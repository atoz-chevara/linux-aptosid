commit de9bca6377e18d3a41cc19d5b2ef118934702b33
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 10:23:40 2010 -0700

    Staging: brcm80211: include: s/uint8/u8/
    
    Replace uint8 with u8, the correct kernel type to be using here.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/include/bcm_rpc_tp.h
+++ b/drivers/staging/brcm80211/include/bcm_rpc_tp.h
@@ -106,16 +106,16 @@ extern void bcm_rpc_tp_txflowctl(rpc_tp_
 extern void bcm_rpc_tp_txflowctlcb_init(rpc_tp_info_t *rpc_th, void *ctx,
 					rpc_txflowctl_cb_t cb);
 extern void bcm_rpc_tp_txflowctlcb_deinit(rpc_tp_info_t *rpc_th);
-extern void bcm_rpc_tp_txq_wm_set(rpc_tp_info_t *rpc_th, uint8 hiwm,
-				  uint8 lowm);
-extern void bcm_rpc_tp_txq_wm_get(rpc_tp_info_t *rpc_th, uint8 *hiwm,
-				  uint8 *lowm);
+extern void bcm_rpc_tp_txq_wm_set(rpc_tp_info_t *rpc_th, u8 hiwm,
+				  u8 lowm);
+extern void bcm_rpc_tp_txq_wm_get(rpc_tp_info_t *rpc_th, u8 *hiwm,
+				  u8 *lowm);
 #endif				/* WLC_LOW */
 
 extern void bcm_rpc_tp_agg_set(rpc_tp_info_t *rpcb, uint32 reason, bool set);
-extern void bcm_rpc_tp_agg_limit_set(rpc_tp_info_t *rpc_th, uint8 sf,
+extern void bcm_rpc_tp_agg_limit_set(rpc_tp_info_t *rpc_th, u8 sf,
 				     uint16 bytes);
-extern void bcm_rpc_tp_agg_limit_get(rpc_tp_info_t *rpc_th, uint8 *sf,
+extern void bcm_rpc_tp_agg_limit_get(rpc_tp_info_t *rpc_th, u8 *sf,
 				     uint16 *bytes);
 
 #define BCM_RPC_TP_MSG_LEVEL_MASK	0x00ff
@@ -131,7 +131,7 @@ extern void bcm_rpc_tp_agg_limit_get(rpc
 #define RPC_TP_MSG_HOST_AGG_VAL		0x0004	/* DNGL TP agg msg */
 #define RPC_TP_MSG_HOST_DEA_VAL		0x0008	/* DNGL TP deag msg */
 
-extern void bcm_rpc_tp_msglevel_set(rpc_tp_info_t *rpc_th, uint8 msglevel,
+extern void bcm_rpc_tp_msglevel_set(rpc_tp_info_t *rpc_th, u8 msglevel,
 				    bool high_low);
 
 #endif				/* _bcm_rpc_tp_h_ */
--- a/drivers/staging/brcm80211/include/bcm_xdr.h
+++ b/drivers/staging/brcm80211/include/bcm_xdr.h
@@ -25,9 +25,9 @@
  *
  */
 typedef struct {
-	uint8 *buf;		/* pointer to current position in origbuf */
+	u8 *buf;		/* pointer to current position in origbuf */
 	uint size;		/* current (residual) size in bytes */
-	uint8 *origbuf;		/* unmodified pointer to orignal buffer */
+	u8 *origbuf;		/* unmodified pointer to orignal buffer */
 	uint origsize;		/* unmodified orignal buffer size in bytes */
 } bcm_xdr_buf_t;
 
@@ -47,8 +47,8 @@ int bcm_xdr_unpack_opaque_varlen(bcm_xdr
 int bcm_xdr_pack_string(bcm_xdr_buf_t *b, char *str);
 int bcm_xdr_unpack_string(bcm_xdr_buf_t *b, uint *plen, char **pstr);
 
-int bcm_xdr_pack_uint8_vec(bcm_xdr_buf_t *, uint8 *vec, uint32 elems);
-int bcm_xdr_unpack_uint8_vec(bcm_xdr_buf_t *, uint8 *vec, uint32 elems);
+int bcm_xdr_pack_u8_vec(bcm_xdr_buf_t *, u8 *vec, uint32 elems);
+int bcm_xdr_unpack_u8_vec(bcm_xdr_buf_t *, u8 *vec, uint32 elems);
 int bcm_xdr_pack_uint16_vec(bcm_xdr_buf_t *b, uint len, void *vec);
 int bcm_xdr_unpack_uint16_vec(bcm_xdr_buf_t *b, uint len, void *vec);
 int bcm_xdr_pack_uint32_vec(bcm_xdr_buf_t *b, uint len, void *vec);
--- a/drivers/staging/brcm80211/include/bcmcdc.h
+++ b/drivers/staging/brcm80211/include/bcmcdc.h
@@ -90,9 +90,9 @@ typedef struct cdc_ioctl {
 	((idx) << BDC_FLAG2_IF_SHIFT)))
 
 struct bdc_header {
-	uint8 flags;		/* Flags */
-	uint8 priority;		/* 802.1d Priority 0:2 bits, 4:7 flow
+	u8 flags;		/* Flags */
+	u8 priority;		/* 802.1d Priority 0:2 bits, 4:7 flow
 				 control info for usb */
-	uint8 flags2;
-	uint8 rssi;
+	u8 flags2;
+	u8 rssi;
 };
--- a/drivers/staging/brcm80211/include/bcmendian.h
+++ b/drivers/staging/brcm80211/include/bcmendian.h
@@ -105,16 +105,16 @@
 #define _NTOH32_UA(cp)	(((cp)[0] << 24) | ((cp)[1] << 16) | ((cp)[2] << 8) | (cp)[3])
 
 #define ltoh_ua(ptr) \
-	(sizeof(*(ptr)) == sizeof(uint8) ? *(const uint8 *)(ptr) : \
-	 sizeof(*(ptr)) == sizeof(uint16) ? _LTOH16_UA((const uint8 *)(ptr)) : \
-	 sizeof(*(ptr)) == sizeof(uint32) ? _LTOH32_UA((const uint8 *)(ptr)) : \
-	 *(uint8 *)0)
+	(sizeof(*(ptr)) == sizeof(u8) ? *(const u8 *)(ptr) : \
+	 sizeof(*(ptr)) == sizeof(uint16) ? _LTOH16_UA((const u8 *)(ptr)) : \
+	 sizeof(*(ptr)) == sizeof(uint32) ? _LTOH32_UA((const u8 *)(ptr)) : \
+	 *(u8 *)0)
 
 #define ntoh_ua(ptr) \
-	(sizeof(*(ptr)) == sizeof(uint8) ? *(const uint8 *)(ptr) : \
-	 sizeof(*(ptr)) == sizeof(uint16) ? _NTOH16_UA((const uint8 *)(ptr)) : \
-	 sizeof(*(ptr)) == sizeof(uint32) ? _NTOH32_UA((const uint8 *)(ptr)) : \
-	 *(uint8 *)0)
+	(sizeof(*(ptr)) == sizeof(u8) ? *(const u8 *)(ptr) : \
+	 sizeof(*(ptr)) == sizeof(uint16) ? _NTOH16_UA((const u8 *)(ptr)) : \
+	 sizeof(*(ptr)) == sizeof(uint32) ? _NTOH32_UA((const u8 *)(ptr)) : \
+	 *(u8 *)0)
 
 #ifdef __GNUC__
 
@@ -148,14 +148,14 @@
 
 #define htol16_ua_store(val, bytes) ({ \
 	uint16 _val = (val); \
-	uint8 *_bytes = (uint8 *)(bytes); \
+	u8 *_bytes = (u8 *)(bytes); \
 	_bytes[0] = _val & 0xff; \
 	_bytes[1] = _val >> 8; \
 })
 
 #define htol32_ua_store(val, bytes) ({ \
 	uint32 _val = (val); \
-	uint8 *_bytes = (uint8 *)(bytes); \
+	u8 *_bytes = (u8 *)(bytes); \
 	_bytes[0] = _val & 0xff; \
 	_bytes[1] = (_val >> 8) & 0xff; \
 	_bytes[2] = (_val >> 16) & 0xff; \
@@ -164,14 +164,14 @@
 
 #define hton16_ua_store(val, bytes) ({ \
 	uint16 _val = (val); \
-	uint8 *_bytes = (uint8 *)(bytes); \
+	u8 *_bytes = (u8 *)(bytes); \
 	_bytes[0] = _val >> 8; \
 	_bytes[1] = _val & 0xff; \
 })
 
 #define hton32_ua_store(val, bytes) ({ \
 	uint32 _val = (val); \
-	uint8 *_bytes = (uint8 *)(bytes); \
+	u8 *_bytes = (u8 *)(bytes); \
 	_bytes[0] = _val >> 24; \
 	_bytes[1] = (_val >> 16) & 0xff; \
 	_bytes[2] = (_val >> 8) & 0xff; \
@@ -179,22 +179,22 @@
 })
 
 #define ltoh16_ua(bytes) ({ \
-	const uint8 *_bytes = (const uint8 *)(bytes); \
+	const u8 *_bytes = (const u8 *)(bytes); \
 	_LTOH16_UA(_bytes); \
 })
 
 #define ltoh32_ua(bytes) ({ \
-	const uint8 *_bytes = (const uint8 *)(bytes); \
+	const u8 *_bytes = (const u8 *)(bytes); \
 	_LTOH32_UA(_bytes); \
 })
 
 #define ntoh16_ua(bytes) ({ \
-	const uint8 *_bytes = (const uint8 *)(bytes); \
+	const u8 *_bytes = (const u8 *)(bytes); \
 	_NTOH16_UA(_bytes); \
 })
 
 #define ntoh32_ua(bytes) ({ \
-	const uint8 *_bytes = (const uint8 *)(bytes); \
+	const u8 *_bytes = (const u8 *)(bytes); \
 	_NTOH32_UA(_bytes); \
 })
 
@@ -232,7 +232,7 @@ static inline void bcmswap16_buf(uint16
 /*
  * Store 16-bit value to unaligned little-endian byte array.
  */
-static inline void htol16_ua_store(uint16 val, uint8 *bytes)
+static inline void htol16_ua_store(uint16 val, u8 *bytes)
 {
 	bytes[0] = val & 0xff;
 	bytes[1] = val >> 8;
@@ -241,7 +241,7 @@ static inline void htol16_ua_store(uint1
 /*
  * Store 32-bit value to unaligned little-endian byte array.
  */
-static inline void htol32_ua_store(uint32 val, uint8 *bytes)
+static inline void htol32_ua_store(uint32 val, u8 *bytes)
 {
 	bytes[0] = val & 0xff;
 	bytes[1] = (val >> 8) & 0xff;
@@ -252,7 +252,7 @@ static inline void htol32_ua_store(uint3
 /*
  * Store 16-bit value to unaligned network-(big-)endian byte array.
  */
-static inline void hton16_ua_store(uint16 val, uint8 *bytes)
+static inline void hton16_ua_store(uint16 val, u8 *bytes)
 {
 	bytes[0] = val >> 8;
 	bytes[1] = val & 0xff;
@@ -261,7 +261,7 @@ static inline void hton16_ua_store(uint1
 /*
  * Store 32-bit value to unaligned network-(big-)endian byte array.
  */
-static inline void hton32_ua_store(uint32 val, uint8 *bytes)
+static inline void hton32_ua_store(uint32 val, u8 *bytes)
 {
 	bytes[0] = val >> 24;
 	bytes[1] = (val >> 16) & 0xff;
@@ -274,7 +274,7 @@ static inline void hton32_ua_store(uint3
  */
 static inline uint16 ltoh16_ua(const void *bytes)
 {
-	return _LTOH16_UA((const uint8 *)bytes);
+	return _LTOH16_UA((const u8 *)bytes);
 }
 
 /*
@@ -282,7 +282,7 @@ static inline uint16 ltoh16_ua(const voi
  */
 static inline uint32 ltoh32_ua(const void *bytes)
 {
-	return _LTOH32_UA((const uint8 *)bytes);
+	return _LTOH32_UA((const u8 *)bytes);
 }
 
 /*
@@ -290,7 +290,7 @@ static inline uint32 ltoh32_ua(const voi
  */
 static inline uint16 ntoh16_ua(const void *bytes)
 {
-	return _NTOH16_UA((const uint8 *)bytes);
+	return _NTOH16_UA((const u8 *)bytes);
 }
 
 /*
@@ -298,7 +298,7 @@ static inline uint16 ntoh16_ua(const voi
  */
 static inline uint32 ntoh32_ua(const void *bytes)
 {
-	return _NTOH32_UA((const uint8 *)bytes);
+	return _NTOH32_UA((const u8 *)bytes);
 }
 
 #endif				/* !__GNUC__ */
--- a/drivers/staging/brcm80211/include/bcmnvram.h
+++ b/drivers/staging/brcm80211/include/bcmnvram.h
@@ -150,7 +150,7 @@ extern int nvram_getall(char *nvram_buf,
  * returns the crc value of the nvram
  * @param	nvh	nvram header pointer
  */
-uint8 nvram_calc_crc(struct nvram_header *nvh);
+u8 nvram_calc_crc(struct nvram_header *nvh);
 
 #endif				/* _LANGUAGE_ASSEMBLY */
 
--- a/drivers/staging/brcm80211/include/bcmsdbus.h
+++ b/drivers/staging/brcm80211/include/bcmsdbus.h
@@ -67,7 +67,7 @@ extern int sdioh_release_host_and_unlock
 
 /* read or write one byte using cmd52 */
 extern SDIOH_API_RC sdioh_request_byte(sdioh_info_t *si, uint rw, uint fnc,
-				       uint addr, uint8 *byte);
+				       uint addr, u8 *byte);
 
 /* read or write 2/4 bytes using cmd53 */
 extern SDIOH_API_RC sdioh_request_word(sdioh_info_t *si, uint cmd_type,
@@ -78,17 +78,17 @@ extern SDIOH_API_RC sdioh_request_word(s
 extern SDIOH_API_RC sdioh_request_buffer(sdioh_info_t *si, uint pio_dma,
 					 uint fix_inc, uint rw, uint fnc_num,
 					 uint32 addr, uint regwidth,
-					 uint32 buflen, uint8 *buffer,
+					 uint32 buflen, u8 *buffer,
 					 void *pkt);
 
 /* get cis data */
-extern SDIOH_API_RC sdioh_cis_read(sdioh_info_t *si, uint fuc, uint8 *cis,
+extern SDIOH_API_RC sdioh_cis_read(sdioh_info_t *si, uint fuc, u8 *cis,
 				   uint32 length);
 
 extern SDIOH_API_RC sdioh_cfg_read(sdioh_info_t *si, uint fuc, uint32 addr,
-				   uint8 *data);
+				   u8 *data);
 extern SDIOH_API_RC sdioh_cfg_write(sdioh_info_t *si, uint fuc, uint32 addr,
-				    uint8 *data);
+				    u8 *data);
 
 /* query number of io functions */
 extern uint sdioh_query_iofnum(sdioh_info_t *si);
--- a/drivers/staging/brcm80211/include/bcmsdh.h
+++ b/drivers/staging/brcm80211/include/bcmsdh.h
@@ -75,8 +75,8 @@ extern int bcmsdh_devremove_reg(void *sd
  *   data: data byte to write
  *   err:  pointer to error code (or NULL)
  */
-extern uint8 bcmsdh_cfg_read(void *sdh, uint func, uint32 addr, int *err);
-extern void bcmsdh_cfg_write(void *sdh, uint func, uint32 addr, uint8 data,
+extern u8 bcmsdh_cfg_read(void *sdh, uint func, uint32 addr, int *err);
+extern void bcmsdh_cfg_write(void *sdh, uint func, uint32 addr, u8 data,
 			     int *err);
 
 /* Read/Write 4bytes from/to cfg space */
@@ -92,7 +92,7 @@ extern void bcmsdh_cfg_write_word(void *
  * Internally, this routine uses the values from the cis base regs (0x9-0xB)
  * to form an SDIO-space address to read the data from.
  */
-extern int bcmsdh_cis_read(void *sdh, uint func, uint8 *cis, uint length);
+extern int bcmsdh_cis_read(void *sdh, uint func, u8 *cis, uint length);
 
 /* Synchronous access to device (client) core registers via CMD53 to F1.
  *   addr: backplane address (i.e. >= regsva from attach)
@@ -119,10 +119,10 @@ extern bool bcmsdh_regfail(void *sdh);
  */
 typedef void (*bcmsdh_cmplt_fn_t) (void *handle, int status, bool sync_waiting);
 extern int bcmsdh_send_buf(void *sdh, uint32 addr, uint fn, uint flags,
-			   uint8 *buf, uint nbytes, void *pkt,
+			   u8 *buf, uint nbytes, void *pkt,
 			   bcmsdh_cmplt_fn_t complete, void *handle);
 extern int bcmsdh_recv_buf(void *sdh, uint32 addr, uint fn, uint flags,
-			   uint8 *buf, uint nbytes, void *pkt,
+			   u8 *buf, uint nbytes, void *pkt,
 			   bcmsdh_cmplt_fn_t complete, void *handle);
 
 /* Flags bits */
@@ -140,7 +140,7 @@ extern int bcmsdh_recv_buf(void *sdh, ui
  *   nbytes:   number of bytes to transfer to/from buf
  * Returns 0 or error code.
  */
-extern int bcmsdh_rwdata(void *sdh, uint rw, uint32 addr, uint8 *buf,
+extern int bcmsdh_rwdata(void *sdh, uint rw, uint32 addr, u8 *buf,
 			 uint nbytes);
 
 /* Issue an abort to the specified function */
--- a/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
+++ b/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
@@ -67,7 +67,7 @@ struct sdioh_info {
 	bool use_client_ints;	/* If this is false, make sure to restore */
 	int sd_mode;		/* SD1/SD4/SPI */
 	int client_block_size[SDIOD_MAX_IOFUNCS];	/* Blocksize */
-	uint8 num_funcs;	/* Supported funcs on client */
+	u8 num_funcs;	/* Supported funcs on client */
 	uint32 com_cis_ptr;
 	uint32 func_cis_ptr[SDIOD_MAX_IOFUNCS];
 	uint max_dma_len;
--- a/drivers/staging/brcm80211/include/bcmsdpcm.h
+++ b/drivers/staging/brcm80211/include/bcmsdpcm.h
@@ -80,36 +80,36 @@
 
 /* SW frame header */
 #define SDPCM_SEQUENCE_MASK		0x000000ff	/* Sequence Number Mask */
-#define SDPCM_PACKET_SEQUENCE(p) (((uint8 *)p)[0] & 0xff)	/* p starts w/SW Header */
+#define SDPCM_PACKET_SEQUENCE(p) (((u8 *)p)[0] & 0xff)	/* p starts w/SW Header */
 
 #define SDPCM_CHANNEL_MASK		0x00000f00	/* Channel Number Mask */
 #define SDPCM_CHANNEL_SHIFT		8	/* Channel Number Shift */
-#define SDPCM_PACKET_CHANNEL(p) (((uint8 *)p)[1] & 0x0f)	/* p starts w/SW Header */
+#define SDPCM_PACKET_CHANNEL(p) (((u8 *)p)[1] & 0x0f)	/* p starts w/SW Header */
 
 #define SDPCM_FLAGS_MASK		0x0000f000	/* Mask of flag bits */
 #define SDPCM_FLAGS_SHIFT		12	/* Flag bits shift */
-#define SDPCM_PACKET_FLAGS(p) ((((uint8 *)p)[1] & 0xf0) >> 4)	/* p starts w/SW Header */
+#define SDPCM_PACKET_FLAGS(p) ((((u8 *)p)[1] & 0xf0) >> 4)	/* p starts w/SW Header */
 
 /* Next Read Len: lookahead length of next frame, in 16-byte units (rounded up) */
 #define SDPCM_NEXTLEN_MASK		0x00ff0000	/* Next Read Len Mask */
 #define SDPCM_NEXTLEN_SHIFT		16	/* Next Read Len Shift */
-#define SDPCM_NEXTLEN_VALUE(p) ((((uint8 *)p)[2] & 0xff) << 4)	/* p starts w/SW Header */
+#define SDPCM_NEXTLEN_VALUE(p) ((((u8 *)p)[2] & 0xff) << 4)	/* p starts w/SW Header */
 #define SDPCM_NEXTLEN_OFFSET		2
 
 /* Data Offset from SOF (HW Tag, SW Tag, Pad) */
 #define SDPCM_DOFFSET_OFFSET		3	/* Data Offset */
-#define SDPCM_DOFFSET_VALUE(p) 		(((uint8 *)p)[SDPCM_DOFFSET_OFFSET] & 0xff)
+#define SDPCM_DOFFSET_VALUE(p) 		(((u8 *)p)[SDPCM_DOFFSET_OFFSET] & 0xff)
 #define SDPCM_DOFFSET_MASK		0xff000000
 #define SDPCM_DOFFSET_SHIFT		24
 
 #define SDPCM_FCMASK_OFFSET		4	/* Flow control */
-#define SDPCM_FCMASK_VALUE(p)		(((uint8 *)p)[SDPCM_FCMASK_OFFSET] & 0xff)
+#define SDPCM_FCMASK_VALUE(p)		(((u8 *)p)[SDPCM_FCMASK_OFFSET] & 0xff)
 #define SDPCM_WINDOW_OFFSET		5	/* Credit based fc */
-#define SDPCM_WINDOW_VALUE(p)		(((uint8 *)p)[SDPCM_WINDOW_OFFSET] & 0xff)
+#define SDPCM_WINDOW_VALUE(p)		(((u8 *)p)[SDPCM_WINDOW_OFFSET] & 0xff)
 #define SDPCM_VERSION_OFFSET		6	/* Version # */
-#define SDPCM_VERSION_VALUE(p)		(((uint8 *)p)[SDPCM_VERSION_OFFSET] & 0xff)
+#define SDPCM_VERSION_VALUE(p)		(((u8 *)p)[SDPCM_VERSION_OFFSET] & 0xff)
 #define SDPCM_UNUSED_OFFSET		7	/* Spare */
-#define SDPCM_UNUSED_VALUE(p)		(((uint8 *)p)[SDPCM_UNUSED_OFFSET] & 0xff)
+#define SDPCM_UNUSED_VALUE(p)		(((u8 *)p)[SDPCM_UNUSED_OFFSET] & 0xff)
 
 #define SDPCM_SWHEADER_LEN	8	/* SW header is 64 bits */
 
@@ -131,7 +131,7 @@
 /* For GLOM_CHANNEL frames, use a flag to indicate descriptor frame */
 #define SDPCM_GLOMDESC_FLAG	(SDPCM_FLAG_GLOMDESC << SDPCM_FLAGS_SHIFT)
 
-#define SDPCM_GLOMDESC(p)	(((uint8 *)p)[1] & 0x80)
+#define SDPCM_GLOMDESC(p)	(((u8 *)p)[1] & 0x80)
 
 /* For TEST_CHANNEL packets, define another 4-byte header */
 #define SDPCM_TEST_HDRLEN	4	/* Generally: Cmd(1), Ext(1), Len(2);
@@ -146,7 +146,7 @@
 #define SDPCM_TEST_SEND		0x05	/* Receiver sets send mode. Ext is boolean on/off */
 
 /* Handy macro for filling in datagen packets with a pattern */
-#define SDPCM_TEST_FILL(byteno, id)	((uint8)(id + byteno))
+#define SDPCM_TEST_FILL(byteno, id)	((u8)(id + byteno))
 
 /*
  * Software counters (first part matches hardware counters)
--- a/drivers/staging/brcm80211/include/bcmsrom.h
+++ b/drivers/staging/brcm80211/include/bcmsrom.h
@@ -29,6 +29,6 @@ extern int srom_read(si_t *sih, uint bus
 /* parse standard PCMCIA cis, normally used by SB/PCMCIA/SDIO/SPI/OTP
  *   and extract from it into name=value pairs
  */
-extern int srom_parsecis(osl_t *osh, uint8 **pcis, uint ciscnt,
+extern int srom_parsecis(osl_t *osh, u8 **pcis, uint ciscnt,
 			 char **vars, uint *count);
 #endif				/* _bcmsrom_h_ */
--- a/drivers/staging/brcm80211/include/bcmsrom_fmt.h
+++ b/drivers/staging/brcm80211/include/bcmsrom_fmt.h
@@ -357,11 +357,11 @@
 #define SROM9_REV_CRC		219
 
 typedef struct {
-	uint8 tssipos;		/* TSSI positive slope, 1: positive, 0: negative */
-	uint8 extpagain;	/* Ext PA gain-type: full-gain: 0, pa-lite: 1, no_pa: 2 */
-	uint8 pdetrange;	/* support 32 combinations of different Pdet dynamic ranges */
-	uint8 triso;		/* TR switch isolation */
-	uint8 antswctrllut;	/* antswctrl lookup table configuration: 32 possible choices */
+	u8 tssipos;		/* TSSI positive slope, 1: positive, 0: negative */
+	u8 extpagain;	/* Ext PA gain-type: full-gain: 0, pa-lite: 1, no_pa: 2 */
+	u8 pdetrange;	/* support 32 combinations of different Pdet dynamic ranges */
+	u8 triso;		/* TR switch isolation */
+	u8 antswctrllut;	/* antswctrl lookup table configuration: 32 possible choices */
 } srom_fem_t;
 
 #endif				/* _bcmsrom_fmt_h_ */
--- a/drivers/staging/brcm80211/include/bcmsrom_tbl.h
+++ b/drivers/staging/brcm80211/include/bcmsrom_tbl.h
@@ -499,8 +499,8 @@ static const povars_t povars[] = {
 };
 
 typedef struct {
-	uint8 tag;		/* Broadcom subtag name */
-	uint8 len;		/* Length field of the tuple, note that it includes the
+	u8 tag;		/* Broadcom subtag name */
+	u8 len;		/* Length field of the tuple, note that it includes the
 				 * subtag name (1 byte): 1 + tuple content length
 				 */
 	const char *params;
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -231,7 +231,7 @@ extern "C" {
 /* variable access */
 	extern char *getvar(char *vars, const char *name);
 	extern int getintvar(char *vars, const char *name);
-	extern int getintvararray(char *vars, const char *name, uint8 index);
+	extern int getintvararray(char *vars, const char *name, u8 index);
 	extern uint getgpiopin(char *vars, char *pin_name, uint def_pin);
 #ifdef BCMDBG
 	extern void prpkt(const char *msg, osl_t *osh, void *p0);
@@ -305,7 +305,7 @@ extern "C" {
 	"void", \
 	"bool", \
 	"int8", \
-	"uint8", \
+	"u8", \
 	"int16", \
 	"uint16", \
 	"int32", \
@@ -458,10 +458,10 @@ extern "C" {
 #ifndef NBBY			/* the BSD family defines NBBY */
 #define	NBBY	8		/* 8 bits per byte */
 #endif				/* #ifndef NBBY */
-#define	setbit(a, i)	(((uint8 *)a)[(i)/NBBY] |= 1<<((i)%NBBY))
-#define	clrbit(a, i)	(((uint8 *)a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
-#define	isset(a, i)	(((const uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY)))
-#define	isclr(a, i)	((((const uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+#define	setbit(a, i)	(((u8 *)a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a, i)	(((u8 *)a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a, i)	(((const u8 *)a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a, i)	((((const u8 *)a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
 #endif				/* setbit */
 
 #define	NBITS(type)	(sizeof(type) * 8)
@@ -505,9 +505,9 @@ extern "C" {
 
 /* tag_ID/length/value_buffer tuple */
 	typedef struct bcm_tlv {
-		uint8 id;
-		uint8 len;
-		uint8 data[1];
+		u8 id;
+		u8 len;
+		u8 data[1];
 	} bcm_tlv_t;
 
 /* Check that bcm_tlv_t fits into the given buflen */
@@ -519,7 +519,7 @@ extern "C" {
 /* crypto utility function */
 /* 128-bit xor: *dst = *src1 xor *src2. dst1, src1 and src2 may have any alignment */
 	static inline void
-	 xor_128bit_block(const uint8 *src1, const uint8 *src2, uint8 *dst) {
+	 xor_128bit_block(const u8 *src1, const u8 *src2, u8 *dst) {
 		if (
 #ifdef __i386__
 			   1 ||
@@ -550,8 +550,8 @@ extern "C" {
 
 /* externs */
 /* crc */
-	extern uint8 BCMROMFN(hndcrc8) (uint8 *p, uint nbytes, uint8 crc);
-	extern uint16 BCMROMFN(hndcrc16) (uint8 *p, uint nbytes, uint16 crc);
+	extern u8 BCMROMFN(hndcrc8) (u8 *p, uint nbytes, u8 crc);
+	extern uint16 BCMROMFN(hndcrc16) (u8 *p, uint nbytes, uint16 crc);
 /* format/print */
 #if defined(BCMDBG)
 	extern int bcm_format_flags(const bcm_bit_desc_t *bd, uint32 flags,
@@ -586,8 +586,8 @@ extern "C" {
 #define	mboolmaskset(mb, mask, val)	((mb) = (((mb) & ~(mask)) | (val)))
 
 /* power conversion */
-	extern uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 qdbm);
-	extern uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw);
+	extern uint16 BCMROMFN(bcm_qdbm_to_mw) (u8 qdbm);
+	extern u8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw);
 
 /* generic datastruct to help dump routines */
 	struct fielddesc {
@@ -598,8 +598,8 @@ extern "C" {
 
 	extern void bcm_binit(struct bcmstrbuf *b, char *buf, uint size);
 	extern int bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...);
-	extern void bcm_inc_bytes(uchar *num, int num_bytes, uint8 amount);
-	extern int bcm_cmp_bytes(uchar *arg1, uchar *arg2, uint8 nbytes);
+	extern void bcm_inc_bytes(uchar *num, int num_bytes, u8 amount);
+	extern int bcm_cmp_bytes(uchar *arg1, uchar *arg2, u8 nbytes);
 	extern void bcm_print_bytes(char *name, const uchar *cdata, int len);
 
 	typedef uint32(*bcmutl_rdreg_rtn) (void *arg0, uint arg1,
@@ -610,7 +610,7 @@ extern "C" {
 
 	extern uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf,
 				uint len);
-	extern uint BCMROMFN(bcm_bitcount) (uint8 *bitmap, uint bytelength);
+	extern uint BCMROMFN(bcm_bitcount) (u8 *bitmap, uint bytelength);
 
 #ifdef __cplusplus
 }
--- a/drivers/staging/brcm80211/include/bcmwifi.h
+++ b/drivers/staging/brcm80211/include/bcmwifi.h
@@ -31,7 +31,7 @@ typedef uint16 chanspec_t;
 #define WLC_MAX_2G_CHANNEL		CH_MAX_2G_CHANNEL	/* legacy define */
 #define	MAXCHANNEL		224	/* max # supported channels. The max channel no is 216,
 					 * this is that + 1 rounded up to a multiple of NBBY (8).
-					 * DO NOT MAKE it > 255: channels are uint8's all over
+					 * DO NOT MAKE it > 255: channels are u8's all over
 					 */
 
 #define WL_CHANSPEC_CHAN_MASK		0x00ff
@@ -74,7 +74,7 @@ typedef uint16 chanspec_t;
 					((channel) | (ctlsb) | WL_CHANSPEC_BW_40 | \
 					((channel) <= CH_MAX_2G_CHANNEL ? WL_CHANSPEC_BAND_2G : \
 					WL_CHANSPEC_BAND_5G))
-#define CHSPEC_CHANNEL(chspec)	((uint8)((chspec) & WL_CHANSPEC_CHAN_MASK))
+#define CHSPEC_CHANNEL(chspec)	((u8)((chspec) & WL_CHANSPEC_CHAN_MASK))
 #define CHSPEC_BAND(chspec)	((chspec) & WL_CHANSPEC_BAND_MASK)
 
 #ifdef WL11N_20MHZONLY
@@ -156,7 +156,7 @@ extern bool wf_chspec_malformed(chanspec
  * channels this is just the channel number, for 40MHZ channels it is the upper or lowre 20MHZ
  * sideband depending on the chanspec selected
  */
-extern uint8 wf_chspec_ctlchan(chanspec_t chspec);
+extern u8 wf_chspec_ctlchan(chanspec_t chspec);
 
 /*
  * This function returns the chanspec that control traffic is being sent on, for legacy
--- a/drivers/staging/brcm80211/include/bcmwpa.h
+++ b/drivers/staging/brcm80211/include/bcmwpa.h
@@ -75,11 +75,11 @@
 			WPA_CIPHER_NONE)
 
 /* Look for a WPA IE; return it's address if found, NULL otherwise */
-extern wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (uint8 *parse, uint len);
+extern wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (u8 *parse, uint len);
 
 /* Check whether the given IE looks like WFA IE with the specific type. */
-extern bool bcm_is_wfa_ie(uint8 *ie, uint8 **tlvs, uint *tlvs_len,
-			  uint8 type);
+extern bool bcm_is_wfa_ie(u8 *ie, u8 **tlvs, uint *tlvs_len,
+			  u8 type);
 /* Check whether pointed-to IE looks like WPA. */
 #define bcm_is_wpa_ie(ie, tlvs, len)	bcm_is_wfa_ie(ie, tlvs, len, WFA_OUI_TYPE_WPA)
 
--- a/drivers/staging/brcm80211/include/d11.h
+++ b/drivers/staging/brcm80211/include/d11.h
@@ -633,9 +633,9 @@ typedef volatile struct _d11regs {
 /* 802.11a PLCP header def */
 typedef struct ofdm_phy_hdr ofdm_phy_hdr_t;
 BWL_PRE_PACKED_STRUCT struct ofdm_phy_hdr {
-	uint8 rlpt[3];		/* rate, length, parity, tail */
+	u8 rlpt[3];		/* rate, length, parity, tail */
 	uint16 service;
-	uint8 pad;
+	u8 pad;
 } BWL_POST_PACKED_STRUCT;
 
 #define	D11A_PHY_HDR_GRATE(phdr)	((phdr)->rlpt[0] & 0x0f)
@@ -668,8 +668,8 @@ BWL_PRE_PACKED_STRUCT struct ofdm_phy_hd
 /* 802.11b PLCP header def */
 typedef struct cck_phy_hdr cck_phy_hdr_t;
 BWL_PRE_PACKED_STRUCT struct cck_phy_hdr {
-	uint8 signal;
-	uint8 service;
+	u8 signal;
+	u8 service;
 	uint16 length;
 	uint16 crc;
 } BWL_POST_PACKED_STRUCT;
@@ -725,12 +725,12 @@ BWL_PRE_PACKED_STRUCT struct d11txh {
 	uint16 PhyTxControlWord_1_FbrRts;	/* 0x8 */
 	uint16 MainRates;	/* 0x9 */
 	uint16 XtraFrameTypes;	/* 0xa */
-	uint8 IV[16];		/* 0x0b - 0x12 */
-	uint8 TxFrameRA[6];	/* 0x13 - 0x15 */
+	u8 IV[16];		/* 0x0b - 0x12 */
+	u8 TxFrameRA[6];	/* 0x13 - 0x15 */
 	uint16 TxFesTimeFallback;	/* 0x16 */
-	uint8 RTSPLCPFallback[6];	/* 0x17 - 0x19 */
+	u8 RTSPLCPFallback[6];	/* 0x17 - 0x19 */
 	uint16 RTSDurFallback;	/* 0x1a */
-	uint8 FragPLCPFallback[6];	/* 0x1b - 1d */
+	u8 FragPLCPFallback[6];	/* 0x1b - 1d */
 	uint16 FragDurFallback;	/* 0x1e */
 	uint16 MModeLen;	/* 0x1f */
 	uint16 MModeFbrLen;	/* 0x20 */
@@ -745,7 +745,7 @@ BWL_PRE_PACKED_STRUCT struct d11txh {
 	uint16 MaxABytes_MRT;	/* 0x29 corerev >=16 */
 	uint16 MaxABytes_FBR;	/* 0x2a corerev >=16 */
 	uint16 MinMBytes;	/* 0x2b corerev >=16 */
-	uint8 RTSPhyHeader[D11_PHY_HDR_LEN];	/* 0x2c - 0x2e */
+	u8 RTSPhyHeader[D11_PHY_HDR_LEN];	/* 0x2c - 0x2e */
 	struct dot11_rts_frame rts_frame;	/* 0x2f - 0x36 */
 	uint16 PAD;		/* 0x37 */
 } BWL_POST_PACKED_STRUCT;
--- a/drivers/staging/brcm80211/include/dbus.h
+++ b/drivers/staging/brcm80211/include/dbus.h
@@ -135,7 +135,7 @@ typedef void *(*exec_cb_t) (struct exec_
 /* Client callbacks registered during dbus_attach() */
 typedef struct dbus_callbacks {
 	void (*send_complete) (void *cbarg, void *info, int status);
-	void (*recv_buf) (void *cbarg, uint8 *buf, int len);
+	void (*recv_buf) (void *cbarg, u8 *buf, int len);
 	void (*recv_pkt) (void *cbarg, void *pkt);
 	void (*txflowcontrol) (void *cbarg, bool onoff);
 	void (*errhandler) (void *cbarg, int err);
@@ -162,8 +162,8 @@ typedef struct {
 	int (*send_irb) (void *bus, struct dbus_irb_tx *txirb);
 	int (*recv_irb) (void *bus, struct dbus_irb_rx *rxirb);
 	int (*cancel_irb) (void *bus, struct dbus_irb_tx *txirb);
-	int (*send_ctl) (void *bus, uint8 *buf, int len);
-	int (*recv_ctl) (void *bus, uint8 *buf, int len);
+	int (*send_ctl) (void *bus, u8 *buf, int len);
+	int (*recv_ctl) (void *bus, u8 *buf, int len);
 	int (*get_stats) (void *bus, dbus_stats_t *stats);
 	int (*get_attrib) (void *bus, dbus_attrib_t *attrib);
 
@@ -186,7 +186,7 @@ typedef struct {
 
 	 bool(*device_exists) (void *bus);
 	 bool(*dlneeded) (void *bus);
-	int (*dlstart) (void *bus, uint8 *fw, int len);
+	int (*dlstart) (void *bus, u8 *fw, int len);
 	int (*dlrun) (void *bus);
 	 bool(*recv_needed) (void *bus);
 
@@ -245,11 +245,11 @@ extern int dbus_stop(const dbus_pub_t *p
 extern int dbus_shutdown(const dbus_pub_t *pub);
 extern void dbus_flowctrl_rx(const dbus_pub_t *pub, bool on);
 
-extern int dbus_send_buf(const dbus_pub_t *pub, uint8 *buf, int len,
+extern int dbus_send_buf(const dbus_pub_t *pub, u8 *buf, int len,
 			 void *info);
 extern int dbus_send_pkt(const dbus_pub_t *pub, void *pkt, void *info);
-extern int dbus_send_ctl(const dbus_pub_t *pub, uint8 *buf, int len);
-extern int dbus_recv_ctl(const dbus_pub_t *pub, uint8 *buf, int len);
+extern int dbus_send_ctl(const dbus_pub_t *pub, u8 *buf, int len);
+extern int dbus_recv_ctl(const dbus_pub_t *pub, u8 *buf, int len);
 
 extern int dbus_get_stats(const dbus_pub_t *pub, dbus_stats_t *stats);
 extern int dbus_get_attrib(const dbus_pub_t *pub, dbus_attrib_t *attrib);
@@ -281,7 +281,7 @@ typedef struct dbus_irb {
 
 typedef struct dbus_irb_rx {
 	struct dbus_irb irb;	/* Must be first */
-	uint8 *buf;
+	u8 *buf;
 	int buf_len;
 	int actual_len;
 	void *pkt;
@@ -291,7 +291,7 @@ typedef struct dbus_irb_rx {
 
 typedef struct dbus_irb_tx {
 	struct dbus_irb irb;	/* Must be first */
-	uint8 *buf;
+	u8 *buf;
 	int len;
 	void *pkt;
 	int retry_count;
--- a/drivers/staging/brcm80211/include/hndpmu.h
+++ b/drivers/staging/brcm80211/include/hndpmu.h
@@ -43,13 +43,13 @@ extern uint32 si_pmu_alp_clock(si_t *sih
 extern uint32 si_pmu_ilp_clock(si_t *sih, osl_t *osh);
 
 extern void si_pmu_set_switcher_voltage(si_t *sih, osl_t *osh,
-					uint8 bb_voltage, uint8 rf_voltage);
-extern void si_pmu_set_ldo_voltage(si_t *sih, osl_t *osh, uint8 ldo,
-				   uint8 voltage);
+					u8 bb_voltage, u8 rf_voltage);
+extern void si_pmu_set_ldo_voltage(si_t *sih, osl_t *osh, u8 ldo,
+				   u8 voltage);
 extern uint16 si_pmu_fast_pwrup_delay(si_t *sih, osl_t *osh);
 extern void si_pmu_rcal(si_t *sih, osl_t *osh);
 extern void si_pmu_pllupd(si_t *sih);
-extern void si_pmu_spuravoid(si_t *sih, osl_t *osh, uint8 spuravoid);
+extern void si_pmu_spuravoid(si_t *sih, osl_t *osh, u8 spuravoid);
 
 extern bool si_pmu_is_otp_powered(si_t *sih, osl_t *osh);
 extern uint32 si_pmu_measure_alpclk(si_t *sih, osl_t *osh);
--- a/drivers/staging/brcm80211/include/linux_osl.h
+++ b/drivers/staging/brcm80211/include/linux_osl.h
@@ -192,7 +192,7 @@ extern int osl_error(int bcmerror);
 #ifndef IL_BIGENDIAN
 #ifndef __mips__
 #define R_REG(osh, r) (\
-	SELECT_BUS_READ(osh, sizeof(*(r)) == sizeof(uint8) ? readb((volatile uint8*)(r)) : \
+	SELECT_BUS_READ(osh, sizeof(*(r)) == sizeof(u8) ? readb((volatile u8*)(r)) : \
 	sizeof(*(r)) == sizeof(uint16) ? readw((volatile uint16*)(r)) : \
 	readl((volatile uint32*)(r)), OSL_READ_REG(osh, r)) \
 )
@@ -203,8 +203,8 @@ extern int osl_error(int bcmerror);
 			__typeof(*(r)) __osl_v; \
 			__asm__ __volatile__("sync"); \
 			switch (sizeof(*(r))) { \
-			case sizeof(uint8): \
-				__osl_v = readb((volatile uint8*)(r)); \
+			case sizeof(u8): \
+				__osl_v = readb((volatile u8*)(r)); \
 				break; \
 			case sizeof(uint16): \
 				__osl_v = readw((volatile uint16*)(r)); \
@@ -230,8 +230,8 @@ extern int osl_error(int bcmerror);
 #define W_REG(osh, r, v) do { \
 	SELECT_BUS_WRITE(osh,  \
 		switch (sizeof(*(r))) { \
-		case sizeof(uint8): \
-			writeb((uint8)(v), (volatile uint8*)(r)); break; \
+		case sizeof(u8): \
+			writeb((u8)(v), (volatile u8*)(r)); break; \
 		case sizeof(uint16): \
 			writew((uint16)(v), (volatile uint16*)(r)); break; \
 		case sizeof(uint32): \
@@ -245,9 +245,9 @@ extern int osl_error(int bcmerror);
 		({ \
 			__typeof(*(r)) __osl_v; \
 			switch (sizeof(*(r))) { \
-			case sizeof(uint8): \
+			case sizeof(u8): \
 				__osl_v = \
-				readb((volatile uint8*)((uintptr)(r)^3)); \
+				readb((volatile u8*)((uintptr)(r)^3)); \
 				break; \
 			case sizeof(uint16): \
 				__osl_v = \
@@ -264,9 +264,9 @@ extern int osl_error(int bcmerror);
 #define W_REG(osh, r, v) do { \
 	SELECT_BUS_WRITE(osh,  \
 		switch (sizeof(*(r))) { \
-		case sizeof(uint8):	\
-			writeb((uint8)(v), \
-			(volatile uint8*)((uintptr)(r)^3)); break; \
+		case sizeof(u8):	\
+			writeb((u8)(v), \
+			(volatile u8*)((uintptr)(r)^3)); break; \
 		case sizeof(uint16):	\
 			writew((uint16)(v), \
 			(volatile uint16*)((uintptr)(r)^2)); break; \
@@ -412,14 +412,14 @@ osl_pkt_tonative(osl_pubinfo_t *osh, voi
 
 #if defined(BCMSDIO) && !defined(BRCM_FULLMAC)
 #define RPC_READ_REG(osh, r) (\
-	sizeof(*(r)) == sizeof(uint8) ? osl_readb((osh), (volatile uint8*)(r)) : \
+	sizeof(*(r)) == sizeof(u8) ? osl_readb((osh), (volatile u8*)(r)) : \
 	sizeof(*(r)) == sizeof(uint16) ? osl_readw((osh), (volatile uint16*)(r)) : \
 	osl_readl((osh), (volatile uint32*)(r)) \
 )
 #define RPC_WRITE_REG(osh, r, v) do { \
 	switch (sizeof(*(r))) { \
-	case sizeof(uint8): \
-		osl_writeb((osh), (volatile uint8*)(r), (uint8)(v)); \
+	case sizeof(u8): \
+		osl_writeb((osh), (volatile u8*)(r), (u8)(v)); \
 		break; \
 	case sizeof(uint16): \
 		osl_writew((osh), (volatile uint16*)(r), (uint16)(v)); \
@@ -430,10 +430,10 @@ osl_pkt_tonative(osl_pubinfo_t *osh, voi
 	} \
 } while (0)
 
-extern uint8 osl_readb(osl_t *osh, volatile uint8 *r);
+extern u8 osl_readb(osl_t *osh, volatile u8 *r);
 extern uint16 osl_readw(osl_t *osh, volatile uint16 *r);
 extern uint32 osl_readl(osl_t *osh, volatile uint32 *r);
-extern void osl_writeb(osl_t *osh, volatile uint8 *r, uint8 v);
+extern void osl_writeb(osl_t *osh, volatile u8 *r, u8 v);
 extern void osl_writew(osl_t *osh, volatile uint16 *r, uint16 v);
 extern void osl_writel(osl_t *osh, volatile uint32 *r, uint32 v);
 #endif				/* BCMSDIO */
--- a/drivers/staging/brcm80211/include/msgtrace.h
+++ b/drivers/staging/brcm80211/include/msgtrace.h
@@ -26,8 +26,8 @@
 
 /* Message trace header */
 typedef BWL_PRE_PACKED_STRUCT struct msgtrace_hdr {
-	uint8 version;
-	uint8 spare;
+	u8 version;
+	u8 spare;
 	uint16 len;		/* Len of the trace */
 	uint32 seqnum;		/* Sequence number of message. Useful
 				 * if the messsage has been lost
@@ -54,8 +54,8 @@ typedef BWL_PRE_PACKED_STRUCT struct msg
  */
 extern bool msgtrace_hbus_trace;
 
-typedef void (*msgtrace_func_send_t) (void *hdl1, void *hdl2, uint8 *hdr,
-				      uint16 hdrlen, uint8 *buf,
+typedef void (*msgtrace_func_send_t) (void *hdl1, void *hdl2, u8 *hdr,
+				      uint16 hdrlen, u8 *buf,
 				      uint16 buflen);
 
 extern void msgtrace_sent(void);
--- a/drivers/staging/brcm80211/include/nicpci.h
+++ b/drivers/staging/brcm80211/include/nicpci.h
@@ -45,14 +45,14 @@
 #else
 struct sbpcieregs;
 
-extern uint8 pcicore_find_pci_capability(osl_t *osh, uint8 req_cap_id,
+extern u8 pcicore_find_pci_capability(osl_t *osh, u8 req_cap_id,
 					 uchar *buf, uint32 *buflen);
 extern uint pcie_readreg(osl_t *osh, struct sbpcieregs *pcieregs,
 			 uint addrtype, uint offset);
 extern uint pcie_writereg(osl_t *osh, struct sbpcieregs *pcieregs,
 			  uint addrtype, uint offset, uint val);
 
-extern uint8 pcie_clkreq(void *pch, uint32 mask, uint32 val);
+extern u8 pcie_clkreq(void *pch, uint32 mask, uint32 val);
 extern uint32 pcie_lcreg(void *pch, uint32 mask, uint32 val);
 
 extern void *pcicore_init(si_t *sih, osl_t *osh, void *regs);
@@ -63,7 +63,7 @@ extern void pcicore_up(void *pch, int st
 extern void pcicore_sleep(void *pch);
 extern void pcicore_down(void *pch, int state);
 
-extern void pcie_war_ovr_aspm_update(void *pch, uint8 aspm);
+extern void pcie_war_ovr_aspm_update(void *pch, u8 aspm);
 extern uint32 pcicore_pcieserdesreg(void *pch, uint32 mdioslave, uint32 offset,
 				    uint32 mask, uint32 val);
 
--- a/drivers/staging/brcm80211/include/pcicfg.h
+++ b/drivers/staging/brcm80211/include/pcicfg.h
@@ -107,25 +107,25 @@ typedef struct _pci_config_regs {
 	uint16 device;
 	uint16 command;
 	uint16 status;
-	uint8 rev_id;
-	uint8 prog_if;
-	uint8 sub_class;
-	uint8 base_class;
-	uint8 cache_line_size;
-	uint8 latency_timer;
-	uint8 header_type;
-	uint8 bist;
+	u8 rev_id;
+	u8 prog_if;
+	u8 sub_class;
+	u8 base_class;
+	u8 cache_line_size;
+	u8 latency_timer;
+	u8 header_type;
+	u8 bist;
 	uint32 base[PCI_BAR_MAX];
 	uint32 cardbus_cis;
 	uint16 subsys_vendor;
 	uint16 subsys_id;
 	uint32 baserom;
 	uint32 rsvd_a[PCR_RSVDA_MAX];
-	uint8 int_line;
-	uint8 int_pin;
-	uint8 min_gnt;
-	uint8 max_lat;
-	uint8 dev_dep[192];
+	u8 int_line;
+	u8 int_pin;
+	u8 min_gnt;
+	u8 max_lat;
+	u8 dev_dep[192];
 } pci_config_regs;
 
 #define	SZPCR		(sizeof (pci_config_regs))
@@ -335,21 +335,21 @@ typedef struct _ppb_config_regs {
 	uint16 device;
 	uint16 command;
 	uint16 status;
-	uint8 rev_id;
-	uint8 prog_if;
-	uint8 sub_class;
-	uint8 base_class;
-	uint8 cache_line_size;
-	uint8 latency_timer;
-	uint8 header_type;
-	uint8 bist;
+	u8 rev_id;
+	u8 prog_if;
+	u8 sub_class;
+	u8 base_class;
+	u8 cache_line_size;
+	u8 latency_timer;
+	u8 header_type;
+	u8 bist;
 	uint32 rsvd_a[PPB_RSVDA_MAX];
-	uint8 prim_bus;
-	uint8 sec_bus;
-	uint8 sub_bus;
-	uint8 sec_lat;
-	uint8 io_base;
-	uint8 io_lim;
+	u8 prim_bus;
+	u8 sec_bus;
+	u8 sub_bus;
+	u8 sec_lat;
+	u8 io_base;
+	u8 io_lim;
 	uint16 sec_status;
 	uint16 mem_base;
 	uint16 mem_lim;
@@ -362,14 +362,14 @@ typedef struct _ppb_config_regs {
 	uint16 subsys_vendor;
 	uint16 subsys_id;
 	uint32 rsvd_b;
-	uint8 rsvd_c;
-	uint8 int_pin;
+	u8 rsvd_c;
+	u8 int_pin;
 	uint16 bridge_ctrl;
-	uint8 chip_ctrl;
-	uint8 diag_ctrl;
+	u8 chip_ctrl;
+	u8 diag_ctrl;
 	uint16 arb_ctrl;
 	uint32 rsvd_d[PPB_RSVDD_MAX];
-	uint8 dev_dep[192];
+	u8 dev_dep[192];
 } ppb_config_regs;
 
 /* PCI CAPABILITY DEFINES */
@@ -382,8 +382,8 @@ typedef struct _ppb_config_regs {
  * Valid for PCI and PCIE configurations
  */
 typedef struct _pciconfig_cap_msi {
-	uint8 capID;
-	uint8 nextptr;
+	u8 capID;
+	u8 nextptr;
 	uint16 msgctrl;
 	uint32 msgaddr;
 } pciconfig_cap_msi;
@@ -392,12 +392,12 @@ typedef struct _pciconfig_cap_msi {
  * Valid for PCI and PCIE configurations
  */
 typedef struct _pciconfig_cap_pwrmgmt {
-	uint8 capID;
-	uint8 nextptr;
+	u8 capID;
+	u8 nextptr;
 	uint16 pme_cap;
 	uint16 pme_sts_ctrl;
-	uint8 pme_bridge_ext;
-	uint8 data;
+	u8 pme_bridge_ext;
+	u8 data;
 } pciconfig_cap_pwrmgmt;
 
 #define PME_CAP_PM_STATES (0x1f << 27)	/* Bits 31:27 states that can generate PME */
@@ -407,8 +407,8 @@ typedef struct _pciconfig_cap_pwrmgmt {
 
 /* Data structure to define the PCIE capability */
 typedef struct _pciconfig_cap_pcie {
-	uint8 capID;
-	uint8 nextptr;
+	u8 capID;
+	u8 nextptr;
 	uint16 pcie_cap;
 	uint32 dev_cap;
 	uint16 dev_ctrl;
--- a/drivers/staging/brcm80211/include/proto/802.11.h
+++ b/drivers/staging/brcm80211/include/proto/802.11.h
@@ -98,25 +98,25 @@ BWL_PRE_PACKED_STRUCT struct dot11_bcn_p
 #define AC_VO			3
 #define AC_COUNT		4
 
-typedef uint8 ac_bitmap_t;
+typedef u8 ac_bitmap_t;
 
 #define AC_BITMAP_ALL		0xf
 #define AC_BITMAP_TST(ab, ac)	(((ab) & (1 << (ac))) != 0)
 
 BWL_PRE_PACKED_STRUCT struct edcf_acparam {
-	uint8 ACI;
-	uint8 ECW;
+	u8 ACI;
+	u8 ECW;
 	uint16 TXOP;
 } BWL_POST_PACKED_STRUCT;
 typedef struct edcf_acparam edcf_acparam_t;
 
 BWL_PRE_PACKED_STRUCT struct wme_param_ie {
-	uint8 oui[3];
-	uint8 type;
-	uint8 subtype;
-	uint8 version;
-	uint8 qosinfo;
-	uint8 rsvd;
+	u8 oui[3];
+	u8 type;
+	u8 subtype;
+	u8 version;
+	u8 qosinfo;
+	u8 rsvd;
 	edcf_acparam_t acparam[AC_COUNT];
 } BWL_POST_PACKED_STRUCT;
 typedef struct wme_param_ie wme_param_ie_t;
@@ -256,11 +256,11 @@ typedef struct d11cnt {
 
 BWL_PRE_PACKED_STRUCT struct ht_cap_ie {
 	uint16 cap;
-	uint8 params;
-	uint8 supp_mcs[MCSSET_LEN];
+	u8 params;
+	u8 supp_mcs[MCSSET_LEN];
 	uint16 ext_htcap;
 	uint32 txbf_cap;
-	uint8 as_cap;
+	u8 as_cap;
 } BWL_POST_PACKED_STRUCT;
 typedef struct ht_cap_ie ht_cap_ie_t;
 
--- a/drivers/staging/brcm80211/include/proto/bcmeth.h
+++ b/drivers/staging/brcm80211/include/proto/bcmeth.h
@@ -39,8 +39,8 @@
 typedef BWL_PRE_PACKED_STRUCT struct bcmeth_hdr {
 	uint16 subtype;
 	uint16 length;
-	uint8 version;
-	uint8 oui[3];
+	u8 version;
+	u8 oui[3];
 	uint16 usr_subtype;
 } BWL_POST_PACKED_STRUCT bcmeth_hdr_t;
 
--- a/drivers/staging/brcm80211/include/proto/bcmevent.h
+++ b/drivers/staging/brcm80211/include/proto/bcmevent.h
@@ -193,11 +193,11 @@ extern const int bcmevent_names_size;
 #define WLC_E_SUP_DEAUTH		14
 
 typedef struct wl_event_data_if {
-	uint8 ifidx;
-	uint8 opcode;
-	uint8 reserved;
-	uint8 bssidx;
-	uint8 role;
+	u8 ifidx;
+	u8 opcode;
+	u8 reserved;
+	u8 bssidx;
+	u8 role;
 } wl_event_data_if_t;
 
 #define WLC_E_IF_ADD		1
--- a/drivers/staging/brcm80211/include/proto/bcmip.h
+++ b/drivers/staging/brcm80211/include/proto/bcmip.h
@@ -27,24 +27,24 @@
 #define IP_VER_6		6
 
 #define IP_VER(ip_body) \
-	((((uint8 *)(ip_body))[IP_VER_OFFSET] & IP_VER_MASK) >> IP_VER_SHIFT)
+	((((u8 *)(ip_body))[IP_VER_OFFSET] & IP_VER_MASK) >> IP_VER_SHIFT)
 
 #define IPV4_TOS_OFFSET		1
 
 #define IPV4_ADDR_LEN		4
 
-#define	IPV4_TOS(ipv4_body)	(((uint8 *)(ipv4_body))[IPV4_TOS_OFFSET])
+#define	IPV4_TOS(ipv4_body)	(((u8 *)(ipv4_body))[IPV4_TOS_OFFSET])
 
 #define	IPV4_TOS_PREC_MASK	0xe0
 #define	IPV4_TOS_PREC_SHIFT	5
 
 BWL_PRE_PACKED_STRUCT struct ipv4_addr {
-	uint8 addr[IPV4_ADDR_LEN];
+	u8 addr[IPV4_ADDR_LEN];
 } BWL_POST_PACKED_STRUCT;
 
 #define IPV6_TRAFFIC_CLASS(ipv6_body) \
-	(((((uint8 *)(ipv6_body))[0] & 0x0f) << 4) | \
-	 ((((uint8 *)(ipv6_body))[1] & 0xf0) >> 4))
+	(((((u8 *)(ipv6_body))[0] & 0x0f) << 4) | \
+	 ((((u8 *)(ipv6_body))[1] & 0xf0) >> 4))
 
 #ifndef IP_TOS
 #define IP_TOS(ip_body) \
--- a/drivers/staging/brcm80211/include/proto/ethernet.h
+++ b/drivers/staging/brcm80211/include/proto/ethernet.h
@@ -45,34 +45,34 @@
 	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
 
 #define ETHER_FILL_MCAST_ADDR_FROM_IP(ea, mgrp_ip) {		\
-		((uint8 *)ea)[0] = 0x01;			\
-		((uint8 *)ea)[1] = 0x00;			\
-		((uint8 *)ea)[2] = 0x5e;			\
-		((uint8 *)ea)[3] = ((mgrp_ip) >> 16) & 0x7f;	\
-		((uint8 *)ea)[4] = ((mgrp_ip) >>  8) & 0xff;	\
-		((uint8 *)ea)[5] = ((mgrp_ip) >>  0) & 0xff;	\
+		((u8 *)ea)[0] = 0x01;			\
+		((u8 *)ea)[1] = 0x00;			\
+		((u8 *)ea)[2] = 0x5e;			\
+		((u8 *)ea)[3] = ((mgrp_ip) >> 16) & 0x7f;	\
+		((u8 *)ea)[4] = ((mgrp_ip) >>  8) & 0xff;	\
+		((u8 *)ea)[5] = ((mgrp_ip) >>  0) & 0xff;	\
 }
 
 BWL_PRE_PACKED_STRUCT struct ether_header {
-	uint8 ether_dhost[ETHER_ADDR_LEN];
-	uint8 ether_shost[ETHER_ADDR_LEN];
+	u8 ether_dhost[ETHER_ADDR_LEN];
+	u8 ether_shost[ETHER_ADDR_LEN];
 	uint16 ether_type;
 } BWL_POST_PACKED_STRUCT;
 
 BWL_PRE_PACKED_STRUCT struct ether_addr {
-	uint8 octet[ETHER_ADDR_LEN];
+	u8 octet[ETHER_ADDR_LEN];
 } BWL_POST_PACKED_STRUCT;
 
-#define ETHER_SET_LOCALADDR(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] | 2))
-#define ETHER_IS_LOCALADDR(ea) 	(((uint8 *)(ea))[0] & 2)
-#define ETHER_CLR_LOCALADDR(ea)	(((uint8 *)(ea))[0] = \
-	(((uint8 *)(ea))[0] & 0xd))
-#define ETHER_TOGGLE_LOCALADDR(ea)	(((uint8 *)(ea))[0] = \
-	(((uint8 *)(ea))[0] ^ 2))
+#define ETHER_SET_LOCALADDR(ea)	(((u8 *)(ea))[0] = (((u8 *)(ea))[0] | 2))
+#define ETHER_IS_LOCALADDR(ea) 	(((u8 *)(ea))[0] & 2)
+#define ETHER_CLR_LOCALADDR(ea)	(((u8 *)(ea))[0] = \
+	(((u8 *)(ea))[0] & 0xd))
+#define ETHER_TOGGLE_LOCALADDR(ea)	(((u8 *)(ea))[0] = \
+	(((u8 *)(ea))[0] ^ 2))
 
-#define ETHER_SET_UNICAST(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] & ~1))
+#define ETHER_SET_UNICAST(ea)	(((u8 *)(ea))[0] = (((u8 *)(ea))[0] & ~1))
 
-#define ETHER_ISMULTI(ea) (((const uint8 *)(ea))[0] & 1)
+#define ETHER_ISMULTI(ea) (((const u8 *)(ea))[0] & 1)
 
 #define	ether_cmp(a, b)	(!(((short *)a)[0] == ((short *)b)[0]) | \
 			 !(((short *)a)[1] == ((short *)b)[1]) | \
@@ -86,18 +86,18 @@ BWL_PRE_PACKED_STRUCT struct ether_addr
 static const struct ether_addr ether_bcast = { {255, 255, 255, 255, 255, 255} };
 static const struct ether_addr ether_null = { {0, 0, 0, 0, 0, 0} };
 
-#define ETHER_ISBCAST(ea)	((((uint8 *)(ea))[0] &		\
-	((uint8 *)(ea))[1] &		\
-	((uint8 *)(ea))[2] &		\
-	((uint8 *)(ea))[3] &		\
-	((uint8 *)(ea))[4] &		\
-	((uint8 *)(ea))[5]) == 0xff)
-#define ETHER_ISNULLADDR(ea)	((((uint8 *)(ea))[0] |		\
-	((uint8 *)(ea))[1] |		\
-	((uint8 *)(ea))[2] |		\
-	((uint8 *)(ea))[3] |		\
-	((uint8 *)(ea))[4] |		\
-	((uint8 *)(ea))[5]) == 0)
+#define ETHER_ISBCAST(ea)	((((u8 *)(ea))[0] &		\
+	((u8 *)(ea))[1] &		\
+	((u8 *)(ea))[2] &		\
+	((u8 *)(ea))[3] &		\
+	((u8 *)(ea))[4] &		\
+	((u8 *)(ea))[5]) == 0xff)
+#define ETHER_ISNULLADDR(ea)	((((u8 *)(ea))[0] |		\
+	((u8 *)(ea))[1] |		\
+	((u8 *)(ea))[2] |		\
+	((u8 *)(ea))[3] |		\
+	((u8 *)(ea))[4] |		\
+	((u8 *)(ea))[5]) == 0)
 
 #define ETHER_MOVE_HDR(d, s) \
 do { \
--- a/drivers/staging/brcm80211/include/proto/vlan.h
+++ b/drivers/staging/brcm80211/include/proto/vlan.h
@@ -32,8 +32,8 @@
 #define VLAN_TPID		0x8100
 
 struct ethervlan_header {
-	uint8 ether_dhost[ETHER_ADDR_LEN];
-	uint8 ether_shost[ETHER_ADDR_LEN];
+	u8 ether_dhost[ETHER_ADDR_LEN];
+	u8 ether_shost[ETHER_ADDR_LEN];
 	uint16 vlan_type;
 	uint16 vlan_tag;
 	uint16 ether_type;
--- a/drivers/staging/brcm80211/include/proto/wpa.h
+++ b/drivers/staging/brcm80211/include/proto/wpa.h
@@ -37,13 +37,13 @@
 #define WPA2_PMKID_LEN	16
 
 typedef BWL_PRE_PACKED_STRUCT struct {
-	uint8 tag;
-	uint8 length;
-	uint8 oui[3];
-	uint8 oui_type;
+	u8 tag;
+	u8 length;
+	u8 oui[3];
+	u8 oui_type;
 	BWL_PRE_PACKED_STRUCT struct {
-		uint8 low;
-		uint8 high;
+		u8 low;
+		u8 high;
 	} BWL_POST_PACKED_STRUCT version;
 } BWL_POST_PACKED_STRUCT wpa_ie_fixed_t;
 #define WPA_IE_OUITYPE_LEN	4
@@ -51,35 +51,35 @@ typedef BWL_PRE_PACKED_STRUCT struct {
 #define WPA_IE_TAG_FIXED_LEN	6
 
 typedef BWL_PRE_PACKED_STRUCT struct {
-	uint8 tag;
-	uint8 length;
+	u8 tag;
+	u8 length;
 	BWL_PRE_PACKED_STRUCT struct {
-		uint8 low;
-		uint8 high;
+		u8 low;
+		u8 high;
 	} BWL_POST_PACKED_STRUCT version;
 } BWL_POST_PACKED_STRUCT wpa_rsn_ie_fixed_t;
 #define WPA_RSN_IE_FIXED_LEN	4
 #define WPA_RSN_IE_TAG_FIXED_LEN	2
-typedef uint8 wpa_pmkid_t[WPA2_PMKID_LEN];
+typedef u8 wpa_pmkid_t[WPA2_PMKID_LEN];
 
 typedef BWL_PRE_PACKED_STRUCT struct {
-	uint8 oui[3];
-	uint8 type;
+	u8 oui[3];
+	u8 type;
 } BWL_POST_PACKED_STRUCT wpa_suite_t, wpa_suite_mcast_t;
 #define WPA_SUITE_LEN	4
 
 typedef BWL_PRE_PACKED_STRUCT struct {
 	BWL_PRE_PACKED_STRUCT struct {
-		uint8 low;
-		uint8 high;
+		u8 low;
+		u8 high;
 	} BWL_POST_PACKED_STRUCT count;
 	wpa_suite_t list[1];
 } BWL_POST_PACKED_STRUCT wpa_suite_ucast_t, wpa_suite_auth_key_mgmt_t;
 #define WPA_IE_SUITE_COUNT_LEN	2
 typedef BWL_PRE_PACKED_STRUCT struct {
 	BWL_PRE_PACKED_STRUCT struct {
-		uint8 low;
-		uint8 high;
+		u8 low;
+		u8 high;
 	} BWL_POST_PACKED_STRUCT count;
 	wpa_pmkid_t list[1];
 } BWL_POST_PACKED_STRUCT wpa_pmkid_list_t;
--- a/drivers/staging/brcm80211/include/sbchipc.h
+++ b/drivers/staging/brcm80211/include/sbchipc.h
@@ -170,24 +170,24 @@ typedef volatile struct {
 	uint32 PAD[70];
 
 	/* UARTs */
-	uint8 uart0data;	/* 0x300 */
-	uint8 uart0imr;
-	uint8 uart0fcr;
-	uint8 uart0lcr;
-	uint8 uart0mcr;
-	uint8 uart0lsr;
-	uint8 uart0msr;
-	uint8 uart0scratch;
-	uint8 PAD[248];		/* corerev >= 1 */
+	u8 uart0data;	/* 0x300 */
+	u8 uart0imr;
+	u8 uart0fcr;
+	u8 uart0lcr;
+	u8 uart0mcr;
+	u8 uart0lsr;
+	u8 uart0msr;
+	u8 uart0scratch;
+	u8 PAD[248];		/* corerev >= 1 */
 
-	uint8 uart1data;	/* 0x400 */
-	uint8 uart1imr;
-	uint8 uart1fcr;
-	uint8 uart1lcr;
-	uint8 uart1mcr;
-	uint8 uart1lsr;
-	uint8 uart1msr;
-	uint8 uart1scratch;
+	u8 uart1data;	/* 0x400 */
+	u8 uart1imr;
+	u8 uart1fcr;
+	u8 uart1lcr;
+	u8 uart1mcr;
+	u8 uart1lsr;
+	u8 uart1msr;
+	u8 uart1scratch;
 	uint32 PAD[126];
 
 	/* PMU registers (corerev >= 20) */
--- a/drivers/staging/brcm80211/include/sbsdpcmdev.h
+++ b/drivers/staging/brcm80211/include/sbsdpcmdev.h
@@ -87,10 +87,10 @@ typedef volatile struct {
 	uint32 PAD[3];
 
 	/* PCMCIA frame control */
-	uint8 pcmciaframectrl;	/* pcmciaFrameCtrl, 0x060, rev8   */
-	uint8 PAD[3];
-	uint8 pcmciawatermark;	/* pcmciaWaterMark, 0x064, rev8   */
-	uint8 PAD[155];
+	u8 pcmciaframectrl;	/* pcmciaFrameCtrl, 0x060, rev8   */
+	u8 PAD[3];
+	u8 pcmciawatermark;	/* pcmciaWaterMark, 0x064, rev8   */
+	u8 PAD[155];
 
 	/* interrupt batching control */
 	uint32 intrcvlazy;	/* IntRcvLazy, 0x100, rev8 */
--- a/drivers/staging/brcm80211/include/sdio.h
+++ b/drivers/staging/brcm80211/include/sdio.h
@@ -21,31 +21,31 @@
 
 /* CCCR structure for function 0 */
 typedef volatile struct {
-	uint8 cccr_sdio_rev;	/* RO, cccr and sdio revision */
-	uint8 sd_rev;		/* RO, sd spec revision */
-	uint8 io_en;		/* I/O enable */
-	uint8 io_rdy;		/* I/O ready reg */
-	uint8 intr_ctl;		/* Master and per function interrupt enable control */
-	uint8 intr_status;	/* RO, interrupt pending status */
-	uint8 io_abort;		/* read/write abort or reset all functions */
-	uint8 bus_inter;	/* bus interface control */
-	uint8 capability;	/* RO, card capability */
-
-	uint8 cis_base_low;	/* 0x9 RO, common CIS base address, LSB */
-	uint8 cis_base_mid;
-	uint8 cis_base_high;	/* 0xB RO, common CIS base address, MSB */
+	u8 cccr_sdio_rev;	/* RO, cccr and sdio revision */
+	u8 sd_rev;		/* RO, sd spec revision */
+	u8 io_en;		/* I/O enable */
+	u8 io_rdy;		/* I/O ready reg */
+	u8 intr_ctl;		/* Master and per function interrupt enable control */
+	u8 intr_status;	/* RO, interrupt pending status */
+	u8 io_abort;		/* read/write abort or reset all functions */
+	u8 bus_inter;	/* bus interface control */
+	u8 capability;	/* RO, card capability */
+
+	u8 cis_base_low;	/* 0x9 RO, common CIS base address, LSB */
+	u8 cis_base_mid;
+	u8 cis_base_high;	/* 0xB RO, common CIS base address, MSB */
 
 	/* suspend/resume registers */
-	uint8 bus_suspend;	/* 0xC */
-	uint8 func_select;	/* 0xD */
-	uint8 exec_flag;	/* 0xE */
-	uint8 ready_flag;	/* 0xF */
+	u8 bus_suspend;	/* 0xC */
+	u8 func_select;	/* 0xD */
+	u8 exec_flag;	/* 0xE */
+	u8 ready_flag;	/* 0xF */
 
-	uint8 fn0_blk_size[2];	/* 0x10(LSB), 0x11(MSB) */
+	u8 fn0_blk_size[2];	/* 0x10(LSB), 0x11(MSB) */
 
-	uint8 power_control;	/* 0x12 (SDIO version 1.10) */
+	u8 power_control;	/* 0x12 (SDIO version 1.10) */
 
-	uint8 speed_control;	/* 0x13 */
+	u8 speed_control;	/* 0x13 */
 } sdio_regs_t;
 
 /* SDIO Device CCCR offsets */
@@ -134,20 +134,20 @@ typedef volatile struct {
 
 /* FBR structure for function 1-7, FBR addresses and register offsets */
 typedef volatile struct {
-	uint8 devctr;		/* device interface, CSA control */
-	uint8 ext_dev;		/* extended standard I/O device type code */
-	uint8 pwr_sel;		/* power selection support */
-	uint8 PAD[6];		/* reserved */
-
-	uint8 cis_low;		/* CIS LSB */
-	uint8 cis_mid;
-	uint8 cis_high;		/* CIS MSB */
-	uint8 csa_low;		/* code storage area, LSB */
-	uint8 csa_mid;
-	uint8 csa_high;		/* code storage area, MSB */
-	uint8 csa_dat_win;	/* data access window to function */
+	u8 devctr;		/* device interface, CSA control */
+	u8 ext_dev;		/* extended standard I/O device type code */
+	u8 pwr_sel;		/* power selection support */
+	u8 PAD[6];		/* reserved */
+
+	u8 cis_low;		/* CIS LSB */
+	u8 cis_mid;
+	u8 cis_high;		/* CIS MSB */
+	u8 csa_low;		/* code storage area, LSB */
+	u8 csa_mid;
+	u8 csa_high;		/* code storage area, MSB */
+	u8 csa_dat_win;	/* data access window to function */
 
-	uint8 fnx_blk_size[2];	/* block size, little endian */
+	u8 fnx_blk_size[2];	/* block size, little endian */
 } sdio_fbr_t;
 
 /* Maximum number of I/O funcs */
--- a/drivers/staging/brcm80211/include/siutils.h
+++ b/drivers/staging/brcm80211/include/siutils.h
@@ -185,25 +185,25 @@ extern uint32 si_gpiotimerval(si_t *sih,
 extern bool si_deviceremoved(si_t *sih);
 extern uint32 si_socram_size(si_t *sih);
 extern uint32 si_socdevram_size(si_t *sih);
-extern void si_socdevram(si_t *sih, bool set, uint8 *ennable,
-			 uint8 *protect);
+extern void si_socdevram(si_t *sih, bool set, u8 *ennable,
+			 u8 *protect);
 extern bool si_socdevram_pkg(si_t *sih);
 
 extern void si_watchdog(si_t *sih, uint ticks);
 extern void si_watchdog_ms(si_t *sih, uint32 ms);
 extern void *si_gpiosetcore(si_t *sih);
 extern uint32 si_gpiocontrol(si_t *sih, uint32 mask, uint32 val,
-			     uint8 priority);
-extern uint32 si_gpioouten(si_t *sih, uint32 mask, uint32 val, uint8 priority);
-extern uint32 si_gpioout(si_t *sih, uint32 mask, uint32 val, uint8 priority);
+			     u8 priority);
+extern uint32 si_gpioouten(si_t *sih, uint32 mask, uint32 val, u8 priority);
+extern uint32 si_gpioout(si_t *sih, uint32 mask, uint32 val, u8 priority);
 extern uint32 si_gpioin(si_t *sih);
 extern uint32 si_gpiointpolarity(si_t *sih, uint32 mask, uint32 val,
-				 uint8 priority);
+				 u8 priority);
 extern uint32 si_gpiointmask(si_t *sih, uint32 mask, uint32 val,
-			     uint8 priority);
+			     u8 priority);
 extern uint32 si_gpioled(si_t *sih, uint32 mask, uint32 val);
-extern uint32 si_gpioreserve(si_t *sih, uint32 gpio_num, uint8 priority);
-extern uint32 si_gpiorelease(si_t *sih, uint32 gpio_num, uint8 priority);
+extern uint32 si_gpioreserve(si_t *sih, uint32 gpio_num, u8 priority);
+extern uint32 si_gpiorelease(si_t *sih, uint32 gpio_num, u8 priority);
 extern uint32 si_gpiopull(si_t *sih, bool updown, uint32 mask, uint32 val);
 extern uint32 si_gpioevent(si_t *sih, uint regtype, uint32 mask, uint32 val);
 extern uint32 si_gpio_int_enable(si_t *sih, bool enable);
@@ -233,7 +233,7 @@ extern uint16 si_d11_devid(si_t *sih);
 #define si_eci_init(sih) (0)
 #define si_eci_notify_bt(sih, type, val)  (0)
 #define si_seci(sih) 0
-static inline void *si_seci_init(si_t *sih, uint8 use_seci)
+static inline void *si_seci_init(si_t *sih, u8 use_seci)
 {
 	return NULL;
 }
@@ -394,13 +394,13 @@ extern int si_devpath(si_t *sih, char *p
 extern char *si_getdevpathvar(si_t *sih, const char *name);
 extern int si_getdevpathintvar(si_t *sih, const char *name);
 
-extern uint8 si_pcieclkreq(si_t *sih, uint32 mask, uint32 val);
+extern u8 si_pcieclkreq(si_t *sih, uint32 mask, uint32 val);
 extern uint32 si_pcielcreg(si_t *sih, uint32 mask, uint32 val);
 extern void si_war42780_clkreq(si_t *sih, bool clkreq);
 extern void si_pci_sleep(si_t *sih);
 extern void si_pci_down(si_t *sih);
 extern void si_pci_up(si_t *sih);
-extern void si_pcie_war_ovr_update(si_t *sih, uint8 aspm);
+extern void si_pcie_war_ovr_update(si_t *sih, u8 aspm);
 extern void si_pcie_extendL1timer(si_t *sih, bool extend);
 extern int si_pci_fixcfg(si_t *sih);
 extern void si_chippkg_set(si_t *sih, uint);
--- a/drivers/staging/brcm80211/include/spid.h
+++ b/drivers/staging/brcm80211/include/spid.h
@@ -23,12 +23,12 @@
  */
 
 typedef volatile struct {
-	uint8 config;		/* 0x00, len, endian, clock, speed, polarity, wakeup */
-	uint8 response_delay;	/* 0x01, read response delay in bytes (corerev < 3) */
-	uint8 status_enable;	/* 0x02, status-enable, intr with status, response_delay
+	u8 config;		/* 0x00, len, endian, clock, speed, polarity, wakeup */
+	u8 response_delay;	/* 0x01, read response delay in bytes (corerev < 3) */
+	u8 status_enable;	/* 0x02, status-enable, intr with status, response_delay
 				 * function selection, command/data error check
 				 */
-	uint8 reset_bp;		/* 0x03, reset on wlan/bt backplane reset (corerev >= 1) */
+	u8 reset_bp;		/* 0x03, reset on wlan/bt backplane reset (corerev >= 1) */
 	uint16 intr_reg;	/* 0x04, Intr status register */
 	uint16 intr_en_reg;	/* 0x06, Intr mask register */
 	uint32 status_reg;	/* 0x08, RO, Status bits of last spi transfer */
@@ -37,10 +37,10 @@ typedef volatile struct {
 	uint16 f3_info_reg;	/* 0x10, RO, enabled, ready for data transfer, blocksize */
 	uint32 test_read;	/* 0x14, RO 0xfeedbead signature */
 	uint32 test_rw;		/* 0x18, RW */
-	uint8 resp_delay_f0;	/* 0x1c, read resp delay bytes for F0 (corerev >= 3) */
-	uint8 resp_delay_f1;	/* 0x1d, read resp delay bytes for F1 (corerev >= 3) */
-	uint8 resp_delay_f2;	/* 0x1e, read resp delay bytes for F2 (corerev >= 3) */
-	uint8 resp_delay_f3;	/* 0x1f, read resp delay bytes for F3 (corerev >= 3) */
+	u8 resp_delay_f0;	/* 0x1c, read resp delay bytes for F0 (corerev >= 3) */
+	u8 resp_delay_f1;	/* 0x1d, read resp delay bytes for F1 (corerev >= 3) */
+	u8 resp_delay_f2;	/* 0x1e, read resp delay bytes for F2 (corerev >= 3) */
+	u8 resp_delay_f3;	/* 0x1f, read resp delay bytes for F3 (corerev >= 3) */
 } spi_regs_t;
 
 /* SPI device register offsets */
--- a/drivers/staging/brcm80211/include/wlioctl.h
+++ b/drivers/staging/brcm80211/include/wlioctl.h
@@ -46,15 +46,15 @@ typedef struct wl_bss_info_107 {
 	struct ether_addr BSSID;
 	uint16 beacon_period;	/* units are Kusec */
 	uint16 capability;	/* Capability information */
-	uint8 SSID_len;
-	uint8 SSID[32];
+	u8 SSID_len;
+	u8 SSID[32];
 	struct {
 		uint count;	/* # rates in this set */
-		uint8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
+		u8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
 	} rateset;		/* supported rates */
-	uint8 channel;		/* Channel no. */
+	u8 channel;		/* Channel no. */
 	uint16 atim_window;	/* units are Kusec */
-	uint8 dtim_period;	/* DTIM period */
+	u8 dtim_period;	/* DTIM period */
 	int16 RSSI;		/* receive signal strength (in dBm) */
 	int8 phy_noise;		/* noise (in dBm) */
 	uint32 ie_length;	/* byte length of Information Elements */
@@ -79,25 +79,25 @@ typedef struct wl_bss_info_108 {
 	struct ether_addr BSSID;
 	uint16 beacon_period;	/* units are Kusec */
 	uint16 capability;	/* Capability information */
-	uint8 SSID_len;
-	uint8 SSID[32];
+	u8 SSID_len;
+	u8 SSID[32];
 	struct {
 		uint count;	/* # rates in this set */
-		uint8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
+		u8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
 	} rateset;		/* supported rates */
 	chanspec_t chanspec;	/* chanspec for bss */
 	uint16 atim_window;	/* units are Kusec */
-	uint8 dtim_period;	/* DTIM period */
+	u8 dtim_period;	/* DTIM period */
 	int16 RSSI;		/* receive signal strength (in dBm) */
 	int8 phy_noise;		/* noise (in dBm) */
 
-	uint8 n_cap;		/* BSS is 802.11N Capable */
+	u8 n_cap;		/* BSS is 802.11N Capable */
 	uint32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
-	uint8 ctl_ch;		/* 802.11N BSS control channel number */
+	u8 ctl_ch;		/* 802.11N BSS control channel number */
 	uint32 reserved32[1];	/* Reserved for expansion of BSS properties */
-	uint8 flags;		/* flags */
-	uint8 reserved[3];	/* Reserved for expansion of BSS properties */
-	uint8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
+	u8 flags;		/* flags */
+	u8 reserved[3];	/* Reserved for expansion of BSS properties */
+	u8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
 
 	uint16 ie_offset;	/* offset at which IEs start, from beginning */
 	uint32 ie_length;	/* byte length of Information Elements */
@@ -123,25 +123,25 @@ typedef struct wl_bss_info {
 	struct ether_addr BSSID;
 	uint16 beacon_period;	/* units are Kusec */
 	uint16 capability;	/* Capability information */
-	uint8 SSID_len;
-	uint8 SSID[32];
+	u8 SSID_len;
+	u8 SSID[32];
 	struct {
 		uint count;	/* # rates in this set */
-		uint8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
+		u8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
 	} rateset;		/* supported rates */
 	chanspec_t chanspec;	/* chanspec for bss */
 	uint16 atim_window;	/* units are Kusec */
-	uint8 dtim_period;	/* DTIM period */
+	u8 dtim_period;	/* DTIM period */
 	int16 RSSI;		/* receive signal strength (in dBm) */
 	int8 phy_noise;		/* noise (in dBm) */
 
-	uint8 n_cap;		/* BSS is 802.11N Capable */
+	u8 n_cap;		/* BSS is 802.11N Capable */
 	uint32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
-	uint8 ctl_ch;		/* 802.11N BSS control channel number */
+	u8 ctl_ch;		/* 802.11N BSS control channel number */
 	uint32 reserved32[1];	/* Reserved for expansion of BSS properties */
-	uint8 flags;		/* flags */
-	uint8 reserved[3];	/* Reserved for expansion of BSS properties */
-	uint8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
+	u8 flags;		/* flags */
+	u8 reserved[3];	/* Reserved for expansion of BSS properties */
+	u8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
 
 	uint16 ie_offset;	/* offset at which IEs start, from beginning */
 	uint32 ie_length;	/* byte length of Information Elements */
@@ -156,8 +156,8 @@ typedef struct wlc_ssid {
 } wlc_ssid_t;
 
 typedef struct chan_scandata {
-	uint8 txpower;
-	uint8 pad;
+	u8 txpower;
+	u8 pad;
 	chanspec_t channel;	/* Channel num, bw, ctrl_sb and band */
 	uint32 channel_mintime;
 	uint32 channel_maxtime;
@@ -204,7 +204,7 @@ typedef struct wl_scan_params {
 	int8 bss_type;		/* default: any,
 				 * DOT11_BSSTYPE_ANY/INFRASTRUCTURE/INDEPENDENT
 				 */
-	uint8 scan_type;	/* flags, 0 use default */
+	u8 scan_type;	/* flags, 0 use default */
 	int32 nprobes;		/* -1 use default, number of probes per channel */
 	int32 active_time;	/* -1 use default, dwell time per channel for
 				 * active scanning
@@ -313,13 +313,13 @@ typedef struct wl_probe_params {
 #define WL_NUMRATES		16	/* max # of rates in a rateset */
 typedef struct wl_rateset {
 	uint32 count;		/* # rates in this set */
-	uint8 rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
+	u8 rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
 } wl_rateset_t;
 
 typedef struct wl_rateset_args {
 	uint32 count;		/* # rates in this set */
-	uint8 rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
-	uint8 mcs[MCSSET_LEN];	/* supported mcs index bit map */
+	u8 rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
+	u8 mcs[MCSSET_LEN];	/* supported mcs index bit map */
 } wl_rateset_args_t;
 
 /* uint32 list */
@@ -386,8 +386,8 @@ typedef struct wl_join_params {
 #define MAX_STREAMS_SUPPORTED	4	/* max number of streams supported */
 
 typedef struct {
-	uint8 ant_config[ANT_SELCFG_MAX];	/* antenna configuration */
-	uint8 num_antcfg;	/* number of available antenna configurations */
+	u8 ant_config[ANT_SELCFG_MAX];	/* antenna configuration */
+	u8 num_antcfg;	/* number of available antenna configurations */
 } wlc_antselcfg_t;
 
 #define HIGHEST_SINGLE_STREAM_MCS	7	/* MCS values greater than this enable multiple streams */
@@ -425,7 +425,7 @@ typedef struct {
 
 typedef struct {
 	chanspec_t chanspec;	/* Which channel? */
-	uint8 num_secs;		/* How many secs worth of data */
+	u8 num_secs;		/* How many secs worth of data */
 	cca_congest_t secs[1];	/* Data */
 } cca_congest_channel_req_t;
 
@@ -501,13 +501,13 @@ typedef struct wl_rm_rep_elt {
 	uint32 tsf_l;		/* TSF low 32-bits */
 	uint32 dur;		/* TUs */
 	uint32 len;		/* byte length of data block */
-	uint8 data[1];		/* variable length data block */
+	u8 data[1];		/* variable length data block */
 } wl_rm_rep_elt_t;
 #define WL_RM_REP_ELT_FIXED_LEN	24	/* length excluding data block */
 
 #define WL_RPI_REP_BIN_NUM 8
 typedef struct wl_rm_rpi_rep {
-	uint8 rpi[WL_RPI_REP_BIN_NUM];
+	u8 rpi[WL_RPI_REP_BIN_NUM];
 	int8 rpi_max[WL_RPI_REP_BIN_NUM];
 } wl_rm_rpi_rep_t;
 
@@ -541,7 +541,7 @@ typedef struct wl_rm_rep {
 typedef struct wl_wsec_key {
 	uint32 index;		/* key index */
 	uint32 len;		/* key length */
-	uint8 data[DOT11_MAX_KEY_SIZE];	/* key data */
+	u8 data[DOT11_MAX_KEY_SIZE];	/* key data */
 	uint32 pad_1[18];
 	uint32 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
 	uint32 flags;		/* misc flags */
@@ -568,7 +568,7 @@ typedef struct wl_wsec_key {
 typedef struct {
 	ushort key_len;		/* octets in key material */
 	ushort flags;		/* key handling qualification */
-	uint8 key[WSEC_MAX_PSK_LEN];	/* PMK material */
+	u8 key[WSEC_MAX_PSK_LEN];	/* PMK material */
 } wsec_pmk_t;
 
 /* wireless security bitvec */
@@ -598,7 +598,7 @@ typedef struct {
 
 typedef struct _pmkid {
 	struct ether_addr BSSID;
-	uint8 PMKID[WPA2_PMKID_LEN];
+	u8 PMKID[WPA2_PMKID_LEN];
 } pmkid_t;
 
 typedef struct _pmkid_list {
@@ -608,7 +608,7 @@ typedef struct _pmkid_list {
 
 typedef struct _pmkid_cand {
 	struct ether_addr BSSID;
-	uint8 preauth;
+	u8 preauth;
 } pmkid_cand_t;
 
 typedef struct _pmkid_cand_list {
@@ -619,7 +619,7 @@ typedef struct _pmkid_cand_list {
 typedef struct wl_led_info {
 	uint32 index;		/* led index */
 	uint32 behavior;
-	uint8 activehi;
+	u8 activehi;
 } wl_led_info_t;
 
 /* flags */
@@ -669,10 +669,10 @@ typedef struct {
 
 /* Per-AC retry parameters */
 struct wme_tx_params_s {
-	uint8 short_retry;
-	uint8 short_fallback;
-	uint8 long_retry;
-	uint8 long_fallback;
+	u8 short_retry;
+	u8 short_fallback;
+	u8 long_retry;
+	u8 long_fallback;
 	uint16 max_rate;	/* In units of 512 Kbps */
 };
 
@@ -694,7 +694,7 @@ typedef struct wme_tx_params_s wme_tx_pa
 /* Used to get specific link/ac parameters */
 typedef struct {
 	int ac;
-	uint8 val;
+	u8 val;
 	struct ether_addr ea;
 } link_val_t;
 
@@ -776,7 +776,7 @@ typedef struct wl_ioctl {
 	uint cmd;		/* common ioctl definition */
 	void *buf;		/* pointer to user buffer */
 	uint len;		/* length of user buffer */
-	uint8 set;		/* get or set request (optional) */
+	u8 set;		/* get or set request (optional) */
 	uint used;		/* bytes read or written (optional) */
 	uint needed;		/* bytes needed (optional) */
 } wl_ioctl_t;
@@ -830,8 +830,8 @@ typedef struct wl_txfifo_sz {
 /* Max supported IOV name size in bytes, + 1 for nul termination */
 #define WLC_IOV_NAME_LEN 30
 typedef struct wlc_iov_trx_s {
-	uint8 module;
-	uint8 type;
+	u8 module;
+	u8 type;
 	char name[WLC_IOV_NAME_LEN];
 } wlc_iov_trx_t;
 
@@ -1379,19 +1379,19 @@ typedef struct {
 #define NUM_PWRCTRL_RATES 12
 
 typedef struct {
-	uint8 txpwr_band_max[NUM_PWRCTRL_RATES];	/* User set target */
-	uint8 txpwr_limit[NUM_PWRCTRL_RATES];	/* reg and local power limit */
-	uint8 txpwr_local_max;	/* local max according to the AP */
-	uint8 txpwr_local_constraint;	/* local constraint according to the AP */
-	uint8 txpwr_chan_reg_max;	/* Regulatory max for this channel */
-	uint8 txpwr_target[2][NUM_PWRCTRL_RATES];	/* Latest target for 2.4 and 5 Ghz */
-	uint8 txpwr_est_Pout[2];	/* Latest estimate for 2.4 and 5 Ghz */
-	uint8 txpwr_opo[NUM_PWRCTRL_RATES];	/* On G phy, OFDM power offset */
-	uint8 txpwr_bphy_cck_max[NUM_PWRCTRL_RATES];	/* Max CCK power for this band (SROM) */
-	uint8 txpwr_bphy_ofdm_max;	/* Max OFDM power for this band (SROM) */
-	uint8 txpwr_aphy_max[NUM_PWRCTRL_RATES];	/* Max power for A band (SROM) */
+	u8 txpwr_band_max[NUM_PWRCTRL_RATES];	/* User set target */
+	u8 txpwr_limit[NUM_PWRCTRL_RATES];	/* reg and local power limit */
+	u8 txpwr_local_max;	/* local max according to the AP */
+	u8 txpwr_local_constraint;	/* local constraint according to the AP */
+	u8 txpwr_chan_reg_max;	/* Regulatory max for this channel */
+	u8 txpwr_target[2][NUM_PWRCTRL_RATES];	/* Latest target for 2.4 and 5 Ghz */
+	u8 txpwr_est_Pout[2];	/* Latest estimate for 2.4 and 5 Ghz */
+	u8 txpwr_opo[NUM_PWRCTRL_RATES];	/* On G phy, OFDM power offset */
+	u8 txpwr_bphy_cck_max[NUM_PWRCTRL_RATES];	/* Max CCK power for this band (SROM) */
+	u8 txpwr_bphy_ofdm_max;	/* Max OFDM power for this band (SROM) */
+	u8 txpwr_aphy_max[NUM_PWRCTRL_RATES];	/* Max power for A band (SROM) */
 	int8 txpwr_antgain[2];	/* Ant gain for each band - from SROM */
-	uint8 txpwr_est_Pout_gofdm;	/* Pwr estimate for 2.4 OFDM */
+	u8 txpwr_est_Pout_gofdm;	/* Pwr estimate for 2.4 OFDM */
 } tx_power_legacy_t;
 
 #define WL_TX_POWER_RATES_LEGACY	45
@@ -1404,18 +1404,18 @@ typedef struct {
 	uint32 flags;
 	chanspec_t chanspec;	/* txpwr report for this channel */
 	chanspec_t local_chanspec;	/* channel on which we are associated */
-	uint8 local_max;	/* local max according to the AP */
-	uint8 local_constraint;	/* local constraint according to the AP */
+	u8 local_max;	/* local max according to the AP */
+	u8 local_constraint;	/* local constraint according to the AP */
 	int8 antgain[2];	/* Ant gain for each band - from SROM */
-	uint8 rf_cores;		/* count of RF Cores being reported */
-	uint8 est_Pout[4];	/* Latest tx power out estimate per RF
+	u8 rf_cores;		/* count of RF Cores being reported */
+	u8 est_Pout[4];	/* Latest tx power out estimate per RF
 				 * chain without adjustment
 				 */
-	uint8 est_Pout_cck;	/* Latest CCK tx power out estimate */
-	uint8 user_limit[WL_TX_POWER_RATES_LEGACY];	/* User limit */
-	uint8 reg_limit[WL_TX_POWER_RATES_LEGACY];	/* Regulatory power limit */
-	uint8 board_limit[WL_TX_POWER_RATES_LEGACY];	/* Max power board can support (SROM) */
-	uint8 target[WL_TX_POWER_RATES_LEGACY];	/* Latest target power */
+	u8 est_Pout_cck;	/* Latest CCK tx power out estimate */
+	u8 user_limit[WL_TX_POWER_RATES_LEGACY];	/* User limit */
+	u8 reg_limit[WL_TX_POWER_RATES_LEGACY];	/* Regulatory power limit */
+	u8 board_limit[WL_TX_POWER_RATES_LEGACY];	/* Max power board can support (SROM) */
+	u8 target[WL_TX_POWER_RATES_LEGACY];	/* Latest target power */
 } tx_power_legacy2_t;
 
 #define WL_TX_POWER_RATES	       101
@@ -1452,26 +1452,26 @@ typedef struct {
 	uint32 flags;
 	chanspec_t chanspec;	/* txpwr report for this channel */
 	chanspec_t local_chanspec;	/* channel on which we are associated */
-	uint8 local_max;	/* local max according to the AP */
-	uint8 local_constraint;	/* local constraint according to the AP */
+	u8 local_max;	/* local max according to the AP */
+	u8 local_constraint;	/* local constraint according to the AP */
 	int8 antgain[2];	/* Ant gain for each band - from SROM */
-	uint8 rf_cores;		/* count of RF Cores being reported */
-	uint8 est_Pout[4];	/* Latest tx power out estimate per RF chain */
-	uint8 est_Pout_act[4];	/* Latest tx power out estimate per RF chain
+	u8 rf_cores;		/* count of RF Cores being reported */
+	u8 est_Pout[4];	/* Latest tx power out estimate per RF chain */
+	u8 est_Pout_act[4];	/* Latest tx power out estimate per RF chain
 				 * without adjustment
 				 */
-	uint8 est_Pout_cck;	/* Latest CCK tx power out estimate */
-	uint8 tx_power_max[4];	/* Maximum target power among all rates */
-	uint8 tx_power_max_rate_ind[4];	/* Index of the rate with the max target power */
-	uint8 user_limit[WL_TX_POWER_RATES];	/* User limit */
-	uint8 reg_limit[WL_TX_POWER_RATES];	/* Regulatory power limit */
-	uint8 board_limit[WL_TX_POWER_RATES];	/* Max power board can support (SROM) */
-	uint8 target[WL_TX_POWER_RATES];	/* Latest target power */
+	u8 est_Pout_cck;	/* Latest CCK tx power out estimate */
+	u8 tx_power_max[4];	/* Maximum target power among all rates */
+	u8 tx_power_max_rate_ind[4];	/* Index of the rate with the max target power */
+	u8 user_limit[WL_TX_POWER_RATES];	/* User limit */
+	u8 reg_limit[WL_TX_POWER_RATES];	/* Regulatory power limit */
+	u8 board_limit[WL_TX_POWER_RATES];	/* Max power board can support (SROM) */
+	u8 target[WL_TX_POWER_RATES];	/* Latest target power */
 } tx_power_t;
 
 typedef struct tx_inst_power {
-	uint8 txpwr_est_Pout[2];	/* Latest estimate for 2.4 and 5 Ghz */
-	uint8 txpwr_est_Pout_gofdm;	/* Pwr estimate for 2.4 OFDM */
+	u8 txpwr_est_Pout[2];	/* Latest estimate for 2.4 and 5 Ghz */
+	u8 txpwr_est_Pout_gofdm;	/* Pwr estimate for 2.4 OFDM */
 } tx_inst_power_t;
 
 /* Message levels */
@@ -1485,7 +1485,7 @@ typedef struct tx_inst_power {
 #define WL_NUMCHANSPECS		100
 
 struct tsinfo_arg {
-	uint8 octets[3];
+	u8 octets[3];
 };
 
 #define	NFIFO			6	/* # tx/rx fifopairs */
@@ -1834,19 +1834,19 @@ typedef struct wlc_ba_cnt {
 
 /* structure for per-tid ampdu control */
 struct ampdu_tid_control {
-	uint8 tid;		/* tid */
-	uint8 enable;		/* enable/disable */
+	u8 tid;		/* tid */
+	u8 enable;		/* enable/disable */
 };
 
 /* structure for identifying ea/tid for sending addba/delba */
 struct ampdu_ea_tid {
 	struct ether_addr ea;	/* Station address */
-	uint8 tid;		/* tid */
+	u8 tid;		/* tid */
 };
 /* structure for identifying retry/tid for retry_limit_tid/rr_retry_limit_tid */
 struct ampdu_retry_tid {
-	uint8 tid;		/* tid */
-	uint8 retry;		/* retry value */
+	u8 tid;		/* tid */
+	u8 retry;		/* retry value */
 };
 
 /* structure for addts arguments */
@@ -1878,7 +1878,7 @@ typedef struct tspec_arg {
 	uint min_phy_rate;	/* Minimum PHY Rate (bps) */
 	uint16 surplus_bw;	/* Surplus Bandwidth Allowance (range 1.0 to 8.0) */
 	uint16 medium_time;	/* Medium Time (32 us/s periods) */
-	uint8 dialog_token;	/* dialog token */
+	u8 dialog_token;	/* dialog token */
 } tspec_arg_t;
 
 /* tspec arg for desired station */
@@ -1934,7 +1934,7 @@ typedef struct wl_pkt_filter_pattern {
 				 * Offset '0' is the first byte of the ethernet header.
 				 */
 	uint32 size_bytes;	/* Size of the pattern.  Bitmask must be the same size. */
-	uint8 mask_and_pattern[1];	/* Variable length mask and pattern data.  mask starts
+	u8 mask_and_pattern[1];	/* Variable length mask and pattern data.  mask starts
 					 * at offset 0.  Pattern immediately follows mask.
 					 */
 } wl_pkt_filter_pattern_t;
@@ -1978,7 +1978,7 @@ typedef struct wl_pkteng {
 	uint32 delay;		/* Inter-packet delay */
 	uint32 nframes;		/* Number of frames */
 	uint32 length;		/* Packet length */
-	uint8 seqno;		/* Enable/disable sequence no. */
+	u8 seqno;		/* Enable/disable sequence no. */
 	struct ether_addr dest;	/* Destination address */
 	struct ether_addr src;	/* Source address */
 } wl_pkteng_t;
--- a/drivers/staging/brcm80211/sys/wlc_rpc.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpc.h
@@ -368,49 +368,49 @@ static __inline char *_wlc_rpc_id_lookup
 
 #define wlc_rpc_txpwr_limits(b, txpwr, op, err)	\
 	do {											\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->cck, WLC_NUM_RATES_CCK);		\
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->cck, WLC_NUM_RATES_CCK);		\
 		ASSERT(!(err));									\
 												\
 		/* 20 MHz Legacy OFDM rates with SISO transmission */				\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->ofdm, WLC_NUM_RATES_OFDM);	\
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->ofdm, WLC_NUM_RATES_OFDM);	\
 		ASSERT(!(err));									\
 												\
 		/* 20 MHz Legacy OFDM rates with CDD transmission */				\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->ofdm_cdd, WLC_NUM_RATES_OFDM);   \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->ofdm_cdd, WLC_NUM_RATES_OFDM);   \
 		ASSERT(!(err));									\
 												\
 		/* 40 MHz Legacy OFDM rates with SISO transmission */				\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->ofdm_40_siso, WLC_NUM_RATES_OFDM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->ofdm_40_siso, WLC_NUM_RATES_OFDM); \
 		ASSERT(!(err));									\
 												\
 		/* 40 MHz Legacy OFDM rates with CDD transmission */				\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->ofdm_40_cdd, WLC_NUM_RATES_OFDM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->ofdm_40_cdd, WLC_NUM_RATES_OFDM); \
 		ASSERT(!(err));									\
 												\
 		/* 20MHz MCS rates SISO/CDD/STBC/SDM */							 \
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_20_siso, WLC_NUM_RATES_MCS_1_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_20_siso, WLC_NUM_RATES_MCS_1_STREAM); \
 		ASSERT(!(err));									\
 												\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_20_cdd, WLC_NUM_RATES_MCS_1_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_20_cdd, WLC_NUM_RATES_MCS_1_STREAM); \
 		ASSERT(!(err));									\
 												\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_20_stbc, WLC_NUM_RATES_MCS_1_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_20_stbc, WLC_NUM_RATES_MCS_1_STREAM); \
 		ASSERT(!(err));									\
 												\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_20_mimo, WLC_NUM_RATES_MCS_2_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_20_mimo, WLC_NUM_RATES_MCS_2_STREAM); \
 		ASSERT(!(err));									\
 												\
 		/* 40MHz MCS rates SISO/CDD/STBC/SDM */							 \
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_40_siso, WLC_NUM_RATES_MCS_1_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_40_siso, WLC_NUM_RATES_MCS_1_STREAM); \
 		ASSERT(!(err));									\
 												\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_40_cdd, WLC_NUM_RATES_MCS_1_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_40_cdd, WLC_NUM_RATES_MCS_1_STREAM); \
 		ASSERT(!(err));									\
 												\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_40_stbc, WLC_NUM_RATES_MCS_1_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_40_stbc, WLC_NUM_RATES_MCS_1_STREAM); \
 		ASSERT(!(err));									\
 												\
-		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_40_mimo, WLC_NUM_RATES_MCS_2_STREAM); \
+		(err) = bcm_xdr_##op##_u8_vec((b), (txpwr)->mcs_40_mimo, WLC_NUM_RATES_MCS_2_STREAM); \
 		ASSERT(!(err));									\
 	} while (0)
 

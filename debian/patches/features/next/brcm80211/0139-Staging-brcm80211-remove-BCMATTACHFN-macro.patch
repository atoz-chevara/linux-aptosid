commit 0d2f0724a4b3a5d1631c39b1bbe7c78c4a15a7ac
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 14:28:21 2010 -0700

    Staging: brcm80211: remove BCMATTACHFN macro
    
    It's not doing anything and is a bit silly.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/include/bcmdefs.h
+++ b/drivers/staging/brcm80211/include/bcmdefs.h
@@ -33,13 +33,7 @@
 /* Reclaiming text and data :
  * The following macros specify special linker sections that can be reclaimed
  * after a system is considered 'up'.
- * BCMATTACHFN is also used for detach functions (it's not worth having a BCMDETACHFN,
- * as in most cases, the attach function calls the detach function to clean up on error).
  */
-
-#define bcmreclaimed 		0
-#define BCMATTACHDATA(_data)	_data
-#define BCMATTACHFN(_fn)	_fn
 #define BCMINITDATA(_data)	_data
 #define BCMINITFN(_fn)		_fn
 #define BCMUNINITFN(_fn)	_fn
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -551,7 +551,7 @@ static void WLBANDINITFN(wlc_set_phy_uni
 	}
 }
 
-shared_phy_t *BCMATTACHFN(wlc_phy_shared_attach) (shared_phy_params_t *shp)
+shared_phy_t *wlc_phy_shared_attach(shared_phy_params_t *shp)
 {
 	shared_phy_t *sh;
 
@@ -590,7 +590,7 @@ shared_phy_t *BCMATTACHFN(wlc_phy_shared
 	return sh;
 }
 
-void BCMATTACHFN(wlc_phy_shared_detach) (shared_phy_t *phy_sh)
+void wlc_phy_shared_detach(shared_phy_t *phy_sh)
 {
 	osl_t *osh;
 
@@ -604,8 +604,8 @@ void BCMATTACHFN(wlc_phy_shared_detach)
 	}
 }
 
-wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (shared_phy_t *sh, void *regs,
-					int bandtype, char *vars) {
+wlc_phy_t *wlc_phy_attach(shared_phy_t *sh, void *regs, int bandtype, char *vars)
+{
 	phy_info_t *pi;
 	u32 sflags = 0;
 	uint phyversion;
@@ -786,7 +786,7 @@ wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (
 	return NULL;
 }
 
-void BCMATTACHFN(wlc_phy_detach) (wlc_phy_t *pih)
+void wlc_phy_detach(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -4726,7 +4726,7 @@ static void wlc_lcnphy_rc_cal(phy_info_t
 	return;
 }
 
-static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t *pi)
+static bool wlc_phy_txpwr_srom_read_lcnphy(phy_info_t *pi)
 {
 	s8 txpwr = 0;
 	int i;
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -14505,7 +14505,7 @@ bool wlc_phy_attach_nphy(phy_info_t *pi)
 	return TRUE;
 }
 
-static void BCMATTACHFN(wlc_phy_txpwrctrl_config_nphy) (phy_info_t *pi)
+static void wlc_phy_txpwrctrl_config_nphy(phy_info_t *pi)
 {
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
@@ -27940,7 +27940,7 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 	return;
 }
 
-static void BCMATTACHFN(wlc_phy_txpwr_srom_read_ppr_nphy) (phy_info_t *pi)
+static void wlc_phy_txpwr_srom_read_ppr_nphy(phy_info_t *pi)
 {
 	u16 bw40po, cddpo, stbcpo, bwduppo;
 	uint band_num;
@@ -28148,7 +28148,7 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 	wlc_phy_txpwr_apply_nphy(pi);
 }
 
-static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_nphy) (phy_info_t *pi)
+static bool wlc_phy_txpwr_srom_read_nphy(phy_info_t *pi)
 {
 
 	pi->antswitch = (u8) PHY_GETINTVAR(pi, "antswitch");
--- a/drivers/staging/brcm80211/sys/wlc_alloc.c
+++ b/drivers/staging/brcm80211/sys/wlc_alloc.c
@@ -46,7 +46,7 @@ void *wlc_calloc(osl_t *osh, uint unit,
 	return item;
 }
 
-void BCMATTACHFN(wlc_tunables_init) (wlc_tunables_t *tunables, uint devid)
+void wlc_tunables_init(wlc_tunables_t *tunables, uint devid)
 {
 	tunables->ntxd = NTXD;
 	tunables->nrxd = NRXD;
@@ -69,8 +69,8 @@ void BCMATTACHFN(wlc_tunables_init) (wlc
 #endif				/* WLC_HIGH_ONLY */
 }
 
-static wlc_pub_t *BCMATTACHFN(wlc_pub_malloc) (osl_t *osh, uint unit,
-					       uint *err, uint devid) {
+static wlc_pub_t *wlc_pub_malloc(osl_t *osh, uint unit, uint *err, uint devid)
+{
 	wlc_pub_t *pub;
 
 	pub = (wlc_pub_t *) wlc_calloc(osh, unit, sizeof(wlc_pub_t));
@@ -103,7 +103,7 @@ static wlc_pub_t *BCMATTACHFN(wlc_pub_ma
 	return NULL;
 }
 
-static void BCMATTACHFN(wlc_pub_mfree) (osl_t *osh, wlc_pub_t *pub)
+static void wlc_pub_mfree(osl_t *osh, wlc_pub_t *pub)
 {
 	if (pub == NULL)
 		return;
@@ -173,8 +173,8 @@ void wlc_bsscfg_ID_assign(wlc_info_t *wl
 /*
  * The common driver entry routine. Error codes should be unique
  */
-wlc_info_t *BCMATTACHFN(wlc_attach_malloc) (osl_t *osh, uint unit, uint *err,
-					    uint devid) {
+wlc_info_t *wlc_attach_malloc(osl_t *osh, uint unit, uint *err, uint devid)
+{
 	wlc_info_t *wlc;
 
 	wlc = (wlc_info_t *) wlc_calloc(osh, unit, sizeof(wlc_info_t));
@@ -310,7 +310,7 @@ wlc_info_t *BCMATTACHFN(wlc_attach_mallo
 	return NULL;
 }
 
-void BCMATTACHFN(wlc_detach_mfree) (wlc_info_t *wlc, osl_t *osh)
+void wlc_detach_mfree(wlc_info_t *wlc, osl_t *osh)
 {
 	if (wlc == NULL)
 		return;
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -167,7 +167,7 @@ static inline u16 pkt_txh_seqnum(wlc_inf
 	return ltoh16(h->seq) >> SEQNUM_SHIFT;
 }
 
-ampdu_info_t *BCMATTACHFN(wlc_ampdu_attach) (wlc_info_t *wlc)
+ampdu_info_t *wlc_ampdu_attach(wlc_info_t *wlc)
 {
 	ampdu_info_t *ampdu;
 	int i;
@@ -233,7 +233,7 @@ ampdu_info_t *BCMATTACHFN(wlc_ampdu_atta
 	return ampdu;
 }
 
-void BCMATTACHFN(wlc_ampdu_detach) (ampdu_info_t *ampdu)
+void wlc_ampdu_detach(ampdu_info_t *ampdu)
 {
 	int i;
 
--- a/drivers/staging/brcm80211/sys/wlc_antsel.c
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.c
@@ -155,7 +155,7 @@ antsel_info_t *BCMNMIATTACHFN(wlc_antsel
 	return asi;
 }
 
-void BCMATTACHFN(wlc_antsel_detach) (antsel_info_t *asi)
+void wlc_antsel_detach(antsel_info_t *asi)
 {
 	if (!asi)
 		return;
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -566,8 +566,7 @@ int wlc_bmac_state_get(wlc_hw_info_t *wl
 	return 0;
 }
 
-static bool
-BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc_info_t *wlc, uint j, bool wme)
+static bool wlc_bmac_attach_dmapio(wlc_info_t *wlc, uint j, bool wme)
 {
 	uint i;
 	char name[8];
@@ -686,7 +685,7 @@ BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc
 	return TRUE;
 }
 
-static void BCMATTACHFN(wlc_bmac_detach_dmapio) (wlc_hw_info_t *wlc_hw)
+static void wlc_bmac_detach_dmapio(wlc_hw_info_t *wlc_hw)
 {
 	uint j;
 
@@ -704,11 +703,10 @@ static void BCMATTACHFN(wlc_bmac_detach_
  *    initialize software state for each core and band
  *    put the whole chip in reset(driver down state), no clock
  */
-
-int
-BCMATTACHFN(wlc_bmac_attach) (wlc_info_t *wlc, u16 vendor, u16 device,
-			      uint unit, bool piomode, osl_t *osh,
-			      void *regsva, uint bustype, void *btparam) {
+int wlc_bmac_attach(wlc_info_t *wlc, u16 vendor, u16 device, uint unit,
+		    bool piomode, osl_t *osh, void *regsva, uint bustype,
+		    void *btparam)
+{
 	wlc_hw_info_t *wlc_hw;
 	d11regs_t *regs;
 	char *macaddr = NULL;
@@ -1048,7 +1046,7 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
  * may get overrides later in this function
  *  BMAC_NOTES, move low out and resolve the dangling ones
  */
-void BCMATTACHFN(wlc_bmac_info_init) (wlc_hw_info_t *wlc_hw)
+void wlc_bmac_info_init(wlc_hw_info_t *wlc_hw)
 {
 	wlc_info_t *wlc = wlc_hw->wlc;
 
@@ -1070,7 +1068,7 @@ void BCMATTACHFN(wlc_bmac_info_init) (wl
 /*
  * low level detach
  */
-int BCMATTACHFN(wlc_bmac_detach) (wlc_info_t *wlc)
+int wlc_bmac_detach(wlc_info_t *wlc)
 {
 	uint i;
 	wlc_hwband_t *band;
@@ -2142,7 +2140,7 @@ void WLBANDINITFN(wlc_setxband) (wlc_hw_
 	}
 }
 
-static bool BCMATTACHFN(wlc_isgoodchip) (wlc_hw_info_t *wlc_hw)
+static bool wlc_isgoodchip(wlc_hw_info_t *wlc_hw)
 {
 
 	/* reject unsupported corerev */
@@ -2154,7 +2152,7 @@ static bool BCMATTACHFN(wlc_isgoodchip)
 	return TRUE;
 }
 
-static bool BCMATTACHFN(wlc_validboardtype) (wlc_hw_info_t *wlc_hw)
+static bool wlc_validboardtype(wlc_hw_info_t *wlc_hw)
 {
 	bool goodboard = TRUE;
 	uint boardrev = wlc_hw->boardrev;
@@ -2784,7 +2782,7 @@ static void BCMINITFN(wlc_gpio_init) (wl
 	si_gpiocontrol(wlc_hw->sih, gm, gc, GPIO_DRV_PRIORITY);
 }
 
-static void BCMATTACHFN(wlc_ucode_download) (wlc_hw_info_t *wlc_hw)
+static void wlc_ucode_download(wlc_hw_info_t *wlc_hw)
 {
 	wlc_info_t *wlc;
 	wlc = wlc_hw->wlc;
@@ -2812,8 +2810,7 @@ static void BCMATTACHFN(wlc_ucode_downlo
 	}
 }
 
-static void
-BCMATTACHFN(wlc_ucode_write) (wlc_hw_info_t *wlc_hw, const u32 ucode[],
+static void wlc_ucode_write(wlc_hw_info_t *wlc_hw, const u32 ucode[],
 			      const uint nbytes) {
 	osl_t *osh;
 	d11regs_t *regs = wlc_hw->regs;
@@ -3668,7 +3665,7 @@ wlc_bmac_read_tsf(wlc_hw_info_t *wlc_hw,
 	return;
 }
 
-bool BCMATTACHFN(wlc_bmac_validate_chip_access) (wlc_hw_info_t *wlc_hw)
+bool wlc_bmac_validate_chip_access(wlc_hw_info_t *wlc_hw)
 {
 	d11regs_t *regs;
 	u32 w, val;
--- a/drivers/staging/brcm80211/sys/wlc_channel.c
+++ b/drivers/staging/brcm80211/sys/wlc_channel.c
@@ -602,7 +602,7 @@ const locale_mimo_info_t *wlc_get_mimo_5
 	return g_mimo_5g_table[locale_idx];
 }
 
-wlc_cm_info_t *BCMATTACHFN(wlc_channel_mgr_attach) (wlc_info_t *wlc)
+wlc_cm_info_t *wlc_channel_mgr_attach(wlc_info_t *wlc)
 {
 	wlc_cm_info_t *wlc_cm;
 	char country_abbrev[WLC_CNTRY_BUF_SZ];
@@ -649,7 +649,7 @@ wlc_cm_info_t *BCMATTACHFN(wlc_channel_m
 	return wlc_cm;
 }
 
-void BCMATTACHFN(wlc_channel_mgr_detach) (wlc_cm_info_t *wlc_cm)
+void wlc_channel_mgr_detach(wlc_cm_info_t *wlc_cm)
 {
 	if (wlc_cm)
 		MFREE(wlc_cm->pub->osh, wlc_cm, sizeof(wlc_cm_info_t));
--- a/drivers/staging/brcm80211/sys/wlc_event.c
+++ b/drivers/staging/brcm80211/sys/wlc_event.c
@@ -53,9 +53,9 @@ struct wlc_eventq {
 /*
  * Export functions
  */
-wlc_eventq_t *BCMATTACHFN(wlc_eventq_attach) (wlc_pub_t *pub,
-					      struct wlc_info *wlc, void *wl,
-					      wlc_eventq_cb_t cb) {
+wlc_eventq_t *wlc_eventq_attach(wlc_pub_t *pub, struct wlc_info *wlc, void *wl,
+				wlc_eventq_cb_t cb)
+{
 	wlc_eventq_t *eq;
 
 	eq = (wlc_eventq_t *) MALLOC(pub->osh, sizeof(wlc_eventq_t));
@@ -80,7 +80,7 @@ wlc_eventq_t *BCMATTACHFN(wlc_eventq_att
 	return eq;
 }
 
-int BCMATTACHFN(wlc_eventq_detach) (wlc_eventq_t *eq)
+int wlc_eventq_detach(wlc_eventq_t *eq)
 {
 	/* Clean up pending events */
 	wlc_eventq_down(eq);
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -1559,7 +1559,7 @@ void wlc_edcf_setparams(wlc_bsscfg_t *cf
 
 }
 
-bool BCMATTACHFN(wlc_timers_init) (wlc_info_t *wlc, int unit)
+bool wlc_timers_init(wlc_info_t *wlc, int unit)
 {
 	wlc->wdtimer = wl_init_timer(wlc->wl, wlc_watchdog_by_timer,
 		wlc, "watchdog");
@@ -1586,7 +1586,7 @@ bool BCMATTACHFN(wlc_timers_init) (wlc_i
  * Initialize wlc_info default values ...
  * may get overrides later in this function
  */
-void BCMATTACHFN(wlc_info_init) (wlc_info_t *wlc, int unit)
+void wlc_info_init(wlc_info_t *wlc, int unit)
 {
 	int i;
 	/* Assume the device is there until proven otherwise */
@@ -1711,7 +1711,7 @@ static bool wlc_state_bmac_sync(wlc_info
 	return TRUE;
 }
 
-static uint BCMATTACHFN(wlc_attach_module) (wlc_info_t *wlc)
+static uint wlc_attach_module(wlc_info_t *wlc)
 {
 	uint err = 0;
 	uint unit;
@@ -1760,10 +1760,10 @@ wlc_pub_t *wlc_pub(void *wlc)
 /*
  * The common driver entry routine. Error codes should be unique
  */
-void *BCMATTACHFN(wlc_attach) (void *wl, u16 vendor, u16 device,
-			       uint unit, bool piomode, osl_t *osh,
-			       void *regsva, uint bustype, void *btparam,
-			       uint *perr) {
+void *wlc_attach(void *wl, u16 vendor, u16 device, uint unit, bool piomode,
+		 osl_t *osh, void *regsva, uint bustype, void *btparam,
+		 uint *perr)
+{
 	wlc_info_t *wlc;
 	uint err = 0;
 	uint j;
@@ -2104,7 +2104,7 @@ static void BCMNMIATTACHFN(wlc_attach_an
 	}
 }
 
-static bool BCMATTACHFN(wlc_attach_stf_ant_init) (wlc_info_t *wlc)
+static bool wlc_attach_stf_ant_init(wlc_info_t *wlc)
 {
 	int aa;
 	uint unit;
@@ -2145,10 +2145,10 @@ static bool BCMATTACHFN(wlc_attach_stf_a
 
 #ifdef WLC_HIGH_ONLY
 /* HIGH_ONLY bmac_attach, which sync over LOW_ONLY bmac_attach states */
-int
-BCMATTACHFN(wlc_bmac_attach) (wlc_info_t *wlc, u16 vendor, u16 device,
-			      uint unit, bool piomode, osl_t *osh,
-			      void *regsva, uint bustype, void *btparam) {
+int wlc_bmac_attach(wlc_info_t *wlc, u16 vendor, u16 device, uint unit,
+		    bool piomode, osl_t *osh, void *regsva, uint bustype,
+		    void *btparam)
+{
 	wlc_bmac_revinfo_t revinfo;
 	uint idx = 0;
 	rpc_info_t *rpc = (rpc_info_t *) btparam;
@@ -2273,7 +2273,7 @@ int wlc_bmac_detach(wlc_info_t *wlc)
 
 #endif				/* WLC_HIGH_ONLY */
 
-static void BCMATTACHFN(wlc_timers_deinit) (wlc_info_t *wlc)
+static void wlc_timers_deinit(wlc_info_t *wlc)
 {
 	/* free timer state */
 	if (wlc->wdtimer) {
@@ -2286,7 +2286,7 @@ static void BCMATTACHFN(wlc_timers_deini
 	}
 }
 
-static void BCMATTACHFN(wlc_detach_module) (wlc_info_t *wlc)
+static void wlc_detach_module(wlc_info_t *wlc)
 {
 	if (wlc->asi) {
 		wlc_antsel_detach(wlc->asi);
@@ -2309,7 +2309,7 @@ static void BCMATTACHFN(wlc_detach_modul
  *    One exception is sb register access, which is possible if crystal is turned on
  * After "down" state, driver should avoid software timer with the exception of radio_monitor.
  */
-uint BCMATTACHFN(wlc_detach) (wlc_info_t *wlc)
+uint wlc_detach(wlc_info_t *wlc)
 {
 	uint i;
 	uint callbacks = 0;
@@ -4520,10 +4520,10 @@ int wlc_iovar_gets8(wlc_info_t *wlc, con
  * calling function must keep 'iovars' until wlc_module_unregister is called.
  * 'iovar' must have the last entry's name field being NULL as terminator.
  */
-int
-BCMATTACHFN(wlc_module_register) (wlc_pub_t *pub, const bcm_iovar_t *iovars,
-				  const char *name, void *hdl, iovar_fn_t i_fn,
-				  watchdog_fn_t w_fn, down_fn_t d_fn) {
+int wlc_module_register(wlc_pub_t *pub, const bcm_iovar_t *iovars,
+			const char *name, void *hdl, iovar_fn_t i_fn,
+			watchdog_fn_t w_fn, down_fn_t d_fn)
+{
 	wlc_info_t *wlc = (wlc_info_t *) pub->wlc;
 	int i;
 
@@ -4550,9 +4550,8 @@ BCMATTACHFN(wlc_module_register) (wlc_pu
 }
 
 /* unregister module callbacks */
-int
-BCMATTACHFN(wlc_module_unregister) (wlc_pub_t *pub, const char *name,
-				    void *hdl) {
+int wlc_module_unregister(wlc_pub_t *pub, const char *name, void *hdl)
+{
 	wlc_info_t *wlc = (wlc_info_t *) pub->wlc;
 	int i;
 
@@ -8144,7 +8143,7 @@ void wlc_default_rateset(wlc_info_t *wlc
 			    wlc->stf->txstreams);
 }
 
-static void BCMATTACHFN(wlc_bss_default_init) (wlc_info_t *wlc)
+static void wlc_bss_default_init(wlc_info_t *wlc)
 {
 	chanspec_t chanspec;
 	wlcband_t *band;
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.c
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.c
@@ -62,7 +62,7 @@ struct wlc_phy_shim_info {
 	void *wl;		/* pointer to os-specific private state */
 };
 
-wlc_phy_shim_info_t *BCMATTACHFN(wlc_phy_shim_attach) (wlc_hw_info_t *wlc_hw,
+wlc_phy_shim_info_t *wlc_phy_shim_attach(wlc_hw_info_t *wlc_hw,
 						       void *wl, void *wlc) {
 	wlc_phy_shim_info_t *physhim = NULL;
 
@@ -80,7 +80,7 @@ wlc_phy_shim_info_t *BCMATTACHFN(wlc_phy
 	return physhim;
 }
 
-void BCMATTACHFN(wlc_phy_shim_detach) (wlc_phy_shim_info_t *physhim)
+void wlc_phy_shim_detach(wlc_phy_shim_info_t *physhim)
 {
 	if (!physhim)
 		return;
--- a/drivers/staging/brcm80211/sys/wlc_stf.c
+++ b/drivers/staging/brcm80211/sys/wlc_stf.c
@@ -404,7 +404,7 @@ int wlc_stf_ss_update(wlc_info_t *wlc, w
 	return ret_code;
 }
 
-int BCMATTACHFN(wlc_stf_attach) (wlc_info_t *wlc)
+int wlc_stf_attach(wlc_info_t *wlc)
 {
 	wlc->bandstate[BAND_2G_INDEX]->band_stf_ss_mode = PHY_TXC1_MODE_SISO;
 	wlc->bandstate[BAND_5G_INDEX]->band_stf_ss_mode = PHY_TXC1_MODE_CDD;
@@ -427,7 +427,7 @@ int BCMATTACHFN(wlc_stf_attach) (wlc_inf
 	return 0;
 }
 
-void BCMATTACHFN(wlc_stf_detach) (wlc_info_t *wlc)
+void wlc_stf_detach(wlc_info_t *wlc)
 {
 }
 
@@ -524,7 +524,7 @@ void wlc_stf_phy_txant_upd(wlc_info_t *w
 	_wlc_stf_phy_txant_upd(wlc);
 }
 
-void BCMATTACHFN(wlc_stf_phy_chain_calc) (wlc_info_t *wlc)
+void wlc_stf_phy_chain_calc(wlc_info_t *wlc)
 {
 	/* get available rx/tx chains */
 	wlc->stf->hw_txchain = (u8) getintvar(wlc->pub->vars, "txchain");
--- a/drivers/staging/brcm80211/util/aiutils.c
+++ b/drivers/staging/brcm80211/util/aiutils.c
@@ -108,7 +108,7 @@ static void ai_hwfixup(si_info_t *sii)
 }
 
 /* parse the enumeration rom to identify all cores */
-void BCMATTACHFN(ai_scan) (si_t *sih, void *regs, uint devid)
+void ai_scan(si_t *sih, void *regs, uint devid)
 {
 	si_info_t *sii = SI_INFO(sih);
 	chipcregs_t *cc = (chipcregs_t *) regs;
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -93,14 +93,14 @@ static int initvars_table(osl_t *osh, ch
 static int initvars_flash(si_t *sih, osl_t *osh, char **vp, uint len);
 
 /* Initialization of varbuf structure */
-static void BCMATTACHFN(varbuf_init) (varbuf_t *b, char *buf, uint size)
+static void varbuf_init(varbuf_t *b, char *buf, uint size)
 {
 	b->size = size;
 	b->base = b->buf = buf;
 }
 
 /* append a null terminated var=value string */
-static int BCMATTACHFN(varbuf_append) (varbuf_t *b, const char *fmt, ...)
+static int varbuf_append(varbuf_t *b, const char *fmt, ...)
 {
 	va_list ap;
 	int r;
@@ -157,9 +157,9 @@ static int BCMATTACHFN(varbuf_append) (v
  * Initialize local vars from the right source for this platform.
  * Return 0 on success, nonzero on error.
  */
-int
-BCMATTACHFN(srom_var_init) (si_t *sih, uint bustype, void *curmap, osl_t *osh,
-			    char **vars, uint *count) {
+int srom_var_init(si_t *sih, uint bustype, void *curmap, osl_t *osh,
+		  char **vars, uint *count)
+{
 	uint len;
 
 	len = 0;
@@ -378,9 +378,7 @@ u8 patch_pair;
 /* For dongle HW, accept partial calibration parameters */
 #define BCMDONGLECASE(n)
 
-int
-BCMATTACHFN(srom_parsecis) (osl_t *osh, u8 *pcis[], uint ciscnt,
-			    char **vars, uint *count)
+int srom_parsecis(osl_t *osh, u8 *pcis[], uint ciscnt, char **vars, uint *count)
 {
 	char eabuf[32];
 	char *base;
@@ -1557,9 +1555,9 @@ static int otp_read_pci(osl_t *osh, si_t
 * Create variable table from memory.
 * Return 0 on success, nonzero on error.
 */
-static int
-BCMATTACHFN(initvars_table) (osl_t *osh, char *start, char *end, char **vars,
-			     uint *count) {
+static int initvars_table(osl_t *osh, char *start, char *end, char **vars,
+			  uint *count)
+{
 	int c = (int)(end - start);
 
 	/* do it only when there is more than just the null string */
@@ -1584,8 +1582,7 @@ BCMATTACHFN(initvars_table) (osl_t *osh,
  * of the table upon enter and to the end of the table upon exit when success.
  * Return 0 on success, nonzero on error.
  */
-static int
-BCMATTACHFN(initvars_flash) (si_t *sih, osl_t *osh, char **base, uint len)
+static int initvars_flash(si_t *sih, osl_t *osh, char **base, uint len)
 {
 	char *vp = *base;
 	char *flash;
@@ -1643,8 +1640,7 @@ BCMATTACHFN(initvars_flash) (si_t *sih,
  * Initialize nonvolatile variable table from flash.
  * Return 0 on success, nonzero on error.
  */
-static int
-BCMATTACHFN(initvars_flash_si) (si_t *sih, char **vars, uint *count)
+static int initvars_flash_si(si_t *sih, char **vars, uint *count)
 {
 	osl_t *osh = si_osh(sih);
 	char *vp, *base;
@@ -1704,9 +1700,8 @@ static bool mask_valid(u16 mask)
 }
 #endif				/* BCMDBG */
 
-static void
-BCMATTACHFN(_initvars_srom_pci) (u8 sromrev, u16 *srom, uint off,
-				 varbuf_t *b) {
+static void _initvars_srom_pci(u8 sromrev, u16 *srom, uint off, varbuf_t *b)
+{
 	u16 w;
 	u32 val;
 	const sromvar_t *srv;
@@ -1853,9 +1848,8 @@ BCMATTACHFN(_initvars_srom_pci) (u8 srom
  * Initialize nonvolatile variable table from sprom.
  * Return 0 on success, nonzero on error.
  */
-static int
-BCMATTACHFN(initvars_srom_pci) (si_t *sih, void *curmap, char **vars,
-				uint *count) {
+static int initvars_srom_pci(si_t *sih, void *curmap, char **vars, uint *count)
+{
 	u16 *srom, *sromwindow;
 	u8 sromrev = 0;
 	u32 sr;
@@ -2002,8 +1996,7 @@ BCMATTACHFN(initvars_srom_pci) (si_t *si
  * Read the SDIO cis and call parsecis to initialize the vars.
  * Return 0 on success, nonzero on error.
  */
-static int
-BCMATTACHFN(initvars_cis_sdio) (osl_t *osh, char **vars, uint *count)
+static int initvars_cis_sdio(osl_t *osh, char **vars, uint *count)
 {
 	u8 *cis[SBSDIO_NUM_FUNCTION + 1];
 	uint fn, numfn;
@@ -2039,7 +2032,7 @@ BCMATTACHFN(initvars_cis_sdio) (osl_t *o
 }
 
 /* set SDIO sprom command register */
-static int BCMATTACHFN(sprom_cmd_sdio) (osl_t *osh, u8 cmd)
+static int sprom_cmd_sdio(osl_t *osh, u8 cmd)
 {
 	u8 status = 0;
 	uint wait_cnt = 1000;
@@ -2087,9 +2080,9 @@ static int sprom_read_sdio(osl_t *osh, u
 }
 #endif				/* BCMSDIO */
 
-static int
-BCMATTACHFN(initvars_srom_si) (si_t *sih, osl_t *osh, void *curmap,
-			       char **vars, uint *varsz) {
+static int initvars_srom_si(si_t *sih, osl_t *osh, void *curmap, char **vars,
+			    uint *varsz)
+{
 	/* Search flash nvram section for srom variables */
 	return initvars_flash_si(sih, vars, varsz);
 }
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -103,9 +103,9 @@ void si_pmu_pllupd(si_t *sih)
 }
 
 /* Setup switcher voltage */
-void
-BCMATTACHFN(si_pmu_set_switcher_voltage) (si_t *sih, osl_t *osh,
-					  u8 bb_voltage, u8 rf_voltage) {
+void si_pmu_set_switcher_voltage(si_t *sih, osl_t *osh, u8 bb_voltage,
+				 u8 rf_voltage)
+{
 	chipcregs_t *cc;
 	uint origidx;
 
@@ -126,9 +126,8 @@ BCMATTACHFN(si_pmu_set_switcher_voltage)
 	si_setcoreidx(sih, origidx);
 }
 
-void
-BCMATTACHFN(si_pmu_set_ldo_voltage) (si_t *sih, osl_t *osh, u8 ldo,
-				     u8 voltage) {
+void si_pmu_set_ldo_voltage(si_t *sih, osl_t *osh, u8 ldo, u8 voltage)
+{
 	u8 sr_cntl_shift = 0, rc_shift = 0, shift = 0, mask = 0;
 	u8 addr = 0;
 
@@ -262,7 +261,7 @@ u16 BCMINITFN(si_pmu_fast_pwrup_delay) (
 	return (u16) delay;
 }
 
-u32 BCMATTACHFN(si_pmu_force_ilp) (si_t *sih, osl_t *osh, bool force)
+u32 si_pmu_force_ilp(si_t *sih, osl_t *osh, bool force)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -564,26 +563,26 @@ static const pmu_res_depend_t bcm4330a0_
 };
 
 /* TRUE if the power topology uses the buck boost to provide 3.3V to VDDIO_RF and WLAN PA */
-static bool BCMATTACHFN(si_pmu_res_depfltr_bb) (si_t *sih)
+static bool si_pmu_res_depfltr_bb(si_t *sih)
 {
 	return (sih->boardflags & BFL_BUCKBOOST) != 0;
 }
 
 /* TRUE if the power topology doesn't use the cbuck. Key on chiprev also if the chip is BCM4325. */
-static bool BCMATTACHFN(si_pmu_res_depfltr_ncb) (si_t *sih)
+static bool si_pmu_res_depfltr_ncb(si_t *sih)
 {
 
 	return (sih->boardflags & BFL_NOCBUCK) != 0;
 }
 
 /* TRUE if the power topology uses the PALDO */
-static bool BCMATTACHFN(si_pmu_res_depfltr_paldo) (si_t *sih)
+static bool si_pmu_res_depfltr_paldo(si_t *sih)
 {
 	return (sih->boardflags & BFL_PALDO) != 0;
 }
 
 /* TRUE if the power topology doesn't use the PALDO */
-static bool BCMATTACHFN(si_pmu_res_depfltr_npaldo) (si_t *sih)
+static bool si_pmu_res_depfltr_npaldo(si_t *sih)
 {
 	return (sih->boardflags & BFL_PALDO) == 0;
 }
@@ -680,7 +679,7 @@ static void si_pmu_res_masks(si_t *sih,
 }
 
 /* initialize PMU resources */
-void BCMATTACHFN(si_pmu_res_init) (si_t *sih, osl_t *osh)
+void si_pmu_res_init(si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -1206,9 +1205,8 @@ BCMINITFN(si_pmu1_alpclk0) (si_t *sih, o
  * case the xtal frequency is unknown to the s/w so we need to call
  * si_pmu1_xtaldef0() wherever it is needed to return a default value.
  */
-static void
-BCMATTACHFN(si_pmu1_pllinit0) (si_t *sih, osl_t *osh, chipcregs_t *cc,
-			       u32 xtal) {
+static void si_pmu1_pllinit0(si_t *sih, osl_t *osh, chipcregs_t *cc, u32 xtal)
+{
 	const pmu1_xtaltab0_t *xt;
 	u32 tmp;
 	u32 buf_strength = 0;
@@ -1506,7 +1504,7 @@ BCMINITFN(si_pmu1_cpuclk0) (si_t *sih, o
 }
 
 /* initialize PLL */
-void BCMATTACHFN(si_pmu_pll_init) (si_t *sih, osl_t *osh, uint xtalfreq)
+void si_pmu_pll_init(si_t *sih, osl_t *osh, uint xtalfreq)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -1980,7 +1978,7 @@ BCMINITFN(si_sdiod_drive_strength_init)
 }
 
 /* initialize PMU */
-void BCMATTACHFN(si_pmu_init) (si_t *sih, osl_t *osh)
+void si_pmu_init(si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -2509,7 +2507,7 @@ void
 #if defined(BCMDBG)
 si_pmu_sprom_enable(si_t *sih, osl_t *osh, bool enable)
 #else
-BCMATTACHFN(si_pmu_sprom_enable) (si_t *sih, osl_t *osh, bool enable)
+si_pmu_sprom_enable(si_t *sih, osl_t *osh, bool enable)
 #endif
 {
 	chipcregs_t *cc;
@@ -2525,7 +2523,7 @@ BCMATTACHFN(si_pmu_sprom_enable) (si_t *
 }
 
 /* initialize PMU chip controls and other chip level stuff */
-void BCMATTACHFN(si_pmu_chip_init) (si_t *sih, osl_t *osh)
+void si_pmu_chip_init(si_t *sih, osl_t *osh)
 {
 	uint origidx;
 
@@ -2547,7 +2545,7 @@ void BCMATTACHFN(si_pmu_chip_init) (si_t
 }
 
 /* initialize PMU switch/regulators */
-void BCMATTACHFN(si_pmu_swreg_init) (si_t *sih, osl_t *osh)
+void si_pmu_swreg_init(si_t *sih, osl_t *osh)
 {
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -2620,7 +2618,7 @@ si_pmu_waitforclk_on_backplane(si_t *sih
 
 #define EXT_ILP_HZ 32768
 
-u32 BCMATTACHFN(si_pmu_measure_alpclk) (si_t *sih, osl_t *osh)
+u32 si_pmu_measure_alpclk(si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -2668,7 +2666,7 @@ u32 BCMATTACHFN(si_pmu_measure_alpclk) (
 	return alp_khz;
 }
 
-static void BCMATTACHFN(si_pmu_set_4330_plldivs) (si_t *sih)
+static void si_pmu_set_4330_plldivs(si_t *sih)
 {
 	u32 FVCO = si_pmu1_pllfvco0(sih) / 1000;
 	u32 m1div, m2div, m3div, m4div, m5div, m6div;
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -641,7 +641,7 @@ void pcie_war_ovr_aspm_update(void *pch,
 }
 
 /* ***** Functions called during driver state changes ***** */
-void BCMATTACHFN(pcicore_attach) (void *pch, char *pvars, int state)
+void pcicore_attach(void *pch, char *pvars, int state)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
 	si_t *sih = pi->sih;
--- a/drivers/staging/brcm80211/util/nvram/nvram_ro.c
+++ b/drivers/staging/brcm80211/util/nvram/nvram_ro.c
@@ -77,7 +77,7 @@ static void BCMINITFN(get_flash_nvram) (
 }
 #endif				/* FLASH */
 
-int BCMATTACHFN(nvram_init) (void *si)
+int nvram_init(void *si)
 {
 
 	/* Make sure we read nvram in flash just once before freeing the memory */
@@ -88,7 +88,7 @@ int BCMATTACHFN(nvram_init) (void *si)
 	return 0;
 }
 
-int BCMATTACHFN(nvram_append) (void *si, char *varlst, uint varsz)
+int nvram_append(void *si, char *varlst, uint varsz)
 {
 	uint bufsz = VARS_T_OH;
 	vars_t *new;
@@ -157,22 +157,22 @@ char *nvram_get(const char *name)
 	return v;
 }
 
-int BCMATTACHFN(nvram_set) (const char *name, const char *value)
+int nvram_set(const char *name, const char *value)
 {
 	return 0;
 }
 
-int BCMATTACHFN(nvram_unset) (const char *name)
+int nvram_unset(const char *name)
 {
 	return 0;
 }
 
-int BCMATTACHFN(nvram_reset) (void *si)
+int nvram_reset(void *si)
 {
 	return 0;
 }
 
-int BCMATTACHFN(nvram_commit) (void)
+int nvram_commit(void)
 {
 	return 0;
 }
--- a/drivers/staging/brcm80211/util/sbutils.c
+++ b/drivers/staging/brcm80211/util/sbutils.c
@@ -72,7 +72,7 @@ uint sb_coreid(si_t *sih)
 }
 
 /* return core index of the core with address 'sba' */
-static uint BCMATTACHFN(_sb_coreidx) (si_info_t *sii, u32 sba)
+static uint _sb_coreidx(si_info_t *sii, u32 sba)
 {
 	uint i;
 
@@ -83,7 +83,7 @@ static uint BCMATTACHFN(_sb_coreidx) (si
 }
 
 /* return core address of the current core */
-static u32 BCMATTACHFN(_sb_coresba) (si_info_t *sii)
+static u32 _sb_coresba(si_info_t *sii)
 {
 	u32 sbaddr = 0;
 
@@ -205,9 +205,9 @@ uint sb_corereg(si_t *sih, uint coreidx,
  * starting from bus 'sbba', inclusive.
  */
 #define SB_MAXBUSES	2
-static uint
-BCMATTACHFN(_sb_scan) (si_info_t *sii, u32 sba, void *regs, uint bus,
-		       u32 sbba, uint numcores) {
+static uint _sb_scan(si_info_t *sii, u32 sba, void *regs, uint bus, u32 sbba,
+		     uint numcores)
+{
 	uint next;
 	uint ncc = 0;
 	uint i;
@@ -287,7 +287,7 @@ BCMATTACHFN(_sb_scan) (si_info_t *sii, u
 }
 
 /* scan the sb enumerated space to identify all cores */
-void BCMATTACHFN(sb_scan) (si_t *sih, void *regs, uint devid)
+void sb_scan(si_t *sih, void *regs, uint devid)
 {
 	si_info_t *sii;
 	u32 origsba;
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -82,9 +82,9 @@ static u32 si_gpioreservation;
  * vars - pointer to a pointer area for "environment" variables
  * varsz - pointer to int to return the size of the vars
  */
-si_t *BCMATTACHFN(si_attach) (uint devid, osl_t *osh, void *regs,
-			      uint bustype, void *sdh, char **vars,
-			      uint *varsz) {
+si_t *si_attach(uint devid, osl_t *osh, void *regs, uint bustype, void *sdh,
+		char **vars, uint *varsz)
+{
 	si_info_t *sii;
 
 	/* alloc si_info_t */
@@ -109,9 +109,9 @@ si_t *BCMATTACHFN(si_attach) (uint devid
 /* global kernel resource */
 static si_info_t ksii;
 
-static bool
-BCMATTACHFN(si_buscore_prep) (si_info_t *sii, uint bustype, uint devid,
-			      void *sdh) {
+static bool si_buscore_prep(si_info_t *sii, uint bustype, uint devid,
+			    void *sdh)
+{
 
 #ifndef BRCM_FULLMAC
 	/* kludge to enable the clock on the 4306 which lacks a slowclock */
@@ -165,9 +165,9 @@ BCMATTACHFN(si_buscore_prep) (si_info_t
 	return TRUE;
 }
 
-static bool
-BCMATTACHFN(si_buscore_setup) (si_info_t *sii, chipcregs_t *cc, uint bustype,
-			       u32 savewin, uint *origidx, void *regs) {
+static bool si_buscore_setup(si_info_t *sii, chipcregs_t *cc, uint bustype,
+			     u32 savewin, uint *origidx, void *regs)
+{
 	bool pci, pcie;
 	uint i;
 	uint pciidx, pcieidx, pcirev, pcierev;
@@ -305,7 +305,7 @@ BCMATTACHFN(si_buscore_setup) (si_info_t
 	return TRUE;
 }
 
-static __used void BCMATTACHFN(si_nvram_process) (si_info_t *sii, char *pvars)
+static __used void si_nvram_process(si_info_t *sii, char *pvars)
 {
 	uint w = 0;
 
@@ -366,10 +366,10 @@ static __used void BCMATTACHFN(si_nvram_
 /* this is will make Sonics calls directly, since Sonics is no longer supported in the Si abstraction */
 /* this has been customized for the bcm 4329 ONLY */
 #ifdef BCMSDIO
-static si_info_t *BCMATTACHFN(si_doattach) (si_info_t *sii, uint devid,
-					    osl_t *osh, void *regs,
-					    uint bustype, void *sdh,
-					    char **vars, uint *varsz) {
+static si_info_t *si_doattach(si_info_t *sii, uint devid, osl_t *osh,
+			      void *regs, uint bustype, void *sdh,
+			      char **vars, uint *varsz)
+{
 	struct si_pub *sih = &sii->pub;
 	u32 w, savewin;
 	chipcregs_t *cc;
@@ -501,10 +501,10 @@ static si_info_t *BCMATTACHFN(si_doattac
 }
 
 #else				/* BCMSDIO */
-static si_info_t *BCMATTACHFN(si_doattach) (si_info_t *sii, uint devid,
-					    osl_t *osh, void *regs,
-					    uint bustype, void *sdh,
-					    char **vars, uint *varsz) {
+static si_info_t *si_doattach(si_info_t *sii, uint devid, osl_t *osh,
+			      void *regs, uint bustype, void *sdh,
+			      char **vars, uint *varsz)
+{
 	struct si_pub *sih = &sii->pub;
 	u32 w, savewin;
 	chipcregs_t *cc;
@@ -697,7 +697,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 #endif				/* BCMSDIO */
 
 /* may be called with core in reset */
-void BCMATTACHFN(si_detach) (si_t *sih)
+void si_detach(si_t *sih)
 {
 	si_info_t *sii;
 	uint idx;
@@ -1452,7 +1452,7 @@ static bool _si_clkctl_cc(si_info_t *sii
 }
 
 /* Build device path. Support SI, PCI, and JTAG for now. */
-int BCMATTACHFN(si_devpath) (si_t *sih, char *path, int size)
+int si_devpath(si_t *sih, char *path, int size)
 {
 	int slen;
 
@@ -1495,7 +1495,7 @@ int BCMATTACHFN(si_devpath) (si_t *sih,
 }
 
 /* Get a variable, but only if it has a devpath prefix */
-char *BCMATTACHFN(si_getdevpathvar) (si_t *sih, const char *name)
+char *si_getdevpathvar(si_t *sih, const char *name)
 {
 	char varname[SI_DEVPATH_BUFSZ + 32];
 
@@ -1505,7 +1505,7 @@ char *BCMATTACHFN(si_getdevpathvar) (si_
 }
 
 /* Get a variable, but only if it has a devpath prefix */
-int BCMATTACHFN(si_getdevpathintvar) (si_t *sih, const char *name)
+int si_getdevpathintvar(si_t *sih, const char *name)
 {
 #if defined(BCMBUSTYPE) && (BCMBUSTYPE == SI_BUS)
 	return getintvar(NULL, name);
@@ -1528,8 +1528,8 @@ char *si_getnvramflvar(si_t *sih, const
  * Nothing is done to the arguments if len == 0 or var is NULL, var is still returned.
  * On overflow, the first char will be set to '\0'.
  */
-static char *BCMATTACHFN(si_devpathvar) (si_t *sih, char *var, int len,
-					 const char *name) {
+static char *si_devpathvar(si_t *sih, char *var, int len, const char *name)
+{
 	uint path_len;
 
 	if (!var || len <= 0)
@@ -1603,7 +1603,7 @@ void si_sdio_init(si_t *sih)
 }
 #endif				/* BCMSDIO */
 
-bool BCMATTACHFN(si_pci_war16165) (si_t *sih)
+bool si_pci_war16165(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -1662,7 +1662,7 @@ void BCMINITFN(si_pci_down) (si_t *sih)
  * Configure the pci core for pci client (NIC) action
  * coremask is the bitvec of cores by index to be enabled.
  */
-void BCMATTACHFN(si_pci_setup) (si_t *sih, uint coremask)
+void si_pci_setup(si_t *sih, uint coremask)
 {
 	si_info_t *sii;
 	sbpciregs_t *pciregs = NULL;

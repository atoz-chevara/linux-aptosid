commit 48c51a8cf484c8d569f97050bbac493c5bc79c2f
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Wed Sep 15 12:47:18 2010 +0300

    staging: brcm80211: use string native library
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -165,19 +165,6 @@ extern "C" {
 #define	PKTPRIO_UPD	0x400	/* DSCP used to update VLAN prio */
 #define	PKTPRIO_DSCP	0x800	/* DSCP prio found */
 
-/* string */
-	extern int BCMROMFN(bcm_atoi) (char *s);
-	extern ulong BCMROMFN(bcm_strtoul) (char *cp, char **endp, uint base);
-	extern char *BCMROMFN(bcmstrstr) (char *haystack, char *needle);
-	extern char *BCMROMFN(bcmstrcat) (char *dest, const char *src);
-	extern char *BCMROMFN(bcmstrncat) (char *dest, const char *src,
-					   uint size);
-	extern ulong wchar2ascii(char *abuf, ushort *wbuf, ushort wbuflen,
-				 ulong abuflen);
-	char *bcmstrtok(char **string, const char *delimiters, char *tokdelim);
-	int bcmstricmp(const char *s1, const char *s2);
-	int bcmstrnicmp(const char *s1, const char *s2, int cnt);
-
 /* ethernet address */
 	extern char *bcm_ether_ntoa(const struct ether_addr *ea, char *buf);
 	extern int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr *ea);
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -17,6 +17,7 @@
 #include <wlc_cfg.h>
 
 #include <osl.h>
+#include <linux/kernel.h>
 #include <bcmendian.h>
 #include <bcmnvram.h>
 #include <sbchipc.h>
@@ -177,7 +178,7 @@ int phy_getintvar(phy_info_t *pi, const
 	if (val == NULL)
 		return 0;
 
-	return bcm_strtoul(val, NULL, 0);
+	return simple_strtoul(val, NULL, 0);
 }
 
 void wlc_phyreg_enter(wlc_phy_t *pih)
--- a/drivers/staging/brcm80211/sys/wl_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.c
@@ -1639,7 +1639,7 @@ static int __init wl_module_init(void)
 	else {
 		char *var = getvar(NULL, "wl_msglevel");
 		if (var)
-			wl_msg_level = bcm_strtoul(var, NULL, 0);
+			wl_msg_level = simple_strtoul(var, NULL, 0);
 	}
 #ifndef WLC_HIGH_ONLY
 	{
@@ -1650,7 +1650,7 @@ static int __init wl_module_init(void)
 		else {
 			char *var = getvar(NULL, "phy_msglevel");
 			if (var)
-				phyhal_msg_level = bcm_strtoul(var, NULL, 0);
+				phyhal_msg_level = simple_strtoul(var, NULL, 0);
 		}
 	}
 #endif				/* WLC_HIGH_ONLY */
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -22,6 +22,7 @@
 #include <typedefs.h>
 #include <bcmdefs.h>
 #include <osl.h>
+#include <linux/kernel.h>
 #include <proto/802.11.h>
 #include <bcmwifi.h>
 #include <bcmutils.h>
@@ -760,12 +761,12 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 
 		var = getvar(vars, "vendid");
 		if (var) {
-			vendor = (uint16) bcm_strtoul(var, NULL, 0);
+			vendor = (uint16) simple_strtoul(var, NULL, 0);
 			WL_ERROR(("Overriding vendor id = 0x%x\n", vendor));
 		}
 		var = getvar(vars, "devid");
 		if (var) {
-			uint16 devid = (uint16) bcm_strtoul(var, NULL, 0);
+			uint16 devid = (uint16) simple_strtoul(var, NULL, 0);
 			if (devid != 0xffff) {
 				device = devid;
 				WL_ERROR(("Overriding device id = 0x%x\n",
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -18,6 +18,7 @@
 #include <typedefs.h>
 #include <bcmdefs.h>
 #include <osl.h>
+#include <linux/ctype.h>
 #include <bcmutils.h>
 #include <bcmwifi.h>
 #include <siutils.h>
@@ -75,8 +76,6 @@
 #define W_REG(osh, r, v) RPC_WRITE_REG(osh, r, v)
 #endif
 
-#include <linux/ctype.h>
-
 /*
  * buffer length needed for wlc_format_ssid
  * 32 SSID chars, max of 4 chars for each SSID char "\xFF", plus NULL.
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -17,6 +17,7 @@
 #include <typedefs.h>
 #include <bcmdefs.h>
 #include <osl.h>
+#include <linux/kernel.h>
 #include <stdarg.h>
 #include <bcmutils.h>
 #include <hndsoc.h>
@@ -1924,7 +1925,7 @@ BCMATTACHFN(initvars_srom_pci) (si_t *si
 
 		value = si_getdevpathvar(sih, "sromrev");
 		if (value) {
-			sromrev = (uint8) bcm_strtoul(value, NULL, 0);
+			sromrev = (uint8) simple_strtoul(value, NULL, 0);
 			flash = TRUE;
 			goto varscont;
 		}
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -18,6 +18,8 @@
 #include <bcmdefs.h>
 #include <stdarg.h>
 #include <osl.h>
+#include <linux/ctype.h>
+#include <linux/kernel.h>
 #include <bcmutils.h>
 #include <siutils.h>
 #include <bcmnvram.h>
@@ -27,8 +29,6 @@
 #include <proto/802.1d.h>
 #include <proto/802.11.h>
 
-#include <linux/ctype.h>
-
 #ifdef WLC_LOW
 /* nvram vars cache */
 static char *nvram_vars;
@@ -492,271 +492,13 @@ void *BCMFASTPATH pktq_mdeq(struct pktq
 	return p;
 }
 
-ulong BCMROMFN(bcm_strtoul) (char *cp, char **endp, uint base)
-{
-	ulong result, last_result = 0, value;
-	bool minus;
-
-	minus = FALSE;
-
-	while (isspace(*cp))
-		cp++;
-
-	if (cp[0] == '+')
-		cp++;
-	else if (cp[0] == '-') {
-		minus = TRUE;
-		cp++;
-	}
-
-	if (base == 0) {
-		if (cp[0] == '0') {
-			if ((cp[1] == 'x') || (cp[1] == 'X')) {
-				base = 16;
-				cp = &cp[2];
-			} else {
-				base = 8;
-				cp = &cp[1];
-			}
-		} else
-			base = 10;
-	} else if (base == 16 && (cp[0] == '0')
-		   && ((cp[1] == 'x') || (cp[1] == 'X'))) {
-		cp = &cp[2];
-	}
-
-	result = 0;
-
-	while (isxdigit(*cp) &&
-	       (value =
-		isdigit(*cp) ? *cp - '0' : toupper(*cp) - 'A' + 10) <
-	       base) {
-		result = result * base + value;
-		/* Detected overflow */
-		if (result < last_result && !minus)
-			return (ulong) -1;
-		last_result = result;
-		cp++;
-	}
-
-	if (minus)
-		result = (ulong) (-(long)result);
-
-	if (endp)
-		*endp = (char *)cp;
-
-	return result;
-}
-
-int BCMROMFN(bcm_atoi) (char *s)
-{
-	return (int)bcm_strtoul(s, NULL, 10);
-}
-
-/* return pointer to location of substring 'needle' in 'haystack' */
-char *BCMROMFN(bcmstrstr) (char *haystack, char *needle)
-{
-	int len, nlen;
-	int i;
-
-	if ((haystack == NULL) || (needle == NULL))
-		return haystack;
-
-	nlen = strlen(needle);
-	len = strlen(haystack) - nlen + 1;
-
-	for (i = 0; i < len; i++)
-		if (memcmp(needle, &haystack[i], nlen) == 0)
-			return &haystack[i];
-	return NULL;
-}
-
-char *BCMROMFN(bcmstrcat) (char *dest, const char *src)
-{
-	char *p;
-
-	p = dest + strlen(dest);
-
-	while ((*p++ = *src++) != '\0')
-		;
-
-	return dest;
-}
-
-char *BCMROMFN(bcmstrncat) (char *dest, const char *src, uint size)
-{
-	char *endp;
-	char *p;
-
-	p = dest + strlen(dest);
-	endp = p + size;
-
-	while (p != endp && (*p++ = *src++) != '\0')
-		;
-
-	return dest;
-}
-
-/****************************************************************************
-* Function:   bcmstrtok
-*
-* Purpose:
-*  Tokenizes a string. This function is conceptually similiar to ANSI C strtok(),
-*  but allows strToken() to be used by different strings or callers at the same
-*  time. Each call modifies '*string' by substituting a NULL character for the
-*  first delimiter that is encountered, and updates 'string' to point to the char
-*  after the delimiter. Leading delimiters are skipped.
-*
-* Parameters:
-*  string      (mod) Ptr to string ptr, updated by token.
-*  delimiters  (in)  Set of delimiter characters.
-*  tokdelim    (out) Character that delimits the returned token. (May
-*                    be set to NULL if token delimiter is not required).
-*
-* Returns:  Pointer to the next token found. NULL when no more tokens are found.
-*****************************************************************************
-*/
-char *bcmstrtok(char **string, const char *delimiters, char *tokdelim)
-{
-	unsigned char *str;
-	unsigned long map[8];
-	int count;
-	char *nextoken;
-
-	if (tokdelim != NULL) {
-		/* Prime the token delimiter */
-		*tokdelim = '\0';
-	}
-
-	/* Clear control map */
-	for (count = 0; count < 8; count++) {
-		map[count] = 0;
-	}
-
-	/* Set bits in delimiter table */
-	do {
-		map[*delimiters >> 5] |= (1 << (*delimiters & 31));
-	} while (*delimiters++);
-
-	str = (unsigned char *)*string;
-
-	/* Find beginning of token (skip over leading delimiters). Note that
-	 * there is no token iff this loop sets str to point to the terminal
-	 * null (*str == '\0')
-	 */
-	while (((map[*str >> 5] & (1 << (*str & 31))) && *str) || (*str == ' ')) {
-		str++;
-	}
-
-	nextoken = (char *)str;
-
-	/* Find the end of the token. If it is not the end of the string,
-	 * put a null there.
-	 */
-	for (; *str; str++) {
-		if (map[*str >> 5] & (1 << (*str & 31))) {
-			if (tokdelim != NULL) {
-				*tokdelim = *str;
-			}
-
-			*str++ = '\0';
-			break;
-		}
-	}
-
-	*string = (char *)str;
-
-	/* Determine if a token has been found. */
-	if (nextoken == (char *)str) {
-		return NULL;
-	} else {
-		return nextoken;
-	}
-}
-
-#define xToLower(C) \
-	((C >= 'A' && C <= 'Z') ? (char)((int)C - (int)'A' + (int)'a') : C)
-
-/****************************************************************************
-* Function:   bcmstricmp
-*
-* Purpose:    Compare to strings case insensitively.
-*
-* Parameters: s1 (in) First string to compare.
-*             s2 (in) Second string to compare.
-*
-* Returns:    Return 0 if the two strings are equal, -1 if t1 < t2 and 1 if
-*             t1 > t2, when ignoring case sensitivity.
-*****************************************************************************
-*/
-int bcmstricmp(const char *s1, const char *s2)
-{
-	char dc, sc;
-
-	while (*s2 && *s1) {
-		dc = xToLower(*s1);
-		sc = xToLower(*s2);
-		if (dc < sc)
-			return -1;
-		if (dc > sc)
-			return 1;
-		s1++;
-		s2++;
-	}
-
-	if (*s1 && !*s2)
-		return 1;
-	if (!*s1 && *s2)
-		return -1;
-	return 0;
-}
-
-/****************************************************************************
-* Function:   bcmstrnicmp
-*
-* Purpose:    Compare to strings case insensitively, upto a max of 'cnt'
-*             characters.
-*
-* Parameters: s1  (in) First string to compare.
-*             s2  (in) Second string to compare.
-*             cnt (in) Max characters to compare.
-*
-* Returns:    Return 0 if the two strings are equal, -1 if t1 < t2 and 1 if
-*             t1 > t2, when ignoring case sensitivity.
-*****************************************************************************
-*/
-int bcmstrnicmp(const char *s1, const char *s2, int cnt)
-{
-	char dc, sc;
-
-	while (*s2 && *s1 && cnt) {
-		dc = xToLower(*s1);
-		sc = xToLower(*s2);
-		if (dc < sc)
-			return -1;
-		if (dc > sc)
-			return 1;
-		s1++;
-		s2++;
-		cnt--;
-	}
-
-	if (!cnt)
-		return 0;
-	if (*s1 && !*s2)
-		return 1;
-	if (!*s1 && *s2)
-		return -1;
-	return 0;
-}
-
 /* parse a xx:xx:xx:xx:xx:xx format ethernet address */
 int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr *ea)
 {
 	int i = 0;
 
 	for (;;) {
-		ea->octet[i++] = (char)bcm_strtoul(p, &p, 16);
+		ea->octet[i++] = (char)simple_strtoul(p, &p, 16);
 		if (!*p++ || i == 6)
 			break;
 	}
@@ -820,7 +562,7 @@ int getintvar(char *vars, const char *na
 	if (val == NULL)
 		return 0;
 
-	return bcm_strtoul(val, NULL, 0);
+	return simple_strtoul(val, NULL, 0);
 }
 
 int getintvararray(char *vars, const char *name, uint8 index)
@@ -836,7 +578,7 @@ int getintvararray(char *vars, const cha
 
 	/* table values are always separated by "," or " " */
 	while (*buf != '\0') {
-		val = bcm_strtoul(buf, &endp, 0);
+		val = simple_strtoul(buf, &endp, 0);
 		if (i == index) {
 			return val;
 		}
--- a/drivers/staging/brcm80211/util/bcmwifi.c
+++ b/drivers/staging/brcm80211/util/bcmwifi.c
@@ -17,12 +17,11 @@
 #include <typedefs.h>
 
 #include <osl.h>
+#include <linux/ctype.h>
+#include <linux/kernel.h>
 #include <bcmutils.h>
-#define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))
 #include <bcmwifi.h>
 
-#include <linux/ctype.h>
-
 /* Chanspec ASCII representation:
  * <channel><band><bandwidth><ctl-sideband>
  *   digit   [AB]     [N]        [UL]
@@ -92,7 +91,7 @@ chanspec_t wf_chspec_aton(char *a)
 	uint channel, band, bw, ctl_sb;
 	char c;
 
-	channel = strtoul(a, &endp, 10);
+	channel = simple_strtoul(a, &endp, 10);
 
 	/* check for no digits parsed */
 	if (endp == a)
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -17,6 +17,7 @@
 #include <typedefs.h>
 #include <bcmdefs.h>
 #include <osl.h>
+#include <linux/kernel.h>
 #include <bcmutils.h>
 #include <siutils.h>
 #include <bcmdevs.h>
@@ -663,13 +664,13 @@ static void si_pmu_res_masks(si_t *sih,
 	val = getvar(NULL, "rmin");
 	if (val != NULL) {
 		PMU_MSG(("Applying rmin=%s to min_mask\n", val));
-		min_mask = (uint32) bcm_strtoul(val, NULL, 0);
+		min_mask = (uint32) simple_strtoul(val, NULL, 0);
 	}
 	/* Apply nvram override to max mask */
 	val = getvar(NULL, "rmax");
 	if (val != NULL) {
 		PMU_MSG(("Applying rmax=%s to max_mask\n", val));
-		max_mask = (uint32) bcm_strtoul(val, NULL, 0);
+		max_mask = (uint32) simple_strtoul(val, NULL, 0);
 	}
 
 	*pmin = min_mask;
@@ -787,7 +788,7 @@ void BCMATTACHFN(si_pmu_res_init) (si_t
 			 val, i));
 		W_REG(osh, &cc->res_table_sel, (uint32) i);
 		W_REG(osh, &cc->res_updn_timer,
-		      (uint32) bcm_strtoul(val, NULL, 0));
+		      (uint32) simple_strtoul(val, NULL, 0));
 	}
 
 	/* Program resource dependencies table */
@@ -838,7 +839,7 @@ void BCMATTACHFN(si_pmu_res_init) (si_t
 			 i));
 		W_REG(osh, &cc->res_table_sel, (uint32) i);
 		W_REG(osh, &cc->res_dep_mask,
-		      (uint32) bcm_strtoul(val, NULL, 0));
+		      (uint32) simple_strtoul(val, NULL, 0));
 	}
 
 	/* Determine min/max rsrc masks */

commit 7d4df48eba4cea654ee6fe6e1a51a0600807ed7b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 17:04:47 2010 -0700

    Staging: brcm80211: s/uint16/u16/
    
    Use the kernel types, don't invent your own.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
@@ -390,7 +390,7 @@ uint32 bcmsdh_reg_read(void *sdh, uint32
 		switch (size) {
 		case sizeof(u8):
 			return word & 0xff;
-		case sizeof(uint16):
+		case sizeof(u16):
 			return word & 0xffff;
 		case sizeof(uint32):
 			return word;
--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
@@ -81,7 +81,7 @@ static bcmsdh_driver_t drvinfo = { NULL,
 /**
  * Checks to see if vendor and device IDs match a supported SDIO Host Controller.
  */
-bool bcmsdh_chipmatch(uint16 vendor, uint16 device)
+bool bcmsdh_chipmatch(u16 vendor, u16 device)
 {
 	/* Add other vendors and devices as required */
 
--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
@@ -479,7 +479,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 	case IOV_SVAL(IOV_BLOCKSIZE):
 		{
 			uint func = ((uint32) int_val >> 16);
-			uint blksize = (uint16) int_val;
+			uint blksize = (u16) int_val;
 			uint maxsize;
 
 			if (func > si->num_funcs) {
--- a/drivers/staging/brcm80211/brcmfmac/bcmutils.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmutils.c
@@ -307,9 +307,9 @@ void pktq_init(struct pktq *pq, int num_
 	bzero(pq,
 	      OFFSETOF(struct pktq, q) + (sizeof(struct pktq_prec) * num_prec));
 
-	pq->num_prec = (uint16) num_prec;
+	pq->num_prec = (u16) num_prec;
 
-	pq->max = (uint16) max_len;
+	pq->max = (u16) max_len;
 
 	for (prec = 0; prec < num_prec; prec++)
 		pq->q[prec].max = pq->max;
@@ -883,12 +883,12 @@ uint pktsetprio(void *pkt, bool update_v
 	int rc = 0;
 
 	pktdata = (u8 *) PKTDATA(pkt);
-	ASSERT(ISALIGNED((uintptr) pktdata, sizeof(uint16)));
+	ASSERT(ISALIGNED((uintptr) pktdata, sizeof(u16)));
 
 	eh = (struct ether_header *)pktdata;
 
 	if (ntoh16(eh->ether_type) == ETHER_TYPE_8021Q) {
-		uint16 vlan_tag;
+		u16 vlan_tag;
 		int vlan_prio, dscp_prio = 0;
 
 		evh = (struct ethervlan_header *)eh;
@@ -920,7 +920,7 @@ uint pktsetprio(void *pkt, bool update_v
 		 */
 		if (update_vtag && (priority != vlan_prio)) {
 			vlan_tag &= ~(VLAN_PRI_MASK << VLAN_PRI_SHIFT);
-			vlan_tag |= (uint16) priority << VLAN_PRI_SHIFT;
+			vlan_tag |= (u16) priority << VLAN_PRI_SHIFT;
 			evh->vlan_tag = hton16(vlan_tag);
 			rc |= PKTPRIO_UPD;
 		}
@@ -1124,7 +1124,7 @@ u8 hndcrc8(u8 *pdata,	/* pointer to arra
  * ****************************************************************************
  */
 
-static const uint16 crc16_table[256] = {
+static const u16 crc16_table[256] = {
 	0x0000, 0x1189, 0x2312, 0x329B, 0x4624, 0x57AD, 0x6536, 0x74BF,
 	0x8C48, 0x9DC1, 0xAF5A, 0xBED3, 0xCA6C, 0xDBE5, 0xE97E, 0xF8F7,
 	0x1081, 0x0108, 0x3393, 0x221A, 0x56A5, 0x472C, 0x75B7, 0x643E,
@@ -1159,9 +1159,9 @@ static const uint16 crc16_table[256] = {
 	0x7BC7, 0x6A4E, 0x58D5, 0x495C, 0x3DE3, 0x2C6A, 0x1EF1, 0x0F78
 };
 
-uint16 hndcrc16(u8 *pdata,	/* pointer to array of data to process */
+u16 hndcrc16(u8 *pdata,	/* pointer to array of data to process */
 		uint nbytes,	/* number of input data bytes to process */
-		uint16 crc	/* either CRC16_INIT_VALUE or previous
+		u16 crc	/* either CRC16_INIT_VALUE or previous
 				 return value */
 )
 {
@@ -1586,7 +1586,7 @@ uint bcm_mkiovar(char *name, char *data,
 /* Quarter dBm units to mW
  * Table starts at QDBM_OFFSET, so the first entry is mW for qdBm=153
  * Table is offset so the last entry is largest mW value that fits in
- * a uint16.
+ * a u16.
  */
 
 #define QDBM_OFFSET 153		/* Offset for first entry */
@@ -1604,7 +1604,7 @@ uint bcm_mkiovar(char *name, char *data,
  */
 #define QDBM_TABLE_HIGH_BOUND 64938	/* High bound */
 
-static const uint16 nqdBm_to_mW_map[QDBM_TABLE_LEN] = {
+static const u16 nqdBm_to_mW_map[QDBM_TABLE_LEN] = {
 /* qdBm: 	+0 	+1 	+2 	+3 	+4 	+5 	+6 	+7 */
 /* 153: */ 6683, 7079, 7499, 7943, 8414, 8913, 9441, 10000,
 /* 161: */ 10593, 11220, 11885, 12589, 13335, 14125, 14962, 15849,
@@ -1613,13 +1613,13 @@ static const uint16 nqdBm_to_mW_map[QDBM
 /* 185: */ 42170, 44668, 47315, 50119, 53088, 56234, 59566, 63096
 };
 
-uint16 bcm_qdbm_to_mw(u8 qdbm)
+u16 bcm_qdbm_to_mw(u8 qdbm)
 {
 	uint factor = 1;
 	int idx = qdbm - QDBM_OFFSET;
 
 	if (idx >= QDBM_TABLE_LEN) {
-		/* clamp to max uint16 mW value */
+		/* clamp to max u16 mW value */
 		return 0xFFFF;
 	}
 
@@ -1637,7 +1637,7 @@ uint16 bcm_qdbm_to_mw(u8 qdbm)
 	return (nqdBm_to_mW_map[idx] + factor / 2) / factor;
 }
 
-u8 bcm_mw_to_qdbm(uint16 mw)
+u8 bcm_mw_to_qdbm(u16 mw)
 {
 	u8 qdbm;
 	int offset;
--- a/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
@@ -52,7 +52,7 @@ extern int dhd_preinit_ioctls(dhd_pub_t
 				 */
 
 typedef struct dhd_prot {
-	uint16 reqid;
+	u16 reqid;
 	u8 pending;
 	uint32 lastcmd;
 	u8 bus_header[BUS_HEADER_LEN];
--- a/drivers/staging/brcm80211/brcmfmac/dhd_common.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_common.c
@@ -836,7 +836,7 @@ wl_host_event(struct dhd_info *dhd, int
 	bcm_event_t *pvt_data = (bcm_event_t *) pktdata;
 	char *event_data;
 	uint32 type, status;
-	uint16 flags;
+	u16 flags;
 	int evlen;
 
 	if (bcmp(BRCM_OUI, &pvt_data->bcm_hdr.oui[0], DOT11_OUI_LEN)) {
@@ -1674,7 +1674,7 @@ void dhd_iscan_ind_scan_confirm(void *dh
 	dhd_ind_scan_confirm(dhdp, status);
 }
 
-int dhd_iscan_request(void *dhdp, uint16 action)
+int dhd_iscan_request(void *dhdp, u16 action)
 {
 	int rc;
 	wl_iscan_params_t params;
--- a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
@@ -1249,7 +1249,7 @@ void dhd_txcomplete(dhd_pub_t *dhdp, voi
 	uint ifidx;
 	dhd_info_t *dhd = (dhd_info_t *) (dhdp->info);
 	struct ether_header *eh;
-	uint16 type;
+	u16 type;
 
 	dhd_prot_hdrpull(dhdp, &ifidx, txp);
 
--- a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
@@ -182,7 +182,7 @@ typedef struct dhd_bus {
 	bool dpc_sched;		/* Indicates DPC schedule (intrpt rcvd) */
 	bool fcstate;		/* State of dongle flow-control */
 
-	uint16 cl_devid;	/* cached devid for dhdsdio_probe_attach() */
+	u16 cl_devid;	/* cached devid for dhdsdio_probe_attach() */
 	char *fw_path;		/* module_param: path to firmware image */
 	char *nv_path;		/* module_param: path to nvram vars file */
 	const char *nvram_params;	/* user specified nvram params. */
@@ -197,7 +197,7 @@ typedef struct dhd_bus {
 
 	u8 hdrbuf[MAX_HDR_READ + DHD_SDALIGN];
 	u8 *rxhdr;		/* Header of current rx frame (in hdrbuf) */
-	uint16 nextlen;		/* Next Read Len from last header */
+	u16 nextlen;		/* Next Read Len from last header */
 	u8 rx_seq;		/* Receive sequence number (expected) */
 	bool rxskip;		/* Skip receive (awaiting NAK ACK) */
 
@@ -271,7 +271,7 @@ typedef struct dhd_bus {
 	uint pktgen_sent;	/* Number of test packets generated */
 	uint pktgen_rcvd;	/* Number of test packets received */
 	uint pktgen_fail;	/* Number of failed send attempts */
-	uint16 pktgen_len;	/* Length of next packet to send */
+	u16 pktgen_len;	/* Length of next packet to send */
 #endif				/* SDTEST */
 
 	/* Some additional counters */
@@ -432,9 +432,9 @@ static int dhdsdio_download_state(dhd_bu
 static void dhdsdio_release(dhd_bus_t *bus, osl_t *osh);
 static void dhdsdio_release_malloc(dhd_bus_t *bus, osl_t *osh);
 static void dhdsdio_disconnect(void *ptr);
-static bool dhdsdio_chipmatch(uint16 chipid);
+static bool dhdsdio_chipmatch(u16 chipid);
 static bool dhdsdio_probe_attach(dhd_bus_t *bus, osl_t *osh, void *sdh,
-				 void *regsva, uint16 devid);
+				 void *regsva, u16 devid);
 static bool dhdsdio_probe_malloc(dhd_bus_t *bus, osl_t *osh, void *sdh);
 static bool dhdsdio_probe_init(dhd_bus_t *bus, osl_t *osh, void *sdh);
 static void dhdsdio_release_dongle(dhd_bus_t *bus, osl_t * osh);
@@ -904,7 +904,7 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 	int ret;
 	osl_t *osh;
 	u8 *frame;
-	uint16 len, pad = 0;
+	u16 len, pad = 0;
 	uint32 swheader;
 	uint retries = 0;
 	bcmsdh_info_t *sdh;
@@ -960,9 +960,9 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 	ASSERT(pad < DHD_SDALIGN);
 
 	/* Hardware tag: 2 byte len followed by 2 byte ~len check (all LE) */
-	len = (uint16) PKTLEN(pkt);
-	*(uint16 *) frame = htol16(len);
-	*(((uint16 *) frame) + 1) = htol16(~len);
+	len = (u16) PKTLEN(pkt);
+	*(u16 *) frame = htol16(len);
+	*(((u16 *) frame) + 1) = htol16(~len);
 
 	/* Software tag: channel, sequence number, data offset */
 	swheader =
@@ -985,7 +985,7 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 
 	/* Raise len to next SDIO block to eliminate tail command */
 	if (bus->roundup && bus->blocksize && (len > bus->blocksize)) {
-		uint16 pad = bus->blocksize - (len % bus->blocksize);
+		u16 pad = bus->blocksize - (len % bus->blocksize);
 		if ((pad <= bus->roundup) && (pad < bus->blocksize))
 #ifdef NOTUSED
 			if (pad <= PKTTAILROOM(pkt))
@@ -1222,7 +1222,7 @@ static uint dhdsdio_sendfromq(dhd_bus_t
 int dhd_bus_txctl(struct dhd_bus *bus, unsigned char *msg, uint msglen)
 {
 	u8 *frame;
-	uint16 len;
+	u16 len;
 	uint32 swheader;
 	uint retries = 0;
 	bcmsdh_info_t *sdh = bus->sdh;
@@ -1254,7 +1254,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 
 	/* Round send length to next SDIO block */
 	if (bus->roundup && bus->blocksize && (len > bus->blocksize)) {
-		uint16 pad = bus->blocksize - (len % bus->blocksize);
+		u16 pad = bus->blocksize - (len % bus->blocksize);
 		if ((pad <= bus->roundup) && (pad < bus->blocksize))
 			len += pad;
 	} else if (len % DHD_SDALIGN) {
@@ -1276,8 +1276,8 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
 
 	/* Hardware tag: 2 byte len followed by 2 byte ~len check (all LE) */
-	*(uint16 *) frame = htol16((uint16) msglen);
-	*(((uint16 *) frame) + 1) = htol16(~msglen);
+	*(u16 *) frame = htol16((u16) msglen);
+	*(((u16 *) frame) + 1) = htol16(~msglen);
 
 	/* Software tag: channel, sequence number, data offset */
 	swheader =
@@ -3009,7 +3009,7 @@ static void dhdsdio_rxfail(dhd_bus_t *bu
 	bcmsdh_info_t *sdh = bus->sdh;
 	sdpcmd_regs_t *regs = bus->regs;
 	uint retries = 0;
-	uint16 lastrbc;
+	u16 lastrbc;
 	u8 hi, lo;
 	int err;
 
@@ -3173,10 +3173,10 @@ done:
 
 static u8 dhdsdio_rxglom(dhd_bus_t *bus, u8 rxseq)
 {
-	uint16 dlen, totlen;
+	u16 dlen, totlen;
 	u8 *dptr, num = 0;
 
-	uint16 sublen, check;
+	u16 sublen, check;
 	void *pfirst, *plast, *pnext, *save_pfirst;
 	osl_t *osh = bus->dhd->osh;
 
@@ -3198,7 +3198,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 		dhd_os_sdlock_rxq(bus->dhd);
 
 		pfirst = plast = pnext = NULL;
-		dlen = (uint16) PKTLEN(bus->glomd);
+		dlen = (u16) PKTLEN(bus->glomd);
 		dptr = PKTDATA(bus->glomd);
 		if (!dlen || (dlen & 1)) {
 			DHD_ERROR(("%s: bad glomd len(%d), ignore descriptor\n",
@@ -3209,8 +3209,8 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 		for (totlen = num = 0; dlen; num++) {
 			/* Get (and move past) next length */
 			sublen = ltoh16_ua(dptr);
-			dlen -= sizeof(uint16);
-			dptr += sizeof(uint16);
+			dlen -= sizeof(u16);
+			dptr += sizeof(u16);
 			if ((sublen < SDPCM_HDRLEN) ||
 			    ((num == 0) && (sublen < (2 * SDPCM_HDRLEN)))) {
 				DHD_ERROR(("%s: descriptor len %d bad: %d\n",
@@ -3297,7 +3297,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 		}
 
 		pfirst = bus->glom;
-		dlen = (uint16) pkttotlen(osh, pfirst);
+		dlen = (u16) pkttotlen(osh, pfirst);
 
 		/* Do an SDIO read for the superframe.  Configurable iovar to
 		 * read directly into the chained packet, or allocate a large
@@ -3317,7 +3317,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 						      F2SYNC, bus->dataptr,
 						      dlen, NULL, NULL, NULL);
 			sublen =
-			    (uint16) pktfrombuf(osh, pfirst, 0, dlen,
+			    (u16) pktfrombuf(osh, pfirst, 0, dlen,
 						bus->dataptr);
 			if (sublen != dlen) {
 				DHD_ERROR(("%s: FAILED TO COPY, dlen %d sublen %d\n",
@@ -3362,7 +3362,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 		/* Validate the superframe header */
 		dptr = (u8 *) PKTDATA(pfirst);
 		sublen = ltoh16_ua(dptr);
-		check = ltoh16_ua(dptr + sizeof(uint16));
+		check = ltoh16_ua(dptr + sizeof(u16));
 
 		chan = SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN]);
 		seq = SDPCM_PACKET_SEQUENCE(&dptr[SDPCM_FRAMETAG_LEN]);
@@ -3376,7 +3376,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 		txmax = SDPCM_WINDOW_VALUE(&dptr[SDPCM_FRAMETAG_LEN]);
 
 		errcode = 0;
-		if ((uint16)~(sublen ^ check)) {
+		if ((u16)~(sublen ^ check)) {
 			DHD_ERROR(("%s (superframe): HW hdr error: len/check "
 				"0x%04x/0x%04x\n", __func__, sublen, check));
 			errcode = -1;
@@ -3430,9 +3430,9 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 		for (num = 0, pnext = pfirst; pnext && !errcode;
 		     num++, pnext = PKTNEXT(pnext)) {
 			dptr = (u8 *) PKTDATA(pnext);
-			dlen = (uint16) PKTLEN(pnext);
+			dlen = (u16) PKTLEN(pnext);
 			sublen = ltoh16_ua(dptr);
-			check = ltoh16_ua(dptr + sizeof(uint16));
+			check = ltoh16_ua(dptr + sizeof(u16));
 			chan = SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN]);
 			doff = SDPCM_DOFFSET_VALUE(&dptr[SDPCM_FRAMETAG_LEN]);
 #ifdef DHD_DEBUG
@@ -3440,7 +3440,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 				prhex("subframe", dptr, 32);
 #endif
 
-			if ((uint16)~(sublen ^ check)) {
+			if ((u16)~(sublen ^ check)) {
 				DHD_ERROR(("%s (subframe %d): HW hdr error: "
 					   "len/check 0x%04x/0x%04x\n",
 					   __func__, num, sublen, check));
@@ -3582,14 +3582,14 @@ static uint dhdsdio_readframes(dhd_bus_t
 	osl_t *osh = bus->dhd->osh;
 	bcmsdh_info_t *sdh = bus->sdh;
 
-	uint16 len, check;	/* Extracted hardware header fields */
+	u16 len, check;	/* Extracted hardware header fields */
 	u8 chan, seq, doff;	/* Extracted software header fields */
 	u8 fcbits;		/* Extracted fcbits from software header */
 	u8 delta;
 
 	void *pkt;		/* Packet for event or data frames */
-	uint16 pad;		/* Number of pad bytes to read */
-	uint16 rdlen;		/* Total number of bytes to read */
+	u16 pad;		/* Number of pad bytes to read */
+	u16 rdlen;		/* Total number of bytes to read */
 	u8 rxseq;		/* Next sequence number to expect */
 	uint rxleft = 0;	/* Remaining number of frames allowed */
 	int sdret;		/* Return code from bcmsdh calls */
@@ -3637,7 +3637,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 
 		/* Try doing single read if we can */
 		if (dhd_readahead && bus->nextlen) {
-			uint16 nextlen = bus->nextlen;
+			u16 nextlen = bus->nextlen;
 			bus->nextlen = 0;
 
 			if (bus->bus == SPI_BUS) {
@@ -3768,7 +3768,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 
 			/* Extract hardware header fields */
 			len = ltoh16_ua(bus->rxhdr);
-			check = ltoh16_ua(bus->rxhdr + sizeof(uint16));
+			check = ltoh16_ua(bus->rxhdr + sizeof(u16));
 
 			/* All zeros means readahead info was bad */
 			if (!(len | check)) {
@@ -3782,7 +3782,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 			}
 
 			/* Validate check bytes */
-			if ((uint16)~(len ^ check)) {
+			if ((u16)~(len ^ check)) {
 				DHD_ERROR(("%s (nextlen): HW hdr error: nextlen/len/check" " 0x%04x/0x%04x/0x%04x\n",
 					__func__, nextlen, len, check));
 				dhd_os_sdlock_rxq(bus->dhd);
@@ -3960,7 +3960,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 
 		/* Extract hardware header fields */
 		len = ltoh16_ua(bus->rxhdr);
-		check = ltoh16_ua(bus->rxhdr + sizeof(uint16));
+		check = ltoh16_ua(bus->rxhdr + sizeof(u16));
 
 		/* All zeros means no more frames */
 		if (!(len | check)) {
@@ -3969,7 +3969,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 		}
 
 		/* Validate check bytes */
-		if ((uint16) ~(len ^ check)) {
+		if ((u16) ~(len ^ check)) {
 			DHD_ERROR(("%s: HW hdr err: len/check 0x%04x/0x%04x\n",
 				__func__, len, check));
 			bus->rx_badhdr++;
@@ -4611,7 +4611,7 @@ static void dhdsdio_pktgen_init(dhd_bus_
 		bus->pktgen_maxlen = MAX_PKTGEN_LEN;
 		bus->pktgen_minlen = 0;
 	}
-	bus->pktgen_len = (uint16) bus->pktgen_minlen;
+	bus->pktgen_len = (u16) bus->pktgen_minlen;
 
 	/* Default to per-watchdog burst with 10s print time */
 	bus->pktgen_freq = 1;
@@ -4630,7 +4630,7 @@ static void dhdsdio_pktgen(dhd_bus_t *bu
 	uint pktcount;
 	uint fillbyte;
 	osl_t *osh = bus->dhd->osh;
-	uint16 len;
+	u16 len;
 
 	/* Display current count if appropriate */
 	if (bus->pktgen_print && (++bus->pktgen_ptick >= bus->pktgen_print)) {
@@ -4722,7 +4722,7 @@ static void dhdsdio_pktgen(dhd_bus_t *bu
 
 		/* Bump length if not fixed, wrap at max */
 		if (++bus->pktgen_len > bus->pktgen_maxlen)
-			bus->pktgen_len = (uint16) bus->pktgen_minlen;
+			bus->pktgen_len = (u16) bus->pktgen_minlen;
 
 		/* Special case for burst mode: just send one request! */
 		if (bus->pktgen_mode == DHD_PKTGEN_RXBURST)
@@ -4765,8 +4765,8 @@ static void dhdsdio_testrcv(dhd_bus_t *b
 
 	u8 cmd;
 	u8 extra;
-	uint16 len;
-	uint16 offset;
+	u16 len;
+	u16 offset;
 
 	/* Check for min length */
 	pktlen = PKTLEN(pkt);
@@ -5047,7 +5047,7 @@ static void dhd_dump_cis(uint fn, u8 *ci
 }
 #endif				/* DHD_DEBUG */
 
-static bool dhdsdio_chipmatch(uint16 chipid)
+static bool dhdsdio_chipmatch(u16 chipid)
 {
 	if (chipid == BCM4325_CHIP_ID)
 		return TRUE;
@@ -5058,8 +5058,8 @@ static bool dhdsdio_chipmatch(uint16 chi
 	return FALSE;
 }
 
-static void *dhdsdio_probe(uint16 venid, uint16 devid, uint16 bus_no,
-			   uint16 slot, uint16 func, uint bustype, void *regsva,
+static void *dhdsdio_probe(u16 venid, u16 devid, u16 bus_no,
+			   u16 slot, u16 func, uint bustype, void *regsva,
 			   osl_t *osh, void *sdh)
 {
 	int ret;
@@ -5154,7 +5154,7 @@ static void *dhdsdio_probe(uint16 venid,
 	}
 	bzero(bus, sizeof(dhd_bus_t));
 	bus->sdh = sdh;
-	bus->cl_devid = (uint16) devid;
+	bus->cl_devid = (u16) devid;
 	bus->bus = DHD_BUS;
 	bus->tx_seq = SDPCM_SEQUENCE_WRAP - 1;
 	bus->usebufpool = FALSE;	/* Use bufpool if allocated,
@@ -5221,7 +5221,7 @@ fail:
 
 static bool
 dhdsdio_probe_attach(struct dhd_bus *bus, osl_t *osh, void *sdh, void *regsva,
-		     uint16 devid)
+		     u16 devid)
 {
 	u8 clkctl = 0;
 	int err = 0;
@@ -5315,7 +5315,7 @@ dhdsdio_probe_attach(struct dhd_bus *bus
 
 	bcmsdh_chipinfo(sdh, bus->sih->chip, bus->sih->chiprev);
 
-	if (!dhdsdio_chipmatch((uint16) bus->sih->chip)) {
+	if (!dhdsdio_chipmatch((u16) bus->sih->chip)) {
 		DHD_ERROR(("%s: unsupported chip: 0x%04x\n",
 			   __func__, bus->sih->chip));
 		goto fail;
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
@@ -86,7 +86,7 @@ static int32 wl_cfg80211_set_bitrate_mas
 static int wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 			       struct cfg80211_connect_params *sme);
 static int32 wl_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
-				    uint16 reason_code);
+				    u16 reason_code);
 static int32 wl_cfg80211_set_tx_power(struct wiphy *wiphy,
 				      enum nl80211_tx_power_setting type,
 				      int32 dbm);
@@ -203,8 +203,8 @@ static int32 wl_get_assoc_ies(struct wl_
 */
 static void wl_rst_ie(struct wl_priv *wl);
 static int32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v);
-static int32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, uint16 ie_size);
-static int32 wl_cp_ie(struct wl_priv *wl, u8 *dst, uint16 dst_size);
+static int32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, u16 ie_size);
+static int32 wl_cp_ie(struct wl_priv *wl, u8 *dst, u16 dst_size);
 static uint32 wl_get_ielen(struct wl_priv *wl);
 
 static int32 wl_mode_to_nl80211_iftype(int32 mode);
@@ -298,7 +298,7 @@ static int32 wl_dev_iovar_getbuf(struct
 				 void *param, int32 paramlen, void *bufptr,
 				 int32 buflen);
 static int32 wl_run_iscan(struct wl_iscan_ctrl *iscan, struct wlc_ssid *ssid,
-			  uint16 action);
+			  u16 action);
 static int32 wl_do_iscan(struct wl_priv *wl);
 static int32 wl_wakeup_iscan(struct wl_iscan_ctrl *iscan);
 static int32 wl_invoke_iscan(struct wl_priv *wl);
@@ -319,7 +319,7 @@ static void wl_init_fw(struct wl_fw_ctrl
 /*
 * find most significant bit set
 */
-static __used uint32 wl_find_msb(uint16 bit16);
+static __used uint32 wl_find_msb(u16 bit16);
 
 /*
 * update pmklist to dongle
@@ -686,7 +686,7 @@ wl_dev_iovar_getbuf(struct net_device *d
 }
 
 static int32
-wl_run_iscan(struct wl_iscan_ctrl *iscan, struct wlc_ssid *ssid, uint16 action)
+wl_run_iscan(struct wl_iscan_ctrl *iscan, struct wlc_ssid *ssid, u16 action)
 {
 	int32 params_size =
 	    (WL_SCAN_PARAMS_FIXED_SIZE + OFFSETOF(wl_iscan_params_t, params));
@@ -1380,7 +1380,7 @@ wl_cfg80211_connect(struct wiphy *wiphy,
 
 static int32
 wl_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
-		       uint16 reason_code)
+		       u16 reason_code)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	scb_val_t scbval;
@@ -1412,7 +1412,7 @@ wl_cfg80211_set_tx_power(struct wiphy *w
 
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	struct net_device *ndev = wl_to_ndev(wl);
-	uint16 txpwrmw;
+	u16 txpwrmw;
 	int32 err = 0;
 	int32 disable = 0;
 
@@ -1445,7 +1445,7 @@ wl_cfg80211_set_tx_power(struct wiphy *w
 	if (dbm > 0xffff)
 		txpwrmw = 0xffff;
 	else
-		txpwrmw = (uint16) dbm;
+		txpwrmw = (u16) dbm;
 	err = wl_dev_intvar_set(ndev, "qtxpower",
 			(int32) (bcm_mw_to_qdbm(txpwrmw)));
 	if (unlikely(err)) {
@@ -1867,7 +1867,7 @@ wl_cfg80211_set_power_mgmt(struct wiphy
 	return err;
 }
 
-static __used uint32 wl_find_msb(uint16 bit16)
+static __used uint32 wl_find_msb(u16 bit16)
 {
 	uint32 ret = 0;
 
@@ -2317,7 +2317,7 @@ static int32 wl_inform_single_bss(struct
 static bool wl_is_linkup(struct wl_priv *wl, const wl_event_msg_t *e)
 {
 	uint32 event = ntoh32(e->event_type);
-	uint16 flags = ntoh16(e->flags);
+	u16 flags = ntoh16(e->flags);
 
 	if (event == WLC_E_JOIN || event == WLC_E_ASSOC_IND
 	    || event == WLC_E_REASSOC_IND) {
@@ -2339,7 +2339,7 @@ static bool wl_is_linkup(struct wl_priv
 static bool wl_is_linkdown(struct wl_priv *wl, const wl_event_msg_t *e)
 {
 	uint32 event = ntoh32(e->event_type);
-	uint16 flags = ntoh16(e->flags);
+	u16 flags = ntoh16(e->flags);
 
 	if (event == WLC_E_DEAUTH_IND || event == WLC_E_DISASSOC_IND) {
 		return TRUE;
@@ -2602,7 +2602,7 @@ static int32
 wl_notify_mic_status(struct wl_priv *wl, struct net_device *ndev,
 		     const wl_event_msg_t *e, void *data)
 {
-	uint16 flags = ntoh16(e->flags);
+	u16 flags = ntoh16(e->flags);
 	enum nl80211_key_type key_type;
 
 	rtnl_lock();
@@ -3897,7 +3897,7 @@ static int32 wl_add_ie(struct wl_priv *w
 	return err;
 }
 
-static int32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, uint16 ie_size)
+static int32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, u16 ie_size)
 {
 	struct wl_ie *ie = wl_to_ie(wl);
 	int32 err = 0;
@@ -3912,7 +3912,7 @@ static int32 wl_mrg_ie(struct wl_priv *w
 	return err;
 }
 
-static int32 wl_cp_ie(struct wl_priv *wl, u8 *dst, uint16 dst_size)
+static int32 wl_cp_ie(struct wl_priv *wl, u8 *dst, u16 dst_size)
 {
 	struct wl_ie *ie = wl_to_ie(wl);
 	int32 err = 0;
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
@@ -180,10 +180,10 @@ struct wl_dev {
 
 /* bss inform structure for cfg80211 interface */
 struct wl_cfg80211_bss_info {
-	uint16 band;
-	uint16 channel;
+	u16 band;
+	u16 channel;
 	int16 rssi;
-	uint16 frame_len;
+	u16 frame_len;
 	u8 frame_buf[1];
 };
 
@@ -194,7 +194,7 @@ struct wl_scan_req {
 
 /* basic structure of information element */
 struct wl_ie {
-	uint16 offset;
+	u16 offset;
 	u8 buf[WL_TLV_INFO_MAX];
 };
 
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -148,7 +148,7 @@ typedef struct iscan_info {
 iscan_info_t *g_iscan;
 static void wl_iw_timerfunc(unsigned long data);
 static void wl_iw_set_event_mask(struct net_device *dev);
-static int wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, uint16 action);
+static int wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, u16 action);
 #endif				/* defined(WL_IW_USE_ISCAN) */
 
 static int
@@ -503,7 +503,7 @@ wl_iw_get_range(struct net_device *dev,
 	int bw_cap = 0, sgi_tx = 0, nmode = 0;
 	channel_info_t ci;
 	u8 nrate_list2copy = 0;
-	uint16 nrate_list[4][8] = { {13, 26, 39, 52, 78, 104, 117, 130},
+	u16 nrate_list[4][8] = { {13, 26, 39, 52, 78, 104, 117, 130},
 	{14, 29, 43, 58, 87, 116, 130, 144},
 	{27, 54, 81, 108, 162, 216, 243, 270},
 	{30, 60, 90, 120, 180, 240, 270, 300}
@@ -1048,7 +1048,7 @@ static int wl_iw_iscan_prep(wl_scan_para
 	return err;
 }
 
-static int wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, uint16 action)
+static int wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, u16 action)
 {
 	int err = 0;
 
@@ -2172,7 +2172,7 @@ wl_iw_set_txpow(struct net_device *dev,
 		struct iw_param *vwrq, char *extra)
 {
 	int error, disable;
-	uint16 txpwrmw;
+	u16 txpwrmw;
 	WL_TRACE(("%s: SIOCSIWTXPOW\n", dev->name));
 
 	disable = vwrq->disabled ? WL_RADIO_SW_DISABLE : 0;
@@ -2195,7 +2195,7 @@ wl_iw_set_txpow(struct net_device *dev,
 	if (vwrq->value > 0xffff)
 		txpwrmw = 0xffff;
 	else
-		txpwrmw = (uint16) vwrq->value;
+		txpwrmw = (u16) vwrq->value;
 
 	error =
 	    dev_wlc_intvar_set(dev, "qtxpower", (int)(bcm_mw_to_qdbm(txpwrmw)));
@@ -3402,7 +3402,7 @@ void wl_iw_event(struct net_device *dev,
 	char extra[IW_CUSTOM_MAX + 1];
 	int cmd = 0;
 	uint32 event_type = ntoh32(e->event_type);
-	uint16 flags = ntoh16(e->flags);
+	u16 flags = ntoh16(e->flags);
 	uint32 datalen = ntoh32(e->datalen);
 	uint32 status = ntoh32(e->status);
 	wl_iw_t *iw;
@@ -3709,7 +3709,7 @@ int wl_iw_attach(struct net_device *dev,
 #ifdef CSCAN
 	params_size =
 	    (WL_SCAN_PARAMS_FIXED_SIZE + OFFSETOF(wl_iscan_params_t, params)) +
-	    (WL_NUMCHANNELS * sizeof(uint16)) +
+	    (WL_NUMCHANNELS * sizeof(u16)) +
 	    WL_SCAN_PARAMS_SSID_MAX * sizeof(wlc_ssid_t);
 #else
 	params_size =
--- a/drivers/staging/brcm80211/include/bcm_rpc.h
+++ b/drivers/staging/brcm80211/include/bcm_rpc.h
@@ -74,7 +74,7 @@ extern int bcm_rpc_dump(rpc_info_t *rpci
 #define RPC_TRACE_VAL	0x0002
 #define RPC_PKTTRACE_VAL 0x0004
 #define RPC_PKTLOG_VAL	0x0008
-extern void bcm_rpc_msglevel_set(struct rpc_info *rpci, uint16 msglevel,
+extern void bcm_rpc_msglevel_set(struct rpc_info *rpci, u16 msglevel,
 				 bool high_low);
 
 #endif				/* _BCM_RPC_H_ */
--- a/drivers/staging/brcm80211/include/bcm_rpc_tp.h
+++ b/drivers/staging/brcm80211/include/bcm_rpc_tp.h
@@ -114,9 +114,9 @@ extern void bcm_rpc_tp_txq_wm_get(rpc_tp
 
 extern void bcm_rpc_tp_agg_set(rpc_tp_info_t *rpcb, uint32 reason, bool set);
 extern void bcm_rpc_tp_agg_limit_set(rpc_tp_info_t *rpc_th, u8 sf,
-				     uint16 bytes);
+				     u16 bytes);
 extern void bcm_rpc_tp_agg_limit_get(rpc_tp_info_t *rpc_th, u8 *sf,
-				     uint16 *bytes);
+				     u16 *bytes);
 
 #define BCM_RPC_TP_MSG_LEVEL_MASK	0x00ff
 /* dongle msg level */
--- a/drivers/staging/brcm80211/include/bcm_xdr.h
+++ b/drivers/staging/brcm80211/include/bcm_xdr.h
@@ -49,8 +49,8 @@ int bcm_xdr_unpack_string(bcm_xdr_buf_t
 
 int bcm_xdr_pack_u8_vec(bcm_xdr_buf_t *, u8 *vec, uint32 elems);
 int bcm_xdr_unpack_u8_vec(bcm_xdr_buf_t *, u8 *vec, uint32 elems);
-int bcm_xdr_pack_uint16_vec(bcm_xdr_buf_t *b, uint len, void *vec);
-int bcm_xdr_unpack_uint16_vec(bcm_xdr_buf_t *b, uint len, void *vec);
+int bcm_xdr_pack_u16_vec(bcm_xdr_buf_t *b, uint len, void *vec);
+int bcm_xdr_unpack_u16_vec(bcm_xdr_buf_t *b, uint len, void *vec);
 int bcm_xdr_pack_uint32_vec(bcm_xdr_buf_t *b, uint len, void *vec);
 int bcm_xdr_unpack_uint32_vec(bcm_xdr_buf_t *b, uint len, void *vec);
 
--- a/drivers/staging/brcm80211/include/bcmendian.h
+++ b/drivers/staging/brcm80211/include/bcmendian.h
@@ -21,8 +21,8 @@
 
 /* Reverse the bytes in a 16-bit value */
 #define BCMSWAP16(val) \
-	((uint16)((((uint16)(val) & (uint16)0x00ffU) << 8) | \
-		  (((uint16)(val) & (uint16)0xff00U) >> 8)))
+	((u16)((((u16)(val) & (u16)0x00ffU) << 8) | \
+		  (((u16)(val) & (u16)0xff00U) >> 8)))
 
 /* Reverse the bytes in a 32-bit value */
 #define BCMSWAP32(val) \
@@ -82,8 +82,8 @@
 #define ltoh16_buf(buf, i)
 #define htol16_buf(buf, i)
 #else
-#define ltoh16_buf(buf, i) bcmswap16_buf((uint16 *)(buf), (i))
-#define htol16_buf(buf, i) bcmswap16_buf((uint16 *)(buf), (i))
+#define ltoh16_buf(buf, i) bcmswap16_buf((u16 *)(buf), (i))
+#define htol16_buf(buf, i) bcmswap16_buf((u16 *)(buf), (i))
 #endif				/* IL_BIGENDIAN */
 
 /* Unaligned loads and stores in host byte order */
@@ -106,13 +106,13 @@
 
 #define ltoh_ua(ptr) \
 	(sizeof(*(ptr)) == sizeof(u8) ? *(const u8 *)(ptr) : \
-	 sizeof(*(ptr)) == sizeof(uint16) ? _LTOH16_UA((const u8 *)(ptr)) : \
+	 sizeof(*(ptr)) == sizeof(u16) ? _LTOH16_UA((const u8 *)(ptr)) : \
 	 sizeof(*(ptr)) == sizeof(uint32) ? _LTOH32_UA((const u8 *)(ptr)) : \
 	 *(u8 *)0)
 
 #define ntoh_ua(ptr) \
 	(sizeof(*(ptr)) == sizeof(u8) ? *(const u8 *)(ptr) : \
-	 sizeof(*(ptr)) == sizeof(uint16) ? _NTOH16_UA((const u8 *)(ptr)) : \
+	 sizeof(*(ptr)) == sizeof(u16) ? _NTOH16_UA((const u8 *)(ptr)) : \
 	 sizeof(*(ptr)) == sizeof(uint32) ? _NTOH32_UA((const u8 *)(ptr)) : \
 	 *(u8 *)0)
 
@@ -123,7 +123,7 @@
  */
 
 #define bcmswap16(val) ({ \
-	uint16 _val = (val); \
+	u16 _val = (val); \
 	BCMSWAP16(_val); \
 })
 
@@ -138,7 +138,7 @@
 })
 
 #define bcmswap16_buf(buf, len) ({ \
-	uint16 *_buf = (uint16 *)(buf); \
+	u16 *_buf = (u16 *)(buf); \
 	uint _wds = (len) / 2; \
 	while (_wds--) { \
 		*_buf = bcmswap16(*_buf); \
@@ -147,7 +147,7 @@
 })
 
 #define htol16_ua_store(val, bytes) ({ \
-	uint16 _val = (val); \
+	u16 _val = (val); \
 	u8 *_bytes = (u8 *)(bytes); \
 	_bytes[0] = _val & 0xff; \
 	_bytes[1] = _val >> 8; \
@@ -163,7 +163,7 @@
 })
 
 #define hton16_ua_store(val, bytes) ({ \
-	uint16 _val = (val); \
+	u16 _val = (val); \
 	u8 *_bytes = (u8 *)(bytes); \
 	_bytes[0] = _val >> 8; \
 	_bytes[1] = _val & 0xff; \
@@ -201,7 +201,7 @@
 #else				/* !__GNUC__ */
 
 /* Inline versions avoid referencing the argument multiple times */
-static inline uint16 bcmswap16(uint16 val)
+static inline u16 bcmswap16(u16 val)
 {
 	return BCMSWAP16(val);
 }
@@ -219,7 +219,7 @@ static inline uint32 bcmswap32by16(uint3
 /* Reverse pairs of bytes in a buffer (not for high-performance use) */
 /* buf	- start of buffer of shorts to swap */
 /* len  - byte length of buffer */
-static inline void bcmswap16_buf(uint16 *buf, uint len)
+static inline void bcmswap16_buf(u16 *buf, uint len)
 {
 	len = len / 2;
 
@@ -232,7 +232,7 @@ static inline void bcmswap16_buf(uint16
 /*
  * Store 16-bit value to unaligned little-endian byte array.
  */
-static inline void htol16_ua_store(uint16 val, u8 *bytes)
+static inline void htol16_ua_store(u16 val, u8 *bytes)
 {
 	bytes[0] = val & 0xff;
 	bytes[1] = val >> 8;
@@ -252,7 +252,7 @@ static inline void htol32_ua_store(uint3
 /*
  * Store 16-bit value to unaligned network-(big-)endian byte array.
  */
-static inline void hton16_ua_store(uint16 val, u8 *bytes)
+static inline void hton16_ua_store(u16 val, u8 *bytes)
 {
 	bytes[0] = val >> 8;
 	bytes[1] = val & 0xff;
@@ -272,7 +272,7 @@ static inline void hton32_ua_store(uint3
 /*
  * Load 16-bit value from unaligned little-endian byte array.
  */
-static inline uint16 ltoh16_ua(const void *bytes)
+static inline u16 ltoh16_ua(const void *bytes)
 {
 	return _LTOH16_UA((const u8 *)bytes);
 }
@@ -288,7 +288,7 @@ static inline uint32 ltoh32_ua(const voi
 /*
  * Load 16-bit value from unaligned big-(network-)endian byte array.
  */
-static inline uint16 ntoh16_ua(const void *bytes)
+static inline u16 ntoh16_ua(const void *bytes)
 {
 	return _NTOH16_UA((const u8 *)bytes);
 }
--- a/drivers/staging/brcm80211/include/bcmotp.h
+++ b/drivers/staging/brcm80211/include/bcmotp.h
@@ -36,9 +36,9 @@
 /* Exported functions */
 extern int otp_status(void *oh);
 extern int otp_size(void *oh);
-extern uint16 otp_read_bit(void *oh, uint offset);
+extern u16 otp_read_bit(void *oh, uint offset);
 extern void *otp_init(si_t *sih);
-extern int otp_read_region(si_t *sih, int region, uint16 *data, uint *wlen);
+extern int otp_read_region(si_t *sih, int region, u16 *data, uint *wlen);
 extern int otp_nvread(void *oh, char *data, uint *len);
 
 #endif				/* _bcmotp_h_ */
--- a/drivers/staging/brcm80211/include/bcmsdh.h
+++ b/drivers/staging/brcm80211/include/bcmsdh.h
@@ -173,8 +173,8 @@ extern void *bcmsdh_get_sdioh(bcmsdh_inf
 /* callback functions */
 typedef struct {
 	/* attach to device */
-	void *(*attach) (uint16 vend_id, uint16 dev_id, uint16 bus, uint16 slot,
-			 uint16 func, uint bustype, void *regsva, osl_t *osh,
+	void *(*attach) (u16 vend_id, u16 dev_id, u16 bus, u16 slot,
+			 u16 func, uint bustype, void *regsva, osl_t *osh,
 			 void *param);
 	/* detach from device */
 	void (*detach) (void *ch);
@@ -183,7 +183,7 @@ typedef struct {
 /* platform specific/high level functions */
 extern int bcmsdh_register(bcmsdh_driver_t *driver);
 extern void bcmsdh_unregister(void);
-extern bool bcmsdh_chipmatch(uint16 vendor, uint16 device);
+extern bool bcmsdh_chipmatch(u16 vendor, u16 device);
 extern void bcmsdh_device_remove(void *sdh);
 
 /* Function to pass device-status bits to DHD. */
--- a/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
+++ b/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
@@ -56,7 +56,7 @@ struct sdioh_info {
 	bool intr_handler_valid;	/* client driver interrupt handler valid */
 	sdioh_cb_fn_t intr_handler;	/* registered interrupt handler */
 	void *intr_handler_arg;	/* argument to call interrupt handler */
-	uint16 intmask;		/* Current active interrupts */
+	u16 intmask;		/* Current active interrupts */
 	void *sdos_info;	/* Pointer to per-OS private data */
 
 	uint irq;		/* Client irq */
--- a/drivers/staging/brcm80211/include/bcmsrom.h
+++ b/drivers/staging/brcm80211/include/bcmsrom.h
@@ -24,7 +24,7 @@ extern int srom_var_init(si_t *sih, uint
 			 char **vars, uint *count);
 
 extern int srom_read(si_t *sih, uint bus, void *curmap, osl_t *osh,
-		     uint byteoff, uint nbytes, uint16 *buf, bool check_crc);
+		     uint byteoff, uint nbytes, u16 *buf, bool check_crc);
 
 /* parse standard PCMCIA cis, normally used by SB/PCMCIA/SDIO/SPI/OTP
  *   and extract from it into name=value pairs
--- a/drivers/staging/brcm80211/include/bcmsrom_tbl.h
+++ b/drivers/staging/brcm80211/include/bcmsrom_tbl.h
@@ -24,8 +24,8 @@ typedef struct {
 	const char *name;
 	uint32 revmask;
 	uint32 flags;
-	uint16 off;
-	uint16 mask;
+	u16 off;
+	u16 mask;
 } sromvar_t;
 
 #define SRFL_MORE	1	/* value continues as described by the next entry */
@@ -447,9 +447,9 @@ static const sromvar_t perpath_pci_sromv
 #endif				/* !defined(PHY_TYPE_NULL) */
 
 typedef struct {
-	uint16 phy_type;
-	uint16 bandrange;
-	uint16 chain;
+	u16 phy_type;
+	u16 bandrange;
+	u16 chain;
 	const char *vars;
 } pavars_t;
 
@@ -476,8 +476,8 @@ static const pavars_t pavars[] = {
 };
 
 typedef struct {
-	uint16 phy_type;
-	uint16 bandrange;
+	u16 phy_type;
+	u16 bandrange;
 	const char *vars;
 } povars_t;
 
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -92,26 +92,26 @@ extern "C" {
 	typedef struct pktq_prec {
 		void *head;	/* first packet to dequeue */
 		void *tail;	/* last packet to dequeue */
-		uint16 len;	/* number of queued packets */
-		uint16 max;	/* maximum number of queued packets */
+		u16 len;	/* number of queued packets */
+		u16 max;	/* maximum number of queued packets */
 	} pktq_prec_t;
 
 /* multi-priority pkt queue */
 	struct pktq {
-		uint16 num_prec;	/* number of precedences in use */
-		uint16 hi_prec;	/* rapid dequeue hint (>= highest non-empty prec) */
-		uint16 max;	/* total max packets */
-		uint16 len;	/* total number of packets */
+		u16 num_prec;	/* number of precedences in use */
+		u16 hi_prec;	/* rapid dequeue hint (>= highest non-empty prec) */
+		u16 max;	/* total max packets */
+		u16 len;	/* total number of packets */
 		/* q array must be last since # of elements can be either PKTQ_MAX_PREC or 1 */
 		struct pktq_prec q[PKTQ_MAX_PREC];
 	};
 
 /* simple, non-priority pkt queue */
 	struct spktq {
-		uint16 num_prec;	/* number of precedences in use (always 1) */
-		uint16 hi_prec;	/* rapid dequeue hint (>= highest non-empty prec) */
-		uint16 max;	/* total max packets */
-		uint16 len;	/* total number of packets */
+		u16 num_prec;	/* number of precedences in use (always 1) */
+		u16 hi_prec;	/* rapid dequeue hint (>= highest non-empty prec) */
+		u16 max;	/* total max packets */
+		u16 len;	/* total number of packets */
 		/* q array must be last since # of elements can be either PKTQ_MAX_PREC or 1 */
 		struct pktq_prec q[1];
 	};
@@ -273,10 +273,10 @@ extern "C" {
 /* iovar structure */
 	typedef struct bcm_iovar {
 		const char *name;	/* name for lookup and display */
-		uint16 varid;	/* id for switch */
-		uint16 flags;	/* driver-specific flag bits */
-		uint16 type;	/* base type of argument */
-		uint16 minlen;	/* min length for buffer vars */
+		u16 varid;	/* id for switch */
+		u16 flags;	/* driver-specific flag bits */
+		u16 type;	/* base type of argument */
+		u16 minlen;	/* min length for buffer vars */
 	} bcm_iovar_t;
 
 /* varid definitions are per-driver, may use these get/set bits */
@@ -325,7 +325,7 @@ extern "C" {
 	"s8", \
 	"u8", \
 	"int16", \
-	"uint16", \
+	"u16", \
 	"int32", \
 	"uint32", \
 	"buffer", \
@@ -569,7 +569,7 @@ extern "C" {
 /* externs */
 /* crc */
 	extern u8 BCMROMFN(hndcrc8) (u8 *p, uint nbytes, u8 crc);
-	extern uint16 BCMROMFN(hndcrc16) (u8 *p, uint nbytes, uint16 crc);
+	extern u16 BCMROMFN(hndcrc16) (u8 *p, uint nbytes, u16 crc);
 /* format/print */
 #if defined(BCMDBG)
 	extern int bcm_format_flags(const bcm_bit_desc_t *bd, uint32 flags,
@@ -612,8 +612,8 @@ extern "C" {
 
 #ifdef BRCM_FULLMAC
 /* power conversion */
-	extern uint16 BCMROMFN(bcm_qdbm_to_mw) (u8 qdbm);
-	extern u8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw);
+	extern u16 BCMROMFN(bcm_qdbm_to_mw) (u8 qdbm);
+	extern u8 BCMROMFN(bcm_mw_to_qdbm) (u16 mw);
 #endif
 
 /* generic datastruct to help dump routines */
--- a/drivers/staging/brcm80211/include/bcmwifi.h
+++ b/drivers/staging/brcm80211/include/bcmwifi.h
@@ -18,7 +18,7 @@
 #define	_bcmwifi_h_
 
 /* A chanspec holds the channel number, band, bandwidth and control sideband */
-typedef uint16 chanspec_t;
+typedef u16 chanspec_t;
 
 /* channel defines */
 #define CH_UPPER_SB			0x01
--- a/drivers/staging/brcm80211/include/d11.h
+++ b/drivers/staging/brcm80211/include/d11.h
@@ -75,8 +75,8 @@ typedef volatile struct {
 typedef volatile union {
 	uint32 pmqhostdata;	/* read only! */
 	struct {
-		uint16 pmqctrlstatus;	/* read/write */
-		uint16 PAD;
+		u16 pmqctrlstatus;	/* read/write */
+		u16 PAD;
 	} w;
 } pmqreg_t;
 
@@ -188,250 +188,250 @@ typedef volatile struct _d11regs {
 	uint32 aggfifocnt;	/* 0x390 */
 	uint32 aggfifodata;	/* 0x394 */
 	uint32 PAD[16];		/* 0x398 - 0x3d4 */
-	uint16 radioregaddr;	/* 0x3d8 */
-	uint16 radioregdata;	/* 0x3da */
+	u16 radioregaddr;	/* 0x3d8 */
+	u16 radioregdata;	/* 0x3da */
 
 	/* time delay between the change on rf disable input and radio shutdown corerev 10 */
 	uint32 rfdisabledly;	/* 0x3DC */
 
 	/* PHY register access */
-	uint16 phyversion;	/* 0x3e0 - 0x0 */
-	uint16 phybbconfig;	/* 0x3e2 - 0x1 */
-	uint16 phyadcbias;	/* 0x3e4 - 0x2  Bphy only */
-	uint16 phyanacore;	/* 0x3e6 - 0x3  pwwrdwn on aphy */
-	uint16 phyrxstatus0;	/* 0x3e8 - 0x4 */
-	uint16 phyrxstatus1;	/* 0x3ea - 0x5 */
-	uint16 phycrsth;	/* 0x3ec - 0x6 */
-	uint16 phytxerror;	/* 0x3ee - 0x7 */
-	uint16 phychannel;	/* 0x3f0 - 0x8 */
-	uint16 PAD[1];		/* 0x3f2 - 0x9 */
-	uint16 phytest;		/* 0x3f4 - 0xa */
-	uint16 phy4waddr;	/* 0x3f6 - 0xb */
-	uint16 phy4wdatahi;	/* 0x3f8 - 0xc */
-	uint16 phy4wdatalo;	/* 0x3fa - 0xd */
-	uint16 phyregaddr;	/* 0x3fc - 0xe */
-	uint16 phyregdata;	/* 0x3fe - 0xf */
+	u16 phyversion;	/* 0x3e0 - 0x0 */
+	u16 phybbconfig;	/* 0x3e2 - 0x1 */
+	u16 phyadcbias;	/* 0x3e4 - 0x2  Bphy only */
+	u16 phyanacore;	/* 0x3e6 - 0x3  pwwrdwn on aphy */
+	u16 phyrxstatus0;	/* 0x3e8 - 0x4 */
+	u16 phyrxstatus1;	/* 0x3ea - 0x5 */
+	u16 phycrsth;	/* 0x3ec - 0x6 */
+	u16 phytxerror;	/* 0x3ee - 0x7 */
+	u16 phychannel;	/* 0x3f0 - 0x8 */
+	u16 PAD[1];		/* 0x3f2 - 0x9 */
+	u16 phytest;		/* 0x3f4 - 0xa */
+	u16 phy4waddr;	/* 0x3f6 - 0xb */
+	u16 phy4wdatahi;	/* 0x3f8 - 0xc */
+	u16 phy4wdatalo;	/* 0x3fa - 0xd */
+	u16 phyregaddr;	/* 0x3fc - 0xe */
+	u16 phyregdata;	/* 0x3fe - 0xf */
 
 	/* IHR *//* 0x400 - 0x7FE */
 
 	/* RXE Block */
-	uint16 PAD[3];		/* 0x400 - 0x406 */
-	uint16 rcv_fifo_ctl;	/* 0x406 */
-	uint16 PAD;		/* 0x408 - 0x40a */
-	uint16 rcv_frm_cnt;	/* 0x40a */
-	uint16 PAD[4];		/* 0x40a - 0x414 */
-	uint16 rssi;		/* 0x414 */
-	uint16 PAD[5];		/* 0x414 - 0x420 */
-	uint16 rcm_ctl;		/* 0x420 */
-	uint16 rcm_mat_data;	/* 0x422 */
-	uint16 rcm_mat_mask;	/* 0x424 */
-	uint16 rcm_mat_dly;	/* 0x426 */
-	uint16 rcm_cond_mask_l;	/* 0x428 */
-	uint16 rcm_cond_mask_h;	/* 0x42A */
-	uint16 rcm_cond_dly;	/* 0x42C */
-	uint16 PAD[1];		/* 0x42E */
-	uint16 ext_ihr_addr;	/* 0x430 */
-	uint16 ext_ihr_data;	/* 0x432 */
-	uint16 rxe_phyrs_2;	/* 0x434 */
-	uint16 rxe_phyrs_3;	/* 0x436 */
-	uint16 phy_mode;	/* 0x438 */
-	uint16 rcmta_ctl;	/* 0x43a */
-	uint16 rcmta_size;	/* 0x43c */
-	uint16 rcmta_addr0;	/* 0x43e */
-	uint16 rcmta_addr1;	/* 0x440 */
-	uint16 rcmta_addr2;	/* 0x442 */
-	uint16 PAD[30];		/* 0x444 - 0x480 */
+	u16 PAD[3];		/* 0x400 - 0x406 */
+	u16 rcv_fifo_ctl;	/* 0x406 */
+	u16 PAD;		/* 0x408 - 0x40a */
+	u16 rcv_frm_cnt;	/* 0x40a */
+	u16 PAD[4];		/* 0x40a - 0x414 */
+	u16 rssi;		/* 0x414 */
+	u16 PAD[5];		/* 0x414 - 0x420 */
+	u16 rcm_ctl;		/* 0x420 */
+	u16 rcm_mat_data;	/* 0x422 */
+	u16 rcm_mat_mask;	/* 0x424 */
+	u16 rcm_mat_dly;	/* 0x426 */
+	u16 rcm_cond_mask_l;	/* 0x428 */
+	u16 rcm_cond_mask_h;	/* 0x42A */
+	u16 rcm_cond_dly;	/* 0x42C */
+	u16 PAD[1];		/* 0x42E */
+	u16 ext_ihr_addr;	/* 0x430 */
+	u16 ext_ihr_data;	/* 0x432 */
+	u16 rxe_phyrs_2;	/* 0x434 */
+	u16 rxe_phyrs_3;	/* 0x436 */
+	u16 phy_mode;	/* 0x438 */
+	u16 rcmta_ctl;	/* 0x43a */
+	u16 rcmta_size;	/* 0x43c */
+	u16 rcmta_addr0;	/* 0x43e */
+	u16 rcmta_addr1;	/* 0x440 */
+	u16 rcmta_addr2;	/* 0x442 */
+	u16 PAD[30];		/* 0x444 - 0x480 */
 
 	/* PSM Block *//* 0x480 - 0x500 */
 
-	uint16 PAD;		/* 0x480 */
-	uint16 psm_maccontrol_h;	/* 0x482 */
-	uint16 psm_macintstatus_l;	/* 0x484 */
-	uint16 psm_macintstatus_h;	/* 0x486 */
-	uint16 psm_macintmask_l;	/* 0x488 */
-	uint16 psm_macintmask_h;	/* 0x48A */
-	uint16 PAD;		/* 0x48C */
-	uint16 psm_maccommand;	/* 0x48E */
-	uint16 psm_brc;		/* 0x490 */
-	uint16 psm_phy_hdr_param;	/* 0x492 */
-	uint16 psm_postcard;	/* 0x494 */
-	uint16 psm_pcard_loc_l;	/* 0x496 */
-	uint16 psm_pcard_loc_h;	/* 0x498 */
-	uint16 psm_gpio_in;	/* 0x49A */
-	uint16 psm_gpio_out;	/* 0x49C */
-	uint16 psm_gpio_oe;	/* 0x49E */
-
-	uint16 psm_bred_0;	/* 0x4A0 */
-	uint16 psm_bred_1;	/* 0x4A2 */
-	uint16 psm_bred_2;	/* 0x4A4 */
-	uint16 psm_bred_3;	/* 0x4A6 */
-	uint16 psm_brcl_0;	/* 0x4A8 */
-	uint16 psm_brcl_1;	/* 0x4AA */
-	uint16 psm_brcl_2;	/* 0x4AC */
-	uint16 psm_brcl_3;	/* 0x4AE */
-	uint16 psm_brpo_0;	/* 0x4B0 */
-	uint16 psm_brpo_1;	/* 0x4B2 */
-	uint16 psm_brpo_2;	/* 0x4B4 */
-	uint16 psm_brpo_3;	/* 0x4B6 */
-	uint16 psm_brwk_0;	/* 0x4B8 */
-	uint16 psm_brwk_1;	/* 0x4BA */
-	uint16 psm_brwk_2;	/* 0x4BC */
-	uint16 psm_brwk_3;	/* 0x4BE */
-
-	uint16 psm_base_0;	/* 0x4C0 */
-	uint16 psm_base_1;	/* 0x4C2 */
-	uint16 psm_base_2;	/* 0x4C4 */
-	uint16 psm_base_3;	/* 0x4C6 */
-	uint16 psm_base_4;	/* 0x4C8 */
-	uint16 psm_base_5;	/* 0x4CA */
-	uint16 psm_base_6;	/* 0x4CC */
-	uint16 psm_pc_reg_0;	/* 0x4CE */
-	uint16 psm_pc_reg_1;	/* 0x4D0 */
-	uint16 psm_pc_reg_2;	/* 0x4D2 */
-	uint16 psm_pc_reg_3;	/* 0x4D4 */
-	uint16 PAD[0xD];	/* 0x4D6 - 0x4DE */
-	uint16 psm_corectlsts;	/* 0x4f0 *//* Corerev >= 13 */
-	uint16 PAD[0x7];	/* 0x4f2 - 0x4fE */
+	u16 PAD;		/* 0x480 */
+	u16 psm_maccontrol_h;	/* 0x482 */
+	u16 psm_macintstatus_l;	/* 0x484 */
+	u16 psm_macintstatus_h;	/* 0x486 */
+	u16 psm_macintmask_l;	/* 0x488 */
+	u16 psm_macintmask_h;	/* 0x48A */
+	u16 PAD;		/* 0x48C */
+	u16 psm_maccommand;	/* 0x48E */
+	u16 psm_brc;		/* 0x490 */
+	u16 psm_phy_hdr_param;	/* 0x492 */
+	u16 psm_postcard;	/* 0x494 */
+	u16 psm_pcard_loc_l;	/* 0x496 */
+	u16 psm_pcard_loc_h;	/* 0x498 */
+	u16 psm_gpio_in;	/* 0x49A */
+	u16 psm_gpio_out;	/* 0x49C */
+	u16 psm_gpio_oe;	/* 0x49E */
+
+	u16 psm_bred_0;	/* 0x4A0 */
+	u16 psm_bred_1;	/* 0x4A2 */
+	u16 psm_bred_2;	/* 0x4A4 */
+	u16 psm_bred_3;	/* 0x4A6 */
+	u16 psm_brcl_0;	/* 0x4A8 */
+	u16 psm_brcl_1;	/* 0x4AA */
+	u16 psm_brcl_2;	/* 0x4AC */
+	u16 psm_brcl_3;	/* 0x4AE */
+	u16 psm_brpo_0;	/* 0x4B0 */
+	u16 psm_brpo_1;	/* 0x4B2 */
+	u16 psm_brpo_2;	/* 0x4B4 */
+	u16 psm_brpo_3;	/* 0x4B6 */
+	u16 psm_brwk_0;	/* 0x4B8 */
+	u16 psm_brwk_1;	/* 0x4BA */
+	u16 psm_brwk_2;	/* 0x4BC */
+	u16 psm_brwk_3;	/* 0x4BE */
+
+	u16 psm_base_0;	/* 0x4C0 */
+	u16 psm_base_1;	/* 0x4C2 */
+	u16 psm_base_2;	/* 0x4C4 */
+	u16 psm_base_3;	/* 0x4C6 */
+	u16 psm_base_4;	/* 0x4C8 */
+	u16 psm_base_5;	/* 0x4CA */
+	u16 psm_base_6;	/* 0x4CC */
+	u16 psm_pc_reg_0;	/* 0x4CE */
+	u16 psm_pc_reg_1;	/* 0x4D0 */
+	u16 psm_pc_reg_2;	/* 0x4D2 */
+	u16 psm_pc_reg_3;	/* 0x4D4 */
+	u16 PAD[0xD];	/* 0x4D6 - 0x4DE */
+	u16 psm_corectlsts;	/* 0x4f0 *//* Corerev >= 13 */
+	u16 PAD[0x7];	/* 0x4f2 - 0x4fE */
 
 	/* TXE0 Block *//* 0x500 - 0x580 */
-	uint16 txe_ctl;		/* 0x500 */
-	uint16 txe_aux;		/* 0x502 */
-	uint16 txe_ts_loc;	/* 0x504 */
-	uint16 txe_time_out;	/* 0x506 */
-	uint16 txe_wm_0;	/* 0x508 */
-	uint16 txe_wm_1;	/* 0x50A */
-	uint16 txe_phyctl;	/* 0x50C */
-	uint16 txe_status;	/* 0x50E */
-	uint16 txe_mmplcp0;	/* 0x510 */
-	uint16 txe_mmplcp1;	/* 0x512 */
-	uint16 txe_phyctl1;	/* 0x514 */
+	u16 txe_ctl;		/* 0x500 */
+	u16 txe_aux;		/* 0x502 */
+	u16 txe_ts_loc;	/* 0x504 */
+	u16 txe_time_out;	/* 0x506 */
+	u16 txe_wm_0;	/* 0x508 */
+	u16 txe_wm_1;	/* 0x50A */
+	u16 txe_phyctl;	/* 0x50C */
+	u16 txe_status;	/* 0x50E */
+	u16 txe_mmplcp0;	/* 0x510 */
+	u16 txe_mmplcp1;	/* 0x512 */
+	u16 txe_phyctl1;	/* 0x514 */
 
-	uint16 PAD[0x05];	/* 0x510 - 0x51E */
+	u16 PAD[0x05];	/* 0x510 - 0x51E */
 
 	/* Transmit control */
-	uint16 xmtfifodef;	/* 0x520 */
-	uint16 xmtfifo_frame_cnt;	/* 0x522 *//* Corerev >= 16 */
-	uint16 xmtfifo_byte_cnt;	/* 0x524 *//* Corerev >= 16 */
-	uint16 xmtfifo_head;	/* 0x526 *//* Corerev >= 16 */
-	uint16 xmtfifo_rd_ptr;	/* 0x528 *//* Corerev >= 16 */
-	uint16 xmtfifo_wr_ptr;	/* 0x52A *//* Corerev >= 16 */
-	uint16 xmtfifodef1;	/* 0x52C *//* Corerev >= 16 */
-
-	uint16 PAD[0x09];	/* 0x52E - 0x53E */
-
-	uint16 xmtfifocmd;	/* 0x540 */
-	uint16 xmtfifoflush;	/* 0x542 */
-	uint16 xmtfifothresh;	/* 0x544 */
-	uint16 xmtfifordy;	/* 0x546 */
-	uint16 xmtfifoprirdy;	/* 0x548 */
-	uint16 xmtfiforqpri;	/* 0x54A */
-	uint16 xmttplatetxptr;	/* 0x54C */
-	uint16 PAD;		/* 0x54E */
-	uint16 xmttplateptr;	/* 0x550 */
-	uint16 smpl_clct_strptr;	/* 0x552 *//* Corerev >= 22 */
-	uint16 smpl_clct_stpptr;	/* 0x554 *//* Corerev >= 22 */
-	uint16 smpl_clct_curptr;	/* 0x556 *//* Corerev >= 22 */
-	uint16 PAD[0x04];	/* 0x558 - 0x55E */
-	uint16 xmttplatedatalo;	/* 0x560 */
-	uint16 xmttplatedatahi;	/* 0x562 */
-
-	uint16 PAD[2];		/* 0x564 - 0x566 */
-
-	uint16 xmtsel;		/* 0x568 */
-	uint16 xmttxcnt;	/* 0x56A */
-	uint16 xmttxshmaddr;	/* 0x56C */
+	u16 xmtfifodef;	/* 0x520 */
+	u16 xmtfifo_frame_cnt;	/* 0x522 *//* Corerev >= 16 */
+	u16 xmtfifo_byte_cnt;	/* 0x524 *//* Corerev >= 16 */
+	u16 xmtfifo_head;	/* 0x526 *//* Corerev >= 16 */
+	u16 xmtfifo_rd_ptr;	/* 0x528 *//* Corerev >= 16 */
+	u16 xmtfifo_wr_ptr;	/* 0x52A *//* Corerev >= 16 */
+	u16 xmtfifodef1;	/* 0x52C *//* Corerev >= 16 */
+
+	u16 PAD[0x09];	/* 0x52E - 0x53E */
+
+	u16 xmtfifocmd;	/* 0x540 */
+	u16 xmtfifoflush;	/* 0x542 */
+	u16 xmtfifothresh;	/* 0x544 */
+	u16 xmtfifordy;	/* 0x546 */
+	u16 xmtfifoprirdy;	/* 0x548 */
+	u16 xmtfiforqpri;	/* 0x54A */
+	u16 xmttplatetxptr;	/* 0x54C */
+	u16 PAD;		/* 0x54E */
+	u16 xmttplateptr;	/* 0x550 */
+	u16 smpl_clct_strptr;	/* 0x552 *//* Corerev >= 22 */
+	u16 smpl_clct_stpptr;	/* 0x554 *//* Corerev >= 22 */
+	u16 smpl_clct_curptr;	/* 0x556 *//* Corerev >= 22 */
+	u16 PAD[0x04];	/* 0x558 - 0x55E */
+	u16 xmttplatedatalo;	/* 0x560 */
+	u16 xmttplatedatahi;	/* 0x562 */
+
+	u16 PAD[2];		/* 0x564 - 0x566 */
+
+	u16 xmtsel;		/* 0x568 */
+	u16 xmttxcnt;	/* 0x56A */
+	u16 xmttxshmaddr;	/* 0x56C */
 
-	uint16 PAD[0x09];	/* 0x56E - 0x57E */
+	u16 PAD[0x09];	/* 0x56E - 0x57E */
 
 	/* TXE1 Block */
-	uint16 PAD[0x40];	/* 0x580 - 0x5FE */
+	u16 PAD[0x40];	/* 0x580 - 0x5FE */
 
 	/* TSF Block */
-	uint16 PAD[0X02];	/* 0x600 - 0x602 */
-	uint16 tsf_cfpstrt_l;	/* 0x604 */
-	uint16 tsf_cfpstrt_h;	/* 0x606 */
-	uint16 PAD[0X05];	/* 0x608 - 0x610 */
-	uint16 tsf_cfppretbtt;	/* 0x612 */
-	uint16 PAD[0XD];	/* 0x614 - 0x62C */
-	uint16 tsf_clk_frac_l;	/* 0x62E */
-	uint16 tsf_clk_frac_h;	/* 0x630 */
-	uint16 PAD[0X14];	/* 0x632 - 0x658 */
-	uint16 tsf_random;	/* 0x65A */
-	uint16 PAD[0x05];	/* 0x65C - 0x664 */
+	u16 PAD[0X02];	/* 0x600 - 0x602 */
+	u16 tsf_cfpstrt_l;	/* 0x604 */
+	u16 tsf_cfpstrt_h;	/* 0x606 */
+	u16 PAD[0X05];	/* 0x608 - 0x610 */
+	u16 tsf_cfppretbtt;	/* 0x612 */
+	u16 PAD[0XD];	/* 0x614 - 0x62C */
+	u16 tsf_clk_frac_l;	/* 0x62E */
+	u16 tsf_clk_frac_h;	/* 0x630 */
+	u16 PAD[0X14];	/* 0x632 - 0x658 */
+	u16 tsf_random;	/* 0x65A */
+	u16 PAD[0x05];	/* 0x65C - 0x664 */
 	/* GPTimer 2 registers are corerev >= 3 */
-	uint16 tsf_gpt2_stat;	/* 0x666 */
-	uint16 tsf_gpt2_ctr_l;	/* 0x668 */
-	uint16 tsf_gpt2_ctr_h;	/* 0x66A */
-	uint16 tsf_gpt2_val_l;	/* 0x66C */
-	uint16 tsf_gpt2_val_h;	/* 0x66E */
-	uint16 tsf_gptall_stat;	/* 0x670 */
-	uint16 PAD[0x07];	/* 0x672 - 0x67E */
+	u16 tsf_gpt2_stat;	/* 0x666 */
+	u16 tsf_gpt2_ctr_l;	/* 0x668 */
+	u16 tsf_gpt2_ctr_h;	/* 0x66A */
+	u16 tsf_gpt2_val_l;	/* 0x66C */
+	u16 tsf_gpt2_val_h;	/* 0x66E */
+	u16 tsf_gptall_stat;	/* 0x670 */
+	u16 PAD[0x07];	/* 0x672 - 0x67E */
 
 	/* IFS Block */
-	uint16 ifs_sifs_rx_tx_tx;	/* 0x680 */
-	uint16 ifs_sifs_nav_tx;	/* 0x682 */
-	uint16 ifs_slot;	/* 0x684 */
-	uint16 PAD;		/* 0x686 */
-	uint16 ifs_ctl;		/* 0x688 */
-	uint16 PAD[0x3];	/* 0x68a - 0x68F */
-	uint16 ifsstat;		/* 0x690 */
-	uint16 ifsmedbusyctl;	/* 0x692 */
-	uint16 iftxdur;		/* 0x694 */
-	uint16 PAD[0x3];	/* 0x696 - 0x69b */
+	u16 ifs_sifs_rx_tx_tx;	/* 0x680 */
+	u16 ifs_sifs_nav_tx;	/* 0x682 */
+	u16 ifs_slot;	/* 0x684 */
+	u16 PAD;		/* 0x686 */
+	u16 ifs_ctl;		/* 0x688 */
+	u16 PAD[0x3];	/* 0x68a - 0x68F */
+	u16 ifsstat;		/* 0x690 */
+	u16 ifsmedbusyctl;	/* 0x692 */
+	u16 iftxdur;		/* 0x694 */
+	u16 PAD[0x3];	/* 0x696 - 0x69b */
 	/* EDCF support in dot11macs with corerevs >= 16 */
-	uint16 ifs_aifsn;	/* 0x69c */
-	uint16 ifs_ctl1;	/* 0x69e */
+	u16 ifs_aifsn;	/* 0x69c */
+	u16 ifs_ctl1;	/* 0x69e */
 
 	/* New slow clock registers on corerev >= 5 */
-	uint16 scc_ctl;		/* 0x6a0 */
-	uint16 scc_timer_l;	/* 0x6a2 */
-	uint16 scc_timer_h;	/* 0x6a4 */
-	uint16 scc_frac;	/* 0x6a6 */
-	uint16 scc_fastpwrup_dly;	/* 0x6a8 */
-	uint16 scc_per;		/* 0x6aa */
-	uint16 scc_per_frac;	/* 0x6ac */
-	uint16 scc_cal_timer_l;	/* 0x6ae */
-	uint16 scc_cal_timer_h;	/* 0x6b0 */
-	uint16 PAD;		/* 0x6b2 */
+	u16 scc_ctl;		/* 0x6a0 */
+	u16 scc_timer_l;	/* 0x6a2 */
+	u16 scc_timer_h;	/* 0x6a4 */
+	u16 scc_frac;	/* 0x6a6 */
+	u16 scc_fastpwrup_dly;	/* 0x6a8 */
+	u16 scc_per;		/* 0x6aa */
+	u16 scc_per_frac;	/* 0x6ac */
+	u16 scc_cal_timer_l;	/* 0x6ae */
+	u16 scc_cal_timer_h;	/* 0x6b0 */
+	u16 PAD;		/* 0x6b2 */
 
-	uint16 PAD[0x26];
+	u16 PAD[0x26];
 
 	/* NAV Block */
-	uint16 nav_ctl;		/* 0x700 */
-	uint16 navstat;		/* 0x702 */
-	uint16 PAD[0x3e];	/* 0x702 - 0x77E */
+	u16 nav_ctl;		/* 0x700 */
+	u16 navstat;		/* 0x702 */
+	u16 PAD[0x3e];	/* 0x702 - 0x77E */
 
 	/* WEP/PMQ Block *//* 0x780 - 0x7FE */
-	uint16 PAD[0x20];	/* 0x780 - 0x7BE */
+	u16 PAD[0x20];	/* 0x780 - 0x7BE */
 
-	uint16 wepctl;		/* 0x7C0 */
-	uint16 wepivloc;	/* 0x7C2 */
-	uint16 wepivkey;	/* 0x7C4 */
-	uint16 wepwkey;		/* 0x7C6 */
-
-	uint16 PAD[4];		/* 0x7C8 - 0x7CE */
-	uint16 pcmctl;		/* 0X7D0 */
-	uint16 pcmstat;		/* 0X7D2 */
-	uint16 PAD[6];		/* 0x7D4 - 0x7DE */
-
-	uint16 pmqctl;		/* 0x7E0 */
-	uint16 pmqstatus;	/* 0x7E2 */
-	uint16 pmqpat0;		/* 0x7E4 */
-	uint16 pmqpat1;		/* 0x7E6 */
-	uint16 pmqpat2;		/* 0x7E8 */
-
-	uint16 pmqdat;		/* 0x7EA */
-	uint16 pmqdator;	/* 0x7EC */
-	uint16 pmqhst;		/* 0x7EE */
-	uint16 pmqpath0;	/* 0x7F0 */
-	uint16 pmqpath1;	/* 0x7F2 */
-	uint16 pmqpath2;	/* 0x7F4 */
-	uint16 pmqdath;		/* 0x7F6 */
+	u16 wepctl;		/* 0x7C0 */
+	u16 wepivloc;	/* 0x7C2 */
+	u16 wepivkey;	/* 0x7C4 */
+	u16 wepwkey;		/* 0x7C6 */
+
+	u16 PAD[4];		/* 0x7C8 - 0x7CE */
+	u16 pcmctl;		/* 0X7D0 */
+	u16 pcmstat;		/* 0X7D2 */
+	u16 PAD[6];		/* 0x7D4 - 0x7DE */
+
+	u16 pmqctl;		/* 0x7E0 */
+	u16 pmqstatus;	/* 0x7E2 */
+	u16 pmqpat0;		/* 0x7E4 */
+	u16 pmqpat1;		/* 0x7E6 */
+	u16 pmqpat2;		/* 0x7E8 */
+
+	u16 pmqdat;		/* 0x7EA */
+	u16 pmqdator;	/* 0x7EC */
+	u16 pmqhst;		/* 0x7EE */
+	u16 pmqpath0;	/* 0x7F0 */
+	u16 pmqpath1;	/* 0x7F2 */
+	u16 pmqpath2;	/* 0x7F4 */
+	u16 pmqdath;		/* 0x7F6 */
 
-	uint16 PAD[0x04];	/* 0x7F8 - 0x7FE */
+	u16 PAD[0x04];	/* 0x7F8 - 0x7FE */
 
 	/* SHM *//* 0x800 - 0xEFE */
-	uint16 PAD[0x380];	/* 0x800 - 0xEFE */
+	u16 PAD[0x380];	/* 0x800 - 0xEFE */
 
 	/* SB configuration registers: 0xF00 */
 	sbconfig_t sbconfig;	/* sb config regs occupy top 256 bytes */
@@ -634,7 +634,7 @@ typedef volatile struct _d11regs {
 typedef struct ofdm_phy_hdr ofdm_phy_hdr_t;
 BWL_PRE_PACKED_STRUCT struct ofdm_phy_hdr {
 	u8 rlpt[3];		/* rate, length, parity, tail */
-	uint16 service;
+	u16 service;
 	u8 pad;
 } BWL_POST_PACKED_STRUCT;
 
@@ -670,8 +670,8 @@ typedef struct cck_phy_hdr cck_phy_hdr_t
 BWL_PRE_PACKED_STRUCT struct cck_phy_hdr {
 	u8 signal;
 	u8 service;
-	uint16 length;
-	uint16 crc;
+	u16 length;
+	u16 crc;
 } BWL_POST_PACKED_STRUCT;
 
 #define	D11B_PHY_HDR_LEN	6
@@ -714,40 +714,40 @@ BWL_PRE_PACKED_STRUCT struct cck_phy_hdr
 /* TX DMA buffer header */
 typedef struct d11txh d11txh_t;
 BWL_PRE_PACKED_STRUCT struct d11txh {
-	uint16 MacTxControlLow;	/* 0x0 */
-	uint16 MacTxControlHigh;	/* 0x1 */
-	uint16 MacFrameControl;	/* 0x2 */
-	uint16 TxFesTimeNormal;	/* 0x3 */
-	uint16 PhyTxControlWord;	/* 0x4 */
-	uint16 PhyTxControlWord_1;	/* 0x5 */
-	uint16 PhyTxControlWord_1_Fbr;	/* 0x6 */
-	uint16 PhyTxControlWord_1_Rts;	/* 0x7 */
-	uint16 PhyTxControlWord_1_FbrRts;	/* 0x8 */
-	uint16 MainRates;	/* 0x9 */
-	uint16 XtraFrameTypes;	/* 0xa */
+	u16 MacTxControlLow;	/* 0x0 */
+	u16 MacTxControlHigh;	/* 0x1 */
+	u16 MacFrameControl;	/* 0x2 */
+	u16 TxFesTimeNormal;	/* 0x3 */
+	u16 PhyTxControlWord;	/* 0x4 */
+	u16 PhyTxControlWord_1;	/* 0x5 */
+	u16 PhyTxControlWord_1_Fbr;	/* 0x6 */
+	u16 PhyTxControlWord_1_Rts;	/* 0x7 */
+	u16 PhyTxControlWord_1_FbrRts;	/* 0x8 */
+	u16 MainRates;	/* 0x9 */
+	u16 XtraFrameTypes;	/* 0xa */
 	u8 IV[16];		/* 0x0b - 0x12 */
 	u8 TxFrameRA[6];	/* 0x13 - 0x15 */
-	uint16 TxFesTimeFallback;	/* 0x16 */
+	u16 TxFesTimeFallback;	/* 0x16 */
 	u8 RTSPLCPFallback[6];	/* 0x17 - 0x19 */
-	uint16 RTSDurFallback;	/* 0x1a */
+	u16 RTSDurFallback;	/* 0x1a */
 	u8 FragPLCPFallback[6];	/* 0x1b - 1d */
-	uint16 FragDurFallback;	/* 0x1e */
-	uint16 MModeLen;	/* 0x1f */
-	uint16 MModeFbrLen;	/* 0x20 */
-	uint16 TstampLow;	/* 0x21 */
-	uint16 TstampHigh;	/* 0x22 */
-	uint16 ABI_MimoAntSel;	/* 0x23 */
-	uint16 PreloadSize;	/* 0x24 */
-	uint16 AmpduSeqCtl;	/* 0x25 */
-	uint16 TxFrameID;	/* 0x26 */
-	uint16 TxStatus;	/* 0x27 */
-	uint16 MaxNMpdus;	/* 0x28 corerev >=16 */
-	uint16 MaxABytes_MRT;	/* 0x29 corerev >=16 */
-	uint16 MaxABytes_FBR;	/* 0x2a corerev >=16 */
-	uint16 MinMBytes;	/* 0x2b corerev >=16 */
+	u16 FragDurFallback;	/* 0x1e */
+	u16 MModeLen;	/* 0x1f */
+	u16 MModeFbrLen;	/* 0x20 */
+	u16 TstampLow;	/* 0x21 */
+	u16 TstampHigh;	/* 0x22 */
+	u16 ABI_MimoAntSel;	/* 0x23 */
+	u16 PreloadSize;	/* 0x24 */
+	u16 AmpduSeqCtl;	/* 0x25 */
+	u16 TxFrameID;	/* 0x26 */
+	u16 TxStatus;	/* 0x27 */
+	u16 MaxNMpdus;	/* 0x28 corerev >=16 */
+	u16 MaxABytes_MRT;	/* 0x29 corerev >=16 */
+	u16 MaxABytes_FBR;	/* 0x2a corerev >=16 */
+	u16 MinMBytes;	/* 0x2b corerev >=16 */
 	u8 RTSPhyHeader[D11_PHY_HDR_LEN];	/* 0x2c - 0x2e */
 	struct dot11_rts_frame rts_frame;	/* 0x2f - 0x36 */
-	uint16 PAD;		/* 0x37 */
+	u16 PAD;		/* 0x37 */
 } BWL_POST_PACKED_STRUCT;
 
 #define	D11_TXH_LEN		112	/* bytes */
@@ -858,14 +858,14 @@ BWL_PRE_PACKED_STRUCT struct d11txh {
 /* tx status packet */
 typedef struct tx_status tx_status_t;
 BWL_PRE_PACKED_STRUCT struct tx_status {
-	uint16 framelen;
-	uint16 PAD;
-	uint16 frameid;
-	uint16 status;
-	uint16 lasttxtime;
-	uint16 sequence;
-	uint16 phyerr;
-	uint16 ackphyrxsh;
+	u16 framelen;
+	u16 PAD;
+	u16 frameid;
+	u16 status;
+	u16 lasttxtime;
+	u16 sequence;
+	u16 phyerr;
+	u16 ackphyrxsh;
 } BWL_POST_PACKED_STRUCT;
 
 #define	TXSTATUS_LEN	16
@@ -1251,22 +1251,22 @@ BWL_PRE_PACKED_STRUCT struct tx_status {
 
 typedef struct shm_acparams shm_acparams_t;
 BWL_PRE_PACKED_STRUCT struct shm_acparams {
-	uint16 txop;
-	uint16 cwmin;
-	uint16 cwmax;
-	uint16 cwcur;
-	uint16 aifs;
-	uint16 bslots;
-	uint16 reggap;
-	uint16 status;
-	uint16 rsvd[8];
+	u16 txop;
+	u16 cwmin;
+	u16 cwmax;
+	u16 cwcur;
+	u16 aifs;
+	u16 bslots;
+	u16 reggap;
+	u16 status;
+	u16 rsvd[8];
 } BWL_POST_PACKED_STRUCT;
 #define M_EDCF_QLEN	(16 * 2)
 
 #define WME_STATUS_NEWAC	(1 << 8)
 
 /* M_HOST_FLAGS */
-#define MHFMAX		5	/* Number of valid hostflag half-word (uint16) */
+#define MHFMAX		5	/* Number of valid hostflag half-word (u16) */
 #define MHF1		0	/* Hostflag 1 index */
 #define MHF2		1	/* Hostflag 2 index */
 #define MHF3		2	/* Hostflag 3 index */
@@ -1310,18 +1310,18 @@ BWL_PRE_PACKED_STRUCT struct shm_acparam
 /* Receive Frame Data Header for 802.11b DCF-only frames */
 typedef struct d11rxhdr d11rxhdr_t;
 BWL_PRE_PACKED_STRUCT struct d11rxhdr {
-	uint16 RxFrameSize;	/* Actual byte length of the frame data received */
-	uint16 PAD;
-	uint16 PhyRxStatus_0;	/* PhyRxStatus 15:0 */
-	uint16 PhyRxStatus_1;	/* PhyRxStatus 31:16 */
-	uint16 PhyRxStatus_2;	/* PhyRxStatus 47:32 */
-	uint16 PhyRxStatus_3;	/* PhyRxStatus 63:48 */
-	uint16 PhyRxStatus_4;	/* PhyRxStatus 79:64 */
-	uint16 PhyRxStatus_5;	/* PhyRxStatus 95:80 */
-	uint16 RxStatus1;	/* MAC Rx Status */
-	uint16 RxStatus2;	/* extended MAC Rx status */
-	uint16 RxTSFTime;	/* RxTSFTime time of first MAC symbol + M_PHY_PLCPRX_DLY */
-	uint16 RxChan;		/* gain code, channel radio code, and phy type */
+	u16 RxFrameSize;	/* Actual byte length of the frame data received */
+	u16 PAD;
+	u16 PhyRxStatus_0;	/* PhyRxStatus 15:0 */
+	u16 PhyRxStatus_1;	/* PhyRxStatus 31:16 */
+	u16 PhyRxStatus_2;	/* PhyRxStatus 47:32 */
+	u16 PhyRxStatus_3;	/* PhyRxStatus 63:48 */
+	u16 PhyRxStatus_4;	/* PhyRxStatus 79:64 */
+	u16 PhyRxStatus_5;	/* PhyRxStatus 95:80 */
+	u16 RxStatus1;	/* MAC Rx Status */
+	u16 RxStatus2;	/* extended MAC Rx status */
+	u16 RxTSFTime;	/* RxTSFTime time of first MAC symbol + M_PHY_PLCPRX_DLY */
+	u16 RxChan;		/* gain code, channel radio code, and phy type */
 } BWL_POST_PACKED_STRUCT;
 
 #define	RXHDR_LEN		24	/* sizeof d11rxhdr_t */
@@ -1566,63 +1566,63 @@ typedef enum {
 
 /* ucode mac statistic counters in shared memory */
 typedef struct macstat {
-	uint16 txallfrm;	/* 0x80 */
-	uint16 txrtsfrm;	/* 0x82 */
-	uint16 txctsfrm;	/* 0x84 */
-	uint16 txackfrm;	/* 0x86 */
-	uint16 txdnlfrm;	/* 0x88 */
-	uint16 txbcnfrm;	/* 0x8a */
-	uint16 txfunfl[8];	/* 0x8c - 0x9b */
-	uint16 txtplunfl;	/* 0x9c */
-	uint16 txphyerr;	/* 0x9e */
-	uint16 pktengrxducast;	/* 0xa0 */
-	uint16 pktengrxdmcast;	/* 0xa2 */
-	uint16 rxfrmtoolong;	/* 0xa4 */
-	uint16 rxfrmtooshrt;	/* 0xa6 */
-	uint16 rxinvmachdr;	/* 0xa8 */
-	uint16 rxbadfcs;	/* 0xaa */
-	uint16 rxbadplcp;	/* 0xac */
-	uint16 rxcrsglitch;	/* 0xae */
-	uint16 rxstrt;		/* 0xb0 */
-	uint16 rxdfrmucastmbss;	/* 0xb2 */
-	uint16 rxmfrmucastmbss;	/* 0xb4 */
-	uint16 rxcfrmucast;	/* 0xb6 */
-	uint16 rxrtsucast;	/* 0xb8 */
-	uint16 rxctsucast;	/* 0xba */
-	uint16 rxackucast;	/* 0xbc */
-	uint16 rxdfrmocast;	/* 0xbe */
-	uint16 rxmfrmocast;	/* 0xc0 */
-	uint16 rxcfrmocast;	/* 0xc2 */
-	uint16 rxrtsocast;	/* 0xc4 */
-	uint16 rxctsocast;	/* 0xc6 */
-	uint16 rxdfrmmcast;	/* 0xc8 */
-	uint16 rxmfrmmcast;	/* 0xca */
-	uint16 rxcfrmmcast;	/* 0xcc */
-	uint16 rxbeaconmbss;	/* 0xce */
-	uint16 rxdfrmucastobss;	/* 0xd0 */
-	uint16 rxbeaconobss;	/* 0xd2 */
-	uint16 rxrsptmout;	/* 0xd4 */
-	uint16 bcntxcancl;	/* 0xd6 */
-	uint16 PAD;
-	uint16 rxf0ovfl;	/* 0xda */
-	uint16 rxf1ovfl;	/* 0xdc */
-	uint16 rxf2ovfl;	/* 0xde */
-	uint16 txsfovfl;	/* 0xe0 */
-	uint16 pmqovfl;		/* 0xe2 */
-	uint16 rxcgprqfrm;	/* 0xe4 */
-	uint16 rxcgprsqovfl;	/* 0xe6 */
-	uint16 txcgprsfail;	/* 0xe8 */
-	uint16 txcgprssuc;	/* 0xea */
-	uint16 prs_timeout;	/* 0xec */
-	uint16 rxnack;
-	uint16 frmscons;
-	uint16 txnack;
-	uint16 txglitch_nack;
-	uint16 txburst;		/* 0xf6 # tx bursts */
-	uint16 bphy_rxcrsglitch;	/* bphy rx crs glitch */
-	uint16 phywatchdog;	/* 0xfa # of phy watchdog events */
-	uint16 PAD;
-	uint16 bphy_badplcp;	/* bphy bad plcp */
+	u16 txallfrm;	/* 0x80 */
+	u16 txrtsfrm;	/* 0x82 */
+	u16 txctsfrm;	/* 0x84 */
+	u16 txackfrm;	/* 0x86 */
+	u16 txdnlfrm;	/* 0x88 */
+	u16 txbcnfrm;	/* 0x8a */
+	u16 txfunfl[8];	/* 0x8c - 0x9b */
+	u16 txtplunfl;	/* 0x9c */
+	u16 txphyerr;	/* 0x9e */
+	u16 pktengrxducast;	/* 0xa0 */
+	u16 pktengrxdmcast;	/* 0xa2 */
+	u16 rxfrmtoolong;	/* 0xa4 */
+	u16 rxfrmtooshrt;	/* 0xa6 */
+	u16 rxinvmachdr;	/* 0xa8 */
+	u16 rxbadfcs;	/* 0xaa */
+	u16 rxbadplcp;	/* 0xac */
+	u16 rxcrsglitch;	/* 0xae */
+	u16 rxstrt;		/* 0xb0 */
+	u16 rxdfrmucastmbss;	/* 0xb2 */
+	u16 rxmfrmucastmbss;	/* 0xb4 */
+	u16 rxcfrmucast;	/* 0xb6 */
+	u16 rxrtsucast;	/* 0xb8 */
+	u16 rxctsucast;	/* 0xba */
+	u16 rxackucast;	/* 0xbc */
+	u16 rxdfrmocast;	/* 0xbe */
+	u16 rxmfrmocast;	/* 0xc0 */
+	u16 rxcfrmocast;	/* 0xc2 */
+	u16 rxrtsocast;	/* 0xc4 */
+	u16 rxctsocast;	/* 0xc6 */
+	u16 rxdfrmmcast;	/* 0xc8 */
+	u16 rxmfrmmcast;	/* 0xca */
+	u16 rxcfrmmcast;	/* 0xcc */
+	u16 rxbeaconmbss;	/* 0xce */
+	u16 rxdfrmucastobss;	/* 0xd0 */
+	u16 rxbeaconobss;	/* 0xd2 */
+	u16 rxrsptmout;	/* 0xd4 */
+	u16 bcntxcancl;	/* 0xd6 */
+	u16 PAD;
+	u16 rxf0ovfl;	/* 0xda */
+	u16 rxf1ovfl;	/* 0xdc */
+	u16 rxf2ovfl;	/* 0xde */
+	u16 txsfovfl;	/* 0xe0 */
+	u16 pmqovfl;		/* 0xe2 */
+	u16 rxcgprqfrm;	/* 0xe4 */
+	u16 rxcgprsqovfl;	/* 0xe6 */
+	u16 txcgprsfail;	/* 0xe8 */
+	u16 txcgprssuc;	/* 0xea */
+	u16 prs_timeout;	/* 0xec */
+	u16 rxnack;
+	u16 frmscons;
+	u16 txnack;
+	u16 txglitch_nack;
+	u16 txburst;		/* 0xf6 # tx bursts */
+	u16 bphy_rxcrsglitch;	/* bphy rx crs glitch */
+	u16 phywatchdog;	/* 0xfa # of phy watchdog events */
+	u16 PAD;
+	u16 bphy_badplcp;	/* bphy bad plcp */
 } macstat_t;
 
 /* dot11 core-specific control flags */
--- a/drivers/staging/brcm80211/include/hnddma.h
+++ b/drivers/staging/brcm80211/include/hnddma.h
@@ -59,8 +59,8 @@ typedef void *(*di_getnexttxp_t) (hnddma
 typedef void *(*di_getnextrxp_t) (hnddma_t *dmah, bool forceall);
 typedef void *(*di_peeknexttxp_t) (hnddma_t *dmah);
 typedef void *(*di_peeknextrxp_t) (hnddma_t *dmah);
-typedef void (*di_rxparam_get_t) (hnddma_t *dmah, uint16 *rxoffset,
-				  uint16 *rxbufsize);
+typedef void (*di_rxparam_get_t) (hnddma_t *dmah, u16 *rxoffset,
+				  u16 *rxbufsize);
 typedef void (*di_txblock_t) (hnddma_t *dmah);
 typedef void (*di_txunblock_t) (hnddma_t *dmah);
 typedef uint(*di_txactive_t) (hnddma_t *dmah);
--- a/drivers/staging/brcm80211/include/hndpmu.h
+++ b/drivers/staging/brcm80211/include/hndpmu.h
@@ -46,7 +46,7 @@ extern void si_pmu_set_switcher_voltage(
 					u8 bb_voltage, u8 rf_voltage);
 extern void si_pmu_set_ldo_voltage(si_t *sih, osl_t *osh, u8 ldo,
 				   u8 voltage);
-extern uint16 si_pmu_fast_pwrup_delay(si_t *sih, osl_t *osh);
+extern u16 si_pmu_fast_pwrup_delay(si_t *sih, osl_t *osh);
 extern void si_pmu_rcal(si_t *sih, osl_t *osh);
 extern void si_pmu_pllupd(si_t *sih);
 extern void si_pmu_spuravoid(si_t *sih, osl_t *osh, u8 spuravoid);
--- a/drivers/staging/brcm80211/include/hndtcam.h
+++ b/drivers/staging/brcm80211/include/hndtcam.h
@@ -39,8 +39,8 @@ typedef struct patchaddrvalue {
 } patchaddrvalue_t;
 
 extern void hnd_patch_init(void *srp);
-extern void hnd_tcam_write(void *srp, uint16 index, uint32 data);
-extern void hnd_tcam_read(void *srp, uint16 index, uint32 * content);
+extern void hnd_tcam_write(void *srp, u16 index, uint32 data);
+extern void hnd_tcam_read(void *srp, u16 index, uint32 * content);
 void *hnd_tcam_init(void *srp, uint no_addrs);
 extern void hnd_tcam_disablepatch(void *srp);
 extern void hnd_tcam_enablepatch(void *srp);
--- a/drivers/staging/brcm80211/include/linux_osl.h
+++ b/drivers/staging/brcm80211/include/linux_osl.h
@@ -128,7 +128,7 @@ extern void *osl_dma_alloc_consistent(os
 #define	DMA_ALLOC_CONSISTENT(osh, size, align, tot, pap, dmah) \
 	osl_dma_alloc_consistent((osh), (size), (align), (tot), (pap))
 extern uint osl_dma_consistent_align(void);
-extern void *osl_dma_alloc_consistent(osl_t *osh, uint size, uint16 align,
+extern void *osl_dma_alloc_consistent(osl_t *osh, uint size, u16 align,
 				      uint *tot, unsigned long *pap);
 #endif
 #define	DMA_FREE_CONSISTENT(osh, va, size, pa, dmah) \
@@ -193,7 +193,7 @@ extern int osl_error(int bcmerror);
 #ifndef __mips__
 #define R_REG(osh, r) (\
 	SELECT_BUS_READ(osh, sizeof(*(r)) == sizeof(u8) ? readb((volatile u8*)(r)) : \
-	sizeof(*(r)) == sizeof(uint16) ? readw((volatile uint16*)(r)) : \
+	sizeof(*(r)) == sizeof(u16) ? readw((volatile u16*)(r)) : \
 	readl((volatile uint32*)(r)), OSL_READ_REG(osh, r)) \
 )
 #else				/* __mips__ */
@@ -206,8 +206,8 @@ extern int osl_error(int bcmerror);
 			case sizeof(u8): \
 				__osl_v = readb((volatile u8*)(r)); \
 				break; \
-			case sizeof(uint16): \
-				__osl_v = readw((volatile uint16*)(r)); \
+			case sizeof(u16): \
+				__osl_v = readw((volatile u16*)(r)); \
 				break; \
 			case sizeof(uint32): \
 				__osl_v = \
@@ -232,8 +232,8 @@ extern int osl_error(int bcmerror);
 		switch (sizeof(*(r))) { \
 		case sizeof(u8): \
 			writeb((u8)(v), (volatile u8*)(r)); break; \
-		case sizeof(uint16): \
-			writew((uint16)(v), (volatile uint16*)(r)); break; \
+		case sizeof(u16): \
+			writew((u16)(v), (volatile u16*)(r)); break; \
 		case sizeof(uint32): \
 			writel((uint32)(v), (volatile uint32*)(r)); break; \
 		}, \
@@ -249,9 +249,9 @@ extern int osl_error(int bcmerror);
 				__osl_v = \
 				readb((volatile u8*)((uintptr)(r)^3)); \
 				break; \
-			case sizeof(uint16): \
+			case sizeof(u16): \
 				__osl_v = \
-				readw((volatile uint16*)((uintptr)(r)^2)); \
+				readw((volatile u16*)((uintptr)(r)^2)); \
 				break; \
 			case sizeof(uint32): \
 				__osl_v = readl((volatile uint32*)(r)); \
@@ -267,9 +267,9 @@ extern int osl_error(int bcmerror);
 		case sizeof(u8):	\
 			writeb((u8)(v), \
 			(volatile u8*)((uintptr)(r)^3)); break; \
-		case sizeof(uint16):	\
-			writew((uint16)(v), \
-			(volatile uint16*)((uintptr)(r)^2)); break; \
+		case sizeof(u16):	\
+			writew((u16)(v), \
+			(volatile u16*)((uintptr)(r)^2)); break; \
 		case sizeof(uint32):	\
 			writel((uint32)(v), \
 			(volatile uint32*)(r)); break; \
@@ -413,7 +413,7 @@ osl_pkt_tonative(osl_pubinfo_t *osh, voi
 #if defined(BCMSDIO) && !defined(BRCM_FULLMAC)
 #define RPC_READ_REG(osh, r) (\
 	sizeof(*(r)) == sizeof(u8) ? osl_readb((osh), (volatile u8*)(r)) : \
-	sizeof(*(r)) == sizeof(uint16) ? osl_readw((osh), (volatile uint16*)(r)) : \
+	sizeof(*(r)) == sizeof(u16) ? osl_readw((osh), (volatile u16*)(r)) : \
 	osl_readl((osh), (volatile uint32*)(r)) \
 )
 #define RPC_WRITE_REG(osh, r, v) do { \
@@ -421,8 +421,8 @@ osl_pkt_tonative(osl_pubinfo_t *osh, voi
 	case sizeof(u8): \
 		osl_writeb((osh), (volatile u8*)(r), (u8)(v)); \
 		break; \
-	case sizeof(uint16): \
-		osl_writew((osh), (volatile uint16*)(r), (uint16)(v)); \
+	case sizeof(u16): \
+		osl_writew((osh), (volatile u16*)(r), (u16)(v)); \
 		break; \
 	case sizeof(uint32): \
 		osl_writel((osh), (volatile uint32*)(r), (uint32)(v)); \
@@ -431,10 +431,10 @@ osl_pkt_tonative(osl_pubinfo_t *osh, voi
 } while (0)
 
 extern u8 osl_readb(osl_t *osh, volatile u8 *r);
-extern uint16 osl_readw(osl_t *osh, volatile uint16 *r);
+extern u16 osl_readw(osl_t *osh, volatile u16 *r);
 extern uint32 osl_readl(osl_t *osh, volatile uint32 *r);
 extern void osl_writeb(osl_t *osh, volatile u8 *r, u8 v);
-extern void osl_writew(osl_t *osh, volatile uint16 *r, uint16 v);
+extern void osl_writew(osl_t *osh, volatile u16 *r, u16 v);
 extern void osl_writel(osl_t *osh, volatile uint32 *r, uint32 v);
 #endif				/* BCMSDIO */
 
--- a/drivers/staging/brcm80211/include/msgtrace.h
+++ b/drivers/staging/brcm80211/include/msgtrace.h
@@ -28,7 +28,7 @@
 typedef BWL_PRE_PACKED_STRUCT struct msgtrace_hdr {
 	u8 version;
 	u8 spare;
-	uint16 len;		/* Len of the trace */
+	u16 len;		/* Len of the trace */
 	uint32 seqnum;		/* Sequence number of message. Useful
 				 * if the messsage has been lost
 				 * because of DMA error or a bus reset
@@ -55,8 +55,8 @@ typedef BWL_PRE_PACKED_STRUCT struct msg
 extern bool msgtrace_hbus_trace;
 
 typedef void (*msgtrace_func_send_t) (void *hdl1, void *hdl2, u8 *hdr,
-				      uint16 hdrlen, u8 *buf,
-				      uint16 buflen);
+				      u16 hdrlen, u8 *buf,
+				      u16 buflen);
 
 extern void msgtrace_sent(void);
 extern void msgtrace_put(char *buf, int count);
--- a/drivers/staging/brcm80211/include/pci_core.h
+++ b/drivers/staging/brcm80211/include/pci_core.h
@@ -50,7 +50,7 @@ typedef struct sbpciregs {
 	uint32 sbtopci2;	/* Sonics to PCI translation 2 */
 	uint32 PAD[189];
 	uint32 pcicfg[4][64];	/* 0x400 - 0x7FF, PCI Cfg Space (>=rev8) */
-	uint16 sprom[36];	/* SPROM shadow Area */
+	u16 sprom[36];	/* SPROM shadow Area */
 	uint32 PAD[46];
 } sbpciregs_t;
 
--- a/drivers/staging/brcm80211/include/pcicfg.h
+++ b/drivers/staging/brcm80211/include/pcicfg.h
@@ -103,10 +103,10 @@
 #define PCI_CAPPTR_PRESENT	0x0010
 
 typedef struct _pci_config_regs {
-	uint16 vendor;
-	uint16 device;
-	uint16 command;
-	uint16 status;
+	u16 vendor;
+	u16 device;
+	u16 command;
+	u16 status;
 	u8 rev_id;
 	u8 prog_if;
 	u8 sub_class;
@@ -117,8 +117,8 @@ typedef struct _pci_config_regs {
 	u8 bist;
 	uint32 base[PCI_BAR_MAX];
 	uint32 cardbus_cis;
-	uint16 subsys_vendor;
-	uint16 subsys_id;
+	u16 subsys_vendor;
+	u16 subsys_id;
 	uint32 baserom;
 	uint32 rsvd_a[PCR_RSVDA_MAX];
 	u8 int_line;
@@ -331,10 +331,10 @@ typedef enum {
 #define	PPB_RSVDD_MAX		8
 
 typedef struct _ppb_config_regs {
-	uint16 vendor;
-	uint16 device;
-	uint16 command;
-	uint16 status;
+	u16 vendor;
+	u16 device;
+	u16 command;
+	u16 status;
 	u8 rev_id;
 	u8 prog_if;
 	u8 sub_class;
@@ -350,24 +350,24 @@ typedef struct _ppb_config_regs {
 	u8 sec_lat;
 	u8 io_base;
 	u8 io_lim;
-	uint16 sec_status;
-	uint16 mem_base;
-	uint16 mem_lim;
-	uint16 pf_mem_base;
-	uint16 pf_mem_lim;
+	u16 sec_status;
+	u16 mem_base;
+	u16 mem_lim;
+	u16 pf_mem_base;
+	u16 pf_mem_lim;
 	uint32 pf_mem_base_hi;
 	uint32 pf_mem_lim_hi;
-	uint16 io_base_hi;
-	uint16 io_lim_hi;
-	uint16 subsys_vendor;
-	uint16 subsys_id;
+	u16 io_base_hi;
+	u16 io_lim_hi;
+	u16 subsys_vendor;
+	u16 subsys_id;
 	uint32 rsvd_b;
 	u8 rsvd_c;
 	u8 int_pin;
-	uint16 bridge_ctrl;
+	u16 bridge_ctrl;
 	u8 chip_ctrl;
 	u8 diag_ctrl;
-	uint16 arb_ctrl;
+	u16 arb_ctrl;
 	uint32 rsvd_d[PPB_RSVDD_MAX];
 	u8 dev_dep[192];
 } ppb_config_regs;
@@ -384,7 +384,7 @@ typedef struct _ppb_config_regs {
 typedef struct _pciconfig_cap_msi {
 	u8 capID;
 	u8 nextptr;
-	uint16 msgctrl;
+	u16 msgctrl;
 	uint32 msgaddr;
 } pciconfig_cap_msi;
 
@@ -394,8 +394,8 @@ typedef struct _pciconfig_cap_msi {
 typedef struct _pciconfig_cap_pwrmgmt {
 	u8 capID;
 	u8 nextptr;
-	uint16 pme_cap;
-	uint16 pme_sts_ctrl;
+	u16 pme_cap;
+	u16 pme_sts_ctrl;
 	u8 pme_bridge_ext;
 	u8 data;
 } pciconfig_cap_pwrmgmt;
@@ -409,18 +409,18 @@ typedef struct _pciconfig_cap_pwrmgmt {
 typedef struct _pciconfig_cap_pcie {
 	u8 capID;
 	u8 nextptr;
-	uint16 pcie_cap;
+	u16 pcie_cap;
 	uint32 dev_cap;
-	uint16 dev_ctrl;
-	uint16 dev_status;
+	u16 dev_ctrl;
+	u16 dev_status;
 	uint32 link_cap;
-	uint16 link_ctrl;
-	uint16 link_status;
+	u16 link_ctrl;
+	u16 link_status;
 	uint32 slot_cap;
-	uint16 slot_ctrl;
-	uint16 slot_status;
-	uint16 root_ctrl;
-	uint16 root_cap;
+	u16 slot_ctrl;
+	u16 slot_status;
+	u16 root_ctrl;
+	u16 root_cap;
 	uint32 root_status;
 } pciconfig_cap_pcie;
 
@@ -453,9 +453,9 @@ typedef struct _pciconfig_cap_pcie {
 
 /* Header to define the PCIE specific capabilities in the extended config space */
 typedef struct _pcie_enhanced_caphdr {
-	uint16 capID;
-	uint16 cap_ver:4;
-	uint16 next_ptr:12;
+	u16 capID;
+	u16 cap_ver:4;
+	u16 next_ptr:12;
 } pcie_enhanced_caphdr;
 
 /* Everything below is BRCM HND proprietary */
--- a/drivers/staging/brcm80211/include/pcie_core.h
+++ b/drivers/staging/brcm80211/include/pcie_core.h
@@ -76,7 +76,7 @@ typedef struct sbpcieregs {
 	uint32 clkreqenctrl;	/* >= rev 6, Clkreq rdma control : 0x138 */
 	uint32 PAD[177];
 	uint32 pciecfg[4][64];	/* 0x400 - 0x7FF, PCIE Cfg Space */
-	uint16 sprom[64];	/* SPROM shadow Area */
+	u16 sprom[64];	/* SPROM shadow Area */
 } sbpcieregs_t;
 
 /* PCI control */
--- a/drivers/staging/brcm80211/include/proto/802.11.h
+++ b/drivers/staging/brcm80211/include/proto/802.11.h
@@ -47,18 +47,18 @@
 #define DOT11_OUI_LEN			3
 
 BWL_PRE_PACKED_STRUCT struct dot11_header {
-	uint16 fc;
-	uint16 durid;
+	u16 fc;
+	u16 durid;
 	struct ether_addr a1;
 	struct ether_addr a2;
 	struct ether_addr a3;
-	uint16 seq;
+	u16 seq;
 	struct ether_addr a4;
 } BWL_POST_PACKED_STRUCT;
 
 BWL_PRE_PACKED_STRUCT struct dot11_rts_frame {
-	uint16 fc;
-	uint16 durid;
+	u16 fc;
+	u16 durid;
 	struct ether_addr ra;
 	struct ether_addr ta;
 } BWL_POST_PACKED_STRUCT;
@@ -71,19 +71,19 @@ BWL_PRE_PACKED_STRUCT struct dot11_rts_f
 #define DOT11_BA_LEN		4
 
 BWL_PRE_PACKED_STRUCT struct dot11_management_header {
-	uint16 fc;
-	uint16 durid;
+	u16 fc;
+	u16 durid;
 	struct ether_addr da;
 	struct ether_addr sa;
 	struct ether_addr bssid;
-	uint16 seq;
+	u16 seq;
 } BWL_POST_PACKED_STRUCT;
 #define	DOT11_MGMT_HDR_LEN	24
 
 BWL_PRE_PACKED_STRUCT struct dot11_bcn_prb {
 	uint32 timestamp[2];
-	uint16 beacon_interval;
-	uint16 capability;
+	u16 beacon_interval;
+	u16 capability;
 } BWL_POST_PACKED_STRUCT;
 #define	DOT11_BCN_PRB_LEN	12
 
@@ -106,7 +106,7 @@ typedef u8 ac_bitmap_t;
 BWL_PRE_PACKED_STRUCT struct edcf_acparam {
 	u8 ACI;
 	u8 ECW;
-	uint16 TXOP;
+	u16 TXOP;
 } BWL_POST_PACKED_STRUCT;
 typedef struct edcf_acparam edcf_acparam_t;
 
@@ -255,10 +255,10 @@ typedef struct d11cnt {
 #define MCSSET_LEN	16
 
 BWL_PRE_PACKED_STRUCT struct ht_cap_ie {
-	uint16 cap;
+	u16 cap;
 	u8 params;
 	u8 supp_mcs[MCSSET_LEN];
-	uint16 ext_htcap;
+	u16 ext_htcap;
 	uint32 txbf_cap;
 	u8 as_cap;
 } BWL_POST_PACKED_STRUCT;
--- a/drivers/staging/brcm80211/include/proto/bcmeth.h
+++ b/drivers/staging/brcm80211/include/proto/bcmeth.h
@@ -37,11 +37,11 @@
 #define BCMILCP_BCM_SUBTYPEHDR_VERSION		0
 
 typedef BWL_PRE_PACKED_STRUCT struct bcmeth_hdr {
-	uint16 subtype;
-	uint16 length;
+	u16 subtype;
+	u16 length;
 	u8 version;
 	u8 oui[3];
-	uint16 usr_subtype;
+	u16 usr_subtype;
 } BWL_POST_PACKED_STRUCT bcmeth_hdr_t;
 
 #include <packed_section_end.h>
--- a/drivers/staging/brcm80211/include/proto/bcmevent.h
+++ b/drivers/staging/brcm80211/include/proto/bcmevent.h
@@ -28,8 +28,8 @@
 #define WLC_EVENT_MSG_GROUP		0x04
 
 typedef BWL_PRE_PACKED_STRUCT struct {
-	uint16 version;
-	uint16 flags;
+	u16 version;
+	u16 flags;
 	uint32 event_type;
 	uint32 status;
 	uint32 reason;
--- a/drivers/staging/brcm80211/include/proto/ethernet.h
+++ b/drivers/staging/brcm80211/include/proto/ethernet.h
@@ -56,7 +56,7 @@
 BWL_PRE_PACKED_STRUCT struct ether_header {
 	u8 ether_dhost[ETHER_ADDR_LEN];
 	u8 ether_shost[ETHER_ADDR_LEN];
-	uint16 ether_type;
+	u16 ether_type;
 } BWL_POST_PACKED_STRUCT;
 
 BWL_PRE_PACKED_STRUCT struct ether_addr {
--- a/drivers/staging/brcm80211/include/proto/vlan.h
+++ b/drivers/staging/brcm80211/include/proto/vlan.h
@@ -34,9 +34,9 @@
 struct ethervlan_header {
 	u8 ether_dhost[ETHER_ADDR_LEN];
 	u8 ether_shost[ETHER_ADDR_LEN];
-	uint16 vlan_type;
-	uint16 vlan_tag;
-	uint16 ether_type;
+	u16 vlan_type;
+	u16 vlan_tag;
+	u16 ether_type;
 };
 
 #define	ETHERVLAN_HDR_LEN	(ETHER_HDR_LEN + VLAN_TAG_LEN)
--- a/drivers/staging/brcm80211/include/qmath.h
+++ b/drivers/staging/brcm80211/include/qmath.h
@@ -27,7 +27,7 @@ int16 qm_mul16(int16 op1, int16 op2);
 
 int32 qm_muls321616(int16 op1, int16 op2);
 
-uint16 qm_mulu16(uint16 op1, uint16 op2);
+u16 qm_mulu16(u16 op1, u16 op2);
 
 int16 qm_muls16(int16 op1, int16 op2);
 
@@ -65,7 +65,7 @@ int16 qm_div163232(int32 num, int32 deno
 
 int32 qm_mul323216(int32 op1, int16 op2);
 
-int32 qm_mulsu321616(int16 op1, uint16 op2);
+int32 qm_mulsu321616(int16 op1, u16 op2);
 
 int32 qm_muls323216(int32 op1, int16 op2);
 
--- a/drivers/staging/brcm80211/include/sbchipc.h
+++ b/drivers/staging/brcm80211/include/sbchipc.h
@@ -220,7 +220,7 @@ typedef volatile struct {
 	uint32 pmustrapopt;	/* 0x668, corerev >= 28 */
 	uint32 pmu_xtalfreq;	/* 0x66C, pmurev >= 10 */
 	uint32 PAD[100];
-	uint16 sromotp[768];
+	u16 sromotp[768];
 } chipcregs_t;
 
 #endif				/* _LANGUAGE_ASSEMBLY */
--- a/drivers/staging/brcm80211/include/sbhnddma.h
+++ b/drivers/staging/brcm80211/include/sbhnddma.h
@@ -308,8 +308,8 @@ typedef volatile struct {
 
 /* receive frame status */
 typedef volatile struct {
-	uint16 len;
-	uint16 flags;
+	u16 len;
+	u16 flags;
 } dma_rxh_t;
 
 #endif				/* _sbhnddma_h_ */
--- a/drivers/staging/brcm80211/include/sbhndpio.h
+++ b/drivers/staging/brcm80211/include/sbhndpio.h
@@ -25,10 +25,10 @@
 
 /* 2byte-wide pio register set per channel(xmt or rcv) */
 typedef volatile struct {
-	uint16 fifocontrol;
-	uint16 fifodata;
-	uint16 fifofree;	/* only valid in xmt channel, not in rcv channel */
-	uint16 PAD;
+	u16 fifocontrol;
+	u16 fifodata;
+	u16 fifofree;	/* only valid in xmt channel, not in rcv channel */
+	u16 PAD;
 } pio2regs_t;
 
 /* a pair of pio channels(tx and rx) */
--- a/drivers/staging/brcm80211/include/sbsdpcmdev.h
+++ b/drivers/staging/brcm80211/include/sbsdpcmdev.h
@@ -60,14 +60,14 @@ typedef volatile struct {
 	uint32 biststatus;	/* BistStatus, 0x00c, rev8  */
 
 	/* PCMCIA access */
-	uint16 pcmciamesportaladdr;	/* PcmciaMesPortalAddr, 0x010, rev8   */
-	uint16 PAD[1];
-	uint16 pcmciamesportalmask;	/* PcmciaMesPortalMask, 0x014, rev8   */
-	uint16 PAD[1];
-	uint16 pcmciawrframebc;	/* PcmciaWrFrameBC, 0x018, rev8   */
-	uint16 PAD[1];
-	uint16 pcmciaunderflowtimer;	/* PcmciaUnderflowTimer, 0x01c, rev8   */
-	uint16 PAD[1];
+	u16 pcmciamesportaladdr;	/* PcmciaMesPortalAddr, 0x010, rev8   */
+	u16 PAD[1];
+	u16 pcmciamesportalmask;	/* PcmciaMesPortalMask, 0x014, rev8   */
+	u16 PAD[1];
+	u16 pcmciawrframebc;	/* PcmciaWrFrameBC, 0x018, rev8   */
+	u16 PAD[1];
+	u16 pcmciaunderflowtimer;	/* PcmciaUnderflowTimer, 0x01c, rev8   */
+	u16 PAD[1];
 
 	/* interrupt */
 	uint32 intstatus;	/* IntStatus, 0x020, rev8   */
@@ -125,22 +125,22 @@ typedef volatile struct {
 
 	/* PCMCIA function control registers */
 	char pcmciafcr[256];	/* PCMCIA FCR, 0x600-6ff, rev6 */
-	uint16 PAD[55];
+	u16 PAD[55];
 
 	/* PCMCIA backplane access */
-	uint16 backplanecsr;	/* BackplaneCSR, 0x76E, rev6 */
-	uint16 backplaneaddr0;	/* BackplaneAddr0, 0x770, rev6 */
-	uint16 backplaneaddr1;	/* BackplaneAddr1, 0x772, rev6 */
-	uint16 backplaneaddr2;	/* BackplaneAddr2, 0x774, rev6 */
-	uint16 backplaneaddr3;	/* BackplaneAddr3, 0x776, rev6 */
-	uint16 backplanedata0;	/* BackplaneData0, 0x778, rev6 */
-	uint16 backplanedata1;	/* BackplaneData1, 0x77a, rev6 */
-	uint16 backplanedata2;	/* BackplaneData2, 0x77c, rev6 */
-	uint16 backplanedata3;	/* BackplaneData3, 0x77e, rev6 */
-	uint16 PAD[31];
+	u16 backplanecsr;	/* BackplaneCSR, 0x76E, rev6 */
+	u16 backplaneaddr0;	/* BackplaneAddr0, 0x770, rev6 */
+	u16 backplaneaddr1;	/* BackplaneAddr1, 0x772, rev6 */
+	u16 backplaneaddr2;	/* BackplaneAddr2, 0x774, rev6 */
+	u16 backplaneaddr3;	/* BackplaneAddr3, 0x776, rev6 */
+	u16 backplanedata0;	/* BackplaneData0, 0x778, rev6 */
+	u16 backplanedata1;	/* BackplaneData1, 0x77a, rev6 */
+	u16 backplanedata2;	/* BackplaneData2, 0x77c, rev6 */
+	u16 backplanedata3;	/* BackplaneData3, 0x77e, rev6 */
+	u16 PAD[31];
 
 	/* sprom "size" & "blank" info */
-	uint16 spromstatus;	/* SPROMStatus, 0x7BE, rev2 */
+	u16 spromstatus;	/* SPROMStatus, 0x7BE, rev2 */
 	uint32 PAD[464];
 
 	/* Sonics SiliconBackplane registers */
@@ -264,8 +264,8 @@ typedef volatile struct {
 
 /* rx header */
 typedef volatile struct {
-	uint16 len;
-	uint16 flags;
+	u16 len;
+	u16 flags;
 } sdpcmd_rxh_t;
 
 /* rx header flags */
--- a/drivers/staging/brcm80211/include/siutils.h
+++ b/drivers/staging/brcm80211/include/siutils.h
@@ -178,7 +178,7 @@ extern void si_register_intr_callback(si
 				      void *intrsenabled_fn, void *intr_arg);
 extern void si_deregister_intr_callback(si_t *sih);
 extern void si_clkctl_init(si_t *sih);
-extern uint16 si_clkctl_fast_pwrup_delay(si_t *sih);
+extern u16 si_clkctl_fast_pwrup_delay(si_t *sih);
 extern bool si_clkctl_cc(si_t *sih, uint mode);
 extern int si_clkctl_xtal(si_t *sih, uint what, bool on);
 extern uint32 si_gpiotimerval(si_t *sih, uint32 mask, uint32 val);
@@ -227,7 +227,7 @@ extern uint si_pcie_readreg(void *sih, u
 extern void si_sdio_init(si_t *sih);
 #endif
 
-extern uint16 si_d11_devid(si_t *sih);
+extern u16 si_d11_devid(si_t *sih);
 
 #define si_eci(sih) 0
 #define si_eci_init(sih) (0)
--- a/drivers/staging/brcm80211/include/spid.h
+++ b/drivers/staging/brcm80211/include/spid.h
@@ -29,12 +29,12 @@ typedef volatile struct {
 				 * function selection, command/data error check
 				 */
 	u8 reset_bp;		/* 0x03, reset on wlan/bt backplane reset (corerev >= 1) */
-	uint16 intr_reg;	/* 0x04, Intr status register */
-	uint16 intr_en_reg;	/* 0x06, Intr mask register */
+	u16 intr_reg;	/* 0x04, Intr status register */
+	u16 intr_en_reg;	/* 0x06, Intr mask register */
 	uint32 status_reg;	/* 0x08, RO, Status bits of last spi transfer */
-	uint16 f1_info_reg;	/* 0x0c, RO, enabled, ready for data transfer, blocksize */
-	uint16 f2_info_reg;	/* 0x0e, RO, enabled, ready for data transfer, blocksize */
-	uint16 f3_info_reg;	/* 0x10, RO, enabled, ready for data transfer, blocksize */
+	u16 f1_info_reg;	/* 0x0c, RO, enabled, ready for data transfer, blocksize */
+	u16 f2_info_reg;	/* 0x0e, RO, enabled, ready for data transfer, blocksize */
+	u16 f3_info_reg;	/* 0x10, RO, enabled, ready for data transfer, blocksize */
 	uint32 test_read;	/* 0x14, RO 0xfeedbead signature */
 	uint32 test_rw;		/* 0x18, RW */
 	u8 resp_delay_f0;	/* 0x1c, read resp delay bytes for F0 (corerev >= 3) */
--- a/drivers/staging/brcm80211/include/typedefs.h
+++ b/drivers/staging/brcm80211/include/typedefs.h
@@ -44,10 +44,6 @@ typedef unsigned int uint;
 
 /* define [u]int16/32/64, uintptr */
 
-#ifndef TYPEDEF_UINT16
-typedef unsigned short uint16;
-#endif
-
 #ifndef TYPEDEF_UINT32
 typedef unsigned int uint32;
 #endif
@@ -85,7 +81,6 @@ typedef signed int int32;
 #define	AUTO	(-1)		/* Auto = -1 */
 
 #undef TYPEDEF_UINT
-#undef TYPEDEF_UINT16
 #undef TYPEDEF_UINT32
 #undef TYPEDEF_UINTPTR
 #undef TYPEDEF_INT16
--- a/drivers/staging/brcm80211/include/wlioctl.h
+++ b/drivers/staging/brcm80211/include/wlioctl.h
@@ -44,8 +44,8 @@ typedef struct wl_bss_info_107 {
 				 * starting at version and including IEs
 				 */
 	struct ether_addr BSSID;
-	uint16 beacon_period;	/* units are Kusec */
-	uint16 capability;	/* Capability information */
+	u16 beacon_period;	/* units are Kusec */
+	u16 capability;	/* Capability information */
 	u8 SSID_len;
 	u8 SSID[32];
 	struct {
@@ -53,7 +53,7 @@ typedef struct wl_bss_info_107 {
 		u8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
 	} rateset;		/* supported rates */
 	u8 channel;		/* Channel no. */
-	uint16 atim_window;	/* units are Kusec */
+	u16 atim_window;	/* units are Kusec */
 	u8 dtim_period;	/* DTIM period */
 	int16 RSSI;		/* receive signal strength (in dBm) */
 	s8 phy_noise;		/* noise (in dBm) */
@@ -77,8 +77,8 @@ typedef struct wl_bss_info_108 {
 				 * starting at version and including IEs
 				 */
 	struct ether_addr BSSID;
-	uint16 beacon_period;	/* units are Kusec */
-	uint16 capability;	/* Capability information */
+	u16 beacon_period;	/* units are Kusec */
+	u16 capability;	/* Capability information */
 	u8 SSID_len;
 	u8 SSID[32];
 	struct {
@@ -86,7 +86,7 @@ typedef struct wl_bss_info_108 {
 		u8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
 	} rateset;		/* supported rates */
 	chanspec_t chanspec;	/* chanspec for bss */
-	uint16 atim_window;	/* units are Kusec */
+	u16 atim_window;	/* units are Kusec */
 	u8 dtim_period;	/* DTIM period */
 	int16 RSSI;		/* receive signal strength (in dBm) */
 	s8 phy_noise;		/* noise (in dBm) */
@@ -99,7 +99,7 @@ typedef struct wl_bss_info_108 {
 	u8 reserved[3];	/* Reserved for expansion of BSS properties */
 	u8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
 
-	uint16 ie_offset;	/* offset at which IEs start, from beginning */
+	u16 ie_offset;	/* offset at which IEs start, from beginning */
 	uint32 ie_length;	/* byte length of Information Elements */
 	/* Add new fields here */
 	/* variable length Information Elements */
@@ -121,8 +121,8 @@ typedef struct wl_bss_info {
 				 * starting at version and including IEs
 				 */
 	struct ether_addr BSSID;
-	uint16 beacon_period;	/* units are Kusec */
-	uint16 capability;	/* Capability information */
+	u16 beacon_period;	/* units are Kusec */
+	u16 capability;	/* Capability information */
 	u8 SSID_len;
 	u8 SSID[32];
 	struct {
@@ -130,7 +130,7 @@ typedef struct wl_bss_info {
 		u8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
 	} rateset;		/* supported rates */
 	chanspec_t chanspec;	/* chanspec for bss */
-	uint16 atim_window;	/* units are Kusec */
+	u16 atim_window;	/* units are Kusec */
 	u8 dtim_period;	/* DTIM period */
 	int16 RSSI;		/* receive signal strength (in dBm) */
 	s8 phy_noise;		/* noise (in dBm) */
@@ -143,7 +143,7 @@ typedef struct wl_bss_info {
 	u8 reserved[3];	/* Reserved for expansion of BSS properties */
 	u8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
 
-	uint16 ie_offset;	/* offset at which IEs start, from beginning */
+	u16 ie_offset;	/* offset at which IEs start, from beginning */
 	uint32 ie_length;	/* byte length of Information Elements */
 	int16 SNR;		/* average SNR of during frame reception */
 	/* Add new fields here */
@@ -229,7 +229,7 @@ typedef struct wl_scan_params {
 				 * parameter portion is assumed, otherwise ssid in
 				 * the fixed portion is ignored
 				 */
-	uint16 channel_list[1];	/* list of chanspecs */
+	u16 channel_list[1];	/* list of chanspecs */
 } wl_scan_params_t;
 
 /* size of wl_scan_params not including variable length array */
@@ -248,8 +248,8 @@ typedef struct wl_scan_params {
 /* incremental scan struct */
 typedef struct wl_iscan_params {
 	uint32 version;
-	uint16 action;
-	uint16 scan_duration;
+	u16 action;
+	u16 scan_duration;
 	wl_scan_params_t params;
 } wl_iscan_params_t;
 
@@ -277,8 +277,8 @@ typedef struct wl_scan_results {
 
 typedef struct wl_escan_params {
 	uint32 version;
-	uint16 action;
-	uint16 sync_id;
+	u16 action;
+	u16 sync_id;
 	wl_scan_params_t params;
 } wl_escan_params_t;
 
@@ -287,8 +287,8 @@ typedef struct wl_escan_params {
 typedef struct wl_escan_result {
 	uint32 buflen;
 	uint32 version;
-	uint16 sync_id;
-	uint16 bss_count;
+	u16 sync_id;
+	u16 bss_count;
 	wl_bss_info_t bss_info[1];
 } wl_escan_result_t;
 
@@ -552,7 +552,7 @@ typedef struct wl_wsec_key {
 	/* Rx IV */
 	struct {
 		uint32 hi;	/* upper 32 bits of IV */
-		uint16 lo;	/* lower 16 bits of IV */
+		u16 lo;	/* lower 16 bits of IV */
 	} rxiv;
 	uint32 pad_5[2];
 	struct ether_addr ea;	/* per station */
@@ -629,7 +629,7 @@ typedef struct wl_led_info {
 typedef struct {
 	uint byteoff;		/* byte offset */
 	uint nbytes;		/* number of bytes */
-	uint16 buf[1];
+	u16 buf[1];
 } srom_rw_t;
 
 /* similar cis (srom or otp) struct [iovar: may not be aligned] */
@@ -661,10 +661,10 @@ typedef struct {
 #define WL_ATTEN_PCL_OFF		2	/* turn off PCL. */
 
 typedef struct {
-	uint16 auto_ctrl;	/* WL_ATTEN_XX */
-	uint16 bb;		/* Baseband attenuation */
-	uint16 radio;		/* Radio attenuation */
-	uint16 txctl1;		/* Radio TX_CTL1 value */
+	u16 auto_ctrl;	/* WL_ATTEN_XX */
+	u16 bb;		/* Baseband attenuation */
+	u16 radio;		/* Radio attenuation */
+	u16 txctl1;		/* Radio TX_CTL1 value */
 } atten_t;
 
 /* Per-AC retry parameters */
@@ -673,7 +673,7 @@ struct wme_tx_params_s {
 	u8 short_fallback;
 	u8 long_retry;
 	u8 long_fallback;
-	uint16 max_rate;	/* In units of 512 Kbps */
+	u16 max_rate;	/* In units of 512 Kbps */
 };
 
 typedef struct wme_tx_params_s wme_tx_params_t;
@@ -701,9 +701,9 @@ typedef struct {
 #define BCM_MAC_STATUS_INDICATION	(0x40010200L)
 
 typedef struct {
-	uint16 ver;		/* version of this struct */
-	uint16 len;		/* length in bytes of this structure */
-	uint16 cap;		/* sta's advertised capabilities */
+	u16 ver;		/* version of this struct */
+	u16 len;		/* length in bytes of this structure */
+	u16 cap;		/* sta's advertised capabilities */
 	uint32 flags;		/* flags defined below */
 	uint32 idle;		/* time since data pkt rx'd from sta */
 	struct ether_addr ea;	/* Station address */
@@ -819,9 +819,9 @@ typedef struct wl_instance_info {
 
 /* structure to change size of tx fifo */
 typedef struct wl_txfifo_sz {
-	uint16 magic;
-	uint16 fifo;
-	uint16 size;
+	u16 magic;
+	u16 fifo;
+	u16 size;
 } wl_txfifo_sz_t;
 /* magic pattern used for mismatch driver and wl */
 #define WL_TXFIFO_SZ_MAGIC	0xa5a5
@@ -1205,11 +1205,11 @@ typedef struct wlc_iov_trx_s {
 #define WL_PHY_PAVARS_LEN	6	/* Phy type, Band range, chain, a1, b0, b1 */
 
 typedef struct wl_po {
-	uint16 phy_type;	/* Phy type */
-	uint16 band;
-	uint16 cckpo;
+	u16 phy_type;	/* Phy type */
+	u16 band;
+	u16 cckpo;
 	uint32 ofdmpo;
-	uint16 mcspo[8];
+	u16 mcspo[8];
 } wl_po_t;
 
 /* a large TX Power as an init value to factor out of MIN() calculations,
@@ -1493,8 +1493,8 @@ struct tsinfo_arg {
 #define	WL_CNT_T_VERSION	7	/* current version of wl_cnt_t struct */
 
 typedef struct {
-	uint16 version;		/* see definition of WL_CNT_T_VERSION */
-	uint16 length;		/* length of entire structure */
+	u16 version;		/* see definition of WL_CNT_T_VERSION */
+	u16 length;		/* length of entire structure */
 
 	/* transmit stat counters */
 	uint32 txframe;		/* tx data frames */
@@ -1727,8 +1727,8 @@ typedef struct {
 #define	WL_DELTA_STATS_T_VERSION	1	/* current version of wl_delta_stats_t struct */
 
 typedef struct {
-	uint16 version;		/* see definition of WL_DELTA_STATS_T_VERSION */
-	uint16 length;		/* length of entire structure */
+	u16 version;		/* see definition of WL_DELTA_STATS_T_VERSION */
+	u16 length;		/* length of entire structure */
 
 	/* transmit stat counters */
 	uint32 txframe;		/* tx data frames */
@@ -1772,8 +1772,8 @@ typedef struct {
 } wl_traffic_stats_t;
 
 typedef struct {
-	uint16 version;		/* see definition of WL_WME_CNT_VERSION */
-	uint16 length;		/* length of entire structure */
+	u16 version;		/* see definition of WL_WME_CNT_VERSION */
+	u16 length;		/* length of entire structure */
 
 	wl_traffic_stats_t tx[AC_COUNT];	/* Packets transmitted */
 	wl_traffic_stats_t tx_failed[AC_COUNT];	/* Packets dropped or failed to transmit */
@@ -1797,8 +1797,8 @@ struct wl_msglevel2 {
 
 /* block ack related stats */
 typedef struct wlc_ba_cnt {
-	uint16 version;		/* WLC_BA_CNT_VERSION */
-	uint16 length;		/* length of entire structure */
+	u16 version;		/* WLC_BA_CNT_VERSION */
+	u16 length;		/* length of entire structure */
 
 	/* transmit stat counters */
 	uint32 txpdu;		/* pdus sent */
@@ -1858,13 +1858,13 @@ struct tslist {
 
 /* structure for addts/delts arguments */
 typedef struct tspec_arg {
-	uint16 version;		/* see definition of TSPEC_ARG_VERSION */
-	uint16 length;		/* length of entire structure */
+	u16 version;		/* see definition of TSPEC_ARG_VERSION */
+	u16 length;		/* length of entire structure */
 	uint flag;		/* bit field */
 	/* TSPEC Arguments */
 	struct tsinfo_arg tsinfo;	/* TS Info bit field */
-	uint16 nom_msdu_size;	/* (Nominal or fixed) MSDU Size (bytes) */
-	uint16 max_msdu_size;	/* Maximum MSDU Size (bytes) */
+	u16 nom_msdu_size;	/* (Nominal or fixed) MSDU Size (bytes) */
+	u16 max_msdu_size;	/* Maximum MSDU Size (bytes) */
 	uint min_srv_interval;	/* Minimum Service Interval (us) */
 	uint max_srv_interval;	/* Maximum Service Interval (us) */
 	uint inactivity_interval;	/* Inactivity Interval (us) */
@@ -1876,8 +1876,8 @@ typedef struct tspec_arg {
 	uint max_burst_size;	/* Maximum Burst Size (bytes) */
 	uint delay_bound;	/* Delay Bound (us) */
 	uint min_phy_rate;	/* Minimum PHY Rate (bps) */
-	uint16 surplus_bw;	/* Surplus Bandwidth Allowance (range 1.0 to 8.0) */
-	uint16 medium_time;	/* Medium Time (32 us/s periods) */
+	u16 surplus_bw;	/* Surplus Bandwidth Allowance (range 1.0 to 8.0) */
+	u16 medium_time;	/* Medium Time (32 us/s periods) */
 	u8 dialog_token;	/* dialog token */
 } tspec_arg_t;
 
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -33,8 +33,8 @@
 uint32 phyhal_msg_level = PHYHAL_ERROR;
 
 typedef struct _chan_info_basic {
-	uint16 chan;
-	uint16 freq;
+	u16 chan;
+	u16 freq;
 } chan_info_basic_t;
 
 static chan_info_basic_t chan_info_all[] = {
@@ -97,7 +97,7 @@ static chan_info_basic_t chan_info_all[]
 	{216, 50800}
 };
 
-uint16 ltrn_list[PHY_LTRN_LIST_LEN] = {
+u16 ltrn_list[PHY_LTRN_LIST_LEN] = {
 	0x18f9, 0x0d01, 0x00e4, 0xdef4, 0x06f1, 0x0ffc,
 	0xfa27, 0x1dff, 0x10f0, 0x0918, 0xf20a, 0xe010,
 	0x1417, 0x1104, 0xf114, 0xf2fa, 0xf7db, 0xe2fc,
@@ -207,16 +207,16 @@ void wlc_radioreg_enter(wlc_phy_t *pih)
 void wlc_radioreg_exit(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	volatile uint16 dummy;
+	volatile u16 dummy;
 
 	dummy = R_REG(pi->sh->osh, &pi->regs->phyversion);
 	pi->phy_wreg = 0;
 	wlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, 0);
 }
 
-uint16 read_radio_reg(phy_info_t *pi, uint16 addr)
+u16 read_radio_reg(phy_info_t *pi, u16 addr)
 {
-	uint16 data;
+	u16 data;
 
 	if ((addr == RADIO_IDCODE))
 		return 0xffff;
@@ -270,7 +270,7 @@ uint16 read_radio_reg(phy_info_t *pi, ui
 	return data;
 }
 
-void write_radio_reg(phy_info_t *pi, uint16 addr, uint16 val)
+void write_radio_reg(phy_info_t *pi, u16 addr, u16 val)
 {
 	osl_t *osh;
 
@@ -344,9 +344,9 @@ static uint32 read_radio_id(phy_info_t *
 	return id;
 }
 
-void and_radio_reg(phy_info_t *pi, uint16 addr, uint16 val)
+void and_radio_reg(phy_info_t *pi, u16 addr, u16 val)
 {
-	uint16 rval;
+	u16 rval;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
@@ -355,9 +355,9 @@ void and_radio_reg(phy_info_t *pi, uint1
 	write_radio_reg(pi, addr, (rval & val));
 }
 
-void or_radio_reg(phy_info_t *pi, uint16 addr, uint16 val)
+void or_radio_reg(phy_info_t *pi, u16 addr, u16 val)
 {
-	uint16 rval;
+	u16 rval;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
@@ -366,9 +366,9 @@ void or_radio_reg(phy_info_t *pi, uint16
 	write_radio_reg(pi, addr, (rval | val));
 }
 
-void xor_radio_reg(phy_info_t *pi, uint16 addr, uint16 mask)
+void xor_radio_reg(phy_info_t *pi, u16 addr, u16 mask)
 {
-	uint16 rval;
+	u16 rval;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
@@ -377,9 +377,9 @@ void xor_radio_reg(phy_info_t *pi, uint1
 	write_radio_reg(pi, addr, (rval ^ mask));
 }
 
-void mod_radio_reg(phy_info_t *pi, uint16 addr, uint16 mask, uint16 val)
+void mod_radio_reg(phy_info_t *pi, u16 addr, u16 mask, u16 val)
 {
-	uint16 rval;
+	u16 rval;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
@@ -403,7 +403,7 @@ static bool wlc_phy_war41476(phy_info_t
 }
 #endif
 
-uint16 read_phy_reg(phy_info_t *pi, uint16 addr)
+u16 read_phy_reg(phy_info_t *pi, u16 addr)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -424,7 +424,7 @@ uint16 read_phy_reg(phy_info_t *pi, uint
 	return R_REG(osh, &regs->phyregdata);
 }
 
-void write_phy_reg(phy_info_t *pi, uint16 addr, uint16 val)
+void write_phy_reg(phy_info_t *pi, u16 addr, u16 val)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -450,7 +450,7 @@ void write_phy_reg(phy_info_t *pi, uint1
 #endif
 }
 
-void and_phy_reg(phy_info_t *pi, uint16 addr, uint16 val)
+void and_phy_reg(phy_info_t *pi, u16 addr, u16 val)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -471,7 +471,7 @@ void and_phy_reg(phy_info_t *pi, uint16
 	pi->phy_wreg = 0;
 }
 
-void or_phy_reg(phy_info_t *pi, uint16 addr, uint16 val)
+void or_phy_reg(phy_info_t *pi, u16 addr, u16 val)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -492,7 +492,7 @@ void or_phy_reg(phy_info_t *pi, uint16 a
 	pi->phy_wreg = 0;
 }
 
-void mod_phy_reg(phy_info_t *pi, uint16 addr, uint16 mask, uint16 val)
+void mod_phy_reg(phy_info_t *pi, u16 addr, u16 mask, u16 val)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -815,12 +815,12 @@ void BCMATTACHFN(wlc_phy_detach) (wlc_ph
 }
 
 bool
-wlc_phy_get_phyversion(wlc_phy_t *pih, uint16 *phytype, uint16 *phyrev,
-		       uint16 *radioid, uint16 *radiover)
+wlc_phy_get_phyversion(wlc_phy_t *pih, u16 *phytype, u16 *phyrev,
+		       u16 *radioid, u16 *radiover)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	*phytype = (uint16) pi->pubpi.phy_type;
-	*phyrev = (uint16) pi->pubpi.phy_rev;
+	*phytype = (u16) pi->pubpi.phy_type;
+	*phyrev = (u16) pi->pubpi.phy_rev;
 	*radioid = pi->pubpi.radioid;
 	*radiover = pi->pubpi.radiorev;
 
@@ -1075,7 +1075,7 @@ static uint32 wlc_phy_get_radio_ver(phy_
 
 void
 wlc_phy_table_addr(phy_info_t *pi, uint tbl_id, uint tbl_offset,
-		   uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
+		   u16 tblAddr, u16 tblDataHi, u16 tblDataLo)
 {
 	write_phy_reg(pi, tblAddr, (tbl_id << 10) | tbl_offset);
 
@@ -1108,24 +1108,24 @@ void wlc_phy_table_data_write(phy_info_t
 
 	if (width == 32) {
 
-		write_phy_reg(pi, pi->tbl_data_hi, (uint16) (val >> 16));
-		write_phy_reg(pi, pi->tbl_data_lo, (uint16) val);
+		write_phy_reg(pi, pi->tbl_data_hi, (u16) (val >> 16));
+		write_phy_reg(pi, pi->tbl_data_lo, (u16) val);
 	} else {
 
-		write_phy_reg(pi, pi->tbl_data_lo, (uint16) val);
+		write_phy_reg(pi, pi->tbl_data_lo, (u16) val);
 	}
 }
 
 void
 wlc_phy_write_table(phy_info_t *pi, const phytbl_info_t *ptbl_info,
-		    uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
+		    u16 tblAddr, u16 tblDataHi, u16 tblDataLo)
 {
 	uint idx;
 	uint tbl_id = ptbl_info->tbl_id;
 	uint tbl_offset = ptbl_info->tbl_offset;
 	uint tbl_width = ptbl_info->tbl_width;
 	const u8 *ptbl_8b = (const u8 *)ptbl_info->tbl_ptr;
-	const uint16 *ptbl_16b = (const uint16 *)ptbl_info->tbl_ptr;
+	const u16 *ptbl_16b = (const u16 *)ptbl_info->tbl_ptr;
 	const uint32 *ptbl_32b = (const uint32 *)ptbl_info->tbl_ptr;
 
 	ASSERT((tbl_width == 8) || (tbl_width == 16) || (tbl_width == 32));
@@ -1147,8 +1147,8 @@ wlc_phy_write_table(phy_info_t *pi, cons
 		if (tbl_width == 32) {
 
 			write_phy_reg(pi, tblDataHi,
-				      (uint16) (ptbl_32b[idx] >> 16));
-			write_phy_reg(pi, tblDataLo, (uint16) ptbl_32b[idx]);
+				      (u16) (ptbl_32b[idx] >> 16));
+			write_phy_reg(pi, tblDataLo, (u16) ptbl_32b[idx]);
 		} else if (tbl_width == 16) {
 
 			write_phy_reg(pi, tblDataLo, ptbl_16b[idx]);
@@ -1161,14 +1161,14 @@ wlc_phy_write_table(phy_info_t *pi, cons
 
 void
 wlc_phy_read_table(phy_info_t *pi, const phytbl_info_t *ptbl_info,
-		   uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
+		   u16 tblAddr, u16 tblDataHi, u16 tblDataLo)
 {
 	uint idx;
 	uint tbl_id = ptbl_info->tbl_id;
 	uint tbl_offset = ptbl_info->tbl_offset;
 	uint tbl_width = ptbl_info->tbl_width;
 	u8 *ptbl_8b = (u8 *) (uintptr) ptbl_info->tbl_ptr;
-	uint16 *ptbl_16b = (uint16 *) (uintptr) ptbl_info->tbl_ptr;
+	u16 *ptbl_16b = (u16 *) (uintptr) ptbl_info->tbl_ptr;
 	uint32 *ptbl_32b = (uint32 *) (uintptr) ptbl_info->tbl_ptr;
 
 	ASSERT((tbl_width == 8) || (tbl_width == 16) || (tbl_width == 32));
@@ -1208,7 +1208,7 @@ wlc_phy_init_radio_regs_allbands(phy_inf
 	do {
 		if (radioregs[i].do_init) {
 			write_radio_reg(pi, radioregs[i].address,
-					(uint16) radioregs[i].init);
+					(u16) radioregs[i].init);
 		}
 
 		i++;
@@ -1219,7 +1219,7 @@ wlc_phy_init_radio_regs_allbands(phy_inf
 
 uint
 wlc_phy_init_radio_regs(phy_info_t *pi, radio_regs_t *radioregs,
-			uint16 core_offset)
+			u16 core_offset)
 {
 	uint i = 0;
 	uint count = 0;
@@ -1230,7 +1230,7 @@ wlc_phy_init_radio_regs(phy_info_t *pi,
 				write_radio_reg(pi,
 						radioregs[i].
 						address | core_offset,
-						(uint16) radioregs[i].init_a);
+						(u16) radioregs[i].init_a);
 				if (ISNPHY(pi) && (++count % 4 == 0))
 					WLC_PHY_WAR_PR51571(pi);
 			}
@@ -1239,7 +1239,7 @@ wlc_phy_init_radio_regs(phy_info_t *pi,
 				write_radio_reg(pi,
 						radioregs[i].
 						address | core_offset,
-						(uint16) radioregs[i].init_g);
+						(u16) radioregs[i].init_g);
 				if (ISNPHY(pi) && (++count % 4 == 0))
 					WLC_PHY_WAR_PR51571(pi);
 			}
@@ -1428,14 +1428,14 @@ void wlc_phy_switch_radio(wlc_phy_t *pih
 	}
 }
 
-uint16 wlc_phy_bw_state_get(wlc_phy_t *ppi)
+u16 wlc_phy_bw_state_get(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	return pi->bw;
 }
 
-void wlc_phy_bw_state_set(wlc_phy_t *ppi, uint16 bw)
+void wlc_phy_bw_state_set(wlc_phy_t *ppi, u16 bw)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
@@ -1459,7 +1459,7 @@ chanspec_t wlc_phy_chanspec_get(wlc_phy_
 void wlc_phy_chanspec_set(wlc_phy_t *ppi, chanspec_t chanspec)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
-	uint16 m_cur_channel;
+	u16 m_cur_channel;
 	chansetfn_t chanspec_set = NULL;
 
 	ASSERT(!wf_chspec_malformed(chanspec));
@@ -2090,7 +2090,7 @@ void wlc_phy_machwcap_set(wlc_phy_t *ppi
 void wlc_phy_runbist_config(wlc_phy_t *ppi, bool start_end)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
-	uint16 rxc;
+	u16 rxc;
 	rxc = 0;
 
 	if (start_end == ON) {
@@ -2169,7 +2169,7 @@ void wlc_phy_txpower_update_shm(phy_info
 		return;
 
 	if (pi->hwpwrctrl) {
-		uint16 offset;
+		u16 offset;
 
 		wlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_MAX, 63);
 		wlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_N,
@@ -2203,7 +2203,7 @@ void wlc_phy_txpower_update_shm(phy_info
 			pi->tx_power_offset[i] =
 			    (u8) ROUNDUP(pi->tx_power_offset[i], 8);
 		wlapi_bmac_write_shm(pi->sh->physhim, M_OFDM_OFFSET,
-				     (uint16) ((pi->
+				     (u16) ((pi->
 						tx_power_offset[TXP_FIRST_OFDM]
 						+ 7) >> 3));
 	}
@@ -2275,7 +2275,7 @@ static uint32 wlc_phy_txpower_est_power_
 static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t *pi)
 {
 	int16 tx0_status, tx1_status;
-	uint16 estPower1, estPower2;
+	u16 estPower1, estPower2;
 	u8 pwr0, pwr1, adj_pwr0, adj_pwr1;
 	uint32 est_pwr;
 
@@ -2444,8 +2444,8 @@ bool wlc_phy_ant_rxdiv_get(wlc_phy_t *pp
 
 		ret = FALSE;
 	} else if (ISLCNPHY(pi)) {
-		uint16 crsctrl = read_phy_reg(pi, 0x410);
-		uint16 div = crsctrl & (0x1 << 1);
+		u16 crsctrl = read_phy_reg(pi, 0x410);
+		u16 div = crsctrl & (0x1 << 1);
 		*pval = (div | ((crsctrl & (0x1 << 0)) ^ (div >> 1)));
 	}
 
@@ -2491,7 +2491,7 @@ void wlc_phy_ant_rxdiv_set(wlc_phy_t *pp
 				    ((ANT_RX_DIV_START_1 == val) ? 1 : 0) << 0);
 		} else {
 			mod_phy_reg(pi, 0x410, (0x1 << 1), 0x00 << 1);
-			mod_phy_reg(pi, 0x410, (0x1 << 0), (uint16) val << 0);
+			mod_phy_reg(pi, 0x410, (0x1 << 0), (u16) val << 0);
 		}
 	} else {
 		ASSERT(0);
@@ -2618,7 +2618,7 @@ wlc_phy_noise_sample_request(wlc_phy_t *
 			phy_iq_est_t est[PHY_CORE_MAX];
 			uint32 cmplx_pwr[PHY_CORE_MAX];
 			s8 noise_dbm_ant[PHY_CORE_MAX];
-			uint16 log_num_samps, num_samps, classif_state = 0;
+			u16 log_num_samps, num_samps, classif_state = 0;
 			u8 wait_time = 32;
 			u8 wait_crs = 0;
 			u8 i;
@@ -2700,7 +2700,7 @@ static s8 wlc_phy_noise_read_shmem(phy_i
 {
 	uint32 cmplx_pwr[PHY_CORE_MAX];
 	s8 noise_dbm_ant[PHY_CORE_MAX];
-	uint16 lo, hi;
+	u16 lo, hi;
 	uint32 cmplx_pwr_tot = 0;
 	s8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
 	u8 idx, core;
@@ -2741,15 +2741,15 @@ static s8 wlc_phy_noise_read_shmem(phy_i
 void wlc_phy_noise_sample_intr(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	uint16 jssi_aux;
+	u16 jssi_aux;
 	u8 channel = 0;
 	s8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
 
 	if (ISLCNPHY(pi)) {
 		uint32 cmplx_pwr, cmplx_pwr0, cmplx_pwr1;
-		uint16 lo, hi;
+		u16 lo, hi;
 		int32 pwr_offset_dB, gain_dB;
-		uint16 status_0, status_1;
+		u16 status_0, status_1;
 
 		jssi_aux = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);
 		channel = jssi_aux & D11_CURCHANNEL_MAX;
@@ -3330,7 +3330,7 @@ void wlc_lcnphy_epa_switch(phy_info_t *p
 	if ((CHIPID(pi->sh->chip) == BCM4313_CHIP_ID) &&
 	    (pi->sh->boardflags & BFL_FEM)) {
 		if (mode) {
-			uint16 txant = 0;
+			u16 txant = 0;
 			txant = wlapi_bmac_get_txant(pi->sh->physhim);
 			if (txant == 1) {
 				mod_phy_reg(pi, 0x44d, (0x1 << 2), (1) << 2);
--- a/drivers/staging/brcm80211/phy/wlc_phy_hal.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_hal.h
@@ -138,8 +138,8 @@ typedef struct shared_phy_params {
 	uint bustype;
 	uint buscorerev;
 	char *vars;
-	uint16 vid;
-	uint16 did;
+	u16 vid;
+	u16 did;
 	uint chip;
 	uint chiprev;
 	uint chippkg;
@@ -159,9 +159,9 @@ extern wlc_phy_t *wlc_phy_attach(shared_
 				 char *vars);
 extern void wlc_phy_detach(wlc_phy_t *ppi);
 
-extern bool wlc_phy_get_phyversion(wlc_phy_t *pih, uint16 *phytype,
-				   uint16 *phyrev, uint16 *radioid,
-				   uint16 *radiover);
+extern bool wlc_phy_get_phyversion(wlc_phy_t *pih, u16 *phytype,
+				   u16 *phyrev, u16 *radioid,
+				   u16 *radiover);
 extern bool wlc_phy_get_encore(wlc_phy_t *pih);
 extern uint32 wlc_phy_get_coreflags(wlc_phy_t *pih);
 
@@ -177,8 +177,8 @@ extern void wlc_phy_antsel_init(wlc_phy_
 extern void wlc_phy_chanspec_set(wlc_phy_t *ppi, chanspec_t chanspec);
 extern chanspec_t wlc_phy_chanspec_get(wlc_phy_t *ppi);
 extern void wlc_phy_chanspec_radio_set(wlc_phy_t *ppi, chanspec_t newch);
-extern uint16 wlc_phy_bw_state_get(wlc_phy_t *ppi);
-extern void wlc_phy_bw_state_set(wlc_phy_t *ppi, uint16 bw);
+extern u16 wlc_phy_bw_state_get(wlc_phy_t *ppi);
+extern void wlc_phy_bw_state_set(wlc_phy_t *ppi, u16 bw);
 
 extern void wlc_phy_rssi_compute(wlc_phy_t *pih, void *ctx);
 extern void wlc_phy_por_inform(wlc_phy_t *ppi);
--- a/drivers/staging/brcm80211/phy/wlc_phy_int.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_int.h
@@ -46,9 +46,9 @@ typedef struct phy_info phy_info_t;
 typedef void (*initfn_t) (phy_info_t *);
 typedef void (*chansetfn_t) (phy_info_t *, chanspec_t);
 typedef int (*longtrnfn_t) (phy_info_t *, int);
-typedef void (*txiqccgetfn_t) (phy_info_t *, uint16 *, uint16 *);
-typedef void (*txiqccsetfn_t) (phy_info_t *, uint16, uint16);
-typedef uint16(*txloccgetfn_t) (phy_info_t *);
+typedef void (*txiqccgetfn_t) (phy_info_t *, u16 *, u16 *);
+typedef void (*txiqccsetfn_t) (phy_info_t *, u16, u16);
+typedef u16(*txloccgetfn_t) (phy_info_t *);
 typedef void (*radioloftgetfn_t) (phy_info_t *, u8 *, u8 *, u8 *,
 				  u8 *);
 typedef int32(*rxsigpwrfn_t) (phy_info_t *, int32);
@@ -282,7 +282,7 @@ typedef enum {
 #endif
 
 #define PHY_LTRN_LIST_LEN	64
-extern uint16 ltrn_list[PHY_LTRN_LIST_LEN];
+extern u16 ltrn_list[PHY_LTRN_LIST_LEN];
 
 typedef struct _phy_table_info {
 	uint table;
@@ -300,111 +300,111 @@ typedef struct phytbl_info {
 
 typedef struct {
 	u8 curr_home_channel;
-	uint16 crsminpwrthld_40_stored;
-	uint16 crsminpwrthld_20L_stored;
-	uint16 crsminpwrthld_20U_stored;
-	uint16 init_gain_code_core1_stored;
-	uint16 init_gain_code_core2_stored;
-	uint16 init_gain_codeb_core1_stored;
-	uint16 init_gain_codeb_core2_stored;
-	uint16 init_gain_table_stored[4];
-
-	uint16 clip1_hi_gain_code_core1_stored;
-	uint16 clip1_hi_gain_code_core2_stored;
-	uint16 clip1_hi_gain_codeb_core1_stored;
-	uint16 clip1_hi_gain_codeb_core2_stored;
-	uint16 nb_clip_thresh_core1_stored;
-	uint16 nb_clip_thresh_core2_stored;
-	uint16 init_ofdmlna2gainchange_stored[4];
-	uint16 init_ccklna2gainchange_stored[4];
-	uint16 clip1_lo_gain_code_core1_stored;
-	uint16 clip1_lo_gain_code_core2_stored;
-	uint16 clip1_lo_gain_codeb_core1_stored;
-	uint16 clip1_lo_gain_codeb_core2_stored;
-	uint16 w1_clip_thresh_core1_stored;
-	uint16 w1_clip_thresh_core2_stored;
-	uint16 radio_2056_core1_rssi_gain_stored;
-	uint16 radio_2056_core2_rssi_gain_stored;
-	uint16 energy_drop_timeout_len_stored;
-
-	uint16 ed_crs40_assertthld0_stored;
-	uint16 ed_crs40_assertthld1_stored;
-	uint16 ed_crs40_deassertthld0_stored;
-	uint16 ed_crs40_deassertthld1_stored;
-	uint16 ed_crs20L_assertthld0_stored;
-	uint16 ed_crs20L_assertthld1_stored;
-	uint16 ed_crs20L_deassertthld0_stored;
-	uint16 ed_crs20L_deassertthld1_stored;
-	uint16 ed_crs20U_assertthld0_stored;
-	uint16 ed_crs20U_assertthld1_stored;
-	uint16 ed_crs20U_deassertthld0_stored;
-	uint16 ed_crs20U_deassertthld1_stored;
-
-	uint16 badplcp_ma;
-	uint16 badplcp_ma_previous;
-	uint16 badplcp_ma_total;
-	uint16 badplcp_ma_list[MA_WINDOW_SZ];
+	u16 crsminpwrthld_40_stored;
+	u16 crsminpwrthld_20L_stored;
+	u16 crsminpwrthld_20U_stored;
+	u16 init_gain_code_core1_stored;
+	u16 init_gain_code_core2_stored;
+	u16 init_gain_codeb_core1_stored;
+	u16 init_gain_codeb_core2_stored;
+	u16 init_gain_table_stored[4];
+
+	u16 clip1_hi_gain_code_core1_stored;
+	u16 clip1_hi_gain_code_core2_stored;
+	u16 clip1_hi_gain_codeb_core1_stored;
+	u16 clip1_hi_gain_codeb_core2_stored;
+	u16 nb_clip_thresh_core1_stored;
+	u16 nb_clip_thresh_core2_stored;
+	u16 init_ofdmlna2gainchange_stored[4];
+	u16 init_ccklna2gainchange_stored[4];
+	u16 clip1_lo_gain_code_core1_stored;
+	u16 clip1_lo_gain_code_core2_stored;
+	u16 clip1_lo_gain_codeb_core1_stored;
+	u16 clip1_lo_gain_codeb_core2_stored;
+	u16 w1_clip_thresh_core1_stored;
+	u16 w1_clip_thresh_core2_stored;
+	u16 radio_2056_core1_rssi_gain_stored;
+	u16 radio_2056_core2_rssi_gain_stored;
+	u16 energy_drop_timeout_len_stored;
+
+	u16 ed_crs40_assertthld0_stored;
+	u16 ed_crs40_assertthld1_stored;
+	u16 ed_crs40_deassertthld0_stored;
+	u16 ed_crs40_deassertthld1_stored;
+	u16 ed_crs20L_assertthld0_stored;
+	u16 ed_crs20L_assertthld1_stored;
+	u16 ed_crs20L_deassertthld0_stored;
+	u16 ed_crs20L_deassertthld1_stored;
+	u16 ed_crs20U_assertthld0_stored;
+	u16 ed_crs20U_assertthld1_stored;
+	u16 ed_crs20U_deassertthld0_stored;
+	u16 ed_crs20U_deassertthld1_stored;
+
+	u16 badplcp_ma;
+	u16 badplcp_ma_previous;
+	u16 badplcp_ma_total;
+	u16 badplcp_ma_list[MA_WINDOW_SZ];
 	int badplcp_ma_index;
 	int16 pre_badplcp_cnt;
 	int16 bphy_pre_badplcp_cnt;
 
-	uint16 init_gain_core1;
-	uint16 init_gain_core2;
-	uint16 init_gainb_core1;
-	uint16 init_gainb_core2;
-	uint16 init_gain_rfseq[4];
-
-	uint16 crsminpwr0;
-	uint16 crsminpwrl0;
-	uint16 crsminpwru0;
+	u16 init_gain_core1;
+	u16 init_gain_core2;
+	u16 init_gainb_core1;
+	u16 init_gainb_core2;
+	u16 init_gain_rfseq[4];
+
+	u16 crsminpwr0;
+	u16 crsminpwrl0;
+	u16 crsminpwru0;
 
 	int16 crsminpwr_index;
 
-	uint16 radio_2057_core1_rssi_wb1a_gc_stored;
-	uint16 radio_2057_core2_rssi_wb1a_gc_stored;
-	uint16 radio_2057_core1_rssi_wb1g_gc_stored;
-	uint16 radio_2057_core2_rssi_wb1g_gc_stored;
-	uint16 radio_2057_core1_rssi_wb2_gc_stored;
-	uint16 radio_2057_core2_rssi_wb2_gc_stored;
-	uint16 radio_2057_core1_rssi_nb_gc_stored;
-	uint16 radio_2057_core2_rssi_nb_gc_stored;
+	u16 radio_2057_core1_rssi_wb1a_gc_stored;
+	u16 radio_2057_core2_rssi_wb1a_gc_stored;
+	u16 radio_2057_core1_rssi_wb1g_gc_stored;
+	u16 radio_2057_core2_rssi_wb1g_gc_stored;
+	u16 radio_2057_core1_rssi_wb2_gc_stored;
+	u16 radio_2057_core2_rssi_wb2_gc_stored;
+	u16 radio_2057_core1_rssi_nb_gc_stored;
+	u16 radio_2057_core2_rssi_nb_gc_stored;
 
 } interference_info_t;
 
 typedef struct {
-	uint16 rc_cal_ovr;
-	uint16 phycrsth1;
-	uint16 phycrsth2;
-	uint16 init_n1p1_gain;
-	uint16 p1_p2_gain;
-	uint16 n1_n2_gain;
-	uint16 n1_p1_gain;
-	uint16 div_search_gain;
-	uint16 div_p1_p2_gain;
-	uint16 div_search_gn_change;
-	uint16 table_7_2;
-	uint16 table_7_3;
-	uint16 cckshbits_gnref;
-	uint16 clip_thresh;
-	uint16 clip2_thresh;
-	uint16 clip3_thresh;
-	uint16 clip_p2_thresh;
-	uint16 clip_pwdn_thresh;
-	uint16 clip_n1p1_thresh;
-	uint16 clip_n1_pwdn_thresh;
-	uint16 bbconfig;
-	uint16 cthr_sthr_shdin;
-	uint16 energy;
-	uint16 clip_p1_p2_thresh;
-	uint16 threshold;
-	uint16 reg15;
-	uint16 reg16;
-	uint16 reg17;
-	uint16 div_srch_idx;
-	uint16 div_srch_p1_p2;
-	uint16 div_srch_gn_back;
-	uint16 ant_dwell;
-	uint16 ant_wr_settle;
+	u16 rc_cal_ovr;
+	u16 phycrsth1;
+	u16 phycrsth2;
+	u16 init_n1p1_gain;
+	u16 p1_p2_gain;
+	u16 n1_n2_gain;
+	u16 n1_p1_gain;
+	u16 div_search_gain;
+	u16 div_p1_p2_gain;
+	u16 div_search_gn_change;
+	u16 table_7_2;
+	u16 table_7_3;
+	u16 cckshbits_gnref;
+	u16 clip_thresh;
+	u16 clip2_thresh;
+	u16 clip3_thresh;
+	u16 clip_p2_thresh;
+	u16 clip_pwdn_thresh;
+	u16 clip_n1p1_thresh;
+	u16 clip_n1_pwdn_thresh;
+	u16 bbconfig;
+	u16 cthr_sthr_shdin;
+	u16 energy;
+	u16 clip_p1_p2_thresh;
+	u16 threshold;
+	u16 reg15;
+	u16 reg16;
+	u16 reg17;
+	u16 div_srch_idx;
+	u16 div_srch_p1_p2;
+	u16 div_srch_gn_back;
+	u16 ant_dwell;
+	u16 ant_wr_settle;
 } aci_save_gphy_t;
 
 typedef struct _lo_complex_t {
@@ -423,23 +423,23 @@ typedef struct _nphy_txpwrindex {
 	s8 index;
 	s8 index_internal;
 	s8 index_internal_save;
-	uint16 AfectrlOverride;
-	uint16 AfeCtrlDacGain;
-	uint16 rad_gain;
+	u16 AfectrlOverride;
+	u16 AfeCtrlDacGain;
+	u16 rad_gain;
 	u8 bbmult;
-	uint16 iqcomp_a;
-	uint16 iqcomp_b;
-	uint16 locomp;
+	u16 iqcomp_a;
+	u16 iqcomp_b;
+	u16 locomp;
 } phy_txpwrindex_t;
 
 typedef struct {
 
-	uint16 txcal_coeffs_2G[8];
-	uint16 txcal_radio_regs_2G[8];
+	u16 txcal_coeffs_2G[8];
+	u16 txcal_radio_regs_2G[8];
 	nphy_iq_comp_t rxcal_coeffs_2G;
 
-	uint16 txcal_coeffs_5G[8];
-	uint16 txcal_radio_regs_5G[8];
+	u16 txcal_coeffs_5G[8];
+	u16 txcal_radio_regs_5G[8];
 	nphy_iq_comp_t rxcal_coeffs_5G;
 } txiqcal_cache_t;
 
@@ -473,11 +473,11 @@ typedef struct _nphy_pwrctrl {
 } phy_pwrctrl_t;
 
 typedef struct _nphy_txgains {
-	uint16 txlpf[2];
-	uint16 txgm[2];
-	uint16 pga[2];
-	uint16 pad[2];
-	uint16 ipa[2];
+	u16 txlpf[2];
+	u16 txgm[2];
+	u16 pga[2];
+	u16 pad[2];
+	u16 ipa[2];
 } nphy_txgains_t;
 
 #define PHY_NOISEVAR_BUFSIZE 10
@@ -490,37 +490,37 @@ typedef struct _nphy_noisevar_buf {
 } phy_noisevar_buf_t;
 
 typedef struct {
-	uint16 rssical_radio_regs_2G[2];
-	uint16 rssical_phyregs_2G[12];
+	u16 rssical_radio_regs_2G[2];
+	u16 rssical_phyregs_2G[12];
 
-	uint16 rssical_radio_regs_5G[2];
-	uint16 rssical_phyregs_5G[12];
+	u16 rssical_radio_regs_5G[2];
+	u16 rssical_phyregs_5G[12];
 } rssical_cache_t;
 
 typedef struct {
 
-	uint16 txiqlocal_a;
-	uint16 txiqlocal_b;
-	uint16 txiqlocal_didq;
+	u16 txiqlocal_a;
+	u16 txiqlocal_b;
+	u16 txiqlocal_didq;
 	u8 txiqlocal_ei0;
 	u8 txiqlocal_eq0;
 	u8 txiqlocal_fi0;
 	u8 txiqlocal_fq0;
 
-	uint16 txiqlocal_bestcoeffs[11];
-	uint16 txiqlocal_bestcoeffs_valid;
+	u16 txiqlocal_bestcoeffs[11];
+	u16 txiqlocal_bestcoeffs_valid;
 
 	uint32 papd_eps_tbl[PHY_PAPD_EPS_TBL_SIZE_LCNPHY];
-	uint16 analog_gain_ref;
-	uint16 lut_begin;
-	uint16 lut_end;
-	uint16 lut_step;
-	uint16 rxcompdbm;
-	uint16 papdctrl;
-	uint16 sslpnCalibClkEnCtrl;
+	u16 analog_gain_ref;
+	u16 lut_begin;
+	u16 lut_end;
+	u16 lut_step;
+	u16 rxcompdbm;
+	u16 papdctrl;
+	u16 sslpnCalibClkEnCtrl;
 
-	uint16 rxiqcal_coeff_a0;
-	uint16 rxiqcal_coeff_b0;
+	u16 rxiqcal_coeff_a0;
+	u16 rxiqcal_coeff_b0;
 } lcnphy_cal_results_t;
 
 struct shared_phy {
@@ -534,8 +534,8 @@ struct shared_phy {
 	bool up;
 	bool clk;
 	uint now;
-	uint16 vid;
-	uint16 did;
+	u16 vid;
+	u16 did;
 	uint chip;
 	uint chiprev;
 	uint chippkg;
@@ -565,7 +565,7 @@ struct phy_pub {
 	uint phy_type;
 	uint phy_rev;
 	u8 phy_corenum;
-	uint16 radioid;
+	u16 radioid;
 	u8 radiorev;
 	u8 radiover;
 
@@ -618,7 +618,7 @@ struct phy_info {
 	bool bf_preempt_4306;
 	chanspec_t radio_chanspec;
 	u8 antsel_type;
-	uint16 bw;
+	u16 bw;
 	u8 txpwr_percent;
 	bool phy_init_por;
 
@@ -663,8 +663,8 @@ struct phy_info {
 	s8 nphy_txrx_chain;
 	bool phy_5g_pwrgain;
 
-	uint16 phy_wreg;
-	uint16 phy_wreg_limit;
+	u16 phy_wreg;
+	u16 phy_wreg_limit;
 
 	s8 n_preamble_override;
 	u8 antswitch;
@@ -683,7 +683,7 @@ struct phy_info {
 	bool txpwroverride;
 	bool txpwridx_override_aphy;
 	int16 radiopwr_override;
-	uint16 hwpwr_txcur;
+	u16 hwpwr_txcur;
 	u8 saved_txpwr_idx;
 
 	bool edcrs_threshold_lock;
@@ -695,10 +695,10 @@ struct phy_info {
 	int16 cck_analog_filt_bw_override;
 	int16 ofdm_rccal_override;
 	int16 cck_rccal_override;
-	uint16 extlna_type;
+	u16 extlna_type;
 
 	uint interference_mode_crs_time;
-	uint16 crsglitch_prev;
+	u16 crsglitch_prev;
 	bool interference_mode_crs;
 
 	uint32 phy_tx_tone_freq;
@@ -719,21 +719,21 @@ struct phy_info {
 	s8 phy_tempsense_offset;
 	bool phy_txcore_heatedup;
 
-	uint16 radiopwr;
-	uint16 bb_atten;
-	uint16 txctl1;
+	u16 radiopwr;
+	u16 bb_atten;
+	u16 txctl1;
 
-	uint16 mintxbias;
-	uint16 mintxmag;
+	u16 mintxbias;
+	u16 mintxmag;
 	lo_complex_abgphy_info_t gphy_locomp_iq[STATIC_NUM_RF][STATIC_NUM_BB];
 	s8 stats_11b_txpower[STATIC_NUM_RF][STATIC_NUM_BB];
-	uint16 gain_table[TX_GAIN_TABLE_LENGTH];
+	u16 gain_table[TX_GAIN_TABLE_LENGTH];
 	bool loopback_gain;
 	int16 max_lpback_gain_hdB;
 	int16 trsw_rx_gain_hdB;
 	u8 power_vec[8];
 
-	uint16 rc_cal;
+	u16 rc_cal;
 	int nrssi_table_delta;
 	int nrssi_slope_scale;
 	int nrssi_slope_offset;
@@ -745,18 +745,18 @@ struct phy_info {
 
 	u8 a_band_high_disable;
 
-	uint16 tx_vos;
-	uint16 global_tx_bb_dc_bias_loft;
+	u16 tx_vos;
+	u16 global_tx_bb_dc_bias_loft;
 
 	int rf_max;
 	int bb_max;
 	int rf_list_size;
 	int bb_list_size;
-	uint16 *rf_attn_list;
-	uint16 *bb_attn_list;
-	uint16 padmix_mask;
-	uint16 padmix_reg;
-	uint16 *txmag_list;
+	u16 *rf_attn_list;
+	u16 *bb_attn_list;
+	u16 padmix_mask;
+	u16 padmix_reg;
+	u16 *txmag_list;
 	uint txmag_len;
 	bool txmag_enable;
 
@@ -766,7 +766,7 @@ struct phy_info {
 	s8 *h_tssi_to_dbm;
 	u8 *hwtxpwr;
 
-	uint16 freqtrack_saved_regs[2];
+	u16 freqtrack_saved_regs[2];
 	int cur_interference_mode;
 	bool hwpwrctrl_capable;
 	bool temppwrctrl_capable;
@@ -782,11 +782,11 @@ struct phy_info {
 	bool nphy_tableloaded;
 	s8 nphy_rssisel;
 	uint32 nphy_bb_mult_save;
-	uint16 nphy_txiqlocal_bestc[11];
+	u16 nphy_txiqlocal_bestc[11];
 	bool nphy_txiqlocal_coeffsvalid;
 	phy_txpwrindex_t nphy_txpwrindex[PHY_CORE_NUM_2];
 	phy_pwrctrl_t nphy_pwrctrl_info[PHY_CORE_NUM_2];
-	uint16 cck2gpo;
+	u16 cck2gpo;
 	uint32 ofdm2gpo;
 	uint32 ofdm5gpo;
 	uint32 ofdm5glpo;
@@ -807,10 +807,10 @@ struct phy_info {
 	u8 bwdup5gpo;
 	u8 bwdup5glpo;
 	u8 bwdup5ghpo;
-	uint16 mcs2gpo[8];
-	uint16 mcs5gpo[8];
-	uint16 mcs5glpo[8];
-	uint16 mcs5ghpo[8];
+	u16 mcs2gpo[8];
+	u16 mcs5gpo[8];
+	u16 mcs5glpo[8];
+	u16 mcs5ghpo[8];
 	uint32 nphy_rxcalparams;
 
 	u8 phy_spuravoid;
@@ -830,8 +830,8 @@ struct phy_info {
 
 	bool nphy_gain_boost;
 	bool nphy_elna_gain_config;
-	uint16 old_bphy_test;
-	uint16 old_bphy_testcontrol;
+	u16 old_bphy_test;
+	u16 old_bphy_testcontrol;
 
 	bool phyhang_avoid;
 
@@ -842,7 +842,7 @@ struct phy_info {
 	u8 mphase_cal_phase_id;
 	u8 mphase_txcal_cmdidx;
 	u8 mphase_txcal_numcmds;
-	uint16 mphase_txcal_bestcoeffs[11];
+	u16 mphase_txcal_bestcoeffs[11];
 	chanspec_t nphy_txiqlocal_chanspec;
 	chanspec_t nphy_iqcal_chanspec_2G;
 	chanspec_t nphy_iqcal_chanspec_5G;
@@ -859,7 +859,7 @@ struct phy_info {
 	u8 nphy_txpwr_idx[2];
 	u8 nphy_papd_cal_type;
 	uint nphy_papd_last_cal;
-	uint16 nphy_papd_tx_gain_at_last_cal[2];
+	u16 nphy_papd_tx_gain_at_last_cal[2];
 	u8 nphy_papd_cal_gain_index[2];
 	int16 nphy_papd_epsilon_offset[2];
 	bool nphy_papd_recal_enable;
@@ -869,64 +869,64 @@ struct phy_info {
 	bool ipa2g_on;
 	bool ipa5g_on;
 
-	uint16 classifier_state;
-	uint16 clip_state[2];
+	u16 classifier_state;
+	u16 clip_state[2];
 	uint nphy_deaf_count;
 	u8 rxiq_samps;
 	u8 rxiq_antsel;
 
-	uint16 rfctrlIntc1_save;
-	uint16 rfctrlIntc2_save;
+	u16 rfctrlIntc1_save;
+	u16 rfctrlIntc2_save;
 	bool first_cal_after_assoc;
-	uint16 tx_rx_cal_radio_saveregs[22];
-	uint16 tx_rx_cal_phy_saveregs[15];
+	u16 tx_rx_cal_radio_saveregs[22];
+	u16 tx_rx_cal_phy_saveregs[15];
 
 	u8 nphy_cal_orig_pwr_idx[2];
 	u8 nphy_txcal_pwr_idx[2];
 	u8 nphy_rxcal_pwr_idx[2];
-	uint16 nphy_cal_orig_tx_gain[2];
+	u16 nphy_cal_orig_tx_gain[2];
 	nphy_txgains_t nphy_cal_target_gain;
-	uint16 nphy_txcal_bbmult;
-	uint16 nphy_gmval;
+	u16 nphy_txcal_bbmult;
+	u16 nphy_gmval;
 
-	uint16 nphy_saved_bbconf;
+	u16 nphy_saved_bbconf;
 
 	bool nphy_gband_spurwar_en;
 	bool nphy_gband_spurwar2_en;
 	bool nphy_aband_spurwar_en;
-	uint16 nphy_rccal_value;
-	uint16 nphy_crsminpwr[3];
+	u16 nphy_rccal_value;
+	u16 nphy_crsminpwr[3];
 	phy_noisevar_buf_t nphy_saved_noisevars;
 	bool nphy_anarxlpf_adjusted;
 	bool nphy_crsminpwr_adjusted;
 	bool nphy_noisevars_adjusted;
 
 	bool nphy_rxcal_active;
-	uint16 radar_percal_mask;
+	u16 radar_percal_mask;
 	bool dfs_lp_buffer_nphy;
 
-	uint16 nphy_fineclockgatecontrol;
+	u16 nphy_fineclockgatecontrol;
 
 	s8 rx2tx_biasentry;
 
-	uint16 crsminpwr0;
-	uint16 crsminpwrl0;
-	uint16 crsminpwru0;
+	u16 crsminpwr0;
+	u16 crsminpwrl0;
+	u16 crsminpwru0;
 	int16 noise_crsminpwr_index;
-	uint16 init_gain_core1;
-	uint16 init_gain_core2;
-	uint16 init_gainb_core1;
-	uint16 init_gainb_core2;
+	u16 init_gain_core1;
+	u16 init_gain_core2;
+	u16 init_gainb_core1;
+	u16 init_gainb_core2;
 	u8 aci_noise_curr_channel;
-	uint16 init_gain_rfseq[4];
+	u16 init_gain_rfseq[4];
 
 	bool radio_is_on;
 
 	bool nphy_sample_play_lpf_bw_ctl_ovr;
 
-	uint16 tbl_data_hi;
-	uint16 tbl_data_lo;
-	uint16 tbl_addr;
+	u16 tbl_data_hi;
+	u16 tbl_data_lo;
+	u16 tbl_addr;
 
 	uint tbl_save_id;
 	uint tbl_save_offset;
@@ -947,7 +947,7 @@ typedef struct _cint32 {
 } cint32;
 
 typedef struct radio_regs {
-	uint16 address;
+	u16 address;
 	uint32 init_a;
 	uint32 init_g;
 	u8 do_init_a;
@@ -955,13 +955,13 @@ typedef struct radio_regs {
 } radio_regs_t;
 
 typedef struct radio_20xx_regs {
-	uint16 address;
+	u16 address;
 	u8 init;
 	u8 do_init;
 } radio_20xx_regs_t;
 
 typedef struct lcnphy_radio_regs {
-	uint16 address;
+	u16 address;
 	u8 init_a;
 	u8 init_g;
 	u8 do_init_a;
@@ -989,20 +989,20 @@ extern int phy_getintvar(phy_info_t *pi,
 #define PHY_GETVAR(pi, name)	phy_getvar(pi, name)
 #define PHY_GETINTVAR(pi, name)	phy_getintvar(pi, name)
 
-extern uint16 read_phy_reg(phy_info_t *pi, uint16 addr);
-extern void write_phy_reg(phy_info_t *pi, uint16 addr, uint16 val);
-extern void and_phy_reg(phy_info_t *pi, uint16 addr, uint16 val);
-extern void or_phy_reg(phy_info_t *pi, uint16 addr, uint16 val);
-extern void mod_phy_reg(phy_info_t *pi, uint16 addr, uint16 mask, uint16 val);
-
-extern uint16 read_radio_reg(phy_info_t *pi, uint16 addr);
-extern void or_radio_reg(phy_info_t *pi, uint16 addr, uint16 val);
-extern void and_radio_reg(phy_info_t *pi, uint16 addr, uint16 val);
-extern void mod_radio_reg(phy_info_t *pi, uint16 addr, uint16 mask,
-			  uint16 val);
-extern void xor_radio_reg(phy_info_t *pi, uint16 addr, uint16 mask);
+extern u16 read_phy_reg(phy_info_t *pi, u16 addr);
+extern void write_phy_reg(phy_info_t *pi, u16 addr, u16 val);
+extern void and_phy_reg(phy_info_t *pi, u16 addr, u16 val);
+extern void or_phy_reg(phy_info_t *pi, u16 addr, u16 val);
+extern void mod_phy_reg(phy_info_t *pi, u16 addr, u16 mask, u16 val);
+
+extern u16 read_radio_reg(phy_info_t *pi, u16 addr);
+extern void or_radio_reg(phy_info_t *pi, u16 addr, u16 val);
+extern void and_radio_reg(phy_info_t *pi, u16 addr, u16 val);
+extern void mod_radio_reg(phy_info_t *pi, u16 addr, u16 mask,
+			  u16 val);
+extern void xor_radio_reg(phy_info_t *pi, u16 addr, u16 mask);
 
-extern void write_radio_reg(phy_info_t *pi, uint16 addr, uint16 val);
+extern void write_radio_reg(phy_info_t *pi, u16 addr, u16 val);
 
 extern void wlc_phyreg_enter(wlc_phy_t *pih);
 extern void wlc_phyreg_exit(wlc_phy_t *pih);
@@ -1010,14 +1010,14 @@ extern void wlc_radioreg_enter(wlc_phy_t
 extern void wlc_radioreg_exit(wlc_phy_t *pih);
 
 extern void wlc_phy_read_table(phy_info_t *pi, const phytbl_info_t *ptbl_info,
-			       uint16 tblAddr, uint16 tblDataHi,
-			       uint16 tblDatalo);
+			       u16 tblAddr, u16 tblDataHi,
+			       u16 tblDatalo);
 extern void wlc_phy_write_table(phy_info_t *pi,
-				const phytbl_info_t *ptbl_info, uint16 tblAddr,
-				uint16 tblDataHi, uint16 tblDatalo);
+				const phytbl_info_t *ptbl_info, u16 tblAddr,
+				u16 tblDataHi, u16 tblDatalo);
 extern void wlc_phy_table_addr(phy_info_t *pi, uint tbl_id, uint tbl_offset,
-			       uint16 tblAddr, uint16 tblDataHi,
-			       uint16 tblDataLo);
+			       u16 tblAddr, u16 tblDataHi,
+			       u16 tblDataLo);
 extern void wlc_phy_table_data_write(phy_info_t *pi, uint width, uint32 val);
 
 extern void write_phy_channel_reg(phy_info_t *pi, uint val);
@@ -1031,7 +1031,7 @@ extern void wlc_phy_compute_dB(uint32 *c
 extern uint wlc_phy_init_radio_regs_allbands(phy_info_t *pi,
 					     radio_20xx_regs_t *radioregs);
 extern uint wlc_phy_init_radio_regs(phy_info_t *pi, radio_regs_t *radioregs,
-				    uint16 core_offset);
+				    u16 core_offset);
 
 extern void wlc_phy_txpower_ipa_upd(phy_info_t *pi);
 
@@ -1061,7 +1061,7 @@ extern int wlc_phy_channel2freq(uint cha
 extern int wlc_phy_chanspec_freq2bandrange_lpssn(uint);
 extern int wlc_phy_chanspec_bandrange_get(phy_info_t *, chanspec_t);
 
-extern void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t *pi, uint16 mode);
+extern void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t *pi, u16 mode);
 extern s8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t *pi);
 
 extern void wlc_phy_txpower_recalc_target_nphy(phy_info_t *pi);
@@ -1072,7 +1072,7 @@ extern void wlc_lcnphy_set_tx_pwr_by_ind
 extern void wlc_lcnphy_tx_pu(phy_info_t *pi, bool bEnable);
 extern void wlc_lcnphy_stop_tx_tone(phy_info_t *pi);
 extern void wlc_lcnphy_start_tx_tone(phy_info_t *pi, int32 f_kHz,
-				     uint16 max_val, bool iqcalmode);
+				     u16 max_val, bool iqcalmode);
 
 extern void wlc_phy_txpower_sromlimit_get_nphy(phy_info_t *pi, uint chan,
 					       u8 *max_pwr, u8 rate_id);
@@ -1084,7 +1084,7 @@ extern void wlc_phy_mcs_to_ofdm_powers_n
 					    u8 rate_ofdm_end,
 					    u8 rate_mcs_start);
 
-extern uint16 wlc_lcnphy_tempsense(phy_info_t *pi, bool mode);
+extern u16 wlc_lcnphy_tempsense(phy_info_t *pi, bool mode);
 extern int16 wlc_lcnphy_tempsense_new(phy_info_t *pi, bool mode);
 extern s8 wlc_lcnphy_tempsense_degree(phy_info_t *pi, bool mode);
 extern s8 wlc_lcnphy_vbatsense(phy_info_t *pi, bool mode);
@@ -1111,10 +1111,10 @@ extern uint32 wlc_phy_qdiv_roundup(uint3
 
 extern void wlc_lcnphy_write_table(phy_info_t *pi, const phytbl_info_t *pti);
 extern void wlc_lcnphy_read_table(phy_info_t *pi, phytbl_info_t *pti);
-extern void wlc_lcnphy_set_tx_iqcc(phy_info_t *pi, uint16 a, uint16 b);
-extern void wlc_lcnphy_set_tx_locc(phy_info_t *pi, uint16 didq);
-extern void wlc_lcnphy_get_tx_iqcc(phy_info_t *pi, uint16 *a, uint16 *b);
-extern uint16 wlc_lcnphy_get_tx_locc(phy_info_t *pi);
+extern void wlc_lcnphy_set_tx_iqcc(phy_info_t *pi, u16 a, u16 b);
+extern void wlc_lcnphy_set_tx_locc(phy_info_t *pi, u16 didq);
+extern void wlc_lcnphy_get_tx_iqcc(phy_info_t *pi, u16 *a, u16 *b);
+extern u16 wlc_lcnphy_get_tx_locc(phy_info_t *pi);
 extern void wlc_lcnphy_get_radio_loft(phy_info_t *pi, u8 *ei0,
 				      u8 *eq0, u8 *fi0, u8 *fq0);
 extern void wlc_lcnphy_calib_modes(phy_info_t *pi, uint mode);
@@ -1173,10 +1173,10 @@ extern void wlc_phy_stf_chain_upd_nphy(p
 extern void wlc_phy_force_rfseq_nphy(phy_info_t *pi, u8 cmd);
 extern int16 wlc_phy_tempsense_nphy(phy_info_t *pi);
 
-extern uint16 wlc_phy_classifier_nphy(phy_info_t *pi, uint16 mask, uint16 val);
+extern u16 wlc_phy_classifier_nphy(phy_info_t *pi, u16 mask, u16 val);
 
 extern void wlc_phy_rx_iq_est_nphy(phy_info_t *pi, phy_iq_est_t *est,
-				   uint16 num_samps, u8 wait_time,
+				   u16 num_samps, u8 wait_time,
 				   u8 wait_for_crs);
 
 extern void wlc_phy_rx_iq_coeffs_nphy(phy_info_t *pi, u8 write,
@@ -1190,7 +1190,7 @@ extern void wlc_phy_txpwrctrl_enable_nph
 extern void wlc_phy_txpwr_fixpower_nphy(phy_info_t *pi);
 extern void wlc_phy_txpwr_apply_nphy(phy_info_t *pi);
 extern void wlc_phy_txpwr_papd_cal_nphy(phy_info_t *pi);
-extern uint16 wlc_phy_txpwr_idx_get_nphy(phy_info_t *pi);
+extern u16 wlc_phy_txpwr_idx_get_nphy(phy_info_t *pi);
 
 extern nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t *pi);
 extern int wlc_phy_cal_txiqlo_nphy(phy_info_t *pi, nphy_txgains_t target_gain,
@@ -1206,7 +1206,7 @@ extern void wlc_phy_rssi_cal_nphy(phy_in
 extern int wlc_phy_aci_scan_nphy(phy_info_t *pi);
 extern void wlc_phy_cal_txgainctrl_nphy(phy_info_t *pi, int32 dBm_targetpower,
 					bool debug);
-extern int wlc_phy_tx_tone_nphy(phy_info_t *pi, uint32 f_kHz, uint16 max_val,
+extern int wlc_phy_tx_tone_nphy(phy_info_t *pi, uint32 f_kHz, u16 max_val,
 				u8 mode, u8, bool);
 extern void wlc_phy_stopplayback_nphy(phy_info_t *pi);
 extern void wlc_phy_est_tonepwr_nphy(phy_info_t *pi, int32 *qdBm_pwrbuf,
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -143,10 +143,10 @@
 	wlapi_bmac_read_shm((pi)->sh->physhim, M_UCODE_MACSTAT + OFFSETOF(macstat_t, txallfrm))
 
 typedef struct {
-	uint16 gm_gain;
-	uint16 pga_gain;
-	uint16 pad_gain;
-	uint16 dac_gain;
+	u16 gm_gain;
+	u16 pga_gain;
+	u16 pad_gain;
+	u16 dac_gain;
 } lcnphy_txgains_t;
 
 typedef enum {
@@ -175,8 +175,8 @@ typedef struct {
 } lcnphy_spb_tone_t;
 
 typedef struct {
-	uint16 re;
-	uint16 im;
+	u16 re;
+	u16 im;
 } lcnphy_unsign16_struct;
 
 typedef struct {
@@ -186,8 +186,8 @@ typedef struct {
 } lcnphy_iq_est_t;
 
 typedef struct {
-	uint16 ptcentreTs20;
-	uint16 ptcentreFactor;
+	u16 ptcentreTs20;
+	u16 ptcentreFactor;
 } lcnphy_sfo_cfg_t;
 
 typedef enum {
@@ -195,7 +195,7 @@ typedef enum {
 	LCNPHY_PAPD_CAL_OFDM
 } lcnphy_papd_cal_type_t;
 
-typedef uint16 iqcal_gain_params_lcnphy[9];
+typedef u16 iqcal_gain_params_lcnphy[9];
 
 static const iqcal_gain_params_lcnphy tbl_iqcal_gainparams_lcnphy_2G[] = {
 	{0, 0, 0, 0, 0, 0, 0, 0, 0},
@@ -205,7 +205,7 @@ static const iqcal_gain_params_lcnphy *t
 	tbl_iqcal_gainparams_lcnphy_2G,
 };
 
-static const uint16 iqcal_gainparams_numgains_lcnphy[1] = {
+static const u16 iqcal_gainparams_numgains_lcnphy[1] = {
 	sizeof(tbl_iqcal_gainparams_lcnphy_2G) /
 	    sizeof(*tbl_iqcal_gainparams_lcnphy_2G),
 };
@@ -228,7 +228,7 @@ static const lcnphy_sfo_cfg_t lcnphy_sfo
 };
 
 static const
-uint16 lcnphy_iqcal_loft_gainladder[] = {
+u16 lcnphy_iqcal_loft_gainladder[] = {
 	((2 << 8) | 0),
 	((3 << 8) | 0),
 	((4 << 8) | 0),
@@ -252,7 +252,7 @@ uint16 lcnphy_iqcal_loft_gainladder[] =
 };
 
 static const
-uint16 lcnphy_iqcal_ir_gainladder[] = {
+u16 lcnphy_iqcal_ir_gainladder[] = {
 	((1 << 8) | 0),
 	((2 << 8) | 0),
 	((4 << 8) | 0),
@@ -312,7 +312,7 @@ lcnphy_spb_tone_t lcnphy_spb_tone_3750[]
 };
 
 static const
-uint16 iqlo_loopback_rf_regs[20] = {
+u16 iqlo_loopback_rf_regs[20] = {
 	RADIO_2064_REG036,
 	RADIO_2064_REG11A,
 	RADIO_2064_REG03A,
@@ -336,7 +336,7 @@ uint16 iqlo_loopback_rf_regs[20] = {
 };
 
 static const
-uint16 tempsense_phy_regs[14] = {
+u16 tempsense_phy_regs[14] = {
 	0x503,
 	0x4a4,
 	0x4d0,
@@ -354,7 +354,7 @@ uint16 tempsense_phy_regs[14] = {
 };
 
 static const
-uint16 rxiq_cal_rf_reg[11] = {
+u16 rxiq_cal_rf_reg[11] = {
 	RADIO_2064_REG098,
 	RADIO_2064_REG116,
 	RADIO_2064_REG12C,
@@ -892,7 +892,7 @@ lcnphy_radio_regs_t lcnphy_radio_regs_20
 #define LCNPHY_NUM_DIG_FILT_COEFFS 16
 #define LCNPHY_NUM_TX_DIG_FILTERS_CCK 13
 
-uint16
+u16
     LCNPHY_txdigfiltcoeffs_cck[LCNPHY_NUM_TX_DIG_FILTERS_CCK]
     [LCNPHY_NUM_DIG_FILT_COEFFS + 1] = {
 	{0, 1, 415, 1874, 64, 128, 64, 792, 1656, 64, 128, 64, 778, 1582, 64,
@@ -924,7 +924,7 @@ uint16
 };
 
 #define LCNPHY_NUM_TX_DIG_FILTERS_OFDM 3
-uint16
+u16
     LCNPHY_txdigfiltcoeffs_ofdm[LCNPHY_NUM_TX_DIG_FILTERS_OFDM]
     [LCNPHY_NUM_DIG_FILT_COEFFS + 1] = {
 	{0, 0, 0xa2, 0x0, 0x100, 0x100, 0x0, 0x0, 0x0, 0x100, 0x0, 0x0,
@@ -938,12 +938,12 @@ uint16
 #define wlc_lcnphy_set_start_tx_pwr_idx(pi, idx) \
 	mod_phy_reg(pi, 0x4a4, \
 		(0x1ff << 0), \
-		(uint16)(idx) << 0)
+		(u16)(idx) << 0)
 
 #define wlc_lcnphy_set_tx_pwr_npt(pi, npt) \
 	mod_phy_reg(pi, 0x4a5, \
 		(0x7 << 8), \
-		(uint16)(npt) << 8)
+		(u16)(npt) << 8)
 
 #define wlc_lcnphy_get_tx_pwr_ctrl(pi) \
 	(read_phy_reg((pi), 0x4a4) & \
@@ -967,7 +967,7 @@ uint16
 #define wlc_lcnphy_set_target_tx_pwr(pi, target) \
 	mod_phy_reg(pi, 0x4a7, \
 		(0xff << 0), \
-		(uint16)(target) << 0)
+		(u16)(target) << 0)
 
 #define wlc_radio_2064_rcal_done(pi) (0 != (read_radio_reg(pi, RADIO_2064_REG05C) & 0x20))
 #define tempsense_done(pi) (0x8000 == (read_phy_reg(pi, 0x476) & 0x8000))
@@ -979,12 +979,12 @@ uint16
 static uint32 wlc_lcnphy_qdiv_roundup(uint32 divident, uint32 divisor,
 				      u8 precision);
 static void wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t *pi,
-						   uint16 ext_lna, uint16 trsw,
-						   uint16 biq2, uint16 biq1,
-						   uint16 tia, uint16 lna2,
-						   uint16 lna1);
+						   u16 ext_lna, u16 trsw,
+						   u16 biq2, u16 biq1,
+						   u16 tia, u16 lna2,
+						   u16 lna1);
 static void wlc_lcnphy_clear_tx_power_offsets(phy_info_t *pi);
-static void wlc_lcnphy_set_pa_gain(phy_info_t *pi, uint16 gain);
+static void wlc_lcnphy_set_pa_gain(phy_info_t *pi, u16 gain);
 static void wlc_lcnphy_set_trsw_override(phy_info_t *pi, bool tx, bool rx);
 static void wlc_lcnphy_set_bbmult(phy_info_t *pi, u8 m0);
 static u8 wlc_lcnphy_get_bbmult(phy_info_t *pi);
@@ -994,10 +994,10 @@ static void wlc_lcnphy_toggle_afe_pwdn(p
 static void wlc_lcnphy_rx_gain_override_enable(phy_info_t *pi, bool enable);
 static void wlc_lcnphy_set_tx_gain(phy_info_t *pi,
 				   lcnphy_txgains_t *target_gains);
-static bool wlc_lcnphy_rx_iq_est(phy_info_t *pi, uint16 num_samps,
+static bool wlc_lcnphy_rx_iq_est(phy_info_t *pi, u16 num_samps,
 				 u8 wait_time, lcnphy_iq_est_t *iq_est);
-static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t *pi, uint16 num_samps);
-static uint16 wlc_lcnphy_get_pa_gain(phy_info_t *pi);
+static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t *pi, u16 num_samps);
+static u16 wlc_lcnphy_get_pa_gain(phy_info_t *pi);
 static void wlc_lcnphy_afe_clk_init(phy_info_t *pi, u8 mode);
 extern void wlc_lcnphy_tx_pwr_ctrl_init(wlc_phy_t *ppi);
 extern void wlc_lcnphy_pktengtx(wlc_phy_t *ppi, wl_pkteng_t *pkteng,
@@ -1010,12 +1010,12 @@ static void wlc_lcnphy_load_tx_gain_tabl
 					  const lcnphy_tx_gain_tbl_entry *g);
 
 static void wlc_lcnphy_samp_cap(phy_info_t *pi, int clip_detect_algo,
-				uint16 thresh, int16 *ptr, int mode);
+				u16 thresh, int16 *ptr, int mode);
 static int wlc_lcnphy_calc_floor(int16 coeff, int type);
 static void wlc_lcnphy_tx_iqlo_loopback(phy_info_t *pi,
-					uint16 *values_to_save);
+					u16 *values_to_save);
 static void wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t *pi,
-						uint16 *values_to_save);
+						u16 *values_to_save);
 static void wlc_lcnphy_set_cc(phy_info_t *pi, int cal_type, int16 coeff_x,
 			      int16 coeff_y);
 static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t *pi, int cal_type);
@@ -1035,7 +1035,7 @@ static void wlc_lcnphy_rcal(phy_info_t *
 static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t *pi, bool enable);
 static int wlc_lcnphy_load_tx_iir_filter(phy_info_t *pi, bool is_ofdm,
 					 int16 filt_type);
-static void wlc_lcnphy_set_rx_iq_comp(phy_info_t *pi, uint16 a, uint16 b);
+static void wlc_lcnphy_set_rx_iq_comp(phy_info_t *pi, u16 a, u16 b);
 
 void wlc_lcnphy_write_table(phy_info_t *pi, const phytbl_info_t *pti)
 {
@@ -1140,7 +1140,7 @@ s8 wlc_lcnphy_get_current_tx_pwr_idx(phy
 	return index;
 }
 
-static uint32 wlc_lcnphy_measure_digital_power(phy_info_t *pi, uint16 nsamples)
+static uint32 wlc_lcnphy_measure_digital_power(phy_info_t *pi, u16 nsamples)
 {
 	lcnphy_iq_est_t iq_est = { 0, 0, 0 };
 
@@ -1151,7 +1151,7 @@ static uint32 wlc_lcnphy_measure_digital
 
 void wlc_lcnphy_crsuprs(phy_info_t *pi, int channel)
 {
-	uint16 afectrlovr, afectrlovrval;
+	u16 afectrlovr, afectrlovrval;
 	afectrlovr = read_phy_reg(pi, 0x43b);
 	afectrlovrval = read_phy_reg(pi, 0x43c);
 	if (channel != 0) {
@@ -1182,7 +1182,7 @@ void wlc_lcnphy_crsuprs(phy_info_t *pi,
 
 static void wlc_lcnphy_toggle_afe_pwdn(phy_info_t *pi)
 {
-	uint16 save_AfeCtrlOvrVal, save_AfeCtrlOvr;
+	u16 save_AfeCtrlOvrVal, save_AfeCtrlOvr;
 
 	save_AfeCtrlOvrVal = read_phy_reg(pi, 0x43c);
 	save_AfeCtrlOvr = read_phy_reg(pi, 0x43b);
@@ -1253,9 +1253,9 @@ void wlc_phy_chanspec_set_lcnphy(phy_inf
 
 }
 
-static void wlc_lcnphy_set_dac_gain(phy_info_t *pi, uint16 dac_gain)
+static void wlc_lcnphy_set_dac_gain(phy_info_t *pi, u16 dac_gain)
 {
-	uint16 dac_ctrl;
+	u16 dac_ctrl;
 
 	dac_ctrl = (read_phy_reg(pi, 0x439) >> 0);
 	dac_ctrl = dac_ctrl & 0xc7f;
@@ -1266,7 +1266,7 @@ static void wlc_lcnphy_set_dac_gain(phy_
 
 static void wlc_lcnphy_set_tx_gain_override(phy_info_t *pi, bool bEnable)
 {
-	uint16 bit = bEnable ? 1 : 0;
+	u16 bit = bEnable ? 1 : 0;
 
 	mod_phy_reg(pi, 0x4b0, (0x1 << 7), bit << 7);
 
@@ -1275,9 +1275,9 @@ static void wlc_lcnphy_set_tx_gain_overr
 	mod_phy_reg(pi, 0x43b, (0x1 << 6), bit << 6);
 }
 
-static uint16 wlc_lcnphy_get_pa_gain(phy_info_t *pi)
+static u16 wlc_lcnphy_get_pa_gain(phy_info_t *pi)
 {
-	uint16 pa_gain;
+	u16 pa_gain;
 
 	pa_gain = (read_phy_reg(pi, 0x4fb) &
 		   LCNPHY_txgainctrlovrval1_pagain_ovr_val1_MASK) >>
@@ -1289,7 +1289,7 @@ static uint16 wlc_lcnphy_get_pa_gain(phy
 static void
 wlc_lcnphy_set_tx_gain(phy_info_t *pi, lcnphy_txgains_t *target_gains)
 {
-	uint16 pa_gain = wlc_lcnphy_get_pa_gain(pi);
+	u16 pa_gain = wlc_lcnphy_get_pa_gain(pi);
 
 	mod_phy_reg(pi, 0x4b5,
 		    (0xffff << 0),
@@ -1314,7 +1314,7 @@ wlc_lcnphy_set_tx_gain(phy_info_t *pi, l
 
 static void wlc_lcnphy_set_bbmult(phy_info_t *pi, u8 m0)
 {
-	uint16 m0m1 = (uint16) m0 << 8;
+	u16 m0m1 = (u16) m0 << 8;
 	phytbl_info_t tab;
 
 	tab.tbl_ptr = &m0m1;
@@ -1393,9 +1393,9 @@ static void wlc_lcnphy_set_tssi_mux(phy_
 	}
 }
 
-static uint16 wlc_lcnphy_rfseq_tbl_adc_pwrup(phy_info_t *pi)
+static u16 wlc_lcnphy_rfseq_tbl_adc_pwrup(phy_info_t *pi)
 {
-	uint16 N1, N2, N3, N4, N5, N6, N;
+	u16 N1, N2, N3, N4, N5, N6, N;
 	N1 = ((read_phy_reg(pi, 0x4a5) & (0xff << 0))
 	      >> 0);
 	N2 = 1 << ((read_phy_reg(pi, 0x4a5) & (0x7 << 12))
@@ -1416,7 +1416,7 @@ static uint16 wlc_lcnphy_rfseq_tbl_adc_p
 
 static void wlc_lcnphy_pwrctrl_rssiparams(phy_info_t *pi)
 {
-	uint16 auxpga_vmid, auxpga_vmid_temp, auxpga_gain_temp;
+	u16 auxpga_vmid, auxpga_vmid_temp, auxpga_gain_temp;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	auxpga_vmid =
@@ -1574,7 +1574,7 @@ static void wlc_lcnphy_tssi_setup(phy_in
 
 void wlc_lcnphy_tx_pwr_update_npt(phy_info_t *pi)
 {
-	uint16 tx_cnt, tx_total, npt;
+	u16 tx_cnt, tx_total, npt;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	tx_total = wlc_lcnphy_total_tx_frames(pi);
@@ -1648,7 +1648,7 @@ static void wlc_lcnphy_set_tx_pwr_soft_c
 	uint32 cck_offset[4] = { 22, 22, 22, 22 };
 	uint32 ofdm_offset, reg_offset_cck;
 	int i;
-	uint16 index2;
+	u16 index2;
 	phytbl_info_t tab;
 
 	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi))
@@ -1689,7 +1689,7 @@ static void wlc_lcnphy_set_tx_pwr_soft_c
 
 	mod_phy_reg(pi, 0x4a9, (0x1 << 15), (1) << 15);
 
-	index2 = (uint16) (index * 2);
+	index2 = (u16) (index * 2);
 	mod_phy_reg(pi, 0x4a9, (0x1ff << 0), (index2) << 0);
 
 	mod_phy_reg(pi, 0x6a3, (0x1 << 4), (0) << 4);
@@ -1701,7 +1701,7 @@ static s8 wlc_lcnphy_tempcompensated_txp
 	s8 index, delta_brd, delta_temp, new_index, tempcorrx;
 	int16 manp, meas_temp, temp_diff;
 	bool neg = 0;
-	uint16 temp;
+	u16 temp;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi))
@@ -1715,7 +1715,7 @@ static s8 wlc_lcnphy_tempcompensated_txp
 	if (pi_lcn->lcnphy_tempsense_slope == 0) {
 		return index;
 	}
-	temp = (uint16) wlc_lcnphy_tempsense(pi, 0);
+	temp = (u16) wlc_lcnphy_tempsense(pi, 0);
 	meas_temp = LCNPHY_TEMPSENSE(temp);
 
 	if (pi->tx_power_min != 0) {
@@ -1761,10 +1761,10 @@ static s8 wlc_lcnphy_tempcompensated_txp
 	return new_index;
 }
 
-static uint16 wlc_lcnphy_set_tx_pwr_ctrl_mode(phy_info_t *pi, uint16 mode)
+static u16 wlc_lcnphy_set_tx_pwr_ctrl_mode(phy_info_t *pi, u16 mode)
 {
 
-	uint16 current_mode = mode;
+	u16 current_mode = mode;
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi) &&
 	    mode == LCNPHY_TX_PWR_CTRL_HW)
 		current_mode = LCNPHY_TX_PWR_CTRL_TEMPBASED;
@@ -1774,9 +1774,9 @@ static uint16 wlc_lcnphy_set_tx_pwr_ctrl
 	return current_mode;
 }
 
-void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t *pi, uint16 mode)
+void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t *pi, u16 mode)
 {
-	uint16 old_mode = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	u16 old_mode = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	s8 index;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -1852,40 +1852,40 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t *pi,
 {
 
 	lcnphy_txgains_t cal_gains, temp_gains;
-	uint16 hash;
+	u16 hash;
 	u8 band_idx;
 	int j;
-	uint16 ncorr_override[5];
-	uint16 syst_coeffs[] = { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	u16 ncorr_override[5];
+	u16 syst_coeffs[] = { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 		0x0000, 0x0000, 0x0000, 0x0000, 0x0000
 	};
 
-	uint16 commands_fullcal[] = {
+	u16 commands_fullcal[] = {
 		0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234 };
 
-	uint16 commands_recal[] = {
+	u16 commands_recal[] = {
 		0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234 };
 
-	uint16 command_nums_fullcal[] = {
+	u16 command_nums_fullcal[] = {
 		0x7a97, 0x7a97, 0x7a97, 0x7a87, 0x7a87, 0x7b97 };
 
-	uint16 command_nums_recal[] = {
+	u16 command_nums_recal[] = {
 		0x7a97, 0x7a97, 0x7a97, 0x7a87, 0x7a87, 0x7b97 };
-	uint16 *command_nums = command_nums_fullcal;
+	u16 *command_nums = command_nums_fullcal;
 
-	uint16 *start_coeffs = NULL, *cal_cmds = NULL, cal_type, diq_start;
-	uint16 tx_pwr_ctrl_old, save_txpwrctrlrfctrl2;
-	uint16 save_sslpnCalibClkEnCtrl, save_sslpnRxFeClkEnCtrl;
+	u16 *start_coeffs = NULL, *cal_cmds = NULL, cal_type, diq_start;
+	u16 tx_pwr_ctrl_old, save_txpwrctrlrfctrl2;
+	u16 save_sslpnCalibClkEnCtrl, save_sslpnRxFeClkEnCtrl;
 	bool tx_gain_override_old;
 	lcnphy_txgains_t old_gains;
 	uint i, n_cal_cmds = 0, n_cal_start = 0;
-	uint16 *values_to_save;
+	u16 *values_to_save;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 
-	values_to_save = MALLOC(pi->sh->osh, sizeof(uint16) * 20);
+	values_to_save = MALLOC(pi->sh->osh, sizeof(u16) * 20);
 	if (NULL == values_to_save) {
 		return;
 	}
@@ -1997,9 +1997,9 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t *pi,
 	write_phy_reg(pi, 0x6da, 0xffff);
 
 	for (i = n_cal_start; i < n_cal_cmds; i++) {
-		uint16 zero_diq = 0;
-		uint16 best_coeffs[11];
-		uint16 command_num;
+		u16 zero_diq = 0;
+		u16 best_coeffs[11];
+		u16 command_num;
 
 		cal_type = (cal_cmds[i] & 0x0f00) >> 8;
 
@@ -2064,7 +2064,7 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t *pi,
 
  cleanup:
 	wlc_lcnphy_tx_iqlo_loopback_cleanup(pi, values_to_save);
-	MFREE(pi->sh->osh, values_to_save, 20 * sizeof(uint16));
+	MFREE(pi->sh->osh, values_to_save, 20 * sizeof(u16));
 
 	if (!keep_tone)
 		wlc_lcnphy_stop_tx_tone(pi);
@@ -2087,14 +2087,14 @@ static void wlc_lcnphy_idle_tssi_est(wlc
 	bool suspend, tx_gain_override_old;
 	lcnphy_txgains_t old_gains;
 	phy_info_t *pi = (phy_info_t *) ppi;
-	uint16 idleTssi, idleTssi0_2C, idleTssi0_OB, idleTssi0_regvalue_OB,
+	u16 idleTssi, idleTssi0_2C, idleTssi0_OB, idleTssi0_regvalue_OB,
 	    idleTssi0_regvalue_2C;
-	uint16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
-	uint16 SAVE_lpfgain = read_radio_reg(pi, RADIO_2064_REG112);
-	uint16 SAVE_jtag_bb_afe_switch =
+	u16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	u16 SAVE_lpfgain = read_radio_reg(pi, RADIO_2064_REG112);
+	u16 SAVE_jtag_bb_afe_switch =
 	    read_radio_reg(pi, RADIO_2064_REG007) & 1;
-	uint16 SAVE_jtag_auxpga = read_radio_reg(pi, RADIO_2064_REG0FF) & 0x10;
-	uint16 SAVE_iqadc_aux_en = read_radio_reg(pi, RADIO_2064_REG11F) & 4;
+	u16 SAVE_jtag_auxpga = read_radio_reg(pi, RADIO_2064_REG0FF) & 0x10;
+	u16 SAVE_iqadc_aux_en = read_radio_reg(pi, RADIO_2064_REG11F) & 4;
 	idleTssi = read_phy_reg(pi, 0x4ab);
 	suspend =
 	    (0 ==
@@ -2151,14 +2151,14 @@ static void wlc_lcnphy_idle_tssi_est(wlc
 static void wlc_lcnphy_vbat_temp_sense_setup(phy_info_t *pi, u8 mode)
 {
 	bool suspend;
-	uint16 save_txpwrCtrlEn;
+	u16 save_txpwrCtrlEn;
 	u8 auxpga_vmidcourse, auxpga_vmidfine, auxpga_gain;
-	uint16 auxpga_vmid;
+	u16 auxpga_vmid;
 	phytbl_info_t tab;
 	uint32 val;
 	u8 save_reg007, save_reg0FF, save_reg11F, save_reg005, save_reg025,
 	    save_reg112;
-	uint16 values_to_save[14];
+	u16 values_to_save[14];
 	s8 index;
 	int i;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -2257,7 +2257,7 @@ static void wlc_lcnphy_vbat_temp_sense_s
 		auxpga_gain = 2;
 	}
 	auxpga_vmid =
-	    (uint16) ((2 << 8) | (auxpga_vmidcourse << 4) | auxpga_vmidfine);
+	    (u16) ((2 << 8) | (auxpga_vmidcourse << 4) | auxpga_vmidfine);
 	mod_phy_reg(pi, 0x4d8, (0x1 << 0), (1) << 0);
 
 	mod_phy_reg(pi, 0x4d8, (0x3ff << 2), (auxpga_vmid) << 2);
@@ -2274,12 +2274,12 @@ static void wlc_lcnphy_vbat_temp_sense_s
 	if (!tempsense_done(pi))
 		OSL_DELAY(10);
 
-	write_radio_reg(pi, RADIO_2064_REG007, (uint16) save_reg007);
-	write_radio_reg(pi, RADIO_2064_REG0FF, (uint16) save_reg0FF);
-	write_radio_reg(pi, RADIO_2064_REG11F, (uint16) save_reg11F);
-	write_radio_reg(pi, RADIO_2064_REG005, (uint16) save_reg005);
-	write_radio_reg(pi, RADIO_2064_REG025, (uint16) save_reg025);
-	write_radio_reg(pi, RADIO_2064_REG112, (uint16) save_reg112);
+	write_radio_reg(pi, RADIO_2064_REG007, (u16) save_reg007);
+	write_radio_reg(pi, RADIO_2064_REG0FF, (u16) save_reg0FF);
+	write_radio_reg(pi, RADIO_2064_REG11F, (u16) save_reg11F);
+	write_radio_reg(pi, RADIO_2064_REG005, (u16) save_reg005);
+	write_radio_reg(pi, RADIO_2064_REG025, (u16) save_reg025);
+	write_radio_reg(pi, RADIO_2064_REG112, (u16) save_reg112);
 	for (i = 0; i < 14; i++)
 		write_phy_reg(pi, tempsense_phy_regs[i], values_to_save[i]);
 	wlc_lcnphy_set_tx_pwr_by_index(pi, (int)index);
@@ -2370,7 +2370,7 @@ void WLBANDINITFN(wlc_lcnphy_tx_pwr_ctrl
 
 static u8 wlc_lcnphy_get_bbmult(phy_info_t *pi)
 {
-	uint16 m0m1;
+	u16 m0m1;
 	phytbl_info_t tab;
 
 	tab.tbl_ptr = &m0m1;
@@ -2383,7 +2383,7 @@ static u8 wlc_lcnphy_get_bbmult(phy_info
 	return (u8) ((m0m1 & 0xff00) >> 8);
 }
 
-static void wlc_lcnphy_set_pa_gain(phy_info_t *pi, uint16 gain)
+static void wlc_lcnphy_set_pa_gain(phy_info_t *pi, u16 gain)
 {
 	mod_phy_reg(pi, 0x4fb,
 		    LCNPHY_txgainctrlovrval1_pagain_ovr_val1_MASK,
@@ -2405,13 +2405,13 @@ wlc_lcnphy_get_radio_loft(phy_info_t *pi
 
 static void wlc_lcnphy_get_tx_gain(phy_info_t *pi, lcnphy_txgains_t *gains)
 {
-	uint16 dac_gain;
+	u16 dac_gain;
 
 	dac_gain = read_phy_reg(pi, 0x439) >> 0;
 	gains->dac_gain = (dac_gain & 0x380) >> 7;
 
 	{
-		uint16 rfgain0, rfgain1;
+		u16 rfgain0, rfgain1;
 
 		rfgain0 = (read_phy_reg(pi, 0x4b5) & (0xffff << 0)) >> 0;
 		rfgain1 = (read_phy_reg(pi, 0x4fb) & (0x7fff << 0)) >> 0;
@@ -2422,10 +2422,10 @@ static void wlc_lcnphy_get_tx_gain(phy_i
 	}
 }
 
-void wlc_lcnphy_set_tx_iqcc(phy_info_t *pi, uint16 a, uint16 b)
+void wlc_lcnphy_set_tx_iqcc(phy_info_t *pi, u16 a, u16 b)
 {
 	phytbl_info_t tab;
-	uint16 iqcc[2];
+	u16 iqcc[2];
 
 	iqcc[0] = a;
 	iqcc[1] = b;
@@ -2438,7 +2438,7 @@ void wlc_lcnphy_set_tx_iqcc(phy_info_t *
 	wlc_lcnphy_write_table(pi, &tab);
 }
 
-void wlc_lcnphy_set_tx_locc(phy_info_t *pi, uint16 didq)
+void wlc_lcnphy_set_tx_locc(phy_info_t *pi, u16 didq)
 {
 	phytbl_info_t tab;
 
@@ -2453,7 +2453,7 @@ void wlc_lcnphy_set_tx_locc(phy_info_t *
 void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t *pi, int index)
 {
 	phytbl_info_t tab;
-	uint16 a, b;
+	u16 a, b;
 	u8 bb_mult;
 	uint32 bbmultiqcomp, txgain, locoeffs, rfpower;
 	lcnphy_txgains_t gains;
@@ -2479,12 +2479,12 @@ void wlc_lcnphy_set_tx_pwr_by_index(phy_
 	tab.tbl_ptr = &txgain;
 	wlc_lcnphy_read_table(pi, &tab);
 
-	gains.gm_gain = (uint16) (txgain & 0xff);
-	gains.pga_gain = (uint16) (txgain >> 8) & 0xff;
-	gains.pad_gain = (uint16) (txgain >> 16) & 0xff;
-	gains.dac_gain = (uint16) (bbmultiqcomp >> 28) & 0x07;
+	gains.gm_gain = (u16) (txgain & 0xff);
+	gains.pga_gain = (u16) (txgain >> 8) & 0xff;
+	gains.pad_gain = (u16) (txgain >> 16) & 0xff;
+	gains.dac_gain = (u16) (bbmultiqcomp >> 28) & 0x07;
 	wlc_lcnphy_set_tx_gain(pi, &gains);
-	wlc_lcnphy_set_pa_gain(pi, (uint16) (txgain >> 24) & 0x7f);
+	wlc_lcnphy_set_pa_gain(pi, (u16) (txgain >> 24) & 0x7f);
 
 	bb_mult = (u8) ((bbmultiqcomp >> 20) & 0xff);
 	wlc_lcnphy_set_bbmult(pi, bb_mult);
@@ -2493,15 +2493,15 @@ void wlc_lcnphy_set_tx_pwr_by_index(phy_
 
 	if (!wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi)) {
 
-		a = (uint16) ((bbmultiqcomp >> 10) & 0x3ff);
-		b = (uint16) (bbmultiqcomp & 0x3ff);
+		a = (u16) ((bbmultiqcomp >> 10) & 0x3ff);
+		b = (u16) (bbmultiqcomp & 0x3ff);
 		wlc_lcnphy_set_tx_iqcc(pi, a, b);
 
 		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_LO_OFFSET + index;
 		tab.tbl_ptr = &locoeffs;
 		wlc_lcnphy_read_table(pi, &tab);
 
-		wlc_lcnphy_set_tx_locc(pi, (uint16) locoeffs);
+		wlc_lcnphy_set_tx_locc(pi, (u16) locoeffs);
 
 		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_PWR_OFFSET + index;
 		tab.tbl_ptr = &rfpower;
@@ -2542,13 +2542,13 @@ static void wlc_lcnphy_clear_papd_compta
 
 static void
 wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t *pi,
-				       uint16 trsw,
-				       uint16 ext_lna,
-				       uint16 biq2,
-				       uint16 biq1,
-				       uint16 tia, uint16 lna2, uint16 lna1)
+				       u16 trsw,
+				       u16 ext_lna,
+				       u16 biq2,
+				       u16 biq1,
+				       u16 tia, u16 lna2, u16 lna1)
 {
-	uint16 gain0_15, gain16_19;
+	u16 gain0_15, gain16_19;
 
 	gain16_19 = biq2 & 0xf;
 	gain0_15 = ((biq1 & 0xf) << 12) |
@@ -2577,7 +2577,7 @@ wlc_lcnphy_set_rx_gain_by_distribution(p
 
 static void wlc_lcnphy_rx_gain_override_enable(phy_info_t *pi, bool enable)
 {
-	uint16 ebit = enable ? 1 : 0;
+	u16 ebit = enable ? 1 : 0;
 
 	mod_phy_reg(pi, 0x4b0, (0x1 << 8), ebit << 8);
 
@@ -2604,27 +2604,27 @@ void wlc_lcnphy_tx_pu(phy_info_t *pi, bo
 {
 	if (!bEnable) {
 
-		and_phy_reg(pi, 0x43b, ~(uint16) ((0x1 << 1) | (0x1 << 4)));
+		and_phy_reg(pi, 0x43b, ~(u16) ((0x1 << 1) | (0x1 << 4)));
 
 		mod_phy_reg(pi, 0x43c, (0x1 << 1), 1 << 1);
 
 		and_phy_reg(pi, 0x44c,
-			    ~(uint16) ((0x1 << 3) |
+			    ~(u16) ((0x1 << 3) |
 				       (0x1 << 5) |
 				       (0x1 << 12) |
 				       (0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
 
 		and_phy_reg(pi, 0x44d,
-			    ~(uint16) ((0x1 << 3) | (0x1 << 5) | (0x1 << 14)));
+			    ~(u16) ((0x1 << 3) | (0x1 << 5) | (0x1 << 14)));
 		mod_phy_reg(pi, 0x44d, (0x1 << 2), 1 << 2);
 
 		mod_phy_reg(pi, 0x44d, (0x1 << 1) | (0x1 << 0), (0x1 << 0));
 
 		and_phy_reg(pi, 0x4f9,
-			    ~(uint16) ((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
+			    ~(u16) ((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
 
 		and_phy_reg(pi, 0x4fa,
-			    ~(uint16) ((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
+			    ~(u16) ((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
 	} else {
 
 		mod_phy_reg(pi, 0x43b, (0x1 << 1), 1 << 1);
@@ -2679,8 +2679,8 @@ void wlc_lcnphy_tx_pu(phy_info_t *pi, bo
 
 static void
 wlc_lcnphy_run_samples(phy_info_t *pi,
-		       uint16 num_samps,
-		       uint16 num_loops, uint16 wait, bool iqcalmode)
+		       u16 num_samps,
+		       u16 num_loops, u16 wait, bool iqcalmode)
 {
 
 	or_phy_reg(pi, 0x6da, 0x8080);
@@ -2694,7 +2694,7 @@ wlc_lcnphy_run_samples(phy_info_t *pi,
 
 	if (iqcalmode) {
 
-		and_phy_reg(pi, 0x453, (uint16) ~(0x1 << 15));
+		and_phy_reg(pi, 0x453, (u16) ~(0x1 << 15));
 		or_phy_reg(pi, 0x453, (0x1 << 15));
 	} else {
 		write_phy_reg(pi, 0x63f, 1);
@@ -2729,16 +2729,16 @@ void wlc_lcnphy_deaf_mode(phy_info_t *pi
 }
 
 void
-wlc_lcnphy_start_tx_tone(phy_info_t *pi, int32 f_kHz, uint16 max_val,
+wlc_lcnphy_start_tx_tone(phy_info_t *pi, int32 f_kHz, u16 max_val,
 			 bool iqcalmode)
 {
 	u8 phy_bw;
-	uint16 num_samps, t, k;
+	u16 num_samps, t, k;
 	uint32 bw;
 	fixed theta = 0, rot = 0;
 	cint32 tone_samp;
 	uint32 data_buf[64];
-	uint16 i_samp, q_samp;
+	u16 i_samp, q_samp;
 	phytbl_info_t tab;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -2774,8 +2774,8 @@ wlc_lcnphy_start_tx_tone(phy_info_t *pi,
 
 		theta += rot;
 
-		i_samp = (uint16) (FLOAT(tone_samp.i * max_val) & 0x3ff);
-		q_samp = (uint16) (FLOAT(tone_samp.q * max_val) & 0x3ff);
+		i_samp = (u16) (FLOAT(tone_samp.i * max_val) & 0x3ff);
+		q_samp = (u16) (FLOAT(tone_samp.q * max_val) & 0x3ff);
 		data_buf[t] = (i_samp << 10) | q_samp;
 	}
 
@@ -2827,12 +2827,12 @@ void wlc_lcnphy_stop_tx_tone(phy_info_t
 static void wlc_lcnphy_clear_trsw_override(phy_info_t *pi)
 {
 
-	and_phy_reg(pi, 0x44c, (uint16) ~((0x1 << 1) | (0x1 << 0)));
+	and_phy_reg(pi, 0x44c, (u16) ~((0x1 << 1) | (0x1 << 0)));
 }
 
-void wlc_lcnphy_get_tx_iqcc(phy_info_t *pi, uint16 *a, uint16 *b)
+void wlc_lcnphy_get_tx_iqcc(phy_info_t *pi, u16 *a, u16 *b)
 {
-	uint16 iqcc[2];
+	u16 iqcc[2];
 	phytbl_info_t tab;
 
 	tab.tbl_ptr = iqcc;
@@ -2846,10 +2846,10 @@ void wlc_lcnphy_get_tx_iqcc(phy_info_t *
 	*b = iqcc[1];
 }
 
-uint16 wlc_lcnphy_get_tx_locc(phy_info_t *pi)
+u16 wlc_lcnphy_get_tx_locc(phy_info_t *pi)
 {
 	phytbl_info_t tab;
-	uint16 didq;
+	u16 didq;
 
 	tab.tbl_id = 0;
 	tab.tbl_width = 16;
@@ -2866,10 +2866,10 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal
 
 	lcnphy_txgains_t target_gains, old_gains;
 	u8 save_bb_mult;
-	uint16 a, b, didq, save_pa_gain = 0;
+	u16 a, b, didq, save_pa_gain = 0;
 	uint idx, SAVE_txpwrindex = 0xFF;
 	uint32 val;
-	uint16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	u16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	phytbl_info_t tab;
 	u8 ei0, eq0, fi0, fq0;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -2977,7 +2977,7 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal
 
 int16 wlc_lcnphy_tempsense_new(phy_info_t *pi, bool mode)
 {
-	uint16 tempsenseval1, tempsenseval2;
+	u16 tempsenseval1, tempsenseval2;
 	int16 avg = 0;
 	bool suspend = 0;
 
@@ -3020,12 +3020,12 @@ int16 wlc_lcnphy_tempsense_new(phy_info_
 	return avg;
 }
 
-uint16 wlc_lcnphy_tempsense(phy_info_t *pi, bool mode)
+u16 wlc_lcnphy_tempsense(phy_info_t *pi, bool mode)
 {
-	uint16 tempsenseval1, tempsenseval2;
+	u16 tempsenseval1, tempsenseval2;
 	int32 avg = 0;
 	bool suspend = 0;
-	uint16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	u16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (NORADIO_ENAB(pi->pubpi))
@@ -3078,7 +3078,7 @@ uint16 wlc_lcnphy_tempsense(phy_info_t *
 		if (!suspend)
 			wlapi_enable_mac(pi->sh->physhim);
 	}
-	return (uint16) avg;
+	return (u16) avg;
 }
 
 s8 wlc_lcnphy_tempsense_degree(phy_info_t *pi, bool mode)
@@ -3092,7 +3092,7 @@ s8 wlc_lcnphy_tempsense_degree(phy_info_
 
 s8 wlc_lcnphy_vbatsense(phy_info_t *pi, bool mode)
 {
-	uint16 vbatsenseval;
+	u16 vbatsenseval;
 	int32 avg = 0;
 	bool suspend = 0;
 
@@ -3142,7 +3142,7 @@ static void wlc_lcnphy_afe_clk_init(phy_
 
 static bool
 wlc_lcnphy_rx_iq_est(phy_info_t *pi,
-		     uint16 num_samps,
+		     u16 num_samps,
 		     u8 wait_time, lcnphy_iq_est_t *iq_est)
 {
 	int wait_count = 0;
@@ -3156,7 +3156,7 @@ wlc_lcnphy_rx_iq_est(phy_info_t *pi,
 
 	mod_phy_reg(pi, 0x482, (0xffff << 0), (num_samps) << 0);
 
-	mod_phy_reg(pi, 0x481, (0xff << 0), ((uint16) wait_time) << 0);
+	mod_phy_reg(pi, 0x481, (0xff << 0), ((u16) wait_time) << 0);
 
 	mod_phy_reg(pi, 0x481, (0x1 << 8), (0) << 8);
 
@@ -3187,11 +3187,11 @@ wlc_lcnphy_rx_iq_est(phy_info_t *pi,
 	return result;
 }
 
-static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t *pi, uint16 num_samps)
+static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t *pi, u16 num_samps)
 {
 #define LCNPHY_MIN_RXIQ_PWR 2
 	bool result;
-	uint16 a0_new, b0_new;
+	u16 a0_new, b0_new;
 	lcnphy_iq_est_t iq_est = { 0, 0, 0 };
 	int32 a, b, temp;
 	int16 iq_nbits, qq_nbits, arsh, brsh;
@@ -3256,8 +3256,8 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 	b -= a * a;
 	b = (int32) wlc_phy_sqrt_int((uint32) b);
 	b -= (1 << 10);
-	a0_new = (uint16) (a & 0x3ff);
-	b0_new = (uint16) (b & 0x3ff);
+	a0_new = (u16) (a & 0x3ff);
+	b0_new = (u16) (b & 0x3ff);
  cleanup:
 
 	wlc_lcnphy_set_rx_iq_comp(pi, a0_new, b0_new);
@@ -3278,17 +3278,17 @@ wlc_lcnphy_rx_iq_cal(phy_info_t *pi, con
 		     int tx_gain_idx)
 {
 	lcnphy_txgains_t old_gains;
-	uint16 tx_pwr_ctrl;
+	u16 tx_pwr_ctrl;
 	u8 tx_gain_index_old = 0;
 	bool result = FALSE, tx_gain_override_old = FALSE;
-	uint16 i, Core1TxControl_old, RFOverride0_old,
+	u16 i, Core1TxControl_old, RFOverride0_old,
 	    RFOverrideVal0_old, rfoverride2_old, rfoverride2val_old,
 	    rfoverride3_old, rfoverride3val_old, rfoverride4_old,
 	    rfoverride4val_old, afectrlovr_old, afectrlovrval_old;
 	int tia_gain;
 	uint32 received_power, rx_pwr_threshold;
-	uint16 old_sslpnCalibClkEnCtrl, old_sslpnRxFeClkEnCtrl;
-	uint16 values_to_save[11];
+	u16 old_sslpnCalibClkEnCtrl, old_sslpnRxFeClkEnCtrl;
+	u16 values_to_save[11];
 	int16 *ptr;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -3304,9 +3304,9 @@ wlc_lcnphy_rx_iq_cal(phy_info_t *pi, con
 			    CHSPEC_CHANNEL(pi->radio_chanspec)) {
 
 				wlc_lcnphy_set_rx_iq_comp(pi,
-							  (uint16)
+							  (u16)
 							  iqcomp[iqcomp_sz].a,
-							  (uint16)
+							  (u16)
 							  iqcomp[iqcomp_sz].b);
 				result = TRUE;
 				break;
@@ -3393,7 +3393,7 @@ wlc_lcnphy_rx_iq_cal(phy_info_t *pi, con
 			tia_gain -= 1;
 			wlc_lcnphy_set_rx_gain_by_distribution(pi,
 							       0, 0, 2, 2,
-							       (uint16)
+							       (u16)
 							       tia_gain, 1, 0);
 			OSL_DELAY(500);
 
@@ -3454,7 +3454,7 @@ static void wlc_lcnphy_glacial_timer_bas
 {
 	bool suspend;
 	s8 index;
-	uint16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	u16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 	suspend =
 	    (0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
@@ -3480,7 +3480,7 @@ static void wlc_lcnphy_periodic_cal(phy_
 	bool suspend, full_cal;
 	const lcnphy_rx_iqcomp_t *rx_iqcomp;
 	int rx_iqcomp_sz;
-	uint16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	u16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	s8 index;
 	phytbl_info_t tab;
 	int32 a1, b0, b1;
@@ -3549,7 +3549,7 @@ static void wlc_lcnphy_periodic_cal(phy_
 
 void wlc_lcnphy_calib_modes(phy_info_t *pi, uint mode)
 {
-	uint16 temp_new;
+	u16 temp_new;
 	int temp1, temp2, temp_diff;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -3592,7 +3592,7 @@ void wlc_lcnphy_calib_modes(phy_info_t *
 void wlc_lcnphy_get_tssi(phy_info_t *pi, s8 *ofdm_pwr, s8 *cck_pwr)
 {
 	s8 cck_offset;
-	uint16 status;
+	u16 status;
 	status = (read_phy_reg(pi, 0x4ab));
 	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi) &&
 	    (status  & (0x1 << 15))) {
@@ -3678,13 +3678,13 @@ wlc_lcnphy_pktengtx(wlc_phy_t *ppi, wl_p
 void wlc_lcnphy_tx_power_adjustment(wlc_phy_t *ppi)
 {
 	s8 index;
-	uint16 index2;
+	u16 index2;
 	phy_info_t *pi = (phy_info_t *) ppi;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
-	uint16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	u16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi) && SAVE_txpwrctrl) {
 		index = wlc_lcnphy_tempcompensated_txpwrctrl(pi);
-		index2 = (uint16) (index * 2);
+		index2 = (u16) (index * 2);
 		mod_phy_reg(pi, 0x4a9, (0x1ff << 0), (index2) << 0);
 
 		pi_lcn->lcnphy_current_index = (s8)
@@ -3692,7 +3692,7 @@ void wlc_lcnphy_tx_power_adjustment(wlc_
 	}
 }
 
-static void wlc_lcnphy_set_rx_iq_comp(phy_info_t *pi, uint16 a, uint16 b)
+static void wlc_lcnphy_set_rx_iq_comp(phy_info_t *pi, u16 a, u16 b)
 {
 	mod_phy_reg(pi, 0x645, (0x3ff << 0), (a) << 0);
 
@@ -3758,9 +3758,9 @@ void WLBANDINITFN(wlc_phy_init_lcnphy) (
 }
 
 static void
-wlc_lcnphy_tx_iqlo_loopback(phy_info_t *pi, uint16 *values_to_save)
+wlc_lcnphy_tx_iqlo_loopback(phy_info_t *pi, u16 *values_to_save)
 {
-	uint16 vmid;
+	u16 vmid;
 	int i;
 	for (i = 0; i < 20; i++) {
 		values_to_save[i] =
@@ -3851,12 +3851,12 @@ wlc_lcnphy_tx_iqlo_loopback(phy_info_t *
 }
 
 static void
-wlc_lcnphy_samp_cap(phy_info_t *pi, int clip_detect_algo, uint16 thresh,
+wlc_lcnphy_samp_cap(phy_info_t *pi, int clip_detect_algo, u16 thresh,
 		    int16 *ptr, int mode)
 {
 	uint32 curval1, curval2, stpptr, curptr, strptr, val;
-	uint16 sslpnCalibClkEnCtrl, timer;
-	uint16 old_sslpnCalibClkEnCtrl;
+	u16 sslpnCalibClkEnCtrl, timer;
+	u16 old_sslpnCalibClkEnCtrl;
 	int16 imag, real;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -3876,7 +3876,7 @@ wlc_lcnphy_samp_cap(phy_info_t *pi, int
 	write_phy_reg(pi, 0x555, 0x0);
 	write_phy_reg(pi, 0x5a6, 0x5);
 
-	write_phy_reg(pi, 0x5a2, (uint16) (mode | mode << 6));
+	write_phy_reg(pi, 0x5a2, (u16) (mode | mode << 6));
 	write_phy_reg(pi, 0x5cf, 3);
 	write_phy_reg(pi, 0x5a5, 0x3);
 	write_phy_reg(pi, 0x583, 0x0);
@@ -3952,8 +3952,8 @@ static void wlc_lcnphy_tx_iqlo_soft_cal_
 static void
 wlc_lcnphy_set_cc(phy_info_t *pi, int cal_type, int16 coeff_x, int16 coeff_y)
 {
-	uint16 di0dq0;
-	uint16 x, y, data_rf;
+	u16 di0dq0;
+	u16 x, y, data_rf;
 	int k;
 	switch (cal_type) {
 	case 0:
@@ -3996,7 +3996,7 @@ wlc_lcnphy_set_cc(phy_info_t *pi, int ca
 
 static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t *pi, int cal_type)
 {
-	uint16 a, b, didq;
+	u16 a, b, didq;
 	u8 di0, dq0, ei, eq, fi, fq;
 	lcnphy_unsign16_struct cc;
 	cc.re = 0;
@@ -4011,18 +4011,18 @@ static lcnphy_unsign16_struct wlc_lcnphy
 		didq = wlc_lcnphy_get_tx_locc(pi);
 		di0 = (((didq & 0xff00) << 16) >> 24);
 		dq0 = (((didq & 0x00ff) << 24) >> 24);
-		cc.re = (uint16) di0;
-		cc.im = (uint16) dq0;
+		cc.re = (u16) di0;
+		cc.im = (u16) dq0;
 		break;
 	case 3:
 		wlc_lcnphy_get_radio_loft(pi, &ei, &eq, &fi, &fq);
-		cc.re = (uint16) ei;
-		cc.im = (uint16) eq;
+		cc.re = (u16) ei;
+		cc.im = (u16) eq;
 		break;
 	case 4:
 		wlc_lcnphy_get_radio_loft(pi, &ei, &eq, &fi, &fq);
-		cc.re = (uint16) fi;
-		cc.im = (uint16) fq;
+		cc.re = (u16) fi;
+		cc.im = (u16) fq;
 		break;
 	}
 	return cc;
@@ -4035,16 +4035,16 @@ wlc_lcnphy_a1(phy_info_t *pi, int cal_ty
 	lcnphy_spb_tone_t phy_c2;
 	lcnphy_unsign16_struct phy_c3;
 	int phy_c4, phy_c5, k, l, j, phy_c6;
-	uint16 phy_c7, phy_c8, phy_c9;
+	u16 phy_c7, phy_c8, phy_c9;
 	int16 phy_c10, phy_c11, phy_c12, phy_c13, phy_c14, phy_c15, phy_c16;
 	int16 *ptr, phy_c17;
 	int32 phy_c18, phy_c19;
 	uint32 phy_c20, phy_c21;
 	bool phy_c22, phy_c23, phy_c24, phy_c25;
-	uint16 phy_c26, phy_c27;
-	uint16 phy_c28, phy_c29, phy_c30;
-	uint16 phy_c31;
-	uint16 *phy_c32;
+	u16 phy_c26, phy_c27;
+	u16 phy_c28, phy_c29, phy_c30;
+	u16 phy_c31;
+	u16 *phy_c32;
 	phy_c21 = 0;
 	phy_c10 = phy_c13 = phy_c14 = phy_c8 = 0;
 	ptr = MALLOC(pi->sh->osh, sizeof(int16) * 131);
@@ -4052,7 +4052,7 @@ wlc_lcnphy_a1(phy_info_t *pi, int cal_ty
 		return;
 	}
 
-	phy_c32 = MALLOC(pi->sh->osh, sizeof(uint16) * 20);
+	phy_c32 = MALLOC(pi->sh->osh, sizeof(u16) * 20);
 	if (NULL == phy_c32) {
 		return;
 	}
@@ -4221,12 +4221,12 @@ wlc_lcnphy_a1(phy_info_t *pi, int cal_ty
 	write_phy_reg(pi, 0x4d8, phy_c30);
 	write_radio_reg(pi, RADIO_2064_REG026, phy_c31);
 
-	MFREE(pi->sh->osh, phy_c32, 20 * sizeof(uint16));
+	MFREE(pi->sh->osh, phy_c32, 20 * sizeof(u16));
 	MFREE(pi->sh->osh, ptr, 131 * sizeof(int16));
 }
 
 static void
-wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t *pi, uint16 *values_to_save)
+wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t *pi, u16 *values_to_save)
 {
 	int i;
 
@@ -4247,8 +4247,8 @@ WLBANDINITFN(wlc_lcnphy_load_tx_gain_tab
 	uint32 j;
 	phytbl_info_t tab;
 	uint32 val;
-	uint16 pa_gain;
-	uint16 gm_gain;
+	u16 pa_gain;
+	u16 gm_gain;
 
 	if (CHSPEC_IS5G(pi->radio_chanspec))
 		pa_gain = 0x70;
@@ -4423,7 +4423,7 @@ static void WLBANDINITFN(wlc_lcnphy_tbl_
 
 static void WLBANDINITFN(wlc_lcnphy_rev0_baseband_init) (phy_info_t *pi)
 {
-	uint16 afectrl1;
+	u16 afectrl1;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	write_radio_reg(pi, RADIO_2064_REG11C, 0x0);
@@ -4448,7 +4448,7 @@ static void WLBANDINITFN(wlc_lcnphy_rev0
 
 	if (0) {
 		afectrl1 = 0;
-		afectrl1 = (uint16) ((pi_lcn->lcnphy_rssi_vf) |
+		afectrl1 = (u16) ((pi_lcn->lcnphy_rssi_vf) |
 				     (pi_lcn->lcnphy_rssi_vc << 4) | (pi_lcn->
 								      lcnphy_rssi_gs
 								      << 10));
@@ -4615,12 +4615,12 @@ static void WLBANDINITFN(wlc_radio_2064_
 			write_radio_reg(pi,
 					((lcnphyregs[i].address & 0x3fff) |
 					 RADIO_DEFAULT_CORE),
-					(uint16) lcnphyregs[i].init_a);
+					(u16) lcnphyregs[i].init_a);
 		else if (lcnphyregs[i].do_init_g)
 			write_radio_reg(pi,
 					((lcnphyregs[i].address & 0x3fff) |
 					 RADIO_DEFAULT_CORE),
-					(uint16) lcnphyregs[i].init_g);
+					(u16) lcnphyregs[i].init_g);
 
 	write_radio_reg(pi, RADIO_2064_REG032, 0x62);
 	write_radio_reg(pi, RADIO_2064_REG033, 0x19);
@@ -4706,7 +4706,7 @@ static void wlc_lcnphy_rcal(phy_info_t *
 static void wlc_lcnphy_rc_cal(phy_info_t *pi)
 {
 	u8 dflt_rc_cal_val;
-	uint16 flt_val;
+	u16 flt_val;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
@@ -4733,7 +4733,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (CHSPEC_IS2G(pi->radio_chanspec)) {
-		uint16 cckpo = 0;
+		u16 cckpo = 0;
 		uint32 offset_ofdm, offset_mcs;
 
 		pi_lcn->lcnphy_tr_isolation_mid =
@@ -4771,7 +4771,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->txpa_2g_high_temp[i] = pi->txpa_2g[i];
 		}
 
-		cckpo = (uint16) PHY_GETINTVAR(pi, "cck2gpo");
+		cckpo = (u16) PHY_GETINTVAR(pi, "cck2gpo");
 		if (cckpo) {
 			uint max_pwr_chan = txpwr;
 
@@ -4804,8 +4804,8 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 				offset_ofdm >>= 4;
 			}
 			offset_mcs =
-			    ((uint16) PHY_GETINTVAR(pi, "mcs2gpo1") << 16) |
-			    (uint16) PHY_GETINTVAR(pi, "mcs2gpo0");
+			    ((u16) PHY_GETINTVAR(pi, "mcs2gpo1") << 16) |
+			    (u16) PHY_GETINTVAR(pi, "mcs2gpo0");
 			pi_lcn->lcnphy_mcs20_po = offset_mcs;
 			for (i = TXP_FIRST_SISO_MCS_20;
 			     i <= TXP_LAST_SISO_MCS_20; i++) {
@@ -4816,7 +4816,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 		}
 
 		pi_lcn->lcnphy_rawtempsense =
-		    (uint16) PHY_GETINTVAR(pi, "rawtempsense");
+		    (u16) PHY_GETINTVAR(pi, "rawtempsense");
 		pi_lcn->lcnphy_measPower =
 		    (u8) PHY_GETINTVAR(pi, "measpower");
 		pi_lcn->lcnphy_tempsense_slope =
@@ -4873,7 +4873,7 @@ wlc_lcnphy_radio_2064_channel_tune_4313(
 	fixed qFxtal, qFref, qFvco, qFcal;
 	u8 d15, d16, f16, e44, e45;
 	uint32 div_int, div_frac, fvco3, fpfd, fref3, fcal_div;
-	uint16 loop_bw, d30, setCount;
+	u16 loop_bw, d30, setCount;
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 	ci = &chan_info_2064_lcnphy[0];
@@ -4991,7 +4991,7 @@ wlc_lcnphy_radio_2064_channel_tune_4313(
 
 	{
 		u8 h29, h23, c28, d29, h28_ten, e30, h30_ten, cp_current;
-		uint16 c29, c38, c30, g30, d28;
+		u16 c29, c38, c30, g30, d28;
 		c29 = loop_bw;
 		d29 = 200;
 		c38 = 1250;
@@ -5040,7 +5040,7 @@ bool wlc_phy_tpc_isenabled_lcnphy(phy_in
 
 void wlc_phy_txpower_recalc_target_lcnphy(phy_info_t *pi)
 {
-	uint16 pwr_ctrl;
+	u16 pwr_ctrl;
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi)) {
 		wlc_lcnphy_calib_modes(pi, LCNPHY_PERICAL_TEMPBASED_TXPWRCTRL);
 	} else if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi)) {
@@ -5113,17 +5113,17 @@ bool wlc_phy_attach_lcnphy(phy_info_t *p
 
 static void wlc_lcnphy_set_rx_gain(phy_info_t *pi, uint32 gain)
 {
-	uint16 trsw, ext_lna, lna1, lna2, tia, biq0, biq1, gain0_15, gain16_19;
+	u16 trsw, ext_lna, lna1, lna2, tia, biq0, biq1, gain0_15, gain16_19;
 
 	trsw = (gain & ((uint32) 1 << 28)) ? 0 : 1;
-	ext_lna = (uint16) (gain >> 29) & 0x01;
-	lna1 = (uint16) (gain >> 0) & 0x0f;
-	lna2 = (uint16) (gain >> 4) & 0x0f;
-	tia = (uint16) (gain >> 8) & 0xf;
-	biq0 = (uint16) (gain >> 12) & 0xf;
-	biq1 = (uint16) (gain >> 16) & 0xf;
+	ext_lna = (u16) (gain >> 29) & 0x01;
+	lna1 = (u16) (gain >> 0) & 0x0f;
+	lna2 = (u16) (gain >> 4) & 0x0f;
+	tia = (u16) (gain >> 8) & 0xf;
+	biq0 = (u16) (gain >> 12) & 0xf;
+	biq1 = (u16) (gain >> 16) & 0xf;
 
-	gain0_15 = (uint16) ((lna1 & 0x3) | ((lna1 & 0x3) << 2) |
+	gain0_15 = (u16) ((lna1 & 0x3) | ((lna1 & 0x3) << 2) |
 			     ((lna2 & 0x3) << 4) | ((lna2 & 0x3) << 6) |
 			     ((tia & 0xf) << 8) | ((biq0 & 0xf) << 12));
 	gain16_19 = biq1;
@@ -5254,7 +5254,7 @@ wlc_lcnphy_load_tx_iir_filter(phy_info_t
 	int16 filt_index = -1;
 	int j;
 
-	uint16 addr[] = {
+	u16 addr[] = {
 		0x910,
 		0x91e,
 		0x91f,
@@ -5273,7 +5273,7 @@ wlc_lcnphy_load_tx_iir_filter(phy_info_t
 		0x932
 	};
 
-	uint16 addr_ofdm[] = {
+	u16 addr_ofdm[] = {
 		0x90f,
 		0x900,
 		0x901,
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
@@ -23,7 +23,7 @@ struct phy_info_lcnphy {
 	int lcnphy_txrf_sp_9_override;
 	u8 lcnphy_full_cal_channel;
 	u8 lcnphy_cal_counter;
-	uint16 lcnphy_cal_temper;
+	u16 lcnphy_cal_temper;
 	bool lcnphy_recal;
 
 	u8 lcnphy_rc_cap;
@@ -51,7 +51,7 @@ struct phy_info_lcnphy {
 	int16 lcnphy_pa0b1;
 	int16 lcnphy_pa0b2;
 
-	uint16 lcnphy_rawtempsense;
+	u16 lcnphy_rawtempsense;
 	u8 lcnphy_measPower;
 	u8 lcnphy_tempsense_slope;
 	u8 lcnphy_freqoffset_corr;
@@ -61,13 +61,13 @@ struct phy_info_lcnphy {
 	bool lcnphy_hw_iqcal_en;
 	uint lcnphy_bandedge_corr;
 	bool lcnphy_spurmod;
-	uint16 lcnphy_tssi_tx_cnt;
-	uint16 lcnphy_tssi_idx;
-	uint16 lcnphy_tssi_npt;
+	u16 lcnphy_tssi_tx_cnt;
+	u16 lcnphy_tssi_idx;
+	u16 lcnphy_tssi_npt;
 
-	uint16 lcnphy_target_tx_freq;
+	u16 lcnphy_target_tx_freq;
 	s8 lcnphy_tx_power_idx_override;
-	uint16 lcnphy_noise_samples;
+	u16 lcnphy_noise_samples;
 
 	uint32 lcnphy_papdRxGnIdx;
 	uint32 lcnphy_papd_rxGnCtrl_init;
@@ -81,8 +81,8 @@ struct phy_info_lcnphy {
 	uint32 lcnphy_tr_R_gain_val;
 	uint32 lcnphy_tr_T_gain_val;
 	s8 lcnphy_input_pwr_offset_db;
-	uint16 lcnphy_Med_Low_Gain_db;
-	uint16 lcnphy_Very_Low_Gain_db;
+	u16 lcnphy_Med_Low_Gain_db;
+	u16 lcnphy_Very_Low_Gain_db;
 	s8 lcnphy_lastsensed_temperature;
 	s8 lcnphy_pkteng_rssi_slope;
 	u8 lcnphy_saved_tx_user_target[TXP_NUM_RATES];
@@ -95,9 +95,9 @@ struct phy_info_lcnphy {
 	u8 lcnphy_psat_2pt3_detected;
 	int32 lcnphy_lowest_Re_div_Im;
 	s8 lcnphy_final_papd_cal_idx;
-	uint16 lcnphy_extstxctrl4;
-	uint16 lcnphy_extstxctrl0;
-	uint16 lcnphy_extstxctrl1;
+	u16 lcnphy_extstxctrl4;
+	u16 lcnphy_extstxctrl0;
+	u16 lcnphy_extstxctrl1;
 	int16 lcnphy_cck_dig_filt_type;
 	int16 lcnphy_ofdm_dig_filt_type;
 	lcnphy_cal_results_t lcnphy_cal_results;
@@ -108,11 +108,11 @@ struct phy_info_lcnphy {
 	u8 lcnphy_final_idx;
 	u8 lcnphy_start_idx;
 	u8 lcnphy_current_index;
-	uint16 lcnphy_logen_buf_1;
-	uint16 lcnphy_local_ovr_2;
-	uint16 lcnphy_local_oval_6;
-	uint16 lcnphy_local_oval_5;
-	uint16 lcnphy_logen_mixer_1;
+	u16 lcnphy_logen_buf_1;
+	u16 lcnphy_local_ovr_2;
+	u16 lcnphy_local_oval_6;
+	u16 lcnphy_local_oval_5;
+	u16 lcnphy_logen_mixer_1;
 
 	u8 lcnphy_aci_stat;
 	uint lcnphy_aci_start_time;
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -141,13 +141,13 @@
 #define NPHY_ADJUSTED_MINCRSPOWER 0x1e
 
 typedef struct _nphy_iqcal_params {
-	uint16 txlpf;
-	uint16 txgm;
-	uint16 pga;
-	uint16 pad;
-	uint16 ipa;
-	uint16 cal_gain;
-	uint16 ncorr[5];
+	u16 txlpf;
+	u16 txgm;
+	u16 pga;
+	u16 pad;
+	u16 ipa;
+	u16 cal_gain;
+	u16 ncorr[5];
 } nphy_iqcal_params_t;
 
 typedef struct _nphy_txiqcal_ladder {
@@ -162,22 +162,22 @@ typedef struct {
 } nphy_ipa_txcalgains_t;
 
 typedef struct nphy_papd_restore_state_t {
-	uint16 fbmix[2];
-	uint16 vga_master[2];
-	uint16 intpa_master[2];
-	uint16 afectrl[2];
-	uint16 afeoverride[2];
-	uint16 pwrup[2];
-	uint16 atten[2];
-	uint16 mm;
+	u16 fbmix[2];
+	u16 vga_master[2];
+	u16 intpa_master[2];
+	u16 afectrl[2];
+	u16 afeoverride[2];
+	u16 pwrup[2];
+	u16 atten[2];
+	u16 mm;
 } nphy_papd_restore_state;
 
 typedef struct _nphy_ipa_txrxgain {
-	uint16 hpvga;
-	uint16 lpf_biq1;
-	uint16 lpf_biq0;
-	uint16 lna2;
-	uint16 lna1;
+	u16 hpvga;
+	u16 lpf_biq1;
+	u16 lpf_biq0;
+	u16 lna2;
+	u16 lna1;
 	s8 txpwrindex;
 } nphy_ipa_txrxgain_t;
 
@@ -237,7 +237,7 @@ enum {
 #define TXFILT_DEFAULT_OFDM20   3
 #define TXFILT_DEFAULT_OFDM40   4
 
-uint16 NPHY_IPA_REV4_txdigi_filtcoeffs[][NPHY_NUM_DIG_FILT_COEFFS] = {
+u16 NPHY_IPA_REV4_txdigi_filtcoeffs[][NPHY_NUM_DIG_FILT_COEFFS] = {
 	{-377, 137, -407, 208, -1527, 956, 93, 186, 93,
 	 230, -44, 230, 201, -191, 201},
 	{-77, 20, -98, 49, -93, 60, 56, 111, 56, 26, -5,
@@ -255,8 +255,8 @@ uint16 NPHY_IPA_REV4_txdigi_filtcoeffs[]
 };
 
 typedef struct _chan_info_nphy_2055 {
-	uint16 chan;
-	uint16 freq;
+	u16 chan;
+	u16 freq;
 	uint unknown;
 	u8 RF_pll_ref;
 	u8 RF_rf_pll_mod1;
@@ -280,17 +280,17 @@ typedef struct _chan_info_nphy_2055 {
 	u8 RF_core2_rxrf_reg1;
 	u8 RF_core2_tx_pga_pad_tn;
 	u8 RF_core2_tx_mx_bgtrim;
-	uint16 PHY_BW1a;
-	uint16 PHY_BW2;
-	uint16 PHY_BW3;
-	uint16 PHY_BW4;
-	uint16 PHY_BW5;
-	uint16 PHY_BW6;
+	u16 PHY_BW1a;
+	u16 PHY_BW2;
+	u16 PHY_BW3;
+	u16 PHY_BW4;
+	u16 PHY_BW5;
+	u16 PHY_BW6;
 } chan_info_nphy_2055_t;
 
 typedef struct _chan_info_nphy_radio205x {
-	uint16 chan;
-	uint16 freq;
+	u16 chan;
+	u16 freq;
 	u8 RF_SYN_pll_vcocal1;
 	u8 RF_SYN_pll_vcocal2;
 	u8 RF_SYN_pll_refdiv;
@@ -328,17 +328,17 @@ typedef struct _chan_info_nphy_radio205x
 	u8 RF_TX1_pgag_boost_tune;
 	u8 RF_TX1_mixa_boost_tune;
 	u8 RF_TX1_mixg_boost_tune;
-	uint16 PHY_BW1a;
-	uint16 PHY_BW2;
-	uint16 PHY_BW3;
-	uint16 PHY_BW4;
-	uint16 PHY_BW5;
-	uint16 PHY_BW6;
+	u16 PHY_BW1a;
+	u16 PHY_BW2;
+	u16 PHY_BW3;
+	u16 PHY_BW4;
+	u16 PHY_BW5;
+	u16 PHY_BW6;
 } chan_info_nphy_radio205x_t;
 
 typedef struct _chan_info_nphy_radio2057 {
-	uint16 chan;
-	uint16 freq;
+	u16 chan;
+	u16 freq;
 	u8 RF_vcocal_countval0;
 	u8 RF_vcocal_countval1;
 	u8 RF_rfpll_refmaster_sparextalsize;
@@ -367,17 +367,17 @@ typedef struct _chan_info_nphy_radio2057
 	u8 RF_pad5g_tune_misc_pus_core1;
 	u8 RF_lna2g_tune_core1;
 	u8 RF_lna5g_tune_core1;
-	uint16 PHY_BW1a;
-	uint16 PHY_BW2;
-	uint16 PHY_BW3;
-	uint16 PHY_BW4;
-	uint16 PHY_BW5;
-	uint16 PHY_BW6;
+	u16 PHY_BW1a;
+	u16 PHY_BW2;
+	u16 PHY_BW3;
+	u16 PHY_BW4;
+	u16 PHY_BW5;
+	u16 PHY_BW6;
 } chan_info_nphy_radio2057_t;
 
 typedef struct _chan_info_nphy_radio2057_rev5 {
-	uint16 chan;
-	uint16 freq;
+	u16 chan;
+	u16 freq;
 	u8 RF_vcocal_countval0;
 	u8 RF_vcocal_countval1;
 	u8 RF_rfpll_refmaster_sparextalsize;
@@ -396,21 +396,21 @@ typedef struct _chan_info_nphy_radio2057
 	u8 RF_txmix2g_tune_boost_pu_core1;
 	u8 RF_pad2g_tune_pus_core1;
 	u8 RF_lna2g_tune_core1;
-	uint16 PHY_BW1a;
-	uint16 PHY_BW2;
-	uint16 PHY_BW3;
-	uint16 PHY_BW4;
-	uint16 PHY_BW5;
-	uint16 PHY_BW6;
+	u16 PHY_BW1a;
+	u16 PHY_BW2;
+	u16 PHY_BW3;
+	u16 PHY_BW4;
+	u16 PHY_BW5;
+	u16 PHY_BW6;
 } chan_info_nphy_radio2057_rev5_t;
 
 typedef struct nphy_sfo_cfg {
-	uint16 PHY_BW1a;
-	uint16 PHY_BW2;
-	uint16 PHY_BW3;
-	uint16 PHY_BW4;
-	uint16 PHY_BW5;
-	uint16 PHY_BW6;
+	u16 PHY_BW1a;
+	u16 PHY_BW2;
+	u16 PHY_BW3;
+	u16 PHY_BW4;
+	u16 PHY_BW5;
+	u16 PHY_BW6;
 } nphy_sfo_cfg_t;
 
 static chan_info_nphy_2055_t chan_info_nphy_2055[] = {
@@ -13285,7 +13285,7 @@ static int16 nphy_def_lnagains[] = { -2,
 static int32 nphy_lnagain_est0[] = { -315, 40370 };
 static int32 nphy_lnagain_est1[] = { -224, 23242 };
 
-static const uint16 tbl_iqcal_gainparams_nphy[2][NPHY_IQCAL_NUMGAINS][8] = {
+static const u16 tbl_iqcal_gainparams_nphy[2][NPHY_IQCAL_NUMGAINS][8] = {
 	{
 	 {0x000, 0, 0, 2, 0x69, 0x69, 0x69, 0x69},
 	 {0x700, 7, 0, 0, 0x69, 0x69, 0x69, 0x69},
@@ -13345,7 +13345,7 @@ static const uint32 nphy_tpc_txgain[] =
 	0x03801442, 0x03801344, 0x03801342, 0x00002b00
 };
 
-static const uint16 nphy_tpc_loscale[] = {
+static const u16 nphy_tpc_loscale[] = {
 	256, 256, 271, 271, 287, 256, 256, 271,
 	271, 287, 287, 304, 304, 256, 256, 271,
 	271, 287, 287, 304, 304, 322, 322, 341,
@@ -14091,7 +14091,7 @@ static void wlc_phy_chanspec_nphy_setup(
 					const nphy_sfo_cfg_t *c);
 
 static void wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t *pi,
-					    uint16 reduction_factr);
+					    u16 reduction_factr);
 static void wlc_phy_adjust_min_noisevar_nphy(phy_info_t *pi, int ntones, int *,
 					     uint32 *buf);
 static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t *pi, u8 minpwr);
@@ -14118,7 +14118,7 @@ static void wlc_phy_tx_iq_war_nphy(phy_i
 static int wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *pi, nphy_txgains_t tg,
 				      u8 type, bool d);
 static void wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t *pi, u8 rxcore,
-					     uint16 *rg, u8 type);
+					     u16 *rg, u8 type);
 static void wlc_phy_update_mimoconfig_nphy(phy_info_t *pi, int32 preamble);
 static void wlc_phy_savecal_nphy(phy_info_t *pi);
 static void wlc_phy_restorecal_nphy(phy_info_t *pi);
@@ -14127,12 +14127,12 @@ static void wlc_phy_resetcca_nphy(phy_in
 static void wlc_phy_txpwrctrl_config_nphy(phy_info_t *pi);
 static void wlc_phy_internal_cal_txgain_nphy(phy_info_t *pi);
 static void wlc_phy_precal_txgain_nphy(phy_info_t *pi);
-static void wlc_phy_update_txcal_ladder_nphy(phy_info_t *pi, uint16 core);
+static void wlc_phy_update_txcal_ladder_nphy(phy_info_t *pi, u16 core);
 
 static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t *pi);
 static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t *pi);
 static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t *pi);
-static uint16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t *pi);
+static u16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t *pi);
 static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t *pi, u8 m0, u8 m1);
 static uint32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t *pi);
 
@@ -14146,15 +14146,15 @@ static void wlc_phy_papd_cal_cleanup_nph
 static void wlc_phy_papd_cal_setup_nphy(phy_info_t *pi,
 					nphy_papd_restore_state *state, u8);
 
-static void wlc_phy_clip_det_nphy(phy_info_t *pi, u8 write, uint16 *vals);
+static void wlc_phy_clip_det_nphy(phy_info_t *pi, u8 write, u16 *vals);
 
 static void wlc_phy_set_rfseq_nphy(phy_info_t *pi, u8 cmd, u8 *evts,
 				   u8 *dlys, u8 len);
 
-static uint16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t *pi, uint16 offset);
+static u16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t *pi, u16 offset);
 
 static void
-wlc_phy_rfctrl_override_nphy_rev7(phy_info_t *pi, uint16 field, uint16 value,
+wlc_phy_rfctrl_override_nphy_rev7(phy_info_t *pi, u16 field, u16 value,
 				  u8 core_mask, u8 off,
 				  u8 override_id);
 
@@ -14163,7 +14163,7 @@ static void wlc_phy_rssi_cal_nphy_rev3(p
 
 static bool wlc_phy_txpwr_srom_read_nphy(phy_info_t *pi);
 static void wlc_phy_txpwr_nphy_srom_convert(u8 *srom_max,
-					    uint16 *pwr_offset,
+					    u16 *pwr_offset,
 					    u8 tmp_max_pwr, u8 rate_start,
 					    u8 rate_end);
 
@@ -14178,17 +14178,17 @@ static void wlc_phy_txpwr_idx_cur_set_np
 					   u8 idx1);
 static void wlc_phy_a4(phy_info_t *pi, bool full_cal);
 
-static uint16 wlc_phy_radio205x_rcal(phy_info_t *pi);
+static u16 wlc_phy_radio205x_rcal(phy_info_t *pi);
 
-static uint16 wlc_phy_radio2057_rccal(phy_info_t *pi);
+static u16 wlc_phy_radio2057_rccal(phy_info_t *pi);
 
-static uint16 wlc_phy_gen_load_samples_nphy(phy_info_t *pi, uint32 f_kHz,
-					    uint16 max_val,
+static u16 wlc_phy_gen_load_samples_nphy(phy_info_t *pi, uint32 f_kHz,
+					    u16 max_val,
 					    u8 dac_test_mode);
 static void wlc_phy_loadsampletable_nphy(phy_info_t *pi, cint32 *tone_buf,
-					 uint16 num_samps);
-static void wlc_phy_runsamples_nphy(phy_info_t *pi, uint16 n, uint16 lps,
-				    uint16 wait, u8 iq, u8 dac_test_mode,
+					 u16 num_samps);
+static void wlc_phy_runsamples_nphy(phy_info_t *pi, u16 n, u16 lps,
+				    u16 wait, u8 iq, u8 dac_test_mode,
 				    bool modify_bbmult);
 
 bool wlc_phy_bist_check_phy(wlc_phy_t *pih)
@@ -14215,7 +14215,7 @@ bool wlc_phy_bist_check_phy(wlc_phy_t *p
 
 static void WLBANDINITFN(wlc_phy_bphy_init_nphy) (phy_info_t *pi)
 {
-	uint16 addr, val;
+	u16 addr, val;
 
 	ASSERT(ISNPHY(pi));
 
@@ -14420,7 +14420,7 @@ static void WLBANDINITFN(wlc_phy_tbl_ini
 }
 
 static void
-wlc_phy_write_txmacreg_nphy(phy_info_t *pi, uint16 holdoff, uint16 delay)
+wlc_phy_write_txmacreg_nphy(phy_info_t *pi, u16 holdoff, u16 delay)
 {
 	write_phy_reg(pi, 0x77, holdoff);
 	write_phy_reg(pi, 0xb4, delay);
@@ -14428,7 +14428,7 @@ wlc_phy_write_txmacreg_nphy(phy_info_t *
 
 void wlc_phy_nphy_tkip_rifs_war(phy_info_t *pi, u8 rifs)
 {
-	uint16 holdoff, delay;
+	u16 holdoff, delay;
 
 	if (rifs) {
 
@@ -14528,8 +14528,8 @@ static void BCMATTACHFN(wlc_phy_txpwrctr
 
 void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t *pi)
 {
-	uint16 val;
-	uint16 clip1_ths[2];
+	u16 val;
+	u16 clip1_ths[2];
 	nphy_txgains_t target_gain;
 	u8 tx_pwr_ctrl_state;
 	bool do_nphy_cal = FALSE;
@@ -14705,7 +14705,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		uint32 *tx_pwrctrl_tbl = NULL;
-		uint16 idx;
+		u16 idx;
 		int16 pga_gn = 0;
 		int16 pad_gn = 0;
 		int32 rfpwr_offset = 0;
@@ -14757,7 +14757,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CORE2TXPWRCTL, 128,
 					 192, 32, tx_pwrctrl_tbl);
 
-		pi->nphy_gmval = (uint16) ((*tx_pwrctrl_tbl >> 16) & 0x7000);
+		pi->nphy_gmval = (u16) ((*tx_pwrctrl_tbl >> 16) & 0x7000);
 
 		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -14942,7 +14942,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 static void wlc_phy_update_mimoconfig_nphy(phy_info_t *pi, int32 preamble)
 {
 	bool gf_preamble = FALSE;
-	uint16 val;
+	u16 val;
 
 	if (preamble == WLC_N_PREAMBLE_GF) {
 		gf_preamble = TRUE;
@@ -14960,7 +14960,7 @@ static void wlc_phy_update_mimoconfig_np
 
 static void wlc_phy_resetcca_nphy(phy_info_t *pi)
 {
-	uint16 val;
+	u16 val;
 
 	ASSERT(0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
 
@@ -14978,7 +14978,7 @@ static void wlc_phy_resetcca_nphy(phy_in
 
 void wlc_phy_pa_override_nphy(phy_info_t *pi, bool en)
 {
-	uint16 rfctrlintc_override_val;
+	u16 rfctrlintc_override_val;
 
 	if (!en) {
 
@@ -15008,7 +15008,7 @@ void wlc_phy_pa_override_nphy(phy_info_t
 void wlc_phy_stf_chain_upd_nphy(phy_info_t *pi)
 {
 
-	uint16 txrx_chain =
+	u16 txrx_chain =
 	    (NPHY_RfseqCoreActv_TxRxChain0 | NPHY_RfseqCoreActv_TxRxChain1);
 	bool CoreActv_override = FALSE;
 
@@ -15042,11 +15042,11 @@ void wlc_phy_stf_chain_upd_nphy(phy_info
 
 void wlc_phy_rxcore_setstate_nphy(wlc_phy_t *pih, u8 rxcore_bitmask)
 {
-	uint16 regval;
-	uint16 tbl_buf[16];
+	u16 regval;
+	u16 tbl_buf[16];
 	uint i;
 	phy_info_t *pi = (phy_info_t *) pih;
-	uint16 tbl_opcode;
+	u16 tbl_opcode;
 	bool suspend;
 
 	pi->sh->phyrxchain = rxcore_bitmask;
@@ -15064,7 +15064,7 @@ void wlc_phy_rxcore_setstate_nphy(wlc_ph
 
 	regval = read_phy_reg(pi, 0xa2);
 	regval &= ~(0xf << 4);
-	regval |= ((uint16) (rxcore_bitmask & 0x3)) << 4;
+	regval |= ((u16) (rxcore_bitmask & 0x3)) << 4;
 	write_phy_reg(pi, 0xa2, regval);
 
 	if ((rxcore_bitmask & 0x3) != 0x3) {
@@ -15123,7 +15123,7 @@ void wlc_phy_rxcore_setstate_nphy(wlc_ph
 
 u8 wlc_phy_rxcore_getstate_nphy(wlc_phy_t *pih)
 {
-	uint16 regval, rxen_bits;
+	u16 regval, rxen_bits;
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	regval = read_phy_reg(pi, 0xa2);
@@ -15327,56 +15327,56 @@ static void wlc_phy_workarounds_nphy(phy
 		NPHY_REV3_RFSEQ_CMD_END
 	};
 	u8 rfseq_rx2tx_dlys_rev3_ipa[] = { 8, 6, 6, 4, 4, 16, 43, 1, 1 };
-	uint16 rfseq_rx2tx_dacbufpu_rev7[] = { 0x10f, 0x10f };
+	u16 rfseq_rx2tx_dacbufpu_rev7[] = { 0x10f, 0x10f };
 
 	int16 alpha0, alpha1, alpha2;
 	int16 beta0, beta1, beta2;
 	uint32 leg_data_weights, ht_data_weights, nss1_data_weights,
 	    stbc_data_weights;
 	u8 chan_freq_range = 0;
-	uint16 dac_control = 0x0002;
-	uint16 aux_adc_vmid_rev7_core0[] = { 0x8e, 0x96, 0x96, 0x96 };
-	uint16 aux_adc_vmid_rev7_core1[] = { 0x8f, 0x9f, 0x9f, 0x96 };
-	uint16 aux_adc_vmid_rev4[] = { 0xa2, 0xb4, 0xb4, 0x89 };
-	uint16 aux_adc_vmid_rev3[] = { 0xa2, 0xb4, 0xb4, 0x89 };
-	uint16 *aux_adc_vmid;
-	uint16 aux_adc_gain_rev7[] = { 0x02, 0x02, 0x02, 0x02 };
-	uint16 aux_adc_gain_rev4[] = { 0x02, 0x02, 0x02, 0x00 };
-	uint16 aux_adc_gain_rev3[] = { 0x02, 0x02, 0x02, 0x00 };
-	uint16 *aux_adc_gain;
-	uint16 sk_adc_vmid[] = { 0xb4, 0xb4, 0xb4, 0x24 };
-	uint16 sk_adc_gain[] = { 0x02, 0x02, 0x02, 0x02 };
+	u16 dac_control = 0x0002;
+	u16 aux_adc_vmid_rev7_core0[] = { 0x8e, 0x96, 0x96, 0x96 };
+	u16 aux_adc_vmid_rev7_core1[] = { 0x8f, 0x9f, 0x9f, 0x96 };
+	u16 aux_adc_vmid_rev4[] = { 0xa2, 0xb4, 0xb4, 0x89 };
+	u16 aux_adc_vmid_rev3[] = { 0xa2, 0xb4, 0xb4, 0x89 };
+	u16 *aux_adc_vmid;
+	u16 aux_adc_gain_rev7[] = { 0x02, 0x02, 0x02, 0x02 };
+	u16 aux_adc_gain_rev4[] = { 0x02, 0x02, 0x02, 0x00 };
+	u16 aux_adc_gain_rev3[] = { 0x02, 0x02, 0x02, 0x00 };
+	u16 *aux_adc_gain;
+	u16 sk_adc_vmid[] = { 0xb4, 0xb4, 0xb4, 0x24 };
+	u16 sk_adc_gain[] = { 0x02, 0x02, 0x02, 0x02 };
 	int32 min_nvar_val = 0x18d;
 	int32 min_nvar_offset_6mbps = 20;
 	u8 pdetrange;
 	u8 triso;
-	uint16 regval;
-	uint16 afectrl_adc_ctrl1_rev7 = 0x20;
-	uint16 afectrl_adc_ctrl2_rev7 = 0x0;
-	uint16 rfseq_rx2tx_lpf_h_hpc_rev7 = 0x77;
-	uint16 rfseq_tx2rx_lpf_h_hpc_rev7 = 0x77;
-	uint16 rfseq_pktgn_lpf_h_hpc_rev7 = 0x77;
-	uint16 rfseq_htpktgn_lpf_hpc_rev7[] = { 0x77, 0x11, 0x11 };
-	uint16 rfseq_pktgn_lpf_hpc_rev7[] = { 0x11, 0x11 };
-	uint16 rfseq_cckpktgn_lpf_hpc_rev7[] = { 0x11, 0x11 };
-	uint16 ipalvlshift_3p3_war_en = 0;
-	uint16 rccal_bcap_val, rccal_scap_val;
-	uint16 rccal_tx20_11b_bcap = 0;
-	uint16 rccal_tx20_11b_scap = 0;
-	uint16 rccal_tx20_11n_bcap = 0;
-	uint16 rccal_tx20_11n_scap = 0;
-	uint16 rccal_tx40_11n_bcap = 0;
-	uint16 rccal_tx40_11n_scap = 0;
-	uint16 rx2tx_lpf_rc_lut_tx20_11b = 0;
-	uint16 rx2tx_lpf_rc_lut_tx20_11n = 0;
-	uint16 rx2tx_lpf_rc_lut_tx40_11n = 0;
-	uint16 tx_lpf_bw_ofdm_20mhz = 0;
-	uint16 tx_lpf_bw_ofdm_40mhz = 0;
-	uint16 tx_lpf_bw_11b = 0;
-	uint16 ipa2g_mainbias, ipa2g_casconv, ipa2g_biasfilt;
-	uint16 txgm_idac_bleed = 0;
+	u16 regval;
+	u16 afectrl_adc_ctrl1_rev7 = 0x20;
+	u16 afectrl_adc_ctrl2_rev7 = 0x0;
+	u16 rfseq_rx2tx_lpf_h_hpc_rev7 = 0x77;
+	u16 rfseq_tx2rx_lpf_h_hpc_rev7 = 0x77;
+	u16 rfseq_pktgn_lpf_h_hpc_rev7 = 0x77;
+	u16 rfseq_htpktgn_lpf_hpc_rev7[] = { 0x77, 0x11, 0x11 };
+	u16 rfseq_pktgn_lpf_hpc_rev7[] = { 0x11, 0x11 };
+	u16 rfseq_cckpktgn_lpf_hpc_rev7[] = { 0x11, 0x11 };
+	u16 ipalvlshift_3p3_war_en = 0;
+	u16 rccal_bcap_val, rccal_scap_val;
+	u16 rccal_tx20_11b_bcap = 0;
+	u16 rccal_tx20_11b_scap = 0;
+	u16 rccal_tx20_11n_bcap = 0;
+	u16 rccal_tx20_11n_scap = 0;
+	u16 rccal_tx40_11n_bcap = 0;
+	u16 rccal_tx40_11n_scap = 0;
+	u16 rx2tx_lpf_rc_lut_tx20_11b = 0;
+	u16 rx2tx_lpf_rc_lut_tx20_11n = 0;
+	u16 rx2tx_lpf_rc_lut_tx40_11n = 0;
+	u16 tx_lpf_bw_ofdm_20mhz = 0;
+	u16 tx_lpf_bw_ofdm_40mhz = 0;
+	u16 tx_lpf_bw_11b = 0;
+	u16 ipa2g_mainbias, ipa2g_casconv, ipa2g_biasfilt;
+	u16 txgm_idac_bleed = 0;
 	bool rccal_ovrd = FALSE;
-	uint16 freq;
+	u16 freq;
 	int coreNum;
 
 	if (CHSPEC_IS5G(pi->radio_chanspec)) {
@@ -16047,8 +16047,8 @@ static void wlc_phy_workarounds_nphy(phy
 						 0x1c, 16, sk_adc_gain);
 		} else if (pdetrange == 2) {
 
-			uint16 bcm_adc_vmid[] = { 0xa2, 0xb4, 0xb4, 0x74 };
-			uint16 bcm_adc_gain[] = { 0x02, 0x02, 0x02, 0x04 };
+			u16 bcm_adc_vmid[] = { 0xa2, 0xb4, 0xb4, 0x74 };
+			u16 bcm_adc_gain[] = { 0x02, 0x02, 0x02, 0x04 };
 
 			if (NREV_GE(pi->pubpi.phy_rev, 6)) {
 				chan_freq_range =
@@ -16079,9 +16079,9 @@ static void wlc_phy_workarounds_nphy(phy
 			if ((NREV_GE(pi->pubpi.phy_rev, 4))
 			    && (chan_freq_range == WL_CHAN_FREQ_RANGE_2G)) {
 
-				uint16 auxadc_vmid[] = {
+				u16 auxadc_vmid[] = {
 					0xa2, 0xb4, 0xb4, 0x270 };
-				uint16 auxadc_gain[] = {
+				u16 auxadc_gain[] = {
 					0x02, 0x02, 0x02, 0x00 };
 
 				wlc_phy_table_write_nphy(pi,
@@ -16098,9 +16098,9 @@ static void wlc_phy_workarounds_nphy(phy
 							 0x1c, 16, auxadc_gain);
 			}
 		} else if ((pdetrange == 4) || (pdetrange == 5)) {
-			uint16 bcm_adc_vmid[] = { 0xa2, 0xb4, 0xb4, 0x0 };
-			uint16 bcm_adc_gain[] = { 0x02, 0x02, 0x02, 0x0 };
-			uint16 Vmid[2], Av[2];
+			u16 bcm_adc_vmid[] = { 0xa2, 0xb4, 0xb4, 0x0 };
+			u16 bcm_adc_gain[] = { 0x02, 0x02, 0x02, 0x0 };
+			u16 Vmid[2], Av[2];
 
 			chan_freq_range =
 			    wlc_phy_get_chan_freq_range_nphy(pi, 0);
@@ -16348,7 +16348,7 @@ static void wlc_phy_workarounds_nphy(phy
 
 static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t *pi)
 {
-	uint16 w1th, hpf_code, currband;
+	u16 w1th, hpf_code, currband;
 	int ctr;
 	u8 rfseq_updategainu_events[] = {
 		NPHY_RFSEQ_CMD_RX_GAIN,
@@ -16399,62 +16399,62 @@ static void wlc_phy_workarounds_nphy_gai
 	s8 *tia_gainbits;
 	s8 lpf_gain_db[] = { 0x00, 0x06, 0x0c, 0x12, 0x12, 0x12 };
 	s8 lpf_gainbits[] = { 0x00, 0x01, 0x02, 0x03, 0x03, 0x03 };
-	uint16 rfseqG_init_gain[] = { 0x613f, 0x613f, 0x613f, 0x613f };
-	uint16 rfseqG_init_gain_rev4[] = { 0x513f, 0x513f, 0x513f, 0x513f };
-	uint16 rfseqG_init_gain_rev5[] = { 0x413f, 0x413f, 0x413f, 0x413f };
-	uint16 rfseqG_init_gain_rev5_elna[] = {
+	u16 rfseqG_init_gain[] = { 0x613f, 0x613f, 0x613f, 0x613f };
+	u16 rfseqG_init_gain_rev4[] = { 0x513f, 0x513f, 0x513f, 0x513f };
+	u16 rfseqG_init_gain_rev5[] = { 0x413f, 0x413f, 0x413f, 0x413f };
+	u16 rfseqG_init_gain_rev5_elna[] = {
 		0x013f, 0x013f, 0x013f, 0x013f };
-	uint16 rfseqG_init_gain_rev6[] = { 0x513f, 0x513f };
-	uint16 rfseqG_init_gain_rev6_224B0[] = { 0x413f, 0x413f };
-	uint16 rfseqG_init_gain_rev6_elna[] = { 0x113f, 0x113f };
-	uint16 rfseqA_init_gain[] = { 0x516f, 0x516f, 0x516f, 0x516f };
-	uint16 rfseqA_init_gain_rev4[] = { 0x614f, 0x614f, 0x614f, 0x614f };
-	uint16 rfseqA_init_gain_rev4_elna[] = {
+	u16 rfseqG_init_gain_rev6[] = { 0x513f, 0x513f };
+	u16 rfseqG_init_gain_rev6_224B0[] = { 0x413f, 0x413f };
+	u16 rfseqG_init_gain_rev6_elna[] = { 0x113f, 0x113f };
+	u16 rfseqA_init_gain[] = { 0x516f, 0x516f, 0x516f, 0x516f };
+	u16 rfseqA_init_gain_rev4[] = { 0x614f, 0x614f, 0x614f, 0x614f };
+	u16 rfseqA_init_gain_rev4_elna[] = {
 		0x314f, 0x314f, 0x314f, 0x314f };
-	uint16 rfseqA_init_gain_rev5[] = { 0x714f, 0x714f, 0x714f, 0x714f };
-	uint16 rfseqA_init_gain_rev6[] = { 0x714f, 0x714f };
-	uint16 *rfseq_init_gain;
-	uint16 initG_gaincode = 0x627e;
-	uint16 initG_gaincode_rev4 = 0x527e;
-	uint16 initG_gaincode_rev5 = 0x427e;
-	uint16 initG_gaincode_rev5_elna = 0x027e;
-	uint16 initG_gaincode_rev6 = 0x527e;
-	uint16 initG_gaincode_rev6_224B0 = 0x427e;
-	uint16 initG_gaincode_rev6_elna = 0x127e;
-	uint16 initA_gaincode = 0x52de;
-	uint16 initA_gaincode_rev4 = 0x629e;
-	uint16 initA_gaincode_rev4_elna = 0x329e;
-	uint16 initA_gaincode_rev5 = 0x729e;
-	uint16 initA_gaincode_rev6 = 0x729e;
-	uint16 init_gaincode;
-	uint16 clip1hiG_gaincode = 0x107e;
-	uint16 clip1hiG_gaincode_rev4 = 0x007e;
-	uint16 clip1hiG_gaincode_rev5 = 0x1076;
-	uint16 clip1hiG_gaincode_rev6 = 0x007e;
-	uint16 clip1hiA_gaincode = 0x00de;
-	uint16 clip1hiA_gaincode_rev4 = 0x029e;
-	uint16 clip1hiA_gaincode_rev5 = 0x029e;
-	uint16 clip1hiA_gaincode_rev6 = 0x029e;
-	uint16 clip1hi_gaincode;
-	uint16 clip1mdG_gaincode = 0x0066;
-	uint16 clip1mdA_gaincode = 0x00ca;
-	uint16 clip1mdA_gaincode_rev4 = 0x1084;
-	uint16 clip1mdA_gaincode_rev5 = 0x2084;
-	uint16 clip1mdA_gaincode_rev6 = 0x2084;
-	uint16 clip1md_gaincode = 0;
-	uint16 clip1loG_gaincode = 0x0074;
-	uint16 clip1loG_gaincode_rev5[] = {
+	u16 rfseqA_init_gain_rev5[] = { 0x714f, 0x714f, 0x714f, 0x714f };
+	u16 rfseqA_init_gain_rev6[] = { 0x714f, 0x714f };
+	u16 *rfseq_init_gain;
+	u16 initG_gaincode = 0x627e;
+	u16 initG_gaincode_rev4 = 0x527e;
+	u16 initG_gaincode_rev5 = 0x427e;
+	u16 initG_gaincode_rev5_elna = 0x027e;
+	u16 initG_gaincode_rev6 = 0x527e;
+	u16 initG_gaincode_rev6_224B0 = 0x427e;
+	u16 initG_gaincode_rev6_elna = 0x127e;
+	u16 initA_gaincode = 0x52de;
+	u16 initA_gaincode_rev4 = 0x629e;
+	u16 initA_gaincode_rev4_elna = 0x329e;
+	u16 initA_gaincode_rev5 = 0x729e;
+	u16 initA_gaincode_rev6 = 0x729e;
+	u16 init_gaincode;
+	u16 clip1hiG_gaincode = 0x107e;
+	u16 clip1hiG_gaincode_rev4 = 0x007e;
+	u16 clip1hiG_gaincode_rev5 = 0x1076;
+	u16 clip1hiG_gaincode_rev6 = 0x007e;
+	u16 clip1hiA_gaincode = 0x00de;
+	u16 clip1hiA_gaincode_rev4 = 0x029e;
+	u16 clip1hiA_gaincode_rev5 = 0x029e;
+	u16 clip1hiA_gaincode_rev6 = 0x029e;
+	u16 clip1hi_gaincode;
+	u16 clip1mdG_gaincode = 0x0066;
+	u16 clip1mdA_gaincode = 0x00ca;
+	u16 clip1mdA_gaincode_rev4 = 0x1084;
+	u16 clip1mdA_gaincode_rev5 = 0x2084;
+	u16 clip1mdA_gaincode_rev6 = 0x2084;
+	u16 clip1md_gaincode = 0;
+	u16 clip1loG_gaincode = 0x0074;
+	u16 clip1loG_gaincode_rev5[] = {
 		0x0062, 0x0064, 0x006a, 0x106a, 0x106c, 0x1074, 0x107c, 0x207c
 	};
-	uint16 clip1loG_gaincode_rev6[] = {
+	u16 clip1loG_gaincode_rev6[] = {
 		0x106a, 0x106c, 0x1074, 0x107c, 0x007e, 0x107e, 0x207e, 0x307e
 	};
-	uint16 clip1loG_gaincode_rev6_224B0 = 0x1074;
-	uint16 clip1loA_gaincode = 0x00cc;
-	uint16 clip1loA_gaincode_rev4 = 0x0086;
-	uint16 clip1loA_gaincode_rev5 = 0x2086;
-	uint16 clip1loA_gaincode_rev6 = 0x2086;
-	uint16 clip1lo_gaincode;
+	u16 clip1loG_gaincode_rev6_224B0 = 0x1074;
+	u16 clip1loA_gaincode = 0x00cc;
+	u16 clip1loA_gaincode_rev4 = 0x0086;
+	u16 clip1loA_gaincode_rev5 = 0x2086;
+	u16 clip1loA_gaincode_rev6 = 0x2086;
+	u16 clip1lo_gaincode;
 	u8 crsminG_th = 0x18;
 	u8 crsminG_th_rev5 = 0x18;
 	u8 crsminG_th_rev6 = 0x18;
@@ -16480,15 +16480,15 @@ static void wlc_phy_workarounds_nphy_gai
 	u8 crsminuA_th_rev6 = 0x24;
 	u8 crsminuA_th_rev6_224B0 = 0x2d;
 	u8 crsminu_th;
-	uint16 nbclipG_th = 0x20d;
-	uint16 nbclipG_th_rev4 = 0x1a1;
-	uint16 nbclipG_th_rev5 = 0x1d0;
-	uint16 nbclipG_th_rev6 = 0x1d0;
-	uint16 nbclipA_th = 0x1a1;
-	uint16 nbclipA_th_rev4 = 0x107;
-	uint16 nbclipA_th_rev5 = 0x0a9;
-	uint16 nbclipA_th_rev6 = 0x0f0;
-	uint16 nbclip_th = 0;
+	u16 nbclipG_th = 0x20d;
+	u16 nbclipG_th_rev4 = 0x1a1;
+	u16 nbclipG_th_rev5 = 0x1d0;
+	u16 nbclipG_th_rev6 = 0x1d0;
+	u16 nbclipA_th = 0x1a1;
+	u16 nbclipA_th_rev4 = 0x107;
+	u16 nbclipA_th_rev5 = 0x0a9;
+	u16 nbclipA_th_rev6 = 0x0f0;
+	u16 nbclip_th = 0;
 	u8 w1clipG_th = 5;
 	u8 w1clipG_th_rev5 = 9;
 	u8 w1clipG_th_rev6 = 5;
@@ -16498,7 +16498,7 @@ static void wlc_phy_workarounds_nphy_gai
 	u8 rssiA_gain_rev5 = 0x90;
 	u8 rssiA_gain_rev6 = 0x90;
 	u8 rssi_gain;
-	uint16 regval[21];
+	u16 regval[21];
 	u8 triso;
 
 	triso = (CHSPEC_IS5G(pi->radio_chanspec)) ? pi->srom_fem5g.triso :
@@ -16945,7 +16945,7 @@ static void wlc_phy_workarounds_nphy_gai
 			wlc_phy_table_write_nphy(pi, 1, 21, 32, 16, regval);
 
 			for (ctr = 0; ctr < 21; ctr++) {
-				regval[ctr] = (uint16) ctr;
+				regval[ctr] = (u16) ctr;
 			}
 			wlc_phy_table_write_nphy(pi, 2, 21, 32, 16, regval);
 			wlc_phy_table_write_nphy(pi, 3, 21, 32, 16, regval);
@@ -17023,7 +17023,7 @@ static void wlc_phy_workarounds_nphy_gai
 
 static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t *pi)
 {
-	uint16 currband;
+	u16 currband;
 	s8 lna1G_gain_db_rev7[] = { 9, 14, 19, 24 };
 	s8 *lna1_gain_db = NULL;
 	s8 *lna1_gain_db_2 = NULL;
@@ -17032,19 +17032,19 @@ static void wlc_phy_workarounds_nphy_gai
 	s8 *tia_gain_db;
 	s8 tiaA_gainbits_rev7[] = { 0, 1, 2, 3, 4, 4, 4, 4, 4, 4 };
 	s8 *tia_gainbits;
-	uint16 rfseqA_init_gain_rev7[] = { 0x624f, 0x624f };
-	uint16 *rfseq_init_gain;
-	uint16 init_gaincode;
-	uint16 clip1hi_gaincode;
-	uint16 clip1md_gaincode = 0;
-	uint16 clip1md_gaincode_B;
-	uint16 clip1lo_gaincode;
-	uint16 clip1lo_gaincode_B;
+	u16 rfseqA_init_gain_rev7[] = { 0x624f, 0x624f };
+	u16 *rfseq_init_gain;
+	u16 init_gaincode;
+	u16 clip1hi_gaincode;
+	u16 clip1md_gaincode = 0;
+	u16 clip1md_gaincode_B;
+	u16 clip1lo_gaincode;
+	u16 clip1lo_gaincode_B;
 	u8 crsminl_th = 0;
 	u8 crsminu_th;
-	uint16 nbclip_th = 0;
+	u16 nbclip_th = 0;
 	u8 w1clip_th;
-	uint16 freq;
+	u16 freq;
 	s8 nvar_baseline_offset0 = 0, nvar_baseline_offset1 = 0;
 	u8 chg_nbclip_th = 0;
 
@@ -17233,8 +17233,8 @@ static void wlc_phy_adjust_lnagaintbl_np
 	int ctr;
 	int16 gain_delta[2];
 	u8 curr_channel;
-	uint16 minmax_gain[2];
-	uint16 regval[4];
+	u16 minmax_gain[2];
+	u16 regval[4];
 
 	if (pi->phyhang_avoid)
 		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
@@ -17280,7 +17280,7 @@ static void wlc_phy_adjust_lnagaintbl_np
 		wlc_phy_table_write_nphy(pi, core, 4, 8, 16, regval);
 
 		minmax_gain[core] =
-		    (uint16) (nphy_def_lnagains[2] + gain_delta[core] + 4);
+		    (u16) (nphy_def_lnagains[2] + gain_delta[core] + 4);
 	}
 
 	mod_phy_reg(pi, 0x1e, (0xff << 0), (minmax_gain[0] << 0));
@@ -17514,15 +17514,15 @@ static void wlc_phy_radio_init_2056(phy_
 		}
 	}
 
-	wlc_phy_init_radio_regs(pi, regs_SYN_2056_ptr, (uint16) RADIO_2056_SYN);
+	wlc_phy_init_radio_regs(pi, regs_SYN_2056_ptr, (u16) RADIO_2056_SYN);
 
-	wlc_phy_init_radio_regs(pi, regs_TX_2056_ptr, (uint16) RADIO_2056_TX0);
+	wlc_phy_init_radio_regs(pi, regs_TX_2056_ptr, (u16) RADIO_2056_TX0);
 
-	wlc_phy_init_radio_regs(pi, regs_TX_2056_ptr, (uint16) RADIO_2056_TX1);
+	wlc_phy_init_radio_regs(pi, regs_TX_2056_ptr, (u16) RADIO_2056_TX1);
 
-	wlc_phy_init_radio_regs(pi, regs_RX_2056_ptr, (uint16) RADIO_2056_RX0);
+	wlc_phy_init_radio_regs(pi, regs_RX_2056_ptr, (u16) RADIO_2056_RX0);
 
-	wlc_phy_init_radio_regs(pi, regs_RX_2056_ptr, (uint16) RADIO_2056_RX1);
+	wlc_phy_init_radio_regs(pi, regs_RX_2056_ptr, (u16) RADIO_2056_RX1);
 }
 
 static void wlc_phy_radio_postinit_2056(phy_info_t *pi)
@@ -17994,11 +17994,11 @@ wlc_phy_chanspec_radio2056_setup(phy_inf
 	if (CHSPEC_IS2G(pi->radio_chanspec)) {
 		write_radio_reg(pi, RADIO_2056_SYN_PLL_CP2 |
 				RADIO_2056_SYN,
-				(uint16) regs_SYN_2056_ptr[0x49 - 2].init_g);
+				(u16) regs_SYN_2056_ptr[0x49 - 2].init_g);
 	} else {
 		write_radio_reg(pi, RADIO_2056_SYN_PLL_CP2 |
 				RADIO_2056_SYN,
-				(uint16) regs_SYN_2056_ptr[0x49 - 2].init_a);
+				(u16) regs_SYN_2056_ptr[0x49 - 2].init_a);
 	}
 
 	if (pi->sh->boardflags2 & BFL2_GPLL_WAR) {
@@ -18057,11 +18057,11 @@ wlc_phy_chanspec_radio2056_setup(phy_inf
 	}
 
 	if (PHY_IPA(pi) && CHSPEC_IS2G(pi->radio_chanspec)) {
-		uint16 pag_boost_tune;
-		uint16 padg_boost_tune;
-		uint16 pgag_boost_tune;
-		uint16 mixg_boost_tune;
-		uint16 bias, cascbias;
+		u16 pag_boost_tune;
+		u16 padg_boost_tune;
+		u16 pgag_boost_tune;
+		u16 mixg_boost_tune;
+		u16 bias, cascbias;
 		uint core;
 
 		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
@@ -18140,11 +18140,11 @@ wlc_phy_chanspec_radio2056_setup(phy_inf
 
 	if (PHY_IPA(pi) && NREV_IS(pi->pubpi.phy_rev, 6)
 	    && CHSPEC_IS5G(pi->radio_chanspec)) {
-		uint16 paa_boost_tune;
-		uint16 pada_boost_tune;
-		uint16 pgaa_boost_tune;
-		uint16 mixa_boost_tune;
-		uint16 freq, pabias, cascbias;
+		u16 paa_boost_tune;
+		u16 pada_boost_tune;
+		u16 pgaa_boost_tune;
+		u16 mixa_boost_tune;
+		u16 freq, pabias, cascbias;
 		uint core;
 
 		freq = CHAN5G_FREQ(CHSPEC_CHANNEL(pi->radio_chanspec));
@@ -18244,9 +18244,9 @@ void wlc_phy_radio205x_vcocal_nphy(phy_i
 
 #define MAX_205x_RCAL_WAITLOOPS 10000
 
-static uint16 wlc_phy_radio205x_rcal(phy_info_t *pi)
+static u16 wlc_phy_radio205x_rcal(phy_info_t *pi)
 {
-	uint16 rcal_reg = 0;
+	u16 rcal_reg = 0;
 	int i;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -18298,7 +18298,7 @@ static uint16 wlc_phy_radio205x_rcal(phy
 		}
 
 	} else if (NREV_IS(pi->pubpi.phy_rev, 3)) {
-		uint16 savereg;
+		u16 savereg;
 
 		savereg =
 		    read_radio_reg(pi,
@@ -18351,8 +18351,8 @@ wlc_phy_chanspec_radio2057_setup(phy_inf
 				 const chan_info_nphy_radio2057_rev5_t *ci2)
 {
 	int coreNum;
-	uint16 txmix2g_tune_boost_pu = 0;
-	uint16 pad2g_tune_pus = 0;
+	u16 txmix2g_tune_boost_pu = 0;
+	u16 pad2g_tune_pus = 0;
 
 	if (pi->pubpi.radiorev == 5) {
 
@@ -18541,9 +18541,9 @@ wlc_phy_chanspec_radio2057_setup(phy_inf
 	wlc_phy_radio205x_vcocal_nphy(pi);
 }
 
-static uint16 wlc_phy_radio2057_rccal(phy_info_t *pi)
+static u16 wlc_phy_radio2057_rccal(phy_info_t *pi)
 {
-	uint16 rccal_valid;
+	u16 rccal_valid;
 	int i;
 	bool chip43226_6362A0;
 
@@ -18628,7 +18628,7 @@ static uint16 wlc_phy_radio2057_rccal(ph
 }
 
 static void
-wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t *pi, uint16 reduction_factr)
+wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t *pi, u16 reduction_factr)
 {
 	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 7)) {
 		if ((CHSPEC_CHANNEL(pi->radio_chanspec) == 11) &&
@@ -18707,7 +18707,7 @@ wlc_phy_adjust_min_noisevar_nphy(phy_inf
 
 static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t *pi, u8 minpwr)
 {
-	uint16 regval;
+	u16 regval;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		if ((CHSPEC_CHANNEL(pi->radio_chanspec) == 11) &&
@@ -18716,19 +18716,19 @@ static void wlc_phy_adjust_crsminpwr_nph
 				regval = read_phy_reg(pi, 0x27d);
 				pi->nphy_crsminpwr[0] = regval & 0xff;
 				regval &= 0xff00;
-				regval |= (uint16) minpwr;
+				regval |= (u16) minpwr;
 				write_phy_reg(pi, 0x27d, regval);
 
 				regval = read_phy_reg(pi, 0x280);
 				pi->nphy_crsminpwr[1] = regval & 0xff;
 				regval &= 0xff00;
-				regval |= (uint16) minpwr;
+				regval |= (u16) minpwr;
 				write_phy_reg(pi, 0x280, regval);
 
 				regval = read_phy_reg(pi, 0x283);
 				pi->nphy_crsminpwr[2] = regval & 0xff;
 				regval &= 0xff00;
-				regval |= (uint16) minpwr;
+				regval |= (u16) minpwr;
 				write_phy_reg(pi, 0x283, regval);
 
 				pi->nphy_crsminpwr_adjusted = TRUE;
@@ -18797,7 +18797,7 @@ static void wlc_phy_txlpfbw_nphy(phy_inf
 
 static void wlc_phy_spurwar_nphy(phy_info_t *pi)
 {
-	uint16 cur_channel = 0;
+	u16 cur_channel = 0;
 	int nphy_adj_tone_id_buf[] = { 57, 58 };
 	uint32 nphy_adj_noise_var_buf[] = { 0x3ff, 0x3ff };
 	bool isAdjustNoiseVar = FALSE;
@@ -18976,7 +18976,7 @@ static void
 wlc_phy_chanspec_nphy_setup(phy_info_t *pi, chanspec_t chanspec,
 			    const nphy_sfo_cfg_t *ci)
 {
-	uint16 val;
+	u16 val;
 
 	val = read_phy_reg(pi, 0x09) & NPHY_BandControl_currentBand;
 	if (CHSPEC_IS5G(chanspec) && !val) {
@@ -19000,7 +19000,7 @@ wlc_phy_chanspec_nphy_setup(phy_info_t *
 		      (val | MAC_PHY_FORCE_CLK));
 
 		and_phy_reg(pi, (NPHY_TO_BPHY_OFF + BPHY_BB_CONFIG),
-			    (uint16) (~(BBCFG_RESETCCA | BBCFG_RESETRX)));
+			    (u16) (~(BBCFG_RESETCCA | BBCFG_RESETRX)));
 
 		W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, val);
 	}
@@ -19216,7 +19216,7 @@ static void wlc_phy_savecal_nphy(phy_inf
 {
 	void *tbl_ptr;
 	int coreNum;
-	uint16 *txcal_radio_regs = NULL;
+	u16 *txcal_radio_regs = NULL;
 
 	if (pi->phyhang_avoid)
 		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
@@ -19363,11 +19363,11 @@ static void wlc_phy_savecal_nphy(phy_inf
 
 static void wlc_phy_restorecal_nphy(phy_info_t *pi)
 {
-	uint16 *loft_comp;
-	uint16 txcal_coeffs_bphy[4];
-	uint16 *tbl_ptr;
+	u16 *loft_comp;
+	u16 txcal_coeffs_bphy[4];
+	u16 *tbl_ptr;
 	int coreNum;
-	uint16 *txcal_radio_regs = NULL;
+	u16 *txcal_radio_regs = NULL;
 
 	if (CHSPEC_IS2G(pi->radio_chanspec)) {
 		if (pi->nphy_iqcal_chanspec_2G == 0)
@@ -19563,14 +19563,14 @@ static void wlc_phy_restorecal_nphy(phy_
 void wlc_phy_antsel_init(wlc_phy_t *ppi, bool lut_init)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
-	uint16 mask = 0xfc00;
+	u16 mask = 0xfc00;
 	uint32 mc = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7))
 		return;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
-		uint16 v0 = 0x211, v1 = 0x222, v2 = 0x144, v3 = 0x188;
+		u16 v0 = 0x211, v1 = 0x222, v2 = 0x144, v3 = 0x188;
 
 		if (lut_init == FALSE)
 			return;
@@ -19624,9 +19624,9 @@ void wlc_phy_antsel_init(wlc_phy_t *ppi,
 	}
 }
 
-uint16 wlc_phy_classifier_nphy(phy_info_t *pi, uint16 mask, uint16 val)
+u16 wlc_phy_classifier_nphy(phy_info_t *pi, u16 mask, u16 val)
 {
-	uint16 curr_ctl, new_ctl;
+	u16 curr_ctl, new_ctl;
 	bool suspended = FALSE;
 
 	if (D11REV_IS(pi->sh->corerev, 16)) {
@@ -19649,7 +19649,7 @@ uint16 wlc_phy_classifier_nphy(phy_info_
 	return new_ctl;
 }
 
-static void wlc_phy_clip_det_nphy(phy_info_t *pi, u8 write, uint16 *vals)
+static void wlc_phy_clip_det_nphy(phy_info_t *pi, u8 write, u16 *vals)
 {
 
 	if (write == 0) {
@@ -19663,8 +19663,8 @@ static void wlc_phy_clip_det_nphy(phy_in
 
 void wlc_phy_force_rfseq_nphy(phy_info_t *pi, u8 cmd)
 {
-	uint16 trigger_mask, status_mask;
-	uint16 orig_RfseqCoreActv;
+	u16 trigger_mask, status_mask;
+	u16 orig_RfseqCoreActv;
 
 	switch (cmd) {
 	case NPHY_RFSEQ_RX2TX:
@@ -19740,10 +19740,10 @@ wlc_phy_set_rfseq_nphy(phy_info_t *pi, u
 		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
 }
 
-static uint16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t *pi, uint16 offset)
+static u16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t *pi, u16 offset)
 {
-	uint16 lpf_bw_ctl_val = 0;
-	uint16 rx2tx_lpf_rc_lut_offset = 0;
+	u16 lpf_bw_ctl_val = 0;
+	u16 rx2tx_lpf_rc_lut_offset = 0;
 
 	if (offset == 0) {
 		if (CHSPEC_IS40(pi->radio_chanspec)) {
@@ -19764,11 +19764,11 @@ static uint16 wlc_phy_read_lpf_bw_ctl_np
 }
 
 static void
-wlc_phy_rfctrl_override_nphy_rev7(phy_info_t *pi, uint16 field, uint16 value,
+wlc_phy_rfctrl_override_nphy_rev7(phy_info_t *pi, u16 field, u16 value,
 				  u8 core_mask, u8 off, u8 override_id)
 {
 	u8 core_num;
-	uint16 addr = 0, en_addr = 0, val_addr = 0, en_mask = 0, val_mask = 0;
+	u16 addr = 0, en_addr = 0, val_addr = 0, en_mask = 0, val_mask = 0;
 	u8 val_shift = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -20034,11 +20034,11 @@ wlc_phy_rfctrl_override_nphy_rev7(phy_in
 }
 
 static void
-wlc_phy_rfctrl_override_nphy(phy_info_t *pi, uint16 field, uint16 value,
+wlc_phy_rfctrl_override_nphy(phy_info_t *pi, u16 field, u16 value,
 			     u8 core_mask, u8 off)
 {
 	u8 core_num;
-	uint16 addr = 0, mask = 0, en_addr = 0, val_addr = 0, en_mask =
+	u16 addr = 0, mask = 0, en_addr = 0, val_addr = 0, en_mask =
 	    0, val_mask = 0;
 	u8 shift = 0, val_shift = 0;
 
@@ -20280,11 +20280,11 @@ wlc_phy_rfctrl_override_nphy(phy_info_t
 }
 
 static void
-wlc_phy_rfctrl_override_1tomany_nphy(phy_info_t *pi, uint16 cmd, uint16 value,
+wlc_phy_rfctrl_override_1tomany_nphy(phy_info_t *pi, u16 cmd, u16 value,
 				     u8 core_mask, u8 off)
 {
-	uint16 rfmxgain = 0, lpfgain = 0;
-	uint16 tgain = 0;
+	u16 rfmxgain = 0, lpfgain = 0;
+	u16 tgain = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -20366,10 +20366,10 @@ wlc_phy_rfctrl_override_1tomany_nphy(phy
 }
 
 static void
-wlc_phy_scale_offset_rssi_nphy(phy_info_t *pi, uint16 scale, s8 offset,
+wlc_phy_scale_offset_rssi_nphy(phy_info_t *pi, u16 scale, s8 offset,
 			       u8 coresel, u8 rail, u8 rssi_type)
 {
-	uint16 valuetostuff;
+	u16 valuetostuff;
 
 	offset = (offset > NPHY_RSSICAL_MAXREAD) ?
 	    NPHY_RSSICAL_MAXREAD : offset;
@@ -20508,13 +20508,13 @@ wlc_phy_scale_offset_rssi_nphy(phy_info_
 
 void wlc_phy_rssisel_nphy(phy_info_t *pi, u8 core_code, u8 rssi_type)
 {
-	uint16 mask, val;
-	uint16 afectrlovr_rssi_val, rfctrlcmd_rxen_val, rfctrlcmd_coresel_val,
+	u16 mask, val;
+	u16 afectrlovr_rssi_val, rfctrlcmd_rxen_val, rfctrlcmd_coresel_val,
 	    startseq;
-	uint16 rfctrlovr_rssi_val, rfctrlovr_rxen_val, rfctrlovr_coresel_val,
+	u16 rfctrlovr_rssi_val, rfctrlovr_rxen_val, rfctrlovr_coresel_val,
 	    rfctrlovr_trigger_val;
-	uint16 afectrlovr_rssi_mask, rfctrlcmd_mask, rfctrlovr_mask;
-	uint16 rfctrlcmd_val, rfctrlovr_val;
+	u16 afectrlovr_rssi_mask, rfctrlcmd_mask, rfctrlovr_mask;
+	u16 rfctrlcmd_val, rfctrlovr_val;
 	u8 core;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
@@ -20814,22 +20814,22 @@ wlc_phy_poll_rssi_nphy(phy_info_t *pi, u
 		       u8 nsamps)
 {
 	int16 rssi0, rssi1;
-	uint16 afectrlCore1_save = 0;
-	uint16 afectrlCore2_save = 0;
-	uint16 afectrlOverride1_save = 0;
-	uint16 afectrlOverride2_save = 0;
-	uint16 rfctrlOverrideAux0_save = 0;
-	uint16 rfctrlOverrideAux1_save = 0;
-	uint16 rfctrlMiscReg1_save = 0;
-	uint16 rfctrlMiscReg2_save = 0;
-	uint16 rfctrlcmd_save = 0;
-	uint16 rfctrloverride_save = 0;
-	uint16 rfctrlrssiothers1_save = 0;
-	uint16 rfctrlrssiothers2_save = 0;
+	u16 afectrlCore1_save = 0;
+	u16 afectrlCore2_save = 0;
+	u16 afectrlOverride1_save = 0;
+	u16 afectrlOverride2_save = 0;
+	u16 rfctrlOverrideAux0_save = 0;
+	u16 rfctrlOverrideAux1_save = 0;
+	u16 rfctrlMiscReg1_save = 0;
+	u16 rfctrlMiscReg2_save = 0;
+	u16 rfctrlcmd_save = 0;
+	u16 rfctrloverride_save = 0;
+	u16 rfctrlrssiothers1_save = 0;
+	u16 rfctrlrssiothers2_save = 0;
 	s8 tmp_buf[4];
 	u8 ctr = 0, samp = 0;
 	int32 rssi_out_val;
-	uint16 gpiosel_orig;
+	u16 gpiosel_orig;
 
 	afectrlCore1_save = read_phy_reg(pi, 0xa6);
 	afectrlCore2_save = read_phy_reg(pi, 0xa7);
@@ -20911,30 +20911,30 @@ wlc_phy_poll_rssi_nphy(phy_info_t *pi, u
 
 int16 wlc_phy_tempsense_nphy(phy_info_t *pi)
 {
-	uint16 core1_txrf_iqcal1_save, core1_txrf_iqcal2_save;
-	uint16 core2_txrf_iqcal1_save, core2_txrf_iqcal2_save;
-	uint16 pwrdet_rxtx_core1_save;
-	uint16 pwrdet_rxtx_core2_save;
-	uint16 afectrlCore1_save;
-	uint16 afectrlCore2_save;
-	uint16 afectrlOverride_save;
-	uint16 afectrlOverride2_save;
-	uint16 pd_pll_ts_save;
-	uint16 gpioSel_save;
+	u16 core1_txrf_iqcal1_save, core1_txrf_iqcal2_save;
+	u16 core2_txrf_iqcal1_save, core2_txrf_iqcal2_save;
+	u16 pwrdet_rxtx_core1_save;
+	u16 pwrdet_rxtx_core2_save;
+	u16 afectrlCore1_save;
+	u16 afectrlCore2_save;
+	u16 afectrlOverride_save;
+	u16 afectrlOverride2_save;
+	u16 pd_pll_ts_save;
+	u16 gpioSel_save;
 	int32 radio_temp[4];
 	int32 radio_temp2[4];
-	uint16 syn_tempprocsense_save;
+	u16 syn_tempprocsense_save;
 	int16 offset = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
-		uint16 auxADC_Vmid, auxADC_Av, auxADC_Vmid_save, auxADC_Av_save;
-		uint16 auxADC_rssi_ctrlL_save, auxADC_rssi_ctrlH_save;
-		uint16 auxADC_rssi_ctrlL, auxADC_rssi_ctrlH;
+		u16 auxADC_Vmid, auxADC_Av, auxADC_Vmid_save, auxADC_Av_save;
+		u16 auxADC_rssi_ctrlL_save, auxADC_rssi_ctrlH_save;
+		u16 auxADC_rssi_ctrlL, auxADC_rssi_ctrlH;
 		int32 auxADC_Vl;
-		uint16 RfctrlOverride5_save, RfctrlOverride6_save;
-		uint16 RfctrlMiscReg5_save, RfctrlMiscReg6_save;
-		uint16 RSSIMultCoef0QPowerDet_save;
-		uint16 tempsense_Rcal;
+		u16 RfctrlOverride5_save, RfctrlOverride6_save;
+		u16 RfctrlMiscReg5_save, RfctrlMiscReg6_save;
+		u16 RSSIMultCoef0QPowerDet_save;
+		u16 tempsense_Rcal;
 
 		syn_tempprocsense_save =
 		    read_radio_reg(pi, RADIO_2057_TEMPSENSE_CONFIG);
@@ -21262,13 +21262,13 @@ void wlc_phy_rssi_cal_nphy(phy_info_t *p
 static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t *pi, u8 rssi_type)
 {
 	int32 target_code;
-	uint16 classif_state;
-	uint16 clip_state[2];
-	uint16 rssi_ctrl_state[2], pd_state[2];
-	uint16 rfctrlintc_state[2], rfpdcorerxtx_state[2];
-	uint16 rfctrlintc_override_val;
-	uint16 clip_off[] = { 0xffff, 0xffff };
-	uint16 rf_pd_val, pd_mask, rssi_ctrl_mask;
+	u16 classif_state;
+	u16 clip_state[2];
+	u16 rssi_ctrl_state[2], pd_state[2];
+	u16 rfctrlintc_state[2], rfpdcorerxtx_state[2];
+	u16 rfctrlintc_override_val;
+	u16 clip_off[] = { 0xffff, 0xffff };
+	u16 rf_pd_val, pd_mask, rssi_ctrl_mask;
 	u8 vcm, min_vcm, vcm_tmp[4];
 	u8 vcm_final[4] = { 0, 0, 0, 0 };
 	u8 result_idx, ctr;
@@ -21509,11 +21509,11 @@ wlc_phy_rssi_compute_nphy(phy_info_t *pi
 }
 
 static void
-wlc_phy_rfctrlintc_override_nphy(phy_info_t *pi, u8 field, uint16 value,
+wlc_phy_rfctrlintc_override_nphy(phy_info_t *pi, u8 field, u16 value,
 				 u8 core_code)
 {
-	uint16 mask;
-	uint16 val;
+	u16 mask;
+	u16 val;
 	u8 core;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
@@ -21557,7 +21557,7 @@ wlc_phy_rfctrlintc_override_nphy(phy_inf
 						    PHY_CORE_0) ? 0x91 : 0x92,
 						   (0x1 << 10));
 
-					and_phy_reg(pi, 0x2ff, (uint16)
+					and_phy_reg(pi, 0x2ff, (u16)
 						    ~(0x3 << 14));
 					or_phy_reg(pi, 0x2ff, (0x1 << 13));
 					or_phy_reg(pi, 0x2ff, (0x1 << 0));
@@ -21745,9 +21745,9 @@ wlc_phy_rfctrlintc_override_nphy(phy_inf
 
 static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t *pi)
 {
-	uint16 classif_state;
-	uint16 clip_state[2];
-	uint16 clip_off[] = { 0xffff, 0xffff };
+	u16 classif_state;
+	u16 clip_state[2];
+	u16 clip_off[] = { 0xffff, 0xffff };
 	int32 target_code;
 	u8 vcm, min_vcm;
 	u8 vcm_final = 0;
@@ -21771,19 +21771,19 @@ static void wlc_phy_rssi_cal_nphy_rev3(p
 	u8 core;
 	u8 wb_cnt;
 	u8 rssi_type;
-	uint16 NPHY_Rfctrlintc1_save, NPHY_Rfctrlintc2_save;
-	uint16 NPHY_AfectrlOverride1_save, NPHY_AfectrlOverride2_save;
-	uint16 NPHY_AfectrlCore1_save, NPHY_AfectrlCore2_save;
-	uint16 NPHY_RfctrlOverride0_save, NPHY_RfctrlOverride1_save;
-	uint16 NPHY_RfctrlOverrideAux0_save, NPHY_RfctrlOverrideAux1_save;
-	uint16 NPHY_RfctrlCmd_save;
-	uint16 NPHY_RfctrlMiscReg1_save, NPHY_RfctrlMiscReg2_save;
-	uint16 NPHY_RfctrlRSSIOTHERS1_save, NPHY_RfctrlRSSIOTHERS2_save;
+	u16 NPHY_Rfctrlintc1_save, NPHY_Rfctrlintc2_save;
+	u16 NPHY_AfectrlOverride1_save, NPHY_AfectrlOverride2_save;
+	u16 NPHY_AfectrlCore1_save, NPHY_AfectrlCore2_save;
+	u16 NPHY_RfctrlOverride0_save, NPHY_RfctrlOverride1_save;
+	u16 NPHY_RfctrlOverrideAux0_save, NPHY_RfctrlOverrideAux1_save;
+	u16 NPHY_RfctrlCmd_save;
+	u16 NPHY_RfctrlMiscReg1_save, NPHY_RfctrlMiscReg2_save;
+	u16 NPHY_RfctrlRSSIOTHERS1_save, NPHY_RfctrlRSSIOTHERS2_save;
 	u8 rxcore_state;
-	uint16 NPHY_REV7_RfctrlOverride3_save, NPHY_REV7_RfctrlOverride4_save;
-	uint16 NPHY_REV7_RfctrlOverride5_save, NPHY_REV7_RfctrlOverride6_save;
-	uint16 NPHY_REV7_RfctrlMiscReg3_save, NPHY_REV7_RfctrlMiscReg4_save;
-	uint16 NPHY_REV7_RfctrlMiscReg5_save, NPHY_REV7_RfctrlMiscReg6_save;
+	u16 NPHY_REV7_RfctrlOverride3_save, NPHY_REV7_RfctrlOverride4_save;
+	u16 NPHY_REV7_RfctrlOverride5_save, NPHY_REV7_RfctrlOverride6_save;
+	u16 NPHY_REV7_RfctrlMiscReg3_save, NPHY_REV7_RfctrlMiscReg4_save;
+	u16 NPHY_REV7_RfctrlMiscReg5_save, NPHY_REV7_RfctrlMiscReg6_save;
 
 	NPHY_REV7_RfctrlOverride3_save = NPHY_REV7_RfctrlOverride4_save =
 	    NPHY_REV7_RfctrlOverride5_save = NPHY_REV7_RfctrlOverride6_save =
@@ -22338,12 +22338,12 @@ static void wlc_phy_restore_rssical_nphy
 	}
 }
 
-static uint16
-wlc_phy_gen_load_samples_nphy(phy_info_t *pi, uint32 f_kHz, uint16 max_val,
+static u16
+wlc_phy_gen_load_samples_nphy(phy_info_t *pi, uint32 f_kHz, u16 max_val,
 			      u8 dac_test_mode)
 {
 	u8 phy_bw, is_phybw40;
-	uint16 num_samps, t, spur;
+	u16 num_samps, t, spur;
 	fixed theta = 0, rot = 0;
 	uint32 tbl_len;
 	cint32 *tone_buf = NULL;
@@ -22366,7 +22366,7 @@ wlc_phy_gen_load_samples_nphy(phy_info_t
 		return 0;
 	}
 
-	num_samps = (uint16) tbl_len;
+	num_samps = (u16) tbl_len;
 	rot = FIXED((f_kHz * 36) / phy_bw) / 100;
 	theta = 0;
 
@@ -22389,12 +22389,12 @@ wlc_phy_gen_load_samples_nphy(phy_info_t
 }
 
 int
-wlc_phy_tx_tone_nphy(phy_info_t *pi, uint32 f_kHz, uint16 max_val,
+wlc_phy_tx_tone_nphy(phy_info_t *pi, uint32 f_kHz, u16 max_val,
 		     u8 iqmode, u8 dac_test_mode, bool modify_bbmult)
 {
-	uint16 num_samps;
-	uint16 loops = 0xffff;
-	uint16 wait = 0;
+	u16 num_samps;
+	u16 loops = 0xffff;
+	u16 wait = 0;
 
 	num_samps =
 		wlc_phy_gen_load_samples_nphy(pi, f_kHz, max_val, dac_test_mode);
@@ -22410,9 +22410,9 @@ wlc_phy_tx_tone_nphy(phy_info_t *pi, uin
 
 static void
 wlc_phy_loadsampletable_nphy(phy_info_t *pi, cint32 *tone_buf,
-			     uint16 num_samps)
+			     u16 num_samps)
 {
-	uint16 t;
+	u16 t;
 	uint32 *data_buf = NULL;
 
 	data_buf = (uint32 *) MALLOC(pi->sh->osh, sizeof(uint32) * num_samps);
@@ -22438,14 +22438,14 @@ wlc_phy_loadsampletable_nphy(phy_info_t
 }
 
 static void
-wlc_phy_runsamples_nphy(phy_info_t *pi, uint16 num_samps, uint16 loops,
-			uint16 wait, u8 iqmode, u8 dac_test_mode,
+wlc_phy_runsamples_nphy(phy_info_t *pi, u16 num_samps, u16 loops,
+			u16 wait, u8 iqmode, u8 dac_test_mode,
 			bool modify_bbmult)
 {
-	uint16 bb_mult;
+	u16 bb_mult;
 	u8 phy_bw, sample_cmd;
-	uint16 orig_RfseqCoreActv;
-	uint16 lpf_bw_ctl_override3, lpf_bw_ctl_override4, lpf_bw_ctl_miscreg3,
+	u16 orig_RfseqCoreActv;
+	u16 lpf_bw_ctl_override3, lpf_bw_ctl_override4, lpf_bw_ctl_miscreg3,
 	    lpf_bw_ctl_miscreg4;
 
 	if (pi->phyhang_avoid)
@@ -22527,8 +22527,8 @@ wlc_phy_runsamples_nphy(phy_info_t *pi,
 
 void wlc_phy_stopplayback_nphy(phy_info_t *pi)
 {
-	uint16 playback_status;
-	uint16 bb_mult;
+	u16 playback_status;
+	u16 bb_mult;
 
 	if (pi->phyhang_avoid)
 		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
@@ -22539,10 +22539,10 @@ void wlc_phy_stopplayback_nphy(phy_info_
 	} else if (playback_status & 0x2) {
 
 		and_phy_reg(pi, 0xc2,
-			    (uint16) ~NPHY_iqloCalCmdGctl_IQLO_CAL_EN);
+			    (u16) ~NPHY_iqloCalCmdGctl_IQLO_CAL_EN);
 	}
 
-	and_phy_reg(pi, 0xc3, (uint16) ~(0x1 << 2));
+	and_phy_reg(pi, 0xc3, (u16) ~(0x1 << 2));
 
 	if ((pi->nphy_bb_mult_save & BB_MULT_VALID_MASK) != 0) {
 
@@ -22569,7 +22569,7 @@ void wlc_phy_stopplayback_nphy(phy_info_
 
 nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t *pi)
 {
-	uint16 base_idx[2], curr_gain[2];
+	u16 base_idx[2], curr_gain[2];
 	u8 core_no;
 	nphy_txgains_t target_gain;
 	uint32 *tx_pwrctrl_tbl = NULL;
@@ -22725,13 +22725,13 @@ nphy_txgains_t wlc_phy_get_tx_gain_nphy(
 }
 
 static void
-wlc_phy_iqcal_gainparams_nphy(phy_info_t *pi, uint16 core_no,
+wlc_phy_iqcal_gainparams_nphy(phy_info_t *pi, u16 core_no,
 			      nphy_txgains_t target_gain,
 			      nphy_iqcal_params_t *params)
 {
 	u8 k;
 	int idx;
-	uint16 gain_index;
+	u16 gain_index;
 	u8 band_idx = (CHSPEC_IS5G(pi->radio_chanspec) ? 1 : 0);
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
@@ -22792,7 +22792,7 @@ wlc_phy_iqcal_gainparams_nphy(phy_info_t
 
 static void wlc_phy_txcal_radio_setup_nphy(phy_info_t *pi)
 {
-	uint16 jtag_core, core;
+	u16 jtag_core, core;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -23102,7 +23102,7 @@ static void wlc_phy_txcal_radio_setup_np
 
 static void wlc_phy_txcal_radio_cleanup_nphy(phy_info_t *pi)
 {
-	uint16 jtag_core, core;
+	u16 jtag_core, core;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 		for (core = 0; core <= 1; core++) {
@@ -23240,7 +23240,7 @@ static void wlc_phy_txcal_radio_cleanup_
 
 static void wlc_phy_txcal_physetup_nphy(phy_info_t *pi)
 {
-	uint16 val, mask;
+	u16 val, mask;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		pi->tx_rx_cal_phy_saveregs[0] = read_phy_reg(pi, 0xa6);
@@ -23392,7 +23392,7 @@ static void wlc_phy_txcal_physetup_nphy(
 
 static void wlc_phy_txcal_phycleanup_nphy(phy_info_t *pi)
 {
-	uint16 mask;
+	u16 mask;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		write_phy_reg(pi, 0xa6, pi->tx_rx_cal_phy_saveregs[0]);
@@ -23474,7 +23474,7 @@ static void wlc_phy_txcal_phycleanup_nph
 void
 wlc_phy_est_tonepwr_nphy(phy_info_t *pi, int32 *qdBm_pwrbuf, u8 num_samps)
 {
-	uint16 tssi_reg;
+	u16 tssi_reg;
 	int32 temp, pwrindex[2];
 	int32 idle_tssi[2];
 	int32 rssi_buf[4];
@@ -23521,7 +23521,7 @@ wlc_phy_est_tonepwr_nphy(phy_info_t *pi,
 
 static void wlc_phy_internal_cal_txgain_nphy(phy_info_t *pi)
 {
-	uint16 txcal_gain[2];
+	u16 txcal_gain[2];
 
 	pi->nphy_txcal_pwr_idx[0] = pi->nphy_cal_orig_pwr_idx[0];
 	pi->nphy_txcal_pwr_idx[1] = pi->nphy_cal_orig_pwr_idx[0];
@@ -23635,14 +23635,14 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 {
 	int gainctrl_loopidx;
 	uint core;
-	uint16 m0m1, curr_m0m1;
+	u16 m0m1, curr_m0m1;
 	int32 delta_power;
 	int32 txpwrindex;
 	int32 qdBm_power[2];
-	uint16 orig_BBConfig;
-	uint16 phy_saveregs[4];
+	u16 orig_BBConfig;
+	u16 phy_saveregs[4];
 	uint32 freq_test;
-	uint16 ampl_test = 250;
+	u16 ampl_test = 250;
 	uint stepsize;
 	bool phyhang_avoid_state = FALSE;
 
@@ -23755,8 +23755,8 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 		pi->nphy_txcal_pwr_idx[core] = (u8) txpwrindex;
 
 		if (debug) {
-			uint16 radio_gain;
-			uint16 dbg_m0m1;
+			u16 radio_gain;
+			u16 dbg_m0m1;
 
 			wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &dbg_m0m1);
 
@@ -23798,12 +23798,12 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
 }
 
-static void wlc_phy_update_txcal_ladder_nphy(phy_info_t *pi, uint16 core)
+static void wlc_phy_update_txcal_ladder_nphy(phy_info_t *pi, u16 core)
 {
 	int index;
 	uint32 bbmult_scale;
-	uint16 bbmult;
-	uint16 tblentry;
+	u16 bbmult;
+	u16 tblentry;
 
 	nphy_txiqcal_ladder_t ladder_lo[] = {
 		{3, 0}, {4, 0}, {6, 0}, {9, 0}, {13, 0}, {18, 0},
@@ -24100,18 +24100,18 @@ int
 wlc_phy_cal_txiqlo_nphy(phy_info_t *pi, nphy_txgains_t target_gain,
 			bool fullcal, bool mphase)
 {
-	uint16 val;
-	uint16 tbl_buf[11];
+	u16 val;
+	u16 tbl_buf[11];
 	u8 cal_cnt;
-	uint16 cal_cmd;
+	u16 cal_cmd;
 	u8 num_cals, max_cal_cmds;
-	uint16 core_no, cal_type;
-	uint16 diq_start = 0;
+	u16 core_no, cal_type;
+	u16 diq_start = 0;
 	u8 phy_bw;
-	uint16 max_val;
-	uint16 tone_freq;
-	uint16 gain_save[2];
-	uint16 cal_gain[2];
+	u16 max_val;
+	u16 tone_freq;
+	u16 gain_save[2];
+	u16 cal_gain[2];
 	nphy_iqcal_params_t cal_params[2];
 	uint32 tbl_len;
 	void *tbl_ptr;
@@ -24120,61 +24120,61 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t *pi,
 	int bcmerror = BCME_OK;
 	bool phyhang_avoid_state = FALSE;
 
-	uint16 tbl_tx_iqlo_cal_loft_ladder_20[] = {
+	u16 tbl_tx_iqlo_cal_loft_ladder_20[] = {
 		0x0300, 0x0500, 0x0700, 0x0900, 0x0d00, 0x1100, 0x1900, 0x1901,
 		    0x1902,
 		0x1903, 0x1904, 0x1905, 0x1906, 0x1907, 0x2407, 0x3207, 0x4607,
 		    0x6407
 	};
 
-	uint16 tbl_tx_iqlo_cal_iqimb_ladder_20[] = {
+	u16 tbl_tx_iqlo_cal_iqimb_ladder_20[] = {
 		0x0200, 0x0300, 0x0600, 0x0900, 0x0d00, 0x1100, 0x1900, 0x2400,
 		    0x3200,
 		0x4600, 0x6400, 0x6401, 0x6402, 0x6403, 0x6404, 0x6405, 0x6406,
 		    0x6407
 	};
 
-	uint16 tbl_tx_iqlo_cal_loft_ladder_40[] = {
+	u16 tbl_tx_iqlo_cal_loft_ladder_40[] = {
 		0x0200, 0x0300, 0x0400, 0x0700, 0x0900, 0x0c00, 0x1200, 0x1201,
 		    0x1202,
 		0x1203, 0x1204, 0x1205, 0x1206, 0x1207, 0x1907, 0x2307, 0x3207,
 		    0x4707
 	};
 
-	uint16 tbl_tx_iqlo_cal_iqimb_ladder_40[] = {
+	u16 tbl_tx_iqlo_cal_iqimb_ladder_40[] = {
 		0x0100, 0x0200, 0x0400, 0x0700, 0x0900, 0x0c00, 0x1200, 0x1900,
 		    0x2300,
 		0x3200, 0x4700, 0x4701, 0x4702, 0x4703, 0x4704, 0x4705, 0x4706,
 		    0x4707
 	};
 
-	uint16 tbl_tx_iqlo_cal_startcoefs[] = {
+	u16 tbl_tx_iqlo_cal_startcoefs[] = {
 		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 		    0x0000
 	};
 
-	uint16 tbl_tx_iqlo_cal_cmds_fullcal[] = {
+	u16 tbl_tx_iqlo_cal_cmds_fullcal[] = {
 		0x8123, 0x8264, 0x8086, 0x8245, 0x8056,
 		0x9123, 0x9264, 0x9086, 0x9245, 0x9056
 	};
 
-	uint16 tbl_tx_iqlo_cal_cmds_recal[] = {
+	u16 tbl_tx_iqlo_cal_cmds_recal[] = {
 		0x8101, 0x8253, 0x8053, 0x8234, 0x8034,
 		0x9101, 0x9253, 0x9053, 0x9234, 0x9034
 	};
 
-	uint16 tbl_tx_iqlo_cal_startcoefs_nphyrev3[] = {
+	u16 tbl_tx_iqlo_cal_startcoefs_nphyrev3[] = {
 		0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 		0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 		0x0000
 	};
 
-	uint16 tbl_tx_iqlo_cal_cmds_fullcal_nphyrev3[] = {
+	u16 tbl_tx_iqlo_cal_cmds_fullcal_nphyrev3[] = {
 		0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234,
 		0x9434, 0x9334, 0x9084, 0x9267, 0x9056, 0x9234
 	};
 
-	uint16 tbl_tx_iqlo_cal_cmds_recal_nphyrev3[] = {
+	u16 tbl_tx_iqlo_cal_cmds_recal_nphyrev3[] = {
 		0x8423, 0x8323, 0x8073, 0x8256, 0x8045, 0x8223,
 		0x9423, 0x9323, 0x9073, 0x9256, 0x9045, 0x9223
 	};
@@ -24467,7 +24467,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t *pi,
 
 static void wlc_phy_reapply_txcal_coeffs_nphy(phy_info_t *pi)
 {
-	uint16 tbl_buf[7];
+	u16 tbl_buf[7];
 
 	ASSERT(NREV_LT(pi->pubpi.phy_rev, 2));
 
@@ -24531,7 +24531,7 @@ wlc_phy_rx_iq_coeffs_nphy(phy_info_t *pi
 }
 
 void
-wlc_phy_rx_iq_est_nphy(phy_info_t *pi, phy_iq_est_t *est, uint16 num_samps,
+wlc_phy_rx_iq_est_nphy(phy_info_t *pi, phy_iq_est_t *est, u16 num_samps,
 		       u8 wait_time, u8 wait_for_crs)
 {
 	u8 core;
@@ -24689,9 +24689,9 @@ static void wlc_phy_calc_rx_iq_comp_nphy
 
 static void wlc_phy_rxcal_radio_setup_nphy(phy_info_t *pi, u8 rx_core)
 {
-	uint16 offtune_val;
-	uint16 bias_g = 0;
-	uint16 bias_a = 0;
+	u16 offtune_val;
+	u16 bias_g = 0;
+	u16 bias_a = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 		if (rx_core == PHY_CORE_0) {
@@ -25157,7 +25157,7 @@ static void wlc_phy_rxcal_radio_cleanup_
 static void wlc_phy_rxcal_physetup_nphy(phy_info_t *pi, u8 rx_core)
 {
 	u8 tx_core;
-	uint16 rx_antval, tx_antval;
+	u16 rx_antval, tx_antval;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -25309,10 +25309,10 @@ static void wlc_phy_rxcal_phycleanup_nph
 
 static void
 wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t *pi, u8 rx_core,
-				 uint16 *rxgain, u8 cal_type)
+				 u16 *rxgain, u8 cal_type)
 {
 
-	uint16 num_samps;
+	u16 num_samps;
 	phy_iq_est_t est[PHY_CORE_MAX];
 	u8 tx_core;
 	nphy_iq_comp_t save_comp, zero_comp;
@@ -25325,10 +25325,10 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 	s8 curr_gaintbl_index = 3;
 	u8 gainctrl_dirn = NPHY_RXCAL_GAIN_INIT;
 	nphy_ipa_txrxgain_t *nphy_rxcal_gaintbl;
-	uint16 hpvga, lpf_biq1, lpf_biq0, lna2, lna1;
+	u16 hpvga, lpf_biq1, lpf_biq0, lna2, lna1;
 	int16 fine_gain_idx;
 	s8 txpwrindex;
-	uint16 nphy_rxcal_txgain[2];
+	u16 nphy_rxcal_txgain[2];
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -25483,7 +25483,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 		if (fine_gain_idx + (int)lpf_biq0 > 10) {
 			lpf_biq1 = 10 - lpf_biq0;
 		} else {
-			lpf_biq1 = (uint16) MAX(fine_gain_idx, 0);
+			lpf_biq1 = (u16) MAX(fine_gain_idx, 0);
 		}
 		wlc_phy_rfctrl_override_1tomany_nphy(pi,
 						     NPHY_REV7_RfctrlOverride_cmd_rxgain,
@@ -25493,7 +25493,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 						      (lna2 << 2) | lna1), 0x3,
 						     0);
 	} else {
-		hpvga = (uint16) MAX(MIN(((int)hpvga) + delta_pwr, 10), 0);
+		hpvga = (u16) MAX(MIN(((int)hpvga) + delta_pwr, 10), 0);
 		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 12),
 					     ((hpvga << 12) | (lpf_biq1 << 10) |
 					      (lpf_biq0 << 8) | (mix_tia_gain <<
@@ -25516,7 +25516,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 }
 
 static void
-wlc_phy_rxcal_gainctrl_nphy(phy_info_t *pi, u8 rx_core, uint16 *rxgain,
+wlc_phy_rxcal_gainctrl_nphy(phy_info_t *pi, u8 rx_core, u16 *rxgain,
 			    u8 cal_type)
 {
 	wlc_phy_rxcal_gainctrl_nphy_rev5(pi, rx_core, rxgain, cal_type);
@@ -25532,29 +25532,29 @@ wlc_phy_rc_sweep_nphy(phy_info_t *pi, u8
 	uint32 target_pwr_ratios[2] = { 28606, 18468 };
 	uint32 target_pwr_ratio, pwr_ratio, last_pwr_ratio = 0;
 
-	uint16 start_rccal_ovr_val = 128;
-	uint16 txlpf_rccal_lpc_ovr_val = 128;
-	uint16 rxlpf_rccal_hpc_ovr_val = 159;
-
-	uint16 orig_txlpf_rccal_lpc_ovr_val;
-	uint16 orig_rxlpf_rccal_hpc_ovr_val;
-	uint16 radio_addr_offset_rx;
-	uint16 radio_addr_offset_tx;
-	uint16 orig_dcBypass;
-	uint16 orig_RxStrnFilt40Num[6];
-	uint16 orig_RxStrnFilt40Den[4];
-	uint16 orig_rfctrloverride[2];
-	uint16 orig_rfctrlauxreg[2];
-	uint16 orig_rfctrlrssiothers;
-	uint16 tx_lpf_bw = 4;
+	u16 start_rccal_ovr_val = 128;
+	u16 txlpf_rccal_lpc_ovr_val = 128;
+	u16 rxlpf_rccal_hpc_ovr_val = 159;
+
+	u16 orig_txlpf_rccal_lpc_ovr_val;
+	u16 orig_rxlpf_rccal_hpc_ovr_val;
+	u16 radio_addr_offset_rx;
+	u16 radio_addr_offset_tx;
+	u16 orig_dcBypass;
+	u16 orig_RxStrnFilt40Num[6];
+	u16 orig_RxStrnFilt40Den[4];
+	u16 orig_rfctrloverride[2];
+	u16 orig_rfctrlauxreg[2];
+	u16 orig_rfctrlrssiothers;
+	u16 tx_lpf_bw = 4;
 
-	uint16 rx_lpf_bw, rx_lpf_bws[2] = { 2, 4 };
-	uint16 lpf_hpc = 7, hpvga_hpc = 7;
+	u16 rx_lpf_bw, rx_lpf_bws[2] = { 2, 4 };
+	u16 lpf_hpc = 7, hpvga_hpc = 7;
 
 	s8 rccal_stepsize;
-	uint16 rccal_val, last_rccal_val = 0, best_rccal_val = 0;
+	u16 rccal_val, last_rccal_val = 0, best_rccal_val = 0;
 	uint32 ref_iq_vals = 0, target_iq_vals = 0;
-	uint16 num_samps, log_num_samps = 10;
+	u16 num_samps, log_num_samps = 10;
 	phy_iq_est_t est[PHY_CORE_MAX];
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -25767,11 +25767,11 @@ static int
 wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *pi, nphy_txgains_t target_gain,
 			   u8 cal_type, bool debug)
 {
-	uint16 orig_BBConfig;
+	u16 orig_BBConfig;
 	u8 core_no, rx_core;
 	u8 best_rccal[2];
-	uint16 gain_save[2];
-	uint16 cal_gain[2];
+	u16 gain_save[2];
+	u16 cal_gain[2];
 	nphy_iqcal_params_t cal_params[2];
 	u8 rxcore_state;
 	s8 rxlpf_rccal_hpc, txlpf_rccal_lpc;
@@ -25926,20 +25926,20 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t *p
 {
 	phy_iq_est_t est[PHY_CORE_MAX];
 	u8 core_num, rx_core, tx_core;
-	uint16 lna_vals[] = { 0x3, 0x3, 0x1 };
-	uint16 hpf1_vals[] = { 0x7, 0x2, 0x0 };
-	uint16 hpf2_vals[] = { 0x2, 0x0, 0x0 };
+	u16 lna_vals[] = { 0x3, 0x3, 0x1 };
+	u16 hpf1_vals[] = { 0x7, 0x2, 0x0 };
+	u16 hpf2_vals[] = { 0x2, 0x0, 0x0 };
 	int16 curr_hpf1, curr_hpf2, curr_hpf, curr_lna;
 	int16 desired_log2_pwr, actual_log2_pwr, hpf_change;
-	uint16 orig_RfseqCoreActv, orig_AfectrlCore, orig_AfectrlOverride;
-	uint16 orig_RfctrlIntcRx, orig_RfctrlIntcTx;
-	uint16 num_samps;
+	u16 orig_RfseqCoreActv, orig_AfectrlCore, orig_AfectrlOverride;
+	u16 orig_RfctrlIntcRx, orig_RfctrlIntcTx;
+	u16 num_samps;
 	uint32 i_pwr, q_pwr, tot_pwr[3];
 	u8 gain_pass, use_hpf_num;
-	uint16 mask, val1, val2;
-	uint16 core_no;
-	uint16 gain_save[2];
-	uint16 cal_gain[2];
+	u16 mask, val1, val2;
+	u16 core_no;
+	u16 gain_save[2];
+	u16 cal_gain[2];
 	nphy_iqcal_params_t cal_params[2];
 	u8 phy_bw;
 	int bcmerror = BCME_OK;
@@ -26079,7 +26079,7 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t *p
 
 			if (first_playtone) {
 				bcmerror = wlc_phy_tx_tone_nphy(pi, 4000,
-								(uint16) (pi->
+								(u16) (pi->
 									  nphy_rxcalparams
 									  &
 									  0xffff),
@@ -26165,7 +26165,7 @@ wlc_phy_cal_rxiq_nphy(phy_info_t *pi, np
 static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t *pi)
 {
 	int j, type = 2;
-	uint16 addr_offset = 0x2c5;
+	u16 addr_offset = 0x2c5;
 
 	for (j = 0; j < NPHY_NUM_DIG_FILT_COEFFS; j++) {
 		write_phy_reg(pi, addr_offset + j,
@@ -26176,7 +26176,7 @@ static void wlc_phy_extpa_set_tx_digi_fi
 static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t *pi)
 {
 	int j, type;
-	uint16 addr_offset[] = { 0x186, 0x195,
+	u16 addr_offset[] = { 0x186, 0x195,
 		0x2c5
 	};
 
@@ -26228,9 +26228,9 @@ static void wlc_phy_ipa_restore_tx_digi_
 	}
 }
 
-static uint16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t *pi)
+static u16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t *pi)
 {
-	uint16 m0m1;
+	u16 m0m1;
 
 	wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &m0m1);
 
@@ -26239,7 +26239,7 @@ static uint16 wlc_phy_ipa_get_bbmult_nph
 
 static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t *pi, u8 m0, u8 m1)
 {
-	uint16 m0m1 = (uint16) ((m0 << 8) | m1);
+	u16 m0m1 = (u16) ((m0 << 8) | m1);
 
 	wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &m0m1);
 	wlc_phy_table_write_nphy(pi, 15, 1, 95, 16, &m0m1);
@@ -26322,7 +26322,7 @@ wlc_phy_papd_cal_setup_nphy(phy_info_t *
 {
 	int32 tone_freq;
 	u8 off_core;
-	uint16 mixgain = 0;
+	u16 mixgain = 0;
 
 	off_core = core ^ 0x1;
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -26776,8 +26776,8 @@ static void
 wlc_phy_a2_nphy(phy_info_t *pi, nphy_ipa_txcalgains_t *txgains,
 		phy_cal_mode_t cal_mode, u8 core)
 {
-	uint16 phy_a1, phy_a2, phy_a3;
-	uint16 phy_a4, phy_a5;
+	u16 phy_a1, phy_a2, phy_a3;
+	u16 phy_a4, phy_a5;
 	bool phy_a6;
 	u8 phy_a7, m[2];
 	uint32 phy_a8 = 0;
@@ -27131,10 +27131,10 @@ static u8 wlc_phy_a3_nphy(phy_info_t *pi
 		for (phy_a10 = 0; phy_a10 < phy_a2; phy_a10++) {
 			if (CHSPEC_IS2G(pi->radio_chanspec)) {
 				phy_a4.gains.pad[core] =
-				    (uint16) phy_a15[phy_a12];
+				    (u16) phy_a15[phy_a12];
 			} else {
 				phy_a4.gains.pga[core] =
-				    (uint16) phy_a15[phy_a12];
+				    (u16) phy_a15[phy_a12];
 			}
 
 			wlc_phy_a2_nphy(pi, &phy_a4, CAL_GCTRL, core);
@@ -27242,7 +27242,7 @@ static void wlc_phy_a4(phy_info_t *pi, b
 	u8 phy_b4;
 	u8 phy_b5;
 	int16 phy_b6, phy_b7, phy_b8;
-	uint16 phy_b9;
+	u16 phy_b9;
 	int16 phy_b10, phy_b11, phy_b12;
 
 	phy_b11 = 0;
@@ -27533,7 +27533,7 @@ void wlc_phy_txpwr_fixpower_nphy(phy_inf
 {
 	uint core;
 	uint32 txgain;
-	uint16 rad_gain, dac_gain, bbmult, m1m2;
+	u16 rad_gain, dac_gain, bbmult, m1m2;
 	u8 txpi[2], chan_freq_range;
 	int32 rfpwr_offset;
 
@@ -27680,14 +27680,14 @@ void wlc_phy_txpwr_fixpower_nphy(phy_inf
 		}
 	}
 
-	and_phy_reg(pi, 0xbf, (uint16) (~(0x1f << 0)));
+	and_phy_reg(pi, 0xbf, (u16) (~(0x1f << 0)));
 
 	if (pi->phyhang_avoid)
 		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
 }
 
 static void
-wlc_phy_txpwr_nphy_srom_convert(u8 *srom_max, uint16 *pwr_offset,
+wlc_phy_txpwr_nphy_srom_convert(u8 *srom_max, u16 *pwr_offset,
 				u8 tmp_max_pwr, u8 rate_start,
 				u8 rate_end)
 {
@@ -27748,7 +27748,7 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 	uint rate1, rate2, band_num;
 	u8 tmp_bw40po = 0, tmp_cddpo = 0, tmp_stbcpo = 0;
 	u8 tmp_max_pwr = 0;
-	uint16 pwr_offsets1[2], *pwr_offsets2 = NULL;
+	u16 pwr_offsets1[2], *pwr_offsets2 = NULL;
 	u8 *tx_srom_max_rate = NULL;
 
 	for (band_num = 0; band_num < (CH_2G_GROUP + CH_5G_GROUP); band_num++) {
@@ -27765,9 +27765,9 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 							TXP_FIRST_CCK,
 							TXP_LAST_CCK);
 
-			pwr_offsets1[0] = (uint16) (pi->ofdm2gpo & 0xffff);
+			pwr_offsets1[0] = (u16) (pi->ofdm2gpo & 0xffff);
 			pwr_offsets1[1] =
-			    (uint16) (pi->ofdm2gpo >> 16) & 0xffff;
+			    (u16) (pi->ofdm2gpo >> 16) & 0xffff;
 
 			pwr_offsets2 = pi->mcs2gpo;
 
@@ -27782,9 +27782,9 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_5gm,
 					  pi->nphy_pwrctrl_info[1].max_pwr_5gm);
 
-			pwr_offsets1[0] = (uint16) (pi->ofdm5gpo & 0xffff);
+			pwr_offsets1[0] = (u16) (pi->ofdm5gpo & 0xffff);
 			pwr_offsets1[1] =
-			    (uint16) (pi->ofdm5gpo >> 16) & 0xffff;
+			    (u16) (pi->ofdm5gpo >> 16) & 0xffff;
 
 			pwr_offsets2 = pi->mcs5gpo;
 
@@ -27799,9 +27799,9 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_5gl,
 					  pi->nphy_pwrctrl_info[1].max_pwr_5gl);
 
-			pwr_offsets1[0] = (uint16) (pi->ofdm5glpo & 0xffff);
+			pwr_offsets1[0] = (u16) (pi->ofdm5glpo & 0xffff);
 			pwr_offsets1[1] =
-			    (uint16) (pi->ofdm5glpo >> 16) & 0xffff;
+			    (u16) (pi->ofdm5glpo >> 16) & 0xffff;
 
 			pwr_offsets2 = pi->mcs5glpo;
 
@@ -27816,9 +27816,9 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_5gh,
 					  pi->nphy_pwrctrl_info[1].max_pwr_5gh);
 
-			pwr_offsets1[0] = (uint16) (pi->ofdm5ghpo & 0xffff);
+			pwr_offsets1[0] = (u16) (pi->ofdm5ghpo & 0xffff);
 			pwr_offsets1[1] =
-			    (uint16) (pi->ofdm5ghpo >> 16) & 0xffff;
+			    (u16) (pi->ofdm5ghpo >> 16) & 0xffff;
 
 			pwr_offsets2 = pi->mcs5ghpo;
 
@@ -27943,7 +27943,7 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 
 static void BCMATTACHFN(wlc_phy_txpwr_srom_read_ppr_nphy) (phy_info_t *pi)
 {
-	uint16 bw40po, cddpo, stbcpo, bwduppo;
+	u16 bw40po, cddpo, stbcpo, bwduppo;
 	uint band_num;
 
 	if (pi->sh->sromrev >= 9) {
@@ -27951,25 +27951,25 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 		return;
 	}
 
-	bw40po = (uint16) PHY_GETINTVAR(pi, "bw40po");
+	bw40po = (u16) PHY_GETINTVAR(pi, "bw40po");
 	pi->bw402gpo = bw40po & 0xf;
 	pi->bw405gpo = (bw40po & 0xf0) >> 4;
 	pi->bw405glpo = (bw40po & 0xf00) >> 8;
 	pi->bw405ghpo = (bw40po & 0xf000) >> 12;
 
-	cddpo = (uint16) PHY_GETINTVAR(pi, "cddpo");
+	cddpo = (u16) PHY_GETINTVAR(pi, "cddpo");
 	pi->cdd2gpo = cddpo & 0xf;
 	pi->cdd5gpo = (cddpo & 0xf0) >> 4;
 	pi->cdd5glpo = (cddpo & 0xf00) >> 8;
 	pi->cdd5ghpo = (cddpo & 0xf000) >> 12;
 
-	stbcpo = (uint16) PHY_GETINTVAR(pi, "stbcpo");
+	stbcpo = (u16) PHY_GETINTVAR(pi, "stbcpo");
 	pi->stbc2gpo = stbcpo & 0xf;
 	pi->stbc5gpo = (stbcpo & 0xf0) >> 4;
 	pi->stbc5glpo = (stbcpo & 0xf00) >> 8;
 	pi->stbc5ghpo = (stbcpo & 0xf000) >> 12;
 
-	bwduppo = (uint16) PHY_GETINTVAR(pi, "bwduppo");
+	bwduppo = (u16) PHY_GETINTVAR(pi, "bwduppo");
 	pi->bwdup2gpo = bwduppo & 0xf;
 	pi->bwdup5gpo = (bwduppo & 0xf0) >> 4;
 	pi->bwdup5glpo = (bwduppo & 0xf00) >> 8;
@@ -28004,18 +28004,18 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_pwrctrl_info[PHY_CORE_1].idle_targ_2g =
 			    (s8) PHY_GETINTVAR(pi, "itt2ga1");
 
-			pi->cck2gpo = (uint16) PHY_GETINTVAR(pi, "cck2gpo");
+			pi->cck2gpo = (u16) PHY_GETINTVAR(pi, "cck2gpo");
 
 			pi->ofdm2gpo = (uint32) PHY_GETINTVAR(pi, "ofdm2gpo");
 
-			pi->mcs2gpo[0] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo0");
-			pi->mcs2gpo[1] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo1");
-			pi->mcs2gpo[2] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo2");
-			pi->mcs2gpo[3] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo3");
-			pi->mcs2gpo[4] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo4");
-			pi->mcs2gpo[5] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo5");
-			pi->mcs2gpo[6] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo6");
-			pi->mcs2gpo[7] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo7");
+			pi->mcs2gpo[0] = (u16) PHY_GETINTVAR(pi, "mcs2gpo0");
+			pi->mcs2gpo[1] = (u16) PHY_GETINTVAR(pi, "mcs2gpo1");
+			pi->mcs2gpo[2] = (u16) PHY_GETINTVAR(pi, "mcs2gpo2");
+			pi->mcs2gpo[3] = (u16) PHY_GETINTVAR(pi, "mcs2gpo3");
+			pi->mcs2gpo[4] = (u16) PHY_GETINTVAR(pi, "mcs2gpo4");
+			pi->mcs2gpo[5] = (u16) PHY_GETINTVAR(pi, "mcs2gpo5");
+			pi->mcs2gpo[6] = (u16) PHY_GETINTVAR(pi, "mcs2gpo6");
+			pi->mcs2gpo[7] = (u16) PHY_GETINTVAR(pi, "mcs2gpo7");
 			break;
 		case 1:
 
@@ -28046,14 +28046,14 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 
 			pi->ofdm5gpo = (uint32) PHY_GETINTVAR(pi, "ofdm5gpo");
 
-			pi->mcs5gpo[0] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo0");
-			pi->mcs5gpo[1] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo1");
-			pi->mcs5gpo[2] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo2");
-			pi->mcs5gpo[3] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo3");
-			pi->mcs5gpo[4] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo4");
-			pi->mcs5gpo[5] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo5");
-			pi->mcs5gpo[6] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo6");
-			pi->mcs5gpo[7] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo7");
+			pi->mcs5gpo[0] = (u16) PHY_GETINTVAR(pi, "mcs5gpo0");
+			pi->mcs5gpo[1] = (u16) PHY_GETINTVAR(pi, "mcs5gpo1");
+			pi->mcs5gpo[2] = (u16) PHY_GETINTVAR(pi, "mcs5gpo2");
+			pi->mcs5gpo[3] = (u16) PHY_GETINTVAR(pi, "mcs5gpo3");
+			pi->mcs5gpo[4] = (u16) PHY_GETINTVAR(pi, "mcs5gpo4");
+			pi->mcs5gpo[5] = (u16) PHY_GETINTVAR(pi, "mcs5gpo5");
+			pi->mcs5gpo[6] = (u16) PHY_GETINTVAR(pi, "mcs5gpo6");
+			pi->mcs5gpo[7] = (u16) PHY_GETINTVAR(pi, "mcs5gpo7");
 			break;
 		case 2:
 
@@ -28083,21 +28083,21 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->ofdm5glpo = (uint32) PHY_GETINTVAR(pi, "ofdm5glpo");
 
 			pi->mcs5glpo[0] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo0");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo0");
 			pi->mcs5glpo[1] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo1");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo1");
 			pi->mcs5glpo[2] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo2");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo2");
 			pi->mcs5glpo[3] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo3");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo3");
 			pi->mcs5glpo[4] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo4");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo4");
 			pi->mcs5glpo[5] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo5");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo5");
 			pi->mcs5glpo[6] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo6");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo6");
 			pi->mcs5glpo[7] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo7");
+			    (u16) PHY_GETINTVAR(pi, "mcs5glpo7");
 			break;
 		case 3:
 
@@ -28127,21 +28127,21 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->ofdm5ghpo = (uint32) PHY_GETINTVAR(pi, "ofdm5ghpo");
 
 			pi->mcs5ghpo[0] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo0");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo0");
 			pi->mcs5ghpo[1] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo1");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo1");
 			pi->mcs5ghpo[2] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo2");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo2");
 			pi->mcs5ghpo[3] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo3");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo3");
 			pi->mcs5ghpo[4] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo4");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo4");
 			pi->mcs5ghpo[5] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo5");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo5");
 			pi->mcs5ghpo[6] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo6");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo6");
 			pi->mcs5ghpo[7] =
-			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo7");
+			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo7");
 			break;
 		}
 	}
@@ -28232,7 +28232,7 @@ void wlc_phy_txpower_recalc_target_nphy(
 static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t *pi)
 {
 	uint32 idx;
-	uint16 iqloCalbuf[7];
+	u16 iqloCalbuf[7];
 	uint32 iqcomp, locomp, curr_locomp;
 	s8 locomp_i, locomp_q;
 	s8 curr_locomp_i, curr_locomp_q;
@@ -28500,7 +28500,7 @@ static void wlc_phy_txpwrctrl_pwr_setup_
 	or_phy_reg(pi, 0x122, (0x1 << 0));
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
-		and_phy_reg(pi, 0x1e7, (uint16) (~(0x1 << 15)));
+		and_phy_reg(pi, 0x1e7, (u16) (~(0x1 << 15)));
 	} else {
 
 		or_phy_reg(pi, 0x1e7, (0x1 << 15));
@@ -28721,7 +28721,7 @@ static bool wlc_phy_txpwr_ison_nphy(phy_
 
 static u8 wlc_phy_txpwr_idx_cur_get_nphy(phy_info_t *pi, u8 core)
 {
-	uint16 tmp;
+	u16 tmp;
 	tmp = read_phy_reg(pi, ((core == PHY_CORE_0) ? 0x1ed : 0x1ee));
 
 	tmp = (tmp & (0x7f << 8)) >> 8;
@@ -28737,10 +28737,10 @@ wlc_phy_txpwr_idx_cur_set_nphy(phy_info_
 		mod_phy_reg(pi, 0x222, (0xff << 0), idx1);
 }
 
-uint16 wlc_phy_txpwr_idx_get_nphy(phy_info_t *pi)
+u16 wlc_phy_txpwr_idx_get_nphy(phy_info_t *pi)
 {
-	uint16 tmp;
-	uint16 pwr_idx[2];
+	u16 tmp;
+	u16 pwr_idx[2];
 
 	if (wlc_phy_txpwr_ison_nphy(pi)) {
 		pwr_idx[0] = wlc_phy_txpwr_idx_cur_get_nphy(pi, PHY_CORE_0);
@@ -28777,12 +28777,12 @@ void wlc_phy_txpwr_papd_cal_nphy(phy_inf
 
 void wlc_phy_txpwrctrl_enable_nphy(phy_info_t *pi, u8 ctrl_type)
 {
-	uint16 mask = 0, val = 0, ishw = 0;
+	u16 mask = 0, val = 0, ishw = 0;
 	u8 ctr;
 	uint core;
 	uint32 tbl_offset;
 	uint32 tbl_len;
-	uint16 regval[84];
+	u16 regval[84];
 
 	if (pi->phyhang_avoid)
 		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
@@ -28823,11 +28823,11 @@ void wlc_phy_txpwrctrl_enable_nphy(phy_i
 		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 
 			and_phy_reg(pi, 0x1e7,
-				    (uint16) (~((0x1 << 15) |
+				    (u16) (~((0x1 << 15) |
 						(0x1 << 14) | (0x1 << 13))));
 		} else {
 			and_phy_reg(pi, 0x1e7,
-				    (uint16) (~((0x1 << 14) | (0x1 << 13))));
+				    (u16) (~((0x1 << 14) | (0x1 << 13))));
 		}
 
 		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
@@ -28925,18 +28925,18 @@ wlc_phy_txpwr_index_nphy(phy_info_t *pi,
 			 bool restore_cals)
 {
 	u8 core, txpwrctl_tbl;
-	uint16 tx_ind0, iq_ind0, lo_ind0;
-	uint16 m1m2;
+	u16 tx_ind0, iq_ind0, lo_ind0;
+	u16 m1m2;
 	uint32 txgain;
-	uint16 rad_gain, dac_gain;
+	u16 rad_gain, dac_gain;
 	u8 bbmult;
 	uint32 iqcomp;
-	uint16 iqcomp_a, iqcomp_b;
+	u16 iqcomp_a, iqcomp_b;
 	uint32 locomp;
-	uint16 tmpval;
+	u16 tmpval;
 	u8 tx_pwr_ctrl_state;
 	int32 rfpwr_offset;
-	uint16 regval[2];
+	u16 regval[2];
 
 	if (pi->phyhang_avoid)
 		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
@@ -29112,8 +29112,8 @@ wlc_phy_txpwr_index_nphy(phy_info_t *pi,
 			iqcomp_b = (iqcomp >> 0) & ((1 << (9 - 0 + 1)) - 1);
 
 			if (restore_cals) {
-				regval[0] = (uint16) iqcomp_a;
-				regval[1] = (uint16) iqcomp_b;
+				regval[0] = (u16) iqcomp_a;
+				regval[1] = (u16) iqcomp_b;
 				wlc_phy_table_write_nphy(pi, 15, 2,
 							 (80 + 2 * core), 16,
 							 regval);
@@ -29190,7 +29190,7 @@ wlc_phy_txpower_sromlimit_get_nphy(phy_i
 
 void wlc_phy_stay_in_carriersearch_nphy(phy_info_t *pi, bool enable)
 {
-	uint16 clip_off[] = { 0xffff, 0xffff };
+	u16 clip_off[] = { 0xffff, 0xffff };
 
 	ASSERT(0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
 
--- a/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c
@@ -217,7 +217,7 @@ const uint32 dot11lcn_gain_tbl_rev1[] =
 	0x00000000,
 };
 
-const uint16 dot11lcn_aux_gain_idx_tbl_rev0[] = {
+const u16 dot11lcn_aux_gain_idx_tbl_rev0[] = {
 	0x0401,
 	0x0402,
 	0x0403,
@@ -409,7 +409,7 @@ const uint32 dot11lcn_gain_idx_tbl_rev0[
 	0x0000001c,
 };
 
-const uint16 dot11lcn_aux_gain_idx_tbl_2G[] = {
+const u16 dot11lcn_aux_gain_idx_tbl_2G[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -874,7 +874,7 @@ const uint32 dot11lcn_gain_tbl_extlna_2G
 	0x00000000
 };
 
-const uint16 dot11lcn_aux_gain_idx_tbl_extlna_2G[] = {
+const u16 dot11lcn_aux_gain_idx_tbl_extlna_2G[] = {
 	0x0400,
 	0x0400,
 	0x0400,
@@ -1625,7 +1625,7 @@ const uint32 dot11lcnphytbl_rx_gain_info
     sizeof(dot11lcnphytbl_rx_gain_info_5G_rev2) /
     sizeof(dot11lcnphytbl_rx_gain_info_5G_rev2[0]);
 
-const uint16 dot11lcn_min_sig_sq_tbl_rev0[] = {
+const u16 dot11lcn_min_sig_sq_tbl_rev0[] = {
 	0x014d,
 	0x014d,
 	0x014d,
@@ -1692,7 +1692,7 @@ const uint16 dot11lcn_min_sig_sq_tbl_rev
 	0x014d,
 };
 
-const uint16 dot11lcn_noise_scale_tbl_rev0[] = {
+const u16 dot11lcn_noise_scale_tbl_rev0[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -1795,7 +1795,7 @@ const uint32 dot11lcn_ps_ctrl_tbl_rev0[]
 	0x00600f22,
 };
 
-const uint16 dot11lcn_sw_ctrl_tbl_4313_epa_rev0_combo[] = {
+const u16 dot11lcn_sw_ctrl_tbl_4313_epa_rev0_combo[] = {
 	0x0007,
 	0x0005,
 	0x0006,
@@ -1863,7 +1863,7 @@ const uint16 dot11lcn_sw_ctrl_tbl_4313_e
 
 };
 
-const uint16 dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0[] = {
+const u16 dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0[] = {
 	0x0007,
 	0x0005,
 	0x0002,
@@ -1930,7 +1930,7 @@ const uint16 dot11lcn_sw_ctrl_tbl_4313_b
 	0x0002,
 };
 
-const uint16 dot11lcn_sw_ctrl_tbl_4313_epa_rev0[] = {
+const u16 dot11lcn_sw_ctrl_tbl_4313_epa_rev0[] = {
 	0x0002,
 	0x0008,
 	0x0004,
@@ -1997,7 +1997,7 @@ const uint16 dot11lcn_sw_ctrl_tbl_4313_e
 	0x0001,
 };
 
-const uint16 dot11lcn_sw_ctrl_tbl_4313_rev0[] = {
+const u16 dot11lcn_sw_ctrl_tbl_4313_rev0[] = {
 	0x000a,
 	0x0009,
 	0x0006,
@@ -2064,7 +2064,7 @@ const uint16 dot11lcn_sw_ctrl_tbl_4313_r
 	0x0005,
 };
 
-const uint16 dot11lcn_sw_ctrl_tbl_rev0[] = {
+const u16 dot11lcn_sw_ctrl_tbl_rev0[] = {
 	0x0004,
 	0x0004,
 	0x0002,
@@ -2344,7 +2344,7 @@ const u8 dot11lcn_spur_tbl_rev0[] = {
 	0x01,
 };
 
-const uint16 dot11lcn_unsup_mcs_tbl_rev0[] = {
+const u16 dot11lcn_unsup_mcs_tbl_rev0[] = {
 	0x001a,
 	0x0034,
 	0x004e,
@@ -2501,7 +2501,7 @@ const uint16 dot11lcn_unsup_mcs_tbl_rev0
 	0x06f6,
 };
 
-const uint16 dot11lcn_iq_local_tbl_rev0[] = {
+const u16 dot11lcn_iq_local_tbl_rev0[] = {
 	0x0200,
 	0x0300,
 	0x0400,
--- a/drivers/staging/brcm80211/phy/wlc_phytbl_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_n.c
@@ -2057,7 +2057,7 @@ const uint32 intlv_tbl_rev0[] = {
 	0x00000070,
 };
 
-const uint16 pilot_tbl_rev0[] = {
+const u16 pilot_tbl_rev0[] = {
 	0xff08,
 	0xff08,
 	0xff08,
@@ -2499,7 +2499,7 @@ const uint32 tdi_tbl40_ant1_rev0[] = {
 	0x00000000,
 };
 
-const uint16 bdi_tbl_rev0[] = {
+const u16 bdi_tbl_rev0[] = {
 	0x0070,
 	0x0126,
 	0x012c,
@@ -4176,7 +4176,7 @@ const uint32 iq_lut_core1_rev0[] = {
 	0x0000007f,
 };
 
-const uint16 loft_lut_core0_rev0[] = {
+const u16 loft_lut_core0_rev0[] = {
 	0x0000,
 	0x0101,
 	0x0002,
@@ -4307,7 +4307,7 @@ const uint16 loft_lut_core0_rev0[] = {
 	0x0103,
 };
 
-const uint16 loft_lut_core1_rev0[] = {
+const u16 loft_lut_core1_rev0[] = {
 	0x0000,
 	0x0101,
 	0x0002,
@@ -4542,7 +4542,7 @@ const uint32 mimophytbl_info_sz_rev0_vol
     sizeof(mimophytbl_info_rev0_volatile) /
     sizeof(mimophytbl_info_rev0_volatile[0]);
 
-const uint16 ant_swctrl_tbl_rev3[] = {
+const u16 ant_swctrl_tbl_rev3[] = {
 	0x0082,
 	0x0082,
 	0x0211,
@@ -4577,7 +4577,7 @@ const uint16 ant_swctrl_tbl_rev3[] = {
 	0x0000,
 };
 
-const uint16 ant_swctrl_tbl_rev3_1[] = {
+const u16 ant_swctrl_tbl_rev3_1[] = {
 	0x0022,
 	0x0022,
 	0x0011,
@@ -4612,7 +4612,7 @@ const uint16 ant_swctrl_tbl_rev3_1[] = {
 	0x0000,
 };
 
-const uint16 ant_swctrl_tbl_rev3_2[] = {
+const u16 ant_swctrl_tbl_rev3_2[] = {
 	0x0088,
 	0x0088,
 	0x0044,
@@ -4647,7 +4647,7 @@ const uint16 ant_swctrl_tbl_rev3_2[] = {
 	0x0000,
 };
 
-const uint16 ant_swctrl_tbl_rev3_3[] = {
+const u16 ant_swctrl_tbl_rev3_3[] = {
 	0x022,
 	0x022,
 	0x011,
@@ -5517,7 +5517,7 @@ const uint32 frame_struct_rev3[] = {
 	0x00000000,
 };
 
-const uint16 pilot_tbl_rev3[] = {
+const u16 pilot_tbl_rev3[] = {
 	0xff08,
 	0xff08,
 	0xff08,
@@ -7035,7 +7035,7 @@ const uint32 noise_var_tbl_rev3[] = {
 	0x0000014d,
 };
 
-const uint16 mcs_tbl_rev3[] = {
+const u16 mcs_tbl_rev3[] = {
 	0x0000,
 	0x0008,
 	0x000a,
@@ -8571,7 +8571,7 @@ const uint32 iq_lut_core1_rev3[] = {
 	0x00000000,
 };
 
-const uint16 loft_lut_core0_rev3[] = {
+const u16 loft_lut_core0_rev3[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -8702,7 +8702,7 @@ const uint16 loft_lut_core0_rev3[] = {
 	0x0000,
 };
 
-const uint16 loft_lut_core1_rev3[] = {
+const u16 loft_lut_core1_rev3[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -8833,7 +8833,7 @@ const uint16 loft_lut_core1_rev3[] = {
 	0x0000,
 };
 
-const uint16 papd_comp_rfpwr_tbl_core0_rev3[] = {
+const u16 papd_comp_rfpwr_tbl_core0_rev3[] = {
 	0x0036,
 	0x0036,
 	0x0036,
@@ -8964,7 +8964,7 @@ const uint16 papd_comp_rfpwr_tbl_core0_r
 	0x01d6,
 };
 
-const uint16 papd_comp_rfpwr_tbl_core1_rev3[] = {
+const u16 papd_comp_rfpwr_tbl_core1_rev3[] = {
 	0x0036,
 	0x0036,
 	0x0036,
--- a/drivers/staging/brcm80211/sys/wl_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.c
@@ -765,7 +765,7 @@ static int wl_set_hint(wl_info_t *wl, ch
  * a warning that this function is defined but not used if we declare
  * it as static.
  */
-static wl_info_t *wl_attach(uint16 vendor, uint16 device, unsigned long regs,
+static wl_info_t *wl_attach(u16 vendor, u16 device, unsigned long regs,
 			    uint bustype, void *btparam, uint irq)
 {
 	wl_info_t *wl;
--- a/drivers/staging/brcm80211/sys/wl_ucode.h
+++ b/drivers/staging/brcm80211/sys/wl_ucode.h
@@ -16,8 +16,8 @@
 
 #include <typedefs.h>
 typedef struct d11init {
-	uint16 addr;
-	uint16 size;
+	u16 addr;
+	u16 size;
 	uint32 value;
 } d11init_t;
 
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -90,9 +90,9 @@ uint32 wl_ampdu_dbg =
  * how often and/or when the wlc counters are updated.
  */
 typedef struct wlc_fifo_info {
-	uint16 ampdu_pld_size;	/* number of bytes to be pre-loaded */
+	u16 ampdu_pld_size;	/* number of bytes to be pre-loaded */
 	u8 mcs2ampdu_table[FFPLD_MAX_MCS + 1];	/* per-mcs max # of mpdus in an ampdu */
-	uint16 prev_txfunfl;	/* num of underflows last read from the HW macstats counter */
+	u16 prev_txfunfl;	/* num of underflows last read from the HW macstats counter */
 	uint32 accum_txfunfl;	/* num of underflows since we modified pld params */
 	uint32 accum_txampdu;	/* num of tx ampdu since we modified pld params  */
 	uint32 prev_txampdu;	/* previous reading of tx ampdu */
@@ -158,7 +158,7 @@ static void wlc_ampdu_dotxstatus_complet
 					  uint32 frmtxstatus,
 					  uint32 frmtxstatus2);
 
-static inline uint16 pkt_txh_seqnum(wlc_info_t *wlc, void *p)
+static inline u16 pkt_txh_seqnum(wlc_info_t *wlc, void *p)
 {
 	d11txh_t *txh;
 	struct dot11_header *h;
@@ -173,7 +173,7 @@ ampdu_info_t *BCMATTACHFN(wlc_ampdu_atta
 	int i;
 
 	/* some code depends on packed structures */
-	ASSERT(DOT11_MAXNUMFRAGS == NBITS(uint16));
+	ASSERT(DOT11_MAXNUMFRAGS == NBITS(u16));
 	ASSERT(ISPOWEROF2(AMPDU_TX_BA_MAX_WSIZE));
 	ASSERT(ISPOWEROF2(AMPDU_RX_BA_MAX_WSIZE));
 	ASSERT(wlc->pub->tunables->ampdunummpdu <= AMPDU_MAX_MPDU);
@@ -339,17 +339,17 @@ static int wlc_ffpld_check_txfunfl(wlc_i
 	uint32 txunfl_ratio;
 	u8 max_mpdu;
 	uint32 current_ampdu_cnt = 0;
-	uint16 max_pld_size;
+	u16 max_pld_size;
 	uint32 new_txunfl;
 	wlc_fifo_info_t *fifo = (ampdu->fifo_tb + fid);
 	uint xmtfifo_sz;
-	uint16 cur_txunfl;
+	u16 cur_txunfl;
 
 	/* return if we got here for a different reason than underflows */
 	cur_txunfl =
 	    wlc_read_shm(wlc,
 			 M_UCODE_MACSTAT + OFFSETOF(macstat_t, txfunfl[fid]));
-	new_txunfl = (uint16) (cur_txunfl - fifo->prev_txfunfl);
+	new_txunfl = (u16) (cur_txunfl - fifo->prev_txfunfl);
 	if (new_txunfl == 0) {
 		WL_FFPLD(("check_txunfl : TX status FRAG set but no tx underflows\n"));
 		return -1;
@@ -516,7 +516,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 
 	bool rr = TRUE, fbr = FALSE;
 	uint i, count = 0, fifo, seg_cnt = 0;
-	uint16 plen, len, seq = 0, mcl, mch, index, frameid, dma_len = 0;
+	u16 plen, len, seq = 0, mcl, mch, index, frameid, dma_len = 0;
 	uint32 ampdu_len, maxlen = 0;
 	d11txh_t *txh = NULL;
 	u8 *plcp;
@@ -528,13 +528,13 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 	bool use_rts = FALSE, use_cts = FALSE;
 	ratespec_t rspec = 0, rspec_fallback = 0;
 	ratespec_t rts_rspec = 0, rts_rspec_fallback = 0;
-	uint16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
+	u16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
 	struct dot11_rts_frame *rts;
 	u8 rr_retry_limit;
 	wlc_fifo_info_t *f;
 	bool fbr_iscck;
 	struct ieee80211_tx_info *tx_info;
-	uint16 qlen;
+	u16 qlen;
 
 	wlc = ampdu->wlc;
 	osh = wlc->osh;
@@ -643,7 +643,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 		 * test whether need to break or change the epoch
 		 */
 		if (count == 0) {
-			uint16 fc;
+			u16 fc;
 			mcl |= (TXC_AMPDU_FIRST << TXC_AMPDU_SHIFT);
 			/* refill the bits since might be a retx mpdu */
 			mcl |= TXC_STARTMSDU;
@@ -665,7 +665,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 		len = ROUNDUP(len, 4);
 		ampdu_len += (len + (ndelim + 1) * AMPDU_DELIMITER_LEN);
 
-		dma_len += (uint16) pkttotlen(osh, p);
+		dma_len += (u16) pkttotlen(osh, p);
 
 		WL_AMPDU_TX(("wl%d: wlc_sendampdu: ampdu_len %d seg_cnt %d null delim %d\n", wlc->pub->unit, ampdu_len, seg_cnt, ndelim));
 
@@ -818,13 +818,13 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 
 		/* reset the mixed mode header durations */
 		if (txh->MModeLen) {
-			uint16 mmodelen =
+			u16 mmodelen =
 			    wlc_calc_lsig_len(wlc, rspec, ampdu_len);
 			txh->MModeLen = htol16(mmodelen);
 			preamble_type = WLC_MM_PREAMBLE;
 		}
 		if (txh->MModeFbrLen) {
-			uint16 mmfbrlen =
+			u16 mmfbrlen =
 			    wlc_calc_lsig_len(wlc, rspec_fallback, ampdu_len);
 			txh->MModeFbrLen = htol16(mmfbrlen);
 			fbr_preamble_type = WLC_MM_PREAMBLE;
@@ -841,7 +841,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 
 		/* update RTS dur fields */
 		if (use_rts || use_cts) {
-			uint16 durid;
+			u16 durid;
 			rts = (struct dot11_rts_frame *)&txh->rts_frame;
 			if ((mch & TXC_PREAMBLE_RTS_MAIN_SHORT) ==
 			    TXC_PREAMBLE_RTS_MAIN_SHORT)
@@ -1026,13 +1026,13 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 	d11txh_t *txh;
 	u8 *plcp;
 	struct dot11_header *h;
-	uint16 seq, start_seq = 0, bindex, index, mcl;
+	u16 seq, start_seq = 0, bindex, index, mcl;
 	u8 mcs = 0;
 	bool ba_recd = FALSE, ack_recd = FALSE;
 	u8 suc_mpdu = 0, tot_mpdu = 0;
 	uint supr_status;
 	bool update_rate = TRUE, retry = TRUE, tx_error = FALSE;
-	uint16 mimoantsel = 0;
+	u16 mimoantsel = 0;
 	u8 antselid = 0;
 	u8 retry_limit, rr_retry_limit;
 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(p);
--- a/drivers/staging/brcm80211/sys/wlc_antsel.c
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.c
@@ -61,11 +61,11 @@
 /* static functions */
 static int wlc_antsel_cfgupd(antsel_info_t *asi, wlc_antselcfg_t *antsel);
 static u8 wlc_antsel_id2antcfg(antsel_info_t *asi, u8 id);
-static uint16 wlc_antsel_antcfg2antsel(antsel_info_t *asi, u8 ant_cfg);
+static u16 wlc_antsel_antcfg2antsel(antsel_info_t *asi, u8 ant_cfg);
 static void wlc_antsel_init_cfg(antsel_info_t *asi, wlc_antselcfg_t *antsel,
 				bool auto_sel);
 
-const uint16 mimo_2x4_div_antselpat_tbl[] = {
+const u16 mimo_2x4_div_antselpat_tbl[] = {
 	0, 0, 0x9, 0xa,		/* ant0: 0 ant1: 2,3 */
 	0, 0, 0x5, 0x6,		/* ant0: 1 ant1: 2,3 */
 	0, 0, 0, 0,		/* n.a.              */
@@ -77,7 +77,7 @@ const u8 mimo_2x4_div_antselid_tbl[16] =
 	0, 0, 1, 0, 0, 0, 0, 0	/* pat to antselid */
 };
 
-const uint16 mimo_2x3_div_antselpat_tbl[] = {
+const u16 mimo_2x3_div_antselpat_tbl[] = {
 	16, 0, 1, 16,		/* ant0: 0 ant1: 1,2 */
 	16, 16, 16, 16,		/* n.a.              */
 	16, 2, 16, 16,		/* ant0: 2 ant1: 1   */
@@ -116,13 +116,13 @@ antsel_info_t *BCMNMIATTACHFN(wlc_antsel
 			/* 4321/2 board with 2x3 switch logic */
 			asi->antsel_type = ANTSEL_2x3;
 			/* Antenna selection availability */
-			if (((uint16) getintvar(asi->pub->vars, "aa2g") == 7) ||
-			    ((uint16) getintvar(asi->pub->vars, "aa5g") == 7)) {
+			if (((u16) getintvar(asi->pub->vars, "aa2g") == 7) ||
+			    ((u16) getintvar(asi->pub->vars, "aa5g") == 7)) {
 				asi->antsel_avail = TRUE;
 			} else
-			    if (((uint16) getintvar(asi->pub->vars, "aa2g") ==
+			    if (((u16) getintvar(asi->pub->vars, "aa2g") ==
 				 3)
-				|| ((uint16) getintvar(asi->pub->vars, "aa5g")
+				|| ((u16) getintvar(asi->pub->vars, "aa5g")
 				    == 3)) {
 				asi->antsel_avail = FALSE;
 			} else {
@@ -135,8 +135,8 @@ antsel_info_t *BCMNMIATTACHFN(wlc_antsel
 			break;
 		}
 	} else if ((asi->pub->sromrev == 4) &&
-		   ((uint16) getintvar(asi->pub->vars, "aa2g") == 7) &&
-		   ((uint16) getintvar(asi->pub->vars, "aa5g") == 0)) {
+		   ((u16) getintvar(asi->pub->vars, "aa2g") == 7) &&
+		   ((u16) getintvar(asi->pub->vars, "aa5g") == 0)) {
 		/* hack to match old 4321CB2 cards with 2of3 antenna switch */
 		asi->antsel_type = ANTSEL_2x3;
 		asi->antsel_avail = TRUE;
@@ -235,7 +235,7 @@ wlc_antsel_antcfg_get(antsel_info_t *asi
 }
 
 /* boardlevel antenna selection: convert mimo_antsel (ucode interface) to id */
-u8 wlc_antsel_antsel2id(antsel_info_t *asi, uint16 antsel)
+u8 wlc_antsel_antsel2id(antsel_info_t *asi, u16 antsel)
 {
 	u8 antselid = 0;
 
@@ -273,10 +273,10 @@ static u8 wlc_antsel_id2antcfg(antsel_in
 }
 
 /* boardlevel antenna selection: convert ant_cfg to mimo_antsel (ucode interface) */
-static uint16 wlc_antsel_antcfg2antsel(antsel_info_t *asi, u8 ant_cfg)
+static u16 wlc_antsel_antcfg2antsel(antsel_info_t *asi, u8 ant_cfg)
 {
 	u8 idx = WLC_ANTIDX_11N(WLC_ANTSEL_11N(ant_cfg));
-	uint16 mimo_antsel = 0;
+	u16 mimo_antsel = 0;
 
 	if (asi->antsel_type == ANTSEL_2x4) {
 		/* 2x4 antenna diversity board, 4 cfgs: 0-2 0-3 1-2 1-3 */
@@ -297,7 +297,7 @@ static int wlc_antsel_cfgupd(antsel_info
 {
 	wlc_info_t *wlc = asi->wlc;
 	u8 ant_cfg;
-	uint16 mimo_antsel;
+	u16 mimo_antsel;
 
 	ASSERT(asi->antsel_type != ANTSEL_NA);
 
--- a/drivers/staging/brcm80211/sys/wlc_antsel.h
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.h
@@ -24,5 +24,5 @@ extern void wlc_antsel_init(antsel_info_
 extern void wlc_antsel_antcfg_get(antsel_info_t *asi, bool usedef, bool sel,
 				  u8 id, u8 fbid, u8 *antcfg,
 				  u8 *fbantcfg);
-extern u8 wlc_antsel_antsel2id(antsel_info_t *asi, uint16 antsel);
+extern u8 wlc_antsel_antsel2id(antsel_info_t *asi, u16 antsel);
 #endif				/* _wlc_antsel_h_ */
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -106,7 +106,7 @@
 
 #define XMTFIFOTBL_STARTREV	20	/* Starting corerev for the fifo size table */
 
-static uint16 xmtfifo_sz[][NFIFO] = {
+static u16 xmtfifo_sz[][NFIFO] = {
 	{20, 192, 192, 21, 17, 5},	/* corerev 20: 5120, 49152, 49152, 5376, 4352, 1280 */
 	{9, 58, 22, 14, 14, 5},	/* corerev 21: 2304, 14848, 5632, 3584, 3584, 1280 */
 	{20, 192, 192, 21, 17, 5},	/* corerev 22: 5120, 49152, 49152, 5376, 4352, 1280 */
@@ -134,14 +134,14 @@ static bool wlc_bmac_recv(wlc_hw_info_t
 /* used by wlc_down() */
 static void wlc_flushqueues(wlc_info_t *wlc);
 
-static void wlc_write_mhf(wlc_hw_info_t *wlc_hw, uint16 *mhfs);
+static void wlc_write_mhf(wlc_hw_info_t *wlc_hw, u16 *mhfs);
 static void wlc_mctrl_reset(wlc_hw_info_t *wlc_hw);
 static void wlc_corerev_fifofixup(wlc_hw_info_t *wlc_hw);
 
 /* Low Level Prototypes */
-static uint16 wlc_bmac_read_objmem(wlc_hw_info_t *wlc_hw, uint offset,
+static u16 wlc_bmac_read_objmem(wlc_hw_info_t *wlc_hw, uint offset,
 				   uint32 sel);
-static void wlc_bmac_write_objmem(wlc_hw_info_t *wlc_hw, uint offset, uint16 v,
+static void wlc_bmac_write_objmem(wlc_hw_info_t *wlc_hw, uint offset, u16 v,
 				  uint32 sel);
 static bool wlc_bmac_attach_dmapio(wlc_info_t *wlc, uint j, bool wme);
 static void wlc_bmac_detach_dmapio(wlc_hw_info_t *wlc_hw);
@@ -149,7 +149,7 @@ static void wlc_ucode_bsinit(wlc_hw_info
 static bool wlc_validboardtype(wlc_hw_info_t *wlc);
 static bool wlc_isgoodchip(wlc_hw_info_t *wlc_hw);
 static char *wlc_get_macaddr(wlc_hw_info_t *wlc_hw);
-static void wlc_mhfdef(wlc_info_t *wlc, uint16 *mhfs, uint16 mhf2_init);
+static void wlc_mhfdef(wlc_info_t *wlc, u16 *mhfs, u16 mhf2_init);
 static void wlc_mctrl_write(wlc_hw_info_t *wlc_hw);
 static void wlc_ucode_mute_override_set(wlc_hw_info_t *wlc_hw);
 static void wlc_ucode_mute_override_clear(wlc_hw_info_t *wlc_hw);
@@ -166,7 +166,7 @@ static void wlc_bmac_setband(wlc_hw_info
 			     chanspec_t chanspec);
 static void wlc_bmac_update_slot_timing(wlc_hw_info_t *wlc_hw, bool shortslot);
 static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t *wlc_hw);
-static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t *wlc_hw,
+static u16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t *wlc_hw,
 					     u8 rate);
 
 /* === Low Level functions === */
@@ -572,7 +572,7 @@ BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc
 	uint i;
 	char name[8];
 	/* ucode host flag 2 needed for pio mode, independent of band and fifo */
-	uint16 pio_mhf2 = 0;
+	u16 pio_mhf2 = 0;
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	uint unit = wlc_hw->unit;
 	wlc_tunables_t *tune = wlc->pub->tunables;
@@ -706,7 +706,7 @@ static void BCMATTACHFN(wlc_bmac_detach_
  */
 
 int
-BCMATTACHFN(wlc_bmac_attach) (wlc_info_t *wlc, uint16 vendor, uint16 device,
+BCMATTACHFN(wlc_bmac_attach) (wlc_info_t *wlc, u16 vendor, u16 device,
 			      uint unit, bool piomode, osl_t *osh,
 			      void *regsva, uint bustype, void *btparam) {
 	wlc_hw_info_t *wlc_hw;
@@ -762,12 +762,12 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 
 		var = getvar(vars, "vendid");
 		if (var) {
-			vendor = (uint16) simple_strtoul(var, NULL, 0);
+			vendor = (u16) simple_strtoul(var, NULL, 0);
 			WL_ERROR(("Overriding vendor id = 0x%x\n", vendor));
 		}
 		var = getvar(vars, "devid");
 		if (var) {
-			uint16 devid = (uint16) simple_strtoul(var, NULL, 0);
+			u16 devid = (u16) simple_strtoul(var, NULL, 0);
 			if (devid != 0xffff) {
 				device = devid;
 				WL_ERROR(("Overriding device id = 0x%x\n",
@@ -822,7 +822,7 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 	/* promote srom boardrev of 0xFF to 1 */
 	if (j == BOARDREV_PROMOTABLE)
 		j = BOARDREV_PROMOTED;
-	wlc_hw->boardrev = (uint16) j;
+	wlc_hw->boardrev = (u16) j;
 	if (!wlc_validboardtype(wlc_hw)) {
 		WL_ERROR(("wl%d: wlc_bmac_attach: Unsupported Broadcom board type (0x%x)" " or revision level (0x%x)\n", unit, wlc_hw->sih->boardtype, wlc_hw->boardrev));
 		err = 15;
@@ -1458,11 +1458,11 @@ static void wlc_clkctl_clk(wlc_hw_info_t
 
 /* set initial host flags value */
 static void
-BCMINITFN(wlc_mhfdef) (wlc_info_t *wlc, uint16 *mhfs, uint16 mhf2_init)
+BCMINITFN(wlc_mhfdef) (wlc_info_t *wlc, u16 *mhfs, u16 mhf2_init)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 
-	bzero(mhfs, sizeof(uint16) * MHFMAX);
+	bzero(mhfs, sizeof(u16) * MHFMAX);
 
 	mhfs[MHF2] |= mhf2_init;
 
@@ -1488,11 +1488,11 @@ BCMINITFN(wlc_mhfdef) (wlc_info_t *wlc,
  *                   WLC_BAND_ALL  <--- All bands
  */
 void
-wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, u8 idx, uint16 mask, uint16 val,
+wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, u8 idx, u16 mask, u16 val,
 	     int bands)
 {
-	uint16 save;
-	uint16 addr[MHFMAX] = {
+	u16 save;
+	u16 addr[MHFMAX] = {
 		M_HOST_FLAGS1, M_HOST_FLAGS2, M_HOST_FLAGS3, M_HOST_FLAGS4,
 		M_HOST_FLAGS5
 	};
@@ -1531,7 +1531,7 @@ wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, u8 i
 		if (wlc_hw->clk && (band->mhfs[idx] != save)
 		    && (band == wlc_hw->band))
 			wlc_bmac_write_shm(wlc_hw, addr[idx],
-					   (uint16) band->mhfs[idx]);
+					   (u16) band->mhfs[idx]);
 	}
 
 	if (bands == WLC_BAND_ALL) {
@@ -1542,7 +1542,7 @@ wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, u8 i
 	}
 }
 
-uint16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, u8 idx, int bands)
+u16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, u8 idx, int bands)
 {
 	wlc_hwband_t *band;
 	ASSERT(idx < MHFMAX);
@@ -1568,10 +1568,10 @@ uint16 wlc_bmac_mhf_get(wlc_hw_info_t *w
 	return band->mhfs[idx];
 }
 
-static void wlc_write_mhf(wlc_hw_info_t *wlc_hw, uint16 *mhfs)
+static void wlc_write_mhf(wlc_hw_info_t *wlc_hw, u16 *mhfs)
 {
 	u8 idx;
-	uint16 addr[] = {
+	u16 addr[] = {
 		M_HOST_FLAGS1, M_HOST_FLAGS2, M_HOST_FLAGS3, M_HOST_FLAGS4,
 		M_HOST_FLAGS5
 	};
@@ -1714,10 +1714,10 @@ wlc_bmac_set_rcmta(wlc_hw_info_t *wlc_hw
 		   const struct ether_addr *addr)
 {
 	d11regs_t *regs = wlc_hw->regs;
-	volatile uint16 *objdata16 =
-	    (volatile uint16 *)(uintptr) & regs->objdata;
+	volatile u16 *objdata16 =
+	    (volatile u16 *)(uintptr) & regs->objdata;
 	uint32 mac_hm;
-	uint16 mac_l;
+	u16 mac_l;
 	osl_t *osh;
 
 	WL_TRACE(("wl%d: %s\n", wlc_hw->unit, __func__));
@@ -1748,9 +1748,9 @@ wlc_bmac_set_addrmatch(wlc_hw_info_t *wl
 		       const struct ether_addr *addr)
 {
 	d11regs_t *regs;
-	uint16 mac_l;
-	uint16 mac_m;
-	uint16 mac_h;
+	u16 mac_l;
+	u16 mac_m;
+	u16 mac_h;
 	osl_t *osh;
 
 	WL_TRACE(("wl%d: wlc_bmac_set_addrmatch\n", wlc_hw->unit));
@@ -1780,7 +1780,7 @@ wlc_bmac_write_template_ram(wlc_hw_info_
 	uint32 word;
 	bool be_bit;
 #ifdef IL_BIGENDIAN
-	volatile uint16 *dptr = NULL;
+	volatile u16 *dptr = NULL;
 #endif				/* IL_BIGENDIAN */
 	osl_t *osh;
 
@@ -1816,7 +1816,7 @@ wlc_bmac_write_template_ram(wlc_hw_info_
 	}
 }
 
-void wlc_bmac_set_cwmin(wlc_hw_info_t *wlc_hw, uint16 newmin)
+void wlc_bmac_set_cwmin(wlc_hw_info_t *wlc_hw, u16 newmin)
 {
 	osl_t *osh;
 
@@ -1828,7 +1828,7 @@ void wlc_bmac_set_cwmin(wlc_hw_info_t *w
 	W_REG(osh, &wlc_hw->regs->objdata, newmin);
 }
 
-void wlc_bmac_set_cwmax(wlc_hw_info_t *wlc_hw, uint16 newmax)
+void wlc_bmac_set_cwmax(wlc_hw_info_t *wlc_hw, u16 newmax)
 {
 	osl_t *osh;
 
@@ -1840,7 +1840,7 @@ void wlc_bmac_set_cwmax(wlc_hw_info_t *w
 	W_REG(osh, &wlc_hw->regs->objdata, newmax);
 }
 
-void wlc_bmac_bw_set(wlc_hw_info_t *wlc_hw, uint16 bw)
+void wlc_bmac_bw_set(wlc_hw_info_t *wlc_hw, u16 bw)
 {
 	bool fastclk;
 	uint32 tmp;
@@ -1873,7 +1873,7 @@ wlc_write_hw_bcntemplate0(wlc_hw_info_t
 				    bcn);
 	/* write beacon length to SCR */
 	ASSERT(len < 65536);
-	wlc_bmac_write_shm(wlc_hw, M_BCN0_FRM_BYTESZ, (uint16) len);
+	wlc_bmac_write_shm(wlc_hw, M_BCN0_FRM_BYTESZ, (u16) len);
 	/* mark beacon0 valid */
 	OR_REG(wlc_hw->osh, &regs->maccommand, MCMD_BCN0VLD);
 }
@@ -1887,7 +1887,7 @@ wlc_write_hw_bcntemplate1(wlc_hw_info_t
 				    bcn);
 	/* write beacon length to SCR */
 	ASSERT(len < 65536);
-	wlc_bmac_write_shm(wlc_hw, M_BCN1_FRM_BYTESZ, (uint16) len);
+	wlc_bmac_write_shm(wlc_hw, M_BCN1_FRM_BYTESZ, (u16) len);
 	/* mark beacon1 valid */
 	OR_REG(wlc_hw->osh, &regs->maccommand, MCMD_BCN1VLD);
 }
@@ -1917,7 +1917,7 @@ wlc_bmac_write_hw_bcntemplates(wlc_hw_in
 
 static void WLBANDINITFN(wlc_bmac_upd_synthpu) (wlc_hw_info_t *wlc_hw)
 {
-	uint16 v;
+	u16 v;
 	wlc_info_t *wlc = wlc_hw->wlc;
 	/* update SYNTHPU_DLY */
 
@@ -1964,8 +1964,8 @@ WLBANDINITFN(wlc_bmac_bsinit) (wlc_info_
 				    shortslot);
 
 	/* write phytype and phyvers */
-	wlc_bmac_write_shm(wlc_hw, M_PHYTYPE, (uint16) wlc_hw->band->phytype);
-	wlc_bmac_write_shm(wlc_hw, M_PHYVER, (uint16) wlc_hw->band->phyrev);
+	wlc_bmac_write_shm(wlc_hw, M_PHYTYPE, (u16) wlc_hw->band->phytype);
+	wlc_bmac_write_shm(wlc_hw, M_PHYVER, (u16) wlc_hw->band->phyrev);
 
 	/* initialize the txphyctl1 rate table since shmem is shared between bands */
 	wlc_upd_ofdm_pctl1_table(wlc_hw);
@@ -2302,7 +2302,7 @@ static bool wlc_dma_rxreset(wlc_hw_info_
 
 	if (D11REV_LT(wlc_hw->corerev, 12)) {
 		bool rxidle = TRUE;
-		uint16 rcv_frm_cnt = 0;
+		u16 rcv_frm_cnt = 0;
 
 		osh = wlc_hw->osh;
 
@@ -2420,10 +2420,10 @@ void BCMINITFN(wlc_bmac_corereset) (wlc_
 static void BCMINITFN(wlc_corerev_fifofixup) (wlc_hw_info_t *wlc_hw)
 {
 	d11regs_t *regs = wlc_hw->regs;
-	uint16 fifo_nu;
-	uint16 txfifo_startblk = TXFIFO_START_BLK, txfifo_endblk;
-	uint16 txfifo_def, txfifo_def1;
-	uint16 txfifo_cmd;
+	u16 fifo_nu;
+	u16 txfifo_startblk = TXFIFO_START_BLK, txfifo_endblk;
+	u16 txfifo_def, txfifo_def1;
+	u16 txfifo_cmd;
 	osl_t *osh;
 
 	if (D11REV_LT(wlc_hw->corerev, 9))
@@ -2487,7 +2487,7 @@ static void BCMINITFN(wlc_coreinit) (wlc
 	bool fifosz_fixup = FALSE;
 	osl_t *osh;
 	int err = 0;
-	uint16 buf[NFIFO];
+	u16 buf[NFIFO];
 
 	regs = wlc_hw->regs;
 	osh = wlc_hw->osh;
@@ -2629,14 +2629,14 @@ static void BCMINITFN(wlc_coreinit) (wlc
 	}
 
 	/* tell the ucode the corerev */
-	wlc_bmac_write_shm(wlc_hw, M_MACHW_VER, (uint16) wlc_hw->corerev);
+	wlc_bmac_write_shm(wlc_hw, M_MACHW_VER, (u16) wlc_hw->corerev);
 
 	/* tell the ucode MAC capabilities */
 	if (D11REV_GE(wlc_hw->corerev, 13)) {
 		wlc_bmac_write_shm(wlc_hw, M_MACHW_CAP_L,
-				   (uint16) (wlc_hw->machwcap & 0xffff));
+				   (u16) (wlc_hw->machwcap & 0xffff));
 		wlc_bmac_write_shm(wlc_hw, M_MACHW_CAP_H,
-				   (uint16) ((wlc_hw->
+				   (u16) ((wlc_hw->
 					      machwcap >> 16) & 0xffff));
 	}
 
@@ -2849,7 +2849,7 @@ static void wlc_write_inits(wlc_hw_info_
 		ASSERT((inits[i].size == 2) || (inits[i].size == 4));
 
 		if (inits[i].size == 2)
-			W_REG(osh, (uint16 *) (uintptr) (base + inits[i].addr),
+			W_REG(osh, (u16 *) (uintptr) (base + inits[i].addr),
 			      inits[i].value);
 		else if (inits[i].size == 4)
 			W_REG(osh, (uint32 *) (uintptr) (base + inits[i].addr),
@@ -2859,9 +2859,9 @@ static void wlc_write_inits(wlc_hw_info_
 
 static void wlc_ucode_txant_set(wlc_hw_info_t *wlc_hw)
 {
-	uint16 phyctl;
-	uint16 phytxant = wlc_hw->bmac_phytxant;
-	uint16 mask = PHY_TXC_ANT_MASK;
+	u16 phyctl;
+	u16 phytxant = wlc_hw->bmac_phytxant;
+	u16 mask = PHY_TXC_ANT_MASK;
 
 	/* set the Probe Response frame phy control word */
 	phyctl = wlc_bmac_read_shm(wlc_hw, M_CTXPRS_BLK + C_CTX_PCTLWD_POS);
@@ -2874,7 +2874,7 @@ static void wlc_ucode_txant_set(wlc_hw_i
 	wlc_bmac_write_shm(wlc_hw, M_RSP_PCTLWD, phyctl);
 }
 
-void wlc_bmac_txant_set(wlc_hw_info_t *wlc_hw, uint16 phytxant)
+void wlc_bmac_txant_set(wlc_hw_info_t *wlc_hw, u16 phytxant)
 {
 	/* update sw state */
 	wlc_hw->bmac_phytxant = phytxant;
@@ -2886,9 +2886,9 @@ void wlc_bmac_txant_set(wlc_hw_info_t *w
 
 }
 
-uint16 wlc_bmac_get_txant(wlc_hw_info_t *wlc_hw)
+u16 wlc_bmac_get_txant(wlc_hw_info_t *wlc_hw)
 {
-	return (uint16) wlc_hw->wlc->stf->txant;
+	return (u16) wlc_hw->wlc->stf->txant;
 }
 
 void wlc_bmac_antsel_type_set(wlc_hw_info_t *wlc_hw, u8 antsel_type)
@@ -3081,8 +3081,8 @@ int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_
 	if (fifo >= NFIFO || blocks > 299)
 		return BCME_RANGE;
 
-	/* BMAC_NOTE, change blocks to uint16 */
-	wlc_hw->xmtfifo_sz[fifo] = (uint16) blocks;
+	/* BMAC_NOTE, change blocks to u16 */
+	wlc_hw->xmtfifo_sz[fifo] = (u16) blocks;
 
 	return 0;
 }
@@ -3587,8 +3587,8 @@ static void wlc_upd_ofdm_pctl1_table(wlc
 		WLC_RATE_6M, WLC_RATE_9M, WLC_RATE_12M, WLC_RATE_18M,
 		WLC_RATE_24M, WLC_RATE_36M, WLC_RATE_48M, WLC_RATE_54M
 	};
-	uint16 entry_ptr;
-	uint16 pctl1;
+	u16 entry_ptr;
+	u16 pctl1;
 	uint i;
 
 	if (!WLC_PHY_11N_CAP(wlc_hw->band))
@@ -3614,7 +3614,7 @@ static void wlc_upd_ofdm_pctl1_table(wlc
 	}
 }
 
-static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t *wlc_hw, u8 rate)
+static u16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t *wlc_hw, u8 rate)
 {
 	uint i;
 	u8 plcp_rate = 0;
@@ -3672,7 +3672,7 @@ bool BCMATTACHFN(wlc_bmac_validate_chip_
 {
 	d11regs_t *regs;
 	uint32 w, val;
-	volatile uint16 *reg16;
+	volatile u16 *reg16;
 	osl_t *osh;
 
 	WL_TRACE(("wl%d: validate_chip_access\n", wlc_hw->unit));
@@ -3719,7 +3719,7 @@ bool BCMATTACHFN(wlc_bmac_validate_chip_
 		/* if 32 bit writes are split into 16 bit writes, are they in the correct order
 		 * for our interface, low to high
 		 */
-		reg16 = (volatile uint16 *)(uintptr) & regs->tsf_cfpstart;
+		reg16 = (volatile u16 *)(uintptr) & regs->tsf_cfpstart;
 
 		/* write the CFPStart register low half explicitly, starting a buffered write */
 		W_REG(osh, reg16, 0xAAAA);
@@ -3903,12 +3903,12 @@ static void wlc_flushqueues(wlc_info_t *
 		dma_rxreclaim(wlc_hw->di[RX_TXSTATUS_FIFO]);
 }
 
-uint16 wlc_bmac_read_shm(wlc_hw_info_t *wlc_hw, uint offset)
+u16 wlc_bmac_read_shm(wlc_hw_info_t *wlc_hw, uint offset)
 {
 	return wlc_bmac_read_objmem(wlc_hw, offset, OBJADDR_SHM_SEL);
 }
 
-void wlc_bmac_write_shm(wlc_hw_info_t *wlc_hw, uint offset, uint16 v)
+void wlc_bmac_write_shm(wlc_hw_info_t *wlc_hw, uint offset, u16 v)
 {
 	wlc_bmac_write_objmem(wlc_hw, offset, v, OBJADDR_SHM_SEL);
 }
@@ -3917,7 +3917,7 @@ void wlc_bmac_write_shm(wlc_hw_info_t *w
  * SHM 'offset' needs to be an even address and
  * Buffer length 'len' must be an even number of bytes
  */
-void wlc_bmac_set_shm(wlc_hw_info_t *wlc_hw, uint offset, uint16 v, int len)
+void wlc_bmac_set_shm(wlc_hw_info_t *wlc_hw, uint offset, u16 v, int len)
 {
 	int i;
 
@@ -3933,14 +3933,14 @@ void wlc_bmac_set_shm(wlc_hw_info_t *wlc
 	}
 }
 
-static uint16
+static u16
 wlc_bmac_read_objmem(wlc_hw_info_t *wlc_hw, uint offset, uint32 sel)
 {
 	d11regs_t *regs = wlc_hw->regs;
-	volatile uint16 *objdata_lo =
-	    (volatile uint16 *)(uintptr) & regs->objdata;
-	volatile uint16 *objdata_hi = objdata_lo + 1;
-	uint16 v;
+	volatile u16 *objdata_lo =
+	    (volatile u16 *)(uintptr) & regs->objdata;
+	volatile u16 *objdata_hi = objdata_lo + 1;
+	u16 v;
 
 	ASSERT((offset & 1) == 0);
 
@@ -3956,12 +3956,12 @@ wlc_bmac_read_objmem(wlc_hw_info_t *wlc_
 }
 
 static void
-wlc_bmac_write_objmem(wlc_hw_info_t *wlc_hw, uint offset, uint16 v, uint32 sel)
+wlc_bmac_write_objmem(wlc_hw_info_t *wlc_hw, uint offset, u16 v, uint32 sel)
 {
 	d11regs_t *regs = wlc_hw->regs;
-	volatile uint16 *objdata_lo =
-	    (volatile uint16 *)(uintptr) & regs->objdata;
-	volatile uint16 *objdata_hi = objdata_lo + 1;
+	volatile u16 *objdata_lo =
+	    (volatile u16 *)(uintptr) & regs->objdata;
+	volatile u16 *objdata_hi = objdata_lo + 1;
 
 	ASSERT((offset & 1) == 0);
 
@@ -3983,7 +3983,7 @@ void
 wlc_bmac_copyto_objmem(wlc_hw_info_t *wlc_hw, uint offset, const void *buf,
 		       int len, uint32 sel)
 {
-	uint16 v;
+	u16 v;
 	const u8 *p = (const u8 *)buf;
 	int i;
 
@@ -4009,7 +4009,7 @@ void
 wlc_bmac_copyfrom_objmem(wlc_hw_info_t *wlc_hw, uint offset, void *buf,
 			 int len, uint32 sel)
 {
-	uint16 v;
+	u16 v;
 	u8 *p = (u8 *) buf;
 	int i;
 
@@ -4036,7 +4036,7 @@ void wlc_bmac_copyfrom_vars(wlc_hw_info_
 	*len = wlc_hw->vars_size;
 }
 
-void wlc_bmac_retrylimit_upd(wlc_hw_info_t *wlc_hw, uint16 SRL, uint16 LRL)
+void wlc_bmac_retrylimit_upd(wlc_hw_info_t *wlc_hw, u16 SRL, u16 LRL)
 {
 	wlc_hw->SRL = SRL;
 	wlc_hw->LRL = LRL;
@@ -4178,9 +4178,9 @@ bool wlc_bmac_radio_hw(wlc_hw_info_t *wl
 	return TRUE;
 }
 
-uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, u8 rate)
+u16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, u8 rate)
 {
-	uint16 table_ptr;
+	u16 table_ptr;
 	u8 phy_rate, index;
 
 	/* get the phy specific rate encoding for the PLCP SIGNAL field */
--- a/drivers/staging/brcm80211/sys/wlc_bmac.h
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.h
@@ -130,7 +130,7 @@ typedef enum {
 	WLCHW_STATE_LAST
 } wlc_bmac_state_id_t;
 
-extern int wlc_bmac_attach(wlc_info_t *wlc, uint16 vendor, uint16 device,
+extern int wlc_bmac_attach(wlc_info_t *wlc, u16 vendor, u16 device,
 			   uint unit, bool piomode, osl_t *osh, void *regsva,
 			   uint bustype, void *btparam);
 extern int wlc_bmac_detach(wlc_info_t *wlc);
@@ -175,24 +175,24 @@ extern void wlc_bmac_set_chanspec(wlc_hw
 				  bool mute, struct txpwr_limits *txpwr);
 
 extern void wlc_bmac_txfifo(wlc_hw_info_t *wlc_hw, uint fifo, void *p,
-			    bool commit, uint16 frameid, u8 txpktpend);
+			    bool commit, u16 frameid, u8 txpktpend);
 extern int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t *wlc_hw, uint fifo,
 				   uint *blocks);
-extern void wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, u8 idx, uint16 mask,
-			 uint16 val, int bands);
+extern void wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, u8 idx, u16 mask,
+			 u16 val, int bands);
 extern void wlc_bmac_mctrl(wlc_hw_info_t *wlc_hw, uint32 mask, uint32 val);
-extern uint16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, u8 idx, int bands);
+extern u16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, u8 idx, int bands);
 extern int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t *wlc_hw, uint fifo,
 				   uint blocks);
-extern void wlc_bmac_txant_set(wlc_hw_info_t *wlc_hw, uint16 phytxant);
-extern uint16 wlc_bmac_get_txant(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_txant_set(wlc_hw_info_t *wlc_hw, u16 phytxant);
+extern u16 wlc_bmac_get_txant(wlc_hw_info_t *wlc_hw);
 extern void wlc_bmac_antsel_type_set(wlc_hw_info_t *wlc_hw, u8 antsel_type);
 extern int wlc_bmac_revinfo_get(wlc_hw_info_t *wlc_hw,
 				wlc_bmac_revinfo_t *revinfo);
 extern int wlc_bmac_state_get(wlc_hw_info_t *wlc_hw, wlc_bmac_state_t *state);
-extern void wlc_bmac_write_shm(wlc_hw_info_t *wlc_hw, uint offset, uint16 v);
-extern uint16 wlc_bmac_read_shm(wlc_hw_info_t *wlc_hw, uint offset);
-extern void wlc_bmac_set_shm(wlc_hw_info_t *wlc_hw, uint offset, uint16 v,
+extern void wlc_bmac_write_shm(wlc_hw_info_t *wlc_hw, uint offset, u16 v);
+extern u16 wlc_bmac_read_shm(wlc_hw_info_t *wlc_hw, uint offset);
+extern void wlc_bmac_set_shm(wlc_hw_info_t *wlc_hw, uint offset, u16 v,
 			     int len);
 extern void wlc_bmac_write_template_ram(wlc_hw_info_t *wlc_hw, int offset,
 					int len, void *buf);
@@ -232,20 +232,20 @@ extern void wlc_bmac_write_hw_bcntemplat
 
 extern void wlc_bmac_read_tsf(wlc_hw_info_t *wlc_hw, uint32 *tsf_l_ptr,
 			      uint32 *tsf_h_ptr);
-extern void wlc_bmac_set_cwmin(wlc_hw_info_t *wlc_hw, uint16 newmin);
-extern void wlc_bmac_set_cwmax(wlc_hw_info_t *wlc_hw, uint16 newmax);
+extern void wlc_bmac_set_cwmin(wlc_hw_info_t *wlc_hw, u16 newmin);
+extern void wlc_bmac_set_cwmax(wlc_hw_info_t *wlc_hw, u16 newmax);
 extern void wlc_bmac_set_noreset(wlc_hw_info_t *wlc, bool noreset_flag);
 extern void wlc_bmac_set_ucode_loaded(wlc_hw_info_t *wlc, bool ucode_loaded);
 
-extern void wlc_bmac_retrylimit_upd(wlc_hw_info_t *wlc_hw, uint16 SRL,
-				    uint16 LRL);
+extern void wlc_bmac_retrylimit_upd(wlc_hw_info_t *wlc_hw, u16 SRL,
+				    u16 LRL);
 
 extern void wlc_bmac_fifoerrors(wlc_hw_info_t *wlc_hw);
 
 #ifdef WLC_HIGH_ONLY
 extern void wlc_bmac_dngl_reboot(rpc_info_t *);
-extern void wlc_bmac_dngl_rpc_agg(rpc_info_t *, uint16 agg);
-extern void wlc_bmac_dngl_rpc_msglevel(rpc_info_t *, uint16 level);
+extern void wlc_bmac_dngl_rpc_agg(rpc_info_t *, u16 agg);
+extern void wlc_bmac_dngl_rpc_msglevel(rpc_info_t *, u16 level);
 extern void wlc_bmac_dngl_rpc_txq_wm_set(rpc_info_t *rpc, uint32 wm);
 extern void wlc_bmac_dngl_rpc_txq_wm_get(rpc_info_t *rpc, uint32 *wm);
 extern void wlc_bmac_dngl_rpc_agg_limit_set(rpc_info_t *rpc, uint32 val);
@@ -255,7 +255,7 @@ extern int wlc_bmac_debug_template(wlc_h
 
 /* API for BMAC driver (e.g. wlc_phy.c etc) */
 
-extern void wlc_bmac_bw_set(wlc_hw_info_t *wlc_hw, uint16 bw);
+extern void wlc_bmac_bw_set(wlc_hw_info_t *wlc_hw, u16 bw);
 extern void wlc_bmac_pllreq(wlc_hw_info_t *wlc_hw, bool set, mbool req_bit);
 extern void wlc_bmac_set_clk(wlc_hw_info_t *wlc_hw, bool on);
 extern bool wlc_bmac_taclear(wlc_hw_info_t *wlc_hw, bool ta_ok);
@@ -266,7 +266,7 @@ extern void wlc_bmac_dump(wlc_hw_info_t
 extern void wlc_gpio_fast_deinit(wlc_hw_info_t *wlc_hw);
 
 extern bool wlc_bmac_radio_hw(wlc_hw_info_t *wlc_hw, bool enable);
-extern uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, u8 rate);
+extern u16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, u8 rate);
 
 extern void wlc_bmac_assert_type_set(wlc_hw_info_t *wlc_hw, uint32 type);
 extern void wlc_bmac_set_txpwr_percent(wlc_hw_info_t *wlc_hw, u8 val);
--- a/drivers/staging/brcm80211/sys/wlc_bsscfg.h
+++ b/drivers/staging/brcm80211/sys/wlc_bsscfg.h
@@ -78,7 +78,7 @@ struct wlc_bsscfg {
 	int16 openshared;	/* try Open auth first, then Shared Key */
 	bool wsec_restrict;	/* drop unencrypted packets if wsec is enabled */
 	bool eap_restrict;	/* restrict data until 802.1X auth succeeds */
-	uint16 WPA_auth;	/* WPA: authenticated key management */
+	u16 WPA_auth;	/* WPA: authenticated key management */
 	bool wpa2_preauth;	/* default is TRUE, wpa_cap sets value */
 	bool wsec_portopen;	/* indicates keys are plumbed */
 	wsec_iv_t wpa_none_txiv;	/* global txiv for WPA_NONE, tkip and aes */
@@ -94,8 +94,8 @@ struct wlc_bsscfg {
 
 	struct ether_addr BSSID;	/* BSSID (associated) */
 	struct ether_addr cur_etheraddr;	/* h/w address */
-	uint16 bcmc_fid;	/* the last BCMC FID queued to TX_BCMC_FIFO */
-	uint16 bcmc_fid_shm;	/* the last BCMC FID written to shared mem */
+	u16 bcmc_fid;	/* the last BCMC FID queued to TX_BCMC_FIFO */
+	u16 bcmc_fid_shm;	/* the last BCMC FID written to shared mem */
 
 	uint32 flags;		/* WLC_BSSCFG flags; see below */
 
@@ -125,7 +125,7 @@ struct wlc_bsscfg {
 	wsec_key_t *rcmta;
 
 	/* 'unique' ID of this bsscfg, assigned at bsscfg allocation */
-	uint16 ID;
+	u16 ID;
 
 	uint txrspecidx;	/* index into tx rate circular buffer */
 	ratespec_t txrspec[NTXRATE][2];	/* circular buffer of prev MPDUs tx rates */
--- a/drivers/staging/brcm80211/sys/wlc_event.h
+++ b/drivers/staging/brcm80211/sys/wlc_event.h
@@ -44,8 +44,8 @@ extern void wlc_assign_event_msg(wlc_inf
 
 #ifdef MSGTRACE
 extern void wlc_event_sendup_trace(struct wlc_info *wlc, hndrte_dev_t *bus,
-				   u8 *hdr, uint16 hdrlen, u8 *buf,
-				   uint16 buflen);
+				   u8 *hdr, u16 hdrlen, u8 *buf,
+				   u16 buflen);
 #endif
 
 #endif				/* _WLC_EVENT_H_ */
--- a/drivers/staging/brcm80211/sys/wlc_key.h
+++ b/drivers/staging/brcm80211/sys/wlc_key.h
@@ -81,7 +81,7 @@ struct wlc_bsscfg;
 
 typedef struct wsec_iv {
 	uint32 hi;		/* upper 32 bits of IV */
-	uint16 lo;		/* lower 16 bits of IV */
+	u16 lo;		/* lower 16 bits of IV */
 } wsec_iv_t;
 
 #define WLC_NUMRXIVS	16	/* # rx IVs (one per 802.11e TID) */
@@ -92,7 +92,7 @@ typedef struct wsec_key {
 	u8 id;		/* key ID [0-3] */
 	u8 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
 	u8 rcmta;		/* rcmta entry index, same as idx by default */
-	uint16 flags;		/* misc flags */
+	u16 flags;		/* misc flags */
 	u8 algo_hw;		/* cache for hw register */
 	u8 aes_mode;		/* cache for hw register */
 	s8 iv_len;		/* IV length */
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -250,7 +250,7 @@ static const u8 acbitmap2maxprio[] = {
 
 /* local prototypes */
 extern void wlc_txq_enq(void *ctx, struct scb *scb, void *sdu, uint prec);
-static uint16 BCMFASTPATH wlc_d11hdrs_mac80211(wlc_info_t *wlc,
+static u16 BCMFASTPATH wlc_d11hdrs_mac80211(wlc_info_t *wlc,
 					       struct ieee80211_hw *hw, void *p,
 					       struct scb *scb, uint frag,
 					       uint nfrags, uint queue,
@@ -277,12 +277,12 @@ static void wlc_txq_free(wlc_info_t *wlc
 static void wlc_txflowcontrol_signal(wlc_info_t *wlc, wlc_txq_info_t *qi,
 				     bool on, int prio);
 static void wlc_txflowcontrol_reset(wlc_info_t *wlc);
-static uint16 wlc_compute_airtime(wlc_info_t *wlc, ratespec_t rspec,
+static u16 wlc_compute_airtime(wlc_info_t *wlc, ratespec_t rspec,
 				  uint length);
 static void wlc_compute_cck_plcp(ratespec_t rate, uint length, u8 *plcp);
 static void wlc_compute_ofdm_plcp(ratespec_t rate, uint length, u8 *plcp);
 static void wlc_compute_mimo_plcp(ratespec_t rate, uint length, u8 *plcp);
-static uint16 wlc_compute_frame_dur(wlc_info_t *wlc, ratespec_t rate,
+static u16 wlc_compute_frame_dur(wlc_info_t *wlc, ratespec_t rate,
 				    u8 preamble_type, uint next_frag_len);
 static void wlc_recvctl(wlc_info_t *wlc, osl_t *osh, d11rxhdr_t *rxh,
 			void *p);
@@ -348,7 +348,7 @@ void wlc_get_rcmta(wlc_info_t *wlc, int
 	addr->octet[3] = (u8) (v32 >> 24);
 	W_REG(osh, &regs->objaddr, (OBJADDR_RCMTA_SEL | ((idx * 2) + 1)));
 	(void)R_REG(osh, &regs->objaddr);
-	v32 = R_REG(osh, (volatile uint16 *)(uintptr) & regs->objdata);
+	v32 = R_REG(osh, (volatile u16 *)(uintptr) & regs->objdata);
 	addr->octet[4] = (u8) v32;
 	addr->octet[5] = (u8) (v32 >> 8);
 }
@@ -559,7 +559,7 @@ void BCMINITFN(wlc_init) (wlc_info_t *wl
 	/* read the ucode version if we have not yet done so */
 	if (wlc->ucode_rev == 0) {
 		wlc->ucode_rev =
-		    wlc_read_shm(wlc, M_BOM_REV_MAJOR) << NBITS(uint16);
+		    wlc_read_shm(wlc, M_BOM_REV_MAJOR) << NBITS(u16);
 		wlc->ucode_rev |= wlc_read_shm(wlc, M_BOM_REV_MINOR);
 	}
 
@@ -1153,9 +1153,9 @@ ratespec_t wlc_lowest_basic_rspec(wlc_in
  */
 void wlc_beacon_phytxctl_txant_upd(wlc_info_t *wlc, ratespec_t bcn_rspec)
 {
-	uint16 phyctl;
-	uint16 phytxant = wlc->stf->phytxant;
-	uint16 mask = PHY_TXC_ANT_MASK;
+	u16 phyctl;
+	u16 phytxant = wlc->stf->phytxant;
+	u16 mask = PHY_TXC_ANT_MASK;
 
 	/* for non-siso rates or default setting, use the available chains */
 	if (WLC_PHY_11N_CAP(wlc->band)) {
@@ -1393,7 +1393,7 @@ void wlc_wme_setparams(wlc_info_t *wlc,
 {
 	int i;
 	shm_acparams_t acp_shm;
-	uint16 *shm_entry;
+	u16 *shm_entry;
 	struct ieee80211_tx_queue_params *params = arg;
 
 	ASSERT(wlc);
@@ -1451,7 +1451,7 @@ void wlc_wme_setparams(wlc_info_t *wlc,
 		acp_shm.status |= WME_STATUS_NEWAC;
 
 		/* Fill in shm acparam table */
-		shm_entry = (uint16 *) &acp_shm;
+		shm_entry = (u16 *) &acp_shm;
 		for (i = 0; i < (int)sizeof(shm_acparams_t); i += 2)
 			wlc_write_shm(wlc,
 				      M_EDCF_QINFO +
@@ -1474,7 +1474,7 @@ void wlc_edcf_setparams(wlc_bsscfg_t *cf
 	uint aci, i, j;
 	edcf_acparam_t *edcf_acp;
 	shm_acparams_t acp_shm;
-	uint16 *shm_entry;
+	u16 *shm_entry;
 
 	ASSERT(cfg);
 	ASSERT(wlc);
@@ -1538,7 +1538,7 @@ void wlc_edcf_setparams(wlc_bsscfg_t *cf
 		acp_shm.status |= WME_STATUS_NEWAC;
 
 		/* Fill in shm acparam table */
-		shm_entry = (uint16 *) &acp_shm;
+		shm_entry = (u16 *) &acp_shm;
 		for (j = 0; j < (int)sizeof(shm_acparams_t); j += 2)
 			wlc_write_shm(wlc,
 				      M_EDCF_QINFO +
@@ -1760,7 +1760,7 @@ wlc_pub_t *wlc_pub(void *wlc)
 /*
  * The common driver entry routine. Error codes should be unique
  */
-void *BCMATTACHFN(wlc_attach) (void *wl, uint16 vendor, uint16 device,
+void *BCMATTACHFN(wlc_attach) (void *wl, u16 vendor, u16 device,
 			       uint unit, bool piomode, osl_t *osh,
 			       void *regsva, uint bustype, void *btparam,
 			       uint *perr) {
@@ -1869,9 +1869,9 @@ void *BCMATTACHFN(wlc_attach) (void *wl,
 
 	/* set maximum allowed duty cycle */
 	wlc->tx_duty_cycle_ofdm =
-	    (uint16) getintvar(pub->vars, "tx_duty_cycle_ofdm");
+	    (u16) getintvar(pub->vars, "tx_duty_cycle_ofdm");
 	wlc->tx_duty_cycle_cck =
-	    (uint16) getintvar(pub->vars, "tx_duty_cycle_cck");
+	    (u16) getintvar(pub->vars, "tx_duty_cycle_cck");
 
 	wlc_stf_phy_chain_calc(wlc);
 
@@ -2146,7 +2146,7 @@ static bool BCMATTACHFN(wlc_attach_stf_a
 #ifdef WLC_HIGH_ONLY
 /* HIGH_ONLY bmac_attach, which sync over LOW_ONLY bmac_attach states */
 int
-BCMATTACHFN(wlc_bmac_attach) (wlc_info_t *wlc, uint16 vendor, uint16 device,
+BCMATTACHFN(wlc_bmac_attach) (wlc_info_t *wlc, u16 vendor, u16 device,
 			      uint unit, bool piomode, osl_t *osh,
 			      void *regsva, uint bustype, void *btparam) {
 	wlc_bmac_revinfo_t revinfo;
@@ -2192,10 +2192,10 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 	bzero(&revinfo, sizeof(wlc_bmac_revinfo_t));
 	if (wlc_bmac_revinfo_get(wlc->hw, &revinfo) != 0)
 		return -1;
-	wlc->vendorid = (uint16) revinfo.vendorid;
-	wlc->deviceid = (uint16) revinfo.deviceid;
+	wlc->vendorid = (u16) revinfo.vendorid;
+	wlc->deviceid = (u16) revinfo.deviceid;
 
-	wlc->pub->boardrev = (uint16) revinfo.boardrev;
+	wlc->pub->boardrev = (u16) revinfo.boardrev;
 	wlc->pub->corerev = revinfo.corerev;
 	wlc->pub->sromrev = (u8) revinfo.sromrev;
 	wlc->pub->sih->chiprev = revinfo.chiprev;
@@ -2227,11 +2227,11 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 		wlc->bandstate[bandunit]->radiorev =
 		    (u8) revinfo.band[idx].radiorev;
 		wlc->bandstate[bandunit]->phytype =
-		    (uint16) revinfo.band[idx].phytype;
+		    (u16) revinfo.band[idx].phytype;
 		wlc->bandstate[bandunit]->phyrev =
-		    (uint16) revinfo.band[idx].phyrev;
+		    (u16) revinfo.band[idx].phyrev;
 		wlc->bandstate[bandunit]->radioid =
-		    (uint16) revinfo.band[idx].radioid;
+		    (u16) revinfo.band[idx].radioid;
 		wlc->bandstate[bandunit]->abgphy_encore =
 		    revinfo.band[idx].abgphy_encore;
 
@@ -2838,7 +2838,7 @@ int BCMINITFN(wlc_up) (wlc_info_t *wlc)
 static void BCMINITFN(wlc_tx_prec_map_init) (wlc_info_t *wlc)
 {
 	wlc->tx_prec_map = WLC_PREC_BMP_ALL;
-	bzero(wlc->fifo2prec_map, sizeof(uint16) * NFIFO);
+	bzero(wlc->fifo2prec_map, sizeof(u16) * NFIFO);
 
 	/* For non-WME, both fifos have overlapping MAXPRIO. So just disable all precedences
 	 * if either is full.
@@ -3449,13 +3449,13 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		if (bcmerror)
 			break;
 
-		i = (uint16) val;
+		i = (u16) val;
 		if (i >= MHFMAX) {
 			bcmerror = BCME_RANGE;
 			break;
 		}
 
-		wlc_mhf(wlc, (u8) i, 0xffff, (uint16) (val >> NBITS(uint16)),
+		wlc_mhf(wlc, (u8) i, 0xffff, (u16) (val >> NBITS(u16)),
 			WLC_BAND_AUTO);
 		break;
 
@@ -3477,7 +3477,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			break;
 		}
 
-		*pval = wlc_read_shm(wlc, (uint16) val);
+		*pval = wlc_read_shm(wlc, (u16) val);
 		break;
 
 	case WLC_SET_SHMEM:
@@ -3498,8 +3498,8 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			break;
 		}
 
-		wlc_write_shm(wlc, (uint16) val,
-			      (uint16) (val >> NBITS(uint16)));
+		wlc_write_shm(wlc, (u16) val,
+			      (u16) (val >> NBITS(u16)));
 		break;
 
 	case WLC_R_REG:	/* MAC registers */
@@ -3529,10 +3529,10 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			    R_REG(osh,
 				  (uint32 *) ((unsigned char *) (uintptr) regs +
 					      r->byteoff));
-		else if (r->size == sizeof(uint16))
+		else if (r->size == sizeof(u16))
 			r->val =
 			    R_REG(osh,
-				  (uint16 *) ((unsigned char *) (uintptr) regs +
+				  (u16 *) ((unsigned char *) (uintptr) regs +
 					      r->byteoff));
 		else
 			bcmerror = BCME_BADADDR;
@@ -3564,9 +3564,9 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			W_REG(osh,
 			      (uint32 *) ((unsigned char *) (uintptr) regs +
 					  r->byteoff), r->val);
-		else if (r->size == sizeof(uint16))
+		else if (r->size == sizeof(u16))
 			W_REG(osh,
-			      (uint16 *) ((unsigned char *) (uintptr) regs +
+			      (u16 *) ((unsigned char *) (uintptr) regs +
 					  r->byteoff), r->val);
 		else
 			bcmerror = BCME_BADADDR;
@@ -3629,7 +3629,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		break;
 
 	case WLC_GET_RX_ANT:{	/* get latest used rx antenna */
-			uint16 rxstatus;
+			u16 rxstatus;
 
 			if (!wlc->pub->up) {
 				bcmerror = BCME_NOTUP;
@@ -3637,7 +3637,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			}
 
 			rxstatus = R_REG(wlc->osh, &wlc->regs->phyrxstatus0);
-			if (rxstatus == 0xdead || rxstatus == (uint16) -1) {
+			if (rxstatus == 0xdead || rxstatus == (u16) -1) {
 				bcmerror = BCME_ERROR;
 				break;
 			}
@@ -3689,7 +3689,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 	case WLC_SET_SRL:
 		if (val >= 1 && val <= RETRY_SHORT_MAX) {
 			int ac;
-			wlc->SRL = (uint16) val;
+			wlc->SRL = (u16) val;
 
 			wlc_bmac_retrylimit_upd(wlc->hw, wlc->SRL, wlc->LRL);
 
@@ -3708,7 +3708,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 	case WLC_SET_LRL:
 		if (val >= 1 && val <= 255) {
 			int ac;
-			wlc->LRL = (uint16) val;
+			wlc->LRL = (u16) val;
 
 			wlc_bmac_retrylimit_upd(wlc->hw, wlc->SRL, wlc->LRL);
 
@@ -3731,7 +3731,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		}
 
 		if (val >= 1 && val <= 255) {
-			wlc_set_cwmin(wlc, (uint16) val);
+			wlc_set_cwmin(wlc, (u16) val);
 		} else
 			bcmerror = BCME_RANGE;
 		break;
@@ -3747,7 +3747,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		}
 
 		if (val >= 255 && val <= 2047) {
-			wlc_set_cwmax(wlc, (uint16) val);
+			wlc_set_cwmax(wlc, (u16) val);
 		} else
 			bcmerror = BCME_RANGE;
 		break;
@@ -3759,7 +3759,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 	case WLC_SET_RADIO:{	/* 32 bits input, higher 16 bits are mask, lower 16 bits are value to
 				 * set
 				 */
-			uint16 radiomask, radioval;
+			u16 radiomask, radioval;
 			uint validbits =
 			    WL_RADIO_SW_DISABLE | WL_RADIO_HW_DISABLE;
 			mbool new = 0;
@@ -3845,7 +3845,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			if ((val >= 0) && (val < WLC_MAX_WSEC_KEYS(wlc)) &&
 				(key != NULL)) {
 				u8 seq[DOT11_WPA_KEY_RSC_LEN];
-				uint16 lo;
+				u16 lo;
 				uint32 hi;
 				/* group keys in WPA-NONE (IBSS only, AES and TKIP) use a global TXIV */
 				if ((bsscfg->WPA_auth & WPA_AUTH_NONE)
@@ -3961,7 +3961,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		/* range [1, 0xffff] */
 		if (val >= DOT11_MIN_BEACON_PERIOD
 		    && val <= DOT11_MAX_BEACON_PERIOD) {
-			wlc->default_bss->beacon_period = (uint16) val;
+			wlc->default_bss->beacon_period = (u16) val;
 		} else
 			bcmerror = BCME_RANGE;
 		break;
@@ -4085,9 +4085,9 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 	case WLC_SET_WPA_AUTH:
 		/* change of WPA_Auth modifies the PS_ALLOWED state */
 		if (BSSCFG_STA(bsscfg)) {
-			bsscfg->WPA_auth = (uint16) val;
+			bsscfg->WPA_auth = (u16) val;
 		} else
-			bsscfg->WPA_auth = (uint16) val;
+			bsscfg->WPA_auth = (u16) val;
 		break;
 #endif				/* SUPPORT_HWKEY */
 
@@ -4320,7 +4320,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			bcmerror = BCME_RANGE;	/* bad value */
 			break;
 		}
-		wlc->prb_resp_timeout = (uint16) val;
+		wlc->prb_resp_timeout = (u16) val;
 		break;
 
 	case WLC_GET_KEY_PRIMARY:{
@@ -4900,7 +4900,7 @@ static const char *supr_reason[] = {
 	"Lifetime Expiry", "Underflow"
 };
 
-static void wlc_print_txs_status(uint16 s)
+static void wlc_print_txs_status(u16 s)
 {
 	printf("[15:12]  %d  frame attempts\n", (s & TX_STATUS_FRM_RTX_MASK) >>
 	       TX_STATUS_FRM_RTX_SHIFT);
@@ -4921,8 +4921,8 @@ static void wlc_print_txs_status(uint16
 void wlc_print_txstatus(tx_status_t *txs)
 {
 #if defined(BCMDBG)
-	uint16 s = txs->status;
-	uint16 ackphyrxsh = txs->ackphyrxsh;
+	u16 s = txs->status;
+	u16 ackphyrxsh = txs->ackphyrxsh;
 
 	printf("\ntxpkt (MPDU) Complete\n");
 
@@ -4949,9 +4949,9 @@ void wlc_statsupd(wlc_info_t *wlc)
 {
 	int i;
 #ifdef BCMDBG
-	uint16 delta;
-	uint16 rxf0ovfl;
-	uint16 txfunfl[NFIFO];
+	u16 delta;
+	u16 rxf0ovfl;
+	u16 txfunfl[NFIFO];
 #endif				/* BCMDBG */
 
 	/* if driver down, make no sense to update stats */
@@ -4969,7 +4969,7 @@ void wlc_statsupd(wlc_info_t *wlc)
 
 #ifdef BCMDBG
 	/* check for rx fifo 0 overflow */
-	delta = (uint16) (wlc->core->macstat_snapshot->rxf0ovfl - rxf0ovfl);
+	delta = (u16) (wlc->core->macstat_snapshot->rxf0ovfl - rxf0ovfl);
 	if (delta)
 		WL_ERROR(("wl%d: %u rx fifo 0 overflows!\n", wlc->pub->unit,
 			  delta));
@@ -4977,7 +4977,7 @@ void wlc_statsupd(wlc_info_t *wlc)
 	/* check for tx fifo underflows */
 	for (i = 0; i < NFIFO; i++) {
 		delta =
-		    (uint16) (wlc->core->macstat_snapshot->txfunfl[i] -
+		    (u16) (wlc->core->macstat_snapshot->txfunfl[i] -
 			      txfunfl[i]);
 		if (delta)
 			WL_ERROR(("wl%d: %u tx fifo %d underflows!\n",
@@ -5027,7 +5027,7 @@ void wlc_statsupd(wlc_info_t *wlc)
 		WLCNTADD(wlc->pub->_cnt->rxerror, wlc->pub->_cnt->rxuflo[i]);
 }
 
-bool wlc_chipmatch(uint16 vendor, uint16 device)
+bool wlc_chipmatch(u16 vendor, u16 device)
 {
 	if (vendor != VENDOR_BROADCOM) {
 		WL_ERROR(("wlc_chipmatch: unknown vendor id %04x\n", vendor));
@@ -5049,32 +5049,32 @@ bool wlc_chipmatch(uint16 vendor, uint16
 #if defined(BCMDBG)
 void wlc_print_txdesc(d11txh_t *txh)
 {
-	uint16 mtcl = ltoh16(txh->MacTxControlLow);
-	uint16 mtch = ltoh16(txh->MacTxControlHigh);
-	uint16 mfc = ltoh16(txh->MacFrameControl);
-	uint16 tfest = ltoh16(txh->TxFesTimeNormal);
-	uint16 ptcw = ltoh16(txh->PhyTxControlWord);
-	uint16 ptcw_1 = ltoh16(txh->PhyTxControlWord_1);
-	uint16 ptcw_1_Fbr = ltoh16(txh->PhyTxControlWord_1_Fbr);
-	uint16 ptcw_1_Rts = ltoh16(txh->PhyTxControlWord_1_Rts);
-	uint16 ptcw_1_FbrRts = ltoh16(txh->PhyTxControlWord_1_FbrRts);
-	uint16 mainrates = ltoh16(txh->MainRates);
-	uint16 xtraft = ltoh16(txh->XtraFrameTypes);
+	u16 mtcl = ltoh16(txh->MacTxControlLow);
+	u16 mtch = ltoh16(txh->MacTxControlHigh);
+	u16 mfc = ltoh16(txh->MacFrameControl);
+	u16 tfest = ltoh16(txh->TxFesTimeNormal);
+	u16 ptcw = ltoh16(txh->PhyTxControlWord);
+	u16 ptcw_1 = ltoh16(txh->PhyTxControlWord_1);
+	u16 ptcw_1_Fbr = ltoh16(txh->PhyTxControlWord_1_Fbr);
+	u16 ptcw_1_Rts = ltoh16(txh->PhyTxControlWord_1_Rts);
+	u16 ptcw_1_FbrRts = ltoh16(txh->PhyTxControlWord_1_FbrRts);
+	u16 mainrates = ltoh16(txh->MainRates);
+	u16 xtraft = ltoh16(txh->XtraFrameTypes);
 	u8 *iv = txh->IV;
 	u8 *ra = txh->TxFrameRA;
-	uint16 tfestfb = ltoh16(txh->TxFesTimeFallback);
+	u16 tfestfb = ltoh16(txh->TxFesTimeFallback);
 	u8 *rtspfb = txh->RTSPLCPFallback;
-	uint16 rtsdfb = ltoh16(txh->RTSDurFallback);
+	u16 rtsdfb = ltoh16(txh->RTSDurFallback);
 	u8 *fragpfb = txh->FragPLCPFallback;
-	uint16 fragdfb = ltoh16(txh->FragDurFallback);
-	uint16 mmodelen = ltoh16(txh->MModeLen);
-	uint16 mmodefbrlen = ltoh16(txh->MModeFbrLen);
-	uint16 tfid = ltoh16(txh->TxFrameID);
-	uint16 txs = ltoh16(txh->TxStatus);
-	uint16 mnmpdu = ltoh16(txh->MaxNMpdus);
-	uint16 mabyte = ltoh16(txh->MaxABytes_MRT);
-	uint16 mabyte_f = ltoh16(txh->MaxABytes_FBR);
-	uint16 mmbyte = ltoh16(txh->MinMBytes);
+	u16 fragdfb = ltoh16(txh->FragDurFallback);
+	u16 mmodelen = ltoh16(txh->MModeLen);
+	u16 mmodefbrlen = ltoh16(txh->MModeFbrLen);
+	u16 tfid = ltoh16(txh->TxFrameID);
+	u16 txs = ltoh16(txh->TxStatus);
+	u16 mnmpdu = ltoh16(txh->MaxNMpdus);
+	u16 mabyte = ltoh16(txh->MaxABytes_MRT);
+	u16 mabyte_f = ltoh16(txh->MaxABytes_FBR);
+	u16 mmbyte = ltoh16(txh->MinMBytes);
 
 	u8 *rtsph = txh->RTSPhyHeader;
 	struct dot11_rts_frame rts = txh->rts_frame;
@@ -5134,13 +5134,13 @@ void wlc_print_txdesc(d11txh_t *txh)
 #if defined(BCMDBG)
 void wlc_print_rxh(d11rxhdr_t *rxh)
 {
-	uint16 len = rxh->RxFrameSize;
-	uint16 phystatus_0 = rxh->PhyRxStatus_0;
-	uint16 phystatus_1 = rxh->PhyRxStatus_1;
-	uint16 phystatus_2 = rxh->PhyRxStatus_2;
-	uint16 phystatus_3 = rxh->PhyRxStatus_3;
-	uint16 macstatus1 = rxh->RxStatus1;
-	uint16 macstatus2 = rxh->RxStatus2;
+	u16 len = rxh->RxFrameSize;
+	u16 phystatus_0 = rxh->PhyRxStatus_0;
+	u16 phystatus_1 = rxh->PhyRxStatus_1;
+	u16 phystatus_2 = rxh->PhyRxStatus_2;
+	u16 phystatus_3 = rxh->PhyRxStatus_3;
+	u16 macstatus1 = rxh->RxStatus1;
+	u16 macstatus2 = rxh->RxStatus2;
 	char flagstr[64];
 	char lenbuf[20];
 	static const bcm_bit_desc_t macstat_flags[] = {
@@ -5197,7 +5197,7 @@ int wlc_format_ssid(char *buf, const uns
 }
 #endif				/* defined(BCMDBG) */
 
-uint16 wlc_rate_shm_offset(wlc_info_t *wlc, u8 rate)
+u16 wlc_rate_shm_offset(wlc_info_t *wlc, u8 rate)
 {
 	return wlc_bmac_rate_shm_offset(wlc->hw, rate);
 }
@@ -5339,7 +5339,7 @@ wlc_sendpkt_mac80211(wlc_info_t *wlc, vo
 	void *pkt;
 	struct scb *scb = &global_scb;
 	struct dot11_header *d11_header = (struct dot11_header *)PKTDATA(sdu);
-	uint16 type, fc;
+	u16 type, fc;
 
 	ASSERT(sdu);
 
@@ -5371,7 +5371,7 @@ void BCMFASTPATH wlc_send_q(wlc_info_t *
 {
 	void *pkt[DOT11_MAXNUMFRAGS];
 	int prec;
-	uint16 prec_map;
+	u16 prec_map;
 	int err = 0, i, count;
 	uint fifo;
 	struct pktq *q = &qi->q;
@@ -5441,10 +5441,10 @@ void BCMFASTPATH wlc_send_q(wlc_info_t *
  * Generate frame ID for a BCMC packet.  The frag field is not used
  * for MC frames so is used as part of the sequence number.
  */
-static inline uint16
+static inline u16
 bcmc_fid_generate(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, d11txh_t *txh)
 {
-	uint16 frameid;
+	u16 frameid;
 
 	frameid = ltoh16(txh->TxFrameID) & ~(TXFID_SEQ_MASK | TXFID_QUEUE_MASK);
 	frameid |=
@@ -5458,7 +5458,7 @@ bcmc_fid_generate(wlc_info_t *wlc, wlc_b
 void BCMFASTPATH
 wlc_txfifo(wlc_info_t *wlc, uint fifo, void *p, bool commit, s8 txpktpend)
 {
-	uint16 frameid = INVALIDFID;
+	u16 frameid = INVALIDFID;
 	d11txh_t *txh;
 
 	ASSERT(fifo < NFIFO);
@@ -5502,10 +5502,10 @@ wlc_txfifo(wlc_info_t *wlc, uint fifo, v
 #endif				/* WLC_HIGH_ONLY */
 }
 
-static uint16
+static u16
 wlc_compute_airtime(wlc_info_t *wlc, ratespec_t rspec, uint length)
 {
-	uint16 usec = 0;
+	u16 usec = 0;
 	uint mac_rate = RSPEC2RATE(rspec);
 	uint nsyms;
 
@@ -5521,7 +5521,7 @@ wlc_compute_airtime(wlc_info_t *wlc, rat
 		nsyms = CEIL((length * 8), (mac_rate * 2));
 
 		/* usec = symbols * usec/symbol */
-		usec = (uint16) (nsyms * APHY_SYMBOL_TIME);
+		usec = (u16) (nsyms * APHY_SYMBOL_TIME);
 		return usec;
 	} else {
 		switch (mac_rate) {
@@ -5609,7 +5609,7 @@ wlc_compute_ofdm_plcp(ratespec_t rspec,
 
 static void wlc_cck_plcp_set(int rate_500, uint length, u8 *plcp)
 {
-	uint16 usec = 0;
+	u16 usec = 0;
 	u8 le = 0;
 
 	switch (rate_500) {
@@ -5643,7 +5643,7 @@ static void wlc_cck_plcp_set(int rate_50
 	plcp[0] = rate_500 * 5;	/* r (500kbps) * 5 == r (100kbps) */
 	/* PLCP service byte */
 	plcp[1] = (u8) (le | D11B_PLCP_SIGNAL_LOCKED);
-	/* PLCP length uint16, little endian */
+	/* PLCP length u16, little endian */
 	plcp[2] = usec & 0xff;
 	plcp[3] = (usec >> 8) & 0xff;
 	/* PLCP CRC16 */
@@ -5671,16 +5671,16 @@ static void wlc_compute_cck_plcp(ratespe
  * next_frag_len	next MPDU length in bytes
  * preamble_type	use short/GF or long/MM PLCP header
  */
-static uint16 BCMFASTPATH
+static u16 BCMFASTPATH
 wlc_compute_frame_dur(wlc_info_t *wlc, ratespec_t rate, u8 preamble_type,
 		      uint next_frag_len)
 {
-	uint16 dur, sifs;
+	u16 dur, sifs;
 
 	sifs = SIFS(wlc->band);
 
 	dur = sifs;
-	dur += (uint16) wlc_calc_ack_time(wlc, rate, preamble_type);
+	dur += (u16) wlc_calc_ack_time(wlc, rate, preamble_type);
 
 	if (next_frag_len) {
 		/* Double the current DUR to get 2 SIFS + 2 ACKs */
@@ -5688,7 +5688,7 @@ wlc_compute_frame_dur(wlc_info_t *wlc, r
 		/* add another SIFS and the frag time */
 		dur += sifs;
 		dur +=
-		    (uint16) wlc_calc_frame_time(wlc, rate, preamble_type,
+		    (u16) wlc_calc_frame_time(wlc, rate, preamble_type,
 						 next_frag_len);
 	}
 	return dur;
@@ -5705,39 +5705,39 @@ wlc_compute_frame_dur(wlc_info_t *wlc, r
  * rate			next MPDU rate in unit of 500kbps
  * frame_len		next MPDU frame length in bytes
  */
-uint16 BCMFASTPATH
+u16 BCMFASTPATH
 wlc_compute_rtscts_dur(wlc_info_t *wlc, bool cts_only, ratespec_t rts_rate,
 		       ratespec_t frame_rate, u8 rts_preamble_type,
 		       u8 frame_preamble_type, uint frame_len, bool ba)
 {
-	uint16 dur, sifs;
+	u16 dur, sifs;
 
 	sifs = SIFS(wlc->band);
 
 	if (!cts_only) {	/* RTS/CTS */
 		dur = 3 * sifs;
 		dur +=
-		    (uint16) wlc_calc_cts_time(wlc, rts_rate,
+		    (u16) wlc_calc_cts_time(wlc, rts_rate,
 					       rts_preamble_type);
 	} else {		/* CTS-TO-SELF */
 		dur = 2 * sifs;
 	}
 
 	dur +=
-	    (uint16) wlc_calc_frame_time(wlc, frame_rate, frame_preamble_type,
+	    (u16) wlc_calc_frame_time(wlc, frame_rate, frame_preamble_type,
 					 frame_len);
 	if (ba)
 		dur +=
-		    (uint16) wlc_calc_ba_time(wlc, frame_rate,
+		    (u16) wlc_calc_ba_time(wlc, frame_rate,
 					      WLC_SHORT_PREAMBLE);
 	else
 		dur +=
-		    (uint16) wlc_calc_ack_time(wlc, frame_rate,
+		    (u16) wlc_calc_ack_time(wlc, frame_rate,
 					       frame_preamble_type);
 	return dur;
 }
 
-static bool wlc_phy_rspec_check(wlc_info_t *wlc, uint16 bw, ratespec_t rspec)
+static bool wlc_phy_rspec_check(wlc_info_t *wlc, u16 bw, ratespec_t rspec)
 {
 	if (IS_MCS(rspec)) {
 		uint mcs = rspec & RSPEC_RATE_MASK;
@@ -5763,10 +5763,10 @@ static bool wlc_phy_rspec_check(wlc_info
 	return TRUE;
 }
 
-uint16 BCMFASTPATH wlc_phytxctl1_calc(wlc_info_t *wlc, ratespec_t rspec)
+u16 BCMFASTPATH wlc_phytxctl1_calc(wlc_info_t *wlc, ratespec_t rspec)
 {
-	uint16 phyctl1 = 0;
-	uint16 bw;
+	u16 phyctl1 = 0;
+	u16 bw;
 
 	if (WLCISLCNPHY(wlc->band)) {
 		bw = PHY_TXC1_BW_20MHZ;
@@ -5823,7 +5823,7 @@ uint16 BCMFASTPATH wlc_phytxctl1_calc(wl
 
 ratespec_t BCMFASTPATH
 wlc_rspec_to_rts_rspec(wlc_info_t *wlc, ratespec_t rspec, bool use_rspec,
-		       uint16 mimo_ctlchbw)
+		       u16 mimo_ctlchbw)
 {
 	ratespec_t rts_rspec = 0;
 
@@ -5877,7 +5877,7 @@ wlc_rspec_to_rts_rspec(wlc_info_t *wlc,
  * headroom == D11_PHY_HDR_LEN + D11_TXH_LEN (D11_TXH_LEN is now 104 bytes)
  *
  */
-static uint16 BCMFASTPATH
+static u16 BCMFASTPATH
 wlc_d11hdrs_mac80211(wlc_info_t *wlc, struct ieee80211_hw *hw,
 		     void *p, struct scb *scb, uint frag,
 		     uint nfrags, uint queue, uint next_frag_len,
@@ -5888,8 +5888,8 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 	u8 *plcp, plcp_fallback[D11_PHY_HDR_LEN];
 	osl_t *osh;
 	int len, phylen, rts_phylen;
-	uint16 fc, type, frameid, mch, phyctl, xfts, mainrates;
-	uint16 seq = 0, mcl = 0, status = 0;
+	u16 fc, type, frameid, mch, phyctl, xfts, mainrates;
+	u16 seq = 0, mcl = 0, status = 0;
 	ratespec_t rspec[2] = { WLC_RATE_1M, WLC_RATE_1M }, rts_rspec[2] = {
 	WLC_RATE_1M, WLC_RATE_1M};
 	bool use_rts = FALSE;
@@ -5904,19 +5904,19 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 	uint ac;
 	uint32 rate_val[2];
 	bool hwtkmic = FALSE;
-	uint16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
+	u16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
 #ifdef WLANTSEL
 #define ANTCFG_NONE 0xFF
 	u8 antcfg = ANTCFG_NONE;
 	u8 fbantcfg = ANTCFG_NONE;
 #endif
 	uint phyctl1_stf = 0;
-	uint16 durid = 0;
+	u16 durid = 0;
 	struct ieee80211_tx_rate *txrate[2];
 	int k;
 	struct ieee80211_tx_info *tx_info;
 	bool is_mcs[2];
-	uint16 mimo_txbw;
+	u16 mimo_txbw;
 	u8 mimo_preamble_type;
 
 	frameid = 0;
@@ -6218,7 +6218,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 	} else if (use_rifs) {
 		/* NAV protect to end of next max packet size */
 		durid =
-		    (uint16) wlc_calc_frame_time(wlc, rspec[0],
+		    (u16) wlc_calc_frame_time(wlc, rspec[0],
 						 preamble_type[0],
 						 DOT11_MAX_FRAG_LEN);
 		durid += RIFS_11N_TIME;
@@ -6268,7 +6268,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 	}
 
 	/* MacFrameControl */
-	bcopy((char *)&h->fc, (char *)&txh->MacFrameControl, sizeof(uint16));
+	bcopy((char *)&h->fc, (char *)&txh->MacFrameControl, sizeof(u16));
 
 	txh->TxFesTimeNormal = htol16(0);
 
@@ -6331,7 +6331,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 		}
 
 		/* RTS PLCP header */
-		ASSERT(ISALIGNED((uintptr) txh->RTSPhyHeader, sizeof(uint16)));
+		ASSERT(ISALIGNED((uintptr) txh->RTSPhyHeader, sizeof(u16)));
 		rts_plcp = txh->RTSPhyHeader;
 		if (use_cts)
 			rts_phylen = DOT11_CTS_LEN + DOT11_FCS_LEN;
@@ -6364,7 +6364,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 			rts->fc = htol16(FC_CTS);
 			bcopy((char *)&h->a2, (char *)&rts->ra, ETHER_ADDR_LEN);
 		} else {
-			rts->fc = htol16((uint16) FC_RTS);
+			rts->fc = htol16((u16) FC_RTS);
 			bcopy((char *)&h->a1, (char *)&rts->ra,
 			      2 * ETHER_ADDR_LEN);
 		}
@@ -6423,7 +6423,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 
 	/* PhyTxControlWord_1 */
 	if (WLC_PHY_11N_CAP(wlc->band)) {
-		uint16 phyctl1 = 0;
+		u16 phyctl1 = 0;
 
 		phyctl1 = wlc_phytxctl1_calc(wlc, rspec[0]);
 		txh->PhyTxControlWord_1 = htol16(phyctl1);
@@ -6443,13 +6443,13 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 		 *  it will be unnecessary if they are separated
 		 */
 		if (IS_MCS(rspec[0]) && (preamble_type[0] == WLC_MM_PREAMBLE)) {
-			uint16 mmodelen =
+			u16 mmodelen =
 			    wlc_calc_lsig_len(wlc, rspec[0], phylen);
 			txh->MModeLen = htol16(mmodelen);
 		}
 
 		if (IS_MCS(rspec[1]) && (preamble_type[1] == WLC_MM_PREAMBLE)) {
-			uint16 mmodefbrlen =
+			u16 mmodefbrlen =
 			    wlc_calc_lsig_len(wlc, rspec[1], phylen);
 			txh->MModeFbrLen = htol16(mmodefbrlen);
 		}
@@ -6506,9 +6506,9 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 							  preamble_type[1], 0);
 			}
 			/* NEED to set TxFesTimeNormal (hard) */
-			txh->TxFesTimeNormal = htol16((uint16) dur);
+			txh->TxFesTimeNormal = htol16((u16) dur);
 			/* NEED to set fallback rate version of TxFesTimeNormal (hard) */
-			txh->TxFesTimeFallback = htol16((uint16) dur_fallback);
+			txh->TxFesTimeFallback = htol16((u16) dur_fallback);
 
 			/* update txop byte threshold (txop minus intraframe overhead) */
 			if (wlc->edcf_txop[ac] >= (dur - frag_dur)) {
@@ -6532,9 +6532,9 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 						    wlc->usr_fragthresh;
 					/* update the fragthresh and do txc update */
 					if (wlc->fragthresh[queue] !=
-					    (uint16) newfragthresh) {
+					    (u16) newfragthresh) {
 						wlc->fragthresh[queue] =
-						    (uint16) newfragthresh;
+						    (u16) newfragthresh;
 					}
 				}
 			} else
@@ -6764,8 +6764,8 @@ wlc_dotxstatus(wlc_info_t *wlc, tx_statu
 	uint totlen, supr_status;
 	bool lastframe;
 	struct dot11_header *h;
-	uint16 fc;
-	uint16 mcl;
+	u16 fc;
+	u16 mcl;
 	struct ieee80211_tx_info *tx_info;
 	struct ieee80211_tx_rate *txrate;
 	int i;
@@ -6854,7 +6854,7 @@ wlc_dotxstatus(wlc_info_t *wlc, tx_statu
 	if (!lastframe) {
 		WL_ERROR(("Not last frame!\n"));
 	} else {
-		uint16 sfbl, lfbl;
+		u16 sfbl, lfbl;
 		ieee80211_tx_info_clear_status(tx_info);
 		if (queue < AC_COUNT) {
 			sfbl = WLC_WME_RETRY_SFB_GET(wlc, wme_fifo2ac[queue]);
@@ -6977,7 +6977,7 @@ uint32 wlc_calc_tbtt_offset(uint32 bp, u
 	 * and
 	 * (X + Y) mod Z = ((X mod Z) + (Y mod Z)) mod Z
 	 *
-	 * So, if BTk[n] = uint16 n [0,3] of BTk.
+	 * So, if BTk[n] = u16 n [0,3] of BTk.
 	 * BTk % BP = SUM((BTk[n] * 2^16n) % BP , 0<=n<4) % BP
 	 * and the SUM term can be broken down:
 	 * (BTk[n] *     2^16n)    % BP
@@ -7222,7 +7222,7 @@ void BCMFASTPATH wlc_recv(wlc_info_t *wl
 	d11rxhdr_t *rxh;
 	struct dot11_header *h;
 	osl_t *osh;
-	uint16 fc;
+	u16 fc;
 	uint len;
 	bool is_amsdu;
 #ifdef BCMDBG
@@ -7313,7 +7313,7 @@ void BCMFASTPATH wlc_recv(wlc_info_t *wl
  * Formula given by HT PHY Spec v 1.13
  *   len = 3(nsyms + nstream + 3) - 3
  */
-uint16 BCMFASTPATH
+u16 BCMFASTPATH
 wlc_calc_lsig_len(wlc_info_t *wlc, ratespec_t ratespec, uint mac_len)
 {
 	uint nsyms, len = 0, kNdps;
@@ -7350,7 +7350,7 @@ wlc_calc_lsig_len(wlc_info_t *wlc, rates
 		len = (3 * nsyms) - 3;	/* (-3) excluding service bits and tail bits */
 	}
 
-	return (uint16) len;
+	return (u16) len;
 }
 
 /* calculate frame duration of a given rate and length, return time in usec unit */
@@ -7609,8 +7609,8 @@ static void wlc_write_rate_shm(wlc_info_
 {
 	u8 phy_rate, index;
 	u8 basic_phy_rate, basic_index;
-	uint16 dir_table, basic_table;
-	uint16 basic_ptr;
+	u16 dir_table, basic_table;
+	u16 basic_ptr;
 
 	/* Shared memory address for the table we are reading */
 	dir_table = IS_OFDM(basic_rate) ? M_RT_DIRMAP_A : M_RT_DIRMAP_B;
@@ -7756,9 +7756,9 @@ void wlc_mod_prb_rsp_rate_table(wlc_info
 	const wlc_rateset_t *rs_dflt;
 	wlc_rateset_t rs;
 	u8 rate;
-	uint16 entry_ptr;
+	u16 entry_ptr;
 	u8 plcp[D11_PHY_HDR_LEN];
-	uint16 dur, sifs;
+	u16 dur, sifs;
 	uint i;
 
 	sifs = SIFS(wlc->band);
@@ -7780,20 +7780,20 @@ void wlc_mod_prb_rsp_rate_table(wlc_info
 
 		/* Calculate the duration of the Probe Response frame plus SIFS for the MAC */
 		dur =
-		    (uint16) wlc_calc_frame_time(wlc, rate, WLC_LONG_PREAMBLE,
+		    (u16) wlc_calc_frame_time(wlc, rate, WLC_LONG_PREAMBLE,
 						 frame_len);
 		dur += sifs;
 
 		/* Update the SHM Rate Table entry Probe Response values */
 		wlc_write_shm(wlc, entry_ptr + M_RT_PRS_PLCP_POS,
-			      (uint16) (plcp[0] + (plcp[1] << 8)));
+			      (u16) (plcp[0] + (plcp[1] << 8)));
 		wlc_write_shm(wlc, entry_ptr + M_RT_PRS_PLCP_POS + 2,
-			      (uint16) (plcp[2] + (plcp[3] << 8)));
+			      (u16) (plcp[2] + (plcp[3] << 8)));
 		wlc_write_shm(wlc, entry_ptr + M_RT_PRS_DUR_POS, dur);
 	}
 }
 
-uint16
+u16
 wlc_compute_bcntsfoff(wlc_info_t *wlc, ratespec_t rspec, bool short_preamble,
 		      bool phydelay)
 {
@@ -7825,7 +7825,7 @@ wlc_compute_bcntsfoff(wlc_info_t *wlc, r
 		    D11B_PHY_LPREHDR_TIME;
 		bcntsfoff += wlc_compute_airtime(wlc, rspec, DOT11_MAC_HDR_LEN);
 	}
-	return (uint16) (bcntsfoff);
+	return (u16) (bcntsfoff);
 }
 
 /*	Max buffering needed for beacon template/prb resp template is 142 bytes.
@@ -7842,7 +7842,7 @@ wlc_compute_bcntsfoff(wlc_info_t *wlc, r
  */
 static void
 wlc_bcn_prb_template(wlc_info_t *wlc, uint type, ratespec_t bcn_rspec,
-		     wlc_bsscfg_t *cfg, uint16 *buf, int *len)
+		     wlc_bsscfg_t *cfg, u16 *buf, int *len)
 {
 	cck_phy_hdr_t *plcp;
 	struct dot11_management_header *h;
@@ -7883,7 +7883,7 @@ wlc_bcn_prb_template(wlc_info_t *wlc, ui
 		h = (struct dot11_management_header *)&plcp[1];
 
 	/* fill in 802.11 header */
-	h->fc = htol16((uint16) type);
+	h->fc = htol16((u16) type);
 
 	/* DUR is 0 for multicast bcn, or filled in by MAC for prb resp */
 	/* A1 filled in by MAC for prb resp, broadcast for bcn */
@@ -7921,7 +7921,7 @@ void wlc_bss_update_beacon(wlc_info_t *w
 
 	if (MBSS_BCN_ENAB(cfg)) {	/* Optimize:  Some of if/else could be combined */
 	} else if (HWBCN_ENAB(cfg)) {	/* Hardware beaconing for this config */
-		uint16 bcn[BCN_TMPL_LEN / 2];
+		u16 bcn[BCN_TMPL_LEN / 2];
 		uint32 both_valid = MCMD_BCN0VLD | MCMD_BCN1VLD;
 		d11regs_t *regs = wlc->regs;
 		osl_t *osh = NULL;
@@ -7977,7 +7977,7 @@ void wlc_update_beacon(wlc_info_t *wlc)
 void wlc_shm_ssid_upd(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
 {
 	u8 *ssidptr = cfg->SSID;
-	uint16 base = M_SSID;
+	u16 base = M_SSID;
 	u8 ssidbuf[DOT11_MAX_SSID_LEN];
 
 	/* padding the ssid with zero and copy it into shm */
@@ -7987,7 +7987,7 @@ void wlc_shm_ssid_upd(wlc_info_t *wlc, w
 	wlc_copyto_shm(wlc, base, ssidbuf, DOT11_MAX_SSID_LEN);
 
 	if (!MBSS_BCN_ENAB(cfg))
-		wlc_write_shm(wlc, M_SSIDLEN, (uint16) cfg->SSID_len);
+		wlc_write_shm(wlc, M_SSIDLEN, (u16) cfg->SSID_len);
 }
 
 void wlc_update_probe_resp(wlc_info_t *wlc, bool suspend)
@@ -8005,7 +8005,7 @@ void wlc_update_probe_resp(wlc_info_t *w
 void
 wlc_bss_update_probe_resp(wlc_info_t *wlc, wlc_bsscfg_t *cfg, bool suspend)
 {
-	uint16 prb_resp[BCN_TMPL_LEN / 2];
+	u16 prb_resp[BCN_TMPL_LEN / 2];
 	int len = BCN_TMPL_LEN;
 
 	/* write the probe response to hardware, or save in the config structure */
@@ -8023,7 +8023,7 @@ wlc_bss_update_probe_resp(wlc_info_t *wl
 					    (len + 3) & ~3, prb_resp);
 
 		/* write the length of the probe response frame (+PLCP/-FCS) */
-		wlc_write_shm(wlc, M_PRB_RESP_FRM_LEN, (uint16) len);
+		wlc_write_shm(wlc, M_PRB_RESP_FRM_LEN, (u16) len);
 
 		/* write the SSID and SSID length */
 		wlc_shm_ssid_upd(wlc, cfg);
@@ -8034,7 +8034,7 @@ wlc_bss_update_probe_resp(wlc_info_t *wl
 		 * wlc_mod_prb_rsp_rate_table() by subtracting the PLCP len and adding the FCS.
 		 */
 		len += (-D11_PHY_HDR_LEN + DOT11_FCS_LEN);
-		wlc_mod_prb_rsp_rate_table(wlc, (uint16) len);
+		wlc_mod_prb_rsp_rate_table(wlc, (u16) len);
 
 		if (suspend)
 			wlc_enable_mac(wlc);
@@ -8051,7 +8051,7 @@ int wlc_prep_pdu(wlc_info_t *wlc, void *
 	d11txh_t *txh;
 	struct dot11_header *h;
 	struct scb *scb;
-	uint16 fc;
+	u16 fc;
 
 	osh = wlc->osh;
 
@@ -8339,12 +8339,12 @@ wlc_duty_cycle_set(wlc_info_t *wlc, int
 		idle_busy_ratio_x_16 = (100 - duty_cycle) * 16 / duty_cycle;
 	/* Only write to shared memory  when wl is up */
 	if (writeToShm)
-		wlc_write_shm(wlc, offset, (uint16) idle_busy_ratio_x_16);
+		wlc_write_shm(wlc, offset, (u16) idle_busy_ratio_x_16);
 
 	if (isOFDM)
-		wlc->tx_duty_cycle_ofdm = (uint16) duty_cycle;
+		wlc->tx_duty_cycle_ofdm = (u16) duty_cycle;
 	else
-		wlc->tx_duty_cycle_cck = (uint16) duty_cycle;
+		wlc->tx_duty_cycle_cck = (u16) duty_cycle;
 
 	return BCME_OK;
 }
@@ -8354,8 +8354,8 @@ wlc_pktengtx(wlc_info_t *wlc, wl_pkteng_
 	     struct ether_addr *sa, uint32 wait_delay)
 {
 	bool suspend;
-	uint16 val = M_PKTENG_MODE_TX;
-	volatile uint16 frame_cnt_check;
+	u16 val = M_PKTENG_MODE_TX;
+	volatile u16 frame_cnt_check;
 	u8 counter = 0;
 
 	wlc_bmac_set_deaf(wlc->hw, TRUE);
@@ -8388,7 +8388,7 @@ wlc_pktengtx(wlc_info_t *wlc, wl_pkteng_
 		/* CTS frame */
 		val |= M_PKTENG_MODE_TX_CTS;
 		wlc_bmac_write_shm(wlc->hw, M_PKTENG_IFS,
-				   (uint16) pkteng->delay);
+				   (u16) pkteng->delay);
 		wlc_bmac_write_shm(wlc->hw, M_PKTENG_CTRL, val);
 	}
 
@@ -8409,18 +8409,18 @@ wlc_pktengtx(wlc_info_t *wlc, wl_pkteng_
 	wlc_bmac_set_deaf(wlc->hw, FALSE);
 }
 
-/* Read a single uint16 from shared memory.
+/* Read a single u16 from shared memory.
  * SHM 'offset' needs to be an even address
  */
-uint16 wlc_read_shm(wlc_info_t *wlc, uint offset)
+u16 wlc_read_shm(wlc_info_t *wlc, uint offset)
 {
 	return wlc_bmac_read_shm(wlc->hw, offset);
 }
 
-/* Write a single uint16 to shared memory.
+/* Write a single u16 to shared memory.
  * SHM 'offset' needs to be an even address
  */
-void wlc_write_shm(wlc_info_t *wlc, uint offset, uint16 v)
+void wlc_write_shm(wlc_info_t *wlc, uint offset, u16 v)
 {
 	wlc_bmac_write_shm(wlc->hw, offset, v);
 }
@@ -8429,7 +8429,7 @@ void wlc_write_shm(wlc_info_t *wlc, uint
  * SHM 'offset' needs to be an even address and
  * Range length 'len' must be an even number of bytes
  */
-void wlc_set_shm(wlc_info_t *wlc, uint offset, uint16 v, int len)
+void wlc_set_shm(wlc_info_t *wlc, uint offset, u16 v, int len)
 {
 	/* offset and len need to be even */
 	ASSERT((offset & 1) == 0);
@@ -8484,12 +8484,12 @@ void wlc_corereset(wlc_info_t *wlc, uint
 	wlc_bmac_corereset(wlc->hw, flags);
 }
 
-void wlc_mhf(wlc_info_t *wlc, u8 idx, uint16 mask, uint16 val, int bands)
+void wlc_mhf(wlc_info_t *wlc, u8 idx, u16 mask, u16 val, int bands)
 {
 	wlc_bmac_mhf(wlc->hw, idx, mask, val, bands);
 }
 
-uint16 wlc_mhf_get(wlc_info_t *wlc, u8 idx, int bands)
+u16 wlc_mhf_get(wlc_info_t *wlc, u8 idx, int bands)
 {
 	return wlc_bmac_mhf_get(wlc->hw, idx, bands);
 }
@@ -8526,13 +8526,13 @@ void wlc_read_tsf(wlc_info_t *wlc, uint3
 	wlc_bmac_read_tsf(wlc->hw, tsf_l_ptr, tsf_h_ptr);
 }
 
-void wlc_set_cwmin(wlc_info_t *wlc, uint16 newmin)
+void wlc_set_cwmin(wlc_info_t *wlc, u16 newmin)
 {
 	wlc->band->CWmin = newmin;
 	wlc_bmac_set_cwmin(wlc->hw, newmin);
 }
 
-void wlc_set_cwmax(wlc_info_t *wlc, uint16 newmax)
+void wlc_set_cwmax(wlc_info_t *wlc, u16 newmax)
 {
 	wlc->band->CWmax = newmax;
 	wlc_bmac_set_cwmax(wlc->hw, newmax);
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.h
@@ -267,12 +267,12 @@ typedef struct wlc_stf {
 
 	u8 ant_rx_ovr;	/* rx antenna override */
 	s8 txant;		/* userTx antenna setting */
-	uint16 phytxant;	/* phyTx antenna setting in txheader */
+	u16 phytxant;	/* phyTx antenna setting in txheader */
 
 	u8 ss_opmode;	/* singlestream Operational mode, 0:siso; 1:cdd */
 	bool ss_algosel_auto;	/* if TRUE, use wlc->stf->ss_algo_channel; */
 	/* else use wlc->band->stf->ss_mode_band; */
-	uint16 ss_algo_channel;	/* ss based on per-channel algo: 0: SISO, 1: CDD 2: STBC */
+	u16 ss_algo_channel;	/* ss based on per-channel algo: 0: SISO, 1: CDD 2: STBC */
 	u8 no_cddstbc;	/* stf override, 1: no CDD (or STBC) allowed */
 
 	u8 rxchain_restore_delay;	/* delay time to restore default rxchain */
@@ -330,10 +330,10 @@ typedef struct wlcband {
 	int bandtype;		/* WLC_BAND_2G, WLC_BAND_5G */
 	uint bandunit;		/* bandstate[] index */
 
-	uint16 phytype;		/* phytype */
-	uint16 phyrev;
-	uint16 radioid;
-	uint16 radiorev;
+	u16 phytype;		/* phytype */
+	u16 phyrev;
+	u16 radioid;
+	u16 radiorev;
 	wlc_phy_t *pi;		/* pointer to phy specific information */
 	bool abgphy_encore;
 
@@ -352,9 +352,9 @@ typedef struct wlcband {
 	bool mimo_cap_40;	/* 40 MHz cap enabled on this band */
 	s8 antgain;		/* antenna gain from srom */
 
-	uint16 CWmin;		/* The minimum size of contention window, in unit of aSlotTime */
-	uint16 CWmax;		/* The maximum size of contention window, in unit of aSlotTime */
-	uint16 bcntsfoff;	/* beacon tsf offset */
+	u16 CWmin;		/* The minimum size of contention window, in unit of aSlotTime */
+	u16 CWmax;		/* The maximum size of contention window, in unit of aSlotTime */
+	u16 bcntsfoff;	/* beacon tsf offset */
 } wlcband_t;
 
 /* generic function callback takes just one arg */
@@ -416,16 +416,16 @@ struct wlc_if {
 typedef struct wlc_hwband {
 	int bandtype;		/* WLC_BAND_2G, WLC_BAND_5G */
 	uint bandunit;		/* bandstate[] index */
-	uint16 mhfs[MHFMAX];	/* MHF array shadow */
+	u16 mhfs[MHFMAX];	/* MHF array shadow */
 	u8 bandhw_stf_ss_mode;	/* HW configured STF type, 0:siso; 1:cdd */
-	uint16 CWmin;
-	uint16 CWmax;
+	u16 CWmin;
+	u16 CWmax;
 	uint32 core_flags;
 
-	uint16 phytype;		/* phytype */
-	uint16 phyrev;
-	uint16 radioid;
-	uint16 radiorev;
+	u16 phytype;		/* phytype */
+	u16 phyrev;
+	u16 radioid;
+	u16 radiorev;
 	wlc_phy_t *pi;		/* pointer to phy specific information */
 	bool abgphy_encore;
 } wlc_hwband_t;
@@ -446,16 +446,16 @@ struct wlc_hw_info {
 	uint unit;		/* device instance number */
 
 	/* version info */
-	uint16 vendorid;	/* PCI vendor id */
-	uint16 deviceid;	/* PCI device id */
+	u16 vendorid;	/* PCI vendor id */
+	u16 deviceid;	/* PCI device id */
 	uint corerev;		/* core revision */
 	u8 sromrev;		/* version # of the srom */
-	uint16 boardrev;	/* version # of particular board */
+	u16 boardrev;	/* version # of particular board */
 	uint32 boardflags;	/* Board specific flags from srom */
 	uint32 boardflags2;	/* More board flags if sromrev >= 4 */
 	uint32 machwcap;	/* MAC capabilities (corerev >= 13) */
 	uint32 machwcap_backup;	/* backup of machwcap (corerev >= 13) */
-	uint16 ucode_dbgsel;	/* dbgsel for ucode debug(config gpio) */
+	u16 ucode_dbgsel;	/* dbgsel for ucode debug(config gpio) */
 
 	si_t *sih;		/* SB handle (cookie for siutils calls) */
 	char *vars;		/* "environment" name=value */
@@ -465,12 +465,12 @@ struct wlc_hw_info {
 	void *phy_sh;		/* pointer to shared phy state */
 	wlc_hwband_t *band;	/* pointer to active per-band state */
 	wlc_hwband_t *bandstate[MAXBANDS];	/* per-band state (one per phy/radio) */
-	uint16 bmac_phytxant;	/* cache of high phytxant state */
+	u16 bmac_phytxant;	/* cache of high phytxant state */
 	bool shortslot;		/* currently using 11g ShortSlot timing */
-	uint16 SRL;		/* 802.11 dot11ShortRetryLimit */
-	uint16 LRL;		/* 802.11 dot11LongRetryLimit */
-	uint16 SFBL;		/* Short Frame Rate Fallback Limit */
-	uint16 LFBL;		/* Long Frame Rate Fallback Limit */
+	u16 SRL;		/* 802.11 dot11ShortRetryLimit */
+	u16 LRL;		/* 802.11 dot11LongRetryLimit */
+	u16 SFBL;		/* Short Frame Rate Fallback Limit */
+	u16 LFBL;		/* Long Frame Rate Fallback Limit */
 
 	bool up;		/* d11 hardware up and running */
 	uint now;		/* # elapsed seconds */
@@ -478,7 +478,7 @@ struct wlc_hw_info {
 	chanspec_t chanspec;	/* bmac chanspec shadow */
 
 	uint *txavail[NFIFO];	/* # tx descriptors available */
-	uint16 *xmtfifo_sz;	/* fifo size in 256B for each xmt fifo */
+	u16 *xmtfifo_sz;	/* fifo size in 256B for each xmt fifo */
 
 	mbool pllreq;		/* pll requests to keep PLL on */
 
@@ -505,7 +505,7 @@ struct wlc_hw_info {
 #ifdef WLC_LOW_ONLY
 	struct wl_timer *wdtimer;	/* timer for watchdog routine */
 	struct ether_addr orig_etheraddr;	/* original hw ethernet address */
-	uint16 rpc_dngl_agg;	/* rpc agg control for dongle */
+	u16 rpc_dngl_agg;	/* rpc agg control for dongle */
 	uint32 mem_required_def;	/* memory required to replenish RX DMA ring */
 	uint32 mem_required_lower;	/* memory required with lower RX bound */
 	uint32 mem_required_least;	/* minimum memory requirement to handle RX */
@@ -549,7 +549,7 @@ struct wlc_info {
 
 	/* clock */
 	int clkreq_override;	/* setting for clkreq for PCIE : Auto, 0, 1 */
-	uint16 fastpwrup_dly;	/* time in us needed to bring up d11 fast clock */
+	u16 fastpwrup_dly;	/* time in us needed to bring up d11 fast clock */
 
 	/* interrupt */
 	uint32 macintstatus;	/* bit channel between isr and dpc */
@@ -595,8 +595,8 @@ struct wlc_info {
 
 	uint vars_size;		/* size of vars, free vars on detach */
 
-	uint16 vendorid;	/* PCI vendor id */
-	uint16 deviceid;	/* PCI device id */
+	u16 vendorid;	/* PCI vendor id */
+	u16 deviceid;	/* PCI device id */
 	uint ucode_rev;		/* microcode revision */
 
 	uint32 machwcap;	/* MAC capabilities, BMAC shadow */
@@ -667,18 +667,18 @@ struct wlc_info {
 	ac_bitmap_t wme_dp;	/* Discard (oldest first) policy per AC */
 	bool wme_apsd;		/* enable Advanced Power Save Delivery */
 	ac_bitmap_t wme_admctl;	/* bit i set if AC i under admission control */
-	uint16 edcf_txop[AC_COUNT];	/* current txop for each ac */
+	u16 edcf_txop[AC_COUNT];	/* current txop for each ac */
 	wme_param_ie_t wme_param_ie;	/* WME parameter info element, which on STA
 					 * contains parameters in use locally, and on
 					 * AP contains parameters advertised to STA
 					 * in beacons and assoc responses.
 					 */
 	bool wme_prec_queuing;	/* enable/disable non-wme STA prec queuing */
-	uint16 wme_retries[AC_COUNT];	/* per-AC retry limits */
+	u16 wme_retries[AC_COUNT];	/* per-AC retry limits */
 
 	int vlan_mode;		/* OK to use 802.1Q Tags (ON, OFF, AUTO) */
-	uint16 tx_prec_map;	/* Precedence map based on HW FIFO space */
-	uint16 fifo2prec_map[NFIFO];	/* pointer to fifo2_prec map based on WME */
+	u16 tx_prec_map;	/* Precedence map based on HW FIFO space */
+	u16 fifo2prec_map[NFIFO];	/* pointer to fifo2_prec map based on WME */
 
 	/* BSS Configurations */
 	wlc_bsscfg_t *bsscfg[WLC_MAXBSSCFG];	/* set of BSS configurations, idx 0 is default and
@@ -708,7 +708,7 @@ struct wlc_info {
 	u8 mimoft;		/* SIGN or 11N */
 	u8 mimo_band_bwcap;	/* bw cap per band type */
 	s8 txburst_limit_override;	/* tx burst limit override */
-	uint16 txburst_limit;	/* tx burst limit value */
+	u16 txburst_limit;	/* tx burst limit value */
 	s8 cck_40txbw;	/* 11N, cck tx b/w override when in 40MHZ mode */
 	s8 ofdm_40txbw;	/* 11N, ofdm tx b/w override when in 40MHZ mode */
 	s8 mimo_40txbw;	/* 11N, mimo tx b/w override when in 40MHZ mode */
@@ -719,9 +719,9 @@ struct wlc_info {
 
 	wlc_bss_info_t *default_bss;	/* configured BSS parameters */
 
-	uint16 AID;		/* association ID */
-	uint16 counter;		/* per-sdu monotonically increasing counter */
-	uint16 mc_fid_counter;	/* BC/MC FIFO frame ID counter */
+	u16 AID;		/* association ID */
+	u16 counter;		/* per-sdu monotonically increasing counter */
+	u16 mc_fid_counter;	/* BC/MC FIFO frame ID counter */
 
 	bool ibss_allowed;	/* FALSE, all IBSS will be ignored during a scan
 				 * and the driver will not allow the creation of
@@ -739,7 +739,7 @@ struct wlc_info {
 	bcm_tlv_t *country_ie_override;	/* debug override of announced Country IE */
 #endif
 
-	uint16 prb_resp_timeout;	/* do not send prb resp if request older than this,
+	u16 prb_resp_timeout;	/* do not send prb resp if request older than this,
 					 * 0 = disable
 					 */
 
@@ -751,13 +751,13 @@ struct wlc_info {
 
 	/* PHY parameters */
 	chanspec_t chanspec;	/* target operational channel */
-	uint16 usr_fragthresh;	/* user configured fragmentation threshold */
-	uint16 fragthresh[NFIFO];	/* per-fifo fragmentation thresholds */
-	uint16 RTSThresh;	/* 802.11 dot11RTSThreshold */
-	uint16 SRL;		/* 802.11 dot11ShortRetryLimit */
-	uint16 LRL;		/* 802.11 dot11LongRetryLimit */
-	uint16 SFBL;		/* Short Frame Rate Fallback Limit */
-	uint16 LFBL;		/* Long Frame Rate Fallback Limit */
+	u16 usr_fragthresh;	/* user configured fragmentation threshold */
+	u16 fragthresh[NFIFO];	/* per-fifo fragmentation thresholds */
+	u16 RTSThresh;	/* 802.11 dot11RTSThreshold */
+	u16 SRL;		/* 802.11 dot11ShortRetryLimit */
+	u16 LRL;		/* 802.11 dot11LongRetryLimit */
+	u16 SFBL;		/* Short Frame Rate Fallback Limit */
+	u16 LFBL;		/* Long Frame Rate Fallback Limit */
 
 	/* network config */
 	bool shortpreamble;	/* currently operating with CCK ShortPreambles */
@@ -802,10 +802,10 @@ struct wlc_info {
 
 	uint tempsense_lasttime;
 
-	uint16 tx_duty_cycle_ofdm;	/* maximum allowed duty cycle for OFDM */
-	uint16 tx_duty_cycle_cck;	/* maximum allowed duty cycle for CCK */
+	u16 tx_duty_cycle_ofdm;	/* maximum allowed duty cycle for OFDM */
+	u16 tx_duty_cycle_cck;	/* maximum allowed duty cycle for CCK */
 
-	uint16 next_bsscfg_ID;
+	u16 next_bsscfg_ID;
 
 	wlc_if_t *wlcif_list;	/* linked list of wlc_if structs */
 	wlc_txq_info_t *active_queue;	/* txq for the currently active transmit context */
@@ -894,8 +894,8 @@ extern void wlc_set_addrmatch(wlc_info_t
 			      const struct ether_addr *addr);
 extern void wlc_read_tsf(wlc_info_t *wlc, uint32 *tsf_l_ptr,
 			 uint32 *tsf_h_ptr);
-extern void wlc_set_cwmin(wlc_info_t *wlc, uint16 newmin);
-extern void wlc_set_cwmax(wlc_info_t *wlc, uint16 newmax);
+extern void wlc_set_cwmin(wlc_info_t *wlc, u16 newmin);
+extern void wlc_set_cwmax(wlc_info_t *wlc, u16 newmax);
 extern void wlc_fifoerrors(wlc_info_t *wlc);
 extern void wlc_pllreq(wlc_info_t *wlc, bool set, mbool req_bit);
 extern void wlc_reset_bmac_done(wlc_info_t *wlc);
@@ -940,11 +940,11 @@ extern bool wlc_txflowcontrol_prio_isset
 extern void wlc_send_q(wlc_info_t *wlc, wlc_txq_info_t *qi);
 extern int wlc_prep_pdu(wlc_info_t *wlc, void *pdu, uint *fifo);
 
-extern uint16 wlc_calc_lsig_len(wlc_info_t *wlc, ratespec_t ratespec,
+extern u16 wlc_calc_lsig_len(wlc_info_t *wlc, ratespec_t ratespec,
 				uint mac_len);
 extern ratespec_t wlc_rspec_to_rts_rspec(wlc_info_t *wlc, ratespec_t rspec,
-					 bool use_rspec, uint16 mimo_ctlchbw);
-extern uint16 wlc_compute_rtscts_dur(wlc_info_t *wlc, bool cts_only,
+					 bool use_rspec, u16 mimo_ctlchbw);
+extern u16 wlc_compute_rtscts_dur(wlc_info_t *wlc, bool cts_only,
 				     ratespec_t rts_rate, ratespec_t frame_rate,
 				     u8 rts_preamble_type,
 				     u8 frame_preamble_type, uint frame_len,
@@ -964,9 +964,9 @@ extern void wlc_uint64_sub(uint32 *a_hig
 extern uint32 wlc_calc_tbtt_offset(uint32 bi, uint32 tsf_h, uint32 tsf_l);
 
 /* Shared memory access */
-extern void wlc_write_shm(wlc_info_t *wlc, uint offset, uint16 v);
-extern uint16 wlc_read_shm(wlc_info_t *wlc, uint offset);
-extern void wlc_set_shm(wlc_info_t *wlc, uint offset, uint16 v, int len);
+extern void wlc_write_shm(wlc_info_t *wlc, uint offset, u16 v);
+extern u16 wlc_read_shm(wlc_info_t *wlc, uint offset);
+extern void wlc_set_shm(wlc_info_t *wlc, uint offset, u16 v, int len);
 extern void wlc_copyto_shm(wlc_info_t *wlc, uint offset, const void *buf,
 			   int len);
 extern void wlc_copyfrom_shm(wlc_info_t *wlc, uint offset, void *buf, int len);
@@ -984,7 +984,7 @@ extern void wlc_radio_mpc_upd(wlc_info_t
 extern bool wlc_prec_enq(wlc_info_t *wlc, struct pktq *q, void *pkt, int prec);
 extern bool wlc_prec_enq_head(wlc_info_t *wlc, struct pktq *q, void *pkt,
 			      int prec, bool head);
-extern uint16 wlc_phytxctl1_calc(wlc_info_t *wlc, ratespec_t rspec);
+extern u16 wlc_phytxctl1_calc(wlc_info_t *wlc, ratespec_t rspec);
 extern void wlc_compute_plcp(wlc_info_t *wlc, ratespec_t rate, uint length,
 			     u8 *plcp);
 extern uint wlc_calc_frame_time(wlc_info_t *wlc, ratespec_t ratespec,
@@ -1021,7 +1021,7 @@ extern void wlc_beacon_phytxctl_txant_up
 					  ratespec_t bcn_rate);
 extern void wlc_mod_prb_rsp_rate_table(wlc_info_t *wlc, uint frame_len);
 extern ratespec_t wlc_lowest_basic_rspec(wlc_info_t *wlc, wlc_rateset_t *rs);
-extern uint16 wlc_compute_bcntsfoff(wlc_info_t *wlc, ratespec_t rspec,
+extern u16 wlc_compute_bcntsfoff(wlc_info_t *wlc, ratespec_t rspec,
 				    bool short_preamble, bool phydelay);
 extern void wlc_radio_disable(wlc_info_t *wlc);
 extern void wlc_bcn_li_upd(wlc_info_t *wlc);
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.c
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.c
@@ -127,19 +127,19 @@ void wlapi_intrsrestore(wlc_phy_shim_inf
 	wl_intrsrestore(physhim->wl, macintmask);
 }
 
-void wlapi_bmac_write_shm(wlc_phy_shim_info_t *physhim, uint offset, uint16 v)
+void wlapi_bmac_write_shm(wlc_phy_shim_info_t *physhim, uint offset, u16 v)
 {
 	wlc_bmac_write_shm(physhim->wlc_hw, offset, v);
 }
 
-uint16 wlapi_bmac_read_shm(wlc_phy_shim_info_t *physhim, uint offset)
+u16 wlapi_bmac_read_shm(wlc_phy_shim_info_t *physhim, uint offset)
 {
 	return wlc_bmac_read_shm(physhim->wlc_hw, offset);
 }
 
 void
-wlapi_bmac_mhf(wlc_phy_shim_info_t *physhim, u8 idx, uint16 mask,
-	       uint16 val, int bands)
+wlapi_bmac_mhf(wlc_phy_shim_info_t *physhim, u8 idx, u16 mask,
+	       u16 val, int bands)
 {
 	wlc_bmac_mhf(physhim->wlc_hw, idx, mask, val, bands);
 }
@@ -174,12 +174,12 @@ void wlapi_bmac_phy_reset(wlc_phy_shim_i
 	wlc_bmac_phy_reset(physhim->wlc_hw);
 }
 
-void wlapi_bmac_bw_set(wlc_phy_shim_info_t *physhim, uint16 bw)
+void wlapi_bmac_bw_set(wlc_phy_shim_info_t *physhim, u16 bw)
 {
 	wlc_bmac_bw_set(physhim->wlc_hw, bw);
 }
 
-uint16 wlapi_bmac_get_txant(wlc_phy_shim_info_t *physhim)
+u16 wlapi_bmac_get_txant(wlc_phy_shim_info_t *physhim)
 {
 	return wlc_bmac_get_txant(physhim->wlc_hw);
 }
@@ -222,7 +222,7 @@ wlapi_bmac_write_template_ram(wlc_phy_sh
 	wlc_bmac_write_template_ram(physhim->wlc_hw, offset, len, buf);
 }
 
-uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t *physhim, u8 rate)
+u16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t *physhim, u8 rate)
 {
 	return wlc_bmac_rate_shm_offset(physhim->wlc_hw, rate);
 }
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.h
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.h
@@ -76,10 +76,10 @@ extern void wlapi_intrsrestore(wlc_phy_s
 			       uint32 macintmask);
 
 extern void wlapi_bmac_write_shm(wlc_phy_shim_info_t *physhim, uint offset,
-				 uint16 v);
-extern uint16 wlapi_bmac_read_shm(wlc_phy_shim_info_t *physhim, uint offset);
+				 u16 v);
+extern u16 wlapi_bmac_read_shm(wlc_phy_shim_info_t *physhim, uint offset);
 extern void wlapi_bmac_mhf(wlc_phy_shim_info_t *physhim, u8 idx,
-			   uint16 mask, uint16 val, int bands);
+			   u16 mask, u16 val, int bands);
 extern void wlapi_bmac_corereset(wlc_phy_shim_info_t *physhim, uint32 flags);
 extern void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t *physhim);
 extern void wlapi_switch_macfreq(wlc_phy_shim_info_t *physhim, u8 spurmode);
@@ -87,7 +87,7 @@ extern void wlapi_enable_mac(wlc_phy_shi
 extern void wlapi_bmac_mctrl(wlc_phy_shim_info_t *physhim, uint32 mask,
 			     uint32 val);
 extern void wlapi_bmac_phy_reset(wlc_phy_shim_info_t *physhim);
-extern void wlapi_bmac_bw_set(wlc_phy_shim_info_t *physhim, uint16 bw);
+extern void wlapi_bmac_bw_set(wlc_phy_shim_info_t *physhim, u16 bw);
 extern void wlapi_bmac_phyclk_fgc(wlc_phy_shim_info_t *physhim, bool clk);
 extern void wlapi_bmac_macphyclk_set(wlc_phy_shim_info_t *physhim, bool clk);
 extern void wlapi_bmac_core_phypll_ctl(wlc_phy_shim_info_t *physhim, bool on);
@@ -98,7 +98,7 @@ extern void wlapi_bmac_ucode_wake_overri
 							physhim);
 extern void wlapi_bmac_write_template_ram(wlc_phy_shim_info_t *physhim, int o,
 					  int len, void *buf);
-extern uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t *physhim,
+extern u16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t *physhim,
 					 u8 rate);
 extern void wlapi_ucode_sample_init(wlc_phy_shim_info_t *physhim);
 extern void wlapi_copyfrom_objmem(wlc_phy_shim_info_t *physhim, uint,
@@ -111,5 +111,5 @@ extern void wlapi_high_update_phy_mode(w
 extern void wlapi_bmac_pktengtx(wlc_phy_shim_info_t *physhim,
 				wl_pkteng_t *pkteng, u8 rate,
 				struct ether_addr *sa, uint32 wait_delay);
-extern uint16 wlapi_bmac_get_txant(wlc_phy_shim_info_t *physhim);
+extern u16 wlapi_bmac_get_txant(wlc_phy_shim_info_t *physhim);
 #endif				/* _wlc_phy_shim_h_ */
--- a/drivers/staging/brcm80211/sys/wlc_pub.h
+++ b/drivers/staging/brcm80211/sys/wlc_pub.h
@@ -166,25 +166,25 @@ typedef struct wlc_event {
 /* wlc internal bss_info, wl external one is in wlioctl.h */
 typedef struct wlc_bss_info {
 	struct ether_addr BSSID;	/* network BSSID */
-	uint16 flags;		/* flags for internal attributes */
+	u16 flags;		/* flags for internal attributes */
 	u8 SSID_len;		/* the length of SSID */
 	u8 SSID[32];		/* SSID string */
 	int16 RSSI;		/* receive signal strength (in dBm) */
 	int16 SNR;		/* receive signal SNR in dB */
-	uint16 beacon_period;	/* units are Kusec */
-	uint16 atim_window;	/* units are Kusec */
+	u16 beacon_period;	/* units are Kusec */
+	u16 atim_window;	/* units are Kusec */
 	chanspec_t chanspec;	/* Channel num, bw, ctrl_sb and band */
 	s8 infra;		/* 0=IBSS, 1=infrastructure, 2=unknown */
 	wlc_rateset_t rateset;	/* supported rates */
 	u8 dtim_period;	/* DTIM period */
 	s8 phy_noise;		/* noise right after tx (in dBm) */
-	uint16 capability;	/* Capability information */
+	u16 capability;	/* Capability information */
 	struct dot11_bcn_prb *bcn_prb;	/* beacon/probe response frame (ioctl na) */
-	uint16 bcn_prb_len;	/* beacon/probe response frame length (ioctl na) */
+	u16 bcn_prb_len;	/* beacon/probe response frame length (ioctl na) */
 	u8 wme_qosinfo;	/* QoS Info from WME IE; valid if WLC_BSS_WME flag set */
 	struct rsn_parms wpa;
 	struct rsn_parms wpa2;
-	uint16 qbss_load_aac;	/* qbss load available admission capacity */
+	u16 qbss_load_aac;	/* qbss load available admission capacity */
 	/* qbss_load_chan_free <- (0xff - channel_utilization of qbss_load_ie_t) */
 	u8 qbss_load_chan_free;	/* indicates how free the channel is */
 	u8 mcipher;		/* multicast cipher */
@@ -299,7 +299,7 @@ typedef struct wlc_pub {
 	uint32 wlfeatureflag;	/* Flags to control sw features from registry */
 	int psq_pkts_total;	/* total num of ps pkts */
 
-	uint16 txmaxpkts;	/* max number of large pkts allowed to be pending */
+	u16 txmaxpkts;	/* max number of large pkts allowed to be pending */
 
 	/* s/w decryption counters */
 	uint32 swdecrypt;	/* s/w decrypt attempts */
@@ -308,7 +308,7 @@ typedef struct wlc_pub {
 
 	mbool radio_disabled;	/* bit vector for radio disabled reasons */
 	bool radio_active;	/* radio on/off state */
-	uint16 roam_time_thresh;	/* Max. # secs. of not hearing beacons
+	u16 roam_time_thresh;	/* Max. # secs. of not hearing beacons
 					 * before roaming.
 					 */
 	bool align_wd_tbtt;	/* Align watchdog with tbtt indication
@@ -322,7 +322,7 @@ typedef struct wlc_pub {
 	uint sdiod_drive_strength;	/* SDIO drive strength */
 #endif				/* BCMSDIO */
 
-	uint16 boardrev;	/* version # of particular board */
+	u16 boardrev;	/* version # of particular board */
 	u8 sromrev;		/* version # of the srom */
 	char srom_ccode[WLC_CNTRY_BUF_SZ];	/* Country Code in SROM */
 	uint32 boardflags;	/* Board specific flags from srom */
@@ -496,7 +496,7 @@ extern const u8 wme_fifo2ac[];
 #define WLCNTVAL(a)		0	/* No stats support */
 
 /* common functions for every port */
-extern void *wlc_attach(void *wl, uint16 vendor, uint16 device, uint unit,
+extern void *wlc_attach(void *wl, u16 vendor, u16 device, uint unit,
 			bool piomode, osl_t *osh, void *regsva, uint bustype,
 			void *btparam, uint *perr);
 extern uint wlc_detach(struct wlc_info *wlc);
@@ -507,7 +507,7 @@ extern int wlc_set(struct wlc_info *wlc,
 extern int wlc_get(struct wlc_info *wlc, int cmd, int *arg);
 extern int wlc_iovar_getint(struct wlc_info *wlc, const char *name, int *arg);
 extern int wlc_iovar_setint(struct wlc_info *wlc, const char *name, int arg);
-extern bool wlc_chipmatch(uint16 vendor, uint16 device);
+extern bool wlc_chipmatch(u16 vendor, u16 device);
 extern void wlc_init(struct wlc_info *wlc);
 extern void wlc_reset(struct wlc_info *wlc);
 
@@ -539,9 +539,9 @@ extern int wlc_bmac_down_finish(struct w
 extern uint32 wlc_reg_read(struct wlc_info *wlc, void *r, uint size);
 extern void wlc_reg_write(struct wlc_info *wlc, void *r, uint32 v, uint size);
 extern void wlc_corereset(struct wlc_info *wlc, uint32 flags);
-extern void wlc_mhf(struct wlc_info *wlc, u8 idx, uint16 mask, uint16 val,
+extern void wlc_mhf(struct wlc_info *wlc, u8 idx, u16 mask, u16 val,
 		    int bands);
-extern uint16 wlc_mhf_get(struct wlc_info *wlc, u8 idx, int bands);
+extern u16 wlc_mhf_get(struct wlc_info *wlc, u8 idx, int bands);
 extern uint32 wlc_delta_txfunfl(struct wlc_info *wlc, int fifo);
 extern void wlc_rate_lookup_init(struct wlc_info *wlc, wlc_rateset_t *rateset);
 extern void wlc_default_rateset(struct wlc_info *wlc, wlc_rateset_t *rs);
@@ -565,7 +565,7 @@ extern void wlc_event_if(struct wlc_info
 			 wlc_event_t *e, const struct ether_addr *addr);
 extern void wlc_suspend_mac_and_wait(struct wlc_info *wlc);
 extern void wlc_enable_mac(struct wlc_info *wlc);
-extern uint16 wlc_rate_shm_offset(struct wlc_info *wlc, u8 rate);
+extern u16 wlc_rate_shm_offset(struct wlc_info *wlc, u8 rate);
 extern uint32 wlc_get_rspec_history(struct wlc_bsscfg *cfg);
 extern uint32 wlc_get_current_highest_rate(struct wlc_bsscfg *cfg);
 
--- a/drivers/staging/brcm80211/sys/wlc_rpctx.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpctx.h
@@ -44,7 +44,7 @@ extern void wlc_rpctx_txreclaim(rpctx_in
 extern uint wlc_rpctx_txavail(rpctx_info_t *rpctx, uint fifo);
 extern int wlc_rpctx_pkteng(rpctx_info_t *rpctx, uint fifo, void *p);
 extern int wlc_rpctx_tx(rpctx_info_t *rpctx, uint fifo, void *p, bool commit,
-			uint16 frameid, u8 txpktpend);
+			u16 frameid, u8 txpktpend);
 extern void wlc_rpctx_txpktpendinc(rpctx_info_t *rpctx, uint fifo, u8 val);
 extern void wlc_rpctx_txpktpenddec(rpctx_info_t *rpctx, uint fifo, u8 val);
 extern void wlc_rpctx_txpktpendclr(rpctx_info_t *rpctx, uint fifo);
--- a/drivers/staging/brcm80211/sys/wlc_scb.h
+++ b/drivers/staging/brcm80211/sys/wlc_scb.h
@@ -38,7 +38,7 @@ typedef struct scb_ampdu {
 	u8 mpdu_density;	/* mpdu density */
 	u8 max_pdu;		/* max pdus allowed in ampdu */
 	u8 release;		/* # of mpdus released at a time */
-	uint16 min_len;		/* min mpdu len to support the density */
+	u16 min_len;		/* min mpdu len to support the density */
 	uint32 max_rxlen;	/* max ampdu rcv length; 8k, 16k, 32k, 64k */
 	struct pktq txq;	/* sdu transmit queue pending aggregation */
 
@@ -62,11 +62,11 @@ struct scb {
 	void *fragbuf[NUMPRIO];	/* defragmentation buffer per prio */
 	uint fragresid[NUMPRIO];	/* #bytes unused in frag buffer per prio */
 
-	uint16 seqctl[NUMPRIO];	/* seqctl of last received frame (for dups) */
-	uint16 seqctl_nonqos;	/* seqctl of last received frame (for dups) for
+	u16 seqctl[NUMPRIO];	/* seqctl of last received frame (for dups) */
+	u16 seqctl_nonqos;	/* seqctl of last received frame (for dups) for
 				 * non-QoS data and management
 				 */
-	uint16 seqnum[NUMPRIO];	/* WME: driver maintained sw seqnum per priority */
+	u16 seqnum[NUMPRIO];	/* WME: driver maintained sw seqnum per priority */
 
 	scb_ampdu_t scb_ampdu;	/* AMPDU state including per tid info */
 };
--- a/drivers/staging/brcm80211/sys/wlc_stf.c
+++ b/drivers/staging/brcm80211/sys/wlc_stf.c
@@ -49,7 +49,7 @@ static int wlc_stf_spatial_policy_set(wl
 static void wlc_stf_stbc_rx_ht_update(wlc_info_t *wlc, int val);
 
 static void _wlc_stf_phy_txant_upd(wlc_info_t *wlc);
-static uint16 _wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec);
+static u16 _wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec);
 
 #define NSTS_1	1
 #define NSTS_2	2
@@ -108,7 +108,7 @@ void wlc_tempsense_upd(wlc_info_t *wlc)
 }
 
 void
-wlc_stf_ss_algo_channel_get(wlc_info_t *wlc, uint16 *ss_algo_channel,
+wlc_stf_ss_algo_channel_get(wlc_info_t *wlc, u16 *ss_algo_channel,
 			    chanspec_t chanspec)
 {
 	tx_power_t power;
@@ -118,7 +118,7 @@ wlc_stf_ss_algo_channel_get(wlc_info_t *
 	*ss_algo_channel = 0;
 
 	if (!wlc->pub->up) {
-		*ss_algo_channel = (uint16) -1;
+		*ss_algo_channel = (u16) -1;
 		return;
 	}
 
@@ -380,7 +380,7 @@ int wlc_stf_ss_update(wlc_info_t *wlc, w
 	/* NOTE: opmode can only be SISO or CDD as STBC is decided on a per-packet basis */
 	if (WLC_STBC_CAP_PHY(wlc) &&
 	    wlc->stf->ss_algosel_auto
-	    && (wlc->stf->ss_algo_channel != (uint16) -1)) {
+	    && (wlc->stf->ss_algo_channel != (u16) -1)) {
 		ASSERT(isset(&wlc->stf->ss_algo_channel, PHY_TXC1_MODE_CDD)
 		       || isset(&wlc->stf->ss_algo_channel,
 				PHY_TXC1_MODE_SISO));
@@ -422,7 +422,7 @@ int BCMATTACHFN(wlc_stf_attach) (wlc_inf
 
 	if (WLC_STBC_CAP_PHY(wlc)) {
 		wlc->stf->ss_algosel_auto = TRUE;
-		wlc->stf->ss_algo_channel = (uint16) -1;	/* Init the default value */
+		wlc->stf->ss_algo_channel = (u16) -1;	/* Init the default value */
 	}
 	return 0;
 }
@@ -561,9 +561,9 @@ void BCMATTACHFN(wlc_stf_phy_chain_calc)
 	wlc_stf_spatial_policy_set(wlc, MIN_SPATIAL_EXPANSION);
 }
 
-static uint16 _wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec)
+static u16 _wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec)
 {
-	uint16 phytxant = wlc->stf->phytxant;
+	u16 phytxant = wlc->stf->phytxant;
 
 	if (RSPEC_STF(rspec) != PHY_TXC1_MODE_SISO) {
 		ASSERT(wlc->stf->txstreams > 1);
@@ -574,15 +574,15 @@ static uint16 _wlc_stf_phytxchain_sel(wl
 	return phytxant;
 }
 
-uint16 wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec)
+u16 wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec)
 {
 	return _wlc_stf_phytxchain_sel(wlc, rspec);
 }
 
-uint16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t *wlc, ratespec_t rspec)
+u16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t *wlc, ratespec_t rspec)
 {
-	uint16 phytxant = wlc->stf->phytxant;
-	uint16 mask = PHY_TXC_ANT_MASK;
+	u16 phytxant = wlc->stf->phytxant;
+	u16 mask = PHY_TXC_ANT_MASK;
 
 	/* for non-siso rates or default setting, use the available chains */
 	if (WLCISNPHY(wlc->band)) {
--- a/drivers/staging/brcm80211/sys/wlc_stf.h
+++ b/drivers/staging/brcm80211/sys/wlc_stf.h
@@ -25,7 +25,7 @@ extern void wlc_stf_detach(wlc_info_t *w
 
 extern void wlc_tempsense_upd(wlc_info_t *wlc);
 extern void wlc_stf_ss_algo_channel_get(wlc_info_t *wlc,
-					uint16 *ss_algo_channel,
+					u16 *ss_algo_channel,
 					chanspec_t chanspec);
 extern int wlc_stf_ss_update(wlc_info_t *wlc, struct wlcband *band);
 extern void wlc_stf_phy_txant_upd(wlc_info_t *wlc);
@@ -36,7 +36,7 @@ extern bool wlc_stf_stbc_rx_set(wlc_info
 extern int wlc_stf_ant_txant_validate(wlc_info_t *wlc, s8 val);
 extern void wlc_stf_phy_txant_upd(wlc_info_t *wlc);
 extern void wlc_stf_phy_chain_calc(wlc_info_t *wlc);
-extern uint16 wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec);
-extern uint16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t *wlc, ratespec_t rspec);
-extern uint16 wlc_stf_spatial_expansion_get(wlc_info_t *wlc, ratespec_t rspec);
+extern u16 wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec);
+extern u16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t *wlc, ratespec_t rspec);
+extern u16 wlc_stf_spatial_expansion_get(wlc_info_t *wlc, ratespec_t rspec);
 #endif				/* _wlc_stf_h_ */
--- a/drivers/staging/brcm80211/util/bcmotp.c
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -59,8 +59,8 @@
 typedef int (*otp_status_t) (void *oh);
 typedef int (*otp_size_t) (void *oh);
 typedef void *(*otp_init_t) (si_t *sih);
-typedef uint16(*otp_read_bit_t) (void *oh, chipcregs_t *cc, uint off);
-typedef int (*otp_read_region_t) (si_t *sih, int region, uint16 *data,
+typedef u16(*otp_read_bit_t) (void *oh, chipcregs_t *cc, uint off);
+typedef int (*otp_read_region_t) (si_t *sih, int region, u16 *data,
 				  uint *wlen);
 typedef int (*otp_nvread_t) (void *oh, char *data, uint *len);
 
@@ -82,18 +82,18 @@ typedef struct {
 
 #ifdef BCMIPXOTP
 	/* IPX OTP section */
-	uint16 wsize;		/* Size of otp in words */
-	uint16 rows;		/* Geometry */
-	uint16 cols;		/* Geometry */
+	u16 wsize;		/* Size of otp in words */
+	u16 rows;		/* Geometry */
+	u16 cols;		/* Geometry */
 	uint32 status;		/* Flag bits (lock/prog/rv).
 				 * (Reflected only when OTP is power cycled)
 				 */
-	uint16 hwbase;		/* hardware subregion offset */
-	uint16 hwlim;		/* hardware subregion boundary */
-	uint16 swbase;		/* software subregion offset */
-	uint16 swlim;		/* software subregion boundary */
-	uint16 fbase;		/* fuse subregion offset */
-	uint16 flim;		/* fuse subregion boundary */
+	u16 hwbase;		/* hardware subregion offset */
+	u16 hwlim;		/* hardware subregion boundary */
+	u16 swbase;		/* software subregion offset */
+	u16 swlim;		/* software subregion boundary */
+	u16 fbase;		/* fuse subregion offset */
+	u16 flim;		/* fuse subregion boundary */
 	int otpgu_base;		/* offset to General Use Region */
 #endif				/* BCMIPXOTP */
 
@@ -173,7 +173,7 @@ static int ipxotp_size(void *oh)
 	return (int)oi->wsize * 2;
 }
 
-static uint16 ipxotp_otpr(void *oh, chipcregs_t *cc, uint wn)
+static u16 ipxotp_otpr(void *oh, chipcregs_t *cc, uint wn)
 {
 	otpinfo_t *oi;
 
@@ -185,7 +185,7 @@ static uint16 ipxotp_otpr(void *oh, chip
 	return R_REG(oi->osh, &cc->sromotp[wn]);
 }
 
-static uint16 ipxotp_read_bit(void *oh, chipcregs_t *cc, uint off)
+static u16 ipxotp_read_bit(void *oh, chipcregs_t *cc, uint off)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint k, row, col;
@@ -373,7 +373,7 @@ static void *BCMNMIATTACHFN(ipxotp_init)
 	return (void *)oi;
 }
 
-static int ipxotp_read_region(void *oh, int region, uint16 *data, uint *wlen)
+static int ipxotp_read_region(void *oh, int region, u16 *data, uint *wlen)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint idx;
@@ -567,26 +567,26 @@ static int hndotp_size(void *oh)
 	return (int)(oi->size);
 }
 
-static uint16 hndotp_otpr(void *oh, chipcregs_t *cc, uint wn)
+static u16 hndotp_otpr(void *oh, chipcregs_t *cc, uint wn)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	osl_t *osh;
-	volatile uint16 *ptr;
+	volatile u16 *ptr;
 
 	ASSERT(wn < ((oi->size / 2) + OTP_RC_LIM_OFF));
 	ASSERT(cc != NULL);
 
 	osh = si_osh(oi->sih);
 
-	ptr = (volatile uint16 *)((volatile char *)cc + CC_SROM_OTP);
+	ptr = (volatile u16 *)((volatile char *)cc + CC_SROM_OTP);
 	return R_REG(osh, &ptr[wn]);
 }
 
-static uint16 hndotp_otproff(void *oh, chipcregs_t *cc, int woff)
+static u16 hndotp_otproff(void *oh, chipcregs_t *cc, int woff)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	osl_t *osh;
-	volatile uint16 *ptr;
+	volatile u16 *ptr;
 
 	ASSERT(woff >= (-((int)oi->size / 2)));
 	ASSERT(woff < OTP_LIM_OFF);
@@ -594,12 +594,12 @@ static uint16 hndotp_otproff(void *oh, c
 
 	osh = si_osh(oi->sih);
 
-	ptr = (volatile uint16 *)((volatile char *)cc + CC_SROM_OTP);
+	ptr = (volatile u16 *)((volatile char *)cc + CC_SROM_OTP);
 
 	return R_REG(osh, &ptr[(oi->size / 2) + woff]);
 }
 
-static uint16 hndotp_read_bit(void *oh, chipcregs_t *cc, uint idx)
+static u16 hndotp_read_bit(void *oh, chipcregs_t *cc, uint idx)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint k, row, col;
@@ -627,7 +627,7 @@ static uint16 hndotp_read_bit(void *oh,
 		return 0xffff;
 	}
 	st = (st & OTPP_VALUE_MASK) >> OTPP_VALUE_SHIFT;
-	return (uint16) st;
+	return (u16) st;
 }
 
 static void *BCMNMIATTACHFN(hndotp_init) (si_t *sih)
@@ -706,7 +706,7 @@ static void *BCMNMIATTACHFN(hndotp_init)
 	return ret;
 }
 
-static int hndotp_read_region(void *oh, int region, uint16 *data, uint *wlen)
+static int hndotp_read_region(void *oh, int region, u16 *data, uint *wlen)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint32 idx, st;
@@ -745,7 +745,7 @@ static int hndotp_nvread(void *oh, char
 	uint32 idx;
 	chipcregs_t *cc;
 	uint offset;
-	uint16 *rawotp = NULL;
+	u16 *rawotp = NULL;
 
 	/* save the orig core */
 	idx = si_coreidx(oi->sih);
@@ -885,12 +885,12 @@ int otp_size(void *oh)
 	return oi->fn->size(oh);
 }
 
-uint16 otp_read_bit(void *oh, uint offset)
+u16 otp_read_bit(void *oh, uint offset)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint idx = si_coreidx(oi->sih);
 	chipcregs_t *cc = si_setcoreidx(oi->sih, SI_CC_IDX);
-	uint16 readBit = (uint16) oi->fn->read_bit(oh, cc, offset);
+	u16 readBit = (u16) oi->fn->read_bit(oh, cc, offset);
 	si_setcoreidx(oi->sih, idx);
 	return readBit;
 }
@@ -928,7 +928,7 @@ void *BCMNMIATTACHFN(otp_init) (si_t *si
 }
 
 int
-BCMNMIATTACHFN(otp_read_region) (si_t *sih, int region, uint16 *data,
+BCMNMIATTACHFN(otp_read_region) (si_t *sih, int region, u16 *data,
 				 uint *wlen) {
 	bool wasup = FALSE;
 	void *oh;
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -70,7 +70,7 @@ extern uint _varsz;
 
 static int initvars_srom_si(si_t *sih, osl_t *osh, void *curmap, char **vars,
 			    uint *count);
-static void _initvars_srom_pci(u8 sromrev, uint16 *srom, uint off,
+static void _initvars_srom_pci(u8 sromrev, u16 *srom, uint off,
 			       varbuf_t *b);
 static int initvars_srom_pci(si_t *sih, void *curmap, char **vars,
 			     uint *count);
@@ -78,15 +78,15 @@ static int initvars_flash_si(si_t *sih,
 #ifdef BCMSDIO
 static int initvars_cis_sdio(osl_t *osh, char **vars, uint *count);
 static int sprom_cmd_sdio(osl_t *osh, u8 cmd);
-static int sprom_read_sdio(osl_t *osh, uint16 addr, uint16 *data);
+static int sprom_read_sdio(osl_t *osh, u16 addr, u16 *data);
 #endif				/* BCMSDIO */
-static int sprom_read_pci(osl_t *osh, si_t *sih, uint16 *sprom, uint wordoff,
-			  uint16 *buf, uint nwords, bool check_crc);
+static int sprom_read_pci(osl_t *osh, si_t *sih, u16 *sprom, uint wordoff,
+			  u16 *buf, uint nwords, bool check_crc);
 #if defined(BCMNVRAMR)
-static int otp_read_pci(osl_t *osh, si_t *sih, uint16 *buf, uint bufsz);
+static int otp_read_pci(osl_t *osh, si_t *sih, u16 *buf, uint bufsz);
 #endif
-static uint16 srom_cc_cmd(si_t *sih, osl_t *osh, void *ccregs, uint32 cmd,
-			  uint wordoff, uint16 data);
+static u16 srom_cc_cmd(si_t *sih, osl_t *osh, void *ccregs, uint32 cmd,
+			  uint wordoff, u16 data);
 
 static int initvars_table(osl_t *osh, char *start, char *end, char **vars,
 			  uint *count);
@@ -197,7 +197,7 @@ BCMATTACHFN(srom_var_init) (si_t *sih, u
 /* support only 16-bit word read from srom */
 int
 srom_read(si_t *sih, uint bustype, void *curmap, osl_t *osh,
-	  uint byteoff, uint nbytes, uint16 *buf, bool check_crc)
+	  uint byteoff, uint nbytes, u16 *buf, bool check_crc)
 {
 	uint off, nw;
 #ifdef BCMSDIO
@@ -218,9 +218,9 @@ srom_read(si_t *sih, uint bustype, void
 			return 1;
 
 		if (si_is_sprom_available(sih)) {
-			uint16 *srom;
+			u16 *srom;
 
-			srom = (uint16 *) SROM_OFFSET(sih);
+			srom = (u16 *) SROM_OFFSET(sih);
 			if (srom == NULL)
 				return 1;
 
@@ -240,7 +240,7 @@ srom_read(si_t *sih, uint bustype, void
 		nw = nbytes / 2;
 		for (i = 0; i < nw; i++) {
 			if (sprom_read_sdio
-			    (osh, (uint16) (off + i), (uint16 *) (buf + i)))
+			    (osh, (u16) (off + i), (u16 *) (buf + i)))
 				return 1;
 		}
 #endif				/* BCMSDIO */
@@ -1014,7 +1014,7 @@ BCMATTACHFN(srom_parsecis) (osl_t *osh,
 					break;
 
 				case HNBU_FEM:{
-						uint16 fem =
+						u16 fem =
 						    (cis[i + 2] << 8) + cis[i +
 									    1];
 						varbuf_append(&b,
@@ -1336,7 +1336,7 @@ BCMATTACHFN(srom_parsecis) (osl_t *osh,
 #if defined(BCMSDIO)
 				case HNBU_SROM3SWRGN:
 					if (tlen >= 73) {
-						uint16 srom[35];
+						u16 srom[35];
 						u8 srev = cis[i + 1 + 70];
 						ASSERT(srev == 3);
 						/* make tuple value 16-bit aligned and parse it */
@@ -1412,9 +1412,9 @@ BCMATTACHFN(srom_parsecis) (osl_t *osh,
 /* In chips with chipcommon rev 32 and later, the srom is in chipcommon,
  * not in the bus cores.
  */
-static uint16
+static u16
 srom_cc_cmd(si_t *sih, osl_t *osh, void *ccregs, uint32 cmd, uint wordoff,
-	    uint16 data)
+	    u16 data)
 {
 	chipcregs_t *cc = (chipcregs_t *) ccregs;
 	uint wait_cnt = 1000;
@@ -1437,7 +1437,7 @@ srom_cc_cmd(si_t *sih, osl_t *osh, void
 		return 0xffff;
 	}
 	if (cmd == SRC_OP_READ)
-		return (uint16) R_REG(osh, &cc->sromdata);
+		return (u16) R_REG(osh, &cc->sromdata);
 	else
 		return 0xffff;
 }
@@ -1447,8 +1447,8 @@ srom_cc_cmd(si_t *sih, osl_t *osh, void
  * Return 0 on success, nonzero on error.
  */
 static int
-sprom_read_pci(osl_t *osh, si_t *sih, uint16 *sprom, uint wordoff,
-	       uint16 *buf, uint nwords, bool check_crc)
+sprom_read_pci(osl_t *osh, si_t *sih, u16 *sprom, uint wordoff,
+	       u16 *buf, uint nwords, bool check_crc)
 {
 	int err = 0;
 	uint i;
@@ -1507,7 +1507,7 @@ sprom_read_pci(osl_t *osh, si_t *sih, ui
 }
 
 #if defined(BCMNVRAMR)
-static int otp_read_pci(osl_t *osh, si_t *sih, uint16 *buf, uint bufsz)
+static int otp_read_pci(osl_t *osh, si_t *sih, u16 *buf, uint bufsz)
 {
 	u8 *otp;
 	uint sz = OTP_SZ_MAX / 2;	/* size in words */
@@ -1522,7 +1522,7 @@ static int otp_read_pci(osl_t *osh, si_t
 
 	bzero(otp, OTP_SZ_MAX);
 
-	err = otp_read_region(sih, OTP_HW_RGN, (uint16 *) otp, &sz);
+	err = otp_read_region(sih, OTP_HW_RGN, (u16 *) otp, &sz);
 
 	bcopy(otp, buf, bufsz);
 
@@ -1673,7 +1673,7 @@ BCMATTACHFN(initvars_flash_si) (si_t *si
  * SROM3_SWRG_OFF (full SROM or software region).
  */
 
-static uint mask_shift(uint16 mask)
+static uint mask_shift(u16 mask)
 {
 	uint i;
 	for (i = 0; i < (sizeof(mask) << 3); i++) {
@@ -1684,7 +1684,7 @@ static uint mask_shift(uint16 mask)
 	return 0;
 }
 
-static uint mask_width(uint16 mask)
+static uint mask_width(u16 mask)
 {
 	int i;
 	for (i = (sizeof(mask) << 3) - 1; i >= 0; i--) {
@@ -1696,7 +1696,7 @@ static uint mask_width(uint16 mask)
 }
 
 #if defined(BCMDBG)
-static bool mask_valid(uint16 mask)
+static bool mask_valid(u16 mask)
 {
 	uint shift = mask_shift(mask);
 	uint width = mask_width(mask);
@@ -1705,9 +1705,9 @@ static bool mask_valid(uint16 mask)
 #endif				/* BCMDBG */
 
 static void
-BCMATTACHFN(_initvars_srom_pci) (u8 sromrev, uint16 *srom, uint off,
+BCMATTACHFN(_initvars_srom_pci) (u8 sromrev, u16 *srom, uint off,
 				 varbuf_t *b) {
-	uint16 w;
+	u16 w;
 	uint32 val;
 	const sromvar_t *srv;
 	uint width;
@@ -1856,7 +1856,7 @@ BCMATTACHFN(_initvars_srom_pci) (u8 srom
 static int
 BCMATTACHFN(initvars_srom_pci) (si_t *sih, void *curmap, char **vars,
 				uint *count) {
-	uint16 *srom, *sromwindow;
+	u16 *srom, *sromwindow;
 	u8 sromrev = 0;
 	uint32 sr;
 	varbuf_t b;
@@ -1876,7 +1876,7 @@ BCMATTACHFN(initvars_srom_pci) (si_t *si
 	if (!srom)
 		return -2;
 
-	sromwindow = (uint16 *) SROM_OFFSET(sih);
+	sromwindow = (u16 *) SROM_OFFSET(sih);
 	if (si_is_sprom_available(sih)) {
 		err =
 		    sprom_read_pci(osh, sih, sromwindow, 0, srom, SROM_WORDS,
@@ -2059,7 +2059,7 @@ static int BCMATTACHFN(sprom_cmd_sdio) (
 }
 
 /* read a word from the SDIO srom */
-static int sprom_read_sdio(osl_t *osh, uint16 addr, uint16 *data)
+static int sprom_read_sdio(osl_t *osh, u16 addr, u16 *data)
 {
 	u8 addr_l, addr_h, data_l, data_h;
 
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -200,9 +200,9 @@ void pktq_init(struct pktq *pq, int num_
 	bzero(pq,
 	      OFFSETOF(struct pktq, q) + (sizeof(struct pktq_prec) * num_prec));
 
-	pq->num_prec = (uint16) num_prec;
+	pq->num_prec = (u16) num_prec;
 
-	pq->max = (uint16) max_len;
+	pq->max = (u16) max_len;
 
 	for (prec = 0; prec < num_prec; prec++)
 		pq->q[prec].max = pq->max;
@@ -491,7 +491,7 @@ u8 BCMROMFN(hndcrc8) (u8 *pdata,	/* poin
  * ****************************************************************************
  */
 
-static const uint16 crc16_table[256] = {
+static const u16 crc16_table[256] = {
 	0x0000, 0x1189, 0x2312, 0x329B, 0x4624, 0x57AD, 0x6536, 0x74BF,
 	0x8C48, 0x9DC1, 0xAF5A, 0xBED3, 0xCA6C, 0xDBE5, 0xE97E, 0xF8F7,
 	0x1081, 0x0108, 0x3393, 0x221A, 0x56A5, 0x472C, 0x75B7, 0x643E,
@@ -526,9 +526,9 @@ static const uint16 crc16_table[256] = {
 	0x7BC7, 0x6A4E, 0x58D5, 0x495C, 0x3DE3, 0x2C6A, 0x1EF1, 0x0F78
 };
 
-uint16 BCMROMFN(hndcrc16) (u8 *pdata,	/* pointer to array of data to process */
+u16 BCMROMFN(hndcrc16) (u8 *pdata,	/* pointer to array of data to process */
 			   uint nbytes,	/* number of input data bytes to process */
-			   uint16 crc	/* either CRC16_INIT_VALUE or previous return value */
+			   u16 crc	/* either CRC16_INIT_VALUE or previous return value */
     ) {
 	while (nbytes-- > 0)
 		CRC_INNER_LOOP(16, crc, *pdata++);
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -98,37 +98,37 @@ typedef struct dma_info {
 		} d64_u;
 	} dregs;
 
-	uint16 dmadesc_align;	/* alignment requirement for dma descriptors */
+	u16 dmadesc_align;	/* alignment requirement for dma descriptors */
 
-	uint16 ntxd;		/* # tx descriptors tunable */
-	uint16 txin;		/* index of next descriptor to reclaim */
-	uint16 txout;		/* index of next descriptor to post */
+	u16 ntxd;		/* # tx descriptors tunable */
+	u16 txin;		/* index of next descriptor to reclaim */
+	u16 txout;		/* index of next descriptor to post */
 	void **txp;		/* pointer to parallel array of pointers to packets */
 	osldma_t *tx_dmah;	/* DMA TX descriptor ring handle */
 	hnddma_seg_map_t *txp_dmah;	/* DMA MAP meta-data handle */
 	dmaaddr_t txdpa;	/* Aligned physical address of descriptor ring */
 	dmaaddr_t txdpaorig;	/* Original physical address of descriptor ring */
-	uint16 txdalign;	/* #bytes added to alloc'd mem to align txd */
+	u16 txdalign;	/* #bytes added to alloc'd mem to align txd */
 	uint32 txdalloc;	/* #bytes allocated for the ring */
 	uint32 xmtptrbase;	/* When using unaligned descriptors, the ptr register
 				 * is not just an index, it needs all 13 bits to be
 				 * an offset from the addr register.
 				 */
 
-	uint16 nrxd;		/* # rx descriptors tunable */
-	uint16 rxin;		/* index of next descriptor to reclaim */
-	uint16 rxout;		/* index of next descriptor to post */
+	u16 nrxd;		/* # rx descriptors tunable */
+	u16 rxin;		/* index of next descriptor to reclaim */
+	u16 rxout;		/* index of next descriptor to post */
 	void **rxp;		/* pointer to parallel array of pointers to packets */
 	osldma_t *rx_dmah;	/* DMA RX descriptor ring handle */
 	hnddma_seg_map_t *rxp_dmah;	/* DMA MAP meta-data handle */
 	dmaaddr_t rxdpa;	/* Aligned physical address of descriptor ring */
 	dmaaddr_t rxdpaorig;	/* Original physical address of descriptor ring */
-	uint16 rxdalign;	/* #bytes added to alloc'd mem to align rxd */
+	u16 rxdalign;	/* #bytes added to alloc'd mem to align rxd */
 	uint32 rxdalloc;	/* #bytes allocated for the ring */
 	uint32 rcvptrbase;	/* Base for ptr reg when using unaligned descriptors */
 
 	/* tunables */
-	uint16 rxbufsize;	/* rx buffer size in bytes,
+	u16 rxbufsize;	/* rx buffer size in bytes,
 				 * not including the extra headroom
 				 */
 	uint rxextrahdrroom;	/* extra rx headroom, reverseved to assist upper stack
@@ -206,8 +206,8 @@ static bool _dma_rxfill(dma_info_t *di);
 static void _dma_rxreclaim(dma_info_t *di);
 static void _dma_rxenable(dma_info_t *di);
 static void *_dma_getnextrxp(dma_info_t *di, bool forceall);
-static void _dma_rx_param_get(dma_info_t *di, uint16 *rxoffset,
-			      uint16 *rxbufsize);
+static void _dma_rx_param_get(dma_info_t *di, u16 *rxoffset,
+			      u16 *rxbufsize);
 
 static void _dma_txblock(dma_info_t *di);
 static void _dma_txunblock(dma_info_t *di);
@@ -224,7 +224,7 @@ static void _dma_fifoloopbackenable(dma_
 static uint _dma_ctrlflags(dma_info_t *di, uint mask, uint flags);
 static u8 dma_align_sizetobits(uint size);
 static void *dma_ringalloc(osl_t *osh, uint32 boundary, uint size,
-			   uint16 *alignbits, uint *alloced,
+			   u16 *alignbits, uint *alloced,
 			   dmaaddr_t *descpa, osldma_t **dmah);
 
 /* Prototypes for 32-bit routines */
@@ -446,18 +446,18 @@ hnddma_t *dma_attach(osl_t *osh, char *n
 	di->sih = sih;
 
 	/* save tunables */
-	di->ntxd = (uint16) ntxd;
-	di->nrxd = (uint16) nrxd;
+	di->ntxd = (u16) ntxd;
+	di->nrxd = (u16) nrxd;
 
 	/* the actual dma size doesn't include the extra headroom */
 	di->rxextrahdrroom =
 	    (rxextheadroom == -1) ? BCMEXTRAHDROOM : rxextheadroom;
 	if (rxbufsize > BCMEXTRAHDROOM)
-		di->rxbufsize = (uint16) (rxbufsize - di->rxextrahdrroom);
+		di->rxbufsize = (u16) (rxbufsize - di->rxextrahdrroom);
 	else
-		di->rxbufsize = (uint16) rxbufsize;
+		di->rxbufsize = (u16) rxbufsize;
 
-	di->nrxpost = (uint16) nrxpost;
+	di->nrxpost = (u16) nrxpost;
 	di->rxoffset = (u8) rxoffset;
 
 	/*
@@ -970,11 +970,11 @@ static void _dma_rxenable(dma_info_t *di
 }
 
 static void
-_dma_rx_param_get(dma_info_t *di, uint16 *rxoffset, uint16 *rxbufsize)
+_dma_rx_param_get(dma_info_t *di, u16 *rxoffset, u16 *rxbufsize)
 {
 	/* the normal values fit into 16 bits */
-	*rxoffset = (uint16) di->rxoffset;
-	*rxbufsize = (uint16) di->rxbufsize;
+	*rxoffset = (u16) di->rxoffset;
+	*rxbufsize = (u16) di->rxbufsize;
 }
 
 /* !! rx entry routine
@@ -998,15 +998,15 @@ static void *BCMFASTPATH _dma_rx(dma_inf
 	if (head == NULL)
 		return NULL;
 
-	len = ltoh16(*(uint16 *) (PKTDATA(head)));
+	len = ltoh16(*(u16 *) (PKTDATA(head)));
 	DMA_TRACE(("%s: dma_rx len %d\n", di->name, len));
 
 #if defined(__mips__)
 	if (!len) {
-		while (!(len = *(uint16 *) OSL_UNCACHED(PKTDATA(head))))
+		while (!(len = *(u16 *) OSL_UNCACHED(PKTDATA(head))))
 			OSL_DELAY(1);
 
-		*(uint16 *) PKTDATA(head) = htol16((uint16) len);
+		*(u16 *) PKTDATA(head) = htol16((u16) len);
 	}
 #endif				/* defined(__mips__) */
 
@@ -1064,7 +1064,7 @@ static void *BCMFASTPATH _dma_rx(dma_inf
 static bool BCMFASTPATH _dma_rxfill(dma_info_t *di)
 {
 	void *p;
-	uint16 rxin, rxout;
+	u16 rxin, rxout;
 	uint32 flags = 0;
 	uint n;
 	uint i;
@@ -1406,7 +1406,7 @@ u8 dma_align_sizetobits(uint size)
  * not cross page boundary
  */
 static void *dma_ringalloc(osl_t *osh, uint32 boundary, uint size,
-			   uint16 *alignbits, uint *alloced,
+			   u16 *alignbits, uint *alloced,
 			   dmaaddr_t *descpa, osldma_t **dmah)
 {
 	void *va;
@@ -1522,8 +1522,8 @@ static bool dma32_alloc(dma_info_t *di,
 	uint ddlen;
 	void *va;
 	uint alloced;
-	uint16 align;
-	uint16 align_bits;
+	u16 align;
+	u16 align_bits;
 
 	ddlen = sizeof(dma32dd_t);
 
@@ -1666,7 +1666,7 @@ static int dma32_txfast(dma_info_t *di,
 	void *p, *next;
 	unsigned char *data;
 	uint len;
-	uint16 txout;
+	u16 txout;
 	uint32 flags = 0;
 	dmaaddr_t pa;
 
@@ -1789,8 +1789,8 @@ static int dma32_txfast(dma_info_t *di,
  */
 static void *dma32_getnexttxp(dma_info_t *di, txd_range_t range)
 {
-	uint16 start, end, i;
-	uint16 active_desc;
+	u16 start, end, i;
+	u16 active_desc;
 	void *txp;
 
 	DMA_TRACE(("%s: dma_getnexttxp %s\n", di->name,
@@ -1811,14 +1811,14 @@ static void *dma32_getnexttxp(dma_info_t
 		dma32regs_t *dregs = di->d32txregs;
 
 		end =
-		    (uint16) B2I(R_REG(di->osh, &dregs->status) & XS_CD_MASK,
+		    (u16) B2I(R_REG(di->osh, &dregs->status) & XS_CD_MASK,
 				 dma32dd_t);
 
 		if (range == HNDDMA_RANGE_TRANSFERED) {
 			active_desc =
-			    (uint16) ((R_REG(di->osh, &dregs->status) &
+			    (u16) ((R_REG(di->osh, &dregs->status) &
 				       XS_AD_MASK) >> XS_AD_SHIFT);
-			active_desc = (uint16) B2I(active_desc, dma32dd_t);
+			active_desc = (u16) B2I(active_desc, dma32dd_t);
 			if (end != active_desc)
 				end = PREVTXD(active_desc);
 		}
@@ -1918,17 +1918,17 @@ static void *dma32_getnextrxp(dma_info_t
  */
 static void dma32_txrotate(dma_info_t *di)
 {
-	uint16 ad;
+	u16 ad;
 	uint nactive;
 	uint rot;
-	uint16 old, new;
+	u16 old, new;
 	uint32 w;
-	uint16 first, last;
+	u16 first, last;
 
 	ASSERT(dma32_txsuspendedidle(di));
 
 	nactive = _dma_txactive(di);
-	ad = (uint16) (B2I
+	ad = (u16) (B2I
 		       (((R_REG(di->osh, &di->d32txregs->status) & XS_AD_MASK)
 			 >> XS_AD_SHIFT), dma32dd_t));
 	rot = TXD(ad - di->txin);
@@ -2088,12 +2088,12 @@ static bool dma64_rxstopped(dma_info_t *
 
 static bool dma64_alloc(dma_info_t *di, uint direction)
 {
-	uint16 size;
+	u16 size;
 	uint ddlen;
 	void *va;
 	uint alloced = 0;
-	uint16 align;
-	uint16 align_bits;
+	u16 align;
+	u16 align_bits;
 
 	ddlen = sizeof(dma64dd_t);
 
@@ -2260,7 +2260,7 @@ static void *dma64_getpos(dma_info_t *di
  */
 static int dma64_txunframed(dma_info_t *di, void *buf, uint len, bool commit)
 {
-	uint16 txout;
+	u16 txout;
 	uint32 flags = 0;
 	dmaaddr_t pa;		/* phys addr */
 
@@ -2317,7 +2317,7 @@ static int BCMFASTPATH dma64_txfast(dma_
 	void *p, *next;
 	unsigned char *data;
 	uint len;
-	uint16 txout;
+	u16 txout;
 	uint32 flags = 0;
 	dmaaddr_t pa;
 
@@ -2439,8 +2439,8 @@ static int BCMFASTPATH dma64_txfast(dma_
  */
 static void *BCMFASTPATH dma64_getnexttxp(dma_info_t *di, txd_range_t range)
 {
-	uint16 start, end, i;
-	uint16 active_desc;
+	u16 start, end, i;
+	u16 active_desc;
 	void *txp;
 
 	DMA_TRACE(("%s: dma_getnexttxp %s\n", di->name,
@@ -2461,14 +2461,14 @@ static void *BCMFASTPATH dma64_getnexttx
 		dma64regs_t *dregs = di->d64txregs;
 
 		end =
-		    (uint16) (B2I
+		    (u16) (B2I
 			      (((R_REG(di->osh, &dregs->status0) &
 				 D64_XS0_CD_MASK) -
 				di->xmtptrbase) & D64_XS0_CD_MASK, dma64dd_t));
 
 		if (range == HNDDMA_RANGE_TRANSFERED) {
 			active_desc =
-			    (uint16) (R_REG(di->osh, &dregs->status1) &
+			    (u16) (R_REG(di->osh, &dregs->status1) &
 				      D64_XS1_AD_MASK);
 			active_desc =
 			    (active_desc - di->xmtptrbase) & D64_XS0_CD_MASK;
@@ -2589,17 +2589,17 @@ static bool _dma64_addrext(osl_t *osh, d
  */
 static void dma64_txrotate(dma_info_t *di)
 {
-	uint16 ad;
+	u16 ad;
 	uint nactive;
 	uint rot;
-	uint16 old, new;
+	u16 old, new;
 	uint32 w;
-	uint16 first, last;
+	u16 first, last;
 
 	ASSERT(dma64_txsuspendedidle(di));
 
 	nactive = _dma_txactive(di);
-	ad = (uint16) (B2I
+	ad = (u16) (B2I
 		       ((((R_REG(di->osh, &di->d64txregs->status1) &
 			   D64_XS1_AD_MASK)
 			  - di->xmtptrbase) & D64_XS1_AD_MASK), dma64dd_t));
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -185,7 +185,7 @@ BCMATTACHFN(si_pmu_set_ldo_voltage) (si_
 /* d11 slow to fast clock transition time in slow clock cycles */
 #define D11SCC_SLOW2FAST_TRANSITION	2
 
-uint16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t *sih, osl_t *osh)
+u16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t *sih, osl_t *osh)
 {
 	uint delay = PMU_MAX_TRANSITION_DLY;
 	chipcregs_t *cc;
@@ -259,7 +259,7 @@ uint16 BCMINITFN(si_pmu_fast_pwrup_delay
 	/* Return to original core */
 	si_setcoreidx(sih, origidx);
 
-	return (uint16) delay;
+	return (u16) delay;
 }
 
 uint32 BCMATTACHFN(si_pmu_force_ilp) (si_t *sih, osl_t *osh, bool force)
@@ -292,7 +292,7 @@ uint32 BCMATTACHFN(si_pmu_force_ilp) (si
 /* Setup resource up/down timers */
 typedef struct {
 	u8 resnum;
-	uint16 updown;
+	u16 updown;
 } pmu_res_updown_t;
 
 /* Change resource dependancies masks */
@@ -872,7 +872,7 @@ void BCMATTACHFN(si_pmu_res_init) (si_t
 
 /* setup pll and query clock speed */
 typedef struct {
-	uint16 freq;
+	u16 freq;
 	u8 xf;
 	u8 wbint;
 	uint32 wbfrac;
@@ -902,7 +902,7 @@ static const pmu0_xtaltab0_t BCMINITDATA
 
 /* setup pll and query clock speed */
 typedef struct {
-	uint16 fref;
+	u16 fref;
 	u8 xf;
 	u8 p1div;
 	u8 p2div;
--- a/drivers/staging/brcm80211/util/linux_osl.c
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -538,10 +538,10 @@ void *osl_dma_alloc_consistent(osl_t *os
 	return pci_alloc_consistent(osh->pdev, size, (dma_addr_t *) pap);
 }
 #else /* !BRCM_FULLMAC */
-void *osl_dma_alloc_consistent(osl_t *osh, uint size, uint16 align_bits,
+void *osl_dma_alloc_consistent(osl_t *osh, uint size, u16 align_bits,
 			       uint *alloced, unsigned long *pap)
 {
-	uint16 align = (1 << align_bits);
+	u16 align = (1 << align_bits);
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
 	if (!ISALIGNED(DMA_CONSISTENT_ALIGN, align))
@@ -664,12 +664,12 @@ u8 osl_readb(osl_t *osh, volatile u8 *r)
 	return (u8) ((rreg) (ctx, (void *)r, sizeof(u8)));
 }
 
-uint16 osl_readw(osl_t *osh, volatile uint16 *r)
+u16 osl_readw(osl_t *osh, volatile u16 *r)
 {
 	osl_rreg_fn_t rreg = ((osl_pubinfo_t *) osh)->rreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
 
-	return (uint16) ((rreg) (ctx, (void *)r, sizeof(uint16)));
+	return (u16) ((rreg) (ctx, (void *)r, sizeof(u16)));
 }
 
 uint32 osl_readl(osl_t *osh, volatile uint32 *r)
@@ -688,12 +688,12 @@ void osl_writeb(osl_t *osh, volatile u8
 	((wreg) (ctx, (void *)r, v, sizeof(u8)));
 }
 
-void osl_writew(osl_t *osh, volatile uint16 *r, uint16 v)
+void osl_writew(osl_t *osh, volatile u16 *r, u16 v)
 {
 	osl_wreg_fn_t wreg = ((osl_pubinfo_t *) osh)->wreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
 
-	((wreg) (ctx, (void *)r, v, sizeof(uint16)));
+	((wreg) (ctx, (void *)r, v, sizeof(u16)));
 }
 
 void osl_writel(osl_t *osh, volatile uint32 *r, uint32 v)
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -484,7 +484,7 @@ static void pcie_war_aspm_clkreq(pcicore
 {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	si_t *sih = pi->sih;
-	uint16 val16, *reg16;
+	u16 val16, *reg16;
 	uint32 w;
 
 	if (!PCIE_ASPM(sih))
@@ -548,7 +548,7 @@ static void pcie_war_serdes(pcicore_info
 static void BCMINITFN(pcie_misc_config_fixup) (pcicore_info_t *pi)
 {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
-	uint16 val16, *reg16;
+	u16 val16, *reg16;
 
 	reg16 = &pcieregs->sprom[SRSH_PCIE_MISC_CONFIG];
 	val16 = R_REG(pi->osh, reg16);
@@ -564,7 +564,7 @@ static void BCMINITFN(pcie_misc_config_f
 static void pcie_war_noplldown(pcicore_info_t *pi)
 {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
-	uint16 *reg16;
+	u16 *reg16;
 
 	ASSERT(pi->sih->buscorerev == 7);
 
--- a/drivers/staging/brcm80211/util/qmath.c
+++ b/drivers/staging/brcm80211/util/qmath.c
@@ -81,9 +81,9 @@ int32 qm_muls321616(int16 op1, int16 op2
 Description: This function make 16 bit unsigned multiplication. To fit the output into
 16 bits the 32 bit multiplication result is right shifted by 16 bits.
 */
-uint16 qm_mulu16(uint16 op1, uint16 op2)
+u16 qm_mulu16(u16 op1, u16 op2)
 {
-	return (uint16) (((uint32) op1 * (uint32) op2) >> 16);
+	return (u16) (((uint32) op1 * (uint32) op2) >> 16);
 }
 
 /*
@@ -258,7 +258,7 @@ Example: qm_norm16(0x0080) = 7.
 */
 int16 qm_norm16(int16 op)
 {
-	uint16 u16extraSignBits;
+	u16 u16extraSignBits;
 	if (op == 0) {
 		return 15;
 	} else {
@@ -277,7 +277,7 @@ Example: qm_norm32(0x00000080) = 23
 */
 int16 qm_norm32(int32 op)
 {
-	uint16 u16extraSignBits;
+	u16 u16extraSignBits;
 	if (op == 0) {
 		return 31;
 	} else {
@@ -407,7 +407,7 @@ into 32 bit output.
 int32 qm_mul323216(int32 op1, int16 op2)
 {
 	int16 hi;
-	uint16 lo;
+	u16 lo;
 	int32 result;
 	hi = op1 >> 16;
 	lo = (int16) (op1 & 0xffff);
@@ -420,7 +420,7 @@ int32 qm_mul323216(int32 op1, int16 op2)
 Description: This function multiply signed 16 bit number with unsigned 16 bit number and return
 the result in 32 bits.
 */
-int32 qm_mulsu321616(int16 op1, uint16 op2)
+int32 qm_mulsu321616(int16 op1, u16 op2)
 {
 	return (int32) (op1) * op2;
 }
@@ -434,7 +434,7 @@ When the input numbers are 0x80000000, 0
 int32 qm_muls323216(int32 op1, int16 op2)
 {
 	int16 hi;
-	uint16 lo;
+	u16 lo;
 	int32 result;
 	hi = op1 >> 16;
 	lo = (int16) (op1 & 0xffff);
@@ -451,12 +451,12 @@ multiplication result is returned as out
 int32 qm_mul32(int32 a, int32 b)
 {
 	int16 hi1, hi2;
-	uint16 lo1, lo2;
+	u16 lo1, lo2;
 	int32 result;
 	hi1 = a >> 16;
 	hi2 = b >> 16;
-	lo1 = (uint16) (a & 0xffff);
-	lo2 = (uint16) (b & 0xffff);
+	lo1 = (u16) (a & 0xffff);
+	lo2 = (u16) (b & 0xffff);
 	result = qm_mul321616(hi1, hi2);
 	result = result + (qm_mulsu321616(hi1, lo2) >> 16);
 	result = result + (qm_mulsu321616(hi2, lo1) >> 16);
@@ -474,12 +474,12 @@ When the input numbers are 0x80000000, 0
 int32 qm_muls32(int32 a, int32 b)
 {
 	int16 hi1, hi2;
-	uint16 lo1, lo2;
+	u16 lo1, lo2;
 	int32 result;
 	hi1 = a >> 16;
 	hi2 = b >> 16;
-	lo1 = (uint16) (a & 0xffff);
-	lo2 = (uint16) (b & 0xffff);
+	lo1 = (u16) (a & 0xffff);
+	lo2 = (u16) (b & 0xffff);
 	result = qm_muls321616(hi1, hi2);
 	result = qm_add32(result, (qm_mulsu321616(hi1, lo2) >> 15));
 	result = qm_add32(result, (qm_mulsu321616(hi2, lo1) >> 15));
@@ -548,7 +548,7 @@ For accurate results input should be in
 void qm_log10(int32 N, int16 qN, int16 *log10N, int16 *qLog10N)
 {
 	int16 s16norm, s16tableIndex, s16errorApproximation;
-	uint16 u16offset;
+	u16 u16offset;
 	int32 s32log;
 
 	/* Logerithm of negative values is undefined.
@@ -580,13 +580,13 @@ void qm_log10(int32 N, int16 qN, int16 *
 
 	/* take the offset as the 16 MSBS after table index.
 	 */
-	u16offset = (uint16) (N >> (32 - (2 + LOG2_LOG_TABLE_SIZE + 16)));
+	u16offset = (u16) (N >> (32 - (2 + LOG2_LOG_TABLE_SIZE + 16)));
 
 	/* look the log value in the table. */
 	s32log = log_table[s16tableIndex];	/* q.15 format */
 
 	/* interpolate using the offset. */
-	s16errorApproximation = (int16) qm_mulu16(u16offset, (uint16) (log_table[s16tableIndex + 1] - log_table[s16tableIndex]));	/* q.15 */
+	s16errorApproximation = (int16) qm_mulu16(u16offset, (u16) (log_table[s16tableIndex + 1] - log_table[s16tableIndex]));	/* q.15 */
 
 	s32log = qm_add16((int16) s32log, s16errorApproximation);	/* q.15 format */
 
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -320,13 +320,13 @@ static __used void BCMATTACHFN(si_nvram_
 		/* do a pci config read to get subsystem id and subvendor id */
 		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_SVID, sizeof(uint32));
 		/* Let nvram variables override subsystem Vend/ID */
-		sii->pub.boardvendor = (uint16)si_getdevpathintvar(&sii->pub,
+		sii->pub.boardvendor = (u16)si_getdevpathintvar(&sii->pub,
 			"boardvendor");
 		if (sii->pub.boardvendor == 0)
 			sii->pub.boardvendor = w & 0xffff;
 		else
 			SI_ERROR(("Overriding boardvendor: 0x%x instead of 0x%x\n", sii->pub.boardvendor, w & 0xffff));
-		sii->pub.boardtype = (uint16)si_getdevpathintvar(&sii->pub,
+		sii->pub.boardtype = (u16)si_getdevpathintvar(&sii->pub,
 			"boardtype");
 		if (sii->pub.boardtype == 0)
 			sii->pub.boardtype = (w >> 16) & 0xffff;
@@ -1389,23 +1389,23 @@ void si_watchdog_ms(si_t *sih, uint32 ms
 	si_watchdog(sih, wd_msticks * ms);
 }
 
-uint16 BCMATTACHFN(si_d11_devid) (si_t *sih)
+u16 BCMATTACHFN(si_d11_devid) (si_t *sih)
 {
 	si_info_t *sii = SI_INFO(sih);
-	uint16 device;
+	u16 device;
 
 	/* normal case: nvram variable with devpath->devid->wl0id */
-	device = (uint16) si_getdevpathintvar(sih, "devid");
+	device = (u16) si_getdevpathintvar(sih, "devid");
 	if (device != 0)
 		goto bail;
 
 	/* Get devid from OTP/SPROM depending on where the SROM is read */
-	device = (uint16) getintvar(sii->vars, "devid");
+	device = (u16) getintvar(sii->vars, "devid");
 	if (device != 0)
 		goto bail;
 
 	/* no longer support wl0id, but keep the code here for backward compatibility. */
-	device = (uint16) getintvar(sii->vars, "wl0id");
+	device = (u16) getintvar(sii->vars, "wl0id");
 	if (device != 0)
 		goto bail;
 
@@ -1543,13 +1543,13 @@ void BCMINITFN(si_clkctl_init) (si_t *si
 }
 
 /* return the value suitable for writing to the dot11 core FAST_PWRUP_DELAY register */
-uint16 BCMINITFN(si_clkctl_fast_pwrup_delay) (si_t *sih)
+u16 BCMINITFN(si_clkctl_fast_pwrup_delay) (si_t *sih)
 {
 	si_info_t *sii;
 	uint origidx = 0;
 	chipcregs_t *cc;
 	uint slowminfreq;
-	uint16 fpdelay;
+	u16 fpdelay;
 	uint intr_val = 0;
 	bool fast;
 
@@ -2183,7 +2183,7 @@ int si_pci_fixcfg(si_t *sih)
 	sbpciregs_t *pciregs = NULL;
 	sbpcieregs_t *pcieregs = NULL;
 	void *regs = NULL;
-	uint16 val16, *reg16 = NULL;
+	u16 val16, *reg16 = NULL;
 
 	si_info_t *sii = SI_INFO(sih);
 
@@ -2208,9 +2208,9 @@ int si_pci_fixcfg(si_t *sih)
 	}
 	pciidx = si_coreidx(&sii->pub);
 	val16 = R_REG(sii->osh, reg16);
-	if (((val16 & SRSH_PI_MASK) >> SRSH_PI_SHIFT) != (uint16) pciidx) {
+	if (((val16 & SRSH_PI_MASK) >> SRSH_PI_SHIFT) != (u16) pciidx) {
 		val16 =
-		    (uint16) (pciidx << SRSH_PI_SHIFT) | (val16 &
+		    (u16) (pciidx << SRSH_PI_SHIFT) | (val16 &
 							  ~SRSH_PI_MASK);
 		W_REG(sii->osh, reg16, val16);
 	}

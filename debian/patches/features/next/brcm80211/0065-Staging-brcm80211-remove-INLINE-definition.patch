commit 2d956e2221929103031f217fd666a10edd05f3a0
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 09:40:02 2010 -0700

    Staging: brcm80211: remove INLINE definition
    
    Use the "real" inline marking for functions.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/include/bcmendian.h
+++ b/drivers/staging/brcm80211/include/bcmendian.h
@@ -201,17 +201,17 @@
 #else				/* !__GNUC__ */
 
 /* Inline versions avoid referencing the argument multiple times */
-static INLINE uint16 bcmswap16(uint16 val)
+static inline uint16 bcmswap16(uint16 val)
 {
 	return BCMSWAP16(val);
 }
 
-static INLINE uint32 bcmswap32(uint32 val)
+static inline uint32 bcmswap32(uint32 val)
 {
 	return BCMSWAP32(val);
 }
 
-static INLINE uint32 bcmswap32by16(uint32 val)
+static inline uint32 bcmswap32by16(uint32 val)
 {
 	return BCMSWAP32BY16(val);
 }
@@ -219,7 +219,7 @@ static INLINE uint32 bcmswap32by16(uint3
 /* Reverse pairs of bytes in a buffer (not for high-performance use) */
 /* buf	- start of buffer of shorts to swap */
 /* len  - byte length of buffer */
-static INLINE void bcmswap16_buf(uint16 *buf, uint len)
+static inline void bcmswap16_buf(uint16 *buf, uint len)
 {
 	len = len / 2;
 
@@ -232,7 +232,7 @@ static INLINE void bcmswap16_buf(uint16
 /*
  * Store 16-bit value to unaligned little-endian byte array.
  */
-static INLINE void htol16_ua_store(uint16 val, uint8 *bytes)
+static inline void htol16_ua_store(uint16 val, uint8 *bytes)
 {
 	bytes[0] = val & 0xff;
 	bytes[1] = val >> 8;
@@ -241,7 +241,7 @@ static INLINE void htol16_ua_store(uint1
 /*
  * Store 32-bit value to unaligned little-endian byte array.
  */
-static INLINE void htol32_ua_store(uint32 val, uint8 *bytes)
+static inline void htol32_ua_store(uint32 val, uint8 *bytes)
 {
 	bytes[0] = val & 0xff;
 	bytes[1] = (val >> 8) & 0xff;
@@ -252,7 +252,7 @@ static INLINE void htol32_ua_store(uint3
 /*
  * Store 16-bit value to unaligned network-(big-)endian byte array.
  */
-static INLINE void hton16_ua_store(uint16 val, uint8 *bytes)
+static inline void hton16_ua_store(uint16 val, uint8 *bytes)
 {
 	bytes[0] = val >> 8;
 	bytes[1] = val & 0xff;
@@ -261,7 +261,7 @@ static INLINE void hton16_ua_store(uint1
 /*
  * Store 32-bit value to unaligned network-(big-)endian byte array.
  */
-static INLINE void hton32_ua_store(uint32 val, uint8 *bytes)
+static inline void hton32_ua_store(uint32 val, uint8 *bytes)
 {
 	bytes[0] = val >> 24;
 	bytes[1] = (val >> 16) & 0xff;
@@ -272,7 +272,7 @@ static INLINE void hton32_ua_store(uint3
 /*
  * Load 16-bit value from unaligned little-endian byte array.
  */
-static INLINE uint16 ltoh16_ua(const void *bytes)
+static inline uint16 ltoh16_ua(const void *bytes)
 {
 	return _LTOH16_UA((const uint8 *)bytes);
 }
@@ -280,7 +280,7 @@ static INLINE uint16 ltoh16_ua(const voi
 /*
  * Load 32-bit value from unaligned little-endian byte array.
  */
-static INLINE uint32 ltoh32_ua(const void *bytes)
+static inline uint32 ltoh32_ua(const void *bytes)
 {
 	return _LTOH32_UA((const uint8 *)bytes);
 }
@@ -288,7 +288,7 @@ static INLINE uint32 ltoh32_ua(const voi
 /*
  * Load 16-bit value from unaligned big-(network-)endian byte array.
  */
-static INLINE uint16 ntoh16_ua(const void *bytes)
+static inline uint16 ntoh16_ua(const void *bytes)
 {
 	return _NTOH16_UA((const uint8 *)bytes);
 }
@@ -296,7 +296,7 @@ static INLINE uint16 ntoh16_ua(const voi
 /*
  * Load 32-bit value from unaligned big-(network-)endian byte array.
  */
-static INLINE uint32 ntoh32_ua(const void *bytes)
+static inline uint32 ntoh32_ua(const void *bytes)
 {
 	return _NTOH32_UA((const uint8 *)bytes);
 }
--- a/drivers/staging/brcm80211/include/bcmnvram.h
+++ b/drivers/staging/brcm80211/include/bcmnvram.h
@@ -91,7 +91,7 @@ extern int BCMINITFN(nvram_resetgpio_ini
  * @return	TRUE if variable is defined and its value is string equal
  *		to match or FALSE otherwise
  */
-static INLINE int nvram_match(char *name, char *match)
+static inline int nvram_match(char *name, char *match)
 {
 	const char *value = nvram_get(name);
 	return value && !strcmp(value, match);
@@ -104,7 +104,7 @@ static INLINE int nvram_match(char *name
  * @return	TRUE if variable is defined and its value is not string
  *		equal to invmatch or FALSE otherwise
  */
-static INLINE int nvram_invmatch(char *name, char *invmatch)
+static inline int nvram_invmatch(char *name, char *invmatch)
 {
 	const char *value = nvram_get(name);
 	return value && strcmp(value, invmatch);
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -518,7 +518,7 @@ extern "C" {
 
 /* crypto utility function */
 /* 128-bit xor: *dst = *src1 xor *src2. dst1, src1 and src2 may have any alignment */
-	static INLINE void
+	static inline void
 	 xor_128bit_block(const uint8 *src1, const uint8 *src2, uint8 *dst) {
 		if (
 #ifdef __i386__
--- a/drivers/staging/brcm80211/include/bitfuncs.h
+++ b/drivers/staging/brcm80211/include/bitfuncs.h
@@ -20,7 +20,7 @@
 #include <typedefs.h>
 
 /* local prototypes */
-static INLINE uint32 find_msbit(uint32 x);
+static inline uint32 find_msbit(uint32 x);
 
 /*
  * find_msbit: returns index of most significant set bit in x, with index
@@ -35,7 +35,7 @@ static INLINE uint32 find_msbit(uint32 x
  * model 2, stepping 12, "Pentium 75 - 200"), so we use the generic
  * implementation instead.
  */
-static INLINE uint32 find_msbit(uint32 x)
+static inline uint32 find_msbit(uint32 x)
 {
 	uint msbit;
  __asm__("bsrl %1,%0" : "=r"(msbit)
@@ -55,7 +55,7 @@ static INLINE uint32 find_msbit(uint32 x
 #define DB_POW_MASK2	0x0000000c
 #define DB_POW_MASK1	0x00000002
 
-static INLINE uint32 find_msbit(uint32 x)
+static inline uint32 find_msbit(uint32 x)
 {
 	uint32 temp_x = x;
 	uint msbit = 0;
--- a/drivers/staging/brcm80211/include/linux_osl.h
+++ b/drivers/staging/brcm80211/include/linux_osl.h
@@ -361,7 +361,7 @@ extern void *osl_pktdup(osl_t *osh, void
 extern void *osl_pktget_static(osl_t *osh, uint len);
 extern void osl_pktfree_static(osl_t *osh, void *skb, bool send);
 
-static INLINE void *
+static inline void *
 osl_pkt_frmnative(osl_pubinfo_t *osh, struct sk_buff *skb)
 {
 	struct sk_buff *nskb;
@@ -377,7 +377,7 @@ osl_pkt_frmnative(osl_pubinfo_t *osh, st
 #define PKTFRMNATIVE(osh, skb)	\
 	osl_pkt_frmnative(((osl_pubinfo_t *)osh), (struct sk_buff*)(skb))
 
-static INLINE struct sk_buff *
+static inline struct sk_buff *
 osl_pkt_tonative(osl_pubinfo_t *osh, void *pkt)
 {
 	struct sk_buff *nskb;
--- a/drivers/staging/brcm80211/include/siutils.h
+++ b/drivers/staging/brcm80211/include/siutils.h
@@ -233,7 +233,7 @@ extern uint16 si_d11_devid(si_t *sih);
 #define si_eci_init(sih) (0)
 #define si_eci_notify_bt(sih, type, val)  (0)
 #define si_seci(sih) 0
-static INLINE void *si_seci_init(si_t *sih, uint8 use_seci)
+static inline void *si_seci_init(si_t *sih, uint8 use_seci)
 {
 	return NULL;
 }
--- a/drivers/staging/brcm80211/include/typedefs.h
+++ b/drivers/staging/brcm80211/include/typedefs.h
@@ -159,31 +159,11 @@ typedef float64 float_t;
 
 #define	AUTO	(-1)		/* Auto = -1 */
 
-/* define PTRSZ, INLINE */
-
+/* define PTRSZ */
 #ifndef PTRSZ
 #define	PTRSZ	sizeof(char *)
 #endif
 
-/* Detect compiler type. */
-#if defined(__GNUC__)
-#define BWL_COMPILER_GNU
-#elif defined(__CC_ARM) && __CC_ARM
-#define BWL_COMPILER_ARMCC
-#else
-#error "Unknown compiler!"
-#endif
-
-#ifndef INLINE
-#if defined(BWL_COMPILER_GNU)
-#define INLINE __inline__
-#elif defined(BWL_COMPILER_ARMCC)
-#define INLINE	__inline
-#else
-#define INLINE
-#endif
-#endif				/* INLINE */
-
 #undef TYPEDEF_BOOL
 #undef TYPEDEF_UCHAR
 #undef TYPEDEF_USHORT
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -158,7 +158,7 @@ static void wlc_ampdu_dotxstatus_complet
 					  uint32 frmtxstatus,
 					  uint32 frmtxstatus2);
 
-static INLINE uint16 pkt_txh_seqnum(wlc_info_t *wlc, void *p)
+static inline uint16 pkt_txh_seqnum(wlc_info_t *wlc, void *p)
 {
 	d11txh_t *txh;
 	struct dot11_header *h;
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -3174,7 +3174,7 @@ void wlc_bmac_tx_fifo_resume(wlc_hw_info
  *   0 if the interrupt is not for us, or we are in some special cases;
  *   device interrupt status bits otherwise.
  */
-static INLINE uint32 wlc_intstatus(wlc_info_t *wlc, bool in_isr)
+static inline uint32 wlc_intstatus(wlc_info_t *wlc, bool in_isr)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -5441,7 +5441,7 @@ void BCMFASTPATH wlc_send_q(wlc_info_t *
  * Generate frame ID for a BCMC packet.  The frag field is not used
  * for MC frames so is used as part of the sequence number.
  */
-static INLINE uint16
+static inline uint16
 bcmc_fid_generate(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, d11txh_t *txh)
 {
 	uint16 frameid;
--- a/drivers/staging/brcm80211/sys/wlc_pub.h
+++ b/drivers/staging/brcm80211/sys/wlc_pub.h
@@ -569,19 +569,19 @@ extern uint16 wlc_rate_shm_offset(struct
 extern uint32 wlc_get_rspec_history(struct wlc_bsscfg *cfg);
 extern uint32 wlc_get_current_highest_rate(struct wlc_bsscfg *cfg);
 
-static INLINE int wlc_iovar_getuint(struct wlc_info *wlc, const char *name,
+static inline int wlc_iovar_getuint(struct wlc_info *wlc, const char *name,
 				    uint *arg)
 {
 	return wlc_iovar_getint(wlc, name, (int *)arg);
 }
 
-static INLINE int wlc_iovar_getuint8(struct wlc_info *wlc, const char *name,
+static inline int wlc_iovar_getuint8(struct wlc_info *wlc, const char *name,
 				     uint8 *arg)
 {
 	return wlc_iovar_getint8(wlc, name, (int8 *) arg);
 }
 
-static INLINE int wlc_iovar_setuint(struct wlc_info *wlc, const char *name,
+static inline int wlc_iovar_setuint(struct wlc_info *wlc, const char *name,
 				    uint arg)
 {
 	return wlc_iovar_setint(wlc, name, (int)arg);
--- a/drivers/staging/brcm80211/sys/wlc_rpc.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpc.h
@@ -420,7 +420,7 @@ typedef struct wlc_rpc_ctx {
 	wlc_hw_info_t *wlc_hw;
 } wlc_rpc_ctx_t;
 
-static INLINE rpc_buf_t *wlc_rpc_buf_alloc(rpc_info_t *rpc, bcm_xdr_buf_t *b,
+static inline rpc_buf_t *wlc_rpc_buf_alloc(rpc_info_t *rpc, bcm_xdr_buf_t *b,
 					   uint len, wlc_rpc_id_t rpc_id)
 {
 	rpc_buf_t *rpc_buf;
@@ -496,7 +496,7 @@ typedef struct wlc_rpc_txstatus {
 	uint32 ackphyrxsh_phyerr;
 } wlc_rpc_txstatus_t;
 
-static INLINE
+static inline
     void txstatus2rpc_txstatus(tx_status_t *txstatus,
 			       wlc_rpc_txstatus_t *rpc_txstatus)
 {
@@ -509,7 +509,7 @@ static INLINE
 	    (txstatus->ackphyrxsh << 16) | txstatus->phyerr;
 }
 
-static INLINE
+static inline
     void rpc_txstatus2txstatus(wlc_rpc_txstatus_t *rpc_txstatus,
 			       tx_status_t *txstatus)
 {
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -273,7 +273,7 @@ static bool dma64_rxstopped(dma_info_t *
 static bool dma64_rxenabled(dma_info_t *di);
 static bool _dma64_addrext(osl_t *osh, dma64regs_t *dma64regs);
 
-STATIC INLINE uint32 parity32(uint32 data);
+STATIC inline uint32 parity32(uint32 data);
 
 const di_fcn_t dma64proc = {
 	(di_detach_t) _dma_detach,
@@ -586,7 +586,7 @@ hnddma_t *dma_attach(osl_t *osh, char *n
 }
 
 /* init the tx or rx descriptor */
-static INLINE void
+static inline void
 dma32_dd_upd(dma_info_t *di, dma32dd_t *ddring, dmaaddr_t pa, uint outidx,
 	     uint32 *flags, uint32 bufcount)
 {
@@ -612,7 +612,7 @@ dma32_dd_upd(dma_info_t *di, dma32dd_t *
 }
 
 /* Check for odd number of 1's */
-STATIC INLINE uint32 parity32(uint32 data)
+STATIC inline uint32 parity32(uint32 data)
 {
 	data ^= data >> 16;
 	data ^= data >> 8;
@@ -625,7 +625,7 @@ STATIC INLINE uint32 parity32(uint32 dat
 
 #define DMA64_DD_PARITY(dd)  parity32((dd)->addrlow ^ (dd)->addrhigh ^ (dd)->ctrl1 ^ (dd)->ctrl2)
 
-static INLINE void
+static inline void
 dma64_dd_upd(dma_info_t *di, dma64dd_t *ddring, dmaaddr_t pa, uint outidx,
 	     uint32 *flags, uint32 bufcount)
 {

commit 3e26416e2f7fc2781c084c4ea51227aef30336de
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:11:13 2010 -0700

    Staging: brcm80211: s/int32/s32/
    
    Use the kernel types, don't invent your own.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
@@ -186,7 +186,7 @@ u8 bcmsdh_cfg_read(void *sdh, uint fnc_n
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 	SDIOH_API_RC status;
 #ifdef SDIOH_API_ACCESS_RETRY_LIMIT
-	int32 retry = 0;
+	s32 retry = 0;
 #endif
 	u8 data = 0;
 
@@ -222,7 +222,7 @@ bcmsdh_cfg_write(void *sdh, uint fnc_num
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 	SDIOH_API_RC status;
 #ifdef SDIOH_API_ACCESS_RETRY_LIMIT
-	int32 retry = 0;
+	s32 retry = 0;
 #endif
 
 	if (!bcmsdh)
--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
@@ -404,7 +404,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 	const bcm_iovar_t *vi = NULL;
 	int bcmerror = 0;
 	int val_size;
-	int32 int_val = 0;
+	s32 int_val = 0;
 	bool bool_val;
 	u32 actionid;
 
@@ -449,7 +449,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
 	switch (actionid) {
 	case IOV_GVAL(IOV_MSGLEVEL):
-		int_val = (int32) sd_msglevel;
+		int_val = (s32) sd_msglevel;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -458,7 +458,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 		break;
 
 	case IOV_GVAL(IOV_BLOCKMODE):
-		int_val = (int32) si->sd_blockmode;
+		int_val = (s32) si->sd_blockmode;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -472,7 +472,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 			bcmerror = BCME_BADARG;
 			break;
 		}
-		int_val = (int32) si->client_block_size[int_val];
+		int_val = (s32) si->client_block_size[int_val];
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -519,7 +519,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 		break;
 
 	case IOV_GVAL(IOV_DMA):
-		int_val = (int32) si->sd_use_dma;
+		int_val = (s32) si->sd_use_dma;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -528,7 +528,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 		break;
 
 	case IOV_GVAL(IOV_USEINTS):
-		int_val = (int32) si->use_client_ints;
+		int_val = (s32) si->use_client_ints;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -587,12 +587,12 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 		break;
 
 	case IOV_GVAL(IOV_NUMINTS):
-		int_val = (int32) si->intrcount;
+		int_val = (s32) si->intrcount;
 		bcopy(&int_val, arg, val_size);
 		break;
 
 	case IOV_GVAL(IOV_NUMLOCALINTS):
-		int_val = (int32) 0;
+		int_val = (s32) 0;
 		bcopy(&int_val, arg, val_size);
 		break;
 
--- a/drivers/staging/brcm80211/brcmfmac/bcmutils.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmutils.c
@@ -995,7 +995,7 @@ int bcm_iovar_lencheck(const bcm_iovar_t
 	case IOVT_UINT8:
 	case IOVT_UINT16:
 	case IOVT_UINT32:
-		/* all integers are int32 sized args at the ioctl interface */
+		/* all integers are s32 sized args at the ioctl interface */
 		if (len < (int)sizeof(int))
 			bcmerror = BCME_BUFTOOSHORT;
 		break;
--- a/drivers/staging/brcm80211/brcmfmac/dhd_common.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_common.c
@@ -205,7 +205,7 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bc
 	    int val_size)
 {
 	int bcmerror = 0;
-	int32 int_val = 0;
+	s32 int_val = 0;
 
 	DHD_TRACE(("%s: Enter\n", __func__));
 
@@ -223,7 +223,7 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bc
 		break;
 
 	case IOV_GVAL(IOV_MSGLEVEL):
-		int_val = (int32) dhd_msg_level;
+		int_val = (s32) dhd_msg_level;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -238,12 +238,12 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bc
 		break;
 
 	case IOV_GVAL(IOV_BCMERROR):
-		int_val = (int32) dhd_pub->bcmerror;
+		int_val = (s32) dhd_pub->bcmerror;
 		bcopy(&int_val, arg, val_size);
 		break;
 
 	case IOV_GVAL(IOV_WDTICK):
-		int_val = (int32) dhd_watchdog_ms;
+		int_val = (s32) dhd_watchdog_ms;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -261,7 +261,7 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bc
 
 #ifdef DHD_DEBUG
 	case IOV_GVAL(IOV_DCONSOLE_POLL):
-		int_val = (int32) dhd_console_ms;
+		int_val = (s32) dhd_console_ms;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -289,7 +289,7 @@ dhd_doiovar(dhd_pub_t *dhd_pub, const bc
 		break;
 
 	case IOV_GVAL(IOV_IOCTLTIMEOUT):{
-			int_val = (int32) dhd_os_get_ioctl_resp_timeout();
+			int_val = (s32) dhd_os_get_ioctl_resp_timeout();
 			bcopy(&int_val, arg, sizeof(int_val));
 			break;
 		}
--- a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
@@ -1797,7 +1797,7 @@ static int dhd_open(struct net_device *n
 	u32 toe_ol;
 #endif
 	int ifidx = dhd_net2idx(dhd, net);
-	int32 ret = 0;
+	s32 ret = 0;
 
 	DHD_TRACE(("%s: ifidx %d\n", __func__, ifidx));
 
--- a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
@@ -234,12 +234,12 @@ typedef struct dhd_bus {
 
 	uint clkstate;		/* State of sd and backplane clock(s) */
 	bool activity;		/* Activity flag for clock down */
-	int32 idletime;		/* Control for activity timeout */
-	int32 idlecount;	/* Activity timeout counter */
-	int32 idleclock;	/* How to set bus driver when idle */
-	int32 sd_divisor;	/* Speed control to bus driver */
-	int32 sd_mode;		/* Mode control to bus driver */
-	int32 sd_rxchain;	/* If bcmsdh api accepts PKT chains */
+	s32 idletime;		/* Control for activity timeout */
+	s32 idlecount;	/* Activity timeout counter */
+	s32 idleclock;	/* How to set bus driver when idle */
+	s32 sd_divisor;	/* Speed control to bus driver */
+	s32 sd_mode;		/* Mode control to bus driver */
+	s32 sd_rxchain;	/* If bcmsdh api accepts PKT chains */
 	bool use_rxchain;	/* If dhd should use PKT chains */
 	bool sleeping;		/* Is SDIO bus sleeping? */
 	bool rxflow_mode;	/* Rx flow control mode */
@@ -461,12 +461,12 @@ static int dhdsdio_download_code_array(s
 
 static void dhd_dongle_setmemsize(struct dhd_bus *bus, int mem_size)
 {
-	int32 min_size = DONGLE_MIN_MEMSIZE;
+	s32 min_size = DONGLE_MIN_MEMSIZE;
 	/* Restrict the memsize to user specified limit */
 	DHD_ERROR(("user: Restrict the dongle ram size to %d, min %d\n",
 		dhd_dongle_memsize, min_size));
 	if ((dhd_dongle_memsize > min_size) &&
-	    (dhd_dongle_memsize < (int32) bus->orig_ramsize))
+	    (dhd_dongle_memsize < (s32) bus->orig_ramsize))
 		bus->ramsize = dhd_dongle_memsize;
 }
 
@@ -634,7 +634,7 @@ static int dhdsdio_htclk(dhd_bus_t *bus,
 static int dhdsdio_sdclk(dhd_bus_t *bus, bool on)
 {
 	int err;
-	int32 iovalue;
+	s32 iovalue;
 
 	DHD_TRACE(("%s: Enter\n", __func__));
 
@@ -2100,7 +2100,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		int val_size)
 {
 	int bcmerror = 0;
-	int32 int_val = 0;
+	s32 int_val = 0;
 	bool bool_val = 0;
 
 	DHD_TRACE(("%s: Enter, action %d name %s params %p plen %d arg %p "
@@ -2131,7 +2131,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		if (IOV_ISSET(actionid)) {
 			bcmerror = dhdsdio_bussleep(bus, bool_val);
 		} else {
-			int_val = (int32) bus->sleeping;
+			int_val = (s32) bus->sleeping;
 			bcopy(&int_val, arg, val_size);
 		}
 		goto exit;
@@ -2145,7 +2145,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 
 	switch (actionid) {
 	case IOV_GVAL(IOV_INTR):
-		int_val = (int32) bus->intr;
+		int_val = (s32) bus->intr;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2166,7 +2166,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		break;
 
 	case IOV_GVAL(IOV_POLLRATE):
-		int_val = (int32) bus->pollrate;
+		int_val = (s32) bus->pollrate;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2188,7 +2188,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		break;
 
 	case IOV_GVAL(IOV_IDLECLOCK):
-		int_val = (int32) bus->idleclock;
+		int_val = (s32) bus->idleclock;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2197,7 +2197,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		break;
 
 	case IOV_GVAL(IOV_SD1IDLE):
-		int_val = (int32) sd1idle;
+		int_val = (s32) sd1idle;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2260,12 +2260,12 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		}
 
 	case IOV_GVAL(IOV_MEMSIZE):
-		int_val = (int32) bus->ramsize;
+		int_val = (s32) bus->ramsize;
 		bcopy(&int_val, arg, val_size);
 		break;
 
 	case IOV_GVAL(IOV_SDIOD_DRIVE):
-		int_val = (int32) dhd_sdiod_drive_strength;
+		int_val = (s32) dhd_sdiod_drive_strength;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2284,7 +2284,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		break;
 
 	case IOV_GVAL(IOV_READAHEAD):
-		int_val = (int32) dhd_readahead;
+		int_val = (s32) dhd_readahead;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2295,7 +2295,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		break;
 
 	case IOV_GVAL(IOV_SDRXCHAIN):
-		int_val = (int32) bus->use_rxchain;
+		int_val = (s32) bus->use_rxchain;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2306,7 +2306,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 			bus->use_rxchain = bool_val;
 		break;
 	case IOV_GVAL(IOV_ALIGNCTL):
-		int_val = (int32) dhd_alignctl;
+		int_val = (s32) dhd_alignctl;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2338,10 +2338,10 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 
 			addr = (uintptr) bus->regs + sd_ptr->offset;
 			size = sd_ptr->func;
-			int_val = (int32) bcmsdh_reg_read(bus->sdh, addr, size);
+			int_val = (s32) bcmsdh_reg_read(bus->sdh, addr, size);
 			if (bcmsdh_regfail(bus->sdh))
 				bcmerror = BCME_SDIO_ERROR;
-			bcopy(&int_val, arg, sizeof(int32));
+			bcopy(&int_val, arg, sizeof(s32));
 			break;
 		}
 
@@ -2371,10 +2371,10 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 
 			addr = SI_ENUM_BASE + sdreg.offset;
 			size = sdreg.func;
-			int_val = (int32) bcmsdh_reg_read(bus->sdh, addr, size);
+			int_val = (s32) bcmsdh_reg_read(bus->sdh, addr, size);
 			if (bcmsdh_regfail(bus->sdh))
 				bcmerror = BCME_SDIO_ERROR;
-			bcopy(&int_val, arg, sizeof(int32));
+			bcopy(&int_val, arg, sizeof(s32));
 			break;
 		}
 
@@ -2413,7 +2413,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		}
 
 	case IOV_GVAL(IOV_FORCEEVEN):
-		int_val = (int32) forcealign;
+		int_val = (s32) forcealign;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2422,7 +2422,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		break;
 
 	case IOV_GVAL(IOV_TXBOUND):
-		int_val = (int32) dhd_txbound;
+		int_val = (s32) dhd_txbound;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2431,7 +2431,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		break;
 
 	case IOV_GVAL(IOV_RXBOUND):
-		int_val = (int32) dhd_rxbound;
+		int_val = (s32) dhd_rxbound;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2440,7 +2440,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		break;
 
 	case IOV_GVAL(IOV_TXMINMAX):
-		int_val = (int32) dhd_txminmax;
+		int_val = (s32) dhd_txminmax;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2451,7 +2451,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 
 #ifdef SDTEST
 	case IOV_GVAL(IOV_EXTLOOP):
-		int_val = (int32) bus->ext_loop;
+		int_val = (s32) bus->ext_loop;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -2742,7 +2742,7 @@ dhd_bus_iovar_op(dhd_pub_t *dhdp, const
 		/* If it was divisor change, read the new one */
 		if (set && strcmp(name, "sd_divisor") == 0) {
 			if (bcmsdh_iovar_op(bus->sdh, "sd_divisor", NULL, 0,
-					    &bus->sd_divisor, sizeof(int32),
+					    &bus->sd_divisor, sizeof(s32),
 					    FALSE) != BCME_OK) {
 				bus->sd_divisor = -1;
 				DHD_ERROR(("%s: fail on %s get\n", __func__,
@@ -2755,7 +2755,7 @@ dhd_bus_iovar_op(dhd_pub_t *dhdp, const
 		/* If it was a mode change, read the new one */
 		if (set && strcmp(name, "sd_mode") == 0) {
 			if (bcmsdh_iovar_op(bus->sdh, "sd_mode", NULL, 0,
-					    &bus->sd_mode, sizeof(int32),
+					    &bus->sd_mode, sizeof(s32),
 					    FALSE) != BCME_OK) {
 				bus->sd_mode = -1;
 				DHD_ERROR(("%s: fail on %s get\n", __func__,
@@ -2767,10 +2767,10 @@ dhd_bus_iovar_op(dhd_pub_t *dhdp, const
 		}
 		/* Similar check for blocksize change */
 		if (set && strcmp(name, "sd_blocksize") == 0) {
-			int32 fnum = 2;
+			s32 fnum = 2;
 			if (bcmsdh_iovar_op
-			    (bus->sdh, "sd_blocksize", &fnum, sizeof(int32),
-			     &bus->blocksize, sizeof(int32),
+			    (bus->sdh, "sd_blocksize", &fnum, sizeof(s32),
+			     &bus->blocksize, sizeof(s32),
 			     FALSE) != BCME_OK) {
 				bus->blocksize = 0;
 				DHD_ERROR(("%s: fail on %s get\n", __func__,
@@ -5442,7 +5442,7 @@ fail:
 
 static bool dhdsdio_probe_init(dhd_bus_t *bus, osl_t *osh, void *sdh)
 {
-	int32 fnum;
+	s32 fnum;
 
 	DHD_TRACE(("%s: Enter\n", __func__));
 
@@ -5464,12 +5464,12 @@ static bool dhdsdio_probe_init(dhd_bus_t
 
 	/* ...and initialize clock/power states */
 	bus->clkstate = CLK_SDONLY;
-	bus->idletime = (int32) dhd_idletime;
+	bus->idletime = (s32) dhd_idletime;
 	bus->idleclock = DHD_IDLE_ACTIVE;
 
 	/* Query the SD clock speed */
 	if (bcmsdh_iovar_op(sdh, "sd_divisor", NULL, 0,
-			    &bus->sd_divisor, sizeof(int32),
+			    &bus->sd_divisor, sizeof(s32),
 			    FALSE) != BCME_OK) {
 		DHD_ERROR(("%s: fail on %s get\n", __func__, "sd_divisor"));
 		bus->sd_divisor = -1;
@@ -5480,7 +5480,7 @@ static bool dhdsdio_probe_init(dhd_bus_t
 
 	/* Query the SD bus mode */
 	if (bcmsdh_iovar_op(sdh, "sd_mode", NULL, 0,
-			    &bus->sd_mode, sizeof(int32), FALSE) != BCME_OK) {
+			    &bus->sd_mode, sizeof(s32), FALSE) != BCME_OK) {
 		DHD_ERROR(("%s: fail on %s get\n", __func__, "sd_mode"));
 		bus->sd_mode = -1;
 	} else {
@@ -5490,8 +5490,8 @@ static bool dhdsdio_probe_init(dhd_bus_t
 
 	/* Query the F2 block size, set roundup accordingly */
 	fnum = 2;
-	if (bcmsdh_iovar_op(sdh, "sd_blocksize", &fnum, sizeof(int32),
-			    &bus->blocksize, sizeof(int32), FALSE) != BCME_OK) {
+	if (bcmsdh_iovar_op(sdh, "sd_blocksize", &fnum, sizeof(s32),
+			    &bus->blocksize, sizeof(s32), FALSE) != BCME_OK) {
 		bus->blocksize = 0;
 		DHD_ERROR(("%s: fail on %s get\n", __func__, "sd_blocksize"));
 	} else {
@@ -5503,7 +5503,7 @@ static bool dhdsdio_probe_init(dhd_bus_t
 	/* Query if bus module supports packet chaining,
 		 default to use if supported */
 	if (bcmsdh_iovar_op(sdh, "sd_rxchain", NULL, 0,
-			    &bus->sd_rxchain, sizeof(int32),
+			    &bus->sd_rxchain, sizeof(s32),
 			    FALSE) != BCME_OK) {
 		bus->sd_rxchain = FALSE;
 	} else {
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
@@ -58,70 +58,70 @@ u32 wl_dbg_level = WL_DBG_ERR | WL_DBG_I
 /*
 ** cfg80211_ops api/callback list
 */
-static int32 wl_cfg80211_change_iface(struct wiphy *wiphy,
+static s32 wl_cfg80211_change_iface(struct wiphy *wiphy,
 				      struct net_device *ndev,
 				      enum nl80211_iftype type, u32 *flags,
 				      struct vif_params *params);
-static int32 __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
+static s32 __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 				struct cfg80211_scan_request *request,
 				struct cfg80211_ssid *this_ssid);
-static int32 wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
+static s32 wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 			      struct cfg80211_scan_request *request);
-static int32 wl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed);
-static int32 wl_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,
+static s32 wl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed);
+static s32 wl_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,
 				   struct cfg80211_ibss_params *params);
-static int32 wl_cfg80211_leave_ibss(struct wiphy *wiphy,
+static s32 wl_cfg80211_leave_ibss(struct wiphy *wiphy,
 				    struct net_device *dev);
-static int32 wl_cfg80211_get_station(struct wiphy *wiphy,
+static s32 wl_cfg80211_get_station(struct wiphy *wiphy,
 				     struct net_device *dev, u8 *mac,
 				     struct station_info *sinfo);
-static int32 wl_cfg80211_set_power_mgmt(struct wiphy *wiphy,
+static s32 wl_cfg80211_set_power_mgmt(struct wiphy *wiphy,
 					struct net_device *dev, bool enabled,
-					int32 timeout);
-static int32 wl_cfg80211_set_bitrate_mask(struct wiphy *wiphy,
+					s32 timeout);
+static s32 wl_cfg80211_set_bitrate_mask(struct wiphy *wiphy,
 					  struct net_device *dev,
 					  const u8 *addr,
 					  const struct cfg80211_bitrate_mask
 					  *mask);
 static int wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 			       struct cfg80211_connect_params *sme);
-static int32 wl_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
+static s32 wl_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 				    u16 reason_code);
-static int32 wl_cfg80211_set_tx_power(struct wiphy *wiphy,
+static s32 wl_cfg80211_set_tx_power(struct wiphy *wiphy,
 				      enum nl80211_tx_power_setting type,
-				      int32 dbm);
-static int32 wl_cfg80211_get_tx_power(struct wiphy *wiphy, int32 *dbm);
-static int32 wl_cfg80211_config_default_key(struct wiphy *wiphy,
+				      s32 dbm);
+static s32 wl_cfg80211_get_tx_power(struct wiphy *wiphy, s32 *dbm);
+static s32 wl_cfg80211_config_default_key(struct wiphy *wiphy,
 					    struct net_device *dev,
 					    u8 key_idx);
-static int32 wl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
+static s32 wl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
 				 u8 key_idx, const u8 *mac_addr,
 				 struct key_params *params);
-static int32 wl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
+static s32 wl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
 				 u8 key_idx, const u8 *mac_addr);
-static int32 wl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *dev,
+static s32 wl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *dev,
 				 u8 key_idx, const u8 *mac_addr,
 				 void *cookie, void (*callback) (void *cookie,
 								 struct
 								 key_params *
 								 params));
-static int32 wl_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,
+static s32 wl_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,
 						 struct net_device *dev,
 						 u8 key_idx);
-static int32 wl_cfg80211_resume(struct wiphy *wiphy);
-static int32 wl_cfg80211_suspend(struct wiphy *wiphy);
-static int32 wl_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *dev,
+static s32 wl_cfg80211_resume(struct wiphy *wiphy);
+static s32 wl_cfg80211_suspend(struct wiphy *wiphy);
+static s32 wl_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *dev,
 				   struct cfg80211_pmksa *pmksa);
-static int32 wl_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *dev,
+static s32 wl_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *dev,
 				   struct cfg80211_pmksa *pmksa);
-static int32 wl_cfg80211_flush_pmksa(struct wiphy *wiphy,
+static s32 wl_cfg80211_flush_pmksa(struct wiphy *wiphy,
 				     struct net_device *dev);
 /*
 ** event & event Q handlers for cfg80211 interfaces
 */
-static int32 wl_create_event_handler(struct wl_priv *wl);
+static s32 wl_create_event_handler(struct wl_priv *wl);
 static void wl_destroy_event_handler(struct wl_priv *wl);
-static int32 wl_event_handler(void *data);
+static s32 wl_event_handler(void *data);
 static void wl_init_eq(struct wl_priv *wl);
 static void wl_flush_eq(struct wl_priv *wl);
 static void wl_lock_eq(struct wl_priv *wl);
@@ -129,24 +129,24 @@ static void wl_unlock_eq(struct wl_priv
 static void wl_init_eq_lock(struct wl_priv *wl);
 static void wl_init_eloop_handler(struct wl_event_loop *el);
 static struct wl_event_q *wl_deq_event(struct wl_priv *wl);
-static int32 wl_enq_event(struct wl_priv *wl, u32 type,
+static s32 wl_enq_event(struct wl_priv *wl, u32 type,
 			  const wl_event_msg_t *msg, void *data);
 static void wl_put_event(struct wl_event_q *e);
 static void wl_wakeup_event(struct wl_priv *wl);
-static int32 wl_notify_connect_status(struct wl_priv *wl,
+static s32 wl_notify_connect_status(struct wl_priv *wl,
 				      struct net_device *ndev,
 				      const wl_event_msg_t *e, void *data);
-static int32 wl_notify_roaming_status(struct wl_priv *wl,
+static s32 wl_notify_roaming_status(struct wl_priv *wl,
 				      struct net_device *ndev,
 				      const wl_event_msg_t *e, void *data);
-static int32 wl_notify_scan_status(struct wl_priv *wl, struct net_device *ndev,
+static s32 wl_notify_scan_status(struct wl_priv *wl, struct net_device *ndev,
 				   const wl_event_msg_t *e, void *data);
-static int32 wl_bss_connect_done(struct wl_priv *wl, struct net_device *ndev,
+static s32 wl_bss_connect_done(struct wl_priv *wl, struct net_device *ndev,
 				 const wl_event_msg_t *e, void *data,
 				bool completed);
-static int32 wl_bss_roaming_done(struct wl_priv *wl, struct net_device *ndev,
+static s32 wl_bss_roaming_done(struct wl_priv *wl, struct net_device *ndev,
 				 const wl_event_msg_t *e, void *data);
-static int32 wl_notify_mic_status(struct wl_priv *wl, struct net_device *ndev,
+static s32 wl_notify_mic_status(struct wl_priv *wl, struct net_device *ndev,
 				  const wl_event_msg_t *e, void *data);
 
 /*
@@ -158,66 +158,66 @@ static void wl_clear_sdio_func(void);
 /*
 ** ioctl utilites
 */
-static int32 wl_dev_bufvar_get(struct net_device *dev, s8 *name, s8 *buf,
-			       int32 buf_len);
-static __used int32 wl_dev_bufvar_set(struct net_device *dev, s8 *name,
-				      s8 *buf, int32 len);
-static int32 wl_dev_intvar_set(struct net_device *dev, s8 *name, int32 val);
-static int32 wl_dev_intvar_get(struct net_device *dev, s8 *name,
-			       int32 *retval);
-static int32 wl_dev_ioctl(struct net_device *dev, u32 cmd, void *arg,
+static s32 wl_dev_bufvar_get(struct net_device *dev, s8 *name, s8 *buf,
+			       s32 buf_len);
+static __used s32 wl_dev_bufvar_set(struct net_device *dev, s8 *name,
+				      s8 *buf, s32 len);
+static s32 wl_dev_intvar_set(struct net_device *dev, s8 *name, s32 val);
+static s32 wl_dev_intvar_get(struct net_device *dev, s8 *name,
+			       s32 *retval);
+static s32 wl_dev_ioctl(struct net_device *dev, u32 cmd, void *arg,
 			  u32 len);
 
 /*
 ** cfg80211 set_wiphy_params utilities
 */
-static int32 wl_set_frag(struct net_device *dev, u32 frag_threshold);
-static int32 wl_set_rts(struct net_device *dev, u32 frag_threshold);
-static int32 wl_set_retry(struct net_device *dev, u32 retry, bool l);
+static s32 wl_set_frag(struct net_device *dev, u32 frag_threshold);
+static s32 wl_set_rts(struct net_device *dev, u32 frag_threshold);
+static s32 wl_set_retry(struct net_device *dev, u32 retry, bool l);
 
 /*
 ** wl profile utilities
 */
-static int32 wl_update_prof(struct wl_priv *wl, const wl_event_msg_t *e,
-			    void *data, int32 item);
-static void *wl_read_prof(struct wl_priv *wl, int32 item);
+static s32 wl_update_prof(struct wl_priv *wl, const wl_event_msg_t *e,
+			    void *data, s32 item);
+static void *wl_read_prof(struct wl_priv *wl, s32 item);
 static void wl_init_prof(struct wl_profile *prof);
 
 /*
 ** cfg80211 connect utilites
 */
-static int32 wl_set_wpa_version(struct net_device *dev,
+static s32 wl_set_wpa_version(struct net_device *dev,
 				struct cfg80211_connect_params *sme);
-static int32 wl_set_auth_type(struct net_device *dev,
+static s32 wl_set_auth_type(struct net_device *dev,
 			      struct cfg80211_connect_params *sme);
-static int32 wl_set_set_cipher(struct net_device *dev,
+static s32 wl_set_set_cipher(struct net_device *dev,
 			       struct cfg80211_connect_params *sme);
-static int32 wl_set_key_mgmt(struct net_device *dev,
+static s32 wl_set_key_mgmt(struct net_device *dev,
 			     struct cfg80211_connect_params *sme);
-static int32 wl_set_set_sharedkey(struct net_device *dev,
+static s32 wl_set_set_sharedkey(struct net_device *dev,
 				  struct cfg80211_connect_params *sme);
-static int32 wl_get_assoc_ies(struct wl_priv *wl);
+static s32 wl_get_assoc_ies(struct wl_priv *wl);
 
 /*
 ** information element utilities
 */
 static void wl_rst_ie(struct wl_priv *wl);
-static int32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v);
-static int32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, u16 ie_size);
-static int32 wl_cp_ie(struct wl_priv *wl, u8 *dst, u16 dst_size);
+static s32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v);
+static s32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, u16 ie_size);
+static s32 wl_cp_ie(struct wl_priv *wl, u8 *dst, u16 dst_size);
 static u32 wl_get_ielen(struct wl_priv *wl);
 
-static int32 wl_mode_to_nl80211_iftype(int32 mode);
+static s32 wl_mode_to_nl80211_iftype(s32 mode);
 
-static struct wireless_dev *wl_alloc_wdev(int32 sizeof_iface,
+static struct wireless_dev *wl_alloc_wdev(s32 sizeof_iface,
 					  struct device *dev);
 static void wl_free_wdev(struct wl_priv *wl);
 
-static int32 wl_inform_bss(struct wl_priv *wl);
-static int32 wl_inform_single_bss(struct wl_priv *wl, struct wl_bss_info *bi);
-static int32 wl_update_bss_info(struct wl_priv *wl);
+static s32 wl_inform_bss(struct wl_priv *wl);
+static s32 wl_inform_single_bss(struct wl_priv *wl, struct wl_bss_info *bi);
+static s32 wl_update_bss_info(struct wl_priv *wl);
 
-static int32 wl_add_keyext(struct wiphy *wiphy, struct net_device *dev,
+static s32 wl_add_keyext(struct wiphy *wiphy, struct net_device *dev,
 			   u8 key_idx, const u8 *mac_addr,
 			   struct key_params *params);
 
@@ -230,7 +230,7 @@ static void swap_key_to_BE(struct wl_wse
 /*
 ** wl_priv memory init/deinit utilities
 */
-static int32 wl_init_priv_mem(struct wl_priv *wl);
+static s32 wl_init_priv_mem(struct wl_priv *wl);
 static void wl_deinit_priv_mem(struct wl_priv *wl);
 
 static void wl_delay(u32 ms);
@@ -255,61 +255,61 @@ static bool wl_is_linkup(struct wl_priv
 static bool wl_is_nonetwork(struct wl_priv *wl, const wl_event_msg_t *e);
 static void wl_link_up(struct wl_priv *wl);
 static void wl_link_down(struct wl_priv *wl);
-static int32 wl_dongle_mode(struct net_device *ndev, int32 iftype);
-static int32 __wl_cfg80211_up(struct wl_priv *wl);
-static int32 __wl_cfg80211_down(struct wl_priv *wl);
-static int32 wl_dongle_probecap(struct wl_priv *wl);
+static s32 wl_dongle_mode(struct net_device *ndev, s32 iftype);
+static s32 __wl_cfg80211_up(struct wl_priv *wl);
+static s32 __wl_cfg80211_down(struct wl_priv *wl);
+static s32 wl_dongle_probecap(struct wl_priv *wl);
 static void wl_init_conf(struct wl_conf *conf);
 
 /*
 ** dongle configuration utilities
 */
 #ifndef EMBEDDED_PLATFORM
-static int32 wl_dongle_mode(struct net_device *ndev, int32 iftype);
-static int32 wl_dongle_country(struct net_device *ndev, u8 ccode);
-static int32 wl_dongle_up(struct net_device *ndev, u32 up);
-static int32 wl_dongle_power(struct net_device *ndev, u32 power_mode);
-static int32 wl_dongle_glom(struct net_device *ndev, u32 glom,
+static s32 wl_dongle_mode(struct net_device *ndev, s32 iftype);
+static s32 wl_dongle_country(struct net_device *ndev, u8 ccode);
+static s32 wl_dongle_up(struct net_device *ndev, u32 up);
+static s32 wl_dongle_power(struct net_device *ndev, u32 power_mode);
+static s32 wl_dongle_glom(struct net_device *ndev, u32 glom,
 			    u32 dongle_align);
-static int32 wl_dongle_roam(struct net_device *ndev, u32 roamvar,
+static s32 wl_dongle_roam(struct net_device *ndev, u32 roamvar,
 			    u32 bcn_timeout);
-static int32 wl_dongle_eventmsg(struct net_device *ndev);
-static int32 wl_dongle_scantime(struct net_device *ndev, int32 scan_assoc_time,
-				int32 scan_unassoc_time);
-static int32 wl_dongle_offload(struct net_device *ndev, int32 arpoe,
-			       int32 arp_ol);
-static int32 wl_pattern_atoh(s8 *src, s8 *dst);
-static int32 wl_dongle_filter(struct net_device *ndev, u32 filter_mode);
-static int32 wl_update_wiphybands(struct wl_priv *wl);
+static s32 wl_dongle_eventmsg(struct net_device *ndev);
+static s32 wl_dongle_scantime(struct net_device *ndev, s32 scan_assoc_time,
+				s32 scan_unassoc_time);
+static s32 wl_dongle_offload(struct net_device *ndev, s32 arpoe,
+			       s32 arp_ol);
+static s32 wl_pattern_atoh(s8 *src, s8 *dst);
+static s32 wl_dongle_filter(struct net_device *ndev, u32 filter_mode);
+static s32 wl_update_wiphybands(struct wl_priv *wl);
 #endif				/* !EMBEDDED_PLATFORM */
-static int32 wl_config_dongle(struct wl_priv *wl, bool need_lock);
+static s32 wl_config_dongle(struct wl_priv *wl, bool need_lock);
 
 /*
 ** iscan handler
 */
 static void wl_iscan_timer(unsigned long data);
 static void wl_term_iscan(struct wl_priv *wl);
-static int32 wl_init_iscan(struct wl_priv *wl);
-static int32 wl_iscan_thread(void *data);
-static int32 wl_dev_iovar_setbuf(struct net_device *dev, s8 *iovar,
-				 void *param, int32 paramlen, void *bufptr,
-				 int32 buflen);
-static int32 wl_dev_iovar_getbuf(struct net_device *dev, s8 *iovar,
-				 void *param, int32 paramlen, void *bufptr,
-				 int32 buflen);
-static int32 wl_run_iscan(struct wl_iscan_ctrl *iscan, struct wlc_ssid *ssid,
+static s32 wl_init_iscan(struct wl_priv *wl);
+static s32 wl_iscan_thread(void *data);
+static s32 wl_dev_iovar_setbuf(struct net_device *dev, s8 *iovar,
+				 void *param, s32 paramlen, void *bufptr,
+				 s32 buflen);
+static s32 wl_dev_iovar_getbuf(struct net_device *dev, s8 *iovar,
+				 void *param, s32 paramlen, void *bufptr,
+				 s32 buflen);
+static s32 wl_run_iscan(struct wl_iscan_ctrl *iscan, struct wlc_ssid *ssid,
 			  u16 action);
-static int32 wl_do_iscan(struct wl_priv *wl);
-static int32 wl_wakeup_iscan(struct wl_iscan_ctrl *iscan);
-static int32 wl_invoke_iscan(struct wl_priv *wl);
-static int32 wl_get_iscan_results(struct wl_iscan_ctrl *iscan, u32 *status,
+static s32 wl_do_iscan(struct wl_priv *wl);
+static s32 wl_wakeup_iscan(struct wl_iscan_ctrl *iscan);
+static s32 wl_invoke_iscan(struct wl_priv *wl);
+static s32 wl_get_iscan_results(struct wl_iscan_ctrl *iscan, u32 *status,
 				  struct wl_scan_results **bss_list);
 static void wl_notify_iscan_complete(struct wl_iscan_ctrl *iscan, bool aborted);
 static void wl_init_iscan_eloop(struct wl_iscan_eloop *el);
-static int32 wl_iscan_done(struct wl_priv *wl);
-static int32 wl_iscan_pending(struct wl_priv *wl);
-static int32 wl_iscan_inprogress(struct wl_priv *wl);
-static int32 wl_iscan_aborted(struct wl_priv *wl);
+static s32 wl_iscan_done(struct wl_priv *wl);
+static s32 wl_iscan_pending(struct wl_priv *wl);
+static s32 wl_iscan_inprogress(struct wl_priv *wl);
+static s32 wl_iscan_aborted(struct wl_priv *wl);
 
 /*
 ** fw/nvram downloading handler
@@ -324,8 +324,8 @@ static __used u32 wl_find_msb(u16 bit16)
 /*
 * update pmklist to dongle
 */
-static __used int32 wl_update_pmklist(struct net_device *dev,
-				      struct wl_pmk_list *pmk_list, int32 err);
+static __used s32 wl_update_pmklist(struct net_device *dev,
+				      struct wl_pmk_list *pmk_list, s32 err);
 
 #define WL_PRIV_GET() 							\
 	({								\
@@ -570,13 +570,13 @@ static void swap_key_to_BE(struct wl_wse
 	key->iv_initialized = dtoh32(key->iv_initialized);
 }
 
-static int32
+static s32
 wl_dev_ioctl(struct net_device *dev, u32 cmd, void *arg, u32 len)
 {
 	struct ifreq ifr;
 	struct wl_ioctl ioc;
 	mm_segment_t fs;
-	int32 err = 0;
+	s32 err = 0;
 
 	memset(&ioc, 0, sizeof(ioc));
 	ioc.cmd = cmd;
@@ -593,16 +593,16 @@ wl_dev_ioctl(struct net_device *dev, u32
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_change_iface(struct wiphy *wiphy, struct net_device *ndev,
 			 enum nl80211_iftype type, u32 *flags,
 			 struct vif_params *params)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	struct wireless_dev *wdev;
-	int32 infra = 0;
-	int32 ap = 0;
-	int32 err = 0;
+	s32 infra = 0;
+	s32 ap = 0;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 	switch (type) {
@@ -661,11 +661,11 @@ static void wl_iscan_prep(struct wl_scan
 
 }
 
-static int32
+static s32
 wl_dev_iovar_setbuf(struct net_device *dev, s8 * iovar, void *param,
-		    int32 paramlen, void *bufptr, int32 buflen)
+		    s32 paramlen, void *bufptr, s32 buflen)
 {
-	int32 iolen;
+	s32 iolen;
 
 	iolen = bcm_mkiovar(iovar, param, paramlen, bufptr, buflen);
 	BUG_ON(unlikely(!iolen));
@@ -673,11 +673,11 @@ wl_dev_iovar_setbuf(struct net_device *d
 	return wl_dev_ioctl(dev, WLC_SET_VAR, bufptr, iolen);
 }
 
-static int32
+static s32
 wl_dev_iovar_getbuf(struct net_device *dev, s8 * iovar, void *param,
-		    int32 paramlen, void *bufptr, int32 buflen)
+		    s32 paramlen, void *bufptr, s32 buflen)
 {
-	int32 iolen;
+	s32 iolen;
 
 	iolen = bcm_mkiovar(iovar, param, paramlen, bufptr, buflen);
 	BUG_ON(unlikely(!iolen));
@@ -685,13 +685,13 @@ wl_dev_iovar_getbuf(struct net_device *d
 	return wl_dev_ioctl(dev, WLC_GET_VAR, bufptr, buflen);
 }
 
-static int32
+static s32
 wl_run_iscan(struct wl_iscan_ctrl *iscan, struct wlc_ssid *ssid, u16 action)
 {
-	int32 params_size =
+	s32 params_size =
 	    (WL_SCAN_PARAMS_FIXED_SIZE + OFFSETOF(wl_iscan_params_t, params));
 	struct wl_iscan_params *params;
-	int32 err = 0;
+	s32 err = 0;
 
 	if (ssid && ssid->SSID_len)
 		params_size += sizeof(struct wlc_ssid);
@@ -721,11 +721,11 @@ wl_run_iscan(struct wl_iscan_ctrl *iscan
 	return err;
 }
 
-static int32 wl_do_iscan(struct wl_priv *wl)
+static s32 wl_do_iscan(struct wl_priv *wl)
 {
 	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
 	struct wlc_ssid ssid;
-	int32 err = 0;
+	s32 err = 0;
 
 	/* Broadcast scan by default */
 	memset(&ssid, 0, sizeof(ssid));
@@ -733,7 +733,7 @@ static int32 wl_do_iscan(struct wl_priv
 	iscan->state = WL_ISCAN_STATE_SCANING;
 
 	if (wl->active_scan) {
-		int32 passive_scan = 0;
+		s32 passive_scan = 0;
 		/* make it active scan */
 		err = wl_dev_ioctl(wl_to_ndev(wl), WLC_SET_PASSIVE_SCAN,
 				&passive_scan, sizeof(passive_scan));
@@ -750,7 +750,7 @@ static int32 wl_do_iscan(struct wl_priv
 	return err;
 }
 
-static int32
+static s32
 __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 		   struct cfg80211_scan_request *request,
 		   struct cfg80211_ssid *this_ssid)
@@ -760,7 +760,7 @@ __wl_cfg80211_scan(struct wiphy *wiphy,
 	struct wl_scan_req *sr = wl_to_sr(wl);
 	bool iscan_req;
 	bool spec_scan;
-	int32 err = 0;
+	s32 err = 0;
 
 	if (unlikely(test_bit(WL_STATUS_SCANNING, &wl->status))) {
 		WL_ERR(("Scanning already : status (%d)\n", (int)wl->status));
@@ -816,7 +816,7 @@ __wl_cfg80211_scan(struct wiphy *wiphy,
 		}
 		WL_DBG(("sr->ssid.SSID_len (%d)\n", sr->ssid.SSID_len));
 		if (wl->active_scan) {
-			int32 pssive_scan = 0;
+			s32 pssive_scan = 0;
 			/* make it active scan */
 			err = wl_dev_ioctl(ndev, WLC_SET_PASSIVE_SCAN,
 					&pssive_scan, sizeof(pssive_scan));
@@ -847,11 +847,11 @@ scan_out:
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 		 struct cfg80211_scan_request *request)
 {
-	int32 err = 0;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 	err = __wl_cfg80211_scan(wiphy, ndev, request, NULL);
@@ -863,11 +863,11 @@ wl_cfg80211_scan(struct wiphy *wiphy, st
 	return err;
 }
 
-static int32 wl_dev_intvar_set(struct net_device *dev, s8 *name, int32 val)
+static s32 wl_dev_intvar_set(struct net_device *dev, s8 *name, s32 val)
 {
 	s8 buf[WLC_IOCTL_SMLEN];
 	u32 len;
-	int32 err = 0;
+	s32 err = 0;
 
 	val = htod32(val);
 	len = bcm_mkiovar(name, (char *)(&val), sizeof(val), buf, sizeof(buf));
@@ -881,16 +881,16 @@ static int32 wl_dev_intvar_set(struct ne
 	return err;
 }
 
-static int32
-wl_dev_intvar_get(struct net_device *dev, s8 *name, int32 *retval)
+static s32
+wl_dev_intvar_get(struct net_device *dev, s8 *name, s32 *retval)
 {
 	union {
 		s8 buf[WLC_IOCTL_SMLEN];
-		int32 val;
+		s32 val;
 	} var;
 	u32 len;
 	u32 data_null;
-	int32 err = 0;
+	s32 err = 0;
 
 	len =
 	    bcm_mkiovar(name, (char *)(&data_null), 0, (char *)(&var),
@@ -905,9 +905,9 @@ wl_dev_intvar_get(struct net_device *dev
 	return err;
 }
 
-static int32 wl_set_rts(struct net_device *dev, u32 rts_threshold)
+static s32 wl_set_rts(struct net_device *dev, u32 rts_threshold)
 {
-	int32 err = 0;
+	s32 err = 0;
 
 	err = wl_dev_intvar_set(dev, "rtsthresh", rts_threshold);
 	if (unlikely(err)) {
@@ -917,9 +917,9 @@ static int32 wl_set_rts(struct net_devic
 	return err;
 }
 
-static int32 wl_set_frag(struct net_device *dev, u32 frag_threshold)
+static s32 wl_set_frag(struct net_device *dev, u32 frag_threshold)
 {
-	int32 err = 0;
+	s32 err = 0;
 
 	err = wl_dev_intvar_set(dev, "fragthresh", frag_threshold);
 	if (unlikely(err)) {
@@ -929,9 +929,9 @@ static int32 wl_set_frag(struct net_devi
 	return err;
 }
 
-static int32 wl_set_retry(struct net_device *dev, u32 retry, bool l)
+static s32 wl_set_retry(struct net_device *dev, u32 retry, bool l)
 {
-	int32 err = 0;
+	s32 err = 0;
 	u32 cmd = (l ? WLC_SET_LRL : WLC_SET_SRL);
 
 	retry = htod32(retry);
@@ -943,11 +943,11 @@ static int32 wl_set_retry(struct net_dev
 	return err;
 }
 
-static int32 wl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
+static s32 wl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	struct net_device *ndev = wl_to_ndev(wl);
-	int32 err = 0;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 	if (changed & WIPHY_PARAM_RTS_THRESHOLD &&
@@ -983,7 +983,7 @@ static int32 wl_cfg80211_set_wiphy_param
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,
 		      struct cfg80211_ibss_params *params)
 {
@@ -992,8 +992,8 @@ wl_cfg80211_join_ibss(struct wiphy *wiph
 	struct ieee80211_channel *chan;
 	struct wl_join_params join_params;
 	struct cfg80211_ssid ssid;
-	int32 scan_retry = 0;
-	int32 err = 0;
+	s32 scan_retry = 0;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 	if (params->bssid) {
@@ -1053,10 +1053,10 @@ wl_cfg80211_join_ibss(struct wiphy *wiph
 	return err;
 }
 
-static int32 wl_cfg80211_leave_ibss(struct wiphy *wiphy, struct net_device *dev)
+static s32 wl_cfg80211_leave_ibss(struct wiphy *wiphy, struct net_device *dev)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
-	int32 err = 0;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 	wl_link_down(wl);
@@ -1064,13 +1064,13 @@ static int32 wl_cfg80211_leave_ibss(stru
 	return err;
 }
 
-static int32
+static s32
 wl_set_wpa_version(struct net_device *dev, struct cfg80211_connect_params *sme)
 {
 	struct wl_priv *wl = ndev_to_wl(dev);
 	struct wl_security *sec;
-	int32 val = 0;
-	int32 err = 0;
+	s32 val = 0;
+	s32 err = 0;
 
 	if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)
 		val = WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED;
@@ -1089,13 +1089,13 @@ wl_set_wpa_version(struct net_device *de
 	return err;
 }
 
-static int32
+static s32
 wl_set_auth_type(struct net_device *dev, struct cfg80211_connect_params *sme)
 {
 	struct wl_priv *wl = ndev_to_wl(dev);
 	struct wl_security *sec;
-	int32 val = 0;
-	int32 err = 0;
+	s32 val = 0;
+	s32 err = 0;
 
 	switch (sme->auth_type) {
 	case NL80211_AUTHTYPE_OPEN_SYSTEM:
@@ -1128,14 +1128,14 @@ wl_set_auth_type(struct net_device *dev,
 	return err;
 }
 
-static int32
+static s32
 wl_set_set_cipher(struct net_device *dev, struct cfg80211_connect_params *sme)
 {
 	struct wl_priv *wl = ndev_to_wl(dev);
 	struct wl_security *sec;
-	int32 pval = 0;
-	int32 gval = 0;
-	int32 err = 0;
+	s32 pval = 0;
+	s32 gval = 0;
+	s32 err = 0;
 
 	if (sme->crypto.n_ciphers_pairwise) {
 		switch (sme->crypto.ciphers_pairwise[0]) {
@@ -1194,13 +1194,13 @@ wl_set_set_cipher(struct net_device *dev
 	return err;
 }
 
-static int32
+static s32
 wl_set_key_mgmt(struct net_device *dev, struct cfg80211_connect_params *sme)
 {
 	struct wl_priv *wl = ndev_to_wl(dev);
 	struct wl_security *sec;
-	int32 val = 0;
-	int32 err = 0;
+	s32 val = 0;
+	s32 err = 0;
 
 	if (sme->crypto.n_akm_suites) {
 		err = wl_dev_intvar_get(dev, "wpa_auth", &val);
@@ -1249,15 +1249,15 @@ wl_set_key_mgmt(struct net_device *dev,
 	return err;
 }
 
-static int32
+static s32
 wl_set_set_sharedkey(struct net_device *dev,
 		     struct cfg80211_connect_params *sme)
 {
 	struct wl_priv *wl = ndev_to_wl(dev);
 	struct wl_security *sec;
 	struct wl_wsec_key key;
-	int32 val;
-	int32 err = 0;
+	s32 val;
+	s32 err = 0;
 
 	WL_DBG(("key len (%d)\n", sme->key_len));
 	if (sme->key_len) {
@@ -1315,14 +1315,14 @@ wl_set_set_sharedkey(struct net_device *
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 		    struct cfg80211_connect_params *sme)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	struct ieee80211_channel *chan = sme->channel;
 	struct wlc_ssid ssid;
-	int32 err = 0;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 	if (unlikely(!sme->ssid)) {
@@ -1378,14 +1378,14 @@ wl_cfg80211_connect(struct wiphy *wiphy,
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 		       u16 reason_code)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	scb_val_t scbval;
 	bool act = FALSE;
-	int32 err = 0;
+	s32 err = 0;
 
 	WL_DBG(("Reason %d\n", reason_code));
 	CHECK_SYS_UP();
@@ -1405,16 +1405,16 @@ wl_cfg80211_disconnect(struct wiphy *wip
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_set_tx_power(struct wiphy *wiphy,
-			 enum nl80211_tx_power_setting type, int32 dbm)
+			 enum nl80211_tx_power_setting type, s32 dbm)
 {
 
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	struct net_device *ndev = wl_to_ndev(wl);
 	u16 txpwrmw;
-	int32 err = 0;
-	int32 disable = 0;
+	s32 err = 0;
+	s32 disable = 0;
 
 	CHECK_SYS_UP();
 	switch (type) {
@@ -1447,7 +1447,7 @@ wl_cfg80211_set_tx_power(struct wiphy *w
 	else
 		txpwrmw = (u16) dbm;
 	err = wl_dev_intvar_set(ndev, "qtxpower",
-			(int32) (bcm_mw_to_qdbm(txpwrmw)));
+			(s32) (bcm_mw_to_qdbm(txpwrmw)));
 	if (unlikely(err)) {
 		WL_ERR(("qtxpower error (%d)\n", err));
 		return err;
@@ -1457,13 +1457,13 @@ wl_cfg80211_set_tx_power(struct wiphy *w
 	return err;
 }
 
-static int32 wl_cfg80211_get_tx_power(struct wiphy *wiphy, int32 *dbm)
+static s32 wl_cfg80211_get_tx_power(struct wiphy *wiphy, s32 *dbm)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	struct net_device *ndev = wl_to_ndev(wl);
-	int32 txpwrdbm;
+	s32 txpwrdbm;
 	u8 result;
-	int32 err = 0;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 	err = wl_dev_intvar_get(ndev, "qtxpower", &txpwrdbm);
@@ -1472,18 +1472,18 @@ static int32 wl_cfg80211_get_tx_power(st
 		return err;
 	}
 	result = (u8) (txpwrdbm & ~WL_TXPWR_OVERRIDE);
-	*dbm = (int32) bcm_qdbm_to_mw(result);
+	*dbm = (s32) bcm_qdbm_to_mw(result);
 
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_config_default_key(struct wiphy *wiphy, struct net_device *dev,
 			       u8 key_idx)
 {
 	u32 index;
-	int32 wsec;
-	int32 err = 0;
+	s32 wsec;
+	s32 err = 0;
 
 	WL_DBG(("key index (%d)\n", key_idx));
 	CHECK_SYS_UP();
@@ -1507,12 +1507,12 @@ wl_cfg80211_config_default_key(struct wi
 	return err;
 }
 
-static int32
+static s32
 wl_add_keyext(struct wiphy *wiphy, struct net_device *dev,
 	      u8 key_idx, const u8 *mac_addr, struct key_params *params)
 {
 	struct wl_wsec_key key;
-	int32 err = 0;
+	s32 err = 0;
 
 	memset(&key, 0, sizeof(key));
 	key.index = (u32) key_idx;
@@ -1594,15 +1594,15 @@ wl_add_keyext(struct wiphy *wiphy, struc
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
 		    u8 key_idx, const u8 *mac_addr,
 		    struct key_params *params)
 {
 	struct wl_wsec_key key;
-	int32 val;
-	int32 wsec;
-	int32 err = 0;
+	s32 val;
+	s32 wsec;
+	s32 err = 0;
 
 	WL_DBG(("key index (%d)\n", key_idx));
 	CHECK_SYS_UP();
@@ -1679,14 +1679,14 @@ wl_cfg80211_add_key(struct wiphy *wiphy,
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
 		    u8 key_idx, const u8 *mac_addr)
 {
 	struct wl_wsec_key key;
-	int32 err = 0;
-	int32 val;
-	int32 wsec;
+	s32 err = 0;
+	s32 val;
+	s32 wsec;
 
 	CHECK_SYS_UP();
 	memset(&key, 0, sizeof(key));
@@ -1735,7 +1735,7 @@ wl_cfg80211_del_key(struct wiphy *wiphy,
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *dev,
 		    u8 key_idx, const u8 *mac_addr, void *cookie,
 		    void (*callback) (void *cookie, struct key_params * params))
@@ -1744,8 +1744,8 @@ wl_cfg80211_get_key(struct wiphy *wiphy,
 	struct wl_wsec_key key;
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	struct wl_security *sec;
-	int32 wsec;
-	int32 err = 0;
+	s32 wsec;
+	s32 err = 0;
 
 	WL_DBG(("key index (%d)\n", key_idx));
 	CHECK_SYS_UP();
@@ -1791,7 +1791,7 @@ wl_cfg80211_get_key(struct wiphy *wiphy,
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,
 				    struct net_device *dev, u8 key_idx)
 {
@@ -1800,15 +1800,15 @@ wl_cfg80211_config_default_mgmt_key(stru
 	return -EOPNOTSUPP;
 }
 
-static int32
+static s32
 wl_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,
 			u8 *mac, struct station_info *sinfo)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	scb_val_t scb_val;
 	int rssi;
-	int32 rate;
-	int32 err = 0;
+	s32 rate;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 	if (unlikely
@@ -1845,12 +1845,12 @@ wl_cfg80211_get_station(struct wiphy *wi
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,
-			   bool enabled, int32 timeout)
+			   bool enabled, s32 timeout)
 {
-	int32 pm;
-	int32 err = 0;
+	s32 pm;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 	pm = enabled ? PM_FAST : PM_OFF;
@@ -1894,18 +1894,18 @@ static __used u32 wl_find_msb(u16 bit16)
 	return ret;
 }
 
-static int32
+static s32
 wl_cfg80211_set_bitrate_mask(struct wiphy *wiphy, struct net_device *dev,
 			     const u8 *addr,
 			     const struct cfg80211_bitrate_mask *mask)
 {
 	struct wl_rateset rateset;
-	int32 rate;
-	int32 val;
-	int32 err_bg;
-	int32 err_a;
+	s32 rate;
+	s32 val;
+	s32 err_bg;
+	s32 err_a;
 	u32 legacy;
-	int32 err = 0;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 	/* addr param is always NULL. ignore it */
@@ -1950,9 +1950,9 @@ wl_cfg80211_set_bitrate_mask(struct wiph
 	return err;
 }
 
-static int32 wl_cfg80211_resume(struct wiphy *wiphy)
+static s32 wl_cfg80211_resume(struct wiphy *wiphy)
 {
-	int32 err = 0;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 	wl_invoke_iscan(wiphy_to_wl(wiphy));
@@ -1960,10 +1960,10 @@ static int32 wl_cfg80211_resume(struct w
 	return err;
 }
 
-static int32 wl_cfg80211_suspend(struct wiphy *wiphy)
+static s32 wl_cfg80211_suspend(struct wiphy *wiphy)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
-	int32 err = 0;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 
@@ -1980,9 +1980,9 @@ static int32 wl_cfg80211_suspend(struct
 	return err;
 }
 
-static __used int32
+static __used s32
 wl_update_pmklist(struct net_device *dev, struct wl_pmk_list *pmk_list,
-		  int32 err)
+		  s32 err)
 {
 	s8 eabuf[ETHER_ADDR_STR_LEN];
 	int i, j;
@@ -2006,13 +2006,13 @@ wl_update_pmklist(struct net_device *dev
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *dev,
 		      struct cfg80211_pmksa *pmksa)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	s8 eabuf[ETHER_ADDR_STR_LEN];
-	int32 err = 0;
+	s32 err = 0;
 	int i;
 
 	CHECK_SYS_UP();
@@ -2046,14 +2046,14 @@ wl_cfg80211_set_pmksa(struct wiphy *wiph
 	return err;
 }
 
-static int32
+static s32
 wl_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *dev,
 		      struct cfg80211_pmksa *pmksa)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	s8 eabuf[ETHER_ADDR_STR_LEN];
 	struct _pmkid_list pmkid;
-	int32 err = 0;
+	s32 err = 0;
 	int i;
 
 	CHECK_SYS_UP();
@@ -2095,11 +2095,11 @@ wl_cfg80211_del_pmksa(struct wiphy *wiph
 
 }
 
-static int32
+static s32
 wl_cfg80211_flush_pmksa(struct wiphy *wiphy, struct net_device *dev)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
-	int32 err = 0;
+	s32 err = 0;
 
 	CHECK_SYS_UP();
 	memset(wl->pmk_list, 0, sizeof(*wl->pmk_list));
@@ -2133,9 +2133,9 @@ static struct cfg80211_ops wl_cfg80211_o
 	.flush_pmksa = wl_cfg80211_flush_pmksa
 };
 
-static int32 wl_mode_to_nl80211_iftype(int32 mode)
+static s32 wl_mode_to_nl80211_iftype(s32 mode)
 {
-	int32 err = 0;
+	s32 err = 0;
 
 	switch (mode) {
 	case WL_MODE_BSS:
@@ -2149,11 +2149,11 @@ static int32 wl_mode_to_nl80211_iftype(i
 	return err;
 }
 
-static struct wireless_dev *wl_alloc_wdev(int32 sizeof_iface,
+static struct wireless_dev *wl_alloc_wdev(s32 sizeof_iface,
 					  struct device *dev)
 {
 	struct wireless_dev *wdev;
-	int32 err = 0;
+	s32 err = 0;
 
 	wdev = kzalloc(sizeof(*wdev), GFP_KERNEL);
 	if (unlikely(!wdev)) {
@@ -2221,11 +2221,11 @@ static void wl_free_wdev(struct wl_priv
 	wl_to_wdev(wl) = NULL;
 }
 
-static int32 wl_inform_bss(struct wl_priv *wl)
+static s32 wl_inform_bss(struct wl_priv *wl)
 {
 	struct wl_scan_results *bss_list;
 	struct wl_bss_info *bi = NULL;	/* must be initialized */
-	int32 err = 0;
+	s32 err = 0;
 	int i;
 
 	bss_list = wl->bss_list;
@@ -2244,7 +2244,7 @@ static int32 wl_inform_bss(struct wl_pri
 	return err;
 }
 
-static int32 wl_inform_single_bss(struct wl_priv *wl, struct wl_bss_info *bi)
+static s32 wl_inform_single_bss(struct wl_priv *wl, struct wl_bss_info *bi)
 {
 	struct wiphy *wiphy = wl_to_wiphy(wl);
 	struct ieee80211_mgmt *mgmt;
@@ -2254,7 +2254,7 @@ static int32 wl_inform_single_bss(struct
 	struct wl_scan_req *sr = wl_to_sr(wl);
 	u32 signal;
 	u32 freq;
-	int32 err = 0;
+	s32 err = 0;
 
 	if (unlikely(dtoh32(bi->length) > WL_BSS_INFO_MAX)) {
 		WL_DBG(("Beacon is larger than buffer. Discarding\n"));
@@ -2364,12 +2364,12 @@ static bool wl_is_nonetwork(struct wl_pr
 	return FALSE;
 }
 
-static int32
+static s32
 wl_notify_connect_status(struct wl_priv *wl, struct net_device *ndev,
 			 const wl_event_msg_t *e, void *data)
 {
 	bool act;
-	int32 err = 0;
+	s32 err = 0;
 
 	if (wl_is_linkup(wl, e)) {
 		wl_link_up(wl);
@@ -2397,12 +2397,12 @@ wl_notify_connect_status(struct wl_priv
 	return err;
 }
 
-static int32
+static s32
 wl_notify_roaming_status(struct wl_priv *wl, struct net_device *ndev,
 			 const wl_event_msg_t *e, void *data)
 {
 	bool act;
-	int32 err = 0;
+	s32 err = 0;
 
 	wl_bss_roaming_done(wl, ndev, e, data);
 	act = TRUE;
@@ -2411,8 +2411,8 @@ wl_notify_roaming_status(struct wl_priv
 	return err;
 }
 
-static __used int32
-wl_dev_bufvar_set(struct net_device *dev, s8 *name, s8 *buf, int32 len)
+static __used s32
+wl_dev_bufvar_set(struct net_device *dev, s8 *name, s8 *buf, s32 len)
 {
 	struct wl_priv *wl = ndev_to_wl(dev);
 	u32 buflen;
@@ -2423,13 +2423,13 @@ wl_dev_bufvar_set(struct net_device *dev
 	return wl_dev_ioctl(dev, WLC_SET_VAR, wl->ioctl_buf, buflen);
 }
 
-static int32
+static s32
 wl_dev_bufvar_get(struct net_device *dev, s8 *name, s8 *buf,
-		  int32 buf_len)
+		  s32 buf_len)
 {
 	struct wl_priv *wl = ndev_to_wl(dev);
 	u32 len;
-	int32 err = 0;
+	s32 err = 0;
 
 	len = bcm_mkiovar(name, NULL, 0, wl->ioctl_buf, WL_IOCTL_LEN_MAX);
 	BUG_ON(unlikely(!len));
@@ -2444,14 +2444,14 @@ wl_dev_bufvar_get(struct net_device *dev
 	return err;
 }
 
-static int32 wl_get_assoc_ies(struct wl_priv *wl)
+static s32 wl_get_assoc_ies(struct wl_priv *wl)
 {
 	struct net_device *ndev = wl_to_ndev(wl);
 	struct wl_assoc_ielen *assoc_info;
 	struct wl_connect_info *conn_info = wl_to_conn(wl);
 	u32 req_len;
 	u32 resp_len;
-	int32 err = 0;
+	s32 err = 0;
 
 	err = wl_dev_bufvar_get(ndev, "assoc_info", wl->extra_buf,
 				WL_ASSOC_INFO_MAX);
@@ -2496,12 +2496,12 @@ static int32 wl_get_assoc_ies(struct wl_
 	return err;
 }
 
-static int32 wl_update_bss_info(struct wl_priv *wl)
+static s32 wl_update_bss_info(struct wl_priv *wl)
 {
 	struct cfg80211_bss *bss;
 	struct wl_bss_info *bi;
 	struct wlc_ssid *ssid;
-	int32 err = 0;
+	s32 err = 0;
 
 	if (wl_is_ibssmode(wl))
 		return err;
@@ -2543,12 +2543,12 @@ update_bss_info_out:
 	return err;
 }
 
-static int32
+static s32
 wl_bss_roaming_done(struct wl_priv *wl, struct net_device *ndev,
 		    const wl_event_msg_t *e, void *data)
 {
 	struct wl_connect_info *conn_info = wl_to_conn(wl);
-	int32 err = 0;
+	s32 err = 0;
 
 	wl_get_assoc_ies(wl);
 	memcpy(&wl->bssid, &e->addr, ETHER_ADDR_LEN);
@@ -2564,12 +2564,12 @@ wl_bss_roaming_done(struct wl_priv *wl,
 	return err;
 }
 
-static int32
+static s32
 wl_bss_connect_done(struct wl_priv *wl, struct net_device *ndev,
 		    const wl_event_msg_t *e, void *data, bool completed)
 {
 	struct wl_connect_info *conn_info = wl_to_conn(wl);
-	int32 err = 0;
+	s32 err = 0;
 
 	wl_get_assoc_ies(wl);
 	memcpy(&wl->bssid, &e->addr, ETHER_ADDR_LEN);
@@ -2598,7 +2598,7 @@ wl_bss_connect_done(struct wl_priv *wl,
 	return err;
 }
 
-static int32
+static s32
 wl_notify_mic_status(struct wl_priv *wl, struct net_device *ndev,
 		     const wl_event_msg_t *e, void *data)
 {
@@ -2618,14 +2618,14 @@ wl_notify_mic_status(struct wl_priv *wl,
 	return 0;
 }
 
-static int32
+static s32
 wl_notify_scan_status(struct wl_priv *wl, struct net_device *ndev,
 		      const wl_event_msg_t *e, void *data)
 {
 	struct channel_info channel_inform;
 	struct wl_scan_results *bss_list;
 	u32 len = WL_SCAN_BUF_MAX;
-	int32 err = 0;
+	s32 err = 0;
 
 	if (wl->iscan_on && wl->iscan_kickstart)
 		return wl_wakeup_iscan(wl_to_iscan(wl));
@@ -2706,7 +2706,7 @@ static void wl_init_eloop_handler(struct
 	el->handler[WLC_E_SET_SSID] = wl_notify_connect_status;
 }
 
-static int32 wl_init_priv_mem(struct wl_priv *wl)
+static s32 wl_init_priv_mem(struct wl_priv *wl)
 {
 	wl->scan_results = (void *)kzalloc(WL_SCAN_BUF_MAX, GFP_KERNEL);
 	if (unlikely(!wl->scan_results)) {
@@ -2792,7 +2792,7 @@ static void wl_deinit_priv_mem(struct wl
 	wl->pmk_list = NULL;
 }
 
-static int32 wl_create_event_handler(struct wl_priv *wl)
+static s32 wl_create_event_handler(struct wl_priv *wl)
 {
 	sema_init(&wl->event_sync, 0);
 	init_completion(&wl->event_exit);
@@ -2840,7 +2840,7 @@ static void wl_notify_iscan_complete(str
 	wl->iscan_kickstart = FALSE;
 }
 
-static int32 wl_wakeup_iscan(struct wl_iscan_ctrl *iscan)
+static s32 wl_wakeup_iscan(struct wl_iscan_ctrl *iscan)
 {
 	if (likely(iscan->state != WL_ISCAN_STATE_IDLE)) {
 		WL_DBG(("wake up iscan\n"));
@@ -2851,14 +2851,14 @@ static int32 wl_wakeup_iscan(struct wl_i
 	return -EIO;
 }
 
-static int32
+static s32
 wl_get_iscan_results(struct wl_iscan_ctrl *iscan, u32 *status,
 		     struct wl_scan_results **bss_list)
 {
 	struct wl_iscan_results list;
 	struct wl_scan_results *results;
 	struct wl_iscan_results *list_buf;
-	int32 err = 0;
+	s32 err = 0;
 
 	memset(iscan->scan_buf, 0, WL_ISCAN_BUF_MAX);
 	list_buf = (struct wl_iscan_results *)iscan->scan_buf;
@@ -2887,10 +2887,10 @@ wl_get_iscan_results(struct wl_iscan_ctr
 	return err;
 }
 
-static int32 wl_iscan_done(struct wl_priv *wl)
+static s32 wl_iscan_done(struct wl_priv *wl)
 {
 	struct wl_iscan_ctrl *iscan = wl->iscan;
-	int32 err = 0;
+	s32 err = 0;
 
 	iscan->state = WL_ISCAN_STATE_IDLE;
 	rtnl_lock();
@@ -2901,10 +2901,10 @@ static int32 wl_iscan_done(struct wl_pri
 	return err;
 }
 
-static int32 wl_iscan_pending(struct wl_priv *wl)
+static s32 wl_iscan_pending(struct wl_priv *wl)
 {
 	struct wl_iscan_ctrl *iscan = wl->iscan;
-	int32 err = 0;
+	s32 err = 0;
 
 	/* Reschedule the timer */
 	mod_timer(&iscan->timer, jiffies + iscan->timer_ms * HZ / 1000);
@@ -2913,10 +2913,10 @@ static int32 wl_iscan_pending(struct wl_
 	return err;
 }
 
-static int32 wl_iscan_inprogress(struct wl_priv *wl)
+static s32 wl_iscan_inprogress(struct wl_priv *wl)
 {
 	struct wl_iscan_ctrl *iscan = wl->iscan;
-	int32 err = 0;
+	s32 err = 0;
 
 	rtnl_lock();
 	wl_inform_bss(wl);
@@ -2929,10 +2929,10 @@ static int32 wl_iscan_inprogress(struct
 	return err;
 }
 
-static int32 wl_iscan_aborted(struct wl_priv *wl)
+static s32 wl_iscan_aborted(struct wl_priv *wl)
 {
 	struct wl_iscan_ctrl *iscan = wl->iscan;
-	int32 err = 0;
+	s32 err = 0;
 
 	iscan->state = WL_ISCAN_STATE_IDLE;
 	rtnl_lock();
@@ -2942,7 +2942,7 @@ static int32 wl_iscan_aborted(struct wl_
 	return err;
 }
 
-static int32 wl_iscan_thread(void *data)
+static s32 wl_iscan_thread(void *data)
 {
 	struct sched_param param = {.sched_priority = MAX_RT_PRIO - 1 };
 	struct wl_iscan_ctrl *iscan = (struct wl_iscan_ctrl *)data;
@@ -2987,7 +2987,7 @@ static void wl_iscan_timer(unsigned long
 	}
 }
 
-static int32 wl_invoke_iscan(struct wl_priv *wl)
+static s32 wl_invoke_iscan(struct wl_priv *wl)
 {
 	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
 	int err = 0;
@@ -3016,7 +3016,7 @@ static void wl_init_iscan_eloop(struct w
 	el->handler[WL_SCAN_RESULTS_NO_MEM] = wl_iscan_aborted;
 }
 
-static int32 wl_init_iscan(struct wl_priv *wl)
+static s32 wl_init_iscan(struct wl_priv *wl)
 {
 	struct wl_iscan_ctrl *iscan = wl_to_iscan(wl);
 	int err = 0;
@@ -3048,10 +3048,10 @@ static void wl_init_fw(struct wl_fw_ctrl
 				 0 means nothing was loaded yet */
 }
 
-static int32 wl_init_priv(struct wl_priv *wl)
+static s32 wl_init_priv(struct wl_priv *wl)
 {
 	struct wiphy *wiphy = wl_to_wiphy(wl);
-	int32 err = 0;
+	s32 err = 0;
 
 	wl->scan_request = NULL;
 	wl->pwr_save = !!(wiphy->flags & WIPHY_FLAG_PS_ON_BY_DEFAULT);
@@ -3101,12 +3101,12 @@ static void wl_deinit_priv(struct wl_pri
 	wl_deinit_priv_mem(wl);
 }
 
-int32 wl_cfg80211_attach(struct net_device *ndev, void *data)
+s32 wl_cfg80211_attach(struct net_device *ndev, void *data)
 {
 	struct wireless_dev *wdev;
 	struct wl_priv *wl;
 	struct wl_iface *ci;
-	int32 err = 0;
+	s32 err = 0;
 
 	if (unlikely(!ndev)) {
 		WL_ERR(("ndev is invaild\n"));
@@ -3164,7 +3164,7 @@ static void wl_wakeup_event(struct wl_pr
 	up(&wl->event_sync);
 }
 
-static int32 wl_event_handler(void *data)
+static s32 wl_event_handler(void *data)
 {
 	struct wl_priv *wl = (struct wl_priv *)data;
 	struct sched_param param = {.sched_priority = MAX_RT_PRIO - 1 };
@@ -3244,12 +3244,12 @@ static struct wl_event_q *wl_deq_event(s
 ** push event to tail of the queue
 */
 
-static int32
+static s32
 wl_enq_event(struct wl_priv *wl, u32 event, const wl_event_msg_t *msg,
 	     void *data)
 {
 	struct wl_event_q *e;
-	int32 err = 0;
+	s32 err = 0;
 
 	e = kzalloc(sizeof(struct wl_event_q), GFP_KERNEL);
 	if (unlikely(!e)) {
@@ -3288,11 +3288,11 @@ struct sdio_func *wl_cfg80211_get_sdio_f
 	return cfg80211_sdio_func;
 }
 
-static int32 wl_dongle_mode(struct net_device *ndev, int32 iftype)
+static s32 wl_dongle_mode(struct net_device *ndev, s32 iftype)
 {
-	int32 infra = 0;
-	int32 ap = 0;
-	int32 err = 0;
+	s32 infra = 0;
+	s32 ap = 0;
+	s32 err = 0;
 
 	switch (iftype) {
 	case NL80211_IFTYPE_MONITOR:
@@ -3329,17 +3329,17 @@ static int32 wl_dongle_mode(struct net_d
 }
 
 #ifndef EMBEDDED_PLATFORM
-static int32 wl_dongle_country(struct net_device *ndev, u8 ccode)
+static s32 wl_dongle_country(struct net_device *ndev, u8 ccode)
 {
 
-	int32 err = 0;
+	s32 err = 0;
 
 	return err;
 }
 
-static int32 wl_dongle_up(struct net_device *ndev, u32 up)
+static s32 wl_dongle_up(struct net_device *ndev, u32 up)
 {
-	int32 err = 0;
+	s32 err = 0;
 
 	err = wl_dev_ioctl(ndev, WLC_UP, &up, sizeof(up));
 	if (unlikely(err)) {
@@ -3348,9 +3348,9 @@ static int32 wl_dongle_up(struct net_dev
 	return err;
 }
 
-static int32 wl_dongle_power(struct net_device *ndev, u32 power_mode)
+static s32 wl_dongle_power(struct net_device *ndev, u32 power_mode)
 {
-	int32 err = 0;
+	s32 err = 0;
 
 	err = wl_dev_ioctl(ndev, WLC_SET_PM, &power_mode, sizeof(power_mode));
 	if (unlikely(err)) {
@@ -3359,12 +3359,12 @@ static int32 wl_dongle_power(struct net_
 	return err;
 }
 
-static int32
+static s32
 wl_dongle_glom(struct net_device *ndev, u32 glom, u32 dongle_align)
 {
 	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 						 '\0' + bitvec  */
-	int32 err = 0;
+	s32 err = 0;
 
 	/* Match Host and Dongle rx alignment */
 	bcm_mkiovar("bus:txglomalign", (char *)&dongle_align, 4, iovbuf,
@@ -3385,12 +3385,12 @@ dongle_glom_out:
 	return err;
 }
 
-static int32
+static s32
 wl_dongle_roam(struct net_device *ndev, u32 roamvar, u32 bcn_timeout)
 {
 	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 						 '\0' + bitvec  */
-	int32 err = 0;
+	s32 err = 0;
 
 	/* Setup timeout if Beacons are lost and roam is
 		 off to report link down */
@@ -3415,13 +3415,13 @@ dongle_rom_out:
 	return err;
 }
 
-static int32 wl_dongle_eventmsg(struct net_device *ndev)
+static s32 wl_dongle_eventmsg(struct net_device *ndev)
 {
 
 	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 						 '\0' + bitvec  */
 	s8 eventmask[WL_EVENTING_MASK_LEN];
-	int32 err = 0;
+	s32 err = 0;
 
 	/* Setup event_msgs */
 	bcm_mkiovar("event_msgs", eventmask, WL_EVENTING_MASK_LEN, iovbuf,
@@ -3464,11 +3464,11 @@ dongle_eventmsg_out:
 	return err;
 }
 
-static int32
-wl_dongle_scantime(struct net_device *ndev, int32 scan_assoc_time,
-		   int32 scan_unassoc_time)
+static s32
+wl_dongle_scantime(struct net_device *ndev, s32 scan_assoc_time,
+		   s32 scan_unassoc_time)
 {
-	int32 err = 0;
+	s32 err = 0;
 
 	err = wl_dev_ioctl(ndev, WLC_SET_SCAN_CHANNEL_TIME, &scan_assoc_time,
 			sizeof(scan_assoc_time));
@@ -3495,12 +3495,12 @@ dongle_scantime_out:
 	return err;
 }
 
-static int32
-wl_dongle_offload(struct net_device *ndev, int32 arpoe, int32 arp_ol)
+static s32
+wl_dongle_offload(struct net_device *ndev, s32 arpoe, s32 arp_ol)
 {
 	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 							 '\0' + bitvec  */
-	int32 err = 0;
+	s32 err = 0;
 
 	/* Set ARP offload */
 	bcm_mkiovar("arpoe", (char *)&arpoe, 4, iovbuf, sizeof(iovbuf));
@@ -3528,7 +3528,7 @@ dongle_offload_out:
 	return err;
 }
 
-static int32 wl_pattern_atoh(s8 *src, s8 *dst)
+static s32 wl_pattern_atoh(s8 *src, s8 *dst)
 {
 #define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))
 	int i;
@@ -3551,19 +3551,19 @@ static int32 wl_pattern_atoh(s8 *src, s8
 	return i;
 }
 
-static int32 wl_dongle_filter(struct net_device *ndev, u32 filter_mode)
+static s32 wl_dongle_filter(struct net_device *ndev, u32 filter_mode)
 {
 	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 							 '\0' + bitvec  */
 	const s8 *str;
 	struct wl_pkt_filter pkt_filter;
 	struct wl_pkt_filter *pkt_filterp;
-	int32 buf_len;
-	int32 str_len;
+	s32 buf_len;
+	s32 str_len;
 	u32 mask_size;
 	u32 pattern_size;
 	s8 buf[256];
-	int32 err = 0;
+	s32 err = 0;
 
 /* add a default packet filter pattern */
 	str = "pkt_filter_add";
@@ -3642,14 +3642,14 @@ dongle_filter_out:
 }
 #endif				/* !EMBEDDED_PLATFORM */
 
-int32 wl_config_dongle(struct wl_priv *wl, bool need_lock)
+s32 wl_config_dongle(struct wl_priv *wl, bool need_lock)
 {
 #ifndef DHD_SDALIGN
 #define DHD_SDALIGN	32
 #endif
 	struct net_device *ndev;
 	struct wireless_dev *wdev;
-	int32 err = 0;
+	s32 err = 0;
 
 	if (wl->dongle_up)
 		return err;
@@ -3703,12 +3703,12 @@ default_conf_out:
 
 }
 
-static int32 wl_update_wiphybands(struct wl_priv *wl)
+static s32 wl_update_wiphybands(struct wl_priv *wl)
 {
 	struct wiphy *wiphy;
-	int32 phy_list;
+	s32 phy_list;
 	s8 phy;
-	int32 err = 0;
+	s32 err = 0;
 
 	err = wl_dev_ioctl(wl_to_ndev(wl), WLC_GET_PHYLIST, &phy_list,
 			sizeof(phy_list));
@@ -3727,9 +3727,9 @@ static int32 wl_update_wiphybands(struct
 	return err;
 }
 
-static int32 __wl_cfg80211_up(struct wl_priv *wl)
+static s32 __wl_cfg80211_up(struct wl_priv *wl)
 {
-	int32 err = 0;
+	s32 err = 0;
 
 	err = wl_config_dongle(wl, FALSE);
 	if (unlikely(err))
@@ -3740,9 +3740,9 @@ static int32 __wl_cfg80211_up(struct wl_
 	return err;
 }
 
-static int32 __wl_cfg80211_down(struct wl_priv *wl)
+static s32 __wl_cfg80211_down(struct wl_priv *wl)
 {
-	int32 err = 0;
+	s32 err = 0;
 
 	/* Check if cfg80211 interface is already down */
 	if (!test_bit(WL_STATUS_READY, &wl->status))
@@ -3763,10 +3763,10 @@ static int32 __wl_cfg80211_down(struct w
 	return err;
 }
 
-int32 wl_cfg80211_up(void)
+s32 wl_cfg80211_up(void)
 {
 	struct wl_priv *wl;
-	int32 err = 0;
+	s32 err = 0;
 
 	wl = WL_PRIV_GET();
 	mutex_lock(&wl->usr_sync);
@@ -3776,10 +3776,10 @@ int32 wl_cfg80211_up(void)
 	return err;
 }
 
-int32 wl_cfg80211_down(void)
+s32 wl_cfg80211_down(void)
 {
 	struct wl_priv *wl;
-	int32 err = 0;
+	s32 err = 0;
 
 	wl = WL_PRIV_GET();
 	mutex_lock(&wl->usr_sync);
@@ -3789,9 +3789,9 @@ int32 wl_cfg80211_down(void)
 	return err;
 }
 
-static int32 wl_dongle_probecap(struct wl_priv *wl)
+static s32 wl_dongle_probecap(struct wl_priv *wl)
 {
-	int32 err = 0;
+	s32 err = 0;
 
 	err = wl_update_wiphybands(wl);
 	if (unlikely(err))
@@ -3800,7 +3800,7 @@ static int32 wl_dongle_probecap(struct w
 	return err;
 }
 
-static void *wl_read_prof(struct wl_priv *wl, int32 item)
+static void *wl_read_prof(struct wl_priv *wl, s32 item)
 {
 	switch (item) {
 	case WL_PROF_SEC:
@@ -3816,11 +3816,11 @@ static void *wl_read_prof(struct wl_priv
 	return NULL;
 }
 
-static int32
+static s32
 wl_update_prof(struct wl_priv *wl, const wl_event_msg_t *e, void *data,
-	       int32 item)
+	       s32 item)
 {
-	int32 err = 0;
+	s32 err = 0;
 	struct wlc_ssid *ssid;
 
 	switch (item) {
@@ -3880,10 +3880,10 @@ static void wl_rst_ie(struct wl_priv *wl
 	ie->offset = 0;
 }
 
-static int32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v)
+static s32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v)
 {
 	struct wl_ie *ie = wl_to_ie(wl);
-	int32 err = 0;
+	s32 err = 0;
 
 	if (unlikely(ie->offset + l + 2 > WL_TLV_INFO_MAX)) {
 		WL_ERR(("ei crosses buffer boundary\n"));
@@ -3897,10 +3897,10 @@ static int32 wl_add_ie(struct wl_priv *w
 	return err;
 }
 
-static int32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, u16 ie_size)
+static s32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, u16 ie_size)
 {
 	struct wl_ie *ie = wl_to_ie(wl);
-	int32 err = 0;
+	s32 err = 0;
 
 	if (unlikely(ie->offset + ie_size > WL_TLV_INFO_MAX)) {
 		WL_ERR(("ei_stream crosses buffer boundary\n"));
@@ -3912,10 +3912,10 @@ static int32 wl_mrg_ie(struct wl_priv *w
 	return err;
 }
 
-static int32 wl_cp_ie(struct wl_priv *wl, u8 *dst, u16 dst_size)
+static s32 wl_cp_ie(struct wl_priv *wl, u8 *dst, u16 dst_size)
 {
 	struct wl_ie *ie = wl_to_ie(wl);
-	int32 err = 0;
+	s32 err = 0;
 
 	if (unlikely(ie->offset > dst_size)) {
 		WL_ERR(("dst_size is not enough\n"));
@@ -3986,7 +3986,7 @@ static void *wl_get_drvdata(struct wl_de
 	return dev->driver_data;
 }
 
-int32 wl_cfg80211_read_fw(s8 *buf, u32 size)
+s32 wl_cfg80211_read_fw(s8 *buf, u32 size)
 {
 	const struct firmware *fw_entry;
 	struct wl_priv *wl;
@@ -4016,7 +4016,7 @@ void *wl_cfg80211_request_fw(s8 *file_na
 {
 	struct wl_priv *wl;
 	const struct firmware *fw_entry = NULL;
-	int32 err = 0;
+	s32 err = 0;
 
 	WL_DBG(("file name : \"%s\"\n", file_name));
 	wl = WL_PRIV_GET();
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
@@ -158,13 +158,13 @@ struct wl_conf {
 	u32 rts_threshold;
 	u32 retry_short;
 	u32 retry_long;
-	int32 tx_power;
+	s32 tx_power;
 	struct ieee80211_channel channel;
 };
 
 /* cfg80211 main event loop */
 struct wl_event_loop {
-	int32(*handler[WLC_E_LAST]) (struct wl_priv *wl,
+	s32(*handler[WLC_E_LAST]) (struct wl_priv *wl,
 				     struct net_device *ndev,
 				     const wl_event_msg_t *e, void *data);
 };
@@ -231,13 +231,13 @@ struct wl_profile {
 	u8 bssid[ETHER_ADDR_LEN];
 	struct wl_security sec;
 	struct wl_ibss ibss;
-	int32 band;
+	s32 band;
 	bool active;
 };
 
 /* dongle iscan event loop */
 struct wl_iscan_eloop {
-	int32(*handler[WL_SCAN_ERSULTS_LAST]) (struct wl_priv *wl);
+	s32(*handler[WL_SCAN_ERSULTS_LAST]) (struct wl_priv *wl);
 };
 
 /* dongle iscan controller */
@@ -246,8 +246,8 @@ struct wl_iscan_ctrl {
 	struct timer_list timer;
 	u32 timer_ms;
 	u32 timer_on;
-	int32 state;
-	int32 pid;
+	s32 state;
+	s32 pid;
 	struct semaphore sync;
 	struct completion exited;
 	struct wl_iscan_eloop el;
@@ -259,9 +259,9 @@ struct wl_iscan_ctrl {
 /* association inform */
 struct wl_connect_info {
 	u8 *req_ie;
-	int32 req_ie_len;
+	s32 req_ie_len;
 	u8 *resp_ie;
-	int32 resp_ie_len;
+	s32 resp_ie_len;
 };
 
 /* firmware /nvram downloading controller */
@@ -315,7 +315,7 @@ struct wl_priv {
 	struct wl_fw_ctrl *fw;	/* control firwmare / nvram paramter
 				 downloading */
 	struct wl_pmk_list *pmk_list;	/* wpa2 pmk list */
-	int32 event_pid;	/* pid of main event handler thread */
+	s32 event_pid;	/* pid of main event handler thread */
 	unsigned long status;		/* current dongle status */
 	void *pub;
 	u32 channel;		/* current channel */
@@ -360,20 +360,20 @@ static inline struct wl_bss_info *next_b
 #define for_each_bss(list, bss, __i)	\
 	for (__i = 0; __i < list->count && __i < WL_AP_MAX; __i++, bss = next_bss(list, bss))
 
-extern int32 wl_cfg80211_attach(struct net_device *ndev, void *data);
+extern s32 wl_cfg80211_attach(struct net_device *ndev, void *data);
 extern void wl_cfg80211_detach(void);
 /* event handler from dongle */
 extern void wl_cfg80211_event(struct net_device *ndev, const wl_event_msg_t *e,
 			      void *data);
 extern void wl_cfg80211_sdio_func(void *func);	/* set sdio function info */
 extern struct sdio_func *wl_cfg80211_get_sdio_func(void);	/* set sdio function info */
-extern int32 wl_cfg80211_up(void);	/* dongle up */
-extern int32 wl_cfg80211_down(void);	/* dongle down */
+extern s32 wl_cfg80211_up(void);	/* dongle up */
+extern s32 wl_cfg80211_down(void);	/* dongle down */
 extern void wl_cfg80211_dbg_level(u32 level);	/* set dongle
 							 debugging level */
 extern void *wl_cfg80211_request_fw(s8 *file_name);	/* request fw /nvram
 							 downloading */
-extern int32 wl_cfg80211_read_fw(s8 *buf, u32 size);	/* read fw
+extern s32 wl_cfg80211_read_fw(s8 *buf, u32 size);	/* read fw
 								 image */
 extern void wl_cfg80211_release_fw(void);	/* release fw */
 extern s8 *wl_cfg80211_get_fwname(void);	/* get firmware name for
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -2222,7 +2222,7 @@ wl_iw_get_txpow(struct net_device *dev,
 
 	disable = dtoh32(disable);
 	result = (u8) (txpwrdbm & ~WL_TXPWR_OVERRIDE);
-	vwrq->value = (int32) bcm_qdbm_to_mw(result);
+	vwrq->value = (s32) bcm_qdbm_to_mw(result);
 	vwrq->fixed = 0;
 	vwrq->disabled =
 	    (disable & (WL_RADIO_SW_DISABLE | WL_RADIO_HW_DISABLE)) ? 1 : 0;
--- a/drivers/staging/brcm80211/include/bcm_xdr.h
+++ b/drivers/staging/brcm80211/include/bcm_xdr.h
@@ -35,8 +35,8 @@ void bcm_xdr_buf_init(bcm_xdr_buf_t *b,
 
 int bcm_xdr_pack_u32(bcm_xdr_buf_t *b, u32 val);
 int bcm_xdr_unpack_u32(bcm_xdr_buf_t *b, u32 *pval);
-int bcm_xdr_pack_int32(bcm_xdr_buf_t *b, int32 val);
-int bcm_xdr_unpack_int32(bcm_xdr_buf_t *b, int32 *pval);
+int bcm_xdr_pack_s32(bcm_xdr_buf_t *b, s32 val);
+int bcm_xdr_unpack_s32(bcm_xdr_buf_t *b, s32 *pval);
 int bcm_xdr_pack_s8(bcm_xdr_buf_t *b, s8 val);
 int bcm_xdr_unpack_s8(bcm_xdr_buf_t *b, s8 *pval);
 int bcm_xdr_pack_opaque(bcm_xdr_buf_t *b, uint len, void *data);
--- a/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
+++ b/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
@@ -94,8 +94,8 @@ extern void sdioh_sdmmc_devintr_off(sdio
  */
 
 /* Register mapping routines */
-extern u32 *sdioh_sdmmc_reg_map(osl_t *osh, int32 addr, int size);
-extern void sdioh_sdmmc_reg_unmap(osl_t *osh, int32 addr, int size);
+extern u32 *sdioh_sdmmc_reg_map(osl_t *osh, s32 addr, int size);
+extern void sdioh_sdmmc_reg_unmap(osl_t *osh, s32 addr, int size);
 
 /* Interrupt (de)registration routines */
 extern int sdioh_sdmmc_register_irq(sdioh_info_t *sd, uint irq);
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -326,7 +326,7 @@ extern "C" {
 	"u8", \
 	"s16", \
 	"u16", \
-	"int32", \
+	"s32", \
 	"u32", \
 	"buffer", \
 	"" }
--- a/drivers/staging/brcm80211/include/qmath.h
+++ b/drivers/staging/brcm80211/include/qmath.h
@@ -19,31 +19,31 @@
 
 #include <typedefs.h>
 
-s16 qm_sat32(int32 op);
+s16 qm_sat32(s32 op);
 
-int32 qm_mul321616(s16 op1, s16 op2);
+s32 qm_mul321616(s16 op1, s16 op2);
 
 s16 qm_mul16(s16 op1, s16 op2);
 
-int32 qm_muls321616(s16 op1, s16 op2);
+s32 qm_muls321616(s16 op1, s16 op2);
 
 u16 qm_mulu16(u16 op1, u16 op2);
 
 s16 qm_muls16(s16 op1, s16 op2);
 
-int32 qm_add32(int32 op1, int32 op2);
+s32 qm_add32(s32 op1, s32 op2);
 
 s16 qm_add16(s16 op1, s16 op2);
 
 s16 qm_sub16(s16 op1, s16 op2);
 
-int32 qm_sub32(int32 op1, int32 op2);
+s32 qm_sub32(s32 op1, s32 op2);
 
-int32 qm_mac321616(int32 acc, s16 op1, s16 op2);
+s32 qm_mac321616(s32 acc, s16 op1, s16 op2);
 
-int32 qm_shl32(int32 op, int shift);
+s32 qm_shl32(s32 op, int shift);
 
-int32 qm_shr32(int32 op, int shift);
+s32 qm_shr32(s32 op, int shift);
 
 s16 qm_shl16(s16 op, int shift);
 
@@ -51,7 +51,7 @@ s16 qm_shr16(s16 op, int shift);
 
 s16 qm_norm16(s16 op);
 
-s16 qm_norm32(int32 op);
+s16 qm_norm32(s32 op);
 
 s16 qm_div_s(s16 num, s16 denom);
 
@@ -59,22 +59,22 @@ s16 qm_abs16(s16 op);
 
 s16 qm_div16(s16 num, s16 denom, s16 *qQuotient);
 
-int32 qm_abs32(int32 op);
+s32 qm_abs32(s32 op);
 
-s16 qm_div163232(int32 num, int32 denom, s16 *qquotient);
+s16 qm_div163232(s32 num, s32 denom, s16 *qquotient);
 
-int32 qm_mul323216(int32 op1, s16 op2);
+s32 qm_mul323216(s32 op1, s16 op2);
 
-int32 qm_mulsu321616(s16 op1, u16 op2);
+s32 qm_mulsu321616(s16 op1, u16 op2);
 
-int32 qm_muls323216(int32 op1, s16 op2);
+s32 qm_muls323216(s32 op1, s16 op2);
 
-int32 qm_mul32(int32 a, int32 b);
+s32 qm_mul32(s32 a, s32 b);
 
-int32 qm_muls32(int32 a, int32 b);
+s32 qm_muls32(s32 a, s32 b);
 
-void qm_log10(int32 N, s16 qN, s16 *log10N, s16 *qLog10N);
+void qm_log10(s32 N, s16 qN, s16 *log10N, s16 *qLog10N);
 
-void qm_1byN(int32 N, s16 qN, int32 *result, s16 *qResult);
+void qm_1byN(s32 N, s16 qN, s32 *result, s16 *qResult);
 
 #endif				/* #ifndef __QMATH_H__ */
--- a/drivers/staging/brcm80211/include/typedefs.h
+++ b/drivers/staging/brcm80211/include/typedefs.h
@@ -42,16 +42,10 @@ typedef unsigned long long int uintptr;
 typedef unsigned int uint;
 #endif
 
-/* define [u]int32/64, uintptr */
-
 #ifndef TYPEDEF_UINTPTR
 typedef unsigned int uintptr;
 #endif
 
-#ifndef TYPEDEF_INT32
-typedef signed int int32;
-#endif
-
 /* define macro values */
 
 #ifndef FALSE
@@ -74,7 +68,6 @@ typedef signed int int32;
 
 #undef TYPEDEF_UINT
 #undef TYPEDEF_UINTPTR
-#undef TYPEDEF_INT32
 
 /*
  * Including the bcmdefs.h here, to make sure everyone including typedefs.h
--- a/drivers/staging/brcm80211/include/wlioctl.h
+++ b/drivers/staging/brcm80211/include/wlioctl.h
@@ -183,7 +183,7 @@ typedef struct wl_extdscan_params {
 	wlc_ssid_t ssid[WLC_EXTDSCAN_MAX_SSID];	/* ssid list */
 	u32 tx_rate;		/* in 500ksec units */
 	wl_scan_type_t scan_type;	/* enum */
-	int32 channel_num;
+	s32 channel_num;
 	chan_scandata_t channel_list[1];	/* list of chandata structs */
 } wl_extdscan_params_t;
 
@@ -205,23 +205,23 @@ typedef struct wl_scan_params {
 				 * DOT11_BSSTYPE_ANY/INFRASTRUCTURE/INDEPENDENT
 				 */
 	u8 scan_type;	/* flags, 0 use default */
-	int32 nprobes;		/* -1 use default, number of probes per channel */
-	int32 active_time;	/* -1 use default, dwell time per channel for
+	s32 nprobes;		/* -1 use default, number of probes per channel */
+	s32 active_time;	/* -1 use default, dwell time per channel for
 				 * active scanning
 				 */
-	int32 passive_time;	/* -1 use default, dwell time per channel
+	s32 passive_time;	/* -1 use default, dwell time per channel
 				 * for passive scanning
 				 */
-	int32 home_time;	/* -1 use default, dwell time for the home channel
+	s32 home_time;	/* -1 use default, dwell time for the home channel
 				 * between channel scans
 				 */
-	int32 channel_num;	/* count of channels and ssids that follow
+	s32 channel_num;	/* count of channels and ssids that follow
 				 *
 				 * low half is count of channels in channel_list, 0
 				 * means default (use all available channels)
 				 *
 				 * high half is entries in wlc_ssid_t array that
-				 * follows channel_list, aligned for int32 (4 bytes)
+				 * follows channel_list, aligned for s32 (4 bytes)
 				 * meaning an odd channel count implies a 2-byte pad
 				 * between end of channel_list and first ssid
 				 *
@@ -333,7 +333,7 @@ typedef struct wl_u32_list {
 /* used for association with a specific BSSID and chanspec list */
 typedef struct wl_assoc_params {
 	struct ether_addr bssid;	/* 00:00:00:00:00:00: broadcast scan */
-	int32 chanspec_num;	/* 0: all available channels,
+	s32 chanspec_num;	/* 0: all available channels,
 				 * otherwise count of chanspecs in chanspec_list
 				 */
 	chanspec_t chanspec_list[1];	/* list of chanspecs */
@@ -435,7 +435,7 @@ typedef struct wl_country {
 	char country_abbrev[WLC_CNTRY_BUF_SZ];	/* nul-terminated country code used in
 						 * the Country IE
 						 */
-	int32 rev;		/* revision specifier for ccode
+	s32 rev;		/* revision specifier for ccode
 				 * on set, -1 indicates unspecified.
 				 * on get, rev >= 0
 				 */
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -1782,8 +1782,8 @@ wlc_phy_txpower_sromlimit_max_get(wlc_ph
 }
 
 void
-wlc_phy_txpower_boardlimit_band(wlc_phy_t *ppi, uint bandunit, int32 *max_pwr,
-				int32 *min_pwr, u32 *step_pwr)
+wlc_phy_txpower_boardlimit_band(wlc_phy_t *ppi, uint bandunit, s32 *max_pwr,
+				s32 *min_pwr, u32 *step_pwr)
 {
 	return;
 }
@@ -2748,7 +2748,7 @@ void wlc_phy_noise_sample_intr(wlc_phy_t
 	if (ISLCNPHY(pi)) {
 		u32 cmplx_pwr, cmplx_pwr0, cmplx_pwr1;
 		u16 lo, hi;
-		int32 pwr_offset_dB, gain_dB;
+		s32 pwr_offset_dB, gain_dB;
 		u16 status_0, status_1;
 
 		jssi_aux = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);
@@ -3021,7 +3021,7 @@ void wlc_phy_BSSinit(wlc_phy_t *pih, boo
 }
 
 void
-wlc_phy_papd_decode_epsilon(u32 epsilon, int32 *eps_real, int32 *eps_imag)
+wlc_phy_papd_decode_epsilon(u32 epsilon, s32 *eps_real, s32 *eps_imag)
 {
 	*eps_imag = (epsilon >> 13);
 	if (*eps_imag > 0xfff)
@@ -3053,7 +3053,7 @@ static const fixed AtanTbl[] = {
 	29
 };
 
-void wlc_phy_cordic(fixed theta, cint32 *val)
+void wlc_phy_cordic(fixed theta, cs32 *val)
 {
 	fixed angle, valtmp;
 	unsigned iter;
@@ -3207,9 +3207,9 @@ void wlc_phy_cal_perical_mphase_restart(
 	pi->mphase_txcal_cmdidx = 0;
 }
 
-u8 wlc_phy_nbits(int32 value)
+u8 wlc_phy_nbits(s32 value)
 {
-	int32 abs_val;
+	s32 abs_val;
 	u8 nbits = 0;
 
 	abs_val = ABS(value);
--- a/drivers/staging/brcm80211/phy/wlc_phy_hal.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_hal.h
@@ -204,8 +204,8 @@ extern void wlc_phy_txpower_sromlimit(wl
 				      u8 *_min_, u8 *_max_, int rate);
 extern void wlc_phy_txpower_sromlimit_max_get(wlc_phy_t *ppi, uint chan,
 					      u8 *_max_, u8 *_min_);
-extern void wlc_phy_txpower_boardlimit_band(wlc_phy_t *ppi, uint band, int32 *,
-					    int32 *, u32 *);
+extern void wlc_phy_txpower_boardlimit_band(wlc_phy_t *ppi, uint band, s32 *,
+					    s32 *, u32 *);
 extern void wlc_phy_txpower_limit_set(wlc_phy_t *ppi, struct txpwr_limits *,
 				      chanspec_t chanspec);
 extern int wlc_phy_txpower_get(wlc_phy_t *ppi, uint *qdbm, bool *override);
--- a/drivers/staging/brcm80211/phy/wlc_phy_int.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_int.h
@@ -51,7 +51,7 @@ typedef void (*txiqccsetfn_t) (phy_info_
 typedef u16(*txloccgetfn_t) (phy_info_t *);
 typedef void (*radioloftgetfn_t) (phy_info_t *, u8 *, u8 *, u8 *,
 				  u8 *);
-typedef int32(*rxsigpwrfn_t) (phy_info_t *, int32);
+typedef s32(*rxsigpwrfn_t) (phy_info_t *, s32);
 typedef void (*detachfn_t) (phy_info_t *);
 
 #undef ISNPHY
@@ -241,7 +241,7 @@ typedef enum {
 
 #define CORDIC_AG	39797
 #define	CORDIC_NI	18
-#define	FIXED(X)	((int32)((X) << 16))
+#define	FIXED(X)	((s32)((X) << 16))
 #define	FLOAT(X)	(((X) >= 0) ? ((((X) >> 15) + 1) >> 1) : -((((-(X)) >> 15) + 1) >> 1))
 
 #define PHY_CHAIN_TX_DISABLE_TEMP	115
@@ -939,12 +939,12 @@ struct phy_info {
 	u32 mcs40_po;
 };
 
-typedef int32 fixed;
+typedef s32 fixed;
 
-typedef struct _cint32 {
+typedef struct _cs32 {
 	fixed q;
 	fixed i;
-} cint32;
+} cs32;
 
 typedef struct radio_regs {
 	u16 address;
@@ -1023,8 +1023,8 @@ extern void wlc_phy_table_data_write(phy
 extern void write_phy_channel_reg(phy_info_t *pi, uint val);
 extern void wlc_phy_txpower_update_shm(phy_info_t *pi);
 
-extern void wlc_phy_cordic(fixed theta, cint32 *val);
-extern u8 wlc_phy_nbits(int32 value);
+extern void wlc_phy_cordic(fixed theta, cs32 *val);
+extern u8 wlc_phy_nbits(s32 value);
 extern u32 wlc_phy_sqrt_int(u32 value);
 extern void wlc_phy_compute_dB(u32 *cmplx_pwr, s8 *p_dB, u8 core);
 
@@ -1036,8 +1036,8 @@ extern uint wlc_phy_init_radio_regs(phy_
 extern void wlc_phy_txpower_ipa_upd(phy_info_t *pi);
 
 extern void wlc_phy_do_dummy_tx(phy_info_t *pi, bool ofdm, bool pa_on);
-extern void wlc_phy_papd_decode_epsilon(u32 epsilon, int32 *eps_real,
-					int32 *eps_imag);
+extern void wlc_phy_papd_decode_epsilon(u32 epsilon, s32 *eps_real,
+					s32 *eps_imag);
 
 extern void wlc_phy_cal_perical_mphase_reset(phy_info_t *pi);
 extern void wlc_phy_cal_perical_mphase_restart(phy_info_t *pi);
@@ -1071,7 +1071,7 @@ extern void wlc_phy_txpower_recalc_targe
 extern void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t *pi, int index);
 extern void wlc_lcnphy_tx_pu(phy_info_t *pi, bool bEnable);
 extern void wlc_lcnphy_stop_tx_tone(phy_info_t *pi);
-extern void wlc_lcnphy_start_tx_tone(phy_info_t *pi, int32 f_kHz,
+extern void wlc_lcnphy_start_tx_tone(phy_info_t *pi, s32 f_kHz,
 				     u16 max_val, bool iqcalmode);
 
 extern void wlc_phy_txpower_sromlimit_get_nphy(phy_info_t *pi, uint chan,
@@ -1121,18 +1121,18 @@ extern void wlc_lcnphy_calib_modes(phy_i
 extern void wlc_lcnphy_deaf_mode(phy_info_t *pi, bool mode);
 extern bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t *pi);
 extern void wlc_lcnphy_tx_pwr_update_npt(phy_info_t *pi);
-extern int32 wlc_lcnphy_tssi2dbm(int32 tssi, int32 a1, int32 b0, int32 b1);
+extern s32 wlc_lcnphy_tssi2dbm(s32 tssi, s32 a1, s32 b0, s32 b1);
 extern void wlc_lcnphy_get_tssi(phy_info_t *pi, s8 *ofdm_pwr,
 				s8 *cck_pwr);
 extern void wlc_lcnphy_tx_power_adjustment(wlc_phy_t *ppi);
 
-extern int32 wlc_lcnphy_rx_signal_power(phy_info_t *pi, int32 gain_index);
+extern s32 wlc_lcnphy_rx_signal_power(phy_info_t *pi, s32 gain_index);
 
 #define NPHY_MAX_HPVGA1_INDEX		10
 #define NPHY_DEF_HPVGA1_INDEXLIMIT	7
 
 typedef struct _phy_iq_est {
-	int32 iq_prod;
+	s32 iq_prod;
 	u32 i_pwr;
 	u32 q_pwr;
 } phy_iq_est_t;
@@ -1201,15 +1201,15 @@ extern void wlc_phy_txpwr_index_nphy(phy
 				     s8 txpwrindex, bool res);
 extern void wlc_phy_rssisel_nphy(phy_info_t *pi, u8 core, u8 rssi_type);
 extern int wlc_phy_poll_rssi_nphy(phy_info_t *pi, u8 rssi_type,
-				  int32 *rssi_buf, u8 nsamps);
+				  s32 *rssi_buf, u8 nsamps);
 extern void wlc_phy_rssi_cal_nphy(phy_info_t *pi);
 extern int wlc_phy_aci_scan_nphy(phy_info_t *pi);
-extern void wlc_phy_cal_txgainctrl_nphy(phy_info_t *pi, int32 dBm_targetpower,
+extern void wlc_phy_cal_txgainctrl_nphy(phy_info_t *pi, s32 dBm_targetpower,
 					bool debug);
 extern int wlc_phy_tx_tone_nphy(phy_info_t *pi, u32 f_kHz, u16 max_val,
 				u8 mode, u8, bool);
 extern void wlc_phy_stopplayback_nphy(phy_info_t *pi);
-extern void wlc_phy_est_tonepwr_nphy(phy_info_t *pi, int32 *qdBm_pwrbuf,
+extern void wlc_phy_est_tonepwr_nphy(phy_info_t *pi, s32 *qdBm_pwrbuf,
 				     u8 num_samps);
 extern void wlc_phy_radio205x_vcocal_nphy(phy_info_t *pi);
 
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -1591,9 +1591,9 @@ void wlc_lcnphy_tx_pwr_update_npt(phy_in
 	}
 }
 
-int32 wlc_lcnphy_tssi2dbm(int32 tssi, int32 a1, int32 b0, int32 b1)
+s32 wlc_lcnphy_tssi2dbm(s32 tssi, s32 a1, s32 b0, s32 b1)
 {
-	int32 a, b, p;
+	s32 a, b, p;
 
 	a = 32768 + (a1 * tssi);
 	b = (1024 * b0) + (64 * b1 * tssi);
@@ -1626,7 +1626,7 @@ void wlc_lcnphy_txpower_recalc_target(ph
 		if (i == WLC_NUM_RATES_CCK + WLC_NUM_RATES_OFDM)
 			j = TXP_FIRST_MCS_20_SISO;
 
-		rate_table[i] = (u32) ((int32) (-pi->tx_power_offset[j]));
+		rate_table[i] = (u32) ((s32) (-pi->tx_power_offset[j]));
 	}
 
 	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
@@ -2295,8 +2295,8 @@ void WLBANDINITFN(wlc_lcnphy_tx_pwr_ctrl
 	lcnphy_txgains_t tx_gains;
 	u8 bbmult;
 	phytbl_info_t tab;
-	int32 a1, b0, b1;
-	int32 tssi, pwr, maxtargetpwr, mintargetpwr;
+	s32 a1, b0, b1;
+	s32 tssi, pwr, maxtargetpwr, mintargetpwr;
 	bool suspend;
 	phy_info_t *pi = (phy_info_t *) ppi;
 
@@ -2729,14 +2729,14 @@ void wlc_lcnphy_deaf_mode(phy_info_t *pi
 }
 
 void
-wlc_lcnphy_start_tx_tone(phy_info_t *pi, int32 f_kHz, u16 max_val,
+wlc_lcnphy_start_tx_tone(phy_info_t *pi, s32 f_kHz, u16 max_val,
 			 bool iqcalmode)
 {
 	u8 phy_bw;
 	u16 num_samps, t, k;
 	u32 bw;
 	fixed theta = 0, rot = 0;
-	cint32 tone_samp;
+	cs32 tone_samp;
 	u32 data_buf[64];
 	u16 i_samp, q_samp;
 	phytbl_info_t tab;
@@ -3023,7 +3023,7 @@ s16 wlc_lcnphy_tempsense_new(phy_info_t
 u16 wlc_lcnphy_tempsense(phy_info_t *pi, bool mode)
 {
 	u16 tempsenseval1, tempsenseval2;
-	int32 avg = 0;
+	s32 avg = 0;
 	bool suspend = 0;
 	u16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -3083,7 +3083,7 @@ u16 wlc_lcnphy_tempsense(phy_info_t *pi,
 
 s8 wlc_lcnphy_tempsense_degree(phy_info_t *pi, bool mode)
 {
-	int32 degree = wlc_lcnphy_tempsense_new(pi, mode);
+	s32 degree = wlc_lcnphy_tempsense_new(pi, mode);
 	degree =
 	    ((degree << 10) + LCN_TEMPSENSE_OFFSET + (LCN_TEMPSENSE_DEN >> 1))
 	    / LCN_TEMPSENSE_DEN;
@@ -3093,7 +3093,7 @@ s8 wlc_lcnphy_tempsense_degree(phy_info_
 s8 wlc_lcnphy_vbatsense(phy_info_t *pi, bool mode)
 {
 	u16 vbatsenseval;
-	int32 avg = 0;
+	s32 avg = 0;
 	bool suspend = 0;
 
 	if (NORADIO_ENAB(pi->pubpi))
@@ -3111,9 +3111,9 @@ s8 wlc_lcnphy_vbatsense(phy_info_t *pi,
 	vbatsenseval = read_phy_reg(pi, 0x475) & 0x1FF;
 
 	if (vbatsenseval > 255)
-		avg = (int32) (vbatsenseval - 512);
+		avg = (s32) (vbatsenseval - 512);
 	else
-		avg = (int32) vbatsenseval;
+		avg = (s32) vbatsenseval;
 
 	avg =
 	    (avg * LCN_VBAT_SCALE_NOM +
@@ -3193,9 +3193,9 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 	bool result;
 	u16 a0_new, b0_new;
 	lcnphy_iq_est_t iq_est = { 0, 0, 0 };
-	int32 a, b, temp;
+	s32 a, b, temp;
 	s16 iq_nbits, qq_nbits, arsh, brsh;
-	int32 iq;
+	s32 iq;
 	u32 ii, qq;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -3211,7 +3211,7 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 	if (!result)
 		goto cleanup;
 
-	iq = (int32) iq_est.iq_prod;
+	iq = (s32) iq_est.iq_prod;
 	ii = iq_est.i_pwr;
 	qq = iq_est.q_pwr;
 
@@ -3226,13 +3226,13 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 	arsh = 10 - (30 - iq_nbits);
 	if (arsh >= 0) {
 		a = (-(iq << (30 - iq_nbits)) + (ii >> (1 + arsh)));
-		temp = (int32) (ii >> arsh);
+		temp = (s32) (ii >> arsh);
 		if (temp == 0) {
 			return FALSE;
 		}
 	} else {
 		a = (-(iq << (30 - iq_nbits)) + (ii << (-1 - arsh)));
-		temp = (int32) (ii << -arsh);
+		temp = (s32) (ii << -arsh);
 		if (temp == 0) {
 			return FALSE;
 		}
@@ -3241,20 +3241,20 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 	brsh = qq_nbits - 31 + 20;
 	if (brsh >= 0) {
 		b = (qq << (31 - qq_nbits));
-		temp = (int32) (ii >> brsh);
+		temp = (s32) (ii >> brsh);
 		if (temp == 0) {
 			return FALSE;
 		}
 	} else {
 		b = (qq << (31 - qq_nbits));
-		temp = (int32) (ii << -brsh);
+		temp = (s32) (ii << -brsh);
 		if (temp == 0) {
 			return FALSE;
 		}
 	}
 	b /= temp;
 	b -= a * a;
-	b = (int32) wlc_phy_sqrt_int((u32) b);
+	b = (s32) wlc_phy_sqrt_int((u32) b);
 	b -= (1 << 10);
 	a0_new = (u16) (a & 0x3ff);
 	b0_new = (u16) (b & 0x3ff);
@@ -3483,8 +3483,8 @@ static void wlc_lcnphy_periodic_cal(phy_
 	u16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	s8 index;
 	phytbl_info_t tab;
-	int32 a1, b0, b1;
-	int32 tssi, pwr, maxtargetpwr, mintargetpwr;
+	s32 a1, b0, b1;
+	s32 tssi, pwr, maxtargetpwr, mintargetpwr;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (NORADIO_ENAB(pi->pubpi))
@@ -4038,7 +4038,7 @@ wlc_lcnphy_a1(phy_info_t *pi, int cal_ty
 	u16 phy_c7, phy_c8, phy_c9;
 	s16 phy_c10, phy_c11, phy_c12, phy_c13, phy_c14, phy_c15, phy_c16;
 	s16 *ptr, phy_c17;
-	int32 phy_c18, phy_c19;
+	s32 phy_c18, phy_c19;
 	u32 phy_c20, phy_c21;
 	bool phy_c22, phy_c23, phy_c24, phy_c25;
 	u16 phy_c26, phy_c27;
@@ -4299,8 +4299,8 @@ static void wlc_lcnphy_load_rfpower(phy_
 		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_GAIN_OFFSET + index;
 		wlc_lcnphy_read_table(pi, &tab);
 
-		qm_log10((int32) (bbmult), 0, &temp1, &qQ1);
-		qm_log10((int32) (1 << 6), 0, &temp2, &qQ2);
+		qm_log10((s32) (bbmult), 0, &temp1, &qQ1);
+		qm_log10((s32) (1 << 6), 0, &temp2, &qQ2);
 
 		if (qQ1 < qQ2) {
 			temp2 = qm_shr16(temp2, qQ2 - qQ1);
@@ -5141,10 +5141,10 @@ static void wlc_lcnphy_set_rx_gain(phy_i
 	wlc_lcnphy_rx_gain_override_enable(pi, TRUE);
 }
 
-static u32 wlc_lcnphy_get_receive_power(phy_info_t *pi, int32 *gain_index)
+static u32 wlc_lcnphy_get_receive_power(phy_info_t *pi, s32 *gain_index)
 {
 	u32 received_power = 0;
-	int32 max_index = 0;
+	s32 max_index = 0;
 	u32 gain_code = 0;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -5154,7 +5154,7 @@ static u32 wlc_lcnphy_get_receive_power(
 
 	if (-1 == *gain_index) {
 		*gain_index = 0;
-		while ((*gain_index <= (int32) max_index)
+		while ((*gain_index <= (s32) max_index)
 		       && (received_power < 700)) {
 			wlc_lcnphy_set_rx_gain(pi,
 					       lcnphy_23bitgaincode_table
@@ -5177,13 +5177,13 @@ static u32 wlc_lcnphy_get_receive_power(
 	return received_power;
 }
 
-int32 wlc_lcnphy_rx_signal_power(phy_info_t *pi, int32 gain_index)
+s32 wlc_lcnphy_rx_signal_power(phy_info_t *pi, s32 gain_index)
 {
-	int32 gain = 0;
-	int32 nominal_power_db;
-	int32 log_val, gain_mismatch, desired_gain, input_power_offset_db,
+	s32 gain = 0;
+	s32 nominal_power_db;
+	s32 log_val, gain_mismatch, desired_gain, input_power_offset_db,
 	    input_power_db;
-	int32 received_power, temperature;
+	s32 received_power, temperature;
 	uint freq;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
@@ -93,7 +93,7 @@ struct phy_info_lcnphy {
 	u8 lcnphy_lowerofdm;
 	u8 lcnphy_cck;
 	u8 lcnphy_psat_2pt3_detected;
-	int32 lcnphy_lowest_Re_div_Im;
+	s32 lcnphy_lowest_Re_div_Im;
 	s8 lcnphy_final_papd_cal_idx;
 	u16 lcnphy_extstxctrl4;
 	u16 lcnphy_extstxctrl0;
@@ -104,7 +104,7 @@ struct phy_info_lcnphy {
 
 	u8 lcnphy_psat_pwr;
 	u8 lcnphy_psat_indx;
-	int32 lcnphy_min_phase;
+	s32 lcnphy_min_phase;
 	u8 lcnphy_final_idx;
 	u8 lcnphy_start_idx;
 	u8 lcnphy_current_index;
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -13281,8 +13281,8 @@ radio_20xx_regs_t regs_2057_rev8[] = {
 
 static s16 nphy_def_lnagains[] = { -2, 10, 19, 25 };
 
-static int32 nphy_lnagain_est0[] = { -315, 40370 };
-static int32 nphy_lnagain_est1[] = { -224, 23242 };
+static s32 nphy_lnagain_est0[] = { -315, 40370 };
+static s32 nphy_lnagain_est1[] = { -224, 23242 };
 
 static const u16 tbl_iqcal_gainparams_nphy[2][NPHY_IQCAL_NUMGAINS][8] = {
 	{
@@ -14118,7 +14118,7 @@ static int wlc_phy_cal_rxiq_nphy_rev3(ph
 				      u8 type, bool d);
 static void wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t *pi, u8 rxcore,
 					     u16 *rg, u8 type);
-static void wlc_phy_update_mimoconfig_nphy(phy_info_t *pi, int32 preamble);
+static void wlc_phy_update_mimoconfig_nphy(phy_info_t *pi, s32 preamble);
 static void wlc_phy_savecal_nphy(phy_info_t *pi);
 static void wlc_phy_restorecal_nphy(phy_info_t *pi);
 static void wlc_phy_resetcca_nphy(phy_info_t *pi);
@@ -14184,7 +14184,7 @@ static u16 wlc_phy_radio2057_rccal(phy_i
 static u16 wlc_phy_gen_load_samples_nphy(phy_info_t *pi, u32 f_kHz,
 					    u16 max_val,
 					    u8 dac_test_mode);
-static void wlc_phy_loadsampletable_nphy(phy_info_t *pi, cint32 *tone_buf,
+static void wlc_phy_loadsampletable_nphy(phy_info_t *pi, cs32 *tone_buf,
 					 u16 num_samps);
 static void wlc_phy_runsamples_nphy(phy_info_t *pi, u16 n, u16 lps,
 				    u16 wait, u8 iq, u8 dac_test_mode,
@@ -14707,7 +14707,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 		u16 idx;
 		s16 pga_gn = 0;
 		s16 pad_gn = 0;
-		int32 rfpwr_offset = 0;
+		s32 rfpwr_offset = 0;
 
 		if (PHY_IPA(pi)) {
 			tx_pwrctrl_tbl = wlc_phy_get_ipa_gaintbl_nphy(pi);
@@ -14938,7 +14938,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 
 }
 
-static void wlc_phy_update_mimoconfig_nphy(phy_info_t *pi, int32 preamble)
+static void wlc_phy_update_mimoconfig_nphy(phy_info_t *pi, s32 preamble)
 {
 	bool gf_preamble = FALSE;
 	u16 val;
@@ -15345,8 +15345,8 @@ static void wlc_phy_workarounds_nphy(phy
 	u16 *aux_adc_gain;
 	u16 sk_adc_vmid[] = { 0xb4, 0xb4, 0xb4, 0x24 };
 	u16 sk_adc_gain[] = { 0x02, 0x02, 0x02, 0x02 };
-	int32 min_nvar_val = 0x18d;
-	int32 min_nvar_offset_6mbps = 20;
+	s32 min_nvar_val = 0x18d;
+	s32 min_nvar_offset_6mbps = 20;
 	u8 pdetrange;
 	u8 triso;
 	u16 regval;
@@ -20809,7 +20809,7 @@ void wlc_phy_rssisel_nphy(phy_info_t *pi
 }
 
 int
-wlc_phy_poll_rssi_nphy(phy_info_t *pi, u8 rssi_type, int32 *rssi_buf,
+wlc_phy_poll_rssi_nphy(phy_info_t *pi, u8 rssi_type, s32 *rssi_buf,
 		       u8 nsamps)
 {
 	s16 rssi0, rssi1;
@@ -20827,7 +20827,7 @@ wlc_phy_poll_rssi_nphy(phy_info_t *pi, u
 	u16 rfctrlrssiothers2_save = 0;
 	s8 tmp_buf[4];
 	u8 ctr = 0, samp = 0;
-	int32 rssi_out_val;
+	s32 rssi_out_val;
 	u16 gpiosel_orig;
 
 	afectrlCore1_save = read_phy_reg(pi, 0xa6);
@@ -20920,8 +20920,8 @@ s16 wlc_phy_tempsense_nphy(phy_info_t *p
 	u16 afectrlOverride2_save;
 	u16 pd_pll_ts_save;
 	u16 gpioSel_save;
-	int32 radio_temp[4];
-	int32 radio_temp2[4];
+	s32 radio_temp[4];
+	s32 radio_temp2[4];
 	u16 syn_tempprocsense_save;
 	s16 offset = 0;
 
@@ -20929,7 +20929,7 @@ s16 wlc_phy_tempsense_nphy(phy_info_t *p
 		u16 auxADC_Vmid, auxADC_Av, auxADC_Vmid_save, auxADC_Av_save;
 		u16 auxADC_rssi_ctrlL_save, auxADC_rssi_ctrlH_save;
 		u16 auxADC_rssi_ctrlL, auxADC_rssi_ctrlH;
-		int32 auxADC_Vl;
+		s32 auxADC_Vl;
 		u16 RfctrlOverride5_save, RfctrlOverride6_save;
 		u16 RfctrlMiscReg5_save, RfctrlMiscReg6_save;
 		u16 RSSIMultCoef0QPowerDet_save;
@@ -21260,7 +21260,7 @@ void wlc_phy_rssi_cal_nphy(phy_info_t *p
 
 static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t *pi, u8 rssi_type)
 {
-	int32 target_code;
+	s32 target_code;
 	u16 classif_state;
 	u16 clip_state[2];
 	u16 rssi_ctrl_state[2], pd_state[2];
@@ -21271,22 +21271,22 @@ static void wlc_phy_rssi_cal_nphy_rev2(p
 	u8 vcm, min_vcm, vcm_tmp[4];
 	u8 vcm_final[4] = { 0, 0, 0, 0 };
 	u8 result_idx, ctr;
-	int32 poll_results[4][4] = {
+	s32 poll_results[4][4] = {
 		{0, 0, 0, 0},
 		{0, 0, 0, 0},
 		{0, 0, 0, 0},
 		{0, 0, 0, 0}
 	};
-	int32 poll_miniq[4][2] = {
+	s32 poll_miniq[4][2] = {
 		{0, 0},
 		{0, 0},
 		{0, 0},
 		{0, 0}
 	};
-	int32 min_d, curr_d;
-	int32 fine_digital_offset[4];
-	int32 poll_results_min[4] = { 0, 0, 0, 0 };
-	int32 min_poll;
+	s32 min_d, curr_d;
+	s32 fine_digital_offset[4];
+	s32 poll_results_min[4] = { 0, 0, 0, 0 };
+	s32 min_poll;
 
 	switch (rssi_type) {
 	case NPHY_RSSI_SEL_NB:
@@ -21747,11 +21747,11 @@ static void wlc_phy_rssi_cal_nphy_rev3(p
 	u16 classif_state;
 	u16 clip_state[2];
 	u16 clip_off[] = { 0xffff, 0xffff };
-	int32 target_code;
+	s32 target_code;
 	u8 vcm, min_vcm;
 	u8 vcm_final = 0;
 	u8 result_idx;
-	int32 poll_results[8][4] = {
+	s32 poll_results[8][4] = {
 		{0, 0, 0, 0},
 		{0, 0, 0, 0},
 		{0, 0, 0, 0},
@@ -21761,11 +21761,11 @@ static void wlc_phy_rssi_cal_nphy_rev3(p
 		{0, 0, 0, 0},
 		{0, 0, 0, 0}
 	};
-	int32 poll_result_core[4] = { 0, 0, 0, 0 };
-	int32 min_d = NPHY_RSSICAL_MAXD, curr_d;
-	int32 fine_digital_offset[4];
-	int32 poll_results_min[4] = { 0, 0, 0, 0 };
-	int32 min_poll;
+	s32 poll_result_core[4] = { 0, 0, 0, 0 };
+	s32 min_d = NPHY_RSSICAL_MAXD, curr_d;
+	s32 fine_digital_offset[4];
+	s32 poll_results_min[4] = { 0, 0, 0, 0 };
+	s32 min_poll;
 	u8 vcm_level_max;
 	u8 core;
 	u8 wb_cnt;
@@ -22345,7 +22345,7 @@ wlc_phy_gen_load_samples_nphy(phy_info_t
 	u16 num_samps, t, spur;
 	fixed theta = 0, rot = 0;
 	u32 tbl_len;
-	cint32 *tone_buf = NULL;
+	cs32 *tone_buf = NULL;
 
 	is_phybw40 = CHSPEC_IS40(pi->radio_chanspec);
 	phy_bw = (is_phybw40 == 1) ? 40 : 20;
@@ -22360,7 +22360,7 @@ wlc_phy_gen_load_samples_nphy(phy_info_t
 		tbl_len = (phy_bw << 1);
 	}
 
-	tone_buf = (cint32 *) MALLOC(pi->sh->osh, sizeof(cint32) * tbl_len);
+	tone_buf = (cs32 *) MALLOC(pi->sh->osh, sizeof(cs32) * tbl_len);
 	if (tone_buf == NULL) {
 		return 0;
 	}
@@ -22375,14 +22375,14 @@ wlc_phy_gen_load_samples_nphy(phy_info_t
 
 		theta += rot;
 
-		tone_buf[t].q = (int32) FLOAT(tone_buf[t].q * max_val);
-		tone_buf[t].i = (int32) FLOAT(tone_buf[t].i * max_val);
+		tone_buf[t].q = (s32) FLOAT(tone_buf[t].q * max_val);
+		tone_buf[t].i = (s32) FLOAT(tone_buf[t].i * max_val);
 	}
 
 	wlc_phy_loadsampletable_nphy(pi, tone_buf, num_samps);
 
 	if (tone_buf != NULL)
-		MFREE(pi->sh->osh, tone_buf, sizeof(cint32) * tbl_len);
+		MFREE(pi->sh->osh, tone_buf, sizeof(cs32) * tbl_len);
 
 	return num_samps;
 }
@@ -22408,7 +22408,7 @@ wlc_phy_tx_tone_nphy(phy_info_t *pi, u32
 }
 
 static void
-wlc_phy_loadsampletable_nphy(phy_info_t *pi, cint32 *tone_buf,
+wlc_phy_loadsampletable_nphy(phy_info_t *pi, cs32 *tone_buf,
 			     u16 num_samps)
 {
 	u16 t;
@@ -23471,21 +23471,21 @@ static void wlc_phy_txcal_phycleanup_nph
 #define NPHY_TEST_TONE_FREQ_20MHz 2500
 
 void
-wlc_phy_est_tonepwr_nphy(phy_info_t *pi, int32 *qdBm_pwrbuf, u8 num_samps)
+wlc_phy_est_tonepwr_nphy(phy_info_t *pi, s32 *qdBm_pwrbuf, u8 num_samps)
 {
 	u16 tssi_reg;
-	int32 temp, pwrindex[2];
-	int32 idle_tssi[2];
-	int32 rssi_buf[4];
-	int32 tssival[2];
+	s32 temp, pwrindex[2];
+	s32 idle_tssi[2];
+	s32 rssi_buf[4];
+	s32 tssival[2];
 	u8 tssi_type;
 
 	tssi_reg = read_phy_reg(pi, 0x1e9);
 
-	temp = (int32) (tssi_reg & 0x3f);
+	temp = (s32) (tssi_reg & 0x3f);
 	idle_tssi[0] = (temp <= 31) ? temp : (temp - 64);
 
-	temp = (int32) ((tssi_reg >> 8) & 0x3f);
+	temp = (s32) ((tssi_reg >> 8) & 0x3f);
 	idle_tssi[1] = (temp <= 31) ? temp : (temp - 64);
 
 	tssi_type =
@@ -23494,8 +23494,8 @@ wlc_phy_est_tonepwr_nphy(phy_info_t *pi,
 
 	wlc_phy_poll_rssi_nphy(pi, tssi_type, rssi_buf, num_samps);
 
-	tssival[0] = rssi_buf[0] / ((int32) num_samps);
-	tssival[1] = rssi_buf[2] / ((int32) num_samps);
+	tssival[0] = rssi_buf[0] / ((s32) num_samps);
+	tssival[1] = rssi_buf[2] / ((s32) num_samps);
 
 	pwrindex[0] = idle_tssi[0] - tssival[0] + 64;
 	pwrindex[1] = idle_tssi[1] - tssival[1] + 64;
@@ -23630,14 +23630,14 @@ static void wlc_phy_precal_txgain_nphy(p
 }
 
 void
-wlc_phy_cal_txgainctrl_nphy(phy_info_t *pi, int32 dBm_targetpower, bool debug)
+wlc_phy_cal_txgainctrl_nphy(phy_info_t *pi, s32 dBm_targetpower, bool debug)
 {
 	int gainctrl_loopidx;
 	uint core;
 	u16 m0m1, curr_m0m1;
-	int32 delta_power;
-	int32 txpwrindex;
-	int32 qdBm_power[2];
+	s32 delta_power;
+	s32 txpwrindex;
+	s32 qdBm_power[2];
 	u16 orig_BBConfig;
 	u16 phy_saveregs[4];
 	u32 freq_test;
@@ -23698,7 +23698,7 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 	wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &m0m1);
 
 	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
-		txpwrindex = (int32) pi->nphy_cal_orig_pwr_idx[core];
+		txpwrindex = (s32) pi->nphy_cal_orig_pwr_idx[core];
 
 		for (gainctrl_loopidx = 0; gainctrl_loopidx < 2;
 		     gainctrl_loopidx++) {
@@ -24568,10 +24568,10 @@ static void wlc_phy_calc_rx_iq_comp_nphy
 	u8 curr_core;
 	phy_iq_est_t est[PHY_CORE_MAX];
 	nphy_iq_comp_t old_comp, new_comp;
-	int32 iq = 0;
+	s32 iq = 0;
 	u32 ii = 0, qq = 0;
 	s16 iq_nbits, qq_nbits, brsh, arsh;
-	int32 a, b, temp;
+	s32 a, b, temp;
 	int bcmerror = BCME_OK;
 	uint cal_retry = 0;
 
@@ -24612,14 +24612,14 @@ static void wlc_phy_calc_rx_iq_comp_nphy
 		arsh = 10 - (30 - iq_nbits);
 		if (arsh >= 0) {
 			a = (-(iq << (30 - iq_nbits)) + (ii >> (1 + arsh)));
-			temp = (int32) (ii >> arsh);
+			temp = (s32) (ii >> arsh);
 			if (temp == 0) {
 				bcmerror = BCME_ERROR;
 				break;
 			}
 		} else {
 			a = (-(iq << (30 - iq_nbits)) + (ii << (-1 - arsh)));
-			temp = (int32) (ii << -arsh);
+			temp = (s32) (ii << -arsh);
 			if (temp == 0) {
 				bcmerror = BCME_ERROR;
 				break;
@@ -24631,14 +24631,14 @@ static void wlc_phy_calc_rx_iq_comp_nphy
 		brsh = qq_nbits - 31 + 20;
 		if (brsh >= 0) {
 			b = (qq << (31 - qq_nbits));
-			temp = (int32) (ii >> brsh);
+			temp = (s32) (ii >> brsh);
 			if (temp == 0) {
 				bcmerror = BCME_ERROR;
 				break;
 			}
 		} else {
 			b = (qq << (31 - qq_nbits));
-			temp = (int32) (ii << -brsh);
+			temp = (s32) (ii << -brsh);
 			if (temp == 0) {
 				bcmerror = BCME_ERROR;
 				break;
@@ -24646,7 +24646,7 @@ static void wlc_phy_calc_rx_iq_comp_nphy
 		}
 		b /= temp;
 		b -= a * a;
-		b = (int32) wlc_phy_sqrt_int((u32) b);
+		b = (s32) wlc_phy_sqrt_int((u32) b);
 		b -= (1 << 10);
 
 		if ((curr_core == PHY_CORE_0) && (core_mask & 0x1)) {
@@ -26319,7 +26319,7 @@ static void
 wlc_phy_papd_cal_setup_nphy(phy_info_t *pi, nphy_papd_restore_state *state,
 			    u8 core)
 {
-	int32 tone_freq;
+	s32 tone_freq;
 	u8 off_core;
 	u16 mixgain = 0;
 
@@ -26743,7 +26743,7 @@ wlc_phy_a1_nphy(phy_info_t *pi, u8 core,
 
 	do {
 		u32 phy_a1, phy_a2;
-		int32 phy_a3, phy_a4, phy_a5, phy_a6, phy_a7;
+		s32 phy_a3, phy_a4, phy_a5, phy_a6, phy_a7;
 
 		phy_a1 = end - MIN(end, (winsz >> 1));
 		phy_a2 = MIN(NPHY_PAPD_EPS_TBL_SIZE - 1, end + (winsz >> 1));
@@ -27080,7 +27080,7 @@ static u8 wlc_phy_a3_nphy(phy_info_t *pi
 	nphy_ipa_txcalgains_t phy_a4;
 	bool phy_a5 = FALSE;
 	bool phy_a6 = TRUE;
-	int32 phy_a7, phy_a8;
+	s32 phy_a7, phy_a8;
 	u32 phy_a9;
 	int phy_a10;
 	bool phy_a11 = FALSE;
@@ -27285,7 +27285,7 @@ static void wlc_phy_a4(phy_info_t *pi, b
 	mod_phy_reg(pi, 0x01, (0x1 << 15), 0);
 
 	for (phy_b5 = 0; phy_b5 < pi->pubpi.phy_corenum; phy_b5++) {
-		int32 i, val = 0;
+		s32 i, val = 0;
 		for (i = 0; i < 64; i++) {
 			wlc_phy_table_write_nphy(pi,
 						 ((phy_b5 ==
@@ -27534,7 +27534,7 @@ void wlc_phy_txpwr_fixpower_nphy(phy_inf
 	u32 txgain;
 	u16 rad_gain, dac_gain, bbmult, m1m2;
 	u8 txpi[2], chan_freq_range;
-	int32 rfpwr_offset;
+	s32 rfpwr_offset;
 
 	ASSERT(pi->nphy_txpwrctrl == PHY_TPC_HW_OFF);
 
@@ -28411,8 +28411,8 @@ static void wlc_phy_ipa_internal_tssi_se
 
 static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t *pi)
 {
-	int32 rssi_buf[4];
-	int32 int_val;
+	s32 rssi_buf[4];
+	s32 int_val;
 
 	if (SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi) || PHY_MUTED(pi))
 
@@ -28480,7 +28480,7 @@ static void wlc_phy_txpwrctrl_pwr_setup_
 	u32 idx;
 	s16 a1[2], b0[2], b1[2];
 	s8 target_pwr_qtrdbm[2];
-	int32 num, den, pwr_est;
+	s32 num, den, pwr_est;
 	u8 chan_freq_range;
 	u8 idle_tssi[2];
 	u32 tbl_id, tbl_len, tbl_offset;
@@ -28934,7 +28934,7 @@ wlc_phy_txpwr_index_nphy(phy_info_t *pi,
 	u32 locomp;
 	u16 tmpval;
 	u8 tx_pwr_ctrl_state;
-	int32 rfpwr_offset;
+	s32 rfpwr_offset;
 	u16 regval[2];
 
 	if (pi->phyhang_avoid)
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -3106,7 +3106,7 @@ int wlc_set_gmode(wlc_info_t *wlc, u8 gm
 	return ret;
 }
 
-static int wlc_nmode_validate(wlc_info_t *wlc, int32 nmode)
+static int wlc_nmode_validate(wlc_info_t *wlc, s32 nmode)
 {
 	int err = 0;
 
@@ -3130,7 +3130,7 @@ static int wlc_nmode_validate(wlc_info_t
 	return err;
 }
 
-int wlc_set_nmode(wlc_info_t *wlc, int32 nmode)
+int wlc_set_nmode(wlc_info_t *wlc, s32 nmode)
 {
 	uint i;
 	int err;
@@ -4489,7 +4489,7 @@ static const bcm_iovar_t *wlc_iovar_look
 /* simplified integer get interface for common WLC_GET_VAR ioctl handler */
 int wlc_iovar_getint(wlc_info_t *wlc, const char *name, int *arg)
 {
-	return wlc_iovar_op(wlc, name, NULL, 0, arg, sizeof(int32), IOV_GET,
+	return wlc_iovar_op(wlc, name, NULL, 0, arg, sizeof(s32), IOV_GET,
 			    NULL);
 }
 
@@ -4677,7 +4677,7 @@ wlc_iovar_check(wlc_pub_t *pub, const bc
 {
 	wlc_info_t *wlc = (wlc_info_t *) pub->wlc;
 	int err = 0;
-	int32 int_val = 0;
+	s32 int_val = 0;
 
 	/* check generic condition flags */
 	if (set) {
@@ -4746,9 +4746,9 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 	wlc_info_t *wlc = hdl;
 	wlc_bsscfg_t *bsscfg;
 	int err = 0;
-	int32 int_val = 0;
-	int32 int_val2 = 0;
-	int32 *ret_int_ptr;
+	s32 int_val = 0;
+	s32 int_val2 = 0;
+	s32 *ret_int_ptr;
 	bool bool_val;
 	bool bool_val2;
 	wlc_bss_info_t *current_bss;
@@ -4771,7 +4771,7 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 		      sizeof(int_val));
 
 	/* convenience int ptr for 4-byte gets (requires int aligned arg) */
-	ret_int_ptr = (int32 *) arg;
+	ret_int_ptr = (s32 *) arg;
 
 	bool_val = (int_val != 0) ? TRUE : FALSE;
 	bool_val2 = (int_val2 != 0) ? TRUE : FALSE;
@@ -4816,7 +4816,7 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 		}
 
 	case IOV_GVAL(IOV_MPC):
-		*ret_int_ptr = (int32) wlc->mpc;
+		*ret_int_ptr = (s32) wlc->mpc;
 		break;
 
 	case IOV_SVAL(IOV_MPC):
@@ -4870,8 +4870,8 @@ wlc_iovar_rangecheck(wlc_info_t *wlc, u3
 		else if (vi->flags & IOVF_WHL)
 			min_val = 0;
 		/* Signed values are checked against max_val and min_val */
-		if ((int32) val < (int32) min_val
-		    || (int32) val > (int32) max_val)
+		if ((s32) val < (s32) min_val
+		    || (s32) val > (s32) max_val)
 			err = BCME_RANGE;
 		break;
 
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.h
@@ -637,7 +637,7 @@ struct wlc_info {
 
 	/* driver feature */
 	bool _rifs;		/* enable per-packet rifs */
-	int32 rifs_advert;	/* RIFS mode advertisement */
+	s32 rifs_advert;	/* RIFS mode advertisement */
 	s8 sgi_tx;		/* sgi tx */
 	bool wet;		/* true if wireless ethernet bridging mode */
 
@@ -1004,7 +1004,7 @@ extern int wlc_doiovar(void *hdl, const
 extern void wlc_print_ies(wlc_info_t *wlc, u8 *ies, uint ies_len);
 #endif
 
-extern int wlc_set_nmode(wlc_info_t *wlc, int32 nmode);
+extern int wlc_set_nmode(wlc_info_t *wlc, s32 nmode);
 extern void wlc_ht_mimops_cap_update(wlc_info_t *wlc, u8 mimops_mode);
 extern void wlc_mimops_action_ht_send(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg,
 				      u8 mimops_mode);
--- a/drivers/staging/brcm80211/sys/wlc_pub.h
+++ b/drivers/staging/brcm80211/sys/wlc_pub.h
@@ -345,8 +345,8 @@ typedef struct wl_rxsts {
 	uint pktlength;		/* pkt length minus bcm phy hdr */
 	u32 mactime;		/* time stamp from mac, count per 1us */
 	uint sq;		/* signal quality */
-	int32 signal;		/* in dbm */
-	int32 noise;		/* in dbm */
+	s32 signal;		/* in dbm */
+	s32 noise;		/* in dbm */
 	uint preamble;		/* Unknown, short, long */
 	uint encoding;		/* Unknown, CCK, PBCC, OFDM */
 	uint nfrmtype;		/* special 802.11n frames(AMPDU, AMSDU) */
--- a/drivers/staging/brcm80211/sys/wlc_stf.c
+++ b/drivers/staging/brcm80211/sys/wlc_stf.c
@@ -43,7 +43,7 @@
 	NREV_GT(wlc->band->phyrev, 3) && NREV_LE(wlc->band->phyrev, 6))
 
 static s8 wlc_stf_stbc_rx_get(wlc_info_t *wlc);
-static bool wlc_stf_stbc_tx_set(wlc_info_t *wlc, int32 int_val);
+static bool wlc_stf_stbc_tx_set(wlc_info_t *wlc, s32 int_val);
 static int wlc_stf_txcore_set(wlc_info_t *wlc, u8 Nsts, u8 val);
 static int wlc_stf_spatial_policy_set(wlc_info_t *wlc, int val);
 static void wlc_stf_stbc_rx_ht_update(wlc_info_t *wlc, int val);
@@ -154,7 +154,7 @@ static s8 wlc_stf_stbc_rx_get(wlc_info_t
 	return (wlc->ht_cap.cap & HT_CAP_RX_STBC_MASK) >> HT_CAP_RX_STBC_SHIFT;
 }
 
-static bool wlc_stf_stbc_tx_set(wlc_info_t *wlc, int32 int_val)
+static bool wlc_stf_stbc_tx_set(wlc_info_t *wlc, s32 int_val)
 {
 	if ((int_val != AUTO) && (int_val != OFF) && (int_val != ON)) {
 		return FALSE;
@@ -175,7 +175,7 @@ static bool wlc_stf_stbc_tx_set(wlc_info
 	return TRUE;
 }
 
-bool wlc_stf_stbc_rx_set(wlc_info_t *wlc, int32 int_val)
+bool wlc_stf_stbc_rx_set(wlc_info_t *wlc, s32 int_val)
 {
 	if ((int_val != HT_CAP_RX_STBC_NO)
 	    && (int_val != HT_CAP_RX_STBC_ONE_STREAM)) {
@@ -245,7 +245,7 @@ static int wlc_stf_spatial_policy_set(wl
 	return BCME_OK;
 }
 
-int wlc_stf_txchain_set(wlc_info_t *wlc, int32 int_val, bool force)
+int wlc_stf_txchain_set(wlc_info_t *wlc, s32 int_val, bool force)
 {
 	u8 txchain = (u8) int_val;
 	u8 txstreams;
@@ -305,7 +305,7 @@ int wlc_stf_txchain_set(wlc_info_t *wlc,
 	return BCME_OK;
 }
 
-int wlc_stf_rxchain_set(wlc_info_t *wlc, int32 int_val)
+int wlc_stf_rxchain_set(wlc_info_t *wlc, s32 int_val)
 {
 	u8 rxchain_cnt;
 	u8 rxchain = (u8) int_val;
--- a/drivers/staging/brcm80211/sys/wlc_stf.h
+++ b/drivers/staging/brcm80211/sys/wlc_stf.h
@@ -29,9 +29,9 @@ extern void wlc_stf_ss_algo_channel_get(
 					chanspec_t chanspec);
 extern int wlc_stf_ss_update(wlc_info_t *wlc, struct wlcband *band);
 extern void wlc_stf_phy_txant_upd(wlc_info_t *wlc);
-extern int wlc_stf_txchain_set(wlc_info_t *wlc, int32 int_val, bool force);
-extern int wlc_stf_rxchain_set(wlc_info_t *wlc, int32 int_val);
-extern bool wlc_stf_stbc_rx_set(wlc_info_t *wlc, int32 int_val);
+extern int wlc_stf_txchain_set(wlc_info_t *wlc, s32 int_val, bool force);
+extern int wlc_stf_rxchain_set(wlc_info_t *wlc, s32 int_val);
+extern bool wlc_stf_stbc_rx_set(wlc_info_t *wlc, s32 int_val);
 
 extern int wlc_stf_ant_txant_validate(wlc_info_t *wlc, s8 val);
 extern void wlc_stf_phy_txant_upd(wlc_info_t *wlc);
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -391,7 +391,7 @@ BCMATTACHFN(srom_parsecis) (osl_t *osh,
 	u32 w32;
 	uint funcid;
 	uint cisnum;
-	int32 boardnum;
+	s32 boardnum;
 	int err;
 	bool standard_cis;
 
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -364,7 +364,7 @@ int bcm_iovar_lencheck(const bcm_iovar_t
 	case IOVT_UINT8:
 	case IOVT_UINT16:
 	case IOVT_UINT32:
-		/* all integers are int32 sized args at the ioctl interface */
+		/* all integers are s32 sized args at the ioctl interface */
 		if (len < (int)sizeof(int)) {
 			bcmerror = BCME_BUFTOOSHORT;
 		}
--- a/drivers/staging/brcm80211/util/qmath.c
+++ b/drivers/staging/brcm80211/util/qmath.c
@@ -22,12 +22,12 @@ If input number is greater than 0x7fff t
 else if input number is less than 0xffff8000 then output is saturated to 0xffff8000
 else output is same as input.
 */
-s16 qm_sat32(int32 op)
+s16 qm_sat32(s32 op)
 {
 	s16 result;
-	if (op > (int32) 0x7fff) {
+	if (op > (s32) 0x7fff) {
 		result = 0x7fff;
-	} else if (op < (int32) 0xffff8000) {
+	} else if (op < (s32) 0xffff8000) {
 		result = (s16) (0x8000);
 	} else {
 		result = (s16) op;
@@ -41,9 +41,9 @@ This multiplication is similar to compil
 16 bit multiplication on the processor platform is cheaper than 32 bit multiplication (as
 the most of qmath functions can be replaced with processor intrinsic instructions).
 */
-int32 qm_mul321616(s16 op1, s16 op2)
+s32 qm_mul321616(s16 op1, s16 op2)
 {
-	return (int32) (op1) * (int32) (op2);
+	return (s32) (op1) * (s32) (op2);
 }
 
 /*
@@ -53,8 +53,8 @@ shifted by 16 bits.
 */
 s16 qm_mul16(s16 op1, s16 op2)
 {
-	int32 result;
-	result = ((int32) (op1) * (int32) (op2));
+	s32 result;
+	result = ((s32) (op1) * (s32) (op2));
 	return (s16) (result >> 16);
 }
 
@@ -65,13 +65,13 @@ This function remove the extra sign bit
 twice that of compiler multiplication. (i.e. qm_muls321616(2,3)=12).
 When both input 16 bit numbers are 0x8000, then the result is saturated to 0x7fffffff.
 */
-int32 qm_muls321616(s16 op1, s16 op2)
+s32 qm_muls321616(s16 op1, s16 op2)
 {
-	int32 result;
+	s32 result;
 	if (op1 == (s16) (0x8000) && op2 == (s16) (0x8000)) {
 		result = 0x7fffffff;
 	} else {
-		result = ((int32) (op1) * (int32) (op2));
+		result = ((s32) (op1) * (s32) (op2));
 		result = result << 1;
 	}
 	return result;
@@ -95,11 +95,11 @@ When both the 16bit inputs are 0x8000 th
 */
 s16 qm_muls16(s16 op1, s16 op2)
 {
-	int32 result;
+	s32 result;
 	if (op1 == (s16) 0x8000 && op2 == (s16) 0x8000) {
 		result = 0x7fffffff;
 	} else {
-		result = ((int32) (op1) * (int32) (op2));
+		result = ((s32) (op1) * (s32) (op2));
 	}
 	return (s16) (result >> 15);
 }
@@ -108,9 +108,9 @@ s16 qm_muls16(s16 op1, s16 op2)
 Description: This function add two 32 bit numbers and return the 32bit result.
 If the result overflow 32 bits, the output will be saturated to 32bits.
 */
-int32 qm_add32(int32 op1, int32 op2)
+s32 qm_add32(s32 op1, s32 op2)
 {
-	int32 result;
+	s32 result;
 	result = op1 + op2;
 	if (op1 < 0 && op2 < 0 && result > 0) {
 		result = 0x80000000;
@@ -127,10 +127,10 @@ If the result overflow 16 bits, the outp
 s16 qm_add16(s16 op1, s16 op2)
 {
 	s16 result;
-	int32 temp = (int32) op1 + (int32) op2;
-	if (temp > (int32) 0x7fff) {
+	s32 temp = (s32) op1 + (s32) op2;
+	if (temp > (s32) 0x7fff) {
 		result = (s16) 0x7fff;
-	} else if (temp < (int32) 0xffff8000) {
+	} else if (temp < (s32) 0xffff8000) {
 		result = (s16) 0xffff8000;
 	} else {
 		result = (s16) temp;
@@ -145,10 +145,10 @@ If the result overflow 16 bits, the outp
 s16 qm_sub16(s16 op1, s16 op2)
 {
 	s16 result;
-	int32 temp = (int32) op1 - (int32) op2;
-	if (temp > (int32) 0x7fff) {
+	s32 temp = (s32) op1 - (s32) op2;
+	if (temp > (s32) 0x7fff) {
 		result = (s16) 0x7fff;
-	} else if (temp < (int32) 0xffff8000) {
+	} else if (temp < (s32) 0xffff8000) {
 		result = (s16) 0xffff8000;
 	} else {
 		result = (s16) temp;
@@ -160,9 +160,9 @@ s16 qm_sub16(s16 op1, s16 op2)
 Description: This function make 32 bit subtraction and return the 32bit result.
 If the result overflow 32 bits, the output will be saturated to 32bits.
 */
-int32 qm_sub32(int32 op1, int32 op2)
+s32 qm_sub32(s32 op1, s32 op2)
 {
-	int32 result;
+	s32 result;
 	result = op1 - op2;
 	if (op1 >= 0 && op2 < 0 && result < 0) {
 		result = 0x7fffffff;
@@ -177,9 +177,9 @@ Description: This function multiply inpu
 into the input 32 bit number and return the 32 bit accumulated result.
 If the accumulation result in overflow, then the output will be saturated.
 */
-int32 qm_mac321616(int32 acc, s16 op1, s16 op2)
+s32 qm_mac321616(s32 acc, s16 op1, s16 op2)
 {
-	int32 result;
+	s32 result;
 	result = qm_add32(acc, qm_mul321616(op1, op2));
 	return result;
 }
@@ -189,10 +189,10 @@ Description: This function make a 32 bit
 is +ve. This function will make a 32 bit right shift when the specified shift is -ve.
 This function return the result after shifting operation.
 */
-int32 qm_shl32(int32 op, int shift)
+s32 qm_shl32(s32 op, int shift)
 {
 	int i;
-	int32 result;
+	s32 result;
 	result = op;
 	if (shift > 31)
 		shift = 31;
@@ -213,7 +213,7 @@ Description: This function make a 32 bit
 This function make a 32 bit saturated left shift when shift is -ve. This function
 return the result of the shift operation.
 */
-int32 qm_shr32(int32 op, int shift)
+s32 qm_shr32(s32 op, int shift)
 {
 	return qm_shl32(op, -shift);
 }
@@ -275,7 +275,7 @@ s16 qm_norm16(s16 op)
 Description: This function return the number of redundant sign bits in a 32 bit number.
 Example: qm_norm32(0x00000080) = 23
 */
-s16 qm_norm32(int32 op)
+s16 qm_norm32(s32 op)
 {
 	u16 u16extraSignBits;
 	if (op == 0) {
@@ -299,8 +299,8 @@ s16 qm_div_s(s16 num, s16 denom)
 {
 	s16 var_out;
 	s16 iteration;
-	int32 L_num;
-	int32 L_denom;
+	s32 L_num;
+	s32 L_denom;
 	L_num = (num) << 15;
 	L_denom = (denom) << 15;
 	for (iteration = 0; iteration < 15; iteration++) {
@@ -359,10 +359,10 @@ s16 qm_div16(s16 num, s16 denom, s16 *qQ
 /*
 Description: This function compute absolute value of a 32 bit number.
 */
-int32 qm_abs32(int32 op)
+s32 qm_abs32(s32 op)
 {
 	if (op < 0) {
-		if (op == (int32) 0x80000000) {
+		if (op == (s32) 0x80000000) {
 			return 0x7fffffff;
 		} else {
 			return -op;
@@ -380,9 +380,9 @@ The qformat of the quotient is returned
 to this function. The qformat of quotient is adjusted appropriately such that
 the quotient occupies all 16 bits.
 */
-s16 qm_div163232(int32 num, int32 denom, s16 *qquotient)
+s16 qm_div163232(s32 num, s32 denom, s16 *qquotient)
 {
-	int32 sign;
+	s32 sign;
 	s16 nNum, nDenom;
 	sign = num ^ denom;
 	num = qm_abs32(num);
@@ -404,11 +404,11 @@ Description: This function multiply a 32
 The multiplicaton result is right shifted by 16 bits to fit the result
 into 32 bit output.
 */
-int32 qm_mul323216(int32 op1, s16 op2)
+s32 qm_mul323216(s32 op1, s16 op2)
 {
 	s16 hi;
 	u16 lo;
-	int32 result;
+	s32 result;
 	hi = op1 >> 16;
 	lo = (s16) (op1 & 0xffff);
 	result = qm_mul321616(hi, op2);
@@ -420,9 +420,9 @@ int32 qm_mul323216(int32 op1, s16 op2)
 Description: This function multiply signed 16 bit number with unsigned 16 bit number and return
 the result in 32 bits.
 */
-int32 qm_mulsu321616(s16 op1, u16 op2)
+s32 qm_mulsu321616(s16 op1, u16 op2)
 {
-	return (int32) (op1) * op2;
+	return (s32) (op1) * op2;
 }
 
 /*
@@ -431,11 +431,11 @@ right shifted by 15 bits to fit the resu
 16 bits is done to remove the extra sign bit formed by multiplication from the return value.
 When the input numbers are 0x80000000, 0x8000 the return value is saturated to 0x7fffffff.
 */
-int32 qm_muls323216(int32 op1, s16 op2)
+s32 qm_muls323216(s32 op1, s16 op2)
 {
 	s16 hi;
 	u16 lo;
-	int32 result;
+	s32 result;
 	hi = op1 >> 16;
 	lo = (s16) (op1 & 0xffff);
 	result = qm_muls321616(hi, op2);
@@ -448,11 +448,11 @@ Description: This function multiply two
 shifted by 32 bits to fit the multiplication result into 32 bits. The right shifted
 multiplication result is returned as output.
 */
-int32 qm_mul32(int32 a, int32 b)
+s32 qm_mul32(s32 a, s32 b)
 {
 	s16 hi1, hi2;
 	u16 lo1, lo2;
-	int32 result;
+	s32 result;
 	hi1 = a >> 16;
 	hi2 = b >> 16;
 	lo1 = (u16) (a & 0xffff);
@@ -471,11 +471,11 @@ instead of 32 bits is done to remove the
 When the input numbers are 0x80000000, 0x80000000 the return value is saturated to
 0x7fffffff.
 */
-int32 qm_muls32(int32 a, int32 b)
+s32 qm_muls32(s32 a, s32 b)
 {
 	s16 hi1, hi2;
 	u16 lo1, lo2;
-	int32 result;
+	s32 result;
 	hi1 = a >> 16;
 	hi2 = b >> 16;
 	lo1 = (u16) (a & 0xffff);
@@ -545,11 +545,11 @@ qLog10N - address where log10N qformat w
 Note/Problem:
 For accurate results input should be in normalized or near normalized form.
 */
-void qm_log10(int32 N, s16 qN, s16 *log10N, s16 *qLog10N)
+void qm_log10(s32 N, s16 qN, s16 *log10N, s16 *qLog10N)
 {
 	s16 s16norm, s16tableIndex, s16errorApproximation;
 	u16 u16offset;
-	int32 s32log;
+	s32 s32log;
 
 	/* Logerithm of negative values is undefined.
 	 * assert N is greater than 0.
@@ -593,7 +593,7 @@ void qm_log10(int32 N, s16 qN, s16 *log1
 	/* adjust for the qformat of the N as
 	 * log2(mag * 2^x) = log2(mag) + x
 	 */
-	s32log = qm_add32(s32log, ((int32) -qN) << 15);	/* q.15 format */
+	s32log = qm_add32(s32log, ((s32) -qN) << 15);	/* q.15 format */
 
 	/* normalize the result. */
 	s16norm = qm_norm32(s32log);
@@ -631,10 +631,10 @@ sqrtN - address where 1/N has to be writ
 qsqrtN - address where q format of 1/N has to be written.
 */
 #define qx 29
-void qm_1byN(int32 N, s16 qN, int32 *result, s16 *qResult)
+void qm_1byN(s32 N, s16 qN, s32 *result, s16 *qResult)
 {
 	s16 normN;
-	int32 s32firstTerm, s32secondTerm, x;
+	s32 s32firstTerm, s32secondTerm, x;
 	int i;
 
 	normN = qm_norm32(N);
@@ -646,10 +646,10 @@ void qm_1byN(int32 N, s16 qN, int32 *res
 
 	/* Take the initial guess as 1/0.75 in qx format with appropriate sign. */
 	if (N >= 0) {
-		x = (int32) ((1 / 0.75) * (1 << qx));
+		x = (s32) ((1 / 0.75) * (1 << qx));
 		/* input no is in the range 0.5 to 1. So 1/0.75 is taken as initial guess. */
 	} else {
-		x = (int32) ((1 / -0.75) * (1 << qx));
+		x = (s32) ((1 / -0.75) * (1 << qx));
 		/* input no is in the range -0.5 to -1. So 1/-0.75 is taken as initial guess. */
 	}
 

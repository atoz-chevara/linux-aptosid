commit 0965ae88aff802ff48fa2f35fff29feff2754962
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 12 12:50:15 2010 -0700

    Staging: brcm80211: remove FALSE #define
    
    use the kernel provided 'false' value instead, especially
    as we are using a 'bool' for these variables.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
@@ -118,7 +118,7 @@ bool bcmsdh_intr_query(void *sdh)
 	ASSERT(bcmsdh);
 	status = sdioh_interrupt_query(bcmsdh->sdioh, &on);
 	if (SDIOH_API_SUCCESS(status))
-		return FALSE;
+		return false;
 	else
 		return on;
 }
@@ -139,7 +139,7 @@ int bcmsdh_intr_disable(void *sdh)
 	SDIOH_API_RC status;
 	ASSERT(bcmsdh);
 
-	status = sdioh_interrupt_set(bcmsdh->sdioh, FALSE);
+	status = sdioh_interrupt_set(bcmsdh->sdioh, false);
 	return SDIOH_API_SUCCESS(status) ? 0 : BCME_ERROR;
 }
 
--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
@@ -121,7 +121,7 @@ bool bcmsdh_chipmatch(u16 vendor, u16 de
 	}
 #endif				/* BCMSDIOH_SPI */
 
-	return FALSE;
+	return false;
 }
 
 #if defined(BCMPLATFORM_BUS)
@@ -190,7 +190,7 @@ int bcmsdh_probe(struct device *dev)
 	}
 #endif				/* defined(OOB_INTR_ONLY) */
 	/* allocate SDIO Host Controller state info */
-	osh = osl_attach(dev, PCI_BUS, FALSE);
+	osh = osl_attach(dev, PCI_BUS, false);
 	if (!osh) {
 		SDLX_MSG(("%s: osl_attach failed\n", __func__));
 		goto err;
@@ -222,7 +222,7 @@ int bcmsdh_probe(struct device *dev)
 	sdhc->sdh = sdh;
 	sdhc->oob_irq = irq;
 	sdhc->oob_flags = irq_flags;
-	sdhc->oob_irq_registered = FALSE;	/* to make sure.. */
+	sdhc->oob_irq_registered = false;	/* to make sure.. */
 #if defined(OOB_INTR_ONLY)
 	spin_lock_init(&sdhc->irq_lock);
 #endif
@@ -388,7 +388,7 @@ bcmsdh_pci_probe(struct pci_dev *pdev, c
 
 		SDLX_MSG(("%s: Disabling TI FlashMedia Controller.\n",
 			  __func__));
-		osh = osl_attach(pdev, PCI_BUS, FALSE);
+		osh = osl_attach(pdev, PCI_BUS, false);
 		if (!osh) {
 			SDLX_MSG(("%s: osl_attach failed\n", __func__));
 			goto err;
@@ -423,7 +423,7 @@ bcmsdh_pci_probe(struct pci_dev *pdev, c
 	 */
 
 	/* allocate SDIO Host Controller state info */
-	osh = osl_attach(pdev, PCI_BUS, FALSE);
+	osh = osl_attach(pdev, PCI_BUS, false);
 	if (!osh) {
 		SDLX_MSG(("%s: osl_attach failed\n", __func__));
 		goto err;
@@ -634,7 +634,7 @@ void bcmsdh_unregister_oob_intr(void)
 	set_irq_wake(sdhcinfo->oob_irq, 0);
 	disable_irq(sdhcinfo->oob_irq);	/* just in case.. */
 	free_irq(sdhcinfo->oob_irq, NULL);
-	sdhcinfo->oob_irq_registered = FALSE;
+	sdhcinfo->oob_irq_registered = false;
 }
 #endif				/* defined(OOB_INTR_ONLY) */
 /* Module parameters specific to each host-controller driver */
--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
@@ -56,7 +56,7 @@ uint sd_divisor = 2;		/* Default 48MHz/2
 
 uint sd_power = 1;		/* Default to SD Slot powered ON */
 uint sd_clock = 1;		/* Default to SD Clock turned ON */
-uint sd_hiok = FALSE;		/* Don't use hi-speed mode by default */
+uint sd_hiok = false;		/* Don't use hi-speed mode by default */
 uint sd_msglevel = 0x01;
 uint sd_use_dma = true;
 DHD_PM_RESUME_WAIT_INIT(sdioh_request_byte_wait);
@@ -105,7 +105,7 @@ static int sdioh_sdmmc_card_enablefuncs(
 			err_ret));
 	}
 
-	return FALSE;
+	return false;
 }
 
 /*
@@ -321,7 +321,7 @@ extern SDIOH_API_RC sdioh_interrupt_dere
 		sdio_release_host(gInstance->func[2]);
 	}
 
-	sd->intr_handler_valid = FALSE;
+	sd->intr_handler_valid = false;
 	sd->intr_handler = NULL;
 	sd->intr_handler_arg = NULL;
 #elif defined(HW_OOB)
@@ -444,7 +444,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 	if (plen >= (int)sizeof(int_val))
 		bcopy(params, &int_val, sizeof(int_val));
 
-	bool_val = (int_val != 0) ? true : FALSE;
+	bool_val = (int_val != 0) ? true : false;
 
 	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
 	switch (actionid) {
@@ -514,7 +514,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 		}
 
 	case IOV_GVAL(IOV_RXCHAIN):
-		int_val = FALSE;
+		int_val = false;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -1041,9 +1041,9 @@ sdioh_request_buffer(sdioh_info_t *sd, u
 		sd_data(("%s: Creating new %s Packet, len=%d\n",
 			 __func__, write ? "TX" : "RX", buflen_u));
 #ifdef DHD_USE_STATIC_BUF
-		mypkt = PKTGET_STATIC(sd->osh, buflen_u, write ? true : FALSE);
+		mypkt = PKTGET_STATIC(sd->osh, buflen_u, write ? true : false);
 #else
-		mypkt = PKTGET(sd->osh, buflen_u, write ? true : FALSE);
+		mypkt = PKTGET(sd->osh, buflen_u, write ? true : false);
 #endif				/* DHD_USE_STATIC_BUF */
 		if (!mypkt) {
 			sd_err(("%s: PKTGET failed: len %d\n",
@@ -1063,9 +1063,9 @@ sdioh_request_buffer(sdioh_info_t *sd, u
 			bcopy(PKTDATA(mypkt), buffer, buflen_u);
 
 #ifdef DHD_USE_STATIC_BUF
-		PKTFREE_STATIC(sd->osh, mypkt, write ? true : FALSE);
+		PKTFREE_STATIC(sd->osh, mypkt, write ? true : false);
 #else
-		PKTFREE(sd->osh, mypkt, write ? true : FALSE);
+		PKTFREE(sd->osh, mypkt, write ? true : false);
 #endif				/* DHD_USE_STATIC_BUF */
 	} else if (((u32) (PKTDATA(pkt)) & DMA_ALIGN_MASK) != 0) {
 		/* Case 2: We have a packet, but it is unaligned. */
@@ -1077,9 +1077,9 @@ sdioh_request_buffer(sdioh_info_t *sd, u
 			 __func__, write ? "TX" : "RX", PKTLEN(pkt)));
 #ifdef DHD_USE_STATIC_BUF
 		mypkt = PKTGET_STATIC(sd->osh, PKTLEN(pkt),
-					write ? true : FALSE);
+					write ? true : false);
 #else
-		mypkt = PKTGET(sd->osh, PKTLEN(pkt), write ? true : FALSE);
+		mypkt = PKTGET(sd->osh, PKTLEN(pkt), write ? true : false);
 #endif				/* DHD_USE_STATIC_BUF */
 		if (!mypkt) {
 			sd_err(("%s: PKTGET failed: len %d\n",
@@ -1099,9 +1099,9 @@ sdioh_request_buffer(sdioh_info_t *sd, u
 			bcopy(PKTDATA(mypkt), PKTDATA(pkt), PKTLEN(mypkt));
 
 #ifdef DHD_USE_STATIC_BUF
-		PKTFREE_STATIC(sd->osh, mypkt, write ? true : FALSE);
+		PKTFREE_STATIC(sd->osh, mypkt, write ? true : false);
 #else
-		PKTFREE(sd->osh, mypkt, write ? true : FALSE);
+		PKTFREE(sd->osh, mypkt, write ? true : false);
 #endif				/* DHD_USE_STATIC_BUF */
 	} else {		/* case 3: We have a packet and
 				 it is aligned. */
--- a/drivers/staging/brcm80211/brcmfmac/dhd.h
+++ b/drivers/staging/brcm80211/brcmfmac/dhd.h
@@ -158,7 +158,7 @@ typedef struct dhd_pub {
 #define _DHD_PM_RESUME_WAIT(a, b) do {\
 			int retry = 0; \
 			while (dhd_mmc_suspend && retry++ != b) { \
-				wait_event_timeout(a, FALSE, HZ/100); \
+				wait_event_timeout(a, false, HZ/100); \
 			} \
 		}	while (0)
 #define DHD_PM_RESUME_WAIT(a)	_DHD_PM_RESUME_WAIT(a, 30)
@@ -171,7 +171,7 @@ typedef struct dhd_pub {
 #define SPINWAIT_SLEEP(a, exp, us) do { \
 		uint countdown = (us) + 9999; \
 		while ((exp) && (countdown >= 10000)) { \
-			wait_event_timeout(a, FALSE, HZ/100); \
+			wait_event_timeout(a, false, HZ/100); \
 			countdown -= 10000; \
 		} \
 	} while (0)
--- a/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
@@ -288,7 +288,7 @@ dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx
 		dhd->wme_dp = (u8) ltoh32(val);
 	}
 
-	prot->pending = FALSE;
+	prot->pending = false;
 
 done:
 	dhd_os_proto_unblock(dhd);
@@ -351,7 +351,7 @@ bool dhd_proto_fcinfo(dhd_pub_t *dhd, vo
 	if ((h->flags2 & BDC_FLAG2_FC_FLAG) == BDC_FLAG2_FC_FLAG)
 		return true;
 #endif
-	return FALSE;
+	return false;
 }
 
 int dhd_prot_hdrpull(dhd_pub_t *dhd, int *ifidx, void *pktbuf)
--- a/drivers/staging/brcm80211/brcmfmac/dhd_common.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_common.c
@@ -347,7 +347,7 @@ bool dhd_prec_enq(dhd_pub_t *dhdp, struc
 		p = pktq_peek_tail(q, &eprec);
 		ASSERT(p);
 		if (eprec > prec)
-			return FALSE;
+			return false;
 	}
 
 	/* Evict if needed */
@@ -356,7 +356,7 @@ bool dhd_prec_enq(dhd_pub_t *dhdp, struc
 		ASSERT(!pktq_pempty(q, eprec));
 		discard_oldest = AC_BITMAP_TST(dhdp->wme_dp, eprec);
 		if (eprec == prec && !discard_oldest)
-			return FALSE;	/* refuse newer (incoming) packet */
+			return false;	/* refuse newer (incoming) packet */
 		/* Evict packet according to discard policy */
 		p = discard_oldest ? pktq_pdeq(q, eprec) : pktq_pdeq_tail(q,
 						  eprec);
@@ -523,7 +523,7 @@ int dhd_ioctl(dhd_pub_t *dhd_pub, dhd_io
 static void wl_show_host_event(wl_event_msg_t *event, void *event_data)
 {
 	uint i, status, reason;
-	bool group = FALSE, flush_txq = FALSE, link = FALSE;
+	bool group = false, flush_txq = false, link = false;
 	char *auth_str, *event_name;
 	unsigned char *buf;
 	char err_msg[256], eabuf[ETHER_ADDR_STR_LEN];
--- a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
@@ -171,7 +171,7 @@ void wifi_del_dev(void)
 
 #if defined(CONFIG_PM_SLEEP)
 #include <linux/suspend.h>
-volatile bool dhd_mmc_suspend = FALSE;
+volatile bool dhd_mmc_suspend = false;
 DECLARE_WAIT_QUEUE_HEAD(dhd_dpc_wait);
 #endif	/*  defined(CONFIG_PM_SLEEP) */
 
@@ -343,7 +343,7 @@ int dhd_idletime = DHD_IDLETIME_TICKS;
 module_param(dhd_idletime, int, 0);
 
 /* Use polling */
-uint dhd_poll = FALSE;
+uint dhd_poll = false;
 module_param(dhd_poll, uint, 0);
 
 /* Use cfg80211 */
@@ -426,7 +426,7 @@ static int dhd_sleep_pm_callback(struct
 		return NOTIFY_OK;
 	case PM_POST_HIBERNATION:
 	case PM_POST_SUSPEND:
-		dhd_mmc_suspend = FALSE;
+		dhd_mmc_suspend = false;
 		return NOTIFY_OK;
 	}
 	return 0;
@@ -707,7 +707,7 @@ static void _dhd_set_multicast_list(dhd_
 	cnt = netdev_mc_count(dev);
 
 	/* Determine initial value of allmulti flag */
-	allmulti = (dev->flags & IFF_ALLMULTI) ? true : FALSE;
+	allmulti = (dev->flags & IFF_ALLMULTI) ? true : false;
 
 	/* Send down the multicast list first. */
 
@@ -789,7 +789,7 @@ static void _dhd_set_multicast_list(dhd_
 	/* Finally, pick up the PROMISC flag as well, like the NIC
 		 driver does */
 
-	allmulti = (dev->flags & IFF_PROMISC) ? true : FALSE;
+	allmulti = (dev->flags & IFF_PROMISC) ? true : false;
 	allmulti = htol32(allmulti);
 
 	memset(&ioc, 0, sizeof(ioc));
@@ -935,7 +935,7 @@ static int _dhd_sysioc_thread(void *data
 	dhd_info_t *dhd = (dhd_info_t *) data;
 	int i;
 #ifdef SOFTAP
-	bool in_ap = FALSE;
+	bool in_ap = false;
 #endif
 
 	while (down_interruptible(&dhd->sysioc_sem) == 0) {
@@ -959,23 +959,23 @@ static int _dhd_sysioc_thread(void *data
 					DHD_TRACE(("attempt to set MAC for %s "
 						"in AP Mode," "blocked. \n",
 						dhd->iflist[i]->net->name));
-					dhd->set_macaddress = FALSE;
+					dhd->set_macaddress = false;
 					continue;
 				}
 
 				if (in_ap && dhd->set_multicast) {
 					DHD_TRACE(("attempt to set MULTICAST list for %s" "in AP Mode, blocked. \n",
 						dhd->iflist[i]->net->name));
-					dhd->set_multicast = FALSE;
+					dhd->set_multicast = false;
 					continue;
 				}
 #endif				/* SOFTAP */
 				if (dhd->set_multicast) {
-					dhd->set_multicast = FALSE;
+					dhd->set_multicast = false;
 					_dhd_set_multicast_list(dhd, i);
 				}
 				if (dhd->set_macaddress) {
-					dhd->set_macaddress = FALSE;
+					dhd->set_macaddress = false;
 					_dhd_set_mac_address(dhd, i,
 							     &dhd->macvalue);
 				}
@@ -1041,7 +1041,7 @@ int dhd_sendpkt(dhd_pub_t *dhdp, int ifi
 
 	/* Look into the packet and update the packet priority */
 	if ((PKTPRIO(pktbuf) == 0))
-		pktsetprio(pktbuf, FALSE);
+		pktsetprio(pktbuf, false);
 
 	/* If the protocol uses a data header, apply it */
 	dhd_prot_hdrpush(dhdp, ifidx, pktbuf);
@@ -1300,7 +1300,7 @@ static int dhd_watchdog_thread(void *dat
 		if (kthread_should_stop())
 			break;
 		if (down_interruptible(&dhd->watchdog_sem) == 0) {
-			if (dhd->pub.dongle_reset == FALSE) {
+			if (dhd->pub.dongle_reset == false) {
 				WAKE_LOCK(&dhd->pub, WAKE_LOCK_WATCHDOG);
 				/* Call the bus module watchdog */
 				dhd_bus_watchdog(&dhd->pub);
@@ -1427,7 +1427,7 @@ static int dhd_toe_get(dhd_info_t *dhd,
 	ioc.cmd = WLC_GET_VAR;
 	ioc.buf = buf;
 	ioc.len = (uint) sizeof(buf);
-	ioc.set = FALSE;
+	ioc.set = false;
 
 	strcpy(buf, "toe_ol");
 	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
@@ -1987,7 +1987,7 @@ dhd_pub_t *dhd_attach(osl_t *osh, struct
 	if ((dhd_watchdog_prio >= 0) && (dhd_dpc_prio >= 0))
 		dhd->threads_only = true;
 	else
-		dhd->threads_only = FALSE;
+		dhd->threads_only = false;
 
 	if (dhd_dpc_prio >= 0) {
 		/* Initialize watchdog thread */
@@ -2111,7 +2111,7 @@ int dhd_bus_start(dhd_pub_t *dhdp)
 	/* Host registration for OOB interrupt */
 	if (bcmsdh_register_oob_intr(dhdp)) {
 		del_timer_sync(&dhd->timer);
-		dhd->wd_timer_valid = FALSE;
+		dhd->wd_timer_valid = false;
 		DHD_ERROR(("%s Host failed to resgister for OOB\n", __func__));
 		return -ENODEV;
 	}
@@ -2123,7 +2123,7 @@ int dhd_bus_start(dhd_pub_t *dhdp)
 	/* If bus is not ready, can't come up */
 	if (dhd->pub.busstate != DHD_BUS_DATA) {
 		del_timer_sync(&dhd->timer);
-		dhd->wd_timer_valid = FALSE;
+		dhd->wd_timer_valid = false;
 		DHD_ERROR(("%s failed bus is not ready\n", __func__));
 		return -ENODEV;
 	}
@@ -2302,7 +2302,7 @@ void dhd_bus_detach(dhd_pub_t *dhdp)
 
 			/* Clear the watchdog timer */
 			del_timer_sync(&dhd->timer);
-			dhd->wd_timer_valid = FALSE;
+			dhd->wd_timer_valid = false;
 		}
 	}
 }
@@ -2535,7 +2535,7 @@ void dhd_os_wd_timer(void *bus, uint wdt
 	/* Totally stop the timer */
 	if (!wdtick && dhd->wd_timer_valid == true) {
 		del_timer_sync(&dhd->timer);
-		dhd->wd_timer_valid = FALSE;
+		dhd->wd_timer_valid = false;
 		save_dhd_watchdog_ms = wdtick;
 		return;
 	}
@@ -2757,7 +2757,7 @@ void dhd_wait_for_event(dhd_pub_t *dhd,
 	struct dhd_info *dhdinfo = dhd->info;
 	dhd_os_sdunlock(dhd);
 	wait_event_interruptible_timeout(dhdinfo->ctrl_wait,
-					 (*lockvar == FALSE), HZ * 2);
+					 (*lockvar == false), HZ * 2);
 	dhd_os_sdlock(dhd);
 	return;
 }
--- a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
@@ -142,7 +142,7 @@
  * bufpool was present for gspi bus.
  */
 #define PKTFREE2()		if ((bus->bus != SPI_BUS) || bus->usebufpool) \
-					PKTFREE(bus->dhd->osh, pkt, FALSE);
+					PKTFREE(bus->dhd->osh, pkt, false);
 DHD_SPINWAIT_SLEEP_INIT(sdioh_spinwait_sleep);
 extern int dhdcdc_set_ioctl(dhd_pub_t *dhd, int ifidx, uint cmd, void *buf,
 			    uint len);
@@ -305,7 +305,7 @@ typedef struct dhd_bus {
 #define CLK_PENDING	2	/* Not used yet */
 #define CLK_AVAIL	3
 
-#define DHD_NOPMU(dhd)	(FALSE)
+#define DHD_NOPMU(dhd)	(false)
 
 #ifdef DHD_DEBUG
 static int qcount[NUMPRIO];
@@ -495,7 +495,7 @@ static int dhdsdio_htclk(dhd_bus_t *bus,
 	DHD_TRACE(("%s: Enter\n", __func__));
 
 #if defined(OOB_INTR_ONLY)
-	pendok = FALSE;
+	pendok = false;
 #endif
 	clkctl = 0;
 	sdh = bus->sdh;
@@ -751,7 +751,7 @@ static int dhdsdio_clkctl(dhd_bus_t *bus
 		if (bus->clkstate == CLK_NONE)
 			dhdsdio_sdclk(bus, true);
 		else if (bus->clkstate == CLK_AVAIL)
-			dhdsdio_htclk(bus, FALSE, FALSE);
+			dhdsdio_htclk(bus, false, false);
 		else
 			DHD_ERROR(("dhdsdio_clkctl: request for %d -> %d\n",
 				   bus->clkstate, target));
@@ -761,9 +761,9 @@ static int dhdsdio_clkctl(dhd_bus_t *bus
 	case CLK_NONE:
 		/* Make sure to remove HT request */
 		if (bus->clkstate == CLK_AVAIL)
-			dhdsdio_htclk(bus, FALSE, FALSE);
+			dhdsdio_htclk(bus, false, false);
 		/* Now remove the SD clock */
-		dhdsdio_sdclk(bus, FALSE);
+		dhdsdio_sdclk(bus, false);
 		dhd_os_wd_timer(bus->dhd, 0);
 		break;
 	}
@@ -798,7 +798,7 @@ int dhdsdio_bussleep(dhd_bus_t *bus, boo
 		bcmsdh_intr_disable(bus->sdh);
 
 		/* Make sure the controller has the bus up */
-		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+		dhdsdio_clkctl(bus, CLK_AVAIL, false);
 
 		/* Tell device to start using OOB wakeup */
 		W_SDREG(SMB_USE_OOB, &regs->tosbmailbox, retries);
@@ -806,7 +806,7 @@ int dhdsdio_bussleep(dhd_bus_t *bus, boo
 			DHD_ERROR(("CANNOT SIGNAL CHIP, WILL NOT WAKE UP!!\n"));
 
 		/* Turn off our contribution to the HT clock request */
-		dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
+		dhdsdio_clkctl(bus, CLK_SDONLY, false);
 
 		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
 				 SBSDIO_FORCE_HW_CLKREQ_OFF, NULL);
@@ -835,7 +835,7 @@ int dhdsdio_bussleep(dhd_bus_t *bus, boo
 					 NULL);
 
 		/* Make sure the controller has the bus up */
-		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+		dhdsdio_clkctl(bus, CLK_AVAIL, false);
 
 		/* Send misc interrupt to indicate OOB not needed */
 		W_SDREG(0, &regs->tosbmailboxdata, retries);
@@ -846,14 +846,14 @@ int dhdsdio_bussleep(dhd_bus_t *bus, boo
 			DHD_ERROR(("CANNOT SIGNAL CHIP TO CLEAR OOB!!\n"));
 
 		/* Make sure we have SD bus access */
-		dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
+		dhdsdio_clkctl(bus, CLK_SDONLY, false);
 
 		/* Change state */
-		bus->sleeping = FALSE;
+		bus->sleeping = false;
 
 		/* Enable interrupts again */
 		if (bus->intr && (bus->dhd->busstate == DHD_BUS_DATA)) {
-			bus->intdis = FALSE;
+			bus->intdis = false;
 			bcmsdh_intr_enable(bus->sdh);
 		}
 	}
@@ -870,7 +870,7 @@ void dhd_enable_oob_intr(struct dhd_bus
 	sdpcmd_regs_t *regs = bus->regs;
 	uint retries = 0;
 
-	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+	dhdsdio_clkctl(bus, CLK_AVAIL, false);
 	if (enable == true) {
 
 		/* Tell device to start using OOB wakeup */
@@ -886,7 +886,7 @@ void dhd_enable_oob_intr(struct dhd_bus
 	}
 
 	/* Turn off our contribution to the HT clock request */
-	dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
+	dhdsdio_clkctl(bus, CLK_SDONLY, false);
 #endif				/* !defined(HW_OOB) */
 }
 #endif				/* defined(OOB_INTR_ONLY) */
@@ -894,7 +894,7 @@ void dhd_enable_oob_intr(struct dhd_bus
 #define BUS_WAKE(bus) \
 	do { \
 		if ((bus)->sleeping) \
-			dhdsdio_bussleep((bus), FALSE); \
+			dhdsdio_bussleep((bus), false); \
 	} while (0);
 
 /* Writes a HW/SW header into the packet and sends it. */
@@ -1103,9 +1103,9 @@ int dhd_bus_txdata(struct dhd_bus *bus,
 
 		/* Priority based enq */
 		dhd_os_sdlock_txq(bus->dhd);
-		if (dhd_prec_enq(bus->dhd, &bus->txq, pkt, prec) == FALSE) {
+		if (dhd_prec_enq(bus->dhd, &bus->txq, pkt, prec) == false) {
 			PKTPULL(pkt, SDPCM_HDRLEN);
-			dhd_txcomplete(bus->dhd, pkt, FALSE);
+			dhd_txcomplete(bus->dhd, pkt, false);
 			PKTFREE(osh, pkt, true);
 			DHD_ERROR(("%s: out of bus->txq !!!\n", __func__));
 			ret = BCME_NORESOURCE;
@@ -1149,7 +1149,7 @@ int dhd_bus_txdata(struct dhd_bus *bus,
 			bus->dhd->dstats.tx_bytes += datalen;
 
 		if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
-			bus->activity = FALSE;
+			bus->activity = false;
 			dhdsdio_clkctl(bus, CLK_NONE, true);
 		}
 
@@ -1273,7 +1273,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 	BUS_WAKE(bus);
 
 	/* Make sure backplane clock is on */
-	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+	dhdsdio_clkctl(bus, CLK_AVAIL, false);
 
 	/* Hardware tag: 2 byte len followed by 2 byte ~len check (all LE) */
 	*(u16 *) frame = htol16((u16) msglen);
@@ -1298,8 +1298,8 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 
 		dhd_wait_for_event(bus->dhd, &bus->ctrl_frame_stat);
 
-		if (bus->ctrl_frame_stat == FALSE) {
-			DHD_INFO(("%s: ctrl_frame_stat == FALSE\n", __func__));
+		if (bus->ctrl_frame_stat == false) {
+			DHD_INFO(("%s: ctrl_frame_stat == false\n", __func__));
 			ret = 0;
 		} else {
 			DHD_INFO(("%s: ctrl_frame_stat == true\n", __func__));
@@ -1316,7 +1316,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 #endif
 
 		do {
-			bus->ctrl_frame_stat = FALSE;
+			bus->ctrl_frame_stat = false;
 			ret =
 			    dhd_bcmsdh_send_buf(bus, bcmsdh_cur_sbwad(sdh),
 						SDIO_FUNC_2, F2SYNC, frame, len,
@@ -1360,7 +1360,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 	}
 
 	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
-		bus->activity = FALSE;
+		bus->activity = false;
 		dhdsdio_clkctl(bus, CLK_NONE, true);
 	}
 
@@ -1759,7 +1759,7 @@ static int dhdsdio_readshared(dhd_bus_t
 
 	/* Read last word in memory to determine address of
 			 sdpcm_shared structure */
-	rv = dhdsdio_membytes(bus, FALSE, bus->ramsize - 4, (u8 *)&addr, 4);
+	rv = dhdsdio_membytes(bus, false, bus->ramsize - 4, (u8 *)&addr, 4);
 	if (rv < 0)
 		return rv;
 
@@ -1778,7 +1778,7 @@ static int dhdsdio_readshared(dhd_bus_t
 	}
 
 	/* Read hndrte_shared structure */
-	rv = dhdsdio_membytes(bus, FALSE, addr, (u8 *) sh,
+	rv = dhdsdio_membytes(bus, false, addr, (u8 *) sh,
 			      sizeof(sdpcm_shared_t));
 	if (rv < 0)
 		return rv;
@@ -1871,7 +1871,7 @@ static int dhdsdio_checkdied(dhd_bus_t *
 			bcm_bprintf(&strbuf, "Dongle assert");
 			if (sdpcm_shared.assert_exp_addr != 0) {
 				str[0] = '\0';
-				bcmerror = dhdsdio_membytes(bus, FALSE,
+				bcmerror = dhdsdio_membytes(bus, false,
 						sdpcm_shared.assert_exp_addr,
 						(u8 *) str, maxstrlen);
 				if (bcmerror < 0)
@@ -1883,7 +1883,7 @@ static int dhdsdio_checkdied(dhd_bus_t *
 
 			if (sdpcm_shared.assert_file_addr != 0) {
 				str[0] = '\0';
-				bcmerror = dhdsdio_membytes(bus, FALSE,
+				bcmerror = dhdsdio_membytes(bus, false,
 						sdpcm_shared.assert_file_addr,
 						(u8 *) str, maxstrlen);
 				if (bcmerror < 0)
@@ -1898,7 +1898,7 @@ static int dhdsdio_checkdied(dhd_bus_t *
 		}
 
 		if (sdpcm_shared.flags & SDPCM_SHARED_TRAP) {
-			bcmerror = dhdsdio_membytes(bus, FALSE,
+			bcmerror = dhdsdio_membytes(bus, false,
 					sdpcm_shared.trap_addr, (u8 *)&tr,
 					sizeof(trap_t));
 			if (bcmerror < 0)
@@ -1955,7 +1955,7 @@ static int dhdsdio_mem_dump(dhd_bus_t *b
 	databuf = buf;
 	while (size) {
 		read_size = min(MEMBLOCK, size);
-		ret = dhdsdio_membytes(bus, FALSE, start, databuf, read_size);
+		ret = dhdsdio_membytes(bus, false, start, databuf, read_size);
 		if (ret) {
 			printf("%s: Error membytes %d\n", __func__, ret);
 			if (buf)
@@ -1996,7 +1996,7 @@ static int dhdsdio_readconsole(dhd_bus_t
 
 	/* Read console log struct */
 	addr = bus->console_addr + offsetof(hndrte_cons_t, log);
-	rv = dhdsdio_membytes(bus, FALSE, addr, (u8 *)&c->log,
+	rv = dhdsdio_membytes(bus, false, addr, (u8 *)&c->log,
 				sizeof(c->log));
 	if (rv < 0)
 		return rv;
@@ -2022,7 +2022,7 @@ static int dhdsdio_readconsole(dhd_bus_t
 
 	/* Read the console buffer */
 	addr = ltoh32(c->log.buf);
-	rv = dhdsdio_membytes(bus, FALSE, addr, c->buf, c->bufsize);
+	rv = dhdsdio_membytes(bus, false, addr, c->buf, c->bufsize);
 	if (rv < 0)
 		return rv;
 
@@ -2114,7 +2114,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 	if (plen >= (int)sizeof(int_val))
 		bcopy(params, &int_val, sizeof(int_val));
 
-	bool_val = (int_val != 0) ? true : FALSE;
+	bool_val = (int_val != 0) ? true : false;
 
 	/* Some ioctls use the bus */
 	dhd_os_sdlock(bus->dhd);
@@ -2140,7 +2140,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 	/* Request clock to allow SDIO accesses */
 	if (!bus->dhd->dongle_reset) {
 		BUS_WAKE(bus);
-		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+		dhdsdio_clkctl(bus, CLK_AVAIL, false);
 	}
 
 	switch (actionid) {
@@ -2151,7 +2151,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 
 	case IOV_SVAL(IOV_INTR):
 		bus->intr = bool_val;
-		bus->intdis = FALSE;
+		bus->intdis = false;
 		if (bus->dhd->up) {
 			if (bus->intr) {
 				DHD_INTR(("%s: enable SDIO device interrupts\n",
@@ -2497,13 +2497,13 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 
 exit:
 	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
-		bus->activity = FALSE;
+		bus->activity = false;
 		dhdsdio_clkctl(bus, CLK_NONE, true);
 	}
 
 	dhd_os_sdunlock(bus->dhd);
 
-	if (actionid == IOV_SVAL(IOV_DEVRESET) && bool_val == FALSE)
+	if (actionid == IOV_SVAL(IOV_DEVRESET) && bool_val == false)
 		dhd_preinit_ioctls((dhd_pub_t *) bus->dhd);
 
 	return bcmerror;
@@ -2548,7 +2548,7 @@ static int dhdsdio_write_vars(dhd_bus_t
 
 		/* Read the vars list to temp buffer for comparison */
 		bcmerror =
-		    dhdsdio_membytes(bus, FALSE, varaddr, nvram_ularray,
+		    dhdsdio_membytes(bus, false, varaddr, nvram_ularray,
 				     varsize);
 		if (bcmerror) {
 			DHD_ERROR(("%s: error %d on reading %d nvram bytes at "
@@ -2689,7 +2689,7 @@ static int dhdsdio_download_state(dhd_bu
 		}
 
 		/* Allow HT Clock now that the ARM is running. */
-		bus->alp_only = FALSE;
+		bus->alp_only = false;
 
 		bus->dhd->busstate = DHD_BUS_LOAD;
 	}
@@ -2731,7 +2731,7 @@ dhd_bus_iovar_op(dhd_pub_t *dhdp, const
 		BUS_WAKE(bus);
 
 		/* Turn on clock in case SD command needs backplane */
-		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+		dhdsdio_clkctl(bus, CLK_AVAIL, false);
 
 		bcmerror =
 		    bcmsdh_iovar_op(bus->sdh, name, params, plen, arg, len,
@@ -2743,7 +2743,7 @@ dhd_bus_iovar_op(dhd_pub_t *dhdp, const
 		if (set && strcmp(name, "sd_divisor") == 0) {
 			if (bcmsdh_iovar_op(bus->sdh, "sd_divisor", NULL, 0,
 					    &bus->sd_divisor, sizeof(s32),
-					    FALSE) != BCME_OK) {
+					    false) != BCME_OK) {
 				bus->sd_divisor = -1;
 				DHD_ERROR(("%s: fail on %s get\n", __func__,
 					   name));
@@ -2756,7 +2756,7 @@ dhd_bus_iovar_op(dhd_pub_t *dhdp, const
 		if (set && strcmp(name, "sd_mode") == 0) {
 			if (bcmsdh_iovar_op(bus->sdh, "sd_mode", NULL, 0,
 					    &bus->sd_mode, sizeof(s32),
-					    FALSE) != BCME_OK) {
+					    false) != BCME_OK) {
 				bus->sd_mode = -1;
 				DHD_ERROR(("%s: fail on %s get\n", __func__,
 					   name));
@@ -2771,7 +2771,7 @@ dhd_bus_iovar_op(dhd_pub_t *dhdp, const
 			if (bcmsdh_iovar_op
 			    (bus->sdh, "sd_blocksize", &fnum, sizeof(s32),
 			     &bus->blocksize, sizeof(s32),
-			     FALSE) != BCME_OK) {
+			     false) != BCME_OK) {
 				bus->blocksize = 0;
 				DHD_ERROR(("%s: fail on %s get\n", __func__,
 					   "sd_blocksize"));
@@ -2784,7 +2784,7 @@ dhd_bus_iovar_op(dhd_pub_t *dhdp, const
 		bus->roundup = min(max_roundup, bus->blocksize);
 
 		if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
-			bus->activity = FALSE;
+			bus->activity = false;
 			dhdsdio_clkctl(bus, CLK_NONE, true);
 		}
 
@@ -2836,7 +2836,7 @@ void dhd_bus_stop(struct dhd_bus *bus, b
 	BUS_WAKE(bus);
 
 	/* Enable clock for device interrupts */
-	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+	dhdsdio_clkctl(bus, CLK_AVAIL, false);
 
 	/* Disable and clear interrupts at the chip level also */
 	W_SDREG(0, &bus->regs->hostintmask, retries);
@@ -2869,17 +2869,17 @@ void dhd_bus_stop(struct dhd_bus *bus, b
 	W_SDREG(local_hostintmask, &bus->regs->intstatus, retries);
 
 	/* Turn off the backplane clock (only) */
-	dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
+	dhdsdio_clkctl(bus, CLK_SDONLY, false);
 
 	/* Clear the data packet queues */
 	pktq_flush(osh, &bus->txq, true);
 
 	/* Clear any held glomming stuff */
 	if (bus->glomd)
-		PKTFREE(osh, bus->glomd, FALSE);
+		PKTFREE(osh, bus->glomd, false);
 
 	if (bus->glom)
-		PKTFREE(osh, bus->glom, FALSE);
+		PKTFREE(osh, bus->glom, false);
 
 	bus->glom = bus->glomd = NULL;
 
@@ -2888,7 +2888,7 @@ void dhd_bus_stop(struct dhd_bus *bus, b
 	dhd_os_ioctl_resp_wake(bus->dhd);
 
 	/* Reset some F2 state stuff */
-	bus->rxskip = FALSE;
+	bus->rxskip = false;
 	bus->tx_seq = bus->rx_seq = 0;
 
 	if (enforce_mutex)
@@ -2914,7 +2914,7 @@ int dhd_bus_init(dhd_pub_t *dhdp, bool e
 		dhd_os_sdlock(bus->dhd);
 
 	/* Make sure backplane clock is on, needed to generate F2 interrupt */
-	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+	dhdsdio_clkctl(bus, CLK_AVAIL, false);
 	if (bus->clkstate != CLK_AVAIL)
 		goto exit;
 
@@ -2970,7 +2970,7 @@ int dhd_bus_init(dhd_pub_t *dhdp, bool e
 
 		/* bcmsdh_intr_unmask(bus->sdh); */
 
-		bus->intdis = FALSE;
+		bus->intdis = false;
 		if (bus->intr) {
 			DHD_INTR(("%s: enable SDIO device interrupts\n",
 				  __func__));
@@ -2995,7 +2995,7 @@ int dhd_bus_init(dhd_pub_t *dhdp, bool e
 
 	/* If we didn't come up, turn off backplane clock */
 	if (dhdp->busstate != DHD_BUS_DATA)
-		dhdsdio_clkctl(bus, CLK_NONE, FALSE);
+		dhdsdio_clkctl(bus, CLK_NONE, false);
 
 exit:
 	if (enforce_mutex)
@@ -3124,7 +3124,7 @@ dhdsdio_read_control(dhd_bus_t *bus, u8
 		DHD_ERROR(("%s: %d-byte control read exceeds %d-byte buffer\n",
 			   __func__, rdlen, bus->dhd->maxctl));
 		bus->dhd->rx_errors++;
-		dhdsdio_rxfail(bus, FALSE, FALSE);
+		dhdsdio_rxfail(bus, false, false);
 		goto done;
 	}
 
@@ -3134,7 +3134,7 @@ dhdsdio_read_control(dhd_bus_t *bus, u8
 			__func__, len, (len - doff), bus->dhd->maxctl));
 		bus->dhd->rx_errors++;
 		bus->rx_toolong++;
-		dhdsdio_rxfail(bus, FALSE, FALSE);
+		dhdsdio_rxfail(bus, false, false);
 		goto done;
 	}
 
@@ -3221,7 +3221,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 			if (sublen % DHD_SDALIGN) {
 				DHD_ERROR(("%s: sublen %d not multiple of %d\n",
 				__func__, sublen, DHD_SDALIGN));
-				usechain = FALSE;
+				usechain = false;
 			}
 			totlen += sublen;
 
@@ -3234,7 +3234,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 			}
 
 			/* Allocate/chain packet for next subframe */
-			pnext = PKTGET(osh, sublen + DHD_SDALIGN, FALSE);
+			pnext = PKTGET(osh, sublen + DHD_SDALIGN, false);
 			if (pnext == NULL) {
 				DHD_ERROR(("%s: PKTGET failed, num %d len %d\n",
 					   __func__, num, sublen));
@@ -3270,13 +3270,13 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 			pfirst = pnext = NULL;
 		} else {
 			if (pfirst)
-				PKTFREE(osh, pfirst, FALSE);
+				PKTFREE(osh, pfirst, false);
 			bus->glom = NULL;
 			num = 0;
 		}
 
 		/* Done with descriptor packet */
-		PKTFREE(osh, bus->glomd, FALSE);
+		PKTFREE(osh, bus->glomd, false);
 		bus->glomd = NULL;
 		bus->nextlen = 0;
 
@@ -3343,9 +3343,9 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 				dhdsdio_rxfail(bus, true, true);
 			} else {
 				bus->glomerr = 0;
-				dhdsdio_rxfail(bus, true, FALSE);
+				dhdsdio_rxfail(bus, true, false);
 				dhd_os_sdlock_rxq(bus->dhd);
-				PKTFREE(osh, bus->glom, FALSE);
+				PKTFREE(osh, bus->glom, false);
 				dhd_os_sdunlock_rxq(bus->dhd);
 				bus->rxglomfail++;
 				bus->glom = NULL;
@@ -3472,9 +3472,9 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 				dhdsdio_rxfail(bus, true, true);
 			} else {
 				bus->glomerr = 0;
-				dhdsdio_rxfail(bus, true, FALSE);
+				dhdsdio_rxfail(bus, true, false);
 				dhd_os_sdlock_rxq(bus->dhd);
-				PKTFREE(osh, bus->glom, FALSE);
+				PKTFREE(osh, bus->glom, false);
 				dhd_os_sdunlock_rxq(bus->dhd);
 				bus->rxglomfail++;
 				bus->glom = NULL;
@@ -3522,7 +3522,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 			PKTPULL(pfirst, doff);
 
 			if (PKTLEN(pfirst) == 0) {
-				PKTFREE(bus->dhd->osh, pfirst, FALSE);
+				PKTFREE(bus->dhd->osh, pfirst, false);
 				if (plast) {
 					PKTSETNEXT(plast, pnext);
 				} else {
@@ -3535,7 +3535,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 				DHD_ERROR(("%s: rx protocol error\n",
 					   __func__));
 				bus->dhd->rx_errors++;
-				PKTFREE(osh, pfirst, FALSE);
+				PKTFREE(osh, pfirst, false);
 				if (plast) {
 					PKTSETNEXT(plast, pnext);
 				} else {
@@ -3601,7 +3601,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 	uint rxcount = 0;	/* Total frames read */
 
 #if defined(DHD_DEBUG) || defined(SDTEST)
-	bool sdtest = FALSE;	/* To limit message spew from test mode */
+	bool sdtest = false;	/* To limit message spew from test mode */
 #endif
 
 	DHD_TRACE(("%s: Enter\n", __func__));
@@ -3617,7 +3617,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 #endif
 
 	/* Not finished unless we encounter no more frames indication */
-	*finished = FALSE;
+	*finished = false;
 
 	for (rxseq = bus->rx_seq, rxleft = maxframes;
 	     !bus->rxskip && rxleft && bus->dhd->busstate != DHD_BUS_DOWN;
@@ -3674,10 +3674,10 @@ static uint dhdsdio_readframes(dhd_bus_t
 			 */
 			/* Allocate a packet buffer */
 			dhd_os_sdlock_rxq(bus->dhd);
-			pkt = PKTGET(osh, rdlen + DHD_SDALIGN, FALSE);
+			pkt = PKTGET(osh, rdlen + DHD_SDALIGN, false);
 			if (!pkt) {
 				if (bus->bus == SPI_BUS) {
-					bus->usebufpool = FALSE;
+					bus->usebufpool = false;
 					bus->rxctl = bus->rxbuf;
 					if (dhd_alignctl) {
 						bus->rxctl += firstread;
@@ -3713,7 +3713,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 						dhd_os_sdunlock_rxq(bus->dhd);
 						dhdsdio_rxfail(bus, true,
 						       (bus->bus ==
-							SPI_BUS) ? FALSE
+							SPI_BUS) ? false
 						       : true);
 						continue;
 					}
@@ -3747,7 +3747,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 				if (sdret < 0) {
 					DHD_ERROR(("%s (nextlen): read %d bytes failed: %d\n",
 						__func__, rdlen, sdret));
-					PKTFREE(bus->dhd->osh, pkt, FALSE);
+					PKTFREE(bus->dhd->osh, pkt, false);
 					bus->dhd->rx_errors++;
 					dhd_os_sdunlock_rxq(bus->dhd);
 					/* Force retry w/normal header read.
@@ -3756,7 +3756,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 					 */
 					dhdsdio_rxfail(bus, true,
 						       (bus->bus ==
-							SPI_BUS) ? FALSE :
+							SPI_BUS) ? false :
 						       true);
 					continue;
 				}
@@ -3789,7 +3789,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 				PKTFREE2();
 				dhd_os_sdunlock_rxq(bus->dhd);
 				bus->rx_badhdr++;
-				dhdsdio_rxfail(bus, FALSE, FALSE);
+				dhdsdio_rxfail(bus, false, false);
 				GSPI_PR55150_BAILOUT;
 				continue;
 			}
@@ -3818,7 +3818,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 				dhd_os_sdunlock_rxq(bus->dhd);
 				dhdsdio_rxfail(bus, true,
 					       (bus->bus ==
-						SPI_BUS) ? FALSE : true);
+						SPI_BUS) ? false : true);
 				GSPI_PR55150_BAILOUT;
 				continue;
 			}
@@ -3896,7 +3896,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 					if (bus->usebufpool) {
 						dhd_os_sdlock_rxq(bus->dhd);
 						PKTFREE(bus->dhd->osh, pkt,
-							FALSE);
+							false);
 						dhd_os_sdunlock_rxq(bus->dhd);
 					}
 					continue;
@@ -3905,7 +3905,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 						__func__, seq));
 					/* Force retry w/normal header read */
 					bus->nextlen = 0;
-					dhdsdio_rxfail(bus, FALSE, true);
+					dhdsdio_rxfail(bus, false, true);
 					dhd_os_sdlock_rxq(bus->dhd);
 					PKTFREE2();
 					dhd_os_sdunlock_rxq(bus->dhd);
@@ -3927,7 +3927,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 				PKTFREE2();
 				dhd_os_sdunlock_rxq(bus->dhd);
 				ASSERT(0);
-				dhdsdio_rxfail(bus, FALSE, FALSE);
+				dhdsdio_rxfail(bus, false, false);
 				continue;
 			}
 
@@ -3973,7 +3973,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 			DHD_ERROR(("%s: HW hdr err: len/check 0x%04x/0x%04x\n",
 				__func__, len, check));
 			bus->rx_badhdr++;
-			dhdsdio_rxfail(bus, FALSE, FALSE);
+			dhdsdio_rxfail(bus, false, false);
 			continue;
 		}
 
@@ -3997,7 +3997,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 				__func__, doff, len, SDPCM_HDRLEN, seq));
 			bus->rx_badhdr++;
 			ASSERT(0);
-			dhdsdio_rxfail(bus, FALSE, FALSE);
+			dhdsdio_rxfail(bus, false, false);
 			continue;
 		}
 
@@ -4080,19 +4080,19 @@ static uint dhdsdio_readframes(dhd_bus_t
 				   __func__, len, rdlen));
 			bus->dhd->rx_errors++;
 			bus->rx_toolong++;
-			dhdsdio_rxfail(bus, FALSE, FALSE);
+			dhdsdio_rxfail(bus, false, false);
 			continue;
 		}
 
 		dhd_os_sdlock_rxq(bus->dhd);
-		pkt = PKTGET(osh, (rdlen + firstread + DHD_SDALIGN), FALSE);
+		pkt = PKTGET(osh, (rdlen + firstread + DHD_SDALIGN), false);
 		if (!pkt) {
 			/* Give up on data, request rtx of events */
 			DHD_ERROR(("%s: PKTGET failed: rdlen %d chan %d\n",
 				   __func__, rdlen, chan));
 			bus->dhd->rx_dropped++;
 			dhd_os_sdunlock_rxq(bus->dhd);
-			dhdsdio_rxfail(bus, FALSE, RETRYCHAN(chan));
+			dhdsdio_rxfail(bus, false, RETRYCHAN(chan));
 			continue;
 		}
 		dhd_os_sdunlock_rxq(bus->dhd);
@@ -4121,7 +4121,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 				       ? "data" : "test")),
 				   sdret));
 			dhd_os_sdlock_rxq(bus->dhd);
-			PKTFREE(bus->dhd->osh, pkt, FALSE);
+			PKTFREE(bus->dhd->osh, pkt, false);
 			dhd_os_sdunlock_rxq(bus->dhd);
 			bus->dhd->rx_errors++;
 			dhdsdio_rxfail(bus, true, RETRYCHAN(chan));
@@ -4155,7 +4155,7 @@ deliver:
 			} else {
 				DHD_ERROR(("%s: glom superframe w/o "
 					"descriptor!\n", __func__));
-				dhdsdio_rxfail(bus, FALSE, FALSE);
+				dhdsdio_rxfail(bus, false, false);
 			}
 			continue;
 		}
@@ -4174,13 +4174,13 @@ deliver:
 
 		if (PKTLEN(pkt) == 0) {
 			dhd_os_sdlock_rxq(bus->dhd);
-			PKTFREE(bus->dhd->osh, pkt, FALSE);
+			PKTFREE(bus->dhd->osh, pkt, false);
 			dhd_os_sdunlock_rxq(bus->dhd);
 			continue;
 		} else if (dhd_prot_hdrpull(bus->dhd, &ifidx, pkt) != 0) {
 			DHD_ERROR(("%s: rx protocol error\n", __func__));
 			dhd_os_sdlock_rxq(bus->dhd);
-			PKTFREE(bus->dhd->osh, pkt, FALSE);
+			PKTFREE(bus->dhd->osh, pkt, false);
 			dhd_os_sdunlock_rxq(bus->dhd);
 			bus->dhd->rx_errors++;
 			continue;
@@ -4231,7 +4231,7 @@ static u32 dhdsdio_hostmail(dhd_bus_t *b
 		if (!bus->rxskip)
 			DHD_ERROR(("%s: unexpected NAKHANDLED!\n", __func__));
 
-		bus->rxskip = FALSE;
+		bus->rxskip = false;
 		intstatus |= I_HMB_FRAME_IND;
 	}
 
@@ -4292,7 +4292,7 @@ bool dhdsdio_dpc(dhd_bus_t *bus)
 	uint txlimit = dhd_txbound;	/* Tx frames to send before resched */
 	uint framecnt = 0;	/* Temporary counter of tx/rx frames */
 	bool rxdone = true;	/* Flag for no more read data */
-	bool resched = FALSE;	/* Flag indicating resched wanted */
+	bool resched = false;	/* Flag indicating resched wanted */
 
 	DHD_TRACE(("%s: Enter\n", __func__));
 
@@ -4364,7 +4364,7 @@ bool dhdsdio_dpc(dhd_bus_t *bus)
 
 	/* Pending interrupt indicates new device status */
 	if (bus->ipend) {
-		bus->ipend = FALSE;
+		bus->ipend = false;
 		R_SDREG(newstatus, &regs->intstatus, retries);
 		bus->f1regdata++;
 		if (bcmsdh_regfail(bus->sdh))
@@ -4449,7 +4449,7 @@ clkwait:
 	if (bus->intr && bus->intdis && !bcmsdh_regfail(sdh)) {
 		DHD_INTR(("%s: enable SDIO interrupts, rxdone %d framecnt %d\n",
 			  __func__, rxdone, framecnt));
-		bus->intdis = FALSE;
+		bus->intdis = false;
 		bcmsdh_intr_enable(sdh);
 	}
 
@@ -4496,7 +4496,7 @@ clkwait:
 			bus->tx_seq = (bus->tx_seq + 1) % SDPCM_SEQUENCE_WRAP;
 
 		printf("Return_dpc value is : %d\n", ret);
-		bus->ctrl_frame_stat = FALSE;
+		bus->ctrl_frame_stat = false;
 		dhd_wait_event_wakeup(bus->dhd);
 	}
 	/* Send queued frames (limit 1 if rx may still be pending) */
@@ -4532,8 +4532,8 @@ clkwait:
 	/* If we're done for now, turn off clock request. */
 	if ((bus->clkstate != CLK_PENDING)
 	    && bus->idletime == DHD_IDLE_IMMEDIATE) {
-		bus->activity = FALSE;
-		dhdsdio_clkctl(bus, CLK_NONE, FALSE);
+		bus->activity = false;
+		dhdsdio_clkctl(bus, CLK_NONE, false);
 	}
 
 	dhd_os_sdunlock(bus->dhd);
@@ -4773,7 +4773,7 @@ static void dhdsdio_testrcv(dhd_bus_t *b
 	if (pktlen < SDPCM_TEST_HDRLEN) {
 		DHD_ERROR(("dhdsdio_restrcv: toss runt frame, pktlen %d\n",
 			   pktlen));
-		PKTFREE(osh, pkt, FALSE);
+		PKTFREE(osh, pkt, false);
 		return;
 	}
 
@@ -4791,7 +4791,7 @@ static void dhdsdio_testrcv(dhd_bus_t *b
 			DHD_ERROR(("dhdsdio_testrcv: frame length mismatch, "
 				"pktlen %d seq %d" " cmd %d extra %d len %d\n",
 				pktlen, seq, cmd, extra, len));
-			PKTFREE(osh, pkt, FALSE);
+			PKTFREE(osh, pkt, false);
 			return;
 		}
 	}
@@ -4806,14 +4806,14 @@ static void dhdsdio_testrcv(dhd_bus_t *b
 			bus->pktgen_sent++;
 		} else {
 			bus->pktgen_fail++;
-			PKTFREE(osh, pkt, FALSE);
+			PKTFREE(osh, pkt, false);
 		}
 		bus->pktgen_rcvd++;
 		break;
 
 	case SDPCM_TEST_ECHORSP:
 		if (bus->ext_loop) {
-			PKTFREE(osh, pkt, FALSE);
+			PKTFREE(osh, pkt, false);
 			bus->pktgen_rcvd++;
 			break;
 		}
@@ -4826,12 +4826,12 @@ static void dhdsdio_testrcv(dhd_bus_t *b
 				break;
 			}
 		}
-		PKTFREE(osh, pkt, FALSE);
+		PKTFREE(osh, pkt, false);
 		bus->pktgen_rcvd++;
 		break;
 
 	case SDPCM_TEST_DISCARD:
-		PKTFREE(osh, pkt, FALSE);
+		PKTFREE(osh, pkt, false);
 		bus->pktgen_rcvd++;
 		break;
 
@@ -4841,7 +4841,7 @@ static void dhdsdio_testrcv(dhd_bus_t *b
 		DHD_INFO(("dhdsdio_testrcv: unsupported or unknown command, "
 			"pktlen %d seq %d" " cmd %d extra %d len %d\n",
 			pktlen, seq, cmd, extra, len));
-		PKTFREE(osh, pkt, FALSE);
+		PKTFREE(osh, pkt, false);
 		break;
 	}
 
@@ -4850,7 +4850,7 @@ static void dhdsdio_testrcv(dhd_bus_t *b
 		if (bus->pktgen_total
 		    && (bus->pktgen_rcvd >= bus->pktgen_total)) {
 			bus->pktgen_count = 0;
-			dhdsdio_sdtest_set(bus, FALSE);
+			dhdsdio_sdtest_set(bus, false);
 		}
 	}
 }
@@ -4865,11 +4865,11 @@ extern bool dhd_bus_watchdog(dhd_pub_t *
 	bus = dhdp->bus;
 
 	if (bus->dhd->dongle_reset)
-		return FALSE;
+		return false;
 
 	/* Ignore the timer if simulating bus down */
 	if (bus->sleeping)
-		return FALSE;
+		return false;
 
 	dhd_os_sdlock(bus->dhd);
 
@@ -4917,7 +4917,7 @@ extern bool dhd_bus_watchdog(dhd_pub_t *
 		if (bus->console.count >= dhd_console_ms) {
 			bus->console.count -= dhd_console_ms;
 			/* Make sure backplane clock is on */
-			dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+			dhdsdio_clkctl(bus, CLK_AVAIL, false);
 			if (dhdsdio_readconsole(bus) < 0)
 				dhd_console_ms = 0;	/* On error,
 							 stop trying */
@@ -4929,7 +4929,7 @@ extern bool dhd_bus_watchdog(dhd_pub_t *
 	/* Generate packets if configured */
 	if (bus->pktgen_count && (++bus->pktgen_tick >= bus->pktgen_freq)) {
 		/* Make sure backplane clock is on */
-		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+		dhdsdio_clkctl(bus, CLK_AVAIL, false);
 		bus->pktgen_tick = 0;
 		dhdsdio_pktgen(bus);
 	}
@@ -4940,10 +4940,10 @@ extern bool dhd_bus_watchdog(dhd_pub_t *
 		if (++bus->idlecount >= bus->idletime) {
 			bus->idlecount = 0;
 			if (bus->activity) {
-				bus->activity = FALSE;
+				bus->activity = false;
 				dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
 			} else {
-				dhdsdio_clkctl(bus, CLK_NONE, FALSE);
+				dhdsdio_clkctl(bus, CLK_NONE, false);
 			}
 		}
 	}
@@ -4977,7 +4977,7 @@ extern int dhd_bus_console_in(dhd_pub_t
 	/* Request clock to allow SDIO accesses */
 	BUS_WAKE(bus);
 	/* No pend allowed since txpkt is called later, ht clk has to be on */
-	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+	dhdsdio_clkctl(bus, CLK_AVAIL, false);
 
 	/* Zero cbuf_index */
 	addr = bus->console_addr + offsetof(hndrte_cons_t, cbuf_idx);
@@ -5008,7 +5008,7 @@ extern int dhd_bus_console_in(dhd_pub_t
 
 done:
 	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
-		bus->activity = FALSE;
+		bus->activity = false;
 		dhdsdio_clkctl(bus, CLK_NONE, true);
 	}
 
@@ -5055,7 +5055,7 @@ static bool dhdsdio_chipmatch(u16 chipid
 		return true;
 	if (chipid == BCM4319_CHIP_ID)
 		return true;
-	return FALSE;
+	return false;
 }
 
 static void *dhdsdio_probe(u16 venid, u16 devid, u16 bus_no,
@@ -5078,8 +5078,8 @@ static void *dhdsdio_probe(u16 venid, u1
 	dhd_alignctl = true;
 	sd1idle = true;
 	dhd_readahead = true;
-	retrydata = FALSE;
-	dhd_doflow = FALSE;
+	retrydata = false;
+	dhd_doflow = false;
 	dhd_dongle_memsize = 0;
 	dhd_txminmax = DHD_TXMINMAX;
 
@@ -5157,7 +5157,7 @@ static void *dhdsdio_probe(u16 venid, u1
 	bus->cl_devid = (u16) devid;
 	bus->bus = DHD_BUS;
 	bus->tx_seq = SDPCM_SEQUENCE_WRAP - 1;
-	bus->usebufpool = FALSE;	/* Use bufpool if allocated,
+	bus->usebufpool = false;	/* Use bufpool if allocated,
 					 else use locally malloced rxbuf */
 
 	/* attempt to attach to the dongle */
@@ -5375,7 +5375,7 @@ dhdsdio_probe_attach(struct dhd_bus *bus
 	return true;
 
 fail:
-	return FALSE;
+	return false;
 }
 
 static bool dhdsdio_probe_malloc(dhd_bus_t *bus, osl_t *osh, void *sdh)
@@ -5437,7 +5437,7 @@ static bool dhdsdio_probe_malloc(dhd_bus
 	return true;
 
 fail:
-	return FALSE;
+	return false;
 }
 
 static bool dhdsdio_probe_init(dhd_bus_t *bus, osl_t *osh, void *sdh)
@@ -5455,8 +5455,8 @@ static bool dhdsdio_probe_init(dhd_bus_t
 			 NULL);
 
 	bus->dhd->busstate = DHD_BUS_DOWN;
-	bus->sleeping = FALSE;
-	bus->rxflow = FALSE;
+	bus->sleeping = false;
+	bus->rxflow = false;
 	bus->prev_rxlim_hit = 0;
 
 	/* Done with backplane-dependent accesses, can drop clock... */
@@ -5470,7 +5470,7 @@ static bool dhdsdio_probe_init(dhd_bus_t
 	/* Query the SD clock speed */
 	if (bcmsdh_iovar_op(sdh, "sd_divisor", NULL, 0,
 			    &bus->sd_divisor, sizeof(s32),
-			    FALSE) != BCME_OK) {
+			    false) != BCME_OK) {
 		DHD_ERROR(("%s: fail on %s get\n", __func__, "sd_divisor"));
 		bus->sd_divisor = -1;
 	} else {
@@ -5480,7 +5480,7 @@ static bool dhdsdio_probe_init(dhd_bus_t
 
 	/* Query the SD bus mode */
 	if (bcmsdh_iovar_op(sdh, "sd_mode", NULL, 0,
-			    &bus->sd_mode, sizeof(s32), FALSE) != BCME_OK) {
+			    &bus->sd_mode, sizeof(s32), false) != BCME_OK) {
 		DHD_ERROR(("%s: fail on %s get\n", __func__, "sd_mode"));
 		bus->sd_mode = -1;
 	} else {
@@ -5491,7 +5491,7 @@ static bool dhdsdio_probe_init(dhd_bus_t
 	/* Query the F2 block size, set roundup accordingly */
 	fnum = 2;
 	if (bcmsdh_iovar_op(sdh, "sd_blocksize", &fnum, sizeof(s32),
-			    &bus->blocksize, sizeof(s32), FALSE) != BCME_OK) {
+			    &bus->blocksize, sizeof(s32), false) != BCME_OK) {
 		bus->blocksize = 0;
 		DHD_ERROR(("%s: fail on %s get\n", __func__, "sd_blocksize"));
 	} else {
@@ -5504,8 +5504,8 @@ static bool dhdsdio_probe_init(dhd_bus_t
 		 default to use if supported */
 	if (bcmsdh_iovar_op(sdh, "sd_rxchain", NULL, 0,
 			    &bus->sd_rxchain, sizeof(s32),
-			    FALSE) != BCME_OK) {
-		bus->sd_rxchain = FALSE;
+			    false) != BCME_OK) {
+		bus->sd_rxchain = false;
 	} else {
 		DHD_INFO(("%s: bus module (through bcmsdh API) %s chaining\n",
 			  __func__,
@@ -5535,11 +5535,11 @@ dhdsdio_download_firmware(struct dhd_bus
 	bool ret;
 
 	/* Download the firmware */
-	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+	dhdsdio_clkctl(bus, CLK_AVAIL, false);
 
 	ret = _dhdsdio_download_firmware(bus) == 0;
 
-	dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
+	dhdsdio_clkctl(bus, CLK_SDONLY, false);
 
 	return ret;
 }
@@ -5606,11 +5606,11 @@ static void dhdsdio_release_dongle(dhd_b
 		return;
 
 	if (bus->sih) {
-		dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
+		dhdsdio_clkctl(bus, CLK_AVAIL, false);
 #if !defined(BCMLXSDMMC)
 		si_watchdog(bus->sih, 4);
 #endif				/* !defined(BCMLXSDMMC) */
-		dhdsdio_clkctl(bus, CLK_NONE, FALSE);
+		dhdsdio_clkctl(bus, CLK_NONE, false);
 		si_detach(bus->sih);
 		if (bus->vars && bus->varsz)
 			MFREE(osh, bus->vars, bus->varsz);
@@ -5703,7 +5703,7 @@ static int dhdsdio_download_code_array(s
 		memset(ularray, 0xaa, bus->ramsize);
 		while ((offset + MEMBLOCK) < sizeof(dlarray)) {
 			bcmerror =
-			    dhdsdio_membytes(bus, FALSE, offset,
+			    dhdsdio_membytes(bus, false, offset,
 					     ularray + offset, MEMBLOCK);
 			if (bcmerror) {
 				DHD_ERROR(("%s: error %d on reading %d membytes"
@@ -5716,7 +5716,7 @@ static int dhdsdio_download_code_array(s
 		}
 
 		if (offset < sizeof(dlarray)) {
-			bcmerror = dhdsdio_membytes(bus, FALSE, offset,
+			bcmerror = dhdsdio_membytes(bus, false, offset,
 						    ularray + offset,
 						    sizeof(dlarray) - offset);
 			if (bcmerror) {
@@ -5810,7 +5810,7 @@ static uint process_nvram_vars(char *var
 
 	dp = varbuf;
 
-	findNewline = FALSE;
+	findNewline = false;
 	column = 0;
 
 	for (n = 0; n < len; n++) {
@@ -5820,7 +5820,7 @@ static uint process_nvram_vars(char *var
 			continue;
 		if (findNewline && varbuf[n] != '\n')
 			continue;
-		findNewline = FALSE;
+		findNewline = false;
 		if (varbuf[n] == '#') {
 			findNewline = true;
 			continue;
@@ -5936,8 +5936,8 @@ static int _dhdsdio_download_firmware(st
 {
 	int bcmerror = -1;
 
-	bool embed = FALSE;	/* download embedded firmware */
-	bool dlok = FALSE;	/* download firmware succeeded */
+	bool embed = false;	/* download embedded firmware */
+	bool dlok = false;	/* download firmware succeeded */
 
 	/* Out immediately if no image to download */
 	if ((bus->fw_path == NULL) || (bus->fw_path[0] == '\0')) {
@@ -5965,7 +5965,7 @@ static int _dhdsdio_download_firmware(st
 			goto err;
 #endif
 		} else {
-			embed = FALSE;
+			embed = false;
 			dlok = true;
 		}
 	}
@@ -5997,7 +5997,7 @@ static int _dhdsdio_download_firmware(st
 	}
 
 	/* Take arm out of reset */
-	if (dhdsdio_download_state(bus, FALSE)) {
+	if (dhdsdio_download_state(bus, false)) {
 		DHD_ERROR(("%s: error getting out of ARM core reset\n",
 			   __func__));
 		goto err;
@@ -6066,14 +6066,14 @@ int dhd_bus_devreset(dhd_pub_t *dhdp, u8
 			/* Expect app to have torn down any
 			 connection before calling */
 			/* Stop the bus, disable F2 */
-			dhd_bus_stop(bus, FALSE);
+			dhd_bus_stop(bus, false);
 
 			/* Clean tx/rx buffer pointers,
 			 detach from the dongle */
 			dhdsdio_release_dongle(bus, bus->dhd->osh);
 
 			bus->dhd->dongle_reset = true;
-			bus->dhd->up = FALSE;
+			bus->dhd->up = false;
 
 			DHD_TRACE(("%s:  WLAN OFF DONE\n", __func__));
 			/* App can now remove power from device */
@@ -6102,13 +6102,13 @@ int dhd_bus_devreset(dhd_pub_t *dhdp, u8
 
 					/* Re-init bus, enable F2 transfer */
 					dhd_bus_init((dhd_pub_t *) bus->dhd,
-						     FALSE);
+						     false);
 
 #if defined(OOB_INTR_ONLY)
 					dhd_enable_oob_intr(bus, true);
 #endif				/* defined(OOB_INTR_ONLY) */
 
-					bus->dhd->dongle_reset = FALSE;
+					bus->dhd->dongle_reset = false;
 					bus->dhd->up = true;
 
 					DHD_TRACE(("%s: WLAN ON DONE\n",
@@ -6119,7 +6119,7 @@ int dhd_bus_devreset(dhd_pub_t *dhdp, u8
 				bcmerror = BCME_SDIO_ERROR;
 		} else {
 			bcmerror = BCME_NOTDOWN;
-			DHD_ERROR(("%s: Set DEVRESET=FALSE invoked when device "
+			DHD_ERROR(("%s: Set DEVRESET=false invoked when device "
 				"is on\n", __func__));
 			bcmerror = BCME_SDIO_ERROR;
 		}
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
@@ -780,8 +780,8 @@ __wl_cfg80211_scan(struct wiphy *wiphy,
 		return -EAGAIN;
 	}
 
-	iscan_req = FALSE;
-	spec_scan = FALSE;
+	iscan_req = false;
+	spec_scan = false;
 	if (request) {		/* scan bss */
 		ssids = request->ssids;
 		if (wl->iscan_on && (!ssids || !ssids->ssid_len)) {	/* for
@@ -984,7 +984,7 @@ static s32 wl_cfg80211_set_wiphy_params(
 	if (changed & WIPHY_PARAM_RETRY_SHORT
 	    && (wl->conf->retry_short != wiphy->retry_short)) {
 		wl->conf->retry_short = wiphy->retry_short;
-		err = wl_set_retry(ndev, wl->conf->retry_short, FALSE);
+		err = wl_set_retry(ndev, wl->conf->retry_short, false);
 		if (!err) {
 			return err;
 		}
@@ -1032,7 +1032,7 @@ wl_cfg80211_join_ibss(struct wiphy *wiph
 					params->ssid, params->ssid_len);
 	}
 	if (bss) {
-		wl->ibss_starter = FALSE;
+		wl->ibss_starter = false;
 		WL_DBG(("Found IBSS\n"));
 	} else {
 		wl->ibss_starter = true;
@@ -1404,7 +1404,7 @@ wl_cfg80211_disconnect(struct wiphy *wip
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	scb_val_t scbval;
-	bool act = FALSE;
+	bool act = false;
 	s32 err = 0;
 
 	WL_DBG(("Reason %d\n", reason_code));
@@ -2344,7 +2344,7 @@ static bool wl_is_linkup(struct wl_priv
 		}
 	}
 
-	return FALSE;
+	return false;
 }
 
 static bool wl_is_linkdown(struct wl_priv *wl, const wl_event_msg_t *e)
@@ -2359,7 +2359,7 @@ static bool wl_is_linkdown(struct wl_pri
 			return true;
 	}
 
-	return FALSE;
+	return false;
 }
 
 static bool wl_is_nonetwork(struct wl_priv *wl, const wl_event_msg_t *e)
@@ -2372,7 +2372,7 @@ static bool wl_is_nonetwork(struct wl_pr
 			return true;
 	}
 
-	return FALSE;
+	return false;
 }
 
 static s32
@@ -2402,7 +2402,7 @@ wl_notify_connect_status(struct wl_priv
 		wl_link_down(wl);
 		wl_init_prof(wl->profile);
 	} else if (wl_is_nonetwork(wl, e)) {
-		wl_bss_connect_done(wl, ndev, e, data, FALSE);
+		wl_bss_connect_done(wl, ndev, e, data, false);
 	}
 
 	return err;
@@ -2710,7 +2710,7 @@ wl_notify_scan_status(struct wl_priv *wl
 
 scan_done_out:
 	if (wl->scan_request) {
-		cfg80211_scan_done(wl->scan_request, FALSE);
+		cfg80211_scan_done(wl->scan_request, false);
 		wl_set_mpc(ndev, 1);
 		wl->scan_request = NULL;
 	}
@@ -2879,7 +2879,7 @@ static void wl_notify_iscan_complete(str
 		wl_set_mpc(ndev, 1);
 		wl->scan_request = NULL;
 	}
-	wl->iscan_kickstart = FALSE;
+	wl->iscan_kickstart = false;
 }
 
 static s32 wl_wakeup_iscan(struct wl_iscan_ctrl *iscan)
@@ -2937,7 +2937,7 @@ static s32 wl_iscan_done(struct wl_priv
 	iscan->state = WL_ISCAN_STATE_IDLE;
 	rtnl_lock();
 	wl_inform_bss(wl);
-	wl_notify_iscan_complete(iscan, FALSE);
+	wl_notify_iscan_complete(iscan, false);
 	rtnl_unlock();
 
 	return err;
@@ -3102,19 +3102,19 @@ static s32 wl_init_priv(struct wl_priv *
 	wl->iscan_on = true;	/* iscan on & off switch.
 				 we enable iscan per default */
 #else
-	wl->iscan_on = FALSE;
+	wl->iscan_on = false;
 #endif				/* WL_ISCAN_DISABLED */
 #ifndef WL_ROAM_DISABLED
 	wl->roam_on = true;	/* roam on & off switch.
 				 we enable roam per default */
 #else
-	wl->roam_on = FALSE;
+	wl->roam_on = false;
 #endif				/* WL_ROAM_DISABLED */
 
-	wl->iscan_kickstart = FALSE;
+	wl->iscan_kickstart = false;
 	wl->active_scan = true;	/* we do active scan for
 				 specific scan per default */
-	wl->dongle_up = FALSE;	/* dongle is not up yet */
+	wl->dongle_up = false;	/* dongle is not up yet */
 	wl_init_eq(wl);
 	err = wl_init_priv_mem(wl);
 	if (unlikely(err))
@@ -3137,7 +3137,7 @@ static s32 wl_init_priv(struct wl_priv *
 static void wl_deinit_priv(struct wl_priv *wl)
 {
 	wl_destroy_event_handler(wl);
-	wl->dongle_up = FALSE;	/* dongle down */
+	wl->dongle_up = false;	/* dongle down */
 	wl_flush_eq(wl);
 	wl_link_down(wl);
 	wl_term_iscan(wl);
@@ -3776,7 +3776,7 @@ static s32 __wl_cfg80211_up(struct wl_pr
 {
 	s32 err = 0;
 
-	err = wl_config_dongle(wl, FALSE);
+	err = wl_config_dongle(wl, false);
 	if (unlikely(err))
 		return err;
 
@@ -3989,7 +3989,7 @@ static void wl_link_down(struct wl_priv
 {
 	struct wl_connect_info *conn_info = wl_to_conn(wl);
 
-	wl->link_up = FALSE;
+	wl->link_up = false;
 	kfree(conn_info->req_ie);
 	conn_info->req_ie = NULL;
 	conn_info->req_ie_len = 0;
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -1175,7 +1175,7 @@ static int _iscan_sysioc_thread(void *da
 {
 	u32 status;
 	iscan_info_t *iscan = (iscan_info_t *) data;
-	static bool iscan_pass_abort = FALSE;
+	static bool iscan_pass_abort = false;
 
 	status = WL_SCAN_RESULTS_PARTIAL;
 	while (down_interruptible(&iscan->sysioc_sem) == 0) {
@@ -1193,7 +1193,7 @@ static int _iscan_sysioc_thread(void *da
 			WL_TRACE(("%s Get results from specific scan "
 				"status = %d\n", __func__, status));
 			wl_iw_send_scan_complete(iscan);
-			iscan_pass_abort = FALSE;
+			iscan_pass_abort = false;
 			status = -1;
 		}
 
@@ -1255,7 +1255,7 @@ wl_iw_set_scan(struct net_device *dev,
 	int error;
 	WL_TRACE(("\n:%s dev:%s: SIOCSIWSCAN : SCAN\n", __func__, dev->name));
 
-	g_set_essid_before_scan = FALSE;
+	g_set_essid_before_scan = false;
 #if defined(CSCAN)
 	WL_ERROR(("%s: Scan from SIOCGIWSCAN not supported\n", __func__));
 	return -EINVAL;
@@ -1413,7 +1413,7 @@ static bool ie_is_wpa_ie(u8 **wpaie, u8
 	ie += ie[1] + 2;
 	*tlvs_len -= (int)(ie - *tlvs);
 	*tlvs = ie;
-	return FALSE;
+	return false;
 }
 
 static bool ie_is_wps_ie(u8 **wpsie, u8 **tlvs, int *tlvs_len)
@@ -1429,7 +1429,7 @@ static bool ie_is_wps_ie(u8 **wpsie, u8
 	ie += ie[1] + 2;
 	*tlvs_len -= (int)(ie - *tlvs);
 	*tlvs = ie;
-	return FALSE;
+	return false;
 }
 #endif				/* WIRELESS_EXT > 17 */
 
@@ -2808,7 +2808,7 @@ wl_iw_set_wpaauth(struct net_device *dev
 			}
 		} else if (val) {
 			error = dev_wlc_intvar_set(dev, "is_WPS_enrollee",
-							FALSE);
+							false);
 			if (error) {
 				WL_WSEC(("Failed to clear is_WPS_enrollee\n"));
 				return error;
@@ -2904,9 +2904,9 @@ wl_iw_set_wpaauth(struct net_device *dev
 			int wsec;
 
 			if (paramval == 0) {
-				iw->privacy_invoked = FALSE;
+				iw->privacy_invoked = false;
 				error = dev_wlc_intvar_set(dev,
-						"is_WPS_enrollee", FALSE);
+						"is_WPS_enrollee", false);
 				if (error) {
 					WL_WSEC(("Failed to clear iovar "
 						"is_WPS_enrollee\n"));
@@ -2930,7 +2930,7 @@ wl_iw_set_wpaauth(struct net_device *dev
 				} else {
 					error = dev_wlc_intvar_set(dev,
 							"is_WPS_enrollee",
-							FALSE);
+							false);
 					if (error) {
 						WL_WSEC(("Failed to clear "
 							"is_WPS_enrollee\n"));
@@ -3036,7 +3036,7 @@ wl_iw_get_wpaauth(struct net_device *dev
 		if (val)
 			paramval = true;
 		else
-			paramval = FALSE;
+			paramval = false;
 		break;
 #if WIRELESS_EXT > 17
 	case IW_AUTH_ROAMING_CONTROL:
@@ -3342,7 +3342,7 @@ wl_iw_conn_status_str(u32 event_type, u3
 		WL_INFORM(("Connection status: %s\n", stringBuf));
 		return true;
 	} else {
-		return FALSE;
+		return false;
 	}
 }
 
@@ -3358,7 +3358,7 @@ wl_iw_check_conn_fail(wl_event_msg_t *e,
 	if (wl_iw_conn_status_str(event, status, reason, stringBuf, buflen)) {
 		return true;
 	} else
-		return FALSE;
+		return false;
 }
 #endif
 
--- a/drivers/staging/brcm80211/include/bcmnvram.h
+++ b/drivers/staging/brcm80211/include/bcmnvram.h
@@ -89,7 +89,7 @@ extern int nvram_resetgpio_init(void *si
  * @param	name	name of variable to match
  * @param	match	value to compare against value of variable
  * @return	true if variable is defined and its value is string equal
- *		to match or FALSE otherwise
+ *		to match or false otherwise
  */
 static inline int nvram_match(char *name, char *match)
 {
@@ -102,7 +102,7 @@ static inline int nvram_match(char *name
  * @param	name	name of variable to match
  * @param	match	value to compare against value of variable
  * @return	true if variable is defined and its value is not string
- *		equal to invmatch or FALSE otherwise
+ *		equal to invmatch or false otherwise
  */
 static inline int nvram_invmatch(char *name, char *invmatch)
 {
--- a/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
+++ b/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
@@ -62,7 +62,7 @@ struct sdioh_info {
 	uint irq;		/* Client irq */
 	int intrcount;		/* Client interrupts */
 	bool sd_use_dma;	/* DMA on CMD53 */
-	bool sd_blockmode;	/* sd_blockmode == FALSE => 64 Byte Cmd 53s. */
+	bool sd_blockmode;	/* sd_blockmode == false => 64 Byte Cmd 53s. */
 	/*  Must be on for sd_multiblock to be effective */
 	bool use_client_ints;	/* If this is false, make sure to restore */
 	int sd_mode;		/* SD1/SD4/SPI */
--- a/drivers/staging/brcm80211/include/linux_osl.h
+++ b/drivers/staging/brcm80211/include/linux_osl.h
@@ -335,7 +335,7 @@ extern int osl_error(int bcmerror);
 #define	PKTTAG(skb)		((void *)(((struct sk_buff *)(skb))->cb))
 #define PKTALLOCED(osh)		(((osl_pubinfo_t *)(osh))->pktalloced)
 #define PKTSETPOOL(osh, skb, x, y)	do {} while (0)
-#define PKTPOOL(osh, skb)		FALSE
+#define PKTPOOL(osh, skb)		false
 extern void *osl_pktget(osl_t *osh, uint len);
 extern void osl_pktfree(osl_t *osh, void *skb, bool send);
 
--- a/drivers/staging/brcm80211/include/nicpci.h
+++ b/drivers/staging/brcm80211/include/nicpci.h
@@ -38,10 +38,10 @@
 #define pcicore_pcieserdesreg(a, b, c, d, e) (0)
 #define pcicore_pciereg(a, b, c, d, e) (0)
 
-#define pcicore_pmecap_fast(a)	(FALSE)
+#define pcicore_pmecap_fast(a)	(false)
 #define pcicore_pmeen(a)	do { } while (0)
 #define pcicore_pmeclr(a)	do { } while (0)
-#define pcicore_pmestat(a)	(FALSE)
+#define pcicore_pmestat(a)	(false)
 #else
 struct sbpcieregs;
 
--- a/drivers/staging/brcm80211/include/osl.h
+++ b/drivers/staging/brcm80211/include/osl.h
@@ -51,7 +51,7 @@ typedef void (*osl_wreg_fn_t) (void *ctx
 
 #if !defined(OSL_SYSUPTIME)
 #define OSL_SYSUPTIME() (0)
-#define OSL_SYSUPTIME_SUPPORT FALSE
+#define OSL_SYSUPTIME_SUPPORT false
 #else
 #define OSL_SYSUPTIME_SUPPORT true
 #endif				/* OSL_SYSUPTIME */
--- a/drivers/staging/brcm80211/include/typedefs.h
+++ b/drivers/staging/brcm80211/include/typedefs.h
@@ -30,10 +30,6 @@ typedef unsigned int uintptr;
 
 #undef TYPEDEF_UINTPTR
 
-#ifndef FALSE
-#define FALSE	0
-#endif
-
 #ifndef OFF
 #define	OFF	0
 #endif
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -518,7 +518,7 @@ static void WLBANDINITFN(wlc_set_phy_uni
 {
 	int i, j;
 
-	pi->initialized = FALSE;
+	pi->initialized = false;
 
 	pi->tx_vos = 0xffff;
 	pi->nrssi_table_delta = 0x7fffffff;
@@ -732,13 +732,13 @@ wlc_phy_t *wlc_phy_attach(shared_phy_t *
 	pi->phy_txcore_enable_temp =
 	    PHY_CHAIN_TX_DISABLE_TEMP - PHY_HYSTERESIS_DELTATEMP;
 	pi->phy_tempsense_offset = 0;
-	pi->phy_txcore_heatedup = FALSE;
+	pi->phy_txcore_heatedup = false;
 
 	pi->nphy_lastcal_temp = -50;
 
 	pi->phynoise_polling = true;
 	if (ISNPHY(pi) || ISLCNPHY(pi))
-		pi->phynoise_polling = FALSE;
+		pi->phynoise_polling = false;
 
 	for (i = 0; i < TXP_NUM_RATES; i++) {
 		pi->txpwr_limit[i] = WLC_TXPWR_MAX;
@@ -748,7 +748,7 @@ wlc_phy_t *wlc_phy_attach(shared_phy_t *
 
 	pi->radiopwr_override = RADIOPWR_OVERRIDE_DEF;
 
-	pi->user_txpwr_at_rfport = FALSE;
+	pi->user_txpwr_at_rfport = false;
 
 	if (ISNPHY(pi)) {
 
@@ -1018,7 +1018,7 @@ void WLBANDINITFN(wlc_phy_init) (wlc_phy
 
 	(*phy_init) (pi);
 
-	pi->phy_init_por = FALSE;
+	pi->phy_init_por = false;
 
 	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
 		wlc_phy_do_dummy_tx(pi, true, OFF);
@@ -1028,7 +1028,7 @@ void WLBANDINITFN(wlc_phy_init) (wlc_phy
 
 	wlc_phy_ant_rxdiv_set((wlc_phy_t *) pi, pi->sh->rx_antdiv);
 
-	pi->init_in_progress = FALSE;
+	pi->init_in_progress = false;
 }
 
 void wlc_phy_cal_init(wlc_phy_t *pih)
@@ -1052,7 +1052,7 @@ int wlc_phy_down(wlc_phy_t *pih)
 	phy_info_t *pi = (phy_info_t *) pih;
 	int callbacks = 0;
 
-	ASSERT(pi->phytest_on == FALSE);
+	ASSERT(pi->phytest_on == false);
 
 	if (pi->phycal_timer
 	    && !wlapi_del_timer(pi->sh->physhim, pi->phycal_timer))
@@ -1382,7 +1382,7 @@ void wlc_phy_clear_tssi(wlc_phy_t *pih)
 
 static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t *pi)
 {
-	return FALSE;
+	return false;
 }
 
 void wlc_phy_switch_radio(wlc_phy_t *pih, bool on)
@@ -1613,7 +1613,7 @@ int wlc_phy_txpower_get(wlc_phy_t *ppi,
 
 void wlc_phy_txpower_target_set(wlc_phy_t *ppi, struct txpwr_limits *txpwr)
 {
-	bool mac_enabled = FALSE;
+	bool mac_enabled = false;
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	bcopy(&txpwr->cck[0], &pi->tx_user_target[TXP_FIRST_CCK],
@@ -1675,7 +1675,7 @@ int wlc_phy_txpower_set(wlc_phy_t *ppi,
 	for (i = 0; i < TXP_NUM_RATES; i++)
 		pi->tx_user_target[i] = (u8) qdbm;
 
-	pi->txpwroverride = FALSE;
+	pi->txpwroverride = false;
 
 	if (pi->sh->up) {
 		if (!SCAN_INPROG_PHY(pi)) {
@@ -2265,8 +2265,8 @@ void wlc_phy_txpower_ipa_upd(phy_info_t
 		pi->ipa2g_on = (pi->srom_fem2g.extpagain == 2);
 		pi->ipa5g_on = (pi->srom_fem5g.extpagain == 2);
 	} else {
-		pi->ipa2g_on = FALSE;
-		pi->ipa5g_on = FALSE;
+		pi->ipa2g_on = false;
+		pi->ipa5g_on = false;
 	}
 }
 
@@ -2442,7 +2442,7 @@ bool wlc_phy_ant_rxdiv_get(wlc_phy_t *pp
 
 	if (ISNPHY(pi)) {
 
-		ret = FALSE;
+		ret = false;
 	} else if (ISLCNPHY(pi)) {
 		u16 crsctrl = read_phy_reg(pi, 0x410);
 		u16 div = crsctrl & (0x1 << 1);
@@ -2580,7 +2580,7 @@ wlc_phy_noise_sample_request(wlc_phy_t *
 			noise_dbm = PHY_NOISE_FIXED_VAL;
 		}
 
-		wait_for_intr = FALSE;
+		wait_for_intr = false;
 		goto done;
 	}
 
@@ -2601,7 +2601,7 @@ wlc_phy_noise_sample_request(wlc_phy_t *
 			noise_dbm = (s8) wlc_lcnphy_rx_signal_power(pi, 20);
 			wlc_lcnphy_deaf_mode(pi, (bool) 1);
 			wlapi_enable_mac(pi->sh->physhim);
-			wait_for_intr = FALSE;
+			wait_for_intr = false;
 		}
 	} else if (ISNPHY(pi)) {
 		if (!pi->phynoise_polling
@@ -2655,7 +2655,7 @@ wlc_phy_noise_sample_request(wlc_phy_t *
 			pi->nphy_noise_index = MODINC_POW2(pi->nphy_noise_index,
 							   PHY_NOISE_WINDOW_SZ);
 
-			wait_for_intr = FALSE;
+			wait_for_intr = false;
 		}
 	}
 
@@ -2935,7 +2935,7 @@ void wlc_phy_set_deaf(wlc_phy_t *ppi, bo
 void wlc_phy_watchdog(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	bool delay_phy_cal = FALSE;
+	bool delay_phy_cal = false;
 	pi->sh->now++;
 
 	if (!pi->watchdog_override)
@@ -3174,7 +3174,7 @@ void wlc_phy_cal_perical(wlc_phy_t *pih,
 			if ((delta_temp < (s16) pi->phycal_tempdelta) &&
 			    (pi->nphy_txiqlocal_chanspec ==
 			     pi->radio_chanspec)) {
-				do_periodic_cal = FALSE;
+				do_periodic_cal = false;
 			} else {
 				pi->nphy_lastcal_temp = nphy_currtemp;
 			}
@@ -3293,7 +3293,7 @@ u8 wlc_phy_stf_chain_active_get(wlc_phy_
 		} else {
 			if (nphy_currtemp <= pi->phy_txcore_enable_temp) {
 				active_bitmap |= 0x2;
-				pi->phy_txcore_heatedup = FALSE;
+				pi->phy_txcore_heatedup = false;
 			}
 		}
 	}
--- a/drivers/staging/brcm80211/phy/wlc_phy_hal.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_hal.h
@@ -51,7 +51,7 @@
 #define BCM2064_IDCODE		0x02064000
 #define BCM2064A0_IDCODE	0x0206417f
 
-#define PHY_TPC_HW_OFF		FALSE
+#define PHY_TPC_HW_OFF		false
 #define PHY_TPC_HW_ON		true
 
 #define PHY_PERICAL_DRIVERUP	1
--- a/drivers/staging/brcm80211/phy/wlc_phy_int.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_int.h
@@ -264,8 +264,8 @@ typedef enum {
 #define VALID_LCN_RADIO(radioid)	(radioid == BCM2064_ID)
 
 #define	VALID_RADIO(pi, radioid)	(\
-	(ISNPHY(pi) ? VALID_N_RADIO(radioid) : FALSE) || \
-	(ISLCNPHY(pi) ? VALID_LCN_RADIO(radioid) : FALSE))
+	(ISNPHY(pi) ? VALID_N_RADIO(radioid) : false) || \
+	(ISLCNPHY(pi) ? VALID_LCN_RADIO(radioid) : false))
 
 #define SCAN_INPROG_PHY(pi)	(mboolisset(pi->measure_hold, PHY_HOLD_FOR_SCAN))
 #define RM_INPROG_PHY(pi)	(mboolisset(pi->measure_hold, PHY_HOLD_FOR_RM))
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -84,7 +84,7 @@
 #define wlc_lcnphy_enable_tx_gain_override(pi) \
 	wlc_lcnphy_set_tx_gain_override(pi, true)
 #define wlc_lcnphy_disable_tx_gain_override(pi) \
-	wlc_lcnphy_set_tx_gain_override(pi, FALSE)
+	wlc_lcnphy_set_tx_gain_override(pi, false)
 
 #define wlc_lcnphy_iqcal_active(pi)	\
 	(read_phy_reg((pi), 0x451) & \
@@ -1237,11 +1237,11 @@ void wlc_phy_chanspec_set_lcnphy(phy_inf
 	if (CHSPEC_CHANNEL(pi->radio_chanspec) == 14) {
 		mod_phy_reg(pi, 0x448, (0x3 << 8), (2) << 8);
 
-		wlc_lcnphy_load_tx_iir_filter(pi, FALSE, 3);
+		wlc_lcnphy_load_tx_iir_filter(pi, false, 3);
 	} else {
 		mod_phy_reg(pi, 0x448, (0x3 << 8), (1) << 8);
 
-		wlc_lcnphy_load_tx_iir_filter(pi, FALSE, 2);
+		wlc_lcnphy_load_tx_iir_filter(pi, false, 2);
 	}
 
 	wlc_lcnphy_load_tx_iir_filter(pi, true, 0);
@@ -1910,7 +1910,7 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t *pi,
 		command_nums = command_nums_recal;
 		break;
 	default:
-		ASSERT(FALSE);
+		ASSERT(false);
 	}
 
 	wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
@@ -2633,7 +2633,7 @@ void wlc_lcnphy_tx_pu(phy_info_t *pi, bo
 		mod_phy_reg(pi, 0x44c, (0x1 << 12), 1 << 12);
 		mod_phy_reg(pi, 0x44d, (0x1 << 14), 1 << 14);
 
-		wlc_lcnphy_set_trsw_override(pi, true, FALSE);
+		wlc_lcnphy_set_trsw_override(pi, true, false);
 
 		mod_phy_reg(pi, 0x44d, (0x1 << 2), 0 << 2);
 		mod_phy_reg(pi, 0x44c, (0x1 << 2), 1 << 2);
@@ -2748,7 +2748,7 @@ wlc_lcnphy_start_tx_tone(phy_info_t *pi,
 		write_phy_reg(pi, 0x942, 0x2);
 		write_phy_reg(pi, 0x93b, 0x0);
 		write_phy_reg(pi, 0x93c, 0x0);
-		wlc_lcnphy_txrx_spur_avoidance_mode(pi, FALSE);
+		wlc_lcnphy_txrx_spur_avoidance_mode(pi, false);
 	}
 
 	if (f_kHz) {
@@ -2818,7 +2818,7 @@ void wlc_lcnphy_stop_tx_tone(phy_info_t
 
 	and_radio_reg(pi, RADIO_2064_REG112, 0xFFF9);
 
-	wlc_lcnphy_deaf_mode(pi, FALSE);
+	wlc_lcnphy_deaf_mode(pi, false);
 }
 
 static void wlc_lcnphy_clear_trsw_override(phy_info_t *pi)
@@ -2895,7 +2895,7 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal
 		wlc_lcnphy_tx_iqlo_cal(pi, &target_gains,
 				       (pi_lcn->
 					lcnphy_recal ? LCNPHY_CAL_RECAL :
-					LCNPHY_CAL_FULL), FALSE);
+					LCNPHY_CAL_FULL), false);
 	} else {
 
 		wlc_lcnphy_tx_iqlo_soft_cal_full(pi);
@@ -2922,7 +2922,7 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal
 			target_gains.pad_gain = 30;
 			wlc_lcnphy_set_tx_pwr_by_index(pi, 16);
 			wlc_lcnphy_tx_iqlo_cal(pi, &target_gains,
-					       LCNPHY_CAL_FULL, FALSE);
+					       LCNPHY_CAL_FULL, false);
 		} else {
 
 			wlc_lcnphy_tx_iqlo_soft_cal_full(pi);
@@ -3162,7 +3162,7 @@ wlc_lcnphy_rx_iq_est(phy_info_t *pi,
 	while (read_phy_reg(pi, 0x481) & (0x1 << 9)) {
 
 		if (wait_count > (10 * 500)) {
-			result = FALSE;
+			result = false;
 			goto cleanup;
 		}
 		OSL_DELAY(100);
@@ -3213,7 +3213,7 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 	qq = iq_est.q_pwr;
 
 	if ((ii + qq) < LCNPHY_MIN_RXIQ_PWR) {
-		result = FALSE;
+		result = false;
 		goto cleanup;
 	}
 
@@ -3225,13 +3225,13 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 		a = (-(iq << (30 - iq_nbits)) + (ii >> (1 + arsh)));
 		temp = (s32) (ii >> arsh);
 		if (temp == 0) {
-			return FALSE;
+			return false;
 		}
 	} else {
 		a = (-(iq << (30 - iq_nbits)) + (ii << (-1 - arsh)));
 		temp = (s32) (ii << -arsh);
 		if (temp == 0) {
-			return FALSE;
+			return false;
 		}
 	}
 	a /= temp;
@@ -3240,13 +3240,13 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 		b = (qq << (31 - qq_nbits));
 		temp = (s32) (ii >> brsh);
 		if (temp == 0) {
-			return FALSE;
+			return false;
 		}
 	} else {
 		b = (qq << (31 - qq_nbits));
 		temp = (s32) (ii << -brsh);
 		if (temp == 0) {
-			return FALSE;
+			return false;
 		}
 	}
 	b /= temp;
@@ -3277,7 +3277,7 @@ wlc_lcnphy_rx_iq_cal(phy_info_t *pi, con
 	lcnphy_txgains_t old_gains;
 	u16 tx_pwr_ctrl;
 	u8 tx_gain_index_old = 0;
-	bool result = FALSE, tx_gain_override_old = FALSE;
+	bool result = false, tx_gain_override_old = false;
 	u16 i, Core1TxControl_old, RFOverride0_old,
 	    RFOverrideVal0_old, rfoverride2_old, rfoverride2val_old,
 	    rfoverride3_old, rfoverride3val_old, rfoverride4_old,
@@ -3291,7 +3291,7 @@ wlc_lcnphy_rx_iq_cal(phy_info_t *pi, con
 
 	ptr = MALLOC(pi->sh->osh, sizeof(s16) * 131);
 	if (NULL == ptr) {
-		return FALSE;
+		return false;
 	}
 	if (module == 2) {
 		ASSERT(iqcomp_sz);
@@ -3433,7 +3433,7 @@ wlc_lcnphy_rx_iq_cal(phy_info_t *pi, con
 			wlc_lcnphy_disable_tx_gain_override(pi);
 		wlc_lcnphy_set_tx_pwr_ctrl(pi, tx_pwr_ctrl);
 
-		wlc_lcnphy_rx_gain_override_enable(pi, FALSE);
+		wlc_lcnphy_rx_gain_override_enable(pi, false);
 	}
 
  cal_done:
@@ -3459,14 +3459,14 @@ static void wlc_lcnphy_glacial_timer_bas
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
 	wlc_lcnphy_deaf_mode(pi, true);
 	pi->phy_lastcal = pi->sh->now;
-	pi->phy_forcecal = FALSE;
+	pi->phy_forcecal = false;
 	index = pi_lcn->lcnphy_current_index;
 
 	wlc_lcnphy_txpwrtbl_iqlo_cal(pi);
 
 	wlc_lcnphy_set_tx_pwr_by_index(pi, index);
 	wlc_lcnphy_set_tx_pwr_ctrl(pi, SAVE_pwrctrl);
-	wlc_lcnphy_deaf_mode(pi, FALSE);
+	wlc_lcnphy_deaf_mode(pi, false);
 	if (!suspend)
 		wlapi_enable_mac(pi->sh->physhim);
 
@@ -3488,7 +3488,7 @@ static void wlc_lcnphy_periodic_cal(phy_
 		return;
 
 	pi->phy_lastcal = pi->sh->now;
-	pi->phy_forcecal = FALSE;
+	pi->phy_forcecal = false;
 	full_cal =
 	    (pi_lcn->lcnphy_full_cal_channel !=
 	     CHSPEC_CHANNEL(pi->radio_chanspec));
@@ -3510,9 +3510,9 @@ static void wlc_lcnphy_periodic_cal(phy_
 	rx_iqcomp_sz = ARRAY_SIZE(lcnphy_rx_iqcomp_table_rev0);
 
 	if (LCNREV_IS(pi->pubpi.phy_rev, 1))
-		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, true, FALSE, 1, 40);
+		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, true, false, 1, 40);
 	else
-		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, true, FALSE, 1, 127);
+		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, true, false, 1, 127);
 
 	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi)) {
 
@@ -3539,7 +3539,7 @@ static void wlc_lcnphy_periodic_cal(phy_
 
 	wlc_lcnphy_set_tx_pwr_by_index(pi, index);
 	wlc_lcnphy_set_tx_pwr_ctrl(pi, SAVE_pwrctrl);
-	wlc_lcnphy_deaf_mode(pi, FALSE);
+	wlc_lcnphy_deaf_mode(pi, false);
 	if (!suspend)
 		wlapi_enable_mac(pi->sh->physhim);
 }
@@ -3642,7 +3642,7 @@ static void wlc_lcnphy_set_chanspec_twea
 
 		si_pmu_pllupd(pi->sh->sih);
 		write_phy_reg(pi, 0x942, 0);
-		wlc_lcnphy_txrx_spur_avoidance_mode(pi, FALSE);
+		wlc_lcnphy_txrx_spur_avoidance_mode(pi, false);
 		pi_lcn->lcnphy_spurmod = 0;
 		mod_phy_reg(pi, 0x424, (0xff << 8), (0x1b) << 8);
 
@@ -5058,7 +5058,7 @@ bool wlc_phy_attach_lcnphy(phy_info_t *p
 	    (phy_info_lcnphy_t *) MALLOC(pi->sh->osh,
 					 sizeof(phy_info_lcnphy_t));
 	if (pi->u.pi_lcnphy == NULL) {
-		return FALSE;
+		return false;
 	}
 	bzero((char *)pi->u.pi_lcnphy, sizeof(phy_info_lcnphy_t));
 
@@ -5085,16 +5085,16 @@ bool wlc_phy_attach_lcnphy(phy_info_t *p
 	pi->pi_fptr.detach = wlc_phy_detach_lcnphy;
 
 	if (!wlc_phy_txpwr_srom_read_lcnphy(pi))
-		return FALSE;
+		return false;
 
 	if ((pi->sh->boardflags & BFL_FEM) && (LCNREV_IS(pi->pubpi.phy_rev, 1))) {
 		if (pi_lcn->lcnphy_tempsense_option == 3) {
 			pi->hwpwrctrl = true;
 			pi->hwpwrctrl_capable = true;
-			pi->temppwrctrl_capable = FALSE;
+			pi->temppwrctrl_capable = false;
 		} else {
-			pi->hwpwrctrl = FALSE;
-			pi->hwpwrctrl_capable = FALSE;
+			pi->hwpwrctrl = false;
+			pi->hwpwrctrl_capable = false;
 			pi->temppwrctrl_capable = true;
 		}
 	}
@@ -5292,7 +5292,7 @@ wlc_lcnphy_load_tx_iir_filter(phy_info_t
 		}
 
 		if (filt_index == -1) {
-			ASSERT(FALSE);
+			ASSERT(false);
 		} else {
 			for (j = 0; j < LCNPHY_NUM_DIG_FILT_COEFFS; j++) {
 				write_phy_reg(pi, addr[j],
@@ -5309,7 +5309,7 @@ wlc_lcnphy_load_tx_iir_filter(phy_info_t
 		}
 
 		if (filt_index == -1) {
-			ASSERT(FALSE);
+			ASSERT(false);
 		} else {
 			for (j = 0; j < LCNPHY_NUM_DIG_FILT_COEFFS; j++) {
 				write_phy_reg(pi, addr_ofdm[j],
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -14209,7 +14209,7 @@ bool wlc_phy_bist_check_phy(wlc_phy_t *p
 		return true;
 	}
 
-	return FALSE;
+	return false;
 }
 
 static void WLBANDINITFN(wlc_phy_bphy_init_nphy) (phy_info_t *pi)
@@ -14483,8 +14483,8 @@ bool wlc_phy_attach_nphy(phy_info_t *pi)
 	pi->mphase_txcal_numcmds = MPHASE_TXCAL_NUMCMDS;
 
 	pi->nphy_gain_boost = true;
-	pi->nphy_elna_gain_config = FALSE;
-	pi->radio_is_on = FALSE;
+	pi->nphy_elna_gain_config = false;
+	pi->radio_is_on = false;
 
 	for (i = 0; i < pi->pubpi.phy_corenum; i++) {
 		pi->nphy_txpwrindex[i].index = AUTO;
@@ -14500,7 +14500,7 @@ bool wlc_phy_attach_nphy(phy_info_t *pi)
 	pi->pi_fptr.txpwrrecalc = wlc_phy_txpower_recalc_target_nphy;
 
 	if (!wlc_phy_txpwr_srom_read_nphy(pi))
-		return FALSE;
+		return false;
 
 	return true;
 }
@@ -14515,7 +14515,7 @@ static void wlc_phy_txpwrctrl_config_nph
 	}
 
 	pi->nphy_txpwrctrl = PHY_TPC_HW_OFF;
-	pi->phy_5g_pwrgain = FALSE;
+	pi->phy_5g_pwrgain = false;
 
 	if ((pi->sh->boardflags2 & BFL2_TXPWRCTRL_EN) &&
 	    NREV_GE(pi->pubpi.phy_rev, 2) && (pi->sh->sromrev >= 4))
@@ -14531,7 +14531,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 	u16 clip1_ths[2];
 	nphy_txgains_t target_gain;
 	u8 tx_pwr_ctrl_state;
-	bool do_nphy_cal = FALSE;
+	bool do_nphy_cal = false;
 	uint core;
 	uint origidx, intr_val;
 	d11regs_t *regs;
@@ -14581,14 +14581,14 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 	      (NREV_GE(pi->pubpi.phy_rev, 5)
 	       && pi->sh->boardflags2 & BFL2_INTERNDET_TXIQCAL)));
 
-	pi->internal_tx_iqlo_cal_tapoff_intpa_nphy = FALSE;
+	pi->internal_tx_iqlo_cal_tapoff_intpa_nphy = false;
 
 	pi->nphy_deaf_count = 0;
 
 	wlc_phy_tbl_init_nphy(pi);
 
-	pi->nphy_crsminpwr_adjusted = FALSE;
-	pi->nphy_noisevars_adjusted = FALSE;
+	pi->nphy_crsminpwr_adjusted = false;
+	pi->nphy_noisevars_adjusted = false;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		write_phy_reg(pi, 0xe7, 0);
@@ -14854,7 +14854,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 	}
 
 	if (!NORADIO_ENAB(pi->pubpi)) {
-		bool do_rssi_cal = FALSE;
+		bool do_rssi_cal = false;
 
 		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 			do_rssi_cal = (CHSPEC_IS2G(pi->radio_chanspec)) ?
@@ -14877,7 +14877,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 		}
 
 		if (!pi->do_initcal)
-			do_nphy_cal = FALSE;
+			do_nphy_cal = false;
 
 		if (do_nphy_cal) {
 
@@ -14903,10 +14903,10 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 				}
 
 				if (wlc_phy_cal_txiqlo_nphy
-				    (pi, target_gain, true, FALSE) == BCME_OK) {
+				    (pi, target_gain, true, false) == BCME_OK) {
 					if (wlc_phy_cal_rxiq_nphy
 					    (pi, target_gain, 2,
-					     FALSE) == BCME_OK) {
+					     false) == BCME_OK) {
 						wlc_phy_savecal_nphy(pi);
 
 					}
@@ -14940,7 +14940,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 
 static void wlc_phy_update_mimoconfig_nphy(phy_info_t *pi, s32 preamble)
 {
-	bool gf_preamble = FALSE;
+	bool gf_preamble = false;
 	u16 val;
 
 	if (preamble == WLC_N_PREAMBLE_GF) {
@@ -15009,7 +15009,7 @@ void wlc_phy_stf_chain_upd_nphy(phy_info
 
 	u16 txrx_chain =
 	    (NPHY_RfseqCoreActv_TxRxChain0 | NPHY_RfseqCoreActv_TxRxChain1);
-	bool CoreActv_override = FALSE;
+	bool CoreActv_override = false;
 
 	if (pi->nphy_txrx_chain == WLC_N_TXRX_CHAIN0) {
 		txrx_chain = NPHY_RfseqCoreActv_TxRxChain0;
@@ -15114,7 +15114,7 @@ void wlc_phy_rxcore_setstate_nphy(wlc_ph
 	wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 	if (!suspend)
 		wlapi_enable_mac(pi->sh->physhim);
@@ -15374,7 +15374,7 @@ static void wlc_phy_workarounds_nphy(phy
 	u16 tx_lpf_bw_11b = 0;
 	u16 ipa2g_mainbias, ipa2g_casconv, ipa2g_biasfilt;
 	u16 txgm_idac_bleed = 0;
-	bool rccal_ovrd = FALSE;
+	bool rccal_ovrd = false;
 	u16 freq;
 	int coreNum;
 
@@ -16342,7 +16342,7 @@ static void wlc_phy_workarounds_nphy(phy
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t *pi)
@@ -17286,7 +17286,7 @@ static void wlc_phy_adjust_lnagaintbl_np
 	mod_phy_reg(pi, 0x34, (0xff << 0), (minmax_gain[1] << 0));
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 void wlc_phy_switch_radio_nphy(phy_info_t *pi, bool on)
@@ -17361,12 +17361,12 @@ void wlc_phy_switch_radio_nphy(phy_info_
 					RADIO_2056_TX_MIXG_BOOST_TUNE |
 					RADIO_2056_TX1, 0);
 
-			pi->radio_is_on = FALSE;
+			pi->radio_is_on = false;
 		}
 
 		if (NREV_GE(pi->pubpi.phy_rev, 8)) {
 			and_phy_reg(pi, 0x78, ~RFCC_CHIP0_PU);
-			pi->radio_is_on = FALSE;
+			pi->radio_is_on = false;
 		}
 
 	}
@@ -17787,7 +17787,7 @@ wlc_phy_chan2freq_nphy(phy_info_t *pi, u
 
  fail:
 	*f = WL_CHAN_FREQ_RANGE_2G;
-	return FALSE;
+	return false;
 }
 
 u8 wlc_phy_get_chan_freq_range_nphy(phy_info_t *pi, uint channel)
@@ -18648,7 +18648,7 @@ wlc_phy_adjust_rx_analpfbw_nphy(phy_info
 						 RADIO_2056_RX0),
 						(pi->nphy_rccal_value | 0x80));
 
-				pi->nphy_anarxlpf_adjusted = FALSE;
+				pi->nphy_anarxlpf_adjusted = false;
 			}
 		}
 	}
@@ -18679,7 +18679,7 @@ wlc_phy_adjust_min_noisevar_nphy(phy_inf
 		}
 
 		pi->nphy_saved_noisevars.bufcount = 0;
-		pi->nphy_noisevars_adjusted = FALSE;
+		pi->nphy_noisevars_adjusted = false;
 	}
 
 	if ((noise_var_buf != NULL) && (tone_id_buf != NULL)) {
@@ -18749,7 +18749,7 @@ static void wlc_phy_adjust_crsminpwr_nph
 				regval |= pi->nphy_crsminpwr[2];
 				write_phy_reg(pi, 0x283, regval);
 
-				pi->nphy_crsminpwr_adjusted = FALSE;
+				pi->nphy_crsminpwr_adjusted = false;
 			}
 		}
 	}
@@ -18799,7 +18799,7 @@ static void wlc_phy_spurwar_nphy(phy_inf
 	u16 cur_channel = 0;
 	int nphy_adj_tone_id_buf[] = { 57, 58 };
 	u32 nphy_adj_noise_var_buf[] = { 0x3ff, 0x3ff };
-	bool isAdjustNoiseVar = FALSE;
+	bool isAdjustNoiseVar = false;
 	uint numTonesAdjust = 0;
 	u32 tempval = 0;
 
@@ -18894,7 +18894,7 @@ static void wlc_phy_spurwar_nphy(phy_inf
 					isAdjustNoiseVar = true;
 					break;
 				default:
-					isAdjustNoiseVar = FALSE;
+					isAdjustNoiseVar = false;
 					break;
 				}
 			}
@@ -18967,7 +18967,7 @@ static void wlc_phy_spurwar_nphy(phy_inf
 		}
 
 		if (pi->phyhang_avoid)
-			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+			wlc_phy_stay_in_carriersearch_nphy(pi, false);
 	}
 }
 
@@ -19081,7 +19081,7 @@ wlc_phy_chanspec_nphy_setup(phy_info_t *
 		    (CHIPID(pi->sh->chip) == BCM47162_CHIP_ID)) {
 			si_pmu_spuravoid(pi->sh->sih, pi->sh->osh, spuravoid);
 		} else {
-			wlapi_bmac_core_phypll_ctl(pi->sh->physhim, FALSE);
+			wlapi_bmac_core_phypll_ctl(pi->sh->physhim, false);
 			si_pmu_spuravoid(pi->sh->sih, pi->sh->osh, spuravoid);
 			wlapi_bmac_core_phypll_ctl(pi->sh->physhim, true);
 		}
@@ -19357,7 +19357,7 @@ static void wlc_phy_savecal_nphy(phy_inf
 	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_IQLOCAL, 8, 80, 16, tbl_ptr);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 static void wlc_phy_restorecal_nphy(phy_info_t *pi)
@@ -19571,7 +19571,7 @@ void wlc_phy_antsel_init(wlc_phy_t *ppi,
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		u16 v0 = 0x211, v1 = 0x222, v2 = 0x144, v3 = 0x188;
 
-		if (lut_init == FALSE)
+		if (lut_init == false)
 			return;
 
 		if (pi->srom_fem2g.antswctrllut == 0) {
@@ -19626,12 +19626,12 @@ void wlc_phy_antsel_init(wlc_phy_t *ppi,
 u16 wlc_phy_classifier_nphy(phy_info_t *pi, u16 mask, u16 val)
 {
 	u16 curr_ctl, new_ctl;
-	bool suspended = FALSE;
+	bool suspended = false;
 
 	if (D11REV_IS(pi->sh->corerev, 16)) {
 		suspended =
 		    (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) ?
-		    FALSE : true;
+		    false : true;
 		if (!suspended)
 			wlapi_suspend_mac_and_wait(pi->sh->physhim);
 	}
@@ -19736,7 +19736,7 @@ wlc_phy_set_rfseq_nphy(phy_info_t *pi, u
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 static u16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t *pi, u16 offset)
@@ -22433,7 +22433,7 @@ wlc_phy_loadsampletable_nphy(phy_info_t
 		MFREE(pi->sh->osh, data_buf, sizeof(u32) * num_samps);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 static void
@@ -22495,7 +22495,7 @@ wlc_phy_runsamples_nphy(phy_info_t *pi,
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 	write_phy_reg(pi, 0xc6, num_samps - 1);
 
@@ -22558,12 +22558,12 @@ void wlc_phy_stopplayback_nphy(phy_info_
 							  (0x1 << 7),
 							  0, 0, 1,
 							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
-			pi->nphy_sample_play_lpf_bw_ctl_ovr = FALSE;
+			pi->nphy_sample_play_lpf_bw_ctl_ovr = false;
 		}
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t *pi)
@@ -22581,7 +22581,7 @@ nphy_txgains_t wlc_phy_get_tx_gain_nphy(
 					curr_gain);
 
 		if (pi->phyhang_avoid)
-			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+			wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 		for (core_no = 0; core_no < 2; core_no++) {
 			if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -23544,7 +23544,7 @@ static void wlc_phy_internal_cal_txgain_
 
 static void wlc_phy_precal_txgain_nphy(phy_info_t *pi)
 {
-	bool save_bbmult = FALSE;
+	bool save_bbmult = false;
 	u8 txcal_index_2057_rev5n7 = 0;
 	u8 txcal_index_2057_rev3n4n6 = 10;
 
@@ -23560,7 +23560,7 @@ static void wlc_phy_precal_txgain_nphy(p
 				    txcal_index_2057_rev3n4n6;
 				wlc_phy_txpwr_index_nphy(pi, 3,
 							 txcal_index_2057_rev3n4n6,
-							 FALSE);
+							 false);
 			} else {
 
 				pi->nphy_txcal_pwr_idx[0] =
@@ -23569,12 +23569,12 @@ static void wlc_phy_precal_txgain_nphy(p
 				    txcal_index_2057_rev5n7;
 				wlc_phy_txpwr_index_nphy(pi, 3,
 							 txcal_index_2057_rev5n7,
-							 FALSE);
+							 false);
 			}
 			save_bbmult = true;
 
 		} else if (NREV_LT(pi->pubpi.phy_rev, 5)) {
-			wlc_phy_cal_txgainctrl_nphy(pi, 11, FALSE);
+			wlc_phy_cal_txgainctrl_nphy(pi, 11, false);
 			if (pi->sh->hw_phytxchain != 3) {
 				pi->nphy_txcal_pwr_idx[1] =
 				    pi->nphy_txcal_pwr_idx[0];
@@ -23589,12 +23589,12 @@ static void wlc_phy_precal_txgain_nphy(p
 			if (PHY_IPA(pi)) {
 				if (CHSPEC_IS2G(pi->radio_chanspec)) {
 					wlc_phy_cal_txgainctrl_nphy(pi, 12,
-								    FALSE);
+								    false);
 				} else {
 					pi->nphy_txcal_pwr_idx[0] = 80;
 					pi->nphy_txcal_pwr_idx[1] = 80;
 					wlc_phy_txpwr_index_nphy(pi, 3, 80,
-								 FALSE);
+								 false);
 					save_bbmult = true;
 				}
 			} else {
@@ -23607,10 +23607,10 @@ static void wlc_phy_precal_txgain_nphy(p
 			if (PHY_IPA(pi)) {
 				if (CHSPEC_IS2G(pi->radio_chanspec)) {
 					wlc_phy_cal_txgainctrl_nphy(pi, 12,
-								    FALSE);
+								    false);
 				} else {
 					wlc_phy_cal_txgainctrl_nphy(pi, 14,
-								    FALSE);
+								    false);
 				}
 			} else {
 
@@ -23620,7 +23620,7 @@ static void wlc_phy_precal_txgain_nphy(p
 		}
 
 	} else {
-		wlc_phy_cal_txgainctrl_nphy(pi, 10, FALSE);
+		wlc_phy_cal_txgainctrl_nphy(pi, 10, false);
 	}
 
 	if (save_bbmult) {
@@ -23643,7 +23643,7 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 	u32 freq_test;
 	u16 ampl_test = 250;
 	uint stepsize;
-	bool phyhang_avoid_state = FALSE;
+	bool phyhang_avoid_state = false;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -23666,7 +23666,7 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	phyhang_avoid_state = pi->phyhang_avoid;
-	pi->phyhang_avoid = FALSE;
+	pi->phyhang_avoid = false;
 
 	phy_saveregs[0] = read_phy_reg(pi, 0x91);
 	phy_saveregs[1] = read_phy_reg(pi, 0x92);
@@ -23703,7 +23703,7 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 		for (gainctrl_loopidx = 0; gainctrl_loopidx < 2;
 		     gainctrl_loopidx++) {
 			wlc_phy_tx_tone_nphy(pi, freq_test, ampl_test, 0, 0,
-					     FALSE);
+					     false);
 
 			if (core == PHY_CORE_0) {
 				curr_m0m1 = m0m1 & 0xff00;
@@ -23760,7 +23760,7 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 			wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &dbg_m0m1);
 
 			wlc_phy_tx_tone_nphy(pi, freq_test, ampl_test, 0, 0,
-					     FALSE);
+					     false);
 
 			wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &dbg_m0m1);
 			wlc_phy_table_write_nphy(pi, 15, 1, 95, 16, &dbg_m0m1);
@@ -23794,7 +23794,7 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 	pi->phyhang_avoid = phyhang_avoid_state;
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 static void wlc_phy_update_txcal_ladder_nphy(phy_info_t *pi, u16 core)
@@ -23844,7 +23844,7 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 	nphy_txgains_t target_gain;
 	u8 tx_pwr_ctrl_state;
 	bool fullcal = true;
-	bool restore_tx_gain = FALSE;
+	bool restore_tx_gain = false;
 	bool mphase;
 
 	if (NORADIO_ENAB(pi->pubpi)) {
@@ -23860,11 +23860,11 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 	if (caltype == PHY_PERICAL_AUTO)
 		fullcal = (pi->radio_chanspec != pi->nphy_txiqlocal_chanspec);
 	else if (caltype == PHY_PERICAL_PARTIAL)
-		fullcal = FALSE;
+		fullcal = false;
 
 	if (pi->cal_type_override != PHY_PERICAL_AUTO) {
 		fullcal =
-		    (pi->cal_type_override == PHY_PERICAL_FULL) ? true : FALSE;
+		    (pi->cal_type_override == PHY_PERICAL_FULL) ? true : false;
 	}
 
 	if ((pi->mphase_cal_phase_id > MPHASE_CAL_STATE_INIT)) {
@@ -23932,7 +23932,7 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 								  cal_type_override
 								  ==
 								  PHY_PERICAL_FULL))
-							     ? 2 : 0, FALSE)) {
+							     ? 2 : 0, false)) {
 				wlc_phy_savecal_nphy(pi);
 
 				wlc_phy_txpwrctrl_coeff_setup_nphy(pi);
@@ -23946,7 +23946,7 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 
 		if (pi->first_cal_after_assoc
 		    || (pi->cal_type_override == PHY_PERICAL_FULL)) {
-			pi->first_cal_after_assoc = FALSE;
+			pi->first_cal_after_assoc = false;
 			wlc_phy_txpwrctrl_idle_tssi_nphy(pi);
 			wlc_phy_txpwrctrl_pwr_setup_nphy(pi);
 		}
@@ -24012,7 +24012,7 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 						  (pi->first_cal_after_assoc ||
 						   (pi->cal_type_override ==
 						    PHY_PERICAL_FULL)) ? 2 : 0,
-						  FALSE) == BCME_OK) {
+						  false) == BCME_OK) {
 				wlc_phy_savecal_nphy(pi);
 			}
 
@@ -24043,7 +24043,7 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 				pi->nphy_rxcal_active = true;
 
 			if (pi->first_cal_after_assoc) {
-				pi->first_cal_after_assoc = FALSE;
+				pi->first_cal_after_assoc = false;
 				wlc_phy_txpwrctrl_idle_tssi_nphy(pi);
 				wlc_phy_txpwrctrl_pwr_setup_nphy(pi);
 			}
@@ -24065,11 +24065,11 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 				wlc_phy_txpwr_index_nphy(pi, 1,
 							 pi->
 							 nphy_cal_orig_pwr_idx
-							 [0], FALSE);
+							 [0], false);
 				wlc_phy_txpwr_index_nphy(pi, 2,
 							 pi->
 							 nphy_cal_orig_pwr_idx
-							 [1], FALSE);
+							 [1], false);
 
 				pi->nphy_txpwrindex[0].index = -1;
 				pi->nphy_txpwrindex[1].index = -1;
@@ -24079,13 +24079,13 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 								 nphy_txpwrindex
 								 [0].
 								 index_internal),
-							 FALSE);
+							 false);
 				wlc_phy_txpwr_index_nphy(pi, (1 << 1),
 							 (s8) (pi->
 								 nphy_txpwrindex
 								 [1].
 								 index_internal),
-							 FALSE);
+							 false);
 			}
 		}
 	}
@@ -24117,7 +24117,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t *pi,
 	bool ladder_updated[2];
 	u8 mphase_cal_lastphase = 0;
 	int bcmerror = BCME_OK;
-	bool phyhang_avoid_state = FALSE;
+	bool phyhang_avoid_state = false;
 
 	u16 tbl_tx_iqlo_cal_loft_ladder_20[] = {
 		0x0300, 0x0500, 0x0700, 0x0900, 0x0d00, 0x1100, 0x1900, 0x1901,
@@ -24182,7 +24182,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t *pi,
 
 	if (NREV_GE(pi->pubpi.phy_rev, 4)) {
 		phyhang_avoid_state = pi->phyhang_avoid;
-		pi->phyhang_avoid = FALSE;
+		pi->phyhang_avoid = false;
 	}
 
 	if (CHSPEC_IS40(pi->radio_chanspec)) {
@@ -24205,7 +24205,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t *pi,
 
 	wlc_phy_txcal_physetup_nphy(pi);
 
-	ladder_updated[0] = ladder_updated[1] = FALSE;
+	ladder_updated[0] = ladder_updated[1] = false;
 	if (!(NREV_GE(pi->pubpi.phy_rev, 6) ||
 	      (NREV_IS(pi->pubpi.phy_rev, 5) && PHY_IPA(pi)
 	       && (CHSPEC_IS2G(pi->radio_chanspec))))) {
@@ -24241,11 +24241,11 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t *pi,
 	tone_freq = (phy_bw == 20) ? 2500 : 5000;
 
 	if (pi->mphase_cal_phase_id > MPHASE_CAL_STATE_TXPHASE0) {
-		wlc_phy_runsamples_nphy(pi, phy_bw * 8, 0xffff, 0, 1, 0, FALSE);
+		wlc_phy_runsamples_nphy(pi, phy_bw * 8, 0xffff, 0, 1, 0, false);
 		bcmerror = BCME_OK;
 	} else {
 		bcmerror =
-		    wlc_phy_tx_tone_nphy(pi, tone_freq, max_val, 1, 0, FALSE);
+		    wlc_phy_tx_tone_nphy(pi, tone_freq, max_val, 1, 0, false);
 	}
 
 	if (bcmerror == BCME_OK) {
@@ -24459,7 +24459,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t *pi,
 		pi->phyhang_avoid = phyhang_avoid_state;
 	}
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 	return bcmerror;
 }
@@ -25318,7 +25318,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 	u32 i_pwr, q_pwr, curr_pwr, optim_pwr = 0, prev_pwr = 0, thresh_pwr =
 	    10000;
 	s16 desired_log2_pwr, actual_log2_pwr, delta_pwr;
-	bool gainctrl_done = FALSE;
+	bool gainctrl_done = false;
 	u8 mix_tia_gain = 3;
 	s8 optim_gaintbl_index = 0, prev_gaintbl_index = 0;
 	s8 curr_gaintbl_index = 3;
@@ -25402,13 +25402,13 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 						 nphy_rxcal_txgain);
 		} else {
 			wlc_phy_txpwr_index_nphy(pi, tx_core + 1, txpwrindex,
-						 FALSE);
+						 false);
 		}
 
 		wlc_phy_tx_tone_nphy(pi, (CHSPEC_IS40(pi->radio_chanspec)) ?
 				     NPHY_RXCAL_TONEFREQ_40MHz :
 				     NPHY_RXCAL_TONEFREQ_20MHz,
-				     NPHY_RXCAL_TONEAMP, 0, cal_type, FALSE);
+				     NPHY_RXCAL_TONEAMP, 0, cal_type, false);
 
 		wlc_phy_rx_iq_est_nphy(pi, est, num_samps, 32, 0);
 		i_pwr = (est[rx_core].i_pwr + num_samps / 2) / num_samps;
@@ -25656,7 +25656,7 @@ wlc_phy_rc_sweep_nphy(phy_info_t *pi, u8
 		if (rccal_stepsize == 16) {
 
 			wlc_phy_tx_tone_nphy(pi, ref_tone, NPHY_RXCAL_TONEAMP,
-					     0, 1, FALSE);
+					     0, 1, false);
 			OSL_DELAY(2);
 
 			wlc_phy_rx_iq_est_nphy(pi, est, num_samps, 32, 0);
@@ -25674,7 +25674,7 @@ wlc_phy_rc_sweep_nphy(phy_info_t *pi, u8
 			}
 
 			wlc_phy_tx_tone_nphy(pi, target_bw, NPHY_RXCAL_TONEAMP,
-					     0, 1, FALSE);
+					     0, 1, false);
 			OSL_DELAY(2);
 		}
 
@@ -25756,7 +25756,7 @@ wlc_phy_rc_sweep_nphy(phy_info_t *pi, u8
 	write_phy_reg(pi, 0xfa, orig_rfctrlauxreg[1]);
 	write_phy_reg(pi, (core_idx == 0) ? 0x7a : 0x7d, orig_rfctrlrssiothers);
 
-	pi->nphy_anarxlpf_adjusted = FALSE;
+	pi->nphy_anarxlpf_adjusted = false;
 
 	return best_rccal_val - 0x80;
 }
@@ -25775,8 +25775,8 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *p
 	u8 rxcore_state;
 	s8 rxlpf_rccal_hpc, txlpf_rccal_lpc;
 	s8 txlpf_idac;
-	bool phyhang_avoid_state = FALSE;
-	bool skip_rxiqcal = FALSE;
+	bool phyhang_avoid_state = false;
+	bool skip_rxiqcal = false;
 
 	orig_BBConfig = read_phy_reg(pi, 0x01);
 	mod_phy_reg(pi, 0x01, (0x1 << 15), 0);
@@ -25785,7 +25785,7 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *p
 
 	if (NREV_GE(pi->pubpi.phy_rev, 4)) {
 		phyhang_avoid_state = pi->phyhang_avoid;
-		pi->phyhang_avoid = FALSE;
+		pi->phyhang_avoid = false;
 	}
 
 	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16, gain_save);
@@ -25803,7 +25803,7 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *p
 	for (rx_core = 0; rx_core < pi->pubpi.phy_corenum; rx_core++) {
 
 		skip_rxiqcal =
-		    ((rxcore_state & (1 << rx_core)) == 0) ? true : FALSE;
+		    ((rxcore_state & (1 << rx_core)) == 0) ? true : false;
 
 		wlc_phy_rxcal_physetup_nphy(pi, rx_core);
 
@@ -25818,7 +25818,7 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *p
 					     NPHY_RXCAL_TONEFREQ_40MHz :
 					     NPHY_RXCAL_TONEFREQ_20MHz,
 					     NPHY_RXCAL_TONEAMP, 0, cal_type,
-					     FALSE);
+					     false);
 
 			if (debug)
 				OSL_DELAY(WAIT_FOR_SCOPE);
@@ -25914,7 +25914,7 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *p
 		pi->phyhang_avoid = phyhang_avoid_state;
 	}
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 	return BCME_OK;
 }
@@ -26083,7 +26083,7 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t *p
 									  &
 									  0xffff),
 								0, 0, true);
-				first_playtone = FALSE;
+				first_playtone = false;
 			} else {
 				phy_bw =
 				    (CHSPEC_IS40(pi->radio_chanspec)) ? 40 : 20;
@@ -26140,7 +26140,7 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t *p
 	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16,
 				 gain_save);
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 	return bcmerror;
 }
@@ -26509,7 +26509,7 @@ wlc_phy_papd_cal_setup_nphy(phy_info_t *
 
 		tone_freq = 4000;
 
-		wlc_phy_tx_tone_nphy(pi, tone_freq, 181, 0, 0, FALSE);
+		wlc_phy_tx_tone_nphy(pi, tone_freq, 181, 0, 0, false);
 
 		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
 			    0x29b, (0x1 << 0), (NPHY_PAPD_COMP_ON) << 0);
@@ -26579,7 +26579,7 @@ wlc_phy_papd_cal_setup_nphy(phy_info_t *
 
 		tone_freq = 4000;
 
-		wlc_phy_tx_tone_nphy(pi, tone_freq, 181, 0, 0, FALSE);
+		wlc_phy_tx_tone_nphy(pi, tone_freq, 181, 0, 0, false);
 
 		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
 			    0x29b, (0x1 << 0), (1) << 0);
@@ -26790,7 +26790,7 @@ wlc_phy_a2_nphy(phy_info_t *pi, nphy_ipa
 	ASSERT((cal_mode == CAL_FULL) || (cal_mode == CAL_GCTRL)
 	       || (cal_mode == CAL_SOFT));
 	phy_a6 = ((cal_mode == CAL_GCTRL)
-		  || (cal_mode == CAL_SOFT)) ? true : FALSE;
+		  || (cal_mode == CAL_SOFT)) ? true : false;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -27078,12 +27078,12 @@ static u8 wlc_phy_a3_nphy(phy_info_t *pi
 	int phy_a2;
 	bool phy_a3;
 	nphy_ipa_txcalgains_t phy_a4;
-	bool phy_a5 = FALSE;
+	bool phy_a5 = false;
 	bool phy_a6 = true;
 	s32 phy_a7, phy_a8;
 	u32 phy_a9;
 	int phy_a10;
-	bool phy_a11 = FALSE;
+	bool phy_a11 = false;
 	int phy_a12;
 	u8 phy_a13 = 0;
 	u8 phy_a14;
@@ -27173,7 +27173,7 @@ static u8 wlc_phy_a3_nphy(phy_info_t *pi
 				break;
 			}
 
-			phy_a6 = FALSE;
+			phy_a6 = false;
 			phy_a5 = phy_a3;
 		}
 
@@ -27219,7 +27219,7 @@ static u8 wlc_phy_a3_nphy(phy_info_t *pi
 				break;
 			}
 
-			phy_a6 = FALSE;
+			phy_a6 = false;
 			phy_a5 = phy_a3;
 		}
 
@@ -27261,7 +27261,7 @@ static void wlc_phy_a4(phy_info_t *pi, b
 
 	wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
-	pi->nphy_force_papd_cal = FALSE;
+	pi->nphy_force_papd_cal = false;
 
 	for (phy_b5 = 0; phy_b5 < pi->pubpi.phy_corenum; phy_b5++)
 		pi->nphy_papd_tx_gain_at_last_cal[phy_b5] =
@@ -27515,13 +27515,13 @@ static void wlc_phy_a4(phy_info_t *pi, b
 	if (phy_b4 == PHY_TPC_HW_OFF) {
 		wlc_phy_txpwr_index_nphy(pi, (1 << 0),
 					 (s8) (pi->nphy_txpwrindex[0].
-						 index_internal), FALSE);
+						 index_internal), false);
 		wlc_phy_txpwr_index_nphy(pi, (1 << 1),
 					 (s8) (pi->nphy_txpwrindex[1].
-						 index_internal), FALSE);
+						 index_internal), false);
 	}
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, false);
 
 	if (!phy_b3) {
 		wlapi_enable_mac(pi->sh->physhim);
@@ -27682,7 +27682,7 @@ void wlc_phy_txpwr_fixpower_nphy(phy_inf
 	and_phy_reg(pi, 0xbf, (u16) (~(0x1f << 0)));
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 static void
@@ -28296,7 +28296,7 @@ static void wlc_phy_txpwrctrl_coeff_setu
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 static void wlc_phy_ipa_internal_tssi_setup_nphy(phy_info_t *pi)
@@ -28432,7 +28432,7 @@ static void wlc_phy_txpwrctrl_idle_tssi_
 
 	wlc_phy_stopplayback_nphy(pi);
 
-	wlc_phy_tx_tone_nphy(pi, 4000, 0, 0, 0, FALSE);
+	wlc_phy_tx_tone_nphy(pi, 4000, 0, 0, 0, false);
 
 	OSL_DELAY(20);
 	int_val =
@@ -28709,7 +28709,7 @@ static void wlc_phy_txpwrctrl_pwr_setup_
 				 pi->adj_pwr_tbl_nphy);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 static bool wlc_phy_txpwr_ison_nphy(phy_info_t *pi)
@@ -28916,7 +28916,7 @@ void wlc_phy_txpwrctrl_enable_nphy(phy_i
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 void
@@ -29155,7 +29155,7 @@ wlc_phy_txpwr_index_nphy(phy_info_t *pi,
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, false);
 }
 
 void
@@ -29228,7 +29228,7 @@ void wlc_nphy_deaf_mode(phy_info_t *pi,
 			wlc_phy_stay_in_carriersearch_nphy(pi, true);
 	} else {
 		if (pi->nphy_deaf_count > 0)
-			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+			wlc_phy_stay_in_carriersearch_nphy(pi, false);
 	}
 	wlapi_enable_mac(pi->sh->physhim);
 }
--- a/drivers/staging/brcm80211/sys/wl_export.h
+++ b/drivers/staging/brcm80211/sys/wl_export.h
@@ -50,7 +50,7 @@ extern uint wl_buf_to_pktcopy(osl_t *osh
 extern void *wl_get_pktbuffer(osl_t *osh, int len);
 extern int wl_set_pktlen(osl_t *osh, void *p, int len);
 
-#define wl_sort_bsslist(a, b) FALSE
+#define wl_sort_bsslist(a, b) false
 
 extern int wl_tkip_miccheck(struct wl_info *wl, void *p, int hdr_len,
 			    bool group_key, int id);
--- a/drivers/staging/brcm80211/sys/wl_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.c
@@ -1373,7 +1373,7 @@ static int wl_suspend(struct pci_dev *pd
 
 	WL_LOCK(wl);
 	wl_down(wl);
-	wl->pub->hw_up = FALSE;
+	wl->pub->hw_up = false;
 	WL_UNLOCK(wl);
 	pci_save_state(pdev, wl->pci_psstate);
 	pci_disable_device(pdev);
@@ -1802,7 +1802,7 @@ irqreturn_t BCMFASTPATH wl_isr(int irq,
 
 			/* ...and call the second level interrupt handler */
 			/* schedule dpc */
-			ASSERT(wl->resched == FALSE);
+			ASSERT(wl->resched == false);
 			tasklet_schedule(&wl->tasklet);
 		}
 	}
@@ -1901,7 +1901,7 @@ static void _wl_timer(wl_timer_t *t)
 			add_timer(&t->timer);
 			t->set = true;
 		} else
-			t->set = FALSE;
+			t->set = false;
 
 		t->fn(t->arg);
 	}
@@ -1964,13 +1964,13 @@ void wl_add_timer(wl_info_t *wl, wl_time
 	add_timer(&t->timer);
 }
 
-/* return true if timer successfully deleted, FALSE if still pending */
+/* return true if timer successfully deleted, false if still pending */
 bool wl_del_timer(wl_info_t *wl, wl_timer_t *t)
 {
 	if (t->set) {
-		t->set = FALSE;
+		t->set = false;
 		if (!del_timer(&t->timer)) {
-			return FALSE;
+			return false;
 		}
 		atomic_dec(&wl->callbacks);
 	}
@@ -2080,7 +2080,7 @@ static int BCMFASTPATH wl_start(struct s
 	}
 	wl->txq_tail = skb;
 
-	if (wl->txq_dispatched == FALSE) {
+	if (wl->txq_dispatched == false) {
 		wl->txq_dispatched = true;
 
 		if (schedule_work(&wl->txq_task.work)) {
@@ -2133,7 +2133,7 @@ static void wl_start_txqwork(struct wl_t
 			atomic_dec(&wl->callbacks);
 		}
 	} else {
-		wl->txq_dispatched = FALSE;
+		wl->txq_dispatched = false;
 		TXQ_UNLOCK(wl, flags);
 		atomic_dec(&wl->callbacks);
 	}
@@ -2200,7 +2200,7 @@ static void wl_rpcq_dispatch(struct wl_t
 		RPCQ_LOCK(wl, flags);
 	}
 
-	wl->rpcq_dispatched = FALSE;
+	wl->rpcq_dispatched = false;
 
 	RPCQ_UNLOCK(wl, flags);
 
@@ -2223,7 +2223,7 @@ static void wl_rpcq_add(wl_info_t *wl, r
 
 	wl->rpcq_tail = buf;
 
-	if (wl->rpcq_dispatched == FALSE) {
+	if (wl->rpcq_dispatched == false) {
 		wl->rpcq_dispatched = true;
 		wl_schedule_task(wl, wl_rpcq_dispatch, wl);
 	}
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -190,12 +190,12 @@ ampdu_info_t *wlc_ampdu_attach(wlc_info_
 	for (i = 0; i < AMPDU_MAX_SCB_TID; i++)
 		ampdu->ini_enable[i] = true;
 	/* Disable ampdu for VO by default */
-	ampdu->ini_enable[PRIO_8021D_VO] = FALSE;
-	ampdu->ini_enable[PRIO_8021D_NC] = FALSE;
+	ampdu->ini_enable[PRIO_8021D_VO] = false;
+	ampdu->ini_enable[PRIO_8021D_NC] = false;
 
 	/* Disable ampdu for BK by default since not enough fifo space */
-	ampdu->ini_enable[PRIO_8021D_NONE] = FALSE;
-	ampdu->ini_enable[PRIO_8021D_BK] = FALSE;
+	ampdu->ini_enable[PRIO_8021D_NONE] = false;
+	ampdu->ini_enable[PRIO_8021D_BK] = false;
 
 	ampdu->ba_tx_wsize = AMPDU_TX_BA_DEF_WSIZE;
 	ampdu->ba_rx_wsize = AMPDU_RX_BA_DEF_WSIZE;
@@ -223,7 +223,7 @@ ampdu_info_t *wlc_ampdu_attach(wlc_info_
 	}
 
 	ampdu_update_max_txlen(ampdu, ampdu->dur);
-	ampdu->mfbr = FALSE;
+	ampdu->mfbr = false;
 	/* try to set ampdu to the default value */
 	wlc_ampdu_set(ampdu, wlc->pub->_ampdu);
 
@@ -261,7 +261,7 @@ void scb_ampdu_cleanup(ampdu_info_t *amp
 	ASSERT(scb_ampdu);
 
 	for (tid = 0; tid < AMPDU_MAX_SCB_TID; tid++) {
-		ampdu_cleanup_tid_ini(ampdu, scb_ampdu, tid, FALSE);
+		ampdu_cleanup_tid_ini(ampdu, scb_ampdu, tid, false);
 	}
 }
 
@@ -335,7 +335,7 @@ static void wlc_ffpld_init(ampdu_info_t
 static int wlc_ffpld_check_txfunfl(wlc_info_t *wlc, int fid)
 {
 	ampdu_info_t *ampdu = wlc->ampdu;
-	u32 phy_rate = MCS_RATE(FFPLD_MAX_MCS, true, FALSE);
+	u32 phy_rate = MCS_RATE(FFPLD_MAX_MCS, true, false);
 	u32 txunfl_ratio;
 	u8 max_mpdu;
 	u32 current_ampdu_cnt = 0;
@@ -463,7 +463,7 @@ static void wlc_ffpld_calc_mcs2ampdu_tab
 	/* note : we divide/multiply by 100 to avoid integer overflows */
 	max_mpdu =
 	    min_t(u8, fifo->mcs2ampdu_table[FFPLD_MAX_MCS], AMPDU_NUM_MPDU_LEGACY);
-	phy_rate = MCS_RATE(FFPLD_MAX_MCS, true, FALSE);
+	phy_rate = MCS_RATE(FFPLD_MAX_MCS, true, false);
 	dma_rate =
 	    (((phy_rate / 100) *
 	      (max_mpdu * FFPLD_MPDU_SIZE - fifo->ampdu_pld_size))
@@ -474,7 +474,7 @@ static void wlc_ffpld_calc_mcs2ampdu_tab
 	dma_rate = dma_rate >> 7;
 	for (i = 0; i < FFPLD_MAX_MCS; i++) {
 		/* shifting to keep it within integer range */
-		phy_rate = MCS_RATE(i, true, FALSE) >> 7;
+		phy_rate = MCS_RATE(i, true, false) >> 7;
 		if (phy_rate > dma_rate) {
 			tmp = ((fifo->ampdu_pld_size * phy_rate) /
 			       ((phy_rate - dma_rate) * FFPLD_MPDU_SIZE)) + 1;
@@ -496,7 +496,7 @@ wlc_ampdu_agg(ampdu_info_t *ampdu, struc
 	/* initialize initiator on first packet; sends addba req */
 	ini = SCB_AMPDU_INI(scb_ampdu, tid);
 	if (ini->magic != INI_MAGIC) {
-		ini = wlc_ampdu_init_tid_ini(ampdu, scb_ampdu, tid, FALSE);
+		ini = wlc_ampdu_init_tid_ini(ampdu, scb_ampdu, tid, false);
 	}
 	return;
 }
@@ -514,7 +514,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 	u8 rts_preamble_type = WLC_LONG_PREAMBLE;
 	u8 rts_fbr_preamble_type = WLC_LONG_PREAMBLE;
 
-	bool rr = true, fbr = FALSE;
+	bool rr = true, fbr = false;
 	uint i, count = 0, fifo, seg_cnt = 0;
 	u16 plen, len, seq = 0, mcl, mch, index, frameid, dma_len = 0;
 	u32 ampdu_len, maxlen = 0;
@@ -525,7 +525,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 	scb_ampdu_t *scb_ampdu;
 	scb_ampdu_tid_ini_t *ini;
 	u8 mcs = 0;
-	bool use_rts = FALSE, use_cts = FALSE;
+	bool use_rts = false, use_cts = false;
 	ratespec_t rspec = 0, rspec_fallback = 0;
 	ratespec_t rts_rspec = 0, rts_rspec_fallback = 0;
 	u16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
@@ -619,11 +619,11 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 		if (txrate[0].count <= rr_retry_limit) {
 			txrate[0].count++;
 			rr = true;
-			fbr = FALSE;
+			fbr = false;
 			ASSERT(!fbr);
 		} else {
 			fbr = true;
-			rr = FALSE;
+			rr = false;
 			txrate[1].count++;
 		}
 
@@ -729,17 +729,17 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 
 			if (use_rts || use_cts) {
 				rts_rspec =
-				    wlc_rspec_to_rts_rspec(wlc, rspec, FALSE,
+				    wlc_rspec_to_rts_rspec(wlc, rspec, false,
 							   mimo_ctlchbw);
 				rts_rspec_fallback =
 				    wlc_rspec_to_rts_rspec(wlc, rspec_fallback,
-							   FALSE, mimo_ctlchbw);
+							   false, mimo_ctlchbw);
 			}
 		}
 
 		/* if (first mpdu for host agg) */
 		/* test whether to add more */
-		if ((MCS_RATE(mcs, true, FALSE) >= f->dmaxferrate) &&
+		if ((MCS_RATE(mcs, true, false) >= f->dmaxferrate) &&
 		    (count == f->mcs2ampdu_table[mcs])) {
 			WL_AMPDU_ERR(("wl%d: PR 37644: stopping ampdu at %d for mcs %d", wlc->pub->unit, count, mcs));
 			break;
@@ -831,7 +831,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 		}
 
 		/* set the preload length */
-		if (MCS_RATE(mcs, true, FALSE) >= f->dmaxferrate) {
+		if (MCS_RATE(mcs, true, false) >= f->dmaxferrate) {
 			dma_len = min(dma_len, f->ampdu_pld_size);
 			txh->PreloadSize = htol16(dma_len);
 		} else
@@ -899,7 +899,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 #ifdef WLC_HIGH_ONLY
 		if (wlc->rpc_agg & BCM_RPC_TP_HOST_AGG_AMPDU)
 			bcm_rpc_tp_agg_set(bcm_rpc_tp_get(wlc->rpc),
-					   BCM_RPC_TP_HOST_AGG_AMPDU, FALSE);
+					   BCM_RPC_TP_HOST_AGG_AMPDU, false);
 #endif
 
 	}
@@ -990,7 +990,7 @@ void wlc_ampdu_txstatus_complete(ampdu_i
 		ampdu->p = NULL;
 	}
 
-	ampdu->waiting_status = FALSE;
+	ampdu->waiting_status = false;
 }
 #endif				/* WLC_HIGH_ONLY */
 void rate_status(wlc_info_t *wlc, struct ieee80211_tx_info *tx_info,
@@ -1028,10 +1028,10 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 	struct dot11_header *h;
 	u16 seq, start_seq = 0, bindex, index, mcl;
 	u8 mcs = 0;
-	bool ba_recd = FALSE, ack_recd = FALSE;
+	bool ba_recd = false, ack_recd = false;
 	u8 suc_mpdu = 0, tot_mpdu = 0;
 	uint supr_status;
-	bool update_rate = true, retry = true, tx_error = FALSE;
+	bool update_rate = true, retry = true, tx_error = false;
 	u16 mimoantsel = 0;
 	u8 antselid = 0;
 	u8 retry_limit, rr_retry_limit;
@@ -1064,7 +1064,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 
 	if (txs->status & TX_STATUS_ACK_RCV) {
 		if (TX_STATUS_SUPR_UF == supr_status) {
-			update_rate = FALSE;
+			update_rate = false;
 		}
 
 		ASSERT(txs->status & TX_STATUS_INTERMEDIATE);
@@ -1091,7 +1091,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 	} else {
 		WLCNTINCR(ampdu->cnt->noba);
 		if (supr_status) {
-			update_rate = FALSE;
+			update_rate = false;
 			if (supr_status == TX_STATUS_SUPR_BADCH) {
 				WL_ERROR(("%s: Pkt tx suppressed, illegal channel possibly %d\n", __func__, CHSPEC_CHANNEL(wlc->default_bss->chanspec)));
 			} else {
@@ -1104,7 +1104,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 			/* no need to retry for badch; will fail again */
 			if (supr_status == TX_STATUS_SUPR_BADCH ||
 			    supr_status == TX_STATUS_SUPR_EXPTIME) {
-				retry = FALSE;
+				retry = false;
 				WLCNTINCR(wlc->pub->_cnt->txchanrej);
 			} else if (supr_status == TX_STATUS_SUPR_EXPTIME) {
 
@@ -1126,7 +1126,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 				}
 			}
 		} else if (txs->phyerr) {
-			update_rate = FALSE;
+			update_rate = false;
 			WLCNTINCR(wlc->pub->_cnt->txphyerr);
 			WL_ERROR(("wl%d: wlc_ampdu_dotxstatus: tx phy error (0x%x)\n", wlc->pub->unit, txs->phyerr));
 
@@ -1156,7 +1156,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 		}
 
 		index = TX_SEQ_TO_INDEX(seq);
-		ack_recd = FALSE;
+		ack_recd = false;
 		if (ba_recd) {
 			bindex = MODSUB_POW2(seq, start_seq, SEQNUM_MAX);
 
@@ -1296,7 +1296,7 @@ int wlc_ampdu_set(ampdu_info_t *ampdu, b
 {
 	wlc_info_t *wlc = ampdu->wlc;
 
-	wlc->pub->_ampdu = FALSE;
+	wlc->pub->_ampdu = false;
 
 	if (on) {
 		if (!N_ENAB(wlc->pub)) {
@@ -1320,7 +1320,7 @@ bool wlc_ampdu_cap(ampdu_info_t *ampdu)
 	if (WLC_PHY_11N_CAP(ampdu->wlc->band))
 		return true;
 	else
-		return FALSE;
+		return false;
 }
 
 static void ampdu_update_max_txlen(ampdu_info_t *ampdu, u8 dur)
@@ -1330,13 +1330,13 @@ static void ampdu_update_max_txlen(ampdu
 	for (mcs = 0; mcs < MCS_TABLE_SIZE; mcs++) {
 		/* rate is in Kbps; dur is in msec ==> len = (rate * dur) / 8 */
 		/* 20MHz, No SGI */
-		rate = MCS_RATE(mcs, FALSE, FALSE);
+		rate = MCS_RATE(mcs, false, false);
 		ampdu->max_txlen[mcs][0][0] = (rate * dur) >> 3;
 		/* 40 MHz, No SGI */
-		rate = MCS_RATE(mcs, true, FALSE);
+		rate = MCS_RATE(mcs, true, false);
 		ampdu->max_txlen[mcs][1][0] = (rate * dur) >> 3;
 		/* 20MHz, SGI */
-		rate = MCS_RATE(mcs, FALSE, true);
+		rate = MCS_RATE(mcs, false, true);
 		ampdu->max_txlen[mcs][0][1] = (rate * dur) >> 3;
 		/* 40 MHz, SGI */
 		rate = MCS_RATE(mcs, true, true);
--- a/drivers/staging/brcm80211/sys/wlc_antsel.c
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.c
@@ -105,7 +105,7 @@ antsel_info_t *wlc_antsel_attach(wlc_inf
 	asi->wlc = wlc;
 	asi->pub = pub;
 	asi->antsel_type = ANTSEL_NA;
-	asi->antsel_avail = FALSE;
+	asi->antsel_avail = false;
 	asi->antsel_antswitch = (u8) getintvar(asi->pub->vars, "antswitch");
 
 	if ((asi->pub->sromrev >= 4) && (asi->antsel_antswitch != 0)) {
@@ -124,9 +124,9 @@ antsel_info_t *wlc_antsel_attach(wlc_inf
 				 3)
 				|| ((u16) getintvar(asi->pub->vars, "aa5g")
 				    == 3)) {
-				asi->antsel_avail = FALSE;
+				asi->antsel_avail = false;
 			} else {
-				asi->antsel_avail = FALSE;
+				asi->antsel_avail = false;
 				WL_ERROR(("wlc_antsel_attach: 2o3 board cfg invalid\n"));
 				ASSERT(0);
 			}
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -266,7 +266,7 @@ static u32 WLBANDINITFN(wlc_setband_inac
 
 /* Process received frames */
 /*
- * Return true if more frames need to be processed. FALSE otherwise.
+ * Return true if more frames need to be processed. false otherwise.
  * Param 'bound' indicates max. # frames to process before break out.
  */
 static bool BCMFASTPATH
@@ -321,7 +321,7 @@ wlc_bmac_recv(wlc_hw_info_t *wlc_hw, uin
 }
 
 /* second-level interrupt processing
- *   Return true if another dpc needs to be re-scheduled. FALSE otherwise.
+ *   Return true if another dpc needs to be re-scheduled. false otherwise.
  *   Param 'bounded' indicates if applicable loops should be bounded.
  */
 bool BCMFASTPATH wlc_dpc(wlc_info_t *wlc, bool bounded)
@@ -329,12 +329,12 @@ bool BCMFASTPATH wlc_dpc(wlc_info_t *wlc
 	u32 macintstatus;
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
-	bool fatal = FALSE;
+	bool fatal = false;
 
 	if (DEVICEREMOVED(wlc)) {
 		WL_ERROR(("wl%d: %s: dead chip\n", wlc_hw->unit, __func__));
 		wl_down(wlc->wl);
-		return FALSE;
+		return false;
 	}
 
 	/* grab and clear the saved software intstatus bits */
@@ -594,7 +594,7 @@ static bool wlc_bmac_attach_dmapio(wlc_i
 
 		if (!wl_alloc_dma_resources(wlc_hw->wlc->wl, addrwidth)) {
 			WL_ERROR(("wl%d: wlc_attach: alloc_dma_resources failed\n", unit));
-			return FALSE;
+			return false;
 		}
 
 		/*
@@ -668,7 +668,7 @@ static bool wlc_bmac_attach_dmapio(wlc_i
 		if (dma_attach_err) {
 			WL_ERROR(("wl%d: wlc_attach: dma_attach failed\n",
 				  unit));
-			return FALSE;
+			return false;
 		}
 
 		/* get pointer to dma engine tx flow control variable */
@@ -713,7 +713,7 @@ int wlc_bmac_attach(wlc_info_t *wlc, u16
 	char *vars;
 	uint err = 0;
 	uint j;
-	bool wme = FALSE;
+	bool wme = false;
 	shared_phy_params_t sha_params;
 
 	WL_TRACE(("wl%d: wlc_bmac_attach: vendor 0x%x device 0x%x\n", unit,
@@ -803,7 +803,7 @@ int wlc_bmac_attach(wlc_info_t *wlc, u16
 
 	/* request fastclock and force fastclock for the rest of attach
 	 * bring the d11 core out of reset.
-	 *   For PMU chips, the first wlc_clkctl_clk is no-op since core-clk is still FALSE;
+	 *   For PMU chips, the first wlc_clkctl_clk is no-op since core-clk is still false;
 	 *   But it will be called again inside wlc_corereset, after d11 is out of reset.
 	 */
 	wlc_clkctl_clk(wlc_hw, CLK_FAST);
@@ -1009,7 +1009,7 @@ int wlc_bmac_attach(wlc_info_t *wlc, u16
 	 * or cores are in reset with clocks off, and the board PLLs
 	 * are off if possible.
 	 *
-	 * Beyond this point, wlc->sbclk == FALSE and chip registers
+	 * Beyond this point, wlc->sbclk == false and chip registers
 	 * should not be touched.
 	 *********************************************************************
 	 */
@@ -1054,7 +1054,7 @@ void wlc_bmac_info_init(wlc_hw_info_t *w
 	wlc->defmacintmask = DEF_MACINTMASK;
 
 	/* various 802.11g modes */
-	wlc_hw->shortslot = FALSE;
+	wlc_hw->shortslot = false;
 
 	wlc_hw->SFBL = RETRY_SHORT_FB;
 	wlc_hw->LFBL = RETRY_LONG_FB;
@@ -1287,15 +1287,15 @@ int wlc_bmac_down_finish(wlc_hw_info_t *
 	if (!wlc_hw->up)
 		return callbacks;
 
-	wlc_hw->up = FALSE;
-	wlc_phy_hw_state_upd(wlc_hw->band->pi, FALSE);
+	wlc_hw->up = false;
+	wlc_phy_hw_state_upd(wlc_hw->band->pi, false);
 
 	dev_gone = DEVICEREMOVED(wlc_hw->wlc);
 
 	if (dev_gone) {
-		wlc_hw->sbclk = FALSE;
-		wlc_hw->clk = FALSE;
-		wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, FALSE);
+		wlc_hw->sbclk = false;
+		wlc_hw->clk = false;
+		wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, false);
 
 		/* reclaim any posted packets */
 		wlc_flushqueues(wlc_hw->wlc);
@@ -2042,7 +2042,7 @@ void wlc_bmac_phy_reset(wlc_hw_info_t *w
 {
 	wlc_phy_t *pih = wlc_hw->band->pi;
 	u32 phy_bw_clkbits;
-	bool phy_in_reset = FALSE;
+	bool phy_in_reset = false;
 
 	WL_TRACE(("wl%d: wlc_bmac_phy_reset\n", wlc_hw->unit));
 
@@ -2146,7 +2146,7 @@ static bool wlc_isgoodchip(wlc_hw_info_t
 	/* reject unsupported corerev */
 	if (!VALID_COREREV(wlc_hw->corerev)) {
 		WL_ERROR(("unsupported core rev %d\n", wlc_hw->corerev));
-		return FALSE;
+		return false;
 	}
 
 	return true;
@@ -2158,7 +2158,7 @@ static bool wlc_validboardtype(wlc_hw_in
 	uint boardrev = wlc_hw->boardrev;
 
 	if (boardrev == 0)
-		goodboard = FALSE;
+		goodboard = false;
 	else if (boardrev > 0xff) {
 		uint brt = (boardrev & 0xf000) >> 12;
 		uint b0 = (boardrev & 0xf00) >> 8;
@@ -2167,7 +2167,7 @@ static bool wlc_validboardtype(wlc_hw_in
 
 		if ((brt > 2) || (brt == 0) || (b0 > 9) || (b0 == 0) || (b1 > 9)
 		    || (b2 > 9))
-			goodboard = FALSE;
+			goodboard = false;
 	}
 
 	if (wlc_hw->sih->boardvendor != VENDOR_BROADCOM)
@@ -2200,7 +2200,7 @@ static char *wlc_get_macaddr(wlc_hw_info
 }
 
 /*
- * Return true if radio is disabled, otherwise FALSE.
+ * Return true if radio is disabled, otherwise false.
  * hw radio disable signal is an external pin, users activate it asynchronously
  * this function could be called when driver is down and w/o clock
  * it operates on different registers depending on corerev and boardflag.
@@ -2281,7 +2281,7 @@ void wlc_bmac_hw_up(wlc_hw_info_t *wlc_h
 	/* Inform phy that a POR reset has occurred so it does a complete phy init */
 	wlc_phy_por_inform(wlc_hw->band->pi);
 
-	wlc_hw->ucode_loaded = FALSE;
+	wlc_hw->ucode_loaded = false;
 	wlc_hw->wlc->pub->hw_up = true;
 
 	if ((wlc_hw->boardflags & BFL_FEM)
@@ -2387,7 +2387,7 @@ void wlc_bmac_corereset(wlc_hw_info_t *w
 	 *  chipcommon during this period if necessary. But that has to work coordinate
 	 *  with other driver like mips/arm since they may touch chipcommon as well.
 	 */
-	wlc_hw->clk = FALSE;
+	wlc_hw->clk = false;
 	si_core_reset(wlc_hw->sih, flags, resetbits);
 	wlc_hw->clk = true;
 	if (wlc_hw->band && wlc_hw->band->pi)
@@ -2482,7 +2482,7 @@ static void wlc_coreinit(wlc_info_t *wlc
 	u32 sflags;
 	uint bcnint_us;
 	uint i = 0;
-	bool fifosz_fixup = FALSE;
+	bool fifosz_fixup = false;
 	osl_t *osh;
 	int err = 0;
 	u16 buf[NFIFO];
@@ -2750,7 +2750,7 @@ static void wlc_gpio_init(wlc_info_t *wl
 				     MHF3_ANTSEL_MODE, WLC_BAND_ALL);
 
 			/* init superswitch control */
-			wlc_phy_antsel_init(wlc_hw->band->pi, FALSE);
+			wlc_phy_antsel_init(wlc_hw->band->pi, false);
 
 		} else if (wlc_hw->antsel_type == ANTSEL_2x4) {
 			ASSERT((gm & BOARD_GPIO_12) == 0);
@@ -2898,7 +2898,7 @@ void wlc_bmac_antsel_type_set(wlc_hw_inf
 
 void wlc_bmac_fifoerrors(wlc_hw_info_t *wlc_hw)
 {
-	bool fatal = FALSE;
+	bool fatal = false;
 	uint unit;
 	uint intstatus, idx;
 	d11regs_t *regs = wlc_hw->regs;
@@ -3109,7 +3109,7 @@ bool wlc_bmac_tx_fifo_suspended(wlc_hw_i
 	     (1 << tx_fifo)) == 0)
 		return true;
 
-	return FALSE;
+	return false;
 }
 
 void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t *wlc_hw, uint tx_fifo)
@@ -3262,7 +3262,7 @@ static inline u32 wlc_intstatus(wlc_info
 }
 
 /* Update wlc->macintstatus and wlc->intstatus[]. */
-/* Return true if they are updated successfully. FALSE otherwise */
+/* Return true if they are updated successfully. false otherwise */
 bool wlc_intrsupd(wlc_info_t *wlc)
 {
 	u32 macintstatus;
@@ -3270,11 +3270,11 @@ bool wlc_intrsupd(wlc_info_t *wlc)
 	ASSERT(wlc->macintstatus != 0);
 
 	/* read and clear macintstatus and intstatus registers */
-	macintstatus = wlc_intstatus(wlc, FALSE);
+	macintstatus = wlc_intstatus(wlc, false);
 
 	/* device is removed */
 	if (macintstatus == 0xffffffff)
-		return FALSE;
+		return false;
 
 	/* update interrupt status in software */
 	wlc->macintstatus |= macintstatus;
@@ -3284,19 +3284,19 @@ bool wlc_intrsupd(wlc_info_t *wlc)
 
 /*
  * First-level interrupt processing.
- * Return true if this was our interrupt, FALSE otherwise.
+ * Return true if this was our interrupt, false otherwise.
  * *wantdpc will be set to true if further wlc_dpc() processing is required,
- * FALSE otherwise.
+ * false otherwise.
  */
 bool BCMFASTPATH wlc_isr(wlc_info_t *wlc, bool *wantdpc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	u32 macintstatus;
 
-	*wantdpc = FALSE;
+	*wantdpc = false;
 
 	if (!wlc_hw->up || !wlc->macintmask)
-		return FALSE;
+		return false;
 
 	/* read and clear macintstatus and intstatus registers */
 	macintstatus = wlc_intstatus(wlc, true);
@@ -3306,7 +3306,7 @@ bool BCMFASTPATH wlc_isr(wlc_info_t *wlc
 
 	/* it is not for us */
 	if (macintstatus == 0)
-		return FALSE;
+		return false;
 
 	*wantdpc = true;
 
@@ -3324,7 +3324,7 @@ static bool wlc_bmac_txstatus_corerev4(w
 	void *status_p;
 	tx_status_t *txs;
 	osl_t *osh;
-	bool fatal = FALSE;
+	bool fatal = false;
 
 	WL_TRACE(("wl%d: wlc_txstatusrecv\n", wlc_hw->unit));
 
@@ -3342,7 +3342,7 @@ static bool wlc_bmac_txstatus_corerev4(w
 
 		fatal = wlc_bmac_dotxstatus(wlc_hw, txs, 0);
 
-		PKTFREE(osh, status_p, FALSE);
+		PKTFREE(osh, status_p, false);
 	}
 
 	if (fatal)
@@ -3351,7 +3351,7 @@ static bool wlc_bmac_txstatus_corerev4(w
 	/* post more rbufs */
 	dma_rxfill(wlc_hw->di[RX_TXSTATUS_FIFO]);
 
-	return FALSE;
+	return false;
 }
 
 static bool BCMFASTPATH
@@ -3364,19 +3364,19 @@ wlc_bmac_dotxstatus(wlc_hw_info_t *wlc_h
 	 */
 	if (!(txs->status & TX_STATUS_AMPDU)
 	    && (txs->status & TX_STATUS_INTERMEDIATE)) {
-		return FALSE;
+		return false;
 	}
 
 	return wlc_dotxstatus(wlc_hw->wlc, txs, s2);
 }
 
 /* process tx completion events in BMAC
- * Return true if more tx status need to be processed. FALSE otherwise.
+ * Return true if more tx status need to be processed. false otherwise.
  */
 static bool BCMFASTPATH
 wlc_bmac_txstatus(wlc_hw_info_t *wlc_hw, bool bound, bool *fatal)
 {
-	bool morepending = FALSE;
+	bool morepending = false;
 	wlc_info_t *wlc = wlc_hw->wlc;
 
 	WL_TRACE(("wl%d: wlc_bmac_txstatus\n", wlc_hw->unit));
@@ -3693,7 +3693,7 @@ bool wlc_bmac_validate_chip_access(wlc_h
 	val = R_REG(osh, &regs->objdata);
 	if (val != (u32) 0xaa5555aa) {
 		WL_ERROR(("wl%d: validate_chip_access: SHM = 0x%x, expected 0xaa5555aa\n", wlc_hw->unit, val));
-		return FALSE;
+		return false;
 	}
 
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
@@ -3705,7 +3705,7 @@ bool wlc_bmac_validate_chip_access(wlc_h
 	val = R_REG(osh, &regs->objdata);
 	if (val != (u32) 0x55aaaa55) {
 		WL_ERROR(("wl%d: validate_chip_access: SHM = 0x%x, expected 0x55aaaa55\n", wlc_hw->unit, val));
-		return FALSE;
+		return false;
 	}
 
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
@@ -3735,12 +3735,12 @@ bool wlc_bmac_validate_chip_access(wlc_h
 		val = R_REG(osh, &regs->tsf_cfpstrt_l);
 		if (val != (uint) 0xBBBB) {
 			WL_ERROR(("wl%d: validate_chip_access: tsf_cfpstrt_l = 0x%x, expected" " 0x%x\n", wlc_hw->unit, val, 0xBBBB));
-			return FALSE;
+			return false;
 		}
 		val = R_REG(osh, &regs->tsf_cfpstrt_h);
 		if (val != (uint) 0xCCCC) {
 			WL_ERROR(("wl%d: validate_chip_access: tsf_cfpstrt_h = 0x%x, expected" " 0x%x\n", wlc_hw->unit, val, 0xCCCC));
-			return FALSE;
+			return false;
 		}
 
 	}
@@ -3752,7 +3752,7 @@ bool wlc_bmac_validate_chip_access(wlc_h
 	if ((w != (MCTL_IHR_EN | MCTL_WAKE)) &&
 	    (w != (MCTL_IHR_EN | MCTL_GMODE | MCTL_WAKE))) {
 		WL_ERROR(("wl%d: validate_chip_access: maccontrol = 0x%x, expected 0x%x or 0x%x\n", wlc_hw->unit, w, (MCTL_IHR_EN | MCTL_WAKE), (MCTL_IHR_EN | MCTL_GMODE | MCTL_WAKE)));
-		return FALSE;
+		return false;
 	}
 
 	return true;
@@ -3842,7 +3842,7 @@ void wlc_coredisable(wlc_hw_info_t *wlc_
 	wlc_phy_anacore(wlc_hw->band->pi, OFF);
 
 	/* turn off PHYPLL to save power */
-	wlc_bmac_core_phypll_ctl(wlc_hw, FALSE);
+	wlc_bmac_core_phypll_ctl(wlc_hw, false);
 
 	/* No need to set wlc->pub->radio_active = OFF
 	 * because this function needs down capability and
@@ -3853,9 +3853,9 @@ void wlc_coredisable(wlc_hw_info_t *wlc_
 	if (wlc_hw->ucode_dbgsel)
 		si_gpiocontrol(wlc_hw->sih, ~0, 0, GPIO_DRV_PRIORITY);
 
-	wlc_hw->clk = FALSE;
+	wlc_hw->clk = false;
 	si_core_disable(wlc_hw->sih, 0);
-	wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, FALSE);
+	wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, false);
 }
 
 /* power both the pll and external oscillator on/off */
@@ -3872,9 +3872,9 @@ void wlc_bmac_xtal(wlc_hw_info_t *wlc_hw
 
 	wlc_hw->sbclk = want;
 	if (!wlc_hw->sbclk) {
-		wlc_hw->clk = FALSE;
+		wlc_hw->clk = false;
 		if (wlc_hw->band && wlc_hw->band->pi)
-			wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, FALSE);
+			wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, false);
 	}
 }
 
@@ -4143,8 +4143,8 @@ void wlc_gpio_fast_deinit(wlc_hw_info_t
 bool wlc_bmac_radio_hw(wlc_hw_info_t *wlc_hw, bool enable)
 {
 	/* Do not access Phy registers if core is not up */
-	if (si_iscoreup(wlc_hw->sih) == FALSE)
-		return FALSE;
+	if (si_iscoreup(wlc_hw->sih) == false)
+		return false;
 
 	if (enable) {
 		if (PMUCTL_ENAB(wlc_hw->sih)) {
@@ -4166,7 +4166,7 @@ bool wlc_bmac_radio_hw(wlc_hw_info_t *wl
 		wlc_phy_anacore(wlc_hw->band->pi, OFF);
 
 		if (PMUCTL_ENAB(wlc_hw->sih)) {
-			si_pmu_radio_enable(wlc_hw->sih, FALSE);
+			si_pmu_radio_enable(wlc_hw->sih, false);
 			OR_REG(wlc_hw->osh, &wlc_hw->regs->clk_ctl_st,
 			       CCS_FORCEHWREQOFF);
 		}
--- a/drivers/staging/brcm80211/sys/wlc_channel.c
+++ b/drivers/staging/brcm80211/sys/wlc_channel.c
@@ -682,14 +682,14 @@ wlc_channel_get_chanvec(struct wlc_info
 
 	country = wlc_country_lookup(wlc, country_abbrev);
 	if (country == NULL)
-		return FALSE;
+		return false;
 
 	if (bandtype == WLC_BAND_2G)
 		locale = wlc_get_locale_2g(country->locale_2G);
 	else if (bandtype == WLC_BAND_5G)
 		locale = wlc_get_locale_5g(country->locale_5G);
 	if (locale == NULL)
-		return FALSE;
+		return false;
 
 	wlc_locale_get_channels(locale, channels);
 	return true;
@@ -775,7 +775,7 @@ wlc_set_country_common(wlc_cm_info_t *wl
 		wlc_set_nmode(wlc, OFF);
 		wlc->stf->no_cddstbc = true;
 	} else {
-		wlc->stf->no_cddstbc = FALSE;
+		wlc->stf->no_cddstbc = false;
 		if (N_ENAB(wlc->pub) != wlc->protection->nmode_user)
 			wlc_set_nmode(wlc, wlc->protection->nmode_user);
 	}
@@ -785,9 +785,9 @@ wlc_set_country_common(wlc_cm_info_t *wl
 	/* set or restore gmode as required by regulatory */
 	locale = wlc_get_locale_2g(country->locale_2G);
 	if (locale && (locale->flags & WLC_NO_OFDM)) {
-		wlc_set_gmode(wlc, GMODE_LEGACY_B, FALSE);
+		wlc_set_gmode(wlc, GMODE_LEGACY_B, false);
 	} else {
-		wlc_set_gmode(wlc, wlc->protection->gmode_user, FALSE);
+		wlc_set_gmode(wlc, wlc->protection->gmode_user, false);
 	}
 
 	wlc_channels_init(wlc_cm, country);
@@ -867,7 +867,7 @@ static int
 wlc_country_aggregate_map(wlc_cm_info_t *wlc_cm, const char *ccode,
 			  char *mapped_ccode, uint *mapped_regrev)
 {
-	return FALSE;
+	return false;
 }
 
 /* Lookup a country info structure from a null terminated country
@@ -986,7 +986,7 @@ static void wlc_channels_commit(wlc_cm_i
 	if (NBANDS(wlc) > 1 || BAND_2G(wlc->band->bandtype)) {
 		wlc_phy_chanspec_ch14_widefilter_set(wlc->band->pi,
 						     wlc_japan(wlc) ? true :
-						     FALSE);
+						     false);
 	}
 
 	if (wlc->pub->up && chan != INVCHANNEL) {
@@ -1539,12 +1539,12 @@ wlc_valid_chanspec_ext(wlc_cm_info_t *wl
 		WL_ERROR(("wl%d: malformed chanspec 0x%x\n", wlc->pub->unit,
 			  chspec));
 		ASSERT(0);
-		return FALSE;
+		return false;
 	}
 
 	if (CHANNEL_BANDUNIT(wlc_cm->wlc, channel) !=
 	    CHSPEC_WLCBANDUNIT(chspec))
-		return FALSE;
+		return false;
 
 	/* Check a 20Mhz channel */
 	if (CHSPEC_IS20(chspec)) {
@@ -1563,16 +1563,16 @@ wlc_valid_chanspec_ext(wlc_cm_info_t *wl
 		    sizeof(chan20_info) / sizeof(struct chan20_info);
 
 		if (!VALID_40CHANSPEC_IN_BAND(wlc, CHSPEC_WLCBANDUNIT(chspec)))
-			return FALSE;
+			return false;
 
 		if (dualband) {
 			if (!VALID_CHANNEL20_DB(wlc, LOWER_20_SB(channel)) ||
 			    !VALID_CHANNEL20_DB(wlc, UPPER_20_SB(channel)))
-				return FALSE;
+				return false;
 		} else {
 			if (!VALID_CHANNEL20(wlc, LOWER_20_SB(channel)) ||
 			    !VALID_CHANNEL20(wlc, UPPER_20_SB(channel)))
-				return FALSE;
+				return false;
 		}
 
 		/* find the lower sideband info in the sideband array */
@@ -1584,16 +1584,16 @@ wlc_valid_chanspec_ext(wlc_cm_info_t *wl
 		if ((upper_sideband & (CH_UPPER_SB | CH_EWA_VALID)) ==
 		    (CH_UPPER_SB | CH_EWA_VALID))
 			return true;
-		return FALSE;
+		return false;
 	}
 #endif				/* 40 MHZ */
 
-	return FALSE;
+	return false;
 }
 
 bool wlc_valid_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chspec)
 {
-	return wlc_valid_chanspec_ext(wlc_cm, chspec, FALSE);
+	return wlc_valid_chanspec_ext(wlc_cm, chspec, false);
 }
 
 bool wlc_valid_chanspec_db(wlc_cm_info_t *wlc_cm, chanspec_t chspec)
--- a/drivers/staging/brcm80211/sys/wlc_event.c
+++ b/drivers/staging/brcm80211/sys/wlc_event.c
@@ -88,13 +88,13 @@ int wlc_eventq_detach(wlc_eventq_t *eq)
 	if (eq->timer) {
 		if (eq->tpending) {
 			wl_del_timer(eq->wl, eq->timer);
-			eq->tpending = FALSE;
+			eq->tpending = false;
 		}
 		wl_free_timer(eq->wl, eq->timer);
 		eq->timer = NULL;
 	}
 
-	ASSERT(wlc_eventq_avail(eq) == FALSE);
+	ASSERT(wlc_eventq_avail(eq) == false);
 	MFREE(eq->pub->osh, eq, sizeof(wlc_eventq_t));
 	return 0;
 }
@@ -107,16 +107,16 @@ int wlc_eventq_down(wlc_eventq_t *eq)
 			callbacks++;
 
 		ASSERT(wlc_eventq_avail(eq) == true);
-		ASSERT(eq->workpending == FALSE);
+		ASSERT(eq->workpending == false);
 		eq->workpending = true;
 		if (eq->cb)
 			eq->cb(eq->wlc);
 
 		ASSERT(eq->workpending == true);
-		eq->workpending = FALSE;
-		eq->tpending = FALSE;
+		eq->workpending = false;
+		eq->tpending = false;
 	} else {
-		ASSERT(eq->workpending || wlc_eventq_avail(eq) == FALSE);
+		ASSERT(eq->workpending || wlc_eventq_avail(eq) == false);
 	}
 	return callbacks;
 }
@@ -216,14 +216,14 @@ static void wlc_timer_cb(void *arg)
 
 	ASSERT(eq->tpending == true);
 	ASSERT(wlc_eventq_avail(eq) == true);
-	ASSERT(eq->workpending == FALSE);
+	ASSERT(eq->workpending == false);
 	eq->workpending = true;
 
 	if (eq->cb)
 		eq->cb(eq->wlc);
 
-	ASSERT(wlc_eventq_avail(eq) == FALSE);
+	ASSERT(wlc_eventq_avail(eq) == false);
 	ASSERT(eq->tpending == true);
-	eq->workpending = FALSE;
-	eq->tpending = FALSE;
+	eq->workpending = false;
+	eq->tpending = false;
 }
--- a/drivers/staging/brcm80211/sys/wlc_key.h
+++ b/drivers/staging/brcm80211/sys/wlc_key.h
@@ -65,7 +65,7 @@ struct wlc_bsscfg;
 #define WSEC_KEY(wlc, i)	(((wlc)->wsec_keys[i] && (wlc)->wsec_keys[i]->len) ? \
 	(wlc)->wsec_keys[i] : NULL)
 
-#define WSEC_SCB_KEY_VALID(scb)	(((scb)->key && (scb)->key->len) ? true : FALSE)
+#define WSEC_SCB_KEY_VALID(scb)	(((scb)->key && (scb)->key->len) ? true : false)
 
 /* default key */
 #define WSEC_BSS_DEFAULT_KEY(bsscfg) (((bsscfg)->wsec_index == -1) ? \
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -114,7 +114,7 @@
 #define WLC_WAR16165(wlc) (BUSTYPE(wlc->pub->sih->bustype) == PCI_BUS && \
 				(!AP_ENAB(wlc->pub)) && (wlc->war16165))
 #else
-#define WLC_WAR16165(wlc) (FALSE)
+#define WLC_WAR16165(wlc) (false)
 #endif				/* WLC_HIGH_ONLY */
 
 /* debug/trace */
@@ -216,7 +216,7 @@ const u8 wme_fifo2ac[] = { AC_BK, AC_BE,
 /* WME/802.1E Access Category to TX FIFO number */
 static const u8 wme_ac2fifo[] = { 1, 0, 2, 3 };
 
-static bool in_send_q = FALSE;
+static bool in_send_q = false;
 
 /* Shared memory location index for various AC params */
 #define wme_shmemacindex(ac)	wme_ac2fifo[ac]
@@ -361,21 +361,21 @@ bool wlc_ps_allowed(wlc_info_t *wlc)
 
 	/* disallow PS when one of the following global conditions meets */
 	if (!wlc->pub->associated || !wlc->PMenabled || wlc->PM_override)
-		return FALSE;
+		return false;
 
 	/* disallow PS when one of these meets when not scanning */
 	if (!wlc->PMblocked) {
 		if (AP_ACTIVE(wlc) || wlc->monitor)
-			return FALSE;
+			return false;
 	}
 
 	FOREACH_AS_STA(wlc, idx, cfg) {
 		/* disallow PS when one of the following bsscfg specific conditions meets */
 		if (!cfg->BSS || !WLC_PORTOPEN(cfg))
-			return FALSE;
+			return false;
 
 		if (!cfg->dtim_programmed)
-			return FALSE;
+			return false;
 	}
 
 	return true;
@@ -385,7 +385,7 @@ void wlc_reset(wlc_info_t *wlc)
 {
 	WL_TRACE(("wl%d: wlc_reset\n", wlc->pub->unit));
 
-	wlc->check_for_unaligned_tbtt = FALSE;
+	wlc->check_for_unaligned_tbtt = false;
 
 	/* slurp up hw mac counters before core reset */
 	if (WLC_UPDATE_STATS(wlc)) {
@@ -458,7 +458,7 @@ void wlc_init(wlc_info_t *wlc)
 	chanspec_t chanspec;
 	int i;
 	wlc_bsscfg_t *bsscfg;
-	bool mute = FALSE;
+	bool mute = false;
 
 	WL_TRACE(("wl%d: wlc_init\n", wlc->pub->unit));
 
@@ -531,7 +531,7 @@ void wlc_init(wlc_info_t *wlc)
 
 	/* initialize maximum allowed duty cycle */
 	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_ofdm, true, true);
-	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_cck, FALSE, true);
+	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_cck, false, true);
 
 	/* Update some shared memory locations related to max AMPDU size allowed to received */
 	wlc_ampdu_shm_upd(wlc->ampdu);
@@ -542,7 +542,7 @@ void wlc_init(wlc_info_t *wlc)
 	/* Enable EDCF mode (while the MAC is suspended) */
 	if (EDCF_ENAB(wlc->pub)) {
 		OR_REG(wlc->osh, &regs->ifs_ctl, IFS_USEEDCF);
-		wlc_edcf_setparams(wlc->cfg, FALSE);
+		wlc_edcf_setparams(wlc->cfg, false);
 	}
 
 	/* Init precedence maps for empty FIFOs */
@@ -562,7 +562,7 @@ void wlc_init(wlc_info_t *wlc)
 	wlc_txflowcontrol_reset(wlc);
 
 	/* clear tx data fifo suspends */
-	wlc->tx_suspended = FALSE;
+	wlc->tx_suspended = false;
 
 	/* enable the RF Disable Delay timer */
 	if (D11REV_GE(wlc->pub->corerev, 10))
@@ -655,7 +655,7 @@ bool wlc_ps_check(wlc_info_t *wlc)
 					continue;
 			}
 
-			res = FALSE;
+			res = false;
 		}
 #ifdef WLC_LOW
 		/* For a monolithic build the wake check can be exact since it looks at wake
@@ -674,7 +674,7 @@ bool wlc_ps_check(wlc_info_t *wlc)
 #endif
 		if (hps && !wake_ok) {
 			WL_ERROR(("wl%d: wake not sync, sw %d maccontrol 0x%x\n", wlc->pub->unit, wake, tmp));
-			res = FALSE;
+			res = false;
 		}
 	}
 	ASSERT(res);
@@ -846,7 +846,7 @@ static void wlc_set_phy_chanspec(wlc_inf
 void wlc_set_chanspec(wlc_info_t *wlc, chanspec_t chanspec)
 {
 	uint bandunit;
-	bool switchband = FALSE;
+	bool switchband = false;
 	chanspec_t old_chanspec = wlc->chanspec;
 
 	if (!wlc_valid_chanspec_db(wlc->cmi, chanspec)) {
@@ -1093,13 +1093,13 @@ void wlc_watchdog_upd(wlc_info_t *wlc, b
 		return;
 	if (!tbtt && wlc->WDarmed) {
 		wl_del_timer(wlc->wl, wlc->wdtimer);
-		wlc->WDarmed = FALSE;
+		wlc->WDarmed = false;
 	}
 
 	/* stop watchdog timer and use tbtt interrupt to drive watchdog */
 	if (tbtt && wlc->WDarmed) {
 		wl_del_timer(wlc->wl, wlc->wdtimer);
-		wlc->WDarmed = FALSE;
+		wlc->WDarmed = false;
 		wlc->WDlast = OSL_SYSUPTIME();
 	}
 	/* arm watchdog timer and drive the watchdog there */
@@ -1231,7 +1231,7 @@ static void wlc_ht_update_ldpc(wlc_info_
 	if (wlc->pub->up) {
 		wlc_update_beacon(wlc);
 		wlc_update_probe_resp(wlc, true);
-		wlc_phy_ldpc_override_set(wlc->band->pi, (val ? true : FALSE));
+		wlc_phy_ldpc_override_set(wlc->band->pi, (val ? true : false));
 	}
 }
 
@@ -1301,7 +1301,7 @@ static void wlc_bandinit_ordered(wlc_inf
 
 		/* fill in hw_rate */
 		wlc_rateset_filter(&default_rateset, &wlc->band->hw_rateset,
-				   FALSE, WLC_RATES_CCK_OFDM, RATE_MASK,
+				   false, WLC_RATES_CCK_OFDM, RATE_MASK,
 				   (bool) N_ENAB(wlc->pub));
 
 		/* init basic rate lookup */
@@ -1543,7 +1543,7 @@ void wlc_edcf_setparams(wlc_bsscfg_t *cf
 
 	if (AP_ENAB(wlc->pub) && WME_ENAB(wlc->pub)) {
 		wlc_update_beacon(wlc);
-		wlc_update_probe_resp(wlc, FALSE);
+		wlc_update_probe_resp(wlc, false);
 	}
 
 	if (suspend)
@@ -1571,7 +1571,7 @@ bool wlc_timers_init(wlc_info_t *wlc, in
 	return true;
 
  fail:
-	return FALSE;
+	return false;
 }
 
 /*
@@ -1591,12 +1591,12 @@ void wlc_info_init(wlc_info_t *wlc, int
 	wlc->chanspec = CH20MHZ_CHSPEC(1);
 
 	/* initialize CCK preamble mode to unassociated state */
-	wlc->shortpreamble = FALSE;
+	wlc->shortpreamble = false;
 
 	wlc->legacy_probe = true;
 
 	/* various 802.11g modes */
-	wlc->shortslot = FALSE;
+	wlc->shortslot = false;
 	wlc->shortslot_override = WLC_SHORTSLOT_AUTO;
 
 	wlc->barker_overlap_control = true;
@@ -1604,12 +1604,12 @@ void wlc_info_init(wlc_info_t *wlc, int
 	wlc->txburst_limit_override = AUTO;
 
 	wlc_protection_upd(wlc, WLC_PROT_G_OVR, WLC_PROTECTION_AUTO);
-	wlc_protection_upd(wlc, WLC_PROT_G_SPEC, FALSE);
+	wlc_protection_upd(wlc, WLC_PROT_G_SPEC, false);
 
 	wlc_protection_upd(wlc, WLC_PROT_N_CFG_OVR, WLC_PROTECTION_AUTO);
 	wlc_protection_upd(wlc, WLC_PROT_N_CFG, WLC_N_PROTECTION_OFF);
 	wlc_protection_upd(wlc, WLC_PROT_N_NONGF_OVR, WLC_PROTECTION_AUTO);
-	wlc_protection_upd(wlc, WLC_PROT_N_NONGF, FALSE);
+	wlc_protection_upd(wlc, WLC_PROT_N_NONGF, false);
 	wlc_protection_upd(wlc, WLC_PROT_N_PAM_OVR, AUTO);
 
 	wlc_protection_upd(wlc, WLC_PROT_OVERLAP, WLC_PROTECTION_CTL_OVERLAP);
@@ -1637,30 +1637,30 @@ void wlc_info_init(wlc_info_t *wlc, int
 
 	/* init PM state */
 	wlc->PM = PM_OFF;	/* User's setting of PM mode through IOCTL */
-	wlc->PM_override = FALSE;	/* Prevents from going to PM if our AP is 'ill' */
-	wlc->PMenabled = FALSE;	/* Current PM state */
-	wlc->PMpending = FALSE;	/* Tracks whether STA indicated PM in the last attempt */
-	wlc->PMblocked = FALSE;	/* To allow blocking going into PM during RM and scans */
+	wlc->PM_override = false;	/* Prevents from going to PM if our AP is 'ill' */
+	wlc->PMenabled = false;	/* Current PM state */
+	wlc->PMpending = false;	/* Tracks whether STA indicated PM in the last attempt */
+	wlc->PMblocked = false;	/* To allow blocking going into PM during RM and scans */
 
 	/* In WMM Auto mode, PM is allowed if association is a UAPSD association */
-	wlc->WME_PM_blocked = FALSE;
+	wlc->WME_PM_blocked = false;
 
 	/* Init wme queuing method */
-	wlc->wme_prec_queuing = FALSE;
+	wlc->wme_prec_queuing = false;
 
 	/* Overrides for the core to stay awake under zillion conditions Look for STAY_AWAKE */
-	wlc->wake = FALSE;
+	wlc->wake = false;
 	/* Are we waiting for a response to PS-Poll that we sent */
-	wlc->PSpoll = FALSE;
+	wlc->PSpoll = false;
 
 	/* APSD defaults */
 	wlc->wme_apsd = true;
-	wlc->apsd_sta_usp = FALSE;
+	wlc->apsd_sta_usp = false;
 	wlc->apsd_trigger_timeout = 0;	/* disable the trigger timer */
 	wlc->apsd_trigger_ac = AC_BITMAP_ALL;
 
 	/* Set flag to indicate that hw keys should be used when available. */
-	wlc->wsec_swkeys = FALSE;
+	wlc->wsec_swkeys = false;
 
 	/* init the 4 static WEP default keys */
 	for (i = 0; i < WSEC_MAX_DEFAULT_KEYS; i++) {
@@ -1668,7 +1668,7 @@ void wlc_info_init(wlc_info_t *wlc, int
 		wlc->wsec_keys[i]->idx = (u8) i;
 	}
 
-	wlc->_regulatory_domain = FALSE;	/* 802.11d */
+	wlc->_regulatory_domain = false;	/* 802.11d */
 
 	/* WME QoS mode is Auto by default */
 	wlc->pub->_wme = AUTO;
@@ -1694,7 +1694,7 @@ static bool wlc_state_bmac_sync(wlc_info
 	wlc_bmac_state_t state_bmac;
 
 	if (wlc_bmac_state_get(wlc->hw, &state_bmac) != 0)
-		return FALSE;
+		return false;
 
 	wlc->machwcap = state_bmac.machwcap;
 	wlc_protection_upd(wlc, WLC_PROT_N_PAM_OVR,
@@ -1818,7 +1818,7 @@ void *wlc_attach(void *wl, u16 vendor, u
 	pub->osh = osh;
 	wlc->btparam = btparam;
 	pub->_piomode = piomode;
-	wlc->bandinit_pending = FALSE;
+	wlc->bandinit_pending = false;
 	/* By default restrict TKIP associations from 11n STA's */
 	wlc->ht_wsec_restriction = WLC_HT_TKIP_RESTRICT;
 
@@ -1931,7 +1931,7 @@ void *wlc_attach(void *wl, u16 vendor, u
 
 		/* fill in hw_rateset (used early by WLC_SET_RATESET) */
 		wlc_rateset_filter(&wlc->band->defrateset,
-				   &wlc->band->hw_rateset, FALSE,
+				   &wlc->band->hw_rateset, false,
 				   WLC_RATES_CCK_OFDM, RATE_MASK,
 				   (bool) N_ENAB(wlc->pub));
 	}
@@ -2415,10 +2415,10 @@ static void wlc_radio_hwdisable_upd(wlc_
 	}
 }
 
-/* return true if Minimum Power Consumption should be entered, FALSE otherwise */
+/* return true if Minimum Power Consumption should be entered, false otherwise */
 bool wlc_is_non_delay_mpc(wlc_info_t *wlc)
 {
-	return FALSE;
+	return false;
 }
 
 bool wlc_ismpc(wlc_info_t *wlc)
@@ -2471,7 +2471,7 @@ void wlc_radio_mpc_upd(wlc_info_t *wlc)
 	 * other than wlc->mpc_delay_off keeping the mpc off. In that case reset
 	 * wlc->mpc_delay_off to wlc->mpc_dlycnt, so that we restart the countdown of mpc_delay_off
 	 */
-	if ((wlc->prev_non_delay_mpc == FALSE) &&
+	if ((wlc->prev_non_delay_mpc == false) &&
 	    (wlc_is_non_delay_mpc(wlc) == true) && wlc->mpc_delay_off) {
 		wlc->mpc_delay_off = wlc->mpc_dlycnt;
 	}
@@ -2500,7 +2500,7 @@ static void wlc_down_led_upd(wlc_info_t
 	if (!AP_ENAB(wlc->pub)) {
 		wlc_pllreq(wlc, true, WLC_PLLREQ_FLIP);
 
-		wlc_pllreq(wlc, FALSE, WLC_PLLREQ_FLIP);
+		wlc_pllreq(wlc, false, WLC_PLLREQ_FLIP);
 	}
 }
 
@@ -2569,8 +2569,8 @@ bool wlc_radio_monitor_stop(wlc_info_t *
 	ASSERT((wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO) !=
 	       WL_SWFL_NOHWRADIO);
 
-	wlc->radio_monitor = FALSE;
-	wlc_pllreq(wlc, FALSE, WLC_PLLREQ_RADIO_MON);
+	wlc->radio_monitor = false;
+	wlc_pllreq(wlc, false, WLC_PLLREQ_RADIO_MON);
 	return wl_del_timer(wlc->wl, wlc->radio_timer);
 }
 
@@ -2580,7 +2580,7 @@ void wlc_out(wlc_info_t *wlc)
 	wlc_bmac_set_noreset(wlc->hw, true);
 	wlc_radio_upd(wlc);
 	wl_down(wlc->wl);
-	wlc_bmac_set_noreset(wlc->hw, FALSE);
+	wlc_bmac_set_noreset(wlc->hw, false);
 
 	/* core clk is true in BMAC driver due to noreset, need to mirror it in HIGH */
 	wlc->clk = true;
@@ -2588,7 +2588,7 @@ void wlc_out(wlc_info_t *wlc)
 	/* This will make sure that when 'up' is done
 	 * after 'out' it'll restore hardware (especially gpios)
 	 */
-	wlc->pub->hw_up = FALSE;
+	wlc->pub->hw_up = false;
 }
 
 #if defined(BCMDBG)
@@ -2604,7 +2604,7 @@ static bool wlc_tx_prec_map_verify(wlc_i
 	if (!EDCF_ENAB(wlc->pub)) {
 		if (!(WLC_TX_FIFO_CHECK(wlc, TX_DATA_FIFO) ||
 		      WLC_TX_FIFO_CHECK(wlc, TX_CTL_FIFO)))
-			return FALSE;
+			return false;
 		else
 			return true;
 	}
@@ -2800,7 +2800,7 @@ int wlc_up(wlc_info_t *wlc)
 	if (wlc->bandinit_pending) {
 		wlc_suspend_mac_and_wait(wlc);
 		wlc_set_chanspec(wlc, wlc->default_bss->chanspec);
-		wlc->bandinit_pending = FALSE;
+		wlc->bandinit_pending = false;
 		wlc_enable_mac(wlc);
 	}
 
@@ -2863,7 +2863,7 @@ uint wlc_down(wlc_info_t *wlc)
 
 	uint callbacks = 0;
 	int i;
-	bool dev_gone = FALSE;
+	bool dev_gone = false;
 	wlc_txq_info_t *qi;
 
 	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __func__));
@@ -2895,7 +2895,7 @@ uint wlc_down(wlc_info_t *wlc)
 	if (wlc->WDarmed) {
 		if (!wl_del_timer(wlc->wl, wlc->wdtimer))
 			callbacks++;
-		wlc->WDarmed = FALSE;
+		wlc->WDarmed = false;
 	}
 	/* cancel all other timers */
 	callbacks += wlc_down_del_timer(wlc);
@@ -2903,9 +2903,9 @@ uint wlc_down(wlc_info_t *wlc)
 	/* interrupt must have been blocked */
 	ASSERT((wlc->macintmask == 0) || !wlc->pub->up);
 
-	wlc->pub->up = FALSE;
+	wlc->pub->up = false;
 
-	wlc_phy_mute_upd(wlc->band->pi, FALSE, PHY_MUTE_ALL);
+	wlc_phy_mute_upd(wlc->band->pi, false, PHY_MUTE_ALL);
 
 	/* clear txq flow control */
 	wlc_txflowcontrol_reset(wlc);
@@ -2925,7 +2925,7 @@ uint wlc_down(wlc_info_t *wlc)
 	callbacks += wlc_bmac_down_finish(wlc->hw);
 
 	/* wlc_bmac_down_finish has done wlc_coredisable(). so clk is off */
-	wlc->clk = FALSE;
+	wlc->clk = false;
 
 #ifdef WLC_HIGH_ONLY
 	wlc_rpctx_txreclaim(wlc->rpctx);
@@ -2943,7 +2943,7 @@ uint wlc_down(wlc_info_t *wlc)
 	for (i = 1; i <= wlc->pub->tunables->maxpktcb; i++)
 		ASSERT(wlc->pkt_callback[i].fn == NULL);
 #endif
-	wlc->going_down = FALSE;
+	wlc->going_down = false;
 	return callbacks;
 }
 
@@ -2955,12 +2955,12 @@ int wlc_set_gmode(wlc_info_t *wlc, u8 gm
 	wlc_rateset_t rs;
 	/* Default to 54g Auto */
 	s8 shortslot = WLC_SHORTSLOT_AUTO;	/* Advertise and use shortslot (-1/0/1 Auto/Off/On) */
-	bool shortslot_restrict = FALSE;	/* Restrict association to stations that support shortslot
+	bool shortslot_restrict = false;	/* Restrict association to stations that support shortslot
 						 */
 	bool ignore_bcns = true;	/* Ignore legacy beacons on the same channel */
-	bool ofdm_basic = FALSE;	/* Make 6, 12, and 24 basic rates */
+	bool ofdm_basic = false;	/* Make 6, 12, and 24 basic rates */
 	int preamble = WLC_PLCP_LONG;	/* Advertise and use short preambles (-1/0/1 Auto/Off/On) */
-	bool preamble_restrict = FALSE;	/* Restrict association to stations that support short
+	bool preamble_restrict = false;	/* Restrict association to stations that support short
 					 * preambles
 					 */
 	wlcband_t *band;
@@ -3238,7 +3238,7 @@ int wlc_get(wlc_info_t *wlc, int cmd, in
 static void wlc_ofdm_rateset_war(wlc_info_t *wlc)
 {
 	u8 r;
-	bool war = FALSE;
+	bool war = false;
 
 	if (wlc->cfg->associated)
 		r = wlc->cfg->current_bss->rateset.rates[0];
@@ -3279,7 +3279,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 
 	/* initialize the following to get rid of compiler warning */
 	nextscb = NULL;
-	ta_ok = FALSE;
+	ta_ok = false;
 	band = 0;
 	r = NULL;
 
@@ -3381,7 +3381,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 				    CHSPEC_WLCBANDUNIT(chspec))
 					wlc->bandinit_pending = true;
 				else
-					wlc->bandinit_pending = FALSE;
+					wlc->bandinit_pending = false;
 			}
 
 			wlc->default_bss->chanspec = chspec;
@@ -4007,7 +4007,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			break;
 		}
 
-		wlc->wake = val ? true : FALSE;
+		wlc->wake = val ? true : false;
 
 		/* if down, we're done */
 		if (!wlc->pub->up)
@@ -4141,11 +4141,11 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			/* let watchdog or beacon processing update shortslot */
 		} else if (wlc->pub->up) {
 			/* unassociated shortslot is off */
-			wlc_switch_shortslot(wlc, FALSE);
+			wlc_switch_shortslot(wlc, false);
 		} else {
 			/* driver is down, so just update the wlc_info value */
 			if (wlc->shortslot_override == WLC_SHORTSLOT_AUTO) {
-				wlc->shortslot = FALSE;
+				wlc->shortslot = false;
 			} else {
 				wlc->shortslot =
 				    (wlc->shortslot_override ==
@@ -4258,11 +4258,11 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			}
 
 			/* validate rateset by comparing pre and post sorted against 11g hw rates */
-			wlc_rateset_filter(&rs, &new, FALSE, WLC_RATES_CCK_OFDM,
+			wlc_rateset_filter(&rs, &new, false, WLC_RATES_CCK_OFDM,
 					   RATE_MASK, BSS_N_ENAB(wlc, bsscfg));
 			wlc_rate_hwrs_filter_sort_validate(&new,
 							   &cck_ofdm_rates,
-							   FALSE,
+							   false,
 							   wlc->stf->txstreams);
 			if (rs.count != new.count) {
 				bcmerror = BCME_BADRATESET;	/* invalid rateset */
@@ -4321,7 +4321,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			/* treat the 'val' parm as the key id */
 			key = WSEC_BSS_DEFAULT_KEY(bsscfg);
 			if (key != NULL) {
-				*pval = key->id == val ? true : FALSE;
+				*pval = key->id == val ? true : false;
 			} else {
 				bcmerror = BCME_BADKEYIDX;
 			}
@@ -4764,8 +4764,8 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 	/* convenience int ptr for 4-byte gets (requires int aligned arg) */
 	ret_int_ptr = (s32 *) arg;
 
-	bool_val = (int_val != 0) ? true : FALSE;
-	bool_val2 = (int_val2 != 0) ? true : FALSE;
+	bool_val = (int_val != 0) ? true : false;
+	bool_val2 = (int_val2 != 0) ? true : false;
 
 	WL_TRACE(("wl%d: %s: id %d\n", wlc->pub->unit, __func__,
 		  IOV_ID(actionid)));
@@ -4799,7 +4799,7 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 			/* Remove override bit and clip to max qdbm value */
 			qdbm = (u8)min_t(u32, (int_val & ~WL_TXPWR_OVERRIDE), 0xff);
 			/* Extract override setting */
-			override = (int_val & WL_TXPWR_OVERRIDE) ? true : FALSE;
+			override = (int_val & WL_TXPWR_OVERRIDE) ? true : false;
 			err =
 			    wlc_phy_txpower_set(wlc->band->pi, qdbm, override);
 			break;
@@ -5021,7 +5021,7 @@ bool wlc_chipmatch(u16 vendor, u16 devic
 {
 	if (vendor != VENDOR_BROADCOM) {
 		WL_ERROR(("wlc_chipmatch: unknown vendor id %04x\n", vendor));
-		return FALSE;
+		return false;
 	}
 
 	if ((device == BCM43224_D11N_ID) || (device == BCM43225_D11N2G_ID))
@@ -5033,7 +5033,7 @@ bool wlc_chipmatch(u16 vendor, u16 devic
 		return true;
 
 	WL_ERROR(("wlc_chipmatch: unknown device id %04x\n", device));
-	return FALSE;
+	return false;
 }
 
 #if defined(BCMDBG)
@@ -5198,7 +5198,7 @@ void wlc_device_removed(void *arg)
 {
 	wlc_info_t *wlc = (wlc_info_t *) arg;
 
-	wlc->device_present = FALSE;
+	wlc->device_present = false;
 }
 #endif				/* WLC_HIGH_ONLY */
 
@@ -5209,12 +5209,12 @@ void wlc_device_removed(void *arg)
  * 'prec' is the precedence number that has already been mapped
  * from the packet priority.
  *
- * Returns true if packet consumed (queued), FALSE if not.
+ * Returns true if packet consumed (queued), false if not.
  */
 bool BCMFASTPATH
 wlc_prec_enq(wlc_info_t *wlc, struct pktq *q, void *pkt, int prec)
 {
-	return wlc_prec_enq_head(wlc, q, pkt, prec, FALSE);
+	return wlc_prec_enq_head(wlc, q, pkt, prec, false);
 }
 
 bool BCMFASTPATH
@@ -5233,7 +5233,7 @@ wlc_prec_enq_head(wlc_info_t *wlc, struc
 		if (eprec > prec) {
 			WL_ERROR(("%s: Failing: eprec %d > prec %d\n", __func__,
 				  eprec, prec));
-			return FALSE;
+			return false;
 		}
 	}
 
@@ -5250,7 +5250,7 @@ wlc_prec_enq_head(wlc_info_t *wlc, struc
 		if (eprec == prec && !discard_oldest) {
 			WL_ERROR(("%s: No where to go, prec == %d\n", __func__,
 				  prec));
-			return FALSE;
+			return false;
 		}
 
 		/* Evict packet according to discard policy */
@@ -5423,7 +5423,7 @@ void BCMFASTPATH wlc_send_q(wlc_info_t *
 			}
 		}
 	}
-	in_send_q = FALSE;
+	in_send_q = false;
 }
 
 /*
@@ -5882,10 +5882,10 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 	u16 seq = 0, mcl = 0, status = 0;
 	ratespec_t rspec[2] = { WLC_RATE_1M, WLC_RATE_1M }, rts_rspec[2] = {
 	WLC_RATE_1M, WLC_RATE_1M};
-	bool use_rts = FALSE;
-	bool use_cts = FALSE;
-	bool use_rifs = FALSE;
-	bool short_preamble[2] = { FALSE, FALSE };
+	bool use_rts = false;
+	bool use_cts = false;
+	bool use_rifs = false;
+	bool short_preamble[2] = { false, false };
 	u8 preamble_type[2] = { WLC_LONG_PREAMBLE, WLC_LONG_PREAMBLE };
 	u8 rts_preamble_type[2] = { WLC_LONG_PREAMBLE, WLC_LONG_PREAMBLE };
 	u8 *rts_plcp, rts_plcp_fallback[D11_PHY_HDR_LEN];
@@ -5893,7 +5893,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 	bool qos;
 	uint ac;
 	u32 rate_val[2];
-	bool hwtkmic = FALSE;
+	bool hwtkmic = false;
 	u16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
 #ifdef WLANTSEL
 #define ANTCFG_NONE 0xFF
@@ -5996,7 +5996,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 
 	for (k = 0; k < hw->max_rates; k++) {
 		is_mcs[k] =
-		    txrate[k]->flags & IEEE80211_TX_RC_MCS ? true : FALSE;
+		    txrate[k]->flags & IEEE80211_TX_RC_MCS ? true : false;
 		if (!is_mcs[k]) {
 			ASSERT(!(tx_info->flags & IEEE80211_TX_CTL_AMPDU));
 			if ((txrate[k]->idx >= 0)
@@ -6008,7 +6008,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 				short_preamble[k] =
 				    txrate[k]->
 				    flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE ?
-				    true : FALSE;
+				    true : false;
 			} else {
 				ASSERT((txrate[k]->idx >= 0) &&
 				       (txrate[k]->idx <
@@ -6024,10 +6024,10 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 		 */
 		use_rts |=
 		    txrate[k]->
-		    flags & IEEE80211_TX_RC_USE_RTS_CTS ? true : FALSE;
+		    flags & IEEE80211_TX_RC_USE_RTS_CTS ? true : false;
 		use_cts |=
 		    txrate[k]->
-		    flags & IEEE80211_TX_RC_USE_CTS_PROTECT ? true : FALSE;
+		    flags & IEEE80211_TX_RC_USE_CTS_PROTECT ? true : false;
 
 		if (is_mcs[k])
 			rate_val[k] |= NRATE_MCS_INUSE;
@@ -6041,7 +6041,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 		} else {
 			if (WLANTSEL_ENAB(wlc) && !ETHER_ISMULTI(&h->a1)) {
 				/* set tx antenna config */
-				wlc_antsel_antcfg_get(wlc->asi, FALSE, FALSE, 0,
+				wlc_antsel_antcfg_get(wlc->asi, false, false, 0,
 						      0, &antcfg, &fbantcfg);
 			}
 		}
@@ -6290,11 +6290,11 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 	/* RTS PLCP header and RTS frame */
 	if (use_rts || use_cts) {
 		if (use_rts && use_cts)
-			use_cts = FALSE;
+			use_cts = false;
 
 		for (k = 0; k < 2; k++) {
 			rts_rspec[k] = wlc_rspec_to_rts_rspec(wlc, rspec[k],
-							      FALSE,
+							      false,
 							      mimo_ctlchbw);
 		}
 
@@ -6341,13 +6341,13 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 
 		durid = wlc_compute_rtscts_dur(wlc, use_cts, rts_rspec[0],
 					       rspec[0], rts_preamble_type[0],
-					       preamble_type[0], phylen, FALSE);
+					       preamble_type[0], phylen, false);
 		rts->durid = htol16(durid);
 		/* fallback rate version of RTS DUR field */
 		durid = wlc_compute_rtscts_dur(wlc, use_cts,
 					       rts_rspec[1], rspec[1],
 					       rts_preamble_type[1],
-					       preamble_type[1], phylen, FALSE);
+					       preamble_type[1], phylen, false);
 		txh->RTSDurFallback = htol16(durid);
 
 		if (use_cts) {
@@ -6552,7 +6552,7 @@ void wlc_tbtt(wlc_info_t *wlc, d11regs_t
 			u32 cur, delta;
 			if (wlc->WDarmed) {
 				wl_del_timer(wlc->wl, wlc->wdtimer);
-				wlc->WDarmed = FALSE;
+				wlc->WDarmed = false;
 			}
 
 			cur = OSL_SYSUPTIME();
@@ -6774,7 +6774,7 @@ wlc_dotxstatus(wlc_info_t *wlc, tx_statu
 			   status & TX_STATUS_FRM_RTX_MASK) >>
 			  TX_STATUS_FRM_RTX_SHIFT));
 		WL_ERROR(("%s: INTERMEDIATE but not AMPDU\n", __func__));
-		return FALSE;
+		return false;
 	}
 
 	osh = wlc->osh;
@@ -6787,7 +6787,7 @@ wlc_dotxstatus(wlc_info_t *wlc, tx_statu
 
 	p = GETNEXTTXP(wlc, queue);
 	if (WLC_WAR16165(wlc))
-		wlc_war16165(wlc, FALSE);
+		wlc_war16165(wlc, false);
 	if (p == NULL)
 		p = wlc_15420war(wlc, queue);
 	ASSERT(p != NULL);
@@ -6825,7 +6825,7 @@ wlc_dotxstatus(wlc_info_t *wlc, tx_statu
 	if (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {
 		ASSERT((mcl & TXC_AMPDU_MASK) != TXC_AMPDU_NONE);
 		wlc_ampdu_dotxstatus(wlc->ampdu, scb, p, txs);
-		return FALSE;
+		return false;
 	}
 
 	supr_status = txs->status & TX_STATUS_SUPR_MASK;
@@ -6897,7 +6897,7 @@ wlc_dotxstatus(wlc_info_t *wlc, tx_statu
 			  __func__));
 	}
 
-	return FALSE;
+	return false;
 
  fatal:
 	ASSERT(0);
@@ -6933,7 +6933,7 @@ wlc_txfifo_complete(wlc_info_t *wlc, uin
 	/* Clear MHF2_TXBCMC_NOW flag if BCMC fifo has drained */
 	if (AP_ENAB(wlc->pub) &&
 	    wlc->bcmcfifo_drain && !TXPKTPENDGET(wlc, TX_BCMC_FIFO)) {
-		wlc->bcmcfifo_drain = FALSE;
+		wlc->bcmcfifo_drain = false;
 		wlc_mhf(wlc, MHF2, MHF2_TXBCMC_NOW, 0, WLC_BAND_AUTO);
 	}
 
@@ -7203,7 +7203,7 @@ void wlc_bss_list_free(wlc_info_t *wlc,
 
 /* Process received frames */
 /*
- * Return true if more frames need to be processed. FALSE otherwise.
+ * Return true if more frames need to be processed. false otherwise.
  * Param 'bound' indicates max. # frames to process before break out.
  */
 /* WLC_HIGH_API */
@@ -7293,7 +7293,7 @@ void BCMFASTPATH wlc_recv(wlc_info_t *wl
 	return;
 
  toss:
-	PKTFREE(osh, p, FALSE);
+	PKTFREE(osh, p, false);
 }
 
 /* calculate frame duration for Mixed-mode L-SIG spoofing, return
@@ -7691,7 +7691,7 @@ bool wlc_valid_rate(wlc_info_t *wlc, rat
 		hw_rateset = &wlc->bandstate[OTHERBANDUNIT(wlc)]->hw_rateset;
 	} else {
 		/* other band specified and we are a single band device */
-		return FALSE;
+		return false;
 	}
 
 	/* check if this is a mimo rate */
@@ -7710,7 +7710,7 @@ bool wlc_valid_rate(wlc_info_t *wlc, rat
 		WL_ERROR(("wl%d: wlc_valid_rate: rate spec 0x%x not in hw_rateset\n", wlc->pub->unit, rspec));
 	}
 
-	return FALSE;
+	return false;
 }
 
 static void wlc_update_mimo_band_bwcap(wlc_info_t *wlc, u8 bwcap)
@@ -7727,13 +7727,13 @@ static void wlc_update_mimo_band_bwcap(w
 			    || (bwcap == WLC_N_BW_20IN2G_40IN5G))
 				band->mimo_cap_40 = true;
 			else
-				band->mimo_cap_40 = FALSE;
+				band->mimo_cap_40 = false;
 		} else {
 			ASSERT(band->bandtype == WLC_BAND_2G);
 			if (bwcap == WLC_N_BW_40ALL)
 				band->mimo_cap_40 = true;
 			else
-				band->mimo_cap_40 = FALSE;
+				band->mimo_cap_40 = false;
 		}
 	}
 
@@ -7943,7 +7943,7 @@ void wlc_bss_update_beacon(wlc_info_t *w
 		/* update the template and ucode shm */
 		wlc_bcn_prb_template(wlc, FC_BEACON, wlc->bcn_rspec, cfg, bcn,
 				     &len);
-		wlc_write_hw_bcntemplates(wlc, bcn, len, FALSE);
+		wlc_write_hw_bcntemplates(wlc, bcn, len, false);
 	}
 }
 
@@ -8129,7 +8129,7 @@ int wlc_get_revision_info(wlc_info_t *wl
 void wlc_default_rateset(wlc_info_t *wlc, wlc_rateset_t *rs)
 {
 	wlc_rateset_default(rs, NULL, wlc->band->phytype, wlc->band->bandtype,
-			    FALSE, RATE_MASK_FULL, (bool) N_ENAB(wlc->pub),
+			    false, RATE_MASK_FULL, (bool) N_ENAB(wlc->pub),
 			    CHSPEC_WLC_BW(wlc->default_bss->chanspec),
 			    wlc->stf->txstreams);
 }
@@ -8162,7 +8162,7 @@ static void wlc_bss_default_init(wlc_inf
 
 	/* init bss rates to the band specific default rate set */
 	wlc_rateset_default(&bi->rateset, NULL, band->phytype, band->bandtype,
-			    FALSE, RATE_MASK_FULL, (bool) N_ENAB(wlc->pub),
+			    false, RATE_MASK_FULL, (bool) N_ENAB(wlc->pub),
 			    CHSPEC_WLC_BW(chanspec), wlc->stf->txstreams);
 
 	if (N_ENAB(wlc->pub))
@@ -8483,7 +8483,7 @@ void wlc_pllreq(wlc_info_t *wlc, bool se
 void wlc_reset_bmac_done(wlc_info_t *wlc)
 {
 #ifdef WLC_HIGH_ONLY
-	wlc->reset_bmac_pending = FALSE;
+	wlc->reset_bmac_pending = false;
 #endif
 }
 
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.h
@@ -723,7 +723,7 @@ struct wlc_info {
 	u16 counter;		/* per-sdu monotonically increasing counter */
 	u16 mc_fid_counter;	/* BC/MC FIFO frame ID counter */
 
-	bool ibss_allowed;	/* FALSE, all IBSS will be ignored during a scan
+	bool ibss_allowed;	/* false, all IBSS will be ignored during a scan
 				 * and the driver will not allow the creation of
 				 * an IBSS network
 				 */
@@ -847,7 +847,7 @@ struct antsel_info {
 /* sum the individual fifo tx pending packet counts */
 #if defined(WLC_HIGH_ONLY)
 #define TXPKTPENDTOT(wlc)		(wlc_rpctx_txpktpend((wlc)->rpctx, 0, true))
-#define TXPKTPENDGET(wlc, fifo)		(wlc_rpctx_txpktpend((wlc)->rpctx, (fifo), FALSE))
+#define TXPKTPENDGET(wlc, fifo)		(wlc_rpctx_txpktpend((wlc)->rpctx, (fifo), false))
 #define TXPKTPENDINC(wlc, fifo, val)	(wlc_rpctx_txpktpendinc((wlc)->rpctx, (fifo), (val)))
 #define TXPKTPENDDEC(wlc, fifo, val)	(wlc_rpctx_txpktpenddec((wlc)->rpctx, (fifo), (val)))
 #define TXPKTPENDCLR(wlc, fifo)		(wlc_rpctx_txpktpendclr((wlc)->rpctx, (fifo)))
--- a/drivers/staging/brcm80211/sys/wlc_rate.c
+++ b/drivers/staging/brcm80211/sys/wlc_rate.c
@@ -265,7 +265,7 @@ static bool wlc_rateset_valid(wlc_ratese
 	uint idx;
 
 	if (!rs->count)
-		return FALSE;
+		return false;
 
 	if (!check_brate)
 		return true;
@@ -275,7 +275,7 @@ static bool wlc_rateset_valid(wlc_ratese
 		if (rs->rates[idx] & WLC_RATE_FLAG)
 			return true;
 	}
-	return FALSE;
+	return false;
 }
 
 void wlc_rateset_mcs_upd(wlc_rateset_t *rs, u8 txstreams)
@@ -328,7 +328,7 @@ wlc_rate_hwrs_filter_sort_validate(wlc_r
 	if (wlc_rateset_valid(rs, check_brate))
 		return true;
 	else
-		return FALSE;
+		return false;
 }
 
 /* caluclate the rate of a rx'd frame and return it as a ratespec */
@@ -460,10 +460,10 @@ wlc_rateset_default(wlc_rateset_t *rs_tg
 
 	wlc_rateset_copy(rs_dflt, &rs_sel);
 	wlc_rateset_mcs_upd(&rs_sel, txstreams);
-	wlc_rateset_filter(&rs_sel, rs_tgt, FALSE,
+	wlc_rateset_filter(&rs_sel, rs_tgt, false,
 			   cck_only ? WLC_RATES_CCK : WLC_RATES_CCK_OFDM,
 			   rate_mask, mcsallow);
-	wlc_rate_hwrs_filter_sort_validate(rs_tgt, rs_hw, FALSE,
+	wlc_rate_hwrs_filter_sort_validate(rs_tgt, rs_hw, false,
 					   mcsallow ? txstreams : 1);
 }
 
--- a/drivers/staging/brcm80211/sys/wlc_rpctx.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpctx.h
@@ -51,11 +51,11 @@ extern void wlc_rpctx_txpktpendclr(rpctx
 extern int wlc_rpctx_txpktpend(rpctx_info_t *rpctx, uint fifo, bool all);
 
 #else
-#define	RPCTX_ENAB(pub)			(FALSE)
+#define	RPCTX_ENAB(pub)			(false)
 #define	wlc_rpctx_attach(pub, wlc)	(NULL)
 #define	wlc_rpctx_fifoinit(rpctx, fifo, ntxd) (0)
 #define	wlc_rpctx_detach(rpctx)		ASSERT(0)
-#define	wlc_rpctx_txavail(rpctx, f)	(FALSE)
+#define	wlc_rpctx_txavail(rpctx, f)	(false)
 #define	wlc_rpctx_dump(rpctx, b)		(0)
 #define	wlc_rpctx_getnexttxp(rpctx, f)		(NULL)
 #define	wlc_rpctx_txreclaim(rpctx)		ASSERT(0)
--- a/drivers/staging/brcm80211/sys/wlc_stf.c
+++ b/drivers/staging/brcm80211/sys/wlc_stf.c
@@ -157,11 +157,11 @@ static s8 wlc_stf_stbc_rx_get(wlc_info_t
 static bool wlc_stf_stbc_tx_set(wlc_info_t *wlc, s32 int_val)
 {
 	if ((int_val != AUTO) && (int_val != OFF) && (int_val != ON)) {
-		return FALSE;
+		return false;
 	}
 
 	if ((int_val == ON) && (wlc->stf->txstreams == 1))
-		return FALSE;
+		return false;
 
 	if ((int_val == OFF) || (wlc->stf->txstreams == 1)
 	    || !WLC_STBC_CAP_PHY(wlc))
@@ -179,13 +179,13 @@ bool wlc_stf_stbc_rx_set(wlc_info_t *wlc
 {
 	if ((int_val != HT_CAP_RX_STBC_NO)
 	    && (int_val != HT_CAP_RX_STBC_ONE_STREAM)) {
-		return FALSE;
+		return false;
 	}
 
 	if (WLC_STF_SS_STBC_RX(wlc)) {
 		if ((int_val != HT_CAP_RX_STBC_NO)
 		    && (wlc->stf->rxstreams == 1))
-			return FALSE;
+			return false;
 	}
 
 	wlc_stf_stbc_rx_ht_update(wlc, int_val);
--- a/drivers/staging/brcm80211/util/aiutils.c
+++ b/drivers/staging/brcm80211/util/aiutils.c
@@ -153,7 +153,7 @@ void ai_scan(si_t *sih, void *regs, uint
 		uint i, j, idx;
 		bool br;
 
-		br = FALSE;
+		br = false;
 
 		/* Grok a component */
 		cia = get_erom_ent(sih, &eromptr, ER_TAG, ER_CI);
@@ -493,7 +493,7 @@ uint ai_corereg(si_t *sih, uint coreidx,
 	u32 *r = NULL;
 	uint w;
 	uint intr_val = 0;
-	bool fast = FALSE;
+	bool fast = false;
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
--- a/drivers/staging/brcm80211/util/bcmotp.c
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -930,7 +930,7 @@ void *otp_init(si_t *sih)
 int
 otp_read_region(si_t *sih, int region, u16 *data,
 				 uint *wlen) {
-	bool wasup = FALSE;
+	bool wasup = false;
 	void *oh;
 	int err = 0;
 
@@ -953,7 +953,7 @@ otp_read_region(si_t *sih, int region, u
 
  out:
 	if (!wasup)
-		si_otp_power(sih, FALSE);
+		si_otp_power(sih, false);
 
 	return err;
 }
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -385,7 +385,7 @@ int srom_parsecis(osl_t *osh, u8 *pcis[]
 	varbuf_t b;
 	u8 *cis, tup, tlen, sromrev = 1;
 	int i, j;
-	bool ag_init = FALSE;
+	bool ag_init = false;
 	u32 w32;
 	uint funcid;
 	uint cisnum;
@@ -692,7 +692,7 @@ int srom_parsecis(osl_t *osh, u8 *pcis[]
 					 * after this tuple
 					 */
 					tlen++;
-					standard_cis = FALSE;
+					standard_cis = false;
 					break;
 
 				case HNBU_USBEPNUM:
@@ -1388,7 +1388,7 @@ int srom_parsecis(osl_t *osh, u8 *pcis[]
 	}
 
 	/* if there is no antenna gain field, set default */
-	if (getvar(NULL, "ag0") == NULL && ag_init == FALSE) {
+	if (getvar(NULL, "ag0") == NULL && ag_init == false) {
 		varbuf_append(&b, vstr_ag, 0, 0xff);
 	}
 
@@ -1850,7 +1850,7 @@ static int initvars_srom_pci(si_t *sih,
 	varbuf_t b;
 	char *vp, *base = NULL;
 	osl_t *osh = si_osh(sih);
-	bool flash = FALSE;
+	bool flash = false;
 	int err = 0;
 
 	/*
--- a/drivers/staging/brcm80211/util/bcmwifi.c
+++ b/drivers/staging/brcm80211/util/bcmwifi.c
@@ -46,7 +46,7 @@ bool wf_chspec_malformed(chanspec_t chan
 			return true;
 	}
 
-	return FALSE;
+	return false;
 }
 
 /*
--- a/drivers/staging/brcm80211/util/bcmwpa.c
+++ b/drivers/staging/brcm80211/util/bcmwpa.c
@@ -40,7 +40,7 @@ bool bcm_is_wfa_ie(u8 *ie, u8 **tlvs, ui
 	/* update the pointer to the start of the buffer */
 	*tlvs = ie;
 
-	return FALSE;
+	return false;
 }
 
 wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (u8 * parse, uint len)
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -169,7 +169,7 @@ typedef struct dma_info {
 #ifdef BCMDMASGLISTOSL
 #define DMASGLIST_ENAB true
 #else
-#define DMASGLIST_ENAB FALSE
+#define DMASGLIST_ENAB false
 #endif				/* BCMDMASGLISTOSL */
 
 /* descriptor bumping macros */
@@ -758,18 +758,18 @@ static bool _dma_descriptor_align(dma_in
 			W_REG(di->osh, &di->d64txregs->addrlow, 0xff0);
 			addrl = R_REG(di->osh, &di->d64txregs->addrlow);
 			if (addrl != 0)
-				return FALSE;
+				return false;
 		} else if (di->d64rxregs != NULL) {
 			W_REG(di->osh, &di->d64rxregs->addrlow, 0xff0);
 			addrl = R_REG(di->osh, &di->d64rxregs->addrlow);
 			if (addrl != 0)
-				return FALSE;
+				return false;
 		}
 	}
 	return true;
 }
 
-/* return true if this dma engine supports DmaExtendedAddrChanges, otherwise FALSE */
+/* return true if this dma engine supports DmaExtendedAddrChanges, otherwise false */
 static bool _dma_isaddrext(dma_info_t *di)
 {
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
@@ -789,7 +789,7 @@ static bool _dma_isaddrext(dma_info_t *d
 			}
 			return true;
 		}
-		return FALSE;
+		return false;
 	} else if (DMA32_ENAB(di)) {
 		if (di->d32txregs)
 			return _dma32_addrext(di->osh, di->d32txregs);
@@ -798,7 +798,7 @@ static bool _dma_isaddrext(dma_info_t *d
 	} else
 		ASSERT(0);
 
-	return FALSE;
+	return false;
 }
 
 /* initialize descriptor table base address */
@@ -994,7 +994,7 @@ static void *BCMFASTPATH _dma_rx(dma_inf
 	int resid = 0;
 
  next_frame:
-	head = _dma_getnextrxp(di, FALSE);
+	head = _dma_getnextrxp(di, false);
 	if (head == NULL)
 		return NULL;
 
@@ -1018,7 +1018,7 @@ static void *BCMFASTPATH _dma_rx(dma_inf
 	/* check for single or multi-buffer rx */
 	if (resid > 0) {
 		tail = head;
-		while ((resid > 0) && (p = _dma_getnextrxp(di, FALSE))) {
+		while ((resid > 0) && (p = _dma_getnextrxp(di, false))) {
 			PKTSETNEXT(tail, p);
 			pkt_len = min(resid, (int)di->rxbufsize);
 			PKTSETLEN(p, pkt_len);
@@ -1047,7 +1047,7 @@ static void *BCMFASTPATH _dma_rx(dma_inf
 		if ((di->hnddma.dmactrlflags & DMA_CTRL_RXMULTI) == 0) {
 			DMA_ERROR(("%s: dma_rx: bad frame length (%d)\n",
 				   di->name, len));
-			PKTFREE(di->osh, head, FALSE);
+			PKTFREE(di->osh, head, false);
 			di->hnddma.rxgiants++;
 			goto next_frame;
 		}
@@ -1057,7 +1057,7 @@ static void *BCMFASTPATH _dma_rx(dma_inf
 }
 
 /* post receive buffers
- *  return FALSE is refill failed completely and ring is empty
+ *  return false is refill failed completely and ring is empty
  *  this will stall the rx dma and user might want to call rxfill again asap
  *  This unlikely happens on memory-rich NIC, but often on memory-constrained dongle
  */
@@ -1072,7 +1072,7 @@ static bool BCMFASTPATH _dma_rxfill(dma_
 	uint extra_offset = 0;
 	bool ring_empty;
 
-	ring_empty = FALSE;
+	ring_empty = false;
 
 	/*
 	 * Determine how many receive buffers we're lacking
@@ -1238,7 +1238,7 @@ static void _dma_rxreclaim(dma_info_t *d
 	DMA_TRACE(("%s: dma_rxreclaim\n", di->name));
 
 	while ((p = _dma_getnextrxp(di, true)))
-		PKTFREE(di->osh, p, FALSE);
+		PKTFREE(di->osh, p, false);
 }
 
 static void *BCMFASTPATH _dma_getnextrxp(dma_info_t *di, bool forceall)
@@ -1538,7 +1538,7 @@ static bool dma32_alloc(dma_info_t *di,
 			&alloced, &di->txdpaorig, &di->tx_dmah);
 		if (va == NULL) {
 			DMA_ERROR(("%s: dma_alloc: DMA_ALLOC_CONSISTENT(ntxd) failed\n", di->name));
-			return FALSE;
+			return false;
 		}
 
 		PHYSADDRHISET(di->txdpa, 0);
@@ -1559,7 +1559,7 @@ static bool dma32_alloc(dma_info_t *di,
 			&alloced, &di->rxdpaorig, &di->rx_dmah);
 		if (va == NULL) {
 			DMA_ERROR(("%s: dma_alloc: DMA_ALLOC_CONSISTENT(nrxd) failed\n", di->name));
-			return FALSE;
+			return false;
 		}
 
 		PHYSADDRHISET(di->rxdpa, 0);
@@ -2106,7 +2106,7 @@ static bool dma64_alloc(dma_info_t *di,
 			&alloced, &di->txdpaorig, &di->tx_dmah);
 		if (va == NULL) {
 			DMA_ERROR(("%s: dma64_alloc: DMA_ALLOC_CONSISTENT(ntxd) failed\n", di->name));
-			return FALSE;
+			return false;
 		}
 		align = (1 << align_bits);
 		di->txd64 = (dma64dd_t *) roundup((uintptr) va, align);
@@ -2124,7 +2124,7 @@ static bool dma64_alloc(dma_info_t *di,
 			&alloced, &di->rxdpaorig, &di->rx_dmah);
 		if (va == NULL) {
 			DMA_ERROR(("%s: dma64_alloc: DMA_ALLOC_CONSISTENT(nrxd) failed\n", di->name));
-			return FALSE;
+			return false;
 		}
 		align = (1 << align_bits);
 		di->rxd64 = (dma64dd_t *) roundup((uintptr) va, align);
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -152,7 +152,7 @@ void si_pmu_set_ldo_voltage(si_t *sih, o
 			mask = 0xf;
 			break;
 		default:
-			ASSERT(FALSE);
+			ASSERT(false);
 			return;
 		}
 		break;
@@ -164,12 +164,12 @@ void si_pmu_set_ldo_voltage(si_t *sih, o
 			mask = 0x1f;
 			break;
 		default:
-			ASSERT(FALSE);
+			ASSERT(false);
 			break;
 		}
 		break;
 	default:
-		ASSERT(FALSE);
+		ASSERT(false);
 		return;
 	}
 
@@ -2021,7 +2021,7 @@ si_pmu_res_uptime(si_t *sih, osl_t *osh,
 	up = (R_REG(osh, &cc->res_updn_timer) >> 8) & 0xff;
 
 	/* direct dependancies of resource 'rsrc' */
-	deps = si_pmu_res_deps(sih, osh, cc, PMURES_BIT(rsrc), FALSE);
+	deps = si_pmu_res_deps(sih, osh, cc, PMURES_BIT(rsrc), false);
 	for (i = 0; i <= PMURES_MAX_RESNUM; i++) {
 		if (!(deps & PMURES_BIT(i)))
 			continue;
@@ -2535,7 +2535,7 @@ void si_pmu_chip_init(si_t *sih, osl_t *
 #endif				/* CHIPC_UART_ALWAYS_ON */
 
 	/* Gate off SPROM clock and chip select signals */
-	si_pmu_sprom_enable(sih, osh, FALSE);
+	si_pmu_sprom_enable(sih, osh, false);
 
 	/* Remember original core */
 	origidx = si_coreidx(sih);
--- a/drivers/staging/brcm80211/util/linux_osl.c
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -167,10 +167,10 @@ osl_t *osl_attach(void *pdev, uint busty
 	case USB_BUS:
 	case SPI_BUS:
 	case RPC_BUS:
-		osh->pub.mmbus = FALSE;
+		osh->pub.mmbus = false;
 		break;
 	default:
-		ASSERT(FALSE);
+		ASSERT(false);
 		break;
 	}
 
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -287,7 +287,7 @@ static bool pcie_mdiosetblock(pcicore_in
 
 	if (i >= pcie_serdes_spinwait) {
 		PCI_ERROR(("pcie_mdiosetblock: timed out\n"));
-		return FALSE;
+		return false;
 	}
 
 	return true;
@@ -356,7 +356,7 @@ pcie_mdioop(pcicore_info_t *pi, uint phy
 static int
 pcie_mdioread(pcicore_info_t *pi, uint physmedia, uint regaddr, uint *regval)
 {
-	return pcie_mdioop(pi, physmedia, regaddr, FALSE, regval);
+	return pcie_mdioop(pi, physmedia, regaddr, false, regval);
 }
 
 /* use the mdio interface to write to mdio slaves */
@@ -704,7 +704,7 @@ void pcicore_sleep(void *pch)
 	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pciecap_lcreg_offset, sizeof(u32),
 			     w);
 
-	pi->pcie_pr42767 = FALSE;
+	pi->pcie_pr42767 = false;
 }
 
 void pcicore_down(void *pch, int state)
@@ -717,7 +717,7 @@ void pcicore_down(void *pch, int state)
 	pcie_clkreq_upd(pi, state);
 
 	/* Reduce L1 timer for better power savings */
-	pcie_extendL1timer(pi, FALSE);
+	pcie_extendL1timer(pi, false);
 }
 
 /* ***** Wake-on-wireless-LAN (WOWL) support functions ***** */
@@ -732,7 +732,7 @@ bool pcicore_pmecap_fast(osl_t *osh)
 					NULL);
 
 	if (!cap_ptr)
-		return FALSE;
+		return false;
 
 	pmecap = OSL_PCI_READ_CONFIG(osh, cap_ptr, sizeof(u32));
 
@@ -753,7 +753,7 @@ static bool pcicore_pmecap(pcicore_info_
 						PCI_CAP_POWERMGMTCAP_ID, NULL,
 						NULL);
 		if (!cap_ptr)
-			return FALSE;
+			return false;
 
 		pi->pmecap_offset = cap_ptr;
 
@@ -794,7 +794,7 @@ bool pcicore_pmestat(void *pch)
 	u32 w;
 
 	if (!pcicore_pmecap(pi))
-		return FALSE;
+		return false;
 
 	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
 				sizeof(u32));
--- a/drivers/staging/brcm80211/util/sbutils.c
+++ b/drivers/staging/brcm80211/util/sbutils.c
@@ -145,7 +145,7 @@ uint sb_corereg(si_t *sih, uint coreidx,
 	u32 *r = NULL;
 	uint w;
 	uint intr_val = 0;
-	bool fast = FALSE;
+	bool fast = false;
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -402,7 +402,7 @@ bool sb_taclear(si_t *sih, bool details)
 	sbconfig_t *sb;
 	uint origidx;
 	uint intr_val = 0;
-	bool rc = FALSE;
+	bool rc = false;
 	u32 inband = 0, serror = 0, timeout = 0;
 	void *corereg = NULL;
 	volatile u32 imstate, tmstate;
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -144,7 +144,7 @@ static bool si_buscore_prep(si_info_t *s
 					 PMU_MAX_TRANSITION_DLY);
 				if (!SBSDIO_ALPAV(clkval)) {
 					SI_ERROR(("timeout on ALPAV wait, clkval 0x%02x\n", clkval));
-					return FALSE;
+					return false;
 				}
 				clkset =
 				    SBSDIO_FORCE_HW_CLKREQ_OFF |
@@ -207,7 +207,7 @@ static bool si_buscore_setup(si_info_t *
 	sii->pub.buscorerev = NOREV;
 	sii->pub.buscoreidx = BADIDX;
 
-	pci = pcie = FALSE;
+	pci = pcie = false;
 	pcirev = pcierev = NOREV;
 	pciidx = pcieidx = BADIDX;
 
@@ -265,9 +265,9 @@ static bool si_buscore_setup(si_info_t *
 #else
 	if (pci && pcie) {
 		if (si_ispcie(sii))
-			pci = FALSE;
+			pci = false;
 		else
-			pcie = FALSE;
+			pcie = false;
 	}
 	if (pci) {
 		sii->pub.buscoretype = PCI_CORE_ID;
@@ -290,12 +290,12 @@ static bool si_buscore_setup(si_info_t *
 					&sii->pub, sii->osh,
 					(void *)PCIEREGS(sii));
 				if (sii->pch == NULL)
-					return FALSE;
+					return false;
 			}
 		}
 		if (si_pci_fixcfg(&sii->pub)) {
 			SI_ERROR(("si_doattach: sb_pci_fixcfg failed\n"));
-			return FALSE;
+			return false;
 		}
 	}
 #endif
@@ -490,7 +490,7 @@ static si_info_t *si_doattach(si_info_t
 
 #ifdef BCMDBG
 	/* clear any previous epidiag-induced target abort */
-	sb_taclear(sih, FALSE);
+	sb_taclear(sih, false);
 #endif				/* BCMDBG */
 #endif
 
@@ -947,7 +947,7 @@ bool si_iscoreup(si_t *sih)
 		return sb_iscoreup(sih);
 #else
 		ASSERT(0);
-		return FALSE;
+		return false;
 #endif
 	}
 }
@@ -1164,7 +1164,7 @@ static void si_clkctl_setdelay(si_info_t
 
 	/* Starting with 4318 it is ILP that is used for the delays */
 	slowmaxfreq =
-	    si_slowclk_freq(sii, (sii->pub.ccrev >= 10) ? FALSE : true, cc);
+	    si_slowclk_freq(sii, (sii->pub.ccrev >= 10) ? false : true, cc);
 
 	pll_on_delay = ((slowmaxfreq * pll_delay) + 999999) / 1000000;
 	fref_sel_delay = ((slowmaxfreq * FREF_DELAY) + 999999) / 1000000;
@@ -1246,7 +1246,7 @@ u16 si_clkctl_fast_pwrup_delay(si_t *sih
 	}
 	ASSERT(cc != NULL);
 
-	slowminfreq = si_slowclk_freq(sii, FALSE, cc);
+	slowminfreq = si_slowclk_freq(sii, false, cc);
 	fpdelay = (((R_REG(sii->osh, &cc->pll_on_delay) + 2) * 1000000) +
 		   (slowminfreq - 1)) / slowminfreq;
 
@@ -1352,7 +1352,7 @@ bool si_clkctl_cc(si_t *sih, uint mode)
 
 	/* chipcommon cores prior to rev6 don't support dynamic clock control */
 	if (sih->ccrev < 6)
-		return FALSE;
+		return false;
 
 	if (PCI_FORCEHT(sii))
 		return mode == CLK_FAST;
@@ -1371,7 +1371,7 @@ static bool _si_clkctl_cc(si_info_t *sii
 
 	/* chipcommon cores prior to rev6 don't support dynamic clock control */
 	if (sii->pub.ccrev < 6)
-		return FALSE;
+		return false;
 
 	/* Chips with ccrev 10 are EOL and they don't have SYCC_HR which we use below */
 	ASSERT(sii->pub.ccrev != 10);
@@ -1553,13 +1553,13 @@ static __used bool si_ispcie(si_info_t *
 	u8 cap_ptr;
 
 	if (BUSTYPE(sii->pub.bustype) != PCI_BUS)
-		return FALSE;
+		return false;
 
 	cap_ptr =
 	    pcicore_find_pci_capability(sii->osh, PCI_CAP_PCIECAP_ID, NULL,
 					NULL);
 	if (!cap_ptr)
-		return FALSE;
+		return false;
 
 	return true;
 }
@@ -1940,7 +1940,7 @@ bool si_deviceremoved(si_t *sih)
 			return true;
 		break;
 	}
-	return FALSE;
+	return false;
 }
 
 bool si_is_sprom_available(si_t *sih)
@@ -1952,7 +1952,7 @@ bool si_is_sprom_available(si_t *sih)
 		u32 sromctrl;
 
 		if ((sih->cccaps & CC_CAP_SROM) == 0)
-			return FALSE;
+			return false;
 
 		sii = SI_INFO(sih);
 		origidx = sii->curidx;
@@ -2004,7 +2004,7 @@ bool si_is_otp_disabled(si_t *sih)
 	case BCM43238_CHIP_ID:
 	case BCM4331_CHIP_ID:
 	default:
-		return FALSE;
+		return false;
 	}
 }
 

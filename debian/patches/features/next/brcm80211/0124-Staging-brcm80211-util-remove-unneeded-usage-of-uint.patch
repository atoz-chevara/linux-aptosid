commit c03b63c1987f06590ad944ffe7179444909e0285
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:20:01 2010 -0700

    Staging: brcm80211: util: remove unneeded usage of uintptr
    
    Double casting is pretty pointless, don't do that.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -705,23 +705,23 @@ static void _dma_detach(dma_info_t *di)
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		if (di->txd64)
 			DMA_FREE_CONSISTENT(di->osh,
-					    ((s8 *) (uintptr) di->txd64 -
+					    ((s8 *)di->txd64 -
 					     di->txdalign), di->txdalloc,
 					    (di->txdpaorig), &di->tx_dmah);
 		if (di->rxd64)
 			DMA_FREE_CONSISTENT(di->osh,
-					    ((s8 *) (uintptr) di->rxd64 -
+					    ((s8 *)di->rxd64 -
 					     di->rxdalign), di->rxdalloc,
 					    (di->rxdpaorig), &di->rx_dmah);
 	} else if (DMA32_ENAB(di)) {
 		if (di->txd32)
 			DMA_FREE_CONSISTENT(di->osh,
-					    ((s8 *) (uintptr) di->txd32 -
+					    ((s8 *)di->txd32 -
 					     di->txdalign), di->txdalloc,
 					    (di->txdpaorig), &di->tx_dmah);
 		if (di->rxd32)
 			DMA_FREE_CONSISTENT(di->osh,
-					    ((s8 *) (uintptr) di->rxd32 -
+					    ((s8 *)di->rxd32 -
 					     di->rxdalign), di->rxdalloc,
 					    (di->rxdpaorig), &di->rx_dmah);
 	} else
@@ -912,7 +912,7 @@ static void _dma_rxinit(dma_info_t *di)
 
 	/* clear rx descriptor ring */
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
-		BZERO_SM((void *)(uintptr) di->rxd64,
+		BZERO_SM((void *)di->rxd64,
 			 (di->nrxd * sizeof(dma64dd_t)));
 
 		/* DMA engine with out alignment requirement requires table to be inited
@@ -926,7 +926,7 @@ static void _dma_rxinit(dma_info_t *di)
 		if (di->aligndesc_4k)
 			_dma_ddtable_init(di, DMA_RX, di->rxdpa);
 	} else if (DMA32_ENAB(di)) {
-		BZERO_SM((void *)(uintptr) di->rxd32,
+		BZERO_SM((void *)di->rxd32,
 			 (di->nrxd * sizeof(dma32dd_t)));
 		_dma_rxenable(di);
 		_dma_ddtable_init(di, DMA_RX, di->rxdpa);
@@ -1444,7 +1444,7 @@ static void dma32_txinit(dma_info_t *di)
 	di->hnddma.txavail = di->ntxd - 1;
 
 	/* clear tx descriptor ring */
-	BZERO_SM((void *)(uintptr) di->txd32, (di->ntxd * sizeof(dma32dd_t)));
+	BZERO_SM((void *)di->txd32, (di->ntxd * sizeof(dma32dd_t)));
 
 	if ((di->hnddma.dmactrlflags & DMA_CTRL_PEN) == 0)
 		control |= XC_PD;
@@ -1545,7 +1545,7 @@ static bool dma32_alloc(dma_info_t *di,
 		ASSERT(PHYSADDRHI(di->txdpaorig) == 0);
 		di->txd32 = (dma32dd_t *) ROUNDUP((uintptr) va, align);
 		di->txdalign =
-		    (uint) ((s8 *) (uintptr) di->txd32 - (s8 *) va);
+		    (uint) ((s8 *)di->txd32 - (s8 *) va);
 
 		PHYSADDRLOSET(di->txdpa,
 			      PHYSADDRLO(di->txdpaorig) + di->txdalign);
@@ -1566,7 +1566,7 @@ static bool dma32_alloc(dma_info_t *di,
 		ASSERT(PHYSADDRHI(di->rxdpaorig) == 0);
 		di->rxd32 = (dma32dd_t *) ROUNDUP((uintptr) va, align);
 		di->rxdalign =
-		    (uint) ((s8 *) (uintptr) di->rxd32 - (s8 *) va);
+		    (uint) ((s8 *)di->rxd32 - (s8 *) va);
 
 		PHYSADDRLOSET(di->rxdpa,
 			      PHYSADDRLO(di->rxdpaorig) + di->rxdalign);
@@ -1999,7 +1999,7 @@ static void dma64_txinit(dma_info_t *di)
 	di->hnddma.txavail = di->ntxd - 1;
 
 	/* clear tx descriptor ring */
-	BZERO_SM((void *)(uintptr) di->txd64, (di->ntxd * sizeof(dma64dd_t)));
+	BZERO_SM((void *)di->txd64, (di->ntxd * sizeof(dma64dd_t)));
 
 	/* DMA engine with out alignment requirement requires table to be inited
 	 * before enabling the engine
@@ -2110,8 +2110,7 @@ static bool dma64_alloc(dma_info_t *di,
 		}
 		align = (1 << align_bits);
 		di->txd64 = (dma64dd_t *) ROUNDUP((uintptr) va, align);
-		di->txdalign =
-		    (uint) ((s8 *) (uintptr) di->txd64 - (s8 *) va);
+		di->txdalign = (uint) ((s8 *)di->txd64 - (s8 *) va);
 		PHYSADDRLOSET(di->txdpa,
 			      PHYSADDRLO(di->txdpaorig) + di->txdalign);
 		/* Make sure that alignment didn't overflow */
@@ -2129,8 +2128,7 @@ static bool dma64_alloc(dma_info_t *di,
 		}
 		align = (1 << align_bits);
 		di->rxd64 = (dma64dd_t *) ROUNDUP((uintptr) va, align);
-		di->rxdalign =
-		    (uint) ((s8 *) (uintptr) di->rxd64 - (s8 *) va);
+		di->rxdalign = (uint) ((s8 *)di->rxd64 - (s8 *) va);
 		PHYSADDRLOSET(di->rxdpa,
 			      PHYSADDRLO(di->rxdpaorig) + di->rxdalign);
 		/* Make sure that alignment didn't overflow */
--- a/drivers/staging/brcm80211/util/nvram/nvram_ro.c
+++ b/drivers/staging/brcm80211/util/nvram/nvram_ro.c
@@ -188,7 +188,7 @@ int nvram_getall(char *buf, int count)
 		int acc;
 
 		from = this->vars;
-		lim = (char *)((uintptr) this->vars + this->size);
+		lim = (char *)(this->vars + this->size);
 		to = buf;
 		acc = 0;
 		while ((from < lim) && (*from)) {
--- a/drivers/staging/brcm80211/util/sbutils.c
+++ b/drivers/staging/brcm80211/util/sbutils.c
@@ -350,7 +350,7 @@ static void *_sb_setcoreidx(si_info_t *s
 	case SDIO_BUS:
 		/* map new one */
 		if (!sii->regs[coreidx]) {
-			sii->regs[coreidx] = (void *)(uintptr) sbaddr;
+			sii->regs[coreidx] = (void *)sbaddr;
 			ASSERT(GOODREGS(sii->regs[coreidx]));
 		}
 		regs = sii->regs[coreidx];
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -173,7 +173,7 @@ BCMATTACHFN(si_buscore_setup) (si_info_t
 	uint pciidx, pcieidx, pcirev, pcierev;
 
 	cc = si_setcoreidx(&sii->pub, SI_CC_IDX);
-	ASSERT((uintptr) cc);
+	ASSERT(cc);
 
 	/* get chipcommon rev */
 	sii->pub.ccrev = (int)si_corerev(&sii->pub);
@@ -286,7 +286,7 @@ BCMATTACHFN(si_buscore_setup) (si_info_t
 	if (BUSTYPE(sii->pub.bustype) == PCI_BUS) {
 		if (SI_FAST(sii)) {
 			if (!sii->pch) {
-				sii->pch = (void *)(uintptr)pcicore_init(
+				sii->pch = (void *)pcicore_init(
 					&sii->pub, sii->osh,
 					(void *)PCIEREGS(sii));
 				if (sii->pch == NULL)
@@ -574,7 +574,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 	if (CHIPTYPE(sii->pub.socitype) == SOCI_AI) {
 		SI_MSG(("Found chip type AI (0x%08x)\n", w));
 		/* pass chipc address instead of original core base */
-		ai_scan(&sii->pub, (void *)(uintptr) cc, devid);
+		ai_scan(&sii->pub, (void *)cc, devid);
 	} else {
 		SI_ERROR(("Found chip of unknown type (0x%08x)\n", w));
 		return NULL;
@@ -1203,7 +1203,7 @@ void BCMINITFN(si_clkctl_init) (si_t *si
 		SET_REG(sii->osh, &cc->system_clk_ctl, SYCC_CD_MASK,
 			(ILP_DIV_1MHZ << SYCC_CD_SHIFT));
 
-	si_clkctl_setdelay(sii, (void *)(uintptr) cc);
+	si_clkctl_setdelay(sii, (void *)cc);
 
 	if (!fast)
 		si_setcoreidx(sih, origidx);

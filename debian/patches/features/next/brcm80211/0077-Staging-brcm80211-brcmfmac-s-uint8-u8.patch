commit 3fd79f7c0b69d100c376ad116733cdb655bb2cf1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 10:11:12 2010 -0700

    Staging: brcm80211: brcmfmac: s/uint8/u8/
    
    Replace uint8 with u8, the correct kernel type to be using here.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
@@ -181,14 +181,14 @@ int bcmsdh_devremove_reg(void *sdh, bcms
 	return BCME_UNSUPPORTED;
 }
 
-uint8 bcmsdh_cfg_read(void *sdh, uint fnc_num, uint32 addr, int *err)
+u8 bcmsdh_cfg_read(void *sdh, uint fnc_num, uint32 addr, int *err)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 	SDIOH_API_RC status;
 #ifdef SDIOH_API_ACCESS_RETRY_LIMIT
 	int32 retry = 0;
 #endif
-	uint8 data = 0;
+	u8 data = 0;
 
 	if (!bcmsdh)
 		bcmsdh = l_bcmsdh;
@@ -202,7 +202,7 @@ uint8 bcmsdh_cfg_read(void *sdh, uint fn
 #endif
 		status =
 		    sdioh_cfg_read(bcmsdh->sdioh, fnc_num, addr,
-				   (uint8 *) &data);
+				   (u8 *) &data);
 #ifdef SDIOH_API_ACCESS_RETRY_LIMIT
 	} while (!SDIOH_API_SUCCESS(status)
 		 && (retry++ < SDIOH_API_ACCESS_RETRY_LIMIT));
@@ -210,14 +210,14 @@ uint8 bcmsdh_cfg_read(void *sdh, uint fn
 	if (err)
 		*err = (SDIOH_API_SUCCESS(status) ? 0 : BCME_SDIO_ERROR);
 
-	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, uint8data = 0x%x\n",
+	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, u8data = 0x%x\n",
 		     __func__, fnc_num, addr, data));
 
 	return data;
 }
 
 void
-bcmsdh_cfg_write(void *sdh, uint fnc_num, uint32 addr, uint8 data, int *err)
+bcmsdh_cfg_write(void *sdh, uint fnc_num, uint32 addr, u8 data, int *err)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 	SDIOH_API_RC status;
@@ -237,7 +237,7 @@ bcmsdh_cfg_write(void *sdh, uint fnc_num
 #endif
 		status =
 		    sdioh_cfg_write(bcmsdh->sdioh, fnc_num, addr,
-				    (uint8 *) &data);
+				    (u8 *) &data);
 #ifdef SDIOH_API_ACCESS_RETRY_LIMIT
 	} while (!SDIOH_API_SUCCESS(status)
 		 && (retry++ < SDIOH_API_ACCESS_RETRY_LIMIT));
@@ -245,7 +245,7 @@ bcmsdh_cfg_write(void *sdh, uint fnc_num
 	if (err)
 		*err = SDIOH_API_SUCCESS(status) ? 0 : BCME_SDIO_ERROR;
 
-	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, uint8data = 0x%x\n",
+	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, u8data = 0x%x\n",
 		     __func__, fnc_num, addr, data));
 }
 
@@ -296,13 +296,13 @@ bcmsdh_cfg_write_word(void *sdh, uint fn
 		     __func__, fnc_num, addr, data));
 }
 
-int bcmsdh_cis_read(void *sdh, uint func, uint8 * cis, uint length)
+int bcmsdh_cis_read(void *sdh, uint func, u8 * cis, uint length)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 	SDIOH_API_RC status;
 
-	uint8 *tmp_buf, *tmp_ptr;
-	uint8 *ptr;
+	u8 *tmp_buf, *tmp_ptr;
+	u8 *ptr;
 	bool ascii = func & ~0xf;
 	func &= 0x7;
 
@@ -318,7 +318,7 @@ int bcmsdh_cis_read(void *sdh, uint func
 	if (ascii) {
 		/* Move binary bits to tmp and format them
 			 into the provided buffer. */
-		tmp_buf = (uint8 *) MALLOC(bcmsdh->osh, length);
+		tmp_buf = (u8 *) MALLOC(bcmsdh->osh, length);
 		if (tmp_buf == NULL) {
 			BCMSDH_ERROR(("%s: out of memory\n", __func__));
 			return BCME_NOMEM;
@@ -388,7 +388,7 @@ uint32 bcmsdh_reg_read(void *sdh, uint32
 	/* if ok, return appropriately masked word */
 	if (SDIOH_API_SUCCESS(status)) {
 		switch (size) {
-		case sizeof(uint8):
+		case sizeof(u8):
 			return word & 0xff;
 		case sizeof(uint16):
 			return word & 0xffff;
@@ -452,7 +452,7 @@ bool bcmsdh_regfail(void *sdh)
 
 int
 bcmsdh_recv_buf(void *sdh, uint32 addr, uint fn, uint flags,
-		uint8 *buf, uint nbytes, void *pkt,
+		u8 *buf, uint nbytes, void *pkt,
 		bcmsdh_cmplt_fn_t complete, void *handle)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
@@ -497,7 +497,7 @@ bcmsdh_recv_buf(void *sdh, uint32 addr,
 
 int
 bcmsdh_send_buf(void *sdh, uint32 addr, uint fn, uint flags,
-		uint8 *buf, uint nbytes, void *pkt,
+		u8 *buf, uint nbytes, void *pkt,
 		bcmsdh_cmplt_fn_t complete, void *handle)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
@@ -540,7 +540,7 @@ bcmsdh_send_buf(void *sdh, uint32 addr,
 	return SDIOH_API_SUCCESS(status) ? 0 : BCME_ERROR;
 }
 
-int bcmsdh_rwdata(void *sdh, uint rw, uint32 addr, uint8 *buf, uint nbytes)
+int bcmsdh_rwdata(void *sdh, uint rw, uint32 addr, u8 *buf, uint nbytes)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 	SDIOH_API_RC status;
--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
@@ -73,7 +73,7 @@ static int sdioh_sdmmc_card_enablefuncs(
 {
 	int err_ret;
 	uint32 fbraddr;
-	uint8 func;
+	u8 func;
 
 	sd_trace(("%s\n", __func__));
 
@@ -204,7 +204,7 @@ extern SDIOH_API_RC sdioh_detach(osl_t *
 
 extern SDIOH_API_RC sdioh_enable_func_intr(void)
 {
-	uint8 reg;
+	u8 reg;
 	int err;
 
 	if (gInstance->func[0]) {
@@ -238,7 +238,7 @@ extern SDIOH_API_RC sdioh_enable_func_in
 
 extern SDIOH_API_RC sdioh_disable_func_intr(void)
 {
-	uint8 reg;
+	u8 reg;
 	int err;
 
 	if (gInstance->func[0]) {
@@ -649,7 +649,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 	case IOV_GVAL(IOV_DEVREG):
 		{
 			sdreg_t *sd_ptr = (sdreg_t *) params;
-			uint8 data = 0;
+			u8 data = 0;
 
 			if (sdioh_cfg_read
 			    (si, sd_ptr->func, sd_ptr->offset, &data)) {
@@ -665,7 +665,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 	case IOV_SVAL(IOV_DEVREG):
 		{
 			sdreg_t *sd_ptr = (sdreg_t *) params;
-			uint8 data = (uint8) sd_ptr->value;
+			u8 data = (u8) sd_ptr->value;
 
 			if (sdioh_cfg_write
 			    (si, sd_ptr->func, sd_ptr->offset, &data)) {
@@ -689,7 +689,7 @@ exit:
 SDIOH_API_RC sdioh_enable_hw_oob_intr(sdioh_info_t *sd, bool enable)
 {
 	SDIOH_API_RC status;
-	uint8 data;
+	u8 data;
 
 	if (enable)
 		data = 3;	/* enable hw oob interrupt */
@@ -703,7 +703,7 @@ SDIOH_API_RC sdioh_enable_hw_oob_intr(sd
 #endif				/* defined(OOB_INTR_ONLY) && defined(HW_OOB) */
 
 extern SDIOH_API_RC
-sdioh_cfg_read(sdioh_info_t *sd, uint fnc_num, uint32 addr, uint8 *data)
+sdioh_cfg_read(sdioh_info_t *sd, uint fnc_num, uint32 addr, u8 *data)
 {
 	SDIOH_API_RC status;
 	/* No lock needed since sdioh_request_byte does locking */
@@ -712,7 +712,7 @@ sdioh_cfg_read(sdioh_info_t *sd, uint fn
 }
 
 extern SDIOH_API_RC
-sdioh_cfg_write(sdioh_info_t *sd, uint fnc_num, uint32 addr, uint8 *data)
+sdioh_cfg_write(sdioh_info_t *sd, uint fnc_num, uint32 addr, u8 *data)
 {
 	/* No lock needed since sdioh_request_byte does locking */
 	SDIOH_API_RC status;
@@ -725,13 +725,13 @@ static int sdioh_sdmmc_get_cisaddr(sdioh
 	/* read 24 bits and return valid 17 bit addr */
 	int i;
 	uint32 scratch, regdata;
-	uint8 *ptr = (uint8 *)&scratch;
+	u8 *ptr = (u8 *)&scratch;
 	for (i = 0; i < 3; i++) {
 		if ((sdioh_sdmmc_card_regread(sd, 0, regaddr, 1, &regdata)) !=
 		    SUCCESS)
 			sd_err(("%s: Can't read!\n", __func__));
 
-		*ptr++ = (uint8) regdata;
+		*ptr++ = (u8) regdata;
 		regaddr++;
 	}
 
@@ -742,12 +742,12 @@ static int sdioh_sdmmc_get_cisaddr(sdioh
 }
 
 extern SDIOH_API_RC
-sdioh_cis_read(sdioh_info_t *sd, uint func, uint8 *cisd, uint32 length)
+sdioh_cis_read(sdioh_info_t *sd, uint func, u8 *cisd, uint32 length)
 {
 	uint32 count;
 	int offset;
 	uint32 foo;
-	uint8 *cis = cisd;
+	u8 *cis = cisd;
 
 	sd_trace(("%s: Func = %d\n", __func__, func));
 
@@ -768,7 +768,7 @@ sdioh_cis_read(sdioh_info_t *sd, uint fu
 			return SDIOH_API_RC_FAIL;
 		}
 
-		*cis = (uint8) (foo & 0xff);
+		*cis = (u8) (foo & 0xff);
 		cis++;
 	}
 
@@ -777,7 +777,7 @@ sdioh_cis_read(sdioh_info_t *sd, uint fu
 
 extern SDIOH_API_RC
 sdioh_request_byte(sdioh_info_t *sd, uint rw, uint func, uint regaddr,
-		   uint8 *byte)
+		   u8 *byte)
 {
 	int err_ret;
 
@@ -967,19 +967,19 @@ sdioh_request_packet(sdioh_info_t *sd, u
 
 		if ((write) && (!fifo)) {
 			err_ret = sdio_memcpy_toio(gInstance->func[func], addr,
-						   ((uint8 *) PKTDATA(pnext)),
+						   ((u8 *) PKTDATA(pnext)),
 						   pkt_len);
 		} else if (write) {
 			err_ret = sdio_memcpy_toio(gInstance->func[func], addr,
-						   ((uint8 *) PKTDATA(pnext)),
+						   ((u8 *) PKTDATA(pnext)),
 						   pkt_len);
 		} else if (fifo) {
 			err_ret = sdio_readsb(gInstance->func[func],
-					      ((uint8 *) PKTDATA(pnext)),
+					      ((u8 *) PKTDATA(pnext)),
 					      addr, pkt_len);
 		} else {
 			err_ret = sdio_memcpy_fromio(gInstance->func[func],
-						     ((uint8 *) PKTDATA(pnext)),
+						     ((u8 *) PKTDATA(pnext)),
 						     addr, pkt_len);
 		}
 
@@ -1026,7 +1026,7 @@ sdioh_request_packet(sdioh_info_t *sd, u
 extern SDIOH_API_RC
 sdioh_request_buffer(sdioh_info_t *sd, uint pio_dma, uint fix_inc, uint write,
 		     uint func, uint addr, uint reg_width, uint buflen_u,
-		     uint8 *buffer, void *pkt)
+		     u8 *buffer, void *pkt)
 {
 	SDIOH_API_RC Status;
 	void *mypkt = NULL;
@@ -1160,7 +1160,7 @@ sdioh_sdmmc_card_regread(sdioh_info_t *s
 {
 
 	if ((func == 0) || (regsize == 1)) {
-		uint8 temp = 0;
+		u8 temp = 0;
 
 		sdioh_request_byte(sd, SDIOH_READ, func, regaddr, &temp);
 		*data = temp;
@@ -1226,7 +1226,7 @@ sdioh_sdmmc_card_regwrite(sdioh_info_t *
 {
 
 	if ((func == 0) || (regsize == 1)) {
-		uint8 temp;
+		u8 temp;
 
 		temp = data & 0xff;
 		sdioh_request_byte(sd, SDIOH_READ, func, regaddr, &temp);
--- a/drivers/staging/brcm80211/brcmfmac/bcmutils.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmutils.c
@@ -158,7 +158,7 @@ void *pktq_penq(struct pktq *pq, int pre
 	pq->len++;
 
 	if (pq->hi_prec < prec)
-		pq->hi_prec = (uint8) prec;
+		pq->hi_prec = (u8) prec;
 
 	return p;
 }
@@ -185,7 +185,7 @@ void *pktq_penq_head(struct pktq *pq, in
 	pq->len++;
 
 	if (pq->hi_prec < prec)
-		pq->hi_prec = (uint8) prec;
+		pq->hi_prec = (u8) prec;
 
 	return p;
 }
@@ -878,11 +878,11 @@ uint pktsetprio(void *pkt, bool update_v
 {
 	struct ether_header *eh;
 	struct ethervlan_header *evh;
-	uint8 *pktdata;
+	u8 *pktdata;
 	int priority = 0;
 	int rc = 0;
 
-	pktdata = (uint8 *) PKTDATA(pkt);
+	pktdata = (u8 *) PKTDATA(pkt);
 	ASSERT(ISALIGNED((uintptr) pktdata, sizeof(uint16)));
 
 	eh = (struct ether_header *)pktdata;
@@ -897,9 +897,9 @@ uint pktsetprio(void *pkt, bool update_v
 		vlan_prio = (int)(vlan_tag >> VLAN_PRI_SHIFT) & VLAN_PRI_MASK;
 
 		if (ntoh16(evh->ether_type) == ETHER_TYPE_IP) {
-			uint8 *ip_body =
+			u8 *ip_body =
 			    pktdata + sizeof(struct ethervlan_header);
-			uint8 tos_tc = IP_TOS(ip_body);
+			u8 tos_tc = IP_TOS(ip_body);
 			dscp_prio = (int)(tos_tc >> IPV4_TOS_PREC_SHIFT);
 		}
 
@@ -925,8 +925,8 @@ uint pktsetprio(void *pkt, bool update_v
 			rc |= PKTPRIO_UPD;
 		}
 	} else if (ntoh16(eh->ether_type) == ETHER_TYPE_IP) {
-		uint8 *ip_body = pktdata + sizeof(struct ether_header);
-		uint8 tos_tc = IP_TOS(ip_body);
+		u8 *ip_body = pktdata + sizeof(struct ether_header);
+		u8 tos_tc = IP_TOS(ip_body);
 		priority = (int)(tos_tc >> IPV4_TOS_PREC_SHIFT);
 		rc |= PKTPRIO_DSCP;
 	}
@@ -1049,7 +1049,7 @@ int bcm_iovar_lencheck(const bcm_iovar_t
  * ****************************************************************************
  */
 
-STATIC const uint8 crc8_table[256] = {
+STATIC const u8 crc8_table[256] = {
 	0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
 	0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
 	0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
@@ -1087,14 +1087,14 @@ STATIC const uint8 crc8_table[256] = {
 #define CRC_INNER_LOOP(n, c, x) \
 	(c) = ((c) >> 8) ^ crc##n##_table[((c) ^ (x)) & 0xff]
 
-uint8 hndcrc8(uint8 *pdata,	/* pointer to array of data to process */
+u8 hndcrc8(u8 *pdata,	/* pointer to array of data to process */
 	      uint nbytes,	/* number of input data bytes to process */
-	      uint8 crc		/* either CRC8_INIT_VALUE or previous
+	      u8 crc		/* either CRC8_INIT_VALUE or previous
 					 return value */
     )
 {
 	/* hard code the crc loop instead of using CRC_INNER_LOOP macro
-	 * to avoid the undefined and unnecessary (uint8 >> 8) operation.
+	 * to avoid the undefined and unnecessary (u8 >> 8) operation.
 	*/
 	while (nbytes-- > 0)
 		crc = crc8_table[(crc ^ *pdata++) & 0xff];
@@ -1159,7 +1159,7 @@ static const uint16 crc16_table[256] = {
 	0x7BC7, 0x6A4E, 0x58D5, 0x495C, 0x3DE3, 0x2C6A, 0x1EF1, 0x0F78
 };
 
-uint16 hndcrc16(uint8 *pdata,	/* pointer to array of data to process */
+uint16 hndcrc16(u8 *pdata,	/* pointer to array of data to process */
 		uint nbytes,	/* number of input data bytes to process */
 		uint16 crc	/* either CRC16_INIT_VALUE or previous
 				 return value */
@@ -1237,19 +1237,19 @@ STATIC const uint32 crc32_table[256] = {
 	0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
 };
 
-uint32 hndcrc32(uint8 *pdata,	/* pointer to array of data to process */
+uint32 hndcrc32(u8 *pdata,	/* pointer to array of data to process */
 		uint nbytes,	/* number of input data bytes to process */
 		uint32 crc	/* either CRC32_INIT_VALUE or previous
 					 return value */
 )
 {
-	uint8 *pend;
+	u8 *pend;
 #ifdef __mips__
-	uint8 tmp[4];
+	u8 tmp[4];
 	ulong *tptr = (ulong *) tmp;
 
 	/* in case the beginning of the buffer isn't aligned */
-	pend = (uint8 *) ((uint) (pdata + 3) & 0xfffffffc);
+	pend = (u8 *) ((uint) (pdata + 3) & 0xfffffffc);
 	nbytes -= (pend - pdata);
 	while (pdata < pend)
 		CRC_INNER_LOOP(32, crc, *pdata++);
@@ -1286,7 +1286,7 @@ uint32 hndcrc32(uint8 *pdata,	/* pointer
 void testcrc32(void)
 {
 	uint j, k, l;
-	uint8 *buf;
+	u8 *buf;
 	uint len[CNBUFS];
 	uint32 crcr;
 	uint32 crc32tv[CNBUFS] = {
@@ -1365,7 +1365,7 @@ bcm_tlv_t *bcm_parse_tlvs(void *buf, int
 		if ((elt->id == key) && (totlen >= (len + 2)))
 			return elt;
 
-		elt = (bcm_tlv_t *) ((uint8 *) elt + (len + 2));
+		elt = (bcm_tlv_t *) ((u8 *) elt + (len + 2));
 		totlen -= (len + 2);
 	}
 
@@ -1399,7 +1399,7 @@ bcm_tlv_t *bcm_parse_ordered_tlvs(void *
 		if ((id == key) && (totlen >= (len + 2)))
 			return elt;
 
-		elt = (bcm_tlv_t *) ((uint8 *) elt + (len + 2));
+		elt = (bcm_tlv_t *) ((u8 *) elt + (len + 2));
 		totlen -= (len + 2);
 	}
 	return NULL;
@@ -1463,7 +1463,7 @@ int bcm_format_hex(char *str, const void
 {
 	int i;
 	char *p = str;
-	const uint8 *src = (const uint8 *)bytes;
+	const u8 *src = (const u8 *)bytes;
 
 	for (i = 0; i < len; i++) {
 		p += sprintf(p, "%02X", *src);
@@ -1613,7 +1613,7 @@ static const uint16 nqdBm_to_mW_map[QDBM
 /* 185: */ 42170, 44668, 47315, 50119, 53088, 56234, 59566, 63096
 };
 
-uint16 bcm_qdbm_to_mw(uint8 qdbm)
+uint16 bcm_qdbm_to_mw(u8 qdbm)
 {
 	uint factor = 1;
 	int idx = qdbm - QDBM_OFFSET;
@@ -1637,9 +1637,9 @@ uint16 bcm_qdbm_to_mw(uint8 qdbm)
 	return (nqdBm_to_mW_map[idx] + factor / 2) / factor;
 }
 
-uint8 bcm_mw_to_qdbm(uint16 mw)
+u8 bcm_mw_to_qdbm(uint16 mw)
 {
-	uint8 qdbm;
+	u8 qdbm;
 	int offset;
 	uint mw_uint = mw;
 	uint boundary;
@@ -1663,15 +1663,15 @@ uint8 bcm_mw_to_qdbm(uint16 mw)
 			break;
 	}
 
-	qdbm += (uint8) offset;
+	qdbm += (u8) offset;
 
 	return qdbm;
 }
 
-uint bcm_bitcount(uint8 *bitmap, uint length)
+uint bcm_bitcount(u8 *bitmap, uint length)
 {
 	uint bitcount = 0, i;
-	uint8 tmp;
+	u8 tmp;
 	for (i = 0; i < length; i++) {
 		tmp = bitmap[i];
 		while (tmp) {
@@ -1716,7 +1716,7 @@ int bcm_bprintf(struct bcmstrbuf *b, con
 	return r;
 }
 
-void bcm_inc_bytes(uchar *num, int num_bytes, uint8 amount)
+void bcm_inc_bytes(uchar *num, int num_bytes, u8 amount)
 {
 	int i;
 
@@ -1728,7 +1728,7 @@ void bcm_inc_bytes(uchar *num, int num_b
 	}
 }
 
-int bcm_cmp_bytes(uchar *arg1, uchar *arg2, uint8 nbytes)
+int bcm_cmp_bytes(uchar *arg1, uchar *arg2, u8 nbytes)
 {
 	int i;
 
--- a/drivers/staging/brcm80211/brcmfmac/dhd.h
+++ b/drivers/staging/brcm80211/brcmfmac/dhd.h
@@ -101,7 +101,7 @@ typedef struct dhd_pub {
 	uint hdrlen;		/* Total DHD header length (proto + bus) */
 	uint maxctl;		/* Max size rxctl request from proto to bus */
 	uint rxsz;		/* Rx buffer size bus module should use */
-	uint8 wme_dp;		/* wme discard priority */
+	u8 wme_dp;		/* wme discard priority */
 
 	/* Dongle media info */
 	bool iswl;		/* Dongle-resident driver is wl */
@@ -153,7 +153,7 @@ typedef struct dhd_pub {
 	char *pktfilter[100];
 	int pktfilter_count;
 
-	uint8 country_code[WLC_CNTRY_BUF_SZ];
+	u8 country_code[WLC_CNTRY_BUF_SZ];
 	char eventmask[WL_EVENTING_MASK_LEN];
 
 #if defined(CONFIG_HAS_WAKELOCK)
@@ -277,10 +277,10 @@ static inline void WAKE_LOCK_DESTROY(dhd
 }
 
 typedef struct dhd_if_event {
-	uint8 ifidx;
-	uint8 action;
-	uint8 flags;
-	uint8 bssidx;
+	u8 ifidx;
+	u8 action;
+	u8 flags;
+	u8 bssidx;
 } dhd_if_event_t;
 
 /*
@@ -348,7 +348,7 @@ extern void dhd_os_sdunlock_sndup_rxq(dh
 extern void dhd_os_sdlock_eventq(dhd_pub_t *pub);
 extern void dhd_os_sdunlock_eventq(dhd_pub_t *pub);
 #ifdef DHD_DEBUG
-extern int write_to_file(dhd_pub_t *dhd, uint8 *buf, int size);
+extern int write_to_file(dhd_pub_t *dhd, u8 *buf, int size);
 #endif				/* DHD_DEBUG */
 #if defined(OOB_INTR_ONLY)
 extern int dhd_customer_oob_irq_map(unsigned long *irq_flags_ptr);
@@ -369,7 +369,7 @@ extern void dhd_timeout_start(dhd_timeou
 extern int dhd_timeout_expired(dhd_timeout_t *tmo);
 
 extern int dhd_ifname2idx(struct dhd_info *dhd, char *name);
-extern uint8 *dhd_bssidx2bssid(dhd_pub_t *dhd, int idx);
+extern u8 *dhd_bssidx2bssid(dhd_pub_t *dhd, int idx);
 extern int wl_host_event(struct dhd_info *dhd, int *idx, void *pktdata,
 			 wl_event_msg_t *, void **data_ptr);
 extern void wl_event_to_host_order(wl_event_msg_t *evt);
@@ -377,7 +377,7 @@ extern void wl_event_to_host_order(wl_ev
 extern void dhd_common_init(void);
 
 extern int dhd_add_if(struct dhd_info *dhd, int ifidx, void *handle,
-		      char *name, uint8 *mac_addr, uint32 flags, uint8 bssidx);
+		      char *name, u8 *mac_addr, uint32 flags, u8 bssidx);
 extern void dhd_del_if(struct dhd_info *dhd, int ifidx);
 
 extern void dhd_vif_add(struct dhd_info *dhd, int ifidx, char *name);
@@ -393,7 +393,7 @@ extern int dhd_sendpkt(dhd_pub_t *dhdp,
 /* Send event to host */
 extern void dhd_sendup_event(dhd_pub_t *dhdp, wl_event_msg_t *event,
 			     void *data);
-extern int dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag);
+extern int dhd_bus_devreset(dhd_pub_t *dhdp, u8 flag);
 extern uint dhd_bus_status(dhd_pub_t *dhdp);
 extern int dhd_bus_start(dhd_pub_t *dhdp);
 
--- a/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
@@ -53,9 +53,9 @@ extern int dhd_preinit_ioctls(dhd_pub_t
 
 typedef struct dhd_prot {
 	uint16 reqid;
-	uint8 pending;
+	u8 pending;
 	uint32 lastcmd;
-	uint8 bus_header[BUS_HEADER_LEN];
+	u8 bus_header[BUS_HEADER_LEN];
 	cdc_ioctl_t msg;
 	unsigned char buf[WLC_IOCTL_MAXLEN + ROUND_UP_MARGIN];
 } dhd_prot_t;
@@ -285,7 +285,7 @@ dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx
 		slen = strlen("wme_dp") + 1;
 		if (len >= (int)(slen + sizeof(int)))
 			bcopy(((char *)buf + slen), &val, sizeof(int));
-		dhd->wme_dp = (uint8) ltoh32(val);
+		dhd->wme_dp = (u8) ltoh32(val);
 	}
 
 	prot->pending = FALSE;
@@ -334,7 +334,7 @@ void dhd_prot_hdrpush(dhd_pub_t *dhd, in
 	BDC_SET_IF_IDX(h, ifidx);
 }
 
-bool dhd_proto_fcinfo(dhd_pub_t *dhd, void *pktbuf, uint8 * fcbits)
+bool dhd_proto_fcinfo(dhd_pub_t *dhd, void *pktbuf, u8 * fcbits)
 {
 #ifdef BDC
 	struct bdc_header *h;
--- a/drivers/staging/brcm80211/brcmfmac/dhd_common.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_common.c
@@ -986,7 +986,7 @@ static int wl_pattern_atoh(char *src, ch
 		char num[3];
 		strncpy(num, src, 2);
 		num[2] = '\0';
-		dst[i] = (uint8) strtoul(num, NULL, 16);
+		dst[i] = (u8) strtoul(num, NULL, 16);
 		src += 2;
 	}
 	return i;
--- a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
@@ -212,7 +212,7 @@ typedef struct dhd_if {
 	int idx;		/* iface idx in dongle */
 	int state;		/* interface state */
 	uint subunit;		/* subunit */
-	uint8 mac_addr[ETHER_ADDR_LEN];	/* assigned MAC address */
+	u8 mac_addr[ETHER_ADDR_LEN];	/* assigned MAC address */
 	bool attached;		/* Delayed attachment when unset */
 	bool txflowcontrol;	/* Per interface flow control indicator */
 	char name[IFNAMSIZ + 1];	/* linux interface name */
@@ -1042,7 +1042,7 @@ int dhd_sendpkt(dhd_pub_t *dhdp, int ifi
 
 	/* Update multicast statistic */
 	if (PKTLEN(pktbuf) >= ETHER_ADDR_LEN) {
-		uint8 *pktdata = (uint8 *) PKTDATA(pktbuf);
+		u8 *pktdata = (u8 *) PKTDATA(pktbuf);
 		struct ether_header *eh = (struct ether_header *)pktdata;
 
 		if (ETHER_ISMULTI(eh->ether_dhost))
@@ -1849,7 +1849,7 @@ void dhd_osl_detach(osl_t *osh)
 
 int
 dhd_add_if(dhd_info_t *dhd, int ifidx, void *handle, char *name,
-	   uint8 *mac_addr, uint32 flags, uint8 bssidx)
+	   u8 *mac_addr, uint32 flags, u8 bssidx)
 {
 	dhd_if_t *ifp;
 
@@ -2224,7 +2224,7 @@ int dhd_net_attach(dhd_pub_t *dhdp, int
 {
 	dhd_info_t *dhd = (dhd_info_t *) dhdp->info;
 	struct net_device *net;
-	uint8 temp_addr[ETHER_ADDR_LEN] = {
+	u8 temp_addr[ETHER_ADDR_LEN] = {
 		0x00, 0x90, 0x4c, 0x11, 0x22, 0x33};
 
 	DHD_TRACE(("%s: ifidx %d\n", __func__, ifidx));
@@ -2795,7 +2795,7 @@ void dhd_wait_event_wakeup(dhd_pub_t *dh
 	return;
 }
 
-int dhd_dev_reset(struct net_device *dev, uint8 flag)
+int dhd_dev_reset(struct net_device *dev, u8 flag)
 {
 	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
 
@@ -2942,7 +2942,7 @@ int dhd_wait_pend8021x(struct net_device
 }
 
 #ifdef DHD_DEBUG
-int write_to_file(dhd_pub_t *dhd, uint8 *buf, int size)
+int write_to_file(dhd_pub_t *dhd, u8 *buf, int size)
 {
 	int ret = 0;
 	struct file *fp;
--- a/drivers/staging/brcm80211/brcmfmac/dhd_proto.h
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_proto.h
@@ -46,7 +46,7 @@ extern int dhd_prot_init(dhd_pub_t *dhdp
 /* Stop protocol: sync w/dongle state. */
 extern void dhd_prot_stop(dhd_pub_t *dhdp);
 
-extern bool dhd_proto_fcinfo(dhd_pub_t *dhd, void *pktbuf, uint8 *fcbits);
+extern bool dhd_proto_fcinfo(dhd_pub_t *dhd, void *pktbuf, u8 *fcbits);
 
 /* Add any protocol-specific data header.
  * Caller must reserve prot_hdrlen prepend space.
--- a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
@@ -154,7 +154,7 @@ typedef struct dhd_console {
 	uint log_addr;		/* Log struct address (fixed) */
 	hndrte_log_t log;	/* Log struct (host copy) */
 	uint bufsize;		/* Size of log buffer */
-	uint8 *buf;		/* Log buffer (host copy) */
+	u8 *buf;		/* Log buffer (host copy) */
 	uint last;		/* Last buffer read index */
 } dhd_console_t;
 #endif				/* DHD_DEBUG */
@@ -191,28 +191,28 @@ typedef struct dhd_bus {
 	uint roundup;		/* Max roundup limit */
 
 	struct pktq txq;	/* Queue length used for flow-control */
-	uint8 flowcontrol;	/* per prio flow control bitmask */
-	uint8 tx_seq;		/* Transmit sequence number (next) */
-	uint8 tx_max;		/* Maximum transmit sequence allowed */
+	u8 flowcontrol;	/* per prio flow control bitmask */
+	u8 tx_seq;		/* Transmit sequence number (next) */
+	u8 tx_max;		/* Maximum transmit sequence allowed */
 
-	uint8 hdrbuf[MAX_HDR_READ + DHD_SDALIGN];
-	uint8 *rxhdr;		/* Header of current rx frame (in hdrbuf) */
+	u8 hdrbuf[MAX_HDR_READ + DHD_SDALIGN];
+	u8 *rxhdr;		/* Header of current rx frame (in hdrbuf) */
 	uint16 nextlen;		/* Next Read Len from last header */
-	uint8 rx_seq;		/* Receive sequence number (expected) */
+	u8 rx_seq;		/* Receive sequence number (expected) */
 	bool rxskip;		/* Skip receive (awaiting NAK ACK) */
 
 	void *glomd;		/* Packet containing glomming descriptor */
 	void *glom;		/* Packet chain for glommed superframe */
 	uint glomerr;		/* Glom packet read errors */
 
-	uint8 *rxbuf;		/* Buffer for receiving control packets */
+	u8 *rxbuf;		/* Buffer for receiving control packets */
 	uint rxblen;		/* Allocated length of rxbuf */
-	uint8 *rxctl;		/* Aligned pointer into rxbuf */
-	uint8 *databuf;		/* Buffer for receiving big glom packet */
-	uint8 *dataptr;		/* Aligned pointer into databuf */
+	u8 *rxctl;		/* Aligned pointer into rxbuf */
+	u8 *databuf;		/* Buffer for receiving big glom packet */
+	u8 *dataptr;		/* Aligned pointer into databuf */
 	uint rxlen;		/* Length of valid data in buffer */
 
-	uint8 sdpcm_ver;	/* Bus protocol reported by dongle */
+	u8 sdpcm_ver;	/* Bus protocol reported by dongle */
 
 	bool intr;		/* Use interrupts */
 	bool poll;		/* Use polling */
@@ -253,7 +253,7 @@ typedef struct dhd_bus {
 #ifdef SDTEST
 	/* external loopback */
 	bool ext_loop;
-	uint8 loopid;
+	u8 loopid;
 
 	/* pktgen configuration */
 	uint pktgen_freq;	/* Ticks between bursts */
@@ -294,7 +294,7 @@ typedef struct dhd_bus {
 	uint f2txdata;		/* Number of f2 frame writes */
 	uint f1regdata;		/* Number of f1 register accesses */
 
-	uint8 *ctrl_frame_buf;
+	u8 *ctrl_frame_buf;
 	uint32 ctrl_frame_len;
 	bool ctrl_frame_stat;
 } dhd_bus_t;
@@ -375,8 +375,8 @@ static bool dhd_readahead;
 
 /* To check if there's window offered */
 #define DATAOK(bus) \
-	(((uint8)(bus->tx_max - bus->tx_seq) != 0) && \
-	(((uint8)(bus->tx_max - bus->tx_seq) & 0x80) == 0))
+	(((u8)(bus->tx_max - bus->tx_seq) != 0) && \
+	(((u8)(bus->tx_max - bus->tx_seq) & 0x80) == 0))
 
 /* Macros to get register read/write status */
 /* NOTE: these assume a local dhdsdio_bus_t *bus! */
@@ -424,7 +424,7 @@ static void dhdsdio_sdtest_set(dhd_bus_t
 #endif
 
 #ifdef DHD_DEBUG
-static int dhdsdio_checkdied(dhd_bus_t *bus, uint8 *data, uint size);
+static int dhdsdio_checkdied(dhd_bus_t *bus, u8 *data, uint size);
 static int dhdsdio_mem_dump(dhd_bus_t *bus);
 #endif				/* DHD_DEBUG  */
 static int dhdsdio_download_state(dhd_bus_t *bus, bool enter);
@@ -443,10 +443,10 @@ static uint process_nvram_vars(char *var
 
 static void dhd_dongle_setmemsize(struct dhd_bus *bus, int mem_size);
 static int dhd_bcmsdh_recv_buf(dhd_bus_t *bus, uint32 addr, uint fn,
-			       uint flags, uint8 *buf, uint nbytes, void *pkt,
+			       uint flags, u8 *buf, uint nbytes, void *pkt,
 			       bcmsdh_cmplt_fn_t complete, void *handle);
 static int dhd_bcmsdh_send_buf(dhd_bus_t *bus, uint32 addr, uint fn,
-			       uint flags, uint8 *buf, uint nbytes, void *pkt,
+			       uint flags, u8 *buf, uint nbytes, void *pkt,
 			       bcmsdh_cmplt_fn_t complete, void *handle);
 
 static bool dhdsdio_download_firmware(struct dhd_bus *bus, osl_t *osh,
@@ -489,7 +489,7 @@ static int dhdsdio_set_siaddr_window(dhd
 static int dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 {
 	int err;
-	uint8 clkctl, clkreq, devctl;
+	u8 clkctl, clkreq, devctl;
 	bcmsdh_info_t *sdh;
 
 	DHD_TRACE(("%s: Enter\n", __func__));
@@ -903,7 +903,7 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 {
 	int ret;
 	osl_t *osh;
-	uint8 *frame;
+	u8 *frame;
 	uint16 len, pad = 0;
 	uint32 swheader;
 	uint retries = 0;
@@ -921,7 +921,7 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 		goto done;
 	}
 
-	frame = (uint8 *) PKTDATA(pkt);
+	frame = (u8 *) PKTDATA(pkt);
 
 	/* Add alignment padding, allocate new packet if needed */
 	pad = ((uintptr) frame % DHD_SDALIGN);
@@ -946,12 +946,12 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 			/* free the pkt if canned one is not used */
 			free_pkt = TRUE;
 			pkt = new;
-			frame = (uint8 *) PKTDATA(pkt);
+			frame = (u8 *) PKTDATA(pkt);
 			ASSERT(((uintptr) frame % DHD_SDALIGN) == 0);
 			pad = 0;
 		} else {
 			PKTPUSH(pkt, pad);
-			frame = (uint8 *) PKTDATA(pkt);
+			frame = (u8 *) PKTDATA(pkt);
 
 			ASSERT((pad + SDPCM_HDRLEN) <= (int)PKTLEN(pkt));
 			bzero(frame, pad + SDPCM_HDRLEN);
@@ -1029,7 +1029,7 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 			bus->f1regdata++;
 
 			for (i = 0; i < 3; i++) {
-				uint8 hi, lo;
+				u8 hi, lo;
 				hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
 						     SBSDIO_FUNC1_WFRAMEBCHI,
 						     NULL);
@@ -1074,11 +1074,11 @@ int dhd_bus_txdata(struct dhd_bus *bus,
 #ifdef SDTEST
 	/* Push the test header if doing loopback */
 	if (bus->ext_loop) {
-		uint8 *data;
+		u8 *data;
 		PKTPUSH(pkt, SDPCM_TEST_HDRLEN);
 		data = PKTDATA(pkt);
 		*data++ = SDPCM_TEST_ECHOREQ;
-		*data++ = (uint8) bus->loopid++;
+		*data++ = (u8) bus->loopid++;
 		*data++ = (datalen >> 0);
 		*data++ = (datalen >> 8);
 		datalen += SDPCM_TEST_HDRLEN;
@@ -1167,7 +1167,7 @@ static uint dhdsdio_sendfromq(dhd_bus_t
 	int ret = 0, prec_out;
 	uint cnt = 0;
 	uint datalen;
-	uint8 tx_prec_map;
+	u8 tx_prec_map;
 
 	dhd_pub_t *dhd = bus->dhd;
 	sdpcmd_regs_t *regs = bus->regs;
@@ -1221,12 +1221,12 @@ static uint dhdsdio_sendfromq(dhd_bus_t
 
 int dhd_bus_txctl(struct dhd_bus *bus, uchar *msg, uint msglen)
 {
-	uint8 *frame;
+	u8 *frame;
 	uint16 len;
 	uint32 swheader;
 	uint retries = 0;
 	bcmsdh_info_t *sdh = bus->sdh;
-	uint8 doff = 0;
+	u8 doff = 0;
 	int ret = -1;
 	int i;
 
@@ -1339,7 +1339,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 				bus->f1regdata++;
 
 				for (i = 0; i < 3; i++) {
-					uint8 hi, lo;
+					u8 hi, lo;
 					hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
 					     SBSDIO_FUNC1_WFRAMEBCHI,
 					     NULL);
@@ -1636,7 +1636,7 @@ void dhd_bus_clearcounts(dhd_pub_t *dhdp
 }
 
 #ifdef SDTEST
-static int dhdsdio_pktgen_get(dhd_bus_t *bus, uint8 *arg)
+static int dhdsdio_pktgen_get(dhd_bus_t *bus, u8 *arg)
 {
 	dhd_pktgen_t pktgen;
 
@@ -1658,7 +1658,7 @@ static int dhdsdio_pktgen_get(dhd_bus_t
 	return 0;
 }
 
-static int dhdsdio_pktgen_set(dhd_bus_t *bus, uint8 *arg)
+static int dhdsdio_pktgen_set(dhd_bus_t *bus, u8 *arg)
 {
 	dhd_pktgen_t pktgen;
 	uint oldcnt, oldmode;
@@ -1692,7 +1692,7 @@ static int dhdsdio_pktgen_set(dhd_bus_t
 #endif				/* SDTEST */
 
 static int
-dhdsdio_membytes(dhd_bus_t *bus, bool write, uint32 address, uint8 *data,
+dhdsdio_membytes(dhd_bus_t *bus, bool write, uint32 address, u8 *data,
 		 uint size)
 {
 	int bcmerror = 0;
@@ -1759,7 +1759,7 @@ static int dhdsdio_readshared(dhd_bus_t
 
 	/* Read last word in memory to determine address of
 			 sdpcm_shared structure */
-	rv = dhdsdio_membytes(bus, FALSE, bus->ramsize - 4, (uint8 *)&addr, 4);
+	rv = dhdsdio_membytes(bus, FALSE, bus->ramsize - 4, (u8 *)&addr, 4);
 	if (rv < 0)
 		return rv;
 
@@ -1778,7 +1778,7 @@ static int dhdsdio_readshared(dhd_bus_t
 	}
 
 	/* Read hndrte_shared structure */
-	rv = dhdsdio_membytes(bus, FALSE, addr, (uint8 *) sh,
+	rv = dhdsdio_membytes(bus, FALSE, addr, (u8 *) sh,
 			      sizeof(sdpcm_shared_t));
 	if (rv < 0)
 		return rv;
@@ -1803,7 +1803,7 @@ static int dhdsdio_readshared(dhd_bus_t
 	return BCME_OK;
 }
 
-static int dhdsdio_checkdied(dhd_bus_t *bus, uint8 *data, uint size)
+static int dhdsdio_checkdied(dhd_bus_t *bus, u8 *data, uint size)
 {
 	int bcmerror = 0;
 	uint msize = 512;
@@ -1873,7 +1873,7 @@ static int dhdsdio_checkdied(dhd_bus_t *
 				str[0] = '\0';
 				bcmerror = dhdsdio_membytes(bus, FALSE,
 						sdpcm_shared.assert_exp_addr,
-						(uint8 *) str, maxstrlen);
+						(u8 *) str, maxstrlen);
 				if (bcmerror < 0)
 					goto done;
 
@@ -1885,7 +1885,7 @@ static int dhdsdio_checkdied(dhd_bus_t *
 				str[0] = '\0';
 				bcmerror = dhdsdio_membytes(bus, FALSE,
 						sdpcm_shared.assert_file_addr,
-						(uint8 *) str, maxstrlen);
+						(u8 *) str, maxstrlen);
 				if (bcmerror < 0)
 					goto done;
 
@@ -1899,7 +1899,7 @@ static int dhdsdio_checkdied(dhd_bus_t *
 
 		if (sdpcm_shared.flags & SDPCM_SHARED_TRAP) {
 			bcmerror = dhdsdio_membytes(bus, FALSE,
-					sdpcm_shared.trap_addr, (uint8 *)&tr,
+					sdpcm_shared.trap_addr, (u8 *)&tr,
 					sizeof(trap_t));
 			if (bcmerror < 0)
 				goto done;
@@ -1940,7 +1940,7 @@ static int dhdsdio_mem_dump(dhd_bus_t *b
 	int size;		/* Full mem size */
 	int start = 0;		/* Start address */
 	int read_size = 0;	/* Read size of each iteration */
-	uint8 *buf = NULL, *databuf = NULL;
+	u8 *buf = NULL, *databuf = NULL;
 
 	/* Get full mem size */
 	size = bus->ramsize;
@@ -1986,7 +1986,7 @@ static int dhdsdio_mem_dump(dhd_bus_t *b
 static int dhdsdio_readconsole(dhd_bus_t *bus)
 {
 	dhd_console_t *c = &bus->console;
-	uint8 line[CONSOLE_LINE_MAX], ch;
+	u8 line[CONSOLE_LINE_MAX], ch;
 	uint32 n, idx, addr;
 	int rv;
 
@@ -1996,7 +1996,7 @@ static int dhdsdio_readconsole(dhd_bus_t
 
 	/* Read console log struct */
 	addr = bus->console_addr + OFFSETOF(hndrte_cons_t, log);
-	rv = dhdsdio_membytes(bus, FALSE, addr, (uint8 *)&c->log,
+	rv = dhdsdio_membytes(bus, FALSE, addr, (u8 *)&c->log,
 				sizeof(c->log));
 	if (rv < 0)
 		return rv;
@@ -2210,7 +2210,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		{
 			uint32 address;
 			uint size, dsize;
-			uint8 *data;
+			u8 *data;
 
 			bool set = (actionid == IOV_SVAL(IOV_MEMBYTES));
 
@@ -2249,8 +2249,8 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 
 			/* Generate the actual data pointer */
 			data =
-			    set ? (uint8 *) params +
-			    2 * sizeof(int) : (uint8 *) arg;
+			    set ? (u8 *) params +
+			    2 * sizeof(int) : (u8 *) arg;
 
 			/* Call to do the transfer */
 			bcmerror =
@@ -2399,15 +2399,15 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 
 			bcmstrcat(arg, "\nFunc 0\n");
 			bcmsdh_cis_read(bus->sdh, 0x10,
-					(uint8 *) arg + strlen(arg),
+					(u8 *) arg + strlen(arg),
 					SBSDIO_CIS_SIZE_LIMIT);
 			bcmstrcat(arg, "\nFunc 1\n");
 			bcmsdh_cis_read(bus->sdh, 0x11,
-					(uint8 *) arg + strlen(arg),
+					(u8 *) arg + strlen(arg),
 					SBSDIO_CIS_SIZE_LIMIT);
 			bcmstrcat(arg, "\nFunc 2\n");
 			bcmsdh_cis_read(bus->sdh, 0x12,
-					(uint8 *) arg + strlen(arg),
+					(u8 *) arg + strlen(arg),
 					SBSDIO_CIS_SIZE_LIMIT);
 			break;
 		}
@@ -2477,7 +2477,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 		ASSERT(bus->dhd->osh);
 		/* ASSERT(bus->cl_devid); */
 
-		dhd_bus_devreset(bus->dhd, (uint8) bool_val);
+		dhd_bus_devreset(bus->dhd, (u8) bool_val);
 
 		break;
 
@@ -2514,7 +2514,7 @@ static int dhdsdio_write_vars(dhd_bus_t
 	int bcmerror = 0;
 	uint32 varsize;
 	uint32 varaddr;
-	uint8 *vbuffer;
+	u8 *vbuffer;
 	uint32 varsizew;
 #ifdef DHD_DEBUG
 	char *nvram_ularray;
@@ -2526,7 +2526,7 @@ static int dhdsdio_write_vars(dhd_bus_t
 	varaddr = (bus->ramsize - 4) - varsize;
 
 	if (bus->vars) {
-		vbuffer = (uint8 *) MALLOC(bus->dhd->osh, varsize);
+		vbuffer = (u8 *) MALLOC(bus->dhd->osh, varsize);
 		if (!vbuffer)
 			return BCME_NOMEM;
 
@@ -2592,7 +2592,7 @@ static int dhdsdio_write_vars(dhd_bus_t
 
 	/* Write the length token to the last word */
 	bcmerror = dhdsdio_membytes(bus, TRUE, (bus->orig_ramsize - 4),
-				    (uint8 *)&varsizew, 4);
+				    (u8 *)&varsizew, 4);
 
 	return bcmerror;
 }
@@ -2641,7 +2641,7 @@ static int dhdsdio_download_state(dhd_bu
 		if (bus->ramsize) {
 			uint32 zeros = 0;
 			dhdsdio_membytes(bus, TRUE, bus->ramsize - 4,
-					 (uint8 *)&zeros, 4);
+					 (u8 *)&zeros, 4);
 		}
 	} else {
 		if (!(si_setcore(bus->sih, SOCRAM_CORE_ID, 0))) {
@@ -2824,7 +2824,7 @@ void dhd_bus_stop(struct dhd_bus *bus, b
 {
 	osl_t *osh = bus->dhd->osh;
 	uint32 local_hostintmask;
-	uint8 saveclk;
+	u8 saveclk;
 	uint retries;
 	int err;
 
@@ -2900,9 +2900,9 @@ int dhd_bus_init(dhd_pub_t *dhdp, bool e
 	dhd_bus_t *bus = dhdp->bus;
 	dhd_timeout_t tmo;
 	uint retries = 0;
-	uint8 ready, enable;
+	u8 ready, enable;
 	int err, ret = 0;
-	uint8 saveclk;
+	u8 saveclk;
 
 	DHD_TRACE(("%s: Enter\n", __func__));
 
@@ -2963,7 +2963,7 @@ int dhd_bus_init(dhd_pub_t *dhdp, bool e
 		W_SDREG(bus->hostintmask, &bus->regs->hostintmask, retries);
 
 		bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_WATERMARK,
-				 (uint8) watermark, &err);
+				 (u8) watermark, &err);
 
 		/* Set bus state according to enable result */
 		dhdp->busstate = DHD_BUS_DATA;
@@ -3010,7 +3010,7 @@ static void dhdsdio_rxfail(dhd_bus_t *bu
 	sdpcmd_regs_t *regs = bus->regs;
 	uint retries = 0;
 	uint16 lastrbc;
-	uint8 hi, lo;
+	u8 hi, lo;
 	int err;
 
 	DHD_ERROR(("%s: %sterminate frame%s\n", __func__,
@@ -3068,7 +3068,7 @@ static void dhdsdio_rxfail(dhd_bus_t *bu
 }
 
 static void
-dhdsdio_read_control(dhd_bus_t *bus, uint8 *hdr, uint len, uint doff)
+dhdsdio_read_control(dhd_bus_t *bus, u8 *hdr, uint len, uint doff)
 {
 	bcmsdh_info_t *sdh = bus->sdh;
 	uint rdlen, pad;
@@ -3171,18 +3171,18 @@ done:
 	dhd_os_ioctl_resp_wake(bus->dhd);
 }
 
-static uint8 dhdsdio_rxglom(dhd_bus_t *bus, uint8 rxseq)
+static u8 dhdsdio_rxglom(dhd_bus_t *bus, u8 rxseq)
 {
 	uint16 dlen, totlen;
-	uint8 *dptr, num = 0;
+	u8 *dptr, num = 0;
 
 	uint16 sublen, check;
 	void *pfirst, *plast, *pnext, *save_pfirst;
 	osl_t *osh = bus->dhd->osh;
 
 	int errcode;
-	uint8 chan, seq, doff, sfdoff;
-	uint8 txmax;
+	u8 chan, seq, doff, sfdoff;
+	u8 txmax;
 
 	int ifidx = 0;
 	bool usechain = bus->use_rxchain;
@@ -3291,7 +3291,7 @@ static uint8 dhdsdio_rxglom(dhd_bus_t *b
 				__func__));
 			for (pnext = bus->glom; pnext; pnext = PKTNEXT(pnext)) {
 				DHD_GLOM(("    %p: %p len 0x%04x (%d)\n",
-					  pnext, (uint8 *) PKTDATA(pnext),
+					  pnext, (u8 *) PKTDATA(pnext),
 					  PKTLEN(pnext), PKTLEN(pnext)));
 			}
 		}
@@ -3308,7 +3308,7 @@ static uint8 dhdsdio_rxglom(dhd_bus_t *b
 						      bcmsdh_cur_sbwad
 						      (bus->sdh), SDIO_FUNC_2,
 						      F2SYNC,
-						      (uint8 *) PKTDATA(pfirst),
+						      (u8 *) PKTDATA(pfirst),
 						      dlen, pfirst, NULL, NULL);
 		} else if (bus->dataptr) {
 			errcode = dhd_bcmsdh_recv_buf(bus,
@@ -3360,7 +3360,7 @@ static uint8 dhdsdio_rxglom(dhd_bus_t *b
 #endif
 
 		/* Validate the superframe header */
-		dptr = (uint8 *) PKTDATA(pfirst);
+		dptr = (u8 *) PKTDATA(pfirst);
 		sublen = ltoh16_ua(dptr);
 		check = ltoh16_ua(dptr + sizeof(uint16));
 
@@ -3415,7 +3415,7 @@ static uint8 dhdsdio_rxglom(dhd_bus_t *b
 		}
 
 		/* Check window for sanity */
-		if ((uint8) (txmax - bus->tx_seq) > 0x40) {
+		if ((u8) (txmax - bus->tx_seq) > 0x40) {
 			DHD_ERROR(("%s: unlikely tx max %d with tx_seq %d\n",
 				__func__, txmax, bus->tx_seq));
 			txmax = bus->tx_seq + 2;
@@ -3429,7 +3429,7 @@ static uint8 dhdsdio_rxglom(dhd_bus_t *b
 		/* Validate all the subframe headers */
 		for (num = 0, pnext = pfirst; pnext && !errcode;
 		     num++, pnext = PKTNEXT(pnext)) {
-			dptr = (uint8 *) PKTDATA(pnext);
+			dptr = (u8 *) PKTDATA(pnext);
 			dlen = (uint16) PKTLEN(pnext);
 			sublen = ltoh16_ua(dptr);
 			check = ltoh16_ua(dptr + sizeof(uint16));
@@ -3493,7 +3493,7 @@ static uint8 dhdsdio_rxglom(dhd_bus_t *b
 			pnext = PKTNEXT(pfirst);
 			PKTSETNEXT(pfirst, NULL);
 
-			dptr = (uint8 *) PKTDATA(pfirst);
+			dptr = (u8 *) PKTDATA(pfirst);
 			sublen = ltoh16_ua(dptr);
 			chan = SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN]);
 			seq = SDPCM_PACKET_SEQUENCE(&dptr[SDPCM_FRAMETAG_LEN]);
@@ -3558,7 +3558,7 @@ static uint8 dhdsdio_rxglom(dhd_bus_t *b
 				__func__, num, pfirst, PKTDATA(pfirst),
 				PKTLEN(pfirst), PKTNEXT(pfirst),
 				PKTLINK(pfirst)));
-				prhex("", (uint8 *) PKTDATA(pfirst),
+				prhex("", (u8 *) PKTDATA(pfirst),
 				      MIN(PKTLEN(pfirst), 32));
 			}
 #endif				/* DHD_DEBUG */
@@ -3583,20 +3583,20 @@ static uint dhdsdio_readframes(dhd_bus_t
 	bcmsdh_info_t *sdh = bus->sdh;
 
 	uint16 len, check;	/* Extracted hardware header fields */
-	uint8 chan, seq, doff;	/* Extracted software header fields */
-	uint8 fcbits;		/* Extracted fcbits from software header */
-	uint8 delta;
+	u8 chan, seq, doff;	/* Extracted software header fields */
+	u8 fcbits;		/* Extracted fcbits from software header */
+	u8 delta;
 
 	void *pkt;		/* Packet for event or data frames */
 	uint16 pad;		/* Number of pad bytes to read */
 	uint16 rdlen;		/* Total number of bytes to read */
-	uint8 rxseq;		/* Next sequence number to expect */
+	u8 rxseq;		/* Next sequence number to expect */
 	uint rxleft = 0;	/* Remaining number of frames allowed */
 	int sdret;		/* Return code from bcmsdh calls */
-	uint8 txmax;		/* Maximum tx sequence offered */
+	u8 txmax;		/* Maximum tx sequence offered */
 	bool len_consistent;	/* Result of comparing readahead len and
 					 len from hw-hdr */
-	uint8 *rxbuf;
+	u8 *rxbuf;
 	int ifidx = 0;
 	uint rxcount = 0;	/* Total frames read */
 
@@ -3625,7 +3625,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 
 		/* Handle glomming separately */
 		if (bus->glom || bus->glomd) {
-			uint8 cnt;
+			u8 cnt;
 			DHD_GLOM(("%s: calling rxglom: glomd %p, glom %p\n",
 				  __func__, bus->glomd, bus->glom));
 			cnt = dhdsdio_rxglom(bus, rxseq);
@@ -3733,7 +3733,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 
 				ASSERT(!PKTLINK(pkt));
 				PKTALIGN(osh, pkt, rdlen, DHD_SDALIGN);
-				rxbuf = (uint8 *) PKTDATA(pkt);
+				rxbuf = (u8 *) PKTDATA(pkt);
 				/* Read the entire frame */
 				sdret =
 				    dhd_bcmsdh_recv_buf(bus,
@@ -3874,7 +3874,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 			}
 
 			/* Check window for sanity */
-			if ((uint8) (txmax - bus->tx_seq) > 0x40) {
+			if ((u8) (txmax - bus->tx_seq) > 0x40) {
 				DHD_ERROR(("%s: got unlikely tx max %d with "
 					"tx_seq %d\n",
 					__func__, txmax, bus->tx_seq));
@@ -4038,7 +4038,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 		}
 
 		/* Check window for sanity */
-		if ((uint8) (txmax - bus->tx_seq) > 0x40) {
+		if ((u8) (txmax - bus->tx_seq) > 0x40) {
 			DHD_ERROR(("%s: unlikely tx max %d with tx_seq %d\n",
 				__func__, txmax, bus->tx_seq));
 			txmax = bus->tx_seq + 2;
@@ -4107,7 +4107,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 		/* Read the remaining frame data */
 		sdret =
 		    dhd_bcmsdh_recv_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2,
-					F2SYNC, ((uint8 *) PKTDATA(pkt)), rdlen,
+					F2SYNC, ((u8 *) PKTDATA(pkt)), rdlen,
 					pkt, NULL, NULL);
 		bus->f2rxdata++;
 		ASSERT(sdret != BCME_PENDING);
@@ -4213,7 +4213,7 @@ static uint32 dhdsdio_hostmail(dhd_bus_t
 	sdpcmd_regs_t *regs = bus->regs;
 	uint32 intstatus = 0;
 	uint32 hmb_data;
-	uint8 fcbits;
+	u8 fcbits;
 	uint retries = 0;
 
 	DHD_TRACE(("%s: Enter\n", __func__));
@@ -4304,7 +4304,7 @@ bool dhdsdio_dpc(dhd_bus_t *bus)
 	/* If waiting for HTAVAIL, check status */
 	if (bus->clkstate == CLK_PENDING) {
 		int err;
-		uint8 clkctl, devctl = 0;
+		u8 clkctl, devctl = 0;
 
 #ifdef DHD_DEBUG
 		/* Check for inconsistent device control */
@@ -4459,7 +4459,7 @@ clkwait:
 
 		ret =
 		    dhd_bcmsdh_send_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2,
-					F2SYNC, (uint8 *) bus->ctrl_frame_buf,
+					F2SYNC, (u8 *) bus->ctrl_frame_buf,
 					(uint32) bus->ctrl_frame_len, NULL,
 					NULL, NULL);
 		ASSERT(ret != BCME_PENDING);
@@ -4479,7 +4479,7 @@ clkwait:
 			bus->f1regdata++;
 
 			for (i = 0; i < 3; i++) {
-				uint8 hi, lo;
+				u8 hi, lo;
 				hi = bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
 						     SBSDIO_FUNC1_WFRAMEBCHI,
 						     NULL);
@@ -4626,7 +4626,7 @@ static void dhdsdio_pktgen_init(dhd_bus_
 static void dhdsdio_pktgen(dhd_bus_t *bus)
 {
 	void *pkt;
-	uint8 *data;
+	u8 *data;
 	uint pktcount;
 	uint fillbyte;
 	osl_t *osh = bus->dhd->osh;
@@ -4666,23 +4666,23 @@ static void dhdsdio_pktgen(dhd_bus_t *bu
 		}
 		PKTALIGN(osh, pkt, (len + SDPCM_HDRLEN + SDPCM_TEST_HDRLEN),
 			 DHD_SDALIGN);
-		data = (uint8 *) PKTDATA(pkt) + SDPCM_HDRLEN;
+		data = (u8 *) PKTDATA(pkt) + SDPCM_HDRLEN;
 
 		/* Write test header cmd and extra based on mode */
 		switch (bus->pktgen_mode) {
 		case DHD_PKTGEN_ECHO:
 			*data++ = SDPCM_TEST_ECHOREQ;
-			*data++ = (uint8) bus->pktgen_sent;
+			*data++ = (u8) bus->pktgen_sent;
 			break;
 
 		case DHD_PKTGEN_SEND:
 			*data++ = SDPCM_TEST_DISCARD;
-			*data++ = (uint8) bus->pktgen_sent;
+			*data++ = (u8) bus->pktgen_sent;
 			break;
 
 		case DHD_PKTGEN_RXBURST:
 			*data++ = SDPCM_TEST_BURST;
-			*data++ = (uint8) bus->pktgen_count;
+			*data++ = (u8) bus->pktgen_count;
 			break;
 
 		default:
@@ -4701,11 +4701,11 @@ static void dhdsdio_pktgen(dhd_bus_t *bu
 			 but who cares... */
 		for (fillbyte = 0; fillbyte < len; fillbyte++)
 			*data++ =
-			    SDPCM_TEST_FILL(fillbyte, (uint8) bus->pktgen_sent);
+			    SDPCM_TEST_FILL(fillbyte, (u8) bus->pktgen_sent);
 
 #ifdef DHD_DEBUG
 		if (DHD_BYTES_ON() && DHD_DATA_ON()) {
-			data = (uint8 *) PKTDATA(pkt) + SDPCM_HDRLEN;
+			data = (u8 *) PKTDATA(pkt) + SDPCM_HDRLEN;
 			prhex("dhdsdio_pktgen: Tx Data", data,
 			      PKTLEN(pkt) - SDPCM_HDRLEN);
 		}
@@ -4733,7 +4733,7 @@ static void dhdsdio_pktgen(dhd_bus_t *bu
 static void dhdsdio_sdtest_set(dhd_bus_t *bus, bool start)
 {
 	void *pkt;
-	uint8 *data;
+	u8 *data;
 	osl_t *osh = bus->dhd->osh;
 
 	/* Allocate the packet */
@@ -4744,7 +4744,7 @@ static void dhdsdio_sdtest_set(dhd_bus_t
 		return;
 	}
 	PKTALIGN(osh, pkt, (SDPCM_HDRLEN + SDPCM_TEST_HDRLEN), DHD_SDALIGN);
-	data = (uint8 *) PKTDATA(pkt) + SDPCM_HDRLEN;
+	data = (u8 *) PKTDATA(pkt) + SDPCM_HDRLEN;
 
 	/* Fill in the test header */
 	*data++ = SDPCM_TEST_SEND;
@@ -4760,11 +4760,11 @@ static void dhdsdio_sdtest_set(dhd_bus_t
 static void dhdsdio_testrcv(dhd_bus_t *bus, void *pkt, uint seq)
 {
 	osl_t *osh = bus->dhd->osh;
-	uint8 *data;
+	u8 *data;
 	uint pktlen;
 
-	uint8 cmd;
-	uint8 extra;
+	u8 cmd;
+	u8 extra;
 	uint16 len;
 	uint16 offset;
 
@@ -4801,7 +4801,7 @@ static void dhdsdio_testrcv(dhd_bus_t *b
 	case SDPCM_TEST_ECHOREQ:
 		/* Rx->Tx turnaround ok (even on NDIS w/current
 			 implementation) */
-		*(uint8 *) (PKTDATA(pkt)) = SDPCM_TEST_ECHORSP;
+		*(u8 *) (PKTDATA(pkt)) = SDPCM_TEST_ECHORSP;
 		if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, TRUE) == 0) {
 			bus->pktgen_sent++;
 		} else {
@@ -4884,7 +4884,7 @@ extern bool dhd_bus_watchdog(dhd_pub_t *
 		if (!bus->intr || (bus->intrcount == bus->lastintrs)) {
 
 			if (!bus->dpc_sched) {
-				uint8 devpend;
+				u8 devpend;
 				devpend = bcmsdh_cfg_read(bus->sdh, SDIO_FUNC_0,
 							  SDIOD_CCCR_INTPEND,
 							  NULL);
@@ -4982,20 +4982,20 @@ extern int dhd_bus_console_in(dhd_pub_t
 	/* Zero cbuf_index */
 	addr = bus->console_addr + OFFSETOF(hndrte_cons_t, cbuf_idx);
 	val = htol32(0);
-	rv = dhdsdio_membytes(bus, TRUE, addr, (uint8 *)&val, sizeof(val));
+	rv = dhdsdio_membytes(bus, TRUE, addr, (u8 *)&val, sizeof(val));
 	if (rv < 0)
 		goto done;
 
 	/* Write message into cbuf */
 	addr = bus->console_addr + OFFSETOF(hndrte_cons_t, cbuf);
-	rv = dhdsdio_membytes(bus, TRUE, addr, (uint8 *)msg, msglen);
+	rv = dhdsdio_membytes(bus, TRUE, addr, (u8 *)msg, msglen);
 	if (rv < 0)
 		goto done;
 
 	/* Write length into vcons_in */
 	addr = bus->console_addr + OFFSETOF(hndrte_cons_t, vcons_in);
 	val = htol32(msglen);
-	rv = dhdsdio_membytes(bus, TRUE, addr, (uint8 *)&val, sizeof(val));
+	rv = dhdsdio_membytes(bus, TRUE, addr, (u8 *)&val, sizeof(val));
 	if (rv < 0)
 		goto done;
 
@@ -5019,7 +5019,7 @@ done:
 #endif				/* DHD_DEBUG */
 
 #ifdef DHD_DEBUG
-static void dhd_dump_cis(uint fn, uint8 *cis)
+static void dhd_dump_cis(uint fn, u8 *cis)
 {
 	uint byte, tag, tdata;
 	DHD_INFO(("Function %d CIS:\n", fn));
@@ -5223,7 +5223,7 @@ static bool
 dhdsdio_probe_attach(struct dhd_bus *bus, osl_t *osh, void *sdh, void *regsva,
 		     uint16 devid)
 {
-	uint8 clkctl = 0;
+	u8 clkctl = 0;
 	int err = 0;
 
 	bus->alp_only = TRUE;
@@ -5256,7 +5256,7 @@ dhdsdio_probe_attach(struct dhd_bus *bus
 #ifdef DHD_DEBUG
 	if (DHD_INFO_ON()) {
 		uint fn, numfn;
-		uint8 *cis[SDIOD_MAX_IOFUNCS];
+		u8 *cis[SDIOD_MAX_IOFUNCS];
 		int err = 0;
 
 		numfn = bcmsdh_query_iofnum(sdh);
@@ -5364,7 +5364,7 @@ dhdsdio_probe_attach(struct dhd_bus *bus
 	pktq_init(&bus->txq, (PRIOMASK + 1), QLEN);
 
 	/* Locate an appropriately-aligned portion of hdrbuf */
-	bus->rxhdr = (uint8 *) ROUNDUP((uintptr)&bus->hdrbuf[0], DHD_SDALIGN);
+	bus->rxhdr = (u8 *) ROUNDUP((uintptr)&bus->hdrbuf[0], DHD_SDALIGN);
 
 	/* Set the poll and/or interrupt flags */
 	bus->intr = (bool) dhd_intr;
@@ -5751,7 +5751,7 @@ static int dhdsdio_download_code_file(st
 	int offset = 0;
 	uint len;
 	void *image = NULL;
-	uint8 *memblock = NULL, *memptr;
+	u8 *memblock = NULL, *memptr;
 
 	DHD_INFO(("%s: download firmware %s\n", __func__, fw_path));
 
@@ -6011,7 +6011,7 @@ err:
 
 static int
 dhd_bcmsdh_recv_buf(dhd_bus_t *bus, uint32 addr, uint fn, uint flags,
-		    uint8 *buf, uint nbytes, void *pkt,
+		    u8 *buf, uint nbytes, void *pkt,
 		    bcmsdh_cmplt_fn_t complete, void *handle)
 {
 	int status;
@@ -6025,7 +6025,7 @@ dhd_bcmsdh_recv_buf(dhd_bus_t *bus, uint
 
 static int
 dhd_bcmsdh_send_buf(dhd_bus_t *bus, uint32 addr, uint fn, uint flags,
-		    uint8 *buf, uint nbytes, void *pkt,
+		    u8 *buf, uint nbytes, void *pkt,
 		    bcmsdh_cmplt_fn_t complete, void *handle)
 {
 	return bcmsdh_send_buf
@@ -6054,7 +6054,7 @@ uint dhd_bus_hdrlen(struct dhd_bus *bus)
 	return SDPCM_HDRLEN;
 }
 
-int dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
+int dhd_bus_devreset(dhd_pub_t *dhdp, u8 flag)
 {
 	int bcmerror = 0;
 	dhd_bus_t *bus;
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
@@ -73,14 +73,14 @@ static int32 wl_cfg80211_join_ibss(struc
 static int32 wl_cfg80211_leave_ibss(struct wiphy *wiphy,
 				    struct net_device *dev);
 static int32 wl_cfg80211_get_station(struct wiphy *wiphy,
-				     struct net_device *dev, uint8 *mac,
+				     struct net_device *dev, u8 *mac,
 				     struct station_info *sinfo);
 static int32 wl_cfg80211_set_power_mgmt(struct wiphy *wiphy,
 					struct net_device *dev, bool enabled,
 					int32 timeout);
 static int32 wl_cfg80211_set_bitrate_mask(struct wiphy *wiphy,
 					  struct net_device *dev,
-					  const uint8 *addr,
+					  const u8 *addr,
 					  const struct cfg80211_bitrate_mask
 					  *mask);
 static int wl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
@@ -93,21 +93,21 @@ static int32 wl_cfg80211_set_tx_power(st
 static int32 wl_cfg80211_get_tx_power(struct wiphy *wiphy, int32 *dbm);
 static int32 wl_cfg80211_config_default_key(struct wiphy *wiphy,
 					    struct net_device *dev,
-					    uint8 key_idx);
+					    u8 key_idx);
 static int32 wl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
-				 uint8 key_idx, const uint8 *mac_addr,
+				 u8 key_idx, const u8 *mac_addr,
 				 struct key_params *params);
 static int32 wl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
-				 uint8 key_idx, const uint8 *mac_addr);
+				 u8 key_idx, const u8 *mac_addr);
 static int32 wl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *dev,
-				 uint8 key_idx, const uint8 *mac_addr,
+				 u8 key_idx, const u8 *mac_addr,
 				 void *cookie, void (*callback) (void *cookie,
 								 struct
 								 key_params *
 								 params));
 static int32 wl_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,
 						 struct net_device *dev,
-						 uint8 key_idx);
+						 u8 key_idx);
 static int32 wl_cfg80211_resume(struct wiphy *wiphy);
 static int32 wl_cfg80211_suspend(struct wiphy *wiphy);
 static int32 wl_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *dev,
@@ -201,9 +201,9 @@ static int32 wl_get_assoc_ies(struct wl_
 ** information element utilities
 */
 static void wl_rst_ie(struct wl_priv *wl);
-static int32 wl_add_ie(struct wl_priv *wl, uint8 t, uint8 l, uint8 *v);
-static int32 wl_mrg_ie(struct wl_priv *wl, uint8 *ie_stream, uint16 ie_size);
-static int32 wl_cp_ie(struct wl_priv *wl, uint8 *dst, uint16 dst_size);
+static int32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v);
+static int32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, uint16 ie_size);
+static int32 wl_cp_ie(struct wl_priv *wl, u8 *dst, uint16 dst_size);
 static uint32 wl_get_ielen(struct wl_priv *wl);
 
 static int32 wl_mode_to_nl80211_iftype(int32 mode);
@@ -217,7 +217,7 @@ static int32 wl_inform_single_bss(struct
 static int32 wl_update_bss_info(struct wl_priv *wl);
 
 static int32 wl_add_keyext(struct wiphy *wiphy, struct net_device *dev,
-			   uint8 key_idx, const uint8 *mac_addr,
+			   u8 key_idx, const u8 *mac_addr,
 			   struct key_params *params);
 
 /*
@@ -264,7 +264,7 @@ static void wl_init_conf(struct wl_conf
 */
 #ifndef EMBEDDED_PLATFORM
 static int32 wl_dongle_mode(struct net_device *ndev, int32 iftype);
-static int32 wl_dongle_country(struct net_device *ndev, uint8 ccode);
+static int32 wl_dongle_country(struct net_device *ndev, u8 ccode);
 static int32 wl_dongle_up(struct net_device *ndev, uint32 up);
 static int32 wl_dongle_power(struct net_device *ndev, uint32 power_mode);
 static int32 wl_dongle_glom(struct net_device *ndev, uint32 glom,
@@ -1451,7 +1451,7 @@ static int32 wl_cfg80211_get_tx_power(st
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	struct net_device *ndev = wl_to_ndev(wl);
 	int32 txpwrdbm;
-	uint8 result;
+	u8 result;
 	int32 err = 0;
 
 	CHECK_SYS_UP();
@@ -1459,7 +1459,7 @@ static int32 wl_cfg80211_get_tx_power(st
 		WL_ERR(("error (%d)\n", err));
 		return err;
 	}
-	result = (uint8) (txpwrdbm & ~WL_TXPWR_OVERRIDE);
+	result = (u8) (txpwrdbm & ~WL_TXPWR_OVERRIDE);
 	*dbm = (int32) bcm_qdbm_to_mw(result);
 
 	return err;
@@ -1467,7 +1467,7 @@ static int32 wl_cfg80211_get_tx_power(st
 
 static int32
 wl_cfg80211_config_default_key(struct wiphy *wiphy, struct net_device *dev,
-			       uint8 key_idx)
+			       u8 key_idx)
 {
 	uint32 index;
 	int32 wsec;
@@ -1496,7 +1496,7 @@ wl_cfg80211_config_default_key(struct wi
 
 static int32
 wl_add_keyext(struct wiphy *wiphy, struct net_device *dev,
-	      uint8 key_idx, const uint8 *mac_addr, struct key_params *params)
+	      u8 key_idx, const u8 *mac_addr, struct key_params *params)
 {
 	struct wl_wsec_key key;
 	int32 err = 0;
@@ -1528,7 +1528,7 @@ wl_add_keyext(struct wiphy *wiphy, struc
 		memcpy(key.data, params->key, key.len);
 
 		if (params->cipher == WLAN_CIPHER_SUITE_TKIP) {
-			uint8 keybuf[8];
+			u8 keybuf[8];
 			memcpy(keybuf, &key.data[24], sizeof(keybuf));
 			memcpy(&key.data[24], &key.data[16], sizeof(keybuf));
 			memcpy(&key.data[16], keybuf, sizeof(keybuf));
@@ -1537,8 +1537,8 @@ wl_add_keyext(struct wiphy *wiphy, struc
 		/* if IW_ENCODE_EXT_RX_SEQ_VALID set */
 		if (params->seq && params->seq_len == 6) {
 			/* rx iv */
-			uint8 *ivptr;
-			ivptr = (uint8 *) params->seq;
+			u8 *ivptr;
+			ivptr = (u8 *) params->seq;
 			key.rxiv.hi = (ivptr[5] << 24) | (ivptr[4] << 16) |
 			    (ivptr[3] << 8) | ivptr[2];
 			key.rxiv.lo = (ivptr[1] << 8) | ivptr[0];
@@ -1585,7 +1585,7 @@ wl_add_keyext(struct wiphy *wiphy, struc
 
 static int32
 wl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
-		    uint8 key_idx, const uint8 *mac_addr,
+		    u8 key_idx, const u8 *mac_addr,
 		    struct key_params *params)
 {
 	struct wl_wsec_key key;
@@ -1668,7 +1668,7 @@ wl_cfg80211_add_key(struct wiphy *wiphy,
 
 static int32
 wl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
-		    uint8 key_idx, const uint8 *mac_addr)
+		    u8 key_idx, const u8 *mac_addr)
 {
 	struct wl_wsec_key key;
 	int32 err = 0;
@@ -1722,7 +1722,7 @@ wl_cfg80211_del_key(struct wiphy *wiphy,
 
 static int32
 wl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *dev,
-		    uint8 key_idx, const uint8 *mac_addr, void *cookie,
+		    u8 key_idx, const u8 *mac_addr, void *cookie,
 		    void (*callback) (void *cookie, struct key_params * params))
 {
 	struct key_params params;
@@ -1739,7 +1739,7 @@ wl_cfg80211_get_key(struct wiphy *wiphy,
 	key.index = key_idx;
 	swap_key_to_BE(&key);
 	memset(&params, 0, sizeof(params));
-	params.key_len = (uint8) MIN(DOT11_MAX_KEY_SIZE, key.len);
+	params.key_len = (u8) MIN(DOT11_MAX_KEY_SIZE, key.len);
 	memcpy(params.key, key.data, params.key_len);
 
 	if (unlikely
@@ -1778,7 +1778,7 @@ wl_cfg80211_get_key(struct wiphy *wiphy,
 
 static int32
 wl_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,
-				    struct net_device *dev, uint8 key_idx)
+				    struct net_device *dev, u8 key_idx)
 {
 	WL_INFO(("Not supported\n"));
 	CHECK_SYS_UP();
@@ -1787,7 +1787,7 @@ wl_cfg80211_config_default_mgmt_key(stru
 
 static int32
 wl_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,
-			uint8 *mac, struct station_info *sinfo)
+			u8 *mac, struct station_info *sinfo)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	scb_val_t scb_val;
@@ -1880,7 +1880,7 @@ static __used uint32 wl_find_msb(uint16
 
 static int32
 wl_cfg80211_set_bitrate_mask(struct wiphy *wiphy, struct net_device *dev,
-			     const uint8 *addr,
+			     const u8 *addr,
 			     const struct cfg80211_bitrate_mask *mask)
 {
 	struct wl_rateset rateset;
@@ -2241,7 +2241,7 @@ static int32 wl_inform_single_bss(struct
 		return err;
 	}
 	notif_bss_info =
-	    kzalloc(sizeof(*notif_bss_info) + sizeof(*mgmt) - sizeof(uint8) +
+	    kzalloc(sizeof(*notif_bss_info) + sizeof(*mgmt) - sizeof(u8) +
 		    WL_BSS_INFO_MAX, GFP_KERNEL);
 	if (unlikely(!notif_bss_info)) {
 		WL_ERR(("notif_bss_info alloc failed\n"));
@@ -2266,7 +2266,7 @@ static int32 wl_inform_single_bss(struct
 	wl_add_ie(wl, WLAN_EID_SSID, bi->SSID_len, bi->SSID);
 	wl_add_ie(wl, WLAN_EID_SUPP_RATES, bi->rateset.count,
 		  bi->rateset.rates);
-	wl_mrg_ie(wl, ((uint8 *) bi) + bi->ie_offset, bi->ie_length);
+	wl_mrg_ie(wl, ((u8 *) bi) + bi->ie_offset, bi->ie_length);
 	wl_cp_ie(wl, mgmt->u.probe_resp.variable, WL_BSS_INFO_MAX -
 		 offsetof(struct wl_cfg80211_bss_info, frame_buf));
 	notif_bss_info->frame_len =
@@ -2519,7 +2519,7 @@ wl_bss_roaming_done(struct wl_priv *wl,
 	memcpy(&wl->bssid, &e->addr, ETHER_ADDR_LEN);
 	wl_update_bss_info(wl);
 	cfg80211_roamed(ndev,
-			(uint8 *)&wl->bssid,
+			(u8 *)&wl->bssid,
 			conn_info->req_ie, conn_info->req_ie_len,
 			conn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);
 	WL_DBG(("Report roaming result\n"));
@@ -2541,7 +2541,7 @@ wl_bss_connect_done(struct wl_priv *wl,
 	wl_update_bss_info(wl);
 	if (test_and_clear_bit(WL_STATUS_CONNECTING, &wl->status)) {
 		cfg80211_connect_result(ndev,
-					(uint8 *)&wl->bssid,
+					(u8 *)&wl->bssid,
 					conn_info->req_ie,
 					conn_info->req_ie_len,
 					conn_info->resp_ie,
@@ -2550,7 +2550,7 @@ wl_bss_connect_done(struct wl_priv *wl,
 		WL_DBG(("Report connect result\n"));
 	} else {
 		cfg80211_roamed(ndev,
-				(uint8 *)&wl->bssid,
+				(u8 *)&wl->bssid,
 				conn_info->req_ie, conn_info->req_ie_len,
 				conn_info->resp_ie, conn_info->resp_ie_len,
 				GFP_KERNEL);
@@ -2574,7 +2574,7 @@ wl_notify_mic_status(struct wl_priv *wl,
 	else
 		key_type = NL80211_KEYTYPE_PAIRWISE;
 
-	cfg80211_michael_mic_failure(ndev, (uint8 *)&e->addr, key_type, -1,
+	cfg80211_michael_mic_failure(ndev, (u8 *)&e->addr, key_type, -1,
 				     NULL, GFP_KERNEL);
 	rtnl_unlock();
 
@@ -3285,7 +3285,7 @@ static int32 wl_dongle_mode(struct net_d
 }
 
 #ifndef EMBEDDED_PLATFORM
-static int32 wl_dongle_country(struct net_device *ndev, uint8 ccode)
+static int32 wl_dongle_country(struct net_device *ndev, u8 ccode)
 {
 
 	int32 err = 0;
@@ -3500,7 +3500,7 @@ static int32 wl_pattern_atoh(int8 *src,
 		char num[3];
 		strncpy(num, src, 2);
 		num[2] = '\0';
-		dst[i] = (uint8) strtoul(num, NULL, 16);
+		dst[i] = (u8) strtoul(num, NULL, 16);
 		src += 2;
 	}
 	return i;
@@ -3819,7 +3819,7 @@ static void wl_rst_ie(struct wl_priv *wl
 	ie->offset = 0;
 }
 
-static int32 wl_add_ie(struct wl_priv *wl, uint8 t, uint8 l, uint8 *v)
+static int32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v)
 {
 	struct wl_ie *ie = wl_to_ie(wl);
 	int32 err = 0;
@@ -3836,7 +3836,7 @@ static int32 wl_add_ie(struct wl_priv *w
 	return err;
 }
 
-static int32 wl_mrg_ie(struct wl_priv *wl, uint8 *ie_stream, uint16 ie_size)
+static int32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, uint16 ie_size)
 {
 	struct wl_ie *ie = wl_to_ie(wl);
 	int32 err = 0;
@@ -3851,7 +3851,7 @@ static int32 wl_mrg_ie(struct wl_priv *w
 	return err;
 }
 
-static int32 wl_cp_ie(struct wl_priv *wl, uint8 *dst, uint16 dst_size)
+static int32 wl_cp_ie(struct wl_priv *wl, u8 *dst, uint16 dst_size)
 {
 	struct wl_ie *ie = wl_to_ie(wl);
 	int32 err = 0;
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
@@ -184,7 +184,7 @@ struct wl_cfg80211_bss_info {
 	uint16 channel;
 	int16 rssi;
 	uint16 frame_len;
-	uint8 frame_buf[1];
+	u8 frame_buf[1];
 };
 
 /* basic structure of scan request */
@@ -195,7 +195,7 @@ struct wl_scan_req {
 /* basic structure of information element */
 struct wl_ie {
 	uint16 offset;
-	uint8 buf[WL_TLV_INFO_MAX];
+	u8 buf[WL_TLV_INFO_MAX];
 };
 
 /* event queue for cfg80211 main event */
@@ -217,18 +217,18 @@ struct wl_security {
 
 /* ibss information for currently joined ibss network */
 struct wl_ibss {
-	uint8 beacon_interval;	/* in millisecond */
-	uint8 atim;		/* in millisecond */
+	u8 beacon_interval;	/* in millisecond */
+	u8 atim;		/* in millisecond */
 	int8 join_only;
-	uint8 band;
-	uint8 channel;
+	u8 band;
+	u8 channel;
 };
 
 /* dongle profile */
 struct wl_profile {
 	uint32 mode;
 	struct wlc_ssid ssid;
-	uint8 bssid[ETHER_ADDR_LEN];
+	u8 bssid[ETHER_ADDR_LEN];
 	struct wl_security sec;
 	struct wl_ibss ibss;
 	int32 band;
@@ -258,9 +258,9 @@ struct wl_iscan_ctrl {
 
 /* association inform */
 struct wl_connect_info {
-	uint8 *req_ie;
+	u8 *req_ie;
 	int32 req_ie_len;
-	uint8 *resp_ie;
+	u8 *resp_ie;
 	int32 resp_ie_len;
 };
 
@@ -329,9 +329,9 @@ struct wl_priv {
 	bool dongle_up;		/* indicate whether dongle up or not */
 	bool roam_on;		/* on/off switch for dongle self-roaming */
 	bool scan_tried;	/* indicates if first scan attempted */
-	uint8 *ioctl_buf;	/* ioctl buffer */
-	uint8 *extra_buf;	/* maily to grab assoc information */
-	uint8 ci[0] __attribute__ ((__aligned__(NETDEV_ALIGN)));
+	u8 *ioctl_buf;	/* ioctl buffer */
+	u8 *extra_buf;	/* maily to grab assoc information */
+	u8 ci[0] __attribute__ ((__aligned__(NETDEV_ALIGN)));
 };
 
 #define wl_to_dev(w) (wiphy_dev(wl->wdev->wiphy))
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -499,7 +499,7 @@ wl_iw_get_range(struct net_device *dev,
 	int phytype;
 	int bw_cap = 0, sgi_tx = 0, nmode = 0;
 	channel_info_t ci;
-	uint8 nrate_list2copy = 0;
+	u8 nrate_list2copy = 0;
 	uint16 nrate_list[4][8] = { {13, 26, 39, 52, 78, 104, 117, 130},
 	{14, 29, 43, 58, 87, 116, 130, 144},
 	{27, 54, 81, 108, 162, 216, 243, 270},
@@ -1407,10 +1407,10 @@ wl_iw_iscan_set_scan(struct net_device *
 #endif				/* WL_IW_USE_ISCAN */
 
 #if WIRELESS_EXT > 17
-static bool ie_is_wpa_ie(uint8 **wpaie, uint8 **tlvs, int *tlvs_len)
+static bool ie_is_wpa_ie(u8 **wpaie, u8 **tlvs, int *tlvs_len)
 {
 
-	uint8 *ie = *wpaie;
+	u8 *ie = *wpaie;
 
 	if ((ie[1] >= 6) &&
 	    !bcmp((const void *)&ie[2], (const void *)(WPA_OUI "\x01"), 4)) {
@@ -1423,10 +1423,10 @@ static bool ie_is_wpa_ie(uint8 **wpaie,
 	return FALSE;
 }
 
-static bool ie_is_wps_ie(uint8 **wpsie, uint8 **tlvs, int *tlvs_len)
+static bool ie_is_wps_ie(u8 **wpsie, u8 **tlvs, int *tlvs_len)
 {
 
-	uint8 *ie = *wpsie;
+	u8 *ie = *wpsie;
 
 	if ((ie[1] >= 4) &&
 	    !bcmp((const void *)&ie[2], (const void *)(WPA_OUI "\x04"), 4)) {
@@ -1451,7 +1451,7 @@ wl_iw_handle_scanresults_ies(char **even
 	event = *event_p;
 	if (bi->ie_length) {
 		bcm_tlv_t *ie;
-		uint8 *ptr = ((uint8 *) bi) + sizeof(wl_bss_info_t);
+		u8 *ptr = ((u8 *) bi) + sizeof(wl_bss_info_t);
 		int ptr_len = bi->ie_length;
 
 #ifdef BCMWPA2
@@ -1463,11 +1463,11 @@ wl_iw_handle_scanresults_ies(char **even
 			    IWE_STREAM_ADD_POINT(info, event, end, &iwe,
 						 (char *)ie);
 		}
-		ptr = ((uint8 *) bi) + sizeof(wl_bss_info_t);
+		ptr = ((u8 *) bi) + sizeof(wl_bss_info_t);
 #endif
 
 		while ((ie = bcm_parse_tlvs(ptr, ptr_len, DOT11_MNG_WPA_ID))) {
-			if (ie_is_wps_ie(((uint8 **)&ie), &ptr, &ptr_len)) {
+			if (ie_is_wps_ie(((u8 **)&ie), &ptr, &ptr_len)) {
 				iwe.cmd = IWEVGENIE;
 				iwe.u.data.length = ie->len + 2;
 				event =
@@ -1477,10 +1477,10 @@ wl_iw_handle_scanresults_ies(char **even
 			}
 		}
 
-		ptr = ((uint8 *) bi) + sizeof(wl_bss_info_t);
+		ptr = ((u8 *) bi) + sizeof(wl_bss_info_t);
 		ptr_len = bi->ie_length;
 		while ((ie = bcm_parse_tlvs(ptr, ptr_len, DOT11_MNG_WPA_ID))) {
-			if (ie_is_wpa_ie(((uint8 **)&ie), &ptr, &ptr_len)) {
+			if (ie_is_wpa_ie(((u8 **)&ie), &ptr, &ptr_len)) {
 				iwe.cmd = IWEVGENIE;
 				iwe.u.data.length = ie->len + 2;
 				event =
@@ -1743,7 +1743,7 @@ wl_iw_iscan_get_scan(struct net_device *
 	iscan_info_t *iscan = g_iscan;
 	iscan_buf_t *p_buf;
 	uint32 counter = 0;
-	uint8 channel;
+	u8 channel;
 
 	WL_TRACE(("%s %s buflen_from_user %d:\n", dev->name, __func__,
 		  dwrq->length));
@@ -2205,7 +2205,7 @@ wl_iw_get_txpow(struct net_device *dev,
 		struct iw_param *vwrq, char *extra)
 {
 	int error, disable, txpwrdbm;
-	uint8 result;
+	u8 result;
 
 	WL_TRACE(("%s: SIOCGIWTXPOW\n", dev->name));
 
@@ -2218,7 +2218,7 @@ wl_iw_get_txpow(struct net_device *dev,
 		return error;
 
 	disable = dtoh32(disable);
-	result = (uint8) (txpwrdbm & ~WL_TXPWR_OVERRIDE);
+	result = (u8) (txpwrdbm & ~WL_TXPWR_OVERRIDE);
 	vwrq->value = (int32) bcm_qdbm_to_mw(result);
 	vwrq->fixed = 0;
 	vwrq->disabled =
@@ -2585,7 +2585,7 @@ wl_iw_set_encodeext(struct net_device *d
 		bcopy((void *)iwe->key, key.data, iwe->key_len);
 
 		if (iwe->alg == IW_ENCODE_ALG_TKIP) {
-			uint8 keybuf[8];
+			u8 keybuf[8];
 			bcopy(&key.data[24], keybuf, sizeof(keybuf));
 			bcopy(&key.data[16], &key.data[24], sizeof(keybuf));
 			bcopy(keybuf, &key.data[16], sizeof(keybuf));
@@ -3508,7 +3508,7 @@ void wl_iw_event(struct net_device *dev,
 				cmd = IWEVPMKIDCAND;
 				pmkcandlist = data;
 				count =
-				    ntoh32_ua((uint8 *) &
+				    ntoh32_ua((u8 *) &
 					      pmkcandlist->npmkid_cand);
 				ASSERT(count >= 0);
 				wrqu.data.length = sizeof(struct iw_pmkid_cand);

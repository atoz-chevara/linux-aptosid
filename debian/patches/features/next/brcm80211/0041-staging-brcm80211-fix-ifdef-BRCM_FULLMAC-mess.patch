commit 84b9fac24ba168ebe5531a820d3ed63f2f3a8935
Author: Nohee Ko <noheek@broadcom.com>
Date:   Wed Sep 29 15:56:49 2010 -0700

    staging: brcm80211: fix #ifdef BRCM_FULLMAC mess
    
    This patch fixes "#ifdef BRCM_FULLMAC" mess which shows
    in siutils.c/hndpmu.c.
    All unnecessary #ifdefs were erased.
    Also as a part of this work, bcmutils.c was also modified.
    
    Signed-off-by: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/bcmutils.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmutils.c
@@ -32,6 +32,7 @@
 #endif				/* BCMDRIVER */
 #include <bcmendian.h>
 #include <bcmdevs.h>
+#include <bcmnvram.h>
 #include <proto/ethernet.h>
 #include <proto/vlan.h>
 #include <proto/bcmip.h>
@@ -1746,6 +1747,25 @@ void bcm_print_bytes(char *name, const u
 	printf("\n");
 }
 
+int getintvar(char *vars, const char *name)
+{
+	return 0;
+}
+
+char *bcm_chipname(uint chipid, char *buf, uint len)
+{
+	const char *fmt;
+
+	fmt = ((chipid > 0xa000) || (chipid < 0x4000)) ? "%d" : "%x";
+	snprintf(buf, len, fmt, chipid);
+	return buf;
+}
+
+char *getvar(char *vars, const char *name)
+{
+	return NULL;
+}
+
 /*
  * buffer length needed for wlc_format_ssid
  * 32 SSID chars, max of 4 chars for each SSID char "\xFF", plus NULL.
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -39,96 +39,6 @@
  */
 #define	PMU_NONE(args)
 
-#ifdef BRCM_FULLMAC
-/* SDIO Pad drive strength to select value mappings */
-typedef struct {
-	uint8 strength;			/* Pad Drive Strength in mA */
-	uint8 sel;			/* Chip-specific select value */
-} sdiod_drive_str_t;
-
-/* SDIO Drive Strength to sel value table for PMU Rev 1 */
-static const sdiod_drive_str_t sdiod_drive_strength_tab1[] = {
-	{4, 0x2},
-	{2, 0x3},
-	{1, 0x0},
-	{0, 0x0} };
-
-/* SDIO Drive Strength to sel value table for PMU Rev 2, 3 */
-static const sdiod_drive_str_t sdiod_drive_strength_tab2[] = {
-	{12, 0x7},
-	{10, 0x6},
-	{8, 0x5},
-	{6, 0x4},
-	{4, 0x2},
-	{2, 0x1},
-	{0, 0x0} };
-
-#define SDIOD_DRVSTR_KEY(chip, pmu)	(((chip) << 16) | (pmu))
-
-void
-si_sdiod_drive_strength_init(si_t *sih, osl_t *osh, uint32 drivestrength)
-{
-	chipcregs_t *cc;
-	uint origidx, intr_val = 0;
-	sdiod_drive_str_t *str_tab = NULL;
-	uint32 str_mask = 0;
-	uint32 str_shift = 0;
-
-	if (!(sih->cccaps & CC_CAP_PMU)) {
-		return;
-	}
-
-	/* Remember original core before switch to chipc */
-	cc = (chipcregs_t *) si_switch_core(sih, CC_CORE_ID, &origidx,
-		&intr_val);
-
-	switch (SDIOD_DRVSTR_KEY(sih->chip, sih->pmurev)) {
-	case SDIOD_DRVSTR_KEY(BCM4325_CHIP_ID, 1):
-		str_tab = (sdiod_drive_str_t *)&sdiod_drive_strength_tab1;
-		str_mask = 0x30000000;
-		str_shift = 28;
-		break;
-	case SDIOD_DRVSTR_KEY(BCM4325_CHIP_ID, 2):
-	case SDIOD_DRVSTR_KEY(BCM4325_CHIP_ID, 3):
-		str_tab = (sdiod_drive_str_t *)&sdiod_drive_strength_tab2;
-		str_mask = 0x00003800;
-		str_shift = 11;
-		break;
-
-	default:
-		PMU_MSG(("No SDIO Drive strength init done for chip %x rev %d "
-			"pmurev %d\n", sih->chip, sih->chiprev, sih->pmurev));
-
-		break;
-	}
-
-	if (str_tab != NULL) {
-		uint32 drivestrength_sel = 0;
-		uint32 cc_data_temp;
-		int i;
-
-		for (i = 0; str_tab[i].strength != 0; i++) {
-			if (drivestrength >= str_tab[i].strength) {
-				drivestrength_sel = str_tab[i].sel;
-				break;
-			}
-		}
-
-		W_REG(osh, &cc->chipcontrol_addr, 1);
-		cc_data_temp = R_REG(osh, &cc->chipcontrol_data);
-		cc_data_temp &= ~str_mask;
-		drivestrength_sel <<= str_shift;
-		cc_data_temp |= drivestrength_sel;
-		W_REG(osh, &cc->chipcontrol_data, cc_data_temp);
-
-		PMU_MSG(("SDIO: %dmA drive strength selected, set to 0x%08x\n",
-			drivestrength, cc_data_temp));
-	}
-
-	/* Return to original core */
-	si_restore_core(sih, origidx, intr_val);
-}
-#else	/* BRCM_FULLMAC */
 /* PLL controls/clocks */
 static void si_pmu1_pllinit0(si_t *sih, osl_t *osh, chipcregs_t *cc,
 			     uint32 xtal);
@@ -2017,6 +1927,17 @@ BCMINITFN(si_sdiod_drive_strength_init)
 					    &intr_val);
 
 	switch (SDIOD_DRVSTR_KEY(sih->chip, sih->pmurev)) {
+	case SDIOD_DRVSTR_KEY(BCM4325_CHIP_ID, 1):
+		str_tab = (sdiod_drive_str_t *)&sdiod_drive_strength_tab1;
+		str_mask = 0x30000000;
+		str_shift = 28;
+		break;
+	case SDIOD_DRVSTR_KEY(BCM4325_CHIP_ID, 2):
+	case SDIOD_DRVSTR_KEY(BCM4325_CHIP_ID, 3):
+		str_tab = (sdiod_drive_str_t *)&sdiod_drive_strength_tab2;
+		str_mask = 0x00003800;
+		str_shift = 11;
+		break;
 	case SDIOD_DRVSTR_KEY(BCM4336_CHIP_ID, 8):
 		str_tab = (sdiod_drive_str_t *) &sdiod_drive_strength_tab3;
 		str_mask = 0x00003800;
@@ -2772,4 +2693,3 @@ static void BCMATTACHFN(si_pmu_set_4330_
 	     (m6div << PMU1_PLL0_PC2_M6DIV_SHIFT));
 	si_pmu_pllcontrol(sih, PMU1_PLL0_PLLCTL2, ~0, pllc2);
 }
-#endif /* BRCM_FULLMAC */
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -59,16 +59,12 @@ static bool si_buscore_prep(si_info_t *s
 			    void *sdh);
 static bool si_buscore_setup(si_info_t *sii, chipcregs_t *cc, uint bustype,
 			     uint32 savewin, uint *origidx, void *regs);
-#ifndef BRCM_FULLMAC
 static void si_nvram_process(si_info_t *sii, char *pvars);
-#endif
 
 /* dev path concatenation util */
-#ifndef BRCM_FULLMAC
 static char *si_devpathvar(si_t *sih, char *var, int len, const char *name);
 static bool _si_clkctl_cc(si_info_t *sii, uint mode);
 static bool si_ispcie(si_info_t *sii);
-#endif
 static uint BCMINITFN(socram_banksize) (si_info_t *sii, sbsocramregs_t *r,
 					uint8 idx, uint8 mtype);
 
@@ -311,8 +307,7 @@ BCMATTACHFN(si_buscore_setup) (si_info_t
 	return TRUE;
 }
 
-#ifndef BRCM_FULLMAC
-static void BCMATTACHFN(si_nvram_process) (si_info_t *sii, char *pvars)
+static __used void BCMATTACHFN(si_nvram_process) (si_info_t *sii, char *pvars)
 {
 	uint w = 0;
 
@@ -369,7 +364,6 @@ static void BCMATTACHFN(si_nvram_process
 
 	sii->pub.boardflags = getintvar(pvars, "boardflags");
 }
-#endif	/* !BRCM_FULLMAC */
 
 /* this is will make Sonics calls directly, since Sonics is no longer supported in the Si abstraction */
 /* this has been customized for the bcm 4329 ONLY */
@@ -1256,7 +1250,6 @@ uint32 BCMINITFN(si_clock_rate) (uint32
 	}
 }
 
-#ifndef BRCM_FULLMAC
 uint32 BCMINITFN(si_clock) (si_t *sih)
 {
 	si_info_t *sii;
@@ -1315,7 +1308,6 @@ uint32 BCMINITFN(si_ilp_clock) (si_t *si
 
 	return ILP_CLOCK;
 }
-#endif
 
 /* set chip watchdog reset timer to fire in 'ticks' */
 #ifdef BRCM_FULLMAC
@@ -1394,7 +1386,6 @@ void si_watchdog_ms(si_t *sih, uint32 ms
 	si_watchdog(sih, wd_msticks * ms);
 }
 
-#ifndef BRCM_FULLMAC
 uint16 BCMATTACHFN(si_d11_devid) (si_t *sih)
 {
 	si_info_t *sii = SI_INFO(sih);
@@ -1918,7 +1909,7 @@ si_pcieserdesreg(si_t *sih, uint32 mdios
 }
 
 /* return TRUE if PCIE capability exists in the pci config space */
-static bool si_ispcie(si_info_t *sii)
+static __used bool si_ispcie(si_info_t *sii)
 {
 	uint8 cap_ptr;
 
@@ -1964,7 +1955,6 @@ void si_pci_pmeclr(si_t *sih)
 
 	pcicore_pmeclr(sii->pch);
 }
-#endif /* !BRCM_FULLMAC */
 
 #ifdef BCMSDIO
 /* initialize the sdio core */
@@ -2005,7 +1995,6 @@ void si_sdio_init(si_t *sih)
 }
 #endif				/* BCMSDIO */
 
-#ifndef BRCM_FULLMAC
 bool BCMATTACHFN(si_pci_war16165) (si_t *sih)
 {
 	si_info_t *sii;
@@ -2229,7 +2218,6 @@ int si_pci_fixcfg(si_t *sih)
 	pcicore_hwup(sii->pch);
 	return 0;
 }
-#endif	/* !BRCM_FULLMAC */
 
 /* change logical "focus" to the gpio core for optimized access */
 void *si_gpiosetcore(si_t *sih)
@@ -2870,7 +2858,6 @@ bool si_deviceremoved(si_t *sih)
 	return FALSE;
 }
 
-#ifndef BRCM_FULLMAC
 bool si_is_sprom_available(si_t *sih)
 {
 	if (sih->ccrev >= 31) {
@@ -3030,4 +3017,3 @@ int si_cis_source(si_t *sih)
 		return CIS_DEFAULT;
 	}
 }
-#endif	/* BRCM_FULLMAC */

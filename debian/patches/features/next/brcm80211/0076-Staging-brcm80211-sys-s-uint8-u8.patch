commit 41feb5ede1994e2c851f65dec82790544ed364fd
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 10:09:00 2010 -0700

    Staging: brcm80211: sys: s/uint8/u8/
    
    Replace uint8 with u8, the correct kernel type to be using here.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/sys/wl_export.h
+++ b/drivers/staging/brcm80211/sys/wl_export.h
@@ -28,7 +28,7 @@ extern uint32 wl_intrsoff(struct wl_info
 extern void wl_intrsrestore(struct wl_info *wl, uint32 macintmask);
 extern void wl_event(struct wl_info *wl, char *ifname, wlc_event_t *e);
 extern void wl_event_sendup(struct wl_info *wl, const wlc_event_t *e,
-			    uint8 *data, uint32 len);
+			    u8 *data, uint32 len);
 extern int wl_up(struct wl_info *wl);
 extern void wl_down(struct wl_info *wl);
 extern void wl_txflowcontrol(struct wl_info *wl, struct wl_if *wlif, bool state,
--- a/drivers/staging/brcm80211/sys/wl_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.c
@@ -773,7 +773,7 @@ static wl_info_t *wl_attach(uint16 vendo
 
 	ulong base_addr;
 	struct ieee80211_hw *hw;
-	uint8 perm[ETH_ALEN];
+	u8 perm[ETH_ALEN];
 
 	unit = wl_found + instance_base;
 	err = 0;
@@ -2285,7 +2285,7 @@ char *wl_firmwares[WL_MAX_FW] = {
 int wl_ucode_init_buf(wl_info_t *wl, void **pbuf, uint32 idx)
 {
 	int i, entry;
-	const uint8 *pdata;
+	const u8 *pdata;
 	struct wl_fw_hdr *hdr;
 	for (i = 0; i < wl->fw.fw_cnt; i++) {
 		hdr = (struct wl_fw_hdr *)wl->fw.fw_hdr[i]->data;
@@ -2311,7 +2311,7 @@ int wl_ucode_init_buf(wl_info_t *wl, voi
 int wl_ucode_init_uint(wl_info_t *wl, uint32 *data, uint32 idx)
 {
 	int i, entry;
-	const uint8 *pdata;
+	const u8 *pdata;
 	struct wl_fw_hdr *hdr;
 	for (i = 0; i < wl->fw.fw_cnt; i++) {
 		hdr = (struct wl_fw_hdr *)wl->fw.fw_hdr[i]->data;
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -91,7 +91,7 @@ uint32 wl_ampdu_dbg =
  */
 typedef struct wlc_fifo_info {
 	uint16 ampdu_pld_size;	/* number of bytes to be pre-loaded */
-	uint8 mcs2ampdu_table[FFPLD_MAX_MCS + 1];	/* per-mcs max # of mpdus in an ampdu */
+	u8 mcs2ampdu_table[FFPLD_MAX_MCS + 1];	/* per-mcs max # of mpdus in an ampdu */
 	uint16 prev_txfunfl;	/* num of underflows last read from the HW macstats counter */
 	uint32 accum_txfunfl;	/* num of underflows since we modified pld params */
 	uint32 accum_txampdu;	/* num of tx ampdu since we modified pld params  */
@@ -103,19 +103,19 @@ typedef struct wlc_fifo_info {
 struct ampdu_info {
 	wlc_info_t *wlc;	/* pointer to main wlc structure */
 	int scb_handle;		/* scb cubby handle to retrieve data from scb */
-	uint8 ini_enable[AMPDU_MAX_SCB_TID];	/* per-tid initiator enable/disable of ampdu */
-	uint8 ba_tx_wsize;	/* Tx ba window size (in pdu) */
-	uint8 ba_rx_wsize;	/* Rx ba window size (in pdu) */
-	uint8 retry_limit;	/* mpdu transmit retry limit */
-	uint8 rr_retry_limit;	/* mpdu transmit retry limit at regular rate */
-	uint8 retry_limit_tid[AMPDU_MAX_SCB_TID];	/* per-tid mpdu transmit retry limit */
+	u8 ini_enable[AMPDU_MAX_SCB_TID];	/* per-tid initiator enable/disable of ampdu */
+	u8 ba_tx_wsize;	/* Tx ba window size (in pdu) */
+	u8 ba_rx_wsize;	/* Rx ba window size (in pdu) */
+	u8 retry_limit;	/* mpdu transmit retry limit */
+	u8 rr_retry_limit;	/* mpdu transmit retry limit at regular rate */
+	u8 retry_limit_tid[AMPDU_MAX_SCB_TID];	/* per-tid mpdu transmit retry limit */
 	/* per-tid mpdu transmit retry limit at regular rate */
-	uint8 rr_retry_limit_tid[AMPDU_MAX_SCB_TID];
-	uint8 mpdu_density;	/* min mpdu spacing (0-7) ==> 2^(x-1)/8 usec */
+	u8 rr_retry_limit_tid[AMPDU_MAX_SCB_TID];
+	u8 mpdu_density;	/* min mpdu spacing (0-7) ==> 2^(x-1)/8 usec */
 	int8 max_pdu;		/* max pdus allowed in ampdu */
-	uint8 dur;		/* max duration of an ampdu (in msec) */
-	uint8 txpkt_weight;	/* weight of ampdu in txfifo; reduces rate lag */
-	uint8 rx_factor;	/* maximum rx ampdu factor (0-3) ==> 2^(13+x) bytes */
+	u8 dur;		/* max duration of an ampdu (in msec) */
+	u8 txpkt_weight;	/* weight of ampdu in txfifo; reduces rate lag */
+	u8 rx_factor;	/* maximum rx ampdu factor (0-3) ==> 2^(13+x) bytes */
 	uint32 ffpld_rsvd;	/* number of bytes to reserve for preload */
 	uint32 max_txlen[MCS_TABLE_SIZE][2][2];	/* max size of ampdu per mcs, bw and sgi */
 	void *ini_free[AMPDU_INI_FREE];	/* array of ini's to be freed on detach */
@@ -144,10 +144,10 @@ static void wlc_ffpld_calc_mcs2ampdu_tab
 
 static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t *ampdu,
 						   scb_ampdu_t *scb_ampdu,
-						   uint8 tid, bool override);
+						   u8 tid, bool override);
 static void ampdu_cleanup_tid_ini(ampdu_info_t *ampdu, scb_ampdu_t *scb_ampdu,
-				  uint8 tid, bool force);
-static void ampdu_update_max_txlen(ampdu_info_t *ampdu, uint8 dur);
+				  u8 tid, bool force);
+static void ampdu_update_max_txlen(ampdu_info_t *ampdu, u8 dur);
 static void scb_ampdu_update_config(ampdu_info_t *ampdu, struct scb *scb);
 static void scb_ampdu_update_config_all(ampdu_info_t *ampdu);
 
@@ -163,7 +163,7 @@ static inline uint16 pkt_txh_seqnum(wlc_
 	d11txh_t *txh;
 	struct dot11_header *h;
 	txh = (d11txh_t *) PKTDATA(p);
-	h = (struct dot11_header *)((uint8 *) (txh + 1) + D11_PHY_HDR_LEN);
+	h = (struct dot11_header *)((u8 *) (txh + 1) + D11_PHY_HDR_LEN);
 	return ltoh16(h->seq) >> SEQNUM_SHIFT;
 }
 
@@ -255,7 +255,7 @@ void BCMATTACHFN(wlc_ampdu_detach) (ampd
 void scb_ampdu_cleanup(ampdu_info_t *ampdu, struct scb *scb)
 {
 	scb_ampdu_t *scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
-	uint8 tid;
+	u8 tid;
 
 	WL_AMPDU_UPDN(("scb_ampdu_cleanup: enter\n"));
 	ASSERT(scb_ampdu);
@@ -278,7 +278,7 @@ static void scb_ampdu_update_config(ampd
 	scb_ampdu_t *scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
 	int i;
 
-	scb_ampdu->max_pdu = (uint8) ampdu->wlc->pub->tunables->ampdunummpdu;
+	scb_ampdu->max_pdu = (u8) ampdu->wlc->pub->tunables->ampdunummpdu;
 
 	/* go back to legacy size if some preloading is occuring */
 	for (i = 0; i < NUM_FFPLD_FIFO; i++) {
@@ -288,7 +288,7 @@ static void scb_ampdu_update_config(ampd
 
 	/* apply user override */
 	if (ampdu->max_pdu != AUTO)
-		scb_ampdu->max_pdu = (uint8) ampdu->max_pdu;
+		scb_ampdu->max_pdu = (u8) ampdu->max_pdu;
 
 	scb_ampdu->release = MIN(scb_ampdu->max_pdu, AMPDU_SCB_MAX_RELEASE);
 
@@ -337,7 +337,7 @@ static int wlc_ffpld_check_txfunfl(wlc_i
 	ampdu_info_t *ampdu = wlc->ampdu;
 	uint32 phy_rate = MCS_RATE(FFPLD_MAX_MCS, TRUE, FALSE);
 	uint32 txunfl_ratio;
-	uint8 max_mpdu;
+	u8 max_mpdu;
 	uint32 current_ampdu_cnt = 0;
 	uint16 max_pld_size;
 	uint32 new_txunfl;
@@ -456,7 +456,7 @@ static void wlc_ffpld_calc_mcs2ampdu_tab
 {
 	int i;
 	uint32 phy_rate, dma_rate, tmp;
-	uint8 max_mpdu;
+	u8 max_mpdu;
 	wlc_fifo_info_t *fifo = (ampdu->fifo_tb + f);
 
 	/* recompute the dma rate */
@@ -479,7 +479,7 @@ static void wlc_ffpld_calc_mcs2ampdu_tab
 			tmp = ((fifo->ampdu_pld_size * phy_rate) /
 			       ((phy_rate - dma_rate) * FFPLD_MPDU_SIZE)) + 1;
 			tmp = MIN(tmp, 255);
-			fifo->mcs2ampdu_table[i] = (uint8) tmp;
+			fifo->mcs2ampdu_table[i] = (u8) tmp;
 		}
 	}
 }
@@ -489,7 +489,7 @@ wlc_ampdu_agg(ampdu_info_t *ampdu, struc
 {
 	scb_ampdu_t *scb_ampdu;
 	scb_ampdu_tid_ini_t *ini;
-	uint8 tid = (uint8) PKTPRIO(p);
+	u8 tid = (u8) PKTPRIO(p);
 
 	scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
 
@@ -507,30 +507,30 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 	wlc_info_t *wlc;
 	osl_t *osh;
 	void *p, *pkt[AMPDU_MAX_MPDU];
-	uint8 tid, ndelim;
+	u8 tid, ndelim;
 	int err = 0;
-	uint8 preamble_type = WLC_GF_PREAMBLE;
-	uint8 fbr_preamble_type = WLC_GF_PREAMBLE;
-	uint8 rts_preamble_type = WLC_LONG_PREAMBLE;
-	uint8 rts_fbr_preamble_type = WLC_LONG_PREAMBLE;
+	u8 preamble_type = WLC_GF_PREAMBLE;
+	u8 fbr_preamble_type = WLC_GF_PREAMBLE;
+	u8 rts_preamble_type = WLC_LONG_PREAMBLE;
+	u8 rts_fbr_preamble_type = WLC_LONG_PREAMBLE;
 
 	bool rr = TRUE, fbr = FALSE;
 	uint i, count = 0, fifo, seg_cnt = 0;
 	uint16 plen, len, seq = 0, mcl, mch, index, frameid, dma_len = 0;
 	uint32 ampdu_len, maxlen = 0;
 	d11txh_t *txh = NULL;
-	uint8 *plcp;
+	u8 *plcp;
 	struct dot11_header *h;
 	struct scb *scb;
 	scb_ampdu_t *scb_ampdu;
 	scb_ampdu_tid_ini_t *ini;
-	uint8 mcs = 0;
+	u8 mcs = 0;
 	bool use_rts = FALSE, use_cts = FALSE;
 	ratespec_t rspec = 0, rspec_fallback = 0;
 	ratespec_t rts_rspec = 0, rts_rspec_fallback = 0;
 	uint16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
 	struct dot11_rts_frame *rts;
-	uint8 rr_retry_limit;
+	u8 rr_retry_limit;
 	wlc_fifo_info_t *f;
 	bool fbr_iscck;
 	struct ieee80211_tx_info *tx_info;
@@ -542,7 +542,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 
 	ASSERT(p);
 
-	tid = (uint8) PKTPRIO(p);
+	tid = (u8) PKTPRIO(p);
 	ASSERT(tid < AMPDU_MAX_SCB_TID);
 
 	f = ampdu->fifo_tb + prio2fifo[tid];
@@ -603,7 +603,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 		/* pkt is good to be aggregated */
 		ASSERT(tx_info->flags & IEEE80211_TX_CTL_AMPDU);
 		txh = (d11txh_t *) PKTDATA(p);
-		plcp = (uint8 *) (txh + 1);
+		plcp = (u8 *) (txh + 1);
 		h = (struct dot11_header *)(plcp + D11_PHY_HDR_LEN);
 		seq = ltoh16(h->seq) >> SEQNUM_SHIFT;
 		index = TX_SEQ_TO_INDEX(seq);
@@ -676,7 +676,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 
 		/* patch the first MPDU */
 		if (count == 1) {
-			uint8 plcp0, plcp3, is40, sgi;
+			u8 plcp0, plcp3, is40, sgi;
 			struct ieee80211_sta *sta;
 
 			sta = tx_info->control.sta;
@@ -757,7 +757,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 
 		if (p) {
 			if ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) &&
-			    ((uint8) PKTPRIO(p) == tid)) {
+			    ((u8) PKTPRIO(p) == tid)) {
 
 				plen =
 				    pkttotlen(osh, p) + AMPDU_MAX_MPDU_OVERHEAD;
@@ -810,7 +810,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 
 		/* patch up the first txh & plcp */
 		txh = (d11txh_t *) PKTDATA(pkt[0]);
-		plcp = (uint8 *) (txh + 1);
+		plcp = (u8 *) (txh + 1);
 
 		WLC_SET_MIMO_PLCP_LEN(plcp, ampdu_len);
 		/* mark plcp to indicate ampdu */
@@ -933,7 +933,7 @@ wlc_ampdu_dotxstatus(ampdu_info_t *ampdu
 	 */
 	if (txs->status & TX_STATUS_ACK_RCV) {
 #ifdef WLC_LOW
-		uint8 status_delay = 0;
+		u8 status_delay = 0;
 
 		/* wait till the next 8 bytes of txstatus is available */
 		while (((s1 =
@@ -994,11 +994,11 @@ void wlc_ampdu_txstatus_complete(ampdu_i
 }
 #endif				/* WLC_HIGH_ONLY */
 void rate_status(wlc_info_t *wlc, struct ieee80211_tx_info *tx_info,
-		 tx_status_t *txs, uint8 mcs);
+		 tx_status_t *txs, u8 mcs);
 
 void
 rate_status(wlc_info_t *wlc, struct ieee80211_tx_info *tx_info,
-	    tx_status_t *txs, uint8 mcs)
+	    tx_status_t *txs, u8 mcs)
 {
 	struct ieee80211_tx_rate *txrate = tx_info->status.rates;
 	int i;
@@ -1022,23 +1022,23 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 	scb_ampdu_t *scb_ampdu;
 	wlc_info_t *wlc = ampdu->wlc;
 	scb_ampdu_tid_ini_t *ini;
-	uint8 bitmap[8], queue, tid;
+	u8 bitmap[8], queue, tid;
 	d11txh_t *txh;
-	uint8 *plcp;
+	u8 *plcp;
 	struct dot11_header *h;
 	uint16 seq, start_seq = 0, bindex, index, mcl;
-	uint8 mcs = 0;
+	u8 mcs = 0;
 	bool ba_recd = FALSE, ack_recd = FALSE;
-	uint8 suc_mpdu = 0, tot_mpdu = 0;
+	u8 suc_mpdu = 0, tot_mpdu = 0;
 	uint supr_status;
 	bool update_rate = TRUE, retry = TRUE, tx_error = FALSE;
 	uint16 mimoantsel = 0;
-	uint8 antselid = 0;
-	uint8 retry_limit, rr_retry_limit;
+	u8 antselid = 0;
+	u8 retry_limit, rr_retry_limit;
 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(p);
 
 #ifdef BCMDBG
-	uint8 hole[AMPDU_MAX_MPDU];
+	u8 hole[AMPDU_MAX_MPDU];
 	bzero(hole, sizeof(hole));
 #endif
 
@@ -1048,7 +1048,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 	scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
 	ASSERT(scb_ampdu);
 
-	tid = (uint8) PKTPRIO(p);
+	tid = (u8) PKTPRIO(p);
 
 	ini = SCB_AMPDU_INI(scb_ampdu, tid);
 	retry_limit = ampdu->retry_limit_tid[tid];
@@ -1146,7 +1146,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 		ASSERT(tx_info->flags & IEEE80211_TX_CTL_AMPDU);
 		txh = (d11txh_t *) PKTDATA(p);
 		mcl = ltoh16(txh->MacTxControlLow);
-		plcp = (uint8 *) (txh + 1);
+		plcp = (u8 *) (txh + 1);
 		h = (struct dot11_header *)(plcp + D11_PHY_HDR_LEN);
 		seq = ltoh16(h->seq) >> SEQNUM_SHIFT;
 
@@ -1244,7 +1244,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 }
 
 static void
-ampdu_cleanup_tid_ini(ampdu_info_t *ampdu, scb_ampdu_t *scb_ampdu, uint8 tid,
+ampdu_cleanup_tid_ini(ampdu_info_t *ampdu, scb_ampdu_t *scb_ampdu, u8 tid,
 		      bool force)
 {
 	scb_ampdu_tid_ini_t *ini;
@@ -1268,7 +1268,7 @@ ampdu_cleanup_tid_ini(ampdu_info_t *ampd
 /* initialize the initiator code for tid */
 static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t *ampdu,
 						   scb_ampdu_t *scb_ampdu,
-						   uint8 tid, bool override)
+						   u8 tid, bool override)
 {
 	scb_ampdu_tid_ini_t *ini;
 
@@ -1323,7 +1323,7 @@ bool wlc_ampdu_cap(ampdu_info_t *ampdu)
 		return FALSE;
 }
 
-static void ampdu_update_max_txlen(ampdu_info_t *ampdu, uint8 dur)
+static void ampdu_update_max_txlen(ampdu_info_t *ampdu, u8 dur)
 {
 	uint32 rate, mcs;
 
@@ -1344,13 +1344,13 @@ static void ampdu_update_max_txlen(ampdu
 	}
 }
 
-uint8 BCMFASTPATH
+u8 BCMFASTPATH
 wlc_ampdu_null_delim_cnt(ampdu_info_t *ampdu, struct scb *scb,
 			 ratespec_t rspec, int phylen)
 {
 	scb_ampdu_t *scb_ampdu;
 	int bytes, cnt, tmp;
-	uint8 tx_density;
+	u8 tx_density;
 
 	ASSERT(scb);
 	ASSERT(SCB_AMPDU(scb));
@@ -1376,7 +1376,7 @@ wlc_ampdu_null_delim_cnt(ampdu_info_t *a
 	if (bytes > phylen) {
 		cnt = CEIL(bytes - phylen, AMPDU_DELIMITER_LEN);
 		ASSERT(cnt <= 255);
-		return (uint8) cnt;
+		return (u8) cnt;
 	} else
 		return 0;
 }
@@ -1392,7 +1392,7 @@ void wlc_ampdu_macaddr_upd(wlc_info_t *w
 			       template);
 }
 
-bool wlc_aggregatable(wlc_info_t *wlc, uint8 tid)
+bool wlc_aggregatable(wlc_info_t *wlc, u8 tid)
 {
 	return wlc->ampdu->ini_enable[tid];
 }
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.h
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.h
@@ -29,7 +29,7 @@ extern void wlc_ampdu_reset(ampdu_info_t
 extern void wlc_ampdu_macaddr_upd(wlc_info_t *wlc);
 extern void wlc_ampdu_shm_upd(ampdu_info_t *ampdu);
 
-extern uint8 wlc_ampdu_null_delim_cnt(ampdu_info_t *ampdu, struct scb *scb,
+extern u8 wlc_ampdu_null_delim_cnt(ampdu_info_t *ampdu, struct scb *scb,
 				      ratespec_t rspec, int phylen);
 extern void scb_ampdu_cleanup(ampdu_info_t *ampdu, struct scb *scb);
 #ifdef WLC_HIGH_ONLY
--- a/drivers/staging/brcm80211/sys/wlc_antsel.c
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.c
@@ -60,8 +60,8 @@
 
 /* static functions */
 static int wlc_antsel_cfgupd(antsel_info_t *asi, wlc_antselcfg_t *antsel);
-static uint8 wlc_antsel_id2antcfg(antsel_info_t *asi, uint8 id);
-static uint16 wlc_antsel_antcfg2antsel(antsel_info_t *asi, uint8 ant_cfg);
+static u8 wlc_antsel_id2antcfg(antsel_info_t *asi, u8 id);
+static uint16 wlc_antsel_antcfg2antsel(antsel_info_t *asi, u8 ant_cfg);
 static void wlc_antsel_init_cfg(antsel_info_t *asi, wlc_antselcfg_t *antsel,
 				bool auto_sel);
 
@@ -72,7 +72,7 @@ const uint16 mimo_2x4_div_antselpat_tbl[
 	0, 0, 0, 0		/* n.a.              */
 };
 
-const uint8 mimo_2x4_div_antselid_tbl[16] = {
+const u8 mimo_2x4_div_antselid_tbl[16] = {
 	0, 0, 0, 0, 0, 2, 3, 0,
 	0, 0, 1, 0, 0, 0, 0, 0	/* pat to antselid */
 };
@@ -84,7 +84,7 @@ const uint16 mimo_2x3_div_antselpat_tbl[
 	16, 16, 16, 16		/* n.a.              */
 };
 
-const uint8 mimo_2x3_div_antselid_tbl[16] = {
+const u8 mimo_2x3_div_antselid_tbl[16] = {
 	0, 1, 2, 0, 0, 0, 0, 0,
 	0, 0, 0, 0, 0, 0, 0, 0	/* pat to antselid */
 };
@@ -106,7 +106,7 @@ antsel_info_t *BCMNMIATTACHFN(wlc_antsel
 	asi->pub = pub;
 	asi->antsel_type = ANTSEL_NA;
 	asi->antsel_avail = FALSE;
-	asi->antsel_antswitch = (uint8) getintvar(asi->pub->vars, "antswitch");
+	asi->antsel_antswitch = (u8) getintvar(asi->pub->vars, "antswitch");
 
 	if ((asi->pub->sromrev >= 4) && (asi->antsel_antswitch != 0)) {
 		switch (asi->antsel_antswitch) {
@@ -176,7 +176,7 @@ wlc_antsel_init_cfg(antsel_info_t *asi,
 		    bool auto_sel)
 {
 	if (asi->antsel_type == ANTSEL_2x3) {
-		uint8 antcfg_def = ANT_SELCFG_DEF_2x3 |
+		u8 antcfg_def = ANT_SELCFG_DEF_2x3 |
 		    ((asi->antsel_avail && auto_sel) ? ANT_SELCFG_AUTO : 0);
 		antsel->ant_config[ANT_SELCFG_TX_DEF] = antcfg_def;
 		antsel->ant_config[ANT_SELCFG_TX_UNICAST] = antcfg_def;
@@ -204,10 +204,10 @@ wlc_antsel_init_cfg(antsel_info_t *asi,
 
 void BCMFASTPATH
 wlc_antsel_antcfg_get(antsel_info_t *asi, bool usedef, bool sel,
-		      uint8 antselid, uint8 fbantselid, uint8 *antcfg,
-		      uint8 *fbantcfg)
+		      u8 antselid, u8 fbantselid, u8 *antcfg,
+		      u8 *fbantcfg)
 {
-	uint8 ant;
+	u8 ant;
 
 	/* if use default, assign it and return */
 	if (usedef) {
@@ -235,9 +235,9 @@ wlc_antsel_antcfg_get(antsel_info_t *asi
 }
 
 /* boardlevel antenna selection: convert mimo_antsel (ucode interface) to id */
-uint8 wlc_antsel_antsel2id(antsel_info_t *asi, uint16 antsel)
+u8 wlc_antsel_antsel2id(antsel_info_t *asi, uint16 antsel)
 {
-	uint8 antselid = 0;
+	u8 antselid = 0;
 
 	if (asi->antsel_type == ANTSEL_2x4) {
 		/* 2x4 antenna diversity board, 4 cfgs: 0-2 0-3 1-2 1-3 */
@@ -254,9 +254,9 @@ uint8 wlc_antsel_antsel2id(antsel_info_t
 }
 
 /* boardlevel antenna selection: convert id to ant_cfg */
-static uint8 wlc_antsel_id2antcfg(antsel_info_t *asi, uint8 id)
+static u8 wlc_antsel_id2antcfg(antsel_info_t *asi, u8 id)
 {
-	uint8 antcfg = ANT_SELCFG_DEF_2x2;
+	u8 antcfg = ANT_SELCFG_DEF_2x2;
 
 	if (asi->antsel_type == ANTSEL_2x4) {
 		/* 2x4 antenna diversity board, 4 cfgs: 0-2 0-3 1-2 1-3 */
@@ -273,9 +273,9 @@ static uint8 wlc_antsel_id2antcfg(antsel
 }
 
 /* boardlevel antenna selection: convert ant_cfg to mimo_antsel (ucode interface) */
-static uint16 wlc_antsel_antcfg2antsel(antsel_info_t *asi, uint8 ant_cfg)
+static uint16 wlc_antsel_antcfg2antsel(antsel_info_t *asi, u8 ant_cfg)
 {
-	uint8 idx = WLC_ANTIDX_11N(WLC_ANTSEL_11N(ant_cfg));
+	u8 idx = WLC_ANTIDX_11N(WLC_ANTSEL_11N(ant_cfg));
 	uint16 mimo_antsel = 0;
 
 	if (asi->antsel_type == ANTSEL_2x4) {
@@ -296,7 +296,7 @@ static uint16 wlc_antsel_antcfg2antsel(a
 static int wlc_antsel_cfgupd(antsel_info_t *asi, wlc_antselcfg_t *antsel)
 {
 	wlc_info_t *wlc = asi->wlc;
-	uint8 ant_cfg;
+	u8 ant_cfg;
 	uint16 mimo_antsel;
 
 	ASSERT(asi->antsel_type != ANTSEL_NA);
--- a/drivers/staging/brcm80211/sys/wlc_antsel.h
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.h
@@ -22,7 +22,7 @@ extern antsel_info_t *wlc_antsel_attach(
 extern void wlc_antsel_detach(antsel_info_t *asi);
 extern void wlc_antsel_init(antsel_info_t *asi);
 extern void wlc_antsel_antcfg_get(antsel_info_t *asi, bool usedef, bool sel,
-				  uint8 id, uint8 fbid, uint8 *antcfg,
-				  uint8 *fbantcfg);
-extern uint8 wlc_antsel_antsel2id(antsel_info_t *asi, uint16 antsel);
+				  u8 id, u8 fbid, u8 *antcfg,
+				  u8 *fbantcfg);
+extern u8 wlc_antsel_antsel2id(antsel_info_t *asi, uint16 antsel);
 #endif				/* _wlc_antsel_h_ */
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -167,7 +167,7 @@ static void wlc_bmac_setband(wlc_hw_info
 static void wlc_bmac_update_slot_timing(wlc_hw_info_t *wlc_hw, bool shortslot);
 static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t *wlc_hw);
 static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t *wlc_hw,
-					     uint8 rate);
+					     u8 rate);
 
 /* === Low Level functions === */
 
@@ -828,7 +828,7 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 		err = 15;
 		goto fail;
 	}
-	wlc_hw->sromrev = (uint8) getintvar(vars, "sromrev");
+	wlc_hw->sromrev = (u8) getintvar(vars, "sromrev");
 	wlc_hw->boardflags = (uint32) getintvar(vars, "boardflags");
 	wlc_hw->boardflags2 = (uint32) getintvar(vars, "boardflags2");
 
@@ -1488,7 +1488,7 @@ BCMINITFN(wlc_mhfdef) (wlc_info_t *wlc,
  *                   WLC_BAND_ALL  <--- All bands
  */
 void
-wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, uint8 idx, uint16 mask, uint16 val,
+wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, u8 idx, uint16 mask, uint16 val,
 	     int bands)
 {
 	uint16 save;
@@ -1542,7 +1542,7 @@ wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, uint
 	}
 }
 
-uint16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, uint8 idx, int bands)
+uint16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, u8 idx, int bands)
 {
 	wlc_hwband_t *band;
 	ASSERT(idx < MHFMAX);
@@ -1570,7 +1570,7 @@ uint16 wlc_bmac_mhf_get(wlc_hw_info_t *w
 
 static void wlc_write_mhf(wlc_hw_info_t *wlc_hw, uint16 *mhfs)
 {
-	uint8 idx;
+	u8 idx;
 	uint16 addr[] = {
 		M_HOST_FLAGS1, M_HOST_FLAGS2, M_HOST_FLAGS3, M_HOST_FLAGS4,
 		M_HOST_FLAGS5
@@ -1802,7 +1802,7 @@ wlc_bmac_write_template_ram(wlc_hw_info_
 	be_bit = (R_REG(osh, &regs->maccontrol) & MCTL_BIGEND) != 0;
 
 	while (len > 0) {
-		bcopy((uint8 *) buf, &word, sizeof(uint32));
+		bcopy((u8 *) buf, &word, sizeof(uint32));
 
 		if (be_bit)
 			word = hton32(word);
@@ -1811,7 +1811,7 @@ wlc_bmac_write_template_ram(wlc_hw_info_
 
 		W_REG(osh, &regs->tplatewrdata, word);
 
-		buf = (uint8 *) buf + sizeof(uint32);
+		buf = (u8 *) buf + sizeof(uint32);
 		len -= sizeof(uint32);
 	}
 }
@@ -2688,7 +2688,7 @@ static void BCMINITFN(wlc_coreinit) (wlc
  *  - 559241 = 0x88889 => tsf_clk_frac_h = 0x8, tsf_clk_frac_l = 0x8889
  */
 
-void wlc_bmac_switch_macfreq(wlc_hw_info_t *wlc_hw, uint8 spurmode)
+void wlc_bmac_switch_macfreq(wlc_hw_info_t *wlc_hw, u8 spurmode)
 {
 	d11regs_t *regs;
 	osl_t *osh;
@@ -2838,12 +2838,12 @@ static void wlc_write_inits(wlc_hw_info_
 {
 	int i;
 	osl_t *osh;
-	volatile uint8 *base;
+	volatile u8 *base;
 
 	WL_TRACE(("wl%d: wlc_write_inits\n", wlc_hw->unit));
 
 	osh = wlc_hw->osh;
-	base = (volatile uint8 *)wlc_hw->regs;
+	base = (volatile u8 *)wlc_hw->regs;
 
 	for (i = 0; inits[i].addr != 0xffff; i++) {
 		ASSERT((inits[i].size == 2) || (inits[i].size == 4));
@@ -2891,7 +2891,7 @@ uint16 wlc_bmac_get_txant(wlc_hw_info_t
 	return (uint16) wlc_hw->wlc->stf->txant;
 }
 
-void wlc_bmac_antsel_type_set(wlc_hw_info_t *wlc_hw, uint8 antsel_type)
+void wlc_bmac_antsel_type_set(wlc_hw_info_t *wlc_hw, u8 antsel_type)
 {
 	wlc_hw->antsel_type = antsel_type;
 
@@ -3117,7 +3117,7 @@ bool wlc_bmac_tx_fifo_suspended(wlc_hw_i
 
 void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t *wlc_hw, uint tx_fifo)
 {
-	uint8 fifo = 1 << tx_fifo;
+	u8 fifo = 1 << tx_fifo;
 
 	/* Two clients of this code, 11h Quiet period and scanning. */
 
@@ -3582,8 +3582,8 @@ void wlc_bmac_ifsctl_edcrs_set(wlc_hw_in
 
 static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t *wlc_hw)
 {
-	uint8 rate;
-	uint8 rates[8] = {
+	u8 rate;
+	u8 rates[8] = {
 		WLC_RATE_6M, WLC_RATE_9M, WLC_RATE_12M, WLC_RATE_18M,
 		WLC_RATE_24M, WLC_RATE_36M, WLC_RATE_48M, WLC_RATE_54M
 	};
@@ -3614,13 +3614,13 @@ static void wlc_upd_ofdm_pctl1_table(wlc
 	}
 }
 
-static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t *wlc_hw, uint8 rate)
+static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t *wlc_hw, u8 rate)
 {
 	uint i;
-	uint8 plcp_rate = 0;
+	u8 plcp_rate = 0;
 	struct plcp_signal_rate_lookup {
-		uint8 rate;
-		uint8 signal_rate;
+		u8 rate;
+		u8 signal_rate;
 	};
 	/* OFDM RATE sub-field of PLCP SIGNAL field, per 802.11 sec 17.3.4.1 */
 	const struct plcp_signal_rate_lookup rate_lookup[] = {
@@ -3647,7 +3647,7 @@ static uint16 wlc_bmac_ofdm_ratetable_of
 	return 2 * wlc_bmac_read_shm(wlc_hw, M_RT_DIRMAP_A + (plcp_rate * 2));
 }
 
-void wlc_bmac_band_stf_ss_set(wlc_hw_info_t *wlc_hw, uint8 stf_mode)
+void wlc_bmac_band_stf_ss_set(wlc_hw_info_t *wlc_hw, u8 stf_mode)
 {
 	wlc_hw->hw_stf_ss_opmode = stf_mode;
 
@@ -3984,7 +3984,7 @@ wlc_bmac_copyto_objmem(wlc_hw_info_t *wl
 		       int len, uint32 sel)
 {
 	uint16 v;
-	const uint8 *p = (const uint8 *)buf;
+	const u8 *p = (const u8 *)buf;
 	int i;
 
 	/* offset and len need to be even */
@@ -4010,7 +4010,7 @@ wlc_bmac_copyfrom_objmem(wlc_hw_info_t *
 			 int len, uint32 sel)
 {
 	uint16 v;
-	uint8 *p = (uint8 *) buf;
+	u8 *p = (u8 *) buf;
 	int i;
 
 	/* offset and len need to be even */
@@ -4178,10 +4178,10 @@ bool wlc_bmac_radio_hw(wlc_hw_info_t *wl
 	return TRUE;
 }
 
-uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, uint8 rate)
+uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, u8 rate)
 {
 	uint16 table_ptr;
-	uint8 phy_rate, index;
+	u8 phy_rate, index;
 
 	/* get the phy specific rate encoding for the PLCP SIGNAL field */
 	/* XXX4321 fixup needed ? */
@@ -4202,7 +4202,7 @@ uint16 wlc_bmac_rate_shm_offset(wlc_hw_i
 	return 2 * wlc_bmac_read_shm(wlc_hw, table_ptr + (index * 2));
 }
 
-void wlc_bmac_set_txpwr_percent(wlc_hw_info_t *wlc_hw, uint8 val)
+void wlc_bmac_set_txpwr_percent(wlc_hw_info_t *wlc_hw, u8 val)
 {
 	wlc_phy_txpwr_percent_set(wlc_hw->band->pi, val);
 }
--- a/drivers/staging/brcm80211/sys/wlc_bmac.h
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.h
@@ -167,7 +167,7 @@ extern int wlc_bmac_up_finish(wlc_hw_inf
 extern int wlc_bmac_down_prep(wlc_hw_info_t *wlc_hw);
 extern int wlc_bmac_down_finish(wlc_hw_info_t *wlc_hw);
 extern void wlc_bmac_corereset(wlc_hw_info_t *wlc_hw, uint32 flags);
-extern void wlc_bmac_switch_macfreq(wlc_hw_info_t *wlc_hw, uint8 spurmode);
+extern void wlc_bmac_switch_macfreq(wlc_hw_info_t *wlc_hw, u8 spurmode);
 
 /* chanspec, ucode interface */
 extern int wlc_bmac_bandtype(wlc_hw_info_t *wlc_hw);
@@ -175,18 +175,18 @@ extern void wlc_bmac_set_chanspec(wlc_hw
 				  bool mute, struct txpwr_limits *txpwr);
 
 extern void wlc_bmac_txfifo(wlc_hw_info_t *wlc_hw, uint fifo, void *p,
-			    bool commit, uint16 frameid, uint8 txpktpend);
+			    bool commit, uint16 frameid, u8 txpktpend);
 extern int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t *wlc_hw, uint fifo,
 				   uint *blocks);
-extern void wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, uint8 idx, uint16 mask,
+extern void wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, u8 idx, uint16 mask,
 			 uint16 val, int bands);
 extern void wlc_bmac_mctrl(wlc_hw_info_t *wlc_hw, uint32 mask, uint32 val);
-extern uint16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, uint8 idx, int bands);
+extern uint16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, u8 idx, int bands);
 extern int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t *wlc_hw, uint fifo,
 				   uint blocks);
 extern void wlc_bmac_txant_set(wlc_hw_info_t *wlc_hw, uint16 phytxant);
 extern uint16 wlc_bmac_get_txant(wlc_hw_info_t *wlc_hw);
-extern void wlc_bmac_antsel_type_set(wlc_hw_info_t *wlc_hw, uint8 antsel_type);
+extern void wlc_bmac_antsel_type_set(wlc_hw_info_t *wlc_hw, u8 antsel_type);
 extern int wlc_bmac_revinfo_get(wlc_hw_info_t *wlc_hw,
 				wlc_bmac_revinfo_t *revinfo);
 extern int wlc_bmac_state_get(wlc_hw_info_t *wlc_hw, wlc_bmac_state_t *state);
@@ -211,7 +211,7 @@ extern bool wlc_bmac_radio_read_hwdisabl
 extern void wlc_bmac_set_shortslot(wlc_hw_info_t *wlc_hw, bool shortslot);
 extern void wlc_bmac_mute(wlc_hw_info_t *wlc_hw, bool want, mbool flags);
 extern void wlc_bmac_set_deaf(wlc_hw_info_t *wlc_hw, bool user_flag);
-extern void wlc_bmac_band_stf_ss_set(wlc_hw_info_t *wlc_hw, uint8 stf_mode);
+extern void wlc_bmac_band_stf_ss_set(wlc_hw_info_t *wlc_hw, u8 stf_mode);
 
 extern void wlc_bmac_wait_for_wake(wlc_hw_info_t *wlc_hw);
 extern bool wlc_bmac_tx_fifo_suspended(wlc_hw_info_t *wlc_hw, uint tx_fifo);
@@ -266,10 +266,10 @@ extern void wlc_bmac_dump(wlc_hw_info_t
 extern void wlc_gpio_fast_deinit(wlc_hw_info_t *wlc_hw);
 
 extern bool wlc_bmac_radio_hw(wlc_hw_info_t *wlc_hw, bool enable);
-extern uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, uint8 rate);
+extern uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, u8 rate);
 
 extern void wlc_bmac_assert_type_set(wlc_hw_info_t *wlc_hw, uint32 type);
-extern void wlc_bmac_set_txpwr_percent(wlc_hw_info_t *wlc_hw, uint8 val);
+extern void wlc_bmac_set_txpwr_percent(wlc_hw_info_t *wlc_hw, u8 val);
 extern void wlc_bmac_blink_sync(wlc_hw_info_t *wlc_hw, uint32 led_pins);
 extern void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t *wlc_hw, bool abie,
 				      bool isht);
--- a/drivers/staging/brcm80211/sys/wlc_bsscfg.h
+++ b/drivers/staging/brcm80211/sys/wlc_bsscfg.h
@@ -61,8 +61,8 @@ struct wlc_bsscfg {
 	void *authenticator;	/* pointer to authenticator state */
 	bool sup_auth_pending;	/* flag for auth timeout */
 #endif
-	uint8 SSID_len;		/* the length of SSID */
-	uint8 SSID[DOT11_MAX_SSID_LEN];	/* SSID string */
+	u8 SSID_len;		/* the length of SSID */
+	u8 SSID[DOT11_MAX_SSID_LEN];	/* SSID string */
 	struct scb *bcmc_scb[MAXBANDS];	/* one bcmc_scb per band */
 	int8 _idx;		/* the index of this bsscfg,
 				 * assigned at wlc_bsscfg_alloc()
@@ -99,7 +99,7 @@ struct wlc_bsscfg {
 
 	uint32 flags;		/* WLC_BSSCFG flags; see below */
 
-	uint8 *bcn;		/* AP beacon */
+	u8 *bcn;		/* AP beacon */
 	uint bcn_len;		/* AP beacon length */
 	bool ar_disassoc;	/* disassociated in associated recreation */
 
--- a/drivers/staging/brcm80211/sys/wlc_channel.c
+++ b/drivers/staging/brcm80211/sys/wlc_channel.c
@@ -32,11 +32,11 @@
 #include <wlc_channel.h>
 
 typedef struct wlc_cm_band {
-	uint8 locale_flags;	/* locale_info_t flags */
+	u8 locale_flags;	/* locale_info_t flags */
 	chanvec_t valid_channels;	/* List of valid channels in the country */
 	const chanvec_t *restricted_channels;	/* List of restricted use channels */
 	const chanvec_t *radar_channels;	/* List of radar sensitive channels */
-	uint8 PAD[8];
+	u8 PAD[8];
 } wlc_cm_band_t;
 
 struct wlc_cm_info {
@@ -74,11 +74,11 @@ static void wlc_channel_min_txpower_limi
 								 struct
 								 txpwr_limits
 								 *txpwr,
-								 uint8
+								 u8
 								 local_constraint_qdbm);
 void wlc_locale_add_channels(chanvec_t *target, const chanvec_t *channels);
-static const locale_mimo_info_t *wlc_get_mimo_2g(uint8 locale_idx);
-static const locale_mimo_info_t *wlc_get_mimo_5g(uint8 locale_idx);
+static const locale_mimo_info_t *wlc_get_mimo_2g(u8 locale_idx);
+static const locale_mimo_info_t *wlc_get_mimo_5g(u8 locale_idx);
 
 /* QDB() macro takes a dB value and converts to a quarter dB value */
 #ifdef QDB
@@ -368,7 +368,7 @@ static const chanvec_t *g_table_locale_b
 
 void wlc_locale_add_channels(chanvec_t *target, const chanvec_t *channels)
 {
-	uint8 i;
+	u8 i;
 	for (i = 0; i < sizeof(chanvec_t); i++) {
 		target->vec[i] |= channels->vec[i];
 	}
@@ -376,7 +376,7 @@ void wlc_locale_add_channels(chanvec_t *
 
 void wlc_locale_get_channels(const locale_info_t *locale, chanvec_t *channels)
 {
-	uint8 i;
+	u8 i;
 
 	bzero(channels, sizeof(chanvec_t));
 
@@ -486,8 +486,8 @@ static const struct {
 #ifdef SUPPORT_40MHZ
 /* 20MHz channel info for 40MHz pairing support */
 struct chan20_info {
-	uint8 sb;
-	uint8 adj_sbs;
+	u8 sb;
+	u8 adj_sbs;
 };
 
 /* indicates adjacent channels that are allowed for a 40 Mhz channel and
@@ -560,7 +560,7 @@ struct chan20_info chan20_info[] = {
 };
 #endif				/* SUPPORT_40MHZ */
 
-const locale_info_t *wlc_get_locale_2g(uint8 locale_idx)
+const locale_info_t *wlc_get_locale_2g(u8 locale_idx)
 {
 	if (locale_idx >= ARRAYSIZE(g_locale_2g_table)) {
 		WL_ERROR(("%s: locale 2g index size out of range %d\n",
@@ -571,7 +571,7 @@ const locale_info_t *wlc_get_locale_2g(u
 	return g_locale_2g_table[locale_idx];
 }
 
-const locale_info_t *wlc_get_locale_5g(uint8 locale_idx)
+const locale_info_t *wlc_get_locale_5g(u8 locale_idx)
 {
 	if (locale_idx >= ARRAYSIZE(g_locale_5g_table)) {
 		WL_ERROR(("%s: locale 5g index size out of range %d\n",
@@ -582,7 +582,7 @@ const locale_info_t *wlc_get_locale_5g(u
 	return g_locale_5g_table[locale_idx];
 }
 
-const locale_mimo_info_t *wlc_get_mimo_2g(uint8 locale_idx)
+const locale_mimo_info_t *wlc_get_mimo_2g(u8 locale_idx)
 {
 	if (locale_idx >= ARRAYSIZE(g_mimo_2g_table)) {
 		WL_ERROR(("%s: mimo 2g index size out of range %d\n", __func__,
@@ -592,7 +592,7 @@ const locale_mimo_info_t *wlc_get_mimo_2
 	return g_mimo_2g_table[locale_idx];
 }
 
-const locale_mimo_info_t *wlc_get_mimo_5g(uint8 locale_idx)
+const locale_mimo_info_t *wlc_get_mimo_5g(u8 locale_idx)
 {
 	if (locale_idx >= ARRAYSIZE(g_mimo_5g_table)) {
 		WL_ERROR(("%s: mimo 5g index size out of range %d\n", __func__,
@@ -660,14 +660,14 @@ const char *wlc_channel_country_abbrev(w
 	return wlc_cm->country_abbrev;
 }
 
-uint8 wlc_channel_locale_flags(wlc_cm_info_t *wlc_cm)
+u8 wlc_channel_locale_flags(wlc_cm_info_t *wlc_cm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 
 	return wlc_cm->bandstate[wlc->band->bandunit].locale_flags;
 }
 
-uint8 wlc_channel_locale_flags_in_band(wlc_cm_info_t *wlc_cm, uint bandunit)
+u8 wlc_channel_locale_flags_in_band(wlc_cm_info_t *wlc_cm, uint bandunit)
 {
 	return wlc_cm->bandstate[bandunit].locale_flags;
 }
@@ -1077,7 +1077,7 @@ bool wlc_valid_40chanspec_in_band(wlc_cm
 static void
 wlc_channel_min_txpower_limits_with_local_constraint(wlc_cm_info_t *wlc_cm,
 						     struct txpwr_limits *txpwr,
-						     uint8
+						     u8
 						     local_constraint_qdbm)
 {
 	int j;
@@ -1163,7 +1163,7 @@ wlc_channel_min_txpower_limits_with_loca
 
 void
 wlc_channel_set_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chanspec,
-			 uint8 local_constraint_qdbm)
+			 u8 local_constraint_qdbm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	struct txpwr_limits txpwr;
@@ -1180,7 +1180,7 @@ wlc_channel_set_chanspec(wlc_cm_info_t *
 
 int
 wlc_channel_set_txpower_limit(wlc_cm_info_t *wlc_cm,
-			      uint8 local_constraint_qdbm)
+			      u8 local_constraint_qdbm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	struct txpwr_limits txpwr;
@@ -1359,7 +1359,7 @@ wlc_channel_reg_limits(wlc_cm_info_t *wl
 		maxpwr = MIN(maxpwr, conducted_max);
 
 		for (i = 0; i < WLC_NUM_RATES_CCK; i++)
-			txpwr->cck[i] = (uint8) maxpwr;
+			txpwr->cck[i] = (u8) maxpwr;
 	}
 
 	/* OFDM txpwr limits for 2.4G or 5G bands */
@@ -1379,7 +1379,7 @@ wlc_channel_reg_limits(wlc_cm_info_t *wl
 		maxpwr = MIN(maxpwr, txpwr->cck[0]);
 
 	for (i = 0; i < WLC_NUM_RATES_OFDM; i++) {
-		txpwr->ofdm[i] = (uint8) maxpwr;
+		txpwr->ofdm[i] = (u8) maxpwr;
 	}
 
 	for (i = 0; i < WLC_NUM_RATES_OFDM; i++) {
@@ -1390,7 +1390,7 @@ wlc_channel_reg_limits(wlc_cm_info_t *wl
 		 */
 		txpwr->ofdm_40_siso[i] = 0;
 
-		txpwr->ofdm_cdd[i] = (uint8) maxpwr;
+		txpwr->ofdm_cdd[i] = (u8) maxpwr;
 
 		txpwr->ofdm_40_cdd[i] = 0;
 	}
@@ -1429,8 +1429,8 @@ wlc_channel_reg_limits(wlc_cm_info_t *wl
 
 	/* Fill in the MCS 0-7 CDD rates */
 	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
-		txpwr->mcs_20_cdd[i] = (uint8) maxpwr20;
-		txpwr->mcs_40_cdd[i] = (uint8) maxpwr40;
+		txpwr->mcs_20_cdd[i] = (u8) maxpwr20;
+		txpwr->mcs_40_cdd[i] = (u8) maxpwr40;
 	}
 
 	/* These locales have SISO expressed in the table and override CDD later */
@@ -1445,8 +1445,8 @@ wlc_channel_reg_limits(wlc_cm_info_t *wl
 		}
 
 		for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
-			txpwr->mcs_20_siso[i] = (uint8) maxpwr20;
-			txpwr->mcs_40_siso[i] = (uint8) maxpwr40;
+			txpwr->mcs_20_siso[i] = (u8) maxpwr20;
+			txpwr->mcs_40_siso[i] = (u8) maxpwr40;
 		}
 	}
 
@@ -1458,12 +1458,12 @@ wlc_channel_reg_limits(wlc_cm_info_t *wl
 
 	/* Fill in the MCS 8-15 SDM rates */
 	for (i = 0; i < WLC_NUM_RATES_MCS_2_STREAM; i++) {
-		txpwr->mcs_20_mimo[i] = (uint8) maxpwr20;
-		txpwr->mcs_40_mimo[i] = (uint8) maxpwr40;
+		txpwr->mcs_20_mimo[i] = (u8) maxpwr20;
+		txpwr->mcs_40_mimo[i] = (u8) maxpwr40;
 	}
 
 	/* Fill in MCS32 */
-	txpwr->mcs32 = (uint8) maxpwr40;
+	txpwr->mcs32 = (u8) maxpwr40;
 
 	for (i = 0, j = 0; i < WLC_NUM_RATES_OFDM; i++, j++) {
 		if (txpwr->ofdm_40_cdd[i] == 0)
@@ -1532,7 +1532,7 @@ static bool
 wlc_valid_chanspec_ext(wlc_cm_info_t *wlc_cm, chanspec_t chspec, bool dualband)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
-	uint8 channel = CHSPEC_CHANNEL(chspec);
+	u8 channel = CHSPEC_CHANNEL(chspec);
 
 	/* check the chanspec */
 	if (wf_chspec_malformed(chspec)) {
@@ -1558,8 +1558,8 @@ wlc_valid_chanspec_ext(wlc_cm_info_t *wl
 	 * for NPHYS
 	 */
 	if (WLCISNPHY(wlc->band) || WLCISSSLPNPHY(wlc->band)) {
-		uint8 upper_sideband = 0, idx;
-		uint8 num_ch20_entries =
+		u8 upper_sideband = 0, idx;
+		u8 num_ch20_entries =
 		    sizeof(chan20_info) / sizeof(struct chan20_info);
 
 		if (!VALID_40CHANSPEC_IN_BAND(wlc, CHSPEC_WLCBANDUNIT(chspec)))
--- a/drivers/staging/brcm80211/sys/wlc_channel.h
+++ b/drivers/staging/brcm80211/sys/wlc_channel.h
@@ -55,13 +55,13 @@ struct wlc_info;
 /* locale channel and power info. */
 typedef struct {
 	uint32 valid_channels;
-	uint8 radar_channels;	/* List of radar sensitive channels */
-	uint8 restricted_channels;	/* List of channels used only if APs are detected */
+	u8 radar_channels;	/* List of radar sensitive channels */
+	u8 restricted_channels;	/* List of channels used only if APs are detected */
 	int8 maxpwr[WLC_MAXPWR_TBL_SIZE];	/* Max tx pwr in qdBm for each sub-band */
 	int8 pub_maxpwr[BAND_5G_PWR_LVLS];	/* Country IE advertised max tx pwr in dBm
 						 * per sub-band
 						 */
-	uint8 flags;
+	u8 flags;
 } locale_info_t;
 
 /* bits for locale_info flags */
@@ -84,7 +84,7 @@ typedef struct {
 typedef struct {
 	int8 maxpwr20[WLC_MAXPWR_MIMO_TBL_SIZE];	/* tx 20 MHz power limits, qdBm units */
 	int8 maxpwr40[WLC_MAXPWR_MIMO_TBL_SIZE];	/* tx 40 MHz power limits, qdBm units */
-	uint8 flags;
+	u8 flags;
 } locale_mimo_info_t;
 
 extern const chanvec_t chanvec_all_2G;
@@ -94,10 +94,10 @@ extern const chanvec_t chanvec_all_5G;
  * Country names and abbreviations with locale defined from ISO 3166
  */
 struct country_info {
-	const uint8 locale_2G;	/* 2.4G band locale */
-	const uint8 locale_5G;	/* 5G band locale */
-	const uint8 locale_mimo_2G;	/* 2.4G mimo info */
-	const uint8 locale_mimo_5G;	/* 5G mimo info */
+	const u8 locale_2G;	/* 2.4G band locale */
+	const u8 locale_5G;	/* 5G band locale */
+	const u8 locale_mimo_2G;	/* 2.4G mimo info */
+	const u8 locale_mimo_5G;	/* 5G mimo info */
 };
 
 typedef struct country_info country_info_t;
@@ -113,8 +113,8 @@ extern int wlc_set_countrycode_rev(wlc_c
 				   const char *ccode, int regrev);
 
 extern const char *wlc_channel_country_abbrev(wlc_cm_info_t *wlc_cm);
-extern uint8 wlc_channel_locale_flags(wlc_cm_info_t *wlc_cm);
-extern uint8 wlc_channel_locale_flags_in_band(wlc_cm_info_t *wlc_cm,
+extern u8 wlc_channel_locale_flags(wlc_cm_info_t *wlc_cm);
+extern u8 wlc_channel_locale_flags_in_band(wlc_cm_info_t *wlc_cm,
 					      uint bandunit);
 
 extern void wlc_quiet_channels_reset(wlc_cm_info_t *wlc_cm);
@@ -139,19 +139,19 @@ extern void wlc_channel_reg_limits(wlc_c
 				   struct txpwr_limits *txpwr);
 extern void wlc_channel_set_chanspec(wlc_cm_info_t *wlc_cm,
 				     chanspec_t chanspec,
-				     uint8 local_constraint_qdbm);
+				     u8 local_constraint_qdbm);
 extern int wlc_channel_set_txpower_limit(wlc_cm_info_t *wlc_cm,
-					 uint8 local_constraint_qdbm);
+					 u8 local_constraint_qdbm);
 
 extern const country_info_t *wlc_country_lookup(struct wlc_info *wlc,
 						const char *ccode);
 extern void wlc_locale_get_channels(const locale_info_t *locale,
 				    chanvec_t *valid_channels);
-extern const locale_info_t *wlc_get_locale_2g(uint8 locale_idx);
-extern const locale_info_t *wlc_get_locale_5g(uint8 locale_idx);
+extern const locale_info_t *wlc_get_locale_2g(u8 locale_idx);
+extern const locale_info_t *wlc_get_locale_5g(u8 locale_idx);
 extern bool wlc_japan(struct wlc_info *wlc);
 
-extern uint8 wlc_get_regclass(wlc_cm_info_t *wlc_cm, chanspec_t chanspec);
+extern u8 wlc_get_regclass(wlc_cm_info_t *wlc_cm, chanspec_t chanspec);
 extern bool wlc_channel_get_chanvec(struct wlc_info *wlc,
 				    const char *country_abbrev, int bandtype,
 				    chanvec_t *channels);
--- a/drivers/staging/brcm80211/sys/wlc_event.c
+++ b/drivers/staging/brcm80211/sys/wlc_event.c
@@ -47,7 +47,7 @@ struct wlc_eventq {
 	bool workpending;
 	struct wl_timer *timer;
 	wlc_eventq_cb_t cb;
-	uint8 event_inds_mask[ROUNDUP(WLC_E_LAST, NBBY) / NBBY];
+	u8 event_inds_mask[ROUNDUP(WLC_E_LAST, NBBY) / NBBY];
 };
 
 /*
--- a/drivers/staging/brcm80211/sys/wlc_event.h
+++ b/drivers/staging/brcm80211/sys/wlc_event.h
@@ -39,12 +39,12 @@ extern int wlc_eventq_test_ind(wlc_event
 extern int wlc_eventq_set_ind(wlc_eventq_t *eq, uint et, bool on);
 extern void wlc_eventq_flush(wlc_eventq_t *eq);
 extern void wlc_assign_event_msg(wlc_info_t *wlc, wl_event_msg_t *msg,
-				 const wlc_event_t *e, uint8 *data,
+				 const wlc_event_t *e, u8 *data,
 				 uint32 len);
 
 #ifdef MSGTRACE
 extern void wlc_event_sendup_trace(struct wlc_info *wlc, hndrte_dev_t *bus,
-				   uint8 *hdr, uint16 hdrlen, uint8 *buf,
+				   u8 *hdr, uint16 hdrlen, u8 *buf,
 				   uint16 buflen);
 #endif
 
--- a/drivers/staging/brcm80211/sys/wlc_key.h
+++ b/drivers/staging/brcm80211/sys/wlc_key.h
@@ -88,25 +88,25 @@ typedef struct wsec_iv {
 
 typedef struct wsec_key {
 	struct ether_addr ea;	/* per station */
-	uint8 idx;		/* key index in wsec_keys array */
-	uint8 id;		/* key ID [0-3] */
-	uint8 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
-	uint8 rcmta;		/* rcmta entry index, same as idx by default */
+	u8 idx;		/* key index in wsec_keys array */
+	u8 id;		/* key ID [0-3] */
+	u8 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
+	u8 rcmta;		/* rcmta entry index, same as idx by default */
 	uint16 flags;		/* misc flags */
-	uint8 algo_hw;		/* cache for hw register */
-	uint8 aes_mode;		/* cache for hw register */
+	u8 algo_hw;		/* cache for hw register */
+	u8 aes_mode;		/* cache for hw register */
 	int8 iv_len;		/* IV length */
 	int8 icv_len;		/* ICV length */
 	uint32 len;		/* key length..don't move this var */
 	/* data is 4byte aligned */
-	uint8 data[DOT11_MAX_KEY_SIZE];	/* key data */
+	u8 data[DOT11_MAX_KEY_SIZE];	/* key data */
 	wsec_iv_t rxiv[WLC_NUMRXIVS];	/* Rx IV (one per TID) */
 	wsec_iv_t txiv;		/* Tx IV */
 
 } wsec_key_t;
 
 typedef struct {
-	uint8 vec[ROUNDUP(WSEC_MAX_KEYS, NBBY) / NBBY];	/* bitvec of wsec_key indexes */
+	u8 vec[ROUNDUP(WSEC_MAX_KEYS, NBBY) / NBBY];	/* bitvec of wsec_key indexes */
 } wsec_key_vec_t;
 
 /* For use with wsec_key_t.flags */
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -172,7 +172,7 @@ const bcm_iovar_t wlc_iovars[] = {
 	{NULL, 0, 0, 0, 0}
 };
 
-const uint8 prio2fifo[NUMPRIO] = {
+const u8 prio2fifo[NUMPRIO] = {
 	TX_AC_BE_FIFO,		/* 0    BE      AC_BE   Best Effort */
 	TX_AC_BK_FIFO,		/* 1    BK      AC_BK   Background */
 	TX_AC_BK_FIFO,		/* 2    --      AC_BK   Background */
@@ -198,7 +198,7 @@ const uint8 prio2fifo[NUMPRIO] = {
 #define	_WLC_PREC_NC		14	/* NC - Network Control */
 
 /* 802.1D Priority to precedence queue mapping */
-const uint8 wlc_prio2prec_map[] = {
+const u8 wlc_prio2prec_map[] = {
 	_WLC_PREC_BE,		/* 0 BE - Best-effort */
 	_WLC_PREC_BK,		/* 1 BK - Background */
 	_WLC_PREC_NONE,		/* 2 None = - */
@@ -219,10 +219,10 @@ const uint8 wlc_prio2prec_map[] = {
 	(wlc)->fifo2prec_map[(fifo)]))
 
 /* TX FIFO number to WME/802.1E Access Category */
-const uint8 wme_fifo2ac[] = { AC_BK, AC_BE, AC_VI, AC_VO, AC_BE, AC_BE };
+const u8 wme_fifo2ac[] = { AC_BK, AC_BE, AC_VI, AC_VO, AC_BE, AC_BE };
 
 /* WME/802.1E Access Category to TX FIFO number */
-static const uint8 wme_ac2fifo[] = { 1, 0, 2, 3 };
+static const u8 wme_ac2fifo[] = { 1, 0, 2, 3 };
 
 static bool in_send_q = FALSE;
 
@@ -235,7 +235,7 @@ static const char *fifo_names[] = {
 const char *aci_names[] = { "AC_BE", "AC_BK", "AC_VI", "AC_VO" };
 #endif
 
-static const uint8 acbitmap2maxprio[] = {
+static const u8 acbitmap2maxprio[] = {
 	PRIO_8021D_BE, PRIO_8021D_BE, PRIO_8021D_BK, PRIO_8021D_BK,
 	PRIO_8021D_VI, PRIO_8021D_VI, PRIO_8021D_VI, PRIO_8021D_VI,
 	PRIO_8021D_VO, PRIO_8021D_VO, PRIO_8021D_VO, PRIO_8021D_VO,
@@ -269,7 +269,7 @@ static void wlc_watchdog_by_timer(void *
 static int wlc_set_rateset(wlc_info_t *wlc, wlc_rateset_t *rs_arg);
 static int wlc_iovar_rangecheck(wlc_info_t *wlc, uint32 val,
 				const bcm_iovar_t *vi);
-static uint8 wlc_local_constraint_qdbm(wlc_info_t *wlc);
+static u8 wlc_local_constraint_qdbm(wlc_info_t *wlc);
 
 /* send and receive */
 static wlc_txq_info_t *wlc_txq_alloc(wlc_info_t *wlc, osl_t *osh);
@@ -279,19 +279,19 @@ static void wlc_txflowcontrol_signal(wlc
 static void wlc_txflowcontrol_reset(wlc_info_t *wlc);
 static uint16 wlc_compute_airtime(wlc_info_t *wlc, ratespec_t rspec,
 				  uint length);
-static void wlc_compute_cck_plcp(ratespec_t rate, uint length, uint8 *plcp);
-static void wlc_compute_ofdm_plcp(ratespec_t rate, uint length, uint8 *plcp);
-static void wlc_compute_mimo_plcp(ratespec_t rate, uint length, uint8 *plcp);
+static void wlc_compute_cck_plcp(ratespec_t rate, uint length, u8 *plcp);
+static void wlc_compute_ofdm_plcp(ratespec_t rate, uint length, u8 *plcp);
+static void wlc_compute_mimo_plcp(ratespec_t rate, uint length, u8 *plcp);
 static uint16 wlc_compute_frame_dur(wlc_info_t *wlc, ratespec_t rate,
-				    uint8 preamble_type, uint next_frag_len);
+				    u8 preamble_type, uint next_frag_len);
 static void wlc_recvctl(wlc_info_t *wlc, osl_t *osh, d11rxhdr_t *rxh,
 			void *p);
 static uint wlc_calc_frame_len(wlc_info_t *wlc, ratespec_t rate,
-			       uint8 preamble_type, uint dur);
+			       u8 preamble_type, uint dur);
 static uint wlc_calc_ack_time(wlc_info_t *wlc, ratespec_t rate,
-			      uint8 preamble_type);
+			      u8 preamble_type);
 static uint wlc_calc_cts_time(wlc_info_t *wlc, ratespec_t rate,
-			      uint8 preamble_type);
+			      u8 preamble_type);
 /* interrupt, up/down, band */
 static void wlc_setband(wlc_info_t *wlc, uint bandunit);
 static chanspec_t wlc_init_chanspec(wlc_info_t *wlc);
@@ -307,10 +307,10 @@ static void wlc_radio_upd(wlc_info_t *wl
 
 /* scan, association, BSS */
 static uint wlc_calc_ba_time(wlc_info_t *wlc, ratespec_t rate,
-			     uint8 preamble_type);
-static void wlc_update_mimo_band_bwcap(wlc_info_t *wlc, uint8 bwcap);
+			     u8 preamble_type);
+static void wlc_update_mimo_band_bwcap(wlc_info_t *wlc, u8 bwcap);
 static void wlc_ht_update_sgi_rx(wlc_info_t *wlc, int val);
-void wlc_ht_mimops_cap_update(wlc_info_t *wlc, uint8 mimops_mode);
+void wlc_ht_mimops_cap_update(wlc_info_t *wlc, u8 mimops_mode);
 static void wlc_ht_update_ldpc(wlc_info_t *wlc, int8 val);
 static void wlc_war16165(wlc_info_t *wlc, bool tx);
 
@@ -342,15 +342,15 @@ void wlc_get_rcmta(wlc_info_t *wlc, int
 	W_REG(osh, &regs->objaddr, (OBJADDR_RCMTA_SEL | (idx * 2)));
 	(void)R_REG(osh, &regs->objaddr);
 	v32 = R_REG(osh, &regs->objdata);
-	addr->octet[0] = (uint8) v32;
-	addr->octet[1] = (uint8) (v32 >> 8);
-	addr->octet[2] = (uint8) (v32 >> 16);
-	addr->octet[3] = (uint8) (v32 >> 24);
+	addr->octet[0] = (u8) v32;
+	addr->octet[1] = (u8) (v32 >> 8);
+	addr->octet[2] = (u8) (v32 >> 16);
+	addr->octet[3] = (u8) (v32 >> 24);
 	W_REG(osh, &regs->objaddr, (OBJADDR_RCMTA_SEL | ((idx * 2) + 1)));
 	(void)R_REG(osh, &regs->objaddr);
 	v32 = R_REG(osh, (volatile uint16 *)(uintptr) & regs->objdata);
-	addr->octet[4] = (uint8) v32;
-	addr->octet[5] = (uint8) (v32 >> 8);
+	addr->octet[4] = (u8) v32;
+	addr->octet[5] = (u8) (v32 >> 8);
 }
 #endif				/* defined(BCMDBG) */
 
@@ -490,7 +490,7 @@ void BCMINITFN(wlc_init) (wlc_info_t *wl
 	/* update beacon listen interval */
 	wlc_bcn_li_upd(wlc);
 	wlc->bcn_wait_prd =
-	    (uint8) (wlc_bmac_read_shm(wlc->hw, M_NOSLPZNATDTIM) >> 10);
+	    (u8) (wlc_bmac_read_shm(wlc->hw, M_NOSLPZNATDTIM) >> 10);
 	ASSERT(wlc->bcn_wait_prd > 0);
 
 	/* the world is new again, so is our reported rate */
@@ -787,9 +787,9 @@ void wlc_switch_shortslot(wlc_info_t *wl
 	wlc_bmac_set_shortslot(wlc->hw, shortslot);
 }
 
-static uint8 wlc_local_constraint_qdbm(wlc_info_t *wlc)
+static u8 wlc_local_constraint_qdbm(wlc_info_t *wlc)
 {
-	uint8 local;
+	u8 local;
 	int16 local_max;
 
 	local = WLC_TXPWR_MAX;
@@ -805,7 +805,7 @@ static uint8 wlc_local_constraint_qdbm(w
 		    (wlc->txpwr_local_max -
 		     wlc->txpwr_local_constraint) * WLC_TXPWR_DB_FACTOR;
 		if (local_max > 0 && local_max < WLC_TXPWR_MAX)
-			return (uint8) local_max;
+			return (u8) local_max;
 		if (local_max < 0)
 			return 0;
 	}
@@ -932,7 +932,7 @@ static int wlc_get_current_txpwr(wlc_inf
 	 */
 	wlc_phy_txpower_get(wlc->band->pi, &qdbm, &override);
 	for (r = 0; r < WL_TX_POWER_RATES; r++) {
-		power.user_limit[r] = (uint8) qdbm;
+		power.user_limit[r] = (u8) qdbm;
 	}
 
 	power.local_max = wlc->txpwr_local_max * WLC_TXPWR_DB_FACTOR;
@@ -1182,7 +1182,7 @@ void wlc_protection_upd(wlc_info_t *wlc,
 		wlc->protection->g_override = (int8) val;
 		break;
 	case WLC_PROT_G_USER:
-		wlc->protection->gmode_user = (uint8) val;
+		wlc->protection->gmode_user = (u8) val;
 		break;
 	case WLC_PROT_OVERLAP:
 		wlc->protection->overlap = (int8) val;
@@ -1673,7 +1673,7 @@ void BCMATTACHFN(wlc_info_init) (wlc_inf
 	/* init the 4 static WEP default keys */
 	for (i = 0; i < WSEC_MAX_DEFAULT_KEYS; i++) {
 		wlc->wsec_keys[i] = wlc->wsec_def_keys[i];
-		wlc->wsec_keys[i]->idx = (uint8) i;
+		wlc->wsec_keys[i]->idx = (u8) i;
 	}
 
 	wlc->_regulatory_domain = FALSE;	/* 802.11d */
@@ -2197,7 +2197,7 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 
 	wlc->pub->boardrev = (uint16) revinfo.boardrev;
 	wlc->pub->corerev = revinfo.corerev;
-	wlc->pub->sromrev = (uint8) revinfo.sromrev;
+	wlc->pub->sromrev = (u8) revinfo.sromrev;
 	wlc->pub->sih->chiprev = revinfo.chiprev;
 	wlc->pub->sih->chip = revinfo.chip;
 	wlc->pub->sih->chippkg = revinfo.chippkg;
@@ -2225,7 +2225,7 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 		bandunit = revinfo.band[idx].bandunit;
 		bandtype = revinfo.band[idx].bandtype;
 		wlc->bandstate[bandunit]->radiorev =
-		    (uint8) revinfo.band[idx].radiorev;
+		    (u8) revinfo.band[idx].radiorev;
 		wlc->bandstate[bandunit]->phytype =
 		    (uint16) revinfo.band[idx].phytype;
 		wlc->bandstate[bandunit]->phyrev =
@@ -2956,7 +2956,7 @@ uint BCMUNINITFN(wlc_down) (wlc_info_t *
 }
 
 /* Set the current gmode configuration */
-int wlc_set_gmode(wlc_info_t *wlc, uint8 gmode, bool config)
+int wlc_set_gmode(wlc_info_t *wlc, u8 gmode, bool config)
 {
 	int ret = 0;
 	uint i;
@@ -3245,7 +3245,7 @@ int wlc_get(wlc_info_t *wlc, int cmd, in
 
 static void wlc_ofdm_rateset_war(wlc_info_t *wlc)
 {
-	uint8 r;
+	u8 r;
 	bool war = FALSE;
 
 	if (wlc->cfg->associated)
@@ -3430,7 +3430,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			break;
 		}
 
-		*pval = wlc_bmac_mhf_get(wlc->hw, (uint8) val, WLC_BAND_AUTO);
+		*pval = wlc_bmac_mhf_get(wlc->hw, (u8) val, WLC_BAND_AUTO);
 		break;
 
 	case WLC_SET_UCFLAGS:
@@ -3455,7 +3455,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			break;
 		}
 
-		wlc_mhf(wlc, (uint8) i, 0xffff, (uint16) (val >> NBITS(uint16)),
+		wlc_mhf(wlc, (u8) i, 0xffff, (uint16) (val >> NBITS(uint16)),
 			WLC_BAND_AUTO);
 		break;
 
@@ -3598,7 +3598,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		break;
 
 	case WLC_GET_ANTDIV:{
-			uint8 phy_antdiv;
+			u8 phy_antdiv;
 
 			/* return configured value if core is down */
 			if (!wlc->pub->up) {
@@ -3624,8 +3624,8 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		if (val == -1)
 			val = ANT_RX_DIV_DEF;
 
-		wlc->stf->ant_rx_ovr = (uint8) val;
-		wlc_phy_ant_rxdiv_set(wlc->band->pi, (uint8) val);
+		wlc->stf->ant_rx_ovr = (u8) val;
+		wlc_phy_ant_rxdiv_set(wlc->band->pi, (u8) val);
 		break;
 
 	case WLC_GET_RX_ANT:{	/* get latest used rx antenna */
@@ -3844,7 +3844,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			key = WSEC_KEY(wlc, val);
 			if ((val >= 0) && (val < WLC_MAX_WSEC_KEYS(wlc)) &&
 				(key != NULL)) {
-				uint8 seq[DOT11_WPA_KEY_RSC_LEN];
+				u8 seq[DOT11_WPA_KEY_RSC_LEN];
 				uint16 lo;
 				uint32 hi;
 				/* group keys in WPA-NONE (IBSS only, AES and TKIP) use a global TXIV */
@@ -3977,7 +3977,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		/* range [1, 0xff] */
 		if (val >= DOT11_MIN_DTIM_PERIOD
 		    && val <= DOT11_MAX_DTIM_PERIOD) {
-			wlc->default_bss->dtim_period = (uint8) val;
+			wlc->default_bss->dtim_period = (u8) val;
 		} else
 			bcmerror = BCME_RANGE;
 		break;
@@ -3989,7 +3989,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 
 	case WLC_SET_PM:
 		if ((val >= PM_OFF) && (val <= PM_MAX)) {
-			wlc->PM = (uint8) val;
+			wlc->PM = (u8) val;
 			if (wlc->pub->up) {
 			}
 			/* Change watchdog driver to align watchdog with tbtt if possible */
@@ -4188,7 +4188,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 
 	case WLC_SET_GMODE:
 		if (!wlc->pub->associated)
-			bcmerror = wlc_set_gmode(wlc, (uint8) val, TRUE);
+			bcmerror = wlc_set_gmode(wlc, (u8) val, TRUE);
 		else {
 			bcmerror = BCME_ASSOCIATED;
 			break;
@@ -4802,12 +4802,12 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 		   not internal or test.
 		 */
 	case IOV_SVAL(IOV_QTXPOWER):{
-			uint8 qdbm;
+			u8 qdbm;
 			bool override;
 
 			/* Remove override bit and clip to max qdbm value */
 			qdbm =
-			    (uint8) MIN((int_val & ~WL_TXPWR_OVERRIDE), 0xff);
+			    (u8) MIN((int_val & ~WL_TXPWR_OVERRIDE), 0xff);
 			/* Extract override setting */
 			override = (int_val & WL_TXPWR_OVERRIDE) ? TRUE : FALSE;
 			err =
@@ -4830,7 +4830,7 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 		break;
 
 	case IOV_SVAL(IOV_BCN_LI_BCN):
-		wlc->bcn_li_bcn = (uint8) int_val;
+		wlc->bcn_li_bcn = (u8) int_val;
 		if (wlc->pub->up)
 			wlc_bcn_li_upd(wlc);
 		break;
@@ -5060,12 +5060,12 @@ void wlc_print_txdesc(d11txh_t *txh)
 	uint16 ptcw_1_FbrRts = ltoh16(txh->PhyTxControlWord_1_FbrRts);
 	uint16 mainrates = ltoh16(txh->MainRates);
 	uint16 xtraft = ltoh16(txh->XtraFrameTypes);
-	uint8 *iv = txh->IV;
-	uint8 *ra = txh->TxFrameRA;
+	u8 *iv = txh->IV;
+	u8 *ra = txh->TxFrameRA;
 	uint16 tfestfb = ltoh16(txh->TxFesTimeFallback);
-	uint8 *rtspfb = txh->RTSPLCPFallback;
+	u8 *rtspfb = txh->RTSPLCPFallback;
 	uint16 rtsdfb = ltoh16(txh->RTSDurFallback);
-	uint8 *fragpfb = txh->FragPLCPFallback;
+	u8 *fragpfb = txh->FragPLCPFallback;
 	uint16 fragdfb = ltoh16(txh->FragDurFallback);
 	uint16 mmodelen = ltoh16(txh->MModeLen);
 	uint16 mmodefbrlen = ltoh16(txh->MModeFbrLen);
@@ -5076,7 +5076,7 @@ void wlc_print_txdesc(d11txh_t *txh)
 	uint16 mabyte_f = ltoh16(txh->MaxABytes_FBR);
 	uint16 mmbyte = ltoh16(txh->MinMBytes);
 
-	uint8 *rtsph = txh->RTSPhyHeader;
+	u8 *rtsph = txh->RTSPhyHeader;
 	struct dot11_rts_frame rts = txh->rts_frame;
 	char hexbuf[256];
 
@@ -5124,7 +5124,7 @@ void wlc_print_txdesc(d11txh_t *txh)
 
 	bcm_format_hex(hexbuf, rtsph, sizeof(txh->RTSPhyHeader));
 	printf("RTS PLCP: %s ", hexbuf);
-	bcm_format_hex(hexbuf, (uint8 *) &rts, sizeof(txh->rts_frame));
+	bcm_format_hex(hexbuf, (u8 *) &rts, sizeof(txh->rts_frame));
 	printf("RTS Frame: %s", hexbuf);
 	printf("\n");
 
@@ -5197,7 +5197,7 @@ int wlc_format_ssid(char *buf, const uch
 }
 #endif				/* defined(BCMDBG) */
 
-uint16 wlc_rate_shm_offset(wlc_info_t *wlc, uint8 rate)
+uint16 wlc_rate_shm_offset(wlc_info_t *wlc, u8 rate)
 {
 	return wlc_bmac_rate_shm_offset(wlc->hw, rate);
 }
@@ -5334,7 +5334,7 @@ void BCMFASTPATH wlc_txq_enq(void *ctx,
 bool BCMFASTPATH
 wlc_sendpkt_mac80211(wlc_info_t *wlc, void *sdu, struct ieee80211_hw *hw)
 {
-	uint8 prio;
+	u8 prio;
 	uint fifo;
 	void *pkt;
 	struct scb *scb = &global_scb;
@@ -5548,7 +5548,7 @@ wlc_compute_airtime(wlc_info_t *wlc, rat
 }
 
 void BCMFASTPATH
-wlc_compute_plcp(wlc_info_t *wlc, ratespec_t rspec, uint length, uint8 *plcp)
+wlc_compute_plcp(wlc_info_t *wlc, ratespec_t rspec, uint length, u8 *plcp)
 {
 	if (IS_MCS(rspec)) {
 		wlc_compute_mimo_plcp(rspec, length, plcp);
@@ -5561,9 +5561,9 @@ wlc_compute_plcp(wlc_info_t *wlc, ratesp
 }
 
 /* Rate: 802.11 rate code, length: PSDU length in octets */
-static void wlc_compute_mimo_plcp(ratespec_t rspec, uint length, uint8 *plcp)
+static void wlc_compute_mimo_plcp(ratespec_t rspec, uint length, u8 *plcp)
 {
-	uint8 mcs = (uint8) (rspec & RSPEC_RATE_MASK);
+	u8 mcs = (u8) (rspec & RSPEC_RATE_MASK);
 	ASSERT(IS_MCS(rspec));
 	plcp[0] = mcs;
 	if (RSPEC_IS40MHZ(rspec) || (mcs == 32))
@@ -5577,9 +5577,9 @@ static void wlc_compute_mimo_plcp(ratesp
 
 /* Rate: 802.11 rate code, length: PSDU length in octets */
 static void BCMFASTPATH
-wlc_compute_ofdm_plcp(ratespec_t rspec, uint32 length, uint8 *plcp)
+wlc_compute_ofdm_plcp(ratespec_t rspec, uint32 length, u8 *plcp)
 {
-	uint8 rate_signal;
+	u8 rate_signal;
 	uint32 tmp = 0;
 	int rate = RSPEC2RATE(rspec);
 
@@ -5607,10 +5607,10 @@ wlc_compute_ofdm_plcp(ratespec_t rspec,
  * Broken out for PRQ.
  */
 
-static void wlc_cck_plcp_set(int rate_500, uint length, uint8 *plcp)
+static void wlc_cck_plcp_set(int rate_500, uint length, u8 *plcp)
 {
 	uint16 usec = 0;
-	uint8 le = 0;
+	u8 le = 0;
 
 	switch (rate_500) {
 	case WLC_RATE_1M:
@@ -5642,7 +5642,7 @@ static void wlc_cck_plcp_set(int rate_50
 	/* PLCP signal byte */
 	plcp[0] = rate_500 * 5;	/* r (500kbps) * 5 == r (100kbps) */
 	/* PLCP service byte */
-	plcp[1] = (uint8) (le | D11B_PLCP_SIGNAL_LOCKED);
+	plcp[1] = (u8) (le | D11B_PLCP_SIGNAL_LOCKED);
 	/* PLCP length uint16, little endian */
 	plcp[2] = usec & 0xff;
 	plcp[3] = (usec >> 8) & 0xff;
@@ -5652,7 +5652,7 @@ static void wlc_cck_plcp_set(int rate_50
 }
 
 /* Rate: 802.11 rate code, length: PSDU length in octets */
-static void wlc_compute_cck_plcp(ratespec_t rspec, uint length, uint8 *plcp)
+static void wlc_compute_cck_plcp(ratespec_t rspec, uint length, u8 *plcp)
 {
 	int rate = RSPEC2RATE(rspec);
 
@@ -5672,7 +5672,7 @@ static void wlc_compute_cck_plcp(ratespe
  * preamble_type	use short/GF or long/MM PLCP header
  */
 static uint16 BCMFASTPATH
-wlc_compute_frame_dur(wlc_info_t *wlc, ratespec_t rate, uint8 preamble_type,
+wlc_compute_frame_dur(wlc_info_t *wlc, ratespec_t rate, u8 preamble_type,
 		      uint next_frag_len)
 {
 	uint16 dur, sifs;
@@ -5707,8 +5707,8 @@ wlc_compute_frame_dur(wlc_info_t *wlc, r
  */
 uint16 BCMFASTPATH
 wlc_compute_rtscts_dur(wlc_info_t *wlc, bool cts_only, ratespec_t rts_rate,
-		       ratespec_t frame_rate, uint8 rts_preamble_type,
-		       uint8 frame_preamble_type, uint frame_len, bool ba)
+		       ratespec_t frame_rate, u8 rts_preamble_type,
+		       u8 frame_preamble_type, uint frame_len, bool ba)
 {
 	uint16 dur, sifs;
 
@@ -5885,7 +5885,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 {
 	struct dot11_header *h;
 	d11txh_t *txh;
-	uint8 *plcp, plcp_fallback[D11_PHY_HDR_LEN];
+	u8 *plcp, plcp_fallback[D11_PHY_HDR_LEN];
 	osl_t *osh;
 	int len, phylen, rts_phylen;
 	uint16 fc, type, frameid, mch, phyctl, xfts, mainrates;
@@ -5896,9 +5896,9 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 	bool use_cts = FALSE;
 	bool use_rifs = FALSE;
 	bool short_preamble[2] = { FALSE, FALSE };
-	uint8 preamble_type[2] = { WLC_LONG_PREAMBLE, WLC_LONG_PREAMBLE };
-	uint8 rts_preamble_type[2] = { WLC_LONG_PREAMBLE, WLC_LONG_PREAMBLE };
-	uint8 *rts_plcp, rts_plcp_fallback[D11_PHY_HDR_LEN];
+	u8 preamble_type[2] = { WLC_LONG_PREAMBLE, WLC_LONG_PREAMBLE };
+	u8 rts_preamble_type[2] = { WLC_LONG_PREAMBLE, WLC_LONG_PREAMBLE };
+	u8 *rts_plcp, rts_plcp_fallback[D11_PHY_HDR_LEN];
 	struct dot11_rts_frame *rts = NULL;
 	bool qos;
 	uint ac;
@@ -5907,8 +5907,8 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 	uint16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
 #ifdef WLANTSEL
 #define ANTCFG_NONE 0xFF
-	uint8 antcfg = ANTCFG_NONE;
-	uint8 fbantcfg = ANTCFG_NONE;
+	u8 antcfg = ANTCFG_NONE;
+	u8 fbantcfg = ANTCFG_NONE;
 #endif
 	uint phyctl1_stf = 0;
 	uint16 durid = 0;
@@ -5917,7 +5917,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 	struct ieee80211_tx_info *tx_info;
 	bool is_mcs[2];
 	uint16 mimo_txbw;
-	uint8 mimo_preamble_type;
+	u8 mimo_preamble_type;
 
 	frameid = 0;
 
@@ -6072,7 +6072,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 				/* For SISO MCS use STBC if possible */
 				if (IS_MCS(rspec[k])
 				    && WLC_STF_SS_STBC_TX(wlc, scb)) {
-					uint8 stc;
+					u8 stc;
 
 					ASSERT(WLC_STBC_CAP_PHY(wlc));
 					stc = 1;	/* Nss for single stream is always 1 */
@@ -6819,13 +6819,13 @@ wlc_dotxstatus(wlc_info_t *wlc, tx_statu
 		goto fatal;
 
 	tx_info = IEEE80211_SKB_CB(p);
-	h = (struct dot11_header *)((uint8 *) (txh + 1) + D11_PHY_HDR_LEN);
+	h = (struct dot11_header *)((u8 *) (txh + 1) + D11_PHY_HDR_LEN);
 	fc = ltoh16(h->fc);
 
 	scb = (struct scb *)tx_info->control.sta->drv_priv;
 
 	if (N_ENAB(wlc->pub)) {
-		uint8 *plcp = (uint8 *) (txh + 1);
+		u8 *plcp = (u8 *) (txh + 1);
 		if (PLCP3_ISSGI(plcp[3]))
 			WLCNTINCR(wlc->pub->_cnt->txmpdu_sgi);
 		if (PLCP3_ISSTBC(plcp[3]))
@@ -7355,7 +7355,7 @@ wlc_calc_lsig_len(wlc_info_t *wlc, rates
 
 /* calculate frame duration of a given rate and length, return time in usec unit */
 uint BCMFASTPATH
-wlc_calc_frame_time(wlc_info_t *wlc, ratespec_t ratespec, uint8 preamble_type,
+wlc_calc_frame_time(wlc_info_t *wlc, ratespec_t ratespec, u8 preamble_type,
 		    uint mac_len)
 {
 	uint nsyms, dur = 0, Ndps, kNdps;
@@ -7425,7 +7425,7 @@ wlc_calc_frame_time(wlc_info_t *wlc, rat
 
 /* The opposite of wlc_calc_frame_time */
 static uint
-wlc_calc_frame_len(wlc_info_t *wlc, ratespec_t ratespec, uint8 preamble_type,
+wlc_calc_frame_len(wlc_info_t *wlc, ratespec_t ratespec, u8 preamble_type,
 		   uint dur)
 {
 	uint nsyms, mac_len, Ndps, kNdps;
@@ -7471,7 +7471,7 @@ wlc_calc_frame_len(wlc_info_t *wlc, rate
 }
 
 static uint
-wlc_calc_ba_time(wlc_info_t *wlc, ratespec_t rspec, uint8 preamble_type)
+wlc_calc_ba_time(wlc_info_t *wlc, ratespec_t rspec, u8 preamble_type)
 {
 	WL_TRACE(("wl%d: wlc_calc_ba_time: rspec 0x%x, preamble_type %d\n",
 		  wlc->pub->unit, rspec, preamble_type));
@@ -7488,7 +7488,7 @@ wlc_calc_ba_time(wlc_info_t *wlc, ratesp
 }
 
 static uint BCMFASTPATH
-wlc_calc_ack_time(wlc_info_t *wlc, ratespec_t rspec, uint8 preamble_type)
+wlc_calc_ack_time(wlc_info_t *wlc, ratespec_t rspec, u8 preamble_type)
 {
 	uint dur = 0;
 
@@ -7508,7 +7508,7 @@ wlc_calc_ack_time(wlc_info_t *wlc, rates
 }
 
 static uint
-wlc_calc_cts_time(wlc_info_t *wlc, ratespec_t rspec, uint8 preamble_type)
+wlc_calc_cts_time(wlc_info_t *wlc, ratespec_t rspec, u8 preamble_type)
 {
 	WL_TRACE(("wl%d: wlc_calc_cts_time: ratespec 0x%x, preamble_type %d\n",
 		  wlc->pub->unit, rspec, preamble_type));
@@ -7518,11 +7518,11 @@ wlc_calc_cts_time(wlc_info_t *wlc, rates
 /* derive wlc->band->basic_rate[] table from 'rateset' */
 void wlc_rate_lookup_init(wlc_info_t *wlc, wlc_rateset_t *rateset)
 {
-	uint8 rate;
-	uint8 mandatory;
-	uint8 cck_basic = 0;
-	uint8 ofdm_basic = 0;
-	uint8 *br = wlc->band->basic_rate;
+	u8 rate;
+	u8 mandatory;
+	u8 cck_basic = 0;
+	u8 ofdm_basic = 0;
+	u8 *br = wlc->band->basic_rate;
 	uint i;
 
 	/* incoming rates are in 500kbps units as in 802.11 Supported Rates */
@@ -7605,10 +7605,10 @@ void wlc_rate_lookup_init(wlc_info_t *wl
 	}
 }
 
-static void wlc_write_rate_shm(wlc_info_t *wlc, uint8 rate, uint8 basic_rate)
+static void wlc_write_rate_shm(wlc_info_t *wlc, u8 rate, u8 basic_rate)
 {
-	uint8 phy_rate, index;
-	uint8 basic_phy_rate, basic_index;
+	u8 phy_rate, index;
+	u8 basic_phy_rate, basic_index;
 	uint16 dir_table, basic_table;
 	uint16 basic_ptr;
 
@@ -7659,7 +7659,7 @@ void wlc_set_ratetable(wlc_info_t *wlc)
 {
 	const wlc_rateset_t *rs_dflt;
 	wlc_rateset_t rs;
-	uint8 rate, basic_rate;
+	u8 rate, basic_rate;
 	uint i;
 
 	rs_dflt = wlc_rateset_get_hwrs(wlc);
@@ -7724,7 +7724,7 @@ bool wlc_valid_rate(wlc_info_t *wlc, rat
 	return FALSE;
 }
 
-static void wlc_update_mimo_band_bwcap(wlc_info_t *wlc, uint8 bwcap)
+static void wlc_update_mimo_band_bwcap(wlc_info_t *wlc, u8 bwcap)
 {
 	uint i;
 	wlcband_t *band;
@@ -7755,9 +7755,9 @@ void wlc_mod_prb_rsp_rate_table(wlc_info
 {
 	const wlc_rateset_t *rs_dflt;
 	wlc_rateset_t rs;
-	uint8 rate;
+	u8 rate;
 	uint16 entry_ptr;
-	uint8 plcp[D11_PHY_HDR_LEN];
+	u8 plcp[D11_PHY_HDR_LEN];
 	uint16 dur, sifs;
 	uint i;
 
@@ -7869,7 +7869,7 @@ wlc_bcn_prb_template(wlc_info_t *wlc, ui
 		/* fill in PLCP */
 		wlc_compute_plcp(wlc, bcn_rspec,
 				 (DOT11_MAC_HDR_LEN + body_len + DOT11_FCS_LEN),
-				 (uint8 *) plcp);
+				 (u8 *) plcp);
 
 	}
 	/* "Regular" and 16 MBSS but not for 4 MBSS */
@@ -7976,9 +7976,9 @@ void wlc_update_beacon(wlc_info_t *wlc)
 /* Write ssid into shared memory */
 void wlc_shm_ssid_upd(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
 {
-	uint8 *ssidptr = cfg->SSID;
+	u8 *ssidptr = cfg->SSID;
 	uint16 base = M_SSID;
-	uint8 ssidbuf[DOT11_MAX_SSID_LEN];
+	u8 ssidbuf[DOT11_MAX_SSID_LEN];
 
 	/* padding the ssid with zero and copy it into shm */
 	bzero(ssidbuf, DOT11_MAX_SSID_LEN);
@@ -8058,7 +8058,7 @@ int wlc_prep_pdu(wlc_info_t *wlc, void *
 	ASSERT(pdu);
 	txh = (d11txh_t *) PKTDATA(pdu);
 	ASSERT(txh);
-	h = (struct dot11_header *)((uint8 *) (txh + 1) + D11_PHY_HDR_LEN);
+	h = (struct dot11_header *)((u8 *) (txh + 1) + D11_PHY_HDR_LEN);
 	ASSERT(h);
 	fc = ltoh16(h->fc);
 
@@ -8211,8 +8211,8 @@ wlc_uint64_sub(uint32 *a_high, uint32 *a
 static ratespec_t
 mac80211_wlc_set_nrate(wlc_info_t *wlc, wlcband_t *cur_band, uint32 int_val)
 {
-	uint8 stf = (int_val & NRATE_STF_MASK) >> NRATE_STF_SHIFT;
-	uint8 rate = int_val & NRATE_RATE_MASK;
+	u8 stf = (int_val & NRATE_STF_MASK) >> NRATE_STF_SHIFT;
+	u8 rate = int_val & NRATE_RATE_MASK;
 	ratespec_t rspec;
 	bool ismcs = ((int_val & NRATE_MCS_INUSE) == NRATE_MCS_INUSE);
 	bool issgi = ((int_val & NRATE_SGI_MASK) >> NRATE_SGI_SHIFT);
@@ -8296,7 +8296,7 @@ mac80211_wlc_set_nrate(wlc_info_t *wlc,
 		rspec |= RSPEC_MIMORATE;
 		/* For STBC populate the STC field of the ratespec */
 		if (stf == PHY_TXC1_MODE_STBC) {
-			uint8 stc;
+			u8 stc;
 			stc = 1;	/* Nss for single stream is always 1 */
 			rspec |= (stc << RSPEC_STC_SHIFT);
 		}
@@ -8350,13 +8350,13 @@ wlc_duty_cycle_set(wlc_info_t *wlc, int
 }
 
 void
-wlc_pktengtx(wlc_info_t *wlc, wl_pkteng_t *pkteng, uint8 rate,
+wlc_pktengtx(wlc_info_t *wlc, wl_pkteng_t *pkteng, u8 rate,
 	     struct ether_addr *sa, uint32 wait_delay)
 {
 	bool suspend;
 	uint16 val = M_PKTENG_MODE_TX;
 	volatile uint16 frame_cnt_check;
-	uint8 counter = 0;
+	u8 counter = 0;
 
 	wlc_bmac_set_deaf(wlc->hw, TRUE);
 
@@ -8484,12 +8484,12 @@ void wlc_corereset(wlc_info_t *wlc, uint
 	wlc_bmac_corereset(wlc->hw, flags);
 }
 
-void wlc_mhf(wlc_info_t *wlc, uint8 idx, uint16 mask, uint16 val, int bands)
+void wlc_mhf(wlc_info_t *wlc, u8 idx, uint16 mask, uint16 val, int bands)
 {
 	wlc_bmac_mhf(wlc->hw, idx, mask, val, bands);
 }
 
-uint16 wlc_mhf_get(wlc_info_t *wlc, uint8 idx, int bands)
+uint16 wlc_mhf_get(wlc_info_t *wlc, u8 idx, int bands)
 {
 	return wlc_bmac_mhf_get(wlc->hw, idx, bands);
 }
@@ -8558,7 +8558,7 @@ void wlc_reset_bmac_done(wlc_info_t *wlc
 #endif
 }
 
-void wlc_ht_mimops_cap_update(wlc_info_t *wlc, uint8 mimops_mode)
+void wlc_ht_mimops_cap_update(wlc_info_t *wlc, u8 mimops_mode)
 {
 	wlc->ht_cap.cap &= ~HT_CAP_MIMO_PS_MASK;
 	wlc->ht_cap.cap |= (mimops_mode << HT_CAP_MIMO_PS_SHIFT);
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.h
@@ -51,7 +51,7 @@
 #define	WLC_PROT_N_PAM_OVR	15	/* n preamble override */
 #define	WLC_PROT_N_OBSS		16	/* non-HT OBSS present */
 
-#define WLC_BITSCNT(x)	bcm_bitcount((uint8 *)&(x), sizeof(uint8))
+#define WLC_BITSCNT(x)	bcm_bitcount((u8 *)&(x), sizeof(u8))
 
 /* Maximum wait time for a MAC suspend */
 #define	WLC_MAX_MAC_SUSPEND	83000	/* uS: 83mS is max packet time (64KB ampdu @ 6Mbps) */
@@ -127,7 +127,7 @@ typedef struct wlc_bss_list {
 #define DATA_BLOCK_TX_SUPR	(1 << 4)
 
 /* 802.1D Priority to TX FIFO number for wme */
-extern const uint8 prio2fifo[];
+extern const u8 prio2fifo[];
 
 /* Ucode MCTL_WAKE override bits */
 #define WLC_WAKE_OVERRIDE_CLKCTL	0x01
@@ -231,7 +231,7 @@ extern const uint8 prio2fifo[];
 typedef struct wlc_protection {
 	bool _g;		/* use g spec protection, driver internal */
 	int8 g_override;	/* override for use of g spec protection */
-	uint8 gmode_user;	/* user config gmode, operating band->gmode is different */
+	u8 gmode_user;	/* user config gmode, operating band->gmode is different */
 	int8 overlap;		/* Overlap BSS/IBSS protection for both 11g and 11n */
 	int8 nmode_user;	/* user config nmode, operating pub->nmode is different */
 	int8 n_cfg;		/* use OFDM protection on MIMO frames */
@@ -257,28 +257,28 @@ typedef struct wlc_protection {
 
 /* anything affects the single/dual streams/antenna operation */
 typedef struct wlc_stf {
-	uint8 hw_txchain;	/* HW txchain bitmap cfg */
-	uint8 txchain;		/* txchain bitmap being used */
-	uint8 txstreams;	/* number of txchains being used */
-
-	uint8 hw_rxchain;	/* HW rxchain bitmap cfg */
-	uint8 rxchain;		/* rxchain bitmap being used */
-	uint8 rxstreams;	/* number of rxchains being used */
+	u8 hw_txchain;	/* HW txchain bitmap cfg */
+	u8 txchain;		/* txchain bitmap being used */
+	u8 txstreams;	/* number of txchains being used */
+
+	u8 hw_rxchain;	/* HW rxchain bitmap cfg */
+	u8 rxchain;		/* rxchain bitmap being used */
+	u8 rxstreams;	/* number of rxchains being used */
 
-	uint8 ant_rx_ovr;	/* rx antenna override */
+	u8 ant_rx_ovr;	/* rx antenna override */
 	int8 txant;		/* userTx antenna setting */
 	uint16 phytxant;	/* phyTx antenna setting in txheader */
 
-	uint8 ss_opmode;	/* singlestream Operational mode, 0:siso; 1:cdd */
+	u8 ss_opmode;	/* singlestream Operational mode, 0:siso; 1:cdd */
 	bool ss_algosel_auto;	/* if TRUE, use wlc->stf->ss_algo_channel; */
 	/* else use wlc->band->stf->ss_mode_band; */
 	uint16 ss_algo_channel;	/* ss based on per-channel algo: 0: SISO, 1: CDD 2: STBC */
-	uint8 no_cddstbc;	/* stf override, 1: no CDD (or STBC) allowed */
+	u8 no_cddstbc;	/* stf override, 1: no CDD (or STBC) allowed */
 
-	uint8 rxchain_restore_delay;	/* delay time to restore default rxchain */
+	u8 rxchain_restore_delay;	/* delay time to restore default rxchain */
 
 	int8 ldpc;		/* AUTO/ON/OFF ldpc cap supported */
-	uint8 txcore[MAX_STREAMS_SUPPORTED + 1];	/* bitmap of selected core for each Nsts */
+	u8 txcore[MAX_STREAMS_SUPPORTED + 1];	/* bitmap of selected core for each Nsts */
 	int8 spatial_policy;
 } wlc_stf_t;
 
@@ -337,7 +337,7 @@ typedef struct wlcband {
 	wlc_phy_t *pi;		/* pointer to phy specific information */
 	bool abgphy_encore;
 
-	uint8 gmode;		/* currently active gmode (see wlioctl.h) */
+	u8 gmode;		/* currently active gmode (see wlioctl.h) */
 
 	struct scb *hwrs_scb;	/* permanent scb for hw rateset */
 
@@ -345,10 +345,10 @@ typedef struct wlcband {
 
 	ratespec_t rspec_override;	/* 802.11 rate override */
 	ratespec_t mrspec_override;	/* multicast rate override */
-	uint8 band_stf_ss_mode;	/* Configured STF type, 0:siso; 1:cdd */
+	u8 band_stf_ss_mode;	/* Configured STF type, 0:siso; 1:cdd */
 	int8 band_stf_stbc_tx;	/* STBC TX 0:off; 1:force on; -1:auto */
 	wlc_rateset_t hw_rateset;	/* rates supported by chip (phy-specific) */
-	uint8 basic_rate[WLC_MAXRATE + 1];	/* basic rates indexed by rate */
+	u8 basic_rate[WLC_MAXRATE + 1];	/* basic rates indexed by rate */
 	bool mimo_cap_40;	/* 40 MHz cap enabled on this band */
 	int8 antgain;		/* antenna gain from srom */
 
@@ -366,7 +366,7 @@ typedef void (*pkcb_fn_t) (wlc_info_t *w
 typedef struct pkt_cb {
 	pkcb_fn_t fn;		/* function to call when tx frame completes */
 	void *arg;		/* void arg for fn */
-	uint8 nextidx;		/* index of next call back if threading */
+	u8 nextidx;		/* index of next call back if threading */
 	bool entered;		/* recursion check */
 } pkt_cb_t;
 
@@ -395,12 +395,12 @@ typedef struct dumpcb_s {
 /* virtual interface */
 struct wlc_if {
 	wlc_if_t *next;
-	uint8 type;		/* WLC_IFTYPE_BSS or WLC_IFTYPE_WDS */
-	uint8 index;		/* assigned in wl_add_if(), index of the wlif if any,
+	u8 type;		/* WLC_IFTYPE_BSS or WLC_IFTYPE_WDS */
+	u8 index;		/* assigned in wl_add_if(), index of the wlif if any,
 				 * not necessarily corresponding to bsscfg._idx or
 				 * AID2PVBMAP(scb).
 				 */
-	uint8 flags;		/* flags for the interface */
+	u8 flags;		/* flags for the interface */
 	wl_if_t *wlif;		/* pointer to wlif */
 	struct wlc_txq_info *qi;	/* pointer to associated tx queue */
 	union {
@@ -417,7 +417,7 @@ typedef struct wlc_hwband {
 	int bandtype;		/* WLC_BAND_2G, WLC_BAND_5G */
 	uint bandunit;		/* bandstate[] index */
 	uint16 mhfs[MHFMAX];	/* MHF array shadow */
-	uint8 bandhw_stf_ss_mode;	/* HW configured STF type, 0:siso; 1:cdd */
+	u8 bandhw_stf_ss_mode;	/* HW configured STF type, 0:siso; 1:cdd */
 	uint16 CWmin;
 	uint16 CWmax;
 	uint32 core_flags;
@@ -449,7 +449,7 @@ struct wlc_hw_info {
 	uint16 vendorid;	/* PCI vendor id */
 	uint16 deviceid;	/* PCI device id */
 	uint corerev;		/* core revision */
-	uint8 sromrev;		/* version # of the srom */
+	u8 sromrev;		/* version # of the srom */
 	uint16 boardrev;	/* version # of particular board */
 	uint32 boardflags;	/* Board specific flags from srom */
 	uint32 boardflags2;	/* More board flags if sromrev >= 4 */
@@ -482,7 +482,7 @@ struct wlc_hw_info {
 
 	mbool pllreq;		/* pll requests to keep PLL on */
 
-	uint8 suspended_fifos;	/* Which TX fifo to remain awake for */
+	u8 suspended_fifos;	/* Which TX fifo to remain awake for */
 	uint32 maccontrol;	/* Cached value of maccontrol */
 	uint mac_suspend_depth;	/* current depth of mac_suspend levels */
 	uint32 wake_override;	/* Various conditions to force MAC to WAKE mode */
@@ -512,8 +512,8 @@ struct wlc_hw_info {
 
 #endif				/* WLC_LOW_ONLY */
 
-	uint8 hw_stf_ss_opmode;	/* STF single stream operation mode */
-	uint8 antsel_type;	/* Type of boardlevel mimo antenna switch-logic
+	u8 hw_stf_ss_opmode;	/* STF single stream operation mode */
+	u8 antsel_type;	/* Type of boardlevel mimo antenna switch-logic
 				 * 0 = N/A, 1 = 2x4 board, 2 = 2x3 CB2 board
 				 */
 	uint32 antsel_avail;	/* put antsel_info_t here if more info is needed */
@@ -578,7 +578,7 @@ struct wlc_info {
 
 	/* Regulatory power limits */
 	int8 txpwr_local_max;	/* regulatory local txpwr max */
-	uint8 txpwr_local_constraint;	/* local power contraint in dB */
+	u8 txpwr_local_constraint;	/* local power contraint in dB */
 
 #ifdef WLC_HIGH_ONLY
 	rpctx_info_t *rpctx;	/* RPC TX module */
@@ -611,10 +611,10 @@ struct wlc_info {
 	bool going_down;	/* down path intermediate variable */
 
 	bool mpc;		/* enable minimum power consumption */
-	uint8 mpc_dlycnt;	/* # of watchdog cnt before turn disable radio */
-	uint8 mpc_offcnt;	/* # of watchdog cnt that radio is disabled */
-	uint8 mpc_delay_off;	/* delay radio disable by # of watchdog cnt */
-	uint8 prev_non_delay_mpc;	/* prev state wlc_is_non_delay_mpc */
+	u8 mpc_dlycnt;	/* # of watchdog cnt before turn disable radio */
+	u8 mpc_offcnt;	/* # of watchdog cnt that radio is disabled */
+	u8 mpc_delay_off;	/* delay radio disable by # of watchdog cnt */
+	u8 prev_non_delay_mpc;	/* prev state wlc_is_non_delay_mpc */
 
 	/* timer */
 	struct wl_timer *wdtimer;	/* timer for watchdog routine */
@@ -633,7 +633,7 @@ struct wlc_info {
 	bool bcnmisc_scan;	/* bcns promisc mode override for scan */
 	bool bcnmisc_monitor;	/* bcns promisc mode override for monitor */
 
-	uint8 bcn_wait_prd;	/* max waiting period (for beacon) in 1024TU */
+	u8 bcn_wait_prd;	/* max waiting period (for beacon) in 1024TU */
 
 	/* driver feature */
 	bool _rifs;		/* enable per-packet rifs */
@@ -651,14 +651,14 @@ struct wlc_info {
 				 * of scan, rm, etc. off home channel activity.
 				 */
 	bool PSpoll;		/* whether there is an outstanding PS-Poll frame */
-	uint8 PM;		/* power-management mode (CAM, PS or FASTPS) */
+	u8 PM;		/* power-management mode (CAM, PS or FASTPS) */
 	bool PMawakebcn;	/* bcn recvd during current waking state */
 
 	bool WME_PM_blocked;	/* Can STA go to PM when in WME Auto mode */
 	bool wake;		/* host-specified PS-mode sleep state */
-	uint8 pspoll_prd;	/* pspoll interval in milliseconds */
-	uint8 bcn_li_bcn;	/* beacon listen interval in # beacons */
-	uint8 bcn_li_dtim;	/* beacon listen interval in # dtims */
+	u8 pspoll_prd;	/* pspoll interval in milliseconds */
+	u8 bcn_li_bcn;	/* beacon listen interval in # beacons */
+	u8 bcn_li_dtim;	/* beacon listen interval in # dtims */
 
 	bool WDarmed;		/* watchdog timer is armed */
 	uint32 WDlast;		/* last time wlc_watchdog() was called */
@@ -685,9 +685,9 @@ struct wlc_info {
 						 * always valid
 						 */
 	wlc_bsscfg_t *cfg;	/* the primary bsscfg (can be AP or STA) */
-	uint8 stas_associated;	/* count of ASSOCIATED STA bsscfgs */
-	uint8 aps_associated;	/* count of UP AP bsscfgs */
-	uint8 block_datafifo;	/* prohibit posting frames to data fifos */
+	u8 stas_associated;	/* count of ASSOCIATED STA bsscfgs */
+	u8 aps_associated;	/* count of UP AP bsscfgs */
+	u8 block_datafifo;	/* prohibit posting frames to data fifos */
 	bool bcmcfifo_drain;	/* TX_BCMC_FIFO is set to drain */
 
 	/* tx queue */
@@ -705,8 +705,8 @@ struct wlc_info {
 	modulecb_t *modulecb;
 	dumpcb_t *dumpcb_head;
 
-	uint8 mimoft;		/* SIGN or 11N */
-	uint8 mimo_band_bwcap;	/* bw cap per band type */
+	u8 mimoft;		/* SIGN or 11N */
+	u8 mimo_band_bwcap;	/* bw cap per band type */
 	int8 txburst_limit_override;	/* tx burst limit override */
 	uint16 txburst_limit;	/* tx burst limit value */
 	int8 cck_40txbw;	/* 11N, cck tx b/w override when in 40MHZ mode */
@@ -790,15 +790,15 @@ struct wlc_info {
 					 */
 	wlc_ap_info_t *ap;
 
-	uint8 htphy_membership;	/* HT PHY membership */
+	u8 htphy_membership;	/* HT PHY membership */
 
 	bool _regulatory_domain;	/* 802.11d enabled? */
 
-	uint8 mimops_PM;
+	u8 mimops_PM;
 
-	uint8 txpwr_percent;	/* power output percentage */
+	u8 txpwr_percent;	/* power output percentage */
 
-	uint8 ht_wsec_restriction;	/* the restriction of HT with TKIP or WEP */
+	u8 ht_wsec_restriction;	/* the restriction of HT with TKIP or WEP */
 
 	uint tempsense_lasttime;
 
@@ -823,10 +823,10 @@ struct wlc_info {
 struct antsel_info {
 	wlc_info_t *wlc;	/* pointer to main wlc structure */
 	wlc_pub_t *pub;		/* pointer to public fn */
-	uint8 antsel_type;	/* Type of boardlevel mimo antenna switch-logic
+	u8 antsel_type;	/* Type of boardlevel mimo antenna switch-logic
 				 * 0 = N/A, 1 = 2x4 board, 2 = 2x3 CB2 board
 				 */
-	uint8 antsel_antswitch;	/* board level antenna switch type */
+	u8 antsel_antswitch;	/* board level antenna switch type */
 	bool antsel_avail;	/* Ant selection availability (SROM based) */
 	wlc_antselcfg_t antcfg_11n;	/* antenna configuration */
 	wlc_antselcfg_t antcfg_cur;	/* current antenna config (auto) */
@@ -902,17 +902,17 @@ extern void wlc_reset_bmac_done(wlc_info
 extern void wlc_protection_upd(wlc_info_t *wlc, uint idx, int val);
 extern void wlc_hwtimer_gptimer_set(wlc_info_t *wlc, uint us);
 extern void wlc_hwtimer_gptimer_abort(wlc_info_t *wlc);
-extern void wlc_pktengtx(wlc_info_t *wlc, wl_pkteng_t *pkteng, uint8 rate,
+extern void wlc_pktengtx(wlc_info_t *wlc, wl_pkteng_t *pkteng, u8 rate,
 			 struct ether_addr *sa, uint32 wait_delay);
 
 #if defined(BCMDBG)
 extern void wlc_print_rxh(d11rxhdr_t *rxh);
-extern void wlc_print_hdrs(wlc_info_t *wlc, const char *prefix, uint8 *frame,
+extern void wlc_print_hdrs(wlc_info_t *wlc, const char *prefix, u8 *frame,
 			   d11txh_t *txh, d11rxhdr_t *rxh, uint len);
 extern void wlc_print_txdesc(d11txh_t *txh);
 #endif
 #if defined(BCMDBG)
-extern void wlc_print_dot11_mac_hdr(uint8 *buf, int len);
+extern void wlc_print_dot11_mac_hdr(u8 *buf, int len);
 #endif
 
 #ifdef WLC_LOW
@@ -926,7 +926,7 @@ extern void wlc_ap_upd(wlc_info_t *wlc);
 
 /* helper functions */
 extern void wlc_shm_ssid_upd(wlc_info_t *wlc, wlc_bsscfg_t *cfg);
-extern int wlc_set_gmode(wlc_info_t *wlc, uint8 gmode, bool config);
+extern int wlc_set_gmode(wlc_info_t *wlc, u8 gmode, bool config);
 
 extern void wlc_mac_bcn_promisc_change(wlc_info_t *wlc, bool promisc);
 extern void wlc_mac_bcn_promisc(wlc_info_t *wlc);
@@ -946,8 +946,8 @@ extern ratespec_t wlc_rspec_to_rts_rspec
 					 bool use_rspec, uint16 mimo_ctlchbw);
 extern uint16 wlc_compute_rtscts_dur(wlc_info_t *wlc, bool cts_only,
 				     ratespec_t rts_rate, ratespec_t frame_rate,
-				     uint8 rts_preamble_type,
-				     uint8 frame_preamble_type, uint frame_len,
+				     u8 rts_preamble_type,
+				     u8 frame_preamble_type, uint frame_len,
 				     bool ba);
 
 extern void wlc_tbtt(wlc_info_t *wlc, d11regs_t *regs);
@@ -986,9 +986,9 @@ extern bool wlc_prec_enq_head(wlc_info_t
 			      int prec, bool head);
 extern uint16 wlc_phytxctl1_calc(wlc_info_t *wlc, ratespec_t rspec);
 extern void wlc_compute_plcp(wlc_info_t *wlc, ratespec_t rate, uint length,
-			     uint8 *plcp);
+			     u8 *plcp);
 extern uint wlc_calc_frame_time(wlc_info_t *wlc, ratespec_t ratespec,
-				uint8 preamble_type, uint mac_len);
+				u8 preamble_type, uint mac_len);
 
 extern void wlc_set_chanspec(wlc_info_t *wlc, chanspec_t chanspec);
 
@@ -1001,13 +1001,13 @@ extern int wlc_doiovar(void *hdl, const
 		       int len, int val_size, wlc_if_t *wlcif);
 
 #if defined(BCMDBG)
-extern void wlc_print_ies(wlc_info_t *wlc, uint8 *ies, uint ies_len);
+extern void wlc_print_ies(wlc_info_t *wlc, u8 *ies, uint ies_len);
 #endif
 
 extern int wlc_set_nmode(wlc_info_t *wlc, int32 nmode);
-extern void wlc_ht_mimops_cap_update(wlc_info_t *wlc, uint8 mimops_mode);
+extern void wlc_ht_mimops_cap_update(wlc_info_t *wlc, u8 mimops_mode);
 extern void wlc_mimops_action_ht_send(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg,
-				      uint8 mimops_mode);
+				      u8 mimops_mode);
 
 extern void wlc_switch_shortslot(wlc_info_t *wlc, bool shortslot);
 extern void wlc_set_bssid(wlc_bsscfg_t *cfg);
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.c
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.c
@@ -138,7 +138,7 @@ uint16 wlapi_bmac_read_shm(wlc_phy_shim_
 }
 
 void
-wlapi_bmac_mhf(wlc_phy_shim_info_t *physhim, uint8 idx, uint16 mask,
+wlapi_bmac_mhf(wlc_phy_shim_info_t *physhim, u8 idx, uint16 mask,
 	       uint16 val, int bands)
 {
 	wlc_bmac_mhf(physhim->wlc_hw, idx, mask, val, bands);
@@ -154,7 +154,7 @@ void wlapi_suspend_mac_and_wait(wlc_phy_
 	wlc_suspend_mac_and_wait(physhim->wlc);
 }
 
-void wlapi_switch_macfreq(wlc_phy_shim_info_t *physhim, uint8 spurmode)
+void wlapi_switch_macfreq(wlc_phy_shim_info_t *physhim, u8 spurmode)
 {
 	wlc_bmac_switch_macfreq(physhim->wlc_hw, spurmode);
 }
@@ -222,7 +222,7 @@ wlapi_bmac_write_template_ram(wlc_phy_sh
 	wlc_bmac_write_template_ram(physhim->wlc_hw, offset, len, buf);
 }
 
-uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t *physhim, uint8 rate)
+uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t *physhim, u8 rate)
 {
 	return wlc_bmac_rate_shm_offset(physhim->wlc_hw, rate);
 }
@@ -247,7 +247,7 @@ wlapi_copyto_objmem(wlc_phy_shim_info_t
 
 void
 wlapi_bmac_pktengtx(wlc_phy_shim_info_t *physhim, wl_pkteng_t *pkteng,
-		    uint8 rate, struct ether_addr *sa, uint32 wait_delay)
+		    u8 rate, struct ether_addr *sa, uint32 wait_delay)
 {
 	wlc_pktengtx(physhim->wlc, pkteng, rate, sa, wait_delay);
 }
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.h
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.h
@@ -78,11 +78,11 @@ extern void wlapi_intrsrestore(wlc_phy_s
 extern void wlapi_bmac_write_shm(wlc_phy_shim_info_t *physhim, uint offset,
 				 uint16 v);
 extern uint16 wlapi_bmac_read_shm(wlc_phy_shim_info_t *physhim, uint offset);
-extern void wlapi_bmac_mhf(wlc_phy_shim_info_t *physhim, uint8 idx,
+extern void wlapi_bmac_mhf(wlc_phy_shim_info_t *physhim, u8 idx,
 			   uint16 mask, uint16 val, int bands);
 extern void wlapi_bmac_corereset(wlc_phy_shim_info_t *physhim, uint32 flags);
 extern void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t *physhim);
-extern void wlapi_switch_macfreq(wlc_phy_shim_info_t *physhim, uint8 spurmode);
+extern void wlapi_switch_macfreq(wlc_phy_shim_info_t *physhim, u8 spurmode);
 extern void wlapi_enable_mac(wlc_phy_shim_info_t *physhim);
 extern void wlapi_bmac_mctrl(wlc_phy_shim_info_t *physhim, uint32 mask,
 			     uint32 val);
@@ -99,7 +99,7 @@ extern void wlapi_bmac_ucode_wake_overri
 extern void wlapi_bmac_write_template_ram(wlc_phy_shim_info_t *physhim, int o,
 					  int len, void *buf);
 extern uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t *physhim,
-					 uint8 rate);
+					 u8 rate);
 extern void wlapi_ucode_sample_init(wlc_phy_shim_info_t *physhim);
 extern void wlapi_copyfrom_objmem(wlc_phy_shim_info_t *physhim, uint,
 				  void *buf, int, uint32 sel);
@@ -109,7 +109,7 @@ extern void wlapi_copyto_objmem(wlc_phy_
 extern void wlapi_high_update_phy_mode(wlc_phy_shim_info_t *physhim,
 				       uint32 phy_mode);
 extern void wlapi_bmac_pktengtx(wlc_phy_shim_info_t *physhim,
-				wl_pkteng_t *pkteng, uint8 rate,
+				wl_pkteng_t *pkteng, u8 rate,
 				struct ether_addr *sa, uint32 wait_delay);
 extern uint16 wlapi_bmac_get_txant(wlc_phy_shim_info_t *physhim);
 #endif				/* _wlc_phy_shim_h_ */
--- a/drivers/staging/brcm80211/sys/wlc_pub.h
+++ b/drivers/staging/brcm80211/sys/wlc_pub.h
@@ -115,19 +115,19 @@ typedef struct wlc_tunables {
 
 typedef struct wlc_rateset {
 	uint count;		/* number of rates in rates[] */
-	uint8 rates[WLC_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
-	uint8 htphy_membership;	/* HT PHY Membership */
-	uint8 mcs[MCSSET_LEN];	/* supported mcs index bit map */
+	u8 rates[WLC_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
+	u8 htphy_membership;	/* HT PHY Membership */
+	u8 mcs[MCSSET_LEN];	/* supported mcs index bit map */
 } wlc_rateset_t;
 
 struct rsn_parms {
-	uint8 flags;		/* misc booleans (e.g., supported) */
-	uint8 multicast;	/* multicast cipher */
-	uint8 ucount;		/* count of unicast ciphers */
-	uint8 unicast[4];	/* unicast ciphers */
-	uint8 acount;		/* count of auth modes */
-	uint8 auth[4];		/* Authentication modes */
-	uint8 PAD[4];		/* padding for future growth */
+	u8 flags;		/* misc booleans (e.g., supported) */
+	u8 multicast;	/* multicast cipher */
+	u8 ucount;		/* count of unicast ciphers */
+	u8 unicast[4];	/* unicast ciphers */
+	u8 acount;		/* count of auth modes */
+	u8 auth[4];		/* Authentication modes */
+	u8 PAD[4];		/* padding for future growth */
 };
 
 /*
@@ -167,8 +167,8 @@ typedef struct wlc_event {
 typedef struct wlc_bss_info {
 	struct ether_addr BSSID;	/* network BSSID */
 	uint16 flags;		/* flags for internal attributes */
-	uint8 SSID_len;		/* the length of SSID */
-	uint8 SSID[32];		/* SSID string */
+	u8 SSID_len;		/* the length of SSID */
+	u8 SSID[32];		/* SSID string */
 	int16 RSSI;		/* receive signal strength (in dBm) */
 	int16 SNR;		/* receive signal SNR in dB */
 	uint16 beacon_period;	/* units are Kusec */
@@ -176,19 +176,19 @@ typedef struct wlc_bss_info {
 	chanspec_t chanspec;	/* Channel num, bw, ctrl_sb and band */
 	int8 infra;		/* 0=IBSS, 1=infrastructure, 2=unknown */
 	wlc_rateset_t rateset;	/* supported rates */
-	uint8 dtim_period;	/* DTIM period */
+	u8 dtim_period;	/* DTIM period */
 	int8 phy_noise;		/* noise right after tx (in dBm) */
 	uint16 capability;	/* Capability information */
 	struct dot11_bcn_prb *bcn_prb;	/* beacon/probe response frame (ioctl na) */
 	uint16 bcn_prb_len;	/* beacon/probe response frame length (ioctl na) */
-	uint8 wme_qosinfo;	/* QoS Info from WME IE; valid if WLC_BSS_WME flag set */
+	u8 wme_qosinfo;	/* QoS Info from WME IE; valid if WLC_BSS_WME flag set */
 	struct rsn_parms wpa;
 	struct rsn_parms wpa2;
 	uint16 qbss_load_aac;	/* qbss load available admission capacity */
 	/* qbss_load_chan_free <- (0xff - channel_utilization of qbss_load_ie_t) */
-	uint8 qbss_load_chan_free;	/* indicates how free the channel is */
-	uint8 mcipher;		/* multicast cipher */
-	uint8 wpacfg;		/* wpa config index */
+	u8 qbss_load_chan_free;	/* indicates how free the channel is */
+	u8 mcipher;		/* multicast cipher */
+	u8 wpacfg;		/* wpa config index */
 } wlc_bss_info_t;
 
 /* forward declarations */
@@ -277,7 +277,7 @@ typedef struct wlc_pub {
 	bool _apsta;		/* simultaneous AP/STA mode enabled */
 	bool _assoc_recreate;	/* association recreation on up transitions */
 	int _wme;		/* WME QoS mode */
-	uint8 _mbss;		/* MBSS mode on */
+	u8 _mbss;		/* MBSS mode on */
 	bool allmulti;		/* enable all multicasts */
 	bool associated;	/* true:part of [I]BSS, false: not */
 	/* (union of stas_associated, aps_associated) */
@@ -285,7 +285,7 @@ typedef struct wlc_pub {
 	bool bf_preempt_4306;	/* True to enable 'darwin' mode */
 	bool _ampdu;		/* ampdu enabled or not */
 	bool _cac;		/* 802.11e CAC enabled */
-	uint8 _n_enab;		/* bitmap of 11N + HT support */
+	u8 _n_enab;		/* bitmap of 11N + HT support */
 	bool _n_reqd;		/* N support required for clients */
 
 	int8 _coex;		/* 20/40 MHz BSS Management AUTO, ENAB, DISABLE */
@@ -323,7 +323,7 @@ typedef struct wlc_pub {
 #endif				/* BCMSDIO */
 
 	uint16 boardrev;	/* version # of particular board */
-	uint8 sromrev;		/* version # of the srom */
+	u8 sromrev;		/* version # of the srom */
 	char srom_ccode[WLC_CNTRY_BUF_SZ];	/* Country Code in SROM */
 	uint32 boardflags;	/* Board specific flags from srom */
 	uint32 boardflags2;	/* More board flags if sromrev >= 4 */
@@ -450,7 +450,7 @@ extern void wlc_pkttag_info_move(wlc_pub
 /* pri is PKTPRIO encoded in the packet. This maps the Packet priority to
  * enqueue precedence as defined in wlc_prec_map
  */
-extern const uint8 wlc_prio2prec_map[];
+extern const u8 wlc_prio2prec_map[];
 #define WLC_PRIO_TO_PREC(pri)	wlc_prio2prec_map[(pri) & 7]
 
 /* This maps priority to one precedence higher - Used by PS-Poll response packets to
@@ -458,7 +458,7 @@ extern const uint8 wlc_prio2prec_map[];
  */
 #define WLC_PRIO_TO_HI_PREC(pri)	MIN(WLC_PRIO_TO_PREC(pri) + 1, WLC_PREC_COUNT - 1)
 
-extern const uint8 wme_fifo2ac[];
+extern const u8 wme_fifo2ac[];
 #define WME_PRIO2AC(prio)	wme_fifo2ac[prio2fifo[(prio)]]
 
 /* Mask to describe all precedence levels */
@@ -539,9 +539,9 @@ extern int wlc_bmac_down_finish(struct w
 extern uint32 wlc_reg_read(struct wlc_info *wlc, void *r, uint size);
 extern void wlc_reg_write(struct wlc_info *wlc, void *r, uint32 v, uint size);
 extern void wlc_corereset(struct wlc_info *wlc, uint32 flags);
-extern void wlc_mhf(struct wlc_info *wlc, uint8 idx, uint16 mask, uint16 val,
+extern void wlc_mhf(struct wlc_info *wlc, u8 idx, uint16 mask, uint16 val,
 		    int bands);
-extern uint16 wlc_mhf_get(struct wlc_info *wlc, uint8 idx, int bands);
+extern uint16 wlc_mhf_get(struct wlc_info *wlc, u8 idx, int bands);
 extern uint32 wlc_delta_txfunfl(struct wlc_info *wlc, int fifo);
 extern void wlc_rate_lookup_init(struct wlc_info *wlc, wlc_rateset_t *rateset);
 extern void wlc_default_rateset(struct wlc_info *wlc, wlc_rateset_t *rs);
@@ -565,7 +565,7 @@ extern void wlc_event_if(struct wlc_info
 			 wlc_event_t *e, const struct ether_addr *addr);
 extern void wlc_suspend_mac_and_wait(struct wlc_info *wlc);
 extern void wlc_enable_mac(struct wlc_info *wlc);
-extern uint16 wlc_rate_shm_offset(struct wlc_info *wlc, uint8 rate);
+extern uint16 wlc_rate_shm_offset(struct wlc_info *wlc, u8 rate);
 extern uint32 wlc_get_rspec_history(struct wlc_bsscfg *cfg);
 extern uint32 wlc_get_current_highest_rate(struct wlc_bsscfg *cfg);
 
@@ -575,8 +575,8 @@ static inline int wlc_iovar_getuint(stru
 	return wlc_iovar_getint(wlc, name, (int *)arg);
 }
 
-static inline int wlc_iovar_getuint8(struct wlc_info *wlc, const char *name,
-				     uint8 *arg)
+static inline int wlc_iovar_getu8(struct wlc_info *wlc, const char *name,
+				     u8 *arg)
 {
 	return wlc_iovar_getint8(wlc, name, (int8 *) arg);
 }
@@ -595,7 +595,7 @@ extern int wlc_iocpichk(struct wlc_info
 #endif
 
 /* helper functions */
-extern void wlc_getrand(struct wlc_info *wlc, uint8 *buf, int len);
+extern void wlc_getrand(struct wlc_info *wlc, u8 *buf, int len);
 
 struct scb;
 extern void wlc_ps_on(struct wlc_info *wlc, struct scb *scb);
--- a/drivers/staging/brcm80211/sys/wlc_rate.c
+++ b/drivers/staging/brcm80211/sys/wlc_rate.c
@@ -31,7 +31,7 @@
 #include <wlc_pub.h>
 
 /* Rate info per rate: It tells whether a rate is ofdm or not and its phy_rate value */
-const uint8 rate_info[WLC_MAXRATE + 1] = {
+const u8 rate_info[WLC_MAXRATE + 1] = {
 	/*  0     1     2     3     4     5     6     7     8     9 */
 /*   0 */ 0x00, 0x00, 0x0a, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
 /*  10 */ 0x00, 0x37, 0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x00,
@@ -154,7 +154,7 @@ const mcs_info_t mcs_table[MCS_TABLE_SIZ
  */
 typedef struct legacy_phycfg {
 	uint32 rate_ofdm;	/* ofdm mac rate */
-	uint8 tx_phy_ctl3;	/* phy ctl byte 3, code rate, modulation type, # of streams */
+	u8 tx_phy_ctl3;	/* phy ctl byte 3, code rate, modulation type, # of streams */
 } legacy_phycfg_t;
 
 #define LEGACY_PHYCFG_TABLE_SIZE	12	/* Number of legacy_rate_cfg entries in the table */
@@ -278,7 +278,7 @@ static bool wlc_rateset_valid(wlc_ratese
 	return FALSE;
 }
 
-void wlc_rateset_mcs_upd(wlc_rateset_t *rs, uint8 txstreams)
+void wlc_rateset_mcs_upd(wlc_rateset_t *rs, u8 txstreams)
 {
 	int i;
 	for (i = txstreams; i < MAX_STREAMS_SUPPORTED; i++)
@@ -291,10 +291,10 @@ void wlc_rateset_mcs_upd(wlc_rateset_t *
 bool
 wlc_rate_hwrs_filter_sort_validate(wlc_rateset_t *rs,
 				   const wlc_rateset_t *hw_rs,
-				   bool check_brate, uint8 txstreams)
+				   bool check_brate, u8 txstreams)
 {
-	uint8 rateset[WLC_MAXRATE + 1];
-	uint8 r;
+	u8 rateset[WLC_MAXRATE + 1];
+	u8 r;
 	uint count;
 	uint i;
 
@@ -332,7 +332,7 @@ wlc_rate_hwrs_filter_sort_validate(wlc_r
 }
 
 /* caluclate the rate of a rx'd frame and return it as a ratespec */
-ratespec_t BCMFASTPATH wlc_compute_rspec(d11rxhdr_t *rxh, uint8 *plcp)
+ratespec_t BCMFASTPATH wlc_compute_rspec(d11rxhdr_t *rxh, u8 *plcp)
 {
 	int phy_type;
 	ratespec_t rspec = PHY_TXC1_BW_20MHZ << RSPEC_BW_SHIFT;
@@ -395,7 +395,7 @@ void wlc_rateset_copy(const wlc_rateset_
  */
 void
 wlc_rateset_filter(wlc_rateset_t *src, wlc_rateset_t *dst, bool basic_only,
-		   uint8 rates, uint xmask, bool mcsallow)
+		   u8 rates, uint xmask, bool mcsallow)
 {
 	uint i;
 	uint r;
@@ -427,7 +427,7 @@ wlc_rateset_filter(wlc_rateset_t *src, w
 void
 wlc_rateset_default(wlc_rateset_t *rs_tgt, const wlc_rateset_t *rs_hw,
 		    uint phy_type, int bandtype, bool cck_only, uint rate_mask,
-		    bool mcsallow, uint8 bw, uint8 txstreams)
+		    bool mcsallow, u8 bw, u8 txstreams)
 {
 	const wlc_rateset_t *rs_dflt;
 	wlc_rateset_t rs_sel;
@@ -484,14 +484,14 @@ void wlc_rateset_mcs_clear(wlc_rateset_t
 		rateset->mcs[i] = 0;
 }
 
-void wlc_rateset_mcs_build(wlc_rateset_t *rateset, uint8 txstreams)
+void wlc_rateset_mcs_build(wlc_rateset_t *rateset, u8 txstreams)
 {
 	bcopy(&cck_ofdm_mimo_rates.mcs[0], &rateset->mcs[0], MCSSET_LEN);
 	wlc_rateset_mcs_upd(rateset, txstreams);
 }
 
 /* Based on bandwidth passed, allow/disallow MCS 32 in the rateset */
-void wlc_rateset_bw_mcs_filter(wlc_rateset_t *rateset, uint8 bw)
+void wlc_rateset_bw_mcs_filter(wlc_rateset_t *rateset, u8 bw)
 {
 	if (bw == WLC_40_MHZ)
 		setbit(rateset->mcs, 32);
--- a/drivers/staging/brcm80211/sys/wlc_rate.h
+++ b/drivers/staging/brcm80211/sys/wlc_rate.h
@@ -17,7 +17,7 @@
 #ifndef _WLC_RATE_H_
 #define _WLC_RATE_H_
 
-extern const uint8 rate_info[];
+extern const u8 rate_info[];
 extern const struct wlc_rateset cck_ofdm_mimo_rates;
 extern const struct wlc_rateset ofdm_mimo_rates;
 extern const struct wlc_rateset cck_ofdm_rates;
@@ -32,8 +32,8 @@ typedef struct mcs_info {
 	uint32 phy_rate_40;	/* phy rate in kbps [40Mhz] */
 	uint32 phy_rate_20_sgi;	/* phy rate in kbps [20Mhz] with SGI */
 	uint32 phy_rate_40_sgi;	/* phy rate in kbps [40Mhz] with SGI */
-	uint8 tx_phy_ctl3;	/* phy ctl byte 3, code rate, modulation type, # of streams */
-	uint8 leg_ofdm;		/* matching legacy ofdm rate in 500bkps */
+	u8 tx_phy_ctl3;	/* phy ctl byte 3, code rate, modulation type, # of streams */
+	u8 leg_ofdm;		/* matching legacy ofdm rate in 500bkps */
 } mcs_info_t;
 
 #define WLC_MAXMCS	32	/* max valid mcs index */
@@ -129,7 +129,7 @@ typedef uint32 ratespec_t;
 	(PHY_TXC1_MODE_SDM << RSPEC_STF_SHIFT)))
 
 /* Convert encoded rate value in plcp header to numerical rates in 500 KHz increments */
-extern const uint8 ofdm_rate_lookup[];
+extern const u8 ofdm_rate_lookup[];
 #define OFDM_PHY2MAC_RATE(rlpt)		(ofdm_rate_lookup[rlpt & 0x7])
 #define CCK_PHY2MAC_RATE(signal)	(signal/5)
 
@@ -145,26 +145,26 @@ struct wlc_rateset;
 extern bool wlc_rate_hwrs_filter_sort_validate(struct wlc_rateset *rs,
 					       const struct wlc_rateset *hw_rs,
 					       bool check_brate,
-					       uint8 txstreams);
+					       u8 txstreams);
 /* copy rateset src to dst as-is (no masking or sorting) */
 extern void wlc_rateset_copy(const struct wlc_rateset *src,
 			     struct wlc_rateset *dst);
 
 /* would be nice to have these documented ... */
-extern ratespec_t wlc_compute_rspec(d11rxhdr_t *rxh, uint8 *plcp);
+extern ratespec_t wlc_compute_rspec(d11rxhdr_t *rxh, u8 *plcp);
 
 extern void wlc_rateset_filter(struct wlc_rateset *src, struct wlc_rateset *dst,
-			       bool basic_only, uint8 rates, uint xmask,
+			       bool basic_only, u8 rates, uint xmask,
 			       bool mcsallow);
 extern void wlc_rateset_default(struct wlc_rateset *rs_tgt,
 				const struct wlc_rateset *rs_hw, uint phy_type,
 				int bandtype, bool cck_only, uint rate_mask,
-				bool mcsallow, uint8 bw, uint8 txstreams);
+				bool mcsallow, u8 bw, u8 txstreams);
 extern int16 wlc_rate_legacy_phyctl(uint rate);
 
-extern void wlc_rateset_mcs_upd(struct wlc_rateset *rs, uint8 txstreams);
+extern void wlc_rateset_mcs_upd(struct wlc_rateset *rs, u8 txstreams);
 extern void wlc_rateset_mcs_clear(struct wlc_rateset *rateset);
-extern void wlc_rateset_mcs_build(struct wlc_rateset *rateset, uint8 txstreams);
-extern void wlc_rateset_bw_mcs_filter(struct wlc_rateset *rateset, uint8 bw);
+extern void wlc_rateset_mcs_build(struct wlc_rateset *rateset, u8 txstreams);
+extern void wlc_rateset_bw_mcs_filter(struct wlc_rateset *rateset, u8 bw);
 
 #endif				/* _WLC_RATE_H_ */
--- a/drivers/staging/brcm80211/sys/wlc_rpctx.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpctx.h
@@ -44,9 +44,9 @@ extern void wlc_rpctx_txreclaim(rpctx_in
 extern uint wlc_rpctx_txavail(rpctx_info_t *rpctx, uint fifo);
 extern int wlc_rpctx_pkteng(rpctx_info_t *rpctx, uint fifo, void *p);
 extern int wlc_rpctx_tx(rpctx_info_t *rpctx, uint fifo, void *p, bool commit,
-			uint16 frameid, uint8 txpktpend);
-extern void wlc_rpctx_txpktpendinc(rpctx_info_t *rpctx, uint fifo, uint8 val);
-extern void wlc_rpctx_txpktpenddec(rpctx_info_t *rpctx, uint fifo, uint8 val);
+			uint16 frameid, u8 txpktpend);
+extern void wlc_rpctx_txpktpendinc(rpctx_info_t *rpctx, uint fifo, u8 val);
+extern void wlc_rpctx_txpktpenddec(rpctx_info_t *rpctx, uint fifo, u8 val);
 extern void wlc_rpctx_txpktpendclr(rpctx_info_t *rpctx, uint fifo);
 extern int wlc_rpctx_txpktpend(rpctx_info_t *rpctx, uint fifo, bool all);
 
--- a/drivers/staging/brcm80211/sys/wlc_scb.h
+++ b/drivers/staging/brcm80211/sys/wlc_scb.h
@@ -19,15 +19,15 @@
 
 #include <proto/802.1d.h>
 
-extern bool wlc_aggregatable(wlc_info_t *wlc, uint8 tid);
+extern bool wlc_aggregatable(wlc_info_t *wlc, u8 tid);
 
 #define AMPDU_TX_BA_MAX_WSIZE	64	/* max Tx ba window size (in pdu) */
 /* structure to store per-tid state for the ampdu initiator */
 typedef struct scb_ampdu_tid_ini {
 	uint32 magic;
-	uint8 tx_in_transit;	/* number of pending mpdus in transit in driver */
-	uint8 tid;		/* initiator tid for easy lookup */
-	uint8 txretry[AMPDU_TX_BA_MAX_WSIZE];	/* tx retry count; indexed by seq modulo */
+	u8 tx_in_transit;	/* number of pending mpdus in transit in driver */
+	u8 tid;		/* initiator tid for easy lookup */
+	u8 txretry[AMPDU_TX_BA_MAX_WSIZE];	/* tx retry count; indexed by seq modulo */
 	struct scb *scb;	/* backptr for easy lookup */
 } scb_ampdu_tid_ini_t;
 
@@ -35,9 +35,9 @@ typedef struct scb_ampdu_tid_ini {
 
 typedef struct scb_ampdu {
 	struct scb *scb;	/* back pointer for easy reference */
-	uint8 mpdu_density;	/* mpdu density */
-	uint8 max_pdu;		/* max pdus allowed in ampdu */
-	uint8 release;		/* # of mpdus released at a time */
+	u8 mpdu_density;	/* mpdu density */
+	u8 max_pdu;		/* max pdus allowed in ampdu */
+	u8 release;		/* # of mpdus released at a time */
 	uint16 min_len;		/* min mpdu len to support the density */
 	uint32 max_rxlen;	/* max ampdu rcv length; 8k, 16k, 32k, 64k */
 	struct pktq txq;	/* sdu transmit queue pending aggregation */
@@ -57,7 +57,7 @@ struct scb {
 	uint32 magic;
 	uint32 flags;		/* various bit flags as defined below */
 	uint32 flags2;		/* various bit flags2 as defined below */
-	uint8 state;		/* current state bitfield of auth/assoc process */
+	u8 state;		/* current state bitfield of auth/assoc process */
 	struct ether_addr ea;	/* station address */
 	void *fragbuf[NUMPRIO];	/* defragmentation buffer per prio */
 	uint fragresid[NUMPRIO];	/* #bytes unused in frag buffer per prio */
--- a/drivers/staging/brcm80211/sys/wlc_stf.c
+++ b/drivers/staging/brcm80211/sys/wlc_stf.c
@@ -44,7 +44,7 @@
 
 static int8 wlc_stf_stbc_rx_get(wlc_info_t *wlc);
 static bool wlc_stf_stbc_tx_set(wlc_info_t *wlc, int32 int_val);
-static int wlc_stf_txcore_set(wlc_info_t *wlc, uint8 Nsts, uint8 val);
+static int wlc_stf_txcore_set(wlc_info_t *wlc, u8 Nsts, u8 val);
 static int wlc_stf_spatial_policy_set(wlc_info_t *wlc, int val);
 static void wlc_stf_stbc_rx_ht_update(wlc_info_t *wlc, int val);
 
@@ -55,7 +55,7 @@ static uint16 _wlc_stf_phytxchain_sel(wl
 #define NSTS_2	2
 #define NSTS_3	3
 #define NSTS_4	4
-const uint8 txcore_default[5] = {
+const u8 txcore_default[5] = {
 	(0),			/* bitmap of the core enabled */
 	(0x01),			/* For Nsts = 1, enable core 1 */
 	(0x03),			/* For Nsts = 2, enable core 1 & 2 */
@@ -112,7 +112,7 @@ wlc_stf_ss_algo_channel_get(wlc_info_t *
 			    chanspec_t chanspec)
 {
 	tx_power_t power;
-	uint8 siso_mcs_id, cdd_mcs_id, stbc_mcs_id;
+	u8 siso_mcs_id, cdd_mcs_id, stbc_mcs_id;
 
 	/* Clear previous settings */
 	*ss_algo_channel = 0;
@@ -192,7 +192,7 @@ bool wlc_stf_stbc_rx_set(wlc_info_t *wlc
 	return TRUE;
 }
 
-static int wlc_stf_txcore_set(wlc_info_t *wlc, uint8 Nsts, uint8 core_mask)
+static int wlc_stf_txcore_set(wlc_info_t *wlc, u8 Nsts, u8 core_mask)
 {
 	WL_TRACE(("wl%d: %s: Nsts %d core_mask %x\n",
 		  wlc->pub->unit, __func__, Nsts, core_mask));
@@ -232,7 +232,7 @@ static int wlc_stf_txcore_set(wlc_info_t
 static int wlc_stf_spatial_policy_set(wlc_info_t *wlc, int val)
 {
 	int i;
-	uint8 core_mask = 0;
+	u8 core_mask = 0;
 
 	WL_TRACE(("wl%d: %s: val %x\n", wlc->pub->unit, __func__, val));
 
@@ -240,15 +240,15 @@ static int wlc_stf_spatial_policy_set(wl
 	for (i = 1; i <= MAX_STREAMS_SUPPORTED; i++) {
 		core_mask = (val == MAX_SPATIAL_EXPANSION) ?
 		    wlc->stf->txchain : txcore_default[i];
-		wlc_stf_txcore_set(wlc, (uint8) i, core_mask);
+		wlc_stf_txcore_set(wlc, (u8) i, core_mask);
 	}
 	return BCME_OK;
 }
 
 int wlc_stf_txchain_set(wlc_info_t *wlc, int32 int_val, bool force)
 {
-	uint8 txchain = (uint8) int_val;
-	uint8 txstreams;
+	u8 txchain = (u8) int_val;
+	u8 txstreams;
 	uint i;
 
 	if (wlc->stf->txchain == txchain)
@@ -259,7 +259,7 @@ int wlc_stf_txchain_set(wlc_info_t *wlc,
 		return BCME_RANGE;
 
 	/* if nrate override is configured to be non-SISO STF mode, reject reducing txchain to 1 */
-	txstreams = (uint8) WLC_BITSCNT(txchain);
+	txstreams = (u8) WLC_BITSCNT(txchain);
 	if (txstreams > MAX_STREAMS_SUPPORTED)
 		return BCME_RANGE;
 
@@ -300,17 +300,17 @@ int wlc_stf_txchain_set(wlc_info_t *wlc,
 			      wlc->stf->rxchain);
 
 	for (i = 1; i <= MAX_STREAMS_SUPPORTED; i++)
-		wlc_stf_txcore_set(wlc, (uint8) i, txcore_default[i]);
+		wlc_stf_txcore_set(wlc, (u8) i, txcore_default[i]);
 
 	return BCME_OK;
 }
 
 int wlc_stf_rxchain_set(wlc_info_t *wlc, int32 int_val)
 {
-	uint8 rxchain_cnt;
-	uint8 rxchain = (uint8) int_val;
-	uint8 mimops_mode;
-	uint8 old_rxchain, old_rxchain_cnt;
+	u8 rxchain_cnt;
+	u8 rxchain = (u8) int_val;
+	u8 mimops_mode;
+	u8 old_rxchain, old_rxchain_cnt;
 
 	if (wlc->stf->rxchain == rxchain)
 		return BCME_OK;
@@ -319,7 +319,7 @@ int wlc_stf_rxchain_set(wlc_info_t *wlc,
 	    || !(rxchain & wlc->stf->hw_rxchain))
 		return BCME_RANGE;
 
-	rxchain_cnt = (uint8) WLC_BITSCNT(rxchain);
+	rxchain_cnt = (u8) WLC_BITSCNT(rxchain);
 	if (WLC_STF_SS_STBC_RX(wlc)) {
 		if ((rxchain_cnt == 1)
 		    && (wlc_stf_stbc_rx_get(wlc) != HT_CAP_RX_STBC_NO))
@@ -372,8 +372,8 @@ int wlc_stf_rxchain_set(wlc_info_t *wlc,
 int wlc_stf_ss_update(wlc_info_t *wlc, wlcband_t *band)
 {
 	int ret_code = 0;
-	uint8 prev_stf_ss;
-	uint8 upd_stf_ss;
+	u8 prev_stf_ss;
+	u8 upd_stf_ss;
 
 	prev_stf_ss = wlc->stf->ss_opmode;
 
@@ -527,8 +527,8 @@ void wlc_stf_phy_txant_upd(wlc_info_t *w
 void BCMATTACHFN(wlc_stf_phy_chain_calc) (wlc_info_t *wlc)
 {
 	/* get available rx/tx chains */
-	wlc->stf->hw_txchain = (uint8) getintvar(wlc->pub->vars, "txchain");
-	wlc->stf->hw_rxchain = (uint8) getintvar(wlc->pub->vars, "rxchain");
+	wlc->stf->hw_txchain = (u8) getintvar(wlc->pub->vars, "txchain");
+	wlc->stf->hw_rxchain = (u8) getintvar(wlc->pub->vars, "rxchain");
 
 	/* these parameter are intended to be used for all PHY types */
 	if (wlc->stf->hw_txchain == 0 || wlc->stf->hw_txchain == 0xf) {
@@ -540,7 +540,7 @@ void BCMATTACHFN(wlc_stf_phy_chain_calc)
 	}
 
 	wlc->stf->txchain = wlc->stf->hw_txchain;
-	wlc->stf->txstreams = (uint8) WLC_BITSCNT(wlc->stf->hw_txchain);
+	wlc->stf->txstreams = (u8) WLC_BITSCNT(wlc->stf->hw_txchain);
 
 	if (wlc->stf->hw_rxchain == 0 || wlc->stf->hw_rxchain == 0xf) {
 		if (WLCISNPHY(wlc->band)) {
@@ -551,7 +551,7 @@ void BCMATTACHFN(wlc_stf_phy_chain_calc)
 	}
 
 	wlc->stf->rxchain = wlc->stf->hw_rxchain;
-	wlc->stf->rxstreams = (uint8) WLC_BITSCNT(wlc->stf->hw_rxchain);
+	wlc->stf->rxstreams = (u8) WLC_BITSCNT(wlc->stf->hw_rxchain);
 
 	/* initialize the txcore table */
 	bcopy(txcore_default, wlc->stf->txcore, sizeof(wlc->stf->txcore));

commit e59fe083f683ca2ca56abefad290d110808a6fb5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 17:08:21 2010 -0700

    Staging: brcm80211: s/int16/s16/
    
    Use the kernel types, don't invent your own.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
@@ -182,7 +182,7 @@ struct wl_dev {
 struct wl_cfg80211_bss_info {
 	u16 band;
 	u16 channel;
-	int16 rssi;
+	s16 rssi;
 	u16 frame_len;
 	u8 frame_buf[1];
 };
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -324,7 +324,7 @@ extern "C" {
 	"bool", \
 	"s8", \
 	"u8", \
-	"int16", \
+	"s16", \
 	"u16", \
 	"int32", \
 	"uint32", \
--- a/drivers/staging/brcm80211/include/qmath.h
+++ b/drivers/staging/brcm80211/include/qmath.h
@@ -19,62 +19,62 @@
 
 #include <typedefs.h>
 
-int16 qm_sat32(int32 op);
+s16 qm_sat32(int32 op);
 
-int32 qm_mul321616(int16 op1, int16 op2);
+int32 qm_mul321616(s16 op1, s16 op2);
 
-int16 qm_mul16(int16 op1, int16 op2);
+s16 qm_mul16(s16 op1, s16 op2);
 
-int32 qm_muls321616(int16 op1, int16 op2);
+int32 qm_muls321616(s16 op1, s16 op2);
 
 u16 qm_mulu16(u16 op1, u16 op2);
 
-int16 qm_muls16(int16 op1, int16 op2);
+s16 qm_muls16(s16 op1, s16 op2);
 
 int32 qm_add32(int32 op1, int32 op2);
 
-int16 qm_add16(int16 op1, int16 op2);
+s16 qm_add16(s16 op1, s16 op2);
 
-int16 qm_sub16(int16 op1, int16 op2);
+s16 qm_sub16(s16 op1, s16 op2);
 
 int32 qm_sub32(int32 op1, int32 op2);
 
-int32 qm_mac321616(int32 acc, int16 op1, int16 op2);
+int32 qm_mac321616(int32 acc, s16 op1, s16 op2);
 
 int32 qm_shl32(int32 op, int shift);
 
 int32 qm_shr32(int32 op, int shift);
 
-int16 qm_shl16(int16 op, int shift);
+s16 qm_shl16(s16 op, int shift);
 
-int16 qm_shr16(int16 op, int shift);
+s16 qm_shr16(s16 op, int shift);
 
-int16 qm_norm16(int16 op);
+s16 qm_norm16(s16 op);
 
-int16 qm_norm32(int32 op);
+s16 qm_norm32(int32 op);
 
-int16 qm_div_s(int16 num, int16 denom);
+s16 qm_div_s(s16 num, s16 denom);
 
-int16 qm_abs16(int16 op);
+s16 qm_abs16(s16 op);
 
-int16 qm_div16(int16 num, int16 denom, int16 *qQuotient);
+s16 qm_div16(s16 num, s16 denom, s16 *qQuotient);
 
 int32 qm_abs32(int32 op);
 
-int16 qm_div163232(int32 num, int32 denom, int16 *qquotient);
+s16 qm_div163232(int32 num, int32 denom, s16 *qquotient);
 
-int32 qm_mul323216(int32 op1, int16 op2);
+int32 qm_mul323216(int32 op1, s16 op2);
 
-int32 qm_mulsu321616(int16 op1, u16 op2);
+int32 qm_mulsu321616(s16 op1, u16 op2);
 
-int32 qm_muls323216(int32 op1, int16 op2);
+int32 qm_muls323216(int32 op1, s16 op2);
 
 int32 qm_mul32(int32 a, int32 b);
 
 int32 qm_muls32(int32 a, int32 b);
 
-void qm_log10(int32 N, int16 qN, int16 *log10N, int16 *qLog10N);
+void qm_log10(int32 N, s16 qN, s16 *log10N, s16 *qLog10N);
 
-void qm_1byN(int32 N, int16 qN, int32 *result, int16 *qResult);
+void qm_1byN(int32 N, s16 qN, int32 *result, s16 *qResult);
 
 #endif				/* #ifndef __QMATH_H__ */
--- a/drivers/staging/brcm80211/include/typedefs.h
+++ b/drivers/staging/brcm80211/include/typedefs.h
@@ -42,7 +42,7 @@ typedef unsigned long long int uintptr;
 typedef unsigned int uint;
 #endif
 
-/* define [u]int16/32/64, uintptr */
+/* define [u]int32/64, uintptr */
 
 #ifndef TYPEDEF_UINT32
 typedef unsigned int uint32;
@@ -52,10 +52,6 @@ typedef unsigned int uint32;
 typedef unsigned int uintptr;
 #endif
 
-#ifndef TYPEDEF_INT16
-typedef signed short int16;
-#endif
-
 #ifndef TYPEDEF_INT32
 typedef signed int int32;
 #endif
@@ -83,7 +79,6 @@ typedef signed int int32;
 #undef TYPEDEF_UINT
 #undef TYPEDEF_UINT32
 #undef TYPEDEF_UINTPTR
-#undef TYPEDEF_INT16
 #undef TYPEDEF_INT32
 
 /*
--- a/drivers/staging/brcm80211/include/wlioctl.h
+++ b/drivers/staging/brcm80211/include/wlioctl.h
@@ -55,7 +55,7 @@ typedef struct wl_bss_info_107 {
 	u8 channel;		/* Channel no. */
 	u16 atim_window;	/* units are Kusec */
 	u8 dtim_period;	/* DTIM period */
-	int16 RSSI;		/* receive signal strength (in dBm) */
+	s16 RSSI;		/* receive signal strength (in dBm) */
 	s8 phy_noise;		/* noise (in dBm) */
 	uint32 ie_length;	/* byte length of Information Elements */
 	/* variable length Information Elements */
@@ -88,7 +88,7 @@ typedef struct wl_bss_info_108 {
 	chanspec_t chanspec;	/* chanspec for bss */
 	u16 atim_window;	/* units are Kusec */
 	u8 dtim_period;	/* DTIM period */
-	int16 RSSI;		/* receive signal strength (in dBm) */
+	s16 RSSI;		/* receive signal strength (in dBm) */
 	s8 phy_noise;		/* noise (in dBm) */
 
 	u8 n_cap;		/* BSS is 802.11N Capable */
@@ -132,7 +132,7 @@ typedef struct wl_bss_info {
 	chanspec_t chanspec;	/* chanspec for bss */
 	u16 atim_window;	/* units are Kusec */
 	u8 dtim_period;	/* DTIM period */
-	int16 RSSI;		/* receive signal strength (in dBm) */
+	s16 RSSI;		/* receive signal strength (in dBm) */
 	s8 phy_noise;		/* noise (in dBm) */
 
 	u8 n_cap;		/* BSS is 802.11N Capable */
@@ -145,7 +145,7 @@ typedef struct wl_bss_info {
 
 	u16 ie_offset;	/* offset at which IEs start, from beginning */
 	uint32 ie_length;	/* byte length of Information Elements */
-	int16 SNR;		/* average SNR of during frame reception */
+	s16 SNR;		/* average SNR of during frame reception */
 	/* Add new fields here */
 	/* variable length Information Elements */
 } wl_bss_info_t;
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -2274,7 +2274,7 @@ static uint32 wlc_phy_txpower_est_power_
 
 static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t *pi)
 {
-	int16 tx0_status, tx1_status;
+	s16 tx0_status, tx1_status;
 	u16 estPower1, estPower2;
 	u8 pwr0, pwr1, adj_pwr0, adj_pwr1;
 	uint32 est_pwr;
@@ -3119,8 +3119,8 @@ static void wlc_phy_cal_perical_mphase_s
 
 void wlc_phy_cal_perical(wlc_phy_t *pih, u8 reason)
 {
-	int16 nphy_currtemp = 0;
-	int16 delta_temp = 0;
+	s16 nphy_currtemp = 0;
+	s16 delta_temp = 0;
 	bool do_periodic_cal = TRUE;
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -3171,7 +3171,7 @@ void wlc_phy_cal_perical(wlc_phy_t *pih,
 			    nphy_currtemp - pi->nphy_lastcal_temp :
 			    pi->nphy_lastcal_temp - nphy_currtemp;
 
-			if ((delta_temp < (int16) pi->phycal_tempdelta) &&
+			if ((delta_temp < (s16) pi->phycal_tempdelta) &&
 			    (pi->nphy_txiqlocal_chanspec ==
 			     pi->radio_chanspec)) {
 				do_periodic_cal = FALSE;
@@ -3271,7 +3271,7 @@ void wlc_phy_stf_chain_get(wlc_phy_t *pi
 
 u8 wlc_phy_stf_chain_active_get(wlc_phy_t *pih)
 {
-	int16 nphy_currtemp;
+	s16 nphy_currtemp;
 	u8 active_bitmap;
 	phy_info_t *pi = (phy_info_t *) pih;
 
--- a/drivers/staging/brcm80211/phy/wlc_phy_int.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_int.h
@@ -345,8 +345,8 @@ typedef struct {
 	u16 badplcp_ma_total;
 	u16 badplcp_ma_list[MA_WINDOW_SZ];
 	int badplcp_ma_index;
-	int16 pre_badplcp_cnt;
-	int16 bphy_pre_badplcp_cnt;
+	s16 pre_badplcp_cnt;
+	s16 bphy_pre_badplcp_cnt;
 
 	u16 init_gain_core1;
 	u16 init_gain_core2;
@@ -358,7 +358,7 @@ typedef struct {
 	u16 crsminpwrl0;
 	u16 crsminpwru0;
 
-	int16 crsminpwr_index;
+	s16 crsminpwr_index;
 
 	u16 radio_2057_core1_rssi_wb1a_gc_stored;
 	u16 radio_2057_core2_rssi_wb1a_gc_stored;
@@ -413,10 +413,10 @@ typedef struct _lo_complex_t {
 } lo_complex_abgphy_info_t;
 
 typedef struct _nphy_iq_comp {
-	int16 a0;
-	int16 b0;
-	int16 a1;
-	int16 b1;
+	s16 a0;
+	s16 b0;
+	s16 a1;
+	s16 b1;
 } nphy_iq_comp_t;
 
 typedef struct _nphy_txpwrindex {
@@ -446,30 +446,30 @@ typedef struct {
 typedef struct _nphy_pwrctrl {
 	s8 max_pwr_2g;
 	s8 idle_targ_2g;
-	int16 pwrdet_2g_a1;
-	int16 pwrdet_2g_b0;
-	int16 pwrdet_2g_b1;
+	s16 pwrdet_2g_a1;
+	s16 pwrdet_2g_b0;
+	s16 pwrdet_2g_b1;
 	s8 max_pwr_5gm;
 	s8 idle_targ_5gm;
 	s8 max_pwr_5gh;
 	s8 max_pwr_5gl;
-	int16 pwrdet_5gm_a1;
-	int16 pwrdet_5gm_b0;
-	int16 pwrdet_5gm_b1;
-	int16 pwrdet_5gl_a1;
-	int16 pwrdet_5gl_b0;
-	int16 pwrdet_5gl_b1;
-	int16 pwrdet_5gh_a1;
-	int16 pwrdet_5gh_b0;
-	int16 pwrdet_5gh_b1;
+	s16 pwrdet_5gm_a1;
+	s16 pwrdet_5gm_b0;
+	s16 pwrdet_5gm_b1;
+	s16 pwrdet_5gl_a1;
+	s16 pwrdet_5gl_b0;
+	s16 pwrdet_5gl_b1;
+	s16 pwrdet_5gh_a1;
+	s16 pwrdet_5gh_b0;
+	s16 pwrdet_5gh_b1;
 	s8 idle_targ_5gl;
 	s8 idle_targ_5gh;
 	s8 idle_tssi_2g;
 	s8 idle_tssi_5g;
 	s8 idle_tssi;
-	int16 a1;
-	int16 b0;
-	int16 b1;
+	s16 a1;
+	s16 b0;
+	s16 b1;
 } phy_pwrctrl_t;
 
 typedef struct _nphy_txgains {
@@ -634,12 +634,12 @@ struct phy_info {
 	bool disable_percal;
 	mbool measure_hold;
 
-	int16 txpa_2g[PWRTBL_NUM_COEFF];
-	int16 txpa_2g_low_temp[PWRTBL_NUM_COEFF];
-	int16 txpa_2g_high_temp[PWRTBL_NUM_COEFF];
-	int16 txpa_5g_low[PWRTBL_NUM_COEFF];
-	int16 txpa_5g_mid[PWRTBL_NUM_COEFF];
-	int16 txpa_5g_hi[PWRTBL_NUM_COEFF];
+	s16 txpa_2g[PWRTBL_NUM_COEFF];
+	s16 txpa_2g_low_temp[PWRTBL_NUM_COEFF];
+	s16 txpa_2g_high_temp[PWRTBL_NUM_COEFF];
+	s16 txpa_5g_low[PWRTBL_NUM_COEFF];
+	s16 txpa_5g_mid[PWRTBL_NUM_COEFF];
+	s16 txpa_5g_hi[PWRTBL_NUM_COEFF];
 
 	u8 tx_srom_max_2g;
 	u8 tx_srom_max_5g_low;
@@ -682,7 +682,7 @@ struct phy_info {
 
 	bool txpwroverride;
 	bool txpwridx_override_aphy;
-	int16 radiopwr_override;
+	s16 radiopwr_override;
 	u16 hwpwr_txcur;
 	u8 saved_txpwr_idx;
 
@@ -691,10 +691,10 @@ struct phy_info {
 	uint32 tr_R_gain_val;
 	uint32 tr_T_gain_val;
 
-	int16 ofdm_analog_filt_bw_override;
-	int16 cck_analog_filt_bw_override;
-	int16 ofdm_rccal_override;
-	int16 cck_rccal_override;
+	s16 ofdm_analog_filt_bw_override;
+	s16 cck_analog_filt_bw_override;
+	s16 ofdm_rccal_override;
+	s16 cck_rccal_override;
 	u16 extlna_type;
 
 	uint interference_mode_crs_time;
@@ -714,8 +714,8 @@ struct phy_info {
 	s8 phy_scraminit;
 	u8 phy_gpiosel;
 
-	int16 phy_txcore_disable_temp;
-	int16 phy_txcore_enable_temp;
+	s16 phy_txcore_disable_temp;
+	s16 phy_txcore_enable_temp;
 	s8 phy_tempsense_offset;
 	bool phy_txcore_heatedup;
 
@@ -729,8 +729,8 @@ struct phy_info {
 	s8 stats_11b_txpower[STATIC_NUM_RF][STATIC_NUM_BB];
 	u16 gain_table[TX_GAIN_TABLE_LENGTH];
 	bool loopback_gain;
-	int16 max_lpback_gain_hdB;
-	int16 trsw_rx_gain_hdB;
+	s16 max_lpback_gain_hdB;
+	s16 trsw_rx_gain_hdB;
 	u8 power_vec[8];
 
 	u16 rc_cal;
@@ -820,7 +820,7 @@ struct phy_info {
 	u8 nphy_papd_skip;
 	u8 nphy_tssi_slope;
 
-	int16 nphy_noise_win[PHY_CORE_MAX][PHY_NOISE_WINDOW_SZ];
+	s16 nphy_noise_win[PHY_CORE_MAX][PHY_NOISE_WINDOW_SZ];
 	u8 nphy_noise_index;
 
 	u8 nphy_txpid2g[PHY_CORE_NUM_2];
@@ -851,7 +851,7 @@ struct phy_info {
 	struct wlapi_timer *phycal_timer;
 	bool use_int_tx_iqlo_cal_nphy;
 	bool internal_tx_iqlo_cal_tapoff_intpa_nphy;
-	int16 nphy_lastcal_temp;
+	s16 nphy_lastcal_temp;
 
 	txiqcal_cache_t calibration_cache;
 	rssical_cache_t rssical_cache;
@@ -861,7 +861,7 @@ struct phy_info {
 	uint nphy_papd_last_cal;
 	u16 nphy_papd_tx_gain_at_last_cal[2];
 	u8 nphy_papd_cal_gain_index[2];
-	int16 nphy_papd_epsilon_offset[2];
+	s16 nphy_papd_epsilon_offset[2];
 	bool nphy_papd_recal_enable;
 	uint32 nphy_papd_recal_counter;
 	bool nphy_force_papd_cal;
@@ -912,7 +912,7 @@ struct phy_info {
 	u16 crsminpwr0;
 	u16 crsminpwrl0;
 	u16 crsminpwru0;
-	int16 noise_crsminpwr_index;
+	s16 noise_crsminpwr_index;
 	u16 init_gain_core1;
 	u16 init_gain_core2;
 	u16 init_gainb_core1;
@@ -1085,7 +1085,7 @@ extern void wlc_phy_mcs_to_ofdm_powers_n
 					    u8 rate_mcs_start);
 
 extern u16 wlc_lcnphy_tempsense(phy_info_t *pi, bool mode);
-extern int16 wlc_lcnphy_tempsense_new(phy_info_t *pi, bool mode);
+extern s16 wlc_lcnphy_tempsense_new(phy_info_t *pi, bool mode);
 extern s8 wlc_lcnphy_tempsense_degree(phy_info_t *pi, bool mode);
 extern s8 wlc_lcnphy_vbatsense(phy_info_t *pi, bool mode);
 extern void wlc_phy_carrier_suppress_lcnphy(phy_info_t *pi);
@@ -1171,7 +1171,7 @@ extern void wlc_phy_switch_radio_nphy(ph
 extern void wlc_phy_stf_chain_upd_nphy(phy_info_t *pi);
 
 extern void wlc_phy_force_rfseq_nphy(phy_info_t *pi, u8 cmd);
-extern int16 wlc_phy_tempsense_nphy(phy_info_t *pi);
+extern s16 wlc_phy_tempsense_nphy(phy_info_t *pi);
 
 extern u16 wlc_phy_classifier_nphy(phy_info_t *pi, u16 mask, u16 val);
 
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -165,13 +165,13 @@ typedef struct {
 
 typedef struct {
 	u8 chan;
-	int16 a;
-	int16 b;
+	s16 a;
+	s16 b;
 } lcnphy_rx_iqcomp_t;
 
 typedef struct {
-	int16 re;
-	int16 im;
+	s16 re;
+	s16 im;
 } lcnphy_spb_tone_t;
 
 typedef struct {
@@ -974,7 +974,7 @@ u16
 
 #define LCNPHY_IQLOCC_READ(val) ((u8)(-(s8)(((val) & 0xf0) >> 4) + (s8)((val) & 0x0f)))
 #define FIXED_TXPWR 78
-#define LCNPHY_TEMPSENSE(val) ((int16)((val > 255) ? (val - 512) : val))
+#define LCNPHY_TEMPSENSE(val) ((s16)((val > 255) ? (val - 512) : val))
 
 static uint32 wlc_lcnphy_qdiv_roundup(uint32 divident, uint32 divisor,
 				      u8 precision);
@@ -1010,14 +1010,14 @@ static void wlc_lcnphy_load_tx_gain_tabl
 					  const lcnphy_tx_gain_tbl_entry *g);
 
 static void wlc_lcnphy_samp_cap(phy_info_t *pi, int clip_detect_algo,
-				u16 thresh, int16 *ptr, int mode);
-static int wlc_lcnphy_calc_floor(int16 coeff, int type);
+				u16 thresh, s16 *ptr, int mode);
+static int wlc_lcnphy_calc_floor(s16 coeff, int type);
 static void wlc_lcnphy_tx_iqlo_loopback(phy_info_t *pi,
 					u16 *values_to_save);
 static void wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t *pi,
 						u16 *values_to_save);
-static void wlc_lcnphy_set_cc(phy_info_t *pi, int cal_type, int16 coeff_x,
-			      int16 coeff_y);
+static void wlc_lcnphy_set_cc(phy_info_t *pi, int cal_type, s16 coeff_x,
+			      s16 coeff_y);
 static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t *pi, int cal_type);
 static void wlc_lcnphy_a1(phy_info_t *pi, int cal_type,
 			  int num_levels, int step_size_lg2);
@@ -1034,7 +1034,7 @@ static void wlc_lcnphy_rc_cal(phy_info_t
 static void wlc_lcnphy_rcal(phy_info_t *pi);
 static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t *pi, bool enable);
 static int wlc_lcnphy_load_tx_iir_filter(phy_info_t *pi, bool is_ofdm,
-					 int16 filt_type);
+					 s16 filt_type);
 static void wlc_lcnphy_set_rx_iq_comp(phy_info_t *pi, u16 a, u16 b);
 
 void wlc_lcnphy_write_table(phy_info_t *pi, const phytbl_info_t *pti)
@@ -1104,7 +1104,7 @@ wlc_lcnphy_qdiv_roundup(uint32 dividend,
 	return quotient;
 }
 
-static int wlc_lcnphy_calc_floor(int16 coeff_x, int type)
+static int wlc_lcnphy_calc_floor(s16 coeff_x, int type)
 {
 	int k;
 	k = 0;
@@ -1699,7 +1699,7 @@ static void wlc_lcnphy_set_tx_pwr_soft_c
 static s8 wlc_lcnphy_tempcompensated_txpwrctrl(phy_info_t *pi)
 {
 	s8 index, delta_brd, delta_temp, new_index, tempcorrx;
-	int16 manp, meas_temp, temp_diff;
+	s16 manp, meas_temp, temp_diff;
 	bool neg = 0;
 	u16 temp;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -2795,7 +2795,7 @@ wlc_lcnphy_start_tx_tone(phy_info_t *pi,
 
 void wlc_lcnphy_stop_tx_tone(phy_info_t *pi)
 {
-	int16 playback_status;
+	s16 playback_status;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	pi->phy_tx_tone_freq = 0;
@@ -2975,10 +2975,10 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal
 		wlc_lcnphy_set_tx_pwr_by_index(pi, SAVE_txpwrindex);
 }
 
-int16 wlc_lcnphy_tempsense_new(phy_info_t *pi, bool mode)
+s16 wlc_lcnphy_tempsense_new(phy_info_t *pi, bool mode)
 {
 	u16 tempsenseval1, tempsenseval2;
-	int16 avg = 0;
+	s16 avg = 0;
 	bool suspend = 0;
 
 	if (NORADIO_ENAB(pi->pubpi))
@@ -2996,14 +2996,14 @@ int16 wlc_lcnphy_tempsense_new(phy_info_
 	tempsenseval2 = read_phy_reg(pi, 0x477) & 0x1FF;
 
 	if (tempsenseval1 > 255)
-		avg = (int16) (tempsenseval1 - 512);
+		avg = (s16) (tempsenseval1 - 512);
 	else
-		avg = (int16) tempsenseval1;
+		avg = (s16) tempsenseval1;
 
 	if (tempsenseval2 > 255)
-		avg += (int16) (tempsenseval2 - 512);
+		avg += (s16) (tempsenseval2 - 512);
 	else
-		avg += (int16) tempsenseval2;
+		avg += (s16) tempsenseval2;
 
 	avg /= 2;
 
@@ -3194,7 +3194,7 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 	u16 a0_new, b0_new;
 	lcnphy_iq_est_t iq_est = { 0, 0, 0 };
 	int32 a, b, temp;
-	int16 iq_nbits, qq_nbits, arsh, brsh;
+	s16 iq_nbits, qq_nbits, arsh, brsh;
 	int32 iq;
 	uint32 ii, qq;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -3289,10 +3289,10 @@ wlc_lcnphy_rx_iq_cal(phy_info_t *pi, con
 	uint32 received_power, rx_pwr_threshold;
 	u16 old_sslpnCalibClkEnCtrl, old_sslpnRxFeClkEnCtrl;
 	u16 values_to_save[11];
-	int16 *ptr;
+	s16 *ptr;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
-	ptr = MALLOC(pi->sh->osh, sizeof(int16) * 131);
+	ptr = MALLOC(pi->sh->osh, sizeof(s16) * 131);
 	if (NULL == ptr) {
 		return FALSE;
 	}
@@ -3440,7 +3440,7 @@ wlc_lcnphy_rx_iq_cal(phy_info_t *pi, con
 	}
 
  cal_done:
-	MFREE(pi->sh->osh, ptr, 131 * sizeof(int16));
+	MFREE(pi->sh->osh, ptr, 131 * sizeof(s16));
 	return result;
 }
 
@@ -3852,12 +3852,12 @@ wlc_lcnphy_tx_iqlo_loopback(phy_info_t *
 
 static void
 wlc_lcnphy_samp_cap(phy_info_t *pi, int clip_detect_algo, u16 thresh,
-		    int16 *ptr, int mode)
+		    s16 *ptr, int mode)
 {
 	uint32 curval1, curval2, stpptr, curptr, strptr, val;
 	u16 sslpnCalibClkEnCtrl, timer;
 	u16 old_sslpnCalibClkEnCtrl;
-	int16 imag, real;
+	s16 imag, real;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	timer = 0;
@@ -3950,7 +3950,7 @@ static void wlc_lcnphy_tx_iqlo_soft_cal_
 }
 
 static void
-wlc_lcnphy_set_cc(phy_info_t *pi, int cal_type, int16 coeff_x, int16 coeff_y)
+wlc_lcnphy_set_cc(phy_info_t *pi, int cal_type, s16 coeff_x, s16 coeff_y)
 {
 	u16 di0dq0;
 	u16 x, y, data_rf;
@@ -4036,8 +4036,8 @@ wlc_lcnphy_a1(phy_info_t *pi, int cal_ty
 	lcnphy_unsign16_struct phy_c3;
 	int phy_c4, phy_c5, k, l, j, phy_c6;
 	u16 phy_c7, phy_c8, phy_c9;
-	int16 phy_c10, phy_c11, phy_c12, phy_c13, phy_c14, phy_c15, phy_c16;
-	int16 *ptr, phy_c17;
+	s16 phy_c10, phy_c11, phy_c12, phy_c13, phy_c14, phy_c15, phy_c16;
+	s16 *ptr, phy_c17;
 	int32 phy_c18, phy_c19;
 	uint32 phy_c20, phy_c21;
 	bool phy_c22, phy_c23, phy_c24, phy_c25;
@@ -4047,7 +4047,7 @@ wlc_lcnphy_a1(phy_info_t *pi, int cal_ty
 	u16 *phy_c32;
 	phy_c21 = 0;
 	phy_c10 = phy_c13 = phy_c14 = phy_c8 = 0;
-	ptr = MALLOC(pi->sh->osh, sizeof(int16) * 131);
+	ptr = MALLOC(pi->sh->osh, sizeof(s16) * 131);
 	if (NULL == ptr) {
 		return;
 	}
@@ -4098,8 +4098,8 @@ wlc_lcnphy_a1(phy_info_t *pi, int cal_ty
 
 	phy_c7 = (1 << step_size_lg2);
 	phy_c3 = wlc_lcnphy_get_cc(pi, cal_type);
-	phy_c15 = (int16) phy_c3.re;
-	phy_c16 = (int16) phy_c3.im;
+	phy_c15 = (s16) phy_c3.re;
+	phy_c16 = (s16) phy_c3.im;
 	if (cal_type == 2) {
 		if (phy_c3.re > 127)
 			phy_c15 = phy_c3.re - 256;
@@ -4222,7 +4222,7 @@ wlc_lcnphy_a1(phy_info_t *pi, int cal_ty
 	write_radio_reg(pi, RADIO_2064_REG026, phy_c31);
 
 	MFREE(pi->sh->osh, phy_c32, 20 * sizeof(u16));
-	MFREE(pi->sh->osh, ptr, 131 * sizeof(int16));
+	MFREE(pi->sh->osh, ptr, 131 * sizeof(s16));
 }
 
 static void
@@ -4283,7 +4283,7 @@ static void wlc_lcnphy_load_rfpower(phy_
 	uint32 val, bbmult, rfgain;
 	u8 index;
 	u8 scale_factor = 1;
-	int16 temp, temp1, temp2, qQ, qQ1, qQ2, shift;
+	s16 temp, temp1, temp2, qQ, qQ1, qQ2, shift;
 
 	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
 	tab.tbl_width = 32;
@@ -4479,7 +4479,7 @@ static void WLBANDINITFN(wlc_lcnphy_rev2
 
 static void wlc_lcnphy_agc_temp_init(phy_info_t *pi)
 {
-	int16 temp;
+	s16 temp;
 	phytbl_info_t tab;
 	uint32 tableBuffer[2];
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -4487,7 +4487,7 @@ static void wlc_lcnphy_agc_temp_init(phy
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 
-	temp = (int16) read_phy_reg(pi, 0x4df);
+	temp = (s16) read_phy_reg(pi, 0x4df);
 	pi_lcn->lcnphy_ofdmgainidxtableoffset = (temp & (0xff << 0)) >> 0;
 
 	if (pi_lcn->lcnphy_ofdmgainidxtableoffset > 127)
@@ -4513,7 +4513,7 @@ static void wlc_lcnphy_agc_temp_init(phy
 		tableBuffer[1] -= 128;
 	pi_lcn->lcnphy_tr_T_gain_val = tableBuffer[1];
 
-	temp = (int16) (read_phy_reg(pi, 0x434)
+	temp = (s16) (read_phy_reg(pi, 0x434)
 			& (0xff << 0));
 	if (temp > 127)
 		temp -= 256;
@@ -4742,9 +4742,9 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 		pi_lcn->lcnphy_rx_power_offset =
 		    (u8) PHY_GETINTVAR(pi, "rxpo2g");
 
-		pi->txpa_2g[0] = (int16) PHY_GETINTVAR(pi, "pa0b0");
-		pi->txpa_2g[1] = (int16) PHY_GETINTVAR(pi, "pa0b1");
-		pi->txpa_2g[2] = (int16) PHY_GETINTVAR(pi, "pa0b2");
+		pi->txpa_2g[0] = (s16) PHY_GETINTVAR(pi, "pa0b0");
+		pi->txpa_2g[1] = (s16) PHY_GETINTVAR(pi, "pa0b1");
+		pi->txpa_2g[2] = (s16) PHY_GETINTVAR(pi, "pa0b2");
 
 		pi_lcn->lcnphy_rssi_vf = (u8) PHY_GETINTVAR(pi, "rssismf2g");
 		pi_lcn->lcnphy_rssi_vc = (u8) PHY_GETINTVAR(pi, "rssismc2g");
@@ -4838,8 +4838,8 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 	}
 	pi_lcn->lcnphy_cck_dig_filt_type = -1;
 	if (PHY_GETVAR(pi, "cckdigfilttype")) {
-		int16 temp;
-		temp = (int16) PHY_GETINTVAR(pi, "cckdigfilttype");
+		s16 temp;
+		temp = (s16) PHY_GETINTVAR(pi, "cckdigfilttype");
 		if (temp >= 0) {
 			pi_lcn->lcnphy_cck_dig_filt_type = temp;
 		}
@@ -5249,9 +5249,9 @@ int32 wlc_lcnphy_rx_signal_power(phy_inf
 }
 
 static int
-wlc_lcnphy_load_tx_iir_filter(phy_info_t *pi, bool is_ofdm, int16 filt_type)
+wlc_lcnphy_load_tx_iir_filter(phy_info_t *pi, bool is_ofdm, s16 filt_type)
 {
-	int16 filt_index = -1;
+	s16 filt_index = -1;
 	int j;
 
 	u16 addr[] = {
@@ -5295,7 +5295,7 @@ wlc_lcnphy_load_tx_iir_filter(phy_info_t
 	if (!is_ofdm) {
 		for (j = 0; j < LCNPHY_NUM_TX_DIG_FILTERS_CCK; j++) {
 			if (filt_type == LCNPHY_txdigfiltcoeffs_cck[j][0]) {
-				filt_index = (int16) j;
+				filt_index = (s16) j;
 				break;
 			}
 		}
@@ -5312,7 +5312,7 @@ wlc_lcnphy_load_tx_iir_filter(phy_info_t
 	} else {
 		for (j = 0; j < LCNPHY_NUM_TX_DIG_FILTERS_OFDM; j++) {
 			if (filt_type == LCNPHY_txdigfiltcoeffs_ofdm[j][0]) {
-				filt_index = (int16) j;
+				filt_index = (s16) j;
 				break;
 			}
 		}
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
@@ -47,9 +47,9 @@ struct phy_info_lcnphy {
 	u8 lcnphy_rssi_vc_hightemp;
 	u8 lcnphy_rssi_gs_hightemp;
 
-	int16 lcnphy_pa0b0;
-	int16 lcnphy_pa0b1;
-	int16 lcnphy_pa0b2;
+	s16 lcnphy_pa0b0;
+	s16 lcnphy_pa0b1;
+	s16 lcnphy_pa0b2;
 
 	u16 lcnphy_rawtempsense;
 	u8 lcnphy_measPower;
@@ -76,8 +76,8 @@ struct phy_info_lcnphy {
 	uint32 lcnphy_gain_idx_14_hiword;
 	uint32 lcnphy_gain_idx_27_lowword;
 	uint32 lcnphy_gain_idx_27_hiword;
-	int16 lcnphy_ofdmgainidxtableoffset;
-	int16 lcnphy_dsssgainidxtableoffset;
+	s16 lcnphy_ofdmgainidxtableoffset;
+	s16 lcnphy_dsssgainidxtableoffset;
 	uint32 lcnphy_tr_R_gain_val;
 	uint32 lcnphy_tr_T_gain_val;
 	s8 lcnphy_input_pwr_offset_db;
@@ -98,8 +98,8 @@ struct phy_info_lcnphy {
 	u16 lcnphy_extstxctrl4;
 	u16 lcnphy_extstxctrl0;
 	u16 lcnphy_extstxctrl1;
-	int16 lcnphy_cck_dig_filt_type;
-	int16 lcnphy_ofdm_dig_filt_type;
+	s16 lcnphy_cck_dig_filt_type;
+	s16 lcnphy_ofdm_dig_filt_type;
 	lcnphy_cal_results_t lcnphy_cal_results;
 
 	u8 lcnphy_psat_pwr;
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -13280,7 +13280,7 @@ radio_20xx_regs_t regs_2057_rev8[] = {
 	{0xFFFF, 0, 0}
 };
 
-static int16 nphy_def_lnagains[] = { -2, 10, 19, 25 };
+static s16 nphy_def_lnagains[] = { -2, 10, 19, 25 };
 
 static int32 nphy_lnagain_est0[] = { -315, 40370 };
 static int32 nphy_lnagain_est1[] = { -224, 23242 };
@@ -13724,21 +13724,21 @@ static s8 nphy_papd_pga_gain_delta_ipa_5
 	-48, -41, -33, -25, -19, -12, -6, 0
 };
 
-static int16 nphy_papd_padgain_dlt_2g_2057rev3n4[] = {
+static s16 nphy_papd_padgain_dlt_2g_2057rev3n4[] = {
 	-159, -113, -86, -72, -62, -54, -48, -43,
 	-39, -35, -31, -28, -25, -23, -20, -18,
 	-17, -15, -13, -11, -10, -8, -7, -6,
 	-5, -4, -3, -3, -2, -1, -1, 0
 };
 
-static int16 nphy_papd_padgain_dlt_2g_2057rev5[] = {
+static s16 nphy_papd_padgain_dlt_2g_2057rev5[] = {
 	-109, -109, -82, -68, -58, -50, -44, -39,
 	-35, -31, -28, -26, -23, -21, -19, -17,
 	-16, -14, -13, -11, -10, -9, -8, -7,
 	-5, -5, -4, -3, -2, -1, -1, 0
 };
 
-static int16 nphy_papd_padgain_dlt_2g_2057rev7[] = {
+static s16 nphy_papd_padgain_dlt_2g_2057rev7[] = {
 	-122, -122, -95, -80, -69, -61, -54, -49,
 	-43, -39, -35, -32, -28, -26, -23, -21,
 	-18, -16, -15, -13, -11, -10, -8, -7,
@@ -14706,8 +14706,8 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		uint32 *tx_pwrctrl_tbl = NULL;
 		u16 idx;
-		int16 pga_gn = 0;
-		int16 pad_gn = 0;
+		s16 pga_gn = 0;
+		s16 pad_gn = 0;
 		int32 rfpwr_offset = 0;
 
 		if (PHY_IPA(pi)) {
@@ -14769,17 +14769,17 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 					if ((pi->pubpi.radiorev == 3) ||
 					    (pi->pubpi.radiorev == 4) ||
 					    (pi->pubpi.radiorev == 6)) {
-						rfpwr_offset = (int16)
+						rfpwr_offset = (s16)
 						    nphy_papd_padgain_dlt_2g_2057rev3n4
 						    [pad_gn];
 					} else if (pi->pubpi.radiorev == 5) {
-						rfpwr_offset = (int16)
+						rfpwr_offset = (s16)
 						    nphy_papd_padgain_dlt_2g_2057rev5
 						    [pad_gn];
 					} else if ((pi->pubpi.radiorev == 7)
 						   || (pi->pubpi.radiorev ==
 						       8)) {
-						rfpwr_offset = (int16)
+						rfpwr_offset = (s16)
 						    nphy_papd_padgain_dlt_2g_2057rev7
 						    [pad_gn];
 					} else {
@@ -14790,13 +14790,13 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 					if ((pi->pubpi.radiorev == 3) ||
 					    (pi->pubpi.radiorev == 4) ||
 					    (pi->pubpi.radiorev == 6)) {
-						rfpwr_offset = (int16)
+						rfpwr_offset = (s16)
 						    nphy_papd_pgagain_dlt_5g_2057
 						    [pga_gn];
 					} else if ((pi->pubpi.radiorev == 7)
 						   || (pi->pubpi.radiorev ==
 						       8)) {
-						rfpwr_offset = (int16)
+						rfpwr_offset = (s16)
 						    nphy_papd_pgagain_dlt_5g_2057rev7
 						    [pga_gn];
 					} else {
@@ -14817,11 +14817,11 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 			for (idx = 0; idx < 128; idx++) {
 				pga_gn = (tx_pwrctrl_tbl[idx] >> 24) & 0xf;
 				if (CHSPEC_IS2G(pi->radio_chanspec)) {
-					rfpwr_offset = (int16)
+					rfpwr_offset = (s16)
 					    nphy_papd_pga_gain_delta_ipa_2g
 					    [pga_gn];
 				} else {
-					rfpwr_offset = (int16)
+					rfpwr_offset = (s16)
 					    nphy_papd_pga_gain_delta_ipa_5g
 					    [pga_gn];
 				}
@@ -15329,8 +15329,8 @@ static void wlc_phy_workarounds_nphy(phy
 	u8 rfseq_rx2tx_dlys_rev3_ipa[] = { 8, 6, 6, 4, 4, 16, 43, 1, 1 };
 	u16 rfseq_rx2tx_dacbufpu_rev7[] = { 0x10f, 0x10f };
 
-	int16 alpha0, alpha1, alpha2;
-	int16 beta0, beta1, beta2;
+	s16 alpha0, alpha1, alpha2;
+	s16 beta0, beta1, beta2;
 	uint32 leg_data_weights, ht_data_weights, nss1_data_weights,
 	    stbc_data_weights;
 	u8 chan_freq_range = 0;
@@ -17231,7 +17231,7 @@ static void wlc_phy_adjust_lnagaintbl_np
 {
 	uint core;
 	int ctr;
-	int16 gain_delta[2];
+	s16 gain_delta[2];
 	u8 curr_channel;
 	u16 minmax_gain[2];
 	u16 regval[4];
@@ -17248,12 +17248,12 @@ static void wlc_phy_adjust_lnagaintbl_np
 
 			curr_channel = CHSPEC_CHANNEL(pi->radio_chanspec);
 			gain_delta[0] =
-			    (int16)
+			    (s16)
 			    PHY_HW_ROUND(((nphy_lnagain_est0[0] *
 					   curr_channel) +
 					  nphy_lnagain_est0[1]), 13);
 			gain_delta[1] =
-			    (int16)
+			    (s16)
 			    PHY_HW_ROUND(((nphy_lnagain_est1[0] *
 					   curr_channel) +
 					  nphy_lnagain_est1[1]), 13);
@@ -20813,7 +20813,7 @@ int
 wlc_phy_poll_rssi_nphy(phy_info_t *pi, u8 rssi_type, int32 *rssi_buf,
 		       u8 nsamps)
 {
-	int16 rssi0, rssi1;
+	s16 rssi0, rssi1;
 	u16 afectrlCore1_save = 0;
 	u16 afectrlCore2_save = 0;
 	u16 afectrlOverride1_save = 0;
@@ -20909,7 +20909,7 @@ wlc_phy_poll_rssi_nphy(phy_info_t *pi, u
 	return rssi_out_val;
 }
 
-int16 wlc_phy_tempsense_nphy(phy_info_t *pi)
+s16 wlc_phy_tempsense_nphy(phy_info_t *pi)
 {
 	u16 core1_txrf_iqcal1_save, core1_txrf_iqcal2_save;
 	u16 core2_txrf_iqcal1_save, core2_txrf_iqcal2_save;
@@ -20924,7 +20924,7 @@ int16 wlc_phy_tempsense_nphy(phy_info_t
 	int32 radio_temp[4];
 	int32 radio_temp2[4];
 	u16 syn_tempprocsense_save;
-	int16 offset = 0;
+	s16 offset = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 		u16 auxADC_Vmid, auxADC_Av, auxADC_Vmid_save, auxADC_Av_save;
@@ -21077,7 +21077,7 @@ int16 wlc_phy_tempsense_nphy(phy_info_t
 					 128) / 256;
 		}
 
-		offset = (int16) pi->phy_tempsense_offset;
+		offset = (s16) pi->phy_tempsense_offset;
 
 	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		syn_tempprocsense_save =
@@ -21116,7 +21116,7 @@ int16 wlc_phy_tempsense_nphy(phy_info_t
 		write_phy_reg(pi, 0x8f, afectrlOverride_save);
 		write_phy_reg(pi, 0xa5, afectrlOverride2_save);
 
-		offset = (int16) pi->phy_tempsense_offset;
+		offset = (s16) pi->phy_tempsense_offset;
 	} else {
 
 		pwrdet_rxtx_core1_save =
@@ -21189,7 +21189,7 @@ int16 wlc_phy_tempsense_nphy(phy_info_t
 		write_phy_reg(pi, 0xa5, afectrlOverride_save);
 	}
 
-	return (int16) radio_temp[0] + offset;
+	return (s16) radio_temp[0] + offset;
 }
 
 static void
@@ -21470,8 +21470,8 @@ int BCMFASTPATH
 wlc_phy_rssi_compute_nphy(phy_info_t *pi, wlc_d11rxhdr_t *wlc_rxh)
 {
 	d11rxhdr_t *rxh = &wlc_rxh->rxhdr;
-	int16 rxpwr, rxpwr0, rxpwr1;
-	int16 phyRx0_l, phyRx2_l;
+	s16 rxpwr, rxpwr0, rxpwr1;
+	s16 phyRx0_l, phyRx2_l;
 
 	rxpwr = 0;
 	rxpwr0 = ltoh16(rxh->PhyRxStatus_1) & PRXS1_nphy_PWR0_MASK;
@@ -24571,7 +24571,7 @@ static void wlc_phy_calc_rx_iq_comp_nphy
 	nphy_iq_comp_t old_comp, new_comp;
 	int32 iq = 0;
 	uint32 ii = 0, qq = 0;
-	int16 iq_nbits, qq_nbits, brsh, arsh;
+	s16 iq_nbits, qq_nbits, brsh, arsh;
 	int32 a, b, temp;
 	int bcmerror = BCME_OK;
 	uint cal_retry = 0;
@@ -24652,22 +24652,22 @@ static void wlc_phy_calc_rx_iq_comp_nphy
 
 		if ((curr_core == PHY_CORE_0) && (core_mask & 0x1)) {
 			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
-				new_comp.a0 = (int16) a & 0x3ff;
-				new_comp.b0 = (int16) b & 0x3ff;
+				new_comp.a0 = (s16) a & 0x3ff;
+				new_comp.b0 = (s16) b & 0x3ff;
 			} else {
 
-				new_comp.a0 = (int16) b & 0x3ff;
-				new_comp.b0 = (int16) a & 0x3ff;
+				new_comp.a0 = (s16) b & 0x3ff;
+				new_comp.b0 = (s16) a & 0x3ff;
 			}
 		}
 		if ((curr_core == PHY_CORE_1) && (core_mask & 0x2)) {
 			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
-				new_comp.a1 = (int16) a & 0x3ff;
-				new_comp.b1 = (int16) b & 0x3ff;
+				new_comp.a1 = (s16) a & 0x3ff;
+				new_comp.b1 = (s16) b & 0x3ff;
 			} else {
 
-				new_comp.a1 = (int16) b & 0x3ff;
-				new_comp.b1 = (int16) a & 0x3ff;
+				new_comp.a1 = (s16) b & 0x3ff;
+				new_comp.b1 = (s16) a & 0x3ff;
 			}
 		}
 	}
@@ -25318,7 +25318,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 	nphy_iq_comp_t save_comp, zero_comp;
 	uint32 i_pwr, q_pwr, curr_pwr, optim_pwr = 0, prev_pwr = 0, thresh_pwr =
 	    10000;
-	int16 desired_log2_pwr, actual_log2_pwr, delta_pwr;
+	s16 desired_log2_pwr, actual_log2_pwr, delta_pwr;
 	bool gainctrl_done = FALSE;
 	u8 mix_tia_gain = 3;
 	s8 optim_gaintbl_index = 0, prev_gaintbl_index = 0;
@@ -25326,7 +25326,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 	u8 gainctrl_dirn = NPHY_RXCAL_GAIN_INIT;
 	nphy_ipa_txrxgain_t *nphy_rxcal_gaintbl;
 	u16 hpvga, lpf_biq1, lpf_biq0, lna2, lna1;
-	int16 fine_gain_idx;
+	s16 fine_gain_idx;
 	s8 txpwrindex;
 	u16 nphy_rxcal_txgain[2];
 
@@ -25929,8 +25929,8 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t *p
 	u16 lna_vals[] = { 0x3, 0x3, 0x1 };
 	u16 hpf1_vals[] = { 0x7, 0x2, 0x0 };
 	u16 hpf2_vals[] = { 0x2, 0x0, 0x0 };
-	int16 curr_hpf1, curr_hpf2, curr_hpf, curr_lna;
-	int16 desired_log2_pwr, actual_log2_pwr, hpf_change;
+	s16 curr_hpf1, curr_hpf2, curr_hpf, curr_lna;
+	s16 desired_log2_pwr, actual_log2_pwr, hpf_change;
 	u16 orig_RfseqCoreActv, orig_AfectrlCore, orig_AfectrlOverride;
 	u16 orig_RfctrlIntcRx, orig_RfctrlIntcTx;
 	u16 num_samps;
@@ -27241,9 +27241,9 @@ static void wlc_phy_a4(phy_info_t *pi, b
 	bool phy_b3;
 	u8 phy_b4;
 	u8 phy_b5;
-	int16 phy_b6, phy_b7, phy_b8;
+	s16 phy_b6, phy_b7, phy_b8;
 	u16 phy_b9;
-	int16 phy_b10, phy_b11, phy_b12;
+	s16 phy_b10, phy_b11, phy_b12;
 
 	phy_b11 = 0;
 	phy_b12 = 0;
@@ -27672,7 +27672,7 @@ void wlc_phy_txpwr_fixpower_nphy(phy_inf
 
 			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
 				    0x29b, (0x1ff << 4),
-				    ((int16) rfpwr_offset) << 4);
+				    ((s16) rfpwr_offset) << 4);
 
 			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
 				    0x29b, (0x1 << 2), (1) << 2);
@@ -27988,17 +27988,17 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_pwrctrl_info[PHY_CORE_1].max_pwr_2g =
 			    (s8) PHY_GETINTVAR(pi, "maxp2ga1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_2g_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa2gw0a0");
+			    (s16) PHY_GETINTVAR(pi, "pa2gw0a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_2g_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa2gw0a1");
+			    (s16) PHY_GETINTVAR(pi, "pa2gw0a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_2g_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa2gw1a0");
+			    (s16) PHY_GETINTVAR(pi, "pa2gw1a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_2g_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa2gw1a1");
+			    (s16) PHY_GETINTVAR(pi, "pa2gw1a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_2g_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa2gw2a0");
+			    (s16) PHY_GETINTVAR(pi, "pa2gw2a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_2g_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa2gw2a1");
+			    (s16) PHY_GETINTVAR(pi, "pa2gw2a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].idle_targ_2g =
 			    (s8) PHY_GETINTVAR(pi, "itt2ga0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].idle_targ_2g =
@@ -28028,17 +28028,17 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_pwrctrl_info[PHY_CORE_1].max_pwr_5gm =
 			    (s8) PHY_GETINTVAR(pi, "maxp5ga1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_5gm_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5gw0a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5gw0a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_5gm_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5gw0a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5gw0a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_5gm_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa5gw1a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5gw1a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_5gm_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa5gw1a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5gw1a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_5gm_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5gw2a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5gw2a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_5gm_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5gw2a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5gw2a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].idle_targ_5gm =
 			    (s8) PHY_GETINTVAR(pi, "itt5ga0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].idle_targ_5gm =
@@ -28066,17 +28066,17 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_pwrctrl_info[1].max_pwr_5gl =
 			    (s8) PHY_GETINTVAR(pi, "maxp5gla1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gl_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5glw0a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5glw0a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gl_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5glw0a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5glw0a1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gl_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa5glw1a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5glw1a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gl_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa5glw1a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5glw1a1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gl_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5glw2a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5glw2a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gl_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5glw2a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5glw2a1");
 			pi->nphy_pwrctrl_info[0].idle_targ_5gl = 0;
 			pi->nphy_pwrctrl_info[1].idle_targ_5gl = 0;
 
@@ -28110,17 +28110,17 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_pwrctrl_info[1].max_pwr_5gh =
 			    (s8) PHY_GETINTVAR(pi, "maxp5gha1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gh_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5ghw0a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5ghw0a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gh_a1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5ghw0a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5ghw0a1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gh_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa5ghw1a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5ghw1a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gh_b0 =
-			    (int16) PHY_GETINTVAR(pi, "pa5ghw1a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5ghw1a1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gh_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5ghw2a0");
+			    (s16) PHY_GETINTVAR(pi, "pa5ghw2a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gh_b1 =
-			    (int16) PHY_GETINTVAR(pi, "pa5ghw2a1");
+			    (s16) PHY_GETINTVAR(pi, "pa5ghw2a1");
 			pi->nphy_pwrctrl_info[0].idle_targ_5gh = 0;
 			pi->nphy_pwrctrl_info[1].idle_targ_5gh = 0;
 
@@ -28178,7 +28178,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 
 	wlc_phy_txpower_ipa_upd(pi);
 
-	pi->phy_txcore_disable_temp = (int16) PHY_GETINTVAR(pi, "tempthresh");
+	pi->phy_txcore_disable_temp = (s16) PHY_GETINTVAR(pi, "tempthresh");
 	if (pi->phy_txcore_disable_temp == 0) {
 		pi->phy_txcore_disable_temp = PHY_CHAIN_TX_DISABLE_TEMP;
 	}
@@ -28479,7 +28479,7 @@ static void wlc_phy_txpwrctrl_idle_tssi_
 static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t *pi)
 {
 	uint32 idx;
-	int16 a1[2], b0[2], b1[2];
+	s16 a1[2], b0[2], b1[2];
 	s8 target_pwr_qtrdbm[2];
 	int32 num, den, pwr_est;
 	u8 chan_freq_range;
@@ -29142,7 +29142,7 @@ wlc_phy_txpwr_index_nphy(phy_info_t *pi,
 
 				mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
 					    0x29b, (0x1ff << 4),
-					    ((int16) rfpwr_offset) << 4);
+					    ((s16) rfpwr_offset) << 4);
 
 				mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
 					    0x29b, (0x1 << 2), (1) << 2);
--- a/drivers/staging/brcm80211/sys/wlc_bsscfg.h
+++ b/drivers/staging/brcm80211/sys/wlc_bsscfg.h
@@ -74,8 +74,8 @@ struct wlc_bsscfg {
 
 	/* security */
 	uint32 wsec;		/* wireless security bitvec */
-	int16 auth;		/* 802.11 authentication: Open, Shared Key, WPA */
-	int16 openshared;	/* try Open auth first, then Shared Key */
+	s16 auth;		/* 802.11 authentication: Open, Shared Key, WPA */
+	s16 openshared;	/* try Open auth first, then Shared Key */
 	bool wsec_restrict;	/* drop unencrypted packets if wsec is enabled */
 	bool eap_restrict;	/* restrict data until 802.1X auth succeeds */
 	u16 WPA_auth;	/* WPA: authenticated key management */
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -790,7 +790,7 @@ void wlc_switch_shortslot(wlc_info_t *wl
 static u8 wlc_local_constraint_qdbm(wlc_info_t *wlc)
 {
 	u8 local;
-	int16 local_max;
+	s16 local_max;
 
 	local = WLC_TXPWR_MAX;
 	if (wlc->pub->associated &&
@@ -5795,7 +5795,7 @@ u16 BCMFASTPATH wlc_phytxctl1_calc(wlc_i
 		/* 0 = 1Mbps; 1 = 2Mbps; 2 = 5.5Mbps; 3 = 11Mbps */
 		phyctl1 = (bw | (RSPEC_STF(rspec) << PHY_TXC1_MODE_SHIFT));
 	} else {		/* legacy OFDM/CCK */
-		int16 phycfg;
+		s16 phycfg;
 		/* get the phyctl byte from rate phycfg table */
 		phycfg = wlc_rate_legacy_phyctl(RSPEC2RATE(rspec));
 		if (phycfg == -1) {
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.h
@@ -317,7 +317,7 @@ typedef struct wlccore {
 
 	/* fifo */
 	uint *txavail[NFIFO];	/* # tx descriptors available */
-	int16 txpktpend[NFIFO];	/* tx admission control */
+	s16 txpktpend[NFIFO];	/* tx admission control */
 #endif				/* WLC_LOW */
 
 	macstat_t *macstat_snapshot;	/* mac hw prev read values */
--- a/drivers/staging/brcm80211/sys/wlc_pub.h
+++ b/drivers/staging/brcm80211/sys/wlc_pub.h
@@ -169,8 +169,8 @@ typedef struct wlc_bss_info {
 	u16 flags;		/* flags for internal attributes */
 	u8 SSID_len;		/* the length of SSID */
 	u8 SSID[32];		/* SSID string */
-	int16 RSSI;		/* receive signal strength (in dBm) */
-	int16 SNR;		/* receive signal SNR in dB */
+	s16 RSSI;		/* receive signal strength (in dBm) */
+	s16 SNR;		/* receive signal SNR in dB */
 	u16 beacon_period;	/* units are Kusec */
 	u16 atim_window;	/* units are Kusec */
 	chanspec_t chanspec;	/* Channel num, bw, ctrl_sb and band */
--- a/drivers/staging/brcm80211/sys/wlc_rate.c
+++ b/drivers/staging/brcm80211/sys/wlc_rate.c
@@ -467,7 +467,7 @@ wlc_rateset_default(wlc_rateset_t *rs_tg
 					   mcsallow ? txstreams : 1);
 }
 
-int16 BCMFASTPATH wlc_rate_legacy_phyctl(uint rate)
+s16 BCMFASTPATH wlc_rate_legacy_phyctl(uint rate)
 {
 	uint i;
 	for (i = 0; i < LEGACY_PHYCFG_TABLE_SIZE; i++)
--- a/drivers/staging/brcm80211/sys/wlc_rate.h
+++ b/drivers/staging/brcm80211/sys/wlc_rate.h
@@ -160,7 +160,7 @@ extern void wlc_rateset_default(struct w
 				const struct wlc_rateset *rs_hw, uint phy_type,
 				int bandtype, bool cck_only, uint rate_mask,
 				bool mcsallow, u8 bw, u8 txstreams);
-extern int16 wlc_rate_legacy_phyctl(uint rate);
+extern s16 wlc_rate_legacy_phyctl(uint rate);
 
 extern void wlc_rateset_mcs_upd(struct wlc_rateset *rs, u8 txstreams);
 extern void wlc_rateset_mcs_clear(struct wlc_rateset *rateset);
--- a/drivers/staging/brcm80211/util/linux_osl.c
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -75,7 +75,7 @@ struct osl_info {
 /* Global ASSERT type flag */
 uint32 g_assert_type;
 
-static int16 linuxbcmerrormap[] = { 0,	/* 0 */
+static s16 linuxbcmerrormap[] = { 0,	/* 0 */
 	-EINVAL,		/* BCME_ERROR */
 	-EINVAL,		/* BCME_BADARG */
 	-EINVAL,		/* BCME_BADOPTION */
--- a/drivers/staging/brcm80211/util/qmath.c
+++ b/drivers/staging/brcm80211/util/qmath.c
@@ -22,15 +22,15 @@ If input number is greater than 0x7fff t
 else if input number is less than 0xffff8000 then output is saturated to 0xffff8000
 else output is same as input.
 */
-int16 qm_sat32(int32 op)
+s16 qm_sat32(int32 op)
 {
-	int16 result;
+	s16 result;
 	if (op > (int32) 0x7fff) {
 		result = 0x7fff;
 	} else if (op < (int32) 0xffff8000) {
-		result = (int16) (0x8000);
+		result = (s16) (0x8000);
 	} else {
-		result = (int16) op;
+		result = (s16) op;
 	}
 	return result;
 }
@@ -41,7 +41,7 @@ This multiplication is similar to compil
 16 bit multiplication on the processor platform is cheaper than 32 bit multiplication (as
 the most of qmath functions can be replaced with processor intrinsic instructions).
 */
-int32 qm_mul321616(int16 op1, int16 op2)
+int32 qm_mul321616(s16 op1, s16 op2)
 {
 	return (int32) (op1) * (int32) (op2);
 }
@@ -51,11 +51,11 @@ Description: This function make 16 bit m
 To fit the result into 16 bits the 32 bit multiplication result is right
 shifted by 16 bits.
 */
-int16 qm_mul16(int16 op1, int16 op2)
+s16 qm_mul16(s16 op1, s16 op2)
 {
 	int32 result;
 	result = ((int32) (op1) * (int32) (op2));
-	return (int16) (result >> 16);
+	return (s16) (result >> 16);
 }
 
 /*
@@ -65,10 +65,10 @@ This function remove the extra sign bit
 twice that of compiler multiplication. (i.e. qm_muls321616(2,3)=12).
 When both input 16 bit numbers are 0x8000, then the result is saturated to 0x7fffffff.
 */
-int32 qm_muls321616(int16 op1, int16 op2)
+int32 qm_muls321616(s16 op1, s16 op2)
 {
 	int32 result;
-	if (op1 == (int16) (0x8000) && op2 == (int16) (0x8000)) {
+	if (op1 == (s16) (0x8000) && op2 == (s16) (0x8000)) {
 		result = 0x7fffffff;
 	} else {
 		result = ((int32) (op1) * (int32) (op2));
@@ -93,15 +93,15 @@ To fit the multiplication result into 16
 due to the multiplication.
 When both the 16bit inputs are 0x8000 then the output is saturated to 0x7fffffff.
 */
-int16 qm_muls16(int16 op1, int16 op2)
+s16 qm_muls16(s16 op1, s16 op2)
 {
 	int32 result;
-	if (op1 == (int16) 0x8000 && op2 == (int16) 0x8000) {
+	if (op1 == (s16) 0x8000 && op2 == (s16) 0x8000) {
 		result = 0x7fffffff;
 	} else {
 		result = ((int32) (op1) * (int32) (op2));
 	}
-	return (int16) (result >> 15);
+	return (s16) (result >> 15);
 }
 
 /*
@@ -124,16 +124,16 @@ int32 qm_add32(int32 op1, int32 op2)
 Description: This function add two 16 bit numbers and return the 16bit result.
 If the result overflow 16 bits, the output will be saturated to 16bits.
 */
-int16 qm_add16(int16 op1, int16 op2)
+s16 qm_add16(s16 op1, s16 op2)
 {
-	int16 result;
+	s16 result;
 	int32 temp = (int32) op1 + (int32) op2;
 	if (temp > (int32) 0x7fff) {
-		result = (int16) 0x7fff;
+		result = (s16) 0x7fff;
 	} else if (temp < (int32) 0xffff8000) {
-		result = (int16) 0xffff8000;
+		result = (s16) 0xffff8000;
 	} else {
-		result = (int16) temp;
+		result = (s16) temp;
 	}
 	return result;
 }
@@ -142,16 +142,16 @@ int16 qm_add16(int16 op1, int16 op2)
 Description: This function make 16 bit subtraction and return the 16bit result.
 If the result overflow 16 bits, the output will be saturated to 16bits.
 */
-int16 qm_sub16(int16 op1, int16 op2)
+s16 qm_sub16(s16 op1, s16 op2)
 {
-	int16 result;
+	s16 result;
 	int32 temp = (int32) op1 - (int32) op2;
 	if (temp > (int32) 0x7fff) {
-		result = (int16) 0x7fff;
+		result = (s16) 0x7fff;
 	} else if (temp < (int32) 0xffff8000) {
-		result = (int16) 0xffff8000;
+		result = (s16) 0xffff8000;
 	} else {
-		result = (int16) temp;
+		result = (s16) temp;
 	}
 	return result;
 }
@@ -177,7 +177,7 @@ Description: This function multiply inpu
 into the input 32 bit number and return the 32 bit accumulated result.
 If the accumulation result in overflow, then the output will be saturated.
 */
-int32 qm_mac321616(int32 acc, int16 op1, int16 op2)
+int32 qm_mac321616(int32 acc, s16 op1, s16 op2)
 {
 	int32 result;
 	result = qm_add32(acc, qm_mul321616(op1, op2));
@@ -223,10 +223,10 @@ Description: This function make a 16 bit
 is +ve. This function will make a 16 bit right shift when the specified shift is -ve.
 This function return the result after shifting operation.
 */
-int16 qm_shl16(int16 op, int shift)
+s16 qm_shl16(s16 op, int shift)
 {
 	int i;
-	int16 result;
+	s16 result;
 	result = op;
 	if (shift > 15)
 		shift = 15;
@@ -247,7 +247,7 @@ Description: This function make a 16 bit
 This function make a 16 bit saturated left shift when shift is -ve. This function
 return the result of the shift operation.
 */
-int16 qm_shr16(int16 op, int shift)
+s16 qm_shr16(s16 op, int shift)
 {
 	return qm_shl16(op, -shift);
 }
@@ -256,7 +256,7 @@ int16 qm_shr16(int16 op, int shift)
 Description: This function return the number of redundant sign bits in a 16 bit number.
 Example: qm_norm16(0x0080) = 7.
 */
-int16 qm_norm16(int16 op)
+s16 qm_norm16(s16 op)
 {
 	u16 u16extraSignBits;
 	if (op == 0) {
@@ -275,7 +275,7 @@ int16 qm_norm16(int16 op)
 Description: This function return the number of redundant sign bits in a 32 bit number.
 Example: qm_norm32(0x00000080) = 23
 */
-int16 qm_norm32(int32 op)
+s16 qm_norm32(int32 op)
 {
 	u16 u16extraSignBits;
 	if (op == 0) {
@@ -295,10 +295,10 @@ Description: This function divide two 16
 The numerator should be less than denominator. So the quotient is always less than 1.
 This function return the quotient in q.15 format.
 */
-int16 qm_div_s(int16 num, int16 denom)
+s16 qm_div_s(s16 num, s16 denom)
 {
-	int16 var_out;
-	int16 iteration;
+	s16 var_out;
+	s16 iteration;
 	int32 L_num;
 	int32 L_denom;
 	L_num = (num) << 15;
@@ -310,17 +310,17 @@ int16 qm_div_s(int16 num, int16 denom)
 			L_num = qm_add32(L_num, 1);
 		}
 	}
-	var_out = (int16) (L_num & 0x7fff);
+	var_out = (s16) (L_num & 0x7fff);
 	return var_out;
 }
 
 /*
 Description: This function compute the absolute value of a 16 bit number.
 */
-int16 qm_abs16(int16 op)
+s16 qm_abs16(s16 op)
 {
 	if (op < 0) {
-		if (op == (int16) 0xffff8000) {
+		if (op == (s16) 0xffff8000) {
 			return 0x7fff;
 		} else {
 			return -op;
@@ -337,10 +337,10 @@ The qformat of the quotient is returned
 to this function. The qformat of quotient is adjusted appropriately such that
 the quotient occupies all 16 bits.
 */
-int16 qm_div16(int16 num, int16 denom, int16 *qQuotient)
+s16 qm_div16(s16 num, s16 denom, s16 *qQuotient)
 {
-	int16 sign;
-	int16 nNum, nDenom;
+	s16 sign;
+	s16 nNum, nDenom;
 	sign = num ^ denom;
 	num = qm_abs16(num);
 	denom = qm_abs16(denom);
@@ -380,10 +380,10 @@ The qformat of the quotient is returned
 to this function. The qformat of quotient is adjusted appropriately such that
 the quotient occupies all 16 bits.
 */
-int16 qm_div163232(int32 num, int32 denom, int16 *qquotient)
+s16 qm_div163232(int32 num, int32 denom, s16 *qquotient)
 {
 	int32 sign;
-	int16 nNum, nDenom;
+	s16 nNum, nDenom;
 	sign = num ^ denom;
 	num = qm_abs32(num);
 	denom = qm_abs32(denom);
@@ -393,9 +393,9 @@ int16 qm_div163232(int32 num, int32 deno
 	denom = qm_shl32(denom, nDenom);
 	*qquotient = nNum - 1 - nDenom + 15;
 	if (sign >= 0) {
-		return qm_div_s((int16) (num >> 16), (int16) (denom >> 16));
+		return qm_div_s((s16) (num >> 16), (s16) (denom >> 16));
 	} else {
-		return -qm_div_s((int16) (num >> 16), (int16) (denom >> 16));
+		return -qm_div_s((s16) (num >> 16), (s16) (denom >> 16));
 	}
 }
 
@@ -404,13 +404,13 @@ Description: This function multiply a 32
 The multiplicaton result is right shifted by 16 bits to fit the result
 into 32 bit output.
 */
-int32 qm_mul323216(int32 op1, int16 op2)
+int32 qm_mul323216(int32 op1, s16 op2)
 {
-	int16 hi;
+	s16 hi;
 	u16 lo;
 	int32 result;
 	hi = op1 >> 16;
-	lo = (int16) (op1 & 0xffff);
+	lo = (s16) (op1 & 0xffff);
 	result = qm_mul321616(hi, op2);
 	result = result + (qm_mulsu321616(op2, lo) >> 16);
 	return result;
@@ -420,7 +420,7 @@ int32 qm_mul323216(int32 op1, int16 op2)
 Description: This function multiply signed 16 bit number with unsigned 16 bit number and return
 the result in 32 bits.
 */
-int32 qm_mulsu321616(int16 op1, u16 op2)
+int32 qm_mulsu321616(s16 op1, u16 op2)
 {
 	return (int32) (op1) * op2;
 }
@@ -431,13 +431,13 @@ right shifted by 15 bits to fit the resu
 16 bits is done to remove the extra sign bit formed by multiplication from the return value.
 When the input numbers are 0x80000000, 0x8000 the return value is saturated to 0x7fffffff.
 */
-int32 qm_muls323216(int32 op1, int16 op2)
+int32 qm_muls323216(int32 op1, s16 op2)
 {
-	int16 hi;
+	s16 hi;
 	u16 lo;
 	int32 result;
 	hi = op1 >> 16;
-	lo = (int16) (op1 & 0xffff);
+	lo = (s16) (op1 & 0xffff);
 	result = qm_muls321616(hi, op2);
 	result = qm_add32(result, (qm_mulsu321616(op2, lo) >> 15));
 	return result;
@@ -450,7 +450,7 @@ multiplication result is returned as out
 */
 int32 qm_mul32(int32 a, int32 b)
 {
-	int16 hi1, hi2;
+	s16 hi1, hi2;
 	u16 lo1, lo2;
 	int32 result;
 	hi1 = a >> 16;
@@ -473,7 +473,7 @@ When the input numbers are 0x80000000, 0
 */
 int32 qm_muls32(int32 a, int32 b)
 {
-	int16 hi1, hi2;
+	s16 hi1, hi2;
 	u16 lo1, lo2;
 	int32 result;
 	hi1 = a >> 16;
@@ -488,7 +488,7 @@ int32 qm_muls32(int32 a, int32 b)
 }
 
 /* This table is log2(1+(i/32)) where i=[0:1:31], in q.15 format */
-static const int16 log_table[] = {
+static const s16 log_table[] = {
 	0,
 	1455,
 	2866,
@@ -545,9 +545,9 @@ qLog10N - address where log10N qformat w
 Note/Problem:
 For accurate results input should be in normalized or near normalized form.
 */
-void qm_log10(int32 N, int16 qN, int16 *log10N, int16 *qLog10N)
+void qm_log10(int32 N, s16 qN, s16 *log10N, s16 *qLog10N)
 {
-	int16 s16norm, s16tableIndex, s16errorApproximation;
+	s16 s16norm, s16tableIndex, s16errorApproximation;
 	u16 u16offset;
 	int32 s32log;
 
@@ -569,11 +569,11 @@ void qm_log10(int32 N, int16 qN, int16 *
 	qN = qN + s16norm - 30;
 
 	/* take the table index as the LOG2_OF_LOG_TABLE_SIZE bits right of the MSB */
-	s16tableIndex = (int16) (N >> (32 - (2 + LOG2_LOG_TABLE_SIZE)));
+	s16tableIndex = (s16) (N >> (32 - (2 + LOG2_LOG_TABLE_SIZE)));
 
 	/* remove the MSB. the MSB is always 1 after normalization. */
 	s16tableIndex =
-	    s16tableIndex & (int16) ((1 << LOG2_LOG_TABLE_SIZE) - 1);
+	    s16tableIndex & (s16) ((1 << LOG2_LOG_TABLE_SIZE) - 1);
 
 	/* remove the (1+LOG2_OF_LOG_TABLE_SIZE) MSBs in the N. */
 	N = N & ((1 << (32 - (2 + LOG2_LOG_TABLE_SIZE))) - 1);
@@ -586,9 +586,9 @@ void qm_log10(int32 N, int16 qN, int16 *
 	s32log = log_table[s16tableIndex];	/* q.15 format */
 
 	/* interpolate using the offset. */
-	s16errorApproximation = (int16) qm_mulu16(u16offset, (u16) (log_table[s16tableIndex + 1] - log_table[s16tableIndex]));	/* q.15 */
+	s16errorApproximation = (s16) qm_mulu16(u16offset, (u16) (log_table[s16tableIndex + 1] - log_table[s16tableIndex]));	/* q.15 */
 
-	s32log = qm_add16((int16) s32log, s16errorApproximation);	/* q.15 format */
+	s32log = qm_add16((s16) s32log, s16errorApproximation);	/* q.15 format */
 
 	/* adjust for the qformat of the N as
 	 * log2(mag * 2^x) = log2(mag) + x
@@ -605,7 +605,7 @@ void qm_log10(int32 N, int16 qN, int16 *
 	 * as log10(mag * 2^x) = log2(mag * 2^x) * log10(2)
 	 * log10N in q.15+s16norm-16+1 (LOG10_2 is in q.16)
 	 */
-	*log10N = qm_muls16((int16) s32log, (int16) LOG10_2);
+	*log10N = qm_muls16((s16) s32log, (s16) LOG10_2);
 
 	/* write the q format of the result. */
 	*qLog10N = 15 + s16norm - 16 + 1;
@@ -631,9 +631,9 @@ sqrtN - address where 1/N has to be writ
 qsqrtN - address where q format of 1/N has to be written.
 */
 #define qx 29
-void qm_1byN(int32 N, int16 qN, int32 *result, int16 *qResult)
+void qm_1byN(int32 N, s16 qN, int32 *result, s16 *qResult)
 {
-	int16 normN;
+	s16 normN;
 	int32 s32firstTerm, s32secondTerm, x;
 	int i;
 
@@ -657,11 +657,11 @@ void qm_1byN(int32 N, int16 qN, int32 *r
 	for (i = 0; i < 4; i++) {
 		s32firstTerm = qm_shl32(x, 1);	/* s32firstTerm = 2*x in q.29 */
 		s32secondTerm =
-		    qm_muls321616((int16) (s32firstTerm >> 16),
-				  (int16) (s32firstTerm >> 16));
+		    qm_muls321616((s16) (s32firstTerm >> 16),
+				  (s16) (s32firstTerm >> 16));
 		/* s32secondTerm = x*x in q.(29+1-16)*2+1 */
 		s32secondTerm =
-		    qm_muls321616((int16) (s32secondTerm >> 16), (int16) N);
+		    qm_muls321616((s16) (s32secondTerm >> 16), (s16) N);
 		/* s32secondTerm = N*x*x in q.((29+1-16)*2+1)-16+15+1 i.e. in q.29 */
 		x = qm_sub32(s32firstTerm, s32secondTerm);
 		/* can be added directly as both are in q.29 */

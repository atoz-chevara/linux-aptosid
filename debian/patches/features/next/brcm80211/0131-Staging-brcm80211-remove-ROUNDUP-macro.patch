commit e18d5313c680e5bb8cbdc0dce8f8698c2ab20663
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:59:06 2010 -0700

    Staging: brcm80211: remove ROUNDUP macro
    
    And use the kernel provided 'roundup' instead.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
@@ -359,7 +359,7 @@ extern void bcmsdh_enable_hw_oob_intr(vo
 	do {								\
 		uint datalign;						\
 		datalign = (uintptr)PKTDATA((p));		\
-		datalign = ROUNDUP(datalign, (align)) - datalign;	\
+		datalign = roundup(datalign, (align)) - datalign;	\
 		ASSERT(datalign < (align));				\
 		ASSERT(PKTLEN((p)) >= ((len) + datalign));	\
 		if (datalign)						\
@@ -1000,7 +1000,7 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 #ifdef NOTUSED
 		if (PKTTAILROOM(pkt))
 #endif
-			len = ROUNDUP(len, ALIGNMENT);
+			len = roundup(len, ALIGNMENT);
 #ifdef NOTUSED
 		else
 			DHD_ERROR(("%s: sending unrounded %d-byte packet\n",
@@ -1263,7 +1263,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 
 	/* Satisfy length-alignment requirements */
 	if (forcealign && (len & (ALIGNMENT - 1)))
-		len = ROUNDUP(len, ALIGNMENT);
+		len = roundup(len, ALIGNMENT);
 
 	ASSERT(IS_ALIGNED((uintptr) frame, 2));
 
@@ -2522,7 +2522,7 @@ static int dhdsdio_write_vars(dhd_bus_t
 
 	/* Even if there are no vars are to be written, we still
 		 need to set the ramsize. */
-	varsize = bus->varsz ? ROUNDUP(bus->varsz, 4) : 0;
+	varsize = bus->varsz ? roundup(bus->varsz, 4) : 0;
 	varaddr = (bus->ramsize - 4) - varsize;
 
 	if (bus->vars) {
@@ -3117,7 +3117,7 @@ dhdsdio_read_control(dhd_bus_t *bus, u8
 
 	/* Satisfy length-alignment requirements */
 	if (forcealign && (rdlen & (ALIGNMENT - 1)))
-		rdlen = ROUNDUP(rdlen, ALIGNMENT);
+		rdlen = roundup(rdlen, ALIGNMENT);
 
 	/* Drop if the read is too big or it exceeds our maximum */
 	if ((rdlen + firstread) > bus->dhd->maxctl) {
@@ -3229,8 +3229,8 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 				 is a block multiple */
 			if (!dlen) {
 				sublen +=
-				    (ROUNDUP(totlen, bus->blocksize) - totlen);
-				totlen = ROUNDUP(totlen, bus->blocksize);
+				    (roundup(totlen, bus->blocksize) - totlen);
+				totlen = roundup(totlen, bus->blocksize);
 			}
 
 			/* Allocate/chain packet for next subframe */
@@ -3380,11 +3380,11 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 			DHD_ERROR(("%s (superframe): HW hdr error: len/check "
 				"0x%04x/0x%04x\n", __func__, sublen, check));
 			errcode = -1;
-		} else if (ROUNDUP(sublen, bus->blocksize) != dlen) {
+		} else if (roundup(sublen, bus->blocksize) != dlen) {
 			DHD_ERROR(("%s (superframe): len 0x%04x, rounded "
 				"0x%04x, expect 0x%04x\n",
 				__func__, sublen,
-				ROUNDUP(sublen, bus->blocksize), dlen));
+				roundup(sublen, bus->blocksize), dlen));
 			errcode = -1;
 		} else if (SDPCM_PACKET_CHANNEL(&dptr[SDPCM_FRAMETAG_LEN]) !=
 			   SDPCM_GLOM_CHANNEL) {
@@ -3806,13 +3806,13 @@ static uint dhdsdio_readframes(dhd_bus_t
 			}
 
 			/* Check for consistency withreadahead info */
-			len_consistent = (nextlen != (ROUNDUP(len, 16) >> 4));
+			len_consistent = (nextlen != (roundup(len, 16) >> 4));
 			if (len_consistent) {
 				/* Mismatch, force retry w/normal
 					header (may be >4K) */
 				DHD_ERROR(("%s (nextlen): mismatch, nextlen %d len %d rnd %d; " "expected rxseq %d\n",
 					__func__, nextlen,
-					len, ROUNDUP(len, 16), rxseq));
+					len, roundup(len, 16), rxseq));
 				dhd_os_sdlock_rxq(bus->dhd);
 				PKTFREE2();
 				dhd_os_sdunlock_rxq(bus->dhd);
@@ -4072,7 +4072,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 
 		/* Satisfy length-alignment requirements */
 		if (forcealign && (rdlen & (ALIGNMENT - 1)))
-			rdlen = ROUNDUP(rdlen, ALIGNMENT);
+			rdlen = roundup(rdlen, ALIGNMENT);
 
 		if ((rdlen + firstread) > MAX_RX_DATASZ) {
 			/* Too long -- skip this frame */
@@ -5364,7 +5364,7 @@ dhdsdio_probe_attach(struct dhd_bus *bus
 	pktq_init(&bus->txq, (PRIOMASK + 1), QLEN);
 
 	/* Locate an appropriately-aligned portion of hdrbuf */
-	bus->rxhdr = (u8 *) ROUNDUP((uintptr)&bus->hdrbuf[0], DHD_SDALIGN);
+	bus->rxhdr = (u8 *) roundup((uintptr)&bus->hdrbuf[0], DHD_SDALIGN);
 
 	/* Set the poll and/or interrupt flags */
 	bus->intr = (bool) dhd_intr;
@@ -5385,7 +5385,7 @@ static bool dhdsdio_probe_malloc(dhd_bus
 #ifndef DHD_USE_STATIC_BUF
 	if (bus->dhd->maxctl) {
 		bus->rxblen =
-		    ROUNDUP((bus->dhd->maxctl + SDPCM_HDRLEN),
+		    roundup((bus->dhd->maxctl + SDPCM_HDRLEN),
 			    ALIGNMENT) + DHD_SDALIGN;
 		bus->rxbuf = MALLOC(osh, bus->rxblen);
 		if (!(bus->rxbuf)) {
@@ -5408,7 +5408,7 @@ static bool dhdsdio_probe_malloc(dhd_bus
 #else
 	if (bus->dhd->maxctl) {
 		bus->rxblen =
-		    ROUNDUP((bus->dhd->maxctl + SDPCM_HDRLEN),
+		    roundup((bus->dhd->maxctl + SDPCM_HDRLEN),
 			    ALIGNMENT) + DHD_SDALIGN;
 		bus->rxbuf = dhd_os_prealloc(DHD_PREALLOC_RXBUF, bus->rxblen);
 		if (!(bus->rxbuf)) {
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -450,7 +450,6 @@ extern "C" {
 #endif				/* ABS */
 
 #define CEIL(x, y)		(((x) + ((y)-1)) / (y))
-#define	ROUNDUP(x, y)		((((x)+((y)-1))/(y))*(y))
 #define	ISPOWEROF2(x)		((((x)-1)&(x)) == 0)
 #define VALID_MASK(mask)	(!((mask) & ((mask) + 1)))
 
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -2201,7 +2201,7 @@ void wlc_phy_txpower_update_shm(phy_info
 
 		for (i = TXP_FIRST_OFDM; i <= TXP_LAST_OFDM; i++)
 			pi->tx_power_offset[i] =
-			    (u8) ROUNDUP(pi->tx_power_offset[i], 8);
+			    (u8) roundup(pi->tx_power_offset[i], 8);
 		wlapi_bmac_write_shm(pi->sh->physhim, M_OFDM_OFFSET,
 				     (u16) ((pi->
 						tx_power_offset[TXP_FIRST_OFDM]
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -662,7 +662,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 			mcl &= ~(TXC_STARTMSDU | TXC_SENDRTS | TXC_SENDCTS);
 		}
 
-		len = ROUNDUP(len, 4);
+		len = roundup(len, 4);
 		ampdu_len += (len + (ndelim + 1) * AMPDU_DELIMITER_LEN);
 
 		dma_len += (u16) pkttotlen(osh, p);
@@ -806,7 +806,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 		fbr_iscck = ((ltoh16(txh->XtraFrameTypes) & 0x3) == 0);
 		len = fbr_iscck ? WLC_GET_CCK_PLCP_LEN(txh->FragPLCPFallback)
 		    : WLC_GET_MIMO_PLCP_LEN(txh->FragPLCPFallback);
-		ampdu_len -= ROUNDUP(len, 4) - len;
+		ampdu_len -= roundup(len, 4) - len;
 
 		/* patch up the first txh & plcp */
 		txh = (d11txh_t *) PKTDATA(pkt[0]);
--- a/drivers/staging/brcm80211/sys/wlc_event.c
+++ b/drivers/staging/brcm80211/sys/wlc_event.c
@@ -47,7 +47,7 @@ struct wlc_eventq {
 	bool workpending;
 	struct wl_timer *timer;
 	wlc_eventq_cb_t cb;
-	u8 event_inds_mask[ROUNDUP(WLC_E_LAST, NBBY) / NBBY];
+	u8 event_inds_mask[roundup(WLC_E_LAST, NBBY) / NBBY];
 };
 
 /*
--- a/drivers/staging/brcm80211/sys/wlc_key.h
+++ b/drivers/staging/brcm80211/sys/wlc_key.h
@@ -106,7 +106,7 @@ typedef struct wsec_key {
 } wsec_key_t;
 
 typedef struct {
-	u8 vec[ROUNDUP(WSEC_MAX_KEYS, NBBY) / NBBY];	/* bitvec of wsec_key indexes */
+	u8 vec[roundup(WSEC_MAX_KEYS, NBBY) / NBBY];	/* bitvec of wsec_key indexes */
 } wsec_key_vec_t;
 
 /* For use with wsec_key_t.flags */
--- a/drivers/staging/brcm80211/sys/wlc_pub.h
+++ b/drivers/staging/brcm80211/sys/wlc_pub.h
@@ -92,7 +92,7 @@
 
 #define RXBUFSZ		PKTBUFSZ
 #ifndef AIDMAPSZ
-#define AIDMAPSZ	(ROUNDUP(MAXSCB, NBBY)/NBBY)	/* aid bitmap size in bytes */
+#define AIDMAPSZ	(roundup(MAXSCB, NBBY)/NBBY)	/* aid bitmap size in bytes */
 #endif				/* AIDMAPSZ */
 
 typedef struct wlc_tunables {
--- a/drivers/staging/brcm80211/sys/wlc_rpc.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpc.h
@@ -362,9 +362,9 @@ static __inline char *_wlc_rpc_id_lookup
 #endif				/* BCMDBG */
 
 /* refer to txpwr_limits_t for each elements, mcs32 is the at the end for 1 byte */
-#define TXPOWER_XDR_SZ	(ROUNDUP(WLC_NUM_RATES_CCK, 4) + ROUNDUP(WLC_NUM_RATES_OFDM, 4) * 4 + \
-	ROUNDUP(WLC_NUM_RATES_MCS_1_STREAM, 4) * 6 + ROUNDUP(WLC_NUM_RATES_MCS_2_STREAM, 4) * 2 + \
-	ROUNDUP(1, 4))
+#define TXPOWER_XDR_SZ	(roundup(WLC_NUM_RATES_CCK, 4) + roundup(WLC_NUM_RATES_OFDM, 4) * 4 + \
+	roundup(WLC_NUM_RATES_MCS_1_STREAM, 4) * 6 + roundup(WLC_NUM_RATES_MCS_2_STREAM, 4) * 2 + \
+	roundup(1, 4))
 
 #define wlc_rpc_txpwr_limits(b, txpwr, op, err)	\
 	do {											\
--- a/drivers/staging/brcm80211/util/bcmotp.c
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -152,7 +152,7 @@ static otpinfo_t otpinfo;
 #define OTPGU_P_SHIFT		(OTPGU_HWP_OFF % 16)
 
 /* OTP Size */
-#define OTP_SZ_FU_324		((ROUNDUP(324, 8))/8)	/* 324 bits */
+#define OTP_SZ_FU_324		((roundup(324, 8))/8)	/* 324 bits */
 #define OTP_SZ_FU_288		(288/8)	/* 288 bits */
 #define OTP_SZ_FU_216		(216/8)	/* 216 bits */
 #define OTP_SZ_FU_72		(72/8)	/* 72 bits */
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -1418,7 +1418,7 @@ static void *dma_ringalloc(osl_t *osh, u
 	if (NULL == va)
 		return NULL;
 
-	desc_strtaddr = (u32) ROUNDUP((uintptr) va, alignbytes);
+	desc_strtaddr = (u32) roundup((uintptr) va, alignbytes);
 	if (((desc_strtaddr + size - 1) & boundary) != (desc_strtaddr
 							& boundary)) {
 		*alignbits = dma_align_sizetobits(size);
@@ -1543,7 +1543,7 @@ static bool dma32_alloc(dma_info_t *di,
 
 		PHYSADDRHISET(di->txdpa, 0);
 		ASSERT(PHYSADDRHI(di->txdpaorig) == 0);
-		di->txd32 = (dma32dd_t *) ROUNDUP((uintptr) va, align);
+		di->txd32 = (dma32dd_t *) roundup((uintptr) va, align);
 		di->txdalign =
 		    (uint) ((s8 *)di->txd32 - (s8 *) va);
 
@@ -1564,7 +1564,7 @@ static bool dma32_alloc(dma_info_t *di,
 
 		PHYSADDRHISET(di->rxdpa, 0);
 		ASSERT(PHYSADDRHI(di->rxdpaorig) == 0);
-		di->rxd32 = (dma32dd_t *) ROUNDUP((uintptr) va, align);
+		di->rxd32 = (dma32dd_t *) roundup((uintptr) va, align);
 		di->rxdalign =
 		    (uint) ((s8 *)di->rxd32 - (s8 *) va);
 
@@ -2109,7 +2109,7 @@ static bool dma64_alloc(dma_info_t *di,
 			return FALSE;
 		}
 		align = (1 << align_bits);
-		di->txd64 = (dma64dd_t *) ROUNDUP((uintptr) va, align);
+		di->txd64 = (dma64dd_t *) roundup((uintptr) va, align);
 		di->txdalign = (uint) ((s8 *)di->txd64 - (s8 *) va);
 		PHYSADDRLOSET(di->txdpa,
 			      PHYSADDRLO(di->txdpaorig) + di->txdalign);
@@ -2127,7 +2127,7 @@ static bool dma64_alloc(dma_info_t *di,
 			return FALSE;
 		}
 		align = (1 << align_bits);
-		di->rxd64 = (dma64dd_t *) ROUNDUP((uintptr) va, align);
+		di->rxd64 = (dma64dd_t *) roundup((uintptr) va, align);
 		di->rxdalign = (uint) ((s8 *)di->rxd64 - (s8 *) va);
 		PHYSADDRLOSET(di->rxdpa,
 			      PHYSADDRLO(di->rxdpaorig) + di->rxdalign);

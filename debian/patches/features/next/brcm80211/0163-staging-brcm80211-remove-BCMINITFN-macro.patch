commit b4f790eeb36564c7e4a5b38712f23ebc2b64b45a
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Mon Oct 11 10:02:58 2010 -0400

    staging: brcm80211: remove BCMINITFN() macro.
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/include/bcmdefs.h
+++ b/drivers/staging/brcm80211/include/bcmdefs.h
@@ -34,7 +34,6 @@
  * The following macros specify special linker sections that can be reclaimed
  * after a system is considered 'up'.
  */
-#define BCMINITFN(_fn)		_fn
 #define BCMUNINITFN(_fn)	_fn
 #define	BCMNMIATTACHFN(_fn)	_fn
 #ifdef mips
--- a/drivers/staging/brcm80211/include/bcmnvram.h
+++ b/drivers/staging/brcm80211/include/bcmnvram.h
@@ -75,7 +75,7 @@ extern char *nvram_get(const char *name)
  * Read the reset GPIO value from the nvram and set the GPIO
  * as input
  */
-extern int BCMINITFN(nvram_resetgpio_init) (void *sih);
+extern int nvram_resetgpio_init(void *sih);
 
 /*
  * Get the value of an NVRAM variable.
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -1031,7 +1031,7 @@ void WLBANDINITFN(wlc_phy_init) (wlc_phy
 	pi->init_in_progress = FALSE;
 }
 
-void BCMINITFN(wlc_phy_cal_init) (wlc_phy_t *pih)
+void wlc_phy_cal_init(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	initfn_t cal_init = NULL;
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -1119,7 +1119,7 @@ int wlc_bmac_detach(wlc_info_t *wlc)
 
 }
 
-void BCMINITFN(wlc_bmac_reset) (wlc_hw_info_t *wlc_hw)
+void wlc_bmac_reset(wlc_hw_info_t *wlc_hw)
 {
 	WL_TRACE(("wl%d: wlc_bmac_reset\n", wlc_hw->unit));
 
@@ -1136,7 +1136,7 @@ void BCMINITFN(wlc_bmac_reset) (wlc_hw_i
 }
 
 void
-BCMINITFN(wlc_bmac_init) (wlc_hw_info_t *wlc_hw, chanspec_t chanspec,
+wlc_bmac_init(wlc_hw_info_t *wlc_hw, chanspec_t chanspec,
 			  bool mute) {
 	u32 macintmask;
 	bool fastclk;
@@ -1187,7 +1187,7 @@ BCMINITFN(wlc_bmac_init) (wlc_hw_info_t
 		wlc_clkctl_clk(wlc_hw, CLK_DYNAMIC);
 }
 
-int BCMINITFN(wlc_bmac_up_prep) (wlc_hw_info_t *wlc_hw)
+int wlc_bmac_up_prep(wlc_hw_info_t *wlc_hw)
 {
 	uint coremask;
 
@@ -1235,7 +1235,7 @@ int BCMINITFN(wlc_bmac_up_prep) (wlc_hw_
 	return 0;
 }
 
-int BCMINITFN(wlc_bmac_up_finish) (wlc_hw_info_t *wlc_hw)
+int wlc_bmac_up_finish(wlc_hw_info_t *wlc_hw)
 {
 	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
 
@@ -1456,7 +1456,7 @@ static void wlc_clkctl_clk(wlc_hw_info_t
 
 /* set initial host flags value */
 static void
-BCMINITFN(wlc_mhfdef) (wlc_info_t *wlc, u16 *mhfs, u16 mhf2_init)
+wlc_mhfdef(wlc_info_t *wlc, u16 *mhfs, u16 mhf2_init)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 
@@ -2176,7 +2176,7 @@ static bool wlc_validboardtype(wlc_hw_in
 	return goodboard;
 }
 
-static char *BCMINITFN(wlc_get_macaddr) (wlc_hw_info_t *wlc_hw)
+static char *wlc_get_macaddr(wlc_hw_info_t *wlc_hw)
 {
 	const char *varname = "macaddr";
 	char *macaddr;
@@ -2251,7 +2251,7 @@ bool wlc_bmac_radio_read_hwdisabled(wlc_
 }
 
 /* Initialize just the hardware when coming out of POR or S3/S5 system states */
-void BCMINITFN(wlc_bmac_hw_up) (wlc_hw_info_t *wlc_hw)
+void wlc_bmac_hw_up(wlc_hw_info_t *wlc_hw)
 {
 	if (wlc_hw->wlc->pub->hw_up)
 		return;
@@ -2326,7 +2326,7 @@ static bool wlc_dma_rxreset(wlc_hw_info_
  *   clear software macintstatus for fresh new start
  * one testing hack wlc_hw->noreset will bypass the d11/phy reset
  */
-void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t *wlc_hw, u32 flags)
+void wlc_bmac_corereset(wlc_hw_info_t *wlc_hw, u32 flags)
 {
 	d11regs_t *regs;
 	uint i;
@@ -2415,7 +2415,7 @@ void BCMINITFN(wlc_bmac_corereset) (wlc_
  * txfifo sizes needs to be modified(increased) since the newer cores
  * have more memory.
  */
-static void BCMINITFN(wlc_corerev_fifofixup) (wlc_hw_info_t *wlc_hw)
+static void wlc_corerev_fifofixup(wlc_hw_info_t *wlc_hw)
 {
 	d11regs_t *regs = wlc_hw->regs;
 	u16 fifo_nu;
@@ -2475,7 +2475,7 @@ static void BCMINITFN(wlc_corerev_fifofi
  *   config other core registers
  *   init dma
  */
-static void BCMINITFN(wlc_coreinit) (wlc_info_t *wlc)
+static void wlc_coreinit(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs;
@@ -2717,7 +2717,7 @@ void wlc_bmac_switch_macfreq(wlc_hw_info
 }
 
 /* Initialize GPIOs that are controlled by D11 core */
-static void BCMINITFN(wlc_gpio_init) (wlc_info_t *wlc)
+static void wlc_gpio_init(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs;
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -381,7 +381,7 @@ bool wlc_ps_allowed(wlc_info_t *wlc)
 	return TRUE;
 }
 
-void BCMINITFN(wlc_reset) (wlc_info_t *wlc)
+void wlc_reset(wlc_info_t *wlc)
 {
 	WL_TRACE(("wl%d: wlc_reset\n", wlc->pub->unit));
 
@@ -428,7 +428,7 @@ void wlc_fatal_error(wlc_info_t *wlc)
  * if other configurations are in conflict (bandlocked, 11n mode disabled,
  * invalid channel for current country, etc.)
  */
-static chanspec_t BCMINITFN(wlc_init_chanspec) (wlc_info_t *wlc)
+static chanspec_t wlc_init_chanspec(wlc_info_t *wlc)
 {
 	chanspec_t chanspec =
 	    1 | WL_CHANSPEC_BW_20 | WL_CHANSPEC_CTL_SB_NONE |
@@ -452,7 +452,7 @@ static void wlc_init_scb(wlc_info_t *wlc
 		scb->seqnum[i] = 0;
 }
 
-void BCMINITFN(wlc_init) (wlc_info_t *wlc)
+void wlc_init(wlc_info_t *wlc)
 {
 	d11regs_t *regs;
 	chanspec_t chanspec;
@@ -2719,7 +2719,7 @@ static void wlc_watchdog(void *arg)
 }
 
 /* make interface operational */
-int BCMINITFN(wlc_up) (wlc_info_t *wlc)
+int wlc_up(wlc_info_t *wlc)
 {
 	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __func__));
 
@@ -2827,7 +2827,7 @@ int BCMINITFN(wlc_up) (wlc_info_t *wlc)
 }
 
 /* Initialize the base precedence map for dequeueing from txq based on WME settings */
-static void BCMINITFN(wlc_tx_prec_map_init) (wlc_info_t *wlc)
+static void wlc_tx_prec_map_init(wlc_info_t *wlc)
 {
 	wlc->tx_prec_map = WLC_PREC_BMP_ALL;
 	bzero(wlc->fifo2prec_map, sizeof(u16) * NFIFO);
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -184,7 +184,7 @@ void si_pmu_set_ldo_voltage(si_t *sih, o
 /* d11 slow to fast clock transition time in slow clock cycles */
 #define D11SCC_SLOW2FAST_TRANSITION	2
 
-u16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t *sih, osl_t *osh)
+u16 si_pmu_fast_pwrup_delay(si_t *sih, osl_t *osh)
 {
 	uint delay = PMU_MAX_TRANSITION_DLY;
 	chipcregs_t *cc;
@@ -1092,7 +1092,7 @@ static const pmu1_xtaltab0_t pmu1_xtalta
 #define PMU1_XTALTAB0_960_48000K	15
 
 /* select xtal table for each chip */
-static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaltab0) (si_t *sih)
+static const pmu1_xtaltab0_t *si_pmu1_xtaltab0(si_t *sih)
 {
 #ifdef BCMDBG
 	char chn[8];
@@ -1119,7 +1119,7 @@ static const pmu1_xtaltab0_t *BCMINITFN(
 }
 
 /* select default xtal frequency for each chip */
-static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaldef0) (si_t *sih)
+static const pmu1_xtaltab0_t *si_pmu1_xtaldef0(si_t *sih)
 {
 #ifdef BCMDBG
 	char chn[8];
@@ -1151,7 +1151,7 @@ static const pmu1_xtaltab0_t *BCMINITFN(
 }
 
 /* select default pll fvco for each chip */
-static u32 BCMINITFN(si_pmu1_pllfvco0) (si_t *sih)
+static u32 si_pmu1_pllfvco0(si_t *sih)
 {
 #ifdef BCMDBG
 	char chn[8];
@@ -1180,7 +1180,7 @@ static u32 BCMINITFN(si_pmu1_pllfvco0) (
 
 /* query alp/xtal clock frequency */
 static u32
-BCMINITFN(si_pmu1_alpclk0) (si_t *sih, osl_t *osh, chipcregs_t *cc)
+si_pmu1_alpclk0(si_t *sih, osl_t *osh, chipcregs_t *cc)
 {
 	const pmu1_xtaltab0_t *xt;
 	u32 xf;
@@ -1450,7 +1450,7 @@ static void si_pmu1_pllinit0(si_t *sih,
 
 /* query the CPU clock frequency */
 static u32
-BCMINITFN(si_pmu1_cpuclk0) (si_t *sih, osl_t *osh, chipcregs_t *cc)
+si_pmu1_cpuclk0(si_t *sih, osl_t *osh, chipcregs_t *cc)
 {
 	u32 tmp, m1div;
 #ifdef BCMDBG
@@ -1557,7 +1557,7 @@ void si_pmu_pll_init(si_t *sih, osl_t *o
 }
 
 /* query alp/xtal clock frequency */
-u32 BCMINITFN(si_pmu_alp_clock) (si_t *sih, osl_t *osh)
+u32 si_pmu_alp_clock(si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -1618,7 +1618,7 @@ u32 BCMINITFN(si_pmu_alp_clock) (si_t *s
  * pllreg "pll0" i.e. 12 for main 6 for phy, 0 for misc.
  */
 static u32
-BCMINITFN(si_pmu5_clock) (si_t *sih, osl_t *osh, chipcregs_t *cc, uint pll0,
+si_pmu5_clock(si_t *sih, osl_t *osh, chipcregs_t *cc, uint pll0,
 			  uint m) {
 	u32 tmp, div, ndiv, p1, p2, fc;
 
@@ -1671,7 +1671,7 @@ BCMINITFN(si_pmu5_clock) (si_t *sih, osl
 /* For designs that feed the same clock to both backplane
  * and CPU just return the CPU clock speed.
  */
-u32 BCMINITFN(si_pmu_si_clock) (si_t *sih, osl_t *osh)
+u32 si_pmu_si_clock(si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -1750,7 +1750,7 @@ u32 BCMINITFN(si_pmu_si_clock) (si_t *si
 }
 
 /* query CPU clock frequency */
-u32 BCMINITFN(si_pmu_cpu_clock) (si_t *sih, osl_t *osh)
+u32 si_pmu_cpu_clock(si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -1794,7 +1794,7 @@ u32 BCMINITFN(si_pmu_cpu_clock) (si_t *s
 }
 
 /* query memory clock frequency */
-u32 BCMINITFN(si_pmu_mem_clock) (si_t *sih, osl_t *osh)
+u32 si_pmu_mem_clock(si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -1843,7 +1843,7 @@ u32 BCMINITFN(si_pmu_mem_clock) (si_t *s
 
 static u32 ilpcycles_per_sec;
 
-u32 BCMINITFN(si_pmu_ilp_clock) (si_t *sih, osl_t *osh)
+u32 si_pmu_ilp_clock(si_t *sih, osl_t *osh)
 {
 	if (ISSIM_ENAB(sih))
 		return ILP_CLOCK;
@@ -1907,7 +1907,7 @@ static const sdiod_drive_str_t sdiod_dri
 #define SDIOD_DRVSTR_KEY(chip, pmu)	(((chip) << 16) | (pmu))
 
 void
-BCMINITFN(si_sdiod_drive_strength_init) (si_t *sih, osl_t *osh,
+si_sdiod_drive_strength_init(si_t *sih, osl_t *osh,
 					 u32 drivestrength) {
 	chipcregs_t *cc;
 	uint origidx, intr_val = 0;
@@ -2010,7 +2010,7 @@ void si_pmu_init(si_t *sih, osl_t *osh)
 
 /* Return up time in ILP cycles for the given resource. */
 static uint
-BCMINITFN(si_pmu_res_uptime) (si_t *sih, osl_t *osh, chipcregs_t *cc,
+si_pmu_res_uptime(si_t *sih, osl_t *osh, chipcregs_t *cc,
 			      u8 rsrc) {
 	u32 deps;
 	uint up, i, dup, dmax;
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -545,7 +545,7 @@ static void pcie_war_serdes(pcicore_info
 
 /* Fix MISC config to allow coming out of L2/L3-Ready state w/o PRST */
 /* Needs to happen when coming out of 'standby'/'hibernate' */
-static void BCMINITFN(pcie_misc_config_fixup) (pcicore_info_t *pi)
+static void pcie_misc_config_fixup(pcicore_info_t *pi)
 {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	u16 val16, *reg16;
--- a/drivers/staging/brcm80211/util/nvram/nvram_ro.c
+++ b/drivers/staging/brcm80211/util/nvram/nvram_ro.c
@@ -47,7 +47,7 @@ static char *findvar(char *vars, char *l
 
 #if defined(FLASH)
 /* copy flash to ram */
-static void BCMINITFN(get_flash_nvram) (si_t *sih, struct nvram_header *nvh)
+static void get_flash_nvram(si_t *sih, struct nvram_header *nvh)
 {
 	osl_t *osh;
 	uint nvs, bufsz;
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -67,7 +67,7 @@ static void si_nvram_process(si_info_t *
 static char *si_devpathvar(si_t *sih, char *var, int len, const char *name);
 static bool _si_clkctl_cc(si_info_t *sii, uint mode);
 static bool si_ispcie(si_info_t *sii);
-static uint BCMINITFN(socram_banksize) (si_info_t *sii, sbsocramregs_t *r,
+static uint socram_banksize(si_info_t *sii, sbsocramregs_t *r,
 					u8 idx, u8 mtype);
 
 /* global variable to indicate reservation/release of gpio's */
@@ -996,7 +996,7 @@ void si_core_reset(si_t *sih, u32 bits,
 #endif
 }
 
-u32 BCMINITFN(si_alp_clock) (si_t *sih)
+u32 si_alp_clock(si_t *sih)
 {
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_alp_clock(sih, si_osh(sih));
@@ -1004,7 +1004,7 @@ u32 BCMINITFN(si_alp_clock) (si_t *sih)
 	return ALP_CLOCK;
 }
 
-u32 BCMINITFN(si_ilp_clock) (si_t *sih)
+u32 si_ilp_clock(si_t *sih)
 {
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_ilp_clock(sih, si_osh(sih));
@@ -1146,7 +1146,7 @@ static uint si_slowclk_freq(si_info_t *s
 	return 0;
 }
 
-static void BCMINITFN(si_clkctl_setdelay) (si_info_t *sii, void *chipcregs)
+static void si_clkctl_setdelay(si_info_t *sii, void *chipcregs)
 {
 	chipcregs_t *cc = (chipcregs_t *) chipcregs;
 	uint slowmaxfreq, pll_delay, slowclk;
@@ -1174,7 +1174,7 @@ static void BCMINITFN(si_clkctl_setdelay
 }
 
 /* initialize power control delay registers */
-void BCMINITFN(si_clkctl_init) (si_t *sih)
+void si_clkctl_init(si_t *sih)
 {
 	si_info_t *sii;
 	uint origidx = 0;
@@ -1210,7 +1210,7 @@ void BCMINITFN(si_clkctl_init) (si_t *si
 }
 
 /* return the value suitable for writing to the dot11 core FAST_PWRUP_DELAY register */
-u16 BCMINITFN(si_clkctl_fast_pwrup_delay) (si_t *sih)
+u16 si_clkctl_fast_pwrup_delay(si_t *sih)
 {
 	si_info_t *sii;
 	uint origidx = 0;
@@ -1612,7 +1612,7 @@ bool si_pci_war16165(si_t *sih)
 	return PCI(sii) && (sih->buscorerev <= 10);
 }
 
-void BCMINITFN(si_pci_up) (si_t *sih)
+void si_pci_up(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -1641,7 +1641,7 @@ void BCMUNINITFN(si_pci_sleep) (si_t *si
 }
 
 /* Unconfigure and/or apply various WARs when going down */
-void BCMINITFN(si_pci_down) (si_t *sih)
+void si_pci_down(si_t *sih)
 {
 	si_info_t *sii;
 

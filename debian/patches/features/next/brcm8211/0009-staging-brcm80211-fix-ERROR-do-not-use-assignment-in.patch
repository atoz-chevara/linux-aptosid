commit ca8c1e5990926406708d99fe1ce2a6f5e12f9033
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:33 2010 -0400

    staging: brcm80211: fix "ERROR: do not use assignment in if condition"
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -172,7 +172,8 @@ int phy_getintvar(phy_info_t *pi, const
 {
 	char *val;
 
-	if ((val = PHY_GETVAR(pi, name)) == NULL)
+	val = PHY_GETVAR(pi, name);
+	if (val == NULL)
 		return 0;
 
 	return bcm_strtoul(val, NULL, 0);
@@ -549,8 +550,8 @@ shared_phy_t *BCMATTACHFN(wlc_phy_shared
 {
 	shared_phy_t *sh;
 
-	if ((sh =
-	     (shared_phy_t *) MALLOC(shp->osh, sizeof(shared_phy_t))) == NULL) {
+	sh = (shared_phy_t *) MALLOC(shp->osh, sizeof(shared_phy_t));
+	if (sh == NULL) {
 		return NULL;
 	}
 	bzero((char *)sh, sizeof(shared_phy_t));
@@ -619,14 +620,16 @@ wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (
 		}
 	}
 
-	if ((sflags & SISF_DB_PHY) && (pi = sh->phy_head)) {
+	pi = sh->phy_head;
+	if ((sflags & SISF_DB_PHY) && pi) {
 
 		wlapi_bmac_corereset(pi->sh->physhim, pi->pubpi.coreflags);
 		pi->refcnt++;
 		return &pi->pubpi_ro;
 	}
 
-	if ((pi = (phy_info_t *) MALLOC(osh, sizeof(phy_info_t))) == NULL) {
+	pi = (phy_info_t *) MALLOC(osh, sizeof(phy_info_t));
+	if (pi == NULL) {
 		return NULL;
 	}
 	bzero((char *)pi, sizeof(phy_info_t));
@@ -744,9 +747,10 @@ wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (
 
 	if (ISNPHY(pi)) {
 
-		if (!(pi->phycal_timer = wlapi_init_timer(pi->sh->physhim,
+		pi->phycal_timer = wlapi_init_timer(pi->sh->physhim,
 							  wlc_phy_timercb_phycal,
-							  pi, "phycal"))) {
+							  pi, "phycal");
+		if (!pi->phycal_timer) {
 			goto err;
 		}
 
@@ -3014,9 +3018,12 @@ void wlc_phy_BSSinit(wlc_phy_t *pih, boo
 void
 wlc_phy_papd_decode_epsilon(uint32 epsilon, int32 *eps_real, int32 *eps_imag)
 {
-	if ((*eps_imag = (epsilon >> 13)) > 0xfff)
+	*eps_imag = (epsilon >> 13);
+	if (*eps_imag > 0xfff)
 		*eps_imag -= 0x2000;
-	if ((*eps_real = (epsilon & 0x1fff)) > 0xfff)
+
+	*eps_real = (epsilon & 0x1fff);
+	if (*eps_real > 0xfff)
 		*eps_real -= 0x2000;
 }
 
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -1882,7 +1882,8 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t *pi,
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 
-	if (NULL == (values_to_save = MALLOC(pi->sh->osh, sizeof(uint16) * 20))) {
+	values_to_save = MALLOC(pi->sh->osh, sizeof(uint16) * 20);
+	if (NULL == values_to_save) {
 		return;
 	}
 
@@ -3203,7 +3204,8 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 
 	wlc_lcnphy_set_rx_iq_comp(pi, 0, 0);
 
-	if (!(result = wlc_lcnphy_rx_iq_est(pi, num_samps, 32, &iq_est)))
+	result = wlc_lcnphy_rx_iq_est(pi, num_samps, 32, &iq_est);
+	if (!result)
 		goto cleanup;
 
 	iq = (int32) iq_est.iq_prod;
@@ -3287,7 +3289,8 @@ wlc_lcnphy_rx_iq_cal(phy_info_t *pi, con
 	int16 *ptr;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
-	if (NULL == (ptr = MALLOC(pi->sh->osh, sizeof(int16) * 131))) {
+	ptr = MALLOC(pi->sh->osh, sizeof(int16) * 131);
+	if (NULL == ptr) {
 		return FALSE;
 	}
 	if (module == 2) {
@@ -3587,8 +3590,9 @@ void wlc_lcnphy_get_tssi(phy_info_t *pi,
 {
 	int8 cck_offset;
 	uint16 status;
+	status = (read_phy_reg(pi, 0x4ab));
 	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi) &&
-	    ((status = (read_phy_reg(pi, 0x4ab))) & (0x1 << 15))) {
+	    (status  & (0x1 << 15))) {
 		*ofdm_pwr = (int8) (((read_phy_reg(pi, 0x4ab) & (0x1ff << 0))
 				     >> 0) >> 1);
 
@@ -4040,11 +4044,13 @@ wlc_lcnphy_a1(phy_info_t *pi, int cal_ty
 	uint16 *phy_c32;
 	phy_c21 = 0;
 	phy_c10 = phy_c13 = phy_c14 = phy_c8 = 0;
-	if (NULL == (ptr = MALLOC(pi->sh->osh, sizeof(int16) * 131))) {
+	ptr = MALLOC(pi->sh->osh, sizeof(int16) * 131);
+	if (NULL == ptr) {
 		return;
 	}
 
-	if (NULL == (phy_c32 = MALLOC(pi->sh->osh, sizeof(uint16) * 20))) {
+	phy_c32 = MALLOC(pi->sh->osh, sizeof(uint16) * 20);
+	if (NULL == phy_c32) {
 		return;
 	}
 	phy_c26 = read_phy_reg(pi, 0x6da);
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -22357,9 +22357,8 @@ wlc_phy_gen_load_samples_nphy(phy_info_t
 		tbl_len = (phy_bw << 1);
 	}
 
-	if ((tone_buf =
-	     (cint32 *) MALLOC(pi->sh->osh,
-			       sizeof(cint32) * tbl_len)) == NULL) {
+	tone_buf = (cint32 *) MALLOC(pi->sh->osh, sizeof(cint32) * tbl_len);
+	if (tone_buf == NULL) {
 		return 0;
 	}
 
@@ -22393,9 +22392,9 @@ wlc_phy_tx_tone_nphy(phy_info_t *pi, uin
 	uint16 loops = 0xffff;
 	uint16 wait = 0;
 
-	if ((num_samps =
-	     wlc_phy_gen_load_samples_nphy(pi, f_kHz, max_val,
-					   dac_test_mode)) == 0) {
+	num_samps =
+		wlc_phy_gen_load_samples_nphy(pi, f_kHz, max_val, dac_test_mode);
+	if (num_samps == 0) {
 		return BCME_ERROR;
 	}
 
@@ -22412,9 +22411,8 @@ wlc_phy_loadsampletable_nphy(phy_info_t
 	uint16 t;
 	uint32 *data_buf = NULL;
 
-	if ((data_buf =
-	     (uint32 *) MALLOC(pi->sh->osh,
-			       sizeof(uint32) * num_samps)) == NULL) {
+	data_buf = (uint32 *) MALLOC(pi->sh->osh, sizeof(uint32) * num_samps);
+	if (data_buf == NULL) {
 		return;
 	}
 
@@ -26728,10 +26726,8 @@ wlc_phy_a1_nphy(phy_info_t *pi, uint8 co
 	ASSERT(end > start);
 	ASSERT(end < NPHY_PAPD_EPS_TBL_SIZE);
 
-	if (NULL ==
-	    (buf =
-	     MALLOC(pi->sh->osh,
-		    2 * sizeof(uint32) * NPHY_PAPD_EPS_TBL_SIZE))) {
+	buf = MALLOC(pi->sh->osh, 2 * sizeof(uint32) * NPHY_PAPD_EPS_TBL_SIZE);
+	if (NULL == buf) {
 		return;
 	}
 
--- a/drivers/staging/brcm80211/sys/wl_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.c
@@ -884,7 +884,8 @@ static wl_info_t *wl_attach(uint16 vendo
 		btparam = wl->rpc;
 	} else
 #endif
-	if ((wl->regsva = ioremap_nocache(base_addr, PCI_BAR0_WINSZ)) == NULL) {
+	wl->regsva = ioremap_nocache(base_addr, PCI_BAR0_WINSZ);
+	if (wl->regsva == NULL) {
 		WL_ERROR(("wl%d: ioremap() failed\n", unit));
 		goto fail;
 	}
@@ -993,8 +994,8 @@ static wl_info_t *wl_attach(uint16 vendo
 #endif				/* BCMDBG */
 	printf("\n");
 
-	if ((wl->proc_entry =
-	     create_proc_entry(PROC_ENTRY_NAME, 0644, NULL)) == NULL) {
+	wl->proc_entry = create_proc_entry(PROC_ENTRY_NAME, 0644, NULL);
+	if (wl->proc_entry == NULL) {
 		WL_ERROR(("create_proc_entry failed *******\n"));
 		ASSERT(0);
 	} else {
@@ -1003,7 +1004,8 @@ static wl_info_t *wl_attach(uint16 vendo
 		wl->proc_entry->data = wl;
 		/* wl->proc_entry->owner = THIS_MODULE; */
 
-		if ((wl->ioctlbuf = (char *)vmalloc(PAGE_SIZE)) == NULL) {
+		wl->ioctlbuf = (char *)vmalloc(PAGE_SIZE);
+		if (wl->ioctlbuf == NULL) {
 			WL_ERROR(("%s: Vmalloc failed\n", __func__));
 		}
 		wl->ioctlbuf_sz = PAGE_SIZE;
@@ -1145,10 +1147,9 @@ static void *wl_dbus_probe_cb(void *arg,
 	wl_info_t *wl;
 	WL_ERROR(("%s:\n", __func__));
 
-	if (!
-	    (wl =
-	     wl_attach(BCM_DNGL_VID, BCM_DNGL_BDC_PID, (ulong) NULL, RPC_BUS,
-		       NULL, 0))) {
+	wl = wl_attach(BCM_DNGL_VID, BCM_DNGL_BDC_PID, (ulong) NULL, RPC_BUS,
+		NULL, 0);
+	if (!wl) {
 		WL_ERROR(("%s: wl_attach failed\n", __func__));
 	}
 
@@ -1656,7 +1657,8 @@ static int __init wl_module_init(void)
 #endif				/* BCMDBG */
 
 #ifndef BCMSDIO
-	if (!(error = pci_module_init(&wl_pci_driver)))
+	error = pci_module_init(&wl_pci_driver);
+	if (!error)
 		return 0;
 
 #endif				/* !BCMSDIO */
@@ -1827,7 +1829,8 @@ wl_schedule_task(wl_info_t *wl, void (*f
 
 	WL_TRACE(("wl%d: wl_schedule_task\n", wl->pub->unit));
 
-	if (!(task = osl_malloc(wl->osh, sizeof(wl_task_t)))) {
+	task = osl_malloc(wl->osh, sizeof(wl_task_t));
+	if (!task) {
 		WL_ERROR(("wl%d: wl_schedule_task: out of memory, malloced %d bytes\n", wl->pub->unit, osl_malloced(wl->osh)));
 		return -ENOMEM;
 	}
@@ -1959,7 +1962,8 @@ irqreturn_t BCMFASTPATH wl_isr(int irq,
 	WL_ISRLOCK(wl, flags);
 
 	/* call common first level interrupt handler */
-	if ((ours = wlc_isr(wl->wlc, &wantdpc))) {
+	ours = wlc_isr(wl->wlc, &wantdpc);
+	if (ours) {
 		/* if more to do... */
 		if (wantdpc) {
 
@@ -2079,7 +2083,8 @@ wl_timer_t *wl_init_timer(wl_info_t *wl,
 {
 	wl_timer_t *t;
 
-	if (!(t = osl_malloc(wl->osh, sizeof(wl_timer_t)))) {
+	t = osl_malloc(wl->osh, sizeof(wl_timer_t));
+	if (!t) {
 		WL_ERROR(("wl%d: wl_init_timer: out of memory, malloced %d bytes\n", wl->pub->unit, osl_malloced(wl->osh)));
 		return 0;
 	}
@@ -2096,7 +2101,8 @@ wl_timer_t *wl_init_timer(wl_info_t *wl,
 	wl->timers = t;
 
 #ifdef BCMDBG
-	if ((t->name = osl_malloc(wl->osh, strlen(name) + 1)))
+	t->name = osl_malloc(wl->osh, strlen(name) + 1);
+	if (t->name)
 		strcpy(t->name, name);
 #endif
 
--- a/drivers/staging/brcm80211/sys/wlc_alloc.c
+++ b/drivers/staging/brcm80211/sys/wlc_alloc.c
@@ -42,7 +42,8 @@ void *wlc_calloc(osl_t *osh, uint unit,
 {
 	void *item;
 
-	if ((item = MALLOC(osh, size)) == NULL)
+	item = MALLOC(osh, size);
+	if (item == NULL)
 		WL_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
 			  unit, __func__, MALLOCED(osh)));
 	else
@@ -77,14 +78,15 @@ static wlc_pub_t *BCMATTACHFN(wlc_pub_ma
 					       uint *err, uint devid) {
 	wlc_pub_t *pub;
 
-	if ((pub =
-	     (wlc_pub_t *) wlc_calloc(osh, unit, sizeof(wlc_pub_t))) == NULL) {
+	pub = (wlc_pub_t *) wlc_calloc(osh, unit, sizeof(wlc_pub_t));
+	if (pub == NULL) {
 		*err = 1001;
 		goto fail;
 	}
 
-	if ((pub->tunables = (wlc_tunables_t *)
-	     wlc_calloc(osh, unit, sizeof(wlc_tunables_t))) == NULL) {
+	pub->tunables = (wlc_tunables_t *)wlc_calloc(osh, unit,
+		sizeof(wlc_tunables_t));
+	if (pub->tunables == NULL) {
 		*err = 1028;
 		goto fail;
 	}
@@ -92,9 +94,9 @@ static wlc_pub_t *BCMATTACHFN(wlc_pub_ma
 	/* need to init the tunables now */
 	wlc_tunables_init(pub->tunables, devid);
 
-	if ((pub->multicast = (struct ether_addr *)
-	     wlc_calloc(osh, unit,
-			(sizeof(struct ether_addr) * MAXMULTILIST))) == NULL) {
+	pub->multicast = (struct ether_addr *)wlc_calloc(osh, unit,
+		(sizeof(struct ether_addr) * MAXMULTILIST));
+	if (pub->multicast == NULL) {
 		*err = 1003;
 		goto fail;
 	}
@@ -127,13 +129,13 @@ wlc_bsscfg_t *wlc_bsscfg_malloc(osl_t *o
 {
 	wlc_bsscfg_t *cfg;
 
-	if ((cfg =
-	     (wlc_bsscfg_t *) wlc_calloc(osh, unit,
-					 sizeof(wlc_bsscfg_t))) == NULL)
+	cfg = (wlc_bsscfg_t *) wlc_calloc(osh, unit, sizeof(wlc_bsscfg_t));
+	if (cfg == NULL)
 		goto fail;
 
-	if ((cfg->current_bss = (wlc_bss_info_t *)
-	     wlc_calloc(osh, unit, sizeof(wlc_bss_info_t))) == NULL)
+	cfg->current_bss = (wlc_bss_info_t *)wlc_calloc(osh, unit,
+		sizeof(wlc_bss_info_t));
+	if (cfg->current_bss == NULL)
 		goto fail;
 
 	return cfg;
@@ -180,9 +182,8 @@ wlc_info_t *BCMATTACHFN(wlc_attach_mallo
 					    uint devid) {
 	wlc_info_t *wlc;
 
-	if ((wlc =
-	     (wlc_info_t *) wlc_calloc(osh, unit,
-				       sizeof(wlc_info_t))) == NULL) {
+	wlc = (wlc_info_t *) wlc_calloc(osh, unit, sizeof(wlc_info_t));
+	if (wlc == NULL) {
 		*err = 1002;
 		goto fail;
 	}
@@ -190,7 +191,8 @@ wlc_info_t *BCMATTACHFN(wlc_attach_mallo
 	wlc->hwrxoff = WL_HWRXOFF;
 
 	/* allocate wlc_pub_t state structure */
-	if ((wlc->pub = wlc_pub_malloc(osh, unit, err, devid)) == NULL) {
+	wlc->pub = wlc_pub_malloc(osh, unit, err, devid);
+	if (wlc->pub == NULL) {
 		*err = 1003;
 		goto fail;
 	}
@@ -198,16 +200,18 @@ wlc_info_t *BCMATTACHFN(wlc_attach_mallo
 
 	/* allocate wlc_hw_info_t state structure */
 
-	if ((wlc->hw = (wlc_hw_info_t *)
-	     wlc_calloc(osh, unit, sizeof(wlc_hw_info_t))) == NULL) {
+	wlc->hw = (wlc_hw_info_t *)wlc_calloc(osh, unit,
+		sizeof(wlc_hw_info_t));
+	if (wlc->hw == NULL) {
 		*err = 1005;
 		goto fail;
 	}
 	wlc->hw->wlc = wlc;
 
 #ifdef WLC_LOW
-	if ((wlc->hw->bandstate[0] = (wlc_hwband_t *)
-	     wlc_calloc(osh, unit, (sizeof(wlc_hwband_t) * MAXBANDS))) == NULL) {
+	wlc->hw->bandstate[0] = (wlc_hwband_t *)wlc_calloc(osh, unit,
+		(sizeof(wlc_hwband_t) * MAXBANDS));
+	if (wlc->hw->bandstate[0] == NULL) {
 		*err = 1006;
 		goto fail;
 	} else {
@@ -221,36 +225,37 @@ wlc_info_t *BCMATTACHFN(wlc_attach_mallo
 	}
 #endif				/* WLC_LOW */
 
-	if ((wlc->modulecb = (modulecb_t *)
-	     wlc_calloc(osh, unit,
-			sizeof(modulecb_t) * WLC_MAXMODULES)) == NULL) {
+	wlc->modulecb = (modulecb_t *)wlc_calloc(osh, unit,
+		sizeof(modulecb_t) * WLC_MAXMODULES);
+	if (wlc->modulecb == NULL) {
 		*err = 1009;
 		goto fail;
 	}
 
-	if ((wlc->default_bss = (wlc_bss_info_t *)
-	     wlc_calloc(osh, unit, sizeof(wlc_bss_info_t))) == NULL) {
+	wlc->default_bss = (wlc_bss_info_t *)wlc_calloc(osh, unit,
+		sizeof(wlc_bss_info_t));
+	if (wlc->default_bss == NULL) {
 		*err = 1010;
 		goto fail;
 	}
 
-	if ((wlc->cfg = wlc_bsscfg_malloc(osh, unit)) == NULL) {
+	wlc->cfg = wlc_bsscfg_malloc(osh, unit);
+	if (wlc->cfg == NULL) {
 		*err = 1011;
 		goto fail;
 	}
 	wlc_bsscfg_ID_assign(wlc, wlc->cfg);
 
-	if ((wlc->pkt_callback = (pkt_cb_t *)
-	     wlc_calloc(osh, unit,
-			(sizeof(pkt_cb_t) *
-			 (wlc->pub->tunables->maxpktcb + 1)))) == NULL) {
+	wlc->pkt_callback = (pkt_cb_t *)wlc_calloc(osh, unit,
+		(sizeof(pkt_cb_t) * (wlc->pub->tunables->maxpktcb + 1)));
+	if (wlc->pkt_callback == NULL) {
 		*err = 1013;
 		goto fail;
 	}
 
-	if ((wlc->wsec_def_keys[0] = (wsec_key_t *)
-	     wlc_calloc(osh, unit,
-			(sizeof(wsec_key_t) * WLC_DEFAULT_KEYS))) == NULL) {
+	wlc->wsec_def_keys[0] = (wsec_key_t *)wlc_calloc(osh, unit,
+		(sizeof(wsec_key_t) * WLC_DEFAULT_KEYS));
+	if (wlc->wsec_def_keys[0] == NULL) {
 		*err = 1015;
 		goto fail;
 	} else {
@@ -262,20 +267,22 @@ wlc_info_t *BCMATTACHFN(wlc_attach_mallo
 		}
 	}
 
-	if ((wlc->protection = (wlc_protection_t *)
-	     wlc_calloc(osh, unit, sizeof(wlc_protection_t))) == NULL) {
+	wlc->protection = (wlc_protection_t *)wlc_calloc(osh, unit,
+		sizeof(wlc_protection_t));
+	if (wlc->protection == NULL) {
 		*err = 1016;
 		goto fail;
 	}
 
-	if ((wlc->stf = (wlc_stf_t *)
-	     wlc_calloc(osh, unit, sizeof(wlc_stf_t))) == NULL) {
+	wlc->stf = (wlc_stf_t *)wlc_calloc(osh, unit, sizeof(wlc_stf_t));
+	if (wlc->stf == NULL) {
 		*err = 1017;
 		goto fail;
 	}
 
-	if ((wlc->bandstate[0] = (wlcband_t *)
-	     wlc_calloc(osh, unit, (sizeof(wlcband_t) * MAXBANDS))) == NULL) {
+	wlc->bandstate[0] = (wlcband_t *)wlc_calloc(osh, unit,
+				(sizeof(wlcband_t) * MAXBANDS));
+	if (wlc->bandstate[0] == NULL) {
 		*err = 1025;
 		goto fail;
 	} else {
@@ -288,14 +295,15 @@ wlc_info_t *BCMATTACHFN(wlc_attach_mallo
 		}
 	}
 
-	if ((wlc->corestate = (wlccore_t *)
-	     wlc_calloc(osh, unit, sizeof(wlccore_t))) == NULL) {
+	wlc->corestate = (wlccore_t *)wlc_calloc(osh, unit, sizeof(wlccore_t));
+	if (wlc->corestate == NULL) {
 		*err = 1026;
 		goto fail;
 	}
 
-	if ((wlc->corestate->macstat_snapshot = (macstat_t *)
-	     wlc_calloc(osh, unit, sizeof(macstat_t))) == NULL) {
+	wlc->corestate->macstat_snapshot =
+		(macstat_t *)wlc_calloc(osh, unit, sizeof(macstat_t));
+	if (wlc->corestate->macstat_snapshot == NULL) {
 		*err = 1027;
 		goto fail;
 	}
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -187,7 +187,8 @@ ampdu_info_t *BCMATTACHFN(wlc_ampdu_atta
 	ASSERT(wlc->pub->tunables->ampdunummpdu <= AMPDU_MAX_MPDU);
 	ASSERT(wlc->pub->tunables->ampdunummpdu > 0);
 
-	if (!(ampdu = (ampdu_info_t *) MALLOC(wlc->osh, sizeof(ampdu_info_t)))) {
+	ampdu = (ampdu_info_t *) MALLOC(wlc->osh, sizeof(ampdu_info_t));
+	if (!ampdu) {
 		WL_ERROR(("wl%d: wlc_ampdu_attach: out of mem, malloced %d bytes\n", wlc->pub->unit, MALLOCED(wlc->osh)));
 		return NULL;
 	}
@@ -1255,7 +1256,8 @@ ampdu_cleanup_tid_ini(ampdu_info_t *ampd
 		      bool force)
 {
 	scb_ampdu_tid_ini_t *ini;
-	if (!(ini = SCB_AMPDU_INI(scb_ampdu, tid)))
+	ini = SCB_AMPDU_INI(scb_ampdu, tid);
+	if (!ini)
 		return;
 
 	WL_AMPDU_CTL(("wl%d: ampdu_cleanup_tid_ini: tid %d\n",
--- a/drivers/staging/brcm80211/sys/wlc_antsel.c
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.c
@@ -98,7 +98,8 @@ antsel_info_t *BCMNMIATTACHFN(wlc_antsel
 						  wlc_hw_info_t *wlc_hw) {
 	antsel_info_t *asi;
 
-	if (!(asi = (antsel_info_t *) MALLOC(osh, sizeof(antsel_info_t)))) {
+	asi = (antsel_info_t *) MALLOC(osh, sizeof(antsel_info_t));
+	if (!asi) {
 		WL_ERROR(("wl%d: wlc_antsel_attach: out of mem, malloced %d bytes\n", pub->unit, MALLOCED(osh)));
 		return NULL;
 	}
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -758,11 +758,13 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 	if (bustype != SI_BUS) {
 		char *var;
 
-		if ((var = getvar(vars, "vendid"))) {
+		var = getvar(vars, "vendid");
+		if (var) {
 			vendor = (uint16) bcm_strtoul(var, NULL, 0);
 			WL_ERROR(("Overriding vendor id = 0x%x\n", vendor));
 		}
-		if ((var = getvar(vars, "devid"))) {
+		var = getvar(vars, "devid");
+		if (var) {
 			uint16 devid = (uint16) bcm_strtoul(var, NULL, 0);
 			if (devid != 0xffff) {
 				device = devid;
@@ -927,9 +929,9 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 		    xmtfifo_sz[(wlc_hw->corerev - XMTFIFOTBL_STARTREV)];
 
 		/* Get a phy for this band */
-		if ((wlc_hw->band->pi =
-		     wlc_phy_attach(wlc_hw->phy_sh, (void *)(uintptr) regs,
-				    wlc_hw->band->bandtype, vars)) == NULL) {
+		wlc_hw->band->pi = wlc_phy_attach(wlc_hw->phy_sh,
+			(void *)(uintptr) regs, wlc_hw->band->bandtype, vars);
+		if (wlc_hw->band->pi == NULL) {
 			WL_ERROR(("wl%d: wlc_bmac_attach: wlc_phy_attach failed\n", unit));
 			err = 17;
 			goto fail;
@@ -1013,7 +1015,8 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 	 */
 
 	/* init etheraddr state variables */
-	if ((macaddr = wlc_get_macaddr(wlc_hw)) == NULL) {
+	macaddr = wlc_get_macaddr(wlc_hw);
+	if (macaddr == NULL) {
 		WL_ERROR(("wl%d: wlc_bmac_attach: macaddr not found\n", unit));
 		err = 21;
 		goto fail;
@@ -1142,7 +1145,8 @@ BCMINITFN(wlc_bmac_init) (wlc_hw_info_t
 	WL_TRACE(("wl%d: wlc_bmac_init\n", wlc_hw->unit));
 
 	/* request FAST clock if not on */
-	if (!(fastclk = wlc_hw->forcefastclk))
+	fastclk = wlc_hw->forcefastclk;
+	if (!fastclk)
 		wlc_clkctl_clk(wlc_hw, CLK_FAST);
 
 	/* disable interrupts */
@@ -1840,7 +1844,8 @@ void wlc_bmac_bw_set(wlc_hw_info_t *wlc_
 	uint32 tmp;
 
 	/* request FAST clock if not on */
-	if (!(fastclk = wlc_hw->forcefastclk))
+	fastclk = wlc_hw->forcefastclk;
+	if (!fastclk)
 		wlc_clkctl_clk(wlc_hw, CLK_FAST);
 
 	wlc_phy_bw_state_set(wlc_hw->band->pi, bw);
@@ -2177,7 +2182,8 @@ static char *BCMINITFN(wlc_get_macaddr)
 	char *macaddr;
 
 	/* If macaddr exists, use it (Sromrev4, CIS, ...). */
-	if ((macaddr = getvar(wlc_hw->vars, varname)) != NULL)
+	macaddr = getvar(wlc_hw->vars, varname);
+	if (macaddr != NULL)
 		return macaddr;
 
 	if (NBANDS_HW(wlc_hw) > 1)
@@ -2185,7 +2191,8 @@ static char *BCMINITFN(wlc_get_macaddr)
 	else
 		varname = "il0macaddr";
 
-	if ((macaddr = getvar(wlc_hw->vars, varname)) == NULL) {
+	macaddr = getvar(wlc_hw->vars, varname);
+	if (macaddr == NULL) {
 		WL_ERROR(("wl%d: wlc_get_macaddr: macaddr getvar(%s) not found\n", wlc_hw->unit, varname));
 	}
 
@@ -2334,7 +2341,8 @@ void BCMINITFN(wlc_bmac_corereset) (wlc_
 	regs = wlc_hw->regs;
 
 	/* request FAST clock if not on  */
-	if (!(fastclk = wlc_hw->forcefastclk))
+	fastclk = wlc_hw->forcefastclk;
+	if (!fastclk)
 		wlc_clkctl_clk(wlc_hw, CLK_FAST);
 
 	/* reset the dma engines except first time thru */
--- a/drivers/staging/brcm80211/sys/wlc_channel.c
+++ b/drivers/staging/brcm80211/sys/wlc_channel.c
@@ -609,9 +609,8 @@ wlc_cm_info_t *BCMATTACHFN(wlc_channel_m
 
 	WL_TRACE(("wl%d: wlc_channel_mgr_attach\n", wlc->pub->unit));
 
-	if ((wlc_cm =
-	     (wlc_cm_info_t *) MALLOC(pub->osh,
-				      sizeof(wlc_cm_info_t))) == NULL) {
+	wlc_cm = (wlc_cm_info_t *) MALLOC(pub->osh, sizeof(wlc_cm_info_t));
+	if (wlc_cm == NULL) {
 		WL_ERROR(("wl%d: %s: out of memory, malloced %d bytes",
 			  pub->unit, __func__, MALLOCED(pub->osh)));
 		return NULL;
--- a/drivers/staging/brcm80211/sys/wlc_event.c
+++ b/drivers/staging/brcm80211/sys/wlc_event.c
@@ -69,7 +69,8 @@ wlc_eventq_t *BCMATTACHFN(wlc_eventq_att
 	eq->wl = wl;
 	eq->pub = pub;
 
-	if (!(eq->timer = wl_init_timer(eq->wl, wlc_timer_cb, eq, "eventq"))) {
+	eq->timer = wl_init_timer(eq->wl, wlc_timer_cb, eq, "eventq");
+	if (!eq->timer) {
 		WL_ERROR(("wl%d: wlc_eventq_attach: timer failed\n",
 			  pub->unit));
 		MFREE(eq->pub->osh, eq, sizeof(wlc_eventq_t));
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -1569,16 +1569,16 @@ void wlc_edcf_setparams(wlc_bsscfg_t *cf
 
 bool BCMATTACHFN(wlc_timers_init) (wlc_info_t *wlc, int unit)
 {
-	if (!
-	    (wlc->wdtimer =
-	     wl_init_timer(wlc->wl, wlc_watchdog_by_timer, wlc, "watchdog"))) {
+	wlc->wdtimer = wl_init_timer(wlc->wl, wlc_watchdog_by_timer,
+		wlc, "watchdog");
+	if (!wlc->wdtimer) {
 		WL_ERROR(("wl%d:  wl_init_timer for wdtimer failed\n", unit));
 		goto fail;
 	}
 
-	if (!
-	    (wlc->radio_timer =
-	     wl_init_timer(wlc->wl, wlc_radio_timer, wlc, "radio"))) {
+	wlc->radio_timer = wl_init_timer(wlc->wl, wlc_radio_timer,
+		wlc, "radio");
+	if (!wlc->radio_timer) {
 		WL_ERROR(("wl%d:  wl_init_timer for radio_timer failed\n",
 			  unit));
 		goto fail;
@@ -1725,15 +1725,16 @@ static uint BCMATTACHFN(wlc_attach_modul
 	uint unit;
 	unit = wlc->pub->unit;
 
-	if ((wlc->asi =
-	     wlc_antsel_attach(wlc, wlc->osh, wlc->pub, wlc->hw)) == NULL) {
+	wlc->asi = wlc_antsel_attach(wlc, wlc->osh, wlc->pub, wlc->hw);
+	if (wlc->asi == NULL) {
 		WL_ERROR(("wl%d: wlc_attach: wlc_antsel_attach failed\n",
 			  unit));
 		err = 44;
 		goto fail;
 	}
 
-	if ((wlc->ampdu = wlc_ampdu_attach(wlc)) == NULL) {
+	wlc->ampdu = wlc_ampdu_attach(wlc);
+	if (wlc->ampdu == NULL) {
 		WL_ERROR(("wl%d: wlc_attach: wlc_ampdu_attach failed\n", unit));
 		err = 50;
 		goto fail;
@@ -1824,8 +1825,8 @@ void *BCMATTACHFN(wlc_attach) (void *wl,
 		   && 4 == WLC_NUMRXIVS));
 
 	/* allocate wlc_info_t state and its substructures */
-	if ((wlc =
-	     (wlc_info_t *) wlc_attach_malloc(osh, unit, &err, device)) == NULL)
+	wlc = (wlc_info_t *) wlc_attach_malloc(osh, unit, &err, device);
+	if (wlc == NULL)
 		goto fail;
 	wlc->osh = osh;
 	pub = wlc->pub;
@@ -2177,7 +2178,8 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 
 	wlc->regs = 0;
 
-	if ((wlc->rpctx = wlc_rpctx_attach(wlc->pub, wlc)) == NULL)
+	wlc->rpctx = wlc_rpctx_attach(wlc->pub, wlc);
+	if (wlc->rpctx == NULL)
 		return -1;
 
 	/*
@@ -3435,7 +3437,8 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		     (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];
 
 		/* bcmerror checking */
-		if ((bcmerror = wlc_iocregchk(wlc, band)))
+		bcmerror = wlc_iocregchk(wlc, band);
+		if (bcmerror)
 			break;
 
 		if (val >= MHFMAX) {
@@ -3458,7 +3461,8 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		     (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];
 
 		/* bcmerror checking */
-		if ((bcmerror = wlc_iocregchk(wlc, band)))
+		bcmerror = wlc_iocregchk(wlc, band);
+		if (bcmerror)
 			break;
 
 		i = (uint16) val;
@@ -3480,7 +3484,8 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		     (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];
 
 		/* bcmerror checking */
-		if ((bcmerror = wlc_iocregchk(wlc, band)))
+		bcmerror = wlc_iocregchk(wlc, band);
+		if (bcmerror)
 			break;
 
 		if (val & 1) {
@@ -3500,7 +3505,8 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		     (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];
 
 		/* bcmerror checking */
-		if ((bcmerror = wlc_iocregchk(wlc, band)))
+		bcmerror = wlc_iocregchk(wlc, band);
+		if (bcmerror)
 			break;
 
 		if (val & 1) {
@@ -3526,7 +3532,8 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			band = r->band;
 
 		/* bcmerror checking */
-		if ((bcmerror = wlc_iocregchk(wlc, band)))
+		bcmerror = wlc_iocregchk(wlc, band);
+		if (bcmerror)
 			break;
 
 		if ((r->byteoff + r->size) > sizeof(d11regs_t)) {
@@ -3561,7 +3568,8 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			band = r->band;
 
 		/* bcmerror checking */
-		if ((bcmerror = wlc_iocregchk(wlc, band)))
+		bcmerror = wlc_iocregchk(wlc, band);
+		if (bcmerror)
 			break;
 
 		if (r->byteoff + r->size > sizeof(d11regs_t)) {
@@ -3849,8 +3857,9 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			 * The format is 8 bytes, with least significant in seq[0].
 			 */
 
+			key = WSEC_KEY(wlc, val);
 			if ((val >= 0) && (val < WLC_MAX_WSEC_KEYS(wlc)) &&
-			    (key = WSEC_KEY(wlc, val)) != NULL) {
+				(key != NULL)) {
 				uint8 seq[DOT11_WPA_KEY_RSC_LEN];
 				uint16 lo;
 				uint32 hi;
@@ -4334,7 +4343,8 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			wsec_key_t *key;
 
 			/* treat the 'val' parm as the key id */
-			if ((key = WSEC_BSS_DEFAULT_KEY(bsscfg)) != NULL) {
+			key = WSEC_BSS_DEFAULT_KEY(bsscfg);
+			if (key != NULL) {
 				*pval = key->id == val ? TRUE : FALSE;
 			} else {
 				bcmerror = BCME_BADKEYIDX;
@@ -4349,11 +4359,10 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 
 			/* treat the 'val' parm as the key id */
 			for (i = 0; i < WSEC_MAX_DEFAULT_KEYS; i++) {
-				if ((key = bsscfg->bss_def_keys[i]) != NULL &&
-				    key->id == val) {
-					if ((old_key =
-					     WSEC_BSS_DEFAULT_KEY(bsscfg)) !=
-					    NULL)
+				key = bsscfg->bss_def_keys[i];
+				if (key != NULL && key->id == val) {
+					old_key = WSEC_BSS_DEFAULT_KEY(bsscfg);
+					if (old_key != NULL)
 						old_key->flags &=
 						    ~WSEC_PRIMARY_KEY;
 					key->flags |= WSEC_PRIMARY_KEY;
@@ -4635,7 +4644,8 @@ wlc_iovar_op(wlc_info_t *wlc, const char
 	for (i = 0; i < WLC_MAXMODULES; i++) {
 		if (!wlc->modulecb[i].iovars)
 			continue;
-		if ((vi = wlc_iovar_lookup(wlc->modulecb[i].iovars, name)))
+		vi = wlc_iovar_lookup(wlc->modulecb[i].iovars, name);
+		if (vi)
 			break;
 	}
 	/* iovar name not found */
@@ -4711,7 +4721,8 @@ wlc_iovar_check(wlc_pub_t *pub, const bc
 		goto exit;
 
 	/* length check on io buf */
-	if ((err = bcm_iovar_lencheck(vi, arg, len, set)))
+	err = bcm_iovar_lencheck(vi, arg, len, set);
+	if (err)
 		goto exit;
 
 	/* On set, check value ranges for integer types */
@@ -4762,8 +4773,8 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 	bsscfg = NULL;
 	current_bss = NULL;
 
-	if ((err =
-	     wlc_iovar_check(wlc->pub, vi, arg, len, IOV_ISSET(actionid))) != 0)
+	err = wlc_iovar_check(wlc->pub, vi, arg, len, IOV_ISSET(actionid));
+	if (err != 0)
 		return err;
 
 	/* convenience int and bool vals for first 8 bytes of buffer */
@@ -4789,9 +4800,9 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 			uint qdbm;
 			bool override;
 
-			if ((err =
-			     wlc_phy_txpower_get(wlc->band->pi, &qdbm,
-						 &override)) != BCME_OK)
+			err = wlc_phy_txpower_get(wlc->band->pi, &qdbm,
+				&override);
+			if (err != BCME_OK)
 				return err;
 
 			/* Return qdbm units */
@@ -6087,7 +6098,8 @@ uint16 BCMFASTPATH wlc_phytxctl1_calc(wl
 	} else {		/* legacy OFDM/CCK */
 		int16 phycfg;
 		/* get the phyctl byte from rate phycfg table */
-		if ((phycfg = wlc_rate_legacy_phyctl(RSPEC2RATE(rspec))) == -1) {
+		phycfg = wlc_rate_legacy_phyctl(RSPEC2RATE(rspec));
+		if (phycfg == -1) {
 			WL_ERROR(("wlc_phytxctl1_calc: wrong legacy OFDM/CCK rate\n"));
 			ASSERT(0);
 			phycfg = 0;
@@ -6753,7 +6765,8 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 	       ((preamble_type[1] == WLC_MM_PREAMBLE) ==
 		(txh->MModeFbrLen != 0)));
 
-	if (SCB_WME(scb) && qos && wlc->edcf_txop[(ac = wme_fifo2ac[queue])]) {
+	ac = wme_fifo2ac[queue];
+	if (SCB_WME(scb) && qos && wlc->edcf_txop[ac]) {
 		uint frag_dur, dur, dur_fallback;
 
 		ASSERT(!ETHER_ISMULTI(&h->a1));
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.c
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.c
@@ -64,10 +64,9 @@ wlc_phy_shim_info_t *BCMATTACHFN(wlc_phy
 						       void *wl, void *wlc) {
 	wlc_phy_shim_info_t *physhim = NULL;
 
-	if (!
-	    (physhim =
-	     (wlc_phy_shim_info_t *) MALLOC(wlc_hw->osh,
-					    sizeof(wlc_phy_shim_info_t)))) {
+	physhim = (wlc_phy_shim_info_t *)MALLOC(wlc_hw->osh,
+		sizeof(wlc_phy_shim_info_t));
+	if (!physhim) {
 		WL_ERROR(("wl%d: wlc_phy_shim_attach: out of mem, malloced %d bytes\n", wlc_hw->unit, MALLOCED(wlc_hw->osh)));
 		return NULL;
 	}
--- a/drivers/staging/brcm80211/util/bcmotp.c
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -640,7 +640,8 @@ static void *BCMNMIATTACHFN(hndotp_init)
 	osh = si_osh(oi->sih);
 
 	/* Check for otp */
-	if ((cc = si_setcoreidx(sih, SI_CC_IDX)) != NULL) {
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	if (cc != NULL) {
 		cap = R_REG(osh, &cc->capabilities);
 		if ((cap & CC_CAP_OTPSIZE) == 0) {
 			/* Nothing there */
@@ -754,7 +755,8 @@ static int hndotp_nvread(void *oh, char
 
 	/* Read the whole otp so we can easily manipulate it */
 	lim = hndotp_size(oh);
-	if ((rawotp = MALLOC(si_osh(oi->sih), lim)) == NULL) {
+	rawotp = MALLOC(si_osh(oi->sih), lim);
+	if (rawotp == NULL) {
 		rc = -2;
 		goto out;
 	}
@@ -927,7 +929,8 @@ BCMNMIATTACHFN(otp_read_region) (si_t *s
 	void *oh;
 	int err = 0;
 
-	if (!(wasup = si_is_otp_powered(sih)))
+	wasup = si_is_otp_powered(sih);
+	if (!wasup)
 		si_otp_power(sih, TRUE);
 
 	if (!si_is_otp_powered(sih) || si_is_otp_disabled(sih)) {
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -124,7 +124,8 @@ static int BCMATTACHFN(varbuf_append) (v
 	}
 
 	/* Remove any earlier occurrence of the same variable */
-	if ((s = strchr(b->buf, '=')) != NULL) {
+	s = strchr(b->buf, '=');
+	if (s != NULL) {
 		len = (size_t) (s - b->buf);
 		for (s = b->base; s < b->buf;) {
 			if ((bcmp(s, b->buf, len) == 0) && s[len] == '=') {
@@ -1515,7 +1516,8 @@ static int otp_read_pci(osl_t *osh, si_t
 
 	ASSERT(bufsz <= OTP_SZ_MAX);
 
-	if ((otp = MALLOC(osh, OTP_SZ_MAX)) == NULL) {
+	otp = MALLOC(osh, OTP_SZ_MAX);
+	if (otp == NULL) {
 		return BCME_ERROR;
 	}
 
@@ -1594,9 +1596,11 @@ BCMATTACHFN(initvars_flash) (si_t *sih,
 	char devpath[SI_DEVPATH_BUFSZ];
 
 	/* allocate memory and read in flash */
-	if (!(flash = MALLOC(osh, NVRAM_SPACE)))
+	flash = MALLOC(osh, NVRAM_SPACE);
+	if (!flash)
 		return BCME_NOMEM;
-	if ((err = nvram_getall(flash, NVRAM_SPACE)))
+	err = nvram_getall(flash, NVRAM_SPACE);
+	if (err)
 		goto exit;
 
 	si_devpath(sih, devpath, sizeof(devpath));
@@ -1655,7 +1659,8 @@ BCMATTACHFN(initvars_flash_si) (si_t *si
 	if (!vp)
 		return BCME_NOMEM;
 
-	if ((err = initvars_flash(sih, osh, &vp, MAXSZ_NVRAM_VARS)) == 0)
+	err = initvars_flash(sih, osh, &vp, MAXSZ_NVRAM_VARS);
+	if (err == 0)
 		err = initvars_table(osh, base, vp, vars, count);
 
 	MFREE(osh, base, MAXSZ_NVRAM_VARS);
@@ -1921,7 +1926,8 @@ BCMATTACHFN(initvars_srom_pci) (si_t *si
 		uint32 val;
 		val = 0;
 
-		if ((value = si_getdevpathvar(sih, "sromrev"))) {
+		value = si_getdevpathvar(sih, "sromrev");
+		if (value) {
 			sromrev = (uint8) bcm_strtoul(value, NULL, 0);
 			flash = TRUE;
 			goto varscont;
@@ -1929,7 +1935,8 @@ BCMATTACHFN(initvars_srom_pci) (si_t *si
 
 		BS_ERROR(("%s, SROM CRC Error\n", __func__));
 
-		if ((value = si_getnvramflvar(sih, "sromrev"))) {
+		value = si_getnvramflvar(sih, "sromrev");
+		if (value) {
 			err = 0;
 			goto errout;
 		}
@@ -1962,7 +1969,8 @@ BCMATTACHFN(initvars_srom_pci) (si_t *si
 
 	/* read variables from flash */
 	if (flash) {
-		if ((err = initvars_flash(sih, osh, &vp, MAXSZ_NVRAM_VARS)))
+		err = initvars_flash(sih, osh, &vp, MAXSZ_NVRAM_VARS);
+		if (err)
 			goto errout;
 		goto varsdone;
 	}
@@ -2006,7 +2014,8 @@ BCMATTACHFN(initvars_cis_sdio) (osl_t *o
 	ASSERT(numfn <= SDIOD_MAX_IOFUNCS);
 
 	for (fn = 0; fn <= numfn; fn++) {
-		if ((cis[fn] = MALLOC(osh, SBSDIO_CIS_SIZE_LIMIT)) == NULL) {
+		cis[fn] = MALLOC(osh, SBSDIO_CIS_SIZE_LIMIT)
+		if (cis[fn] == NULL) {
 			rc = -1;
 			break;
 		}
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -190,10 +190,12 @@ void *BCMFASTPATH pktq_pdeq(struct pktq
 
 	q = &pq->q[prec];
 
-	if ((p = q->head) == NULL)
+	p = q->head;
+	if (p == NULL)
 		return NULL;
 
-	if ((q->head = PKTLINK(p)) == NULL)
+	q->head = PKTLINK(p);
+	if (q->head == NULL)
 		q->tail = NULL;
 
 	q->len--;
@@ -214,7 +216,8 @@ void *BCMFASTPATH pktq_pdeq_tail(struct
 
 	q = &pq->q[prec];
 
-	if ((p = q->head) == NULL)
+	p = q->head;
+	if (p == NULL)
 		return NULL;
 
 	for (prev = NULL; p != q->tail; p = PKTLINK(p))
@@ -279,7 +282,8 @@ bool BCMFASTPATH pktq_pdel(struct pktq *
 	q = &pq->q[prec];
 
 	if (q->head == pktbuf) {
-		if ((q->head = PKTLINK(pktbuf)) == NULL)
+		q->head = PKTLINK(pktbuf);
+		if (q->head == NULL)
 			q->tail = NULL;
 	} else {
 		for (p = q->head; p && PKTLINK(p) != pktbuf; p = PKTLINK(p)) ;
@@ -329,10 +333,12 @@ void *BCMFASTPATH pktq_deq(struct pktq *
 
 	q = &pq->q[prec];
 
-	if ((p = q->head) == NULL)
+	p = q->head;
+	if (p == NULL)
 		return NULL;
 
-	if ((q->head = PKTLINK(p)) == NULL)
+	q->head = PKTLINK(p);
+	if (q->head == NULL)
 		q->tail = NULL;
 
 	q->len--;
@@ -362,7 +368,8 @@ void *BCMFASTPATH pktq_deq_tail(struct p
 
 	q = &pq->q[prec];
 
-	if ((p = q->head) == NULL)
+	p = q->head;
+	if (p == NULL)
 		return NULL;
 
 	for (prev = NULL; p != q->tail; p = PKTLINK(p))
@@ -461,10 +468,12 @@ void *BCMFASTPATH pktq_mdeq(struct pktq
 
 	q = &pq->q[prec];
 
-	if ((p = q->head) == NULL)
+	p = q->head;
+	if (p == NULL)
 		return NULL;
 
-	if ((q->head = PKTLINK(p)) == NULL)
+	q->head = PKTLINK(p);
+	if (q->head == NULL)
 		q->tail = NULL;
 
 	q->len--;
@@ -847,7 +856,8 @@ int getintvar(char *vars, const char *na
 {
 	char *val;
 
-	if ((val = getvar(vars, name)) == NULL)
+	val = getvar(vars, name);
+	if (val == NULL)
 		return 0;
 
 	return bcm_strtoul(val, NULL, 0);
@@ -859,7 +869,8 @@ int getintvararray(char *vars, const cha
 	int i = 0;
 	int val = 0;
 
-	if ((buf = getvar(vars, name)) == NULL) {
+	buf = getvar(vars, name);
+	if (buf == NULL) {
 		return 0;
 	}
 
@@ -975,7 +986,8 @@ static void BCMINITFN(bcm_nvram_refresh)
 	/* default "empty" vars cache */
 	bzero(flash, 2);
 
-	if ((ret = nvram_getall(flash, NVRAM_SPACE)))
+	ret = nvram_getall(flash, NVRAM_SPACE);
+	if (ret)
 		return;
 
 	/* determine nvram length */
@@ -1021,7 +1033,8 @@ int BCMINITFN(bcm_nvram_cache) (void *si
 	osh = si_osh((si_t *) sih);
 
 	/* allocate memory and read in flash */
-	if (!(flash = MALLOC(osh, NVRAM_SPACE))) {
+	flash = MALLOC(osh, NVRAM_SPACE);
+	if (!flash) {
 		ret = BCME_NOMEM;
 		goto exit;
 	}
@@ -1030,7 +1043,8 @@ int BCMINITFN(bcm_nvram_cache) (void *si
 #ifdef BCMNVRAMR
 	if (vars_len > 3) {
 		/* copy into a properly-sized buffer */
-		if (!(nvram_vars = MALLOC(osh, vars_len))) {
+		nvram_vars = MALLOC(osh, vars_len);
+		if (!nvram_vars) {
 			ret = BCME_NOMEM;
 		} else
 			bcopy(flash, nvram_vars, vars_len);
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -363,7 +363,8 @@ hnddma_t *dma_attach(osl_t *osh, char *n
 	uint size;
 
 	/* allocate private info structure */
-	if ((di = MALLOC(osh, sizeof(dma_info_t))) == NULL) {
+	di = MALLOC(osh, sizeof(dma_info_t));
+	if (di == NULL) {
 #ifdef BCMDBG
 		printf("dma_attach: out of memory, malloced %d bytes\n",
 		       MALLOCED(osh));
@@ -499,7 +500,8 @@ hnddma_t *dma_attach(osl_t *osh, char *n
 	/* allocate tx packet pointer vector */
 	if (ntxd) {
 		size = ntxd * sizeof(void *);
-		if ((di->txp = MALLOC(osh, size)) == NULL) {
+		di->txp = MALLOC(osh, size);
+		if (di->txp == NULL) {
 			DMA_ERROR(("%s: dma_attach: out of tx memory, malloced %d bytes\n", di->name, MALLOCED(osh)));
 			goto fail;
 		}
@@ -509,7 +511,8 @@ hnddma_t *dma_attach(osl_t *osh, char *n
 	/* allocate rx packet pointer vector */
 	if (nrxd) {
 		size = nrxd * sizeof(void *);
-		if ((di->rxp = MALLOC(osh, size)) == NULL) {
+		di->rxp = MALLOC(osh, size);
+		if (di->rxp == NULL) {
 			DMA_ERROR(("%s: dma_attach: out of rx memory, malloced %d bytes\n", di->name, MALLOCED(osh)));
 			goto fail;
 		}
@@ -545,16 +548,16 @@ hnddma_t *dma_attach(osl_t *osh, char *n
 	if (DMASGLIST_ENAB) {
 		if (ntxd) {
 			size = ntxd * sizeof(hnddma_seg_map_t);
-			if ((di->txp_dmah =
-			     (hnddma_seg_map_t *) MALLOC(osh, size)) == NULL)
+			di->txp_dmah = (hnddma_seg_map_t *) MALLOC(osh, size);
+			if (di->txp_dmah == NULL)
 				goto fail;
 			bzero((char *)di->txp_dmah, size);
 		}
 
 		if (nrxd) {
 			size = nrxd * sizeof(hnddma_seg_map_t);
-			if ((di->rxp_dmah =
-			     (hnddma_seg_map_t *) MALLOC(osh, size)) == NULL)
+			di->rxp_dmah = (hnddma_seg_map_t *) MALLOC(osh, size);
+			if (di->rxp_dmah == NULL)
 				goto fail;
 			bzero((char *)di->rxp_dmah, size);
 		}
@@ -1395,10 +1398,9 @@ static void *dma_ringalloc(osl_t *osh, u
 	uint32 desc_strtaddr;
 	uint32 alignbytes = 1 << *alignbits;
 
-	if (NULL ==
-	    (va =
-	     DMA_ALLOC_CONSISTENT(osh, size, *alignbits, alloced, descpa,
-				  dmah)))
+	va = DMA_ALLOC_CONSISTENT(osh, size, *alignbits, alloced, descpa,
+		dmah);
+	if (NULL == va)
 		return NULL;
 
 	desc_strtaddr = (uint32) ROUNDUP((uintptr) va, alignbytes);
@@ -1517,10 +1519,9 @@ static bool dma32_alloc(dma_info_t *di,
 	align = (1 << align_bits);
 
 	if (direction == DMA_TX) {
-		if ((va =
-		     dma_ringalloc(di->osh, D32RINGALIGN, size, &align_bits,
-				   &alloced, &di->txdpaorig,
-				   &di->tx_dmah)) == NULL) {
+		va = dma_ringalloc(di->osh, D32RINGALIGN, size, &align_bits,
+			&alloced, &di->txdpaorig, &di->tx_dmah);
+		if (va == NULL) {
 			DMA_ERROR(("%s: dma_alloc: DMA_ALLOC_CONSISTENT(ntxd) failed\n", di->name));
 			return FALSE;
 		}
@@ -1539,10 +1540,9 @@ static bool dma32_alloc(dma_info_t *di,
 		di->txdalloc = alloced;
 		ASSERT(ISALIGNED((uintptr) di->txd32, align));
 	} else {
-		if ((va =
-		     dma_ringalloc(di->osh, D32RINGALIGN, size, &align_bits,
-				   &alloced, &di->rxdpaorig,
-				   &di->rx_dmah)) == NULL) {
+		va = dma_ringalloc(di->osh, D32RINGALIGN, size, &align_bits,
+			&alloced, &di->rxdpaorig, &di->rx_dmah);
+		if (va == NULL) {
 			DMA_ERROR(("%s: dma_alloc: DMA_ALLOC_CONSISTENT(nrxd) failed\n", di->name));
 			return FALSE;
 		}
@@ -2087,10 +2087,9 @@ static bool dma64_alloc(dma_info_t *di,
 	align = (1 << align_bits);
 
 	if (direction == DMA_TX) {
-		if ((va =
-		     dma_ringalloc(di->osh, D64RINGALIGN, size, &align_bits,
-				   &alloced, &di->txdpaorig,
-				   &di->tx_dmah)) == NULL) {
+		va = dma_ringalloc(di->osh, D64RINGALIGN, size, &align_bits,
+			&alloced, &di->txdpaorig, &di->tx_dmah);
+		if (va == NULL) {
 			DMA_ERROR(("%s: dma64_alloc: DMA_ALLOC_CONSISTENT(ntxd) failed\n", di->name));
 			return FALSE;
 		}
@@ -2107,10 +2106,9 @@ static bool dma64_alloc(dma_info_t *di,
 		di->txdalloc = alloced;
 		ASSERT(ISALIGNED((uintptr) di->txd64, align));
 	} else {
-		if ((va =
-		     dma_ringalloc(di->osh, D64RINGALIGN, size, &align_bits,
-				   &alloced, &di->rxdpaorig,
-				   &di->rx_dmah)) == NULL) {
+		va = dma_ringalloc(di->osh, D64RINGALIGN, size, &align_bits,
+			&alloced, &di->rxdpaorig, &di->rx_dmah);
+		if (va == NULL) {
 			DMA_ERROR(("%s: dma64_alloc: DMA_ALLOC_CONSISTENT(nrxd) failed\n", di->name));
 			return FALSE;
 		}
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -679,12 +679,14 @@ static void si_pmu_res_masks(si_t *sih,
 	}
 
 	/* Apply nvram override to min mask */
-	if ((val = getvar(NULL, "rmin")) != NULL) {
+	val = getvar(NULL, "rmin");
+	if (val != NULL) {
 		PMU_MSG(("Applying rmin=%s to min_mask\n", val));
 		min_mask = (uint32) bcm_strtoul(val, NULL, 0);
 	}
 	/* Apply nvram override to max mask */
-	if ((val = getvar(NULL, "rmax")) != NULL) {
+	val = getvar(NULL, "rmax");
+	if (val != NULL) {
 		PMU_MSG(("Applying rmax=%s to max_mask\n", val));
 		max_mask = (uint32) bcm_strtoul(val, NULL, 0);
 	}
@@ -797,7 +799,8 @@ void BCMATTACHFN(si_pmu_res_init) (si_t
 	/* Apply nvram overrides to up/down timers */
 	for (i = 0; i < rsrcs; i++) {
 		snprintf(name, sizeof(name), "r%dt", i);
-		if ((val = getvar(NULL, name)) == NULL)
+		val = getvar(NULL, name);
+		if (val == NULL)
 			continue;
 		PMU_MSG(("Applying %s=%s to rsrc %d res_updn_timer\n", name,
 			 val, i));
@@ -847,7 +850,8 @@ void BCMATTACHFN(si_pmu_res_init) (si_t
 	/* Apply nvram overrides to dependancies masks */
 	for (i = 0; i < rsrcs; i++) {
 		snprintf(name, sizeof(name), "r%dd", i);
-		if ((val = getvar(NULL, name)) == NULL)
+		val = getvar(NULL, name);
+		if (val == NULL)
 			continue;
 		PMU_MSG(("Applying %s=%s to rsrc %d res_dep_mask\n", name, val,
 			 i));
--- a/drivers/staging/brcm80211/util/linux_osl.c
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -180,7 +180,8 @@ void *BCMFASTPATH osl_pktget(osl_t *osh,
 {
 	struct sk_buff *skb;
 
-	if ((skb = dev_alloc_skb(len))) {
+	skb = dev_alloc_skb(len);
+	if (skb) {
 		skb_put(skb, len);
 		skb->priority = 0;
 
@@ -312,7 +313,8 @@ void *osl_malloc(osl_t *osh, uint size)
 	if (osh)
 		ASSERT(osh->magic == OS_HANDLE_MAGIC);
 
-	if ((addr = kmalloc(size, GFP_ATOMIC)) == NULL) {
+	addr = kmalloc(size, GFP_ATOMIC);
+	if (addr == NULL) {
 		if (osh)
 			osh->failed++;
 		return NULL;
@@ -452,7 +454,8 @@ void *osl_pktdup(osl_t *osh, void *skb)
 {
 	void *p;
 
-	if ((p = skb_clone((struct sk_buff *)skb, GFP_ATOMIC)) == NULL)
+	p = skb_clone((struct sk_buff *)skb, GFP_ATOMIC);
+	if (p == NULL)
 		return NULL;
 
 	/* skb_clone copies skb->cb.. we don't want that */
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -113,7 +113,8 @@ void *pcicore_init(si_t *sih, osl_t *osh
 	ASSERT(sih->bustype == PCI_BUS);
 
 	/* alloc pcicore_info_t */
-	if ((pi = MALLOC(osh, sizeof(pcicore_info_t))) == NULL) {
+	pi = MALLOC(osh, sizeof(pcicore_info_t));
+	if (pi == NULL) {
 		PCI_ERROR(("pci_attach: malloc failed! malloced %d bytes\n",
 			   MALLOCED(osh)));
 		return NULL;
--- a/drivers/staging/brcm80211/util/nvram/nvram_ro.c
+++ b/drivers/staging/brcm80211/util/nvram/nvram_ro.c
@@ -57,7 +57,8 @@ static void BCMINITFN(get_flash_nvram) (
 	nvs = R_REG(osh, &nvh->len) - sizeof(struct nvram_header);
 	bufsz = nvs + VARS_T_OH;
 
-	if ((new = (vars_t *) MALLOC(osh, bufsz)) == NULL) {
+	new = (vars_t *) MALLOC(osh, bufsz);
+	if (new == NULL) {
 		NVR_MSG(("Out of memory for flash vars\n"));
 		return;
 	}
@@ -91,7 +92,8 @@ int BCMATTACHFN(nvram_append) (void *si,
 	uint bufsz = VARS_T_OH;
 	vars_t *new;
 
-	if ((new = MALLOC(si_osh((si_t *) si), bufsz)) == NULL)
+	new = MALLOC(si_osh((si_t *) si), bufsz);
+	if (new == NULL)
 		return BCME_NOMEM;
 
 	new->vars = varlst;
@@ -144,9 +146,11 @@ char *nvram_get(const char *name)
 	char *v = NULL;
 	vars_t *cur;
 
-	for (cur = vars; cur; cur = cur->next)
-		if ((v = findvar(cur->vars, cur->vars + cur->size, name)))
+	for (cur = vars; cur; cur = cur->next) {
+		v = findvar(cur->vars, cur->vars + cur->size, name);
+		if (v)
 			break;
+	}
 
 	return v;
 }
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -88,7 +88,8 @@ si_t *BCMATTACHFN(si_attach) (uint devid
 	si_info_t *sii;
 
 	/* alloc si_info_t */
-	if ((sii = MALLOC(osh, sizeof(si_info_t))) == NULL) {
+	sii = MALLOC(osh, sizeof(si_info_t));
+	if (sii == NULL) {
 		SI_ERROR(("si_attach: malloc failed! malloced %d bytes\n",
 			  MALLOCED(osh)));
 		return NULL;
@@ -269,14 +270,13 @@ BCMATTACHFN(si_buscore_setup) (si_info_t
 	/* fixup necessary chip/core configurations */
 	if (BUSTYPE(sii->pub.bustype) == PCI_BUS) {
 		if (SI_FAST(sii)) {
-			if (!sii->pch &&
-			    ((sii->pch =
-			      (void *)(uintptr) pcicore_init(&sii->pub,
-							     sii->osh,
-							     (void *)
-							     PCIEREGS(sii))) ==
-			     NULL))
-				return FALSE;
+			if (!sii->pch) {
+				sii->pch = (void *)(uintptr)pcicore_init(
+					&sii->pub, sii->osh,
+					(void *)PCIEREGS(sii));
+				if (sii->pch == NULL)
+					return FALSE;
+			}
 		}
 		if (si_pci_fixcfg(&sii->pub)) {
 			SI_ERROR(("si_doattach: sb_pci_fixcfg failed\n"));
@@ -300,15 +300,15 @@ static void BCMATTACHFN(si_nvram_process
 		/* do a pci config read to get subsystem id and subvendor id */
 		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_SVID, sizeof(uint32));
 		/* Let nvram variables override subsystem Vend/ID */
-		if ((sii->pub.boardvendor =
-		     (uint16) si_getdevpathintvar(&sii->pub, "boardvendor"))
-		    == 0)
+		sii->pub.boardvendor = (uint16)si_getdevpathintvar(&sii->pub,
+			"boardvendor");
+		if (sii->pub.boardvendor == 0)
 			sii->pub.boardvendor = w & 0xffff;
 		else
 			SI_ERROR(("Overriding boardvendor: 0x%x instead of 0x%x\n", sii->pub.boardvendor, w & 0xffff));
-		if ((sii->pub.boardtype =
-		     (uint16) si_getdevpathintvar(&sii->pub, "boardtype"))
-		    == 0)
+		sii->pub.boardtype = (uint16)si_getdevpathintvar(&sii->pub,
+			"boardtype");
+		if (sii->pub.boardtype == 0)
 			sii->pub.boardtype = (w >> 16) & 0xffff;
 		else
 			SI_ERROR(("Overriding boardtype: 0x%x instead of 0x%x\n", sii->pub.boardtype, (w >> 16) & 0xffff));
@@ -331,11 +331,12 @@ static void BCMATTACHFN(si_nvram_process
 	case SI_BUS:
 	case JTAG_BUS:
 		sii->pub.boardvendor = VENDOR_BROADCOM;
-		if (pvars == NULL
-		    || ((sii->pub.boardtype = getintvar(pvars, "prodid")) == 0))
-			if ((sii->pub.boardtype =
-			     getintvar(NULL, "boardtype")) == 0)
+		sii->pub.boardtype = getintvar(pvars, "prodid");
+		if (pvars == NULL || (sii->pub.boardtype == 0)) {
+			sii->pub.boardtype = getintvar(NULL, "boardtype");
+			if (sii->pub.boardtype == 0)
 				sii->pub.boardtype = 0xffff;
+		}
 		break;
 	}
 
@@ -456,7 +457,8 @@ static si_info_t *BCMATTACHFN(si_doattac
 	}
 
 	/* setup the GPIO based LED powersave register */
-	if ((w = getintvar(pvars, "leddc")) == 0)
+	w = getintvar(pvars, "leddc");
+	if (w == 0)
 		w = DEFAULT_GPIOTIMERVAL;
 	sb_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiotimerval), ~0, w);
 
@@ -614,7 +616,8 @@ static si_info_t *BCMATTACHFN(si_doattac
 	}
 
 	/* setup the GPIO based LED powersave register */
-	if ((w = getintvar(pvars, "leddc")) == 0)
+	w = getintvar(pvars, "leddc");
+	if (w == 0)
 		w = DEFAULT_GPIOTIMERVAL;
 	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiotimerval), ~0, w);
 
@@ -1331,15 +1334,24 @@ uint16 BCMATTACHFN(si_d11_devid) (si_t *
 	uint16 device;
 
 	/* normal case: nvram variable with devpath->devid->wl0id */
-	if ((device = (uint16) si_getdevpathintvar(sih, "devid")) != 0) ;
+	device = (uint16) si_getdevpathintvar(sih, "devid");
+	if (device != 0)
+		goto bail;
+
 	/* Get devid from OTP/SPROM depending on where the SROM is read */
-	else if ((device = (uint16) getintvar(sii->vars, "devid")) != 0) ;
+	device = (uint16) getintvar(sii->vars, "devid");
+	if (device != 0)
+		goto bail;
+
 	/* no longer support wl0id, but keep the code here for backward compatibility. */
-	else if ((device = (uint16) getintvar(sii->vars, "wl0id")) != 0) ;
-	else
-		/* ignore it */
-		device = 0xffff;
+	device = (uint16) getintvar(sii->vars, "wl0id");
+	if (device != 0)
+		goto bail;
+
+	/* ignore it */
+	device = 0xffff;
 
+bail:
 	return device;
 }
 
@@ -1448,11 +1460,14 @@ void BCMINITFN(si_clkctl_init) (si_t *si
 	fast = SI_FAST(sii);
 	if (!fast) {
 		origidx = sii->curidx;
-		if ((cc =
-		     (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0)) == NULL)
+		cc = (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0);
+		if (cc == NULL)
 			return;
-	} else if ((cc = (chipcregs_t *) CCREGS_FAST(sii)) == NULL)
-		return;
+	} else {
+		cc = (chipcregs_t *) CCREGS_FAST(sii);
+		if (cc == NULL)
+			return;
+	}
 	ASSERT(cc != NULL);
 
 	/* set all Instaclk chip ILP to 1 MHz */
@@ -1493,11 +1508,14 @@ uint16 BCMINITFN(si_clkctl_fast_pwrup_de
 	if (!fast) {
 		origidx = sii->curidx;
 		INTR_OFF(sii, intr_val);
-		if ((cc =
-		     (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0)) == NULL)
+		cc = (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0);
+		if (cc == NULL)
 			goto done;
-	} else if ((cc = (chipcregs_t *) CCREGS_FAST(sii)) == NULL)
-		goto done;
+	} else {
+		cc = (chipcregs_t *) CCREGS_FAST(sii);
+		if (cc == NULL)
+			goto done;
+	}
 	ASSERT(cc != NULL);
 
 	slowminfreq = si_slowclk_freq(sii, FALSE, cc);
@@ -1640,8 +1658,11 @@ static bool _si_clkctl_cc(si_info_t *sii
 			goto done;
 
 		cc = (chipcregs_t *) si_setcore(&sii->pub, CC_CORE_ID, 0);
-	} else if ((cc = (chipcregs_t *) CCREGS_FAST(sii)) == NULL)
-		goto done;
+	} else {
+		cc = (chipcregs_t *) CCREGS_FAST(sii);
+		if (cc == NULL)
+			goto done;
+	}
 	ASSERT(cc != NULL);
 
 	if (!CCCTL_ENAB(&sii->pub) && (sii->pub.ccrev < 20))
@@ -1893,9 +1914,8 @@ void si_sdio_init(si_t *sih)
 		ASSERT(idx == si_findcoreidx(sih, D11_CORE_ID, 0));
 
 		/* switch to sdio core */
-		if (!
-		    (sdpregs =
-		     (sdpcmd_regs_t *) si_setcore(sih, PCMCIA_CORE_ID, 0)))
+		sdpregs = (sdpcmd_regs_t *) si_setcore(sih, PCMCIA_CORE_ID, 0);
+		if (!sdpregs)
 			sdpregs =
 			    (sdpcmd_regs_t *) si_setcore(sih, SDIOD_CORE_ID, 0);
 		ASSERT(sdpregs);
@@ -2408,7 +2428,8 @@ void *BCMATTACHFN(si_gpio_handler_regist
 	if (sih->ccrev < 11)
 		return NULL;
 
-	if ((gi = MALLOC(sii->osh, sizeof(gpioh_item_t))) == NULL)
+	gi = MALLOC(sii->osh, sizeof(gpioh_item_t));
+	if (gi == NULL)
 		return NULL;
 
 	bzero(gi, sizeof(gpioh_item_t));
@@ -2525,11 +2546,13 @@ void si_socdevram(si_t *sih, bool set, u
 		*enable = *protect = 0;
 
 	/* Switch to SOCRAM core */
-	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
+	regs = si_setcore(sih, SOCRAM_CORE_ID, 0);
+	if (!regs)
 		goto done;
 
 	/* Get info for determining size */
-	if (!(wasup = si_iscoreup(sih)))
+	wasup = si_iscoreup(sih);
+	if (!wasup)
 		si_core_reset(sih, 0, 0);
 
 	corerev = si_corerev(sih);
@@ -2606,11 +2629,13 @@ uint32 si_socdevram_size(si_t *sih)
 	origidx = si_coreidx(sih);
 
 	/* Switch to SOCRAM core */
-	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
+	regs = si_setcore(sih, SOCRAM_CORE_ID, 0);
+	if (!regs)
 		goto done;
 
 	/* Get info for determining size */
-	if (!(wasup = si_iscoreup(sih)))
+	wasup = si_iscoreup(sih);
+	if (!wasup)
 		si_core_reset(sih, 0, 0);
 
 	corerev = si_corerev(sih);
@@ -2659,11 +2684,13 @@ uint32 si_socram_size(si_t *sih)
 	origidx = si_coreidx(sih);
 
 	/* Switch to SOCRAM core */
-	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
+	regs = si_setcore(sih, SOCRAM_CORE_ID, 0);
+	if (!regs)
 		goto done;
 
 	/* Get info for determining size */
-	if (!(wasup = si_iscoreup(sih)))
+	wasup = si_iscoreup(sih);
+	if (!wasup)
 		si_core_reset(sih, 0, 0);
 	corerev = si_corerev(sih);
 	coreinfo = R_REG(sii->osh, &regs->coreinfo);

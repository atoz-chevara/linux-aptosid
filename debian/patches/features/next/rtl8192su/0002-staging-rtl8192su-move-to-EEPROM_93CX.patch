From e3133b282af36665593b2802eaa591538ebe5f11 Mon Sep 17 00:00:00 2001
From: Florian Schilhabel <florian.c.schilhabel@googlemail.com>
Date: Sat, 6 Mar 2010 20:44:33 +0100
Subject: [PATCH 02/18] staging: rtl8192su: move to EEPROM_93CX

this is basically a port of Larry Fingers Patch for rtl8187se to rtl8192su.
also removed some dead code.
plus cosmetics.

Signed-off-by: Florian Schilhabel <florian.c.schilhabel@googlemail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rtl8192su/Kconfig       |    1 +
 drivers/staging/rtl8192su/Makefile      |    1 -
 drivers/staging/rtl8192su/r8180_93cx6.c |  146 -------------------------------
 drivers/staging/rtl8192su/r8180_93cx6.h |   40 ---------
 drivers/staging/rtl8192su/r8192U.h      |    6 ++
 drivers/staging/rtl8192su/r8192U_core.c |  113 ++++++++++++++----------
 6 files changed, 74 insertions(+), 233 deletions(-)
 delete mode 100644 drivers/staging/rtl8192su/r8180_93cx6.c
 delete mode 100644 drivers/staging/rtl8192su/r8180_93cx6.h

--- a/drivers/staging/rtl8192su/Kconfig
+++ b/drivers/staging/rtl8192su/Kconfig
@@ -3,5 +3,6 @@ config RTL8192SU
 	depends on PCI && WLAN && USB
 	select WIRELESS_EXT
 	select WEXT_PRIV
+	select EEPROM_93CX6
 	default N
 	---help---
--- a/drivers/staging/rtl8192su/Makefile
+++ b/drivers/staging/rtl8192su/Makefile
@@ -9,7 +9,6 @@ EXTRA_CFLAGS += -DTHOMAS_BEACON
 #EXTRA_CFLAGS += -DMUTIPLE_BULK_OUT
 
 r8192s_usb-objs :=		\
-	r8180_93cx6.o		\
 	r8192U_wx.o		\
 	r8192S_phy.o		\
 	r8192S_rtl6052.o	\
--- a/drivers/staging/rtl8192su/r8180_93cx6.c
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
-   This files contains card eeprom (93c46 or 93c56) programming routines,
-   memory is addressed by 16 bits words.
-
-   This is part of rtl8180 OpenSource driver.
-   Copyright (C) Andrea Merello 2004  <andreamrl@tiscali.it>
-   Released under the terms of GPL (General Public Licence)
-
-   Parts of this driver are based on the GPL part of the
-   official realtek driver.
-
-   Parts of this driver are based on the rtl8180 driver skeleton
-   from Patric Schenke & Andres Salomon.
-
-   Parts of this driver are based on the Intel Pro Wireless 2100 GPL driver.
-
-   We want to tanks the Authors of those projects and the Ndiswrapper
-   project Authors.
-*/
-
-#include "r8180_93cx6.h"
-
-void eprom_cs(struct net_device *dev, short bit)
-{
-	if(bit)
-		write_nic_byte_E(dev, EPROM_CMD,
-			       (1<<EPROM_CS_SHIFT) | \
-			       read_nic_byte_E(dev, EPROM_CMD)); //enable EPROM
-	else
-		write_nic_byte_E(dev, EPROM_CMD, read_nic_byte_E(dev, EPROM_CMD)\
-			       &~(1<<EPROM_CS_SHIFT)); //disable EPROM
-
-	force_pci_posting(dev);
-	udelay(EPROM_DELAY);
-}
-
-
-void eprom_ck_cycle(struct net_device *dev)
-{
-	write_nic_byte_E(dev, EPROM_CMD,
-		       (1<<EPROM_CK_SHIFT) | read_nic_byte_E(dev,EPROM_CMD));
-	force_pci_posting(dev);
-	udelay(EPROM_DELAY);
-	write_nic_byte_E(dev, EPROM_CMD,
-		       read_nic_byte_E(dev, EPROM_CMD) &~ (1<<EPROM_CK_SHIFT));
-	force_pci_posting(dev);
-	udelay(EPROM_DELAY);
-}
-
-
-void eprom_w(struct net_device *dev,short bit)
-{
-	if(bit)
-		write_nic_byte_E(dev, EPROM_CMD, (1<<EPROM_W_SHIFT) | \
-			       read_nic_byte_E(dev,EPROM_CMD));
-	else
-		write_nic_byte_E(dev, EPROM_CMD, read_nic_byte_E(dev,EPROM_CMD)\
-			       &~(1<<EPROM_W_SHIFT));
-
-	force_pci_posting(dev);
-	udelay(EPROM_DELAY);
-}
-
-
-short eprom_r(struct net_device *dev)
-{
-	short bit;
-
-	bit=(read_nic_byte_E(dev, EPROM_CMD) & (1<<EPROM_R_SHIFT) );
-	udelay(EPROM_DELAY);
-
-	if(bit) return 1;
-	return 0;
-}
-
-
-void eprom_send_bits_string(struct net_device *dev, short b[], int len)
-{
-	int i;
-
-	for(i=0; i<len; i++){
-		eprom_w(dev, b[i]);
-		eprom_ck_cycle(dev);
-	}
-}
-
-
-u32 eprom_read(struct net_device *dev, u32 addr)
-{
-	struct r8192_priv *priv = ieee80211_priv(dev);
-	short read_cmd[]={1,1,0};
-	short addr_str[8];
-	int i;
-	int addr_len;
-	u32 ret;
-
-	ret=0;
-        //enable EPROM programming
-	write_nic_byte_E(dev, EPROM_CMD,
-		       (EPROM_CMD_PROGRAM<<EPROM_CMD_OPERATING_MODE_SHIFT));
-	force_pci_posting(dev);
-	udelay(EPROM_DELAY);
-
-	if (priv->epromtype==EPROM_93c56){
-		addr_str[7]=addr & 1;
-		addr_str[6]=addr & (1<<1);
-		addr_str[5]=addr & (1<<2);
-		addr_str[4]=addr & (1<<3);
-		addr_str[3]=addr & (1<<4);
-		addr_str[2]=addr & (1<<5);
-		addr_str[1]=addr & (1<<6);
-		addr_str[0]=addr & (1<<7);
-		addr_len=8;
-	}else{
-		addr_str[5]=addr & 1;
-		addr_str[4]=addr & (1<<1);
-		addr_str[3]=addr & (1<<2);
-		addr_str[2]=addr & (1<<3);
-		addr_str[1]=addr & (1<<4);
-		addr_str[0]=addr & (1<<5);
-		addr_len=6;
-	}
-	eprom_cs(dev, 1);
-	eprom_ck_cycle(dev);
-	eprom_send_bits_string(dev, read_cmd, 3);
-	eprom_send_bits_string(dev, addr_str, addr_len);
-
-	//keep chip pin D to low state while reading.
-	//I'm unsure if it is necessary, but anyway shouldn't hurt
-	eprom_w(dev, 0);
-
-	for(i=0;i<16;i++){
-		//eeprom needs a clk cycle between writing opcode&adr
-		//and reading data. (eeprom outs a dummy 0)
-		eprom_ck_cycle(dev);
-		ret |= (eprom_r(dev)<<(15-i));
-	}
-
-	eprom_cs(dev, 0);
-	eprom_ck_cycle(dev);
-
-	//disable EPROM programming
-	write_nic_byte_E(dev, EPROM_CMD,
-		       (EPROM_CMD_NORMAL<<EPROM_CMD_OPERATING_MODE_SHIFT));
-	return ret;
-}
--- a/drivers/staging/rtl8192su/r8180_93cx6.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-	This is part of rtl8187 OpenSource driver
-	Copyright (C) Andrea Merello 2004-2005  <andreamrl@tiscali.it>
-	Released under the terms of GPL (General Public Licence)
-
-	Parts of this driver are based on the GPL part of the official realtek driver
-	Parts of this driver are based on the rtl8180 driver skeleton from Patric Schenke & Andres Salomon
-	Parts of this driver are based on the Intel Pro Wireless 2100 GPL driver
-
-	We want to tanks the Authors of such projects and the Ndiswrapper project Authors.
-*/
-
-/*This files contains card eeprom (93c46 or 93c56) programming routines*/
-/*memory is addressed by WORDS*/
-
-#include "r8192U.h"
-#include "r8192S_hw.h"
-
-#define EPROM_DELAY 10
-
-#define EPROM_ANAPARAM_ADDRLWORD 0xd
-#define EPROM_ANAPARAM_ADDRHWORD 0xe
-
-#define EPROM_RFCHIPID 0x6
-#define EPROM_TXPW_BASE 0x05
-#define EPROM_RFCHIPID_RTL8225U 5
-#define EPROM_RF_PARAM 0x4
-#define EPROM_CONFIG2 0xc
-
-#define EPROM_VERSION 0x1E
-#define MAC_ADR 0x7
-
-#define CIS 0x18
-
-#define EPROM_TXPW0 0x16
-#define EPROM_TXPW2 0x1b
-#define EPROM_TXPW1 0x3d
-
-
-u32 eprom_read(struct net_device *dev,u32 addr); //reads a 16 bits word
--- a/drivers/staging/rtl8192su/r8192U.h
+++ b/drivers/staging/rtl8192su/r8192U.h
@@ -44,6 +44,12 @@
 
 #include "r8192S_firmware.h"
 
+/* EEPROM defs for use with linux/eeprom_93cx6.h */
+#define RTL819X_EEPROM_CMD_READ		(1 << 0)
+#define RTL819X_EEPROM_CMD_WRITE	(1 << 1)
+#define RTL819X_EEPROM_CMD_CK		(1 << 2)
+#define RTL819X_EEPROM_CMD_CS		(1 << 3)
+
 //#define RTL8192U
 #define RTL819xU_MODULE_NAME "rtl819xU"
 //added for HW security, john.0629
--- a/drivers/staging/rtl8192su/r8192U_core.c
+++ b/drivers/staging/rtl8192su/r8192U_core.c
@@ -26,6 +26,7 @@
 
 #include <linux/vmalloc.h>
 #include <linux/slab.h>
+#include <linux/eeprom_93cx6.h>
 
 #undef LOOP_TEST
 #undef DUMP_RX
@@ -54,7 +55,6 @@
 
 #include <asm/uaccess.h>
 #include "r8192U.h"
-#include "r8180_93cx6.h"   /* Card EEPROM */
 #include "r8192U_wx.h"
 
 #include "r8192S_rtl8225.h"
@@ -217,6 +217,36 @@ static CHANNEL_LIST ChannelPlan[] = {
 	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14},14}					//For Global Domain. 1-11:active scan, 12-14 passive scan. //+YJ, 080626
 };
 
+static void rtl819x_eeprom_register_read(struct eeprom_93cx6 *eeprom)
+{
+	struct net_device *dev = eeprom->data;
+	u8 reg = read_nic_byte(dev, EPROM_CMD);
+
+	eeprom->reg_data_in = reg & RTL819X_EEPROM_CMD_WRITE;
+	eeprom->reg_data_out = reg & RTL819X_EEPROM_CMD_READ;
+	eeprom->reg_data_clock = reg & RTL819X_EEPROM_CMD_CK;
+	eeprom->reg_chip_select = reg & RTL819X_EEPROM_CMD_CS;
+}
+
+static void rtl819x_eeprom_register_write(struct eeprom_93cx6 *eeprom)
+{
+	struct net_device *dev = eeprom->data;
+	u8 reg = 2 << 6;
+
+	if (eeprom->reg_data_in)
+		reg |= RTL819X_EEPROM_CMD_WRITE;
+	if (eeprom->reg_data_out)
+		reg |= RTL819X_EEPROM_CMD_READ;
+	if (eeprom->reg_data_clock)
+		reg |= RTL819X_EEPROM_CMD_CK;
+	if (eeprom->reg_chip_select)
+		reg |= RTL819X_EEPROM_CMD_CS;
+
+	write_nic_byte(dev, EPROM_CMD, reg);
+	read_nic_byte(dev, EPROM_CMD);
+	udelay(10);
+}
+
 static void rtl819x_set_channel_map(u8 channel_plan, struct r8192_priv* priv)
 {
 	int i, max_chan=-1, min_chan=-1;
@@ -1155,15 +1185,6 @@ void tx_timeout(struct net_device *dev)
 	//DMESG("TXTIMEOUT");
 }
 
-
-/* this is only for debug */
-void dump_eprom(struct net_device *dev)
-{
-	int i;
-	for(i=0; i<63; i++)
-		RT_TRACE(COMP_EPROM, "EEPROM addr %x : %x", i, eprom_read(dev,i));
-}
-
 /* this is only for debug */
 void rtl8192_dump_reg(struct net_device *dev)
 {
@@ -3534,26 +3555,32 @@ rtl8192SU_ConfigAdapterInfo8192SForAutoL
 //
 //	Created by Roger, 2008.10.21.
 //
-void
-rtl8192SU_ReadAdapterInfo8192SUsb(struct net_device* dev)
+void rtl8192SU_ReadAdapterInfo8192SUsb(struct net_device* dev)
 {
-	struct r8192_priv 	*priv = ieee80211_priv(dev);
-	u16			i,usValue;
-	u8			tmpU1b, tempval;
-	u16			EEPROMId;
-	u8			hwinfo[HWSET_MAX_SIZE_92S];
-	u8			rf_path, index;	// For EEPROM/EFUSE After V0.6_1117
-
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u16 i;
+	u8 tmpU1b, tempval;
+	u16 EEPROMId;
+	u8 hwinfo[HWSET_MAX_SIZE_92S];
+	u8 rf_path, index;	// For EEPROM/EFUSE After V0.6_1117
+	struct eeprom_93cx6 eeprom;
+	u16 eeprom_val;
+
+	eeprom.data = dev;
+	eeprom.register_read = rtl819x_eeprom_register_read;
+	eeprom.register_write = rtl819x_eeprom_register_write;
+	if (priv->epromtype == EPROM_93c46)
+		eeprom.width = PCI_EEPROM_WIDTH_93C46;
+	else
+		eeprom.width = PCI_EEPROM_WIDTH_93C56;
 
 	RT_TRACE(COMP_INIT, "====> ReadAdapterInfo8192SUsb\n");
 
-	//
-	// <Roger_Note> The following operation are prevent Efuse leakage by turn on 2.5V.
-	// 2008.11.25.
-	//
+	/*
+	 * The following operation are prevent Efuse leakage by turn on 2.5V..
+	 */
 	tmpU1b = read_nic_byte(dev, EFUSE_TEST+3);
 	write_nic_byte(dev, EFUSE_TEST+3, tmpU1b|0x80);
-	//PlatformStallExecution(1000);
 	mdelay(10);
 	write_nic_byte(dev, EFUSE_TEST+3, (tmpU1b&(~BIT7)));
 
@@ -3561,21 +3588,20 @@ rtl8192SU_ReadAdapterInfo8192SUsb(struct
 	priv->card_8192_version = (VERSION_8192S)((read_nic_dword(dev, PMC_FSM)>>16)&0xF);
 	RT_TRACE(COMP_INIT, "Chip Version ID: 0x%2x\n", priv->card_8192_version);
 
-	switch(priv->card_8192_version)
-	{
-		case 0:
-			RT_TRACE(COMP_INIT, "Chip Version ID: VERSION_8192S_ACUT.\n");
-			break;
-		case 1:
-			RT_TRACE(COMP_INIT, "Chip Version ID: VERSION_8192S_BCUT.\n");
-			break;
-		case 2:
-			RT_TRACE(COMP_INIT, "Chip Version ID: VERSION_8192S_CCUT.\n");
-			break;
-		default:
-			RT_TRACE(COMP_INIT, "Unknown Chip Version!!\n");
-			priv->card_8192_version = VERSION_8192S_BCUT;
-			break;
+	switch (priv->card_8192_version) {
+	case 0:
+		RT_TRACE(COMP_INIT, "Chip Version ID: VERSION_8192S_ACUT.\n");
+		break;
+	case 1:
+		RT_TRACE(COMP_INIT, "Chip Version ID: VERSION_8192S_BCUT.\n");
+		break;
+	case 2:
+		RT_TRACE(COMP_INIT, "Chip Version ID: VERSION_8192S_CCUT.\n");
+		break;
+	default:
+		RT_TRACE(COMP_INIT, "Unknown Chip Version!!\n");
+		priv->card_8192_version = VERSION_8192S_BCUT;
+		break;
 	}
 
 	//if (IS_BOOT_FROM_EEPROM(Adapter))
@@ -3588,8 +3614,8 @@ rtl8192SU_ReadAdapterInfo8192SUsb(struct
 		// Read all Content from EEPROM or EFUSE.
 		for(i = 0; i < HWSET_MAX_SIZE_92S; i += 2)
 		{
-			usValue = eprom_read(dev, (u16) (i>>1));
-			*((u16*)(&hwinfo[i])) = usValue;
+			eeprom_93cx6_read(&eeprom, (u16) (i>>1), &eeprom_val);
+			*((u16 *)(&hwinfo[i])) = eeprom_val;
 		}
 	}
 	else if (!(priv->EepromOrEfuse))
@@ -4141,11 +4167,6 @@ short rtl8192_init(struct net_device *de
 	init_timer(&priv->watch_dog_timer);
 	priv->watch_dog_timer.data = (unsigned long)dev;
 	priv->watch_dog_timer.function = watch_dog_timer_callback;
-
-	//rtl8192_adapter_start(dev);
-#ifdef DEBUG_EPROM
-	dump_eprom(dev);
-#endif
 	return 0;
 }
 

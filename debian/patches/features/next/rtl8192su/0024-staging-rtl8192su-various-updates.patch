From 653e99e316a8579fd933386d7d4be40e6c9170e5 Mon Sep 17 00:00:00 2001
From: Florian Schilhabel <florian.c.schilhabel@googlemail.com>
Date: Wed, 14 Jul 2010 14:47:27 +0200
Subject: [PATCH 24/41] staging: rtl8192su: various updates

Signed-off-by: Florian Schilhabel <florian.c.schilhabel@googlemail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 .../staging/rtl8192su/ieee80211/ieee80211_r8192s.h |   43 +++--
 drivers/staging/rtl8192su/r8192S_firmware.c        |   26 ++-
 drivers/staging/rtl8192su/r8192S_firmware.h        |  100 ++++++-----
 drivers/staging/rtl8192su/r8192S_hw.h              |   83 +++++----
 drivers/staging/rtl8192su/r8192S_phy.c             |  183 +++++++++----------
 5 files changed, 232 insertions(+), 203 deletions(-)

--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_r8192s.h
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_r8192s.h
@@ -339,28 +339,39 @@ enum {
 };
 
 /* Firmware related CMD IO. */
-typedef enum _FW_CMD_IO_TYPE {
-	FW_CMD_DIG_ENABLE = 0,		/* for DIG DM */
+typedef	enum _FW_CMD_IO_TYPE{
+	FW_CMD_DIG_ENABLE = 0, /* for DIG DM */
 	FW_CMD_DIG_DISABLE = 1,
 	FW_CMD_DIG_HALT = 2,
 	FW_CMD_DIG_RESUME = 3,
-	FW_CMD_HIGH_PWR_ENABLE = 4,	/* for High Power DM */
+	FW_CMD_HIGH_PWR_ENABLE = 4, /* for DIG DM */
 	FW_CMD_HIGH_PWR_DISABLE = 5,
-	FW_CMD_RA_RESET = 6,		/* for Rate adaptive DM */
-	FW_CMD_RA_ACTIVE = 7,
-	FW_CMD_RA_REFRESH_N = 8,
-	FW_CMD_RA_REFRESH_BG = 9,
-	FW_CMD_IQK_ENABLE = 10,		/* for FW supported IQK */
-	FW_CMD_TXPWR_TRACK_ENABLE = 11,	/* Tx power tracking switch */
-	FW_CMD_TXPWR_TRACK_DISABLE = 12,/* Tx power tracking switch */
-	FW_CMD_PAUSE_DM_BY_SCAN = 13,
-	FW_CMD_RESUME_DM_BY_SCAN = 14,
-	FW_CMD_MID_HIGH_PWR_ENABLE = 15,
+	FW_CMD_RA_RESET = 6, /* for DIG DM */
+	FW_CMD_RA_ACTIVE= 7,
+	FW_CMD_RA_REFRESH_N= 8,
+	FW_CMD_RA_REFRESH_BG= 9,
+	FW_CMD_RA_INIT= 10, /* for FW supported IQK */
+	FW_CMD_IQK_ENABLE = 11, /* Tx power tracking switch */
+	FW_CMD_TXPWR_TRACK_ENABLE = 12, /* Tx power tracking switch */
+	FW_CMD_TXPWR_TRACK_DISABLE = 13,
+	FW_CMD_TXPWR_TRACK_THERMAL = 14,
+	FW_CMD_PAUSE_DM_BY_SCAN = 15,
 	/* indicate firmware that driver enters LPS, for PS-Poll hardware bug */
-	FW_CMD_LPS_ENTER = 16,
+	FW_CMD_RESUME_DM_BY_SCAN = 16,
 	/* indicate firmware that driver leave LPS */
-	FW_CMD_LPS_LEAVE = 17,
-} FW_CMD_IO_TYPE;
+	FW_CMD_RA_REFRESH_N_COMB = 17,
+	FW_CMD_RA_REFRESH_BG_COMB = 18,
+	FW_CMD_ANTENNA_SW_ENABLE = 19,
+	FW_CMD_ANTENNA_SW_DISABLE = 20,
+	FW_CMD_TX_FEEDBACK_CCX_ENABLE = 21,
+	FW_CMD_LPS_ENTER = 22,
+	FW_CMD_LPS_LEAVE = 23,
+	FW_CMD_DIG_MODE_SS = 24,
+	FW_CMD_DIG_MODE_FA = 25,
+	FW_CMD_ADD_A2_ENTRY = 26,
+	FW_CMD_CTRL_DM_BY_DRIVER = 27,
+	FW_CMD_CTRL_DM_BY_DRIVER_NEW = 28,
+}FW_CMD_IO_TYPE,*PFW_CMD_IO_TYPE;
 
 #define RT_MAX_LD_SLOT_NUM	10
 struct rt_link_detect {
--- a/drivers/staging/rtl8192su/r8192S_firmware.c
+++ b/drivers/staging/rtl8192su/r8192S_firmware.c
@@ -1,16 +1,22 @@
-/**************************************************************************************************
- * Procedure:    Init boot code/firmware code/data session
+/******************************************************************************
+ * Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  *
- * Description: This routine will intialize firmware. If any error occurs during the initialization
- * 		process, the routine shall terminate immediately and return fail.
- *		NIC driver should call NdisOpenFile only from MiniportInitialize.
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  *
- * Arguments:   The pointer of the adapter
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+******************************************************************************/
 
- * Returns:
- *        NDIS_STATUS_FAILURE - the following initialization process should be terminated
- *        NDIS_STATUS_SUCCESS - if firmware initialization process success
-**************************************************************************************************/
 #include "r8192U.h"
 #include "r8192S_firmware.h"
 #include <linux/unistd.h>
--- a/drivers/staging/rtl8192su/r8192S_firmware.h
+++ b/drivers/staging/rtl8192su/r8192S_firmware.h
@@ -1,44 +1,32 @@
+/******************************************************************************
+ * Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+******************************************************************************/
 #ifndef __INC_FIRMWARE_H
 #define __INC_FIRMWARE_H
 
 
-//#define RTL8190_CPU_START_OFFSET	0x80
-/* TODO: this definition is TBD */
-//#define USB_HWDESC_HEADER_LEN	0
-
-/* It should be double word alignment */
-//#if DEV_BUS_TYPE==PCI_INTERFACE
-//#define GET_COMMAND_PACKET_FRAG_THRESHOLD(v)	4*(v/4) - 8
-//#else
-//#define GET_COMMAND_PACKET_FRAG_THRESHOLD(v)	(4*(v/4) - 8 - USB_HWDESC_HEADER_LEN)
-//#endif
-
-//typedef enum _firmware_init_step{
-//	FW_INIT_STEP0_BOOT = 0,
-//	FW_INIT_STEP1_MAIN = 1,
-//	FW_INIT_STEP2_DATA = 2,
-//}firmware_init_step_e;
-
-//typedef enum _DESC_PACKET_TYPE{
-//	DESC_PACKET_TYPE_INIT = 0,
-//	DESC_PACKET_TYPE_NORMAL = 1,
-//}DESC_PACKET_TYPE;
-#define	RTL8192S_FW_PKT_FRAG_SIZE		0xFF00	// 64K
-
-
 #define 	RTL8190_MAX_FIRMWARE_CODE_SIZE	64000	//64k
 #define	MAX_FIRMWARE_CODE_SIZE	0xFF00 // Firmware Local buffer size.
 #define 	RTL8190_CPU_START_OFFSET			0x80
-
+#define	RTL8192S_FW_PKT_FRAG_SIZE		0x4000
 #define GET_COMMAND_PACKET_FRAG_THRESHOLD(v)	(4*(v/4) - 8 - USB_HWDESC_HEADER_LEN)
 
-//typedef enum _DESC_PACKET_TYPE{
-//	DESC_PACKET_TYPE_INIT = 0,
-//	DESC_PACKET_TYPE_NORMAL = 1,
-//}DESC_PACKET_TYPE;
 
-// Forward declaration.
-//typedef	struct _ADAPTER	ADAPTER, *PADAPTER;
 #ifdef RTL8192S
 typedef enum _firmware_init_step{
 	FW_INIT_STEP0_IMEM = 0,
@@ -64,17 +52,8 @@ typedef enum _opt_rst_type{
 	OPT_FIRMWARE_RESET = 1,
 }opt_rst_type_e;
 
-/*typedef enum _FIRMWARE_STATUS{
-	FW_STATUS_0_INIT = 0,
-	FW_STATUS_1_MOVE_BOOT_CODE = 1,
-	FW_STATUS_2_MOVE_MAIN_CODE = 2,
-	FW_STATUS_3_TURNON_CPU = 3,
-	FW_STATUS_4_MOVE_DATA_CODE = 4,
-	FW_STATUS_5_READY = 5,
-}FIRMWARE_STATUS;
-*/
 //--------------------------------------------------------------------------------
-// RTL8192S Firmware related, Revised by Roger, 2008.12.18.
+// RTL8192S Firmware related
 //--------------------------------------------------------------------------------
 typedef  struct _RT_8192S_FIRMWARE_PRIV { //8-bytes alignment required
 
@@ -181,7 +160,6 @@ typedef enum _FIRMWARE_8192S_STATUS{
 typedef struct _rt_firmware{
 	PRT_8192S_FIRMWARE_HDR	pFwHeader;
 	FIRMWARE_8192S_STATUS	FWStatus;
-	u16             FirmwareVersion;
 	u8		FwIMEM[RTL8190_MAX_FIRMWARE_CODE_SIZE];
 	u8		FwEMEM[RTL8190_MAX_FIRMWARE_CODE_SIZE];
 	u32		FwIMEMLen;
@@ -189,11 +167,43 @@ typedef struct _rt_firmware{
 	u8		szFwTmpBuffer[164000];
         u32             szFwTmpBufferLen;
 	u16		CmdPacketFragThresold;
+	u16		FirmwareVersion;
 }rt_firmware, *prt_firmware;
 
-//typedef struct _RT_FIRMWARE_INFO_8192SU{
-//	u8		szInfo[16];
-//}RT_FIRMWARE_INFO_8192SU, *PRT_FIRMWARE_INFO_8192SU;
+#define		FW_DIG_ENABLE_CTL			BIT0
+#define		FW_HIGH_PWR_ENABLE_CTL		BIT1
+#define		FW_SS_CTL						BIT2
+#define		FW_RA_INIT_CTL				BIT3
+#define		FW_RA_BG_CTL					BIT4
+#define		FW_RA_N_CTL					BIT5
+#define		FW_PWR_TRK_CTL				BIT6
+#define		FW_IQK_CTL						BIT7
+#define		FW_ANTENNA_SW				BIT8
+#define		FW_DISABLE_ALL_DM			0
+
+#define		FW_PWR_TRK_PARAM_CLR		0x0000ffff
+#define		FW_RA_PARAM_CLR				0xffff0000
+
+#define	FW_CMD_IO_CLR(_pdev, _Bit)		\
+	udelay(1000);		\
+	((struct r8192_priv *)ieee80211_priv(_pdev))->FwCmdIOMap &= (~_Bit);
+
+#define	FW_CMD_IO_UPDATE(_pdev, _val)		\
+	((struct r8192_priv *)ieee80211_priv(_pdev))->FwCmdIOMap = _val;
+
+#define		FW_CMD_IO_SET(_pdev, _val) 	\
+	write_nic_word(_pdev, LBUS_MON_ADDR, (u16)_val);	\
+	FW_CMD_IO_UPDATE(_pdev, _val);
+
+#define		FW_CMD_PARA_SET(_pdev, _val) 		\
+	write_nic_dword(_pdev, LBUS_ADDR_MASK, _val);	\
+	((struct r8192_priv *)ieee80211_priv(_pdev))->FwCmdIOParam = _val;
+
+#define		FW_CMD_IO_QUERY(_pdev)	(u16)(((struct r8192_priv *)ieee80211_priv(_pdev))->FwCmdIOMap)
+#define	FW_CMD_IO_PARA_QUERY(_pdev)	(u32)(((struct r8192_priv *)ieee80211_priv(_pdev))->FwCmdIOParam)
+
+
+
 bool FirmwareDownload92S(struct net_device *dev);
 
 #endif
--- a/drivers/staging/rtl8192su/r8192S_hw.h
+++ b/drivers/staging/rtl8192su/r8192S_hw.h
@@ -1,25 +1,22 @@
-/*****************************************************************************
- *	Copyright(c) 2008,  RealTEK Technology Inc. All Right Reserved.
+/******************************************************************************
+ * Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  *
- * Module:	__INC_HAL8192SEREG_H
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
  *
- * Note:	1. Define Mac register address and corresponding bit mask map
- *			2. CCX register
- *			3. Backward compatible register with useless address.
- *			4. Define 92SU required register address and definition.
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
  *
- *
- * Export:	Constants, macro, functions(API), global variables(None).
- *
- * Abbrev:
- *
- * History:
- *		Data		Who		Remark
- *      08/07/2007  MHC    	1. Porting from 9x series PHYCFG.h.
- *							2. Reorganize code architecture.
- *
- *****************************************************************************/
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+******************************************************************************/
+
 #ifndef R8192S_HW
 #define R8192S_HW
 
@@ -58,10 +55,10 @@ typedef enum _BaseBand_Config_Type{
 #define	RTL8187_REQ_SET_REGS	0x05
 
 #define MAX_TX_URB 5
-#define MAX_RX_URB 16
+#define MAX_RX_URB 8
 
 #define R8180_MAX_RETRY 255
-#define RX_URB_SIZE 		9100
+#define RX_URB_SIZE 		0x4000
 
 #define BB_ANTATTEN_CHAN14	0x0c
 #define BB_ANTENNA_B 		0x40
@@ -122,7 +119,6 @@ typedef enum _BaseBand_Config_Type{
 #define MSR_LINK_ENEDCA	   	(1<<4)
 
 
-//#define Cmd9346CR_9356SEL	(1<<4)
 #define EPROM_CMD_RESERVED_MASK 			(1<<5)
 #define EPROM_CMD_OPERATING_MODE_SHIFT 	6
 #define EPROM_CMD_OPERATING_MODE_MASK 	((1<<7)|(1<<6))
@@ -1230,17 +1226,18 @@ Default: 00b.
 #define		EEPROM_CHANNEL_PLAN_GLOBAL_DOMAIN	0x9
 #define		EEPROM_CHANNEL_PLAN_WORLD_WIDE_13	0xA
 #define		EEPROM_CHANNEL_PLAN_BY_HW_MASK	0x80
+#define 	EEPROM_CID_DEFAULT			0x0
+#define 	EEPROM_CID_ALPHA			0x1
+#define 	EEPROM_CID_Senao			0x3
+#define		EEPROM_CID_CAMEO			0X8
+#define 	EEPROM_CID_SITECOM			0x9
+#define 	EEPROM_CID_COREGA			0xB
+#define 	EEPROM_CID_EDIMAX_BELKIN		0xC
+#define		EEPROM_CID_SERCOMM_BELKIN		0xE
+#define		EEPROM_CID_CAMEO1			0xF
+#define 	EEPROM_CID_WHQL 			0xFE
+#define		EEPROM_CID_NetCore			0x5
 
-#define 		EEPROM_CID_DEFAULT				0x0
-#define 		EEPROM_CID_ALPHA				0x1
-#define		EEPROM_CID_CAMEO					0X8
-#define 		EEPROM_CID_SITECOM				0x9
-
-//#define EEPROM_CID_RUNTOP						0x2
-//#define EEPROM_CID_Senao						0x3
-//#define EEPROM_CID_TOSHIBA						0x4
-//#define EEPROM_CID_NetCore						0x5
-#define 		EEPROM_CID_WHQL 				0xFE // added by chiyoko for dtm, 20090108
 
 //-----------------------------------------------------------------
 // 0x2c0 FW Command Control register definition, added by Roger, 2008.11.27.
@@ -1253,18 +1250,32 @@ Default: 00b.
 #define		FW_HIGH_PWR_ENABLE			0xfd000009
 #define		FW_TXPWR_TRACK_ENABLE		0xfd000017
 #define		FW_TXPWR_TRACK_DISABLE		0xfd000018
-#define		FW_RA_RESET					0xfd0000af
-#define		FW_RA_ACTIVE					0xfd0000a6
+#define		FW_TXPWR_TRACK_THERMAL		0xfd000019
+#define		FW_RA_INIT						0xfd000026
+#define		FW_RA_IOT_BG_COMB			0xfd000030
+#define		FW_RA_IOT_N_COMB				0xfd000031
 #define		FW_RA_REFRESH					0xfd0000a0
-#define		FW_RA_ENABLE_BG				0xfd0000ac
+#define		FW_RA_DISABLE					0xfd0000a4
+#define		FW_RA_ACTIVE					0xfd0000a6
+#define		FW_RA_DISABLE_RSSI_MASK		0xfd0000ac
+#define		FW_RA_ENABLE_RSSI_MASK		0xfd0000ad
+#define		FW_RA_RESET					0xfd0000af
+#define		FW_DM_DISABLE					0xfd00aa00
 #define		FW_IQK_ENABLE					0xf0000020
 #define		FW_IQK_SUCCESS				0x0000dddd
 #define		FW_IQK_FAIL					0x0000ffff
 #define		FW_OP_FAILURE					0xffffffff
-#define		FW_DM_DISABLE					0xfd00aa00
+#define		FW_TX_FEEDBACK_NONE				0xfb000000
+#define		FW_TX_FEEDBACK_DTM_ENABLE		(FW_TX_FEEDBACK_NONE | 0x1)
+#define		FW_TX_FEEDBACK_CCX_ENABLE		(FW_TX_FEEDBACK_NONE | 0x2)
 #define		FW_BB_RESET_ENABLE			0xff00000d
 #define		FW_BB_RESET_DISABLE			0xff00000e
-
+#define		FW_LPS_ENTER					0xfe000010
+#define		FW_LPS_LEAVE					0xfe000011
+#define		FW_INDIRECT_READ				0xf2000000
+#define		FW_INDIRECT_WRITE				0xf2000001
+#define		FW_TXANT_SWITCH_ENABLE		0xfd000023
+#define		FW_TXANT_SWITCH_DISABLE		0xfd000024
 //
 //--------------92SU require delete or move to other place later
 //
--- a/drivers/staging/rtl8192su/r8192S_phy.c
+++ b/drivers/staging/rtl8192su/r8192S_phy.c
@@ -3485,9 +3485,10 @@ void ChkFwCmdIoDone(struct net_device* d
 //
 void phy_SetFwCmdIOCallback(struct net_device* dev)
 {
-	u32 	 	input;
-	static u32 ScanRegister;
 	struct r8192_priv *priv = ieee80211_priv(dev);
+	PRT_HIGH_THROUGHPUT	pHTInfo = priv->ieee80211->pHTInfo;
+	rt_firmware		*pFirmware = priv->pFirmware;
+	u32	input, CurrentAID = 0;;
 	if(!priv->up)
 	{
 		RT_TRACE(COMP_CMD, "SetFwCmdIOTimerCallback(): driver is going to unload\n");
@@ -3496,61 +3497,22 @@ void phy_SetFwCmdIOCallback(struct net_d
 
 	RT_TRACE(COMP_CMD, "--->SetFwCmdIOTimerCallback(): Cmd(%#x), SetFwCmdInProgress(%d)\n", priv->CurrentFwCmdIO, priv->SetFwCmdInProgress);
 
-	switch(priv->CurrentFwCmdIO)
+	if(pFirmware->FirmwareVersion >= 0x34)
 	{
-		case FW_CMD_HIGH_PWR_ENABLE:
-			if((priv->ieee80211->pHTInfo->IOTAction & HT_IOT_ACT_DISABLE_HIGH_POWER)==0)
-				write_nic_dword(dev, WFM5, FW_HIGH_PWR_ENABLE);
-			break;
-
-		case FW_CMD_HIGH_PWR_DISABLE:
-			write_nic_dword(dev, WFM5, FW_HIGH_PWR_DISABLE);
-			break;
-
-		case FW_CMD_DIG_RESUME:
-			write_nic_dword(dev, WFM5, FW_DIG_RESUME);
+		switch(priv->CurrentFwCmdIO)
+		{
+			case FW_CMD_RA_REFRESH_N:
+				priv->CurrentFwCmdIO = FW_CMD_RA_REFRESH_N_COMB;
 			break;
-
-		case FW_CMD_DIG_HALT:
-			write_nic_dword(dev, WFM5, FW_DIG_HALT);
-			break;
-
-		//
-		// <Roger_Notes> The following FW CMD IO was combined into single operation
-		// (i.e., to prevent number of system workitem out of resource!!).
-		// 2008.12.04.
-		//
-		case FW_CMD_RESUME_DM_BY_SCAN:
-			RT_TRACE(COMP_CMD, "[FW CMD] Set HIGHPWR enable and DIG resume!!\n");
-			if((priv->ieee80211->pHTInfo->IOTAction & HT_IOT_ACT_DISABLE_HIGH_POWER)==0)
-			{
-				write_nic_dword(dev, WFM5, FW_HIGH_PWR_ENABLE); //break;
-				ChkFwCmdIoDone(dev);
-			}
-			write_nic_dword(dev, WFM5, FW_DIG_RESUME);
+			case FW_CMD_RA_REFRESH_BG:
+				priv->CurrentFwCmdIO = FW_CMD_RA_REFRESH_BG_COMB;
 			break;
-
-		case FW_CMD_PAUSE_DM_BY_SCAN:
-			RT_TRACE(COMP_CMD, "[FW CMD] Set HIGHPWR disable and DIG halt!!\n");
-			write_nic_dword(dev, WFM5, FW_HIGH_PWR_DISABLE); //break;
-			ChkFwCmdIoDone(dev);
-			write_nic_dword(dev, WFM5, FW_DIG_HALT);
-			break;
-
-		//
-		// <Roger_Notes> The following FW CMD IO should be checked
-		// (i.e., workitem schedule timing issue!!).
-		// 2008.12.04.
-		//
-		case FW_CMD_DIG_DISABLE:
-			RT_TRACE(COMP_CMD, "[FW CMD] Set DIG disable!!\n");
-			write_nic_dword(dev, WFM5, FW_DIG_DISABLE);
-			break;
-
-		case FW_CMD_DIG_ENABLE:
-			RT_TRACE(COMP_CMD, "[FW CMD] Set DIG enable!!\n");
-			write_nic_dword(dev, WFM5, FW_DIG_ENABLE);
+			default:
 			break;
+		}
+	}
+	switch(priv->CurrentFwCmdIO)
+	{
 
 		case FW_CMD_RA_RESET:
 			write_nic_dword(dev, WFM5, FW_RA_RESET);
@@ -3561,82 +3523,111 @@ void phy_SetFwCmdIOCallback(struct net_d
 			break;
 
 		case FW_CMD_RA_REFRESH_N:
-			RT_TRACE(COMP_CMD, "[FW CMD] Set RA refresh!! N\n");
-			if(priv->ieee80211->pHTInfo->IOTRaFunc & HT_IOT_RAFUNC_DISABLE_ALL)
+			RT_TRACE(COMP_CMD, "[FW CMD] Set RA n refresh!!\n");
+			if(pHTInfo->IOTRaFunc & HT_IOT_RAFUNC_DISABLE_ALL)
 				input = FW_RA_REFRESH;
 			else
-				input = FW_RA_REFRESH | (priv->ieee80211->pHTInfo->IOTRaFunc << 8);
+				input = FW_RA_REFRESH | (pHTInfo->IOTRaFunc << 8);
 			write_nic_dword(dev, WFM5, input);
+			ChkFwCmdIoDone(dev);
+			write_nic_dword(dev, WFM5, FW_RA_ENABLE_RSSI_MASK);
+			ChkFwCmdIoDone(dev);
 			break;
 		case FW_CMD_RA_REFRESH_BG:
-			RT_TRACE(COMP_CMD, "[FW CMD] Set RA refresh!! B/G\n");
+			RT_TRACE(COMP_CMD, "[FW CMD] Set RA BG refresh!!\n");
 			write_nic_dword(dev, WFM5, FW_RA_REFRESH);
 			ChkFwCmdIoDone(dev);
-			write_nic_dword(dev, WFM5, FW_RA_ENABLE_BG);
+			write_nic_dword(dev, WFM5, FW_RA_DISABLE_RSSI_MASK);
+			ChkFwCmdIoDone(dev);
+			break;
+
+		case FW_CMD_RA_REFRESH_N_COMB:
+			RT_TRACE(COMP_CMD, "[FW CMD] Set RA n Combo refresh!!\n");
+			if(pHTInfo->IOTRaFunc & HT_IOT_RAFUNC_DISABLE_ALL)
+				input = FW_RA_IOT_N_COMB;
+			else
+				input = FW_RA_IOT_N_COMB | (((pHTInfo->IOTRaFunc)&0x0f) << 8);
+			input = input |((pHTInfo->IOTPeer & 0xf) <<12);
+			RT_TRACE(COMP_CMD, "[FW CMD] Set RA/IOT Comb in n mode!! input(%#x)\n", input);
+			write_nic_dword(dev, WFM5, input);
+			ChkFwCmdIoDone(dev);
+			break;
+
+		case FW_CMD_RA_REFRESH_BG_COMB:
+			RT_TRACE(COMP_CMD, "[FW CMD] Set RA B/G Combo refresh!!\n");
+			if(pHTInfo->IOTRaFunc & HT_IOT_RAFUNC_DISABLE_ALL)
+				input = FW_RA_IOT_BG_COMB;
+			else
+				input = FW_RA_IOT_BG_COMB | (((pHTInfo->IOTRaFunc)&0x0f) << 8);
+			input = input |((pHTInfo->IOTPeer & 0xf) <<12);
+			RT_TRACE(COMP_CMD, "[FW CMD] Set RA/IOT Comb in B/G mode!! input(%#x)\n", input);
+			write_nic_dword(dev, WFM5, input);
+			ChkFwCmdIoDone(dev);
 			break;
 
 		case FW_CMD_IQK_ENABLE:
 			write_nic_dword(dev, WFM5, FW_IQK_ENABLE);
+			ChkFwCmdIoDone(dev);
 			break;
 
 		case FW_CMD_TXPWR_TRACK_ENABLE:
 			write_nic_dword(dev, WFM5, FW_TXPWR_TRACK_ENABLE);
+			ChkFwCmdIoDone(dev);
 			break;
 
 		case FW_CMD_TXPWR_TRACK_DISABLE:
 			write_nic_dword(dev, WFM5, FW_TXPWR_TRACK_DISABLE);
+			ChkFwCmdIoDone(dev);
 			break;
 
-		default:
-			RT_TRACE(COMP_CMD,"Unknown FW Cmd IO(%#x)\n", priv->CurrentFwCmdIO);
+		case FW_CMD_PAUSE_DM_BY_SCAN:
+			RT_TRACE(COMP_CMD,"[FW CMD] Pause DM by Scan!!\n");
+			rtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, bMaskByte0, 0x17);
+			rtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, bMaskByte0, 0x17);
+			rtl8192_setBBreg(dev, rCCK0_CCA, bMaskByte2, 0x40);
 			break;
-	}
-
-	ChkFwCmdIoDone(dev);
 
-	switch(priv->CurrentFwCmdIO)
-	{
+		case FW_CMD_RESUME_DM_BY_SCAN:
+			RT_TRACE(COMP_CMD, "[FW CMD] Resume DM by Scan!!\n");
+			rtl8192_setBBreg(dev, rCCK0_CCA, bMaskByte2, 0x83);
+			PHY_SetTxPowerLevel8192S(dev, priv->chan);
+			break;
 		case FW_CMD_HIGH_PWR_DISABLE:
-			//if(pMgntInfo->bTurboScan)
-			{
-				//Lower initial gain
-				rtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, bMaskByte0, 0x17);
-				rtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, bMaskByte0, 0x17);
-				// CCA threshold
-				rtl8192_setBBreg(dev, rCCK0_CCA, bMaskByte2, 0x40);
-				// Disable OFDM Part
-				rtl8192_setBBreg(dev, rOFDM0_TRMuxPar, bMaskByte2, 0x1);
-				ScanRegister = rtl8192_QueryBBReg(dev, rOFDM0_RxDetector1,bMaskDWord);
-				rtl8192_setBBreg(dev, rOFDM0_RxDetector1, 0xf, 0xf);
-				rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x0);
-			}
+			RT_TRACE(COMP_CMD, "[FW CMD] High Pwr Disable!!\n");
+			if(priv->DMFlag & HAL_DM_HIPWR_DISABLE)
+				break;
+			rtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, bMaskByte0, 0x17);
+			rtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, bMaskByte0, 0x17);
+			rtl8192_setBBreg(dev, rCCK0_CCA, bMaskByte2, 0x40);
 			break;
 
 		case FW_CMD_HIGH_PWR_ENABLE:
-			//if(pMgntInfo->bTurboScan)
-			{
-				rtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, bMaskByte0, 0x36);
-				rtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, bMaskByte0, 0x36);
-
-				// CCA threshold
-				rtl8192_setBBreg(dev, rCCK0_CCA, bMaskByte2, 0x83);
-				// Enable OFDM Part
-				rtl8192_setBBreg(dev, rOFDM0_TRMuxPar, bMaskByte2, 0x0);
-
-				//LZM ADD because sometimes there is no FW_CMD_HIGH_PWR_DISABLE, this value will be 0.
-				if(ScanRegister != 0){
-				rtl8192_setBBreg(dev, rOFDM0_RxDetector1, bMaskDWord, ScanRegister);
-				}
-
-				if(priv->rf_type == RF_1T2R || priv->rf_type == RF_2T2R)
-					rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x3);
-				else
-					rtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x1);
-			}
+			RT_TRACE(COMP_CMD, "[FW CMD] High Pwr Enable!!\n");
+			if(priv->DMFlag & HAL_DM_HIPWR_DISABLE)
+				break;
+			rtl8192_setBBreg(dev, rCCK0_CCA, bMaskByte2, 0x83);
+			break;
+
+		case FW_CMD_LPS_ENTER:
+			RT_TRACE(COMP_CMD, "[FW CMD] Enter LPS mode!!\n");
+			CurrentAID = priv->ieee80211->assoc_id;
+			write_nic_dword(dev, WFM5, (FW_LPS_ENTER| ((CurrentAID|0xc000)<<8))    );
+			ChkFwCmdIoDone(dev);
+			pHTInfo->IOTAction |=  HT_IOT_ACT_DISABLE_EDCA_TURBO;
+			break;
+
+		case FW_CMD_LPS_LEAVE:
+			RT_TRACE(COMP_CMD, "[FW CMD] Leave LPS mode!!\n");
+			write_nic_dword(dev, WFM5, FW_LPS_LEAVE );
+			ChkFwCmdIoDone(dev);
+			pHTInfo->IOTAction &=  (~HT_IOT_ACT_DISABLE_EDCA_TURBO);
+			break;
+
+		default:
 			break;
 	}
 
-	priv->SetFwCmdInProgress = false;// Clear FW CMD operation flag.
+	priv->SetFwCmdInProgress = false;
 	RT_TRACE(COMP_CMD, "<---SetFwCmdIOWorkItemCallback()\n");
 
 }

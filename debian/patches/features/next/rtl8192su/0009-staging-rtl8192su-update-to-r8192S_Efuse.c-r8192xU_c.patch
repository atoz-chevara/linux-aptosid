From a6f81aaf95166759246ede7b223e094568805370 Mon Sep 17 00:00:00 2001
From: Florian Schilhabel <florian.c.schilhabel@googlemail.com>
Date: Wed, 14 Jul 2010 14:43:26 +0200
Subject: [PATCH 09/41] staging: rtl8192su: update to r8192S_Efuse.c, r8192xU_cmdpkt.c

cosmetics, various updates to reflect realteks upstream changes.

Signed-off-by: Florian Schilhabel <florian.c.schilhabel@googlemail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rtl8192su/r8192S_Efuse.c  |  226 ++++++++++++++++++----------
 drivers/staging/rtl8192su/r8192S_Efuse.h  |   67 +++------
 drivers/staging/rtl8192su/r8192U.h        |    3 +
 drivers/staging/rtl8192su/r819xU_cmdpkt.c |   44 ++++---
 drivers/staging/rtl8192su/r819xU_cmdpkt.h |    1 +
 5 files changed, 199 insertions(+), 142 deletions(-)

--- a/drivers/staging/rtl8192su/r8192S_Efuse.c
+++ b/drivers/staging/rtl8192su/r8192S_Efuse.c
@@ -88,6 +88,7 @@ const u8 MAX_PGPKT_SIZE = 9; //header+ 2
 const u8 PGPKT_DATA_SIZE = 8; //BYTES sizeof(u8)*8
 const u32 EFUSE_MAX_SIZE = 512;
 
+const u8 EFUSE_OOB_PROTECT_BYTES = 14;
 
 const EFUSE_MAP RTL8712_SDIO_EFUSE_TABLE[]={
 				//offset	word_s	byte_start	byte_cnts
@@ -157,7 +158,7 @@ efuse_ParsingMap(char* szStr,u32* pu4bVa
 //
 static	u8
 efuse_PgPacketRead(	struct net_device* dev,u8	offset,u8 *data);
-static	u8
+static	u32
 efuse_PgPacketWrite(struct net_device* dev,u8 offset,u8 word_en,u8	*data);
 static	void
 efuse_WordEnableDataRead(	u8 word_en,u8 *sourdata,u8 *targetdata);
@@ -499,77 +500,146 @@ void
 ReadEFuse(struct net_device* dev, u16	 _offset, u16 _size_byte, u8 *pbuf)
 {
 
-	u8  	efuseTbl[128];
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u8  	efuseTbl[EFUSE_MAP_LEN];
 	u8  	rtemp8[1];
 	u16 	eFuse_Addr = 0;
 	u8  	offset, wren;
 	u16  	i, j;
-	u16 	eFuseWord[16][4];// = {0xFF};//FIXLZM
+	u16 	eFuseWord[EFUSE_MAX_SECTION][EFUSE_MAX_WORD_UNIT];
+	u16	efuse_utilized = 0;
+	u16	efuse_usage = 0;
 
-	for(i=0; i<16; i++)
-		for(j=0; j<4; j++)
-			eFuseWord[i][j]=0xFF;
-
-	// Do NOT excess total size of EFuse table. Added by Roger, 2008.11.10.
-	if((_offset + _size_byte)>128)
-	{// total E-Fuse table is 128bytes
+	if((_offset + _size_byte)>EFUSE_MAP_LEN)
+	{
 		printk("ReadEFuse(): Invalid offset with read bytes!!\n");
 		return;
 	}
 
-	// Refresh efuse init map as all oxFF.
-	for (i = 0; i < 128; i++)
-		efuseTbl[i] = 0xFF;
+	for(i = 0; i < EFUSE_MAX_SECTION; i++)
+		for(j = 0; j < EFUSE_MAX_WORD_UNIT; j++)
+			eFuseWord[i][j]=0xFFFF;
 
 #if (EFUSE_READ_SWITCH == 1)
 	ReadEFuseByte(dev, eFuse_Addr, rtemp8);
 #else
 	rtemp8[0] = EFUSE_Read1Byte(dev, eFuse_Addr);
 #endif
-	if(*rtemp8 != 0xFF)		eFuse_Addr++;
-	while((*rtemp8 != 0xFF) && (eFuse_Addr < 512)){
+	if(*rtemp8 != 0xFF){
+		efuse_utilized++;
+		RT_TRACE(COMP_EPROM, "Addr=%d\n", eFuse_Addr);
+		eFuse_Addr++;
+	}
+
+	while((*rtemp8 != 0xFF) && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN))
+	{
 		offset = ((*rtemp8 >> 4) & 0x0f);
-		if(offset <= 0x0F){
+		if(offset < EFUSE_MAX_SECTION)
+		{
 			wren = (*rtemp8 & 0x0f);
-			for(i=0; i<4; i++){
-				if(!(wren & 0x01)){
+			RT_TRACE(COMP_EPROM, "Offset-%d Worden=%x\n", offset, wren);
+
+			for(i = 0; i < EFUSE_MAX_WORD_UNIT; i++)
+			{
+				if(!(wren & 0x01))
+				{
+					RT_TRACE(COMP_EPROM, "Addr=%d\n", eFuse_Addr);
 #if (EFUSE_READ_SWITCH == 1)
 					ReadEFuseByte(dev, eFuse_Addr, rtemp8);	eFuse_Addr++;
 #else
 					rtemp8[0] = EFUSE_Read1Byte(dev, eFuse_Addr);	eFuse_Addr++;
 #endif
+					efuse_utilized++;
 					eFuseWord[offset][i] = (*rtemp8 & 0xff);
-					if(eFuse_Addr >= 512) break;
+					if(eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
+						break;
+
+					RT_TRACE(COMP_EPROM, "Addr=%d\n", eFuse_Addr);
 #if (EFUSE_READ_SWITCH == 1)
 					ReadEFuseByte(dev, eFuse_Addr, rtemp8);	eFuse_Addr++;
 #else
 					rtemp8[0] = EFUSE_Read1Byte(dev, eFuse_Addr);	eFuse_Addr++;
 #endif
+					efuse_utilized++;
 					eFuseWord[offset][i] |= (((u16)*rtemp8 << 8) & 0xff00);
-					if(eFuse_Addr >= 512) break;
+					if(eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
+						break;
 				}
 				wren >>= 1;
 			}
 		}
+
+		RT_TRACE(COMP_EPROM, "Addr=%d\n", eFuse_Addr);
 #if (EFUSE_READ_SWITCH == 1)
 		ReadEFuseByte(dev, eFuse_Addr, rtemp8);
 #else
 		rtemp8[0] = EFUSE_Read1Byte(dev, eFuse_Addr);	eFuse_Addr++;
 #endif
-		if(*rtemp8 != 0xFF && (eFuse_Addr < 512))	eFuse_Addr++;
+		if(*rtemp8 != 0xFF && (eFuse_Addr < 512))
+		{
+			efuse_utilized++;
+			eFuse_Addr++;
+		}
 	}
 
-	for(i=0; i<16; i++){
-		for(j=0; j<4; j++){
+	for(i=0; i<EFUSE_MAX_SECTION; i++)
+	{
+		for(j=0; j<EFUSE_MAX_WORD_UNIT; j++)
+		{
 			efuseTbl[(i*8)+(j*2)]=(eFuseWord[i][j] & 0xff);
 			efuseTbl[(i*8)+((j*2)+1)]=((eFuseWord[i][j] >> 8) & 0xff);
 		}
 	}
 	for(i=0; i<_size_byte; i++)
 		pbuf[i] = efuseTbl[_offset+i];
+
+	efuse_usage = (u8)((efuse_utilized*100)/EFUSE_REAL_CONTENT_LEN);
+	priv->EfuseUsedBytes = efuse_utilized;
+	priv->EfuseUsedPercentage = (u8)efuse_usage;
 }
 #endif
 
+extern	bool
+EFUSE_ShadowUpdateChk(struct net_device* dev)
+{
+	struct r8192_priv *priv = ieee80211_priv(dev);
+	u8	SectionIdx, i, Base;
+	u16	WordsNeed = 0, HdrNum = 0, TotalBytes = 0, EfuseUsed = 0;
+	bool	bWordChanged, bResult = true;
+
+	for (SectionIdx = 0; SectionIdx < 16; SectionIdx++)
+	{
+		Base = SectionIdx * 8;
+		bWordChanged = false;
+
+		for (i = 0; i < 8; i=i+2)
+		{
+			if((priv->EfuseMap[EFUSE_INIT_MAP][Base+i] !=
+				priv->EfuseMap[EFUSE_MODIFY_MAP][Base+i]) ||
+				(priv->EfuseMap[EFUSE_INIT_MAP][Base+i+1] !=
+				priv->EfuseMap[EFUSE_MODIFY_MAP][Base+i+1]))
+			{
+				WordsNeed++;
+				bWordChanged = true;
+			}
+		}
+
+		if( bWordChanged==true )
+			HdrNum++;
+	}
+
+	TotalBytes = HdrNum + WordsNeed*2;
+	EfuseUsed = priv->EfuseUsedBytes;
+
+	if( (TotalBytes + EfuseUsed) >= (EFUSE_MAX_SIZE-EFUSE_OOB_PROTECT_BYTES))
+		bResult = true;
+
+	RT_TRACE(COMP_EPROM, "EFUSE_ShadowUpdateChk(): TotalBytes(%x), HdrNum(%x), WordsNeed(%x), EfuseUsed(%d)\n",
+		TotalBytes, HdrNum, WordsNeed, EfuseUsed);
+
+	return bResult;
+}
+
 /*-----------------------------------------------------------------------------
  * Function:	EFUSE_ShadowRead
  *
@@ -645,14 +715,25 @@ EFUSE_ShadowWrite(	struct net_device*	de
  * 11/12/2008 	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-extern	void
+extern bool
 EFUSE_ShadowUpdate(struct net_device* dev)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u16			i, offset, base = 0;
 	u8			word_en = 0x0F;
-	bool first_pg = false;
-	// For Efuse write action, we must enable LDO2.5V and 40MHZ clk.
+	bool			first_pg = false;
+
+	RT_TRACE(COMP_EPROM, "--->EFUSE_ShadowUpdate()\n");
+
+	if(!EFUSE_ShadowUpdateChk(dev))
+	{
+		efuse_ReadAllMap(dev, &priv->EfuseMap[EFUSE_INIT_MAP][0]);
+		memcpy((void *)&priv->EfuseMap[EFUSE_MODIFY_MAP][0],
+			(void *)&priv->EfuseMap[EFUSE_INIT_MAP][0], HWSET_MAX_SIZE_92S);
+
+		RT_TRACE(COMP_EPROM, "<---EFUSE_ShadowUpdate(): Efuse out of capacity!!\n");
+		return false;
+	}
 	efuse_PowerSwitch(dev, TRUE);
 
 	//
@@ -670,13 +751,12 @@ EFUSE_ShadowUpdate(struct net_device* de
 		//
 		for (i = 0; i < 8; i++)
 		{
-			if (offset == 0 && priv->EfuseMap[EFUSE_INIT_MAP][base+i] == 0xFF)
-			{
-				first_pg = TRUE;
-			}
 			if (first_pg == TRUE)
 			{
 				word_en &= ~(1<<(i/2));
+				RT_TRACE(COMP_EPROM,"Section(%x) Addr[%x] %x update to %x, Word_En=%02x\n",
+				offset, base+i, priv->EfuseMap[EFUSE_INIT_MAP][base+i],
+				priv->EfuseMap[EFUSE_MODIFY_MAP][base+i],word_en);
 				priv->EfuseMap[EFUSE_INIT_MAP][base+i] =
 				priv->EfuseMap[EFUSE_MODIFY_MAP][base+i];
 			}else
@@ -685,8 +765,9 @@ EFUSE_ShadowUpdate(struct net_device* de
 				priv->EfuseMap[EFUSE_MODIFY_MAP][base+i])
 			{
 				word_en &= ~(EFUSE_BIT(i/2));
-				//RT_TRACE(COMP_EFUSE,  "Offset=%d Addr%x %x ==> %x Word_En=%02x\n",
-				//offset, base+i, priv->EfuseMap[0][base+i], priv->EfuseMap[1][base+i],word_en);
+				RT_TRACE(COMP_EPROM, "Section(%x) Addr[%x] %x update to %x, Word_En=%02x\n",
+				offset, base+i, priv->EfuseMap[0][base+i],
+				priv->EfuseMap[1][base+i],word_en);
 
 				// Update init table!!!
 				priv->EfuseMap[EFUSE_INIT_MAP][base+i] =
@@ -702,20 +783,26 @@ EFUSE_ShadowUpdate(struct net_device* de
 		{
 			u8	tmpdata[8];
 
-			memcpy(tmpdata, &(priv->EfuseMap[EFUSE_MODIFY_MAP][base]), 8);
-			efuse_PgPacketWrite(dev,(u8)offset,word_en,tmpdata);
+			memcpy((void *)tmpdata, (void *)&(priv->EfuseMap[EFUSE_MODIFY_MAP][base]), 8);
+			RT_TRACE(COMP_INIT, "U-EFUSE\n");
+
+			if(!efuse_PgPacketWrite(dev,(u8)offset,word_en,tmpdata))
+			{
+				RT_TRACE(COMP_EPROM,"EFUSE_ShadowUpdate(): PG section(%x) fail!!\n", offset);
+				break;
+			}
 		}
 
 	}
-	// We will force write 0x10EC into address 10&11 after all Efuse content.
-	//
-
-
 	// For warm reboot, we must resume Efuse clock to 500K.
+
 	efuse_PowerSwitch(dev, FALSE);
-	// 2008/12/01 MH We update shadow content again!!!!
-	EFUSE_ShadowMapUpdate(dev);
 
+	efuse_ReadAllMap(dev, &priv->EfuseMap[EFUSE_INIT_MAP][0]);
+	memcpy((void *)&priv->EfuseMap[EFUSE_MODIFY_MAP][0],
+		(void *)&priv->EfuseMap[EFUSE_INIT_MAP][0], HWSET_MAX_SIZE_92S);
+
+	return true;
 }
 
 /*-----------------------------------------------------------------------------
@@ -743,8 +830,8 @@ extern void EFUSE_ShadowMapUpdate(struct
 	}else{
 		efuse_ReadAllMap(dev, &priv->EfuseMap[EFUSE_INIT_MAP][0]);
 	}
-	memcpy(&priv->EfuseMap[EFUSE_MODIFY_MAP][0],
-		&priv->EfuseMap[EFUSE_INIT_MAP][0], HWSET_MAX_SIZE_92S);
+	memcpy((void *)&priv->EfuseMap[EFUSE_MODIFY_MAP][0],
+		(void *)&priv->EfuseMap[EFUSE_INIT_MAP][0], HWSET_MAX_SIZE_92S);
 
 }
 
@@ -1119,7 +1206,7 @@ efuse_PgPacketRead(	struct net_device*	d
  * 11/16/2008 	MHC		Reorganize code Arch and assign as local API.
  *
  *---------------------------------------------------------------------------*/
-static u8 efuse_PgPacketWrite(struct net_device* dev, u8 offset, u8 word_en,u8 *data)
+static u32 efuse_PgPacketWrite(struct net_device* dev, u8 offset, u8 word_en,u8 *data)
 {
 	u8 WriteState = PG_STATE_HEADER;
 
@@ -1227,14 +1314,12 @@ static u8 efuse_PgPacketWrite(struct net
 							badworden = efuse_WordEnableDataWrite(dev,efuse_addr+1, tmp_pkt.word_en ,target_pkt.data);
 
 							//************  so-2-2-A-1 *******************
-							//############################
 							if(0x0F != (badworden&0x0F))
 							{
 								u8 reorg_offset = offset;
 								u8 reorg_worden=badworden;
 								efuse_PgPacketWrite(dev,reorg_offset,reorg_worden,originaldata);
 							}
-							//############################
 
 							tmp_word_en = 0x0F;
 							if(  (target_pkt.word_en&BIT0)^(match_word_en&BIT0)  )
@@ -1257,13 +1342,13 @@ static u8 efuse_PgPacketWrite(struct net
 							//************  so-2-2-A-2 *******************
 							if((tmp_word_en&0x0F)!=0x0F){
 								//reorganize other pg packet
-								//efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr
-								efuse_addr = efuse_GetCurrentSize(dev);
-								//===========================
-								target_pkt.offset = offset;
+
+							efuse_addr = efuse_GetCurrentSize(dev);
+
+							target_pkt.offset = offset;
 								target_pkt.word_en= tmp_word_en;
-								//===========================
-							}else{
+
+						}else{
 								bContinual = FALSE;
 							}
 							#if (EFUSE_ERROE_HANDLE == 1)
@@ -1278,10 +1363,8 @@ static u8 efuse_PgPacketWrite(struct net
 						else{//************  so-2-2-B *******************
 							//reorganize other pg packet
 							efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr
-							//===========================
 							target_pkt.offset = offset;
 							target_pkt.word_en= target_pkt.word_en;
-							//===========================
 							#if (EFUSE_ERROE_HANDLE == 1)
 							WriteState=PG_STATE_HEADER;
 							#endif
@@ -1320,13 +1403,10 @@ static u8 efuse_PgPacketWrite(struct net
 
 					//************  s1-2-A :cover the exist data *******************
 					memset(originaldata,0xff,sizeof(u8)*8);
-					//PlatformFillMemory((PVOID)originaldata, sizeof(u8)*8, 0xff);
 
 					if(efuse_PgPacketRead( dev, tmp_pkt.offset,originaldata))
 					{	//check if data exist
-						//efuse_reg_ctrl(pAdapter,TRUE);//power on
 						badworden = efuse_WordEnableDataWrite(dev,efuse_addr+1,tmp_pkt.word_en,originaldata);
-						//############################
 						if(0x0F != (badworden&0x0F))
 						{
 							u8 reorg_offset = tmp_pkt.offset;
@@ -1334,7 +1414,6 @@ static u8 efuse_PgPacketWrite(struct net
 							efuse_PgPacketWrite(dev,reorg_offset,reorg_worden,originaldata);
 							efuse_addr = efuse_GetCurrentSize(dev);
 						}
-						//############################
 						else{
 							efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet
 						}
@@ -1374,11 +1453,9 @@ static u8 efuse_PgPacketWrite(struct net
 			{//reorganize other pg packet //************  s1-1-B *******************
 				efuse_addr = efuse_addr + (2*target_word_cnts) +1;//next pg packet addr
 
-				//===========================
 				target_pkt.offset = offset;
 				target_pkt.word_en= badworden;
 				target_word_cnts =  efuse_CalculateWordCnts(target_pkt.word_en);
-				//===========================
 				#if (EFUSE_ERROE_HANDLE == 1)
 				WriteState=PG_STATE_HEADER;
 				repeat_times++;
@@ -1392,6 +1469,10 @@ static u8 efuse_PgPacketWrite(struct net
 		}
 	}
 
+	if(efuse_addr  >= (EFUSE_MAX_SIZE-EFUSE_OOB_PROTECT_BYTES))
+	{
+		RT_TRACE(COMP_EPROM, "efuse_PgPacketWrite(): efuse_addr(%x) Out of size!!\n", efuse_addr);
+	}
 	return TRUE;
 }
 
@@ -1678,12 +1759,10 @@ EFUSE_ProgramMap(struct net_device* dev,
 				{
 					u32	j;
 
-					//GetHexValueFromString(szLine, &u4bRegValue, &u4bMove);
 					efuse_ParsingMap(szLine, &u4bRegValue, &u4bMove);
 
 					// Get next hex value as EEPROM value.
 					szLine += u4bMove;
-					//WriteEEprom(dev, (u16)(ithLine*8+i), (u16)u4bRegValue);
 					eeprom[index++] = (u8)(u4bRegValue&0xff);
 					eeprom[index++] = (u8)((u4bRegValue>>8)&0xff);
 
@@ -1713,7 +1792,7 @@ EFUSE_ProgramMap(struct net_device* dev,
 	}
 
 	return	rtStatus;
-}	/* EFUSE_ProgramMap */
+}
 
 #endif
 
@@ -1762,9 +1841,6 @@ efuse_ParsingMap(char* szStr,u32* pu4bVa
 	// Check input parameter.
 	if(szStr == NULL || pu4bVal == NULL || pu4bMove == NULL)
 	{
-		//RT_TRACE(COMP_EFUSE,
-		//"eeprom_ParsingMap(): Invalid IN args! szStr: %p, pu4bVal: %p, pu4bMove: %p\n",
-		//szStr, pu4bVal, pu4bMove);
 		return FALSE;
 	}
 
@@ -1798,17 +1874,12 @@ efuse_ParsingMap(char* szStr,u32* pu4bVa
 
 	return TRUE;
 
-}	/* efuse_ParsingMap */
+}
 #endif
 
-//
-// Useless Section Code Now!!!!!!
-//
-// Porting from 8712 SDIO
 int efuse_one_byte_rw(struct net_device* dev, u8 bRead, u16 addr, u8 *data)
 {
 	u32 bResult;
-	//u8 efuse_ctlreg,tmpidx = 0;
 	u8 tmpidx = 0;
 	u8 tmpv8=0;
 
@@ -1858,7 +1929,7 @@ int efuse_one_byte_rw(struct net_device*
 	}
 	return bResult;
 }
-//------------------------------------------------------------------------------
+
 void efuse_access(struct net_device* dev, u8 bRead,u16 start_addr, u8 cnts, u8 *data)
 {
 	u8	efuse_clk_ori,efuse_clk_new;//,tmp8;
@@ -1889,9 +1960,8 @@ void efuse_access(struct net_device* dev
 	//-----------------e-fuse one byte read / write ------------------------------
 	for(i=0;i<cnts;i++){
 		efuse_one_byte_rw(dev,bRead, start_addr+i , data+i);
-		////RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("==>efuse_access addr:0x%02x value:0x%02x\n",data+i,*(data+i)));
+
 	}
-	// -----------------e-fuse pwr & clk reg ctrl ---------------------------------
 	write_nic_byte(dev, EFUSE_TEST+3, read_nic_byte(dev, EFUSE_TEST+3)&0x7f);
 	write_nic_byte(dev, EFUSE_CLK_CTRL, read_nic_byte(dev, EFUSE_CLK_CTRL)&0xfd);
 
@@ -1899,8 +1969,6 @@ void efuse_access(struct net_device* dev
 	if(efuse_clk_new != efuse_clk_ori)	write_nic_byte(dev, 0x10250003, efuse_clk_ori);
 
 }
-//------------------------------------------------------------------------------
-//------------------------------------------------------------------------------
 
 #ifdef TO_DO_LIST
 static	void efuse_reg_ctrl(struct net_device* dev, u8 bPowerOn)
@@ -1933,9 +2001,7 @@ static	void efuse_reg_ctrl(struct net_de
 
 }
 #endif
-//------------------------------------------------------------------------------
 
-//------------------------------------------------------------------------------
 void efuse_read_data(struct net_device* dev,u8 efuse_read_item,u8 *data,u32 data_size)
 {
 	u8 offset, word_start,byte_start,byte_cnts;
@@ -1989,7 +2055,7 @@ void efuse_read_data(struct net_device*
 	}
 
 }
-//------------------------------------------------------------------------------
+
 //per interface doesn't alike
 void efuse_write_data(struct net_device* dev,u8 efuse_write_item,u8 *data,u32 data_size,u32 bWordUnit)
 {
@@ -2082,7 +2148,6 @@ void efuse_write_data(struct net_device*
 		}
 
 	}
-	//========================================================================
 	else if(pg_pkt_cnts>1){//situation B
 		if(word_start==0){
 			word_en = 0x00;
@@ -2103,7 +2168,6 @@ void efuse_write_data(struct net_device*
 
 		}
 	}
-	//========================================================================
 	else{//situation C
 		word_en = 0x0f;
 		for(tmpidx= 0; tmpidx<word_cnts ; tmpidx++)
--- a/drivers/staging/rtl8192su/r8192S_Efuse.h
+++ b/drivers/staging/rtl8192su/r8192S_Efuse.h
@@ -1,39 +1,39 @@
 /******************************************************************************
+ * Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  *
- *     (c) Copyright  2008, RealTEK Technologies Inc. All Rights Reserved.
- *
- * Module:	Efuse.h	( Header File)
- *
- * Note:
- *
- * Function:
- *
- * Export:
- *
- * Abbrev:
- *
- * History:
- * Data			Who		Remark
- *
- * 09/23/2008	MHC		Porting Efuse R/W API from WMAC.
- * 11/10/2008	MHC		Porting Efuse.h from 8712 SDIO.
- *						1. We muse redefine the header file to fit our coding
- *						   style.
- *						2. THe API we export to other module, we must redefine
- *						   for 8192S series.
+ * Based on the r8180 driver, which is:
+ * Copyright 2004-2005 Andrea Merello <andreamrl@tiscali.it>, et al.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
  *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
  *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
 ******************************************************************************/
-/* Check to see if the file has been included already.  */
 
 #ifndef __INC_EFUSE_H
 #define __INC_EFUSE_H
 
-// Roger porting for 8192SU
 #define		EFUSE_FOR_92SU		1
 
 /*--------------------------Define Parameters-------------------------------*/
 #define		EFUSE_MAC_LEN					0x200
+#define		EFUSE_REAL_CONTENT_LEN		512
+#define		EFUSE_MAP_LEN					128
+#define		EFUSE_MAX_SECTION			16
+#define		EFUSE_MAX_WORD_UNIT			4
 
 #define		EFUSE_INIT_MAP				0
 #define		EFUSE_MODIFY_MAP				1
@@ -41,7 +41,6 @@
 #define		EFUSE_CLK_CTRL			EFUSE_CTRL
 #define 	EFUSE_BIT(x)  (1 << (x))
 
-// From 8712!!!!!!!!
 #define		PG_STATE_HEADER 	0x01
 #define		PG_STATE_WORD_0		0x02
 #define		PG_STATE_WORD_1		0x04
@@ -52,22 +51,6 @@
 #define		PG_SWBYTE_H			0x01
 #define		PG_SWBYTE_L			0x02
 
-/*--------------------------Define Parameters-------------------------------*/
-
-
-/*------------------------------Define structure----------------------------*/
-
-/*------------------------------Define structure----------------------------*/
-
-
-/*------------------------Export global variable----------------------------*/
-/*------------------------Export global variable----------------------------*/
-
-/*------------------------Export Marco Definition---------------------------*/
-
-/*------------------------Export Marco Definition---------------------------*/
-
-
 /*--------------------------Exported Function prototype---------------------*/
 extern	void
 EFUSE_Initialize(struct net_device* dev);
@@ -81,13 +64,13 @@ extern 	void
 ReadEFuse(struct net_device* dev,u16 _offset,u16 _size_byte,u8* pbuf);
 extern	void
 ReadEFuseByte(struct net_device* dev,u16  _offset,u8  *pbuf);
-#endif	// #if (EFUSE_FOR_92SU == 1)
+#endif
 
 extern	void
 EFUSE_ShadowRead(struct net_device* dev,unsigned char Type,unsigned short Offset,u32 *Value);
 extern	void
 EFUSE_ShadowWrite(struct net_device* dev,unsigned char Type,unsigned short Offset,u32 Value);
-extern	void
+extern	bool
 EFUSE_ShadowUpdate(struct net_device* dev);
 extern	void
 EFUSE_ShadowMapUpdate(struct net_device* dev);
@@ -96,6 +79,4 @@ extern	bool
 EFUSE_ProgramMap(struct net_device* dev,char* pFileName, u8 TableType);		// 0=Shadow 1=Real Efuse
 /*--------------------------Exported Function prototype---------------------*/
 
-/* End of Efuse.h */
-
-#endif //__INC_EFUSE_H
+#endif
--- a/drivers/staging/rtl8192su/r8192U.h
+++ b/drivers/staging/rtl8192su/r8192U.h
@@ -1268,6 +1268,9 @@ typedef struct r8192_priv
 	bool		EepromOrEfuse;
 	bool		bBootFromEfuse;	// system boot form EFUSE
 	u8  		EfuseMap[2][HWSET_MAX_SIZE_92S];
+	u16		EfuseUsedBytes;
+	u8		EfuseUsedPercentage;
+
 
 	u8  		EEPROMUsbOption;
 	u8  		EEPROMUsbPhyParam[5];
--- a/drivers/staging/rtl8192su/r819xU_cmdpkt.c
+++ b/drivers/staging/rtl8192su/r819xU_cmdpkt.c
@@ -1,13 +1,22 @@
-/*
- * (c) Copyright 2008, RealTEK Technologies Inc. All Rights Reserved.
- *
- * Module: r819xusb_cmdpkt.c
- * (RTL8190 TX/RX command packet handler Source C File)
- *
- * Note: The module is responsible for handling TX and RX command packet.
- * 1.TX: Send set and query configuration command packet.
- * 2.RX: Receive tx feedback, beacon state, query configuration, command packet.
- */
+/******************************************************************************
+ * Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
+ * Linux device driver for RTL8192U
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+******************************************************************************/
 #include "r8192U.h"
 #include "r819xU_cmdpkt.h"
 
@@ -19,19 +28,13 @@ bool SendTxCommandPacket(struct net_devi
 	cb_desc		    *tcb_desc;
 	unsigned char	    *ptr_buf;
 
-	/* PlatformAcquireSpinLock(Adapter, RT_TX_SPINLOCK); */
-
 	/*
 	 * Get TCB and local buffer from common pool.
 	 * (It is shared by CmdQ, MgntQ, and USB coalesce DataQ)
 	 */
 	skb  = dev_alloc_skb(USB_HWDESC_HEADER_LEN + DataLen + 4);
-	if (skb == NULL) {
-		RT_TRACE(COMP_ERR, "(%s): unable to alloc skb buffer\n",
-								__func__);
-		rtStatus = false;
-		return rtStatus;
-	}
+	if (!skb)
+		return false;
 	memcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));
 	tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);
 	tcb_desc->queue_index = TXCMD_QUEUE;
@@ -51,7 +54,6 @@ bool SendTxCommandPacket(struct net_devi
 			priv->ieee80211->softmac_hard_start_xmit(skb, dev);
 		}
 
-	//PlatformReleaseSpinLock(Adapter, RT_TX_SPINLOCK);
 	return rtStatus;
 }
 
@@ -224,7 +226,6 @@ static void cmpk_handle_interrupt_status
 	if (priv->ieee80211->iw_mode == IW_MODE_ADHOC) {
 		//2 maybe need endian transform?
 		rx_intr_status.interrupt_status = *((u32 *)(pmsg + 4));
-		//rx_intr_status.InterruptStatus = N2H4BYTE(*((UINT32 *)(pMsg + 4)));
 
 		DMESG("interrupt status = 0x%x\n", rx_intr_status.interrupt_status);
 
@@ -491,6 +492,13 @@ cmpk_message_handle_rx(
 			cmpk_handle_tx_rate_history(dev, pcmd_buff);
 			cmd_length = CMPK_TX_RAHIS_SIZE;
 			break;
+		case RX_TX_TSSI_MEAN_BACK:
+			{
+				u32	*pMsg;
+				pMsg = (u32 *)pcmd_buff;
+			}
+			cmd_length = 32;
+			break;
 		default:
 			 RT_TRACE(COMP_ERR, "(%s): unknown CMD Element\n",
 								__func__);
--- a/drivers/staging/rtl8192su/r819xU_cmdpkt.h
+++ b/drivers/staging/rtl8192su/r819xU_cmdpkt.h
@@ -173,6 +173,7 @@ typedef enum tag_command_packet_director
     RX_DBGINFO_FEEDBACK = 5,
     RX_TX_PER_PKT_FEEDBACK = 6,
     RX_TX_RATE_HISTORY = 7,
+    RX_TX_TSSI_MEAN_BACK = 8,
     RX_CMD_ELE_MAX
 } cmpk_element_e;
 

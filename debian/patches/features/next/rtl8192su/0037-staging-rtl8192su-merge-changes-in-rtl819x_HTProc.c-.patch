From 53faa56b78f1929d3e9d339b8c21541bd355b4eb Mon Sep 17 00:00:00 2001
From: Florian Schilhabel <florian.c.schilhabel@googlemail.com>
Date: Thu, 15 Jul 2010 19:04:46 +0200
Subject: [PATCH 37/41] staging: rtl8192su: merge changes in rtl819x_HTProc.c; still incomplete

Signed-off-by: Florian Schilhabel <florian.c.schilhabel@googlemail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 .../staging/rtl8192su/ieee80211/rtl819x_HTProc.c   |  109 +++++--------------
 1 files changed, 29 insertions(+), 80 deletions(-)

--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c
@@ -1,4 +1,3 @@
-
 /******************************************************************************
  * Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
  *
@@ -25,25 +24,25 @@ u8 MCS_FILTER_1SS[16] = {0xff, 0x00, 0x0
 
 u16 MCS_DATA_RATE[2][2][77] =
 	{	{	{13, 26, 39, 52, 78, 104, 117, 130, 26, 52, 78 ,104, 156, 208, 234, 260,
-			39, 78, 117, 234, 312, 351, 390, 52, 104, 156, 208, 312, 416, 468, 520,
+			39, 78, 117, 234, 312, 351, 390, 52, 104, 156, 208, 312, 416, 468, 520, 
 			0, 78, 104, 130, 117, 156, 195, 104, 130, 130, 156, 182, 182, 208, 156, 195,
-			195, 234, 273, 273, 312, 130, 156, 181, 156, 181, 208, 234, 208, 234, 260, 260,
-			286, 195, 234, 273, 234, 273, 312, 351, 312, 351, 390, 390, 429},			// Long GI, 20MHz
-			{14, 29, 43, 58, 87, 116, 130, 144, 29, 58, 87, 116, 173, 231, 260, 289,
-			43, 87, 130, 173, 260, 347, 390, 433, 58, 116, 173, 231, 347, 462, 520, 578,
-			0, 87, 116, 144, 130, 173, 217, 116, 144, 144, 173, 202, 202, 231, 173, 217,
-			217, 260, 303, 303, 347, 144, 173, 202, 173, 202, 231, 260, 231, 260, 289, 289,
-			318, 217, 260, 303, 260, 303, 347, 390, 347, 390, 433, 433, 477}	},		// Short GI, 20MHz
-		{	{27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540,
-			81, 162, 243, 324, 486, 648, 729, 810, 108, 216, 324, 432, 648, 864, 972, 1080,
-			12, 162, 216, 270, 243, 324, 405, 216, 270, 270, 324, 378, 378, 432, 324, 405,
-			405, 486, 567, 567, 648, 270, 324, 378, 324, 378, 432, 486, 432, 486, 540, 540,
-			594, 405, 486, 567, 486, 567, 648, 729, 648, 729, 810, 810, 891}, 	// Long GI, 40MHz
-			{30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600,
-			90, 180, 270, 360, 540, 720, 810, 900, 120, 240, 360, 480, 720, 960, 1080, 1200,
-			13, 180, 240, 300, 270, 360, 450, 240, 300, 300, 360, 420, 420, 480, 360, 450,
-			450, 540, 630, 630, 720, 300, 360, 420, 360, 420, 480, 540, 480, 540, 600, 600,
-			660, 450, 540, 630, 540, 630, 720, 810, 720, 810, 900, 900, 990}	}	// Short GI, 40MHz
+			195, 234, 273, 273, 312, 130, 156, 181, 156, 181, 208, 234, 208, 234, 260, 260, 
+			286, 195, 234, 273, 234, 273, 312, 351, 312, 351, 390, 390, 429},			
+			{14, 29, 43, 58, 87, 116, 130, 144, 29, 58, 87, 116, 173, 231, 260, 289, 
+			43, 87, 130, 173, 260, 347, 390, 433, 58, 116, 173, 231, 347, 462, 520, 578, 
+			0, 87, 116, 144, 130, 173, 217, 116, 144, 144, 173, 202, 202, 231, 173, 217, 
+			217, 260, 303, 303, 347, 144, 173, 202, 173, 202, 231, 260, 231, 260, 289, 289, 
+			318, 217, 260, 303, 260, 303, 347, 390, 347, 390, 433, 433, 477}	},		
+		{	{27, 54, 81, 108, 162, 216, 243, 270, 54, 108, 162, 216, 324, 432, 486, 540, 
+			81, 162, 243, 324, 486, 648, 729, 810, 108, 216, 324, 432, 648, 864, 972, 1080, 
+			12, 162, 216, 270, 243, 324, 405, 216, 270, 270, 324, 378, 378, 432, 324, 405, 
+			405, 486, 567, 567, 648, 270, 324, 378, 324, 378, 432, 486, 432, 486, 540, 540, 
+			594, 405, 486, 567, 486, 567, 648, 729, 648, 729, 810, 810, 891}, 	
+			{30, 60, 90, 120, 180, 240, 270, 300, 60, 120, 180, 240, 360, 480, 540, 600, 
+			90, 180, 270, 360, 540, 720, 810, 900, 120, 240, 360, 480, 720, 960, 1080, 1200, 
+			13, 180, 240, 300, 270, 360, 450, 240, 300, 300, 360, 420, 420, 480, 360, 450, 
+			450, 540, 630, 630, 720, 300, 360, 420, 360, 420, 480, 540, 480, 540, 600, 600, 
+			660, 450, 540, 630, 540, 630, 720, 810, 720, 810, 900, 900, 990}	}	
 	};
 
 static u8 UNKNOWN_BORADCOM[3] = {0x00, 0x14, 0xbf};
@@ -70,10 +69,7 @@ static u8 LINKSYS_MARVELL_4400N[3] = {0x
 void HTUpdateDefaultSetting(struct ieee80211_device* ieee)
 {
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
-	//const typeof( ((struct ieee80211_device *)0)->pHTInfo ) *__mptr = &pHTInfo;
 
-	//printk("pHTinfo:%p, &pHTinfo:%p, mptr:%p,  offsetof:%x\n", pHTInfo, &pHTInfo, __mptr, offsetof(struct ieee80211_device, pHTInfo));
-	//printk("===>ieee:%p,\n", ieee);
 	// ShortGI support
 	pHTInfo->bRegShortGI20MHz= 1;
 	pHTInfo->bRegShortGI40MHz= 1;
@@ -306,7 +302,6 @@ u16 HTMcsToDataRate( struct ieee80211_de
  * *****************************************************************************************************************/
 u16  TxCountToDataRate( struct ieee80211_device* ieee, u8 nDataRate)
 {
-	//PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	u16		CCKOFDMRate[12] = {0x02 , 0x04 , 0x0b , 0x16 , 0x0c , 0x12 , 0x18 , 0x24 , 0x30 , 0x48 , 0x60 , 0x6c};
 	u8	is40MHz = 0;
 	u8	isShortGI = 0;
@@ -322,28 +317,24 @@ u16  TxCountToDataRate( struct ieee80211
 			is40MHz = 0;
 			isShortGI = 0;
 
-		      // nDataRate = nDataRate - 12;
 		}
 		else if(nDataRate >=0x20  && nDataRate <= 0x2f ) //(27, 44)
 		{
 			is40MHz = 1;
 			isShortGI = 0;
 
-			//nDataRate = nDataRate - 28;
 		}
 		else if(nDataRate >= 0x30  && nDataRate <= 0x3f )  //(43, 60)
 		{
 			is40MHz = 0;
 			isShortGI = 1;
 
-			//nDataRate = nDataRate - 44;
 		}
 		else if(nDataRate >= 0x40  && nDataRate <= 0x4f ) //(59, 76)
 		{
 			is40MHz = 1;
 			isShortGI = 1;
 
-			//nDataRate = nDataRate - 60;
 		}
 		return MCS_DATA_RATE[is40MHz][isShortGI][nDataRate&0xf];
 	}
@@ -393,6 +384,9 @@ void HTIOTPeerDetermine(struct ieee80211
 		if(net->bssht.RT2RT_HT_Mode & RT_HT_CAP_USE_92SE){
 			pHTInfo->IOTPeer = HT_IOT_PEER_REALTEK_92SE;
 		}
+		if(net->bssht.RT2RT_HT_Mode & RT_HT_CAP_USE_SOFTAP){
+			pHTInfo->IOTPeer = HT_IOT_PEER_92U_SOFTAP;
+		}
 	}
 	else if(net->broadcom_cap_exist)
 		pHTInfo->IOTPeer = HT_IOT_PEER_BROADCOM;
@@ -452,25 +446,6 @@ u8 HTIOTActIsDisableMCS14(struct ieee802
 bool HTIOTActIsDisableMCS15(struct ieee80211_device* ieee)
 {
 	bool retValue = false;
-
-#ifdef TODO
-	// Apply for 819u only
-#if (HAL_CODE_BASE==RTL8192)
-
-#if (DEV_BUS_TYPE == USB_INTERFACE)
-	// Alway disable MCS15 by Jerry Chang's request.by Emily, 2008.04.15
-	retValue = true;
-#elif (DEV_BUS_TYPE == PCI_INTERFACE)
-	// Enable MCS15 if the peer is Cisco AP. by Emily, 2008.05.12
-//	if(pBssDesc->bCiscoCapExist)
-//		retValue = false;
-//	else
-		retValue = false;
-#endif
-#endif
-#endif
-	// Jerry Chang suggest that 8190 1x2 does not need to disable MCS15
-
 	return retValue;
 }
 
@@ -637,17 +612,11 @@ HTIOCActRejcectADDBARequest(struct ieee8
   HTIOTActIsEDCABiasRx(struct ieee80211_device* ieee,struct ieee80211_network *network)
 {
 	u8	retValue = 0;
-	//if(IS_HARDWARE_TYPE_8192SU(Adapter))
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 	{
-//#if UNDER_VISTA
-//		if(pBssDesc->Vender==HT_IOT_PEER_ATHEROS ||
-//			pBssDesc->Vender==HT_IOT_PEER_RALINK)
-//#else
 		if(pHTInfo->IOTPeer==HT_IOT_PEER_ATHEROS ||
 		   pHTInfo->IOTPeer==HT_IOT_PEER_BROADCOM ||
 		   pHTInfo->IOTPeer==HT_IOT_PEER_RALINK)
-//#endif
 			return 1;
 
 	}
@@ -662,7 +631,6 @@ HTIOTActDisableShortGI(struct ieee80211_
 
 	if(pHTInfo->IOTPeer==HT_IOT_PEER_RALINK)
 	{
-		if(network->bssht.bdHT1R)
 			retValue = 1;
 	}
 
@@ -675,9 +643,10 @@ HTIOTActDisableHighPower(struct ieee8021
 	u8	retValue = 0;
 	PRT_HIGH_THROUGHPUT	pHTInfo = ieee->pHTInfo;
 
-	if(pHTInfo->IOTPeer==HT_IOT_PEER_RALINK)
+	if(pHTInfo->IOTPeer==HT_IOT_PEER_RALINK ||
+		pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK ||
+		pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK_92SE)
 	{
-		if(network->bssht.bdHT1R)
 			retValue = 1;
 	}
 
@@ -731,8 +700,7 @@ HTIOTActIsTxNoAggregation(struct ieee802
 		(KEY_TYPE_WEP40 == ieee->group_key_type) ||
 		(KEY_TYPE_TKIP == ieee->pairwise_key_type) )
 	{
-		if(pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK ||
-		    pHTInfo->IOTPeer==HT_IOT_PEER_UNKNOWN)
+		if(pHTInfo->IOTPeer==HT_IOT_PEER_REALTEK)
 			retValue = 1;
 	}
 
@@ -797,7 +765,6 @@ void HTConstructCapabilityElement(struct
 {
 	PRT_HIGH_THROUGHPUT	pHT = ieee->pHTInfo;
 	PHT_CAPABILITY_ELE 	pCapELE = NULL;
-	//u8 bIsDeclareMCS13;
 
 	if ((posHTCap == NULL) || (pHT == NULL))
 	{
@@ -827,13 +794,11 @@ void HTConstructCapabilityElement(struct
 		pCapELE->ChlWidth = (pHT->bRegBW40MHz?1:0);
 	}
 
-//	pCapELE->ChlWidth 		= (pHT->bRegBW40MHz?1:0);
 	pCapELE->MimoPwrSave 		= pHT->SelfMimoPs;
 	pCapELE->GreenField		= 0; // This feature is not supported now!!
 	pCapELE->ShortGI20Mhz		= 1; // We can receive Short GI!!
 	pCapELE->ShortGI40Mhz		= 1; // We can receive Short GI!!
-	//DbgPrint("TX HT cap/info ele BW=%d SG20=%d SG40=%d\n\r",
-		//pCapELE->ChlWidth, pCapELE->ShortGI20Mhz, pCapELE->ShortGI40Mhz);
+
 	pCapELE->TxSTBC 		= 1;
 	pCapELE->RxSTBC 		= 0;
 	pCapELE->DelayBA		= 0;	// Do not support now!!
@@ -893,12 +858,6 @@ void HTConstructCapabilityElement(struct
 	else
 		*len = 26 + 2;
 
-
-
-//	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA | IEEE80211_DL_HT, posHTCap, *len -2);
-
-	//Print each field in detail. Driver should not print out this message by default
-//	HTDebugHTCapability(posHTCap, (u8*)"HTConstructCapability()");
 	return;
 
 }
@@ -952,8 +911,6 @@ void HTConstructInfoElement(struct ieee8
 		//STA should not generate High Throughput Information Element
 		*len = 0;
 	}
-	//IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA | IEEE80211_DL_HT, posHTInfo, *len - 2);
-	//HTDebugHTInfo(posHTInfo, "HTConstructInforElement");
 	return;
 }
 
@@ -1019,7 +976,6 @@ void HTConstructRT2RTAggElement(struct i
 	*/
 
 #else
-	// Do Nothing
 #endif
 
 	posRT2RTAgg->Length = 6;
@@ -1202,12 +1158,7 @@ void HTOnAssocRsp(struct ieee80211_devic
 		return;
 	}
 	IEEE80211_DEBUG(IEEE80211_DL_HT, "===> HTOnAssocRsp_wq(): HT_ENABLE\n");
-//	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, pHTInfo->PeerHTCapBuf, sizeof(HT_CAPABILITY_ELE));
-//	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, pHTInfo->PeerHTInfoBuf, sizeof(HT_INFORMATION_ELE));
 
-//	HTDebugHTCapability(pHTInfo->PeerHTCapBuf,"HTOnAssocRsp_wq");
-//	HTDebugHTInfo(pHTInfo->PeerHTInfoBuf,"HTOnAssocRsp_wq");
-	//
 	if(!memcmp(pHTInfo->PeerHTCapBuf,EWC11NHTCap, sizeof(EWC11NHTCap)))
 		pPeerHTCap = (PHT_CAPABILITY_ELE)(&pHTInfo->PeerHTCapBuf[4]);
 	else
@@ -1223,12 +1174,10 @@ void HTOnAssocRsp(struct ieee80211_devic
 	// Configurations:
 	////////////////////////////////////////////////////////
 	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA|IEEE80211_DL_HT, pPeerHTCap, sizeof(HT_CAPABILITY_ELE));
-//	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA|IEEE80211_DL_HT, pPeerHTInfo, sizeof(HT_INFORMATION_ELE));
-	// Config Supported Channel Width setting
-	//
+
 	HTSetConnectBwMode(ieee, (HT_CHANNEL_WIDTH)(pPeerHTCap->ChlWidth), (HT_EXTCHNL_OFFSET)(pPeerHTInfo->ExtChlOffset));
 
-//	if(pHTInfo->bCurBW40MHz == true)
+	if(pHTInfo->bCurBW40MHz == true)
 		pHTInfo->bCurTxBW40MHz = ((pPeerHTInfo->RecommemdedTxWidth == 1)?true:false);
 
 	//
@@ -1309,7 +1258,7 @@ void HTOnAssocRsp(struct ieee80211_devic
 
 	// <2> Set AMPDU Minimum MPDU Start Spacing
 	// 802.11n 3.0 section 9.7d.3
-#if 1
+#if 0
 	if(pHTInfo->MPDU_Density > pPeerHTCap->MPDUDensity)
 		pHTInfo->CurrentMPDUDensity = pHTInfo->MPDU_Density;
 	else

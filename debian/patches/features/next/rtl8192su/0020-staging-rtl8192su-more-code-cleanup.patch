From 47790cb22612290ee6c1c4d9f3e65fa6d2e01845 Mon Sep 17 00:00:00 2001
From: Florian Schilhabel <florian.c.schilhabel@googlemail.com>
Date: Wed, 14 Jul 2010 14:46:35 +0200
Subject: [PATCH 20/40] staging: rtl8192su: more code cleanup

Signed-off-by: Florian Schilhabel <florian.c.schilhabel@googlemail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/rtl8192su/ieee80211/rtl819x_Qos.h  |   88 +++++--------------
 drivers/staging/rtl8192su/ieee80211/rtl819x_TS.h   |   23 ++++-
 .../staging/rtl8192su/ieee80211/rtl819x_TSProc.c   |   41 +++++----
 3 files changed, 64 insertions(+), 88 deletions(-)

--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_Qos.h
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_Qos.h
@@ -1,3 +1,21 @@
+/******************************************************************************
+ * Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+******************************************************************************/
 #ifndef __INC_QOS_TYPE_H
 #define __INC_QOS_TYPE_H
 
@@ -36,18 +54,6 @@
 
 #define	MAX_WMMELE_LENGTH	64
 
-//
-// QoS mode.
-// enum 0, 1, 2, 4: since we can use the OR(|) operation.
-//
-// QOS_MODE is redefined for enum can't be ++, | under C++ compiler, 2006.05.17, by rcnjko.
-//typedef	enum _QOS_MODE{
-//	QOS_DISABLE		= 0,
-//	QOS_WMM			= 1,
-//	QOS_EDCA			= 2,
-//	QOS_HCCA			= 4,
-//}QOS_MODE,*PQOS_MODE;
-//
 typedef u32 QOS_MODE, *PQOS_MODE;
 #define QOS_DISABLE		0
 #define QOS_WMM			1
@@ -219,19 +225,6 @@ typedef	union _QOS_INFO_FIELD{
 
 }QOS_INFO_FIELD, *PQOS_INFO_FIELD;
 
-//
-// ACI to AC coding.
-// Ref: WMM spec 2.2.2: WME Parameter Element, p.13.
-//
-// AC_CODING is redefined for enum can't be ++, | under C++ compiler, 2006.05.17, by rcnjko.
-//typedef	enum _AC_CODING{
-//	AC0_BE	= 0,		// ACI: 0x00	// Best Effort
-//	AC1_BK	= 1,		// ACI: 0x01	// Background
-//	AC2_VI	= 2,		// ACI: 0x10	// Video
-//	AC3_VO	= 3,		// ACI: 0x11	// Voice
-//	AC_MAX = 4,		// Max: define total number; Should not to be used as a real enum.
-//}AC_CODING,*PAC_CODING;
-//
 typedef u32 AC_CODING;
 #define AC0_BE	0		// ACI: 0x00	// Best Effort
 #define AC1_BK	1		// ACI: 0x01	// Background
@@ -252,7 +245,7 @@ typedef	union _ACI_AIFSN{
 		u8	ACM:1;
 		u8	ACI:2;
 		u8	Reserved:1;
-	}f;	// Field
+	}f;
 }ACI_AIFSN, *PACI_AIFSN;
 
 //
@@ -265,7 +258,7 @@ typedef	union _ECW{
 	{
 		u8	ECWmin:4;
 		u8	ECWmax:4;
-	}f;	// Field
+	}f;
 }ECW, *PECW;
 
 //
@@ -281,7 +274,7 @@ typedef	union _AC_PARAM{
 		ACI_AIFSN	AciAifsn;
 		ECW		Ecw;
 		u16		TXOPLimit;
-	}f;	// Field
+	}f;
 }AC_PARAM, *PAC_PARAM;
 
 
@@ -354,7 +347,7 @@ typedef union _TSPEC_BODY{
 		u32	MinPhyRate;
 		u16	SurplusBandwidthAllowance;
 		u16	MediumTime;
-	} f;	// Field
+	} f;
 }TSPEC_BODY, *PTSPEC_BODY;
 
 
@@ -384,7 +377,6 @@ typedef	enum _ACM_METHOD{
 
 
 typedef struct _ACM{
-//	u8		RegEnableACM;
 	u64		UsedTime;
 	u64		MediumTime;
 	u8		HwAcmCtl;	// TRUE: UsedTime exceed => Do NOT USE this AC. It wll be written to ACM_CONTROL(0xBF BIT 0/1/2 in 8185B).
@@ -404,10 +396,6 @@ typedef	u8		AC_UAPSD, *PAC_UAPSD;
 #define	GET_BE_UAPSD(_apsd) ((_apsd) & BIT3)
 #define	SET_BE_UAPSD(_apsd) ((_apsd) |= BIT3)
 
-
-//typedef struct _TCLASS{
-// TODO
-//} TCLASS, *PTCLASS;
 typedef union _QOS_TCLAS{
 
 	struct _TYPE_GENERAL{
@@ -459,32 +447,12 @@ typedef union _QOS_TCLAS{
 	} TYPE2_8021Q;
 } QOS_TCLAS, *PQOS_TCLAS;
 
-//typedef struct _WMM_TSTREAM{
-//
-//- TSPEC
-//- AC (which to mapping)
-//} WMM_TSTREAM, *PWMM_TSTREAM;
 typedef struct _QOS_TSTREAM{
 	u8			AC;
 	WMM_TSPEC		TSpec;
 	QOS_TCLAS		TClass;
 } QOS_TSTREAM, *PQOS_TSTREAM;
 
-//typedef struct _U_APSD{
-//- TriggerEnable [4]
-//- MaxSPLength
-//- HighestAcBuffered
-//} U_APSD, *PU_APSD;
-
-//joseph TODO:
-//	UAPSD function should be implemented by 2 data structure
-//	"Qos control field" and "Qos info field"
-//typedef struct _QOS_UAPSD{
-//	u8			bTriggerEnable[4];
-//	u8 			MaxSPLength;
-//	u8			HighestBufAC;
-//} QOS_UAPSD, *PQOS_APSD;
-
 //----------------------------------------------------------------------------
 //      802.11 Management frame Status Code field
 //----------------------------------------------------------------------------
@@ -498,7 +466,6 @@ typedef struct _OCTET_STRING{
 // Ref: DOT11_QOS in 8185 code. [def. in QoS_mp.h]
 //
 typedef struct _STA_QOS{
-	//DECLARE_RT_OBJECT(STA_QOS);
 	u8				WMMIEBuf[MAX_WMMELE_LENGTH];
 	u8*				WMMIE;
 
@@ -565,18 +532,9 @@ typedef struct _BSS_QOS{
 	AC_PARAM		AcParameter[4];
 }BSS_QOS, *PBSS_QOS;
 
-
-//
-// Ref: sQoSCtlLng and QoSCtl definition in 8185 QoS code.
-//#define QoSCtl   ((	(Adapter->bRegQoS) && (Adapter->dot11QoS.QoSMode &(QOS_EDCA|QOS_HCCA))	  )  ?sQoSCtlLng:0)
-//
 #define sQoSCtlLng			2
 #define	QOS_CTRL_LEN(_QosMode)		((_QosMode > QOS_DISABLE)? sQoSCtlLng : 0)
 
-
-//Added by joseph
-//UP Mapping to AC, using in MgntQuery_SequenceNumber() and maybe for DSCP
-//#define UP2AC(up)			((up<3)?((up==0)?1:0):(up>>1))
 #define IsACValid(ac)			((ac<=7 )?true:false )
 
-#endif // #ifndef __INC_QOS_TYPE_H
+#endif
--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_TS.h
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_TS.h
@@ -1,3 +1,21 @@
+/******************************************************************************
+ * Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+******************************************************************************/
 #ifndef _TSTYPE_H_
 #define _TSTYPE_H_
 #include "rtl819x_Qos.h"
@@ -30,10 +48,10 @@ typedef struct _TX_TS_RECORD{
 	u16				TxCurSeq;
 	BA_RECORD			TxPendingBARecord;  	// For BA Originator
 	BA_RECORD			TxAdmittedBARecord;	// For BA Originator
-//	QOS_DL_RECORD		DLRecord;
 	u8				bAddBaReqInProgress;
 	u8				bAddBaReqDelayed;
 	u8				bUsingBa;
+	u8 				bDisable_AddBa;
 	struct timer_list		TsAddBaTimer;
 	u8				num;
 } TX_TS_RECORD, *PTX_TS_RECORD;
@@ -48,9 +66,6 @@ typedef struct _RX_TS_RECORD {
 	u16				RxLastSeqNum;
 	u8				RxLastFragNum;
 	u8				num;
-//	QOS_DL_RECORD		DLRecord;
 } RX_TS_RECORD, *PRX_TS_RECORD;
 
-
 #endif
-
--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_TSProc.c
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_TSProc.c
@@ -1,3 +1,21 @@
+/******************************************************************************
+ * Copyright(c) 2008 - 2010 Realtek Corporation. All rights reserved.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+******************************************************************************/
 #include "ieee80211.h"
 #include <linux/etherdevice.h>
 #include <linux/slab.h>
@@ -29,7 +47,6 @@ void RxPktPendingTimeout(unsigned long d
 
 	PRX_REORDER_ENTRY 	pReorderEntry = NULL;
 
-	//u32 flags = 0;
 	unsigned long flags = 0;
 	struct ieee80211_rxb *stats_IndicateArray[REORDER_WIN_SIZE];
 	u8 index = 0;
@@ -37,7 +54,6 @@ void RxPktPendingTimeout(unsigned long d
 
 
 	spin_lock_irqsave(&(ieee->reorder_spinlock), flags);
-	//PlatformAcquireSpinLock(Adapter, RT_RX_SPINLOCK);
 	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"==================>%s()\n",__FUNCTION__);
 	if(pRxTs->RxTimeoutIndicateSeq != 0xffff)
 	{
@@ -72,7 +88,6 @@ void RxPktPendingTimeout(unsigned long d
 
 	if(index>0)
 	{
-		// Set RxTimeoutIndicateSeq to 0xffff to indicate no pending packets in buffer now.
 		pRxTs->RxTimeoutIndicateSeq = 0xffff;
 
 		// Indicate packets
@@ -82,6 +97,7 @@ void RxPktPendingTimeout(unsigned long d
 			return;
 		}
 		ieee80211_indicate_packets(ieee, stats_IndicateArray, index);
+		 bPktInBuf = false;
 	}
 
 	if(bPktInBuf && (pRxTs->RxTimeoutIndicateSeq==0xffff))
@@ -126,6 +142,7 @@ void ResetTxTsEntry(PTX_TS_RECORD pTS)
 	pTS->bAddBaReqInProgress = false;
 	pTS->bAddBaReqDelayed = false;
 	pTS->bUsingBa = false;
+	pTS->bDisable_AddBa = false;
 	ResetBaEntry(&pTS->TxAdmittedBARecord); //For BA Originator
 	ResetBaEntry(&pTS->TxPendingBARecord);
 }
@@ -212,7 +229,6 @@ void TSInitialize(struct ieee80211_devic
 	}
 	// Initialize unused Rx Reorder List.
 	INIT_LIST_HEAD(&ieee->RxReorder_Unused_List);
-//#ifdef TO_DO_LIST
 	for(count = 0; count < REORDER_ENTRY_NUM; count++)
 	{
 		list_add_tail( &pRxReorderEntry->List,&ieee->RxReorder_Unused_List);
@@ -220,7 +236,6 @@ void TSInitialize(struct ieee80211_devic
 			break;
 		pRxReorderEntry = &ieee->RxReorderEntry[count+1];
 	}
-//#endif
 
 }
 
@@ -236,7 +251,6 @@ void AdmitTS(struct ieee80211_device *ie
 
 PTS_COMMON_INFO SearchAdmitTRStream(struct ieee80211_device *ieee, u8*	Addr, u8 TID, TR_SELECT	TxRxSelect)
 {
-	//DIRECTION_VALUE 	dir;
 	u8 	dir;
 	bool				search_dir[4] = {0, 0, 0, 0};
 	struct list_head*		psearch_list; //FIXME
@@ -282,18 +296,15 @@ PTS_COMMON_INFO SearchAdmitTRStream(stru
 	else
 		psearch_list = &ieee->Rx_TS_Admit_List;
 
-	//for(dir = DIR_UP; dir <= DIR_BI_DIR; dir++)
 	for(dir = 0; dir <= DIR_BI_DIR; dir++)
 	{
 		if(search_dir[dir] ==false )
 			continue;
 		list_for_each_entry(pRet, psearch_list, List){
-	//		IEEE80211_DEBUG(IEEE80211_DL_TS, "ADD:%pM, TID:%d, dir:%d\n", pRet->Addr, pRet->TSpec.f.TSInfo.field.ucTSID, pRet->TSpec.f.TSInfo.field.ucDirection);
 			if (memcmp(pRet->Addr, Addr, 6) == 0)
 				if (pRet->TSpec.f.TSInfo.field.ucTSID == TID)
 					if(pRet->TSpec.f.TSInfo.field.ucDirection == dir)
 					{
-	//					printk("Bingo! got it\n");
 						break;
 					}
 
@@ -352,10 +363,9 @@ bool GetTs(
 	//
 	if(is_broadcast_ether_addr(Addr) || is_multicast_ether_addr(Addr))
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "get TS for Broadcast or Multicast\n");
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "ERR! get TS for Broadcast or Multicast\n");
 		return false;
 	}
-
 	if (ieee->current_network.qos_data.supported == 0)
 		UP = 0;
 	else
@@ -363,7 +373,7 @@ bool GetTs(
 		// In WMM case: we use 4 TID only
 		if (!IsACValid(TID))
 		{
-			IEEE80211_DEBUG(IEEE80211_DL_ERR, " in %s(), TID(%d) is not valid\n", __FUNCTION__, TID);
+			IEEE80211_DEBUG(IEEE80211_DL_ERR, "ERR! in %s(), TID(%d) is not valid\n", __FUNCTION__, TID);
 			return false;
 		}
 
@@ -478,7 +488,6 @@ void RemoveTsEntry(
 	TR_SELECT			TxRxSelect
 	)
 {
-	//u32 flags = 0;
 	unsigned long flags = 0;
 	del_timer_sync(&pTs->SetupTimer);
 	del_timer_sync(&pTs->InactTimer);
@@ -486,7 +495,6 @@ void RemoveTsEntry(
 
 	if(TxRxSelect == RX_DIR)
 	{
-//#ifdef TO_DO_LIST
 		PRX_REORDER_ENTRY	pRxReorderEntry;
 		PRX_TS_RECORD 		pRxTS = (PRX_TS_RECORD)pTs;
 		if(timer_pending(&pRxTS->RxPktPendingTimer))
@@ -494,9 +502,7 @@ void RemoveTsEntry(
 
                 while(!list_empty(&pRxTS->RxPendingPktList))
                 {
-                //      PlatformAcquireSpinLock(Adapter, RT_RX_SPINLOCK);
                         spin_lock_irqsave(&(ieee->reorder_spinlock), flags);
-                        //pRxReorderEntry = list_entry(&pRxTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
 			pRxReorderEntry = (PRX_REORDER_ENTRY)list_entry(pRxTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
                         list_del_init(&pRxReorderEntry->List);
                         {
@@ -514,11 +520,8 @@ void RemoveTsEntry(
                                 prxb = NULL;
                         }
                         list_add_tail(&pRxReorderEntry->List,&ieee->RxReorder_Unused_List);
-                        //PlatformReleaseSpinLock(Adapter, RT_RX_SPINLOCK);
                         spin_unlock_irqrestore(&(ieee->reorder_spinlock), flags);
                 }
-
-//#endif
 	}
 	else
 	{

--- a/drivers/staging/rtl8192e/ieee80211.h
+++ b/drivers/staging/rtl8192e/ieee80211.h
@@ -531,7 +531,7 @@ do { if (ieee80211_debug_level & (level)
 		{ 	\
 			int i;					\
 			u8* pdata = (u8*) data;			\
-			printk(KERN_DEBUG "ieee80211: %s()\n", __FUNCTION__);	\
+			printk(KERN_DEBUG "ieee80211: %s()\n", __func__);	\
 			for(i=0; i<(int)(datalen); i++)			\
 			{						\
 				printk("%2x ", pdata[i]);		\
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211.h
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211.h
@@ -554,7 +554,7 @@ do { if (ieee80211_debug_level & (level)
 		{ 	\
 			int i;					\
 			u8* pdata = (u8*) data;			\
-			printk(KERN_DEBUG "ieee80211: %s()\n", __FUNCTION__);	\
+			printk(KERN_DEBUG "ieee80211: %s()\n", __func__);	\
 			for(i=0; i<(int)(datalen); i++)			\
 			{						\
 				printk("%2x ", pdata[i]);		\
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211_crypt_ccmp.c
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211_crypt_ccmp.c
@@ -456,7 +456,7 @@ static char * ieee80211_ccmp_print_stats
 
 void ieee80211_ccmp_null(void)
 {
-//    printk("============>%s()\n", __FUNCTION__);
+//    printk("============>%s()\n", __func__);
 	return;
 }
 
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211_crypt_tkip.c
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211_crypt_tkip.c
@@ -829,7 +829,7 @@ void ieee80211_crypto_tkip_exit(void)
 
 void ieee80211_tkip_null(void)
 {
-//    printk("============>%s()\n", __FUNCTION__);
+//    printk("============>%s()\n", __func__);
         return;
 }
 
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211_rx.c
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211_rx.c
@@ -575,7 +575,7 @@ void ieee80211_indicate_packets(struct i
 	u8 i = 0 , j=0;
 	u16 ethertype;
 //	if(index > 1)
-//		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): hahahahhhh, We indicate packet from reorder list, index is %u\n",__FUNCTION__,index);
+//		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): hahahahhhh, We indicate packet from reorder list, index is %u\n",__func__,index);
 	for(j = 0; j<index; j++)
 	{
 //added by amy for reorder
@@ -636,7 +636,7 @@ void RxReorderIndicatePacket( struct iee
 	u16			WinEnd = (pTS->RxIndicateSeq + WinSize -1)%4096;
 	u8			index = 0;
 	bool			bMatchWinStart = false, bPktInBuf = false;
-	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): Seq is %d,pTS->RxIndicateSeq is %d, WinSize is %d\n",__FUNCTION__,SeqNum,pTS->RxIndicateSeq,WinSize);
+	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): Seq is %d,pTS->RxIndicateSeq is %d, WinSize is %d\n",__func__,SeqNum,pTS->RxIndicateSeq,WinSize);
 #if 0
 	if(!list_empty(&ieee->RxReorder_Unused_List))
 		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): ieee->RxReorder_Unused_List is nut NULL\n");
@@ -693,11 +693,11 @@ void RxReorderIndicatePacket( struct iee
 		IEEE80211_DEBUG(IEEE80211_DL_REORDER, "Packets indication!! IndicateSeq: %d, NewSeq: %d\n",\
 				pTS->RxIndicateSeq, SeqNum);
 		prxbIndicateArray[0] = prxb;
-//		printk("========================>%s(): SeqNum is %d\n",__FUNCTION__,SeqNum);
+//		printk("========================>%s(): SeqNum is %d\n",__func__,SeqNum);
 		index = 1;
 	} else {
 		/* Current packet is going to be inserted into pending list.*/
-		//IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): We RX no ordered packed, insert to orderd list\n",__FUNCTION__);
+		//IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): We RX no ordered packed, insert to orderd list\n",__func__);
 		if(!list_empty(&ieee->RxReorder_Unused_List)) {
 			pReorderEntry = (PRX_REORDER_ENTRY)list_entry(ieee->RxReorder_Unused_List.next,RX_REORDER_ENTRY,List);
 			list_del_init(&pReorderEntry->List);
@@ -705,12 +705,12 @@ void RxReorderIndicatePacket( struct iee
 			/* Make a reorder entry and insert into a the packet list.*/
 			pReorderEntry->SeqNum = SeqNum;
 			pReorderEntry->prxb = prxb;
-	//		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): pREorderEntry->SeqNum is %d\n",__FUNCTION__,pReorderEntry->SeqNum);
+	//		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): pREorderEntry->SeqNum is %d\n",__func__,pReorderEntry->SeqNum);
 
 #if 1
 			if(!AddReorderEntry(pTS, pReorderEntry)) {
 				IEEE80211_DEBUG(IEEE80211_DL_REORDER, "%s(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n",
-					__FUNCTION__, pTS->RxIndicateSeq, SeqNum);
+					__func__, pTS->RxIndicateSeq, SeqNum);
 				list_add_tail(&pReorderEntry->List,&ieee->RxReorder_Unused_List);
 				{
 					int i;
@@ -746,7 +746,7 @@ void RxReorderIndicatePacket( struct iee
 
 	/* Check if there is any packet need indicate.*/
 	while(!list_empty(&pTS->RxPendingPktList)) {
-		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): start RREORDER indicate\n",__FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): start RREORDER indicate\n",__func__);
 #if 1
 		pReorderEntry = (PRX_REORDER_ENTRY)list_entry(pTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
 		if( SN_LESS(pReorderEntry->SeqNum, pTS->RxIndicateSeq) ||
@@ -766,7 +766,7 @@ void RxReorderIndicatePacket( struct iee
 
 			IEEE80211_DEBUG(IEEE80211_DL_REORDER,"Packets indication!! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);
 			prxbIndicateArray[index] = pReorderEntry->prxb;
-		//	printk("========================>%s(): pReorderEntry->SeqNum is %d\n",__FUNCTION__,pReorderEntry->SeqNum);
+		//	printk("========================>%s(): pReorderEntry->SeqNum is %d\n",__func__,pReorderEntry->SeqNum);
 			index++;
 
 			list_add_tail(&pReorderEntry->List,&ieee->RxReorder_Unused_List);
@@ -796,7 +796,7 @@ void RxReorderIndicatePacket( struct iee
 #if 1
 	if(bPktInBuf && pTS->RxTimeoutIndicateSeq==0xffff) {
 		// Set new pending timer.
-		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): SET rx timeout timer\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): SET rx timeout timer\n", __func__);
 		pTS->RxTimeoutIndicateSeq = pTS->RxIndicateSeq;
 #if 0
 		if(timer_pending(&pTS->RxPktPendingTimer))
@@ -881,8 +881,8 @@ u8 parse_subframe(struct ieee80211_devic
 						("ParseSubframe(): A-MSDU subframe parse error!! Subframe Length: %d\n", nSubframe_Length) );
 #endif
 				printk("%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",\
-						__FUNCTION__,rxb->nr_subframes);
-				printk("%s: A-MSDU parse error!! Subframe Length: %d\n",__FUNCTION__, nSubframe_Length);
+						__func__,rxb->nr_subframes);
+				printk("%s: A-MSDU parse error!! Subframe Length: %d\n",__func__, nSubframe_Length);
 				printk("nRemain_Length is %d and nSubframe_Length is : %d\n",skb->len,nSubframe_Length);
 				printk("The Packet SeqNum is %d\n",SeqNum);
 				return 0;
@@ -1088,7 +1088,7 @@ int ieee80211_rtl_rx(struct ieee80211_de
 		printk("====================>fc:%x, tid:%d, tmp:%d\n", fc, tid, tmp);
 		//u8 tid =  (u8)((frameqos*)(buf + ((fc & IEEE80211_FCTL_TODS)&&(fc & IEEE80211_FCTL_FROMDS))? 30 : 24))->field.tid;
 	#endif
-			//IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): QOS ENABLE AND RECEIVE QOS DATA , we will get Ts, tid:%d\n",__FUNCTION__, tid);
+			//IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): QOS ENABLE AND RECEIVE QOS DATA , we will get Ts, tid:%d\n",__func__, tid);
 #if 1
 		if(GetTs(
 				ieee,
@@ -1099,7 +1099,7 @@ int ieee80211_rtl_rx(struct ieee80211_de
 				true))
 		{
 
-		//	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): pRxTS->RxLastFragNum is %d,frag is %d,pRxTS->RxLastSeqNum is %d,seq is %d\n",__FUNCTION__,pRxTS->RxLastFragNum,frag,pRxTS->RxLastSeqNum,WLAN_GET_SEQ_SEQ(sc));
+		//	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): pRxTS->RxLastFragNum is %d,frag is %d,pRxTS->RxLastSeqNum is %d,seq is %d\n",__func__,pRxTS->RxLastFragNum,frag,pRxTS->RxLastSeqNum,WLAN_GET_SEQ_SEQ(sc));
 			if( 	(fc & (1<<11))  &&
 					(frag == pRxTS->RxLastFragNum) &&
 					(WLAN_GET_SEQ_SEQ(sc) == pRxTS->RxLastSeqNum)	)
@@ -1114,7 +1114,7 @@ int ieee80211_rtl_rx(struct ieee80211_de
 		}
 		else
 		{
-			IEEE80211_DEBUG(IEEE80211_DL_ERR, "%s(): No TS!! Skip the check!!\n",__FUNCTION__);
+			IEEE80211_DEBUG(IEEE80211_DL_ERR, "%s(): No TS!! Skip the check!!\n",__func__);
 			goto rx_dropped;
 		}
 	}
@@ -1396,7 +1396,7 @@ int ieee80211_rtl_rx(struct ieee80211_de
 	rxb = kmalloc(sizeof(struct ieee80211_rxb), GFP_ATOMIC);
 	if(rxb == NULL)
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_ERR,"%s(): kmalloc rxb error\n",__FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR,"%s(): kmalloc rxb error\n",__func__);
 		goto rx_dropped;
 	}
 	/* to parse amsdu packets */
@@ -1488,7 +1488,7 @@ int ieee80211_rtl_rx(struct ieee80211_de
 	}
 	else
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): REORDER ENABLE AND PTS not NULL, and we will enter RxReorderIndicatePacket()\n",__FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): REORDER ENABLE AND PTS not NULL, and we will enter RxReorderIndicatePacket()\n",__func__);
 		RxReorderIndicatePacket(ieee, rxb, pTS, SeqNum);
 	}
 #ifndef JOHN_NOCPY
@@ -2073,7 +2073,7 @@ int ieee80211_parse_info_param(struct ie
 				info_element->data[1] == 0x13 &&
 				info_element->data[2] == 0x74))
 			{
-				//printk("========>%s(): athros AP is exist\n",__FUNCTION__);
+				//printk("========>%s(): athros AP is exist\n",__func__);
 				network->atheros_cap_exist = true;
 			}
 			else
@@ -2085,7 +2085,7 @@ int ieee80211_parse_info_param(struct ie
 						info_element->data[2] == 0x43) )
 			{
 				network->marvell_cap_exist = true;
-				//printk("========>%s(): marvel AP is exist\n",__FUNCTION__);
+				//printk("========>%s(): marvel AP is exist\n",__func__);
 			}
 
 
@@ -2551,7 +2551,7 @@ static inline void update_network(struct
 	old_param = dst->qos_data.param_count;
 	if(dst->flags & NETWORK_HAS_QOS_MASK){
         //not update QOS paramter in beacon, as most AP will set all these parameter to 0.//WB
-	//	printk("====>%s(), aifs:%x, %x\n", __FUNCTION__, dst->qos_data.parameters.aifs[0], src->qos_data.parameters.aifs[0]);
+	//	printk("====>%s(), aifs:%x, %x\n", __func__, dst->qos_data.parameters.aifs[0], src->qos_data.parameters.aifs[0]);
 	//	memcpy(&dst->qos_data, &src->qos_data,
 	//		sizeof(struct ieee80211_qos_data));
 	}
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211_softmac.c
@@ -280,7 +280,7 @@ inline void softmac_mgmt_xmit(struct sk_
 			/* as for the completion function, it does not need
 			 * to check it any more.
 			 * */
-			//printk("%s():insert to waitqueue!\n",__FUNCTION__);
+			//printk("%s():insert to waitqueue!\n",__func__);
 			skb_queue_tail(&ieee->skb_waitQ[tcb_desc->queue_index], skb);
 		} else {
 			//printk("TX packet!\n");
@@ -304,7 +304,7 @@ inline void softmac_ps_mgmt_xmit(struct
 	tcb_desc->RATRIndex = 7;
 	tcb_desc->bTxDisableRateFallBack = 1;
 	tcb_desc->bTxUseDriverAssingedRate = 1;
-	//printk("=============>%s()\n", __FUNCTION__);
+	//printk("=============>%s()\n", __func__);
 	if(single){
 
 		header->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);
@@ -716,7 +716,7 @@ inline struct sk_buff *ieee80211_authent
 		auth->algorithm = WLAN_AUTH_SHARED_KEY;
 	else if(ieee->auth_mode == 2)
 		auth->algorithm = WLAN_AUTH_OPEN;//0x80;
-	printk("=================>%s():auth->algorithm is %d\n",__FUNCTION__,auth->algorithm);
+	printk("=================>%s():auth->algorithm is %d\n",__func__,auth->algorithm);
 	auth->transaction = cpu_to_le16(ieee->associate_seq);
 	ieee->associate_seq++;
 
@@ -1344,7 +1344,7 @@ inline struct sk_buff *ieee80211_associa
 			memcpy(tag, realtek_ie_buf,realtek_ie_len -2 );
 		}
 	}
-//	printk("<=====%s(), %p, %p\n", __FUNCTION__, ieee->dev, ieee->dev->dev_addr);
+//	printk("<=====%s(), %p, %p\n", __func__, ieee->dev, ieee->dev->dev_addr);
 //	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, skb->data, skb->len);
 	return skb;
 }
@@ -1559,7 +1559,7 @@ void ieee80211_associate_procedure_wq(st
 		ieee->data_hard_stop(ieee->dev);
 
 	ieee80211_stop_scan(ieee);
-	printk("===>%s(), chan:%d\n", __FUNCTION__, ieee->current_network.channel);
+	printk("===>%s(), chan:%d\n", __func__, ieee->current_network.channel);
 	//ieee->set_chan(ieee->dev, ieee->current_network.channel);
 	HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
 
@@ -1921,7 +1921,7 @@ short ieee80211_sta_ps_sleep(struct ieee
 	}
 
 	dtim = ieee->current_network.dtim_data;
-//	printk("%s():DTIM:%d\n",__FUNCTION__,dtim);
+//	printk("%s():DTIM:%d\n",__func__,dtim);
 	if(!(dtim & IEEE80211_DTIM_VALID))
 		return 0;
 	timeout = ieee->current_network.beacon_interval; //should we use ps_timeout value or beacon_interval
@@ -1932,11 +1932,11 @@ short ieee80211_sta_ps_sleep(struct ieee
 		return 2;
 
 	if(!time_after(jiffies, ieee->dev->trans_start + MSECS(timeout))){
-//		printk("%s():111Oh Oh ,it is not time out return 0\n",__FUNCTION__);
+//		printk("%s():111Oh Oh ,it is not time out return 0\n",__func__);
 		return 0;
 	}
 	if(!time_after(jiffies, ieee->last_rx_ps_time + MSECS(timeout))){
-//		printk("%s():222Oh Oh ,it is not time out return 0\n",__FUNCTION__);
+//		printk("%s():222Oh Oh ,it is not time out return 0\n",__func__);
 		return 0;
 	}
 	if((ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE ) &&
@@ -2011,7 +2011,7 @@ inline void ieee80211_sta_ps(struct ieee
 
 	//	#warning CHECK_LOCK_HERE
 		printk("=====>%s(): no need to ps,wake up!! ieee->ps is %d,ieee->iw_mode is %d,ieee->state is %d\n",
-			__FUNCTION__,ieee->ps,ieee->iw_mode,ieee->state);
+			__func__,ieee->ps,ieee->iw_mode,ieee->state);
 		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
 
 		ieee80211_sta_wakeup(ieee, 1);
@@ -2937,7 +2937,7 @@ void ieee80211_start_protocol(struct iee
 
 	if (ieee->current_network.beacon_interval == 0)
 		ieee->current_network.beacon_interval = 100;
-//	printk("===>%s(), chan:%d\n", __FUNCTION__, ieee->current_network.channel);
+//	printk("===>%s(), chan:%d\n", __func__, ieee->current_network.channel);
 //	ieee->set_chan(ieee->dev,ieee->current_network.channel);
 
        	for(i = 0; i < 17; i++) {
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211_tx.c
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211_tx.c
@@ -189,7 +189,7 @@ int ieee80211_encrypt_fragment(
 
 	if (!(crypt && crypt->ops))
 	{
-		printk("=========>%s(), crypt is null\n", __FUNCTION__);
+		printk("=========>%s(), crypt is null\n", __func__);
 		return -1;
 	}
 #ifdef CONFIG_IEEE80211_CRYPT_TKIP
--- a/drivers/staging/rtl8192e/ieee80211/ieee80211_wx.c
+++ b/drivers/staging/rtl8192e/ieee80211/ieee80211_wx.c
@@ -813,7 +813,7 @@ int ieee80211_wx_set_auth(struct ieee802
 		break;
 
 	case IW_AUTH_80211_AUTH_ALG:
-		//printk("======>%s():data->value is %d\n",__FUNCTION__,data->value);
+		//printk("======>%s():data->value is %d\n",__func__,data->value);
 	//	ieee->open_wep = (data->value&IW_AUTH_ALG_OPEN_SYSTEM)?1:0;
 		if(data->value & IW_AUTH_ALG_SHARED_KEY){
 			ieee->open_wep = 0;
--- a/drivers/staging/rtl8192e/ieee80211/rtl819x_BAProc.c
+++ b/drivers/staging/rtl8192e/ieee80211/rtl819x_BAProc.c
@@ -113,7 +113,7 @@ static struct sk_buff* ieee80211_ADDBA(s
 	u16 tmp = 0;
 	u16 len = ieee->tx_headroom + 9;
 	//category(1) + action field(1) + Dialog Token(1) + BA Parameter Set(2) +  BA Timeout Value(2) +  BA Start SeqCtrl(2)(or StatusCode(2))
-	IEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "========>%s(), frame(%d) sentd to:%pM, ieee->dev:%p\n", __FUNCTION__, type, Dst, ieee->dev);
+	IEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "========>%s(), frame(%d) sentd to:%pM, ieee->dev:%p\n", __func__, type, Dst, ieee->dev);
 	if (pBA == NULL||ieee == NULL)
 	{
 		IEEE80211_DEBUG(IEEE80211_DL_ERR, "pBA(%p) is NULL or ieee(%p) is NULL\n", pBA, ieee);
@@ -243,7 +243,7 @@ static struct sk_buff* ieee80211_DELBA(
 	u16 len = 6 + ieee->tx_headroom;
 
 	if (net_ratelimit())
-	IEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "========>%s(), ReasonCode(%d) sentd to:%pM\n", __FUNCTION__, ReasonCode, dst);
+	IEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "========>%s(), ReasonCode(%d) sentd to:%pM\n", __func__, ReasonCode, dst);
 
 	memset(&DelbaParamSet, 0, 2);
 
@@ -282,7 +282,7 @@ static struct sk_buff* ieee80211_DELBA(
 
 	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA|IEEE80211_DL_BA, skb->data, skb->len);
 	if (net_ratelimit())
-	IEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "<=====%s()\n", __FUNCTION__);
+	IEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "<=====%s()\n", __func__);
 	return skb;
 }
 
@@ -307,7 +307,7 @@ void ieee80211_send_ADDBAReq(struct ieee
 	}
 	else
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __func__);
 	}
 	return;
 }
@@ -331,7 +331,7 @@ void ieee80211_send_ADDBARsp(struct ieee
 	}
 	else
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __func__);
 	}
 
 	return;
@@ -358,7 +358,7 @@ void ieee80211_send_DELBA(struct ieee802
 	}
 	else
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __func__);
 	}
 	return ;
 }
@@ -418,7 +418,7 @@ int ieee80211_rx_ADDBAReq( struct ieee80
 			true)	)
 	{
 		rc = ADDBA_STATUS_REFUSED;
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "can't get TS in %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "can't get TS in %s()\n", __func__);
 		goto OnADDBAReq_Fail;
 	}
 	pBA = &pTS->RxAdmittedBARecord;
@@ -429,7 +429,7 @@ int ieee80211_rx_ADDBAReq( struct ieee80
 	if(pBaParamSet->field.BAPolicy == BA_POLICY_DELAYED)
 	{
 		rc = ADDBA_STATUS_INVALID_PARAM;
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "BA Policy is not correct in %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "BA Policy is not correct in %s()\n", __func__);
 		goto OnADDBAReq_Fail;
 	}
 		// Admit the ADDBA Request
@@ -517,7 +517,7 @@ int ieee80211_rx_ADDBARsp( struct ieee80
 			TX_DIR,
 			false)	)
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "can't get TS in %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "can't get TS in %s()\n", __func__);
 		ReasonCode = DELBA_REASON_UNKNOWN_BA;
 		goto OnADDBARsp_Reject;
 	}
@@ -641,7 +641,7 @@ int ieee80211_rx_DELBA(struct ieee80211_
 				RX_DIR,
 				false)	)
 		{
-			IEEE80211_DEBUG(IEEE80211_DL_ERR,  "can't get TS for RXTS in %s()\n", __FUNCTION__);
+			IEEE80211_DEBUG(IEEE80211_DL_ERR,  "can't get TS for RXTS in %s()\n", __func__);
 			return -1;
 		}
 
@@ -659,7 +659,7 @@ int ieee80211_rx_DELBA(struct ieee80211_
 			TX_DIR,
 			false)	)
 		{
-			IEEE80211_DEBUG(IEEE80211_DL_ERR,  "can't get TS for TXTS in %s()\n", __FUNCTION__);
+			IEEE80211_DEBUG(IEEE80211_DL_ERR,  "can't get TS for TXTS in %s()\n", __func__);
 			return -1;
 		}
 
--- a/drivers/staging/rtl8192e/ieee80211/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192e/ieee80211/rtl819x_HTProc.c
@@ -131,7 +131,7 @@ void HTDebugHTCapability(u8* CapIE, u8*
 	if(!memcmp(CapIE, EWC11NHTCap, sizeof(EWC11NHTCap)))
 	{
 		//EWC IE
-		IEEE80211_DEBUG(IEEE80211_DL_HT, "EWC IE in %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_HT, "EWC IE in %s()\n", __func__);
 		pCapELE = (PHT_CAPABILITY_ELE)(&CapIE[4]);
 	}else
 		pCapELE = (PHT_CAPABILITY_ELE)(&CapIE[0]);
@@ -168,7 +168,7 @@ void HTDebugHTInfo(u8*	InfoIE, u8* Title
 	if(!memcmp(InfoIE, EWC11NHTInfo, sizeof(EWC11NHTInfo)))
 	{
 		// Not EWC IE
-		IEEE80211_DEBUG(IEEE80211_DL_HT, "EWC IE in %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_HT, "EWC IE in %s()\n", __func__);
 		pHTInfoEle = (PHT_INFORMATION_ELE)(&InfoIE[4]);
 	}else
 		pHTInfoEle = (PHT_INFORMATION_ELE)(&InfoIE[0]);
@@ -1235,7 +1235,7 @@ void HTInitializeHTInfo(struct ieee80211
 	//
 	// These parameters will be reset when receiving deauthentication packet
 	//
-	IEEE80211_DEBUG(IEEE80211_DL_HT, "===========>%s()\n", __FUNCTION__);
+	IEEE80211_DEBUG(IEEE80211_DL_HT, "===========>%s()\n", __func__);
 	pHTInfo->bCurrentHTSupport = false;
 
 	// 40MHz channel support
@@ -1511,7 +1511,7 @@ void HTResetSelfAndSavePeerSetting(struc
 	//
 	//  Save Peer Setting before Association
 	//
-	IEEE80211_DEBUG(IEEE80211_DL_HT, "==============>%s()\n", __FUNCTION__);
+	IEEE80211_DEBUG(IEEE80211_DL_HT, "==============>%s()\n", __func__);
 	/*unmark bEnableHT flag here is the same reason why unmarked in function ieee80211_softmac_new_net. WB 2008.09.10*/
 //	if( pHTInfo->bEnableHT &&  pNetwork->bssht.bdSupportHT)
 	if (pNetwork->bssht.bdSupportHT)
@@ -1730,7 +1730,7 @@ void HTSetConnectBwModeCallback(struct i
 {
 	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
 
-	IEEE80211_DEBUG(IEEE80211_DL_HT, "======>%s()\n", __FUNCTION__);
+	IEEE80211_DEBUG(IEEE80211_DL_HT, "======>%s()\n", __func__);
 
 	if(pHTInfo->bCurBW40MHz)
 	{
--- a/drivers/staging/rtl8192e/ieee80211/rtl819x_TSProc.c
+++ b/drivers/staging/rtl8192e/ieee80211/rtl819x_TSProc.c
@@ -38,7 +38,7 @@ void RxPktPendingTimeout(unsigned long d
 
 	spin_lock_irqsave(&(ieee->reorder_spinlock), flags);
 	//PlatformAcquireSpinLock(Adapter, RT_RX_SPINLOCK);
-	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"==================>%s()\n",__FUNCTION__);
+	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"==================>%s()\n",__func__);
 	if(pRxTs->RxTimeoutIndicateSeq != 0xffff)
 	{
 		// Indicate the pending packets sequentially according to SeqNum until meet the gap.
@@ -144,7 +144,7 @@ void TSInitialize(struct ieee80211_devic
 	PRX_TS_RECORD		pRxTS  = ieee->RxTsRecord;
 	PRX_REORDER_ENTRY	pRxReorderEntry = ieee->RxReorderEntry;
 	u8				count = 0;
-	IEEE80211_DEBUG(IEEE80211_DL_TS, "==========>%s()\n", __FUNCTION__);
+	IEEE80211_DEBUG(IEEE80211_DL_TS, "==========>%s()\n", __func__);
 	// Initialize Tx TS related info.
 	INIT_LIST_HEAD(&ieee->Tx_TS_Admit_List);
 	INIT_LIST_HEAD(&ieee->Tx_TS_Pending_List);
@@ -363,7 +363,7 @@ bool GetTs(
 		// In WMM case: we use 4 TID only
 		if (!IsACValid(TID))
 		{
-			IEEE80211_DEBUG(IEEE80211_DL_ERR, " in %s(), TID(%d) is not valid\n", __FUNCTION__, TID);
+			IEEE80211_DEBUG(IEEE80211_DL_ERR, " in %s(), TID(%d) is not valid\n", __func__, TID);
 			return false;
 		}
 
@@ -465,7 +465,7 @@ bool GetTs(
 			}
 			else
 			{
-				IEEE80211_DEBUG(IEEE80211_DL_ERR, "in function %s() There is not enough TS record to be used!!", __FUNCTION__);
+				IEEE80211_DEBUG(IEEE80211_DL_ERR, "in function %s() There is not enough TS record to be used!!", __func__);
 				return false;
 			}
 		}
@@ -624,5 +624,5 @@ void TsStartAddBaProcess(struct ieee8021
 		}
 	}
 	else
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "%s()==>BA timer is already added\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "%s()==>BA timer is already added\n", __func__);
 }
--- a/drivers/staging/rtl8192e/r8190_rtl8256.c
+++ b/drivers/staging/rtl8192e/r8190_rtl8256.c
@@ -511,7 +511,7 @@ SetRFPowerState8190(
 
 					if(rtstatus != true)
 					{
-						RT_TRACE(COMP_ERR,"%s():Initialize Adapter fail,return\n",__FUNCTION__);
+						RT_TRACE(COMP_ERR,"%s():Initialize Adapter fail,return\n",__func__);
 						priv->SetRFPowerStateInProgress = false;
 						return false;
 					}
--- a/drivers/staging/rtl8192e/r8192E.h
+++ b/drivers/staging/rtl8192e/r8192E.h
@@ -155,7 +155,7 @@ do { if(rt_global_debug_component & comp
 #define assert(expr) \
         if (!(expr)) {                                  \
                 printk( "Assertion failed! %s,%s,%s,line=%d\n", \
-                #expr,__FILE__,__FUNCTION__,__LINE__);          \
+                #expr,__FILE__,__func__,__LINE__);          \
         }
 //wb added to debug out data buf
 //if you want print DATA buffer related BA, please set ieee80211_debug_level to DATA|BA
@@ -164,7 +164,7 @@ do { if(rt_global_debug_component & comp
                 {       \
                         int i;                                  \
                         u8* pdata = (u8*) data;                 \
-                        printk(KERN_DEBUG RTL819xE_MODULE_NAME ": %s()\n", __FUNCTION__);   \
+                        printk(KERN_DEBUG RTL819xE_MODULE_NAME ": %s()\n", __func__);   \
                         for(i=0; i<(int)(datalen); i++)                 \
                         {                                               \
                                 printk("%2x ", pdata[i]);               \
--- a/drivers/staging/rtl8192e/r8192E_core.c
+++ b/drivers/staging/rtl8192e/r8192E_core.c
@@ -210,7 +210,7 @@ static void rtl819x_set_channel_map(u8 c
 			}
 			else
 			{
-				RT_TRACE(COMP_ERR, "unknown rf chip, can't set channel map in function:%s()\n", __FUNCTION__);
+				RT_TRACE(COMP_ERR, "unknown rf chip, can't set channel map in function:%s()\n", __func__);
 			}
 			if (ChannelPlan[channel_plan].Len != 0){
 				// Clear old channel map
@@ -896,7 +896,7 @@ void rtl8192_update_msr(struct net_devic
 void rtl8192_set_chan(struct net_device *dev,short ch)
 {
     struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
-    RT_TRACE(COMP_RF, "=====>%s()====ch:%d\n", __FUNCTION__, ch);
+    RT_TRACE(COMP_RF, "=====>%s()====ch:%d\n", __func__, ch);
     priv->chan=ch;
 #if 0
     if(priv->ieee80211->iw_mode == IW_MODE_ADHOC ||
@@ -1605,7 +1605,7 @@ short rtl8192_tx(struct net_device *dev,
     int   idx;
 
     if(priv->bdisable_nic){
-       	RT_TRACE(COMP_ERR,"%s: ERR!! Nic is disabled! Can't tx packet len=%d qidx=%d!!!\n", __FUNCTION__, skb->len, tcb_desc->queue_index);
+       	RT_TRACE(COMP_ERR,"%s: ERR!! Nic is disabled! Can't tx packet len=%d qidx=%d!!!\n", __func__, skb->len, tcb_desc->queue_index);
 		return skb->len;
     }
 
@@ -2127,7 +2127,7 @@ static int rtl8192_qos_association_resp(
 
         spin_unlock_irqrestore(&priv->ieee80211->lock, flags);
 
-	RT_TRACE(COMP_QOS, "%s: network->flags = %d,%d\n",__FUNCTION__,network->flags ,priv->ieee80211->current_network.qos_data.active);
+	RT_TRACE(COMP_QOS, "%s: network->flags = %d,%d\n",__func__,network->flags ,priv->ieee80211->current_network.qos_data.active);
 	if (set_qos_param == 1)
 		queue_work(priv->priv_wq, &priv->qos_activate);
 
@@ -2236,7 +2236,7 @@ static bool GetNmodeSupportBySecCfg8190P
 		else
 			return false;
 	} else {
-		//RT_TRACE(COMP_ERR,"In %s The GroupEncAlgorithm is [4]\n",__FUNCTION__ );
+		//RT_TRACE(COMP_ERR,"In %s The GroupEncAlgorithm is [4]\n",__func__ );
 		return true;
 	}
 
@@ -2309,7 +2309,7 @@ static void rtl8192_SetWirelessMode(stru
 			wireless_mode = WIRELESS_MODE_B;
 		}
 		else{
-			RT_TRACE(COMP_ERR, "%s(), No valid wireless mode supported, SupportedWirelessMode(%x)!!!\n", __FUNCTION__,bSupportMode);
+			RT_TRACE(COMP_ERR, "%s(), No valid wireless mode supported, SupportedWirelessMode(%x)!!!\n", __func__,bSupportMode);
 			wireless_mode = WIRELESS_MODE_B;
 		}
 	}
@@ -2371,7 +2371,7 @@ static void rtl8192_hw_sleep_down(struct
 		return;
 	}
 	spin_unlock_irqrestore(&priv->rf_ps_lock,flags);
-	//RT_TRACE(COMP_PS, "%s()============>come to sleep down\n", __FUNCTION__);
+	//RT_TRACE(COMP_PS, "%s()============>come to sleep down\n", __func__);
 
 	MgntActSet_RF_State(dev, eRfSleep, RF_CHANGE_BY_PS);
 }
@@ -2402,7 +2402,7 @@ static void rtl8192_hw_wakeup(struct net
 	}
 	spin_unlock_irqrestore(&priv->rf_ps_lock,flags);
 
-	//RT_TRACE(COMP_PS, "%s()============>come to wake up\n", __FUNCTION__);
+	//RT_TRACE(COMP_PS, "%s()============>come to wake up\n", __func__);
 	MgntActSet_RF_State(dev, eRfOn, RF_CHANGE_BY_PS);
 }
 
@@ -2687,12 +2687,12 @@ static void rtl8192_get_eeprom_size(stru
 {
 	u16 curCR = 0;
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	RT_TRACE(COMP_INIT, "===========>%s()\n", __FUNCTION__);
+	RT_TRACE(COMP_INIT, "===========>%s()\n", __func__);
 	curCR = read_nic_dword(dev, EPROM_CMD);
 	RT_TRACE(COMP_INIT, "read from Reg Cmd9346CR(%x):%x\n", EPROM_CMD, curCR);
 	//whether need I consider BIT5?
 	priv->epromtype = (curCR & EPROM_CMD_9356SEL) ? EPROM_93c56 : EPROM_93c46;
-	RT_TRACE(COMP_INIT, "<===========%s(), epromtype:%d\n", __FUNCTION__, priv->epromtype);
+	RT_TRACE(COMP_INIT, "<===========%s(), epromtype:%d\n", __func__, priv->epromtype);
 }
 
 //used to swap endian. as ntohl & htonl are not neccessary to swap endian, so use this instead.
@@ -3365,7 +3365,7 @@ static RT_STATUS rtl8192_adapter_start(s
 	int	i =0;
 //	u32 dwRegRead = 0;
 
-	RT_TRACE(COMP_INIT, "====>%s()\n", __FUNCTION__);
+	RT_TRACE(COMP_INIT, "====>%s()\n", __func__);
 	priv->being_init_adapter = true;
         rtl8192_pci_resetdescring(dev);
 	// 2007/11/02 MH Before initalizing RF. We can not use FW to do RF-R/W.
@@ -3399,7 +3399,7 @@ static RT_STATUS rtl8192_adapter_start(s
 	}else if(priv->pFirmware->firmware_status == FW_STATUS_5_READY)
 		ulRegRead |= CPU_GEN_FIRMWARE_RESET;	// Called from MPReset
 	else
-		RT_TRACE(COMP_ERR, "ERROR in %s(): undefined firmware state(%d)\n", __FUNCTION__,   priv->pFirmware->firmware_status);
+		RT_TRACE(COMP_ERR, "ERROR in %s(): undefined firmware state(%d)\n", __func__,   priv->pFirmware->firmware_status);
 
 #ifdef RTL8190P
 	//2008.06.03, for WOL 90 hw bug
@@ -3651,7 +3651,7 @@ static RT_STATUS rtl8192_adapter_start(s
 {
 	if(priv->RegRfOff == TRUE)
 	{ // User disable RF via registry.
-		RT_TRACE((COMP_INIT|COMP_RF|COMP_POWER), "%s(): Turn off RF for RegRfOff ----------\n",__FUNCTION__);
+		RT_TRACE((COMP_INIT|COMP_RF|COMP_POWER), "%s(): Turn off RF for RegRfOff ----------\n",__func__);
 		MgntActSet_RF_State(dev, eRfOff, RF_CHANGE_BY_SW);
 #if 0//cosa, ask SD3 willis and he doesn't know what is this for
 		// Those action will be discard in MgntActSet_RF_State because off the same state
@@ -3661,17 +3661,17 @@ static RT_STATUS rtl8192_adapter_start(s
 	}
 	else if(priv->ieee80211->RfOffReason > RF_CHANGE_BY_PS)
 	{ // H/W or S/W RF OFF before sleep.
-		RT_TRACE((COMP_INIT|COMP_RF|COMP_POWER), "%s(): Turn off RF for RfOffReason(%d) ----------\n", __FUNCTION__,priv->ieee80211->RfOffReason);
+		RT_TRACE((COMP_INIT|COMP_RF|COMP_POWER), "%s(): Turn off RF for RfOffReason(%d) ----------\n", __func__,priv->ieee80211->RfOffReason);
 		MgntActSet_RF_State(dev, eRfOff, priv->ieee80211->RfOffReason);
 	}
 	else if(priv->ieee80211->RfOffReason >= RF_CHANGE_BY_IPS)
 	{ // H/W or S/W RF OFF before sleep.
-		RT_TRACE((COMP_INIT|COMP_RF|COMP_POWER), "%s(): Turn off RF for RfOffReason(%d) ----------\n", __FUNCTION__,priv->ieee80211->RfOffReason);
+		RT_TRACE((COMP_INIT|COMP_RF|COMP_POWER), "%s(): Turn off RF for RfOffReason(%d) ----------\n", __func__,priv->ieee80211->RfOffReason);
 		MgntActSet_RF_State(dev, eRfOff, priv->ieee80211->RfOffReason);
 	}
 	else
 	{
-		RT_TRACE((COMP_INIT|COMP_RF|COMP_POWER), "%s(): RF-ON \n",__FUNCTION__);
+		RT_TRACE((COMP_INIT|COMP_RF|COMP_POWER), "%s(): RF-ON \n",__func__);
 		priv->ieee80211->eRFPowerState = eRfOn;
 		priv->ieee80211->RfOffReason = 0;
 		//DrvIFIndicateCurrentPhyStatus(Adapter);
@@ -3807,7 +3807,7 @@ static void rtl8192_prepare_beacon(struc
 
 	skb = ieee80211_get_beacon(priv->ieee80211);
 	tcb_desc = (cb_desc *)(skb->cb + 8);
-        //printk("===========> %s\n", __FUNCTION__);
+        //printk("===========> %s\n", __func__);
 	//spin_lock_irqsave(&priv->tx_lock,flags);
 	/* prepare misc info for the beacon xmit */
 	tcb_desc->queue_index = BEACON_QUEUE;
@@ -3887,7 +3887,7 @@ static bool HalTxCheckStuck8190Pci(struc
 	u16 				RegTxCounter = read_nic_word(dev, 0x128);
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	bool				bStuck = FALSE;
-	RT_TRACE(COMP_RESET,"%s():RegTxCounter is %d,TxCounter is %d\n",__FUNCTION__,RegTxCounter,priv->TxCounter);
+	RT_TRACE(COMP_RESET,"%s():RegTxCounter is %d,TxCounter is %d\n",__func__,RegTxCounter,priv->TxCounter);
 	if(priv->TxCounter==RegTxCounter)
 		bStuck = TRUE;
 
@@ -3913,7 +3913,7 @@ TxCheckStuck(struct net_device *dev)
 	//
 	// Decide Stuch threshold according to current power save mode
 	//
-	//printk("++++++++++++>%s()\n",__FUNCTION__);
+	//printk("++++++++++++>%s()\n",__func__);
 	switch (priv->ieee80211->dot11PowerSaveMode)
 	{
 		// The threshold value  may required to be adjusted .
@@ -3976,7 +3976,7 @@ TxCheckStuck(struct net_device *dev)
 			txring = head;
 			if(txring == NULL)
 			{
-				RT_TRACE(COMP_ERR,"%s():txring is NULL , BUG!\n",__FUNCTION__);
+				RT_TRACE(COMP_ERR,"%s():txring is NULL , BUG!\n",__func__);
 				continue;
 			}
 			txring->nStuckCount++;
@@ -4003,7 +4003,7 @@ static bool HalRxCheckStuck8190Pci(struc
 	u16 				RegRxCounter = read_nic_word(dev, 0x130);
 	bool				bStuck = FALSE;
 	static u8			rx_chk_cnt = 0;
-	RT_TRACE(COMP_RESET,"%s(): RegRxCounter is %d,RxCounter is %d\n",__FUNCTION__,RegRxCounter,priv->RxCounter);
+	RT_TRACE(COMP_RESET,"%s(): RegRxCounter is %d,RxCounter is %d\n",__func__,RegRxCounter,priv->RxCounter);
 	// If rssi is small, we should check rx for long time because of bad rx.
 	// or maybe it will continuous silent reset every 2 seconds.
 	rx_chk_cnt++;
@@ -4101,7 +4101,7 @@ rtl819x_ifcheck_resetornot(struct net_de
 	}
 #endif
 
-	RT_TRACE(COMP_RESET,"%s(): TxResetType is %d, RxResetType is %d\n",__FUNCTION__,TxResetType,RxResetType);
+	RT_TRACE(COMP_RESET,"%s(): TxResetType is %d, RxResetType is %d\n",__func__,TxResetType,RxResetType);
 	if(TxResetType==RESET_TYPE_NORMAL || RxResetType==RESET_TYPE_NORMAL)
 		return RESET_TYPE_NORMAL;
 	else if(TxResetType==RESET_TYPE_SILENT || RxResetType==RESET_TYPE_SILENT)
@@ -4286,12 +4286,12 @@ RESET_START:
 		down(&priv->wx_sem);
 		if(priv->up == 0)
 		{
-			RT_TRACE(COMP_ERR,"%s():the driver is not up! return\n",__FUNCTION__);
+			RT_TRACE(COMP_ERR,"%s():the driver is not up! return\n",__func__);
 			up(&priv->wx_sem);
 			return ;
 		}
 		priv->up = 0;
-		RT_TRACE(COMP_RESET,"%s():======>start to down the driver\n",__FUNCTION__);
+		RT_TRACE(COMP_RESET,"%s():======>start to down the driver\n",__func__);
 		if(!netif_queue_stopped(dev))
 			netif_stop_queue(dev);
 
@@ -4318,11 +4318,11 @@ RESET_START:
 		}
 		rtl8192_halt_adapter(dev, true);
 		up(&priv->wx_sem);
-		RT_TRACE(COMP_RESET,"%s():<==========down process is finished\n",__FUNCTION__);
-		RT_TRACE(COMP_RESET,"%s():===========>start to up the driver\n",__FUNCTION__);
+		RT_TRACE(COMP_RESET,"%s():<==========down process is finished\n",__func__);
+		RT_TRACE(COMP_RESET,"%s():===========>start to up the driver\n",__func__);
 		reset_status = _rtl8192_up(dev);
 
-		RT_TRACE(COMP_RESET,"%s():<===========up process is finished\n",__FUNCTION__);
+		RT_TRACE(COMP_RESET,"%s():<===========up process is finished\n",__func__);
 		if(reset_status == -1)
 		{
 			if(reset_times < 3)
@@ -4332,7 +4332,7 @@ RESET_START:
 			}
 			else
 			{
-				RT_TRACE(COMP_ERR," ERR!!! %s():  Reset Failed!!\n",__FUNCTION__);
+				RT_TRACE(COMP_ERR," ERR!!! %s():  Reset Failed!!\n",__func__);
 			}
 		}
 #endif
@@ -4440,7 +4440,7 @@ bool MgntActSet_802_11_PowerSaveMode(str
 //	Adapter->HalFunc.SetPSModeHandler( Adapter, rtPsMode );
 
 	// Update power save mode configured.
-	//RT_TRACE(COMP_LPS,"%s(): set ieee->ps = %x\n",__FUNCTION__,rtPsMode);
+	//RT_TRACE(COMP_LPS,"%s(): set ieee->ps = %x\n",__func__,rtPsMode);
 	if(!priv->ps_force) {
 		priv->ieee80211->ps = rtPsMode;
 	}
@@ -4618,11 +4618,11 @@ void ieee80211_ips_leave_wq(struct net_d
 		if(rtState == eRfOff){
 			if(priv->ieee80211->RfOffReason > RF_CHANGE_BY_IPS)
 			{
-				RT_TRACE(COMP_ERR, "%s(): RF is OFF.\n",__FUNCTION__);
+				RT_TRACE(COMP_ERR, "%s(): RF is OFF.\n",__func__);
 				return;
 			}
 			else{
-				printk("=========>%s(): IPSLeave\n",__FUNCTION__);
+				printk("=========>%s(): IPSLeave\n",__func__);
 				queue_work(priv->ieee80211->wq,&priv->ieee80211->ips_leave_wq);
 			}
 		}
@@ -4756,8 +4756,8 @@ static void rtl819x_watchdog_wqcallback(
 			if((TotalRxBcnNum+TotalRxDataNum) == 0)
 			{
 				if( ieee->eRFPowerState == eRfOff)
-					RT_TRACE(COMP_ERR,"========>%s()\n",__FUNCTION__);
-				printk("===>%s(): AP is power off,connect another one\n",__FUNCTION__);
+					RT_TRACE(COMP_ERR,"========>%s()\n",__func__);
+				printk("===>%s(): AP is power off,connect another one\n",__func__);
 				//		Dot11d_Reset(dev);
 				ieee->state = IEEE80211_ASSOCIATING;
 				notify_wx_assoc_event(priv->ieee80211);
@@ -4784,7 +4784,7 @@ static void rtl819x_watchdog_wqcallback(
 	if(!priv->bDisableNormalResetCheck && ResetType == RESET_TYPE_NORMAL)
 	{
 		priv->ResetProgress = RESET_TYPE_NORMAL;
-		RT_TRACE(COMP_RESET,"%s(): NOMAL RESET\n",__FUNCTION__);
+		RT_TRACE(COMP_RESET,"%s(): NOMAL RESET\n",__func__);
 		return;
 	}
 	/* disable silent reset temply 2008.9.11*/
@@ -4824,7 +4824,7 @@ int _rtl8192_up(struct net_device *dev)
 	init_status = rtl8192_adapter_start(dev);
 	if(init_status != RT_STATUS_SUCCESS)
 	{
-		RT_TRACE(COMP_ERR,"ERR!!! %s(): initialization is failed!\n",__FUNCTION__);
+		RT_TRACE(COMP_ERR,"ERR!!! %s(): initialization is failed!\n",__func__);
 		return -1;
 	}
 	RT_TRACE(COMP_INIT, "start adapter finished\n");
@@ -4901,7 +4901,7 @@ int rtl8192_down(struct net_device *dev)
 
 	priv->up=0;
 	priv->ieee80211->ieee_up = 0;
-	RT_TRACE(COMP_DOWN, "==========>%s()\n", __FUNCTION__);
+	RT_TRACE(COMP_DOWN, "==========>%s()\n", __func__);
 /* FIXME */
 	if (!netif_queue_stopped(dev))
 		netif_stop_queue(dev);
@@ -4941,7 +4941,7 @@ int rtl8192_down(struct net_device *dev)
 	rtl8192_halt_adapter(dev,false);
 	memset(&priv->ieee80211->current_network, 0 , offsetof(struct ieee80211_network, list));
 
-	RT_TRACE(COMP_DOWN, "<==========%s()\n", __FUNCTION__);
+	RT_TRACE(COMP_DOWN, "<==========%s()\n", __func__);
 
 		return 0;
 }
@@ -6825,7 +6825,7 @@ void EnableHWSecurityConfig8192(struct n
 		SECR_value &= ~SCR_RxDecEnable;
 	}
 
-	RT_TRACE(COMP_SEC,"%s:, hwsec:%d, pairwise_key:%d, SECR_value:%x\n", __FUNCTION__, \
+	RT_TRACE(COMP_SEC,"%s:, hwsec:%d, pairwise_key:%d, SECR_value:%x\n", __func__, \
 			ieee->hwsec_active, ieee->pairwise_key_type, SECR_value);
 	{
                 write_nic_byte(dev, SECR,  SECR_value);//SECR_value |  SCR_UseDK );
@@ -6854,7 +6854,7 @@ void setKey(	struct net_device *dev,
 		if(rtState == eRfOff){
 			if(priv->ieee80211->RfOffReason > RF_CHANGE_BY_IPS)
 			{
-				RT_TRACE(COMP_ERR, "%s(): RF is OFF.\n",__FUNCTION__);
+				RT_TRACE(COMP_ERR, "%s(): RF is OFF.\n",__func__);
 				//up(&priv->wx_sem);
 				return ;
 			}
@@ -6939,7 +6939,7 @@ bool NicIFEnableNIC(struct net_device* d
 
 	//YJ,add,091109
 	if (priv->up == 0){
-		RT_TRACE(COMP_ERR, "ERR!!! %s(): Driver is already down!\n",__FUNCTION__);
+		RT_TRACE(COMP_ERR, "ERR!!! %s(): Driver is already down!\n",__func__);
 		priv->bdisable_nic = false;  //YJ,add,091111
 		return false;
 	}
@@ -6947,11 +6947,11 @@ bool NicIFEnableNIC(struct net_device* d
 	//NicIFResetMemory(Adapter);
 
 	// <2> Enable Adapter
-	//printk("===========>%s()\n",__FUNCTION__);
+	//printk("===========>%s()\n",__func__);
 	//priv->bfirst_init = true;
 	init_status = rtl8192_adapter_start(dev);
 	if (init_status != RT_STATUS_SUCCESS) {
-		RT_TRACE(COMP_ERR,"ERR!!! %s(): initialization is failed!\n",__FUNCTION__);
+		RT_TRACE(COMP_ERR,"ERR!!! %s(): initialization is failed!\n",__func__);
 		priv->bdisable_nic = false;  //YJ,add,091111
 		return -1;
 	}
@@ -6962,7 +6962,7 @@ bool NicIFEnableNIC(struct net_device* d
 	// <3> Enable Interrupt
 	rtl8192_irq_enable(dev);
 	priv->bdisable_nic = false;
-	//RT_TRACE(COMP_PS,"<===========%s()\n",__FUNCTION__);
+	//RT_TRACE(COMP_PS,"<===========%s()\n",__func__);
 	return (init_status == RT_STATUS_SUCCESS) ? true:false;
 }
 bool NicIFDisableNIC(struct net_device* dev)
@@ -6971,7 +6971,7 @@ bool NicIFDisableNIC(struct net_device*
 	struct r8192_priv* priv = ieee80211_priv(dev);
 	u8 tmp_state = 0;
 	// <1> Disable Interrupt
-	//RT_TRACE(COMP_PS, "=========>%s()\n",__FUNCTION__);
+	//RT_TRACE(COMP_PS, "=========>%s()\n",__func__);
 	priv->bdisable_nic = true;	//YJ,move,091109
 	tmp_state = priv->ieee80211->state;
 
@@ -6985,7 +6985,7 @@ bool NicIFDisableNIC(struct net_device*
 	// <3> Disable Adapter
 	rtl8192_halt_adapter(dev, false);
 //	priv->bdisable_nic = true;
-	//RT_TRACE(COMP_PS, "<=========%s()\n",__FUNCTION__);
+	//RT_TRACE(COMP_PS, "<=========%s()\n",__func__);
 
 	return status;
 }
--- a/drivers/staging/rtl8192e/r8192E_dm.c
+++ b/drivers/staging/rtl8192e/r8192E_dm.c
@@ -664,7 +664,7 @@ static void dm_TXPowerTrackingCallback_T
 #endif
 //	bool rtStatus = true;
 	u32						delta=0;
-	RT_TRACE(COMP_POWER_TRACKING,"%s()\n",__FUNCTION__);
+	RT_TRACE(COMP_POWER_TRACKING,"%s()\n",__func__);
 //	write_nic_byte(dev, 0x1ba, 0);
 	write_nic_byte(dev, Pw_Track_Flag, 0);
 	write_nic_byte(dev, FW_Busy_Flag, 0);
@@ -1593,7 +1593,7 @@ static void dm_CheckTXPowerTracking_TSSI
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	static u32 tx_power_track_counter = 0;
-	RT_TRACE(COMP_POWER_TRACKING,"%s()\n",__FUNCTION__);
+	RT_TRACE(COMP_POWER_TRACKING,"%s()\n",__func__);
 	if(read_nic_byte(dev, 0x11e) ==1)
 		return;
 	if(!priv->btxpower_tracking)
@@ -2680,7 +2680,7 @@ static void dm_check_edca_turbo(
 	if(priv->ieee80211->pHTInfo->IOTAction & HT_IOT_ACT_DISABLE_EDCA_TURBO)
 		goto dm_CheckEdcaTurbo_EXIT;
 
-//	printk("========>%s():bis_any_nonbepkts is %d\n",__FUNCTION__,priv->bis_any_nonbepkts);
+//	printk("========>%s():bis_any_nonbepkts is %d\n",__func__,priv->bis_any_nonbepkts);
 	// Check the status for current condition.
 	if(!priv->ieee80211->bis_any_nonbepkts)
 	{
@@ -3491,7 +3491,7 @@ void dm_fsync_timer_callback(unsigned lo
 
 static void dm_StartHWFsync(struct net_device *dev)
 {
-	RT_TRACE(COMP_HALDM, "%s\n", __FUNCTION__);
+	RT_TRACE(COMP_HALDM, "%s\n", __func__);
 	write_nic_dword(dev, rOFDM0_RxDetector2, 0x465c12cf);
 	write_nic_byte(dev, 0xc3b, 0x41);
 }
@@ -3500,7 +3500,7 @@ static void dm_EndSWFsync(struct net_dev
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
-	RT_TRACE(COMP_HALDM, "%s\n", __FUNCTION__);
+	RT_TRACE(COMP_HALDM, "%s\n", __func__);
 	del_timer_sync(&(priv->fsync_timer));
 
 	// Let Register return to default value;
@@ -3530,7 +3530,7 @@ static void dm_StartSWFsync(struct net_d
 	u32 			rateIndex;
 	u32 			rateBitmap;
 
-	RT_TRACE(COMP_HALDM,"%s\n", __FUNCTION__);
+	RT_TRACE(COMP_HALDM,"%s\n", __func__);
 	// Initial rate record to zero, start to record.
 	priv->rate_record = 0;
 	// Initial contiune diff count to zero, start to record.
@@ -3567,7 +3567,7 @@ static void dm_StartSWFsync(struct net_d
 
 static void dm_EndHWFsync(struct net_device *dev)
 {
-	RT_TRACE(COMP_HALDM,"%s\n", __FUNCTION__);
+	RT_TRACE(COMP_HALDM,"%s\n", __func__);
 	write_nic_dword(dev, rOFDM0_RxDetector2, 0x465c52cd);
 	write_nic_byte(dev, 0xc3b, 0x49);
 
@@ -3813,7 +3813,7 @@ static void dm_dynamic_txpower(struct ne
 		txlowpower_threshold = TX_POWER_NEAR_FIELD_THRESH_LOW;
 	}
 
-//	printk("=======>%s(): txhipower_threshhold is %d,txlowpower_threshold is %d\n",__FUNCTION__,txhipower_threshhold,txlowpower_threshold);
+//	printk("=======>%s(): txhipower_threshhold is %d,txlowpower_threshold is %d\n",__func__,txhipower_threshhold,txlowpower_threshold);
 
 	RT_TRACE(COMP_TXAGC,"priv->undecorated_smoothed_pwdb = %ld \n" , priv->undecorated_smoothed_pwdb);
 
--- a/drivers/staging/rtl8192e/r8192E_wx.c
+++ b/drivers/staging/rtl8192e/r8192E_wx.c
@@ -165,7 +165,7 @@ static int r8192_wx_force_reset(struct n
 
 	down(&priv->wx_sem);
 
-	printk("%s(): force reset ! extra is %d\n",__FUNCTION__, *extra);
+	printk("%s(): force reset ! extra is %d\n",__func__, *extra);
 	priv->force_reset = *extra;
 	up(&priv->wx_sem);
 	return 0;
@@ -224,12 +224,12 @@ static int r8192_wx_set_mode(struct net_
 			if(rtState == eRfOff){
 				if(priv->ieee80211->RfOffReason > RF_CHANGE_BY_IPS)
 				{
-					RT_TRACE(COMP_ERR, "%s(): RF is OFF.\n",__FUNCTION__);
+					RT_TRACE(COMP_ERR, "%s(): RF is OFF.\n",__func__);
 					up(&priv->wx_sem);
 					return -1;
 				}
 				else{
-					RT_TRACE(COMP_ERR, "%s(): IPSLeave\n",__FUNCTION__);
+					RT_TRACE(COMP_ERR, "%s(): IPSLeave\n",__func__);
 					down(&priv->ieee80211->ips_sem);
 					IPSLeave(dev);
 					up(&priv->ieee80211->ips_sem);
@@ -412,12 +412,12 @@ static int r8192_wx_set_scan(struct net_
 			if(rtState == eRfOff){
 				if(priv->ieee80211->RfOffReason > RF_CHANGE_BY_IPS)
 				{
-					RT_TRACE(COMP_ERR, "%s(): RF is OFF.\n",__FUNCTION__);
+					RT_TRACE(COMP_ERR, "%s(): RF is OFF.\n",__func__);
 					up(&priv->wx_sem);
 					return -1;
 				}
 				else{
-					//RT_TRACE(COMP_PS, "%s(): IPSLeave\n",__FUNCTION__);
+					//RT_TRACE(COMP_PS, "%s(): IPSLeave\n",__func__);
 					down(&priv->ieee80211->ips_sem);
 					IPSLeave(dev);
 					up(&priv->ieee80211->ips_sem);
@@ -1013,7 +1013,7 @@ static int r8192_wx_set_auth(struct net_
                                         union iwreq_data *data, char *extra)
 {
 	int ret=0;
-	//printk("====>%s()\n", __FUNCTION__);
+	//printk("====>%s()\n", __func__);
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
 	if(priv->bHwRadioOff == true)
@@ -1029,7 +1029,7 @@ static int r8192_wx_set_mlme(struct net_
                                         struct iw_request_info *info,
                                         union iwreq_data *wrqu, char *extra)
 {
-	//printk("====>%s()\n", __FUNCTION__);
+	//printk("====>%s()\n", __func__);
 
 	int ret=0;
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -1047,7 +1047,7 @@ static int r8192_wx_set_gen_ie(struct ne
                                         struct iw_request_info *info,
                                         union iwreq_data *data, char *extra)
 {
-	   //printk("====>%s(), len:%d\n", __FUNCTION__, data->length);
+	   //printk("====>%s(), len:%d\n", __func__, data->length);
 	int ret=0;
         struct r8192_priv *priv = ieee80211_priv(dev);
 
@@ -1057,7 +1057,7 @@ static int r8192_wx_set_gen_ie(struct ne
         down(&priv->wx_sem);
         ret = ieee80211_wx_set_gen_ie(priv->ieee80211, extra, data->data.length);
         up(&priv->wx_sem);
-	//printk("<======%s(), ret:%d\n", __FUNCTION__, ret);
+	//printk("<======%s(), ret:%d\n", __func__, ret);
         return ret;
 }
 
@@ -1080,7 +1080,7 @@ static int r8192_wx_adapter_power_status
 	down(&priv->wx_sem);
 
 #ifdef ENABLE_LPS
-	RT_TRACE(COMP_POWER, "%s(): %s\n",__FUNCTION__, (*extra ==  6)?"DC power":"AC power");
+	RT_TRACE(COMP_POWER, "%s(): %s\n",__func__, (*extra ==  6)?"DC power":"AC power");
 	// ieee->ps shall not be set under DC mode, otherwise it conflict
 	// with Leisure power save mode setting.
 	//
--- a/drivers/staging/rtl8192e/r819xE_cmdpkt.c
+++ b/drivers/staging/rtl8192e/r819xE_cmdpkt.c
@@ -83,7 +83,7 @@ RT_STATUS cmpk_message_handle_tx(
         int i;
 
 	//spin_lock_irqsave(&priv->tx_lock,flags);
-	RT_TRACE(COMP_CMDPKT,"%s(),buffer_len is %d\n",__FUNCTION__,buffer_len);
+	RT_TRACE(COMP_CMDPKT,"%s(),buffer_len is %d\n",__func__,buffer_len);
 	firmware_init_param(dev);
 	//Fragmentation might be required
 	frag_threshold = pfirmware->cmdpacket_frag_thresold;
--- a/drivers/staging/rtl8192e/r819xE_phy.c
+++ b/drivers/staging/rtl8192e/r819xE_phy.c
@@ -2179,7 +2179,7 @@ RT_STATUS rtl8192_phy_checkBBAndRF(struc
 	WriteAddr[HW90_BLOCK_PHY0] = 0x900;
 	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
 	WriteAddr[HW90_BLOCK_RF] = 0x3;
-	RT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __FUNCTION__, CheckBlock);
+	RT_TRACE(COMP_PHY, "=======>%s(), CheckBlock:%d\n", __func__, CheckBlock);
 	for(i=0 ; i < CheckTimes ; i++)
 	{
 
@@ -2500,7 +2500,7 @@ void rtl8192_phy_setTxPower(struct net_d
 	case RF_8258:
 		break;
 	default:
-		RT_TRACE(COMP_ERR, "unknown rf chip in funtion %s()\n", __FUNCTION__);
+		RT_TRACE(COMP_ERR, "unknown rf chip in funtion %s()\n", __func__);
 		break;
 	}
 	return;
@@ -2727,7 +2727,7 @@ static u8 rtl8192_phy_SwChnlStepByStep(s
 //	u32		RfRetVal;
 //	u8		RetryCnt;
 
-	RT_TRACE(COMP_TRACE, "====>%s()====stage:%d, step:%d, channel:%d\n", __FUNCTION__, *stage, *step, channel);
+	RT_TRACE(COMP_TRACE, "====>%s()====stage:%d, step:%d, channel:%d\n", __func__, *stage, *step, channel);
 //	RT_ASSERT(IsLegalChannel(Adapter, channel), ("illegal channel: %d\n", channel));
 
 #ifdef ENABLE_DOT11D
@@ -2890,7 +2890,7 @@ void rtl8192_SwChnl_WorkItem(struct net_
 
 	RT_TRACE(COMP_TRACE, "==> SwChnlCallback819xUsbWorkItem()\n");
 
-	RT_TRACE(COMP_TRACE, "=====>--%s(), set chan:%d, priv:%p\n", __FUNCTION__, priv->chan, priv);
+	RT_TRACE(COMP_TRACE, "=====>--%s(), set chan:%d, priv:%p\n", __func__, priv->chan, priv);
 
 	rtl8192_phy_FinishSwChnlNow(dev , priv->chan);
 
@@ -2908,7 +2908,7 @@ void rtl8192_SwChnl_WorkItem(struct net_
 u8 rtl8192_phy_SwChnl(struct net_device* dev, u8 channel)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
-	RT_TRACE(COMP_PHY, "=====>%s()\n", __FUNCTION__);
+	RT_TRACE(COMP_PHY, "=====>%s()\n", __func__);
         if(!priv->up)
 		return false;
 	if(priv->SwChnlInProgress)

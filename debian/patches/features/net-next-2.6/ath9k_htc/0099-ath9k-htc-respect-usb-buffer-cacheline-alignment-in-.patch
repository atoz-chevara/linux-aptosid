From 0fa35a5836df2b8f285d6f53dfb4316c34621f88 Mon Sep 17 00:00:00 2001
From: Ming Lei <tom.leiming@gmail.com>
Date: Tue, 13 Apr 2010 00:29:15 +0800
Subject: [PATCH 099/267] ath9k-htc:respect usb buffer cacheline alignment in reg out path

In ath9k-htc register out path, ath9k-htc will pass skb->data into
usb hcd and usb hcd will do dma mapping and unmapping to the buffer
pointed by skb->data, so we should pass a cache-line aligned address.

This patch replace __dev_alloc_skb with alloc_skb to make skb->data
pointed to a cacheline aligned address simply since ath9k-htc does not
skb_push on the skb and pass it to mac80211, also use kfree_skb to free
the skb allocated by alloc_skb(we can use kfree_skb safely in hardirq
context since skb->destructor is NULL always in the path).

Signed-off-by: Sujith <Sujith.Manoharan@atheros.com>
Signed-off-by: Ming Lei <tom.leiming@gmail.com>
Signed-off-by: John W. Linville <linville@tuxdriver.com>
---
 drivers/net/wireless/ath/ath9k/hif_usb.c |    2 +-
 drivers/net/wireless/ath/ath9k/htc_hst.c |   21 ++++++++++++---------
 drivers/net/wireless/ath/ath9k/wmi.c     |    6 +++---
 3 files changed, 16 insertions(+), 13 deletions(-)

--- a/drivers/net/wireless/ath/ath9k/hif_usb.c
+++ b/drivers/net/wireless/ath/ath9k/hif_usb.c
@@ -53,7 +53,7 @@ static void hif_usb_regout_cb(struct urb
 
 	return;
 free:
-	dev_kfree_skb_any(cmd->skb);
+	kfree_skb(cmd->skb);
 	kfree(cmd);
 }
 
--- a/drivers/net/wireless/ath/ath9k/htc_hst.c
+++ b/drivers/net/wireless/ath/ath9k/htc_hst.c
@@ -146,7 +146,7 @@ static int htc_config_pipe_credits(struc
 	struct htc_config_pipe_msg *cp_msg;
 	int ret, time_left;
 
-	skb = dev_alloc_skb(50 + sizeof(struct htc_frame_hdr));
+	skb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);
 	if (!skb) {
 		dev_err(target->dev, "failed to allocate send buffer\n");
 		return -ENOMEM;
@@ -174,7 +174,7 @@ static int htc_config_pipe_credits(struc
 
 	return 0;
 err:
-	dev_kfree_skb(skb);
+	kfree_skb(skb);
 	return -EINVAL;
 }
 
@@ -184,7 +184,7 @@ static int htc_setup_complete(struct htc
 	struct htc_comp_msg *comp_msg;
 	int ret = 0, time_left;
 
-	skb = dev_alloc_skb(50 + sizeof(struct htc_frame_hdr));
+	skb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);
 	if (!skb) {
 		dev_err(target->dev, "failed to allocate send buffer\n");
 		return -ENOMEM;
@@ -210,7 +210,7 @@ static int htc_setup_complete(struct htc
 	return 0;
 
 err:
-	dev_kfree_skb(skb);
+	kfree_skb(skb);
 	return -EINVAL;
 }
 
@@ -250,8 +250,8 @@ int htc_connect_service(struct htc_targe
 	endpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);
 	endpoint->ep_callbacks = service_connreq->ep_callbacks;
 
-	skb = dev_alloc_skb(sizeof(struct htc_conn_svc_msg) +
-			    sizeof(struct htc_frame_hdr));
+	skb = alloc_skb(sizeof(struct htc_conn_svc_msg) +
+			    sizeof(struct htc_frame_hdr), GFP_ATOMIC);
 	if (!skb) {
 		dev_err(target->dev, "Failed to allocate buf to send"
 			"service connect req\n");
@@ -282,7 +282,7 @@ int htc_connect_service(struct htc_targe
 	*conn_rsp_epid = target->conn_rsp_epid;
 	return 0;
 err:
-	dev_kfree_skb(skb);
+	kfree_skb(skb);
 	return ret;
 }
 
@@ -321,7 +321,7 @@ void ath9k_htc_txcompletion_cb(struct ht
 			       struct sk_buff *skb, bool txok)
 {
 	struct htc_endpoint *endpoint;
-	struct htc_frame_hdr *htc_hdr;
+	struct htc_frame_hdr *htc_hdr = NULL;
 
 	if (htc_handle->htc_flags & HTC_OP_CONFIG_PIPE_CREDITS) {
 		complete(&htc_handle->cmd_wait);
@@ -349,7 +349,10 @@ void ath9k_htc_txcompletion_cb(struct ht
 	return;
 ret:
 	/* HTC-generated packets are freed here. */
-	dev_kfree_skb_any(skb);
+	if (htc_hdr && htc_hdr->endpoint_id != ENDPOINT0)
+		dev_kfree_skb_any(skb);
+	else
+		kfree_skb(skb);
 }
 
 /*
--- a/drivers/net/wireless/ath/ath9k/wmi.c
+++ b/drivers/net/wireless/ath/ath9k/wmi.c
@@ -213,7 +213,7 @@ free_skb:
 static void ath9k_wmi_ctrl_tx(void *priv, struct sk_buff *skb,
 			      enum htc_endpoint_id epid, bool txok)
 {
-	dev_kfree_skb_any(skb);
+	kfree_skb(skb);
 }
 
 int ath9k_wmi_connect(struct htc_target *htc, struct wmi *wmi,
@@ -269,7 +269,7 @@ int ath9k_wmi_cmd(struct wmi *wmi, enum
 	if (!wmi)
 		return -EINVAL;
 
-	skb = dev_alloc_skb(headroom + cmd_len);
+	skb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);
 	if (!skb)
 		return -ENOMEM;
 
@@ -313,7 +313,7 @@ out:
 	ath_print(common, ATH_DBG_WMI,
 		  "WMI failure for: %s\n", wmi_cmd_to_name(cmd_id));
 	mutex_unlock(&wmi->op_mutex);
-	dev_kfree_skb_any(skb);
+	kfree_skb(skb);
 
 	return ret;
 }

rtl8192su: __FUNCTION__ is gcc-specific, use __func__

Signed-off-by: Stefan Lippers-Hollmann <s.l-h@gmx.de>

--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_crypt_ccmp.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_crypt_ccmp.c
@@ -445,7 +445,7 @@ static char * ieee80211_ccmp_print_stats
 
 void ieee80211_ccmp_null(void)
 {
-//    printk("============>%s()\n", __FUNCTION__);
+//    printk("============>%s()\n", __func__);
 	return;
 }
 
--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_crypt_tkip.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_crypt_tkip.c
@@ -774,6 +774,6 @@ void __exit ieee80211_crypto_tkip_exit(v
 
 void ieee80211_tkip_null(void)
 {
-//    printk("============>%s()\n", __FUNCTION__);
+//    printk("============>%s()\n", __func__);
         return;
 }
--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_crypt_wep.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_crypt_wep.c
@@ -291,6 +291,6 @@ void __exit ieee80211_crypto_wep_exit(vo
 
 void ieee80211_wep_null(void)
 {
-//	printk("============>%s()\n", __FUNCTION__);
+//	printk("============>%s()\n", __func__);
         return;
 }
--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_rx.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_rx.c
@@ -512,7 +512,7 @@ void ieee80211_indicate_packets(struct i
 	u8 i = 0 , j=0;
 	u16 ethertype;
 //	if(index > 1)
-//		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): hahahahhhh, We indicate packet from reorder list, index is %u\n",__FUNCTION__,index);
+//		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): hahahahhhh, We indicate packet from reorder list, index is %u\n",__func__,index);
 	for(j = 0; j<index; j++)
 	{
 //added by amy for reorder
@@ -573,7 +573,7 @@ void RxReorderIndicatePacket( struct iee
 	u16			WinEnd = (pTS->RxIndicateSeq + WinSize -1)%4096;
 	u8			index = 0;
 	bool			bMatchWinStart = false, bPktInBuf = false;
-	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): Seq is %d,pTS->RxIndicateSeq is %d, WinSize is %d\n",__FUNCTION__,SeqNum,pTS->RxIndicateSeq,WinSize);
+	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): Seq is %d,pTS->RxIndicateSeq is %d, WinSize is %d\n",__func__,SeqNum,pTS->RxIndicateSeq,WinSize);
 	/* Rx Reorder initialize condition.*/
 	if(pTS->RxIndicateSeq == 0xffff) {
 		pTS->RxIndicateSeq = SeqNum;
@@ -626,11 +626,11 @@ void RxReorderIndicatePacket( struct iee
 		IEEE80211_DEBUG(IEEE80211_DL_REORDER, "Packets indication!! IndicateSeq: %d, NewSeq: %d\n",\
 				pTS->RxIndicateSeq, SeqNum);
 		prxbIndicateArray[0] = prxb;
-//		printk("========================>%s(): SeqNum is %d\n",__FUNCTION__,SeqNum);
+//		printk("========================>%s(): SeqNum is %d\n",__func__,SeqNum);
 		index = 1;
 	} else {
 		/* Current packet is going to be inserted into pending list.*/
-		//IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): We RX no ordered packed, insert to orderd list\n",__FUNCTION__);
+		//IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): We RX no ordered packed, insert to orderd list\n",__func__);
 		if(!list_empty(&ieee->RxReorder_Unused_List)) {
 			pReorderEntry = (PRX_REORDER_ENTRY)list_entry(ieee->RxReorder_Unused_List.next,RX_REORDER_ENTRY,List);
 			list_del_init(&pReorderEntry->List);
@@ -638,12 +638,12 @@ void RxReorderIndicatePacket( struct iee
 			/* Make a reorder entry and insert into a the packet list.*/
 			pReorderEntry->SeqNum = SeqNum;
 			pReorderEntry->prxb = prxb;
-	//		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): pREorderEntry->SeqNum is %d\n",__FUNCTION__,pReorderEntry->SeqNum);
+	//		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): pREorderEntry->SeqNum is %d\n",__func__,pReorderEntry->SeqNum);
 
 #if 1
 			if(!AddReorderEntry(pTS, pReorderEntry)) {
 				IEEE80211_DEBUG(IEEE80211_DL_REORDER, "%s(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n",
-					__FUNCTION__, pTS->RxIndicateSeq, SeqNum);
+					__func__, pTS->RxIndicateSeq, SeqNum);
 				list_add_tail(&pReorderEntry->List,&ieee->RxReorder_Unused_List);
 				{
 					int i;
@@ -679,7 +679,7 @@ void RxReorderIndicatePacket( struct iee
 
 	/* Check if there is any packet need indicate.*/
 	while(!list_empty(&pTS->RxPendingPktList)) {
-		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): start RREORDER indicate\n",__FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): start RREORDER indicate\n",__func__);
 #if 1
 		pReorderEntry = (PRX_REORDER_ENTRY)list_entry(pTS->RxPendingPktList.prev,RX_REORDER_ENTRY,List);
 		if( SN_LESS(pReorderEntry->SeqNum, pTS->RxIndicateSeq) ||
@@ -699,7 +699,7 @@ void RxReorderIndicatePacket( struct iee
 
 			IEEE80211_DEBUG(IEEE80211_DL_REORDER,"Packets indication!! IndicateSeq: %d, NewSeq: %d\n",pTS->RxIndicateSeq, SeqNum);
 			prxbIndicateArray[index] = pReorderEntry->prxb;
-		//	printk("========================>%s(): pReorderEntry->SeqNum is %d\n",__FUNCTION__,pReorderEntry->SeqNum);
+		//	printk("========================>%s(): pReorderEntry->SeqNum is %d\n",__func__,pReorderEntry->SeqNum);
 			index++;
 
 			list_add_tail(&pReorderEntry->List,&ieee->RxReorder_Unused_List);
@@ -732,7 +732,7 @@ void RxReorderIndicatePacket( struct iee
 #if 1
 	if(bPktInBuf && pTS->RxTimeoutIndicateSeq==0xffff) {
 		// Set new pending timer.
-		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): SET rx timeout timer\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): SET rx timeout timer\n", __func__);
 		pTS->RxTimeoutIndicateSeq = pTS->RxIndicateSeq;
 		mod_timer(&pTS->RxPktPendingTimer,  jiffies + MSECS(pHTInfo->RxReorderPendingTime));
 	}
@@ -804,8 +804,8 @@ u8 parse_subframe(struct sk_buff *skb,
 
 			if(skb->len<(ETHERNET_HEADER_SIZE + nSubframe_Length)) {
 				printk("%s: A-MSDU parse error!! pRfd->nTotalSubframe : %d\n",\
-						__FUNCTION__,rxb->nr_subframes);
-				printk("%s: A-MSDU parse error!! Subframe Length: %d\n",__FUNCTION__, nSubframe_Length);
+						__func__,rxb->nr_subframes);
+				printk("%s: A-MSDU parse error!! Subframe Length: %d\n",__func__, nSubframe_Length);
 				printk("nRemain_Length is %d and nSubframe_Length is : %d\n",skb->len,nSubframe_Length);
 				printk("The Packet SeqNum is %d\n",SeqNum);
 				return 0;
@@ -958,7 +958,7 @@ int ieee80211_rtl_rx(struct ieee80211_de
 	else
 	{
 		PRX_TS_RECORD pRxTS = NULL;
-			//IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): QOS ENABLE AND RECEIVE QOS DATA , we will get Ts, tid:%d\n",__FUNCTION__, tid);
+			//IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): QOS ENABLE AND RECEIVE QOS DATA , we will get Ts, tid:%d\n",__func__, tid);
 #if 1
 		if(GetTs(
 				ieee,
@@ -969,7 +969,7 @@ int ieee80211_rtl_rx(struct ieee80211_de
 				true))
 		{
 
-		//	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): pRxTS->RxLastFragNum is %d,frag is %d,pRxTS->RxLastSeqNum is %d,seq is %d\n",__FUNCTION__,pRxTS->RxLastFragNum,frag,pRxTS->RxLastSeqNum,WLAN_GET_SEQ_SEQ(sc));
+		//	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): pRxTS->RxLastFragNum is %d,frag is %d,pRxTS->RxLastSeqNum is %d,seq is %d\n",__func__,pRxTS->RxLastFragNum,frag,pRxTS->RxLastSeqNum,WLAN_GET_SEQ_SEQ(sc));
 			if( 	(fc & (1<<11))  &&
 					(frag == pRxTS->RxLastFragNum) &&
 					(WLAN_GET_SEQ_SEQ(sc) == pRxTS->RxLastSeqNum)	)
@@ -984,7 +984,7 @@ int ieee80211_rtl_rx(struct ieee80211_de
 		}
 		else
 		{
-			IEEE80211_DEBUG(IEEE80211_DL_ERR, "%s(): No TS!! Skip the check!!\n",__FUNCTION__);
+			IEEE80211_DEBUG(IEEE80211_DL_ERR, "%s(): No TS!! Skip the check!!\n",__func__);
 			goto rx_dropped;
 		}
 	}
@@ -1194,7 +1194,7 @@ int ieee80211_rtl_rx(struct ieee80211_de
 	rxb = kmalloc(sizeof(struct ieee80211_rxb), GFP_ATOMIC);
 	if(rxb == NULL)
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_ERR,"%s(): kmalloc rxb error\n",__FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR,"%s(): kmalloc rxb error\n",__func__);
 		goto rx_dropped;
 	}
 	/* to parse amsdu packets */
@@ -1260,7 +1260,7 @@ int ieee80211_rtl_rx(struct ieee80211_de
 	}
 	else
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): REORDER ENABLE AND PTS not NULL, and we will enter RxReorderIndicatePacket()\n",__FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_REORDER,"%s(): REORDER ENABLE AND PTS not NULL, and we will enter RxReorderIndicatePacket()\n",__func__);
 		RxReorderIndicatePacket(ieee, rxb, pTS, SeqNum);
 	}
 #ifndef JOHN_NOCPY
@@ -1833,7 +1833,7 @@ int ieee80211_parse_info_param(struct ie
 				info_element->data[1] == 0x13 &&
 				info_element->data[2] == 0x74))
 			{
-			//	printk("========>%s(): athros AP is exist\n",__FUNCTION__);
+			//	printk("========>%s(): athros AP is exist\n",__func__);
 				network->atheros_cap_exist = true;
 			}
 			else
@@ -2270,7 +2270,7 @@ static inline void update_network(struct
 	old_param = dst->qos_data.param_count;
 	if(dst->flags & NETWORK_HAS_QOS_MASK){
         //not update QOS paramter in beacon, as most AP will set all these parameter to 0.//WB
-	//	printk("====>%s(), aifs:%x, %x\n", __FUNCTION__, dst->qos_data.parameters.aifs[0], src->qos_data.parameters.aifs[0]);
+	//	printk("====>%s(), aifs:%x, %x\n", __func__, dst->qos_data.parameters.aifs[0], src->qos_data.parameters.aifs[0]);
 	//	memcpy(&dst->qos_data, &src->qos_data,
 	//		sizeof(struct ieee80211_qos_data));
 	}
--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c
@@ -276,7 +276,7 @@ inline void softmac_mgmt_xmit(struct sk_
 			/* as for the completion function, it does not need
 			 * to check it any more.
 			 * */
-			printk("%s():insert to waitqueue!\n",__FUNCTION__);
+			printk("%s():insert to waitqueue!\n",__func__);
 			skb_queue_tail(&ieee->skb_waitQ[tcb_desc->queue_index], skb);
 		} else {
 			//printk("TX packet!\n");
@@ -300,7 +300,7 @@ inline void softmac_ps_mgmt_xmit(struct
 	tcb_desc->RATRIndex = 7;
 	tcb_desc->bTxDisableRateFallBack = 1;
 	tcb_desc->bTxUseDriverAssingedRate = 1;
-	//printk("=============>%s()\n", __FUNCTION__);
+	//printk("=============>%s()\n", __func__);
 	if(single){
 
 		header->seq_ctrl = cpu_to_le16(ieee->seq_ctrl[0] << 4);
@@ -679,7 +679,7 @@ inline struct sk_buff *ieee80211_authent
 		auth->algorithm = WLAN_AUTH_SHARED_KEY;
 	else if(ieee->auth_mode == 2)
 		auth->algorithm = WLAN_AUTH_OPEN;//0x80;
-	IEEE80211_DEBUG_MGMT("=================>%s():auth->algorithm is %d\n",__FUNCTION__,auth->algorithm);
+	IEEE80211_DEBUG_MGMT("=================>%s():auth->algorithm is %d\n",__func__,auth->algorithm);
 	auth->transaction = cpu_to_le16(ieee->associate_seq);
 	ieee->associate_seq++;
 
@@ -1215,7 +1215,7 @@ inline struct sk_buff *ieee80211_associa
 			memcpy(tag, realtek_ie_buf,realtek_ie_len -2 );
 		}
 	}
-//	printk("<=====%s(), %p, %p\n", __FUNCTION__, ieee->dev, ieee->dev->dev_addr);
+//	printk("<=====%s(), %p, %p\n", __func__, ieee->dev, ieee->dev->dev_addr);
 //	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA, skb->data, skb->len);
 	return skb;
 }
@@ -1403,7 +1403,7 @@ void ieee80211_associate_procedure_wq(st
 		ieee->data_hard_stop(ieee->dev);
 
 	ieee80211_stop_scan(ieee);
-	IEEE80211_DEBUG_MGMT("===>%s(), chan:%d\n", __FUNCTION__, ieee->current_network.channel);
+	IEEE80211_DEBUG_MGMT("===>%s(), chan:%d\n", __func__, ieee->current_network.channel);
 	//ieee->set_chan(ieee->dev, ieee->current_network.channel);
 	HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
 
@@ -2657,7 +2657,7 @@ void ieee80211_start_protocol(struct iee
 
 	if (ieee->current_network.beacon_interval == 0)
 		ieee->current_network.beacon_interval = 100;
-//	IEEE80211_DEBUG_MGMT("===>%s(), chan:%d\n", __FUNCTION__, ieee->current_network.channel);
+//	IEEE80211_DEBUG_MGMT("===>%s(), chan:%d\n", __func__, ieee->current_network.channel);
 //	ieee->set_chan(ieee->dev,ieee->current_network.channel);
 
        	for(i = 0; i < 17; i++) {
--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_tx.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_tx.c
@@ -188,7 +188,7 @@ int ieee80211_encrypt_fragment(
 
 	if (!(crypt && crypt->ops))
 	{
-		printk("=========>%s(), crypt is null\n", __FUNCTION__);
+		printk("=========>%s(), crypt is null\n", __func__);
 		return -1;
 	}
 #ifdef CONFIG_IEEE80211_CRYPT_TKIP
--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_wx.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_wx.c
@@ -708,7 +708,7 @@ int ieee80211_wx_set_auth(struct ieee802
 		break;
 
 	case IW_AUTH_80211_AUTH_ALG:
-		//printk("======>%s():data->value is %d\n",__FUNCTION__,data->value);
+		//printk("======>%s():data->value is %d\n",__func__,data->value);
 	//	ieee->open_wep = (data->value&IW_AUTH_ALG_OPEN_SYSTEM)?1:0;
 		if(data->value & IW_AUTH_ALG_SHARED_KEY){
 			ieee->open_wep = 0;
--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_BAProc.c
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_BAProc.c
@@ -113,7 +113,7 @@ static struct sk_buff* ieee80211_ADDBA(s
 	u16 tmp = 0;
 	u16 len = ieee->tx_headroom + 9;
 	//category(1) + action field(1) + Dialog Token(1) + BA Parameter Set(2) +  BA Timeout Value(2) +  BA Start SeqCtrl(2)(or StatusCode(2))
-	IEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "========>%s(), frame(%d) sentd to:%pM, ieee->dev:%p\n", __FUNCTION__, type, Dst, ieee->dev);
+	IEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "========>%s(), frame(%d) sentd to:%pM, ieee->dev:%p\n", __func__, type, Dst, ieee->dev);
 	if (pBA == NULL||ieee == NULL)
 	{
 		IEEE80211_DEBUG(IEEE80211_DL_ERR, "pBA(%p) is NULL or ieee(%p) is NULL\n", pBA, ieee);
@@ -200,7 +200,7 @@ static struct sk_buff* ieee80211_DELBA(
 	u16 len = 6 + ieee->tx_headroom;
 
 	if (net_ratelimit())
-	IEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "========>%s(), ReasonCode(%d) sentd to:%pM\n", __FUNCTION__, ReasonCode, dst);
+	IEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "========>%s(), ReasonCode(%d) sentd to:%pM\n", __func__, ReasonCode, dst);
 
 	memset(&DelbaParamSet, 0, 2);
 
@@ -239,7 +239,7 @@ static struct sk_buff* ieee80211_DELBA(
 
 	IEEE80211_DEBUG_DATA(IEEE80211_DL_DATA|IEEE80211_DL_BA, skb->data, skb->len);
 	if (net_ratelimit())
-	IEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "<=====%s()\n", __FUNCTION__);
+	IEEE80211_DEBUG(IEEE80211_DL_TRACE | IEEE80211_DL_BA, "<=====%s()\n", __func__);
 	return skb;
 }
 
@@ -264,7 +264,7 @@ void ieee80211_send_ADDBAReq(struct ieee
 	}
 	else
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __func__);
 	}
 	return;
 }
@@ -288,7 +288,7 @@ void ieee80211_send_ADDBARsp(struct ieee
 	}
 	else
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __func__);
 	}
 
 	return;
@@ -315,7 +315,7 @@ void ieee80211_send_DELBA(struct ieee802
 	}
 	else
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "alloc skb error in function %s()\n", __func__);
 	}
 	return ;
 }
@@ -379,7 +379,7 @@ int ieee80211_rx_ADDBAReq( struct ieee80
 			true)	)
 	{
 		rc = ADDBA_STATUS_REFUSED;
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "can't get TS in %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "can't get TS in %s()\n", __func__);
 		goto OnADDBAReq_Fail;
 	}
 	pBA = &pTS->RxAdmittedBARecord;
@@ -390,7 +390,7 @@ int ieee80211_rx_ADDBAReq( struct ieee80
 	if(pBaParamSet->field.BAPolicy == BA_POLICY_DELAYED)
 	{
 		rc = ADDBA_STATUS_INVALID_PARAM;
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "BA Policy is not correct in %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "BA Policy is not correct in %s()\n", __func__);
 		goto OnADDBAReq_Fail;
 	}
 		// Admit the ADDBA Request
@@ -482,7 +482,7 @@ int ieee80211_rx_ADDBARsp( struct ieee80
 			TX_DIR,
 			false)	)
 	{
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "can't get TS in %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "can't get TS in %s()\n", __func__);
 		ReasonCode = DELBA_REASON_UNKNOWN_BA;
 		goto OnADDBARsp_Reject;
 	}
@@ -609,7 +609,7 @@ int ieee80211_rx_DELBA(struct ieee80211_
 				RX_DIR,
 				false)	)
 		{
-			IEEE80211_DEBUG(IEEE80211_DL_ERR,  "can't get TS for RXTS in %s()\n", __FUNCTION__);
+			IEEE80211_DEBUG(IEEE80211_DL_ERR,  "can't get TS for RXTS in %s()\n", __func__);
 			return -1;
 		}
 
@@ -627,7 +627,7 @@ int ieee80211_rx_DELBA(struct ieee80211_
 			TX_DIR,
 			false)	)
 		{
-			IEEE80211_DEBUG(IEEE80211_DL_ERR,  "can't get TS for TXTS in %s()\n", __FUNCTION__);
+			IEEE80211_DEBUG(IEEE80211_DL_ERR,  "can't get TS for TXTS in %s()\n", __func__);
 			return -1;
 		}
 
--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c
@@ -122,7 +122,7 @@ void HTDebugHTCapability(u8* CapIE, u8*
 	if(!memcmp(CapIE, EWC11NHTCap, sizeof(EWC11NHTCap)))
 	{
 		//EWC IE
-		IEEE80211_DEBUG(IEEE80211_DL_HT, "EWC IE in %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_HT, "EWC IE in %s()\n", __func__);
 		pCapELE = (PHT_CAPABILITY_ELE)(&CapIE[4]);
 	}else
 		pCapELE = (PHT_CAPABILITY_ELE)(&CapIE[0]);
@@ -159,7 +159,7 @@ void HTDebugHTInfo(u8*	InfoIE, u8* Title
 	if(!memcmp(InfoIE, EWC11NHTInfo, sizeof(EWC11NHTInfo)))
 	{
 		// Not EWC IE
-		IEEE80211_DEBUG(IEEE80211_DL_HT, "EWC IE in %s()\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_HT, "EWC IE in %s()\n", __func__);
 		pHTInfoEle = (PHT_INFORMATION_ELE)(&InfoIE[4]);
 	}else
 		pHTInfoEle = (PHT_INFORMATION_ELE)(&InfoIE[0]);
@@ -558,7 +558,7 @@ u8 HTIOTActIsForcedCTS2Self(struct ieee8
 u8 HTIOTActIsForcedRTSCTS(struct ieee80211_device *ieee, struct ieee80211_network *network)
 {
 	u8	retValue = 0;
-	//printk("============>%s(), %d\n", __FUNCTION__, network->realtek_cap_exit);
+	//printk("============>%s(), %d\n", __func__, network->realtek_cap_exit);
 	// Force protection
 	if(ieee->pHTInfo->bCurrentHTSupport)
 	{
@@ -1377,7 +1377,7 @@ void HTInitializeHTInfo(struct ieee80211
 	//
 	// These parameters will be reset when receiving deauthentication packet
 	//
-	IEEE80211_DEBUG(IEEE80211_DL_HT, "===========>%s()\n", __FUNCTION__);
+	IEEE80211_DEBUG(IEEE80211_DL_HT, "===========>%s()\n", __func__);
 	pHTInfo->bCurrentHTSupport = false;
 
 	// 40MHz channel support
@@ -1477,7 +1477,7 @@ void HTResetSelfAndSavePeerSetting(struc
 	//
 	//  Save Peer Setting before Association
 	//
-	IEEE80211_DEBUG(IEEE80211_DL_HT, "==============>%s()\n", __FUNCTION__);
+	IEEE80211_DEBUG(IEEE80211_DL_HT, "==============>%s()\n", __func__);
 	/*unmark bEnableHT flag here is the same reason why unmarked in function ieee80211_softmac_new_net. WB 2008.09.10*/
 //	if( pHTInfo->bEnableHT &&  pNetwork->bssht.bdSupportHT)
 	if (pNetwork->bssht.bdSupportHT)
@@ -1742,7 +1742,7 @@ void HTSetConnectBwModeCallback(struct i
 {
 	PRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;
 
-	IEEE80211_DEBUG(IEEE80211_DL_HT, "======>%s()\n", __FUNCTION__);
+	IEEE80211_DEBUG(IEEE80211_DL_HT, "======>%s()\n", __func__);
 	if(pHTInfo->bCurBW40MHz)
 	{
 		if(pHTInfo->CurSTAExtChnlOffset==HT_EXTCHNL_OFFSET_UPPER)
--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_TSProc.c
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_TSProc.c
@@ -38,7 +38,7 @@ void RxPktPendingTimeout(unsigned long d
 
 	spin_lock_irqsave(&(ieee->reorder_spinlock), flags);
 	//PlatformAcquireSpinLock(Adapter, RT_RX_SPINLOCK);
-	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"==================>%s()\n",__FUNCTION__);
+	IEEE80211_DEBUG(IEEE80211_DL_REORDER,"==================>%s()\n",__func__);
 	if(pRxTs->RxTimeoutIndicateSeq != 0xffff)
 	{
 		// Indicate the pending packets sequentially according to SeqNum until meet the gap.
@@ -144,7 +144,7 @@ void TSInitialize(struct ieee80211_devic
 	PRX_TS_RECORD		pRxTS  = ieee->RxTsRecord;
 	PRX_REORDER_ENTRY	pRxReorderEntry = ieee->RxReorderEntry;
 	u8				count = 0;
-	IEEE80211_DEBUG(IEEE80211_DL_TS, "==========>%s()\n", __FUNCTION__);
+	IEEE80211_DEBUG(IEEE80211_DL_TS, "==========>%s()\n", __func__);
 	// Initialize Tx TS related info.
 	INIT_LIST_HEAD(&ieee->Tx_TS_Admit_List);
 	INIT_LIST_HEAD(&ieee->Tx_TS_Pending_List);
@@ -363,7 +363,7 @@ bool GetTs(
 		// In WMM case: we use 4 TID only
 		if (!IsACValid(TID))
 		{
-			IEEE80211_DEBUG(IEEE80211_DL_ERR, " in %s(), TID(%d) is not valid\n", __FUNCTION__, TID);
+			IEEE80211_DEBUG(IEEE80211_DL_ERR, " in %s(), TID(%d) is not valid\n", __func__, TID);
 			return false;
 		}
 
@@ -465,7 +465,7 @@ bool GetTs(
 			}
 			else
 			{
-				IEEE80211_DEBUG(IEEE80211_DL_ERR, "in function %s() There is not enough TS record to be used!!", __FUNCTION__);
+				IEEE80211_DEBUG(IEEE80211_DL_ERR, "in function %s() There is not enough TS record to be used!!", __func__);
 				return false;
 			}
 		}
@@ -624,5 +624,5 @@ void TsStartAddBaProcess(struct ieee8021
 		}
 	}
 	else
-		IEEE80211_DEBUG(IEEE80211_DL_ERR, "%s()==>BA timer is already added\n", __FUNCTION__);
+		IEEE80211_DEBUG(IEEE80211_DL_ERR, "%s()==>BA timer is already added\n", __func__);
 }
--- a/drivers/staging/rtl8192su/r8192S_phy.c
+++ b/drivers/staging/rtl8192su/r8192S_phy.c
@@ -191,7 +191,7 @@ phy_SetUsbBBReg(struct net_device* dev,u
 	}
 
 	priv->bChangeBBInProgress = true;
-	//printk("**************%s: RegAddr:%x Data:%x\n", __FUNCTION__,RegAddr, Data);
+	//printk("**************%s: RegAddr:%x Data:%x\n", __func__,RegAddr, Data);
 	write_nic_dword(dev, RegAddr, Data);
 
 	priv->bChangeBBInProgress = false;
@@ -399,7 +399,7 @@ u32 rtl8192_QueryBBReg(struct net_device
 
 		if((RegAddr & 0x03) != 0)
 		{
-			printk("%s: Not DWORD alignment!!\n", __FUNCTION__);
+			printk("%s: Not DWORD alignment!!\n", __func__);
 			return 0;
 		}
 
@@ -455,7 +455,7 @@ void rtl8192_setBBreg(struct net_device*
 	{
 		if((RegAddr & 0x03) != 0)
 		{
-			printk("%s: Not DWORD alignment!!\n", __FUNCTION__);
+			printk("%s: Not DWORD alignment!!\n", __func__);
 			return;
 		}
 
@@ -2810,7 +2810,7 @@ phy_SwChnlStepByStep(
 
 	//RT_ASSERT((dev != NULL), ("Adapter should not be NULL\n"));
 	//RT_ASSERT(IsLegalChannel(dev, channel), ("illegal channel: %d\n", channel));
-	RT_TRACE(COMP_CH, "===========>%s(), channel:%d, stage:%d, step:%d\n", __FUNCTION__, channel, *stage, *step);
+	RT_TRACE(COMP_CH, "===========>%s(), channel:%d, stage:%d, step:%d\n", __func__, channel, *stage, *step);
 	//RT_ASSERT((pHalData != NULL), ("pHalData should not be NULL\n"));
 	if (!IsLegalChannel(priv->ieee80211, channel))
 	{
@@ -2943,7 +2943,7 @@ phy_SwChnlStepByStep(
 
 	(*delay)=CurrentCmd->msDelay;
 	(*step)++;
-	RT_TRACE(COMP_CH, "<===========%s(), channel:%d, stage:%d, step:%d\n", __FUNCTION__, channel, *stage, *step);
+	RT_TRACE(COMP_CH, "<===========%s(), channel:%d, stage:%d, step:%d\n", __func__, channel, *stage, *step);
 	return FALSE;
 }
 
--- a/drivers/staging/rtl8192su/r8192U.h
+++ b/drivers/staging/rtl8192su/r8192U.h
@@ -162,7 +162,7 @@ do { if(rt_global_debug_component & comp
 #define assert(expr) \
         if (!(expr)) {                                  \
                 printk( "Assertion failed! %s,%s,%s,line=%d\n", \
-                #expr,__FILE__,__FUNCTION__,__LINE__);          \
+                #expr,__FILE__,__func__,__LINE__);          \
         }
 //wb added to debug out data buf
 //if you want print DATA buffer related BA, please set ieee80211_debug_level to DATA|BA
@@ -171,7 +171,7 @@ do { if(rt_global_debug_component & comp
                 {       \
                         int i;                                  \
                         u8* pdata = (u8*) data;                 \
-                        printk(KERN_DEBUG RTL819xU_MODULE_NAME ": %s()\n", __FUNCTION__);   \
+                        printk(KERN_DEBUG RTL819xU_MODULE_NAME ": %s()\n", __func__);   \
                         for(i=0; i<(int)(datalen); i++)                 \
                         {                                               \
                                 printk("%2x ", pdata[i]);               \
--- a/drivers/staging/rtl8192su/r8192U_core.c
+++ b/drivers/staging/rtl8192su/r8192U_core.c
@@ -283,7 +283,7 @@ static void rtl819x_set_channel_map(u8 c
 			}
 			else
 			{
-				RT_TRACE(COMP_ERR, "unknown rf chip, can't set channel map in function:%s()\n", __FUNCTION__);
+				RT_TRACE(COMP_ERR, "unknown rf chip, can't set channel map in function:%s()\n", __func__);
 			}
 			if (ChannelPlan[channel_plan].Len != 0){
 				// Clear old channel map
@@ -1292,7 +1292,7 @@ void rtl8192_set_chan(struct net_device
 {
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 //	u32 tx;
-	RT_TRACE(COMP_CH, "=====>%s()====ch:%d\n", __FUNCTION__, ch);
+	RT_TRACE(COMP_CH, "=====>%s()====ch:%d\n", __func__, ch);
 	priv->chan=ch;
 
 	/* this hack should avoid frame TX during channel setting*/
@@ -1534,7 +1534,7 @@ static void rtl8192_rx_isr(struct urb *u
                 priv->stats.rxstaterr++;
                 priv->ieee80211->stats.rx_errors++;
                 usb_free_urb(urb);
-	//	printk("%s():rx status err\n",__FUNCTION__);
+	//	printk("%s():rx status err\n",__func__);
                 return;
         }
 
@@ -1547,7 +1547,7 @@ static void rtl8192_rx_isr(struct urb *u
         skb = dev_alloc_skb(RX_URB_SIZE);
         if (unlikely(!skb)) {
                 usb_free_urb(urb);
-		printk("%s():can,t alloc skb\n",__FUNCTION__);
+		printk("%s():can,t alloc skb\n",__func__);
                 /* TODO check rx queue length and refill *somewhere* */
                 return;
         }
@@ -1985,7 +1985,7 @@ unsigned int txqueue2outpipe(struct r819
 
 	if(tx_queue >= 9)
 	{
-		RT_TRACE(COMP_ERR,"%s():Unknown queue ID!!!\n",__FUNCTION__);
+		RT_TRACE(COMP_ERR,"%s():Unknown queue ID!!!\n",__func__);
 		return 0x04;
 	}
 	return priv->txqueue_to_outpipemap[tx_queue];
@@ -2002,7 +2002,7 @@ short rtl8192SU_tx_cmd(struct net_device
 	u8 queue_index = tcb_desc->queue_index;
 	u32			PktSize = 0;
 
-	//printk("\n %s::::::::::::::::::::::queue_index = %d\n",__FUNCTION__, queue_index);
+	//printk("\n %s::::::::::::::::::::::queue_index = %d\n",__func__, queue_index);
 	atomic_inc(&priv->tx_pending[queue_index]);
 
 	tx_urb = usb_alloc_urb(0,GFP_ATOMIC);
@@ -2598,7 +2598,7 @@ void rtl8192SU_update_ratr_table(struct
 				ratr_value &= 0x0f0ff0f5;
 				}
 			}
-			//RT_TRACE("====>%s(), mode is not correct:%x\n", __FUNCTION__, ieee->mode);
+			//RT_TRACE("====>%s(), mode is not correct:%x\n", __func__, ieee->mode);
 			break;
 	}
 
@@ -2824,7 +2824,7 @@ static int rtl8192_qos_association_resp(
 
         spin_unlock_irqrestore(&priv->ieee80211->lock, flags);
 
-	RT_TRACE(COMP_QOS, "%s: network->flags = %d,%d\n",__FUNCTION__,network->flags ,priv->ieee80211->current_network.qos_data.active);
+	RT_TRACE(COMP_QOS, "%s: network->flags = %d,%d\n",__func__,network->flags ,priv->ieee80211->current_network.qos_data.active);
 	if (set_qos_param == 1)
 		queue_work(priv->priv_wq, &priv->qos_activate);
 
@@ -3010,7 +3010,7 @@ void rtl8192_SetWirelessMode(struct net_
 			wireless_mode = WIRELESS_MODE_B;
 		}
 		else{
-			RT_TRACE(COMP_ERR, "%s(), No valid wireless mode supported, SupportedWirelessMode(%x)!!!\n", __FUNCTION__,bSupportMode);
+			RT_TRACE(COMP_ERR, "%s(), No valid wireless mode supported, SupportedWirelessMode(%x)!!!\n", __func__,bSupportMode);
 			wireless_mode = WIRELESS_MODE_B;
 		}
 	}
@@ -3052,7 +3052,7 @@ short rtl8192_is_tx_queue_empty(struct n
 
 void rtl8192_hw_sleep_down(struct net_device *dev)
 {
-	RT_TRACE(COMP_POWER, "%s()============>come to sleep down\n", __FUNCTION__);
+	RT_TRACE(COMP_POWER, "%s()============>come to sleep down\n", __func__);
 #ifdef TODO
 //	MgntActSet_RF_State(dev, eRfSleep, RF_CHANGE_BY_PS);
 #endif
@@ -3067,17 +3067,17 @@ void rtl8192_hw_sleep_wq (struct work_st
         struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,hw_sleep_wq);
         struct net_device *dev = ieee->dev;
 
-	//RT_TRACE("=========>%s()\n", __FUNCTION__);
+	//RT_TRACE("=========>%s()\n", __func__);
         rtl8192_hw_sleep_down(dev);
 }
 //	RT_TRACE("dev is %d\n",dev);
-//	RT_TRACE("&*&(^*(&(&=========>%s()\n", __FUNCTION__);
+//	RT_TRACE("&*&(^*(&(&=========>%s()\n", __func__);
 void rtl8192_hw_wakeup(struct net_device* dev)
 {
 //	u32 flags = 0;
 
 //	spin_lock_irqsave(&priv->ps_lock,flags);
-	RT_TRACE(COMP_POWER, "%s()============>come to wake up\n", __FUNCTION__);
+	RT_TRACE(COMP_POWER, "%s()============>come to wake up\n", __func__);
 #ifdef TODO
 //	MgntActSet_RF_State(dev, eRfSleep, RF_CHANGE_BY_PS);
 #endif
@@ -3154,7 +3154,7 @@ void rtl8192_hw_to_sleep(struct net_devi
 //	if(priv->rf_sleep)
 //		priv->rf_sleep(dev);
 
-	//RT_TRACE("<=========%s()\n", __FUNCTION__);
+	//RT_TRACE("<=========%s()\n", __func__);
 	queue_delayed_work(priv->ieee80211->wq, (void *)&priv->ieee80211->hw_sleep_wq,0);
 
 	spin_unlock_irqrestore(&priv->ps_lock,flags);
@@ -4464,7 +4464,7 @@ static void rtl8192SU_MacConfigAfterFwDo
 
 		// Change Program timing
 		write_nic_byte(dev, EFUSE_CTRL+3, 0x72);
-		//printk("!!!!!!!!!!!!!!!!!!!!!%s: write 0x33 with 0x72\n",__FUNCTION__);
+		//printk("!!!!!!!!!!!!!!!!!!!!!%s: write 0x33 with 0x72\n",__func__);
 		RT_TRACE(COMP_INIT, "EFUSE CONFIG OK\n");
 	}
 
@@ -4959,7 +4959,7 @@ HalTxCheckStuck819xUsb(
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	u16 		RegTxCounter = read_nic_word(dev, 0x128);
 	bool		bStuck = FALSE;
-	RT_TRACE(COMP_RESET,"%s():RegTxCounter is %d,TxCounter is %d\n",__FUNCTION__,RegTxCounter,priv->TxCounter);
+	RT_TRACE(COMP_RESET,"%s():RegTxCounter is %d,TxCounter is %d\n",__func__,RegTxCounter,priv->TxCounter);
 	if(priv->TxCounter==RegTxCounter)
 		bStuck = TRUE;
 
@@ -5026,7 +5026,7 @@ HalRxCheckStuck819xUsb(struct net_device
 
 //#else
 	static u8	rx_chk_cnt = 0;
-	RT_TRACE(COMP_RESET,"%s(): RegRxCounter is %d,RxCounter is %d\n",__FUNCTION__,RegRxCounter,priv->RxCounter);
+	RT_TRACE(COMP_RESET,"%s(): RegRxCounter is %d,RxCounter is %d\n",__func__,RegRxCounter,priv->RxCounter);
 	// If rssi is small, we should check rx for long time because of bad rx.
 	// or maybe it will continuous silent reset every 2 seconds.
 	rx_chk_cnt++;
@@ -5156,7 +5156,7 @@ rtl819x_ifcheck_resetornot(struct net_de
 	if(TxResetType==RESET_TYPE_NORMAL || RxResetType==RESET_TYPE_NORMAL)
 		return RESET_TYPE_NORMAL;
 	else if(TxResetType==RESET_TYPE_SILENT || RxResetType==RESET_TYPE_SILENT){
-		RT_TRACE(COMP_RESET,"%s():silent reset\n",__FUNCTION__);
+		RT_TRACE(COMP_RESET,"%s():silent reset\n",__func__);
 		return RESET_TYPE_SILENT;
 	}
 	else
@@ -5336,12 +5336,12 @@ RESET_START:
 		down(&priv->wx_sem);
 		if(priv->up == 0)
 		{
-			RT_TRACE(COMP_ERR,"%s():the driver is not up! return\n",__FUNCTION__);
+			RT_TRACE(COMP_ERR,"%s():the driver is not up! return\n",__func__);
 			up(&priv->wx_sem);
 			return ;
 		}
 		priv->up = 0;
-		RT_TRACE(COMP_RESET,"%s():======>start to down the driver\n",__FUNCTION__);
+		RT_TRACE(COMP_RESET,"%s():======>start to down the driver\n",__func__);
 //		if(!netif_queue_stopped(dev))
 //			netif_stop_queue(dev);
 
@@ -5366,12 +5366,12 @@ RESET_START:
 			printk("ieee->state is NOT LINKED\n");
 			ieee80211_softmac_stop_protocol(priv->ieee80211);			}
 		up(&priv->wx_sem);
-		RT_TRACE(COMP_RESET,"%s():<==========down process is finished\n",__FUNCTION__);
+		RT_TRACE(COMP_RESET,"%s():<==========down process is finished\n",__func__);
 	//rtl8192_irq_disable(dev);
-		RT_TRACE(COMP_RESET,"%s():===========>start to up the driver\n",__FUNCTION__);
+		RT_TRACE(COMP_RESET,"%s():===========>start to up the driver\n",__func__);
 		reset_status = _rtl8192_up(dev);
 
-		RT_TRACE(COMP_RESET,"%s():<===========up process is finished\n",__FUNCTION__);
+		RT_TRACE(COMP_RESET,"%s():<===========up process is finished\n",__func__);
 		if(reset_status == -EAGAIN)
 		{
 			if(reset_times < 3)
@@ -5381,7 +5381,7 @@ RESET_START:
 			}
 			else
 			{
-				RT_TRACE(COMP_ERR," ERR!!! %s():  Reset Failed!!\n", __FUNCTION__);
+				RT_TRACE(COMP_ERR," ERR!!! %s():  Reset Failed!!\n", __func__);
 			}
 		}
 #endif
@@ -5592,7 +5592,7 @@ int _rtl8192_up(struct net_device *dev)
 	init_status = priv->ops->rtl819x_adapter_start(dev);
 	if(!init_status)
 	{
-		RT_TRACE(COMP_ERR,"ERR!!! %s(): initialization is failed!\n", __FUNCTION__);
+		RT_TRACE(COMP_ERR,"ERR!!! %s(): initialization is failed!\n", __func__);
 		priv->up=priv->ieee80211->ieee_up = 0;
 		return -EAGAIN;
 	}
@@ -5666,7 +5666,7 @@ int rtl8192_down(struct net_device *dev)
 
 	priv->up=0;
 	priv->ieee80211->ieee_up = 0;
-	RT_TRACE(COMP_DOWN, "==========>%s()\n", __FUNCTION__);
+	RT_TRACE(COMP_DOWN, "==========>%s()\n", __func__);
 /* FIXME */
 	if (!netif_queue_stopped(dev))
 		netif_stop_queue(dev);
@@ -5695,7 +5695,7 @@ int rtl8192_down(struct net_device *dev)
 
 	ieee80211_softmac_stop_protocol(priv->ieee80211);
 	memset(&priv->ieee80211->current_network, 0 , offsetof(struct ieee80211_network, list));
-	RT_TRACE(COMP_DOWN, "<==========%s()\n", __FUNCTION__);
+	RT_TRACE(COMP_DOWN, "<==========%s()\n", __func__);
 
 		return 0;
 }
@@ -6953,9 +6953,9 @@ void rtl8192SU_query_rxdesc_status(struc
 if(stats->bHwError)
 {
 	if(stats->bICV)
-		printk("%s: Receive ICV error!!!!!!!!!!!!!!!!!!!!!!\n", __FUNCTION__);
+		printk("%s: Receive ICV error!!!!!!!!!!!!!!!!!!!!!!\n", __func__);
 	if(stats->bCRC)
-		printk("%s: Receive CRC error!!!!!!!!!!!!!!!!!!!!!!\n", __FUNCTION__);
+		printk("%s: Receive CRC error!!!!!!!!!!!!!!!!!!!!!!\n", __func__);
 }
 
 	if(IS_UNDER_11N_AES_MODE(priv->ieee80211))
--- a/drivers/staging/rtl8192su/r8192U_dm.c
+++ b/drivers/staging/rtl8192su/r8192U_dm.c
@@ -2697,7 +2697,7 @@ static void dm_check_edca_turbo(
 		u8* peername[11] = {"unknown", "realtek", "realtek_92se", "broadcom", "ralink", "atheros", "cisco", "marvell", "92u_softap", "self_softap"};
 		static int wb_tmp = 0;
 		if (wb_tmp == 0){
-			printk("%s():iot peer is %#x:%s, bssid:%pM\n",__FUNCTION__,pHTInfo->IOTPeer,peername[pHTInfo->IOTPeer], priv->ieee80211->current_network.bssid);
+			printk("%s():iot peer is %#x:%s, bssid:%pM\n",__func__,pHTInfo->IOTPeer,peername[pHTInfo->IOTPeer], priv->ieee80211->current_network.bssid);
 			wb_tmp = 1;
 		}
 	}
@@ -3573,7 +3573,7 @@ extern void dm_fsync_timer_callback(unsi
 
 static void dm_StartHWFsync(struct net_device *dev)
 {
-	RT_TRACE(COMP_HALDM, "%s\n", __FUNCTION__);
+	RT_TRACE(COMP_HALDM, "%s\n", __func__);
 	write_nic_dword(dev, rOFDM0_RxDetector2, 0x465c12cf);
 	write_nic_byte(dev, 0xc3b, 0x41);
 }
@@ -3582,7 +3582,7 @@ static void dm_EndSWFsync(struct net_dev
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
-	RT_TRACE(COMP_HALDM, "%s\n", __FUNCTION__);
+	RT_TRACE(COMP_HALDM, "%s\n", __func__);
 	del_timer_sync(&(priv->fsync_timer));
 
 	// Let Register return to default value;
@@ -3612,7 +3612,7 @@ static void dm_StartSWFsync(struct net_d
 	u32 			rateIndex;
 	u32 			rateBitmap;
 
-	RT_TRACE(COMP_HALDM,"%s\n", __FUNCTION__);
+	RT_TRACE(COMP_HALDM,"%s\n", __func__);
 	// Initial rate record to zero, start to record.
 	priv->rate_record = 0;
 	// Initial contiune diff count to zero, start to record.
@@ -3649,7 +3649,7 @@ static void dm_StartSWFsync(struct net_d
 
 static void dm_EndHWFsync(struct net_device *dev)
 {
-	RT_TRACE(COMP_HALDM,"%s\n", __FUNCTION__);
+	RT_TRACE(COMP_HALDM,"%s\n", __func__);
 	write_nic_dword(dev, rOFDM0_RxDetector2, 0x465c52cd);
 	write_nic_byte(dev, 0xc3b, 0x49);
 
@@ -3888,7 +3888,7 @@ static void dm_dynamic_txpower(struct ne
 		txlowpower_threshold = TX_POWER_NEAR_FIELD_THRESH_LOW;
 	}
 
-//	printk("=======>%s(): txhipower_threshhold is %d,txlowpower_threshold is %d\n",__FUNCTION__,txhipower_threshhold,txlowpower_threshold);
+//	printk("=======>%s(): txhipower_threshhold is %d,txlowpower_threshold is %d\n",__func__,txhipower_threshhold,txlowpower_threshold);
 	RT_TRACE(COMP_TXAGC,"priv->undecorated_smoothed_pwdb = %ld \n" , priv->undecorated_smoothed_pwdb);
 
 	if(priv->ieee80211->state == IEEE80211_LINKED)
--- a/drivers/staging/rtl8192su/r8192U_wx.c
+++ b/drivers/staging/rtl8192su/r8192U_wx.c
@@ -284,7 +284,7 @@ static int r8192_wx_force_reset(struct n
 
 	down(&priv->wx_sem);
 
-	printk("%s(): force reset ! extra is %d\n",__FUNCTION__, *extra);
+	printk("%s(): force reset ! extra is %d\n",__func__, *extra);
 	priv->force_reset = *extra;
 	up(&priv->wx_sem);
 	return 0;
@@ -907,7 +907,7 @@ static int r8192_wx_set_enc_ext(struct n
 	int ret=0;
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	struct ieee80211_device* ieee = priv->ieee80211;
-	//RT_TRACE("===>%s()\n", __FUNCTION__);
+	//RT_TRACE("===>%s()\n", __func__);
 
 
 	down(&priv->wx_sem);
@@ -989,7 +989,7 @@ static int r8192_wx_set_auth(struct net_
 {
 	int ret=0;
 
-	//RT_TRACE("====>%s()\n", __FUNCTION__);
+	//RT_TRACE("====>%s()\n", __func__);
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	down(&priv->wx_sem);
 	ret = ieee80211_wx_set_auth(priv->ieee80211, info, &(data->param), extra);
@@ -1001,7 +1001,7 @@ static int r8192_wx_set_mlme(struct net_
                                         struct iw_request_info *info,
                                         union iwreq_data *wrqu, char *extra)
 {
-	//RT_TRACE("====>%s()\n", __FUNCTION__);
+	//RT_TRACE("====>%s()\n", __func__);
 
 	int ret=0;
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -1015,7 +1015,7 @@ static int r8192_wx_set_gen_ie(struct ne
                                         struct iw_request_info *info,
                                         union iwreq_data *data, char *extra)
 {
-	   //RT_TRACE("====>%s(), len:%d\n", __FUNCTION__, data->length);
+	   //RT_TRACE("====>%s(), len:%d\n", __func__, data->length);
 	int ret=0;
         struct r8192_priv *priv = ieee80211_priv(dev);
         down(&priv->wx_sem);
@@ -1023,7 +1023,7 @@ static int r8192_wx_set_gen_ie(struct ne
         ret = ieee80211_wx_set_gen_ie(priv->ieee80211, extra, data->data.length);
 #endif
         up(&priv->wx_sem);
-	//RT_TRACE("<======%s(), ret:%d\n", __FUNCTION__, ret);
+	//RT_TRACE("<======%s(), ret:%d\n", __func__, ret);
         return ret;
 
 

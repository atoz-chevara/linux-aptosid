--- a/drivers/staging/rtl8192su/r8192U.h
+++ b/drivers/staging/rtl8192su/r8192U.h
@@ -90,12 +90,18 @@
 #define DMESG(x,a...)
 #define DMESGW(x,a...)
 #define DMESGE(x,a...)
+
 extern u32 rt_global_debug_component;
+#ifdef RTL819x_DEBUG
 #define RT_TRACE(component, x, args...) \
 do { if(rt_global_debug_component & component) \
 	printk(KERN_DEBUG RTL819xU_MODULE_NAME ":" x "\n" , \
 	       ##args);\
 }while(0);
+#else
+#define RT_TRACE(component, x, args...) do {} while (0)
+#endif /* RTL8169_DEBUG */
+
 //----------------------------------------------------------------------
 //// Get 8192SU  Rx descriptor. Added by Roger, 2008.04.15.
 ////----------------------------------------------------------------------
@@ -145,7 +151,6 @@ do { if(rt_global_debug_component & comp
 #define COMP_RESET				BIT30  //for silent reset
 #define COMP_ERR				BIT31 //for error out, always on
 
-#define RTL819x_DEBUG
 #ifdef RTL819x_DEBUG
 #define assert(expr) \
         if (!(expr)) {                                  \
--- a/drivers/staging/rtl8192su/ieee80211/ieee80211.h
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211.h
@@ -169,7 +169,6 @@ typedef struct ieee_param {
 #define IEEE80211_QCTL_TID              0x000F
 
 /* debug macros */
-#define CONFIG_IEEE80211_DEBUG
 #ifdef CONFIG_IEEE80211_DEBUG
 extern u32 ieee80211_debug_level;
 #define IEEE80211_DEBUG(level, fmt, args...) \
--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c
@@ -679,7 +679,7 @@ inline struct sk_buff *ieee80211_authent
 		auth->algorithm = WLAN_AUTH_SHARED_KEY;
 	else if(ieee->auth_mode == 2)
 		auth->algorithm = WLAN_AUTH_OPEN;//0x80;
-	printk("=================>%s():auth->algorithm is %d\n",__FUNCTION__,auth->algorithm);
+	IEEE80211_DEBUG_MGMT("=================>%s():auth->algorithm is %d\n",__FUNCTION__,auth->algorithm);
 	auth->transaction = cpu_to_le16(ieee->associate_seq);
 	ieee->associate_seq++;
 
@@ -761,7 +761,7 @@ static struct sk_buff* ieee80211_probe_r
 		tmp_generic_ie_len = sizeof(ieee->pHTInfo->szRT2RTAggBuffer);
 		HTConstructRT2RTAggElement(ieee, tmp_generic_ie_buf, &tmp_generic_ie_len);
         }
-//	printk("===============>tmp_ht_cap_len is %d,tmp_ht_info_len is %d, tmp_generic_ie_len is %d\n",tmp_ht_cap_len,tmp_ht_info_len,tmp_generic_ie_len);
+//	IEEE80211_DEBUG_DATA("===============>tmp_ht_cap_len is %d,tmp_ht_info_len is %d, tmp_generic_ie_len is %d\n",tmp_ht_cap_len,tmp_ht_info_len,tmp_generic_ie_len);
 #endif
 	beacon_size = sizeof(struct ieee80211_probe_response)+2+
 		ssid_len
@@ -1367,12 +1367,12 @@ void ieee80211_associate_complete_wq(str
 	}
 	ieee->link_change(ieee->dev);
 	if(ieee->is_silent_reset == 0){
-		printk("============>normal associate\n");
+		IEEE80211_DEBUG_MGMT("============>normal associate\n");
 	notify_wx_assoc_event(ieee);
 	}
 	else if(ieee->is_silent_reset == 1)
 	{
-		printk("==================>silent reset associate\n");
+		IEEE80211_DEBUG_MGMT("==================>silent reset associate\n");
 		ieee->is_silent_reset = 0;
 	}
 
@@ -1403,7 +1403,7 @@ void ieee80211_associate_procedure_wq(st
 		ieee->data_hard_stop(ieee->dev);
 
 	ieee80211_stop_scan(ieee);
-	printk("===>%s(), chan:%d\n", __FUNCTION__, ieee->current_network.channel);
+	IEEE80211_DEBUG_MGMT("===>%s(), chan:%d\n", __FUNCTION__, ieee->current_network.channel);
 	//ieee->set_chan(ieee->dev, ieee->current_network.channel);
 	HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
 
@@ -2031,7 +2031,7 @@ ieee80211_rx_frame_softmac(struct ieee80
 											bSupportNmode = false;
 											bHalfSupportNmode = false;
 										}
-									printk("==========>to link with AP using SEC(%d, %d)", bSupportNmode, bHalfSupportNmode);
+									IEEE80211_DEBUG_MGMT("==========>to link with AP using SEC(%d, %d)", bSupportNmode, bHalfSupportNmode);
 									}
 								}
 								/* Dummy wirless mode setting to avoid encryption issue */
@@ -2047,7 +2047,7 @@ ieee80211_rx_frame_softmac(struct ieee80
 
 								if (ieee->current_network.mode == IEEE_N_24G && bHalfSupportNmode == true)
 								{
-									printk("===============>entern half N mode\n");
+									IEEE80211_DEBUG_MGMT("===============>enter half N mode\n");
 									ieee->bHalfWirelessN24GMode = true;
 								}
 								else
@@ -2342,7 +2342,7 @@ void ieee80211_start_ibss_wq(struct work
 	 * on the semaphore
 	 */
 	if(!ieee->proto_started){
-		printk("==========oh driver down return\n");
+		IEEE80211_DEBUG_MGMT("==========oh driver down return\n");
 		return;
 	}
 	down(&ieee->wx_sem);
@@ -2656,7 +2656,7 @@ void ieee80211_start_protocol(struct iee
 
 	if (ieee->current_network.beacon_interval == 0)
 		ieee->current_network.beacon_interval = 100;
-//	printk("===>%s(), chan:%d\n", __FUNCTION__, ieee->current_network.channel);
+//	IEEE80211_DEBUG_MGMT("===>%s(), chan:%d\n", __FUNCTION__, ieee->current_network.channel);
 //	ieee->set_chan(ieee->dev,ieee->current_network.channel);
 
        	for(i = 0; i < 17; i++) {
--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_wx.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_wx.c
@@ -581,7 +581,7 @@ int ieee80211_wx_set_encode_ext(struct i
                 ret = -EINVAL;
                 goto done;
         }
-	printk("alg name:%s\n",alg);
+	IEEE80211_DEBUG_WX("alg name:%s\n",alg);
 
 	 ops = ieee80211_get_crypto_ops(alg);
         if (ops == NULL)
--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_BAProc.c
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_BAProc.c
@@ -148,7 +148,7 @@ static struct sk_buff* ieee80211_ADDBA(s
 	if (ACT_ADDBARSP == type)
 	{
 		// Status Code
-		printk("=====>to send ADDBARSP\n");
+		//printk("=====>to send ADDBARSP\n");
 		tmp = cpu_to_le16(StatusCode);
 		memcpy(tag, (u8*)&tmp, 2);
 		tag += 2;
@@ -357,7 +357,7 @@ int ieee80211_rx_ADDBAReq( struct ieee80
 	pBaTimeoutVal = (u16*)(tag + 5);
 	pBaStartSeqCtrl = (PSEQUENCE_CONTROL)(req + 7);
 
-	printk("====================>rx ADDBAREQ from :%pM\n", dst);
+	//printk("====================>rx ADDBAREQ from :%pM\n", dst);
 //some other capability is not ready now.
 	if(	(ieee->current_network.qos_data.active == 0) ||
 		(ieee->pHTInfo->bCurrentHTSupport == false) ||
--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c
@@ -558,7 +558,7 @@ u8 HTIOTActIsForcedCTS2Self(struct ieee8
 u8 HTIOTActIsForcedRTSCTS(struct ieee80211_device *ieee, struct ieee80211_network *network)
 {
 	u8	retValue = 0;
-	printk("============>%s(), %d\n", __FUNCTION__, network->realtek_cap_exit);
+	//printk("============>%s(), %d\n", __FUNCTION__, network->realtek_cap_exit);
 	// Force protection
 	if(ieee->pHTInfo->bCurrentHTSupport)
 	{
@@ -683,7 +683,7 @@ HTIOTActDetermineRaFunc(struct ieee80211
 	if(pHTInfo->IOTAction & HT_IOT_ACT_AMSDU_ENABLE)
 		pHTInfo->IOTRaFunc |= HT_IOT_RAFUNC_TX_AMSDU;
 
-	printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!IOTRaFunc = %8.8x\n", pHTInfo->IOTRaFunc);
+	IEEE80211_DEBUG("!!!!!!!!!!!!!!!!!!!!!!!!!!!IOTRaFunc = %8.8x\n", pHTInfo->IOTRaFunc);
 }
 
 
@@ -1585,7 +1585,7 @@ void HTResetSelfAndSavePeerSetting(struc
 		if(bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_FORCED_RTS;
 
-		printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!IOTAction = %8.8x\n", pHTInfo->IOTAction);
+		IEEE80211_DEBUG("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!IOTAction = %8.8x\n", pHTInfo->IOTAction);
 	}
 	else
 	{
--- a/drivers/staging/rtl8192su/r8192S_phy.c
+++ b/drivers/staging/rtl8192su/r8192S_phy.c
@@ -2931,7 +2931,7 @@ phy_SwChnlStepByStep(
 			{
 			// For new T65 RF 0222d register 0x18 bit 0-9 = channel number.
 				rtl8192_phy_SetRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, 0x1f, (CurrentCmd->Para2));
-				//printk("====>%x, %x, read_back:%x\n", CurrentCmd->Para2,CurrentCmd->Para1, rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, 0x1f));
+				//RT_TRACE("====>%x, %x, read_back:%x\n", CurrentCmd->Para2,CurrentCmd->Para1, rtl8192_phy_QueryRFReg(dev, (RF90_RADIO_PATH_E)eRFPath, CurrentCmd->Para1, 0x1f));
 			}
 			break;
                 default:
--- a/drivers/staging/rtl8192su/r8192U_core.c
+++ b/drivers/staging/rtl8192su/r8192U_core.c
@@ -1229,7 +1229,6 @@ void rtl8192_set_chan(struct net_device
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 //	u32 tx;
 	RT_TRACE(COMP_CH, "=====>%s()====ch:%d\n", __FUNCTION__, ch);
-	//printk("=====>%s()====ch:%d\n", __FUNCTION__, ch);
 	priv->chan=ch;
 
 	/* this hack should avoid frame TX during channel setting*/
@@ -1962,7 +1961,7 @@ short rtl8192SU_tx_cmd(struct net_device
 	//----------------------------------------------------------------------------
 	// Get index to out pipe from specified QueueID.
 	idx_pipe = txqueue2outpipe(priv,queue_index);
-	//printk("=============>%s queue_index:%d, outpipe:%d\n", __func__,queue_index,priv->RtOutPipes[idx_pipe]);
+	//RT_TRACE("=============>%s queue_index:%d, outpipe:%d\n", __func__,queue_index,priv->RtOutPipes[idx_pipe]);
 
 	usb_fill_bulk_urb(tx_urb,
 	                            priv->udev,
@@ -2329,7 +2328,7 @@ short rtl8192SU_tx(struct net_device *de
 
 	/* Get index to out pipe from specified QueueID */
 	idx_pipe = txqueue2outpipe(priv,tcb_desc->queue_index);
-	//printk("=============>%s queue_index:%d, outpipe:%d\n", __func__,tcb_desc->queue_index,priv->RtOutPipes[idx_pipe]);
+	//RT_TRACE("=============>%s queue_index:%d, outpipe:%d\n", __func__,tcb_desc->queue_index,priv->RtOutPipes[idx_pipe]);
 
 	//RT_DEBUG_DATA(COMP_SEND,tx_fwinfo,sizeof(tx_fwinfo_819x_usb));
 	//RT_DEBUG_DATA(COMP_SEND,tx_desc,sizeof(tx_desc_819x_usb));
@@ -2534,7 +2533,7 @@ void rtl8192SU_update_ratr_table(struct
 				ratr_value &= 0x0f0ff0f5;
 				}
 			}
-			//printk("====>%s(), mode is not correct:%x\n", __FUNCTION__, ieee->mode);
+			//RT_TRACE("====>%s(), mode is not correct:%x\n", __FUNCTION__, ieee->mode);
 			break;
 	}
 
@@ -2559,15 +2558,15 @@ void rtl8192SU_update_ratr_table(struct
 		//printk("==>SG_RATE:%x\n", read_nic_byte(dev, SG_RATE));
 	}
 	write_nic_dword(dev, ARFR0+rate_index*4, ratr_value);
-	printk("=============>ARFR0+rate_index*4:%#x\n", ratr_value);
+	RT_TRACE("=============>ARFR0+rate_index*4:%#x\n", ratr_value);
 
 	//2 UFWP
 	if (ratr_value & 0xfffff000){
-		//printk("===>set to N mode\n");
+		//RT_TRACE("===>set to N mode\n");
 		HalSetFwCmd8192S(dev, FW_CMD_RA_REFRESH_N);
 	}
 	else	{
-		//printk("===>set to B/G mode\n");
+		//RT_TRACE("===>set to B/G mode\n");
 		HalSetFwCmd8192S(dev, FW_CMD_RA_REFRESH_BG);
 	}
 }
@@ -2579,7 +2578,7 @@ void rtl8192SU_link_change(struct net_de
 	//unsigned long flags;
 	u32 reg = 0;
 
-	printk("=====>%s 1\n", __func__);
+	RT_TRACE("=====>%s 1\n", __func__);
 	reg = read_nic_dword(dev, RCR);
 
 	if (ieee->state == IEEE80211_LINKED)
@@ -2598,7 +2597,7 @@ void rtl8192SU_link_change(struct net_de
 	write_nic_dword(dev, RCR, reg);
 	rtl8192_update_msr(dev);
 
-	printk("<=====%s 2\n", __func__);
+	RT_TRACE("<=====%s 2\n", __func__);
 }
 
 static struct ieee80211_qos_parameters def_qos_parameters = {
@@ -2989,7 +2988,7 @@ short rtl8192_is_tx_queue_empty(struct n
 			continue;
 		if (atomic_read(&priv->tx_pending[i]))
 		{
-			printk("===>tx queue is not empty:%d, %d\n", i, atomic_read(&priv->tx_pending[i]));
+			RT_TRACE("===>tx queue is not empty:%d, %d\n", i, atomic_read(&priv->tx_pending[i]));
 			return 0;
 		}
 	}
@@ -3013,11 +3012,11 @@ void rtl8192_hw_sleep_wq (struct work_st
         struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,hw_sleep_wq);
         struct net_device *dev = ieee->dev;
 
-	//printk("=========>%s()\n", __FUNCTION__);
+	//RT_TRACE("=========>%s()\n", __FUNCTION__);
         rtl8192_hw_sleep_down(dev);
 }
-//	printk("dev is %d\n",dev);
-//	printk("&*&(^*(&(&=========>%s()\n", __FUNCTION__);
+//	RT_TRACE("dev is %d\n",dev);
+//	RT_TRACE("&*&(^*(&(&=========>%s()\n", __FUNCTION__);
 void rtl8192_hw_wakeup(struct net_device* dev)
 {
 //	u32 flags = 0;
@@ -3092,7 +3091,7 @@ void rtl8192_hw_to_sleep(struct net_devi
 #if 1
 	if(((tl > rb) && ((tl-rb) > MSECS(MAX_SLEEP_TIME)))||
 		((tl < rb) && ((rb-tl) > MSECS(MAX_SLEEP_TIME)))) {
-		printk("========>too long to sleep:%x, %x, %lx\n", tl, rb,  MSECS(MAX_SLEEP_TIME));
+		RT_TRACE("========>too long to sleep:%x, %x, %lx\n", tl, rb,  MSECS(MAX_SLEEP_TIME));
 		spin_unlock_irqrestore(&priv->ps_lock,flags);
 		return;
 	}
@@ -3100,7 +3099,7 @@ void rtl8192_hw_to_sleep(struct net_devi
 //	if(priv->rf_sleep)
 //		priv->rf_sleep(dev);
 
-	//printk("<=========%s()\n", __FUNCTION__);
+	//RT_TRACE("<=========%s()\n", __FUNCTION__);
 	queue_delayed_work(priv->ieee80211->wq, (void *)&priv->ieee80211->hw_sleep_wq,0);
 
 	spin_unlock_irqrestore(&priv->ps_lock,flags);
@@ -5459,7 +5458,7 @@ void CAM_read_entry(
 	 u8 entry_i=0;
 	 u32 ulStatus;
 	s32 i=100;
-//	printk("=======>start read CAM\n");
+//	RT_TRACE("=======>start read CAM\n");
  	for(entry_i=0;entry_i<CAM_CONTENT_COUNT;entry_i++)
  	{
    	// polling bit, and No Write enable, and address
@@ -5554,7 +5553,7 @@ extern	void	rtl819x_watchdog_wqcallback(
 				if(rfState == eRfOff)
 					RT_TRACE(COMP_ERR,"========>%s()\n",__FUNCTION__);
 				#endif
-				printk("===>%s(): AP is power off,connect another one\n",__FUNCTION__);
+				RT_TRACE("===>%s(): AP is power off,connect another one\n",__FUNCTION__);
 			//	Dot11d_Reset(dev);
 				priv->ieee80211->state = IEEE80211_ASSOCIATING;
 				notify_wx_assoc_event(priv->ieee80211);
@@ -5595,7 +5594,7 @@ extern	void	rtl819x_watchdog_wqcallback(
 void watch_dog_timer_callback(unsigned long data)
 {
 	struct r8192_priv *priv = ieee80211_priv((struct net_device *) data);
-	//printk("===============>watch_dog  timer\n");
+	//RT_TRACE("===============>watch_dog  timer\n");
 	queue_delayed_work(priv->priv_wq,&priv->watch_dog_wq, 0);
 	mod_timer(&priv->watch_dog_timer, jiffies + MSECS(IEEE80211_WATCH_DOG_TIME));
 }
@@ -7416,7 +7415,7 @@ static int __devinit rtl8192_usb_probe(s
 
 	HalUsbSetQueuePipeMapping8192SUsb(intf, dev);
 
-	//printk("===============>NIC 8192SU\n");
+	//RT_TRACE("===============>NIC 8192SU\n");
 	priv->ops = &rtl8192su_ops;
 
 	dev->netdev_ops = &rtl8192_netdev_ops;
--- a/drivers/staging/rtl8192su/r8192U_wx.c
+++ b/drivers/staging/rtl8192su/r8192U_wx.c
@@ -511,10 +511,10 @@ static int r8192_wx_set_scan(struct net_
 		struct iw_scan_req* req = (struct iw_scan_req*)b;
 		if (req->essid_len)
 		{
-			//printk("==**&*&*&**===>scan set ssid:%s\n", req->essid);
+			//RT_TRACE("==**&*&*&**===>scan set ssid:%s\n", req->essid);
 			ieee->current_network.ssid_len = req->essid_len;
 			memcpy(ieee->current_network.ssid, req->essid, req->essid_len);
-			//printk("=====>network ssid:%s\n", ieee->current_network.ssid);
+			//RT_TRACE("=====>network ssid:%s\n", ieee->current_network.ssid);
 		}
 	}
 
@@ -907,7 +907,7 @@ static int r8192_wx_set_enc_ext(struct n
 	int ret=0;
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	struct ieee80211_device* ieee = priv->ieee80211;
-	//printk("===>%s()\n", __FUNCTION__);
+	//RT_TRACE("===>%s()\n", __FUNCTION__);
 
 
 	down(&priv->wx_sem);
@@ -989,7 +989,7 @@ static int r8192_wx_set_auth(struct net_
 {
 	int ret=0;
 
-	//printk("====>%s()\n", __FUNCTION__);
+	//RT_TRACE("====>%s()\n", __FUNCTION__);
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	down(&priv->wx_sem);
 	ret = ieee80211_wx_set_auth(priv->ieee80211, info, &(data->param), extra);
@@ -1001,7 +1001,7 @@ static int r8192_wx_set_mlme(struct net_
                                         struct iw_request_info *info,
                                         union iwreq_data *wrqu, char *extra)
 {
-	//printk("====>%s()\n", __FUNCTION__);
+	//RT_TRACE("====>%s()\n", __FUNCTION__);
 
 	int ret=0;
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -1015,7 +1015,7 @@ static int r8192_wx_set_gen_ie(struct ne
                                         struct iw_request_info *info,
                                         union iwreq_data *data, char *extra)
 {
-	   //printk("====>%s(), len:%d\n", __FUNCTION__, data->length);
+	   //RT_TRACE("====>%s(), len:%d\n", __FUNCTION__, data->length);
 	int ret=0;
         struct r8192_priv *priv = ieee80211_priv(dev);
         down(&priv->wx_sem);
@@ -1023,7 +1023,7 @@ static int r8192_wx_set_gen_ie(struct ne
         ret = ieee80211_wx_set_gen_ie(priv->ieee80211, extra, data->data.length);
 #endif
         up(&priv->wx_sem);
-	//printk("<======%s(), ret:%d\n", __FUNCTION__, ret);
+	//RT_TRACE("<======%s(), ret:%d\n", __FUNCTION__, ret);
         return ret;
 
 

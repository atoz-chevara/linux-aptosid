From a073fdef46d50440ee573452a436023dcf4f9edf Mon Sep 17 00:00:00 2001
From: Ivo van Doorn <ivdoorn@gmail.com>
Date: Sat, 30 Apr 2011 17:14:23 +0200
Subject: [PATCH 41/48] rt2x00: Optimize TX_STA_FIFO register reading

Add recycling functionality to rt2x00usb_register_read_async.
When the callback function returns true, resubmit the urb to
read the register again.

This optimizes the rt2800usb driver when multiple TX status reports
are pending in the register, because now we don't need to allocate
the rt2x00_async_read_data and urb structure each time.

Signed-off-by: Ivo van Doorn <IvDoorn@gmail.com>
Acked-by: Gertjan van Wingerde <gwingerde@gmail.com>
Signed-off-by: John W. Linville <linville@tuxdriver.com>
---
 drivers/net/wireless/rt2x00/rt2800usb.c |    9 +++++----
 drivers/net/wireless/rt2x00/rt2x00usb.c |   11 +++++++----
 drivers/net/wireless/rt2x00/rt2x00usb.h |    4 +++-
 3 files changed, 15 insertions(+), 9 deletions(-)

--- a/drivers/net/wireless/rt2x00/rt2800usb.c
+++ b/drivers/net/wireless/rt2x00/rt2800usb.c
@@ -114,12 +114,12 @@ static bool rt2800usb_txstatus_pending(s
 	return false;
 }
 
-static void rt2800usb_tx_sta_fifo_read_completed(struct rt2x00_dev *rt2x00dev,
+static bool rt2800usb_tx_sta_fifo_read_completed(struct rt2x00_dev *rt2x00dev,
 						 int urb_status, u32 tx_status)
 {
 	if (urb_status) {
 		WARNING(rt2x00dev, "rt2x00usb_register_read_async failed: %d\n", urb_status);
-		return;
+		return false;
 	}
 
 	/* try to read all TX_STA_FIFO entries before scheduling txdone_work */
@@ -129,13 +129,14 @@ static void rt2800usb_tx_sta_fifo_read_c
 				"drop tx status report.\n");
 			queue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);
 		} else
-			rt2x00usb_register_read_async(rt2x00dev, TX_STA_FIFO,
-						      rt2800usb_tx_sta_fifo_read_completed);
+			return true;
 	} else if (!kfifo_is_empty(&rt2x00dev->txstatus_fifo)) {
 		queue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);
 	} else if (rt2800usb_txstatus_pending(rt2x00dev)) {
 		mod_timer(&rt2x00dev->txstatus_timer, jiffies + msecs_to_jiffies(2));
 	}
+
+	return false;
 }
 
 static void rt2800usb_tx_dma_done(struct queue_entry *entry)
--- a/drivers/net/wireless/rt2x00/rt2x00usb.c
+++ b/drivers/net/wireless/rt2x00/rt2x00usb.c
@@ -170,19 +170,22 @@ struct rt2x00_async_read_data {
 	__le32 reg;
 	struct usb_ctrlrequest cr;
 	struct rt2x00_dev *rt2x00dev;
-	void (*callback)(struct rt2x00_dev *,int,u32);
+	bool (*callback)(struct rt2x00_dev *, int, u32);
 };
 
 static void rt2x00usb_register_read_async_cb(struct urb *urb)
 {
 	struct rt2x00_async_read_data *rd = urb->context;
-	rd->callback(rd->rt2x00dev, urb->status, le32_to_cpu(rd->reg));
-	kfree(urb->context);
+	if (rd->callback(rd->rt2x00dev, urb->status, le32_to_cpu(rd->reg))) {
+		if (usb_submit_urb(urb, GFP_ATOMIC) < 0)
+			kfree(rd);
+	} else
+		kfree(rd);
 }
 
 void rt2x00usb_register_read_async(struct rt2x00_dev *rt2x00dev,
 				   const unsigned int offset,
-				   void (*callback)(struct rt2x00_dev*,int,u32))
+				   bool (*callback)(struct rt2x00_dev*, int, u32))
 {
 	struct usb_device *usb_dev = to_usb_device_intf(rt2x00dev->dev);
 	struct urb *urb;
--- a/drivers/net/wireless/rt2x00/rt2x00usb.h
+++ b/drivers/net/wireless/rt2x00/rt2x00usb.h
@@ -349,10 +349,12 @@ int rt2x00usb_regbusy_read(struct rt2x00
  * be called from atomic context.  The callback will be called
  * when the URB completes. Otherwise the function is similar
  * to rt2x00usb_register_read().
+ * When the callback function returns false, the memory will be cleaned up,
+ * when it returns true, the urb will be fired again.
  */
 void rt2x00usb_register_read_async(struct rt2x00_dev *rt2x00dev,
 				   const unsigned int offset,
-				   void (*callback)(struct rt2x00_dev*,int,u32));
+				   bool (*callback)(struct rt2x00_dev*, int, u32));
 
 /*
  * Radio handlers

--- a/drivers/net/wireless/ath/carl9170/main.c
+++ b/drivers/net/wireless/ath/carl9170/main.c
@@ -446,7 +446,7 @@ static void ar9170_watchdog_work(struct
 }
 
 static int ar9170_op_add_interface(struct ieee80211_hw *hw,
-				   struct ieee80211_vif *vif)
+				   struct ieee80211_if_init_conf *conf)
 {
 	struct ar9170 *ar = hw->priv;
 	struct ath_common *common = &ar->common;
@@ -462,18 +462,18 @@ static int ar9170_op_add_interface(struc
 	}
 	rcu_read_unlock();
 
-	rcu_assign_pointer(ar->vif, vif);
+	rcu_assign_pointer(ar->vif, conf->vif);
 
-	memcpy(common->macaddr, vif->addr, ETH_ALEN);
+	memcpy(common->macaddr, conf->mac_addr, ETH_ALEN);
 
-	if (modparam_nohwcrypt || (vif->type != NL80211_IFTYPE_STATION)) {
+	if (modparam_nohwcrypt || (ar->vif->type != NL80211_IFTYPE_STATION)) {
 		ar->rx_software_decryption = true;
 		ar->disable_offload = true;
 	}
 
 	ar->cur_filter = 0;
 
-	if (vif->type != NL80211_IFTYPE_MONITOR)
+	if (ar->vif->type != NL80211_IFTYPE_MONITOR)
 		ftf = AR9170_MAC_FTF_DEFAULTS;
 	else
 		ftf = AR9170_MAC_FTF_MONITOR;
@@ -492,7 +492,7 @@ unlock:
 }
 
 static void ar9170_op_remove_interface(struct ieee80211_hw *hw,
-				       struct ieee80211_vif *vif)
+				       struct ieee80211_if_init_conf *conf)
 {
 	struct ar9170 *ar = hw->priv;
 
@@ -918,64 +918,56 @@ out:
 	return err;
 }
 
-static int ar9170_sta_add(struct ieee80211_hw *hw,
-			   struct ieee80211_vif *vif,
-			   struct ieee80211_sta *sta)
+static void ar9170_sta_notify(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif,
+			      enum sta_notify_cmd cmd,
+			      struct ieee80211_sta *sta)
 {
 	struct ar9170 *ar = hw->priv;
 	struct ar9170_sta_info *sta_info = (void *) sta->drv_priv;
+	unsigned int i;
 
-	if (!sta->ht_cap.ht_supported)
-		return 0;
+	switch (cmd) {
+	case STA_NOTIFY_ADD:
+		if (!sta->ht_cap.ht_supported)
+			break;
 
-	if (sta->ht_cap.ampdu_density > 6) {
-		if (net_ratelimit())
+		if (sta->ht_cap.ampdu_density > 6) {
 			printk(KERN_WARNING "%s: HW does support 16us AMPDU "
 			       "density. No HT-Xmit for station %pM\n",
 			       wiphy_name(ar->hw->wiphy), sta->addr);
-		return 0;
-	}
+			break;
+		}
 
-	sta_info->ht_sta = true;
-	sta_info->ampdu_max_len = 1 << (3 + sta->ht_cap.ampdu_factor);
+		sta_info->ampdu_max_len = 1 << (3 + sta->ht_cap.ampdu_factor);
+		break;
 
-	return 0;
-}
+	case STA_NOTIFY_REMOVE:
+		if (!sta->ht_cap.ht_supported)
+			break;
 
-static int ar9170_sta_remove(struct ieee80211_hw *hw,
-			      struct ieee80211_vif *vif,
-			      struct ieee80211_sta *sta)
-{
-	struct ar9170 *ar = hw->priv;
-	struct ar9170_sta_info *sta_info = (void *) sta->drv_priv;
-	unsigned int i;
+		rcu_read_lock();
+		for (i = 0; i < AR9170_NUM_TID; i++) {
+			struct ar9170_sta_tid *tid_info;
 
-	if (!sta->ht_cap.ht_supported)
-		return 0;
+			tid_info = rcu_dereference(sta_info->agg[i]);
 
-	sta_info->ht_sta = false;
+			if (!tid_info)
+				continue;
 
-	rcu_read_lock();
-	for (i = 0; i < AR9170_NUM_TID; i++) {
-		struct ar9170_sta_tid *tid_info;
+			tid_info->state = AR9170_TID_STATE_SHUTDOWN;
 
-		tid_info = rcu_dereference(sta_info->agg[i]);
+			rcu_assign_pointer(sta_info->agg[i], NULL);
 
-		if (!tid_info)
-			continue;
+			ieee80211_queue_work(ar->hw, &ar->ampdu_work);
+		}
+		rcu_read_unlock();
 
-		tid_info->state = AR9170_TID_STATE_SHUTDOWN;
+		break;
 
-		rcu_assign_pointer(sta_info->agg[i], NULL);
+	default:
+		break;
 	}
-	rcu_read_unlock();
-	synchronize_rcu();
-
-	mutex_lock(&ar->mutex);
-	ar9170_ampdu_gc(ar);
-	mutex_unlock(&ar->mutex);
-
-	return 0;
 }
 
 static int ar9170_conf_tx(struct ieee80211_hw *hw, u16 queue,
@@ -1150,8 +1142,7 @@ static const struct ieee80211_ops ar9170
 	.bss_info_changed	= ar9170_op_bss_info_changed,
 	.get_tsf		= ar9170_op_get_tsf,
 	.set_key		= ar9170_set_key,
-	.sta_add		= ar9170_sta_add,
-	.sta_remove		= ar9170_sta_remove,
+	.sta_notify		= ar9170_sta_notify,
 	.ampdu_action		= ar9170_ampdu_action,
 };
 
@@ -1205,7 +1196,6 @@ void *ar9170_alloc(size_t priv_size)
 				     BIT(NL80211_IFTYPE_WDS) |
 				     BIT(NL80211_IFTYPE_ADHOC);
 	hw->flags |= IEEE80211_HW_RX_INCLUDES_FCS |
-		     IEEE80211_HW_REPORTS_TX_ACK_STATUS |
 		     IEEE80211_HW_SIGNAL_DBM |
 		     IEEE80211_HW_NOISE_DBM;
 
--- a/drivers/net/wireless/ath/carl9170/mac.c
+++ b/drivers/net/wireless/ath/carl9170/mac.c
@@ -420,7 +420,7 @@ int ar9170_set_beacon_timers(struct ar91
 		}
 
 		if (vif->type == NL80211_IFTYPE_STATION)
-			v |= ar->hw->conf.ps_dtim_period << 16;
+			v |= vif->bss_conf.dtim_period << 16;
 	}
 	rcu_read_unlock();
 
--- a/drivers/net/wireless/ath/carl9170/rx.c
+++ b/drivers/net/wireless/ath/carl9170/rx.c
@@ -488,9 +488,9 @@ static void ar9170_ps_beacon(struct ar91
 	tim_len = tim[1];
 	tim_ie = (struct ieee80211_tim_ie *) &tim[2];
 
-	if (!WARN_ON_ONCE(!ar->hw->conf.ps_dtim_period))
+	if (!WARN_ON_ONCE(!ar->vif->bss_conf.dtim_period))
 		ar->ps_dtim_counter = (tim_ie->dtim_count - 1) %
-			ar->hw->conf.ps_dtim_period;
+			ar->vif->bss_conf.dtim_period;
 
 	/* Check whenever the PHY can be turned off again. */
 

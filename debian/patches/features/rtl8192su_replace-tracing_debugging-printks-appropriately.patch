--- a/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c
+++ b/drivers/staging/rtl8192su/ieee80211/ieee80211_softmac.c
@@ -690,7 +690,7 @@ inline struct sk_buff *ieee80211_authent
 		auth->algorithm = WLAN_AUTH_SHARED_KEY;
 	else if(ieee->auth_mode == 2)
 		auth->algorithm = WLAN_AUTH_OPEN;//0x80;
-	printk("=================>%s():auth->algorithm is %d\n",__FUNCTION__,auth->algorithm);
+	IEEE80211_DEBUG_MGMT("=================>%s():auth->algorithm is %d\n",__FUNCTION__,auth->algorithm);
 	auth->transaction = cpu_to_le16(ieee->associate_seq);
 	ieee->associate_seq++;
 
@@ -1442,12 +1442,12 @@ void ieee80211_associate_complete_wq(str
 	}
 	ieee->link_change(ieee->dev);
 	if(ieee->is_silent_reset == 0){
-		printk("============>normal associate\n");
+		IEEE80211_DEBUG_MGMT("============>normal associate\n");
 	notify_wx_assoc_event(ieee);
 	}
 	else if(ieee->is_silent_reset == 1)
 	{
-		printk("==================>silent reset associate\n");
+		IEEE80211_DEBUG_MGMT("==================>silent reset associate\n");
 		ieee->is_silent_reset = 0;
 	}
 
@@ -1477,7 +1477,7 @@ void ieee80211_associate_procedure_wq(st
 		ieee->data_hard_stop(ieee->dev);
 
 	ieee80211_stop_scan(ieee);
-	printk("===>%s(), chan:%d\n", __FUNCTION__, ieee->current_network.channel);
+	IEEE80211_DEBUG_MGMT("===>%s(), chan:%d\n", __FUNCTION__, ieee->current_network.channel);
 	HTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);
 
 	if(ieee->eRFPowerState == eRfOff)
@@ -2107,7 +2107,7 @@ ieee80211_rx_frame_softmac(struct ieee80
 											bSupportNmode = false;
 											bHalfSupportNmode = false;
 										}
-									printk("==========>to link with AP using SEC(%d, %d)", bSupportNmode, bHalfSupportNmode);
+									IEEE80211_DEBUG_MGMT("==========>to link with AP using SEC(%d, %d)", bSupportNmode, bHalfSupportNmode);
 									}
 								}
 								/* Dummy wirless mode setting to avoid encryption issue */
@@ -2123,7 +2123,7 @@ ieee80211_rx_frame_softmac(struct ieee80
 
 								if (ieee->current_network.mode == IEEE_N_24G && bHalfSupportNmode == true)
 								{
-									printk("===============>entern half N mode\n");
+									IEEE80211_DEBUG_MGMT("===============>enter half N mode\n");
 									ieee->bHalfWirelessN24GMode = true;
 								}
 								else
@@ -2403,7 +2403,7 @@ void ieee80211_start_ibss_wq(struct work
 	 * on the semaphore
 	 */
 	if(!ieee->proto_started){
-		printk("==========oh driver down return\n");
+		IEEE80211_DEBUG_MGMT("==========oh driver down return\n");
 		return;
 	}
 	down(&ieee->wx_sem);
--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_BAProc.c
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_BAProc.c
@@ -158,7 +158,7 @@ static struct sk_buff* ieee80211_ADDBA(s
 	if (ACT_ADDBARSP == type)
 	{
 		// Status Code
-		printk("=====>to send ADDBARSP\n");
+		//printk("=====>to send ADDBARSP\n");
 		tmp = cpu_to_le16(StatusCode);
 		memcpy(tag, (u8*)&tmp, 2);
 		tag += 2;
@@ -359,7 +359,7 @@ int ieee80211_rx_ADDBAReq( struct ieee80
 	pBaTimeoutVal = (u16*)(tag + 5);
 	pBaStartSeqCtrl = (PSEQUENCE_CONTROL)(req + 7);
 
-	printk("====================>rx ADDBAREQ from :%pM\n", dst);
+	//printk("====================>rx ADDBAREQ from :%pM\n", dst);
 //some other capability is not ready now.
 	if(	(ieee->current_network.qos_data.active == 0) ||
 		(ieee->pHTInfo->bCurrentHTSupport == false) ||
--- a/drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c
+++ b/drivers/staging/rtl8192su/ieee80211/rtl819x_HTProc.c
@@ -546,7 +546,7 @@ u8 HTIOTActIsForcedCTS2Self(struct ieee8
 u8 HTIOTActIsForcedRTSCTS(struct ieee80211_device *ieee, struct ieee80211_network *network)
 {
 	u8	retValue = 0;
-	printk("============>%s(), %d\n", __FUNCTION__, network->realtek_cap_exit);
+	//printk("============>%s(), %d\n", __FUNCTION__, network->realtek_cap_exit);
 	// Force protection
 	if(ieee->pHTInfo->bCurrentHTSupport)
 	{
@@ -665,7 +665,7 @@ HTIOTActDetermineRaFunc(struct ieee80211
 	if(pHTInfo->IOTAction & HT_IOT_ACT_AMSDU_ENABLE)
 		pHTInfo->IOTRaFunc |= HT_IOT_RAFUNC_TX_AMSDU;
 
-	printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!IOTRaFunc = %8.8x\n", pHTInfo->IOTRaFunc);
+	IEEE80211_DEBUG("!!!!!!!!!!!!!!!!!!!!!!!!!!!IOTRaFunc = %8.8x\n", pHTInfo->IOTRaFunc);
 }
 
 
@@ -1548,7 +1548,7 @@ void HTResetSelfAndSavePeerSetting(struc
 		if(bIOTAction)
 			pHTInfo->IOTAction |= HT_IOT_ACT_FORCED_RTS;
 
-		printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!IOTAction = %8.8x\n", pHTInfo->IOTAction);
+		IEEE80211_DEBUG("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!IOTAction = %8.8x\n", pHTInfo->IOTAction);
 	}
 	else
 	{
--- a/drivers/staging/rtl8192su/r8192U_core.c
+++ b/drivers/staging/rtl8192su/r8192U_core.c
@@ -1284,7 +1284,6 @@ void rtl8192_set_chan(struct net_device
 	struct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);
 //	u32 tx;
 	RT_TRACE(COMP_CH, "=====>%s()====ch:%d\n", __FUNCTION__, ch);
-	//printk("=====>%s()====ch:%d\n", __FUNCTION__, ch);
 	priv->chan=ch;
 
 	/* this hack should avoid frame TX during channel setting*/
@@ -2015,7 +2014,7 @@ short rtl8192SU_tx_cmd(struct net_device
 	//----------------------------------------------------------------------------
 	// Get index to out pipe from specified QueueID.
 	idx_pipe = txqueue2outpipe(priv,queue_index);
-	//printk("=============>%s queue_index:%d, outpipe:%d\n", __func__,queue_index,priv->RtOutPipes[idx_pipe]);
+	//RT_TRACE("=============>%s queue_index:%d, outpipe:%d\n", __func__,queue_index,priv->RtOutPipes[idx_pipe]);
 
 	usb_fill_bulk_urb(tx_urb,
 	                            priv->udev,
@@ -2380,7 +2379,7 @@ short rtl8192SU_tx(struct net_device *de
 
 	/* Get index to out pipe from specified QueueID */
 	idx_pipe = txqueue2outpipe(priv,tcb_desc->queue_index);
-	//printk("=============>%s queue_index:%d, outpipe:%d\n", __func__,tcb_desc->queue_index,priv->RtOutPipes[idx_pipe]);
+	//RT_TRACE("=============>%s queue_index:%d, outpipe:%d\n", __func__,tcb_desc->queue_index,priv->RtOutPipes[idx_pipe]);
 
 	//RT_DEBUG_DATA(COMP_SEND,tx_fwinfo,sizeof(tx_fwinfo_819x_usb));
 	//RT_DEBUG_DATA(COMP_SEND,tx_desc,sizeof(tx_desc_819x_usb));
@@ -2590,7 +2589,7 @@ void rtl8192SU_update_ratr_table(struct
 				ratr_value &= 0x0f0ff0f5;
 				}
 			}
-			//printk("====>%s(), mode is not correct:%x\n", __FUNCTION__, ieee->mode);
+			//RT_TRACE("====>%s(), mode is not correct:%x\n", __FUNCTION__, ieee->mode);
 			break;
 	}
 
@@ -2615,15 +2614,15 @@ void rtl8192SU_update_ratr_table(struct
 		//printk("==>SG_RATE:%x\n", read_nic_byte(dev, SG_RATE));
 	}
 	write_nic_dword(dev, ARFR0+rate_index*4, ratr_value);
-	printk("=============>ARFR0+rate_index*4:%#x\n", ratr_value);
+	RT_TRACE("=============>ARFR0+rate_index*4:%#x\n", ratr_value);
 
 	//2 UFWP
 	if (ratr_value & 0xfffff000){
-		//printk("===>set to N mode\n");
+		//RT_TRACE("===>set to N mode\n");
 		HalSetFwCmd8192S(dev, FW_CMD_RA_REFRESH_N);
 	}
 	else	{
-		//printk("===>set to B/G mode\n");
+		//RT_TRACE("===>set to B/G mode\n");
 		HalSetFwCmd8192S(dev, FW_CMD_RA_REFRESH_BG);
 	}
 }
@@ -3035,7 +3034,7 @@ short rtl8192_is_tx_queue_empty(struct n
 			continue;
 		if (atomic_read(&priv->tx_pending[i]))
 		{
-			printk("===>tx queue is not empty:%d, %d\n", i, atomic_read(&priv->tx_pending[i]));
+			RT_TRACE("===>tx queue is not empty:%d, %d\n", i, atomic_read(&priv->tx_pending[i]));
 			return 0;
 		}
 	}
@@ -3059,11 +3058,11 @@ void rtl8192_hw_sleep_wq (struct work_st
         struct ieee80211_device *ieee = container_of(dwork,struct ieee80211_device,hw_sleep_wq);
         struct net_device *dev = ieee->dev;
 
-	//printk("=========>%s()\n", __FUNCTION__);
+	//RT_TRACE("=========>%s()\n", __FUNCTION__);
         rtl8192_hw_sleep_down(dev);
 }
-//	printk("dev is %d\n",dev);
-//	printk("&*&(^*(&(&=========>%s()\n", __FUNCTION__);
+//	RT_TRACE("dev is %d\n",dev);
+//	RT_TRACE("&*&(^*(&(&=========>%s()\n", __FUNCTION__);
 void rtl8192_hw_wakeup(struct net_device* dev)
 {
 //	u32 flags = 0;
@@ -3138,7 +3137,7 @@ void rtl8192_hw_to_sleep(struct net_devi
 #if 1
 	if(((tl > rb) && ((tl-rb) > MSECS(MAX_SLEEP_TIME)))||
 		((tl < rb) && ((rb-tl) > MSECS(MAX_SLEEP_TIME)))) {
-		printk("========>too long to sleep:%x, %x, %lx\n", tl, rb,  MSECS(MAX_SLEEP_TIME));
+		RT_TRACE("========>too long to sleep:%x, %x, %lx\n", tl, rb,  MSECS(MAX_SLEEP_TIME));
 		spin_unlock_irqrestore(&priv->ps_lock,flags);
 		return;
 	}
@@ -3146,7 +3145,7 @@ void rtl8192_hw_to_sleep(struct net_devi
 //	if(priv->rf_sleep)
 //		priv->rf_sleep(dev);
 
-	//printk("<=========%s()\n", __FUNCTION__);
+	//RT_TRACE("<=========%s()\n", __FUNCTION__);
 	queue_delayed_work(priv->ieee80211->wq, (void *)&priv->ieee80211->hw_sleep_wq,0);
 
 	spin_unlock_irqrestore(&priv->ps_lock,flags);
@@ -5430,7 +5429,7 @@ void CAM_read_entry(
 	 u8 entry_i=0;
 	 u32 ulStatus;
 	s32 i=100;
-//	printk("=======>start read CAM\n");
+//	RT_TRACE("=======>start read CAM\n");
  	for(entry_i=0;entry_i<CAM_CONTENT_COUNT;entry_i++)
  	{
    	// polling bit, and No Write enable, and address
@@ -5569,7 +5568,7 @@ void rtl819x_watchdog_wqcallback(struct
 void watch_dog_timer_callback(unsigned long data)
 {
 	struct r8192_priv *priv = ieee80211_priv((struct net_device *) data);
-	//printk("===============>watch_dog  timer\n");
+	//RT_TRACE("===============>watch_dog  timer\n");
 	queue_delayed_work(priv->priv_wq,&priv->watch_dog_wq, 0);
 	mod_timer(&priv->watch_dog_timer, jiffies + MSECS(IEEE80211_WATCH_DOG_TIME));
 }
@@ -7390,7 +7389,7 @@ static int __devinit rtl8192_usb_probe(s
 
 	HalUsbSetQueuePipeMapping8192SUsb(intf, dev);
 
-	//printk("===============>NIC 8192SU\n");
+	//RT_TRACE("===============>NIC 8192SU\n");
 	priv->ops = &rtl8192su_ops;
 
 	dev->netdev_ops = &rtl8192_netdev_ops;
--- a/drivers/staging/rtl8192su/r8192U_wx.c
+++ b/drivers/staging/rtl8192su/r8192U_wx.c
@@ -513,10 +513,10 @@ static int r8192_wx_set_scan(struct net_
 		struct iw_scan_req* req = (struct iw_scan_req*)b;
 		if (req->essid_len)
 		{
-			//printk("==**&*&*&**===>scan set ssid:%s\n", req->essid);
+			//RT_TRACE("==**&*&*&**===>scan set ssid:%s\n", req->essid);
 			ieee->current_network.ssid_len = req->essid_len;
 			memcpy(ieee->current_network.ssid, req->essid, req->essid_len);
-			//printk("=====>network ssid:%s\n", ieee->current_network.ssid);
+			//RT_TRACE("=====>network ssid:%s\n", ieee->current_network.ssid);
 		}
 	}
 
@@ -909,7 +909,7 @@ static int r8192_wx_set_enc_ext(struct n
 	int ret=0;
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	struct ieee80211_device* ieee = priv->ieee80211;
-	//printk("===>%s()\n", __FUNCTION__);
+	//RT_TRACE("===>%s()\n", __FUNCTION__);
 
 
 	down(&priv->wx_sem);
@@ -991,7 +991,7 @@ static int r8192_wx_set_auth(struct net_
 {
 	int ret=0;
 
-	//printk("====>%s()\n", __FUNCTION__);
+	//RT_TRACE("====>%s()\n", __FUNCTION__);
 	struct r8192_priv *priv = ieee80211_priv(dev);
 	down(&priv->wx_sem);
 	ret = ieee80211_wx_set_auth(priv->ieee80211, info, &(data->param), extra);
@@ -1003,7 +1003,7 @@ static int r8192_wx_set_mlme(struct net_
                                         struct iw_request_info *info,
                                         union iwreq_data *wrqu, char *extra)
 {
-	//printk("====>%s()\n", __FUNCTION__);
+	//RT_TRACE("====>%s()\n", __FUNCTION__);
 
 	int ret=0;
 	struct r8192_priv *priv = ieee80211_priv(dev);
@@ -1081,7 +1081,7 @@ static int r8192_wx_set_gen_ie(struct ne
                                         struct iw_request_info *info,
                                         union iwreq_data *data, char *extra)
 {
-	   //printk("====>%s(), len:%d\n", __FUNCTION__, data->length);
+	   //RT_TRACE("====>%s(), len:%d\n", __FUNCTION__, data->length);
 	int ret=0;
         struct r8192_priv *priv = ieee80211_priv(dev);
         down(&priv->wx_sem);
@@ -1089,7 +1089,7 @@ static int r8192_wx_set_gen_ie(struct ne
         ret = ieee80211_wx_set_gen_ie(priv->ieee80211, extra, data->data.length);
 #endif
         up(&priv->wx_sem);
-	//printk("<======%s(), ret:%d\n", __FUNCTION__, ret);
+	//RT_TRACE("<======%s(), ret:%d\n", __FUNCTION__, ret);
         return ret;
 
 
--- a/drivers/staging/rtl8192su/ieee80211/dot11d.c
+++ b/drivers/staging/rtl8192su/ieee80211/dot11d.c
@@ -31,8 +31,6 @@ Dot11d_Init(struct ieee80211_device *iee
 	memset(pDot11dInfo->channel_map, 0, MAX_CHANNEL_NUMBER+1);
 	memset(pDot11dInfo->MaxTxPwrDbmList, 0xFF, MAX_CHANNEL_NUMBER+1);
 	RESET_CIE_WATCHDOG(ieee);
-
-	printk("Dot11d_Init()\n");
 }
 
 //

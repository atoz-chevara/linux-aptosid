commit 36ef9a1e983e39c5f5929ce9660b7e01706fceec
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 10:02:49 2010 -0700

    Staging: brcm80211: util: s/uint8/u8/
    
    Replace uint8 with u8, the correct kernel type to be using here.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/util/bcmotp.c
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -808,7 +808,7 @@ static int hndotp_nvread(void *oh, char
 			/* Bad length, try to find another chunk anyway */
 			rsz = 6;
 		}
-		if (hndcrc16((uint8 *) &rawotp[i], rsz,
+		if (hndcrc16((u8 *) &rawotp[i], rsz,
 			     CRC16_INIT_VALUE) == CRC16_GOOD_VALUE) {
 			/* Good crc, copy the vars */
 			gchunks++;
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -50,8 +50,8 @@
 
 #define SROM_OFFSET(sih) ((sih->ccrev > 31) ? \
 	(((sih->cccaps & CC_CAP_SROM) == 0) ? NULL : \
-	 ((uint8 *)curmap + PCI_16KB0_CCREGS_OFFSET + CC_SROM_OTP)) : \
-	((uint8 *)curmap + PCI_BAR0_SPROM_OFFSET))
+	 ((u8 *)curmap + PCI_16KB0_CCREGS_OFFSET + CC_SROM_OTP)) : \
+	((u8 *)curmap + PCI_BAR0_SPROM_OFFSET))
 
 #if defined(BCMDBG)
 #define WRITE_ENABLE_DELAY	500	/* 500 ms after write enable/disable toggle */
@@ -70,14 +70,14 @@ extern uint _varsz;
 
 static int initvars_srom_si(si_t *sih, osl_t *osh, void *curmap, char **vars,
 			    uint *count);
-static void _initvars_srom_pci(uint8 sromrev, uint16 *srom, uint off,
+static void _initvars_srom_pci(u8 sromrev, uint16 *srom, uint off,
 			       varbuf_t *b);
 static int initvars_srom_pci(si_t *sih, void *curmap, char **vars,
 			     uint *count);
 static int initvars_flash_si(si_t *sih, char **vars, uint *count);
 #ifdef BCMSDIO
 static int initvars_cis_sdio(osl_t *osh, char **vars, uint *count);
-static int sprom_cmd_sdio(osl_t *osh, uint8 cmd);
+static int sprom_cmd_sdio(osl_t *osh, u8 cmd);
 static int sprom_read_sdio(osl_t *osh, uint16 addr, uint16 *data);
 #endif				/* BCMSDIO */
 static int sprom_read_pci(osl_t *osh, si_t *sih, uint16 *sprom, uint wordoff,
@@ -373,19 +373,19 @@ static const char BCMATTACHDATA(vstr_mac
 static const char BCMATTACHDATA(vstr_usbepnum)[] = "usbepnum=0x%x";
 static const char BCMATTACHDATA(vstr_end)[] = "END\0";
 
-uint8 patch_pair;
+u8 patch_pair;
 
 /* For dongle HW, accept partial calibration parameters */
 #define BCMDONGLECASE(n)
 
 int
-BCMATTACHFN(srom_parsecis) (osl_t *osh, uint8 *pcis[], uint ciscnt,
+BCMATTACHFN(srom_parsecis) (osl_t *osh, u8 *pcis[], uint ciscnt,
 			    char **vars, uint *count)
 {
 	char eabuf[32];
 	char *base;
 	varbuf_t b;
-	uint8 *cis, tup, tlen, sromrev = 1;
+	u8 *cis, tup, tlen, sromrev = 1;
 	int i, j;
 	bool ag_init = FALSE;
 	uint32 w32;
@@ -464,7 +464,7 @@ BCMATTACHFN(srom_parsecis) (osl_t *osh,
 				case CISTPL_FID_SDIO:
 #ifdef BCMSDIO
 					if (cis[i] == 0) {
-						uint8 spd = cis[i + 3];
+						u8 spd = cis[i + 3];
 						static int base[] = {
 							-1, 10, 12, 13, 15, 20,
 							    25, 30,
@@ -1337,7 +1337,7 @@ BCMATTACHFN(srom_parsecis) (osl_t *osh,
 				case HNBU_SROM3SWRGN:
 					if (tlen >= 73) {
 						uint16 srom[35];
-						uint8 srev = cis[i + 1 + 70];
+						u8 srev = cis[i + 1 + 70];
 						ASSERT(srev == 3);
 						/* make tuple value 16-bit aligned and parse it */
 						bcopy(&cis[i + 1], srom,
@@ -1462,7 +1462,7 @@ sprom_read_pci(osl_t *osh, si_t *sih, ui
 			if ((sih->cccaps & CC_CAP_SROM) == 0)
 				return 1;
 
-			ccregs = (void *)((uint8 *) sprom - CC_SROM_OTP);
+			ccregs = (void *)((u8 *) sprom - CC_SROM_OTP);
 			buf[i] =
 			    srom_cc_cmd(sih, osh, ccregs, SRC_OP_READ,
 					wordoff + i, 0);
@@ -1494,7 +1494,7 @@ sprom_read_pci(osl_t *osh, si_t *sih, ui
 
 		/* fixup the endianness so crc8 will pass */
 		htol16_buf(buf, nwords * 2);
-		if (hndcrc8((uint8 *) buf, nwords * 2, CRC8_INIT_VALUE) !=
+		if (hndcrc8((u8 *) buf, nwords * 2, CRC8_INIT_VALUE) !=
 		    CRC8_GOOD_VALUE) {
 			/* DBG only pci always read srom4 first, then srom8/9 */
 			/* BS_ERROR(("%s: bad crc\n", __func__)); */
@@ -1509,7 +1509,7 @@ sprom_read_pci(osl_t *osh, si_t *sih, ui
 #if defined(BCMNVRAMR)
 static int otp_read_pci(osl_t *osh, si_t *sih, uint16 *buf, uint bufsz)
 {
-	uint8 *otp;
+	u8 *otp;
 	uint sz = OTP_SZ_MAX / 2;	/* size in words */
 	int err = 0;
 
@@ -1542,7 +1542,7 @@ static int otp_read_pci(osl_t *osh, si_t
 
 	/* fixup the endianness so crc8 will pass */
 	htol16_buf(buf, bufsz);
-	if (hndcrc8((uint8 *) buf, SROM4_WORDS * 2, CRC8_INIT_VALUE) !=
+	if (hndcrc8((u8 *) buf, SROM4_WORDS * 2, CRC8_INIT_VALUE) !=
 	    CRC8_GOOD_VALUE) {
 		BS_ERROR(("%s: bad crc\n", __func__));
 		err = 1;
@@ -1705,7 +1705,7 @@ static bool mask_valid(uint16 mask)
 #endif				/* BCMDBG */
 
 static void
-BCMATTACHFN(_initvars_srom_pci) (uint8 sromrev, uint16 *srom, uint off,
+BCMATTACHFN(_initvars_srom_pci) (u8 sromrev, uint16 *srom, uint off,
 				 varbuf_t *b) {
 	uint16 w;
 	uint32 val;
@@ -1857,7 +1857,7 @@ static int
 BCMATTACHFN(initvars_srom_pci) (si_t *sih, void *curmap, char **vars,
 				uint *count) {
 	uint16 *srom, *sromwindow;
-	uint8 sromrev = 0;
+	u8 sromrev = 0;
 	uint32 sr;
 	varbuf_t b;
 	char *vp, *base = NULL;
@@ -1927,7 +1927,7 @@ BCMATTACHFN(initvars_srom_pci) (si_t *si
 
 		value = si_getdevpathvar(sih, "sromrev");
 		if (value) {
-			sromrev = (uint8) simple_strtoul(value, NULL, 0);
+			sromrev = (u8) simple_strtoul(value, NULL, 0);
 			flash = TRUE;
 			goto varscont;
 		}
@@ -2005,7 +2005,7 @@ BCMATTACHFN(initvars_srom_pci) (si_t *si
 static int
 BCMATTACHFN(initvars_cis_sdio) (osl_t *osh, char **vars, uint *count)
 {
-	uint8 *cis[SBSDIO_NUM_FUNCTION + 1];
+	u8 *cis[SBSDIO_NUM_FUNCTION + 1];
 	uint fn, numfn;
 	int rc = 0;
 
@@ -2039,9 +2039,9 @@ BCMATTACHFN(initvars_cis_sdio) (osl_t *o
 }
 
 /* set SDIO sprom command register */
-static int BCMATTACHFN(sprom_cmd_sdio) (osl_t *osh, uint8 cmd)
+static int BCMATTACHFN(sprom_cmd_sdio) (osl_t *osh, u8 cmd)
 {
-	uint8 status = 0;
+	u8 status = 0;
 	uint wait_cnt = 1000;
 
 	/* write sprom command register */
@@ -2061,10 +2061,10 @@ static int BCMATTACHFN(sprom_cmd_sdio) (
 /* read a word from the SDIO srom */
 static int sprom_read_sdio(osl_t *osh, uint16 addr, uint16 *data)
 {
-	uint8 addr_l, addr_h, data_l, data_h;
+	u8 addr_l, addr_h, data_l, data_h;
 
-	addr_l = (uint8) ((addr * 2) & 0xff);
-	addr_h = (uint8) (((addr * 2) >> 8) & 0xff);
+	addr_l = (u8) ((addr * 2) & 0xff);
+	addr_h = (u8) (((addr * 2) >> 8) & 0xff);
 
 	/* set address */
 	bcmsdh_cfg_write(NULL, SDIO_FUNC_1, SBSDIO_SPROM_ADDR_HIGH, addr_h,
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -154,7 +154,7 @@ void *BCMFASTPATH pktq_penq(struct pktq
 	pq->len++;
 
 	if (pq->hi_prec < prec)
-		pq->hi_prec = (uint8) prec;
+		pq->hi_prec = (u8) prec;
 
 	return p;
 }
@@ -181,7 +181,7 @@ void *BCMFASTPATH pktq_penq_head(struct
 	pq->len++;
 
 	if (pq->hi_prec < prec)
-		pq->hi_prec = (uint8) prec;
+		pq->hi_prec = (u8) prec;
 
 	return p;
 }
@@ -567,7 +567,7 @@ int getintvar(char *vars, const char *na
 	return simple_strtoul(val, NULL, 0);
 }
 
-int getintvararray(char *vars, const char *name, uint8 index)
+int getintvararray(char *vars, const char *name, u8 index)
 {
 	char *buf, *endp;
 	int i = 0;
@@ -855,7 +855,7 @@ int bcm_iovar_lencheck(const bcm_iovar_t
  * ****************************************************************************
  */
 
-static const uint8 crc8_table[256] = {
+static const u8 crc8_table[256] = {
 	0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
 	0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
 	0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
@@ -893,12 +893,12 @@ static const uint8 crc8_table[256] = {
 #define CRC_INNER_LOOP(n, c, x) \
 	((c) = ((c) >> 8) ^ crc##n##_table[((c) ^ (x)) & 0xff])
 
-uint8 BCMROMFN(hndcrc8) (uint8 *pdata,	/* pointer to array of data to process */
+u8 BCMROMFN(hndcrc8) (u8 *pdata,	/* pointer to array of data to process */
 			 uint nbytes,	/* number of input data bytes to process */
-			 uint8 crc	/* either CRC8_INIT_VALUE or previous return value */
+			 u8 crc	/* either CRC8_INIT_VALUE or previous return value */
     ) {
 	/* hard code the crc loop instead of using CRC_INNER_LOOP macro
-	 * to avoid the undefined and unnecessary (uint8 >> 8) operation.
+	 * to avoid the undefined and unnecessary (u8 >> 8) operation.
 	 */
 	while (nbytes-- > 0)
 		crc = crc8_table[(crc ^ *pdata++) & 0xff];
@@ -963,7 +963,7 @@ static const uint16 crc16_table[256] = {
 	0x7BC7, 0x6A4E, 0x58D5, 0x495C, 0x3DE3, 0x2C6A, 0x1EF1, 0x0F78
 };
 
-uint16 BCMROMFN(hndcrc16) (uint8 *pdata,	/* pointer to array of data to process */
+uint16 BCMROMFN(hndcrc16) (u8 *pdata,	/* pointer to array of data to process */
 			   uint nbytes,	/* number of input data bytes to process */
 			   uint16 crc	/* either CRC16_INIT_VALUE or previous return value */
     ) {
@@ -1021,7 +1021,7 @@ bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (voi
 		if ((elt->id == key) && (totlen >= (len + 2)))
 			return elt;
 
-		elt = (bcm_tlv_t *) ((uint8 *) elt + (len + 2));
+		elt = (bcm_tlv_t *) ((u8 *) elt + (len + 2));
 		totlen -= (len + 2);
 	}
 
@@ -1055,7 +1055,7 @@ bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tl
 		if ((id == key) && (totlen >= (len + 2)))
 			return elt;
 
-		elt = (bcm_tlv_t *) ((uint8 *) elt + (len + 2));
+		elt = (bcm_tlv_t *) ((u8 *) elt + (len + 2));
 		totlen -= (len + 2);
 	}
 	return NULL;
@@ -1120,7 +1120,7 @@ int bcm_format_hex(char *str, const void
 {
 	int i;
 	char *p = str;
-	const uint8 *src = (const uint8 *)bytes;
+	const u8 *src = (const u8 *)bytes;
 
 	for (i = 0; i < len; i++) {
 		p += snprintf(p, 3, "%02X", *src);
@@ -1187,11 +1187,11 @@ const char *bcm_crypto_algo_name(uint al
 #ifdef BCMDBG
 void deadbeef(void *p, uint len)
 {
-	static uint8 meat[] = { 0xde, 0xad, 0xbe, 0xef };
+	static u8 meat[] = { 0xde, 0xad, 0xbe, 0xef };
 
 	while (len-- > 0) {
-		*(uint8 *) p = meat[((uintptr) p) & 3];
-		p = (uint8 *) p + 1;
+		*(u8 *) p = meat[((uintptr) p) & 3];
+		p = (u8 *) p + 1;
 	}
 }
 #endif				/* BCMDBG */
@@ -1318,7 +1318,7 @@ static const uint16 nqdBm_to_mW_map[QDBM
 /* 185: */ 42170, 44668, 47315, 50119, 53088, 56234, 59566, 63096
 };
 
-uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 qdbm)
+uint16 BCMROMFN(bcm_qdbm_to_mw) (u8 qdbm)
 {
 	uint factor = 1;
 	int idx = qdbm - QDBM_OFFSET;
@@ -1342,9 +1342,9 @@ uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 q
 	return (nqdBm_to_mW_map[idx] + factor / 2) / factor;
 }
 
-uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw)
+u8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw)
 {
-	uint8 qdbm;
+	u8 qdbm;
 	int offset;
 	uint mw_uint = mw;
 	uint boundary;
@@ -1368,15 +1368,15 @@ uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 m
 			break;
 	}
 
-	qdbm += (uint8) offset;
+	qdbm += (u8) offset;
 
 	return qdbm;
 }
 
-uint BCMROMFN(bcm_bitcount) (uint8 *bitmap, uint length)
+uint BCMROMFN(bcm_bitcount) (u8 *bitmap, uint length)
 {
 	uint bitcount = 0, i;
-	uint8 tmp;
+	u8 tmp;
 	for (i = 0; i < length; i++) {
 		tmp = bitmap[i];
 		while (tmp) {
@@ -1419,7 +1419,7 @@ int bcm_bprintf(struct bcmstrbuf *b, con
 	return r;
 }
 
-void bcm_inc_bytes(uchar *num, int num_bytes, uint8 amount)
+void bcm_inc_bytes(uchar *num, int num_bytes, u8 amount)
 {
 	int i;
 
@@ -1431,7 +1431,7 @@ void bcm_inc_bytes(uchar *num, int num_b
 	}
 }
 
-int bcm_cmp_bytes(uchar *arg1, uchar *arg2, uint8 nbytes)
+int bcm_cmp_bytes(uchar *arg1, uchar *arg2, u8 nbytes)
 {
 	int i;
 
--- a/drivers/staging/brcm80211/util/bcmwifi.c
+++ b/drivers/staging/brcm80211/util/bcmwifi.c
@@ -180,9 +180,9 @@ bool wf_chspec_malformed(chanspec_t chan
  * channels this is just the channel number, for 40MHZ channels it is the upper or lowre 20MHZ
  * sideband depending on the chanspec selected
  */
-uint8 wf_chspec_ctlchan(chanspec_t chspec)
+u8 wf_chspec_ctlchan(chanspec_t chspec)
 {
-	uint8 ctl_chan;
+	u8 ctl_chan;
 
 	/* Is there a sideband ? */
 	if (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_NONE) {
@@ -210,7 +210,7 @@ uint8 wf_chspec_ctlchan(chanspec_t chspe
 chanspec_t wf_chspec_ctlchspec(chanspec_t chspec)
 {
 	chanspec_t ctl_chspec = 0;
-	uint8 channel;
+	u8 channel;
 
 	ASSERT(!wf_chspec_malformed(chspec));
 
--- a/drivers/staging/brcm80211/util/bcmwpa.c
+++ b/drivers/staging/brcm80211/util/bcmwpa.c
@@ -24,7 +24,7 @@
 /* Is this body of this tlvs entry a WFA entry? If
  * not update the tlvs buffer pointer/length.
  */
-bool bcm_is_wfa_ie(uint8 *ie, uint8 **tlvs, uint *tlvs_len, uint8 type)
+bool bcm_is_wfa_ie(u8 *ie, u8 **tlvs, uint *tlvs_len, u8 type)
 {
 	/* If the contents match the WFA_OUI and type */
 	if ((ie[TLV_LEN_OFF] > (WFA_OUI_LEN + 1)) &&
@@ -43,12 +43,12 @@ bool bcm_is_wfa_ie(uint8 *ie, uint8 **tl
 	return FALSE;
 }
 
-wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (uint8 * parse, uint len)
+wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (u8 * parse, uint len)
 {
 	bcm_tlv_t *ie;
 
 	while ((ie = bcm_parse_tlvs(parse, len, DOT11_MNG_VS_ID))) {
-		if (bcm_is_wpa_ie((uint8 *) ie, &parse, &len)) {
+		if (bcm_is_wpa_ie((u8 *) ie, &parse, &len)) {
 			return (wpa_ie_fixed_t *) ie;
 		}
 	}
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -222,7 +222,7 @@ static uintptr _dma_getvar(dma_info_t *d
 static void _dma_counterreset(dma_info_t *di);
 static void _dma_fifoloopbackenable(dma_info_t *di);
 static uint _dma_ctrlflags(dma_info_t *di, uint mask, uint flags);
-static uint8 dma_align_sizetobits(uint size);
+static u8 dma_align_sizetobits(uint size);
 static void *dma_ringalloc(osl_t *osh, uint32 boundary, uint size,
 			   uint16 *alignbits, uint *alloced,
 			   dmaaddr_t *descpa, osldma_t **dmah);
@@ -458,7 +458,7 @@ hnddma_t *dma_attach(osl_t *osh, char *n
 		di->rxbufsize = (uint16) rxbufsize;
 
 	di->nrxpost = (uint16) nrxpost;
-	di->rxoffset = (uint8) rxoffset;
+	di->rxoffset = (u8) rxoffset;
 
 	/*
 	 * figure out the DMA physical address offset for dd and data
@@ -1388,9 +1388,9 @@ void dma_txpioloopback(osl_t *osh, dma32
 }
 
 static
-uint8 dma_align_sizetobits(uint size)
+u8 dma_align_sizetobits(uint size)
 {
-	uint8 bitpos = 0;
+	u8 bitpos = 0;
 	ASSERT(size);
 	ASSERT(!(size & (size - 1)));
 	while (size >>= 1) {
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -55,10 +55,10 @@ static bool si_pmu_res_depfltr_npaldo(si
 static uint32 si_pmu_res_deps(si_t *sih, osl_t *osh, chipcregs_t *cc,
 			      uint32 rsrcs, bool all);
 static uint si_pmu_res_uptime(si_t *sih, osl_t *osh, chipcregs_t *cc,
-			      uint8 rsrc);
+			      u8 rsrc);
 static void si_pmu_res_masks(si_t *sih, uint32 * pmin, uint32 * pmax);
 static void si_pmu_spuravoid_pllupdate(si_t *sih, chipcregs_t *cc,
-				       osl_t *osh, uint8 spuravoid);
+				       osl_t *osh, u8 spuravoid);
 
 static void si_pmu_set_4330_plldivs(si_t *sih);
 
@@ -105,7 +105,7 @@ void si_pmu_pllupd(si_t *sih)
 /* Setup switcher voltage */
 void
 BCMATTACHFN(si_pmu_set_switcher_voltage) (si_t *sih, osl_t *osh,
-					  uint8 bb_voltage, uint8 rf_voltage) {
+					  u8 bb_voltage, u8 rf_voltage) {
 	chipcregs_t *cc;
 	uint origidx;
 
@@ -127,10 +127,10 @@ BCMATTACHFN(si_pmu_set_switcher_voltage)
 }
 
 void
-BCMATTACHFN(si_pmu_set_ldo_voltage) (si_t *sih, osl_t *osh, uint8 ldo,
-				     uint8 voltage) {
-	uint8 sr_cntl_shift = 0, rc_shift = 0, shift = 0, mask = 0;
-	uint8 addr = 0;
+BCMATTACHFN(si_pmu_set_ldo_voltage) (si_t *sih, osl_t *osh, u8 ldo,
+				     u8 voltage) {
+	u8 sr_cntl_shift = 0, rc_shift = 0, shift = 0, mask = 0;
+	u8 addr = 0;
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -291,7 +291,7 @@ uint32 BCMATTACHFN(si_pmu_force_ilp) (si
 
 /* Setup resource up/down timers */
 typedef struct {
-	uint8 resnum;
+	u8 resnum;
 	uint16 updown;
 } pmu_res_updown_t;
 
@@ -873,8 +873,8 @@ void BCMATTACHFN(si_pmu_res_init) (si_t
 /* setup pll and query clock speed */
 typedef struct {
 	uint16 freq;
-	uint8 xf;
-	uint8 wbint;
+	u8 xf;
+	u8 wbint;
 	uint32 wbfrac;
 } pmu0_xtaltab0_t;
 
@@ -903,10 +903,10 @@ static const pmu0_xtaltab0_t BCMINITDATA
 /* setup pll and query clock speed */
 typedef struct {
 	uint16 fref;
-	uint8 xf;
-	uint8 p1div;
-	uint8 p2div;
-	uint8 ndiv_int;
+	u8 xf;
+	u8 p1div;
+	u8 p2div;
+	u8 ndiv_int;
 	uint32 ndiv_frac;
 } pmu1_xtaltab0_t;
 
@@ -1212,7 +1212,7 @@ BCMATTACHFN(si_pmu1_pllinit0) (si_t *sih
 	const pmu1_xtaltab0_t *xt;
 	uint32 tmp;
 	uint32 buf_strength = 0;
-	uint8 ndiv_mode = 1;
+	u8 ndiv_mode = 1;
 
 	/* Use h/w default PLL config */
 	if (xtal == 0) {
@@ -1868,8 +1868,8 @@ uint32 BCMINITFN(si_pmu_ilp_clock) (si_t
 
 /* SDIO Pad drive strength to select value mappings */
 typedef struct {
-	uint8 strength;		/* Pad Drive Strength in mA */
-	uint8 sel;		/* Chip-specific select value */
+	u8 strength;		/* Pad Drive Strength in mA */
+	u8 sel;		/* Chip-specific select value */
 } sdiod_drive_str_t;
 
 /* SDIO Drive Strength to sel value table for PMU Rev 1 */
@@ -2013,7 +2013,7 @@ void BCMATTACHFN(si_pmu_init) (si_t *sih
 /* Return up time in ILP cycles for the given resource. */
 static uint
 BCMINITFN(si_pmu_res_uptime) (si_t *sih, osl_t *osh, chipcregs_t *cc,
-			      uint8 rsrc) {
+			      u8 rsrc) {
 	uint32 deps;
 	uint up, i, dup, dmax;
 	uint32 min_mask = 0, max_mask = 0;
@@ -2037,7 +2037,7 @@ BCMINITFN(si_pmu_res_uptime) (si_t *sih,
 	for (i = 0; i <= PMURES_MAX_RESNUM; i++) {
 		if (!(deps & PMURES_BIT(i)))
 			continue;
-		dup = si_pmu_res_uptime(sih, osh, cc, (uint8) i);
+		dup = si_pmu_res_uptime(sih, osh, cc, (u8) i);
 		if (dmax < dup)
 			dmax = dup;
 	}
@@ -2153,7 +2153,7 @@ void si_pmu_rcal(si_t *sih, osl_t *osh)
 
 	switch (CHIPID(sih->chip)) {
 	case BCM4329_CHIP_ID:{
-			uint8 rcal_code;
+			u8 rcal_code;
 			uint32 val;
 
 			/* Kick RCal */
@@ -2172,7 +2172,7 @@ void si_pmu_rcal(si_t *sih, osl_t *osh)
 
 			/* Drop the LSB to convert from 5 bit code to 4 bit code */
 			rcal_code =
-			    (uint8) (R_REG(osh, &cc->chipstatus) >> 5) & 0x0f;
+			    (u8) (R_REG(osh, &cc->chipstatus) >> 5) & 0x0f;
 
 			PMU_MSG(("RCal completed, status 0x%x, code 0x%x\n",
 				 R_REG(osh, &cc->chipstatus), rcal_code));
@@ -2222,7 +2222,7 @@ void si_pmu_rcal(si_t *sih, osl_t *osh)
 	si_setcoreidx(sih, origidx);
 }
 
-void si_pmu_spuravoid(si_t *sih, osl_t *osh, uint8 spuravoid)
+void si_pmu_spuravoid(si_t *sih, osl_t *osh, u8 spuravoid)
 {
 	chipcregs_t *cc;
 	uint origidx, intr_val;
@@ -2260,12 +2260,12 @@ void si_pmu_spuravoid(si_t *sih, osl_t *
 
 static void
 si_pmu_spuravoid_pllupdate(si_t *sih, chipcregs_t *cc, osl_t *osh,
-			   uint8 spuravoid)
+			   u8 spuravoid)
 {
 	uint32 tmp = 0;
-	uint8 phypll_offset = 0;
-	uint8 bcm5357_bcm43236_p1div[] = { 0x1, 0x5, 0x5 };
-	uint8 bcm5357_bcm43236_ndiv[] = { 0x30, 0xf6, 0xfc };
+	u8 phypll_offset = 0;
+	u8 bcm5357_bcm43236_p1div[] = { 0x1, 0x5, 0x5 };
+	u8 bcm5357_bcm43236_ndiv[] = { 0x30, 0xf6, 0xfc };
 
 	switch (CHIPID(sih->chip)) {
 	case BCM5357_CHIP_ID:
--- a/drivers/staging/brcm80211/util/linux_osl.c
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -468,12 +468,12 @@ void *osl_pktdup(osl_t *osh, void *skb)
 }
 
 #ifdef BCMSDIO
-uint8 osl_readb(osl_t *osh, volatile uint8 *r)
+u8 osl_readb(osl_t *osh, volatile u8 *r)
 {
 	osl_rreg_fn_t rreg = ((osl_pubinfo_t *) osh)->rreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
 
-	return (uint8) ((rreg) (ctx, (void *)r, sizeof(uint8)));
+	return (u8) ((rreg) (ctx, (void *)r, sizeof(u8)));
 }
 
 uint16 osl_readw(osl_t *osh, volatile uint16 *r)
@@ -492,12 +492,12 @@ uint32 osl_readl(osl_t *osh, volatile ui
 	return (uint32) ((rreg) (ctx, (void *)r, sizeof(uint32)));
 }
 
-void osl_writeb(osl_t *osh, volatile uint8 *r, uint8 v)
+void osl_writeb(osl_t *osh, volatile u8 *r, u8 v)
 {
 	osl_wreg_fn_t wreg = ((osl_pubinfo_t *) osh)->wreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
 
-	((wreg) (ctx, (void *)r, v, sizeof(uint8)));
+	((wreg) (ctx, (void *)r, v, sizeof(u8)));
 }
 
 void osl_writew(osl_t *osh, volatile uint16 *r, uint16 v)
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -37,12 +37,12 @@ typedef struct {
 
 	si_t *sih;		/* System interconnect handle */
 	osl_t *osh;		/* OSL handle */
-	uint8 pciecap_lcreg_offset;	/* PCIE capability LCreg offset in the config space */
+	u8 pciecap_lcreg_offset;	/* PCIE capability LCreg offset in the config space */
 	bool pcie_pr42767;
-	uint8 pcie_polarity;
-	uint8 pcie_war_aspm_ovr;	/* Override ASPM/Clkreq settings */
+	u8 pcie_polarity;
+	u8 pcie_war_aspm_ovr;	/* Override ASPM/Clkreq settings */
 
-	uint8 pmecap_offset;	/* PM Capability offset in the config space */
+	u8 pmecap_offset;	/* PM Capability offset in the config space */
 	bool pmecap;		/* Capable of generating PME */
 } pcicore_info_t;
 
@@ -128,7 +128,7 @@ void *pcicore_init(si_t *sih, osl_t *osh
 	pi->osh = osh;
 
 	if (sih->buscoretype == PCIE_CORE_ID) {
-		uint8 cap_ptr;
+		u8 cap_ptr;
 		pi->regs.pcieregs = (sbpcieregs_t *) regs;
 		cap_ptr =
 		    pcicore_find_pci_capability(pi->osh, PCI_CAP_PCIECAP_ID,
@@ -152,14 +152,14 @@ void pcicore_deinit(void *pch)
 
 /* return cap_offset if requested capability exists in the PCI config space */
 /* Note that it's caller's responsibility to make sure it's a pci bus */
-uint8
-pcicore_find_pci_capability(osl_t *osh, uint8 req_cap_id, uchar *buf,
+u8
+pcicore_find_pci_capability(osl_t *osh, u8 req_cap_id, uchar *buf,
 			    uint32 *buflen)
 {
-	uint8 cap_id;
-	uint8 cap_ptr = 0;
+	u8 cap_id;
+	u8 cap_ptr = 0;
 	uint32 bufsize;
-	uint8 byte_val;
+	u8 byte_val;
 
 	/* check for Header type 0 */
 	byte_val = read_pci_cfg_byte(PCI_CFG_HDR);
@@ -191,7 +191,7 @@ pcicore_find_pci_capability(osl_t *osh,
 	}
 	/* found the caller requested capability */
 	if ((buf != NULL) && (buflen != NULL)) {
-		uint8 cap_data;
+		u8 cap_data;
 
 		bufsize = *buflen;
 		if (!bufsize)
@@ -367,11 +367,11 @@ pcie_mdiowrite(pcicore_info_t *pi, uint
 }
 
 /* ***** Support functions ***** */
-uint8 pcie_clkreq(void *pch, uint32 mask, uint32 val)
+u8 pcie_clkreq(void *pch, uint32 mask, uint32 val)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
 	uint32 reg_val;
-	uint8 offset;
+	u8 offset;
 
 	offset = pi->pciecap_lcreg_offset;
 	if (!offset)
@@ -623,7 +623,7 @@ static void pcie_war_pci_setup(pcicore_i
 		pcie_misc_config_fixup(pi);
 }
 
-void pcie_war_ovr_aspm_update(void *pch, uint8 aspm)
+void pcie_war_ovr_aspm_update(void *pch, u8 aspm)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
 
@@ -724,7 +724,7 @@ void pcicore_down(void *pch, int state)
 /* Just uses PCI config accesses to find out, when needed before sb_attach is done */
 bool pcicore_pmecap_fast(osl_t *osh)
 {
-	uint8 cap_ptr;
+	u8 cap_ptr;
 	uint32 pmecap;
 
 	cap_ptr =
@@ -744,7 +744,7 @@ bool pcicore_pmecap_fast(osl_t *osh)
  */
 static bool pcicore_pmecap(pcicore_info_t *pi)
 {
-	uint8 cap_ptr;
+	u8 cap_ptr;
 	uint32 pmecap;
 
 	if (!pi->pmecap_offset) {
@@ -827,7 +827,7 @@ void pcicore_pmeclr(void *pch)
 uint32 pcie_lcreg(void *pch, uint32 mask, uint32 val)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
-	uint8 offset;
+	u8 offset;
 
 	offset = pi->pciecap_lcreg_offset;
 	if (!offset)
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -69,7 +69,7 @@ static char *si_devpathvar(si_t *sih, ch
 static bool _si_clkctl_cc(si_info_t *sii, uint mode);
 static bool si_ispcie(si_info_t *sii);
 static uint BCMINITFN(socram_banksize) (si_info_t *sii, sbsocramregs_t *r,
-					uint8 idx, uint8 mtype);
+					u8 idx, u8 mtype);
 
 /* global variable to indicate reservation/release of gpio's */
 static uint32 si_gpioreservation;
@@ -127,14 +127,14 @@ BCMATTACHFN(si_buscore_prep) (si_info_t
 #if defined(BCMSDIO)
 	if (BUSTYPE(bustype) == SDIO_BUS) {
 		int err;
-		uint8 clkset;
+		u8 clkset;
 
 		/* Try forcing SDIO core to do ALPAvail request only */
 		clkset = SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_ALP_AVAIL_REQ;
 		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
 				 clkset, &err);
 		if (!err) {
-			uint8 clkval;
+			u8 clkval;
 
 			/* If register supported, wait for ALPAvail and then force ALP */
 			clkval =
@@ -1914,7 +1914,7 @@ si_pcieserdesreg(si_t *sih, uint32 mdios
 /* return TRUE if PCIE capability exists in the pci config space */
 static __used bool si_ispcie(si_info_t *sii)
 {
-	uint8 cap_ptr;
+	u8 cap_ptr;
 
 	if (BUSTYPE(sii->pub.bustype) != PCI_BUS)
 		return FALSE;
@@ -2012,7 +2012,7 @@ bool BCMATTACHFN(si_pci_war16165) (si_t
  * but are in systems that still want the benefits of ASPM
  * Note that this should be done AFTER si_doattach
  */
-void si_pcie_war_ovr_update(si_t *sih, uint8 aspm)
+void si_pcie_war_ovr_update(si_t *sih, u8 aspm)
 {
 	si_info_t *sii;
 
@@ -2142,7 +2142,7 @@ void BCMATTACHFN(si_pci_setup) (si_t *si
 	}
 }
 
-uint8 si_pcieclkreq(si_t *sih, uint32 mask, uint32 val)
+u8 si_pcieclkreq(si_t *sih, uint32 mask, uint32 val)
 {
 	si_info_t *sii;
 
@@ -2229,7 +2229,7 @@ void *si_gpiosetcore(si_t *sih)
 }
 
 /* mask&set gpiocontrol bits */
-uint32 si_gpiocontrol(si_t *sih, uint32 mask, uint32 val, uint8 priority)
+uint32 si_gpiocontrol(si_t *sih, uint32 mask, uint32 val, u8 priority)
 {
 	uint regoff;
 
@@ -2250,7 +2250,7 @@ uint32 si_gpiocontrol(si_t *sih, uint32
 }
 
 /* mask&set gpio output enable bits */
-uint32 si_gpioouten(si_t *sih, uint32 mask, uint32 val, uint8 priority)
+uint32 si_gpioouten(si_t *sih, uint32 mask, uint32 val, u8 priority)
 {
 	uint regoff;
 
@@ -2271,7 +2271,7 @@ uint32 si_gpioouten(si_t *sih, uint32 ma
 }
 
 /* mask&set gpio output bits */
-uint32 si_gpioout(si_t *sih, uint32 mask, uint32 val, uint8 priority)
+uint32 si_gpioout(si_t *sih, uint32 mask, uint32 val, u8 priority)
 {
 	uint regoff;
 
@@ -2292,7 +2292,7 @@ uint32 si_gpioout(si_t *sih, uint32 mask
 }
 
 /* reserve one gpio */
-uint32 si_gpioreserve(si_t *sih, uint32 gpio_bitmask, uint8 priority)
+uint32 si_gpioreserve(si_t *sih, uint32 gpio_bitmask, u8 priority)
 {
 	si_info_t *sii;
 
@@ -2327,7 +2327,7 @@ uint32 si_gpioreserve(si_t *sih, uint32
  * persists till some one overwrites it
  */
 
-uint32 si_gpiorelease(si_t *sih, uint32 gpio_bitmask, uint8 priority)
+uint32 si_gpiorelease(si_t *sih, uint32 gpio_bitmask, u8 priority)
 {
 	si_info_t *sii;
 
@@ -2371,7 +2371,7 @@ uint32 si_gpioin(si_t *sih)
 }
 
 /* mask&set gpio interrupt polarity bits */
-uint32 si_gpiointpolarity(si_t *sih, uint32 mask, uint32 val, uint8 priority)
+uint32 si_gpiointpolarity(si_t *sih, uint32 mask, uint32 val, u8 priority)
 {
 	si_info_t *sii;
 	uint regoff;
@@ -2391,7 +2391,7 @@ uint32 si_gpiointpolarity(si_t *sih, uin
 }
 
 /* mask&set gpio interrupt mask bits */
-uint32 si_gpiointmask(si_t *sih, uint32 mask, uint32 val, uint8 priority)
+uint32 si_gpiointmask(si_t *sih, uint32 mask, uint32 val, u8 priority)
 {
 	si_info_t *sii;
 	uint regoff;
@@ -2573,8 +2573,8 @@ uint32 si_gpio_int_enable(si_t *sih, boo
 
 /* Return the size of the specified SOCRAM bank */
 static uint
-socram_banksize(si_info_t *sii, sbsocramregs_t *regs, uint8 index,
-		uint8 mem_type)
+socram_banksize(si_info_t *sii, sbsocramregs_t *regs, u8 index,
+		u8 mem_type)
 {
 	uint banksize, bankinfo;
 	uint bankidx = index | (mem_type << SOCRAM_BANKIDX_MEMTYPE_SHIFT);
@@ -2588,7 +2588,7 @@ socram_banksize(si_info_t *sii, sbsocram
 	return banksize;
 }
 
-void si_socdevram(si_t *sih, bool set, uint8 *enable, uint8 *protect)
+void si_socdevram(si_t *sih, bool set, u8 *enable, u8 *protect)
 {
 	si_info_t *sii;
 	uint origidx;
@@ -2619,8 +2619,8 @@ void si_socdevram(si_t *sih, bool set, u
 	corerev = si_corerev(sih);
 	if (corerev >= 10) {
 		uint32 extcinfo;
-		uint8 nb;
-		uint8 i;
+		u8 nb;
+		u8 i;
 		uint32 bankidx, bankinfo;
 
 		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
@@ -2702,8 +2702,8 @@ uint32 si_socdevram_size(si_t *sih)
 	corerev = si_corerev(sih);
 	if (corerev >= 10) {
 		uint32 extcinfo;
-		uint8 nb;
-		uint8 i;
+		u8 nb;
+		u8 i;
 
 		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
 		nb = (((extcinfo & SOCRAM_DEVRAMBANK_MASK) >>
@@ -2772,7 +2772,7 @@ uint32 si_socram_size(si_t *sih)
 		if (lss != 0)
 			memsize += (1 << ((lss - 1) + SR_BSZ_BASE));
 	} else {
-		uint8 i;
+		u8 i;
 		uint nb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
 		for (i = 0; i < nb; i++)
 			memsize +=
@@ -2979,7 +2979,7 @@ int si_cis_source(si_t *sih)
 	case BCM43235_CHIP_ID:
 	case BCM43236_CHIP_ID:
 	case BCM43238_CHIP_ID:{
-			uint8 strap =
+			u8 strap =
 			    (sih->
 			     chipst & CST4322_SPROM_OTP_SEL_MASK) >>
 			    CST4322_SPROM_OTP_SEL_SHIFT;

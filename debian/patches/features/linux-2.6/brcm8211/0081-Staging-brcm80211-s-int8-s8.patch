commit 562c8850786d8d1a9e3f9f076deb581962c594ab
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 11:04:17 2010 -0700

    Staging: brcm80211: s/int8/s8/
    
    This changes the usage everywhere in the driver, and removes
    the definition as it should no longer be used anywhere.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
@@ -157,12 +157,12 @@ static void wl_clear_sdio_func(void);
 /*
 ** ioctl utilites
 */
-static int32 wl_dev_bufvar_get(struct net_device *dev, int8 *name, int8 *buf,
+static int32 wl_dev_bufvar_get(struct net_device *dev, s8 *name, s8 *buf,
 			       int32 buf_len);
-static __used int32 wl_dev_bufvar_set(struct net_device *dev, int8 *name,
-				      int8 *buf, int32 len);
-static int32 wl_dev_intvar_set(struct net_device *dev, int8 *name, int32 val);
-static int32 wl_dev_intvar_get(struct net_device *dev, int8 *name,
+static __used int32 wl_dev_bufvar_set(struct net_device *dev, s8 *name,
+				      s8 *buf, int32 len);
+static int32 wl_dev_intvar_set(struct net_device *dev, s8 *name, int32 val);
+static int32 wl_dev_intvar_get(struct net_device *dev, s8 *name,
 			       int32 *retval);
 static int32 wl_dev_ioctl(struct net_device *dev, uint32 cmd, void *arg,
 			  uint32 len);
@@ -276,7 +276,7 @@ static int32 wl_dongle_scantime(struct n
 				int32 scan_unassoc_time);
 static int32 wl_dongle_offload(struct net_device *ndev, int32 arpoe,
 			       int32 arp_ol);
-static int32 wl_pattern_atoh(int8 *src, int8 *dst);
+static int32 wl_pattern_atoh(s8 *src, s8 *dst);
 static int32 wl_dongle_filter(struct net_device *ndev, uint32 filter_mode);
 static int32 wl_update_wiphybands(struct wl_priv *wl);
 #endif				/* !EMBEDDED_PLATFORM */
@@ -289,10 +289,10 @@ static void wl_iscan_timer(ulong data);
 static void wl_term_iscan(struct wl_priv *wl);
 static int32 wl_init_iscan(struct wl_priv *wl);
 static int32 wl_iscan_thread(void *data);
-static int32 wl_dev_iovar_setbuf(struct net_device *dev, int8 *iovar,
+static int32 wl_dev_iovar_setbuf(struct net_device *dev, s8 *iovar,
 				 void *param, int32 paramlen, void *bufptr,
 				 int32 buflen);
-static int32 wl_dev_iovar_getbuf(struct net_device *dev, int8 *iovar,
+static int32 wl_dev_iovar_getbuf(struct net_device *dev, s8 *iovar,
 				 void *param, int32 paramlen, void *bufptr,
 				 int32 buflen);
 static int32 wl_run_iscan(struct wl_iscan_ctrl *iscan, struct wlc_ssid *ssid,
@@ -350,7 +350,7 @@ extern int dhd_wait_pend8021x(struct net
 
 #if (WL_DBG_LEVEL > 0)
 #define WL_DBG_ESTR_MAX	32
-static int8 wl_dbg_estr[][WL_DBG_ESTR_MAX] = {
+static s8 wl_dbg_estr[][WL_DBG_ESTR_MAX] = {
 	"SET_SSID", "JOIN", "START", "AUTH", "AUTH_IND",
 	"DEAUTH", "DEAUTH_IND", "ASSOC", "ASSOC_IND", "REASSOC",
 	"REASSOC_IND", "DISASSOC", "DISASSOC_IND", "QUIET_START", "QUIET_END",
@@ -656,7 +656,7 @@ static void wl_iscan_prep(struct wl_scan
 }
 
 static int32
-wl_dev_iovar_setbuf(struct net_device *dev, int8 * iovar, void *param,
+wl_dev_iovar_setbuf(struct net_device *dev, s8 * iovar, void *param,
 		    int32 paramlen, void *bufptr, int32 buflen)
 {
 	int32 iolen;
@@ -668,7 +668,7 @@ wl_dev_iovar_setbuf(struct net_device *d
 }
 
 static int32
-wl_dev_iovar_getbuf(struct net_device *dev, int8 * iovar, void *param,
+wl_dev_iovar_getbuf(struct net_device *dev, s8 * iovar, void *param,
 		    int32 paramlen, void *bufptr, int32 buflen)
 {
 	int32 iolen;
@@ -868,9 +868,9 @@ wl_cfg80211_scan(struct wiphy *wiphy, st
 	return err;
 }
 
-static int32 wl_dev_intvar_set(struct net_device *dev, int8 *name, int32 val)
+static int32 wl_dev_intvar_set(struct net_device *dev, s8 *name, int32 val)
 {
-	int8 buf[WLC_IOCTL_SMLEN];
+	s8 buf[WLC_IOCTL_SMLEN];
 	uint32 len;
 	int32 err = 0;
 
@@ -886,10 +886,10 @@ static int32 wl_dev_intvar_set(struct ne
 }
 
 static int32
-wl_dev_intvar_get(struct net_device *dev, int8 *name, int32 *retval)
+wl_dev_intvar_get(struct net_device *dev, s8 *name, int32 *retval)
 {
 	union {
-		int8 buf[WLC_IOCTL_SMLEN];
+		s8 buf[WLC_IOCTL_SMLEN];
 		int32 val;
 	} var;
 	uint32 len;
@@ -1966,7 +1966,7 @@ static __used int32
 wl_update_pmklist(struct net_device *dev, struct wl_pmk_list *pmk_list,
 		  int32 err)
 {
-	int8 eabuf[ETHER_ADDR_STR_LEN];
+	s8 eabuf[ETHER_ADDR_STR_LEN];
 	int i, j;
 
 	memset(eabuf, 0, ETHER_ADDR_STR_LEN);
@@ -1993,7 +1993,7 @@ wl_cfg80211_set_pmksa(struct wiphy *wiph
 		      struct cfg80211_pmksa *pmksa)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
-	int8 eabuf[ETHER_ADDR_STR_LEN];
+	s8 eabuf[ETHER_ADDR_STR_LEN];
 	int32 err = 0;
 	int i;
 
@@ -2033,7 +2033,7 @@ wl_cfg80211_del_pmksa(struct wiphy *wiph
 		      struct cfg80211_pmksa *pmksa)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
-	int8 eabuf[ETHER_ADDR_STR_LEN];
+	s8 eabuf[ETHER_ADDR_STR_LEN];
 	struct _pmkid_list pmkid;
 	int32 err = 0;
 	int i;
@@ -2339,7 +2339,7 @@ wl_notify_connect_status(struct wl_priv
 	if (wl_is_linkup(wl, e)) {
 		wl_link_up(wl);
 		if (wl_is_ibssmode(wl)) {
-			cfg80211_ibss_joined(ndev, (int8 *)&e->addr,
+			cfg80211_ibss_joined(ndev, (s8 *)&e->addr,
 					     GFP_KERNEL);
 			WL_DBG(("joined in IBSS network\n"));
 		} else {
@@ -2375,7 +2375,7 @@ wl_notify_roaming_status(struct wl_priv
 }
 
 static __used int32
-wl_dev_bufvar_set(struct net_device *dev, int8 *name, int8 *buf, int32 len)
+wl_dev_bufvar_set(struct net_device *dev, s8 *name, s8 *buf, int32 len)
 {
 	struct wl_priv *wl = ndev_to_wl(dev);
 	uint32 buflen;
@@ -2387,7 +2387,7 @@ wl_dev_bufvar_set(struct net_device *dev
 }
 
 static int32
-wl_dev_bufvar_get(struct net_device *dev, int8 *name, int8 *buf,
+wl_dev_bufvar_get(struct net_device *dev, s8 *name, s8 *buf,
 		  int32 buf_len)
 {
 	struct wl_priv *wl = ndev_to_wl(dev);
@@ -2473,7 +2473,7 @@ static int32 wl_update_bss_info(struct w
 
 	ssid = (struct wlc_ssid *)wl_read_prof(wl, WL_PROF_SSID);
 	bss =
-	    cfg80211_get_bss(wl_to_wiphy(wl), NULL, (int8 *)&wl->bssid,
+	    cfg80211_get_bss(wl_to_wiphy(wl), NULL, (s8 *)&wl->bssid,
 			     ssid->SSID, ssid->SSID_len, WLAN_CAPABILITY_ESS,
 			     WLAN_CAPABILITY_ESS);
 
@@ -3155,8 +3155,8 @@ wl_cfg80211_event(struct net_device *nde
 	uint32 event_type = ntoh32(e->event_type);
 	struct wl_priv *wl = ndev_to_wl(ndev);
 #if (WL_DBG_LEVEL > 0)
-	int8 *estr = (event_type <= sizeof(wl_dbg_estr) / WL_DBG_ESTR_MAX - 1) ?
-	    wl_dbg_estr[event_type] : (int8 *) "Unknown";
+	s8 *estr = (event_type <= sizeof(wl_dbg_estr) / WL_DBG_ESTR_MAX - 1) ?
+	    wl_dbg_estr[event_type] : (s8 *) "Unknown";
 #endif				/* (WL_DBG_LEVEL > 0) */
 	WL_DBG(("event_type (%d):" "WLC_E_" "%s\n", event_type, estr));
 	if (likely(!wl_enq_event(wl, event_type, e, data)))
@@ -3318,7 +3318,7 @@ static int32 wl_dongle_power(struct net_
 static int32
 wl_dongle_glom(struct net_device *ndev, uint32 glom, uint32 dongle_align)
 {
-	int8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
+	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 						 '\0' + bitvec  */
 	int32 err = 0;
 
@@ -3344,7 +3344,7 @@ dongle_glom_out:
 static int32
 wl_dongle_roam(struct net_device *ndev, uint32 roamvar, uint32 bcn_timeout)
 {
-	int8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
+	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 						 '\0' + bitvec  */
 	int32 err = 0;
 
@@ -3375,9 +3375,9 @@ dongle_rom_out:
 static int32 wl_dongle_eventmsg(struct net_device *ndev)
 {
 
-	int8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
+	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 						 '\0' + bitvec  */
-	int8 eventmask[WL_EVENTING_MASK_LEN];
+	s8 eventmask[WL_EVENTING_MASK_LEN];
 	int32 err = 0;
 
 	/* Setup event_msgs */
@@ -3455,7 +3455,7 @@ dongle_scantime_out:
 static int32
 wl_dongle_offload(struct net_device *ndev, int32 arpoe, int32 arp_ol)
 {
-	int8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
+	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 							 '\0' + bitvec  */
 	int32 err = 0;
 
@@ -3483,7 +3483,7 @@ dongle_offload_out:
 	return err;
 }
 
-static int32 wl_pattern_atoh(int8 *src, int8 *dst)
+static int32 wl_pattern_atoh(s8 *src, s8 *dst)
 {
 #define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))
 	int i;
@@ -3508,16 +3508,16 @@ static int32 wl_pattern_atoh(int8 *src,
 
 static int32 wl_dongle_filter(struct net_device *ndev, uint32 filter_mode)
 {
-	int8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
+	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 							 '\0' + bitvec  */
-	const int8 *str;
+	const s8 *str;
 	struct wl_pkt_filter pkt_filter;
 	struct wl_pkt_filter *pkt_filterp;
 	int32 buf_len;
 	int32 str_len;
 	uint32 mask_size;
 	uint32 pattern_size;
-	int8 buf[256];
+	s8 buf[256];
 	int32 err = 0;
 
 /* add a default packet filter pattern */
@@ -3653,7 +3653,7 @@ static int32 wl_update_wiphybands(struct
 {
 	struct wiphy *wiphy;
 	int32 phy_list;
-	int8 phy;
+	s8 phy;
 	int32 err = 0;
 
 	if (unlikely
@@ -3925,7 +3925,7 @@ static void *wl_get_drvdata(struct wl_de
 	return dev->driver_data;
 }
 
-int32 wl_cfg80211_read_fw(int8 *buf, uint32 size)
+int32 wl_cfg80211_read_fw(s8 *buf, uint32 size)
 {
 	const struct firmware *fw_entry;
 	struct wl_priv *wl;
@@ -3951,7 +3951,7 @@ void wl_cfg80211_release_fw(void)
 	wl->fw->ptr = 0;
 }
 
-void *wl_cfg80211_request_fw(int8 *file_name)
+void *wl_cfg80211_request_fw(s8 *file_name)
 {
 	struct wl_priv *wl;
 	const struct firmware *fw_entry = NULL;
@@ -4001,7 +4001,7 @@ req_fw_out:
 	return (void *)fw_entry->data;
 }
 
-int8 *wl_cfg80211_get_fwname(void)
+s8 *wl_cfg80211_get_fwname(void)
 {
 	struct wl_priv *wl;
 
@@ -4010,7 +4010,7 @@ int8 *wl_cfg80211_get_fwname(void)
 	return wl->fw->fw_name;
 }
 
-int8 *wl_cfg80211_get_nvramname(void)
+s8 *wl_cfg80211_get_nvramname(void)
 {
 	struct wl_priv *wl;
 
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
@@ -203,7 +203,7 @@ struct wl_event_q {
 	struct list_head eq_list;
 	uint32 etype;
 	wl_event_msg_t emsg;
-	int8 edata[1];
+	s8 edata[1];
 };
 
 /* security information with currently associated ap */
@@ -219,7 +219,7 @@ struct wl_security {
 struct wl_ibss {
 	u8 beacon_interval;	/* in millisecond */
 	u8 atim;		/* in millisecond */
-	int8 join_only;
+	s8 join_only;
 	u8 band;
 	u8 channel;
 };
@@ -252,8 +252,8 @@ struct wl_iscan_ctrl {
 	struct completion exited;
 	struct wl_iscan_eloop el;
 	void *data;
-	int8 ioctl_buf[WLC_IOCTL_SMLEN];
-	int8 scan_buf[WL_ISCAN_BUF_MAX];
+	s8 ioctl_buf[WLC_IOCTL_SMLEN];
+	s8 scan_buf[WL_ISCAN_BUF_MAX];
 };
 
 /* association inform */
@@ -269,8 +269,8 @@ struct wl_fw_ctrl {
 	const struct firmware *fw_entry;
 	ulong status;
 	uint32 ptr;
-	int8 fw_name[WL_FILE_NAME_MAX];
-	int8 nvram_name[WL_FILE_NAME_MAX];
+	s8 fw_name[WL_FILE_NAME_MAX];
+	s8 nvram_name[WL_FILE_NAME_MAX];
 };
 
 /* assoc ie length */
@@ -370,14 +370,14 @@ extern int32 wl_cfg80211_up(void);	/* do
 extern int32 wl_cfg80211_down(void);	/* dongle down */
 extern void wl_cfg80211_dbg_level(uint32 level);	/* set dongle
 							 debugging level */
-extern void *wl_cfg80211_request_fw(int8 *file_name);	/* request fw /nvram
+extern void *wl_cfg80211_request_fw(s8 *file_name);	/* request fw /nvram
 							 downloading */
-extern int32 wl_cfg80211_read_fw(int8 *buf, uint32 size);	/* read fw
+extern int32 wl_cfg80211_read_fw(s8 *buf, uint32 size);	/* read fw
 								 image */
 extern void wl_cfg80211_release_fw(void);	/* release fw */
-extern int8 *wl_cfg80211_get_fwname(void);	/* get firmware name for
+extern s8 *wl_cfg80211_get_fwname(void);	/* get firmware name for
 						 the dongle */
-extern int8 *wl_cfg80211_get_nvramname(void);	/* get nvram name for
+extern s8 *wl_cfg80211_get_nvramname(void);	/* get nvram name for
 						 the dongle */
 
 #endif				/* _wl_cfg80211_h_ */
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -492,7 +492,7 @@ wl_iw_get_range(struct net_device *dev,
 	struct iw_range *range = (struct iw_range *)extra;
 	wl_uint32_list_t *list;
 	wl_rateset_t rateset;
-	int8 *channels;
+	s8 *channels;
 	int error, i, k;
 	uint sf, ch;
 
--- a/drivers/staging/brcm80211/include/bcm_xdr.h
+++ b/drivers/staging/brcm80211/include/bcm_xdr.h
@@ -37,8 +37,8 @@ int bcm_xdr_pack_uint32(bcm_xdr_buf_t *b
 int bcm_xdr_unpack_uint32(bcm_xdr_buf_t *b, uint32 *pval);
 int bcm_xdr_pack_int32(bcm_xdr_buf_t *b, int32 val);
 int bcm_xdr_unpack_int32(bcm_xdr_buf_t *b, int32 *pval);
-int bcm_xdr_pack_int8(bcm_xdr_buf_t *b, int8 val);
-int bcm_xdr_unpack_int8(bcm_xdr_buf_t *b, int8 *pval);
+int bcm_xdr_pack_s8(bcm_xdr_buf_t *b, s8 val);
+int bcm_xdr_unpack_s8(bcm_xdr_buf_t *b, s8 *pval);
 int bcm_xdr_pack_opaque(bcm_xdr_buf_t *b, uint len, void *data);
 int bcm_xdr_unpack_opaque(bcm_xdr_buf_t *b, uint len, void **pdata);
 int bcm_xdr_unpack_opaque_cpy(bcm_xdr_buf_t *b, uint len, void *data);
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -304,7 +304,7 @@ extern "C" {
 #define BCM_IOV_TYPE_INIT { \
 	"void", \
 	"bool", \
-	"int8", \
+	"s8", \
 	"u8", \
 	"int16", \
 	"uint16", \
--- a/drivers/staging/brcm80211/include/d11.h
+++ b/drivers/staging/brcm80211/include/d11.h
@@ -1331,11 +1331,11 @@ typedef struct wlc_d11rxhdr wlc_d11rxhdr
 BWL_PRE_PACKED_STRUCT struct wlc_d11rxhdr {
 	d11rxhdr_t rxhdr;
 	uint32 tsf_l;		/* TSF_L reading */
-	int8 rssi;		/* computed instanteneous rssi in BMAC */
-	int8 rxpwr0;		/* obsoleted, place holder for legacy ROM code. use rxpwr[] */
-	int8 rxpwr1;		/* obsoleted, place holder for legacy ROM code. use rxpwr[] */
-	int8 do_rssi_ma;	/* do per-pkt sampling for per-antenna ma in HIGH */
-	int8 rxpwr[WL_RSSI_ANT_MAX];	/* rssi for supported antennas */
+	s8 rssi;		/* computed instanteneous rssi in BMAC */
+	s8 rxpwr0;		/* obsoleted, place holder for legacy ROM code. use rxpwr[] */
+	s8 rxpwr1;		/* obsoleted, place holder for legacy ROM code. use rxpwr[] */
+	s8 do_rssi_ma;	/* do per-pkt sampling for per-antenna ma in HIGH */
+	s8 rxpwr[WL_RSSI_ANT_MAX];	/* rssi for supported antennas */
 } BWL_POST_PACKED_STRUCT;
 
 /* PhyRxStatus_0: */
--- a/drivers/staging/brcm80211/include/typedefs.h
+++ b/drivers/staging/brcm80211/include/typedefs.h
@@ -56,7 +56,7 @@ typedef unsigned int uint;
 typedef unsigned long ulong;
 #endif
 
-/* define [u]int8/16/32/64, uintptr */
+/* define [u]int16/32/64, uintptr */
 
 #ifndef TYPEDEF_UINT16
 typedef unsigned short uint16;
@@ -70,10 +70,6 @@ typedef unsigned int uint32;
 typedef unsigned int uintptr;
 #endif
 
-#ifndef TYPEDEF_INT8
-typedef signed char int8;
-#endif
-
 #ifndef TYPEDEF_INT16
 typedef signed short int16;
 #endif
@@ -109,7 +105,6 @@ typedef signed int int32;
 #undef TYPEDEF_UINT16
 #undef TYPEDEF_UINT32
 #undef TYPEDEF_UINTPTR
-#undef TYPEDEF_INT8
 #undef TYPEDEF_INT16
 #undef TYPEDEF_INT32
 #undef TYPEDEF_FLOAT32
--- a/drivers/staging/brcm80211/include/wlioctl.h
+++ b/drivers/staging/brcm80211/include/wlioctl.h
@@ -56,7 +56,7 @@ typedef struct wl_bss_info_107 {
 	uint16 atim_window;	/* units are Kusec */
 	u8 dtim_period;	/* DTIM period */
 	int16 RSSI;		/* receive signal strength (in dBm) */
-	int8 phy_noise;		/* noise (in dBm) */
+	s8 phy_noise;		/* noise (in dBm) */
 	uint32 ie_length;	/* byte length of Information Elements */
 	/* variable length Information Elements */
 } wl_bss_info_107_t;
@@ -89,7 +89,7 @@ typedef struct wl_bss_info_108 {
 	uint16 atim_window;	/* units are Kusec */
 	u8 dtim_period;	/* DTIM period */
 	int16 RSSI;		/* receive signal strength (in dBm) */
-	int8 phy_noise;		/* noise (in dBm) */
+	s8 phy_noise;		/* noise (in dBm) */
 
 	u8 n_cap;		/* BSS is 802.11N Capable */
 	uint32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
@@ -133,7 +133,7 @@ typedef struct wl_bss_info {
 	uint16 atim_window;	/* units are Kusec */
 	u8 dtim_period;	/* DTIM period */
 	int16 RSSI;		/* receive signal strength (in dBm) */
-	int8 phy_noise;		/* noise (in dBm) */
+	s8 phy_noise;		/* noise (in dBm) */
 
 	u8 n_cap;		/* BSS is 802.11N Capable */
 	uint32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
@@ -176,10 +176,10 @@ typedef enum wl_scan_type {
 #define WL_BSS_FLAGS_RSSI_ONCHANNEL     0x04	/* rssi info was received on channel (vs offchannel) */
 
 typedef struct wl_extdscan_params {
-	int8 nprobes;		/* 0, passive, otherwise active */
-	int8 split_scan;	/* split scan */
-	int8 band;		/* band */
-	int8 pad;
+	s8 nprobes;		/* 0, passive, otherwise active */
+	s8 split_scan;	/* split scan */
+	s8 band;		/* band */
+	s8 pad;
 	wlc_ssid_t ssid[WLC_EXTDSCAN_MAX_SSID];	/* ssid list */
 	uint32 tx_rate;		/* in 500ksec units */
 	wl_scan_type_t scan_type;	/* enum */
@@ -201,7 +201,7 @@ typedef struct wl_extdscan_params {
 typedef struct wl_scan_params {
 	wlc_ssid_t ssid;	/* default: {0, ""} */
 	struct ether_addr bssid;	/* default: bcast */
-	int8 bss_type;		/* default: any,
+	s8 bss_type;		/* default: any,
 				 * DOT11_BSSTYPE_ANY/INFRASTRUCTURE/INDEPENDENT
 				 */
 	u8 scan_type;	/* flags, 0 use default */
@@ -474,8 +474,8 @@ typedef struct wl_country_list {
 #define WL_RM_FLAG_REFUSED	(1<<3)
 
 typedef struct wl_rm_req_elt {
-	int8 type;
-	int8 flags;
+	s8 type;
+	s8 flags;
 	chanspec_t chanspec;
 	uint32 token;		/* token for this measurement */
 	uint32 tsf_h;		/* TSF high 32-bits of Measurement start time */
@@ -493,8 +493,8 @@ typedef struct wl_rm_req {
 #define WL_RM_REQ_FIXED_LEN	OFFSETOF(wl_rm_req_t, req)
 
 typedef struct wl_rm_rep_elt {
-	int8 type;
-	int8 flags;
+	s8 type;
+	s8 flags;
 	chanspec_t chanspec;
 	uint32 token;		/* token for this measurement */
 	uint32 tsf_h;		/* TSF high 32-bits of Measurement start time */
@@ -508,7 +508,7 @@ typedef struct wl_rm_rep_elt {
 #define WL_RPI_REP_BIN_NUM 8
 typedef struct wl_rm_rpi_rep {
 	u8 rpi[WL_RPI_REP_BIN_NUM];
-	int8 rpi_max[WL_RPI_REP_BIN_NUM];
+	s8 rpi_max[WL_RPI_REP_BIN_NUM];
 } wl_rm_rpi_rep_t;
 
 typedef struct wl_rm_rep {
@@ -1213,7 +1213,7 @@ typedef struct wl_po {
 } wl_po_t;
 
 /* a large TX Power as an init value to factor out of MIN() calculations,
- * keep low enough to fit in an int8, units are .25 dBm
+ * keep low enough to fit in an s8, units are .25 dBm
  */
 #define WLC_TXPWR_MAX		(127)	/* ~32 dBm = 1,500 mW */
 
@@ -1373,7 +1373,7 @@ typedef struct wl_po {
 typedef struct {
 	uint32 version;		/* version field */
 	uint32 count;		/* number of valid antenna rssi */
-	int8 rssi_ant[WL_RSSI_ANT_MAX];	/* rssi per antenna */
+	s8 rssi_ant[WL_RSSI_ANT_MAX];	/* rssi per antenna */
 } wl_rssi_ant_t;
 
 #define NUM_PWRCTRL_RATES 12
@@ -1390,7 +1390,7 @@ typedef struct {
 	u8 txpwr_bphy_cck_max[NUM_PWRCTRL_RATES];	/* Max CCK power for this band (SROM) */
 	u8 txpwr_bphy_ofdm_max;	/* Max OFDM power for this band (SROM) */
 	u8 txpwr_aphy_max[NUM_PWRCTRL_RATES];	/* Max power for A band (SROM) */
-	int8 txpwr_antgain[2];	/* Ant gain for each band - from SROM */
+	s8 txpwr_antgain[2];	/* Ant gain for each band - from SROM */
 	u8 txpwr_est_Pout_gofdm;	/* Pwr estimate for 2.4 OFDM */
 } tx_power_legacy_t;
 
@@ -1406,7 +1406,7 @@ typedef struct {
 	chanspec_t local_chanspec;	/* channel on which we are associated */
 	u8 local_max;	/* local max according to the AP */
 	u8 local_constraint;	/* local constraint according to the AP */
-	int8 antgain[2];	/* Ant gain for each band - from SROM */
+	s8 antgain[2];	/* Ant gain for each band - from SROM */
 	u8 rf_cores;		/* count of RF Cores being reported */
 	u8 est_Pout[4];	/* Latest tx power out estimate per RF
 				 * chain without adjustment
@@ -1454,7 +1454,7 @@ typedef struct {
 	chanspec_t local_chanspec;	/* channel on which we are associated */
 	u8 local_max;	/* local max according to the AP */
 	u8 local_constraint;	/* local constraint according to the AP */
-	int8 antgain[2];	/* Ant gain for each band - from SROM */
+	s8 antgain[2];	/* Ant gain for each band - from SROM */
 	u8 rf_cores;		/* count of RF Cores being reported */
 	u8 est_Pout[4];	/* Latest tx power out estimate per RF chain */
 	u8 est_Pout_act[4];	/* Latest tx power out estimate per RF chain
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -130,10 +130,10 @@ static uint32 wlc_phy_get_radio_ver(phy_
 static void wlc_phy_timercb_phycal(void *arg);
 
 static bool wlc_phy_noise_calc_phy(phy_info_t *pi, uint32 *cmplx_pwr,
-				   int8 *pwr_ant);
+				   s8 *pwr_ant);
 
 static void wlc_phy_cal_perical_mphase_schedule(phy_info_t *pi, uint delay);
-static void wlc_phy_noise_cb(phy_info_t *pi, u8 channel, int8 noise_dbm);
+static void wlc_phy_noise_cb(phy_info_t *pi, u8 channel, s8 noise_dbm);
 static void wlc_phy_noise_sample_request(wlc_phy_t *pih, u8 reason,
 					 u8 ch);
 
@@ -141,11 +141,11 @@ static void wlc_phy_txpower_reg_limit_ca
 					   struct txpwr_limits *tp, chanspec_t);
 static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t *pi);
 
-static int8 wlc_user_txpwr_antport_to_rfport(phy_info_t *pi, uint chan,
+static s8 wlc_user_txpwr_antport_to_rfport(phy_info_t *pi, uint chan,
 					     uint32 band, u8 rate);
 static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t *pi, uint32 band);
-static int8 wlc_phy_env_measure_vbat(phy_info_t *pi);
-static int8 wlc_phy_env_measure_temperature(phy_info_t *pi);
+static s8 wlc_phy_env_measure_vbat(phy_info_t *pi);
+static s8 wlc_phy_env_measure_temperature(phy_info_t *pi);
 
 char *phy_getvar(phy_info_t *pi, const char *name)
 {
@@ -2412,8 +2412,8 @@ wlc_phy_txpower_get_current(wlc_phy_t *p
 				power->flags &=
 				    ~(WL_TX_POWER_F_HW | WL_TX_POWER_F_ENABLED);
 
-			wlc_lcnphy_get_tssi(pi, (int8 *) &power->est_Pout[0],
-					    (int8 *) &power->est_Pout_cck);
+			wlc_lcnphy_get_tssi(pi, (s8 *) &power->est_Pout[0],
+					    (s8 *) &power->est_Pout_cck);
 		}
 		wlc_phyreg_exit(ppi);
 	}
@@ -2504,9 +2504,9 @@ void wlc_phy_ant_rxdiv_set(wlc_phy_t *pp
 }
 
 static bool
-wlc_phy_noise_calc_phy(phy_info_t *pi, uint32 *cmplx_pwr, int8 *pwr_ant)
+wlc_phy_noise_calc_phy(phy_info_t *pi, uint32 *cmplx_pwr, s8 *pwr_ant)
 {
-	int8 cmplx_pwr_dbm[PHY_CORE_MAX];
+	s8 cmplx_pwr_dbm[PHY_CORE_MAX];
 	u8 i;
 
 	bzero((u8 *) cmplx_pwr_dbm, sizeof(cmplx_pwr_dbm));
@@ -2515,10 +2515,10 @@ wlc_phy_noise_calc_phy(phy_info_t *pi, u
 
 	for (i = 0; i < pi->pubpi.phy_corenum; i++) {
 		if (NREV_GE(pi->pubpi.phy_rev, 3))
-			cmplx_pwr_dbm[i] += (int8) PHY_NOISE_OFFSETFACT_4322;
+			cmplx_pwr_dbm[i] += (s8) PHY_NOISE_OFFSETFACT_4322;
 		else
 
-			cmplx_pwr_dbm[i] += (int8) (16 - (15) * 3 - 70);
+			cmplx_pwr_dbm[i] += (s8) (16 - (15) * 3 - 70);
 	}
 
 	for (i = 0; i < pi->pubpi.phy_corenum; i++) {
@@ -2534,7 +2534,7 @@ static void
 wlc_phy_noise_sample_request(wlc_phy_t *pih, u8 reason, u8 ch)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
+	s8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
 	bool sampling_in_progress = (pi->phynoise_state != 0);
 	bool wait_for_intr = TRUE;
 
@@ -2598,7 +2598,7 @@ wlc_phy_noise_sample_request(wlc_phy_t *
 		} else {
 			wlapi_suspend_mac_and_wait(pi->sh->physhim);
 			wlc_lcnphy_deaf_mode(pi, (bool) 0);
-			noise_dbm = (int8) wlc_lcnphy_rx_signal_power(pi, 20);
+			noise_dbm = (s8) wlc_lcnphy_rx_signal_power(pi, 20);
 			wlc_lcnphy_deaf_mode(pi, (bool) 1);
 			wlapi_enable_mac(pi->sh->physhim);
 			wait_for_intr = FALSE;
@@ -2617,7 +2617,7 @@ wlc_phy_noise_sample_request(wlc_phy_t *
 		} else {
 			phy_iq_est_t est[PHY_CORE_MAX];
 			uint32 cmplx_pwr[PHY_CORE_MAX];
-			int8 noise_dbm_ant[PHY_CORE_MAX];
+			s8 noise_dbm_ant[PHY_CORE_MAX];
 			uint16 log_num_samps, num_samps, classif_state = 0;
 			u8 wait_time = 32;
 			u8 wait_crs = 0;
@@ -2675,7 +2675,7 @@ void wlc_phy_noise_sample_request_extern
 	wlc_phy_noise_sample_request(pih, PHY_NOISE_SAMPLE_EXTERNAL, channel);
 }
 
-static void wlc_phy_noise_cb(phy_info_t *pi, u8 channel, int8 noise_dbm)
+static void wlc_phy_noise_cb(phy_info_t *pi, u8 channel, s8 noise_dbm)
 {
 	if (!pi->phynoise_state)
 		return;
@@ -2696,13 +2696,13 @@ static void wlc_phy_noise_cb(phy_info_t
 
 }
 
-static int8 wlc_phy_noise_read_shmem(phy_info_t *pi)
+static s8 wlc_phy_noise_read_shmem(phy_info_t *pi)
 {
 	uint32 cmplx_pwr[PHY_CORE_MAX];
-	int8 noise_dbm_ant[PHY_CORE_MAX];
+	s8 noise_dbm_ant[PHY_CORE_MAX];
 	uint16 lo, hi;
 	uint32 cmplx_pwr_tot = 0;
-	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
+	s8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
 	u8 idx, core;
 
 	ASSERT(pi->pubpi.phy_corenum <= PHY_CORE_MAX);
@@ -2743,7 +2743,7 @@ void wlc_phy_noise_sample_intr(wlc_phy_t
 	phy_info_t *pi = (phy_info_t *) pih;
 	uint16 jssi_aux;
 	u8 channel = 0;
-	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
+	s8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
 
 	if (ISLCNPHY(pi)) {
 		uint32 cmplx_pwr, cmplx_pwr0, cmplx_pwr1;
@@ -2774,10 +2774,10 @@ void wlc_phy_noise_sample_intr(wlc_phy_t
 			if (pwr_offset_dB > 127)
 				pwr_offset_dB -= 256;
 
-			noise_dbm += (int8) (pwr_offset_dB - 30);
+			noise_dbm += (s8) (pwr_offset_dB - 30);
 
 			gain_dB = (status_0 & 0x1ff);
-			noise_dbm -= (int8) (gain_dB);
+			noise_dbm -= (s8) (gain_dB);
 		} else {
 			noise_dbm = PHY_NOISE_FIXED_VAL_LCNPHY;
 		}
@@ -2795,7 +2795,7 @@ void wlc_phy_noise_sample_intr(wlc_phy_t
 
 }
 
-int8 lcnphy_gain_index_offset_for_pkt_rssi[] = {
+s8 lcnphy_gain_index_offset_for_pkt_rssi[] = {
 	8,
 	8,
 	8,
@@ -2836,7 +2836,7 @@ int8 lcnphy_gain_index_offset_for_pkt_rs
 	0
 };
 
-void wlc_phy_compute_dB(uint32 *cmplx_pwr, int8 *p_cmplx_pwr_dB, u8 core)
+void wlc_phy_compute_dB(uint32 *cmplx_pwr, s8 *p_cmplx_pwr_dB, u8 core)
 {
 	u8 shift_ct, lsb, msb, secondmsb, i;
 	uint32 tmp;
@@ -2852,7 +2852,7 @@ void wlc_phy_compute_dB(uint32 *cmplx_pw
 				msb = shift_ct;
 		}
 		secondmsb = (u8) ((cmplx_pwr[i] >> (msb - 1)) & 1);
-		p_cmplx_pwr_dB[i] = (int8) (3 * msb + 2 * secondmsb);
+		p_cmplx_pwr_dB[i] = (s8) (3 * msb + 2 * secondmsb);
 	}
 }
 
@@ -2905,7 +2905,7 @@ void BCMFASTPATH wlc_phy_rssi_compute(wl
 	}
 
  end:
-	wlc_rxhdr->rssi = (int8) rssi;
+	wlc_rxhdr->rssi = (s8) rssi;
 }
 
 void wlc_phy_freqtrack_start(wlc_phy_t *pih)
@@ -3004,7 +3004,7 @@ void wlc_phy_BSSinit(wlc_phy_t *pih, boo
 	uint k;
 
 	for (i = 0; i < MA_WINDOW_SZ; i++) {
-		pi->sh->phy_noise_window[i] = (int8) (rssi & 0xff);
+		pi->sh->phy_noise_window[i] = (s8) (rssi & 0xff);
 	}
 	if (ISLCNPHY(pi)) {
 		for (i = 0; i < MA_WINDOW_SZ; i++)
@@ -3301,7 +3301,7 @@ u8 wlc_phy_stf_chain_active_get(wlc_phy_
 	return active_bitmap;
 }
 
-int8 wlc_phy_stf_ssmode_get(wlc_phy_t *pih, chanspec_t chanspec)
+s8 wlc_phy_stf_ssmode_get(wlc_phy_t *pih, chanspec_t chanspec)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	u8 siso_mcs_id, cdd_mcs_id;
@@ -3362,18 +3362,18 @@ void wlc_lcnphy_epa_switch(phy_info_t *p
 	}
 }
 
-static int8
+static s8
 wlc_user_txpwr_antport_to_rfport(phy_info_t *pi, uint chan, uint32 band,
 				 u8 rate)
 {
-	int8 offset = 0;
+	s8 offset = 0;
 
 	if (!pi->user_txpwr_at_rfport)
 		return offset;
 	return offset;
 }
 
-static int8 wlc_phy_env_measure_vbat(phy_info_t *pi)
+static s8 wlc_phy_env_measure_vbat(phy_info_t *pi)
 {
 	if (ISLCNPHY(pi))
 		return wlc_lcnphy_vbatsense(pi, 0);
@@ -3381,7 +3381,7 @@ static int8 wlc_phy_env_measure_vbat(phy
 		return 0;
 }
 
-static int8 wlc_phy_env_measure_temperature(phy_info_t *pi)
+static s8 wlc_phy_env_measure_temperature(phy_info_t *pi)
 {
 	if (ISLCNPHY(pi))
 		return wlc_lcnphy_tempsense_degree(pi, 0);
@@ -3392,7 +3392,7 @@ static int8 wlc_phy_env_measure_temperat
 static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t *pi, uint32 band)
 {
 	u8 i;
-	int8 temp, vbat;
+	s8 temp, vbat;
 
 	for (i = 0; i < TXP_NUM_RATES; i++)
 		pi->txpwr_env_limit[i] = WLC_TXPWR_MAX;
@@ -3408,7 +3408,7 @@ void wlc_phy_ldpc_override_set(wlc_phy_t
 }
 
 void
-wlc_phy_get_pwrdet_offsets(phy_info_t *pi, int8 *cckoffset, int8 *ofdmoffset)
+wlc_phy_get_pwrdet_offsets(phy_info_t *pi, s8 *cckoffset, s8 *ofdmoffset)
 {
 	*cckoffset = 0;
 	*ofdmoffset = 0;
@@ -3441,7 +3441,7 @@ uint32 wlc_phy_qdiv_roundup(uint32 divid
 	return quotient;
 }
 
-int8 wlc_phy_upd_rssi_offset(phy_info_t *pi, int8 rssi, chanspec_t chanspec)
+s8 wlc_phy_upd_rssi_offset(phy_info_t *pi, s8 rssi, chanspec_t chanspec)
 {
 
 	return rssi;
--- a/drivers/staging/brcm80211/phy/wlc_phy_hal.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_hal.h
@@ -224,7 +224,7 @@ extern void wlc_phy_stf_chain_set(wlc_ph
 extern void wlc_phy_stf_chain_get(wlc_phy_t *pih, u8 *txchain,
 				  u8 *rxchain);
 extern u8 wlc_phy_stf_chain_active_get(wlc_phy_t *pih);
-extern int8 wlc_phy_stf_ssmode_get(wlc_phy_t *pih, chanspec_t chanspec);
+extern s8 wlc_phy_stf_ssmode_get(wlc_phy_t *pih, chanspec_t chanspec);
 extern void wlc_phy_ldpc_override_set(wlc_phy_t *ppi, bool val);
 
 extern void wlc_phy_cal_perical(wlc_phy_t *ppi, u8 reason);
@@ -257,7 +257,7 @@ extern void wlc_phy_freqtrack_end(wlc_ph
 
 extern const u8 *wlc_phy_get_ofdm_rate_lookup(void);
 
-extern int8 wlc_phy_get_tx_power_offset_by_mcs(wlc_phy_t *ppi,
+extern s8 wlc_phy_get_tx_power_offset_by_mcs(wlc_phy_t *ppi,
 					       u8 mcs_offset);
-extern int8 wlc_phy_get_tx_power_offset(wlc_phy_t *ppi, u8 tbl_offset);
+extern s8 wlc_phy_get_tx_power_offset(wlc_phy_t *ppi, u8 tbl_offset);
 #endif				/* _wlc_phy_h_ */
--- a/drivers/staging/brcm80211/phy/wlc_phy_int.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_int.h
@@ -408,8 +408,8 @@ typedef struct {
 } aci_save_gphy_t;
 
 typedef struct _lo_complex_t {
-	int8 i;
-	int8 q;
+	s8 i;
+	s8 q;
 } lo_complex_abgphy_info_t;
 
 typedef struct _nphy_iq_comp {
@@ -420,9 +420,9 @@ typedef struct _nphy_iq_comp {
 } nphy_iq_comp_t;
 
 typedef struct _nphy_txpwrindex {
-	int8 index;
-	int8 index_internal;
-	int8 index_internal_save;
+	s8 index;
+	s8 index_internal;
+	s8 index_internal_save;
 	uint16 AfectrlOverride;
 	uint16 AfeCtrlDacGain;
 	uint16 rad_gain;
@@ -444,15 +444,15 @@ typedef struct {
 } txiqcal_cache_t;
 
 typedef struct _nphy_pwrctrl {
-	int8 max_pwr_2g;
-	int8 idle_targ_2g;
+	s8 max_pwr_2g;
+	s8 idle_targ_2g;
 	int16 pwrdet_2g_a1;
 	int16 pwrdet_2g_b0;
 	int16 pwrdet_2g_b1;
-	int8 max_pwr_5gm;
-	int8 idle_targ_5gm;
-	int8 max_pwr_5gh;
-	int8 max_pwr_5gl;
+	s8 max_pwr_5gm;
+	s8 idle_targ_5gm;
+	s8 max_pwr_5gh;
+	s8 max_pwr_5gl;
 	int16 pwrdet_5gm_a1;
 	int16 pwrdet_5gm_b0;
 	int16 pwrdet_5gm_b1;
@@ -462,11 +462,11 @@ typedef struct _nphy_pwrctrl {
 	int16 pwrdet_5gh_a1;
 	int16 pwrdet_5gh_b0;
 	int16 pwrdet_5gh_b1;
-	int8 idle_targ_5gl;
-	int8 idle_targ_5gh;
-	int8 idle_tssi_2g;
-	int8 idle_tssi_5g;
-	int8 idle_tssi;
+	s8 idle_targ_5gl;
+	s8 idle_targ_5gh;
+	s8 idle_tssi_2g;
+	s8 idle_tssi_5g;
+	s8 idle_tssi;
 	int16 a1;
 	int16 b0;
 	int16 b1;
@@ -551,7 +551,7 @@ struct shared_phy {
 	uint slow_timer;
 	uint glacial_timer;
 	u8 rx_antdiv;
-	int8 phy_noise_window[MA_WINDOW_SZ];
+	s8 phy_noise_window[MA_WINDOW_SZ];
 	uint phy_noise_index;
 	u8 hw_phytxchain;
 	u8 hw_phyrxchain;
@@ -650,7 +650,7 @@ struct phy_info {
 	u8 tx_srom_max_rate_5g_mid[TXP_NUM_RATES];
 	u8 tx_srom_max_rate_5g_hi[TXP_NUM_RATES];
 	u8 tx_user_target[TXP_NUM_RATES];
-	int8 tx_power_offset[TXP_NUM_RATES];
+	s8 tx_power_offset[TXP_NUM_RATES];
 	u8 tx_power_target[TXP_NUM_RATES];
 
 	srom_fem_t srom_fem2g;
@@ -660,19 +660,19 @@ struct phy_info {
 	u8 tx_power_max_rate_ind;
 	bool hwpwrctrl;
 	u8 nphy_txpwrctrl;
-	int8 nphy_txrx_chain;
+	s8 nphy_txrx_chain;
 	bool phy_5g_pwrgain;
 
 	uint16 phy_wreg;
 	uint16 phy_wreg_limit;
 
-	int8 n_preamble_override;
+	s8 n_preamble_override;
 	u8 antswitch;
 	u8 aa2g, aa5g;
 
-	int8 idle_tssi[CH_5G_GROUP];
-	int8 target_idle_tssi;
-	int8 txpwr_est_Pout;
+	s8 idle_tssi[CH_5G_GROUP];
+	s8 target_idle_tssi;
+	s8 txpwr_est_Pout;
 	u8 tx_power_min;
 	u8 txpwr_limit[TXP_NUM_RATES];
 	u8 txpwr_env_limit[TXP_NUM_RATES];
@@ -707,16 +707,16 @@ struct phy_info {
 	bool phy_fixed_noise;
 	uint32 xtalfreq;
 	u8 pdiv;
-	int8 carrier_suppr_disable;
+	s8 carrier_suppr_disable;
 
 	bool phy_bphy_evm;
 	bool phy_bphy_rfcs;
-	int8 phy_scraminit;
+	s8 phy_scraminit;
 	u8 phy_gpiosel;
 
 	int16 phy_txcore_disable_temp;
 	int16 phy_txcore_enable_temp;
-	int8 phy_tempsense_offset;
+	s8 phy_tempsense_offset;
 	bool phy_txcore_heatedup;
 
 	uint16 radiopwr;
@@ -726,7 +726,7 @@ struct phy_info {
 	uint16 mintxbias;
 	uint16 mintxmag;
 	lo_complex_abgphy_info_t gphy_locomp_iq[STATIC_NUM_RF][STATIC_NUM_BB];
-	int8 stats_11b_txpower[STATIC_NUM_RF][STATIC_NUM_BB];
+	s8 stats_11b_txpower[STATIC_NUM_RF][STATIC_NUM_BB];
 	uint16 gain_table[TX_GAIN_TABLE_LENGTH];
 	bool loopback_gain;
 	int16 max_lpback_gain_hdB;
@@ -740,7 +740,7 @@ struct phy_info {
 	int min_rssi;
 	int max_rssi;
 
-	int8 txpwridx;
+	s8 txpwridx;
 	u8 min_txpower;
 
 	u8 a_band_high_disable;
@@ -760,10 +760,10 @@ struct phy_info {
 	uint txmag_len;
 	bool txmag_enable;
 
-	int8 *a_tssi_to_dbm;
-	int8 *m_tssi_to_dbm;
-	int8 *l_tssi_to_dbm;
-	int8 *h_tssi_to_dbm;
+	s8 *a_tssi_to_dbm;
+	s8 *m_tssi_to_dbm;
+	s8 *l_tssi_to_dbm;
+	s8 *h_tssi_to_dbm;
 	u8 *hwtxpwr;
 
 	uint16 freqtrack_saved_regs[2];
@@ -780,7 +780,7 @@ struct phy_info {
 	u8 phy_aa2g;
 
 	bool nphy_tableloaded;
-	int8 nphy_rssisel;
+	s8 nphy_rssisel;
 	uint32 nphy_bb_mult_save;
 	uint16 nphy_txiqlocal_bestc[11];
 	bool nphy_txiqlocal_coeffsvalid;
@@ -907,7 +907,7 @@ struct phy_info {
 
 	uint16 nphy_fineclockgatecontrol;
 
-	int8 rx2tx_biasentry;
+	s8 rx2tx_biasentry;
 
 	uint16 crsminpwr0;
 	uint16 crsminpwrl0;
@@ -932,7 +932,7 @@ struct phy_info {
 	uint tbl_save_offset;
 
 	u8 txpwrctrl;
-	int8 txpwrindex[PHY_CORE_MAX];
+	s8 txpwrindex[PHY_CORE_MAX];
 
 	u8 phycal_tempdelta;
 	uint32 mcs20_po;
@@ -1026,7 +1026,7 @@ extern void wlc_phy_txpower_update_shm(p
 extern void wlc_phy_cordic(fixed theta, cint32 *val);
 extern u8 wlc_phy_nbits(int32 value);
 extern uint32 wlc_phy_sqrt_int(uint32 value);
-extern void wlc_phy_compute_dB(uint32 *cmplx_pwr, int8 *p_dB, u8 core);
+extern void wlc_phy_compute_dB(uint32 *cmplx_pwr, s8 *p_dB, u8 core);
 
 extern uint wlc_phy_init_radio_regs_allbands(phy_info_t *pi,
 					     radio_20xx_regs_t *radioregs);
@@ -1062,7 +1062,7 @@ extern int wlc_phy_chanspec_freq2bandran
 extern int wlc_phy_chanspec_bandrange_get(phy_info_t *, chanspec_t);
 
 extern void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t *pi, uint16 mode);
-extern int8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t *pi);
+extern s8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t *pi);
 
 extern void wlc_phy_txpower_recalc_target_nphy(phy_info_t *pi);
 extern void wlc_lcnphy_txpower_recalc_target(phy_info_t *pi);
@@ -1086,8 +1086,8 @@ extern void wlc_phy_mcs_to_ofdm_powers_n
 
 extern uint16 wlc_lcnphy_tempsense(phy_info_t *pi, bool mode);
 extern int16 wlc_lcnphy_tempsense_new(phy_info_t *pi, bool mode);
-extern int8 wlc_lcnphy_tempsense_degree(phy_info_t *pi, bool mode);
-extern int8 wlc_lcnphy_vbatsense(phy_info_t *pi, bool mode);
+extern s8 wlc_lcnphy_tempsense_degree(phy_info_t *pi, bool mode);
+extern s8 wlc_lcnphy_vbatsense(phy_info_t *pi, bool mode);
 extern void wlc_phy_carrier_suppress_lcnphy(phy_info_t *pi);
 extern void wlc_lcnphy_crsuprs(phy_info_t *pi, int channel);
 extern void wlc_lcnphy_epa_switch(phy_info_t *pi, bool mode);
@@ -1122,8 +1122,8 @@ extern void wlc_lcnphy_deaf_mode(phy_inf
 extern bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t *pi);
 extern void wlc_lcnphy_tx_pwr_update_npt(phy_info_t *pi);
 extern int32 wlc_lcnphy_tssi2dbm(int32 tssi, int32 a1, int32 b0, int32 b1);
-extern void wlc_lcnphy_get_tssi(phy_info_t *pi, int8 *ofdm_pwr,
-				int8 *cck_pwr);
+extern void wlc_lcnphy_get_tssi(phy_info_t *pi, s8 *ofdm_pwr,
+				s8 *cck_pwr);
 extern void wlc_lcnphy_tx_power_adjustment(wlc_phy_t *ppi);
 
 extern int32 wlc_lcnphy_rx_signal_power(phy_info_t *pi, int32 gain_index);
@@ -1198,7 +1198,7 @@ extern int wlc_phy_cal_txiqlo_nphy(phy_i
 extern int wlc_phy_cal_rxiq_nphy(phy_info_t *pi, nphy_txgains_t target_gain,
 				 u8 type, bool d);
 extern void wlc_phy_txpwr_index_nphy(phy_info_t *pi, u8 core_mask,
-				     int8 txpwrindex, bool res);
+				     s8 txpwrindex, bool res);
 extern void wlc_phy_rssisel_nphy(phy_info_t *pi, u8 core, u8 rssi_type);
 extern int wlc_phy_poll_rssi_nphy(phy_info_t *pi, u8 rssi_type,
 				  int32 *rssi_buf, u8 nsamps);
@@ -1220,9 +1220,9 @@ extern int wlc_phy_rssi_compute_nphy(phy
 
 extern void wlc_phy_nphy_tkip_rifs_war(phy_info_t *pi, u8 rifs);
 
-void wlc_phy_get_pwrdet_offsets(phy_info_t *pi, int8 *cckoffset,
-				int8 *ofdmoffset);
-extern int8 wlc_phy_upd_rssi_offset(phy_info_t *pi, int8 rssi,
+void wlc_phy_get_pwrdet_offsets(phy_info_t *pi, s8 *cckoffset,
+				s8 *ofdmoffset);
+extern s8 wlc_phy_upd_rssi_offset(phy_info_t *pi, s8 rssi,
 				    chanspec_t chanspec);
 
 extern bool wlc_phy_n_txpower_ipa_ison(phy_info_t *pih);
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -463,7 +463,7 @@ static const uint32 lcnphy_23bitgaincode
 	0x04464f,
 };
 
-static const int8 lcnphy_gain_table[] = {
+static const s8 lcnphy_gain_table[] = {
 	-16,
 	-13,
 	10,
@@ -503,7 +503,7 @@ static const int8 lcnphy_gain_table[] =
 	92,
 };
 
-static const int8 lcnphy_gain_index_offset_for_rssi[] = {
+static const s8 lcnphy_gain_index_offset_for_rssi[] = {
 	7,
 	7,
 	7,
@@ -972,7 +972,7 @@ uint16
 #define wlc_radio_2064_rcal_done(pi) (0 != (read_radio_reg(pi, RADIO_2064_REG05C) & 0x20))
 #define tempsense_done(pi) (0x8000 == (read_phy_reg(pi, 0x476) & 0x8000))
 
-#define LCNPHY_IQLOCC_READ(val) ((u8)(-(int8)(((val) & 0xf0) >> 4) + (int8)((val) & 0x0f)))
+#define LCNPHY_IQLOCC_READ(val) ((u8)(-(s8)(((val) & 0xf0) >> 4) + (s8)((val) & 0x0f)))
 #define FIXED_TXPWR 78
 #define LCNPHY_TEMPSENSE(val) ((int16)((val > 255) ? (val - 512) : val))
 
@@ -1124,16 +1124,16 @@ static int wlc_lcnphy_calc_floor(int16 c
 	return k;
 }
 
-int8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t *pi)
+s8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t *pi)
 {
-	int8 index;
+	s8 index;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (txpwrctrl_off(pi))
 		index = pi_lcn->lcnphy_current_index;
 	else if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi))
 		index =
-		    (int8) (wlc_lcnphy_get_current_tx_pwr_idx_if_pwrctrl_on(pi)
+		    (s8) (wlc_lcnphy_get_current_tx_pwr_idx_if_pwrctrl_on(pi)
 			    / 2);
 	else
 		index = pi_lcn->lcnphy_current_index;
@@ -1643,7 +1643,7 @@ void wlc_lcnphy_txpower_recalc_target(ph
 	}
 }
 
-static void wlc_lcnphy_set_tx_pwr_soft_ctrl(phy_info_t *pi, int8 index)
+static void wlc_lcnphy_set_tx_pwr_soft_ctrl(phy_info_t *pi, s8 index)
 {
 	uint32 cck_offset[4] = { 22, 22, 22, 22 };
 	uint32 ofdm_offset, reg_offset_cck;
@@ -1696,9 +1696,9 @@ static void wlc_lcnphy_set_tx_pwr_soft_c
 
 }
 
-static int8 wlc_lcnphy_tempcompensated_txpwrctrl(phy_info_t *pi)
+static s8 wlc_lcnphy_tempcompensated_txpwrctrl(phy_info_t *pi)
 {
-	int8 index, delta_brd, delta_temp, new_index, tempcorrx;
+	s8 index, delta_brd, delta_temp, new_index, tempcorrx;
 	int16 manp, meas_temp, temp_diff;
 	bool neg = 0;
 	uint16 temp;
@@ -1733,7 +1733,7 @@ static int8 wlc_lcnphy_tempcompensated_t
 		temp_diff = -temp_diff;
 	}
 
-	delta_temp = (int8) wlc_lcnphy_qdiv_roundup((uint32) (temp_diff * 192),
+	delta_temp = (s8) wlc_lcnphy_qdiv_roundup((uint32) (temp_diff * 192),
 						    (uint32) (pi_lcn->
 							      lcnphy_tempsense_slope
 							      * 10), 0);
@@ -1744,9 +1744,9 @@ static int8 wlc_lcnphy_tempcompensated_t
 	    && LCNREV_IS(pi->pubpi.phy_rev, 0))
 		delta_temp = 0;
 	if (pi_lcn->lcnphy_tempcorrx > 31)
-		tempcorrx = (int8) (pi_lcn->lcnphy_tempcorrx - 64);
+		tempcorrx = (s8) (pi_lcn->lcnphy_tempcorrx - 64);
 	else
-		tempcorrx = (int8) pi_lcn->lcnphy_tempcorrx;
+		tempcorrx = (s8) pi_lcn->lcnphy_tempcorrx;
 	if (LCNREV_IS(pi->pubpi.phy_rev, 1))
 		tempcorrx = 4;
 	new_index =
@@ -1777,7 +1777,7 @@ static uint16 wlc_lcnphy_set_tx_pwr_ctrl
 void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t *pi, uint16 mode)
 {
 	uint16 old_mode = wlc_lcnphy_get_tx_pwr_ctrl(pi);
-	int8 index;
+	s8 index;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	ASSERT((LCNPHY_TX_PWR_CTRL_OFF == mode) ||
@@ -1824,7 +1824,7 @@ void wlc_lcnphy_set_tx_pwr_ctrl(phy_info
 		if (mode == LCNPHY_TX_PWR_CTRL_TEMPBASED) {
 			index = wlc_lcnphy_tempcompensated_txpwrctrl(pi);
 			wlc_lcnphy_set_tx_pwr_soft_ctrl(pi, index);
-			pi_lcn->lcnphy_current_index = (int8)
+			pi_lcn->lcnphy_current_index = (s8)
 			    ((read_phy_reg(pi, 0x4a9) & 0xFF) / 2);
 		}
 	}
@@ -2159,7 +2159,7 @@ static void wlc_lcnphy_vbat_temp_sense_s
 	u8 save_reg007, save_reg0FF, save_reg11F, save_reg005, save_reg025,
 	    save_reg112;
 	uint16 values_to_save[14];
-	int8 index;
+	s8 index;
 	int i;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 	OSL_DELAY(999);
@@ -2461,7 +2461,7 @@ void wlc_lcnphy_set_tx_pwr_by_index(phy_
 
 	ASSERT(index <= LCNPHY_MAX_TX_POWER_INDEX);
 
-	pi_lcn->lcnphy_tx_power_idx_override = (int8) index;
+	pi_lcn->lcnphy_tx_power_idx_override = (s8) index;
 	pi_lcn->lcnphy_current_index = (u8) index;
 
 	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
@@ -2905,7 +2905,7 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal
 	}
 
 	wlc_lcnphy_get_radio_loft(pi, &ei0, &eq0, &fi0, &fq0);
-	if ((ABS((int8) fi0) == 15) && (ABS((int8) fq0) == 15)) {
+	if ((ABS((s8) fi0) == 15) && (ABS((s8) fq0) == 15)) {
 		if (CHSPEC_IS5G(pi->radio_chanspec)) {
 			target_gains.gm_gain = 255;
 			target_gains.pga_gain = 255;
@@ -3081,16 +3081,16 @@ uint16 wlc_lcnphy_tempsense(phy_info_t *
 	return (uint16) avg;
 }
 
-int8 wlc_lcnphy_tempsense_degree(phy_info_t *pi, bool mode)
+s8 wlc_lcnphy_tempsense_degree(phy_info_t *pi, bool mode)
 {
 	int32 degree = wlc_lcnphy_tempsense_new(pi, mode);
 	degree =
 	    ((degree << 10) + LCN_TEMPSENSE_OFFSET + (LCN_TEMPSENSE_DEN >> 1))
 	    / LCN_TEMPSENSE_DEN;
-	return (int8) degree;
+	return (s8) degree;
 }
 
-int8 wlc_lcnphy_vbatsense(phy_info_t *pi, bool mode)
+s8 wlc_lcnphy_vbatsense(phy_info_t *pi, bool mode)
 {
 	uint16 vbatsenseval;
 	int32 avg = 0;
@@ -3123,7 +3123,7 @@ int8 wlc_lcnphy_vbatsense(phy_info_t *pi
 		if (!suspend)
 			wlapi_enable_mac(pi->sh->physhim);
 	}
-	return (int8) avg;
+	return (s8) avg;
 }
 
 static void wlc_lcnphy_afe_clk_init(phy_info_t *pi, u8 mode)
@@ -3453,7 +3453,7 @@ static void wlc_lcnphy_temp_adj(phy_info
 static void wlc_lcnphy_glacial_timer_based_cal(phy_info_t *pi)
 {
 	bool suspend;
-	int8 index;
+	s8 index;
 	uint16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 	suspend =
@@ -3481,7 +3481,7 @@ static void wlc_lcnphy_periodic_cal(phy_
 	const lcnphy_rx_iqcomp_t *rx_iqcomp;
 	int rx_iqcomp_sz;
 	uint16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
-	int8 index;
+	s8 index;
 	phytbl_info_t tab;
 	int32 a1, b0, b1;
 	int32 tssi, pwr, maxtargetpwr, mintargetpwr;
@@ -3589,14 +3589,14 @@ void wlc_lcnphy_calib_modes(phy_info_t *
 	}
 }
 
-void wlc_lcnphy_get_tssi(phy_info_t *pi, int8 *ofdm_pwr, int8 *cck_pwr)
+void wlc_lcnphy_get_tssi(phy_info_t *pi, s8 *ofdm_pwr, s8 *cck_pwr)
 {
-	int8 cck_offset;
+	s8 cck_offset;
 	uint16 status;
 	status = (read_phy_reg(pi, 0x4ab));
 	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi) &&
 	    (status  & (0x1 << 15))) {
-		*ofdm_pwr = (int8) (((read_phy_reg(pi, 0x4ab) & (0x1ff << 0))
+		*ofdm_pwr = (s8) (((read_phy_reg(pi, 0x4ab) & (0x1ff << 0))
 				     >> 0) >> 1);
 
 		if (wlc_phy_tpc_isenabled_lcnphy(pi))
@@ -3677,7 +3677,7 @@ wlc_lcnphy_pktengtx(wlc_phy_t *ppi, wl_p
 
 void wlc_lcnphy_tx_power_adjustment(wlc_phy_t *ppi)
 {
-	int8 index;
+	s8 index;
 	uint16 index2;
 	phy_info_t *pi = (phy_info_t *) ppi;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -3687,7 +3687,7 @@ void wlc_lcnphy_tx_power_adjustment(wlc_
 		index2 = (uint16) (index * 2);
 		mod_phy_reg(pi, 0x4a9, (0x1ff << 0), (index2) << 0);
 
-		pi_lcn->lcnphy_current_index = (int8)
+		pi_lcn->lcnphy_current_index = (s8)
 		    ((read_phy_reg(pi, 0x4a9) & 0xFF) / 2);
 	}
 }
@@ -4517,7 +4517,7 @@ static void wlc_lcnphy_agc_temp_init(phy
 			& (0xff << 0));
 	if (temp > 127)
 		temp -= 256;
-	pi_lcn->lcnphy_input_pwr_offset_db = (int8) temp;
+	pi_lcn->lcnphy_input_pwr_offset_db = (s8) temp;
 
 	pi_lcn->lcnphy_Med_Low_Gain_db = (read_phy_reg(pi, 0x424)
 					  & (0xff << 8))
@@ -4728,7 +4728,7 @@ static void wlc_lcnphy_rc_cal(phy_info_t
 
 static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t *pi)
 {
-	int8 txpwr = 0;
+	s8 txpwr = 0;
 	int i;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -4763,7 +4763,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 			    pi_lcn->lcnphy_rssi_gs;
 		}
 
-		txpwr = (int8) PHY_GETINTVAR(pi, "maxp2ga0");
+		txpwr = (s8) PHY_GETINTVAR(pi, "maxp2ga0");
 		pi->tx_srom_max_2g = txpwr;
 
 		for (i = 0; i < PWRTBL_NUM_COEFF; i++) {
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
@@ -66,7 +66,7 @@ struct phy_info_lcnphy {
 	uint16 lcnphy_tssi_npt;
 
 	uint16 lcnphy_target_tx_freq;
-	int8 lcnphy_tx_power_idx_override;
+	s8 lcnphy_tx_power_idx_override;
 	uint16 lcnphy_noise_samples;
 
 	uint32 lcnphy_papdRxGnIdx;
@@ -80,11 +80,11 @@ struct phy_info_lcnphy {
 	int16 lcnphy_dsssgainidxtableoffset;
 	uint32 lcnphy_tr_R_gain_val;
 	uint32 lcnphy_tr_T_gain_val;
-	int8 lcnphy_input_pwr_offset_db;
+	s8 lcnphy_input_pwr_offset_db;
 	uint16 lcnphy_Med_Low_Gain_db;
 	uint16 lcnphy_Very_Low_Gain_db;
-	int8 lcnphy_lastsensed_temperature;
-	int8 lcnphy_pkteng_rssi_slope;
+	s8 lcnphy_lastsensed_temperature;
+	s8 lcnphy_pkteng_rssi_slope;
 	u8 lcnphy_saved_tx_user_target[TXP_NUM_RATES];
 	u8 lcnphy_volt_winner;
 	u8 lcnphy_volt_low;
@@ -94,7 +94,7 @@ struct phy_info_lcnphy {
 	u8 lcnphy_cck;
 	u8 lcnphy_psat_2pt3_detected;
 	int32 lcnphy_lowest_Re_div_Im;
-	int8 lcnphy_final_papd_cal_idx;
+	s8 lcnphy_final_papd_cal_idx;
 	uint16 lcnphy_extstxctrl4;
 	uint16 lcnphy_extstxctrl0;
 	uint16 lcnphy_extstxctrl1;
@@ -116,6 +116,6 @@ struct phy_info_lcnphy {
 
 	u8 lcnphy_aci_stat;
 	uint lcnphy_aci_start_time;
-	int8 lcnphy_tx_power_offset[TXP_NUM_RATES];
+	s8 lcnphy_tx_power_offset[TXP_NUM_RATES];
 };
 #endif				/* _wlc_phy_lcn_h_ */
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -109,7 +109,7 @@
 #define NPHY_CALSANITY_RSSI_W1_MAX_NEG (NPHY_RSSICAL_W1_TARGET - NPHY_RSSICAL_MAXREAD)
 #define NPHY_CALSANITY_RSSI_W2_MAX_POS  NPHY_CALSANITY_RSSI_W1_MAX_POS
 #define NPHY_CALSANITY_RSSI_W2_MAX_NEG (NPHY_RSSICAL_W2_TARGET - NPHY_RSSICAL_MAXREAD)
-#define NPHY_RSSI_SXT(x) ((int8) (-((x) & 0x20) + ((x) & 0x1f)))
+#define NPHY_RSSI_SXT(x) ((s8) (-((x) & 0x20) + ((x) & 0x1f)))
 #define NPHY_RSSI_NB_VIOL(x)  (((x) > NPHY_CALSANITY_RSSI_NB_MAX_POS) || \
 			       ((x) < NPHY_CALSANITY_RSSI_NB_MAX_NEG))
 #define NPHY_RSSI_W1_VIOL(x)  (((x) > NPHY_CALSANITY_RSSI_W1_MAX_POS) || \
@@ -178,7 +178,7 @@ typedef struct _nphy_ipa_txrxgain {
 	uint16 lpf_biq0;
 	uint16 lna2;
 	uint16 lna1;
-	int8 txpwrindex;
+	s8 txpwrindex;
 } nphy_ipa_txrxgain_t;
 
 #define NPHY_IPA_RXCAL_MAXGAININDEX (6 - 1)
@@ -13714,12 +13714,12 @@ static uint32 nphy_tpc_txgain_ipa_5g_205
 	0x607f0001, 0x607f0001, 0x607f0001, 0x607f0001
 };
 
-static int8 nphy_papd_pga_gain_delta_ipa_2g[] = {
+static s8 nphy_papd_pga_gain_delta_ipa_2g[] = {
 	-114, -108, -98, -91, -84, -78, -70, -62,
 	-54, -46, -39, -31, -23, -15, -8, 0
 };
 
-static int8 nphy_papd_pga_gain_delta_ipa_5g[] = {
+static s8 nphy_papd_pga_gain_delta_ipa_5g[] = {
 	-100, -95, -89, -83, -77, -70, -63, -56,
 	-48, -41, -33, -25, -19, -12, -6, 0
 };
@@ -13745,12 +13745,12 @@ static int16 nphy_papd_padgain_dlt_2g_20
 	-6, -5, -4, -3, -2, -1, -1, 0
 };
 
-static int8 nphy_papd_pgagain_dlt_5g_2057[] = {
+static s8 nphy_papd_pgagain_dlt_5g_2057[] = {
 	-107, -101, -92, -85, -78, -71, -62, -55,
 	-47, -39, -32, -24, -19, -12, -6, 0
 };
 
-static int8 nphy_papd_pgagain_dlt_5g_2057rev7[] = {
+static s8 nphy_papd_pgagain_dlt_5g_2057rev7[] = {
 	-110, -104, -95, -88, -81, -74, -66, -58,
 	-50, -44, -36, -28, -23, -15, -8, 0
 };
@@ -16356,49 +16356,49 @@ static void wlc_phy_workarounds_nphy_gai
 		NPHY_RFSEQ_CMD_SET_HPF_BW
 	};
 	u8 rfseq_updategainu_dlys[] = { 10, 30, 1 };
-	int8 lna1G_gain_db[] = { 7, 11, 16, 23 };
-	int8 lna1G_gain_db_rev4[] = { 8, 12, 17, 25 };
-	int8 lna1G_gain_db_rev5[] = { 9, 13, 18, 26 };
-	int8 lna1G_gain_db_rev6[] = { 8, 13, 18, 25 };
-	int8 lna1G_gain_db_rev6_224B0[] = { 10, 14, 19, 27 };
-	int8 lna1A_gain_db[] = { 7, 11, 17, 23 };
-	int8 lna1A_gain_db_rev4[] = { 8, 12, 18, 23 };
-	int8 lna1A_gain_db_rev5[] = { 6, 10, 16, 21 };
-	int8 lna1A_gain_db_rev6[] = { 6, 10, 16, 21 };
-	int8 *lna1_gain_db = NULL;
-	int8 lna2G_gain_db[] = { -5, 6, 10, 14 };
-	int8 lna2G_gain_db_rev5[] = { -3, 7, 11, 16 };
-	int8 lna2G_gain_db_rev6[] = { -5, 6, 10, 14 };
-	int8 lna2G_gain_db_rev6_224B0[] = { -5, 6, 10, 15 };
-	int8 lna2A_gain_db[] = { -6, 2, 6, 10 };
-	int8 lna2A_gain_db_rev4[] = { -5, 2, 6, 10 };
-	int8 lna2A_gain_db_rev5[] = { -7, 0, 4, 8 };
-	int8 lna2A_gain_db_rev6[] = { -7, 0, 4, 8 };
-	int8 *lna2_gain_db = NULL;
-	int8 tiaG_gain_db[] = {
+	s8 lna1G_gain_db[] = { 7, 11, 16, 23 };
+	s8 lna1G_gain_db_rev4[] = { 8, 12, 17, 25 };
+	s8 lna1G_gain_db_rev5[] = { 9, 13, 18, 26 };
+	s8 lna1G_gain_db_rev6[] = { 8, 13, 18, 25 };
+	s8 lna1G_gain_db_rev6_224B0[] = { 10, 14, 19, 27 };
+	s8 lna1A_gain_db[] = { 7, 11, 17, 23 };
+	s8 lna1A_gain_db_rev4[] = { 8, 12, 18, 23 };
+	s8 lna1A_gain_db_rev5[] = { 6, 10, 16, 21 };
+	s8 lna1A_gain_db_rev6[] = { 6, 10, 16, 21 };
+	s8 *lna1_gain_db = NULL;
+	s8 lna2G_gain_db[] = { -5, 6, 10, 14 };
+	s8 lna2G_gain_db_rev5[] = { -3, 7, 11, 16 };
+	s8 lna2G_gain_db_rev6[] = { -5, 6, 10, 14 };
+	s8 lna2G_gain_db_rev6_224B0[] = { -5, 6, 10, 15 };
+	s8 lna2A_gain_db[] = { -6, 2, 6, 10 };
+	s8 lna2A_gain_db_rev4[] = { -5, 2, 6, 10 };
+	s8 lna2A_gain_db_rev5[] = { -7, 0, 4, 8 };
+	s8 lna2A_gain_db_rev6[] = { -7, 0, 4, 8 };
+	s8 *lna2_gain_db = NULL;
+	s8 tiaG_gain_db[] = {
 		0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A };
-	int8 tiaA_gain_db[] = {
+	s8 tiaA_gain_db[] = {
 		0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13 };
-	int8 tiaA_gain_db_rev4[] = {
+	s8 tiaA_gain_db_rev4[] = {
 		0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d };
-	int8 tiaA_gain_db_rev5[] = {
+	s8 tiaA_gain_db_rev5[] = {
 		0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d };
-	int8 tiaA_gain_db_rev6[] = {
+	s8 tiaA_gain_db_rev6[] = {
 		0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d };
-	int8 *tia_gain_db;
-	int8 tiaG_gainbits[] = {
+	s8 *tia_gain_db;
+	s8 tiaG_gainbits[] = {
 		0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 };
-	int8 tiaA_gainbits[] = {
+	s8 tiaA_gainbits[] = {
 		0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06 };
-	int8 tiaA_gainbits_rev4[] = {
+	s8 tiaA_gainbits_rev4[] = {
 		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 };
-	int8 tiaA_gainbits_rev5[] = {
+	s8 tiaA_gainbits_rev5[] = {
 		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 };
-	int8 tiaA_gainbits_rev6[] = {
+	s8 tiaA_gainbits_rev6[] = {
 		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 };
-	int8 *tia_gainbits;
-	int8 lpf_gain_db[] = { 0x00, 0x06, 0x0c, 0x12, 0x12, 0x12 };
-	int8 lpf_gainbits[] = { 0x00, 0x01, 0x02, 0x03, 0x03, 0x03 };
+	s8 *tia_gainbits;
+	s8 lpf_gain_db[] = { 0x00, 0x06, 0x0c, 0x12, 0x12, 0x12 };
+	s8 lpf_gainbits[] = { 0x00, 0x01, 0x02, 0x03, 0x03, 0x03 };
 	uint16 rfseqG_init_gain[] = { 0x613f, 0x613f, 0x613f, 0x613f };
 	uint16 rfseqG_init_gain_rev4[] = { 0x513f, 0x513f, 0x513f, 0x513f };
 	uint16 rfseqG_init_gain_rev5[] = { 0x413f, 0x413f, 0x413f, 0x413f };
@@ -16968,10 +16968,10 @@ static void wlc_phy_workarounds_nphy_gai
 
 static void wlc_phy_workarounds_nphy_gainctrl_2057_rev5(phy_info_t *pi)
 {
-	int8 lna1_gain_db[] = { 8, 13, 17, 22 };
-	int8 lna2_gain_db[] = { -2, 7, 11, 15 };
-	int8 tia_gain_db[] = { -4, -1, 2, 5, 5, 5, 5, 5, 5, 5 };
-	int8 tia_gainbits[] = {
+	s8 lna1_gain_db[] = { 8, 13, 17, 22 };
+	s8 lna2_gain_db[] = { -2, 7, 11, 15 };
+	s8 tia_gain_db[] = { -4, -1, 2, 5, 5, 5, 5, 5, 5, 5 };
+	s8 tia_gainbits[] = {
 		0x0, 0x01, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 };
 
 	mod_phy_reg(pi, 0x1c, (0x1 << 13), (1 << 13));
@@ -17024,14 +17024,14 @@ static void wlc_phy_workarounds_nphy_gai
 static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t *pi)
 {
 	uint16 currband;
-	int8 lna1G_gain_db_rev7[] = { 9, 14, 19, 24 };
-	int8 *lna1_gain_db = NULL;
-	int8 *lna1_gain_db_2 = NULL;
-	int8 *lna2_gain_db = NULL;
-	int8 tiaA_gain_db_rev7[] = { -9, -6, -3, 0, 3, 3, 3, 3, 3, 3 };
-	int8 *tia_gain_db;
-	int8 tiaA_gainbits_rev7[] = { 0, 1, 2, 3, 4, 4, 4, 4, 4, 4 };
-	int8 *tia_gainbits;
+	s8 lna1G_gain_db_rev7[] = { 9, 14, 19, 24 };
+	s8 *lna1_gain_db = NULL;
+	s8 *lna1_gain_db_2 = NULL;
+	s8 *lna2_gain_db = NULL;
+	s8 tiaA_gain_db_rev7[] = { -9, -6, -3, 0, 3, 3, 3, 3, 3, 3 };
+	s8 *tia_gain_db;
+	s8 tiaA_gainbits_rev7[] = { 0, 1, 2, 3, 4, 4, 4, 4, 4, 4 };
+	s8 *tia_gainbits;
 	uint16 rfseqA_init_gain_rev7[] = { 0x624f, 0x624f };
 	uint16 *rfseq_init_gain;
 	uint16 init_gaincode;
@@ -17045,7 +17045,7 @@ static void wlc_phy_workarounds_nphy_gai
 	uint16 nbclip_th = 0;
 	u8 w1clip_th;
 	uint16 freq;
-	int8 nvar_baseline_offset0 = 0, nvar_baseline_offset1 = 0;
+	s8 nvar_baseline_offset0 = 0, nvar_baseline_offset1 = 0;
 	u8 chg_nbclip_th = 0;
 
 	mod_phy_reg(pi, 0x1c, (0x1 << 13), (1 << 13));
@@ -17094,10 +17094,10 @@ static void wlc_phy_workarounds_nphy_gai
 
 			if ((freq <= 5080) || (freq == 5825)) {
 
-				int8 lna1A_gain_db_rev7[] = { 11, 16, 20, 24 };
-				int8 lna1A_gain_db_2_rev7[] = {
+				s8 lna1A_gain_db_rev7[] = { 11, 16, 20, 24 };
+				s8 lna1A_gain_db_2_rev7[] = {
 					11, 17, 22, 25 };
-				int8 lna2A_gain_db_rev7[] = { -1, 6, 10, 14 };
+				s8 lna2A_gain_db_rev7[] = { -1, 6, 10, 14 };
 
 				crsminu_th = 0x3e;
 				lna1_gain_db = lna1A_gain_db_rev7;
@@ -17105,10 +17105,10 @@ static void wlc_phy_workarounds_nphy_gai
 				lna2_gain_db = lna2A_gain_db_rev7;
 			} else if ((freq >= 5500) && (freq <= 5700)) {
 
-				int8 lna1A_gain_db_rev7[] = { 11, 17, 21, 25 };
-				int8 lna1A_gain_db_2_rev7[] = {
+				s8 lna1A_gain_db_rev7[] = { 11, 17, 21, 25 };
+				s8 lna1A_gain_db_2_rev7[] = {
 					12, 18, 22, 26 };
-				int8 lna2A_gain_db_rev7[] = { 1, 8, 12, 16 };
+				s8 lna2A_gain_db_rev7[] = { 1, 8, 12, 16 };
 
 				crsminu_th = 0x45;
 				clip1md_gaincode_B = 0x14;
@@ -17119,10 +17119,10 @@ static void wlc_phy_workarounds_nphy_gai
 				lna2_gain_db = lna2A_gain_db_rev7;
 			} else {
 
-				int8 lna1A_gain_db_rev7[] = { 12, 18, 22, 26 };
-				int8 lna1A_gain_db_2_rev7[] = {
+				s8 lna1A_gain_db_rev7[] = { 12, 18, 22, 26 };
+				s8 lna1A_gain_db_2_rev7[] = {
 					12, 18, 22, 26 };
-				int8 lna2A_gain_db_rev7[] = { -1, 6, 10, 14 };
+				s8 lna2A_gain_db_rev7[] = { -1, 6, 10, 14 };
 
 				crsminu_th = 0x41;
 				lna1_gain_db = lna1A_gain_db_rev7;
@@ -20366,7 +20366,7 @@ wlc_phy_rfctrl_override_1tomany_nphy(phy
 }
 
 static void
-wlc_phy_scale_offset_rssi_nphy(phy_info_t *pi, uint16 scale, int8 offset,
+wlc_phy_scale_offset_rssi_nphy(phy_info_t *pi, uint16 scale, s8 offset,
 			       u8 coresel, u8 rail, u8 rssi_type)
 {
 	uint16 valuetostuff;
@@ -20826,7 +20826,7 @@ wlc_phy_poll_rssi_nphy(phy_info_t *pi, u
 	uint16 rfctrloverride_save = 0;
 	uint16 rfctrlrssiothers1_save = 0;
 	uint16 rfctrlrssiothers2_save = 0;
-	int8 tmp_buf[4];
+	s8 tmp_buf[4];
 	u8 ctr = 0, samp = 0;
 	int32 rssi_out_val;
 	uint16 gpiosel_orig;
@@ -20869,10 +20869,10 @@ wlc_phy_poll_rssi_nphy(phy_info_t *pi, u
 		}
 
 		ctr = 0;
-		tmp_buf[ctr++] = ((int8) ((rssi0 & 0x3f) << 2)) >> 2;
-		tmp_buf[ctr++] = ((int8) (((rssi0 >> 8) & 0x3f) << 2)) >> 2;
-		tmp_buf[ctr++] = ((int8) ((rssi1 & 0x3f) << 2)) >> 2;
-		tmp_buf[ctr++] = ((int8) (((rssi1 >> 8) & 0x3f) << 2)) >> 2;
+		tmp_buf[ctr++] = ((s8) ((rssi0 & 0x3f) << 2)) >> 2;
+		tmp_buf[ctr++] = ((s8) (((rssi0 >> 8) & 0x3f) << 2)) >> 2;
+		tmp_buf[ctr++] = ((s8) ((rssi1 & 0x3f) << 2)) >> 2;
+		tmp_buf[ctr++] = ((s8) (((rssi1 >> 8) & 0x3f) << 2)) >> 2;
 
 		for (ctr = 0; ctr < 4; ctr++) {
 			rssi_buf[ctr] += tmp_buf[ctr];
@@ -21414,7 +21414,7 @@ static void wlc_phy_rssi_cal_nphy_rev2(p
 		}
 
 		wlc_phy_scale_offset_rssi_nphy(pi, 0x0,
-					       (int8)
+					       (s8)
 					       fine_digital_offset[result_idx],
 					       (result_idx / 2 ==
 						0) ? RADIO_MIMO_CORESEL_CORE1 :
@@ -21492,8 +21492,8 @@ wlc_phy_rssi_compute_nphy(phy_info_t *pi
 		rxpwr1 = phyRx2_l;
 	}
 
-	wlc_rxh->rxpwr[0] = (int8) rxpwr0;
-	wlc_rxh->rxpwr[1] = (int8) rxpwr1;
+	wlc_rxh->rxpwr[0] = (s8) rxpwr0;
+	wlc_rxh->rxpwr[1] = (s8) rxpwr1;
 	wlc_rxh->do_rssi_ma = 0;
 
 	if (pi->sh->rssi_mode == RSSI_ANT_MERGE_MAX)
@@ -21999,7 +21999,7 @@ static void wlc_phy_rssi_cal_nphy_rev3(p
 				}
 
 				wlc_phy_scale_offset_rssi_nphy(pi, 0x0,
-							       (int8)
+							       (s8)
 							       fine_digital_offset
 							       [result_idx],
 							       (result_idx /
@@ -22076,7 +22076,7 @@ static void wlc_phy_rssi_cal_nphy_rev3(p
 					}
 
 					wlc_phy_scale_offset_rssi_nphy(pi, 0x0,
-								       (int8)
+								       (s8)
 								       fine_digital_offset
 								       [core *
 									2],
@@ -24076,13 +24076,13 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 				pi->nphy_txpwrindex[1].index = -1;
 			} else {
 				wlc_phy_txpwr_index_nphy(pi, (1 << 0),
-							 (int8) (pi->
+							 (s8) (pi->
 								 nphy_txpwrindex
 								 [0].
 								 index_internal),
 							 FALSE);
 				wlc_phy_txpwr_index_nphy(pi, (1 << 1),
-							 (int8) (pi->
+							 (s8) (pi->
 								 nphy_txpwrindex
 								 [1].
 								 index_internal),
@@ -25321,13 +25321,13 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 	int16 desired_log2_pwr, actual_log2_pwr, delta_pwr;
 	bool gainctrl_done = FALSE;
 	u8 mix_tia_gain = 3;
-	int8 optim_gaintbl_index = 0, prev_gaintbl_index = 0;
-	int8 curr_gaintbl_index = 3;
+	s8 optim_gaintbl_index = 0, prev_gaintbl_index = 0;
+	s8 curr_gaintbl_index = 3;
 	u8 gainctrl_dirn = NPHY_RXCAL_GAIN_INIT;
 	nphy_ipa_txrxgain_t *nphy_rxcal_gaintbl;
 	uint16 hpvga, lpf_biq1, lpf_biq0, lna2, lna1;
 	int16 fine_gain_idx;
-	int8 txpwrindex;
+	s8 txpwrindex;
 	uint16 nphy_rxcal_txgain[2];
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -25551,7 +25551,7 @@ wlc_phy_rc_sweep_nphy(phy_info_t *pi, u8
 	uint16 rx_lpf_bw, rx_lpf_bws[2] = { 2, 4 };
 	uint16 lpf_hpc = 7, hpvga_hpc = 7;
 
-	int8 rccal_stepsize;
+	s8 rccal_stepsize;
 	uint16 rccal_val, last_rccal_val = 0, best_rccal_val = 0;
 	uint32 ref_iq_vals = 0, target_iq_vals = 0;
 	uint16 num_samps, log_num_samps = 10;
@@ -25774,8 +25774,8 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *p
 	uint16 cal_gain[2];
 	nphy_iqcal_params_t cal_params[2];
 	u8 rxcore_state;
-	int8 rxlpf_rccal_hpc, txlpf_rccal_lpc;
-	int8 txlpf_idac;
+	s8 rxlpf_rccal_hpc, txlpf_rccal_lpc;
+	s8 txlpf_idac;
 	bool phyhang_avoid_state = FALSE;
 	bool skip_rxiqcal = FALSE;
 
@@ -27515,10 +27515,10 @@ static void wlc_phy_a4(phy_info_t *pi, b
 	wlc_phy_txpwrctrl_enable_nphy(pi, phy_b4);
 	if (phy_b4 == PHY_TPC_HW_OFF) {
 		wlc_phy_txpwr_index_nphy(pi, (1 << 0),
-					 (int8) (pi->nphy_txpwrindex[0].
+					 (s8) (pi->nphy_txpwrindex[0].
 						 index_internal), FALSE);
 		wlc_phy_txpwr_index_nphy(pi, (1 << 1),
-					 (int8) (pi->nphy_txpwrindex[1].
+					 (s8) (pi->nphy_txpwrindex[1].
 						 index_internal), FALSE);
 	}
 
@@ -27984,9 +27984,9 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_txpid2g[PHY_CORE_1] =
 			    (u8) PHY_GETINTVAR(pi, "txpid2ga1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].max_pwr_2g =
-			    (int8) PHY_GETINTVAR(pi, "maxp2ga0");
+			    (s8) PHY_GETINTVAR(pi, "maxp2ga0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].max_pwr_2g =
-			    (int8) PHY_GETINTVAR(pi, "maxp2ga1");
+			    (s8) PHY_GETINTVAR(pi, "maxp2ga1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_2g_a1 =
 			    (int16) PHY_GETINTVAR(pi, "pa2gw0a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_2g_a1 =
@@ -28000,9 +28000,9 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_2g_b1 =
 			    (int16) PHY_GETINTVAR(pi, "pa2gw2a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].idle_targ_2g =
-			    (int8) PHY_GETINTVAR(pi, "itt2ga0");
+			    (s8) PHY_GETINTVAR(pi, "itt2ga0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].idle_targ_2g =
-			    (int8) PHY_GETINTVAR(pi, "itt2ga1");
+			    (s8) PHY_GETINTVAR(pi, "itt2ga1");
 
 			pi->cck2gpo = (uint16) PHY_GETINTVAR(pi, "cck2gpo");
 
@@ -28024,9 +28024,9 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_txpid5g[PHY_CORE_1] =
 			    (u8) PHY_GETINTVAR(pi, "txpid5ga1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].max_pwr_5gm =
-			    (int8) PHY_GETINTVAR(pi, "maxp5ga0");
+			    (s8) PHY_GETINTVAR(pi, "maxp5ga0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].max_pwr_5gm =
-			    (int8) PHY_GETINTVAR(pi, "maxp5ga1");
+			    (s8) PHY_GETINTVAR(pi, "maxp5ga1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_5gm_a1 =
 			    (int16) PHY_GETINTVAR(pi, "pa5gw0a0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_5gm_a1 =
@@ -28040,9 +28040,9 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_5gm_b1 =
 			    (int16) PHY_GETINTVAR(pi, "pa5gw2a1");
 			pi->nphy_pwrctrl_info[PHY_CORE_0].idle_targ_5gm =
-			    (int8) PHY_GETINTVAR(pi, "itt5ga0");
+			    (s8) PHY_GETINTVAR(pi, "itt5ga0");
 			pi->nphy_pwrctrl_info[PHY_CORE_1].idle_targ_5gm =
-			    (int8) PHY_GETINTVAR(pi, "itt5ga1");
+			    (s8) PHY_GETINTVAR(pi, "itt5ga1");
 
 			pi->ofdm5gpo = (uint32) PHY_GETINTVAR(pi, "ofdm5gpo");
 
@@ -28062,9 +28062,9 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_txpid5gl[1] =
 			    (u8) PHY_GETINTVAR(pi, "txpid5gla1");
 			pi->nphy_pwrctrl_info[0].max_pwr_5gl =
-			    (int8) PHY_GETINTVAR(pi, "maxp5gla0");
+			    (s8) PHY_GETINTVAR(pi, "maxp5gla0");
 			pi->nphy_pwrctrl_info[1].max_pwr_5gl =
-			    (int8) PHY_GETINTVAR(pi, "maxp5gla1");
+			    (s8) PHY_GETINTVAR(pi, "maxp5gla1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gl_a1 =
 			    (int16) PHY_GETINTVAR(pi, "pa5glw0a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gl_a1 =
@@ -28106,9 +28106,9 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_txpid5gh[1] =
 			    (u8) PHY_GETINTVAR(pi, "txpid5gha1");
 			pi->nphy_pwrctrl_info[0].max_pwr_5gh =
-			    (int8) PHY_GETINTVAR(pi, "maxp5gha0");
+			    (s8) PHY_GETINTVAR(pi, "maxp5gha0");
 			pi->nphy_pwrctrl_info[1].max_pwr_5gh =
-			    (int8) PHY_GETINTVAR(pi, "maxp5gha1");
+			    (s8) PHY_GETINTVAR(pi, "maxp5gha1");
 			pi->nphy_pwrctrl_info[0].pwrdet_5gh_a1 =
 			    (int16) PHY_GETINTVAR(pi, "pa5ghw0a0");
 			pi->nphy_pwrctrl_info[1].pwrdet_5gh_a1 =
@@ -28183,7 +28183,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 		pi->phy_txcore_disable_temp = PHY_CHAIN_TX_DISABLE_TEMP;
 	}
 
-	pi->phy_tempsense_offset = (int8) PHY_GETINTVAR(pi, "tempoffset");
+	pi->phy_tempsense_offset = (s8) PHY_GETINTVAR(pi, "tempoffset");
 	if (pi->phy_tempsense_offset != 0) {
 		if (pi->phy_tempsense_offset >
 		    (NPHY_SROM_TEMPSHIFT + NPHY_SROM_MAXTEMPOFFSET)) {
@@ -28234,8 +28234,8 @@ static void wlc_phy_txpwrctrl_coeff_setu
 	uint32 idx;
 	uint16 iqloCalbuf[7];
 	uint32 iqcomp, locomp, curr_locomp;
-	int8 locomp_i, locomp_q;
-	int8 curr_locomp_i, curr_locomp_q;
+	s8 locomp_i, locomp_q;
+	s8 curr_locomp_i, curr_locomp_q;
 	uint32 tbl_id, tbl_len, tbl_offset;
 	uint32 regval[128];
 
@@ -28268,18 +28268,18 @@ static void wlc_phy_txpwrctrl_coeff_setu
 
 		locomp =
 		    (uint32) ((tbl_id == 26) ? iqloCalbuf[5] : iqloCalbuf[6]);
-		locomp_i = (int8) ((locomp >> 8) & 0xff);
-		locomp_q = (int8) ((locomp) & 0xff);
+		locomp_i = (s8) ((locomp >> 8) & 0xff);
+		locomp_q = (s8) ((locomp) & 0xff);
 		for (idx = 0; idx < tbl_len; idx++) {
 			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 				curr_locomp_i = locomp_i;
 				curr_locomp_q = locomp_q;
 			} else {
-				curr_locomp_i = (int8) ((locomp_i *
+				curr_locomp_i = (s8) ((locomp_i *
 							 nphy_tpc_loscale[idx] +
 							 128) >> 8);
 				curr_locomp_q =
-				    (int8) ((locomp_q * nphy_tpc_loscale[idx] +
+				    (s8) ((locomp_q * nphy_tpc_loscale[idx] +
 					     128) >> 8);
 			}
 			curr_locomp = (uint32) ((curr_locomp_i & 0xff) << 8);
@@ -28480,7 +28480,7 @@ static void wlc_phy_txpwrctrl_pwr_setup_
 {
 	uint32 idx;
 	int16 a1[2], b0[2], b1[2];
-	int8 target_pwr_qtrdbm[2];
+	s8 target_pwr_qtrdbm[2];
 	int32 num, den, pwr_est;
 	u8 chan_freq_range;
 	u8 idle_tssi[2];
@@ -28595,8 +28595,8 @@ static void wlc_phy_txpwrctrl_pwr_setup_
 		}
 	}
 
-	target_pwr_qtrdbm[0] = (int8) pi->tx_power_max;
-	target_pwr_qtrdbm[1] = (int8) pi->tx_power_max;
+	target_pwr_qtrdbm[0] = (s8) pi->tx_power_max;
+	target_pwr_qtrdbm[1] = (s8) pi->tx_power_max;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		if (pi->srom_fem2g.tssipos) {
@@ -28921,7 +28921,7 @@ void wlc_phy_txpwrctrl_enable_nphy(phy_i
 }
 
 void
-wlc_phy_txpwr_index_nphy(phy_info_t *pi, u8 core_mask, int8 txpwrindex,
+wlc_phy_txpwr_index_nphy(phy_info_t *pi, u8 core_mask, s8 txpwrindex,
 			 bool restore_cals)
 {
 	u8 core, txpwrctl_tbl;
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -112,7 +112,7 @@ struct ampdu_info {
 	/* per-tid mpdu transmit retry limit at regular rate */
 	u8 rr_retry_limit_tid[AMPDU_MAX_SCB_TID];
 	u8 mpdu_density;	/* min mpdu spacing (0-7) ==> 2^(x-1)/8 usec */
-	int8 max_pdu;		/* max pdus allowed in ampdu */
+	s8 max_pdu;		/* max pdus allowed in ampdu */
 	u8 dur;		/* max duration of an ampdu (in msec) */
 	u8 txpkt_weight;	/* weight of ampdu in txfifo; reduces rate lag */
 	u8 rx_factor;	/* maximum rx ampdu factor (0-3) ==> 2^(13+x) bytes */
--- a/drivers/staging/brcm80211/sys/wlc_bmac.h
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.h
@@ -200,7 +200,7 @@ extern void wlc_bmac_copyfrom_vars(wlc_h
 				   uint *len);
 
 extern void wlc_bmac_process_ps_switch(wlc_hw_info_t *wlc,
-				       struct ether_addr *ea, int8 ps_on);
+				       struct ether_addr *ea, s8 ps_on);
 extern void wlc_bmac_hw_etheraddr(wlc_hw_info_t *wlc_hw,
 				  struct ether_addr *ea);
 extern void wlc_bmac_set_hw_etheraddr(wlc_hw_info_t *wlc_hw,
--- a/drivers/staging/brcm80211/sys/wlc_bsscfg.h
+++ b/drivers/staging/brcm80211/sys/wlc_bsscfg.h
@@ -56,7 +56,7 @@ struct wlc_bsscfg {
 	bool _ap;		/* is this configuration an AP */
 	struct wlc_if *wlcif;	/* virtual interface, NULL for primary bsscfg */
 	void *sup;		/* pointer to supplicant state */
-	int8 sup_type;		/* type of supplicant */
+	s8 sup_type;		/* type of supplicant */
 	bool sup_enable_wpa;	/* supplicant WPA on/off */
 	void *authenticator;	/* pointer to authenticator state */
 	bool sup_auth_pending;	/* flag for auth timeout */
@@ -64,7 +64,7 @@ struct wlc_bsscfg {
 	u8 SSID_len;		/* the length of SSID */
 	u8 SSID[DOT11_MAX_SSID_LEN];	/* SSID string */
 	struct scb *bcmc_scb[MAXBANDS];	/* one bcmc_scb per band */
-	int8 _idx;		/* the index of this bsscfg,
+	s8 _idx;		/* the index of this bsscfg,
 				 * assigned at wlc_bsscfg_alloc()
 				 */
 	/* MAC filter */
--- a/drivers/staging/brcm80211/sys/wlc_channel.h
+++ b/drivers/staging/brcm80211/sys/wlc_channel.h
@@ -57,8 +57,8 @@ typedef struct {
 	uint32 valid_channels;
 	u8 radar_channels;	/* List of radar sensitive channels */
 	u8 restricted_channels;	/* List of channels used only if APs are detected */
-	int8 maxpwr[WLC_MAXPWR_TBL_SIZE];	/* Max tx pwr in qdBm for each sub-band */
-	int8 pub_maxpwr[BAND_5G_PWR_LVLS];	/* Country IE advertised max tx pwr in dBm
+	s8 maxpwr[WLC_MAXPWR_TBL_SIZE];	/* Max tx pwr in qdBm for each sub-band */
+	s8 pub_maxpwr[BAND_5G_PWR_LVLS];	/* Country IE advertised max tx pwr in dBm
 						 * per sub-band
 						 */
 	u8 flags;
@@ -82,8 +82,8 @@ typedef struct {
  * by sub-band for 5 GHz limits using CHANNEL_POWER_IDX_5G(channel)
  */
 typedef struct {
-	int8 maxpwr20[WLC_MAXPWR_MIMO_TBL_SIZE];	/* tx 20 MHz power limits, qdBm units */
-	int8 maxpwr40[WLC_MAXPWR_MIMO_TBL_SIZE];	/* tx 40 MHz power limits, qdBm units */
+	s8 maxpwr20[WLC_MAXPWR_MIMO_TBL_SIZE];	/* tx 20 MHz power limits, qdBm units */
+	s8 maxpwr40[WLC_MAXPWR_MIMO_TBL_SIZE];	/* tx 40 MHz power limits, qdBm units */
 	u8 flags;
 } locale_mimo_info_t;
 
--- a/drivers/staging/brcm80211/sys/wlc_key.h
+++ b/drivers/staging/brcm80211/sys/wlc_key.h
@@ -95,8 +95,8 @@ typedef struct wsec_key {
 	uint16 flags;		/* misc flags */
 	u8 algo_hw;		/* cache for hw register */
 	u8 aes_mode;		/* cache for hw register */
-	int8 iv_len;		/* IV length */
-	int8 icv_len;		/* ICV length */
+	s8 iv_len;		/* IV length */
+	s8 icv_len;		/* ICV length */
 	uint32 len;		/* key length..don't move this var */
 	/* data is 4byte aligned */
 	u8 data[DOT11_MAX_KEY_SIZE];	/* key data */
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -311,7 +311,7 @@ static uint wlc_calc_ba_time(wlc_info_t
 static void wlc_update_mimo_band_bwcap(wlc_info_t *wlc, u8 bwcap);
 static void wlc_ht_update_sgi_rx(wlc_info_t *wlc, int val);
 void wlc_ht_mimops_cap_update(wlc_info_t *wlc, u8 mimops_mode);
-static void wlc_ht_update_ldpc(wlc_info_t *wlc, int8 val);
+static void wlc_ht_update_ldpc(wlc_info_t *wlc, s8 val);
 static void wlc_war16165(wlc_info_t *wlc, bool tx);
 
 static void wlc_process_eventq(void *arg);
@@ -1179,31 +1179,31 @@ void wlc_protection_upd(wlc_info_t *wlc,
 		wlc->protection->_g = (bool) val;
 		break;
 	case WLC_PROT_G_OVR:
-		wlc->protection->g_override = (int8) val;
+		wlc->protection->g_override = (s8) val;
 		break;
 	case WLC_PROT_G_USER:
 		wlc->protection->gmode_user = (u8) val;
 		break;
 	case WLC_PROT_OVERLAP:
-		wlc->protection->overlap = (int8) val;
+		wlc->protection->overlap = (s8) val;
 		break;
 	case WLC_PROT_N_USER:
-		wlc->protection->nmode_user = (int8) val;
+		wlc->protection->nmode_user = (s8) val;
 		break;
 	case WLC_PROT_N_CFG:
-		wlc->protection->n_cfg = (int8) val;
+		wlc->protection->n_cfg = (s8) val;
 		break;
 	case WLC_PROT_N_CFG_OVR:
-		wlc->protection->n_cfg_override = (int8) val;
+		wlc->protection->n_cfg_override = (s8) val;
 		break;
 	case WLC_PROT_N_NONGF:
 		wlc->protection->nongf = (bool) val;
 		break;
 	case WLC_PROT_N_NONGF_OVR:
-		wlc->protection->nongf_override = (int8) val;
+		wlc->protection->nongf_override = (s8) val;
 		break;
 	case WLC_PROT_N_PAM_OVR:
-		wlc->protection->n_pam_override = (int8) val;
+		wlc->protection->n_pam_override = (s8) val;
 		break;
 	case WLC_PROT_N_OBSS:
 		wlc->protection->n_obss = (bool) val;
@@ -1228,7 +1228,7 @@ static void wlc_ht_update_sgi_rx(wlc_inf
 	}
 }
 
-static void wlc_ht_update_ldpc(wlc_info_t *wlc, int8 val)
+static void wlc_ht_update_ldpc(wlc_info_t *wlc, s8 val)
 {
 	wlc->stf->ldpc = val;
 
@@ -1706,7 +1706,7 @@ static bool wlc_state_bmac_sync(wlc_info
 
 	wlc->machwcap = state_bmac.machwcap;
 	wlc_protection_upd(wlc, WLC_PROT_N_PAM_OVR,
-			   (int8) state_bmac.preamble_ovr);
+			   (s8) state_bmac.preamble_ovr);
 
 	return TRUE;
 }
@@ -2085,7 +2085,7 @@ static void BCMNMIATTACHFN(wlc_attach_an
 		WL_ERROR(("wl%d: %s: Invalid antennas available in srom, using 2dB\n", unit, __func__));
 		wlc->band->antgain = 8;
 	} else {
-		int8 gain, fract;
+		s8 gain, fract;
 		/* Older sroms specified gain in whole dbm only.  In order
 		 * be able to specify qdbm granularity and remain backward compatible
 		 * the whole dbms are now encoded in only low 6 bits and remaining qdbms
@@ -2116,9 +2116,9 @@ static bool BCMATTACHFN(wlc_attach_stf_a
 	bandtype = wlc->band->bandtype;
 
 	/* get antennas available */
-	aa = (int8) getintvar(vars, (BAND_5G(bandtype) ? "aa5g" : "aa2g"));
+	aa = (s8) getintvar(vars, (BAND_5G(bandtype) ? "aa5g" : "aa2g"));
 	if (aa == 0)
-		aa = (int8) getintvar(vars,
+		aa = (s8) getintvar(vars,
 				      (BAND_5G(bandtype) ? "aa1" : "aa0"));
 	if ((aa < 1) || (aa > 15)) {
 		WL_ERROR(("wl%d: %s: Invalid antennas available in srom (0x%x), using 3.\n", unit, __func__, aa));
@@ -2137,7 +2137,7 @@ static bool BCMATTACHFN(wlc_attach_stf_a
 
 	/* Compute Antenna Gain */
 	wlc->band->antgain =
-	    (int8) getintvar(vars, (BAND_5G(bandtype) ? "ag1" : "ag0"));
+	    (s8) getintvar(vars, (BAND_5G(bandtype) ? "ag1" : "ag0"));
 	wlc_attach_antgain_init(wlc);
 
 	return TRUE;
@@ -2962,7 +2962,7 @@ int wlc_set_gmode(wlc_info_t *wlc, u8 gm
 	uint i;
 	wlc_rateset_t rs;
 	/* Default to 54g Auto */
-	int8 shortslot = WLC_SHORTSLOT_AUTO;	/* Advertise and use shortslot (-1/0/1 Auto/Off/On) */
+	s8 shortslot = WLC_SHORTSLOT_AUTO;	/* Advertise and use shortslot (-1/0/1 Auto/Off/On) */
 	bool shortslot_restrict = FALSE;	/* Restrict association to stations that support shortslot
 						 */
 	bool ignore_bcns = TRUE;	/* Ignore legacy beacons on the same channel */
@@ -3578,11 +3578,11 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		break;
 
 	case WLC_SET_TXANT:
-		bcmerror = wlc_stf_ant_txant_validate(wlc, (int8) val);
+		bcmerror = wlc_stf_ant_txant_validate(wlc, (s8) val);
 		if (bcmerror < 0)
 			break;
 
-		wlc->stf->txant = (int8) val;
+		wlc->stf->txant = (s8) val;
 
 		/* if down, we are done */
 		if (!wlc->pub->up)
@@ -4137,7 +4137,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			break;
 		}
 
-		wlc->shortslot_override = (int8) val;
+		wlc->shortslot_override = (s8) val;
 
 		/* shortslot is an 11g feature, so no more work if we are
 		 * currently on the 5G band
@@ -4211,7 +4211,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			break;
 		}
 
-		wlc_protection_upd(wlc, WLC_PROT_OVERLAP, (int8) val);
+		wlc_protection_upd(wlc, WLC_PROT_OVERLAP, (s8) val);
 
 		/* Current g_protection will sync up to the specified control alg in watchdog
 		 * if the driver is up and associated.
@@ -4230,7 +4230,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			break;
 		}
 
-		wlc_protection_upd(wlc, WLC_PROT_G_OVR, (int8) val);
+		wlc_protection_upd(wlc, WLC_PROT_G_OVR, (s8) val);
 
 		break;
 
@@ -4381,13 +4381,13 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			if (cmd == WLC_GET_VAR) {
 				bcmerror =
 				    wlc_iovar_op(wlc, arg,
-						 (void *)((int8 *) arg + i),
+						 (void *)((s8 *) arg + i),
 						 len - i, arg, len, IOV_GET,
 						 wlcif);
 			} else
 				bcmerror =
 				    wlc_iovar_op(wlc, arg, NULL, 0,
-						 (void *)((int8 *) arg + i),
+						 (void *)((s8 *) arg + i),
 						 len - i, IOV_SET, wlcif);
 
 			break;
@@ -4500,8 +4500,8 @@ int wlc_iovar_setint(wlc_info_t *wlc, co
 			    IOV_SET, NULL);
 }
 
-/* simplified int8 get interface for common WLC_GET_VAR ioctl handler */
-int wlc_iovar_getint8(wlc_info_t *wlc, const char *name, int8 *arg)
+/* simplified s8 get interface for common WLC_GET_VAR ioctl handler */
+int wlc_iovar_gets8(wlc_info_t *wlc, const char *name, s8 *arg)
 {
 	int iovar_int;
 	int err;
@@ -4510,7 +4510,7 @@ int wlc_iovar_getint8(wlc_info_t *wlc, c
 	    wlc_iovar_op(wlc, name, NULL, 0, &iovar_int, sizeof(iovar_int),
 			 IOV_GET, NULL);
 	if (!err)
-		*arg = (int8) iovar_int;
+		*arg = (s8) iovar_int;
 
 	return err;
 }
@@ -5456,7 +5456,7 @@ bcmc_fid_generate(wlc_info_t *wlc, wlc_b
 }
 
 void BCMFASTPATH
-wlc_txfifo(wlc_info_t *wlc, uint fifo, void *p, bool commit, int8 txpktpend)
+wlc_txfifo(wlc_info_t *wlc, uint fifo, void *p, bool commit, s8 txpktpend)
 {
 	uint16 frameid = INVALIDFID;
 	d11txh_t *txh;
@@ -6925,7 +6925,7 @@ wlc_dotxstatus(wlc_info_t *wlc, tx_statu
 }
 
 void BCMFASTPATH
-wlc_txfifo_complete(wlc_info_t *wlc, uint fifo, int8 txpktpend)
+wlc_txfifo_complete(wlc_info_t *wlc, uint fifo, s8 txpktpend)
 {
 	TXPKTPENDDEC(wlc, fifo, txpktpend);
 	WL_TRACE(("wlc_txfifo_complete, pktpend dec %d to %d\n", txpktpend,
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.h
@@ -230,15 +230,15 @@ extern const u8 prio2fifo[];
 
 typedef struct wlc_protection {
 	bool _g;		/* use g spec protection, driver internal */
-	int8 g_override;	/* override for use of g spec protection */
+	s8 g_override;	/* override for use of g spec protection */
 	u8 gmode_user;	/* user config gmode, operating band->gmode is different */
-	int8 overlap;		/* Overlap BSS/IBSS protection for both 11g and 11n */
-	int8 nmode_user;	/* user config nmode, operating pub->nmode is different */
-	int8 n_cfg;		/* use OFDM protection on MIMO frames */
-	int8 n_cfg_override;	/* override for use of N protection */
+	s8 overlap;		/* Overlap BSS/IBSS protection for both 11g and 11n */
+	s8 nmode_user;	/* user config nmode, operating pub->nmode is different */
+	s8 n_cfg;		/* use OFDM protection on MIMO frames */
+	s8 n_cfg_override;	/* override for use of N protection */
 	bool nongf;		/* non-GF present protection */
-	int8 nongf_override;	/* override for use of GF protection */
-	int8 n_pam_override;	/* override for preamble: MM or GF */
+	s8 nongf_override;	/* override for use of GF protection */
+	s8 n_pam_override;	/* override for preamble: MM or GF */
 	bool n_obss;		/* indicated OBSS Non-HT STA present */
 
 	uint longpre_detect_timeout;	/* #sec until long preamble bcns gone */
@@ -266,7 +266,7 @@ typedef struct wlc_stf {
 	u8 rxstreams;	/* number of rxchains being used */
 
 	u8 ant_rx_ovr;	/* rx antenna override */
-	int8 txant;		/* userTx antenna setting */
+	s8 txant;		/* userTx antenna setting */
 	uint16 phytxant;	/* phyTx antenna setting in txheader */
 
 	u8 ss_opmode;	/* singlestream Operational mode, 0:siso; 1:cdd */
@@ -277,9 +277,9 @@ typedef struct wlc_stf {
 
 	u8 rxchain_restore_delay;	/* delay time to restore default rxchain */
 
-	int8 ldpc;		/* AUTO/ON/OFF ldpc cap supported */
+	s8 ldpc;		/* AUTO/ON/OFF ldpc cap supported */
 	u8 txcore[MAX_STREAMS_SUPPORTED + 1];	/* bitmap of selected core for each Nsts */
-	int8 spatial_policy;
+	s8 spatial_policy;
 } wlc_stf_t;
 
 #define WLC_STF_SS_STBC_TX(wlc, scb) \
@@ -346,11 +346,11 @@ typedef struct wlcband {
 	ratespec_t rspec_override;	/* 802.11 rate override */
 	ratespec_t mrspec_override;	/* multicast rate override */
 	u8 band_stf_ss_mode;	/* Configured STF type, 0:siso; 1:cdd */
-	int8 band_stf_stbc_tx;	/* STBC TX 0:off; 1:force on; -1:auto */
+	s8 band_stf_stbc_tx;	/* STBC TX 0:off; 1:force on; -1:auto */
 	wlc_rateset_t hw_rateset;	/* rates supported by chip (phy-specific) */
 	u8 basic_rate[WLC_MAXRATE + 1];	/* basic rates indexed by rate */
 	bool mimo_cap_40;	/* 40 MHz cap enabled on this band */
-	int8 antgain;		/* antenna gain from srom */
+	s8 antgain;		/* antenna gain from srom */
 
 	uint16 CWmin;		/* The minimum size of contention window, in unit of aSlotTime */
 	uint16 CWmax;		/* The maximum size of contention window, in unit of aSlotTime */
@@ -577,7 +577,7 @@ struct wlc_info {
 	uint qvalid;		/* DirFrmQValid and BcMcFrmQValid */
 
 	/* Regulatory power limits */
-	int8 txpwr_local_max;	/* regulatory local txpwr max */
+	s8 txpwr_local_max;	/* regulatory local txpwr max */
 	u8 txpwr_local_constraint;	/* local power contraint in dB */
 
 #ifdef WLC_HIGH_ONLY
@@ -638,7 +638,7 @@ struct wlc_info {
 	/* driver feature */
 	bool _rifs;		/* enable per-packet rifs */
 	int32 rifs_advert;	/* RIFS mode advertisement */
-	int8 sgi_tx;		/* sgi tx */
+	s8 sgi_tx;		/* sgi tx */
 	bool wet;		/* true if wireless ethernet bridging mode */
 
 	/* AP-STA synchronization, power save */
@@ -707,11 +707,11 @@ struct wlc_info {
 
 	u8 mimoft;		/* SIGN or 11N */
 	u8 mimo_band_bwcap;	/* bw cap per band type */
-	int8 txburst_limit_override;	/* tx burst limit override */
+	s8 txburst_limit_override;	/* tx burst limit override */
 	uint16 txburst_limit;	/* tx burst limit value */
-	int8 cck_40txbw;	/* 11N, cck tx b/w override when in 40MHZ mode */
-	int8 ofdm_40txbw;	/* 11N, ofdm tx b/w override when in 40MHZ mode */
-	int8 mimo_40txbw;	/* 11N, mimo tx b/w override when in 40MHZ mode */
+	s8 cck_40txbw;	/* 11N, cck tx b/w override when in 40MHZ mode */
+	s8 ofdm_40txbw;	/* 11N, ofdm tx b/w override when in 40MHZ mode */
+	s8 mimo_40txbw;	/* 11N, mimo tx b/w override when in 40MHZ mode */
 	ht_cap_ie_t ht_cap;	/* HT CAP IE being advertised by this node */
 
 	uint seckeys;		/* 54 key table shm address */
@@ -762,15 +762,15 @@ struct wlc_info {
 	/* network config */
 	bool shortpreamble;	/* currently operating with CCK ShortPreambles */
 	bool shortslot;		/* currently using 11g ShortSlot timing */
-	int8 barker_preamble;	/* current Barker Preamble Mode */
-	int8 shortslot_override;	/* 11g ShortSlot override */
+	s8 barker_preamble;	/* current Barker Preamble Mode */
+	s8 shortslot_override;	/* 11g ShortSlot override */
 	bool include_legacy_erp;	/* include Legacy ERP info elt ID 47 as well as g ID 42 */
 	bool barker_overlap_control;	/* TRUE: be aware of overlapping BSSs for barker */
 	bool ignore_bcns;	/* override: ignore non shortslot bcns in a 11g network */
 	bool legacy_probe;	/* restricts probe requests to CCK rates */
 
 	wlc_protection_t *protection;
-	int8 PLCPHdr_override;	/* 802.11b Preamble Type override */
+	s8 PLCPHdr_override;	/* 802.11b Preamble Type override */
 
 	wlc_stf_t *stf;
 
@@ -876,8 +876,8 @@ extern void wlc_bmac_rpc_watchdog(wlc_in
 extern void wlc_recv(wlc_info_t *wlc, void *p);
 extern bool wlc_dotxstatus(wlc_info_t *wlc, tx_status_t *txs, uint32 frm_tx2);
 extern void wlc_txfifo(wlc_info_t *wlc, uint fifo, void *p, bool commit,
-		       int8 txpktpend);
-extern void wlc_txfifo_complete(wlc_info_t *wlc, uint fifo, int8 txpktpend);
+		       s8 txpktpend);
+extern void wlc_txfifo_complete(wlc_info_t *wlc, uint fifo, s8 txpktpend);
 extern void wlc_info_init(wlc_info_t *wlc, int unit);
 extern void wlc_print_txstatus(tx_status_t *txs);
 extern int wlc_xmtfifo_sz_get(wlc_info_t *wlc, uint fifo, uint *blocks);
--- a/drivers/staging/brcm80211/sys/wlc_pub.h
+++ b/drivers/staging/brcm80211/sys/wlc_pub.h
@@ -58,7 +58,7 @@
 #define WLC_SNR_INVALID		0	/* invalid SNR value */
 
 /* a large TX Power as an init value to factor out of MIN() calculations,
- * keep low enough to fit in an int8, units are .25 dBm
+ * keep low enough to fit in an s8, units are .25 dBm
  */
 #define WLC_TXPWR_MAX		(127)	/* ~32 dBm = 1,500 mW */
 
@@ -174,10 +174,10 @@ typedef struct wlc_bss_info {
 	uint16 beacon_period;	/* units are Kusec */
 	uint16 atim_window;	/* units are Kusec */
 	chanspec_t chanspec;	/* Channel num, bw, ctrl_sb and band */
-	int8 infra;		/* 0=IBSS, 1=infrastructure, 2=unknown */
+	s8 infra;		/* 0=IBSS, 1=infrastructure, 2=unknown */
 	wlc_rateset_t rateset;	/* supported rates */
 	u8 dtim_period;	/* DTIM period */
-	int8 phy_noise;		/* noise right after tx (in dBm) */
+	s8 phy_noise;		/* noise right after tx (in dBm) */
 	uint16 capability;	/* Capability information */
 	struct dot11_bcn_prb *bcn_prb;	/* beacon/probe response frame (ioctl na) */
 	uint16 bcn_prb_len;	/* beacon/probe response frame length (ioctl na) */
@@ -288,7 +288,7 @@ typedef struct wlc_pub {
 	u8 _n_enab;		/* bitmap of 11N + HT support */
 	bool _n_reqd;		/* N support required for clients */
 
-	int8 _coex;		/* 20/40 MHz BSS Management AUTO, ENAB, DISABLE */
+	s8 _coex;		/* 20/40 MHz BSS Management AUTO, ENAB, DISABLE */
 	bool _priofc;		/* Priority-based flowcontrol */
 
 	struct ether_addr cur_etheraddr;	/* our local ethernet address */
@@ -552,8 +552,8 @@ extern void wlc_mctrl(struct wlc_info *w
 extern void wlc_scb_ratesel_init_all(struct wlc_info *wlc);
 
 /* ioctl */
-extern int wlc_iovar_getint8(struct wlc_info *wlc, const char *name,
-			     int8 *arg);
+extern int wlc_iovar_gets8(struct wlc_info *wlc, const char *name,
+			     s8 *arg);
 extern int wlc_iovar_check(wlc_pub_t *pub, const bcm_iovar_t *vi, void *arg,
 			   int len, bool set);
 
@@ -578,7 +578,7 @@ static inline int wlc_iovar_getuint(stru
 static inline int wlc_iovar_getu8(struct wlc_info *wlc, const char *name,
 				     u8 *arg)
 {
-	return wlc_iovar_getint8(wlc, name, (int8 *) arg);
+	return wlc_iovar_gets8(wlc, name, (s8 *) arg);
 }
 
 static inline int wlc_iovar_setuint(struct wlc_info *wlc, const char *name,
--- a/drivers/staging/brcm80211/sys/wlc_stf.c
+++ b/drivers/staging/brcm80211/sys/wlc_stf.c
@@ -42,7 +42,7 @@
 #define WLC_STF_SS_STBC_RX(wlc) (WLCISNPHY(wlc->band) && \
 	NREV_GT(wlc->band->phyrev, 3) && NREV_LE(wlc->band->phyrev, 6))
 
-static int8 wlc_stf_stbc_rx_get(wlc_info_t *wlc);
+static s8 wlc_stf_stbc_rx_get(wlc_info_t *wlc);
 static bool wlc_stf_stbc_tx_set(wlc_info_t *wlc, int32 int_val);
 static int wlc_stf_txcore_set(wlc_info_t *wlc, u8 Nsts, u8 val);
 static int wlc_stf_spatial_policy_set(wlc_info_t *wlc, int val);
@@ -149,7 +149,7 @@ wlc_stf_ss_algo_channel_get(wlc_info_t *
 		setbit(ss_algo_channel, PHY_TXC1_MODE_STBC);
 }
 
-static int8 wlc_stf_stbc_rx_get(wlc_info_t *wlc)
+static s8 wlc_stf_stbc_rx_get(wlc_info_t *wlc)
 {
 	return (wlc->ht_cap.cap & HT_CAP_RX_STBC_MASK) >> HT_CAP_RX_STBC_SHIFT;
 }
@@ -169,8 +169,8 @@ static bool wlc_stf_stbc_tx_set(wlc_info
 	else
 		wlc->ht_cap.cap |= HT_CAP_TX_STBC;
 
-	wlc->bandstate[BAND_2G_INDEX]->band_stf_stbc_tx = (int8) int_val;
-	wlc->bandstate[BAND_5G_INDEX]->band_stf_stbc_tx = (int8) int_val;
+	wlc->bandstate[BAND_2G_INDEX]->band_stf_stbc_tx = (s8) int_val;
+	wlc->bandstate[BAND_5G_INDEX]->band_stf_stbc_tx = (s8) int_val;
 
 	return TRUE;
 }
@@ -236,7 +236,7 @@ static int wlc_stf_spatial_policy_set(wl
 
 	WL_TRACE(("wl%d: %s: val %x\n", wlc->pub->unit, __func__, val));
 
-	wlc->stf->spatial_policy = (int8) val;
+	wlc->stf->spatial_policy = (s8) val;
 	for (i = 1; i <= MAX_STREAMS_SUPPORTED; i++) {
 		core_mask = (val == MAX_SPATIAL_EXPANSION) ?
 		    wlc->stf->txchain : txcore_default[i];
@@ -431,7 +431,7 @@ void BCMATTACHFN(wlc_stf_detach) (wlc_in
 {
 }
 
-int wlc_stf_ant_txant_validate(wlc_info_t *wlc, int8 val)
+int wlc_stf_ant_txant_validate(wlc_info_t *wlc, s8 val)
 {
 	int bcmerror = BCME_OK;
 
@@ -458,7 +458,7 @@ int wlc_stf_ant_txant_validate(wlc_info_
 	}
 
 	if (bcmerror == BCME_OK)
-		wlc->stf->txant = (int8) val;
+		wlc->stf->txant = (s8) val;
 
 	return bcmerror;
 
@@ -480,9 +480,9 @@ int wlc_stf_ant_txant_validate(wlc_info_
 */
 static void _wlc_stf_phy_txant_upd(wlc_info_t *wlc)
 {
-	int8 txant;
+	s8 txant;
 
-	txant = (int8) wlc->stf->txant;
+	txant = (s8) wlc->stf->txant;
 	ASSERT(txant == ANT_TX_FORCE_0 || txant == ANT_TX_FORCE_1
 	       || txant == ANT_TX_LAST_RX);
 
--- a/drivers/staging/brcm80211/sys/wlc_stf.h
+++ b/drivers/staging/brcm80211/sys/wlc_stf.h
@@ -33,7 +33,7 @@ extern int wlc_stf_txchain_set(wlc_info_
 extern int wlc_stf_rxchain_set(wlc_info_t *wlc, int32 int_val);
 extern bool wlc_stf_stbc_rx_set(wlc_info_t *wlc, int32 int_val);
 
-extern int wlc_stf_ant_txant_validate(wlc_info_t *wlc, int8 val);
+extern int wlc_stf_ant_txant_validate(wlc_info_t *wlc, s8 val);
 extern void wlc_stf_phy_txant_upd(wlc_info_t *wlc);
 extern void wlc_stf_phy_chain_calc(wlc_info_t *wlc);
 extern uint16 wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec);
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -705,23 +705,23 @@ static void _dma_detach(dma_info_t *di)
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		if (di->txd64)
 			DMA_FREE_CONSISTENT(di->osh,
-					    ((int8 *) (uintptr) di->txd64 -
+					    ((s8 *) (uintptr) di->txd64 -
 					     di->txdalign), di->txdalloc,
 					    (di->txdpaorig), &di->tx_dmah);
 		if (di->rxd64)
 			DMA_FREE_CONSISTENT(di->osh,
-					    ((int8 *) (uintptr) di->rxd64 -
+					    ((s8 *) (uintptr) di->rxd64 -
 					     di->rxdalign), di->rxdalloc,
 					    (di->rxdpaorig), &di->rx_dmah);
 	} else if (DMA32_ENAB(di)) {
 		if (di->txd32)
 			DMA_FREE_CONSISTENT(di->osh,
-					    ((int8 *) (uintptr) di->txd32 -
+					    ((s8 *) (uintptr) di->txd32 -
 					     di->txdalign), di->txdalloc,
 					    (di->txdpaorig), &di->tx_dmah);
 		if (di->rxd32)
 			DMA_FREE_CONSISTENT(di->osh,
-					    ((int8 *) (uintptr) di->rxd32 -
+					    ((s8 *) (uintptr) di->rxd32 -
 					     di->rxdalign), di->rxdalloc,
 					    (di->rxdpaorig), &di->rx_dmah);
 	} else
@@ -1545,7 +1545,7 @@ static bool dma32_alloc(dma_info_t *di,
 		ASSERT(PHYSADDRHI(di->txdpaorig) == 0);
 		di->txd32 = (dma32dd_t *) ROUNDUP((uintptr) va, align);
 		di->txdalign =
-		    (uint) ((int8 *) (uintptr) di->txd32 - (int8 *) va);
+		    (uint) ((s8 *) (uintptr) di->txd32 - (s8 *) va);
 
 		PHYSADDRLOSET(di->txdpa,
 			      PHYSADDRLO(di->txdpaorig) + di->txdalign);
@@ -1566,7 +1566,7 @@ static bool dma32_alloc(dma_info_t *di,
 		ASSERT(PHYSADDRHI(di->rxdpaorig) == 0);
 		di->rxd32 = (dma32dd_t *) ROUNDUP((uintptr) va, align);
 		di->rxdalign =
-		    (uint) ((int8 *) (uintptr) di->rxd32 - (int8 *) va);
+		    (uint) ((s8 *) (uintptr) di->rxd32 - (s8 *) va);
 
 		PHYSADDRLOSET(di->rxdpa,
 			      PHYSADDRLO(di->rxdpaorig) + di->rxdalign);
@@ -2111,7 +2111,7 @@ static bool dma64_alloc(dma_info_t *di,
 		align = (1 << align_bits);
 		di->txd64 = (dma64dd_t *) ROUNDUP((uintptr) va, align);
 		di->txdalign =
-		    (uint) ((int8 *) (uintptr) di->txd64 - (int8 *) va);
+		    (uint) ((s8 *) (uintptr) di->txd64 - (s8 *) va);
 		PHYSADDRLOSET(di->txdpa,
 			      PHYSADDRLO(di->txdpaorig) + di->txdalign);
 		/* Make sure that alignment didn't overflow */
@@ -2130,7 +2130,7 @@ static bool dma64_alloc(dma_info_t *di,
 		align = (1 << align_bits);
 		di->rxd64 = (dma64dd_t *) ROUNDUP((uintptr) va, align);
 		di->rxdalign =
-		    (uint) ((int8 *) (uintptr) di->rxd64 - (int8 *) va);
+		    (uint) ((s8 *) (uintptr) di->rxd64 - (s8 *) va);
 		PHYSADDRLOSET(di->rxdpa,
 			      PHYSADDRLO(di->rxdpaorig) + di->rxdalign);
 		/* Make sure that alignment didn't overflow */
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -298,7 +298,7 @@ typedef struct {
 /* Change resource dependancies masks */
 typedef struct {
 	uint32 res_mask;	/* resources (chip specific) */
-	int8 action;		/* action */
+	s8 action;		/* action */
 	uint32 depend_mask;	/* changes to the dependancies mask */
 	 bool(*filter) (si_t *sih);	/* action is taken when filter is NULL or return TRUE */
 } pmu_res_depend_t;
--- a/drivers/staging/brcm80211/util/sbutils.c
+++ b/drivers/staging/brcm80211/util/sbutils.c
@@ -36,7 +36,7 @@ static void *_sb_setcoreidx(si_info_t *s
 
 #define	SET_SBREG(sii, r, mask, val)	\
 		W_SBREG((sii), (r), ((R_SBREG((sii), (r)) & ~(mask)) | (val)))
-#define	REGS2SB(va)	(sbconfig_t *) ((int8 *)(va) + SBCONFIGOFF)
+#define	REGS2SB(va)	(sbconfig_t *) ((s8 *)(va) + SBCONFIGOFF)
 
 /* sonicsrev */
 #define	SONICS_2_2	(SBIDL_RV_2_2 >> SBIDL_RV_SHIFT)

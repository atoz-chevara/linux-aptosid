commit 66cbd3ab35d35580ddf98304c280a6231685aa41
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:05:47 2010 -0700

    Staging: brcm80211: s/uint32/u32/
    
    Use the kernel types, don't invent your own.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
@@ -36,11 +36,11 @@ const uint bcmsdh_msglevel = BCMSDH_ERRO
 struct bcmsdh_info {
 	bool init_success;	/* underlying driver successfully attached */
 	void *sdioh;		/* handler for sdioh */
-	uint32 vendevid;	/* Target Vendor and Device ID on SD bus */
+	u32 vendevid;	/* Target Vendor and Device ID on SD bus */
 	osl_t *osh;
 	bool regfail;		/* Save status of last
 				 reg_read/reg_write call */
-	uint32 sbwad;		/* Save backplane window address */
+	u32 sbwad;		/* Save backplane window address */
 };
 /* local copy of bcm sd handler */
 bcmsdh_info_t *l_bcmsdh;
@@ -78,7 +78,7 @@ bcmsdh_info_t *bcmsdh_attach(osl_t *osh,
 	bcmsdh->osh = osh;
 	bcmsdh->init_success = TRUE;
 
-	*regsva = (uint32 *) SI_ENUM_BASE;
+	*regsva = (u32 *) SI_ENUM_BASE;
 
 	/* Report the BAR, to fix if needed */
 	bcmsdh->sbwad = SI_ENUM_BASE;
@@ -181,7 +181,7 @@ int bcmsdh_devremove_reg(void *sdh, bcms
 	return BCME_UNSUPPORTED;
 }
 
-u8 bcmsdh_cfg_read(void *sdh, uint fnc_num, uint32 addr, int *err)
+u8 bcmsdh_cfg_read(void *sdh, uint fnc_num, u32 addr, int *err)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 	SDIOH_API_RC status;
@@ -217,7 +217,7 @@ u8 bcmsdh_cfg_read(void *sdh, uint fnc_n
 }
 
 void
-bcmsdh_cfg_write(void *sdh, uint fnc_num, uint32 addr, u8 data, int *err)
+bcmsdh_cfg_write(void *sdh, uint fnc_num, u32 addr, u8 data, int *err)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 	SDIOH_API_RC status;
@@ -249,11 +249,11 @@ bcmsdh_cfg_write(void *sdh, uint fnc_num
 		     __func__, fnc_num, addr, data));
 }
 
-uint32 bcmsdh_cfg_read_word(void *sdh, uint fnc_num, uint32 addr, int *err)
+u32 bcmsdh_cfg_read_word(void *sdh, uint fnc_num, u32 addr, int *err)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 	SDIOH_API_RC status;
-	uint32 data = 0;
+	u32 data = 0;
 
 	if (!bcmsdh)
 		bcmsdh = l_bcmsdh;
@@ -267,14 +267,14 @@ uint32 bcmsdh_cfg_read_word(void *sdh, u
 	if (err)
 		*err = (SDIOH_API_SUCCESS(status) ? 0 : BCME_SDIO_ERROR);
 
-	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, uint32data = 0x%x\n",
+	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, u32data = 0x%x\n",
 		     __func__, fnc_num, addr, data));
 
 	return data;
 }
 
 void
-bcmsdh_cfg_write_word(void *sdh, uint fnc_num, uint32 addr, uint32 data,
+bcmsdh_cfg_write_word(void *sdh, uint fnc_num, u32 addr, u32 data,
 		      int *err)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
@@ -292,7 +292,7 @@ bcmsdh_cfg_write_word(void *sdh, uint fn
 	if (err)
 		*err = (SDIOH_API_SUCCESS(status) ? 0 : BCME_SDIO_ERROR);
 
-	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, uint32data = 0x%x\n",
+	BCMSDH_INFO(("%s:fun = %d, addr = 0x%x, u32data = 0x%x\n",
 		     __func__, fnc_num, addr, data));
 }
 
@@ -336,7 +336,7 @@ int bcmsdh_cis_read(void *sdh, uint func
 	return SDIOH_API_SUCCESS(status) ? 0 : BCME_ERROR;
 }
 
-static int bcmsdhsdio_set_sbaddr_window(void *sdh, uint32 address)
+static int bcmsdhsdio_set_sbaddr_window(void *sdh, u32 address)
 {
 	int err = 0;
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
@@ -353,11 +353,11 @@ static int bcmsdhsdio_set_sbaddr_window(
 	return err;
 }
 
-uint32 bcmsdh_reg_read(void *sdh, uint32 addr, uint size)
+u32 bcmsdh_reg_read(void *sdh, u32 addr, uint size)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 	SDIOH_API_RC status;
-	uint32 word = 0;
+	u32 word = 0;
 	uint bar0 = addr & ~SBSDIO_SB_OFT_ADDR_MASK;
 
 	BCMSDH_INFO(("%s:fun = 1, addr = 0x%x, ", __func__, addr));
@@ -383,7 +383,7 @@ uint32 bcmsdh_reg_read(void *sdh, uint32
 
 	bcmsdh->regfail = !(SDIOH_API_SUCCESS(status));
 
-	BCMSDH_INFO(("uint32data = 0x%x\n", word));
+	BCMSDH_INFO(("u32data = 0x%x\n", word));
 
 	/* if ok, return appropriately masked word */
 	if (SDIOH_API_SUCCESS(status)) {
@@ -392,7 +392,7 @@ uint32 bcmsdh_reg_read(void *sdh, uint32
 			return word & 0xff;
 		case sizeof(u16):
 			return word & 0xffff;
-		case sizeof(uint32):
+		case sizeof(u32):
 			return word;
 		default:
 			bcmsdh->regfail = TRUE;
@@ -406,7 +406,7 @@ uint32 bcmsdh_reg_read(void *sdh, uint32
 	return 0xFFFFFFFF;
 }
 
-uint32 bcmsdh_reg_write(void *sdh, uint32 addr, uint size, uint32 data)
+u32 bcmsdh_reg_write(void *sdh, u32 addr, uint size, u32 data)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 	SDIOH_API_RC status;
@@ -451,7 +451,7 @@ bool bcmsdh_regfail(void *sdh)
 }
 
 int
-bcmsdh_recv_buf(void *sdh, uint32 addr, uint fn, uint flags,
+bcmsdh_recv_buf(void *sdh, u32 addr, uint fn, uint flags,
 		u8 *buf, uint nbytes, void *pkt,
 		bcmsdh_cmplt_fn_t complete, void *handle)
 {
@@ -496,7 +496,7 @@ bcmsdh_recv_buf(void *sdh, uint32 addr,
 }
 
 int
-bcmsdh_send_buf(void *sdh, uint32 addr, uint fn, uint flags,
+bcmsdh_send_buf(void *sdh, u32 addr, uint fn, uint flags,
 		u8 *buf, uint nbytes, void *pkt,
 		bcmsdh_cmplt_fn_t complete, void *handle)
 {
@@ -540,7 +540,7 @@ bcmsdh_send_buf(void *sdh, uint32 addr,
 	return SDIOH_API_SUCCESS(status) ? 0 : BCME_ERROR;
 }
 
-int bcmsdh_rwdata(void *sdh, uint rw, uint32 addr, u8 *buf, uint nbytes)
+int bcmsdh_rwdata(void *sdh, uint rw, u32 addr, u8 *buf, uint nbytes)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 	SDIOH_API_RC status;
@@ -612,12 +612,12 @@ void *bcmsdh_get_sdioh(bcmsdh_info_t *sd
 }
 
 /* Function to pass device-status bits to DHD. */
-uint32 bcmsdh_get_dstatus(void *sdh)
+u32 bcmsdh_get_dstatus(void *sdh)
 {
 	return 0;
 }
 
-uint32 bcmsdh_cur_sbwad(void *sdh)
+u32 bcmsdh_cur_sbwad(void *sdh)
 {
 	bcmsdh_info_t *bcmsdh = (bcmsdh_info_t *) sdh;
 
@@ -627,7 +627,7 @@ uint32 bcmsdh_cur_sbwad(void *sdh)
 	return bcmsdh->sbwad;
 }
 
-void bcmsdh_chipinfo(void *sdh, uint32 chip, uint32 chiprev)
+void bcmsdh_chipinfo(void *sdh, u32 chip, u32 chiprev)
 {
 	return;
 }
--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
@@ -164,7 +164,7 @@ int bcmsdh_probe(struct device *dev)
 	struct resource *r;
 #endif				/* BCMLXSDMMC */
 	int irq = 0;
-	uint32 vendevid;
+	u32 vendevid;
 	unsigned long irq_flags = 0;
 
 #if !defined(BCMLXSDMMC) && defined(BCMPLATFORM_BUS)
@@ -384,7 +384,7 @@ bcmsdh_pci_probe(struct pci_dev *pdev, c
 	if ((pdev->vendor == VENDOR_TI)
 	    && ((pdev->device == PCIXX21_FLASHMEDIA_ID)
 		|| (pdev->device == PCIXX21_FLASHMEDIA0_ID))) {
-		uint32 config_reg;
+		u32 config_reg;
 
 		SDLX_MSG(("%s: Disabling TI FlashMedia Controller.\n",
 			  __func__));
--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
@@ -44,7 +44,7 @@ extern void sdio_function_cleanup(void);
 static void IRQHandler(struct sdio_func *func);
 static void IRQHandlerF2(struct sdio_func *func);
 #endif				/* !defined(OOB_INTR_ONLY) */
-static int sdioh_sdmmc_get_cisaddr(sdioh_info_t *sd, uint32 regaddr);
+static int sdioh_sdmmc_get_cisaddr(sdioh_info_t *sd, u32 regaddr);
 extern int sdio_reset_comm(struct mmc_card *card);
 
 extern PBCMSDH_SDMMC_INSTANCE gInstance;
@@ -66,13 +66,13 @@ DHD_PM_RESUME_WAIT_INIT(sdioh_request_bu
 
 #define DMA_ALIGN_MASK	0x03
 
-int sdioh_sdmmc_card_regread(sdioh_info_t *sd, int func, uint32 regaddr,
-			     int regsize, uint32 *data);
+int sdioh_sdmmc_card_regread(sdioh_info_t *sd, int func, u32 regaddr,
+			     int regsize, u32 *data);
 
 static int sdioh_sdmmc_card_enablefuncs(sdioh_info_t *sd)
 {
 	int err_ret;
-	uint32 fbraddr;
+	u32 fbraddr;
 	u8 func;
 
 	sd_trace(("%s\n", __func__));
@@ -406,7 +406,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 	int val_size;
 	int32 int_val = 0;
 	bool bool_val;
-	uint32 actionid;
+	u32 actionid;
 
 	ASSERT(name);
 	ASSERT(len >= 0);
@@ -468,7 +468,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 		break;
 
 	case IOV_GVAL(IOV_BLOCKSIZE):
-		if ((uint32) int_val > si->num_funcs) {
+		if ((u32) int_val > si->num_funcs) {
 			bcmerror = BCME_BADARG;
 			break;
 		}
@@ -478,7 +478,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 
 	case IOV_SVAL(IOV_BLOCKSIZE):
 		{
-			uint func = ((uint32) int_val >> 16);
+			uint func = ((u32) int_val >> 16);
 			uint blksize = (u16) int_val;
 			uint maxsize;
 
@@ -542,7 +542,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 		break;
 
 	case IOV_GVAL(IOV_DIVISOR):
-		int_val = (uint32) sd_divisor;
+		int_val = (u32) sd_divisor;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -551,7 +551,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 		break;
 
 	case IOV_GVAL(IOV_POWER):
-		int_val = (uint32) sd_power;
+		int_val = (u32) sd_power;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -560,7 +560,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 		break;
 
 	case IOV_GVAL(IOV_CLOCK):
-		int_val = (uint32) sd_clock;
+		int_val = (u32) sd_clock;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -569,7 +569,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 		break;
 
 	case IOV_GVAL(IOV_SDMODE):
-		int_val = (uint32) sd_sdmode;
+		int_val = (u32) sd_sdmode;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -578,7 +578,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 		break;
 
 	case IOV_GVAL(IOV_HISPEED):
-		int_val = (uint32) sd_hiok;
+		int_val = (u32) sd_hiok;
 		bcopy(&int_val, arg, val_size);
 		break;
 
@@ -703,7 +703,7 @@ SDIOH_API_RC sdioh_enable_hw_oob_intr(sd
 #endif				/* defined(OOB_INTR_ONLY) && defined(HW_OOB) */
 
 extern SDIOH_API_RC
-sdioh_cfg_read(sdioh_info_t *sd, uint fnc_num, uint32 addr, u8 *data)
+sdioh_cfg_read(sdioh_info_t *sd, uint fnc_num, u32 addr, u8 *data)
 {
 	SDIOH_API_RC status;
 	/* No lock needed since sdioh_request_byte does locking */
@@ -712,7 +712,7 @@ sdioh_cfg_read(sdioh_info_t *sd, uint fn
 }
 
 extern SDIOH_API_RC
-sdioh_cfg_write(sdioh_info_t *sd, uint fnc_num, uint32 addr, u8 *data)
+sdioh_cfg_write(sdioh_info_t *sd, uint fnc_num, u32 addr, u8 *data)
 {
 	/* No lock needed since sdioh_request_byte does locking */
 	SDIOH_API_RC status;
@@ -720,11 +720,11 @@ sdioh_cfg_write(sdioh_info_t *sd, uint f
 	return status;
 }
 
-static int sdioh_sdmmc_get_cisaddr(sdioh_info_t *sd, uint32 regaddr)
+static int sdioh_sdmmc_get_cisaddr(sdioh_info_t *sd, u32 regaddr)
 {
 	/* read 24 bits and return valid 17 bit addr */
 	int i;
-	uint32 scratch, regdata;
+	u32 scratch, regdata;
 	u8 *ptr = (u8 *)&scratch;
 	for (i = 0; i < 3; i++) {
 		if ((sdioh_sdmmc_card_regread(sd, 0, regaddr, 1, &regdata)) !=
@@ -742,11 +742,11 @@ static int sdioh_sdmmc_get_cisaddr(sdioh
 }
 
 extern SDIOH_API_RC
-sdioh_cis_read(sdioh_info_t *sd, uint func, u8 *cisd, uint32 length)
+sdioh_cis_read(sdioh_info_t *sd, uint func, u8 *cisd, u32 length)
 {
-	uint32 count;
+	u32 count;
 	int offset;
-	uint32 foo;
+	u32 foo;
 	u8 *cis = cisd;
 
 	sd_trace(("%s: Func = %d\n", __func__, func));
@@ -876,7 +876,7 @@ sdioh_request_byte(sdioh_info_t *sd, uin
 
 extern SDIOH_API_RC
 sdioh_request_word(sdioh_info_t *sd, uint cmd_type, uint rw, uint func,
-		   uint addr, uint32 *word, uint nbytes)
+		   uint addr, u32 *word, uint nbytes)
 {
 	int err_ret = SDIOH_API_RC_FAIL;
 
@@ -932,7 +932,7 @@ sdioh_request_packet(sdioh_info_t *sd, u
 		     uint addr, void *pkt)
 {
 	bool fifo = (fix_inc == SDIOH_DATA_FIX);
-	uint32 SGCount = 0;
+	u32 SGCount = 0;
 	int err_ret = 0;
 
 	void *pnext;
@@ -963,7 +963,7 @@ sdioh_request_packet(sdioh_info_t *sd, u
 		 * is supposed to give
 		 * us something we can work with.
 		 */
-		ASSERT(((uint32) (PKTDATA(pkt)) & DMA_ALIGN_MASK) == 0);
+		ASSERT(((u32) (PKTDATA(pkt)) & DMA_ALIGN_MASK) == 0);
 
 		if ((write) && (!fifo)) {
 			err_ret = sdio_memcpy_toio(gInstance->func[func], addr,
@@ -1067,7 +1067,7 @@ sdioh_request_buffer(sdioh_info_t *sd, u
 #else
 		PKTFREE(sd->osh, mypkt, write ? TRUE : FALSE);
 #endif				/* DHD_USE_STATIC_BUF */
-	} else if (((uint32) (PKTDATA(pkt)) & DMA_ALIGN_MASK) != 0) {
+	} else if (((u32) (PKTDATA(pkt)) & DMA_ALIGN_MASK) != 0) {
 		/* Case 2: We have a packet, but it is unaligned. */
 
 		/* In this case, we cannot have a chain. */
@@ -1156,8 +1156,8 @@ void sdioh_sdmmc_devintr_on(sdioh_info_t
 
 /* Read client card reg */
 int
-sdioh_sdmmc_card_regread(sdioh_info_t *sd, int func, uint32 regaddr,
-			 int regsize, uint32 *data)
+sdioh_sdmmc_card_regread(sdioh_info_t *sd, int func, u32 regaddr,
+			 int regsize, u32 *data)
 {
 
 	if ((func == 0) || (regsize == 1)) {
@@ -1222,8 +1222,8 @@ static void IRQHandlerF2(struct sdio_fun
 #ifdef NOTUSED
 /* Write client card reg */
 static int
-sdioh_sdmmc_card_regwrite(sdioh_info_t *sd, int func, uint32 regaddr,
-			  int regsize, uint32 data)
+sdioh_sdmmc_card_regwrite(sdioh_info_t *sd, int func, u32 regaddr,
+			  int regsize, u32 data)
 {
 
 	if ((func == 0) || (regsize == 1)) {
--- a/drivers/staging/brcm80211/brcmfmac/bcmutils.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmutils.c
@@ -1170,7 +1170,7 @@ u16 hndcrc16(u8 *pdata,	/* pointer to ar
 	return crc;
 }
 
-static const uint32 crc32_table[256] = {
+static const u32 crc32_table[256] = {
 	0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
 	0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
 	0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
@@ -1237,9 +1237,9 @@ static const uint32 crc32_table[256] = {
 	0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
 };
 
-uint32 hndcrc32(u8 *pdata,	/* pointer to array of data to process */
+u32 hndcrc32(u8 *pdata,	/* pointer to array of data to process */
 		uint nbytes,	/* number of input data bytes to process */
-		uint32 crc	/* either CRC32_INIT_VALUE or previous
+		u32 crc	/* either CRC32_INIT_VALUE or previous
 					 return value */
 )
 {
@@ -1288,8 +1288,8 @@ void testcrc32(void)
 	uint j, k, l;
 	u8 *buf;
 	uint len[CNBUFS];
-	uint32 crcr;
-	uint32 crc32tv[CNBUFS] = {
+	u32 crcr;
+	u32 crc32tv[CNBUFS] = {
 		0xd2cb1faa, 0xd385c8fa, 0xf5b4f3f3, 0x55789e20, 0x00343110};
 
 	ASSERT((buf = MALLOC(CBUFSIZ * CNBUFS)) != NULL);
@@ -1408,13 +1408,13 @@ bcm_tlv_t *bcm_parse_ordered_tlvs(void *
 #if defined(WLMSG_PRHDRS) || defined(WLMSG_PRPKT) || defined(WLMSG_ASSOC) || \
 	defined(DHD_DEBUG)
 int
-bcm_format_flags(const bcm_bit_desc_t *bd, uint32 flags, char *buf, int len)
+bcm_format_flags(const bcm_bit_desc_t *bd, u32 flags, char *buf, int len)
 {
 	int i;
 	char *p = buf;
 	char hexstr[16];
 	int slen = 0;
-	uint32 bit;
+	u32 bit;
 	const char *name;
 
 	if (len < 2 || !buf)
@@ -1500,7 +1500,7 @@ void prhex(const char *msg, unsigned cha
 #endif		/* defined(WLMSG_PRHDRS) || defined(WLMSG_PRPKT) */
 
 /* Produce a human-readable string for boardrev */
-char *bcm_brev_str(uint32 brev, char *buf)
+char *bcm_brev_str(u32 brev, char *buf)
 {
 	if (brev < 0x100)
 		snprintf(buf, 8, "%d.%d", (brev & 0xf0) >> 4, brev & 0xf);
@@ -1540,7 +1540,7 @@ void printbig(char *buf)
 /* routine to dump fields in a fileddesc structure */
 uint
 bcmdumpfields(bcmutl_rdreg_rtn read_rtn, void *arg0, uint arg1,
-	      struct fielddesc *fielddesc_array, char *buf, uint32 bufsize)
+	      struct fielddesc *fielddesc_array, char *buf, u32 bufsize)
 {
 	uint filled_len;
 	int len;
@@ -1555,7 +1555,7 @@ bcmdumpfields(bcmutl_rdreg_rtn read_rtn,
 		len = snprintf(buf, bufsize, cur_ptr->nameandfmt,
 			       read_rtn(arg0, arg1, cur_ptr->offset));
 		/* check for snprintf overflow or error */
-		if (len < 0 || (uint32) len >= bufsize)
+		if (len < 0 || (u32) len >= bufsize)
 			len = bufsize - 1;
 		buf += len;
 		bufsize -= len;
--- a/drivers/staging/brcm80211/brcmfmac/dhd.h
+++ b/drivers/staging/brcm80211/brcmfmac/dhd.h
@@ -359,10 +359,10 @@ extern void dhd_os_sdtxunlock(dhd_pub_t
 int setScheduler(struct task_struct *p, int policy, struct sched_param *param);
 
 typedef struct {
-	uint32 limit;		/* Expiration time (usec) */
-	uint32 increment;	/* Current expiration increment (usec) */
-	uint32 elapsed;		/* Current elapsed time (usec) */
-	uint32 tick;		/* O/S tick time (usec) */
+	u32 limit;		/* Expiration time (usec) */
+	u32 increment;	/* Current expiration increment (usec) */
+	u32 elapsed;		/* Current elapsed time (usec) */
+	u32 tick;		/* O/S tick time (usec) */
 } dhd_timeout_t;
 
 extern void dhd_timeout_start(dhd_timeout_t *tmo, uint usec);
@@ -377,7 +377,7 @@ extern void wl_event_to_host_order(wl_ev
 extern void dhd_common_init(void);
 
 extern int dhd_add_if(struct dhd_info *dhd, int ifidx, void *handle,
-		      char *name, u8 *mac_addr, uint32 flags, u8 bssidx);
+		      char *name, u8 *mac_addr, u32 flags, u8 bssidx);
 extern void dhd_del_if(struct dhd_info *dhd, int ifidx);
 
 extern void dhd_vif_add(struct dhd_info *dhd, int ifidx, char *name);
--- a/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
@@ -54,7 +54,7 @@ extern int dhd_preinit_ioctls(dhd_pub_t
 typedef struct dhd_prot {
 	u16 reqid;
 	u8 pending;
-	uint32 lastcmd;
+	u32 lastcmd;
 	u8 bus_header[BUS_HEADER_LEN];
 	cdc_ioctl_t msg;
 	unsigned char buf[WLC_IOCTL_MAXLEN + ROUND_UP_MARGIN];
@@ -78,7 +78,7 @@ static int dhdcdc_msg(dhd_pub_t *dhd)
 	return dhd_bus_txctl(dhd->bus, (unsigned char *)&prot->msg, len);
 }
 
-static int dhdcdc_cmplt(dhd_pub_t *dhd, uint32 id, uint32 len)
+static int dhdcdc_cmplt(dhd_pub_t *dhd, u32 id, u32 len)
 {
 	int ret;
 	dhd_prot_t *prot = dhd->prot;
@@ -103,7 +103,7 @@ dhdcdc_query_ioctl(dhd_pub_t *dhd, int i
 	cdc_ioctl_t *msg = &prot->msg;
 	void *info;
 	int ret = 0, retries = 0;
-	uint32 id, flags = 0;
+	u32 id, flags = 0;
 
 	DHD_TRACE(("%s: Enter\n", __func__));
 	DHD_CTL(("%s: cmd %d len %d\n", __func__, cmd, len));
@@ -182,7 +182,7 @@ int dhdcdc_set_ioctl(dhd_pub_t *dhd, int
 	dhd_prot_t *prot = dhd->prot;
 	cdc_ioctl_t *msg = &prot->msg;
 	int ret = 0;
-	uint32 flags, id;
+	u32 flags, id;
 
 	DHD_TRACE(("%s: Enter\n", __func__));
 	DHD_CTL(("%s: cmd %d len %d\n", __func__, cmd, len));
--- a/drivers/staging/brcm80211/brcmfmac/dhd_common.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_common.c
@@ -30,9 +30,9 @@ char fw_path[MOD_PARAM_PATHLEN];
 char nv_path[MOD_PARAM_PATHLEN];
 
 /* Last connection success/failure status */
-uint32 dhd_conn_event;
-uint32 dhd_conn_status;
-uint32 dhd_conn_reason;
+u32 dhd_conn_event;
+u32 dhd_conn_status;
+u32 dhd_conn_reason;
 
 #define htod32(i) i
 #define htod16(i) i
@@ -200,7 +200,7 @@ static int dhd_dump(dhd_pub_t *dhdp, cha
 }
 
 static int
-dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, uint32 actionid,
+dhd_doiovar(dhd_pub_t *dhd_pub, const bcm_iovar_t *vi, u32 actionid,
 	    const char *name, void *params, int plen, void *arg, int len,
 	    int val_size)
 {
@@ -313,7 +313,7 @@ exit:
 }
 
 /* Store the status of a connection attempt for later retrieval by an iovar */
-void dhd_store_conn_status(uint32 event, uint32 status, uint32 reason)
+void dhd_store_conn_status(u32 event, u32 status, u32 reason)
 {
 	/* Do not overwrite a WLC_E_PRUNE with a WLC_E_SET_SSID
 	 * because an encryption/rsn mismatch results in both events, and
@@ -387,7 +387,7 @@ dhd_iovar_op(dhd_pub_t *dhd_pub, const c
 	int bcmerror = 0;
 	int val_size;
 	const bcm_iovar_t *vi = NULL;
-	uint32 actionid;
+	u32 actionid;
 
 	DHD_TRACE(("%s: Enter\n", __func__));
 
@@ -750,9 +750,9 @@ static void wl_show_host_event(wl_event_
 
 	case WLC_E_TRACE:
 		{
-			static uint32 seqnum_prev;
+			static u32 seqnum_prev;
 			msgtrace_hdr_t hdr;
-			uint32 nblost;
+			u32 nblost;
 			char *s, *p;
 
 			buf = (unsigned char *) event_data;
@@ -835,7 +835,7 @@ wl_host_event(struct dhd_info *dhd, int
 	/* check whether packet is a BRCM event pkt */
 	bcm_event_t *pvt_data = (bcm_event_t *) pktdata;
 	char *event_data;
-	uint32 type, status;
+	u32 type, status;
 	u16 flags;
 	int evlen;
 
@@ -912,7 +912,7 @@ wl_host_event(struct dhd_info *dhd, int
 
 		/* put it back to WLC_E_NDIS_LINK */
 		if (type == WLC_E_NDIS_LINK) {
-			uint32 temp;
+			u32 temp;
 
 			temp = ntoh32_ua((void *)&event->event_type);
 			DHD_TRACE(("Converted to WLC_E_LINK type %d\n", temp));
@@ -1072,8 +1072,8 @@ void dhd_pktfilter_offload_set(dhd_pub_t
 	int buf_len;
 	int str_len;
 	int rc;
-	uint32 mask_size;
-	uint32 pattern_size;
+	u32 mask_size;
+	u32 pattern_size;
 	char *argv[8], *buf = 0;
 	int i = 0;
 	char *arg_save = 0, *arg_org = 0;
@@ -1242,8 +1242,8 @@ int dhd_preinit_ioctls(dhd_pub_t *dhd)
 	uint up = 0;
 	char buf[128], *ptr;
 	uint power_mode = PM_FAST;
-	uint32 dongle_align = DHD_SDALIGN;
-	uint32 glom = 0;
+	u32 dongle_align = DHD_SDALIGN;
+	u32 glom = 0;
 	uint bcn_timeout = 3;
 	int scan_assoc_time = 40;
 	int scan_unassoc_time = 40;
--- a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
@@ -425,8 +425,8 @@ extern int dhd_wait_pend8021x(struct net
 #ifndef BDC
 #error TOE requires BDC
 #endif				/* !BDC */
-static int dhd_toe_get(dhd_info_t *dhd, int idx, uint32 *toe_ol);
-static int dhd_toe_set(dhd_info_t *dhd, int idx, uint32 toe_ol);
+static int dhd_toe_get(dhd_info_t *dhd, int idx, u32 *toe_ol);
+static int dhd_toe_set(dhd_info_t *dhd, int idx, u32 toe_ol);
 #endif				/* TOE */
 
 static int dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,
@@ -712,7 +712,7 @@ static void _dhd_set_multicast_list(dhd_
 {
 	struct net_device *dev;
 	struct netdev_hw_addr *ha;
-	uint32 allmulti, cnt;
+	u32 allmulti, cnt;
 
 	wl_ioctl_t ioc;
 	char *buf, *bufp;
@@ -1434,7 +1434,7 @@ void dhd_sched_dpc(dhd_pub_t *dhdp)
 #ifdef TOE
 /* Retrieve current toe component enables, which are kept
 	 as a bitmap in toe_ol iovar */
-static int dhd_toe_get(dhd_info_t *dhd, int ifidx, uint32 *toe_ol)
+static int dhd_toe_get(dhd_info_t *dhd, int ifidx, u32 *toe_ol)
 {
 	wl_ioctl_t ioc;
 	char buf[32];
@@ -1462,13 +1462,13 @@ static int dhd_toe_get(dhd_info_t *dhd,
 		return ret;
 	}
 
-	memcpy(toe_ol, buf, sizeof(uint32));
+	memcpy(toe_ol, buf, sizeof(u32));
 	return 0;
 }
 
 /* Set current toe component enables in toe_ol iovar,
 	 and set toe global enable iovar */
-static int dhd_toe_set(dhd_info_t *dhd, int ifidx, uint32 toe_ol)
+static int dhd_toe_set(dhd_info_t *dhd, int ifidx, u32 toe_ol)
 {
 	wl_ioctl_t ioc;
 	char buf[32];
@@ -1484,7 +1484,7 @@ static int dhd_toe_set(dhd_info_t *dhd,
 	/* Set toe_ol as requested */
 
 	strcpy(buf, "toe_ol");
-	memcpy(&buf[sizeof("toe_ol")], &toe_ol, sizeof(uint32));
+	memcpy(&buf[sizeof("toe_ol")], &toe_ol, sizeof(u32));
 
 	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
 	if (ret < 0) {
@@ -1498,7 +1498,7 @@ static int dhd_toe_set(dhd_info_t *dhd,
 	toe = (toe_ol != 0);
 
 	strcpy(buf, "toe");
-	memcpy(&buf[sizeof("toe")], &toe, sizeof(uint32));
+	memcpy(&buf[sizeof("toe")], &toe, sizeof(u32));
 
 	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
 	if (ret < 0) {
@@ -1530,17 +1530,17 @@ static int dhd_ethtool(dhd_info_t *dhd,
 {
 	struct ethtool_drvinfo info;
 	char drvname[sizeof(info.driver)];
-	uint32 cmd;
+	u32 cmd;
 #ifdef TOE
 	struct ethtool_value edata;
-	uint32 toe_cmpnt, csum_dir;
+	u32 toe_cmpnt, csum_dir;
 	int ret;
 #endif
 
 	DHD_TRACE(("%s: Enter\n", __func__));
 
 	/* all ethtool calls start with a cmd word */
-	if (copy_from_user(&cmd, uaddr, sizeof(uint32)))
+	if (copy_from_user(&cmd, uaddr, sizeof(u32)))
 		return -EFAULT;
 
 	switch (cmd) {
@@ -1794,7 +1794,7 @@ static int dhd_open(struct net_device *n
 {
 	dhd_info_t *dhd = *(dhd_info_t **) netdev_priv(net);
 #ifdef TOE
-	uint32 toe_ol;
+	u32 toe_ol;
 #endif
 	int ifidx = dhd_net2idx(dhd, net);
 	int32 ret = 0;
@@ -1854,7 +1854,7 @@ void dhd_osl_detach(osl_t *osh)
 
 int
 dhd_add_if(dhd_info_t *dhd, int ifidx, void *handle, char *name,
-	   u8 *mac_addr, uint32 flags, u8 bssidx)
+	   u8 *mac_addr, u32 flags, u8 bssidx)
 {
 	dhd_if_t *ifp;
 
--- a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
@@ -167,18 +167,18 @@ typedef struct dhd_bus {
 	si_t *sih;		/* Handle for SI calls */
 	char *vars;		/* Variables (from CIS and/or other) */
 	uint varsz;		/* Size of variables buffer */
-	uint32 sbaddr;		/* Current SB window pointer (-1, invalid) */
+	u32 sbaddr;		/* Current SB window pointer (-1, invalid) */
 
 	sdpcmd_regs_t *regs;	/* Registers for SDIO core */
 	uint sdpcmrev;		/* SDIO core revision */
 	uint armrev;		/* CPU core revision */
 	uint ramrev;		/* SOCRAM core revision */
-	uint32 ramsize;		/* Size of RAM in SOCRAM (bytes) */
-	uint32 orig_ramsize;	/* Size of RAM in SOCRAM (bytes) */
+	u32 ramsize;		/* Size of RAM in SOCRAM (bytes) */
+	u32 orig_ramsize;	/* Size of RAM in SOCRAM (bytes) */
 
-	uint32 bus;		/* gSPI or SDIO bus */
-	uint32 hostintmask;	/* Copy of Host Interrupt Mask */
-	uint32 intstatus;	/* Intstatus bits (events) pending */
+	u32 bus;		/* gSPI or SDIO bus */
+	u32 hostintmask;	/* Copy of Host Interrupt Mask */
+	u32 intstatus;	/* Intstatus bits (events) pending */
 	bool dpc_sched;		/* Indicates DPC schedule (intrpt rcvd) */
 	bool fcstate;		/* State of dongle flow-control */
 
@@ -295,7 +295,7 @@ typedef struct dhd_bus {
 	uint f1regdata;		/* Number of f1 register accesses */
 
 	u8 *ctrl_frame_buf;
-	uint32 ctrl_frame_len;
+	u32 ctrl_frame_len;
 	bool ctrl_frame_stat;
 } dhd_bus_t;
 
@@ -442,10 +442,10 @@ static void dhdsdio_release_dongle(dhd_b
 static uint process_nvram_vars(char *varbuf, uint len);
 
 static void dhd_dongle_setmemsize(struct dhd_bus *bus, int mem_size);
-static int dhd_bcmsdh_recv_buf(dhd_bus_t *bus, uint32 addr, uint fn,
+static int dhd_bcmsdh_recv_buf(dhd_bus_t *bus, u32 addr, uint fn,
 			       uint flags, u8 *buf, uint nbytes, void *pkt,
 			       bcmsdh_cmplt_fn_t complete, void *handle);
-static int dhd_bcmsdh_send_buf(dhd_bus_t *bus, uint32 addr, uint fn,
+static int dhd_bcmsdh_send_buf(dhd_bus_t *bus, u32 addr, uint fn,
 			       uint flags, u8 *buf, uint nbytes, void *pkt,
 			       bcmsdh_cmplt_fn_t complete, void *handle);
 
@@ -470,7 +470,7 @@ static void dhd_dongle_setmemsize(struct
 		bus->ramsize = dhd_dongle_memsize;
 }
 
-static int dhdsdio_set_siaddr_window(dhd_bus_t *bus, uint32 address)
+static int dhdsdio_set_siaddr_window(dhd_bus_t *bus, u32 address)
 {
 	int err = 0;
 	bcmsdh_cfg_write(bus->sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SBADDRLOW,
@@ -519,7 +519,7 @@ static int dhdsdio_htclk(dhd_bus_t *bus,
 
 		if (pendok && ((bus->sih->buscoretype == PCMCIA_CORE_ID)
 			       && (bus->sih->buscorerev == 9))) {
-			uint32 dummy, retries;
+			u32 dummy, retries;
 			R_SDREG(dummy, &bus->regs->clockctlstatus, retries);
 		}
 
@@ -905,7 +905,7 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 	osl_t *osh;
 	u8 *frame;
 	u16 len, pad = 0;
-	uint32 swheader;
+	u32 swheader;
 	uint retries = 0;
 	bcmsdh_info_t *sdh;
 	void *new;
@@ -1162,7 +1162,7 @@ int dhd_bus_txdata(struct dhd_bus *bus,
 static uint dhdsdio_sendfromq(dhd_bus_t *bus, uint maxframes)
 {
 	void *pkt;
-	uint32 intstatus = 0;
+	u32 intstatus = 0;
 	uint retries = 0;
 	int ret = 0, prec_out;
 	uint cnt = 0;
@@ -1223,7 +1223,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 {
 	u8 *frame;
 	u16 len;
-	uint32 swheader;
+	u32 swheader;
 	uint retries = 0;
 	bcmsdh_info_t *sdh = bus->sdh;
 	u8 doff = 0;
@@ -1692,11 +1692,11 @@ static int dhdsdio_pktgen_set(dhd_bus_t
 #endif				/* SDTEST */
 
 static int
-dhdsdio_membytes(dhd_bus_t *bus, bool write, uint32 address, u8 *data,
+dhdsdio_membytes(dhd_bus_t *bus, bool write, u32 address, u8 *data,
 		 uint size)
 {
 	int bcmerror = 0;
-	uint32 sdaddr;
+	u32 sdaddr;
 	uint dsize;
 
 	/* Determine initial transfer parameters */
@@ -1754,7 +1754,7 @@ xfer_done:
 #ifdef DHD_DEBUG
 static int dhdsdio_readshared(dhd_bus_t *bus, sdpcm_shared_t *sh)
 {
-	uint32 addr;
+	u32 addr;
 	int rv;
 
 	/* Read last word in memory to determine address of
@@ -1987,7 +1987,7 @@ static int dhdsdio_readconsole(dhd_bus_t
 {
 	dhd_console_t *c = &bus->console;
 	u8 line[CONSOLE_LINE_MAX], ch;
-	uint32 n, idx, addr;
+	u32 n, idx, addr;
 	int rv;
 
 	/* Don't do anything until FWREADY updates console address */
@@ -2095,7 +2095,7 @@ err:
 }
 
 static int
-dhdsdio_doiovar(dhd_bus_t *bus, const bcm_iovar_t *vi, uint32 actionid,
+dhdsdio_doiovar(dhd_bus_t *bus, const bcm_iovar_t *vi, u32 actionid,
 		const char *name, void *params, int plen, void *arg, int len,
 		int val_size)
 {
@@ -2208,7 +2208,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 	case IOV_SVAL(IOV_MEMBYTES):
 	case IOV_GVAL(IOV_MEMBYTES):
 		{
-			uint32 address;
+			u32 address;
 			uint size, dsize;
 			u8 *data;
 
@@ -2216,7 +2216,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 
 			ASSERT(plen >= 2 * sizeof(int));
 
-			address = (uint32) int_val;
+			address = (u32) int_val;
 			bcopy((char *)params + sizeof(int_val), &int_val,
 			      sizeof(int_val));
 			size = (uint) int_val;
@@ -2332,7 +2332,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 	case IOV_GVAL(IOV_SDREG):
 		{
 			sdreg_t *sd_ptr;
-			uint32 addr, size;
+			u32 addr, size;
 
 			sd_ptr = (sdreg_t *) params;
 
@@ -2348,7 +2348,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 	case IOV_SVAL(IOV_SDREG):
 		{
 			sdreg_t *sd_ptr;
-			uint32 addr, size;
+			u32 addr, size;
 
 			sd_ptr = (sdreg_t *) params;
 
@@ -2365,7 +2365,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 	case IOV_GVAL(IOV_SBREG):
 		{
 			sdreg_t sdreg;
-			uint32 addr, size;
+			u32 addr, size;
 
 			bcopy(params, &sdreg, sizeof(sdreg));
 
@@ -2381,7 +2381,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 	case IOV_SVAL(IOV_SBREG):
 		{
 			sdreg_t sdreg;
-			uint32 addr, size;
+			u32 addr, size;
 
 			bcopy(params, &sdreg, sizeof(sdreg));
 
@@ -2512,10 +2512,10 @@ exit:
 static int dhdsdio_write_vars(dhd_bus_t *bus)
 {
 	int bcmerror = 0;
-	uint32 varsize;
-	uint32 varaddr;
+	u32 varsize;
+	u32 varaddr;
 	u8 *vbuffer;
-	uint32 varsizew;
+	u32 varsizew;
 #ifdef DHD_DEBUG
 	char *nvram_ularray;
 #endif				/* DHD_DEBUG */
@@ -2639,7 +2639,7 @@ static int dhdsdio_download_state(dhd_bu
 
 		/* Clear the top bit of memory */
 		if (bus->ramsize) {
-			uint32 zeros = 0;
+			u32 zeros = 0;
 			dhdsdio_membytes(bus, TRUE, bus->ramsize - 4,
 					 (u8 *)&zeros, 4);
 		}
@@ -2710,7 +2710,7 @@ dhd_bus_iovar_op(dhd_pub_t *dhdp, const
 	const bcm_iovar_t *vi = NULL;
 	int bcmerror = 0;
 	int val_size;
-	uint32 actionid;
+	u32 actionid;
 
 	DHD_TRACE(("%s: Enter\n", __func__));
 
@@ -2823,7 +2823,7 @@ exit:
 void dhd_bus_stop(struct dhd_bus *bus, bool enforce_mutex)
 {
 	osl_t *osh = bus->dhd->osh;
-	uint32 local_hostintmask;
+	u32 local_hostintmask;
 	u8 saveclk;
 	uint retries;
 	int err;
@@ -4208,11 +4208,11 @@ deliver:
 	return rxcount;
 }
 
-static uint32 dhdsdio_hostmail(dhd_bus_t *bus)
+static u32 dhdsdio_hostmail(dhd_bus_t *bus)
 {
 	sdpcmd_regs_t *regs = bus->regs;
-	uint32 intstatus = 0;
-	uint32 hmb_data;
+	u32 intstatus = 0;
+	u32 hmb_data;
 	u8 fcbits;
 	uint retries = 0;
 
@@ -4286,7 +4286,7 @@ bool dhdsdio_dpc(dhd_bus_t *bus)
 {
 	bcmsdh_info_t *sdh = bus->sdh;
 	sdpcmd_regs_t *regs = bus->regs;
-	uint32 intstatus, newstatus = 0;
+	u32 intstatus, newstatus = 0;
 	uint retries = 0;
 	uint rxlimit = dhd_rxbound;	/* Rx frames to read before resched */
 	uint txlimit = dhd_txbound;	/* Tx frames to send before resched */
@@ -4460,7 +4460,7 @@ clkwait:
 		ret =
 		    dhd_bcmsdh_send_buf(bus, bcmsdh_cur_sbwad(sdh), SDIO_FUNC_2,
 					F2SYNC, (u8 *) bus->ctrl_frame_buf,
-					(uint32) bus->ctrl_frame_len, NULL,
+					(u32) bus->ctrl_frame_len, NULL,
 					NULL, NULL);
 		ASSERT(ret != BCME_PENDING);
 
@@ -4875,7 +4875,7 @@ extern bool dhd_bus_watchdog(dhd_pub_t *
 
 	/* Poll period: check device if appropriate. */
 	if (bus->poll && (++bus->polltick >= bus->pollrate)) {
-		uint32 intstatus = 0;
+		u32 intstatus = 0;
 
 		/* Reset poll tick */
 		bus->polltick = 0;
@@ -4957,7 +4957,7 @@ extern bool dhd_bus_watchdog(dhd_pub_t *
 extern int dhd_bus_console_in(dhd_pub_t *dhdp, unsigned char *msg, uint msglen)
 {
 	dhd_bus_t *bus = dhdp->bus;
-	uint32 addr, val;
+	u32 addr, val;
 	int rv;
 	void *pkt;
 
@@ -5765,9 +5765,9 @@ static int dhdsdio_download_code_file(st
 			   __func__, MEMBLOCK));
 		goto err;
 	}
-	if ((uint32) (uintptr) memblock % DHD_SDALIGN)
+	if ((u32) (uintptr) memblock % DHD_SDALIGN)
 		memptr +=
-		    (DHD_SDALIGN - ((uint32) (uintptr) memblock % DHD_SDALIGN));
+		    (DHD_SDALIGN - ((u32) (uintptr) memblock % DHD_SDALIGN));
 
 	/* Download image */
 	while ((len =
@@ -6010,7 +6010,7 @@ err:
 }
 
 static int
-dhd_bcmsdh_recv_buf(dhd_bus_t *bus, uint32 addr, uint fn, uint flags,
+dhd_bcmsdh_recv_buf(dhd_bus_t *bus, u32 addr, uint fn, uint flags,
 		    u8 *buf, uint nbytes, void *pkt,
 		    bcmsdh_cmplt_fn_t complete, void *handle)
 {
@@ -6024,7 +6024,7 @@ dhd_bcmsdh_recv_buf(dhd_bus_t *bus, uint
 }
 
 static int
-dhd_bcmsdh_send_buf(dhd_bus_t *bus, uint32 addr, uint fn, uint flags,
+dhd_bcmsdh_send_buf(dhd_bus_t *bus, u32 addr, uint fn, uint flags,
 		    u8 *buf, uint nbytes, void *pkt,
 		    bcmsdh_cmplt_fn_t complete, void *handle)
 {
@@ -6091,7 +6091,7 @@ int dhd_bus_devreset(dhd_pub_t *dhdp, u8
 
 			/* Attempt to re-attach & download */
 			if (dhdsdio_probe_attach(bus, bus->dhd->osh, bus->sdh,
-						 (uint32 *) SI_ENUM_BASE,
+						 (u32 *) SI_ENUM_BASE,
 						 bus->cl_devid)) {
 				/* Attempt to download binary to the dongle */
 				if (dhdsdio_probe_init
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
@@ -50,7 +50,7 @@
 static struct sdio_func *cfg80211_sdio_func;
 static struct wl_dev *wl_cfg80211_dev;
 
-uint32 wl_dbg_level = WL_DBG_ERR | WL_DBG_INFO;
+u32 wl_dbg_level = WL_DBG_ERR | WL_DBG_INFO;
 
 #define WL_4329_FW_FILE "brcm/bcm4329-fullmac-4-218-248-5.bin"
 #define WL_4329_NVRAM_FILE "brcm/bcm4329-fullmac-4-218-248-5.txt"
@@ -60,14 +60,14 @@ uint32 wl_dbg_level = WL_DBG_ERR | WL_DB
 */
 static int32 wl_cfg80211_change_iface(struct wiphy *wiphy,
 				      struct net_device *ndev,
-				      enum nl80211_iftype type, uint32 *flags,
+				      enum nl80211_iftype type, u32 *flags,
 				      struct vif_params *params);
 static int32 __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 				struct cfg80211_scan_request *request,
 				struct cfg80211_ssid *this_ssid);
 static int32 wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
 			      struct cfg80211_scan_request *request);
-static int32 wl_cfg80211_set_wiphy_params(struct wiphy *wiphy, uint32 changed);
+static int32 wl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed);
 static int32 wl_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,
 				   struct cfg80211_ibss_params *params);
 static int32 wl_cfg80211_leave_ibss(struct wiphy *wiphy,
@@ -129,7 +129,7 @@ static void wl_unlock_eq(struct wl_priv
 static void wl_init_eq_lock(struct wl_priv *wl);
 static void wl_init_eloop_handler(struct wl_event_loop *el);
 static struct wl_event_q *wl_deq_event(struct wl_priv *wl);
-static int32 wl_enq_event(struct wl_priv *wl, uint32 type,
+static int32 wl_enq_event(struct wl_priv *wl, u32 type,
 			  const wl_event_msg_t *msg, void *data);
 static void wl_put_event(struct wl_event_q *e);
 static void wl_wakeup_event(struct wl_priv *wl);
@@ -165,15 +165,15 @@ static __used int32 wl_dev_bufvar_set(st
 static int32 wl_dev_intvar_set(struct net_device *dev, s8 *name, int32 val);
 static int32 wl_dev_intvar_get(struct net_device *dev, s8 *name,
 			       int32 *retval);
-static int32 wl_dev_ioctl(struct net_device *dev, uint32 cmd, void *arg,
-			  uint32 len);
+static int32 wl_dev_ioctl(struct net_device *dev, u32 cmd, void *arg,
+			  u32 len);
 
 /*
 ** cfg80211 set_wiphy_params utilities
 */
-static int32 wl_set_frag(struct net_device *dev, uint32 frag_threshold);
-static int32 wl_set_rts(struct net_device *dev, uint32 frag_threshold);
-static int32 wl_set_retry(struct net_device *dev, uint32 retry, bool l);
+static int32 wl_set_frag(struct net_device *dev, u32 frag_threshold);
+static int32 wl_set_rts(struct net_device *dev, u32 frag_threshold);
+static int32 wl_set_retry(struct net_device *dev, u32 retry, bool l);
 
 /*
 ** wl profile utilities
@@ -205,7 +205,7 @@ static void wl_rst_ie(struct wl_priv *wl
 static int32 wl_add_ie(struct wl_priv *wl, u8 t, u8 l, u8 *v);
 static int32 wl_mrg_ie(struct wl_priv *wl, u8 *ie_stream, u16 ie_size);
 static int32 wl_cp_ie(struct wl_priv *wl, u8 *dst, u16 dst_size);
-static uint32 wl_get_ielen(struct wl_priv *wl);
+static u32 wl_get_ielen(struct wl_priv *wl);
 
 static int32 wl_mode_to_nl80211_iftype(int32 mode);
 
@@ -233,7 +233,7 @@ static void swap_key_to_BE(struct wl_wse
 static int32 wl_init_priv_mem(struct wl_priv *wl);
 static void wl_deinit_priv_mem(struct wl_priv *wl);
 
-static void wl_delay(uint32 ms);
+static void wl_delay(u32 ms);
 
 /*
 ** store/restore cfg80211 instance data
@@ -267,19 +267,19 @@ static void wl_init_conf(struct wl_conf
 #ifndef EMBEDDED_PLATFORM
 static int32 wl_dongle_mode(struct net_device *ndev, int32 iftype);
 static int32 wl_dongle_country(struct net_device *ndev, u8 ccode);
-static int32 wl_dongle_up(struct net_device *ndev, uint32 up);
-static int32 wl_dongle_power(struct net_device *ndev, uint32 power_mode);
-static int32 wl_dongle_glom(struct net_device *ndev, uint32 glom,
-			    uint32 dongle_align);
-static int32 wl_dongle_roam(struct net_device *ndev, uint32 roamvar,
-			    uint32 bcn_timeout);
+static int32 wl_dongle_up(struct net_device *ndev, u32 up);
+static int32 wl_dongle_power(struct net_device *ndev, u32 power_mode);
+static int32 wl_dongle_glom(struct net_device *ndev, u32 glom,
+			    u32 dongle_align);
+static int32 wl_dongle_roam(struct net_device *ndev, u32 roamvar,
+			    u32 bcn_timeout);
 static int32 wl_dongle_eventmsg(struct net_device *ndev);
 static int32 wl_dongle_scantime(struct net_device *ndev, int32 scan_assoc_time,
 				int32 scan_unassoc_time);
 static int32 wl_dongle_offload(struct net_device *ndev, int32 arpoe,
 			       int32 arp_ol);
 static int32 wl_pattern_atoh(s8 *src, s8 *dst);
-static int32 wl_dongle_filter(struct net_device *ndev, uint32 filter_mode);
+static int32 wl_dongle_filter(struct net_device *ndev, u32 filter_mode);
 static int32 wl_update_wiphybands(struct wl_priv *wl);
 #endif				/* !EMBEDDED_PLATFORM */
 static int32 wl_config_dongle(struct wl_priv *wl, bool need_lock);
@@ -302,7 +302,7 @@ static int32 wl_run_iscan(struct wl_isca
 static int32 wl_do_iscan(struct wl_priv *wl);
 static int32 wl_wakeup_iscan(struct wl_iscan_ctrl *iscan);
 static int32 wl_invoke_iscan(struct wl_priv *wl);
-static int32 wl_get_iscan_results(struct wl_iscan_ctrl *iscan, uint32 *status,
+static int32 wl_get_iscan_results(struct wl_iscan_ctrl *iscan, u32 *status,
 				  struct wl_scan_results **bss_list);
 static void wl_notify_iscan_complete(struct wl_iscan_ctrl *iscan, bool aborted);
 static void wl_init_iscan_eloop(struct wl_iscan_eloop *el);
@@ -319,7 +319,7 @@ static void wl_init_fw(struct wl_fw_ctrl
 /*
 * find most significant bit set
 */
-static __used uint32 wl_find_msb(u16 bit16);
+static __used u32 wl_find_msb(u16 bit16);
 
 /*
 * update pmklist to dongle
@@ -540,7 +540,7 @@ static struct ieee80211_supported_band _
 	.n_bitrates = wl_a_rates_size,
 };
 
-static const uint32 __wl_cipher_suites[] = {
+static const u32 __wl_cipher_suites[] = {
 	WLAN_CIPHER_SUITE_WEP40,
 	WLAN_CIPHER_SUITE_WEP104,
 	WLAN_CIPHER_SUITE_TKIP,
@@ -571,7 +571,7 @@ static void swap_key_to_BE(struct wl_wse
 }
 
 static int32
-wl_dev_ioctl(struct net_device *dev, uint32 cmd, void *arg, uint32 len)
+wl_dev_ioctl(struct net_device *dev, u32 cmd, void *arg, u32 len)
 {
 	struct ifreq ifr;
 	struct wl_ioctl ioc;
@@ -595,7 +595,7 @@ wl_dev_ioctl(struct net_device *dev, uin
 
 static int32
 wl_cfg80211_change_iface(struct wiphy *wiphy, struct net_device *ndev,
-			 enum nl80211_iftype type, uint32 *flags,
+			 enum nl80211_iftype type, u32 *flags,
 			 struct vif_params *params)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
@@ -866,7 +866,7 @@ wl_cfg80211_scan(struct wiphy *wiphy, st
 static int32 wl_dev_intvar_set(struct net_device *dev, s8 *name, int32 val)
 {
 	s8 buf[WLC_IOCTL_SMLEN];
-	uint32 len;
+	u32 len;
 	int32 err = 0;
 
 	val = htod32(val);
@@ -888,8 +888,8 @@ wl_dev_intvar_get(struct net_device *dev
 		s8 buf[WLC_IOCTL_SMLEN];
 		int32 val;
 	} var;
-	uint32 len;
-	uint32 data_null;
+	u32 len;
+	u32 data_null;
 	int32 err = 0;
 
 	len =
@@ -905,7 +905,7 @@ wl_dev_intvar_get(struct net_device *dev
 	return err;
 }
 
-static int32 wl_set_rts(struct net_device *dev, uint32 rts_threshold)
+static int32 wl_set_rts(struct net_device *dev, u32 rts_threshold)
 {
 	int32 err = 0;
 
@@ -917,7 +917,7 @@ static int32 wl_set_rts(struct net_devic
 	return err;
 }
 
-static int32 wl_set_frag(struct net_device *dev, uint32 frag_threshold)
+static int32 wl_set_frag(struct net_device *dev, u32 frag_threshold)
 {
 	int32 err = 0;
 
@@ -929,10 +929,10 @@ static int32 wl_set_frag(struct net_devi
 	return err;
 }
 
-static int32 wl_set_retry(struct net_device *dev, uint32 retry, bool l)
+static int32 wl_set_retry(struct net_device *dev, u32 retry, bool l)
 {
 	int32 err = 0;
-	uint32 cmd = (l ? WLC_SET_LRL : WLC_SET_SRL);
+	u32 cmd = (l ? WLC_SET_LRL : WLC_SET_SRL);
 
 	retry = htod32(retry);
 	err = wl_dev_ioctl(dev, cmd, &retry, sizeof(retry));
@@ -943,7 +943,7 @@ static int32 wl_set_retry(struct net_dev
 	return err;
 }
 
-static int32 wl_cfg80211_set_wiphy_params(struct wiphy *wiphy, uint32 changed)
+static int32 wl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
 {
 	struct wl_priv *wl = wiphy_to_wl(wiphy);
 	struct net_device *ndev = wl_to_ndev(wl);
@@ -1270,8 +1270,8 @@ wl_set_set_sharedkey(struct net_device *
 && (sec->cipher_pairwise & (WLAN_CIPHER_SUITE_WEP40 |
 			    WLAN_CIPHER_SUITE_WEP104))) {
 			memset(&key, 0, sizeof(key));
-			key.len = (uint32) sme->key_len;
-			key.index = (uint32) sme->key_idx;
+			key.len = (u32) sme->key_len;
+			key.index = (u32) sme->key_idx;
 			if (unlikely(key.len > sizeof(key.data))) {
 				WL_ERR(("Too long key length (%u)\n", key.len));
 				return -EINVAL;
@@ -1481,7 +1481,7 @@ static int32
 wl_cfg80211_config_default_key(struct wiphy *wiphy, struct net_device *dev,
 			       u8 key_idx)
 {
-	uint32 index;
+	u32 index;
 	int32 wsec;
 	int32 err = 0;
 
@@ -1496,7 +1496,7 @@ wl_cfg80211_config_default_key(struct wi
 	wsec = dtoh32(wsec);
 	if (wsec & WEP_ENABLED) {
 		/* Just select a new current key */
-		index = (uint32) key_idx;
+		index = (u32) key_idx;
 		index = htod32(index);
 		err = wl_dev_ioctl(dev, WLC_SET_KEY_PRIMARY, &index,
 				sizeof(index));
@@ -1515,12 +1515,12 @@ wl_add_keyext(struct wiphy *wiphy, struc
 	int32 err = 0;
 
 	memset(&key, 0, sizeof(key));
-	key.index = (uint32) key_idx;
+	key.index = (u32) key_idx;
 	/* Instead of bcast for ea address for default wep keys,
 		 driver needs it to be Null */
 	if (!ETHER_ISMULTI(mac_addr))
 		memcpy((char *)&key.ea, (void *)mac_addr, ETHER_ADDR_LEN);
-	key.len = (uint32) params->key_len;
+	key.len = (u32) params->key_len;
 	/* check for key index change */
 	if (key.len == 0) {
 		/* key delete */
@@ -1611,8 +1611,8 @@ wl_cfg80211_add_key(struct wiphy *wiphy,
 		return wl_add_keyext(wiphy, dev, key_idx, mac_addr, params);
 	memset(&key, 0, sizeof(key));
 
-	key.len = (uint32) params->key_len;
-	key.index = (uint32) key_idx;
+	key.len = (u32) params->key_len;
+	key.index = (u32) key_idx;
 
 	if (unlikely(key.len > sizeof(key.data))) {
 		WL_ERR(("Too long key length (%u)\n", key.len));
@@ -1691,7 +1691,7 @@ wl_cfg80211_del_key(struct wiphy *wiphy,
 	CHECK_SYS_UP();
 	memset(&key, 0, sizeof(key));
 
-	key.index = (uint32) key_idx;
+	key.index = (u32) key_idx;
 	key.flags = WL_PRIMARY_KEY;
 	key.algo = CRYPTO_ALGO_OFF;
 
@@ -1867,9 +1867,9 @@ wl_cfg80211_set_power_mgmt(struct wiphy
 	return err;
 }
 
-static __used uint32 wl_find_msb(u16 bit16)
+static __used u32 wl_find_msb(u16 bit16)
 {
-	uint32 ret = 0;
+	u32 ret = 0;
 
 	if (bit16 & 0xff00) {
 		ret += 8;
@@ -1904,7 +1904,7 @@ wl_cfg80211_set_bitrate_mask(struct wiph
 	int32 val;
 	int32 err_bg;
 	int32 err_a;
-	uint32 legacy;
+	u32 legacy;
 	int32 err = 0;
 
 	CHECK_SYS_UP();
@@ -2252,8 +2252,8 @@ static int32 wl_inform_single_bss(struct
 	struct ieee80211_supported_band *band;
 	struct wl_cfg80211_bss_info *notif_bss_info;
 	struct wl_scan_req *sr = wl_to_sr(wl);
-	uint32 signal;
-	uint32 freq;
+	u32 signal;
+	u32 freq;
 	int32 err = 0;
 
 	if (unlikely(dtoh32(bi->length) > WL_BSS_INFO_MAX)) {
@@ -2316,7 +2316,7 @@ static int32 wl_inform_single_bss(struct
 
 static bool wl_is_linkup(struct wl_priv *wl, const wl_event_msg_t *e)
 {
-	uint32 event = ntoh32(e->event_type);
+	u32 event = ntoh32(e->event_type);
 	u16 flags = ntoh16(e->flags);
 
 	if (event == WLC_E_JOIN || event == WLC_E_ASSOC_IND
@@ -2338,7 +2338,7 @@ static bool wl_is_linkup(struct wl_priv
 
 static bool wl_is_linkdown(struct wl_priv *wl, const wl_event_msg_t *e)
 {
-	uint32 event = ntoh32(e->event_type);
+	u32 event = ntoh32(e->event_type);
 	u16 flags = ntoh16(e->flags);
 
 	if (event == WLC_E_DEAUTH_IND || event == WLC_E_DISASSOC_IND) {
@@ -2353,8 +2353,8 @@ static bool wl_is_linkdown(struct wl_pri
 
 static bool wl_is_nonetwork(struct wl_priv *wl, const wl_event_msg_t *e)
 {
-	uint32 event = ntoh32(e->event_type);
-	uint32 status = ntoh32(e->status);
+	u32 event = ntoh32(e->event_type);
+	u32 status = ntoh32(e->status);
 
 	if (event == WLC_E_SET_SSID || event == WLC_E_LINK) {
 		if (status == WLC_E_STATUS_NO_NETWORKS)
@@ -2415,7 +2415,7 @@ static __used int32
 wl_dev_bufvar_set(struct net_device *dev, s8 *name, s8 *buf, int32 len)
 {
 	struct wl_priv *wl = ndev_to_wl(dev);
-	uint32 buflen;
+	u32 buflen;
 
 	buflen = bcm_mkiovar(name, buf, len, wl->ioctl_buf, WL_IOCTL_LEN_MAX);
 	BUG_ON(unlikely(!buflen));
@@ -2428,7 +2428,7 @@ wl_dev_bufvar_get(struct net_device *dev
 		  int32 buf_len)
 {
 	struct wl_priv *wl = ndev_to_wl(dev);
-	uint32 len;
+	u32 len;
 	int32 err = 0;
 
 	len = bcm_mkiovar(name, NULL, 0, wl->ioctl_buf, WL_IOCTL_LEN_MAX);
@@ -2449,8 +2449,8 @@ static int32 wl_get_assoc_ies(struct wl_
 	struct net_device *ndev = wl_to_ndev(wl);
 	struct wl_assoc_ielen *assoc_info;
 	struct wl_connect_info *conn_info = wl_to_conn(wl);
-	uint32 req_len;
-	uint32 resp_len;
+	u32 req_len;
+	u32 resp_len;
 	int32 err = 0;
 
 	err = wl_dev_bufvar_get(ndev, "assoc_info", wl->extra_buf,
@@ -2515,7 +2515,7 @@ static int32 wl_update_bss_info(struct w
 	rtnl_lock();
 	if (unlikely(!bss)) {
 		WL_DBG(("Could not find the AP\n"));
-		*(uint32 *) wl->extra_buf = htod32(WL_EXTRA_BUF_MAX);
+		*(u32 *) wl->extra_buf = htod32(WL_EXTRA_BUF_MAX);
 		err = wl_dev_ioctl(wl_to_ndev(wl), WLC_GET_BSS_INFO,
 				wl->extra_buf, WL_EXTRA_BUF_MAX);
 		if (unlikely(err)) {
@@ -2624,7 +2624,7 @@ wl_notify_scan_status(struct wl_priv *wl
 {
 	struct channel_info channel_inform;
 	struct wl_scan_results *bss_list;
-	uint32 len = WL_SCAN_BUF_MAX;
+	u32 len = WL_SCAN_BUF_MAX;
 	int32 err = 0;
 
 	if (wl->iscan_on && wl->iscan_kickstart)
@@ -2678,11 +2678,11 @@ scan_done_out:
 
 static void wl_init_conf(struct wl_conf *conf)
 {
-	conf->mode = (uint32)-1;
-	conf->frag_threshold = (uint32)-1;
-	conf->rts_threshold = (uint32)-1;
-	conf->retry_short = (uint32)-1;
-	conf->retry_long = (uint32)-1;
+	conf->mode = (u32)-1;
+	conf->frag_threshold = (u32)-1;
+	conf->rts_threshold = (u32)-1;
+	conf->retry_short = (u32)-1;
+	conf->retry_long = (u32)-1;
 	conf->tx_power = -1;
 }
 
@@ -2852,7 +2852,7 @@ static int32 wl_wakeup_iscan(struct wl_i
 }
 
 static int32
-wl_get_iscan_results(struct wl_iscan_ctrl *iscan, uint32 *status,
+wl_get_iscan_results(struct wl_iscan_ctrl *iscan, u32 *status,
 		     struct wl_scan_results **bss_list)
 {
 	struct wl_iscan_results list;
@@ -2948,7 +2948,7 @@ static int32 wl_iscan_thread(void *data)
 	struct wl_iscan_ctrl *iscan = (struct wl_iscan_ctrl *)data;
 	struct wl_priv *wl = iscan_to_wl(iscan);
 	struct wl_iscan_eloop *el = &iscan->el;
-	uint32 status;
+	u32 status;
 	int err = 0;
 
 	sched_setscheduler(current, SCHED_FIFO, &param);
@@ -3192,7 +3192,7 @@ static int32 wl_event_handler(void *data
 void
 wl_cfg80211_event(struct net_device *ndev, const wl_event_msg_t * e, void *data)
 {
-	uint32 event_type = ntoh32(e->event_type);
+	u32 event_type = ntoh32(e->event_type);
 	struct wl_priv *wl = ndev_to_wl(ndev);
 #if (WL_DBG_LEVEL > 0)
 	s8 *estr = (event_type <= sizeof(wl_dbg_estr) / WL_DBG_ESTR_MAX - 1) ?
@@ -3245,7 +3245,7 @@ static struct wl_event_q *wl_deq_event(s
 */
 
 static int32
-wl_enq_event(struct wl_priv *wl, uint32 event, const wl_event_msg_t *msg,
+wl_enq_event(struct wl_priv *wl, u32 event, const wl_event_msg_t *msg,
 	     void *data)
 {
 	struct wl_event_q *e;
@@ -3337,7 +3337,7 @@ static int32 wl_dongle_country(struct ne
 	return err;
 }
 
-static int32 wl_dongle_up(struct net_device *ndev, uint32 up)
+static int32 wl_dongle_up(struct net_device *ndev, u32 up)
 {
 	int32 err = 0;
 
@@ -3348,7 +3348,7 @@ static int32 wl_dongle_up(struct net_dev
 	return err;
 }
 
-static int32 wl_dongle_power(struct net_device *ndev, uint32 power_mode)
+static int32 wl_dongle_power(struct net_device *ndev, u32 power_mode)
 {
 	int32 err = 0;
 
@@ -3360,7 +3360,7 @@ static int32 wl_dongle_power(struct net_
 }
 
 static int32
-wl_dongle_glom(struct net_device *ndev, uint32 glom, uint32 dongle_align)
+wl_dongle_glom(struct net_device *ndev, u32 glom, u32 dongle_align)
 {
 	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 						 '\0' + bitvec  */
@@ -3386,7 +3386,7 @@ dongle_glom_out:
 }
 
 static int32
-wl_dongle_roam(struct net_device *ndev, uint32 roamvar, uint32 bcn_timeout)
+wl_dongle_roam(struct net_device *ndev, u32 roamvar, u32 bcn_timeout)
 {
 	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 						 '\0' + bitvec  */
@@ -3551,7 +3551,7 @@ static int32 wl_pattern_atoh(s8 *src, s8
 	return i;
 }
 
-static int32 wl_dongle_filter(struct net_device *ndev, uint32 filter_mode)
+static int32 wl_dongle_filter(struct net_device *ndev, u32 filter_mode)
 {
 	s8 iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" +
 							 '\0' + bitvec  */
@@ -3560,8 +3560,8 @@ static int32 wl_dongle_filter(struct net
 	struct wl_pkt_filter *pkt_filterp;
 	int32 buf_len;
 	int32 str_len;
-	uint32 mask_size;
-	uint32 pattern_size;
+	u32 mask_size;
+	u32 pattern_size;
 	s8 buf[256];
 	int32 err = 0;
 
@@ -3852,7 +3852,7 @@ wl_update_prof(struct wl_priv *wl, const
 	return err;
 }
 
-void wl_cfg80211_dbg_level(uint32 level)
+void wl_cfg80211_dbg_level(u32 level)
 {
 	/*
 	* prohibit to change debug level
@@ -3926,7 +3926,7 @@ static int32 wl_cp_ie(struct wl_priv *wl
 	return err;
 }
 
-static uint32 wl_get_ielen(struct wl_priv *wl)
+static u32 wl_get_ielen(struct wl_priv *wl)
 {
 	struct wl_ie *ie = wl_to_ie(wl);
 
@@ -3966,7 +3966,7 @@ static void wl_init_eq_lock(struct wl_pr
 	spin_lock_init(&wl->eq_lock);
 }
 
-static void wl_delay(uint32 ms)
+static void wl_delay(u32 ms)
 {
 	if (ms < 1000 / HZ) {
 		cond_resched();
@@ -3986,7 +3986,7 @@ static void *wl_get_drvdata(struct wl_de
 	return dev->driver_data;
 }
 
-int32 wl_cfg80211_read_fw(s8 *buf, uint32 size)
+int32 wl_cfg80211_read_fw(s8 *buf, u32 size)
 {
 	const struct firmware *fw_entry;
 	struct wl_priv *wl;
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
@@ -153,11 +153,11 @@ enum wl_fw_status {
 
 /* dongle configuration */
 struct wl_conf {
-	uint32 mode;		/* adhoc , infrastructure or ap */
-	uint32 frag_threshold;
-	uint32 rts_threshold;
-	uint32 retry_short;
-	uint32 retry_long;
+	u32 mode;		/* adhoc , infrastructure or ap */
+	u32 frag_threshold;
+	u32 rts_threshold;
+	u32 retry_short;
+	u32 retry_long;
 	int32 tx_power;
 	struct ieee80211_channel channel;
 };
@@ -201,18 +201,18 @@ struct wl_ie {
 /* event queue for cfg80211 main event */
 struct wl_event_q {
 	struct list_head eq_list;
-	uint32 etype;
+	u32 etype;
 	wl_event_msg_t emsg;
 	s8 edata[1];
 };
 
 /* security information with currently associated ap */
 struct wl_security {
-	uint32 wpa_versions;
-	uint32 auth_type;
-	uint32 cipher_pairwise;
-	uint32 cipher_group;
-	uint32 wpa_auth;
+	u32 wpa_versions;
+	u32 auth_type;
+	u32 cipher_pairwise;
+	u32 cipher_group;
+	u32 wpa_auth;
 };
 
 /* ibss information for currently joined ibss network */
@@ -226,7 +226,7 @@ struct wl_ibss {
 
 /* dongle profile */
 struct wl_profile {
-	uint32 mode;
+	u32 mode;
 	struct wlc_ssid ssid;
 	u8 bssid[ETHER_ADDR_LEN];
 	struct wl_security sec;
@@ -244,8 +244,8 @@ struct wl_iscan_eloop {
 struct wl_iscan_ctrl {
 	struct net_device *dev;
 	struct timer_list timer;
-	uint32 timer_ms;
-	uint32 timer_on;
+	u32 timer_ms;
+	u32 timer_on;
 	int32 state;
 	int32 pid;
 	struct semaphore sync;
@@ -268,15 +268,15 @@ struct wl_connect_info {
 struct wl_fw_ctrl {
 	const struct firmware *fw_entry;
 	unsigned long status;
-	uint32 ptr;
+	u32 ptr;
 	s8 fw_name[WL_FILE_NAME_MAX];
 	s8 nvram_name[WL_FILE_NAME_MAX];
 };
 
 /* assoc ie length */
 struct wl_assoc_ielen {
-	uint32 req_len;
-	uint32 resp_len;
+	u32 req_len;
+	u32 resp_len;
 };
 
 /* wpa2 pmk list */
@@ -318,7 +318,7 @@ struct wl_priv {
 	int32 event_pid;	/* pid of main event handler thread */
 	unsigned long status;		/* current dongle status */
 	void *pub;
-	uint32 channel;		/* current channel */
+	u32 channel;		/* current channel */
 	bool iscan_on;		/* iscan on/off switch */
 	bool iscan_kickstart;	/* indicate iscan already started */
 	bool active_scan;	/* current scan mode */
@@ -369,11 +369,11 @@ extern void wl_cfg80211_sdio_func(void *
 extern struct sdio_func *wl_cfg80211_get_sdio_func(void);	/* set sdio function info */
 extern int32 wl_cfg80211_up(void);	/* dongle up */
 extern int32 wl_cfg80211_down(void);	/* dongle down */
-extern void wl_cfg80211_dbg_level(uint32 level);	/* set dongle
+extern void wl_cfg80211_dbg_level(u32 level);	/* set dongle
 							 debugging level */
 extern void *wl_cfg80211_request_fw(s8 *file_name);	/* request fw /nvram
 							 downloading */
-extern int32 wl_cfg80211_read_fw(s8 *buf, uint32 size);	/* read fw
+extern int32 wl_cfg80211_read_fw(s8 *buf, u32 size);	/* read fw
 								 image */
 extern void wl_cfg80211_release_fw(void);	/* release fw */
 extern s8 *wl_cfg80211_get_fwname(void);	/* get firmware name for
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -66,8 +66,8 @@ bool g_set_essid_before_scan = TRUE;
 static int g_onoff = G_WLAN_SET_ON;
 wl_iw_extra_params_t g_wl_iw_params;
 
-extern bool wl_iw_conn_status_str(uint32 event_type, uint32 status,
-				  uint32 reason, char *stringBuf, uint buflen);
+extern bool wl_iw_conn_status_str(u32 event_type, u32 status,
+				  u32 reason, char *stringBuf, uint buflen);
 
 uint wl_msg_level = WL_ERROR_VAL;
 
@@ -127,8 +127,8 @@ typedef struct iscan_buf {
 typedef struct iscan_info {
 	struct net_device *dev;
 	struct timer_list timer;
-	uint32 timer_ms;
-	uint32 timer_on;
+	u32 timer_ms;
+	u32 timer_on;
 	int iscan_state;
 	iscan_buf_t *list_hdr;
 	iscan_buf_t *list_cur;
@@ -493,7 +493,7 @@ wl_iw_get_range(struct net_device *dev,
 		struct iw_point *dwrq, char *extra)
 {
 	struct iw_range *range = (struct iw_range *)extra;
-	wl_uint32_list_t *list;
+	wl_u32_list_t *list;
 	wl_rateset_t rateset;
 	s8 *channels;
 	int error, i, k;
@@ -519,7 +519,7 @@ wl_iw_get_range(struct net_device *dev,
 		WL_ERROR(("Could not alloc channels\n"));
 		return -ENOMEM;
 	}
-	list = (wl_uint32_list_t *) channels;
+	list = (wl_u32_list_t *) channels;
 
 	dwrq->length = sizeof(struct iw_range);
 	memset(range, 0, sizeof(range));
@@ -1097,14 +1097,14 @@ static void wl_iw_set_event_mask(struct
 			    iovbuf, sizeof(iovbuf));
 }
 
-static uint32 wl_iw_iscan_get(iscan_info_t *iscan)
+static u32 wl_iw_iscan_get(iscan_info_t *iscan)
 {
 	iscan_buf_t *buf;
 	iscan_buf_t *ptr;
 	wl_iscan_results_t *list_buf;
 	wl_iscan_results_t list;
 	wl_scan_results_t *results;
-	uint32 status;
+	u32 status;
 	int res = 0;
 
 	MUTEX_LOCK_WL_SCAN_SET();
@@ -1185,7 +1185,7 @@ static void wl_iw_send_scan_complete(isc
 
 static int _iscan_sysioc_thread(void *data)
 {
-	uint32 status;
+	u32 status;
 	iscan_info_t *iscan = (iscan_info_t *) data;
 	static bool iscan_pass_abort = FALSE;
 	DAEMONIZE("iscan_sysioc");
@@ -1745,7 +1745,7 @@ wl_iw_iscan_get_scan(struct net_device *
 	char *event = extra, *end = extra + dwrq->length, *value;
 	iscan_info_t *iscan = g_iscan;
 	iscan_buf_t *p_buf;
-	uint32 counter = 0;
+	u32 counter = 0;
 	u8 channel;
 
 	WL_TRACE(("%s %s buflen_from_user %d:\n", dev->name, __func__,
@@ -3300,13 +3300,13 @@ int wl_iw_ioctl(struct net_device *dev,
 }
 
 bool
-wl_iw_conn_status_str(uint32 event_type, uint32 status, uint32 reason,
+wl_iw_conn_status_str(u32 event_type, u32 status, u32 reason,
 		      char *stringBuf, uint buflen)
 {
 	typedef struct conn_fail_event_map_t {
-		uint32 inEvent;
-		uint32 inStatus;
-		uint32 inReason;
+		u32 inEvent;
+		u32 inStatus;
+		u32 inReason;
 		const char *outName;
 		const char *outCause;
 	} conn_fail_event_map_t;
@@ -3380,9 +3380,9 @@ wl_iw_conn_status_str(uint32 event_type,
 static bool
 wl_iw_check_conn_fail(wl_event_msg_t *e, char *stringBuf, uint buflen)
 {
-	uint32 event = ntoh32(e->event_type);
-	uint32 status = ntoh32(e->status);
-	uint32 reason = ntoh32(e->reason);
+	u32 event = ntoh32(e->event_type);
+	u32 status = ntoh32(e->status);
+	u32 reason = ntoh32(e->reason);
 
 	if (wl_iw_conn_status_str(event, status, reason, stringBuf, buflen)) {
 		return TRUE;
@@ -3401,12 +3401,12 @@ void wl_iw_event(struct net_device *dev,
 	union iwreq_data wrqu;
 	char extra[IW_CUSTOM_MAX + 1];
 	int cmd = 0;
-	uint32 event_type = ntoh32(e->event_type);
+	u32 event_type = ntoh32(e->event_type);
 	u16 flags = ntoh16(e->flags);
-	uint32 datalen = ntoh32(e->datalen);
-	uint32 status = ntoh32(e->status);
+	u32 datalen = ntoh32(e->datalen);
+	u32 status = ntoh32(e->status);
 	wl_iw_t *iw;
-	uint32 toto;
+	u32 toto;
 	memset(&wrqu, 0, sizeof(wrqu));
 	memset(extra, 0, sizeof(extra));
 	iw = 0;
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.h
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.h
@@ -93,8 +93,8 @@ typedef struct wl_iw {
 	struct iw_statistics wstats;
 
 	int spy_num;
-	uint32 pwsec;
-	uint32 gwsec;
+	u32 pwsec;
+	u32 gwsec;
 	bool privacy_invoked;
 
 	struct ether_addr spy_addr[IW_MAX_SPY];
--- a/drivers/staging/brcm80211/include/aidmp.h
+++ b/drivers/staging/brcm80211/include/aidmp.h
@@ -103,121 +103,121 @@
 #ifndef _LANGUAGE_ASSEMBLY
 
 typedef volatile struct _aidmp {
-	uint32 oobselina30;	/* 0x000 */
-	uint32 oobselina74;	/* 0x004 */
-	uint32 PAD[6];
-	uint32 oobselinb30;	/* 0x020 */
-	uint32 oobselinb74;	/* 0x024 */
-	uint32 PAD[6];
-	uint32 oobselinc30;	/* 0x040 */
-	uint32 oobselinc74;	/* 0x044 */
-	uint32 PAD[6];
-	uint32 oobselind30;	/* 0x060 */
-	uint32 oobselind74;	/* 0x064 */
-	uint32 PAD[38];
-	uint32 oobselouta30;	/* 0x100 */
-	uint32 oobselouta74;	/* 0x104 */
-	uint32 PAD[6];
-	uint32 oobseloutb30;	/* 0x120 */
-	uint32 oobseloutb74;	/* 0x124 */
-	uint32 PAD[6];
-	uint32 oobseloutc30;	/* 0x140 */
-	uint32 oobseloutc74;	/* 0x144 */
-	uint32 PAD[6];
-	uint32 oobseloutd30;	/* 0x160 */
-	uint32 oobseloutd74;	/* 0x164 */
-	uint32 PAD[38];
-	uint32 oobsynca;	/* 0x200 */
-	uint32 oobseloutaen;	/* 0x204 */
-	uint32 PAD[6];
-	uint32 oobsyncb;	/* 0x220 */
-	uint32 oobseloutben;	/* 0x224 */
-	uint32 PAD[6];
-	uint32 oobsyncc;	/* 0x240 */
-	uint32 oobseloutcen;	/* 0x244 */
-	uint32 PAD[6];
-	uint32 oobsyncd;	/* 0x260 */
-	uint32 oobseloutden;	/* 0x264 */
-	uint32 PAD[38];
-	uint32 oobaextwidth;	/* 0x300 */
-	uint32 oobainwidth;	/* 0x304 */
-	uint32 oobaoutwidth;	/* 0x308 */
-	uint32 PAD[5];
-	uint32 oobbextwidth;	/* 0x320 */
-	uint32 oobbinwidth;	/* 0x324 */
-	uint32 oobboutwidth;	/* 0x328 */
-	uint32 PAD[5];
-	uint32 oobcextwidth;	/* 0x340 */
-	uint32 oobcinwidth;	/* 0x344 */
-	uint32 oobcoutwidth;	/* 0x348 */
-	uint32 PAD[5];
-	uint32 oobdextwidth;	/* 0x360 */
-	uint32 oobdinwidth;	/* 0x364 */
-	uint32 oobdoutwidth;	/* 0x368 */
-	uint32 PAD[37];
-	uint32 ioctrlset;	/* 0x400 */
-	uint32 ioctrlclear;	/* 0x404 */
-	uint32 ioctrl;		/* 0x408 */
-	uint32 PAD[61];
-	uint32 iostatus;	/* 0x500 */
-	uint32 PAD[127];
-	uint32 ioctrlwidth;	/* 0x700 */
-	uint32 iostatuswidth;	/* 0x704 */
-	uint32 PAD[62];
-	uint32 resetctrl;	/* 0x800 */
-	uint32 resetstatus;	/* 0x804 */
-	uint32 resetreadid;	/* 0x808 */
-	uint32 resetwriteid;	/* 0x80c */
-	uint32 PAD[60];
-	uint32 errlogctrl;	/* 0x900 */
-	uint32 errlogdone;	/* 0x904 */
-	uint32 errlogstatus;	/* 0x908 */
-	uint32 errlogaddrlo;	/* 0x90c */
-	uint32 errlogaddrhi;	/* 0x910 */
-	uint32 errlogid;	/* 0x914 */
-	uint32 errloguser;	/* 0x918 */
-	uint32 errlogflags;	/* 0x91c */
-	uint32 PAD[56];
-	uint32 intstatus;	/* 0xa00 */
-	uint32 PAD[127];
-	uint32 config;		/* 0xe00 */
-	uint32 PAD[63];
-	uint32 itcr;		/* 0xf00 */
-	uint32 PAD[3];
-	uint32 itipooba;	/* 0xf10 */
-	uint32 itipoobb;	/* 0xf14 */
-	uint32 itipoobc;	/* 0xf18 */
-	uint32 itipoobd;	/* 0xf1c */
-	uint32 PAD[4];
-	uint32 itipoobaout;	/* 0xf30 */
-	uint32 itipoobbout;	/* 0xf34 */
-	uint32 itipoobcout;	/* 0xf38 */
-	uint32 itipoobdout;	/* 0xf3c */
-	uint32 PAD[4];
-	uint32 itopooba;	/* 0xf50 */
-	uint32 itopoobb;	/* 0xf54 */
-	uint32 itopoobc;	/* 0xf58 */
-	uint32 itopoobd;	/* 0xf5c */
-	uint32 PAD[4];
-	uint32 itopoobain;	/* 0xf70 */
-	uint32 itopoobbin;	/* 0xf74 */
-	uint32 itopoobcin;	/* 0xf78 */
-	uint32 itopoobdin;	/* 0xf7c */
-	uint32 PAD[4];
-	uint32 itopreset;	/* 0xf90 */
-	uint32 PAD[15];
-	uint32 peripherialid4;	/* 0xfd0 */
-	uint32 peripherialid5;	/* 0xfd4 */
-	uint32 peripherialid6;	/* 0xfd8 */
-	uint32 peripherialid7;	/* 0xfdc */
-	uint32 peripherialid0;	/* 0xfe0 */
-	uint32 peripherialid1;	/* 0xfe4 */
-	uint32 peripherialid2;	/* 0xfe8 */
-	uint32 peripherialid3;	/* 0xfec */
-	uint32 componentid0;	/* 0xff0 */
-	uint32 componentid1;	/* 0xff4 */
-	uint32 componentid2;	/* 0xff8 */
-	uint32 componentid3;	/* 0xffc */
+	u32 oobselina30;	/* 0x000 */
+	u32 oobselina74;	/* 0x004 */
+	u32 PAD[6];
+	u32 oobselinb30;	/* 0x020 */
+	u32 oobselinb74;	/* 0x024 */
+	u32 PAD[6];
+	u32 oobselinc30;	/* 0x040 */
+	u32 oobselinc74;	/* 0x044 */
+	u32 PAD[6];
+	u32 oobselind30;	/* 0x060 */
+	u32 oobselind74;	/* 0x064 */
+	u32 PAD[38];
+	u32 oobselouta30;	/* 0x100 */
+	u32 oobselouta74;	/* 0x104 */
+	u32 PAD[6];
+	u32 oobseloutb30;	/* 0x120 */
+	u32 oobseloutb74;	/* 0x124 */
+	u32 PAD[6];
+	u32 oobseloutc30;	/* 0x140 */
+	u32 oobseloutc74;	/* 0x144 */
+	u32 PAD[6];
+	u32 oobseloutd30;	/* 0x160 */
+	u32 oobseloutd74;	/* 0x164 */
+	u32 PAD[38];
+	u32 oobsynca;	/* 0x200 */
+	u32 oobseloutaen;	/* 0x204 */
+	u32 PAD[6];
+	u32 oobsyncb;	/* 0x220 */
+	u32 oobseloutben;	/* 0x224 */
+	u32 PAD[6];
+	u32 oobsyncc;	/* 0x240 */
+	u32 oobseloutcen;	/* 0x244 */
+	u32 PAD[6];
+	u32 oobsyncd;	/* 0x260 */
+	u32 oobseloutden;	/* 0x264 */
+	u32 PAD[38];
+	u32 oobaextwidth;	/* 0x300 */
+	u32 oobainwidth;	/* 0x304 */
+	u32 oobaoutwidth;	/* 0x308 */
+	u32 PAD[5];
+	u32 oobbextwidth;	/* 0x320 */
+	u32 oobbinwidth;	/* 0x324 */
+	u32 oobboutwidth;	/* 0x328 */
+	u32 PAD[5];
+	u32 oobcextwidth;	/* 0x340 */
+	u32 oobcinwidth;	/* 0x344 */
+	u32 oobcoutwidth;	/* 0x348 */
+	u32 PAD[5];
+	u32 oobdextwidth;	/* 0x360 */
+	u32 oobdinwidth;	/* 0x364 */
+	u32 oobdoutwidth;	/* 0x368 */
+	u32 PAD[37];
+	u32 ioctrlset;	/* 0x400 */
+	u32 ioctrlclear;	/* 0x404 */
+	u32 ioctrl;		/* 0x408 */
+	u32 PAD[61];
+	u32 iostatus;	/* 0x500 */
+	u32 PAD[127];
+	u32 ioctrlwidth;	/* 0x700 */
+	u32 iostatuswidth;	/* 0x704 */
+	u32 PAD[62];
+	u32 resetctrl;	/* 0x800 */
+	u32 resetstatus;	/* 0x804 */
+	u32 resetreadid;	/* 0x808 */
+	u32 resetwriteid;	/* 0x80c */
+	u32 PAD[60];
+	u32 errlogctrl;	/* 0x900 */
+	u32 errlogdone;	/* 0x904 */
+	u32 errlogstatus;	/* 0x908 */
+	u32 errlogaddrlo;	/* 0x90c */
+	u32 errlogaddrhi;	/* 0x910 */
+	u32 errlogid;	/* 0x914 */
+	u32 errloguser;	/* 0x918 */
+	u32 errlogflags;	/* 0x91c */
+	u32 PAD[56];
+	u32 intstatus;	/* 0xa00 */
+	u32 PAD[127];
+	u32 config;		/* 0xe00 */
+	u32 PAD[63];
+	u32 itcr;		/* 0xf00 */
+	u32 PAD[3];
+	u32 itipooba;	/* 0xf10 */
+	u32 itipoobb;	/* 0xf14 */
+	u32 itipoobc;	/* 0xf18 */
+	u32 itipoobd;	/* 0xf1c */
+	u32 PAD[4];
+	u32 itipoobaout;	/* 0xf30 */
+	u32 itipoobbout;	/* 0xf34 */
+	u32 itipoobcout;	/* 0xf38 */
+	u32 itipoobdout;	/* 0xf3c */
+	u32 PAD[4];
+	u32 itopooba;	/* 0xf50 */
+	u32 itopoobb;	/* 0xf54 */
+	u32 itopoobc;	/* 0xf58 */
+	u32 itopoobd;	/* 0xf5c */
+	u32 PAD[4];
+	u32 itopoobain;	/* 0xf70 */
+	u32 itopoobbin;	/* 0xf74 */
+	u32 itopoobcin;	/* 0xf78 */
+	u32 itopoobdin;	/* 0xf7c */
+	u32 PAD[4];
+	u32 itopreset;	/* 0xf90 */
+	u32 PAD[15];
+	u32 peripherialid4;	/* 0xfd0 */
+	u32 peripherialid5;	/* 0xfd4 */
+	u32 peripherialid6;	/* 0xfd8 */
+	u32 peripherialid7;	/* 0xfdc */
+	u32 peripherialid0;	/* 0xfe0 */
+	u32 peripherialid1;	/* 0xfe4 */
+	u32 peripherialid2;	/* 0xfe8 */
+	u32 peripherialid3;	/* 0xfec */
+	u32 componentid0;	/* 0xff0 */
+	u32 componentid1;	/* 0xff4 */
+	u32 componentid2;	/* 0xff8 */
+	u32 componentid3;	/* 0xffc */
 } aidmp_t;
 
 #endif				/* _LANGUAGE_ASSEMBLY */
--- a/drivers/staging/brcm80211/include/bcm_rpc.h
+++ b/drivers/staging/brcm80211/include/bcm_rpc.h
@@ -65,7 +65,7 @@ extern uint bcm_rpc_buf_header_len(struc
 #define RPC_PKTLOG_SIZE		50	/* Depth of the history */
 #define RPC_PKTLOG_RD_LEN	3
 #define RPC_PKTLOG_DUMP_SIZE	150	/* dump size should be more than the product of above two */
-extern int bcm_rpc_pktlog_get(struct rpc_info *rpci, uint32 *buf,
+extern int bcm_rpc_pktlog_get(struct rpc_info *rpci, u32 *buf,
 			      uint buf_size, bool send);
 extern int bcm_rpc_dump(rpc_info_t *rpci, struct bcmstrbuf *b);
 
--- a/drivers/staging/brcm80211/include/bcm_rpc_tp.h
+++ b/drivers/staging/brcm80211/include/bcm_rpc_tp.h
@@ -112,7 +112,7 @@ extern void bcm_rpc_tp_txq_wm_get(rpc_tp
 				  u8 *lowm);
 #endif				/* WLC_LOW */
 
-extern void bcm_rpc_tp_agg_set(rpc_tp_info_t *rpcb, uint32 reason, bool set);
+extern void bcm_rpc_tp_agg_set(rpc_tp_info_t *rpcb, u32 reason, bool set);
 extern void bcm_rpc_tp_agg_limit_set(rpc_tp_info_t *rpc_th, u8 sf,
 				     u16 bytes);
 extern void bcm_rpc_tp_agg_limit_get(rpc_tp_info_t *rpc_th, u8 *sf,
--- a/drivers/staging/brcm80211/include/bcm_xdr.h
+++ b/drivers/staging/brcm80211/include/bcm_xdr.h
@@ -33,8 +33,8 @@ typedef struct {
 
 void bcm_xdr_buf_init(bcm_xdr_buf_t *b, void *buf, size_t len);
 
-int bcm_xdr_pack_uint32(bcm_xdr_buf_t *b, uint32 val);
-int bcm_xdr_unpack_uint32(bcm_xdr_buf_t *b, uint32 *pval);
+int bcm_xdr_pack_u32(bcm_xdr_buf_t *b, u32 val);
+int bcm_xdr_unpack_u32(bcm_xdr_buf_t *b, u32 *pval);
 int bcm_xdr_pack_int32(bcm_xdr_buf_t *b, int32 val);
 int bcm_xdr_unpack_int32(bcm_xdr_buf_t *b, int32 *pval);
 int bcm_xdr_pack_s8(bcm_xdr_buf_t *b, s8 val);
@@ -47,12 +47,12 @@ int bcm_xdr_unpack_opaque_varlen(bcm_xdr
 int bcm_xdr_pack_string(bcm_xdr_buf_t *b, char *str);
 int bcm_xdr_unpack_string(bcm_xdr_buf_t *b, uint *plen, char **pstr);
 
-int bcm_xdr_pack_u8_vec(bcm_xdr_buf_t *, u8 *vec, uint32 elems);
-int bcm_xdr_unpack_u8_vec(bcm_xdr_buf_t *, u8 *vec, uint32 elems);
+int bcm_xdr_pack_u8_vec(bcm_xdr_buf_t *, u8 *vec, u32 elems);
+int bcm_xdr_unpack_u8_vec(bcm_xdr_buf_t *, u8 *vec, u32 elems);
 int bcm_xdr_pack_u16_vec(bcm_xdr_buf_t *b, uint len, void *vec);
 int bcm_xdr_unpack_u16_vec(bcm_xdr_buf_t *b, uint len, void *vec);
-int bcm_xdr_pack_uint32_vec(bcm_xdr_buf_t *b, uint len, void *vec);
-int bcm_xdr_unpack_uint32_vec(bcm_xdr_buf_t *b, uint len, void *vec);
+int bcm_xdr_pack_u32_vec(bcm_xdr_buf_t *b, uint len, void *vec);
+int bcm_xdr_unpack_u32_vec(bcm_xdr_buf_t *b, uint len, void *vec);
 
 int bcm_xdr_pack_opaque_raw(bcm_xdr_buf_t *b, uint len, void *data);
 int bcm_xdr_pack_opaque_pad(bcm_xdr_buf_t *b);
--- a/drivers/staging/brcm80211/include/bcmcdc.h
+++ b/drivers/staging/brcm80211/include/bcmcdc.h
@@ -16,11 +16,11 @@
 #include <proto/ethernet.h>
 
 typedef struct cdc_ioctl {
-	uint32 cmd;		/* ioctl command value */
-	uint32 len;		/* lower 16: output buflen; upper 16:
+	u32 cmd;		/* ioctl command value */
+	u32 len;		/* lower 16: output buflen; upper 16:
 				 input buflen (excludes header) */
-	uint32 flags;		/* flag defns given below */
-	uint32 status;		/* status code returned from the device */
+	u32 flags;		/* flag defns given below */
+	u32 status;		/* status code returned from the device */
 } cdc_ioctl_t;
 
 /* Max valid buffer size that can be sent to the dongle */
--- a/drivers/staging/brcm80211/include/bcmdefs.h
+++ b/drivers/staging/brcm80211/include/bcmdefs.h
@@ -104,8 +104,8 @@
 
 #ifdef BCMDMA64OSL
 typedef struct {
-	uint32 loaddr;
-	uint32 hiaddr;
+	u32 loaddr;
+	u32 hiaddr;
 } dma64addr_t;
 
 typedef dma64addr_t dmaaddr_t;
@@ -134,7 +134,7 @@ typedef unsigned long dmaaddr_t;
 /* One physical DMA segment */
 typedef struct {
 	dmaaddr_t addr;
-	uint32 length;
+	u32 length;
 } hnddma_seg_t;
 
 #define MAX_DMA_SEGS 4
--- a/drivers/staging/brcm80211/include/bcmendian.h
+++ b/drivers/staging/brcm80211/include/bcmendian.h
@@ -26,15 +26,15 @@
 
 /* Reverse the bytes in a 32-bit value */
 #define BCMSWAP32(val) \
-	((uint32)((((uint32)(val) & (uint32)0x000000ffU) << 24) | \
-		  (((uint32)(val) & (uint32)0x0000ff00U) <<  8) | \
-		  (((uint32)(val) & (uint32)0x00ff0000U) >>  8) | \
-		  (((uint32)(val) & (uint32)0xff000000U) >> 24)))
+	((u32)((((u32)(val) & (u32)0x000000ffU) << 24) | \
+		  (((u32)(val) & (u32)0x0000ff00U) <<  8) | \
+		  (((u32)(val) & (u32)0x00ff0000U) >>  8) | \
+		  (((u32)(val) & (u32)0xff000000U) >> 24)))
 
 /* Reverse the two 16-bit halves of a 32-bit value */
 #define BCMSWAP32BY16(val) \
-	((uint32)((((uint32)(val) & (uint32)0x0000ffffU) << 16) | \
-		  (((uint32)(val) & (uint32)0xffff0000U) >> 16)))
+	((u32)((((u32)(val) & (u32)0x0000ffffU) << 16) | \
+		  (((u32)(val) & (u32)0xffff0000U) >> 16)))
 
 /* Byte swapping macros
  *    Host <=> Network (Big Endian) for 16- and 32-bit values
@@ -107,13 +107,13 @@
 #define ltoh_ua(ptr) \
 	(sizeof(*(ptr)) == sizeof(u8) ? *(const u8 *)(ptr) : \
 	 sizeof(*(ptr)) == sizeof(u16) ? _LTOH16_UA((const u8 *)(ptr)) : \
-	 sizeof(*(ptr)) == sizeof(uint32) ? _LTOH32_UA((const u8 *)(ptr)) : \
+	 sizeof(*(ptr)) == sizeof(u32) ? _LTOH32_UA((const u8 *)(ptr)) : \
 	 *(u8 *)0)
 
 #define ntoh_ua(ptr) \
 	(sizeof(*(ptr)) == sizeof(u8) ? *(const u8 *)(ptr) : \
 	 sizeof(*(ptr)) == sizeof(u16) ? _NTOH16_UA((const u8 *)(ptr)) : \
-	 sizeof(*(ptr)) == sizeof(uint32) ? _NTOH32_UA((const u8 *)(ptr)) : \
+	 sizeof(*(ptr)) == sizeof(u32) ? _NTOH32_UA((const u8 *)(ptr)) : \
 	 *(u8 *)0)
 
 #ifdef __GNUC__
@@ -128,12 +128,12 @@
 })
 
 #define bcmswap32(val) ({ \
-	uint32 _val = (val); \
+	u32 _val = (val); \
 	BCMSWAP32(_val); \
 })
 
 #define bcmswap32by16(val) ({ \
-	uint32 _val = (val); \
+	u32 _val = (val); \
 	BCMSWAP32BY16(_val); \
 })
 
@@ -154,7 +154,7 @@
 })
 
 #define htol32_ua_store(val, bytes) ({ \
-	uint32 _val = (val); \
+	u32 _val = (val); \
 	u8 *_bytes = (u8 *)(bytes); \
 	_bytes[0] = _val & 0xff; \
 	_bytes[1] = (_val >> 8) & 0xff; \
@@ -170,7 +170,7 @@
 })
 
 #define hton32_ua_store(val, bytes) ({ \
-	uint32 _val = (val); \
+	u32 _val = (val); \
 	u8 *_bytes = (u8 *)(bytes); \
 	_bytes[0] = _val >> 24; \
 	_bytes[1] = (_val >> 16) & 0xff; \
@@ -206,12 +206,12 @@ static inline u16 bcmswap16(u16 val)
 	return BCMSWAP16(val);
 }
 
-static inline uint32 bcmswap32(uint32 val)
+static inline u32 bcmswap32(u32 val)
 {
 	return BCMSWAP32(val);
 }
 
-static inline uint32 bcmswap32by16(uint32 val)
+static inline u32 bcmswap32by16(u32 val)
 {
 	return BCMSWAP32BY16(val);
 }
@@ -241,7 +241,7 @@ static inline void htol16_ua_store(u16 v
 /*
  * Store 32-bit value to unaligned little-endian byte array.
  */
-static inline void htol32_ua_store(uint32 val, u8 *bytes)
+static inline void htol32_ua_store(u32 val, u8 *bytes)
 {
 	bytes[0] = val & 0xff;
 	bytes[1] = (val >> 8) & 0xff;
@@ -261,7 +261,7 @@ static inline void hton16_ua_store(u16 v
 /*
  * Store 32-bit value to unaligned network-(big-)endian byte array.
  */
-static inline void hton32_ua_store(uint32 val, u8 *bytes)
+static inline void hton32_ua_store(u32 val, u8 *bytes)
 {
 	bytes[0] = val >> 24;
 	bytes[1] = (val >> 16) & 0xff;
@@ -280,7 +280,7 @@ static inline u16 ltoh16_ua(const void *
 /*
  * Load 32-bit value from unaligned little-endian byte array.
  */
-static inline uint32 ltoh32_ua(const void *bytes)
+static inline u32 ltoh32_ua(const void *bytes)
 {
 	return _LTOH32_UA((const u8 *)bytes);
 }
@@ -296,7 +296,7 @@ static inline u16 ntoh16_ua(const void *
 /*
  * Load 32-bit value from unaligned big-(network-)endian byte array.
  */
-static inline uint32 ntoh32_ua(const void *bytes)
+static inline u32 ntoh32_ua(const void *bytes)
 {
 	return _NTOH32_UA((const u8 *)bytes);
 }
--- a/drivers/staging/brcm80211/include/bcmnvram.h
+++ b/drivers/staging/brcm80211/include/bcmnvram.h
@@ -23,11 +23,11 @@
 #include <bcmdefs.h>
 
 struct nvram_header {
-	uint32 magic;
-	uint32 len;
-	uint32 crc_ver_init;	/* 0:7 crc, 8:15 ver, 16:31 sdram_init */
-	uint32 config_refresh;	/* 0:15 sdram_config, 16:31 sdram_refresh */
-	uint32 config_ncdl;	/* ncdl values for memc */
+	u32 magic;
+	u32 len;
+	u32 crc_ver_init;	/* 0:7 crc, 8:15 ver, 16:31 sdram_init */
+	u32 config_refresh;	/* 0:15 sdram_config, 16:31 sdram_refresh */
+	u32 config_ncdl;	/* ncdl values for memc */
 };
 
 struct nvram_tuple {
--- a/drivers/staging/brcm80211/include/bcmsdbus.h
+++ b/drivers/staging/brcm80211/include/bcmsdbus.h
@@ -72,22 +72,22 @@ extern SDIOH_API_RC sdioh_request_byte(s
 /* read or write 2/4 bytes using cmd53 */
 extern SDIOH_API_RC sdioh_request_word(sdioh_info_t *si, uint cmd_type,
 				       uint rw, uint fnc, uint addr,
-				       uint32 *word, uint nbyte);
+				       u32 *word, uint nbyte);
 
 /* read or write any buffer using cmd53 */
 extern SDIOH_API_RC sdioh_request_buffer(sdioh_info_t *si, uint pio_dma,
 					 uint fix_inc, uint rw, uint fnc_num,
-					 uint32 addr, uint regwidth,
-					 uint32 buflen, u8 *buffer,
+					 u32 addr, uint regwidth,
+					 u32 buflen, u8 *buffer,
 					 void *pkt);
 
 /* get cis data */
 extern SDIOH_API_RC sdioh_cis_read(sdioh_info_t *si, uint fuc, u8 *cis,
-				   uint32 length);
+				   u32 length);
 
-extern SDIOH_API_RC sdioh_cfg_read(sdioh_info_t *si, uint fuc, uint32 addr,
+extern SDIOH_API_RC sdioh_cfg_read(sdioh_info_t *si, uint fuc, u32 addr,
 				   u8 *data);
-extern SDIOH_API_RC sdioh_cfg_write(sdioh_info_t *si, uint fuc, uint32 addr,
+extern SDIOH_API_RC sdioh_cfg_write(sdioh_info_t *si, uint fuc, u32 addr,
 				    u8 *data);
 
 /* query number of io functions */
--- a/drivers/staging/brcm80211/include/bcmsdh.h
+++ b/drivers/staging/brcm80211/include/bcmsdh.h
@@ -75,15 +75,15 @@ extern int bcmsdh_devremove_reg(void *sd
  *   data: data byte to write
  *   err:  pointer to error code (or NULL)
  */
-extern u8 bcmsdh_cfg_read(void *sdh, uint func, uint32 addr, int *err);
-extern void bcmsdh_cfg_write(void *sdh, uint func, uint32 addr, u8 data,
+extern u8 bcmsdh_cfg_read(void *sdh, uint func, u32 addr, int *err);
+extern void bcmsdh_cfg_write(void *sdh, uint func, u32 addr, u8 data,
 			     int *err);
 
 /* Read/Write 4bytes from/to cfg space */
-extern uint32 bcmsdh_cfg_read_word(void *sdh, uint fnc_num, uint32 addr,
+extern u32 bcmsdh_cfg_read_word(void *sdh, uint fnc_num, u32 addr,
 				   int *err);
-extern void bcmsdh_cfg_write_word(void *sdh, uint fnc_num, uint32 addr,
-				  uint32 data, int *err);
+extern void bcmsdh_cfg_write_word(void *sdh, uint fnc_num, u32 addr,
+				  u32 data, int *err);
 
 /* Read CIS content for specified function.
  *   fn:     function whose CIS is being requested (0 is common CIS)
@@ -99,8 +99,8 @@ extern int bcmsdh_cis_read(void *sdh, ui
  *   size: register width in bytes (2 or 4)
  *   data: data for register write
  */
-extern uint32 bcmsdh_reg_read(void *sdh, uint32 addr, uint size);
-extern uint32 bcmsdh_reg_write(void *sdh, uint32 addr, uint size, uint32 data);
+extern u32 bcmsdh_reg_read(void *sdh, u32 addr, uint size);
+extern u32 bcmsdh_reg_write(void *sdh, u32 addr, uint size, u32 data);
 
 /* Indicate if last reg read/write failed */
 extern bool bcmsdh_regfail(void *sdh);
@@ -118,10 +118,10 @@ extern bool bcmsdh_regfail(void *sdh);
  * NOTE: Async operation is not currently supported.
  */
 typedef void (*bcmsdh_cmplt_fn_t) (void *handle, int status, bool sync_waiting);
-extern int bcmsdh_send_buf(void *sdh, uint32 addr, uint fn, uint flags,
+extern int bcmsdh_send_buf(void *sdh, u32 addr, uint fn, uint flags,
 			   u8 *buf, uint nbytes, void *pkt,
 			   bcmsdh_cmplt_fn_t complete, void *handle);
-extern int bcmsdh_recv_buf(void *sdh, uint32 addr, uint fn, uint flags,
+extern int bcmsdh_recv_buf(void *sdh, u32 addr, uint fn, uint flags,
 			   u8 *buf, uint nbytes, void *pkt,
 			   bcmsdh_cmplt_fn_t complete, void *handle);
 
@@ -140,7 +140,7 @@ extern int bcmsdh_recv_buf(void *sdh, ui
  *   nbytes:   number of bytes to transfer to/from buf
  * Returns 0 or error code.
  */
-extern int bcmsdh_rwdata(void *sdh, uint rw, uint32 addr, u8 *buf,
+extern int bcmsdh_rwdata(void *sdh, uint rw, u32 addr, u8 *buf,
 			 uint nbytes);
 
 /* Issue an abort to the specified function */
@@ -187,12 +187,12 @@ extern bool bcmsdh_chipmatch(u16 vendor,
 extern void bcmsdh_device_remove(void *sdh);
 
 /* Function to pass device-status bits to DHD. */
-extern uint32 bcmsdh_get_dstatus(void *sdh);
+extern u32 bcmsdh_get_dstatus(void *sdh);
 
 /* Function to return current window addr */
-extern uint32 bcmsdh_cur_sbwad(void *sdh);
+extern u32 bcmsdh_cur_sbwad(void *sdh);
 
 /* Function to pass chipid and rev to lower layers for controlling pr's */
-extern void bcmsdh_chipinfo(void *sdh, uint32 chip, uint32 chiprev);
+extern void bcmsdh_chipinfo(void *sdh, u32 chip, u32 chiprev);
 
 #endif				/* _bcmsdh_h_ */
--- a/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
+++ b/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
@@ -68,8 +68,8 @@ struct sdioh_info {
 	int sd_mode;		/* SD1/SD4/SPI */
 	int client_block_size[SDIOD_MAX_IOFUNCS];	/* Blocksize */
 	u8 num_funcs;	/* Supported funcs on client */
-	uint32 com_cis_ptr;
-	uint32 func_cis_ptr[SDIOD_MAX_IOFUNCS];
+	u32 com_cis_ptr;
+	u32 func_cis_ptr[SDIOD_MAX_IOFUNCS];
 	uint max_dma_len;
 	uint max_dma_descriptors;	/* DMA Descriptors supported by this controller. */
 	/*	SDDMA_DESCRIPTOR	SGList[32]; *//* Scatter/Gather DMA List */
@@ -94,7 +94,7 @@ extern void sdioh_sdmmc_devintr_off(sdio
  */
 
 /* Register mapping routines */
-extern uint32 *sdioh_sdmmc_reg_map(osl_t *osh, int32 addr, int size);
+extern u32 *sdioh_sdmmc_reg_map(osl_t *osh, int32 addr, int size);
 extern void sdioh_sdmmc_reg_unmap(osl_t *osh, int32 addr, int size);
 
 /* Interrupt (de)registration routines */
@@ -104,7 +104,7 @@ extern void sdioh_sdmmc_free_irq(uint ir
 typedef struct _BCMSDH_SDMMC_INSTANCE {
 	sdioh_info_t *sd;
 	struct sdio_func *func[SDIOD_MAX_IOFUNCS];
-	uint32 host_claimed;
+	u32 host_claimed;
 } BCMSDH_SDMMC_INSTANCE, *PBCMSDH_SDMMC_INSTANCE;
 
 #endif				/* __BCMSDH_SDMMC_H__ */
--- a/drivers/staging/brcm80211/include/bcmsdpcm.h
+++ b/drivers/staging/brcm80211/include/bcmsdpcm.h
@@ -153,33 +153,33 @@
  */
 
 typedef volatile struct {
-	uint32 cmd52rd;		/* Cmd52RdCount, SDIO: cmd52 reads */
-	uint32 cmd52wr;		/* Cmd52WrCount, SDIO: cmd52 writes */
-	uint32 cmd53rd;		/* Cmd53RdCount, SDIO: cmd53 reads */
-	uint32 cmd53wr;		/* Cmd53WrCount, SDIO: cmd53 writes */
-	uint32 abort;		/* AbortCount, SDIO: aborts */
-	uint32 datacrcerror;	/* DataCrcErrorCount, SDIO: frames w/CRC error */
-	uint32 rdoutofsync;	/* RdOutOfSyncCount, SDIO/PCMCIA: Rd Frm out of sync */
-	uint32 wroutofsync;	/* RdOutOfSyncCount, SDIO/PCMCIA: Wr Frm out of sync */
-	uint32 writebusy;	/* WriteBusyCount, SDIO: device asserted "busy" */
-	uint32 readwait;	/* ReadWaitCount, SDIO: no data ready for a read cmd */
-	uint32 readterm;	/* ReadTermCount, SDIO: read frame termination cmds */
-	uint32 writeterm;	/* WriteTermCount, SDIO: write frames termination cmds */
-	uint32 rxdescuflo;	/* receive descriptor underflows */
-	uint32 rxfifooflo;	/* receive fifo overflows */
-	uint32 txfifouflo;	/* transmit fifo underflows */
-	uint32 runt;		/* runt (too short) frames recv'd from bus */
-	uint32 badlen;		/* frame's rxh len does not match its hw tag len */
-	uint32 badcksum;	/* frame's hw tag chksum doesn't agree with len value */
-	uint32 seqbreak;	/* break in sequence # space from one rx frame to the next */
-	uint32 rxfcrc;		/* frame rx header indicates crc error */
-	uint32 rxfwoos;		/* frame rx header indicates write out of sync */
-	uint32 rxfwft;		/* frame rx header indicates write frame termination */
-	uint32 rxfabort;	/* frame rx header indicates frame aborted */
-	uint32 woosint;		/* write out of sync interrupt */
-	uint32 roosint;		/* read out of sync interrupt */
-	uint32 rftermint;	/* read frame terminate interrupt */
-	uint32 wftermint;	/* write frame terminate interrupt */
+	u32 cmd52rd;		/* Cmd52RdCount, SDIO: cmd52 reads */
+	u32 cmd52wr;		/* Cmd52WrCount, SDIO: cmd52 writes */
+	u32 cmd53rd;		/* Cmd53RdCount, SDIO: cmd53 reads */
+	u32 cmd53wr;		/* Cmd53WrCount, SDIO: cmd53 writes */
+	u32 abort;		/* AbortCount, SDIO: aborts */
+	u32 datacrcerror;	/* DataCrcErrorCount, SDIO: frames w/CRC error */
+	u32 rdoutofsync;	/* RdOutOfSyncCount, SDIO/PCMCIA: Rd Frm out of sync */
+	u32 wroutofsync;	/* RdOutOfSyncCount, SDIO/PCMCIA: Wr Frm out of sync */
+	u32 writebusy;	/* WriteBusyCount, SDIO: device asserted "busy" */
+	u32 readwait;	/* ReadWaitCount, SDIO: no data ready for a read cmd */
+	u32 readterm;	/* ReadTermCount, SDIO: read frame termination cmds */
+	u32 writeterm;	/* WriteTermCount, SDIO: write frames termination cmds */
+	u32 rxdescuflo;	/* receive descriptor underflows */
+	u32 rxfifooflo;	/* receive fifo overflows */
+	u32 txfifouflo;	/* transmit fifo underflows */
+	u32 runt;		/* runt (too short) frames recv'd from bus */
+	u32 badlen;		/* frame's rxh len does not match its hw tag len */
+	u32 badcksum;	/* frame's hw tag chksum doesn't agree with len value */
+	u32 seqbreak;	/* break in sequence # space from one rx frame to the next */
+	u32 rxfcrc;		/* frame rx header indicates crc error */
+	u32 rxfwoos;		/* frame rx header indicates write out of sync */
+	u32 rxfwft;		/* frame rx header indicates write frame termination */
+	u32 rxfabort;	/* frame rx header indicates frame aborted */
+	u32 woosint;		/* write out of sync interrupt */
+	u32 roosint;		/* read out of sync interrupt */
+	u32 rftermint;	/* read frame terminate interrupt */
+	u32 wftermint;	/* write frame terminate interrupt */
 } sdpcmd_cnt_t;
 
 /*
@@ -241,13 +241,13 @@ typedef volatile struct {
 #define SDPCM_SHARED_TRAP          0x0400
 
 typedef struct {
-	uint32 flags;
-	uint32 trap_addr;
-	uint32 assert_exp_addr;
-	uint32 assert_file_addr;
-	uint32 assert_line;
-	uint32 console_addr;	/* Address of hndrte_cons_t */
-	uint32 msgtrace_addr;
+	u32 flags;
+	u32 trap_addr;
+	u32 assert_exp_addr;
+	u32 assert_file_addr;
+	u32 assert_line;
+	u32 console_addr;	/* Address of hndrte_cons_t */
+	u32 msgtrace_addr;
 } sdpcm_shared_t;
 
 extern sdpcm_shared_t sdpcm_shared;
--- a/drivers/staging/brcm80211/include/bcmsrom_tbl.h
+++ b/drivers/staging/brcm80211/include/bcmsrom_tbl.h
@@ -22,8 +22,8 @@
 
 typedef struct {
 	const char *name;
-	uint32 revmask;
-	uint32 flags;
+	u32 revmask;
+	u32 flags;
 	u16 off;
 	u16 mask;
 } sromvar_t;
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -327,7 +327,7 @@ extern "C" {
 	"s16", \
 	"u16", \
 	"int32", \
-	"uint32", \
+	"u32", \
 	"buffer", \
 	"" }
 
@@ -517,7 +517,7 @@ extern "C" {
 
 /* bcm_format_flags() bit description structure */
 	typedef struct bcm_bit_desc {
-		uint32 bit;
+		u32 bit;
 		const char *name;
 	} bcm_bit_desc_t;
 
@@ -546,17 +546,17 @@ extern "C" {
 			    3) == 0) {
 			/* ARM CM3 rel time: 1229 (727 if alignment check could be omitted) */
 			/* x86 supports unaligned.  This version runs 6x-9x faster on x86. */
-			((uint32 *) dst)[0] =
-			    ((const uint32 *)src1)[0] ^ ((const uint32 *)
+			((u32 *) dst)[0] =
+			    ((const u32 *)src1)[0] ^ ((const u32 *)
 							 src2)[0];
-			((uint32 *) dst)[1] =
-			    ((const uint32 *)src1)[1] ^ ((const uint32 *)
+			((u32 *) dst)[1] =
+			    ((const u32 *)src1)[1] ^ ((const u32 *)
 							 src2)[1];
-			((uint32 *) dst)[2] =
-			    ((const uint32 *)src1)[2] ^ ((const uint32 *)
+			((u32 *) dst)[2] =
+			    ((const u32 *)src1)[2] ^ ((const u32 *)
 							 src2)[2];
-			((uint32 *) dst)[3] =
-			    ((const uint32 *)src1)[3] ^ ((const uint32 *)
+			((u32 *) dst)[3] =
+			    ((const u32 *)src1)[3] ^ ((const u32 *)
 							 src2)[3];
 		} else {
 			/* ARM CM3 rel time: 4668 (4191 if alignment check could be omitted) */
@@ -572,7 +572,7 @@ extern "C" {
 	extern u16 BCMROMFN(hndcrc16) (u8 *p, uint nbytes, u16 crc);
 /* format/print */
 #if defined(BCMDBG)
-	extern int bcm_format_flags(const bcm_bit_desc_t *bd, uint32 flags,
+	extern int bcm_format_flags(const bcm_bit_desc_t *bd, u32 flags,
 				    char *buf, int len);
 	extern int bcm_format_hex(char *str, const void *bytes, int len);
 #endif
@@ -584,7 +584,7 @@ extern "C" {
 #endif /* BRCM_FULLMAC */
 	extern char *bcm_chipname(uint chipid, char *buf, uint len);
 #ifdef BRCM_FULLMAC
-	extern char *bcm_brev_str(uint32 brev, char *buf);
+	extern char *bcm_brev_str(u32 brev, char *buf);
 	extern void printbig(char *buf);
 #endif /* BRCM_FULLMAC */
 	extern void prhex(const char *msg, unsigned char *buf, uint len);
@@ -604,7 +604,7 @@ extern "C" {
 #endif
 
 /* multi-bool data type: set of bools, mbool is true if any is set */
-	typedef uint32 mbool;
+	typedef u32 mbool;
 #define mboolset(mb, bit)		((mb) |= (bit))	/* set one bool */
 #define mboolclr(mb, bit)		((mb) &= ~(bit))	/* clear one bool */
 #define mboolisset(mb, bit)		(((mb) & (bit)) != 0)	/* TRUE if one bool is set */
@@ -619,8 +619,8 @@ extern "C" {
 /* generic datastruct to help dump routines */
 	struct fielddesc {
 		const char *nameandfmt;
-		uint32 offset;
-		uint32 len;
+		u32 offset;
+		u32 len;
 	};
 
 #ifdef BRCM_FULLMAC
@@ -631,12 +631,12 @@ extern "C" {
 	extern void bcm_print_bytes(char *name, const unsigned char *cdata, int len);
 #endif
 
-	typedef uint32(*bcmutl_rdreg_rtn) (void *arg0, uint arg1,
-					   uint32 offset);
+	typedef u32(*bcmutl_rdreg_rtn) (void *arg0, uint arg1,
+					   u32 offset);
 #ifdef BRCM_FULLMAC
 	extern uint bcmdumpfields(bcmutl_rdreg_rtn func_ptr, void *arg0,
 				  uint arg1, struct fielddesc *str, char *buf,
-				  uint32 bufsize);
+				  u32 bufsize);
 
 	extern uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf,
 				uint len);
--- a/drivers/staging/brcm80211/include/d11.h
+++ b/drivers/staging/brcm80211/include/d11.h
@@ -65,15 +65,15 @@
 #define	TX_CTL_FIFO		TX_AC_VO_FIFO
 
 typedef volatile struct {
-	uint32 intstatus;
-	uint32 intmask;
+	u32 intstatus;
+	u32 intmask;
 } intctrlregs_t;
 
 /* read: 32-bit register that can be read as 32-bit or as 2 16-bit
  * write: only low 16b-it half can be written
  */
 typedef volatile union {
-	uint32 pmqhostdata;	/* read only! */
+	u32 pmqhostdata;	/* read only! */
 	struct {
 		u16 pmqctrlstatus;	/* read/write */
 		u16 PAD;
@@ -107,74 +107,74 @@ typedef volatile struct {
  */
 typedef volatile struct _d11regs {
 	/* Device Control ("semi-standard host registers") */
-	uint32 PAD[3];		/* 0x0 - 0x8 */
-	uint32 biststatus;	/* 0xC */
-	uint32 biststatus2;	/* 0x10 */
-	uint32 PAD;		/* 0x14 */
-	uint32 gptimer;		/* 0x18 *//* for corerev >= 3 */
-	uint32 usectimer;	/* 0x1c *//* for corerev >= 26 */
+	u32 PAD[3];		/* 0x0 - 0x8 */
+	u32 biststatus;	/* 0xC */
+	u32 biststatus2;	/* 0x10 */
+	u32 PAD;		/* 0x14 */
+	u32 gptimer;		/* 0x18 *//* for corerev >= 3 */
+	u32 usectimer;	/* 0x1c *//* for corerev >= 26 */
 
 	/* Interrupt Control *//* 0x20 */
 	intctrlregs_t intctrlregs[8];
 
-	uint32 PAD[40];		/* 0x60 - 0xFC */
+	u32 PAD[40];		/* 0x60 - 0xFC */
 
 	/* tx fifos 6-7 and rx fifos 1-3 removed in corerev 5 */
-	uint32 intrcvlazy[4];	/* 0x100 - 0x10C */
+	u32 intrcvlazy[4];	/* 0x100 - 0x10C */
 
-	uint32 PAD[4];		/* 0x110 - 0x11c */
+	u32 PAD[4];		/* 0x110 - 0x11c */
 
-	uint32 maccontrol;	/* 0x120 */
-	uint32 maccommand;	/* 0x124 */
-	uint32 macintstatus;	/* 0x128 */
-	uint32 macintmask;	/* 0x12C */
+	u32 maccontrol;	/* 0x120 */
+	u32 maccommand;	/* 0x124 */
+	u32 macintstatus;	/* 0x128 */
+	u32 macintmask;	/* 0x12C */
 
 	/* Transmit Template Access */
-	uint32 tplatewrptr;	/* 0x130 */
-	uint32 tplatewrdata;	/* 0x134 */
-	uint32 PAD[2];		/* 0x138 - 0x13C */
+	u32 tplatewrptr;	/* 0x130 */
+	u32 tplatewrdata;	/* 0x134 */
+	u32 PAD[2];		/* 0x138 - 0x13C */
 
 	/* PMQ registers */
 	pmqreg_t pmqreg;	/* 0x140 */
-	uint32 pmqpatl;		/* 0x144 */
-	uint32 pmqpath;		/* 0x148 */
-	uint32 PAD;		/* 0x14C */
-
-	uint32 chnstatus;	/* 0x150 */
-	uint32 psmdebug;	/* 0x154 *//* for corerev >= 3 */
-	uint32 phydebug;	/* 0x158 *//* for corerev >= 3 */
-	uint32 machwcap;	/* 0x15C *//* Corerev >= 13 */
+	u32 pmqpatl;		/* 0x144 */
+	u32 pmqpath;		/* 0x148 */
+	u32 PAD;		/* 0x14C */
+
+	u32 chnstatus;	/* 0x150 */
+	u32 psmdebug;	/* 0x154 *//* for corerev >= 3 */
+	u32 phydebug;	/* 0x158 *//* for corerev >= 3 */
+	u32 machwcap;	/* 0x15C *//* Corerev >= 13 */
 
 	/* Extended Internal Objects */
-	uint32 objaddr;		/* 0x160 */
-	uint32 objdata;		/* 0x164 */
-	uint32 PAD[2];		/* 0x168 - 0x16c */
+	u32 objaddr;		/* 0x160 */
+	u32 objdata;		/* 0x164 */
+	u32 PAD[2];		/* 0x168 - 0x16c */
 
 	/* New txstatus registers on corerev >= 5 */
-	uint32 frmtxstatus;	/* 0x170 */
-	uint32 frmtxstatus2;	/* 0x174 */
-	uint32 PAD[2];		/* 0x178 - 0x17c */
+	u32 frmtxstatus;	/* 0x170 */
+	u32 frmtxstatus2;	/* 0x174 */
+	u32 PAD[2];		/* 0x178 - 0x17c */
 
 	/* New TSF host access on corerev >= 3 */
 
-	uint32 tsf_timerlow;	/* 0x180 */
-	uint32 tsf_timerhigh;	/* 0x184 */
-	uint32 tsf_cfprep;	/* 0x188 */
-	uint32 tsf_cfpstart;	/* 0x18c */
-	uint32 tsf_cfpmaxdur32;	/* 0x190 */
-	uint32 PAD[3];		/* 0x194 - 0x19c */
-
-	uint32 maccontrol1;	/* 0x1a0 */
-	uint32 machwcap1;	/* 0x1a4 */
-	uint32 PAD[14];		/* 0x1a8 - 0x1dc */
+	u32 tsf_timerlow;	/* 0x180 */
+	u32 tsf_timerhigh;	/* 0x184 */
+	u32 tsf_cfprep;	/* 0x188 */
+	u32 tsf_cfpstart;	/* 0x18c */
+	u32 tsf_cfpmaxdur32;	/* 0x190 */
+	u32 PAD[3];		/* 0x194 - 0x19c */
+
+	u32 maccontrol1;	/* 0x1a0 */
+	u32 machwcap1;	/* 0x1a4 */
+	u32 PAD[14];		/* 0x1a8 - 0x1dc */
 
 	/* Clock control and hardware workarounds (corerev >= 13) */
-	uint32 clk_ctl_st;	/* 0x1e0 */
-	uint32 hw_war;
-	uint32 d11_phypllctl;	/* 0x1e8 (corerev == 16), the phypll request/avail bits are
+	u32 clk_ctl_st;	/* 0x1e0 */
+	u32 hw_war;
+	u32 d11_phypllctl;	/* 0x1e8 (corerev == 16), the phypll request/avail bits are
 				 *   moved to clk_ctl_st for corerev >= 17
 				 */
-	uint32 PAD[5];		/* 0x1ec - 0x1fc */
+	u32 PAD[5];		/* 0x1ec - 0x1fc */
 
 	/* 0x200-0x37F dma/pio registers */
 	volatile union {
@@ -185,14 +185,14 @@ typedef volatile struct _d11regs {
 	/* FIFO diagnostic port access */
 	dma32diag_t dmafifo;	/* 0x380 - 0x38C */
 
-	uint32 aggfifocnt;	/* 0x390 */
-	uint32 aggfifodata;	/* 0x394 */
-	uint32 PAD[16];		/* 0x398 - 0x3d4 */
+	u32 aggfifocnt;	/* 0x390 */
+	u32 aggfifodata;	/* 0x394 */
+	u32 PAD[16];		/* 0x398 - 0x3d4 */
 	u16 radioregaddr;	/* 0x3d8 */
 	u16 radioregdata;	/* 0x3da */
 
 	/* time delay between the change on rf disable input and radio shutdown corerev 10 */
-	uint32 rfdisabledly;	/* 0x3DC */
+	u32 rfdisabledly;	/* 0x3DC */
 
 	/* PHY register access */
 	u16 phyversion;	/* 0x3e0 - 0x0 */
@@ -640,7 +640,7 @@ BWL_PRE_PACKED_STRUCT struct ofdm_phy_hd
 
 #define	D11A_PHY_HDR_GRATE(phdr)	((phdr)->rlpt[0] & 0x0f)
 #define	D11A_PHY_HDR_GRES(phdr)		(((phdr)->rlpt[0] >> 4) & 0x01)
-#define	D11A_PHY_HDR_GLENGTH(phdr)	(((uint32 *)((phdr)->rlpt) >> 5) & 0x0fff)
+#define	D11A_PHY_HDR_GLENGTH(phdr)	(((u32 *)((phdr)->rlpt) >> 5) & 0x0fff)
 #define	D11A_PHY_HDR_GPARITY(phdr)	(((phdr)->rlpt[3] >> 1) & 0x01)
 #define	D11A_PHY_HDR_GTAIL(phdr)	(((phdr)->rlpt[3] >> 2) & 0x3f)
 
@@ -651,7 +651,7 @@ BWL_PRE_PACKED_STRUCT struct ofdm_phy_hd
 #define	D11A_PHY_HDR_SRES(phdr)		((phdr)->rlpt[0] &= 0xef)
 /* length is number of octets in PSDU */
 #define	D11A_PHY_HDR_SLENGTH(phdr, length)	\
-	(*(uint32 *)((phdr)->rlpt) = *(uint32 *)((phdr)->rlpt) | \
+	(*(u32 *)((phdr)->rlpt) = *(u32 *)((phdr)->rlpt) | \
 	(((length) & 0x0fff) << 5))
 /* set the tail to all zeros */
 #define	D11A_PHY_HDR_STAIL(phdr)	((phdr)->rlpt[3] &= 0x03)
@@ -1330,7 +1330,7 @@ BWL_PRE_PACKED_STRUCT struct d11rxhdr {
 typedef struct wlc_d11rxhdr wlc_d11rxhdr_t;
 BWL_PRE_PACKED_STRUCT struct wlc_d11rxhdr {
 	d11rxhdr_t rxhdr;
-	uint32 tsf_l;		/* TSF_L reading */
+	u32 tsf_l;		/* TSF_L reading */
 	s8 rssi;		/* computed instanteneous rssi in BMAC */
 	s8 rxpwr0;		/* obsoleted, place holder for legacy ROM code. use rxpwr[] */
 	s8 rxpwr1;		/* obsoleted, place holder for legacy ROM code. use rxpwr[] */
--- a/drivers/staging/brcm80211/include/dbus.h
+++ b/drivers/staging/brcm80211/include/dbus.h
@@ -111,10 +111,10 @@ typedef struct {
  * Let upper layer account for packets/bytes
  */
 typedef struct {
-	uint32 rx_errors;
-	uint32 tx_errors;
-	uint32 rx_dropped;
-	uint32 tx_dropped;
+	u32 rx_errors;
+	u32 tx_errors;
+	u32 rx_dropped;
+	u32 tx_dropped;
 } dbus_stats_t;
 
 /*
@@ -127,8 +127,8 @@ typedef struct {
 struct dbus_callbacks;
 struct exec_parms;
 
-typedef void *(*probe_cb_t) (void *arg, const char *desc, uint32 bustype,
-			     uint32 hdrlen);
+typedef void *(*probe_cb_t) (void *arg, const char *desc, u32 bustype,
+			     u32 hdrlen);
 typedef void (*disconnect_cb_t) (void *arg);
 typedef void *(*exec_cb_t) (struct exec_parms *args);
 
@@ -260,7 +260,7 @@ extern int dbus_get_config(const dbus_pu
 extern void *dbus_pktget(const dbus_pub_t *pub, int len);
 extern void dbus_pktfree(const dbus_pub_t *pub, void *pkt);
 
-extern int dbus_set_errmask(const dbus_pub_t *pub, uint32 mask);
+extern int dbus_set_errmask(const dbus_pub_t *pub, u32 mask);
 extern int dbus_pnp_sleep(const dbus_pub_t *pub);
 extern int dbus_pnp_resume(const dbus_pub_t *pub, int *fw_reload);
 extern int dbus_pnp_disconnect(const dbus_pub_t *pub);
--- a/drivers/staging/brcm80211/include/hndpmu.h
+++ b/drivers/staging/brcm80211/include/hndpmu.h
@@ -30,17 +30,17 @@
 
 extern void si_pmu_init(si_t *sih, osl_t *osh);
 extern void si_pmu_chip_init(si_t *sih, osl_t *osh);
-extern void si_pmu_pll_init(si_t *sih, osl_t *osh, uint32 xtalfreq);
+extern void si_pmu_pll_init(si_t *sih, osl_t *osh, u32 xtalfreq);
 extern void si_pmu_res_init(si_t *sih, osl_t *osh);
 extern void si_pmu_swreg_init(si_t *sih, osl_t *osh);
 
-extern uint32 si_pmu_force_ilp(si_t *sih, osl_t *osh, bool force);
+extern u32 si_pmu_force_ilp(si_t *sih, osl_t *osh, bool force);
 
-extern uint32 si_pmu_si_clock(si_t *sih, osl_t *osh);
-extern uint32 si_pmu_cpu_clock(si_t *sih, osl_t *osh);
-extern uint32 si_pmu_mem_clock(si_t *sih, osl_t *osh);
-extern uint32 si_pmu_alp_clock(si_t *sih, osl_t *osh);
-extern uint32 si_pmu_ilp_clock(si_t *sih, osl_t *osh);
+extern u32 si_pmu_si_clock(si_t *sih, osl_t *osh);
+extern u32 si_pmu_cpu_clock(si_t *sih, osl_t *osh);
+extern u32 si_pmu_mem_clock(si_t *sih, osl_t *osh);
+extern u32 si_pmu_alp_clock(si_t *sih, osl_t *osh);
+extern u32 si_pmu_ilp_clock(si_t *sih, osl_t *osh);
 
 extern void si_pmu_set_switcher_voltage(si_t *sih, osl_t *osh,
 					u8 bb_voltage, u8 rf_voltage);
@@ -52,20 +52,20 @@ extern void si_pmu_pllupd(si_t *sih);
 extern void si_pmu_spuravoid(si_t *sih, osl_t *osh, u8 spuravoid);
 
 extern bool si_pmu_is_otp_powered(si_t *sih, osl_t *osh);
-extern uint32 si_pmu_measure_alpclk(si_t *sih, osl_t *osh);
+extern u32 si_pmu_measure_alpclk(si_t *sih, osl_t *osh);
 
-extern uint32 si_pmu_chipcontrol(si_t *sih, uint reg, uint32 mask, uint32 val);
-extern uint32 si_pmu_regcontrol(si_t *sih, uint reg, uint32 mask, uint32 val);
-extern uint32 si_pmu_pllcontrol(si_t *sih, uint reg, uint32 mask, uint32 val);
+extern u32 si_pmu_chipcontrol(si_t *sih, uint reg, u32 mask, u32 val);
+extern u32 si_pmu_regcontrol(si_t *sih, uint reg, u32 mask, u32 val);
+extern u32 si_pmu_pllcontrol(si_t *sih, uint reg, u32 mask, u32 val);
 extern void si_pmu_pllupd(si_t *sih);
 extern void si_pmu_sprom_enable(si_t *sih, osl_t *osh, bool enable);
 
 extern void si_pmu_radio_enable(si_t *sih, bool enable);
-extern uint32 si_pmu_waitforclk_on_backplane(si_t *sih, osl_t *osh,
-					     uint32 clk, uint32 delay);
+extern u32 si_pmu_waitforclk_on_backplane(si_t *sih, osl_t *osh,
+					     u32 clk, u32 delay);
 
 extern void si_pmu_otp_power(si_t *sih, osl_t *osh, bool on);
 extern void si_sdiod_drive_strength_init(si_t *sih, osl_t *osh,
-					 uint32 drivestrength);
+					 u32 drivestrength);
 
 #endif				/* _hndpmu_h_ */
--- a/drivers/staging/brcm80211/include/hndrte_armtrap.h
+++ b/drivers/staging/brcm80211/include/hndrte_armtrap.h
@@ -50,26 +50,26 @@
 #include <typedefs.h>
 
 typedef struct _trap_struct {
-	uint32 type;
-	uint32 epc;
-	uint32 cpsr;
-	uint32 spsr;
-	uint32 r0;
-	uint32 r1;
-	uint32 r2;
-	uint32 r3;
-	uint32 r4;
-	uint32 r5;
-	uint32 r6;
-	uint32 r7;
-	uint32 r8;
-	uint32 r9;
-	uint32 r10;
-	uint32 r11;
-	uint32 r12;
-	uint32 r13;
-	uint32 r14;
-	uint32 pc;
+	u32 type;
+	u32 epc;
+	u32 cpsr;
+	u32 spsr;
+	u32 r0;
+	u32 r1;
+	u32 r2;
+	u32 r3;
+	u32 r4;
+	u32 r5;
+	u32 r6;
+	u32 r7;
+	u32 r8;
+	u32 r9;
+	u32 r10;
+	u32 r11;
+	u32 r12;
+	u32 r13;
+	u32 r14;
+	u32 pc;
 } trap_t;
 
 #endif				/* !_LANGUAGE_ASSEMBLY */
--- a/drivers/staging/brcm80211/include/hndrte_cons.h
+++ b/drivers/staging/brcm80211/include/hndrte_cons.h
@@ -21,7 +21,7 @@
 #define LOG_BUF_LEN	1024
 
 typedef struct {
-	uint32 buf;		/* Can't be pointer on (64-bit) hosts */
+	u32 buf;		/* Can't be pointer on (64-bit) hosts */
 	uint buf_size;
 	uint idx;
 	char *_buf_compat;	/* Redundant pointer for backward compat. */
--- a/drivers/staging/brcm80211/include/linux_osl.h
+++ b/drivers/staging/brcm80211/include/linux_osl.h
@@ -30,7 +30,7 @@ extern void osl_os_close_image(void *ima
 extern osl_t *osl_attach(void *pdev, uint bustype, bool pkttag);
 extern void osl_detach(osl_t *osh);
 
-extern uint32 g_assert_type;
+extern u32 g_assert_type;
 
 #if defined(BCMDBG_ASSERT)
 #define ASSERT(exp) \
@@ -57,7 +57,7 @@ extern void osl_delay(uint usec);
 	osl_pci_read_config((osh), (offset), (size))
 #define	OSL_PCI_WRITE_CONFIG(osh, offset, size, val) \
 	osl_pci_write_config((osh), (offset), (size), (val))
-extern uint32 osl_pci_read_config(osl_t *osh, uint offset, uint size);
+extern u32 osl_pci_read_config(osl_t *osh, uint offset, uint size);
 extern void osl_pci_write_config(osl_t *osh, uint offset, uint size, uint val);
 
 /* PCI device bus # and slot # */
@@ -165,7 +165,7 @@ extern int osl_error(int bcmerror);
 /* the largest reasonable packet buffer driver uses for ethernet MTU in bytes */
 #define	PKTBUFSZ	2048	/* largest reasonable packet buffer, driver uses for ethernet MTU */
 
-#define OSL_SYSUPTIME()		((uint32)jiffies * (1000 / HZ))
+#define OSL_SYSUPTIME()		((u32)jiffies * (1000 / HZ))
 #define	printf(fmt, args...)	printk(fmt , ## args)
 #ifdef BRCM_FULLMAC
 #include <linux/kernel.h>	/* for vsn/printf's */
@@ -184,7 +184,7 @@ extern int osl_error(int bcmerror);
 #define R_REG(osh, r) (\
 	SELECT_BUS_READ(osh, sizeof(*(r)) == sizeof(u8) ? readb((volatile u8*)(r)) : \
 	sizeof(*(r)) == sizeof(u16) ? readw((volatile u16*)(r)) : \
-	readl((volatile uint32*)(r)), OSL_READ_REG(osh, r)) \
+	readl((volatile u32*)(r)), OSL_READ_REG(osh, r)) \
 )
 #else				/* __mips__ */
 #define R_REG(osh, r) (\
@@ -199,9 +199,9 @@ extern int osl_error(int bcmerror);
 			case sizeof(u16): \
 				__osl_v = readw((volatile u16*)(r)); \
 				break; \
-			case sizeof(uint32): \
+			case sizeof(u32): \
 				__osl_v = \
-				readl((volatile uint32*)(r)); \
+				readl((volatile u32*)(r)); \
 				break; \
 			} \
 			__asm__ __volatile__("sync"); \
@@ -224,8 +224,8 @@ extern int osl_error(int bcmerror);
 			writeb((u8)(v), (volatile u8*)(r)); break; \
 		case sizeof(u16): \
 			writew((u16)(v), (volatile u16*)(r)); break; \
-		case sizeof(uint32): \
-			writel((uint32)(v), (volatile uint32*)(r)); break; \
+		case sizeof(u32): \
+			writel((u32)(v), (volatile u32*)(r)); break; \
 		}, \
 		(OSL_WRITE_REG(osh, r, v))); \
 	} while (0)
@@ -243,8 +243,8 @@ extern int osl_error(int bcmerror);
 				__osl_v = \
 				readw((volatile u16*)((uintptr)(r)^2)); \
 				break; \
-			case sizeof(uint32): \
-				__osl_v = readl((volatile uint32*)(r)); \
+			case sizeof(u32): \
+				__osl_v = readl((volatile u32*)(r)); \
 				break; \
 			} \
 			__osl_v; \
@@ -260,9 +260,9 @@ extern int osl_error(int bcmerror);
 		case sizeof(u16):	\
 			writew((u16)(v), \
 			(volatile u16*)((uintptr)(r)^2)); break; \
-		case sizeof(uint32):	\
-			writel((uint32)(v), \
-			(volatile uint32*)(r)); break; \
+		case sizeof(u32):	\
+			writel((u32)(v), \
+			(volatile u32*)(r)); break; \
 		}, \
 		(OSL_WRITE_REG(osh, r, v))); \
 	} while (0)
@@ -402,7 +402,7 @@ osl_pkt_tonative(osl_pubinfo_t *osh, voi
 #define RPC_READ_REG(osh, r) (\
 	sizeof(*(r)) == sizeof(u8) ? osl_readb((osh), (volatile u8*)(r)) : \
 	sizeof(*(r)) == sizeof(u16) ? osl_readw((osh), (volatile u16*)(r)) : \
-	osl_readl((osh), (volatile uint32*)(r)) \
+	osl_readl((osh), (volatile u32*)(r)) \
 )
 #define RPC_WRITE_REG(osh, r, v) do { \
 	switch (sizeof(*(r))) { \
@@ -412,18 +412,18 @@ osl_pkt_tonative(osl_pubinfo_t *osh, voi
 	case sizeof(u16): \
 		osl_writew((osh), (volatile u16*)(r), (u16)(v)); \
 		break; \
-	case sizeof(uint32): \
-		osl_writel((osh), (volatile uint32*)(r), (uint32)(v)); \
+	case sizeof(u32): \
+		osl_writel((osh), (volatile u32*)(r), (u32)(v)); \
 		break; \
 	} \
 } while (0)
 
 extern u8 osl_readb(osl_t *osh, volatile u8 *r);
 extern u16 osl_readw(osl_t *osh, volatile u16 *r);
-extern uint32 osl_readl(osl_t *osh, volatile uint32 *r);
+extern u32 osl_readl(osl_t *osh, volatile u32 *r);
 extern void osl_writeb(osl_t *osh, volatile u8 *r, u8 v);
 extern void osl_writew(osl_t *osh, volatile u16 *r, u16 v);
-extern void osl_writel(osl_t *osh, volatile uint32 *r, uint32 v);
+extern void osl_writel(osl_t *osh, volatile u32 *r, u32 v);
 #endif				/* BCMSDIO */
 
 #endif				/* _linux_osl_h_ */
--- a/drivers/staging/brcm80211/include/msgtrace.h
+++ b/drivers/staging/brcm80211/include/msgtrace.h
@@ -29,14 +29,14 @@ typedef BWL_PRE_PACKED_STRUCT struct msg
 	u8 version;
 	u8 spare;
 	u16 len;		/* Len of the trace */
-	uint32 seqnum;		/* Sequence number of message. Useful
+	u32 seqnum;		/* Sequence number of message. Useful
 				 * if the messsage has been lost
 				 * because of DMA error or a bus reset
 				 * (ex: SDIO Func2)
 				 */
-	uint32 discarded_bytes;	/* Number of discarded bytes because of
+	u32 discarded_bytes;	/* Number of discarded bytes because of
 				 trace overflow  */
-	uint32 discarded_printf;	/* Number of discarded printf
+	u32 discarded_printf;	/* Number of discarded printf
 				 because of trace overflow */
 } BWL_POST_PACKED_STRUCT msgtrace_hdr_t;
 
--- a/drivers/staging/brcm80211/include/nicpci.h
+++ b/drivers/staging/brcm80211/include/nicpci.h
@@ -46,14 +46,14 @@
 struct sbpcieregs;
 
 extern u8 pcicore_find_pci_capability(osl_t *osh, u8 req_cap_id,
-					 unsigned char *buf, uint32 *buflen);
+					 unsigned char *buf, u32 *buflen);
 extern uint pcie_readreg(osl_t *osh, struct sbpcieregs *pcieregs,
 			 uint addrtype, uint offset);
 extern uint pcie_writereg(osl_t *osh, struct sbpcieregs *pcieregs,
 			  uint addrtype, uint offset, uint val);
 
-extern u8 pcie_clkreq(void *pch, uint32 mask, uint32 val);
-extern uint32 pcie_lcreg(void *pch, uint32 mask, uint32 val);
+extern u8 pcie_clkreq(void *pch, u32 mask, u32 val);
+extern u32 pcie_lcreg(void *pch, u32 mask, u32 val);
 
 extern void *pcicore_init(si_t *sih, osl_t *osh, void *regs);
 extern void pcicore_deinit(void *pch);
@@ -64,11 +64,11 @@ extern void pcicore_sleep(void *pch);
 extern void pcicore_down(void *pch, int state);
 
 extern void pcie_war_ovr_aspm_update(void *pch, u8 aspm);
-extern uint32 pcicore_pcieserdesreg(void *pch, uint32 mdioslave, uint32 offset,
-				    uint32 mask, uint32 val);
+extern u32 pcicore_pcieserdesreg(void *pch, u32 mdioslave, u32 offset,
+				    u32 mask, u32 val);
 
-extern uint32 pcicore_pciereg(void *pch, uint32 offset, uint32 mask,
-			      uint32 val, uint type);
+extern u32 pcicore_pciereg(void *pch, u32 offset, u32 mask,
+			      u32 val, uint type);
 
 extern bool pcicore_pmecap_fast(osl_t *osh);
 extern void pcicore_pmeen(void *pch);
--- a/drivers/staging/brcm80211/include/pci_core.h
+++ b/drivers/staging/brcm80211/include/pci_core.h
@@ -28,30 +28,30 @@
 
 /* Sonics side: PCI core and host control registers */
 typedef struct sbpciregs {
-	uint32 control;		/* PCI control */
-	uint32 PAD[3];
-	uint32 arbcontrol;	/* PCI arbiter control */
-	uint32 clkrun;		/* Clkrun Control (>=rev11) */
-	uint32 PAD[2];
-	uint32 intstatus;	/* Interrupt status */
-	uint32 intmask;		/* Interrupt mask */
-	uint32 sbtopcimailbox;	/* Sonics to PCI mailbox */
-	uint32 PAD[9];
-	uint32 bcastaddr;	/* Sonics broadcast address */
-	uint32 bcastdata;	/* Sonics broadcast data */
-	uint32 PAD[2];
-	uint32 gpioin;		/* ro: gpio input (>=rev2) */
-	uint32 gpioout;		/* rw: gpio output (>=rev2) */
-	uint32 gpioouten;	/* rw: gpio output enable (>= rev2) */
-	uint32 gpiocontrol;	/* rw: gpio control (>= rev2) */
-	uint32 PAD[36];
-	uint32 sbtopci0;	/* Sonics to PCI translation 0 */
-	uint32 sbtopci1;	/* Sonics to PCI translation 1 */
-	uint32 sbtopci2;	/* Sonics to PCI translation 2 */
-	uint32 PAD[189];
-	uint32 pcicfg[4][64];	/* 0x400 - 0x7FF, PCI Cfg Space (>=rev8) */
+	u32 control;		/* PCI control */
+	u32 PAD[3];
+	u32 arbcontrol;	/* PCI arbiter control */
+	u32 clkrun;		/* Clkrun Control (>=rev11) */
+	u32 PAD[2];
+	u32 intstatus;	/* Interrupt status */
+	u32 intmask;		/* Interrupt mask */
+	u32 sbtopcimailbox;	/* Sonics to PCI mailbox */
+	u32 PAD[9];
+	u32 bcastaddr;	/* Sonics broadcast address */
+	u32 bcastdata;	/* Sonics broadcast data */
+	u32 PAD[2];
+	u32 gpioin;		/* ro: gpio input (>=rev2) */
+	u32 gpioout;		/* rw: gpio output (>=rev2) */
+	u32 gpioouten;	/* rw: gpio output enable (>= rev2) */
+	u32 gpiocontrol;	/* rw: gpio control (>= rev2) */
+	u32 PAD[36];
+	u32 sbtopci0;	/* Sonics to PCI translation 0 */
+	u32 sbtopci1;	/* Sonics to PCI translation 1 */
+	u32 sbtopci2;	/* Sonics to PCI translation 2 */
+	u32 PAD[189];
+	u32 pcicfg[4][64];	/* 0x400 - 0x7FF, PCI Cfg Space (>=rev8) */
 	u16 sprom[36];	/* SPROM shadow Area */
-	uint32 PAD[46];
+	u32 PAD[46];
 } sbpciregs_t;
 
 #endif				/* _LANGUAGE_ASSEMBLY */
--- a/drivers/staging/brcm80211/include/pcicfg.h
+++ b/drivers/staging/brcm80211/include/pcicfg.h
@@ -115,12 +115,12 @@ typedef struct _pci_config_regs {
 	u8 latency_timer;
 	u8 header_type;
 	u8 bist;
-	uint32 base[PCI_BAR_MAX];
-	uint32 cardbus_cis;
+	u32 base[PCI_BAR_MAX];
+	u32 cardbus_cis;
 	u16 subsys_vendor;
 	u16 subsys_id;
-	uint32 baserom;
-	uint32 rsvd_a[PCR_RSVDA_MAX];
+	u32 baserom;
+	u32 rsvd_a[PCR_RSVDA_MAX];
 	u8 int_line;
 	u8 int_pin;
 	u8 min_gnt;
@@ -343,7 +343,7 @@ typedef struct _ppb_config_regs {
 	u8 latency_timer;
 	u8 header_type;
 	u8 bist;
-	uint32 rsvd_a[PPB_RSVDA_MAX];
+	u32 rsvd_a[PPB_RSVDA_MAX];
 	u8 prim_bus;
 	u8 sec_bus;
 	u8 sub_bus;
@@ -355,20 +355,20 @@ typedef struct _ppb_config_regs {
 	u16 mem_lim;
 	u16 pf_mem_base;
 	u16 pf_mem_lim;
-	uint32 pf_mem_base_hi;
-	uint32 pf_mem_lim_hi;
+	u32 pf_mem_base_hi;
+	u32 pf_mem_lim_hi;
 	u16 io_base_hi;
 	u16 io_lim_hi;
 	u16 subsys_vendor;
 	u16 subsys_id;
-	uint32 rsvd_b;
+	u32 rsvd_b;
 	u8 rsvd_c;
 	u8 int_pin;
 	u16 bridge_ctrl;
 	u8 chip_ctrl;
 	u8 diag_ctrl;
 	u16 arb_ctrl;
-	uint32 rsvd_d[PPB_RSVDD_MAX];
+	u32 rsvd_d[PPB_RSVDD_MAX];
 	u8 dev_dep[192];
 } ppb_config_regs;
 
@@ -385,7 +385,7 @@ typedef struct _pciconfig_cap_msi {
 	u8 capID;
 	u8 nextptr;
 	u16 msgctrl;
-	uint32 msgaddr;
+	u32 msgaddr;
 } pciconfig_cap_msi;
 
 /* Data structure to define the Power managment facility
@@ -410,18 +410,18 @@ typedef struct _pciconfig_cap_pcie {
 	u8 capID;
 	u8 nextptr;
 	u16 pcie_cap;
-	uint32 dev_cap;
+	u32 dev_cap;
 	u16 dev_ctrl;
 	u16 dev_status;
-	uint32 link_cap;
+	u32 link_cap;
 	u16 link_ctrl;
 	u16 link_status;
-	uint32 slot_cap;
+	u32 slot_cap;
 	u16 slot_ctrl;
 	u16 slot_status;
 	u16 root_ctrl;
 	u16 root_cap;
-	uint32 root_status;
+	u32 root_status;
 } pciconfig_cap_pcie;
 
 /* PCIE Enhanced CAPABILITY DEFINES */
--- a/drivers/staging/brcm80211/include/pcie_core.h
+++ b/drivers/staging/brcm80211/include/pcie_core.h
@@ -46,36 +46,36 @@
 
 /* SB side: PCIE core and host control registers */
 typedef struct sbpcieregs {
-	uint32 control;		/* host mode only */
-	uint32 PAD[2];
-	uint32 biststatus;	/* bist Status: 0x00C */
-	uint32 gpiosel;		/* PCIE gpio sel: 0x010 */
-	uint32 gpioouten;	/* PCIE gpio outen: 0x14 */
-	uint32 PAD[2];
-	uint32 intstatus;	/* Interrupt status: 0x20 */
-	uint32 intmask;		/* Interrupt mask: 0x24 */
-	uint32 sbtopcimailbox;	/* sb to pcie mailbox: 0x028 */
-	uint32 PAD[53];
-	uint32 sbtopcie0;	/* sb to pcie translation 0: 0x100 */
-	uint32 sbtopcie1;	/* sb to pcie translation 1: 0x104 */
-	uint32 sbtopcie2;	/* sb to pcie translation 2: 0x108 */
-	uint32 PAD[5];
+	u32 control;		/* host mode only */
+	u32 PAD[2];
+	u32 biststatus;	/* bist Status: 0x00C */
+	u32 gpiosel;		/* PCIE gpio sel: 0x010 */
+	u32 gpioouten;	/* PCIE gpio outen: 0x14 */
+	u32 PAD[2];
+	u32 intstatus;	/* Interrupt status: 0x20 */
+	u32 intmask;		/* Interrupt mask: 0x24 */
+	u32 sbtopcimailbox;	/* sb to pcie mailbox: 0x028 */
+	u32 PAD[53];
+	u32 sbtopcie0;	/* sb to pcie translation 0: 0x100 */
+	u32 sbtopcie1;	/* sb to pcie translation 1: 0x104 */
+	u32 sbtopcie2;	/* sb to pcie translation 2: 0x108 */
+	u32 PAD[5];
 
 	/* pcie core supports in direct access to config space */
-	uint32 configaddr;	/* pcie config space access: Address field: 0x120 */
-	uint32 configdata;	/* pcie config space access: Data field: 0x124 */
+	u32 configaddr;	/* pcie config space access: Address field: 0x120 */
+	u32 configdata;	/* pcie config space access: Data field: 0x124 */
 
 	/* mdio access to serdes */
-	uint32 mdiocontrol;	/* controls the mdio access: 0x128 */
-	uint32 mdiodata;	/* Data to the mdio access: 0x12c */
+	u32 mdiocontrol;	/* controls the mdio access: 0x128 */
+	u32 mdiodata;	/* Data to the mdio access: 0x12c */
 
 	/* pcie protocol phy/dllp/tlp register indirect access mechanism */
-	uint32 pcieindaddr;	/* indirect access to the internal register: 0x130 */
-	uint32 pcieinddata;	/* Data to/from the internal regsiter: 0x134 */
+	u32 pcieindaddr;	/* indirect access to the internal register: 0x130 */
+	u32 pcieinddata;	/* Data to/from the internal regsiter: 0x134 */
 
-	uint32 clkreqenctrl;	/* >= rev 6, Clkreq rdma control : 0x138 */
-	uint32 PAD[177];
-	uint32 pciecfg[4][64];	/* 0x400 - 0x7FF, PCIE Cfg Space */
+	u32 clkreqenctrl;	/* >= rev 6, Clkreq rdma control : 0x138 */
+	u32 PAD[177];
+	u32 pciecfg[4][64];	/* 0x400 - 0x7FF, PCIE Cfg Space */
 	u16 sprom[64];	/* SPROM shadow Area */
 } sbpcieregs_t;
 
--- a/drivers/staging/brcm80211/include/proto/802.11.h
+++ b/drivers/staging/brcm80211/include/proto/802.11.h
@@ -81,7 +81,7 @@ BWL_PRE_PACKED_STRUCT struct dot11_manag
 #define	DOT11_MGMT_HDR_LEN	24
 
 BWL_PRE_PACKED_STRUCT struct dot11_bcn_prb {
-	uint32 timestamp[2];
+	u32 timestamp[2];
 	u16 beacon_interval;
 	u16 capability;
 } BWL_POST_PACKED_STRUCT;
@@ -236,20 +236,20 @@ typedef struct wme_param_ie wme_param_ie
 #define	DOT11_MAXNUMFRAGS	16
 
 typedef struct d11cnt {
-	uint32 txfrag;
-	uint32 txmulti;
-	uint32 txfail;
-	uint32 txretry;
-	uint32 txretrie;
-	uint32 rxdup;
-	uint32 txrts;
-	uint32 txnocts;
-	uint32 txnoack;
-	uint32 rxfrag;
-	uint32 rxmulti;
-	uint32 rxcrc;
-	uint32 txfrmsnt;
-	uint32 rxundec;
+	u32 txfrag;
+	u32 txmulti;
+	u32 txfail;
+	u32 txretry;
+	u32 txretrie;
+	u32 rxdup;
+	u32 txrts;
+	u32 txnocts;
+	u32 txnoack;
+	u32 rxfrag;
+	u32 rxmulti;
+	u32 rxcrc;
+	u32 txfrmsnt;
+	u32 rxundec;
 } d11cnt_t;
 
 #define MCSSET_LEN	16
@@ -259,7 +259,7 @@ BWL_PRE_PACKED_STRUCT struct ht_cap_ie {
 	u8 params;
 	u8 supp_mcs[MCSSET_LEN];
 	u16 ext_htcap;
-	uint32 txbf_cap;
+	u32 txbf_cap;
 	u8 as_cap;
 } BWL_POST_PACKED_STRUCT;
 typedef struct ht_cap_ie ht_cap_ie_t;
--- a/drivers/staging/brcm80211/include/proto/bcmevent.h
+++ b/drivers/staging/brcm80211/include/proto/bcmevent.h
@@ -30,11 +30,11 @@
 typedef BWL_PRE_PACKED_STRUCT struct {
 	u16 version;
 	u16 flags;
-	uint32 event_type;
-	uint32 status;
-	uint32 reason;
-	uint32 auth_type;
-	uint32 datalen;
+	u32 event_type;
+	u32 status;
+	u32 reason;
+	u32 auth_type;
+	u32 datalen;
 	struct ether_addr addr;
 	char ifname[BCM_MSG_IFNAME_MAX];
 } BWL_POST_PACKED_STRUCT wl_event_msg_t;
--- a/drivers/staging/brcm80211/include/sbchipc.h
+++ b/drivers/staging/brcm80211/include/sbchipc.h
@@ -27,147 +27,147 @@
 #endif				/* PAD */
 
 typedef volatile struct {
-	uint32 chipid;		/* 0x0 */
-	uint32 capabilities;
-	uint32 corecontrol;	/* corerev >= 1 */
-	uint32 bist;
+	u32 chipid;		/* 0x0 */
+	u32 capabilities;
+	u32 corecontrol;	/* corerev >= 1 */
+	u32 bist;
 
 	/* OTP */
-	uint32 otpstatus;	/* 0x10, corerev >= 10 */
-	uint32 otpcontrol;
-	uint32 otpprog;
-	uint32 otplayout;	/* corerev >= 23 */
+	u32 otpstatus;	/* 0x10, corerev >= 10 */
+	u32 otpcontrol;
+	u32 otpprog;
+	u32 otplayout;	/* corerev >= 23 */
 
 	/* Interrupt control */
-	uint32 intstatus;	/* 0x20 */
-	uint32 intmask;
+	u32 intstatus;	/* 0x20 */
+	u32 intmask;
 
 	/* Chip specific regs */
-	uint32 chipcontrol;	/* 0x28, rev >= 11 */
-	uint32 chipstatus;	/* 0x2c, rev >= 11 */
+	u32 chipcontrol;	/* 0x28, rev >= 11 */
+	u32 chipstatus;	/* 0x2c, rev >= 11 */
 
 	/* Jtag Master */
-	uint32 jtagcmd;		/* 0x30, rev >= 10 */
-	uint32 jtagir;
-	uint32 jtagdr;
-	uint32 jtagctrl;
+	u32 jtagcmd;		/* 0x30, rev >= 10 */
+	u32 jtagir;
+	u32 jtagdr;
+	u32 jtagctrl;
 
 	/* serial flash interface registers */
-	uint32 flashcontrol;	/* 0x40 */
-	uint32 flashaddress;
-	uint32 flashdata;
-	uint32 PAD[1];
+	u32 flashcontrol;	/* 0x40 */
+	u32 flashaddress;
+	u32 flashdata;
+	u32 PAD[1];
 
 	/* Silicon backplane configuration broadcast control */
-	uint32 broadcastaddress;	/* 0x50 */
-	uint32 broadcastdata;
+	u32 broadcastaddress;	/* 0x50 */
+	u32 broadcastdata;
 
 	/* gpio - cleared only by power-on-reset */
-	uint32 gpiopullup;	/* 0x58, corerev >= 20 */
-	uint32 gpiopulldown;	/* 0x5c, corerev >= 20 */
-	uint32 gpioin;		/* 0x60 */
-	uint32 gpioout;		/* 0x64 */
-	uint32 gpioouten;	/* 0x68 */
-	uint32 gpiocontrol;	/* 0x6C */
-	uint32 gpiointpolarity;	/* 0x70 */
-	uint32 gpiointmask;	/* 0x74 */
+	u32 gpiopullup;	/* 0x58, corerev >= 20 */
+	u32 gpiopulldown;	/* 0x5c, corerev >= 20 */
+	u32 gpioin;		/* 0x60 */
+	u32 gpioout;		/* 0x64 */
+	u32 gpioouten;	/* 0x68 */
+	u32 gpiocontrol;	/* 0x6C */
+	u32 gpiointpolarity;	/* 0x70 */
+	u32 gpiointmask;	/* 0x74 */
 
 	/* GPIO events corerev >= 11 */
-	uint32 gpioevent;
-	uint32 gpioeventintmask;
+	u32 gpioevent;
+	u32 gpioeventintmask;
 
 	/* Watchdog timer */
-	uint32 watchdog;	/* 0x80 */
+	u32 watchdog;	/* 0x80 */
 
 	/* GPIO events corerev >= 11 */
-	uint32 gpioeventintpolarity;
+	u32 gpioeventintpolarity;
 
 	/* GPIO based LED powersave registers corerev >= 16 */
-	uint32 gpiotimerval;	/* 0x88 */
-	uint32 gpiotimeroutmask;
+	u32 gpiotimerval;	/* 0x88 */
+	u32 gpiotimeroutmask;
 
 	/* clock control */
-	uint32 clockcontrol_n;	/* 0x90 */
-	uint32 clockcontrol_sb;	/* aka m0 */
-	uint32 clockcontrol_pci;	/* aka m1 */
-	uint32 clockcontrol_m2;	/* mii/uart/mipsref */
-	uint32 clockcontrol_m3;	/* cpu */
-	uint32 clkdiv;		/* corerev >= 3 */
-	uint32 gpiodebugsel;	/* corerev >= 28 */
-	uint32 capabilities_ext;	/* 0xac  */
+	u32 clockcontrol_n;	/* 0x90 */
+	u32 clockcontrol_sb;	/* aka m0 */
+	u32 clockcontrol_pci;	/* aka m1 */
+	u32 clockcontrol_m2;	/* mii/uart/mipsref */
+	u32 clockcontrol_m3;	/* cpu */
+	u32 clkdiv;		/* corerev >= 3 */
+	u32 gpiodebugsel;	/* corerev >= 28 */
+	u32 capabilities_ext;	/* 0xac  */
 
 	/* pll delay registers (corerev >= 4) */
-	uint32 pll_on_delay;	/* 0xb0 */
-	uint32 fref_sel_delay;
-	uint32 slow_clk_ctl;	/* 5 < corerev < 10 */
-	uint32 PAD;
+	u32 pll_on_delay;	/* 0xb0 */
+	u32 fref_sel_delay;
+	u32 slow_clk_ctl;	/* 5 < corerev < 10 */
+	u32 PAD;
 
 	/* Instaclock registers (corerev >= 10) */
-	uint32 system_clk_ctl;	/* 0xc0 */
-	uint32 clkstatestretch;
-	uint32 PAD[2];
+	u32 system_clk_ctl;	/* 0xc0 */
+	u32 clkstatestretch;
+	u32 PAD[2];
 
 	/* Indirect backplane access (corerev >= 22) */
-	uint32 bp_addrlow;	/* 0xd0 */
-	uint32 bp_addrhigh;
-	uint32 bp_data;
-	uint32 PAD;
-	uint32 bp_indaccess;
-	uint32 PAD[3];
+	u32 bp_addrlow;	/* 0xd0 */
+	u32 bp_addrhigh;
+	u32 bp_data;
+	u32 PAD;
+	u32 bp_indaccess;
+	u32 PAD[3];
 
 	/* More clock dividers (corerev >= 32) */
-	uint32 clkdiv2;
-	uint32 PAD[2];
+	u32 clkdiv2;
+	u32 PAD[2];
 
 	/* In AI chips, pointer to erom */
-	uint32 eromptr;		/* 0xfc */
+	u32 eromptr;		/* 0xfc */
 
 	/* ExtBus control registers (corerev >= 3) */
-	uint32 pcmcia_config;	/* 0x100 */
-	uint32 pcmcia_memwait;
-	uint32 pcmcia_attrwait;
-	uint32 pcmcia_iowait;
-	uint32 ide_config;
-	uint32 ide_memwait;
-	uint32 ide_attrwait;
-	uint32 ide_iowait;
-	uint32 prog_config;
-	uint32 prog_waitcount;
-	uint32 flash_config;
-	uint32 flash_waitcount;
-	uint32 SECI_config;	/* 0x130 SECI configuration */
-	uint32 PAD[3];
+	u32 pcmcia_config;	/* 0x100 */
+	u32 pcmcia_memwait;
+	u32 pcmcia_attrwait;
+	u32 pcmcia_iowait;
+	u32 ide_config;
+	u32 ide_memwait;
+	u32 ide_attrwait;
+	u32 ide_iowait;
+	u32 prog_config;
+	u32 prog_waitcount;
+	u32 flash_config;
+	u32 flash_waitcount;
+	u32 SECI_config;	/* 0x130 SECI configuration */
+	u32 PAD[3];
 
 	/* Enhanced Coexistence Interface (ECI) registers (corerev >= 21) */
-	uint32 eci_output;	/* 0x140 */
-	uint32 eci_control;
-	uint32 eci_inputlo;
-	uint32 eci_inputmi;
-	uint32 eci_inputhi;
-	uint32 eci_inputintpolaritylo;
-	uint32 eci_inputintpolaritymi;
-	uint32 eci_inputintpolarityhi;
-	uint32 eci_intmasklo;
-	uint32 eci_intmaskmi;
-	uint32 eci_intmaskhi;
-	uint32 eci_eventlo;
-	uint32 eci_eventmi;
-	uint32 eci_eventhi;
-	uint32 eci_eventmasklo;
-	uint32 eci_eventmaskmi;
-	uint32 eci_eventmaskhi;
-	uint32 PAD[3];
+	u32 eci_output;	/* 0x140 */
+	u32 eci_control;
+	u32 eci_inputlo;
+	u32 eci_inputmi;
+	u32 eci_inputhi;
+	u32 eci_inputintpolaritylo;
+	u32 eci_inputintpolaritymi;
+	u32 eci_inputintpolarityhi;
+	u32 eci_intmasklo;
+	u32 eci_intmaskmi;
+	u32 eci_intmaskhi;
+	u32 eci_eventlo;
+	u32 eci_eventmi;
+	u32 eci_eventhi;
+	u32 eci_eventmasklo;
+	u32 eci_eventmaskmi;
+	u32 eci_eventmaskhi;
+	u32 PAD[3];
 
 	/* SROM interface (corerev >= 32) */
-	uint32 sromcontrol;	/* 0x190 */
-	uint32 sromaddress;
-	uint32 sromdata;
-	uint32 PAD[17];
+	u32 sromcontrol;	/* 0x190 */
+	u32 sromaddress;
+	u32 sromdata;
+	u32 PAD[17];
 
 	/* Clock control and hardware workarounds (corerev >= 20) */
-	uint32 clk_ctl_st;	/* 0x1e0 */
-	uint32 hw_war;
-	uint32 PAD[70];
+	u32 clk_ctl_st;	/* 0x1e0 */
+	u32 hw_war;
+	u32 PAD[70];
 
 	/* UARTs */
 	u8 uart0data;	/* 0x300 */
@@ -188,38 +188,38 @@ typedef volatile struct {
 	u8 uart1lsr;
 	u8 uart1msr;
 	u8 uart1scratch;
-	uint32 PAD[126];
+	u32 PAD[126];
 
 	/* PMU registers (corerev >= 20) */
-	uint32 pmucontrol;	/* 0x600 */
-	uint32 pmucapabilities;
-	uint32 pmustatus;
-	uint32 res_state;
-	uint32 res_pending;
-	uint32 pmutimer;
-	uint32 min_res_mask;
-	uint32 max_res_mask;
-	uint32 res_table_sel;
-	uint32 res_dep_mask;
-	uint32 res_updn_timer;
-	uint32 res_timer;
-	uint32 clkstretch;
-	uint32 pmuwatchdog;
-	uint32 gpiosel;		/* 0x638, rev >= 1 */
-	uint32 gpioenable;	/* 0x63c, rev >= 1 */
-	uint32 res_req_timer_sel;
-	uint32 res_req_timer;
-	uint32 res_req_mask;
-	uint32 PAD;
-	uint32 chipcontrol_addr;	/* 0x650 */
-	uint32 chipcontrol_data;	/* 0x654 */
-	uint32 regcontrol_addr;
-	uint32 regcontrol_data;
-	uint32 pllcontrol_addr;
-	uint32 pllcontrol_data;
-	uint32 pmustrapopt;	/* 0x668, corerev >= 28 */
-	uint32 pmu_xtalfreq;	/* 0x66C, pmurev >= 10 */
-	uint32 PAD[100];
+	u32 pmucontrol;	/* 0x600 */
+	u32 pmucapabilities;
+	u32 pmustatus;
+	u32 res_state;
+	u32 res_pending;
+	u32 pmutimer;
+	u32 min_res_mask;
+	u32 max_res_mask;
+	u32 res_table_sel;
+	u32 res_dep_mask;
+	u32 res_updn_timer;
+	u32 res_timer;
+	u32 clkstretch;
+	u32 pmuwatchdog;
+	u32 gpiosel;		/* 0x638, rev >= 1 */
+	u32 gpioenable;	/* 0x63c, rev >= 1 */
+	u32 res_req_timer_sel;
+	u32 res_req_timer;
+	u32 res_req_mask;
+	u32 PAD;
+	u32 chipcontrol_addr;	/* 0x650 */
+	u32 chipcontrol_data;	/* 0x654 */
+	u32 regcontrol_addr;
+	u32 regcontrol_data;
+	u32 pllcontrol_addr;
+	u32 pllcontrol_data;
+	u32 pmustrapopt;	/* 0x668, corerev >= 28 */
+	u32 pmu_xtalfreq;	/* 0x66C, pmurev >= 10 */
+	u32 PAD[100];
 	u16 sromotp[768];
 } chipcregs_t;
 
--- a/drivers/staging/brcm80211/include/sbconfig.h
+++ b/drivers/staging/brcm80211/include/sbconfig.h
@@ -74,43 +74,43 @@
 #ifndef _LANGUAGE_ASSEMBLY
 
 typedef volatile struct _sbconfig {
-	uint32 PAD[2];
-	uint32 sbipsflag;	/* initiator port ocp slave flag */
-	uint32 PAD[3];
-	uint32 sbtpsflag;	/* target port ocp slave flag */
-	uint32 PAD[11];
-	uint32 sbtmerrloga;	/* (sonics >= 2.3) */
-	uint32 PAD;
-	uint32 sbtmerrlog;	/* (sonics >= 2.3) */
-	uint32 PAD[3];
-	uint32 sbadmatch3;	/* address match3 */
-	uint32 PAD;
-	uint32 sbadmatch2;	/* address match2 */
-	uint32 PAD;
-	uint32 sbadmatch1;	/* address match1 */
-	uint32 PAD[7];
-	uint32 sbimstate;	/* initiator agent state */
-	uint32 sbintvec;	/* interrupt mask */
-	uint32 sbtmstatelow;	/* target state */
-	uint32 sbtmstatehigh;	/* target state */
-	uint32 sbbwa0;		/* bandwidth allocation table0 */
-	uint32 PAD;
-	uint32 sbimconfiglow;	/* initiator configuration */
-	uint32 sbimconfighigh;	/* initiator configuration */
-	uint32 sbadmatch0;	/* address match0 */
-	uint32 PAD;
-	uint32 sbtmconfiglow;	/* target configuration */
-	uint32 sbtmconfighigh;	/* target configuration */
-	uint32 sbbconfig;	/* broadcast configuration */
-	uint32 PAD;
-	uint32 sbbstate;	/* broadcast state */
-	uint32 PAD[3];
-	uint32 sbactcnfg;	/* activate configuration */
-	uint32 PAD[3];
-	uint32 sbflagst;	/* current sbflags */
-	uint32 PAD[3];
-	uint32 sbidlow;		/* identification */
-	uint32 sbidhigh;	/* identification */
+	u32 PAD[2];
+	u32 sbipsflag;	/* initiator port ocp slave flag */
+	u32 PAD[3];
+	u32 sbtpsflag;	/* target port ocp slave flag */
+	u32 PAD[11];
+	u32 sbtmerrloga;	/* (sonics >= 2.3) */
+	u32 PAD;
+	u32 sbtmerrlog;	/* (sonics >= 2.3) */
+	u32 PAD[3];
+	u32 sbadmatch3;	/* address match3 */
+	u32 PAD;
+	u32 sbadmatch2;	/* address match2 */
+	u32 PAD;
+	u32 sbadmatch1;	/* address match1 */
+	u32 PAD[7];
+	u32 sbimstate;	/* initiator agent state */
+	u32 sbintvec;	/* interrupt mask */
+	u32 sbtmstatelow;	/* target state */
+	u32 sbtmstatehigh;	/* target state */
+	u32 sbbwa0;		/* bandwidth allocation table0 */
+	u32 PAD;
+	u32 sbimconfiglow;	/* initiator configuration */
+	u32 sbimconfighigh;	/* initiator configuration */
+	u32 sbadmatch0;	/* address match0 */
+	u32 PAD;
+	u32 sbtmconfiglow;	/* target configuration */
+	u32 sbtmconfighigh;	/* target configuration */
+	u32 sbbconfig;	/* broadcast configuration */
+	u32 PAD;
+	u32 sbbstate;	/* broadcast state */
+	u32 PAD[3];
+	u32 sbactcnfg;	/* activate configuration */
+	u32 PAD[3];
+	u32 sbflagst;	/* current sbflags */
+	u32 PAD[3];
+	u32 sbidlow;		/* identification */
+	u32 sbidhigh;	/* identification */
 } sbconfig_t;
 
 #endif				/* _LANGUAGE_ASSEMBLY */
--- a/drivers/staging/brcm80211/include/sbhnddma.h
+++ b/drivers/staging/brcm80211/include/sbhnddma.h
@@ -27,10 +27,10 @@
 
 /* dma registers per channel(xmt or rcv) */
 typedef volatile struct {
-	uint32 control;		/* enable, et al */
-	uint32 addr;		/* descriptor ring base address (4K aligned) */
-	uint32 ptr;		/* last descriptor posted to chip */
-	uint32 status;		/* current active descriptor, et al */
+	u32 control;		/* enable, et al */
+	u32 addr;		/* descriptor ring base address (4K aligned) */
+	u32 ptr;		/* last descriptor posted to chip */
+	u32 status;		/* current active descriptor, et al */
 } dma32regs_t;
 
 typedef volatile struct {
@@ -39,10 +39,10 @@ typedef volatile struct {
 } dma32regp_t;
 
 typedef volatile struct {	/* diag access */
-	uint32 fifoaddr;	/* diag address */
-	uint32 fifodatalow;	/* low 32bits of data */
-	uint32 fifodatahigh;	/* high 32bits of data */
-	uint32 pad;		/* reserved */
+	u32 fifoaddr;	/* diag address */
+	u32 fifodatalow;	/* low 32bits of data */
+	u32 fifodatahigh;	/* high 32bits of data */
+	u32 pad;		/* reserved */
 } dma32diag_t;
 
 /*
@@ -50,8 +50,8 @@ typedef volatile struct {	/* diag access
  * Descriptors are only read by the hardware, never written back.
  */
 typedef volatile struct {
-	uint32 ctrl;		/* misc control bits & bufcount */
-	uint32 addr;		/* data buffer address */
+	u32 ctrl;		/* misc control bits & bufcount */
+	u32 addr;		/* data buffer address */
 } dma32dd_t;
 
 /*
@@ -64,12 +64,12 @@ typedef volatile struct {
 #define	D32MAXDD	(D32MAXRINGSZ / sizeof (dma32dd_t))
 
 /* transmit channel control */
-#define	XC_XE		((uint32)1 << 0)	/* transmit enable */
-#define	XC_SE		((uint32)1 << 1)	/* transmit suspend request */
-#define	XC_LE		((uint32)1 << 2)	/* loopback enable */
-#define	XC_FL		((uint32)1 << 4)	/* flush request */
-#define	XC_PD		((uint32)1 << 11)	/* parity check disable */
-#define	XC_AE		((uint32)3 << 16)	/* address extension bits */
+#define	XC_XE		((u32)1 << 0)	/* transmit enable */
+#define	XC_SE		((u32)1 << 1)	/* transmit suspend request */
+#define	XC_LE		((u32)1 << 2)	/* loopback enable */
+#define	XC_FL		((u32)1 << 4)	/* flush request */
+#define	XC_PD		((u32)1 << 11)	/* parity check disable */
+#define	XC_AE		((u32)3 << 16)	/* address extension bits */
 #define	XC_AE_SHIFT	16
 
 /* transmit descriptor table pointer */
@@ -95,14 +95,14 @@ typedef volatile struct {
 #define	XS_AD_SHIFT	20
 
 /* receive channel control */
-#define	RC_RE		((uint32)1 << 0)	/* receive enable */
+#define	RC_RE		((u32)1 << 0)	/* receive enable */
 #define	RC_RO_MASK	0xfe	/* receive frame offset */
 #define	RC_RO_SHIFT	1
-#define	RC_FM		((uint32)1 << 8)	/* direct fifo receive (pio) mode */
-#define	RC_SH		((uint32)1 << 9)	/* separate rx header descriptor enable */
-#define	RC_OC		((uint32)1 << 10)	/* overflow continue */
-#define	RC_PD		((uint32)1 << 11)	/* parity check disable */
-#define	RC_AE		((uint32)3 << 16)	/* address extension bits */
+#define	RC_FM		((u32)1 << 8)	/* direct fifo receive (pio) mode */
+#define	RC_SH		((u32)1 << 9)	/* separate rx header descriptor enable */
+#define	RC_OC		((u32)1 << 10)	/* overflow continue */
+#define	RC_PD		((u32)1 << 11)	/* parity check disable */
+#define	RC_AE		((u32)3 << 16)	/* address extension bits */
 #define	RC_AE_SHIFT	16
 
 /* receive descriptor table pointer */
@@ -143,13 +143,13 @@ typedef volatile struct {
 
 /* descriptor control flags */
 #define	CTRL_BC_MASK	0x00001fff	/* buffer byte count, real data len must <= 4KB */
-#define	CTRL_AE		((uint32)3 << 16)	/* address extension bits */
+#define	CTRL_AE		((u32)3 << 16)	/* address extension bits */
 #define	CTRL_AE_SHIFT	16
-#define	CTRL_PARITY	((uint32)3 << 18)	/* parity bit */
-#define	CTRL_EOT	((uint32)1 << 28)	/* end of descriptor table */
-#define	CTRL_IOC	((uint32)1 << 29)	/* interrupt on completion */
-#define	CTRL_EOF	((uint32)1 << 30)	/* end of frame */
-#define	CTRL_SOF	((uint32)1 << 31)	/* start of frame */
+#define	CTRL_PARITY	((u32)3 << 18)	/* parity bit */
+#define	CTRL_EOT	((u32)1 << 28)	/* end of descriptor table */
+#define	CTRL_IOC	((u32)1 << 29)	/* interrupt on completion */
+#define	CTRL_EOF	((u32)1 << 30)	/* end of frame */
+#define	CTRL_SOF	((u32)1 << 31)	/* start of frame */
 
 /* control flags in the range [27:20] are core-specific and not defined here */
 #define	CTRL_CORE_MASK	0x0ff00000
@@ -158,12 +158,12 @@ typedef volatile struct {
 
 /* dma registers per channel(xmt or rcv) */
 typedef volatile struct {
-	uint32 control;		/* enable, et al */
-	uint32 ptr;		/* last descriptor posted to chip */
-	uint32 addrlow;		/* descriptor ring base address low 32-bits (8K aligned) */
-	uint32 addrhigh;	/* descriptor ring base address bits 63:32 (8K aligned) */
-	uint32 status0;		/* current descriptor, xmt state */
-	uint32 status1;		/* active descriptor, xmt error */
+	u32 control;		/* enable, et al */
+	u32 ptr;		/* last descriptor posted to chip */
+	u32 addrlow;		/* descriptor ring base address low 32-bits (8K aligned) */
+	u32 addrhigh;	/* descriptor ring base address bits 63:32 (8K aligned) */
+	u32 status0;		/* current descriptor, xmt state */
+	u32 status1;		/* active descriptor, xmt error */
 } dma64regs_t;
 
 typedef volatile struct {
@@ -172,10 +172,10 @@ typedef volatile struct {
 } dma64regp_t;
 
 typedef volatile struct {	/* diag access */
-	uint32 fifoaddr;	/* diag address */
-	uint32 fifodatalow;	/* low 32bits of data */
-	uint32 fifodatahigh;	/* high 32bits of data */
-	uint32 pad;		/* reserved */
+	u32 fifoaddr;	/* diag address */
+	u32 fifodatalow;	/* low 32bits of data */
+	u32 fifodatahigh;	/* high 32bits of data */
+	u32 pad;		/* reserved */
 } dma64diag_t;
 
 /*
@@ -183,10 +183,10 @@ typedef volatile struct {	/* diag access
  * Descriptors are only read by the hardware, never written back.
  */
 typedef volatile struct {
-	uint32 ctrl1;		/* misc control bits & bufcount */
-	uint32 ctrl2;		/* buffer count and address extension */
-	uint32 addrlow;		/* memory address of the date buffer, bits 31:0 */
-	uint32 addrhigh;	/* memory address of the date buffer, bits 63:32 */
+	u32 ctrl1;		/* misc control bits & bufcount */
+	u32 ctrl2;		/* buffer count and address extension */
+	u32 addrlow;		/* memory address of the date buffer, bits 31:0 */
+	u32 addrhigh;	/* memory address of the date buffer, bits 63:32 */
 } dma64dd_t;
 
 /*
@@ -287,10 +287,10 @@ typedef volatile struct {
 
 /* descriptor control flags 1 */
 #define D64_CTRL_COREFLAGS	0x0ff00000	/* core specific flags */
-#define	D64_CTRL1_EOT		((uint32)1 << 28)	/* end of descriptor table */
-#define	D64_CTRL1_IOC		((uint32)1 << 29)	/* interrupt on completion */
-#define	D64_CTRL1_EOF		((uint32)1 << 30)	/* end of frame */
-#define	D64_CTRL1_SOF		((uint32)1 << 31)	/* start of frame */
+#define	D64_CTRL1_EOT		((u32)1 << 28)	/* end of descriptor table */
+#define	D64_CTRL1_IOC		((u32)1 << 29)	/* interrupt on completion */
+#define	D64_CTRL1_EOF		((u32)1 << 30)	/* end of frame */
+#define	D64_CTRL1_SOF		((u32)1 << 31)	/* start of frame */
 
 /* descriptor control flags 2 */
 #define	D64_CTRL2_BC_MASK	0x00007fff	/* buffer byte count. real data len must <= 16KB */
--- a/drivers/staging/brcm80211/include/sbhndpio.h
+++ b/drivers/staging/brcm80211/include/sbhndpio.h
@@ -39,8 +39,8 @@ typedef volatile struct {
 
 /* 4byte-wide pio register set per channel(xmt or rcv) */
 typedef volatile struct {
-	uint32 fifocontrol;
-	uint32 fifodata;
+	u32 fifocontrol;
+	u32 fifodata;
 } pio4regs_t;
 
 /* a pair of pio channels(tx and rx) */
--- a/drivers/staging/brcm80211/include/sbsdpcmdev.h
+++ b/drivers/staging/brcm80211/include/sbsdpcmdev.h
@@ -26,38 +26,38 @@
 
 typedef volatile struct {
 	dma64regs_t xmt;	/* dma tx */
-	uint32 PAD[2];
+	u32 PAD[2];
 	dma64regs_t rcv;	/* dma rx */
-	uint32 PAD[2];
+	u32 PAD[2];
 } dma64p_t;
 
 /* dma64 sdiod corerev >= 1 */
 typedef volatile struct {
 	dma64p_t dma64regs[2];
 	dma64diag_t dmafifo;	/* DMA Diagnostic Regs, 0x280-0x28c */
-	uint32 PAD[92];
+	u32 PAD[92];
 } sdiodma64_t;
 
 /* dma32 sdiod corerev == 0 */
 typedef volatile struct {
 	dma32regp_t dma32regs[2];	/* dma tx & rx, 0x200-0x23c */
 	dma32diag_t dmafifo;	/* DMA Diagnostic Regs, 0x240-0x24c */
-	uint32 PAD[108];
+	u32 PAD[108];
 } sdiodma32_t;
 
 /* dma32 regs for pcmcia core */
 typedef volatile struct {
 	dma32regp_t dmaregs;	/* DMA Regs, 0x200-0x21c, rev8 */
 	dma32diag_t dmafifo;	/* DMA Diagnostic Regs, 0x220-0x22c */
-	uint32 PAD[116];
+	u32 PAD[116];
 } pcmdma32_t;
 
 /* core registers */
 typedef volatile struct {
-	uint32 corecontrol;	/* CoreControl, 0x000, rev8 */
-	uint32 corestatus;	/* CoreStatus, 0x004, rev8  */
-	uint32 PAD[1];
-	uint32 biststatus;	/* BistStatus, 0x00c, rev8  */
+	u32 corecontrol;	/* CoreControl, 0x000, rev8 */
+	u32 corestatus;	/* CoreStatus, 0x004, rev8  */
+	u32 PAD[1];
+	u32 biststatus;	/* BistStatus, 0x00c, rev8  */
 
 	/* PCMCIA access */
 	u16 pcmciamesportaladdr;	/* PcmciaMesPortalAddr, 0x010, rev8   */
@@ -70,21 +70,21 @@ typedef volatile struct {
 	u16 PAD[1];
 
 	/* interrupt */
-	uint32 intstatus;	/* IntStatus, 0x020, rev8   */
-	uint32 hostintmask;	/* IntHostMask, 0x024, rev8   */
-	uint32 intmask;		/* IntSbMask, 0x028, rev8   */
-	uint32 sbintstatus;	/* SBIntStatus, 0x02c, rev8   */
-	uint32 sbintmask;	/* SBIntMask, 0x030, rev8   */
-	uint32 funcintmask;	/* SDIO Function Interrupt Mask, SDIO rev4 */
-	uint32 PAD[2];
-	uint32 tosbmailbox;	/* ToSBMailbox, 0x040, rev8   */
-	uint32 tohostmailbox;	/* ToHostMailbox, 0x044, rev8   */
-	uint32 tosbmailboxdata;	/* ToSbMailboxData, 0x048, rev8   */
-	uint32 tohostmailboxdata;	/* ToHostMailboxData, 0x04c, rev8   */
+	u32 intstatus;	/* IntStatus, 0x020, rev8   */
+	u32 hostintmask;	/* IntHostMask, 0x024, rev8   */
+	u32 intmask;		/* IntSbMask, 0x028, rev8   */
+	u32 sbintstatus;	/* SBIntStatus, 0x02c, rev8   */
+	u32 sbintmask;	/* SBIntMask, 0x030, rev8   */
+	u32 funcintmask;	/* SDIO Function Interrupt Mask, SDIO rev4 */
+	u32 PAD[2];
+	u32 tosbmailbox;	/* ToSBMailbox, 0x040, rev8   */
+	u32 tohostmailbox;	/* ToHostMailbox, 0x044, rev8   */
+	u32 tosbmailboxdata;	/* ToSbMailboxData, 0x048, rev8   */
+	u32 tohostmailboxdata;	/* ToHostMailboxData, 0x04c, rev8   */
 
 	/* synchronized access to registers in SDIO clock domain */
-	uint32 sdioaccess;	/* SdioAccess, 0x050, rev8   */
-	uint32 PAD[3];
+	u32 sdioaccess;	/* SdioAccess, 0x050, rev8   */
+	u32 PAD[3];
 
 	/* PCMCIA frame control */
 	u8 pcmciaframectrl;	/* pcmciaFrameCtrl, 0x060, rev8   */
@@ -93,25 +93,25 @@ typedef volatile struct {
 	u8 PAD[155];
 
 	/* interrupt batching control */
-	uint32 intrcvlazy;	/* IntRcvLazy, 0x100, rev8 */
-	uint32 PAD[3];
+	u32 intrcvlazy;	/* IntRcvLazy, 0x100, rev8 */
+	u32 PAD[3];
 
 	/* counters */
-	uint32 cmd52rd;		/* Cmd52RdCount, 0x110, rev8, SDIO: cmd52 reads */
-	uint32 cmd52wr;		/* Cmd52WrCount, 0x114, rev8, SDIO: cmd52 writes */
-	uint32 cmd53rd;		/* Cmd53RdCount, 0x118, rev8, SDIO: cmd53 reads */
-	uint32 cmd53wr;		/* Cmd53WrCount, 0x11c, rev8, SDIO: cmd53 writes */
-	uint32 abort;		/* AbortCount, 0x120, rev8, SDIO: aborts */
-	uint32 datacrcerror;	/* DataCrcErrorCount, 0x124, rev8, SDIO: frames w/bad CRC */
-	uint32 rdoutofsync;	/* RdOutOfSyncCount, 0x128, rev8, SDIO/PCMCIA: Rd Frm OOS */
-	uint32 wroutofsync;	/* RdOutOfSyncCount, 0x12c, rev8, SDIO/PCMCIA: Wr Frm OOS */
-	uint32 writebusy;	/* WriteBusyCount, 0x130, rev8, SDIO: dev asserted "busy" */
-	uint32 readwait;	/* ReadWaitCount, 0x134, rev8, SDIO: read: no data avail */
-	uint32 readterm;	/* ReadTermCount, 0x138, rev8, SDIO: rd frm terminates */
-	uint32 writeterm;	/* WriteTermCount, 0x13c, rev8, SDIO: wr frm terminates */
-	uint32 PAD[40];
-	uint32 clockctlstatus;	/* ClockCtlStatus, 0x1e0, rev8 */
-	uint32 PAD[7];
+	u32 cmd52rd;		/* Cmd52RdCount, 0x110, rev8, SDIO: cmd52 reads */
+	u32 cmd52wr;		/* Cmd52WrCount, 0x114, rev8, SDIO: cmd52 writes */
+	u32 cmd53rd;		/* Cmd53RdCount, 0x118, rev8, SDIO: cmd53 reads */
+	u32 cmd53wr;		/* Cmd53WrCount, 0x11c, rev8, SDIO: cmd53 writes */
+	u32 abort;		/* AbortCount, 0x120, rev8, SDIO: aborts */
+	u32 datacrcerror;	/* DataCrcErrorCount, 0x124, rev8, SDIO: frames w/bad CRC */
+	u32 rdoutofsync;	/* RdOutOfSyncCount, 0x128, rev8, SDIO/PCMCIA: Rd Frm OOS */
+	u32 wroutofsync;	/* RdOutOfSyncCount, 0x12c, rev8, SDIO/PCMCIA: Wr Frm OOS */
+	u32 writebusy;	/* WriteBusyCount, 0x130, rev8, SDIO: dev asserted "busy" */
+	u32 readwait;	/* ReadWaitCount, 0x134, rev8, SDIO: read: no data avail */
+	u32 readterm;	/* ReadTermCount, 0x138, rev8, SDIO: rd frm terminates */
+	u32 writeterm;	/* WriteTermCount, 0x13c, rev8, SDIO: wr frm terminates */
+	u32 PAD[40];
+	u32 clockctlstatus;	/* ClockCtlStatus, 0x1e0, rev8 */
+	u32 PAD[7];
 
 	/* DMA engines */
 	volatile union {
@@ -141,7 +141,7 @@ typedef volatile struct {
 
 	/* sprom "size" & "blank" info */
 	u16 spromstatus;	/* SPROMStatus, 0x7BE, rev2 */
-	uint32 PAD[464];
+	u32 PAD[464];
 
 	/* Sonics SiliconBackplane registers */
 	sbconfig_t sbconfig;	/* SbConfig Regs, 0xf00-0xfff, rev8 */
--- a/drivers/staging/brcm80211/include/sbsocram.h
+++ b/drivers/staging/brcm80211/include/sbsocram.h
@@ -28,34 +28,34 @@
 
 /* Memcsocram core registers */
 typedef volatile struct sbsocramregs {
-	uint32 coreinfo;
-	uint32 bwalloc;
-	uint32 extracoreinfo;
-	uint32 biststat;
-	uint32 bankidx;
-	uint32 standbyctrl;
+	u32 coreinfo;
+	u32 bwalloc;
+	u32 extracoreinfo;
+	u32 biststat;
+	u32 bankidx;
+	u32 standbyctrl;
 
-	uint32 errlogstatus;	/* rev 6 */
-	uint32 errlogaddr;	/* rev 6 */
+	u32 errlogstatus;	/* rev 6 */
+	u32 errlogaddr;	/* rev 6 */
 	/* used for patching rev 3 & 5 */
-	uint32 cambankidx;
-	uint32 cambankstandbyctrl;
-	uint32 cambankpatchctrl;
-	uint32 cambankpatchtblbaseaddr;
-	uint32 cambankcmdreg;
-	uint32 cambankdatareg;
-	uint32 cambankmaskreg;
-	uint32 PAD[1];
-	uint32 bankinfo;	/* corev 8 */
-	uint32 PAD[15];
-	uint32 extmemconfig;
-	uint32 extmemparitycsr;
-	uint32 extmemparityerrdata;
-	uint32 extmemparityerrcnt;
-	uint32 extmemwrctrlandsize;
-	uint32 PAD[84];
-	uint32 workaround;
-	uint32 pwrctl;		/* corerev >= 2 */
+	u32 cambankidx;
+	u32 cambankstandbyctrl;
+	u32 cambankpatchctrl;
+	u32 cambankpatchtblbaseaddr;
+	u32 cambankcmdreg;
+	u32 cambankdatareg;
+	u32 cambankmaskreg;
+	u32 PAD[1];
+	u32 bankinfo;	/* corev 8 */
+	u32 PAD[15];
+	u32 extmemconfig;
+	u32 extmemparitycsr;
+	u32 extmemparityerrdata;
+	u32 extmemparityerrcnt;
+	u32 extmemwrctrlandsize;
+	u32 PAD[84];
+	u32 workaround;
+	u32 pwrctl;		/* corerev >= 2 */
 } sbsocramregs_t;
 
 #endif				/* _LANGUAGE_ASSEMBLY */
--- a/drivers/staging/brcm80211/include/siutils.h
+++ b/drivers/staging/brcm80211/include/siutils.h
@@ -34,10 +34,10 @@ struct si_pub {
 	uint buscorerev;	/* buscore rev */
 	uint buscoreidx;	/* buscore index */
 	int ccrev;		/* chip common core rev */
-	uint32 cccaps;		/* chip common capabilities */
-	uint32 cccaps_ext;	/* chip common capabilities extension */
+	u32 cccaps;		/* chip common capabilities */
+	u32 cccaps_ext;	/* chip common capabilities extension */
 	int pmurev;		/* pmu core rev */
-	uint32 pmucaps;		/* pmu capabilities */
+	u32 pmucaps;		/* pmu capabilities */
 	uint boardtype;		/* board type */
 	uint boardvendor;	/* board vendor */
 	uint boardflags;	/* board flags */
@@ -45,7 +45,7 @@ struct si_pub {
 	uint chip;		/* chip number */
 	uint chiprev;		/* chip revision */
 	uint chippkg;		/* chip package option */
-	uint32 chipst;		/* chip status */
+	u32 chipst;		/* chip status */
 	bool issim;		/* chip is in simulation or emulation */
 	uint socirev;		/* SOC interconnect rev */
 	bool pci_pr32414;
@@ -122,7 +122,7 @@ typedef const struct si_pub si_t;
 #define CCPLL_ENAB(sih)		((sih)->cccaps & CC_CAP_PLL_MASK)
 #endif
 
-typedef void (*gpio_handler_t) (uint32 stat, void *arg);
+typedef void (*gpio_handler_t) (u32 stat, void *arg);
 
 /* External PA enable mask */
 #define GPIO_CTRL_EPA_EN_MASK 0x40
@@ -141,9 +141,9 @@ extern uint si_corerev(si_t *sih);
 extern void *si_osh(si_t *sih);
 extern uint si_corereg(si_t *sih, uint coreidx, uint regoff, uint mask,
 		uint val);
-extern void si_write_wrapperreg(si_t *sih, uint32 offset, uint32 val);
-extern uint32 si_core_cflags(si_t *sih, uint32 mask, uint32 val);
-extern uint32 si_core_sflags(si_t *sih, uint32 mask, uint32 val);
+extern void si_write_wrapperreg(si_t *sih, u32 offset, u32 val);
+extern u32 si_core_cflags(si_t *sih, u32 mask, u32 val);
+extern u32 si_core_sflags(si_t *sih, u32 mask, u32 val);
 extern bool si_iscoreup(si_t *sih);
 extern uint si_findcoreidx(si_t *sih, uint coreid, uint coreunit);
 #ifndef BCMSDIO
@@ -153,10 +153,10 @@ extern void *si_setcore(si_t *sih, uint
 extern void *si_switch_core(si_t *sih, uint coreid, uint *origidx,
 			    uint *intr_val);
 extern void si_restore_core(si_t *sih, uint coreid, uint intr_val);
-extern void si_core_reset(si_t *sih, uint32 bits, uint32 resetbits);
-extern void si_core_disable(si_t *sih, uint32 bits);
-extern uint32 si_alp_clock(si_t *sih);
-extern uint32 si_ilp_clock(si_t *sih);
+extern void si_core_reset(si_t *sih, u32 bits, u32 resetbits);
+extern void si_core_disable(si_t *sih, u32 bits);
+extern u32 si_alp_clock(si_t *sih);
+extern u32 si_ilp_clock(si_t *sih);
 extern void si_pci_setup(si_t *sih, uint coremask);
 extern void si_setint(si_t *sih, int siflag);
 extern bool si_backplane64(si_t *sih);
@@ -169,10 +169,10 @@ extern u16 si_clkctl_fast_pwrup_delay(si
 extern bool si_clkctl_cc(si_t *sih, uint mode);
 extern int si_clkctl_xtal(si_t *sih, uint what, bool on);
 extern bool si_deviceremoved(si_t *sih);
-extern uint32 si_socram_size(si_t *sih);
+extern u32 si_socram_size(si_t *sih);
 
 extern void si_watchdog(si_t *sih, uint ticks);
-extern uint32 si_gpiocontrol(si_t *sih, uint32 mask, uint32 val,
+extern u32 si_gpiocontrol(si_t *sih, u32 mask, u32 val,
 			     u8 priority);
 
 #ifdef BCMSDIO
@@ -212,15 +212,15 @@ extern void si_sprom_init(si_t *sih);
 
 #define	IS_SIM(chippkg)	((chippkg == HDLSIM_PKG_ID) || (chippkg == HWSIM_PKG_ID))
 
-typedef uint32(*si_intrsoff_t) (void *intr_arg);
-typedef void (*si_intrsrestore_t) (void *intr_arg, uint32 arg);
+typedef u32(*si_intrsoff_t) (void *intr_arg);
+typedef void (*si_intrsrestore_t) (void *intr_arg, u32 arg);
 typedef bool(*si_intrsenabled_t) (void *intr_arg);
 
 typedef struct gpioh_item {
 	void *arg;
 	bool level;
 	gpio_handler_t handler;
-	uint32 event;
+	u32 event;
 	struct gpioh_item *next;
 } gpioh_item_t;
 
@@ -250,19 +250,19 @@ typedef struct si_info {
 	uint curidx;		/* current core index */
 	uint numcores;		/* # discovered cores */
 	uint coreid[SI_MAXCORES];	/* id of each core */
-	uint32 coresba[SI_MAXCORES];	/* backplane address of each core */
+	u32 coresba[SI_MAXCORES];	/* backplane address of each core */
 	void *regs2[SI_MAXCORES];	/* va of each core second register set (usbh20) */
-	uint32 coresba2[SI_MAXCORES];	/* address of each core second register set (usbh20) */
-	uint32 coresba_size[SI_MAXCORES];	/* backplane address space size */
-	uint32 coresba2_size[SI_MAXCORES];	/* second address space size */
+	u32 coresba2[SI_MAXCORES];	/* address of each core second register set (usbh20) */
+	u32 coresba_size[SI_MAXCORES];	/* backplane address space size */
+	u32 coresba2_size[SI_MAXCORES];	/* second address space size */
 
 	void *curwrap;		/* current wrapper va */
 	void *wrappers[SI_MAXCORES];	/* other cores wrapper va */
-	uint32 wrapba[SI_MAXCORES];	/* address of controlling wrapper */
+	u32 wrapba[SI_MAXCORES];	/* address of controlling wrapper */
 
-	uint32 cia[SI_MAXCORES];	/* erom cia entry for each core */
-	uint32 cib[SI_MAXCORES];	/* erom cia entry for each core */
-	uint32 oob_router;	/* oob router registers for axi */
+	u32 cia[SI_MAXCORES];	/* erom cia entry for each core */
+	u32 cib[SI_MAXCORES];	/* erom cia entry for each core */
+	u32 oob_router;	/* oob router registers for axi */
 } si_info_t;
 
 #define	SI_INFO(sih)	(si_info_t *)(uintptr)sih
@@ -356,17 +356,17 @@ extern uint ai_corevendor(si_t *sih);
 extern uint ai_corerev(si_t *sih);
 extern bool ai_iscoreup(si_t *sih);
 extern void *ai_setcoreidx(si_t *sih, uint coreidx);
-extern uint32 ai_core_cflags(si_t *sih, uint32 mask, uint32 val);
-extern void ai_core_cflags_wo(si_t *sih, uint32 mask, uint32 val);
-extern uint32 ai_core_sflags(si_t *sih, uint32 mask, uint32 val);
+extern u32 ai_core_cflags(si_t *sih, u32 mask, u32 val);
+extern void ai_core_cflags_wo(si_t *sih, u32 mask, u32 val);
+extern u32 ai_core_sflags(si_t *sih, u32 mask, u32 val);
 extern uint ai_corereg(si_t *sih, uint coreidx, uint regoff, uint mask,
 		       uint val);
-extern void ai_core_reset(si_t *sih, uint32 bits, uint32 resetbits);
-extern void ai_core_disable(si_t *sih, uint32 bits);
+extern void ai_core_reset(si_t *sih, u32 bits, u32 resetbits);
+extern void ai_core_disable(si_t *sih, u32 bits);
 extern int ai_numaddrspaces(si_t *sih);
-extern uint32 ai_addrspace(si_t *sih, uint asidx);
-extern uint32 ai_addrspacesize(si_t *sih, uint asidx);
-extern void ai_write_wrap_reg(si_t *sih, uint32 offset, uint32 val);
+extern u32 ai_addrspace(si_t *sih, uint asidx);
+extern u32 ai_addrspacesize(si_t *sih, uint asidx);
+extern void ai_write_wrap_reg(si_t *sih, u32 offset, u32 val);
 
 #ifdef BCMSDIO
 #define si_setcoreidx(sih, idx) sb_setcoreidx(sih, idx)
--- a/drivers/staging/brcm80211/include/spid.h
+++ b/drivers/staging/brcm80211/include/spid.h
@@ -31,12 +31,12 @@ typedef volatile struct {
 	u8 reset_bp;		/* 0x03, reset on wlan/bt backplane reset (corerev >= 1) */
 	u16 intr_reg;	/* 0x04, Intr status register */
 	u16 intr_en_reg;	/* 0x06, Intr mask register */
-	uint32 status_reg;	/* 0x08, RO, Status bits of last spi transfer */
+	u32 status_reg;	/* 0x08, RO, Status bits of last spi transfer */
 	u16 f1_info_reg;	/* 0x0c, RO, enabled, ready for data transfer, blocksize */
 	u16 f2_info_reg;	/* 0x0e, RO, enabled, ready for data transfer, blocksize */
 	u16 f3_info_reg;	/* 0x10, RO, enabled, ready for data transfer, blocksize */
-	uint32 test_read;	/* 0x14, RO 0xfeedbead signature */
-	uint32 test_rw;		/* 0x18, RW */
+	u32 test_read;	/* 0x14, RO 0xfeedbead signature */
+	u32 test_rw;		/* 0x18, RW */
 	u8 resp_delay_f0;	/* 0x1c, read resp delay bytes for F0 (corerev >= 3) */
 	u8 resp_delay_f1;	/* 0x1d, read resp delay bytes for F1 (corerev >= 3) */
 	u8 resp_delay_f2;	/* 0x1e, read resp delay bytes for F2 (corerev >= 3) */
--- a/drivers/staging/brcm80211/include/typedefs.h
+++ b/drivers/staging/brcm80211/include/typedefs.h
@@ -44,10 +44,6 @@ typedef unsigned int uint;
 
 /* define [u]int32/64, uintptr */
 
-#ifndef TYPEDEF_UINT32
-typedef unsigned int uint32;
-#endif
-
 #ifndef TYPEDEF_UINTPTR
 typedef unsigned int uintptr;
 #endif
@@ -77,7 +73,6 @@ typedef signed int int32;
 #define	AUTO	(-1)		/* Auto = -1 */
 
 #undef TYPEDEF_UINT
-#undef TYPEDEF_UINT32
 #undef TYPEDEF_UINTPTR
 #undef TYPEDEF_INT32
 
--- a/drivers/staging/brcm80211/include/wlioctl.h
+++ b/drivers/staging/brcm80211/include/wlioctl.h
@@ -39,8 +39,8 @@
 #define	LEGACY_WL_BSS_INFO_VERSION	107	/* older version of wl_bss_info struct */
 
 typedef struct wl_bss_info_107 {
-	uint32 version;		/* version field */
-	uint32 length;		/* byte length of data in this record,
+	u32 version;		/* version field */
+	u32 length;		/* byte length of data in this record,
 				 * starting at version and including IEs
 				 */
 	struct ether_addr BSSID;
@@ -57,7 +57,7 @@ typedef struct wl_bss_info_107 {
 	u8 dtim_period;	/* DTIM period */
 	s16 RSSI;		/* receive signal strength (in dBm) */
 	s8 phy_noise;		/* noise (in dBm) */
-	uint32 ie_length;	/* byte length of Information Elements */
+	u32 ie_length;	/* byte length of Information Elements */
 	/* variable length Information Elements */
 } wl_bss_info_107_t;
 
@@ -72,8 +72,8 @@ typedef struct wl_bss_info_107 {
  * next bss_info structure in a vector (in wl_scan_results_t)
  */
 typedef struct wl_bss_info_108 {
-	uint32 version;		/* version field */
-	uint32 length;		/* byte length of data in this record,
+	u32 version;		/* version field */
+	u32 length;		/* byte length of data in this record,
 				 * starting at version and including IEs
 				 */
 	struct ether_addr BSSID;
@@ -92,15 +92,15 @@ typedef struct wl_bss_info_108 {
 	s8 phy_noise;		/* noise (in dBm) */
 
 	u8 n_cap;		/* BSS is 802.11N Capable */
-	uint32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
+	u32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
 	u8 ctl_ch;		/* 802.11N BSS control channel number */
-	uint32 reserved32[1];	/* Reserved for expansion of BSS properties */
+	u32 reserved32[1];	/* Reserved for expansion of BSS properties */
 	u8 flags;		/* flags */
 	u8 reserved[3];	/* Reserved for expansion of BSS properties */
 	u8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
 
 	u16 ie_offset;	/* offset at which IEs start, from beginning */
-	uint32 ie_length;	/* byte length of Information Elements */
+	u32 ie_length;	/* byte length of Information Elements */
 	/* Add new fields here */
 	/* variable length Information Elements */
 } wl_bss_info_108_t;
@@ -116,8 +116,8 @@ typedef struct wl_bss_info_108 {
  * next bss_info structure in a vector (in wl_scan_results_t)
  */
 typedef struct wl_bss_info {
-	uint32 version;		/* version field */
-	uint32 length;		/* byte length of data in this record,
+	u32 version;		/* version field */
+	u32 length;		/* byte length of data in this record,
 				 * starting at version and including IEs
 				 */
 	struct ether_addr BSSID;
@@ -136,22 +136,22 @@ typedef struct wl_bss_info {
 	s8 phy_noise;		/* noise (in dBm) */
 
 	u8 n_cap;		/* BSS is 802.11N Capable */
-	uint32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
+	u32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
 	u8 ctl_ch;		/* 802.11N BSS control channel number */
-	uint32 reserved32[1];	/* Reserved for expansion of BSS properties */
+	u32 reserved32[1];	/* Reserved for expansion of BSS properties */
 	u8 flags;		/* flags */
 	u8 reserved[3];	/* Reserved for expansion of BSS properties */
 	u8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
 
 	u16 ie_offset;	/* offset at which IEs start, from beginning */
-	uint32 ie_length;	/* byte length of Information Elements */
+	u32 ie_length;	/* byte length of Information Elements */
 	s16 SNR;		/* average SNR of during frame reception */
 	/* Add new fields here */
 	/* variable length Information Elements */
 } wl_bss_info_t;
 
 typedef struct wlc_ssid {
-	uint32 SSID_len;
+	u32 SSID_len;
 	unsigned char SSID[32];
 } wlc_ssid_t;
 
@@ -159,8 +159,8 @@ typedef struct chan_scandata {
 	u8 txpower;
 	u8 pad;
 	chanspec_t channel;	/* Channel num, bw, ctrl_sb and band */
-	uint32 channel_mintime;
-	uint32 channel_maxtime;
+	u32 channel_mintime;
+	u32 channel_maxtime;
 } chan_scandata_t;
 
 typedef enum wl_scan_type {
@@ -181,7 +181,7 @@ typedef struct wl_extdscan_params {
 	s8 band;		/* band */
 	s8 pad;
 	wlc_ssid_t ssid[WLC_EXTDSCAN_MAX_SSID];	/* ssid list */
-	uint32 tx_rate;		/* in 500ksec units */
+	u32 tx_rate;		/* in 500ksec units */
 	wl_scan_type_t scan_type;	/* enum */
 	int32 channel_num;
 	chan_scandata_t channel_list[1];	/* list of chandata structs */
@@ -247,7 +247,7 @@ typedef struct wl_scan_params {
 
 /* incremental scan struct */
 typedef struct wl_iscan_params {
-	uint32 version;
+	u32 version;
 	u16 action;
 	u16 scan_duration;
 	wl_scan_params_t params;
@@ -257,9 +257,9 @@ typedef struct wl_iscan_params {
 #define WL_ISCAN_PARAMS_FIXED_SIZE (OFFSETOF(wl_iscan_params_t, params) + sizeof(wlc_ssid_t))
 
 typedef struct wl_scan_results {
-	uint32 buflen;
-	uint32 version;
-	uint32 count;
+	u32 buflen;
+	u32 version;
+	u32 count;
 	wl_bss_info_t bss_info[1];
 } wl_scan_results_t;
 
@@ -276,7 +276,7 @@ typedef struct wl_scan_results {
 #define ESCAN_REQ_VERSION 1
 
 typedef struct wl_escan_params {
-	uint32 version;
+	u32 version;
 	u16 action;
 	u16 sync_id;
 	wl_scan_params_t params;
@@ -285,8 +285,8 @@ typedef struct wl_escan_params {
 #define WL_ESCAN_PARAMS_FIXED_SIZE (OFFSETOF(wl_escan_params_t, params) + sizeof(wlc_ssid_t))
 
 typedef struct wl_escan_result {
-	uint32 buflen;
-	uint32 version;
+	u32 buflen;
+	u32 version;
 	u16 sync_id;
 	u16 bss_count;
 	wl_bss_info_t bss_info[1];
@@ -296,7 +296,7 @@ typedef struct wl_escan_result {
 
 /* incremental scan results struct */
 typedef struct wl_iscan_results {
-	uint32 status;
+	u32 status;
 	wl_scan_results_t results;
 } wl_iscan_results_t;
 
@@ -312,23 +312,23 @@ typedef struct wl_probe_params {
 
 #define WL_NUMRATES		16	/* max # of rates in a rateset */
 typedef struct wl_rateset {
-	uint32 count;		/* # rates in this set */
+	u32 count;		/* # rates in this set */
 	u8 rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
 } wl_rateset_t;
 
 typedef struct wl_rateset_args {
-	uint32 count;		/* # rates in this set */
+	u32 count;		/* # rates in this set */
 	u8 rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
 	u8 mcs[MCSSET_LEN];	/* supported mcs index bit map */
 } wl_rateset_args_t;
 
-/* uint32 list */
-typedef struct wl_uint32_list {
+/* u32 list */
+typedef struct wl_u32_list {
 	/* in - # of elements, out - # of entries */
-	uint32 count;
-	/* variable length uint32 list */
-	uint32 element[1];
-} wl_uint32_list_t;
+	u32 count;
+	/* variable length u32 list */
+	u32 element[1];
+} wl_u32_list_t;
 
 /* used for association with a specific BSSID and chanspec list */
 typedef struct wl_assoc_params {
@@ -415,12 +415,12 @@ typedef struct {
 #define CCA_ERRNO_TOO_FEW	5	/* Only 1 channel was input */
 
 typedef struct {
-	uint32 duration;	/* millisecs spent sampling this channel */
-	uint32 congest_ibss;	/* millisecs in our bss (presumably this traffic will */
+	u32 duration;	/* millisecs spent sampling this channel */
+	u32 congest_ibss;	/* millisecs in our bss (presumably this traffic will */
 	/*  move if cur bss moves channels) */
-	uint32 congest_obss;	/* traffic not in our bss */
-	uint32 interference;	/* millisecs detecting a non 802.11 interferer. */
-	uint32 timestamp;	/* second timestamp */
+	u32 congest_obss;	/* traffic not in our bss */
+	u32 interference;	/* millisecs detecting a non 802.11 interferer. */
+	u32 timestamp;	/* second timestamp */
 } cca_congest_t;
 
 typedef struct {
@@ -447,18 +447,18 @@ typedef struct wl_country {
 } wl_country_t;
 
 typedef struct wl_channels_in_country {
-	uint32 buflen;
-	uint32 band;
+	u32 buflen;
+	u32 band;
 	char country_abbrev[WLC_CNTRY_BUF_SZ];
-	uint32 count;
-	uint32 channel[1];
+	u32 count;
+	u32 channel[1];
 } wl_channels_in_country_t;
 
 typedef struct wl_country_list {
-	uint32 buflen;
-	uint32 band_set;
-	uint32 band;
-	uint32 count;
+	u32 buflen;
+	u32 band_set;
+	u32 band;
+	u32 count;
 	char country_abbrev[1];
 } wl_country_list_t;
 
@@ -477,15 +477,15 @@ typedef struct wl_rm_req_elt {
 	s8 type;
 	s8 flags;
 	chanspec_t chanspec;
-	uint32 token;		/* token for this measurement */
-	uint32 tsf_h;		/* TSF high 32-bits of Measurement start time */
-	uint32 tsf_l;		/* TSF low 32-bits */
-	uint32 dur;		/* TUs */
+	u32 token;		/* token for this measurement */
+	u32 tsf_h;		/* TSF high 32-bits of Measurement start time */
+	u32 tsf_l;		/* TSF low 32-bits */
+	u32 dur;		/* TUs */
 } wl_rm_req_elt_t;
 
 typedef struct wl_rm_req {
-	uint32 token;		/* overall measurement set token */
-	uint32 count;		/* number of measurement requests */
+	u32 token;		/* overall measurement set token */
+	u32 count;		/* number of measurement requests */
 	void *cb;		/* completion callback function: may be NULL */
 	void *cb_arg;		/* arg to completion callback function */
 	wl_rm_req_elt_t req[1];	/* variable length block of requests */
@@ -496,11 +496,11 @@ typedef struct wl_rm_rep_elt {
 	s8 type;
 	s8 flags;
 	chanspec_t chanspec;
-	uint32 token;		/* token for this measurement */
-	uint32 tsf_h;		/* TSF high 32-bits of Measurement start time */
-	uint32 tsf_l;		/* TSF low 32-bits */
-	uint32 dur;		/* TUs */
-	uint32 len;		/* byte length of data block */
+	u32 token;		/* token for this measurement */
+	u32 tsf_h;		/* TSF high 32-bits of Measurement start time */
+	u32 tsf_l;		/* TSF low 32-bits */
+	u32 dur;		/* TUs */
+	u32 len;		/* byte length of data block */
 	u8 data[1];		/* variable length data block */
 } wl_rm_rep_elt_t;
 #define WL_RM_REP_ELT_FIXED_LEN	24	/* length excluding data block */
@@ -512,8 +512,8 @@ typedef struct wl_rm_rpi_rep {
 } wl_rm_rpi_rep_t;
 
 typedef struct wl_rm_rep {
-	uint32 token;		/* overall measurement set token */
-	uint32 len;		/* length of measurement report block */
+	u32 token;		/* overall measurement set token */
+	u32 len;		/* length of measurement report block */
 	wl_rm_rep_elt_t rep[1];	/* variable length block of reports */
 } wl_rm_rep_t;
 #define WL_RM_REP_FIXED_LEN	8
@@ -539,22 +539,22 @@ typedef struct wl_rm_rep {
 #define WL_IBSS_PEER_GROUP_KEY	(1 << 6)	/* Indicates a group key for a IBSS PEER */
 
 typedef struct wl_wsec_key {
-	uint32 index;		/* key index */
-	uint32 len;		/* key length */
+	u32 index;		/* key index */
+	u32 len;		/* key length */
 	u8 data[DOT11_MAX_KEY_SIZE];	/* key data */
-	uint32 pad_1[18];
-	uint32 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
-	uint32 flags;		/* misc flags */
-	uint32 pad_2[2];
+	u32 pad_1[18];
+	u32 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
+	u32 flags;		/* misc flags */
+	u32 pad_2[2];
 	int pad_3;
 	int iv_initialized;	/* has IV been initialized already? */
 	int pad_4;
 	/* Rx IV */
 	struct {
-		uint32 hi;	/* upper 32 bits of IV */
+		u32 hi;	/* upper 32 bits of IV */
 		u16 lo;	/* lower 16 bits of IV */
 	} rxiv;
-	uint32 pad_5[2];
+	u32 pad_5[2];
 	struct ether_addr ea;	/* per station */
 } wl_wsec_key_t;
 
@@ -602,7 +602,7 @@ typedef struct _pmkid {
 } pmkid_t;
 
 typedef struct _pmkid_list {
-	uint32 npmkid;
+	u32 npmkid;
 	pmkid_t pmkid[1];
 } pmkid_list_t;
 
@@ -612,13 +612,13 @@ typedef struct _pmkid_cand {
 } pmkid_cand_t;
 
 typedef struct _pmkid_cand_list {
-	uint32 npmkid_cand;
+	u32 npmkid_cand;
 	pmkid_cand_t pmkid_cand[1];
 } pmkid_cand_list_t;
 
 typedef struct wl_led_info {
-	uint32 index;		/* led index */
-	uint32 behavior;
+	u32 index;		/* led index */
+	u32 behavior;
 	u8 activehi;
 } wl_led_info_t;
 
@@ -634,9 +634,9 @@ typedef struct {
 
 /* similar cis (srom or otp) struct [iovar: may not be aligned] */
 typedef struct {
-	uint32 source;		/* cis source */
-	uint32 byteoff;		/* byte offset */
-	uint32 nbytes;		/* number of bytes */
+	u32 source;		/* cis source */
+	u32 byteoff;		/* byte offset */
+	u32 nbytes;		/* number of bytes */
 	/* data follows here */
 } cis_rw_t;
 
@@ -646,9 +646,9 @@ typedef struct {
 
 /* R_REG and W_REG struct passed through ioctl */
 typedef struct {
-	uint32 byteoff;		/* byte offset of the field in d11regs_t */
-	uint32 val;		/* read/write value of the field */
-	uint32 size;		/* sizeof the field */
+	u32 byteoff;		/* byte offset of the field in d11regs_t */
+	u32 val;		/* read/write value of the field */
+	u32 size;		/* sizeof the field */
 	uint band;		/* band (optional) */
 } rw_reg_t;
 
@@ -704,20 +704,20 @@ typedef struct {
 	u16 ver;		/* version of this struct */
 	u16 len;		/* length in bytes of this structure */
 	u16 cap;		/* sta's advertised capabilities */
-	uint32 flags;		/* flags defined below */
-	uint32 idle;		/* time since data pkt rx'd from sta */
+	u32 flags;		/* flags defined below */
+	u32 idle;		/* time since data pkt rx'd from sta */
 	struct ether_addr ea;	/* Station address */
 	wl_rateset_t rateset;	/* rateset in use */
-	uint32 in;		/* seconds elapsed since associated */
-	uint32 listen_interval_inms;	/* Min Listen interval in ms for this STA */
-	uint32 tx_pkts;		/* # of packets transmitted */
-	uint32 tx_failures;	/* # of packets failed */
-	uint32 rx_ucast_pkts;	/* # of unicast packets received */
-	uint32 rx_mcast_pkts;	/* # of multicast packets received */
-	uint32 tx_rate;		/* Rate of last successful tx frame */
-	uint32 rx_rate;		/* Rate of last successful rx frame */
-	uint32 rx_decrypt_succeeds;	/* # of packet decrypted successfully */
-	uint32 rx_decrypt_failures;	/* # of packet decrypted unsuccessfully */
+	u32 in;		/* seconds elapsed since associated */
+	u32 listen_interval_inms;	/* Min Listen interval in ms for this STA */
+	u32 tx_pkts;		/* # of packets transmitted */
+	u32 tx_failures;	/* # of packets failed */
+	u32 rx_ucast_pkts;	/* # of unicast packets received */
+	u32 rx_mcast_pkts;	/* # of multicast packets received */
+	u32 tx_rate;		/* Rate of last successful tx frame */
+	u32 rx_rate;		/* Rate of last successful rx frame */
+	u32 rx_decrypt_succeeds;	/* # of packet decrypted successfully */
+	u32 rx_decrypt_failures;	/* # of packet decrypted unsuccessfully */
 } sta_info_t;
 
 #define WL_OLD_STAINFO_SIZE	OFFSETOF(sta_info_t, tx_pkts)
@@ -745,7 +745,7 @@ typedef struct {
 
 /* Used to get specific STA parameters */
 typedef struct {
-	uint32 val;
+	u32 val;
 	struct ether_addr ea;
 } scb_val_t;
 
@@ -1208,7 +1208,7 @@ typedef struct wl_po {
 	u16 phy_type;	/* Phy type */
 	u16 band;
 	u16 cckpo;
-	uint32 ofdmpo;
+	u32 ofdmpo;
 	u16 mcspo[8];
 } wl_po_t;
 
@@ -1371,8 +1371,8 @@ typedef struct wl_po {
 
 /* RSSI per antenna */
 typedef struct {
-	uint32 version;		/* version field */
-	uint32 count;		/* number of valid antenna rssi */
+	u32 version;		/* version field */
+	u32 count;		/* number of valid antenna rssi */
 	s8 rssi_ant[WL_RSSI_ANT_MAX];	/* rssi per antenna */
 } wl_rssi_ant_t;
 
@@ -1401,7 +1401,7 @@ typedef struct {
 #define WL_TX_POWER_MCS40_NUM	        17
 
 typedef struct {
-	uint32 flags;
+	u32 flags;
 	chanspec_t chanspec;	/* txpwr report for this channel */
 	chanspec_t local_chanspec;	/* channel on which we are associated */
 	u8 local_max;	/* local max according to the AP */
@@ -1449,7 +1449,7 @@ typedef struct {
 #define WL_TX_POWER_F_SISO	8
 
 typedef struct {
-	uint32 flags;
+	u32 flags;
 	chanspec_t chanspec;	/* txpwr report for this channel */
 	chanspec_t local_chanspec;	/* channel on which we are associated */
 	u8 local_max;	/* local max according to the AP */
@@ -1497,231 +1497,231 @@ typedef struct {
 	u16 length;		/* length of entire structure */
 
 	/* transmit stat counters */
-	uint32 txframe;		/* tx data frames */
-	uint32 txbyte;		/* tx data bytes */
-	uint32 txretrans;	/* tx mac retransmits */
-	uint32 txerror;		/* tx data errors (derived: sum of others) */
-	uint32 txctl;		/* tx management frames */
-	uint32 txprshort;	/* tx short preamble frames */
-	uint32 txserr;		/* tx status errors */
-	uint32 txnobuf;		/* tx out of buffers errors */
-	uint32 txnoassoc;	/* tx discard because we're not associated */
-	uint32 txrunt;		/* tx runt frames */
-	uint32 txchit;		/* tx header cache hit (fastpath) */
-	uint32 txcmiss;		/* tx header cache miss (slowpath) */
-	uint32 ieee_tx_status;	/* calls to ieee80211_tx_status */
-	uint32 ieee_tx;		/* tx calls frm mac0211 */
-	uint32 ieee_rx;		/* calls to ieee_rx */
+	u32 txframe;		/* tx data frames */
+	u32 txbyte;		/* tx data bytes */
+	u32 txretrans;	/* tx mac retransmits */
+	u32 txerror;		/* tx data errors (derived: sum of others) */
+	u32 txctl;		/* tx management frames */
+	u32 txprshort;	/* tx short preamble frames */
+	u32 txserr;		/* tx status errors */
+	u32 txnobuf;		/* tx out of buffers errors */
+	u32 txnoassoc;	/* tx discard because we're not associated */
+	u32 txrunt;		/* tx runt frames */
+	u32 txchit;		/* tx header cache hit (fastpath) */
+	u32 txcmiss;		/* tx header cache miss (slowpath) */
+	u32 ieee_tx_status;	/* calls to ieee80211_tx_status */
+	u32 ieee_tx;		/* tx calls frm mac0211 */
+	u32 ieee_rx;		/* calls to ieee_rx */
 
 	/* transmit chip error counters */
-	uint32 txuflo;		/* tx fifo underflows */
-	uint32 txphyerr;	/* tx phy errors (indicated in tx status) */
-	uint32 txphycrs;
+	u32 txuflo;		/* tx fifo underflows */
+	u32 txphyerr;	/* tx phy errors (indicated in tx status) */
+	u32 txphycrs;
 
 	/* receive stat counters */
-	uint32 rxframe;		/* rx data frames */
-	uint32 rxbyte;		/* rx data bytes */
-	uint32 rxerror;		/* rx data errors (derived: sum of others) */
-	uint32 rxctl;		/* rx management frames */
-	uint32 rxnobuf;		/* rx out of buffers errors */
-	uint32 rxnondata;	/* rx non data frames in the data channel errors */
-	uint32 rxbadds;		/* rx bad DS errors */
-	uint32 rxbadcm;		/* rx bad control or management frames */
-	uint32 rxfragerr;	/* rx fragmentation errors */
-	uint32 rxrunt;		/* rx runt frames */
-	uint32 rxgiant;		/* rx giant frames */
-	uint32 rxnoscb;		/* rx no scb error */
-	uint32 rxbadproto;	/* rx invalid frames */
-	uint32 rxbadsrcmac;	/* rx frames with Invalid Src Mac */
-	uint32 rxbadda;		/* rx frames tossed for invalid da */
-	uint32 rxfilter;	/* rx frames filtered out */
+	u32 rxframe;		/* rx data frames */
+	u32 rxbyte;		/* rx data bytes */
+	u32 rxerror;		/* rx data errors (derived: sum of others) */
+	u32 rxctl;		/* rx management frames */
+	u32 rxnobuf;		/* rx out of buffers errors */
+	u32 rxnondata;	/* rx non data frames in the data channel errors */
+	u32 rxbadds;		/* rx bad DS errors */
+	u32 rxbadcm;		/* rx bad control or management frames */
+	u32 rxfragerr;	/* rx fragmentation errors */
+	u32 rxrunt;		/* rx runt frames */
+	u32 rxgiant;		/* rx giant frames */
+	u32 rxnoscb;		/* rx no scb error */
+	u32 rxbadproto;	/* rx invalid frames */
+	u32 rxbadsrcmac;	/* rx frames with Invalid Src Mac */
+	u32 rxbadda;		/* rx frames tossed for invalid da */
+	u32 rxfilter;	/* rx frames filtered out */
 
 	/* receive chip error counters */
-	uint32 rxoflo;		/* rx fifo overflow errors */
-	uint32 rxuflo[NFIFO];	/* rx dma descriptor underflow errors */
+	u32 rxoflo;		/* rx fifo overflow errors */
+	u32 rxuflo[NFIFO];	/* rx dma descriptor underflow errors */
 
-	uint32 d11cnt_txrts_off;	/* d11cnt txrts value when reset d11cnt */
-	uint32 d11cnt_rxcrc_off;	/* d11cnt rxcrc value when reset d11cnt */
-	uint32 d11cnt_txnocts_off;	/* d11cnt txnocts value when reset d11cnt */
+	u32 d11cnt_txrts_off;	/* d11cnt txrts value when reset d11cnt */
+	u32 d11cnt_rxcrc_off;	/* d11cnt rxcrc value when reset d11cnt */
+	u32 d11cnt_txnocts_off;	/* d11cnt txnocts value when reset d11cnt */
 
 	/* misc counters */
-	uint32 dmade;		/* tx/rx dma descriptor errors */
-	uint32 dmada;		/* tx/rx dma data errors */
-	uint32 dmape;		/* tx/rx dma descriptor protocol errors */
-	uint32 reset;		/* reset count */
-	uint32 tbtt;		/* cnts the TBTT int's */
-	uint32 txdmawar;
-	uint32 pkt_callback_reg_fail;	/* callbacks register failure */
+	u32 dmade;		/* tx/rx dma descriptor errors */
+	u32 dmada;		/* tx/rx dma data errors */
+	u32 dmape;		/* tx/rx dma descriptor protocol errors */
+	u32 reset;		/* reset count */
+	u32 tbtt;		/* cnts the TBTT int's */
+	u32 txdmawar;
+	u32 pkt_callback_reg_fail;	/* callbacks register failure */
 
 	/* MAC counters: 32-bit version of d11.h's macstat_t */
-	uint32 txallfrm;	/* total number of frames sent, incl. Data, ACK, RTS, CTS,
+	u32 txallfrm;	/* total number of frames sent, incl. Data, ACK, RTS, CTS,
 				 * Control Management (includes retransmissions)
 				 */
-	uint32 txrtsfrm;	/* number of RTS sent out by the MAC */
-	uint32 txctsfrm;	/* number of CTS sent out by the MAC */
-	uint32 txackfrm;	/* number of ACK frames sent out */
-	uint32 txdnlfrm;	/* Not used */
-	uint32 txbcnfrm;	/* beacons transmitted */
-	uint32 txfunfl[8];	/* per-fifo tx underflows */
-	uint32 txtplunfl;	/* Template underflows (mac was too slow to transmit ACK/CTS
+	u32 txrtsfrm;	/* number of RTS sent out by the MAC */
+	u32 txctsfrm;	/* number of CTS sent out by the MAC */
+	u32 txackfrm;	/* number of ACK frames sent out */
+	u32 txdnlfrm;	/* Not used */
+	u32 txbcnfrm;	/* beacons transmitted */
+	u32 txfunfl[8];	/* per-fifo tx underflows */
+	u32 txtplunfl;	/* Template underflows (mac was too slow to transmit ACK/CTS
 				 * or BCN)
 				 */
-	uint32 txphyerror;	/* Transmit phy error, type of error is reported in tx-status for
+	u32 txphyerror;	/* Transmit phy error, type of error is reported in tx-status for
 				 * driver enqueued frames
 				 */
-	uint32 rxfrmtoolong;	/* Received frame longer than legal limit (2346 bytes) */
-	uint32 rxfrmtooshrt;	/* Received frame did not contain enough bytes for its frame type */
-	uint32 rxinvmachdr;	/* Either the protocol version != 0 or frame type not
+	u32 rxfrmtoolong;	/* Received frame longer than legal limit (2346 bytes) */
+	u32 rxfrmtooshrt;	/* Received frame did not contain enough bytes for its frame type */
+	u32 rxinvmachdr;	/* Either the protocol version != 0 or frame type not
 				 * data/control/management
 				 */
-	uint32 rxbadfcs;	/* number of frames for which the CRC check failed in the MAC */
-	uint32 rxbadplcp;	/* parity check of the PLCP header failed */
-	uint32 rxcrsglitch;	/* PHY was able to correlate the preamble but not the header */
-	uint32 rxstrt;		/* Number of received frames with a good PLCP
+	u32 rxbadfcs;	/* number of frames for which the CRC check failed in the MAC */
+	u32 rxbadplcp;	/* parity check of the PLCP header failed */
+	u32 rxcrsglitch;	/* PHY was able to correlate the preamble but not the header */
+	u32 rxstrt;		/* Number of received frames with a good PLCP
 				 * (i.e. passing parity check)
 				 */
-	uint32 rxdfrmucastmbss;	/* Number of received DATA frames with good FCS and matching RA */
-	uint32 rxmfrmucastmbss;	/* number of received mgmt frames with good FCS and matching RA */
-	uint32 rxcfrmucast;	/* number of received CNTRL frames with good FCS and matching RA */
-	uint32 rxrtsucast;	/* number of unicast RTS addressed to the MAC (good FCS) */
-	uint32 rxctsucast;	/* number of unicast CTS addressed to the MAC (good FCS) */
-	uint32 rxackucast;	/* number of ucast ACKS received (good FCS) */
-	uint32 rxdfrmocast;	/* number of received DATA frames (good FCS and not matching RA) */
-	uint32 rxmfrmocast;	/* number of received MGMT frames (good FCS and not matching RA) */
-	uint32 rxcfrmocast;	/* number of received CNTRL frame (good FCS and not matching RA) */
-	uint32 rxrtsocast;	/* number of received RTS not addressed to the MAC */
-	uint32 rxctsocast;	/* number of received CTS not addressed to the MAC */
-	uint32 rxdfrmmcast;	/* number of RX Data multicast frames received by the MAC */
-	uint32 rxmfrmmcast;	/* number of RX Management multicast frames received by the MAC */
-	uint32 rxcfrmmcast;	/* number of RX Control multicast frames received by the MAC
+	u32 rxdfrmucastmbss;	/* Number of received DATA frames with good FCS and matching RA */
+	u32 rxmfrmucastmbss;	/* number of received mgmt frames with good FCS and matching RA */
+	u32 rxcfrmucast;	/* number of received CNTRL frames with good FCS and matching RA */
+	u32 rxrtsucast;	/* number of unicast RTS addressed to the MAC (good FCS) */
+	u32 rxctsucast;	/* number of unicast CTS addressed to the MAC (good FCS) */
+	u32 rxackucast;	/* number of ucast ACKS received (good FCS) */
+	u32 rxdfrmocast;	/* number of received DATA frames (good FCS and not matching RA) */
+	u32 rxmfrmocast;	/* number of received MGMT frames (good FCS and not matching RA) */
+	u32 rxcfrmocast;	/* number of received CNTRL frame (good FCS and not matching RA) */
+	u32 rxrtsocast;	/* number of received RTS not addressed to the MAC */
+	u32 rxctsocast;	/* number of received CTS not addressed to the MAC */
+	u32 rxdfrmmcast;	/* number of RX Data multicast frames received by the MAC */
+	u32 rxmfrmmcast;	/* number of RX Management multicast frames received by the MAC */
+	u32 rxcfrmmcast;	/* number of RX Control multicast frames received by the MAC
 				 * (unlikely to see these)
 				 */
-	uint32 rxbeaconmbss;	/* beacons received from member of BSS */
-	uint32 rxdfrmucastobss;	/* number of unicast frames addressed to the MAC from
+	u32 rxbeaconmbss;	/* beacons received from member of BSS */
+	u32 rxdfrmucastobss;	/* number of unicast frames addressed to the MAC from
 				 * other BSS (WDS FRAME)
 				 */
-	uint32 rxbeaconobss;	/* beacons received from other BSS */
-	uint32 rxrsptmout;	/* Number of response timeouts for transmitted frames
+	u32 rxbeaconobss;	/* beacons received from other BSS */
+	u32 rxrsptmout;	/* Number of response timeouts for transmitted frames
 				 * expecting a response
 				 */
-	uint32 bcntxcancl;	/* transmit beacons canceled due to receipt of beacon (IBSS) */
-	uint32 rxf0ovfl;	/* Number of receive fifo 0 overflows */
-	uint32 rxf1ovfl;	/* Number of receive fifo 1 overflows (obsolete) */
-	uint32 rxf2ovfl;	/* Number of receive fifo 2 overflows (obsolete) */
-	uint32 txsfovfl;	/* Number of transmit status fifo overflows (obsolete) */
-	uint32 pmqovfl;		/* Number of PMQ overflows */
-	uint32 rxcgprqfrm;	/* Number of received Probe requests that made it into
+	u32 bcntxcancl;	/* transmit beacons canceled due to receipt of beacon (IBSS) */
+	u32 rxf0ovfl;	/* Number of receive fifo 0 overflows */
+	u32 rxf1ovfl;	/* Number of receive fifo 1 overflows (obsolete) */
+	u32 rxf2ovfl;	/* Number of receive fifo 2 overflows (obsolete) */
+	u32 txsfovfl;	/* Number of transmit status fifo overflows (obsolete) */
+	u32 pmqovfl;		/* Number of PMQ overflows */
+	u32 rxcgprqfrm;	/* Number of received Probe requests that made it into
 				 * the PRQ fifo
 				 */
-	uint32 rxcgprsqovfl;	/* Rx Probe Request Que overflow in the AP */
-	uint32 txcgprsfail;	/* Tx Probe Response Fail. AP sent probe response but did
+	u32 rxcgprsqovfl;	/* Rx Probe Request Que overflow in the AP */
+	u32 txcgprsfail;	/* Tx Probe Response Fail. AP sent probe response but did
 				 * not get ACK
 				 */
-	uint32 txcgprssuc;	/* Tx Probe Response Success (ACK was received) */
-	uint32 prs_timeout;	/* Number of probe requests that were dropped from the PRQ
+	u32 txcgprssuc;	/* Tx Probe Response Success (ACK was received) */
+	u32 prs_timeout;	/* Number of probe requests that were dropped from the PRQ
 				 * fifo because a probe response could not be sent out within
 				 * the time limit defined in M_PRS_MAXTIME
 				 */
-	uint32 rxnack;
-	uint32 frmscons;
-	uint32 txnack;
-	uint32 txglitch_nack;	/* obsolete */
-	uint32 txburst;		/* obsolete */
+	u32 rxnack;
+	u32 frmscons;
+	u32 txnack;
+	u32 txglitch_nack;	/* obsolete */
+	u32 txburst;		/* obsolete */
 
 	/* 802.11 MIB counters, pp. 614 of 802.11 reaff doc. */
-	uint32 txfrag;		/* dot11TransmittedFragmentCount */
-	uint32 txmulti;		/* dot11MulticastTransmittedFrameCount */
-	uint32 txfail;		/* dot11FailedCount */
-	uint32 txretry;		/* dot11RetryCount */
-	uint32 txretrie;	/* dot11MultipleRetryCount */
-	uint32 rxdup;		/* dot11FrameduplicateCount */
-	uint32 txrts;		/* dot11RTSSuccessCount */
-	uint32 txnocts;		/* dot11RTSFailureCount */
-	uint32 txnoack;		/* dot11ACKFailureCount */
-	uint32 rxfrag;		/* dot11ReceivedFragmentCount */
-	uint32 rxmulti;		/* dot11MulticastReceivedFrameCount */
-	uint32 rxcrc;		/* dot11FCSErrorCount */
-	uint32 txfrmsnt;	/* dot11TransmittedFrameCount (bogus MIB?) */
-	uint32 rxundec;		/* dot11WEPUndecryptableCount */
+	u32 txfrag;		/* dot11TransmittedFragmentCount */
+	u32 txmulti;		/* dot11MulticastTransmittedFrameCount */
+	u32 txfail;		/* dot11FailedCount */
+	u32 txretry;		/* dot11RetryCount */
+	u32 txretrie;	/* dot11MultipleRetryCount */
+	u32 rxdup;		/* dot11FrameduplicateCount */
+	u32 txrts;		/* dot11RTSSuccessCount */
+	u32 txnocts;		/* dot11RTSFailureCount */
+	u32 txnoack;		/* dot11ACKFailureCount */
+	u32 rxfrag;		/* dot11ReceivedFragmentCount */
+	u32 rxmulti;		/* dot11MulticastReceivedFrameCount */
+	u32 rxcrc;		/* dot11FCSErrorCount */
+	u32 txfrmsnt;	/* dot11TransmittedFrameCount (bogus MIB?) */
+	u32 rxundec;		/* dot11WEPUndecryptableCount */
 
 	/* WPA2 counters (see rxundec for DecryptFailureCount) */
-	uint32 tkipmicfaill;	/* TKIPLocalMICFailures */
-	uint32 tkipcntrmsr;	/* TKIPCounterMeasuresInvoked */
-	uint32 tkipreplay;	/* TKIPReplays */
-	uint32 ccmpfmterr;	/* CCMPFormatErrors */
-	uint32 ccmpreplay;	/* CCMPReplays */
-	uint32 ccmpundec;	/* CCMPDecryptErrors */
-	uint32 fourwayfail;	/* FourWayHandshakeFailures */
-	uint32 wepundec;	/* dot11WEPUndecryptableCount */
-	uint32 wepicverr;	/* dot11WEPICVErrorCount */
-	uint32 decsuccess;	/* DecryptSuccessCount */
-	uint32 tkipicverr;	/* TKIPICVErrorCount */
-	uint32 wepexcluded;	/* dot11WEPExcludedCount */
+	u32 tkipmicfaill;	/* TKIPLocalMICFailures */
+	u32 tkipcntrmsr;	/* TKIPCounterMeasuresInvoked */
+	u32 tkipreplay;	/* TKIPReplays */
+	u32 ccmpfmterr;	/* CCMPFormatErrors */
+	u32 ccmpreplay;	/* CCMPReplays */
+	u32 ccmpundec;	/* CCMPDecryptErrors */
+	u32 fourwayfail;	/* FourWayHandshakeFailures */
+	u32 wepundec;	/* dot11WEPUndecryptableCount */
+	u32 wepicverr;	/* dot11WEPICVErrorCount */
+	u32 decsuccess;	/* DecryptSuccessCount */
+	u32 tkipicverr;	/* TKIPICVErrorCount */
+	u32 wepexcluded;	/* dot11WEPExcludedCount */
 
-	uint32 rxundec_mcst;	/* dot11WEPUndecryptableCount */
+	u32 rxundec_mcst;	/* dot11WEPUndecryptableCount */
 
 	/* WPA2 counters (see rxundec for DecryptFailureCount) */
-	uint32 tkipmicfaill_mcst;	/* TKIPLocalMICFailures */
-	uint32 tkipcntrmsr_mcst;	/* TKIPCounterMeasuresInvoked */
-	uint32 tkipreplay_mcst;	/* TKIPReplays */
-	uint32 ccmpfmterr_mcst;	/* CCMPFormatErrors */
-	uint32 ccmpreplay_mcst;	/* CCMPReplays */
-	uint32 ccmpundec_mcst;	/* CCMPDecryptErrors */
-	uint32 fourwayfail_mcst;	/* FourWayHandshakeFailures */
-	uint32 wepundec_mcst;	/* dot11WEPUndecryptableCount */
-	uint32 wepicverr_mcst;	/* dot11WEPICVErrorCount */
-	uint32 decsuccess_mcst;	/* DecryptSuccessCount */
-	uint32 tkipicverr_mcst;	/* TKIPICVErrorCount */
-	uint32 wepexcluded_mcst;	/* dot11WEPExcludedCount */
-
-	uint32 txchanrej;	/* Tx frames suppressed due to channel rejection */
-	uint32 txexptime;	/* Tx frames suppressed due to timer expiration */
-	uint32 psmwds;		/* Count PSM watchdogs */
-	uint32 phywatchdog;	/* Count Phy watchdogs (triggered by ucode) */
+	u32 tkipmicfaill_mcst;	/* TKIPLocalMICFailures */
+	u32 tkipcntrmsr_mcst;	/* TKIPCounterMeasuresInvoked */
+	u32 tkipreplay_mcst;	/* TKIPReplays */
+	u32 ccmpfmterr_mcst;	/* CCMPFormatErrors */
+	u32 ccmpreplay_mcst;	/* CCMPReplays */
+	u32 ccmpundec_mcst;	/* CCMPDecryptErrors */
+	u32 fourwayfail_mcst;	/* FourWayHandshakeFailures */
+	u32 wepundec_mcst;	/* dot11WEPUndecryptableCount */
+	u32 wepicverr_mcst;	/* dot11WEPICVErrorCount */
+	u32 decsuccess_mcst;	/* DecryptSuccessCount */
+	u32 tkipicverr_mcst;	/* TKIPICVErrorCount */
+	u32 wepexcluded_mcst;	/* dot11WEPExcludedCount */
+
+	u32 txchanrej;	/* Tx frames suppressed due to channel rejection */
+	u32 txexptime;	/* Tx frames suppressed due to timer expiration */
+	u32 psmwds;		/* Count PSM watchdogs */
+	u32 phywatchdog;	/* Count Phy watchdogs (triggered by ucode) */
 
 	/* MBSS counters, AP only */
-	uint32 prq_entries_handled;	/* PRQ entries read in */
-	uint32 prq_undirected_entries;	/*    which were bcast bss & ssid */
-	uint32 prq_bad_entries;	/*    which could not be translated to info */
-	uint32 atim_suppress_count;	/* TX suppressions on ATIM fifo */
-	uint32 bcn_template_not_ready;	/* Template marked in use on send bcn ... */
-	uint32 bcn_template_not_ready_done;	/* ...but "DMA done" interrupt rcvd */
-	uint32 late_tbtt_dpc;	/* TBTT DPC did not happen in time */
+	u32 prq_entries_handled;	/* PRQ entries read in */
+	u32 prq_undirected_entries;	/*    which were bcast bss & ssid */
+	u32 prq_bad_entries;	/*    which could not be translated to info */
+	u32 atim_suppress_count;	/* TX suppressions on ATIM fifo */
+	u32 bcn_template_not_ready;	/* Template marked in use on send bcn ... */
+	u32 bcn_template_not_ready_done;	/* ...but "DMA done" interrupt rcvd */
+	u32 late_tbtt_dpc;	/* TBTT DPC did not happen in time */
 
 	/* per-rate receive stat counters */
-	uint32 rx1mbps;		/* packets rx at 1Mbps */
-	uint32 rx2mbps;		/* packets rx at 2Mbps */
-	uint32 rx5mbps5;	/* packets rx at 5.5Mbps */
-	uint32 rx6mbps;		/* packets rx at 6Mbps */
-	uint32 rx9mbps;		/* packets rx at 9Mbps */
-	uint32 rx11mbps;	/* packets rx at 11Mbps */
-	uint32 rx12mbps;	/* packets rx at 12Mbps */
-	uint32 rx18mbps;	/* packets rx at 18Mbps */
-	uint32 rx24mbps;	/* packets rx at 24Mbps */
-	uint32 rx36mbps;	/* packets rx at 36Mbps */
-	uint32 rx48mbps;	/* packets rx at 48Mbps */
-	uint32 rx54mbps;	/* packets rx at 54Mbps */
-	uint32 rx108mbps;	/* packets rx at 108mbps */
-	uint32 rx162mbps;	/* packets rx at 162mbps */
-	uint32 rx216mbps;	/* packets rx at 216 mbps */
-	uint32 rx270mbps;	/* packets rx at 270 mbps */
-	uint32 rx324mbps;	/* packets rx at 324 mbps */
-	uint32 rx378mbps;	/* packets rx at 378 mbps */
-	uint32 rx432mbps;	/* packets rx at 432 mbps */
-	uint32 rx486mbps;	/* packets rx at 486 mbps */
-	uint32 rx540mbps;	/* packets rx at 540 mbps */
+	u32 rx1mbps;		/* packets rx at 1Mbps */
+	u32 rx2mbps;		/* packets rx at 2Mbps */
+	u32 rx5mbps5;	/* packets rx at 5.5Mbps */
+	u32 rx6mbps;		/* packets rx at 6Mbps */
+	u32 rx9mbps;		/* packets rx at 9Mbps */
+	u32 rx11mbps;	/* packets rx at 11Mbps */
+	u32 rx12mbps;	/* packets rx at 12Mbps */
+	u32 rx18mbps;	/* packets rx at 18Mbps */
+	u32 rx24mbps;	/* packets rx at 24Mbps */
+	u32 rx36mbps;	/* packets rx at 36Mbps */
+	u32 rx48mbps;	/* packets rx at 48Mbps */
+	u32 rx54mbps;	/* packets rx at 54Mbps */
+	u32 rx108mbps;	/* packets rx at 108mbps */
+	u32 rx162mbps;	/* packets rx at 162mbps */
+	u32 rx216mbps;	/* packets rx at 216 mbps */
+	u32 rx270mbps;	/* packets rx at 270 mbps */
+	u32 rx324mbps;	/* packets rx at 324 mbps */
+	u32 rx378mbps;	/* packets rx at 378 mbps */
+	u32 rx432mbps;	/* packets rx at 432 mbps */
+	u32 rx486mbps;	/* packets rx at 486 mbps */
+	u32 rx540mbps;	/* packets rx at 540 mbps */
 
 	/* pkteng rx frame stats */
-	uint32 pktengrxducast;	/* unicast frames rxed by the pkteng code */
-	uint32 pktengrxdmcast;	/* multicast frames rxed by the pkteng code */
+	u32 pktengrxducast;	/* unicast frames rxed by the pkteng code */
+	u32 pktengrxdmcast;	/* multicast frames rxed by the pkteng code */
 
-	uint32 rfdisable;	/* count of radio disables */
-	uint32 bphy_rxcrsglitch;	/* PHY count of bphy glitches */
+	u32 rfdisable;	/* count of radio disables */
+	u32 bphy_rxcrsglitch;	/* PHY count of bphy glitches */
 
-	uint32 txmpdu_sgi;	/* count for sgi transmit */
-	uint32 rxmpdu_sgi;	/* count for sgi received */
-	uint32 txmpdu_stbc;	/* count for stbc transmit */
-	uint32 rxmpdu_stbc;	/* count for stbc received */
+	u32 txmpdu_sgi;	/* count for sgi transmit */
+	u32 rxmpdu_sgi;	/* count for sgi received */
+	u32 txmpdu_stbc;	/* count for stbc transmit */
+	u32 rxmpdu_stbc;	/* count for stbc received */
 } wl_cnt_t;
 
 #define	WL_DELTA_STATS_T_VERSION	1	/* current version of wl_delta_stats_t struct */
@@ -1731,44 +1731,44 @@ typedef struct {
 	u16 length;		/* length of entire structure */
 
 	/* transmit stat counters */
-	uint32 txframe;		/* tx data frames */
-	uint32 txbyte;		/* tx data bytes */
-	uint32 txretrans;	/* tx mac retransmits */
-	uint32 txfail;		/* tx failures */
+	u32 txframe;		/* tx data frames */
+	u32 txbyte;		/* tx data bytes */
+	u32 txretrans;	/* tx mac retransmits */
+	u32 txfail;		/* tx failures */
 
 	/* receive stat counters */
-	uint32 rxframe;		/* rx data frames */
-	uint32 rxbyte;		/* rx data bytes */
+	u32 rxframe;		/* rx data frames */
+	u32 rxbyte;		/* rx data bytes */
 
 	/* per-rate receive stat counters */
-	uint32 rx1mbps;		/* packets rx at 1Mbps */
-	uint32 rx2mbps;		/* packets rx at 2Mbps */
-	uint32 rx5mbps5;	/* packets rx at 5.5Mbps */
-	uint32 rx6mbps;		/* packets rx at 6Mbps */
-	uint32 rx9mbps;		/* packets rx at 9Mbps */
-	uint32 rx11mbps;	/* packets rx at 11Mbps */
-	uint32 rx12mbps;	/* packets rx at 12Mbps */
-	uint32 rx18mbps;	/* packets rx at 18Mbps */
-	uint32 rx24mbps;	/* packets rx at 24Mbps */
-	uint32 rx36mbps;	/* packets rx at 36Mbps */
-	uint32 rx48mbps;	/* packets rx at 48Mbps */
-	uint32 rx54mbps;	/* packets rx at 54Mbps */
-	uint32 rx108mbps;	/* packets rx at 108mbps */
-	uint32 rx162mbps;	/* packets rx at 162mbps */
-	uint32 rx216mbps;	/* packets rx at 216 mbps */
-	uint32 rx270mbps;	/* packets rx at 270 mbps */
-	uint32 rx324mbps;	/* packets rx at 324 mbps */
-	uint32 rx378mbps;	/* packets rx at 378 mbps */
-	uint32 rx432mbps;	/* packets rx at 432 mbps */
-	uint32 rx486mbps;	/* packets rx at 486 mbps */
-	uint32 rx540mbps;	/* packets rx at 540 mbps */
+	u32 rx1mbps;		/* packets rx at 1Mbps */
+	u32 rx2mbps;		/* packets rx at 2Mbps */
+	u32 rx5mbps5;	/* packets rx at 5.5Mbps */
+	u32 rx6mbps;		/* packets rx at 6Mbps */
+	u32 rx9mbps;		/* packets rx at 9Mbps */
+	u32 rx11mbps;	/* packets rx at 11Mbps */
+	u32 rx12mbps;	/* packets rx at 12Mbps */
+	u32 rx18mbps;	/* packets rx at 18Mbps */
+	u32 rx24mbps;	/* packets rx at 24Mbps */
+	u32 rx36mbps;	/* packets rx at 36Mbps */
+	u32 rx48mbps;	/* packets rx at 48Mbps */
+	u32 rx54mbps;	/* packets rx at 54Mbps */
+	u32 rx108mbps;	/* packets rx at 108mbps */
+	u32 rx162mbps;	/* packets rx at 162mbps */
+	u32 rx216mbps;	/* packets rx at 216 mbps */
+	u32 rx270mbps;	/* packets rx at 270 mbps */
+	u32 rx324mbps;	/* packets rx at 324 mbps */
+	u32 rx378mbps;	/* packets rx at 378 mbps */
+	u32 rx432mbps;	/* packets rx at 432 mbps */
+	u32 rx486mbps;	/* packets rx at 486 mbps */
+	u32 rx540mbps;	/* packets rx at 540 mbps */
 } wl_delta_stats_t;
 
 #define WL_WME_CNT_VERSION	1	/* current version of wl_wme_cnt_t */
 
 typedef struct {
-	uint32 packets;
-	uint32 bytes;
+	u32 packets;
+	u32 bytes;
 } wl_traffic_stats_t;
 
 typedef struct {
@@ -1787,8 +1787,8 @@ typedef struct {
 } wl_wme_cnt_t;
 
 struct wl_msglevel2 {
-	uint32 low;
-	uint32 high;
+	u32 low;
+	u32 high;
 };
 
 #ifdef WLBA
@@ -1801,34 +1801,34 @@ typedef struct wlc_ba_cnt {
 	u16 length;		/* length of entire structure */
 
 	/* transmit stat counters */
-	uint32 txpdu;		/* pdus sent */
-	uint32 txsdu;		/* sdus sent */
-	uint32 txfc;		/* tx side flow controlled packets */
-	uint32 txfci;		/* tx side flow control initiated */
-	uint32 txretrans;	/* retransmitted pdus */
-	uint32 txbatimer;	/* ba resend due to timer */
-	uint32 txdrop;		/* dropped packets */
-	uint32 txaddbareq;	/* addba req sent */
-	uint32 txaddbaresp;	/* addba resp sent */
-	uint32 txdelba;		/* delba sent */
-	uint32 txba;		/* ba sent */
-	uint32 txbar;		/* bar sent */
-	uint32 txpad[4];	/* future */
+	u32 txpdu;		/* pdus sent */
+	u32 txsdu;		/* sdus sent */
+	u32 txfc;		/* tx side flow controlled packets */
+	u32 txfci;		/* tx side flow control initiated */
+	u32 txretrans;	/* retransmitted pdus */
+	u32 txbatimer;	/* ba resend due to timer */
+	u32 txdrop;		/* dropped packets */
+	u32 txaddbareq;	/* addba req sent */
+	u32 txaddbaresp;	/* addba resp sent */
+	u32 txdelba;		/* delba sent */
+	u32 txba;		/* ba sent */
+	u32 txbar;		/* bar sent */
+	u32 txpad[4];	/* future */
 
 	/* receive side counters */
-	uint32 rxpdu;		/* pdus recd */
-	uint32 rxqed;		/* pdus buffered before sending up */
-	uint32 rxdup;		/* duplicate pdus */
-	uint32 rxnobuf;		/* pdus discarded due to no buf */
-	uint32 rxaddbareq;	/* addba req recd */
-	uint32 rxaddbaresp;	/* addba resp recd */
-	uint32 rxdelba;		/* delba recd */
-	uint32 rxba;		/* ba recd */
-	uint32 rxbar;		/* bar recd */
-	uint32 rxinvba;		/* invalid ba recd */
-	uint32 rxbaholes;	/* ba recd with holes */
-	uint32 rxunexp;		/* unexpected packets */
-	uint32 rxpad[4];	/* future */
+	u32 rxpdu;		/* pdus recd */
+	u32 rxqed;		/* pdus buffered before sending up */
+	u32 rxdup;		/* duplicate pdus */
+	u32 rxnobuf;		/* pdus discarded due to no buf */
+	u32 rxaddbareq;	/* addba req recd */
+	u32 rxaddbaresp;	/* addba resp recd */
+	u32 rxdelba;		/* delba recd */
+	u32 rxba;		/* ba recd */
+	u32 rxbar;		/* bar recd */
+	u32 rxinvba;		/* invalid ba recd */
+	u32 rxbaholes;	/* ba recd with holes */
+	u32 rxunexp;		/* unexpected packets */
+	u32 rxpad[4];	/* future */
 } wlc_ba_cnt_t;
 #endif				/* WLBA */
 
@@ -1889,7 +1889,7 @@ typedef struct tspec_per_sta_arg {
 
 /* structure for max bandwidth for each access category */
 typedef struct wme_max_bandwidth {
-	uint32 ac[AC_COUNT];	/* max bandwidth for each access category */
+	u32 ac[AC_COUNT];	/* max bandwidth for each access category */
 } wme_max_bandwidth_t;
 
 #define WL_WME_MBW_PARAMS_IO_BYTES (sizeof(wme_max_bandwidth_t))
@@ -1930,10 +1930,10 @@ typedef enum wl_pkt_filter_type {
  * that indicates which bits within the pattern should be matched.
  */
 typedef struct wl_pkt_filter_pattern {
-	uint32 offset;		/* Offset within received packet to start pattern matching.
+	u32 offset;		/* Offset within received packet to start pattern matching.
 				 * Offset '0' is the first byte of the ethernet header.
 				 */
-	uint32 size_bytes;	/* Size of the pattern.  Bitmask must be the same size. */
+	u32 size_bytes;	/* Size of the pattern.  Bitmask must be the same size. */
 	u8 mask_and_pattern[1];	/* Variable length mask and pattern data.  mask starts
 					 * at offset 0.  Pattern immediately follows mask.
 					 */
@@ -1941,9 +1941,9 @@ typedef struct wl_pkt_filter_pattern {
 
 /* IOVAR "pkt_filter_add" parameter. Used to install packet filters. */
 typedef struct wl_pkt_filter {
-	uint32 id;		/* Unique filter id, specified by app. */
-	uint32 type;		/* Filter type (WL_PKT_FILTER_TYPE_xxx). */
-	uint32 negate_match;	/* Negate the result of filter matches */
+	u32 id;		/* Unique filter id, specified by app. */
+	u32 type;		/* Filter type (WL_PKT_FILTER_TYPE_xxx). */
+	u32 negate_match;	/* Negate the result of filter matches */
 	union {			/* Filter definitions */
 		wl_pkt_filter_pattern_t pattern;	/* Pattern matching filter */
 	} u;
@@ -1954,13 +1954,13 @@ typedef struct wl_pkt_filter {
 
 /* IOVAR "pkt_filter_enable" parameter. */
 typedef struct wl_pkt_filter_enable {
-	uint32 id;		/* Unique filter id */
-	uint32 enable;		/* Enable/disable bool */
+	u32 id;		/* Unique filter id */
+	u32 enable;		/* Enable/disable bool */
 } wl_pkt_filter_enable_t;
 
 /* IOVAR "pkt_filter_list" parameter. Used to retrieve a list of installed filters. */
 typedef struct wl_pkt_filter_list {
-	uint32 num;		/* Number of installed packet filters */
+	u32 num;		/* Number of installed packet filters */
 	wl_pkt_filter_t filter[1];	/* Variable array of packet filters. */
 } wl_pkt_filter_list_t;
 
@@ -1968,16 +1968,16 @@ typedef struct wl_pkt_filter_list {
 
 /* IOVAR "pkt_filter_stats" parameter. Used to retrieve debug statistics. */
 typedef struct wl_pkt_filter_stats {
-	uint32 num_pkts_matched;	/* # filter matches for specified filter id */
-	uint32 num_pkts_forwarded;	/* # packets fwded from dongle to host for all filters */
-	uint32 num_pkts_discarded;	/* # packets discarded by dongle for all filters */
+	u32 num_pkts_matched;	/* # filter matches for specified filter id */
+	u32 num_pkts_forwarded;	/* # packets fwded from dongle to host for all filters */
+	u32 num_pkts_discarded;	/* # packets discarded by dongle for all filters */
 } wl_pkt_filter_stats_t;
 
 typedef struct wl_pkteng {
-	uint32 flags;
-	uint32 delay;		/* Inter-packet delay */
-	uint32 nframes;		/* Number of frames */
-	uint32 length;		/* Packet length */
+	u32 flags;
+	u32 delay;		/* Inter-packet delay */
+	u32 nframes;		/* Number of frames */
+	u32 length;		/* Packet length */
 	u8 seqno;		/* Enable/disable sequence no. */
 	struct ether_addr dest;	/* Destination address */
 	struct ether_addr src;	/* Source address */
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -30,7 +30,7 @@
 #include <wlc_phy_radio.h>
 #include <wlc_phy_lcn.h>
 
-uint32 phyhal_msg_level = PHYHAL_ERROR;
+u32 phyhal_msg_level = PHYHAL_ERROR;
 
 typedef struct _chan_info_basic {
 	u16 chan;
@@ -126,10 +126,10 @@ const u8 ofdm_rate_lookup[] = {
 #define PHY_WREG_LIMIT	24
 
 static void wlc_set_phy_uninitted(phy_info_t *pi);
-static uint32 wlc_phy_get_radio_ver(phy_info_t *pi);
+static u32 wlc_phy_get_radio_ver(phy_info_t *pi);
 static void wlc_phy_timercb_phycal(void *arg);
 
-static bool wlc_phy_noise_calc_phy(phy_info_t *pi, uint32 *cmplx_pwr,
+static bool wlc_phy_noise_calc_phy(phy_info_t *pi, u32 *cmplx_pwr,
 				   s8 *pwr_ant);
 
 static void wlc_phy_cal_perical_mphase_schedule(phy_info_t *pi, uint delay);
@@ -142,8 +142,8 @@ static void wlc_phy_txpower_reg_limit_ca
 static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t *pi);
 
 static s8 wlc_user_txpwr_antport_to_rfport(phy_info_t *pi, uint chan,
-					     uint32 band, u8 rate);
-static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t *pi, uint32 band);
+					     u32 band, u8 rate);
+static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t *pi, u32 band);
 static s8 wlc_phy_env_measure_vbat(phy_info_t *pi);
 static s8 wlc_phy_env_measure_temperature(phy_info_t *pi);
 
@@ -304,31 +304,31 @@ void write_radio_reg(phy_info_t *pi, u16
 	}
 }
 
-static uint32 read_radio_id(phy_info_t *pi)
+static u32 read_radio_id(phy_info_t *pi)
 {
-	uint32 id;
+	u32 id;
 
 	if (NORADIO_ENAB(pi->pubpi))
 		return NORADIO_IDCODE;
 
 	if (D11REV_GE(pi->sh->corerev, 24)) {
-		uint32 b0, b1, b2;
+		u32 b0, b1, b2;
 
 		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 0);
 #ifdef __mips__
 		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
 #endif
-		b0 = (uint32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
+		b0 = (u32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
 		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 1);
 #ifdef __mips__
 		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
 #endif
-		b1 = (uint32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
+		b1 = (u32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
 		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 2);
 #ifdef __mips__
 		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
 #endif
-		b2 = (uint32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
+		b2 = (u32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
 
 		id = ((b0 & 0xf) << 28) | (((b2 << 8) | b1) << 12) | ((b0 >> 4)
 								      & 0xf);
@@ -337,8 +337,8 @@ static uint32 read_radio_id(phy_info_t *
 #ifdef __mips__
 		(void)R_REG(pi->sh->osh, &pi->regs->phy4waddr);
 #endif
-		id = (uint32) R_REG(pi->sh->osh, &pi->regs->phy4wdatalo);
-		id |= (uint32) R_REG(pi->sh->osh, &pi->regs->phy4wdatahi) << 16;
+		id = (u32) R_REG(pi->sh->osh, &pi->regs->phy4wdatalo);
+		id |= (u32) R_REG(pi->sh->osh, &pi->regs->phy4wdatahi) << 16;
 	}
 	pi->phy_wreg = 0;
 	return id;
@@ -396,7 +396,7 @@ void write_phy_channel_reg(phy_info_t *p
 #if defined(BCMDBG)
 static bool wlc_phy_war41476(phy_info_t *pi)
 {
-	uint32 mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);
+	u32 mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);
 
 	return ((mc & MCTL_EN_MAC) == 0)
 	    || ((mc & MCTL_PHYLOCK) == MCTL_PHYLOCK);
@@ -439,7 +439,7 @@ void write_phy_reg(phy_info_t *pi, u16 a
 	if (addr == 0x72)
 		(void)R_REG(osh, &regs->phyregdata);
 #else
-	W_REG(osh, (volatile uint32 *)(uintptr) (&regs->phyregaddr),
+	W_REG(osh, (volatile u32 *)(uintptr) (&regs->phyregaddr),
 	      addr | (val << 16));
 	if (BUSTYPE(pi->sh->bustype) == PCI_BUS) {
 		if (++pi->phy_wreg >= pi->phy_wreg_limit) {
@@ -607,7 +607,7 @@ void BCMATTACHFN(wlc_phy_shared_detach)
 wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (shared_phy_t *sh, void *regs,
 					int bandtype, char *vars) {
 	phy_info_t *pi;
-	uint32 sflags = 0;
+	u32 sflags = 0;
 	uint phyversion;
 	int i;
 	osl_t *osh;
@@ -686,7 +686,7 @@ wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (
 		pi->pubpi.radioid = NORADIO_ID;
 		pi->pubpi.radiorev = 5;
 	} else {
-		uint32 idcode;
+		u32 idcode;
 
 		wlc_phy_anacore((wlc_phy_t *) pi, ON);
 
@@ -833,7 +833,7 @@ bool wlc_phy_get_encore(wlc_phy_t *pih)
 	return pi->pubpi.abgphy_encore;
 }
 
-uint32 wlc_phy_get_coreflags(wlc_phy_t *pih)
+u32 wlc_phy_get_coreflags(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	return pi->pubpi.coreflags;
@@ -899,11 +899,11 @@ void wlc_phy_anacore(wlc_phy_t *pih, boo
 	}
 }
 
-uint32 wlc_phy_clk_bwbits(wlc_phy_t *pih)
+u32 wlc_phy_clk_bwbits(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
-	uint32 phy_bw_clkbits = 0;
+	u32 phy_bw_clkbits = 0;
 
 	if (pi && (ISNPHY(pi) || ISLCNPHY(pi))) {
 		switch (pi->bw) {
@@ -973,7 +973,7 @@ void wlc_phy_hw_state_upd(wlc_phy_t *pih
 
 void WLBANDINITFN(wlc_phy_init) (wlc_phy_t *pih, chanspec_t chanspec)
 {
-	uint32 mc;
+	u32 mc;
 	initfn_t phy_init = NULL;
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -1064,9 +1064,9 @@ int BCMUNINITFN(wlc_phy_down) (wlc_phy_t
 	return callbacks;
 }
 
-static uint32 wlc_phy_get_radio_ver(phy_info_t *pi)
+static u32 wlc_phy_get_radio_ver(phy_info_t *pi)
 {
-	uint32 ver;
+	u32 ver;
 
 	ver = read_radio_id(pi);
 
@@ -1091,7 +1091,7 @@ wlc_phy_table_addr(phy_info_t *pi, uint
 	}
 }
 
-void wlc_phy_table_data_write(phy_info_t *pi, uint width, uint32 val)
+void wlc_phy_table_data_write(phy_info_t *pi, uint width, u32 val)
 {
 	ASSERT((width == 8) || (width == 16) || (width == 32));
 
@@ -1126,7 +1126,7 @@ wlc_phy_write_table(phy_info_t *pi, cons
 	uint tbl_width = ptbl_info->tbl_width;
 	const u8 *ptbl_8b = (const u8 *)ptbl_info->tbl_ptr;
 	const u16 *ptbl_16b = (const u16 *)ptbl_info->tbl_ptr;
-	const uint32 *ptbl_32b = (const uint32 *)ptbl_info->tbl_ptr;
+	const u32 *ptbl_32b = (const u32 *)ptbl_info->tbl_ptr;
 
 	ASSERT((tbl_width == 8) || (tbl_width == 16) || (tbl_width == 32));
 
@@ -1169,7 +1169,7 @@ wlc_phy_read_table(phy_info_t *pi, const
 	uint tbl_width = ptbl_info->tbl_width;
 	u8 *ptbl_8b = (u8 *) (uintptr) ptbl_info->tbl_ptr;
 	u16 *ptbl_16b = (u16 *) (uintptr) ptbl_info->tbl_ptr;
-	uint32 *ptbl_32b = (uint32 *) (uintptr) ptbl_info->tbl_ptr;
+	u32 *ptbl_32b = (u32 *) (uintptr) ptbl_info->tbl_ptr;
 
 	ASSERT((tbl_width == 8) || (tbl_width == 16) || (tbl_width == 32));
 
@@ -1264,11 +1264,11 @@ void wlc_phy_do_dummy_tx(phy_info_t *pi,
 		0x6e, 0x84, 0x0b, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00,
 		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
 	};
-	uint32 *dummypkt;
+	u32 *dummypkt;
 
 	ASSERT((R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) == 0);
 
-	dummypkt = (uint32 *) (ofdm ? ofdmpkt : cckpkt);
+	dummypkt = (u32 *) (ofdm ? ofdmpkt : cckpkt);
 	wlapi_bmac_write_template_ram(pi->sh->physhim, 0, DUMMY_PKT_LEN,
 				      dummypkt);
 
@@ -1783,7 +1783,7 @@ wlc_phy_txpower_sromlimit_max_get(wlc_ph
 
 void
 wlc_phy_txpower_boardlimit_band(wlc_phy_t *ppi, uint bandunit, int32 *max_pwr,
-				int32 *min_pwr, uint32 *step_pwr)
+				int32 *min_pwr, u32 *step_pwr)
 {
 	return;
 }
@@ -1813,7 +1813,7 @@ void wlc_phy_txpower_recalc_target(phy_i
 	u8 max_num_rate;
 	u8 start_rate = 0;
 	chanspec_t chspec;
-	uint32 band = CHSPEC2WLC_BAND(pi->radio_chanspec);
+	u32 band = CHSPEC2WLC_BAND(pi->radio_chanspec);
 	initfn_t txpwr_recalc_fn = NULL;
 
 	chspec = pi->radio_chanspec;
@@ -1826,7 +1826,7 @@ void wlc_phy_txpower_recalc_target(phy_i
 
 	pactrl = 0;
 	if (ISLCNPHY(pi)) {
-		uint32 offset_mcs, i;
+		u32 offset_mcs, i;
 
 		if (CHSPEC_IS40(pi->radio_chanspec)) {
 			offset_mcs = pi->mcs40_po;
@@ -2080,7 +2080,7 @@ void wlc_phy_txpwr_percent_set(wlc_phy_t
 	pi->txpwr_percent = txpwr_percent;
 }
 
-void wlc_phy_machwcap_set(wlc_phy_t *ppi, uint32 machwcap)
+void wlc_phy_machwcap_set(wlc_phy_t *ppi, u32 machwcap)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
@@ -2270,14 +2270,14 @@ void wlc_phy_txpower_ipa_upd(phy_info_t
 	}
 }
 
-static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t *pi);
+static u32 wlc_phy_txpower_est_power_nphy(phy_info_t *pi);
 
-static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t *pi)
+static u32 wlc_phy_txpower_est_power_nphy(phy_info_t *pi)
 {
 	s16 tx0_status, tx1_status;
 	u16 estPower1, estPower2;
 	u8 pwr0, pwr1, adj_pwr0, adj_pwr1;
-	uint32 est_pwr;
+	u32 est_pwr;
 
 	estPower1 = read_phy_reg(pi, 0x118);
 	estPower2 = read_phy_reg(pi, 0x119);
@@ -2317,7 +2317,7 @@ static uint32 wlc_phy_txpower_est_power_
 	}
 
 	est_pwr =
-	    (uint32) ((pwr0 << 24) | (pwr1 << 16) | (adj_pwr0 << 8) | adj_pwr1);
+	    (u32) ((pwr0 << 24) | (pwr1 << 16) | (adj_pwr0 << 8) | adj_pwr1);
 	return est_pwr;
 }
 
@@ -2360,7 +2360,7 @@ wlc_phy_txpower_get_current(wlc_phy_t *p
 	}
 
 	if (ISNPHY(pi)) {
-		uint32 est_pout;
+		u32 est_pout;
 
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
 		wlc_phyreg_enter((wlc_phy_t *) pi);
@@ -2504,7 +2504,7 @@ void wlc_phy_ant_rxdiv_set(wlc_phy_t *pp
 }
 
 static bool
-wlc_phy_noise_calc_phy(phy_info_t *pi, uint32 *cmplx_pwr, s8 *pwr_ant)
+wlc_phy_noise_calc_phy(phy_info_t *pi, u32 *cmplx_pwr, s8 *pwr_ant)
 {
 	s8 cmplx_pwr_dbm[PHY_CORE_MAX];
 	u8 i;
@@ -2616,7 +2616,7 @@ wlc_phy_noise_sample_request(wlc_phy_t *
 			       MCMD_BG_NOISE);
 		} else {
 			phy_iq_est_t est[PHY_CORE_MAX];
-			uint32 cmplx_pwr[PHY_CORE_MAX];
+			u32 cmplx_pwr[PHY_CORE_MAX];
 			s8 noise_dbm_ant[PHY_CORE_MAX];
 			u16 log_num_samps, num_samps, classif_state = 0;
 			u8 wait_time = 32;
@@ -2698,10 +2698,10 @@ static void wlc_phy_noise_cb(phy_info_t
 
 static s8 wlc_phy_noise_read_shmem(phy_info_t *pi)
 {
-	uint32 cmplx_pwr[PHY_CORE_MAX];
+	u32 cmplx_pwr[PHY_CORE_MAX];
 	s8 noise_dbm_ant[PHY_CORE_MAX];
 	u16 lo, hi;
-	uint32 cmplx_pwr_tot = 0;
+	u32 cmplx_pwr_tot = 0;
 	s8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
 	u8 idx, core;
 
@@ -2746,7 +2746,7 @@ void wlc_phy_noise_sample_intr(wlc_phy_t
 	s8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
 
 	if (ISLCNPHY(pi)) {
-		uint32 cmplx_pwr, cmplx_pwr0, cmplx_pwr1;
+		u32 cmplx_pwr, cmplx_pwr0, cmplx_pwr1;
 		u16 lo, hi;
 		int32 pwr_offset_dB, gain_dB;
 		u16 status_0, status_1;
@@ -2836,10 +2836,10 @@ s8 lcnphy_gain_index_offset_for_pkt_rssi
 	0
 };
 
-void wlc_phy_compute_dB(uint32 *cmplx_pwr, s8 *p_cmplx_pwr_dB, u8 core)
+void wlc_phy_compute_dB(u32 *cmplx_pwr, s8 *p_cmplx_pwr_dB, u8 core)
 {
 	u8 shift_ct, lsb, msb, secondmsb, i;
-	uint32 tmp;
+	u32 tmp;
 
 	for (i = 0; i < core; i++) {
 		tmp = cmplx_pwr[i];
@@ -3021,7 +3021,7 @@ void wlc_phy_BSSinit(wlc_phy_t *pih, boo
 }
 
 void
-wlc_phy_papd_decode_epsilon(uint32 epsilon, int32 *eps_real, int32 *eps_imag)
+wlc_phy_papd_decode_epsilon(u32 epsilon, int32 *eps_real, int32 *eps_imag)
 {
 	*eps_imag = (epsilon >> 13);
 	if (*eps_imag > 0xfff)
@@ -3219,9 +3219,9 @@ u8 wlc_phy_nbits(int32 value)
 	return nbits;
 }
 
-uint32 wlc_phy_sqrt_int(uint32 value)
+u32 wlc_phy_sqrt_int(u32 value)
 {
-	uint32 root = 0, shift = 0;
+	u32 root = 0, shift = 0;
 
 	for (shift = 0; shift < 32; shift += 2) {
 		if (((0x40000000 >> shift) + root) <= value) {
@@ -3363,7 +3363,7 @@ void wlc_lcnphy_epa_switch(phy_info_t *p
 }
 
 static s8
-wlc_user_txpwr_antport_to_rfport(phy_info_t *pi, uint chan, uint32 band,
+wlc_user_txpwr_antport_to_rfport(phy_info_t *pi, uint chan, u32 band,
 				 u8 rate)
 {
 	s8 offset = 0;
@@ -3389,7 +3389,7 @@ static s8 wlc_phy_env_measure_temperatur
 		return 0;
 }
 
-static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t *pi, uint32 band)
+static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t *pi, u32 band)
 {
 	u8 i;
 	s8 temp, vbat;
@@ -3414,9 +3414,9 @@ wlc_phy_get_pwrdet_offsets(phy_info_t *p
 	*ofdmoffset = 0;
 }
 
-uint32 wlc_phy_qdiv_roundup(uint32 dividend, uint32 divisor, u8 precision)
+u32 wlc_phy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
 {
-	uint32 quotient, remainder, roundup, rbit;
+	u32 quotient, remainder, roundup, rbit;
 
 	ASSERT(divisor);
 
--- a/drivers/staging/brcm80211/phy/wlc_phy_hal.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_hal.h
@@ -147,8 +147,8 @@ typedef struct shared_phy_params {
 	uint boardtype;
 	uint boardrev;
 	uint boardvendor;
-	uint32 boardflags;
-	uint32 boardflags2;
+	u32 boardflags;
+	u32 boardflags2;
 } shared_phy_params_t;
 
 #ifdef WLC_LOW
@@ -163,14 +163,14 @@ extern bool wlc_phy_get_phyversion(wlc_p
 				   u16 *phyrev, u16 *radioid,
 				   u16 *radiover);
 extern bool wlc_phy_get_encore(wlc_phy_t *pih);
-extern uint32 wlc_phy_get_coreflags(wlc_phy_t *pih);
+extern u32 wlc_phy_get_coreflags(wlc_phy_t *pih);
 
 extern void wlc_phy_hw_clk_state_upd(wlc_phy_t *ppi, bool newstate);
 extern void wlc_phy_hw_state_upd(wlc_phy_t *ppi, bool newstate);
 extern void wlc_phy_init(wlc_phy_t *ppi, chanspec_t chanspec);
 extern void wlc_phy_watchdog(wlc_phy_t *ppi);
 extern int wlc_phy_down(wlc_phy_t *ppi);
-extern uint32 wlc_phy_clk_bwbits(wlc_phy_t *pih);
+extern u32 wlc_phy_clk_bwbits(wlc_phy_t *pih);
 extern void wlc_phy_cal_init(wlc_phy_t *ppi);
 extern void wlc_phy_antsel_init(wlc_phy_t *ppi, bool lut_init);
 
@@ -205,7 +205,7 @@ extern void wlc_phy_txpower_sromlimit(wl
 extern void wlc_phy_txpower_sromlimit_max_get(wlc_phy_t *ppi, uint chan,
 					      u8 *_max_, u8 *_min_);
 extern void wlc_phy_txpower_boardlimit_band(wlc_phy_t *ppi, uint band, int32 *,
-					    int32 *, uint32 *);
+					    int32 *, u32 *);
 extern void wlc_phy_txpower_limit_set(wlc_phy_t *ppi, struct txpwr_limits *,
 				      chanspec_t chanspec);
 extern int wlc_phy_txpower_get(wlc_phy_t *ppi, uint *qdbm, bool *override);
@@ -248,7 +248,7 @@ extern bool wlc_phy_test_ison(wlc_phy_t
 extern void wlc_phy_txpwr_percent_set(wlc_phy_t *ppi, u8 txpwr_percent);
 extern void wlc_phy_ofdm_rateset_war(wlc_phy_t *pih, bool war);
 extern void wlc_phy_bf_preempt_enable(wlc_phy_t *pih, bool bf_preempt);
-extern void wlc_phy_machwcap_set(wlc_phy_t *ppi, uint32 machwcap);
+extern void wlc_phy_machwcap_set(wlc_phy_t *ppi, u32 machwcap);
 
 extern void wlc_phy_runbist_config(wlc_phy_t *ppi, bool start_end);
 
--- a/drivers/staging/brcm80211/phy/wlc_phy_int.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_int.h
@@ -27,7 +27,7 @@
 #define PHYHAL_TRACE	0x0002
 #define PHYHAL_INFORM	0x0004
 
-extern uint32 phyhal_msg_level;
+extern u32 phyhal_msg_level;
 
 #define PHY_INFORM_ON()		(phyhal_msg_level & PHYHAL_INFORM)
 #define PHY_THERMAL_ON()	(phyhal_msg_level & PHYHAL_THERMAL)
@@ -292,10 +292,10 @@ typedef struct _phy_table_info {
 
 typedef struct phytbl_info {
 	const void *tbl_ptr;
-	uint32 tbl_len;
-	uint32 tbl_id;
-	uint32 tbl_offset;
-	uint32 tbl_width;
+	u32 tbl_len;
+	u32 tbl_id;
+	u32 tbl_offset;
+	u32 tbl_width;
 } phytbl_info_t;
 
 typedef struct {
@@ -485,8 +485,8 @@ typedef struct _nphy_txgains {
 typedef struct _nphy_noisevar_buf {
 	int bufcount;
 	int tone_id[PHY_NOISEVAR_BUFSIZE];
-	uint32 noise_vars[PHY_NOISEVAR_BUFSIZE];
-	uint32 min_noise_vars[PHY_NOISEVAR_BUFSIZE];
+	u32 noise_vars[PHY_NOISEVAR_BUFSIZE];
+	u32 min_noise_vars[PHY_NOISEVAR_BUFSIZE];
 } phy_noisevar_buf_t;
 
 typedef struct {
@@ -510,7 +510,7 @@ typedef struct {
 	u16 txiqlocal_bestcoeffs[11];
 	u16 txiqlocal_bestcoeffs_valid;
 
-	uint32 papd_eps_tbl[PHY_PAPD_EPS_TBL_SIZE_LCNPHY];
+	u32 papd_eps_tbl[PHY_PAPD_EPS_TBL_SIZE_LCNPHY];
 	u16 analog_gain_ref;
 	u16 lut_begin;
 	u16 lut_end;
@@ -530,7 +530,7 @@ struct shared_phy {
 	si_t *sih;
 	void *physhim;
 	uint corerev;
-	uint32 machwcap;
+	u32 machwcap;
 	bool up;
 	bool clk;
 	uint now;
@@ -543,8 +543,8 @@ struct shared_phy {
 	uint boardtype;
 	uint boardrev;
 	uint boardvendor;
-	uint32 boardflags;
-	uint32 boardflags2;
+	u32 boardflags;
+	u32 boardflags2;
 	uint bustype;
 	uint buscorerev;
 	uint fast_timer;
@@ -688,8 +688,8 @@ struct phy_info {
 
 	bool edcrs_threshold_lock;
 
-	uint32 tr_R_gain_val;
-	uint32 tr_T_gain_val;
+	u32 tr_R_gain_val;
+	u32 tr_T_gain_val;
 
 	s16 ofdm_analog_filt_bw_override;
 	s16 cck_analog_filt_bw_override;
@@ -701,11 +701,11 @@ struct phy_info {
 	u16 crsglitch_prev;
 	bool interference_mode_crs;
 
-	uint32 phy_tx_tone_freq;
+	u32 phy_tx_tone_freq;
 	uint phy_lastcal;
 	bool phy_forcecal;
 	bool phy_fixed_noise;
-	uint32 xtalfreq;
+	u32 xtalfreq;
 	u8 pdiv;
 	s8 carrier_suppr_disable;
 
@@ -781,16 +781,16 @@ struct phy_info {
 
 	bool nphy_tableloaded;
 	s8 nphy_rssisel;
-	uint32 nphy_bb_mult_save;
+	u32 nphy_bb_mult_save;
 	u16 nphy_txiqlocal_bestc[11];
 	bool nphy_txiqlocal_coeffsvalid;
 	phy_txpwrindex_t nphy_txpwrindex[PHY_CORE_NUM_2];
 	phy_pwrctrl_t nphy_pwrctrl_info[PHY_CORE_NUM_2];
 	u16 cck2gpo;
-	uint32 ofdm2gpo;
-	uint32 ofdm5gpo;
-	uint32 ofdm5glpo;
-	uint32 ofdm5ghpo;
+	u32 ofdm2gpo;
+	u32 ofdm5gpo;
+	u32 ofdm5glpo;
+	u32 ofdm5ghpo;
 	u8 bw402gpo;
 	u8 bw405gpo;
 	u8 bw405glpo;
@@ -811,7 +811,7 @@ struct phy_info {
 	u16 mcs5gpo[8];
 	u16 mcs5glpo[8];
 	u16 mcs5ghpo[8];
-	uint32 nphy_rxcalparams;
+	u32 nphy_rxcalparams;
 
 	u8 phy_spuravoid;
 	bool phy_isspuravoid;
@@ -863,7 +863,7 @@ struct phy_info {
 	u8 nphy_papd_cal_gain_index[2];
 	s16 nphy_papd_epsilon_offset[2];
 	bool nphy_papd_recal_enable;
-	uint32 nphy_papd_recal_counter;
+	u32 nphy_papd_recal_counter;
 	bool nphy_force_papd_cal;
 	bool nphy_papdcomp;
 	bool ipa2g_on;
@@ -935,8 +935,8 @@ struct phy_info {
 	s8 txpwrindex[PHY_CORE_MAX];
 
 	u8 phycal_tempdelta;
-	uint32 mcs20_po;
-	uint32 mcs40_po;
+	u32 mcs20_po;
+	u32 mcs40_po;
 };
 
 typedef int32 fixed;
@@ -948,8 +948,8 @@ typedef struct _cint32 {
 
 typedef struct radio_regs {
 	u16 address;
-	uint32 init_a;
-	uint32 init_g;
+	u32 init_a;
+	u32 init_g;
 	u8 do_init_a;
 	u8 do_init_g;
 } radio_regs_t;
@@ -1018,15 +1018,15 @@ extern void wlc_phy_write_table(phy_info
 extern void wlc_phy_table_addr(phy_info_t *pi, uint tbl_id, uint tbl_offset,
 			       u16 tblAddr, u16 tblDataHi,
 			       u16 tblDataLo);
-extern void wlc_phy_table_data_write(phy_info_t *pi, uint width, uint32 val);
+extern void wlc_phy_table_data_write(phy_info_t *pi, uint width, u32 val);
 
 extern void write_phy_channel_reg(phy_info_t *pi, uint val);
 extern void wlc_phy_txpower_update_shm(phy_info_t *pi);
 
 extern void wlc_phy_cordic(fixed theta, cint32 *val);
 extern u8 wlc_phy_nbits(int32 value);
-extern uint32 wlc_phy_sqrt_int(uint32 value);
-extern void wlc_phy_compute_dB(uint32 *cmplx_pwr, s8 *p_dB, u8 core);
+extern u32 wlc_phy_sqrt_int(u32 value);
+extern void wlc_phy_compute_dB(u32 *cmplx_pwr, s8 *p_dB, u8 core);
 
 extern uint wlc_phy_init_radio_regs_allbands(phy_info_t *pi,
 					     radio_20xx_regs_t *radioregs);
@@ -1036,7 +1036,7 @@ extern uint wlc_phy_init_radio_regs(phy_
 extern void wlc_phy_txpower_ipa_upd(phy_info_t *pi);
 
 extern void wlc_phy_do_dummy_tx(phy_info_t *pi, bool ofdm, bool pa_on);
-extern void wlc_phy_papd_decode_epsilon(uint32 epsilon, int32 *eps_real,
+extern void wlc_phy_papd_decode_epsilon(u32 epsilon, int32 *eps_real,
 					int32 *eps_imag);
 
 extern void wlc_phy_cal_perical_mphase_reset(phy_info_t *pi);
@@ -1094,7 +1094,7 @@ extern void wlc_lcnphy_epa_switch(phy_in
 extern void wlc_2064_vco_cal(phy_info_t *pi);
 
 extern void wlc_phy_txpower_recalc_target(phy_info_t *pi);
-extern uint32 wlc_phy_qdiv_roundup(uint32 dividend, uint32 divisor,
+extern u32 wlc_phy_qdiv_roundup(u32 dividend, u32 divisor,
 				   u8 precision);
 
 #define LCNPHY_TBL_ID_PAPDCOMPDELTATBL	0x18
@@ -1133,8 +1133,8 @@ extern int32 wlc_lcnphy_rx_signal_power(
 
 typedef struct _phy_iq_est {
 	int32 iq_prod;
-	uint32 i_pwr;
-	uint32 q_pwr;
+	u32 i_pwr;
+	u32 q_pwr;
 } phy_iq_est_t;
 
 extern void wlc_phy_stay_in_carriersearch_nphy(phy_info_t *pi, bool enable);
@@ -1148,10 +1148,10 @@ extern void wlc_nphy_deaf_mode(phy_info_
 	0x72, 0x74, 0x73)
 #define wlc_nphy_table_data_write(pi, w, v)	wlc_phy_table_data_write((pi), (w), (v))
 
-extern void wlc_phy_table_read_nphy(phy_info_t *pi, uint32, uint32 l, uint32 o,
-				    uint32 w, void *d);
-extern void wlc_phy_table_write_nphy(phy_info_t *pi, uint32, uint32, uint32,
-				     uint32, const void *);
+extern void wlc_phy_table_read_nphy(phy_info_t *pi, u32, u32 l, u32 o,
+				    u32 w, void *d);
+extern void wlc_phy_table_write_nphy(phy_info_t *pi, u32, u32, u32,
+				     u32, const void *);
 
 #define	PHY_IPA(pi) \
 	((pi->ipa2g_on && CHSPEC_IS2G(pi->radio_chanspec)) || \
@@ -1206,7 +1206,7 @@ extern void wlc_phy_rssi_cal_nphy(phy_in
 extern int wlc_phy_aci_scan_nphy(phy_info_t *pi);
 extern void wlc_phy_cal_txgainctrl_nphy(phy_info_t *pi, int32 dBm_targetpower,
 					bool debug);
-extern int wlc_phy_tx_tone_nphy(phy_info_t *pi, uint32 f_kHz, u16 max_val,
+extern int wlc_phy_tx_tone_nphy(phy_info_t *pi, u32 f_kHz, u16 max_val,
 				u8 mode, u8, bool);
 extern void wlc_phy_stopplayback_nphy(phy_info_t *pi);
 extern void wlc_phy_est_tonepwr_nphy(phy_info_t *pi, int32 *qdBm_pwrbuf,
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -180,9 +180,9 @@ typedef struct {
 } lcnphy_unsign16_struct;
 
 typedef struct {
-	uint32 iq_prod;
-	uint32 i_pwr;
-	uint32 q_pwr;
+	u32 iq_prod;
+	u32 i_pwr;
+	u32 q_pwr;
 } lcnphy_iq_est_t;
 
 typedef struct {
@@ -423,7 +423,7 @@ lcnphy_rx_iqcomp_t lcnphy_rx_iqcomp_tabl
 	{216, 0, 0},
 };
 
-static const uint32 lcnphy_23bitgaincode_table[] = {
+static const u32 lcnphy_23bitgaincode_table[] = {
 	0x200100,
 	0x200200,
 	0x200004,
@@ -545,7 +545,7 @@ static const s8 lcnphy_gain_index_offset
 };
 
 extern const u8 spur_tbl_rev0[];
-extern const uint32 dot11lcnphytbl_rx_gain_info_sz_rev1;
+extern const u32 dot11lcnphytbl_rx_gain_info_sz_rev1;
 extern const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev1[];
 extern const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa;
 extern const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa_p250;
@@ -976,7 +976,7 @@ u16
 #define FIXED_TXPWR 78
 #define LCNPHY_TEMPSENSE(val) ((s16)((val > 255) ? (val - 512) : val))
 
-static uint32 wlc_lcnphy_qdiv_roundup(uint32 divident, uint32 divisor,
+static u32 wlc_lcnphy_qdiv_roundup(u32 divident, u32 divisor,
 				      u8 precision);
 static void wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t *pi,
 						   u16 ext_lna, u16 trsw,
@@ -1002,7 +1002,7 @@ static void wlc_lcnphy_afe_clk_init(phy_
 extern void wlc_lcnphy_tx_pwr_ctrl_init(wlc_phy_t *ppi);
 extern void wlc_lcnphy_pktengtx(wlc_phy_t *ppi, wl_pkteng_t *pkteng,
 				u8 rate, struct ether_addr *sa,
-				uint32 wait_delay);
+				u32 wait_delay);
 static void wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t *pi,
 						    u8 channel);
 
@@ -1048,9 +1048,9 @@ void wlc_lcnphy_read_table(phy_info_t *p
 }
 
 static void
-wlc_lcnphy_common_read_table(phy_info_t *pi, uint32 tbl_id,
-			     const void *tbl_ptr, uint32 tbl_len,
-			     uint32 tbl_width, uint32 tbl_offset)
+wlc_lcnphy_common_read_table(phy_info_t *pi, u32 tbl_id,
+			     const void *tbl_ptr, u32 tbl_len,
+			     u32 tbl_width, u32 tbl_offset)
 {
 	phytbl_info_t tab;
 	tab.tbl_id = tbl_id;
@@ -1062,9 +1062,9 @@ wlc_lcnphy_common_read_table(phy_info_t
 }
 
 static void
-wlc_lcnphy_common_write_table(phy_info_t *pi, uint32 tbl_id,
-			      const void *tbl_ptr, uint32 tbl_len,
-			      uint32 tbl_width, uint32 tbl_offset)
+wlc_lcnphy_common_write_table(phy_info_t *pi, u32 tbl_id,
+			      const void *tbl_ptr, u32 tbl_len,
+			      u32 tbl_width, u32 tbl_offset)
 {
 
 	phytbl_info_t tab;
@@ -1076,10 +1076,10 @@ wlc_lcnphy_common_write_table(phy_info_t
 	wlc_lcnphy_write_table(pi, &tab);
 }
 
-static uint32
-wlc_lcnphy_qdiv_roundup(uint32 dividend, uint32 divisor, u8 precision)
+static u32
+wlc_lcnphy_qdiv_roundup(u32 dividend, u32 divisor, u8 precision)
 {
-	uint32 quotient, remainder, roundup, rbit;
+	u32 quotient, remainder, roundup, rbit;
 
 	ASSERT(divisor);
 
@@ -1140,7 +1140,7 @@ s8 wlc_lcnphy_get_current_tx_pwr_idx(phy
 	return index;
 }
 
-static uint32 wlc_lcnphy_measure_digital_power(phy_info_t *pi, u16 nsamples)
+static u32 wlc_lcnphy_measure_digital_power(phy_info_t *pi, u16 nsamples)
 {
 	lcnphy_iq_est_t iq_est = { 0, 0, 0 };
 
@@ -1327,7 +1327,7 @@ static void wlc_lcnphy_set_bbmult(phy_in
 
 static void wlc_lcnphy_clear_tx_power_offsets(phy_info_t *pi)
 {
-	uint32 data_buf[64];
+	u32 data_buf[64];
 	phytbl_info_t tab;
 
 	bzero(data_buf, sizeof(data_buf));
@@ -1461,7 +1461,7 @@ static void wlc_lcnphy_pwrctrl_rssiparam
 static void wlc_lcnphy_tssi_setup(phy_info_t *pi)
 {
 	phytbl_info_t tab;
-	uint32 rfseq, ind;
+	u32 rfseq, ind;
 
 	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
 	tab.tbl_width = 32;
@@ -1615,7 +1615,7 @@ static void wlc_lcnphy_txpower_reset_npt
 void wlc_lcnphy_txpower_recalc_target(phy_info_t *pi)
 {
 	phytbl_info_t tab;
-	uint32 rate_table[WLC_NUM_RATES_CCK + WLC_NUM_RATES_OFDM +
+	u32 rate_table[WLC_NUM_RATES_CCK + WLC_NUM_RATES_OFDM +
 			  WLC_NUM_RATES_MCS_1_STREAM];
 	uint i, j;
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi))
@@ -1626,7 +1626,7 @@ void wlc_lcnphy_txpower_recalc_target(ph
 		if (i == WLC_NUM_RATES_CCK + WLC_NUM_RATES_OFDM)
 			j = TXP_FIRST_MCS_20_SISO;
 
-		rate_table[i] = (uint32) ((int32) (-pi->tx_power_offset[j]));
+		rate_table[i] = (u32) ((int32) (-pi->tx_power_offset[j]));
 	}
 
 	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
@@ -1645,8 +1645,8 @@ void wlc_lcnphy_txpower_recalc_target(ph
 
 static void wlc_lcnphy_set_tx_pwr_soft_ctrl(phy_info_t *pi, s8 index)
 {
-	uint32 cck_offset[4] = { 22, 22, 22, 22 };
-	uint32 ofdm_offset, reg_offset_cck;
+	u32 cck_offset[4] = { 22, 22, 22, 22 };
+	u32 ofdm_offset, reg_offset_cck;
 	int i;
 	u16 index2;
 	phytbl_info_t tab;
@@ -1733,8 +1733,8 @@ static s8 wlc_lcnphy_tempcompensated_txp
 		temp_diff = -temp_diff;
 	}
 
-	delta_temp = (s8) wlc_lcnphy_qdiv_roundup((uint32) (temp_diff * 192),
-						    (uint32) (pi_lcn->
+	delta_temp = (s8) wlc_lcnphy_qdiv_roundup((u32) (temp_diff * 192),
+						    (u32) (pi_lcn->
 							      lcnphy_tempsense_slope
 							      * 10), 0);
 	if (neg)
@@ -2155,7 +2155,7 @@ static void wlc_lcnphy_vbat_temp_sense_s
 	u8 auxpga_vmidcourse, auxpga_vmidfine, auxpga_gain;
 	u16 auxpga_vmid;
 	phytbl_info_t tab;
-	uint32 val;
+	u32 val;
 	u8 save_reg007, save_reg0FF, save_reg11F, save_reg005, save_reg025,
 	    save_reg112;
 	u16 values_to_save[14];
@@ -2455,7 +2455,7 @@ void wlc_lcnphy_set_tx_pwr_by_index(phy_
 	phytbl_info_t tab;
 	u16 a, b;
 	u8 bb_mult;
-	uint32 bbmultiqcomp, txgain, locoeffs, rfpower;
+	u32 bbmultiqcomp, txgain, locoeffs, rfpower;
 	lcnphy_txgains_t gains;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -2523,9 +2523,9 @@ static void wlc_lcnphy_set_trsw_override
 
 static void wlc_lcnphy_clear_papd_comptable(phy_info_t *pi)
 {
-	uint32 j;
+	u32 j;
 	phytbl_info_t tab;
-	uint32 temp_offset[128];
+	u32 temp_offset[128];
 	tab.tbl_ptr = temp_offset;
 	tab.tbl_len = 128;
 	tab.tbl_id = LCNPHY_TBL_ID_PAPDCOMPDELTATBL;
@@ -2734,10 +2734,10 @@ wlc_lcnphy_start_tx_tone(phy_info_t *pi,
 {
 	u8 phy_bw;
 	u16 num_samps, t, k;
-	uint32 bw;
+	u32 bw;
 	fixed theta = 0, rot = 0;
 	cint32 tone_samp;
-	uint32 data_buf[64];
+	u32 data_buf[64];
 	u16 i_samp, q_samp;
 	phytbl_info_t tab;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -2761,7 +2761,7 @@ wlc_lcnphy_start_tx_tone(phy_info_t *pi,
 			num_samps = bw / ABS(f_kHz);
 			ASSERT(num_samps <= ARRAYSIZE(data_buf));
 			k++;
-		} while ((num_samps * (uint32) (ABS(f_kHz))) != bw);
+		} while ((num_samps * (u32) (ABS(f_kHz))) != bw);
 	} else
 		num_samps = 2;
 
@@ -2868,7 +2868,7 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal
 	u8 save_bb_mult;
 	u16 a, b, didq, save_pa_gain = 0;
 	uint idx, SAVE_txpwrindex = 0xFF;
-	uint32 val;
+	u32 val;
 	u16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	phytbl_info_t tab;
 	u8 ei0, eq0, fi0, fq0;
@@ -2949,7 +2949,7 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal
 
 		wlc_lcnphy_read_table(pi, &tab);
 		val = (val & 0xfff00000) |
-		    ((uint32) (a & 0x3FF) << 10) | (b & 0x3ff);
+		    ((u32) (a & 0x3FF) << 10) | (b & 0x3ff);
 		wlc_lcnphy_write_table(pi, &tab);
 
 		val = didq;
@@ -3172,12 +3172,12 @@ wlc_lcnphy_rx_iq_est(phy_info_t *pi,
 		wait_count++;
 	}
 
-	iq_est->iq_prod = ((uint32) read_phy_reg(pi, 0x483) << 16) |
-	    (uint32) read_phy_reg(pi, 0x484);
-	iq_est->i_pwr = ((uint32) read_phy_reg(pi, 0x485) << 16) |
-	    (uint32) read_phy_reg(pi, 0x486);
-	iq_est->q_pwr = ((uint32) read_phy_reg(pi, 0x487) << 16) |
-	    (uint32) read_phy_reg(pi, 0x488);
+	iq_est->iq_prod = ((u32) read_phy_reg(pi, 0x483) << 16) |
+	    (u32) read_phy_reg(pi, 0x484);
+	iq_est->i_pwr = ((u32) read_phy_reg(pi, 0x485) << 16) |
+	    (u32) read_phy_reg(pi, 0x486);
+	iq_est->q_pwr = ((u32) read_phy_reg(pi, 0x487) << 16) |
+	    (u32) read_phy_reg(pi, 0x488);
 
  cleanup:
 	mod_phy_reg(pi, 0x410, (0x1 << 3), (1) << 3);
@@ -3196,7 +3196,7 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 	int32 a, b, temp;
 	s16 iq_nbits, qq_nbits, arsh, brsh;
 	int32 iq;
-	uint32 ii, qq;
+	u32 ii, qq;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	a0_new = ((read_phy_reg(pi, 0x645) & (0x3ff << 0)) >> 0);
@@ -3254,7 +3254,7 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 	}
 	b /= temp;
 	b -= a * a;
-	b = (int32) wlc_phy_sqrt_int((uint32) b);
+	b = (int32) wlc_phy_sqrt_int((u32) b);
 	b -= (1 << 10);
 	a0_new = (u16) (a & 0x3ff);
 	b0_new = (u16) (b & 0x3ff);
@@ -3286,7 +3286,7 @@ wlc_lcnphy_rx_iq_cal(phy_info_t *pi, con
 	    rfoverride3_old, rfoverride3val_old, rfoverride4_old,
 	    rfoverride4val_old, afectrlovr_old, afectrlovrval_old;
 	int tia_gain;
-	uint32 received_power, rx_pwr_threshold;
+	u32 received_power, rx_pwr_threshold;
 	u16 old_sslpnCalibClkEnCtrl, old_sslpnRxFeClkEnCtrl;
 	u16 values_to_save[11];
 	s16 *ptr;
@@ -3671,7 +3671,7 @@ static void wlc_lcnphy_set_chanspec_twea
 
 void
 wlc_lcnphy_pktengtx(wlc_phy_t *ppi, wl_pkteng_t *pkteng, u8 rate,
-		    struct ether_addr *sa, uint32 wait_delay)
+		    struct ether_addr *sa, u32 wait_delay)
 {
 }
 
@@ -3854,7 +3854,7 @@ static void
 wlc_lcnphy_samp_cap(phy_info_t *pi, int clip_detect_algo, u16 thresh,
 		    s16 *ptr, int mode)
 {
-	uint32 curval1, curval2, stpptr, curptr, strptr, val;
+	u32 curval1, curval2, stpptr, curptr, strptr, val;
 	u16 sslpnCalibClkEnCtrl, timer;
 	u16 old_sslpnCalibClkEnCtrl;
 	s16 imag, real;
@@ -3887,7 +3887,7 @@ wlc_lcnphy_samp_cap(phy_info_t *pi, int
 	write_phy_reg(pi, 0x580, 0x4501);
 
 	sslpnCalibClkEnCtrl = read_phy_reg(pi, 0x6da);
-	write_phy_reg(pi, 0x6da, (uint32) (sslpnCalibClkEnCtrl | 0x2008));
+	write_phy_reg(pi, 0x6da, (u32) (sslpnCalibClkEnCtrl | 0x2008));
 	stpptr = R_REG(pi->sh->osh, &pi->regs->smpl_clct_stpptr);
 	curptr = R_REG(pi->sh->osh, &pi->regs->smpl_clct_curptr);
 	do {
@@ -4039,7 +4039,7 @@ wlc_lcnphy_a1(phy_info_t *pi, int cal_ty
 	s16 phy_c10, phy_c11, phy_c12, phy_c13, phy_c14, phy_c15, phy_c16;
 	s16 *ptr, phy_c17;
 	int32 phy_c18, phy_c19;
-	uint32 phy_c20, phy_c21;
+	u32 phy_c20, phy_c21;
 	bool phy_c22, phy_c23, phy_c24, phy_c25;
 	u16 phy_c26, phy_c27;
 	u16 phy_c28, phy_c29, phy_c30;
@@ -4244,9 +4244,9 @@ static void
 WLBANDINITFN(wlc_lcnphy_load_tx_gain_table) (phy_info_t *pi,
 					     const lcnphy_tx_gain_tbl_entry *
 					     gain_table) {
-	uint32 j;
+	u32 j;
 	phytbl_info_t tab;
-	uint32 val;
+	u32 val;
 	u16 pa_gain;
 	u16 gm_gain;
 
@@ -4264,7 +4264,7 @@ WLBANDINITFN(wlc_lcnphy_load_tx_gain_tab
 
 	for (j = 0; j < 128; j++) {
 		gm_gain = gain_table[j].gm;
-		val = (((uint32) pa_gain << 24) |
+		val = (((u32) pa_gain << 24) |
 		       (gain_table[j].pad << 16) |
 		       (gain_table[j].pga << 8) | gm_gain);
 
@@ -4280,7 +4280,7 @@ WLBANDINITFN(wlc_lcnphy_load_tx_gain_tab
 static void wlc_lcnphy_load_rfpower(phy_info_t *pi)
 {
 	phytbl_info_t tab;
-	uint32 val, bbmult, rfgain;
+	u32 val, bbmult, rfgain;
 	u8 index;
 	u8 scale_factor = 1;
 	s16 temp, temp1, temp2, qQ, qQ1, qQ2, shift;
@@ -4331,7 +4331,7 @@ static void WLBANDINITFN(wlc_lcnphy_tbl_
 	uint idx;
 	u8 phybw40;
 	phytbl_info_t tab;
-	uint32 val;
+	u32 val;
 
 	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
 
@@ -4481,7 +4481,7 @@ static void wlc_lcnphy_agc_temp_init(phy
 {
 	s16 temp;
 	phytbl_info_t tab;
-	uint32 tableBuffer[2];
+	u32 tableBuffer[2];
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	if (NORADIO_ENAB(pi->pubpi))
@@ -4605,7 +4605,7 @@ static void WLBANDINITFN(wlc_lcnphy_base
 
 static void WLBANDINITFN(wlc_radio_2064_init) (phy_info_t *pi)
 {
-	uint32 i;
+	u32 i;
 	lcnphy_radio_regs_t *lcnphyregs = NULL;
 
 	lcnphyregs = lcnphy_radio_regs_2064;
@@ -4734,7 +4734,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 
 	if (CHSPEC_IS2G(pi->radio_chanspec)) {
 		u16 cckpo = 0;
-		uint32 offset_ofdm, offset_mcs;
+		u32 offset_ofdm, offset_mcs;
 
 		pi_lcn->lcnphy_tr_isolation_mid =
 		    (u8) PHY_GETINTVAR(pi, "triso2g");
@@ -4781,7 +4781,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 				cckpo >>= 4;
 			}
 
-			offset_ofdm = (uint32) PHY_GETINTVAR(pi, "ofdm2gpo");
+			offset_ofdm = (u32) PHY_GETINTVAR(pi, "ofdm2gpo");
 			for (i = TXP_FIRST_OFDM; i <= TXP_LAST_OFDM; i++) {
 				pi->tx_srom_max_rate_2g[i] = max_pwr_chan -
 				    ((offset_ofdm & 0xf) * 2);
@@ -4796,7 +4796,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 				pi->tx_srom_max_rate_2g[i] = txpwr;
 			}
 
-			offset_ofdm = (uint32) PHY_GETINTVAR(pi, "ofdm2gpo");
+			offset_ofdm = (u32) PHY_GETINTVAR(pi, "ofdm2gpo");
 
 			for (i = TXP_FIRST_OFDM; i <= TXP_LAST_OFDM; i++) {
 				pi->tx_srom_max_rate_2g[i] = txpwr -
@@ -4872,7 +4872,7 @@ wlc_lcnphy_radio_2064_channel_tune_4313(
 	u8 pll_pwrup, pll_pwrup_ovr;
 	fixed qFxtal, qFref, qFvco, qFcal;
 	u8 d15, d16, f16, e44, e45;
-	uint32 div_int, div_frac, fvco3, fpfd, fref3, fcal_div;
+	u32 div_int, div_frac, fvco3, fpfd, fref3, fcal_div;
 	u16 loop_bw, d30, setCount;
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
@@ -5111,11 +5111,11 @@ bool wlc_phy_attach_lcnphy(phy_info_t *p
 	return TRUE;
 }
 
-static void wlc_lcnphy_set_rx_gain(phy_info_t *pi, uint32 gain)
+static void wlc_lcnphy_set_rx_gain(phy_info_t *pi, u32 gain)
 {
 	u16 trsw, ext_lna, lna1, lna2, tia, biq0, biq1, gain0_15, gain16_19;
 
-	trsw = (gain & ((uint32) 1 << 28)) ? 0 : 1;
+	trsw = (gain & ((u32) 1 << 28)) ? 0 : 1;
 	ext_lna = (u16) (gain >> 29) & 0x01;
 	lna1 = (u16) (gain >> 0) & 0x0f;
 	lna2 = (u16) (gain >> 4) & 0x0f;
@@ -5141,11 +5141,11 @@ static void wlc_lcnphy_set_rx_gain(phy_i
 	wlc_lcnphy_rx_gain_override_enable(pi, TRUE);
 }
 
-static uint32 wlc_lcnphy_get_receive_power(phy_info_t *pi, int32 *gain_index)
+static u32 wlc_lcnphy_get_receive_power(phy_info_t *pi, int32 *gain_index)
 {
-	uint32 received_power = 0;
+	u32 received_power = 0;
 	int32 max_index = 0;
-	uint32 gain_code = 0;
+	u32 gain_code = 0;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
 	max_index = 36;
@@ -5194,8 +5194,8 @@ int32 wlc_lcnphy_rx_signal_power(phy_inf
 	nominal_power_db = read_phy_reg(pi, 0x425) >> 8;
 
 	{
-		uint32 power = (received_power * 16);
-		uint32 msb1, msb2, val1, val2, diff1, diff2;
+		u32 power = (received_power * 16);
+		u32 msb1, msb2, val1, val2, diff1, diff2;
 		msb1 = ffs(power) - 1;
 		msb2 = msb1 + 1;
 		val1 = 1 << msb1;
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
@@ -27,7 +27,7 @@ struct phy_info_lcnphy {
 	bool lcnphy_recal;
 
 	u8 lcnphy_rc_cap;
-	uint32 lcnphy_mcs20_po;
+	u32 lcnphy_mcs20_po;
 
 	u8 lcnphy_tr_isolation_mid;
 	u8 lcnphy_tr_isolation_low;
@@ -69,17 +69,17 @@ struct phy_info_lcnphy {
 	s8 lcnphy_tx_power_idx_override;
 	u16 lcnphy_noise_samples;
 
-	uint32 lcnphy_papdRxGnIdx;
-	uint32 lcnphy_papd_rxGnCtrl_init;
+	u32 lcnphy_papdRxGnIdx;
+	u32 lcnphy_papd_rxGnCtrl_init;
 
-	uint32 lcnphy_gain_idx_14_lowword;
-	uint32 lcnphy_gain_idx_14_hiword;
-	uint32 lcnphy_gain_idx_27_lowword;
-	uint32 lcnphy_gain_idx_27_hiword;
+	u32 lcnphy_gain_idx_14_lowword;
+	u32 lcnphy_gain_idx_14_hiword;
+	u32 lcnphy_gain_idx_27_lowword;
+	u32 lcnphy_gain_idx_27_hiword;
 	s16 lcnphy_ofdmgainidxtableoffset;
 	s16 lcnphy_dsssgainidxtableoffset;
-	uint32 lcnphy_tr_R_gain_val;
-	uint32 lcnphy_tr_T_gain_val;
+	u32 lcnphy_tr_R_gain_val;
+	u32 lcnphy_tr_T_gain_val;
 	s8 lcnphy_input_pwr_offset_db;
 	u16 lcnphy_Med_Low_Gain_db;
 	u16 lcnphy_Very_Low_Gain_db;
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -13309,7 +13309,7 @@ static const u16 tbl_iqcal_gainparams_np
 	 }
 };
 
-static const uint32 nphy_tpc_txgain[] = {
+static const u32 nphy_tpc_txgain[] = {
 	0x03cc2b44, 0x03cc2b42, 0x03cc2a44, 0x03cc2a42,
 	0x03cc2944, 0x03c82b44, 0x03c82b42, 0x03c82a44,
 	0x03c82a42, 0x03c82944, 0x03c82942, 0x03c82844,
@@ -13363,7 +13363,7 @@ static const u16 nphy_tpc_loscale[] = {
 	858, 908, 908, 962, 962, 1019, 1019, 256
 };
 
-static uint32 nphy_tpc_txgain_ipa[] = {
+static u32 nphy_tpc_txgain_ipa[] = {
 	0x5ff7002d, 0x5ff7002b, 0x5ff7002a, 0x5ff70029,
 	0x5ff70028, 0x5ff70027, 0x5ff70026, 0x5ff70025,
 	0x5ef7002d, 0x5ef7002b, 0x5ef7002a, 0x5ef70029,
@@ -13398,7 +13398,7 @@ static uint32 nphy_tpc_txgain_ipa[] = {
 	0x50f70028, 0x50f70027, 0x50f70026, 0x50f70025
 };
 
-static uint32 nphy_tpc_txgain_ipa_rev5[] = {
+static u32 nphy_tpc_txgain_ipa_rev5[] = {
 	0x1ff7002d, 0x1ff7002b, 0x1ff7002a, 0x1ff70029,
 	0x1ff70028, 0x1ff70027, 0x1ff70026, 0x1ff70025,
 	0x1ef7002d, 0x1ef7002b, 0x1ef7002a, 0x1ef70029,
@@ -13433,7 +13433,7 @@ static uint32 nphy_tpc_txgain_ipa_rev5[]
 	0x10f70028, 0x10f70027, 0x10f70026, 0x10f70025
 };
 
-static uint32 nphy_tpc_txgain_ipa_rev6[] = {
+static u32 nphy_tpc_txgain_ipa_rev6[] = {
 	0x0ff7002d, 0x0ff7002b, 0x0ff7002a, 0x0ff70029,
 	0x0ff70028, 0x0ff70027, 0x0ff70026, 0x0ff70025,
 	0x0ef7002d, 0x0ef7002b, 0x0ef7002a, 0x0ef70029,
@@ -13468,7 +13468,7 @@ static uint32 nphy_tpc_txgain_ipa_rev6[]
 	0x00f70028, 0x00f70027, 0x00f70026, 0x00f70025
 };
 
-static uint32 nphy_tpc_txgain_ipa_2g_2057rev3[] = {
+static u32 nphy_tpc_txgain_ipa_2g_2057rev3[] = {
 	0x70ff0040, 0x70f7003e, 0x70ef003b, 0x70e70039,
 	0x70df0037, 0x70d70036, 0x70cf0033, 0x70c70032,
 	0x70bf0031, 0x70b7002f, 0x70af002e, 0x70a7002d,
@@ -13503,7 +13503,7 @@ static uint32 nphy_tpc_txgain_ipa_2g_205
 	0x700f0001, 0x700f0001, 0x700f0001, 0x700f0001
 };
 
-static uint32 nphy_tpc_txgain_ipa_2g_2057rev4n6[] = {
+static u32 nphy_tpc_txgain_ipa_2g_2057rev4n6[] = {
 	0xf0ff0040, 0xf0f7003e, 0xf0ef003b, 0xf0e70039,
 	0xf0df0037, 0xf0d70036, 0xf0cf0033, 0xf0c70032,
 	0xf0bf0031, 0xf0b7002f, 0xf0af002e, 0xf0a7002d,
@@ -13538,7 +13538,7 @@ static uint32 nphy_tpc_txgain_ipa_2g_205
 	0xf00f0001, 0xf00f0001, 0xf00f0001, 0xf00f0001
 };
 
-static uint32 nphy_tpc_txgain_ipa_2g_2057rev5[] = {
+static u32 nphy_tpc_txgain_ipa_2g_2057rev5[] = {
 	0x30ff0031, 0x30e70031, 0x30e7002e, 0x30cf002e,
 	0x30bf002e, 0x30af002e, 0x309f002f, 0x307f0033,
 	0x307f0031, 0x307f002e, 0x3077002e, 0x306f002e,
@@ -13573,7 +13573,7 @@ static uint32 nphy_tpc_txgain_ipa_2g_205
 	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715
 };
 
-static uint32 nphy_tpc_txgain_ipa_2g_2057rev7[] = {
+static u32 nphy_tpc_txgain_ipa_2g_2057rev7[] = {
 	0x30ff0031, 0x30e70031, 0x30e7002e, 0x30cf002e,
 	0x30bf002e, 0x30af002e, 0x309f002f, 0x307f0033,
 	0x307f0031, 0x307f002e, 0x3077002e, 0x306f002e,
@@ -13608,7 +13608,7 @@ static uint32 nphy_tpc_txgain_ipa_2g_205
 	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715
 };
 
-static uint32 nphy_tpc_txgain_ipa_5g[] = {
+static u32 nphy_tpc_txgain_ipa_5g[] = {
 	0x7ff70035, 0x7ff70033, 0x7ff70032, 0x7ff70031,
 	0x7ff7002f, 0x7ff7002e, 0x7ff7002d, 0x7ff7002b,
 	0x7ff7002a, 0x7ff70029, 0x7ff70028, 0x7ff70027,
@@ -13643,7 +13643,7 @@ static uint32 nphy_tpc_txgain_ipa_5g[] =
 	0x70f70021, 0x70f70020, 0x70f70020, 0x70f7001f
 };
 
-static uint32 nphy_tpc_txgain_ipa_5g_2057[] = {
+static u32 nphy_tpc_txgain_ipa_5g_2057[] = {
 	0x7f7f0044, 0x7f7f0040, 0x7f7f003c, 0x7f7f0039,
 	0x7f7f0036, 0x7e7f003c, 0x7e7f0038, 0x7e7f0035,
 	0x7d7f003c, 0x7d7f0039, 0x7d7f0036, 0x7d7f0033,
@@ -13678,7 +13678,7 @@ static uint32 nphy_tpc_txgain_ipa_5g_205
 	0x707f0001, 0x707f0001, 0x707f0001, 0x707f0001
 };
 
-static uint32 nphy_tpc_txgain_ipa_5g_2057rev7[] = {
+static u32 nphy_tpc_txgain_ipa_5g_2057rev7[] = {
 	0x6f7f0031, 0x6f7f002e, 0x6f7f002c, 0x6f7f002a,
 	0x6f7f0027, 0x6e7f002e, 0x6e7f002c, 0x6e7f002a,
 	0x6d7f0030, 0x6d7f002d, 0x6d7f002a, 0x6d7f0028,
@@ -13775,7 +13775,7 @@ static u8 pga_all_gain_codes_2057[] = {
 	15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
 };
 
-static uint32 nphy_papd_scaltbl[] = {
+static u32 nphy_papd_scaltbl[] = {
 	0x0ae2002f, 0x0a3b0032, 0x09a70035, 0x09220038,
 	0x0887003c, 0x081f003f, 0x07a20043, 0x07340047,
 	0x06d2004b, 0x067a004f, 0x06170054, 0x05bf0059,
@@ -13794,7 +13794,7 @@ static uint32 nphy_papd_scaltbl[] = {
 	0x005805d7, 0x0053062f, 0x004e068d, 0x004a06f1
 };
 
-static uint32 nphy_tpc_txgain_rev3[] = {
+static u32 nphy_tpc_txgain_rev3[] = {
 	0x1f410044, 0x1f410042, 0x1f410040, 0x1f41003e,
 	0x1f41003c, 0x1f41003b, 0x1f410039, 0x1f410037,
 	0x1e410044, 0x1e410042, 0x1e410040, 0x1e41003e,
@@ -13829,7 +13829,7 @@ static uint32 nphy_tpc_txgain_rev3[] = {
 	0x1041003c, 0x1041003b, 0x10410039, 0x10410037
 };
 
-static uint32 nphy_tpc_txgain_HiPwrEPA[] = {
+static u32 nphy_tpc_txgain_HiPwrEPA[] = {
 	0x0f410044, 0x0f410042, 0x0f410040, 0x0f41003e,
 	0x0f41003c, 0x0f41003b, 0x0f410039, 0x0f410037,
 	0x0e410044, 0x0e410042, 0x0e410040, 0x0e41003e,
@@ -13864,7 +13864,7 @@ static uint32 nphy_tpc_txgain_HiPwrEPA[]
 	0x0041003c, 0x0041003b, 0x00410039, 0x00410037
 };
 
-static uint32 nphy_tpc_txgain_epa_2057rev3[] = {
+static u32 nphy_tpc_txgain_epa_2057rev3[] = {
 	0x80f90040, 0x80e10040, 0x80e1003c, 0x80c9003d,
 	0x80b9003c, 0x80a9003d, 0x80a1003c, 0x8099003b,
 	0x8091003b, 0x8089003a, 0x8081003a, 0x80790039,
@@ -13899,7 +13899,7 @@ static uint32 nphy_tpc_txgain_epa_2057re
 	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d
 };
 
-static uint32 nphy_tpc_txgain_epa_2057rev5[] = {
+static u32 nphy_tpc_txgain_epa_2057rev5[] = {
 	0x10f90040, 0x10e10040, 0x10e1003c, 0x10c9003d,
 	0x10b9003c, 0x10a9003d, 0x10a1003c, 0x1099003b,
 	0x1091003b, 0x1089003a, 0x1081003a, 0x10790039,
@@ -13934,7 +13934,7 @@ static uint32 nphy_tpc_txgain_epa_2057re
 	0x10090001, 0x10090001, 0x10090001, 0x10090001
 };
 
-static uint32 nphy_tpc_5GHz_txgain_rev3[] = {
+static u32 nphy_tpc_5GHz_txgain_rev3[] = {
 	0xcff70044, 0xcff70042, 0xcff70040, 0xcff7003e,
 	0xcff7003c, 0xcff7003b, 0xcff70039, 0xcff70037,
 	0xcef70044, 0xcef70042, 0xcef70040, 0xcef7003e,
@@ -13969,7 +13969,7 @@ static uint32 nphy_tpc_5GHz_txgain_rev3[
 	0xc0f7003c, 0xc0f7003b, 0xc0f70039, 0xc0f70037
 };
 
-static uint32 nphy_tpc_5GHz_txgain_rev4[] = {
+static u32 nphy_tpc_5GHz_txgain_rev4[] = {
 	0x2ff20044, 0x2ff20042, 0x2ff20040, 0x2ff2003e,
 	0x2ff2003c, 0x2ff2003b, 0x2ff20039, 0x2ff20037,
 	0x2ef20044, 0x2ef20042, 0x2ef20040, 0x2ef2003e,
@@ -14004,7 +14004,7 @@ static uint32 nphy_tpc_5GHz_txgain_rev4[
 	0x20d2003a, 0x20d20038, 0x20d20036, 0x20d20034
 };
 
-static uint32 nphy_tpc_5GHz_txgain_rev5[] = {
+static u32 nphy_tpc_5GHz_txgain_rev5[] = {
 	0x0f62004a, 0x0f620048, 0x0f620046, 0x0f620044,
 	0x0f620042, 0x0f620040, 0x0f62003e, 0x0f62003c,
 	0x0e620044, 0x0e620042, 0x0e620040, 0x0e62003e,
@@ -14039,7 +14039,7 @@ static uint32 nphy_tpc_5GHz_txgain_rev5[
 	0x0062003b, 0x00620039, 0x00620037, 0x00620035
 };
 
-static uint32 nphy_tpc_5GHz_txgain_HiPwrEPA[] = {
+static u32 nphy_tpc_5GHz_txgain_HiPwrEPA[] = {
 	0x2ff10044, 0x2ff10042, 0x2ff10040, 0x2ff1003e,
 	0x2ff1003c, 0x2ff1003b, 0x2ff10039, 0x2ff10037,
 	0x2ef10044, 0x2ef10042, 0x2ef10040, 0x2ef1003e,
@@ -14092,7 +14092,7 @@ static void wlc_phy_chanspec_nphy_setup(
 static void wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t *pi,
 					    u16 reduction_factr);
 static void wlc_phy_adjust_min_noisevar_nphy(phy_info_t *pi, int ntones, int *,
-					     uint32 *buf);
+					     u32 *buf);
 static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t *pi, u8 minpwr);
 static void wlc_phy_txlpfbw_nphy(phy_info_t *pi);
 static void wlc_phy_spurwar_nphy(phy_info_t *pi);
@@ -14133,10 +14133,10 @@ static void wlc_phy_ipa_set_tx_digi_filt
 static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t *pi);
 static u16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t *pi);
 static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t *pi, u8 m0, u8 m1);
-static uint32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t *pi);
+static u32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t *pi);
 
-static void wlc_phy_a1_nphy(phy_info_t *pi, u8 core, uint32 winsz, uint32,
-			    uint32 e);
+static void wlc_phy_a1_nphy(phy_info_t *pi, u8 core, u32 winsz, u32,
+			    u32 e);
 static u8 wlc_phy_a3_nphy(phy_info_t *pi, u8 start_gain, u8 core);
 static void wlc_phy_a2_nphy(phy_info_t *pi, nphy_ipa_txcalgains_t *,
 			    phy_cal_mode_t, u8);
@@ -14181,7 +14181,7 @@ static u16 wlc_phy_radio205x_rcal(phy_in
 
 static u16 wlc_phy_radio2057_rccal(phy_info_t *pi);
 
-static u16 wlc_phy_gen_load_samples_nphy(phy_info_t *pi, uint32 f_kHz,
+static u16 wlc_phy_gen_load_samples_nphy(phy_info_t *pi, u32 f_kHz,
 					    u16 max_val,
 					    u8 dac_test_mode);
 static void wlc_phy_loadsampletable_nphy(phy_info_t *pi, cint32 *tone_buf,
@@ -14193,7 +14193,7 @@ static void wlc_phy_runsamples_nphy(phy_
 bool wlc_phy_bist_check_phy(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
-	uint32 phybist0, phybist1, phybist2, phybist3, phybist4;
+	u32 phybist0, phybist1, phybist2, phybist3, phybist4;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 16))
 		return TRUE;
@@ -14243,8 +14243,8 @@ static void WLBANDINITFN(wlc_phy_bphy_in
 }
 
 void
-wlc_phy_table_write_nphy(phy_info_t *pi, uint32 id, uint32 len, uint32 offset,
-			 uint32 width, const void *data)
+wlc_phy_table_write_nphy(phy_info_t *pi, u32 id, u32 len, u32 offset,
+			 u32 width, const void *data)
 {
 	mimophytbl_info_t tbl;
 
@@ -14257,8 +14257,8 @@ wlc_phy_table_write_nphy(phy_info_t *pi,
 }
 
 void
-wlc_phy_table_read_nphy(phy_info_t *pi, uint32 id, uint32 len, uint32 offset,
-			uint32 width, void *data)
+wlc_phy_table_read_nphy(phy_info_t *pi, u32 id, u32 len, u32 offset,
+			u32 width, void *data)
 {
 	mimophytbl_info_t tbl;
 
@@ -14535,7 +14535,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 	uint core;
 	uint origidx, intr_val;
 	d11regs_t *regs;
-	uint32 d11_clk_ctl_st;
+	u32 d11_clk_ctl_st;
 
 	core = 0;
 
@@ -14703,7 +14703,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 	wlc_phy_txpwrctrl_pwr_setup_nphy(pi);
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
-		uint32 *tx_pwrctrl_tbl = NULL;
+		u32 *tx_pwrctrl_tbl = NULL;
 		u16 idx;
 		s16 pga_gn = 0;
 		s16 pad_gn = 0;
@@ -15330,7 +15330,7 @@ static void wlc_phy_workarounds_nphy(phy
 
 	s16 alpha0, alpha1, alpha2;
 	s16 beta0, beta1, beta2;
-	uint32 leg_data_weights, ht_data_weights, nss1_data_weights,
+	u32 leg_data_weights, ht_data_weights, nss1_data_weights,
 	    stbc_data_weights;
 	u8 chan_freq_range = 0;
 	u16 dac_control = 0x0002;
@@ -17629,7 +17629,7 @@ wlc_phy_chan2freq_nphy(phy_info_t *pi, u
 	chan_info_nphy_radio2057_t *chan_info_tbl_p_0 = NULL;
 	chan_info_nphy_radio205x_t *chan_info_tbl_p_1 = NULL;
 	chan_info_nphy_radio2057_rev5_t *chan_info_tbl_p_2 = NULL;
-	uint32 tbl_len = 0;
+	u32 tbl_len = 0;
 
 	int freq = 0;
 
@@ -18656,10 +18656,10 @@ wlc_phy_adjust_rx_analpfbw_nphy(phy_info
 
 static void
 wlc_phy_adjust_min_noisevar_nphy(phy_info_t *pi, int ntones, int *tone_id_buf,
-				 uint32 *noise_var_buf)
+				 u32 *noise_var_buf)
 {
 	int i;
-	uint32 offset;
+	u32 offset;
 	int tone_id;
 	int tbllen =
 	    CHSPEC_IS40(pi->
@@ -18798,10 +18798,10 @@ static void wlc_phy_spurwar_nphy(phy_inf
 {
 	u16 cur_channel = 0;
 	int nphy_adj_tone_id_buf[] = { 57, 58 };
-	uint32 nphy_adj_noise_var_buf[] = { 0x3ff, 0x3ff };
+	u32 nphy_adj_noise_var_buf[] = { 0x3ff, 0x3ff };
 	bool isAdjustNoiseVar = FALSE;
 	uint numTonesAdjust = 0;
-	uint32 tempval = 0;
+	u32 tempval = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		if (pi->phyhang_avoid)
@@ -19563,7 +19563,7 @@ void wlc_phy_antsel_init(wlc_phy_t *ppi,
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	u16 mask = 0xfc00;
-	uint32 mc = 0;
+	u32 mc = 0;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7))
 		return;
@@ -19709,7 +19709,7 @@ static void
 wlc_phy_set_rfseq_nphy(phy_info_t *pi, u8 cmd, u8 *events, u8 *dlys,
 		       u8 len)
 {
-	uint32 t1_offset, t2_offset;
+	u32 t1_offset, t2_offset;
 	u8 ctr;
 	u8 end_event =
 	    NREV_GE(pi->pubpi.phy_rev,
@@ -19754,7 +19754,7 @@ static u16 wlc_phy_read_lpf_bw_ctl_nphy(
 		rx2tx_lpf_rc_lut_offset = offset;
 	}
 	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 1,
-				(uint32) rx2tx_lpf_rc_lut_offset, 16,
+				(u32) rx2tx_lpf_rc_lut_offset, 16,
 				&lpf_bw_ctl_val);
 
 	lpf_bw_ctl_val = lpf_bw_ctl_val & 0x7;
@@ -22338,13 +22338,13 @@ static void wlc_phy_restore_rssical_nphy
 }
 
 static u16
-wlc_phy_gen_load_samples_nphy(phy_info_t *pi, uint32 f_kHz, u16 max_val,
+wlc_phy_gen_load_samples_nphy(phy_info_t *pi, u32 f_kHz, u16 max_val,
 			      u8 dac_test_mode)
 {
 	u8 phy_bw, is_phybw40;
 	u16 num_samps, t, spur;
 	fixed theta = 0, rot = 0;
-	uint32 tbl_len;
+	u32 tbl_len;
 	cint32 *tone_buf = NULL;
 
 	is_phybw40 = CHSPEC_IS40(pi->radio_chanspec);
@@ -22388,7 +22388,7 @@ wlc_phy_gen_load_samples_nphy(phy_info_t
 }
 
 int
-wlc_phy_tx_tone_nphy(phy_info_t *pi, uint32 f_kHz, u16 max_val,
+wlc_phy_tx_tone_nphy(phy_info_t *pi, u32 f_kHz, u16 max_val,
 		     u8 iqmode, u8 dac_test_mode, bool modify_bbmult)
 {
 	u16 num_samps;
@@ -22412,9 +22412,9 @@ wlc_phy_loadsampletable_nphy(phy_info_t
 			     u16 num_samps)
 {
 	u16 t;
-	uint32 *data_buf = NULL;
+	u32 *data_buf = NULL;
 
-	data_buf = (uint32 *) MALLOC(pi->sh->osh, sizeof(uint32) * num_samps);
+	data_buf = (u32 *) MALLOC(pi->sh->osh, sizeof(u32) * num_samps);
 	if (data_buf == NULL) {
 		return;
 	}
@@ -22430,7 +22430,7 @@ wlc_phy_loadsampletable_nphy(phy_info_t
 				 data_buf);
 
 	if (data_buf != NULL)
-		MFREE(pi->sh->osh, data_buf, sizeof(uint32) * num_samps);
+		MFREE(pi->sh->osh, data_buf, sizeof(u32) * num_samps);
 
 	if (pi->phyhang_avoid)
 		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
@@ -22571,7 +22571,7 @@ nphy_txgains_t wlc_phy_get_tx_gain_nphy(
 	u16 base_idx[2], curr_gain[2];
 	u8 core_no;
 	nphy_txgains_t target_gain;
-	uint32 *tx_pwrctrl_tbl = NULL;
+	u32 *tx_pwrctrl_tbl = NULL;
 
 	if (pi->nphy_txpwrctrl == PHY_TPC_HW_OFF) {
 		if (pi->phyhang_avoid)
@@ -23513,9 +23513,9 @@ wlc_phy_est_tonepwr_nphy(phy_info_t *pi,
 	}
 
 	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_CORE1TXPWRCTL, 1,
-				(uint32) pwrindex[0], 32, &qdBm_pwrbuf[0]);
+				(u32) pwrindex[0], 32, &qdBm_pwrbuf[0]);
 	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_CORE2TXPWRCTL, 1,
-				(uint32) pwrindex[1], 32, &qdBm_pwrbuf[1]);
+				(u32) pwrindex[1], 32, &qdBm_pwrbuf[1]);
 }
 
 static void wlc_phy_internal_cal_txgain_nphy(phy_info_t *pi)
@@ -23640,7 +23640,7 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 	int32 qdBm_power[2];
 	u16 orig_BBConfig;
 	u16 phy_saveregs[4];
-	uint32 freq_test;
+	u32 freq_test;
 	u16 ampl_test = 250;
 	uint stepsize;
 	bool phyhang_avoid_state = FALSE;
@@ -23800,7 +23800,7 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 static void wlc_phy_update_txcal_ladder_nphy(phy_info_t *pi, u16 core)
 {
 	int index;
-	uint32 bbmult_scale;
+	u32 bbmult_scale;
 	u16 bbmult;
 	u16 tblentry;
 
@@ -24112,7 +24112,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t *pi,
 	u16 gain_save[2];
 	u16 cal_gain[2];
 	nphy_iqcal_params_t cal_params[2];
-	uint32 tbl_len;
+	u32 tbl_len;
 	void *tbl_ptr;
 	bool ladder_updated[2];
 	u8 mphase_cal_lastphase = 0;
@@ -24569,7 +24569,7 @@ static void wlc_phy_calc_rx_iq_comp_nphy
 	phy_iq_est_t est[PHY_CORE_MAX];
 	nphy_iq_comp_t old_comp, new_comp;
 	int32 iq = 0;
-	uint32 ii = 0, qq = 0;
+	u32 ii = 0, qq = 0;
 	s16 iq_nbits, qq_nbits, brsh, arsh;
 	int32 a, b, temp;
 	int bcmerror = BCME_OK;
@@ -24646,7 +24646,7 @@ static void wlc_phy_calc_rx_iq_comp_nphy
 		}
 		b /= temp;
 		b -= a * a;
-		b = (int32) wlc_phy_sqrt_int((uint32) b);
+		b = (int32) wlc_phy_sqrt_int((u32) b);
 		b -= (1 << 10);
 
 		if ((curr_core == PHY_CORE_0) && (core_mask & 0x1)) {
@@ -25315,7 +25315,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 	phy_iq_est_t est[PHY_CORE_MAX];
 	u8 tx_core;
 	nphy_iq_comp_t save_comp, zero_comp;
-	uint32 i_pwr, q_pwr, curr_pwr, optim_pwr = 0, prev_pwr = 0, thresh_pwr =
+	u32 i_pwr, q_pwr, curr_pwr, optim_pwr = 0, prev_pwr = 0, thresh_pwr =
 	    10000;
 	s16 desired_log2_pwr, actual_log2_pwr, delta_pwr;
 	bool gainctrl_done = FALSE;
@@ -25524,12 +25524,12 @@ wlc_phy_rxcal_gainctrl_nphy(phy_info_t *
 static u8
 wlc_phy_rc_sweep_nphy(phy_info_t *pi, u8 core_idx, u8 loopback_type)
 {
-	uint32 target_bws[2] = { 9500, 21000 };
-	uint32 ref_tones[2] = { 3000, 6000 };
-	uint32 target_bw, ref_tone;
+	u32 target_bws[2] = { 9500, 21000 };
+	u32 ref_tones[2] = { 3000, 6000 };
+	u32 target_bw, ref_tone;
 
-	uint32 target_pwr_ratios[2] = { 28606, 18468 };
-	uint32 target_pwr_ratio, pwr_ratio, last_pwr_ratio = 0;
+	u32 target_pwr_ratios[2] = { 28606, 18468 };
+	u32 target_pwr_ratio, pwr_ratio, last_pwr_ratio = 0;
 
 	u16 start_rccal_ovr_val = 128;
 	u16 txlpf_rccal_lpc_ovr_val = 128;
@@ -25552,7 +25552,7 @@ wlc_phy_rc_sweep_nphy(phy_info_t *pi, u8
 
 	s8 rccal_stepsize;
 	u16 rccal_val, last_rccal_val = 0, best_rccal_val = 0;
-	uint32 ref_iq_vals = 0, target_iq_vals = 0;
+	u32 ref_iq_vals = 0, target_iq_vals = 0;
 	u16 num_samps, log_num_samps = 10;
 	phy_iq_est_t est[PHY_CORE_MAX];
 
@@ -25933,7 +25933,7 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t *p
 	u16 orig_RfseqCoreActv, orig_AfectrlCore, orig_AfectrlOverride;
 	u16 orig_RfctrlIntcRx, orig_RfctrlIntcTx;
 	u16 num_samps;
-	uint32 i_pwr, q_pwr, tot_pwr[3];
+	u32 i_pwr, q_pwr, tot_pwr[3];
 	u8 gain_pass, use_hpf_num;
 	u16 mask, val1, val2;
 	u16 core_no;
@@ -26244,9 +26244,9 @@ static void wlc_phy_ipa_set_bbmult_nphy(
 	wlc_phy_table_write_nphy(pi, 15, 1, 95, 16, &m0m1);
 }
 
-static uint32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t *pi)
+static u32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t *pi)
 {
-	uint32 *tx_pwrctrl_tbl = NULL;
+	u32 *tx_pwrctrl_tbl = NULL;
 
 	if (CHSPEC_IS2G(pi->radio_chanspec)) {
 
@@ -26718,16 +26718,16 @@ wlc_phy_papd_cal_cleanup_nphy(phy_info_t
 }
 
 static void
-wlc_phy_a1_nphy(phy_info_t *pi, u8 core, uint32 winsz, uint32 start,
-		uint32 end)
+wlc_phy_a1_nphy(phy_info_t *pi, u8 core, u32 winsz, u32 start,
+		u32 end)
 {
-	uint32 *buf, *src, *dst, sz;
+	u32 *buf, *src, *dst, sz;
 
 	sz = end - start + 1;
 	ASSERT(end > start);
 	ASSERT(end < NPHY_PAPD_EPS_TBL_SIZE);
 
-	buf = MALLOC(pi->sh->osh, 2 * sizeof(uint32) * NPHY_PAPD_EPS_TBL_SIZE);
+	buf = MALLOC(pi->sh->osh, 2 * sizeof(u32) * NPHY_PAPD_EPS_TBL_SIZE);
 	if (NULL == buf) {
 		return;
 	}
@@ -26742,7 +26742,7 @@ wlc_phy_a1_nphy(phy_info_t *pi, u8 core,
 				NPHY_PAPD_EPS_TBL_SIZE, 0, 32, src);
 
 	do {
-		uint32 phy_a1, phy_a2;
+		u32 phy_a1, phy_a2;
 		int32 phy_a3, phy_a4, phy_a5, phy_a6, phy_a7;
 
 		phy_a1 = end - MIN(end, (winsz >> 1));
@@ -26760,7 +26760,7 @@ wlc_phy_a1_nphy(phy_info_t *pi, u8 core,
 
 		phy_a6 /= phy_a3;
 		phy_a7 /= phy_a3;
-		dst[end] = ((uint32) phy_a7 << 13) | ((uint32) phy_a6 & 0x1fff);
+		dst[end] = ((u32) phy_a7 << 13) | ((u32) phy_a6 & 0x1fff);
 	} while (end-- != start);
 
 	wlc_phy_table_write_nphy(pi,
@@ -26768,7 +26768,7 @@ wlc_phy_a1_nphy(phy_info_t *pi, u8 core,
 				  PHY_CORE_0) ? NPHY_TBL_ID_EPSILONTBL0 :
 				 NPHY_TBL_ID_EPSILONTBL1, sz, start, 32, dst);
 
-	MFREE(pi->sh->osh, buf, 2 * sizeof(uint32) * NPHY_PAPD_EPS_TBL_SIZE);
+	MFREE(pi->sh->osh, buf, 2 * sizeof(u32) * NPHY_PAPD_EPS_TBL_SIZE);
 }
 
 static void
@@ -26779,7 +26779,7 @@ wlc_phy_a2_nphy(phy_info_t *pi, nphy_ipa
 	u16 phy_a4, phy_a5;
 	bool phy_a6;
 	u8 phy_a7, m[2];
-	uint32 phy_a8 = 0;
+	u32 phy_a8 = 0;
 	nphy_txgains_t phy_a9;
 
 	if (NREV_LT(pi->pubpi.phy_rev, 3))
@@ -27081,7 +27081,7 @@ static u8 wlc_phy_a3_nphy(phy_info_t *pi
 	bool phy_a5 = FALSE;
 	bool phy_a6 = TRUE;
 	int32 phy_a7, phy_a8;
-	uint32 phy_a9;
+	u32 phy_a9;
 	int phy_a10;
 	bool phy_a11 = FALSE;
 	int phy_a12;
@@ -27531,7 +27531,7 @@ static void wlc_phy_a4(phy_info_t *pi, b
 void wlc_phy_txpwr_fixpower_nphy(phy_info_t *pi)
 {
 	uint core;
-	uint32 txgain;
+	u32 txgain;
 	u16 rad_gain, dac_gain, bbmult, m1m2;
 	u8 txpi[2], chan_freq_range;
 	int32 rfpwr_offset;
@@ -27590,7 +27590,7 @@ void wlc_phy_txpwr_fixpower_nphy(phy_inf
 	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
 		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 			if (PHY_IPA(pi)) {
-				uint32 *tx_gaintbl =
+				u32 *tx_gaintbl =
 				    wlc_phy_get_ipa_gaintbl_nphy(pi);
 				txgain = tx_gaintbl[txpi[core]];
 			} else {
@@ -28005,7 +28005,7 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 
 			pi->cck2gpo = (u16) PHY_GETINTVAR(pi, "cck2gpo");
 
-			pi->ofdm2gpo = (uint32) PHY_GETINTVAR(pi, "ofdm2gpo");
+			pi->ofdm2gpo = (u32) PHY_GETINTVAR(pi, "ofdm2gpo");
 
 			pi->mcs2gpo[0] = (u16) PHY_GETINTVAR(pi, "mcs2gpo0");
 			pi->mcs2gpo[1] = (u16) PHY_GETINTVAR(pi, "mcs2gpo1");
@@ -28043,7 +28043,7 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_pwrctrl_info[PHY_CORE_1].idle_targ_5gm =
 			    (s8) PHY_GETINTVAR(pi, "itt5ga1");
 
-			pi->ofdm5gpo = (uint32) PHY_GETINTVAR(pi, "ofdm5gpo");
+			pi->ofdm5gpo = (u32) PHY_GETINTVAR(pi, "ofdm5gpo");
 
 			pi->mcs5gpo[0] = (u16) PHY_GETINTVAR(pi, "mcs5gpo0");
 			pi->mcs5gpo[1] = (u16) PHY_GETINTVAR(pi, "mcs5gpo1");
@@ -28079,7 +28079,7 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_pwrctrl_info[0].idle_targ_5gl = 0;
 			pi->nphy_pwrctrl_info[1].idle_targ_5gl = 0;
 
-			pi->ofdm5glpo = (uint32) PHY_GETINTVAR(pi, "ofdm5glpo");
+			pi->ofdm5glpo = (u32) PHY_GETINTVAR(pi, "ofdm5glpo");
 
 			pi->mcs5glpo[0] =
 			    (u16) PHY_GETINTVAR(pi, "mcs5glpo0");
@@ -28123,7 +28123,7 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 			pi->nphy_pwrctrl_info[0].idle_targ_5gh = 0;
 			pi->nphy_pwrctrl_info[1].idle_targ_5gh = 0;
 
-			pi->ofdm5ghpo = (uint32) PHY_GETINTVAR(pi, "ofdm5ghpo");
+			pi->ofdm5ghpo = (u32) PHY_GETINTVAR(pi, "ofdm5ghpo");
 
 			pi->mcs5ghpo[0] =
 			    (u16) PHY_GETINTVAR(pi, "mcs5ghpo0");
@@ -28230,13 +28230,13 @@ void wlc_phy_txpower_recalc_target_nphy(
 
 static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t *pi)
 {
-	uint32 idx;
+	u32 idx;
 	u16 iqloCalbuf[7];
-	uint32 iqcomp, locomp, curr_locomp;
+	u32 iqcomp, locomp, curr_locomp;
 	s8 locomp_i, locomp_q;
 	s8 curr_locomp_i, curr_locomp_q;
-	uint32 tbl_id, tbl_len, tbl_offset;
-	uint32 regval[128];
+	u32 tbl_id, tbl_len, tbl_offset;
+	u32 regval[128];
 
 	if (pi->phyhang_avoid)
 		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
@@ -28249,9 +28249,9 @@ static void wlc_phy_txpwrctrl_coeff_setu
 	     tbl_id <= NPHY_TBL_ID_CORE2TXPWRCTL; tbl_id++) {
 		iqcomp =
 		    (tbl_id ==
-		     26) ? (((uint32) (iqloCalbuf[0] & 0x3ff)) << 10) |
+		     26) ? (((u32) (iqloCalbuf[0] & 0x3ff)) << 10) |
 		    (iqloCalbuf[1] & 0x3ff)
-		    : (((uint32) (iqloCalbuf[2] & 0x3ff)) << 10) |
+		    : (((u32) (iqloCalbuf[2] & 0x3ff)) << 10) |
 		    (iqloCalbuf[3] & 0x3ff);
 
 		for (idx = 0; idx < tbl_len; idx++) {
@@ -28266,7 +28266,7 @@ static void wlc_phy_txpwrctrl_coeff_setu
 	     tbl_id <= NPHY_TBL_ID_CORE2TXPWRCTL; tbl_id++) {
 
 		locomp =
-		    (uint32) ((tbl_id == 26) ? iqloCalbuf[5] : iqloCalbuf[6]);
+		    (u32) ((tbl_id == 26) ? iqloCalbuf[5] : iqloCalbuf[6]);
 		locomp_i = (s8) ((locomp >> 8) & 0xff);
 		locomp_q = (s8) ((locomp) & 0xff);
 		for (idx = 0; idx < tbl_len; idx++) {
@@ -28281,8 +28281,8 @@ static void wlc_phy_txpwrctrl_coeff_setu
 				    (s8) ((locomp_q * nphy_tpc_loscale[idx] +
 					     128) >> 8);
 			}
-			curr_locomp = (uint32) ((curr_locomp_i & 0xff) << 8);
-			curr_locomp |= (uint32) (curr_locomp_q & 0xff);
+			curr_locomp = (u32) ((curr_locomp_i & 0xff) << 8);
+			curr_locomp |= (u32) (curr_locomp_q & 0xff);
 			regval[idx] = curr_locomp;
 		}
 		wlc_phy_table_write_nphy(pi, tbl_id, tbl_len, tbl_offset, 32,
@@ -28477,14 +28477,14 @@ static void wlc_phy_txpwrctrl_idle_tssi_
 
 static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t *pi)
 {
-	uint32 idx;
+	u32 idx;
 	s16 a1[2], b0[2], b1[2];
 	s8 target_pwr_qtrdbm[2];
 	int32 num, den, pwr_est;
 	u8 chan_freq_range;
 	u8 idle_tssi[2];
-	uint32 tbl_id, tbl_len, tbl_offset;
-	uint32 regval[64];
+	u32 tbl_id, tbl_len, tbl_offset;
+	u32 regval[64];
 	u8 core;
 
 	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
@@ -28696,7 +28696,7 @@ static void wlc_phy_txpwrctrl_pwr_setup_
 						target_pwr_qtrdbm[tbl_id - 26] +
 						1);
 			}
-			regval[idx] = (uint32) pwr_est;
+			regval[idx] = (u32) pwr_est;
 		}
 		wlc_phy_table_write_nphy(pi, tbl_id, tbl_len, tbl_offset, 32,
 					 regval);
@@ -28764,10 +28764,10 @@ void wlc_phy_txpwr_papd_cal_nphy(phy_inf
 	    && (pi->nphy_force_papd_cal
 		|| (wlc_phy_txpwr_ison_nphy(pi)
 		    &&
-		    (((uint32)
+		    (((u32)
 		      ABS(wlc_phy_txpwr_idx_cur_get_nphy(pi, 0) -
 			  pi->nphy_papd_tx_gain_at_last_cal[0]) >= 4)
-		     || ((uint32)
+		     || ((u32)
 			 ABS(wlc_phy_txpwr_idx_cur_get_nphy(pi, 1) -
 			     pi->nphy_papd_tx_gain_at_last_cal[1]) >= 4))))) {
 		wlc_phy_a4(pi, TRUE);
@@ -28779,8 +28779,8 @@ void wlc_phy_txpwrctrl_enable_nphy(phy_i
 	u16 mask = 0, val = 0, ishw = 0;
 	u8 ctr;
 	uint core;
-	uint32 tbl_offset;
-	uint32 tbl_len;
+	u32 tbl_offset;
+	u32 tbl_len;
 	u16 regval[84];
 
 	if (pi->phyhang_avoid)
@@ -28926,12 +28926,12 @@ wlc_phy_txpwr_index_nphy(phy_info_t *pi,
 	u8 core, txpwrctl_tbl;
 	u16 tx_ind0, iq_ind0, lo_ind0;
 	u16 m1m2;
-	uint32 txgain;
+	u32 txgain;
 	u16 rad_gain, dac_gain;
 	u8 bbmult;
-	uint32 iqcomp;
+	u32 iqcomp;
 	u16 iqcomp_a, iqcomp_b;
-	uint32 locomp;
+	u32 locomp;
 	u16 tmpval;
 	u8 tx_pwr_ctrl_state;
 	int32 rfpwr_offset;
--- a/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c
@@ -19,7 +19,7 @@
 #include <wlc_phy_int.h>
 #include <wlc_phytbl_lcn.h>
 
-const uint32 dot11lcn_gain_tbl_rev0[] = {
+const u32 dot11lcn_gain_tbl_rev0[] = {
 	0x00000000,
 	0x00000000,
 	0x00000000,
@@ -118,7 +118,7 @@ const uint32 dot11lcn_gain_tbl_rev0[] =
 	0x00000000,
 };
 
-const uint32 dot11lcn_gain_tbl_rev1[] = {
+const u32 dot11lcn_gain_tbl_rev1[] = {
 	0x00000000,
 	0x00000000,
 	0x00000000,
@@ -258,7 +258,7 @@ const u16 dot11lcn_aux_gain_idx_tbl_rev0
 	0x0000,
 };
 
-const uint32 dot11lcn_gain_idx_tbl_rev0[] = {
+const u32 dot11lcn_gain_idx_tbl_rev0[] = {
 	0x00000000,
 	0x00000000,
 	0x10000000,
@@ -521,7 +521,7 @@ const u8 dot11lcn_gain_val_tbl_2G[] = {
 	0x00
 };
 
-const uint32 dot11lcn_gain_idx_tbl_2G[] = {
+const u32 dot11lcn_gain_idx_tbl_2G[] = {
 	0x00000000,
 	0x00000000,
 	0x00000000,
@@ -676,7 +676,7 @@ const uint32 dot11lcn_gain_idx_tbl_2G[]
 	0x00000000
 };
 
-const uint32 dot11lcn_gain_tbl_2G[] = {
+const u32 dot11lcn_gain_tbl_2G[] = {
 	0x00000000,
 	0x00000004,
 	0x00000008,
@@ -775,7 +775,7 @@ const uint32 dot11lcn_gain_tbl_2G[] = {
 	0x00000000
 };
 
-const uint32 dot11lcn_gain_tbl_extlna_2G[] = {
+const u32 dot11lcn_gain_tbl_extlna_2G[] = {
 	0x00000000,
 	0x00000004,
 	0x00000008,
@@ -986,7 +986,7 @@ const u8 dot11lcn_gain_val_tbl_extlna_2G
 	0x00
 };
 
-const uint32 dot11lcn_gain_idx_tbl_extlna_2G[] = {
+const u32 dot11lcn_gain_idx_tbl_extlna_2G[] = {
 	0x00000000,
 	0x00000040,
 	0x00000000,
@@ -1141,7 +1141,7 @@ const uint32 dot11lcn_gain_idx_tbl_extln
 	0x00000000
 };
 
-const uint32 dot11lcn_aux_gain_idx_tbl_5G[] = {
+const u32 dot11lcn_aux_gain_idx_tbl_5G[] = {
 	0x0000,
 	0x0000,
 	0x0000,
@@ -1182,7 +1182,7 @@ const uint32 dot11lcn_aux_gain_idx_tbl_5
 	0x0000
 };
 
-const uint32 dot11lcn_gain_val_tbl_5G[] = {
+const u32 dot11lcn_gain_val_tbl_5G[] = {
 	0xf7,
 	0xfd,
 	0x00,
@@ -1253,7 +1253,7 @@ const uint32 dot11lcn_gain_val_tbl_5G[]
 	0x00
 };
 
-const uint32 dot11lcn_gain_idx_tbl_5G[] = {
+const u32 dot11lcn_gain_idx_tbl_5G[] = {
 	0x00000000,
 	0x00000000,
 	0x00000000,
@@ -1408,7 +1408,7 @@ const uint32 dot11lcn_gain_idx_tbl_5G[]
 	0x00000000
 };
 
-const uint32 dot11lcn_gain_tbl_5G[] = {
+const u32 dot11lcn_gain_tbl_5G[] = {
 	0x00000000,
 	0x00000040,
 	0x00000080,
@@ -1609,19 +1609,19 @@ const dot11lcnphytbl_info_t dot11lcnphyt
 	 17, 0, 8}
 };
 
-const uint32 dot11lcnphytbl_rx_gain_info_sz_rev0 =
+const u32 dot11lcnphytbl_rx_gain_info_sz_rev0 =
     sizeof(dot11lcnphytbl_rx_gain_info_rev0) /
     sizeof(dot11lcnphytbl_rx_gain_info_rev0[0]);
 
-const uint32 dot11lcnphytbl_rx_gain_info_sz_rev1 =
+const u32 dot11lcnphytbl_rx_gain_info_sz_rev1 =
     sizeof(dot11lcnphytbl_rx_gain_info_rev1) /
     sizeof(dot11lcnphytbl_rx_gain_info_rev1[0]);
 
-const uint32 dot11lcnphytbl_rx_gain_info_2G_rev2_sz =
+const u32 dot11lcnphytbl_rx_gain_info_2G_rev2_sz =
     sizeof(dot11lcnphytbl_rx_gain_info_2G_rev2) /
     sizeof(dot11lcnphytbl_rx_gain_info_2G_rev2[0]);
 
-const uint32 dot11lcnphytbl_rx_gain_info_5G_rev2_sz =
+const u32 dot11lcnphytbl_rx_gain_info_5G_rev2_sz =
     sizeof(dot11lcnphytbl_rx_gain_info_5G_rev2) /
     sizeof(dot11lcnphytbl_rx_gain_info_5G_rev2[0]);
 
@@ -1759,7 +1759,7 @@ const u16 dot11lcn_noise_scale_tbl_rev0[
 	0x0000,
 };
 
-const uint32 dot11lcn_fltr_ctrl_tbl_rev0[] = {
+const u32 dot11lcn_fltr_ctrl_tbl_rev0[] = {
 	0x000141f8,
 	0x000021f8,
 	0x000021fb,
@@ -1772,7 +1772,7 @@ const uint32 dot11lcn_fltr_ctrl_tbl_rev0
 	0x0000024b,
 };
 
-const uint32 dot11lcn_ps_ctrl_tbl_rev0[] = {
+const u32 dot11lcn_ps_ctrl_tbl_rev0[] = {
 	0x00100001,
 	0x00200010,
 	0x00300001,
@@ -2612,7 +2612,7 @@ const u16 dot11lcn_iq_local_tbl_rev0[] =
 	0x0000,
 };
 
-const uint32 dot11lcn_papd_compdelta_tbl_rev0[] = {
+const u32 dot11lcn_papd_compdelta_tbl_rev0[] = {
 	0x00080000,
 	0x00080000,
 	0x00080000,
@@ -2858,7 +2858,7 @@ const dot11lcnphytbl_info_t dot11lcn_sw_
 	    sizeof(dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0[0]), 15, 0, 16
 };
 
-const uint32 dot11lcnphytbl_info_sz_rev0 =
+const u32 dot11lcnphytbl_info_sz_rev0 =
     sizeof(dot11lcnphytbl_info_rev0) / sizeof(dot11lcnphytbl_info_rev0[0]);
 
 const lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_extPA_gaintable_rev0[128] = {
--- a/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.h
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.h
@@ -17,19 +17,19 @@
 typedef phytbl_info_t dot11lcnphytbl_info_t;
 
 extern const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev0[];
-extern const uint32 dot11lcnphytbl_rx_gain_info_sz_rev0;
+extern const u32 dot11lcnphytbl_rx_gain_info_sz_rev0;
 extern const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313;
 extern const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_epa;
 extern const dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_epa_combo;
 
 extern const dot11lcnphytbl_info_t dot11lcnphytbl_info_rev0[];
-extern const uint32 dot11lcnphytbl_info_sz_rev0;
+extern const u32 dot11lcnphytbl_info_sz_rev0;
 
 extern const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_2G_rev2[];
-extern const uint32 dot11lcnphytbl_rx_gain_info_2G_rev2_sz;
+extern const u32 dot11lcnphytbl_rx_gain_info_2G_rev2_sz;
 
 extern const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_5G_rev2[];
-extern const uint32 dot11lcnphytbl_rx_gain_info_5G_rev2_sz;
+extern const u32 dot11lcnphytbl_rx_gain_info_5G_rev2_sz;
 
 extern const dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_2G_rev2[];
 
--- a/drivers/staging/brcm80211/phy/wlc_phytbl_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_n.c
@@ -19,7 +19,7 @@
 #include <wlc_phy_int.h>
 #include <wlc_phytbl_n.h>
 
-const uint32 frame_struct_rev0[] = {
+const u32 frame_struct_rev0[] = {
 	0x08004a04,
 	0x00100000,
 	0x01000a05,
@@ -889,7 +889,7 @@ const u8 frame_lut_rev0[] = {
 	0x2a,
 };
 
-const uint32 tmap_tbl_rev0[] = {
+const u32 tmap_tbl_rev0[] = {
 	0x8a88aa80,
 	0x8aaaaa8a,
 	0x8a8a8aa8,
@@ -1340,7 +1340,7 @@ const uint32 tmap_tbl_rev0[] = {
 	0x00000000,
 };
 
-const uint32 tdtrn_tbl_rev0[] = {
+const u32 tdtrn_tbl_rev0[] = {
 	0x061c061c,
 	0x0050ee68,
 	0xf592fe36,
@@ -2047,7 +2047,7 @@ const uint32 tdtrn_tbl_rev0[] = {
 	0x00f006be,
 };
 
-const uint32 intlv_tbl_rev0[] = {
+const u32 intlv_tbl_rev0[] = {
 	0x00802070,
 	0x0671188d,
 	0x0a60192c,
@@ -2148,7 +2148,7 @@ const u16 pilot_tbl_rev0[] = {
 	0xffff,
 };
 
-const uint32 pltlut_tbl_rev0[] = {
+const u32 pltlut_tbl_rev0[] = {
 	0x76540123,
 	0x62407351,
 	0x76543201,
@@ -2157,7 +2157,7 @@ const uint32 pltlut_tbl_rev0[] = {
 	0x76430521,
 };
 
-const uint32 tdi_tbl20_ant0_rev0[] = {
+const u32 tdi_tbl20_ant0_rev0[] = {
 	0x00091226,
 	0x000a1429,
 	0x000b56ad,
@@ -2215,7 +2215,7 @@ const uint32 tdi_tbl20_ant0_rev0[] = {
 	0x00000000,
 };
 
-const uint32 tdi_tbl20_ant1_rev0[] = {
+const u32 tdi_tbl20_ant1_rev0[] = {
 	0x00014b26,
 	0x00028d29,
 	0x000393ad,
@@ -2273,7 +2273,7 @@ const uint32 tdi_tbl20_ant1_rev0[] = {
 	0x00000000,
 };
 
-const uint32 tdi_tbl40_ant0_rev0[] = {
+const u32 tdi_tbl40_ant0_rev0[] = {
 	0x0011a346,
 	0x00136ccf,
 	0x0014f5d9,
@@ -2386,7 +2386,7 @@ const uint32 tdi_tbl40_ant0_rev0[] = {
 	0x00000000,
 };
 
-const uint32 tdi_tbl40_ant1_rev0[] = {
+const u32 tdi_tbl40_ant1_rev0[] = {
 	0x001edb36,
 	0x000129ca,
 	0x0002b353,
@@ -2508,7 +2508,7 @@ const u16 bdi_tbl_rev0[] = {
 	0x04d2,
 };
 
-const uint32 chanest_tbl_rev0[] = {
+const u32 chanest_tbl_rev0[] = {
 	0x44444444,
 	0x44444444,
 	0x44444444,
@@ -2738,7 +2738,7 @@ const u8 mcs_tbl_rev0[] = {
 	0x00,
 };
 
-const uint32 noise_var_tbl0_rev0[] = {
+const u32 noise_var_tbl0_rev0[] = {
 	0x020c020c,
 	0x0000014d,
 	0x020c020c,
@@ -2997,7 +2997,7 @@ const uint32 noise_var_tbl0_rev0[] = {
 	0x0000014d,
 };
 
-const uint32 noise_var_tbl1_rev0[] = {
+const u32 noise_var_tbl1_rev0[] = {
 	0x020c020c,
 	0x0000014d,
 	0x020c020c,
@@ -3652,7 +3652,7 @@ const u8 adj_pwr_lut_core1_rev0[] = {
 	0x00,
 };
 
-const uint32 gainctrl_lut_core0_rev0[] = {
+const u32 gainctrl_lut_core0_rev0[] = {
 	0x03cc2b44,
 	0x03cc2b42,
 	0x03cc2b40,
@@ -3783,7 +3783,7 @@ const uint32 gainctrl_lut_core0_rev0[] =
 	0x00002b00,
 };
 
-const uint32 gainctrl_lut_core1_rev0[] = {
+const u32 gainctrl_lut_core1_rev0[] = {
 	0x03cc2b44,
 	0x03cc2b42,
 	0x03cc2b40,
@@ -3914,7 +3914,7 @@ const uint32 gainctrl_lut_core1_rev0[] =
 	0x00002b00,
 };
 
-const uint32 iq_lut_core0_rev0[] = {
+const u32 iq_lut_core0_rev0[] = {
 	0x0000007f,
 	0x0000007f,
 	0x0000007f,
@@ -4045,7 +4045,7 @@ const uint32 iq_lut_core0_rev0[] = {
 	0x0000007f,
 };
 
-const uint32 iq_lut_core1_rev0[] = {
+const u32 iq_lut_core1_rev0[] = {
 	0x0000007f,
 	0x0000007f,
 	0x0000007f,
@@ -4536,9 +4536,9 @@ const mimophytbl_info_t mimophytbl_info_
 	,
 };
 
-const uint32 mimophytbl_info_sz_rev0 =
+const u32 mimophytbl_info_sz_rev0 =
     sizeof(mimophytbl_info_rev0) / sizeof(mimophytbl_info_rev0[0]);
-const uint32 mimophytbl_info_sz_rev0_volatile =
+const u32 mimophytbl_info_sz_rev0_volatile =
     sizeof(mimophytbl_info_rev0_volatile) /
     sizeof(mimophytbl_info_rev0_volatile[0]);
 
@@ -4682,7 +4682,7 @@ const u16 ant_swctrl_tbl_rev3_3[] = {
 	0x3cc
 };
 
-const uint32 frame_struct_rev3[] = {
+const u32 frame_struct_rev3[] = {
 	0x08004a04,
 	0x00100000,
 	0x01000a05,
@@ -5608,7 +5608,7 @@ const u16 pilot_tbl_rev3[] = {
 	0xffff,
 };
 
-const uint32 tmap_tbl_rev3[] = {
+const u32 tmap_tbl_rev3[] = {
 	0x8a88aa80,
 	0x8aaaaa8a,
 	0x8a8a8aa8,
@@ -6059,7 +6059,7 @@ const uint32 tmap_tbl_rev3[] = {
 	0x00000000,
 };
 
-const uint32 intlv_tbl_rev3[] = {
+const u32 intlv_tbl_rev3[] = {
 	0x00802070,
 	0x0671188d,
 	0x0a60192c,
@@ -6069,7 +6069,7 @@ const uint32 intlv_tbl_rev3[] = {
 	0x00000070,
 };
 
-const uint32 tdtrn_tbl_rev3[] = {
+const u32 tdtrn_tbl_rev3[] = {
 	0x061c061c,
 	0x0050ee68,
 	0xf592fe36,
@@ -6776,7 +6776,7 @@ const uint32 tdtrn_tbl_rev3[] = {
 	0x00f006be,
 };
 
-const uint32 noise_var_tbl_rev3[] = {
+const u32 noise_var_tbl_rev3[] = {
 	0x02110211,
 	0x0000014d,
 	0x02110211,
@@ -7166,7 +7166,7 @@ const u16 mcs_tbl_rev3[] = {
 	0x0007,
 };
 
-const uint32 tdi_tbl20_ant0_rev3[] = {
+const u32 tdi_tbl20_ant0_rev3[] = {
 	0x00091226,
 	0x000a1429,
 	0x000b56ad,
@@ -7224,7 +7224,7 @@ const uint32 tdi_tbl20_ant0_rev3[] = {
 	0x00000000,
 };
 
-const uint32 tdi_tbl20_ant1_rev3[] = {
+const u32 tdi_tbl20_ant1_rev3[] = {
 	0x00014b26,
 	0x00028d29,
 	0x000393ad,
@@ -7282,7 +7282,7 @@ const uint32 tdi_tbl20_ant1_rev3[] = {
 	0x00000000,
 };
 
-const uint32 tdi_tbl40_ant0_rev3[] = {
+const u32 tdi_tbl40_ant0_rev3[] = {
 	0x0011a346,
 	0x00136ccf,
 	0x0014f5d9,
@@ -7395,7 +7395,7 @@ const uint32 tdi_tbl40_ant0_rev3[] = {
 	0x00000000,
 };
 
-const uint32 tdi_tbl40_ant1_rev3[] = {
+const u32 tdi_tbl40_ant1_rev3[] = {
 	0x001edb36,
 	0x000129ca,
 	0x0002b353,
@@ -7508,7 +7508,7 @@ const uint32 tdi_tbl40_ant1_rev3[] = {
 	0x00000000,
 };
 
-const uint32 pltlut_tbl_rev3[] = {
+const u32 pltlut_tbl_rev3[] = {
 	0x76540213,
 	0x62407351,
 	0x76543210,
@@ -7517,7 +7517,7 @@ const uint32 pltlut_tbl_rev3[] = {
 	0x76430521,
 };
 
-const uint32 chanest_tbl_rev3[] = {
+const u32 chanest_tbl_rev3[] = {
 	0x44444444,
 	0x44444444,
 	0x44444444,
@@ -8047,7 +8047,7 @@ const u8 adj_pwr_lut_core1_rev3[] = {
 	0x00,
 };
 
-const uint32 gainctrl_lut_core0_rev3[] = {
+const u32 gainctrl_lut_core0_rev3[] = {
 	0x5bf70044,
 	0x5bf70042,
 	0x5bf70040,
@@ -8178,7 +8178,7 @@ const uint32 gainctrl_lut_core0_rev3[] =
 	0x5b07001c,
 };
 
-const uint32 gainctrl_lut_core1_rev3[] = {
+const u32 gainctrl_lut_core1_rev3[] = {
 	0x5bf70044,
 	0x5bf70042,
 	0x5bf70040,
@@ -8309,7 +8309,7 @@ const uint32 gainctrl_lut_core1_rev3[] =
 	0x5b07001c,
 };
 
-const uint32 iq_lut_core0_rev3[] = {
+const u32 iq_lut_core0_rev3[] = {
 	0x00000000,
 	0x00000000,
 	0x00000000,
@@ -8440,7 +8440,7 @@ const uint32 iq_lut_core0_rev3[] = {
 	0x00000000,
 };
 
-const uint32 iq_lut_core1_rev3[] = {
+const u32 iq_lut_core1_rev3[] = {
 	0x00000000,
 	0x00000000,
 	0x00000000,
@@ -9095,7 +9095,7 @@ const u16 papd_comp_rfpwr_tbl_core1_rev3
 	0x01d6,
 };
 
-const uint32 papd_comp_epsilon_tbl_core0_rev3[] = {
+const u32 papd_comp_epsilon_tbl_core0_rev3[] = {
 	0x00000000,
 	0x00001fa0,
 	0x00019f78,
@@ -9162,7 +9162,7 @@ const uint32 papd_comp_epsilon_tbl_core0
 	0x03e38ffe,
 };
 
-const uint32 papd_cal_scalars_tbl_core0_rev3[] = {
+const u32 papd_cal_scalars_tbl_core0_rev3[] = {
 	0x05af005a,
 	0x0571005e,
 	0x05040066,
@@ -9229,7 +9229,7 @@ const uint32 papd_cal_scalars_tbl_core0_
 	0x002606a4,
 };
 
-const uint32 papd_comp_epsilon_tbl_core1_rev3[] = {
+const u32 papd_comp_epsilon_tbl_core1_rev3[] = {
 	0x00000000,
 	0x00001fa0,
 	0x00019f78,
@@ -9296,7 +9296,7 @@ const uint32 papd_comp_epsilon_tbl_core1
 	0x03e38ffe,
 };
 
-const uint32 papd_cal_scalars_tbl_core1_rev3[] = {
+const u32 papd_cal_scalars_tbl_core1_rev3[] = {
 	0x05af005a,
 	0x0571005e,
 	0x05040066,
@@ -9476,22 +9476,22 @@ const mimophytbl_info_t mimophytbl_info_
 	 16}
 };
 
-const uint32 mimophytbl_info_sz_rev3 =
+const u32 mimophytbl_info_sz_rev3 =
     sizeof(mimophytbl_info_rev3) / sizeof(mimophytbl_info_rev3[0]);
-const uint32 mimophytbl_info_sz_rev3_volatile =
+const u32 mimophytbl_info_sz_rev3_volatile =
     sizeof(mimophytbl_info_rev3_volatile) /
     sizeof(mimophytbl_info_rev3_volatile[0]);
-const uint32 mimophytbl_info_sz_rev3_volatile1 =
+const u32 mimophytbl_info_sz_rev3_volatile1 =
     sizeof(mimophytbl_info_rev3_volatile1) /
     sizeof(mimophytbl_info_rev3_volatile1[0]);
-const uint32 mimophytbl_info_sz_rev3_volatile2 =
+const u32 mimophytbl_info_sz_rev3_volatile2 =
     sizeof(mimophytbl_info_rev3_volatile2) /
     sizeof(mimophytbl_info_rev3_volatile2[0]);
-const uint32 mimophytbl_info_sz_rev3_volatile3 =
+const u32 mimophytbl_info_sz_rev3_volatile3 =
     sizeof(mimophytbl_info_rev3_volatile3) /
     sizeof(mimophytbl_info_rev3_volatile3[0]);
 
-const uint32 tmap_tbl_rev7[] = {
+const u32 tmap_tbl_rev7[] = {
 	0x8a88aa80,
 	0x8aaaaa8a,
 	0x8a8a8aa8,
@@ -9942,7 +9942,7 @@ const uint32 tmap_tbl_rev7[] = {
 	0x00000000,
 };
 
-const uint32 noise_var_tbl_rev7[] = {
+const u32 noise_var_tbl_rev7[] = {
 	0x020c020c,
 	0x0000014d,
 	0x020c020c,
@@ -10201,7 +10201,7 @@ const uint32 noise_var_tbl_rev7[] = {
 	0x0000014d,
 };
 
-const uint32 papd_comp_epsilon_tbl_core0_rev7[] = {
+const u32 papd_comp_epsilon_tbl_core0_rev7[] = {
 	0x00000000,
 	0x00000000,
 	0x00016023,
@@ -10268,7 +10268,7 @@ const uint32 papd_comp_epsilon_tbl_core0
 	0x0156cfff,
 };
 
-const uint32 papd_cal_scalars_tbl_core0_rev7[] = {
+const u32 papd_cal_scalars_tbl_core0_rev7[] = {
 	0x0b5e002d,
 	0x0ae2002f,
 	0x0a3b0032,
@@ -10335,7 +10335,7 @@ const uint32 papd_cal_scalars_tbl_core0_
 	0x004e068c,
 };
 
-const uint32 papd_comp_epsilon_tbl_core1_rev7[] = {
+const u32 papd_comp_epsilon_tbl_core1_rev7[] = {
 	0x00000000,
 	0x00000000,
 	0x00016023,
@@ -10402,7 +10402,7 @@ const uint32 papd_comp_epsilon_tbl_core1
 	0x0156cfff,
 };
 
-const uint32 papd_cal_scalars_tbl_core1_rev7[] = {
+const u32 papd_cal_scalars_tbl_core1_rev7[] = {
 	0x0b5e002d,
 	0x0ae2002f,
 	0x0a3b0032,
@@ -10580,7 +10580,7 @@ const mimophytbl_info_t mimophytbl_info_
 	,
 };
 
-const uint32 mimophytbl_info_sz_rev7 =
+const u32 mimophytbl_info_sz_rev7 =
     sizeof(mimophytbl_info_rev7) / sizeof(mimophytbl_info_rev7[0]);
 
 const mimophytbl_info_t mimophytbl_info_rev16[] = {
@@ -10627,5 +10627,5 @@ const mimophytbl_info_t mimophytbl_info_
 	,
 };
 
-const uint32 mimophytbl_info_sz_rev16 =
+const u32 mimophytbl_info_sz_rev16 =
     sizeof(mimophytbl_info_rev16) / sizeof(mimophytbl_info_rev16[0]);
--- a/drivers/staging/brcm80211/phy/wlc_phytbl_n.h
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_n.h
@@ -20,20 +20,20 @@ typedef phytbl_info_t mimophytbl_info_t;
 
 extern const mimophytbl_info_t mimophytbl_info_rev0[],
     mimophytbl_info_rev0_volatile[];
-extern const uint32 mimophytbl_info_sz_rev0, mimophytbl_info_sz_rev0_volatile;
+extern const u32 mimophytbl_info_sz_rev0, mimophytbl_info_sz_rev0_volatile;
 
 extern const mimophytbl_info_t mimophytbl_info_rev3[],
     mimophytbl_info_rev3_volatile[], mimophytbl_info_rev3_volatile1[],
     mimophytbl_info_rev3_volatile2[], mimophytbl_info_rev3_volatile3[];
-extern const uint32 mimophytbl_info_sz_rev3, mimophytbl_info_sz_rev3_volatile,
+extern const u32 mimophytbl_info_sz_rev3, mimophytbl_info_sz_rev3_volatile,
     mimophytbl_info_sz_rev3_volatile1, mimophytbl_info_sz_rev3_volatile2,
     mimophytbl_info_sz_rev3_volatile3;
 
-extern const uint32 noise_var_tbl_rev3[];
+extern const u32 noise_var_tbl_rev3[];
 
 extern const mimophytbl_info_t mimophytbl_info_rev7[];
-extern const uint32 mimophytbl_info_sz_rev7;
-extern const uint32 noise_var_tbl_rev7[];
+extern const u32 mimophytbl_info_sz_rev7;
+extern const u32 noise_var_tbl_rev7[];
 
 extern const mimophytbl_info_t mimophytbl_info_rev16[];
-extern const uint32 mimophytbl_info_sz_rev16;
+extern const u32 mimophytbl_info_sz_rev16;
--- a/drivers/staging/brcm80211/sys/wl_dbg.h
+++ b/drivers/staging/brcm80211/sys/wl_dbg.h
@@ -18,7 +18,7 @@
 #define _wl_dbg_h_
 
 /* wl_msg_level is a bit vector with defs in wlioctl.h */
-extern uint32 wl_msg_level;
+extern u32 wl_msg_level;
 
 #define WL_PRINT(args)		printf args
 #define WL_NONE(args)
@@ -42,7 +42,7 @@ extern uint32 wl_msg_level;
 #define   WL_AMPDU_HWTXS_VAL    0x00000040	/* AMPDU_HWTXS */
 #define   WL_AMPDU_HWDBG_VAL    0x00000080	/* AMPDU_DBG */
 
-extern uint32 wl_ampdu_dbg;
+extern u32 wl_ampdu_dbg;
 
 #define WL_AMPDU_UPDN(args) do {if (wl_ampdu_dbg & WL_AMPDU_UPDN_VAL) {WL_AMPDU(args); } } while (0)
 #define WL_AMPDU_RX(args) do {if (wl_ampdu_dbg & WL_AMPDU_RX_VAL) {WL_AMPDU(args); } } while (0)
--- a/drivers/staging/brcm80211/sys/wl_export.h
+++ b/drivers/staging/brcm80211/sys/wl_export.h
@@ -24,11 +24,11 @@ struct wlc_if;
 extern void wl_init(struct wl_info *wl);
 extern uint wl_reset(struct wl_info *wl);
 extern void wl_intrson(struct wl_info *wl);
-extern uint32 wl_intrsoff(struct wl_info *wl);
-extern void wl_intrsrestore(struct wl_info *wl, uint32 macintmask);
+extern u32 wl_intrsoff(struct wl_info *wl);
+extern void wl_intrsrestore(struct wl_info *wl, u32 macintmask);
 extern void wl_event(struct wl_info *wl, char *ifname, wlc_event_t *e);
 extern void wl_event_sendup(struct wl_info *wl, const wlc_event_t *e,
-			    u8 *data, uint32 len);
+			    u8 *data, u32 len);
 extern int wl_up(struct wl_info *wl);
 extern void wl_down(struct wl_info *wl);
 extern void wl_txflowcontrol(struct wl_info *wl, struct wl_if *wlif, bool state,
--- a/drivers/staging/brcm80211/sys/wl_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.c
@@ -475,7 +475,7 @@ wl_ops_bss_info_changed(struct ieee80211
 	}
 	if (changed & BSS_CHANGED_BASIC_RATES) {
 		WL_NONE(("Need to change Basic Rates:\t0x%x! Implement me\n",
-			 (uint32) info->basic_rates));
+			 (u32) info->basic_rates));
 		/* Basic rateset changed */
 	}
 	if (changed & BSS_CHANGED_BEACON_INT) {
@@ -982,8 +982,8 @@ fail1:
 }
 
 #ifdef WLC_HIGH_ONLY
-static void *wl_dbus_probe_cb(void *arg, const char *desc, uint32 bustype,
-			      uint32 hdrlen)
+static void *wl_dbus_probe_cb(void *arg, const char *desc, u32 bustype,
+			      u32 hdrlen)
 {
 	wl_info_t *wl;
 	WL_ERROR(("%s:\n", __func__));
@@ -1305,7 +1305,7 @@ wl_pci_probe(struct pci_dev *pdev, const
 	int rc;
 	wl_info_t *wl;
 	struct ieee80211_hw *hw;
-	uint32 val;
+	u32 val;
 
 	ASSERT(pdev);
 
@@ -1388,7 +1388,7 @@ static int wl_resume(struct pci_dev *pde
 	wl_info_t *wl;
 	struct ieee80211_hw *hw;
 	int err = 0;
-	uint32 val;
+	u32 val;
 
 	WL_TRACE(("wl: wl_resume\n"));
 	hw = pci_get_drvdata(pdev);
@@ -1485,7 +1485,7 @@ static int __init wl_module_init(void)
 	}
 #ifndef WLC_HIGH_ONLY
 	{
-		extern uint32 phyhal_msg_level;
+		extern u32 phyhal_msg_level;
 
 		if (phymsglevel != 0xdeadbeef)
 			phyhal_msg_level = phymsglevel;
@@ -1727,11 +1727,11 @@ bool wl_alloc_dma_resources(wl_info_t *w
 	return TRUE;
 }
 
-uint32 BCMFASTPATH wl_intrsoff(wl_info_t *wl)
+u32 BCMFASTPATH wl_intrsoff(wl_info_t *wl)
 {
 #if defined(WLC_LOW)
 	unsigned long flags;
-	uint32 status;
+	u32 status;
 
 	INT_LOCK(wl, flags);
 	status = wlc_intrsoff(wl->wlc);
@@ -1742,7 +1742,7 @@ uint32 BCMFASTPATH wl_intrsoff(wl_info_t
 #endif				/* WLC_LOW */
 }
 
-void wl_intrsrestore(wl_info_t *wl, uint32 macintmask)
+void wl_intrsrestore(wl_info_t *wl, u32 macintmask)
 {
 #if defined(WLC_LOW)
 	unsigned long flags;
@@ -2052,9 +2052,9 @@ static int wl_linux_watchdog(void *ctx)
 }
 
 struct wl_fw_hdr {
-	uint32 offset;
-	uint32 len;
-	uint32 idx;
+	u32 offset;
+	u32 len;
+	u32 idx;
 };
 
 #ifdef WLC_HIGH_ONLY
@@ -2249,7 +2249,7 @@ static void wl_rpc_dispatch_schedule(voi
 	bcm_xdr_buf_init(&b, bcm_rpc_buf_data(wl->rpc_th, buf),
 			 bcm_rpc_buf_len_get(wl->rpc_th, buf));
 
-	err = bcm_xdr_unpack_uint32(&b, &rpc_id);
+	err = bcm_xdr_unpack_u32(&b, &rpc_id);
 	ASSERT(!err);
 	WL_TRACE(("%s: Dispatch id %s\n", __func__,
 		  WLC_RPC_ID_LOOKUP(rpc_name_tbl, rpc_id)));
@@ -2283,7 +2283,7 @@ char *wl_firmwares[WL_MAX_FW] = {
 };
 
 #ifdef WLC_LOW
-int wl_ucode_init_buf(wl_info_t *wl, void **pbuf, uint32 idx)
+int wl_ucode_init_buf(wl_info_t *wl, void **pbuf, u32 idx)
 {
 	int i, entry;
 	const u8 *pdata;
@@ -2309,7 +2309,7 @@ int wl_ucode_init_buf(wl_info_t *wl, voi
 	return -1;
 }
 
-int wl_ucode_init_uint(wl_info_t *wl, uint32 *data, uint32 idx)
+int wl_ucode_init_uint(wl_info_t *wl, u32 *data, u32 idx)
 {
 	int i, entry;
 	const u8 *pdata;
@@ -2321,7 +2321,7 @@ int wl_ucode_init_uint(wl_info_t *wl, ui
 			if (hdr->idx == idx) {
 				pdata = wl->fw.fw_bin[i]->data + hdr->offset;
 				ASSERT(hdr->len == 4);
-				*data = *((uint32 *) pdata);
+				*data = *((u32 *) pdata);
 				return 0;
 			}
 		}
--- a/drivers/staging/brcm80211/sys/wl_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.h
@@ -53,17 +53,17 @@ struct wl_if {
 
 #define WL_MAX_FW		4
 struct wl_firmware {
-	uint32 fw_cnt;
+	u32 fw_cnt;
 	const struct firmware *fw_bin[WL_MAX_FW];
 	const struct firmware *fw_hdr[WL_MAX_FW];
-	uint32 hdr_num_entries[WL_MAX_FW];
+	u32 hdr_num_entries[WL_MAX_FW];
 };
 
 struct wl_info {
 	wlc_pub_t *pub;		/* pointer to public wlc state */
 	void *wlc;		/* pointer to private common os-independent data */
 	osl_t *osh;		/* pointer to os handler */
-	uint32 magic;
+	u32 magic;
 
 	int irq;
 
@@ -85,7 +85,7 @@ struct wl_info {
 #endif				/* BCMSDIO */
 	bool resched;		/* dpc needs to be and is rescheduled */
 #ifdef LINUXSTA_PS
-	uint32 pci_psstate[16];	/* pci ps-state save/restore */
+	u32 pci_psstate[16];	/* pci ps-state save/restore */
 #endif
 	/* RPC, handle, lock, txq, workitem */
 #ifdef WLC_HIGH_ONLY
@@ -154,8 +154,8 @@ extern int wl_ucode_data_init(wl_info_t
 extern void wl_ucode_data_free(void);
 #ifdef WLC_LOW
 extern void wl_ucode_free_buf(void *);
-extern int wl_ucode_init_buf(wl_info_t *wl, void **pbuf, uint32 idx);
-extern int wl_ucode_init_uint(wl_info_t *wl, uint32 *data, uint32 idx);
+extern int wl_ucode_init_buf(wl_info_t *wl, void **pbuf, u32 idx);
+extern int wl_ucode_init_uint(wl_info_t *wl, u32 *data, u32 idx);
 #endif				/* WLC_LOW */
 
 #endif				/* _wl_mac80211_h_ */
--- a/drivers/staging/brcm80211/sys/wl_ucode.h
+++ b/drivers/staging/brcm80211/sys/wl_ucode.h
@@ -18,7 +18,7 @@
 typedef struct d11init {
 	u16 addr;
 	u16 size;
-	uint32 value;
+	u32 value;
 } d11init_t;
 
 extern d11init_t *d11lcn0bsinitvals24;
@@ -30,9 +30,9 @@ extern d11init_t *d11lcn2initvals24;
 extern d11init_t *d11n0absinitvals16;
 extern d11init_t *d11n0bsinitvals16;
 extern d11init_t *d11n0initvals16;
-extern uint32 *bcm43xx_16_mimo;
-extern uint32 bcm43xx_16_mimosz;
-extern uint32 *bcm43xx_24_lcn;
-extern uint32 bcm43xx_24_lcnsz;
-extern uint32 *bcm43xx_bommajor;
-extern uint32 *bcm43xx_bomminor;
+extern u32 *bcm43xx_16_mimo;
+extern u32 bcm43xx_16_mimosz;
+extern u32 *bcm43xx_24_lcn;
+extern u32 bcm43xx_24_lcnsz;
+extern u32 *bcm43xx_bommajor;
+extern u32 *bcm43xx_bomminor;
--- a/drivers/staging/brcm80211/sys/wl_ucode_loader.c
+++ b/drivers/staging/brcm80211/sys/wl_ucode_loader.c
@@ -34,12 +34,12 @@ d11init_t *d11lcn2initvals24;
 d11init_t *d11n0absinitvals16;
 d11init_t *d11n0bsinitvals16;
 d11init_t *d11n0initvals16;
-uint32 *bcm43xx_16_mimo;
-uint32 bcm43xx_16_mimosz;
-uint32 *bcm43xx_24_lcn;
-uint32 bcm43xx_24_lcnsz;
-uint32 *bcm43xx_bommajor;
-uint32 *bcm43xx_bomminor;
+u32 *bcm43xx_16_mimo;
+u32 bcm43xx_16_mimosz;
+u32 *bcm43xx_24_lcn;
+u32 bcm43xx_24_lcnsz;
+u32 *bcm43xx_bommajor;
+u32 *bcm43xx_bomminor;
 
 int wl_ucode_data_init(wl_info_t *wl)
 {
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -74,7 +74,7 @@
 	+ DOT11_A4_HDR_LEN + DOT11_QOS_LEN + DOT11_IV_MAX_LEN)
 
 #ifdef BCMDBG
-uint32 wl_ampdu_dbg =
+u32 wl_ampdu_dbg =
     WL_AMPDU_UPDN_VAL |
     WL_AMPDU_ERR_VAL |
     WL_AMPDU_TX_VAL |
@@ -93,10 +93,10 @@ typedef struct wlc_fifo_info {
 	u16 ampdu_pld_size;	/* number of bytes to be pre-loaded */
 	u8 mcs2ampdu_table[FFPLD_MAX_MCS + 1];	/* per-mcs max # of mpdus in an ampdu */
 	u16 prev_txfunfl;	/* num of underflows last read from the HW macstats counter */
-	uint32 accum_txfunfl;	/* num of underflows since we modified pld params */
-	uint32 accum_txampdu;	/* num of tx ampdu since we modified pld params  */
-	uint32 prev_txampdu;	/* previous reading of tx ampdu */
-	uint32 dmaxferrate;	/* estimated dma avg xfer rate in kbits/sec */
+	u32 accum_txfunfl;	/* num of underflows since we modified pld params */
+	u32 accum_txampdu;	/* num of tx ampdu since we modified pld params  */
+	u32 prev_txampdu;	/* previous reading of tx ampdu */
+	u32 dmaxferrate;	/* estimated dma avg xfer rate in kbits/sec */
 } wlc_fifo_info_t;
 
 /* AMPDU module specific state */
@@ -116,11 +116,11 @@ struct ampdu_info {
 	u8 dur;		/* max duration of an ampdu (in msec) */
 	u8 txpkt_weight;	/* weight of ampdu in txfifo; reduces rate lag */
 	u8 rx_factor;	/* maximum rx ampdu factor (0-3) ==> 2^(13+x) bytes */
-	uint32 ffpld_rsvd;	/* number of bytes to reserve for preload */
-	uint32 max_txlen[MCS_TABLE_SIZE][2][2];	/* max size of ampdu per mcs, bw and sgi */
+	u32 ffpld_rsvd;	/* number of bytes to reserve for preload */
+	u32 max_txlen[MCS_TABLE_SIZE][2][2];	/* max size of ampdu per mcs, bw and sgi */
 	void *ini_free[AMPDU_INI_FREE];	/* array of ini's to be freed on detach */
 	bool mfbr;		/* enable multiple fallback rate */
-	uint32 tx_max_funl;	/* underflows should be kept such that
+	u32 tx_max_funl;	/* underflows should be kept such that
 				 * (tx_max_funfl*underflows) < tx frames
 				 */
 	wlc_fifo_info_t fifo_tb[NUM_FFPLD_FIFO];	/* table of fifo infos  */
@@ -155,8 +155,8 @@ static void scb_ampdu_update_config_all(
 
 static void wlc_ampdu_dotxstatus_complete(ampdu_info_t *ampdu, struct scb *scb,
 					  void *p, tx_status_t *txs,
-					  uint32 frmtxstatus,
-					  uint32 frmtxstatus2);
+					  u32 frmtxstatus,
+					  u32 frmtxstatus2);
 
 static inline u16 pkt_txh_seqnum(wlc_info_t *wlc, void *p)
 {
@@ -335,12 +335,12 @@ static void wlc_ffpld_init(ampdu_info_t
 static int wlc_ffpld_check_txfunfl(wlc_info_t *wlc, int fid)
 {
 	ampdu_info_t *ampdu = wlc->ampdu;
-	uint32 phy_rate = MCS_RATE(FFPLD_MAX_MCS, TRUE, FALSE);
-	uint32 txunfl_ratio;
+	u32 phy_rate = MCS_RATE(FFPLD_MAX_MCS, TRUE, FALSE);
+	u32 txunfl_ratio;
 	u8 max_mpdu;
-	uint32 current_ampdu_cnt = 0;
+	u32 current_ampdu_cnt = 0;
 	u16 max_pld_size;
-	uint32 new_txunfl;
+	u32 new_txunfl;
 	wlc_fifo_info_t *fifo = (ampdu->fifo_tb + fid);
 	uint xmtfifo_sz;
 	u16 cur_txunfl;
@@ -365,7 +365,7 @@ static int wlc_ffpld_check_txfunfl(wlc_i
 		return -1;
 	}
 
-	if ((TXFIFO_SIZE_UNIT * (uint32) xmtfifo_sz) <= ampdu->ffpld_rsvd)
+	if ((TXFIFO_SIZE_UNIT * (u32) xmtfifo_sz) <= ampdu->ffpld_rsvd)
 		return 1;
 
 	max_pld_size = TXFIFO_SIZE_UNIT * xmtfifo_sz - ampdu->ffpld_rsvd;
@@ -455,7 +455,7 @@ static int wlc_ffpld_check_txfunfl(wlc_i
 static void wlc_ffpld_calc_mcs2ampdu_table(ampdu_info_t *ampdu, int f)
 {
 	int i;
-	uint32 phy_rate, dma_rate, tmp;
+	u32 phy_rate, dma_rate, tmp;
 	u8 max_mpdu;
 	wlc_fifo_info_t *fifo = (ampdu->fifo_tb + f);
 
@@ -517,7 +517,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 	bool rr = TRUE, fbr = FALSE;
 	uint i, count = 0, fifo, seg_cnt = 0;
 	u16 plen, len, seq = 0, mcl, mch, index, frameid, dma_len = 0;
-	uint32 ampdu_len, maxlen = 0;
+	u32 ampdu_len, maxlen = 0;
 	d11txh_t *txh = NULL;
 	u8 *plcp;
 	struct dot11_header *h;
@@ -914,7 +914,7 @@ wlc_ampdu_dotxstatus(ampdu_info_t *ampdu
 	scb_ampdu_t *scb_ampdu;
 	wlc_info_t *wlc = ampdu->wlc;
 	scb_ampdu_tid_ini_t *ini;
-	uint32 s1 = 0, s2 = 0;
+	u32 s1 = 0, s2 = 0;
 	struct ieee80211_tx_info *tx_info;
 
 	tx_info = IEEE80211_SKB_CB(p);
@@ -969,7 +969,7 @@ wlc_ampdu_dotxstatus(ampdu_info_t *ampdu
 }
 
 #ifdef WLC_HIGH_ONLY
-void wlc_ampdu_txstatus_complete(ampdu_info_t *ampdu, uint32 s1, uint32 s2)
+void wlc_ampdu_txstatus_complete(ampdu_info_t *ampdu, u32 s1, u32 s2)
 {
 	WL_AMPDU_TX(("wl%d: wlc_ampdu_txstatus_complete: High Recvd 0x%x 0x%x p:%p\n", ampdu->wlc->pub->unit, s1, s2, ampdu->p));
 
@@ -1017,7 +1017,7 @@ extern void wlc_txq_enq(wlc_info_t *wlc,
 
 static void BCMFASTPATH
 wlc_ampdu_dotxstatus_complete(ampdu_info_t *ampdu, struct scb *scb, void *p,
-			      tx_status_t *txs, uint32 s1, uint32 s2)
+			      tx_status_t *txs, u32 s1, u32 s2)
 {
 	scb_ampdu_t *scb_ampdu;
 	wlc_info_t *wlc = ampdu->wlc;
@@ -1325,7 +1325,7 @@ bool wlc_ampdu_cap(ampdu_info_t *ampdu)
 
 static void ampdu_update_max_txlen(ampdu_info_t *ampdu, u8 dur)
 {
-	uint32 rate, mcs;
+	u32 rate, mcs;
 
 	for (mcs = 0; mcs < MCS_TABLE_SIZE; mcs++) {
 		/* rate is in Kbps; dur is in msec ==> len = (rate * dur) / 8 */
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.h
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.h
@@ -33,8 +33,8 @@ extern u8 wlc_ampdu_null_delim_cnt(ampdu
 				      ratespec_t rspec, int phylen);
 extern void scb_ampdu_cleanup(ampdu_info_t *ampdu, struct scb *scb);
 #ifdef WLC_HIGH_ONLY
-extern void wlc_ampdu_txstatus_complete(ampdu_info_t *ampdu, uint32 s1,
-					uint32 s2);
+extern void wlc_ampdu_txstatus_complete(ampdu_info_t *ampdu, u32 s1,
+					u32 s2);
 #endif
 
 #endif				/* _wlc_ampdu_h_ */
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -119,14 +119,14 @@ static void wlc_coreinit(wlc_info_t *wlc
 
 /* used by wlc_wakeucode_init() */
 static void wlc_write_inits(wlc_hw_info_t *wlc_hw, const d11init_t *inits);
-static void wlc_ucode_write(wlc_hw_info_t *wlc_hw, const uint32 ucode[],
+static void wlc_ucode_write(wlc_hw_info_t *wlc_hw, const u32 ucode[],
 			    const uint nbytes);
 static void wlc_ucode_download(wlc_hw_info_t *wlc);
 static void wlc_ucode_txant_set(wlc_hw_info_t *wlc_hw);
 
 /* used by wlc_dpc() */
 static bool wlc_bmac_dotxstatus(wlc_hw_info_t *wlc, tx_status_t *txs,
-				uint32 s2);
+				u32 s2);
 static bool wlc_bmac_txstatus_corerev4(wlc_hw_info_t *wlc);
 static bool wlc_bmac_txstatus(wlc_hw_info_t *wlc, bool bound, bool *fatal);
 static bool wlc_bmac_recv(wlc_hw_info_t *wlc_hw, uint fifo, bool bound);
@@ -140,9 +140,9 @@ static void wlc_corerev_fifofixup(wlc_hw
 
 /* Low Level Prototypes */
 static u16 wlc_bmac_read_objmem(wlc_hw_info_t *wlc_hw, uint offset,
-				   uint32 sel);
+				   u32 sel);
 static void wlc_bmac_write_objmem(wlc_hw_info_t *wlc_hw, uint offset, u16 v,
-				  uint32 sel);
+				  u32 sel);
 static bool wlc_bmac_attach_dmapio(wlc_info_t *wlc, uint j, bool wme);
 static void wlc_bmac_detach_dmapio(wlc_hw_info_t *wlc_hw);
 static void wlc_ucode_bsinit(wlc_hw_info_t *wlc_hw);
@@ -153,15 +153,15 @@ static void wlc_mhfdef(wlc_info_t *wlc,
 static void wlc_mctrl_write(wlc_hw_info_t *wlc_hw);
 static void wlc_ucode_mute_override_set(wlc_hw_info_t *wlc_hw);
 static void wlc_ucode_mute_override_clear(wlc_hw_info_t *wlc_hw);
-static uint32 wlc_wlintrsoff(wlc_info_t *wlc);
-static void wlc_wlintrsrestore(wlc_info_t *wlc, uint32 macintmask);
+static u32 wlc_wlintrsoff(wlc_info_t *wlc);
+static void wlc_wlintrsrestore(wlc_info_t *wlc, u32 macintmask);
 static void wlc_gpio_init(wlc_info_t *wlc);
 static void wlc_write_hw_bcntemplate0(wlc_hw_info_t *wlc_hw, void *bcn,
 				      int len);
 static void wlc_write_hw_bcntemplate1(wlc_hw_info_t *wlc_hw, void *bcn,
 				      int len);
 static void wlc_bmac_bsinit(wlc_info_t *wlc, chanspec_t chanspec);
-static uint32 wlc_setband_inact(wlc_info_t *wlc, uint bandunit);
+static u32 wlc_setband_inact(wlc_info_t *wlc, uint bandunit);
 static void wlc_bmac_setband(wlc_hw_info_t *wlc_hw, uint bandunit,
 			     chanspec_t chanspec);
 static void wlc_bmac_update_slot_timing(wlc_hw_info_t *wlc_hw, bool shortslot);
@@ -233,11 +233,11 @@ static void WLBANDINITFN(wlc_ucode_bsini
 }
 
 /* switch to new band but leave it inactive */
-static uint32 WLBANDINITFN(wlc_setband_inact) (wlc_info_t *wlc, uint bandunit)
+static u32 WLBANDINITFN(wlc_setband_inact) (wlc_info_t *wlc, uint bandunit)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
-	uint32 macintmask;
-	uint32 tmp;
+	u32 macintmask;
+	u32 tmp;
 
 	WL_TRACE(("wl%d: wlc_setband_inact\n", wlc_hw->unit));
 
@@ -277,7 +277,7 @@ wlc_bmac_recv(wlc_hw_info_t *wlc_hw, uin
 	void *tail = NULL;
 	uint n = 0;
 	uint bound_limit = bound ? wlc_hw->wlc->pub->tunables->rxbnd : -1;
-	uint32 tsf_h, tsf_l;
+	u32 tsf_h, tsf_l;
 	wlc_d11rxhdr_t *wlc_rxhdr = NULL;
 
 	WL_TRACE(("wl%d: %s\n", wlc_hw->unit, __func__));
@@ -326,7 +326,7 @@ wlc_bmac_recv(wlc_hw_info_t *wlc_hw, uin
  */
 bool BCMFASTPATH wlc_dpc(wlc_info_t *wlc, bool bounded)
 {
-	uint32 macintstatus;
+	u32 macintstatus;
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
 	bool fatal = FALSE;
@@ -425,7 +425,7 @@ bool BCMFASTPATH wlc_dpc(wlc_info_t *wlc
 
 	if (macintstatus & MI_RFDISABLE) {
 #if defined(BCMDBG)
-		uint32 rfd = R_REG(wlc_hw->osh, &regs->phydebug) & PDBG_RFD;
+		u32 rfd = R_REG(wlc_hw->osh, &regs->phydebug) & PDBG_RFD;
 #endif
 
 		WL_ERROR(("wl%d: MAC Detected a change on the RF Disable Input 0x%x\n", wlc_hw->unit, rfd));
@@ -829,8 +829,8 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 		goto fail;
 	}
 	wlc_hw->sromrev = (u8) getintvar(vars, "sromrev");
-	wlc_hw->boardflags = (uint32) getintvar(vars, "boardflags");
-	wlc_hw->boardflags2 = (uint32) getintvar(vars, "boardflags2");
+	wlc_hw->boardflags = (u32) getintvar(vars, "boardflags");
+	wlc_hw->boardflags2 = (u32) getintvar(vars, "boardflags2");
 
 	if (D11REV_LE(wlc_hw->corerev, 4)
 	    || (wlc_hw->boardflags & BFL_NOPLLDOWN))
@@ -1140,7 +1140,7 @@ void BCMINITFN(wlc_bmac_reset) (wlc_hw_i
 void
 BCMINITFN(wlc_bmac_init) (wlc_hw_info_t *wlc_hw, chanspec_t chanspec,
 			  bool mute) {
-	uint32 macintmask;
+	u32 macintmask;
 	bool fastclk;
 	wlc_info_t *wlc = wlc_hw->wlc;
 
@@ -1597,10 +1597,10 @@ static void wlc_mctrl_reset(wlc_hw_info_
 }
 
 /* set or clear maccontrol bits */
-void wlc_bmac_mctrl(wlc_hw_info_t *wlc_hw, uint32 mask, uint32 val)
+void wlc_bmac_mctrl(wlc_hw_info_t *wlc_hw, u32 mask, u32 val)
 {
-	uint32 maccontrol;
-	uint32 new_maccontrol;
+	u32 maccontrol;
+	u32 new_maccontrol;
 
 	ASSERT((val & ~mask) == 0);
 
@@ -1621,7 +1621,7 @@ void wlc_bmac_mctrl(wlc_hw_info_t *wlc_h
 /* write the software state of maccontrol and overrides to the maccontrol register */
 static void wlc_mctrl_write(wlc_hw_info_t *wlc_hw)
 {
-	uint32 maccontrol = wlc_hw->maccontrol;
+	u32 maccontrol = wlc_hw->maccontrol;
 
 	/* OR in the wake bit if overridden */
 	if (wlc_hw->wake_override)
@@ -1636,7 +1636,7 @@ static void wlc_mctrl_write(wlc_hw_info_
 	W_REG(wlc_hw->osh, &wlc_hw->regs->maccontrol, maccontrol);
 }
 
-void wlc_ucode_wake_override_set(wlc_hw_info_t *wlc_hw, uint32 override_bit)
+void wlc_ucode_wake_override_set(wlc_hw_info_t *wlc_hw, u32 override_bit)
 {
 	ASSERT((wlc_hw->wake_override & override_bit) == 0);
 
@@ -1653,7 +1653,7 @@ void wlc_ucode_wake_override_set(wlc_hw_
 	return;
 }
 
-void wlc_ucode_wake_override_clear(wlc_hw_info_t *wlc_hw, uint32 override_bit)
+void wlc_ucode_wake_override_clear(wlc_hw_info_t *wlc_hw, u32 override_bit)
 {
 	ASSERT(wlc_hw->wake_override & override_bit);
 
@@ -1716,7 +1716,7 @@ wlc_bmac_set_rcmta(wlc_hw_info_t *wlc_hw
 	d11regs_t *regs = wlc_hw->regs;
 	volatile u16 *objdata16 =
 	    (volatile u16 *)(uintptr) & regs->objdata;
-	uint32 mac_hm;
+	u32 mac_hm;
 	u16 mac_l;
 	osl_t *osh;
 
@@ -1777,7 +1777,7 @@ wlc_bmac_write_template_ram(wlc_hw_info_
 			    void *buf)
 {
 	d11regs_t *regs;
-	uint32 word;
+	u32 word;
 	bool be_bit;
 #ifdef IL_BIGENDIAN
 	volatile u16 *dptr = NULL;
@@ -1789,8 +1789,8 @@ wlc_bmac_write_template_ram(wlc_hw_info_
 	regs = wlc_hw->regs;
 	osh = wlc_hw->osh;
 
-	ASSERT(ISALIGNED(offset, sizeof(uint32)));
-	ASSERT(ISALIGNED(len, sizeof(uint32)));
+	ASSERT(ISALIGNED(offset, sizeof(u32)));
+	ASSERT(ISALIGNED(len, sizeof(u32)));
 	ASSERT((offset & ~0xffff) == 0);
 
 	W_REG(osh, &regs->tplatewrptr, offset);
@@ -1802,7 +1802,7 @@ wlc_bmac_write_template_ram(wlc_hw_info_
 	be_bit = (R_REG(osh, &regs->maccontrol) & MCTL_BIGEND) != 0;
 
 	while (len > 0) {
-		bcopy((u8 *) buf, &word, sizeof(uint32));
+		bcopy((u8 *) buf, &word, sizeof(u32));
 
 		if (be_bit)
 			word = hton32(word);
@@ -1811,8 +1811,8 @@ wlc_bmac_write_template_ram(wlc_hw_info_
 
 		W_REG(osh, &regs->tplatewrdata, word);
 
-		buf = (u8 *) buf + sizeof(uint32);
-		len -= sizeof(uint32);
+		buf = (u8 *) buf + sizeof(u32);
+		len -= sizeof(u32);
 	}
 }
 
@@ -1843,7 +1843,7 @@ void wlc_bmac_set_cwmax(wlc_hw_info_t *w
 void wlc_bmac_bw_set(wlc_hw_info_t *wlc_hw, u16 bw)
 {
 	bool fastclk;
-	uint32 tmp;
+	u32 tmp;
 
 	/* request FAST clock if not on */
 	fastclk = wlc_hw->forcefastclk;
@@ -2043,7 +2043,7 @@ void wlc_bmac_macphyclk_set(wlc_hw_info_
 void wlc_bmac_phy_reset(wlc_hw_info_t *wlc_hw)
 {
 	wlc_phy_t *pih = wlc_hw->band->pi;
-	uint32 phy_bw_clkbits;
+	u32 phy_bw_clkbits;
 	bool phy_in_reset = FALSE;
 
 	WL_TRACE(("wl%d: wlc_bmac_phy_reset\n", wlc_hw->unit));
@@ -2087,7 +2087,7 @@ static void
 WLBANDINITFN(wlc_bmac_setband) (wlc_hw_info_t *wlc_hw, uint bandunit,
 				chanspec_t chanspec) {
 	wlc_info_t *wlc = wlc_hw->wlc;
-	uint32 macintmask;
+	u32 macintmask;
 
 	ASSERT(NBANDS_HW(wlc_hw) > 1);
 	ASSERT(bandunit != wlc_hw->band->bandunit);
@@ -2210,7 +2210,7 @@ static char *BCMINITFN(wlc_get_macaddr)
 bool wlc_bmac_radio_read_hwdisabled(wlc_hw_info_t *wlc_hw)
 {
 	bool v, clk, xtal;
-	uint32 resetbits = 0, flags = 0;
+	u32 resetbits = 0, flags = 0;
 
 	xtal = wlc_hw->sbclk;
 	if (!xtal)
@@ -2328,12 +2328,12 @@ static bool wlc_dma_rxreset(wlc_hw_info_
  *   clear software macintstatus for fresh new start
  * one testing hack wlc_hw->noreset will bypass the d11/phy reset
  */
-void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t *wlc_hw, uint32 flags)
+void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t *wlc_hw, u32 flags)
 {
 	d11regs_t *regs;
 	uint i;
 	bool fastclk;
-	uint32 resetbits = 0;
+	u32 resetbits = 0;
 
 	if (flags == WLC_USE_COREFLAGS)
 		flags = (wlc_hw->band->pi ? wlc_hw->band->core_flags : 0);
@@ -2481,7 +2481,7 @@ static void BCMINITFN(wlc_coreinit) (wlc
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs;
-	uint32 sflags;
+	u32 sflags;
 	uint bcnint_us;
 	uint i = 0;
 	bool fifosz_fixup = FALSE;
@@ -2723,7 +2723,7 @@ static void BCMINITFN(wlc_gpio_init) (wl
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs;
-	uint32 gc, gm;
+	u32 gc, gm;
 	osl_t *osh;
 
 	regs = wlc_hw->regs;
@@ -2813,7 +2813,7 @@ static void BCMATTACHFN(wlc_ucode_downlo
 }
 
 static void
-BCMATTACHFN(wlc_ucode_write) (wlc_hw_info_t *wlc_hw, const uint32 ucode[],
+BCMATTACHFN(wlc_ucode_write) (wlc_hw_info_t *wlc_hw, const u32 ucode[],
 			      const uint nbytes) {
 	osl_t *osh;
 	d11regs_t *regs = wlc_hw->regs;
@@ -2824,9 +2824,9 @@ BCMATTACHFN(wlc_ucode_write) (wlc_hw_inf
 
 	WL_TRACE(("wl%d: wlc_ucode_write\n", wlc_hw->unit));
 
-	ASSERT(ISALIGNED(nbytes, sizeof(uint32)));
+	ASSERT(ISALIGNED(nbytes, sizeof(u32)));
 
-	count = (nbytes / sizeof(uint32));
+	count = (nbytes / sizeof(u32));
 
 	W_REG(osh, &regs->objaddr, (OBJADDR_AUTO_INC | OBJADDR_UCM_SEL));
 	(void)R_REG(osh, &regs->objaddr);
@@ -2852,7 +2852,7 @@ static void wlc_write_inits(wlc_hw_info_
 			W_REG(osh, (u16 *) (uintptr) (base + inits[i].addr),
 			      inits[i].value);
 		else if (inits[i].size == 4)
-			W_REG(osh, (uint32 *) (uintptr) (base + inits[i].addr),
+			W_REG(osh, (u32 *) (uintptr) (base + inits[i].addr),
 			      inits[i].value);
 	}
 }
@@ -2980,7 +2980,7 @@ void wlc_intrson(wlc_info_t *wlc)
  *  but also because per-port code may require sync with valid interrupt.
  */
 
-static uint32 wlc_wlintrsoff(wlc_info_t *wlc)
+static u32 wlc_wlintrsoff(wlc_info_t *wlc)
 {
 	if (!wlc->hw->up)
 		return 0;
@@ -2988,7 +2988,7 @@ static uint32 wlc_wlintrsoff(wlc_info_t
 	return wl_intrsoff(wlc->wl);
 }
 
-static void wlc_wlintrsrestore(wlc_info_t *wlc, uint32 macintmask)
+static void wlc_wlintrsrestore(wlc_info_t *wlc, u32 macintmask)
 {
 	if (!wlc->hw->up)
 		return;
@@ -2996,10 +2996,10 @@ static void wlc_wlintrsrestore(wlc_info_
 	wl_intrsrestore(wlc->wl, macintmask);
 }
 
-uint32 wlc_intrsoff(wlc_info_t *wlc)
+u32 wlc_intrsoff(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
-	uint32 macintmask;
+	u32 macintmask;
 
 	if (!wlc_hw->clk)
 		return 0;
@@ -3015,7 +3015,7 @@ uint32 wlc_intrsoff(wlc_info_t *wlc)
 	return wlc->macintstatus ? 0 : macintmask;
 }
 
-void wlc_intrsrestore(wlc_info_t *wlc, uint32 macintmask)
+void wlc_intrsrestore(wlc_info_t *wlc, u32 macintmask)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	if (!wlc_hw->clk)
@@ -3174,12 +3174,12 @@ void wlc_bmac_tx_fifo_resume(wlc_hw_info
  *   0 if the interrupt is not for us, or we are in some special cases;
  *   device interrupt status bits otherwise.
  */
-static inline uint32 wlc_intstatus(wlc_info_t *wlc, bool in_isr)
+static inline u32 wlc_intstatus(wlc_info_t *wlc, bool in_isr)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
-	uint32 macintstatus;
-	uint32 intstatus_rxfifo, intstatus_txsfifo;
+	u32 macintstatus;
+	u32 intstatus_rxfifo, intstatus_txsfifo;
 	osl_t *osh;
 
 	osh = wlc_hw->osh;
@@ -3268,7 +3268,7 @@ static inline uint32 wlc_intstatus(wlc_i
 /* Return TRUE if they are updated successfully. FALSE otherwise */
 bool wlc_intrsupd(wlc_info_t *wlc)
 {
-	uint32 macintstatus;
+	u32 macintstatus;
 
 	ASSERT(wlc->macintstatus != 0);
 
@@ -3294,7 +3294,7 @@ bool wlc_intrsupd(wlc_info_t *wlc)
 bool BCMFASTPATH wlc_isr(wlc_info_t *wlc, bool *wantdpc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
-	uint32 macintstatus;
+	u32 macintstatus;
 
 	*wantdpc = FALSE;
 
@@ -3358,7 +3358,7 @@ static bool wlc_bmac_txstatus_corerev4(w
 }
 
 static bool BCMFASTPATH
-wlc_bmac_dotxstatus(wlc_hw_info_t *wlc_hw, tx_status_t *txs, uint32 s2)
+wlc_bmac_dotxstatus(wlc_hw_info_t *wlc_hw, tx_status_t *txs, u32 s2)
 {
 	/* discard intermediate indications for ucode with one legitimate case:
 	 *   e.g. if "useRTS" is set. ucode did a successful rts/cts exchange, but the subsequent
@@ -3395,7 +3395,7 @@ wlc_bmac_txstatus(wlc_hw_info_t *wlc_hw,
 		d11regs_t *regs;
 		osl_t *osh;
 		tx_status_t txstatus, *txs;
-		uint32 s1, s2;
+		u32 s1, s2;
 		uint n = 0;
 		/* Param 'max_tx_num' indicates max. # tx status to process before break out. */
 		uint max_tx_num = bound ? wlc->pub->tunables->txsbnd : -1;
@@ -3445,7 +3445,7 @@ void wlc_suspend_mac_and_wait(wlc_info_t
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
-	uint32 mc, mi;
+	u32 mc, mi;
 	osl_t *osh;
 
 	WL_TRACE(("wl%d: wlc_suspend_mac_and_wait: bandunit %d\n", wlc_hw->unit,
@@ -3509,7 +3509,7 @@ void wlc_enable_mac(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
-	uint32 mc, mi;
+	u32 mc, mi;
 	osl_t *osh;
 
 	WL_TRACE(("wl%d: wlc_enable_mac: bandunit %d\n", wlc_hw->unit,
@@ -3656,8 +3656,8 @@ void wlc_bmac_band_stf_ss_set(wlc_hw_inf
 }
 
 void BCMFASTPATH
-wlc_bmac_read_tsf(wlc_hw_info_t *wlc_hw, uint32 *tsf_l_ptr,
-		  uint32 *tsf_h_ptr)
+wlc_bmac_read_tsf(wlc_hw_info_t *wlc_hw, u32 *tsf_l_ptr,
+		  u32 *tsf_h_ptr)
 {
 	d11regs_t *regs = wlc_hw->regs;
 
@@ -3671,7 +3671,7 @@ wlc_bmac_read_tsf(wlc_hw_info_t *wlc_hw,
 bool BCMATTACHFN(wlc_bmac_validate_chip_access) (wlc_hw_info_t *wlc_hw)
 {
 	d11regs_t *regs;
-	uint32 w, val;
+	u32 w, val;
 	volatile u16 *reg16;
 	osl_t *osh;
 
@@ -3689,24 +3689,24 @@ bool BCMATTACHFN(wlc_bmac_validate_chip_
 	/* Can we write and read back a 32bit register? */
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
 	(void)R_REG(osh, &regs->objaddr);
-	W_REG(osh, &regs->objdata, (uint32) 0xaa5555aa);
+	W_REG(osh, &regs->objdata, (u32) 0xaa5555aa);
 
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
 	(void)R_REG(osh, &regs->objaddr);
 	val = R_REG(osh, &regs->objdata);
-	if (val != (uint32) 0xaa5555aa) {
+	if (val != (u32) 0xaa5555aa) {
 		WL_ERROR(("wl%d: validate_chip_access: SHM = 0x%x, expected 0xaa5555aa\n", wlc_hw->unit, val));
 		return FALSE;
 	}
 
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
 	(void)R_REG(osh, &regs->objaddr);
-	W_REG(osh, &regs->objdata, (uint32) 0x55aaaa55);
+	W_REG(osh, &regs->objdata, (u32) 0x55aaaa55);
 
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
 	(void)R_REG(osh, &regs->objaddr);
 	val = R_REG(osh, &regs->objdata);
-	if (val != (uint32) 0x55aaaa55) {
+	if (val != (u32) 0x55aaaa55) {
 		WL_ERROR(("wl%d: validate_chip_access: SHM = 0x%x, expected 0x55aaaa55\n", wlc_hw->unit, val));
 		return FALSE;
 	}
@@ -3767,7 +3767,7 @@ void wlc_bmac_core_phypll_ctl(wlc_hw_inf
 {
 	d11regs_t *regs;
 	osl_t *osh;
-	uint32 tmp;
+	u32 tmp;
 
 	WL_TRACE(("wl%d: wlc_bmac_core_phypll_ctl\n", wlc_hw->unit));
 
@@ -3934,7 +3934,7 @@ void wlc_bmac_set_shm(wlc_hw_info_t *wlc
 }
 
 static u16
-wlc_bmac_read_objmem(wlc_hw_info_t *wlc_hw, uint offset, uint32 sel)
+wlc_bmac_read_objmem(wlc_hw_info_t *wlc_hw, uint offset, u32 sel)
 {
 	d11regs_t *regs = wlc_hw->regs;
 	volatile u16 *objdata_lo =
@@ -3956,7 +3956,7 @@ wlc_bmac_read_objmem(wlc_hw_info_t *wlc_
 }
 
 static void
-wlc_bmac_write_objmem(wlc_hw_info_t *wlc_hw, uint offset, u16 v, uint32 sel)
+wlc_bmac_write_objmem(wlc_hw_info_t *wlc_hw, uint offset, u16 v, u32 sel)
 {
 	d11regs_t *regs = wlc_hw->regs;
 	volatile u16 *objdata_lo =
@@ -3981,7 +3981,7 @@ wlc_bmac_write_objmem(wlc_hw_info_t *wlc
  */
 void
 wlc_bmac_copyto_objmem(wlc_hw_info_t *wlc_hw, uint offset, const void *buf,
-		       int len, uint32 sel)
+		       int len, u32 sel)
 {
 	u16 v;
 	const u8 *p = (const u8 *)buf;
@@ -4007,7 +4007,7 @@ wlc_bmac_copyto_objmem(wlc_hw_info_t *wl
  */
 void
 wlc_bmac_copyfrom_objmem(wlc_hw_info_t *wlc_hw, uint offset, void *buf,
-			 int len, uint32 sel)
+			 int len, u32 sel)
 {
 	u16 v;
 	u8 *p = (u8 *) buf;
@@ -4207,7 +4207,7 @@ void wlc_bmac_set_txpwr_percent(wlc_hw_i
 	wlc_phy_txpwr_percent_set(wlc_hw->band->pi, val);
 }
 
-void wlc_bmac_antsel_set(wlc_hw_info_t *wlc_hw, uint32 antsel_avail)
+void wlc_bmac_antsel_set(wlc_hw_info_t *wlc_hw, u32 antsel_avail)
 {
 	wlc_hw->antsel_avail = antsel_avail;
 }
--- a/drivers/staging/brcm80211/sys/wlc_bmac.h
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.h
@@ -41,7 +41,7 @@ typedef struct wlc_bmac_revinfo {
 	uint bustype;		/* SB_BUS, PCI_BUS  */
 	uint buscoretype;	/* PCI_CORE_ID, PCIE_CORE_ID, PCMCIA_CORE_ID */
 	uint buscorerev;	/* buscore rev */
-	uint32 issim;		/* chip is in simulation or emulation */
+	u32 issim;		/* chip is in simulation or emulation */
 
 	uint nbands;
 
@@ -59,8 +59,8 @@ typedef struct wlc_bmac_revinfo {
 
 /* dup state between BMAC(wlc_hw_info_t) and HIGH(wlc_info_t) driver */
 typedef struct wlc_bmac_state {
-	uint32 machwcap;	/* mac hw capibility */
-	uint32 preamble_ovr;	/* preamble override */
+	u32 machwcap;	/* mac hw capibility */
+	u32 preamble_ovr;	/* preamble override */
 } wlc_bmac_state_t;
 
 enum {
@@ -144,9 +144,9 @@ extern void wlc_bmac_xtal(wlc_hw_info_t
 
 extern void wlc_bmac_copyto_objmem(wlc_hw_info_t *wlc_hw,
 				   uint offset, const void *buf, int len,
-				   uint32 sel);
+				   u32 sel);
 extern void wlc_bmac_copyfrom_objmem(wlc_hw_info_t *wlc_hw, uint offset,
-				     void *buf, int len, uint32 sel);
+				     void *buf, int len, u32 sel);
 #define wlc_bmac_copyfrom_shm(wlc_hw, offset, buf, len)                 \
 	wlc_bmac_copyfrom_objmem(wlc_hw, offset, buf, len, OBJADDR_SHM_SEL)
 #define wlc_bmac_copyto_shm(wlc_hw, offset, buf, len)                   \
@@ -158,7 +158,7 @@ extern void wlc_bmac_core_phypll_ctl(wlc
 extern void wlc_bmac_phyclk_fgc(wlc_hw_info_t *wlc_hw, bool clk);
 extern void wlc_bmac_macphyclk_set(wlc_hw_info_t *wlc_hw, bool clk);
 extern void wlc_bmac_phy_reset(wlc_hw_info_t *wlc_hw);
-extern void wlc_bmac_corereset(wlc_hw_info_t *wlc_hw, uint32 flags);
+extern void wlc_bmac_corereset(wlc_hw_info_t *wlc_hw, u32 flags);
 extern void wlc_bmac_reset(wlc_hw_info_t *wlc_hw);
 extern void wlc_bmac_init(wlc_hw_info_t *wlc_hw, chanspec_t chanspec,
 			  bool mute);
@@ -166,7 +166,7 @@ extern int wlc_bmac_up_prep(wlc_hw_info_
 extern int wlc_bmac_up_finish(wlc_hw_info_t *wlc_hw);
 extern int wlc_bmac_down_prep(wlc_hw_info_t *wlc_hw);
 extern int wlc_bmac_down_finish(wlc_hw_info_t *wlc_hw);
-extern void wlc_bmac_corereset(wlc_hw_info_t *wlc_hw, uint32 flags);
+extern void wlc_bmac_corereset(wlc_hw_info_t *wlc_hw, u32 flags);
 extern void wlc_bmac_switch_macfreq(wlc_hw_info_t *wlc_hw, u8 spurmode);
 
 /* chanspec, ucode interface */
@@ -180,7 +180,7 @@ extern int wlc_bmac_xmtfifo_sz_get(wlc_h
 				   uint *blocks);
 extern void wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, u8 idx, u16 mask,
 			 u16 val, int bands);
-extern void wlc_bmac_mctrl(wlc_hw_info_t *wlc_hw, uint32 mask, uint32 val);
+extern void wlc_bmac_mctrl(wlc_hw_info_t *wlc_hw, u32 mask, u32 val);
 extern u16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, u8 idx, int bands);
 extern int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t *wlc_hw, uint fifo,
 				   uint blocks);
@@ -219,9 +219,9 @@ extern void wlc_bmac_tx_fifo_suspend(wlc
 extern void wlc_bmac_tx_fifo_resume(wlc_hw_info_t *wlc_hw, uint tx_fifo);
 
 extern void wlc_ucode_wake_override_set(wlc_hw_info_t *wlc_hw,
-					uint32 override_bit);
+					u32 override_bit);
 extern void wlc_ucode_wake_override_clear(wlc_hw_info_t *wlc_hw,
-					  uint32 override_bit);
+					  u32 override_bit);
 
 extern void wlc_bmac_set_rcmta(wlc_hw_info_t *wlc_hw, int idx,
 			       const struct ether_addr *addr);
@@ -230,8 +230,8 @@ extern void wlc_bmac_set_addrmatch(wlc_h
 extern void wlc_bmac_write_hw_bcntemplates(wlc_hw_info_t *wlc_hw, void *bcn,
 					   int len, bool both);
 
-extern void wlc_bmac_read_tsf(wlc_hw_info_t *wlc_hw, uint32 *tsf_l_ptr,
-			      uint32 *tsf_h_ptr);
+extern void wlc_bmac_read_tsf(wlc_hw_info_t *wlc_hw, u32 *tsf_l_ptr,
+			      u32 *tsf_h_ptr);
 extern void wlc_bmac_set_cwmin(wlc_hw_info_t *wlc_hw, u16 newmin);
 extern void wlc_bmac_set_cwmax(wlc_hw_info_t *wlc_hw, u16 newmax);
 extern void wlc_bmac_set_noreset(wlc_hw_info_t *wlc, bool noreset_flag);
@@ -246,10 +246,10 @@ extern void wlc_bmac_fifoerrors(wlc_hw_i
 extern void wlc_bmac_dngl_reboot(rpc_info_t *);
 extern void wlc_bmac_dngl_rpc_agg(rpc_info_t *, u16 agg);
 extern void wlc_bmac_dngl_rpc_msglevel(rpc_info_t *, u16 level);
-extern void wlc_bmac_dngl_rpc_txq_wm_set(rpc_info_t *rpc, uint32 wm);
-extern void wlc_bmac_dngl_rpc_txq_wm_get(rpc_info_t *rpc, uint32 *wm);
-extern void wlc_bmac_dngl_rpc_agg_limit_set(rpc_info_t *rpc, uint32 val);
-extern void wlc_bmac_dngl_rpc_agg_limit_get(rpc_info_t *rpc, uint32 *pval);
+extern void wlc_bmac_dngl_rpc_txq_wm_set(rpc_info_t *rpc, u32 wm);
+extern void wlc_bmac_dngl_rpc_txq_wm_get(rpc_info_t *rpc, u32 *wm);
+extern void wlc_bmac_dngl_rpc_agg_limit_set(rpc_info_t *rpc, u32 val);
+extern void wlc_bmac_dngl_rpc_agg_limit_get(rpc_info_t *rpc, u32 *pval);
 extern int wlc_bmac_debug_template(wlc_hw_info_t *wlc_hw);
 #endif
 
@@ -268,10 +268,10 @@ extern void wlc_gpio_fast_deinit(wlc_hw_
 extern bool wlc_bmac_radio_hw(wlc_hw_info_t *wlc_hw, bool enable);
 extern u16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, u8 rate);
 
-extern void wlc_bmac_assert_type_set(wlc_hw_info_t *wlc_hw, uint32 type);
+extern void wlc_bmac_assert_type_set(wlc_hw_info_t *wlc_hw, u32 type);
 extern void wlc_bmac_set_txpwr_percent(wlc_hw_info_t *wlc_hw, u8 val);
-extern void wlc_bmac_blink_sync(wlc_hw_info_t *wlc_hw, uint32 led_pins);
+extern void wlc_bmac_blink_sync(wlc_hw_info_t *wlc_hw, u32 led_pins);
 extern void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t *wlc_hw, bool abie,
 				      bool isht);
 
-extern void wlc_bmac_antsel_set(wlc_hw_info_t *wlc_hw, uint32 antsel_avail);
+extern void wlc_bmac_antsel_set(wlc_hw_info_t *wlc_hw, u32 antsel_avail);
--- a/drivers/staging/brcm80211/sys/wlc_bsscfg.h
+++ b/drivers/staging/brcm80211/sys/wlc_bsscfg.h
@@ -73,7 +73,7 @@ struct wlc_bsscfg {
 	struct ether_addr *maclist;	/* list of source MAC addrs to match */
 
 	/* security */
-	uint32 wsec;		/* wireless security bitvec */
+	u32 wsec;		/* wireless security bitvec */
 	s16 auth;		/* 802.11 authentication: Open, Shared Key, WPA */
 	s16 openshared;	/* try Open auth first, then Shared Key */
 	bool wsec_restrict;	/* drop unencrypted packets if wsec is enabled */
@@ -87,9 +87,9 @@ struct wlc_bsscfg {
 
 	/* TKIP countermeasures */
 	bool tkip_countermeasures;	/* flags TKIP no-assoc period */
-	uint32 tk_cm_dt;	/* detect timer */
-	uint32 tk_cm_bt;	/* blocking timer */
-	uint32 tk_cm_bt_tmstmp;	/* Timestamp when TKIP BT is activated */
+	u32 tk_cm_dt;	/* detect timer */
+	u32 tk_cm_bt;	/* blocking timer */
+	u32 tk_cm_bt_tmstmp;	/* Timestamp when TKIP BT is activated */
 	bool tk_cm_activate;	/* activate countermeasures after EAPOL-Key sent */
 
 	struct ether_addr BSSID;	/* BSSID (associated) */
@@ -97,7 +97,7 @@ struct wlc_bsscfg {
 	u16 bcmc_fid;	/* the last BCMC FID queued to TX_BCMC_FIFO */
 	u16 bcmc_fid_shm;	/* the last BCMC FID written to shared mem */
 
-	uint32 flags;		/* WLC_BSSCFG flags; see below */
+	u32 flags;		/* WLC_BSSCFG flags; see below */
 
 	u8 *bcn;		/* AP beacon */
 	uint bcn_len;		/* AP beacon length */
--- a/drivers/staging/brcm80211/sys/wlc_channel.h
+++ b/drivers/staging/brcm80211/sys/wlc_channel.h
@@ -54,7 +54,7 @@ struct wlc_info;
 
 /* locale channel and power info. */
 typedef struct {
-	uint32 valid_channels;
+	u32 valid_channels;
 	u8 radar_channels;	/* List of radar sensitive channels */
 	u8 restricted_channels;	/* List of channels used only if APs are detected */
 	s8 maxpwr[WLC_MAXPWR_TBL_SIZE];	/* Max tx pwr in qdBm for each sub-band */
--- a/drivers/staging/brcm80211/sys/wlc_event.h
+++ b/drivers/staging/brcm80211/sys/wlc_event.h
@@ -40,7 +40,7 @@ extern int wlc_eventq_set_ind(wlc_eventq
 extern void wlc_eventq_flush(wlc_eventq_t *eq);
 extern void wlc_assign_event_msg(wlc_info_t *wlc, wl_event_msg_t *msg,
 				 const wlc_event_t *e, u8 *data,
-				 uint32 len);
+				 u32 len);
 
 #ifdef MSGTRACE
 extern void wlc_event_sendup_trace(struct wlc_info *wlc, hndrte_dev_t *bus,
--- a/drivers/staging/brcm80211/sys/wlc_key.h
+++ b/drivers/staging/brcm80211/sys/wlc_key.h
@@ -80,7 +80,7 @@ struct wlc_bsscfg;
 #define WSEC_BSS_STA_KEY_GROUP_SIZE	5
 
 typedef struct wsec_iv {
-	uint32 hi;		/* upper 32 bits of IV */
+	u32 hi;		/* upper 32 bits of IV */
 	u16 lo;		/* lower 16 bits of IV */
 } wsec_iv_t;
 
@@ -97,7 +97,7 @@ typedef struct wsec_key {
 	u8 aes_mode;		/* cache for hw register */
 	s8 iv_len;		/* IV length */
 	s8 icv_len;		/* ICV length */
-	uint32 len;		/* key length..don't move this var */
+	u32 len;		/* key length..don't move this var */
 	/* data is 4byte aligned */
 	u8 data[DOT11_MAX_KEY_SIZE];	/* key data */
 	wsec_iv_t rxiv[WLC_NUMRXIVS];	/* Rx IV (one per TID) */
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -262,12 +262,12 @@ void wlc_wme_setparams(wlc_info_t *wlc,
 static void wlc_bss_default_init(wlc_info_t *wlc);
 static void wlc_ucode_mac_upd(wlc_info_t *wlc);
 static ratespec_t mac80211_wlc_set_nrate(wlc_info_t *wlc, wlcband_t *cur_band,
-					 uint32 int_val);
+					 u32 int_val);
 static void wlc_tx_prec_map_init(wlc_info_t *wlc);
 static void wlc_watchdog(void *arg);
 static void wlc_watchdog_by_timer(void *arg);
 static int wlc_set_rateset(wlc_info_t *wlc, wlc_rateset_t *rs_arg);
-static int wlc_iovar_rangecheck(wlc_info_t *wlc, uint32 val,
+static int wlc_iovar_rangecheck(wlc_info_t *wlc, u32 val,
 				const bcm_iovar_t *vi);
 static u8 wlc_local_constraint_qdbm(wlc_info_t *wlc);
 
@@ -330,7 +330,7 @@ static int _wlc_ioctl(wlc_info_t *wlc, i
 void wlc_get_rcmta(wlc_info_t *wlc, int idx, struct ether_addr *addr)
 {
 	d11regs_t *regs = wlc->regs;
-	uint32 v32;
+	u32 v32;
 	osl_t *osh;
 
 	WL_TRACE(("wl%d: %s\n", WLCWLUNIT(wlc), __func__));
@@ -506,7 +506,7 @@ void BCMINITFN(wlc_init) (wlc_info_t *wl
 	if (wlc->pub->associated) {
 		FOREACH_BSS(wlc, i, bsscfg) {
 			if (bsscfg->up) {
-				uint32 bi;
+				u32 bi;
 
 				/* get beacon period from bsscfg and convert to uS */
 				bi = bsscfg->current_bss->beacon_period << 10;
@@ -612,7 +612,7 @@ void wlc_mac_bcn_promisc(wlc_info_t *wlc
 /* set or clear maccontrol bits MCTL_PROMISC and MCTL_KEEPCONTROL */
 void wlc_mac_promisc(wlc_info_t *wlc)
 {
-	uint32 promisc_bits = 0;
+	u32 promisc_bits = 0;
 
 	/* promiscuous mode just sets MCTL_PROMISC
 	 * Note: APs get all BSS traffic without the need to set the MCTL_PROMISC bit
@@ -639,7 +639,7 @@ bool wlc_ps_check(wlc_info_t *wlc)
 	bool wake_ok;
 
 	if (!AP_ACTIVE(wlc)) {
-		volatile uint32 tmp;
+		volatile u32 tmp;
 		tmp = R_REG(wlc->osh, &wlc->regs->maccontrol);
 
 		/* If deviceremoved is detected, then don't take any action as this can be called
@@ -692,7 +692,7 @@ bool wlc_ps_check(wlc_info_t *wlc)
 /* push sw hps and wake state through hardware */
 void wlc_set_ps_ctrl(wlc_info_t *wlc)
 {
-	uint32 v1, v2;
+	u32 v1, v2;
 	bool hps, wake;
 	bool awake_before;
 
@@ -1075,9 +1075,9 @@ static int wlc_get_current_txpwr(wlc_inf
 }
 #endif				/* defined(BCMDBG) */
 
-static uint32 wlc_watchdog_backup_bi(wlc_info_t *wlc)
+static u32 wlc_watchdog_backup_bi(wlc_info_t *wlc)
 {
-	uint32 bi;
+	u32 bi;
 	bi = 2 * wlc->cfg->current_bss->dtim_period *
 	    wlc->cfg->current_bss->beacon_period;
 	if (wlc->bcn_li_dtim)
@@ -1793,7 +1793,7 @@ void *BCMATTACHFN(wlc_attach) (void *wl,
 	ASSERT(sizeof(ht_cap_ie_t) == HT_CAP_IE_LEN);
 	ASSERT(OFFSETOF(wl_scan_params_t, channel_list) ==
 	       WL_SCAN_PARAMS_FIXED_SIZE);
-	ASSERT(ISALIGNED(OFFSETOF(wsec_key_t, data), sizeof(uint32)));
+	ASSERT(ISALIGNED(OFFSETOF(wsec_key_t, data), sizeof(u32)));
 	ASSERT(ISPOWEROF2(MA_WINDOW_SZ));
 
 	ASSERT(sizeof(wlc_d11rxhdr_t) <= WL_HWRXOFF);
@@ -3304,7 +3304,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 	pval = arg ? (int *)arg:NULL;
 
 	/* This will prevent the misaligned access */
-	if (pval && (uint32) len >= sizeof(val))
+	if (pval && (u32) len >= sizeof(val))
 		bcopy(pval, &val, sizeof(val));
 	else
 		val = 0;
@@ -3524,10 +3524,10 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			bcmerror = BCME_BADADDR;
 			break;
 		}
-		if (r->size == sizeof(uint32))
+		if (r->size == sizeof(u32))
 			r->val =
 			    R_REG(osh,
-				  (uint32 *) ((unsigned char *) (uintptr) regs +
+				  (u32 *) ((unsigned char *) (uintptr) regs +
 					      r->byteoff));
 		else if (r->size == sizeof(u16))
 			r->val =
@@ -3560,9 +3560,9 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			bcmerror = BCME_BADADDR;
 			break;
 		}
-		if (r->size == sizeof(uint32))
+		if (r->size == sizeof(u32))
 			W_REG(osh,
-			      (uint32 *) ((unsigned char *) (uintptr) regs +
+			      (u32 *) ((unsigned char *) (uintptr) regs +
 					  r->byteoff), r->val);
 		else if (r->size == sizeof(u16))
 			W_REG(osh,
@@ -3846,7 +3846,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 				(key != NULL)) {
 				u8 seq[DOT11_WPA_KEY_RSC_LEN];
 				u16 lo;
-				uint32 hi;
+				u32 hi;
 				/* group keys in WPA-NONE (IBSS only, AES and TKIP) use a global TXIV */
 				if ((bsscfg->WPA_auth & WPA_AUTH_NONE)
 				    && ETHER_ISNULLADDR(&key->ea)) {
@@ -4043,7 +4043,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		break;
 
 	case WLC_SET_ATIM:
-		wlc->default_bss->atim_window = (uint32) val;
+		wlc->default_bss->atim_window = (u32) val;
 		break;
 
 	case WLC_GET_PKTCNTS:{
@@ -4603,7 +4603,7 @@ wlc_iovar_op(wlc_info_t *wlc, const char
 	int err = 0;
 	int val_size;
 	const bcm_iovar_t *vi = NULL;
-	uint32 actionid;
+	u32 actionid;
 	int i;
 
 	ASSERT(name != NULL);
@@ -4739,7 +4739,7 @@ wlc_iovar_check(wlc_pub_t *pub, const bc
  * Please use params for additional qualifying parameters.
  */
 int
-wlc_doiovar(void *hdl, const bcm_iovar_t *vi, uint32 actionid,
+wlc_doiovar(void *hdl, const bcm_iovar_t *vi, u32 actionid,
 	    const char *name, void *params, uint p_len, void *arg, int len,
 	    int val_size, struct wlc_if *wlcif)
 {
@@ -4848,11 +4848,11 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 }
 
 static int
-wlc_iovar_rangecheck(wlc_info_t *wlc, uint32 val, const bcm_iovar_t *vi)
+wlc_iovar_rangecheck(wlc_info_t *wlc, u32 val, const bcm_iovar_t *vi)
 {
 	int err = 0;
-	uint32 min_val = 0;
-	uint32 max_val = 0;
+	u32 min_val = 0;
+	u32 max_val = 0;
 
 	/* Only ranged integers are checked */
 	switch (vi->type) {
@@ -5577,10 +5577,10 @@ static void wlc_compute_mimo_plcp(ratesp
 
 /* Rate: 802.11 rate code, length: PSDU length in octets */
 static void BCMFASTPATH
-wlc_compute_ofdm_plcp(ratespec_t rspec, uint32 length, u8 *plcp)
+wlc_compute_ofdm_plcp(ratespec_t rspec, u32 length, u8 *plcp)
 {
 	u8 rate_signal;
-	uint32 tmp = 0;
+	u32 tmp = 0;
 	int rate = RSPEC2RATE(rspec);
 
 	ASSERT(IS_OFDM(rspec));
@@ -5902,7 +5902,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 	struct dot11_rts_frame *rts = NULL;
 	bool qos;
 	uint ac;
-	uint32 rate_val[2];
+	u32 rate_val[2];
 	bool hwtkmic = FALSE;
 	u16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
 #ifdef WLANTSEL
@@ -6559,7 +6559,7 @@ void wlc_tbtt(wlc_info_t *wlc, d11regs_t
 	if (BSSCFG_STA(cfg)) {
 		/* run watchdog here if the watchdog timer is not armed */
 		if (WLC_WATCHDOG_TBTT(wlc)) {
-			uint32 cur, delta;
+			u32 cur, delta;
 			if (wlc->WDarmed) {
 				wl_del_timer(wlc->wl, wlc->wdtimer);
 				wlc->WDarmed = FALSE;
@@ -6567,7 +6567,7 @@ void wlc_tbtt(wlc_info_t *wlc, d11regs_t
 
 			cur = OSL_SYSUPTIME();
 			delta = cur > wlc->WDlast ? cur - wlc->WDlast :
-			    (uint32) ~0 - wlc->WDlast + cur + 1;
+			    (u32) ~0 - wlc->WDlast + cur + 1;
 			if (delta >= TIMER_INTERVAL_WATCHDOG) {
 				wlc_watchdog((void *)wlc);
 				wlc->WDlast = cur;
@@ -6611,7 +6611,7 @@ static void wlc_hwtimer_gptimer_cb(wlc_i
  * POLICY: no macinstatus change, no bounding loop.
  *         All dpc bounding should be handled in BMAC dpc, like txstatus and rxint
  */
-void wlc_high_dpc(wlc_info_t *wlc, uint32 macintstatus)
+void wlc_high_dpc(wlc_info_t *wlc, u32 macintstatus)
 {
 	d11regs_t *regs = wlc->regs;
 #ifdef BCMDBG
@@ -6752,7 +6752,7 @@ static void wlc_war16165(wlc_info_t *wlc
 /* process an individual tx_status_t */
 /* WLC_HIGH_API */
 bool BCMFASTPATH
-wlc_dotxstatus(wlc_info_t *wlc, tx_status_t *txs, uint32 frm_tx2)
+wlc_dotxstatus(wlc_info_t *wlc, tx_status_t *txs, u32 frm_tx2)
 {
 	void *p;
 	uint queue;
@@ -6953,9 +6953,9 @@ wlc_txfifo_complete(wlc_info_t *wlc, uin
 /* Given the beacon interval in kus, and a 64 bit TSF in us,
  * return the offset (in us) of the TSF from the last TBTT
  */
-uint32 wlc_calc_tbtt_offset(uint32 bp, uint32 tsf_h, uint32 tsf_l)
+u32 wlc_calc_tbtt_offset(u32 bp, u32 tsf_h, u32 tsf_l)
 {
-	uint32 k, btklo, btkhi, offset;
+	u32 k, btklo, btkhi, offset;
 
 	/* TBTT is always an even multiple of the beacon_interval,
 	 * so the TBTT less than or equal to the beacon timestamp is
@@ -6970,7 +6970,7 @@ uint32 wlc_calc_tbtt_offset(uint32 bp, u
 	 * BP = beacon interval (Kusec, 16bits)
 	 * BIu = BP * 2^10 = beacon interval (usec, 26bits)
 	 *
-	 * To keep the calculations in uint32s, the modulo operation
+	 * To keep the calculations in u32s, the modulo operation
 	 * on the high part of BT needs to be done in parts using the
 	 * relations:
 	 * X*Y mod Z = ((X mod Z) * (Y mod Z)) mod Z
@@ -7003,8 +7003,8 @@ uint32 wlc_calc_tbtt_offset(uint32 bp, u
 	offset = btklo % bp;
 
 	/* K[2] = ((2^16 % BP) * 2^16) % BP */
-	k = (uint32) (1 << 16) % bp;
-	k = (uint32) (k * 1 << 16) % (uint32) bp;
+	k = (u32) (1 << 16) % bp;
+	k = (u32) (k * 1 << 16) % (u32) bp;
 
 	/* offset += (BTk[2] * K[2]) % BP */
 	offset += ((btkhi & 0xffff) * k) % bp;
@@ -7046,7 +7046,7 @@ static void
 prep_mac80211_status(wlc_info_t *wlc, d11rxhdr_t *rxh, void *p,
 		     struct ieee80211_rx_status *rx_status)
 {
-	uint32 tsf_l, tsf_h;
+	u32 tsf_l, tsf_h;
 	wlc_d11rxhdr_t *wlc_rxh = (wlc_d11rxhdr_t *) rxh;
 	int preamble;
 	int channel;
@@ -7922,7 +7922,7 @@ void wlc_bss_update_beacon(wlc_info_t *w
 	if (MBSS_BCN_ENAB(cfg)) {	/* Optimize:  Some of if/else could be combined */
 	} else if (HWBCN_ENAB(cfg)) {	/* Hardware beaconing for this config */
 		u16 bcn[BCN_TMPL_LEN / 2];
-		uint32 both_valid = MCMD_BCN0VLD | MCMD_BCN1VLD;
+		u32 both_valid = MCMD_BCN0VLD | MCMD_BCN1VLD;
 		d11regs_t *regs = wlc->regs;
 		osl_t *osh = NULL;
 
@@ -8198,7 +8198,7 @@ static void wlc_process_eventq(void *arg
 }
 
 void
-wlc_uint64_sub(uint32 *a_high, uint32 *a_low, uint32 b_high, uint32 b_low)
+wlc_uint64_sub(u32 *a_high, u32 *a_low, u32 b_high, u32 b_low)
 {
 	if (b_low > *a_low) {
 		/* low half needs a carry */
@@ -8209,7 +8209,7 @@ wlc_uint64_sub(uint32 *a_high, uint32 *a
 }
 
 static ratespec_t
-mac80211_wlc_set_nrate(wlc_info_t *wlc, wlcband_t *cur_band, uint32 int_val)
+mac80211_wlc_set_nrate(wlc_info_t *wlc, wlcband_t *cur_band, u32 int_val)
 {
 	u8 stf = (int_val & NRATE_STF_MASK) >> NRATE_STF_SHIFT;
 	u8 rate = int_val & NRATE_RATE_MASK;
@@ -8351,7 +8351,7 @@ wlc_duty_cycle_set(wlc_info_t *wlc, int
 
 void
 wlc_pktengtx(wlc_info_t *wlc, wl_pkteng_t *pkteng, u8 rate,
-	     struct ether_addr *sa, uint32 wait_delay)
+	     struct ether_addr *sa, u32 wait_delay)
 {
 	bool suspend;
 	u16 val = M_PKTENG_MODE_TX;
@@ -8474,12 +8474,12 @@ void wlc_copyfrom_shm(wlc_info_t *wlc, u
 }
 
 /* wrapper BMAC functions to for HIGH driver access */
-void wlc_mctrl(wlc_info_t *wlc, uint32 mask, uint32 val)
+void wlc_mctrl(wlc_info_t *wlc, u32 mask, u32 val)
 {
 	wlc_bmac_mctrl(wlc->hw, mask, val);
 }
 
-void wlc_corereset(wlc_info_t *wlc, uint32 flags)
+void wlc_corereset(wlc_info_t *wlc, u32 flags)
 {
 	wlc_bmac_corereset(wlc->hw, flags);
 }
@@ -8521,7 +8521,7 @@ void wlc_set_rcmta(wlc_info_t *wlc, int
 	wlc_bmac_set_rcmta(wlc->hw, idx, addr);
 }
 
-void wlc_read_tsf(wlc_info_t *wlc, uint32 *tsf_l_ptr, uint32 *tsf_h_ptr)
+void wlc_read_tsf(wlc_info_t *wlc, u32 *tsf_l_ptr, u32 *tsf_h_ptr)
 {
 	wlc_bmac_read_tsf(wlc->hw, tsf_l_ptr, tsf_h_ptr);
 }
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.h
@@ -420,7 +420,7 @@ typedef struct wlc_hwband {
 	u8 bandhw_stf_ss_mode;	/* HW configured STF type, 0:siso; 1:cdd */
 	u16 CWmin;
 	u16 CWmax;
-	uint32 core_flags;
+	u32 core_flags;
 
 	u16 phytype;		/* phytype */
 	u16 phyrev;
@@ -451,10 +451,10 @@ struct wlc_hw_info {
 	uint corerev;		/* core revision */
 	u8 sromrev;		/* version # of the srom */
 	u16 boardrev;	/* version # of particular board */
-	uint32 boardflags;	/* Board specific flags from srom */
-	uint32 boardflags2;	/* More board flags if sromrev >= 4 */
-	uint32 machwcap;	/* MAC capabilities (corerev >= 13) */
-	uint32 machwcap_backup;	/* backup of machwcap (corerev >= 13) */
+	u32 boardflags;	/* Board specific flags from srom */
+	u32 boardflags2;	/* More board flags if sromrev >= 4 */
+	u32 machwcap;	/* MAC capabilities (corerev >= 13) */
+	u32 machwcap_backup;	/* backup of machwcap (corerev >= 13) */
 	u16 ucode_dbgsel;	/* dbgsel for ucode debug(config gpio) */
 
 	si_t *sih;		/* SB handle (cookie for siutils calls) */
@@ -483,12 +483,12 @@ struct wlc_hw_info {
 	mbool pllreq;		/* pll requests to keep PLL on */
 
 	u8 suspended_fifos;	/* Which TX fifo to remain awake for */
-	uint32 maccontrol;	/* Cached value of maccontrol */
+	u32 maccontrol;	/* Cached value of maccontrol */
 	uint mac_suspend_depth;	/* current depth of mac_suspend levels */
-	uint32 wake_override;	/* Various conditions to force MAC to WAKE mode */
-	uint32 mute_override;	/* Prevent ucode from sending beacons */
+	u32 wake_override;	/* Various conditions to force MAC to WAKE mode */
+	u32 mute_override;	/* Prevent ucode from sending beacons */
 	struct ether_addr etheraddr;	/* currently configured ethernet address */
-	uint32 led_gpio_mask;	/* LED GPIO Mask */
+	u32 led_gpio_mask;	/* LED GPIO Mask */
 	bool noreset;		/* true= do not reset hw, used by WLC_OUT */
 	bool forcefastclk;	/* true if the h/w is forcing the use of fast clk */
 	bool clk;		/* core is out of reset and has clock */
@@ -506,9 +506,9 @@ struct wlc_hw_info {
 	struct wl_timer *wdtimer;	/* timer for watchdog routine */
 	struct ether_addr orig_etheraddr;	/* original hw ethernet address */
 	u16 rpc_dngl_agg;	/* rpc agg control for dongle */
-	uint32 mem_required_def;	/* memory required to replenish RX DMA ring */
-	uint32 mem_required_lower;	/* memory required with lower RX bound */
-	uint32 mem_required_least;	/* minimum memory requirement to handle RX */
+	u32 mem_required_def;	/* memory required to replenish RX DMA ring */
+	u32 mem_required_lower;	/* memory required with lower RX bound */
+	u32 mem_required_least;	/* minimum memory requirement to handle RX */
 
 #endif				/* WLC_LOW_ONLY */
 
@@ -516,7 +516,7 @@ struct wlc_hw_info {
 	u8 antsel_type;	/* Type of boardlevel mimo antenna switch-logic
 				 * 0 = N/A, 1 = 2x4 board, 2 = 2x3 CB2 board
 				 */
-	uint32 antsel_avail;	/* put antsel_info_t here if more info is needed */
+	u32 antsel_avail;	/* put antsel_info_t here if more info is needed */
 #endif				/* WLC_LOW */
 };
 
@@ -552,9 +552,9 @@ struct wlc_info {
 	u16 fastpwrup_dly;	/* time in us needed to bring up d11 fast clock */
 
 	/* interrupt */
-	uint32 macintstatus;	/* bit channel between isr and dpc */
-	uint32 macintmask;	/* sw runtime master macintmask value */
-	uint32 defmacintmask;	/* default "on" macintmask value */
+	u32 macintstatus;	/* bit channel between isr and dpc */
+	u32 macintmask;	/* sw runtime master macintmask value */
+	u32 defmacintmask;	/* default "on" macintmask value */
 
 	/* up and down */
 	bool device_present;	/* (removable) device is present */
@@ -583,8 +583,8 @@ struct wlc_info {
 #ifdef WLC_HIGH_ONLY
 	rpctx_info_t *rpctx;	/* RPC TX module */
 	bool reset_bmac_pending;	/* bmac reset is in progressing */
-	uint32 rpc_agg;		/* host agg: bit 16-31, bmac agg: bit 0-15 */
-	uint32 rpc_msglevel;	/* host rpc: bit 16-31, bmac rpc: bit 0-15 */
+	u32 rpc_agg;		/* host agg: bit 16-31, bmac agg: bit 0-15 */
+	u32 rpc_msglevel;	/* host rpc: bit 16-31, bmac rpc: bit 0-15 */
 #endif
 
 	ampdu_info_t *ampdu;	/* ampdu module handler */
@@ -599,7 +599,7 @@ struct wlc_info {
 	u16 deviceid;	/* PCI device id */
 	uint ucode_rev;		/* microcode revision */
 
-	uint32 machwcap;	/* MAC capabilities, BMAC shadow */
+	u32 machwcap;	/* MAC capabilities, BMAC shadow */
 
 	struct ether_addr perm_etheraddr;	/* original sprom local ethernet address */
 
@@ -661,7 +661,7 @@ struct wlc_info {
 	u8 bcn_li_dtim;	/* beacon listen interval in # dtims */
 
 	bool WDarmed;		/* watchdog timer is armed */
-	uint32 WDlast;		/* last time wlc_watchdog() was called */
+	u32 WDlast;		/* last time wlc_watchdog() was called */
 
 	/* WME */
 	ac_bitmap_t wme_dp;	/* Discard (oldest first) policy per AC */
@@ -776,13 +776,13 @@ struct wlc_info {
 
 	pkt_cb_t *pkt_callback;	/* tx completion callback handlers */
 
-	uint32 txretried;	/* tx retried number in one msdu */
+	u32 txretried;	/* tx retried number in one msdu */
 
 	ratespec_t bcn_rspec;	/* save bcn ratespec purpose */
 
 	bool apsd_sta_usp;	/* Unscheduled Service Period in progress on STA */
 	struct wl_timer *apsd_trigger_timer;	/* timer for wme apsd trigger frames */
-	uint32 apsd_trigger_timeout;	/* timeout value for apsd_trigger_timer (in ms)
+	u32 apsd_trigger_timeout;	/* timeout value for apsd_trigger_timer (in ms)
 					 * 0 == disable
 					 */
 	ac_bitmap_t apsd_trigger_ac;	/* Permissible Acess Category in which APSD Null
@@ -809,10 +809,10 @@ struct wlc_info {
 
 	wlc_if_t *wlcif_list;	/* linked list of wlc_if structs */
 	wlc_txq_info_t *active_queue;	/* txq for the currently active transmit context */
-	uint32 mpc_dur;		/* total time (ms) in mpc mode except for the
+	u32 mpc_dur;		/* total time (ms) in mpc mode except for the
 				 * portion since radio is turned off last time
 				 */
-	uint32 mpc_laston_ts;	/* timestamp (ms) when radio is turned off last
+	u32 mpc_laston_ts;	/* timestamp (ms) when radio is turned off last
 				 * time
 				 */
 	bool pr80838_war;
@@ -870,11 +870,11 @@ struct antsel_info {
 	((len1 == len2) && !bcmp(ssid1, ssid2, len1))
 
 /* API shared by both WLC_HIGH and WLC_LOW driver */
-extern void wlc_high_dpc(wlc_info_t *wlc, uint32 macintstatus);
+extern void wlc_high_dpc(wlc_info_t *wlc, u32 macintstatus);
 extern void wlc_fatal_error(wlc_info_t *wlc);
 extern void wlc_bmac_rpc_watchdog(wlc_info_t *wlc);
 extern void wlc_recv(wlc_info_t *wlc, void *p);
-extern bool wlc_dotxstatus(wlc_info_t *wlc, tx_status_t *txs, uint32 frm_tx2);
+extern bool wlc_dotxstatus(wlc_info_t *wlc, tx_status_t *txs, u32 frm_tx2);
 extern void wlc_txfifo(wlc_info_t *wlc, uint fifo, void *p, bool commit,
 		       s8 txpktpend);
 extern void wlc_txfifo_complete(wlc_info_t *wlc, uint fifo, s8 txpktpend);
@@ -892,8 +892,8 @@ extern void wlc_set_rcmta(wlc_info_t *wl
 			  const struct ether_addr *addr);
 extern void wlc_set_addrmatch(wlc_info_t *wlc, int match_reg_offset,
 			      const struct ether_addr *addr);
-extern void wlc_read_tsf(wlc_info_t *wlc, uint32 *tsf_l_ptr,
-			 uint32 *tsf_h_ptr);
+extern void wlc_read_tsf(wlc_info_t *wlc, u32 *tsf_l_ptr,
+			 u32 *tsf_h_ptr);
 extern void wlc_set_cwmin(wlc_info_t *wlc, u16 newmin);
 extern void wlc_set_cwmax(wlc_info_t *wlc, u16 newmax);
 extern void wlc_fifoerrors(wlc_info_t *wlc);
@@ -903,7 +903,7 @@ extern void wlc_protection_upd(wlc_info_
 extern void wlc_hwtimer_gptimer_set(wlc_info_t *wlc, uint us);
 extern void wlc_hwtimer_gptimer_abort(wlc_info_t *wlc);
 extern void wlc_pktengtx(wlc_info_t *wlc, wl_pkteng_t *pkteng, u8 rate,
-			 struct ether_addr *sa, uint32 wait_delay);
+			 struct ether_addr *sa, u32 wait_delay);
 
 #if defined(BCMDBG)
 extern void wlc_print_rxh(d11rxhdr_t *rxh);
@@ -959,9 +959,9 @@ extern void wlc_dump_ie(wlc_info_t *wlc,
 extern bool wlc_ps_check(wlc_info_t *wlc);
 extern void wlc_reprate_init(wlc_info_t *wlc);
 extern void wlc_bsscfg_reprate_init(wlc_bsscfg_t *bsscfg);
-extern void wlc_uint64_sub(uint32 *a_high, uint32 *a_low, uint32 b_high,
-			   uint32 b_low);
-extern uint32 wlc_calc_tbtt_offset(uint32 bi, uint32 tsf_h, uint32 tsf_l);
+extern void wlc_uint64_sub(u32 *a_high, u32 *a_low, u32 b_high,
+			   u32 b_low);
+extern u32 wlc_calc_tbtt_offset(u32 bi, u32 tsf_h, u32 tsf_l);
 
 /* Shared memory access */
 extern void wlc_write_shm(wlc_info_t *wlc, uint offset, u16 v);
@@ -996,7 +996,7 @@ extern bool wlc_timers_init(wlc_info_t *
 
 extern const bcm_iovar_t wlc_iovars[];
 
-extern int wlc_doiovar(void *hdl, const bcm_iovar_t *vi, uint32 actionid,
+extern int wlc_doiovar(void *hdl, const bcm_iovar_t *vi, u32 actionid,
 		       const char *name, void *params, uint p_len, void *arg,
 		       int len, int val_size, wlc_if_t *wlcif);
 
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.c
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.c
@@ -117,12 +117,12 @@ void wlapi_intrson(wlc_phy_shim_info_t *
 	wl_intrson(physhim->wl);
 }
 
-uint32 wlapi_intrsoff(wlc_phy_shim_info_t *physhim)
+u32 wlapi_intrsoff(wlc_phy_shim_info_t *physhim)
 {
 	return wl_intrsoff(physhim->wl);
 }
 
-void wlapi_intrsrestore(wlc_phy_shim_info_t *physhim, uint32 macintmask)
+void wlapi_intrsrestore(wlc_phy_shim_info_t *physhim, u32 macintmask)
 {
 	wl_intrsrestore(physhim->wl, macintmask);
 }
@@ -144,7 +144,7 @@ wlapi_bmac_mhf(wlc_phy_shim_info_t *phys
 	wlc_bmac_mhf(physhim->wlc_hw, idx, mask, val, bands);
 }
 
-void wlapi_bmac_corereset(wlc_phy_shim_info_t *physhim, uint32 flags)
+void wlapi_bmac_corereset(wlc_phy_shim_info_t *physhim, u32 flags)
 {
 	wlc_bmac_corereset(physhim->wlc_hw, flags);
 }
@@ -164,7 +164,7 @@ void wlapi_enable_mac(wlc_phy_shim_info_
 	wlc_enable_mac(physhim->wlc);
 }
 
-void wlapi_bmac_mctrl(wlc_phy_shim_info_t *physhim, uint32 mask, uint32 val)
+void wlapi_bmac_mctrl(wlc_phy_shim_info_t *physhim, u32 mask, u32 val)
 {
 	wlc_bmac_mctrl(physhim->wlc_hw, mask, val);
 }
@@ -233,21 +233,21 @@ void wlapi_ucode_sample_init(wlc_phy_shi
 
 void
 wlapi_copyfrom_objmem(wlc_phy_shim_info_t *physhim, uint offset, void *buf,
-		      int len, uint32 sel)
+		      int len, u32 sel)
 {
 	wlc_bmac_copyfrom_objmem(physhim->wlc_hw, offset, buf, len, sel);
 }
 
 void
 wlapi_copyto_objmem(wlc_phy_shim_info_t *physhim, uint offset, const void *buf,
-		    int l, uint32 sel)
+		    int l, u32 sel)
 {
 	wlc_bmac_copyto_objmem(physhim->wlc_hw, offset, buf, l, sel);
 }
 
 void
 wlapi_bmac_pktengtx(wlc_phy_shim_info_t *physhim, wl_pkteng_t *pkteng,
-		    u8 rate, struct ether_addr *sa, uint32 wait_delay)
+		    u8 rate, struct ether_addr *sa, u32 wait_delay)
 {
 	wlc_pktengtx(physhim->wlc, pkteng, rate, sa, wait_delay);
 }
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.h
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.h
@@ -71,21 +71,21 @@ extern void wlapi_add_timer(wlc_phy_shim
 extern bool wlapi_del_timer(wlc_phy_shim_info_t *physhim,
 			    struct wlapi_timer *t);
 extern void wlapi_intrson(wlc_phy_shim_info_t *physhim);
-extern uint32 wlapi_intrsoff(wlc_phy_shim_info_t *physhim);
+extern u32 wlapi_intrsoff(wlc_phy_shim_info_t *physhim);
 extern void wlapi_intrsrestore(wlc_phy_shim_info_t *physhim,
-			       uint32 macintmask);
+			       u32 macintmask);
 
 extern void wlapi_bmac_write_shm(wlc_phy_shim_info_t *physhim, uint offset,
 				 u16 v);
 extern u16 wlapi_bmac_read_shm(wlc_phy_shim_info_t *physhim, uint offset);
 extern void wlapi_bmac_mhf(wlc_phy_shim_info_t *physhim, u8 idx,
 			   u16 mask, u16 val, int bands);
-extern void wlapi_bmac_corereset(wlc_phy_shim_info_t *physhim, uint32 flags);
+extern void wlapi_bmac_corereset(wlc_phy_shim_info_t *physhim, u32 flags);
 extern void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t *physhim);
 extern void wlapi_switch_macfreq(wlc_phy_shim_info_t *physhim, u8 spurmode);
 extern void wlapi_enable_mac(wlc_phy_shim_info_t *physhim);
-extern void wlapi_bmac_mctrl(wlc_phy_shim_info_t *physhim, uint32 mask,
-			     uint32 val);
+extern void wlapi_bmac_mctrl(wlc_phy_shim_info_t *physhim, u32 mask,
+			     u32 val);
 extern void wlapi_bmac_phy_reset(wlc_phy_shim_info_t *physhim);
 extern void wlapi_bmac_bw_set(wlc_phy_shim_info_t *physhim, u16 bw);
 extern void wlapi_bmac_phyclk_fgc(wlc_phy_shim_info_t *physhim, bool clk);
@@ -102,14 +102,14 @@ extern u16 wlapi_bmac_rate_shm_offset(wl
 					 u8 rate);
 extern void wlapi_ucode_sample_init(wlc_phy_shim_info_t *physhim);
 extern void wlapi_copyfrom_objmem(wlc_phy_shim_info_t *physhim, uint,
-				  void *buf, int, uint32 sel);
+				  void *buf, int, u32 sel);
 extern void wlapi_copyto_objmem(wlc_phy_shim_info_t *physhim, uint,
-				const void *buf, int, uint32);
+				const void *buf, int, u32);
 
 extern void wlapi_high_update_phy_mode(wlc_phy_shim_info_t *physhim,
-				       uint32 phy_mode);
+				       u32 phy_mode);
 extern void wlapi_bmac_pktengtx(wlc_phy_shim_info_t *physhim,
 				wl_pkteng_t *pkteng, u8 rate,
-				struct ether_addr *sa, uint32 wait_delay);
+				struct ether_addr *sa, u32 wait_delay);
 extern u16 wlapi_bmac_get_txant(wlc_phy_shim_info_t *physhim);
 #endif				/* _wlc_phy_shim_h_ */
--- a/drivers/staging/brcm80211/sys/wlc_pub.h
+++ b/drivers/staging/brcm80211/sys/wlc_pub.h
@@ -240,7 +240,7 @@ typedef int (*dump_fn_t) (void *handle,
  * All pointers may point into the same buffer.
  */
 typedef int (*iovar_fn_t) (void *handle, const bcm_iovar_t *vi,
-			   uint32 actionid, const char *name, void *params,
+			   u32 actionid, const char *name, void *params,
 			   uint plen, void *arg, int alen, int vsize,
 			   struct wlc_if *wlcif);
 
@@ -296,13 +296,13 @@ typedef struct wlc_pub {
 	struct ether_addr *multicast;	/* ptr to list of multicast addresses */
 	uint nmulticast;	/* # enabled multicast addresses */
 
-	uint32 wlfeatureflag;	/* Flags to control sw features from registry */
+	u32 wlfeatureflag;	/* Flags to control sw features from registry */
 	int psq_pkts_total;	/* total num of ps pkts */
 
 	u16 txmaxpkts;	/* max number of large pkts allowed to be pending */
 
 	/* s/w decryption counters */
-	uint32 swdecrypt;	/* s/w decrypt attempts */
+	u32 swdecrypt;	/* s/w decrypt attempts */
 
 	int bcmerror;		/* last bcm error */
 
@@ -325,8 +325,8 @@ typedef struct wlc_pub {
 	u16 boardrev;	/* version # of particular board */
 	u8 sromrev;		/* version # of the srom */
 	char srom_ccode[WLC_CNTRY_BUF_SZ];	/* Country Code in SROM */
-	uint32 boardflags;	/* Board specific flags from srom */
-	uint32 boardflags2;	/* More board flags if sromrev >= 4 */
+	u32 boardflags;	/* Board specific flags from srom */
+	u32 boardflags2;	/* More board flags if sromrev >= 4 */
 	bool tempsense_disable;	/* disable periodic tempsense check */
 
 	bool _lmac;		/* lmac module included and enabled */
@@ -343,7 +343,7 @@ typedef struct wl_rxsts {
 	uint datarate;		/* rate in 500kbps */
 	uint antenna;		/* antenna pkts received on */
 	uint pktlength;		/* pkt length minus bcm phy hdr */
-	uint32 mactime;		/* time stamp from mac, count per 1us */
+	u32 mactime;		/* time stamp from mac, count per 1us */
 	uint sq;		/* signal quality */
 	int32 signal;		/* in dbm */
 	int32 noise;		/* in dbm */
@@ -512,8 +512,8 @@ extern void wlc_init(struct wlc_info *wl
 extern void wlc_reset(struct wlc_info *wlc);
 
 extern void wlc_intrson(struct wlc_info *wlc);
-extern uint32 wlc_intrsoff(struct wlc_info *wlc);
-extern void wlc_intrsrestore(struct wlc_info *wlc, uint32 macintmask);
+extern u32 wlc_intrsoff(struct wlc_info *wlc);
+extern void wlc_intrsrestore(struct wlc_info *wlc, u32 macintmask);
 extern bool wlc_intrsupd(struct wlc_info *wlc);
 extern bool wlc_isr(struct wlc_info *wlc, bool *wantdpc);
 extern bool wlc_dpc(struct wlc_info *wlc, bool bounded);
@@ -536,19 +536,19 @@ extern int wlc_bmac_up_finish(struct wlc
 extern int wlc_bmac_down_prep(struct wlc_hw_info *wlc_hw);
 extern int wlc_bmac_down_finish(struct wlc_hw_info *wlc_hw);
 
-extern uint32 wlc_reg_read(struct wlc_info *wlc, void *r, uint size);
-extern void wlc_reg_write(struct wlc_info *wlc, void *r, uint32 v, uint size);
-extern void wlc_corereset(struct wlc_info *wlc, uint32 flags);
+extern u32 wlc_reg_read(struct wlc_info *wlc, void *r, uint size);
+extern void wlc_reg_write(struct wlc_info *wlc, void *r, u32 v, uint size);
+extern void wlc_corereset(struct wlc_info *wlc, u32 flags);
 extern void wlc_mhf(struct wlc_info *wlc, u8 idx, u16 mask, u16 val,
 		    int bands);
 extern u16 wlc_mhf_get(struct wlc_info *wlc, u8 idx, int bands);
-extern uint32 wlc_delta_txfunfl(struct wlc_info *wlc, int fifo);
+extern u32 wlc_delta_txfunfl(struct wlc_info *wlc, int fifo);
 extern void wlc_rate_lookup_init(struct wlc_info *wlc, wlc_rateset_t *rateset);
 extern void wlc_default_rateset(struct wlc_info *wlc, wlc_rateset_t *rs);
 
 /* wlc_phy.c helper functions */
 extern void wlc_set_ps_ctrl(struct wlc_info *wlc);
-extern void wlc_mctrl(struct wlc_info *wlc, uint32 mask, uint32 val);
+extern void wlc_mctrl(struct wlc_info *wlc, u32 mask, u32 val);
 extern void wlc_scb_ratesel_init_all(struct wlc_info *wlc);
 
 /* ioctl */
@@ -566,8 +566,8 @@ extern void wlc_event_if(struct wlc_info
 extern void wlc_suspend_mac_and_wait(struct wlc_info *wlc);
 extern void wlc_enable_mac(struct wlc_info *wlc);
 extern u16 wlc_rate_shm_offset(struct wlc_info *wlc, u8 rate);
-extern uint32 wlc_get_rspec_history(struct wlc_bsscfg *cfg);
-extern uint32 wlc_get_current_highest_rate(struct wlc_bsscfg *cfg);
+extern u32 wlc_get_rspec_history(struct wlc_bsscfg *cfg);
+extern u32 wlc_get_current_highest_rate(struct wlc_bsscfg *cfg);
 
 static inline int wlc_iovar_getuint(struct wlc_info *wlc, const char *name,
 				    uint *arg)
@@ -621,7 +621,7 @@ extern void wlc_pmkid_event(struct wlc_b
 void wlc_device_removed(void *arg);
 #endif
 
-/* BMAC RPC: 7 uint32 params: pkttotlen, fifo, commit, fid, txpktpend, pktflag, rpc_id */
+/* BMAC RPC: 7 u32 params: pkttotlen, fifo, commit, fid, txpktpend, pktflag, rpc_id */
 #define WLC_RPCTX_PARAMS		32
 
 #endif				/* _wlc_pub_h_ */
--- a/drivers/staging/brcm80211/sys/wlc_rate.c
+++ b/drivers/staging/brcm80211/sys/wlc_rate.c
@@ -153,7 +153,7 @@ const mcs_info_t mcs_table[MCS_TABLE_SIZ
  *   other fields: refer to table 78 of section 17.3.2.2 of the original .11a standard
  */
 typedef struct legacy_phycfg {
-	uint32 rate_ofdm;	/* ofdm mac rate */
+	u32 rate_ofdm;	/* ofdm mac rate */
 	u8 tx_phy_ctl3;	/* phy ctl byte 3, code rate, modulation type, # of streams */
 } legacy_phycfg_t;
 
--- a/drivers/staging/brcm80211/sys/wlc_rate.h
+++ b/drivers/staging/brcm80211/sys/wlc_rate.h
@@ -28,10 +28,10 @@ extern const struct wlc_rateset wlc_lrs_
 extern const struct wlc_rateset rate_limit_1_2;
 
 typedef struct mcs_info {
-	uint32 phy_rate_20;	/* phy rate in kbps [20Mhz] */
-	uint32 phy_rate_40;	/* phy rate in kbps [40Mhz] */
-	uint32 phy_rate_20_sgi;	/* phy rate in kbps [20Mhz] with SGI */
-	uint32 phy_rate_40_sgi;	/* phy rate in kbps [40Mhz] with SGI */
+	u32 phy_rate_20;	/* phy rate in kbps [20Mhz] */
+	u32 phy_rate_40;	/* phy rate in kbps [40Mhz] */
+	u32 phy_rate_20_sgi;	/* phy rate in kbps [20Mhz] with SGI */
+	u32 phy_rate_40_sgi;	/* phy rate in kbps [40Mhz] with SGI */
 	u8 tx_phy_ctl3;	/* phy ctl byte 3, code rate, modulation type, # of streams */
 	u8 leg_ofdm;		/* matching legacy ofdm rate in 500bkps */
 } mcs_info_t;
@@ -65,7 +65,7 @@ extern const mcs_info_t mcs_table[];
 /* rate spec : holds rate and mode specific information required to generate a tx frame. */
 /* Legacy CCK and OFDM information is held in the same manner as was done in the past    */
 /* (in the lower byte) the upper 3 bytes primarily hold MIMO specific information        */
-typedef uint32 ratespec_t;
+typedef u32 ratespec_t;
 
 /* rate spec bit fields */
 #define RSPEC_RATE_MASK		0x0000007F	/* Either 500Kbps units or MIMO MCS idx */
--- a/drivers/staging/brcm80211/sys/wlc_rpc.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpc.h
@@ -425,15 +425,15 @@ static inline rpc_buf_t *wlc_rpc_buf_all
 {
 	rpc_buf_t *rpc_buf;
 
-	rpc_buf = bcm_rpc_buf_alloc(rpc, len + sizeof(uint32));
+	rpc_buf = bcm_rpc_buf_alloc(rpc, len + sizeof(u32));
 
 	if (!rpc_buf)
 		return NULL;
 
 	bcm_xdr_buf_init(b, bcm_rpc_buf_data(bcm_rpc_tp_get(rpc), rpc_buf),
-			 len + sizeof(uint32));
+			 len + sizeof(u32));
 
-	bcm_xdr_pack_uint32(b, rpc_id);
+	bcm_xdr_pack_u32(b, rpc_id);
 
 	return rpc_buf;
 }
@@ -446,9 +446,9 @@ wlc_rpc_id_get(struct rpc_info *rpc, rpc
 	bcm_xdr_buf_t b;
 
 	bcm_xdr_buf_init(&b, bcm_rpc_buf_data(bcm_rpc_tp_get(rpc), buf),
-			 sizeof(uint32));
+			 sizeof(u32));
 
-	bcm_xdr_unpack_uint32(&b, (uint32 *) ((uintptr) & rpc_id));
+	bcm_xdr_unpack_u32(&b, (u32 *) ((uintptr) & rpc_id));
 	return rpc_id;
 }
 #endif
@@ -488,12 +488,12 @@ extern void wlc_rpc_bmac_dump_txfifohist
 extern void wlc_rpc_high_dispatch(wlc_rpc_ctx_t *ctx, struct rpc_buf *buf);
 #endif
 
-/* Packed structure for ease of transport across RPC bus along uint32 boundary */
+/* Packed structure for ease of transport across RPC bus along u32 boundary */
 typedef struct wlc_rpc_txstatus {
-	uint32 PAD_framelen;
-	uint32 status_frameid;
-	uint32 sequence_lasttxtime;
-	uint32 ackphyrxsh_phyerr;
+	u32 PAD_framelen;
+	u32 status_frameid;
+	u32 sequence_lasttxtime;
+	u32 ackphyrxsh_phyerr;
 } wlc_rpc_txstatus_t;
 
 static inline
--- a/drivers/staging/brcm80211/sys/wlc_scb.h
+++ b/drivers/staging/brcm80211/sys/wlc_scb.h
@@ -24,7 +24,7 @@ extern bool wlc_aggregatable(wlc_info_t
 #define AMPDU_TX_BA_MAX_WSIZE	64	/* max Tx ba window size (in pdu) */
 /* structure to store per-tid state for the ampdu initiator */
 typedef struct scb_ampdu_tid_ini {
-	uint32 magic;
+	u32 magic;
 	u8 tx_in_transit;	/* number of pending mpdus in transit in driver */
 	u8 tid;		/* initiator tid for easy lookup */
 	u8 txretry[AMPDU_TX_BA_MAX_WSIZE];	/* tx retry count; indexed by seq modulo */
@@ -39,7 +39,7 @@ typedef struct scb_ampdu {
 	u8 max_pdu;		/* max pdus allowed in ampdu */
 	u8 release;		/* # of mpdus released at a time */
 	u16 min_len;		/* min mpdu len to support the density */
-	uint32 max_rxlen;	/* max ampdu rcv length; 8k, 16k, 32k, 64k */
+	u32 max_rxlen;	/* max ampdu rcv length; 8k, 16k, 32k, 64k */
 	struct pktq txq;	/* sdu transmit queue pending aggregation */
 
 	/* This could easily be a ini[] pointer and we keep this info in wl itself instead
@@ -54,9 +54,9 @@ typedef struct scb_ampdu {
 
 /* station control block - one per remote MAC address */
 struct scb {
-	uint32 magic;
-	uint32 flags;		/* various bit flags as defined below */
-	uint32 flags2;		/* various bit flags2 as defined below */
+	u32 magic;
+	u32 flags;		/* various bit flags as defined below */
+	u32 flags2;		/* various bit flags2 as defined below */
 	u8 state;		/* current state bitfield of auth/assoc process */
 	struct ether_addr ea;	/* station address */
 	void *fragbuf[NUMPRIO];	/* defragmentation buffer per prio */
--- a/drivers/staging/brcm80211/util/aiutils.c
+++ b/drivers/staging/brcm80211/util/aiutils.c
@@ -33,10 +33,10 @@
 
 /* EROM parsing */
 
-static uint32
-get_erom_ent(si_t *sih, uint32 **eromptr, uint32 mask, uint32 match)
+static u32
+get_erom_ent(si_t *sih, u32 **eromptr, u32 mask, u32 match)
 {
-	uint32 ent;
+	u32 ent;
 	uint inv = 0, nom = 0;
 
 	while (TRUE) {
@@ -68,11 +68,11 @@ get_erom_ent(si_t *sih, uint32 **eromptr
 	return ent;
 }
 
-static uint32
-get_asd(si_t *sih, uint32 **eromptr, uint sp, uint ad, uint st,
-	uint32 *addrl, uint32 *addrh, uint32 *sizel, uint32 *sizeh)
+static u32
+get_asd(si_t *sih, u32 **eromptr, uint sp, uint ad, uint st,
+	u32 *addrl, u32 *addrh, u32 *sizel, u32 *sizeh)
 {
-	uint32 asd, sz, szd;
+	u32 asd, sz, szd;
 
 	asd = get_erom_ent(sih, eromptr, ER_VALID, ER_VALID);
 	if (((asd & ER_TAG1) != ER_ADD) ||
@@ -112,13 +112,13 @@ void BCMATTACHFN(ai_scan) (si_t *sih, vo
 {
 	si_info_t *sii = SI_INFO(sih);
 	chipcregs_t *cc = (chipcregs_t *) regs;
-	uint32 erombase, *eromptr, *eromlim;
+	u32 erombase, *eromptr, *eromlim;
 
 	erombase = R_REG(sii->osh, &cc->eromptr);
 
 	switch (BUSTYPE(sih->bustype)) {
 	case SI_BUS:
-		eromptr = (uint32 *) REG_MAP(erombase, SI_CORE_SIZE);
+		eromptr = (u32 *) REG_MAP(erombase, SI_CORE_SIZE);
 		break;
 
 	case PCI_BUS:
@@ -134,7 +134,7 @@ void BCMATTACHFN(ai_scan) (si_t *sih, vo
 	case SPI_BUS:
 	case SDIO_BUS:
 #endif				/* BCMSDIO */
-		eromptr = (uint32 *) (uintptr) erombase;
+		eromptr = (u32 *) (uintptr) erombase;
 		break;
 
 	default:
@@ -143,13 +143,13 @@ void BCMATTACHFN(ai_scan) (si_t *sih, vo
 		ASSERT(0);
 		return;
 	}
-	eromlim = eromptr + (ER_REMAPCONTROL / sizeof(uint32));
+	eromlim = eromptr + (ER_REMAPCONTROL / sizeof(u32));
 
 	SI_VMSG(("ai_scan: regs = 0x%p, erombase = 0x%08x, eromptr = 0x%p, eromlim = 0x%p\n", regs, erombase, eromptr, eromlim));
 	while (eromptr < eromlim) {
-		uint32 cia, cib, cid, mfg, crev, nmw, nsw, nmp, nsp;
-		uint32 mpd, asd, addrl, addrh, sizel, sizeh;
-		uint32 *base;
+		u32 cia, cib, cid, mfg, crev, nmw, nsw, nmp, nsp;
+		u32 mpd, asd, addrl, addrh, sizel, sizeh;
+		u32 *base;
 		uint i, j, idx;
 		bool br;
 
@@ -317,8 +317,8 @@ void BCMATTACHFN(ai_scan) (si_t *sih, vo
 void *ai_setcoreidx(si_t *sih, uint coreidx)
 {
 	si_info_t *sii = SI_INFO(sih);
-	uint32 addr = sii->coresba[coreidx];
-	uint32 wrap = sii->wrapba[coreidx];
+	u32 addr = sii->coresba[coreidx];
+	u32 wrap = sii->wrapba[coreidx];
 	void *regs;
 
 	if (coreidx >= sii->numcores)
@@ -381,7 +381,7 @@ int ai_numaddrspaces(si_t *sih)
 }
 
 /* Return the address of the nth address space in the current core */
-uint32 ai_addrspace(si_t *sih, uint asidx)
+u32 ai_addrspace(si_t *sih, uint asidx)
 {
 	si_info_t *sii;
 	uint cidx;
@@ -400,7 +400,7 @@ uint32 ai_addrspace(si_t *sih, uint asid
 }
 
 /* Return the size of the nth address space in the current core */
-uint32 ai_addrspacesize(si_t *sih, uint asidx)
+u32 ai_addrspacesize(si_t *sih, uint asidx)
 {
 	si_info_t *sii;
 	uint cidx;
@@ -437,10 +437,10 @@ void ai_setint(si_t *sih, int siflag)
 {
 }
 
-void ai_write_wrap_reg(si_t *sih, uint32 offset, uint32 val)
+void ai_write_wrap_reg(si_t *sih, u32 offset, u32 val)
 {
 	si_info_t *sii = SI_INFO(sih);
-	uint32 *w = (uint32 *) sii->curwrap;
+	u32 *w = (u32 *) sii->curwrap;
 	W_REG(sii->osh, w + (offset / 4), val);
 	return;
 }
@@ -448,7 +448,7 @@ void ai_write_wrap_reg(si_t *sih, uint32
 uint ai_corevendor(si_t *sih)
 {
 	si_info_t *sii;
-	uint32 cia;
+	u32 cia;
 
 	sii = SI_INFO(sih);
 	cia = sii->cia[sii->curidx];
@@ -458,7 +458,7 @@ uint ai_corevendor(si_t *sih)
 uint ai_corerev(si_t *sih)
 {
 	si_info_t *sii;
-	uint32 cib;
+	u32 cib;
 
 	sii = SI_INFO(sih);
 	cib = sii->cib[sii->curidx];
@@ -490,7 +490,7 @@ bool ai_iscoreup(si_t *sih)
 uint ai_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val)
 {
 	uint origidx = 0;
-	uint32 *r = NULL;
+	u32 *r = NULL;
 	uint w;
 	uint intr_val = 0;
 	bool fast = FALSE;
@@ -514,7 +514,7 @@ uint ai_corereg(si_t *sih, uint coreidx,
 						     SI_CORE_SIZE);
 			ASSERT(GOODREGS(sii->regs[coreidx]));
 		}
-		r = (uint32 *) ((unsigned char *) sii->regs[coreidx] + regoff);
+		r = (u32 *) ((unsigned char *) sii->regs[coreidx] + regoff);
 	} else if (BUSTYPE(sih->bustype) == PCI_BUS) {
 		/* If pci/pcie, we can get at pci/pcie regs and on newer cores to chipc */
 
@@ -522,7 +522,7 @@ uint ai_corereg(si_t *sih, uint coreidx,
 			/* Chipc registers are mapped at 12KB */
 
 			fast = TRUE;
-			r = (uint32 *) ((char *)sii->curmap +
+			r = (u32 *) ((char *)sii->curmap +
 					PCI_16KB0_CCREGS_OFFSET + regoff);
 		} else if (sii->pub.buscoreidx == coreidx) {
 			/* pci registers are at either in the last 2KB of an 8KB window
@@ -530,11 +530,11 @@ uint ai_corereg(si_t *sih, uint coreidx,
 			 */
 			fast = TRUE;
 			if (SI_FAST(sii))
-				r = (uint32 *) ((char *)sii->curmap +
+				r = (u32 *) ((char *)sii->curmap +
 						PCI_16KB0_PCIREGS_OFFSET +
 						regoff);
 			else
-				r = (uint32 *) ((char *)sii->curmap +
+				r = (u32 *) ((char *)sii->curmap +
 						((regoff >= SBCONFIGOFF) ?
 						 PCI_BAR0_PCISBR_OFFSET :
 						 PCI_BAR0_PCIREGS_OFFSET) +
@@ -549,7 +549,7 @@ uint ai_corereg(si_t *sih, uint coreidx,
 		origidx = si_coreidx(&sii->pub);
 
 		/* switch core */
-		r = (uint32 *) ((unsigned char *) ai_setcoreidx(&sii->pub, coreidx) +
+		r = (u32 *) ((unsigned char *) ai_setcoreidx(&sii->pub, coreidx) +
 				regoff);
 	}
 	ASSERT(r != NULL);
@@ -574,10 +574,10 @@ uint ai_corereg(si_t *sih, uint coreidx,
 	return w;
 }
 
-void ai_core_disable(si_t *sih, uint32 bits)
+void ai_core_disable(si_t *sih, u32 bits)
 {
 	si_info_t *sii;
-	volatile uint32 dummy;
+	volatile u32 dummy;
 	aidmp_t *ai;
 
 	sii = SI_INFO(sih);
@@ -602,11 +602,11 @@ void ai_core_disable(si_t *sih, uint32 b
  * bits - core specific bits that are set during and after reset sequence
  * resetbits - core specific bits that are set only during reset sequence
  */
-void ai_core_reset(si_t *sih, uint32 bits, uint32 resetbits)
+void ai_core_reset(si_t *sih, u32 bits, u32 resetbits)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
-	volatile uint32 dummy;
+	volatile u32 dummy;
 
 	sii = SI_INFO(sih);
 	ASSERT(GOODREGS(sii->curwrap));
@@ -630,11 +630,11 @@ void ai_core_reset(si_t *sih, uint32 bit
 	OSL_DELAY(1);
 }
 
-void ai_core_cflags_wo(si_t *sih, uint32 mask, uint32 val)
+void ai_core_cflags_wo(si_t *sih, u32 mask, u32 val)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
-	uint32 w;
+	u32 w;
 
 	sii = SI_INFO(sih);
 
@@ -655,11 +655,11 @@ void ai_core_cflags_wo(si_t *sih, uint32
 	}
 }
 
-uint32 ai_core_cflags(si_t *sih, uint32 mask, uint32 val)
+u32 ai_core_cflags(si_t *sih, u32 mask, u32 val)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
-	uint32 w;
+	u32 w;
 
 	sii = SI_INFO(sih);
 	if (BCM47162_DMP()) {
@@ -681,11 +681,11 @@ uint32 ai_core_cflags(si_t *sih, uint32
 	return R_REG(sii->osh, &ai->ioctrl);
 }
 
-uint32 ai_core_sflags(si_t *sih, uint32 mask, uint32 val)
+u32 ai_core_sflags(si_t *sih, u32 mask, u32 val)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
-	uint32 w;
+	u32 w;
 
 	sii = SI_INFO(sih);
 	if (BCM47162_DMP()) {
--- a/drivers/staging/brcm80211/util/bcmotp.c
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -85,7 +85,7 @@ typedef struct {
 	u16 wsize;		/* Size of otp in words */
 	u16 rows;		/* Geometry */
 	u16 cols;		/* Geometry */
-	uint32 status;		/* Flag bits (lock/prog/rv).
+	u32 status;		/* Flag bits (lock/prog/rv).
 				 * (Reflected only when OTP is power cycled)
 				 */
 	u16 hwbase;		/* hardware subregion offset */
@@ -189,7 +189,7 @@ static u16 ipxotp_read_bit(void *oh, chi
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint k, row, col;
-	uint32 otpp, st;
+	u32 otpp, st;
 
 	row = off / oi->cols;
 	col = off % oi->cols;
@@ -240,7 +240,7 @@ static int ipxotp_max_rgnsz(si_t *sih, i
 static void BCMNMIATTACHFN(_ipxotp_init) (otpinfo_t *oi, chipcregs_t *cc)
 {
 	uint k;
-	uint32 otpp, st;
+	u32 otpp, st;
 
 	/* record word offset of General Use Region for various chipcommon revs */
 	if (oi->sih->ccrev == 21 || oi->sih->ccrev == 24
@@ -274,7 +274,7 @@ static void BCMNMIATTACHFN(_ipxotp_init)
 
 	if ((CHIPID(oi->sih->chip) == BCM43224_CHIP_ID)
 	    || (CHIPID(oi->sih->chip) == BCM43225_CHIP_ID)) {
-		uint32 p_bits;
+		u32 p_bits;
 		p_bits =
 		    (ipxotp_otpr(oi, cc, oi->otpgu_base + OTPGU_P_OFF) &
 		     OTPGU_P_MSK)
@@ -603,7 +603,7 @@ static u16 hndotp_read_bit(void *oh, chi
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint k, row, col;
-	uint32 otpp, st;
+	u32 otpp, st;
 	osl_t *osh;
 
 	osh = si_osh(oi->sih);
@@ -635,7 +635,7 @@ static void *BCMNMIATTACHFN(hndotp_init)
 	uint idx;
 	chipcregs_t *cc;
 	otpinfo_t *oi;
-	uint32 cap = 0, clkdiv, otpdiv = 0;
+	u32 cap = 0, clkdiv, otpdiv = 0;
 	void *ret = NULL;
 	osl_t *osh;
 
@@ -709,7 +709,7 @@ static void *BCMNMIATTACHFN(hndotp_init)
 static int hndotp_read_region(void *oh, int region, u16 *data, uint *wlen)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
-	uint32 idx, st;
+	u32 idx, st;
 	chipcregs_t *cc;
 	int i;
 
@@ -740,9 +740,9 @@ static int hndotp_nvread(void *oh, char
 {
 	int rc = 0;
 	otpinfo_t *oi = (otpinfo_t *) oh;
-	uint32 base, bound, lim = 0, st;
+	u32 base, bound, lim = 0, st;
 	int i, chunk, gchunks, tsz = 0;
-	uint32 idx;
+	u32 idx;
 	chipcregs_t *cc;
 	uint offset;
 	u16 *rawotp = NULL;
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -85,7 +85,7 @@ static int sprom_read_pci(osl_t *osh, si
 #if defined(BCMNVRAMR)
 static int otp_read_pci(osl_t *osh, si_t *sih, u16 *buf, uint bufsz);
 #endif
-static u16 srom_cc_cmd(si_t *sih, osl_t *osh, void *ccregs, uint32 cmd,
+static u16 srom_cc_cmd(si_t *sih, osl_t *osh, void *ccregs, u32 cmd,
 			  uint wordoff, u16 data);
 
 static int initvars_table(osl_t *osh, char *start, char *end, char **vars,
@@ -388,7 +388,7 @@ BCMATTACHFN(srom_parsecis) (osl_t *osh,
 	u8 *cis, tup, tlen, sromrev = 1;
 	int i, j;
 	bool ag_init = FALSE;
-	uint32 w32;
+	u32 w32;
 	uint funcid;
 	uint cisnum;
 	int32 boardnum;
@@ -1413,7 +1413,7 @@ BCMATTACHFN(srom_parsecis) (osl_t *osh,
  * not in the bus cores.
  */
 static u16
-srom_cc_cmd(si_t *sih, osl_t *osh, void *ccregs, uint32 cmd, uint wordoff,
+srom_cc_cmd(si_t *sih, osl_t *osh, void *ccregs, u32 cmd, uint wordoff,
 	    u16 data)
 {
 	chipcregs_t *cc = (chipcregs_t *) ccregs;
@@ -1708,11 +1708,11 @@ static void
 BCMATTACHFN(_initvars_srom_pci) (u8 sromrev, u16 *srom, uint off,
 				 varbuf_t *b) {
 	u16 w;
-	uint32 val;
+	u32 val;
 	const sromvar_t *srv;
 	uint width;
 	uint flags;
-	uint32 sr = (1 << sromrev);
+	u32 sr = (1 << sromrev);
 
 	varbuf_append(b, "sromrev=%d", sromrev);
 
@@ -1786,7 +1786,7 @@ BCMATTACHFN(_initvars_srom_pci) (u8 srom
 			 *(oncount >> 24) (offcount >> 8)
 			 */
 			else if (flags & SRFL_LEDDC) {
-				uint32 w32 = (((val >> 8) & 0xff) << 24) |	/* oncount */
+				u32 w32 = (((val >> 8) & 0xff) << 24) |	/* oncount */
 				    (((val & 0xff)) << 8);	/* offcount */
 				varbuf_append(b, "leddc=%d", w32);
 			} else if (flags & SRFL_PRHEX)
@@ -1858,7 +1858,7 @@ BCMATTACHFN(initvars_srom_pci) (si_t *si
 				uint *count) {
 	u16 *srom, *sromwindow;
 	u8 sromrev = 0;
-	uint32 sr;
+	u32 sr;
 	varbuf_t b;
 	char *vp, *base = NULL;
 	osl_t *osh = si_osh(sih);
@@ -1922,7 +1922,7 @@ BCMATTACHFN(initvars_srom_pci) (si_t *si
 	 */
 	if (err) {
 		char *value;
-		uint32 val;
+		u32 val;
 		val = 0;
 
 		value = si_getdevpathvar(sih, "sromrev");
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -566,13 +566,13 @@ bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (voi
 
 #if defined(BCMDBG)
 int
-bcm_format_flags(const bcm_bit_desc_t *bd, uint32 flags, char *buf, int len)
+bcm_format_flags(const bcm_bit_desc_t *bd, u32 flags, char *buf, int len)
 {
 	int i;
 	char *p = buf;
 	char hexstr[16];
 	int slen = 0, nlen = 0;
-	uint32 bit;
+	u32 bit;
 	const char *name;
 
 	if (len < 2 || !buf)
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -109,8 +109,8 @@ typedef struct dma_info {
 	dmaaddr_t txdpa;	/* Aligned physical address of descriptor ring */
 	dmaaddr_t txdpaorig;	/* Original physical address of descriptor ring */
 	u16 txdalign;	/* #bytes added to alloc'd mem to align txd */
-	uint32 txdalloc;	/* #bytes allocated for the ring */
-	uint32 xmtptrbase;	/* When using unaligned descriptors, the ptr register
+	u32 txdalloc;	/* #bytes allocated for the ring */
+	u32 xmtptrbase;	/* When using unaligned descriptors, the ptr register
 				 * is not just an index, it needs all 13 bits to be
 				 * an offset from the addr register.
 				 */
@@ -124,8 +124,8 @@ typedef struct dma_info {
 	dmaaddr_t rxdpa;	/* Aligned physical address of descriptor ring */
 	dmaaddr_t rxdpaorig;	/* Original physical address of descriptor ring */
 	u16 rxdalign;	/* #bytes added to alloc'd mem to align rxd */
-	uint32 rxdalloc;	/* #bytes allocated for the ring */
-	uint32 rcvptrbase;	/* Base for ptr reg when using unaligned descriptors */
+	u32 rxdalloc;	/* #bytes allocated for the ring */
+	u32 rcvptrbase;	/* Base for ptr reg when using unaligned descriptors */
 
 	/* tunables */
 	u16 rxbufsize;	/* rx buffer size in bytes,
@@ -223,7 +223,7 @@ static void _dma_counterreset(dma_info_t
 static void _dma_fifoloopbackenable(dma_info_t *di);
 static uint _dma_ctrlflags(dma_info_t *di, uint mask, uint flags);
 static u8 dma_align_sizetobits(uint size);
-static void *dma_ringalloc(osl_t *osh, uint32 boundary, uint size,
+static void *dma_ringalloc(osl_t *osh, u32 boundary, uint size,
 			   u16 *alignbits, uint *alloced,
 			   dmaaddr_t *descpa, osldma_t **dmah);
 
@@ -273,7 +273,7 @@ static bool dma64_rxstopped(dma_info_t *
 static bool dma64_rxenabled(dma_info_t *di);
 static bool _dma64_addrext(osl_t *osh, dma64regs_t *dma64regs);
 
-static inline uint32 parity32(uint32 data);
+static inline u32 parity32(u32 data);
 
 const di_fcn_t dma64proc = {
 	(di_detach_t) _dma_detach,
@@ -548,11 +548,11 @@ hnddma_t *dma_attach(osl_t *osh, char *n
 
 	if ((di->ddoffsetlow != 0) && !di->addrext) {
 		if (PHYSADDRLO(di->txdpa) > SI_PCI_DMA_SZ) {
-			DMA_ERROR(("%s: dma_attach: txdpa 0x%x: addrext not supported\n", di->name, (uint32) PHYSADDRLO(di->txdpa)));
+			DMA_ERROR(("%s: dma_attach: txdpa 0x%x: addrext not supported\n", di->name, (u32) PHYSADDRLO(di->txdpa)));
 			goto fail;
 		}
 		if (PHYSADDRLO(di->rxdpa) > SI_PCI_DMA_SZ) {
-			DMA_ERROR(("%s: dma_attach: rxdpa 0x%x: addrext not supported\n", di->name, (uint32) PHYSADDRLO(di->rxdpa)));
+			DMA_ERROR(("%s: dma_attach: rxdpa 0x%x: addrext not supported\n", di->name, (u32) PHYSADDRLO(di->rxdpa)));
 			goto fail;
 		}
 	}
@@ -588,7 +588,7 @@ hnddma_t *dma_attach(osl_t *osh, char *n
 /* init the tx or rx descriptor */
 static inline void
 dma32_dd_upd(dma_info_t *di, dma32dd_t *ddring, dmaaddr_t pa, uint outidx,
-	     uint32 *flags, uint32 bufcount)
+	     u32 *flags, u32 bufcount)
 {
 	/* dma32 uses 32-bit control to fit both flags and bufcounter */
 	*flags = *flags | (bufcount & CTRL_BC_MASK);
@@ -599,7 +599,7 @@ dma32_dd_upd(dma_info_t *di, dma32dd_t *
 		W_SM(&ddring[outidx].ctrl, BUS_SWAP32(*flags));
 	} else {
 		/* address extension */
-		uint32 ae;
+		u32 ae;
 		ASSERT(di->addrext);
 		ae = (PHYSADDRLO(pa) & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
 		PHYSADDRLO(pa) &= ~PCI32ADDR_HIGH;
@@ -612,7 +612,7 @@ dma32_dd_upd(dma_info_t *di, dma32dd_t *
 }
 
 /* Check for odd number of 1's */
-static inline uint32 parity32(uint32 data)
+static inline u32 parity32(u32 data)
 {
 	data ^= data >> 16;
 	data ^= data >> 8;
@@ -627,9 +627,9 @@ static inline uint32 parity32(uint32 dat
 
 static inline void
 dma64_dd_upd(dma_info_t *di, dma64dd_t *ddring, dmaaddr_t pa, uint outidx,
-	     uint32 *flags, uint32 bufcount)
+	     u32 *flags, u32 bufcount)
 {
-	uint32 ctrl2 = bufcount & D64_CTRL2_BC_MASK;
+	u32 ctrl2 = bufcount & D64_CTRL2_BC_MASK;
 
 	/* PCI bus with big(>1G) physical address, use address extension */
 #if defined(__mips__) && defined(IL_BIGENDIAN)
@@ -648,7 +648,7 @@ dma64_dd_upd(dma_info_t *di, dma64dd_t *
 		W_SM(&ddring[outidx].ctrl2, BUS_SWAP32(ctrl2));
 	} else {
 		/* address extension for 32-bit PCI */
-		uint32 ae;
+		u32 ae;
 		ASSERT(di->addrext);
 
 		ae = (PHYSADDRLO(pa) & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
@@ -673,7 +673,7 @@ dma64_dd_upd(dma_info_t *di, dma64dd_t *
 
 static bool _dma32_addrext(osl_t *osh, dma32regs_t *dma32regs)
 {
-	uint32 w;
+	u32 w;
 
 	OR_REG(osh, &dma32regs->control, XC_AE);
 	w = R_REG(osh, &dma32regs->control);
@@ -751,7 +751,7 @@ static void _dma_detach(dma_info_t *di)
 static bool _dma_descriptor_align(dma_info_t *di)
 {
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
-		uint32 addrl;
+		u32 addrl;
 
 		/* Check to see if the descriptors need to be aligned on 4K/8K or not */
 		if (di->d64txregs != NULL) {
@@ -827,7 +827,7 @@ static void _dma_ddtable_init(dma_info_t
 			}
 		} else {
 			/* DMA64 32bits address extension */
-			uint32 ae;
+			u32 ae;
 			ASSERT(di->addrext);
 			ASSERT(PHYSADDRHI(pa) == 0);
 
@@ -865,7 +865,7 @@ static void _dma_ddtable_init(dma_info_t
 				      (PHYSADDRLO(pa) + di->ddoffsetlow));
 		} else {
 			/* dma32 address extension */
-			uint32 ae;
+			u32 ae;
 			ASSERT(di->addrext);
 
 			/* shift the high bit(s) from pa to ae */
@@ -941,7 +941,7 @@ static void _dma_rxenable(dma_info_t *di
 	DMA_TRACE(("%s: dma_rxenable\n", di->name));
 
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
-		uint32 control =
+		u32 control =
 		    (R_REG(di->osh, &di->d64rxregs->control) & D64_RC_AE) |
 		    D64_RC_RE;
 
@@ -954,7 +954,7 @@ static void _dma_rxenable(dma_info_t *di
 		W_REG(di->osh, &di->d64rxregs->control,
 		      ((di->rxoffset << D64_RC_RO_SHIFT) | control));
 	} else if (DMA32_ENAB(di)) {
-		uint32 control =
+		u32 control =
 		    (R_REG(di->osh, &di->d32rxregs->control) & RC_AE) | RC_RE;
 
 		if ((dmactrlflags & DMA_CTRL_PEN) == 0)
@@ -1065,7 +1065,7 @@ static bool BCMFASTPATH _dma_rxfill(dma_
 {
 	void *p;
 	u16 rxin, rxout;
-	uint32 flags = 0;
+	u32 flags = 0;
 	uint n;
 	uint i;
 	dmaaddr_t pa;
@@ -1124,7 +1124,7 @@ static bool BCMFASTPATH _dma_rxfill(dma_
 		/* Do a cached write instead of uncached write since DMA_MAP
 		 * will flush the cache.
 		 */
-		*(uint32 *) (PKTDATA(p)) = 0;
+		*(u32 *) (PKTDATA(p)) = 0;
 
 		if (DMASGLIST_ENAB)
 			bzero(&di->rxp_dmah[rxout], sizeof(hnddma_seg_map_t));
@@ -1335,7 +1335,7 @@ static uint _dma_ctrlflags(dma_info_t *d
 
 	/* If trying to enable parity, check if parity is actually supported */
 	if (dmactrlflags & DMA_CTRL_PEN) {
-		uint32 control;
+		u32 control;
 
 		if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 			control = R_REG(di->osh, &di->d64txregs->control);
@@ -1405,20 +1405,20 @@ u8 dma_align_sizetobits(uint size)
  * descriptor ring size aligned location. This will ensure that the ring will
  * not cross page boundary
  */
-static void *dma_ringalloc(osl_t *osh, uint32 boundary, uint size,
+static void *dma_ringalloc(osl_t *osh, u32 boundary, uint size,
 			   u16 *alignbits, uint *alloced,
 			   dmaaddr_t *descpa, osldma_t **dmah)
 {
 	void *va;
-	uint32 desc_strtaddr;
-	uint32 alignbytes = 1 << *alignbits;
+	u32 desc_strtaddr;
+	u32 alignbytes = 1 << *alignbits;
 
 	va = DMA_ALLOC_CONSISTENT(osh, size, *alignbits, alloced, descpa,
 		dmah);
 	if (NULL == va)
 		return NULL;
 
-	desc_strtaddr = (uint32) ROUNDUP((uintptr) va, alignbytes);
+	desc_strtaddr = (u32) ROUNDUP((uintptr) va, alignbytes);
 	if (((desc_strtaddr + size - 1) & boundary) != (desc_strtaddr
 							& boundary)) {
 		*alignbits = dma_align_sizetobits(size);
@@ -1433,7 +1433,7 @@ static void *dma_ringalloc(osl_t *osh, u
 
 static void dma32_txinit(dma_info_t *di)
 {
-	uint32 control = XC_XE;
+	u32 control = XC_XE;
 
 	DMA_TRACE(("%s: dma_txinit\n", di->name));
 
@@ -1454,7 +1454,7 @@ static void dma32_txinit(dma_info_t *di)
 
 static bool dma32_txenabled(dma_info_t *di)
 {
-	uint32 xc;
+	u32 xc;
 
 	/* If the chip is dead, it is not enabled :-) */
 	xc = R_REG(di->osh, &di->d32txregs->control);
@@ -1581,7 +1581,7 @@ static bool dma32_alloc(dma_info_t *di,
 
 static bool dma32_txreset(dma_info_t *di)
 {
-	uint32 status;
+	u32 status;
 
 	if (di->ntxd == 0)
 		return TRUE;
@@ -1617,7 +1617,7 @@ static bool dma32_rxidle(dma_info_t *di)
 
 static bool dma32_rxreset(dma_info_t *di)
 {
-	uint32 status;
+	u32 status;
 
 	if (di->nrxd == 0)
 		return TRUE;
@@ -1632,7 +1632,7 @@ static bool dma32_rxreset(dma_info_t *di
 
 static bool dma32_rxenabled(dma_info_t *di)
 {
-	uint32 rc;
+	u32 rc;
 
 	rc = R_REG(di->osh, &di->d32rxregs->control);
 	return (rc != 0xffffffff) && (rc & RC_RE);
@@ -1667,7 +1667,7 @@ static int dma32_txfast(dma_info_t *di,
 	unsigned char *data;
 	uint len;
 	u16 txout;
-	uint32 flags = 0;
+	u32 flags = 0;
 	dmaaddr_t pa;
 
 	DMA_TRACE(("%s: dma_txfast\n", di->name));
@@ -1922,7 +1922,7 @@ static void dma32_txrotate(dma_info_t *d
 	uint nactive;
 	uint rot;
 	u16 old, new;
-	uint32 w;
+	u32 w;
 	u16 first, last;
 
 	ASSERT(dma32_txsuspendedidle(di));
@@ -1988,7 +1988,7 @@ static void dma32_txrotate(dma_info_t *d
 
 static void dma64_txinit(dma_info_t *di)
 {
-	uint32 control = D64_XC_XE;
+	u32 control = D64_XC_XE;
 
 	DMA_TRACE(("%s: dma_txinit\n", di->name));
 
@@ -2020,7 +2020,7 @@ static void dma64_txinit(dma_info_t *di)
 
 static bool dma64_txenabled(dma_info_t *di)
 {
-	uint32 xc;
+	u32 xc;
 
 	/* If the chip is dead, it is not enabled :-) */
 	xc = R_REG(di->osh, &di->d64txregs->control);
@@ -2146,7 +2146,7 @@ static bool dma64_alloc(dma_info_t *di,
 
 static bool dma64_txreset(dma_info_t *di)
 {
-	uint32 status;
+	u32 status;
 
 	if (di->ntxd == 0)
 		return TRUE;
@@ -2182,7 +2182,7 @@ static bool dma64_rxidle(dma_info_t *di)
 
 static bool dma64_rxreset(dma_info_t *di)
 {
-	uint32 status;
+	u32 status;
 
 	if (di->nrxd == 0)
 		return TRUE;
@@ -2197,7 +2197,7 @@ static bool dma64_rxreset(dma_info_t *di
 
 static bool dma64_rxenabled(dma_info_t *di)
 {
-	uint32 rc;
+	u32 rc;
 
 	rc = R_REG(di->osh, &di->d64rxregs->control);
 	return (rc != 0xffffffff) && (rc & D64_RC_RE);
@@ -2227,7 +2227,7 @@ static void *dma64_getpos(dma_info_t *di
 {
 	void *va;
 	bool idle;
-	uint32 cd_offset;
+	u32 cd_offset;
 
 	if (direction == DMA_TX) {
 		cd_offset =
@@ -2261,7 +2261,7 @@ static void *dma64_getpos(dma_info_t *di
 static int dma64_txunframed(dma_info_t *di, void *buf, uint len, bool commit)
 {
 	u16 txout;
-	uint32 flags = 0;
+	u32 flags = 0;
 	dmaaddr_t pa;		/* phys addr */
 
 	txout = di->txout;
@@ -2318,7 +2318,7 @@ static int BCMFASTPATH dma64_txfast(dma_
 	unsigned char *data;
 	uint len;
 	u16 txout;
-	uint32 flags = 0;
+	u32 flags = 0;
 	dmaaddr_t pa;
 
 	DMA_TRACE(("%s: dma_txfast\n", di->name));
@@ -2577,7 +2577,7 @@ static void *BCMFASTPATH dma64_getnextrx
 
 static bool _dma64_addrext(osl_t *osh, dma64regs_t * dma64regs)
 {
-	uint32 w;
+	u32 w;
 	OR_REG(osh, &dma64regs->control, D64_XC_AE);
 	w = R_REG(osh, &dma64regs->control);
 	AND_REG(osh, &dma64regs->control, ~D64_XC_AE);
@@ -2593,7 +2593,7 @@ static void dma64_txrotate(dma_info_t *d
 	uint nactive;
 	uint rot;
 	u16 old, new;
-	uint32 w;
+	u32 w;
 	u16 first, last;
 
 	ASSERT(dma64_txsuspendedidle(di));
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -43,20 +43,20 @@
 
 /* PLL controls/clocks */
 static void si_pmu1_pllinit0(si_t *sih, osl_t *osh, chipcregs_t *cc,
-			     uint32 xtal);
-static uint32 si_pmu1_cpuclk0(si_t *sih, osl_t *osh, chipcregs_t *cc);
-static uint32 si_pmu1_alpclk0(si_t *sih, osl_t *osh, chipcregs_t *cc);
+			     u32 xtal);
+static u32 si_pmu1_cpuclk0(si_t *sih, osl_t *osh, chipcregs_t *cc);
+static u32 si_pmu1_alpclk0(si_t *sih, osl_t *osh, chipcregs_t *cc);
 
 /* PMU resources */
 static bool si_pmu_res_depfltr_bb(si_t *sih);
 static bool si_pmu_res_depfltr_ncb(si_t *sih);
 static bool si_pmu_res_depfltr_paldo(si_t *sih);
 static bool si_pmu_res_depfltr_npaldo(si_t *sih);
-static uint32 si_pmu_res_deps(si_t *sih, osl_t *osh, chipcregs_t *cc,
-			      uint32 rsrcs, bool all);
+static u32 si_pmu_res_deps(si_t *sih, osl_t *osh, chipcregs_t *cc,
+			      u32 rsrcs, bool all);
 static uint si_pmu_res_uptime(si_t *sih, osl_t *osh, chipcregs_t *cc,
 			      u8 rsrc);
-static void si_pmu_res_masks(si_t *sih, uint32 * pmin, uint32 * pmax);
+static void si_pmu_res_masks(si_t *sih, u32 * pmin, u32 * pmax);
 static void si_pmu_spuravoid_pllupdate(si_t *sih, chipcregs_t *cc,
 				       osl_t *osh, u8 spuravoid);
 
@@ -69,7 +69,7 @@ static void si_pmu_set_4330_plldivs(si_t
 #define FVCO_960	960000	/* 960MHz */
 
 /* Read/write a chipcontrol reg */
-uint32 si_pmu_chipcontrol(si_t *sih, uint reg, uint32 mask, uint32 val)
+u32 si_pmu_chipcontrol(si_t *sih, uint reg, u32 mask, u32 val)
 {
 	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol_addr), ~0,
 		   reg);
@@ -78,7 +78,7 @@ uint32 si_pmu_chipcontrol(si_t *sih, uin
 }
 
 /* Read/write a regcontrol reg */
-uint32 si_pmu_regcontrol(si_t *sih, uint reg, uint32 mask, uint32 val)
+u32 si_pmu_regcontrol(si_t *sih, uint reg, u32 mask, u32 val)
 {
 	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_addr), ~0,
 		   reg);
@@ -87,7 +87,7 @@ uint32 si_pmu_regcontrol(si_t *sih, uint
 }
 
 /* Read/write a pllcontrol reg */
-uint32 si_pmu_pllcontrol(si_t *sih, uint reg, uint32 mask, uint32 val)
+u32 si_pmu_pllcontrol(si_t *sih, uint reg, u32 mask, u32 val)
 {
 	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pllcontrol_addr), ~0,
 		   reg);
@@ -117,10 +117,10 @@ BCMATTACHFN(si_pmu_set_switcher_voltage)
 	ASSERT(cc != NULL);
 
 	W_REG(osh, &cc->regcontrol_addr, 0x01);
-	W_REG(osh, &cc->regcontrol_data, (uint32) (bb_voltage & 0x1f) << 22);
+	W_REG(osh, &cc->regcontrol_data, (u32) (bb_voltage & 0x1f) << 22);
 
 	W_REG(osh, &cc->regcontrol_addr, 0x00);
-	W_REG(osh, &cc->regcontrol_data, (uint32) (rf_voltage & 0x1f) << 14);
+	W_REG(osh, &cc->regcontrol_data, (u32) (rf_voltage & 0x1f) << 14);
 
 	/* Return to original core */
 	si_setcoreidx(sih, origidx);
@@ -218,7 +218,7 @@ u16 BCMINITFN(si_pmu_fast_pwrup_delay) (
 		if (ISSIM_ENAB(sih))
 			delay = 70;
 		else {
-			uint32 ilp = si_ilp_clock(sih);
+			u32 ilp = si_ilp_clock(sih);
 			delay =
 			    (si_pmu_res_uptime(sih, osh, cc, RES4329_HT_AVAIL) +
 			     D11SCC_SLOW2FAST_TRANSITION) * ((1000000 + ilp -
@@ -233,7 +233,7 @@ u16 BCMINITFN(si_pmu_fast_pwrup_delay) (
 		if (ISSIM_ENAB(sih))
 			delay = 70;
 		else {
-			uint32 ilp = si_ilp_clock(sih);
+			u32 ilp = si_ilp_clock(sih);
 			delay =
 			    (si_pmu_res_uptime(sih, osh, cc, RES4336_HT_AVAIL) +
 			     D11SCC_SLOW2FAST_TRANSITION) * ((1000000 + ilp -
@@ -245,7 +245,7 @@ u16 BCMINITFN(si_pmu_fast_pwrup_delay) (
 		if (ISSIM_ENAB(sih))
 			delay = 70;
 		else {
-			uint32 ilp = si_ilp_clock(sih);
+			u32 ilp = si_ilp_clock(sih);
 			delay =
 			    (si_pmu_res_uptime(sih, osh, cc, RES4330_HT_AVAIL) +
 			     D11SCC_SLOW2FAST_TRANSITION) * ((1000000 + ilp -
@@ -262,11 +262,11 @@ u16 BCMINITFN(si_pmu_fast_pwrup_delay) (
 	return (u16) delay;
 }
 
-uint32 BCMATTACHFN(si_pmu_force_ilp) (si_t *sih, osl_t *osh, bool force)
+u32 BCMATTACHFN(si_pmu_force_ilp) (si_t *sih, osl_t *osh, bool force)
 {
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 oldpmucontrol;
+	u32 oldpmucontrol;
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -297,9 +297,9 @@ typedef struct {
 
 /* Change resource dependancies masks */
 typedef struct {
-	uint32 res_mask;	/* resources (chip specific) */
+	u32 res_mask;	/* resources (chip specific) */
 	s8 action;		/* action */
-	uint32 depend_mask;	/* changes to the dependancies mask */
+	u32 depend_mask;	/* changes to the dependancies mask */
 	 bool(*filter) (si_t *sih);	/* action is taken when filter is NULL or return TRUE */
 } pmu_res_depend_t;
 
@@ -592,9 +592,9 @@ static bool BCMATTACHFN(si_pmu_res_depfl
 					sih->boardtype == BCM94325BGABU_BOARD)
 
 /* Determine min/max rsrc masks. Value 0 leaves hardware at default. */
-static void si_pmu_res_masks(si_t *sih, uint32 * pmin, uint32 * pmax)
+static void si_pmu_res_masks(si_t *sih, u32 * pmin, u32 * pmax)
 {
-	uint32 min_mask = 0, max_mask = 0;
+	u32 min_mask = 0, max_mask = 0;
 	uint rsrcs;
 	char *val;
 
@@ -666,13 +666,13 @@ static void si_pmu_res_masks(si_t *sih,
 	val = getvar(NULL, "rmin");
 	if (val != NULL) {
 		PMU_MSG(("Applying rmin=%s to min_mask\n", val));
-		min_mask = (uint32) simple_strtoul(val, NULL, 0);
+		min_mask = (u32) simple_strtoul(val, NULL, 0);
 	}
 	/* Apply nvram override to max mask */
 	val = getvar(NULL, "rmax");
 	if (val != NULL) {
 		PMU_MSG(("Applying rmax=%s to max_mask\n", val));
-		max_mask = (uint32) simple_strtoul(val, NULL, 0);
+		max_mask = (u32) simple_strtoul(val, NULL, 0);
 	}
 
 	*pmin = min_mask;
@@ -688,7 +688,7 @@ void BCMATTACHFN(si_pmu_res_init) (si_t
 	uint pmu_res_updown_table_sz = 0;
 	const pmu_res_depend_t *pmu_res_depend_table = NULL;
 	uint pmu_res_depend_table_sz = 0;
-	uint32 min_mask = 0, max_mask = 0;
+	u32 min_mask = 0, max_mask = 0;
 	char name[8], *val;
 	uint i, rsrcs;
 
@@ -788,9 +788,9 @@ void BCMATTACHFN(si_pmu_res_init) (si_t
 			continue;
 		PMU_MSG(("Applying %s=%s to rsrc %d res_updn_timer\n", name,
 			 val, i));
-		W_REG(osh, &cc->res_table_sel, (uint32) i);
+		W_REG(osh, &cc->res_table_sel, (u32) i);
 		W_REG(osh, &cc->res_updn_timer,
-		      (uint32) simple_strtoul(val, NULL, 0));
+		      (u32) simple_strtoul(val, NULL, 0));
 	}
 
 	/* Program resource dependencies table */
@@ -839,9 +839,9 @@ void BCMATTACHFN(si_pmu_res_init) (si_t
 			continue;
 		PMU_MSG(("Applying %s=%s to rsrc %d res_dep_mask\n", name, val,
 			 i));
-		W_REG(osh, &cc->res_table_sel, (uint32) i);
+		W_REG(osh, &cc->res_table_sel, (u32) i);
 		W_REG(osh, &cc->res_dep_mask,
-		      (uint32) simple_strtoul(val, NULL, 0));
+		      (u32) simple_strtoul(val, NULL, 0));
 	}
 
 	/* Determine min/max rsrc masks */
@@ -875,7 +875,7 @@ typedef struct {
 	u16 freq;
 	u8 xf;
 	u8 wbint;
-	uint32 wbfrac;
+	u32 wbfrac;
 } pmu0_xtaltab0_t;
 
 /* the following table is based on 880Mhz fvco */
@@ -907,7 +907,7 @@ typedef struct {
 	u8 p1div;
 	u8 p2div;
 	u8 ndiv_int;
-	uint32 ndiv_frac;
+	u32 ndiv_frac;
 } pmu1_xtaltab0_t;
 
 static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_880_4329)[] = {
@@ -1152,7 +1152,7 @@ static const pmu1_xtaltab0_t *BCMINITFN(
 }
 
 /* select default pll fvco for each chip */
-static uint32 BCMINITFN(si_pmu1_pllfvco0) (si_t *sih)
+static u32 BCMINITFN(si_pmu1_pllfvco0) (si_t *sih)
 {
 #ifdef BCMDBG
 	char chn[8];
@@ -1180,11 +1180,11 @@ static uint32 BCMINITFN(si_pmu1_pllfvco0
 }
 
 /* query alp/xtal clock frequency */
-static uint32
+static u32
 BCMINITFN(si_pmu1_alpclk0) (si_t *sih, osl_t *osh, chipcregs_t *cc)
 {
 	const pmu1_xtaltab0_t *xt;
-	uint32 xf;
+	u32 xf;
 
 	/* Find the frequency in the table */
 	xf = (R_REG(osh, &cc->pmucontrol) & PCTL_XTALFREQ_MASK) >>
@@ -1208,10 +1208,10 @@ BCMINITFN(si_pmu1_alpclk0) (si_t *sih, o
  */
 static void
 BCMATTACHFN(si_pmu1_pllinit0) (si_t *sih, osl_t *osh, chipcregs_t *cc,
-			       uint32 xtal) {
+			       u32 xtal) {
 	const pmu1_xtaltab0_t *xt;
-	uint32 tmp;
-	uint32 buf_strength = 0;
+	u32 tmp;
+	u32 buf_strength = 0;
 	u8 ndiv_mode = 1;
 
 	/* Use h/w default PLL config */
@@ -1451,15 +1451,15 @@ BCMATTACHFN(si_pmu1_pllinit0) (si_t *sih
 }
 
 /* query the CPU clock frequency */
-static uint32
+static u32
 BCMINITFN(si_pmu1_cpuclk0) (si_t *sih, osl_t *osh, chipcregs_t *cc)
 {
-	uint32 tmp, m1div;
+	u32 tmp, m1div;
 #ifdef BCMDBG
-	uint32 ndiv_int, ndiv_frac, p2div, p1div, fvco;
-	uint32 fref;
+	u32 ndiv_int, ndiv_frac, p2div, p1div, fvco;
+	u32 fref;
 #endif
-	uint32 FVCO = si_pmu1_pllfvco0(sih);
+	u32 FVCO = si_pmu1_pllfvco0(sih);
 
 	/* Read m1div from pllcontrol[1] */
 	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL1);
@@ -1559,11 +1559,11 @@ void BCMATTACHFN(si_pmu_pll_init) (si_t
 }
 
 /* query alp/xtal clock frequency */
-uint32 BCMINITFN(si_pmu_alp_clock) (si_t *sih, osl_t *osh)
+u32 BCMINITFN(si_pmu_alp_clock) (si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 clock = ALP_CLOCK;
+	u32 clock = ALP_CLOCK;
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1619,10 +1619,10 @@ uint32 BCMINITFN(si_pmu_alp_clock) (si_t
 /* Find the output of the "m" pll divider given pll controls that start with
  * pllreg "pll0" i.e. 12 for main 6 for phy, 0 for misc.
  */
-static uint32
+static u32
 BCMINITFN(si_pmu5_clock) (si_t *sih, osl_t *osh, chipcregs_t *cc, uint pll0,
 			  uint m) {
-	uint32 tmp, div, ndiv, p1, p2, fc;
+	u32 tmp, div, ndiv, p1, p2, fc;
 
 	if ((pll0 & 3) || (pll0 > PMU4716_MAINPLL_PLL0)) {
 		PMU_ERROR(("%s: Bad pll0: %d\n", __func__, pll0));
@@ -1673,11 +1673,11 @@ BCMINITFN(si_pmu5_clock) (si_t *sih, osl
 /* For designs that feed the same clock to both backplane
  * and CPU just return the CPU clock speed.
  */
-uint32 BCMINITFN(si_pmu_si_clock) (si_t *sih, osl_t *osh)
+u32 BCMINITFN(si_pmu_si_clock) (si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 clock = HT_CLOCK;
+	u32 clock = HT_CLOCK;
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1752,11 +1752,11 @@ uint32 BCMINITFN(si_pmu_si_clock) (si_t
 }
 
 /* query CPU clock frequency */
-uint32 BCMINITFN(si_pmu_cpu_clock) (si_t *sih, osl_t *osh)
+u32 BCMINITFN(si_pmu_cpu_clock) (si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 clock;
+	u32 clock;
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -1796,11 +1796,11 @@ uint32 BCMINITFN(si_pmu_cpu_clock) (si_t
 }
 
 /* query memory clock frequency */
-uint32 BCMINITFN(si_pmu_mem_clock) (si_t *sih, osl_t *osh)
+u32 BCMINITFN(si_pmu_mem_clock) (si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 clock;
+	u32 clock;
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -1843,16 +1843,16 @@ uint32 BCMINITFN(si_pmu_mem_clock) (si_t
 /* Measure ILP clock frequency */
 #define ILP_CALC_DUR	10	/* ms, make sure 1000 can be divided by it. */
 
-static uint32 ilpcycles_per_sec;
+static u32 ilpcycles_per_sec;
 
-uint32 BCMINITFN(si_pmu_ilp_clock) (si_t *sih, osl_t *osh)
+u32 BCMINITFN(si_pmu_ilp_clock) (si_t *sih, osl_t *osh)
 {
 	if (ISSIM_ENAB(sih))
 		return ILP_CLOCK;
 
 	if (ilpcycles_per_sec == 0) {
-		uint32 start, end, delta;
-		uint32 origidx = si_coreidx(sih);
+		u32 start, end, delta;
+		u32 origidx = si_coreidx(sih);
 		chipcregs_t *cc = si_setcoreidx(sih, SI_CC_IDX);
 		ASSERT(cc != NULL);
 		start = R_REG(osh, &cc->pmutimer);
@@ -1910,12 +1910,12 @@ static const sdiod_drive_str_t BCMINITDA
 
 void
 BCMINITFN(si_sdiod_drive_strength_init) (si_t *sih, osl_t *osh,
-					 uint32 drivestrength) {
+					 u32 drivestrength) {
 	chipcregs_t *cc;
 	uint origidx, intr_val = 0;
 	sdiod_drive_str_t *str_tab = NULL;
-	uint32 str_mask = 0;
-	uint32 str_shift = 0;
+	u32 str_mask = 0;
+	u32 str_shift = 0;
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1953,8 +1953,8 @@ BCMINITFN(si_sdiod_drive_strength_init)
 	}
 
 	if (str_tab != NULL) {
-		uint32 drivestrength_sel = 0;
-		uint32 cc_data_temp;
+		u32 drivestrength_sel = 0;
+		u32 cc_data_temp;
 		int i;
 
 		for (i = 0; str_tab[i].strength != 0; i++) {
@@ -2014,9 +2014,9 @@ void BCMATTACHFN(si_pmu_init) (si_t *sih
 static uint
 BCMINITFN(si_pmu_res_uptime) (si_t *sih, osl_t *osh, chipcregs_t *cc,
 			      u8 rsrc) {
-	uint32 deps;
+	u32 deps;
 	uint up, i, dup, dmax;
-	uint32 min_mask = 0, max_mask = 0;
+	u32 min_mask = 0, max_mask = 0;
 
 	/* uptime of resource 'rsrc' */
 	W_REG(osh, &cc->res_table_sel, rsrc);
@@ -2048,12 +2048,12 @@ BCMINITFN(si_pmu_res_uptime) (si_t *sih,
 }
 
 /* Return dependancies (direct or all/indirect) for the given resources */
-static uint32
-si_pmu_res_deps(si_t *sih, osl_t *osh, chipcregs_t *cc, uint32 rsrcs,
+static u32
+si_pmu_res_deps(si_t *sih, osl_t *osh, chipcregs_t *cc, u32 rsrcs,
 		bool all)
 {
-	uint32 deps = 0;
-	uint32 i;
+	u32 deps = 0;
+	u32 i;
 
 	for (i = 0; i <= PMURES_MAX_RESNUM; i++) {
 		if (!(rsrcs & PMURES_BIT(i)))
@@ -2073,7 +2073,7 @@ void si_pmu_otp_power(si_t *sih, osl_t *
 {
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 rsrcs = 0;	/* rsrcs to turn on/off OTP power */
+	u32 rsrcs = 0;	/* rsrcs to turn on/off OTP power */
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -2106,11 +2106,11 @@ void si_pmu_otp_power(si_t *sih, osl_t *
 	}
 
 	if (rsrcs != 0) {
-		uint32 otps;
+		u32 otps;
 
 		/* Figure out the dependancies (exclude min_res_mask) */
-		uint32 deps = si_pmu_res_deps(sih, osh, cc, rsrcs, TRUE);
-		uint32 min_mask = 0, max_mask = 0;
+		u32 deps = si_pmu_res_deps(sih, osh, cc, rsrcs, TRUE);
+		u32 min_mask = 0, max_mask = 0;
 		si_pmu_res_masks(sih, &min_mask, &max_mask);
 		deps &= ~min_mask;
 		/* Turn on/off the power */
@@ -2154,7 +2154,7 @@ void si_pmu_rcal(si_t *sih, osl_t *osh)
 	switch (CHIPID(sih->chip)) {
 	case BCM4329_CHIP_ID:{
 			u8 rcal_code;
-			uint32 val;
+			u32 val;
 
 			/* Kick RCal */
 			W_REG(osh, &cc->chipcontrol_addr, 1);
@@ -2182,12 +2182,12 @@ void si_pmu_rcal(si_t *sih, osl_t *osh)
 			val =
 			    R_REG(osh,
 				  &cc->
-				  regcontrol_data) & ~((uint32) 0x07 << 29);
-			val |= (uint32) (rcal_code & 0x07) << 29;
+				  regcontrol_data) & ~((u32) 0x07 << 29);
+			val |= (u32) (rcal_code & 0x07) << 29;
 			W_REG(osh, &cc->regcontrol_data, val);
 			W_REG(osh, &cc->regcontrol_addr, 1);
-			val = R_REG(osh, &cc->regcontrol_data) & ~(uint32) 0x01;
-			val |= (uint32) ((rcal_code >> 3) & 0x01);
+			val = R_REG(osh, &cc->regcontrol_data) & ~(u32) 0x01;
+			val |= (u32) ((rcal_code >> 3) & 0x01);
 			W_REG(osh, &cc->regcontrol_data, val);
 
 			/* Write RCal code into pmu_chip_ctrl[33:30] */
@@ -2195,13 +2195,13 @@ void si_pmu_rcal(si_t *sih, osl_t *osh)
 			val =
 			    R_REG(osh,
 				  &cc->
-				  chipcontrol_data) & ~((uint32) 0x03 << 30);
-			val |= (uint32) (rcal_code & 0x03) << 30;
+				  chipcontrol_data) & ~((u32) 0x03 << 30);
+			val |= (u32) (rcal_code & 0x03) << 30;
 			W_REG(osh, &cc->chipcontrol_data, val);
 			W_REG(osh, &cc->chipcontrol_addr, 1);
 			val =
-			    R_REG(osh, &cc->chipcontrol_data) & ~(uint32) 0x03;
-			val |= (uint32) ((rcal_code >> 2) & 0x03);
+			    R_REG(osh, &cc->chipcontrol_data) & ~(u32) 0x03;
+			val |= (u32) ((rcal_code >> 2) & 0x03);
 			W_REG(osh, &cc->chipcontrol_data, val);
 
 			/* Set override in pmu_chip_ctrl[29] */
@@ -2226,7 +2226,7 @@ void si_pmu_spuravoid(si_t *sih, osl_t *
 {
 	chipcregs_t *cc;
 	uint origidx, intr_val;
-	uint32 tmp = 0;
+	u32 tmp = 0;
 
 	/* Remember original core before switch to chipc */
 	cc = (chipcregs_t *) si_switch_core(sih, CC_CORE_ID, &origidx,
@@ -2262,7 +2262,7 @@ static void
 si_pmu_spuravoid_pllupdate(si_t *sih, chipcregs_t *cc, osl_t *osh,
 			   u8 spuravoid)
 {
-	uint32 tmp = 0;
+	u32 tmp = 0;
 	u8 phypll_offset = 0;
 	u8 bcm5357_bcm43236_p1div[] = { 0x1, 0x5, 0x5 };
 	u8 bcm5357_bcm43236_ndiv[] = { 0x30, 0xf6, 0xfc };
@@ -2581,18 +2581,18 @@ void si_pmu_radio_enable(si_t *sih, bool
 	case BCM4319_CHIP_ID:
 		if (enable)
 			si_write_wrapperreg(sih, AI_OOBSELOUTB74,
-					    (uint32) 0x868584);
+					    (u32) 0x868584);
 		else
 			si_write_wrapperreg(sih, AI_OOBSELOUTB74,
-					    (uint32) 0x060584);
+					    (u32) 0x060584);
 		break;
 	}
 }
 
 /* Wait for a particular clock level to be on the backplane */
-uint32
-si_pmu_waitforclk_on_backplane(si_t *sih, osl_t *osh, uint32 clk,
-			       uint32 delay)
+u32
+si_pmu_waitforclk_on_backplane(si_t *sih, osl_t *osh, u32 clk,
+			       u32 delay)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -2620,11 +2620,11 @@ si_pmu_waitforclk_on_backplane(si_t *sih
 
 #define EXT_ILP_HZ 32768
 
-uint32 BCMATTACHFN(si_pmu_measure_alpclk) (si_t *sih, osl_t *osh)
+u32 BCMATTACHFN(si_pmu_measure_alpclk) (si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 alp_khz;
+	u32 alp_khz;
 
 	if (sih->pmurev < 10)
 		return 0;
@@ -2637,7 +2637,7 @@ uint32 BCMATTACHFN(si_pmu_measure_alpclk
 	ASSERT(cc != NULL);
 
 	if (R_REG(osh, &cc->pmustatus) & PST_EXTLPOAVAIL) {
-		uint32 ilp_ctr, alp_hz;
+		u32 ilp_ctr, alp_hz;
 
 		/* Enable the reg to measure the freq, in case disabled before */
 		W_REG(osh, &cc->pmu_xtalfreq,
@@ -2670,9 +2670,9 @@ uint32 BCMATTACHFN(si_pmu_measure_alpclk
 
 static void BCMATTACHFN(si_pmu_set_4330_plldivs) (si_t *sih)
 {
-	uint32 FVCO = si_pmu1_pllfvco0(sih) / 1000;
-	uint32 m1div, m2div, m3div, m4div, m5div, m6div;
-	uint32 pllc1, pllc2;
+	u32 FVCO = si_pmu1_pllfvco0(sih) / 1000;
+	u32 m1div, m2div, m3div, m4div, m5div, m6div;
+	u32 pllc1, pllc2;
 
 	m2div = m3div = m4div = m6div = FVCO / 80;
 	m5div = FVCO / 160;
--- a/drivers/staging/brcm80211/util/linux_osl.c
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -73,7 +73,7 @@ struct osl_info {
 };
 
 /* Global ASSERT type flag */
-uint32 g_assert_type;
+u32 g_assert_type;
 
 #ifdef BRCM_FULLMAC
 static s16 linuxbcmerrormap[] = { 0,	/* 0 */
@@ -358,7 +358,7 @@ void osl_pktfree_static(osl_t *osh, void
 }
 #endif /* defined(BRCM_FULLMAC) && defined(DHD_USE_STATIC_BUF) */
 
-uint32 osl_pci_read_config(osl_t *osh, uint offset, uint size)
+u32 osl_pci_read_config(osl_t *osh, uint offset, uint size)
 {
 	uint val = 0;
 	uint retry = PCI_CFG_RETRY;
@@ -558,7 +558,7 @@ void BCMFASTPATH osl_dma_unmap(osl_t *os
 
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 	dir = (direction == DMA_TX) ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE;
-	pci_unmap_single(osh->pdev, (uint32) pa, size, dir);
+	pci_unmap_single(osh->pdev, (u32) pa, size, dir);
 }
 
 #if defined(BCMDBG_ASSERT)
@@ -636,12 +636,12 @@ u16 osl_readw(osl_t *osh, volatile u16 *
 	return (u16) ((rreg) (ctx, (void *)r, sizeof(u16)));
 }
 
-uint32 osl_readl(osl_t *osh, volatile uint32 *r)
+u32 osl_readl(osl_t *osh, volatile u32 *r)
 {
 	osl_rreg_fn_t rreg = ((osl_pubinfo_t *) osh)->rreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
 
-	return (uint32) ((rreg) (ctx, (void *)r, sizeof(uint32)));
+	return (u32) ((rreg) (ctx, (void *)r, sizeof(u32)));
 }
 
 void osl_writeb(osl_t *osh, volatile u8 *r, u8 v)
@@ -660,11 +660,11 @@ void osl_writew(osl_t *osh, volatile u16
 	((wreg) (ctx, (void *)r, v, sizeof(u16)));
 }
 
-void osl_writel(osl_t *osh, volatile uint32 *r, uint32 v)
+void osl_writel(osl_t *osh, volatile u32 *r, u32 v)
 {
 	osl_wreg_fn_t wreg = ((osl_pubinfo_t *) osh)->wreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
 
-	((wreg) (ctx, (void *)r, v, sizeof(uint32)));
+	((wreg) (ctx, (void *)r, v, sizeof(u32)));
 }
 #endif	/* BCMSDIO */
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -89,14 +89,14 @@ static bool pcicore_pmecap(pcicore_info_
 	(WORD_VAL(OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4), a) & 0xffff)
 
 #define write_pci_cfg_byte(a, val) do { \
-	uint32 tmpval; \
+	u32 tmpval; \
 	tmpval = (OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4) & ~0xFF << BYTE_POS(a)) | \
 		val << BYTE_POS(a); \
 	OSL_PCI_WRITE_CONFIG(osh, DWORD_ALIGN(a), 4, tmpval); \
 	} while (0)
 
 #define write_pci_cfg_word(a, val) do { \
-	uint32 tmpval; \
+	u32 tmpval; \
 	tmpval = (OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4) & ~0xFFFF << WORD_POS(a)) | \
 		val << WORD_POS(a); \
 	OSL_PCI_WRITE_CONFIG(osh, DWORD_ALIGN(a), 4, tmpval); \
@@ -154,11 +154,11 @@ void pcicore_deinit(void *pch)
 /* Note that it's caller's responsibility to make sure it's a pci bus */
 u8
 pcicore_find_pci_capability(osl_t *osh, u8 req_cap_id, unsigned char *buf,
-			    uint32 *buflen)
+			    u32 *buflen)
 {
 	u8 cap_id;
 	u8 cap_ptr = 0;
-	uint32 bufsize;
+	u32 bufsize;
 	u8 byte_val;
 
 	/* check for Header type 0 */
@@ -367,25 +367,25 @@ pcie_mdiowrite(pcicore_info_t *pi, uint
 }
 
 /* ***** Support functions ***** */
-u8 pcie_clkreq(void *pch, uint32 mask, uint32 val)
+u8 pcie_clkreq(void *pch, u32 mask, u32 val)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
-	uint32 reg_val;
+	u32 reg_val;
 	u8 offset;
 
 	offset = pi->pciecap_lcreg_offset;
 	if (!offset)
 		return 0;
 
-	reg_val = OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(uint32));
+	reg_val = OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(u32));
 	/* set operation */
 	if (mask) {
 		if (val)
 			reg_val |= PCIE_CLKREQ_ENAB;
 		else
 			reg_val &= ~PCIE_CLKREQ_ENAB;
-		OSL_PCI_WRITE_CONFIG(pi->osh, offset, sizeof(uint32), reg_val);
-		reg_val = OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(uint32));
+		OSL_PCI_WRITE_CONFIG(pi->osh, offset, sizeof(u32), reg_val);
+		reg_val = OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(u32));
 	}
 	if (reg_val & PCIE_CLKREQ_ENAB)
 		return 1;
@@ -395,7 +395,7 @@ u8 pcie_clkreq(void *pch, uint32 mask, u
 
 static void pcie_extendL1timer(pcicore_info_t *pi, bool extend)
 {
-	uint32 w;
+	u32 w;
 	si_t *sih = pi->sih;
 	osl_t *osh = pi->osh;
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
@@ -457,7 +457,7 @@ static void pcie_clkreq_upd(pcicore_info
 /* Done only once at attach time */
 static void pcie_war_polarity(pcicore_info_t *pi)
 {
-	uint32 w;
+	u32 w;
 
 	if (pi->pcie_polarity != 0)
 		return;
@@ -485,7 +485,7 @@ static void pcie_war_aspm_clkreq(pcicore
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	si_t *sih = pi->sih;
 	u16 val16, *reg16;
-	uint32 w;
+	u32 w;
 
 	if (!PCIE_ASPM(sih))
 		return;
@@ -507,11 +507,11 @@ static void pcie_war_aspm_clkreq(pcicore
 		W_REG(pi->osh, reg16, val16);
 
 		w = OSL_PCI_READ_CONFIG(pi->osh, pi->pciecap_lcreg_offset,
-					sizeof(uint32));
+					sizeof(u32));
 		w &= ~PCIE_ASPM_ENAB;
 		w |= pi->pcie_war_aspm_ovr;
 		OSL_PCI_WRITE_CONFIG(pi->osh, pi->pciecap_lcreg_offset,
-				     sizeof(uint32), w);
+				     sizeof(u32), w);
 	}
 
 	reg16 = &pcieregs->sprom[SRSH_CLKREQ_OFFSET_REV5];
@@ -530,7 +530,7 @@ static void pcie_war_aspm_clkreq(pcicore
 /* Needs to happen when coming out of 'standby'/'hibernate' */
 static void pcie_war_serdes(pcicore_info_t *pi)
 {
-	uint32 w = 0;
+	u32 w = 0;
 
 	if (pi->pcie_polarity != 0)
 		pcie_mdiowrite(pi, MDIODATA_DEV_RX, SERDES_RX_CTRL,
@@ -583,7 +583,7 @@ static void pcie_war_pci_setup(pcicore_i
 	si_t *sih = pi->sih;
 	osl_t *osh = pi->osh;
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
-	uint32 w;
+	u32 w;
 
 	if ((sih->buscorerev == 0) || (sih->buscorerev == 1)) {
 		w = pcie_readreg(osh, pcieregs, PCIE_PCIEREGS,
@@ -648,7 +648,7 @@ void BCMATTACHFN(pcicore_attach) (void *
 
 	/* Determine if this board needs override */
 	if (PCIE_ASPM(sih)) {
-		if ((uint32) getintvar(pvars, "boardflags2") & BFL2_PCIEWAR_OVR) {
+		if ((u32) getintvar(pvars, "boardflags2") & BFL2_PCIEWAR_OVR) {
 			pi->pcie_war_aspm_ovr = PCIE_ASPM_DISAB;
 		} else {
 			pi->pcie_war_aspm_ovr = PCIE_ASPM_ENAB;
@@ -693,15 +693,15 @@ void pcicore_up(void *pch, int state)
 void pcicore_sleep(void *pch)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
-	uint32 w;
+	u32 w;
 
 	if (!pi || !PCIE_ASPM(pi->sih))
 		return;
 
 	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pciecap_lcreg_offset,
-				sizeof(uint32));
+				sizeof(u32));
 	w &= ~PCIE_CAP_LCREG_ASPML1;
-	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pciecap_lcreg_offset, sizeof(uint32),
+	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pciecap_lcreg_offset, sizeof(u32),
 			     w);
 
 	pi->pcie_pr42767 = FALSE;
@@ -725,7 +725,7 @@ void pcicore_down(void *pch, int state)
 bool pcicore_pmecap_fast(osl_t *osh)
 {
 	u8 cap_ptr;
-	uint32 pmecap;
+	u32 pmecap;
 
 	cap_ptr =
 	    pcicore_find_pci_capability(osh, PCI_CAP_POWERMGMTCAP_ID, NULL,
@@ -734,7 +734,7 @@ bool pcicore_pmecap_fast(osl_t *osh)
 	if (!cap_ptr)
 		return FALSE;
 
-	pmecap = OSL_PCI_READ_CONFIG(osh, cap_ptr, sizeof(uint32));
+	pmecap = OSL_PCI_READ_CONFIG(osh, cap_ptr, sizeof(u32));
 
 	return (pmecap & PME_CAP_PM_STATES) != 0;
 }
@@ -745,7 +745,7 @@ bool pcicore_pmecap_fast(osl_t *osh)
 static bool pcicore_pmecap(pcicore_info_t *pi)
 {
 	u8 cap_ptr;
-	uint32 pmecap;
+	u32 pmecap;
 
 	if (!pi->pmecap_offset) {
 		cap_ptr =
@@ -759,7 +759,7 @@ static bool pcicore_pmecap(pcicore_info_
 
 		pmecap =
 		    OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset,
-					sizeof(uint32));
+					sizeof(u32));
 
 		/* At least one state can generate PME */
 		pi->pmecap = (pmecap & PME_CAP_PM_STATES) != 0;
@@ -772,17 +772,17 @@ static bool pcicore_pmecap(pcicore_info_
 void pcicore_pmeen(void *pch)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
-	uint32 w;
+	u32 w;
 
 	/* if not pmecapable return */
 	if (!pcicore_pmecap(pi))
 		return;
 
 	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
-				sizeof(uint32));
+				sizeof(u32));
 	w |= (PME_CSR_PME_EN);
 	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
-			     sizeof(uint32), w);
+			     sizeof(u32), w);
 }
 
 /*
@@ -791,13 +791,13 @@ void pcicore_pmeen(void *pch)
 bool pcicore_pmestat(void *pch)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
-	uint32 w;
+	u32 w;
 
 	if (!pcicore_pmecap(pi))
 		return FALSE;
 
 	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
-				sizeof(uint32));
+				sizeof(u32));
 
 	return (w & PME_CSR_PME_STAT) == PME_CSR_PME_STAT;
 }
@@ -807,13 +807,13 @@ bool pcicore_pmestat(void *pch)
 void pcicore_pmeclr(void *pch)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
-	uint32 w;
+	u32 w;
 
 	if (!pcicore_pmecap(pi))
 		return;
 
 	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
-				sizeof(uint32));
+				sizeof(u32));
 
 	PCI_ERROR(("pcicore_pci_pmeclr PMECSR : 0x%x\n", w));
 
@@ -821,10 +821,10 @@ void pcicore_pmeclr(void *pch)
 	w &= ~(PME_CSR_PME_EN);
 
 	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
-			     sizeof(uint32), w);
+			     sizeof(u32), w);
 }
 
-uint32 pcie_lcreg(void *pch, uint32 mask, uint32 val)
+u32 pcie_lcreg(void *pch, u32 mask, u32 val)
 {
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
 	u8 offset;
@@ -835,15 +835,15 @@ uint32 pcie_lcreg(void *pch, uint32 mask
 
 	/* set operation */
 	if (mask)
-		OSL_PCI_WRITE_CONFIG(pi->osh, offset, sizeof(uint32), val);
+		OSL_PCI_WRITE_CONFIG(pi->osh, offset, sizeof(u32), val);
 
-	return OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(uint32));
+	return OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(u32));
 }
 
-uint32
-pcicore_pciereg(void *pch, uint32 offset, uint32 mask, uint32 val, uint type)
+u32
+pcicore_pciereg(void *pch, u32 offset, u32 mask, u32 val, uint type)
 {
-	uint32 reg_val = 0;
+	u32 reg_val = 0;
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	osl_t *osh = pi->osh;
@@ -864,11 +864,11 @@ pcicore_pciereg(void *pch, uint32 offset
 	return reg_val;
 }
 
-uint32
-pcicore_pcieserdesreg(void *pch, uint32 mdioslave, uint32 offset, uint32 mask,
-		      uint32 val)
+u32
+pcicore_pcieserdesreg(void *pch, u32 mdioslave, u32 offset, u32 mask,
+		      u32 val)
 {
-	uint32 reg_val = 0;
+	u32 reg_val = 0;
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
 
 	if (mask) {
--- a/drivers/staging/brcm80211/util/qmath.c
+++ b/drivers/staging/brcm80211/util/qmath.c
@@ -83,7 +83,7 @@ Description: This function make 16 bit u
 */
 u16 qm_mulu16(u16 op1, u16 op2)
 {
-	return (u16) (((uint32) op1 * (uint32) op2) >> 16);
+	return (u16) (((u32) op1 * (u32) op2) >> 16);
 }
 
 /*
--- a/drivers/staging/brcm80211/util/sbutils.c
+++ b/drivers/staging/brcm80211/util/sbutils.c
@@ -28,10 +28,10 @@
 #include "siutils_priv.h"
 
 /* local prototypes */
-static uint _sb_coreidx(si_info_t *sii, uint32 sba);
-static uint _sb_scan(si_info_t *sii, uint32 sba, void *regs, uint bus,
-		     uint32 sbba, uint ncores);
-static uint32 _sb_coresba(si_info_t *sii);
+static uint _sb_coreidx(si_info_t *sii, u32 sba);
+static uint _sb_scan(si_info_t *sii, u32 sba, void *regs, uint bus,
+		     u32 sbba, uint ncores);
+static u32 _sb_coresba(si_info_t *sii);
 static void *_sb_setcoreidx(si_info_t *sii, uint coreidx);
 
 #define	SET_SBREG(sii, r, mask, val)	\
@@ -49,12 +49,12 @@ static void *_sb_setcoreidx(si_info_t *s
 #define	OR_SBREG(sii, sbr, v)	\
 	W_SBREG((sii), (sbr), (R_SBREG((sii), (sbr)) | (v)))
 
-static uint32 sb_read_sbreg(si_info_t *sii, volatile uint32 *sbr)
+static u32 sb_read_sbreg(si_info_t *sii, volatile u32 *sbr)
 {
 	return R_REG(sii->osh, sbr);
 }
 
-static void sb_write_sbreg(si_info_t *sii, volatile uint32 *sbr, uint32 v)
+static void sb_write_sbreg(si_info_t *sii, volatile u32 *sbr, u32 v)
 {
 	W_REG(sii->osh, sbr, v);
 }
@@ -72,7 +72,7 @@ uint sb_coreid(si_t *sih)
 }
 
 /* return core index of the core with address 'sba' */
-static uint BCMATTACHFN(_sb_coreidx) (si_info_t *sii, uint32 sba)
+static uint BCMATTACHFN(_sb_coreidx) (si_info_t *sii, u32 sba)
 {
 	uint i;
 
@@ -83,14 +83,14 @@ static uint BCMATTACHFN(_sb_coreidx) (si
 }
 
 /* return core address of the current core */
-static uint32 BCMATTACHFN(_sb_coresba) (si_info_t *sii)
+static u32 BCMATTACHFN(_sb_coresba) (si_info_t *sii)
 {
-	uint32 sbaddr = 0;
+	u32 sbaddr = 0;
 
 	switch (BUSTYPE(sii->pub.bustype)) {
 	case SPI_BUS:
 	case SDIO_BUS:
-		sbaddr = (uint32) (uintptr) sii->curmap;
+		sbaddr = (u32) (uintptr) sii->curmap;
 		break;
 	default:
 		ASSERT(0);
@@ -142,7 +142,7 @@ bool sb_iscoreup(si_t *sih)
 uint sb_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val)
 {
 	uint origidx = 0;
-	uint32 *r = NULL;
+	u32 *r = NULL;
 	uint w;
 	uint intr_val = 0;
 	bool fast = FALSE;
@@ -164,7 +164,7 @@ uint sb_corereg(si_t *sih, uint coreidx,
 		origidx = si_coreidx(&sii->pub);
 
 		/* switch core */
-		r = (uint32 *) ((unsigned char *) sb_setcoreidx(&sii->pub, coreidx) +
+		r = (u32 *) ((unsigned char *) sb_setcoreidx(&sii->pub, coreidx) +
 				regoff);
 	}
 	ASSERT(r != NULL);
@@ -206,8 +206,8 @@ uint sb_corereg(si_t *sih, uint coreidx,
  */
 #define SB_MAXBUSES	2
 static uint
-BCMATTACHFN(_sb_scan) (si_info_t *sii, uint32 sba, void *regs, uint bus,
-		       uint32 sbba, uint numcores) {
+BCMATTACHFN(_sb_scan) (si_info_t *sii, u32 sba, void *regs, uint bus,
+		       u32 sbba, uint numcores) {
 	uint next;
 	uint ncc = 0;
 	uint i;
@@ -237,7 +237,7 @@ BCMATTACHFN(_sb_scan) (si_info_t *sii, u
 		/* chipc provides # cores */
 		if (sii->coreid[next] == CC_CORE_ID) {
 			chipcregs_t *cc = (chipcregs_t *) sii->curmap;
-			uint32 ccrev = sb_corerev(&sii->pub);
+			u32 ccrev = sb_corerev(&sii->pub);
 
 			/* determine numcores - this is the
 				 total # cores in the chip */
@@ -259,7 +259,7 @@ BCMATTACHFN(_sb_scan) (si_info_t *sii, u
 		/* scan bridged SB(s) and add results to the end of the list */
 		else if (sii->coreid[next] == OCP_CORE_ID) {
 			sbconfig_t *sb = REGS2SB(sii->curmap);
-			uint32 nsbba = R_SBREG(sii, &sb->sbadmatch1);
+			u32 nsbba = R_SBREG(sii, &sb->sbadmatch1);
 			uint nsbcc;
 
 			sii->numcores = next + 1;
@@ -290,7 +290,7 @@ BCMATTACHFN(_sb_scan) (si_info_t *sii, u
 void BCMATTACHFN(sb_scan) (si_t *sih, void *regs, uint devid)
 {
 	si_info_t *sii;
-	uint32 origsba;
+	u32 origsba;
 	sbconfig_t *sb;
 
 	sii = SI_INFO(sih);
@@ -341,7 +341,7 @@ void *sb_setcoreidx(si_t *sih, uint core
  */
 static void *_sb_setcoreidx(si_info_t *sii, uint coreidx)
 {
-	uint32 sbaddr = sii->coresba[coreidx];
+	u32 sbaddr = sii->coresba[coreidx];
 	void *regs;
 
 	switch (BUSTYPE(sii->pub.bustype)) {
@@ -403,9 +403,9 @@ bool sb_taclear(si_t *sih, bool details)
 	uint origidx;
 	uint intr_val = 0;
 	bool rc = FALSE;
-	uint32 inband = 0, serror = 0, timeout = 0;
+	u32 inband = 0, serror = 0, timeout = 0;
 	void *corereg = NULL;
-	volatile uint32 imstate, tmstate;
+	volatile u32 imstate, tmstate;
 
 	sii = SI_INFO(sih);
 
@@ -453,10 +453,10 @@ bool sb_taclear(si_t *sih, bool details)
 	return rc;
 }
 
-void sb_core_disable(si_t *sih, uint32 bits)
+void sb_core_disable(si_t *sih, u32 bits)
 {
 	si_info_t *sii;
-	volatile uint32 dummy;
+	volatile u32 dummy;
 	sbconfig_t *sb;
 
 	sii = SI_INFO(sih);
@@ -512,11 +512,11 @@ disable:
  * bits - core specific bits that are set during and after reset sequence
  * resetbits - core specific bits that are set only during reset sequence
  */
-void sb_core_reset(si_t *sih, uint32 bits, uint32 resetbits)
+void sb_core_reset(si_t *sih, u32 bits, u32 resetbits)
 {
 	si_info_t *sii;
 	sbconfig_t *sb;
-	volatile uint32 dummy;
+	volatile u32 dummy;
 
 	sii = SI_INFO(sih);
 	ASSERT(GOODREGS(sii->curmap));
@@ -561,9 +561,9 @@ void sb_core_reset(si_t *sih, uint32 bit
 	OSL_DELAY(1);
 }
 
-uint32 sb_base(uint32 admatch)
+u32 sb_base(u32 admatch)
 {
-	uint32 base;
+	u32 base;
 	uint type;
 
 	type = admatch & SBAM_TYPE_MASK;
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -60,7 +60,7 @@ static si_info_t *si_doattach(si_info_t
 static bool si_buscore_prep(si_info_t *sii, uint bustype, uint devid,
 			    void *sdh);
 static bool si_buscore_setup(si_info_t *sii, chipcregs_t *cc, uint bustype,
-			     uint32 savewin, uint *origidx, void *regs);
+			     u32 savewin, uint *origidx, void *regs);
 static void si_nvram_process(si_info_t *sii, char *pvars);
 
 /* dev path concatenation util */
@@ -71,7 +71,7 @@ static uint BCMINITFN(socram_banksize) (
 					u8 idx, u8 mtype);
 
 /* global variable to indicate reservation/release of gpio's */
-static uint32 si_gpioreservation;
+static u32 si_gpioreservation;
 
 /*
  * Allocate a si handle.
@@ -167,7 +167,7 @@ BCMATTACHFN(si_buscore_prep) (si_info_t
 
 static bool
 BCMATTACHFN(si_buscore_setup) (si_info_t *sii, chipcregs_t *cc, uint bustype,
-			       uint32 savewin, uint *origidx, void *regs) {
+			       u32 savewin, uint *origidx, void *regs) {
 	bool pci, pcie;
 	uint i;
 	uint pciidx, pcieidx, pcirev, pcierev;
@@ -313,7 +313,7 @@ static __used void BCMATTACHFN(si_nvram_
 	switch (BUSTYPE(sii->pub.bustype)) {
 	case PCI_BUS:
 		/* do a pci config read to get subsystem id and subvendor id */
-		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_SVID, sizeof(uint32));
+		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_SVID, sizeof(u32));
 		/* Let nvram variables override subsystem Vend/ID */
 		sii->pub.boardvendor = (u16)si_getdevpathintvar(&sii->pub,
 			"boardvendor");
@@ -371,7 +371,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 					    uint bustype, void *sdh,
 					    char **vars, uint *varsz) {
 	struct si_pub *sih = &sii->pub;
-	uint32 w, savewin;
+	u32 w, savewin;
 	chipcregs_t *cc;
 	char *pvars = NULL;
 	uint origidx;
@@ -470,7 +470,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 #ifndef BRCM_FULLMAC
 	/* PMU specific initializations */
 	if (PMUCTL_ENAB(sih)) {
-		uint32 xtalfreq;
+		u32 xtalfreq;
 		si_pmu_init(sih, sii->osh);
 		si_pmu_chip_init(sih, sii->osh);
 		xtalfreq = getintvar(pvars, "xtalfreq");
@@ -506,7 +506,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 					    uint bustype, void *sdh,
 					    char **vars, uint *varsz) {
 	struct si_pub *sih = &sii->pub;
-	uint32 w, savewin;
+	u32 w, savewin;
 	chipcregs_t *cc;
 	char *pvars = NULL;
 	uint origidx;
@@ -525,7 +525,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 
 	/* check to see if we are a si core mimic'ing a pci core */
 	if ((bustype == PCI_BUS) &&
-	    (OSL_PCI_READ_CONFIG(sii->osh, PCI_SPROM_CONTROL, sizeof(uint32)) ==
+	    (OSL_PCI_READ_CONFIG(sii->osh, PCI_SPROM_CONTROL, sizeof(u32)) ==
 	     0xffffffff)) {
 		SI_ERROR(("%s: incoming bus is PCI but it's a lie, switching to SI " "devid:0x%x\n", __func__, devid));
 		bustype = SI_BUS;
@@ -534,7 +534,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 	/* find Chipcommon address */
 	if (bustype == PCI_BUS) {
 		savewin =
-		    OSL_PCI_READ_CONFIG(sii->osh, PCI_BAR0_WIN, sizeof(uint32));
+		    OSL_PCI_READ_CONFIG(sii->osh, PCI_BAR0_WIN, sizeof(u32));
 		if (!GOODCOREADDR(savewin, SI_ENUM_BASE))
 			savewin = SI_ENUM_BASE;
 		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN, 4, SI_ENUM_BASE);
@@ -630,7 +630,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 
 	/* PMU specific initializations */
 	if (PMUCTL_ENAB(sih)) {
-		uint32 xtalfreq;
+		u32 xtalfreq;
 		si_pmu_init(sih, sii->osh);
 		si_pmu_chip_init(sih, sii->osh);
 		xtalfreq = getintvar(pvars, "xtalfreq");
@@ -918,7 +918,7 @@ void si_restore_core(si_t *sih, uint cor
 	INTR_RESTORE(sii, intr_val);
 }
 
-uint32 si_core_cflags(si_t *sih, uint32 mask, uint32 val)
+u32 si_core_cflags(si_t *sih, u32 mask, u32 val)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_core_cflags(sih, mask, val);
@@ -928,7 +928,7 @@ uint32 si_core_cflags(si_t *sih, uint32
 	}
 }
 
-uint32 si_core_sflags(si_t *sih, uint32 mask, uint32 val)
+u32 si_core_sflags(si_t *sih, u32 mask, u32 val)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_core_sflags(sih, mask, val);
@@ -952,7 +952,7 @@ bool si_iscoreup(si_t *sih)
 	}
 }
 
-void si_write_wrapperreg(si_t *sih, uint32 offset, uint32 val)
+void si_write_wrapperreg(si_t *sih, u32 offset, u32 val)
 {
 	/* only for 4319, no requirement for SOCI_SB */
 	if (CHIPTYPE(sih->socitype) == SOCI_AI) {
@@ -975,7 +975,7 @@ uint si_corereg(si_t *sih, uint coreidx,
 	}
 }
 
-void si_core_disable(si_t *sih, uint32 bits)
+void si_core_disable(si_t *sih, u32 bits)
 {
 
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
@@ -986,7 +986,7 @@ void si_core_disable(si_t *sih, uint32 b
 #endif
 }
 
-void si_core_reset(si_t *sih, uint32 bits, uint32 resetbits)
+void si_core_reset(si_t *sih, u32 bits, u32 resetbits)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		ai_core_reset(sih, bits, resetbits);
@@ -996,7 +996,7 @@ void si_core_reset(si_t *sih, uint32 bit
 #endif
 }
 
-uint32 BCMINITFN(si_alp_clock) (si_t *sih)
+u32 BCMINITFN(si_alp_clock) (si_t *sih)
 {
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_alp_clock(sih, si_osh(sih));
@@ -1004,7 +1004,7 @@ uint32 BCMINITFN(si_alp_clock) (si_t *si
 	return ALP_CLOCK;
 }
 
-uint32 BCMINITFN(si_ilp_clock) (si_t *sih)
+u32 BCMINITFN(si_ilp_clock) (si_t *sih)
 {
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_ilp_clock(sih, si_osh(sih));
@@ -1092,7 +1092,7 @@ static uint si_slowclk_src(si_info_t *si
 
 	if (sii->pub.ccrev < 6) {
 		if ((BUSTYPE(sii->pub.bustype) == PCI_BUS) &&
-		    (OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(uint32))
+		    (OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(u32))
 		     & PCI_CFG_GPIO_SCS))
 			return SCC_SS_PCI;
 		else
@@ -1107,7 +1107,7 @@ static uint si_slowclk_src(si_info_t *si
 /* return the ILP (slowclock) min or max frequency */
 static uint si_slowclk_freq(si_info_t *sii, bool max_freq, chipcregs_t *cc)
 {
-	uint32 slowclk;
+	u32 slowclk;
 	uint div;
 
 	ASSERT(SI_FAST(sii) || si_coreid(&sii->pub) == CC_CORE_ID);
@@ -1262,7 +1262,7 @@ u16 BCMINITFN(si_clkctl_fast_pwrup_delay
 int si_clkctl_xtal(si_t *sih, uint what, bool on)
 {
 	si_info_t *sii;
-	uint32 in, out, outen;
+	u32 in, out, outen;
 
 	sii = SI_INFO(sih);
 
@@ -1278,12 +1278,12 @@ int si_clkctl_xtal(si_t *sih, uint what,
 		if (PCIE(sii))
 			return -1;
 
-		in = OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_IN, sizeof(uint32));
+		in = OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_IN, sizeof(u32));
 		out =
-		    OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(uint32));
+		    OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(u32));
 		outen =
 		    OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUTEN,
-					sizeof(uint32));
+					sizeof(u32));
 
 		/*
 		 * Avoid glitching the clock if GPRS is already using it.
@@ -1305,9 +1305,9 @@ int si_clkctl_xtal(si_t *sih, uint what,
 				if (what & PLL)
 					out |= PCI_CFG_GPIO_PLL;
 				OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUT,
-						     sizeof(uint32), out);
+						     sizeof(u32), out);
 				OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUTEN,
-						     sizeof(uint32), outen);
+						     sizeof(u32), outen);
 				OSL_DELAY(XTAL_ON_DELAY);
 			}
 
@@ -1315,7 +1315,7 @@ int si_clkctl_xtal(si_t *sih, uint what,
 			if (what & PLL) {
 				out &= ~PCI_CFG_GPIO_PLL;
 				OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUT,
-						     sizeof(uint32), out);
+						     sizeof(u32), out);
 				OSL_DELAY(2000);
 			}
 		} else {
@@ -1324,9 +1324,9 @@ int si_clkctl_xtal(si_t *sih, uint what,
 			if (what & PLL)
 				out |= PCI_CFG_GPIO_PLL;
 			OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUT,
-					     sizeof(uint32), out);
+					     sizeof(u32), out);
 			OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUTEN,
-					     sizeof(uint32), outen);
+					     sizeof(u32), outen);
 		}
 
 	default:
@@ -1365,7 +1365,7 @@ static bool _si_clkctl_cc(si_info_t *sii
 {
 	uint origidx = 0;
 	chipcregs_t *cc;
-	uint32 scc;
+	u32 scc;
 	uint intr_val = 0;
 	bool fast = SI_FAST(sii);
 
@@ -1411,7 +1411,7 @@ static bool _si_clkctl_cc(si_info_t *sii
 
 		/* wait for the PLL */
 		if (PMUCTL_ENAB(&sii->pub)) {
-			uint32 htavail = CCS_HTAVAIL;
+			u32 htavail = CCS_HTAVAIL;
 			SPINWAIT(((R_REG(sii->osh, &cc->clk_ctl_st) & htavail)
 				  == 0), PMU_MAX_TRANSITION_DLY);
 			ASSERT(R_REG(sii->osh, &cc->clk_ctl_st) & htavail);
@@ -1666,7 +1666,7 @@ void BCMATTACHFN(si_pci_setup) (si_t *si
 {
 	si_info_t *sii;
 	sbpciregs_t *pciregs = NULL;
-	uint32 siflag = 0, w;
+	u32 siflag = 0, w;
 	uint idx = 0;
 
 	sii = SI_INFO(sih);
@@ -1695,9 +1695,9 @@ void BCMATTACHFN(si_pci_setup) (si_t *si
 	 */
 	if (PCIE(sii) || (PCI(sii) && ((sii->pub.buscorerev) >= 6))) {
 		/* pci config write to set this core bit in PCIIntMask */
-		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_INT_MASK, sizeof(uint32));
+		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_INT_MASK, sizeof(u32));
 		w |= (coremask << PCI_SBIM_SHIFT);
-		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_INT_MASK, sizeof(uint32), w);
+		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_INT_MASK, sizeof(u32), w);
 	} else {
 		/* set sbintvec bit for our flag number */
 		si_setint(sih, siflag);
@@ -1770,7 +1770,7 @@ int si_pci_fixcfg(si_t *sih)
 }
 
 /* mask&set gpiocontrol bits */
-uint32 si_gpiocontrol(si_t *sih, uint32 mask, uint32 val, u8 priority)
+u32 si_gpiocontrol(si_t *sih, u32 mask, u32 val, u8 priority)
 {
 	uint regoff;
 
@@ -1808,7 +1808,7 @@ socram_banksize(si_info_t *sii, sbsocram
 }
 
 /* Return the RAM size of the SOCRAM core */
-uint32 si_socram_size(si_t *sih)
+u32 si_socram_size(si_t *sih)
 {
 	si_info_t *sii;
 	uint origidx;
@@ -1817,7 +1817,7 @@ uint32 si_socram_size(si_t *sih)
 	sbsocramregs_t *regs;
 	bool wasup;
 	uint corerev;
-	uint32 coreinfo;
+	u32 coreinfo;
 	uint memsize = 0;
 
 	sii = SI_INFO(sih);
@@ -1877,7 +1877,7 @@ void si_chipcontrl_epa4331(si_t *sih, bo
 	si_info_t *sii;
 	chipcregs_t *cc;
 	uint origidx;
-	uint32 val;
+	u32 val;
 
 	sii = SI_INFO(sih);
 	origidx = si_coreidx(sih);
@@ -1927,7 +1927,7 @@ void si_epa_4313war(si_t *sih)
 /* check if the device is removed */
 bool si_deviceremoved(si_t *sih)
 {
-	uint32 w;
+	u32 w;
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -1935,7 +1935,7 @@ bool si_deviceremoved(si_t *sih)
 	switch (BUSTYPE(sih->bustype)) {
 	case PCI_BUS:
 		ASSERT(sii->osh != NULL);
-		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_VID, sizeof(uint32));
+		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_VID, sizeof(u32));
 		if ((w & 0xFFFF) != VENDOR_BROADCOM)
 			return TRUE;
 		break;
@@ -1949,7 +1949,7 @@ bool si_is_sprom_available(si_t *sih)
 		si_info_t *sii;
 		uint origidx;
 		chipcregs_t *cc;
-		uint32 sromctrl;
+		u32 sromctrl;
 
 		if ((sih->cccaps & CC_CAP_SROM) == 0)
 			return FALSE;
--- a/drivers/staging/brcm80211/util/siutils_priv.h
+++ b/drivers/staging/brcm80211/util/siutils_priv.h
@@ -25,8 +25,8 @@ extern uint sb_corereg(si_t *sih, uint c
 		       uint val);
 extern bool sb_iscoreup(si_t *sih);
 void *sb_setcoreidx(si_t *sih, uint coreidx);
-extern uint32 sb_base(uint32 admatch);
-extern void sb_core_reset(si_t *sih, uint32 bits, uint32 resetbits);
-extern void sb_core_disable(si_t *sih, uint32 bits);
+extern u32 sb_base(u32 admatch);
+extern void sb_core_reset(si_t *sih, u32 bits, u32 resetbits);
+extern void sb_core_disable(si_t *sih, u32 bits);
 extern bool sb_taclear(si_t *sih, bool details);
 #endif				/* _siutils_priv_h_ */

commit 0f0881b09078fe3a6bc70f05e8ba49a52b2478a2
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 12 12:15:18 2010 -0700

    Staging: brcm80211: remove TRUE #define
    
    use the kernel provided 'true' value instead, especially
    as we are using a 'bool' for these variables.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh.c
@@ -76,7 +76,7 @@ bcmsdh_info_t *bcmsdh_attach(osl_t *osh,
 	}
 
 	bcmsdh->osh = osh;
-	bcmsdh->init_success = TRUE;
+	bcmsdh->init_success = true;
 
 	*regsva = (u32 *) SI_ENUM_BASE;
 
@@ -129,7 +129,7 @@ int bcmsdh_intr_enable(void *sdh)
 	SDIOH_API_RC status;
 	ASSERT(bcmsdh);
 
-	status = sdioh_interrupt_set(bcmsdh->sdioh, TRUE);
+	status = sdioh_interrupt_set(bcmsdh->sdioh, true);
 	return SDIOH_API_SUCCESS(status) ? 0 : BCME_ERROR;
 }
 
@@ -395,7 +395,7 @@ u32 bcmsdh_reg_read(void *sdh, u32 addr,
 		case sizeof(u32):
 			return word;
 		default:
-			bcmsdh->regfail = TRUE;
+			bcmsdh->regfail = true;
 
 		}
 	}
--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
@@ -88,36 +88,36 @@ bool bcmsdh_chipmatch(u16 vendor, u16 de
 #ifdef BCMSDIOH_STD
 	/* Check for Arasan host controller */
 	if (vendor == VENDOR_SI_IMAGE)
-		return TRUE;
+		return true;
 
 	/* Check for BRCM 27XX Standard host controller */
 	if (device == BCM27XX_SDIOH_ID && vendor == VENDOR_BROADCOM)
-		return TRUE;
+		return true;
 
 	/* Check for BRCM Standard host controller */
 	if (device == SDIOH_FPGA_ID && vendor == VENDOR_BROADCOM)
-		return TRUE;
+		return true;
 
 	/* Check for TI PCIxx21 Standard host controller */
 	if (device == PCIXX21_SDIOH_ID && vendor == VENDOR_TI)
-		return TRUE;
+		return true;
 
 	if (device == PCIXX21_SDIOH0_ID && vendor == VENDOR_TI)
-		return TRUE;
+		return true;
 
 	/* Ricoh R5C822 Standard SDIO Host */
 	if (device == R5C822_SDIOH_ID && vendor == VENDOR_RICOH)
-		return TRUE;
+		return true;
 
 	/* JMicron Standard SDIO Host */
 	if (device == JMICRON_SDIOH_ID && vendor == VENDOR_JMICRON)
-		return TRUE;
+		return true;
 #endif				/* BCMSDIOH_STD */
 #ifdef BCMSDIOH_SPI
 	/* This is the PciSpiHost. */
 	if (device == SPIH_FPGA_ID && vendor == VENDOR_BROADCOM) {
 		printf("Found PCI SPI Host Controller\n");
-		return TRUE;
+		return true;
 	}
 #endif				/* BCMSDIOH_SPI */
 
@@ -621,7 +621,7 @@ int bcmsdh_register_oob_intr(void *dhdp)
 			return -ENODEV;
 
 		set_irq_wake(sdhcinfo->oob_irq, 1);
-		sdhcinfo->oob_irq_registered = TRUE;
+		sdhcinfo->oob_irq_registered = true;
 	}
 
 	return 0;
--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc.c
@@ -58,7 +58,7 @@ uint sd_power = 1;		/* Default to SD Slo
 uint sd_clock = 1;		/* Default to SD Clock turned ON */
 uint sd_hiok = FALSE;		/* Don't use hi-speed mode by default */
 uint sd_msglevel = 0x01;
-uint sd_use_dma = TRUE;
+uint sd_use_dma = true;
 DHD_PM_RESUME_WAIT_INIT(sdioh_request_byte_wait);
 DHD_PM_RESUME_WAIT_INIT(sdioh_request_word_wait);
 DHD_PM_RESUME_WAIT_INIT(sdioh_request_packet_wait);
@@ -138,8 +138,8 @@ extern sdioh_info_t *sdioh_attach(osl_t
 	}
 
 	sd->num_funcs = 2;
-	sd->sd_blockmode = TRUE;
-	sd->use_client_ints = TRUE;
+	sd->sd_blockmode = true;
+	sd->use_client_ints = true;
 	sd->client_block_size[0] = 64;
 
 	gInstance->sd = sd;
@@ -281,7 +281,7 @@ sdioh_interrupt_register(sdioh_info_t *s
 #if !defined(OOB_INTR_ONLY)
 	sd->intr_handler = fn;
 	sd->intr_handler_arg = argh;
-	sd->intr_handler_valid = TRUE;
+	sd->intr_handler_valid = true;
 
 	/* register and unmask irq */
 	if (gInstance->func[2]) {
@@ -444,7 +444,7 @@ sdioh_iovar_op(sdioh_info_t *si, const c
 	if (plen >= (int)sizeof(int_val))
 		bcopy(params, &int_val, sizeof(int_val));
 
-	bool_val = (int_val != 0) ? TRUE : FALSE;
+	bool_val = (int_val != 0) ? true : FALSE;
 
 	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
 	switch (actionid) {
@@ -1041,9 +1041,9 @@ sdioh_request_buffer(sdioh_info_t *sd, u
 		sd_data(("%s: Creating new %s Packet, len=%d\n",
 			 __func__, write ? "TX" : "RX", buflen_u));
 #ifdef DHD_USE_STATIC_BUF
-		mypkt = PKTGET_STATIC(sd->osh, buflen_u, write ? TRUE : FALSE);
+		mypkt = PKTGET_STATIC(sd->osh, buflen_u, write ? true : FALSE);
 #else
-		mypkt = PKTGET(sd->osh, buflen_u, write ? TRUE : FALSE);
+		mypkt = PKTGET(sd->osh, buflen_u, write ? true : FALSE);
 #endif				/* DHD_USE_STATIC_BUF */
 		if (!mypkt) {
 			sd_err(("%s: PKTGET failed: len %d\n",
@@ -1063,9 +1063,9 @@ sdioh_request_buffer(sdioh_info_t *sd, u
 			bcopy(PKTDATA(mypkt), buffer, buflen_u);
 
 #ifdef DHD_USE_STATIC_BUF
-		PKTFREE_STATIC(sd->osh, mypkt, write ? TRUE : FALSE);
+		PKTFREE_STATIC(sd->osh, mypkt, write ? true : FALSE);
 #else
-		PKTFREE(sd->osh, mypkt, write ? TRUE : FALSE);
+		PKTFREE(sd->osh, mypkt, write ? true : FALSE);
 #endif				/* DHD_USE_STATIC_BUF */
 	} else if (((u32) (PKTDATA(pkt)) & DMA_ALIGN_MASK) != 0) {
 		/* Case 2: We have a packet, but it is unaligned. */
@@ -1077,9 +1077,9 @@ sdioh_request_buffer(sdioh_info_t *sd, u
 			 __func__, write ? "TX" : "RX", PKTLEN(pkt)));
 #ifdef DHD_USE_STATIC_BUF
 		mypkt = PKTGET_STATIC(sd->osh, PKTLEN(pkt),
-					write ? TRUE : FALSE);
+					write ? true : FALSE);
 #else
-		mypkt = PKTGET(sd->osh, PKTLEN(pkt), write ? TRUE : FALSE);
+		mypkt = PKTGET(sd->osh, PKTLEN(pkt), write ? true : FALSE);
 #endif				/* DHD_USE_STATIC_BUF */
 		if (!mypkt) {
 			sd_err(("%s: PKTGET failed: len %d\n",
@@ -1099,9 +1099,9 @@ sdioh_request_buffer(sdioh_info_t *sd, u
 			bcopy(PKTDATA(mypkt), PKTDATA(pkt), PKTLEN(mypkt));
 
 #ifdef DHD_USE_STATIC_BUF
-		PKTFREE_STATIC(sd->osh, mypkt, write ? TRUE : FALSE);
+		PKTFREE_STATIC(sd->osh, mypkt, write ? true : FALSE);
 #else
-		PKTFREE(sd->osh, mypkt, write ? TRUE : FALSE);
+		PKTFREE(sd->osh, mypkt, write ? true : FALSE);
 #endif				/* DHD_USE_STATIC_BUF */
 	} else {		/* case 3: We have a packet and
 				 it is aligned. */
--- a/drivers/staging/brcm80211/brcmfmac/dhd.h
+++ b/drivers/staging/brcm80211/brcmfmac/dhd.h
@@ -87,7 +87,7 @@ typedef struct dhd_pub {
 	/* Internal dhd items */
 	bool up;		/* Driver up/down (to OS) */
 	bool txoff;		/* Transmit flow-controlled */
-	bool dongle_reset;	/* TRUE = DEVRESET put dongle into reset */
+	bool dongle_reset;	/* true = DEVRESET put dongle into reset */
 	enum dhd_bus_state busstate;
 	uint hdrlen;		/* Total DHD header length (proto + bus) */
 	uint maxctl;		/* Max size rxctl request from proto to bus */
--- a/drivers/staging/brcm80211/brcmfmac/dhd_bus.h
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_bus.h
@@ -52,7 +52,7 @@ extern bool dhd_bus_watchdog(dhd_pub_t *
 extern int dhd_bus_console_in(dhd_pub_t *dhd, unsigned char *msg, uint msglen);
 #endif				/* DHD_DEBUG */
 
-/* Deferred processing for the bus, return TRUE requests reschedule */
+/* Deferred processing for the bus, return true requests reschedule */
 extern bool dhd_bus_dpc(struct dhd_bus *bus);
 extern void dhd_bus_isr(bool *InterruptRecognized,
 			bool *QueueMiniportHandleInterrupt, void *arg);
--- a/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
@@ -248,7 +248,7 @@ dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx
 	if (len > WLC_IOCTL_MAXLEN)
 		goto done;
 
-	if (prot->pending == TRUE) {
+	if (prot->pending == true) {
 		DHD_TRACE(("CDC packet is pending!!!! cmd=0x%x (%lu) "
 			"lastcmd=0x%x (%lu)\n",
 			ioc->cmd, (unsigned long)ioc->cmd, prot->lastcmd,
@@ -259,7 +259,7 @@ dhd_prot_ioctl(dhd_pub_t *dhd, int ifidx
 		goto done;
 	}
 
-	prot->pending = TRUE;
+	prot->pending = true;
 	prot->lastcmd = ioc->cmd;
 	if (ioc->set)
 		ret = dhdcdc_set_ioctl(dhd, ifidx, ioc->cmd, buf, len);
@@ -349,7 +349,7 @@ bool dhd_proto_fcinfo(dhd_pub_t *dhd, vo
 
 	*fcbits = h->priority >> BDC_PRIORITY_FC_SHIFT;
 	if ((h->flags2 & BDC_FLAG2_FC_FLAG) == BDC_FLAG2_FC_FLAG)
-		return TRUE;
+		return true;
 #endif
 	return FALSE;
 }
@@ -391,7 +391,7 @@ int dhd_prot_hdrpull(dhd_pub_t *dhd, int
 		DHD_INFO(("%s: BDC packet received with good rx-csum, "
 			"flags 0x%x\n",
 			dhd_ifname(dhd, *ifidx), h->flags));
-		PKTSETSUMGOOD(pktbuf, TRUE);
+		PKTSETSUMGOOD(pktbuf, true);
 	}
 
 	PKTSETPRIO(pktbuf, (h->priority & BDC_PRIORITY_MASK));
@@ -489,7 +489,7 @@ int dhd_prot_init(dhd_pub_t *dhd)
 #endif				/* EMBEDDED_PLATFORM */
 
 	/* Always assumes wl for now */
-	dhd->iswl = TRUE;
+	dhd->iswl = true;
 
 	return ret;
 }
--- a/drivers/staging/brcm80211/brcmfmac/dhd_common.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_common.c
@@ -337,7 +337,7 @@ bool dhd_prec_enq(dhd_pub_t *dhdp, struc
 	 */
 	if (!pktq_pfull(q, prec) && !pktq_full(q)) {
 		pktq_penq(q, prec, pkt);
-		return TRUE;
+		return true;
 	}
 
 	/* Determine precedence from which to evict packet, if any */
@@ -366,7 +366,7 @@ bool dhd_prec_enq(dhd_pub_t *dhdp, struc
 			ASSERT(p);
 		}
 
-		PKTFREE(dhdp->osh, p, TRUE);
+		PKTFREE(dhdp->osh, p, true);
 	}
 
 	/* Enqueue */
@@ -376,7 +376,7 @@ bool dhd_prec_enq(dhd_pub_t *dhdp, struc
 		ASSERT(p);
 	}
 
-	return TRUE;
+	return true;
 }
 
 static int
@@ -608,11 +608,11 @@ static void wl_show_host_event(wl_event_
 	DHD_EVENT(("EVENT: %s, event ID = %d\n", event_name, event_type));
 
 	if (flags & WLC_EVENT_MSG_LINK)
-		link = TRUE;
+		link = true;
 	if (flags & WLC_EVENT_MSG_GROUP)
-		group = TRUE;
+		group = true;
 	if (flags & WLC_EVENT_MSG_FLUSHTXQ)
-		flush_txq = TRUE;
+		flush_txq = true;
 
 	switch (event_type) {
 	case WLC_E_START:
--- a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
@@ -273,7 +273,7 @@ module_param_string(nvram_path, nvram_pa
 module_param(dhd_msg_level, int, 0);
 
 /* Spawn a thread for system ioctls (set mac, set mcast) */
-uint dhd_sysioc = TRUE;
+uint dhd_sysioc = true;
 module_param(dhd_sysioc, uint, 0);
 
 /* Watchdog interval */
@@ -292,11 +292,11 @@ uint dhd_arp_mode = 0xb;
 module_param(dhd_arp_mode, uint, 0);
 
 /* ARP offload enable */
-uint dhd_arp_enable = TRUE;
+uint dhd_arp_enable = true;
 module_param(dhd_arp_enable, uint, 0);
 
 /* Global Pkt filter enable control */
-uint dhd_pkt_filter_enable = TRUE;
+uint dhd_pkt_filter_enable = true;
 module_param(dhd_pkt_filter_enable, uint, 0);
 
 /*  Pkt filter init setup */
@@ -304,7 +304,7 @@ uint dhd_pkt_filter_init;
 module_param(dhd_pkt_filter_init, uint, 0);
 
 /* Pkt filter mode control */
-uint dhd_master_mode = TRUE;
+uint dhd_master_mode = true;
 module_param(dhd_master_mode, uint, 1);
 
 /* Watchdog thread priority, -1 to use kernel timer */
@@ -347,11 +347,11 @@ uint dhd_poll = FALSE;
 module_param(dhd_poll, uint, 0);
 
 /* Use cfg80211 */
-uint dhd_cfg80211 = TRUE;
+uint dhd_cfg80211 = true;
 module_param(dhd_cfg80211, uint, 0);
 
 /* Use interrupts */
-uint dhd_intr = TRUE;
+uint dhd_intr = true;
 module_param(dhd_intr, uint, 0);
 
 /* SDIO Drive Strength (in milliamps) */
@@ -422,7 +422,7 @@ static int dhd_sleep_pm_callback(struct
 	switch (action) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
-		dhd_mmc_suspend = TRUE;
+		dhd_mmc_suspend = true;
 		return NOTIFY_OK;
 	case PM_POST_HIBERNATION:
 	case PM_POST_SUSPEND:
@@ -707,7 +707,7 @@ static void _dhd_set_multicast_list(dhd_
 	cnt = netdev_mc_count(dev);
 
 	/* Determine initial value of allmulti flag */
-	allmulti = (dev->flags & IFF_ALLMULTI) ? TRUE : FALSE;
+	allmulti = (dev->flags & IFF_ALLMULTI) ? true : FALSE;
 
 	/* Send down the multicast list first. */
 
@@ -738,13 +738,13 @@ static void _dhd_set_multicast_list(dhd_
 	ioc.cmd = WLC_SET_VAR;
 	ioc.buf = buf;
 	ioc.len = buflen;
-	ioc.set = TRUE;
+	ioc.set = true;
 
 	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
 	if (ret < 0) {
 		DHD_ERROR(("%s: set mcast_list failed, cnt %d\n",
 			   dhd_ifname(&dhd->pub, ifidx), cnt));
-		allmulti = cnt ? TRUE : allmulti;
+		allmulti = cnt ? true : allmulti;
 	}
 
 	MFREE(dhd->pub.osh, buf, buflen);
@@ -776,7 +776,7 @@ static void _dhd_set_multicast_list(dhd_
 	ioc.cmd = WLC_SET_VAR;
 	ioc.buf = buf;
 	ioc.len = buflen;
-	ioc.set = TRUE;
+	ioc.set = true;
 
 	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
 	if (ret < 0) {
@@ -789,14 +789,14 @@ static void _dhd_set_multicast_list(dhd_
 	/* Finally, pick up the PROMISC flag as well, like the NIC
 		 driver does */
 
-	allmulti = (dev->flags & IFF_PROMISC) ? TRUE : FALSE;
+	allmulti = (dev->flags & IFF_PROMISC) ? true : FALSE;
 	allmulti = htol32(allmulti);
 
 	memset(&ioc, 0, sizeof(ioc));
 	ioc.cmd = WLC_SET_PROMISC;
 	ioc.buf = &allmulti;
 	ioc.len = sizeof(allmulti);
-	ioc.set = TRUE;
+	ioc.set = true;
 
 	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
 	if (ret < 0) {
@@ -823,7 +823,7 @@ _dhd_set_mac_address(dhd_info_t *dhd, in
 	ioc.cmd = WLC_SET_VAR;
 	ioc.buf = buf;
 	ioc.len = 32;
-	ioc.set = TRUE;
+	ioc.set = true;
 
 	ret = dhd_prot_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);
 	if (ret < 0) {
@@ -999,7 +999,7 @@ static int dhd_set_mac_address(struct ne
 
 	ASSERT(dhd->sysioc_tsk);
 	memcpy(&dhd->macvalue, sa->sa_data, ETHER_ADDR_LEN);
-	dhd->set_macaddress = TRUE;
+	dhd->set_macaddress = true;
 	up(&dhd->sysioc_sem);
 
 	return ret;
@@ -1015,7 +1015,7 @@ static void dhd_set_multicast_list(struc
 		return;
 
 	ASSERT(dhd->sysioc_tsk);
-	dhd->set_multicast = TRUE;
+	dhd->set_multicast = true;
 	up(&dhd->sysioc_sem);
 }
 
@@ -1376,7 +1376,7 @@ static int dhd_dpc_thread(void *data)
 				}
 				WAKE_UNLOCK(&dhd->pub, WAKE_LOCK_DPC);
 			} else {
-				dhd_bus_stop(dhd->pub.bus, TRUE);
+				dhd_bus_stop(dhd->pub.bus, true);
 			}
 		} else
 			break;
@@ -1397,7 +1397,7 @@ static void dhd_dpc(unsigned long data)
 		if (dhd_bus_dpc(dhd->pub.bus))
 			tasklet_schedule(&dhd->tasklet);
 	} else {
-		dhd_bus_stop(dhd->pub.bus, TRUE);
+		dhd_bus_stop(dhd->pub.bus, true);
 	}
 }
 
@@ -1461,7 +1461,7 @@ static int dhd_toe_set(dhd_info_t *dhd,
 	ioc.cmd = WLC_SET_VAR;
 	ioc.buf = buf;
 	ioc.len = (uint) sizeof(buf);
-	ioc.set = TRUE;
+	ioc.set = true;
 
 	/* Set toe_ol as requested */
 
@@ -1818,7 +1818,7 @@ static int dhd_open(struct net_device *n
 
 osl_t *dhd_osl_attach(void *pdev, uint bustype)
 {
-	return osl_attach(pdev, bustype, TRUE);
+	return osl_attach(pdev, bustype, true);
 }
 
 void dhd_osl_detach(osl_t *osh)
@@ -1985,7 +1985,7 @@ dhd_pub_t *dhd_attach(osl_t *osh, struct
 	/* Initialize thread based operation and lock */
 	init_MUTEX(&dhd->sdsem);
 	if ((dhd_watchdog_prio >= 0) && (dhd_dpc_prio >= 0))
-		dhd->threads_only = TRUE;
+		dhd->threads_only = true;
 	else
 		dhd->threads_only = FALSE;
 
@@ -2102,7 +2102,7 @@ int dhd_bus_start(dhd_pub_t *dhdp)
 	dhd_os_wd_timer(&dhd->pub, dhd_watchdog_ms);
 
 	/* Bring up the bus */
-	ret = dhd_bus_init(&dhd->pub, TRUE);
+	ret = dhd_bus_init(&dhd->pub, true);
 	if (ret != 0) {
 		DHD_ERROR(("%s, dhd_bus_init failed %d\n", __func__, ret));
 		return ret;
@@ -2117,7 +2117,7 @@ int dhd_bus_start(dhd_pub_t *dhdp)
 	}
 
 	/* Enable oob at firmware */
-	dhd_enable_oob_intr(dhd->pub.bus, TRUE);
+	dhd_enable_oob_intr(dhd->pub.bus, true);
 #endif				/* defined(OOB_INTR_ONLY) */
 
 	/* If bus is not ready, can't come up */
@@ -2295,7 +2295,7 @@ void dhd_bus_detach(dhd_pub_t *dhdp)
 			dhd_prot_stop(&dhd->pub);
 
 			/* Stop the bus module */
-			dhd_bus_stop(dhd->pub.bus, TRUE);
+			dhd_bus_stop(dhd->pub.bus, true);
 #if defined(OOB_INTR_ONLY)
 			bcmsdh_unregister_oob_intr();
 #endif				/* defined(OOB_INTR_ONLY) */
@@ -2504,7 +2504,7 @@ int dhd_os_ioctl_resp_wait(dhd_pub_t *pu
 		timeout = schedule_timeout(timeout);
 
 	if (signal_pending(current))
-		*pending = TRUE;
+		*pending = true;
 
 	set_current_state(TASK_RUNNING);
 	remove_wait_queue(&dhd->ioctl_resp_wait, &wait);
@@ -2533,7 +2533,7 @@ void dhd_os_wd_timer(void *bus, uint wdt
 		return;
 
 	/* Totally stop the timer */
-	if (!wdtick && dhd->wd_timer_valid == TRUE) {
+	if (!wdtick && dhd->wd_timer_valid == true) {
 		del_timer_sync(&dhd->timer);
 		dhd->wd_timer_valid = FALSE;
 		save_dhd_watchdog_ms = wdtick;
@@ -2545,7 +2545,7 @@ void dhd_os_wd_timer(void *bus, uint wdt
 
 		if (save_dhd_watchdog_ms != dhd_watchdog_ms) {
 
-			if (dhd->wd_timer_valid == TRUE)
+			if (dhd->wd_timer_valid == true)
 				/* Stop timer and restart at new value */
 				del_timer_sync(&dhd->timer);
 
@@ -2562,7 +2562,7 @@ void dhd_os_wd_timer(void *bus, uint wdt
 				  jiffies + dhd_watchdog_ms * HZ / 1000);
 		}
 
-		dhd->wd_timer_valid = TRUE;
+		dhd->wd_timer_valid = true;
 		save_dhd_watchdog_ms = wdtick;
 	}
 }
--- a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
@@ -588,7 +588,7 @@ static int dhdsdio_htclk(dhd_bus_t *bus,
 		DHD_INFO(("CLKCTL: turned ON\n"));
 
 #if defined(DHD_DEBUG)
-		if (bus->alp_only == TRUE) {
+		if (bus->alp_only == true) {
 #if !defined(BCMLXSDMMC)
 			if (!SBSDIO_ALPONLY(clkctl)) {
 				DHD_ERROR(("%s: HT Clock, when ALP Only\n",
@@ -603,7 +603,7 @@ static int dhdsdio_htclk(dhd_bus_t *bus,
 		}
 #endif				/* defined (DHD_DEBUG) */
 
-		bus->activity = TRUE;
+		bus->activity = true;
 	} else {
 		clkreq = 0;
 
@@ -643,7 +643,7 @@ static int dhdsdio_sdclk(dhd_bus_t *bus,
 			/* Turn on clock and restore mode */
 			iovalue = 1;
 			err = bcmsdh_iovar_op(bus->sdh, "sd_clock", NULL, 0,
-					      &iovalue, sizeof(iovalue), TRUE);
+					      &iovalue, sizeof(iovalue), true);
 			if (err) {
 				DHD_ERROR(("%s: error enabling sd_clock: %d\n",
 					   __func__, err));
@@ -652,7 +652,7 @@ static int dhdsdio_sdclk(dhd_bus_t *bus,
 
 			iovalue = bus->sd_mode;
 			err = bcmsdh_iovar_op(bus->sdh, "sd_mode", NULL, 0,
-					      &iovalue, sizeof(iovalue), TRUE);
+					      &iovalue, sizeof(iovalue), true);
 			if (err) {
 				DHD_ERROR(("%s: error changing sd_mode: %d\n",
 					   __func__, err));
@@ -662,7 +662,7 @@ static int dhdsdio_sdclk(dhd_bus_t *bus,
 			/* Restore clock speed */
 			iovalue = bus->sd_divisor;
 			err = bcmsdh_iovar_op(bus->sdh, "sd_divisor", NULL, 0,
-					      &iovalue, sizeof(iovalue), TRUE);
+					      &iovalue, sizeof(iovalue), true);
 			if (err) {
 				DHD_ERROR(("%s: error restoring sd_divisor: %d\n",
 					__func__, err));
@@ -684,7 +684,7 @@ static int dhdsdio_sdclk(dhd_bus_t *bus,
 				err =
 				    bcmsdh_iovar_op(bus->sdh, "sd_mode", NULL,
 						    0, &iovalue,
-						    sizeof(iovalue), TRUE);
+						    sizeof(iovalue), true);
 				if (err) {
 					DHD_ERROR(("%s: error changing sd_clock: %d\n",
 						__func__, err));
@@ -694,7 +694,7 @@ static int dhdsdio_sdclk(dhd_bus_t *bus,
 
 			iovalue = 0;
 			err = bcmsdh_iovar_op(bus->sdh, "sd_clock", NULL, 0,
-					      &iovalue, sizeof(iovalue), TRUE);
+					      &iovalue, sizeof(iovalue), true);
 			if (err) {
 				DHD_ERROR(("%s: error disabling sd_clock: %d\n",
 					   __func__, err));
@@ -704,7 +704,7 @@ static int dhdsdio_sdclk(dhd_bus_t *bus,
 			/* Set divisor to idle value */
 			iovalue = bus->idleclock;
 			err = bcmsdh_iovar_op(bus->sdh, "sd_divisor", NULL, 0,
-					      &iovalue, sizeof(iovalue), TRUE);
+					      &iovalue, sizeof(iovalue), true);
 			if (err) {
 				DHD_ERROR(("%s: error changing sd_divisor: %d\n",
 					__func__, err));
@@ -730,7 +730,7 @@ static int dhdsdio_clkctl(dhd_bus_t *bus
 	if (bus->clkstate == target) {
 		if (target == CLK_AVAIL) {
 			dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
-			bus->activity = TRUE;
+			bus->activity = true;
 		}
 		return BCME_OK;
 	}
@@ -739,17 +739,17 @@ static int dhdsdio_clkctl(dhd_bus_t *bus
 	case CLK_AVAIL:
 		/* Make sure SD clock is available */
 		if (bus->clkstate == CLK_NONE)
-			dhdsdio_sdclk(bus, TRUE);
+			dhdsdio_sdclk(bus, true);
 		/* Now request HT Avail on the backplane */
-		dhdsdio_htclk(bus, TRUE, pendok);
+		dhdsdio_htclk(bus, true, pendok);
 		dhd_os_wd_timer(bus->dhd, dhd_watchdog_ms);
-		bus->activity = TRUE;
+		bus->activity = true;
 		break;
 
 	case CLK_SDONLY:
 		/* Remove HT request, or bring up SD clock */
 		if (bus->clkstate == CLK_NONE)
-			dhdsdio_sdclk(bus, TRUE);
+			dhdsdio_sdclk(bus, true);
 		else if (bus->clkstate == CLK_AVAIL)
 			dhdsdio_htclk(bus, FALSE, FALSE);
 		else
@@ -819,7 +819,7 @@ int dhdsdio_bussleep(dhd_bus_t *bus, boo
 		}
 
 		/* Change state */
-		bus->sleeping = TRUE;
+		bus->sleeping = true;
 
 	} else {
 		/* Waking up: bus power up is ok, set local state */
@@ -871,7 +871,7 @@ void dhd_enable_oob_intr(struct dhd_bus
 	uint retries = 0;
 
 	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
-	if (enable == TRUE) {
+	if (enable == true) {
 
 		/* Tell device to start using OOB wakeup */
 		W_SDREG(SMB_USE_OOB, &regs->tosbmailbox, retries);
@@ -930,7 +930,7 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 			DHD_INFO(("%s: insufficient headroom %d for %d pad\n",
 				  __func__, (int)PKTHEADROOM(pkt), pad));
 			bus->dhd->tx_realloc++;
-			new = PKTGET(osh, (PKTLEN(pkt) + DHD_SDALIGN), TRUE);
+			new = PKTGET(osh, (PKTLEN(pkt) + DHD_SDALIGN), true);
 			if (!new) {
 				DHD_ERROR(("%s: couldn't allocate new %d-byte "
 					"packet\n",
@@ -942,9 +942,9 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 			PKTALIGN(osh, new, PKTLEN(pkt), DHD_SDALIGN);
 			bcopy(PKTDATA(pkt), PKTDATA(new), PKTLEN(pkt));
 			if (free_pkt)
-				PKTFREE(osh, pkt, TRUE);
+				PKTFREE(osh, pkt, true);
 			/* free the pkt if canned one is not used */
-			free_pkt = TRUE;
+			free_pkt = true;
 			pkt = new;
 			frame = (u8 *) PKTDATA(pkt);
 			ASSERT(((uintptr) frame % DHD_SDALIGN) == 0);
@@ -1055,7 +1055,7 @@ done:
 	dhd_os_sdlock(bus->dhd);
 
 	if (free_pkt)
-		PKTFREE(osh, pkt, TRUE);
+		PKTFREE(osh, pkt, true);
 
 	return ret;
 }
@@ -1106,7 +1106,7 @@ int dhd_bus_txdata(struct dhd_bus *bus,
 		if (dhd_prec_enq(bus->dhd, &bus->txq, pkt, prec) == FALSE) {
 			PKTPULL(pkt, SDPCM_HDRLEN);
 			dhd_txcomplete(bus->dhd, pkt, FALSE);
-			PKTFREE(osh, pkt, TRUE);
+			PKTFREE(osh, pkt, true);
 			DHD_ERROR(("%s: out of bus->txq !!!\n", __func__));
 			ret = BCME_NORESOURCE;
 		} else {
@@ -1123,7 +1123,7 @@ int dhd_bus_txdata(struct dhd_bus *bus,
 #endif
 		/* Schedule DPC if needed to send queued packet(s) */
 		if (dhd_deferred_tx && !bus->dpc_sched) {
-			bus->dpc_sched = TRUE;
+			bus->dpc_sched = true;
 			dhd_sched_dpc(bus->dhd);
 		}
 	} else {
@@ -1133,15 +1133,15 @@ int dhd_bus_txdata(struct dhd_bus *bus,
 		/* Otherwise, send it now */
 		BUS_WAKE(bus);
 		/* Make sure back plane ht clk is on, no pending allowed */
-		dhdsdio_clkctl(bus, CLK_AVAIL, TRUE);
+		dhdsdio_clkctl(bus, CLK_AVAIL, true);
 
 #ifndef SDTEST
 		DHD_TRACE(("%s: calling txpkt\n", __func__));
-		ret = dhdsdio_txpkt(bus, pkt, SDPCM_DATA_CHANNEL, TRUE);
+		ret = dhdsdio_txpkt(bus, pkt, SDPCM_DATA_CHANNEL, true);
 #else
 		ret = dhdsdio_txpkt(bus, pkt,
 				    (bus->ext_loop ? SDPCM_TEST_CHANNEL :
-				     SDPCM_DATA_CHANNEL), TRUE);
+				     SDPCM_DATA_CHANNEL), true);
 #endif
 		if (ret)
 			bus->dhd->tx_errors++;
@@ -1150,7 +1150,7 @@ int dhd_bus_txdata(struct dhd_bus *bus,
 
 		if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
 			bus->activity = FALSE;
-			dhdsdio_clkctl(bus, CLK_NONE, TRUE);
+			dhdsdio_clkctl(bus, CLK_NONE, true);
 		}
 
 		dhd_os_sdunlock(bus->dhd);
@@ -1188,11 +1188,11 @@ static uint dhdsdio_sendfromq(dhd_bus_t
 		datalen = PKTLEN(pkt) - SDPCM_HDRLEN;
 
 #ifndef SDTEST
-		ret = dhdsdio_txpkt(bus, pkt, SDPCM_DATA_CHANNEL, TRUE);
+		ret = dhdsdio_txpkt(bus, pkt, SDPCM_DATA_CHANNEL, true);
 #else
 		ret = dhdsdio_txpkt(bus, pkt,
 				    (bus->ext_loop ? SDPCM_TEST_CHANNEL :
-				     SDPCM_DATA_CHANNEL), TRUE);
+				     SDPCM_DATA_CHANNEL), true);
 #endif
 		if (ret)
 			bus->dhd->tx_errors++;
@@ -1207,7 +1207,7 @@ static uint dhdsdio_sendfromq(dhd_bus_t
 			if (bcmsdh_regfail(bus->sdh))
 				break;
 			if (intstatus & bus->hostintmask)
-				bus->ipend = TRUE;
+				bus->ipend = true;
 		}
 	}
 
@@ -1291,7 +1291,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 	if (!DATAOK(bus)) {
 		DHD_INFO(("%s: No bus credit bus->tx_max %d, bus->tx_seq %d\n",
 			  __func__, bus->tx_max, bus->tx_seq));
-		bus->ctrl_frame_stat = TRUE;
+		bus->ctrl_frame_stat = true;
 		/* Send from dpc */
 		bus->ctrl_frame_buf = frame;
 		bus->ctrl_frame_len = len;
@@ -1302,7 +1302,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 			DHD_INFO(("%s: ctrl_frame_stat == FALSE\n", __func__));
 			ret = 0;
 		} else {
-			DHD_INFO(("%s: ctrl_frame_stat == TRUE\n", __func__));
+			DHD_INFO(("%s: ctrl_frame_stat == true\n", __func__));
 			ret = -1;
 		}
 	}
@@ -1361,7 +1361,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 
 	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
 		bus->activity = FALSE;
-		dhdsdio_clkctl(bus, CLK_NONE, TRUE);
+		dhdsdio_clkctl(bus, CLK_NONE, true);
 	}
 
 	dhd_os_sdunlock(bus->dhd);
@@ -1404,7 +1404,7 @@ int dhd_bus_rxctl(struct dhd_bus *bus, u
 		dhdsdio_checkdied(bus, NULL, 0);
 		dhd_os_sdunlock(bus->dhd);
 #endif				/* DHD_DEBUG */
-	} else if (pending == TRUE) {
+	} else if (pending == true) {
 		DHD_CTL(("%s: cancelled\n", __func__));
 		return -ERESTARTSYS;
 	} else {
@@ -2114,7 +2114,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 	if (plen >= (int)sizeof(int_val))
 		bcopy(params, &int_val, sizeof(int_val));
 
-	bool_val = (int_val != 0) ? TRUE : FALSE;
+	bool_val = (int_val != 0) ? true : FALSE;
 
 	/* Some ioctls use the bus */
 	dhd_os_sdlock(bus->dhd);
@@ -2498,7 +2498,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 exit:
 	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
 		bus->activity = FALSE;
-		dhdsdio_clkctl(bus, CLK_NONE, TRUE);
+		dhdsdio_clkctl(bus, CLK_NONE, true);
 	}
 
 	dhd_os_sdunlock(bus->dhd);
@@ -2535,7 +2535,7 @@ static int dhdsdio_write_vars(dhd_bus_t
 
 		/* Write the vars list */
 		bcmerror =
-		    dhdsdio_membytes(bus, TRUE, varaddr, vbuffer, varsize);
+		    dhdsdio_membytes(bus, true, varaddr, vbuffer, varsize);
 #ifdef DHD_DEBUG
 		/* Verify NVRAM bytes */
 		DHD_INFO(("Compare NVRAM dl & ul; varsize=%d\n", varsize));
@@ -2591,7 +2591,7 @@ static int dhdsdio_write_vars(dhd_bus_t
 		  varsizew));
 
 	/* Write the length token to the last word */
-	bcmerror = dhdsdio_membytes(bus, TRUE, (bus->orig_ramsize - 4),
+	bcmerror = dhdsdio_membytes(bus, true, (bus->orig_ramsize - 4),
 				    (u8 *)&varsizew, 4);
 
 	return bcmerror;
@@ -2607,7 +2607,7 @@ static int dhdsdio_download_state(dhd_bu
 	 */
 	if (enter) {
 
-		bus->alp_only = TRUE;
+		bus->alp_only = true;
 
 		if (!(si_setcore(bus->sih, ARM7S_CORE_ID, 0)) &&
 		    !(si_setcore(bus->sih, ARMCM3_CORE_ID, 0))) {
@@ -2640,7 +2640,7 @@ static int dhdsdio_download_state(dhd_bu
 		/* Clear the top bit of memory */
 		if (bus->ramsize) {
 			u32 zeros = 0;
-			dhdsdio_membytes(bus, TRUE, bus->ramsize - 4,
+			dhdsdio_membytes(bus, true, bus->ramsize - 4,
 					 (u8 *)&zeros, 4);
 		}
 	} else {
@@ -2785,7 +2785,7 @@ dhd_bus_iovar_op(dhd_pub_t *dhdp, const
 
 		if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
 			bus->activity = FALSE;
-			dhdsdio_clkctl(bus, CLK_NONE, TRUE);
+			dhdsdio_clkctl(bus, CLK_NONE, true);
 		}
 
 		dhd_os_sdunlock(bus->dhd);
@@ -2872,7 +2872,7 @@ void dhd_bus_stop(struct dhd_bus *bus, b
 	dhdsdio_clkctl(bus, CLK_SDONLY, FALSE);
 
 	/* Clear the data packet queues */
-	pktq_flush(osh, &bus->txq, TRUE);
+	pktq_flush(osh, &bus->txq, true);
 
 	/* Clear any held glomming stuff */
 	if (bus->glomd)
@@ -3056,7 +3056,7 @@ static void dhdsdio_rxfail(dhd_bus_t *bu
 		W_SDREG(SMB_NAK, &regs->tosbmailbox, retries);
 		bus->f1regdata++;
 		if (retries <= retry_limit)
-			bus->rxskip = TRUE;
+			bus->rxskip = true;
 	}
 
 	/* Clear partial in any case */
@@ -3151,7 +3151,7 @@ dhdsdio_read_control(dhd_bus_t *bus, u8
 		DHD_ERROR(("%s: read %d control bytes failed: %d\n",
 			   __func__, rdlen, sdret));
 		bus->rxc_errors++;	/* dhd.rx_ctlerrs is higher level */
-		dhdsdio_rxfail(bus, TRUE, TRUE);
+		dhdsdio_rxfail(bus, true, true);
 		goto done;
 	}
 
@@ -3340,10 +3340,10 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 			bus->dhd->rx_errors++;
 
 			if (bus->glomerr++ < 3) {
-				dhdsdio_rxfail(bus, TRUE, TRUE);
+				dhdsdio_rxfail(bus, true, true);
 			} else {
 				bus->glomerr = 0;
-				dhdsdio_rxfail(bus, TRUE, FALSE);
+				dhdsdio_rxfail(bus, true, FALSE);
 				dhd_os_sdlock_rxq(bus->dhd);
 				PKTFREE(osh, bus->glom, FALSE);
 				dhd_os_sdunlock_rxq(bus->dhd);
@@ -3469,10 +3469,10 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 			if (bus->glomerr++ < 3) {
 				/* Restore superframe header space */
 				PKTPUSH(pfirst, sfdoff);
-				dhdsdio_rxfail(bus, TRUE, TRUE);
+				dhdsdio_rxfail(bus, true, true);
 			} else {
 				bus->glomerr = 0;
-				dhdsdio_rxfail(bus, TRUE, FALSE);
+				dhdsdio_rxfail(bus, true, FALSE);
 				dhd_os_sdlock_rxq(bus->dhd);
 				PKTFREE(osh, bus->glom, FALSE);
 				dhd_os_sdunlock_rxq(bus->dhd);
@@ -3576,7 +3576,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 	return num;
 }
 
-/* Return TRUE if there may be more frames to read */
+/* Return true if there may be more frames to read */
 static uint dhdsdio_readframes(dhd_bus_t *bus, uint maxframes, bool *finished)
 {
 	osl_t *osh = bus->dhd->osh;
@@ -3612,7 +3612,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 	/* Allow pktgen to override maxframes */
 	if (bus->pktgen_count && (bus->pktgen_mode == DHD_PKTGEN_RECV)) {
 		maxframes = bus->pktgen_count;
-		sdtest = TRUE;
+		sdtest = true;
 	}
 #endif
 
@@ -3711,10 +3711,10 @@ static uint dhdsdio_readframes(dhd_bus_t
 						/* dhd.rx_ctlerrs is higher */
 						bus->rxc_errors++;
 						dhd_os_sdunlock_rxq(bus->dhd);
-						dhdsdio_rxfail(bus, TRUE,
+						dhdsdio_rxfail(bus, true,
 						       (bus->bus ==
 							SPI_BUS) ? FALSE
-						       : TRUE);
+						       : true);
 						continue;
 					}
 				} else {
@@ -3729,7 +3729,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 				}
 			} else {
 				if (bus->bus == SPI_BUS)
-					bus->usebufpool = TRUE;
+					bus->usebufpool = true;
 
 				ASSERT(!PKTLINK(pkt));
 				PKTALIGN(osh, pkt, rdlen, DHD_SDALIGN);
@@ -3754,10 +3754,10 @@ static uint dhdsdio_readframes(dhd_bus_t
 					 * Don't attemp NAK for
 					 * gSPI
 					 */
-					dhdsdio_rxfail(bus, TRUE,
+					dhdsdio_rxfail(bus, true,
 						       (bus->bus ==
 							SPI_BUS) ? FALSE :
-						       TRUE);
+						       true);
 					continue;
 				}
 			}
@@ -3816,9 +3816,9 @@ static uint dhdsdio_readframes(dhd_bus_t
 				dhd_os_sdlock_rxq(bus->dhd);
 				PKTFREE2();
 				dhd_os_sdunlock_rxq(bus->dhd);
-				dhdsdio_rxfail(bus, TRUE,
+				dhdsdio_rxfail(bus, true,
 					       (bus->bus ==
-						SPI_BUS) ? FALSE : TRUE);
+						SPI_BUS) ? FALSE : true);
 				GSPI_PR55150_BAILOUT;
 				continue;
 			}
@@ -3905,7 +3905,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 						__func__, seq));
 					/* Force retry w/normal header read */
 					bus->nextlen = 0;
-					dhdsdio_rxfail(bus, FALSE, TRUE);
+					dhdsdio_rxfail(bus, FALSE, true);
 					dhd_os_sdlock_rxq(bus->dhd);
 					PKTFREE2();
 					dhd_os_sdunlock_rxq(bus->dhd);
@@ -3950,7 +3950,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 			DHD_ERROR(("%s: RXHEADER FAILED: %d\n", __func__,
 				   sdret));
 			bus->rx_hdrfail++;
-			dhdsdio_rxfail(bus, TRUE, TRUE);
+			dhdsdio_rxfail(bus, true, true);
 			continue;
 		}
 #ifdef DHD_DEBUG
@@ -3964,7 +3964,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 
 		/* All zeros means no more frames */
 		if (!(len | check)) {
-			*finished = TRUE;
+			*finished = true;
 			break;
 		}
 
@@ -4124,7 +4124,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 			PKTFREE(bus->dhd->osh, pkt, FALSE);
 			dhd_os_sdunlock_rxq(bus->dhd);
 			bus->dhd->rx_errors++;
-			dhdsdio_rxfail(bus, TRUE, RETRYCHAN(chan));
+			dhdsdio_rxfail(bus, true, RETRYCHAN(chan));
 			continue;
 		}
 
@@ -4291,7 +4291,7 @@ bool dhdsdio_dpc(dhd_bus_t *bus)
 	uint rxlimit = dhd_rxbound;	/* Rx frames to read before resched */
 	uint txlimit = dhd_txbound;	/* Tx frames to send before resched */
 	uint framecnt = 0;	/* Temporary counter of tx/rx frames */
-	bool rxdone = TRUE;	/* Flag for no more read data */
+	bool rxdone = true;	/* Flag for no more read data */
 	bool resched = FALSE;	/* Flag indicating resched wanted */
 
 	DHD_TRACE(("%s: Enter\n", __func__));
@@ -4358,7 +4358,7 @@ bool dhdsdio_dpc(dhd_bus_t *bus)
 	BUS_WAKE(bus);
 
 	/* Make sure backplane clock is on */
-	dhdsdio_clkctl(bus, CLK_AVAIL, TRUE);
+	dhdsdio_clkctl(bus, CLK_AVAIL, true);
 	if (bus->clkstate == CLK_PENDING)
 		goto clkwait;
 
@@ -4520,11 +4520,11 @@ clkwait:
 	} else if (bus->clkstate == CLK_PENDING) {
 		DHD_INFO(("%s: rescheduled due to CLK_PENDING awaiting "
 			"I_CHIPACTIVE interrupt\n", __func__));
-		resched = TRUE;
+		resched = true;
 	} else if (bus->intstatus || bus->ipend ||
 		(!bus->fcstate && pktq_mlen(&bus->txq, ~bus->flowcontrol) &&
 			DATAOK(bus)) || PKT_AVAILABLE()) {
-		resched = TRUE;
+		resched = true;
 	}
 
 	bus->dpc_sched = resched;
@@ -4572,7 +4572,7 @@ void dhdsdio_isr(void *arg)
 	}
 	/* Count the interrupt call */
 	bus->intrcount++;
-	bus->ipend = TRUE;
+	bus->ipend = true;
 
 	/* Shouldn't get this interrupt if we're sleeping? */
 	if (bus->sleeping) {
@@ -4587,14 +4587,14 @@ void dhdsdio_isr(void *arg)
 		DHD_ERROR(("dhdsdio_isr() w/o interrupt configured!\n"));
 
 	bcmsdh_intr_disable(sdh);
-	bus->intdis = TRUE;
+	bus->intdis = true;
 
 #if defined(SDIO_ISR_THREAD)
 	DHD_TRACE(("Calling dhdsdio_dpc() from %s\n", __func__));
 	while (dhdsdio_dpc(bus))
 		;
 #else
-	bus->dpc_sched = TRUE;
+	bus->dpc_sched = true;
 	dhd_sched_dpc(bus->dhd);
 #endif
 
@@ -4642,7 +4642,7 @@ static void dhdsdio_pktgen(dhd_bus_t *bu
 	/* For recv mode, just make sure dongle has started sending */
 	if (bus->pktgen_mode == DHD_PKTGEN_RECV) {
 		if (!bus->pktgen_rcvd)
-			dhdsdio_sdtest_set(bus, TRUE);
+			dhdsdio_sdtest_set(bus, true);
 		return;
 	}
 
@@ -4659,7 +4659,7 @@ static void dhdsdio_pktgen(dhd_bus_t *bu
 		len = bus->pktgen_len;
 		pkt = PKTGET(osh,
 			(len + SDPCM_HDRLEN + SDPCM_TEST_HDRLEN + DHD_SDALIGN),
-			TRUE);
+			true);
 		if (!pkt) {
 			DHD_ERROR(("%s: PKTGET failed!\n", __func__));
 			break;
@@ -4688,7 +4688,7 @@ static void dhdsdio_pktgen(dhd_bus_t *bu
 		default:
 			DHD_ERROR(("Unrecognized pktgen mode %d\n",
 				   bus->pktgen_mode));
-			PKTFREE(osh, pkt, TRUE);
+			PKTFREE(osh, pkt, true);
 			bus->pktgen_count = 0;
 			return;
 		}
@@ -4712,7 +4712,7 @@ static void dhdsdio_pktgen(dhd_bus_t *bu
 #endif
 
 		/* Send it */
-		if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, TRUE)) {
+		if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, true)) {
 			bus->pktgen_fail++;
 			if (bus->pktgen_stop
 			    && bus->pktgen_stop == bus->pktgen_fail)
@@ -4738,7 +4738,7 @@ static void dhdsdio_sdtest_set(dhd_bus_t
 
 	/* Allocate the packet */
 	pkt = PKTGET(osh, SDPCM_HDRLEN + SDPCM_TEST_HDRLEN + DHD_SDALIGN,
-			TRUE);
+			true);
 	if (!pkt) {
 		DHD_ERROR(("%s: PKTGET failed!\n", __func__));
 		return;
@@ -4753,7 +4753,7 @@ static void dhdsdio_sdtest_set(dhd_bus_t
 	*data++ = (bus->pktgen_maxlen >> 8);
 
 	/* Send it */
-	if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, TRUE))
+	if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, true))
 		bus->pktgen_fail++;
 }
 
@@ -4802,7 +4802,7 @@ static void dhdsdio_testrcv(dhd_bus_t *b
 		/* Rx->Tx turnaround ok (even on NDIS w/current
 			 implementation) */
 		*(u8 *) (PKTDATA(pkt)) = SDPCM_TEST_ECHORSP;
-		if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, TRUE) == 0) {
+		if (dhdsdio_txpkt(bus, pkt, SDPCM_TEST_CHANNEL, true) == 0) {
 			bus->pktgen_sent++;
 		} else {
 			bus->pktgen_fail++;
@@ -4897,11 +4897,11 @@ extern bool dhd_bus_watchdog(dhd_pub_t *
 				 schedule the DPC */
 			if (intstatus) {
 				bus->pollcnt++;
-				bus->ipend = TRUE;
+				bus->ipend = true;
 				if (bus->intr)
 					bcmsdh_intr_disable(bus->sdh);
 
-				bus->dpc_sched = TRUE;
+				bus->dpc_sched = true;
 				dhd_sched_dpc(bus->dhd);
 
 			}
@@ -4982,34 +4982,34 @@ extern int dhd_bus_console_in(dhd_pub_t
 	/* Zero cbuf_index */
 	addr = bus->console_addr + offsetof(hndrte_cons_t, cbuf_idx);
 	val = htol32(0);
-	rv = dhdsdio_membytes(bus, TRUE, addr, (u8 *)&val, sizeof(val));
+	rv = dhdsdio_membytes(bus, true, addr, (u8 *)&val, sizeof(val));
 	if (rv < 0)
 		goto done;
 
 	/* Write message into cbuf */
 	addr = bus->console_addr + offsetof(hndrte_cons_t, cbuf);
-	rv = dhdsdio_membytes(bus, TRUE, addr, (u8 *)msg, msglen);
+	rv = dhdsdio_membytes(bus, true, addr, (u8 *)msg, msglen);
 	if (rv < 0)
 		goto done;
 
 	/* Write length into vcons_in */
 	addr = bus->console_addr + offsetof(hndrte_cons_t, vcons_in);
 	val = htol32(msglen);
-	rv = dhdsdio_membytes(bus, TRUE, addr, (u8 *)&val, sizeof(val));
+	rv = dhdsdio_membytes(bus, true, addr, (u8 *)&val, sizeof(val));
 	if (rv < 0)
 		goto done;
 
 	/* Bump dongle by sending an empty event pkt.
 	 * sdpcm_sendup (RX) checks for virtual console input.
 	 */
-	pkt = PKTGET(bus->dhd->osh, 4 + SDPCM_RESERVE, TRUE);
+	pkt = PKTGET(bus->dhd->osh, 4 + SDPCM_RESERVE, true);
 	if ((pkt != NULL) && bus->clkstate == CLK_AVAIL)
-		dhdsdio_txpkt(bus, pkt, SDPCM_EVENT_CHANNEL, TRUE);
+		dhdsdio_txpkt(bus, pkt, SDPCM_EVENT_CHANNEL, true);
 
 done:
 	if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
 		bus->activity = FALSE;
-		dhdsdio_clkctl(bus, CLK_NONE, TRUE);
+		dhdsdio_clkctl(bus, CLK_NONE, true);
 	}
 
 	dhd_os_sdunlock(bus->dhd);
@@ -5050,11 +5050,11 @@ static void dhd_dump_cis(uint fn, u8 *ci
 static bool dhdsdio_chipmatch(u16 chipid)
 {
 	if (chipid == BCM4325_CHIP_ID)
-		return TRUE;
+		return true;
 	if (chipid == BCM4329_CHIP_ID)
-		return TRUE;
+		return true;
 	if (chipid == BCM4319_CHIP_ID)
-		return TRUE;
+		return true;
 	return FALSE;
 }
 
@@ -5075,15 +5075,15 @@ static void *dhdsdio_probe(u16 venid, u1
 	 */
 	dhd_txbound = DHD_TXBOUND;
 	dhd_rxbound = DHD_RXBOUND;
-	dhd_alignctl = TRUE;
-	sd1idle = TRUE;
-	dhd_readahead = TRUE;
+	dhd_alignctl = true;
+	sd1idle = true;
+	dhd_readahead = true;
 	retrydata = FALSE;
 	dhd_doflow = FALSE;
 	dhd_dongle_memsize = 0;
 	dhd_txminmax = DHD_TXMINMAX;
 
-	forcealign = TRUE;
+	forcealign = true;
 
 	dhd_common_init();
 
@@ -5226,7 +5226,7 @@ dhdsdio_probe_attach(struct dhd_bus *bus
 	u8 clkctl = 0;
 	int err = 0;
 
-	bus->alp_only = TRUE;
+	bus->alp_only = true;
 
 	/* Return the window to backplane enumeration space for core access */
 	if (dhdsdio_set_siaddr_window(bus, SI_ENUM_BASE))
@@ -5372,7 +5372,7 @@ dhdsdio_probe_attach(struct dhd_bus *bus
 	if (bus->poll)
 		bus->pollrate = 1;
 
-	return TRUE;
+	return true;
 
 fail:
 	return FALSE;
@@ -5434,7 +5434,7 @@ static bool dhdsdio_probe_malloc(dhd_bus
 	else
 		bus->dataptr = bus->databuf;
 
-	return TRUE;
+	return true;
 
 fail:
 	return FALSE;
@@ -5513,7 +5513,7 @@ static bool dhdsdio_probe_init(dhd_bus_t
 	}
 	bus->use_rxchain = (bool) bus->sd_rxchain;
 
-	return TRUE;
+	return true;
 }
 
 bool
@@ -5669,7 +5669,7 @@ static int dhdsdio_download_code_array(s
 	/* Download image */
 	while ((offset + MEMBLOCK) < sizeof(dlarray)) {
 		bcmerror =
-		    dhdsdio_membytes(bus, TRUE, offset, dlarray + offset,
+		    dhdsdio_membytes(bus, true, offset, dlarray + offset,
 				     MEMBLOCK);
 		if (bcmerror) {
 			DHD_ERROR(("%s: error %d on writing %d membytes at "
@@ -5682,7 +5682,7 @@ static int dhdsdio_download_code_array(s
 	}
 
 	if (offset < sizeof(dlarray)) {
-		bcmerror = dhdsdio_membytes(bus, TRUE, offset,
+		bcmerror = dhdsdio_membytes(bus, true, offset,
 					    dlarray + offset,
 					    sizeof(dlarray) - offset);
 		if (bcmerror) {
@@ -5772,7 +5772,7 @@ static int dhdsdio_download_code_file(st
 	/* Download image */
 	while ((len =
 		dhd_os_get_image_block((char *)memptr, MEMBLOCK, image))) {
-		bcmerror = dhdsdio_membytes(bus, TRUE, offset, memptr, len);
+		bcmerror = dhdsdio_membytes(bus, true, offset, memptr, len);
 		if (bcmerror) {
 			DHD_ERROR(("%s: error %d on writing %d membytes at "
 			"0x%08x\n", __func__, bcmerror, MEMBLOCK, offset));
@@ -5822,7 +5822,7 @@ static uint process_nvram_vars(char *var
 			continue;
 		findNewline = FALSE;
 		if (varbuf[n] == '#') {
-			findNewline = TRUE;
+			findNewline = true;
 			continue;
 		}
 		if (varbuf[n] == '\n') {
@@ -5942,14 +5942,14 @@ static int _dhdsdio_download_firmware(st
 	/* Out immediately if no image to download */
 	if ((bus->fw_path == NULL) || (bus->fw_path[0] == '\0')) {
 #ifdef BCMEMBEDIMAGE
-		embed = TRUE;
+		embed = true;
 #else
 		return bcmerror;
 #endif
 	}
 
 	/* Keep arm in reset */
-	if (dhdsdio_download_state(bus, TRUE)) {
+	if (dhdsdio_download_state(bus, true)) {
 		DHD_ERROR(("%s: error placing ARM core in reset\n", __func__));
 		goto err;
 	}
@@ -5960,13 +5960,13 @@ static int _dhdsdio_download_firmware(st
 			DHD_ERROR(("%s: dongle image file download failed\n",
 				   __func__));
 #ifdef BCMEMBEDIMAGE
-			embed = TRUE;
+			embed = true;
 #else
 			goto err;
 #endif
 		} else {
 			embed = FALSE;
-			dlok = TRUE;
+			dlok = true;
 		}
 	}
 #ifdef BCMEMBEDIMAGE
@@ -5976,7 +5976,7 @@ static int _dhdsdio_download_firmware(st
 				   __func__));
 			goto err;
 		} else {
-			dlok = TRUE;
+			dlok = true;
 		}
 	}
 #endif
@@ -6061,7 +6061,7 @@ int dhd_bus_devreset(dhd_pub_t *dhdp, u8
 
 	bus = dhdp->bus;
 
-	if (flag == TRUE) {
+	if (flag == true) {
 		if (!bus->dhd->dongle_reset) {
 			/* Expect app to have torn down any
 			 connection before calling */
@@ -6072,7 +6072,7 @@ int dhd_bus_devreset(dhd_pub_t *dhdp, u8
 			 detach from the dongle */
 			dhdsdio_release_dongle(bus, bus->dhd->osh);
 
-			bus->dhd->dongle_reset = TRUE;
+			bus->dhd->dongle_reset = true;
 			bus->dhd->up = FALSE;
 
 			DHD_TRACE(("%s:  WLAN OFF DONE\n", __func__));
@@ -6105,11 +6105,11 @@ int dhd_bus_devreset(dhd_pub_t *dhdp, u8
 						     FALSE);
 
 #if defined(OOB_INTR_ONLY)
-					dhd_enable_oob_intr(bus, TRUE);
+					dhd_enable_oob_intr(bus, true);
 #endif				/* defined(OOB_INTR_ONLY) */
 
 					bus->dhd->dongle_reset = FALSE;
-					bus->dhd->up = TRUE;
+					bus->dhd->up = true;
 
 					DHD_TRACE(("%s: WLAN ON DONE\n",
 						   __func__));
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
@@ -750,7 +750,7 @@ static s32 wl_do_iscan(struct wl_priv *w
 		}
 	}
 	wl_set_mpc(ndev, 0);
-	wl->iscan_kickstart = TRUE;
+	wl->iscan_kickstart = true;
 	wl_run_iscan(iscan, &ssid, WL_SCAN_ACTION_START);
 	mod_timer(&iscan->timer, jiffies + iscan->timer_ms * HZ / 1000);
 	iscan->timer_on = 1;
@@ -793,7 +793,7 @@ __wl_cfg80211_scan(struct wiphy *wiphy,
 							 * we do not iscan for
 							 * specific scan request
 							 */
-			iscan_req = TRUE;
+			iscan_req = true;
 		}
 	} else {		/* scan in ibss */
 		/* we don't do iscan in ibss */
@@ -818,7 +818,7 @@ __wl_cfg80211_scan(struct wiphy *wiphy,
 			sr->ssid.SSID_len = htod32(sr->ssid.SSID_len);
 			WL_DBG(("Specific scan ssid=\"%s\" len=%d\n",
 					sr->ssid.SSID, sr->ssid.SSID_len));
-			spec_scan = TRUE;
+			spec_scan = true;
 		} else {
 			WL_DBG(("Broadcast scan\n"));
 		}
@@ -977,7 +977,7 @@ static s32 wl_cfg80211_set_wiphy_params(
 	if (changed & WIPHY_PARAM_RETRY_LONG
 	    && (wl->conf->retry_long != wiphy->retry_long)) {
 		wl->conf->retry_long = wiphy->retry_long;
-		err = wl_set_retry(ndev, wl->conf->retry_long, TRUE);
+		err = wl_set_retry(ndev, wl->conf->retry_long, true);
 		if (!err)
 			return err;
 	}
@@ -1035,7 +1035,7 @@ wl_cfg80211_join_ibss(struct wiphy *wiph
 		wl->ibss_starter = FALSE;
 		WL_DBG(("Found IBSS\n"));
 	} else {
-		wl->ibss_starter = TRUE;
+		wl->ibss_starter = true;
 	}
 	chan = params->channel;
 	if (chan)
@@ -1574,7 +1574,7 @@ wl_add_keyext(struct wiphy *wiphy, struc
 			key.rxiv.hi = (ivptr[5] << 24) | (ivptr[4] << 16) |
 			    (ivptr[3] << 8) | ivptr[2];
 			key.rxiv.lo = (ivptr[1] << 8) | ivptr[0];
-			key.iv_initialized = TRUE;
+			key.iv_initialized = true;
 		}
 
 		switch (params->cipher) {
@@ -1991,7 +1991,7 @@ static s32 wl_cfg80211_suspend(struct wi
 	set_bit(WL_STATUS_SCAN_ABORTING, &wl->status);
 	wl_term_iscan(wl);
 	if (wl->scan_request) {
-		cfg80211_scan_done(wl->scan_request, TRUE);	/* TRUE means
+		cfg80211_scan_done(wl->scan_request, true);	/* true means
 								 abort */
 		wl_set_mpc(ndev, 1);
 		wl->scan_request = NULL;
@@ -2339,7 +2339,7 @@ static bool wl_is_linkup(struct wl_priv
 				if (wl_is_ibssstarter(wl)) {
 				}
 			} else {
-				return TRUE;
+				return true;
 			}
 		}
 	}
@@ -2353,10 +2353,10 @@ static bool wl_is_linkdown(struct wl_pri
 	u16 flags = ntoh16(e->flags);
 
 	if (event == WLC_E_DEAUTH_IND || event == WLC_E_DISASSOC_IND) {
-		return TRUE;
+		return true;
 	} else if (event == WLC_E_LINK) {
 		if (!(flags & WLC_EVENT_MSG_LINK))
-			return TRUE;
+			return true;
 	}
 
 	return FALSE;
@@ -2369,7 +2369,7 @@ static bool wl_is_nonetwork(struct wl_pr
 
 	if (event == WLC_E_SET_SSID || event == WLC_E_LINK) {
 		if (status == WLC_E_STATUS_NO_NETWORKS)
-			return TRUE;
+			return true;
 	}
 
 	return FALSE;
@@ -2389,12 +2389,12 @@ wl_notify_connect_status(struct wl_priv
 					     GFP_KERNEL);
 			WL_DBG(("joined in IBSS network\n"));
 		} else {
-			wl_bss_connect_done(wl, ndev, e, data, TRUE);
+			wl_bss_connect_done(wl, ndev, e, data, true);
 			WL_DBG(("joined in BSS network \"%s\"\n",
 				((struct wlc_ssid *)
 				 wl_read_prof(wl, WL_PROF_SSID))->SSID));
 		}
-		act = TRUE;
+		act = true;
 		wl_update_prof(wl, e, &act, WL_PROF_ACT);
 	} else if (wl_is_linkdown(wl, e)) {
 		cfg80211_disconnected(ndev, 0, NULL, 0, GFP_KERNEL);
@@ -2416,7 +2416,7 @@ wl_notify_roaming_status(struct wl_priv
 	s32 err = 0;
 
 	wl_bss_roaming_done(wl, ndev, e, data);
-	act = TRUE;
+	act = true;
 	wl_update_prof(wl, e, &act, WL_PROF_ACT);
 
 	return err;
@@ -2978,7 +2978,7 @@ static s32 wl_iscan_aborted(struct wl_pr
 
 	iscan->state = WL_ISCAN_STATE_IDLE;
 	rtnl_lock();
-	wl_notify_iscan_complete(iscan, TRUE);
+	wl_notify_iscan_complete(iscan, true);
 	rtnl_unlock();
 
 	return err;
@@ -3099,20 +3099,20 @@ static s32 wl_init_priv(struct wl_priv *
 	wl->scan_request = NULL;
 	wl->pwr_save = !!(wiphy->flags & WIPHY_FLAG_PS_ON_BY_DEFAULT);
 #ifndef WL_ISCAN_DISABLED
-	wl->iscan_on = TRUE;	/* iscan on & off switch.
+	wl->iscan_on = true;	/* iscan on & off switch.
 				 we enable iscan per default */
 #else
 	wl->iscan_on = FALSE;
 #endif				/* WL_ISCAN_DISABLED */
 #ifndef WL_ROAM_DISABLED
-	wl->roam_on = TRUE;	/* roam on & off switch.
+	wl->roam_on = true;	/* roam on & off switch.
 				 we enable roam per default */
 #else
 	wl->roam_on = FALSE;
 #endif				/* WL_ROAM_DISABLED */
 
 	wl->iscan_kickstart = FALSE;
-	wl->active_scan = TRUE;	/* we do active scan for
+	wl->active_scan = true;	/* we do active scan for
 				 specific scan per default */
 	wl->dongle_up = FALSE;	/* dongle is not up yet */
 	wl_init_eq(wl);
@@ -3742,7 +3742,7 @@ default_conf_out:
 	if (need_lock)
 		rtnl_unlock();
 
-	wl->dongle_up = TRUE;
+	wl->dongle_up = true;
 
 	return err;
 
@@ -3797,7 +3797,7 @@ static s32 __wl_cfg80211_down(struct wl_
 	set_bit(WL_STATUS_SCAN_ABORTING, &wl->status);
 	wl_term_iscan(wl);
 	if (wl->scan_request) {
-		cfg80211_scan_done(wl->scan_request, TRUE);	/* TRUE
+		cfg80211_scan_done(wl->scan_request, true);	/* true
 								 means abort */
 		wl_set_mpc(ndev, 1);
 		wl->scan_request = NULL;
@@ -3982,7 +3982,7 @@ static u32 wl_get_ielen(struct wl_priv *
 
 static void wl_link_up(struct wl_priv *wl)
 {
-	wl->link_up = TRUE;
+	wl->link_up = true;
 }
 
 static void wl_link_down(struct wl_priv *wl)
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -57,7 +57,7 @@ typedef const struct si_pub si_t;
 #define WL_IW_USE_ISCAN  1
 #define ENABLE_ACTIVE_PASSIVE_SCAN_SUPPRESS  1
 
-bool g_set_essid_before_scan = TRUE;
+bool g_set_essid_before_scan = true;
 
 #define WL_IW_IOCTL_CALL(func_call) \
 	do {				\
@@ -1189,7 +1189,7 @@ static int _iscan_sysioc_thread(void *da
 		rtnl_lock();
 		status = wl_iw_iscan_get(iscan);
 		rtnl_unlock();
-		if (g_scan_specified_ssid && (iscan_pass_abort == TRUE)) {
+		if (g_scan_specified_ssid && (iscan_pass_abort == true)) {
 			WL_TRACE(("%s Get results from specific scan "
 				"status = %d\n", __func__, status));
 			wl_iw_send_scan_complete(iscan);
@@ -1224,7 +1224,7 @@ static int _iscan_sysioc_thread(void *da
 			if (g_scan_specified_ssid == 0)
 				wl_iw_send_scan_complete(iscan);
 			else {
-				iscan_pass_abort = TRUE;
+				iscan_pass_abort = true;
 				wl_iw_force_specific_scan(iscan);
 			}
 			break;
@@ -1407,7 +1407,7 @@ static bool ie_is_wpa_ie(u8 **wpaie, u8
 
 	if ((ie[1] >= 6) &&
 	    !bcmp((const void *)&ie[2], (const void *)(WPA_OUI "\x01"), 4)) {
-		return TRUE;
+		return true;
 	}
 
 	ie += ie[1] + 2;
@@ -1423,7 +1423,7 @@ static bool ie_is_wps_ie(u8 **wpsie, u8
 
 	if ((ie[1] >= 4) &&
 	    !bcmp((const void *)&ie[2], (const void *)(WPA_OUI "\x04"), 4)) {
-		return TRUE;
+		return true;
 	}
 
 	ie += ie[1] + 2;
@@ -2590,7 +2590,7 @@ wl_iw_set_encodeext(struct net_device *d
 			key.rxiv.hi = (ivptr[5] << 24) | (ivptr[4] << 16) |
 			    (ivptr[3] << 8) | ivptr[2];
 			key.rxiv.lo = (ivptr[1] << 8) | ivptr[0];
-			key.iv_initialized = TRUE;
+			key.iv_initialized = true;
 		}
 
 		switch (iwe->alg) {
@@ -2797,11 +2797,11 @@ wl_iw_set_wpaauth(struct net_device *dev
 		}
 
 		if (iw->privacy_invoked && !val) {
-			WL_WSEC(("%s: %s: 'Privacy invoked' TRUE but clearing "
+			WL_WSEC(("%s: %s: 'Privacy invoked' true but clearing "
 				"wsec, assuming " "we're a WPS enrollee\n",
 				dev->name, __func__));
 			error = dev_wlc_intvar_set(dev, "is_WPS_enrollee",
-							TRUE);
+							true);
 			if (error) {
 				WL_WSEC(("Failed to set is_WPS_enrollee\n"));
 				return error;
@@ -2913,7 +2913,7 @@ wl_iw_set_wpaauth(struct net_device *dev
 					return error;
 				}
 			} else {
-				iw->privacy_invoked = TRUE;
+				iw->privacy_invoked = true;
 				error = dev_wlc_intvar_get(dev, "wsec", &wsec);
 				if (error)
 					return error;
@@ -2921,7 +2921,7 @@ wl_iw_set_wpaauth(struct net_device *dev
 				if (!(IW_WSEC_ENABLED(wsec))) {
 					error = dev_wlc_intvar_set(dev,
 							"is_WPS_enrollee",
-							TRUE);
+							true);
 					if (error) {
 						WL_WSEC(("Failed to set iovar "
 						"is_WPS_enrollee\n"));
@@ -3034,7 +3034,7 @@ wl_iw_get_wpaauth(struct net_device *dev
 		if (error)
 			return error;
 		if (val)
-			paramval = TRUE;
+			paramval = true;
 		else
 			paramval = FALSE;
 		break;
@@ -3340,7 +3340,7 @@ wl_iw_conn_status_str(u32 event_type, u3
 		snprintf(stringBuf, buflen, "%s %s %02d %02d",
 			 name, cause, status, reason);
 		WL_INFORM(("Connection status: %s\n", stringBuf));
-		return TRUE;
+		return true;
 	} else {
 		return FALSE;
 	}
@@ -3356,7 +3356,7 @@ wl_iw_check_conn_fail(wl_event_msg_t *e,
 	u32 reason = ntoh32(e->reason);
 
 	if (wl_iw_conn_status_str(event, status, reason, stringBuf, buflen)) {
-		return TRUE;
+		return true;
 	} else
 		return FALSE;
 }
--- a/drivers/staging/brcm80211/include/bcmdefs.h
+++ b/drivers/staging/brcm80211/include/bcmdefs.h
@@ -185,7 +185,7 @@ typedef struct {
 
 /* define BCMSMALL to remove misc features for memory-constrained environments */
 #define	BCMSPACE
-#define bcmspace	TRUE	/* if (bcmspace) code is retained */
+#define bcmspace	true	/* if (bcmspace) code is retained */
 
 /* Max. nvram variable table size */
 #define	MAXSZ_NVRAM_VARS	4096
--- a/drivers/staging/brcm80211/include/bcmnvram.h
+++ b/drivers/staging/brcm80211/include/bcmnvram.h
@@ -88,7 +88,7 @@ extern int nvram_resetgpio_init(void *si
  * Match an NVRAM variable.
  * @param	name	name of variable to match
  * @param	match	value to compare against value of variable
- * @return	TRUE if variable is defined and its value is string equal
+ * @return	true if variable is defined and its value is string equal
  *		to match or FALSE otherwise
  */
 static inline int nvram_match(char *name, char *match)
@@ -101,7 +101,7 @@ static inline int nvram_match(char *name
  * Inversely match an NVRAM variable.
  * @param	name	name of variable to match
  * @param	match	value to compare against value of variable
- * @return	TRUE if variable is defined and its value is not string
+ * @return	true if variable is defined and its value is not string
  *		equal to invmatch or FALSE otherwise
  */
 static inline int nvram_invmatch(char *name, char *invmatch)
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -482,7 +482,7 @@
 	typedef u32 mbool;
 #define mboolset(mb, bit)		((mb) |= (bit))	/* set one bool */
 #define mboolclr(mb, bit)		((mb) &= ~(bit))	/* clear one bool */
-#define mboolisset(mb, bit)		(((mb) & (bit)) != 0)	/* TRUE if one bool is set */
+#define mboolisset(mb, bit)		(((mb) & (bit)) != 0)	/* true if one bool is set */
 #define	mboolmaskset(mb, mask, val)	((mb) = (((mb) & ~(mask)) | (val)))
 
 /* power conversion */
--- a/drivers/staging/brcm80211/include/bcmwifi.h
+++ b/drivers/staging/brcm80211/include/bcmwifi.h
@@ -132,7 +132,7 @@ typedef u16 chanspec_t;
  * Verify the chanspec is using a legal set of parameters, i.e. that the
  * chanspec specified a band, bw, ctl_sb and channel and that the
  * combination could be legal given any set of circumstances.
- * RETURNS: TRUE is the chanspec is malformed, false if it looks good.
+ * RETURNS: true is the chanspec is malformed, false if it looks good.
  */
 extern bool wf_chspec_malformed(chanspec_t chanspec);
 
--- a/drivers/staging/brcm80211/include/msgtrace.h
+++ b/drivers/staging/brcm80211/include/msgtrace.h
@@ -44,7 +44,7 @@ typedef BWL_PRE_PACKED_STRUCT struct msg
 
 /* The hbus driver generates traces when sending a trace message.
  * This causes endless traces.
- * This flag must be set to TRUE in any hbus traces.
+ * This flag must be set to true in any hbus traces.
  * The flag is reset in the function msgtrace_put.
  * This prevents endless traces but generates hasardous
  * lost of traces only in bus device code.
--- a/drivers/staging/brcm80211/include/osl.h
+++ b/drivers/staging/brcm80211/include/osl.h
@@ -53,7 +53,7 @@ typedef void (*osl_wreg_fn_t) (void *ctx
 #define OSL_SYSUPTIME() (0)
 #define OSL_SYSUPTIME_SUPPORT FALSE
 #else
-#define OSL_SYSUPTIME_SUPPORT TRUE
+#define OSL_SYSUPTIME_SUPPORT true
 #endif				/* OSL_SYSUPTIME */
 
 #endif				/* _osl_h_ */
--- a/drivers/staging/brcm80211/include/typedefs.h
+++ b/drivers/staging/brcm80211/include/typedefs.h
@@ -34,10 +34,6 @@ typedef unsigned int uintptr;
 #define FALSE	0
 #endif
 
-#ifndef TRUE
-#define TRUE	1		/* TRUE */
-#endif
-
 #ifndef OFF
 #define	OFF	0
 #endif
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -640,14 +640,14 @@ wlc_phy_t *wlc_phy_attach(shared_phy_t *
 	bzero((char *)pi, sizeof(phy_info_t));
 	pi->regs = (d11regs_t *) regs;
 	pi->sh = sh;
-	pi->phy_init_por = TRUE;
+	pi->phy_init_por = true;
 	pi->phy_wreg_limit = PHY_WREG_LIMIT;
 
 	pi->vars = vars;
 
 	pi->txpwr_percent = 100;
 
-	pi->do_initcal = TRUE;
+	pi->do_initcal = true;
 
 	pi->phycal_tempdelta = 0;
 
@@ -713,7 +713,7 @@ wlc_phy_t *wlc_phy_attach(shared_phy_t *
 	pi->rxiq_samps = PHY_NOISE_SAMPLE_LOG_NUM_NPHY;
 	pi->rxiq_antsel = ANT_RX_DIV_DEF;
 
-	pi->watchdog_override = TRUE;
+	pi->watchdog_override = true;
 
 	pi->cal_type_override = PHY_PERICAL_AUTO;
 
@@ -736,7 +736,7 @@ wlc_phy_t *wlc_phy_attach(shared_phy_t *
 
 	pi->nphy_lastcal_temp = -50;
 
-	pi->phynoise_polling = TRUE;
+	pi->phynoise_polling = true;
 	if (ISNPHY(pi) || ISLCNPHY(pi))
 		pi->phynoise_polling = FALSE;
 
@@ -824,7 +824,7 @@ wlc_phy_get_phyversion(wlc_phy_t *pih, u
 	*radioid = pi->pubpi.radioid;
 	*radiover = pi->pubpi.radiorev;
 
-	return TRUE;
+	return true;
 }
 
 bool wlc_phy_get_encore(wlc_phy_t *pih)
@@ -929,7 +929,7 @@ void WLBANDINITFN(wlc_phy_por_inform) (w
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
-	pi->phy_init_por = TRUE;
+	pi->phy_init_por = true;
 }
 
 void wlc_phy_edcrs_lock(wlc_phy_t *pih, bool lock)
@@ -980,7 +980,7 @@ void WLBANDINITFN(wlc_phy_init) (wlc_phy
 	if (pi->init_in_progress)
 		return;
 
-	pi->init_in_progress = TRUE;
+	pi->init_in_progress = true;
 
 	pi->radio_chanspec = chanspec;
 
@@ -1012,7 +1012,7 @@ void WLBANDINITFN(wlc_phy_init) (wlc_phy
 		wlapi_bmac_bw_set(pi->sh->physhim,
 				  CHSPEC_BW(pi->radio_chanspec));
 
-	pi->nphy_gain_boost = TRUE;
+	pi->nphy_gain_boost = true;
 
 	wlc_phy_switch_radio((wlc_phy_t *) pi, ON);
 
@@ -1021,7 +1021,7 @@ void WLBANDINITFN(wlc_phy_init) (wlc_phy
 	pi->phy_init_por = FALSE;
 
 	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
-		wlc_phy_do_dummy_tx(pi, TRUE, OFF);
+		wlc_phy_do_dummy_tx(pi, true, OFF);
 
 	if (!(ISNPHY(pi)))
 		wlc_phy_txpower_update_shm(pi);
@@ -1043,7 +1043,7 @@ void wlc_phy_cal_init(wlc_phy_t *pih)
 		if (cal_init)
 			(*cal_init) (pi);
 
-		pi->initialized = TRUE;
+		pi->initialized = true;
 	}
 }
 
@@ -1652,7 +1652,7 @@ void wlc_phy_txpower_target_set(wlc_phy_
 	      WLC_NUM_RATES_MCS_2_STREAM);
 
 	if (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC)
-		mac_enabled = TRUE;
+		mac_enabled = true;
 
 	if (mac_enabled)
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
@@ -2436,7 +2436,7 @@ bool wlc_phy_test_ison(wlc_phy_t *ppi)
 bool wlc_phy_ant_rxdiv_get(wlc_phy_t *ppi, u8 *pval)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
-	bool ret = TRUE;
+	bool ret = true;
 
 	wlc_phyreg_enter(ppi);
 
@@ -2527,7 +2527,7 @@ wlc_phy_noise_calc_phy(phy_info_t *pi, u
 	}
 	pi->nphy_noise_index =
 	    MODINC_POW2(pi->nphy_noise_index, PHY_NOISE_WINDOW_SZ);
-	return TRUE;
+	return true;
 }
 
 static void
@@ -2536,7 +2536,7 @@ wlc_phy_noise_sample_request(wlc_phy_t *
 	phy_info_t *pi = (phy_info_t *) pih;
 	s8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
 	bool sampling_in_progress = (pi->phynoise_state != 0);
-	bool wait_for_intr = TRUE;
+	bool wait_for_intr = true;
 
 	if (NORADIO_ENAB(pi->pubpi)) {
 		return;
@@ -2924,9 +2924,9 @@ void wlc_phy_set_deaf(wlc_phy_t *ppi, bo
 	pi = (phy_info_t *) ppi;
 
 	if (ISLCNPHY(pi))
-		wlc_lcnphy_deaf_mode(pi, TRUE);
+		wlc_lcnphy_deaf_mode(pi, true);
 	else if (ISNPHY(pi))
-		wlc_nphy_deaf_mode(pi, TRUE);
+		wlc_nphy_deaf_mode(pi, true);
 	else {
 		ASSERT(0);
 	}
@@ -3121,7 +3121,7 @@ void wlc_phy_cal_perical(wlc_phy_t *pih,
 {
 	s16 nphy_currtemp = 0;
 	s16 delta_temp = 0;
-	bool do_periodic_cal = TRUE;
+	bool do_periodic_cal = true;
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	if (!ISNPHY(pi))
@@ -3153,7 +3153,7 @@ void wlc_phy_cal_perical(wlc_phy_t *pih,
 			wlc_phy_cal_perical_mphase_reset(pi);
 		}
 
-		pi->first_cal_after_assoc = TRUE;
+		pi->first_cal_after_assoc = true;
 
 		pi->cal_type_override = PHY_PERICAL_FULL;
 
@@ -3288,7 +3288,7 @@ u8 wlc_phy_stf_chain_active_get(wlc_phy_
 		if (!pi->phy_txcore_heatedup) {
 			if (nphy_currtemp >= pi->phy_txcore_disable_temp) {
 				active_bitmap &= 0xFD;
-				pi->phy_txcore_heatedup = TRUE;
+				pi->phy_txcore_heatedup = true;
 			}
 		} else {
 			if (nphy_currtemp <= pi->phy_txcore_enable_temp) {
--- a/drivers/staging/brcm80211/phy/wlc_phy_hal.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_hal.h
@@ -52,7 +52,7 @@
 #define BCM2064A0_IDCODE	0x0206417f
 
 #define PHY_TPC_HW_OFF		FALSE
-#define PHY_TPC_HW_ON		TRUE
+#define PHY_TPC_HW_ON		true
 
 #define PHY_PERICAL_DRIVERUP	1
 #define PHY_PERICAL_WATCHDOG	2
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -82,7 +82,7 @@
 	(0x7f << LCNPHY_stxtxgainctrlovrval1_pagain_ovr_val1_SHIFT)
 
 #define wlc_lcnphy_enable_tx_gain_override(pi) \
-	wlc_lcnphy_set_tx_gain_override(pi, TRUE)
+	wlc_lcnphy_set_tx_gain_override(pi, true)
 #define wlc_lcnphy_disable_tx_gain_override(pi) \
 	wlc_lcnphy_set_tx_gain_override(pi, FALSE)
 
@@ -1244,7 +1244,7 @@ void wlc_phy_chanspec_set_lcnphy(phy_inf
 		wlc_lcnphy_load_tx_iir_filter(pi, FALSE, 2);
 	}
 
-	wlc_lcnphy_load_tx_iir_filter(pi, TRUE, 0);
+	wlc_lcnphy_load_tx_iir_filter(pi, true, 0);
 
 	mod_phy_reg(pi, 0x4eb, (0x7 << 3), (1) << 3);
 
@@ -2049,7 +2049,7 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t *pi,
 				     txiqlocal_bestcoeffs,
 				     ARRAY_SIZE(pi_lcn->lcnphy_cal_results.
 					       txiqlocal_bestcoeffs), 16, 96);
-	pi_lcn->lcnphy_cal_results.txiqlocal_bestcoeffs_valid = TRUE;
+	pi_lcn->lcnphy_cal_results.txiqlocal_bestcoeffs_valid = true;
 
 	wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
 				      &pi_lcn->lcnphy_cal_results.
@@ -2111,7 +2111,7 @@ static void wlc_lcnphy_idle_tssi_est(wlc
 	mod_radio_reg(pi, RADIO_2064_REG0FF, 0x10, 1 << 4);
 	mod_radio_reg(pi, RADIO_2064_REG11F, 0x4, 1 << 2);
 	wlc_lcnphy_tssi_setup(pi);
-	wlc_phy_do_dummy_tx(pi, TRUE, OFF);
+	wlc_phy_do_dummy_tx(pi, true, OFF);
 	idleTssi = ((read_phy_reg(pi, 0x4ab) & (0x1ff << 0))
 		    >> 0);
 
@@ -2267,7 +2267,7 @@ static void wlc_lcnphy_vbat_temp_sense_s
 
 	write_radio_reg(pi, RADIO_2064_REG112, 0x6);
 
-	wlc_phy_do_dummy_tx(pi, TRUE, OFF);
+	wlc_phy_do_dummy_tx(pi, true, OFF);
 	if (!tempsense_done(pi))
 		OSL_DELAY(10);
 
@@ -2633,7 +2633,7 @@ void wlc_lcnphy_tx_pu(phy_info_t *pi, bo
 		mod_phy_reg(pi, 0x44c, (0x1 << 12), 1 << 12);
 		mod_phy_reg(pi, 0x44d, (0x1 << 14), 1 << 14);
 
-		wlc_lcnphy_set_trsw_override(pi, TRUE, FALSE);
+		wlc_lcnphy_set_trsw_override(pi, true, FALSE);
 
 		mod_phy_reg(pi, 0x44d, (0x1 << 2), 0 << 2);
 		mod_phy_reg(pi, 0x44c, (0x1 << 2), 1 << 2);
@@ -2741,7 +2741,7 @@ wlc_lcnphy_start_tx_tone(phy_info_t *pi,
 
 	pi->phy_tx_tone_freq = f_kHz;
 
-	wlc_lcnphy_deaf_mode(pi, TRUE);
+	wlc_lcnphy_deaf_mode(pi, true);
 
 	phy_bw = 40;
 	if (pi_lcn->lcnphy_spurmod) {
@@ -2800,7 +2800,7 @@ void wlc_lcnphy_stop_tx_tone(phy_info_t
 		write_phy_reg(pi, 0x942, 0x7);
 		write_phy_reg(pi, 0x93b, 0x2017);
 		write_phy_reg(pi, 0x93c, 0x27c5);
-		wlc_lcnphy_txrx_spur_avoidance_mode(pi, TRUE);
+		wlc_lcnphy_txrx_spur_avoidance_mode(pi, true);
 	}
 
 	playback_status = read_phy_reg(pi, 0x644);
@@ -3143,7 +3143,7 @@ wlc_lcnphy_rx_iq_est(phy_info_t *pi,
 		     u8 wait_time, lcnphy_iq_est_t *iq_est)
 {
 	int wait_count = 0;
-	bool result = TRUE;
+	bool result = true;
 	u8 phybw40;
 	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
 
@@ -3305,7 +3305,7 @@ wlc_lcnphy_rx_iq_cal(phy_info_t *pi, con
 							  iqcomp[iqcomp_sz].a,
 							  (u16)
 							  iqcomp[iqcomp_sz].b);
-				result = TRUE;
+				result = true;
 				break;
 			}
 		}
@@ -3382,7 +3382,7 @@ wlc_lcnphy_rx_iq_cal(phy_info_t *pi, con
 		write_phy_reg(pi, 0x6da, 0xffff);
 		or_phy_reg(pi, 0x6db, 0x3);
 		wlc_lcnphy_set_trsw_override(pi, tx_switch, rx_switch);
-		wlc_lcnphy_rx_gain_override_enable(pi, TRUE);
+		wlc_lcnphy_rx_gain_override_enable(pi, true);
 
 		tia_gain = 8;
 		rx_pwr_threshold = 950;
@@ -3457,7 +3457,7 @@ static void wlc_lcnphy_glacial_timer_bas
 	    (0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
 	if (!suspend)
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
-	wlc_lcnphy_deaf_mode(pi, TRUE);
+	wlc_lcnphy_deaf_mode(pi, true);
 	pi->phy_lastcal = pi->sh->now;
 	pi->phy_forcecal = FALSE;
 	index = pi_lcn->lcnphy_current_index;
@@ -3502,7 +3502,7 @@ static void wlc_lcnphy_periodic_cal(phy_
 		wlapi_bmac_write_shm(pi->sh->physhim, M_CTS_DURATION, 10000);
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
 	}
-	wlc_lcnphy_deaf_mode(pi, TRUE);
+	wlc_lcnphy_deaf_mode(pi, true);
 
 	wlc_lcnphy_txpwrtbl_iqlo_cal(pi);
 
@@ -3510,9 +3510,9 @@ static void wlc_lcnphy_periodic_cal(phy_
 	rx_iqcomp_sz = ARRAY_SIZE(lcnphy_rx_iqcomp_table_rev0);
 
 	if (LCNREV_IS(pi->pubpi.phy_rev, 1))
-		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, TRUE, FALSE, 1, 40);
+		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, true, FALSE, 1, 40);
 	else
-		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, TRUE, FALSE, 1, 127);
+		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, true, FALSE, 1, 127);
 
 	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi)) {
 
@@ -3654,7 +3654,7 @@ static void wlc_lcnphy_set_chanspec_twea
 
 		si_pmu_pllupd(pi->sh->sih);
 		write_phy_reg(pi, 0x942, 0);
-		wlc_lcnphy_txrx_spur_avoidance_mode(pi, TRUE);
+		wlc_lcnphy_txrx_spur_avoidance_mode(pi, true);
 
 		pi_lcn->lcnphy_spurmod = 0;
 		mod_phy_reg(pi, 0x424, (0xff << 8), (0x1f) << 8);
@@ -4836,7 +4836,7 @@ static bool wlc_phy_txpwr_srom_read_lcnp
 		}
 	}
 
-	return TRUE;
+	return true;
 }
 
 void wlc_2064_vco_cal(phy_info_t *pi)
@@ -5065,8 +5065,8 @@ bool wlc_phy_attach_lcnphy(phy_info_t *p
 	pi_lcn = pi->u.pi_lcnphy;
 
 	if ((0 == (pi->sh->boardflags & BFL_NOPA)) && !NORADIO_ENAB(pi->pubpi)) {
-		pi->hwpwrctrl = TRUE;
-		pi->hwpwrctrl_capable = TRUE;
+		pi->hwpwrctrl = true;
+		pi->hwpwrctrl_capable = true;
 	}
 
 	pi->xtalfreq = si_alp_clock(pi->sh->sih);
@@ -5089,17 +5089,17 @@ bool wlc_phy_attach_lcnphy(phy_info_t *p
 
 	if ((pi->sh->boardflags & BFL_FEM) && (LCNREV_IS(pi->pubpi.phy_rev, 1))) {
 		if (pi_lcn->lcnphy_tempsense_option == 3) {
-			pi->hwpwrctrl = TRUE;
-			pi->hwpwrctrl_capable = TRUE;
+			pi->hwpwrctrl = true;
+			pi->hwpwrctrl_capable = true;
 			pi->temppwrctrl_capable = FALSE;
 		} else {
 			pi->hwpwrctrl = FALSE;
 			pi->hwpwrctrl_capable = FALSE;
-			pi->temppwrctrl_capable = TRUE;
+			pi->temppwrctrl_capable = true;
 		}
 	}
 
-	return TRUE;
+	return true;
 }
 
 static void wlc_lcnphy_set_rx_gain(phy_info_t *pi, u32 gain)
@@ -5129,7 +5129,7 @@ static void wlc_lcnphy_set_rx_gain(phy_i
 		mod_phy_reg(pi, 0x4b1, (0x3 << 11), lna1 << 11);
 		mod_phy_reg(pi, 0x4e6, (0x3 << 3), lna1 << 3);
 	}
-	wlc_lcnphy_rx_gain_override_enable(pi, TRUE);
+	wlc_lcnphy_rx_gain_override_enable(pi, true);
 }
 
 static u32 wlc_lcnphy_get_receive_power(phy_info_t *pi, s32 *gain_index)
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -14196,7 +14196,7 @@ bool wlc_phy_bist_check_phy(wlc_phy_t *p
 	u32 phybist0, phybist1, phybist2, phybist3, phybist4;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 16))
-		return TRUE;
+		return true;
 
 	phybist0 = read_phy_reg(pi, 0x0e);
 	phybist1 = read_phy_reg(pi, 0x0f);
@@ -14206,7 +14206,7 @@ bool wlc_phy_bist_check_phy(wlc_phy_t *p
 
 	if ((phybist0 == 0) && (phybist1 == 0x4000) && (phybist2 == 0x1fe0) &&
 	    (phybist3 == 0) && (phybist4 == 0)) {
-		return TRUE;
+		return true;
 	}
 
 	return FALSE;
@@ -14451,21 +14451,21 @@ bool wlc_phy_attach_nphy(phy_info_t *pi)
 	uint i;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 6)) {
-		pi->phyhang_avoid = TRUE;
+		pi->phyhang_avoid = true;
 	}
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 7)) {
 
-		pi->nphy_gband_spurwar_en = TRUE;
+		pi->nphy_gband_spurwar_en = true;
 
 		if (pi->sh->boardflags2 & BFL2_SPUR_WAR) {
-			pi->nphy_aband_spurwar_en = TRUE;
+			pi->nphy_aband_spurwar_en = true;
 		}
 	}
 	if (NREV_GE(pi->pubpi.phy_rev, 6) && NREV_LT(pi->pubpi.phy_rev, 7)) {
 
 		if (pi->sh->boardflags2 & BFL2_2G_SPUR_WAR) {
-			pi->nphy_gband_spurwar2_en = TRUE;
+			pi->nphy_gband_spurwar2_en = true;
 		}
 	}
 
@@ -14482,7 +14482,7 @@ bool wlc_phy_attach_nphy(phy_info_t *pi)
 	pi->mphase_cal_phase_id = MPHASE_CAL_STATE_IDLE;
 	pi->mphase_txcal_numcmds = MPHASE_TXCAL_NUMCMDS;
 
-	pi->nphy_gain_boost = TRUE;
+	pi->nphy_gain_boost = true;
 	pi->nphy_elna_gain_config = FALSE;
 	pi->radio_is_on = FALSE;
 
@@ -14492,7 +14492,7 @@ bool wlc_phy_attach_nphy(phy_info_t *pi)
 
 	wlc_phy_txpwrctrl_config_nphy(pi);
 	if (pi->nphy_txpwrctrl == PHY_TPC_HW_ON)
-		pi->hwpwrctrl_capable = TRUE;
+		pi->hwpwrctrl_capable = true;
 
 	pi->pi_fptr.init = wlc_phy_init_nphy;
 	pi->pi_fptr.calinit = wlc_phy_cal_init_nphy;
@@ -14502,7 +14502,7 @@ bool wlc_phy_attach_nphy(phy_info_t *pi)
 	if (!wlc_phy_txpwr_srom_read_nphy(pi))
 		return FALSE;
 
-	return TRUE;
+	return true;
 }
 
 static void wlc_phy_txpwrctrl_config_nphy(phy_info_t *pi)
@@ -14510,7 +14510,7 @@ static void wlc_phy_txpwrctrl_config_nph
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		pi->nphy_txpwrctrl = PHY_TPC_HW_ON;
-		pi->phy_5g_pwrgain = TRUE;
+		pi->phy_5g_pwrgain = true;
 		return;
 	}
 
@@ -14522,7 +14522,7 @@ static void wlc_phy_txpwrctrl_config_nph
 		pi->nphy_txpwrctrl = PHY_TPC_HW_ON;
 	else if ((pi->sh->sromrev >= 4)
 		 && (pi->sh->boardflags2 & BFL2_5G_PWRGAIN))
-		pi->phy_5g_pwrgain = TRUE;
+		pi->phy_5g_pwrgain = true;
 }
 
 void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t *pi)
@@ -14884,7 +14884,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 			target_gain = wlc_phy_get_tx_gain_nphy(pi);
 
 			if (pi->antsel_type == ANTSEL_2x3)
-				wlc_phy_antsel_init((wlc_phy_t *) pi, TRUE);
+				wlc_phy_antsel_init((wlc_phy_t *) pi, true);
 
 			if (pi->nphy_perical != PHY_PERICAL_MPHASE) {
 				wlc_phy_rssi_cal_nphy(pi);
@@ -14903,7 +14903,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 				}
 
 				if (wlc_phy_cal_txiqlo_nphy
-				    (pi, target_gain, TRUE, FALSE) == BCME_OK) {
+				    (pi, target_gain, true, FALSE) == BCME_OK) {
 					if (wlc_phy_cal_rxiq_nphy
 					    (pi, target_gain, 2,
 					     FALSE) == BCME_OK) {
@@ -14944,7 +14944,7 @@ static void wlc_phy_update_mimoconfig_np
 	u16 val;
 
 	if (preamble == WLC_N_PREAMBLE_GF) {
-		gf_preamble = TRUE;
+		gf_preamble = true;
 	}
 
 	val = read_phy_reg(pi, 0xed);
@@ -15013,14 +15013,14 @@ void wlc_phy_stf_chain_upd_nphy(phy_info
 
 	if (pi->nphy_txrx_chain == WLC_N_TXRX_CHAIN0) {
 		txrx_chain = NPHY_RfseqCoreActv_TxRxChain0;
-		CoreActv_override = TRUE;
+		CoreActv_override = true;
 
 		if (NREV_LE(pi->pubpi.phy_rev, 2)) {
 			and_phy_reg(pi, 0xa0, ~0x20);
 		}
 	} else if (pi->nphy_txrx_chain == WLC_N_TXRX_CHAIN1) {
 		txrx_chain = NPHY_RfseqCoreActv_TxRxChain1;
-		CoreActv_override = TRUE;
+		CoreActv_override = true;
 
 		if (NREV_LE(pi->pubpi.phy_rev, 2)) {
 			or_phy_reg(pi, 0xa0, 0x20);
@@ -15059,7 +15059,7 @@ void wlc_phy_rxcore_setstate_nphy(wlc_ph
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	regval = read_phy_reg(pi, 0xa2);
 	regval &= ~(0xf << 4);
@@ -15385,7 +15385,7 @@ static void wlc_phy_workarounds_nphy(phy
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (!ISSIM_ENAB(pi->sh->sih)) {
 		or_phy_reg(pi, 0xb1, NPHY_IQFlip_ADC1 | NPHY_IQFlip_ADC2);
@@ -15483,7 +15483,7 @@ static void wlc_phy_workarounds_nphy(phy
 					rccal_tx40_11n_bcap = 0xc;
 					rccal_tx40_11n_scap = 0xc;
 
-					rccal_ovrd = TRUE;
+					rccal_ovrd = true;
 
 				} else if ((pi->pubpi.radiorev == 7)
 					   || (pi->pubpi.radiorev == 8)) {
@@ -15503,7 +15503,7 @@ static void wlc_phy_workarounds_nphy(phy
 						rccal_tx40_11n_scap = 0xf;
 					}
 
-					rccal_ovrd = TRUE;
+					rccal_ovrd = true;
 				}
 			}
 
@@ -15529,7 +15529,7 @@ static void wlc_phy_workarounds_nphy(phy
 				rccal_tx40_11n_bcap = 0x13;
 				rccal_tx40_11n_scap = 0x11;
 
-				rccal_ovrd = TRUE;
+				rccal_ovrd = true;
 			}
 		}
 
@@ -17236,7 +17236,7 @@ static void wlc_phy_adjust_lnagaintbl_np
 	u16 regval[4];
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (pi->nphy_gain_boost) {
 		if ((CHSPEC_IS2G(pi->radio_chanspec))) {
@@ -17314,7 +17314,7 @@ void wlc_phy_switch_radio_nphy(phy_info_
 			wlc_phy_radio_postinit_2055(pi);
 		}
 
-		pi->radio_is_on = TRUE;
+		pi->radio_is_on = true;
 
 	} else {
 
@@ -17783,7 +17783,7 @@ wlc_phy_chan2freq_nphy(phy_info_t *pi, u
 	}
 
 	*f = freq;
-	return TRUE;
+	return true;
 
  fail:
 	*f = WL_CHAN_FREQ_RANGE_2G;
@@ -18639,7 +18639,7 @@ wlc_phy_adjust_rx_analpfbw_nphy(phy_info
 						((pi->nphy_rccal_value +
 						  reduction_factr) | 0x80));
 
-				pi->nphy_anarxlpf_adjusted = TRUE;
+				pi->nphy_anarxlpf_adjusted = true;
 			}
 		} else {
 			if (pi->nphy_anarxlpf_adjusted) {
@@ -18700,7 +18700,7 @@ wlc_phy_adjust_min_noisevar_nphy(phy_inf
 			pi->nphy_saved_noisevars.bufcount++;
 		}
 
-		pi->nphy_noisevars_adjusted = TRUE;
+		pi->nphy_noisevars_adjusted = true;
 	}
 }
 
@@ -18730,7 +18730,7 @@ static void wlc_phy_adjust_crsminpwr_nph
 				regval |= (u16) minpwr;
 				write_phy_reg(pi, 0x283, regval);
 
-				pi->nphy_crsminpwr_adjusted = TRUE;
+				pi->nphy_crsminpwr_adjusted = true;
 			}
 		} else {
 			if (pi->nphy_crsminpwr_adjusted) {
@@ -18805,7 +18805,7 @@ static void wlc_phy_spurwar_nphy(phy_inf
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		if (pi->phyhang_avoid)
-			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+			wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 		cur_channel = CHSPEC_CHANNEL(pi->radio_chanspec);
 
@@ -18842,56 +18842,56 @@ static void wlc_phy_spurwar_nphy(phy_inf
 					nphy_adj_tone_id_buf[1] = 58;
 					nphy_adj_noise_var_buf[0] = 0x22f;
 					nphy_adj_noise_var_buf[1] = 0x25f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 4:
 					nphy_adj_tone_id_buf[0] = 41;
 					nphy_adj_tone_id_buf[1] = 42;
 					nphy_adj_noise_var_buf[0] = 0x22f;
 					nphy_adj_noise_var_buf[1] = 0x25f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 5:
 					nphy_adj_tone_id_buf[0] = 25;
 					nphy_adj_tone_id_buf[1] = 26;
 					nphy_adj_noise_var_buf[0] = 0x24f;
 					nphy_adj_noise_var_buf[1] = 0x25f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 6:
 					nphy_adj_tone_id_buf[0] = 9;
 					nphy_adj_tone_id_buf[1] = 10;
 					nphy_adj_noise_var_buf[0] = 0x22f;
 					nphy_adj_noise_var_buf[1] = 0x24f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 7:
 					nphy_adj_tone_id_buf[0] = 121;
 					nphy_adj_tone_id_buf[1] = 122;
 					nphy_adj_noise_var_buf[0] = 0x18f;
 					nphy_adj_noise_var_buf[1] = 0x24f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 8:
 					nphy_adj_tone_id_buf[0] = 105;
 					nphy_adj_tone_id_buf[1] = 106;
 					nphy_adj_noise_var_buf[0] = 0x22f;
 					nphy_adj_noise_var_buf[1] = 0x25f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 9:
 					nphy_adj_tone_id_buf[0] = 89;
 					nphy_adj_tone_id_buf[1] = 90;
 					nphy_adj_noise_var_buf[0] = 0x22f;
 					nphy_adj_noise_var_buf[1] = 0x24f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				case 10:
 					nphy_adj_tone_id_buf[0] = 73;
 					nphy_adj_tone_id_buf[1] = 74;
 					nphy_adj_noise_var_buf[0] = 0x22f;
 					nphy_adj_noise_var_buf[1] = 0x24f;
-					isAdjustNoiseVar = TRUE;
+					isAdjustNoiseVar = true;
 					break;
 				default:
 					isAdjustNoiseVar = FALSE;
@@ -19083,7 +19083,7 @@ wlc_phy_chanspec_nphy_setup(phy_info_t *
 		} else {
 			wlapi_bmac_core_phypll_ctl(pi->sh->physhim, FALSE);
 			si_pmu_spuravoid(pi->sh->sih, pi->sh->osh, spuravoid);
-			wlapi_bmac_core_phypll_ctl(pi->sh->physhim, TRUE);
+			wlapi_bmac_core_phypll_ctl(pi->sh->physhim, true);
 		}
 
 		if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID) ||
@@ -19218,7 +19218,7 @@ static void wlc_phy_savecal_nphy(phy_inf
 	u16 *txcal_radio_regs = NULL;
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (CHSPEC_IS2G(pi->radio_chanspec)) {
 
@@ -19631,7 +19631,7 @@ u16 wlc_phy_classifier_nphy(phy_info_t *
 	if (D11REV_IS(pi->sh->corerev, 16)) {
 		suspended =
 		    (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) ?
-		    FALSE : TRUE;
+		    FALSE : true;
 		if (!suspended)
 			wlapi_suspend_mac_and_wait(pi->sh->physhim);
 	}
@@ -19719,7 +19719,7 @@ wlc_phy_set_rfseq_nphy(phy_info_t *pi, u
 	ASSERT(len <= 16);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	t1_offset = cmd << 4;
 	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, len, t1_offset, 8,
@@ -22420,7 +22420,7 @@ wlc_phy_loadsampletable_nphy(phy_info_t
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	for (t = 0; t < num_samps; t++) {
 		data_buf[t] = ((((unsigned int)tone_buf[t].i) & 0x3ff) << 10) |
@@ -22448,7 +22448,7 @@ wlc_phy_runsamples_nphy(phy_info_t *pi,
 	    lpf_bw_ctl_miscreg4;
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	phy_bw = 20;
 	if (CHSPEC_IS40(pi->radio_chanspec))
@@ -22470,7 +22470,7 @@ wlc_phy_runsamples_nphy(phy_info_t *pi,
 							  (pi, 0), 0, 0,
 							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
 
-			pi->nphy_sample_play_lpf_bw_ctl_ovr = TRUE;
+			pi->nphy_sample_play_lpf_bw_ctl_ovr = true;
 
 			lpf_bw_ctl_miscreg3 = read_phy_reg(pi, 0x340) &
 			    (0x7 << 8);
@@ -22530,7 +22530,7 @@ void wlc_phy_stopplayback_nphy(phy_info_
 	u16 bb_mult;
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	playback_status = read_phy_reg(pi, 0xc7);
 	if (playback_status & 0x1) {
@@ -22575,7 +22575,7 @@ nphy_txgains_t wlc_phy_get_tx_gain_nphy(
 
 	if (pi->nphy_txpwrctrl == PHY_TPC_HW_OFF) {
 		if (pi->phyhang_avoid)
-			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+			wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16,
 					curr_gain);
@@ -23524,8 +23524,8 @@ static void wlc_phy_internal_cal_txgain_
 
 	pi->nphy_txcal_pwr_idx[0] = pi->nphy_cal_orig_pwr_idx[0];
 	pi->nphy_txcal_pwr_idx[1] = pi->nphy_cal_orig_pwr_idx[0];
-	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_cal_orig_pwr_idx[0], TRUE);
-	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_cal_orig_pwr_idx[1], TRUE);
+	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_cal_orig_pwr_idx[0], true);
+	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_cal_orig_pwr_idx[1], true);
 
 	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16,
 				txcal_gain);
@@ -23571,7 +23571,7 @@ static void wlc_phy_precal_txgain_nphy(p
 							 txcal_index_2057_rev5n7,
 							 FALSE);
 			}
-			save_bbmult = TRUE;
+			save_bbmult = true;
 
 		} else if (NREV_LT(pi->pubpi.phy_rev, 5)) {
 			wlc_phy_cal_txgainctrl_nphy(pi, 11, FALSE);
@@ -23581,8 +23581,8 @@ static void wlc_phy_precal_txgain_nphy(p
 				wlc_phy_txpwr_index_nphy(pi, 3,
 							 pi->
 							 nphy_txcal_pwr_idx[0],
-							 TRUE);
-				save_bbmult = TRUE;
+							 true);
+				save_bbmult = true;
 			}
 
 		} else if (NREV_IS(pi->pubpi.phy_rev, 5)) {
@@ -23595,12 +23595,12 @@ static void wlc_phy_precal_txgain_nphy(p
 					pi->nphy_txcal_pwr_idx[1] = 80;
 					wlc_phy_txpwr_index_nphy(pi, 3, 80,
 								 FALSE);
-					save_bbmult = TRUE;
+					save_bbmult = true;
 				}
 			} else {
 
 				wlc_phy_internal_cal_txgain_nphy(pi);
-				save_bbmult = TRUE;
+				save_bbmult = true;
 			}
 
 		} else if (NREV_IS(pi->pubpi.phy_rev, 6)) {
@@ -23615,7 +23615,7 @@ static void wlc_phy_precal_txgain_nphy(p
 			} else {
 
 				wlc_phy_internal_cal_txgain_nphy(pi);
-				save_bbmult = TRUE;
+				save_bbmult = true;
 			}
 		}
 
@@ -23659,11 +23659,11 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 		freq_test = 2500;
 	}
 
-	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_cal_orig_pwr_idx[0], TRUE);
-	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_cal_orig_pwr_idx[1], TRUE);
+	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_cal_orig_pwr_idx[0], true);
+	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_cal_orig_pwr_idx[1], true);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	phyhang_avoid_state = pi->phyhang_avoid;
 	pi->phyhang_avoid = FALSE;
@@ -23748,7 +23748,7 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 			}
 
 			wlc_phy_txpwr_index_nphy(pi, (1 << core),
-						 (u8) txpwrindex, TRUE);
+						 (u8) txpwrindex, true);
 		}
 
 		pi->nphy_txcal_pwr_idx[core] = (u8) txpwrindex;
@@ -23779,8 +23779,8 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 		}
 	}
 
-	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_txcal_pwr_idx[0], TRUE);
-	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_txcal_pwr_idx[1], TRUE);
+	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_txcal_pwr_idx[0], true);
+	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_txcal_pwr_idx[1], true);
 
 	wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &pi->nphy_txcal_bbmult);
 
@@ -23843,7 +23843,7 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 {
 	nphy_txgains_t target_gain;
 	u8 tx_pwr_ctrl_state;
-	bool fullcal = TRUE;
+	bool fullcal = true;
 	bool restore_tx_gain = FALSE;
 	bool mphase;
 
@@ -23864,7 +23864,7 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 
 	if (pi->cal_type_override != PHY_PERICAL_AUTO) {
 		fullcal =
-		    (pi->cal_type_override == PHY_PERICAL_FULL) ? TRUE : FALSE;
+		    (pi->cal_type_override == PHY_PERICAL_FULL) ? true : FALSE;
 	}
 
 	if ((pi->mphase_cal_phase_id > MPHASE_CAL_STATE_INIT)) {
@@ -23901,7 +23901,7 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 	wlc_phy_txpwrctrl_enable_nphy(pi, PHY_TPC_HW_OFF);
 
 	if (pi->antsel_type == ANTSEL_2x3)
-		wlc_phy_antsel_init((wlc_phy_t *) pi, TRUE);
+		wlc_phy_antsel_init((wlc_phy_t *) pi, true);
 
 	mphase = (pi->mphase_cal_phase_id != MPHASE_CAL_STATE_IDLE);
 	if (!mphase) {
@@ -23909,14 +23909,14 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 			wlc_phy_precal_txgain_nphy(pi);
 			pi->nphy_cal_target_gain = wlc_phy_get_tx_gain_nphy(pi);
-			restore_tx_gain = TRUE;
+			restore_tx_gain = true;
 
 			target_gain = pi->nphy_cal_target_gain;
 		}
 		if (BCME_OK ==
 		    wlc_phy_cal_txiqlo_nphy(pi, target_gain, fullcal, mphase)) {
 			if (PHY_IPA(pi))
-				wlc_phy_a4(pi, TRUE);
+				wlc_phy_a4(pi, true);
 
 			wlc_phyreg_exit((wlc_phy_t *) pi);
 			wlapi_enable_mac(pi->sh->physhim);
@@ -23976,11 +23976,11 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 		case MPHASE_CAL_STATE_TXPHASE4:
 		case MPHASE_CAL_STATE_TXPHASE5:
 			if ((pi->radar_percal_mask & 0x10) != 0)
-				pi->nphy_rxcal_active = TRUE;
+				pi->nphy_rxcal_active = true;
 
 			if (wlc_phy_cal_txiqlo_nphy
 			    (pi, pi->nphy_cal_target_gain, fullcal,
-			     TRUE) != BCME_OK) {
+			     true) != BCME_OK) {
 
 				wlc_phy_cal_perical_mphase_reset(pi);
 				break;
@@ -23997,17 +23997,17 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 
 		case MPHASE_CAL_STATE_PAPDCAL:
 			if ((pi->radar_percal_mask & 0x2) != 0)
-				pi->nphy_rxcal_active = TRUE;
+				pi->nphy_rxcal_active = true;
 
 			if (PHY_IPA(pi)) {
-				wlc_phy_a4(pi, TRUE);
+				wlc_phy_a4(pi, true);
 			}
 			pi->mphase_cal_phase_id++;
 			break;
 
 		case MPHASE_CAL_STATE_RXCAL:
 			if ((pi->radar_percal_mask & 0x1) != 0)
-				pi->nphy_rxcal_active = TRUE;
+				pi->nphy_rxcal_active = true;
 			if (wlc_phy_cal_rxiq_nphy(pi, target_gain,
 						  (pi->first_cal_after_assoc ||
 						   (pi->cal_type_override ==
@@ -24021,14 +24021,14 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 
 		case MPHASE_CAL_STATE_RSSICAL:
 			if ((pi->radar_percal_mask & 0x4) != 0)
-				pi->nphy_rxcal_active = TRUE;
+				pi->nphy_rxcal_active = true;
 			wlc_phy_txpwrctrl_coeff_setup_nphy(pi);
 			wlc_phy_rssi_cal_nphy(pi);
 
 			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 				wlc_phy_radio205x_vcocal_nphy(pi);
 			}
-			restore_tx_gain = TRUE;
+			restore_tx_gain = true;
 
 			if (pi->first_cal_after_assoc) {
 				pi->mphase_cal_phase_id++;
@@ -24040,7 +24040,7 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 
 		case MPHASE_CAL_STATE_IDLETSSI:
 			if ((pi->radar_percal_mask & 0x8) != 0)
-				pi->nphy_rxcal_active = TRUE;
+				pi->nphy_rxcal_active = true;
 
 			if (pi->first_cal_after_assoc) {
 				pi->first_cal_after_assoc = FALSE;
@@ -24178,7 +24178,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t *pi,
 		0x9423, 0x9323, 0x9073, 0x9256, 0x9045, 0x9223
 	};
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (NREV_GE(pi->pubpi.phy_rev, 4)) {
 		phyhang_avoid_state = pi->phyhang_avoid;
@@ -24268,7 +24268,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t *pi,
 				}
 			} else {
 
-				fullcal = TRUE;
+				fullcal = true;
 
 				if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 					tbl_ptr =
@@ -24332,7 +24332,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t *pi,
 				if (!ladder_updated[core_no]) {
 					wlc_phy_update_txcal_ladder_nphy(pi,
 									 core_no);
-					ladder_updated[core_no] = TRUE;
+					ladder_updated[core_no] = true;
 				}
 			}
 
@@ -24423,7 +24423,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t *pi,
 						tbl_len, 96, 16,
 						pi->nphy_txiqlocal_bestc);
 
-			pi->nphy_txiqlocal_coeffsvalid = TRUE;
+			pi->nphy_txiqlocal_coeffsvalid = true;
 			pi->nphy_txiqlocal_chanspec = pi->radio_chanspec;
 		} else {
 			tbl_len = ARRAY_SIZE(pi->mphase_txcal_bestcoeffs);
@@ -25430,7 +25430,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 
 		case NPHY_RXCAL_GAIN_UP:
 			if (curr_pwr > thresh_pwr) {
-				gainctrl_done = TRUE;
+				gainctrl_done = true;
 				optim_pwr = prev_pwr;
 				optim_gaintbl_index = prev_gaintbl_index;
 			} else {
@@ -25444,7 +25444,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 				prev_gaintbl_index = curr_gaintbl_index;
 				curr_gaintbl_index--;
 			} else {
-				gainctrl_done = TRUE;
+				gainctrl_done = true;
 				optim_pwr = curr_pwr;
 				optim_gaintbl_index = curr_gaintbl_index;
 			}
@@ -25456,7 +25456,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 
 		if ((curr_gaintbl_index < 0) ||
 		    (curr_gaintbl_index > NPHY_IPA_RXCAL_MAXGAININDEX)) {
-			gainctrl_done = TRUE;
+			gainctrl_done = true;
 			optim_pwr = curr_pwr;
 			optim_gaintbl_index = prev_gaintbl_index;
 		} else {
@@ -25781,7 +25781,7 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *p
 	orig_BBConfig = read_phy_reg(pi, 0x01);
 	mod_phy_reg(pi, 0x01, (0x1 << 15), 0);
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (NREV_GE(pi->pubpi.phy_rev, 4)) {
 		phyhang_avoid_state = pi->phyhang_avoid;
@@ -25803,7 +25803,7 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *p
 	for (rx_core = 0; rx_core < pi->pubpi.phy_corenum; rx_core++) {
 
 		skip_rxiqcal =
-		    ((rxcore_state & (1 << rx_core)) == 0) ? TRUE : FALSE;
+		    ((rxcore_state & (1 << rx_core)) == 0) ? true : FALSE;
 
 		wlc_phy_rxcal_physetup_nphy(pi, rx_core);
 
@@ -25942,9 +25942,9 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t *p
 	nphy_iqcal_params_t cal_params[2];
 	u8 phy_bw;
 	int bcmerror = BCME_OK;
-	bool first_playtone = TRUE;
+	bool first_playtone = true;
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (NREV_LT(pi->pubpi.phy_rev, 2)) {
 
@@ -26082,13 +26082,13 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t *p
 									  nphy_rxcalparams
 									  &
 									  0xffff),
-								0, 0, TRUE);
+								0, 0, true);
 				first_playtone = FALSE;
 			} else {
 				phy_bw =
 				    (CHSPEC_IS40(pi->radio_chanspec)) ? 40 : 20;
 				wlc_phy_runsamples_nphy(pi, phy_bw * 8, 0xffff,
-							0, 0, 0, TRUE);
+							0, 0, 0, true);
 			}
 
 			if (bcmerror == BCME_OK) {
@@ -26790,7 +26790,7 @@ wlc_phy_a2_nphy(phy_info_t *pi, nphy_ipa
 	ASSERT((cal_mode == CAL_FULL) || (cal_mode == CAL_GCTRL)
 	       || (cal_mode == CAL_SOFT));
 	phy_a6 = ((cal_mode == CAL_GCTRL)
-		  || (cal_mode == CAL_SOFT)) ? TRUE : FALSE;
+		  || (cal_mode == CAL_SOFT)) ? true : FALSE;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 
@@ -27079,7 +27079,7 @@ static u8 wlc_phy_a3_nphy(phy_info_t *pi
 	bool phy_a3;
 	nphy_ipa_txcalgains_t phy_a4;
 	bool phy_a5 = FALSE;
-	bool phy_a6 = TRUE;
+	bool phy_a6 = true;
 	s32 phy_a7, phy_a8;
 	u32 phy_a9;
 	int phy_a10;
@@ -27089,7 +27089,7 @@ static u8 wlc_phy_a3_nphy(phy_info_t *pi
 	u8 phy_a14;
 	u8 *phy_a15 = NULL;
 
-	phy_a4.useindex = TRUE;
+	phy_a4.useindex = true;
 	phy_a12 = start_gain;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -27154,7 +27154,7 @@ static u8 wlc_phy_a3_nphy(phy_info_t *pi
 				if (!phy_a3) {
 					phy_a12 -= (u8) phy_a1;
 				}
-				phy_a11 = TRUE;
+				phy_a11 = true;
 				break;
 			}
 
@@ -27169,7 +27169,7 @@ static u8 wlc_phy_a3_nphy(phy_info_t *pi
 				} else {
 					phy_a12 = phy_a13;
 				}
-				phy_a11 = TRUE;
+				phy_a11 = true;
 				break;
 			}
 
@@ -27200,7 +27200,7 @@ static u8 wlc_phy_a3_nphy(phy_info_t *pi
 				if (!phy_a3) {
 					phy_a12 -= (u8) phy_a1;
 				}
-				phy_a11 = TRUE;
+				phy_a11 = true;
 				break;
 			}
 
@@ -27215,7 +27215,7 @@ static u8 wlc_phy_a3_nphy(phy_info_t *pi
 				} else {
 					phy_a12 = 127;
 				}
-				phy_a11 = TRUE;
+				phy_a11 = true;
 				break;
 			}
 
@@ -27259,7 +27259,7 @@ static void wlc_phy_a4(phy_info_t *pi, b
 		wlapi_suspend_mac_and_wait(pi->sh->physhim);
 	}
 
-	wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+	wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	pi->nphy_force_papd_cal = FALSE;
 
@@ -27351,7 +27351,7 @@ static void wlc_phy_a4(phy_info_t *pi, b
 				    pi->nphy_papd_cal_gain_index[phy_b5];
 			}
 		} else {
-			phy_b1[phy_b5].useindex = TRUE;
+			phy_b1[phy_b5].useindex = true;
 			phy_b1[phy_b5].index = 16;
 			phy_b1[phy_b5].index =
 			    wlc_phy_a3_nphy(pi, phy_b1[phy_b5].index, phy_b5);
@@ -27539,7 +27539,7 @@ void wlc_phy_txpwr_fixpower_nphy(phy_inf
 	ASSERT(pi->nphy_txpwrctrl == PHY_TPC_HW_OFF);
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	if (pi->sh->sromrev < 4) {
 		txpi[0] = txpi[1] = 72;
@@ -28205,7 +28205,7 @@ static bool wlc_phy_txpwr_srom_read_nphy
 
 	wlc_phy_txpwr_srom_read_ppr_nphy(pi);
 
-	return TRUE;
+	return true;
 }
 
 void wlc_phy_txpower_recalc_target_nphy(phy_info_t *pi)
@@ -28239,7 +28239,7 @@ static void wlc_phy_txpwrctrl_coeff_setu
 	u32 regval[128];
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	wlc_phy_table_read_nphy(pi, 15, 7, 80, 16, iqloCalbuf);
 
@@ -28494,7 +28494,7 @@ static void wlc_phy_txpwrctrl_pwr_setup_
 	}
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	or_phy_reg(pi, 0x122, (0x1 << 0));
 
@@ -28770,7 +28770,7 @@ void wlc_phy_txpwr_papd_cal_nphy(phy_inf
 		     || ((u32)
 			 ABS(wlc_phy_txpwr_idx_cur_get_nphy(pi, 1) -
 			     pi->nphy_papd_tx_gain_at_last_cal[1]) >= 4))))) {
-		wlc_phy_a4(pi, TRUE);
+		wlc_phy_a4(pi, true);
 	}
 }
 
@@ -28784,7 +28784,7 @@ void wlc_phy_txpwrctrl_enable_nphy(phy_i
 	u16 regval[84];
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	switch (ctrl_type) {
 	case PHY_TPC_HW_OFF:
@@ -28938,7 +28938,7 @@ wlc_phy_txpwr_index_nphy(phy_info_t *pi,
 	u16 regval[2];
 
 	if (pi->phyhang_avoid)
-		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+		wlc_phy_stay_in_carriersearch_nphy(pi, true);
 
 	tx_ind0 = 192;
 	iq_ind0 = 320;
@@ -29225,7 +29225,7 @@ void wlc_nphy_deaf_mode(phy_info_t *pi,
 
 	if (mode) {
 		if (pi->nphy_deaf_count == 0)
-			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+			wlc_phy_stay_in_carriersearch_nphy(pi, true);
 	} else {
 		if (pi->nphy_deaf_count > 0)
 			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
--- a/drivers/staging/brcm80211/sys/wl_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.c
@@ -609,7 +609,7 @@ wl_ops_conf_tx(struct ieee80211_hw *hw,
 		 params->txop, params->cw_min, params->cw_max, params->aifs));
 
 	WL_LOCK(wl);
-	wlc_wme_setparams(wl->wlc, queue, (void *)params, TRUE);
+	wlc_wme_setparams(wl->wlc, queue, (void *)params, true);
 	WL_UNLOCK(wl);
 
 	return 0;
@@ -649,7 +649,7 @@ wl_sta_add(struct ieee80211_hw *hw, stru
 	pktq_init(&scb->scb_ampdu.txq, AMPDU_MAX_SCB_TID,
 		  AMPDU_MAX_SCB_TID * PKTQ_LEN_DEFAULT);
 
-	sta->ht_cap.ht_supported = TRUE;
+	sta->ht_cap.ht_supported = true;
 #ifdef WLC_HIGH_ONLY
 	sta->ht_cap.ampdu_factor = AMPDU_RX_FACTOR_16K;
 #else
@@ -787,7 +787,7 @@ static wl_info_t *wl_attach(u16 vendor,
 	}
 
 	/* Requires pkttag feature */
-	osh = osl_attach(btparam, bustype, TRUE);
+	osh = osl_attach(btparam, bustype, true);
 	ASSERT(osh);
 
 #ifdef WLC_HIGH_ONLY
@@ -1721,7 +1721,7 @@ void BCMFASTPATH wl_intrson(wl_info_t *w
 
 bool wl_alloc_dma_resources(wl_info_t *wl, uint addrwidth)
 {
-	return TRUE;
+	return true;
 }
 
 u32 BCMFASTPATH wl_intrsoff(wl_info_t *wl)
@@ -1834,7 +1834,7 @@ static void BCMFASTPATH wl_dpc(unsigned
 			INT_UNLOCK(wl, flags);
 		}
 
-		wl->resched = wlc_dpc(wl->wlc, TRUE);
+		wl->resched = wlc_dpc(wl->wlc, true);
 	}
 
 	/* wlc_dpc() may bring the driver down */
@@ -1899,7 +1899,7 @@ static void _wl_timer(wl_timer_t *t)
 			t->timer.expires = jiffies + t->ms * HZ / 1000;
 			atomic_inc(&t->wl->callbacks);
 			add_timer(&t->timer);
-			t->set = TRUE;
+			t->set = true;
 		} else
 			t->set = FALSE;
 
@@ -1957,14 +1957,14 @@ void wl_add_timer(wl_info_t *wl, wl_time
 
 	t->ms = ms;
 	t->periodic = (bool) periodic;
-	t->set = TRUE;
+	t->set = true;
 	t->timer.expires = jiffies + ms * HZ / 1000;
 
 	atomic_inc(&wl->callbacks);
 	add_timer(&t->timer);
 }
 
-/* return TRUE if timer successfully deleted, FALSE if still pending */
+/* return true if timer successfully deleted, FALSE if still pending */
 bool wl_del_timer(wl_info_t *wl, wl_timer_t *t)
 {
 	if (t->set) {
@@ -1975,7 +1975,7 @@ bool wl_del_timer(wl_info_t *wl, wl_time
 		atomic_dec(&wl->callbacks);
 	}
 
-	return TRUE;
+	return true;
 }
 
 void wl_free_timer(wl_info_t *wl, wl_timer_t *t)
@@ -2081,7 +2081,7 @@ static int BCMFASTPATH wl_start(struct s
 	wl->txq_tail = skb;
 
 	if (wl->txq_dispatched == FALSE) {
-		wl->txq_dispatched = TRUE;
+		wl->txq_dispatched = true;
 
 		if (schedule_work(&wl->txq_task.work)) {
 			atomic_inc(&wl->callbacks);
@@ -2153,7 +2153,7 @@ static void wl_txq_free(wl_info_t *wl)
 	while (wl->txq_head) {
 		skb = wl->txq_head;
 		wl->txq_head = skb->prev;
-		PKTFREE(wl->osh, skb, TRUE);
+		PKTFREE(wl->osh, skb, true);
 	}
 
 	wl->txq_tail = NULL;
@@ -2224,7 +2224,7 @@ static void wl_rpcq_add(wl_info_t *wl, r
 	wl->rpcq_tail = buf;
 
 	if (wl->rpcq_dispatched == FALSE) {
-		wl->rpcq_dispatched = TRUE;
+		wl->rpcq_dispatched = true;
 		wl_schedule_task(wl, wl_rpcq_dispatch, wl);
 	}
 
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -188,7 +188,7 @@ ampdu_info_t *wlc_ampdu_attach(wlc_info_
 	ampdu->wlc = wlc;
 
 	for (i = 0; i < AMPDU_MAX_SCB_TID; i++)
-		ampdu->ini_enable[i] = TRUE;
+		ampdu->ini_enable[i] = true;
 	/* Disable ampdu for VO by default */
 	ampdu->ini_enable[PRIO_8021D_VO] = FALSE;
 	ampdu->ini_enable[PRIO_8021D_NC] = FALSE;
@@ -335,7 +335,7 @@ static void wlc_ffpld_init(ampdu_info_t
 static int wlc_ffpld_check_txfunfl(wlc_info_t *wlc, int fid)
 {
 	ampdu_info_t *ampdu = wlc->ampdu;
-	u32 phy_rate = MCS_RATE(FFPLD_MAX_MCS, TRUE, FALSE);
+	u32 phy_rate = MCS_RATE(FFPLD_MAX_MCS, true, FALSE);
 	u32 txunfl_ratio;
 	u8 max_mpdu;
 	u32 current_ampdu_cnt = 0;
@@ -463,7 +463,7 @@ static void wlc_ffpld_calc_mcs2ampdu_tab
 	/* note : we divide/multiply by 100 to avoid integer overflows */
 	max_mpdu =
 	    min_t(u8, fifo->mcs2ampdu_table[FFPLD_MAX_MCS], AMPDU_NUM_MPDU_LEGACY);
-	phy_rate = MCS_RATE(FFPLD_MAX_MCS, TRUE, FALSE);
+	phy_rate = MCS_RATE(FFPLD_MAX_MCS, true, FALSE);
 	dma_rate =
 	    (((phy_rate / 100) *
 	      (max_mpdu * FFPLD_MPDU_SIZE - fifo->ampdu_pld_size))
@@ -474,7 +474,7 @@ static void wlc_ffpld_calc_mcs2ampdu_tab
 	dma_rate = dma_rate >> 7;
 	for (i = 0; i < FFPLD_MAX_MCS; i++) {
 		/* shifting to keep it within integer range */
-		phy_rate = MCS_RATE(i, TRUE, FALSE) >> 7;
+		phy_rate = MCS_RATE(i, true, FALSE) >> 7;
 		if (phy_rate > dma_rate) {
 			tmp = ((fifo->ampdu_pld_size * phy_rate) /
 			       ((phy_rate - dma_rate) * FFPLD_MPDU_SIZE)) + 1;
@@ -514,7 +514,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 	u8 rts_preamble_type = WLC_LONG_PREAMBLE;
 	u8 rts_fbr_preamble_type = WLC_LONG_PREAMBLE;
 
-	bool rr = TRUE, fbr = FALSE;
+	bool rr = true, fbr = FALSE;
 	uint i, count = 0, fifo, seg_cnt = 0;
 	u16 plen, len, seq = 0, mcl, mch, index, frameid, dma_len = 0;
 	u32 ampdu_len, maxlen = 0;
@@ -618,11 +618,11 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 		/*  Handle retry limits */
 		if (txrate[0].count <= rr_retry_limit) {
 			txrate[0].count++;
-			rr = TRUE;
+			rr = true;
 			fbr = FALSE;
 			ASSERT(!fbr);
 		} else {
-			fbr = TRUE;
+			fbr = true;
 			rr = FALSE;
 			txrate[1].count++;
 		}
@@ -651,11 +651,11 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 			fc = ltoh16(rts->fc);
 			if ((fc & FC_KIND_MASK) == FC_RTS) {
 				mcl |= TXC_SENDRTS;
-				use_rts = TRUE;
+				use_rts = true;
 			}
 			if ((fc & FC_KIND_MASK) == FC_CTS) {
 				mcl |= TXC_SENDCTS;
-				use_cts = TRUE;
+				use_cts = true;
 			}
 		} else {
 			mcl |= (TXC_AMPDU_MIDDLE << TXC_AMPDU_SHIFT);
@@ -739,7 +739,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 
 		/* if (first mpdu for host agg) */
 		/* test whether to add more */
-		if ((MCS_RATE(mcs, TRUE, FALSE) >= f->dmaxferrate) &&
+		if ((MCS_RATE(mcs, true, FALSE) >= f->dmaxferrate) &&
 		    (count == f->mcs2ampdu_table[mcs])) {
 			WL_AMPDU_ERR(("wl%d: PR 37644: stopping ampdu at %d for mcs %d", wlc->pub->unit, count, mcs));
 			break;
@@ -831,7 +831,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 		}
 
 		/* set the preload length */
-		if (MCS_RATE(mcs, TRUE, FALSE) >= f->dmaxferrate) {
+		if (MCS_RATE(mcs, true, FALSE) >= f->dmaxferrate) {
 			dma_len = min(dma_len, f->ampdu_pld_size);
 			txh->PreloadSize = htol16(dma_len);
 		} else
@@ -855,14 +855,14 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 			    wlc_compute_rtscts_dur(wlc, use_cts, rts_rspec,
 						   rspec, rts_preamble_type,
 						   preamble_type, ampdu_len,
-						   TRUE);
+						   true);
 			rts->durid = htol16(durid);
 			durid = wlc_compute_rtscts_dur(wlc, use_cts,
 						       rts_rspec_fallback,
 						       rspec_fallback,
 						       rts_fbr_preamble_type,
 						       fbr_preamble_type,
-						       ampdu_len, TRUE);
+						       ampdu_len, true);
 			txh->RTSDurFallback = htol16(durid);
 			/* set TxFesTimeNormal */
 			txh->TxFesTimeNormal = rts->durid;
@@ -891,7 +891,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 #ifdef WLC_HIGH_ONLY
 		if (wlc->rpc_agg & BCM_RPC_TP_HOST_AGG_AMPDU)
 			bcm_rpc_tp_agg_set(bcm_rpc_tp_get(wlc->rpc),
-					   BCM_RPC_TP_HOST_AGG_AMPDU, TRUE);
+					   BCM_RPC_TP_HOST_AGG_AMPDU, true);
 #endif
 		for (i = 0; i < count; i++)
 			wlc_txfifo(wlc, fifo, pkt[i], i == (count - 1),
@@ -959,7 +959,7 @@ wlc_ampdu_dotxstatus(ampdu_info_t *ampdu
 		ASSERT(!ampdu->p);
 		ampdu->p = p;
 		bcopy(txs, &ampdu->txs, sizeof(tx_status_t));
-		ampdu->waiting_status = TRUE;
+		ampdu->waiting_status = true;
 		return;
 #endif				/* WLC_LOW */
 	}
@@ -1031,7 +1031,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 	bool ba_recd = FALSE, ack_recd = FALSE;
 	u8 suc_mpdu = 0, tot_mpdu = 0;
 	uint supr_status;
-	bool update_rate = TRUE, retry = TRUE, tx_error = FALSE;
+	bool update_rate = true, retry = true, tx_error = FALSE;
 	u16 mimoantsel = 0;
 	u8 antselid = 0;
 	u8 retry_limit, rr_retry_limit;
@@ -1087,7 +1087,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 		bitmap[6] = (s2 >> 16) & 0xff;
 		bitmap[7] = (s2 >> 24) & 0xff;
 
-		ba_recd = TRUE;
+		ba_recd = true;
 	} else {
 		WLCNTINCR(ampdu->cnt->noba);
 		if (supr_status) {
@@ -1117,7 +1117,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 				 */
 				if (wlc_ffpld_check_txfunfl(wlc, prio2fifo[tid])
 				    > 0) {
-					tx_error = TRUE;
+					tx_error = true;
 #ifdef WLC_HIGH_ONLY
 					/* With BMAC, TX Underflows should not happen */
 					WL_ERROR(("wl%d: BMAC TX Underflow?",
@@ -1193,7 +1193,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 
 				ieee80211_tx_status_irqsafe(wlc->pub->ieee_hw,
 							    p);
-				ack_recd = TRUE;
+				ack_recd = true;
 				suc_mpdu++;
 			}
 		}
@@ -1262,7 +1262,7 @@ ampdu_cleanup_tid_ini(ampdu_info_t *ampd
 	ASSERT(ini == &scb_ampdu->ini[ini->tid]);
 
 	/* free all buffered tx packets */
-	pktq_pflush(ampdu->wlc->osh, &scb_ampdu->txq, ini->tid, TRUE, NULL, 0);
+	pktq_pflush(ampdu->wlc->osh, &scb_ampdu->txq, ini->tid, true, NULL, 0);
 }
 
 /* initialize the initiator code for tid */
@@ -1318,7 +1318,7 @@ int wlc_ampdu_set(ampdu_info_t *ampdu, b
 bool wlc_ampdu_cap(ampdu_info_t *ampdu)
 {
 	if (WLC_PHY_11N_CAP(ampdu->wlc->band))
-		return TRUE;
+		return true;
 	else
 		return FALSE;
 }
@@ -1333,13 +1333,13 @@ static void ampdu_update_max_txlen(ampdu
 		rate = MCS_RATE(mcs, FALSE, FALSE);
 		ampdu->max_txlen[mcs][0][0] = (rate * dur) >> 3;
 		/* 40 MHz, No SGI */
-		rate = MCS_RATE(mcs, TRUE, FALSE);
+		rate = MCS_RATE(mcs, true, FALSE);
 		ampdu->max_txlen[mcs][1][0] = (rate * dur) >> 3;
 		/* 20MHz, SGI */
-		rate = MCS_RATE(mcs, FALSE, TRUE);
+		rate = MCS_RATE(mcs, FALSE, true);
 		ampdu->max_txlen[mcs][0][1] = (rate * dur) >> 3;
 		/* 40 MHz, SGI */
-		rate = MCS_RATE(mcs, TRUE, TRUE);
+		rate = MCS_RATE(mcs, true, true);
 		ampdu->max_txlen[mcs][1][1] = (rate * dur) >> 3;
 	}
 }
--- a/drivers/staging/brcm80211/sys/wlc_antsel.c
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.c
@@ -118,7 +118,7 @@ antsel_info_t *wlc_antsel_attach(wlc_inf
 			/* Antenna selection availability */
 			if (((u16) getintvar(asi->pub->vars, "aa2g") == 7) ||
 			    ((u16) getintvar(asi->pub->vars, "aa5g") == 7)) {
-				asi->antsel_avail = TRUE;
+				asi->antsel_avail = true;
 			} else
 			    if (((u16) getintvar(asi->pub->vars, "aa2g") ==
 				 3)
@@ -139,18 +139,18 @@ antsel_info_t *wlc_antsel_attach(wlc_inf
 		   ((u16) getintvar(asi->pub->vars, "aa5g") == 0)) {
 		/* hack to match old 4321CB2 cards with 2of3 antenna switch */
 		asi->antsel_type = ANTSEL_2x3;
-		asi->antsel_avail = TRUE;
+		asi->antsel_avail = true;
 	} else if (asi->pub->boardflags2 & BFL2_2X4_DIV) {
 		asi->antsel_type = ANTSEL_2x4;
-		asi->antsel_avail = TRUE;
+		asi->antsel_avail = true;
 	}
 
 	/* Set the antenna selection type for the low driver */
 	wlc_bmac_antsel_type_set(wlc_hw, asi->antsel_type);
 
 	/* Init (auto/manual) antenna selection */
-	wlc_antsel_init_cfg(asi, &asi->antcfg_11n, TRUE);
-	wlc_antsel_init_cfg(asi, &asi->antcfg_cur, TRUE);
+	wlc_antsel_init_cfg(asi, &asi->antcfg_11n, true);
+	wlc_antsel_init_cfg(asi, &asi->antcfg_cur, true);
 
 	return asi;
 }
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -266,7 +266,7 @@ static u32 WLBANDINITFN(wlc_setband_inac
 
 /* Process received frames */
 /*
- * Return TRUE if more frames need to be processed. FALSE otherwise.
+ * Return true if more frames need to be processed. FALSE otherwise.
  * Param 'bound' indicates max. # frames to process before break out.
  */
 static bool BCMFASTPATH
@@ -321,7 +321,7 @@ wlc_bmac_recv(wlc_hw_info_t *wlc_hw, uin
 }
 
 /* second-level interrupt processing
- *   Return TRUE if another dpc needs to be re-scheduled. FALSE otherwise.
+ *   Return true if another dpc needs to be re-scheduled. FALSE otherwise.
  *   Param 'bounded' indicates if applicable loops should be bounded.
  */
 bool BCMFASTPATH wlc_dpc(wlc_info_t *wlc, bool bounded)
@@ -440,7 +440,7 @@ bool BCMFASTPATH wlc_dpc(wlc_info_t *wlc
 	ASSERT(wlc_ps_check(wlc));
 
 	/* make sure the bound indication and the implementation are in sync */
-	ASSERT(bounded == TRUE || wlc->macintstatus == 0);
+	ASSERT(bounded == true || wlc->macintstatus == 0);
 
 	/* it isn't done and needs to be resched if macintstatus is non-zero */
 	return wlc->macintstatus != 0;
@@ -682,7 +682,7 @@ static bool wlc_bmac_attach_dmapio(wlc_i
 	/* initial ucode host flags */
 	wlc_mhfdef(wlc, wlc_hw->band->mhfs, pio_mhf2);
 
-	return TRUE;
+	return true;
 }
 
 static void wlc_bmac_detach_dmapio(wlc_hw_info_t *wlc_hw)
@@ -721,7 +721,7 @@ int wlc_bmac_attach(wlc_info_t *wlc, u16
 
 	ASSERT(sizeof(wlc_d11rxhdr_t) <= WL_HWRXOFF);
 
-	wme = TRUE;
+	wme = true;
 
 	wlc_hw = wlc->hw;
 	wlc_hw->wlc = wlc;
@@ -832,11 +832,11 @@ int wlc_bmac_attach(wlc_info_t *wlc, u16
 
 	if (D11REV_LE(wlc_hw->corerev, 4)
 	    || (wlc_hw->boardflags & BFL_NOPLLDOWN))
-		wlc_bmac_pllreq(wlc_hw, TRUE, WLC_PLLREQ_SHARED);
+		wlc_bmac_pllreq(wlc_hw, true, WLC_PLLREQ_SHARED);
 
 	if ((BUSTYPE(wlc_hw->sih->bustype) == PCI_BUS)
 	    && (si_pci_war16165(wlc_hw->sih)))
-		wlc->war16165 = TRUE;
+		wlc->war16165 = true;
 
 	/* check device id(srom, nvram etc.) to set bands */
 	if (wlc_hw->deviceid == BCM43224_D11N_ID) {
@@ -1239,8 +1239,8 @@ int wlc_bmac_up_finish(wlc_hw_info_t *wl
 {
 	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
 
-	wlc_hw->up = TRUE;
-	wlc_phy_hw_state_upd(wlc_hw->band->pi, TRUE);
+	wlc_hw->up = true;
+	wlc_phy_hw_state_upd(wlc_hw->band->pi, true);
 
 	/* FULLY enable dynamic power control and d11 core interrupt */
 	wlc_clkctl_clk(wlc_hw, CLK_DYNAMIC);
@@ -1958,7 +1958,7 @@ WLBANDINITFN(wlc_bmac_bsinit) (wlc_info_
 
 	wlc_bmac_update_slot_timing(wlc_hw,
 				    BAND_5G(wlc_hw->band->
-					    bandtype) ? TRUE : wlc_hw->
+					    bandtype) ? true : wlc_hw->
 				    shortslot);
 
 	/* write phytype and phyvers */
@@ -2065,7 +2065,7 @@ void wlc_bmac_phy_reset(wlc_hw_info_t *w
 		/* reset the PHY */
 		si_core_cflags(wlc_hw->sih, (SICF_PRST | SICF_PCLKE),
 			       (SICF_PRST | SICF_PCLKE));
-		phy_in_reset = TRUE;
+		phy_in_reset = true;
 	} else {
 
 		si_core_cflags(wlc_hw->sih,
@@ -2149,12 +2149,12 @@ static bool wlc_isgoodchip(wlc_hw_info_t
 		return FALSE;
 	}
 
-	return TRUE;
+	return true;
 }
 
 static bool wlc_validboardtype(wlc_hw_info_t *wlc_hw)
 {
-	bool goodboard = TRUE;
+	bool goodboard = true;
 	uint boardrev = wlc_hw->boardrev;
 
 	if (boardrev == 0)
@@ -2200,7 +2200,7 @@ static char *wlc_get_macaddr(wlc_hw_info
 }
 
 /*
- * Return TRUE if radio is disabled, otherwise FALSE.
+ * Return true if radio is disabled, otherwise FALSE.
  * hw radio disable signal is an external pin, users activate it asynchronously
  * this function could be called when driver is down and w/o clock
  * it operates on different registers depending on corerev and boardflag.
@@ -2282,7 +2282,7 @@ void wlc_bmac_hw_up(wlc_hw_info_t *wlc_h
 	wlc_phy_por_inform(wlc_hw->band->pi);
 
 	wlc_hw->ucode_loaded = FALSE;
-	wlc_hw->wlc->pub->hw_up = TRUE;
+	wlc_hw->wlc->pub->hw_up = true;
 
 	if ((wlc_hw->boardflags & BFL_FEM)
 	    && (CHIPID(wlc_hw->sih->chip) == BCM4313_CHIP_ID)) {
@@ -2299,7 +2299,7 @@ static bool wlc_dma_rxreset(wlc_hw_info_
 	osl_t *osh;
 
 	if (D11REV_LT(wlc_hw->corerev, 12)) {
-		bool rxidle = TRUE;
+		bool rxidle = true;
 		u16 rcv_frm_cnt = 0;
 
 		osh = wlc_hw->osh;
@@ -2389,9 +2389,9 @@ void wlc_bmac_corereset(wlc_hw_info_t *w
 	 */
 	wlc_hw->clk = FALSE;
 	si_core_reset(wlc_hw->sih, flags, resetbits);
-	wlc_hw->clk = TRUE;
+	wlc_hw->clk = true;
 	if (wlc_hw->band && wlc_hw->band->pi)
-		wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, TRUE);
+		wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, true);
 
 	wlc_mctrl_reset(wlc_hw);
 
@@ -2401,7 +2401,7 @@ void wlc_bmac_corereset(wlc_hw_info_t *w
 	wlc_bmac_phy_reset(wlc_hw);
 
 	/* turn on PHY_PLL */
-	wlc_bmac_core_phypll_ctl(wlc_hw, TRUE);
+	wlc_bmac_core_phypll_ctl(wlc_hw, true);
 
 	/* clear sw intstatus */
 	wlc_hw->wlc->macintstatus = 0;
@@ -2502,7 +2502,7 @@ static void wlc_coreinit(wlc_info_t *wlc
 	 * 2) newer chips, driver wants to controls the fifo allocation
 	 */
 	if (D11REV_GE(wlc_hw->corerev, 4))
-		fifosz_fixup = TRUE;
+		fifosz_fixup = true;
 
 	/* let the PSM run to the suspended state, set mode to BSS STA */
 	W_REG(osh, &regs->macintstatus, -1);
@@ -2539,7 +2539,7 @@ static void wlc_coreinit(wlc_info_t *wlc
 	}
 
 	/* For old ucode, txfifo sizes needs to be modified(increased) for Corerev >= 9 */
-	if (fifosz_fixup == TRUE) {
+	if (fifosz_fixup == true) {
 		wlc_corerev_fifofixup(wlc_hw);
 	}
 
@@ -2794,7 +2794,7 @@ static void wlc_ucode_download(wlc_hw_in
 		if (WLCISNPHY(wlc_hw->band)) {
 			wlc_ucode_write(wlc_hw, bcm43xx_16_mimo,
 					bcm43xx_16_mimosz);
-			wlc_hw->ucode_loaded = TRUE;
+			wlc_hw->ucode_loaded = true;
 		} else
 			WL_ERROR(("%s: wl%d: unsupported phy in corerev %d\n",
 				  __func__, wlc_hw->unit, wlc_hw->corerev));
@@ -2802,7 +2802,7 @@ static void wlc_ucode_download(wlc_hw_in
 		if (WLCISLCNPHY(wlc_hw->band)) {
 			wlc_ucode_write(wlc_hw, bcm43xx_24_lcn,
 					bcm43xx_24_lcnsz);
-			wlc_hw->ucode_loaded = TRUE;
+			wlc_hw->ucode_loaded = true;
 		} else {
 			WL_ERROR(("%s: wl%d: unsupported phy in corerev %d\n",
 				  __func__, wlc_hw->unit, wlc_hw->corerev));
@@ -2920,27 +2920,27 @@ void wlc_bmac_fifoerrors(wlc_hw_info_t *
 			WL_ERROR(("wl%d: fifo %d: receive fifo overflow\n",
 				  unit, idx));
 			WLCNTINCR(wlc_hw->wlc->pub->_cnt->rxoflo);
-			fatal = TRUE;
+			fatal = true;
 		}
 
 		if (intstatus & I_PC) {
 			WL_ERROR(("wl%d: fifo %d: descriptor error\n", unit,
 				  idx));
 			WLCNTINCR(wlc_hw->wlc->pub->_cnt->dmade);
-			fatal = TRUE;
+			fatal = true;
 		}
 
 		if (intstatus & I_PD) {
 			WL_ERROR(("wl%d: fifo %d: data error\n", unit, idx));
 			WLCNTINCR(wlc_hw->wlc->pub->_cnt->dmada);
-			fatal = TRUE;
+			fatal = true;
 		}
 
 		if (intstatus & I_DE) {
 			WL_ERROR(("wl%d: fifo %d: descriptor protocol error\n",
 				  unit, idx));
 			WLCNTINCR(wlc_hw->wlc->pub->_cnt->dmape);
-			fatal = TRUE;
+			fatal = true;
 		}
 
 		if (intstatus & I_RU) {
@@ -2952,7 +2952,7 @@ void wlc_bmac_fifoerrors(wlc_hw_info_t *
 			WL_ERROR(("wl%d: fifo %d: transmit fifo underflow\n",
 				  idx, unit));
 			WLCNTINCR(wlc_hw->wlc->pub->_cnt->txuflo);
-			fatal = TRUE;
+			fatal = true;
 		}
 
 		if (fatal) {
@@ -3107,7 +3107,7 @@ bool wlc_bmac_tx_fifo_suspended(wlc_hw_i
 	if (dma_txsuspended(wlc_hw->di[tx_fifo]) &&
 	    (R_REG(wlc_hw->osh, &wlc_hw->regs->chnstatus) &
 	     (1 << tx_fifo)) == 0)
-		return TRUE;
+		return true;
 
 	return FALSE;
 }
@@ -3167,7 +3167,7 @@ void wlc_bmac_tx_fifo_resume(wlc_hw_info
  * Read and clear macintmask and macintstatus and intstatus registers.
  * This routine should be called with interrupts off
  * Return:
- *   -1 if DEVICEREMOVED(wlc) evaluates to TRUE;
+ *   -1 if DEVICEREMOVED(wlc) evaluates to true;
  *   0 if the interrupt is not for us, or we are in some special cases;
  *   device interrupt status bits otherwise.
  */
@@ -3262,7 +3262,7 @@ static inline u32 wlc_intstatus(wlc_info
 }
 
 /* Update wlc->macintstatus and wlc->intstatus[]. */
-/* Return TRUE if they are updated successfully. FALSE otherwise */
+/* Return true if they are updated successfully. FALSE otherwise */
 bool wlc_intrsupd(wlc_info_t *wlc)
 {
 	u32 macintstatus;
@@ -3279,13 +3279,13 @@ bool wlc_intrsupd(wlc_info_t *wlc)
 	/* update interrupt status in software */
 	wlc->macintstatus |= macintstatus;
 
-	return TRUE;
+	return true;
 }
 
 /*
  * First-level interrupt processing.
- * Return TRUE if this was our interrupt, FALSE otherwise.
- * *wantdpc will be set to TRUE if further wlc_dpc() processing is required,
+ * Return true if this was our interrupt, FALSE otherwise.
+ * *wantdpc will be set to true if further wlc_dpc() processing is required,
  * FALSE otherwise.
  */
 bool BCMFASTPATH wlc_isr(wlc_info_t *wlc, bool *wantdpc)
@@ -3299,7 +3299,7 @@ bool BCMFASTPATH wlc_isr(wlc_info_t *wlc
 		return FALSE;
 
 	/* read and clear macintstatus and intstatus registers */
-	macintstatus = wlc_intstatus(wlc, TRUE);
+	macintstatus = wlc_intstatus(wlc, true);
 
 	if (macintstatus == 0xffffffff)
 		WL_ERROR(("DEVICEREMOVED detected in the ISR code path.\n"));
@@ -3308,13 +3308,13 @@ bool BCMFASTPATH wlc_isr(wlc_info_t *wlc
 	if (macintstatus == 0)
 		return FALSE;
 
-	*wantdpc = TRUE;
+	*wantdpc = true;
 
 	/* save interrupt status bits */
 	ASSERT(wlc->macintstatus == 0);
 	wlc->macintstatus = macintstatus;
 
-	return TRUE;
+	return true;
 
 }
 
@@ -3346,7 +3346,7 @@ static bool wlc_bmac_txstatus_corerev4(w
 	}
 
 	if (fatal)
-		return TRUE;
+		return true;
 
 	/* post more rbufs */
 	dma_rxfill(wlc_hw->di[RX_TXSTATUS_FIFO]);
@@ -3371,7 +3371,7 @@ wlc_bmac_dotxstatus(wlc_hw_info_t *wlc_h
 }
 
 /* process tx completion events in BMAC
- * Return TRUE if more tx status need to be processed. FALSE otherwise.
+ * Return true if more tx status need to be processed. FALSE otherwise.
  */
 static bool BCMFASTPATH
 wlc_bmac_txstatus(wlc_hw_info_t *wlc_hw, bool bound, bool *fatal)
@@ -3429,7 +3429,7 @@ wlc_bmac_txstatus(wlc_hw_info_t *wlc_hw,
 			return 0;
 
 		if (n >= max_tx_num)
-			morepending = TRUE;
+			morepending = true;
 	}
 
 	if (!pktq_empty(&wlc->active_queue->q))
@@ -3755,7 +3755,7 @@ bool wlc_bmac_validate_chip_access(wlc_h
 		return FALSE;
 	}
 
-	return TRUE;
+	return true;
 }
 
 #define PHYPLL_WAIT_US	100000
@@ -4116,7 +4116,7 @@ void wlc_bmac_set_clk(wlc_hw_info_t *wlc
 /* this will be true for all ai chips */
 bool wlc_bmac_taclear(wlc_hw_info_t *wlc_hw, bool ta_ok)
 {
-	return TRUE;
+	return true;
 }
 
 /* Lower down relevant GPIOs like LED when going down w/o
@@ -4150,7 +4150,7 @@ bool wlc_bmac_radio_hw(wlc_hw_info_t *wl
 		if (PMUCTL_ENAB(wlc_hw->sih)) {
 			AND_REG(wlc_hw->osh, &wlc_hw->regs->clk_ctl_st,
 				~CCS_FORCEHWREQOFF);
-			si_pmu_radio_enable(wlc_hw->sih, TRUE);
+			si_pmu_radio_enable(wlc_hw->sih, true);
 		}
 
 		wlc_phy_anacore(wlc_hw->band->pi, ON);
@@ -4172,7 +4172,7 @@ bool wlc_bmac_radio_hw(wlc_hw_info_t *wl
 		}
 	}
 
-	return TRUE;
+	return true;
 }
 
 u16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, u8 rate)
--- a/drivers/staging/brcm80211/sys/wlc_bsscfg.h
+++ b/drivers/staging/brcm80211/sys/wlc_bsscfg.h
@@ -79,7 +79,7 @@ struct wlc_bsscfg {
 	bool wsec_restrict;	/* drop unencrypted packets if wsec is enabled */
 	bool eap_restrict;	/* restrict data until 802.1X auth succeeds */
 	u16 WPA_auth;	/* WPA: authenticated key management */
-	bool wpa2_preauth;	/* default is TRUE, wpa_cap sets value */
+	bool wpa2_preauth;	/* default is true, wpa_cap sets value */
 	bool wsec_portopen;	/* indicates keys are plumbed */
 	wsec_iv_t wpa_none_txiv;	/* global txiv for WPA_NONE, tkip and aes */
 	int wsec_index;		/* 0-3: default tx key, -1: not set */
--- a/drivers/staging/brcm80211/sys/wlc_channel.c
+++ b/drivers/staging/brcm80211/sys/wlc_channel.c
@@ -692,7 +692,7 @@ wlc_channel_get_chanvec(struct wlc_info
 		return FALSE;
 
 	wlc_locale_get_channels(locale, channels);
-	return TRUE;
+	return true;
 }
 
 /* set the driver's current country and regulatory information using a country code
@@ -773,7 +773,7 @@ wlc_set_country_common(wlc_cm_info_t *wl
 	li_mimo = wlc_get_mimo_2g(country->locale_mimo_2G);
 	if (li_mimo && (li_mimo->flags & WLC_NO_MIMO)) {
 		wlc_set_nmode(wlc, OFF);
-		wlc->stf->no_cddstbc = TRUE;
+		wlc->stf->no_cddstbc = true;
 	} else {
 		wlc->stf->no_cddstbc = FALSE;
 		if (N_ENAB(wlc->pub) != wlc->protection->nmode_user)
@@ -985,7 +985,7 @@ static void wlc_channels_commit(wlc_cm_i
 	 */
 	if (NBANDS(wlc) > 1 || BAND_2G(wlc->band->bandtype)) {
 		wlc_phy_chanspec_ch14_widefilter_set(wlc->band->pi,
-						     wlc_japan(wlc) ? TRUE :
+						     wlc_japan(wlc) ? true :
 						     FALSE);
 	}
 
@@ -1511,7 +1511,7 @@ wlc_channel_reg_limits(wlc_cm_info_t *wl
 	return;
 }
 
-/* Returns TRUE if currently set country is Japan or variant */
+/* Returns true if currently set country is Japan or variant */
 bool wlc_japan(struct wlc_info *wlc)
 {
 	return wlc_japan_ccode(wlc->cmi->country_abbrev);
@@ -1583,7 +1583,7 @@ wlc_valid_chanspec_ext(wlc_cm_info_t *wl
 		/* check that the lower sideband allows an upper sideband */
 		if ((upper_sideband & (CH_UPPER_SB | CH_EWA_VALID)) ==
 		    (CH_UPPER_SB | CH_EWA_VALID))
-			return TRUE;
+			return true;
 		return FALSE;
 	}
 #endif				/* 40 MHZ */
@@ -1598,5 +1598,5 @@ bool wlc_valid_chanspec(wlc_cm_info_t *w
 
 bool wlc_valid_chanspec_db(wlc_cm_info_t *wlc_cm, chanspec_t chspec)
 {
-	return wlc_valid_chanspec_ext(wlc_cm, chspec, TRUE);
+	return wlc_valid_chanspec_ext(wlc_cm, chspec, true);
 }
--- a/drivers/staging/brcm80211/sys/wlc_event.c
+++ b/drivers/staging/brcm80211/sys/wlc_event.c
@@ -106,13 +106,13 @@ int wlc_eventq_down(wlc_eventq_t *eq)
 		if (!wl_del_timer(eq->wl, eq->timer))
 			callbacks++;
 
-		ASSERT(wlc_eventq_avail(eq) == TRUE);
+		ASSERT(wlc_eventq_avail(eq) == true);
 		ASSERT(eq->workpending == FALSE);
-		eq->workpending = TRUE;
+		eq->workpending = true;
 		if (eq->cb)
 			eq->cb(eq->wlc);
 
-		ASSERT(eq->workpending == TRUE);
+		ASSERT(eq->workpending == true);
 		eq->workpending = FALSE;
 		eq->tpending = FALSE;
 	} else {
@@ -153,7 +153,7 @@ void wlc_eventq_enq(wlc_eventq_t *eq, wl
 		eq->head = eq->tail = e;
 
 	if (!eq->tpending) {
-		eq->tpending = TRUE;
+		eq->tpending = true;
 		/* Use a zero-delay timer to trigger
 		 * delayed processing of the event.
 		 */
@@ -214,16 +214,16 @@ static void wlc_timer_cb(void *arg)
 {
 	struct wlc_eventq *eq = (struct wlc_eventq *)arg;
 
-	ASSERT(eq->tpending == TRUE);
-	ASSERT(wlc_eventq_avail(eq) == TRUE);
+	ASSERT(eq->tpending == true);
+	ASSERT(wlc_eventq_avail(eq) == true);
 	ASSERT(eq->workpending == FALSE);
-	eq->workpending = TRUE;
+	eq->workpending = true;
 
 	if (eq->cb)
 		eq->cb(eq->wlc);
 
 	ASSERT(wlc_eventq_avail(eq) == FALSE);
-	ASSERT(eq->tpending == TRUE);
+	ASSERT(eq->tpending == true);
 	eq->workpending = FALSE;
 	eq->tpending = FALSE;
 }
--- a/drivers/staging/brcm80211/sys/wlc_key.h
+++ b/drivers/staging/brcm80211/sys/wlc_key.h
@@ -65,7 +65,7 @@ struct wlc_bsscfg;
 #define WSEC_KEY(wlc, i)	(((wlc)->wsec_keys[i] && (wlc)->wsec_keys[i]->len) ? \
 	(wlc)->wsec_keys[i] : NULL)
 
-#define WSEC_SCB_KEY_VALID(scb)	(((scb)->key && (scb)->key->len) ? TRUE : FALSE)
+#define WSEC_SCB_KEY_VALID(scb)	(((scb)->key && (scb)->key->len) ? true : FALSE)
 
 /* default key */
 #define WSEC_BSS_DEFAULT_KEY(bsscfg) (((bsscfg)->wsec_index == -1) ? \
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -349,7 +349,7 @@ void wlc_get_rcmta(wlc_info_t *wlc, int
 /* keep the chip awake if needed */
 bool wlc_stay_awake(wlc_info_t *wlc)
 {
-	return TRUE;
+	return true;
 }
 
 /* conditions under which the PM bit should be set in outgoing frames and STAY_AWAKE is meaningful
@@ -378,7 +378,7 @@ bool wlc_ps_allowed(wlc_info_t *wlc)
 			return FALSE;
 	}
 
-	return TRUE;
+	return true;
 }
 
 void wlc_reset(wlc_info_t *wlc)
@@ -408,7 +408,7 @@ void wlc_reset(wlc_info_t *wlc)
 	 *  have been cleared instantly in wlc_bmac_reset() and no txstatus interrupt
 	 *  will come to driver to fetch those flushed dma pkt pointers.
 	 */
-	wlc->reset_bmac_pending = TRUE;
+	wlc->reset_bmac_pending = true;
 
 	wlc_rpctx_txreclaim(wlc->rpctx);
 
@@ -530,8 +530,8 @@ void wlc_init(wlc_info_t *wlc)
 		       _rifs ? (EDCF_AC_VO_TXOP_AP << 5) : MAXFRAMEBURST_TXOP));
 
 	/* initialize maximum allowed duty cycle */
-	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_ofdm, TRUE, TRUE);
-	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_cck, FALSE, TRUE);
+	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_ofdm, true, true);
+	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_cck, FALSE, true);
 
 	/* Update some shared memory locations related to max AMPDU size allowed to received */
 	wlc_ampdu_shm_upd(wlc->ampdu);
@@ -626,7 +626,7 @@ void wlc_mac_promisc(wlc_info_t *wlc)
 /* check if hps and wake states of sw and hw are in sync */
 bool wlc_ps_check(wlc_info_t *wlc)
 {
-	bool res = TRUE;
+	bool res = true;
 	bool hps, wake;
 	bool wake_ok;
 
@@ -689,7 +689,7 @@ void wlc_set_ps_ctrl(wlc_info_t *wlc)
 	bool awake_before;
 
 	hps = PS_ALLOWED(wlc);
-	wake = hps ? (STAY_AWAKE(wlc)) : TRUE;
+	wake = hps ? (STAY_AWAKE(wlc)) : true;
 
 	WL_TRACE(("wl%d: wlc_set_ps_ctrl: hps %d wake %d\n", wlc->pub->unit,
 		  hps, wake));
@@ -860,7 +860,7 @@ void wlc_set_chanspec(wlc_info_t *wlc, c
 	if (NBANDS(wlc) > 1) {
 		bandunit = CHSPEC_WLCBANDUNIT(chanspec);
 		if (wlc->band->bandunit != bandunit || wlc->bandinit_pending) {
-			switchband = TRUE;
+			switchband = true;
 			if (wlc->bandlocked) {
 				WL_ERROR(("wl%d: %s: chspec %d band is locked!\n", wlc->pub->unit, __func__, CHSPEC_CHANNEL(chanspec)));
 				return;
@@ -1084,7 +1084,7 @@ static u32 wlc_watchdog_backup_bi(wlc_in
 }
 
 /* Change to run the watchdog either from a periodic timer or from tbtt handler.
- * Call watchdog from tbtt handler if tbtt is TRUE, watchdog timer otherwise.
+ * Call watchdog from tbtt handler if tbtt is true, watchdog timer otherwise.
  */
 void wlc_watchdog_upd(wlc_info_t *wlc, bool tbtt)
 {
@@ -1105,13 +1105,13 @@ void wlc_watchdog_upd(wlc_info_t *wlc, b
 	/* arm watchdog timer and drive the watchdog there */
 	else if (!tbtt && !wlc->WDarmed) {
 		wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG,
-			     TRUE);
-		wlc->WDarmed = TRUE;
+			     true);
+		wlc->WDarmed = true;
 	}
 	if (tbtt && !wlc->WDarmed) {
 		wl_add_timer(wlc->wl, wlc->wdtimer, wlc_watchdog_backup_bi(wlc),
-			     TRUE);
-		wlc->WDarmed = TRUE;
+			     true);
+		wlc->WDarmed = true;
 	}
 }
 
@@ -1216,7 +1216,7 @@ static void wlc_ht_update_sgi_rx(wlc_inf
 
 	if (wlc->pub->up) {
 		wlc_update_beacon(wlc);
-		wlc_update_probe_resp(wlc, TRUE);
+		wlc_update_probe_resp(wlc, true);
 	}
 }
 
@@ -1230,8 +1230,8 @@ static void wlc_ht_update_ldpc(wlc_info_
 
 	if (wlc->pub->up) {
 		wlc_update_beacon(wlc);
-		wlc_update_probe_resp(wlc, TRUE);
-		wlc_phy_ldpc_override_set(wlc->band->pi, (val ? TRUE : FALSE));
+		wlc_update_probe_resp(wlc, true);
+		wlc_phy_ldpc_override_set(wlc->band->pi, (val ? true : FALSE));
 	}
 }
 
@@ -1346,9 +1346,9 @@ static void WLBANDINITFN(wlc_setband) (w
 		return;
 
 	/* wait for at least one beacon before entering sleeping state */
-	wlc->PMawakebcn = TRUE;
+	wlc->PMawakebcn = true;
 	FOREACH_AS_STA(wlc, idx, cfg)
-	    cfg->PMawakebcn = TRUE;
+	    cfg->PMawakebcn = true;
 	wlc_set_ps_ctrl(wlc);
 
 	/* band-specific initializations */
@@ -1568,7 +1568,7 @@ bool wlc_timers_init(wlc_info_t *wlc, in
 		goto fail;
 	}
 
-	return TRUE;
+	return true;
 
  fail:
 	return FALSE;
@@ -1582,7 +1582,7 @@ void wlc_info_init(wlc_info_t *wlc, int
 {
 	int i;
 	/* Assume the device is there until proven otherwise */
-	wlc->device_present = TRUE;
+	wlc->device_present = true;
 
 	/* set default power output percentage to 100 percent */
 	wlc->txpwr_percent = 100;
@@ -1593,13 +1593,13 @@ void wlc_info_init(wlc_info_t *wlc, int
 	/* initialize CCK preamble mode to unassociated state */
 	wlc->shortpreamble = FALSE;
 
-	wlc->legacy_probe = TRUE;
+	wlc->legacy_probe = true;
 
 	/* various 802.11g modes */
 	wlc->shortslot = FALSE;
 	wlc->shortslot_override = WLC_SHORTSLOT_AUTO;
 
-	wlc->barker_overlap_control = TRUE;
+	wlc->barker_overlap_control = true;
 	wlc->barker_preamble = WLC_BARKER_SHORT_ALLOWED;
 	wlc->txburst_limit_override = AUTO;
 
@@ -1615,7 +1615,7 @@ void wlc_info_init(wlc_info_t *wlc, int
 	wlc_protection_upd(wlc, WLC_PROT_OVERLAP, WLC_PROTECTION_CTL_OVERLAP);
 
 	/* 802.11g draft 4.0 NonERP elt advertisement */
-	wlc->include_legacy_erp = TRUE;
+	wlc->include_legacy_erp = true;
 
 	wlc->stf->ant_rx_ovr = ANT_RX_DIV_DEF;
 	wlc->stf->txant = ANT_TX_DEF;
@@ -1654,7 +1654,7 @@ void wlc_info_init(wlc_info_t *wlc, int
 	wlc->PSpoll = FALSE;
 
 	/* APSD defaults */
-	wlc->wme_apsd = TRUE;
+	wlc->wme_apsd = true;
 	wlc->apsd_sta_usp = FALSE;
 	wlc->apsd_trigger_timeout = 0;	/* disable the trigger timer */
 	wlc->apsd_trigger_ac = AC_BITMAP_ALL;
@@ -1674,19 +1674,19 @@ void wlc_info_init(wlc_info_t *wlc, int
 	wlc->pub->_wme = AUTO;
 
 #ifdef BCMSDIODEV_ENABLED
-	wlc->pub->_priofc = TRUE;	/* enable priority flow control for sdio dongle */
+	wlc->pub->_priofc = true;	/* enable priority flow control for sdio dongle */
 #endif
 
 	wlc->pub->_ampdu = AMPDU_AGG_HOST;
 	wlc->pub->bcmerror = 0;
-	wlc->ibss_allowed = TRUE;
-	wlc->ibss_coalesce_allowed = TRUE;
+	wlc->ibss_allowed = true;
+	wlc->ibss_coalesce_allowed = true;
 	wlc->pub->_coex = ON;
 
 	/* intialize mpc delay */
 	wlc->mpc_delay_off = wlc->mpc_dlycnt = WLC_MPC_MIN_DELAYCNT;
 
-	wlc->pr80838_war = TRUE;
+	wlc->pr80838_war = true;
 }
 
 static bool wlc_state_bmac_sync(wlc_info_t *wlc)
@@ -1700,7 +1700,7 @@ static bool wlc_state_bmac_sync(wlc_info
 	wlc_protection_upd(wlc, WLC_PROT_N_PAM_OVR,
 			   (s8) state_bmac.preamble_ovr);
 
-	return TRUE;
+	return true;
 }
 
 static uint wlc_attach_module(wlc_info_t *wlc)
@@ -2132,7 +2132,7 @@ static bool wlc_attach_stf_ant_init(wlc_
 	    (s8) getintvar(vars, (BAND_5G(bandtype) ? "ag1" : "ag0"));
 	wlc_attach_antgain_init(wlc);
 
-	return TRUE;
+	return true;
 }
 
 #ifdef WLC_HIGH_ONLY
@@ -2399,7 +2399,7 @@ void wlc_ap_upd(wlc_info_t *wlc)
 	wlc->vlan_mode = AP_ENAB(wlc->pub) ? OFF : AUTO;
 
 	/* fixup mpc */
-	wlc->mpc = TRUE;
+	wlc->mpc = true;
 }
 
 /* read hwdisable state and propagate to wlc flag */
@@ -2415,7 +2415,7 @@ static void wlc_radio_hwdisable_upd(wlc_
 	}
 }
 
-/* return TRUE if Minimum Power Consumption should be entered, FALSE otherwise */
+/* return true if Minimum Power Consumption should be entered, FALSE otherwise */
 bool wlc_is_non_delay_mpc(wlc_info_t *wlc)
 {
 	return FALSE;
@@ -2454,7 +2454,7 @@ void wlc_radio_mpc_upd(wlc_info_t *wlc)
 	radio_state =
 	    (mboolisset(wlc->pub->radio_disabled, WL_RADIO_MPC_DISABLE) ? OFF :
 	     ON);
-	mpc_radio = (wlc_ismpc(wlc) == TRUE) ? OFF : ON;
+	mpc_radio = (wlc_ismpc(wlc) == true) ? OFF : ON;
 
 	if (radio_state == ON && mpc_radio == OFF)
 		wlc->mpc_delay_off = wlc->mpc_dlycnt;
@@ -2472,7 +2472,7 @@ void wlc_radio_mpc_upd(wlc_info_t *wlc)
 	 * wlc->mpc_delay_off to wlc->mpc_dlycnt, so that we restart the countdown of mpc_delay_off
 	 */
 	if ((wlc->prev_non_delay_mpc == FALSE) &&
-	    (wlc_is_non_delay_mpc(wlc) == TRUE) && wlc->mpc_delay_off) {
+	    (wlc_is_non_delay_mpc(wlc) == true) && wlc->mpc_delay_off) {
 		wlc->mpc_delay_off = wlc->mpc_dlycnt;
 	}
 	wlc->prev_non_delay_mpc = wlc_is_non_delay_mpc(wlc);
@@ -2498,7 +2498,7 @@ static void wlc_down_led_upd(wlc_info_t
 	/* maintain LEDs while in down state, turn on sbclk if not available yet */
 	/* turn on sbclk if necessary */
 	if (!AP_ENAB(wlc->pub)) {
-		wlc_pllreq(wlc, TRUE, WLC_PLLREQ_FLIP);
+		wlc_pllreq(wlc, true, WLC_PLLREQ_FLIP);
 
 		wlc_pllreq(wlc, FALSE, WLC_PLLREQ_FLIP);
 	}
@@ -2553,18 +2553,18 @@ static bool wlc_radio_monitor_start(wlc_
 {
 	/* Don't start the timer if HWRADIO feature is disabled */
 	if (wlc->radio_monitor || (wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO))
-		return TRUE;
+		return true;
 
-	wlc->radio_monitor = TRUE;
-	wlc_pllreq(wlc, TRUE, WLC_PLLREQ_RADIO_MON);
-	wl_add_timer(wlc->wl, wlc->radio_timer, TIMER_INTERVAL_RADIOCHK, TRUE);
-	return TRUE;
+	wlc->radio_monitor = true;
+	wlc_pllreq(wlc, true, WLC_PLLREQ_RADIO_MON);
+	wl_add_timer(wlc->wl, wlc->radio_timer, TIMER_INTERVAL_RADIOCHK, true);
+	return true;
 }
 
 bool wlc_radio_monitor_stop(wlc_info_t *wlc)
 {
 	if (!wlc->radio_monitor)
-		return TRUE;
+		return true;
 
 	ASSERT((wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO) !=
 	       WL_SWFL_NOHWRADIO);
@@ -2577,13 +2577,13 @@ bool wlc_radio_monitor_stop(wlc_info_t *
 /* bring the driver down, but don't reset hardware */
 void wlc_out(wlc_info_t *wlc)
 {
-	wlc_bmac_set_noreset(wlc->hw, TRUE);
+	wlc_bmac_set_noreset(wlc->hw, true);
 	wlc_radio_upd(wlc);
 	wl_down(wlc->wl);
 	wlc_bmac_set_noreset(wlc->hw, FALSE);
 
-	/* core clk is TRUE in BMAC driver due to noreset, need to mirror it in HIGH */
-	wlc->clk = TRUE;
+	/* core clk is true in BMAC driver due to noreset, need to mirror it in HIGH */
+	wlc->clk = true;
 
 	/* This will make sure that when 'up' is done
 	 * after 'out' it'll restore hardware (especially gpios)
@@ -2606,7 +2606,7 @@ static bool wlc_tx_prec_map_verify(wlc_i
 		      WLC_TX_FIFO_CHECK(wlc, TX_CTL_FIFO)))
 			return FALSE;
 		else
-			return TRUE;
+			return true;
 	}
 
 	return WLC_TX_FIFO_CHECK(wlc, TX_AC_BK_FIFO)
@@ -2624,7 +2624,7 @@ static void wlc_watchdog_by_timer(void *
 		/* set to normal osl watchdog period */
 		wl_del_timer(wlc->wl, wlc->wdtimer);
 		wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG,
-			     TRUE);
+			     true);
 	}
 }
 
@@ -2709,7 +2709,7 @@ static void wlc_watchdog(void *arg)
 	}
 #ifdef WLC_LOW
 	/* BMAC_NOTE: for HIGH_ONLY driver, this seems being called after RPC bus failed */
-	ASSERT(wlc_bmac_taclear(wlc->hw, TRUE));
+	ASSERT(wlc_bmac_taclear(wlc->hw, true));
 #endif
 
 	/* Verify that tx_prec_map and fifos are in sync to avoid lock ups */
@@ -2729,7 +2729,7 @@ int wlc_up(wlc_info_t *wlc)
 
 	if (!wlc->pub->hw_up) {
 		wlc_bmac_hw_up(wlc->hw);
-		wlc->pub->hw_up = TRUE;
+		wlc->pub->hw_up = true;
 	}
 
 	if ((wlc->pub->boardflags & BFL_FEM)
@@ -2779,7 +2779,7 @@ int wlc_up(wlc_info_t *wlc)
 	}
 
 	/* wlc_bmac_up_prep has done wlc_corereset(). so clk is on, set it */
-	wlc->clk = TRUE;
+	wlc->clk = true;
 
 	wlc_radio_monitor_stop(wlc);
 
@@ -2795,7 +2795,7 @@ int wlc_up(wlc_info_t *wlc)
 			WLC_BAND_ALL);
 
 	wl_init(wlc->wl);
-	wlc->pub->up = TRUE;
+	wlc->pub->up = true;
 
 	if (wlc->bandinit_pending) {
 		wlc_suspend_mac_and_wait(wlc);
@@ -2815,8 +2815,8 @@ int wlc_up(wlc_info_t *wlc)
 
 	/* start one second watchdog timer */
 	ASSERT(!wlc->WDarmed);
-	wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG, TRUE);
-	wlc->WDarmed = TRUE;
+	wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG, true);
+	wlc->WDarmed = true;
 
 	/* ensure antenna config is up to date */
 	wlc_stf_phy_txant_upd(wlc);
@@ -2878,7 +2878,7 @@ uint wlc_down(wlc_info_t *wlc)
 		return callbacks;
 
 	/* in between, mpc could try to bring down again.. */
-	wlc->going_down = TRUE;
+	wlc->going_down = true;
 
 	callbacks += wlc_bmac_down_prep(wlc->hw);
 
@@ -2912,7 +2912,7 @@ uint wlc_down(wlc_info_t *wlc)
 
 	/* flush tx queues */
 	for (qi = wlc->tx_queues; qi != NULL; qi = qi->next) {
-		pktq_flush(wlc->osh, &qi->q, TRUE, NULL, 0);
+		pktq_flush(wlc->osh, &qi->q, true, NULL, 0);
 		ASSERT(pktq_empty(&qi->q));
 	}
 
@@ -2957,7 +2957,7 @@ int wlc_set_gmode(wlc_info_t *wlc, u8 gm
 	s8 shortslot = WLC_SHORTSLOT_AUTO;	/* Advertise and use shortslot (-1/0/1 Auto/Off/On) */
 	bool shortslot_restrict = FALSE;	/* Restrict association to stations that support shortslot
 						 */
-	bool ignore_bcns = TRUE;	/* Ignore legacy beacons on the same channel */
+	bool ignore_bcns = true;	/* Ignore legacy beacons on the same channel */
 	bool ofdm_basic = FALSE;	/* Make 6, 12, and 24 basic rates */
 	int preamble = WLC_PLCP_LONG;	/* Advertise and use short preambles (-1/0/1 Auto/Off/On) */
 	bool preamble_restrict = FALSE;	/* Restrict association to stations that support short
@@ -2986,7 +2986,7 @@ int wlc_set_gmode(wlc_info_t *wlc, u8 gm
 		return BCME_RANGE;
 
 	/* update configuration value */
-	if (config == TRUE)
+	if (config == true)
 		wlc_protection_upd(wlc, WLC_PROT_G_USER, gmode);
 
 	/* Clear supported rates filter */
@@ -3012,9 +3012,9 @@ int wlc_set_gmode(wlc_info_t *wlc, u8 gm
 		break;
 
 	case GMODE_ONLY:
-		ofdm_basic = TRUE;
+		ofdm_basic = true;
 		preamble = WLC_PLCP_SHORT;
-		preamble_restrict = TRUE;
+		preamble_restrict = true;
 		break;
 
 	case GMODE_PERFORMANCE:
@@ -3023,10 +3023,10 @@ int wlc_set_gmode(wlc_info_t *wlc, u8 gm
 					 &wlc->sup_rates_override);
 
 		shortslot = WLC_SHORTSLOT_ON;
-		shortslot_restrict = TRUE;
-		ofdm_basic = TRUE;
+		shortslot_restrict = true;
+		ofdm_basic = true;
 		preamble = WLC_PLCP_SHORT;
-		preamble_restrict = TRUE;
+		preamble_restrict = true;
 		break;
 
 	default:
@@ -3159,7 +3159,7 @@ int wlc_set_nmode(wlc_info_t *wlc, s32 n
 	case WL_11N_3x3:
 		ASSERT(WLC_PHY_11N_CAP(wlc->band));
 		/* force GMODE_AUTO if NMODE is ON */
-		wlc_set_gmode(wlc, GMODE_AUTO, TRUE);
+		wlc_set_gmode(wlc, GMODE_AUTO, true);
 		if (nmode == WL_11N_3x3)
 			wlc->pub->_n_enab = SUPPORT_HT;
 		else
@@ -3196,7 +3196,7 @@ static int wlc_set_rateset(wlc_info_t *w
 	bandunit = wlc->band->bandunit;
 	bcopy((char *)&rs, (char *)&new, sizeof(wlc_rateset_t));
 	if (wlc_rate_hwrs_filter_sort_validate
-	    (&new, &wlc->bandstate[bandunit]->hw_rateset, TRUE,
+	    (&new, &wlc->bandstate[bandunit]->hw_rateset, true,
 	     wlc->stf->txstreams))
 		goto good;
 
@@ -3207,7 +3207,7 @@ static int wlc_set_rateset(wlc_info_t *w
 		if (wlc_rate_hwrs_filter_sort_validate(&new,
 						       &wlc->
 						       bandstate[bandunit]->
-						       hw_rateset, TRUE,
+						       hw_rateset, true,
 						       wlc->stf->txstreams))
 			goto good;
 	}
@@ -3379,7 +3379,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			if (!wlc->pub->up && IS_MBAND_UNLOCKED(wlc)) {
 				if (wlc->band->bandunit !=
 				    CHSPEC_WLCBANDUNIT(chspec))
-					wlc->bandinit_pending = TRUE;
+					wlc->bandinit_pending = true;
 				else
 					wlc->bandinit_pending = FALSE;
 			}
@@ -3452,7 +3452,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		break;
 
 	case WLC_GET_SHMEM:
-		ta_ok = TRUE;
+		ta_ok = true;
 
 		/* optional band is stored in the second integer of incoming buffer */
 		band =
@@ -3473,7 +3473,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		break;
 
 	case WLC_SET_SHMEM:
-		ta_ok = TRUE;
+		ta_ok = true;
 
 		/* optional band is stored in the second integer of incoming buffer */
 		band =
@@ -3495,7 +3495,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		break;
 
 	case WLC_R_REG:	/* MAC registers */
-		ta_ok = TRUE;
+		ta_ok = true;
 		r = (rw_reg_t *) arg;
 		band = WLC_BAND_AUTO;
 
@@ -3531,7 +3531,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		break;
 
 	case WLC_W_REG:
-		ta_ok = TRUE;
+		ta_ok = true;
 		r = (rw_reg_t *) arg;
 		band = WLC_BAND_AUTO;
 
@@ -4007,7 +4007,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			break;
 		}
 
-		wlc->wake = val ? TRUE : FALSE;
+		wlc->wake = val ? true : FALSE;
 
 		/* if down, we're done */
 		if (!wlc->pub->up)
@@ -4167,7 +4167,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 
 		if (AP_ENAB(wlc->pub) && wlc->clk) {
 			wlc_update_beacon(wlc);
-			wlc_update_probe_resp(wlc, TRUE);
+			wlc_update_probe_resp(wlc, true);
 		}
 		break;
 
@@ -4180,7 +4180,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 
 	case WLC_SET_GMODE:
 		if (!wlc->pub->associated)
-			bcmerror = wlc_set_gmode(wlc, (u8) val, TRUE);
+			bcmerror = wlc_set_gmode(wlc, (u8) val, true);
 		else {
 			bcmerror = BCME_ASSOCIATED;
 			break;
@@ -4277,7 +4277,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			if (wlc->pub->up && AP_ENAB(wlc->pub)
 			    && wlc->pub->associated) {
 				wlc_update_beacon(wlc);
-				wlc_update_probe_resp(wlc, TRUE);
+				wlc_update_probe_resp(wlc, true);
 			}
 			break;
 		}
@@ -4321,7 +4321,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 			/* treat the 'val' parm as the key id */
 			key = WSEC_BSS_DEFAULT_KEY(bsscfg);
 			if (key != NULL) {
-				*pval = key->id == val ? TRUE : FALSE;
+				*pval = key->id == val ? true : FALSE;
 			} else {
 				bcmerror = BCME_BADKEYIDX;
 			}
@@ -4764,8 +4764,8 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 	/* convenience int ptr for 4-byte gets (requires int aligned arg) */
 	ret_int_ptr = (s32 *) arg;
 
-	bool_val = (int_val != 0) ? TRUE : FALSE;
-	bool_val2 = (int_val2 != 0) ? TRUE : FALSE;
+	bool_val = (int_val != 0) ? true : FALSE;
+	bool_val2 = (int_val2 != 0) ? true : FALSE;
 
 	WL_TRACE(("wl%d: %s: id %d\n", wlc->pub->unit, __func__,
 		  IOV_ID(actionid)));
@@ -4799,7 +4799,7 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 			/* Remove override bit and clip to max qdbm value */
 			qdbm = (u8)min_t(u32, (int_val & ~WL_TXPWR_OVERRIDE), 0xff);
 			/* Extract override setting */
-			override = (int_val & WL_TXPWR_OVERRIDE) ? TRUE : FALSE;
+			override = (int_val & WL_TXPWR_OVERRIDE) ? true : FALSE;
 			err =
 			    wlc_phy_txpower_set(wlc->band->pi, qdbm, override);
 			break;
@@ -5025,12 +5025,12 @@ bool wlc_chipmatch(u16 vendor, u16 devic
 	}
 
 	if ((device == BCM43224_D11N_ID) || (device == BCM43225_D11N2G_ID))
-		return TRUE;
+		return true;
 
 	if (device == BCM4313_D11N2G_ID)
-		return TRUE;
+		return true;
 	if ((device == BCM43236_D11N_ID) || (device == BCM43236_D11N2G_ID))
-		return TRUE;
+		return true;
 
 	WL_ERROR(("wlc_chipmatch: unknown device id %04x\n", device));
 	return FALSE;
@@ -5209,7 +5209,7 @@ void wlc_device_removed(void *arg)
  * 'prec' is the precedence number that has already been mapped
  * from the packet priority.
  *
- * Returns TRUE if packet consumed (queued), FALSE if not.
+ * Returns true if packet consumed (queued), FALSE if not.
  */
 bool BCMFASTPATH
 wlc_prec_enq(wlc_info_t *wlc, struct pktq *q, void *pkt, int prec)
@@ -5268,7 +5268,7 @@ wlc_prec_enq_head(wlc_info_t *wlc, struc
 		}
 
 		ASSERT(0);
-		PKTFREE(wlc->osh, p, TRUE);
+		PKTFREE(wlc->osh, p, true);
 		WLCNTINCR(wlc->pub->_cnt->txnobuf);
 	}
 
@@ -5279,7 +5279,7 @@ wlc_prec_enq_head(wlc_info_t *wlc, struc
 		p = pktq_penq(q, prec, pkt);
 	ASSERT(p != NULL);
 
-	return TRUE;
+	return true;
 }
 
 void BCMFASTPATH wlc_txq_enq(void *ctx, struct scb *scb, void *sdu, uint prec)
@@ -5300,7 +5300,7 @@ void BCMFASTPATH wlc_txq_enq(void *ctx,
 				  wlc->pub->unit));
 
 		/* ASSERT(9 == 8); *//* XXX we might hit this condtion in case packet flooding from mac80211 stack */
-		PKTFREE(wlc->osh, sdu, TRUE);
+		PKTFREE(wlc->osh, sdu, true);
 		WLCNTINCR(wlc->pub->_cnt->txnobuf);
 	}
 
@@ -5374,7 +5374,7 @@ void BCMFASTPATH wlc_send_q(wlc_info_t *
 	if (in_send_q)
 		return;
 	else
-		in_send_q = TRUE;
+		in_send_q = true;
 
 	prec_map = wlc->tx_prec_map;
 
@@ -5390,7 +5390,7 @@ void BCMFASTPATH wlc_send_q(wlc_info_t *
 			err = wlc_prep_pdu(wlc, pkt[0], &fifo);
 			if (!err) {
 				for (i = 0; i < count; i++) {
-					wlc_txfifo(wlc, fifo, pkt[i], TRUE, 1);
+					wlc_txfifo(wlc, fifo, pkt[i], true, 1);
 				}
 			}
 		}
@@ -5463,7 +5463,7 @@ wlc_txfifo(wlc_info_t *wlc, uint fifo, v
 	}
 
 	if (WLC_WAR16165(wlc))
-		wlc_war16165(wlc, TRUE);
+		wlc_war16165(wlc, true);
 
 #ifdef WLC_HIGH_ONLY
 	if (RPCTX_ENAB(wlc->pub)) {
@@ -5750,7 +5750,7 @@ static bool wlc_phy_rspec_check(wlc_info
 		ASSERT(RSPEC_STF(rspec) == PHY_TXC1_MODE_SISO);
 	}
 
-	return TRUE;
+	return true;
 }
 
 u16 BCMFASTPATH wlc_phytxctl1_calc(wlc_info_t *wlc, ratespec_t rspec)
@@ -5996,7 +5996,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 
 	for (k = 0; k < hw->max_rates; k++) {
 		is_mcs[k] =
-		    txrate[k]->flags & IEEE80211_TX_RC_MCS ? TRUE : FALSE;
+		    txrate[k]->flags & IEEE80211_TX_RC_MCS ? true : FALSE;
 		if (!is_mcs[k]) {
 			ASSERT(!(tx_info->flags & IEEE80211_TX_CTL_AMPDU));
 			if ((txrate[k]->idx >= 0)
@@ -6008,7 +6008,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 				short_preamble[k] =
 				    txrate[k]->
 				    flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE ?
-				    TRUE : FALSE;
+				    true : FALSE;
 			} else {
 				ASSERT((txrate[k]->idx >= 0) &&
 				       (txrate[k]->idx <
@@ -6024,10 +6024,10 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 		 */
 		use_rts |=
 		    txrate[k]->
-		    flags & IEEE80211_TX_RC_USE_RTS_CTS ? TRUE : FALSE;
+		    flags & IEEE80211_TX_RC_USE_RTS_CTS ? true : FALSE;
 		use_cts |=
 		    txrate[k]->
-		    flags & IEEE80211_TX_RC_USE_CTS_PROTECT ? TRUE : FALSE;
+		    flags & IEEE80211_TX_RC_USE_CTS_PROTECT ? true : FALSE;
 
 		if (is_mcs[k])
 			rate_val[k] |= NRATE_MCS_INUSE;
@@ -6564,8 +6564,8 @@ void wlc_tbtt(wlc_info_t *wlc, d11regs_t
 			}
 
 			wl_add_timer(wlc->wl, wlc->wdtimer,
-				     wlc_watchdog_backup_bi(wlc), TRUE);
-			wlc->WDarmed = TRUE;
+				     wlc_watchdog_backup_bi(wlc), true);
+			wlc->WDarmed = true;
 		}
 	}
 
@@ -6879,7 +6879,7 @@ wlc_dotxstatus(wlc_info_t *wlc, tx_statu
 	}
 
 	totlen = pkttotlen(osh, p);
-	free_pdu = TRUE;
+	free_pdu = true;
 
 	wlc_txfifo_complete(wlc, queue, 1);
 
@@ -6902,7 +6902,7 @@ wlc_dotxstatus(wlc_info_t *wlc, tx_statu
  fatal:
 	ASSERT(0);
 	if (p)
-		PKTFREE(osh, p, TRUE);
+		PKTFREE(osh, p, true);
 
 #ifdef WLC_HIGH_ONLY
 	/* If this is a split driver, do the big-hammer here.
@@ -6910,7 +6910,7 @@ wlc_dotxstatus(wlc_info_t *wlc, tx_statu
 	 */
 	wl_init(wlc->wl);
 #endif
-	return TRUE;
+	return true;
 
 }
 
@@ -7203,7 +7203,7 @@ void wlc_bss_list_free(wlc_info_t *wlc,
 
 /* Process received frames */
 /*
- * Return TRUE if more frames need to be processed. FALSE otherwise.
+ * Return true if more frames need to be processed. FALSE otherwise.
  * Param 'bound' indicates max. # frames to process before break out.
  */
 /* WLC_HIGH_API */
@@ -7704,7 +7704,7 @@ bool wlc_valid_rate(wlc_info_t *wlc, rat
 
 	for (i = 0; i < hw_rateset->count; i++)
 		if (hw_rateset->rates[i] == RSPEC2RATE(rspec))
-			return TRUE;
+			return true;
  error:
 	if (verbose) {
 		WL_ERROR(("wl%d: wlc_valid_rate: rate spec 0x%x not in hw_rateset\n", wlc->pub->unit, rspec));
@@ -7725,13 +7725,13 @@ static void wlc_update_mimo_band_bwcap(w
 		if (band->bandtype == WLC_BAND_5G) {
 			if ((bwcap == WLC_N_BW_40ALL)
 			    || (bwcap == WLC_N_BW_20IN2G_40IN5G))
-				band->mimo_cap_40 = TRUE;
+				band->mimo_cap_40 = true;
 			else
 				band->mimo_cap_40 = FALSE;
 		} else {
 			ASSERT(band->bandtype == WLC_BAND_2G);
 			if (bwcap == WLC_N_BW_40ALL)
-				band->mimo_cap_40 = TRUE;
+				band->mimo_cap_40 = true;
 			else
 				band->mimo_cap_40 = FALSE;
 		}
@@ -7938,7 +7938,7 @@ void wlc_bss_update_beacon(wlc_info_t *w
 		       (wlc, wlc->bcn_rspec,
 			CHSPEC_IS2G(cfg->current_bss->
 				    chanspec) ? WLC_BAND_2G : WLC_BAND_5G,
-			TRUE));
+			true));
 
 		/* update the template and ucode shm */
 		wlc_bcn_prb_template(wlc, FC_BEACON, wlc->bcn_rspec, cfg, bcn,
@@ -8300,7 +8300,7 @@ mac80211_wlc_set_nrate(wlc_info_t *wlc,
 		rspec |= RSPEC_SHORT_GI;
 
 	if ((rate != 0)
-	    && !wlc_valid_rate(wlc, rspec, cur_band->bandtype, TRUE)) {
+	    && !wlc_valid_rate(wlc, rspec, cur_band->bandtype, true)) {
 		return rate;
 	}
 
@@ -8494,7 +8494,7 @@ void wlc_ht_mimops_cap_update(wlc_info_t
 
 	if (AP_ENAB(wlc->pub) && wlc->clk) {
 		wlc_update_beacon(wlc);
-		wlc_update_probe_resp(wlc, TRUE);
+		wlc_update_probe_resp(wlc, true);
 	}
 }
 
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.h
@@ -119,7 +119,7 @@ typedef struct wlc_bss_list {
  */
 #define WLC_PORTOPEN(cfg) \
 	(((cfg)->WPA_auth != WPA_AUTH_DISABLED && WSEC_ENABLED((cfg)->wsec)) ? \
-	(cfg)->wsec_portopen : TRUE)
+	(cfg)->wsec_portopen : true)
 
 #define PS_ALLOWED(wlc)	wlc_ps_allowed(wlc)
 #define STAY_AWAKE(wlc) wlc_stay_awake(wlc)
@@ -191,7 +191,7 @@ extern const u8 prio2fifo[];
 #define WLC_PLLREQ_FLIP		0x4	/* hold/release pll for some short operation */
 
 /* Do we support this rate? */
-#define VALID_RATE_DBG(wlc, rspec) wlc_valid_rate(wlc, rspec, WLC_BAND_AUTO, TRUE)
+#define VALID_RATE_DBG(wlc, rspec) wlc_valid_rate(wlc, rspec, WLC_BAND_AUTO, true)
 
 /*
  * Macros to check if AP or STA is active.
@@ -270,7 +270,7 @@ typedef struct wlc_stf {
 	u16 phytxant;	/* phyTx antenna setting in txheader */
 
 	u8 ss_opmode;	/* singlestream Operational mode, 0:siso; 1:cdd */
-	bool ss_algosel_auto;	/* if TRUE, use wlc->stf->ss_algo_channel; */
+	bool ss_algosel_auto;	/* if true, use wlc->stf->ss_algo_channel; */
 	/* else use wlc->band->stf->ss_mode_band; */
 	u16 ss_algo_channel;	/* ss based on per-channel algo: 0: SISO, 1: CDD 2: STBC */
 	u8 no_cddstbc;	/* stf override, 1: no CDD (or STBC) allowed */
@@ -500,7 +500,7 @@ struct wlc_hw_info {
 #ifdef BCMSDIO
 	void *sdh;
 #endif
-	bool ucode_loaded;	/* TRUE after ucode downloaded */
+	bool ucode_loaded;	/* true after ucode downloaded */
 
 #ifdef WLC_LOW_ONLY
 	struct wl_timer *wdtimer;	/* timer for watchdog routine */
@@ -765,7 +765,7 @@ struct wlc_info {
 	s8 barker_preamble;	/* current Barker Preamble Mode */
 	s8 shortslot_override;	/* 11g ShortSlot override */
 	bool include_legacy_erp;	/* include Legacy ERP info elt ID 47 as well as g ID 42 */
-	bool barker_overlap_control;	/* TRUE: be aware of overlapping BSSs for barker */
+	bool barker_overlap_control;	/* true: be aware of overlapping BSSs for barker */
 	bool ignore_bcns;	/* override: ignore non shortslot bcns in a 11g network */
 	bool legacy_probe;	/* restricts probe requests to CCK rates */
 
@@ -846,7 +846,7 @@ struct antsel_info {
 
 /* sum the individual fifo tx pending packet counts */
 #if defined(WLC_HIGH_ONLY)
-#define TXPKTPENDTOT(wlc)		(wlc_rpctx_txpktpend((wlc)->rpctx, 0, TRUE))
+#define TXPKTPENDTOT(wlc)		(wlc_rpctx_txpktpend((wlc)->rpctx, 0, true))
 #define TXPKTPENDGET(wlc, fifo)		(wlc_rpctx_txpktpend((wlc)->rpctx, (fifo), FALSE))
 #define TXPKTPENDINC(wlc, fifo, val)	(wlc_rpctx_txpktpendinc((wlc)->rpctx, (fifo), (val)))
 #define TXPKTPENDDEC(wlc, fifo, val)	(wlc_rpctx_txpktpenddec((wlc)->rpctx, (fifo), (val)))
--- a/drivers/staging/brcm80211/sys/wlc_rate.c
+++ b/drivers/staging/brcm80211/sys/wlc_rate.c
@@ -268,12 +268,12 @@ static bool wlc_rateset_valid(wlc_ratese
 		return FALSE;
 
 	if (!check_brate)
-		return TRUE;
+		return true;
 
 	/* error if no basic rates */
 	for (idx = 0; idx < rs->count; idx++) {
 		if (rs->rates[idx] & WLC_RATE_FLAG)
-			return TRUE;
+			return true;
 	}
 	return FALSE;
 }
@@ -326,7 +326,7 @@ wlc_rate_hwrs_filter_sort_validate(wlc_r
 		rs->mcs[i] = (rs->mcs[i] & hw_rs->mcs[i]);
 
 	if (wlc_rateset_valid(rs, check_brate))
-		return TRUE;
+		return true;
 	else
 		return FALSE;
 }
--- a/drivers/staging/brcm80211/sys/wlc_rpctx.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpctx.h
@@ -34,7 +34,7 @@ struct wlc_rpc_phy {
 	struct rpc_info *rpc;
 };
 
-#define RPCTX_ENAB(pub)		(TRUE)
+#define RPCTX_ENAB(pub)		(true)
 extern rpctx_info_t *wlc_rpctx_attach(wlc_pub_t *pub, struct wlc_info *wlc);
 extern int wlc_rpctx_fifoinit(rpctx_info_t *rpctx, uint fifo, uint ntxd);
 extern void wlc_rpctx_detach(rpctx_info_t *rpctx);
--- a/drivers/staging/brcm80211/sys/wlc_scb.h
+++ b/drivers/staging/brcm80211/sys/wlc_scb.h
@@ -80,5 +80,5 @@ struct scb {
 #define SCB_SEQNUM(scb, prio)	((scb)->seqnum[(prio)])
 #define SCB_PS(a)		NULL
 #define SCB_STBC_CAP(a)		((a)->flags & SCB_STBCCAP)
-#define SCB_AMPDU(a)		TRUE
+#define SCB_AMPDU(a)		true
 #endif				/* _wlc_scb_h_ */
--- a/drivers/staging/brcm80211/sys/wlc_stf.c
+++ b/drivers/staging/brcm80211/sys/wlc_stf.c
@@ -79,7 +79,7 @@ static void wlc_stf_stbc_rx_ht_update(wl
 
 	if (wlc->pub->up) {
 		wlc_update_beacon(wlc);
-		wlc_update_probe_resp(wlc, TRUE);
+		wlc_update_probe_resp(wlc, true);
 	}
 }
 
@@ -97,12 +97,12 @@ void wlc_tempsense_upd(wlc_info_t *wlc)
 	if (wlc->stf->txchain == wlc->stf->hw_txchain) {
 		if (txchain && (txchain < wlc->stf->hw_txchain)) {
 			/* turn off 1 tx chain */
-			wlc_stf_txchain_set(wlc, txchain, TRUE);
+			wlc_stf_txchain_set(wlc, txchain, true);
 		}
 	} else if (wlc->stf->txchain < wlc->stf->hw_txchain) {
 		if (txchain == wlc->stf->hw_txchain) {
 			/* turn back on txchain */
-			wlc_stf_txchain_set(wlc, txchain, TRUE);
+			wlc_stf_txchain_set(wlc, txchain, true);
 		}
 	}
 }
@@ -172,7 +172,7 @@ static bool wlc_stf_stbc_tx_set(wlc_info
 	wlc->bandstate[BAND_2G_INDEX]->band_stf_stbc_tx = (s8) int_val;
 	wlc->bandstate[BAND_5G_INDEX]->band_stf_stbc_tx = (s8) int_val;
 
-	return TRUE;
+	return true;
 }
 
 bool wlc_stf_stbc_rx_set(wlc_info_t *wlc, s32 int_val)
@@ -189,7 +189,7 @@ bool wlc_stf_stbc_rx_set(wlc_info_t *wlc
 	}
 
 	wlc_stf_stbc_rx_ht_update(wlc, int_val);
-	return TRUE;
+	return true;
 }
 
 static int wlc_stf_txcore_set(wlc_info_t *wlc, u8 Nsts, u8 core_mask)
@@ -421,7 +421,7 @@ int wlc_stf_attach(wlc_info_t *wlc)
 	wlc->bandstate[BAND_5G_INDEX]->band_stf_stbc_tx = OFF;
 
 	if (WLC_STBC_CAP_PHY(wlc)) {
-		wlc->stf->ss_algosel_auto = TRUE;
+		wlc->stf->ss_algosel_auto = true;
 		wlc->stf->ss_algo_channel = (u16) -1;	/* Init the default value */
 	}
 	return 0;
--- a/drivers/staging/brcm80211/util/aiutils.c
+++ b/drivers/staging/brcm80211/util/aiutils.c
@@ -39,7 +39,7 @@ get_erom_ent(si_t *sih, u32 **eromptr, u
 	u32 ent;
 	uint inv = 0, nom = 0;
 
-	while (TRUE) {
+	while (true) {
 		ent = R_REG(si_osh(sih), *eromptr);
 		(*eromptr)++;
 
@@ -224,7 +224,7 @@ void ai_scan(si_t *sih, void *regs, uint
 			    get_asd(sih, &eromptr, 0, 0, AD_ST_BRIDGE, &addrl,
 				    &addrh, &sizel, &sizeh);
 			if (asd != 0)
-				br = TRUE;
+				br = true;
 			else if ((addrh != 0) || (sizeh != 0)
 				 || (sizel != SI_CORE_SIZE)) {
 				SI_ERROR(("First Slave ASD for core 0x%04x malformed " "(0x%08x)\n", cid, asd));
@@ -507,7 +507,7 @@ uint ai_corereg(si_t *sih, uint coreidx,
 
 	if (BUSTYPE(sih->bustype) == SI_BUS) {
 		/* If internal bus, we can always get at everything */
-		fast = TRUE;
+		fast = true;
 		/* map if does not exist */
 		if (!sii->regs[coreidx]) {
 			sii->regs[coreidx] = REG_MAP(sii->coresba[coreidx],
@@ -521,14 +521,14 @@ uint ai_corereg(si_t *sih, uint coreidx,
 		if ((sii->coreid[coreidx] == CC_CORE_ID) && SI_FAST(sii)) {
 			/* Chipc registers are mapped at 12KB */
 
-			fast = TRUE;
+			fast = true;
 			r = (u32 *) ((char *)sii->curmap +
 					PCI_16KB0_CCREGS_OFFSET + regoff);
 		} else if (sii->pub.buscoreidx == coreidx) {
 			/* pci registers are at either in the last 2KB of an 8KB window
 			 * or, in pcie and pci rev 13 at 8KB
 			 */
-			fast = TRUE;
+			fast = true;
 			if (SI_FAST(sii))
 				r = (u32 *) ((char *)sii->curmap +
 						PCI_16KB0_PCIREGS_OFFSET +
--- a/drivers/staging/brcm80211/util/bcmotp.c
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -936,7 +936,7 @@ otp_read_region(si_t *sih, int region, u
 
 	wasup = si_is_otp_powered(sih);
 	if (!wasup)
-		si_otp_power(sih, TRUE);
+		si_otp_power(sih, true);
 
 	if (!si_is_otp_powered(sih) || si_is_otp_disabled(sih)) {
 		err = BCME_NOTREADY;
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -410,7 +410,7 @@ int srom_parsecis(osl_t *osh, u8 *pcis[]
 		cis = *pcis++;
 		i = 0;
 		funcid = 0;
-		standard_cis = TRUE;
+		standard_cis = true;
 		do {
 			if (standard_cis) {
 				tup = cis[i++];
@@ -722,7 +722,7 @@ int srom_parsecis(osl_t *osh, u8 *pcis[]
 					if (tlen >= 5)
 						varbuf_append(&b, vstr_ag, 3,
 							      cis[i + 4]);
-					ag_init = TRUE;
+					ag_init = true;
 					break;
 
 				case HNBU_ANT5G:
@@ -1340,7 +1340,7 @@ int srom_parsecis(osl_t *osh, u8 *pcis[]
 								   SROM3_SWRGN_OFF,
 								   &b);
 						/* 2.4G antenna gain is included in SROM */
-						ag_init = TRUE;
+						ag_init = true;
 						/* Ethernet MAC address is included in SROM */
 						eabuf[0] = 0;
 						boardnum = -1;
@@ -1868,7 +1868,7 @@ static int initvars_srom_pci(si_t *sih,
 	if (si_is_sprom_available(sih)) {
 		err =
 		    sprom_read_pci(osh, sih, sromwindow, 0, srom, SROM_WORDS,
-				   TRUE);
+				   true);
 
 		if ((srom[SROM4_SIGN] == SROM4_SIGNATURE) ||
 		    (((sih->buscoretype == PCIE_CORE_ID)
@@ -1878,7 +1878,7 @@ static int initvars_srom_pci(si_t *sih,
 			/* sromrev >= 4, read more */
 			err =
 			    sprom_read_pci(osh, sih, sromwindow, 0, srom,
-					   SROM4_WORDS, TRUE);
+					   SROM4_WORDS, true);
 			sromrev = srom[SROM4_CRCREV] & 0xff;
 			if (err)
 				BS_ERROR(("%s: srom %d, bad crc\n", __func__,
@@ -1916,7 +1916,7 @@ static int initvars_srom_pci(si_t *sih,
 		value = si_getdevpathvar(sih, "sromrev");
 		if (value) {
 			sromrev = (u8) simple_strtoul(value, NULL, 0);
-			flash = TRUE;
+			flash = true;
 			goto varscont;
 		}
 
--- a/drivers/staging/brcm80211/util/bcmwifi.c
+++ b/drivers/staging/brcm80211/util/bcmwifi.c
@@ -26,24 +26,24 @@
  * Verify the chanspec is using a legal set of parameters, i.e. that the
  * chanspec specified a band, bw, ctl_sb and channel and that the
  * combination could be legal given any set of circumstances.
- * RETURNS: TRUE is the chanspec is malformed, false if it looks good.
+ * RETURNS: true is the chanspec is malformed, false if it looks good.
  */
 bool wf_chspec_malformed(chanspec_t chanspec)
 {
 	/* must be 2G or 5G band */
 	if (!CHSPEC_IS5G(chanspec) && !CHSPEC_IS2G(chanspec))
-		return TRUE;
+		return true;
 	/* must be 20 or 40 bandwidth */
 	if (!CHSPEC_IS40(chanspec) && !CHSPEC_IS20(chanspec))
-		return TRUE;
+		return true;
 
 	/* 20MHZ b/w must have no ctl sb, 40 must have a ctl sb */
 	if (CHSPEC_IS20(chanspec)) {
 		if (!CHSPEC_SB_NONE(chanspec))
-			return TRUE;
+			return true;
 	} else {
 		if (!CHSPEC_SB_UPPER(chanspec) && !CHSPEC_SB_LOWER(chanspec))
-			return TRUE;
+			return true;
 	}
 
 	return FALSE;
--- a/drivers/staging/brcm80211/util/bcmwpa.c
+++ b/drivers/staging/brcm80211/util/bcmwpa.c
@@ -30,7 +30,7 @@ bool bcm_is_wfa_ie(u8 *ie, u8 **tlvs, ui
 	if ((ie[TLV_LEN_OFF] > (WFA_OUI_LEN + 1)) &&
 	    !bcmp(&ie[TLV_BODY_OFF], WFA_OUI, WFA_OUI_LEN) &&
 	    type == ie[TLV_BODY_OFF + WFA_OUI_LEN]) {
-		return TRUE;
+		return true;
 	}
 
 	/* point to the next ie */
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -167,7 +167,7 @@ typedef struct dma_info {
 
 /* DMA Scatter-gather list is supported. Note this is limited to TX direction only */
 #ifdef BCMDMASGLISTOSL
-#define DMASGLIST_ENAB TRUE
+#define DMASGLIST_ENAB true
 #else
 #define DMASGLIST_ENAB FALSE
 #endif				/* BCMDMASGLISTOSL */
@@ -766,10 +766,10 @@ static bool _dma_descriptor_align(dma_in
 				return FALSE;
 		}
 	}
-	return TRUE;
+	return true;
 }
 
-/* return TRUE if this dma engine supports DmaExtendedAddrChanges, otherwise FALSE */
+/* return true if this dma engine supports DmaExtendedAddrChanges, otherwise FALSE */
 static bool _dma_isaddrext(dma_info_t *di)
 {
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
@@ -781,13 +781,13 @@ static bool _dma_isaddrext(dma_info_t *d
 				DMA_ERROR(("%s: _dma_isaddrext: DMA64 tx doesn't have AE set\n", di->name));
 				ASSERT(0);
 			}
-			return TRUE;
+			return true;
 		} else if (di->d64rxregs != NULL) {
 			if (!_dma64_addrext(di->osh, di->d64rxregs)) {
 				DMA_ERROR(("%s: _dma_isaddrext: DMA64 rx doesn't have AE set\n", di->name));
 				ASSERT(0);
 			}
-			return TRUE;
+			return true;
 		}
 		return FALSE;
 	} else if (DMA32_ENAB(di)) {
@@ -1104,12 +1104,12 @@ static bool BCMFASTPATH _dma_rxfill(dma_
 				if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 					if (dma64_rxidle(di)) {
 						DMA_ERROR(("%s: rxfill64: ring is empty !\n", di->name));
-						ring_empty = TRUE;
+						ring_empty = true;
 					}
 				} else if (DMA32_ENAB(di)) {
 					if (dma32_rxidle(di)) {
 						DMA_ERROR(("%s: rxfill32: ring is empty !\n", di->name));
-						ring_empty = TRUE;
+						ring_empty = true;
 					}
 				} else
 					ASSERT(0);
@@ -1237,7 +1237,7 @@ static void _dma_rxreclaim(dma_info_t *d
 
 	DMA_TRACE(("%s: dma_rxreclaim\n", di->name));
 
-	while ((p = _dma_getnextrxp(di, TRUE)))
+	while ((p = _dma_getnextrxp(di, true)))
 		PKTFREE(di->osh, p, FALSE);
 }
 
@@ -1501,7 +1501,7 @@ static void dma32_txreclaim(dma_info_t *
 		return;
 
 	while ((p = dma32_getnexttxp(di, range)))
-		PKTFREE(di->osh, p, TRUE);
+		PKTFREE(di->osh, p, true);
 }
 
 static bool dma32_txstopped(dma_info_t *di)
@@ -1576,7 +1576,7 @@ static bool dma32_alloc(dma_info_t *di,
 		ASSERT(IS_ALIGNED((uintptr) di->rxd32, align));
 	}
 
-	return TRUE;
+	return true;
 }
 
 static bool dma32_txreset(dma_info_t *di)
@@ -1584,7 +1584,7 @@ static bool dma32_txreset(dma_info_t *di
 	u32 status;
 
 	if (di->ntxd == 0)
-		return TRUE;
+		return true;
 
 	/* suspend tx DMA first */
 	W_REG(di->osh, &di->d32txregs->control, XC_SE);
@@ -1609,7 +1609,7 @@ static bool dma32_rxidle(dma_info_t *di)
 	DMA_TRACE(("%s: dma_rxidle\n", di->name));
 
 	if (di->nrxd == 0)
-		return TRUE;
+		return true;
 
 	return ((R_REG(di->osh, &di->d32rxregs->status) & RS_CD_MASK) ==
 		R_REG(di->osh, &di->d32rxregs->ptr));
@@ -1620,7 +1620,7 @@ static bool dma32_rxreset(dma_info_t *di
 	u32 status;
 
 	if (di->nrxd == 0)
-		return TRUE;
+		return true;
 
 	W_REG(di->osh, &di->d32rxregs->control, 0);
 	SPINWAIT(((status = (R_REG(di->osh,
@@ -1641,7 +1641,7 @@ static bool dma32_rxenabled(dma_info_t *
 static bool dma32_txsuspendedidle(dma_info_t *di)
 {
 	if (di->ntxd == 0)
-		return TRUE;
+		return true;
 
 	if (!(R_REG(di->osh, &di->d32txregs->control) & XC_SE))
 		return 0;
@@ -1771,7 +1771,7 @@ static int dma32_txfast(dma_info_t *di,
 
  outoftxd:
 	DMA_ERROR(("%s: dma_txfast: out of txds\n", di->name));
-	PKTFREE(di->osh, p0, TRUE);
+	PKTFREE(di->osh, p0, true);
 	di->hnddma.txavail = 0;
 	di->hnddma.txnobuf++;
 	return -1;
@@ -2070,7 +2070,7 @@ static void BCMFASTPATH dma64_txreclaim(
 	while ((p = dma64_getnexttxp(di, range))) {
 		/* For unframed data, we don't have any packets to free */
 		if (!(di->hnddma.dmactrlflags & DMA_CTRL_UNFRAMED))
-			PKTFREE(di->osh, p, TRUE);
+			PKTFREE(di->osh, p, true);
 	}
 }
 
@@ -2139,7 +2139,7 @@ static bool dma64_alloc(dma_info_t *di,
 		ASSERT(IS_ALIGNED((uintptr) di->rxd64, align));
 	}
 
-	return TRUE;
+	return true;
 }
 
 static bool dma64_txreset(dma_info_t *di)
@@ -2147,7 +2147,7 @@ static bool dma64_txreset(dma_info_t *di
 	u32 status;
 
 	if (di->ntxd == 0)
-		return TRUE;
+		return true;
 
 	/* suspend tx DMA first */
 	W_REG(di->osh, &di->d64txregs->control, D64_XC_SE);
@@ -2172,7 +2172,7 @@ static bool dma64_rxidle(dma_info_t *di)
 	DMA_TRACE(("%s: dma_rxidle\n", di->name));
 
 	if (di->nrxd == 0)
-		return TRUE;
+		return true;
 
 	return ((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_CD_MASK) ==
 		(R_REG(di->osh, &di->d64rxregs->ptr) & D64_RS0_CD_MASK));
@@ -2183,7 +2183,7 @@ static bool dma64_rxreset(dma_info_t *di
 	u32 status;
 
 	if (di->nrxd == 0)
-		return TRUE;
+		return true;
 
 	W_REG(di->osh, &di->d64rxregs->control, 0);
 	SPINWAIT(((status =
@@ -2205,7 +2205,7 @@ static bool dma64_txsuspendedidle(dma_in
 {
 
 	if (di->ntxd == 0)
-		return TRUE;
+		return true;
 
 	if (!(R_REG(di->osh, &di->d64txregs->control) & D64_XC_SE))
 		return 0;
@@ -2419,7 +2419,7 @@ static int BCMFASTPATH dma64_txfast(dma_
 
  outoftxd:
 	DMA_ERROR(("%s: dma_txfast: out of txds !!!\n", di->name));
-	PKTFREE(di->osh, p0, TRUE);
+	PKTFREE(di->osh, p0, true);
 	di->hnddma.txavail = 0;
 	di->hnddma.txnobuf++;
 	return -1;
@@ -2679,7 +2679,7 @@ uint dma_addrwidth(si_t *sih, void *dmar
 			     (sih->buscoretype == PCIE_CORE_ID)))
 				return DMADDRWIDTH_64;
 
-		/* DMA64 is always 32-bit capable, AE is always TRUE */
+		/* DMA64 is always 32-bit capable, AE is always true */
 		ASSERT(_dma64_addrext(osh, (dma64regs_t *) dmaregs));
 
 		return DMADDRWIDTH_32;
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -299,7 +299,7 @@ typedef struct {
 	u32 res_mask;	/* resources (chip specific) */
 	s8 action;		/* action */
 	u32 depend_mask;	/* changes to the dependancies mask */
-	 bool(*filter) (si_t *sih);	/* action is taken when filter is NULL or return TRUE */
+	 bool(*filter) (si_t *sih);	/* action is taken when filter is NULL or return true */
 } pmu_res_depend_t;
 
 /* Resource dependancies mask change action */
@@ -562,26 +562,26 @@ static const pmu_res_depend_t bcm4330a0_
 	PMURES_BIT(RES4330_HT_AVAIL), RES_DEPEND_ADD, 0, NULL}
 };
 
-/* TRUE if the power topology uses the buck boost to provide 3.3V to VDDIO_RF and WLAN PA */
+/* true if the power topology uses the buck boost to provide 3.3V to VDDIO_RF and WLAN PA */
 static bool si_pmu_res_depfltr_bb(si_t *sih)
 {
 	return (sih->boardflags & BFL_BUCKBOOST) != 0;
 }
 
-/* TRUE if the power topology doesn't use the cbuck. Key on chiprev also if the chip is BCM4325. */
+/* true if the power topology doesn't use the cbuck. Key on chiprev also if the chip is BCM4325. */
 static bool si_pmu_res_depfltr_ncb(si_t *sih)
 {
 
 	return (sih->boardflags & BFL_NOCBUCK) != 0;
 }
 
-/* TRUE if the power topology uses the PALDO */
+/* true if the power topology uses the PALDO */
 static bool si_pmu_res_depfltr_paldo(si_t *sih)
 {
 	return (sih->boardflags & BFL_PALDO) != 0;
 }
 
-/* TRUE if the power topology doesn't use the PALDO */
+/* true if the power topology doesn't use the PALDO */
 static bool si_pmu_res_depfltr_npaldo(si_t *sih)
 {
 	return (sih->boardflags & BFL_PALDO) == 0;
@@ -2025,7 +2025,7 @@ si_pmu_res_uptime(si_t *sih, osl_t *osh,
 	for (i = 0; i <= PMURES_MAX_RESNUM; i++) {
 		if (!(deps & PMURES_BIT(i)))
 			continue;
-		deps &= ~si_pmu_res_deps(sih, osh, cc, PMURES_BIT(i), TRUE);
+		deps &= ~si_pmu_res_deps(sih, osh, cc, PMURES_BIT(i), true);
 	}
 	si_pmu_res_masks(sih, &min_mask, &max_mask);
 	deps &= ~min_mask;
@@ -2063,7 +2063,7 @@ si_pmu_res_deps(si_t *sih, osl_t *osh, c
 	return !all ? deps : (deps
 			      ? (deps |
 				 si_pmu_res_deps(sih, osh, cc, deps,
-						 TRUE)) : 0);
+						 true)) : 0);
 }
 
 /* power up/down OTP through PMU resources */
@@ -2107,7 +2107,7 @@ void si_pmu_otp_power(si_t *sih, osl_t *
 		u32 otps;
 
 		/* Figure out the dependancies (exclude min_res_mask) */
-		u32 deps = si_pmu_res_deps(sih, osh, cc, rsrcs, TRUE);
+		u32 deps = si_pmu_res_deps(sih, osh, cc, rsrcs, true);
 		u32 min_mask = 0, max_mask = 0;
 		si_pmu_res_masks(sih, &min_mask, &max_mask);
 		deps &= ~min_mask;
@@ -2491,10 +2491,10 @@ bool si_pmu_is_otp_powered(si_t *sih, os
 	case BCM43236_CHIP_ID:
 	case BCM43235_CHIP_ID:
 	case BCM43238_CHIP_ID:
-		st = TRUE;
+		st = true;
 		break;
 	default:
-		st = TRUE;
+		st = true;
 		break;
 	}
 
--- a/drivers/staging/brcm80211/util/linux_osl.c
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -160,7 +160,7 @@ osl_t *osl_attach(void *pdev, uint busty
 	case PCI_BUS:
 	case SI_BUS:
 	case PCMCIA_BUS:
-		osh->pub.mmbus = TRUE;
+		osh->pub.mmbus = true;
 		break;
 	case JTAG_BUS:
 	case SDIO_BUS:
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -290,7 +290,7 @@ static bool pcie_mdiosetblock(pcicore_in
 		return FALSE;
 	}
 
-	return TRUE;
+	return true;
 }
 
 static int
@@ -363,7 +363,7 @@ pcie_mdioread(pcicore_info_t *pi, uint p
 static int
 pcie_mdiowrite(pcicore_info_t *pi, uint physmedia, uint regaddr, uint val)
 {
-	return pcie_mdioop(pi, physmedia, regaddr, TRUE, &val);
+	return pcie_mdioop(pi, physmedia, regaddr, true, &val);
 }
 
 /* ***** Support functions ***** */
@@ -519,7 +519,7 @@ static void pcie_war_aspm_clkreq(pcicore
 
 	if (pi->pcie_war_aspm_ovr != PCIE_ASPM_DISAB) {
 		val16 |= SRSH_CLKREQ_ENB;
-		pi->pcie_pr42767 = TRUE;
+		pi->pcie_pr42767 = true;
 	} else
 		val16 &= ~SRSH_CLKREQ_ENB;
 
@@ -684,7 +684,7 @@ void pcicore_up(void *pch, int state)
 		return;
 
 	/* Restore L1 timer for better performance */
-	pcie_extendL1timer(pi, TRUE);
+	pcie_extendL1timer(pi, true);
 
 	pcie_clkreq_upd(pi, state);
 }
@@ -739,7 +739,7 @@ bool pcicore_pmecap_fast(osl_t *osh)
 	return (pmecap & PME_CAP_PM_STATES) != 0;
 }
 
-/* return TRUE if PM capability exists in the pci config space
+/* return true if PM capability exists in the pci config space
  * Uses and caches the information using core handle
  */
 static bool pcicore_pmecap(pcicore_info_t *pi)
@@ -786,7 +786,7 @@ void pcicore_pmeen(void *pch)
 }
 
 /*
- * Return TRUE if PME status set
+ * Return true if PME status set
  */
 bool pcicore_pmestat(void *pch)
 {
--- a/drivers/staging/brcm80211/util/sbutils.c
+++ b/drivers/staging/brcm80211/util/sbutils.c
@@ -445,7 +445,7 @@ bool sb_taclear(si_t *sih, bool details)
 	}
 
 	if (inband | timeout | serror) {
-		rc = TRUE;
+		rc = true;
 		SI_ERROR(("sb_taclear: inband 0x%x, serror 0x%x, timeout "
 			"0x%x!\n", inband, serror, timeout));
 	}
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -162,7 +162,7 @@ static bool si_buscore_prep(si_info_t *s
 	}
 #endif				/* defined(BCMSDIO) */
 
-	return TRUE;
+	return true;
 }
 
 static bool si_buscore_setup(si_info_t *sii, chipcregs_t *cc, uint bustype,
@@ -226,11 +226,11 @@ static bool si_buscore_setup(si_info_t *
 			if (cid == PCI_CORE_ID) {
 				pciidx = i;
 				pcirev = crev;
-				pci = TRUE;
+				pci = true;
 			} else if (cid == PCIE_CORE_ID) {
 				pcieidx = i;
 				pcierev = crev;
-				pcie = TRUE;
+				pcie = true;
 			}
 		}
 #ifdef BCMSDIO
@@ -302,7 +302,7 @@ static bool si_buscore_setup(si_info_t *
 	/* return to the original core */
 	si_setcoreidx(&sii->pub, *origidx);
 
-	return TRUE;
+	return true;
 }
 
 static __used void si_nvram_process(si_info_t *sii, char *pvars)
@@ -681,7 +681,7 @@ static si_info_t *si_doattach(si_info_t
 
 	if (CHIPID(sih->chip) == BCM4331_CHIP_ID) {
 		/* Enable Ext PA lines depending on chip package option */
-		si_chipcontrl_epa4331(sih, TRUE);
+		si_chipcontrl_epa4331(sih, true);
 	}
 
 	return sii;
@@ -1164,7 +1164,7 @@ static void si_clkctl_setdelay(si_info_t
 
 	/* Starting with 4318 it is ILP that is used for the delays */
 	slowmaxfreq =
-	    si_slowclk_freq(sii, (sii->pub.ccrev >= 10) ? FALSE : TRUE, cc);
+	    si_slowclk_freq(sii, (sii->pub.ccrev >= 10) ? FALSE : true, cc);
 
 	pll_on_delay = ((slowmaxfreq * pll_delay) + 999999) / 1000000;
 	fref_sel_delay = ((slowmaxfreq * FREF_DELAY) + 999999) / 1000000;
@@ -1547,7 +1547,7 @@ static char *si_devpathvar(si_t *sih, ch
 	return var;
 }
 
-/* return TRUE if PCIE capability exists in the pci config space */
+/* return true if PCIE capability exists in the pci config space */
 static __used bool si_ispcie(si_info_t *sii)
 {
 	u8 cap_ptr;
@@ -1561,7 +1561,7 @@ static __used bool si_ispcie(si_info_t *
 	if (!cap_ptr)
 		return FALSE;
 
-	return TRUE;
+	return true;
 }
 
 #ifdef BCMSDIO
@@ -1937,7 +1937,7 @@ bool si_deviceremoved(si_t *sih)
 		ASSERT(sii->osh != NULL);
 		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_VID, sizeof(u32));
 		if ((w & 0xFFFF) != VENDOR_BROADCOM)
-			return TRUE;
+			return true;
 		break;
 	}
 	return FALSE;
@@ -1976,7 +1976,7 @@ bool si_is_sprom_available(si_t *sih)
 	case BCM4331_CHIP_ID:
 		return (sih->chipst & CST4331_SPROM_PRESENT) != 0;
 	default:
-		return TRUE;
+		return true;
 	}
 }
 
@@ -2012,7 +2012,7 @@ bool si_is_otp_powered(si_t *sih)
 {
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_is_otp_powered(sih, si_osh(sih));
-	return TRUE;
+	return true;
 }
 
 void si_otp_power(si_t *sih, bool on)

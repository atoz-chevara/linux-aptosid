commit ab3275a6b57cd42d25dc1f32123ac5d1fb438984
Author: Henry Ptasinski <henryp@broadcom.com>
Date:   Thu Oct 21 11:04:10 2010 -0700

    staging: brcm80211: Removed unnecessary pktsetprio() function.
    
    This function is completely unnecessary, as packet classification is done
    higher up in the stack.  As used, the function actually mis-classifies frames
    in some cases since it overwrites the classification done by the stack.
    
    Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
@@ -1039,10 +1039,6 @@ int dhd_sendpkt(dhd_pub_t *dhdp, int ifi
 			atomic_inc(&dhd->pend_8021x_cnt);
 	}
 
-	/* Look into the packet and update the packet priority */
-	if ((PKTPRIO(pktbuf) == 0))
-		pktsetprio(pktbuf, false);
-
 	/* If the protocol uses a data header, apply it */
 	dhd_prot_hdrpush(dhdp, ifidx, pktbuf);
 
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -155,13 +155,6 @@
 	extern uint pktsegcnt(osl_t *osh, void *p);
 	extern uint pkttotlen(osl_t *osh, void *p);
 
-/* Get priority from a packet and pass it back in scb (or equiv) */
-	extern uint pktsetprio(void *pkt, bool update_vtag);
-#define	PKTPRIO_VDSCP	0x100	/* DSCP prio found after VLAN tag */
-#define	PKTPRIO_VLAN	0x200	/* VLAN prio found */
-#define	PKTPRIO_UPD	0x400	/* DSCP used to update VLAN prio */
-#define	PKTPRIO_DSCP	0x800	/* DSCP prio found */
-
 /* ethernet address */
 	extern int bcm_ether_atoe(char *p, struct ether_addr *ea);
 
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -418,72 +418,6 @@ void prpkt(const char *msg, osl_t *osh,
 }
 #endif				/* defined(BCMDBG) */
 
-/* Takes an Ethernet frame and sets out-of-bound PKTPRIO.
- * Also updates the inplace vlan tag if requested.
- * For debugging, it returns an indication of what it did.
- */
-uint pktsetprio(void *pkt, bool update_vtag)
-{
-	struct ether_header *eh;
-	struct ethervlan_header *evh;
-	u8 *pktdata;
-	int priority = 0;
-	int rc = 0;
-
-	pktdata = (u8 *) PKTDATA(pkt);
-	ASSERT(IS_ALIGNED((unsigned long)pktdata, sizeof(u16)));
-
-	eh = (struct ether_header *)pktdata;
-
-	if (ntoh16(eh->ether_type) == ETHER_TYPE_8021Q) {
-		u16 vlan_tag;
-		int vlan_prio, dscp_prio = 0;
-
-		evh = (struct ethervlan_header *)eh;
-
-		vlan_tag = ntoh16(evh->vlan_tag);
-		vlan_prio = (int)(vlan_tag >> VLAN_PRI_SHIFT) & VLAN_PRI_MASK;
-
-		if (ntoh16(evh->ether_type) == ETHER_TYPE_IP) {
-			u8 *ip_body =
-			    pktdata + sizeof(struct ethervlan_header);
-			u8 tos_tc = IP_TOS(ip_body);
-			dscp_prio = (int)(tos_tc >> IPV4_TOS_PREC_SHIFT);
-		}
-
-		/* DSCP priority gets precedence over 802.1P (vlan tag) */
-		if (dscp_prio != 0) {
-			priority = dscp_prio;
-			rc |= PKTPRIO_VDSCP;
-		} else {
-			priority = vlan_prio;
-			rc |= PKTPRIO_VLAN;
-		}
-		/*
-		 * If the DSCP priority is not the same as the VLAN priority,
-		 * then overwrite the priority field in the vlan tag, with the
-		 * DSCP priority value. This is required for Linux APs because
-		 * the VLAN driver on Linux, overwrites the skb->priority field
-		 * with the priority value in the vlan tag
-		 */
-		if (update_vtag && (priority != vlan_prio)) {
-			vlan_tag &= ~(VLAN_PRI_MASK << VLAN_PRI_SHIFT);
-			vlan_tag |= (u16) priority << VLAN_PRI_SHIFT;
-			evh->vlan_tag = hton16(vlan_tag);
-			rc |= PKTPRIO_UPD;
-		}
-	} else if (ntoh16(eh->ether_type) == ETHER_TYPE_IP) {
-		u8 *ip_body = pktdata + sizeof(struct ether_header);
-		u8 tos_tc = IP_TOS(ip_body);
-		priority = (int)(tos_tc >> IPV4_TOS_PREC_SHIFT);
-		rc |= PKTPRIO_DSCP;
-	}
-
-	ASSERT(priority >= 0 && priority <= MAXPRIO);
-	PKTSETPRIO(pkt, priority);
-	return rc | priority;
-}
-
 static char bcm_undeferrstr[BCME_STRLEN];
 
 static const char *bcmerrorstrtable[] = BCMERRSTRINGTABLE;

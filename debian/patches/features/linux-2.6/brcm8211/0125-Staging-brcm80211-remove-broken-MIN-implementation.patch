commit 7068c2f13983a39a49981891c47c74efb5fb60c7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:34:59 2010 -0700

    Staging: brcm80211: remove broken MIN() implementation
    
    Use the kernel-provided version, this one is broken.
    
    Note, there are more compiler warnings now, that's due to different
    types being compared, which shows how the original macro was wrong in at
    least one way.  They need to be fixed up.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/bcmutils.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmutils.c
@@ -61,7 +61,7 @@ uint pktcopy(osl_t *osh, void *p, uint o
 
 	/* copy the data */
 	for (; p && len; p = PKTNEXT(p)) {
-		n = MIN((uint) PKTLEN(p) - offset, (uint) len);
+		n = min((uint) PKTLEN(p) - offset, (uint) len);
 		bcopy(PKTDATA(p) + offset, buf, n);
 		buf += n;
 		len -= n;
@@ -89,7 +89,7 @@ uint pktfrombuf(osl_t *osh, void *p, uin
 
 	/* copy the data */
 	for (; p && len; p = PKTNEXT(p)) {
-		n = MIN((uint) PKTLEN(p) - offset, (uint) len);
+		n = min((uint) PKTLEN(p) - offset, (uint) len);
 		bcopy(buf, PKTDATA(p) + offset, n);
 		buf += n;
 		len -= n;
--- a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
@@ -1682,7 +1682,7 @@ static int dhd_ioctl_entry(struct net_de
 
 	/* Copy out any buffer passed */
 	if (ioc.buf) {
-		buflen = MIN(ioc.len, DHD_IOCTL_MAXLEN);
+		buflen = min(ioc.len, DHD_IOCTL_MAXLEN);
 		/* optimization for direct ioctl calls from kernel */
 		/*
 		   if (segment_eq(get_fs(), KERNEL_DS)) {
--- a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
@@ -979,7 +979,7 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 	      (DHD_DATA_ON() && (chan != SDPCM_CONTROL_CHANNEL))))) {
 		prhex("Tx Frame", frame, len);
 	} else if (DHD_HDRS_ON()) {
-		prhex("TxHdr", frame, MIN(len, 16));
+		prhex("TxHdr", frame, min(len, 16));
 	}
 #endif
 
@@ -1312,7 +1312,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 		if (DHD_BYTES_ON() && DHD_CTL_ON())
 			prhex("Tx Frame", frame, len);
 		else if (DHD_HDRS_ON())
-			prhex("TxHdr", frame, MIN(len, 16));
+			prhex("TxHdr", frame, min(len, 16));
 #endif
 
 		do {
@@ -1390,7 +1390,7 @@ int dhd_bus_rxctl(struct dhd_bus *bus, u
 
 	dhd_os_sdlock(bus->dhd);
 	rxlen = bus->rxlen;
-	bcopy(bus->rxctl, msg, MIN(msglen, rxlen));
+	bcopy(bus->rxctl, msg, min(msglen, rxlen));
 	bus->rxlen = 0;
 	dhd_os_sdunlock(bus->dhd);
 
@@ -1681,7 +1681,7 @@ static int dhdsdio_pktgen_set(dhd_bus_t
 
 	bus->pktgen_tick = bus->pktgen_ptick = 0;
 	bus->pktgen_len = MAX(bus->pktgen_len, bus->pktgen_minlen);
-	bus->pktgen_len = MIN(bus->pktgen_len, bus->pktgen_maxlen);
+	bus->pktgen_len = min(bus->pktgen_len, bus->pktgen_maxlen);
 
 	/* Clear counts for a new pktgen (mode change, or was stopped) */
 	if (bus->pktgen_count && (!oldcnt || oldmode != bus->pktgen_mode))
@@ -1737,7 +1737,7 @@ dhdsdio_membytes(dhd_bus_t *bus, bool wr
 				break;
 			}
 			sdaddr = 0;
-			dsize = MIN(SBSDIO_SB_OFT_ADDR_LIMIT, size);
+			dsize = min(SBSDIO_SB_OFT_ADDR_LIMIT, size);
 		}
 	}
 
@@ -1954,7 +1954,7 @@ static int dhdsdio_mem_dump(dhd_bus_t *b
 	printf("Dump dongle memory");
 	databuf = buf;
 	while (size) {
-		read_size = MIN(MEMBLOCK, size);
+		read_size = min(MEMBLOCK, size);
 		ret = dhdsdio_membytes(bus, FALSE, start, databuf, read_size);
 		if (ret) {
 			printf("%s: Error membytes %d\n", __func__, ret);
@@ -2781,7 +2781,7 @@ dhd_bus_iovar_op(dhd_pub_t *dhdp, const
 					  bus->blocksize));
 			}
 		}
-		bus->roundup = MIN(max_roundup, bus->blocksize);
+		bus->roundup = min(max_roundup, bus->blocksize);
 
 		if ((bus->idletime == DHD_IDLE_IMMEDIATE) && !bus->dpc_sched) {
 			bus->activity = FALSE;
@@ -3355,7 +3355,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 #ifdef DHD_DEBUG
 		if (DHD_GLOM_ON()) {
 			prhex("SUPERFRAME", PKTDATA(pfirst),
-			      MIN(PKTLEN(pfirst), 48));
+			      min(PKTLEN(pfirst), 48));
 		}
 #endif
 
@@ -3559,7 +3559,7 @@ static u8 dhdsdio_rxglom(dhd_bus_t *bus,
 				PKTLEN(pfirst), PKTNEXT(pfirst),
 				PKTLINK(pfirst)));
 				prhex("", (u8 *) PKTDATA(pfirst),
-				      MIN(PKTLEN(pfirst), 32));
+				      min(PKTLEN(pfirst), 32));
 			}
 #endif				/* DHD_DEBUG */
 		}
@@ -4432,7 +4432,7 @@ bool dhdsdio_dpc(dhd_bus_t *bus)
 		framecnt = dhdsdio_readframes(bus, rxlimit, &rxdone);
 		if (rxdone || bus->rxskip)
 			intstatus &= ~I_HMB_FRAME_IND;
-		rxlimit -= MIN(framecnt, rxlimit);
+		rxlimit -= min(framecnt, rxlimit);
 	}
 
 	/* Keep still-pending events for next scheduling */
@@ -4503,7 +4503,7 @@ clkwait:
 	else if ((bus->clkstate == CLK_AVAIL) && !bus->fcstate &&
 		 pktq_mlen(&bus->txq, ~bus->flowcontrol) && txlimit
 		 && DATAOK(bus)) {
-		framecnt = rxdone ? txlimit : MIN(txlimit, dhd_txminmax);
+		framecnt = rxdone ? txlimit : min(txlimit, dhd_txminmax);
 		framecnt = dhdsdio_sendfromq(bus, framecnt);
 		txlimit -= framecnt;
 	}
@@ -4605,7 +4605,7 @@ static void dhdsdio_pktgen_init(dhd_bus_
 {
 	/* Default to specified length, or full range */
 	if (dhd_pktgen_len) {
-		bus->pktgen_maxlen = MIN(dhd_pktgen_len, MAX_PKTGEN_LEN);
+		bus->pktgen_maxlen = min(dhd_pktgen_len, MAX_PKTGEN_LEN);
 		bus->pktgen_minlen = bus->pktgen_maxlen;
 	} else {
 		bus->pktgen_maxlen = MAX_PKTGEN_LEN;
@@ -5498,7 +5498,7 @@ static bool dhdsdio_probe_init(dhd_bus_t
 		DHD_INFO(("%s: Initial value for %s is %d\n",
 			  __func__, "sd_blocksize", bus->blocksize));
 	}
-	bus->roundup = MIN(max_roundup, bus->blocksize);
+	bus->roundup = min(max_roundup, bus->blocksize);
 
 	/* Query if bus module supports packet chaining,
 		 default to use if supported */
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
@@ -804,7 +804,7 @@ __wl_cfg80211_scan(struct wiphy *wiphy,
 			ssids->ssid, ssids->ssid_len));
 		memset(&sr->ssid, 0, sizeof(sr->ssid));
 		sr->ssid.SSID_len =
-			    MIN(sizeof(sr->ssid.SSID), ssids->ssid_len);
+			    min(sizeof(sr->ssid.SSID), ssids->ssid_len);
 		if (sr->ssid.SSID_len) {
 			memcpy(sr->ssid.SSID, ssids->ssid, sr->ssid.SSID_len);
 			sr->ssid.SSID_len = htod32(sr->ssid.SSID_len);
@@ -1361,7 +1361,7 @@ wl_cfg80211_connect(struct wiphy *wiphy,
 	 **  If SSID is zero join based on BSSID only
 	 */
 	memset(&ssid, 0, sizeof(ssid));
-	ssid.SSID_len = MIN(sizeof(ssid.SSID), sme->ssid_len);
+	ssid.SSID_len = min(sizeof(ssid.SSID), sme->ssid_len);
 	memcpy(ssid.SSID, sme->ssid, ssid.SSID_len);
 	ssid.SSID_len = htod32(ssid.SSID_len);
 	wl_update_prof(wl, NULL, &ssid, WL_PROF_SSID);
@@ -1754,7 +1754,7 @@ wl_cfg80211_get_key(struct wiphy *wiphy,
 	key.index = key_idx;
 	swap_key_to_BE(&key);
 	memset(&params, 0, sizeof(params));
-	params.key_len = (u8) MIN(DOT11_MAX_KEY_SIZE, key.len);
+	params.key_len = (u8) min(DOT11_MAX_KEY_SIZE, key.len);
 	memcpy(params.key, key.data, params.key_len);
 
 	err = wl_dev_ioctl(dev, WLC_GET_WSEC, &wsec, sizeof(wsec));
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -701,7 +701,7 @@ wl_iw_set_spy(struct net_device *dev,
 	if (!extra)
 		return -EINVAL;
 
-	iw->spy_num = MIN(ARRAYSIZE(iw->spy_addr), dwrq->length);
+	iw->spy_num = min(ARRAYSIZE(iw->spy_addr), dwrq->length);
 	for (i = 0; i < iw->spy_num; i++)
 		memcpy(&iw->spy_addr[i], addr[i].sa_data, ETHER_ADDR_LEN);
 	memset(iw->spy_qual, 0, sizeof(iw->spy_qual));
@@ -1291,7 +1291,7 @@ wl_iw_set_scan(struct net_device *dev,
 				return -EBUSY;
 			} else {
 				g_specific_ssid.SSID_len =
-				    MIN(sizeof(g_specific_ssid.SSID),
+				    min(sizeof(g_specific_ssid.SSID),
 					req->essid_len);
 				memcpy(g_specific_ssid.SSID, req->essid,
 				       g_specific_ssid.SSID_len);
@@ -1389,7 +1389,7 @@ wl_iw_iscan_set_scan(struct net_device *
 	if (wrqu->data.length == sizeof(struct iw_scan_req)) {
 		if (wrqu->data.flags & IW_SCAN_THIS_ESSID) {
 			struct iw_scan_req *req = (struct iw_scan_req *)extra;
-			ssid.SSID_len = MIN(sizeof(ssid.SSID), req->essid_len);
+			ssid.SSID_len = min(sizeof(ssid.SSID), req->essid_len);
 			memcpy(ssid.SSID, req->essid, ssid.SSID_len);
 			ssid.SSID_len = htod32(ssid.SSID_len);
 		} else {
@@ -1918,9 +1918,9 @@ wl_iw_set_essid(struct net_device *dev,
 
 	if (dwrq->length && extra) {
 #if WIRELESS_EXT > 20
-		g_ssid.SSID_len = MIN(sizeof(g_ssid.SSID), dwrq->length);
+		g_ssid.SSID_len = min(sizeof(g_ssid.SSID), dwrq->length);
 #else
-		g_ssid.SSID_len = MIN(sizeof(g_ssid.SSID), dwrq->length - 1);
+		g_ssid.SSID_len = min(sizeof(g_ssid.SSID), dwrq->length - 1);
 #endif
 		memcpy(g_ssid.SSID, extra, g_ssid.SSID_len);
 	} else {
@@ -2453,7 +2453,7 @@ wl_iw_get_encode(struct net_device *dev,
 
 	wsec = dtoh32(wsec);
 	auth = dtoh32(auth);
-	dwrq->length = MIN(DOT11_MAX_KEY_SIZE, key.len);
+	dwrq->length = min(DOT11_MAX_KEY_SIZE, key.len);
 
 	dwrq->flags = key.index + 1;
 	if (!(wsec & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED)))
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -449,10 +449,6 @@ extern "C" {
 #define	ABS(a)			(((a) < 0) ? -(a) : (a))
 #endif				/* ABS */
 
-#ifndef MIN
-#define	MIN(a, b)		(((a) < (b)) ? (a) : (b))
-#endif				/* MIN */
-
 #ifndef MAX
 #define	MAX(a, b)		(((a) > (b)) ? (a) : (b))
 #endif				/* MAX */
--- a/drivers/staging/brcm80211/include/wlioctl.h
+++ b/drivers/staging/brcm80211/include/wlioctl.h
@@ -1212,7 +1212,7 @@ typedef struct wl_po {
 	u16 mcspo[8];
 } wl_po_t;
 
-/* a large TX Power as an init value to factor out of MIN() calculations,
+/* a large TX Power as an init value to factor out of min() calculations,
  * keep low enough to fit in an s8, units are .25 dBm
  */
 #define WLC_TXPWR_MAX		(127)	/* ~32 dBm = 1,500 mW */
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -1775,7 +1775,7 @@ wlc_phy_txpower_sromlimit_max_get(wlc_ph
 		maxtxpwr = (maxtxpwr > 6) ? (maxtxpwr - 6) : 0;
 
 		tx_pwr_max = MAX(tx_pwr_max, maxtxpwr);
-		tx_pwr_min = MIN(tx_pwr_min, maxtxpwr);
+		tx_pwr_min = min(tx_pwr_min, maxtxpwr);
 	}
 	*max_txpwr = tx_pwr_max;
 	*min_txpwr = tx_pwr_min;
@@ -1873,14 +1873,14 @@ void wlc_phy_txpower_recalc_target(phy_i
 			wlc_phy_txpower_sromlimit((wlc_phy_t *) pi, target_chan,
 						  &mintxpwr, &maxtxpwr, rate);
 
-			maxtxpwr = MIN(maxtxpwr, pi->txpwr_limit[rate]);
+			maxtxpwr = min(maxtxpwr, pi->txpwr_limit[rate]);
 
 			maxtxpwr =
 			    (maxtxpwr > pactrl) ? (maxtxpwr - pactrl) : 0;
 
 			maxtxpwr = (maxtxpwr > 6) ? (maxtxpwr - 6) : 0;
 
-			maxtxpwr = MIN(maxtxpwr, tx_pwr_target[rate]);
+			maxtxpwr = min(maxtxpwr, tx_pwr_target[rate]);
 
 			if (pi->txpwr_percent <= 100)
 				maxtxpwr = (maxtxpwr * pi->txpwr_percent) / 100;
@@ -1889,13 +1889,13 @@ void wlc_phy_txpower_recalc_target(phy_i
 		}
 
 		tx_pwr_target[rate] =
-		    MIN(tx_pwr_target[rate], pi->txpwr_env_limit[rate]);
+		    min(tx_pwr_target[rate], pi->txpwr_env_limit[rate]);
 
 		if (tx_pwr_target[rate] > tx_pwr_max)
 			tx_pwr_max_rate_ind = rate;
 
 		tx_pwr_max = MAX(tx_pwr_max, tx_pwr_target[rate]);
-		tx_pwr_min = MIN(tx_pwr_min, tx_pwr_target[rate]);
+		tx_pwr_min = min(tx_pwr_min, tx_pwr_target[rate]);
 	}
 
 	bzero(pi->tx_power_offset, sizeof(pi->tx_power_offset));
@@ -1978,7 +1978,7 @@ wlc_phy_txpower_reg_limit_calc(phy_info_
 			for (rate1 = rate_start_index, rate2 = 0;
 			     rate2 < WLC_NUM_RATES_OFDM; rate1++, rate2++)
 				pi->txpwr_limit[rate1] =
-				    MIN(txpwr_ptr2[rate2],
+				    min(txpwr_ptr2[rate2],
 					tmp_txpwr_limit[rate2]);
 		}
 
@@ -2021,7 +2021,7 @@ wlc_phy_txpower_reg_limit_calc(phy_info_
 			     rate2 < WLC_NUM_RATES_MCS_1_STREAM;
 			     rate1++, rate2++)
 				pi->txpwr_limit[rate1] =
-				    MIN(txpwr_ptr2[rate2],
+				    min(txpwr_ptr2[rate2],
 					tmp_txpwr_limit[rate2]);
 		}
 
@@ -2066,7 +2066,7 @@ wlc_phy_txpower_reg_limit_calc(phy_info_
 		pi->txpwr_limit[WL_TX_POWER_MCS_32] = txpwr->mcs32;
 
 		pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST] =
-		    MIN(pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST],
+		    min(pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST],
 			pi->txpwr_limit[WL_TX_POWER_MCS_32]);
 		pi->txpwr_limit[WL_TX_POWER_MCS_32] =
 		    pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST];
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -21357,7 +21357,7 @@ static void wlc_phy_rssi_cal_nphy_rev2(p
 		    || (rssi_type == NPHY_RSSI_SEL_W2)) {
 			for (ctr = 0; ctr < 2; ctr++) {
 				poll_miniq[vcm][ctr] =
-				    MIN(poll_results[vcm][ctr * 2 + 0],
+				    min(poll_results[vcm][ctr * 2 + 0],
 					poll_results[vcm][ctr * 2 + 1]);
 			}
 		}
@@ -25492,7 +25492,7 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 						      (lna2 << 2) | lna1), 0x3,
 						     0);
 	} else {
-		hpvga = (u16) MAX(MIN(((int)hpvga) + delta_pwr, 10), 0);
+		hpvga = (u16) MAX(min(((int)hpvga) + delta_pwr, 10), 0);
 		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 12),
 					     ((hpvga << 12) | (lpf_biq1 << 10) |
 					      (lpf_biq0 << 8) | (mix_tia_gain <<
@@ -25877,8 +25877,8 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *p
 						 TXLPF_IDAC_4, txlpf_idac);
 			}
 
-			rxlpf_rccal_hpc = MAX(MIN(rxlpf_rccal_hpc, 31), 0);
-			txlpf_rccal_lpc = MAX(MIN(txlpf_rccal_lpc, 31), 0);
+			rxlpf_rccal_hpc = MAX(min(rxlpf_rccal_hpc, 31), 0);
+			txlpf_rccal_lpc = MAX(min(txlpf_rccal_lpc, 31), 0);
 
 			write_radio_reg(pi, (RADIO_2056_RX_RXLPF_RCCAL_HPC |
 					     ((rx_core ==
@@ -26060,7 +26060,7 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t *p
 
 				hpf_change = desired_log2_pwr - actual_log2_pwr;
 				curr_hpf += hpf_change;
-				curr_hpf = MAX(MIN(curr_hpf, 10), 0);
+				curr_hpf = MAX(min(curr_hpf, 10), 0);
 				if (use_hpf_num == 1) {
 					curr_hpf1 = curr_hpf;
 				} else {
@@ -26745,8 +26745,8 @@ wlc_phy_a1_nphy(phy_info_t *pi, u8 core,
 		u32 phy_a1, phy_a2;
 		s32 phy_a3, phy_a4, phy_a5, phy_a6, phy_a7;
 
-		phy_a1 = end - MIN(end, (winsz >> 1));
-		phy_a2 = MIN(NPHY_PAPD_EPS_TBL_SIZE - 1, end + (winsz >> 1));
+		phy_a1 = end - min(end, (winsz >> 1));
+		phy_a2 = min(NPHY_PAPD_EPS_TBL_SIZE - 1, end + (winsz >> 1));
 		phy_a3 = phy_a2 - phy_a1 + 1;
 		phy_a6 = 0;
 		phy_a7 = 0;
@@ -27754,7 +27754,7 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 		switch (band_num) {
 		case 0:
 
-			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_2g,
+			tmp_max_pwr = min(pi->nphy_pwrctrl_info[0].max_pwr_2g,
 					  pi->nphy_pwrctrl_info[1].max_pwr_2g);
 
 			pwr_offsets1[0] = pi->cck2gpo;
@@ -27778,7 +27778,7 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 			break;
 		case 1:
 
-			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_5gm,
+			tmp_max_pwr = min(pi->nphy_pwrctrl_info[0].max_pwr_5gm,
 					  pi->nphy_pwrctrl_info[1].max_pwr_5gm);
 
 			pwr_offsets1[0] = (u16) (pi->ofdm5gpo & 0xffff);
@@ -27795,7 +27795,7 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 			break;
 		case 2:
 
-			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_5gl,
+			tmp_max_pwr = min(pi->nphy_pwrctrl_info[0].max_pwr_5gl,
 					  pi->nphy_pwrctrl_info[1].max_pwr_5gl);
 
 			pwr_offsets1[0] = (u16) (pi->ofdm5glpo & 0xffff);
@@ -27812,7 +27812,7 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 			break;
 		case 3:
 
-			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_5gh,
+			tmp_max_pwr = min(pi->nphy_pwrctrl_info[0].max_pwr_5gh,
 					  pi->nphy_pwrctrl_info[1].max_pwr_5gh);
 
 			pwr_offsets1[0] = (u16) (pi->ofdm5ghpo & 0xffff);
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -290,13 +290,13 @@ static void scb_ampdu_update_config(ampd
 	if (ampdu->max_pdu != AUTO)
 		scb_ampdu->max_pdu = (u8) ampdu->max_pdu;
 
-	scb_ampdu->release = MIN(scb_ampdu->max_pdu, AMPDU_SCB_MAX_RELEASE);
+	scb_ampdu->release = min(scb_ampdu->max_pdu, AMPDU_SCB_MAX_RELEASE);
 
 	if (scb_ampdu->max_rxlen)
 		scb_ampdu->release =
-		    MIN(scb_ampdu->release, scb_ampdu->max_rxlen / 1600);
+		    min(scb_ampdu->release, scb_ampdu->max_rxlen / 1600);
 
-	scb_ampdu->release = MIN(scb_ampdu->release,
+	scb_ampdu->release = min(scb_ampdu->release,
 				 ampdu->fifo_tb[TX_AC_BE_FIFO].
 				 mcs2ampdu_table[FFPLD_MAX_MCS]);
 
@@ -396,7 +396,7 @@ static int wlc_ffpld_check_txfunfl(wlc_i
 		return 0;
 	}
 	max_mpdu =
-	    MIN(fifo->mcs2ampdu_table[FFPLD_MAX_MCS], AMPDU_NUM_MPDU_LEGACY);
+	    min(fifo->mcs2ampdu_table[FFPLD_MAX_MCS], AMPDU_NUM_MPDU_LEGACY);
 
 	/* In case max value max_pdu is already lower than
 	   the fifo depth, there is nothing more we can do.
@@ -462,7 +462,7 @@ static void wlc_ffpld_calc_mcs2ampdu_tab
 	/* recompute the dma rate */
 	/* note : we divide/multiply by 100 to avoid integer overflows */
 	max_mpdu =
-	    MIN(fifo->mcs2ampdu_table[FFPLD_MAX_MCS], AMPDU_NUM_MPDU_LEGACY);
+	    min(fifo->mcs2ampdu_table[FFPLD_MAX_MCS], AMPDU_NUM_MPDU_LEGACY);
 	phy_rate = MCS_RATE(FFPLD_MAX_MCS, TRUE, FALSE);
 	dma_rate =
 	    (((phy_rate / 100) *
@@ -478,7 +478,7 @@ static void wlc_ffpld_calc_mcs2ampdu_tab
 		if (phy_rate > dma_rate) {
 			tmp = ((fifo->ampdu_pld_size * phy_rate) /
 			       ((phy_rate - dma_rate) * FFPLD_MPDU_SIZE)) + 1;
-			tmp = MIN(tmp, 255);
+			tmp = min(tmp, 255);
 			fifo->mcs2ampdu_table[i] = (u8) tmp;
 		}
 	}
@@ -694,7 +694,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 			mcs = plcp0 & ~MIMO_PLCP_40MHZ;
 			ASSERT(mcs < MCS_TABLE_SIZE);
 			maxlen =
-			    MIN(scb_ampdu->max_rxlen,
+			    min(scb_ampdu->max_rxlen,
 				ampdu->max_txlen[mcs][is40][sgi]);
 
 			WL_NONE(("sendampdu: sgi %d, is40 %d, mcs %d\n", sgi,
@@ -832,7 +832,7 @@ wlc_sendampdu(ampdu_info_t *ampdu, wlc_t
 
 		/* set the preload length */
 		if (MCS_RATE(mcs, TRUE, FALSE) >= f->dmaxferrate) {
-			dma_len = MIN(dma_len, f->ampdu_pld_size);
+			dma_len = min(dma_len, f->ampdu_pld_size);
 			txh->PreloadSize = htol16(dma_len);
 		} else
 			txh->PreloadSize = 0;
--- a/drivers/staging/brcm80211/sys/wlc_channel.c
+++ b/drivers/staging/brcm80211/sys/wlc_channel.c
@@ -1084,80 +1084,80 @@ wlc_channel_min_txpower_limits_with_loca
 
 	/* CCK Rates */
 	for (j = 0; j < WL_TX_POWER_CCK_NUM; j++) {
-		txpwr->cck[j] = MIN(txpwr->cck[j], local_constraint_qdbm);
+		txpwr->cck[j] = min(txpwr->cck[j], local_constraint_qdbm);
 	}
 
 	/* 20 MHz Legacy OFDM SISO */
 	for (j = 0; j < WL_TX_POWER_OFDM_NUM; j++) {
-		txpwr->ofdm[j] = MIN(txpwr->ofdm[j], local_constraint_qdbm);
+		txpwr->ofdm[j] = min(txpwr->ofdm[j], local_constraint_qdbm);
 	}
 
 	/* 20 MHz Legacy OFDM CDD */
 	for (j = 0; j < WLC_NUM_RATES_OFDM; j++) {
 		txpwr->ofdm_cdd[j] =
-		    MIN(txpwr->ofdm_cdd[j], local_constraint_qdbm);
+		    min(txpwr->ofdm_cdd[j], local_constraint_qdbm);
 	}
 
 	/* 40 MHz Legacy OFDM SISO */
 	for (j = 0; j < WLC_NUM_RATES_OFDM; j++) {
 		txpwr->ofdm_40_siso[j] =
-		    MIN(txpwr->ofdm_40_siso[j], local_constraint_qdbm);
+		    min(txpwr->ofdm_40_siso[j], local_constraint_qdbm);
 	}
 
 	/* 40 MHz Legacy OFDM CDD */
 	for (j = 0; j < WLC_NUM_RATES_OFDM; j++) {
 		txpwr->ofdm_40_cdd[j] =
-		    MIN(txpwr->ofdm_40_cdd[j], local_constraint_qdbm);
+		    min(txpwr->ofdm_40_cdd[j], local_constraint_qdbm);
 	}
 
 	/* 20MHz MCS 0-7 SISO */
 	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
 		txpwr->mcs_20_siso[j] =
-		    MIN(txpwr->mcs_20_siso[j], local_constraint_qdbm);
+		    min(txpwr->mcs_20_siso[j], local_constraint_qdbm);
 	}
 
 	/* 20MHz MCS 0-7 CDD */
 	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
 		txpwr->mcs_20_cdd[j] =
-		    MIN(txpwr->mcs_20_cdd[j], local_constraint_qdbm);
+		    min(txpwr->mcs_20_cdd[j], local_constraint_qdbm);
 	}
 
 	/* 20MHz MCS 0-7 STBC */
 	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
 		txpwr->mcs_20_stbc[j] =
-		    MIN(txpwr->mcs_20_stbc[j], local_constraint_qdbm);
+		    min(txpwr->mcs_20_stbc[j], local_constraint_qdbm);
 	}
 
 	/* 20MHz MCS 8-15 MIMO */
 	for (j = 0; j < WLC_NUM_RATES_MCS_2_STREAM; j++)
 		txpwr->mcs_20_mimo[j] =
-		    MIN(txpwr->mcs_20_mimo[j], local_constraint_qdbm);
+		    min(txpwr->mcs_20_mimo[j], local_constraint_qdbm);
 
 	/* 40MHz MCS 0-7 SISO */
 	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
 		txpwr->mcs_40_siso[j] =
-		    MIN(txpwr->mcs_40_siso[j], local_constraint_qdbm);
+		    min(txpwr->mcs_40_siso[j], local_constraint_qdbm);
 	}
 
 	/* 40MHz MCS 0-7 CDD */
 	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
 		txpwr->mcs_40_cdd[j] =
-		    MIN(txpwr->mcs_40_cdd[j], local_constraint_qdbm);
+		    min(txpwr->mcs_40_cdd[j], local_constraint_qdbm);
 	}
 
 	/* 40MHz MCS 0-7 STBC */
 	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
 		txpwr->mcs_40_stbc[j] =
-		    MIN(txpwr->mcs_40_stbc[j], local_constraint_qdbm);
+		    min(txpwr->mcs_40_stbc[j], local_constraint_qdbm);
 	}
 
 	/* 40MHz MCS 8-15 MIMO */
 	for (j = 0; j < WLC_NUM_RATES_MCS_2_STREAM; j++)
 		txpwr->mcs_40_mimo[j] =
-		    MIN(txpwr->mcs_40_mimo[j], local_constraint_qdbm);
+		    min(txpwr->mcs_40_mimo[j], local_constraint_qdbm);
 
 	/* 40MHz MCS 32 */
-	txpwr->mcs32 = MIN(txpwr->mcs32, local_constraint_qdbm);
+	txpwr->mcs32 = min(txpwr->mcs32, local_constraint_qdbm);
 
 }
 
@@ -1356,7 +1356,7 @@ wlc_channel_reg_limits(wlc_cm_info_t *wl
 
 		maxpwr = maxpwr - delta;
 		maxpwr = MAX(maxpwr, 0);
-		maxpwr = MIN(maxpwr, conducted_max);
+		maxpwr = min(maxpwr, conducted_max);
 
 		for (i = 0; i < WLC_NUM_RATES_CCK; i++)
 			txpwr->cck[i] = (u8) maxpwr;
@@ -1372,11 +1372,11 @@ wlc_channel_reg_limits(wlc_cm_info_t *wl
 
 	maxpwr = maxpwr - delta;
 	maxpwr = MAX(maxpwr, 0);
-	maxpwr = MIN(maxpwr, conducted_ofdm_max);
+	maxpwr = min(maxpwr, conducted_ofdm_max);
 
 	/* Keep OFDM lmit below CCK limit */
 	if (BAND_2G(band->bandtype))
-		maxpwr = MIN(maxpwr, txpwr->cck[0]);
+		maxpwr = min(maxpwr, txpwr->cck[0]);
 
 	for (i = 0; i < WLC_NUM_RATES_OFDM; i++) {
 		txpwr->ofdm[i] = (u8) maxpwr;
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -4806,8 +4806,7 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 			bool override;
 
 			/* Remove override bit and clip to max qdbm value */
-			qdbm =
-			    (u8) MIN((int_val & ~WL_TXPWR_OVERRIDE), 0xff);
+			qdbm = (u8)min((int_val & ~WL_TXPWR_OVERRIDE), 0xff);
 			/* Extract override setting */
 			override = (int_val & WL_TXPWR_OVERRIDE) ? TRUE : FALSE;
 			err =
--- a/drivers/staging/brcm80211/sys/wlc_pub.h
+++ b/drivers/staging/brcm80211/sys/wlc_pub.h
@@ -57,7 +57,7 @@
 
 #define WLC_SNR_INVALID		0	/* invalid SNR value */
 
-/* a large TX Power as an init value to factor out of MIN() calculations,
+/* a large TX Power as an init value to factor out of min() calculations,
  * keep low enough to fit in an s8, units are .25 dBm
  */
 #define WLC_TXPWR_MAX		(127)	/* ~32 dBm = 1,500 mW */
@@ -456,7 +456,7 @@ extern const u8 wlc_prio2prec_map[];
 /* This maps priority to one precedence higher - Used by PS-Poll response packets to
  * simulate enqueue-at-head operation, but still maintain the order on the queue
  */
-#define WLC_PRIO_TO_HI_PREC(pri)	MIN(WLC_PRIO_TO_PREC(pri) + 1, WLC_PREC_COUNT - 1)
+#define WLC_PRIO_TO_HI_PREC(pri)	min(WLC_PRIO_TO_PREC(pri) + 1, WLC_PREC_COUNT - 1)
 
 extern const u8 wme_fifo2ac[];
 #define WME_PRIO2AC(prio)	wme_fifo2ac[prio2fifo[(prio)]]
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -1011,7 +1011,7 @@ static void *BCMFASTPATH _dma_rx(dma_inf
 #endif				/* defined(__mips__) */
 
 	/* set actual length */
-	pkt_len = MIN((di->rxoffset + len), di->rxbufsize);
+	pkt_len = min((di->rxoffset + len), di->rxbufsize);
 	PKTSETLEN(head, pkt_len);
 	resid = len - (di->rxbufsize - di->rxoffset);
 
@@ -1020,7 +1020,7 @@ static void *BCMFASTPATH _dma_rx(dma_inf
 		tail = head;
 		while ((resid > 0) && (p = _dma_getnextrxp(di, FALSE))) {
 			PKTSETNEXT(tail, p);
-			pkt_len = MIN(resid, (int)di->rxbufsize);
+			pkt_len = min(resid, (int)di->rxbufsize);
 			PKTSETLEN(p, pkt_len);
 
 			tail = p;
--- a/drivers/staging/brcm80211/util/linux_osl.c
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -613,7 +613,7 @@ void osl_delay(uint usec)
 	uint d;
 
 	while (usec > 0) {
-		d = MIN(usec, 1000);
+		d = min(usec, (uint)1000);
 		udelay(d);
 		usec -= d;
 	}

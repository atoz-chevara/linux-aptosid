commit a2627bc06580ffe1115b24a1dcce52924f157955
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:31 2010 -0400

    staging: brcm80211: fix "ERROR: open brace '{' following function dec..."
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -508,7 +508,8 @@ void mod_phy_reg(phy_info_t *pi, uint16
 	pi->phy_wreg = 0;
 }
 
-static void WLBANDINITFN(wlc_set_phy_uninitted) (phy_info_t *pi) {
+static void WLBANDINITFN(wlc_set_phy_uninitted) (phy_info_t *pi)
+{
 	int i, j;
 
 	pi->initialized = FALSE;
@@ -544,7 +545,8 @@ static void WLBANDINITFN(wlc_set_phy_uni
 	}
 }
 
-shared_phy_t *BCMATTACHFN(wlc_phy_shared_attach) (shared_phy_params_t *shp) {
+shared_phy_t *BCMATTACHFN(wlc_phy_shared_attach) (shared_phy_params_t *shp)
+{
 	shared_phy_t *sh;
 
 	if ((sh =
@@ -582,7 +584,8 @@ shared_phy_t *BCMATTACHFN(wlc_phy_shared
 	return sh;
 }
 
-void BCMATTACHFN(wlc_phy_shared_detach) (shared_phy_t *phy_sh) {
+void BCMATTACHFN(wlc_phy_shared_detach) (shared_phy_t *phy_sh)
+{
 	osl_t *osh;
 
 	if (phy_sh) {
@@ -774,7 +777,8 @@ wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (
 	return NULL;
 }
 
-void BCMATTACHFN(wlc_phy_detach) (wlc_phy_t *pih) {
+void BCMATTACHFN(wlc_phy_detach) (wlc_phy_t *pih)
+{
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	if (pih) {
@@ -912,7 +916,8 @@ uint32 wlc_phy_clk_bwbits(wlc_phy_t *pih
 	return phy_bw_clkbits;
 }
 
-void WLBANDINITFN(wlc_phy_por_inform) (wlc_phy_t *ppi) {
+void WLBANDINITFN(wlc_phy_por_inform) (wlc_phy_t *ppi)
+{
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	pi->phy_init_por = TRUE;
@@ -957,7 +962,8 @@ void wlc_phy_hw_state_upd(wlc_phy_t *pih
 	pi->sh->up = newstate;
 }
 
-void WLBANDINITFN(wlc_phy_init) (wlc_phy_t *pih, chanspec_t chanspec) {
+void WLBANDINITFN(wlc_phy_init) (wlc_phy_t *pih, chanspec_t chanspec)
+{
 	uint32 mc;
 	initfn_t phy_init = NULL;
 	phy_info_t *pi = (phy_info_t *) pih;
@@ -1016,7 +1022,8 @@ void WLBANDINITFN(wlc_phy_init) (wlc_phy
 	pi->init_in_progress = FALSE;
 }
 
-void BCMINITFN(wlc_phy_cal_init) (wlc_phy_t *pih) {
+void BCMINITFN(wlc_phy_cal_init) (wlc_phy_t *pih)
+{
 	phy_info_t *pi = (phy_info_t *) pih;
 	initfn_t cal_init = NULL;
 
@@ -1031,7 +1038,8 @@ void BCMINITFN(wlc_phy_cal_init) (wlc_ph
 	}
 }
 
-int BCMUNINITFN(wlc_phy_down) (wlc_phy_t *pih) {
+int BCMUNINITFN(wlc_phy_down) (wlc_phy_t *pih)
+{
 	phy_info_t *pi = (phy_info_t *) pih;
 	int callbacks = 0;
 
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -2286,7 +2286,8 @@ static void wlc_lcnphy_vbat_temp_sense_s
 	OSL_DELAY(999);
 }
 
-void WLBANDINITFN(wlc_lcnphy_tx_pwr_ctrl_init) (wlc_phy_t *ppi) {
+void WLBANDINITFN(wlc_lcnphy_tx_pwr_ctrl_init) (wlc_phy_t *ppi)
+{
 	lcnphy_txgains_t tx_gains;
 	uint8 bbmult;
 	phytbl_info_t tab;
@@ -3603,7 +3604,8 @@ void wlc_lcnphy_get_tssi(phy_info_t *pi,
 	}
 }
 
-void WLBANDINITFN(wlc_phy_cal_init_lcnphy) (phy_info_t *pi) {
+void WLBANDINITFN(wlc_phy_cal_init_lcnphy) (phy_info_t *pi)
+{
 	return;
 
 }
@@ -3699,7 +3701,8 @@ static void wlc_lcnphy_set_rx_iq_comp(ph
 
 }
 
-void WLBANDINITFN(wlc_phy_init_lcnphy) (phy_info_t *pi) {
+void WLBANDINITFN(wlc_phy_init_lcnphy) (phy_info_t *pi)
+{
 	uint8 phybw40;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
@@ -4314,7 +4317,8 @@ static void wlc_lcnphy_load_rfpower(phy_
 	}
 }
 
-static void WLBANDINITFN(wlc_lcnphy_tbl_init) (phy_info_t *pi) {
+static void WLBANDINITFN(wlc_lcnphy_tbl_init) (phy_info_t *pi)
+{
 	uint idx;
 	uint8 phybw40;
 	phytbl_info_t tab;
@@ -4408,7 +4412,8 @@ static void WLBANDINITFN(wlc_lcnphy_tbl_
 	wlc_lcnphy_clear_papd_comptable(pi);
 }
 
-static void WLBANDINITFN(wlc_lcnphy_rev0_baseband_init) (phy_info_t *pi) {
+static void WLBANDINITFN(wlc_lcnphy_rev0_baseband_init) (phy_info_t *pi)
+{
 	uint16 afectrl1;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -4454,7 +4459,8 @@ static void WLBANDINITFN(wlc_lcnphy_rev0
 
 }
 
-static void WLBANDINITFN(wlc_lcnphy_rev2_baseband_init) (phy_info_t *pi) {
+static void WLBANDINITFN(wlc_lcnphy_rev2_baseband_init) (phy_info_t *pi)
+{
 	if (CHSPEC_IS5G(pi->radio_chanspec)) {
 		mod_phy_reg(pi, 0x416, (0xff << 0), 80 << 0);
 
@@ -4523,7 +4529,8 @@ static void wlc_lcnphy_agc_temp_init(phy
 
 }
 
-static void WLBANDINITFN(wlc_lcnphy_bu_tweaks) (phy_info_t *pi) {
+static void WLBANDINITFN(wlc_lcnphy_bu_tweaks) (phy_info_t *pi)
+{
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 
@@ -4577,7 +4584,8 @@ static void WLBANDINITFN(wlc_lcnphy_bu_t
 	}
 }
 
-static void WLBANDINITFN(wlc_lcnphy_baseband_init) (phy_info_t *pi) {
+static void WLBANDINITFN(wlc_lcnphy_baseband_init) (phy_info_t *pi)
+{
 
 	wlc_lcnphy_tbl_init(pi);
 	wlc_lcnphy_rev0_baseband_init(pi);
@@ -4586,7 +4594,8 @@ static void WLBANDINITFN(wlc_lcnphy_base
 	wlc_lcnphy_bu_tweaks(pi);
 }
 
-static void WLBANDINITFN(wlc_radio_2064_init) (phy_info_t *pi) {
+static void WLBANDINITFN(wlc_radio_2064_init) (phy_info_t *pi)
+{
 	uint32 i;
 	lcnphy_radio_regs_t *lcnphyregs = NULL;
 
@@ -4646,7 +4655,8 @@ static void WLBANDINITFN(wlc_radio_2064_
 	wlc_lcnphy_rc_cal(pi);
 }
 
-static void WLBANDINITFN(wlc_lcnphy_radio_init) (phy_info_t *pi) {
+static void WLBANDINITFN(wlc_lcnphy_radio_init) (phy_info_t *pi)
+{
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 
@@ -4707,7 +4717,8 @@ static void wlc_lcnphy_rc_cal(phy_info_t
 	return;
 }
 
-static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t *pi) {
+static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t *pi)
+{
 	int8 txpwr = 0;
 	int i;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -14209,7 +14209,8 @@ bool wlc_phy_bist_check_phy(wlc_phy_t *p
 	return FALSE;
 }
 
-static void WLBANDINITFN(wlc_phy_bphy_init_nphy) (phy_info_t *pi) {
+static void WLBANDINITFN(wlc_phy_bphy_init_nphy) (phy_info_t *pi)
+{
 	uint16 addr, val;
 
 	ASSERT(ISNPHY(pi));
@@ -14266,7 +14267,8 @@ wlc_phy_table_read_nphy(phy_info_t *pi,
 	wlc_phy_read_table_nphy(pi, &tbl);
 }
 
-static void WLBANDINITFN(wlc_phy_static_table_download_nphy) (phy_info_t *pi) {
+static void WLBANDINITFN(wlc_phy_static_table_download_nphy) (phy_info_t *pi)
+{
 	uint idx;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 16)) {
@@ -14288,7 +14290,8 @@ static void WLBANDINITFN(wlc_phy_static_
 	}
 }
 
-static void WLBANDINITFN(wlc_phy_tbl_init_nphy) (phy_info_t *pi) {
+static void WLBANDINITFN(wlc_phy_tbl_init_nphy) (phy_info_t *pi)
+{
 	uint idx = 0;
 	uint8 antswctrllut;
 
@@ -14499,7 +14502,8 @@ bool wlc_phy_attach_nphy(phy_info_t *pi)
 	return TRUE;
 }
 
-static void BCMATTACHFN(wlc_phy_txpwrctrl_config_nphy) (phy_info_t *pi) {
+static void BCMATTACHFN(wlc_phy_txpwrctrl_config_nphy) (phy_info_t *pi)
+{
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		pi->nphy_txpwrctrl = PHY_TPC_HW_ON;
@@ -14518,7 +14522,8 @@ static void BCMATTACHFN(wlc_phy_txpwrctr
 		pi->phy_5g_pwrgain = TRUE;
 }
 
-void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t *pi) {
+void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t *pi)
+{
 	uint16 val;
 	uint16 clip1_ths[2];
 	nphy_txgains_t target_gain;
@@ -27740,7 +27745,8 @@ wlc_phy_mcs_to_ofdm_powers_nphy(uint8 *p
 	}
 }
 
-void BCMNMIATTACHFN(wlc_phy_txpwr_apply_nphy) (phy_info_t *pi) {
+void BCMNMIATTACHFN(wlc_phy_txpwr_apply_nphy) (phy_info_t *pi)
+{
 	uint rate1, rate2, band_num;
 	uint8 tmp_bw40po = 0, tmp_cddpo = 0, tmp_stbcpo = 0;
 	uint8 tmp_max_pwr = 0;
@@ -27937,7 +27943,8 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 	return;
 }
 
-static void BCMATTACHFN(wlc_phy_txpwr_srom_read_ppr_nphy) (phy_info_t *pi) {
+static void BCMATTACHFN(wlc_phy_txpwr_srom_read_ppr_nphy) (phy_info_t *pi)
+{
 	uint16 bw40po, cddpo, stbcpo, bwduppo;
 	uint band_num;
 
@@ -28144,7 +28151,8 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 	wlc_phy_txpwr_apply_nphy(pi);
 }
 
-static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_nphy) (phy_info_t *pi) {
+static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_nphy) (phy_info_t *pi)
+{
 
 	pi->antswitch = (uint8) PHY_GETINTVAR(pi, "antswitch");
 	pi->aa2g = (uint8) PHY_GETINTVAR(pi, "aa2g");
--- a/drivers/staging/brcm80211/sys/wlc_alloc.c
+++ b/drivers/staging/brcm80211/sys/wlc_alloc.c
@@ -50,7 +50,8 @@ void *wlc_calloc(osl_t *osh, uint unit,
 	return item;
 }
 
-void BCMATTACHFN(wlc_tunables_init) (wlc_tunables_t *tunables, uint devid) {
+void BCMATTACHFN(wlc_tunables_init) (wlc_tunables_t *tunables, uint devid)
+{
 	tunables->ntxd = NTXD;
 	tunables->nrxd = NRXD;
 	tunables->rxbufsz = RXBUFSZ;
@@ -105,7 +106,8 @@ static wlc_pub_t *BCMATTACHFN(wlc_pub_ma
 	return NULL;
 }
 
-static void BCMATTACHFN(wlc_pub_mfree) (osl_t *osh, wlc_pub_t *pub) {
+static void BCMATTACHFN(wlc_pub_mfree) (osl_t *osh, wlc_pub_t *pub)
+{
 	if (pub == NULL)
 		return;
 
@@ -305,7 +307,8 @@ wlc_info_t *BCMATTACHFN(wlc_attach_mallo
 	return NULL;
 }
 
-void BCMATTACHFN(wlc_detach_mfree) (wlc_info_t *wlc, osl_t *osh) {
+void BCMATTACHFN(wlc_detach_mfree) (wlc_info_t *wlc, osl_t *osh)
+{
 	if (wlc == NULL)
 		return;
 
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -169,7 +169,8 @@ static INLINE uint16 pkt_txh_seqnum(wlc_
 	return (ltoh16(h->seq) >> SEQNUM_SHIFT);
 }
 
-ampdu_info_t *BCMATTACHFN(wlc_ampdu_attach) (wlc_info_t *wlc) {
+ampdu_info_t *BCMATTACHFN(wlc_ampdu_attach) (wlc_info_t *wlc)
+{
 	ampdu_info_t *ampdu;
 	int i;
 
@@ -239,7 +240,8 @@ ampdu_info_t *BCMATTACHFN(wlc_ampdu_atta
 	return ampdu;
 }
 
-void BCMATTACHFN(wlc_ampdu_detach) (ampdu_info_t *ampdu) {
+void BCMATTACHFN(wlc_ampdu_detach) (ampdu_info_t *ampdu)
+{
 	int i;
 
 	if (!ampdu)
--- a/drivers/staging/brcm80211/sys/wlc_antsel.c
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.c
@@ -158,7 +158,8 @@ antsel_info_t *BCMNMIATTACHFN(wlc_antsel
 	return asi;
 }
 
-void BCMATTACHFN(wlc_antsel_detach) (antsel_info_t *asi) {
+void BCMATTACHFN(wlc_antsel_detach) (antsel_info_t *asi)
+{
 	if (!asi)
 		return;
 
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -204,7 +204,8 @@ static void wlc_bmac_update_slot_timing(
 	}
 }
 
-static void WLBANDINITFN(wlc_ucode_bsinit) (wlc_hw_info_t *wlc_hw) {
+static void WLBANDINITFN(wlc_ucode_bsinit) (wlc_hw_info_t *wlc_hw)
+{
 	/* init microcode host flags */
 	wlc_write_mhf(wlc_hw, wlc_hw->band->mhfs);
 
@@ -230,7 +231,8 @@ static void WLBANDINITFN(wlc_ucode_bsini
 }
 
 /* switch to new band but leave it inactive */
-static uint32 WLBANDINITFN(wlc_setband_inact) (wlc_info_t *wlc, uint bandunit) {
+static uint32 WLBANDINITFN(wlc_setband_inact) (wlc_info_t *wlc, uint bandunit)
+{
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	uint32 macintmask;
 	uint32 tmp;
@@ -563,7 +565,8 @@ int wlc_bmac_state_get(wlc_hw_info_t *wl
 }
 
 static bool
-BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc_info_t *wlc, uint j, bool wme) {
+BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc_info_t *wlc, uint j, bool wme)
+{
 	uint i;
 	char name[8];
 	/* ucode host flag 2 needed for pio mode, independent of band and fifo */
@@ -681,7 +684,8 @@ BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc
 	return TRUE;
 }
 
-static void BCMATTACHFN(wlc_bmac_detach_dmapio) (wlc_hw_info_t *wlc_hw) {
+static void BCMATTACHFN(wlc_bmac_detach_dmapio) (wlc_hw_info_t *wlc_hw)
+{
 	uint j;
 
 	for (j = 0; j < NFIFO; j++) {
@@ -1039,7 +1043,8 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
  * may get overrides later in this function
  *  BMAC_NOTES, move low out and resolve the dangling ones
  */
-void BCMATTACHFN(wlc_bmac_info_init) (wlc_hw_info_t *wlc_hw) {
+void BCMATTACHFN(wlc_bmac_info_init) (wlc_hw_info_t *wlc_hw)
+{
 	wlc_info_t *wlc = wlc_hw->wlc;
 
 	/* set default sw macintmask value */
@@ -1060,7 +1065,8 @@ void BCMATTACHFN(wlc_bmac_info_init) (wl
 /*
  * low level detach
  */
-int BCMATTACHFN(wlc_bmac_detach) (wlc_info_t *wlc) {
+int BCMATTACHFN(wlc_bmac_detach) (wlc_info_t *wlc)
+{
 	uint i;
 	wlc_hwband_t *band;
 	wlc_hw_info_t *wlc_hw = wlc->hw;
@@ -1110,7 +1116,8 @@ int BCMATTACHFN(wlc_bmac_detach) (wlc_in
 
 }
 
-void BCMINITFN(wlc_bmac_reset) (wlc_hw_info_t *wlc_hw) {
+void BCMINITFN(wlc_bmac_reset) (wlc_hw_info_t *wlc_hw)
+{
 	WL_TRACE(("wl%d: wlc_bmac_reset\n", wlc_hw->unit));
 
 	WLCNTINCR(wlc_hw->wlc->pub->_cnt->reset);
@@ -1176,7 +1183,8 @@ BCMINITFN(wlc_bmac_init) (wlc_hw_info_t
 		wlc_clkctl_clk(wlc_hw, CLK_DYNAMIC);
 }
 
-int BCMINITFN(wlc_bmac_up_prep) (wlc_hw_info_t *wlc_hw) {
+int BCMINITFN(wlc_bmac_up_prep) (wlc_hw_info_t *wlc_hw)
+{
 	uint coremask;
 
 	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
@@ -1223,7 +1231,8 @@ int BCMINITFN(wlc_bmac_up_prep) (wlc_hw_
 	return 0;
 }
 
-int BCMINITFN(wlc_bmac_up_finish) (wlc_hw_info_t *wlc_hw) {
+int BCMINITFN(wlc_bmac_up_finish) (wlc_hw_info_t *wlc_hw)
+{
 	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
 
 	wlc_hw->up = TRUE;
@@ -1236,7 +1245,8 @@ int BCMINITFN(wlc_bmac_up_finish) (wlc_h
 	return 0;
 }
 
-int BCMUNINITFN(wlc_bmac_down_prep) (wlc_hw_info_t *wlc_hw) {
+int BCMUNINITFN(wlc_bmac_down_prep) (wlc_hw_info_t *wlc_hw)
+{
 	bool dev_gone;
 	uint callbacks = 0;
 
@@ -1263,7 +1273,8 @@ int BCMUNINITFN(wlc_bmac_down_prep) (wlc
 	return callbacks;
 }
 
-int BCMUNINITFN(wlc_bmac_down_finish) (wlc_hw_info_t *wlc_hw) {
+int BCMUNINITFN(wlc_bmac_down_finish) (wlc_hw_info_t *wlc_hw)
+{
 	uint callbacks = 0;
 	bool dev_gone;
 
@@ -1441,7 +1452,8 @@ static void wlc_clkctl_clk(wlc_hw_info_t
 
 /* set initial host flags value */
 static void
-BCMINITFN(wlc_mhfdef) (wlc_info_t *wlc, uint16 *mhfs, uint16 mhf2_init) {
+BCMINITFN(wlc_mhfdef) (wlc_info_t *wlc, uint16 *mhfs, uint16 mhf2_init)
+{
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 
 	bzero(mhfs, sizeof(uint16) * MHFMAX);
@@ -1896,7 +1908,8 @@ wlc_bmac_write_hw_bcntemplates(wlc_hw_in
 	}
 }
 
-static void WLBANDINITFN(wlc_bmac_upd_synthpu) (wlc_hw_info_t *wlc_hw) {
+static void WLBANDINITFN(wlc_bmac_upd_synthpu) (wlc_hw_info_t *wlc_hw)
+{
 	uint16 v;
 	wlc_info_t *wlc = wlc_hw->wlc;
 	/* update SYNTHPU_DLY */
@@ -1914,7 +1927,8 @@ static void WLBANDINITFN(wlc_bmac_upd_sy
 
 /* band-specific init */
 static void
-WLBANDINITFN(wlc_bmac_bsinit) (wlc_info_t *wlc, chanspec_t chanspec) {
+WLBANDINITFN(wlc_bmac_bsinit) (wlc_info_t *wlc, chanspec_t chanspec)
+{
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 
 	WL_TRACE(("wl%d: wlc_bmac_bsinit: bandunit %d\n", wlc_hw->unit,
@@ -2105,7 +2119,8 @@ WLBANDINITFN(wlc_bmac_setband) (wlc_hw_i
 }
 
 /* low-level band switch utility routine */
-void WLBANDINITFN(wlc_setxband) (wlc_hw_info_t *wlc_hw, uint bandunit) {
+void WLBANDINITFN(wlc_setxband) (wlc_hw_info_t *wlc_hw, uint bandunit)
+{
 	WL_TRACE(("wl%d: wlc_setxband: bandunit %d\n", wlc_hw->unit, bandunit));
 
 	wlc_hw->band = wlc_hw->bandstate[bandunit];
@@ -2120,7 +2135,8 @@ void WLBANDINITFN(wlc_setxband) (wlc_hw_
 	}
 }
 
-static bool BCMATTACHFN(wlc_isgoodchip) (wlc_hw_info_t *wlc_hw) {
+static bool BCMATTACHFN(wlc_isgoodchip) (wlc_hw_info_t *wlc_hw)
+{
 
 	/* reject unsupported corerev */
 	if (!VALID_COREREV(wlc_hw->corerev)) {
@@ -2131,7 +2147,8 @@ static bool BCMATTACHFN(wlc_isgoodchip)
 	return TRUE;
 }
 
-static bool BCMATTACHFN(wlc_validboardtype) (wlc_hw_info_t *wlc_hw) {
+static bool BCMATTACHFN(wlc_validboardtype) (wlc_hw_info_t *wlc_hw)
+{
 	bool goodboard = TRUE;
 	uint boardrev = wlc_hw->boardrev;
 
@@ -2154,7 +2171,8 @@ static bool BCMATTACHFN(wlc_validboardty
 	return goodboard;
 }
 
-static char *BCMINITFN(wlc_get_macaddr) (wlc_hw_info_t *wlc_hw) {
+static char *BCMINITFN(wlc_get_macaddr) (wlc_hw_info_t *wlc_hw)
+{
 	const char *varname = "macaddr";
 	char *macaddr;
 
@@ -2226,7 +2244,8 @@ bool wlc_bmac_radio_read_hwdisabled(wlc_
 }
 
 /* Initialize just the hardware when coming out of POR or S3/S5 system states */
-void BCMINITFN(wlc_bmac_hw_up) (wlc_hw_info_t *wlc_hw) {
+void BCMINITFN(wlc_bmac_hw_up) (wlc_hw_info_t *wlc_hw)
+{
 	if (wlc_hw->wlc->pub->hw_up)
 		return;
 
@@ -2300,7 +2319,8 @@ static bool wlc_dma_rxreset(wlc_hw_info_
  *   clear software macintstatus for fresh new start
  * one testing hack wlc_hw->noreset will bypass the d11/phy reset
  */
-void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t *wlc_hw, uint32 flags) {
+void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t *wlc_hw, uint32 flags)
+{
 	d11regs_t *regs;
 	uint i;
 	bool fastclk;
@@ -2387,7 +2407,8 @@ void BCMINITFN(wlc_bmac_corereset) (wlc_
  * txfifo sizes needs to be modified(increased) since the newer cores
  * have more memory.
  */
-static void BCMINITFN(wlc_corerev_fifofixup) (wlc_hw_info_t *wlc_hw) {
+static void BCMINITFN(wlc_corerev_fifofixup) (wlc_hw_info_t *wlc_hw)
+{
 	d11regs_t *regs = wlc_hw->regs;
 	uint16 fifo_nu;
 	uint16 txfifo_startblk = TXFIFO_START_BLK, txfifo_endblk;
@@ -2446,7 +2467,8 @@ static void BCMINITFN(wlc_corerev_fifofi
  *   config other core registers
  *   init dma
  */
-static void BCMINITFN(wlc_coreinit) (wlc_info_t *wlc) {
+static void BCMINITFN(wlc_coreinit) (wlc_info_t *wlc)
+{
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs;
 	uint32 sflags;
@@ -2687,7 +2709,8 @@ void wlc_bmac_switch_macfreq(wlc_hw_info
 }
 
 /* Initialize GPIOs that are controlled by D11 core */
-static void BCMINITFN(wlc_gpio_init) (wlc_info_t *wlc) {
+static void BCMINITFN(wlc_gpio_init) (wlc_info_t *wlc)
+{
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs;
 	uint32 gc, gm;
@@ -2751,7 +2774,8 @@ static void BCMINITFN(wlc_gpio_init) (wl
 	si_gpiocontrol(wlc_hw->sih, gm, gc, GPIO_DRV_PRIORITY);
 }
 
-static void BCMATTACHFN(wlc_ucode_download) (wlc_hw_info_t *wlc_hw) {
+static void BCMATTACHFN(wlc_ucode_download) (wlc_hw_info_t *wlc_hw)
+{
 	wlc_info_t *wlc;
 	wlc = wlc_hw->wlc;
 
@@ -3634,7 +3658,8 @@ wlc_bmac_read_tsf(wlc_hw_info_t *wlc_hw,
 	return;
 }
 
-bool BCMATTACHFN(wlc_bmac_validate_chip_access) (wlc_hw_info_t *wlc_hw) {
+bool BCMATTACHFN(wlc_bmac_validate_chip_access) (wlc_hw_info_t *wlc_hw)
+{
 	d11regs_t *regs;
 	uint32 w, val;
 	volatile uint16 *reg16;
--- a/drivers/staging/brcm80211/sys/wlc_channel.c
+++ b/drivers/staging/brcm80211/sys/wlc_channel.c
@@ -599,7 +599,8 @@ const locale_mimo_info_t *wlc_get_mimo_5
 	return g_mimo_5g_table[locale_idx];
 }
 
-wlc_cm_info_t *BCMATTACHFN(wlc_channel_mgr_attach) (wlc_info_t *wlc) {
+wlc_cm_info_t *BCMATTACHFN(wlc_channel_mgr_attach) (wlc_info_t *wlc)
+{
 	wlc_cm_info_t *wlc_cm;
 	char country_abbrev[WLC_CNTRY_BUF_SZ];
 	const country_info_t *country;
@@ -646,7 +647,8 @@ wlc_cm_info_t *BCMATTACHFN(wlc_channel_m
 	return wlc_cm;
 }
 
-void BCMATTACHFN(wlc_channel_mgr_detach) (wlc_cm_info_t *wlc_cm) {
+void BCMATTACHFN(wlc_channel_mgr_detach) (wlc_cm_info_t *wlc_cm)
+{
 	if (wlc_cm)
 		MFREE(wlc_cm->pub->osh, wlc_cm, sizeof(wlc_cm_info_t));
 }
--- a/drivers/staging/brcm80211/sys/wlc_event.c
+++ b/drivers/staging/brcm80211/sys/wlc_event.c
@@ -79,7 +79,8 @@ wlc_eventq_t *BCMATTACHFN(wlc_eventq_att
 	return eq;
 }
 
-int BCMATTACHFN(wlc_eventq_detach) (wlc_eventq_t *eq) {
+int BCMATTACHFN(wlc_eventq_detach) (wlc_eventq_t *eq)
+{
 	/* Clean up pending events */
 	wlc_eventq_down(eq);
 
@@ -97,7 +98,8 @@ int BCMATTACHFN(wlc_eventq_detach) (wlc_
 	return 0;
 }
 
-int BCMUNINITFN(wlc_eventq_down) (wlc_eventq_t *eq) {
+int BCMUNINITFN(wlc_eventq_down) (wlc_eventq_t *eq)
+{
 	int callbacks = 0;
 	if (eq->tpending && !eq->workpending) {
 		if (!wl_del_timer(eq->wl, eq->timer))
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -397,7 +397,8 @@ bool wlc_ps_allowed(wlc_info_t *wlc)
 	return TRUE;
 }
 
-void BCMINITFN(wlc_reset) (wlc_info_t *wlc) {
+void BCMINITFN(wlc_reset) (wlc_info_t *wlc)
+{
 	WL_TRACE(("wl%d: wlc_reset\n", wlc->pub->unit));
 
 	wlc->check_for_unaligned_tbtt = FALSE;
@@ -443,7 +444,8 @@ void wlc_fatal_error(wlc_info_t *wlc)
  * if other configurations are in conflict (bandlocked, 11n mode disabled,
  * invalid channel for current country, etc.)
  */
-static chanspec_t BCMINITFN(wlc_init_chanspec) (wlc_info_t *wlc) {
+static chanspec_t BCMINITFN(wlc_init_chanspec) (wlc_info_t *wlc)
+{
 	chanspec_t chanspec =
 	    1 | WL_CHANSPEC_BW_20 | WL_CHANSPEC_CTL_SB_NONE |
 	    WL_CHANSPEC_BAND_2G;
@@ -466,7 +468,8 @@ static void wlc_init_scb(wlc_info_t *wlc
 		scb->seqnum[i] = 0;
 }
 
-void BCMINITFN(wlc_init) (wlc_info_t *wlc) {
+void BCMINITFN(wlc_init) (wlc_info_t *wlc)
+{
 	d11regs_t *regs;
 	chanspec_t chanspec;
 	int i;
@@ -1326,7 +1329,8 @@ static void wlc_bandinit_ordered(wlc_inf
 }
 
 /* band-specific init */
-static void WLBANDINITFN(wlc_bsinit) (wlc_info_t *wlc) {
+static void WLBANDINITFN(wlc_bsinit) (wlc_info_t *wlc)
+{
 	WL_TRACE(("wl%d: wlc_bsinit: bandunit %d\n", wlc->pub->unit,
 		  wlc->band->bandunit));
 
@@ -1343,7 +1347,8 @@ static void WLBANDINITFN(wlc_bsinit) (wl
 }
 
 /* switch to and initialize new band */
-static void WLBANDINITFN(wlc_setband) (wlc_info_t *wlc, uint bandunit) {
+static void WLBANDINITFN(wlc_setband) (wlc_info_t *wlc, uint bandunit)
+{
 	int idx;
 	wlc_bsscfg_t *cfg;
 
@@ -1562,7 +1567,8 @@ void wlc_edcf_setparams(wlc_bsscfg_t *cf
 
 }
 
-bool BCMATTACHFN(wlc_timers_init) (wlc_info_t *wlc, int unit) {
+bool BCMATTACHFN(wlc_timers_init) (wlc_info_t *wlc, int unit)
+{
 	if (!
 	    (wlc->wdtimer =
 	     wl_init_timer(wlc->wl, wlc_watchdog_by_timer, wlc, "watchdog"))) {
@@ -1588,7 +1594,8 @@ bool BCMATTACHFN(wlc_timers_init) (wlc_i
  * Initialize wlc_info default values ...
  * may get overrides later in this function
  */
-void BCMATTACHFN(wlc_info_init) (wlc_info_t *wlc, int unit) {
+void BCMATTACHFN(wlc_info_init) (wlc_info_t *wlc, int unit)
+{
 	int i;
 	/* Assume the device is there until proven otherwise */
 	wlc->device_present = TRUE;
@@ -1712,7 +1719,8 @@ static bool wlc_state_bmac_sync(wlc_info
 	return TRUE;
 }
 
-static uint BCMATTACHFN(wlc_attach_module) (wlc_info_t *wlc) {
+static uint BCMATTACHFN(wlc_attach_module) (wlc_info_t *wlc)
+{
 	uint err = 0;
 	uint unit;
 	unit = wlc->pub->unit;
@@ -2080,7 +2088,8 @@ void *BCMATTACHFN(wlc_attach) (void *wl,
 	return (NULL);
 }
 
-static void BCMNMIATTACHFN(wlc_attach_antgain_init) (wlc_info_t *wlc) {
+static void BCMNMIATTACHFN(wlc_attach_antgain_init) (wlc_info_t *wlc)
+{
 	uint unit;
 	unit = wlc->pub->unit;
 
@@ -2110,7 +2119,8 @@ static void BCMNMIATTACHFN(wlc_attach_an
 	}
 }
 
-static bool BCMATTACHFN(wlc_attach_stf_ant_init) (wlc_info_t *wlc) {
+static bool BCMATTACHFN(wlc_attach_stf_ant_init) (wlc_info_t *wlc)
+{
 	int aa;
 	uint unit;
 	char *vars;
@@ -2277,7 +2287,8 @@ int wlc_bmac_detach(wlc_info_t *wlc)
 
 #endif				/* WLC_HIGH_ONLY */
 
-static void BCMATTACHFN(wlc_timers_deinit) (wlc_info_t *wlc) {
+static void BCMATTACHFN(wlc_timers_deinit) (wlc_info_t *wlc)
+{
 	/* free timer state */
 	if (wlc->wdtimer) {
 		wl_free_timer(wlc->wl, wlc->wdtimer);
@@ -2289,7 +2300,8 @@ static void BCMATTACHFN(wlc_timers_deini
 	}
 }
 
-static void BCMATTACHFN(wlc_detach_module) (wlc_info_t *wlc) {
+static void BCMATTACHFN(wlc_detach_module) (wlc_info_t *wlc)
+{
 	if (wlc->asi) {
 		wlc_antsel_detach(wlc->asi);
 		wlc->asi = NULL;
@@ -2311,7 +2323,8 @@ static void BCMATTACHFN(wlc_detach_modul
  *    One exception is sb register access, which is possible if crystal is turned on
  * After "down" state, driver should avoid software timer with the exception of radio_monitor.
  */
-uint BCMATTACHFN(wlc_detach) (wlc_info_t *wlc) {
+uint BCMATTACHFN(wlc_detach) (wlc_info_t *wlc)
+{
 	uint i;
 	uint callbacks = 0;
 
@@ -2728,7 +2741,8 @@ static void wlc_watchdog(void *arg)
 }
 
 /* make interface operational */
-int BCMINITFN(wlc_up) (wlc_info_t *wlc) {
+int BCMINITFN(wlc_up) (wlc_info_t *wlc)
+{
 	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __func__));
 
 	/* HW is turned off so don't try to access it */
@@ -2835,7 +2849,8 @@ int BCMINITFN(wlc_up) (wlc_info_t *wlc)
 }
 
 /* Initialize the base precedence map for dequeueing from txq based on WME settings */
-static void BCMINITFN(wlc_tx_prec_map_init) (wlc_info_t *wlc) {
+static void BCMINITFN(wlc_tx_prec_map_init) (wlc_info_t *wlc)
+{
 	wlc->tx_prec_map = WLC_PREC_BMP_ALL;
 	bzero(wlc->fifo2prec_map, sizeof(uint16) * NFIFO);
 
@@ -2853,7 +2868,8 @@ static void BCMINITFN(wlc_tx_prec_map_in
 	}
 }
 
-static uint BCMUNINITFN(wlc_down_del_timer) (wlc_info_t *wlc) {
+static uint BCMUNINITFN(wlc_down_del_timer) (wlc_info_t *wlc)
+{
 	uint callbacks = 0;
 
 	return callbacks;
@@ -2864,7 +2880,8 @@ static uint BCMUNINITFN(wlc_down_del_tim
  * disable the hardware, free any transient buffer state.
  * Return a count of the number of driver callbacks still pending.
  */
-uint BCMUNINITFN(wlc_down) (wlc_info_t *wlc) {
+uint BCMUNINITFN(wlc_down) (wlc_info_t *wlc)
+{
 
 	uint callbacks = 0;
 	int i;
@@ -8505,7 +8522,8 @@ void wlc_default_rateset(wlc_info_t *wlc
 			    wlc->stf->txstreams);
 }
 
-static void BCMATTACHFN(wlc_bss_default_init) (wlc_info_t *wlc) {
+static void BCMATTACHFN(wlc_bss_default_init) (wlc_info_t *wlc)
+{
 	chanspec_t chanspec;
 	wlcband_t *band;
 	wlc_bss_info_t *bi = wlc->default_bss;
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.c
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.c
@@ -79,7 +79,8 @@ wlc_phy_shim_info_t *BCMATTACHFN(wlc_phy
 	return physhim;
 }
 
-void BCMATTACHFN(wlc_phy_shim_detach) (wlc_phy_shim_info_t *physhim) {
+void BCMATTACHFN(wlc_phy_shim_detach) (wlc_phy_shim_info_t *physhim)
+{
 	if (!physhim)
 		return;
 
--- a/drivers/staging/brcm80211/sys/wlc_stf.c
+++ b/drivers/staging/brcm80211/sys/wlc_stf.c
@@ -402,7 +402,8 @@ int wlc_stf_ss_update(wlc_info_t *wlc, w
 	return ret_code;
 }
 
-int BCMATTACHFN(wlc_stf_attach) (wlc_info_t *wlc) {
+int BCMATTACHFN(wlc_stf_attach) (wlc_info_t *wlc)
+{
 	wlc->bandstate[BAND_2G_INDEX]->band_stf_ss_mode = PHY_TXC1_MODE_SISO;
 	wlc->bandstate[BAND_5G_INDEX]->band_stf_ss_mode = PHY_TXC1_MODE_CDD;
 
@@ -424,7 +425,8 @@ int BCMATTACHFN(wlc_stf_attach) (wlc_inf
 	return 0;
 }
 
-void BCMATTACHFN(wlc_stf_detach) (wlc_info_t *wlc) {
+void BCMATTACHFN(wlc_stf_detach) (wlc_info_t *wlc)
+{
 }
 
 int wlc_stf_ant_txant_validate(wlc_info_t *wlc, int8 val)
@@ -520,7 +522,8 @@ void wlc_stf_phy_txant_upd(wlc_info_t *w
 	_wlc_stf_phy_txant_upd(wlc);
 }
 
-void BCMATTACHFN(wlc_stf_phy_chain_calc) (wlc_info_t *wlc) {
+void BCMATTACHFN(wlc_stf_phy_chain_calc) (wlc_info_t *wlc)
+{
 	/* get available rx/tx chains */
 	wlc->stf->hw_txchain = (uint8) getintvar(wlc->pub->vars, "txchain");
 	wlc->stf->hw_rxchain = (uint8) getintvar(wlc->pub->vars, "rxchain");
--- a/drivers/staging/brcm80211/util/aiutils.c
+++ b/drivers/staging/brcm80211/util/aiutils.c
@@ -105,7 +105,8 @@ static void ai_hwfixup(si_info_t *sii)
 }
 
 /* parse the enumeration rom to identify all cores */
-void BCMATTACHFN(ai_scan) (si_t *sih, void *regs, uint devid) {
+void BCMATTACHFN(ai_scan) (si_t *sih, void *regs, uint devid)
+{
 	si_info_t *sii = SI_INFO(sih);
 	chipcregs_t *cc = (chipcregs_t *) regs;
 	uint32 erombase, *eromptr, *eromlim;
--- a/drivers/staging/brcm80211/util/bcmotp.c
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -233,7 +233,8 @@ static int ipxotp_max_rgnsz(si_t *sih, i
 	return ret;
 }
 
-static void BCMNMIATTACHFN(_ipxotp_init) (otpinfo_t *oi, chipcregs_t *cc) {
+static void BCMNMIATTACHFN(_ipxotp_init) (otpinfo_t *oi, chipcregs_t *cc)
+{
 	uint k;
 	uint32 otpp, st;
 
@@ -302,7 +303,8 @@ static void BCMNMIATTACHFN(_ipxotp_init)
 	oi->flim = oi->wsize;
 }
 
-static void *BCMNMIATTACHFN(ipxotp_init) (si_t *sih) {
+static void *BCMNMIATTACHFN(ipxotp_init) (si_t *sih)
+{
 	uint idx;
 	chipcregs_t *cc;
 	otpinfo_t *oi;
@@ -623,7 +625,8 @@ static uint16 hndotp_read_bit(void *oh,
 	return (uint16) st;
 }
 
-static void *BCMNMIATTACHFN(hndotp_init) (si_t *sih) {
+static void *BCMNMIATTACHFN(hndotp_init) (si_t *sih)
+{
 	uint idx;
 	chipcregs_t *cc;
 	otpinfo_t *oi;
@@ -885,7 +888,8 @@ uint16 otp_read_bit(void *oh, uint offse
 	return readBit;
 }
 
-void *BCMNMIATTACHFN(otp_init) (si_t *sih) {
+void *BCMNMIATTACHFN(otp_init) (si_t *sih)
+{
 	otpinfo_t *oi;
 	void *ret = NULL;
 
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -90,13 +90,15 @@ static int initvars_table(osl_t *osh, ch
 static int initvars_flash(si_t *sih, osl_t *osh, char **vp, uint len);
 
 /* Initialization of varbuf structure */
-static void BCMATTACHFN(varbuf_init) (varbuf_t *b, char *buf, uint size) {
+static void BCMATTACHFN(varbuf_init) (varbuf_t *b, char *buf, uint size)
+{
 	b->size = size;
 	b->base = b->buf = buf;
 }
 
 /* append a null terminated var=value string */
-static int BCMATTACHFN(varbuf_append) (varbuf_t *b, const char *fmt, ...) {
+static int BCMATTACHFN(varbuf_append) (varbuf_t *b, const char *fmt, ...)
+{
 	va_list ap;
 	int r;
 	size_t len;
@@ -1582,7 +1584,8 @@ BCMATTACHFN(initvars_table) (osl_t *osh,
  * Return 0 on success, nonzero on error.
  */
 static int
-BCMATTACHFN(initvars_flash) (si_t *sih, osl_t *osh, char **base, uint len) {
+BCMATTACHFN(initvars_flash) (si_t *sih, osl_t *osh, char **base, uint len)
+{
 	char *vp = *base;
 	char *flash;
 	int err;
@@ -1638,7 +1641,8 @@ BCMATTACHFN(initvars_flash) (si_t *sih,
  * Return 0 on success, nonzero on error.
  */
 static int
-BCMATTACHFN(initvars_flash_si) (si_t *sih, char **vars, uint *count) {
+BCMATTACHFN(initvars_flash_si) (si_t *sih, char **vars, uint *count)
+{
 	osl_t *osh = si_osh(sih);
 	char *vp, *base;
 	int err;
@@ -1992,7 +1996,8 @@ BCMATTACHFN(initvars_srom_pci) (si_t *si
  * Return 0 on success, nonzero on error.
  */
 static int
-BCMATTACHFN(initvars_cis_sdio) (osl_t *osh, char **vars, uint *count) {
+BCMATTACHFN(initvars_cis_sdio) (osl_t *osh, char **vars, uint *count)
+{
 	uint8 *cis[SBSDIO_NUM_FUNCTION + 1];
 	uint fn, numfn;
 	int rc = 0;
@@ -2026,7 +2031,8 @@ BCMATTACHFN(initvars_cis_sdio) (osl_t *o
 }
 
 /* set SDIO sprom command register */
-static int BCMATTACHFN(sprom_cmd_sdio) (osl_t *osh, uint8 cmd) {
+static int BCMATTACHFN(sprom_cmd_sdio) (osl_t *osh, uint8 cmd)
+{
 	uint8 status = 0;
 	uint wait_cnt = 1000;
 
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -525,7 +525,8 @@ const unsigned char bcm_ctype[] = {
 	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L	/* 240-255 */
 };
 
-ulong BCMROMFN(bcm_strtoul) (char *cp, char **endp, uint base) {
+ulong BCMROMFN(bcm_strtoul) (char *cp, char **endp, uint base)
+{
 	ulong result, last_result = 0, value;
 	bool minus;
 
@@ -580,12 +581,14 @@ ulong BCMROMFN(bcm_strtoul) (char *cp, c
 	return (result);
 }
 
-int BCMROMFN(bcm_atoi) (char *s) {
+int BCMROMFN(bcm_atoi) (char *s)
+{
 	return (int)bcm_strtoul(s, NULL, 10);
 }
 
 /* return pointer to location of substring 'needle' in 'haystack' */
-char *BCMROMFN(bcmstrstr) (char *haystack, char *needle) {
+char *BCMROMFN(bcmstrstr) (char *haystack, char *needle)
+{
 	int len, nlen;
 	int i;
 
@@ -601,7 +604,8 @@ char *BCMROMFN(bcmstrstr) (char *haystac
 	return (NULL);
 }
 
-char *BCMROMFN(bcmstrcat) (char *dest, const char *src) {
+char *BCMROMFN(bcmstrcat) (char *dest, const char *src)
+{
 	char *p;
 
 	p = dest + strlen(dest);
@@ -611,7 +615,8 @@ char *BCMROMFN(bcmstrcat) (char *dest, c
 	return (dest);
 }
 
-char *BCMROMFN(bcmstrncat) (char *dest, const char *src, uint size) {
+char *BCMROMFN(bcmstrncat) (char *dest, const char *src, uint size)
+{
 	char *endp;
 	char *p;
 
@@ -778,7 +783,8 @@ int bcmstrnicmp(const char *s1, const ch
 }
 
 /* parse a xx:xx:xx:xx:xx:xx format ethernet address */
-int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr *ea) {
+int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr *ea)
+{
 	int i = 0;
 
 	for (;;) {
@@ -959,7 +965,8 @@ const char *bcmerrorstr(int bcmerror)
 }
 
 #ifdef WLC_LOW
-static void BCMINITFN(bcm_nvram_refresh) (char *flash) {
+static void BCMINITFN(bcm_nvram_refresh) (char *flash)
+{
 	int i;
 	int ret = 0;
 
@@ -998,7 +1005,8 @@ char *bcm_nvram_vars(uint *length)
 }
 
 /* copy nvram vars into locally-allocated multi-string array */
-int BCMINITFN(bcm_nvram_cache) (void *sih) {
+int BCMINITFN(bcm_nvram_cache) (void *sih)
+{
 	int ret = 0;
 	void *osh;
 	char *flash = NULL;
@@ -1254,7 +1262,8 @@ uint16 BCMROMFN(hndcrc16) (uint8 *pdata,
  * *buflen is not modified if the TLV elt parameter is invalid, or is decremented
  * by the TLV parameter's length if it is valid.
  */
-bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t *elt, int *buflen) {
+bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t *elt, int *buflen)
+{
 	int len;
 
 	/* validate current elt */
@@ -1278,7 +1287,8 @@ bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_t
  * triples, returning a pointer to the substring whose first element
  * matches tag
  */
-bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (void *buf, int buflen, uint key) {
+bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (void *buf, int buflen, uint key)
+{
 	bcm_tlv_t *elt;
 	int totlen;
 
@@ -1306,7 +1316,8 @@ bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (voi
  * matches tag.  Stop parsing when we see an element whose ID is greater
  * than the target key.
  */
-bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tlvs) (void *buf, int buflen, uint key) {
+bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tlvs) (void *buf, int buflen, uint key)
+{
 	bcm_tlv_t *elt;
 	int totlen;
 
@@ -1589,7 +1600,8 @@ static const uint16 nqdBm_to_mW_map[QDBM
 /* 185: */ 42170, 44668, 47315, 50119, 53088, 56234, 59566, 63096
 };
 
-uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 qdbm) {
+uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 qdbm)
+{
 	uint factor = 1;
 	int idx = qdbm - QDBM_OFFSET;
 
@@ -1612,7 +1624,8 @@ uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 q
 	return ((nqdBm_to_mW_map[idx] + factor / 2) / factor);
 }
 
-uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw) {
+uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw)
+{
 	uint8 qdbm;
 	int offset;
 	uint mw_uint = mw;
@@ -1642,7 +1655,8 @@ uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 m
 	return (qdbm);
 }
 
-uint BCMROMFN(bcm_bitcount) (uint8 *bitmap, uint length) {
+uint BCMROMFN(bcm_bitcount) (uint8 *bitmap, uint length)
+{
 	uint bitcount = 0, i;
 	uint8 tmp;
 	for (i = 0; i < length; i++) {
--- a/drivers/staging/brcm80211/util/bcmwpa.c
+++ b/drivers/staging/brcm80211/util/bcmwpa.c
@@ -39,7 +39,8 @@ bool bcm_is_wfa_ie(uint8 *ie, uint8 **tl
 	return FALSE;
 }
 
-wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (uint8 * parse, uint len) {
+wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (uint8 * parse, uint len)
+{
 	bcm_tlv_t *ie;
 
 	while ((ie = bcm_parse_tlvs(parse, len, DOT11_MNG_VS_ID))) {
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -182,7 +182,8 @@ BCMATTACHFN(si_pmu_set_ldo_voltage) (si_
 /* d11 slow to fast clock transition time in slow clock cycles */
 #define D11SCC_SLOW2FAST_TRANSITION	2
 
-uint16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t *sih, osl_t *osh) {
+uint16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t *sih, osl_t *osh)
+{
 	uint delay = PMU_MAX_TRANSITION_DLY;
 	chipcregs_t *cc;
 	uint origidx;
@@ -258,7 +259,8 @@ uint16 BCMINITFN(si_pmu_fast_pwrup_delay
 	return (uint16) delay;
 }
 
-uint32 BCMATTACHFN(si_pmu_force_ilp) (si_t *sih, osl_t *osh, bool force) {
+uint32 BCMATTACHFN(si_pmu_force_ilp) (si_t *sih, osl_t *osh, bool force)
+{
 	chipcregs_t *cc;
 	uint origidx;
 	uint32 oldpmucontrol;
@@ -578,23 +580,27 @@ static const pmu_res_depend_t BCMATTACHD
 };
 
 /* TRUE if the power topology uses the buck boost to provide 3.3V to VDDIO_RF and WLAN PA */
-static bool BCMATTACHFN(si_pmu_res_depfltr_bb) (si_t *sih) {
+static bool BCMATTACHFN(si_pmu_res_depfltr_bb) (si_t *sih)
+{
 	return (sih->boardflags & BFL_BUCKBOOST) != 0;
 }
 
 /* TRUE if the power topology doesn't use the cbuck. Key on chiprev also if the chip is BCM4325. */
-static bool BCMATTACHFN(si_pmu_res_depfltr_ncb) (si_t *sih) {
+static bool BCMATTACHFN(si_pmu_res_depfltr_ncb) (si_t *sih)
+{
 
 	return ((sih->boardflags & BFL_NOCBUCK) != 0);
 }
 
 /* TRUE if the power topology uses the PALDO */
-static bool BCMATTACHFN(si_pmu_res_depfltr_paldo) (si_t *sih) {
+static bool BCMATTACHFN(si_pmu_res_depfltr_paldo) (si_t *sih)
+{
 	return (sih->boardflags & BFL_PALDO) != 0;
 }
 
 /* TRUE if the power topology doesn't use the PALDO */
-static bool BCMATTACHFN(si_pmu_res_depfltr_npaldo) (si_t *sih) {
+static bool BCMATTACHFN(si_pmu_res_depfltr_npaldo) (si_t *sih)
+{
 	return (sih->boardflags & BFL_PALDO) == 0;
 }
 
@@ -688,7 +694,8 @@ static void si_pmu_res_masks(si_t *sih,
 }
 
 /* initialize PMU resources */
-void BCMATTACHFN(si_pmu_res_init) (si_t *sih, osl_t *osh) {
+void BCMATTACHFN(si_pmu_res_init) (si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
 	const pmu_res_updown_t *pmu_res_updown_table = NULL;
@@ -1104,7 +1111,8 @@ static const pmu1_xtaltab0_t BCMINITDATA
 #define PMU1_XTALTAB0_960_48000K	15
 
 /* select xtal table for each chip */
-static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaltab0) (si_t *sih) {
+static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaltab0) (si_t *sih)
+{
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1130,7 +1138,8 @@ static const pmu1_xtaltab0_t *BCMINITFN(
 }
 
 /* select default xtal frequency for each chip */
-static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaldef0) (si_t *sih) {
+static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaldef0) (si_t *sih)
+{
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1161,7 +1170,8 @@ static const pmu1_xtaltab0_t *BCMINITFN(
 }
 
 /* select default pll fvco for each chip */
-static uint32 BCMINITFN(si_pmu1_pllfvco0) (si_t *sih) {
+static uint32 BCMINITFN(si_pmu1_pllfvco0) (si_t *sih)
+{
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1189,7 +1199,8 @@ static uint32 BCMINITFN(si_pmu1_pllfvco0
 
 /* query alp/xtal clock frequency */
 static uint32
-BCMINITFN(si_pmu1_alpclk0) (si_t *sih, osl_t *osh, chipcregs_t *cc) {
+BCMINITFN(si_pmu1_alpclk0) (si_t *sih, osl_t *osh, chipcregs_t *cc)
+{
 	const pmu1_xtaltab0_t *xt;
 	uint32 xf;
 
@@ -1459,7 +1470,8 @@ BCMATTACHFN(si_pmu1_pllinit0) (si_t *sih
 
 /* query the CPU clock frequency */
 static uint32
-BCMINITFN(si_pmu1_cpuclk0) (si_t *sih, osl_t *osh, chipcregs_t *cc) {
+BCMINITFN(si_pmu1_cpuclk0) (si_t *sih, osl_t *osh, chipcregs_t *cc)
+{
 	uint32 tmp, m1div;
 #ifdef BCMDBG
 	uint32 ndiv_int, ndiv_frac, p2div, p1div, fvco;
@@ -1512,7 +1524,8 @@ BCMINITFN(si_pmu1_cpuclk0) (si_t *sih, o
 }
 
 /* initialize PLL */
-void BCMATTACHFN(si_pmu_pll_init) (si_t *sih, osl_t *osh, uint xtalfreq) {
+void BCMATTACHFN(si_pmu_pll_init) (si_t *sih, osl_t *osh, uint xtalfreq)
+{
 	chipcregs_t *cc;
 	uint origidx;
 #ifdef BCMDBG
@@ -1564,7 +1577,8 @@ void BCMATTACHFN(si_pmu_pll_init) (si_t
 }
 
 /* query alp/xtal clock frequency */
-uint32 BCMINITFN(si_pmu_alp_clock) (si_t *sih, osl_t *osh) {
+uint32 BCMINITFN(si_pmu_alp_clock) (si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
 	uint32 clock = ALP_CLOCK;
@@ -1677,7 +1691,8 @@ BCMINITFN(si_pmu5_clock) (si_t *sih, osl
 /* For designs that feed the same clock to both backplane
  * and CPU just return the CPU clock speed.
  */
-uint32 BCMINITFN(si_pmu_si_clock) (si_t *sih, osl_t *osh) {
+uint32 BCMINITFN(si_pmu_si_clock) (si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
 	uint32 clock = HT_CLOCK;
@@ -1755,7 +1770,8 @@ uint32 BCMINITFN(si_pmu_si_clock) (si_t
 }
 
 /* query CPU clock frequency */
-uint32 BCMINITFN(si_pmu_cpu_clock) (si_t *sih, osl_t *osh) {
+uint32 BCMINITFN(si_pmu_cpu_clock) (si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
 	uint32 clock;
@@ -1798,7 +1814,8 @@ uint32 BCMINITFN(si_pmu_cpu_clock) (si_t
 }
 
 /* query memory clock frequency */
-uint32 BCMINITFN(si_pmu_mem_clock) (si_t *sih, osl_t *osh) {
+uint32 BCMINITFN(si_pmu_mem_clock) (si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
 	uint32 clock;
@@ -1846,7 +1863,8 @@ uint32 BCMINITFN(si_pmu_mem_clock) (si_t
 
 static uint32 ilpcycles_per_sec = 0;
 
-uint32 BCMINITFN(si_pmu_ilp_clock) (si_t *sih, osl_t *osh) {
+uint32 BCMINITFN(si_pmu_ilp_clock) (si_t *sih, osl_t *osh)
+{
 	if (ISSIM_ENAB(sih))
 		return ILP_CLOCK;
 
@@ -1969,7 +1987,8 @@ BCMINITFN(si_sdiod_drive_strength_init)
 }
 
 /* initialize PMU */
-void BCMATTACHFN(si_pmu_init) (si_t *sih, osl_t *osh) {
+void BCMATTACHFN(si_pmu_init) (si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
 
@@ -2513,7 +2532,8 @@ BCMATTACHFN(si_pmu_sprom_enable) (si_t *
 }
 
 /* initialize PMU chip controls and other chip level stuff */
-void BCMATTACHFN(si_pmu_chip_init) (si_t *sih, osl_t *osh) {
+void BCMATTACHFN(si_pmu_chip_init) (si_t *sih, osl_t *osh)
+{
 	uint origidx;
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
@@ -2534,7 +2554,8 @@ void BCMATTACHFN(si_pmu_chip_init) (si_t
 }
 
 /* initialize PMU switch/regulators */
-void BCMATTACHFN(si_pmu_swreg_init) (si_t *sih, osl_t *osh) {
+void BCMATTACHFN(si_pmu_swreg_init) (si_t *sih, osl_t *osh)
+{
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
 	switch (CHIPID(sih->chip)) {
@@ -2606,7 +2627,8 @@ si_pmu_waitforclk_on_backplane(si_t *sih
 
 #define EXT_ILP_HZ 32768
 
-uint32 BCMATTACHFN(si_pmu_measure_alpclk) (si_t *sih, osl_t *osh) {
+uint32 BCMATTACHFN(si_pmu_measure_alpclk) (si_t *sih, osl_t *osh)
+{
 	chipcregs_t *cc;
 	uint origidx;
 	uint32 alp_khz;
@@ -2653,7 +2675,8 @@ uint32 BCMATTACHFN(si_pmu_measure_alpclk
 	return alp_khz;
 }
 
-static void BCMATTACHFN(si_pmu_set_4330_plldivs) (si_t *sih) {
+static void BCMATTACHFN(si_pmu_set_4330_plldivs) (si_t *sih)
+{
 	uint32 FVCO = si_pmu1_pllfvco0(sih) / 1000;
 	uint32 m1div, m2div, m3div, m4div, m5div, m6div;
 	uint32 pllc1, pllc2;
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -542,7 +542,8 @@ static void pcie_war_serdes(pcicore_info
 
 /* Fix MISC config to allow coming out of L2/L3-Ready state w/o PRST */
 /* Needs to happen when coming out of 'standby'/'hibernate' */
-static void BCMINITFN(pcie_misc_config_fixup) (pcicore_info_t *pi) {
+static void BCMINITFN(pcie_misc_config_fixup) (pcicore_info_t *pi)
+{
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	uint16 val16, *reg16;
 
@@ -637,7 +638,8 @@ void pcie_war_ovr_aspm_update(void *pch,
 }
 
 /* ***** Functions called during driver state changes ***** */
-void BCMATTACHFN(pcicore_attach) (void *pch, char *pvars, int state) {
+void BCMATTACHFN(pcicore_attach) (void *pch, char *pvars, int state)
+{
 	pcicore_info_t *pi = (pcicore_info_t *) pch;
 	si_t *sih = pi->sih;
 
--- a/drivers/staging/brcm80211/util/nvram/nvram_ro.c
+++ b/drivers/staging/brcm80211/util/nvram/nvram_ro.c
@@ -46,7 +46,8 @@ static char *findvar(char *vars, char *l
 
 #if defined(FLASH)
 /* copy flash to ram */
-static void BCMINITFN(get_flash_nvram) (si_t *sih, struct nvram_header *nvh) {
+static void BCMINITFN(get_flash_nvram) (si_t *sih, struct nvram_header *nvh)
+{
 	osl_t *osh;
 	uint nvs, bufsz;
 	vars_t *new;
@@ -74,7 +75,8 @@ static void BCMINITFN(get_flash_nvram) (
 }
 #endif				/* FLASH */
 
-int BCMATTACHFN(nvram_init) (void *si) {
+int BCMATTACHFN(nvram_init) (void *si)
+{
 
 	/* Make sure we read nvram in flash just once before freeing the memory */
 	if (vars != NULL) {
@@ -84,7 +86,8 @@ int BCMATTACHFN(nvram_init) (void *si) {
 	return 0;
 }
 
-int BCMATTACHFN(nvram_append) (void *si, char *varlst, uint varsz) {
+int BCMATTACHFN(nvram_append) (void *si, char *varlst, uint varsz)
+{
 	uint bufsz = VARS_T_OH;
 	vars_t *new;
 
@@ -100,7 +103,8 @@ int BCMATTACHFN(nvram_append) (void *si,
 	return BCME_OK;
 }
 
-void BCMUNINITFN(nvram_exit) (void *si) {
+void BCMUNINITFN(nvram_exit) (void *si)
+{
 	vars_t *this, *next;
 	si_t *sih;
 
@@ -147,19 +151,23 @@ char *nvram_get(const char *name)
 	return v;
 }
 
-int BCMATTACHFN(nvram_set) (const char *name, const char *value) {
+int BCMATTACHFN(nvram_set) (const char *name, const char *value)
+{
 	return 0;
 }
 
-int BCMATTACHFN(nvram_unset) (const char *name) {
+int BCMATTACHFN(nvram_unset) (const char *name)
+{
 	return 0;
 }
 
-int BCMATTACHFN(nvram_reset) (void *si) {
+int BCMATTACHFN(nvram_reset) (void *si)
+{
 	return 0;
 }
 
-int BCMATTACHFN(nvram_commit) (void) {
+int BCMATTACHFN(nvram_commit) (void)
+{
 	return 0;
 }
 
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -290,7 +290,8 @@ BCMATTACHFN(si_buscore_setup) (si_info_t
 	return TRUE;
 }
 
-static void BCMATTACHFN(si_nvram_process) (si_info_t *sii, char *pvars) {
+static void BCMATTACHFN(si_nvram_process) (si_info_t *sii, char *pvars)
+{
 	uint w = 0;
 
 	/* get boardtype and boardrev */
@@ -666,7 +667,8 @@ static si_info_t *BCMATTACHFN(si_doattac
 #endif				/* BCMSDIO */
 
 /* may be called with core in reset */
-void BCMATTACHFN(si_detach) (si_t *sih) {
+void BCMATTACHFN(si_detach) (si_t *sih)
+{
 	si_info_t *sii;
 	uint idx;
 
@@ -1108,7 +1110,8 @@ int si_corebist(si_t *sih)
 	return result;
 }
 
-static uint32 BCMINITFN(factor6) (uint32 x) {
+static uint32 BCMINITFN(factor6) (uint32 x)
+{
 	switch (x) {
 	case CC_F6_2:
 		return 2;
@@ -1128,7 +1131,8 @@ static uint32 BCMINITFN(factor6) (uint32
 }
 
 /* calculate the speed the SI would run at given a set of clockcontrol values */
-uint32 BCMINITFN(si_clock_rate) (uint32 pll_type, uint32 n, uint32 m) {
+uint32 BCMINITFN(si_clock_rate) (uint32 pll_type, uint32 n, uint32 m)
+{
 	uint32 n1, n2, clock, m1, m2, m3, mc;
 
 	n1 = n & CN_N1_MASK;
@@ -1212,7 +1216,8 @@ uint32 BCMINITFN(si_clock_rate) (uint32
 	}
 }
 
-uint32 BCMINITFN(si_clock) (si_t *sih) {
+uint32 BCMINITFN(si_clock) (si_t *sih)
+{
 	si_info_t *sii;
 	chipcregs_t *cc;
 	uint32 n, m;
@@ -1254,14 +1259,16 @@ uint32 BCMINITFN(si_clock) (si_t *sih) {
 	return rate;
 }
 
-uint32 BCMINITFN(si_alp_clock) (si_t *sih) {
+uint32 BCMINITFN(si_alp_clock) (si_t *sih)
+{
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_alp_clock(sih, si_osh(sih));
 
 	return ALP_CLOCK;
 }
 
-uint32 BCMINITFN(si_ilp_clock) (si_t *sih) {
+uint32 BCMINITFN(si_ilp_clock) (si_t *sih)
+{
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_ilp_clock(sih, si_osh(sih));
 
@@ -1318,7 +1325,8 @@ void si_watchdog_ms(si_t *sih, uint32 ms
 	si_watchdog(sih, wd_msticks * ms);
 }
 
-uint16 BCMATTACHFN(si_d11_devid) (si_t *sih) {
+uint16 BCMATTACHFN(si_d11_devid) (si_t *sih)
+{
 	si_info_t *sii = SI_INFO(sih);
 	uint16 device;
 
@@ -1398,7 +1406,8 @@ static uint si_slowclk_freq(si_info_t *s
 	return (0);
 }
 
-static void BCMINITFN(si_clkctl_setdelay) (si_info_t *sii, void *chipcregs) {
+static void BCMINITFN(si_clkctl_setdelay) (si_info_t *sii, void *chipcregs)
+{
 	chipcregs_t *cc = (chipcregs_t *) chipcregs;
 	uint slowmaxfreq, pll_delay, slowclk;
 	uint pll_on_delay, fref_sel_delay;
@@ -1425,7 +1434,8 @@ static void BCMINITFN(si_clkctl_setdelay
 }
 
 /* initialize power control delay registers */
-void BCMINITFN(si_clkctl_init) (si_t *sih) {
+void BCMINITFN(si_clkctl_init) (si_t *sih)
+{
 	si_info_t *sii;
 	uint origidx = 0;
 	chipcregs_t *cc;
@@ -1457,7 +1467,8 @@ void BCMINITFN(si_clkctl_init) (si_t *si
 }
 
 /* return the value suitable for writing to the dot11 core FAST_PWRUP_DELAY register */
-uint16 BCMINITFN(si_clkctl_fast_pwrup_delay) (si_t *sih) {
+uint16 BCMINITFN(si_clkctl_fast_pwrup_delay) (si_t *sih)
+{
 	si_info_t *sii;
 	uint origidx = 0;
 	chipcregs_t *cc;
@@ -1692,7 +1703,8 @@ static bool _si_clkctl_cc(si_info_t *sii
 }
 
 /* Build device path. Support SI, PCI, and JTAG for now. */
-int BCMATTACHFN(si_devpath) (si_t *sih, char *path, int size) {
+int BCMATTACHFN(si_devpath) (si_t *sih, char *path, int size)
+{
 	int slen;
 
 	ASSERT(path != NULL);
@@ -1734,7 +1746,8 @@ int BCMATTACHFN(si_devpath) (si_t *sih,
 }
 
 /* Get a variable, but only if it has a devpath prefix */
-char *BCMATTACHFN(si_getdevpathvar) (si_t *sih, const char *name) {
+char *BCMATTACHFN(si_getdevpathvar) (si_t *sih, const char *name)
+{
 	char varname[SI_DEVPATH_BUFSZ + 32];
 
 	si_devpathvar(sih, varname, sizeof(varname), name);
@@ -1743,7 +1756,8 @@ char *BCMATTACHFN(si_getdevpathvar) (si_
 }
 
 /* Get a variable, but only if it has a devpath prefix */
-int BCMATTACHFN(si_getdevpathintvar) (si_t *sih, const char *name) {
+int BCMATTACHFN(si_getdevpathintvar) (si_t *sih, const char *name)
+{
 #if defined(BCMBUSTYPE) && (BCMBUSTYPE == SI_BUS)
 	return (getintvar(NULL, name));
 #else
@@ -1903,7 +1917,8 @@ void si_sdio_init(si_t *sih)
 }
 #endif				/* BCMSDIO */
 
-bool BCMATTACHFN(si_pci_war16165) (si_t *sih) {
+bool BCMATTACHFN(si_pci_war16165) (si_t *sih)
+{
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -1938,7 +1953,8 @@ void si_chippkg_set(si_t *sih, uint val)
 	sii->pub.chippkg = val;
 }
 
-void BCMINITFN(si_pci_up) (si_t *sih) {
+void BCMINITFN(si_pci_up) (si_t *sih)
+{
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -1956,7 +1972,8 @@ void BCMINITFN(si_pci_up) (si_t *sih) {
 }
 
 /* Unconfigure and/or apply various WARs when system is going to sleep mode */
-void BCMUNINITFN(si_pci_sleep) (si_t *sih) {
+void BCMUNINITFN(si_pci_sleep) (si_t *sih)
+{
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -1965,7 +1982,8 @@ void BCMUNINITFN(si_pci_sleep) (si_t *si
 }
 
 /* Unconfigure and/or apply various WARs when going down */
-void BCMINITFN(si_pci_down) (si_t *sih) {
+void BCMINITFN(si_pci_down) (si_t *sih)
+{
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -1985,7 +2003,8 @@ void BCMINITFN(si_pci_down) (si_t *sih)
  * Configure the pci core for pci client (NIC) action
  * coremask is the bitvec of cores by index to be enabled.
  */
-void BCMATTACHFN(si_pci_setup) (si_t *sih, uint coremask) {
+void BCMATTACHFN(si_pci_setup) (si_t *sih, uint coremask)
+{
 	si_info_t *sii;
 	sbpciregs_t *pciregs = NULL;
 	uint32 siflag = 0, w;
@@ -2404,7 +2423,8 @@ void *BCMATTACHFN(si_gpio_handler_regist
 	return (void *)(gi);
 }
 
-void BCMATTACHFN(si_gpio_handler_unregister) (si_t *sih, void *gpioh) {
+void BCMATTACHFN(si_gpio_handler_unregister) (si_t *sih, void *gpioh)
+{
 	si_info_t *sii;
 	gpioh_item_t *p, *n;
 

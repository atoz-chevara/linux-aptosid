commit f024c48a77c3c20d99de8f3424e8d3a061896885
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 21 10:50:21 2010 -0700

    Staging: brcm80211: remove uintptr typedef usage
    
    Use a unsigned long, that is the proper type for this type of thing on
    Linux.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
@@ -442,7 +442,7 @@ bcmsdh_pci_probe(struct pci_dev *pdev, c
 		SDLX_MSG(("%s: Cannot enable PCI device\n", __func__));
 		goto err;
 	}
-	sdh = bcmsdh_attach(osh, (void *)(uintptr) pci_resource_start(pdev, 0),
+	sdh = bcmsdh_attach(osh, (void *)(unsigned long)pci_resource_start(pdev, 0),
 			(void **)&regs, pdev->irq);
 	if (!sdh) {
 		SDLX_MSG(("%s: bcmsdh_attach failed\n", __func__));
--- a/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_cdc.c
@@ -413,7 +413,7 @@ int dhd_prot_attach(dhd_pub_t *dhd)
 	}
 
 	/* ensure that the msg buf directly follows the cdc msg struct */
-	if ((uintptr) (&cdc->msg + 1) != (uintptr) cdc->buf) {
+	if ((unsigned long)(&cdc->msg + 1) != (unsigned long)cdc->buf) {
 		DHD_ERROR(("dhd_prot_t is not correctly defined\n"));
 		goto fail;
 	}
--- a/drivers/staging/brcm80211/brcmfmac/dhd_common.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_common.c
@@ -1476,7 +1476,7 @@ int dhd_iscan_print_cache(iscan_buf_t *i
 				   bi->BSSID.octet[2], bi->BSSID.octet[3],
 				   bi->BSSID.octet[4], bi->BSSID.octet[5]));
 
-			bi = (wl_bss_info_t *) ((uintptr) bi +
+			bi = (wl_bss_info_t *)((unsigned long)bi +
 						dtoh32(bi->length));
 		}
 		iscan_cur = iscan_cur->next;
@@ -1541,7 +1541,7 @@ int dhd_iscan_delete_bss(void *dhdp, voi
 					bi->BSSID.octet[5]));
 
 					bi_new = bi;
-					bi = (wl_bss_info_t *) ((uintptr) bi +
+					bi = (wl_bss_info_t *)((unsigned long)bi +
 								dtoh32
 								(bi->length));
 /*
@@ -1567,17 +1567,14 @@ int dhd_iscan_delete_bss(void *dhdp, voi
 							bi->BSSID.octet[5]));
 
 							bi_next =
-							    (wl_bss_info_t
-							     *) ((uintptr) bi +
+							    (wl_bss_info_t *)((unsigned long)bi +
 								 dtoh32
 								 (bi->length));
 							bcopy(bi, bi_new,
 							      dtoh32
 							      (bi->length));
 							bi_new =
-							    (wl_bss_info_t
-							     *) ((uintptr)
-								 bi_new +
+							    (wl_bss_info_t *)((unsigned long)bi_new +
 								 dtoh32
 								 (bi_new->
 								  length));
@@ -1594,7 +1591,7 @@ int dhd_iscan_delete_bss(void *dhdp, voi
 					}
 					break;
 				}
-				bi = (wl_bss_info_t *) ((uintptr) bi +
+				bi = (wl_bss_info_t *)((unsigned long)bi +
 							dtoh32(bi->length));
 			}
 		}
@@ -1649,7 +1646,7 @@ int dhd_iscan_remove_duplicates(void *dh
 
 		dhd_iscan_delete_bss(dhdp, bi->BSSID.octet, iscan_cur);
 
-		bi = (wl_bss_info_t *) ((uintptr) bi + dtoh32(bi->length));
+		bi = (wl_bss_info_t *)((unsigned long)bi + dtoh32(bi->length));
 	}
 
 done:
--- a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
@@ -358,7 +358,7 @@ extern void bcmsdh_enable_hw_oob_intr(vo
 #define PKTALIGN(osh, p, len, align)					\
 	do {								\
 		uint datalign;						\
-		datalign = (uintptr)PKTDATA((p));		\
+		datalign = (unsigned long)PKTDATA((p));			\
 		datalign = roundup(datalign, (align)) - datalign;	\
 		ASSERT(datalign < (align));				\
 		ASSERT(PKTLEN((p)) >= ((len) + datalign));	\
@@ -924,7 +924,7 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 	frame = (u8 *) PKTDATA(pkt);
 
 	/* Add alignment padding, allocate new packet if needed */
-	pad = ((uintptr) frame % DHD_SDALIGN);
+	pad = ((unsigned long)frame % DHD_SDALIGN);
 	if (pad) {
 		if (PKTHEADROOM(pkt) < pad) {
 			DHD_INFO(("%s: insufficient headroom %d for %d pad\n",
@@ -947,7 +947,7 @@ static int dhdsdio_txpkt(dhd_bus_t *bus,
 			free_pkt = true;
 			pkt = new;
 			frame = (u8 *) PKTDATA(pkt);
-			ASSERT(((uintptr) frame % DHD_SDALIGN) == 0);
+			ASSERT(((unsigned long)frame % DHD_SDALIGN) == 0);
 			pad = 0;
 		} else {
 			PKTPUSH(pkt, pad);
@@ -1087,7 +1087,7 @@ int dhd_bus_txdata(struct dhd_bus *bus,
 
 	/* Add space for the header */
 	PKTPUSH(pkt, SDPCM_HDRLEN);
-	ASSERT(IS_ALIGNED((uintptr) PKTDATA(pkt), 2));
+	ASSERT(IS_ALIGNED((unsigned long)PKTDATA(pkt), 2));
 
 	prec = PRIO2PREC((PKTPRIO(pkt) & PRIOMASK));
 
@@ -1241,7 +1241,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 
 	/* Add alignment padding (optional for ctl frames) */
 	if (dhd_alignctl) {
-		doff = ((uintptr) frame % DHD_SDALIGN);
+		doff = ((unsigned long)frame % DHD_SDALIGN);
 		if (doff) {
 			frame -= doff;
 			len += doff;
@@ -1265,7 +1265,7 @@ int dhd_bus_txctl(struct dhd_bus *bus, u
 	if (forcealign && (len & (ALIGNMENT - 1)))
 		len = roundup(len, ALIGNMENT);
 
-	ASSERT(IS_ALIGNED((uintptr) frame, 2));
+	ASSERT(IS_ALIGNED((unsigned long)frame, 2));
 
 	/* Need to lock here to protect txseq and SDIO tx calls */
 	dhd_os_sdlock(bus->dhd);
@@ -2336,7 +2336,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 
 			sd_ptr = (sdreg_t *) params;
 
-			addr = (uintptr) bus->regs + sd_ptr->offset;
+			addr = (unsigned long)bus->regs + sd_ptr->offset;
 			size = sd_ptr->func;
 			int_val = (s32) bcmsdh_reg_read(bus->sdh, addr, size);
 			if (bcmsdh_regfail(bus->sdh))
@@ -2352,7 +2352,7 @@ dhdsdio_doiovar(dhd_bus_t *bus, const bc
 
 			sd_ptr = (sdreg_t *) params;
 
-			addr = (uintptr) bus->regs + sd_ptr->offset;
+			addr = (unsigned long)bus->regs + sd_ptr->offset;
 			size = sd_ptr->func;
 			bcmsdh_reg_write(bus->sdh, addr, size, sd_ptr->value);
 			if (bcmsdh_regfail(bus->sdh))
@@ -3086,7 +3086,7 @@ dhdsdio_read_control(dhd_bus_t *bus, u8
 	bus->rxctl = bus->rxbuf;
 	if (dhd_alignctl) {
 		bus->rxctl += firstread;
-		pad = ((uintptr) bus->rxctl % DHD_SDALIGN);
+		pad = ((unsigned long)bus->rxctl % DHD_SDALIGN);
 		if (pad)
 			bus->rxctl += (DHD_SDALIGN - pad);
 		bus->rxctl -= firstread;
@@ -3681,7 +3681,7 @@ static uint dhdsdio_readframes(dhd_bus_t
 					bus->rxctl = bus->rxbuf;
 					if (dhd_alignctl) {
 						bus->rxctl += firstread;
-						pad = ((uintptr) bus->rxctl %
+						pad = ((unsigned long)bus->rxctl %
 						      DHD_SDALIGN);
 						if (pad)
 							bus->rxctl +=
@@ -5091,7 +5091,7 @@ static void *dhdsdio_probe(u16 venid, u1
 	DHD_INFO(("%s: venid 0x%04x devid 0x%04x\n", __func__, venid, devid));
 
 	/* We make assumptions about address window mappings */
-	ASSERT((uintptr) regsva == SI_ENUM_BASE);
+	ASSERT((unsigned long)regsva == SI_ENUM_BASE);
 
 	/* BCMSDH passes venid and devid based on CIS parsing -- but
 	 * low-power start
@@ -5363,7 +5363,7 @@ dhdsdio_probe_attach(struct dhd_bus *bus
 	pktq_init(&bus->txq, (PRIOMASK + 1), QLEN);
 
 	/* Locate an appropriately-aligned portion of hdrbuf */
-	bus->rxhdr = (u8 *) roundup((uintptr)&bus->hdrbuf[0], DHD_SDALIGN);
+	bus->rxhdr = (u8 *) roundup((unsigned long)&bus->hdrbuf[0], DHD_SDALIGN);
 
 	/* Set the poll and/or interrupt flags */
 	bus->intr = (bool) dhd_intr;
@@ -5405,10 +5405,10 @@ static bool dhdsdio_probe_malloc(dhd_bus
 	}
 
 	/* Align the buffer */
-	if ((uintptr) bus->databuf % DHD_SDALIGN)
+	if ((unsigned long)bus->databuf % DHD_SDALIGN)
 		bus->dataptr =
 		    bus->databuf + (DHD_SDALIGN -
-				    ((uintptr) bus->databuf % DHD_SDALIGN));
+				    ((unsigned long)bus->databuf % DHD_SDALIGN));
 	else
 		bus->dataptr = bus->databuf;
 
@@ -5739,9 +5739,9 @@ static int dhdsdio_download_code_file(st
 			   __func__, MEMBLOCK));
 		goto err;
 	}
-	if ((u32) (uintptr) memblock % DHD_SDALIGN)
+	if ((u32)(unsigned long)memblock % DHD_SDALIGN)
 		memptr +=
-		    (DHD_SDALIGN - ((u32) (uintptr) memblock % DHD_SDALIGN));
+		    (DHD_SDALIGN - ((u32)(unsigned long)memblock % DHD_SDALIGN));
 
 	/* Download image */
 	while ((len =
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
@@ -364,7 +364,7 @@ static inline struct wl_bss_info *next_b
 					   struct wl_bss_info *bss)
 {
 	return bss = bss ?
-		(struct wl_bss_info *)((uintptr) bss +
+		(struct wl_bss_info *)((unsigned long)bss +
 				       dtoh32(bss->length)) : list->bss_info;
 }
 
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -903,11 +903,11 @@ wl_iw_get_aplist(struct net_device *dev,
 
 	for (i = 0, dwrq->length = 0;
 	     i < list->count && dwrq->length < IW_MAX_AP; i++) {
-		bi = bi ? (wl_bss_info_t *) ((uintptr) bi +
+		bi = bi ? (wl_bss_info_t *) ((unsigned long)bi +
 					     dtoh32(bi->length)) : list->
 		    bss_info;
-		ASSERT(((uintptr) bi + dtoh32(bi->length)) <=
-		       ((uintptr) list + buflen));
+		ASSERT(((unsigned long)bi + dtoh32(bi->length)) <=
+		       ((unsigned long)list + buflen));
 
 		if (!(dtoh16(bi->capability) & DOT11_CAP_ESS))
 			continue;
@@ -976,11 +976,11 @@ wl_iw_iscan_get_aplist(struct net_device
 		bi = NULL;
 		for (i = 0, dwrq->length = 0;
 		     i < list->count && dwrq->length < IW_MAX_AP; i++) {
-			bi = bi ? (wl_bss_info_t *) ((uintptr) bi +
+			bi = bi ? (wl_bss_info_t *) ((unsigned long)bi +
 						     dtoh32(bi->length)) :
 			    list->bss_info;
-			ASSERT(((uintptr) bi + dtoh32(bi->length)) <=
-			       ((uintptr) list + WLC_IW_ISCAN_MAXLEN));
+			ASSERT(((unsigned long)bi + dtoh32(bi->length)) <=
+			       ((unsigned long)list + WLC_IW_ISCAN_MAXLEN));
 
 			if (!(dtoh16(bi->capability) & DOT11_CAP_ESS))
 				continue;
@@ -1508,7 +1508,7 @@ wl_iw_get_scan_prep(wl_scan_results_t *l
 			return ret;
 		}
 
-		bi = bi ? (wl_bss_info_t *) ((uintptr) bi +
+		bi = bi ? (wl_bss_info_t *)((unsigned long)bi +
 					     dtoh32(bi->length)) : list->
 		    bss_info;
 
@@ -1568,7 +1568,7 @@ wl_iw_get_scan_prep(wl_scan_results_t *l
 
 		if (bi->rateset.count) {
 			if (((event - extra) +
-				IW_EV_LCP_LEN) <= (uintptr) end) {
+				IW_EV_LCP_LEN) <= (unsigned long)end) {
 				value = event + IW_EV_LCP_LEN;
 				iwe.cmd = SIOCGIWRATE;
 				iwe.u.bitrate.fixed = iwe.u.bitrate.disabled =
@@ -1774,11 +1774,11 @@ wl_iw_iscan_get_scan(struct net_device *
 		bi = NULL;
 		for (ii = 0; ii < list->count && apcnt < IW_MAX_AP;
 		     apcnt++, ii++) {
-			bi = bi ? (wl_bss_info_t *) ((uintptr) bi +
+			bi = bi ? (wl_bss_info_t *)((unsigned long)bi +
 						     dtoh32(bi->length)) :
 			    list->bss_info;
-			ASSERT(((uintptr) bi + dtoh32(bi->length)) <=
-			       ((uintptr) list + WLC_IW_ISCAN_MAXLEN));
+			ASSERT(((unsigned long)bi + dtoh32(bi->length)) <=
+			       ((unsigned long)list + WLC_IW_ISCAN_MAXLEN));
 
 			if (event + ETHER_ADDR_LEN + bi->SSID_len +
 			    IW_EV_UINT_LEN + IW_EV_FREQ_LEN + IW_EV_QUAL_LEN >=
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -436,7 +436,7 @@
 #ifdef __i386__
 			   1 ||
 #endif
-			   (((uintptr) src1 | (uintptr) src2 | (uintptr) dst) &
+			   (((unsigned long) src1 | (unsigned long) src2 | (unsigned long) dst) &
 			    3) == 0) {
 			/* ARM CM3 rel time: 1229 (727 if alignment check could be omitted) */
 			/* x86 supports unaligned.  This version runs 6x-9x faster on x86. */
--- a/drivers/staging/brcm80211/include/hnddma.h
+++ b/drivers/staging/brcm80211/include/hnddma.h
@@ -54,7 +54,7 @@ typedef void *(*di_rx_t) (hnddma_t *dmah
 typedef bool(*di_rxfill_t) (hnddma_t *dmah);
 typedef void (*di_txreclaim_t) (hnddma_t *dmah, txd_range_t range);
 typedef void (*di_rxreclaim_t) (hnddma_t *dmah);
-typedef uintptr(*di_getvar_t) (hnddma_t *dmah, const char *name);
+typedef unsigned long (*di_getvar_t) (hnddma_t *dmah, const char *name);
 typedef void *(*di_getnexttxp_t) (hnddma_t *dmah, txd_range_t range);
 typedef void *(*di_getnextrxp_t) (hnddma_t *dmah, bool forceall);
 typedef void *(*di_peeknexttxp_t) (hnddma_t *dmah);
--- a/drivers/staging/brcm80211/include/linux_osl.h
+++ b/drivers/staging/brcm80211/include/linux_osl.h
@@ -131,8 +131,8 @@ extern void osl_dma_unmap(osl_t *osh, ui
 #ifdef BRCM_FULLMAC
 #include <bcmsdh.h>
 #endif
-#define OSL_WRITE_REG(osh, r, v) (bcmsdh_reg_write(NULL, (uintptr)(r), sizeof(*(r)), (v)))
-#define OSL_READ_REG(osh, r) (bcmsdh_reg_read(NULL, (uintptr)(r), sizeof(*(r))))
+#define OSL_WRITE_REG(osh, r, v) (bcmsdh_reg_write(NULL, (unsigned long)(r), sizeof(*(r)), (v)))
+#define OSL_READ_REG(osh, r) (bcmsdh_reg_read(NULL, (unsigned long)(r), sizeof(*(r))))
 #endif
 
 #if defined(BCMSDIO)
--- a/drivers/staging/brcm80211/include/siutils.h
+++ b/drivers/staging/brcm80211/include/siutils.h
@@ -269,7 +269,7 @@ typedef struct si_info {
 
 #define	GOODCOREADDR(x, b) (((x) >= (b)) && ((x) < ((b) + SI_MAXCORES * SI_CORE_SIZE)) && \
 		IS_ALIGNED((x), SI_CORE_SIZE))
-#define	GOODREGS(regs)	((regs) != NULL && IS_ALIGNED((uintptr)(regs), SI_CORE_SIZE))
+#define	GOODREGS(regs)	((regs) != NULL && IS_ALIGNED((unsigned long)(regs), SI_CORE_SIZE))
 #define BADCOREADDR	0
 #define	GOODIDX(idx)	(((uint)idx) < SI_MAXCORES)
 #define	NOREV		-1	/* Invalid rev */
--- a/drivers/staging/brcm80211/include/typedefs.h
+++ b/drivers/staging/brcm80211/include/typedefs.h
@@ -19,17 +19,6 @@
 
 #include <linux/types.h>
 
-#if defined(__x86_64__)
-#define TYPEDEF_UINTPTR
-typedef unsigned long long int uintptr;
-#endif
-
-#ifndef TYPEDEF_UINTPTR
-typedef unsigned int uintptr;
-#endif
-
-#undef TYPEDEF_UINTPTR
-
 #ifndef OFF
 #define	OFF	0
 #endif
--- a/drivers/staging/brcm80211/sys/wlc_alloc.c
+++ b/drivers/staging/brcm80211/sys/wlc_alloc.c
@@ -206,7 +206,7 @@ wlc_info_t *wlc_attach_malloc(osl_t *osh
 
 		for (i = 1; i < MAXBANDS; i++) {
 			wlc->hw->bandstate[i] = (wlc_hwband_t *)
-			    ((uintptr) wlc->hw->bandstate[0] +
+			    ((unsigned long)wlc->hw->bandstate[0] +
 			     (sizeof(wlc_hwband_t) * i));
 		}
 	}
@@ -249,7 +249,7 @@ wlc_info_t *wlc_attach_malloc(osl_t *osh
 		int i;
 		for (i = 1; i < WLC_DEFAULT_KEYS; i++) {
 			wlc->wsec_def_keys[i] = (wsec_key_t *)
-			    ((uintptr) wlc->wsec_def_keys[0] +
+			    ((unsigned long)wlc->wsec_def_keys[0] +
 			     (sizeof(wsec_key_t) * i));
 		}
 	}
@@ -277,7 +277,7 @@ wlc_info_t *wlc_attach_malloc(osl_t *osh
 
 		for (i = 1; i < MAXBANDS; i++) {
 			wlc->bandstate[i] =
-			    (wlcband_t *) ((uintptr) wlc->bandstate[0] +
+			    (wlcband_t *) ((unsigned long)wlc->bandstate[0] +
 					   (sizeof(wlcband_t) * i));
 		}
 	}
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -3516,12 +3516,12 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		if (r->size == sizeof(u32))
 			r->val =
 			    R_REG(osh,
-				  (u32 *) ((unsigned char *) (uintptr) regs +
+				  (u32 *)((unsigned char *)(unsigned long)regs +
 					      r->byteoff));
 		else if (r->size == sizeof(u16))
 			r->val =
 			    R_REG(osh,
-				  (u16 *) ((unsigned char *) (uintptr) regs +
+				  (u16 *)((unsigned char *)(unsigned long)regs +
 					      r->byteoff));
 		else
 			bcmerror = BCME_BADADDR;
@@ -3551,11 +3551,11 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		}
 		if (r->size == sizeof(u32))
 			W_REG(osh,
-			      (u32 *) ((unsigned char *) (uintptr) regs +
+			      (u32 *)((unsigned char *)(unsigned long) regs +
 					  r->byteoff), r->val);
 		else if (r->size == sizeof(u16))
 			W_REG(osh,
-			      (u16 *) ((unsigned char *) (uintptr) regs +
+			      (u16 *)((unsigned char *)(unsigned long) regs +
 					  r->byteoff), r->val);
 		else
 			bcmerror = BCME_BADADDR;
@@ -4607,7 +4607,7 @@ wlc_iovar_op(wlc_info_t *wlc, const char
 	ASSERT(!set || (!params && !p_len));
 
 	if (!set && (len == sizeof(int)) &&
-	    !(IS_ALIGNED((uintptr) (arg), (uint) sizeof(int)))) {
+	    !(IS_ALIGNED((unsigned long)(arg), (uint) sizeof(int)))) {
 		WL_ERROR(("wl%d: %s unaligned get ptr for %s\n",
 			  wlc->pub->unit, __func__, name));
 		ASSERT(0);
@@ -4755,7 +4755,7 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 		bcopy(params, &int_val, sizeof(int_val));
 
 	if (p_len >= (int)sizeof(int_val) * 2)
-		bcopy((void *)((uintptr) params + sizeof(int_val)), &int_val2,
+		bcopy((void *)((unsigned long)params + sizeof(int_val)), &int_val2,
 		      sizeof(int_val));
 
 	/* convenience int ptr for 4-byte gets (requires int aligned arg) */
@@ -6318,7 +6318,7 @@ wlc_d11hdrs_mac80211(wlc_info_t *wlc, st
 		}
 
 		/* RTS PLCP header */
-		ASSERT(IS_ALIGNED((uintptr) txh->RTSPhyHeader, sizeof(u16)));
+		ASSERT(IS_ALIGNED((unsigned long)txh->RTSPhyHeader, sizeof(u16)));
 		rts_plcp = txh->RTSPhyHeader;
 		if (use_cts)
 			rts_phylen = DOT11_CTS_LEN + DOT11_FCS_LEN;
@@ -7164,7 +7164,7 @@ wlc_recvctl(wlc_info_t *wlc, osl_t *osh,
 	ASSERT(!PKTNEXT(p));
 	ASSERT(!PKTLINK(p));
 
-	ASSERT(IS_ALIGNED((uintptr) skb->data, 2));
+	ASSERT(IS_ALIGNED((unsigned long)skb->data, 2));
 
 	memcpy(IEEE80211_SKB_RXCB(p), &rx_status, sizeof(rx_status));
 	ieee80211_rx_irqsafe(wlc->pub->ieee_hw, p);
--- a/drivers/staging/brcm80211/sys/wlc_rpc.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpc.h
@@ -448,7 +448,7 @@ wlc_rpc_id_get(struct rpc_info *rpc, rpc
 	bcm_xdr_buf_init(&b, bcm_rpc_buf_data(bcm_rpc_tp_get(rpc), buf),
 			 sizeof(u32));
 
-	bcm_xdr_unpack_u32(&b, (u32 *) ((uintptr) & rpc_id));
+	bcm_xdr_unpack_u32(&b, (u32 *)((unsigned long) & rpc_id));
 	return rpc_id;
 }
 #endif
--- a/drivers/staging/brcm80211/util/aiutils.c
+++ b/drivers/staging/brcm80211/util/aiutils.c
@@ -123,7 +123,7 @@ void ai_scan(si_t *sih, void *regs, uint
 
 	case PCI_BUS:
 		/* Set wrappers address */
-		sii->curwrap = (void *)((uintptr) regs + SI_CORE_SIZE);
+		sii->curwrap = (void *)((unsigned long)regs + SI_CORE_SIZE);
 
 		/* Now point the window at the erom */
 		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN, 4, erombase);
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -432,7 +432,7 @@ uint pktsetprio(void *pkt, bool update_v
 	int rc = 0;
 
 	pktdata = (u8 *) PKTDATA(pkt);
-	ASSERT(IS_ALIGNED((uintptr) pktdata, sizeof(u16)));
+	ASSERT(IS_ALIGNED((unsigned long)pktdata, sizeof(u16)));
 
 	eh = (struct ether_header *)pktdata;
 
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -218,7 +218,7 @@ static uint _dma_txcommitted(dma_info_t
 
 static void *_dma_peeknexttxp(dma_info_t *di);
 static void *_dma_peeknextrxp(dma_info_t *di);
-static uintptr _dma_getvar(dma_info_t *di, const char *name);
+static unsigned long _dma_getvar(dma_info_t *di, const char *name);
 static void _dma_counterreset(dma_info_t *di);
 static void _dma_fifoloopbackenable(dma_info_t *di);
 static uint _dma_ctrlflags(dma_info_t *di, uint mask, uint flags);
@@ -1363,10 +1363,10 @@ static uint _dma_ctrlflags(dma_info_t *d
 }
 
 /* get the address of the var in order to change later */
-static uintptr _dma_getvar(dma_info_t *di, const char *name)
+static unsigned long _dma_getvar(dma_info_t *di, const char *name)
 {
 	if (!strcmp(name, "&txavail"))
-		return (uintptr) &(di->hnddma.txavail);
+		return (unsigned long)&(di->hnddma.txavail);
 	else {
 		ASSERT(0);
 	}
@@ -1409,7 +1409,7 @@ static void *dma_ringalloc(osl_t *osh, u
 	if (NULL == va)
 		return NULL;
 
-	desc_strtaddr = (u32) roundup((uintptr) va, alignbytes);
+	desc_strtaddr = (u32) roundup((unsigned long)va, alignbytes);
 	if (((desc_strtaddr + size - 1) & boundary) != (desc_strtaddr
 							& boundary)) {
 		*alignbits = dma_align_sizetobits(size);
@@ -1534,7 +1534,7 @@ static bool dma32_alloc(dma_info_t *di,
 
 		PHYSADDRHISET(di->txdpa, 0);
 		ASSERT(PHYSADDRHI(di->txdpaorig) == 0);
-		di->txd32 = (dma32dd_t *) roundup((uintptr) va, align);
+		di->txd32 = (dma32dd_t *) roundup((unsigned long)va, align);
 		di->txdalign =
 		    (uint) ((s8 *)di->txd32 - (s8 *) va);
 
@@ -1544,7 +1544,7 @@ static bool dma32_alloc(dma_info_t *di,
 		ASSERT(PHYSADDRLO(di->txdpa) >= PHYSADDRLO(di->txdpaorig));
 
 		di->txdalloc = alloced;
-		ASSERT(IS_ALIGNED((uintptr) di->txd32, align));
+		ASSERT(IS_ALIGNED((unsigned long)di->txd32, align));
 	} else {
 		va = dma_ringalloc(di->osh, D32RINGALIGN, size, &align_bits,
 			&alloced, &di->rxdpaorig, &di->rx_dmah);
@@ -1555,7 +1555,7 @@ static bool dma32_alloc(dma_info_t *di,
 
 		PHYSADDRHISET(di->rxdpa, 0);
 		ASSERT(PHYSADDRHI(di->rxdpaorig) == 0);
-		di->rxd32 = (dma32dd_t *) roundup((uintptr) va, align);
+		di->rxd32 = (dma32dd_t *) roundup((unsigned long)va, align);
 		di->rxdalign =
 		    (uint) ((s8 *)di->rxd32 - (s8 *) va);
 
@@ -1564,7 +1564,7 @@ static bool dma32_alloc(dma_info_t *di,
 		/* Make sure that alignment didn't overflow */
 		ASSERT(PHYSADDRLO(di->rxdpa) >= PHYSADDRLO(di->rxdpaorig));
 		di->rxdalloc = alloced;
-		ASSERT(IS_ALIGNED((uintptr) di->rxd32, align));
+		ASSERT(IS_ALIGNED((unsigned long)di->rxd32, align));
 	}
 
 	return true;
@@ -2100,7 +2100,7 @@ static bool dma64_alloc(dma_info_t *di,
 			return false;
 		}
 		align = (1 << align_bits);
-		di->txd64 = (dma64dd_t *) roundup((uintptr) va, align);
+		di->txd64 = (dma64dd_t *) roundup((unsigned long)va, align);
 		di->txdalign = (uint) ((s8 *)di->txd64 - (s8 *) va);
 		PHYSADDRLOSET(di->txdpa,
 			      PHYSADDRLO(di->txdpaorig) + di->txdalign);
@@ -2109,7 +2109,7 @@ static bool dma64_alloc(dma_info_t *di,
 
 		PHYSADDRHISET(di->txdpa, PHYSADDRHI(di->txdpaorig));
 		di->txdalloc = alloced;
-		ASSERT(IS_ALIGNED((uintptr) di->txd64, align));
+		ASSERT(IS_ALIGNED((unsigned long)di->txd64, align));
 	} else {
 		va = dma_ringalloc(di->osh, D64RINGALIGN, size, &align_bits,
 			&alloced, &di->rxdpaorig, &di->rx_dmah);
@@ -2118,7 +2118,7 @@ static bool dma64_alloc(dma_info_t *di,
 			return false;
 		}
 		align = (1 << align_bits);
-		di->rxd64 = (dma64dd_t *) roundup((uintptr) va, align);
+		di->rxd64 = (dma64dd_t *) roundup((unsigned long)va, align);
 		di->rxdalign = (uint) ((s8 *)di->rxd64 - (s8 *) va);
 		PHYSADDRLOSET(di->rxdpa,
 			      PHYSADDRLO(di->rxdpaorig) + di->rxdalign);
@@ -2127,7 +2127,7 @@ static bool dma64_alloc(dma_info_t *di,
 
 		PHYSADDRHISET(di->rxdpa, PHYSADDRHI(di->rxdpaorig));
 		di->rxdalloc = alloced;
-		ASSERT(IS_ALIGNED((uintptr) di->rxd64, align));
+		ASSERT(IS_ALIGNED((unsigned long)di->rxd64, align));
 	}
 
 	return true;
--- a/drivers/staging/brcm80211/util/sbutils.c
+++ b/drivers/staging/brcm80211/util/sbutils.c
@@ -90,7 +90,7 @@ static u32 _sb_coresba(si_info_t *sii)
 	switch (BUSTYPE(sii->pub.bustype)) {
 	case SPI_BUS:
 	case SDIO_BUS:
-		sbaddr = (u32) (uintptr) sii->curmap;
+		sbaddr = (u32)(unsigned long)sii->curmap;
 		break;
 	default:
 		ASSERT(0);

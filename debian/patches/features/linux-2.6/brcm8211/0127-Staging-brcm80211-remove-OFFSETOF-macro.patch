commit ce0f1b8cd1526e800b8f3c1e978ac7c23ed91e2f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Oct 8 11:44:45 2010 -0700

    Staging: brcm80211: remove OFFSETOF macro
    
    Use the real 'offsetof' definition instead.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/bcmutils.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmutils.c
@@ -305,7 +305,7 @@ void pktq_init(struct pktq *pq, int num_
 
 	/* pq is variable size; only zero out what's requested */
 	bzero(pq,
-	      OFFSETOF(struct pktq, q) + (sizeof(struct pktq_prec) * num_prec));
+	      offsetof(struct pktq, q) + (sizeof(struct pktq_prec) * num_prec));
 
 	pq->num_prec = (u16) num_prec;
 
--- a/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_sdio.c
@@ -1995,7 +1995,7 @@ static int dhdsdio_readconsole(dhd_bus_t
 		return 0;
 
 	/* Read console log struct */
-	addr = bus->console_addr + OFFSETOF(hndrte_cons_t, log);
+	addr = bus->console_addr + offsetof(hndrte_cons_t, log);
 	rv = dhdsdio_membytes(bus, FALSE, addr, (u8 *)&c->log,
 				sizeof(c->log));
 	if (rv < 0)
@@ -4980,20 +4980,20 @@ extern int dhd_bus_console_in(dhd_pub_t
 	dhdsdio_clkctl(bus, CLK_AVAIL, FALSE);
 
 	/* Zero cbuf_index */
-	addr = bus->console_addr + OFFSETOF(hndrte_cons_t, cbuf_idx);
+	addr = bus->console_addr + offsetof(hndrte_cons_t, cbuf_idx);
 	val = htol32(0);
 	rv = dhdsdio_membytes(bus, TRUE, addr, (u8 *)&val, sizeof(val));
 	if (rv < 0)
 		goto done;
 
 	/* Write message into cbuf */
-	addr = bus->console_addr + OFFSETOF(hndrte_cons_t, cbuf);
+	addr = bus->console_addr + offsetof(hndrte_cons_t, cbuf);
 	rv = dhdsdio_membytes(bus, TRUE, addr, (u8 *)msg, msglen);
 	if (rv < 0)
 		goto done;
 
 	/* Write length into vcons_in */
-	addr = bus->console_addr + OFFSETOF(hndrte_cons_t, vcons_in);
+	addr = bus->console_addr + offsetof(hndrte_cons_t, vcons_in);
 	val = htol32(msglen);
 	rv = dhdsdio_membytes(bus, TRUE, addr, (u8 *)&val, sizeof(val));
 	if (rv < 0)
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
@@ -689,7 +689,7 @@ static s32
 wl_run_iscan(struct wl_iscan_ctrl *iscan, struct wlc_ssid *ssid, u16 action)
 {
 	s32 params_size =
-	    (WL_SCAN_PARAMS_FIXED_SIZE + OFFSETOF(wl_iscan_params_t, params));
+	    (WL_SCAN_PARAMS_FIXED_SIZE + offsetof(wl_iscan_params_t, params));
 	struct wl_iscan_params *params;
 	s32 err = 0;
 
@@ -707,7 +707,7 @@ wl_run_iscan(struct wl_iscan_ctrl *iscan
 	params->action = htod16(action);
 	params->scan_duration = htod16(0);
 
-	/* params_size += OFFSETOF(wl_iscan_params_t, params); */
+	/* params_size += offsetof(wl_iscan_params_t, params); */
 	err = wl_dev_iovar_setbuf(iscan->dev, "iscan", params, params_size,
 				iscan->ioctl_buf, WLC_IOCTL_SMLEN);
 	if (unlikely(err)) {
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -3708,12 +3708,12 @@ int wl_iw_attach(struct net_device *dev,
 
 #ifdef CSCAN
 	params_size =
-	    (WL_SCAN_PARAMS_FIXED_SIZE + OFFSETOF(wl_iscan_params_t, params)) +
+	    (WL_SCAN_PARAMS_FIXED_SIZE + offsetof(wl_iscan_params_t, params)) +
 	    (WL_NUMCHANNELS * sizeof(u16)) +
 	    WL_SCAN_PARAMS_SSID_MAX * sizeof(wlc_ssid_t);
 #else
 	params_size =
-	    (WL_SCAN_PARAMS_FIXED_SIZE + OFFSETOF(wl_iscan_params_t, params));
+	    (WL_SCAN_PARAMS_FIXED_SIZE + offsetof(wl_iscan_params_t, params));
 #endif
 	iscan = kmalloc(sizeof(iscan_info_t), GFP_KERNEL);
 
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -456,9 +456,6 @@ extern "C" {
 	& ~((boundary) - 1))
 #define	ISPOWEROF2(x)		((((x)-1)&(x)) == 0)
 #define VALID_MASK(mask)	(!((mask) & ((mask) + 1)))
-#ifndef OFFSETOF
-#define	OFFSETOF(type, member)	((uint)(uintptr)&((type *)0)->member)
-#endif				/* OFFSETOF */
 #ifndef ARRAYSIZE
 #define ARRAYSIZE(a)		(sizeof(a)/sizeof(a[0]))
 #endif
--- a/drivers/staging/brcm80211/include/wlioctl.h
+++ b/drivers/staging/brcm80211/include/wlioctl.h
@@ -254,7 +254,7 @@ typedef struct wl_iscan_params {
 } wl_iscan_params_t;
 
 /* 3 fields + size of wl_scan_params, not including variable length array */
-#define WL_ISCAN_PARAMS_FIXED_SIZE (OFFSETOF(wl_iscan_params_t, params) + sizeof(wlc_ssid_t))
+#define WL_ISCAN_PARAMS_FIXED_SIZE (offsetof(wl_iscan_params_t, params) + sizeof(wlc_ssid_t))
 
 typedef struct wl_scan_results {
 	u32 buflen;
@@ -282,7 +282,7 @@ typedef struct wl_escan_params {
 	wl_scan_params_t params;
 } wl_escan_params_t;
 
-#define WL_ESCAN_PARAMS_FIXED_SIZE (OFFSETOF(wl_escan_params_t, params) + sizeof(wlc_ssid_t))
+#define WL_ESCAN_PARAMS_FIXED_SIZE (offsetof(wl_escan_params_t, params) + sizeof(wlc_ssid_t))
 
 typedef struct wl_escan_result {
 	u32 buflen;
@@ -302,7 +302,7 @@ typedef struct wl_iscan_results {
 
 /* size of wl_iscan_results not including variable length array */
 #define WL_ISCAN_RESULTS_FIXED_SIZE \
-	(WL_SCAN_RESULTS_FIXED_SIZE + OFFSETOF(wl_iscan_results_t, results))
+	(WL_SCAN_RESULTS_FIXED_SIZE + offsetof(wl_iscan_results_t, results))
 
 typedef struct wl_probe_params {
 	wlc_ssid_t ssid;
@@ -490,7 +490,7 @@ typedef struct wl_rm_req {
 	void *cb_arg;		/* arg to completion callback function */
 	wl_rm_req_elt_t req[1];	/* variable length block of requests */
 } wl_rm_req_t;
-#define WL_RM_REQ_FIXED_LEN	OFFSETOF(wl_rm_req_t, req)
+#define WL_RM_REQ_FIXED_LEN	offsetof(wl_rm_req_t, req)
 
 typedef struct wl_rm_rep_elt {
 	s8 type;
@@ -720,7 +720,7 @@ typedef struct {
 	u32 rx_decrypt_failures;	/* # of packet decrypted unsuccessfully */
 } sta_info_t;
 
-#define WL_OLD_STAINFO_SIZE	OFFSETOF(sta_info_t, tx_pkts)
+#define WL_OLD_STAINFO_SIZE	offsetof(sta_info_t, tx_pkts)
 
 #define WL_STA_VER		3
 
@@ -1949,8 +1949,8 @@ typedef struct wl_pkt_filter {
 	} u;
 } wl_pkt_filter_t;
 
-#define WL_PKT_FILTER_FIXED_LEN		  OFFSETOF(wl_pkt_filter_t, u)
-#define WL_PKT_FILTER_PATTERN_FIXED_LEN	  OFFSETOF(wl_pkt_filter_pattern_t, mask_and_pattern)
+#define WL_PKT_FILTER_FIXED_LEN		  offsetof(wl_pkt_filter_t, u)
+#define WL_PKT_FILTER_PATTERN_FIXED_LEN	  offsetof(wl_pkt_filter_pattern_t, mask_and_pattern)
 
 /* IOVAR "pkt_filter_enable" parameter. */
 typedef struct wl_pkt_filter_enable {
@@ -1964,7 +1964,7 @@ typedef struct wl_pkt_filter_list {
 	wl_pkt_filter_t filter[1];	/* Variable array of packet filters. */
 } wl_pkt_filter_list_t;
 
-#define WL_PKT_FILTER_LIST_FIXED_LEN	  OFFSETOF(wl_pkt_filter_list_t, filter)
+#define WL_PKT_FILTER_LIST_FIXED_LEN	  offsetof(wl_pkt_filter_list_t, filter)
 
 /* IOVAR "pkt_filter_stats" parameter. Used to retrieve debug statistics. */
 typedef struct wl_pkt_filter_stats {
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -3339,12 +3339,12 @@ void wlc_lcnphy_epa_switch(phy_info_t *p
 
 			}
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, gpiocontrol), ~0x0,
+				   offsetof(chipcregs_t, gpiocontrol), ~0x0,
 				   0x0);
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, gpioout), 0x40, 0x40);
+				   offsetof(chipcregs_t, gpioout), 0x40, 0x40);
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, gpioouten), 0x40,
+				   offsetof(chipcregs_t, gpioouten), 0x40,
 				   0x40);
 		} else {
 			mod_phy_reg(pi, 0x44c, (0x1 << 2), (0) << 2);
@@ -3352,11 +3352,11 @@ void wlc_lcnphy_epa_switch(phy_info_t *p
 			mod_phy_reg(pi, 0x44d, (0x1 << 2), (0) << 2);
 
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, gpioout), 0x40, 0x00);
+				   offsetof(chipcregs_t, gpioout), 0x40, 0x00);
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, gpioouten), 0x40, 0x0);
+				   offsetof(chipcregs_t, gpioouten), 0x40, 0x0);
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, gpiocontrol), ~0x0,
+				   offsetof(chipcregs_t, gpiocontrol), ~0x0,
 				   0x40);
 		}
 	}
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -140,7 +140,7 @@
 	(0 != (read_phy_reg((pi), 0x43b) & (0x1 << 6)))
 
 #define wlc_lcnphy_total_tx_frames(pi) \
-	wlapi_bmac_read_shm((pi)->sh->physhim, M_UCODE_MACSTAT + OFFSETOF(macstat_t, txallfrm))
+	wlapi_bmac_read_shm((pi)->sh->physhim, M_UCODE_MACSTAT + offsetof(macstat_t, txallfrm))
 
 typedef struct {
 	u16 gm_gain;
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -14549,7 +14549,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 		if ((pi->sh->boardflags & BFL_EXTLNA) &&
 		    (CHSPEC_IS2G(pi->radio_chanspec))) {
 			si_corereg(pi->sh->sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, chipcontrol), 0x40,
+				   offsetof(chipcregs_t, chipcontrol), 0x40,
 				   0x40);
 		}
 	}
--- a/drivers/staging/brcm80211/sys/wlc_alloc.c
+++ b/drivers/staging/brcm80211/sys/wlc_alloc.c
@@ -147,7 +147,7 @@ void wlc_bsscfg_mfree(osl_t *osh, wlc_bs
 
 	if (cfg->maclist) {
 		MFREE(osh, cfg->maclist,
-		      (int)(OFFSETOF(struct maclist, ea) +
+		      (int)(offsetof(struct maclist, ea) +
 			    cfg->nmac * ETHER_ADDR_LEN));
 		cfg->maclist = NULL;
 	}
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -348,7 +348,7 @@ static int wlc_ffpld_check_txfunfl(wlc_i
 	/* return if we got here for a different reason than underflows */
 	cur_txunfl =
 	    wlc_read_shm(wlc,
-			 M_UCODE_MACSTAT + OFFSETOF(macstat_t, txfunfl[fid]));
+			 M_UCODE_MACSTAT + offsetof(macstat_t, txfunfl[fid]));
 	new_txunfl = (u16) (cur_txunfl - fifo->prev_txfunfl);
 	if (new_txunfl == 0) {
 		WL_FFPLD(("check_txunfl : TX status FRAG set but no tx underflows\n"));
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -2003,16 +2003,16 @@ void wlc_bmac_core_phypll_reset(wlc_hw_i
 	WL_TRACE(("wl%d: wlc_bmac_core_phypll_reset\n", wlc_hw->unit));
 
 	si_corereg(wlc_hw->sih, SI_CC_IDX,
-		   OFFSETOF(chipcregs_t, chipcontrol_addr), ~0, 0);
+		   offsetof(chipcregs_t, chipcontrol_addr), ~0, 0);
 	OSL_DELAY(1);
 	si_corereg(wlc_hw->sih, SI_CC_IDX,
-		   OFFSETOF(chipcregs_t, chipcontrol_data), 0x4, 0);
+		   offsetof(chipcregs_t, chipcontrol_data), 0x4, 0);
 	OSL_DELAY(1);
 	si_corereg(wlc_hw->sih, SI_CC_IDX,
-		   OFFSETOF(chipcregs_t, chipcontrol_data), 0x4, 4);
+		   offsetof(chipcregs_t, chipcontrol_data), 0x4, 4);
 	OSL_DELAY(1);
 	si_corereg(wlc_hw->sih, SI_CC_IDX,
-		   OFFSETOF(chipcregs_t, chipcontrol_data), 0x4, 0);
+		   offsetof(chipcregs_t, chipcontrol_data), 0x4, 0);
 	OSL_DELAY(1);
 }
 
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -1791,9 +1791,9 @@ void *BCMATTACHFN(wlc_attach) (void *wl,
 	ASSERT(sizeof(struct dot11_bcn_prb) == DOT11_BCN_PRB_LEN);
 	ASSERT(sizeof(tx_status_t) == TXSTATUS_LEN);
 	ASSERT(sizeof(ht_cap_ie_t) == HT_CAP_IE_LEN);
-	ASSERT(OFFSETOF(wl_scan_params_t, channel_list) ==
+	ASSERT(offsetof(wl_scan_params_t, channel_list) ==
 	       WL_SCAN_PARAMS_FIXED_SIZE);
-	ASSERT(ISALIGNED(OFFSETOF(wsec_key_t, data), sizeof(u32)));
+	ASSERT(ISALIGNED(offsetof(wsec_key_t, data), sizeof(u32)));
 	ASSERT(ISPOWEROF2(MA_WINDOW_SZ));
 
 	ASSERT(sizeof(wlc_d11rxhdr_t) <= WL_HWRXOFF);
@@ -8123,7 +8123,7 @@ int wlc_get_revision_info(wlc_info_t *wl
 	rinfo->bus = wlc->pub->sih->bustype;
 	rinfo->chipnum = wlc->pub->sih->chip;
 
-	if (len >= (OFFSETOF(wlc_rev_info_t, chippkg))) {
+	if (len >= (offsetof(wlc_rev_info_t, chippkg))) {
 		rinfo->phytype = wlc->band->phytype;
 		rinfo->phyrev = wlc->band->phyrev;
 		rinfo->anarev = 0;	/* obsolete stuff, suppress */
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -198,7 +198,7 @@ void pktq_init(struct pktq *pq, int num_
 
 	/* pq is variable size; only zero out what's requested */
 	bzero(pq,
-	      OFFSETOF(struct pktq, q) + (sizeof(struct pktq_prec) * num_prec));
+	      offsetof(struct pktq, q) + (sizeof(struct pktq_prec) * num_prec));
 
 	pq->num_prec = (u16) num_prec;
 
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -71,34 +71,34 @@ static void si_pmu_set_4330_plldivs(si_t
 /* Read/write a chipcontrol reg */
 u32 si_pmu_chipcontrol(si_t *sih, uint reg, u32 mask, u32 val)
 {
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol_addr), ~0,
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, chipcontrol_addr), ~0,
 		   reg);
 	return si_corereg(sih, SI_CC_IDX,
-			  OFFSETOF(chipcregs_t, chipcontrol_data), mask, val);
+			  offsetof(chipcregs_t, chipcontrol_data), mask, val);
 }
 
 /* Read/write a regcontrol reg */
 u32 si_pmu_regcontrol(si_t *sih, uint reg, u32 mask, u32 val)
 {
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_addr), ~0,
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, regcontrol_addr), ~0,
 		   reg);
 	return si_corereg(sih, SI_CC_IDX,
-			  OFFSETOF(chipcregs_t, regcontrol_data), mask, val);
+			  offsetof(chipcregs_t, regcontrol_data), mask, val);
 }
 
 /* Read/write a pllcontrol reg */
 u32 si_pmu_pllcontrol(si_t *sih, uint reg, u32 mask, u32 val)
 {
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pllcontrol_addr), ~0,
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, pllcontrol_addr), ~0,
 		   reg);
 	return si_corereg(sih, SI_CC_IDX,
-			  OFFSETOF(chipcregs_t, pllcontrol_data), mask, val);
+			  offsetof(chipcregs_t, pllcontrol_data), mask, val);
 }
 
 /* PMU PLL update */
 void si_pmu_pllupd(si_t *sih)
 {
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pmucontrol),
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, pmucontrol),
 		   PCTL_PLL_PLLCTL_UPD, PCTL_PLL_PLLCTL_UPD);
 }
 
@@ -176,9 +176,9 @@ BCMATTACHFN(si_pmu_set_ldo_voltage) (si_
 
 	shift = sr_cntl_shift + rc_shift;
 
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_addr),
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, regcontrol_addr),
 		   ~0, addr);
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_data),
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, regcontrol_data),
 		   mask << shift, (voltage & mask) << shift);
 }
 
@@ -2532,7 +2532,7 @@ void BCMATTACHFN(si_pmu_chip_init) (si_t
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
 #ifdef CHIPC_UART_ALWAYS_ON
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, clk_ctl_st),
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, clk_ctl_st),
 		   CCS_FORCEALP, CCS_FORCEALP);
 #endif				/* CHIPC_UART_ALWAYS_ON */
 
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -426,10 +426,10 @@ static void pcie_clkreq_upd(pcicore_info
 	case SI_PCIDOWN:
 		if (sih->buscorerev == 6) {	/* turn on serdes PLL down */
 			si_corereg(sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, chipcontrol_addr), ~0,
+				   offsetof(chipcregs_t, chipcontrol_addr), ~0,
 				   0);
 			si_corereg(sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, chipcontrol_data),
+				   offsetof(chipcregs_t, chipcontrol_data),
 				   ~0x40, 0);
 		} else if (pi->pcie_pr42767) {
 			pcie_clkreq((void *)pi, 1, 1);
@@ -438,10 +438,10 @@ static void pcie_clkreq_upd(pcicore_info
 	case SI_PCIUP:
 		if (sih->buscorerev == 6) {	/* turn off serdes PLL down */
 			si_corereg(sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, chipcontrol_addr), ~0,
+				   offsetof(chipcregs_t, chipcontrol_addr), ~0,
 				   0);
 			si_corereg(sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, chipcontrol_data),
+				   offsetof(chipcregs_t, chipcontrol_data),
 				   ~0x40, 0x40);
 		} else if (PCIE_ASPM(sih)) {	/* disable clkreq */
 			pcie_clkreq((void *)pi, 1, 0);
@@ -569,7 +569,7 @@ static void pcie_war_noplldown(pcicore_i
 	ASSERT(pi->sih->buscorerev == 7);
 
 	/* turn off serdes PLL down */
-	si_corereg(pi->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol),
+	si_corereg(pi->sih, SI_CC_IDX, offsetof(chipcregs_t, chipcontrol),
 		   CHIPCTRL_4321_PLL_DOWN, CHIPCTRL_4321_PLL_DOWN);
 
 	/*  clear srom shadow backdoor */
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -486,7 +486,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 	w = getintvar(pvars, "leddc");
 	if (w == 0)
 		w = DEFAULT_GPIOTIMERVAL;
-	sb_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiotimerval), ~0, w);
+	sb_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, gpiotimerval), ~0, w);
 
 #ifdef BCMDBG
 	/* clear any previous epidiag-induced target abort */
@@ -646,7 +646,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 	w = getintvar(pvars, "leddc");
 	if (w == 0)
 		w = DEFAULT_GPIOTIMERVAL;
-	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiotimerval), ~0, w);
+	si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, gpiotimerval), ~0, w);
 
 	if (PCIE(sii)) {
 		ASSERT(sii->pch != NULL);
@@ -659,7 +659,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 		if (CHIPREV(sih->chiprev) == 0) {
 			SI_MSG(("Applying 43224A0 WARs\n"));
 			si_corereg(sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, chipcontrol),
+				   offsetof(chipcregs_t, chipcontrol),
 				   CCTRL43224_GPIO_TOGGLE,
 				   CCTRL43224_GPIO_TOGGLE);
 			si_pmu_chipcontrol(sih, 0, CCTRL_43224A0_12MA_LED_DRIVE,
@@ -1021,7 +1021,7 @@ si_watchdog(si_t *sih, uint ticks)
 
 		if ((sih->chip == BCM4319_CHIP_ID) && (sih->chiprev == 0) &&
 			(ticks != 0)) {
-			si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t,
+			si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t,
 			clk_ctl_st), ~0, 0x2);
 			si_setcore(sih, USB20D_CORE_ID, 0);
 			si_core_disable(sih, 1);
@@ -1030,11 +1030,11 @@ si_watchdog(si_t *sih, uint ticks)
 
 		if (ticks == 1)
 			ticks = 2;
-		si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pmuwatchdog),
+		si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, pmuwatchdog),
 			~0, ticks);
 	} else {
 		/* instant NMI */
-		si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, watchdog),
+		si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, watchdog),
 			~0, ticks);
 	}
 }
@@ -1048,7 +1048,7 @@ void si_watchdog(si_t *sih, uint ticks)
 		if ((CHIPID(sih->chip) == BCM4319_CHIP_ID) &&
 		    (CHIPREV(sih->chiprev) == 0) && (ticks != 0)) {
 			si_corereg(sih, SI_CC_IDX,
-				   OFFSETOF(chipcregs_t, clk_ctl_st), ~0, 0x2);
+				   offsetof(chipcregs_t, clk_ctl_st), ~0, 0x2);
 			si_setcore(sih, USB20D_CORE_ID, 0);
 			si_core_disable(sih, 1);
 			si_setcore(sih, CC_CORE_ID, 0);
@@ -1068,7 +1068,7 @@ void si_watchdog(si_t *sih, uint ticks)
 		else if (ticks > maxt)
 			ticks = maxt;
 
-		si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pmuwatchdog),
+		si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, pmuwatchdog),
 			   ~0, ticks);
 	} else {
 		/* make sure we come up in fast clock mode; or if clearing, clear clock */
@@ -1077,7 +1077,7 @@ void si_watchdog(si_t *sih, uint ticks)
 		if (ticks > maxt)
 			ticks = maxt;
 
-		si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, watchdog), ~0,
+		si_corereg(sih, SI_CC_IDX, offsetof(chipcregs_t, watchdog), ~0,
 			   ticks);
 	}
 }
@@ -1786,7 +1786,7 @@ u32 si_gpiocontrol(si_t *sih, u32 mask,
 		val &= mask;
 	}
 
-	regoff = OFFSETOF(chipcregs_t, gpiocontrol);
+	regoff = offsetof(chipcregs_t, gpiocontrol);
 	return si_corereg(sih, SI_CC_IDX, regoff, mask, val);
 }
 

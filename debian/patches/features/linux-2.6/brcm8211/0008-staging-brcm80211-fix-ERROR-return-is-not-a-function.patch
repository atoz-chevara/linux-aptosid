commit 90ea22962c5160812c601a115fb7b80c60d49fad
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:32 2010 -0400

    staging: brcm80211: fix "ERROR: return is not a function, paren..."
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/include/bcmnvram.h
+++ b/drivers/staging/brcm80211/include/bcmnvram.h
@@ -94,7 +94,7 @@ extern int BCMINITFN(nvram_resetgpio_ini
 static INLINE int nvram_match(char *name, char *match)
 {
 	const char *value = nvram_get(name);
-	return (value && !strcmp(value, match));
+	return value && !strcmp(value, match);
 }
 
 /*
@@ -107,7 +107,7 @@ static INLINE int nvram_match(char *name
 static INLINE int nvram_invmatch(char *name, char *invmatch)
 {
 	const char *value = nvram_get(name);
-	return (value && strcmp(value, invmatch));
+	return value && strcmp(value, invmatch);
 }
 
 /*
--- a/drivers/staging/brcm80211/include/bitfuncs.h
+++ b/drivers/staging/brcm80211/include/bitfuncs.h
@@ -78,7 +78,7 @@ static INLINE uint32 find_msbit(uint32 x
 	if (temp_x & DB_POW_MASK1) {
 		msbit += 1;
 	}
-	return (msbit);
+	return msbit;
 }
 
 #endif				/* USE_PENTIUM_BSR && __GNUC__ */
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -160,12 +160,12 @@ char *phy_getvar(phy_info_t *pi, const c
 
 	for (s = vars; s && *s;) {
 		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
-			return (&s[len + 1]);
+			return &s[len + 1];
 
 		while (*s++) ;
 	}
 
-	return (nvram_get(name));
+	return nvram_get(name);
 }
 
 int phy_getintvar(phy_info_t *pi, const char *name)
@@ -173,9 +173,9 @@ int phy_getintvar(phy_info_t *pi, const
 	char *val;
 
 	if ((val = PHY_GETVAR(pi, name)) == NULL)
-		return (0);
+		return 0;
 
-	return (bcm_strtoul(val, NULL, 0));
+	return bcm_strtoul(val, NULL, 0);
 }
 
 void wlc_phyreg_enter(wlc_phy_t *pih)
@@ -216,7 +216,7 @@ uint16 read_radio_reg(phy_info_t *pi, ui
 		return 0xffff;
 
 	if (NORADIO_ENAB(pi->pubpi))
-		return (NORADIO_IDCODE & 0xffff);
+		return NORADIO_IDCODE & 0xffff;
 
 	switch (pi->pubpi.phy_type) {
 	case PHY_TYPE_N:
@@ -303,7 +303,7 @@ static uint32 read_radio_id(phy_info_t *
 	uint32 id;
 
 	if (NORADIO_ENAB(pi->pubpi))
-		return (NORADIO_IDCODE);
+		return NORADIO_IDCODE;
 
 	if (D11REV_GE(pi->sh->corerev, 24)) {
 		uint32 b0, b1, b2;
@@ -415,7 +415,7 @@ uint16 read_phy_reg(phy_info_t *pi, uint
 		|| D11REV_IS(pi->sh->corerev, 12)) || wlc_phy_war41476(pi));
 
 	pi->phy_wreg = 0;
-	return (R_REG(osh, &regs->phyregdata));
+	return R_REG(osh, &regs->phyregdata);
 }
 
 void write_phy_reg(phy_info_t *pi, uint16 addr, uint16 val)
@@ -1514,8 +1514,8 @@ int wlc_phy_channel2freq(uint channel)
 
 	for (i = 0; i < ARRAYSIZE(chan_info_all); i++)
 		if (chan_info_all[i].chan == channel)
-			return (chan_info_all[i].freq);
-	return (0);
+			return chan_info_all[i].freq;
+	return 0;
 }
 
 void
@@ -1599,7 +1599,7 @@ int wlc_phy_txpower_get(wlc_phy_t *ppi,
 	*qdbm = pi->tx_user_target[0];
 	if (override != NULL)
 		*override = pi->txpwroverride;
-	return (0);
+	return 0;
 }
 
 void wlc_phy_txpower_target_set(wlc_phy_t *ppi, struct txpwr_limits *txpwr)
@@ -1687,7 +1687,7 @@ int wlc_phy_txpower_set(wlc_phy_t *ppi,
 				wlapi_enable_mac(pi->sh->physhim);
 		}
 	}
-	return (0);
+	return 0;
 }
 
 void
@@ -2309,7 +2309,7 @@ static uint32 wlc_phy_txpower_est_power_
 
 	est_pwr =
 	    (uint32) ((pwr0 << 24) | (pwr1 << 16) | (adj_pwr0 << 8) | adj_pwr1);
-	return (est_pwr);
+	return est_pwr;
 }
 
 void
@@ -2421,7 +2421,7 @@ bool wlc_phy_test_ison(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
-	return (pi->phytest_on);
+	return pi->phytest_on;
 }
 
 bool wlc_phy_ant_rxdiv_get(wlc_phy_t *ppi, uint8 *pval)
@@ -3440,7 +3440,7 @@ bool wlc_phy_txpower_ipa_ison(wlc_phy_t
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	if (ISNPHY(pi))
-		return (wlc_phy_n_txpower_ipa_ison(pi));
+		return wlc_phy_n_txpower_ipa_ison(pi);
 	else
 		return 0;
 }
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -15125,7 +15125,7 @@ uint8 wlc_phy_rxcore_getstate_nphy(wlc_p
 	regval = read_phy_reg(pi, 0xa2);
 	rxen_bits = (regval >> 4) & 0xf;
 
-	return ((uint8) rxen_bits);
+	return (uint8) rxen_bits;
 }
 
 bool wlc_phy_n_txpower_ipa_ison(phy_info_t *pi)
@@ -18336,9 +18336,9 @@ static uint16 wlc_phy_radio205x_rcal(phy
 		write_radio_reg(pi, RADIO_2056_SYN_PLL_MAST2 | RADIO_2056_SYN,
 				savereg);
 
-		return (rcal_reg & 0x1f);
+		return rcal_reg & 0x1f;
 	}
-	return (rcal_reg & 0x3e);
+	return rcal_reg & 0x3e;
 }
 
 static void
@@ -18620,7 +18620,7 @@ static uint16 wlc_phy_radio2057_rccal(ph
 
 	write_radio_reg(pi, RADIO_2057_RCCAL_START_R1_Q1_P1, 0x15);
 
-	return (rccal_valid);
+	return rccal_valid;
 }
 
 static void
@@ -20902,7 +20902,7 @@ wlc_phy_poll_rssi_nphy(phy_info_t *pi, u
 		write_phy_reg(pi, 0x7d, rfctrlrssiothers2_save);
 	}
 
-	return (rssi_out_val);
+	return rssi_out_val;
 }
 
 int16 wlc_phy_tempsense_nphy(phy_info_t *pi)
@@ -21185,7 +21185,7 @@ int16 wlc_phy_tempsense_nphy(phy_info_t
 		write_phy_reg(pi, 0xa5, afectrlOverride_save);
 	}
 
-	return ((int16) radio_temp[0] + offset);
+	return (int16) radio_temp[0] + offset;
 }
 
 static void
@@ -22719,7 +22719,7 @@ nphy_txgains_t wlc_phy_get_tx_gain_nphy(
 		}
 	}
 
-	return (target_gain);
+	return target_gain;
 }
 
 static void
@@ -25759,7 +25759,7 @@ wlc_phy_rc_sweep_nphy(phy_info_t *pi, ui
 
 	pi->nphy_anarxlpf_adjusted = FALSE;
 
-	return (best_rccal_val - 0x80);
+	return best_rccal_val - 0x80;
 }
 
 #define WAIT_FOR_SCOPE	4000000
@@ -28718,8 +28718,8 @@ static void wlc_phy_txpwrctrl_pwr_setup_
 
 static bool wlc_phy_txpwr_ison_nphy(phy_info_t *pi)
 {
-	return (read_phy_reg((pi), 0x1e7) & ((0x1 << 15) |
-					     (0x1 << 14) | (0x1 << 13)));
+	return read_phy_reg((pi), 0x1e7) & ((0x1 << 15) |
+					     (0x1 << 14) | (0x1 << 13));
 }
 
 static uint8 wlc_phy_txpwr_idx_cur_get_nphy(phy_info_t *pi, uint8 core)
--- a/drivers/staging/brcm80211/sys/wl_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.c
@@ -775,7 +775,7 @@ static int wl_set_hint(wl_info_t *wl, ch
 {
 	WL_ERROR(("%s: Sending country code %c%c to MAC80211\n", __func__,
 		  abbrev[0], abbrev[1]));
-	return (regulatory_hint(wl->pub->ieee_hw->wiphy, abbrev));
+	return regulatory_hint(wl->pub->ieee_hw->wiphy, abbrev);
 }
 
 /**
@@ -1403,7 +1403,7 @@ static int ieee_hw_rate_init(struct ieee
 		hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &wl_band_2GHz_nphy;
 	} else {
 		BUG();
-		return (-1);
+		return -1;
 	}
 
 	/* Assume all bands use the same phy.  True for 11n devices. */
@@ -1417,13 +1417,13 @@ static int ieee_hw_rate_init(struct ieee
 			hw->wiphy->bands[IEEE80211_BAND_5GHZ] =
 			    &wl_band_5GHz_nphy;
 		} else {
-			return (-1);
+			return -1;
 		}
 	}
 
 	WL_NONE(("%s: 2ghz = %d, 5ghz = %d\n", __func__, 1, has_5g));
 
-	return (0);
+	return 0;
 }
 
 static int ieee_hw_init(struct ieee80211_hw *hw)
@@ -1449,7 +1449,7 @@ static int ieee_hw_init(struct ieee80211
 	hw->rate_control_algorithm = "minstrel_ht";
 
 	hw->sta_data_size = sizeof(struct scb);
-	return (ieee_hw_rate_init(hw));
+	return ieee_hw_rate_init(hw);
 }
 
 #ifndef BCMSDIO
@@ -1478,14 +1478,14 @@ wl_pci_probe(struct pci_dev *pdev, const
 	    (((pdev->device & 0xff00) != 0x4300) &&
 	     ((pdev->device & 0xff00) != 0x4700) &&
 	     ((pdev->device < 43000) || (pdev->device > 43999))))
-		return (-ENODEV);
+		return -ENODEV;
 
 	rc = pci_enable_device(pdev);
 	if (rc) {
 		WL_ERROR(("%s: Cannot enable device %d-%d_%d\n", __func__,
 			  pdev->bus->number, PCI_SLOT(pdev->devfn),
 			  PCI_FUNC(pdev->devfn)));
-		return (-ENODEV);
+		return -ENODEV;
 	}
 	pci_set_master(pdev);
 
@@ -1574,7 +1574,7 @@ static int wl_resume(struct pci_dev *pde
 	err = wl_up(wl);
 	WL_UNLOCK(wl);
 
-	return (err);
+	return err;
 }
 #endif				/* LINUXSTA_PS */
 
@@ -1657,7 +1657,7 @@ static int __init wl_module_init(void)
 
 #ifndef BCMSDIO
 	if (!(error = pci_module_init(&wl_pci_driver)))
-		return (0);
+		return 0;
 
 #endif				/* !BCMSDIO */
 
@@ -1671,7 +1671,7 @@ static int __init wl_module_init(void)
 	}
 #endif				/* WLC_HIGH_ONLY */
 
-	return (error);
+	return error;
 }
 
 /**
@@ -1809,7 +1809,7 @@ wl_start_int(wl_info_t *wl, struct ieee8
 #ifdef WLC_HIGH_ONLY
 	WL_UNLOCK(wl);
 #endif
-	return (NETDEV_TX_OK);
+	return NETDEV_TX_OK;
 }
 
 void wl_txflowcontrol(wl_info_t *wl, struct wl_if *wlif, bool state, int prio)
@@ -1865,7 +1865,7 @@ uint wl_reset(wl_info_t *wl)
 	/* dpc will not be rescheduled */
 	wl->resched = 0;
 
-	return (0);
+	return 0;
 }
 
 /*
@@ -1919,11 +1919,11 @@ int wl_up(wl_info_t *wl)
 	int error = 0;
 
 	if (wl->pub->up)
-		return (0);
+		return 0;
 
 	error = wlc_up(wl->wlc);
 
-	return (error);
+	return error;
 }
 
 void wl_down(wl_info_t *wl)
@@ -2254,7 +2254,7 @@ static int BCMFASTPATH wl_start(struct s
 
 	TXQ_UNLOCK(wl, flags);
 
-	return (0);
+	return 0;
 
 }
 
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -166,7 +166,7 @@ static INLINE uint16 pkt_txh_seqnum(wlc_
 	struct dot11_header *h;
 	txh = (d11txh_t *) PKTDATA(p);
 	h = (struct dot11_header *)((uint8 *) (txh + 1) + D11_PHY_HDR_LEN);
-	return (ltoh16(h->seq) >> SEQNUM_SHIFT);
+	return ltoh16(h->seq) >> SEQNUM_SHIFT;
 }
 
 ampdu_info_t *BCMATTACHFN(wlc_ampdu_attach) (wlc_info_t *wlc)
@@ -1400,7 +1400,7 @@ void wlc_ampdu_macaddr_upd(wlc_info_t *w
 
 bool wlc_aggregatable(wlc_info_t *wlc, uint8 tid)
 {
-	return (wlc->ampdu->ini_enable[tid]);
+	return wlc->ampdu->ini_enable[tid];
 }
 
 void wlc_ampdu_shm_upd(ampdu_info_t *ampdu)
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -259,7 +259,7 @@ static uint32 WLBANDINITFN(wlc_setband_i
 
 	wlc_setxband(wlc_hw, bandunit);
 
-	return (macintmask);
+	return macintmask;
 }
 
 /* Process received frames */
@@ -315,7 +315,7 @@ wlc_bmac_recv(wlc_hw_info_t *wlc_hw, uin
 		wlc_recv(wlc_hw->wlc, p);
 	}
 
-	return (n >= bound_limit);
+	return n >= bound_limit;
 }
 
 /* second-level interrupt processing
@@ -441,11 +441,11 @@ bool BCMFASTPATH wlc_dpc(wlc_info_t *wlc
 	ASSERT(bounded == TRUE || wlc->macintstatus == 0);
 
 	/* it isn't done and needs to be resched if macintstatus is non-zero */
-	return (wlc->macintstatus != 0);
+	return wlc->macintstatus != 0;
 
  fatal:
 	wl_init(wlc->wl);
-	return (wlc->macintstatus != 0);
+	return wlc->macintstatus != 0;
 }
 
 /* common low-level watchdog code */
@@ -1345,13 +1345,13 @@ void wlc_bmac_set_hw_etheraddr(wlc_hw_in
 
 int wlc_bmac_bandtype(wlc_hw_info_t *wlc_hw)
 {
-	return (wlc_hw->band->bandtype);
+	return wlc_hw->band->bandtype;
 }
 
 void *wlc_cur_phy(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
-	return ((void *)wlc_hw->band->pi);
+	return (void *)wlc_hw->band->pi;
 }
 
 /* control chip clock to save power, enable dynamic clock or force fast clock */
@@ -2240,7 +2240,7 @@ bool wlc_bmac_radio_read_hwdisabled(wlc_
 	if (!xtal)
 		wlc_bmac_xtal(wlc_hw, OFF);
 
-	return (v);
+	return v;
 }
 
 /* Initialize just the hardware when coming out of POR or S3/S5 system states */
@@ -2308,7 +2308,7 @@ static bool wlc_dma_rxreset(wlc_hw_info_
 		OSL_DELAY(2000);
 	}
 
-	return (dma_rxreset(di));
+	return dma_rxreset(di);
 }
 
 /* d11 core reset
@@ -3002,7 +3002,7 @@ uint32 wlc_intrsoff(wlc_info_t *wlc)
 	wlc->macintmask = 0;
 
 	/* return previous macintmask; resolve race between us and our isr */
-	return (wlc->macintstatus ? 0 : macintmask);
+	return wlc->macintstatus ? 0 : macintmask;
 }
 
 void wlc_intrsrestore(wlc_info_t *wlc, uint32 macintmask)
@@ -3289,7 +3289,7 @@ bool BCMFASTPATH wlc_isr(wlc_info_t *wlc
 	*wantdpc = FALSE;
 
 	if (!wlc_hw->up || !wlc->macintmask)
-		return (FALSE);
+		return FALSE;
 
 	/* read and clear macintstatus and intstatus registers */
 	macintstatus = wlc_intstatus(wlc, TRUE);
@@ -3299,7 +3299,7 @@ bool BCMFASTPATH wlc_isr(wlc_info_t *wlc
 
 	/* it is not for us */
 	if (macintstatus == 0)
-		return (FALSE);
+		return FALSE;
 
 	*wantdpc = TRUE;
 
@@ -3307,7 +3307,7 @@ bool BCMFASTPATH wlc_isr(wlc_info_t *wlc
 	ASSERT(wlc->macintstatus == 0);
 	wlc->macintstatus = macintstatus;
 
-	return (TRUE);
+	return TRUE;
 
 }
 
@@ -3634,7 +3634,7 @@ static uint16 wlc_bmac_ofdm_ratetable_of
 	/* Find the SHM pointer to the rate table entry by looking in the
 	 * Direct-map Table
 	 */
-	return (2 * wlc_bmac_read_shm(wlc_hw, M_RT_DIRMAP_A + (plcp_rate * 2)));
+	return 2 * wlc_bmac_read_shm(wlc_hw, M_RT_DIRMAP_A + (plcp_rate * 2));
 }
 
 void wlc_bmac_band_stf_ss_set(wlc_hw_info_t *wlc_hw, uint8 stf_mode)
@@ -3686,7 +3686,7 @@ bool BCMATTACHFN(wlc_bmac_validate_chip_
 	val = R_REG(osh, &regs->objdata);
 	if (val != (uint32) 0xaa5555aa) {
 		WL_ERROR(("wl%d: validate_chip_access: SHM = 0x%x, expected 0xaa5555aa\n", wlc_hw->unit, val));
-		return (FALSE);
+		return FALSE;
 	}
 
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
@@ -3698,7 +3698,7 @@ bool BCMATTACHFN(wlc_bmac_validate_chip_
 	val = R_REG(osh, &regs->objdata);
 	if (val != (uint32) 0x55aaaa55) {
 		WL_ERROR(("wl%d: validate_chip_access: SHM = 0x%x, expected 0x55aaaa55\n", wlc_hw->unit, val));
-		return (FALSE);
+		return FALSE;
 	}
 
 	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
@@ -3728,12 +3728,12 @@ bool BCMATTACHFN(wlc_bmac_validate_chip_
 		val = R_REG(osh, &regs->tsf_cfpstrt_l);
 		if (val != (uint) 0xBBBB) {
 			WL_ERROR(("wl%d: validate_chip_access: tsf_cfpstrt_l = 0x%x, expected" " 0x%x\n", wlc_hw->unit, val, 0xBBBB));
-			return (FALSE);
+			return FALSE;
 		}
 		val = R_REG(osh, &regs->tsf_cfpstrt_h);
 		if (val != (uint) 0xCCCC) {
 			WL_ERROR(("wl%d: validate_chip_access: tsf_cfpstrt_h = 0x%x, expected" " 0x%x\n", wlc_hw->unit, val, 0xCCCC));
-			return (FALSE);
+			return FALSE;
 		}
 
 	}
@@ -3745,10 +3745,10 @@ bool BCMATTACHFN(wlc_bmac_validate_chip_
 	if ((w != (MCTL_IHR_EN | MCTL_WAKE)) &&
 	    (w != (MCTL_IHR_EN | MCTL_GMODE | MCTL_WAKE))) {
 		WL_ERROR(("wl%d: validate_chip_access: maccontrol = 0x%x, expected 0x%x or 0x%x\n", wlc_hw->unit, w, (MCTL_IHR_EN | MCTL_WAKE), (MCTL_IHR_EN | MCTL_GMODE | MCTL_WAKE)));
-		return (FALSE);
+		return FALSE;
 	}
 
-	return (TRUE);
+	return TRUE;
 }
 
 #define PHYPLL_WAIT_US	100000
@@ -4189,7 +4189,7 @@ uint16 wlc_bmac_rate_shm_offset(wlc_hw_i
 	/* Find the SHM pointer to the rate table entry by looking in the
 	 * Direct-map Table
 	 */
-	return (2 * wlc_bmac_read_shm(wlc_hw, table_ptr + (index * 2)));
+	return 2 * wlc_bmac_read_shm(wlc_hw, table_ptr + (index * 2));
 }
 
 void wlc_bmac_set_txpwr_percent(wlc_hw_info_t *wlc_hw, uint8 val)
--- a/drivers/staging/brcm80211/sys/wlc_channel.c
+++ b/drivers/staging/brcm80211/sys/wlc_channel.c
@@ -945,7 +945,7 @@ wlc_channels_init(wlc_cm_info_t *wlc_cm,
 	wlc_quiet_channels_reset(wlc_cm);
 	wlc_channels_commit(wlc_cm);
 
-	return (0);
+	return 0;
 }
 
 /* Update the radio state (enable/disable) and tx power targets
@@ -1020,7 +1020,7 @@ void wlc_quiet_channels_reset(wlc_cm_inf
 
 bool wlc_quiet_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chspec)
 {
-	return (N_ENAB(wlc_cm->wlc->pub) && CHSPEC_IS40(chspec) ?
+	return N_ENAB(wlc_cm->wlc->pub) && CHSPEC_IS40(chspec) ?
 		(isset
 		 (wlc_cm->quiet_channels.vec,
 		  LOWER_20_SB(CHSPEC_CHANNEL(chspec)))
@@ -1029,7 +1029,7 @@ bool wlc_quiet_chanspec(wlc_cm_info_t *w
 									quiet_channels.
 									vec,
 									CHSPEC_CHANNEL
-									(chspec)));
+									(chspec));
 }
 
 /* Is the channel valid for the current locale? (but don't consider channels not
@@ -1039,9 +1039,9 @@ bool wlc_valid_channel20_db(wlc_cm_info_
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 
-	return (VALID_CHANNEL20(wlc, val) ||
+	return VALID_CHANNEL20(wlc, val) ||
 		(!wlc->bandlocked
-		 && VALID_CHANNEL20_IN_BAND(wlc, OTHERBANDUNIT(wlc), val)));
+		 && VALID_CHANNEL20_IN_BAND(wlc, OTHERBANDUNIT(wlc), val));
 }
 
 /* Is the channel valid for the current locale and specified band? */
@@ -1547,9 +1547,9 @@ wlc_valid_chanspec_ext(wlc_cm_info_t *wl
 	/* Check a 20Mhz channel */
 	if (CHSPEC_IS20(chspec)) {
 		if (dualband)
-			return (VALID_CHANNEL20_DB(wlc_cm->wlc, channel));
+			return VALID_CHANNEL20_DB(wlc_cm->wlc, channel);
 		else
-			return (VALID_CHANNEL20(wlc_cm->wlc, channel));
+			return VALID_CHANNEL20(wlc_cm->wlc, channel);
 	}
 #ifdef SUPPORT_40MHZ
 	/* We know we are now checking a 40MHZ channel, so we should only be here
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -1151,7 +1151,7 @@ ratespec_t wlc_lowest_basic_rspec(wlc_in
 	}
 #endif
 
-	return (lowest_basic_rspec);
+	return lowest_basic_rspec;
 }
 
 /* This function changes the phytxctl for beacon based on current beacon ratespec AND txant
@@ -2076,7 +2076,7 @@ void *BCMATTACHFN(wlc_attach) (void *wl,
 	if (perr)
 		*perr = 0;
 
-	return ((void *)wlc);
+	return (void *)wlc;
 
  fail:
 	WL_ERROR(("wl%d: %s: failed with err %d\n", unit, __func__, err));
@@ -2085,7 +2085,7 @@ void *BCMATTACHFN(wlc_attach) (void *wl,
 
 	if (perr)
 		*perr = err;
-	return (NULL);
+	return NULL;
 }
 
 static void BCMNMIATTACHFN(wlc_attach_antgain_init) (wlc_info_t *wlc)
@@ -2406,7 +2406,7 @@ uint BCMATTACHFN(wlc_detach) (wlc_info_t
 		ASSERT(wlc->modulecb[i].name[0] == '\0');
 
 	wlc_detach_mfree(wlc, wlc->osh);
-	return (callbacks);
+	return callbacks;
 }
 
 /* update state that depends on the current value of "ap" */
@@ -2440,12 +2440,12 @@ static void wlc_radio_hwdisable_upd(wlc_
 /* return TRUE if Minimum Power Consumption should be entered, FALSE otherwise */
 bool wlc_is_non_delay_mpc(wlc_info_t *wlc)
 {
-	return (FALSE);
+	return FALSE;
 }
 
 bool wlc_ismpc(wlc_info_t *wlc)
 {
-	return ((wlc->mpc_delay_off == 0) && (wlc_is_non_delay_mpc(wlc)));
+	return (wlc->mpc_delay_off == 0) && (wlc_is_non_delay_mpc(wlc));
 }
 
 void wlc_radio_mpc_upd(wlc_info_t *wlc)
@@ -2593,7 +2593,7 @@ bool wlc_radio_monitor_stop(wlc_info_t *
 
 	wlc->radio_monitor = FALSE;
 	wlc_pllreq(wlc, FALSE, WLC_PLLREQ_RADIO_MON);
-	return (wl_del_timer(wlc->wl, wlc->radio_timer));
+	return wl_del_timer(wlc->wl, wlc->radio_timer);
 }
 
 /* bring the driver down, but don't reset hardware */
@@ -2631,10 +2631,10 @@ static bool wlc_tx_prec_map_verify(wlc_i
 			return TRUE;
 	}
 
-	return (WLC_TX_FIFO_CHECK(wlc, TX_AC_BK_FIFO)
+	return WLC_TX_FIFO_CHECK(wlc, TX_AC_BK_FIFO)
 		&& WLC_TX_FIFO_CHECK(wlc, TX_AC_BE_FIFO)
 		&& WLC_TX_FIFO_CHECK(wlc, TX_AC_VI_FIFO)
-		&& WLC_TX_FIFO_CHECK(wlc, TX_AC_VO_FIFO));
+		&& WLC_TX_FIFO_CHECK(wlc, TX_AC_VO_FIFO);
 }
 #endif				/* BCMDBG */
 
@@ -2845,7 +2845,7 @@ int BCMINITFN(wlc_up) (wlc_info_t *wlc)
 	/* ensure LDPC config is in sync */
 	wlc_ht_update_ldpc(wlc, wlc->stf->ldpc);
 
-	return (0);
+	return 0;
 }
 
 /* Initialize the base precedence map for dequeueing from txq based on WME settings */
@@ -2897,7 +2897,7 @@ uint BCMUNINITFN(wlc_down) (wlc_info_t *
 		return 0;
 	}
 	if (!wlc->pub->up)
-		return (callbacks);
+		return callbacks;
 
 	/* in between, mpc could try to bring down again.. */
 	wlc->going_down = TRUE;
@@ -2966,7 +2966,7 @@ uint BCMUNINITFN(wlc_down) (wlc_info_t *
 		ASSERT(wlc->pkt_callback[i].fn == NULL);
 #endif
 	wlc->going_down = FALSE;
-	return (callbacks);
+	return callbacks;
 }
 
 /* Set the current gmode configuration */
@@ -3242,7 +3242,7 @@ static int wlc_set_rateset(wlc_info_t *w
 	      sizeof(wlc_rateset_t));
 	bcopy((char *)&new, (char *)&wlc->bandstate[bandunit]->defrateset,
 	      sizeof(wlc_rateset_t));
-	return (0);
+	return 0;
 }
 
 /* simplified integer set interface for common ioctl handler */
@@ -3275,7 +3275,7 @@ static void wlc_ofdm_rateset_war(wlc_inf
 int
 wlc_ioctl(wlc_info_t *wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 {
-	return (_wlc_ioctl(wlc, cmd, arg, len, wlcif));
+	return _wlc_ioctl(wlc, cmd, arg, len, wlcif);
 }
 
 /* common ioctl handler. return: 0=ok, -1=error, positive=particular error */
@@ -4434,7 +4434,7 @@ _wlc_ioctl(wlc_info_t *wlc, int cmd, voi
 		ASSERT(wlc_bmac_taclear(wlc->hw, ta_ok) || !ta_ok);
 #endif
 
-	return (bcmerror);
+	return bcmerror;
 }
 
 #if defined(BCMDBG)
@@ -4443,17 +4443,17 @@ int wlc_iocregchk(wlc_info_t *wlc, uint
 {
 	/* if band is specified, it must be the current band */
 	if ((band != WLC_BAND_AUTO) && (band != (uint) wlc->band->bandtype))
-		return (BCME_BADBAND);
+		return BCME_BADBAND;
 
 	/* if multiband and band is not specified, band must be locked */
 	if ((band == WLC_BAND_AUTO) && IS_MBAND_UNLOCKED(wlc))
-		return (BCME_NOTBANDLOCKED);
+		return BCME_NOTBANDLOCKED;
 
 	/* must have core clocks */
 	if (!wlc->clk)
-		return (BCME_NOCLK);
+		return BCME_NOCLK;
 
-	return (0);
+	return 0;
 }
 #endif				/* defined(BCMDBG) */
 
@@ -5073,19 +5073,19 @@ bool wlc_chipmatch(uint16 vendor, uint16
 {
 	if (vendor != VENDOR_BROADCOM) {
 		WL_ERROR(("wlc_chipmatch: unknown vendor id %04x\n", vendor));
-		return (FALSE);
+		return FALSE;
 	}
 
 	if ((device == BCM43224_D11N_ID) || (device == BCM43225_D11N2G_ID))
-		return (TRUE);
+		return TRUE;
 
 	if (device == BCM4313_D11N2G_ID)
-		return (TRUE);
+		return TRUE;
 	if ((device == BCM43236_D11N_ID) || (device == BCM43236_D11N2G_ID))
-		return (TRUE);
+		return TRUE;
 
 	WL_ERROR(("wlc_chipmatch: unknown device id %04x\n", device));
-	return (FALSE);
+	return FALSE;
 }
 
 #if defined(BCMDBG)
@@ -5489,7 +5489,7 @@ int wlc_format_ssid(char *buf, const uch
 
 uint16 wlc_rate_shm_offset(wlc_info_t *wlc, uint8 rate)
 {
-	return (wlc_bmac_rate_shm_offset(wlc->hw, rate));
+	return wlc_bmac_rate_shm_offset(wlc->hw, rate);
 }
 
 /* Callback for device removed */
@@ -5812,7 +5812,7 @@ wlc_compute_airtime(wlc_info_t *wlc, rat
 
 		/* usec = symbols * usec/symbol */
 		usec = (uint16) (nsyms * APHY_SYMBOL_TIME);
-		return (usec);
+		return usec;
 	} else {
 		switch (mac_rate) {
 		case WLC_RATE_1M:
@@ -5834,7 +5834,7 @@ wlc_compute_airtime(wlc_info_t *wlc, rat
 		}
 	}
 
-	return (usec);
+	return usec;
 }
 
 void BCMFASTPATH
@@ -5981,7 +5981,7 @@ wlc_compute_frame_dur(wlc_info_t *wlc, r
 		    (uint16) wlc_calc_frame_time(wlc, rate, preamble_type,
 						 next_frag_len);
 	}
-	return (dur);
+	return dur;
 }
 
 /* wlc_compute_rtscts_dur()
@@ -6024,7 +6024,7 @@ wlc_compute_rtscts_dur(wlc_info_t *wlc,
 		dur +=
 		    (uint16) wlc_calc_ack_time(wlc, frame_rate,
 					       frame_preamble_type);
-	return (dur);
+	return dur;
 }
 
 static bool wlc_phy_rspec_check(wlc_info_t *wlc, uint16 bw, ratespec_t rspec)
@@ -7003,7 +7003,7 @@ static void *wlc_15420war(wlc_info_t *wl
 
 	if ((D11REV_IS(wlc->pub->corerev, 4))
 	    || (D11REV_GT(wlc->pub->corerev, 6)))
-		return (NULL);
+		return NULL;
 
 	di = wlc->hw->di[queue];
 	ASSERT(di != NULL);
@@ -7021,7 +7021,7 @@ static void *wlc_15420war(wlc_info_t *wl
 			WL_ERROR(("wl%d: %s: dma_txreset[%d]: cannot stop dma\n", wlc->pub->unit, __func__, queue));
 		dma_txinit(di);
 	}
-	return (p);
+	return p;
 }
 
 static void wlc_war16165(wlc_info_t *wlc, bool tx)
@@ -7526,7 +7526,7 @@ char *print_fk(uint16 fk)
 		str = "Unknown!!";
 		break;
 	}
-	return (str);
+	return str;
 }
 
 static void
@@ -8079,7 +8079,7 @@ bool wlc_valid_rate(wlc_info_t *wlc, rat
 		hw_rateset = &wlc->bandstate[OTHERBANDUNIT(wlc)]->hw_rateset;
 	} else {
 		/* other band specified and we are a single band device */
-		return (FALSE);
+		return FALSE;
 	}
 
 	/* check if this is a mimo rate */
@@ -8092,13 +8092,13 @@ bool wlc_valid_rate(wlc_info_t *wlc, rat
 
 	for (i = 0; i < hw_rateset->count; i++)
 		if (hw_rateset->rates[i] == RSPEC2RATE(rspec))
-			return (TRUE);
+			return TRUE;
  error:
 	if (verbose) {
 		WL_ERROR(("wl%d: wlc_valid_rate: rate spec 0x%x not in hw_rateset\n", wlc->pub->unit, rspec));
 	}
 
-	return (FALSE);
+	return FALSE;
 }
 
 static void wlc_update_mimo_band_bwcap(wlc_info_t *wlc, uint8 bwcap)
--- a/drivers/staging/brcm80211/util/aiutils.c
+++ b/drivers/staging/brcm80211/util/aiutils.c
@@ -319,7 +319,7 @@ void *ai_setcoreidx(si_t *sih, uint core
 	void *regs;
 
 	if (coreidx >= sii->numcores)
-		return (NULL);
+		return NULL;
 
 	/*
 	 * If the user has provided an interrupt mask enabled function,
@@ -427,7 +427,7 @@ uint ai_flag(si_t *sih)
 	}
 	ai = sii->curwrap;
 
-	return (R_REG(sii->osh, &ai->oobselouta30) & 0x1f);
+	return R_REG(sii->osh, &ai->oobselouta30) & 0x1f;
 }
 
 void ai_setint(si_t *sih, int siflag)
@@ -449,7 +449,7 @@ uint ai_corevendor(si_t *sih)
 
 	sii = SI_INFO(sih);
 	cia = sii->cia[sii->curidx];
-	return ((cia & CIA_MFG_MASK) >> CIA_MFG_SHIFT);
+	return (cia & CIA_MFG_MASK) >> CIA_MFG_SHIFT;
 }
 
 uint ai_corerev(si_t *sih)
@@ -459,7 +459,7 @@ uint ai_corerev(si_t *sih)
 
 	sii = SI_INFO(sih);
 	cib = sii->cib[sii->curidx];
-	return ((cib & CIB_REV_MASK) >> CIB_REV_SHIFT);
+	return (cib & CIB_REV_MASK) >> CIB_REV_SHIFT;
 }
 
 bool ai_iscoreup(si_t *sih)
@@ -568,7 +568,7 @@ uint ai_corereg(si_t *sih, uint coreidx,
 		INTR_RESTORE(sii, intr_val);
 	}
 
-	return (w);
+	return w;
 }
 
 void ai_core_disable(si_t *sih, uint32 bits)
--- a/drivers/staging/brcm80211/util/bcmotp.c
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -553,13 +553,13 @@ static otp_fn_t ipxotp_fn = {
 static int hndotp_status(void *oh)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
-	return ((int)(oi->hwprot | oi->signvalid));
+	return (int)(oi->hwprot | oi->signvalid);
 }
 
 static int hndotp_size(void *oh)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
-	return ((int)(oi->size));
+	return (int)(oi->size);
 }
 
 static uint16 hndotp_otpr(void *oh, chipcregs_t *cc, uint wn)
@@ -574,7 +574,7 @@ static uint16 hndotp_otpr(void *oh, chip
 	osh = si_osh(oi->sih);
 
 	ptr = (volatile uint16 *)((volatile char *)cc + CC_SROM_OTP);
-	return (R_REG(osh, &ptr[wn]));
+	return R_REG(osh, &ptr[wn]);
 }
 
 static uint16 hndotp_otproff(void *oh, chipcregs_t *cc, int woff)
@@ -591,7 +591,7 @@ static uint16 hndotp_otproff(void *oh, c
 
 	ptr = (volatile uint16 *)((volatile char *)cc + CC_SROM_OTP);
 
-	return (R_REG(osh, &ptr[(oi->size / 2) + woff]));
+	return R_REG(osh, &ptr[(oi->size / 2) + woff]);
 }
 
 static uint16 hndotp_read_bit(void *oh, chipcregs_t *cc, uint idx)
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -161,7 +161,7 @@ BCMATTACHFN(srom_var_init) (si_t *sih, u
 
 	ASSERT(bustype == BUSTYPE(bustype));
 	if (vars == NULL || count == NULL)
-		return (0);
+		return 0;
 
 	*vars = NULL;
 	*count = 0;
@@ -174,7 +174,7 @@ BCMATTACHFN(srom_var_init) (si_t *sih, u
 	case PCI_BUS:
 		ASSERT(curmap != NULL);
 		if (curmap == NULL)
-			return (-1);
+			return -1;
 
 		return initvars_srom_pci(sih, curmap, vars, count);
 
@@ -186,7 +186,7 @@ BCMATTACHFN(srom_var_init) (si_t *sih, u
 	default:
 		ASSERT(0);
 	}
-	return (-1);
+	return -1;
 }
 
 /* support only 16-bit word read from srom */
@@ -2027,7 +2027,7 @@ BCMATTACHFN(initvars_cis_sdio) (osl_t *o
 	while (fn-- > 0)
 		MFREE(osh, cis[fn], SBSDIO_CIS_SIZE_LIMIT);
 
-	return (rc);
+	return rc;
 }
 
 /* set SDIO sprom command register */
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -100,7 +100,7 @@ uint BCMFASTPATH pkttotlen(osl_t *osh, v
 	total = 0;
 	for (; p; p = PKTNEXT(p))
 		total += PKTLEN(p);
-	return (total);
+	return total;
 }
 
 /* return the last buffer of chained pkt */
@@ -108,7 +108,7 @@ void *pktlast(osl_t *osh, void *p)
 {
 	for (; PKTNEXT(p); p = PKTNEXT(p)) ;
 
-	return (p);
+	return p;
 }
 
 /* count segments of a chained packet */
@@ -399,7 +399,7 @@ void *pktq_peek(struct pktq *pq, int *pr
 	if (prec_out)
 		*prec_out = prec;
 
-	return (pq->q[prec].head);
+	return pq->q[prec].head;
 }
 
 void *pktq_peek_tail(struct pktq *pq, int *prec_out)
@@ -416,7 +416,7 @@ void *pktq_peek_tail(struct pktq *pq, in
 	if (prec_out)
 		*prec_out = prec;
 
-	return (pq->q[prec].tail);
+	return pq->q[prec].tail;
 }
 
 void pktq_flush(osl_t *osh, struct pktq *pq, bool dir, ifpkt_cb_t fn, int arg)
@@ -578,7 +578,7 @@ ulong BCMROMFN(bcm_strtoul) (char *cp, c
 	if (endp)
 		*endp = (char *)cp;
 
-	return (result);
+	return result;
 }
 
 int BCMROMFN(bcm_atoi) (char *s)
@@ -593,15 +593,15 @@ char *BCMROMFN(bcmstrstr) (char *haystac
 	int i;
 
 	if ((haystack == NULL) || (needle == NULL))
-		return (haystack);
+		return haystack;
 
 	nlen = strlen(needle);
 	len = strlen(haystack) - nlen + 1;
 
 	for (i = 0; i < len; i++)
 		if (memcmp(needle, &haystack[i], nlen) == 0)
-			return (&haystack[i]);
-	return (NULL);
+			return &haystack[i];
+	return NULL;
 }
 
 char *BCMROMFN(bcmstrcat) (char *dest, const char *src)
@@ -612,7 +612,7 @@ char *BCMROMFN(bcmstrcat) (char *dest, c
 
 	while ((*p++ = *src++) != '\0') ;
 
-	return (dest);
+	return dest;
 }
 
 char *BCMROMFN(bcmstrncat) (char *dest, const char *src, uint size)
@@ -625,7 +625,7 @@ char *BCMROMFN(bcmstrncat) (char *dest,
 
 	while (p != endp && (*p++ = *src++) != '\0') ;
 
-	return (dest);
+	return dest;
 }
 
 /****************************************************************************
@@ -793,13 +793,13 @@ int BCMROMFN(bcm_ether_atoe) (char *p, s
 			break;
 	}
 
-	return (i == 6);
+	return i == 6;
 }
 
 char *bcm_ether_ntoa(const struct ether_addr *ea, char *buf)
 {
 	snprintf(buf, 18, "%pM", ea->octet);
-	return (buf);
+	return buf;
 }
 
 void bcm_mdelay(uint ms)
@@ -830,13 +830,13 @@ char *getvar(char *vars, const char *nam
 	/* first look in vars[] */
 	for (s = vars; s && *s;) {
 		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
-			return (&s[len + 1]);
+			return &s[len + 1];
 
 		while (*s++) ;
 	}
 
 	/* then query nvram */
-	return (nvram_get(name));
+	return nvram_get(name);
 }
 
 /*
@@ -848,9 +848,9 @@ int getintvar(char *vars, const char *na
 	char *val;
 
 	if ((val = getvar(vars, name)) == NULL)
-		return (0);
+		return 0;
 
-	return (bcm_strtoul(val, NULL, 0));
+	return bcm_strtoul(val, NULL, 0);
 }
 
 int getintvararray(char *vars, const char *name, uint8 index)
@@ -860,7 +860,7 @@ int getintvararray(char *vars, const cha
 	int val = 0;
 
 	if ((buf = getvar(vars, name)) == NULL) {
-		return (0);
+		return 0;
 	}
 
 	/* table values are always separated by "," or " " */
@@ -891,7 +891,7 @@ static int findmatch(char *string, char
 		string = c + 1;
 	}
 
-	return (!strcmp(string, name));
+	return !strcmp(string, name);
 }
 
 /* Return gpio pin number assigned to the named pin
@@ -1301,7 +1301,7 @@ bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (voi
 
 		/* validate remaining totlen */
 		if ((elt->id == key) && (totlen >= (len + 2)))
-			return (elt);
+			return elt;
 
 		elt = (bcm_tlv_t *) ((uint8 *) elt + (len + 2));
 		totlen -= (len + 2);
@@ -1331,11 +1331,11 @@ bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tl
 
 		/* Punt if we start seeing IDs > than target key */
 		if (id > key)
-			return (NULL);
+			return NULL;
 
 		/* validate remaining totlen */
 		if ((id == key) && (totlen >= (len + 2)))
-			return (elt);
+			return elt;
 
 		elt = (bcm_tlv_t *) ((uint8 *) elt + (len + 2));
 		totlen -= (len + 2);
@@ -1496,7 +1496,7 @@ char *bcm_brev_str(uint32 brev, char *bu
 		snprintf(buf, 8, "%c%03x",
 			 ((brev & 0xf000) == 0x1000) ? 'P' : 'A', brev & 0xfff);
 
-	return (buf);
+	return buf;
 }
 
 #define BUFSIZE_TODUMP_ATONCE 512	/* Buffer size */
@@ -1621,7 +1621,7 @@ uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 q
 	/* return the mW value scaled down to the correct factor of 10,
 	 * adding in factor/2 to get proper rounding.
 	 */
-	return ((nqdBm_to_mW_map[idx] + factor / 2) / factor);
+	return (nqdBm_to_mW_map[idx] + factor / 2) / factor;
 }
 
 uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw)
@@ -1652,7 +1652,7 @@ uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 m
 
 	qdbm += (uint8) offset;
 
-	return (qdbm);
+	return qdbm;
 }
 
 uint BCMROMFN(bcm_bitcount) (uint8 *bitmap, uint length)
@@ -1719,7 +1719,7 @@ int bcm_cmp_bytes(uchar *arg1, uchar *ar
 
 	for (i = nbytes - 1; i >= 0; i--) {
 		if (arg1[i] != arg2[i])
-			return (arg1[i] - arg2[i]);
+			return arg1[i] - arg2[i];
 	}
 	return 0;
 }
--- a/drivers/staging/brcm80211/util/bcmwifi.c
+++ b/drivers/staging/brcm80211/util/bcmwifi.c
@@ -79,7 +79,7 @@ char *wf_chspec_ntoa(chanspec_t chspec,
 
 	/* Outputs a max of 6 chars including '\0'  */
 	snprintf(buf, 6, "%d%s%s%s", channel, band, bw, sb);
-	return (buf);
+	return buf;
 }
 
 /* given a chanspec string, convert to a chanspec.
@@ -145,7 +145,7 @@ chanspec_t wf_chspec_aton(char *a)
 	}
 
  done:
-	return (channel | band | bw | ctl_sb);
+	return channel | band | bw | ctl_sb;
 }
 
 /*
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -368,7 +368,7 @@ hnddma_t *dma_attach(osl_t *osh, char *n
 		printf("dma_attach: out of memory, malloced %d bytes\n",
 		       MALLOCED(osh));
 #endif
-		return (NULL);
+		return NULL;
 	}
 
 	bzero((char *)di, sizeof(dma_info_t));
@@ -560,11 +560,11 @@ hnddma_t *dma_attach(osl_t *osh, char *n
 		}
 	}
 
-	return ((hnddma_t *) di);
+	return (hnddma_t *) di;
 
  fail:
 	_dma_detach(di);
-	return (NULL);
+	return NULL;
 }
 
 /* init the tx or rx descriptor */
@@ -602,7 +602,7 @@ STATIC INLINE uint32 parity32(uint32 dat
 	data ^= data >> 2;
 	data ^= data >> 1;
 
-	return (data & 1);
+	return data & 1;
 }
 
 #define DMA64_DD_PARITY(dd)  parity32((dd)->addrlow ^ (dd)->addrhigh ^ (dd)->ctrl1 ^ (dd)->ctrl2)
@@ -660,7 +660,7 @@ static bool _dma32_addrext(osl_t *osh, d
 	OR_REG(osh, &dma32regs->control, XC_AE);
 	w = R_REG(osh, &dma32regs->control);
 	AND_REG(osh, &dma32regs->control, ~XC_AE);
-	return ((w & XC_AE) == XC_AE);
+	return (w & XC_AE) == XC_AE;
 }
 
 static bool _dma_alloc(dma_info_t *di, uint direction)
@@ -774,9 +774,9 @@ static bool _dma_isaddrext(dma_info_t *d
 		return FALSE;
 	} else if (DMA32_ENAB(di)) {
 		if (di->d32txregs)
-			return (_dma32_addrext(di->osh, di->d32txregs));
+			return _dma32_addrext(di->osh, di->d32txregs);
 		else if (di->d32rxregs)
-			return (_dma32_addrext(di->osh, di->d32rxregs));
+			return _dma32_addrext(di->osh, di->d32rxregs);
 	} else
 		ASSERT(0);
 
@@ -978,7 +978,7 @@ static void *BCMFASTPATH _dma_rx(dma_inf
  next_frame:
 	head = _dma_getnextrxp(di, FALSE);
 	if (head == NULL)
-		return (NULL);
+		return NULL;
 
 	len = ltoh16(*(uint16 *) (PKTDATA(head)));
 	DMA_TRACE(("%s: dma_rx len %d\n", di->name, len));
@@ -1035,7 +1035,7 @@ static void *BCMFASTPATH _dma_rx(dma_inf
 		}
 	}
 
-	return (head);
+	return head;
 }
 
 /* post receive buffers
@@ -1160,7 +1160,7 @@ static void *_dma_peeknexttxp(dma_info_t
 	uint end, i;
 
 	if (di->ntxd == 0)
-		return (NULL);
+		return NULL;
 
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		end =
@@ -1176,9 +1176,9 @@ static void *_dma_peeknexttxp(dma_info_t
 
 	for (i = di->txin; i != end; i = NEXTTXD(i))
 		if (di->txp[i])
-			return (di->txp[i]);
+			return di->txp[i];
 
-	return (NULL);
+	return NULL;
 }
 
 /* like getnextrxp but not take off the ring */
@@ -1187,7 +1187,7 @@ static void *_dma_peeknextrxp(dma_info_t
 	uint end, i;
 
 	if (di->nrxd == 0)
-		return (NULL);
+		return NULL;
 
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		end =
@@ -1203,9 +1203,9 @@ static void *_dma_peeknextrxp(dma_info_t
 
 	for (i = di->rxin; i != end; i = NEXTRXD(i))
 		if (di->rxp[i])
-			return (di->rxp[i]);
+			return di->rxp[i];
 
-	return (NULL);
+	return NULL;
 }
 
 static void _dma_rxreclaim(dma_info_t *di)
@@ -1226,7 +1226,7 @@ static void _dma_rxreclaim(dma_info_t *d
 static void *BCMFASTPATH _dma_getnextrxp(dma_info_t *di, bool forceall)
 {
 	if (di->nrxd == 0)
-		return (NULL);
+		return NULL;
 
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		return dma64_getnextrxp(di, forceall);
@@ -1307,7 +1307,7 @@ static uint _dma_ctrlflags(dma_info_t *d
 
 	if (di == NULL) {
 		DMA_ERROR(("%s: _dma_ctrlflags: NULL dma handle\n", di->name));
-		return (0);
+		return 0;
 	}
 
 	ASSERT((flags & ~mask) == 0);
@@ -1350,18 +1350,18 @@ static uint _dma_ctrlflags(dma_info_t *d
 
 	di->hnddma.dmactrlflags = dmactrlflags;
 
-	return (dmactrlflags);
+	return dmactrlflags;
 }
 
 /* get the address of the var in order to change later */
 static uintptr _dma_getvar(dma_info_t *di, const char *name)
 {
 	if (!strcmp(name, "&txavail"))
-		return ((uintptr) & (di->hnddma.txavail));
+		return (uintptr) & (di->hnddma.txavail);
 	else {
 		ASSERT(0);
 	}
-	return (0);
+	return 0;
 }
 
 void dma_txpioloopback(osl_t *osh, dma32regs_t *regs)
@@ -1378,7 +1378,7 @@ uint8 dma_align_sizetobits(uint size)
 	while (size >>= 1) {
 		bitpos++;
 	}
-	return (bitpos);
+	return bitpos;
 }
 
 /* This function ensures that the DMA descriptor ring will not get allocated
@@ -1441,7 +1441,7 @@ static bool dma32_txenabled(dma_info_t *
 
 	/* If the chip is dead, it is not enabled :-) */
 	xc = R_REG(di->osh, &di->d32txregs->control);
-	return ((xc != 0xffffffff) && (xc & XC_XE));
+	return (xc != 0xffffffff) && (xc & XC_XE);
 }
 
 static void dma32_txsuspend(dma_info_t *di)
@@ -1586,7 +1586,7 @@ static bool dma32_txreset(dma_info_t *di
 	/* wait for the last transaction to complete */
 	OSL_DELAY(300);
 
-	return (status == XS_XS_DISABLED);
+	return status == XS_XS_DISABLED;
 }
 
 static bool dma32_rxidle(dma_info_t *di)
@@ -1612,7 +1612,7 @@ static bool dma32_rxreset(dma_info_t *di
 				   &di->d32rxregs->status) & RS_RS_MASK)) !=
 		  RS_RS_DISABLED), 10000);
 
-	return (status == RS_RS_DISABLED);
+	return status == RS_RS_DISABLED;
 }
 
 static bool dma32_rxenabled(dma_info_t *di)
@@ -1620,7 +1620,7 @@ static bool dma32_rxenabled(dma_info_t *
 	uint32 rc;
 
 	rc = R_REG(di->osh, &di->d32rxregs->control);
-	return ((rc != 0xffffffff) && (rc & RC_RE));
+	return (rc != 0xffffffff) && (rc & RC_RE);
 }
 
 static bool dma32_txsuspendedidle(dma_info_t *di)
@@ -1752,14 +1752,14 @@ static int dma32_txfast(dma_info_t *di,
 	/* tx flow control */
 	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
-	return (0);
+	return 0;
 
  outoftxd:
 	DMA_ERROR(("%s: dma_txfast: out of txds\n", di->name));
 	PKTFREE(di->osh, p0, TRUE);
 	di->hnddma.txavail = 0;
 	di->hnddma.txnobuf++;
-	return (-1);
+	return -1;
 }
 
 /*
@@ -1785,7 +1785,7 @@ static void *dma32_getnexttxp(dma_info_t
 		    "transfered")));
 
 	if (di->ntxd == 0)
-		return (NULL);
+		return NULL;
 
 	txp = NULL;
 
@@ -1850,11 +1850,11 @@ static void *dma32_getnexttxp(dma_info_t
 	/* tx flow control */
 	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
-	return (txp);
+	return txp;
 
  bogus:
 	DMA_NONE(("dma_getnexttxp: bogus curr: start %d end %d txout %d force %d\n", start, end, di->txout, forceall));
-	return (NULL);
+	return NULL;
 }
 
 static void *dma32_getnextrxp(dma_info_t *di, bool forceall)
@@ -1869,14 +1869,14 @@ static void *dma32_getnextrxp(dma_info_t
 
 	/* return if no packets posted */
 	if (i == di->rxout)
-		return (NULL);
+		return NULL;
 
 	curr =
 	    B2I(R_REG(di->osh, &di->d32rxregs->status) & RS_CD_MASK, dma32dd_t);
 
 	/* ignore curr if forceall */
 	if (!forceall && (i == curr))
-		return (NULL);
+		return NULL;
 
 	/* get the packet pointer that corresponds to the rx descriptor */
 	rxp = di->rxp[i];
@@ -1895,7 +1895,7 @@ static void *dma32_getnextrxp(dma_info_t
 
 	di->rxin = NEXTRXD(i);
 
-	return (rxp);
+	return rxp;
 }
 
 /*
@@ -2009,7 +2009,7 @@ static bool dma64_txenabled(dma_info_t *
 
 	/* If the chip is dead, it is not enabled :-) */
 	xc = R_REG(di->osh, &di->d64txregs->control);
-	return ((xc != 0xffffffff) && (xc & D64_XC_XE));
+	return (xc != 0xffffffff) && (xc & D64_XC_XE);
 }
 
 static void dma64_txsuspend(dma_info_t *di)
@@ -2153,7 +2153,7 @@ static bool dma64_txreset(dma_info_t *di
 	/* wait for the last transaction to complete */
 	OSL_DELAY(300);
 
-	return (status == D64_XS0_XS_DISABLED);
+	return status == D64_XS0_XS_DISABLED;
 }
 
 static bool dma64_rxidle(dma_info_t *di)
@@ -2179,7 +2179,7 @@ static bool dma64_rxreset(dma_info_t *di
 		   (R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_RS_MASK))
 		  != D64_RS0_RS_DISABLED), 10000);
 
-	return (status == D64_RS0_RS_DISABLED);
+	return status == D64_RS0_RS_DISABLED;
 }
 
 static bool dma64_rxenabled(dma_info_t *di)
@@ -2187,7 +2187,7 @@ static bool dma64_rxenabled(dma_info_t *
 	uint32 rc;
 
 	rc = R_REG(di->osh, &di->d64rxregs->control);
-	return ((rc != 0xffffffff) && (rc & D64_RC_RE));
+	return (rc != 0xffffffff) && (rc & D64_RC_RE);
 }
 
 static bool dma64_txsuspendedidle(dma_info_t *di)
@@ -2286,13 +2286,13 @@ static int dma64_txunframed(dma_info_t *
 	/* tx flow control */
 	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
-	return (0);
+	return 0;
 
  outoftxd:
 	DMA_ERROR(("%s: %s: out of txds !!!\n", di->name, __func__));
 	di->hnddma.txavail = 0;
 	di->hnddma.txnobuf++;
-	return (-1);
+	return -1;
 }
 
 /* !! tx entry routine
@@ -2404,14 +2404,14 @@ static int BCMFASTPATH dma64_txfast(dma_
 	/* tx flow control */
 	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
-	return (0);
+	return 0;
 
  outoftxd:
 	DMA_ERROR(("%s: dma_txfast: out of txds !!!\n", di->name));
 	PKTFREE(di->osh, p0, TRUE);
 	di->hnddma.txavail = 0;
 	di->hnddma.txnobuf++;
-	return (-1);
+	return -1;
 }
 
 /*
@@ -2437,7 +2437,7 @@ static void *BCMFASTPATH dma64_getnexttx
 		    "transfered")));
 
 	if (di->ntxd == 0)
-		return (NULL);
+		return NULL;
 
 	txp = NULL;
 
@@ -2509,11 +2509,11 @@ static void *BCMFASTPATH dma64_getnexttx
 	/* tx flow control */
 	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 
-	return (txp);
+	return txp;
 
  bogus:
 	DMA_NONE(("dma_getnexttxp: bogus curr: start %d end %d txout %d force %d\n", start, end, di->txout, forceall));
-	return (NULL);
+	return NULL;
 }
 
 static void *BCMFASTPATH dma64_getnextrxp(dma_info_t *di, bool forceall)
@@ -2529,7 +2529,7 @@ static void *BCMFASTPATH dma64_getnextrx
 
 	/* return if no packets posted */
 	if (i == di->rxout)
-		return (NULL);
+		return NULL;
 
 	curr =
 	    B2I(((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_CD_MASK) -
@@ -2537,7 +2537,7 @@ static void *BCMFASTPATH dma64_getnextrx
 
 	/* ignore curr if forceall */
 	if (!forceall && (i == curr))
-		return (NULL);
+		return NULL;
 
 	/* get the packet pointer that corresponds to the rx descriptor */
 	rxp = di->rxp[i];
@@ -2559,7 +2559,7 @@ static void *BCMFASTPATH dma64_getnextrx
 
 	di->rxin = NEXTRXD(i);
 
-	return (rxp);
+	return rxp;
 }
 
 static bool _dma64_addrext(osl_t *osh, dma64regs_t * dma64regs)
@@ -2568,7 +2568,7 @@ static bool _dma64_addrext(osl_t *osh, d
 	OR_REG(osh, &dma64regs->control, D64_XC_AE);
 	w = R_REG(osh, &dma64regs->control);
 	AND_REG(osh, &dma64regs->control, ~D64_XC_AE);
-	return ((w & D64_XC_AE) == D64_XC_AE);
+	return (w & D64_XC_AE) == D64_XC_AE;
 }
 
 /*
@@ -2666,12 +2666,12 @@ uint dma_addrwidth(si_t *sih, void *dmar
 			if ((BUSTYPE(sih->bustype) == SI_BUS) ||
 			    ((BUSTYPE(sih->bustype) == PCI_BUS) &&
 			     (sih->buscoretype == PCIE_CORE_ID)))
-				return (DMADDRWIDTH_64);
+				return DMADDRWIDTH_64;
 
 		/* DMA64 is always 32-bit capable, AE is always TRUE */
 		ASSERT(_dma64_addrext(osh, (dma64regs_t *) dmaregs));
 
-		return (DMADDRWIDTH_32);
+		return DMADDRWIDTH_32;
 	}
 
 	/* Start checking for 32-bit / 30-bit addressing */
@@ -2682,8 +2682,8 @@ uint dma_addrwidth(si_t *sih, void *dmar
 	    ((BUSTYPE(sih->bustype) == PCI_BUS)
 	     && sih->buscoretype == PCIE_CORE_ID)
 	    || (_dma32_addrext(osh, dma32regs)))
-		return (DMADDRWIDTH_32);
+		return DMADDRWIDTH_32;
 
 	/* Fallthru */
-	return (DMADDRWIDTH_30);
+	return DMADDRWIDTH_30;
 }
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -589,7 +589,7 @@ static bool BCMATTACHFN(si_pmu_res_depfl
 static bool BCMATTACHFN(si_pmu_res_depfltr_ncb) (si_t *sih)
 {
 
-	return ((sih->boardflags & BFL_NOCBUCK) != 0);
+	return (sih->boardflags & BFL_NOCBUCK) != 0;
 }
 
 /* TRUE if the power topology uses the PALDO */
@@ -1656,7 +1656,7 @@ BCMINITFN(si_pmu5_clock) (si_t *sih, osl
 	if (CHIPID(sih->chip) == BCM5357_CHIP_ID) {
 		/* Detect failure in clock setting */
 		if ((R_REG(osh, &cc->chipstatus) & 0x40000) != 0) {
-			return (133 * 1000000);
+			return 133 * 1000000;
 		}
 	}
 
@@ -1684,7 +1684,7 @@ BCMINITFN(si_pmu5_clock) (si_t *sih, osl
 		  __func__, p1, p2, ndiv, ndiv, m, div, fc, fc / div));
 
 	/* Return clock in Hertz */
-	return ((fc / div) * 1000000);
+	return (fc / div) * 1000000;
 }
 
 /* query backplane clock frequency */
@@ -2617,7 +2617,7 @@ si_pmu_waitforclk_on_backplane(si_t *sih
 	/* Return to original core */
 	si_setcoreidx(sih, origidx);
 
-	return (R_REG(osh, &cc->pmustatus) & clk);
+	return R_REG(osh, &cc->pmustatus) & clk;
 }
 
 /*
--- a/drivers/staging/brcm80211/util/linux_osl.c
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -187,7 +187,7 @@ void *BCMFASTPATH osl_pktget(osl_t *osh,
 		osh->pub.pktalloced++;
 	}
 
-	return ((void *)skb);
+	return (void *)skb;
 }
 
 /* Free the driver packet. Free the tag if present */
@@ -246,7 +246,7 @@ uint32 osl_pci_read_config(osl_t *osh, u
 		       offset, (PCI_CFG_RETRY - retry));
 #endif				/* BCMDBG */
 
-	return (val);
+	return val;
 }
 
 void osl_pci_write_config(osl_t *osh, uint offset, uint size, uint val)
@@ -315,12 +315,12 @@ void *osl_malloc(osl_t *osh, uint size)
 	if ((addr = kmalloc(size, GFP_ATOMIC)) == NULL) {
 		if (osh)
 			osh->failed++;
-		return (NULL);
+		return NULL;
 	}
 	if (osh)
 		osh->malloced += size;
 
-	return (addr);
+	return addr;
 }
 
 void osl_mfree(osl_t *osh, void *addr, uint size)
@@ -335,18 +335,18 @@ void osl_mfree(osl_t *osh, void *addr, u
 uint osl_malloced(osl_t *osh)
 {
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
-	return (osh->malloced);
+	return osh->malloced;
 }
 
 uint osl_malloc_failed(osl_t *osh)
 {
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
-	return (osh->failed);
+	return osh->failed;
 }
 
 uint osl_dma_consistent_align(void)
 {
-	return (PAGE_SIZE);
+	return PAGE_SIZE;
 }
 
 void *osl_dma_alloc_consistent(osl_t *osh, uint size, uint16 align_bits,
@@ -359,7 +359,7 @@ void *osl_dma_alloc_consistent(osl_t *os
 		size += align;
 	*alloced = size;
 
-	return (pci_alloc_consistent(osh->pdev, size, (dma_addr_t *) pap));
+	return pci_alloc_consistent(osh->pdev, size, (dma_addr_t *) pap);
 }
 
 void osl_dma_free_consistent(osl_t *osh, void *va, uint size, ulong pa)
@@ -375,7 +375,7 @@ uint BCMFASTPATH osl_dma_map(osl_t *osh,
 
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 	dir = (direction == DMA_TX) ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE;
-	return (pci_map_single(osh->pdev, va, size, dir));
+	return pci_map_single(osh->pdev, va, size, dir);
 }
 
 void BCMFASTPATH osl_dma_unmap(osl_t *osh, uint pa, uint size, int direction)
@@ -461,7 +461,7 @@ void *osl_pktdup(osl_t *osh, void *skb)
 
 	/* Increment the packet counter */
 	osh->pub.pktalloced++;
-	return (p);
+	return p;
 }
 
 #ifdef BCMSDIO
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -116,7 +116,7 @@ void *pcicore_init(si_t *sih, osl_t *osh
 	if ((pi = MALLOC(osh, sizeof(pcicore_info_t))) == NULL) {
 		PCI_ERROR(("pci_attach: malloc failed! malloced %d bytes\n",
 			   MALLOCED(osh)));
-		return (NULL);
+		return NULL;
 	}
 
 	bzero(pi, sizeof(pcicore_info_t));
@@ -733,7 +733,7 @@ bool pcicore_pmecap_fast(osl_t *osh)
 
 	pmecap = OSL_PCI_READ_CONFIG(osh, cap_ptr, sizeof(uint32));
 
-	return ((pmecap & PME_CAP_PM_STATES) != 0);
+	return (pmecap & PME_CAP_PM_STATES) != 0;
 }
 
 /* return TRUE if PM capability exists in the pci config space
@@ -762,7 +762,7 @@ static bool pcicore_pmecap(pcicore_info_
 		pi->pmecap = (pmecap & PME_CAP_PM_STATES) != 0;
 	}
 
-	return (pi->pmecap);
+	return pi->pmecap;
 }
 
 /* Enable PME generation */
--- a/drivers/staging/brcm80211/util/nvram/nvram_ro.c
+++ b/drivers/staging/brcm80211/util/nvram/nvram_ro.c
@@ -131,7 +131,7 @@ static char *findvar(char *vars, char *l
 
 	for (s = vars; (s < lim) && *s;) {
 		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
-			return (&s[len + 1]);
+			return &s[len + 1];
 
 		while (*s++) ;
 	}
--- a/drivers/staging/brcm80211/util/qmath.c
+++ b/drivers/staging/brcm80211/util/qmath.c
@@ -43,7 +43,7 @@ the most of qmath functions can be repla
 */
 int32 qm_mul321616(int16 op1, int16 op2)
 {
-	return ((int32) (op1) * (int32) (op2));
+	return (int32) (op1) * (int32) (op2);
 }
 
 /*
@@ -55,7 +55,7 @@ int16 qm_mul16(int16 op1, int16 op2)
 {
 	int32 result;
 	result = ((int32) (op1) * (int32) (op2));
-	return ((int16) (result >> 16));
+	return (int16) (result >> 16);
 }
 
 /*
@@ -101,7 +101,7 @@ int16 qm_muls16(int16 op1, int16 op2)
 	} else {
 		result = ((int32) (op1) * (int32) (op2));
 	}
-	return ((int16) (result >> 15));
+	return (int16) (result >> 15);
 }
 
 /*
@@ -311,7 +311,7 @@ int16 qm_div_s(int16 num, int16 denom)
 		}
 	}
 	var_out = (int16) (L_num & 0x7fff);
-	return (var_out);
+	return var_out;
 }
 
 /*
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -91,13 +91,13 @@ si_t *BCMATTACHFN(si_attach) (uint devid
 	if ((sii = MALLOC(osh, sizeof(si_info_t))) == NULL) {
 		SI_ERROR(("si_attach: malloc failed! malloced %d bytes\n",
 			  MALLOCED(osh)));
-		return (NULL);
+		return NULL;
 	}
 
 	if (si_doattach(sii, devid, osh, regs, bustype, sdh, vars, varsz) ==
 	    NULL) {
 		MFREE(osh, sii, sizeof(si_info_t));
-		return (NULL);
+		return NULL;
 	}
 	sii->vars = vars ? *vars : NULL;
 	sii->varsz = varsz ? *varsz : 0;
@@ -465,7 +465,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 	sb_taclear(sih, FALSE);
 #endif				/* BCMDBG */
 
-	return (sii);
+	return sii;
 
  exit:
 	return NULL;
@@ -654,7 +654,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 		si_chipcontrl_epa4331(sih, TRUE);
 	}
 
-	return (sii);
+	return sii;
  exit:
 	if (BUSTYPE(sih->bustype) == PCI_BUS) {
 		if (sii->pch)
@@ -818,7 +818,7 @@ uint si_coreunit(si_t *sih)
 		if (sii->coreid[i] == coreid)
 			coreunit++;
 
-	return (coreunit);
+	return coreunit;
 }
 
 uint si_corevendor(si_t *sih)
@@ -833,7 +833,7 @@ uint si_corevendor(si_t *sih)
 
 bool si_backplane64(si_t *sih)
 {
-	return ((sih->cccaps & CC_CAP_BKPLN64) != 0);
+	return (sih->cccaps & CC_CAP_BKPLN64) != 0;
 }
 
 #ifndef BCMSDIO
@@ -862,11 +862,11 @@ uint si_findcoreidx(si_t *sih, uint core
 	for (i = 0; i < sii->numcores; i++)
 		if (sii->coreid[i] == coreid) {
 			if (found == coreunit)
-				return (i);
+				return i;
 			found++;
 		}
 
-	return (BADIDX);
+	return BADIDX;
 }
 
 /* return list of found cores */
@@ -878,7 +878,7 @@ uint si_corelist(si_t *sih, uint coreid[
 
 	bcopy((uchar *) sii->coreid, (uchar *) coreid,
 	      (sii->numcores * sizeof(uint)));
-	return (sii->numcores);
+	return sii->numcores;
 }
 
 /* return current register mapping */
@@ -889,7 +889,7 @@ void *si_coreregs(si_t *sih)
 	sii = SI_INFO(sih);
 	ASSERT(GOODREGS(sii->curmap));
 
-	return (sii->curmap);
+	return sii->curmap;
 }
 
 /*
@@ -903,7 +903,7 @@ void *si_setcore(si_t *sih, uint coreid,
 
 	idx = si_findcoreidx(sih, coreid, coreunit);
 	if (!GOODIDX(idx))
-		return (NULL);
+		return NULL;
 
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_setcoreidx(sih, idx);
@@ -1154,7 +1154,7 @@ uint32 BCMINITFN(si_clock_rate) (uint32
 		ASSERT((n1 >= 2) && (n1 <= 7));
 		ASSERT((n2 >= 5) && (n2 <= 23));
 	} else if (pll_type == PLL_TYPE5) {
-		return (100000000);
+		return 100000000;
 	} else
 		ASSERT(0);
 	/* PLL types 3 and 7 use BASE2 (25Mhz) */
@@ -1183,17 +1183,17 @@ uint32 BCMINITFN(si_clock_rate) (uint32
 
 		switch (mc) {
 		case CC_MC_BYPASS:
-			return (clock);
+			return clock;
 		case CC_MC_M1:
-			return (clock / m1);
+			return clock / m1;
 		case CC_MC_M1M2:
-			return (clock / (m1 * m2));
+			return clock / (m1 * m2);
 		case CC_MC_M1M2M3:
-			return (clock / (m1 * m2 * m3));
+			return clock / (m1 * m2 * m3);
 		case CC_MC_M1M3:
-			return (clock / (m1 * m3));
+			return clock / (m1 * m3);
 		default:
-			return (0);
+			return 0;
 		}
 	} else {
 		ASSERT(pll_type == PLL_TYPE2);
@@ -1212,7 +1212,7 @@ uint32 BCMINITFN(si_clock_rate) (uint32
 		if ((mc & CC_T2MC_M3BYP) == 0)
 			clock /= m3;
 
-		return (clock);
+		return clock;
 	}
 }
 
@@ -1354,14 +1354,14 @@ static uint si_slowclk_src(si_info_t *si
 		if ((BUSTYPE(sii->pub.bustype) == PCI_BUS) &&
 		    (OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(uint32))
 		     & PCI_CFG_GPIO_SCS))
-			return (SCC_SS_PCI);
+			return SCC_SS_PCI;
 		else
-			return (SCC_SS_XTAL);
+			return SCC_SS_XTAL;
 	} else if (sii->pub.ccrev < 10) {
 		cc = (chipcregs_t *) si_setcoreidx(&sii->pub, sii->curidx);
-		return (R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_SS_MASK);
+		return R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_SS_MASK;
 	} else			/* Insta-clock */
-		return (SCC_SS_XTAL);
+		return SCC_SS_XTAL;
 }
 
 /* return the ILP (slowclock) min or max frequency */
@@ -1378,32 +1378,32 @@ static uint si_slowclk_freq(si_info_t *s
 	slowclk = si_slowclk_src(sii);
 	if (sii->pub.ccrev < 6) {
 		if (slowclk == SCC_SS_PCI)
-			return (max_freq ? (PCIMAXFREQ / 64)
-				: (PCIMINFREQ / 64));
+			return max_freq ? (PCIMAXFREQ / 64)
+				: (PCIMINFREQ / 64);
 		else
-			return (max_freq ? (XTALMAXFREQ / 32)
-				: (XTALMINFREQ / 32));
+			return max_freq ? (XTALMAXFREQ / 32)
+				: (XTALMINFREQ / 32);
 	} else if (sii->pub.ccrev < 10) {
 		div = 4 *
 		    (((R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_CD_MASK) >>
 		      SCC_CD_SHIFT) + 1);
 		if (slowclk == SCC_SS_LPO)
-			return (max_freq ? LPOMAXFREQ : LPOMINFREQ);
+			return max_freq ? LPOMAXFREQ : LPOMINFREQ;
 		else if (slowclk == SCC_SS_XTAL)
-			return (max_freq ? (XTALMAXFREQ / div)
-				: (XTALMINFREQ / div));
+			return max_freq ? (XTALMAXFREQ / div)
+				: (XTALMINFREQ / div);
 		else if (slowclk == SCC_SS_PCI)
-			return (max_freq ? (PCIMAXFREQ / div)
-				: (PCIMINFREQ / div));
+			return max_freq ? (PCIMAXFREQ / div)
+				: (PCIMINFREQ / div);
 		else
 			ASSERT(0);
 	} else {
 		/* Chipc rev 10 is InstaClock */
 		div = R_REG(sii->osh, &cc->system_clk_ctl) >> SYCC_CD_SHIFT;
 		div = 4 * (div + 1);
-		return (max_freq ? XTALMAXFREQ : (XTALMINFREQ / div));
+		return max_freq ? XTALMAXFREQ : (XTALMINFREQ / div);
 	}
-	return (0);
+	return 0;
 }
 
 static void BCMINITFN(si_clkctl_setdelay) (si_info_t *sii, void *chipcregs)
@@ -1524,7 +1524,7 @@ int si_clkctl_xtal(si_t *sih, uint what,
 
 #ifdef BCMSDIO
 	case SDIO_BUS:
-		return (-1);
+		return -1;
 #endif				/* BCMSDIO */
 
 	case PCI_BUS:
@@ -1545,7 +1545,7 @@ int si_clkctl_xtal(si_t *sih, uint what,
 		 * by the value of XTAL_PU which *is* readable via gpioin.
 		 */
 		if (on && (in & PCI_CFG_GPIO_XTAL))
-			return (0);
+			return 0;
 
 		if (what & XTAL)
 			outen |= PCI_CFG_GPIO_XTAL;
@@ -1584,10 +1584,10 @@ int si_clkctl_xtal(si_t *sih, uint what,
 		}
 
 	default:
-		return (-1);
+		return -1;
 	}
 
-	return (0);
+	return 0;
 }
 
 /*
@@ -1609,7 +1609,7 @@ bool si_clkctl_cc(si_t *sih, uint mode)
 		return FALSE;
 
 	if (PCI_FORCEHT(sii))
-		return (mode == CLK_FAST);
+		return mode == CLK_FAST;
 
 	return _si_clkctl_cc(sii, mode);
 }
@@ -1625,7 +1625,7 @@ static bool _si_clkctl_cc(si_info_t *sii
 
 	/* chipcommon cores prior to rev6 don't support dynamic clock control */
 	if (sii->pub.ccrev < 6)
-		return (FALSE);
+		return FALSE;
 
 	/* Chips with ccrev 10 are EOL and they don't have SYCC_HR which we use below */
 	ASSERT(sii->pub.ccrev != 10);
@@ -1699,7 +1699,7 @@ static bool _si_clkctl_cc(si_info_t *sii
 		si_setcoreidx(&sii->pub, origidx);
 		INTR_RESTORE(sii, intr_val);
 	}
-	return (mode == CLK_FAST);
+	return mode == CLK_FAST;
 }
 
 /* Build device path. Support SI, PCI, and JTAG for now. */
@@ -1752,26 +1752,26 @@ char *BCMATTACHFN(si_getdevpathvar) (si_
 
 	si_devpathvar(sih, varname, sizeof(varname), name);
 
-	return (getvar(NULL, varname));
+	return getvar(NULL, varname);
 }
 
 /* Get a variable, but only if it has a devpath prefix */
 int BCMATTACHFN(si_getdevpathintvar) (si_t *sih, const char *name)
 {
 #if defined(BCMBUSTYPE) && (BCMBUSTYPE == SI_BUS)
-	return (getintvar(NULL, name));
+	return getintvar(NULL, name);
 #else
 	char varname[SI_DEVPATH_BUFSZ + 32];
 
 	si_devpathvar(sih, varname, sizeof(varname), name);
 
-	return (getintvar(NULL, varname));
+	return getintvar(NULL, varname);
 #endif
 }
 
 char *si_getnvramflvar(si_t *sih, const char *name)
 {
-	return (getvar(NULL, name));
+	return getvar(NULL, name);
 }
 
 /* Concatenate the dev path with a varname into the given 'var' buffer
@@ -1923,7 +1923,7 @@ bool BCMATTACHFN(si_pci_war16165) (si_t
 
 	sii = SI_INFO(sih);
 
-	return (PCI(sii) && (sih->buscorerev <= 10));
+	return PCI(sii) && (sih->buscorerev <= 10);
 }
 
 /* Disable pcie_war_ovr for some platforms (sigh!)
@@ -2144,7 +2144,7 @@ int si_pci_fixcfg(si_t *sih)
 /* change logical "focus" to the gpio core for optimized access */
 void *si_gpiosetcore(si_t *sih)
 {
-	return (si_setcoreidx(sih, SI_CC_IDX));
+	return si_setcoreidx(sih, SI_CC_IDX);
 }
 
 /* mask&set gpiocontrol bits */
@@ -2165,7 +2165,7 @@ uint32 si_gpiocontrol(si_t *sih, uint32
 	}
 
 	regoff = OFFSETOF(chipcregs_t, gpiocontrol);
-	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
+	return si_corereg(sih, SI_CC_IDX, regoff, mask, val);
 }
 
 /* mask&set gpio output enable bits */
@@ -2186,7 +2186,7 @@ uint32 si_gpioouten(si_t *sih, uint32 ma
 	}
 
 	regoff = OFFSETOF(chipcregs_t, gpioouten);
-	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
+	return si_corereg(sih, SI_CC_IDX, regoff, mask, val);
 }
 
 /* mask&set gpio output bits */
@@ -2207,7 +2207,7 @@ uint32 si_gpioout(si_t *sih, uint32 mask
 	}
 
 	regoff = OFFSETOF(chipcregs_t, gpioout);
-	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
+	return si_corereg(sih, SI_CC_IDX, regoff, mask, val);
 }
 
 /* reserve one gpio */
@@ -2286,7 +2286,7 @@ uint32 si_gpioin(si_t *sih)
 	regoff = 0;
 
 	regoff = OFFSETOF(chipcregs_t, gpioin);
-	return (si_corereg(sih, SI_CC_IDX, regoff, 0, 0));
+	return si_corereg(sih, SI_CC_IDX, regoff, 0, 0);
 }
 
 /* mask&set gpio interrupt polarity bits */
@@ -2306,7 +2306,7 @@ uint32 si_gpiointpolarity(si_t *sih, uin
 	}
 
 	regoff = OFFSETOF(chipcregs_t, gpiointpolarity);
-	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
+	return si_corereg(sih, SI_CC_IDX, regoff, mask, val);
 }
 
 /* mask&set gpio interrupt mask bits */
@@ -2326,7 +2326,7 @@ uint32 si_gpiointmask(si_t *sih, uint32
 	}
 
 	regoff = OFFSETOF(chipcregs_t, gpiointmask);
-	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
+	return si_corereg(sih, SI_CC_IDX, regoff, mask, val);
 }
 
 /* assign the gpio to an led */
@@ -2339,9 +2339,9 @@ uint32 si_gpioled(si_t *sih, uint32 mask
 		return 0xffffffff;
 
 	/* gpio led powersave reg */
-	return (si_corereg
+	return si_corereg
 		(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiotimeroutmask), mask,
-		 val));
+		 val);
 }
 
 /* mask&set gpio timer val */
@@ -2354,9 +2354,9 @@ uint32 si_gpiotimerval(si_t *sih, uint32
 	if (sih->ccrev < 16)
 		return 0xffffffff;
 
-	return (si_corereg(sih, SI_CC_IDX,
+	return si_corereg(sih, SI_CC_IDX,
 			   OFFSETOF(chipcregs_t, gpiotimerval), mask,
-			   gpiotimerval));
+			   gpiotimerval);
 }
 
 uint32 si_gpiopull(si_t *sih, bool updown, uint32 mask, uint32 val)
@@ -2371,7 +2371,7 @@ uint32 si_gpiopull(si_t *sih, bool updow
 	offs =
 	    (updown ? OFFSETOF(chipcregs_t, gpiopulldown) :
 	     OFFSETOF(chipcregs_t, gpiopullup));
-	return (si_corereg(sih, SI_CC_IDX, offs, mask, val));
+	return si_corereg(sih, SI_CC_IDX, offs, mask, val);
 }
 
 uint32 si_gpioevent(si_t *sih, uint regtype, uint32 mask, uint32 val)
@@ -2392,7 +2392,7 @@ uint32 si_gpioevent(si_t *sih, uint regt
 	else
 		return 0xffffffff;
 
-	return (si_corereg(sih, SI_CC_IDX, offs, mask, val));
+	return si_corereg(sih, SI_CC_IDX, offs, mask, val);
 }
 
 void *BCMATTACHFN(si_gpio_handler_register) (si_t *sih, uint32 event,
@@ -2485,8 +2485,8 @@ uint32 si_gpio_int_enable(si_t *sih, boo
 		return 0xffffffff;
 
 	offs = OFFSETOF(chipcregs_t, intmask);
-	return (si_corereg
-		(sih, SI_CC_IDX, offs, CI_GPIO, (enable ? CI_GPIO : 0)));
+	return si_corereg
+		(sih, SI_CC_IDX, offs, CI_GPIO, (enable ? CI_GPIO : 0));
 }
 
 /* Return the size of the specified SOCRAM bank */
@@ -2789,7 +2789,7 @@ bool si_is_sprom_available(si_t *sih)
 		cc = si_setcoreidx(sih, SI_CC_IDX);
 		sromctrl = R_REG(sii->osh, &cc->sromcontrol);
 		si_setcoreidx(sih, origidx);
-		return (sromctrl & SRC_PRESENT);
+		return sromctrl & SRC_PRESENT;
 	}
 
 	switch (CHIPID(sih->chip)) {
@@ -2820,9 +2820,9 @@ bool si_is_otp_disabled(si_t *sih)
 		return (sih->chipst & CST4319_SPROM_OTP_SEL_MASK) ==
 		    CST4319_OTP_PWRDN;
 	case BCM4336_CHIP_ID:
-		return ((sih->chipst & CST4336_OTP_PRESENT) == 0);
+		return (sih->chipst & CST4336_OTP_PRESENT) == 0;
 	case BCM4330_CHIP_ID:
-		return ((sih->chipst & CST4330_OTP_PRESENT) == 0);
+		return (sih->chipst & CST4330_OTP_PRESENT) == 0;
 	case BCM4313_CHIP_ID:
 		return (sih->chipst & CST4313_OTP_PRESENT) == 0;
 		/* These chips always have their OTP on */

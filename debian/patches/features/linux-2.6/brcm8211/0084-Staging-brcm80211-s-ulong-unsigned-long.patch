commit 3deea9049e161965fe3caa2ae1f5f0bc96643465
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 5 11:15:47 2010 -0700

    Staging: brcm80211: s/ulong/unsigned long/
    
    This changes the usage everywhere in the driver, and removes
    the definition as it should no longer be used anywhere.
    
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Henry Ptasinski <henryp@broadcom.com>
    Cc: Nohee Ko <noheek@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_linux.c
@@ -157,7 +157,7 @@ int bcmsdh_probe(struct device *dev)
 {
 	osl_t *osh = NULL;
 	bcmsdh_hc_t *sdhc = NULL;
-	ulong regs = 0;
+	unsigned long regs = 0;
 	bcmsdh_info_t *sdh = NULL;
 #if !defined(BCMLXSDMMC) && defined(BCMPLATFORM_BUS)
 	struct platform_device *pdev;
@@ -354,7 +354,7 @@ bcmsdh_pci_probe(struct pci_dev *pdev, c
 {
 	osl_t *osh = NULL;
 	bcmsdh_hc_t *sdhc = NULL;
-	ulong regs;
+	unsigned long regs;
 	bcmsdh_info_t *sdh = NULL;
 	int rc;
 
--- a/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmsdh_sdmmc_linux.c
@@ -174,7 +174,7 @@ void sdioh_sdmmc_osfree(sdioh_info_t *sd
 /* Interrupt enable/disable */
 SDIOH_API_RC sdioh_interrupt_set(sdioh_info_t *sd, bool enable)
 {
-	ulong flags;
+	unsigned long flags;
 	struct sdos_info *sdos;
 
 	sd_trace(("%s: %s\n", __func__, enable ? "Enabling" : "Disabling"));
--- a/drivers/staging/brcm80211/brcmfmac/bcmutils.c
+++ b/drivers/staging/brcm80211/brcmfmac/bcmutils.c
@@ -530,9 +530,9 @@ const unsigned char bcm_ctype[] = {
 	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L	/* 240-255 */
 };
 
-ulong bcm_strtoul(char *cp, char **endp, uint base)
+unsigned long bcm_strtoul(char *cp, char **endp, uint base)
 {
-	ulong result, last_result = 0, value;
+	unsigned long result, last_result = 0, value;
 	bool minus;
 
 	minus = FALSE;
@@ -572,13 +572,13 @@ ulong bcm_strtoul(char *cp, char **endp,
 		result = result * base + value;
 		/* Detected overflow */
 		if (result < last_result && !minus)
-			return (ulong)-1;
+			return (unsigned long)-1;
 		last_result = result;
 		cp++;
 	}
 
 	if (minus)
-		result = (ulong) (-(long)result);
+		result = (unsigned long) (-(long)result);
 
 	if (endp)
 		*endp = (char *)cp;
@@ -807,9 +807,9 @@ int bcm_ether_atoe(char *p, struct ether
  * parameter order is like strncpy, but returns count
  * of bytes copied. Minimum bytes copied is null char(1)/wchar(2)
  */
-ulong wchar2ascii(char *abuf, unsigned short * wbuf, unsigned short wbuflen, ulong abuflen)
+unsigned long wchar2ascii(char *abuf, unsigned short * wbuf, unsigned short wbuflen, unsigned long abuflen)
 {
-	ulong copyct = 1;
+	unsigned long copyct = 1;
 	unsigned short i;
 
 	if (abuflen == 0)
@@ -1246,7 +1246,7 @@ uint32 hndcrc32(u8 *pdata,	/* pointer to
 	u8 *pend;
 #ifdef __mips__
 	u8 tmp[4];
-	ulong *tptr = (ulong *) tmp;
+	unsigned long *tptr = (unsigned long *) tmp;
 
 	/* in case the beginning of the buffer isn't aligned */
 	pend = (u8 *) ((uint) (pdata + 3) & 0xfffffffc);
@@ -1257,8 +1257,8 @@ uint32 hndcrc32(u8 *pdata,	/* pointer to
 	/* handle bulk of data as 32-bit words */
 	pend = pdata + (nbytes & 0xfffffffc);
 	while (pdata < pend) {
-		*tptr = *(ulong *) pdata;
-		pdata += sizeof(ulong *);
+		*tptr = *(unsigned long *) pdata;
+		pdata += sizeof(unsigned long *);
 		CRC_INNER_LOOP(32, crc, tmp[0]);
 		CRC_INNER_LOOP(32, crc, tmp[1]);
 		CRC_INNER_LOOP(32, crc, tmp[2]);
--- a/drivers/staging/brcm80211/brcmfmac/dhd.h
+++ b/drivers/staging/brcm80211/brcmfmac/dhd.h
@@ -105,33 +105,33 @@ typedef struct dhd_pub {
 
 	/* Dongle media info */
 	bool iswl;		/* Dongle-resident driver is wl */
-	ulong drv_version;	/* Version of dongle-resident driver */
+	unsigned long drv_version;	/* Version of dongle-resident driver */
 	struct ether_addr mac;	/* MAC address obtained from dongle */
 	dngl_stats_t dstats;	/* Stats for dongle-based data */
 
 	/* Additional stats for the bus level */
-	ulong tx_packets;	/* Data packets sent to dongle */
-	ulong tx_multicast;	/* Multicast data packets sent to dongle */
-	ulong tx_errors;	/* Errors in sending data to dongle */
-	ulong tx_ctlpkts;	/* Control packets sent to dongle */
-	ulong tx_ctlerrs;	/* Errors sending control frames to dongle */
-	ulong rx_packets;	/* Packets sent up the network interface */
-	ulong rx_multicast;	/* Multicast packets sent up the network
+	unsigned long tx_packets;	/* Data packets sent to dongle */
+	unsigned long tx_multicast;	/* Multicast data packets sent to dongle */
+	unsigned long tx_errors;	/* Errors in sending data to dongle */
+	unsigned long tx_ctlpkts;	/* Control packets sent to dongle */
+	unsigned long tx_ctlerrs;	/* Errors sending control frames to dongle */
+	unsigned long rx_packets;	/* Packets sent up the network interface */
+	unsigned long rx_multicast;	/* Multicast packets sent up the network
 					 interface */
-	ulong rx_errors;	/* Errors processing rx data packets */
-	ulong rx_ctlpkts;	/* Control frames processed from dongle */
-	ulong rx_ctlerrs;	/* Errors in processing rx control frames */
-	ulong rx_dropped;	/* Packets dropped locally (no memory) */
-	ulong rx_flushed;	/* Packets flushed due to
+	unsigned long rx_errors;	/* Errors processing rx data packets */
+	unsigned long rx_ctlpkts;	/* Control frames processed from dongle */
+	unsigned long rx_ctlerrs;	/* Errors in processing rx control frames */
+	unsigned long rx_dropped;	/* Packets dropped locally (no memory) */
+	unsigned long rx_flushed;	/* Packets flushed due to
 				unscheduled sendup thread */
-	ulong wd_dpc_sched;	/* Number of times dhd dpc scheduled by
+	unsigned long wd_dpc_sched;	/* Number of times dhd dpc scheduled by
 					 watchdog timer */
 
-	ulong rx_readahead_cnt;	/* Number of packets where header read-ahead
+	unsigned long rx_readahead_cnt;	/* Number of packets where header read-ahead
 					 was used. */
-	ulong tx_realloc;	/* Number of tx packets we had to realloc for
+	unsigned long tx_realloc;	/* Number of tx packets we had to realloc for
 					 headroom */
-	ulong fc_packets;	/* Number of flow control pkts recvd */
+	unsigned long fc_packets;	/* Number of flow control pkts recvd */
 
 	/* Last error return */
 	int bcmerror;
--- a/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
+++ b/drivers/staging/brcm80211/brcmfmac/dhd_linux.c
@@ -412,7 +412,7 @@ static char dhd_version[] = "Dongle Host
 struct iw_statistics *dhd_get_wireless_stats(struct net_device *dev);
 #endif				/* defined(CONFIG_WIRELESS_EXT) */
 
-static void dhd_dpc(ulong data);
+static void dhd_dpc(unsigned long data);
 /* forward decl */
 extern int dhd_wait_pend8021x(struct net_device *dev);
 
@@ -1328,7 +1328,7 @@ static int dhd_watchdog_thread(void *dat
 	complete_and_exit(&dhd->watchdog_exited, 0);
 }
 
-static void dhd_watchdog(ulong data)
+static void dhd_watchdog(unsigned long data)
 {
 	dhd_info_t *dhd = (dhd_info_t *) data;
 
@@ -1399,7 +1399,7 @@ static int dhd_dpc_thread(void *data)
 	complete_and_exit(&dhd->dpc_exited, 0);
 }
 
-static void dhd_dpc(ulong data)
+static void dhd_dpc(unsigned long data)
 {
 	dhd_info_t *dhd;
 
@@ -1999,7 +1999,7 @@ dhd_pub_t *dhd_attach(osl_t *osh, struct
 
 	/* Set up the watchdog timer */
 	init_timer(&dhd->timer);
-	dhd->timer.data = (ulong) dhd;
+	dhd->timer.data = (unsigned long) dhd;
 	dhd->timer.function = dhd_watchdog;
 
 	/* Initialize thread based operation and lock */
@@ -2025,7 +2025,7 @@ dhd_pub_t *dhd_attach(osl_t *osh, struct
 		init_completion(&dhd->dpc_exited);
 		dhd->dpc_pid = kernel_thread(dhd_dpc_thread, dhd, 0);
 	} else {
-		tasklet_init(&dhd->tasklet, dhd_dpc, (ulong) dhd);
+		tasklet_init(&dhd->tasklet, dhd_dpc, (unsigned long) dhd);
 		dhd->dpc_pid = -1;
 	}
 
--- a/drivers/staging/brcm80211/brcmfmac/linux_osl.c
+++ b/drivers/staging/brcm80211/brcmfmac/linux_osl.c
@@ -482,14 +482,14 @@ uint osl_malloc_failed(osl_t *osh)
 	return osh->failed;
 }
 
-void *osl_dma_alloc_consistent(osl_t *osh, uint size, ulong *pap)
+void *osl_dma_alloc_consistent(osl_t *osh, uint size, unsigned long *pap)
 {
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
 	return pci_alloc_consistent(osh->pdev, size, (dma_addr_t *) pap);
 }
 
-void osl_dma_free_consistent(osl_t *osh, void *va, uint size, ulong pa)
+void osl_dma_free_consistent(osl_t *osh, void *va, uint size, unsigned long pa)
 {
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.c
@@ -285,7 +285,7 @@ static int32 wl_config_dongle(struct wl_
 /*
 ** iscan handler
 */
-static void wl_iscan_timer(ulong data);
+static void wl_iscan_timer(unsigned long data);
 static void wl_term_iscan(struct wl_priv *wl);
 static int32 wl_init_iscan(struct wl_priv *wl);
 static int32 wl_iscan_thread(void *data);
@@ -2939,7 +2939,7 @@ static int32 wl_iscan_thread(void *data)
 	return 0;
 }
 
-static void wl_iscan_timer(ulong data)
+static void wl_iscan_timer(unsigned long data)
 {
 	struct wl_iscan_ctrl *iscan = (struct wl_iscan_ctrl *)data;
 
@@ -2990,7 +2990,7 @@ static int32 wl_init_iscan(struct wl_pri
 		wl_init_iscan_eloop(&iscan->el);
 		iscan->timer_ms = WL_ISCAN_TIMER_INTERVAL_MS;
 		init_timer(&iscan->timer);
-		iscan->timer.data = (ulong) iscan;
+		iscan->timer.data = (unsigned long) iscan;
 		iscan->timer.function = wl_iscan_timer;
 		sema_init(&iscan->sync, 0);
 		init_completion(&iscan->exited);
--- a/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
+++ b/drivers/staging/brcm80211/brcmfmac/wl_cfg80211.h
@@ -267,7 +267,7 @@ struct wl_connect_info {
 /* firmware /nvram downloading controller */
 struct wl_fw_ctrl {
 	const struct firmware *fw_entry;
-	ulong status;
+	unsigned long status;
 	uint32 ptr;
 	s8 fw_name[WL_FILE_NAME_MAX];
 	s8 nvram_name[WL_FILE_NAME_MAX];
@@ -316,7 +316,7 @@ struct wl_priv {
 				 downloading */
 	struct wl_pmk_list *pmk_list;	/* wpa2 pmk list */
 	int32 event_pid;	/* pid of main event handler thread */
-	ulong status;		/* current dongle status */
+	unsigned long status;		/* current dongle status */
 	void *pub;
 	uint32 channel;		/* current channel */
 	bool iscan_on;		/* iscan on/off switch */
--- a/drivers/staging/brcm80211/brcmfmac/wl_iw.c
+++ b/drivers/staging/brcm80211/brcmfmac/wl_iw.c
@@ -143,7 +143,7 @@ typedef struct iscan_info {
 	int iscan_ex_param_size;
 } iscan_info_t;
 iscan_info_t *g_iscan = NULL;
-static void wl_iw_timerfunc(ulong data);
+static void wl_iw_timerfunc(unsigned long data);
 static void wl_iw_set_event_mask(struct net_device *dev);
 static int wl_iw_iscan(iscan_info_t *iscan, wlc_ssid_t *ssid, uint16 action);
 #endif				/* defined(WL_IW_USE_ISCAN) */
@@ -1070,7 +1070,7 @@ static int wl_iw_iscan(iscan_info_t *isc
 	return err;
 }
 
-static void wl_iw_timerfunc(ulong data)
+static void wl_iw_timerfunc(unsigned long data)
 {
 	iscan_info_t *iscan = (iscan_info_t *) data;
 	if (iscan) {
@@ -3731,7 +3731,7 @@ int wl_iw_attach(struct net_device *dev,
 
 	iscan->timer_ms = 3000;
 	init_timer(&iscan->timer);
-	iscan->timer.data = (ulong) iscan;
+	iscan->timer.data = (unsigned long) iscan;
 	iscan->timer.function = wl_iw_timerfunc;
 
 	sema_init(&iscan->sysioc_sem, 0);
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -207,13 +207,13 @@ extern "C" {
 #ifdef BRCM_FULLMAC
 /* string */
 	extern int BCMROMFN(bcm_atoi) (char *s);
-	extern ulong BCMROMFN(bcm_strtoul) (char *cp, char **endp, uint base);
+	extern unsigned long BCMROMFN(bcm_strtoul) (char *cp, char **endp, uint base);
 	extern char *BCMROMFN(bcmstrstr) (char *haystack, char *needle);
 	extern char *BCMROMFN(bcmstrcat) (char *dest, const char *src);
 	extern char *BCMROMFN(bcmstrncat) (char *dest, const char *src,
 					   uint size);
-	extern ulong wchar2ascii(char *abuf, unsigned short *wbuf, unsigned short wbuflen,
-				 ulong abuflen);
+	extern unsigned long wchar2ascii(char *abuf, unsigned short *wbuf, unsigned short wbuflen,
+				 unsigned long abuflen);
 	char *bcmstrtok(char **string, const char *delimiters, char *tokdelim);
 	int bcmstricmp(const char *s1, const char *s2);
 	int bcmstrnicmp(const char *s1, const char *s2, int cnt);
--- a/drivers/staging/brcm80211/include/linux_osl.h
+++ b/drivers/staging/brcm80211/include/linux_osl.h
@@ -121,7 +121,7 @@ extern uint osl_malloc_failed(osl_t *osh
 #define	DMA_CONSISTENT_ALIGN	PAGE_SIZE
 #define	DMA_ALLOC_CONSISTENT(osh, size, pap, dmah, alignbits) \
 	osl_dma_alloc_consistent((osh), (size), (pap))
-extern void *osl_dma_alloc_consistent(osl_t *osh, uint size, ulong *pap);
+extern void *osl_dma_alloc_consistent(osl_t *osh, uint size, unsigned long *pap);
 #else
 /* allocate/free shared (dma-able) consistent memory */
 #define	DMA_CONSISTENT_ALIGN	osl_dma_consistent_align()
@@ -129,11 +129,11 @@ extern void *osl_dma_alloc_consistent(os
 	osl_dma_alloc_consistent((osh), (size), (align), (tot), (pap))
 extern uint osl_dma_consistent_align(void);
 extern void *osl_dma_alloc_consistent(osl_t *osh, uint size, uint16 align,
-				      uint *tot, ulong *pap);
+				      uint *tot, unsigned long *pap);
 #endif
 #define	DMA_FREE_CONSISTENT(osh, va, size, pa, dmah) \
 	osl_dma_free_consistent((osh), (void *)(va), (size), (pa))
-extern void osl_dma_free_consistent(osl_t *osh, void *va, uint size, ulong pa);
+extern void osl_dma_free_consistent(osl_t *osh, void *va, uint size, unsigned long pa);
 
 /* map/unmap direction */
 #define	DMA_TX	1		/* TX direction for DMA */
--- a/drivers/staging/brcm80211/include/typedefs.h
+++ b/drivers/staging/brcm80211/include/typedefs.h
@@ -31,22 +31,17 @@ typedef unsigned long long int uintptr;
 #endif
 
 #define TYPEDEF_UINT
-#define TYPEDEF_ULONG
 
 /*
  * Default Typedefs
  */
 
-/* define ushort, uint, ulong */
+/* define uint */
 
 #ifndef TYPEDEF_UINT
 typedef unsigned int uint;
 #endif
 
-#ifndef TYPEDEF_ULONG
-typedef unsigned long ulong;
-#endif
-
 /* define [u]int16/32/64, uintptr */
 
 #ifndef TYPEDEF_UINT16
@@ -90,7 +85,6 @@ typedef signed int int32;
 #define	AUTO	(-1)		/* Auto = -1 */
 
 #undef TYPEDEF_UINT
-#undef TYPEDEF_ULONG
 #undef TYPEDEF_UINT16
 #undef TYPEDEF_UINT32
 #undef TYPEDEF_UINTPTR
--- a/drivers/staging/brcm80211/sys/wl_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.c
@@ -69,7 +69,7 @@ void wlc_mac_bcn_promisc_change(wlc_info
 void wlc_set_addrmatch(wlc_info_t *wlc, int match_reg_offset,
 		       const struct ether_addr *addr);
 
-static void wl_timer(ulong data);
+static void wl_timer(unsigned long data);
 static void _wl_timer(wl_timer_t *t);
 
 #ifdef WLC_HIGH_ONLY
@@ -144,7 +144,7 @@ static void wl_release_fw(wl_info_t *wl)
 static int wl_start(struct sk_buff *skb, wl_info_t *wl);
 static int wl_start_int(wl_info_t *wl, struct ieee80211_hw *hw,
 			struct sk_buff *skb);
-static void wl_dpc(ulong data);
+static void wl_dpc(unsigned long data);
 
 MODULE_AUTHOR("Broadcom Corporation");
 MODULE_DESCRIPTION("Broadcom 802.11n wireless LAN driver.");
@@ -764,14 +764,14 @@ static int wl_set_hint(wl_info_t *wl, ch
  * a warning that this function is defined but not used if we declare
  * it as static.
  */
-static wl_info_t *wl_attach(uint16 vendor, uint16 device, ulong regs,
+static wl_info_t *wl_attach(uint16 vendor, uint16 device, unsigned long regs,
 			    uint bustype, void *btparam, uint irq)
 {
 	wl_info_t *wl;
 	osl_t *osh;
 	int unit, err;
 
-	ulong base_addr;
+	unsigned long base_addr;
 	struct ieee80211_hw *hw;
 	u8 perm[ETH_ALEN];
 
@@ -813,7 +813,7 @@ static wl_info_t *wl_attach(uint16 vendo
 	atomic_set(&wl->callbacks, 0);
 
 	/* setup the bottom half handler */
-	tasklet_init(&wl->tasklet, wl_dpc, (ulong) wl);
+	tasklet_init(&wl->tasklet, wl_dpc, (unsigned long) wl);
 
 #ifdef WLC_HIGH_ONLY
 	wl->rpc_th = bcm_rpc_tp_attach(osh, NULL);
@@ -987,7 +987,7 @@ static void *wl_dbus_probe_cb(void *arg,
 	wl_info_t *wl;
 	WL_ERROR(("%s:\n", __func__));
 
-	wl = wl_attach(BCM_DNGL_VID, BCM_DNGL_BDC_PID, (ulong) NULL, RPC_BUS,
+	wl = wl_attach(BCM_DNGL_VID, BCM_DNGL_BDC_PID, (unsigned long) NULL, RPC_BUS,
 		NULL, 0);
 	if (!wl) {
 		WL_ERROR(("%s: wl_attach failed\n", __func__));
@@ -1817,7 +1817,7 @@ irqreturn_t BCMFASTPATH wl_isr(int irq,
 #endif				/* WLC_LOW */
 }
 
-static void BCMFASTPATH wl_dpc(ulong data)
+static void BCMFASTPATH wl_dpc(unsigned long data)
 {
 #ifdef WLC_LOW
 	wl_info_t *wl;
@@ -1882,7 +1882,7 @@ void wl_event(wl_info_t *wl, char *ifnam
 	}
 }
 
-static void wl_timer(ulong data)
+static void wl_timer(unsigned long data)
 {
 #ifndef WLC_HIGH_ONLY
 	_wl_timer((wl_timer_t *) data);
@@ -1927,7 +1927,7 @@ wl_timer_t *wl_init_timer(wl_info_t *wl,
 	bzero(t, sizeof(wl_timer_t));
 
 	init_timer(&t->timer);
-	t->timer.data = (ulong) t;
+	t->timer.data = (unsigned long) t;
 	t->timer.function = wl_timer;
 	t->wl = wl;
 	t->fn = fn;
@@ -2069,7 +2069,7 @@ static void wl_rpc_down(void *wlh)
 static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t *wl)
 {
 
-	ulong flags;
+	unsigned long flags;
 
 	skb->prev = NULL;
 
@@ -2103,7 +2103,7 @@ static void wl_start_txqwork(struct wl_t
 {
 	wl_info_t *wl = (wl_info_t *) task->context;
 	struct sk_buff *skb;
-	ulong flags;
+	unsigned long flags;
 	uint count = 0;
 
 	WL_TRACE(("wl%d: wl_start_txqwork\n", wl->pub->unit));
@@ -2183,7 +2183,7 @@ static void wl_rpcq_dispatch(struct wl_t
 {
 	wl_info_t *wl = (wl_info_t *) task->context;
 	rpc_buf_t *buf;
-	ulong flags;
+	unsigned long flags;
 
 	/* First remove an entry then go for execution */
 	RPCQ_LOCK(wl, flags);
@@ -2212,7 +2212,7 @@ static void wl_rpcq_dispatch(struct wl_t
 
 static void wl_rpcq_add(wl_info_t *wl, rpc_buf_t *buf)
 {
-	ulong flags;
+	unsigned long flags;
 
 	bcm_rpc_buf_next_set(wl->rpc_th, buf, NULL);
 
--- a/drivers/staging/brcm80211/sys/wl_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.h
@@ -81,7 +81,7 @@ struct wl_info {
 	struct tasklet_struct tasklet;	/* dpc tasklet */
 #ifdef BCMSDIO
 	bcmsdh_info_t *sdh;	/* pointer to sdio bus handler */
-	ulong flags;		/* current irq flags */
+	unsigned long flags;		/* current irq flags */
 #endif				/* BCMSDIO */
 	bool resched;		/* dpc needs to be and is rescheduled */
 #ifdef LINUXSTA_PS
--- a/drivers/staging/brcm80211/util/linux_osl.c
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -352,7 +352,7 @@ uint osl_dma_consistent_align(void)
 }
 
 void *osl_dma_alloc_consistent(osl_t *osh, uint size, uint16 align_bits,
-			       uint *alloced, ulong *pap)
+			       uint *alloced, unsigned long *pap)
 {
 	uint16 align = (1 << align_bits);
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
@@ -364,7 +364,7 @@ void *osl_dma_alloc_consistent(osl_t *os
 	return pci_alloc_consistent(osh->pdev, size, (dma_addr_t *) pap);
 }
 
-void osl_dma_free_consistent(osl_t *osh, void *va, uint size, ulong pa)
+void osl_dma_free_consistent(osl_t *osh, void *va, uint size, unsigned long pa)
 {
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 

commit 52b0e80e72ab7535896d0af72c720b22ad46a421
Author: Brett Rudley <brudley@broadcom.com>
Date:   Tue Oct 5 16:49:47 2010 -0700

    staging: brcm80211: bcmutils.[ch]: purge unused funcs
    
    Get rid of unused functions in bcmutils.[ch]. Note that bcmutils.h is shared between
    fullmac and softmac
    
    Signed-off-by: Brett Rudley <brudley@broadcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -151,12 +151,16 @@ extern "C" {
 	extern void pktq_pflush(osl_t *osh, struct pktq *pq, int prec,
 		bool dir, ifpkt_cb_t fn, int arg);
 #endif
+#ifdef BRCM_FULLMAC
 /* Remove a specified packet from its queue */
 	extern bool pktq_pdel(struct pktq *pq, void *p, int prec);
+#endif /* BRCM_FULLMAC */
 
 /* operations on a set of precedences in packet queue */
 
+#ifdef BRCM_FULLMAC
 	extern int pktq_mlen(struct pktq *pq, uint prec_bmp);
+#endif /* BRCM_FULLMAC */
 	extern void *pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out);
 
 /* operations on packet queue as a whole */
@@ -176,9 +180,11 @@ extern "C" {
 
 	extern void pktq_init(struct pktq *pq, int num_prec, int max_len);
 /* prec_out may be NULL if caller is not interested in return value */
+#ifdef BRCM_FULLMAC
 	extern void *pktq_deq(struct pktq *pq, int *prec_out);
 	extern void *pktq_deq_tail(struct pktq *pq, int *prec_out);
 	extern void *pktq_peek(struct pktq *pq, int *prec_out);
+#endif /* BRCM_FULLMAC */
 	extern void *pktq_peek_tail(struct pktq *pq, int *prec_out);
 #ifdef BRCM_FULLMAC
 	extern void pktq_flush(osl_t *osh, struct pktq *pq, bool dir);
@@ -189,13 +195,15 @@ extern "C" {
 
 /* externs */
 /* packet */
+#ifdef BRCM_FULLMAC
 	extern uint pktcopy(osl_t *osh, void *p, uint offset, int len,
 			    unsigned char *buf);
 	extern uint pktfrombuf(osl_t *osh, void *p, uint offset, int len,
 			       unsigned char *buf);
-	extern uint pkttotlen(osl_t *osh, void *p);
 	extern void *pktlast(osl_t *osh, void *p);
 	extern uint pktsegcnt(osl_t *osh, void *p);
+#endif /* BRCM_FULLMAC */
+	extern uint pkttotlen(osl_t *osh, void *p);
 
 /* Get priority from a packet and pass it back in scb (or equiv) */
 	extern uint pktsetprio(void *pkt, bool update_vtag);
@@ -226,13 +234,17 @@ extern "C" {
 	struct ipv4_addr;
 	extern char *bcm_ip_ntoa(struct ipv4_addr *ia, char *buf);
 
+#ifdef BRCM_FULLMAC
 /* delay */
 	extern void bcm_mdelay(uint ms);
+#endif
 /* variable access */
 	extern char *getvar(char *vars, const char *name);
 	extern int getintvar(char *vars, const char *name);
+#ifdef BRCM_FULLMAC
 	extern int getintvararray(char *vars, const char *name, u8 index);
 	extern uint getgpiopin(char *vars, char *pin_name, uint def_pin);
+#endif
 #ifdef BCMDBG
 	extern void prpkt(const char *msg, osl_t *osh, void *p0);
 #endif				/* BCMDBG */
@@ -246,8 +258,10 @@ extern "C" {
 #define bcmprinttslogs()
 #define bcmprinttstamp(us)
 
+#ifdef BRCM_FULLLMAC
 	extern char *bcm_nvram_vars(uint *length);
 	extern int bcm_nvram_cache(void *sih);
+#endif
 
 /* Support for sharing code across in-driver iovar implementations.
  * The intent is that a driver use this structure to map iovar names
@@ -279,14 +293,18 @@ extern "C" {
 
 /* flags are per-driver based on driver attributes */
 
+#ifdef BRCM_FULLMAC
 	extern const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t *table,
 						   const char *name);
+#endif
 	extern int bcm_iovar_lencheck(const bcm_iovar_t *table, void *arg,
 				      int len, bool set);
+#ifdef BRCM_FULLMAC
 #if defined(BCMDBG)
 	extern int bcm_format_ssid(char *buf, const unsigned char ssid[],
 				   uint ssid_len);
 #endif
+#endif /* BRCM_FULLMAC */
 
 /* Base type definitions */
 #define IOVT_VOID	0	/* no value (implictly set only) */
@@ -558,25 +576,32 @@ extern "C" {
 				    char *buf, int len);
 	extern int bcm_format_hex(char *str, const void *bytes, int len);
 #endif
+#ifdef BRCM_FULLMAC
 #ifdef BCMDBG
 	extern void deadbeef(void *p, uint len);
 #endif
 	extern const char *bcm_crypto_algo_name(uint algo);
+#endif /* BRCM_FULLMAC */
 	extern char *bcm_chipname(uint chipid, char *buf, uint len);
+#ifdef BRCM_FULLMAC
 	extern char *bcm_brev_str(uint32 brev, char *buf);
 	extern void printbig(char *buf);
+#endif /* BRCM_FULLMAC */
 	extern void prhex(const char *msg, unsigned char *buf, uint len);
 
+#ifdef BRCM_FULLMAC
 /* IE parsing */
 	extern bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t *elt, int *buflen);
-	extern bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (void *buf, int buflen,
-						    uint key);
 	extern bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tlvs) (void *buf,
 							    int buflen,
 							    uint key);
-
+#endif
+	extern bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (void *buf, int buflen,
+						    uint key);
+#ifdef BRCM_FULLMAC
 /* bcmerror */
 	extern const char *bcmerrorstr(int bcmerror);
+#endif
 
 /* multi-bool data type: set of bools, mbool is true if any is set */
 	typedef uint32 mbool;
@@ -585,9 +610,11 @@ extern "C" {
 #define mboolisset(mb, bit)		(((mb) & (bit)) != 0)	/* TRUE if one bool is set */
 #define	mboolmaskset(mb, mask, val)	((mb) = (((mb) & ~(mask)) | (val)))
 
+#ifdef BRCM_FULLMAC
 /* power conversion */
 	extern uint16 BCMROMFN(bcm_qdbm_to_mw) (u8 qdbm);
 	extern u8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw);
+#endif
 
 /* generic datastruct to help dump routines */
 	struct fielddesc {
@@ -596,20 +623,24 @@ extern "C" {
 		uint32 len;
 	};
 
+#ifdef BRCM_FULLMAC
 	extern void bcm_binit(struct bcmstrbuf *b, char *buf, uint size);
 	extern int bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...);
 	extern void bcm_inc_bytes(unsigned char *num, int num_bytes, u8 amount);
 	extern int bcm_cmp_bytes(unsigned char *arg1, unsigned char *arg2, u8 nbytes);
 	extern void bcm_print_bytes(char *name, const unsigned char *cdata, int len);
+#endif
 
 	typedef uint32(*bcmutl_rdreg_rtn) (void *arg0, uint arg1,
 					   uint32 offset);
+#ifdef BRCM_FULLMAC
 	extern uint bcmdumpfields(bcmutl_rdreg_rtn func_ptr, void *arg0,
 				  uint arg1, struct fielddesc *str, char *buf,
 				  uint32 bufsize);
 
 	extern uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf,
 				uint len);
+#endif
 	extern uint BCMROMFN(bcm_bitcount) (u8 *bitmap, uint bytelength);
 
 #ifdef __cplusplus
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -31,70 +31,6 @@
 #include <proto/802.1d.h>
 #include <proto/802.11.h>
 
-#ifdef WLC_LOW
-/* nvram vars cache */
-static char *nvram_vars;
-static int vars_len = -1;
-#endif				/* WLC_LOW */
-
-/* copy a pkt buffer chain into a buffer */
-uint pktcopy(osl_t *osh, void *p, uint offset, int len, unsigned char *buf)
-{
-	uint n, ret = 0;
-
-	if (len < 0)
-		len = 4096;	/* "infinite" */
-
-	/* skip 'offset' bytes */
-	for (; p && offset; p = PKTNEXT(p)) {
-		if (offset < (uint) PKTLEN(p))
-			break;
-		offset -= PKTLEN(p);
-	}
-
-	if (!p)
-		return 0;
-
-	/* copy the data */
-	for (; p && len; p = PKTNEXT(p)) {
-		n = MIN((uint) PKTLEN(p) - offset, (uint) len);
-		bcopy(PKTDATA(p) + offset, buf, n);
-		buf += n;
-		len -= n;
-		ret += n;
-		offset = 0;
-	}
-
-	return ret;
-}
-
-/* copy a buffer into a pkt buffer chain */
-uint pktfrombuf(osl_t *osh, void *p, uint offset, int len, unsigned char *buf)
-{
-	uint n, ret = 0;
-
-	/* skip 'offset' bytes */
-	for (; p && offset; p = PKTNEXT(p)) {
-		if (offset < (uint) PKTLEN(p))
-			break;
-		offset -= PKTLEN(p);
-	}
-
-	if (!p)
-		return 0;
-
-	/* copy the data */
-	for (; p && len; p = PKTNEXT(p)) {
-		n = MIN((uint) PKTLEN(p) - offset, (uint) len);
-		bcopy(buf, PKTDATA(p) + offset, n);
-		buf += n;
-		len -= n;
-		ret += n;
-		offset = 0;
-	}
-
-	return ret;
-}
 
 /* return total length of buffer chain */
 uint BCMFASTPATH pkttotlen(osl_t *osh, void *p)
@@ -107,26 +43,6 @@ uint BCMFASTPATH pkttotlen(osl_t *osh, v
 	return total;
 }
 
-/* return the last buffer of chained pkt */
-void *pktlast(osl_t *osh, void *p)
-{
-	for (; PKTNEXT(p); p = PKTNEXT(p))
-		;
-
-	return p;
-}
-
-/* count segments of a chained packet */
-uint BCMFASTPATH pktsegcnt(osl_t *osh, void *p)
-{
-	uint cnt;
-
-	for (cnt = 0; p; p = PKTNEXT(p))
-		cnt++;
-
-	return cnt;
-}
-
 /*
  * osl multiple-precedence packet queue
  * hi_prec is always >= the number of the highest non-empty precedence
@@ -274,39 +190,6 @@ pktq_pflush(osl_t *osh, struct pktq *pq,
 	}
 }
 
-bool BCMFASTPATH pktq_pdel(struct pktq *pq, void *pktbuf, int prec)
-{
-	struct pktq_prec *q;
-	void *p;
-
-	ASSERT(prec >= 0 && prec < pq->num_prec);
-
-	if (!pktbuf)
-		return FALSE;
-
-	q = &pq->q[prec];
-
-	if (q->head == pktbuf) {
-		q->head = PKTLINK(pktbuf);
-		if (q->head == NULL)
-			q->tail = NULL;
-	} else {
-		for (p = q->head; p && PKTLINK(p) != pktbuf; p = PKTLINK(p))
-			;
-		if (p == NULL)
-			return FALSE;
-
-		PKTSETLINK(p, PKTLINK(pktbuf));
-		if (q->tail == pktbuf)
-			q->tail = p;
-	}
-
-	q->len--;
-	pq->len--;
-	PKTSETLINK(pktbuf, NULL);
-	return TRUE;
-}
-
 void pktq_init(struct pktq *pq, int num_prec, int max_len)
 {
 	int prec;
@@ -325,96 +208,6 @@ void pktq_init(struct pktq *pq, int num_
 		pq->q[prec].max = pq->max;
 }
 
-void *BCMFASTPATH pktq_deq(struct pktq *pq, int *prec_out)
-{
-	struct pktq_prec *q;
-	void *p;
-	int prec;
-
-	if (pq->len == 0)
-		return NULL;
-
-	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
-		pq->hi_prec--;
-
-	q = &pq->q[prec];
-
-	p = q->head;
-	if (p == NULL)
-		return NULL;
-
-	q->head = PKTLINK(p);
-	if (q->head == NULL)
-		q->tail = NULL;
-
-	q->len--;
-
-	pq->len--;
-
-	if (prec_out)
-		*prec_out = prec;
-
-	PKTSETLINK(p, NULL);
-
-	return p;
-}
-
-void *BCMFASTPATH pktq_deq_tail(struct pktq *pq, int *prec_out)
-{
-	struct pktq_prec *q;
-	void *p, *prev;
-	int prec;
-
-	if (pq->len == 0)
-		return NULL;
-
-	for (prec = 0; prec < pq->hi_prec; prec++)
-		if (pq->q[prec].head)
-			break;
-
-	q = &pq->q[prec];
-
-	p = q->head;
-	if (p == NULL)
-		return NULL;
-
-	for (prev = NULL; p != q->tail; p = PKTLINK(p))
-		prev = p;
-
-	if (prev)
-		PKTSETLINK(prev, NULL);
-	else
-		q->head = NULL;
-
-	q->tail = prev;
-	q->len--;
-
-	pq->len--;
-
-	if (prec_out)
-		*prec_out = prec;
-
-	PKTSETLINK(p, NULL);
-
-	return p;
-}
-
-void *pktq_peek(struct pktq *pq, int *prec_out)
-{
-	int prec;
-
-	if (pq->len == 0)
-		return NULL;
-
-	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
-		pq->hi_prec--;
-
-	if (prec_out)
-		*prec_out = prec;
-
-	return pq->q[prec].head;
-}
-
 void *pktq_peek_tail(struct pktq *pq, int *prec_out)
 {
 	int prec;
@@ -441,20 +234,6 @@ void pktq_flush(osl_t *osh, struct pktq
 		ASSERT(pq->len == 0);
 }
 
-/* Return sum of lengths of a specific set of precedences */
-int pktq_mlen(struct pktq *pq, uint prec_bmp)
-{
-	int prec, len;
-
-	len = 0;
-
-	for (prec = 0; prec <= pq->hi_prec; prec++)
-		if (prec_bmp & (1 << prec))
-			len += pq->q[prec].len;
-
-	return len;
-}
-
 /* Priority dequeue from a specific set of precedences */
 void *BCMFASTPATH pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out)
 {
@@ -514,15 +293,6 @@ char *bcm_ether_ntoa(const struct ether_
 	return buf;
 }
 
-void bcm_mdelay(uint ms)
-{
-	uint i;
-
-	for (i = 0; i < ms; i++) {
-		OSL_DELAY(1000);
-	}
-}
-
 /*
  * Search the name=value vars for a specific one and return its value.
  * Returns NULL if not found.
@@ -567,84 +337,6 @@ int getintvar(char *vars, const char *na
 	return simple_strtoul(val, NULL, 0);
 }
 
-int getintvararray(char *vars, const char *name, u8 index)
-{
-	char *buf, *endp;
-	int i = 0;
-	int val = 0;
-
-	buf = getvar(vars, name);
-	if (buf == NULL) {
-		return 0;
-	}
-
-	/* table values are always separated by "," or " " */
-	while (*buf != '\0') {
-		val = simple_strtoul(buf, &endp, 0);
-		if (i == index) {
-			return val;
-		}
-		buf = endp;
-		/* delimiter is ',' */
-		if (*buf == ',')
-			buf++;
-		i++;
-	}
-	return 0;
-}
-
-/* Search for token in comma separated token-string */
-static int findmatch(char *string, char *name)
-{
-	uint len;
-	char *c;
-
-	len = strlen(name);
-	while ((c = strchr(string, ',')) != NULL) {
-		if (len == (uint) (c - string) && !strncmp(string, name, len))
-			return 1;
-		string = c + 1;
-	}
-
-	return !strcmp(string, name);
-}
-
-/* Return gpio pin number assigned to the named pin
- *
- * Variable should be in format:
- *
- *	gpio<N>=pin_name,pin_name
- *
- * This format allows multiple features to share the gpio with mutual
- * understanding.
- *
- * 'def_pin' is returned if a specific gpio is not defined for the requested functionality
- * and if def_pin is not used by others.
- */
-uint getgpiopin(char *vars, char *pin_name, uint def_pin)
-{
-	char name[] = "gpioXXXX";
-	char *val;
-	uint pin;
-
-	/* Go thru all possibilities till a match in pin name */
-	for (pin = 0; pin < GPIO_NUMPINS; pin++) {
-		snprintf(name, sizeof(name), "gpio%d", pin);
-		val = getvar(vars, name);
-		if (val && findmatch(val, pin_name))
-			return pin;
-	}
-
-	if (def_pin != GPIO_PIN_NOTDEFINED) {
-		/* make sure the default pin is not used by someone else */
-		snprintf(name, sizeof(name), "gpio%d", def_pin);
-		if (getvar(vars, name)) {
-			def_pin = GPIO_PIN_NOTDEFINED;
-		}
-	}
-	return def_pin;
-}
-
 #if defined(BCMDBG)
 /* pretty hex print a pkt buffer chain */
 void prpkt(const char *msg, osl_t *osh, void *p0)
@@ -659,135 +351,6 @@ void prpkt(const char *msg, osl_t *osh,
 }
 #endif				/* defined(BCMDBG) */
 
-static char bcm_undeferrstr[32];
-static const char *bcmerrorstrtable[] = BCMERRSTRINGTABLE;
-
-/* Convert the error codes into related error strings  */
-const char *bcmerrorstr(int bcmerror)
-{
-	/* check if someone added a bcmerror code but forgot to add errorstring */
-	ASSERT(ABS(BCME_LAST) == (ARRAYSIZE(bcmerrorstrtable) - 1));
-
-	if (bcmerror > 0 || bcmerror < BCME_LAST) {
-		snprintf(bcm_undeferrstr, sizeof(bcm_undeferrstr),
-			 "Undefined error %d", bcmerror);
-		return bcm_undeferrstr;
-	}
-
-	ASSERT(strlen(bcmerrorstrtable[-bcmerror]) < BCME_STRLEN);
-
-	return bcmerrorstrtable[-bcmerror];
-}
-
-#ifdef WLC_LOW
-static void BCMINITFN(bcm_nvram_refresh) (char *flash)
-{
-	int i;
-	int ret = 0;
-
-	ASSERT(flash != NULL);
-
-	/* default "empty" vars cache */
-	bzero(flash, 2);
-
-	ret = nvram_getall(flash, NVRAM_SPACE);
-	if (ret)
-		return;
-
-	/* determine nvram length */
-	for (i = 0; i < NVRAM_SPACE; i++) {
-		if (flash[i] == '\0' && flash[i + 1] == '\0')
-			break;
-	}
-
-	if (i > 1)
-		vars_len = i + 2;
-	else
-		vars_len = 0;
-}
-
-char *bcm_nvram_vars(uint *length)
-{
-#ifndef BCMNVRAMR
-	/* cache may be stale if nvram is read/write */
-	if (nvram_vars) {
-		ASSERT(!bcmreclaimed);
-		bcm_nvram_refresh(nvram_vars);
-	}
-#endif
-	if (length)
-		*length = vars_len;
-	return nvram_vars;
-}
-
-/* copy nvram vars into locally-allocated multi-string array */
-int BCMINITFN(bcm_nvram_cache) (void *sih)
-{
-	int ret = 0;
-	void *osh;
-	char *flash = NULL;
-
-	if (vars_len >= 0) {
-#ifndef BCMNVRAMR
-		bcm_nvram_refresh(nvram_vars);
-#endif
-		return 0;
-	}
-
-	osh = si_osh((si_t *) sih);
-
-	/* allocate memory and read in flash */
-	flash = MALLOC(osh, NVRAM_SPACE);
-	if (!flash) {
-		ret = BCME_NOMEM;
-		goto exit;
-	}
-
-	bcm_nvram_refresh(flash);
-#ifdef BCMNVRAMR
-	if (vars_len > 3) {
-		/* copy into a properly-sized buffer */
-		nvram_vars = MALLOC(osh, vars_len);
-		if (!nvram_vars) {
-			ret = BCME_NOMEM;
-		} else
-			bcopy(flash, nvram_vars, vars_len);
-	}
-	MFREE(osh, flash, NVRAM_SPACE);
-#else
-	/* cache must be full size of nvram if read/write */
-	nvram_vars = flash;
-#endif				/* BCMNVRAMR */
-
- exit:
-	return ret;
-}
-#endif				/* WLC_LOW */
-
-/* iovar table lookup */
-const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t *table, const char *name)
-{
-	const bcm_iovar_t *vi;
-	const char *lookup_name;
-
-	/* skip any ':' delimited option prefixes */
-	lookup_name = strrchr(name, ':');
-	if (lookup_name != NULL)
-		lookup_name++;
-	else
-		lookup_name = name;
-
-	ASSERT(table != NULL);
-
-	for (vi = table; vi->name; vi++) {
-		if (!strcmp(vi->name, lookup_name))
-			return vi;
-	}
-	/* ran to end of table */
-
-	return NULL;		/* var name not found */
-}
-
 int bcm_iovar_lencheck(const bcm_iovar_t *vi, void *arg, int len, bool set)
 {
 	int bcmerror = 0;
@@ -973,34 +536,6 @@ uint16 BCMROMFN(hndcrc16) (u8 *pdata,	/*
 }
 
 /*
- * Advance from the current 1-byte tag/1-byte length/variable-length value
- * triple, to the next, returning a pointer to the next.
- * If the current or next TLV is invalid (does not fit in given buffer length),
- * NULL is returned.
- * *buflen is not modified if the TLV elt parameter is invalid, or is decremented
- * by the TLV parameter's length if it is valid.
- */
-bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t *elt, int *buflen)
-{
-	int len;
-
-	/* validate current elt */
-	if (!bcm_valid_tlv(elt, *buflen))
-		return NULL;
-
-	/* advance to next elt */
-	len = elt->len;
-	elt = (bcm_tlv_t *) (elt->data + len);
-	*buflen -= (2 + len);
-
-	/* validate next elt */
-	if (!bcm_valid_tlv(elt, *buflen))
-		return NULL;
-
-	return elt;
-}
-
-/*
  * Traverse a string of 1-byte tag/1-byte length/variable-length value
  * triples, returning a pointer to the substring whose first element
  * matches tag
@@ -1028,38 +563,6 @@ bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (voi
 	return NULL;
 }
 
-/*
- * Traverse a string of 1-byte tag/1-byte length/variable-length value
- * triples, returning a pointer to the substring whose first element
- * matches tag.  Stop parsing when we see an element whose ID is greater
- * than the target key.
- */
-bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tlvs) (void *buf, int buflen, uint key)
-{
-	bcm_tlv_t *elt;
-	int totlen;
-
-	elt = (bcm_tlv_t *) buf;
-	totlen = buflen;
-
-	/* find tagged parameter */
-	while (totlen >= 2) {
-		uint id = elt->id;
-		int len = elt->len;
-
-		/* Punt if we start seeing IDs > than target key */
-		if (id > key)
-			return NULL;
-
-		/* validate remaining totlen */
-		if ((id == key) && (totlen >= (len + 2)))
-			return elt;
-
-		elt = (bcm_tlv_t *) ((u8 *) elt + (len + 2));
-		totlen -= (len + 2);
-	}
-	return NULL;
-}
 
 #if defined(BCMDBG)
 int
@@ -1166,36 +669,6 @@ void prhex(const char *msg, unsigned cha
 		printf("%s\n", line);
 }
 
-static const char *crypto_algo_names[] = {
-	"NONE",
-	"WEP1",
-	"TKIP",
-	"WEP128",
-	"AES_CCM",
-	"NALG" "UNDEF",
-	"UNDEF",
-	"UNDEF",
-	"UNDEF"
-};
-
-const char *bcm_crypto_algo_name(uint algo)
-{
-	return (algo <
-		ARRAYSIZE(crypto_algo_names)) ? crypto_algo_names[algo] : "ERR";
-}
-
-#ifdef BCMDBG
-void deadbeef(void *p, uint len)
-{
-	static u8 meat[] = { 0xde, 0xad, 0xbe, 0xef };
-
-	while (len-- > 0) {
-		*(u8 *) p = meat[((uintptr) p) & 3];
-		p = (u8 *) p + 1;
-	}
-}
-#endif				/* BCMDBG */
-
 char *bcm_chipname(uint chipid, char *buf, uint len)
 {
 	const char *fmt;
@@ -1205,174 +678,6 @@ char *bcm_chipname(uint chipid, char *bu
 	return buf;
 }
 
-/* Produce a human-readable string for boardrev */
-char *bcm_brev_str(uint32 brev, char *buf)
-{
-	if (brev < 0x100)
-		snprintf(buf, 8, "%d.%d", (brev & 0xf0) >> 4, brev & 0xf);
-	else
-		snprintf(buf, 8, "%c%03x",
-			 ((brev & 0xf000) == 0x1000) ? 'P' : 'A', brev & 0xfff);
-
-	return buf;
-}
-
-#define BUFSIZE_TODUMP_ATONCE 512	/* Buffer size */
-
-/* dump large strings to console */
-void printbig(char *buf)
-{
-	uint len, max_len;
-	char c;
-
-	len = strlen(buf);
-
-	max_len = BUFSIZE_TODUMP_ATONCE;
-
-	while (len > max_len) {
-		c = buf[max_len];
-		buf[max_len] = '\0';
-		printf("%s", buf);
-		buf[max_len] = c;
-
-		buf += max_len;
-		len -= max_len;
-	}
-	/* print the remaining string */
-	printf("%s\n", buf);
-	return;
-}
-
-/* routine to dump fields in a fileddesc structure */
-uint
-bcmdumpfields(bcmutl_rdreg_rtn read_rtn, void *arg0, uint arg1,
-	      struct fielddesc *fielddesc_array, char *buf, uint32 bufsize)
-{
-	uint filled_len;
-	int len;
-	struct fielddesc *cur_ptr;
-
-	filled_len = 0;
-	cur_ptr = fielddesc_array;
-
-	while (bufsize > 1) {
-		if (cur_ptr->nameandfmt == NULL)
-			break;
-		len = snprintf(buf, bufsize, cur_ptr->nameandfmt,
-			       read_rtn(arg0, arg1, cur_ptr->offset));
-		/* check for snprintf overflow or error */
-		if (len < 0 || (uint32) len >= bufsize)
-			len = bufsize - 1;
-		buf += len;
-		bufsize -= len;
-		filled_len += len;
-		cur_ptr++;
-	}
-	return filled_len;
-}
-
-uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf, uint buflen)
-{
-	uint len;
-
-	len = strlen(name) + 1;
-
-	if ((len + datalen) > buflen)
-		return 0;
-
-	strncpy(buf, name, buflen);
-
-	/* append data onto the end of the name string */
-	memcpy(&buf[len], data, datalen);
-	len += datalen;
-
-	return len;
-}
-
-/* Quarter dBm units to mW
- * Table starts at QDBM_OFFSET, so the first entry is mW for qdBm=153
- * Table is offset so the last entry is largest mW value that fits in
- * a uint16.
- */
-
-#define QDBM_OFFSET 153		/* Offset for first entry */
-#define QDBM_TABLE_LEN 40	/* Table size */
-
-/* Smallest mW value that will round up to the first table entry, QDBM_OFFSET.
- * Value is ( mW(QDBM_OFFSET - 1) + mW(QDBM_OFFSET) ) / 2
- */
-#define QDBM_TABLE_LOW_BOUND 6493	/* Low bound */
-
-/* Largest mW value that will round down to the last table entry,
- * QDBM_OFFSET + QDBM_TABLE_LEN-1.
- * Value is ( mW(QDBM_OFFSET + QDBM_TABLE_LEN - 1) + mW(QDBM_OFFSET + QDBM_TABLE_LEN) ) / 2.
- */
-#define QDBM_TABLE_HIGH_BOUND 64938	/* High bound */
-
-static const uint16 nqdBm_to_mW_map[QDBM_TABLE_LEN] = {
-/* qdBm: 	+0 	+1 	+2 	+3 	+4 	+5 	+6 	+7 */
-/* 153: */ 6683, 7079, 7499, 7943, 8414, 8913, 9441, 10000,
-/* 161: */ 10593, 11220, 11885, 12589, 13335, 14125, 14962, 15849,
-/* 169: */ 16788, 17783, 18836, 19953, 21135, 22387, 23714, 25119,
-/* 177: */ 26607, 28184, 29854, 31623, 33497, 35481, 37584, 39811,
-/* 185: */ 42170, 44668, 47315, 50119, 53088, 56234, 59566, 63096
-};
-
-uint16 BCMROMFN(bcm_qdbm_to_mw) (u8 qdbm)
-{
-	uint factor = 1;
-	int idx = qdbm - QDBM_OFFSET;
-
-	if (idx >= QDBM_TABLE_LEN) {
-		/* clamp to max uint16 mW value */
-		return 0xFFFF;
-	}
-
-	/* scale the qdBm index up to the range of the table 0-40
-	 * where an offset of 40 qdBm equals a factor of 10 mW.
-	 */
-	while (idx < 0) {
-		idx += 40;
-		factor *= 10;
-	}
-
-	/* return the mW value scaled down to the correct factor of 10,
-	 * adding in factor/2 to get proper rounding.
-	 */
-	return (nqdBm_to_mW_map[idx] + factor / 2) / factor;
-}
-
-u8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw)
-{
-	u8 qdbm;
-	int offset;
-	uint mw_uint = mw;
-	uint boundary;
-
-	/* handle boundary case */
-	if (mw_uint <= 1)
-		return 0;
-
-	offset = QDBM_OFFSET;
-
-	/* move mw into the range of the table */
-	while (mw_uint < QDBM_TABLE_LOW_BOUND) {
-		mw_uint *= 10;
-		offset -= 40;
-	}
-
-	for (qdbm = 0; qdbm < QDBM_TABLE_LEN - 1; qdbm++) {
-		boundary = nqdBm_to_mW_map[qdbm] + (nqdBm_to_mW_map[qdbm + 1] -
-						    nqdBm_to_mW_map[qdbm]) / 2;
-		if (mw_uint < boundary)
-			break;
-	}
-
-	qdbm += (u8) offset;
-
-	return qdbm;
-}
-
 uint BCMROMFN(bcm_bitcount) (u8 *bitmap, uint length)
 {
 	uint bitcount = 0, i;
@@ -1386,104 +691,3 @@ uint BCMROMFN(bcm_bitcount) (u8 *bitmap,
 	}
 	return bitcount;
 }
-
-/* Initialization of bcmstrbuf structure */
-void bcm_binit(struct bcmstrbuf *b, char *buf, uint size)
-{
-	b->origsize = b->size = size;
-	b->origbuf = b->buf = buf;
-}
-
-/* Buffer sprintf wrapper to guard against buffer overflow */
-int bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...)
-{
-	va_list ap;
-	int r;
-
-	va_start(ap, fmt);
-	r = vsnprintf(b->buf, b->size, fmt, ap);
-
-	/* Non Ansi C99 compliant returns -1,
-	 * Ansi compliant return r >= b->size,
-	 * bcmstdlib returns 0, handle all
-	 */
-	if ((r == -1) || (r >= (int)b->size) || (r == 0)) {
-		b->size = 0;
-	} else {
-		b->size -= r;
-		b->buf += r;
-	}
-
-	va_end(ap);
-
-	return r;
-}
-
-void bcm_inc_bytes(unsigned char *num, int num_bytes, u8 amount)
-{
-	int i;
-
-	for (i = 0; i < num_bytes; i++) {
-		num[i] += amount;
-		if (num[i] >= amount)
-			break;
-		amount = 1;
-	}
-}
-
-int bcm_cmp_bytes(unsigned char *arg1, unsigned char *arg2, u8 nbytes)
-{
-	int i;
-
-	for (i = nbytes - 1; i >= 0; i--) {
-		if (arg1[i] != arg2[i])
-			return arg1[i] - arg2[i];
-	}
-	return 0;
-}
-
-void bcm_print_bytes(char *name, const unsigned char *data, int len)
-{
-	int i;
-	int per_line = 0;
-
-	printf("%s: %d\n", name ? name : "", len);
-	for (i = 0; i < len; i++) {
-		printf("%02x ", *data++);
-		per_line++;
-		if (per_line == 16) {
-			per_line = 0;
-			printf("\n");
-		}
-	}
-	printf("\n");
-}
-
-#if defined(BCMDBG)
-#define SSID_FMT_BUF_LEN	((4 * DOT11_MAX_SSID_LEN) + 1)
-int bcm_format_ssid(char *buf, const unsigned char ssid[], uint ssid_len)
-{
-	uint i, c;
-	char *p = buf;
-	char *endp = buf + SSID_FMT_BUF_LEN;
-
-	if (ssid_len > DOT11_MAX_SSID_LEN)
-		ssid_len = DOT11_MAX_SSID_LEN;
-
-	for (i = 0; i < ssid_len; i++) {
-		c = (uint) ssid[i];
-		if (c == '\\') {
-			*p++ = '\\';
-			*p++ = '\\';
-		} else if (isprint((unsigned char) c)) {
-			*p++ = (char)c;
-		} else {
-			p += snprintf(p, (endp - p), "\\x%02X", c);
-		}
-	}
-	*p = '\0';
-	ASSERT(p < endp);
-
-	return (int)(p - buf);
-}
-#endif				/* defined(BCMDBG) */

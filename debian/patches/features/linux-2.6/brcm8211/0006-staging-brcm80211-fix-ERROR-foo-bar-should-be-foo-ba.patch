commit 7cc4a4c02954afcd00abe5af81a4254d33a36e14
Author: Jason Cooper <jason@lakedaemon.net>
Date:   Tue Sep 14 09:45:30 2010 -0400

    staging: brcm80211: fix 'ERROR: "foo * bar" should be "foo *bar"'
    
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

--- a/drivers/staging/brcm80211/include/bcm_rpc.h
+++ b/drivers/staging/brcm80211/include/bcm_rpc.h
@@ -23,11 +23,11 @@
 typedef struct rpc_info rpc_info_t;
 typedef struct rpc_buf rpc_buf_t;
 struct rpc_transport_info;
-typedef void (*rpc_dispatch_cb_t) (void *ctx, struct rpc_buf * buf);
+typedef void (*rpc_dispatch_cb_t) (void *ctx, struct rpc_buf *buf);
 typedef void (*rpc_resync_cb_t) (void *ctx);
 typedef void (*rpc_down_cb_t) (void *ctx);
-typedef void (*rpc_txdone_cb_t) (void *ctx, struct rpc_buf * buf);
-extern struct rpc_info *bcm_rpc_attach(void *pdev, osl_t * osh,
+typedef void (*rpc_txdone_cb_t) (void *ctx, struct rpc_buf *buf);
+extern struct rpc_info *bcm_rpc_attach(void *pdev, osl_t *osh,
 				       struct rpc_transport_info *rpc_th);
 
 extern void bcm_rpc_detach(struct rpc_info *rpc);
@@ -65,9 +65,9 @@ extern uint bcm_rpc_buf_header_len(struc
 #define RPC_PKTLOG_SIZE		50	/* Depth of the history */
 #define RPC_PKTLOG_RD_LEN	3
 #define RPC_PKTLOG_DUMP_SIZE	150	/* dump size should be more than the product of above two */
-extern int bcm_rpc_pktlog_get(struct rpc_info *rpci, uint32 * buf,
+extern int bcm_rpc_pktlog_get(struct rpc_info *rpci, uint32 *buf,
 			      uint buf_size, bool send);
-extern int bcm_rpc_dump(rpc_info_t * rpci, struct bcmstrbuf *b);
+extern int bcm_rpc_dump(rpc_info_t *rpci, struct bcmstrbuf *b);
 
 /* HIGH/BMAC: bit 15-8: RPC module, bit 7-0: TP module */
 #define RPC_ERROR_VAL	0x0001
--- a/drivers/staging/brcm80211/include/bcm_rpc_tp.h
+++ b/drivers/staging/brcm80211/include/bcm_rpc_tp.h
@@ -57,66 +57,66 @@ typedef void (*rpc_rx_fn_t) (void *, rpc
 typedef void (*rpc_txflowctl_cb_t) (void *ctx, bool on);
 #endif
 
-extern rpc_tp_info_t *bcm_rpc_tp_attach(osl_t * osh, void *bus);
-extern void bcm_rpc_tp_detach(rpc_tp_info_t * rpcb);
-extern void bcm_rpc_tp_down(rpc_tp_info_t * rpcb);
-extern void bcm_rpc_tp_watchdog(rpc_tp_info_t * rpcb);
+extern rpc_tp_info_t *bcm_rpc_tp_attach(osl_t *osh, void *bus);
+extern void bcm_rpc_tp_detach(rpc_tp_info_t *rpcb);
+extern void bcm_rpc_tp_down(rpc_tp_info_t *rpcb);
+extern void bcm_rpc_tp_watchdog(rpc_tp_info_t *rpcb);
 
-extern int bcm_rpc_tp_buf_send(rpc_tp_info_t * rpcb, rpc_buf_t * buf);
+extern int bcm_rpc_tp_buf_send(rpc_tp_info_t *rpcb, rpc_buf_t *buf);
 
 /* callback for tx_complete, rx_pkt */
-extern void bcm_rpc_tp_register_cb(rpc_tp_info_t * rpcb,
+extern void bcm_rpc_tp_register_cb(rpc_tp_info_t *rpcb,
 				   rpc_tx_complete_fn_t txcmplt,
 				   void *tx_context, rpc_rx_fn_t rxpkt,
-				   void *rx_context, rpc_osl_t * rpc_osh);
-extern void bcm_rpc_tp_deregister_cb(rpc_tp_info_t * rpcb);
+				   void *rx_context, rpc_osl_t *rpc_osh);
+extern void bcm_rpc_tp_deregister_cb(rpc_tp_info_t *rpcb);
 
 /* Buffer manipulation */
-extern uint bcm_rpc_buf_tp_header_len(rpc_tp_info_t * rpcb);
-extern rpc_buf_t *bcm_rpc_tp_buf_alloc(rpc_tp_info_t * rpcb, int len);
-extern void bcm_rpc_tp_buf_free(rpc_tp_info_t * rpcb, rpc_buf_t * buf);
-extern int bcm_rpc_buf_len_get(rpc_tp_info_t * rpcb, rpc_buf_t * b);
-extern int bcm_rpc_buf_len_set(rpc_tp_info_t * rpcb, rpc_buf_t * b, uint len);
-extern rpc_buf_t *bcm_rpc_buf_next_get(rpc_tp_info_t * rpcb, rpc_buf_t * b);
-extern void bcm_rpc_buf_next_set(rpc_tp_info_t * rpcb, rpc_buf_t * b,
-				 rpc_buf_t * nextb);
-extern unsigned char *bcm_rpc_buf_data(rpc_tp_info_t * rpcb, rpc_buf_t * b);
-extern unsigned char *bcm_rpc_buf_push(rpc_tp_info_t * rpcb, rpc_buf_t * b,
+extern uint bcm_rpc_buf_tp_header_len(rpc_tp_info_t *rpcb);
+extern rpc_buf_t *bcm_rpc_tp_buf_alloc(rpc_tp_info_t *rpcb, int len);
+extern void bcm_rpc_tp_buf_free(rpc_tp_info_t *rpcb, rpc_buf_t *buf);
+extern int bcm_rpc_buf_len_get(rpc_tp_info_t *rpcb, rpc_buf_t *b);
+extern int bcm_rpc_buf_len_set(rpc_tp_info_t *rpcb, rpc_buf_t *b, uint len);
+extern rpc_buf_t *bcm_rpc_buf_next_get(rpc_tp_info_t *rpcb, rpc_buf_t *b);
+extern void bcm_rpc_buf_next_set(rpc_tp_info_t *rpcb, rpc_buf_t *b,
+				 rpc_buf_t *nextb);
+extern unsigned char *bcm_rpc_buf_data(rpc_tp_info_t *rpcb, rpc_buf_t *b);
+extern unsigned char *bcm_rpc_buf_push(rpc_tp_info_t *rpcb, rpc_buf_t *b,
 				       uint delta);
-extern unsigned char *bcm_rpc_buf_pull(rpc_tp_info_t * rpcb, rpc_buf_t * b,
+extern unsigned char *bcm_rpc_buf_pull(rpc_tp_info_t *rpcb, rpc_buf_t *b,
 				       uint delta);
-extern void bcm_rpc_tp_buf_release(rpc_tp_info_t * rpcb, rpc_buf_t * buf);
-extern void bcm_rpc_tp_buf_cnt_adjust(rpc_tp_info_t * rpcb, int adjust);
+extern void bcm_rpc_tp_buf_release(rpc_tp_info_t *rpcb, rpc_buf_t *buf);
+extern void bcm_rpc_tp_buf_cnt_adjust(rpc_tp_info_t *rpcb, int adjust);
 /* RPC call_with_return */
-extern int bcm_rpc_tp_recv_rtn(rpc_tp_info_t * rpcb);
-extern int bcm_rpc_tp_get_device_speed(rpc_tp_info_t * rpc_th);
+extern int bcm_rpc_tp_recv_rtn(rpc_tp_info_t *rpcb);
+extern int bcm_rpc_tp_get_device_speed(rpc_tp_info_t *rpc_th);
 #ifdef BCMDBG
-extern int bcm_rpc_tp_dump(rpc_tp_info_t * rpcb, struct bcmstrbuf *b);
+extern int bcm_rpc_tp_dump(rpc_tp_info_t *rpcb, struct bcmstrbuf *b);
 #endif
 
 #ifdef WLC_LOW
 /* intercept USB pkt to parse RPC header: USB driver rx-> wl_send -> this -> wl driver */
-extern void bcm_rpc_tp_rx_from_dnglbus(rpc_tp_info_t * rpc_th, struct lbuf *lb);
+extern void bcm_rpc_tp_rx_from_dnglbus(rpc_tp_info_t *rpc_th, struct lbuf *lb);
 
 /* RPC callreturn pkt, go to USB driver tx */
-extern int bcm_rpc_tp_send_callreturn(rpc_tp_info_t * rpc_th, rpc_buf_t * b);
+extern int bcm_rpc_tp_send_callreturn(rpc_tp_info_t *rpc_th, rpc_buf_t *b);
 
-extern void bcm_rpc_tp_dump(rpc_tp_info_t * rpcb);
-extern void bcm_rpc_tp_txflowctl(rpc_tp_info_t * rpcb, bool state, int prio);
-extern void bcm_rpc_tp_txflowctlcb_init(rpc_tp_info_t * rpc_th, void *ctx,
+extern void bcm_rpc_tp_dump(rpc_tp_info_t *rpcb);
+extern void bcm_rpc_tp_txflowctl(rpc_tp_info_t *rpcb, bool state, int prio);
+extern void bcm_rpc_tp_txflowctlcb_init(rpc_tp_info_t *rpc_th, void *ctx,
 					rpc_txflowctl_cb_t cb);
-extern void bcm_rpc_tp_txflowctlcb_deinit(rpc_tp_info_t * rpc_th);
-extern void bcm_rpc_tp_txq_wm_set(rpc_tp_info_t * rpc_th, uint8 hiwm,
+extern void bcm_rpc_tp_txflowctlcb_deinit(rpc_tp_info_t *rpc_th);
+extern void bcm_rpc_tp_txq_wm_set(rpc_tp_info_t *rpc_th, uint8 hiwm,
 				  uint8 lowm);
-extern void bcm_rpc_tp_txq_wm_get(rpc_tp_info_t * rpc_th, uint8 * hiwm,
-				  uint8 * lowm);
+extern void bcm_rpc_tp_txq_wm_get(rpc_tp_info_t *rpc_th, uint8 *hiwm,
+				  uint8 *lowm);
 #endif				/* WLC_LOW */
 
-extern void bcm_rpc_tp_agg_set(rpc_tp_info_t * rpcb, uint32 reason, bool set);
-extern void bcm_rpc_tp_agg_limit_set(rpc_tp_info_t * rpc_th, uint8 sf,
+extern void bcm_rpc_tp_agg_set(rpc_tp_info_t *rpcb, uint32 reason, bool set);
+extern void bcm_rpc_tp_agg_limit_set(rpc_tp_info_t *rpc_th, uint8 sf,
 				     uint16 bytes);
-extern void bcm_rpc_tp_agg_limit_get(rpc_tp_info_t * rpc_th, uint8 * sf,
-				     uint16 * bytes);
+extern void bcm_rpc_tp_agg_limit_get(rpc_tp_info_t *rpc_th, uint8 *sf,
+				     uint16 *bytes);
 
 #define BCM_RPC_TP_MSG_LEVEL_MASK	0x00ff
 /* dongle msg level */
@@ -131,7 +131,7 @@ extern void bcm_rpc_tp_agg_limit_get(rpc
 #define RPC_TP_MSG_HOST_AGG_VAL		0x0004	/* DNGL TP agg msg */
 #define RPC_TP_MSG_HOST_DEA_VAL		0x0008	/* DNGL TP deag msg */
 
-extern void bcm_rpc_tp_msglevel_set(rpc_tp_info_t * rpc_th, uint8 msglevel,
+extern void bcm_rpc_tp_msglevel_set(rpc_tp_info_t *rpc_th, uint8 msglevel,
 				    bool high_low);
 
 #endif				/* _bcm_rpc_tp_h_ */
--- a/drivers/staging/brcm80211/include/bcm_xdr.h
+++ b/drivers/staging/brcm80211/include/bcm_xdr.h
@@ -31,30 +31,30 @@ typedef struct {
 	uint origsize;		/* unmodified orignal buffer size in bytes */
 } bcm_xdr_buf_t;
 
-void bcm_xdr_buf_init(bcm_xdr_buf_t * b, void *buf, size_t len);
+void bcm_xdr_buf_init(bcm_xdr_buf_t *b, void *buf, size_t len);
 
-int bcm_xdr_pack_uint32(bcm_xdr_buf_t * b, uint32 val);
-int bcm_xdr_unpack_uint32(bcm_xdr_buf_t * b, uint32 * pval);
-int bcm_xdr_pack_int32(bcm_xdr_buf_t * b, int32 val);
-int bcm_xdr_unpack_int32(bcm_xdr_buf_t * b, int32 * pval);
-int bcm_xdr_pack_int8(bcm_xdr_buf_t * b, int8 val);
-int bcm_xdr_unpack_int8(bcm_xdr_buf_t * b, int8 * pval);
-int bcm_xdr_pack_opaque(bcm_xdr_buf_t * b, uint len, void *data);
-int bcm_xdr_unpack_opaque(bcm_xdr_buf_t * b, uint len, void **pdata);
-int bcm_xdr_unpack_opaque_cpy(bcm_xdr_buf_t * b, uint len, void *data);
-int bcm_xdr_pack_opaque_varlen(bcm_xdr_buf_t * b, uint len, void *data);
-int bcm_xdr_unpack_opaque_varlen(bcm_xdr_buf_t * b, uint * plen, void **pdata);
-int bcm_xdr_pack_string(bcm_xdr_buf_t * b, char *str);
-int bcm_xdr_unpack_string(bcm_xdr_buf_t * b, uint * plen, char **pstr);
+int bcm_xdr_pack_uint32(bcm_xdr_buf_t *b, uint32 val);
+int bcm_xdr_unpack_uint32(bcm_xdr_buf_t *b, uint32 *pval);
+int bcm_xdr_pack_int32(bcm_xdr_buf_t *b, int32 val);
+int bcm_xdr_unpack_int32(bcm_xdr_buf_t *b, int32 *pval);
+int bcm_xdr_pack_int8(bcm_xdr_buf_t *b, int8 val);
+int bcm_xdr_unpack_int8(bcm_xdr_buf_t *b, int8 *pval);
+int bcm_xdr_pack_opaque(bcm_xdr_buf_t *b, uint len, void *data);
+int bcm_xdr_unpack_opaque(bcm_xdr_buf_t *b, uint len, void **pdata);
+int bcm_xdr_unpack_opaque_cpy(bcm_xdr_buf_t *b, uint len, void *data);
+int bcm_xdr_pack_opaque_varlen(bcm_xdr_buf_t *b, uint len, void *data);
+int bcm_xdr_unpack_opaque_varlen(bcm_xdr_buf_t *b, uint *plen, void **pdata);
+int bcm_xdr_pack_string(bcm_xdr_buf_t *b, char *str);
+int bcm_xdr_unpack_string(bcm_xdr_buf_t *b, uint *plen, char **pstr);
 
-int bcm_xdr_pack_uint8_vec(bcm_xdr_buf_t *, uint8 * vec, uint32 elems);
-int bcm_xdr_unpack_uint8_vec(bcm_xdr_buf_t *, uint8 * vec, uint32 elems);
-int bcm_xdr_pack_uint16_vec(bcm_xdr_buf_t * b, uint len, void *vec);
-int bcm_xdr_unpack_uint16_vec(bcm_xdr_buf_t * b, uint len, void *vec);
-int bcm_xdr_pack_uint32_vec(bcm_xdr_buf_t * b, uint len, void *vec);
-int bcm_xdr_unpack_uint32_vec(bcm_xdr_buf_t * b, uint len, void *vec);
+int bcm_xdr_pack_uint8_vec(bcm_xdr_buf_t *, uint8 *vec, uint32 elems);
+int bcm_xdr_unpack_uint8_vec(bcm_xdr_buf_t *, uint8 *vec, uint32 elems);
+int bcm_xdr_pack_uint16_vec(bcm_xdr_buf_t *b, uint len, void *vec);
+int bcm_xdr_unpack_uint16_vec(bcm_xdr_buf_t *b, uint len, void *vec);
+int bcm_xdr_pack_uint32_vec(bcm_xdr_buf_t *b, uint len, void *vec);
+int bcm_xdr_unpack_uint32_vec(bcm_xdr_buf_t *b, uint len, void *vec);
 
-int bcm_xdr_pack_opaque_raw(bcm_xdr_buf_t * b, uint len, void *data);
-int bcm_xdr_pack_opaque_pad(bcm_xdr_buf_t * b);
+int bcm_xdr_pack_opaque_raw(bcm_xdr_buf_t *b, uint len, void *data);
+int bcm_xdr_pack_opaque_pad(bcm_xdr_buf_t *b);
 
 #endif				/* _BCM_XDR_H */
--- a/drivers/staging/brcm80211/include/bcmendian.h
+++ b/drivers/staging/brcm80211/include/bcmendian.h
@@ -219,7 +219,7 @@ static INLINE uint32 bcmswap32by16(uint3
 /* Reverse pairs of bytes in a buffer (not for high-performance use) */
 /* buf	- start of buffer of shorts to swap */
 /* len  - byte length of buffer */
-static INLINE void bcmswap16_buf(uint16 * buf, uint len)
+static INLINE void bcmswap16_buf(uint16 *buf, uint len)
 {
 	len = len / 2;
 
@@ -232,7 +232,7 @@ static INLINE void bcmswap16_buf(uint16
 /*
  * Store 16-bit value to unaligned little-endian byte array.
  */
-static INLINE void htol16_ua_store(uint16 val, uint8 * bytes)
+static INLINE void htol16_ua_store(uint16 val, uint8 *bytes)
 {
 	bytes[0] = val & 0xff;
 	bytes[1] = val >> 8;
@@ -241,7 +241,7 @@ static INLINE void htol16_ua_store(uint1
 /*
  * Store 32-bit value to unaligned little-endian byte array.
  */
-static INLINE void htol32_ua_store(uint32 val, uint8 * bytes)
+static INLINE void htol32_ua_store(uint32 val, uint8 *bytes)
 {
 	bytes[0] = val & 0xff;
 	bytes[1] = (val >> 8) & 0xff;
@@ -252,7 +252,7 @@ static INLINE void htol32_ua_store(uint3
 /*
  * Store 16-bit value to unaligned network-(big-)endian byte array.
  */
-static INLINE void hton16_ua_store(uint16 val, uint8 * bytes)
+static INLINE void hton16_ua_store(uint16 val, uint8 *bytes)
 {
 	bytes[0] = val >> 8;
 	bytes[1] = val & 0xff;
@@ -261,7 +261,7 @@ static INLINE void hton16_ua_store(uint1
 /*
  * Store 32-bit value to unaligned network-(big-)endian byte array.
  */
-static INLINE void hton32_ua_store(uint32 val, uint8 * bytes)
+static INLINE void hton32_ua_store(uint32 val, uint8 *bytes)
 {
 	bytes[0] = val >> 24;
 	bytes[1] = (val >> 16) & 0xff;
--- a/drivers/staging/brcm80211/include/bcmotp.h
+++ b/drivers/staging/brcm80211/include/bcmotp.h
@@ -37,8 +37,8 @@
 extern int otp_status(void *oh);
 extern int otp_size(void *oh);
 extern uint16 otp_read_bit(void *oh, uint offset);
-extern void *otp_init(si_t * sih);
-extern int otp_read_region(si_t * sih, int region, uint16 * data, uint * wlen);
-extern int otp_nvread(void *oh, char *data, uint * len);
+extern void *otp_init(si_t *sih);
+extern int otp_read_region(si_t *sih, int region, uint16 *data, uint *wlen);
+extern int otp_nvread(void *oh, char *data, uint *len);
 
 #endif				/* _bcmotp_h_ */
--- a/drivers/staging/brcm80211/include/bcmsdbus.h
+++ b/drivers/staging/brcm80211/include/bcmsdbus.h
@@ -46,68 +46,68 @@ typedef void (*sdioh_cb_fn_t) (void *);
  *  The handler shall be provided by all subsequent calls. No local cache
  *  cfghdl points to the starting address of pci device mapped memory
  */
-extern sdioh_info_t *sdioh_attach(osl_t * osh, void *cfghdl, uint irq);
-extern SDIOH_API_RC sdioh_detach(osl_t * osh, sdioh_info_t * si);
-extern SDIOH_API_RC sdioh_interrupt_register(sdioh_info_t * si,
+extern sdioh_info_t *sdioh_attach(osl_t *osh, void *cfghdl, uint irq);
+extern SDIOH_API_RC sdioh_detach(osl_t *osh, sdioh_info_t *si);
+extern SDIOH_API_RC sdioh_interrupt_register(sdioh_info_t *si,
 					     sdioh_cb_fn_t fn, void *argh);
-extern SDIOH_API_RC sdioh_interrupt_deregister(sdioh_info_t * si);
+extern SDIOH_API_RC sdioh_interrupt_deregister(sdioh_info_t *si);
 
 /* query whether SD interrupt is enabled or not */
-extern SDIOH_API_RC sdioh_interrupt_query(sdioh_info_t * si, bool * onoff);
+extern SDIOH_API_RC sdioh_interrupt_query(sdioh_info_t *si, bool *onoff);
 
 /* enable or disable SD interrupt */
-extern SDIOH_API_RC sdioh_interrupt_set(sdioh_info_t * si, bool enable_disable);
+extern SDIOH_API_RC sdioh_interrupt_set(sdioh_info_t *si, bool enable_disable);
 
 #if defined(BCMDBG)
-extern bool sdioh_interrupt_pending(sdioh_info_t * si);
+extern bool sdioh_interrupt_pending(sdioh_info_t *si);
 #endif
 
-extern int sdioh_claim_host_and_lock(sdioh_info_t * si);
-extern int sdioh_release_host_and_unlock(sdioh_info_t * si);
+extern int sdioh_claim_host_and_lock(sdioh_info_t *si);
+extern int sdioh_release_host_and_unlock(sdioh_info_t *si);
 
 /* read or write one byte using cmd52 */
-extern SDIOH_API_RC sdioh_request_byte(sdioh_info_t * si, uint rw, uint fnc,
-				       uint addr, uint8 * byte);
+extern SDIOH_API_RC sdioh_request_byte(sdioh_info_t *si, uint rw, uint fnc,
+				       uint addr, uint8 *byte);
 
 /* read or write 2/4 bytes using cmd53 */
-extern SDIOH_API_RC sdioh_request_word(sdioh_info_t * si, uint cmd_type,
+extern SDIOH_API_RC sdioh_request_word(sdioh_info_t *si, uint cmd_type,
 				       uint rw, uint fnc, uint addr,
-				       uint32 * word, uint nbyte);
+				       uint32 *word, uint nbyte);
 
 /* read or write any buffer using cmd53 */
-extern SDIOH_API_RC sdioh_request_buffer(sdioh_info_t * si, uint pio_dma,
+extern SDIOH_API_RC sdioh_request_buffer(sdioh_info_t *si, uint pio_dma,
 					 uint fix_inc, uint rw, uint fnc_num,
 					 uint32 addr, uint regwidth,
-					 uint32 buflen, uint8 * buffer,
+					 uint32 buflen, uint8 *buffer,
 					 void *pkt);
 
 /* get cis data */
-extern SDIOH_API_RC sdioh_cis_read(sdioh_info_t * si, uint fuc, uint8 * cis,
+extern SDIOH_API_RC sdioh_cis_read(sdioh_info_t *si, uint fuc, uint8 *cis,
 				   uint32 length);
 
-extern SDIOH_API_RC sdioh_cfg_read(sdioh_info_t * si, uint fuc, uint32 addr,
-				   uint8 * data);
-extern SDIOH_API_RC sdioh_cfg_write(sdioh_info_t * si, uint fuc, uint32 addr,
-				    uint8 * data);
+extern SDIOH_API_RC sdioh_cfg_read(sdioh_info_t *si, uint fuc, uint32 addr,
+				   uint8 *data);
+extern SDIOH_API_RC sdioh_cfg_write(sdioh_info_t *si, uint fuc, uint32 addr,
+				    uint8 *data);
 
 /* query number of io functions */
-extern uint sdioh_query_iofnum(sdioh_info_t * si);
+extern uint sdioh_query_iofnum(sdioh_info_t *si);
 
 /* handle iovars */
-extern int sdioh_iovar_op(sdioh_info_t * si, const char *name,
+extern int sdioh_iovar_op(sdioh_info_t *si, const char *name,
 			  void *params, int plen, void *arg, int len, bool set);
 
 /* Issue abort to the specified function and clear controller as needed */
-extern int sdioh_abort(sdioh_info_t * si, uint fnc);
+extern int sdioh_abort(sdioh_info_t *si, uint fnc);
 
 /* Start and Stop SDIO without re-enumerating the SD card. */
-extern int sdioh_start(sdioh_info_t * si, int stage);
-extern int sdioh_stop(sdioh_info_t * si);
+extern int sdioh_start(sdioh_info_t *si, int stage);
+extern int sdioh_stop(sdioh_info_t *si);
 
 /* Reset and re-initialize the device */
-extern int sdioh_sdio_reset(sdioh_info_t * si);
+extern int sdioh_sdio_reset(sdioh_info_t *si);
 
 /* Helper function */
-void *bcmsdh_get_sdioh(bcmsdh_info_t * sdh);
+void *bcmsdh_get_sdioh(bcmsdh_info_t *sdh);
 
 #endif				/* _sdio_api_h_ */
--- a/drivers/staging/brcm80211/include/bcmsdh.h
+++ b/drivers/staging/brcm80211/include/bcmsdh.h
@@ -40,11 +40,11 @@ typedef void (*bcmsdh_cb_fn_t) (void *);
  *    implementation may maintain a single "default" handle (e.g. the first or
  *    most recent one) to enable single-instance implementations to pass NULL.
  */
-extern bcmsdh_info_t *bcmsdh_attach(osl_t * osh, void *cfghdl, void **regsva,
+extern bcmsdh_info_t *bcmsdh_attach(osl_t *osh, void *cfghdl, void **regsva,
 				    uint irq);
 
 /* Detach - freeup resources allocated in attach */
-extern int bcmsdh_detach(osl_t * osh, void *sdh);
+extern int bcmsdh_detach(osl_t *osh, void *sdh);
 
 /* Query if SD device interrupts are enabled */
 extern bool bcmsdh_intr_query(void *sdh);
@@ -92,7 +92,7 @@ extern void bcmsdh_cfg_write_word(void *
  * Internally, this routine uses the values from the cis base regs (0x9-0xB)
  * to form an SDIO-space address to read the data from.
  */
-extern int bcmsdh_cis_read(void *sdh, uint func, uint8 * cis, uint length);
+extern int bcmsdh_cis_read(void *sdh, uint func, uint8 *cis, uint length);
 
 /* Synchronous access to device (client) core registers via CMD53 to F1.
  *   addr: backplane address (i.e. >= regsva from attach)
@@ -119,10 +119,10 @@ extern bool bcmsdh_regfail(void *sdh);
  */
 typedef void (*bcmsdh_cmplt_fn_t) (void *handle, int status, bool sync_waiting);
 extern int bcmsdh_send_buf(void *sdh, uint32 addr, uint fn, uint flags,
-			   uint8 * buf, uint nbytes, void *pkt,
+			   uint8 *buf, uint nbytes, void *pkt,
 			   bcmsdh_cmplt_fn_t complete, void *handle);
 extern int bcmsdh_recv_buf(void *sdh, uint32 addr, uint fn, uint flags,
-			   uint8 * buf, uint nbytes, void *pkt,
+			   uint8 *buf, uint nbytes, void *pkt,
 			   bcmsdh_cmplt_fn_t complete, void *handle);
 
 /* Flags bits */
@@ -140,7 +140,7 @@ extern int bcmsdh_recv_buf(void *sdh, ui
  *   nbytes:   number of bytes to transfer to/from buf
  * Returns 0 or error code.
  */
-extern int bcmsdh_rwdata(void *sdh, uint rw, uint32 addr, uint8 * buf,
+extern int bcmsdh_rwdata(void *sdh, uint rw, uint32 addr, uint8 *buf,
 			 uint nbytes);
 
 /* Issue an abort to the specified function */
@@ -164,24 +164,24 @@ extern int bcmsdh_iovar_op(void *sdh, co
 			   bool set);
 
 /* Reset and reinitialize the device */
-extern int bcmsdh_reset(bcmsdh_info_t * sdh);
+extern int bcmsdh_reset(bcmsdh_info_t *sdh);
 
 /* helper functions */
 
-extern void *bcmsdh_get_sdioh(bcmsdh_info_t * sdh);
+extern void *bcmsdh_get_sdioh(bcmsdh_info_t *sdh);
 
 /* callback functions */
 typedef struct {
 	/* attach to device */
 	void *(*attach) (uint16 vend_id, uint16 dev_id, uint16 bus, uint16 slot,
-			 uint16 func, uint bustype, void *regsva, osl_t * osh,
+			 uint16 func, uint bustype, void *regsva, osl_t *osh,
 			 void *param);
 	/* detach from device */
 	void (*detach) (void *ch);
 } bcmsdh_driver_t;
 
 /* platform specific/high level functions */
-extern int bcmsdh_register(bcmsdh_driver_t * driver);
+extern int bcmsdh_register(bcmsdh_driver_t *driver);
 extern void bcmsdh_unregister(void);
 extern bool bcmsdh_chipmatch(uint16 vendor, uint16 device);
 extern void bcmsdh_device_remove(void *sdh);
--- a/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
+++ b/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
@@ -34,8 +34,8 @@
 #endif
 
 /* Allocate/init/free per-OS private data */
-extern int sdioh_sdmmc_osinit(sdioh_info_t * sd);
-extern void sdioh_sdmmc_osfree(sdioh_info_t * sd);
+extern int sdioh_sdmmc_osinit(sdioh_info_t *sd);
+extern void sdioh_sdmmc_osfree(sdioh_info_t *sd);
 
 #define BLOCK_SIZE_64 64
 #define BLOCK_SIZE_512 512
@@ -81,23 +81,23 @@ struct sdioh_info {
 extern uint sd_msglevel;
 
 /* OS-independent interrupt handler */
-extern bool check_client_intr(sdioh_info_t * sd);
+extern bool check_client_intr(sdioh_info_t *sd);
 
 /* Core interrupt enable/disable of device interrupts */
-extern void sdioh_sdmmc_devintr_on(sdioh_info_t * sd);
-extern void sdioh_sdmmc_devintr_off(sdioh_info_t * sd);
+extern void sdioh_sdmmc_devintr_on(sdioh_info_t *sd);
+extern void sdioh_sdmmc_devintr_off(sdioh_info_t *sd);
 
 /**************************************************************
  * Internal interfaces: bcmsdh_sdmmc.c references to per-port code
  */
 
 /* Register mapping routines */
-extern uint32 *sdioh_sdmmc_reg_map(osl_t * osh, int32 addr, int size);
-extern void sdioh_sdmmc_reg_unmap(osl_t * osh, int32 addr, int size);
+extern uint32 *sdioh_sdmmc_reg_map(osl_t *osh, int32 addr, int size);
+extern void sdioh_sdmmc_reg_unmap(osl_t *osh, int32 addr, int size);
 
 /* Interrupt (de)registration routines */
-extern int sdioh_sdmmc_register_irq(sdioh_info_t * sd, uint irq);
-extern void sdioh_sdmmc_free_irq(uint irq, sdioh_info_t * sd);
+extern int sdioh_sdmmc_register_irq(sdioh_info_t *sd, uint irq);
+extern void sdioh_sdmmc_free_irq(uint irq, sdioh_info_t *sd);
 
 typedef struct _BCMSDH_SDMMC_INSTANCE {
 	sdioh_info_t *sd;
--- a/drivers/staging/brcm80211/include/bcmsrom.h
+++ b/drivers/staging/brcm80211/include/bcmsrom.h
@@ -20,15 +20,15 @@
 #include <bcmsrom_fmt.h>
 
 /* Prototypes */
-extern int srom_var_init(si_t * sih, uint bus, void *curmap, osl_t * osh,
-			 char **vars, uint * count);
+extern int srom_var_init(si_t *sih, uint bus, void *curmap, osl_t *osh,
+			 char **vars, uint *count);
 
-extern int srom_read(si_t * sih, uint bus, void *curmap, osl_t * osh,
-		     uint byteoff, uint nbytes, uint16 * buf, bool check_crc);
+extern int srom_read(si_t *sih, uint bus, void *curmap, osl_t *osh,
+		     uint byteoff, uint nbytes, uint16 *buf, bool check_crc);
 
 /* parse standard PCMCIA cis, normally used by SB/PCMCIA/SDIO/SPI/OTP
  *   and extract from it into name=value pairs
  */
-extern int srom_parsecis(osl_t * osh, uint8 ** pcis, uint ciscnt,
-			 char **vars, uint * count);
+extern int srom_parsecis(osl_t *osh, uint8 **pcis, uint ciscnt,
+			 char **vars, uint *count);
 #endif				/* _bcmsrom_h_ */
--- a/drivers/staging/brcm80211/include/bcmutils.h
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -141,7 +141,7 @@ extern "C" {
 	extern void *pktq_pdeq(struct pktq *pq, int prec);
 	extern void *pktq_pdeq_tail(struct pktq *pq, int prec);
 /* Empty the queue at particular precedence level */
-	extern void pktq_pflush(osl_t * osh, struct pktq *pq, int prec,
+	extern void pktq_pflush(osl_t *osh, struct pktq *pq, int prec,
 				bool dir, ifpkt_cb_t fn, int arg);
 /* Remove a specified packet from its queue */
 	extern bool pktq_pdel(struct pktq *pq, void *p, int prec);
@@ -172,18 +172,18 @@ extern "C" {
 	extern void *pktq_deq_tail(struct pktq *pq, int *prec_out);
 	extern void *pktq_peek(struct pktq *pq, int *prec_out);
 	extern void *pktq_peek_tail(struct pktq *pq, int *prec_out);
-	extern void pktq_flush(osl_t * osh, struct pktq *pq, bool dir,
+	extern void pktq_flush(osl_t *osh, struct pktq *pq, bool dir,
 			       ifpkt_cb_t fn, int arg);
 
 /* externs */
 /* packet */
-	extern uint pktcopy(osl_t * osh, void *p, uint offset, int len,
-			    uchar * buf);
-	extern uint pktfrombuf(osl_t * osh, void *p, uint offset, int len,
-			       uchar * buf);
-	extern uint pkttotlen(osl_t * osh, void *p);
-	extern void *pktlast(osl_t * osh, void *p);
-	extern uint pktsegcnt(osl_t * osh, void *p);
+	extern uint pktcopy(osl_t *osh, void *p, uint offset, int len,
+			    uchar *buf);
+	extern uint pktfrombuf(osl_t *osh, void *p, uint offset, int len,
+			       uchar *buf);
+	extern uint pkttotlen(osl_t *osh, void *p);
+	extern void *pktlast(osl_t *osh, void *p);
+	extern uint pktsegcnt(osl_t *osh, void *p);
 
 /* Get priority from a packet and pass it back in scb (or equiv) */
 	extern uint pktsetprio(void *pkt, bool update_vtag);
@@ -199,7 +199,7 @@ extern "C" {
 	extern char *BCMROMFN(bcmstrcat) (char *dest, const char *src);
 	extern char *BCMROMFN(bcmstrncat) (char *dest, const char *src,
 					   uint size);
-	extern ulong wchar2ascii(char *abuf, ushort * wbuf, ushort wbuflen,
+	extern ulong wchar2ascii(char *abuf, ushort *wbuf, ushort wbuflen,
 				 ulong abuflen);
 	char *bcmstrtok(char **string, const char *delimiters, char *tokdelim);
 	int bcmstricmp(const char *s1, const char *s2);
@@ -207,7 +207,7 @@ extern "C" {
 
 /* ethernet address */
 	extern char *bcm_ether_ntoa(const struct ether_addr *ea, char *buf);
-	extern int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr * ea);
+	extern int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr *ea);
 
 /* ip address */
 	struct ipv4_addr;
@@ -221,7 +221,7 @@ extern "C" {
 	extern int getintvararray(char *vars, const char *name, uint8 index);
 	extern uint getgpiopin(char *vars, char *pin_name, uint def_pin);
 #ifdef BCMDBG
-	extern void prpkt(const char *msg, osl_t * osh, void *p0);
+	extern void prpkt(const char *msg, osl_t *osh, void *p0);
 #endif				/* BCMDBG */
 #define bcm_perf_enable()
 #define bcmstats(fmt)
@@ -233,7 +233,7 @@ extern "C" {
 #define bcmprinttslogs()
 #define bcmprinttstamp(us)
 
-	extern char *bcm_nvram_vars(uint * length);
+	extern char *bcm_nvram_vars(uint *length);
 	extern int bcm_nvram_cache(void *sih);
 
 /* Support for sharing code across in-driver iovar implementations.
@@ -266,9 +266,9 @@ extern "C" {
 
 /* flags are per-driver based on driver attributes */
 
-	extern const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t * table,
+	extern const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t *table,
 						   const char *name);
-	extern int bcm_iovar_lencheck(const bcm_iovar_t * table, void *arg,
+	extern int bcm_iovar_lencheck(const bcm_iovar_t *table, void *arg,
 				      int len, bool set);
 #if defined(BCMDBG)
 	extern int bcm_format_ssid(char *buf, const uchar ssid[],
@@ -506,7 +506,7 @@ extern "C" {
 /* crypto utility function */
 /* 128-bit xor: *dst = *src1 xor *src2. dst1, src1 and src2 may have any alignment */
 	static INLINE void
-	 xor_128bit_block(const uint8 * src1, const uint8 * src2, uint8 * dst) {
+	 xor_128bit_block(const uint8 *src1, const uint8 *src2, uint8 *dst) {
 		if (
 #ifdef __i386__
 			   1 ||
@@ -537,11 +537,11 @@ extern "C" {
 
 /* externs */
 /* crc */
-	extern uint8 BCMROMFN(hndcrc8) (uint8 * p, uint nbytes, uint8 crc);
-	extern uint16 BCMROMFN(hndcrc16) (uint8 * p, uint nbytes, uint16 crc);
+	extern uint8 BCMROMFN(hndcrc8) (uint8 *p, uint nbytes, uint8 crc);
+	extern uint16 BCMROMFN(hndcrc16) (uint8 *p, uint nbytes, uint16 crc);
 /* format/print */
 #if defined(BCMDBG)
-	extern int bcm_format_flags(const bcm_bit_desc_t * bd, uint32 flags,
+	extern int bcm_format_flags(const bcm_bit_desc_t *bd, uint32 flags,
 				    char *buf, int len);
 	extern int bcm_format_hex(char *str, const void *bytes, int len);
 #endif
@@ -552,10 +552,10 @@ extern "C" {
 	extern char *bcm_chipname(uint chipid, char *buf, uint len);
 	extern char *bcm_brev_str(uint32 brev, char *buf);
 	extern void printbig(char *buf);
-	extern void prhex(const char *msg, uchar * buf, uint len);
+	extern void prhex(const char *msg, uchar *buf, uint len);
 
 /* IE parsing */
-	extern bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t * elt, int *buflen);
+	extern bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t *elt, int *buflen);
 	extern bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (void *buf, int buflen,
 						    uint key);
 	extern bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tlvs) (void *buf,
@@ -585,9 +585,9 @@ extern "C" {
 
 	extern void bcm_binit(struct bcmstrbuf *b, char *buf, uint size);
 	extern int bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...);
-	extern void bcm_inc_bytes(uchar * num, int num_bytes, uint8 amount);
-	extern int bcm_cmp_bytes(uchar * arg1, uchar * arg2, uint8 nbytes);
-	extern void bcm_print_bytes(char *name, const uchar * cdata, int len);
+	extern void bcm_inc_bytes(uchar *num, int num_bytes, uint8 amount);
+	extern int bcm_cmp_bytes(uchar *arg1, uchar *arg2, uint8 nbytes);
+	extern void bcm_print_bytes(char *name, const uchar *cdata, int len);
 
 	typedef uint32(*bcmutl_rdreg_rtn) (void *arg0, uint arg1,
 					   uint32 offset);
@@ -597,7 +597,7 @@ extern "C" {
 
 	extern uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf,
 				uint len);
-	extern uint BCMROMFN(bcm_bitcount) (uint8 * bitmap, uint bytelength);
+	extern uint BCMROMFN(bcm_bitcount) (uint8 *bitmap, uint bytelength);
 
 #ifdef __cplusplus
 }
--- a/drivers/staging/brcm80211/include/bcmwpa.h
+++ b/drivers/staging/brcm80211/include/bcmwpa.h
@@ -75,10 +75,10 @@
 			WPA_CIPHER_NONE)
 
 /* Look for a WPA IE; return it's address if found, NULL otherwise */
-extern wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (uint8 * parse, uint len);
+extern wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (uint8 *parse, uint len);
 
 /* Check whether the given IE looks like WFA IE with the specific type. */
-extern bool bcm_is_wfa_ie(uint8 * ie, uint8 ** tlvs, uint * tlvs_len,
+extern bool bcm_is_wfa_ie(uint8 *ie, uint8 **tlvs, uint *tlvs_len,
 			  uint8 type);
 /* Check whether pointed-to IE looks like WPA. */
 #define bcm_is_wpa_ie(ie, tlvs, len)	bcm_is_wfa_ie(ie, tlvs, len, WFA_OUI_TYPE_WPA)
--- a/drivers/staging/brcm80211/include/dbus.h
+++ b/drivers/staging/brcm80211/include/dbus.h
@@ -130,12 +130,12 @@ struct exec_parms;
 typedef void *(*probe_cb_t) (void *arg, const char *desc, uint32 bustype,
 			     uint32 hdrlen);
 typedef void (*disconnect_cb_t) (void *arg);
-typedef void *(*exec_cb_t) (struct exec_parms * args);
+typedef void *(*exec_cb_t) (struct exec_parms *args);
 
 /* Client callbacks registered during dbus_attach() */
 typedef struct dbus_callbacks {
 	void (*send_complete) (void *cbarg, void *info, int status);
-	void (*recv_buf) (void *cbarg, uint8 * buf, int len);
+	void (*recv_buf) (void *cbarg, uint8 *buf, int len);
 	void (*recv_pkt) (void *cbarg, void *pkt);
 	void (*txflowcontrol) (void *cbarg, bool onoff);
 	void (*errhandler) (void *cbarg, int err);
@@ -153,19 +153,19 @@ struct dbus_irb_tx;
 struct dbus_intf_callbacks;
 
 typedef struct {
-	void *(*attach) (struct dbus_pub * pub, void *cbarg,
-			 struct dbus_intf_callbacks * cbs);
-	void (*detach) (struct dbus_pub * pub, void *bus);
+	void *(*attach) (struct dbus_pub *pub, void *cbarg,
+			 struct dbus_intf_callbacks *cbs);
+	void (*detach) (struct dbus_pub *pub, void *bus);
 
 	int (*up) (void *bus);
 	int (*down) (void *bus);
-	int (*send_irb) (void *bus, struct dbus_irb_tx * txirb);
-	int (*recv_irb) (void *bus, struct dbus_irb_rx * rxirb);
-	int (*cancel_irb) (void *bus, struct dbus_irb_tx * txirb);
-	int (*send_ctl) (void *bus, uint8 * buf, int len);
-	int (*recv_ctl) (void *bus, uint8 * buf, int len);
-	int (*get_stats) (void *bus, dbus_stats_t * stats);
-	int (*get_attrib) (void *bus, dbus_attrib_t * attrib);
+	int (*send_irb) (void *bus, struct dbus_irb_tx *txirb);
+	int (*recv_irb) (void *bus, struct dbus_irb_rx *rxirb);
+	int (*cancel_irb) (void *bus, struct dbus_irb_tx *txirb);
+	int (*send_ctl) (void *bus, uint8 *buf, int len);
+	int (*recv_ctl) (void *bus, uint8 *buf, int len);
+	int (*get_stats) (void *bus, dbus_stats_t *stats);
+	int (*get_attrib) (void *bus, dbus_attrib_t *attrib);
 
 	int (*pnp) (void *bus, int event);
 	int (*remove) (void *bus);
@@ -180,20 +180,20 @@ typedef struct {
 
 	int (*iovar_op) (void *bus, const char *name, void *params, int plen,
 			 void *arg, int len, bool set);
-	void (*dump) (void *bus, struct bcmstrbuf * strbuf);
-	int (*set_config) (void *bus, dbus_config_t * config);
-	int (*get_config) (void *bus, dbus_config_t * config);
+	void (*dump) (void *bus, struct bcmstrbuf *strbuf);
+	int (*set_config) (void *bus, dbus_config_t *config);
+	int (*get_config) (void *bus, dbus_config_t *config);
 
 	 bool(*device_exists) (void *bus);
 	 bool(*dlneeded) (void *bus);
-	int (*dlstart) (void *bus, uint8 * fw, int len);
+	int (*dlstart) (void *bus, uint8 *fw, int len);
 	int (*dlrun) (void *bus);
 	 bool(*recv_needed) (void *bus);
 
 	void *(*exec_rxlock) (void *bus, exec_cb_t func,
-			      struct exec_parms * args);
+			      struct exec_parms *args);
 	void *(*exec_txlock) (void *bus, exec_cb_t func,
-			      struct exec_parms * args);
+			      struct exec_parms *args);
 
 	int (*tx_timer_init) (void *bus);
 	int (*tx_timer_start) (void *bus, uint timeout);
@@ -235,40 +235,40 @@ extern int dbus_deregister(void);
 
 extern const dbus_pub_t *dbus_attach(struct osl_info *osh, int rxsize, int nrxq,
 				     int ntxq, void *cbarg,
-				     dbus_callbacks_t * cbs,
+				     dbus_callbacks_t *cbs,
 				     struct shared_info *sh);
-extern void dbus_detach(const dbus_pub_t * pub);
+extern void dbus_detach(const dbus_pub_t *pub);
 
-extern int dbus_up(const dbus_pub_t * pub);
-extern int dbus_down(const dbus_pub_t * pub);
-extern int dbus_stop(const dbus_pub_t * pub);
-extern int dbus_shutdown(const dbus_pub_t * pub);
-extern void dbus_flowctrl_rx(const dbus_pub_t * pub, bool on);
+extern int dbus_up(const dbus_pub_t *pub);
+extern int dbus_down(const dbus_pub_t *pub);
+extern int dbus_stop(const dbus_pub_t *pub);
+extern int dbus_shutdown(const dbus_pub_t *pub);
+extern void dbus_flowctrl_rx(const dbus_pub_t *pub, bool on);
 
-extern int dbus_send_buf(const dbus_pub_t * pub, uint8 * buf, int len,
+extern int dbus_send_buf(const dbus_pub_t *pub, uint8 *buf, int len,
 			 void *info);
-extern int dbus_send_pkt(const dbus_pub_t * pub, void *pkt, void *info);
-extern int dbus_send_ctl(const dbus_pub_t * pub, uint8 * buf, int len);
-extern int dbus_recv_ctl(const dbus_pub_t * pub, uint8 * buf, int len);
-
-extern int dbus_get_stats(const dbus_pub_t * pub, dbus_stats_t * stats);
-extern int dbus_get_attrib(const dbus_pub_t * pub, dbus_attrib_t * attrib);
-extern int dbus_get_device_speed(const dbus_pub_t * pub);
-extern int dbus_set_config(const dbus_pub_t * pub, dbus_config_t * config);
-extern int dbus_get_config(const dbus_pub_t * pub, dbus_config_t * config);
-
-extern void *dbus_pktget(const dbus_pub_t * pub, int len);
-extern void dbus_pktfree(const dbus_pub_t * pub, void *pkt);
-
-extern int dbus_set_errmask(const dbus_pub_t * pub, uint32 mask);
-extern int dbus_pnp_sleep(const dbus_pub_t * pub);
-extern int dbus_pnp_resume(const dbus_pub_t * pub, int *fw_reload);
-extern int dbus_pnp_disconnect(const dbus_pub_t * pub);
+extern int dbus_send_pkt(const dbus_pub_t *pub, void *pkt, void *info);
+extern int dbus_send_ctl(const dbus_pub_t *pub, uint8 *buf, int len);
+extern int dbus_recv_ctl(const dbus_pub_t *pub, uint8 *buf, int len);
+
+extern int dbus_get_stats(const dbus_pub_t *pub, dbus_stats_t *stats);
+extern int dbus_get_attrib(const dbus_pub_t *pub, dbus_attrib_t *attrib);
+extern int dbus_get_device_speed(const dbus_pub_t *pub);
+extern int dbus_set_config(const dbus_pub_t *pub, dbus_config_t *config);
+extern int dbus_get_config(const dbus_pub_t *pub, dbus_config_t *config);
+
+extern void *dbus_pktget(const dbus_pub_t *pub, int len);
+extern void dbus_pktfree(const dbus_pub_t *pub, void *pkt);
+
+extern int dbus_set_errmask(const dbus_pub_t *pub, uint32 mask);
+extern int dbus_pnp_sleep(const dbus_pub_t *pub);
+extern int dbus_pnp_resume(const dbus_pub_t *pub, int *fw_reload);
+extern int dbus_pnp_disconnect(const dbus_pub_t *pub);
 
-extern int dbus_iovar_op(const dbus_pub_t * pub, const char *name,
+extern int dbus_iovar_op(const dbus_pub_t *pub, const char *name,
 			 void *params, int plen, void *arg, int len, bool set);
 #ifdef BCMDBG
-extern void dbus_hist_dump(const dbus_pub_t * pub, struct bcmstrbuf *b);
+extern void dbus_hist_dump(const dbus_pub_t *pub, struct bcmstrbuf *b);
 #endif				/* BCMDBG */
 /*
  * Private Common Bus Interface
@@ -303,15 +303,15 @@ typedef struct dbus_irb_tx {
  * so, internally, different info can be passed to upper layer
  */
 typedef struct dbus_intf_callbacks {
-	void (*send_irb_timeout) (void *cbarg, dbus_irb_tx_t * txirb);
-	void (*send_irb_complete) (void *cbarg, dbus_irb_tx_t * txirb,
+	void (*send_irb_timeout) (void *cbarg, dbus_irb_tx_t *txirb);
+	void (*send_irb_complete) (void *cbarg, dbus_irb_tx_t *txirb,
 				   int status);
-	void (*recv_irb_complete) (void *cbarg, dbus_irb_rx_t * rxirb,
+	void (*recv_irb_complete) (void *cbarg, dbus_irb_rx_t *rxirb,
 				   int status);
 	void (*errhandler) (void *cbarg, int err);
 	void (*ctl_complete) (void *cbarg, int type, int status);
 	void (*state_change) (void *cbarg, int state);
-	 bool(*isr) (void *cbarg, bool * wantdpc);
+	 bool(*isr) (void *cbarg, bool *wantdpc);
 	 bool(*dpc) (void *cbarg, bool bounded);
 	void (*watchdog) (void *cbarg);
 	void *(*pktget) (void *cbarg, uint len, bool send);
@@ -330,7 +330,7 @@ typedef struct dbus_intf_callbacks {
  */
 extern int dbus_bus_register(int vid, int pid, probe_cb_t prcb,
 			     disconnect_cb_t discb, void *prarg,
-			     dbus_intf_t ** intf, void *param1, void *param2);
+			     dbus_intf_t **intf, void *param1, void *param2);
 extern int dbus_bus_deregister(void);
 
 /*
@@ -339,7 +339,7 @@ extern int dbus_bus_deregister(void);
  */
 extern int dbus_bus_osl_register(int vid, int pid, probe_cb_t prcb,
 				 disconnect_cb_t discb, void *prarg,
-				 dbus_intf_t ** intf, void *param1,
+				 dbus_intf_t **intf, void *param1,
 				 void *param2);
 extern int dbus_bus_osl_deregister(void);
 
@@ -349,7 +349,7 @@ extern int dbus_bus_osl_deregister(void)
  */
 extern int dbus_bus_osl_hw_register(int vid, int pid, probe_cb_t prcb,
 				    disconnect_cb_t discb, void *prarg,
-				    dbus_intf_t ** intf);
+				    dbus_intf_t **intf);
 extern int dbus_bus_osl_hw_deregister(void);
 
 #endif				/* __DBUS_H__ */
--- a/drivers/staging/brcm80211/include/hnddma.h
+++ b/drivers/staging/brcm80211/include/hnddma.h
@@ -30,52 +30,52 @@ typedef enum txd_range {
 } txd_range_t;
 
 /* dma function type */
-typedef void (*di_detach_t) (hnddma_t * dmah);
-typedef bool(*di_txreset_t) (hnddma_t * dmah);
-typedef bool(*di_rxreset_t) (hnddma_t * dmah);
-typedef bool(*di_rxidle_t) (hnddma_t * dmah);
-typedef void (*di_txinit_t) (hnddma_t * dmah);
-typedef bool(*di_txenabled_t) (hnddma_t * dmah);
-typedef void (*di_rxinit_t) (hnddma_t * dmah);
-typedef void (*di_txsuspend_t) (hnddma_t * dmah);
-typedef void (*di_txresume_t) (hnddma_t * dmah);
-typedef bool(*di_txsuspended_t) (hnddma_t * dmah);
-typedef bool(*di_txsuspendedidle_t) (hnddma_t * dmah);
-typedef int (*di_txfast_t) (hnddma_t * dmah, void *p, bool commit);
-typedef int (*di_txunframed_t) (hnddma_t * dmah, void *p, uint len,
+typedef void (*di_detach_t) (hnddma_t *dmah);
+typedef bool(*di_txreset_t) (hnddma_t *dmah);
+typedef bool(*di_rxreset_t) (hnddma_t *dmah);
+typedef bool(*di_rxidle_t) (hnddma_t *dmah);
+typedef void (*di_txinit_t) (hnddma_t *dmah);
+typedef bool(*di_txenabled_t) (hnddma_t *dmah);
+typedef void (*di_rxinit_t) (hnddma_t *dmah);
+typedef void (*di_txsuspend_t) (hnddma_t *dmah);
+typedef void (*di_txresume_t) (hnddma_t *dmah);
+typedef bool(*di_txsuspended_t) (hnddma_t *dmah);
+typedef bool(*di_txsuspendedidle_t) (hnddma_t *dmah);
+typedef int (*di_txfast_t) (hnddma_t *dmah, void *p, bool commit);
+typedef int (*di_txunframed_t) (hnddma_t *dmah, void *p, uint len,
 				bool commit);
-typedef void *(*di_getpos_t) (hnddma_t * di, bool direction);
-typedef void (*di_fifoloopbackenable_t) (hnddma_t * dmah);
-typedef bool(*di_txstopped_t) (hnddma_t * dmah);
-typedef bool(*di_rxstopped_t) (hnddma_t * dmah);
-typedef bool(*di_rxenable_t) (hnddma_t * dmah);
-typedef bool(*di_rxenabled_t) (hnddma_t * dmah);
-typedef void *(*di_rx_t) (hnddma_t * dmah);
-typedef bool(*di_rxfill_t) (hnddma_t * dmah);
-typedef void (*di_txreclaim_t) (hnddma_t * dmah, txd_range_t range);
-typedef void (*di_rxreclaim_t) (hnddma_t * dmah);
-typedef uintptr(*di_getvar_t) (hnddma_t * dmah, const char *name);
-typedef void *(*di_getnexttxp_t) (hnddma_t * dmah, txd_range_t range);
-typedef void *(*di_getnextrxp_t) (hnddma_t * dmah, bool forceall);
-typedef void *(*di_peeknexttxp_t) (hnddma_t * dmah);
-typedef void *(*di_peeknextrxp_t) (hnddma_t * dmah);
-typedef void (*di_rxparam_get_t) (hnddma_t * dmah, uint16 * rxoffset,
-				  uint16 * rxbufsize);
-typedef void (*di_txblock_t) (hnddma_t * dmah);
-typedef void (*di_txunblock_t) (hnddma_t * dmah);
-typedef uint(*di_txactive_t) (hnddma_t * dmah);
-typedef void (*di_txrotate_t) (hnddma_t * dmah);
-typedef void (*di_counterreset_t) (hnddma_t * dmah);
-typedef uint(*di_ctrlflags_t) (hnddma_t * dmah, uint mask, uint flags);
-typedef char *(*di_dump_t) (hnddma_t * dmah, struct bcmstrbuf * b,
+typedef void *(*di_getpos_t) (hnddma_t *di, bool direction);
+typedef void (*di_fifoloopbackenable_t) (hnddma_t *dmah);
+typedef bool(*di_txstopped_t) (hnddma_t *dmah);
+typedef bool(*di_rxstopped_t) (hnddma_t *dmah);
+typedef bool(*di_rxenable_t) (hnddma_t *dmah);
+typedef bool(*di_rxenabled_t) (hnddma_t *dmah);
+typedef void *(*di_rx_t) (hnddma_t *dmah);
+typedef bool(*di_rxfill_t) (hnddma_t *dmah);
+typedef void (*di_txreclaim_t) (hnddma_t *dmah, txd_range_t range);
+typedef void (*di_rxreclaim_t) (hnddma_t *dmah);
+typedef uintptr(*di_getvar_t) (hnddma_t *dmah, const char *name);
+typedef void *(*di_getnexttxp_t) (hnddma_t *dmah, txd_range_t range);
+typedef void *(*di_getnextrxp_t) (hnddma_t *dmah, bool forceall);
+typedef void *(*di_peeknexttxp_t) (hnddma_t *dmah);
+typedef void *(*di_peeknextrxp_t) (hnddma_t *dmah);
+typedef void (*di_rxparam_get_t) (hnddma_t *dmah, uint16 *rxoffset,
+				  uint16 *rxbufsize);
+typedef void (*di_txblock_t) (hnddma_t *dmah);
+typedef void (*di_txunblock_t) (hnddma_t *dmah);
+typedef uint(*di_txactive_t) (hnddma_t *dmah);
+typedef void (*di_txrotate_t) (hnddma_t *dmah);
+typedef void (*di_counterreset_t) (hnddma_t *dmah);
+typedef uint(*di_ctrlflags_t) (hnddma_t *dmah, uint mask, uint flags);
+typedef char *(*di_dump_t) (hnddma_t *dmah, struct bcmstrbuf *b,
 			    bool dumpring);
-typedef char *(*di_dumptx_t) (hnddma_t * dmah, struct bcmstrbuf * b,
+typedef char *(*di_dumptx_t) (hnddma_t *dmah, struct bcmstrbuf *b,
 			      bool dumpring);
-typedef char *(*di_dumprx_t) (hnddma_t * dmah, struct bcmstrbuf * b,
+typedef char *(*di_dumprx_t) (hnddma_t *dmah, struct bcmstrbuf *b,
 			      bool dumpring);
-typedef uint(*di_rxactive_t) (hnddma_t * dmah);
-typedef uint(*di_txpending_t) (hnddma_t * dmah);
-typedef uint(*di_txcommitted_t) (hnddma_t * dmah);
+typedef uint(*di_rxactive_t) (hnddma_t *dmah);
+typedef uint(*di_txpending_t) (hnddma_t *dmah);
+typedef uint(*di_txcommitted_t) (hnddma_t *dmah);
 
 /* dma opsvec */
 typedef struct di_fcn_s {
@@ -141,10 +141,10 @@ struct hnddma_pub {
 	uint txnobuf;		/* tx out of dma descriptors */
 };
 
-extern hnddma_t *dma_attach(osl_t * osh, char *name, si_t * sih,
+extern hnddma_t *dma_attach(osl_t *osh, char *name, si_t *sih,
 			    void *dmaregstx, void *dmaregsrx, uint ntxd,
 			    uint nrxd, uint rxbufsize, int rxextheadroom,
-			    uint nrxpost, uint rxoffset, uint * msg_level);
+			    uint nrxpost, uint rxoffset, uint *msg_level);
 #ifdef BCMDMA32
 
 #define dma_detach(di)			((di)->di_fn->detach(di))
@@ -235,9 +235,9 @@ extern const di_fcn_t dma64proc;
  * SB attach provides ability to probe backplane and dma core capabilities
  * This info is needed by DMA_ALLOC_CONSISTENT in dma attach
  */
-extern uint dma_addrwidth(si_t * sih, void *dmaregs);
+extern uint dma_addrwidth(si_t *sih, void *dmaregs);
 
 /* pio helpers */
-extern void dma_txpioloopback(osl_t * osh, dma32regs_t *);
+extern void dma_txpioloopback(osl_t *osh, dma32regs_t *);
 
 #endif				/* _hnddma_h_ */
--- a/drivers/staging/brcm80211/include/hndpmu.h
+++ b/drivers/staging/brcm80211/include/hndpmu.h
@@ -28,44 +28,44 @@
 #define SET_LDO_VOLTAGE_LNLDO1	9
 #define SET_LDO_VOLTAGE_LNLDO2_SEL	10
 
-extern void si_pmu_init(si_t * sih, osl_t * osh);
-extern void si_pmu_chip_init(si_t * sih, osl_t * osh);
-extern void si_pmu_pll_init(si_t * sih, osl_t * osh, uint32 xtalfreq);
-extern void si_pmu_res_init(si_t * sih, osl_t * osh);
-extern void si_pmu_swreg_init(si_t * sih, osl_t * osh);
-
-extern uint32 si_pmu_force_ilp(si_t * sih, osl_t * osh, bool force);
-
-extern uint32 si_pmu_si_clock(si_t * sih, osl_t * osh);
-extern uint32 si_pmu_cpu_clock(si_t * sih, osl_t * osh);
-extern uint32 si_pmu_mem_clock(si_t * sih, osl_t * osh);
-extern uint32 si_pmu_alp_clock(si_t * sih, osl_t * osh);
-extern uint32 si_pmu_ilp_clock(si_t * sih, osl_t * osh);
+extern void si_pmu_init(si_t *sih, osl_t *osh);
+extern void si_pmu_chip_init(si_t *sih, osl_t *osh);
+extern void si_pmu_pll_init(si_t *sih, osl_t *osh, uint32 xtalfreq);
+extern void si_pmu_res_init(si_t *sih, osl_t *osh);
+extern void si_pmu_swreg_init(si_t *sih, osl_t *osh);
+
+extern uint32 si_pmu_force_ilp(si_t *sih, osl_t *osh, bool force);
+
+extern uint32 si_pmu_si_clock(si_t *sih, osl_t *osh);
+extern uint32 si_pmu_cpu_clock(si_t *sih, osl_t *osh);
+extern uint32 si_pmu_mem_clock(si_t *sih, osl_t *osh);
+extern uint32 si_pmu_alp_clock(si_t *sih, osl_t *osh);
+extern uint32 si_pmu_ilp_clock(si_t *sih, osl_t *osh);
 
-extern void si_pmu_set_switcher_voltage(si_t * sih, osl_t * osh,
+extern void si_pmu_set_switcher_voltage(si_t *sih, osl_t *osh,
 					uint8 bb_voltage, uint8 rf_voltage);
-extern void si_pmu_set_ldo_voltage(si_t * sih, osl_t * osh, uint8 ldo,
+extern void si_pmu_set_ldo_voltage(si_t *sih, osl_t *osh, uint8 ldo,
 				   uint8 voltage);
-extern uint16 si_pmu_fast_pwrup_delay(si_t * sih, osl_t * osh);
-extern void si_pmu_rcal(si_t * sih, osl_t * osh);
-extern void si_pmu_pllupd(si_t * sih);
-extern void si_pmu_spuravoid(si_t * sih, osl_t * osh, uint8 spuravoid);
-
-extern bool si_pmu_is_otp_powered(si_t * sih, osl_t * osh);
-extern uint32 si_pmu_measure_alpclk(si_t * sih, osl_t * osh);
-
-extern uint32 si_pmu_chipcontrol(si_t * sih, uint reg, uint32 mask, uint32 val);
-extern uint32 si_pmu_regcontrol(si_t * sih, uint reg, uint32 mask, uint32 val);
-extern uint32 si_pmu_pllcontrol(si_t * sih, uint reg, uint32 mask, uint32 val);
-extern void si_pmu_pllupd(si_t * sih);
-extern void si_pmu_sprom_enable(si_t * sih, osl_t * osh, bool enable);
+extern uint16 si_pmu_fast_pwrup_delay(si_t *sih, osl_t *osh);
+extern void si_pmu_rcal(si_t *sih, osl_t *osh);
+extern void si_pmu_pllupd(si_t *sih);
+extern void si_pmu_spuravoid(si_t *sih, osl_t *osh, uint8 spuravoid);
+
+extern bool si_pmu_is_otp_powered(si_t *sih, osl_t *osh);
+extern uint32 si_pmu_measure_alpclk(si_t *sih, osl_t *osh);
+
+extern uint32 si_pmu_chipcontrol(si_t *sih, uint reg, uint32 mask, uint32 val);
+extern uint32 si_pmu_regcontrol(si_t *sih, uint reg, uint32 mask, uint32 val);
+extern uint32 si_pmu_pllcontrol(si_t *sih, uint reg, uint32 mask, uint32 val);
+extern void si_pmu_pllupd(si_t *sih);
+extern void si_pmu_sprom_enable(si_t *sih, osl_t *osh, bool enable);
 
-extern void si_pmu_radio_enable(si_t * sih, bool enable);
-extern uint32 si_pmu_waitforclk_on_backplane(si_t * sih, osl_t * osh,
+extern void si_pmu_radio_enable(si_t *sih, bool enable);
+extern uint32 si_pmu_waitforclk_on_backplane(si_t *sih, osl_t *osh,
 					     uint32 clk, uint32 delay);
 
-extern void si_pmu_otp_power(si_t * sih, osl_t * osh, bool on);
-extern void si_sdiod_drive_strength_init(si_t * sih, osl_t * osh,
+extern void si_pmu_otp_power(si_t *sih, osl_t *osh, bool on);
+extern void si_sdiod_drive_strength_init(si_t *sih, osl_t *osh,
 					 uint32 drivestrength);
 
 #endif				/* _hndpmu_h_ */
--- a/drivers/staging/brcm80211/include/linux_osl.h
+++ b/drivers/staging/brcm80211/include/linux_osl.h
@@ -26,7 +26,7 @@ extern void osl_os_close_image(void *ima
 /* Linux Kernel: File Operations: end */
 
 extern osl_t *osl_attach(void *pdev, uint bustype, bool pkttag);
-extern void osl_detach(osl_t * osh);
+extern void osl_detach(osl_t *osh);
 
 extern uint32 g_assert_type;
 
@@ -54,8 +54,8 @@ extern void osl_delay(uint usec);
 	osl_pcmcia_read_attr((osh), (offset), (buf), (size))
 #define	OSL_PCMCIA_WRITE_ATTR(osh, offset, buf, size) \
 	osl_pcmcia_write_attr((osh), (offset), (buf), (size))
-extern void osl_pcmcia_read_attr(osl_t * osh, uint offset, void *buf, int size);
-extern void osl_pcmcia_write_attr(osl_t * osh, uint offset, void *buf,
+extern void osl_pcmcia_read_attr(osl_t *osh, uint offset, void *buf, int size);
+extern void osl_pcmcia_write_attr(osl_t *osh, uint offset, void *buf,
 				  int size);
 
 /* PCI configuration space access macros */
@@ -63,14 +63,14 @@ extern void osl_pcmcia_write_attr(osl_t
 	osl_pci_read_config((osh), (offset), (size))
 #define	OSL_PCI_WRITE_CONFIG(osh, offset, size, val) \
 	osl_pci_write_config((osh), (offset), (size), (val))
-extern uint32 osl_pci_read_config(osl_t * osh, uint offset, uint size);
-extern void osl_pci_write_config(osl_t * osh, uint offset, uint size, uint val);
+extern uint32 osl_pci_read_config(osl_t *osh, uint offset, uint size);
+extern void osl_pci_write_config(osl_t *osh, uint offset, uint size, uint val);
 
 /* PCI device bus # and slot # */
 #define OSL_PCI_BUS(osh)	osl_pci_bus(osh)
 #define OSL_PCI_SLOT(osh)	osl_pci_slot(osh)
-extern uint osl_pci_bus(osl_t * osh);
-extern uint osl_pci_slot(osl_t * osh);
+extern uint osl_pci_bus(osl_t *osh);
+extern uint osl_pci_slot(osl_t *osh);
 
 /* Pkttag flag should be part of public information */
 typedef struct {
@@ -106,14 +106,14 @@ typedef struct {
 #define MALLOC(osh, size)	osl_malloc((osh), (size))
 #define MFREE(osh, addr, size)	osl_mfree((osh), (addr), (size))
 #define MALLOCED(osh)		osl_malloced((osh))
-extern void *osl_malloc(osl_t * osh, uint size);
-extern void osl_mfree(osl_t * osh, void *addr, uint size);
-extern uint osl_malloced(osl_t * osh);
+extern void *osl_malloc(osl_t *osh, uint size);
+extern void osl_mfree(osl_t *osh, void *addr, uint size);
+extern uint osl_malloced(osl_t *osh);
 
 #define NATIVE_MALLOC(osh, size)	kmalloc(size, GFP_ATOMIC)
 #define NATIVE_MFREE(osh, addr, size)	kfree(addr)
 #define	MALLOC_FAILED(osh)		osl_malloc_failed((osh))
-extern uint osl_malloc_failed(osl_t * osh);
+extern uint osl_malloc_failed(osl_t *osh);
 
 /* allocate/free shared (dma-able) consistent memory */
 #define	DMA_CONSISTENT_ALIGN	osl_dma_consistent_align()
@@ -122,9 +122,9 @@ extern uint osl_malloc_failed(osl_t * os
 #define	DMA_FREE_CONSISTENT(osh, va, size, pa, dmah) \
 	osl_dma_free_consistent((osh), (void*)(va), (size), (pa))
 extern uint osl_dma_consistent_align(void);
-extern void *osl_dma_alloc_consistent(osl_t * osh, uint size, uint16 align,
-				      uint * tot, ulong * pap);
-extern void osl_dma_free_consistent(osl_t * osh, void *va, uint size, ulong pa);
+extern void *osl_dma_alloc_consistent(osl_t *osh, uint size, uint16 align,
+				      uint *tot, ulong *pap);
+extern void osl_dma_free_consistent(osl_t *osh, void *va, uint size, ulong pa);
 
 /* map/unmap direction */
 #define	DMA_TX	1		/* TX direction for DMA */
@@ -135,8 +135,8 @@ extern void osl_dma_free_consistent(osl_
 	osl_dma_map((osh), (va), (size), (direction))
 #define	DMA_UNMAP(osh, pa, size, direction, p, dmah) \
 	osl_dma_unmap((osh), (pa), (size), (direction))
-extern uint osl_dma_map(osl_t * osh, void *va, uint size, int direction);
-extern void osl_dma_unmap(osl_t * osh, uint pa, uint size, int direction);
+extern uint osl_dma_map(osl_t *osh, void *va, uint size, int direction);
+extern void osl_dma_unmap(osl_t *osh, uint pa, uint size, int direction);
 
 /* API for DMA addressing capability */
 #define OSL_DMADDRWIDTH(osh, addrwidth) do {} while (0)
@@ -330,10 +330,10 @@ extern int osl_error(int bcmerror);
 #define	PKTCLRSKIPCT(osh, skb)
 #define	PKTSKIPCT(osh, skb)
 
-extern void osl_pktfree(osl_t * osh, void *skb, bool send);
+extern void osl_pktfree(osl_t *osh, void *skb, bool send);
 
-extern void *osl_pktget(osl_t * osh, uint len);
-extern void *osl_pktdup(osl_t * osh, void *skb);
+extern void *osl_pktget(osl_t *osh, uint len);
+extern void *osl_pktdup(osl_t *osh, void *skb);
 
 #define	PKTLINK(skb)			(((struct sk_buff*)(skb))->prev)
 #define	PKTSETLINK(skb, x)		(((struct sk_buff*)(skb))->prev = (struct sk_buff*)(x))
@@ -359,12 +359,12 @@ extern void *osl_pktdup(osl_t * osh, voi
 	} \
 } while (0)
 
-extern uint8 osl_readb(osl_t * osh, volatile uint8 * r);
-extern uint16 osl_readw(osl_t * osh, volatile uint16 * r);
-extern uint32 osl_readl(osl_t * osh, volatile uint32 * r);
-extern void osl_writeb(osl_t * osh, volatile uint8 * r, uint8 v);
-extern void osl_writew(osl_t * osh, volatile uint16 * r, uint16 v);
-extern void osl_writel(osl_t * osh, volatile uint32 * r, uint32 v);
+extern uint8 osl_readb(osl_t *osh, volatile uint8 *r);
+extern uint16 osl_readw(osl_t *osh, volatile uint16 *r);
+extern uint32 osl_readl(osl_t *osh, volatile uint32 *r);
+extern void osl_writeb(osl_t *osh, volatile uint8 *r, uint8 v);
+extern void osl_writew(osl_t *osh, volatile uint16 *r, uint16 v);
+extern void osl_writel(osl_t *osh, volatile uint32 *r, uint32 v);
 #endif				/* BCMSDIO */
 
 #endif				/* _linux_osl_h_ */
--- a/drivers/staging/brcm80211/include/nicpci.h
+++ b/drivers/staging/brcm80211/include/nicpci.h
@@ -45,17 +45,17 @@
 #else
 struct sbpcieregs;
 
-extern uint8 pcicore_find_pci_capability(osl_t * osh, uint8 req_cap_id,
-					 uchar * buf, uint32 * buflen);
-extern uint pcie_readreg(osl_t * osh, struct sbpcieregs *pcieregs,
+extern uint8 pcicore_find_pci_capability(osl_t *osh, uint8 req_cap_id,
+					 uchar *buf, uint32 *buflen);
+extern uint pcie_readreg(osl_t *osh, struct sbpcieregs *pcieregs,
 			 uint addrtype, uint offset);
-extern uint pcie_writereg(osl_t * osh, struct sbpcieregs *pcieregs,
+extern uint pcie_writereg(osl_t *osh, struct sbpcieregs *pcieregs,
 			  uint addrtype, uint offset, uint val);
 
 extern uint8 pcie_clkreq(void *pch, uint32 mask, uint32 val);
 extern uint32 pcie_lcreg(void *pch, uint32 mask, uint32 val);
 
-extern void *pcicore_init(si_t * sih, osl_t * osh, void *regs);
+extern void *pcicore_init(si_t *sih, osl_t *osh, void *regs);
 extern void pcicore_deinit(void *pch);
 extern void pcicore_attach(void *pch, char *pvars, int state);
 extern void pcicore_hwup(void *pch);
@@ -70,7 +70,7 @@ extern uint32 pcicore_pcieserdesreg(void
 extern uint32 pcicore_pciereg(void *pch, uint32 offset, uint32 mask,
 			      uint32 val, uint type);
 
-extern bool pcicore_pmecap_fast(osl_t * osh);
+extern bool pcicore_pmecap_fast(osl_t *osh);
 extern void pcicore_pmeen(void *pch);
 extern void pcicore_pmeclr(void *pch);
 extern bool pcicore_pmestat(void *pch);
--- a/drivers/staging/brcm80211/include/qmath.h
+++ b/drivers/staging/brcm80211/include/qmath.h
@@ -57,11 +57,11 @@ int16 qm_div_s(int16 num, int16 denom);
 
 int16 qm_abs16(int16 op);
 
-int16 qm_div16(int16 num, int16 denom, int16 * qQuotient);
+int16 qm_div16(int16 num, int16 denom, int16 *qQuotient);
 
 int32 qm_abs32(int32 op);
 
-int16 qm_div163232(int32 num, int32 denom, int16 * qquotient);
+int16 qm_div163232(int32 num, int32 denom, int16 *qquotient);
 
 int32 qm_mul323216(int32 op1, int16 op2);
 
@@ -73,8 +73,8 @@ int32 qm_mul32(int32 a, int32 b);
 
 int32 qm_muls32(int32 a, int32 b);
 
-void qm_log10(int32 N, int16 qN, int16 * log10N, int16 * qLog10N);
+void qm_log10(int32 N, int16 qN, int16 *log10N, int16 *qLog10N);
 
-void qm_1byN(int32 N, int16 qN, int32 * result, int16 * qResult);
+void qm_1byN(int32 N, int16 qN, int32 *result, int16 *qResult);
 
 #endif				/* #ifndef __QMATH_H__ */
--- a/drivers/staging/brcm80211/include/rpc_osl.h
+++ b/drivers/staging/brcm80211/include/rpc_osl.h
@@ -18,16 +18,16 @@
 #define _rpcosl_h_
 
 typedef struct rpc_osl rpc_osl_t;
-extern rpc_osl_t *rpc_osl_attach(osl_t * osh);
-extern void rpc_osl_detach(rpc_osl_t * rpc_osh);
+extern rpc_osl_t *rpc_osl_attach(osl_t *osh);
+extern void rpc_osl_detach(rpc_osl_t *rpc_osh);
 
 #define RPC_OSL_LOCK(rpc_osh) rpc_osl_lock((rpc_osh))
 #define RPC_OSL_UNLOCK(rpc_osh) rpc_osl_unlock((rpc_osh))
 #define RPC_OSL_WAIT(rpc_osh, to, ptimedout)	rpc_osl_wait((rpc_osh), (to), (ptimedout))
 #define RPC_OSL_WAKE(rpc_osh)			rpc_osl_wake((rpc_osh))
-extern void rpc_osl_lock(rpc_osl_t * rpc_osh);
-extern void rpc_osl_unlock(rpc_osl_t * rpc_osh);
-extern int rpc_osl_wait(rpc_osl_t * rpc_osh, uint ms, bool * ptimedout);
-extern void rpc_osl_wake(rpc_osl_t * rpc_osh);
+extern void rpc_osl_lock(rpc_osl_t *rpc_osh);
+extern void rpc_osl_unlock(rpc_osl_t *rpc_osh);
+extern int rpc_osl_wait(rpc_osl_t *rpc_osh, uint ms, bool *ptimedout);
+extern void rpc_osl_wake(rpc_osl_t *rpc_osh);
 
 #endif				/* _rpcosl_h_ */
--- a/drivers/staging/brcm80211/include/siutils.h
+++ b/drivers/staging/brcm80211/include/siutils.h
@@ -128,131 +128,131 @@ typedef void (*gpio_handler_t) (uint32 s
 #define GPIO_CTRL_EPA_EN_MASK 0x40
 
 /* === exported functions === */
-extern si_t *si_attach(uint pcidev, osl_t * osh, void *regs, uint bustype,
-		       void *sdh, char **vars, uint * varsz);
+extern si_t *si_attach(uint pcidev, osl_t *osh, void *regs, uint bustype,
+		       void *sdh, char **vars, uint *varsz);
 
-extern void si_detach(si_t * sih);
-extern bool si_pci_war16165(si_t * sih);
+extern void si_detach(si_t *sih);
+extern bool si_pci_war16165(si_t *sih);
 
-extern uint si_corelist(si_t * sih, uint coreid[]);
-extern uint si_coreid(si_t * sih);
-extern uint si_flag(si_t * sih);
-extern uint si_intflag(si_t * sih);
-extern uint si_coreidx(si_t * sih);
-extern uint si_coreunit(si_t * sih);
-extern uint si_corevendor(si_t * sih);
-extern uint si_corerev(si_t * sih);
-extern void *si_osh(si_t * sih);
-extern void si_setosh(si_t * sih, osl_t * osh);
-extern uint si_corereg(si_t * sih, uint coreidx, uint regoff, uint mask,
+extern uint si_corelist(si_t *sih, uint coreid[]);
+extern uint si_coreid(si_t *sih);
+extern uint si_flag(si_t *sih);
+extern uint si_intflag(si_t *sih);
+extern uint si_coreidx(si_t *sih);
+extern uint si_coreunit(si_t *sih);
+extern uint si_corevendor(si_t *sih);
+extern uint si_corerev(si_t *sih);
+extern void *si_osh(si_t *sih);
+extern void si_setosh(si_t *sih, osl_t *osh);
+extern uint si_corereg(si_t *sih, uint coreidx, uint regoff, uint mask,
 		       uint val);
-extern void *si_coreregs(si_t * sih);
-extern void si_write_wrapperreg(si_t * sih, uint32 offset, uint32 val);
-extern uint32 si_core_cflags(si_t * sih, uint32 mask, uint32 val);
-extern void si_core_cflags_wo(si_t * sih, uint32 mask, uint32 val);
-extern uint32 si_core_sflags(si_t * sih, uint32 mask, uint32 val);
-extern bool si_iscoreup(si_t * sih);
-extern uint si_findcoreidx(si_t * sih, uint coreid, uint coreunit);
+extern void *si_coreregs(si_t *sih);
+extern void si_write_wrapperreg(si_t *sih, uint32 offset, uint32 val);
+extern uint32 si_core_cflags(si_t *sih, uint32 mask, uint32 val);
+extern void si_core_cflags_wo(si_t *sih, uint32 mask, uint32 val);
+extern uint32 si_core_sflags(si_t *sih, uint32 mask, uint32 val);
+extern bool si_iscoreup(si_t *sih);
+extern uint si_findcoreidx(si_t *sih, uint coreid, uint coreunit);
 #ifndef BCMSDIO
-extern void *si_setcoreidx(si_t * sih, uint coreidx);
+extern void *si_setcoreidx(si_t *sih, uint coreidx);
 #endif
-extern void *si_setcore(si_t * sih, uint coreid, uint coreunit);
-extern void *si_switch_core(si_t * sih, uint coreid, uint * origidx,
-			    uint * intr_val);
-extern void si_restore_core(si_t * sih, uint coreid, uint intr_val);
-extern int si_numaddrspaces(si_t * sih);
-extern uint32 si_addrspace(si_t * sih, uint asidx);
-extern uint32 si_addrspacesize(si_t * sih, uint asidx);
-extern int si_corebist(si_t * sih);
-extern void si_core_reset(si_t * sih, uint32 bits, uint32 resetbits);
-extern void si_core_disable(si_t * sih, uint32 bits);
+extern void *si_setcore(si_t *sih, uint coreid, uint coreunit);
+extern void *si_switch_core(si_t *sih, uint coreid, uint *origidx,
+			    uint *intr_val);
+extern void si_restore_core(si_t *sih, uint coreid, uint intr_val);
+extern int si_numaddrspaces(si_t *sih);
+extern uint32 si_addrspace(si_t *sih, uint asidx);
+extern uint32 si_addrspacesize(si_t *sih, uint asidx);
+extern int si_corebist(si_t *sih);
+extern void si_core_reset(si_t *sih, uint32 bits, uint32 resetbits);
+extern void si_core_disable(si_t *sih, uint32 bits);
 extern uint32 si_clock_rate(uint32 pll_type, uint32 n, uint32 m);
-extern uint32 si_clock(si_t * sih);
-extern uint32 si_alp_clock(si_t * sih);
-extern uint32 si_ilp_clock(si_t * sih);
-extern void si_pci_setup(si_t * sih, uint coremask);
-extern void si_setint(si_t * sih, int siflag);
-extern bool si_backplane64(si_t * sih);
-extern void si_register_intr_callback(si_t * sih, void *intrsoff_fn,
+extern uint32 si_clock(si_t *sih);
+extern uint32 si_alp_clock(si_t *sih);
+extern uint32 si_ilp_clock(si_t *sih);
+extern void si_pci_setup(si_t *sih, uint coremask);
+extern void si_setint(si_t *sih, int siflag);
+extern bool si_backplane64(si_t *sih);
+extern void si_register_intr_callback(si_t *sih, void *intrsoff_fn,
 				      void *intrsrestore_fn,
 				      void *intrsenabled_fn, void *intr_arg);
-extern void si_deregister_intr_callback(si_t * sih);
-extern void si_clkctl_init(si_t * sih);
-extern uint16 si_clkctl_fast_pwrup_delay(si_t * sih);
-extern bool si_clkctl_cc(si_t * sih, uint mode);
-extern int si_clkctl_xtal(si_t * sih, uint what, bool on);
-extern uint32 si_gpiotimerval(si_t * sih, uint32 mask, uint32 val);
-extern bool si_deviceremoved(si_t * sih);
-extern uint32 si_socram_size(si_t * sih);
-extern uint32 si_socdevram_size(si_t * sih);
-extern void si_socdevram(si_t * sih, bool set, uint8 * ennable,
-			 uint8 * protect);
-extern bool si_socdevram_pkg(si_t * sih);
-
-extern void si_watchdog(si_t * sih, uint ticks);
-extern void si_watchdog_ms(si_t * sih, uint32 ms);
-extern void *si_gpiosetcore(si_t * sih);
-extern uint32 si_gpiocontrol(si_t * sih, uint32 mask, uint32 val,
+extern void si_deregister_intr_callback(si_t *sih);
+extern void si_clkctl_init(si_t *sih);
+extern uint16 si_clkctl_fast_pwrup_delay(si_t *sih);
+extern bool si_clkctl_cc(si_t *sih, uint mode);
+extern int si_clkctl_xtal(si_t *sih, uint what, bool on);
+extern uint32 si_gpiotimerval(si_t *sih, uint32 mask, uint32 val);
+extern bool si_deviceremoved(si_t *sih);
+extern uint32 si_socram_size(si_t *sih);
+extern uint32 si_socdevram_size(si_t *sih);
+extern void si_socdevram(si_t *sih, bool set, uint8 *ennable,
+			 uint8 *protect);
+extern bool si_socdevram_pkg(si_t *sih);
+
+extern void si_watchdog(si_t *sih, uint ticks);
+extern void si_watchdog_ms(si_t *sih, uint32 ms);
+extern void *si_gpiosetcore(si_t *sih);
+extern uint32 si_gpiocontrol(si_t *sih, uint32 mask, uint32 val,
 			     uint8 priority);
-extern uint32 si_gpioouten(si_t * sih, uint32 mask, uint32 val, uint8 priority);
-extern uint32 si_gpioout(si_t * sih, uint32 mask, uint32 val, uint8 priority);
-extern uint32 si_gpioin(si_t * sih);
-extern uint32 si_gpiointpolarity(si_t * sih, uint32 mask, uint32 val,
+extern uint32 si_gpioouten(si_t *sih, uint32 mask, uint32 val, uint8 priority);
+extern uint32 si_gpioout(si_t *sih, uint32 mask, uint32 val, uint8 priority);
+extern uint32 si_gpioin(si_t *sih);
+extern uint32 si_gpiointpolarity(si_t *sih, uint32 mask, uint32 val,
 				 uint8 priority);
-extern uint32 si_gpiointmask(si_t * sih, uint32 mask, uint32 val,
+extern uint32 si_gpiointmask(si_t *sih, uint32 mask, uint32 val,
 			     uint8 priority);
-extern uint32 si_gpioled(si_t * sih, uint32 mask, uint32 val);
-extern uint32 si_gpioreserve(si_t * sih, uint32 gpio_num, uint8 priority);
-extern uint32 si_gpiorelease(si_t * sih, uint32 gpio_num, uint8 priority);
-extern uint32 si_gpiopull(si_t * sih, bool updown, uint32 mask, uint32 val);
-extern uint32 si_gpioevent(si_t * sih, uint regtype, uint32 mask, uint32 val);
-extern uint32 si_gpio_int_enable(si_t * sih, bool enable);
+extern uint32 si_gpioled(si_t *sih, uint32 mask, uint32 val);
+extern uint32 si_gpioreserve(si_t *sih, uint32 gpio_num, uint8 priority);
+extern uint32 si_gpiorelease(si_t *sih, uint32 gpio_num, uint8 priority);
+extern uint32 si_gpiopull(si_t *sih, bool updown, uint32 mask, uint32 val);
+extern uint32 si_gpioevent(si_t *sih, uint regtype, uint32 mask, uint32 val);
+extern uint32 si_gpio_int_enable(si_t *sih, bool enable);
 
 /* GPIO event handlers */
-extern void *si_gpio_handler_register(si_t * sih, uint32 e, bool lev,
+extern void *si_gpio_handler_register(si_t *sih, uint32 e, bool lev,
 				      gpio_handler_t cb, void *arg);
-extern void si_gpio_handler_unregister(si_t * sih, void *gpioh);
-extern void si_gpio_handler_process(si_t * sih);
+extern void si_gpio_handler_unregister(si_t *sih, void *gpioh);
+extern void si_gpio_handler_process(si_t *sih);
 
 /* Wake-on-wireless-LAN (WOWL) */
-extern bool si_pci_pmecap(si_t * sih);
+extern bool si_pci_pmecap(si_t *sih);
 struct osl_info;
 extern bool si_pci_fastpmecap(struct osl_info *osh);
-extern bool si_pci_pmestat(si_t * sih);
-extern void si_pci_pmeclr(si_t * sih);
-extern void si_pci_pmeen(si_t * sih);
+extern bool si_pci_pmestat(si_t *sih);
+extern void si_pci_pmeclr(si_t *sih);
+extern void si_pci_pmeen(si_t *sih);
 extern uint si_pcie_readreg(void *sih, uint addrtype, uint offset);
 
 #ifdef BCMSDIO
-extern void si_sdio_init(si_t * sih);
+extern void si_sdio_init(si_t *sih);
 #endif
 
-extern uint16 si_d11_devid(si_t * sih);
+extern uint16 si_d11_devid(si_t *sih);
 
 #define si_eci(sih) 0
 #define si_eci_init(sih) (0)
 #define si_eci_notify_bt(sih, type, val)  (0)
 #define si_seci(sih) 0
-static INLINE void *si_seci_init(si_t * sih, uint8 use_seci)
+static INLINE void *si_seci_init(si_t *sih, uint8 use_seci)
 {
 	return NULL;
 }
 
 /* OTP status */
-extern bool si_is_otp_disabled(si_t * sih);
-extern bool si_is_otp_powered(si_t * sih);
-extern void si_otp_power(si_t * sih, bool on);
+extern bool si_is_otp_disabled(si_t *sih);
+extern bool si_is_otp_powered(si_t *sih);
+extern void si_otp_power(si_t *sih, bool on);
 
 /* SPROM availability */
-extern bool si_is_sprom_available(si_t * sih);
-extern bool si_is_sprom_enabled(si_t * sih);
-extern void si_sprom_enable(si_t * sih, bool enable);
+extern bool si_is_sprom_available(si_t *sih);
+extern bool si_is_sprom_enabled(si_t *sih);
+extern void si_sprom_enable(si_t *sih, bool enable);
 #ifdef SI_SPROM_PROBE
-extern void si_sprom_init(si_t * sih);
+extern void si_sprom_init(si_t *sih);
 #endif				/* SI_SPROM_PROBE */
 
 /* OTP/SROM CIS stuff */
-extern int si_cis_source(si_t * sih);
+extern int si_cis_source(si_t *sih);
 #define CIS_DEFAULT	0
 #define CIS_SROM	1
 #define CIS_OTP		2
@@ -389,61 +389,61 @@ typedef struct si_info {
  * The returned path is NULL terminated and has trailing '/'.
  * Return 0 on success, nonzero otherwise.
  */
-extern int si_devpath(si_t * sih, char *path, int size);
+extern int si_devpath(si_t *sih, char *path, int size);
 /* Read variable with prepending the devpath to the name */
-extern char *si_getdevpathvar(si_t * sih, const char *name);
-extern int si_getdevpathintvar(si_t * sih, const char *name);
+extern char *si_getdevpathvar(si_t *sih, const char *name);
+extern int si_getdevpathintvar(si_t *sih, const char *name);
 
-extern uint8 si_pcieclkreq(si_t * sih, uint32 mask, uint32 val);
-extern uint32 si_pcielcreg(si_t * sih, uint32 mask, uint32 val);
-extern void si_war42780_clkreq(si_t * sih, bool clkreq);
-extern void si_pci_sleep(si_t * sih);
-extern void si_pci_down(si_t * sih);
-extern void si_pci_up(si_t * sih);
-extern void si_pcie_war_ovr_update(si_t * sih, uint8 aspm);
-extern void si_pcie_extendL1timer(si_t * sih, bool extend);
-extern int si_pci_fixcfg(si_t * sih);
-extern void si_chippkg_set(si_t * sih, uint);
+extern uint8 si_pcieclkreq(si_t *sih, uint32 mask, uint32 val);
+extern uint32 si_pcielcreg(si_t *sih, uint32 mask, uint32 val);
+extern void si_war42780_clkreq(si_t *sih, bool clkreq);
+extern void si_pci_sleep(si_t *sih);
+extern void si_pci_down(si_t *sih);
+extern void si_pci_up(si_t *sih);
+extern void si_pcie_war_ovr_update(si_t *sih, uint8 aspm);
+extern void si_pcie_extendL1timer(si_t *sih, bool extend);
+extern int si_pci_fixcfg(si_t *sih);
+extern void si_chippkg_set(si_t *sih, uint);
 
-extern void si_chipcontrl_epa4331(si_t * sih, bool on);
+extern void si_chipcontrl_epa4331(si_t *sih, bool on);
 /* Enable Ex-PA for 4313 */
-extern void si_epa_4313war(si_t * sih);
+extern void si_epa_4313war(si_t *sih);
 
 /* === debug routines === */
-extern uint32 si_pciereg(si_t * sih, uint32 offset, uint32 mask, uint32 val,
+extern uint32 si_pciereg(si_t *sih, uint32 offset, uint32 mask, uint32 val,
 			 uint type);
-extern uint32 si_pcieserdesreg(si_t * sih, uint32 mdioslave, uint32 offset,
+extern uint32 si_pcieserdesreg(si_t *sih, uint32 mdioslave, uint32 offset,
 			       uint32 mask, uint32 val);
 
-char *si_getnvramflvar(si_t * sih, const char *name);
+char *si_getnvramflvar(si_t *sih, const char *name);
 
 /* AMBA Interconnect exported externs */
-extern si_t *ai_attach(uint pcidev, osl_t * osh, void *regs, uint bustype,
-		       void *sdh, char **vars, uint * varsz);
-extern si_t *ai_kattach(osl_t * osh);
-extern void ai_scan(si_t * sih, void *regs, uint devid);
-
-extern uint ai_flag(si_t * sih);
-extern void ai_setint(si_t * sih, int siflag);
-extern uint ai_coreidx(si_t * sih);
-extern uint ai_corevendor(si_t * sih);
-extern uint ai_corerev(si_t * sih);
-extern bool ai_iscoreup(si_t * sih);
-extern void *ai_setcoreidx(si_t * sih, uint coreidx);
-extern uint32 ai_core_cflags(si_t * sih, uint32 mask, uint32 val);
-extern void ai_core_cflags_wo(si_t * sih, uint32 mask, uint32 val);
-extern uint32 ai_core_sflags(si_t * sih, uint32 mask, uint32 val);
-extern uint ai_corereg(si_t * sih, uint coreidx, uint regoff, uint mask,
+extern si_t *ai_attach(uint pcidev, osl_t *osh, void *regs, uint bustype,
+		       void *sdh, char **vars, uint *varsz);
+extern si_t *ai_kattach(osl_t *osh);
+extern void ai_scan(si_t *sih, void *regs, uint devid);
+
+extern uint ai_flag(si_t *sih);
+extern void ai_setint(si_t *sih, int siflag);
+extern uint ai_coreidx(si_t *sih);
+extern uint ai_corevendor(si_t *sih);
+extern uint ai_corerev(si_t *sih);
+extern bool ai_iscoreup(si_t *sih);
+extern void *ai_setcoreidx(si_t *sih, uint coreidx);
+extern uint32 ai_core_cflags(si_t *sih, uint32 mask, uint32 val);
+extern void ai_core_cflags_wo(si_t *sih, uint32 mask, uint32 val);
+extern uint32 ai_core_sflags(si_t *sih, uint32 mask, uint32 val);
+extern uint ai_corereg(si_t *sih, uint coreidx, uint regoff, uint mask,
 		       uint val);
-extern void ai_core_reset(si_t * sih, uint32 bits, uint32 resetbits);
-extern void ai_core_disable(si_t * sih, uint32 bits);
-extern int ai_numaddrspaces(si_t * sih);
-extern uint32 ai_addrspace(si_t * sih, uint asidx);
-extern uint32 ai_addrspacesize(si_t * sih, uint asidx);
-extern void ai_write_wrap_reg(si_t * sih, uint32 offset, uint32 val);
+extern void ai_core_reset(si_t *sih, uint32 bits, uint32 resetbits);
+extern void ai_core_disable(si_t *sih, uint32 bits);
+extern int ai_numaddrspaces(si_t *sih);
+extern uint32 ai_addrspace(si_t *sih, uint asidx);
+extern uint32 ai_addrspacesize(si_t *sih, uint asidx);
+extern void ai_write_wrap_reg(si_t *sih, uint32 offset, uint32 val);
 
 #ifdef BCMDBG
-extern void ai_view(si_t * sih, bool verbose);
+extern void ai_view(si_t *sih, bool verbose);
 #endif
 
 #ifdef BCMSDIO
--- a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -121,29 +121,29 @@ const uint8 ofdm_rate_lookup[] = {
 
 #define PHY_WREG_LIMIT	24
 
-static void wlc_set_phy_uninitted(phy_info_t * pi);
-static uint32 wlc_phy_get_radio_ver(phy_info_t * pi);
+static void wlc_set_phy_uninitted(phy_info_t *pi);
+static uint32 wlc_phy_get_radio_ver(phy_info_t *pi);
 static void wlc_phy_timercb_phycal(void *arg);
 
-static bool wlc_phy_noise_calc_phy(phy_info_t * pi, uint32 * cmplx_pwr,
-				   int8 * pwr_ant);
+static bool wlc_phy_noise_calc_phy(phy_info_t *pi, uint32 *cmplx_pwr,
+				   int8 *pwr_ant);
 
-static void wlc_phy_cal_perical_mphase_schedule(phy_info_t * pi, uint delay);
-static void wlc_phy_noise_cb(phy_info_t * pi, uint8 channel, int8 noise_dbm);
-static void wlc_phy_noise_sample_request(wlc_phy_t * pih, uint8 reason,
+static void wlc_phy_cal_perical_mphase_schedule(phy_info_t *pi, uint delay);
+static void wlc_phy_noise_cb(phy_info_t *pi, uint8 channel, int8 noise_dbm);
+static void wlc_phy_noise_sample_request(wlc_phy_t *pih, uint8 reason,
 					 uint8 ch);
 
-static void wlc_phy_txpower_reg_limit_calc(phy_info_t * pi,
+static void wlc_phy_txpower_reg_limit_calc(phy_info_t *pi,
 					   struct txpwr_limits *tp, chanspec_t);
-static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t * pi);
+static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t *pi);
 
-static int8 wlc_user_txpwr_antport_to_rfport(phy_info_t * pi, uint chan,
+static int8 wlc_user_txpwr_antport_to_rfport(phy_info_t *pi, uint chan,
 					     uint32 band, uint8 rate);
-static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t * pi, uint32 band);
-static int8 wlc_phy_env_measure_vbat(phy_info_t * pi);
-static int8 wlc_phy_env_measure_temperature(phy_info_t * pi);
+static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t *pi, uint32 band);
+static int8 wlc_phy_env_measure_vbat(phy_info_t *pi);
+static int8 wlc_phy_env_measure_temperature(phy_info_t *pi);
 
-char *phy_getvar(phy_info_t * pi, const char *name)
+char *phy_getvar(phy_info_t *pi, const char *name)
 {
 	char *vars = pi->vars;
 	char *s;
@@ -168,7 +168,7 @@ char *phy_getvar(phy_info_t * pi, const
 	return (nvram_get(name));
 }
 
-int phy_getintvar(phy_info_t * pi, const char *name)
+int phy_getintvar(phy_info_t *pi, const char *name)
 {
 	char *val;
 
@@ -178,19 +178,19 @@ int phy_getintvar(phy_info_t * pi, const
 	return (bcm_strtoul(val, NULL, 0));
 }
 
-void wlc_phyreg_enter(wlc_phy_t * pih)
+void wlc_phyreg_enter(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	wlapi_bmac_ucode_wake_override_phyreg_set(pi->sh->physhim);
 }
 
-void wlc_phyreg_exit(wlc_phy_t * pih)
+void wlc_phyreg_exit(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	wlapi_bmac_ucode_wake_override_phyreg_clear(pi->sh->physhim);
 }
 
-void wlc_radioreg_enter(wlc_phy_t * pih)
+void wlc_radioreg_enter(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	wlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, MCTL_LOCK_RADIO);
@@ -198,7 +198,7 @@ void wlc_radioreg_enter(wlc_phy_t * pih)
 	OSL_DELAY(10);
 }
 
-void wlc_radioreg_exit(wlc_phy_t * pih)
+void wlc_radioreg_exit(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	volatile uint16 dummy;
@@ -208,7 +208,7 @@ void wlc_radioreg_exit(wlc_phy_t * pih)
 	wlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, 0);
 }
 
-uint16 read_radio_reg(phy_info_t * pi, uint16 addr)
+uint16 read_radio_reg(phy_info_t *pi, uint16 addr)
 {
 	uint16 data;
 
@@ -264,7 +264,7 @@ uint16 read_radio_reg(phy_info_t * pi, u
 	return data;
 }
 
-void write_radio_reg(phy_info_t * pi, uint16 addr, uint16 val)
+void write_radio_reg(phy_info_t *pi, uint16 addr, uint16 val)
 {
 	osl_t *osh;
 
@@ -298,7 +298,7 @@ void write_radio_reg(phy_info_t * pi, ui
 	}
 }
 
-static uint32 read_radio_id(phy_info_t * pi)
+static uint32 read_radio_id(phy_info_t *pi)
 {
 	uint32 id;
 
@@ -338,7 +338,7 @@ static uint32 read_radio_id(phy_info_t *
 	return id;
 }
 
-void and_radio_reg(phy_info_t * pi, uint16 addr, uint16 val)
+void and_radio_reg(phy_info_t *pi, uint16 addr, uint16 val)
 {
 	uint16 rval;
 
@@ -349,7 +349,7 @@ void and_radio_reg(phy_info_t * pi, uint
 	write_radio_reg(pi, addr, (rval & val));
 }
 
-void or_radio_reg(phy_info_t * pi, uint16 addr, uint16 val)
+void or_radio_reg(phy_info_t *pi, uint16 addr, uint16 val)
 {
 	uint16 rval;
 
@@ -360,7 +360,7 @@ void or_radio_reg(phy_info_t * pi, uint1
 	write_radio_reg(pi, addr, (rval | val));
 }
 
-void xor_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask)
+void xor_radio_reg(phy_info_t *pi, uint16 addr, uint16 mask)
 {
 	uint16 rval;
 
@@ -371,7 +371,7 @@ void xor_radio_reg(phy_info_t * pi, uint
 	write_radio_reg(pi, addr, (rval ^ mask));
 }
 
-void mod_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask, uint16 val)
+void mod_radio_reg(phy_info_t *pi, uint16 addr, uint16 mask, uint16 val)
 {
 	uint16 rval;
 
@@ -382,13 +382,13 @@ void mod_radio_reg(phy_info_t * pi, uint
 	write_radio_reg(pi, addr, (rval & ~mask) | (val & mask));
 }
 
-void write_phy_channel_reg(phy_info_t * pi, uint val)
+void write_phy_channel_reg(phy_info_t *pi, uint val)
 {
 	W_REG(pi->sh->osh, &pi->regs->phychannel, val);
 }
 
 #if defined(BCMDBG)
-static bool wlc_phy_war41476(phy_info_t * pi)
+static bool wlc_phy_war41476(phy_info_t *pi)
 {
 	uint32 mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);
 
@@ -397,7 +397,7 @@ static bool wlc_phy_war41476(phy_info_t
 }
 #endif
 
-uint16 read_phy_reg(phy_info_t * pi, uint16 addr)
+uint16 read_phy_reg(phy_info_t *pi, uint16 addr)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -418,7 +418,7 @@ uint16 read_phy_reg(phy_info_t * pi, uin
 	return (R_REG(osh, &regs->phyregdata));
 }
 
-void write_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
+void write_phy_reg(phy_info_t *pi, uint16 addr, uint16 val)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -444,7 +444,7 @@ void write_phy_reg(phy_info_t * pi, uint
 #endif
 }
 
-void and_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
+void and_phy_reg(phy_info_t *pi, uint16 addr, uint16 val)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -465,7 +465,7 @@ void and_phy_reg(phy_info_t * pi, uint16
 	pi->phy_wreg = 0;
 }
 
-void or_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
+void or_phy_reg(phy_info_t *pi, uint16 addr, uint16 val)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -486,7 +486,7 @@ void or_phy_reg(phy_info_t * pi, uint16
 	pi->phy_wreg = 0;
 }
 
-void mod_phy_reg(phy_info_t * pi, uint16 addr, uint16 mask, uint16 val)
+void mod_phy_reg(phy_info_t *pi, uint16 addr, uint16 mask, uint16 val)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -508,7 +508,7 @@ void mod_phy_reg(phy_info_t * pi, uint16
 	pi->phy_wreg = 0;
 }
 
-static void WLBANDINITFN(wlc_set_phy_uninitted) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_set_phy_uninitted) (phy_info_t *pi) {
 	int i, j;
 
 	pi->initialized = FALSE;
@@ -544,7 +544,7 @@ static void WLBANDINITFN(wlc_set_phy_uni
 	}
 }
 
-shared_phy_t *BCMATTACHFN(wlc_phy_shared_attach) (shared_phy_params_t * shp) {
+shared_phy_t *BCMATTACHFN(wlc_phy_shared_attach) (shared_phy_params_t *shp) {
 	shared_phy_t *sh;
 
 	if ((sh =
@@ -582,7 +582,7 @@ shared_phy_t *BCMATTACHFN(wlc_phy_shared
 	return sh;
 }
 
-void BCMATTACHFN(wlc_phy_shared_detach) (shared_phy_t * phy_sh) {
+void BCMATTACHFN(wlc_phy_shared_detach) (shared_phy_t *phy_sh) {
 	osl_t *osh;
 
 	if (phy_sh) {
@@ -595,7 +595,7 @@ void BCMATTACHFN(wlc_phy_shared_detach)
 	}
 }
 
-wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (shared_phy_t * sh, void *regs,
+wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (shared_phy_t *sh, void *regs,
 					int bandtype, char *vars) {
 	phy_info_t *pi;
 	uint32 sflags = 0;
@@ -774,7 +774,7 @@ wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (
 	return NULL;
 }
 
-void BCMATTACHFN(wlc_phy_detach) (wlc_phy_t * pih) {
+void BCMATTACHFN(wlc_phy_detach) (wlc_phy_t *pih) {
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	if (pih) {
@@ -802,8 +802,8 @@ void BCMATTACHFN(wlc_phy_detach) (wlc_ph
 }
 
 bool
-wlc_phy_get_phyversion(wlc_phy_t * pih, uint16 * phytype, uint16 * phyrev,
-		       uint16 * radioid, uint16 * radiover)
+wlc_phy_get_phyversion(wlc_phy_t *pih, uint16 *phytype, uint16 *phyrev,
+		       uint16 *radioid, uint16 *radiover)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	*phytype = (uint16) pi->pubpi.phy_type;
@@ -814,13 +814,13 @@ wlc_phy_get_phyversion(wlc_phy_t * pih,
 	return TRUE;
 }
 
-bool wlc_phy_get_encore(wlc_phy_t * pih)
+bool wlc_phy_get_encore(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	return pi->pubpi.abgphy_encore;
 }
 
-uint32 wlc_phy_get_coreflags(wlc_phy_t * pih)
+uint32 wlc_phy_get_coreflags(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	return pi->pubpi.coreflags;
@@ -849,7 +849,7 @@ static void wlc_phy_timercb_phycal(void
 
 }
 
-void wlc_phy_anacore(wlc_phy_t * pih, bool on)
+void wlc_phy_anacore(wlc_phy_t *pih, bool on)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -886,7 +886,7 @@ void wlc_phy_anacore(wlc_phy_t * pih, bo
 	}
 }
 
-uint32 wlc_phy_clk_bwbits(wlc_phy_t * pih)
+uint32 wlc_phy_clk_bwbits(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -912,13 +912,13 @@ uint32 wlc_phy_clk_bwbits(wlc_phy_t * pi
 	return phy_bw_clkbits;
 }
 
-void WLBANDINITFN(wlc_phy_por_inform) (wlc_phy_t * ppi) {
+void WLBANDINITFN(wlc_phy_por_inform) (wlc_phy_t *ppi) {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	pi->phy_init_por = TRUE;
 }
 
-void wlc_phy_edcrs_lock(wlc_phy_t * pih, bool lock)
+void wlc_phy_edcrs_lock(wlc_phy_t *pih, bool lock)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -930,14 +930,14 @@ void wlc_phy_edcrs_lock(wlc_phy_t * pih,
 	write_phy_reg(pi, 0x22f, 0x3c0);
 }
 
-void wlc_phy_initcal_enable(wlc_phy_t * pih, bool initcal)
+void wlc_phy_initcal_enable(wlc_phy_t *pih, bool initcal)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	pi->do_initcal = initcal;
 }
 
-void wlc_phy_hw_clk_state_upd(wlc_phy_t * pih, bool newstate)
+void wlc_phy_hw_clk_state_upd(wlc_phy_t *pih, bool newstate)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -947,7 +947,7 @@ void wlc_phy_hw_clk_state_upd(wlc_phy_t
 	pi->sh->clk = newstate;
 }
 
-void wlc_phy_hw_state_upd(wlc_phy_t * pih, bool newstate)
+void wlc_phy_hw_state_upd(wlc_phy_t *pih, bool newstate)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -957,7 +957,7 @@ void wlc_phy_hw_state_upd(wlc_phy_t * pi
 	pi->sh->up = newstate;
 }
 
-void WLBANDINITFN(wlc_phy_init) (wlc_phy_t * pih, chanspec_t chanspec) {
+void WLBANDINITFN(wlc_phy_init) (wlc_phy_t *pih, chanspec_t chanspec) {
 	uint32 mc;
 	initfn_t phy_init = NULL;
 	phy_info_t *pi = (phy_info_t *) pih;
@@ -1016,7 +1016,7 @@ void WLBANDINITFN(wlc_phy_init) (wlc_phy
 	pi->init_in_progress = FALSE;
 }
 
-void BCMINITFN(wlc_phy_cal_init) (wlc_phy_t * pih) {
+void BCMINITFN(wlc_phy_cal_init) (wlc_phy_t *pih) {
 	phy_info_t *pi = (phy_info_t *) pih;
 	initfn_t cal_init = NULL;
 
@@ -1031,7 +1031,7 @@ void BCMINITFN(wlc_phy_cal_init) (wlc_ph
 	}
 }
 
-int BCMUNINITFN(wlc_phy_down) (wlc_phy_t * pih) {
+int BCMUNINITFN(wlc_phy_down) (wlc_phy_t *pih) {
 	phy_info_t *pi = (phy_info_t *) pih;
 	int callbacks = 0;
 
@@ -1047,7 +1047,7 @@ int BCMUNINITFN(wlc_phy_down) (wlc_phy_t
 	return callbacks;
 }
 
-static uint32 wlc_phy_get_radio_ver(phy_info_t * pi)
+static uint32 wlc_phy_get_radio_ver(phy_info_t *pi)
 {
 	uint32 ver;
 
@@ -1057,7 +1057,7 @@ static uint32 wlc_phy_get_radio_ver(phy_
 }
 
 void
-wlc_phy_table_addr(phy_info_t * pi, uint tbl_id, uint tbl_offset,
+wlc_phy_table_addr(phy_info_t *pi, uint tbl_id, uint tbl_offset,
 		   uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
 {
 	write_phy_reg(pi, tblAddr, (tbl_id << 10) | tbl_offset);
@@ -1074,7 +1074,7 @@ wlc_phy_table_addr(phy_info_t * pi, uint
 	}
 }
 
-void wlc_phy_table_data_write(phy_info_t * pi, uint width, uint32 val)
+void wlc_phy_table_data_write(phy_info_t *pi, uint width, uint32 val)
 {
 	ASSERT((width == 8) || (width == 16) || (width == 32));
 
@@ -1100,7 +1100,7 @@ void wlc_phy_table_data_write(phy_info_t
 }
 
 void
-wlc_phy_write_table(phy_info_t * pi, const phytbl_info_t * ptbl_info,
+wlc_phy_write_table(phy_info_t *pi, const phytbl_info_t *ptbl_info,
 		    uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
 {
 	uint idx;
@@ -1143,7 +1143,7 @@ wlc_phy_write_table(phy_info_t * pi, con
 }
 
 void
-wlc_phy_read_table(phy_info_t * pi, const phytbl_info_t * ptbl_info,
+wlc_phy_read_table(phy_info_t *pi, const phytbl_info_t *ptbl_info,
 		   uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
 {
 	uint idx;
@@ -1184,7 +1184,7 @@ wlc_phy_read_table(phy_info_t * pi, cons
 }
 
 uint
-wlc_phy_init_radio_regs_allbands(phy_info_t * pi, radio_20xx_regs_t * radioregs)
+wlc_phy_init_radio_regs_allbands(phy_info_t *pi, radio_20xx_regs_t *radioregs)
 {
 	uint i = 0;
 
@@ -1201,7 +1201,7 @@ wlc_phy_init_radio_regs_allbands(phy_inf
 }
 
 uint
-wlc_phy_init_radio_regs(phy_info_t * pi, radio_regs_t * radioregs,
+wlc_phy_init_radio_regs(phy_info_t *pi, radio_regs_t *radioregs,
 			uint16 core_offset)
 {
 	uint i = 0;
@@ -1234,7 +1234,7 @@ wlc_phy_init_radio_regs(phy_info_t * pi,
 	return i;
 }
 
-void wlc_phy_do_dummy_tx(phy_info_t * pi, bool ofdm, bool pa_on)
+void wlc_phy_do_dummy_tx(phy_info_t *pi, bool ofdm, bool pa_on)
 {
 #define	DUMMY_PKT_LEN	20
 	d11regs_t *regs = pi->regs;
@@ -1320,7 +1320,7 @@ void wlc_phy_do_dummy_tx(phy_info_t * pi
 	}
 }
 
-void wlc_phy_hold_upd(wlc_phy_t * pih, mbool id, bool set)
+void wlc_phy_hold_upd(wlc_phy_t *pih, mbool id, bool set)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	ASSERT(id);
@@ -1334,7 +1334,7 @@ void wlc_phy_hold_upd(wlc_phy_t * pih, m
 	return;
 }
 
-void wlc_phy_mute_upd(wlc_phy_t * pih, bool mute, mbool flags)
+void wlc_phy_mute_upd(wlc_phy_t *pih, bool mute, mbool flags)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -1349,7 +1349,7 @@ void wlc_phy_mute_upd(wlc_phy_t * pih, b
 	return;
 }
 
-void wlc_phy_clear_tssi(wlc_phy_t * pih)
+void wlc_phy_clear_tssi(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -1363,12 +1363,12 @@ void wlc_phy_clear_tssi(wlc_phy_t * pih)
 	}
 }
 
-static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t * pi)
+static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t *pi)
 {
 	return FALSE;
 }
 
-void wlc_phy_switch_radio(wlc_phy_t * pih, bool on)
+void wlc_phy_switch_radio(wlc_phy_t *pih, bool on)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -1411,35 +1411,35 @@ void wlc_phy_switch_radio(wlc_phy_t * pi
 	}
 }
 
-uint16 wlc_phy_bw_state_get(wlc_phy_t * ppi)
+uint16 wlc_phy_bw_state_get(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	return pi->bw;
 }
 
-void wlc_phy_bw_state_set(wlc_phy_t * ppi, uint16 bw)
+void wlc_phy_bw_state_set(wlc_phy_t *ppi, uint16 bw)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	pi->bw = bw;
 }
 
-void wlc_phy_chanspec_radio_set(wlc_phy_t * ppi, chanspec_t newch)
+void wlc_phy_chanspec_radio_set(wlc_phy_t *ppi, chanspec_t newch)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	pi->radio_chanspec = newch;
 
 }
 
-chanspec_t wlc_phy_chanspec_get(wlc_phy_t * ppi)
+chanspec_t wlc_phy_chanspec_get(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	return pi->radio_chanspec;
 }
 
-void wlc_phy_chanspec_set(wlc_phy_t * ppi, chanspec_t chanspec)
+void wlc_phy_chanspec_set(wlc_phy_t *ppi, chanspec_t chanspec)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	uint16 m_cur_channel;
@@ -1476,7 +1476,7 @@ int wlc_phy_chanspec_freq2bandrange_lpss
 	return range;
 }
 
-int wlc_phy_chanspec_bandrange_get(phy_info_t * pi, chanspec_t chanspec)
+int wlc_phy_chanspec_bandrange_get(phy_info_t *pi, chanspec_t chanspec)
 {
 	int range = -1;
 	uint channel = CHSPEC_CHANNEL(chanspec);
@@ -1492,7 +1492,7 @@ int wlc_phy_chanspec_bandrange_get(phy_i
 	return range;
 }
 
-void wlc_phy_chanspec_ch14_widefilter_set(wlc_phy_t * ppi, bool wide_filter)
+void wlc_phy_chanspec_ch14_widefilter_set(wlc_phy_t *ppi, bool wide_filter)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
@@ -1511,7 +1511,7 @@ int wlc_phy_channel2freq(uint channel)
 }
 
 void
-wlc_phy_chanspec_band_validch(wlc_phy_t * ppi, uint band, chanvec_t * channels)
+wlc_phy_chanspec_band_validch(wlc_phy_t *ppi, uint band, chanvec_t *channels)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	uint i;
@@ -1534,7 +1534,7 @@ wlc_phy_chanspec_band_validch(wlc_phy_t
 	}
 }
 
-chanspec_t wlc_phy_chanspec_band_firstch(wlc_phy_t * ppi, uint band)
+chanspec_t wlc_phy_chanspec_band_firstch(wlc_phy_t *ppi, uint band)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	uint i;
@@ -1583,7 +1583,7 @@ chanspec_t wlc_phy_chanspec_band_firstch
 	return (chanspec_t) INVCHANSPEC;
 }
 
-int wlc_phy_txpower_get(wlc_phy_t * ppi, uint * qdbm, bool * override)
+int wlc_phy_txpower_get(wlc_phy_t *ppi, uint *qdbm, bool *override)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
@@ -1594,7 +1594,7 @@ int wlc_phy_txpower_get(wlc_phy_t * ppi,
 	return (0);
 }
 
-void wlc_phy_txpower_target_set(wlc_phy_t * ppi, struct txpwr_limits *txpwr)
+void wlc_phy_txpower_target_set(wlc_phy_t *ppi, struct txpwr_limits *txpwr)
 {
 	bool mac_enabled = FALSE;
 	phy_info_t *pi = (phy_info_t *) ppi;
@@ -1647,7 +1647,7 @@ void wlc_phy_txpower_target_set(wlc_phy_
 		wlapi_enable_mac(pi->sh->physhim);
 }
 
-int wlc_phy_txpower_set(wlc_phy_t * ppi, uint qdbm, bool override)
+int wlc_phy_txpower_set(wlc_phy_t *ppi, uint qdbm, bool override)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	int i;
@@ -1683,8 +1683,8 @@ int wlc_phy_txpower_set(wlc_phy_t * ppi,
 }
 
 void
-wlc_phy_txpower_sromlimit(wlc_phy_t * ppi, uint channel, uint8 * min_pwr,
-			  uint8 * max_pwr, int txp_rate_idx)
+wlc_phy_txpower_sromlimit(wlc_phy_t *ppi, uint channel, uint8 *min_pwr,
+			  uint8 *max_pwr, int txp_rate_idx)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	uint i;
@@ -1734,8 +1734,8 @@ wlc_phy_txpower_sromlimit(wlc_phy_t * pp
 }
 
 void
-wlc_phy_txpower_sromlimit_max_get(wlc_phy_t * ppi, uint chan, uint8 * max_txpwr,
-				  uint8 * min_txpwr)
+wlc_phy_txpower_sromlimit_max_get(wlc_phy_t *ppi, uint chan, uint8 *max_txpwr,
+				  uint8 *min_txpwr)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	uint8 tx_pwr_max = 0;
@@ -1765,27 +1765,27 @@ wlc_phy_txpower_sromlimit_max_get(wlc_ph
 }
 
 void
-wlc_phy_txpower_boardlimit_band(wlc_phy_t * ppi, uint bandunit, int32 * max_pwr,
-				int32 * min_pwr, uint32 * step_pwr)
+wlc_phy_txpower_boardlimit_band(wlc_phy_t *ppi, uint bandunit, int32 *max_pwr,
+				int32 *min_pwr, uint32 *step_pwr)
 {
 	return;
 }
 
-uint8 wlc_phy_txpower_get_target_min(wlc_phy_t * ppi)
+uint8 wlc_phy_txpower_get_target_min(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	return pi->tx_power_min;
 }
 
-uint8 wlc_phy_txpower_get_target_max(wlc_phy_t * ppi)
+uint8 wlc_phy_txpower_get_target_max(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	return pi->tx_power_max;
 }
 
-void wlc_phy_txpower_recalc_target(phy_info_t * pi)
+void wlc_phy_txpower_recalc_target(phy_info_t *pi)
 {
 	uint8 maxtxpwr, mintxpwr, rate, pactrl;
 	uint target_chan;
@@ -1904,7 +1904,7 @@ void wlc_phy_txpower_recalc_target(phy_i
 }
 
 void
-wlc_phy_txpower_reg_limit_calc(phy_info_t * pi, struct txpwr_limits *txpwr,
+wlc_phy_txpower_reg_limit_calc(phy_info_t *pi, struct txpwr_limits *txpwr,
 			       chanspec_t chanspec)
 {
 	uint8 tmp_txpwr_limit[2 * WLC_NUM_RATES_OFDM];
@@ -2056,21 +2056,21 @@ wlc_phy_txpower_reg_limit_calc(phy_info_
 	}
 }
 
-void wlc_phy_txpwr_percent_set(wlc_phy_t * ppi, uint8 txpwr_percent)
+void wlc_phy_txpwr_percent_set(wlc_phy_t *ppi, uint8 txpwr_percent)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	pi->txpwr_percent = txpwr_percent;
 }
 
-void wlc_phy_machwcap_set(wlc_phy_t * ppi, uint32 machwcap)
+void wlc_phy_machwcap_set(wlc_phy_t *ppi, uint32 machwcap)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	pi->sh->machwcap = machwcap;
 }
 
-void wlc_phy_runbist_config(wlc_phy_t * ppi, bool start_end)
+void wlc_phy_runbist_config(wlc_phy_t *ppi, bool start_end)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	uint16 rxc;
@@ -2101,7 +2101,7 @@ void wlc_phy_runbist_config(wlc_phy_t *
 }
 
 void
-wlc_phy_txpower_limit_set(wlc_phy_t * ppi, struct txpwr_limits *txpwr,
+wlc_phy_txpower_limit_set(wlc_phy_t *ppi, struct txpwr_limits *txpwr,
 			  chanspec_t chanspec)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
@@ -2126,21 +2126,21 @@ wlc_phy_txpower_limit_set(wlc_phy_t * pp
 	wlapi_enable_mac(pi->sh->physhim);
 }
 
-void wlc_phy_ofdm_rateset_war(wlc_phy_t * pih, bool war)
+void wlc_phy_ofdm_rateset_war(wlc_phy_t *pih, bool war)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	pi->ofdm_rateset_war = war;
 }
 
-void wlc_phy_bf_preempt_enable(wlc_phy_t * pih, bool bf_preempt)
+void wlc_phy_bf_preempt_enable(wlc_phy_t *pih, bool bf_preempt)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
 	pi->bf_preempt_4306 = bf_preempt;
 }
 
-void wlc_phy_txpower_update_shm(phy_info_t * pi)
+void wlc_phy_txpower_update_shm(phy_info_t *pi)
 {
 	int j;
 	if (ISNPHY(pi)) {
@@ -2192,7 +2192,7 @@ void wlc_phy_txpower_update_shm(phy_info
 	}
 }
 
-bool wlc_phy_txpower_hw_ctrl_get(wlc_phy_t * ppi)
+bool wlc_phy_txpower_hw_ctrl_get(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
@@ -2203,7 +2203,7 @@ bool wlc_phy_txpower_hw_ctrl_get(wlc_phy
 	}
 }
 
-void wlc_phy_txpower_hw_ctrl_set(wlc_phy_t * ppi, bool hwpwrctrl)
+void wlc_phy_txpower_hw_ctrl_set(wlc_phy_t *ppi, bool hwpwrctrl)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	bool cur_hwpwrctrl = pi->hwpwrctrl;
@@ -2241,7 +2241,7 @@ void wlc_phy_txpower_hw_ctrl_set(wlc_phy
 	}
 }
 
-void wlc_phy_txpower_ipa_upd(phy_info_t * pi)
+void wlc_phy_txpower_ipa_upd(phy_info_t *pi)
 {
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
@@ -2253,9 +2253,9 @@ void wlc_phy_txpower_ipa_upd(phy_info_t
 	}
 }
 
-static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t * pi);
+static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t *pi);
 
-static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t * pi)
+static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t *pi)
 {
 	int16 tx0_status, tx1_status;
 	uint16 estPower1, estPower2;
@@ -2305,7 +2305,7 @@ static uint32 wlc_phy_txpower_est_power_
 }
 
 void
-wlc_phy_txpower_get_current(wlc_phy_t * ppi, tx_power_t * power, uint channel)
+wlc_phy_txpower_get_current(wlc_phy_t *ppi, tx_power_t *power, uint channel)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	uint rate, num_rates;
@@ -2402,21 +2402,21 @@ wlc_phy_txpower_get_current(wlc_phy_t *
 	}
 }
 
-void wlc_phy_antsel_type_set(wlc_phy_t * ppi, uint8 antsel_type)
+void wlc_phy_antsel_type_set(wlc_phy_t *ppi, uint8 antsel_type)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	pi->antsel_type = antsel_type;
 }
 
-bool wlc_phy_test_ison(wlc_phy_t * ppi)
+bool wlc_phy_test_ison(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
 	return (pi->phytest_on);
 }
 
-bool wlc_phy_ant_rxdiv_get(wlc_phy_t * ppi, uint8 * pval)
+bool wlc_phy_ant_rxdiv_get(wlc_phy_t *ppi, uint8 *pval)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	bool ret = TRUE;
@@ -2437,7 +2437,7 @@ bool wlc_phy_ant_rxdiv_get(wlc_phy_t * p
 	return ret;
 }
 
-void wlc_phy_ant_rxdiv_set(wlc_phy_t * ppi, uint8 val)
+void wlc_phy_ant_rxdiv_set(wlc_phy_t *ppi, uint8 val)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	bool suspend;
@@ -2487,7 +2487,7 @@ void wlc_phy_ant_rxdiv_set(wlc_phy_t * p
 }
 
 static bool
-wlc_phy_noise_calc_phy(phy_info_t * pi, uint32 * cmplx_pwr, int8 * pwr_ant)
+wlc_phy_noise_calc_phy(phy_info_t *pi, uint32 *cmplx_pwr, int8 *pwr_ant)
 {
 	int8 cmplx_pwr_dbm[PHY_CORE_MAX];
 	uint8 i;
@@ -2514,7 +2514,7 @@ wlc_phy_noise_calc_phy(phy_info_t * pi,
 }
 
 static void
-wlc_phy_noise_sample_request(wlc_phy_t * pih, uint8 reason, uint8 ch)
+wlc_phy_noise_sample_request(wlc_phy_t *pih, uint8 reason, uint8 ch)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
@@ -2649,7 +2649,7 @@ wlc_phy_noise_sample_request(wlc_phy_t *
 
 }
 
-void wlc_phy_noise_sample_request_external(wlc_phy_t * pih)
+void wlc_phy_noise_sample_request_external(wlc_phy_t *pih)
 {
 	uint8 channel;
 
@@ -2658,7 +2658,7 @@ void wlc_phy_noise_sample_request_extern
 	wlc_phy_noise_sample_request(pih, PHY_NOISE_SAMPLE_EXTERNAL, channel);
 }
 
-static void wlc_phy_noise_cb(phy_info_t * pi, uint8 channel, int8 noise_dbm)
+static void wlc_phy_noise_cb(phy_info_t *pi, uint8 channel, int8 noise_dbm)
 {
 	if (!pi->phynoise_state)
 		return;
@@ -2679,7 +2679,7 @@ static void wlc_phy_noise_cb(phy_info_t
 
 }
 
-static int8 wlc_phy_noise_read_shmem(phy_info_t * pi)
+static int8 wlc_phy_noise_read_shmem(phy_info_t *pi)
 {
 	uint32 cmplx_pwr[PHY_CORE_MAX];
 	int8 noise_dbm_ant[PHY_CORE_MAX];
@@ -2721,7 +2721,7 @@ static int8 wlc_phy_noise_read_shmem(phy
 
 }
 
-void wlc_phy_noise_sample_intr(wlc_phy_t * pih)
+void wlc_phy_noise_sample_intr(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	uint16 jssi_aux;
@@ -2819,7 +2819,7 @@ int8 lcnphy_gain_index_offset_for_pkt_rs
 	0
 };
 
-void wlc_phy_compute_dB(uint32 * cmplx_pwr, int8 * p_cmplx_pwr_dB, uint8 core)
+void wlc_phy_compute_dB(uint32 *cmplx_pwr, int8 *p_cmplx_pwr_dB, uint8 core)
 {
 	uint8 shift_ct, lsb, msb, secondmsb, i;
 	uint32 tmp;
@@ -2839,7 +2839,7 @@ void wlc_phy_compute_dB(uint32 * cmplx_p
 	}
 }
 
-void BCMFASTPATH wlc_phy_rssi_compute(wlc_phy_t * pih, void *ctx)
+void BCMFASTPATH wlc_phy_rssi_compute(wlc_phy_t *pih, void *ctx)
 {
 	wlc_d11rxhdr_t *wlc_rxhdr = (wlc_d11rxhdr_t *) ctx;
 	d11rxhdr_t *rxh = &wlc_rxhdr->rxhdr;
@@ -2891,17 +2891,17 @@ void BCMFASTPATH wlc_phy_rssi_compute(wl
 	wlc_rxhdr->rssi = (int8) rssi;
 }
 
-void wlc_phy_freqtrack_start(wlc_phy_t * pih)
+void wlc_phy_freqtrack_start(wlc_phy_t *pih)
 {
 	return;
 }
 
-void wlc_phy_freqtrack_end(wlc_phy_t * pih)
+void wlc_phy_freqtrack_end(wlc_phy_t *pih)
 {
 	return;
 }
 
-void wlc_phy_set_deaf(wlc_phy_t * ppi, bool user_flag)
+void wlc_phy_set_deaf(wlc_phy_t *ppi, bool user_flag)
 {
 	phy_info_t *pi;
 	pi = (phy_info_t *) ppi;
@@ -2915,7 +2915,7 @@ void wlc_phy_set_deaf(wlc_phy_t * ppi, b
 	}
 }
 
-void wlc_phy_watchdog(wlc_phy_t * pih)
+void wlc_phy_watchdog(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	bool delay_phy_cal = FALSE;
@@ -2980,7 +2980,7 @@ void wlc_phy_watchdog(wlc_phy_t * pih)
 	}
 }
 
-void wlc_phy_BSSinit(wlc_phy_t * pih, bool bonlyap, int rssi)
+void wlc_phy_BSSinit(wlc_phy_t *pih, bool bonlyap, int rssi)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	uint i;
@@ -3004,7 +3004,7 @@ void wlc_phy_BSSinit(wlc_phy_t * pih, bo
 }
 
 void
-wlc_phy_papd_decode_epsilon(uint32 epsilon, int32 * eps_real, int32 * eps_imag)
+wlc_phy_papd_decode_epsilon(uint32 epsilon, int32 *eps_real, int32 *eps_imag)
 {
 	if ((*eps_imag = (epsilon >> 13)) > 0xfff)
 		*eps_imag -= 0x2000;
@@ -3033,7 +3033,7 @@ static const fixed AtanTbl[] = {
 	29
 };
 
-void wlc_phy_cordic(fixed theta, cint32 * val)
+void wlc_phy_cordic(fixed theta, cint32 *val)
 {
 	fixed angle, valtmp;
 	unsigned iter;
@@ -3075,7 +3075,7 @@ void wlc_phy_cordic(fixed theta, cint32
 	val[0].q = val[0].q * signx;
 }
 
-void wlc_phy_cal_perical_mphase_reset(phy_info_t * pi)
+void wlc_phy_cal_perical_mphase_reset(phy_info_t *pi)
 {
 	wlapi_del_timer(pi->sh->physhim, pi->phycal_timer);
 
@@ -3084,7 +3084,7 @@ void wlc_phy_cal_perical_mphase_reset(ph
 	pi->mphase_txcal_cmdidx = 0;
 }
 
-static void wlc_phy_cal_perical_mphase_schedule(phy_info_t * pi, uint delay)
+static void wlc_phy_cal_perical_mphase_schedule(phy_info_t *pi, uint delay)
 {
 
 	if ((pi->nphy_perical != PHY_PERICAL_MPHASE) &&
@@ -3097,7 +3097,7 @@ static void wlc_phy_cal_perical_mphase_s
 	wlapi_add_timer(pi->sh->physhim, pi->phycal_timer, delay, 0);
 }
 
-void wlc_phy_cal_perical(wlc_phy_t * pih, uint8 reason)
+void wlc_phy_cal_perical(wlc_phy_t *pih, uint8 reason)
 {
 	int16 nphy_currtemp = 0;
 	int16 delta_temp = 0;
@@ -3181,7 +3181,7 @@ void wlc_phy_cal_perical(wlc_phy_t * pih
 	}
 }
 
-void wlc_phy_cal_perical_mphase_restart(phy_info_t * pi)
+void wlc_phy_cal_perical_mphase_restart(phy_info_t *pi)
 {
 	pi->mphase_cal_phase_id = MPHASE_CAL_STATE_INIT;
 	pi->mphase_txcal_cmdidx = 0;
@@ -3218,7 +3218,7 @@ uint32 wlc_phy_sqrt_int(uint32 value)
 	return root;
 }
 
-void wlc_phy_stf_chain_init(wlc_phy_t * pih, uint8 txchain, uint8 rxchain)
+void wlc_phy_stf_chain_init(wlc_phy_t *pih, uint8 txchain, uint8 rxchain)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -3229,7 +3229,7 @@ void wlc_phy_stf_chain_init(wlc_phy_t *
 	pi->pubpi.phy_corenum = (uint8) PHY_BITSCNT(pi->sh->phyrxchain);
 }
 
-void wlc_phy_stf_chain_set(wlc_phy_t * pih, uint8 txchain, uint8 rxchain)
+void wlc_phy_stf_chain_set(wlc_phy_t *pih, uint8 txchain, uint8 rxchain)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -3241,7 +3241,7 @@ void wlc_phy_stf_chain_set(wlc_phy_t * p
 	pi->pubpi.phy_corenum = (uint8) PHY_BITSCNT(pi->sh->phyrxchain);
 }
 
-void wlc_phy_stf_chain_get(wlc_phy_t * pih, uint8 * txchain, uint8 * rxchain)
+void wlc_phy_stf_chain_get(wlc_phy_t *pih, uint8 *txchain, uint8 *rxchain)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 
@@ -3249,7 +3249,7 @@ void wlc_phy_stf_chain_get(wlc_phy_t * p
 	*rxchain = pi->sh->phyrxchain;
 }
 
-uint8 wlc_phy_stf_chain_active_get(wlc_phy_t * pih)
+uint8 wlc_phy_stf_chain_active_get(wlc_phy_t *pih)
 {
 	int16 nphy_currtemp;
 	uint8 active_bitmap;
@@ -3281,7 +3281,7 @@ uint8 wlc_phy_stf_chain_active_get(wlc_p
 	return active_bitmap;
 }
 
-int8 wlc_phy_stf_ssmode_get(wlc_phy_t * pih, chanspec_t chanspec)
+int8 wlc_phy_stf_ssmode_get(wlc_phy_t *pih, chanspec_t chanspec)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	uint8 siso_mcs_id, cdd_mcs_id;
@@ -3305,7 +3305,7 @@ const uint8 *wlc_phy_get_ofdm_rate_looku
 	return ofdm_rate_lookup;
 }
 
-void wlc_lcnphy_epa_switch(phy_info_t * pi, bool mode)
+void wlc_lcnphy_epa_switch(phy_info_t *pi, bool mode)
 {
 	if ((CHIPID(pi->sh->chip) == BCM4313_CHIP_ID) &&
 	    (pi->sh->boardflags & BFL_FEM)) {
@@ -3343,7 +3343,7 @@ void wlc_lcnphy_epa_switch(phy_info_t *
 }
 
 static int8
-wlc_user_txpwr_antport_to_rfport(phy_info_t * pi, uint chan, uint32 band,
+wlc_user_txpwr_antport_to_rfport(phy_info_t *pi, uint chan, uint32 band,
 				 uint8 rate)
 {
 	int8 offset = 0;
@@ -3353,7 +3353,7 @@ wlc_user_txpwr_antport_to_rfport(phy_inf
 	return offset;
 }
 
-static int8 wlc_phy_env_measure_vbat(phy_info_t * pi)
+static int8 wlc_phy_env_measure_vbat(phy_info_t *pi)
 {
 	if (ISLCNPHY(pi))
 		return wlc_lcnphy_vbatsense(pi, 0);
@@ -3361,7 +3361,7 @@ static int8 wlc_phy_env_measure_vbat(phy
 		return 0;
 }
 
-static int8 wlc_phy_env_measure_temperature(phy_info_t * pi)
+static int8 wlc_phy_env_measure_temperature(phy_info_t *pi)
 {
 	if (ISLCNPHY(pi))
 		return wlc_lcnphy_tempsense_degree(pi, 0);
@@ -3369,7 +3369,7 @@ static int8 wlc_phy_env_measure_temperat
 		return 0;
 }
 
-static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t * pi, uint32 band)
+static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t *pi, uint32 band)
 {
 	uint8 i;
 	int8 temp, vbat;
@@ -3382,13 +3382,13 @@ static void wlc_phy_upd_env_txpwr_rate_l
 
 }
 
-void wlc_phy_ldpc_override_set(wlc_phy_t * ppi, bool ldpc)
+void wlc_phy_ldpc_override_set(wlc_phy_t *ppi, bool ldpc)
 {
 	return;
 }
 
 void
-wlc_phy_get_pwrdet_offsets(phy_info_t * pi, int8 * cckoffset, int8 * ofdmoffset)
+wlc_phy_get_pwrdet_offsets(phy_info_t *pi, int8 *cckoffset, int8 *ofdmoffset)
 {
 	*cckoffset = 0;
 	*ofdmoffset = 0;
@@ -3421,13 +3421,13 @@ uint32 wlc_phy_qdiv_roundup(uint32 divid
 	return quotient;
 }
 
-int8 wlc_phy_upd_rssi_offset(phy_info_t * pi, int8 rssi, chanspec_t chanspec)
+int8 wlc_phy_upd_rssi_offset(phy_info_t *pi, int8 rssi, chanspec_t chanspec)
 {
 
 	return rssi;
 }
 
-bool wlc_phy_txpower_ipa_ison(wlc_phy_t * ppi)
+bool wlc_phy_txpower_ipa_ison(wlc_phy_t *ppi)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 
--- a/drivers/staging/brcm80211/phy/wlc_phy_hal.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_hal.h
@@ -153,111 +153,111 @@ typedef struct shared_phy_params {
 
 #ifdef WLC_LOW
 
-extern shared_phy_t *wlc_phy_shared_attach(shared_phy_params_t * shp);
-extern void wlc_phy_shared_detach(shared_phy_t * phy_sh);
-extern wlc_phy_t *wlc_phy_attach(shared_phy_t * sh, void *regs, int bandtype,
+extern shared_phy_t *wlc_phy_shared_attach(shared_phy_params_t *shp);
+extern void wlc_phy_shared_detach(shared_phy_t *phy_sh);
+extern wlc_phy_t *wlc_phy_attach(shared_phy_t *sh, void *regs, int bandtype,
 				 char *vars);
-extern void wlc_phy_detach(wlc_phy_t * ppi);
+extern void wlc_phy_detach(wlc_phy_t *ppi);
 
-extern bool wlc_phy_get_phyversion(wlc_phy_t * pih, uint16 * phytype,
-				   uint16 * phyrev, uint16 * radioid,
-				   uint16 * radiover);
-extern bool wlc_phy_get_encore(wlc_phy_t * pih);
-extern uint32 wlc_phy_get_coreflags(wlc_phy_t * pih);
-
-extern void wlc_phy_hw_clk_state_upd(wlc_phy_t * ppi, bool newstate);
-extern void wlc_phy_hw_state_upd(wlc_phy_t * ppi, bool newstate);
-extern void wlc_phy_init(wlc_phy_t * ppi, chanspec_t chanspec);
-extern void wlc_phy_watchdog(wlc_phy_t * ppi);
-extern int wlc_phy_down(wlc_phy_t * ppi);
-extern uint32 wlc_phy_clk_bwbits(wlc_phy_t * pih);
-extern void wlc_phy_cal_init(wlc_phy_t * ppi);
-extern void wlc_phy_antsel_init(wlc_phy_t * ppi, bool lut_init);
-
-extern void wlc_phy_chanspec_set(wlc_phy_t * ppi, chanspec_t chanspec);
-extern chanspec_t wlc_phy_chanspec_get(wlc_phy_t * ppi);
-extern void wlc_phy_chanspec_radio_set(wlc_phy_t * ppi, chanspec_t newch);
-extern uint16 wlc_phy_bw_state_get(wlc_phy_t * ppi);
-extern void wlc_phy_bw_state_set(wlc_phy_t * ppi, uint16 bw);
-
-extern void wlc_phy_rssi_compute(wlc_phy_t * pih, void *ctx);
-extern void wlc_phy_por_inform(wlc_phy_t * ppi);
-extern void wlc_phy_noise_sample_intr(wlc_phy_t * ppi);
-extern bool wlc_phy_bist_check_phy(wlc_phy_t * ppi);
+extern bool wlc_phy_get_phyversion(wlc_phy_t *pih, uint16 *phytype,
+				   uint16 *phyrev, uint16 *radioid,
+				   uint16 *radiover);
+extern bool wlc_phy_get_encore(wlc_phy_t *pih);
+extern uint32 wlc_phy_get_coreflags(wlc_phy_t *pih);
+
+extern void wlc_phy_hw_clk_state_upd(wlc_phy_t *ppi, bool newstate);
+extern void wlc_phy_hw_state_upd(wlc_phy_t *ppi, bool newstate);
+extern void wlc_phy_init(wlc_phy_t *ppi, chanspec_t chanspec);
+extern void wlc_phy_watchdog(wlc_phy_t *ppi);
+extern int wlc_phy_down(wlc_phy_t *ppi);
+extern uint32 wlc_phy_clk_bwbits(wlc_phy_t *pih);
+extern void wlc_phy_cal_init(wlc_phy_t *ppi);
+extern void wlc_phy_antsel_init(wlc_phy_t *ppi, bool lut_init);
+
+extern void wlc_phy_chanspec_set(wlc_phy_t *ppi, chanspec_t chanspec);
+extern chanspec_t wlc_phy_chanspec_get(wlc_phy_t *ppi);
+extern void wlc_phy_chanspec_radio_set(wlc_phy_t *ppi, chanspec_t newch);
+extern uint16 wlc_phy_bw_state_get(wlc_phy_t *ppi);
+extern void wlc_phy_bw_state_set(wlc_phy_t *ppi, uint16 bw);
+
+extern void wlc_phy_rssi_compute(wlc_phy_t *pih, void *ctx);
+extern void wlc_phy_por_inform(wlc_phy_t *ppi);
+extern void wlc_phy_noise_sample_intr(wlc_phy_t *ppi);
+extern bool wlc_phy_bist_check_phy(wlc_phy_t *ppi);
 
-extern void wlc_phy_set_deaf(wlc_phy_t * ppi, bool user_flag);
+extern void wlc_phy_set_deaf(wlc_phy_t *ppi, bool user_flag);
 
-extern void wlc_phy_switch_radio(wlc_phy_t * ppi, bool on);
-extern void wlc_phy_anacore(wlc_phy_t * ppi, bool on);
+extern void wlc_phy_switch_radio(wlc_phy_t *ppi, bool on);
+extern void wlc_phy_anacore(wlc_phy_t *ppi, bool on);
 
 #endif				/* WLC_LOW */
 
-extern void wlc_phy_BSSinit(wlc_phy_t * ppi, bool bonlyap, int rssi);
+extern void wlc_phy_BSSinit(wlc_phy_t *ppi, bool bonlyap, int rssi);
 
-extern void wlc_phy_chanspec_ch14_widefilter_set(wlc_phy_t * ppi,
+extern void wlc_phy_chanspec_ch14_widefilter_set(wlc_phy_t *ppi,
 						 bool wide_filter);
-extern void wlc_phy_chanspec_band_validch(wlc_phy_t * ppi, uint band,
-					  chanvec_t * channels);
-extern chanspec_t wlc_phy_chanspec_band_firstch(wlc_phy_t * ppi, uint band);
-
-extern void wlc_phy_txpower_sromlimit(wlc_phy_t * ppi, uint chan,
-				      uint8 * _min_, uint8 * _max_, int rate);
-extern void wlc_phy_txpower_sromlimit_max_get(wlc_phy_t * ppi, uint chan,
-					      uint8 * _max_, uint8 * _min_);
-extern void wlc_phy_txpower_boardlimit_band(wlc_phy_t * ppi, uint band, int32 *,
+extern void wlc_phy_chanspec_band_validch(wlc_phy_t *ppi, uint band,
+					  chanvec_t *channels);
+extern chanspec_t wlc_phy_chanspec_band_firstch(wlc_phy_t *ppi, uint band);
+
+extern void wlc_phy_txpower_sromlimit(wlc_phy_t *ppi, uint chan,
+				      uint8 *_min_, uint8 *_max_, int rate);
+extern void wlc_phy_txpower_sromlimit_max_get(wlc_phy_t *ppi, uint chan,
+					      uint8 *_max_, uint8 *_min_);
+extern void wlc_phy_txpower_boardlimit_band(wlc_phy_t *ppi, uint band, int32 *,
 					    int32 *, uint32 *);
-extern void wlc_phy_txpower_limit_set(wlc_phy_t * ppi, struct txpwr_limits *,
+extern void wlc_phy_txpower_limit_set(wlc_phy_t *ppi, struct txpwr_limits *,
 				      chanspec_t chanspec);
-extern int wlc_phy_txpower_get(wlc_phy_t * ppi, uint * qdbm, bool * override);
-extern int wlc_phy_txpower_set(wlc_phy_t * ppi, uint qdbm, bool override);
-extern void wlc_phy_txpower_target_set(wlc_phy_t * ppi, struct txpwr_limits *);
-extern bool wlc_phy_txpower_hw_ctrl_get(wlc_phy_t * ppi);
-extern void wlc_phy_txpower_hw_ctrl_set(wlc_phy_t * ppi, bool hwpwrctrl);
-extern uint8 wlc_phy_txpower_get_target_min(wlc_phy_t * ppi);
-extern uint8 wlc_phy_txpower_get_target_max(wlc_phy_t * ppi);
-extern bool wlc_phy_txpower_ipa_ison(wlc_phy_t * pih);
+extern int wlc_phy_txpower_get(wlc_phy_t *ppi, uint *qdbm, bool *override);
+extern int wlc_phy_txpower_set(wlc_phy_t *ppi, uint qdbm, bool override);
+extern void wlc_phy_txpower_target_set(wlc_phy_t *ppi, struct txpwr_limits *);
+extern bool wlc_phy_txpower_hw_ctrl_get(wlc_phy_t *ppi);
+extern void wlc_phy_txpower_hw_ctrl_set(wlc_phy_t *ppi, bool hwpwrctrl);
+extern uint8 wlc_phy_txpower_get_target_min(wlc_phy_t *ppi);
+extern uint8 wlc_phy_txpower_get_target_max(wlc_phy_t *ppi);
+extern bool wlc_phy_txpower_ipa_ison(wlc_phy_t *pih);
 
-extern void wlc_phy_stf_chain_init(wlc_phy_t * pih, uint8 txchain,
+extern void wlc_phy_stf_chain_init(wlc_phy_t *pih, uint8 txchain,
 				   uint8 rxchain);
-extern void wlc_phy_stf_chain_set(wlc_phy_t * pih, uint8 txchain,
+extern void wlc_phy_stf_chain_set(wlc_phy_t *pih, uint8 txchain,
 				  uint8 rxchain);
-extern void wlc_phy_stf_chain_get(wlc_phy_t * pih, uint8 * txchain,
-				  uint8 * rxchain);
-extern uint8 wlc_phy_stf_chain_active_get(wlc_phy_t * pih);
-extern int8 wlc_phy_stf_ssmode_get(wlc_phy_t * pih, chanspec_t chanspec);
-extern void wlc_phy_ldpc_override_set(wlc_phy_t * ppi, bool val);
-
-extern void wlc_phy_cal_perical(wlc_phy_t * ppi, uint8 reason);
-extern void wlc_phy_noise_sample_request_external(wlc_phy_t * ppi);
-extern void wlc_phy_edcrs_lock(wlc_phy_t * pih, bool lock);
-extern void wlc_phy_cal_papd_recal(wlc_phy_t * ppi);
-
-extern void wlc_phy_ant_rxdiv_set(wlc_phy_t * ppi, uint8 val);
-extern bool wlc_phy_ant_rxdiv_get(wlc_phy_t * ppi, uint8 * pval);
-extern void wlc_phy_clear_tssi(wlc_phy_t * ppi);
-extern void wlc_phy_hold_upd(wlc_phy_t * ppi, mbool id, bool val);
-extern void wlc_phy_mute_upd(wlc_phy_t * ppi, bool val, mbool flags);
+extern void wlc_phy_stf_chain_get(wlc_phy_t *pih, uint8 *txchain,
+				  uint8 *rxchain);
+extern uint8 wlc_phy_stf_chain_active_get(wlc_phy_t *pih);
+extern int8 wlc_phy_stf_ssmode_get(wlc_phy_t *pih, chanspec_t chanspec);
+extern void wlc_phy_ldpc_override_set(wlc_phy_t *ppi, bool val);
+
+extern void wlc_phy_cal_perical(wlc_phy_t *ppi, uint8 reason);
+extern void wlc_phy_noise_sample_request_external(wlc_phy_t *ppi);
+extern void wlc_phy_edcrs_lock(wlc_phy_t *pih, bool lock);
+extern void wlc_phy_cal_papd_recal(wlc_phy_t *ppi);
+
+extern void wlc_phy_ant_rxdiv_set(wlc_phy_t *ppi, uint8 val);
+extern bool wlc_phy_ant_rxdiv_get(wlc_phy_t *ppi, uint8 *pval);
+extern void wlc_phy_clear_tssi(wlc_phy_t *ppi);
+extern void wlc_phy_hold_upd(wlc_phy_t *ppi, mbool id, bool val);
+extern void wlc_phy_mute_upd(wlc_phy_t *ppi, bool val, mbool flags);
 
-extern void wlc_phy_antsel_type_set(wlc_phy_t * ppi, uint8 antsel_type);
+extern void wlc_phy_antsel_type_set(wlc_phy_t *ppi, uint8 antsel_type);
 
-extern void wlc_phy_txpower_get_current(wlc_phy_t * ppi, tx_power_t * power,
+extern void wlc_phy_txpower_get_current(wlc_phy_t *ppi, tx_power_t *power,
 					uint channel);
 
-extern void wlc_phy_initcal_enable(wlc_phy_t * pih, bool initcal);
-extern bool wlc_phy_test_ison(wlc_phy_t * ppi);
-extern void wlc_phy_txpwr_percent_set(wlc_phy_t * ppi, uint8 txpwr_percent);
-extern void wlc_phy_ofdm_rateset_war(wlc_phy_t * pih, bool war);
-extern void wlc_phy_bf_preempt_enable(wlc_phy_t * pih, bool bf_preempt);
-extern void wlc_phy_machwcap_set(wlc_phy_t * ppi, uint32 machwcap);
+extern void wlc_phy_initcal_enable(wlc_phy_t *pih, bool initcal);
+extern bool wlc_phy_test_ison(wlc_phy_t *ppi);
+extern void wlc_phy_txpwr_percent_set(wlc_phy_t *ppi, uint8 txpwr_percent);
+extern void wlc_phy_ofdm_rateset_war(wlc_phy_t *pih, bool war);
+extern void wlc_phy_bf_preempt_enable(wlc_phy_t *pih, bool bf_preempt);
+extern void wlc_phy_machwcap_set(wlc_phy_t *ppi, uint32 machwcap);
 
-extern void wlc_phy_runbist_config(wlc_phy_t * ppi, bool start_end);
+extern void wlc_phy_runbist_config(wlc_phy_t *ppi, bool start_end);
 
-extern void wlc_phy_freqtrack_start(wlc_phy_t * ppi);
-extern void wlc_phy_freqtrack_end(wlc_phy_t * ppi);
+extern void wlc_phy_freqtrack_start(wlc_phy_t *ppi);
+extern void wlc_phy_freqtrack_end(wlc_phy_t *ppi);
 
 extern const uint8 *wlc_phy_get_ofdm_rate_lookup(void);
 
-extern int8 wlc_phy_get_tx_power_offset_by_mcs(wlc_phy_t * ppi,
+extern int8 wlc_phy_get_tx_power_offset_by_mcs(wlc_phy_t *ppi,
 					       uint8 mcs_offset);
-extern int8 wlc_phy_get_tx_power_offset(wlc_phy_t * ppi, uint8 tbl_offset);
+extern int8 wlc_phy_get_tx_power_offset(wlc_phy_t *ppi, uint8 tbl_offset);
 #endif				/* _wlc_phy_h_ */
--- a/drivers/staging/brcm80211/phy/wlc_phy_int.h
+++ b/drivers/staging/brcm80211/phy/wlc_phy_int.h
@@ -984,116 +984,116 @@ extern radio_regs_t regs_SYN_2056_rev8[]
 extern radio_20xx_regs_t regs_2057_rev4[], regs_2057_rev5[], regs_2057_rev5v1[];
 extern radio_20xx_regs_t regs_2057_rev7[], regs_2057_rev8[];
 
-extern char *phy_getvar(phy_info_t * pi, const char *name);
-extern int phy_getintvar(phy_info_t * pi, const char *name);
+extern char *phy_getvar(phy_info_t *pi, const char *name);
+extern int phy_getintvar(phy_info_t *pi, const char *name);
 #define PHY_GETVAR(pi, name)	phy_getvar(pi, name)
 #define PHY_GETINTVAR(pi, name)	phy_getintvar(pi, name)
 
-extern uint16 read_phy_reg(phy_info_t * pi, uint16 addr);
-extern void write_phy_reg(phy_info_t * pi, uint16 addr, uint16 val);
-extern void and_phy_reg(phy_info_t * pi, uint16 addr, uint16 val);
-extern void or_phy_reg(phy_info_t * pi, uint16 addr, uint16 val);
-extern void mod_phy_reg(phy_info_t * pi, uint16 addr, uint16 mask, uint16 val);
-
-extern uint16 read_radio_reg(phy_info_t * pi, uint16 addr);
-extern void or_radio_reg(phy_info_t * pi, uint16 addr, uint16 val);
-extern void and_radio_reg(phy_info_t * pi, uint16 addr, uint16 val);
-extern void mod_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask,
+extern uint16 read_phy_reg(phy_info_t *pi, uint16 addr);
+extern void write_phy_reg(phy_info_t *pi, uint16 addr, uint16 val);
+extern void and_phy_reg(phy_info_t *pi, uint16 addr, uint16 val);
+extern void or_phy_reg(phy_info_t *pi, uint16 addr, uint16 val);
+extern void mod_phy_reg(phy_info_t *pi, uint16 addr, uint16 mask, uint16 val);
+
+extern uint16 read_radio_reg(phy_info_t *pi, uint16 addr);
+extern void or_radio_reg(phy_info_t *pi, uint16 addr, uint16 val);
+extern void and_radio_reg(phy_info_t *pi, uint16 addr, uint16 val);
+extern void mod_radio_reg(phy_info_t *pi, uint16 addr, uint16 mask,
 			  uint16 val);
-extern void xor_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask);
+extern void xor_radio_reg(phy_info_t *pi, uint16 addr, uint16 mask);
 
-extern void write_radio_reg(phy_info_t * pi, uint16 addr, uint16 val);
+extern void write_radio_reg(phy_info_t *pi, uint16 addr, uint16 val);
 
-extern void wlc_phyreg_enter(wlc_phy_t * pih);
-extern void wlc_phyreg_exit(wlc_phy_t * pih);
-extern void wlc_radioreg_enter(wlc_phy_t * pih);
-extern void wlc_radioreg_exit(wlc_phy_t * pih);
+extern void wlc_phyreg_enter(wlc_phy_t *pih);
+extern void wlc_phyreg_exit(wlc_phy_t *pih);
+extern void wlc_radioreg_enter(wlc_phy_t *pih);
+extern void wlc_radioreg_exit(wlc_phy_t *pih);
 
-extern void wlc_phy_read_table(phy_info_t * pi, const phytbl_info_t * ptbl_info,
+extern void wlc_phy_read_table(phy_info_t *pi, const phytbl_info_t *ptbl_info,
 			       uint16 tblAddr, uint16 tblDataHi,
 			       uint16 tblDatalo);
-extern void wlc_phy_write_table(phy_info_t * pi,
-				const phytbl_info_t * ptbl_info, uint16 tblAddr,
+extern void wlc_phy_write_table(phy_info_t *pi,
+				const phytbl_info_t *ptbl_info, uint16 tblAddr,
 				uint16 tblDataHi, uint16 tblDatalo);
-extern void wlc_phy_table_addr(phy_info_t * pi, uint tbl_id, uint tbl_offset,
+extern void wlc_phy_table_addr(phy_info_t *pi, uint tbl_id, uint tbl_offset,
 			       uint16 tblAddr, uint16 tblDataHi,
 			       uint16 tblDataLo);
-extern void wlc_phy_table_data_write(phy_info_t * pi, uint width, uint32 val);
+extern void wlc_phy_table_data_write(phy_info_t *pi, uint width, uint32 val);
 
-extern void write_phy_channel_reg(phy_info_t * pi, uint val);
-extern void wlc_phy_txpower_update_shm(phy_info_t * pi);
+extern void write_phy_channel_reg(phy_info_t *pi, uint val);
+extern void wlc_phy_txpower_update_shm(phy_info_t *pi);
 
-extern void wlc_phy_cordic(fixed theta, cint32 * val);
+extern void wlc_phy_cordic(fixed theta, cint32 *val);
 extern uint8 wlc_phy_nbits(int32 value);
 extern uint32 wlc_phy_sqrt_int(uint32 value);
-extern void wlc_phy_compute_dB(uint32 * cmplx_pwr, int8 * p_dB, uint8 core);
+extern void wlc_phy_compute_dB(uint32 *cmplx_pwr, int8 *p_dB, uint8 core);
 
-extern uint wlc_phy_init_radio_regs_allbands(phy_info_t * pi,
-					     radio_20xx_regs_t * radioregs);
-extern uint wlc_phy_init_radio_regs(phy_info_t * pi, radio_regs_t * radioregs,
+extern uint wlc_phy_init_radio_regs_allbands(phy_info_t *pi,
+					     radio_20xx_regs_t *radioregs);
+extern uint wlc_phy_init_radio_regs(phy_info_t *pi, radio_regs_t *radioregs,
 				    uint16 core_offset);
 
-extern void wlc_phy_txpower_ipa_upd(phy_info_t * pi);
+extern void wlc_phy_txpower_ipa_upd(phy_info_t *pi);
 
-extern void wlc_phy_do_dummy_tx(phy_info_t * pi, bool ofdm, bool pa_on);
-extern void wlc_phy_papd_decode_epsilon(uint32 epsilon, int32 * eps_real,
-					int32 * eps_imag);
+extern void wlc_phy_do_dummy_tx(phy_info_t *pi, bool ofdm, bool pa_on);
+extern void wlc_phy_papd_decode_epsilon(uint32 epsilon, int32 *eps_real,
+					int32 *eps_imag);
 
-extern void wlc_phy_cal_perical_mphase_reset(phy_info_t * pi);
-extern void wlc_phy_cal_perical_mphase_restart(phy_info_t * pi);
+extern void wlc_phy_cal_perical_mphase_reset(phy_info_t *pi);
+extern void wlc_phy_cal_perical_mphase_restart(phy_info_t *pi);
 
-extern bool wlc_phy_attach_nphy(phy_info_t * pi);
-extern bool wlc_phy_attach_lcnphy(phy_info_t * pi);
+extern bool wlc_phy_attach_nphy(phy_info_t *pi);
+extern bool wlc_phy_attach_lcnphy(phy_info_t *pi);
 
-extern void wlc_phy_detach_lcnphy(phy_info_t * pi);
+extern void wlc_phy_detach_lcnphy(phy_info_t *pi);
 
-extern void wlc_phy_init_nphy(phy_info_t * pi);
-extern void wlc_phy_init_lcnphy(phy_info_t * pi);
+extern void wlc_phy_init_nphy(phy_info_t *pi);
+extern void wlc_phy_init_lcnphy(phy_info_t *pi);
 
-extern void wlc_phy_cal_init_nphy(phy_info_t * pi);
-extern void wlc_phy_cal_init_lcnphy(phy_info_t * pi);
+extern void wlc_phy_cal_init_nphy(phy_info_t *pi);
+extern void wlc_phy_cal_init_lcnphy(phy_info_t *pi);
 
-extern void wlc_phy_chanspec_set_nphy(phy_info_t * pi, chanspec_t chanspec);
-extern void wlc_phy_chanspec_set_lcnphy(phy_info_t * pi, chanspec_t chanspec);
-extern void wlc_phy_chanspec_set_fixup_lcnphy(phy_info_t * pi,
+extern void wlc_phy_chanspec_set_nphy(phy_info_t *pi, chanspec_t chanspec);
+extern void wlc_phy_chanspec_set_lcnphy(phy_info_t *pi, chanspec_t chanspec);
+extern void wlc_phy_chanspec_set_fixup_lcnphy(phy_info_t *pi,
 					      chanspec_t chanspec);
 extern int wlc_phy_channel2freq(uint channel);
 extern int wlc_phy_chanspec_freq2bandrange_lpssn(uint);
 extern int wlc_phy_chanspec_bandrange_get(phy_info_t *, chanspec_t);
 
-extern void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t * pi, uint16 mode);
-extern int8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t * pi);
+extern void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t *pi, uint16 mode);
+extern int8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t *pi);
 
-extern void wlc_phy_txpower_recalc_target_nphy(phy_info_t * pi);
-extern void wlc_lcnphy_txpower_recalc_target(phy_info_t * pi);
-extern void wlc_phy_txpower_recalc_target_lcnphy(phy_info_t * pi);
-
-extern void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t * pi, int index);
-extern void wlc_lcnphy_tx_pu(phy_info_t * pi, bool bEnable);
-extern void wlc_lcnphy_stop_tx_tone(phy_info_t * pi);
-extern void wlc_lcnphy_start_tx_tone(phy_info_t * pi, int32 f_kHz,
+extern void wlc_phy_txpower_recalc_target_nphy(phy_info_t *pi);
+extern void wlc_lcnphy_txpower_recalc_target(phy_info_t *pi);
+extern void wlc_phy_txpower_recalc_target_lcnphy(phy_info_t *pi);
+
+extern void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t *pi, int index);
+extern void wlc_lcnphy_tx_pu(phy_info_t *pi, bool bEnable);
+extern void wlc_lcnphy_stop_tx_tone(phy_info_t *pi);
+extern void wlc_lcnphy_start_tx_tone(phy_info_t *pi, int32 f_kHz,
 				     uint16 max_val, bool iqcalmode);
 
-extern void wlc_phy_txpower_sromlimit_get_nphy(phy_info_t * pi, uint chan,
-					       uint8 * max_pwr, uint8 rate_id);
-extern void wlc_phy_ofdm_to_mcs_powers_nphy(uint8 * power, uint8 rate_mcs_start,
+extern void wlc_phy_txpower_sromlimit_get_nphy(phy_info_t *pi, uint chan,
+					       uint8 *max_pwr, uint8 rate_id);
+extern void wlc_phy_ofdm_to_mcs_powers_nphy(uint8 *power, uint8 rate_mcs_start,
 					    uint8 rate_mcs_end,
 					    uint8 rate_ofdm_start);
-extern void wlc_phy_mcs_to_ofdm_powers_nphy(uint8 * power,
+extern void wlc_phy_mcs_to_ofdm_powers_nphy(uint8 *power,
 					    uint8 rate_ofdm_start,
 					    uint8 rate_ofdm_end,
 					    uint8 rate_mcs_start);
 
-extern uint16 wlc_lcnphy_tempsense(phy_info_t * pi, bool mode);
-extern int16 wlc_lcnphy_tempsense_new(phy_info_t * pi, bool mode);
-extern int8 wlc_lcnphy_tempsense_degree(phy_info_t * pi, bool mode);
-extern int8 wlc_lcnphy_vbatsense(phy_info_t * pi, bool mode);
-extern void wlc_phy_carrier_suppress_lcnphy(phy_info_t * pi);
-extern void wlc_lcnphy_crsuprs(phy_info_t * pi, int channel);
-extern void wlc_lcnphy_epa_switch(phy_info_t * pi, bool mode);
-extern void wlc_2064_vco_cal(phy_info_t * pi);
+extern uint16 wlc_lcnphy_tempsense(phy_info_t *pi, bool mode);
+extern int16 wlc_lcnphy_tempsense_new(phy_info_t *pi, bool mode);
+extern int8 wlc_lcnphy_tempsense_degree(phy_info_t *pi, bool mode);
+extern int8 wlc_lcnphy_vbatsense(phy_info_t *pi, bool mode);
+extern void wlc_phy_carrier_suppress_lcnphy(phy_info_t *pi);
+extern void wlc_lcnphy_crsuprs(phy_info_t *pi, int channel);
+extern void wlc_lcnphy_epa_switch(phy_info_t *pi, bool mode);
+extern void wlc_2064_vco_cal(phy_info_t *pi);
 
-extern void wlc_phy_txpower_recalc_target(phy_info_t * pi);
+extern void wlc_phy_txpower_recalc_target(phy_info_t *pi);
 extern uint32 wlc_phy_qdiv_roundup(uint32 dividend, uint32 divisor,
 				   uint8 precision);
 
@@ -1109,24 +1109,24 @@ extern uint32 wlc_phy_qdiv_roundup(uint3
 
 #define LCNPHY_TX_PWR_CTRL_TEMPBASED	0xE001
 
-extern void wlc_lcnphy_write_table(phy_info_t * pi, const phytbl_info_t * pti);
-extern void wlc_lcnphy_read_table(phy_info_t * pi, phytbl_info_t * pti);
-extern void wlc_lcnphy_set_tx_iqcc(phy_info_t * pi, uint16 a, uint16 b);
-extern void wlc_lcnphy_set_tx_locc(phy_info_t * pi, uint16 didq);
-extern void wlc_lcnphy_get_tx_iqcc(phy_info_t * pi, uint16 * a, uint16 * b);
-extern uint16 wlc_lcnphy_get_tx_locc(phy_info_t * pi);
-extern void wlc_lcnphy_get_radio_loft(phy_info_t * pi, uint8 * ei0,
-				      uint8 * eq0, uint8 * fi0, uint8 * fq0);
-extern void wlc_lcnphy_calib_modes(phy_info_t * pi, uint mode);
-extern void wlc_lcnphy_deaf_mode(phy_info_t * pi, bool mode);
-extern bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t * pi);
-extern void wlc_lcnphy_tx_pwr_update_npt(phy_info_t * pi);
+extern void wlc_lcnphy_write_table(phy_info_t *pi, const phytbl_info_t *pti);
+extern void wlc_lcnphy_read_table(phy_info_t *pi, phytbl_info_t *pti);
+extern void wlc_lcnphy_set_tx_iqcc(phy_info_t *pi, uint16 a, uint16 b);
+extern void wlc_lcnphy_set_tx_locc(phy_info_t *pi, uint16 didq);
+extern void wlc_lcnphy_get_tx_iqcc(phy_info_t *pi, uint16 *a, uint16 *b);
+extern uint16 wlc_lcnphy_get_tx_locc(phy_info_t *pi);
+extern void wlc_lcnphy_get_radio_loft(phy_info_t *pi, uint8 *ei0,
+				      uint8 *eq0, uint8 *fi0, uint8 *fq0);
+extern void wlc_lcnphy_calib_modes(phy_info_t *pi, uint mode);
+extern void wlc_lcnphy_deaf_mode(phy_info_t *pi, bool mode);
+extern bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t *pi);
+extern void wlc_lcnphy_tx_pwr_update_npt(phy_info_t *pi);
 extern int32 wlc_lcnphy_tssi2dbm(int32 tssi, int32 a1, int32 b0, int32 b1);
-extern void wlc_lcnphy_get_tssi(phy_info_t * pi, int8 * ofdm_pwr,
-				int8 * cck_pwr);
-extern void wlc_lcnphy_tx_power_adjustment(wlc_phy_t * ppi);
+extern void wlc_lcnphy_get_tssi(phy_info_t *pi, int8 *ofdm_pwr,
+				int8 *cck_pwr);
+extern void wlc_lcnphy_tx_power_adjustment(wlc_phy_t *ppi);
 
-extern int32 wlc_lcnphy_rx_signal_power(phy_info_t * pi, int32 gain_index);
+extern int32 wlc_lcnphy_rx_signal_power(phy_info_t *pi, int32 gain_index);
 
 #define NPHY_MAX_HPVGA1_INDEX		10
 #define NPHY_DEF_HPVGA1_INDEXLIMIT	7
@@ -1137,8 +1137,8 @@ typedef struct _phy_iq_est {
 	uint32 q_pwr;
 } phy_iq_est_t;
 
-extern void wlc_phy_stay_in_carriersearch_nphy(phy_info_t * pi, bool enable);
-extern void wlc_nphy_deaf_mode(phy_info_t * pi, bool mode);
+extern void wlc_phy_stay_in_carriersearch_nphy(phy_info_t *pi, bool enable);
+extern void wlc_nphy_deaf_mode(phy_info_t *pi, bool mode);
 
 #define wlc_phy_write_table_nphy(pi, pti)	wlc_phy_write_table(pi, pti, 0x72, \
 	0x74, 0x73)
@@ -1148,9 +1148,9 @@ extern void wlc_nphy_deaf_mode(phy_info_
 	0x72, 0x74, 0x73)
 #define wlc_nphy_table_data_write(pi, w, v)	wlc_phy_table_data_write((pi), (w), (v))
 
-extern void wlc_phy_table_read_nphy(phy_info_t * pi, uint32, uint32 l, uint32 o,
+extern void wlc_phy_table_read_nphy(phy_info_t *pi, uint32, uint32 l, uint32 o,
 				    uint32 w, void *d);
-extern void wlc_phy_table_write_nphy(phy_info_t * pi, uint32, uint32, uint32,
+extern void wlc_phy_table_write_nphy(phy_info_t *pi, uint32, uint32, uint32,
 				     uint32, const void *);
 
 #define	PHY_IPA(pi) \
@@ -1161,69 +1161,69 @@ extern void wlc_phy_table_write_nphy(phy
 	if ((BUSTYPE((pi)->sh->bustype) == PCI_BUS) && NREV_LT((pi)->pubpi.phy_rev, 3)) \
 		(void)R_REG((pi)->sh->osh, &(pi)->regs->maccontrol)
 
-extern void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype);
-extern void wlc_phy_aci_reset_nphy(phy_info_t * pi);
-extern void wlc_phy_pa_override_nphy(phy_info_t * pi, bool en);
+extern void wlc_phy_cal_perical_nphy_run(phy_info_t *pi, uint8 caltype);
+extern void wlc_phy_aci_reset_nphy(phy_info_t *pi);
+extern void wlc_phy_pa_override_nphy(phy_info_t *pi, bool en);
 
-extern uint8 wlc_phy_get_chan_freq_range_nphy(phy_info_t * pi, uint chan);
-extern void wlc_phy_switch_radio_nphy(phy_info_t * pi, bool on);
+extern uint8 wlc_phy_get_chan_freq_range_nphy(phy_info_t *pi, uint chan);
+extern void wlc_phy_switch_radio_nphy(phy_info_t *pi, bool on);
 
-extern void wlc_phy_stf_chain_upd_nphy(phy_info_t * pi);
+extern void wlc_phy_stf_chain_upd_nphy(phy_info_t *pi);
 
-extern void wlc_phy_force_rfseq_nphy(phy_info_t * pi, uint8 cmd);
-extern int16 wlc_phy_tempsense_nphy(phy_info_t * pi);
+extern void wlc_phy_force_rfseq_nphy(phy_info_t *pi, uint8 cmd);
+extern int16 wlc_phy_tempsense_nphy(phy_info_t *pi);
 
-extern uint16 wlc_phy_classifier_nphy(phy_info_t * pi, uint16 mask, uint16 val);
+extern uint16 wlc_phy_classifier_nphy(phy_info_t *pi, uint16 mask, uint16 val);
 
-extern void wlc_phy_rx_iq_est_nphy(phy_info_t * pi, phy_iq_est_t * est,
+extern void wlc_phy_rx_iq_est_nphy(phy_info_t *pi, phy_iq_est_t *est,
 				   uint16 num_samps, uint8 wait_time,
 				   uint8 wait_for_crs);
 
-extern void wlc_phy_rx_iq_coeffs_nphy(phy_info_t * pi, uint8 write,
-				      nphy_iq_comp_t * comp);
-extern void wlc_phy_aci_and_noise_reduction_nphy(phy_info_t * pi);
-
-extern void wlc_phy_rxcore_setstate_nphy(wlc_phy_t * pih, uint8 rxcore_bitmask);
-extern uint8 wlc_phy_rxcore_getstate_nphy(wlc_phy_t * pih);
-
-extern void wlc_phy_txpwrctrl_enable_nphy(phy_info_t * pi, uint8 ctrl_type);
-extern void wlc_phy_txpwr_fixpower_nphy(phy_info_t * pi);
-extern void wlc_phy_txpwr_apply_nphy(phy_info_t * pi);
-extern void wlc_phy_txpwr_papd_cal_nphy(phy_info_t * pi);
-extern uint16 wlc_phy_txpwr_idx_get_nphy(phy_info_t * pi);
+extern void wlc_phy_rx_iq_coeffs_nphy(phy_info_t *pi, uint8 write,
+				      nphy_iq_comp_t *comp);
+extern void wlc_phy_aci_and_noise_reduction_nphy(phy_info_t *pi);
+
+extern void wlc_phy_rxcore_setstate_nphy(wlc_phy_t *pih, uint8 rxcore_bitmask);
+extern uint8 wlc_phy_rxcore_getstate_nphy(wlc_phy_t *pih);
+
+extern void wlc_phy_txpwrctrl_enable_nphy(phy_info_t *pi, uint8 ctrl_type);
+extern void wlc_phy_txpwr_fixpower_nphy(phy_info_t *pi);
+extern void wlc_phy_txpwr_apply_nphy(phy_info_t *pi);
+extern void wlc_phy_txpwr_papd_cal_nphy(phy_info_t *pi);
+extern uint16 wlc_phy_txpwr_idx_get_nphy(phy_info_t *pi);
 
-extern nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t * pi);
-extern int wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
+extern nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t *pi);
+extern int wlc_phy_cal_txiqlo_nphy(phy_info_t *pi, nphy_txgains_t target_gain,
 				   bool full, bool m);
-extern int wlc_phy_cal_rxiq_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
+extern int wlc_phy_cal_rxiq_nphy(phy_info_t *pi, nphy_txgains_t target_gain,
 				 uint8 type, bool d);
-extern void wlc_phy_txpwr_index_nphy(phy_info_t * pi, uint8 core_mask,
+extern void wlc_phy_txpwr_index_nphy(phy_info_t *pi, uint8 core_mask,
 				     int8 txpwrindex, bool res);
-extern void wlc_phy_rssisel_nphy(phy_info_t * pi, uint8 core, uint8 rssi_type);
-extern int wlc_phy_poll_rssi_nphy(phy_info_t * pi, uint8 rssi_type,
-				  int32 * rssi_buf, uint8 nsamps);
-extern void wlc_phy_rssi_cal_nphy(phy_info_t * pi);
-extern int wlc_phy_aci_scan_nphy(phy_info_t * pi);
-extern void wlc_phy_cal_txgainctrl_nphy(phy_info_t * pi, int32 dBm_targetpower,
+extern void wlc_phy_rssisel_nphy(phy_info_t *pi, uint8 core, uint8 rssi_type);
+extern int wlc_phy_poll_rssi_nphy(phy_info_t *pi, uint8 rssi_type,
+				  int32 *rssi_buf, uint8 nsamps);
+extern void wlc_phy_rssi_cal_nphy(phy_info_t *pi);
+extern int wlc_phy_aci_scan_nphy(phy_info_t *pi);
+extern void wlc_phy_cal_txgainctrl_nphy(phy_info_t *pi, int32 dBm_targetpower,
 					bool debug);
-extern int wlc_phy_tx_tone_nphy(phy_info_t * pi, uint32 f_kHz, uint16 max_val,
+extern int wlc_phy_tx_tone_nphy(phy_info_t *pi, uint32 f_kHz, uint16 max_val,
 				uint8 mode, uint8, bool);
-extern void wlc_phy_stopplayback_nphy(phy_info_t * pi);
-extern void wlc_phy_est_tonepwr_nphy(phy_info_t * pi, int32 * qdBm_pwrbuf,
+extern void wlc_phy_stopplayback_nphy(phy_info_t *pi);
+extern void wlc_phy_est_tonepwr_nphy(phy_info_t *pi, int32 *qdBm_pwrbuf,
 				     uint8 num_samps);
-extern void wlc_phy_radio205x_vcocal_nphy(phy_info_t * pi);
+extern void wlc_phy_radio205x_vcocal_nphy(phy_info_t *pi);
 
-extern int wlc_phy_rssi_compute_nphy(phy_info_t * pi, wlc_d11rxhdr_t * wlc_rxh);
+extern int wlc_phy_rssi_compute_nphy(phy_info_t *pi, wlc_d11rxhdr_t *wlc_rxh);
 
 #define NPHY_TESTPATTERN_BPHY_EVM   0
 #define NPHY_TESTPATTERN_BPHY_RFCS  1
 
-extern void wlc_phy_nphy_tkip_rifs_war(phy_info_t * pi, uint8 rifs);
+extern void wlc_phy_nphy_tkip_rifs_war(phy_info_t *pi, uint8 rifs);
 
-void wlc_phy_get_pwrdet_offsets(phy_info_t * pi, int8 * cckoffset,
-				int8 * ofdmoffset);
-extern int8 wlc_phy_upd_rssi_offset(phy_info_t * pi, int8 rssi,
+void wlc_phy_get_pwrdet_offsets(phy_info_t *pi, int8 *cckoffset,
+				int8 *ofdmoffset);
+extern int8 wlc_phy_upd_rssi_offset(phy_info_t *pi, int8 rssi,
 				    chanspec_t chanspec);
 
-extern bool wlc_phy_n_txpower_ipa_ison(phy_info_t * pih);
+extern bool wlc_phy_n_txpower_ipa_ison(phy_info_t *pih);
 #endif				/* _wlc_phy_int_h_ */
--- a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -975,77 +975,77 @@ uint16
 
 static uint32 wlc_lcnphy_qdiv_roundup(uint32 divident, uint32 divisor,
 				      uint8 precision);
-static void wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t * pi,
+static void wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t *pi,
 						   uint16 ext_lna, uint16 trsw,
 						   uint16 biq2, uint16 biq1,
 						   uint16 tia, uint16 lna2,
 						   uint16 lna1);
-static void wlc_lcnphy_clear_tx_power_offsets(phy_info_t * pi);
-static void wlc_lcnphy_set_pa_gain(phy_info_t * pi, uint16 gain);
-static void wlc_lcnphy_set_trsw_override(phy_info_t * pi, bool tx, bool rx);
-static void wlc_lcnphy_set_bbmult(phy_info_t * pi, uint8 m0);
-static uint8 wlc_lcnphy_get_bbmult(phy_info_t * pi);
-static void wlc_lcnphy_get_tx_gain(phy_info_t * pi, lcnphy_txgains_t * gains);
-static void wlc_lcnphy_set_tx_gain_override(phy_info_t * pi, bool bEnable);
-static void wlc_lcnphy_toggle_afe_pwdn(phy_info_t * pi);
-static void wlc_lcnphy_rx_gain_override_enable(phy_info_t * pi, bool enable);
-static void wlc_lcnphy_set_tx_gain(phy_info_t * pi,
-				   lcnphy_txgains_t * target_gains);
-static bool wlc_lcnphy_rx_iq_est(phy_info_t * pi, uint16 num_samps,
-				 uint8 wait_time, lcnphy_iq_est_t * iq_est);
-static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t * pi, uint16 num_samps);
-static uint16 wlc_lcnphy_get_pa_gain(phy_info_t * pi);
-static void wlc_lcnphy_afe_clk_init(phy_info_t * pi, uint8 mode);
-extern void wlc_lcnphy_tx_pwr_ctrl_init(wlc_phy_t * ppi);
-extern void wlc_lcnphy_pktengtx(wlc_phy_t * ppi, wl_pkteng_t * pkteng,
+static void wlc_lcnphy_clear_tx_power_offsets(phy_info_t *pi);
+static void wlc_lcnphy_set_pa_gain(phy_info_t *pi, uint16 gain);
+static void wlc_lcnphy_set_trsw_override(phy_info_t *pi, bool tx, bool rx);
+static void wlc_lcnphy_set_bbmult(phy_info_t *pi, uint8 m0);
+static uint8 wlc_lcnphy_get_bbmult(phy_info_t *pi);
+static void wlc_lcnphy_get_tx_gain(phy_info_t *pi, lcnphy_txgains_t *gains);
+static void wlc_lcnphy_set_tx_gain_override(phy_info_t *pi, bool bEnable);
+static void wlc_lcnphy_toggle_afe_pwdn(phy_info_t *pi);
+static void wlc_lcnphy_rx_gain_override_enable(phy_info_t *pi, bool enable);
+static void wlc_lcnphy_set_tx_gain(phy_info_t *pi,
+				   lcnphy_txgains_t *target_gains);
+static bool wlc_lcnphy_rx_iq_est(phy_info_t *pi, uint16 num_samps,
+				 uint8 wait_time, lcnphy_iq_est_t *iq_est);
+static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t *pi, uint16 num_samps);
+static uint16 wlc_lcnphy_get_pa_gain(phy_info_t *pi);
+static void wlc_lcnphy_afe_clk_init(phy_info_t *pi, uint8 mode);
+extern void wlc_lcnphy_tx_pwr_ctrl_init(wlc_phy_t *ppi);
+extern void wlc_lcnphy_pktengtx(wlc_phy_t *ppi, wl_pkteng_t *pkteng,
 				uint8 rate, struct ether_addr *sa,
 				uint32 wait_delay);
-static void wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi,
+static void wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t *pi,
 						    uint8 channel);
 
-static void wlc_lcnphy_load_tx_gain_table(phy_info_t * pi,
-					  const lcnphy_tx_gain_tbl_entry * g);
+static void wlc_lcnphy_load_tx_gain_table(phy_info_t *pi,
+					  const lcnphy_tx_gain_tbl_entry *g);
 
-static void wlc_lcnphy_samp_cap(phy_info_t * pi, int clip_detect_algo,
-				uint16 thresh, int16 * ptr, int mode);
+static void wlc_lcnphy_samp_cap(phy_info_t *pi, int clip_detect_algo,
+				uint16 thresh, int16 *ptr, int mode);
 static int wlc_lcnphy_calc_floor(int16 coeff, int type);
-static void wlc_lcnphy_tx_iqlo_loopback(phy_info_t * pi,
-					uint16 * values_to_save);
-static void wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t * pi,
-						uint16 * values_to_save);
-static void wlc_lcnphy_set_cc(phy_info_t * pi, int cal_type, int16 coeff_x,
+static void wlc_lcnphy_tx_iqlo_loopback(phy_info_t *pi,
+					uint16 *values_to_save);
+static void wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t *pi,
+						uint16 *values_to_save);
+static void wlc_lcnphy_set_cc(phy_info_t *pi, int cal_type, int16 coeff_x,
 			      int16 coeff_y);
-static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t * pi, int cal_type);
-static void wlc_lcnphy_a1(phy_info_t * pi, int cal_type,
+static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t *pi, int cal_type);
+static void wlc_lcnphy_a1(phy_info_t *pi, int cal_type,
 			  int num_levels, int step_size_lg2);
-static void wlc_lcnphy_tx_iqlo_soft_cal_full(phy_info_t * pi);
+static void wlc_lcnphy_tx_iqlo_soft_cal_full(phy_info_t *pi);
 
-static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t * pi,
+static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t *pi,
 					   chanspec_t chanspec);
-static void wlc_lcnphy_agc_temp_init(phy_info_t * pi);
-static void wlc_lcnphy_temp_adj(phy_info_t * pi);
-static void wlc_lcnphy_clear_papd_comptable(phy_info_t * pi);
-static void wlc_lcnphy_baseband_init(phy_info_t * pi);
-static void wlc_lcnphy_radio_init(phy_info_t * pi);
-static void wlc_lcnphy_rc_cal(phy_info_t * pi);
-static void wlc_lcnphy_rcal(phy_info_t * pi);
-static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t * pi, bool enable);
-static int wlc_lcnphy_load_tx_iir_filter(phy_info_t * pi, bool is_ofdm,
+static void wlc_lcnphy_agc_temp_init(phy_info_t *pi);
+static void wlc_lcnphy_temp_adj(phy_info_t *pi);
+static void wlc_lcnphy_clear_papd_comptable(phy_info_t *pi);
+static void wlc_lcnphy_baseband_init(phy_info_t *pi);
+static void wlc_lcnphy_radio_init(phy_info_t *pi);
+static void wlc_lcnphy_rc_cal(phy_info_t *pi);
+static void wlc_lcnphy_rcal(phy_info_t *pi);
+static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t *pi, bool enable);
+static int wlc_lcnphy_load_tx_iir_filter(phy_info_t *pi, bool is_ofdm,
 					 int16 filt_type);
-static void wlc_lcnphy_set_rx_iq_comp(phy_info_t * pi, uint16 a, uint16 b);
+static void wlc_lcnphy_set_rx_iq_comp(phy_info_t *pi, uint16 a, uint16 b);
 
-void wlc_lcnphy_write_table(phy_info_t * pi, const phytbl_info_t * pti)
+void wlc_lcnphy_write_table(phy_info_t *pi, const phytbl_info_t *pti)
 {
 	wlc_phy_write_table(pi, pti, 0x455, 0x457, 0x456);
 }
 
-void wlc_lcnphy_read_table(phy_info_t * pi, phytbl_info_t * pti)
+void wlc_lcnphy_read_table(phy_info_t *pi, phytbl_info_t *pti)
 {
 	wlc_phy_read_table(pi, pti, 0x455, 0x457, 0x456);
 }
 
 static void
-wlc_lcnphy_common_read_table(phy_info_t * pi, uint32 tbl_id,
+wlc_lcnphy_common_read_table(phy_info_t *pi, uint32 tbl_id,
 			     CONST void *tbl_ptr, uint32 tbl_len,
 			     uint32 tbl_width, uint32 tbl_offset)
 {
@@ -1059,7 +1059,7 @@ wlc_lcnphy_common_read_table(phy_info_t
 }
 
 static void
-wlc_lcnphy_common_write_table(phy_info_t * pi, uint32 tbl_id,
+wlc_lcnphy_common_write_table(phy_info_t *pi, uint32 tbl_id,
 			      CONST void *tbl_ptr, uint32 tbl_len,
 			      uint32 tbl_width, uint32 tbl_offset)
 {
@@ -1121,7 +1121,7 @@ static int wlc_lcnphy_calc_floor(int16 c
 	return k;
 }
 
-int8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t * pi)
+int8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t *pi)
 {
 	int8 index;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -1137,7 +1137,7 @@ int8 wlc_lcnphy_get_current_tx_pwr_idx(p
 	return index;
 }
 
-static uint32 wlc_lcnphy_measure_digital_power(phy_info_t * pi, uint16 nsamples)
+static uint32 wlc_lcnphy_measure_digital_power(phy_info_t *pi, uint16 nsamples)
 {
 	lcnphy_iq_est_t iq_est = { 0, 0, 0 };
 
@@ -1146,7 +1146,7 @@ static uint32 wlc_lcnphy_measure_digital
 	return (iq_est.i_pwr + iq_est.q_pwr) / nsamples;
 }
 
-void wlc_lcnphy_crsuprs(phy_info_t * pi, int channel)
+void wlc_lcnphy_crsuprs(phy_info_t *pi, int channel)
 {
 	uint16 afectrlovr, afectrlovrval;
 	afectrlovr = read_phy_reg(pi, 0x43b);
@@ -1177,7 +1177,7 @@ void wlc_lcnphy_crsuprs(phy_info_t * pi,
 	}
 }
 
-static void wlc_lcnphy_toggle_afe_pwdn(phy_info_t * pi)
+static void wlc_lcnphy_toggle_afe_pwdn(phy_info_t *pi)
 {
 	uint16 save_AfeCtrlOvrVal, save_AfeCtrlOvr;
 
@@ -1194,7 +1194,7 @@ static void wlc_lcnphy_toggle_afe_pwdn(p
 	write_phy_reg(pi, 0x43b, save_AfeCtrlOvr);
 }
 
-static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t * pi, bool enable)
+static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t *pi, bool enable)
 {
 	if (enable) {
 		write_phy_reg(pi, 0x942, 0x7);
@@ -1213,7 +1213,7 @@ static void wlc_lcnphy_txrx_spur_avoidan
 	wlapi_switch_macfreq(pi->sh->physhim, enable);
 }
 
-void wlc_phy_chanspec_set_lcnphy(phy_info_t * pi, chanspec_t chanspec)
+void wlc_phy_chanspec_set_lcnphy(phy_info_t *pi, chanspec_t chanspec)
 {
 	uint8 channel = CHSPEC_CHANNEL(chanspec);
 
@@ -1250,7 +1250,7 @@ void wlc_phy_chanspec_set_lcnphy(phy_inf
 
 }
 
-static void wlc_lcnphy_set_dac_gain(phy_info_t * pi, uint16 dac_gain)
+static void wlc_lcnphy_set_dac_gain(phy_info_t *pi, uint16 dac_gain)
 {
 	uint16 dac_ctrl;
 
@@ -1261,7 +1261,7 @@ static void wlc_lcnphy_set_dac_gain(phy_
 
 }
 
-static void wlc_lcnphy_set_tx_gain_override(phy_info_t * pi, bool bEnable)
+static void wlc_lcnphy_set_tx_gain_override(phy_info_t *pi, bool bEnable)
 {
 	uint16 bit = bEnable ? 1 : 0;
 
@@ -1272,7 +1272,7 @@ static void wlc_lcnphy_set_tx_gain_overr
 	mod_phy_reg(pi, 0x43b, (0x1 << 6), bit << 6);
 }
 
-static uint16 wlc_lcnphy_get_pa_gain(phy_info_t * pi)
+static uint16 wlc_lcnphy_get_pa_gain(phy_info_t *pi)
 {
 	uint16 pa_gain;
 
@@ -1284,7 +1284,7 @@ static uint16 wlc_lcnphy_get_pa_gain(phy
 }
 
 static void
-wlc_lcnphy_set_tx_gain(phy_info_t * pi, lcnphy_txgains_t * target_gains)
+wlc_lcnphy_set_tx_gain(phy_info_t *pi, lcnphy_txgains_t *target_gains)
 {
 	uint16 pa_gain = wlc_lcnphy_get_pa_gain(pi);
 
@@ -1309,7 +1309,7 @@ wlc_lcnphy_set_tx_gain(phy_info_t * pi,
 	wlc_lcnphy_enable_tx_gain_override(pi);
 }
 
-static void wlc_lcnphy_set_bbmult(phy_info_t * pi, uint8 m0)
+static void wlc_lcnphy_set_bbmult(phy_info_t *pi, uint8 m0)
 {
 	uint16 m0m1 = (uint16) m0 << 8;
 	phytbl_info_t tab;
@@ -1322,7 +1322,7 @@ static void wlc_lcnphy_set_bbmult(phy_in
 	wlc_lcnphy_write_table(pi, &tab);
 }
 
-static void wlc_lcnphy_clear_tx_power_offsets(phy_info_t * pi)
+static void wlc_lcnphy_clear_tx_power_offsets(phy_info_t *pi)
 {
 	uint32 data_buf[64];
 	phytbl_info_t tab;
@@ -1351,7 +1351,7 @@ typedef enum {
 	LCNPHY_TSSI_EXT
 } lcnphy_tssi_mode_t;
 
-static void wlc_lcnphy_set_tssi_mux(phy_info_t * pi, lcnphy_tssi_mode_t pos)
+static void wlc_lcnphy_set_tssi_mux(phy_info_t *pi, lcnphy_tssi_mode_t pos)
 {
 	mod_phy_reg(pi, 0x4d7, (0x1 << 0), (0x1) << 0);
 
@@ -1390,7 +1390,7 @@ static void wlc_lcnphy_set_tssi_mux(phy_
 	}
 }
 
-static uint16 wlc_lcnphy_rfseq_tbl_adc_pwrup(phy_info_t * pi)
+static uint16 wlc_lcnphy_rfseq_tbl_adc_pwrup(phy_info_t *pi)
 {
 	uint16 N1, N2, N3, N4, N5, N6, N;
 	N1 = ((read_phy_reg(pi, 0x4a5) & (0xff << 0))
@@ -1411,7 +1411,7 @@ static uint16 wlc_lcnphy_rfseq_tbl_adc_p
 	return N;
 }
 
-static void wlc_lcnphy_pwrctrl_rssiparams(phy_info_t * pi)
+static void wlc_lcnphy_pwrctrl_rssiparams(phy_info_t *pi)
 {
 	uint16 auxpga_vmid, auxpga_vmid_temp, auxpga_gain_temp;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -1455,7 +1455,7 @@ static void wlc_lcnphy_pwrctrl_rssiparam
 	mod_radio_reg(pi, RADIO_2064_REG082, (1 << 5), (1 << 5));
 }
 
-static void wlc_lcnphy_tssi_setup(phy_info_t * pi)
+static void wlc_lcnphy_tssi_setup(phy_info_t *pi)
 {
 	phytbl_info_t tab;
 	uint32 rfseq, ind;
@@ -1569,7 +1569,7 @@ static void wlc_lcnphy_tssi_setup(phy_in
 	wlc_lcnphy_pwrctrl_rssiparams(pi);
 }
 
-void wlc_lcnphy_tx_pwr_update_npt(phy_info_t * pi)
+void wlc_lcnphy_tx_pwr_update_npt(phy_info_t *pi)
 {
 	uint16 tx_cnt, tx_total, npt;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -1599,7 +1599,7 @@ int32 wlc_lcnphy_tssi2dbm(int32 tssi, in
 	return p;
 }
 
-static void wlc_lcnphy_txpower_reset_npt(phy_info_t * pi)
+static void wlc_lcnphy_txpower_reset_npt(phy_info_t *pi)
 {
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi))
@@ -1609,7 +1609,7 @@ static void wlc_lcnphy_txpower_reset_npt
 	pi_lcn->lcnphy_tssi_npt = LCNPHY_TX_PWR_CTRL_START_NPT;
 }
 
-void wlc_lcnphy_txpower_recalc_target(phy_info_t * pi)
+void wlc_lcnphy_txpower_recalc_target(phy_info_t *pi)
 {
 	phytbl_info_t tab;
 	uint32 rate_table[WLC_NUM_RATES_CCK + WLC_NUM_RATES_OFDM +
@@ -1640,7 +1640,7 @@ void wlc_lcnphy_txpower_recalc_target(ph
 	}
 }
 
-static void wlc_lcnphy_set_tx_pwr_soft_ctrl(phy_info_t * pi, int8 index)
+static void wlc_lcnphy_set_tx_pwr_soft_ctrl(phy_info_t *pi, int8 index)
 {
 	uint32 cck_offset[4] = { 22, 22, 22, 22 };
 	uint32 ofdm_offset, reg_offset_cck;
@@ -1693,7 +1693,7 @@ static void wlc_lcnphy_set_tx_pwr_soft_c
 
 }
 
-static int8 wlc_lcnphy_tempcompensated_txpwrctrl(phy_info_t * pi)
+static int8 wlc_lcnphy_tempcompensated_txpwrctrl(phy_info_t *pi)
 {
 	int8 index, delta_brd, delta_temp, new_index, tempcorrx;
 	int16 manp, meas_temp, temp_diff;
@@ -1758,7 +1758,7 @@ static int8 wlc_lcnphy_tempcompensated_t
 	return new_index;
 }
 
-static uint16 wlc_lcnphy_set_tx_pwr_ctrl_mode(phy_info_t * pi, uint16 mode)
+static uint16 wlc_lcnphy_set_tx_pwr_ctrl_mode(phy_info_t *pi, uint16 mode)
 {
 
 	uint16 current_mode = mode;
@@ -1771,7 +1771,7 @@ static uint16 wlc_lcnphy_set_tx_pwr_ctrl
 	return current_mode;
 }
 
-void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t * pi, uint16 mode)
+void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t *pi, uint16 mode)
 {
 	uint16 old_mode = wlc_lcnphy_get_tx_pwr_ctrl(pi);
 	int8 index;
@@ -1827,7 +1827,7 @@ void wlc_lcnphy_set_tx_pwr_ctrl(phy_info
 	}
 }
 
-static bool wlc_lcnphy_iqcal_wait(phy_info_t * pi)
+static bool wlc_lcnphy_iqcal_wait(phy_info_t *pi)
 {
 	uint delay_count = 0;
 
@@ -1843,8 +1843,8 @@ static bool wlc_lcnphy_iqcal_wait(phy_in
 }
 
 static void
-wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
-		       lcnphy_txgains_t * target_gains,
+wlc_lcnphy_tx_iqlo_cal(phy_info_t *pi,
+		       lcnphy_txgains_t *target_gains,
 		       lcnphy_cal_mode_t cal_mode, bool keep_tone)
 {
 
@@ -2078,7 +2078,7 @@ wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
 
 }
 
-static void wlc_lcnphy_idle_tssi_est(wlc_phy_t * ppi)
+static void wlc_lcnphy_idle_tssi_est(wlc_phy_t *ppi)
 {
 	bool suspend, tx_gain_override_old;
 	lcnphy_txgains_t old_gains;
@@ -2144,7 +2144,7 @@ static void wlc_lcnphy_idle_tssi_est(wlc
 		wlapi_enable_mac(pi->sh->physhim);
 }
 
-static void wlc_lcnphy_vbat_temp_sense_setup(phy_info_t * pi, uint8 mode)
+static void wlc_lcnphy_vbat_temp_sense_setup(phy_info_t *pi, uint8 mode)
 {
 	bool suspend;
 	uint16 save_txpwrCtrlEn;
@@ -2286,7 +2286,7 @@ static void wlc_lcnphy_vbat_temp_sense_s
 	OSL_DELAY(999);
 }
 
-void WLBANDINITFN(wlc_lcnphy_tx_pwr_ctrl_init) (wlc_phy_t * ppi) {
+void WLBANDINITFN(wlc_lcnphy_tx_pwr_ctrl_init) (wlc_phy_t *ppi) {
 	lcnphy_txgains_t tx_gains;
 	uint8 bbmult;
 	phytbl_info_t tab;
@@ -2363,7 +2363,7 @@ void WLBANDINITFN(wlc_lcnphy_tx_pwr_ctrl
 		wlapi_enable_mac(pi->sh->physhim);
 }
 
-static uint8 wlc_lcnphy_get_bbmult(phy_info_t * pi)
+static uint8 wlc_lcnphy_get_bbmult(phy_info_t *pi)
 {
 	uint16 m0m1;
 	phytbl_info_t tab;
@@ -2378,7 +2378,7 @@ static uint8 wlc_lcnphy_get_bbmult(phy_i
 	return (uint8) ((m0m1 & 0xff00) >> 8);
 }
 
-static void wlc_lcnphy_set_pa_gain(phy_info_t * pi, uint16 gain)
+static void wlc_lcnphy_set_pa_gain(phy_info_t *pi, uint16 gain)
 {
 	mod_phy_reg(pi, 0x4fb,
 		    LCNPHY_txgainctrlovrval1_pagain_ovr_val1_MASK,
@@ -2389,8 +2389,8 @@ static void wlc_lcnphy_set_pa_gain(phy_i
 }
 
 void
-wlc_lcnphy_get_radio_loft(phy_info_t * pi,
-			  uint8 * ei0, uint8 * eq0, uint8 * fi0, uint8 * fq0)
+wlc_lcnphy_get_radio_loft(phy_info_t *pi,
+			  uint8 *ei0, uint8 *eq0, uint8 *fi0, uint8 *fq0)
 {
 	*ei0 = LCNPHY_IQLOCC_READ(read_radio_reg(pi, RADIO_2064_REG089));
 	*eq0 = LCNPHY_IQLOCC_READ(read_radio_reg(pi, RADIO_2064_REG08A));
@@ -2398,7 +2398,7 @@ wlc_lcnphy_get_radio_loft(phy_info_t * p
 	*fq0 = LCNPHY_IQLOCC_READ(read_radio_reg(pi, RADIO_2064_REG08C));
 }
 
-static void wlc_lcnphy_get_tx_gain(phy_info_t * pi, lcnphy_txgains_t * gains)
+static void wlc_lcnphy_get_tx_gain(phy_info_t *pi, lcnphy_txgains_t *gains)
 {
 	uint16 dac_gain;
 
@@ -2417,7 +2417,7 @@ static void wlc_lcnphy_get_tx_gain(phy_i
 	}
 }
 
-void wlc_lcnphy_set_tx_iqcc(phy_info_t * pi, uint16 a, uint16 b)
+void wlc_lcnphy_set_tx_iqcc(phy_info_t *pi, uint16 a, uint16 b)
 {
 	phytbl_info_t tab;
 	uint16 iqcc[2];
@@ -2433,7 +2433,7 @@ void wlc_lcnphy_set_tx_iqcc(phy_info_t *
 	wlc_lcnphy_write_table(pi, &tab);
 }
 
-void wlc_lcnphy_set_tx_locc(phy_info_t * pi, uint16 didq)
+void wlc_lcnphy_set_tx_locc(phy_info_t *pi, uint16 didq)
 {
 	phytbl_info_t tab;
 
@@ -2445,7 +2445,7 @@ void wlc_lcnphy_set_tx_locc(phy_info_t *
 	wlc_lcnphy_write_table(pi, &tab);
 }
 
-void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t * pi, int index)
+void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t *pi, int index)
 {
 	phytbl_info_t tab;
 	uint16 a, b;
@@ -2506,7 +2506,7 @@ void wlc_lcnphy_set_tx_pwr_by_index(phy_
 	}
 }
 
-static void wlc_lcnphy_set_trsw_override(phy_info_t * pi, bool tx, bool rx)
+static void wlc_lcnphy_set_trsw_override(phy_info_t *pi, bool tx, bool rx)
 {
 
 	mod_phy_reg(pi, 0x44d,
@@ -2516,7 +2516,7 @@ static void wlc_lcnphy_set_trsw_override
 	or_phy_reg(pi, 0x44c, (0x1 << 1) | (0x1 << 0));
 }
 
-static void wlc_lcnphy_clear_papd_comptable(phy_info_t * pi)
+static void wlc_lcnphy_clear_papd_comptable(phy_info_t *pi)
 {
 	uint32 j;
 	phytbl_info_t tab;
@@ -2536,7 +2536,7 @@ static void wlc_lcnphy_clear_papd_compta
 }
 
 static void
-wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t * pi,
+wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t *pi,
 				       uint16 trsw,
 				       uint16 ext_lna,
 				       uint16 biq2,
@@ -2570,7 +2570,7 @@ wlc_lcnphy_set_rx_gain_by_distribution(p
 
 }
 
-static void wlc_lcnphy_rx_gain_override_enable(phy_info_t * pi, bool enable)
+static void wlc_lcnphy_rx_gain_override_enable(phy_info_t *pi, bool enable)
 {
 	uint16 ebit = enable ? 1 : 0;
 
@@ -2595,7 +2595,7 @@ static void wlc_lcnphy_rx_gain_override_
 	}
 }
 
-void wlc_lcnphy_tx_pu(phy_info_t * pi, bool bEnable)
+void wlc_lcnphy_tx_pu(phy_info_t *pi, bool bEnable)
 {
 	if (!bEnable) {
 
@@ -2673,7 +2673,7 @@ void wlc_lcnphy_tx_pu(phy_info_t * pi, b
 }
 
 static void
-wlc_lcnphy_run_samples(phy_info_t * pi,
+wlc_lcnphy_run_samples(phy_info_t *pi,
 		       uint16 num_samps,
 		       uint16 num_loops, uint16 wait, bool iqcalmode)
 {
@@ -2699,7 +2699,7 @@ wlc_lcnphy_run_samples(phy_info_t * pi,
 	or_radio_reg(pi, RADIO_2064_REG112, 0x6);
 }
 
-void wlc_lcnphy_deaf_mode(phy_info_t * pi, bool mode)
+void wlc_lcnphy_deaf_mode(phy_info_t *pi, bool mode)
 {
 
 	uint8 phybw40;
@@ -2724,7 +2724,7 @@ void wlc_lcnphy_deaf_mode(phy_info_t * p
 }
 
 void
-wlc_lcnphy_start_tx_tone(phy_info_t * pi, int32 f_kHz, uint16 max_val,
+wlc_lcnphy_start_tx_tone(phy_info_t *pi, int32 f_kHz, uint16 max_val,
 			 bool iqcalmode)
 {
 	uint8 phy_bw;
@@ -2788,7 +2788,7 @@ wlc_lcnphy_start_tx_tone(phy_info_t * pi
 	wlc_lcnphy_run_samples(pi, num_samps, 0xffff, 0, iqcalmode);
 }
 
-void wlc_lcnphy_stop_tx_tone(phy_info_t * pi)
+void wlc_lcnphy_stop_tx_tone(phy_info_t *pi)
 {
 	int16 playback_status;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -2819,13 +2819,13 @@ void wlc_lcnphy_stop_tx_tone(phy_info_t
 	wlc_lcnphy_deaf_mode(pi, FALSE);
 }
 
-static void wlc_lcnphy_clear_trsw_override(phy_info_t * pi)
+static void wlc_lcnphy_clear_trsw_override(phy_info_t *pi)
 {
 
 	and_phy_reg(pi, 0x44c, (uint16) ~ ((0x1 << 1) | (0x1 << 0)));
 }
 
-void wlc_lcnphy_get_tx_iqcc(phy_info_t * pi, uint16 * a, uint16 * b)
+void wlc_lcnphy_get_tx_iqcc(phy_info_t *pi, uint16 *a, uint16 *b)
 {
 	uint16 iqcc[2];
 	phytbl_info_t tab;
@@ -2841,7 +2841,7 @@ void wlc_lcnphy_get_tx_iqcc(phy_info_t *
 	*b = iqcc[1];
 }
 
-uint16 wlc_lcnphy_get_tx_locc(phy_info_t * pi)
+uint16 wlc_lcnphy_get_tx_locc(phy_info_t *pi)
 {
 	phytbl_info_t tab;
 	uint16 didq;
@@ -2856,7 +2856,7 @@ uint16 wlc_lcnphy_get_tx_locc(phy_info_t
 	return didq;
 }
 
-static void wlc_lcnphy_txpwrtbl_iqlo_cal(phy_info_t * pi)
+static void wlc_lcnphy_txpwrtbl_iqlo_cal(phy_info_t *pi)
 {
 
 	lcnphy_txgains_t target_gains, old_gains;
@@ -2970,7 +2970,7 @@ static void wlc_lcnphy_txpwrtbl_iqlo_cal
 		wlc_lcnphy_set_tx_pwr_by_index(pi, SAVE_txpwrindex);
 }
 
-int16 wlc_lcnphy_tempsense_new(phy_info_t * pi, bool mode)
+int16 wlc_lcnphy_tempsense_new(phy_info_t *pi, bool mode)
 {
 	uint16 tempsenseval1, tempsenseval2;
 	int16 avg = 0;
@@ -3015,7 +3015,7 @@ int16 wlc_lcnphy_tempsense_new(phy_info_
 	return avg;
 }
 
-uint16 wlc_lcnphy_tempsense(phy_info_t * pi, bool mode)
+uint16 wlc_lcnphy_tempsense(phy_info_t *pi, bool mode)
 {
 	uint16 tempsenseval1, tempsenseval2;
 	int32 avg = 0;
@@ -3076,7 +3076,7 @@ uint16 wlc_lcnphy_tempsense(phy_info_t *
 	return (uint16) avg;
 }
 
-int8 wlc_lcnphy_tempsense_degree(phy_info_t * pi, bool mode)
+int8 wlc_lcnphy_tempsense_degree(phy_info_t *pi, bool mode)
 {
 	int32 degree = wlc_lcnphy_tempsense_new(pi, mode);
 	degree =
@@ -3085,7 +3085,7 @@ int8 wlc_lcnphy_tempsense_degree(phy_inf
 	return (int8) degree;
 }
 
-int8 wlc_lcnphy_vbatsense(phy_info_t * pi, bool mode)
+int8 wlc_lcnphy_vbatsense(phy_info_t *pi, bool mode)
 {
 	uint16 vbatsenseval;
 	int32 avg = 0;
@@ -3121,7 +3121,7 @@ int8 wlc_lcnphy_vbatsense(phy_info_t * p
 	return (int8) avg;
 }
 
-static void wlc_lcnphy_afe_clk_init(phy_info_t * pi, uint8 mode)
+static void wlc_lcnphy_afe_clk_init(phy_info_t *pi, uint8 mode)
 {
 	uint8 phybw40;
 	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
@@ -3136,9 +3136,9 @@ static void wlc_lcnphy_afe_clk_init(phy_
 }
 
 static bool
-wlc_lcnphy_rx_iq_est(phy_info_t * pi,
+wlc_lcnphy_rx_iq_est(phy_info_t *pi,
 		     uint16 num_samps,
-		     uint8 wait_time, lcnphy_iq_est_t * iq_est)
+		     uint8 wait_time, lcnphy_iq_est_t *iq_est)
 {
 	int wait_count = 0;
 	bool result = TRUE;
@@ -3182,7 +3182,7 @@ wlc_lcnphy_rx_iq_est(phy_info_t * pi,
 	return result;
 }
 
-static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t * pi, uint16 num_samps)
+static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t *pi, uint16 num_samps)
 {
 #define LCNPHY_MIN_RXIQ_PWR 2
 	bool result;
@@ -3267,7 +3267,7 @@ static bool wlc_lcnphy_calc_rx_iq_comp(p
 }
 
 static bool
-wlc_lcnphy_rx_iq_cal(phy_info_t * pi, const lcnphy_rx_iqcomp_t * iqcomp,
+wlc_lcnphy_rx_iq_cal(phy_info_t *pi, const lcnphy_rx_iqcomp_t *iqcomp,
 		     int iqcomp_sz, bool tx_switch, bool rx_switch, int module,
 		     int tx_gain_idx)
 {
@@ -3437,13 +3437,13 @@ wlc_lcnphy_rx_iq_cal(phy_info_t * pi, co
 	return result;
 }
 
-static void wlc_lcnphy_temp_adj(phy_info_t * pi)
+static void wlc_lcnphy_temp_adj(phy_info_t *pi)
 {
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 }
 
-static void wlc_lcnphy_glacial_timer_based_cal(phy_info_t * pi)
+static void wlc_lcnphy_glacial_timer_based_cal(phy_info_t *pi)
 {
 	bool suspend;
 	int8 index;
@@ -3468,7 +3468,7 @@ static void wlc_lcnphy_glacial_timer_bas
 
 }
 
-static void wlc_lcnphy_periodic_cal(phy_info_t * pi)
+static void wlc_lcnphy_periodic_cal(phy_info_t *pi)
 {
 	bool suspend, full_cal;
 	const lcnphy_rx_iqcomp_t *rx_iqcomp;
@@ -3540,7 +3540,7 @@ static void wlc_lcnphy_periodic_cal(phy_
 		wlapi_enable_mac(pi->sh->physhim);
 }
 
-void wlc_lcnphy_calib_modes(phy_info_t * pi, uint mode)
+void wlc_lcnphy_calib_modes(phy_info_t *pi, uint mode)
 {
 	uint16 temp_new;
 	int temp1, temp2, temp_diff;
@@ -3582,7 +3582,7 @@ void wlc_lcnphy_calib_modes(phy_info_t *
 	}
 }
 
-void wlc_lcnphy_get_tssi(phy_info_t * pi, int8 * ofdm_pwr, int8 * cck_pwr)
+void wlc_lcnphy_get_tssi(phy_info_t *pi, int8 *ofdm_pwr, int8 *cck_pwr)
 {
 	int8 cck_offset;
 	uint16 status;
@@ -3603,12 +3603,12 @@ void wlc_lcnphy_get_tssi(phy_info_t * pi
 	}
 }
 
-void WLBANDINITFN(wlc_phy_cal_init_lcnphy) (phy_info_t * pi) {
+void WLBANDINITFN(wlc_phy_cal_init_lcnphy) (phy_info_t *pi) {
 	return;
 
 }
 
-static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t * pi, chanspec_t chanspec)
+static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t *pi, chanspec_t chanspec)
 {
 	uint8 channel = CHSPEC_CHANNEL(chanspec);
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -3661,12 +3661,12 @@ static void wlc_lcnphy_set_chanspec_twea
 }
 
 void
-wlc_lcnphy_pktengtx(wlc_phy_t * ppi, wl_pkteng_t * pkteng, uint8 rate,
+wlc_lcnphy_pktengtx(wlc_phy_t *ppi, wl_pkteng_t *pkteng, uint8 rate,
 		    struct ether_addr *sa, uint32 wait_delay)
 {
 }
 
-void wlc_lcnphy_tx_power_adjustment(wlc_phy_t * ppi)
+void wlc_lcnphy_tx_power_adjustment(wlc_phy_t *ppi)
 {
 	int8 index;
 	uint16 index2;
@@ -3683,7 +3683,7 @@ void wlc_lcnphy_tx_power_adjustment(wlc_
 	}
 }
 
-static void wlc_lcnphy_set_rx_iq_comp(phy_info_t * pi, uint16 a, uint16 b)
+static void wlc_lcnphy_set_rx_iq_comp(phy_info_t *pi, uint16 a, uint16 b)
 {
 	mod_phy_reg(pi, 0x645, (0x3ff << 0), (a) << 0);
 
@@ -3699,7 +3699,7 @@ static void wlc_lcnphy_set_rx_iq_comp(ph
 
 }
 
-void WLBANDINITFN(wlc_phy_init_lcnphy) (phy_info_t * pi) {
+void WLBANDINITFN(wlc_phy_init_lcnphy) (phy_info_t *pi) {
 	uint8 phybw40;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
@@ -3748,7 +3748,7 @@ void WLBANDINITFN(wlc_phy_init_lcnphy) (
 }
 
 static void
-wlc_lcnphy_tx_iqlo_loopback(phy_info_t * pi, uint16 * values_to_save)
+wlc_lcnphy_tx_iqlo_loopback(phy_info_t *pi, uint16 *values_to_save)
 {
 	uint16 vmid;
 	int i;
@@ -3841,8 +3841,8 @@ wlc_lcnphy_tx_iqlo_loopback(phy_info_t *
 }
 
 static void
-wlc_lcnphy_samp_cap(phy_info_t * pi, int clip_detect_algo, uint16 thresh,
-		    int16 * ptr, int mode)
+wlc_lcnphy_samp_cap(phy_info_t *pi, int clip_detect_algo, uint16 thresh,
+		    int16 *ptr, int mode)
 {
 	uint32 curval1, curval2, stpptr, curptr, strptr, val;
 	uint16 sslpnCalibClkEnCtrl, timer;
@@ -3917,7 +3917,7 @@ wlc_lcnphy_samp_cap(phy_info_t * pi, int
 	W_REG(pi->sh->osh, &pi->regs->psm_corectlsts, curval1);
 }
 
-static void wlc_lcnphy_tx_iqlo_soft_cal_full(phy_info_t * pi)
+static void wlc_lcnphy_tx_iqlo_soft_cal_full(phy_info_t *pi)
 {
 	lcnphy_unsign16_struct iqcc0, locc2, locc3, locc4;
 
@@ -3940,7 +3940,7 @@ static void wlc_lcnphy_tx_iqlo_soft_cal_
 }
 
 static void
-wlc_lcnphy_set_cc(phy_info_t * pi, int cal_type, int16 coeff_x, int16 coeff_y)
+wlc_lcnphy_set_cc(phy_info_t *pi, int cal_type, int16 coeff_x, int16 coeff_y)
 {
 	uint16 di0dq0;
 	uint16 x, y, data_rf;
@@ -3984,7 +3984,7 @@ wlc_lcnphy_set_cc(phy_info_t * pi, int c
 	}
 }
 
-static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t * pi, int cal_type)
+static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t *pi, int cal_type)
 {
 	uint16 a, b, didq;
 	uint8 di0, dq0, ei, eq, fi, fq;
@@ -4019,7 +4019,7 @@ static lcnphy_unsign16_struct wlc_lcnphy
 }
 
 static void
-wlc_lcnphy_a1(phy_info_t * pi, int cal_type, int num_levels, int step_size_lg2)
+wlc_lcnphy_a1(phy_info_t *pi, int cal_type, int num_levels, int step_size_lg2)
 {
 	const lcnphy_spb_tone_t *phy_c1;
 	lcnphy_spb_tone_t phy_c2;
@@ -4214,7 +4214,7 @@ wlc_lcnphy_a1(phy_info_t * pi, int cal_t
 }
 
 static void
-wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t * pi, uint16 * values_to_save)
+wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t *pi, uint16 *values_to_save)
 {
 	int i;
 
@@ -4229,7 +4229,7 @@ wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_
 }
 
 static void
-WLBANDINITFN(wlc_lcnphy_load_tx_gain_table) (phy_info_t * pi,
+WLBANDINITFN(wlc_lcnphy_load_tx_gain_table) (phy_info_t *pi,
 					     const lcnphy_tx_gain_tbl_entry *
 					     gain_table) {
 	uint32 j;
@@ -4265,7 +4265,7 @@ WLBANDINITFN(wlc_lcnphy_load_tx_gain_tab
 	}
 }
 
-static void wlc_lcnphy_load_rfpower(phy_info_t * pi)
+static void wlc_lcnphy_load_rfpower(phy_info_t *pi)
 {
 	phytbl_info_t tab;
 	uint32 val, bbmult, rfgain;
@@ -4314,7 +4314,7 @@ static void wlc_lcnphy_load_rfpower(phy_
 	}
 }
 
-static void WLBANDINITFN(wlc_lcnphy_tbl_init) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_lcnphy_tbl_init) (phy_info_t *pi) {
 	uint idx;
 	uint8 phybw40;
 	phytbl_info_t tab;
@@ -4408,7 +4408,7 @@ static void WLBANDINITFN(wlc_lcnphy_tbl_
 	wlc_lcnphy_clear_papd_comptable(pi);
 }
 
-static void WLBANDINITFN(wlc_lcnphy_rev0_baseband_init) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_lcnphy_rev0_baseband_init) (phy_info_t *pi) {
 	uint16 afectrl1;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
 
@@ -4454,7 +4454,7 @@ static void WLBANDINITFN(wlc_lcnphy_rev0
 
 }
 
-static void WLBANDINITFN(wlc_lcnphy_rev2_baseband_init) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_lcnphy_rev2_baseband_init) (phy_info_t *pi) {
 	if (CHSPEC_IS5G(pi->radio_chanspec)) {
 		mod_phy_reg(pi, 0x416, (0xff << 0), 80 << 0);
 
@@ -4462,7 +4462,7 @@ static void WLBANDINITFN(wlc_lcnphy_rev2
 	}
 }
 
-static void wlc_lcnphy_agc_temp_init(phy_info_t * pi)
+static void wlc_lcnphy_agc_temp_init(phy_info_t *pi)
 {
 	int16 temp;
 	phytbl_info_t tab;
@@ -4523,7 +4523,7 @@ static void wlc_lcnphy_agc_temp_init(phy
 
 }
 
-static void WLBANDINITFN(wlc_lcnphy_bu_tweaks) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_lcnphy_bu_tweaks) (phy_info_t *pi) {
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 
@@ -4577,7 +4577,7 @@ static void WLBANDINITFN(wlc_lcnphy_bu_t
 	}
 }
 
-static void WLBANDINITFN(wlc_lcnphy_baseband_init) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_lcnphy_baseband_init) (phy_info_t *pi) {
 
 	wlc_lcnphy_tbl_init(pi);
 	wlc_lcnphy_rev0_baseband_init(pi);
@@ -4586,7 +4586,7 @@ static void WLBANDINITFN(wlc_lcnphy_base
 	wlc_lcnphy_bu_tweaks(pi);
 }
 
-static void WLBANDINITFN(wlc_radio_2064_init) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_radio_2064_init) (phy_info_t *pi) {
 	uint32 i;
 	lcnphy_radio_regs_t *lcnphyregs = NULL;
 
@@ -4646,14 +4646,14 @@ static void WLBANDINITFN(wlc_radio_2064_
 	wlc_lcnphy_rc_cal(pi);
 }
 
-static void WLBANDINITFN(wlc_lcnphy_radio_init) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_lcnphy_radio_init) (phy_info_t *pi) {
 	if (NORADIO_ENAB(pi->pubpi))
 		return;
 
 	wlc_radio_2064_init(pi);
 }
 
-static void wlc_lcnphy_rcal(phy_info_t * pi)
+static void wlc_lcnphy_rcal(phy_info_t *pi)
 {
 	uint8 rcal_value;
 
@@ -4684,7 +4684,7 @@ static void wlc_lcnphy_rcal(phy_info_t *
 	and_radio_reg(pi, RADIO_2064_REG057, 0xFE);
 }
 
-static void wlc_lcnphy_rc_cal(phy_info_t * pi)
+static void wlc_lcnphy_rc_cal(phy_info_t *pi)
 {
 	uint8 dflt_rc_cal_val;
 	uint16 flt_val;
@@ -4707,7 +4707,7 @@ static void wlc_lcnphy_rc_cal(phy_info_t
 	return;
 }
 
-static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t * pi) {
+static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t *pi) {
 	int8 txpwr = 0;
 	int i;
 	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
@@ -4828,7 +4828,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 	return TRUE;
 }
 
-void wlc_2064_vco_cal(phy_info_t * pi)
+void wlc_2064_vco_cal(phy_info_t *pi)
 {
 	uint8 calnrst;
 
@@ -4844,7 +4844,7 @@ void wlc_2064_vco_cal(phy_info_t * pi)
 }
 
 static void
-wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi, uint8 channel)
+wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t *pi, uint8 channel)
 {
 	uint i;
 	const chan_info_2064_lcnphy_t *ci;
@@ -5009,7 +5009,7 @@ wlc_lcnphy_radio_2064_channel_tune_4313(
 	}
 }
 
-bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t * pi)
+bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t *pi)
 {
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi))
 		return 0;
@@ -5018,7 +5018,7 @@ bool wlc_phy_tpc_isenabled_lcnphy(phy_in
 			wlc_lcnphy_get_tx_pwr_ctrl((pi)));
 }
 
-void wlc_phy_txpower_recalc_target_lcnphy(phy_info_t * pi)
+void wlc_phy_txpower_recalc_target_lcnphy(phy_info_t *pi)
 {
 	uint16 pwr_ctrl;
 	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi)) {
@@ -5034,12 +5034,12 @@ void wlc_phy_txpower_recalc_target_lcnph
 		return;
 }
 
-void wlc_phy_detach_lcnphy(phy_info_t * pi)
+void wlc_phy_detach_lcnphy(phy_info_t *pi)
 {
 	MFREE(pi->sh->osh, pi->u.pi_lcnphy, sizeof(phy_info_lcnphy_t));
 }
 
-bool wlc_phy_attach_lcnphy(phy_info_t * pi)
+bool wlc_phy_attach_lcnphy(phy_info_t *pi)
 {
 	phy_info_lcnphy_t *pi_lcn;
 
@@ -5091,7 +5091,7 @@ bool wlc_phy_attach_lcnphy(phy_info_t *
 	return TRUE;
 }
 
-static void wlc_lcnphy_set_rx_gain(phy_info_t * pi, uint32 gain)
+static void wlc_lcnphy_set_rx_gain(phy_info_t *pi, uint32 gain)
 {
 	uint16 trsw, ext_lna, lna1, lna2, tia, biq0, biq1, gain0_15, gain16_19;
 
@@ -5121,7 +5121,7 @@ static void wlc_lcnphy_set_rx_gain(phy_i
 	wlc_lcnphy_rx_gain_override_enable(pi, TRUE);
 }
 
-static uint32 wlc_lcnphy_get_receive_power(phy_info_t * pi, int32 * gain_index)
+static uint32 wlc_lcnphy_get_receive_power(phy_info_t *pi, int32 *gain_index)
 {
 	uint32 received_power = 0;
 	int32 max_index = 0;
@@ -5157,7 +5157,7 @@ static uint32 wlc_lcnphy_get_receive_pow
 	return received_power;
 }
 
-int32 wlc_lcnphy_rx_signal_power(phy_info_t * pi, int32 gain_index)
+int32 wlc_lcnphy_rx_signal_power(phy_info_t *pi, int32 gain_index)
 {
 	int32 gain = 0;
 	int32 nominal_power_db;
@@ -5229,7 +5229,7 @@ int32 wlc_lcnphy_rx_signal_power(phy_inf
 }
 
 static int
-wlc_lcnphy_load_tx_iir_filter(phy_info_t * pi, bool is_ofdm, int16 filt_type)
+wlc_lcnphy_load_tx_iir_filter(phy_info_t *pi, bool is_ofdm, int16 filt_type)
 {
 	int16 filt_index = -1;
 	int j;
--- a/drivers/staging/brcm80211/phy/wlc_phy_n.c
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -14078,116 +14078,116 @@ static uint8 ant_sw_ctrl_tbl_rev8_2057v7
 static uint8 ant_sw_ctrl_tbl_rev8_2057v7_core1[] =
     { 0x09, 0x0a, 0x09, 0x0a, 0x15, 0x16 };
 
-static bool wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
-				   chan_info_nphy_radio2057_t ** t0,
-				   chan_info_nphy_radio205x_t ** t1,
-				   chan_info_nphy_radio2057_rev5_t ** t2,
-				   chan_info_nphy_2055_t ** t3);
-static void wlc_phy_chanspec_nphy_setup(phy_info_t * pi, chanspec_t chans,
-					const nphy_sfo_cfg_t * c);
+static bool wlc_phy_chan2freq_nphy(phy_info_t *pi, uint channel, int *f,
+				   chan_info_nphy_radio2057_t **t0,
+				   chan_info_nphy_radio205x_t **t1,
+				   chan_info_nphy_radio2057_rev5_t **t2,
+				   chan_info_nphy_2055_t **t3);
+static void wlc_phy_chanspec_nphy_setup(phy_info_t *pi, chanspec_t chans,
+					const nphy_sfo_cfg_t *c);
 
-static void wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t * pi,
+static void wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t *pi,
 					    uint16 reduction_factr);
-static void wlc_phy_adjust_min_noisevar_nphy(phy_info_t * pi, int ntones, int *,
-					     uint32 * buf);
-static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t * pi, uint8 minpwr);
-static void wlc_phy_txlpfbw_nphy(phy_info_t * pi);
-static void wlc_phy_spurwar_nphy(phy_info_t * pi);
-
-static void wlc_phy_radio_preinit_2055(phy_info_t * pi);
-static void wlc_phy_radio_init_2055(phy_info_t * pi);
-static void wlc_phy_radio_postinit_2055(phy_info_t * pi);
-static void wlc_phy_radio_preinit_205x(phy_info_t * pi);
-static void wlc_phy_radio_init_2056(phy_info_t * pi);
-static void wlc_phy_radio_postinit_2056(phy_info_t * pi);
-static void wlc_phy_radio_init_2057(phy_info_t * pi);
-static void wlc_phy_radio_postinit_2057(phy_info_t * pi);
-static void wlc_phy_workarounds_nphy(phy_info_t * pi);
-static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t * pi);
-static void wlc_phy_workarounds_nphy_gainctrl_2057_rev5(phy_info_t * pi);
-static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t * pi);
-static void wlc_phy_adjust_lnagaintbl_nphy(phy_info_t * pi);
-
-static void wlc_phy_restore_rssical_nphy(phy_info_t * pi);
-static void wlc_phy_reapply_txcal_coeffs_nphy(phy_info_t * pi);
-static void wlc_phy_tx_iq_war_nphy(phy_info_t * pi);
-static int wlc_phy_cal_rxiq_nphy_rev3(phy_info_t * pi, nphy_txgains_t tg,
+static void wlc_phy_adjust_min_noisevar_nphy(phy_info_t *pi, int ntones, int *,
+					     uint32 *buf);
+static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t *pi, uint8 minpwr);
+static void wlc_phy_txlpfbw_nphy(phy_info_t *pi);
+static void wlc_phy_spurwar_nphy(phy_info_t *pi);
+
+static void wlc_phy_radio_preinit_2055(phy_info_t *pi);
+static void wlc_phy_radio_init_2055(phy_info_t *pi);
+static void wlc_phy_radio_postinit_2055(phy_info_t *pi);
+static void wlc_phy_radio_preinit_205x(phy_info_t *pi);
+static void wlc_phy_radio_init_2056(phy_info_t *pi);
+static void wlc_phy_radio_postinit_2056(phy_info_t *pi);
+static void wlc_phy_radio_init_2057(phy_info_t *pi);
+static void wlc_phy_radio_postinit_2057(phy_info_t *pi);
+static void wlc_phy_workarounds_nphy(phy_info_t *pi);
+static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t *pi);
+static void wlc_phy_workarounds_nphy_gainctrl_2057_rev5(phy_info_t *pi);
+static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t *pi);
+static void wlc_phy_adjust_lnagaintbl_nphy(phy_info_t *pi);
+
+static void wlc_phy_restore_rssical_nphy(phy_info_t *pi);
+static void wlc_phy_reapply_txcal_coeffs_nphy(phy_info_t *pi);
+static void wlc_phy_tx_iq_war_nphy(phy_info_t *pi);
+static int wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *pi, nphy_txgains_t tg,
 				      uint8 type, bool d);
-static void wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rxcore,
-					     uint16 * rg, uint8 type);
-static void wlc_phy_update_mimoconfig_nphy(phy_info_t * pi, int32 preamble);
-static void wlc_phy_savecal_nphy(phy_info_t * pi);
-static void wlc_phy_restorecal_nphy(phy_info_t * pi);
-static void wlc_phy_resetcca_nphy(phy_info_t * pi);
-
-static void wlc_phy_txpwrctrl_config_nphy(phy_info_t * pi);
-static void wlc_phy_internal_cal_txgain_nphy(phy_info_t * pi);
-static void wlc_phy_precal_txgain_nphy(phy_info_t * pi);
-static void wlc_phy_update_txcal_ladder_nphy(phy_info_t * pi, uint16 core);
-
-static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t * pi);
-static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t * pi);
-static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t * pi);
-static uint16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t * pi);
-static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t * pi, uint8 m0, uint8 m1);
-static uint32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t * pi);
+static void wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t *pi, uint8 rxcore,
+					     uint16 *rg, uint8 type);
+static void wlc_phy_update_mimoconfig_nphy(phy_info_t *pi, int32 preamble);
+static void wlc_phy_savecal_nphy(phy_info_t *pi);
+static void wlc_phy_restorecal_nphy(phy_info_t *pi);
+static void wlc_phy_resetcca_nphy(phy_info_t *pi);
+
+static void wlc_phy_txpwrctrl_config_nphy(phy_info_t *pi);
+static void wlc_phy_internal_cal_txgain_nphy(phy_info_t *pi);
+static void wlc_phy_precal_txgain_nphy(phy_info_t *pi);
+static void wlc_phy_update_txcal_ladder_nphy(phy_info_t *pi, uint16 core);
+
+static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t *pi);
+static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t *pi);
+static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t *pi);
+static uint16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t *pi);
+static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t *pi, uint8 m0, uint8 m1);
+static uint32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t *pi);
 
-static void wlc_phy_a1_nphy(phy_info_t * pi, uint8 core, uint32 winsz, uint32,
+static void wlc_phy_a1_nphy(phy_info_t *pi, uint8 core, uint32 winsz, uint32,
 			    uint32 e);
-static uint8 wlc_phy_a3_nphy(phy_info_t * pi, uint8 start_gain, uint8 core);
-static void wlc_phy_a2_nphy(phy_info_t * pi, nphy_ipa_txcalgains_t *,
+static uint8 wlc_phy_a3_nphy(phy_info_t *pi, uint8 start_gain, uint8 core);
+static void wlc_phy_a2_nphy(phy_info_t *pi, nphy_ipa_txcalgains_t *,
 			    phy_cal_mode_t, uint8);
-static void wlc_phy_papd_cal_cleanup_nphy(phy_info_t * pi,
-					  nphy_papd_restore_state * state);
-static void wlc_phy_papd_cal_setup_nphy(phy_info_t * pi,
-					nphy_papd_restore_state * state, uint8);
+static void wlc_phy_papd_cal_cleanup_nphy(phy_info_t *pi,
+					  nphy_papd_restore_state *state);
+static void wlc_phy_papd_cal_setup_nphy(phy_info_t *pi,
+					nphy_papd_restore_state *state, uint8);
 
-static void wlc_phy_clip_det_nphy(phy_info_t * pi, uint8 write, uint16 * vals);
+static void wlc_phy_clip_det_nphy(phy_info_t *pi, uint8 write, uint16 *vals);
 
-static void wlc_phy_set_rfseq_nphy(phy_info_t * pi, uint8 cmd, uint8 * evts,
-				   uint8 * dlys, uint8 len);
+static void wlc_phy_set_rfseq_nphy(phy_info_t *pi, uint8 cmd, uint8 *evts,
+				   uint8 *dlys, uint8 len);
 
-static uint16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t * pi, uint16 offset);
+static uint16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t *pi, uint16 offset);
 
 static void
-wlc_phy_rfctrl_override_nphy_rev7(phy_info_t * pi, uint16 field, uint16 value,
+wlc_phy_rfctrl_override_nphy_rev7(phy_info_t *pi, uint16 field, uint16 value,
 				  uint8 core_mask, uint8 off,
 				  uint8 override_id);
 
-static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t * pi, uint8 rssi_type);
-static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t * pi);
+static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t *pi, uint8 rssi_type);
+static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t *pi);
 
-static bool wlc_phy_txpwr_srom_read_nphy(phy_info_t * pi);
-static void wlc_phy_txpwr_nphy_srom_convert(uint8 * srom_max,
-					    uint16 * pwr_offset,
+static bool wlc_phy_txpwr_srom_read_nphy(phy_info_t *pi);
+static void wlc_phy_txpwr_nphy_srom_convert(uint8 *srom_max,
+					    uint16 *pwr_offset,
 					    uint8 tmp_max_pwr, uint8 rate_start,
 					    uint8 rate_end);
 
-static void wlc_phy_txpwr_limit_to_tbl_nphy(phy_info_t * pi);
-static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t * pi);
-static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t * pi);
-static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t * pi);
-
-static bool wlc_phy_txpwr_ison_nphy(phy_info_t * pi);
-static uint8 wlc_phy_txpwr_idx_cur_get_nphy(phy_info_t * pi, uint8 core);
-static void wlc_phy_txpwr_idx_cur_set_nphy(phy_info_t * pi, uint8 idx0,
+static void wlc_phy_txpwr_limit_to_tbl_nphy(phy_info_t *pi);
+static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t *pi);
+static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t *pi);
+static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t *pi);
+
+static bool wlc_phy_txpwr_ison_nphy(phy_info_t *pi);
+static uint8 wlc_phy_txpwr_idx_cur_get_nphy(phy_info_t *pi, uint8 core);
+static void wlc_phy_txpwr_idx_cur_set_nphy(phy_info_t *pi, uint8 idx0,
 					   uint8 idx1);
-static void wlc_phy_a4(phy_info_t * pi, bool full_cal);
+static void wlc_phy_a4(phy_info_t *pi, bool full_cal);
 
-static uint16 wlc_phy_radio205x_rcal(phy_info_t * pi);
+static uint16 wlc_phy_radio205x_rcal(phy_info_t *pi);
 
-static uint16 wlc_phy_radio2057_rccal(phy_info_t * pi);
+static uint16 wlc_phy_radio2057_rccal(phy_info_t *pi);
 
-static uint16 wlc_phy_gen_load_samples_nphy(phy_info_t * pi, uint32 f_kHz,
+static uint16 wlc_phy_gen_load_samples_nphy(phy_info_t *pi, uint32 f_kHz,
 					    uint16 max_val,
 					    uint8 dac_test_mode);
-static void wlc_phy_loadsampletable_nphy(phy_info_t * pi, cint32 * tone_buf,
+static void wlc_phy_loadsampletable_nphy(phy_info_t *pi, cint32 *tone_buf,
 					 uint16 num_samps);
-static void wlc_phy_runsamples_nphy(phy_info_t * pi, uint16 n, uint16 lps,
+static void wlc_phy_runsamples_nphy(phy_info_t *pi, uint16 n, uint16 lps,
 				    uint16 wait, uint8 iq, uint8 dac_test_mode,
 				    bool modify_bbmult);
 
-bool wlc_phy_bist_check_phy(wlc_phy_t * pih)
+bool wlc_phy_bist_check_phy(wlc_phy_t *pih)
 {
 	phy_info_t *pi = (phy_info_t *) pih;
 	uint32 phybist0, phybist1, phybist2, phybist3, phybist4;
@@ -14209,7 +14209,7 @@ bool wlc_phy_bist_check_phy(wlc_phy_t *
 	return FALSE;
 }
 
-static void WLBANDINITFN(wlc_phy_bphy_init_nphy) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_phy_bphy_init_nphy) (phy_info_t *pi) {
 	uint16 addr, val;
 
 	ASSERT(ISNPHY(pi));
@@ -14239,7 +14239,7 @@ static void WLBANDINITFN(wlc_phy_bphy_in
 }
 
 void
-wlc_phy_table_write_nphy(phy_info_t * pi, uint32 id, uint32 len, uint32 offset,
+wlc_phy_table_write_nphy(phy_info_t *pi, uint32 id, uint32 len, uint32 offset,
 			 uint32 width, const void *data)
 {
 	mimophytbl_info_t tbl;
@@ -14253,7 +14253,7 @@ wlc_phy_table_write_nphy(phy_info_t * pi
 }
 
 void
-wlc_phy_table_read_nphy(phy_info_t * pi, uint32 id, uint32 len, uint32 offset,
+wlc_phy_table_read_nphy(phy_info_t *pi, uint32 id, uint32 len, uint32 offset,
 			uint32 width, void *data)
 {
 	mimophytbl_info_t tbl;
@@ -14266,7 +14266,7 @@ wlc_phy_table_read_nphy(phy_info_t * pi,
 	wlc_phy_read_table_nphy(pi, &tbl);
 }
 
-static void WLBANDINITFN(wlc_phy_static_table_download_nphy) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_phy_static_table_download_nphy) (phy_info_t *pi) {
 	uint idx;
 
 	if (NREV_GE(pi->pubpi.phy_rev, 16)) {
@@ -14288,7 +14288,7 @@ static void WLBANDINITFN(wlc_phy_static_
 	}
 }
 
-static void WLBANDINITFN(wlc_phy_tbl_init_nphy) (phy_info_t * pi) {
+static void WLBANDINITFN(wlc_phy_tbl_init_nphy) (phy_info_t *pi) {
 	uint idx = 0;
 	uint8 antswctrllut;
 
@@ -14413,13 +14413,13 @@ static void WLBANDINITFN(wlc_phy_tbl_ini
 }
 
 static void
-wlc_phy_write_txmacreg_nphy(phy_info_t * pi, uint16 holdoff, uint16 delay)
+wlc_phy_write_txmacreg_nphy(phy_info_t *pi, uint16 holdoff, uint16 delay)
 {
 	write_phy_reg(pi, 0x77, holdoff);
 	write_phy_reg(pi, 0xb4, delay);
 }
 
-void wlc_phy_nphy_tkip_rifs_war(phy_info_t * pi, uint8 rifs)
+void wlc_phy_nphy_tkip_rifs_war(phy_info_t *pi, uint8 rifs)
 {
 	uint16 holdoff, delay;
 
@@ -14440,7 +14440,7 @@ void wlc_phy_nphy_tkip_rifs_war(phy_info
 	}
 }
 
-bool wlc_phy_attach_nphy(phy_info_t * pi)
+bool wlc_phy_attach_nphy(phy_info_t *pi)
 {
 	uint i;
 
@@ -14499,7 +14499,7 @@ bool wlc_phy_attach_nphy(phy_info_t * pi
 	return TRUE;
 }
 
-static void BCMATTACHFN(wlc_phy_txpwrctrl_config_nphy) (phy_info_t * pi) {
+static void BCMATTACHFN(wlc_phy_txpwrctrl_config_nphy) (phy_info_t *pi) {
 
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 		pi->nphy_txpwrctrl = PHY_TPC_HW_ON;
@@ -14518,7 +14518,7 @@ static void BCMATTACHFN(wlc_phy_txpwrctr
 		pi->phy_5g_pwrgain = TRUE;
 }
 
-void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
+void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t *pi) {
 	uint16 val;
 	uint16 clip1_ths[2];
 	nphy_txgains_t target_gain;
@@ -14930,7 +14930,7 @@ void WLBANDINITFN(wlc_phy_init_nphy) (ph
 
 }
 
-static void wlc_phy_update_mimoconfig_nphy(phy_info_t * pi, int32 preamble)
+static void wlc_phy_update_mimoconfig_nphy(phy_info_t *pi, int32 preamble)
 {
 	bool gf_preamble = FALSE;
 	uint16 val;
@@ -14949,7 +14949,7 @@ static void wlc_phy_update_mimoconfig_np
 	write_phy_reg(pi, 0xed, val);
 }
 
-static void wlc_phy_resetcca_nphy(phy_info_t * pi)
+static void wlc_phy_resetcca_nphy(phy_info_t *pi)
 {
 	uint16 val;
 
@@ -14967,7 +14967,7 @@ static void wlc_phy_resetcca_nphy(phy_in
 	wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
 }
 
-void wlc_phy_pa_override_nphy(phy_info_t * pi, bool en)
+void wlc_phy_pa_override_nphy(phy_info_t *pi, bool en)
 {
 	uint16 rfctrlintc_override_val;
 
@@ -14996,7 +14996,7 @@ void wlc_phy_pa_override_nphy(phy_info_t
 
 }
 
-void wlc_phy_stf_chain_upd_nphy(phy_info_t * pi)
+void wlc_phy_stf_chain_upd_nphy(phy_info_t *pi)
 {
 
 	uint16 txrx_chain =
@@ -15031,7 +15031,7 @@ void wlc_phy_stf_chain_upd_nphy(phy_info
 	}
 }
 
-void wlc_phy_rxcore_setstate_nphy(wlc_phy_t * pih, uint8 rxcore_bitmask)
+void wlc_phy_rxcore_setstate_nphy(wlc_phy_t *pih, uint8 rxcore_bitmask)
 {
 	uint16 regval;
 	uint16 tbl_buf[16];
@@ -15112,7 +15112,7 @@ void wlc_phy_rxcore_setstate_nphy(wlc_ph
 		wlapi_enable_mac(pi->sh->physhim);
 }
 
-uint8 wlc_phy_rxcore_getstate_nphy(wlc_phy_t * pih)
+uint8 wlc_phy_rxcore_getstate_nphy(wlc_phy_t *pih)
 {
 	uint16 regval, rxen_bits;
 	phy_info_t *pi = (phy_info_t *) pih;
@@ -15123,12 +15123,12 @@ uint8 wlc_phy_rxcore_getstate_nphy(wlc_p
 	return ((uint8) rxen_bits);
 }
 
-bool wlc_phy_n_txpower_ipa_ison(phy_info_t * pi)
+bool wlc_phy_n_txpower_ipa_ison(phy_info_t *pi)
 {
 	return PHY_IPA(pi);
 }
 
-static void wlc_phy_txpwr_limit_to_tbl_nphy(phy_info_t * pi)
+static void wlc_phy_txpwr_limit_to_tbl_nphy(phy_info_t *pi)
 {
 	uint8 idx, idx2, i, delta_ind;
 
@@ -15222,11 +15222,11 @@ static void wlc_phy_txpwr_limit_to_tbl_n
 	}
 }
 
-void wlc_phy_cal_init_nphy(phy_info_t * pi)
+void wlc_phy_cal_init_nphy(phy_info_t *pi)
 {
 }
 
-static void wlc_phy_war_force_trsw_to_R_cliplo_nphy(phy_info_t * pi, uint8 core)
+static void wlc_phy_war_force_trsw_to_R_cliplo_nphy(phy_info_t *pi, uint8 core)
 {
 	if (core == PHY_CORE_0) {
 		write_phy_reg(pi, 0x38, 0x4);
@@ -15245,7 +15245,7 @@ static void wlc_phy_war_force_trsw_to_R_
 	}
 }
 
-static void wlc_phy_war_txchain_upd_nphy(phy_info_t * pi, uint8 txchain)
+static void wlc_phy_war_txchain_upd_nphy(phy_info_t *pi, uint8 txchain)
 {
 	uint8 txchain0, txchain1;
 
@@ -15260,7 +15260,7 @@ static void wlc_phy_war_txchain_upd_nphy
 	}
 }
 
-static void wlc_phy_workarounds_nphy(phy_info_t * pi)
+static void wlc_phy_workarounds_nphy(phy_info_t *pi)
 {
 	uint8 rfseq_rx2tx_events[] = {
 		NPHY_RFSEQ_CMD_NOP,
@@ -16337,7 +16337,7 @@ static void wlc_phy_workarounds_nphy(phy
 		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
 }
 
-static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t * pi)
+static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t *pi)
 {
 	uint16 w1th, hpf_code, currband;
 	int ctr;
@@ -16957,7 +16957,7 @@ static void wlc_phy_workarounds_nphy_gai
 	}
 }
 
-static void wlc_phy_workarounds_nphy_gainctrl_2057_rev5(phy_info_t * pi)
+static void wlc_phy_workarounds_nphy_gainctrl_2057_rev5(phy_info_t *pi)
 {
 	int8 lna1_gain_db[] = { 8, 13, 17, 22 };
 	int8 lna2_gain_db[] = { -2, 7, 11, 15 };
@@ -17012,7 +17012,7 @@ static void wlc_phy_workarounds_nphy_gai
 	}
 }
 
-static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t * pi)
+static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t *pi)
 {
 	uint16 currband;
 	int8 lna1G_gain_db_rev7[] = { 9, 14, 19, 24 };
@@ -17218,7 +17218,7 @@ static void wlc_phy_workarounds_nphy_gai
 
 }
 
-static void wlc_phy_adjust_lnagaintbl_nphy(phy_info_t * pi)
+static void wlc_phy_adjust_lnagaintbl_nphy(phy_info_t *pi)
 {
 	uint core;
 	int ctr;
@@ -17281,7 +17281,7 @@ static void wlc_phy_adjust_lnagaintbl_np
 		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
 }
 
-void wlc_phy_switch_radio_nphy(phy_info_t * pi, bool on)
+void wlc_phy_switch_radio_nphy(phy_info_t *pi, bool on)
 {
 	if (on) {
 		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -17364,7 +17364,7 @@ void wlc_phy_switch_radio_nphy(phy_info_
 	}
 }
 
-static void wlc_phy_radio_preinit_2055(phy_info_t * pi)
+static void wlc_phy_radio_preinit_2055(phy_info_t *pi)
 {
 
 	and_phy_reg(pi, 0x78, ~RFCC_POR_FORCE);
@@ -17373,12 +17373,12 @@ static void wlc_phy_radio_preinit_2055(p
 	or_phy_reg(pi, 0x78, RFCC_POR_FORCE);
 }
 
-static void wlc_phy_radio_init_2055(phy_info_t * pi)
+static void wlc_phy_radio_init_2055(phy_info_t *pi)
 {
 	wlc_phy_init_radio_regs(pi, regs_2055, RADIO_DEFAULT_CORE);
 }
 
-static void wlc_phy_radio_postinit_2055(phy_info_t * pi)
+static void wlc_phy_radio_postinit_2055(phy_info_t *pi)
 {
 
 	and_radio_reg(pi, RADIO_2055_MASTER_CNTRL1,
@@ -17441,7 +17441,7 @@ static void wlc_phy_radio_postinit_2055(
 	OSL_DELAY(2);
 }
 
-static void wlc_phy_radio_preinit_205x(phy_info_t * pi)
+static void wlc_phy_radio_preinit_205x(phy_info_t *pi)
 {
 
 	and_phy_reg(pi, 0x78, ~RFCC_CHIP0_PU);
@@ -17452,7 +17452,7 @@ static void wlc_phy_radio_preinit_205x(p
 
 }
 
-static void wlc_phy_radio_init_2056(phy_info_t * pi)
+static void wlc_phy_radio_init_2056(phy_info_t *pi)
 {
 	radio_regs_t *regs_SYN_2056_ptr = NULL;
 	radio_regs_t *regs_TX_2056_ptr = NULL;
@@ -17516,7 +17516,7 @@ static void wlc_phy_radio_init_2056(phy_
 	wlc_phy_init_radio_regs(pi, regs_RX_2056_ptr, (uint16) RADIO_2056_RX1);
 }
 
-static void wlc_phy_radio_postinit_2056(phy_info_t * pi)
+static void wlc_phy_radio_postinit_2056(phy_info_t *pi)
 {
 	mod_radio_reg(pi, RADIO_2056_SYN_COM_CTRL, 0xb, 0xb);
 
@@ -17541,7 +17541,7 @@ static void wlc_phy_radio_postinit_2056(
 	}
 }
 
-static void wlc_phy_radio_init_2057(phy_info_t * pi)
+static void wlc_phy_radio_init_2057(phy_info_t *pi)
 {
 	radio_20xx_regs_t *regs_2057_ptr = NULL;
 
@@ -17586,7 +17586,7 @@ static void wlc_phy_radio_init_2057(phy_
 	wlc_phy_init_radio_regs_allbands(pi, regs_2057_ptr);
 }
 
-static void wlc_phy_radio_postinit_2057(phy_info_t * pi)
+static void wlc_phy_radio_postinit_2057(phy_info_t *pi)
 {
 
 	mod_radio_reg(pi, RADIO_2057_XTALPUOVR_PINCTRL, 0x1, 0x1);
@@ -17611,11 +17611,11 @@ static void wlc_phy_radio_postinit_2057(
 }
 
 static bool
-wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
-		       chan_info_nphy_radio2057_t ** t0,
-		       chan_info_nphy_radio205x_t ** t1,
-		       chan_info_nphy_radio2057_rev5_t ** t2,
-		       chan_info_nphy_2055_t ** t3)
+wlc_phy_chan2freq_nphy(phy_info_t *pi, uint channel, int *f,
+		       chan_info_nphy_radio2057_t **t0,
+		       chan_info_nphy_radio205x_t **t1,
+		       chan_info_nphy_radio2057_rev5_t **t2,
+		       chan_info_nphy_2055_t **t3)
 {
 	uint i;
 	chan_info_nphy_radio2057_t *chan_info_tbl_p_0 = NULL;
@@ -17782,7 +17782,7 @@ wlc_phy_chan2freq_nphy(phy_info_t * pi,
 	return FALSE;
 }
 
-uint8 wlc_phy_get_chan_freq_range_nphy(phy_info_t * pi, uint channel)
+uint8 wlc_phy_get_chan_freq_range_nphy(phy_info_t *pi, uint channel)
 {
 	int freq;
 	chan_info_nphy_radio2057_t *t0 = NULL;
@@ -17811,7 +17811,7 @@ uint8 wlc_phy_get_chan_freq_range_nphy(p
 }
 
 static void
-wlc_phy_chanspec_radio2055_setup(phy_info_t * pi, chan_info_nphy_2055_t * ci)
+wlc_phy_chanspec_radio2055_setup(phy_info_t *pi, chan_info_nphy_2055_t *ci)
 {
 
 	write_radio_reg(pi, RADIO_2055_PLL_REF, ci->RF_pll_ref);
@@ -17873,8 +17873,8 @@ wlc_phy_chanspec_radio2055_setup(phy_inf
 }
 
 static void
-wlc_phy_chanspec_radio2056_setup(phy_info_t * pi,
-				 const chan_info_nphy_radio205x_t * ci)
+wlc_phy_chanspec_radio2056_setup(phy_info_t *pi,
+				 const chan_info_nphy_radio205x_t *ci)
 {
 	radio_regs_t *regs_SYN_2056_ptr = NULL;
 
@@ -18214,7 +18214,7 @@ wlc_phy_chanspec_radio2056_setup(phy_inf
 	wlc_phy_radio205x_vcocal_nphy(pi);
 }
 
-void wlc_phy_radio205x_vcocal_nphy(phy_info_t * pi)
+void wlc_phy_radio205x_vcocal_nphy(phy_info_t *pi)
 {
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 		mod_radio_reg(pi, RADIO_2057_RFPLL_MISC_EN, 0x01, 0x0);
@@ -18235,7 +18235,7 @@ void wlc_phy_radio205x_vcocal_nphy(phy_i
 
 #define MAX_205x_RCAL_WAITLOOPS 10000
 
-static uint16 wlc_phy_radio205x_rcal(phy_info_t * pi)
+static uint16 wlc_phy_radio205x_rcal(phy_info_t *pi)
 {
 	uint16 rcal_reg = 0;
 	int i;
@@ -18337,9 +18337,9 @@ static uint16 wlc_phy_radio205x_rcal(phy
 }
 
 static void
-wlc_phy_chanspec_radio2057_setup(phy_info_t * pi,
-				 const chan_info_nphy_radio2057_t * ci,
-				 const chan_info_nphy_radio2057_rev5_t * ci2)
+wlc_phy_chanspec_radio2057_setup(phy_info_t *pi,
+				 const chan_info_nphy_radio2057_t *ci,
+				 const chan_info_nphy_radio2057_rev5_t *ci2)
 {
 	int coreNum;
 	uint16 txmix2g_tune_boost_pu = 0;
@@ -18532,7 +18532,7 @@ wlc_phy_chanspec_radio2057_setup(phy_inf
 	wlc_phy_radio205x_vcocal_nphy(pi);
 }
 
-static uint16 wlc_phy_radio2057_rccal(phy_info_t * pi)
+static uint16 wlc_phy_radio2057_rccal(phy_info_t *pi)
 {
 	uint16 rccal_valid;
 	int i;
@@ -18619,7 +18619,7 @@ static uint16 wlc_phy_radio2057_rccal(ph
 }
 
 static void
-wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t * pi, uint16 reduction_factr)
+wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t *pi, uint16 reduction_factr)
 {
 	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 7)) {
 		if ((CHSPEC_CHANNEL(pi->radio_chanspec) == 11) &&
@@ -18647,8 +18647,8 @@ wlc_phy_adjust_rx_analpfbw_nphy(phy_info
 }
 
 static void
-wlc_phy_adjust_min_noisevar_nphy(phy_info_t * pi, int ntones, int *tone_id_buf,
-				 uint32 * noise_var_buf)
+wlc_phy_adjust_min_noisevar_nphy(phy_info_t *pi, int ntones, int *tone_id_buf,
+				 uint32 *noise_var_buf)
 {
 	int i;
 	uint32 offset;
@@ -18696,7 +18696,7 @@ wlc_phy_adjust_min_noisevar_nphy(phy_inf
 	}
 }
 
-static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t * pi, uint8 minpwr)
+static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t *pi, uint8 minpwr)
 {
 	uint16 regval;
 
@@ -18747,7 +18747,7 @@ static void wlc_phy_adjust_crsminpwr_nph
 	}
 }
 
-static void wlc_phy_txlpfbw_nphy(phy_info_t * pi)
+static void wlc_phy_txlpfbw_nphy(phy_info_t *pi)
 {
 	uint8 tx_lpf_bw = 0;
 
@@ -18786,7 +18786,7 @@ static void wlc_phy_txlpfbw_nphy(phy_inf
 	}
 }
 
-static void wlc_phy_spurwar_nphy(phy_info_t * pi)
+static void wlc_phy_spurwar_nphy(phy_info_t *pi)
 {
 	uint16 cur_channel = 0;
 	int nphy_adj_tone_id_buf[] = { 57, 58 };
@@ -18964,8 +18964,8 @@ static void wlc_phy_spurwar_nphy(phy_inf
 }
 
 static void
-wlc_phy_chanspec_nphy_setup(phy_info_t * pi, chanspec_t chanspec,
-			    const nphy_sfo_cfg_t * ci)
+wlc_phy_chanspec_nphy_setup(phy_info_t *pi, chanspec_t chanspec,
+			    const nphy_sfo_cfg_t *ci)
 {
 	uint16 val;
 
@@ -19116,7 +19116,7 @@ wlc_phy_chanspec_nphy_setup(phy_info_t *
 	wlc_phy_spurwar_nphy(pi);
 }
 
-void wlc_phy_chanspec_set_nphy(phy_info_t * pi, chanspec_t chanspec)
+void wlc_phy_chanspec_set_nphy(phy_info_t *pi, chanspec_t chanspec)
 {
 	int freq;
 	chan_info_nphy_radio2057_t *t0 = NULL;
@@ -19203,7 +19203,7 @@ void wlc_phy_chanspec_set_nphy(phy_info_
 
 }
 
-static void wlc_phy_savecal_nphy(phy_info_t * pi)
+static void wlc_phy_savecal_nphy(phy_info_t *pi)
 {
 	void *tbl_ptr;
 	int coreNum;
@@ -19352,7 +19352,7 @@ static void wlc_phy_savecal_nphy(phy_inf
 		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
 }
 
-static void wlc_phy_restorecal_nphy(phy_info_t * pi)
+static void wlc_phy_restorecal_nphy(phy_info_t *pi)
 {
 	uint16 *loft_comp;
 	uint16 txcal_coeffs_bphy[4];
@@ -19551,7 +19551,7 @@ static void wlc_phy_restorecal_nphy(phy_
 	}
 }
 
-void wlc_phy_antsel_init(wlc_phy_t * ppi, bool lut_init)
+void wlc_phy_antsel_init(wlc_phy_t *ppi, bool lut_init)
 {
 	phy_info_t *pi = (phy_info_t *) ppi;
 	uint16 mask = 0xfc00;
@@ -19615,7 +19615,7 @@ void wlc_phy_antsel_init(wlc_phy_t * ppi
 	}
 }
 
-uint16 wlc_phy_classifier_nphy(phy_info_t * pi, uint16 mask, uint16 val)
+uint16 wlc_phy_classifier_nphy(phy_info_t *pi, uint16 mask, uint16 val)
 {
 	uint16 curr_ctl, new_ctl;
 	bool suspended = FALSE;
@@ -19640,7 +19640,7 @@ uint16 wlc_phy_classifier_nphy(phy_info_
 	return new_ctl;
 }
 
-static void wlc_phy_clip_det_nphy(phy_info_t * pi, uint8 write, uint16 * vals)
+static void wlc_phy_clip_det_nphy(phy_info_t *pi, uint8 write, uint16 *vals)
 {
 
 	if (write == 0) {
@@ -19652,7 +19652,7 @@ static void wlc_phy_clip_det_nphy(phy_in
 	}
 }
 
-void wlc_phy_force_rfseq_nphy(phy_info_t * pi, uint8 cmd)
+void wlc_phy_force_rfseq_nphy(phy_info_t *pi, uint8 cmd)
 {
 	uint16 trigger_mask, status_mask;
 	uint16 orig_RfseqCoreActv;
@@ -19698,7 +19698,7 @@ void wlc_phy_force_rfseq_nphy(phy_info_t
 }
 
 static void
-wlc_phy_set_rfseq_nphy(phy_info_t * pi, uint8 cmd, uint8 * events, uint8 * dlys,
+wlc_phy_set_rfseq_nphy(phy_info_t *pi, uint8 cmd, uint8 *events, uint8 *dlys,
 		       uint8 len)
 {
 	uint32 t1_offset, t2_offset;
@@ -19731,7 +19731,7 @@ wlc_phy_set_rfseq_nphy(phy_info_t * pi,
 		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
 }
 
-static uint16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t * pi, uint16 offset)
+static uint16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t *pi, uint16 offset)
 {
 	uint16 lpf_bw_ctl_val = 0;
 	uint16 rx2tx_lpf_rc_lut_offset = 0;
@@ -19755,7 +19755,7 @@ static uint16 wlc_phy_read_lpf_bw_ctl_np
 }
 
 static void
-wlc_phy_rfctrl_override_nphy_rev7(phy_info_t * pi, uint16 field, uint16 value,
+wlc_phy_rfctrl_override_nphy_rev7(phy_info_t *pi, uint16 field, uint16 value,
 				  uint8 core_mask, uint8 off, uint8 override_id)
 {
 	uint8 core_num;
@@ -20025,7 +20025,7 @@ wlc_phy_rfctrl_override_nphy_rev7(phy_in
 }
 
 static void
-wlc_phy_rfctrl_override_nphy(phy_info_t * pi, uint16 field, uint16 value,
+wlc_phy_rfctrl_override_nphy(phy_info_t *pi, uint16 field, uint16 value,
 			     uint8 core_mask, uint8 off)
 {
 	uint8 core_num;
@@ -20271,7 +20271,7 @@ wlc_phy_rfctrl_override_nphy(phy_info_t
 }
 
 static void
-wlc_phy_rfctrl_override_1tomany_nphy(phy_info_t * pi, uint16 cmd, uint16 value,
+wlc_phy_rfctrl_override_1tomany_nphy(phy_info_t *pi, uint16 cmd, uint16 value,
 				     uint8 core_mask, uint8 off)
 {
 	uint16 rfmxgain = 0, lpfgain = 0;
@@ -20357,7 +20357,7 @@ wlc_phy_rfctrl_override_1tomany_nphy(phy
 }
 
 static void
-wlc_phy_scale_offset_rssi_nphy(phy_info_t * pi, uint16 scale, int8 offset,
+wlc_phy_scale_offset_rssi_nphy(phy_info_t *pi, uint16 scale, int8 offset,
 			       uint8 coresel, uint8 rail, uint8 rssi_type)
 {
 	uint16 valuetostuff;
@@ -20497,7 +20497,7 @@ wlc_phy_scale_offset_rssi_nphy(phy_info_
 	}
 }
 
-void wlc_phy_rssisel_nphy(phy_info_t * pi, uint8 core_code, uint8 rssi_type)
+void wlc_phy_rssisel_nphy(phy_info_t *pi, uint8 core_code, uint8 rssi_type)
 {
 	uint16 mask, val;
 	uint16 afectrlovr_rssi_val, rfctrlcmd_rxen_val, rfctrlcmd_coresel_val,
@@ -20801,7 +20801,7 @@ void wlc_phy_rssisel_nphy(phy_info_t * p
 }
 
 int
-wlc_phy_poll_rssi_nphy(phy_info_t * pi, uint8 rssi_type, int32 * rssi_buf,
+wlc_phy_poll_rssi_nphy(phy_info_t *pi, uint8 rssi_type, int32 *rssi_buf,
 		       uint8 nsamps)
 {
 	int16 rssi0, rssi1;
@@ -20900,7 +20900,7 @@ wlc_phy_poll_rssi_nphy(phy_info_t * pi,
 	return (rssi_out_val);
 }
 
-int16 wlc_phy_tempsense_nphy(phy_info_t * pi)
+int16 wlc_phy_tempsense_nphy(phy_info_t *pi)
 {
 	uint16 core1_txrf_iqcal1_save, core1_txrf_iqcal2_save;
 	uint16 core2_txrf_iqcal1_save, core2_txrf_iqcal2_save;
@@ -21184,7 +21184,7 @@ int16 wlc_phy_tempsense_nphy(phy_info_t
 }
 
 static void
-wlc_phy_set_rssi_2055_vcm(phy_info_t * pi, uint8 rssi_type, uint8 * vcm_buf)
+wlc_phy_set_rssi_2055_vcm(phy_info_t *pi, uint8 rssi_type, uint8 *vcm_buf)
 {
 	uint8 core;
 
@@ -21238,7 +21238,7 @@ wlc_phy_set_rssi_2055_vcm(phy_info_t * p
 	}
 }
 
-void wlc_phy_rssi_cal_nphy(phy_info_t * pi)
+void wlc_phy_rssi_cal_nphy(phy_info_t *pi)
 {
 	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
 
@@ -21250,7 +21250,7 @@ void wlc_phy_rssi_cal_nphy(phy_info_t *
 	}
 }
 
-static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t * pi, uint8 rssi_type)
+static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t *pi, uint8 rssi_type)
 {
 	int32 target_code;
 	uint16 classif_state;
@@ -21458,7 +21458,7 @@ static void wlc_phy_rssi_cal_nphy_rev2(p
 }
 
 int BCMFASTPATH
-wlc_phy_rssi_compute_nphy(phy_info_t * pi, wlc_d11rxhdr_t * wlc_rxh)
+wlc_phy_rssi_compute_nphy(phy_info_t *pi, wlc_d11rxhdr_t *wlc_rxh)
 {
 	d11rxhdr_t *rxh = &wlc_rxh->rxhdr;
 	int16 rxpwr, rxpwr0, rxpwr1;
@@ -21500,7 +21500,7 @@ wlc_phy_rssi_compute_nphy(phy_info_t * p
 }
 
 static void
-wlc_phy_rfctrlintc_override_nphy(phy_info_t * pi, uint8 field, uint16 value,
+wlc_phy_rfctrlintc_override_nphy(phy_info_t *pi, uint8 field, uint16 value,
 				 uint8 core_code)
 {
 	uint16 mask;
@@ -21734,7 +21734,7 @@ wlc_phy_rfctrlintc_override_nphy(phy_inf
 	}
 }
 
-static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t * pi)
+static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t *pi)
 {
 	uint16 classif_state;
 	uint16 clip_state[2];
@@ -22221,7 +22221,7 @@ static void wlc_phy_rssi_cal_nphy_rev3(p
 	wlc_phy_clip_det_nphy(pi, 1, clip_state);
 }
 
-static void wlc_phy_restore_rssical_nphy(phy_info_t * pi)
+static void wlc_phy_restore_rssical_nphy(phy_info_t *pi)
 {
 	ASSERT(NREV_GE(pi->pubpi.phy_rev, 3));
 
@@ -22330,7 +22330,7 @@ static void wlc_phy_restore_rssical_nphy
 }
 
 static uint16
-wlc_phy_gen_load_samples_nphy(phy_info_t * pi, uint32 f_kHz, uint16 max_val,
+wlc_phy_gen_load_samples_nphy(phy_info_t *pi, uint32 f_kHz, uint16 max_val,
 			      uint8 dac_test_mode)
 {
 	uint8 phy_bw, is_phybw40;
@@ -22381,7 +22381,7 @@ wlc_phy_gen_load_samples_nphy(phy_info_t
 }
 
 int
-wlc_phy_tx_tone_nphy(phy_info_t * pi, uint32 f_kHz, uint16 max_val,
+wlc_phy_tx_tone_nphy(phy_info_t *pi, uint32 f_kHz, uint16 max_val,
 		     uint8 iqmode, uint8 dac_test_mode, bool modify_bbmult)
 {
 	uint16 num_samps;
@@ -22401,7 +22401,7 @@ wlc_phy_tx_tone_nphy(phy_info_t * pi, ui
 }
 
 static void
-wlc_phy_loadsampletable_nphy(phy_info_t * pi, cint32 * tone_buf,
+wlc_phy_loadsampletable_nphy(phy_info_t *pi, cint32 *tone_buf,
 			     uint16 num_samps)
 {
 	uint16 t;
@@ -22431,7 +22431,7 @@ wlc_phy_loadsampletable_nphy(phy_info_t
 }
 
 static void
-wlc_phy_runsamples_nphy(phy_info_t * pi, uint16 num_samps, uint16 loops,
+wlc_phy_runsamples_nphy(phy_info_t *pi, uint16 num_samps, uint16 loops,
 			uint16 wait, uint8 iqmode, uint8 dac_test_mode,
 			bool modify_bbmult)
 {
@@ -22518,7 +22518,7 @@ wlc_phy_runsamples_nphy(phy_info_t * pi,
 	write_phy_reg(pi, 0xa1, orig_RfseqCoreActv);
 }
 
-void wlc_phy_stopplayback_nphy(phy_info_t * pi)
+void wlc_phy_stopplayback_nphy(phy_info_t *pi)
 {
 	uint16 playback_status;
 	uint16 bb_mult;
@@ -22560,7 +22560,7 @@ void wlc_phy_stopplayback_nphy(phy_info_
 		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
 }
 
-nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t * pi)
+nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t *pi)
 {
 	uint16 base_idx[2], curr_gain[2];
 	uint8 core_no;
@@ -22718,9 +22718,9 @@ nphy_txgains_t wlc_phy_get_tx_gain_nphy(
 }
 
 static void
-wlc_phy_iqcal_gainparams_nphy(phy_info_t * pi, uint16 core_no,
+wlc_phy_iqcal_gainparams_nphy(phy_info_t *pi, uint16 core_no,
 			      nphy_txgains_t target_gain,
-			      nphy_iqcal_params_t * params)
+			      nphy_iqcal_params_t *params)
 {
 	uint8 k;
 	int idx;
@@ -22783,7 +22783,7 @@ wlc_phy_iqcal_gainparams_nphy(phy_info_t
 	}
 }
 
-static void wlc_phy_txcal_radio_setup_nphy(phy_info_t * pi)
+static void wlc_phy_txcal_radio_setup_nphy(phy_info_t *pi)
 {
 	uint16 jtag_core, core;
 
@@ -23095,7 +23095,7 @@ static void wlc_phy_txcal_radio_setup_np
 	}
 }
 
-static void wlc_phy_txcal_radio_cleanup_nphy(phy_info_t * pi)
+static void wlc_phy_txcal_radio_cleanup_nphy(phy_info_t *pi)
 {
 	uint16 jtag_core, core;
 
@@ -23233,7 +23233,7 @@ static void wlc_phy_txcal_radio_cleanup_
 	}
 }
 
-static void wlc_phy_txcal_physetup_nphy(phy_info_t * pi)
+static void wlc_phy_txcal_physetup_nphy(phy_info_t *pi)
 {
 	uint16 val, mask;
 
@@ -23385,7 +23385,7 @@ static void wlc_phy_txcal_physetup_nphy(
 	}
 }
 
-static void wlc_phy_txcal_phycleanup_nphy(phy_info_t * pi)
+static void wlc_phy_txcal_phycleanup_nphy(phy_info_t *pi)
 {
 	uint16 mask;
 
@@ -23467,7 +23467,7 @@ static void wlc_phy_txcal_phycleanup_nph
 #define NPHY_TEST_TONE_FREQ_20MHz 2500
 
 void
-wlc_phy_est_tonepwr_nphy(phy_info_t * pi, int32 * qdBm_pwrbuf, uint8 num_samps)
+wlc_phy_est_tonepwr_nphy(phy_info_t *pi, int32 *qdBm_pwrbuf, uint8 num_samps)
 {
 	uint16 tssi_reg;
 	int32 temp, pwrindex[2];
@@ -23514,7 +23514,7 @@ wlc_phy_est_tonepwr_nphy(phy_info_t * pi
 				(uint32) pwrindex[1], 32, &qdBm_pwrbuf[1]);
 }
 
-static void wlc_phy_internal_cal_txgain_nphy(phy_info_t * pi)
+static void wlc_phy_internal_cal_txgain_nphy(phy_info_t *pi)
 {
 	uint16 txcal_gain[2];
 
@@ -23538,7 +23538,7 @@ static void wlc_phy_internal_cal_txgain_
 				 txcal_gain);
 }
 
-static void wlc_phy_precal_txgain_nphy(phy_info_t * pi)
+static void wlc_phy_precal_txgain_nphy(phy_info_t *pi)
 {
 	bool save_bbmult = FALSE;
 	uint8 txcal_index_2057_rev5n7 = 0;
@@ -23626,7 +23626,7 @@ static void wlc_phy_precal_txgain_nphy(p
 }
 
 void
-wlc_phy_cal_txgainctrl_nphy(phy_info_t * pi, int32 dBm_targetpower, bool debug)
+wlc_phy_cal_txgainctrl_nphy(phy_info_t *pi, int32 dBm_targetpower, bool debug)
 {
 	int gainctrl_loopidx;
 	uint core;
@@ -23793,7 +23793,7 @@ wlc_phy_cal_txgainctrl_nphy(phy_info_t *
 		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
 }
 
-static void wlc_phy_update_txcal_ladder_nphy(phy_info_t * pi, uint16 core)
+static void wlc_phy_update_txcal_ladder_nphy(phy_info_t *pi, uint16 core)
 {
 	int index;
 	uint32 bbmult_scale;
@@ -23835,7 +23835,7 @@ static void wlc_phy_update_txcal_ladder_
 	}
 }
 
-void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
+void wlc_phy_cal_perical_nphy_run(phy_info_t *pi, uint8 caltype)
 {
 	nphy_txgains_t target_gain;
 	uint8 tx_pwr_ctrl_state;
@@ -24092,7 +24092,7 @@ void wlc_phy_cal_perical_nphy_run(phy_in
 }
 
 int
-wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
+wlc_phy_cal_txiqlo_nphy(phy_info_t *pi, nphy_txgains_t target_gain,
 			bool fullcal, bool mphase)
 {
 	uint16 val;
@@ -24460,7 +24460,7 @@ wlc_phy_cal_txiqlo_nphy(phy_info_t * pi,
 	return bcmerror;
 }
 
-static void wlc_phy_reapply_txcal_coeffs_nphy(phy_info_t * pi)
+static void wlc_phy_reapply_txcal_coeffs_nphy(phy_info_t *pi)
 {
 	uint16 tbl_buf[7];
 
@@ -24497,7 +24497,7 @@ static void wlc_phy_reapply_txcal_coeffs
 	}
 }
 
-static void wlc_phy_tx_iq_war_nphy(phy_info_t * pi)
+static void wlc_phy_tx_iq_war_nphy(phy_info_t *pi)
 {
 	nphy_iq_comp_t tx_comp;
 
@@ -24510,7 +24510,7 @@ static void wlc_phy_tx_iq_war_nphy(phy_i
 }
 
 void
-wlc_phy_rx_iq_coeffs_nphy(phy_info_t * pi, uint8 write, nphy_iq_comp_t * pcomp)
+wlc_phy_rx_iq_coeffs_nphy(phy_info_t *pi, uint8 write, nphy_iq_comp_t *pcomp)
 {
 	if (write) {
 		write_phy_reg(pi, 0x9a, pcomp->a0);
@@ -24526,7 +24526,7 @@ wlc_phy_rx_iq_coeffs_nphy(phy_info_t * p
 }
 
 void
-wlc_phy_rx_iq_est_nphy(phy_info_t * pi, phy_iq_est_t * est, uint16 num_samps,
+wlc_phy_rx_iq_est_nphy(phy_info_t *pi, phy_iq_est_t *est, uint16 num_samps,
 		       uint8 wait_time, uint8 wait_for_crs)
 {
 	uint8 core;
@@ -24559,7 +24559,7 @@ wlc_phy_rx_iq_est_nphy(phy_info_t * pi,
 }
 
 #define CAL_RETRY_CNT 2
-static void wlc_phy_calc_rx_iq_comp_nphy(phy_info_t * pi, uint8 core_mask)
+static void wlc_phy_calc_rx_iq_comp_nphy(phy_info_t *pi, uint8 core_mask)
 {
 	uint8 curr_core;
 	phy_iq_est_t est[PHY_CORE_MAX];
@@ -24682,7 +24682,7 @@ static void wlc_phy_calc_rx_iq_comp_nphy
 	wlc_phy_rx_iq_coeffs_nphy(pi, 1, &new_comp);
 }
 
-static void wlc_phy_rxcal_radio_setup_nphy(phy_info_t * pi, uint8 rx_core)
+static void wlc_phy_rxcal_radio_setup_nphy(phy_info_t *pi, uint8 rx_core)
 {
 	uint16 offtune_val;
 	uint16 bias_g = 0;
@@ -24979,7 +24979,7 @@ static void wlc_phy_rxcal_radio_setup_np
 	}
 }
 
-static void wlc_phy_rxcal_radio_cleanup_nphy(phy_info_t * pi, uint8 rx_core)
+static void wlc_phy_rxcal_radio_cleanup_nphy(phy_info_t *pi, uint8 rx_core)
 {
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
 		if (rx_core == PHY_CORE_0) {
@@ -25149,7 +25149,7 @@ static void wlc_phy_rxcal_radio_cleanup_
 	}
 }
 
-static void wlc_phy_rxcal_physetup_nphy(phy_info_t * pi, uint8 rx_core)
+static void wlc_phy_rxcal_physetup_nphy(phy_info_t *pi, uint8 rx_core)
 {
 	uint8 tx_core;
 	uint16 rx_antval, tx_antval;
@@ -25276,7 +25276,7 @@ static void wlc_phy_rxcal_physetup_nphy(
 	}
 }
 
-static void wlc_phy_rxcal_phycleanup_nphy(phy_info_t * pi, uint8 rx_core)
+static void wlc_phy_rxcal_phycleanup_nphy(phy_info_t *pi, uint8 rx_core)
 {
 
 	write_phy_reg(pi, 0xa2, pi->tx_rx_cal_phy_saveregs[0]);
@@ -25303,8 +25303,8 @@ static void wlc_phy_rxcal_phycleanup_nph
 }
 
 static void
-wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rx_core,
-				 uint16 * rxgain, uint8 cal_type)
+wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t *pi, uint8 rx_core,
+				 uint16 *rxgain, uint8 cal_type)
 {
 
 	uint16 num_samps;
@@ -25511,14 +25511,14 @@ wlc_phy_rxcal_gainctrl_nphy_rev5(phy_inf
 }
 
 static void
-wlc_phy_rxcal_gainctrl_nphy(phy_info_t * pi, uint8 rx_core, uint16 * rxgain,
+wlc_phy_rxcal_gainctrl_nphy(phy_info_t *pi, uint8 rx_core, uint16 *rxgain,
 			    uint8 cal_type)
 {
 	wlc_phy_rxcal_gainctrl_nphy_rev5(pi, rx_core, rxgain, cal_type);
 }
 
 static uint8
-wlc_phy_rc_sweep_nphy(phy_info_t * pi, uint8 core_idx, uint8 loopback_type)
+wlc_phy_rc_sweep_nphy(phy_info_t *pi, uint8 core_idx, uint8 loopback_type)
 {
 	uint32 target_bws[2] = { 9500, 21000 };
 	uint32 ref_tones[2] = { 3000, 6000 };
@@ -25759,7 +25759,7 @@ wlc_phy_rc_sweep_nphy(phy_info_t * pi, u
 
 #define WAIT_FOR_SCOPE	4000000
 static int
-wlc_phy_cal_rxiq_nphy_rev3(phy_info_t * pi, nphy_txgains_t target_gain,
+wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *pi, nphy_txgains_t target_gain,
 			   uint8 cal_type, bool debug)
 {
 	uint16 orig_BBConfig;
@@ -25916,7 +25916,7 @@ wlc_phy_cal_rxiq_nphy_rev3(phy_info_t *
 }
 
 static int
-wlc_phy_cal_rxiq_nphy_rev2(phy_info_t * pi, nphy_txgains_t target_gain,
+wlc_phy_cal_rxiq_nphy_rev2(phy_info_t *pi, nphy_txgains_t target_gain,
 			   bool debug)
 {
 	phy_iq_est_t est[PHY_CORE_MAX];
@@ -26142,7 +26142,7 @@ wlc_phy_cal_rxiq_nphy_rev2(phy_info_t *
 }
 
 int
-wlc_phy_cal_rxiq_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
+wlc_phy_cal_rxiq_nphy(phy_info_t *pi, nphy_txgains_t target_gain,
 		      uint8 cal_type, bool debug)
 {
 	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
@@ -26157,7 +26157,7 @@ wlc_phy_cal_rxiq_nphy(phy_info_t * pi, n
 	}
 }
 
-static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t * pi)
+static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t *pi)
 {
 	int j, type = 2;
 	uint16 addr_offset = 0x2c5;
@@ -26168,7 +26168,7 @@ static void wlc_phy_extpa_set_tx_digi_fi
 	}
 }
 
-static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t * pi)
+static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t *pi)
 {
 	int j, type;
 	uint16 addr_offset[] = { 0x186, 0x195,
@@ -26206,7 +26206,7 @@ static void wlc_phy_ipa_set_tx_digi_filt
 	}
 }
 
-static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t * pi)
+static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t *pi)
 {
 	int j;
 
@@ -26223,7 +26223,7 @@ static void wlc_phy_ipa_restore_tx_digi_
 	}
 }
 
-static uint16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t * pi)
+static uint16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t *pi)
 {
 	uint16 m0m1;
 
@@ -26232,7 +26232,7 @@ static uint16 wlc_phy_ipa_get_bbmult_nph
 	return m0m1;
 }
 
-static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t * pi, uint8 m0, uint8 m1)
+static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t *pi, uint8 m0, uint8 m1)
 {
 	uint16 m0m1 = (uint16) ((m0 << 8) | m1);
 
@@ -26240,7 +26240,7 @@ static void wlc_phy_ipa_set_bbmult_nphy(
 	wlc_phy_table_write_nphy(pi, 15, 1, 95, 16, &m0m1);
 }
 
-static uint32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t * pi)
+static uint32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t *pi)
 {
 	uint32 *tx_pwrctrl_tbl = NULL;
 
@@ -26312,7 +26312,7 @@ static uint32 *wlc_phy_get_ipa_gaintbl_n
 }
 
 static void
-wlc_phy_papd_cal_setup_nphy(phy_info_t * pi, nphy_papd_restore_state * state,
+wlc_phy_papd_cal_setup_nphy(phy_info_t *pi, nphy_papd_restore_state *state,
 			    uint8 core)
 {
 	int32 tone_freq;
@@ -26588,7 +26588,7 @@ wlc_phy_papd_cal_setup_nphy(phy_info_t *
 }
 
 static void
-wlc_phy_papd_cal_cleanup_nphy(phy_info_t * pi, nphy_papd_restore_state * state)
+wlc_phy_papd_cal_cleanup_nphy(phy_info_t *pi, nphy_papd_restore_state *state)
 {
 	uint8 core;
 
@@ -26714,7 +26714,7 @@ wlc_phy_papd_cal_cleanup_nphy(phy_info_t
 }
 
 static void
-wlc_phy_a1_nphy(phy_info_t * pi, uint8 core, uint32 winsz, uint32 start,
+wlc_phy_a1_nphy(phy_info_t *pi, uint8 core, uint32 winsz, uint32 start,
 		uint32 end)
 {
 	uint32 *buf, *src, *dst, sz;
@@ -26770,7 +26770,7 @@ wlc_phy_a1_nphy(phy_info_t * pi, uint8 c
 }
 
 static void
-wlc_phy_a2_nphy(phy_info_t * pi, nphy_ipa_txcalgains_t * txgains,
+wlc_phy_a2_nphy(phy_info_t *pi, nphy_ipa_txcalgains_t *txgains,
 		phy_cal_mode_t cal_mode, uint8 core)
 {
 	uint16 phy_a1, phy_a2, phy_a3;
@@ -27070,7 +27070,7 @@ wlc_phy_a2_nphy(phy_info_t * pi, nphy_ip
 	}
 }
 
-static uint8 wlc_phy_a3_nphy(phy_info_t * pi, uint8 start_gain, uint8 core)
+static uint8 wlc_phy_a3_nphy(phy_info_t *pi, uint8 start_gain, uint8 core)
 {
 	int phy_a1;
 	int phy_a2;
@@ -27231,7 +27231,7 @@ static uint8 wlc_phy_a3_nphy(phy_info_t
 
 }
 
-static void wlc_phy_a4(phy_info_t * pi, bool full_cal)
+static void wlc_phy_a4(phy_info_t *pi, bool full_cal)
 {
 	nphy_ipa_txcalgains_t phy_b1[2];
 	nphy_papd_restore_state phy_b2;
@@ -27526,7 +27526,7 @@ static void wlc_phy_a4(phy_info_t * pi,
 	}
 }
 
-void wlc_phy_txpwr_fixpower_nphy(phy_info_t * pi)
+void wlc_phy_txpwr_fixpower_nphy(phy_info_t *pi)
 {
 	uint core;
 	uint32 txgain;
@@ -27684,7 +27684,7 @@ void wlc_phy_txpwr_fixpower_nphy(phy_inf
 }
 
 static void
-wlc_phy_txpwr_nphy_srom_convert(uint8 * srom_max, uint16 * pwr_offset,
+wlc_phy_txpwr_nphy_srom_convert(uint8 *srom_max, uint16 *pwr_offset,
 				uint8 tmp_max_pwr, uint8 rate_start,
 				uint8 rate_end)
 {
@@ -27702,7 +27702,7 @@ wlc_phy_txpwr_nphy_srom_convert(uint8 *
 }
 
 static void
-wlc_phy_txpwr_nphy_po_apply(uint8 * srom_max, uint8 pwr_offset,
+wlc_phy_txpwr_nphy_po_apply(uint8 *srom_max, uint8 pwr_offset,
 			    uint8 rate_start, uint8 rate_end)
 {
 	uint8 rate;
@@ -27713,7 +27713,7 @@ wlc_phy_txpwr_nphy_po_apply(uint8 * srom
 }
 
 void
-wlc_phy_ofdm_to_mcs_powers_nphy(uint8 * power, uint8 rate_mcs_start,
+wlc_phy_ofdm_to_mcs_powers_nphy(uint8 *power, uint8 rate_mcs_start,
 				uint8 rate_mcs_end, uint8 rate_ofdm_start)
 {
 	uint8 rate1, rate2;
@@ -27727,7 +27727,7 @@ wlc_phy_ofdm_to_mcs_powers_nphy(uint8 *
 }
 
 void
-wlc_phy_mcs_to_ofdm_powers_nphy(uint8 * power, uint8 rate_ofdm_start,
+wlc_phy_mcs_to_ofdm_powers_nphy(uint8 *power, uint8 rate_ofdm_start,
 				uint8 rate_ofdm_end, uint8 rate_mcs_start)
 {
 	uint8 rate1, rate2;
@@ -27740,7 +27740,7 @@ wlc_phy_mcs_to_ofdm_powers_nphy(uint8 *
 	}
 }
 
-void BCMNMIATTACHFN(wlc_phy_txpwr_apply_nphy) (phy_info_t * pi) {
+void BCMNMIATTACHFN(wlc_phy_txpwr_apply_nphy) (phy_info_t *pi) {
 	uint rate1, rate2, band_num;
 	uint8 tmp_bw40po = 0, tmp_cddpo = 0, tmp_stbcpo = 0;
 	uint8 tmp_max_pwr = 0;
@@ -27937,7 +27937,7 @@ void BCMNMIATTACHFN(wlc_phy_txpwr_apply_
 	return;
 }
 
-static void BCMATTACHFN(wlc_phy_txpwr_srom_read_ppr_nphy) (phy_info_t * pi) {
+static void BCMATTACHFN(wlc_phy_txpwr_srom_read_ppr_nphy) (phy_info_t *pi) {
 	uint16 bw40po, cddpo, stbcpo, bwduppo;
 	uint band_num;
 
@@ -28144,7 +28144,7 @@ static void BCMATTACHFN(wlc_phy_txpwr_sr
 	wlc_phy_txpwr_apply_nphy(pi);
 }
 
-static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_nphy) (phy_info_t * pi) {
+static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_nphy) (phy_info_t *pi) {
 
 	pi->antswitch = (uint8) PHY_GETINTVAR(pi, "antswitch");
 	pi->aa2g = (uint8) PHY_GETINTVAR(pi, "aa2g");
@@ -28204,7 +28204,7 @@ static bool BCMATTACHFN(wlc_phy_txpwr_sr
 	return TRUE;
 }
 
-void wlc_phy_txpower_recalc_target_nphy(phy_info_t * pi)
+void wlc_phy_txpower_recalc_target_nphy(phy_info_t *pi)
 {
 	uint8 tx_pwr_ctrl_state;
 	wlc_phy_txpwr_limit_to_tbl_nphy(pi);
@@ -28224,7 +28224,7 @@ void wlc_phy_txpower_recalc_target_nphy(
 		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, 0);
 }
 
-static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t * pi)
+static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t *pi)
 {
 	uint32 idx;
 	uint16 iqloCalbuf[7];
@@ -28295,7 +28295,7 @@ static void wlc_phy_txpwrctrl_coeff_setu
 		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
 }
 
-static void wlc_phy_ipa_internal_tssi_setup_nphy(phy_info_t * pi)
+static void wlc_phy_ipa_internal_tssi_setup_nphy(phy_info_t *pi)
 {
 	uint8 core;
 
@@ -28405,7 +28405,7 @@ static void wlc_phy_ipa_internal_tssi_se
 	}
 }
 
-static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t * pi)
+static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t *pi)
 {
 	int32 rssi_buf[4];
 	int32 int_val;
@@ -28471,7 +28471,7 @@ static void wlc_phy_txpwrctrl_idle_tssi_
 
 }
 
-static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t * pi)
+static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t *pi)
 {
 	uint32 idx;
 	int16 a1[2], b0[2], b1[2];
@@ -28708,13 +28708,13 @@ static void wlc_phy_txpwrctrl_pwr_setup_
 		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
 }
 
-static bool wlc_phy_txpwr_ison_nphy(phy_info_t * pi)
+static bool wlc_phy_txpwr_ison_nphy(phy_info_t *pi)
 {
 	return (read_phy_reg((pi), 0x1e7) & ((0x1 << 15) |
 					     (0x1 << 14) | (0x1 << 13)));
 }
 
-static uint8 wlc_phy_txpwr_idx_cur_get_nphy(phy_info_t * pi, uint8 core)
+static uint8 wlc_phy_txpwr_idx_cur_get_nphy(phy_info_t *pi, uint8 core)
 {
 	uint16 tmp;
 	tmp = read_phy_reg(pi, ((core == PHY_CORE_0) ? 0x1ed : 0x1ee));
@@ -28724,7 +28724,7 @@ static uint8 wlc_phy_txpwr_idx_cur_get_n
 }
 
 static void
-wlc_phy_txpwr_idx_cur_set_nphy(phy_info_t * pi, uint8 idx0, uint8 idx1)
+wlc_phy_txpwr_idx_cur_set_nphy(phy_info_t *pi, uint8 idx0, uint8 idx1)
 {
 	mod_phy_reg(pi, 0x1e7, (0x7f << 0), idx0);
 
@@ -28732,7 +28732,7 @@ wlc_phy_txpwr_idx_cur_set_nphy(phy_info_
 		mod_phy_reg(pi, 0x222, (0xff << 0), idx1);
 }
 
-uint16 wlc_phy_txpwr_idx_get_nphy(phy_info_t * pi)
+uint16 wlc_phy_txpwr_idx_get_nphy(phy_info_t *pi)
 {
 	uint16 tmp;
 	uint16 pwr_idx[2];
@@ -28754,7 +28754,7 @@ uint16 wlc_phy_txpwr_idx_get_nphy(phy_in
 	return tmp;
 }
 
-void wlc_phy_txpwr_papd_cal_nphy(phy_info_t * pi)
+void wlc_phy_txpwr_papd_cal_nphy(phy_info_t *pi)
 {
 	if (PHY_IPA(pi)
 	    && (pi->nphy_force_papd_cal
@@ -28770,7 +28770,7 @@ void wlc_phy_txpwr_papd_cal_nphy(phy_inf
 	}
 }
 
-void wlc_phy_txpwrctrl_enable_nphy(phy_info_t * pi, uint8 ctrl_type)
+void wlc_phy_txpwrctrl_enable_nphy(phy_info_t *pi, uint8 ctrl_type)
 {
 	uint16 mask = 0, val = 0, ishw = 0;
 	uint8 ctr;
@@ -28916,7 +28916,7 @@ void wlc_phy_txpwrctrl_enable_nphy(phy_i
 }
 
 void
-wlc_phy_txpwr_index_nphy(phy_info_t * pi, uint8 core_mask, int8 txpwrindex,
+wlc_phy_txpwr_index_nphy(phy_info_t *pi, uint8 core_mask, int8 txpwrindex,
 			 bool restore_cals)
 {
 	uint8 core, txpwrctl_tbl;
@@ -29155,7 +29155,7 @@ wlc_phy_txpwr_index_nphy(phy_info_t * pi
 }
 
 void
-wlc_phy_txpower_sromlimit_get_nphy(phy_info_t * pi, uint chan, uint8 * max_pwr,
+wlc_phy_txpower_sromlimit_get_nphy(phy_info_t *pi, uint chan, uint8 *max_pwr,
 				   uint8 txp_rate_idx)
 {
 	uint8 chan_freq_range;
@@ -29183,7 +29183,7 @@ wlc_phy_txpower_sromlimit_get_nphy(phy_i
 	return;
 }
 
-void wlc_phy_stay_in_carriersearch_nphy(phy_info_t * pi, bool enable)
+void wlc_phy_stay_in_carriersearch_nphy(phy_info_t *pi, bool enable)
 {
 	uint16 clip_off[] = { 0xffff, 0xffff };
 
@@ -29215,7 +29215,7 @@ void wlc_phy_stay_in_carriersearch_nphy(
 	}
 }
 
-void wlc_nphy_deaf_mode(phy_info_t * pi, bool mode)
+void wlc_nphy_deaf_mode(phy_info_t *pi, bool mode)
 {
 	wlapi_suspend_mac_and_wait(pi->sh->physhim);
 
--- a/drivers/staging/brcm80211/sys/wl_export.h
+++ b/drivers/staging/brcm80211/sys/wl_export.h
@@ -26,9 +26,9 @@ extern uint wl_reset(struct wl_info *wl)
 extern void wl_intrson(struct wl_info *wl);
 extern uint32 wl_intrsoff(struct wl_info *wl);
 extern void wl_intrsrestore(struct wl_info *wl, uint32 macintmask);
-extern void wl_event(struct wl_info *wl, char *ifname, wlc_event_t * e);
-extern void wl_event_sendup(struct wl_info *wl, const wlc_event_t * e,
-			    uint8 * data, uint32 len);
+extern void wl_event(struct wl_info *wl, char *ifname, wlc_event_t *e);
+extern void wl_event_sendup(struct wl_info *wl, const wlc_event_t *e,
+			    uint8 *data, uint32 len);
 extern int wl_up(struct wl_info *wl);
 extern void wl_down(struct wl_info *wl);
 extern void wl_txflowcontrol(struct wl_info *wl, struct wl_if *wlif, bool state,
@@ -45,10 +45,10 @@ extern void wl_add_timer(struct wl_info
 			 int periodic);
 extern bool wl_del_timer(struct wl_info *wl, struct wl_timer *timer);
 
-extern uint wl_buf_to_pktcopy(osl_t * osh, void *p, uchar * buf, int len,
+extern uint wl_buf_to_pktcopy(osl_t *osh, void *p, uchar *buf, int len,
 			      uint offset);
-extern void *wl_get_pktbuffer(osl_t * osh, int len);
-extern int wl_set_pktlen(osl_t * osh, void *p, int len);
+extern void *wl_get_pktbuffer(osl_t *osh, int len);
+extern int wl_set_pktlen(osl_t *osh, void *p, int len);
 
 #define wl_sort_bsslist(a, b) FALSE
 
@@ -59,5 +59,5 @@ extern int wl_tkip_encrypt(struct wl_inf
 extern int wl_tkip_decrypt(struct wl_info *wl, void *p, int hdr_len,
 			   bool group_key);
 extern void wl_tkip_printstats(struct wl_info *wl, bool group_key);
-extern int wl_tkip_keyset(struct wl_info *wl, wsec_key_t * key);
+extern int wl_tkip_keyset(struct wl_info *wl, wsec_key_t *key);
 #endif				/* _wl_export_h_ */
--- a/drivers/staging/brcm80211/sys/wl_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.c
@@ -82,20 +82,20 @@
 extern struct device *sdiommc_dev;
 #endif
 
-extern void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg,
+extern void wlc_wme_setparams(wlc_info_t *wlc, u16 aci, void *arg,
 			      bool suspend);
-bool wlc_sendpkt_mac80211(wlc_info_t * wlc, void *sdu, struct ieee80211_hw *hw);
-void wlc_mac_bcn_promisc_change(wlc_info_t * wlc, bool promisc);
-void wlc_set_addrmatch(wlc_info_t * wlc, int match_reg_offset,
+bool wlc_sendpkt_mac80211(wlc_info_t *wlc, void *sdu, struct ieee80211_hw *hw);
+void wlc_mac_bcn_promisc_change(wlc_info_t *wlc, bool promisc);
+void wlc_set_addrmatch(wlc_info_t *wlc, int match_reg_offset,
 		       const struct ether_addr *addr);
 
 static void wl_timer(ulong data);
-static void _wl_timer(wl_timer_t * t);
+static void _wl_timer(wl_timer_t *t);
 
 /* proc fs */
 static int wl_proc_read(char *buffer, char **start, off_t offset, int length,
 			int *eof, void *data);
-static int wl_proc_write(struct file *filp, const char __user * buff,
+static int wl_proc_write(struct file *filp, const char __user *buff,
 			 unsigned long len, void *data);
 
 #ifdef WLC_HIGH_ONLY
@@ -104,13 +104,13 @@ static int wl_proc_write(struct file *fi
 #define TXQ_LOCK(_wl, _flags) spin_lock_irqsave(&(_wl)->txq_lock, (_flags))
 #define TXQ_UNLOCK(_wl, _flags)  spin_unlock_irqrestore(&(_wl)->txq_lock, (_flags))
 static void wl_rpc_down(void *wlh);
-static void wl_rpcq_free(wl_info_t * wl);
+static void wl_rpcq_free(wl_info_t *wl);
 static void wl_rpcq_dispatch(struct wl_task *task);
 static void wl_rpc_dispatch_schedule(void *ctx, struct rpc_buf *buf);
 static void wl_start_txqwork(struct wl_task *task);
-static void wl_txq_free(wl_info_t * wl);
-static void wl_timer_task(wl_task_t * task);
-static int wl_schedule_task(wl_info_t * wl, void (*fn) (struct wl_task *),
+static void wl_txq_free(wl_info_t *wl);
+static void wl_timer_task(wl_task_t *task);
+static int wl_schedule_task(wl_info_t *wl, void (*fn) (struct wl_task *),
 			    void *context);
 #endif				/* WLC_HIGH_ONLY */
 
@@ -162,13 +162,13 @@ struct ieee80211_tkip_data {
 
 #ifndef WLC_HIGH_ONLY
 #define	WL_INFO(dev)		((wl_info_t*)(WL_DEV_IF(dev)->wl))	/* points to wl */
-static int wl_request_fw(wl_info_t * wl, struct pci_dev *pdev);
-static void wl_release_fw(wl_info_t * wl);
+static int wl_request_fw(wl_info_t *wl, struct pci_dev *pdev);
+static void wl_release_fw(wl_info_t *wl);
 #endif
 
 /* local prototypes */
-static int wl_start(struct sk_buff *skb, wl_info_t * wl);
-static int wl_start_int(wl_info_t * wl, struct ieee80211_hw *hw,
+static int wl_start(struct sk_buff *skb, wl_info_t *wl);
+static int wl_start_int(wl_info_t *wl, struct ieee80211_hw *hw,
 			struct sk_buff *skb);
 static void wl_dpc(ulong data);
 
@@ -271,7 +271,7 @@ static int wl_sta_remove(struct ieee8021
 			 struct ieee80211_sta *sta);
 static int wl_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			   enum ieee80211_ampdu_mlme_action action,
-			   struct ieee80211_sta *sta, u16 tid, u16 * ssn);
+			   struct ieee80211_sta *sta, u16 tid, u16 *ssn);
 
 #ifdef WLC_HIGH_ONLY
 static int wl_ops_tx_nl(struct ieee80211_hw *hw, struct sk_buff *skb)
@@ -703,7 +703,7 @@ static int
 wl_ampdu_action(struct ieee80211_hw *hw,
 		struct ieee80211_vif *vif,
 		enum ieee80211_ampdu_mlme_action action,
-		struct ieee80211_sta *sta, u16 tid, u16 * ssn)
+		struct ieee80211_sta *sta, u16 tid, u16 *ssn)
 {
 #if defined(BCMDBG)
 	struct scb *scb = (struct scb *)sta->drv_priv;
@@ -771,7 +771,7 @@ static const struct ieee80211_ops wl_ops
 	.ampdu_action = wl_ampdu_action,
 };
 
-static int wl_set_hint(wl_info_t * wl, char *abbrev)
+static int wl_set_hint(wl_info_t *wl, char *abbrev)
 {
 	WL_ERROR(("%s: Sending country code %c%c to MAC80211\n", __func__,
 		  abbrev[0], abbrev[1]));
@@ -1071,7 +1071,7 @@ wl_proc_read(char *buffer, char **start,
 
 /* OS Entry point when app attempts to write */
 static int
-wl_proc_write(struct file *filp, const char __user * buff, unsigned long length,
+wl_proc_write(struct file *filp, const char __user *buff, unsigned long length,
 	      void *data)
 {
 	wl_info_t *wl = (wl_info_t *) data;
@@ -1702,7 +1702,7 @@ module_exit(wl_module_exit);
  * by the wl parameter.
  *
  */
-void wl_free(wl_info_t * wl)
+void wl_free(wl_info_t *wl)
 {
 	wl_timer_t *t, *next;
 	osl_t *osh;
@@ -1790,7 +1790,7 @@ void wl_free(wl_info_t * wl)
 
 #ifdef WLC_LOW
 /* transmit a packet */
-static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t * wl)
+static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t *wl)
 {
 	if (!wl)
 		return -ENETDOWN;
@@ -1800,7 +1800,7 @@ static int BCMFASTPATH wl_start(struct s
 #endif				/* WLC_LOW */
 
 static int BCMFASTPATH
-wl_start_int(wl_info_t * wl, struct ieee80211_hw *hw, struct sk_buff *skb)
+wl_start_int(wl_info_t *wl, struct ieee80211_hw *hw, struct sk_buff *skb)
 {
 #ifdef WLC_HIGH_ONLY
 	WL_LOCK(wl);
@@ -1812,7 +1812,7 @@ wl_start_int(wl_info_t * wl, struct ieee
 	return (NETDEV_TX_OK);
 }
 
-void wl_txflowcontrol(wl_info_t * wl, struct wl_if *wlif, bool state, int prio)
+void wl_txflowcontrol(wl_info_t *wl, struct wl_if *wlif, bool state, int prio)
 {
 	WL_ERROR(("Shouldn't be here %s\n", __func__));
 }
@@ -1820,7 +1820,7 @@ void wl_txflowcontrol(wl_info_t * wl, st
 #if defined(WLC_HIGH_ONLY)
 /* Schedule a completion handler to run at safe time */
 static int
-wl_schedule_task(wl_info_t * wl, void (*fn) (struct wl_task * task),
+wl_schedule_task(wl_info_t *wl, void (*fn) (struct wl_task *task),
 		 void *context)
 {
 	wl_task_t *task;
@@ -1847,7 +1847,7 @@ wl_schedule_task(wl_info_t * wl, void (*
 }
 #endif				/* defined(WLC_HIGH_ONLY) */
 
-void wl_init(wl_info_t * wl)
+void wl_init(wl_info_t *wl)
 {
 	WL_TRACE(("wl%d: wl_init\n", wl->pub->unit));
 
@@ -1856,7 +1856,7 @@ void wl_init(wl_info_t * wl)
 	wlc_init(wl->wlc);
 }
 
-uint wl_reset(wl_info_t * wl)
+uint wl_reset(wl_info_t *wl)
 {
 	WL_TRACE(("wl%d: wl_reset\n", wl->pub->unit));
 
@@ -1872,7 +1872,7 @@ uint wl_reset(wl_info_t * wl)
  * These are interrupt on/off entry points. Disable interrupts
  * during interrupt state transition.
  */
-void BCMFASTPATH wl_intrson(wl_info_t * wl)
+void BCMFASTPATH wl_intrson(wl_info_t *wl)
 {
 #if defined(WLC_LOW)
 	unsigned long flags;
@@ -1883,12 +1883,12 @@ void BCMFASTPATH wl_intrson(wl_info_t *
 #endif				/* WLC_LOW */
 }
 
-bool wl_alloc_dma_resources(wl_info_t * wl, uint addrwidth)
+bool wl_alloc_dma_resources(wl_info_t *wl, uint addrwidth)
 {
 	return TRUE;
 }
 
-uint32 BCMFASTPATH wl_intrsoff(wl_info_t * wl)
+uint32 BCMFASTPATH wl_intrsoff(wl_info_t *wl)
 {
 #if defined(WLC_LOW)
 	unsigned long flags;
@@ -1903,7 +1903,7 @@ uint32 BCMFASTPATH wl_intrsoff(wl_info_t
 #endif				/* WLC_LOW */
 }
 
-void wl_intrsrestore(wl_info_t * wl, uint32 macintmask)
+void wl_intrsrestore(wl_info_t *wl, uint32 macintmask)
 {
 #if defined(WLC_LOW)
 	unsigned long flags;
@@ -1914,7 +1914,7 @@ void wl_intrsrestore(wl_info_t * wl, uin
 #endif				/* WLC_LOW */
 }
 
-int wl_up(wl_info_t * wl)
+int wl_up(wl_info_t *wl)
 {
 	int error = 0;
 
@@ -1926,7 +1926,7 @@ int wl_up(wl_info_t * wl)
 	return (error);
 }
 
-void wl_down(wl_info_t * wl)
+void wl_down(wl_info_t *wl)
 {
 	uint callbacks, ret_val = 0;
 
@@ -2017,17 +2017,17 @@ static void BCMFASTPATH wl_dpc(ulong dat
 #endif				/* WLC_LOW */
 }
 
-static void wl_link_up(wl_info_t * wl, char *ifname)
+static void wl_link_up(wl_info_t *wl, char *ifname)
 {
 	WL_ERROR(("wl%d: link up (%s)\n", wl->pub->unit, ifname));
 }
 
-static void wl_link_down(wl_info_t * wl, char *ifname)
+static void wl_link_down(wl_info_t *wl, char *ifname)
 {
 	WL_ERROR(("wl%d: link down (%s)\n", wl->pub->unit, ifname));
 }
 
-void wl_event(wl_info_t * wl, char *ifname, wlc_event_t * e)
+void wl_event(wl_info_t *wl, char *ifname, wlc_event_t *e)
 {
 
 	switch (e->event.event_type) {
@@ -2053,7 +2053,7 @@ static void wl_timer(ulong data)
 #endif				/* WLC_HIGH_ONLY */
 }
 
-static void _wl_timer(wl_timer_t * t)
+static void _wl_timer(wl_timer_t *t)
 {
 	WL_LOCK(t->wl);
 
@@ -2074,7 +2074,7 @@ static void _wl_timer(wl_timer_t * t)
 	WL_UNLOCK(t->wl);
 }
 
-wl_timer_t *wl_init_timer(wl_info_t * wl, void (*fn) (void *arg), void *arg,
+wl_timer_t *wl_init_timer(wl_info_t *wl, void (*fn) (void *arg), void *arg,
 			  const char *name)
 {
 	wl_timer_t *t;
@@ -2106,7 +2106,7 @@ wl_timer_t *wl_init_timer(wl_info_t * wl
 /* BMAC_NOTE: Add timer adds only the kernel timer since it's going to be more accurate
  * as well as it's easier to make it periodic
  */
-void wl_add_timer(wl_info_t * wl, wl_timer_t * t, uint ms, int periodic)
+void wl_add_timer(wl_info_t *wl, wl_timer_t *t, uint ms, int periodic)
 {
 #ifdef BCMDBG
 	if (t->set) {
@@ -2126,7 +2126,7 @@ void wl_add_timer(wl_info_t * wl, wl_tim
 }
 
 /* return TRUE if timer successfully deleted, FALSE if still pending */
-bool wl_del_timer(wl_info_t * wl, wl_timer_t * t)
+bool wl_del_timer(wl_info_t *wl, wl_timer_t *t)
 {
 	if (t->set) {
 		t->set = FALSE;
@@ -2139,7 +2139,7 @@ bool wl_del_timer(wl_info_t * wl, wl_tim
 	return TRUE;
 }
 
-void wl_free_timer(wl_info_t * wl, wl_timer_t * t)
+void wl_free_timer(wl_info_t *wl, wl_timer_t *t)
 {
 	wl_timer_t *tmp;
 
@@ -2225,7 +2225,7 @@ static void wl_rpc_down(void *wlh)
 	wl_rpcq_free(wl);
 }
 
-static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t * wl)
+static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t *wl)
 {
 
 	ulong flags;
@@ -2302,7 +2302,7 @@ static void wl_start_txqwork(struct wl_t
 	return;
 }
 
-static void wl_txq_free(wl_info_t * wl)
+static void wl_txq_free(wl_info_t *wl)
 {
 	struct sk_buff *skb;
 
@@ -2320,7 +2320,7 @@ static void wl_txq_free(wl_info_t * wl)
 	wl->txq_tail = NULL;
 }
 
-static void wl_rpcq_free(wl_info_t * wl)
+static void wl_rpcq_free(wl_info_t *wl)
 {
 	rpc_buf_t *buf;
 
@@ -2369,7 +2369,7 @@ static void wl_rpcq_dispatch(struct wl_t
 	atomic_dec(&wl->callbacks);
 }
 
-static void wl_rpcq_add(wl_info_t * wl, rpc_buf_t * buf)
+static void wl_rpcq_add(wl_info_t *wl, rpc_buf_t *buf)
 {
 	ulong flags;
 
@@ -2420,7 +2420,7 @@ static void wl_rpc_dispatch_schedule(voi
 	}
 }
 
-static void wl_timer_task(wl_task_t * task)
+static void wl_timer_task(wl_task_t *task)
 {
 	wl_timer_t *t = (wl_timer_t *) task->context;
 
@@ -2441,7 +2441,7 @@ char *wl_firmwares[WL_MAX_FW] = {
 };
 
 #ifdef WLC_LOW
-int wl_ucode_init_buf(wl_info_t * wl, void **pbuf, uint32 idx)
+int wl_ucode_init_buf(wl_info_t *wl, void **pbuf, uint32 idx)
 {
 	int i, entry;
 	const uint8 *pdata;
@@ -2467,7 +2467,7 @@ int wl_ucode_init_buf(wl_info_t * wl, vo
 	return -1;
 }
 
-int wl_ucode_init_uint(wl_info_t * wl, uint32 * data, uint32 idx)
+int wl_ucode_init_uint(wl_info_t *wl, uint32 *data, uint32 idx)
 {
 	int i, entry;
 	const uint8 *pdata;
@@ -2489,7 +2489,7 @@ int wl_ucode_init_uint(wl_info_t * wl, u
 }
 #endif				/* WLC_LOW */
 
-static int wl_request_fw(wl_info_t * wl, struct pci_dev *pdev)
+static int wl_request_fw(wl_info_t *wl, struct pci_dev *pdev)
 {
 	int status;
 	struct device *device = &pdev->dev;
@@ -2535,7 +2535,7 @@ void wl_ucode_free_buf(void *p)
 }
 #endif				/* WLC_LOW */
 
-static void wl_release_fw(wl_info_t * wl)
+static void wl_release_fw(wl_info_t *wl)
 {
 	int i;
 	for (i = 0; i < WL_MAX_FW; i++) {
--- a/drivers/staging/brcm80211/sys/wl_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.h
@@ -158,14 +158,14 @@ extern irqreturn_t wl_isr(int irq, void
 
 extern int __devinit wl_pci_probe(struct pci_dev *pdev,
 				  const struct pci_device_id *ent);
-extern void wl_free(wl_info_t * wl);
+extern void wl_free(wl_info_t *wl);
 extern int wl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
-extern int wl_ucode_data_init(wl_info_t * wl);
+extern int wl_ucode_data_init(wl_info_t *wl);
 extern void wl_ucode_data_free(void);
 #ifdef WLC_LOW
 extern void wl_ucode_free_buf(void *);
-extern int wl_ucode_init_buf(wl_info_t * wl, void **pbuf, uint32 idx);
-extern int wl_ucode_init_uint(wl_info_t * wl, uint32 * data, uint32 idx);
+extern int wl_ucode_init_buf(wl_info_t *wl, void **pbuf, uint32 idx);
+extern int wl_ucode_init_uint(wl_info_t *wl, uint32 *data, uint32 idx);
 #endif				/* WLC_LOW */
 
 #endif				/* _wl_mac80211_h_ */
--- a/drivers/staging/brcm80211/sys/wl_ucode_loader.c
+++ b/drivers/staging/brcm80211/sys/wl_ucode_loader.c
@@ -19,9 +19,9 @@ typedef struct wl_info wl_info_t;
 #include <d11ucode_ext.h>
 #include <wl_ucode.h>
 
-extern int wl_ucode_init_buf(wl_info_t * wl, void **pbuf, unsigned int idx);
-extern int wl_ucode_init_uint(wl_info_t * wl, unsigned *data, unsigned int idx);
-extern int wl_ucode_data_init(wl_info_t * wl);
+extern int wl_ucode_init_buf(wl_info_t *wl, void **pbuf, unsigned int idx);
+extern int wl_ucode_init_uint(wl_info_t *wl, unsigned *data, unsigned int idx);
+extern int wl_ucode_data_init(wl_info_t *wl);
 extern void wl_ucode_data_free(void);
 extern void wl_ucode_free_buf(void *);
 
@@ -41,7 +41,7 @@ uint32 bcm43xx_24_lcnsz;
 uint32 *bcm43xx_bommajor;
 uint32 *bcm43xx_bomminor;
 
-int wl_ucode_data_init(wl_info_t * wl)
+int wl_ucode_data_init(wl_info_t *wl)
 {
 	wl_ucode_init_buf(wl, (void **)&d11lcn0bsinitvals24,
 			  D11LCN0BSINITVALS24);
--- a/drivers/staging/brcm80211/sys/wlc_alloc.c
+++ b/drivers/staging/brcm80211/sys/wlc_alloc.c
@@ -33,12 +33,12 @@
 #include <wlc_mac80211.h>
 #include <wlc_alloc.h>
 
-static wlc_pub_t *wlc_pub_malloc(osl_t * osh, uint unit, uint * err,
+static wlc_pub_t *wlc_pub_malloc(osl_t *osh, uint unit, uint *err,
 				 uint devid);
-static void wlc_pub_mfree(osl_t * osh, wlc_pub_t * pub);
-static void wlc_tunables_init(wlc_tunables_t * tunables, uint devid);
+static void wlc_pub_mfree(osl_t *osh, wlc_pub_t *pub);
+static void wlc_tunables_init(wlc_tunables_t *tunables, uint devid);
 
-void *wlc_calloc(osl_t * osh, uint unit, uint size)
+void *wlc_calloc(osl_t *osh, uint unit, uint size)
 {
 	void *item;
 
@@ -50,7 +50,7 @@ void *wlc_calloc(osl_t * osh, uint unit,
 	return item;
 }
 
-void BCMATTACHFN(wlc_tunables_init) (wlc_tunables_t * tunables, uint devid) {
+void BCMATTACHFN(wlc_tunables_init) (wlc_tunables_t *tunables, uint devid) {
 	tunables->ntxd = NTXD;
 	tunables->nrxd = NRXD;
 	tunables->rxbufsz = RXBUFSZ;
@@ -72,8 +72,8 @@ void BCMATTACHFN(wlc_tunables_init) (wlc
 #endif				/* WLC_HIGH_ONLY */
 }
 
-static wlc_pub_t *BCMATTACHFN(wlc_pub_malloc) (osl_t * osh, uint unit,
-					       uint * err, uint devid) {
+static wlc_pub_t *BCMATTACHFN(wlc_pub_malloc) (osl_t *osh, uint unit,
+					       uint *err, uint devid) {
 	wlc_pub_t *pub;
 
 	if ((pub =
@@ -105,7 +105,7 @@ static wlc_pub_t *BCMATTACHFN(wlc_pub_ma
 	return NULL;
 }
 
-static void BCMATTACHFN(wlc_pub_mfree) (osl_t * osh, wlc_pub_t * pub) {
+static void BCMATTACHFN(wlc_pub_mfree) (osl_t *osh, wlc_pub_t *pub) {
 	if (pub == NULL)
 		return;
 
@@ -121,7 +121,7 @@ static void BCMATTACHFN(wlc_pub_mfree) (
 	MFREE(osh, pub, sizeof(wlc_pub_t));
 }
 
-wlc_bsscfg_t *wlc_bsscfg_malloc(osl_t * osh, uint unit)
+wlc_bsscfg_t *wlc_bsscfg_malloc(osl_t *osh, uint unit)
 {
 	wlc_bsscfg_t *cfg;
 
@@ -141,7 +141,7 @@ wlc_bsscfg_t *wlc_bsscfg_malloc(osl_t *
 	return NULL;
 }
 
-void wlc_bsscfg_mfree(osl_t * osh, wlc_bsscfg_t * cfg)
+void wlc_bsscfg_mfree(osl_t *osh, wlc_bsscfg_t *cfg)
 {
 	if (cfg == NULL)
 		return;
@@ -165,7 +165,7 @@ void wlc_bsscfg_mfree(osl_t * osh, wlc_b
 	MFREE(osh, cfg, sizeof(wlc_bsscfg_t));
 }
 
-void wlc_bsscfg_ID_assign(wlc_info_t * wlc, wlc_bsscfg_t * bsscfg)
+void wlc_bsscfg_ID_assign(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg)
 {
 	bsscfg->ID = wlc->next_bsscfg_ID;
 	wlc->next_bsscfg_ID++;
@@ -174,7 +174,7 @@ void wlc_bsscfg_ID_assign(wlc_info_t * w
 /*
  * The common driver entry routine. Error codes should be unique
  */
-wlc_info_t *BCMATTACHFN(wlc_attach_malloc) (osl_t * osh, uint unit, uint * err,
+wlc_info_t *BCMATTACHFN(wlc_attach_malloc) (osl_t *osh, uint unit, uint *err,
 					    uint devid) {
 	wlc_info_t *wlc;
 
@@ -305,7 +305,7 @@ wlc_info_t *BCMATTACHFN(wlc_attach_mallo
 	return NULL;
 }
 
-void BCMATTACHFN(wlc_detach_mfree) (wlc_info_t * wlc, osl_t * osh) {
+void BCMATTACHFN(wlc_detach_mfree) (wlc_info_t *wlc, osl_t *osh) {
 	if (wlc == NULL)
 		return;
 
--- a/drivers/staging/brcm80211/sys/wlc_alloc.h
+++ b/drivers/staging/brcm80211/sys/wlc_alloc.h
@@ -14,12 +14,12 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-extern void *wlc_calloc(osl_t * osh, uint unit, uint size);
+extern void *wlc_calloc(osl_t *osh, uint unit, uint size);
 
-extern wlc_info_t *wlc_attach_malloc(osl_t * osh, uint unit, uint * err,
+extern wlc_info_t *wlc_attach_malloc(osl_t *osh, uint unit, uint *err,
 				     uint devid);
-extern void wlc_detach_mfree(wlc_info_t * wlc, osl_t * osh);
+extern void wlc_detach_mfree(wlc_info_t *wlc, osl_t *osh);
 
 struct wlc_bsscfg;
-extern struct wlc_bsscfg *wlc_bsscfg_malloc(osl_t * osh, uint unit);
-extern void wlc_bsscfg_mfree(osl_t * osh, struct wlc_bsscfg *cfg);
+extern struct wlc_bsscfg *wlc_bsscfg_malloc(osl_t *osh, uint unit);
+extern void wlc_bsscfg_mfree(osl_t *osh, struct wlc_bsscfg *cfg);
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.c
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -140,27 +140,27 @@ struct ampdu_info {
 #define SCB_AMPDU_CUBBY(ampdu, scb) (&(scb->scb_ampdu))
 #define SCB_AMPDU_INI(scb_ampdu, tid) (&(scb_ampdu->ini[tid]))
 
-static void wlc_ffpld_init(ampdu_info_t * ampdu);
-static int wlc_ffpld_check_txfunfl(wlc_info_t * wlc, int f);
-static void wlc_ffpld_calc_mcs2ampdu_table(ampdu_info_t * ampdu, int f);
+static void wlc_ffpld_init(ampdu_info_t *ampdu);
+static int wlc_ffpld_check_txfunfl(wlc_info_t *wlc, int f);
+static void wlc_ffpld_calc_mcs2ampdu_table(ampdu_info_t *ampdu, int f);
 
-static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t * ampdu,
-						   scb_ampdu_t * scb_ampdu,
+static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t *ampdu,
+						   scb_ampdu_t *scb_ampdu,
 						   uint8 tid, bool override);
-static void ampdu_cleanup_tid_ini(ampdu_info_t * ampdu, scb_ampdu_t * scb_ampdu,
+static void ampdu_cleanup_tid_ini(ampdu_info_t *ampdu, scb_ampdu_t *scb_ampdu,
 				  uint8 tid, bool force);
-static void ampdu_update_max_txlen(ampdu_info_t * ampdu, uint8 dur);
-static void scb_ampdu_update_config(ampdu_info_t * ampdu, struct scb *scb);
-static void scb_ampdu_update_config_all(ampdu_info_t * ampdu);
+static void ampdu_update_max_txlen(ampdu_info_t *ampdu, uint8 dur);
+static void scb_ampdu_update_config(ampdu_info_t *ampdu, struct scb *scb);
+static void scb_ampdu_update_config_all(ampdu_info_t *ampdu);
 
 #define wlc_ampdu_txflowcontrol(a, b, c)	do {} while (0)
 
-static void wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb,
-					  void *p, tx_status_t * txs,
+static void wlc_ampdu_dotxstatus_complete(ampdu_info_t *ampdu, struct scb *scb,
+					  void *p, tx_status_t *txs,
 					  uint32 frmtxstatus,
 					  uint32 frmtxstatus2);
 
-static INLINE uint16 pkt_txh_seqnum(wlc_info_t * wlc, void *p)
+static INLINE uint16 pkt_txh_seqnum(wlc_info_t *wlc, void *p)
 {
 	d11txh_t *txh;
 	struct dot11_header *h;
@@ -169,7 +169,7 @@ static INLINE uint16 pkt_txh_seqnum(wlc_
 	return (ltoh16(h->seq) >> SEQNUM_SHIFT);
 }
 
-ampdu_info_t *BCMATTACHFN(wlc_ampdu_attach) (wlc_info_t * wlc) {
+ampdu_info_t *BCMATTACHFN(wlc_ampdu_attach) (wlc_info_t *wlc) {
 	ampdu_info_t *ampdu;
 	int i;
 
@@ -239,7 +239,7 @@ ampdu_info_t *BCMATTACHFN(wlc_ampdu_atta
 	return ampdu;
 }
 
-void BCMATTACHFN(wlc_ampdu_detach) (ampdu_info_t * ampdu) {
+void BCMATTACHFN(wlc_ampdu_detach) (ampdu_info_t *ampdu) {
 	int i;
 
 	if (!ampdu)
@@ -257,7 +257,7 @@ void BCMATTACHFN(wlc_ampdu_detach) (ampd
 	MFREE(ampdu->wlc->osh, ampdu, sizeof(ampdu_info_t));
 }
 
-void scb_ampdu_cleanup(ampdu_info_t * ampdu, struct scb *scb)
+void scb_ampdu_cleanup(ampdu_info_t *ampdu, struct scb *scb)
 {
 	scb_ampdu_t *scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
 	uint8 tid;
@@ -273,12 +273,12 @@ void scb_ampdu_cleanup(ampdu_info_t * am
 /* reset the ampdu state machine so that it can gracefully handle packets that were
  * freed from the dma and tx queues during reinit
  */
-void wlc_ampdu_reset(ampdu_info_t * ampdu)
+void wlc_ampdu_reset(ampdu_info_t *ampdu)
 {
 	WL_NONE(("%s: Entering\n", __func__));
 }
 
-static void scb_ampdu_update_config(ampdu_info_t * ampdu, struct scb *scb)
+static void scb_ampdu_update_config(ampdu_info_t *ampdu, struct scb *scb)
 {
 	scb_ampdu_t *scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
 	int i;
@@ -308,12 +308,12 @@ static void scb_ampdu_update_config(ampd
 	ASSERT(scb_ampdu->release);
 }
 
-void scb_ampdu_update_config_all(ampdu_info_t * ampdu)
+void scb_ampdu_update_config_all(ampdu_info_t *ampdu)
 {
 	scb_ampdu_update_config(ampdu, ampdu->wlc->pub->global_scb);
 }
 
-static void wlc_ffpld_init(ampdu_info_t * ampdu)
+static void wlc_ffpld_init(ampdu_info_t *ampdu)
 {
 	int i, j;
 	wlc_fifo_info_t *fifo;
@@ -337,7 +337,7 @@ static void wlc_ffpld_init(ampdu_info_t
  * Return 1 if pre-loading not active, -1 if not an underflow event,
  * 0 if pre-loading module took care of the event.
  */
-static int wlc_ffpld_check_txfunfl(wlc_info_t * wlc, int fid)
+static int wlc_ffpld_check_txfunfl(wlc_info_t *wlc, int fid)
 {
 	ampdu_info_t *ampdu = wlc->ampdu;
 	uint32 phy_rate = MCS_RATE(FFPLD_MAX_MCS, TRUE, FALSE);
@@ -457,7 +457,7 @@ static int wlc_ffpld_check_txfunfl(wlc_i
 	return 0;
 }
 
-static void wlc_ffpld_calc_mcs2ampdu_table(ampdu_info_t * ampdu, int f)
+static void wlc_ffpld_calc_mcs2ampdu_table(ampdu_info_t *ampdu, int f)
 {
 	int i;
 	uint32 phy_rate, dma_rate, tmp;
@@ -490,7 +490,7 @@ static void wlc_ffpld_calc_mcs2ampdu_tab
 }
 
 static void BCMFASTPATH
-wlc_ampdu_agg(ampdu_info_t * ampdu, struct scb *scb, void *p, uint prec)
+wlc_ampdu_agg(ampdu_info_t *ampdu, struct scb *scb, void *p, uint prec)
 {
 	scb_ampdu_t *scb_ampdu;
 	scb_ampdu_tid_ini_t *ini;
@@ -507,7 +507,7 @@ wlc_ampdu_agg(ampdu_info_t * ampdu, stru
 }
 
 int BCMFASTPATH
-wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
+wlc_sendampdu(ampdu_info_t *ampdu, wlc_txq_info_t *qi, void **pdu, int prec)
 {
 	wlc_info_t *wlc;
 	osl_t *osh;
@@ -913,8 +913,8 @@ wlc_sendampdu(ampdu_info_t * ampdu, wlc_
 }
 
 void BCMFASTPATH
-wlc_ampdu_dotxstatus(ampdu_info_t * ampdu, struct scb *scb, void *p,
-		     tx_status_t * txs)
+wlc_ampdu_dotxstatus(ampdu_info_t *ampdu, struct scb *scb, void *p,
+		     tx_status_t *txs)
 {
 	scb_ampdu_t *scb_ampdu;
 	wlc_info_t *wlc = ampdu->wlc;
@@ -974,7 +974,7 @@ wlc_ampdu_dotxstatus(ampdu_info_t * ampd
 }
 
 #ifdef WLC_HIGH_ONLY
-void wlc_ampdu_txstatus_complete(ampdu_info_t * ampdu, uint32 s1, uint32 s2)
+void wlc_ampdu_txstatus_complete(ampdu_info_t *ampdu, uint32 s1, uint32 s2)
 {
 	WL_AMPDU_TX(("wl%d: wlc_ampdu_txstatus_complete: High Recvd 0x%x 0x%x p:%p\n", ampdu->wlc->pub->unit, s1, s2, ampdu->p));
 
@@ -998,12 +998,12 @@ void wlc_ampdu_txstatus_complete(ampdu_i
 	ampdu->waiting_status = FALSE;
 }
 #endif				/* WLC_HIGH_ONLY */
-void rate_status(wlc_info_t * wlc, struct ieee80211_tx_info *tx_info,
-		 tx_status_t * txs, uint8 mcs);
+void rate_status(wlc_info_t *wlc, struct ieee80211_tx_info *tx_info,
+		 tx_status_t *txs, uint8 mcs);
 
 void
-rate_status(wlc_info_t * wlc, struct ieee80211_tx_info *tx_info,
-	    tx_status_t * txs, uint8 mcs)
+rate_status(wlc_info_t *wlc, struct ieee80211_tx_info *tx_info,
+	    tx_status_t *txs, uint8 mcs)
 {
 	struct ieee80211_tx_rate *txrate = tx_info->status.rates;
 	int i;
@@ -1015,14 +1015,14 @@ rate_status(wlc_info_t * wlc, struct iee
 	}
 }
 
-extern void wlc_txq_enq(wlc_info_t * wlc, struct scb *scb, void *sdu,
+extern void wlc_txq_enq(wlc_info_t *wlc, struct scb *scb, void *sdu,
 			uint prec);
 
 #define SHORTNAME "AMPDU status"
 
 static void BCMFASTPATH
-wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
-			      tx_status_t * txs, uint32 s1, uint32 s2)
+wlc_ampdu_dotxstatus_complete(ampdu_info_t *ampdu, struct scb *scb, void *p,
+			      tx_status_t *txs, uint32 s1, uint32 s2)
 {
 	scb_ampdu_t *scb_ampdu;
 	wlc_info_t *wlc = ampdu->wlc;
@@ -1249,7 +1249,7 @@ wlc_ampdu_dotxstatus_complete(ampdu_info
 }
 
 static void
-ampdu_cleanup_tid_ini(ampdu_info_t * ampdu, scb_ampdu_t * scb_ampdu, uint8 tid,
+ampdu_cleanup_tid_ini(ampdu_info_t *ampdu, scb_ampdu_t *scb_ampdu, uint8 tid,
 		      bool force)
 {
 	scb_ampdu_tid_ini_t *ini;
@@ -1270,8 +1270,8 @@ ampdu_cleanup_tid_ini(ampdu_info_t * amp
 }
 
 /* initialize the initiator code for tid */
-static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t * ampdu,
-						   scb_ampdu_t * scb_ampdu,
+static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t *ampdu,
+						   scb_ampdu_t *scb_ampdu,
 						   uint8 tid, bool override)
 {
 	scb_ampdu_tid_ini_t *ini;
@@ -1296,7 +1296,7 @@ static scb_ampdu_tid_ini_t *wlc_ampdu_in
 	return ini;
 }
 
-int wlc_ampdu_set(ampdu_info_t * ampdu, bool on)
+int wlc_ampdu_set(ampdu_info_t *ampdu, bool on)
 {
 	wlc_info_t *wlc = ampdu->wlc;
 
@@ -1319,7 +1319,7 @@ int wlc_ampdu_set(ampdu_info_t * ampdu,
 	return 0;
 }
 
-bool wlc_ampdu_cap(ampdu_info_t * ampdu)
+bool wlc_ampdu_cap(ampdu_info_t *ampdu)
 {
 	if (WLC_PHY_11N_CAP(ampdu->wlc->band))
 		return TRUE;
@@ -1327,7 +1327,7 @@ bool wlc_ampdu_cap(ampdu_info_t * ampdu)
 		return FALSE;
 }
 
-static void ampdu_update_max_txlen(ampdu_info_t * ampdu, uint8 dur)
+static void ampdu_update_max_txlen(ampdu_info_t *ampdu, uint8 dur)
 {
 	uint32 rate, mcs;
 
@@ -1349,7 +1349,7 @@ static void ampdu_update_max_txlen(ampdu
 }
 
 uint8 BCMFASTPATH
-wlc_ampdu_null_delim_cnt(ampdu_info_t * ampdu, struct scb *scb,
+wlc_ampdu_null_delim_cnt(ampdu_info_t *ampdu, struct scb *scb,
 			 ratespec_t rspec, int phylen)
 {
 	scb_ampdu_t *scb_ampdu;
@@ -1385,7 +1385,7 @@ wlc_ampdu_null_delim_cnt(ampdu_info_t *
 		return 0;
 }
 
-void wlc_ampdu_macaddr_upd(wlc_info_t * wlc)
+void wlc_ampdu_macaddr_upd(wlc_info_t *wlc)
 {
 	char template[T_RAM_ACCESS_SZ * 2];
 
@@ -1396,12 +1396,12 @@ void wlc_ampdu_macaddr_upd(wlc_info_t *
 			       template);
 }
 
-bool wlc_aggregatable(wlc_info_t * wlc, uint8 tid)
+bool wlc_aggregatable(wlc_info_t *wlc, uint8 tid)
 {
 	return (wlc->ampdu->ini_enable[tid]);
 }
 
-void wlc_ampdu_shm_upd(ampdu_info_t * ampdu)
+void wlc_ampdu_shm_upd(ampdu_info_t *ampdu)
 {
 	wlc_info_t *wlc = ampdu->wlc;
 
--- a/drivers/staging/brcm80211/sys/wlc_ampdu.h
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.h
@@ -17,23 +17,23 @@
 #ifndef _wlc_ampdu_h_
 #define _wlc_ampdu_h_
 
-extern ampdu_info_t *wlc_ampdu_attach(wlc_info_t * wlc);
-extern void wlc_ampdu_detach(ampdu_info_t * ampdu);
-extern bool wlc_ampdu_cap(ampdu_info_t * ampdu);
-extern int wlc_ampdu_set(ampdu_info_t * ampdu, bool on);
-extern int wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **aggp,
+extern ampdu_info_t *wlc_ampdu_attach(wlc_info_t *wlc);
+extern void wlc_ampdu_detach(ampdu_info_t *ampdu);
+extern bool wlc_ampdu_cap(ampdu_info_t *ampdu);
+extern int wlc_ampdu_set(ampdu_info_t *ampdu, bool on);
+extern int wlc_sendampdu(ampdu_info_t *ampdu, wlc_txq_info_t *qi, void **aggp,
 			 int prec);
-extern void wlc_ampdu_dotxstatus(ampdu_info_t * ampdu, struct scb *scb, void *p,
-				 tx_status_t * txs);
-extern void wlc_ampdu_reset(ampdu_info_t * ampdu);
-extern void wlc_ampdu_macaddr_upd(wlc_info_t * wlc);
-extern void wlc_ampdu_shm_upd(ampdu_info_t * ampdu);
+extern void wlc_ampdu_dotxstatus(ampdu_info_t *ampdu, struct scb *scb, void *p,
+				 tx_status_t *txs);
+extern void wlc_ampdu_reset(ampdu_info_t *ampdu);
+extern void wlc_ampdu_macaddr_upd(wlc_info_t *wlc);
+extern void wlc_ampdu_shm_upd(ampdu_info_t *ampdu);
 
-extern uint8 wlc_ampdu_null_delim_cnt(ampdu_info_t * ampdu, struct scb *scb,
+extern uint8 wlc_ampdu_null_delim_cnt(ampdu_info_t *ampdu, struct scb *scb,
 				      ratespec_t rspec, int phylen);
-extern void scb_ampdu_cleanup(ampdu_info_t * ampdu, struct scb *scb);
+extern void scb_ampdu_cleanup(ampdu_info_t *ampdu, struct scb *scb);
 #ifdef WLC_HIGH_ONLY
-extern void wlc_ampdu_txstatus_complete(ampdu_info_t * ampdu, uint32 s1,
+extern void wlc_ampdu_txstatus_complete(ampdu_info_t *ampdu, uint32 s1,
 					uint32 s2);
 #endif
 
--- a/drivers/staging/brcm80211/sys/wlc_antsel.c
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.c
@@ -63,10 +63,10 @@
 #define ANT_SELCFG_DEF_2x4	0x02	/* default antenna configuration */
 
 /* static functions */
-static int wlc_antsel_cfgupd(antsel_info_t * asi, wlc_antselcfg_t * antsel);
-static uint8 wlc_antsel_id2antcfg(antsel_info_t * asi, uint8 id);
-static uint16 wlc_antsel_antcfg2antsel(antsel_info_t * asi, uint8 ant_cfg);
-static void wlc_antsel_init_cfg(antsel_info_t * asi, wlc_antselcfg_t * antsel,
+static int wlc_antsel_cfgupd(antsel_info_t *asi, wlc_antselcfg_t *antsel);
+static uint8 wlc_antsel_id2antcfg(antsel_info_t *asi, uint8 id);
+static uint16 wlc_antsel_antcfg2antsel(antsel_info_t *asi, uint8 ant_cfg);
+static void wlc_antsel_init_cfg(antsel_info_t *asi, wlc_antselcfg_t *antsel,
 				bool auto_sel);
 
 const uint16 mimo_2x4_div_antselpat_tbl[] = {
@@ -93,9 +93,9 @@ const uint8 mimo_2x3_div_antselid_tbl[16
 	0, 0, 0, 0, 0, 0, 0, 0	/* pat to antselid */
 };
 
-antsel_info_t *BCMNMIATTACHFN(wlc_antsel_attach) (wlc_info_t * wlc, osl_t * osh,
-						  wlc_pub_t * pub,
-						  wlc_hw_info_t * wlc_hw) {
+antsel_info_t *BCMNMIATTACHFN(wlc_antsel_attach) (wlc_info_t *wlc, osl_t *osh,
+						  wlc_pub_t *pub,
+						  wlc_hw_info_t *wlc_hw) {
 	antsel_info_t *asi;
 
 	if (!(asi = (antsel_info_t *) MALLOC(osh, sizeof(antsel_info_t)))) {
@@ -158,14 +158,14 @@ antsel_info_t *BCMNMIATTACHFN(wlc_antsel
 	return asi;
 }
 
-void BCMATTACHFN(wlc_antsel_detach) (antsel_info_t * asi) {
+void BCMATTACHFN(wlc_antsel_detach) (antsel_info_t *asi) {
 	if (!asi)
 		return;
 
 	MFREE(asi->pub->osh, asi, sizeof(antsel_info_t));
 }
 
-void wlc_antsel_init(antsel_info_t * asi)
+void wlc_antsel_init(antsel_info_t *asi)
 {
 	if ((asi->antsel_type == ANTSEL_2x3) ||
 	    (asi->antsel_type == ANTSEL_2x4))
@@ -174,7 +174,7 @@ void wlc_antsel_init(antsel_info_t * asi
 
 /* boardlevel antenna selection: init antenna selection structure */
 static void
-wlc_antsel_init_cfg(antsel_info_t * asi, wlc_antselcfg_t * antsel,
+wlc_antsel_init_cfg(antsel_info_t *asi, wlc_antselcfg_t *antsel,
 		    bool auto_sel)
 {
 	if (asi->antsel_type == ANTSEL_2x3) {
@@ -205,9 +205,9 @@ wlc_antsel_init_cfg(antsel_info_t * asi,
 }
 
 void BCMFASTPATH
-wlc_antsel_antcfg_get(antsel_info_t * asi, bool usedef, bool sel,
-		      uint8 antselid, uint8 fbantselid, uint8 * antcfg,
-		      uint8 * fbantcfg)
+wlc_antsel_antcfg_get(antsel_info_t *asi, bool usedef, bool sel,
+		      uint8 antselid, uint8 fbantselid, uint8 *antcfg,
+		      uint8 *fbantcfg)
 {
 	uint8 ant;
 
@@ -237,7 +237,7 @@ wlc_antsel_antcfg_get(antsel_info_t * as
 }
 
 /* boardlevel antenna selection: convert mimo_antsel (ucode interface) to id */
-uint8 wlc_antsel_antsel2id(antsel_info_t * asi, uint16 antsel)
+uint8 wlc_antsel_antsel2id(antsel_info_t *asi, uint16 antsel)
 {
 	uint8 antselid = 0;
 
@@ -256,7 +256,7 @@ uint8 wlc_antsel_antsel2id(antsel_info_t
 }
 
 /* boardlevel antenna selection: convert id to ant_cfg */
-static uint8 wlc_antsel_id2antcfg(antsel_info_t * asi, uint8 id)
+static uint8 wlc_antsel_id2antcfg(antsel_info_t *asi, uint8 id)
 {
 	uint8 antcfg = ANT_SELCFG_DEF_2x2;
 
@@ -275,7 +275,7 @@ static uint8 wlc_antsel_id2antcfg(antsel
 }
 
 /* boardlevel antenna selection: convert ant_cfg to mimo_antsel (ucode interface) */
-static uint16 wlc_antsel_antcfg2antsel(antsel_info_t * asi, uint8 ant_cfg)
+static uint16 wlc_antsel_antcfg2antsel(antsel_info_t *asi, uint8 ant_cfg)
 {
 	uint8 idx = WLC_ANTIDX_11N(WLC_ANTSEL_11N(ant_cfg));
 	uint16 mimo_antsel = 0;
@@ -295,7 +295,7 @@ static uint16 wlc_antsel_antcfg2antsel(a
 }
 
 /* boardlevel antenna selection: ucode interface control */
-static int wlc_antsel_cfgupd(antsel_info_t * asi, wlc_antselcfg_t * antsel)
+static int wlc_antsel_cfgupd(antsel_info_t *asi, wlc_antselcfg_t *antsel)
 {
 	wlc_info_t *wlc = asi->wlc;
 	uint8 ant_cfg;
--- a/drivers/staging/brcm80211/sys/wlc_antsel.h
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.h
@@ -16,13 +16,13 @@
 
 #ifndef _wlc_antsel_h_
 #define _wlc_antsel_h_
-extern antsel_info_t *wlc_antsel_attach(wlc_info_t * wlc, osl_t * osh,
-					wlc_pub_t * pub,
-					wlc_hw_info_t * wlc_hw);
-extern void wlc_antsel_detach(antsel_info_t * asi);
-extern void wlc_antsel_init(antsel_info_t * asi);
-extern void wlc_antsel_antcfg_get(antsel_info_t * asi, bool usedef, bool sel,
-				  uint8 id, uint8 fbid, uint8 * antcfg,
-				  uint8 * fbantcfg);
-extern uint8 wlc_antsel_antsel2id(antsel_info_t * asi, uint16 antsel);
+extern antsel_info_t *wlc_antsel_attach(wlc_info_t *wlc, osl_t *osh,
+					wlc_pub_t *pub,
+					wlc_hw_info_t *wlc_hw);
+extern void wlc_antsel_detach(antsel_info_t *asi);
+extern void wlc_antsel_init(antsel_info_t *asi);
+extern void wlc_antsel_antcfg_get(antsel_info_t *asi, bool usedef, bool sel,
+				  uint8 id, uint8 fbid, uint8 *antcfg,
+				  uint8 *fbantcfg);
+extern uint8 wlc_antsel_antsel2id(antsel_info_t *asi, uint16 antsel);
 #endif				/* _wlc_antsel_h_ */
--- a/drivers/staging/brcm80211/sys/wlc_bmac.c
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -112,64 +112,64 @@ static uint16 xmtfifo_sz[][NFIFO] = {
 	{9, 58, 22, 14, 14, 5},	/* corerev 24: 2304, 14848, 5632, 3584, 3584, 1280 */
 };
 
-static void wlc_clkctl_clk(wlc_hw_info_t * wlc, uint mode);
-static void wlc_coreinit(wlc_info_t * wlc);
+static void wlc_clkctl_clk(wlc_hw_info_t *wlc, uint mode);
+static void wlc_coreinit(wlc_info_t *wlc);
 
 /* used by wlc_wakeucode_init() */
-static void wlc_write_inits(wlc_hw_info_t * wlc_hw, const d11init_t * inits);
-static void wlc_ucode_write(wlc_hw_info_t * wlc_hw, const uint32 ucode[],
+static void wlc_write_inits(wlc_hw_info_t *wlc_hw, const d11init_t *inits);
+static void wlc_ucode_write(wlc_hw_info_t *wlc_hw, const uint32 ucode[],
 			    const uint nbytes);
-static void wlc_ucode_download(wlc_hw_info_t * wlc);
-static void wlc_ucode_txant_set(wlc_hw_info_t * wlc_hw);
+static void wlc_ucode_download(wlc_hw_info_t *wlc);
+static void wlc_ucode_txant_set(wlc_hw_info_t *wlc_hw);
 
 /* used by wlc_dpc() */
-static bool wlc_bmac_dotxstatus(wlc_hw_info_t * wlc, tx_status_t * txs,
+static bool wlc_bmac_dotxstatus(wlc_hw_info_t *wlc, tx_status_t *txs,
 				uint32 s2);
-static bool wlc_bmac_txstatus_corerev4(wlc_hw_info_t * wlc);
-static bool wlc_bmac_txstatus(wlc_hw_info_t * wlc, bool bound, bool * fatal);
-static bool wlc_bmac_recv(wlc_hw_info_t * wlc_hw, uint fifo, bool bound);
+static bool wlc_bmac_txstatus_corerev4(wlc_hw_info_t *wlc);
+static bool wlc_bmac_txstatus(wlc_hw_info_t *wlc, bool bound, bool *fatal);
+static bool wlc_bmac_recv(wlc_hw_info_t *wlc_hw, uint fifo, bool bound);
 
 /* used by wlc_down() */
-static void wlc_flushqueues(wlc_info_t * wlc);
+static void wlc_flushqueues(wlc_info_t *wlc);
 
-static void wlc_write_mhf(wlc_hw_info_t * wlc_hw, uint16 * mhfs);
-static void wlc_mctrl_reset(wlc_hw_info_t * wlc_hw);
-static void wlc_corerev_fifofixup(wlc_hw_info_t * wlc_hw);
+static void wlc_write_mhf(wlc_hw_info_t *wlc_hw, uint16 *mhfs);
+static void wlc_mctrl_reset(wlc_hw_info_t *wlc_hw);
+static void wlc_corerev_fifofixup(wlc_hw_info_t *wlc_hw);
 
 /* Low Level Prototypes */
-static uint16 wlc_bmac_read_objmem(wlc_hw_info_t * wlc_hw, uint offset,
+static uint16 wlc_bmac_read_objmem(wlc_hw_info_t *wlc_hw, uint offset,
 				   uint32 sel);
-static void wlc_bmac_write_objmem(wlc_hw_info_t * wlc_hw, uint offset, uint16 v,
+static void wlc_bmac_write_objmem(wlc_hw_info_t *wlc_hw, uint offset, uint16 v,
 				  uint32 sel);
-static bool wlc_bmac_attach_dmapio(wlc_info_t * wlc, uint j, bool wme);
-static void wlc_bmac_detach_dmapio(wlc_hw_info_t * wlc_hw);
-static void wlc_ucode_bsinit(wlc_hw_info_t * wlc_hw);
-static bool wlc_validboardtype(wlc_hw_info_t * wlc);
-static bool wlc_isgoodchip(wlc_hw_info_t * wlc_hw);
-static char *wlc_get_macaddr(wlc_hw_info_t * wlc_hw);
-static void wlc_mhfdef(wlc_info_t * wlc, uint16 * mhfs, uint16 mhf2_init);
-static void wlc_mctrl_write(wlc_hw_info_t * wlc_hw);
-static void wlc_ucode_mute_override_set(wlc_hw_info_t * wlc_hw);
-static void wlc_ucode_mute_override_clear(wlc_hw_info_t * wlc_hw);
-static uint32 wlc_wlintrsoff(wlc_info_t * wlc);
-static void wlc_wlintrsrestore(wlc_info_t * wlc, uint32 macintmask);
-static void wlc_gpio_init(wlc_info_t * wlc);
-static void wlc_write_hw_bcntemplate0(wlc_hw_info_t * wlc_hw, void *bcn,
+static bool wlc_bmac_attach_dmapio(wlc_info_t *wlc, uint j, bool wme);
+static void wlc_bmac_detach_dmapio(wlc_hw_info_t *wlc_hw);
+static void wlc_ucode_bsinit(wlc_hw_info_t *wlc_hw);
+static bool wlc_validboardtype(wlc_hw_info_t *wlc);
+static bool wlc_isgoodchip(wlc_hw_info_t *wlc_hw);
+static char *wlc_get_macaddr(wlc_hw_info_t *wlc_hw);
+static void wlc_mhfdef(wlc_info_t *wlc, uint16 *mhfs, uint16 mhf2_init);
+static void wlc_mctrl_write(wlc_hw_info_t *wlc_hw);
+static void wlc_ucode_mute_override_set(wlc_hw_info_t *wlc_hw);
+static void wlc_ucode_mute_override_clear(wlc_hw_info_t *wlc_hw);
+static uint32 wlc_wlintrsoff(wlc_info_t *wlc);
+static void wlc_wlintrsrestore(wlc_info_t *wlc, uint32 macintmask);
+static void wlc_gpio_init(wlc_info_t *wlc);
+static void wlc_write_hw_bcntemplate0(wlc_hw_info_t *wlc_hw, void *bcn,
 				      int len);
-static void wlc_write_hw_bcntemplate1(wlc_hw_info_t * wlc_hw, void *bcn,
+static void wlc_write_hw_bcntemplate1(wlc_hw_info_t *wlc_hw, void *bcn,
 				      int len);
-static void wlc_bmac_bsinit(wlc_info_t * wlc, chanspec_t chanspec);
-static uint32 wlc_setband_inact(wlc_info_t * wlc, uint bandunit);
-static void wlc_bmac_setband(wlc_hw_info_t * wlc_hw, uint bandunit,
+static void wlc_bmac_bsinit(wlc_info_t *wlc, chanspec_t chanspec);
+static uint32 wlc_setband_inact(wlc_info_t *wlc, uint bandunit);
+static void wlc_bmac_setband(wlc_hw_info_t *wlc_hw, uint bandunit,
 			     chanspec_t chanspec);
-static void wlc_bmac_update_slot_timing(wlc_hw_info_t * wlc_hw, bool shortslot);
-static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t * wlc_hw);
-static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t * wlc_hw,
+static void wlc_bmac_update_slot_timing(wlc_hw_info_t *wlc_hw, bool shortslot);
+static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t *wlc_hw);
+static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t *wlc_hw,
 					     uint8 rate);
 
 /* === Low Level functions === */
 
-void wlc_bmac_set_shortslot(wlc_hw_info_t * wlc_hw, bool shortslot)
+void wlc_bmac_set_shortslot(wlc_hw_info_t *wlc_hw, bool shortslot)
 {
 	wlc_hw->shortslot = shortslot;
 
@@ -185,7 +185,7 @@ void wlc_bmac_set_shortslot(wlc_hw_info_
  * or shortslot 11g (9us slots)
  * The PSM needs to be suspended for this call.
  */
-static void wlc_bmac_update_slot_timing(wlc_hw_info_t * wlc_hw, bool shortslot)
+static void wlc_bmac_update_slot_timing(wlc_hw_info_t *wlc_hw, bool shortslot)
 {
 	osl_t *osh;
 	d11regs_t *regs;
@@ -204,7 +204,7 @@ static void wlc_bmac_update_slot_timing(
 	}
 }
 
-static void WLBANDINITFN(wlc_ucode_bsinit) (wlc_hw_info_t * wlc_hw) {
+static void WLBANDINITFN(wlc_ucode_bsinit) (wlc_hw_info_t *wlc_hw) {
 	/* init microcode host flags */
 	wlc_write_mhf(wlc_hw, wlc_hw->band->mhfs);
 
@@ -230,7 +230,7 @@ static void WLBANDINITFN(wlc_ucode_bsini
 }
 
 /* switch to new band but leave it inactive */
-static uint32 WLBANDINITFN(wlc_setband_inact) (wlc_info_t * wlc, uint bandunit) {
+static uint32 WLBANDINITFN(wlc_setband_inact) (wlc_info_t *wlc, uint bandunit) {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	uint32 macintmask;
 	uint32 tmp;
@@ -266,7 +266,7 @@ static uint32 WLBANDINITFN(wlc_setband_i
  * Param 'bound' indicates max. # frames to process before break out.
  */
 static bool BCMFASTPATH
-wlc_bmac_recv(wlc_hw_info_t * wlc_hw, uint fifo, bool bound)
+wlc_bmac_recv(wlc_hw_info_t *wlc_hw, uint fifo, bool bound)
 {
 	void *p;
 	void *head = NULL;
@@ -320,7 +320,7 @@ wlc_bmac_recv(wlc_hw_info_t * wlc_hw, ui
  *   Return TRUE if another dpc needs to be re-scheduled. FALSE otherwise.
  *   Param 'bounded' indicates if applicable loops should be bounded.
  */
-bool BCMFASTPATH wlc_dpc(wlc_info_t * wlc, bool bounded)
+bool BCMFASTPATH wlc_dpc(wlc_info_t *wlc, bool bounded)
 {
 	uint32 macintstatus;
 	wlc_hw_info_t *wlc_hw = wlc->hw;
@@ -473,7 +473,7 @@ void wlc_bmac_watchdog(void *arg)
 }
 
 void
-wlc_bmac_set_chanspec(wlc_hw_info_t * wlc_hw, chanspec_t chanspec, bool mute,
+wlc_bmac_set_chanspec(wlc_hw_info_t *wlc_hw, chanspec_t chanspec, bool mute,
 		      struct txpwr_limits *txpwr)
 {
 	uint bandunit;
@@ -517,7 +517,7 @@ wlc_bmac_set_chanspec(wlc_hw_info_t * wl
 	}
 }
 
-int wlc_bmac_revinfo_get(wlc_hw_info_t * wlc_hw, wlc_bmac_revinfo_t * revinfo)
+int wlc_bmac_revinfo_get(wlc_hw_info_t *wlc_hw, wlc_bmac_revinfo_t *revinfo)
 {
 	si_t *sih = wlc_hw->sih;
 	uint idx;
@@ -555,7 +555,7 @@ int wlc_bmac_revinfo_get(wlc_hw_info_t *
 	return 0;
 }
 
-int wlc_bmac_state_get(wlc_hw_info_t * wlc_hw, wlc_bmac_state_t * state)
+int wlc_bmac_state_get(wlc_hw_info_t *wlc_hw, wlc_bmac_state_t *state)
 {
 	state->machwcap = wlc_hw->machwcap;
 
@@ -563,7 +563,7 @@ int wlc_bmac_state_get(wlc_hw_info_t * w
 }
 
 static bool
-BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc_info_t * wlc, uint j, bool wme) {
+BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc_info_t *wlc, uint j, bool wme) {
 	uint i;
 	char name[8];
 	/* ucode host flag 2 needed for pio mode, independent of band and fifo */
@@ -681,7 +681,7 @@ BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc
 	return TRUE;
 }
 
-static void BCMATTACHFN(wlc_bmac_detach_dmapio) (wlc_hw_info_t * wlc_hw) {
+static void BCMATTACHFN(wlc_bmac_detach_dmapio) (wlc_hw_info_t *wlc_hw) {
 	uint j;
 
 	for (j = 0; j < NFIFO; j++) {
@@ -700,8 +700,8 @@ static void BCMATTACHFN(wlc_bmac_detach_
  */
 
 int
-BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
-			      uint unit, bool piomode, osl_t * osh,
+BCMATTACHFN(wlc_bmac_attach) (wlc_info_t *wlc, uint16 vendor, uint16 device,
+			      uint unit, bool piomode, osl_t *osh,
 			      void *regsva, uint bustype, void *btparam) {
 	wlc_hw_info_t *wlc_hw;
 	d11regs_t *regs;
@@ -1039,7 +1039,7 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
  * may get overrides later in this function
  *  BMAC_NOTES, move low out and resolve the dangling ones
  */
-void BCMATTACHFN(wlc_bmac_info_init) (wlc_hw_info_t * wlc_hw) {
+void BCMATTACHFN(wlc_bmac_info_init) (wlc_hw_info_t *wlc_hw) {
 	wlc_info_t *wlc = wlc_hw->wlc;
 
 	/* set default sw macintmask value */
@@ -1060,7 +1060,7 @@ void BCMATTACHFN(wlc_bmac_info_init) (wl
 /*
  * low level detach
  */
-int BCMATTACHFN(wlc_bmac_detach) (wlc_info_t * wlc) {
+int BCMATTACHFN(wlc_bmac_detach) (wlc_info_t *wlc) {
 	uint i;
 	wlc_hwband_t *band;
 	wlc_hw_info_t *wlc_hw = wlc->hw;
@@ -1110,7 +1110,7 @@ int BCMATTACHFN(wlc_bmac_detach) (wlc_in
 
 }
 
-void BCMINITFN(wlc_bmac_reset) (wlc_hw_info_t * wlc_hw) {
+void BCMINITFN(wlc_bmac_reset) (wlc_hw_info_t *wlc_hw) {
 	WL_TRACE(("wl%d: wlc_bmac_reset\n", wlc_hw->unit));
 
 	WLCNTINCR(wlc_hw->wlc->pub->_cnt->reset);
@@ -1126,7 +1126,7 @@ void BCMINITFN(wlc_bmac_reset) (wlc_hw_i
 }
 
 void
-BCMINITFN(wlc_bmac_init) (wlc_hw_info_t * wlc_hw, chanspec_t chanspec,
+BCMINITFN(wlc_bmac_init) (wlc_hw_info_t *wlc_hw, chanspec_t chanspec,
 			  bool mute) {
 	uint32 macintmask;
 	bool fastclk;
@@ -1176,7 +1176,7 @@ BCMINITFN(wlc_bmac_init) (wlc_hw_info_t
 		wlc_clkctl_clk(wlc_hw, CLK_DYNAMIC);
 }
 
-int BCMINITFN(wlc_bmac_up_prep) (wlc_hw_info_t * wlc_hw) {
+int BCMINITFN(wlc_bmac_up_prep) (wlc_hw_info_t *wlc_hw) {
 	uint coremask;
 
 	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
@@ -1223,7 +1223,7 @@ int BCMINITFN(wlc_bmac_up_prep) (wlc_hw_
 	return 0;
 }
 
-int BCMINITFN(wlc_bmac_up_finish) (wlc_hw_info_t * wlc_hw) {
+int BCMINITFN(wlc_bmac_up_finish) (wlc_hw_info_t *wlc_hw) {
 	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
 
 	wlc_hw->up = TRUE;
@@ -1236,7 +1236,7 @@ int BCMINITFN(wlc_bmac_up_finish) (wlc_h
 	return 0;
 }
 
-int BCMUNINITFN(wlc_bmac_down_prep) (wlc_hw_info_t * wlc_hw) {
+int BCMUNINITFN(wlc_bmac_down_prep) (wlc_hw_info_t *wlc_hw) {
 	bool dev_gone;
 	uint callbacks = 0;
 
@@ -1263,7 +1263,7 @@ int BCMUNINITFN(wlc_bmac_down_prep) (wlc
 	return callbacks;
 }
 
-int BCMUNINITFN(wlc_bmac_down_finish) (wlc_hw_info_t * wlc_hw) {
+int BCMUNINITFN(wlc_bmac_down_finish) (wlc_hw_info_t *wlc_hw) {
 	uint callbacks = 0;
 	bool dev_gone;
 
@@ -1306,7 +1306,7 @@ int BCMUNINITFN(wlc_bmac_down_finish) (w
 	return callbacks;
 }
 
-void wlc_bmac_wait_for_wake(wlc_hw_info_t * wlc_hw)
+void wlc_bmac_wait_for_wake(wlc_hw_info_t *wlc_hw)
 {
 	if (D11REV_IS(wlc_hw->corerev, 4))	/* no slowclock */
 		OSL_DELAY(5);
@@ -1322,29 +1322,29 @@ void wlc_bmac_wait_for_wake(wlc_hw_info_
 	ASSERT(wlc_bmac_read_shm(wlc_hw, M_UCODE_DBGST) != DBGST_ASLEEP);
 }
 
-void wlc_bmac_hw_etheraddr(wlc_hw_info_t * wlc_hw, struct ether_addr *ea)
+void wlc_bmac_hw_etheraddr(wlc_hw_info_t *wlc_hw, struct ether_addr *ea)
 {
 	bcopy(&wlc_hw->etheraddr, ea, ETHER_ADDR_LEN);
 }
 
-void wlc_bmac_set_hw_etheraddr(wlc_hw_info_t * wlc_hw, struct ether_addr *ea)
+void wlc_bmac_set_hw_etheraddr(wlc_hw_info_t *wlc_hw, struct ether_addr *ea)
 {
 	bcopy(ea, &wlc_hw->etheraddr, ETHER_ADDR_LEN);
 }
 
-int wlc_bmac_bandtype(wlc_hw_info_t * wlc_hw)
+int wlc_bmac_bandtype(wlc_hw_info_t *wlc_hw)
 {
 	return (wlc_hw->band->bandtype);
 }
 
-void *wlc_cur_phy(wlc_info_t * wlc)
+void *wlc_cur_phy(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	return ((void *)wlc_hw->band->pi);
 }
 
 /* control chip clock to save power, enable dynamic clock or force fast clock */
-static void wlc_clkctl_clk(wlc_hw_info_t * wlc_hw, uint mode)
+static void wlc_clkctl_clk(wlc_hw_info_t *wlc_hw, uint mode)
 {
 	if (PMUCTL_ENAB(wlc_hw->sih)) {
 		/* new chips with PMU, CCS_FORCEHT will distribute the HT clock on backplane,
@@ -1441,7 +1441,7 @@ static void wlc_clkctl_clk(wlc_hw_info_t
 
 /* set initial host flags value */
 static void
-BCMINITFN(wlc_mhfdef) (wlc_info_t * wlc, uint16 * mhfs, uint16 mhf2_init) {
+BCMINITFN(wlc_mhfdef) (wlc_info_t *wlc, uint16 *mhfs, uint16 mhf2_init) {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 
 	bzero(mhfs, sizeof(uint16) * MHFMAX);
@@ -1470,7 +1470,7 @@ BCMINITFN(wlc_mhfdef) (wlc_info_t * wlc,
  *                   WLC_BAND_ALL  <--- All bands
  */
 void
-wlc_bmac_mhf(wlc_hw_info_t * wlc_hw, uint8 idx, uint16 mask, uint16 val,
+wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, uint8 idx, uint16 mask, uint16 val,
 	     int bands)
 {
 	uint16 save;
@@ -1524,7 +1524,7 @@ wlc_bmac_mhf(wlc_hw_info_t * wlc_hw, uin
 	}
 }
 
-uint16 wlc_bmac_mhf_get(wlc_hw_info_t * wlc_hw, uint8 idx, int bands)
+uint16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, uint8 idx, int bands)
 {
 	wlc_hwband_t *band;
 	ASSERT(idx < MHFMAX);
@@ -1550,7 +1550,7 @@ uint16 wlc_bmac_mhf_get(wlc_hw_info_t *
 	return band->mhfs[idx];
 }
 
-static void wlc_write_mhf(wlc_hw_info_t * wlc_hw, uint16 * mhfs)
+static void wlc_write_mhf(wlc_hw_info_t *wlc_hw, uint16 *mhfs)
 {
 	uint8 idx;
 	uint16 addr[] =
@@ -1568,7 +1568,7 @@ static void wlc_write_mhf(wlc_hw_info_t
 /* set the maccontrol register to desired reset state and
  * initialize the sw cache of the register
  */
-static void wlc_mctrl_reset(wlc_hw_info_t * wlc_hw)
+static void wlc_mctrl_reset(wlc_hw_info_t *wlc_hw)
 {
 	/* IHR accesses are always enabled, PSM disabled, HPS off and WAKE on */
 	wlc_hw->maccontrol = 0;
@@ -1579,7 +1579,7 @@ static void wlc_mctrl_reset(wlc_hw_info_
 }
 
 /* set or clear maccontrol bits */
-void wlc_bmac_mctrl(wlc_hw_info_t * wlc_hw, uint32 mask, uint32 val)
+void wlc_bmac_mctrl(wlc_hw_info_t *wlc_hw, uint32 mask, uint32 val)
 {
 	uint32 maccontrol;
 	uint32 new_maccontrol;
@@ -1601,7 +1601,7 @@ void wlc_bmac_mctrl(wlc_hw_info_t * wlc_
 }
 
 /* write the software state of maccontrol and overrides to the maccontrol register */
-static void wlc_mctrl_write(wlc_hw_info_t * wlc_hw)
+static void wlc_mctrl_write(wlc_hw_info_t *wlc_hw)
 {
 	uint32 maccontrol = wlc_hw->maccontrol;
 
@@ -1618,7 +1618,7 @@ static void wlc_mctrl_write(wlc_hw_info_
 	W_REG(wlc_hw->osh, &wlc_hw->regs->maccontrol, maccontrol);
 }
 
-void wlc_ucode_wake_override_set(wlc_hw_info_t * wlc_hw, uint32 override_bit)
+void wlc_ucode_wake_override_set(wlc_hw_info_t *wlc_hw, uint32 override_bit)
 {
 	ASSERT((wlc_hw->wake_override & override_bit) == 0);
 
@@ -1635,7 +1635,7 @@ void wlc_ucode_wake_override_set(wlc_hw_
 	return;
 }
 
-void wlc_ucode_wake_override_clear(wlc_hw_info_t * wlc_hw, uint32 override_bit)
+void wlc_ucode_wake_override_clear(wlc_hw_info_t *wlc_hw, uint32 override_bit)
 {
 	ASSERT(wlc_hw->wake_override & override_bit);
 
@@ -1656,7 +1656,7 @@ void wlc_ucode_wake_override_clear(wlc_h
  * STA               0              1 <--- This will ensure no beacons
  * IBSS              0              0
  */
-static void wlc_ucode_mute_override_set(wlc_hw_info_t * wlc_hw)
+static void wlc_ucode_mute_override_set(wlc_hw_info_t *wlc_hw)
 {
 	wlc_hw->mute_override = 1;
 
@@ -1672,7 +1672,7 @@ static void wlc_ucode_mute_override_set(
 }
 
 /* Clear the override on AP and INFRA bits */
-static void wlc_ucode_mute_override_clear(wlc_hw_info_t * wlc_hw)
+static void wlc_ucode_mute_override_clear(wlc_hw_info_t *wlc_hw)
 {
 	if (wlc_hw->mute_override == 0)
 		return;
@@ -1692,7 +1692,7 @@ static void wlc_ucode_mute_override_clea
  * Write a MAC address to the rcmta structure
  */
 void
-wlc_bmac_set_rcmta(wlc_hw_info_t * wlc_hw, int idx,
+wlc_bmac_set_rcmta(wlc_hw_info_t *wlc_hw, int idx,
 		   const struct ether_addr *addr)
 {
 	d11regs_t *regs = wlc_hw->regs;
@@ -1726,7 +1726,7 @@ wlc_bmac_set_rcmta(wlc_hw_info_t * wlc_h
  * Write a MAC address to the given match reg offset in the RXE match engine.
  */
 void
-wlc_bmac_set_addrmatch(wlc_hw_info_t * wlc_hw, int match_reg_offset,
+wlc_bmac_set_addrmatch(wlc_hw_info_t *wlc_hw, int match_reg_offset,
 		       const struct ether_addr *addr)
 {
 	d11regs_t *regs;
@@ -1755,7 +1755,7 @@ wlc_bmac_set_addrmatch(wlc_hw_info_t * w
 }
 
 void
-wlc_bmac_write_template_ram(wlc_hw_info_t * wlc_hw, int offset, int len,
+wlc_bmac_write_template_ram(wlc_hw_info_t *wlc_hw, int offset, int len,
 			    void *buf)
 {
 	d11regs_t *regs;
@@ -1798,7 +1798,7 @@ wlc_bmac_write_template_ram(wlc_hw_info_
 	}
 }
 
-void wlc_bmac_set_cwmin(wlc_hw_info_t * wlc_hw, uint16 newmin)
+void wlc_bmac_set_cwmin(wlc_hw_info_t *wlc_hw, uint16 newmin)
 {
 	osl_t *osh;
 
@@ -1810,7 +1810,7 @@ void wlc_bmac_set_cwmin(wlc_hw_info_t *
 	W_REG(osh, &wlc_hw->regs->objdata, newmin);
 }
 
-void wlc_bmac_set_cwmax(wlc_hw_info_t * wlc_hw, uint16 newmax)
+void wlc_bmac_set_cwmax(wlc_hw_info_t *wlc_hw, uint16 newmax)
 {
 	osl_t *osh;
 
@@ -1822,7 +1822,7 @@ void wlc_bmac_set_cwmax(wlc_hw_info_t *
 	W_REG(osh, &wlc_hw->regs->objdata, newmax);
 }
 
-void wlc_bmac_bw_set(wlc_hw_info_t * wlc_hw, uint16 bw)
+void wlc_bmac_bw_set(wlc_hw_info_t *wlc_hw, uint16 bw)
 {
 	bool fastclk;
 	uint32 tmp;
@@ -1846,7 +1846,7 @@ void wlc_bmac_bw_set(wlc_hw_info_t * wlc
 }
 
 static void
-wlc_write_hw_bcntemplate0(wlc_hw_info_t * wlc_hw, void *bcn, int len)
+wlc_write_hw_bcntemplate0(wlc_hw_info_t *wlc_hw, void *bcn, int len)
 {
 	d11regs_t *regs = wlc_hw->regs;
 
@@ -1860,7 +1860,7 @@ wlc_write_hw_bcntemplate0(wlc_hw_info_t
 }
 
 static void
-wlc_write_hw_bcntemplate1(wlc_hw_info_t * wlc_hw, void *bcn, int len)
+wlc_write_hw_bcntemplate1(wlc_hw_info_t *wlc_hw, void *bcn, int len)
 {
 	d11regs_t *regs = wlc_hw->regs;
 
@@ -1875,7 +1875,7 @@ wlc_write_hw_bcntemplate1(wlc_hw_info_t
 
 /* mac is assumed to be suspended at this point */
 void
-wlc_bmac_write_hw_bcntemplates(wlc_hw_info_t * wlc_hw, void *bcn, int len,
+wlc_bmac_write_hw_bcntemplates(wlc_hw_info_t *wlc_hw, void *bcn, int len,
 			       bool both)
 {
 	d11regs_t *regs = wlc_hw->regs;
@@ -1896,7 +1896,7 @@ wlc_bmac_write_hw_bcntemplates(wlc_hw_in
 	}
 }
 
-static void WLBANDINITFN(wlc_bmac_upd_synthpu) (wlc_hw_info_t * wlc_hw) {
+static void WLBANDINITFN(wlc_bmac_upd_synthpu) (wlc_hw_info_t *wlc_hw) {
 	uint16 v;
 	wlc_info_t *wlc = wlc_hw->wlc;
 	/* update SYNTHPU_DLY */
@@ -1914,7 +1914,7 @@ static void WLBANDINITFN(wlc_bmac_upd_sy
 
 /* band-specific init */
 static void
-WLBANDINITFN(wlc_bmac_bsinit) (wlc_info_t * wlc, chanspec_t chanspec) {
+WLBANDINITFN(wlc_bmac_bsinit) (wlc_info_t *wlc, chanspec_t chanspec) {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 
 	WL_TRACE(("wl%d: wlc_bmac_bsinit: bandunit %d\n", wlc_hw->unit,
@@ -1952,7 +1952,7 @@ WLBANDINITFN(wlc_bmac_bsinit) (wlc_info_
 	wlc_bmac_upd_synthpu(wlc_hw);
 }
 
-void wlc_bmac_core_phy_clk(wlc_hw_info_t * wlc_hw, bool clk)
+void wlc_bmac_core_phy_clk(wlc_hw_info_t *wlc_hw, bool clk)
 {
 	WL_TRACE(("wl%d: wlc_bmac_core_phy_clk: clk %d\n", wlc_hw->unit, clk));
 
@@ -1977,7 +1977,7 @@ void wlc_bmac_core_phy_clk(wlc_hw_info_t
 }
 
 /* Perform a soft reset of the PHY PLL */
-void wlc_bmac_core_phypll_reset(wlc_hw_info_t * wlc_hw)
+void wlc_bmac_core_phypll_reset(wlc_hw_info_t *wlc_hw)
 {
 	WL_TRACE(("wl%d: wlc_bmac_core_phypll_reset\n", wlc_hw->unit));
 
@@ -1998,7 +1998,7 @@ void wlc_bmac_core_phypll_reset(wlc_hw_i
 /* light way to turn on phy clock without reset for NPHY only
  *  refer to wlc_bmac_core_phy_clk for full version
  */
-void wlc_bmac_phyclk_fgc(wlc_hw_info_t * wlc_hw, bool clk)
+void wlc_bmac_phyclk_fgc(wlc_hw_info_t *wlc_hw, bool clk)
 {
 	/* support(necessary for NPHY and HYPHY) only */
 	if (!WLCISNPHY(wlc_hw->band))
@@ -2011,7 +2011,7 @@ void wlc_bmac_phyclk_fgc(wlc_hw_info_t *
 
 }
 
-void wlc_bmac_macphyclk_set(wlc_hw_info_t * wlc_hw, bool clk)
+void wlc_bmac_macphyclk_set(wlc_hw_info_t *wlc_hw, bool clk)
 {
 	if (ON == clk)
 		si_core_cflags(wlc_hw->sih, SICF_MPCLKE, SICF_MPCLKE);
@@ -2019,7 +2019,7 @@ void wlc_bmac_macphyclk_set(wlc_hw_info_
 		si_core_cflags(wlc_hw->sih, SICF_MPCLKE, 0);
 }
 
-void wlc_bmac_phy_reset(wlc_hw_info_t * wlc_hw)
+void wlc_bmac_phy_reset(wlc_hw_info_t *wlc_hw)
 {
 	wlc_phy_t *pih = wlc_hw->band->pi;
 	uint32 phy_bw_clkbits;
@@ -2063,7 +2063,7 @@ void wlc_bmac_phy_reset(wlc_hw_info_t *
 
 /* switch to and initialize new band */
 static void
-WLBANDINITFN(wlc_bmac_setband) (wlc_hw_info_t * wlc_hw, uint bandunit,
+WLBANDINITFN(wlc_bmac_setband) (wlc_hw_info_t *wlc_hw, uint bandunit,
 				chanspec_t chanspec) {
 	wlc_info_t *wlc = wlc_hw->wlc;
 	uint32 macintmask;
@@ -2105,7 +2105,7 @@ WLBANDINITFN(wlc_bmac_setband) (wlc_hw_i
 }
 
 /* low-level band switch utility routine */
-void WLBANDINITFN(wlc_setxband) (wlc_hw_info_t * wlc_hw, uint bandunit) {
+void WLBANDINITFN(wlc_setxband) (wlc_hw_info_t *wlc_hw, uint bandunit) {
 	WL_TRACE(("wl%d: wlc_setxband: bandunit %d\n", wlc_hw->unit, bandunit));
 
 	wlc_hw->band = wlc_hw->bandstate[bandunit];
@@ -2120,7 +2120,7 @@ void WLBANDINITFN(wlc_setxband) (wlc_hw_
 	}
 }
 
-static bool BCMATTACHFN(wlc_isgoodchip) (wlc_hw_info_t * wlc_hw) {
+static bool BCMATTACHFN(wlc_isgoodchip) (wlc_hw_info_t *wlc_hw) {
 
 	/* reject unsupported corerev */
 	if (!VALID_COREREV(wlc_hw->corerev)) {
@@ -2131,7 +2131,7 @@ static bool BCMATTACHFN(wlc_isgoodchip)
 	return TRUE;
 }
 
-static bool BCMATTACHFN(wlc_validboardtype) (wlc_hw_info_t * wlc_hw) {
+static bool BCMATTACHFN(wlc_validboardtype) (wlc_hw_info_t *wlc_hw) {
 	bool goodboard = TRUE;
 	uint boardrev = wlc_hw->boardrev;
 
@@ -2154,7 +2154,7 @@ static bool BCMATTACHFN(wlc_validboardty
 	return goodboard;
 }
 
-static char *BCMINITFN(wlc_get_macaddr) (wlc_hw_info_t * wlc_hw) {
+static char *BCMINITFN(wlc_get_macaddr) (wlc_hw_info_t *wlc_hw) {
 	const char *varname = "macaddr";
 	char *macaddr;
 
@@ -2180,7 +2180,7 @@ static char *BCMINITFN(wlc_get_macaddr)
  * this function could be called when driver is down and w/o clock
  * it operates on different registers depending on corerev and boardflag.
  */
-bool wlc_bmac_radio_read_hwdisabled(wlc_hw_info_t * wlc_hw)
+bool wlc_bmac_radio_read_hwdisabled(wlc_hw_info_t *wlc_hw)
 {
 	bool v, clk, xtal;
 	uint32 resetbits = 0, flags = 0;
@@ -2226,7 +2226,7 @@ bool wlc_bmac_radio_read_hwdisabled(wlc_
 }
 
 /* Initialize just the hardware when coming out of POR or S3/S5 system states */
-void BCMINITFN(wlc_bmac_hw_up) (wlc_hw_info_t * wlc_hw) {
+void BCMINITFN(wlc_bmac_hw_up) (wlc_hw_info_t *wlc_hw) {
 	if (wlc_hw->wlc->pub->hw_up)
 		return;
 
@@ -2267,7 +2267,7 @@ void BCMINITFN(wlc_bmac_hw_up) (wlc_hw_i
 	}
 }
 
-static bool wlc_dma_rxreset(wlc_hw_info_t * wlc_hw, uint fifo)
+static bool wlc_dma_rxreset(wlc_hw_info_t *wlc_hw, uint fifo)
 {
 	hnddma_t *di = wlc_hw->di[fifo];
 	osl_t *osh;
@@ -2300,7 +2300,7 @@ static bool wlc_dma_rxreset(wlc_hw_info_
  *   clear software macintstatus for fresh new start
  * one testing hack wlc_hw->noreset will bypass the d11/phy reset
  */
-void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t * wlc_hw, uint32 flags) {
+void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t *wlc_hw, uint32 flags) {
 	d11regs_t *regs;
 	uint i;
 	bool fastclk;
@@ -2387,7 +2387,7 @@ void BCMINITFN(wlc_bmac_corereset) (wlc_
  * txfifo sizes needs to be modified(increased) since the newer cores
  * have more memory.
  */
-static void BCMINITFN(wlc_corerev_fifofixup) (wlc_hw_info_t * wlc_hw) {
+static void BCMINITFN(wlc_corerev_fifofixup) (wlc_hw_info_t *wlc_hw) {
 	d11regs_t *regs = wlc_hw->regs;
 	uint16 fifo_nu;
 	uint16 txfifo_startblk = TXFIFO_START_BLK, txfifo_endblk;
@@ -2446,7 +2446,7 @@ static void BCMINITFN(wlc_corerev_fifofi
  *   config other core registers
  *   init dma
  */
-static void BCMINITFN(wlc_coreinit) (wlc_info_t * wlc) {
+static void BCMINITFN(wlc_coreinit) (wlc_info_t *wlc) {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs;
 	uint32 sflags;
@@ -2656,7 +2656,7 @@ static void BCMINITFN(wlc_coreinit) (wlc
  *  - 559241 = 0x88889 => tsf_clk_frac_h = 0x8, tsf_clk_frac_l = 0x8889
  */
 
-void wlc_bmac_switch_macfreq(wlc_hw_info_t * wlc_hw, uint8 spurmode)
+void wlc_bmac_switch_macfreq(wlc_hw_info_t *wlc_hw, uint8 spurmode)
 {
 	d11regs_t *regs;
 	osl_t *osh;
@@ -2687,7 +2687,7 @@ void wlc_bmac_switch_macfreq(wlc_hw_info
 }
 
 /* Initialize GPIOs that are controlled by D11 core */
-static void BCMINITFN(wlc_gpio_init) (wlc_info_t * wlc) {
+static void BCMINITFN(wlc_gpio_init) (wlc_info_t *wlc) {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs;
 	uint32 gc, gm;
@@ -2751,7 +2751,7 @@ static void BCMINITFN(wlc_gpio_init) (wl
 	si_gpiocontrol(wlc_hw->sih, gm, gc, GPIO_DRV_PRIORITY);
 }
 
-static void BCMATTACHFN(wlc_ucode_download) (wlc_hw_info_t * wlc_hw) {
+static void BCMATTACHFN(wlc_ucode_download) (wlc_hw_info_t *wlc_hw) {
 	wlc_info_t *wlc;
 	wlc = wlc_hw->wlc;
 
@@ -2779,7 +2779,7 @@ static void BCMATTACHFN(wlc_ucode_downlo
 }
 
 static void
-BCMATTACHFN(wlc_ucode_write) (wlc_hw_info_t * wlc_hw, const uint32 ucode[],
+BCMATTACHFN(wlc_ucode_write) (wlc_hw_info_t *wlc_hw, const uint32 ucode[],
 			      const uint nbytes) {
 	osl_t *osh;
 	d11regs_t *regs = wlc_hw->regs;
@@ -2800,7 +2800,7 @@ BCMATTACHFN(wlc_ucode_write) (wlc_hw_inf
 		W_REG(osh, &regs->objdata, ucode[i]);
 }
 
-static void wlc_write_inits(wlc_hw_info_t * wlc_hw, const d11init_t * inits)
+static void wlc_write_inits(wlc_hw_info_t *wlc_hw, const d11init_t *inits)
 {
 	int i;
 	osl_t *osh;
@@ -2823,7 +2823,7 @@ static void wlc_write_inits(wlc_hw_info_
 	}
 }
 
-static void wlc_ucode_txant_set(wlc_hw_info_t * wlc_hw)
+static void wlc_ucode_txant_set(wlc_hw_info_t *wlc_hw)
 {
 	uint16 phyctl;
 	uint16 phytxant = wlc_hw->bmac_phytxant;
@@ -2840,7 +2840,7 @@ static void wlc_ucode_txant_set(wlc_hw_i
 	wlc_bmac_write_shm(wlc_hw, M_RSP_PCTLWD, phyctl);
 }
 
-void wlc_bmac_txant_set(wlc_hw_info_t * wlc_hw, uint16 phytxant)
+void wlc_bmac_txant_set(wlc_hw_info_t *wlc_hw, uint16 phytxant)
 {
 	/* update sw state */
 	wlc_hw->bmac_phytxant = phytxant;
@@ -2852,12 +2852,12 @@ void wlc_bmac_txant_set(wlc_hw_info_t *
 
 }
 
-uint16 wlc_bmac_get_txant(wlc_hw_info_t * wlc_hw)
+uint16 wlc_bmac_get_txant(wlc_hw_info_t *wlc_hw)
 {
 	return (uint16) wlc_hw->wlc->stf->txant;
 }
 
-void wlc_bmac_antsel_type_set(wlc_hw_info_t * wlc_hw, uint8 antsel_type)
+void wlc_bmac_antsel_type_set(wlc_hw_info_t *wlc_hw, uint8 antsel_type)
 {
 	wlc_hw->antsel_type = antsel_type;
 
@@ -2865,7 +2865,7 @@ void wlc_bmac_antsel_type_set(wlc_hw_inf
 	wlc_phy_antsel_type_set(wlc_hw->band->pi, antsel_type);
 }
 
-void wlc_bmac_fifoerrors(wlc_hw_info_t * wlc_hw)
+void wlc_bmac_fifoerrors(wlc_hw_info_t *wlc_hw)
 {
 	bool fatal = FALSE;
 	uint unit;
@@ -2933,7 +2933,7 @@ void wlc_bmac_fifoerrors(wlc_hw_info_t *
 	}
 }
 
-void wlc_intrson(wlc_info_t * wlc)
+void wlc_intrson(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	ASSERT(wlc->defmacintmask);
@@ -2946,7 +2946,7 @@ void wlc_intrson(wlc_info_t * wlc)
  *  but also because per-port code may require sync with valid interrupt.
  */
 
-static uint32 wlc_wlintrsoff(wlc_info_t * wlc)
+static uint32 wlc_wlintrsoff(wlc_info_t *wlc)
 {
 	if (!wlc->hw->up)
 		return 0;
@@ -2954,7 +2954,7 @@ static uint32 wlc_wlintrsoff(wlc_info_t
 	return wl_intrsoff(wlc->wl);
 }
 
-static void wlc_wlintrsrestore(wlc_info_t * wlc, uint32 macintmask)
+static void wlc_wlintrsrestore(wlc_info_t *wlc, uint32 macintmask)
 {
 	if (!wlc->hw->up)
 		return;
@@ -2962,7 +2962,7 @@ static void wlc_wlintrsrestore(wlc_info_
 	wl_intrsrestore(wlc->wl, macintmask);
 }
 
-uint32 wlc_intrsoff(wlc_info_t * wlc)
+uint32 wlc_intrsoff(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	uint32 macintmask;
@@ -2981,7 +2981,7 @@ uint32 wlc_intrsoff(wlc_info_t * wlc)
 	return (wlc->macintstatus ? 0 : macintmask);
 }
 
-void wlc_intrsrestore(wlc_info_t * wlc, uint32 macintmask)
+void wlc_intrsrestore(wlc_info_t *wlc, uint32 macintmask)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	if (!wlc_hw->clk)
@@ -2991,7 +2991,7 @@ void wlc_intrsrestore(wlc_info_t * wlc,
 	W_REG(wlc_hw->osh, &wlc_hw->regs->macintmask, wlc->macintmask);
 }
 
-void wlc_bmac_mute(wlc_hw_info_t * wlc_hw, bool on, mbool flags)
+void wlc_bmac_mute(wlc_hw_info_t *wlc_hw, bool on, mbool flags)
 {
 	struct ether_addr null_ether_addr = { {0, 0, 0, 0, 0, 0} };
 
@@ -3027,12 +3027,12 @@ void wlc_bmac_mute(wlc_hw_info_t * wlc_h
 		wlc_ucode_mute_override_clear(wlc_hw);
 }
 
-void wlc_bmac_set_deaf(wlc_hw_info_t * wlc_hw, bool user_flag)
+void wlc_bmac_set_deaf(wlc_hw_info_t *wlc_hw, bool user_flag)
 {
 	wlc_phy_set_deaf(wlc_hw->band->pi, user_flag);
 }
 
-int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t * wlc_hw, uint fifo, uint * blocks)
+int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t *wlc_hw, uint fifo, uint *blocks)
 {
 	if (fifo >= NFIFO)
 		return BCME_RANGE;
@@ -3042,7 +3042,7 @@ int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_
 	return 0;
 }
 
-int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t * wlc_hw, uint fifo, uint blocks)
+int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t *wlc_hw, uint fifo, uint blocks)
 {
 	if (fifo >= NFIFO || blocks > 299)
 		return BCME_RANGE;
@@ -3062,7 +3062,7 @@ int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_
  * be pulling data into a tx fifo, by the time the MAC acks the suspend
  * request.
  */
-bool wlc_bmac_tx_fifo_suspended(wlc_hw_info_t * wlc_hw, uint tx_fifo)
+bool wlc_bmac_tx_fifo_suspended(wlc_hw_info_t *wlc_hw, uint tx_fifo)
 {
 	/* check that a suspend has been requested and is no longer pending */
 
@@ -3081,7 +3081,7 @@ bool wlc_bmac_tx_fifo_suspended(wlc_hw_i
 	return FALSE;
 }
 
-void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t * wlc_hw, uint tx_fifo)
+void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t *wlc_hw, uint tx_fifo)
 {
 	uint8 fifo = 1 << tx_fifo;
 
@@ -3112,7 +3112,7 @@ void wlc_bmac_tx_fifo_suspend(wlc_hw_inf
 	}
 }
 
-void wlc_bmac_tx_fifo_resume(wlc_hw_info_t * wlc_hw, uint tx_fifo)
+void wlc_bmac_tx_fifo_resume(wlc_hw_info_t *wlc_hw, uint tx_fifo)
 {
 	/* BMAC_NOTE: WLC_TX_FIFO_ENAB is done in wlc_dpc() for DMA case but need to be done
 	 * here for PIO otherwise the watchdog will catch the inconsistency and fire
@@ -3140,7 +3140,7 @@ void wlc_bmac_tx_fifo_resume(wlc_hw_info
  *   0 if the interrupt is not for us, or we are in some special cases;
  *   device interrupt status bits otherwise.
  */
-static INLINE uint32 wlc_intstatus(wlc_info_t * wlc, bool in_isr)
+static INLINE uint32 wlc_intstatus(wlc_info_t *wlc, bool in_isr)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
@@ -3232,7 +3232,7 @@ static INLINE uint32 wlc_intstatus(wlc_i
 
 /* Update wlc->macintstatus and wlc->intstatus[]. */
 /* Return TRUE if they are updated successfully. FALSE otherwise */
-bool wlc_intrsupd(wlc_info_t * wlc)
+bool wlc_intrsupd(wlc_info_t *wlc)
 {
 	uint32 macintstatus;
 
@@ -3257,7 +3257,7 @@ bool wlc_intrsupd(wlc_info_t * wlc)
  * *wantdpc will be set to TRUE if further wlc_dpc() processing is required,
  * FALSE otherwise.
  */
-bool BCMFASTPATH wlc_isr(wlc_info_t * wlc, bool * wantdpc)
+bool BCMFASTPATH wlc_isr(wlc_info_t *wlc, bool *wantdpc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	uint32 macintstatus;
@@ -3288,7 +3288,7 @@ bool BCMFASTPATH wlc_isr(wlc_info_t * wl
 }
 
 /* process tx completion events for corerev < 5 */
-static bool wlc_bmac_txstatus_corerev4(wlc_hw_info_t * wlc_hw)
+static bool wlc_bmac_txstatus_corerev4(wlc_hw_info_t *wlc_hw)
 {
 	void *status_p;
 	tx_status_t *txs;
@@ -3324,7 +3324,7 @@ static bool wlc_bmac_txstatus_corerev4(w
 }
 
 static bool BCMFASTPATH
-wlc_bmac_dotxstatus(wlc_hw_info_t * wlc_hw, tx_status_t * txs, uint32 s2)
+wlc_bmac_dotxstatus(wlc_hw_info_t *wlc_hw, tx_status_t *txs, uint32 s2)
 {
 	/* discard intermediate indications for ucode with one legitimate case:
 	 *   e.g. if "useRTS" is set. ucode did a successful rts/cts exchange, but the subsequent
@@ -3343,7 +3343,7 @@ wlc_bmac_dotxstatus(wlc_hw_info_t * wlc_
  * Return TRUE if more tx status need to be processed. FALSE otherwise.
  */
 static bool BCMFASTPATH
-wlc_bmac_txstatus(wlc_hw_info_t * wlc_hw, bool bound, bool * fatal)
+wlc_bmac_txstatus(wlc_hw_info_t *wlc_hw, bool bound, bool *fatal)
 {
 	bool morepending = FALSE;
 	wlc_info_t *wlc = wlc_hw->wlc;
@@ -3407,7 +3407,7 @@ wlc_bmac_txstatus(wlc_hw_info_t * wlc_hw
 	return morepending;
 }
 
-void wlc_suspend_mac_and_wait(wlc_info_t * wlc)
+void wlc_suspend_mac_and_wait(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
@@ -3471,7 +3471,7 @@ void wlc_suspend_mac_and_wait(wlc_info_t
 	ASSERT(!(mc & MCTL_EN_MAC));
 }
 
-void wlc_enable_mac(wlc_info_t * wlc)
+void wlc_enable_mac(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	d11regs_t *regs = wlc_hw->regs;
@@ -3510,7 +3510,7 @@ void wlc_enable_mac(wlc_info_t * wlc)
 	wlc_ucode_wake_override_clear(wlc_hw, WLC_WAKE_OVERRIDE_MACSUSPEND);
 }
 
-void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t * wlc_hw, bool abie, bool isht)
+void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t *wlc_hw, bool abie, bool isht)
 {
 	if (!(WLCISNPHY(wlc_hw->band) && (D11REV_GE(wlc_hw->corerev, 16))))
 		return;
@@ -3546,7 +3546,7 @@ void wlc_bmac_ifsctl_edcrs_set(wlc_hw_in
 	}
 }
 
-static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t * wlc_hw)
+static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t *wlc_hw)
 {
 	uint8 rate;
 	uint8 rates[8] = {
@@ -3580,7 +3580,7 @@ static void wlc_upd_ofdm_pctl1_table(wlc
 	}
 }
 
-static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t * wlc_hw, uint8 rate)
+static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t *wlc_hw, uint8 rate)
 {
 	uint i;
 	uint8 plcp_rate = 0;
@@ -3613,7 +3613,7 @@ static uint16 wlc_bmac_ofdm_ratetable_of
 	return (2 * wlc_bmac_read_shm(wlc_hw, M_RT_DIRMAP_A + (plcp_rate * 2)));
 }
 
-void wlc_bmac_band_stf_ss_set(wlc_hw_info_t * wlc_hw, uint8 stf_mode)
+void wlc_bmac_band_stf_ss_set(wlc_hw_info_t *wlc_hw, uint8 stf_mode)
 {
 	wlc_hw->hw_stf_ss_opmode = stf_mode;
 
@@ -3622,8 +3622,8 @@ void wlc_bmac_band_stf_ss_set(wlc_hw_inf
 }
 
 void BCMFASTPATH
-wlc_bmac_read_tsf(wlc_hw_info_t * wlc_hw, uint32 * tsf_l_ptr,
-		  uint32 * tsf_h_ptr)
+wlc_bmac_read_tsf(wlc_hw_info_t *wlc_hw, uint32 *tsf_l_ptr,
+		  uint32 *tsf_h_ptr)
 {
 	d11regs_t *regs = wlc_hw->regs;
 
@@ -3634,7 +3634,7 @@ wlc_bmac_read_tsf(wlc_hw_info_t * wlc_hw
 	return;
 }
 
-bool BCMATTACHFN(wlc_bmac_validate_chip_access) (wlc_hw_info_t * wlc_hw) {
+bool BCMATTACHFN(wlc_bmac_validate_chip_access) (wlc_hw_info_t *wlc_hw) {
 	d11regs_t *regs;
 	uint32 w, val;
 	volatile uint16 *reg16;
@@ -3728,7 +3728,7 @@ bool BCMATTACHFN(wlc_bmac_validate_chip_
 
 #define PHYPLL_WAIT_US	100000
 
-void wlc_bmac_core_phypll_ctl(wlc_hw_info_t * wlc_hw, bool on)
+void wlc_bmac_core_phypll_ctl(wlc_hw_info_t *wlc_hw, bool on)
 {
 	d11regs_t *regs;
 	osl_t *osh;
@@ -3787,7 +3787,7 @@ void wlc_bmac_core_phypll_ctl(wlc_hw_inf
 	}
 }
 
-void wlc_coredisable(wlc_hw_info_t * wlc_hw)
+void wlc_coredisable(wlc_hw_info_t *wlc_hw)
 {
 	bool dev_gone;
 
@@ -3827,7 +3827,7 @@ void wlc_coredisable(wlc_hw_info_t * wlc
 }
 
 /* power both the pll and external oscillator on/off */
-void wlc_bmac_xtal(wlc_hw_info_t * wlc_hw, bool want)
+void wlc_bmac_xtal(wlc_hw_info_t *wlc_hw, bool want)
 {
 	WL_TRACE(("wl%d: wlc_bmac_xtal: want %d\n", wlc_hw->unit, want));
 
@@ -3846,7 +3846,7 @@ void wlc_bmac_xtal(wlc_hw_info_t * wlc_h
 	}
 }
 
-static void wlc_flushqueues(wlc_info_t * wlc)
+static void wlc_flushqueues(wlc_info_t *wlc)
 {
 	wlc_hw_info_t *wlc_hw = wlc->hw;
 	uint i;
@@ -3868,12 +3868,12 @@ static void wlc_flushqueues(wlc_info_t *
 		dma_rxreclaim(wlc_hw->di[RX_TXSTATUS_FIFO]);
 }
 
-uint16 wlc_bmac_read_shm(wlc_hw_info_t * wlc_hw, uint offset)
+uint16 wlc_bmac_read_shm(wlc_hw_info_t *wlc_hw, uint offset)
 {
 	return wlc_bmac_read_objmem(wlc_hw, offset, OBJADDR_SHM_SEL);
 }
 
-void wlc_bmac_write_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v)
+void wlc_bmac_write_shm(wlc_hw_info_t *wlc_hw, uint offset, uint16 v)
 {
 	wlc_bmac_write_objmem(wlc_hw, offset, v, OBJADDR_SHM_SEL);
 }
@@ -3882,7 +3882,7 @@ void wlc_bmac_write_shm(wlc_hw_info_t *
  * SHM 'offset' needs to be an even address and
  * Buffer length 'len' must be an even number of bytes
  */
-void wlc_bmac_set_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v, int len)
+void wlc_bmac_set_shm(wlc_hw_info_t *wlc_hw, uint offset, uint16 v, int len)
 {
 	int i;
 
@@ -3899,7 +3899,7 @@ void wlc_bmac_set_shm(wlc_hw_info_t * wl
 }
 
 static uint16
-wlc_bmac_read_objmem(wlc_hw_info_t * wlc_hw, uint offset, uint32 sel)
+wlc_bmac_read_objmem(wlc_hw_info_t *wlc_hw, uint offset, uint32 sel)
 {
 	d11regs_t *regs = wlc_hw->regs;
 	volatile uint16 *objdata_lo =
@@ -3921,7 +3921,7 @@ wlc_bmac_read_objmem(wlc_hw_info_t * wlc
 }
 
 static void
-wlc_bmac_write_objmem(wlc_hw_info_t * wlc_hw, uint offset, uint16 v, uint32 sel)
+wlc_bmac_write_objmem(wlc_hw_info_t *wlc_hw, uint offset, uint16 v, uint32 sel)
 {
 	d11regs_t *regs = wlc_hw->regs;
 	volatile uint16 *objdata_lo =
@@ -3945,7 +3945,7 @@ wlc_bmac_write_objmem(wlc_hw_info_t * wl
  * 'sel' selects the type of memory
  */
 void
-wlc_bmac_copyto_objmem(wlc_hw_info_t * wlc_hw, uint offset, const void *buf,
+wlc_bmac_copyto_objmem(wlc_hw_info_t *wlc_hw, uint offset, const void *buf,
 		       int len, uint32 sel)
 {
 	uint16 v;
@@ -3971,7 +3971,7 @@ wlc_bmac_copyto_objmem(wlc_hw_info_t * w
  * 'sel' selects the type of memory
  */
 void
-wlc_bmac_copyfrom_objmem(wlc_hw_info_t * wlc_hw, uint offset, void *buf,
+wlc_bmac_copyfrom_objmem(wlc_hw_info_t *wlc_hw, uint offset, void *buf,
 			 int len, uint32 sel)
 {
 	uint16 v;
@@ -3992,7 +3992,7 @@ wlc_bmac_copyfrom_objmem(wlc_hw_info_t *
 	}
 }
 
-void wlc_bmac_copyfrom_vars(wlc_hw_info_t * wlc_hw, char **buf, uint * len)
+void wlc_bmac_copyfrom_vars(wlc_hw_info_t *wlc_hw, char **buf, uint *len)
 {
 	WL_TRACE(("wlc_bmac_copyfrom_vars, nvram vars totlen=%d\n",
 		  wlc_hw->vars_size));
@@ -4001,7 +4001,7 @@ void wlc_bmac_copyfrom_vars(wlc_hw_info_
 	*len = wlc_hw->vars_size;
 }
 
-void wlc_bmac_retrylimit_upd(wlc_hw_info_t * wlc_hw, uint16 SRL, uint16 LRL)
+void wlc_bmac_retrylimit_upd(wlc_hw_info_t *wlc_hw, uint16 SRL, uint16 LRL)
 {
 	wlc_hw->SRL = SRL;
 	wlc_hw->LRL = LRL;
@@ -4019,17 +4019,17 @@ void wlc_bmac_retrylimit_upd(wlc_hw_info
 	}
 }
 
-void wlc_bmac_set_noreset(wlc_hw_info_t * wlc_hw, bool noreset_flag)
+void wlc_bmac_set_noreset(wlc_hw_info_t *wlc_hw, bool noreset_flag)
 {
 	wlc_hw->noreset = noreset_flag;
 }
 
-void wlc_bmac_set_ucode_loaded(wlc_hw_info_t * wlc_hw, bool ucode_loaded)
+void wlc_bmac_set_ucode_loaded(wlc_hw_info_t *wlc_hw, bool ucode_loaded)
 {
 	wlc_hw->ucode_loaded = ucode_loaded;
 }
 
-void wlc_bmac_pllreq(wlc_hw_info_t * wlc_hw, bool set, mbool req_bit)
+void wlc_bmac_pllreq(wlc_hw_info_t *wlc_hw, bool set, mbool req_bit)
 {
 	ASSERT(req_bit);
 
@@ -4060,7 +4060,7 @@ void wlc_bmac_pllreq(wlc_hw_info_t * wlc
 	return;
 }
 
-void wlc_bmac_set_clk(wlc_hw_info_t * wlc_hw, bool on)
+void wlc_bmac_set_clk(wlc_hw_info_t *wlc_hw, bool on)
 {
 	if (on) {
 		/* power up pll and oscillator */
@@ -4082,7 +4082,7 @@ void wlc_bmac_set_clk(wlc_hw_info_t * wl
 }
 
 /* this will be true for all ai chips */
-bool wlc_bmac_taclear(wlc_hw_info_t * wlc_hw, bool ta_ok)
+bool wlc_bmac_taclear(wlc_hw_info_t *wlc_hw, bool ta_ok)
 {
 	return TRUE;
 }
@@ -4090,7 +4090,7 @@ bool wlc_bmac_taclear(wlc_hw_info_t * wl
 /* Lower down relevant GPIOs like LED when going down w/o
  * doing PCI config cycles or touching interrupts
  */
-void wlc_gpio_fast_deinit(wlc_hw_info_t * wlc_hw)
+void wlc_gpio_fast_deinit(wlc_hw_info_t *wlc_hw)
 {
 	if ((wlc_hw == NULL) || (wlc_hw->sih == NULL))
 		return;
@@ -4108,7 +4108,7 @@ void wlc_gpio_fast_deinit(wlc_hw_info_t
 	return;
 }
 
-bool wlc_bmac_radio_hw(wlc_hw_info_t * wlc_hw, bool enable)
+bool wlc_bmac_radio_hw(wlc_hw_info_t *wlc_hw, bool enable)
 {
 	/* Do not access Phy registers if core is not up */
 	if (si_iscoreup(wlc_hw->sih) == FALSE)
@@ -4143,7 +4143,7 @@ bool wlc_bmac_radio_hw(wlc_hw_info_t * w
 	return TRUE;
 }
 
-uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t * wlc_hw, uint8 rate)
+uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, uint8 rate)
 {
 	uint16 table_ptr;
 	uint8 phy_rate, index;
@@ -4167,12 +4167,12 @@ uint16 wlc_bmac_rate_shm_offset(wlc_hw_i
 	return (2 * wlc_bmac_read_shm(wlc_hw, table_ptr + (index * 2)));
 }
 
-void wlc_bmac_set_txpwr_percent(wlc_hw_info_t * wlc_hw, uint8 val)
+void wlc_bmac_set_txpwr_percent(wlc_hw_info_t *wlc_hw, uint8 val)
 {
 	wlc_phy_txpwr_percent_set(wlc_hw->band->pi, val);
 }
 
-void wlc_bmac_antsel_set(wlc_hw_info_t * wlc_hw, uint32 antsel_avail)
+void wlc_bmac_antsel_set(wlc_hw_info_t *wlc_hw, uint32 antsel_avail)
 {
 	wlc_hw->antsel_avail = antsel_avail;
 }
--- a/drivers/staging/brcm80211/sys/wlc_bmac.h
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.h
@@ -130,148 +130,148 @@ typedef enum {
 	WLCHW_STATE_LAST
 } wlc_bmac_state_id_t;
 
-extern int wlc_bmac_attach(wlc_info_t * wlc, uint16 vendor, uint16 device,
-			   uint unit, bool piomode, osl_t * osh, void *regsva,
+extern int wlc_bmac_attach(wlc_info_t *wlc, uint16 vendor, uint16 device,
+			   uint unit, bool piomode, osl_t *osh, void *regsva,
 			   uint bustype, void *btparam);
-extern int wlc_bmac_detach(wlc_info_t * wlc);
+extern int wlc_bmac_detach(wlc_info_t *wlc);
 extern void wlc_bmac_watchdog(void *arg);
-extern void wlc_bmac_info_init(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_info_init(wlc_hw_info_t *wlc_hw);
 
 /* up/down, reset, clk */
 #ifdef WLC_LOW
-extern void wlc_bmac_xtal(wlc_hw_info_t * wlc_hw, bool want);
+extern void wlc_bmac_xtal(wlc_hw_info_t *wlc_hw, bool want);
 #endif
 
-extern void wlc_bmac_copyto_objmem(wlc_hw_info_t * wlc_hw,
+extern void wlc_bmac_copyto_objmem(wlc_hw_info_t *wlc_hw,
 				   uint offset, const void *buf, int len,
 				   uint32 sel);
-extern void wlc_bmac_copyfrom_objmem(wlc_hw_info_t * wlc_hw, uint offset,
+extern void wlc_bmac_copyfrom_objmem(wlc_hw_info_t *wlc_hw, uint offset,
 				     void *buf, int len, uint32 sel);
 #define wlc_bmac_copyfrom_shm(wlc_hw, offset, buf, len)                 \
 	wlc_bmac_copyfrom_objmem(wlc_hw, offset, buf, len, OBJADDR_SHM_SEL)
 #define wlc_bmac_copyto_shm(wlc_hw, offset, buf, len)                   \
 	wlc_bmac_copyto_objmem(wlc_hw, offset, buf, len, OBJADDR_SHM_SEL)
 
-extern void wlc_bmac_core_phy_clk(wlc_hw_info_t * wlc_hw, bool clk);
-extern void wlc_bmac_core_phypll_reset(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_core_phypll_ctl(wlc_hw_info_t * wlc_hw, bool on);
-extern void wlc_bmac_phyclk_fgc(wlc_hw_info_t * wlc_hw, bool clk);
-extern void wlc_bmac_macphyclk_set(wlc_hw_info_t * wlc_hw, bool clk);
-extern void wlc_bmac_phy_reset(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_corereset(wlc_hw_info_t * wlc_hw, uint32 flags);
-extern void wlc_bmac_reset(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_init(wlc_hw_info_t * wlc_hw, chanspec_t chanspec,
+extern void wlc_bmac_core_phy_clk(wlc_hw_info_t *wlc_hw, bool clk);
+extern void wlc_bmac_core_phypll_reset(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_core_phypll_ctl(wlc_hw_info_t *wlc_hw, bool on);
+extern void wlc_bmac_phyclk_fgc(wlc_hw_info_t *wlc_hw, bool clk);
+extern void wlc_bmac_macphyclk_set(wlc_hw_info_t *wlc_hw, bool clk);
+extern void wlc_bmac_phy_reset(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_corereset(wlc_hw_info_t *wlc_hw, uint32 flags);
+extern void wlc_bmac_reset(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_init(wlc_hw_info_t *wlc_hw, chanspec_t chanspec,
 			  bool mute);
-extern int wlc_bmac_up_prep(wlc_hw_info_t * wlc_hw);
-extern int wlc_bmac_up_finish(wlc_hw_info_t * wlc_hw);
-extern int wlc_bmac_down_prep(wlc_hw_info_t * wlc_hw);
-extern int wlc_bmac_down_finish(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_corereset(wlc_hw_info_t * wlc_hw, uint32 flags);
-extern void wlc_bmac_switch_macfreq(wlc_hw_info_t * wlc_hw, uint8 spurmode);
+extern int wlc_bmac_up_prep(wlc_hw_info_t *wlc_hw);
+extern int wlc_bmac_up_finish(wlc_hw_info_t *wlc_hw);
+extern int wlc_bmac_down_prep(wlc_hw_info_t *wlc_hw);
+extern int wlc_bmac_down_finish(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_corereset(wlc_hw_info_t *wlc_hw, uint32 flags);
+extern void wlc_bmac_switch_macfreq(wlc_hw_info_t *wlc_hw, uint8 spurmode);
 
 /* chanspec, ucode interface */
-extern int wlc_bmac_bandtype(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_set_chanspec(wlc_hw_info_t * wlc_hw, chanspec_t chanspec,
+extern int wlc_bmac_bandtype(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_set_chanspec(wlc_hw_info_t *wlc_hw, chanspec_t chanspec,
 				  bool mute, struct txpwr_limits *txpwr);
 
-extern void wlc_bmac_txfifo(wlc_hw_info_t * wlc_hw, uint fifo, void *p,
+extern void wlc_bmac_txfifo(wlc_hw_info_t *wlc_hw, uint fifo, void *p,
 			    bool commit, uint16 frameid, uint8 txpktpend);
-extern int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t * wlc_hw, uint fifo,
-				   uint * blocks);
-extern void wlc_bmac_mhf(wlc_hw_info_t * wlc_hw, uint8 idx, uint16 mask,
+extern int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t *wlc_hw, uint fifo,
+				   uint *blocks);
+extern void wlc_bmac_mhf(wlc_hw_info_t *wlc_hw, uint8 idx, uint16 mask,
 			 uint16 val, int bands);
-extern void wlc_bmac_mctrl(wlc_hw_info_t * wlc_hw, uint32 mask, uint32 val);
-extern uint16 wlc_bmac_mhf_get(wlc_hw_info_t * wlc_hw, uint8 idx, int bands);
-extern int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t * wlc_hw, uint fifo,
+extern void wlc_bmac_mctrl(wlc_hw_info_t *wlc_hw, uint32 mask, uint32 val);
+extern uint16 wlc_bmac_mhf_get(wlc_hw_info_t *wlc_hw, uint8 idx, int bands);
+extern int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t *wlc_hw, uint fifo,
 				   uint blocks);
-extern void wlc_bmac_txant_set(wlc_hw_info_t * wlc_hw, uint16 phytxant);
-extern uint16 wlc_bmac_get_txant(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_antsel_type_set(wlc_hw_info_t * wlc_hw, uint8 antsel_type);
-extern int wlc_bmac_revinfo_get(wlc_hw_info_t * wlc_hw,
-				wlc_bmac_revinfo_t * revinfo);
-extern int wlc_bmac_state_get(wlc_hw_info_t * wlc_hw, wlc_bmac_state_t * state);
-extern void wlc_bmac_write_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v);
-extern uint16 wlc_bmac_read_shm(wlc_hw_info_t * wlc_hw, uint offset);
-extern void wlc_bmac_set_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v,
+extern void wlc_bmac_txant_set(wlc_hw_info_t *wlc_hw, uint16 phytxant);
+extern uint16 wlc_bmac_get_txant(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_antsel_type_set(wlc_hw_info_t *wlc_hw, uint8 antsel_type);
+extern int wlc_bmac_revinfo_get(wlc_hw_info_t *wlc_hw,
+				wlc_bmac_revinfo_t *revinfo);
+extern int wlc_bmac_state_get(wlc_hw_info_t *wlc_hw, wlc_bmac_state_t *state);
+extern void wlc_bmac_write_shm(wlc_hw_info_t *wlc_hw, uint offset, uint16 v);
+extern uint16 wlc_bmac_read_shm(wlc_hw_info_t *wlc_hw, uint offset);
+extern void wlc_bmac_set_shm(wlc_hw_info_t *wlc_hw, uint offset, uint16 v,
 			     int len);
-extern void wlc_bmac_write_template_ram(wlc_hw_info_t * wlc_hw, int offset,
+extern void wlc_bmac_write_template_ram(wlc_hw_info_t *wlc_hw, int offset,
 					int len, void *buf);
-extern void wlc_bmac_copyfrom_vars(wlc_hw_info_t * wlc_hw, char **buf,
-				   uint * len);
+extern void wlc_bmac_copyfrom_vars(wlc_hw_info_t *wlc_hw, char **buf,
+				   uint *len);
 
-extern void wlc_bmac_process_ps_switch(wlc_hw_info_t * wlc,
+extern void wlc_bmac_process_ps_switch(wlc_hw_info_t *wlc,
 				       struct ether_addr *ea, int8 ps_on);
-extern void wlc_bmac_hw_etheraddr(wlc_hw_info_t * wlc_hw,
+extern void wlc_bmac_hw_etheraddr(wlc_hw_info_t *wlc_hw,
 				  struct ether_addr *ea);
-extern void wlc_bmac_set_hw_etheraddr(wlc_hw_info_t * wlc_hw,
+extern void wlc_bmac_set_hw_etheraddr(wlc_hw_info_t *wlc_hw,
 				      struct ether_addr *ea);
-extern bool wlc_bmac_validate_chip_access(wlc_hw_info_t * wlc_hw);
+extern bool wlc_bmac_validate_chip_access(wlc_hw_info_t *wlc_hw);
 
-extern bool wlc_bmac_radio_read_hwdisabled(wlc_hw_info_t * wlc_hw);
-extern void wlc_bmac_set_shortslot(wlc_hw_info_t * wlc_hw, bool shortslot);
-extern void wlc_bmac_mute(wlc_hw_info_t * wlc_hw, bool want, mbool flags);
-extern void wlc_bmac_set_deaf(wlc_hw_info_t * wlc_hw, bool user_flag);
-extern void wlc_bmac_band_stf_ss_set(wlc_hw_info_t * wlc_hw, uint8 stf_mode);
-
-extern void wlc_bmac_wait_for_wake(wlc_hw_info_t * wlc_hw);
-extern bool wlc_bmac_tx_fifo_suspended(wlc_hw_info_t * wlc_hw, uint tx_fifo);
-extern void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t * wlc_hw, uint tx_fifo);
-extern void wlc_bmac_tx_fifo_resume(wlc_hw_info_t * wlc_hw, uint tx_fifo);
+extern bool wlc_bmac_radio_read_hwdisabled(wlc_hw_info_t *wlc_hw);
+extern void wlc_bmac_set_shortslot(wlc_hw_info_t *wlc_hw, bool shortslot);
+extern void wlc_bmac_mute(wlc_hw_info_t *wlc_hw, bool want, mbool flags);
+extern void wlc_bmac_set_deaf(wlc_hw_info_t *wlc_hw, bool user_flag);
+extern void wlc_bmac_band_stf_ss_set(wlc_hw_info_t *wlc_hw, uint8 stf_mode);
+
+extern void wlc_bmac_wait_for_wake(wlc_hw_info_t *wlc_hw);
+extern bool wlc_bmac_tx_fifo_suspended(wlc_hw_info_t *wlc_hw, uint tx_fifo);
+extern void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t *wlc_hw, uint tx_fifo);
+extern void wlc_bmac_tx_fifo_resume(wlc_hw_info_t *wlc_hw, uint tx_fifo);
 
-extern void wlc_ucode_wake_override_set(wlc_hw_info_t * wlc_hw,
+extern void wlc_ucode_wake_override_set(wlc_hw_info_t *wlc_hw,
 					uint32 override_bit);
-extern void wlc_ucode_wake_override_clear(wlc_hw_info_t * wlc_hw,
+extern void wlc_ucode_wake_override_clear(wlc_hw_info_t *wlc_hw,
 					  uint32 override_bit);
 
-extern void wlc_bmac_set_rcmta(wlc_hw_info_t * wlc_hw, int idx,
+extern void wlc_bmac_set_rcmta(wlc_hw_info_t *wlc_hw, int idx,
 			       const struct ether_addr *addr);
-extern void wlc_bmac_set_addrmatch(wlc_hw_info_t * wlc_hw, int match_reg_offset,
+extern void wlc_bmac_set_addrmatch(wlc_hw_info_t *wlc_hw, int match_reg_offset,
 				   const struct ether_addr *addr);
-extern void wlc_bmac_write_hw_bcntemplates(wlc_hw_info_t * wlc_hw, void *bcn,
+extern void wlc_bmac_write_hw_bcntemplates(wlc_hw_info_t *wlc_hw, void *bcn,
 					   int len, bool both);
 
-extern void wlc_bmac_read_tsf(wlc_hw_info_t * wlc_hw, uint32 * tsf_l_ptr,
-			      uint32 * tsf_h_ptr);
-extern void wlc_bmac_set_cwmin(wlc_hw_info_t * wlc_hw, uint16 newmin);
-extern void wlc_bmac_set_cwmax(wlc_hw_info_t * wlc_hw, uint16 newmax);
-extern void wlc_bmac_set_noreset(wlc_hw_info_t * wlc, bool noreset_flag);
-extern void wlc_bmac_set_ucode_loaded(wlc_hw_info_t * wlc, bool ucode_loaded);
+extern void wlc_bmac_read_tsf(wlc_hw_info_t *wlc_hw, uint32 *tsf_l_ptr,
+			      uint32 *tsf_h_ptr);
+extern void wlc_bmac_set_cwmin(wlc_hw_info_t *wlc_hw, uint16 newmin);
+extern void wlc_bmac_set_cwmax(wlc_hw_info_t *wlc_hw, uint16 newmax);
+extern void wlc_bmac_set_noreset(wlc_hw_info_t *wlc, bool noreset_flag);
+extern void wlc_bmac_set_ucode_loaded(wlc_hw_info_t *wlc, bool ucode_loaded);
 
-extern void wlc_bmac_retrylimit_upd(wlc_hw_info_t * wlc_hw, uint16 SRL,
+extern void wlc_bmac_retrylimit_upd(wlc_hw_info_t *wlc_hw, uint16 SRL,
 				    uint16 LRL);
 
-extern void wlc_bmac_fifoerrors(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_fifoerrors(wlc_hw_info_t *wlc_hw);
 
 #ifdef WLC_HIGH_ONLY
 extern void wlc_bmac_dngl_reboot(rpc_info_t *);
 extern void wlc_bmac_dngl_rpc_agg(rpc_info_t *, uint16 agg);
 extern void wlc_bmac_dngl_rpc_msglevel(rpc_info_t *, uint16 level);
-extern void wlc_bmac_dngl_rpc_txq_wm_set(rpc_info_t * rpc, uint32 wm);
-extern void wlc_bmac_dngl_rpc_txq_wm_get(rpc_info_t * rpc, uint32 * wm);
-extern void wlc_bmac_dngl_rpc_agg_limit_set(rpc_info_t * rpc, uint32 val);
-extern void wlc_bmac_dngl_rpc_agg_limit_get(rpc_info_t * rpc, uint32 * pval);
-extern int wlc_bmac_debug_template(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_dngl_rpc_txq_wm_set(rpc_info_t *rpc, uint32 wm);
+extern void wlc_bmac_dngl_rpc_txq_wm_get(rpc_info_t *rpc, uint32 *wm);
+extern void wlc_bmac_dngl_rpc_agg_limit_set(rpc_info_t *rpc, uint32 val);
+extern void wlc_bmac_dngl_rpc_agg_limit_get(rpc_info_t *rpc, uint32 *pval);
+extern int wlc_bmac_debug_template(wlc_hw_info_t *wlc_hw);
 #endif
 
 /* API for BMAC driver (e.g. wlc_phy.c etc) */
 
-extern void wlc_bmac_bw_set(wlc_hw_info_t * wlc_hw, uint16 bw);
-extern void wlc_bmac_pllreq(wlc_hw_info_t * wlc_hw, bool set, mbool req_bit);
-extern void wlc_bmac_set_clk(wlc_hw_info_t * wlc_hw, bool on);
-extern bool wlc_bmac_taclear(wlc_hw_info_t * wlc_hw, bool ta_ok);
+extern void wlc_bmac_bw_set(wlc_hw_info_t *wlc_hw, uint16 bw);
+extern void wlc_bmac_pllreq(wlc_hw_info_t *wlc_hw, bool set, mbool req_bit);
+extern void wlc_bmac_set_clk(wlc_hw_info_t *wlc_hw, bool on);
+extern bool wlc_bmac_taclear(wlc_hw_info_t *wlc_hw, bool ta_ok);
 extern void wlc_bmac_hw_up(struct wlc_hw_info *wlc_hw);
 
-extern void wlc_bmac_dump(wlc_hw_info_t * wlc_hw, struct bcmstrbuf *b,
+extern void wlc_bmac_dump(wlc_hw_info_t *wlc_hw, struct bcmstrbuf *b,
 			  wlc_bmac_dump_id_t dump_id);
-extern void wlc_gpio_fast_deinit(wlc_hw_info_t * wlc_hw);
+extern void wlc_gpio_fast_deinit(wlc_hw_info_t *wlc_hw);
 
-extern bool wlc_bmac_radio_hw(wlc_hw_info_t * wlc_hw, bool enable);
-extern uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t * wlc_hw, uint8 rate);
+extern bool wlc_bmac_radio_hw(wlc_hw_info_t *wlc_hw, bool enable);
+extern uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t *wlc_hw, uint8 rate);
 
-extern void wlc_bmac_assert_type_set(wlc_hw_info_t * wlc_hw, uint32 type);
-extern void wlc_bmac_set_txpwr_percent(wlc_hw_info_t * wlc_hw, uint8 val);
-extern void wlc_bmac_blink_sync(wlc_hw_info_t * wlc_hw, uint32 led_pins);
-extern void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t * wlc_hw, bool abie,
+extern void wlc_bmac_assert_type_set(wlc_hw_info_t *wlc_hw, uint32 type);
+extern void wlc_bmac_set_txpwr_percent(wlc_hw_info_t *wlc_hw, uint8 val);
+extern void wlc_bmac_blink_sync(wlc_hw_info_t *wlc_hw, uint32 led_pins);
+extern void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t *wlc_hw, bool abie,
 				      bool isht);
 
-extern void wlc_bmac_antsel_set(wlc_hw_info_t * wlc_hw, uint32 antsel_avail);
+extern void wlc_bmac_antsel_set(wlc_hw_info_t *wlc_hw, uint32 antsel_avail);
--- a/drivers/staging/brcm80211/sys/wlc_channel.c
+++ b/drivers/staging/brcm80211/sys/wlc_channel.c
@@ -50,21 +50,21 @@ struct wlc_cm_info {
 	chanvec_t quiet_channels;	/* channels on which we cannot transmit */
 };
 
-static int wlc_channels_init(wlc_cm_info_t * wlc_cm,
-			     const country_info_t * country);
-static void wlc_set_country_common(wlc_cm_info_t * wlc_cm,
+static int wlc_channels_init(wlc_cm_info_t *wlc_cm,
+			     const country_info_t *country);
+static void wlc_set_country_common(wlc_cm_info_t *wlc_cm,
 				   const char *country_abbrev,
 				   const char *ccode, uint regrev,
-				   const country_info_t * country);
-static int wlc_country_aggregate_map(wlc_cm_info_t * wlc_cm, const char *ccode,
-				     char *mapped_ccode, uint * mapped_regrev);
+				   const country_info_t *country);
+static int wlc_country_aggregate_map(wlc_cm_info_t *wlc_cm, const char *ccode,
+				     char *mapped_ccode, uint *mapped_regrev);
 static const country_info_t *wlc_country_lookup_direct(const char *ccode,
 						       uint regrev);
-static const country_info_t *wlc_countrycode_map(wlc_cm_info_t * wlc_cm,
+static const country_info_t *wlc_countrycode_map(wlc_cm_info_t *wlc_cm,
 						 const char *ccode,
 						 char *mapped_ccode,
-						 uint * mapped_regrev);
-static void wlc_channels_commit(wlc_cm_info_t * wlc_cm);
+						 uint *mapped_regrev);
+static void wlc_channels_commit(wlc_cm_info_t *wlc_cm);
 static bool wlc_japan_ccode(const char *ccode);
 static void wlc_channel_min_txpower_limits_with_local_constraint(wlc_cm_info_t *
 								 wlc_cm,
@@ -73,7 +73,7 @@ static void wlc_channel_min_txpower_limi
 								 *txpwr,
 								 uint8
 								 local_constraint_qdbm);
-void wlc_locale_add_channels(chanvec_t * target, const chanvec_t * channels);
+void wlc_locale_add_channels(chanvec_t *target, const chanvec_t *channels);
 static const locale_mimo_info_t *wlc_get_mimo_2g(uint8 locale_idx);
 static const locale_mimo_info_t *wlc_get_mimo_5g(uint8 locale_idx);
 
@@ -363,7 +363,7 @@ static const chanvec_t *g_table_locale_b
 	&locale_5g_HIGH4
 };
 
-void wlc_locale_add_channels(chanvec_t * target, const chanvec_t * channels)
+void wlc_locale_add_channels(chanvec_t *target, const chanvec_t *channels)
 {
 	uint8 i;
 	for (i = 0; i < sizeof(chanvec_t); i++) {
@@ -371,7 +371,7 @@ void wlc_locale_add_channels(chanvec_t *
 	}
 }
 
-void wlc_locale_get_channels(const locale_info_t * locale, chanvec_t * channels)
+void wlc_locale_get_channels(const locale_info_t *locale, chanvec_t *channels)
 {
 	uint8 i;
 
@@ -599,7 +599,7 @@ const locale_mimo_info_t *wlc_get_mimo_5
 	return g_mimo_5g_table[locale_idx];
 }
 
-wlc_cm_info_t *BCMATTACHFN(wlc_channel_mgr_attach) (wlc_info_t * wlc) {
+wlc_cm_info_t *BCMATTACHFN(wlc_channel_mgr_attach) (wlc_info_t *wlc) {
 	wlc_cm_info_t *wlc_cm;
 	char country_abbrev[WLC_CNTRY_BUF_SZ];
 	const country_info_t *country;
@@ -646,32 +646,32 @@ wlc_cm_info_t *BCMATTACHFN(wlc_channel_m
 	return wlc_cm;
 }
 
-void BCMATTACHFN(wlc_channel_mgr_detach) (wlc_cm_info_t * wlc_cm) {
+void BCMATTACHFN(wlc_channel_mgr_detach) (wlc_cm_info_t *wlc_cm) {
 	if (wlc_cm)
 		MFREE(wlc_cm->pub->osh, wlc_cm, sizeof(wlc_cm_info_t));
 }
 
-const char *wlc_channel_country_abbrev(wlc_cm_info_t * wlc_cm)
+const char *wlc_channel_country_abbrev(wlc_cm_info_t *wlc_cm)
 {
 	return wlc_cm->country_abbrev;
 }
 
-uint8 wlc_channel_locale_flags(wlc_cm_info_t * wlc_cm)
+uint8 wlc_channel_locale_flags(wlc_cm_info_t *wlc_cm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 
 	return wlc_cm->bandstate[wlc->band->bandunit].locale_flags;
 }
 
-uint8 wlc_channel_locale_flags_in_band(wlc_cm_info_t * wlc_cm, uint bandunit)
+uint8 wlc_channel_locale_flags_in_band(wlc_cm_info_t *wlc_cm, uint bandunit)
 {
 	return wlc_cm->bandstate[bandunit].locale_flags;
 }
 
 /* return chanvec for a given country code and band */
 bool
-wlc_channel_get_chanvec(struct wlc_info * wlc, const char *country_abbrev,
-			int bandtype, chanvec_t * channels)
+wlc_channel_get_chanvec(struct wlc_info *wlc, const char *country_abbrev,
+			int bandtype, chanvec_t *channels)
 {
 	const country_info_t *country;
 	const locale_info_t *locale = NULL;
@@ -694,7 +694,7 @@ wlc_channel_get_chanvec(struct wlc_info
 /* set the driver's current country and regulatory information using a country code
  * as the source. Lookup built in country information found with the country code.
  */
-int wlc_set_countrycode(wlc_cm_info_t * wlc_cm, const char *ccode)
+int wlc_set_countrycode(wlc_cm_info_t *wlc_cm, const char *ccode)
 {
 	char country_abbrev[WLC_CNTRY_BUF_SZ];
 	strncpy(country_abbrev, ccode, WLC_CNTRY_BUF_SZ);
@@ -702,7 +702,7 @@ int wlc_set_countrycode(wlc_cm_info_t *
 }
 
 int
-wlc_set_countrycode_rev(wlc_cm_info_t * wlc_cm,
+wlc_set_countrycode_rev(wlc_cm_info_t *wlc_cm,
 			const char *country_abbrev,
 			const char *ccode, int regrev)
 {
@@ -742,10 +742,10 @@ wlc_set_countrycode_rev(wlc_cm_info_t *
  * as the source. Look up built in country information found with the country code.
  */
 static void
-wlc_set_country_common(wlc_cm_info_t * wlc_cm,
+wlc_set_country_common(wlc_cm_info_t *wlc_cm,
 		       const char *country_abbrev,
 		       const char *ccode, uint regrev,
-		       const country_info_t * country)
+		       const country_info_t *country)
 {
 	const locale_mimo_info_t *li_mimo;
 	const locale_info_t *locale;
@@ -808,10 +808,10 @@ const country_info_t *wlc_country_lookup
 	return country;
 }
 
-static const country_info_t *wlc_countrycode_map(wlc_cm_info_t * wlc_cm,
+static const country_info_t *wlc_countrycode_map(wlc_cm_info_t *wlc_cm,
 						 const char *ccode,
 						 char *mapped_ccode,
-						 uint * mapped_regrev)
+						 uint *mapped_regrev)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	const country_info_t *country;
@@ -860,8 +860,8 @@ static const country_info_t *wlc_country
 }
 
 static int
-wlc_country_aggregate_map(wlc_cm_info_t * wlc_cm, const char *ccode,
-			  char *mapped_ccode, uint * mapped_regrev)
+wlc_country_aggregate_map(wlc_cm_info_t *wlc_cm, const char *ccode,
+			  char *mapped_ccode, uint *mapped_regrev)
 {
 	return FALSE;
 }
@@ -895,7 +895,7 @@ static const country_info_t *wlc_country
 }
 
 static int
-wlc_channels_init(wlc_cm_info_t * wlc_cm, const country_info_t * country)
+wlc_channels_init(wlc_cm_info_t *wlc_cm, const country_info_t *country)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	uint i, j;
@@ -949,7 +949,7 @@ wlc_channels_init(wlc_cm_info_t * wlc_cm
 /* Update the radio state (enable/disable) and tx power targets
  * based on a new set of channel/regulatory information
  */
-static void wlc_channels_commit(wlc_cm_info_t * wlc_cm)
+static void wlc_channels_commit(wlc_cm_info_t *wlc_cm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	uint chan;
@@ -995,7 +995,7 @@ static void wlc_channels_commit(wlc_cm_i
 }
 
 /* reset the quiet channels vector to the union of the restricted and radar channel sets */
-void wlc_quiet_channels_reset(wlc_cm_info_t * wlc_cm)
+void wlc_quiet_channels_reset(wlc_cm_info_t *wlc_cm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	uint i, j;
@@ -1016,7 +1016,7 @@ void wlc_quiet_channels_reset(wlc_cm_inf
 	}
 }
 
-bool wlc_quiet_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec)
+bool wlc_quiet_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chspec)
 {
 	return (N_ENAB(wlc_cm->wlc->pub) && CHSPEC_IS40(chspec) ?
 		(isset
@@ -1033,7 +1033,7 @@ bool wlc_quiet_chanspec(wlc_cm_info_t *
 /* Is the channel valid for the current locale? (but don't consider channels not
  *   available due to bandlocking)
  */
-bool wlc_valid_channel20_db(wlc_cm_info_t * wlc_cm, uint val)
+bool wlc_valid_channel20_db(wlc_cm_info_t *wlc_cm, uint val)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 
@@ -1044,14 +1044,14 @@ bool wlc_valid_channel20_db(wlc_cm_info_
 
 /* Is the channel valid for the current locale and specified band? */
 bool
-wlc_valid_channel20_in_band(wlc_cm_info_t * wlc_cm, uint bandunit, uint val)
+wlc_valid_channel20_in_band(wlc_cm_info_t *wlc_cm, uint bandunit, uint val)
 {
 	return ((val < MAXCHANNEL)
 		&& isset(wlc_cm->bandstate[bandunit].valid_channels.vec, val));
 }
 
 /* Is the channel valid for the current locale and current band? */
-bool wlc_valid_channel20(wlc_cm_info_t * wlc_cm, uint val)
+bool wlc_valid_channel20(wlc_cm_info_t *wlc_cm, uint val)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 
@@ -1061,7 +1061,7 @@ bool wlc_valid_channel20(wlc_cm_info_t *
 }
 
 /* Is the 40 MHz allowed for the current locale and specified band? */
-bool wlc_valid_40chanspec_in_band(wlc_cm_info_t * wlc_cm, uint bandunit)
+bool wlc_valid_40chanspec_in_band(wlc_cm_info_t *wlc_cm, uint bandunit)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 
@@ -1071,7 +1071,7 @@ bool wlc_valid_40chanspec_in_band(wlc_cm
 }
 
 static void
-wlc_channel_min_txpower_limits_with_local_constraint(wlc_cm_info_t * wlc_cm,
+wlc_channel_min_txpower_limits_with_local_constraint(wlc_cm_info_t *wlc_cm,
 						     struct txpwr_limits *txpwr,
 						     uint8
 						     local_constraint_qdbm)
@@ -1158,7 +1158,7 @@ wlc_channel_min_txpower_limits_with_loca
 }
 
 void
-wlc_channel_set_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
+wlc_channel_set_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chanspec,
 			 uint8 local_constraint_qdbm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
@@ -1175,7 +1175,7 @@ wlc_channel_set_chanspec(wlc_cm_info_t *
 }
 
 int
-wlc_channel_set_txpower_limit(wlc_cm_info_t * wlc_cm,
+wlc_channel_set_txpower_limit(wlc_cm_info_t *wlc_cm,
 			      uint8 local_constraint_qdbm)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
@@ -1192,7 +1192,7 @@ wlc_channel_set_txpower_limit(wlc_cm_inf
 }
 
 #ifdef POWER_DBG
-static void wlc_phy_txpower_limits_dump(txpwr_limits_t * txpwr)
+static void wlc_phy_txpower_limits_dump(txpwr_limits_t *txpwr)
 {
 	int i;
 	char fraction[4][4] = { "   ", ".25", ".5 ", ".75" };
@@ -1295,8 +1295,8 @@ static void wlc_phy_txpower_limits_dump(
 #endif				/* POWER_DBG */
 
 void
-wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
-		       txpwr_limits_t * txpwr)
+wlc_channel_reg_limits(wlc_cm_info_t *wlc_cm, chanspec_t chanspec,
+		       txpwr_limits_t *txpwr)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	uint i;
@@ -1508,7 +1508,7 @@ wlc_channel_reg_limits(wlc_cm_info_t * w
 }
 
 /* Returns TRUE if currently set country is Japan or variant */
-bool wlc_japan(struct wlc_info * wlc)
+bool wlc_japan(struct wlc_info *wlc)
 {
 	return wlc_japan_ccode(wlc->cmi->country_abbrev);
 }
@@ -1525,7 +1525,7 @@ static bool wlc_japan_ccode(const char *
  * are valid 20MZH channels in this locale and they are also a legal HT combination
  */
 static bool
-wlc_valid_chanspec_ext(wlc_cm_info_t * wlc_cm, chanspec_t chspec, bool dualband)
+wlc_valid_chanspec_ext(wlc_cm_info_t *wlc_cm, chanspec_t chspec, bool dualband)
 {
 	wlc_info_t *wlc = wlc_cm->wlc;
 	uint8 channel = CHSPEC_CHANNEL(chspec);
@@ -1587,12 +1587,12 @@ wlc_valid_chanspec_ext(wlc_cm_info_t * w
 	return FALSE;
 }
 
-bool wlc_valid_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec)
+bool wlc_valid_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chspec)
 {
 	return wlc_valid_chanspec_ext(wlc_cm, chspec, FALSE);
 }
 
-bool wlc_valid_chanspec_db(wlc_cm_info_t * wlc_cm, chanspec_t chspec)
+bool wlc_valid_chanspec_db(wlc_cm_info_t *wlc_cm, chanspec_t chspec)
 {
 	return wlc_valid_chanspec_ext(wlc_cm, chspec, TRUE);
 }
--- a/drivers/staging/brcm80211/sys/wlc_channel.h
+++ b/drivers/staging/brcm80211/sys/wlc_channel.h
@@ -105,20 +105,20 @@ typedef struct country_info country_info
 typedef struct wlc_cm_info wlc_cm_info_t;
 
 extern wlc_cm_info_t *wlc_channel_mgr_attach(struct wlc_info *wlc);
-extern void wlc_channel_mgr_detach(wlc_cm_info_t * wlc_cm);
+extern void wlc_channel_mgr_detach(wlc_cm_info_t *wlc_cm);
 
-extern int wlc_set_countrycode(wlc_cm_info_t * wlc_cm, const char *ccode);
-extern int wlc_set_countrycode_rev(wlc_cm_info_t * wlc_cm,
+extern int wlc_set_countrycode(wlc_cm_info_t *wlc_cm, const char *ccode);
+extern int wlc_set_countrycode_rev(wlc_cm_info_t *wlc_cm,
 				   const char *country_abbrev,
 				   const char *ccode, int regrev);
 
-extern const char *wlc_channel_country_abbrev(wlc_cm_info_t * wlc_cm);
-extern uint8 wlc_channel_locale_flags(wlc_cm_info_t * wlc_cm);
-extern uint8 wlc_channel_locale_flags_in_band(wlc_cm_info_t * wlc_cm,
+extern const char *wlc_channel_country_abbrev(wlc_cm_info_t *wlc_cm);
+extern uint8 wlc_channel_locale_flags(wlc_cm_info_t *wlc_cm);
+extern uint8 wlc_channel_locale_flags_in_band(wlc_cm_info_t *wlc_cm,
 					      uint bandunit);
 
-extern void wlc_quiet_channels_reset(wlc_cm_info_t * wlc_cm);
-extern bool wlc_quiet_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec);
+extern void wlc_quiet_channels_reset(wlc_cm_info_t *wlc_cm);
+extern bool wlc_quiet_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chspec);
 
 #define	VALID_CHANNEL20_DB(wlc, val) wlc_valid_channel20_db((wlc)->cmi, val)
 #define	VALID_CHANNEL20_IN_BAND(wlc, bandunit, val) \
@@ -126,34 +126,34 @@ extern bool wlc_quiet_chanspec(wlc_cm_in
 #define	VALID_CHANNEL20(wlc, val) wlc_valid_channel20((wlc)->cmi, val)
 #define VALID_40CHANSPEC_IN_BAND(wlc, bandunit) wlc_valid_40chanspec_in_band((wlc)->cmi, bandunit)
 
-extern bool wlc_valid_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec);
-extern bool wlc_valid_chanspec_db(wlc_cm_info_t * wlc_cm, chanspec_t chspec);
-extern bool wlc_valid_channel20_db(wlc_cm_info_t * wlc_cm, uint val);
-extern bool wlc_valid_channel20_in_band(wlc_cm_info_t * wlc_cm, uint bandunit,
+extern bool wlc_valid_chanspec(wlc_cm_info_t *wlc_cm, chanspec_t chspec);
+extern bool wlc_valid_chanspec_db(wlc_cm_info_t *wlc_cm, chanspec_t chspec);
+extern bool wlc_valid_channel20_db(wlc_cm_info_t *wlc_cm, uint val);
+extern bool wlc_valid_channel20_in_band(wlc_cm_info_t *wlc_cm, uint bandunit,
 					uint val);
-extern bool wlc_valid_channel20(wlc_cm_info_t * wlc_cm, uint val);
-extern bool wlc_valid_40chanspec_in_band(wlc_cm_info_t * wlc_cm, uint bandunit);
+extern bool wlc_valid_channel20(wlc_cm_info_t *wlc_cm, uint val);
+extern bool wlc_valid_40chanspec_in_band(wlc_cm_info_t *wlc_cm, uint bandunit);
 
-extern void wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm,
+extern void wlc_channel_reg_limits(wlc_cm_info_t *wlc_cm,
 				   chanspec_t chanspec,
 				   struct txpwr_limits *txpwr);
-extern void wlc_channel_set_chanspec(wlc_cm_info_t * wlc_cm,
+extern void wlc_channel_set_chanspec(wlc_cm_info_t *wlc_cm,
 				     chanspec_t chanspec,
 				     uint8 local_constraint_qdbm);
-extern int wlc_channel_set_txpower_limit(wlc_cm_info_t * wlc_cm,
+extern int wlc_channel_set_txpower_limit(wlc_cm_info_t *wlc_cm,
 					 uint8 local_constraint_qdbm);
 
 extern const country_info_t *wlc_country_lookup(struct wlc_info *wlc,
 						const char *ccode);
-extern void wlc_locale_get_channels(const locale_info_t * locale,
-				    chanvec_t * valid_channels);
+extern void wlc_locale_get_channels(const locale_info_t *locale,
+				    chanvec_t *valid_channels);
 extern const locale_info_t *wlc_get_locale_2g(uint8 locale_idx);
 extern const locale_info_t *wlc_get_locale_5g(uint8 locale_idx);
 extern bool wlc_japan(struct wlc_info *wlc);
 
-extern uint8 wlc_get_regclass(wlc_cm_info_t * wlc_cm, chanspec_t chanspec);
+extern uint8 wlc_get_regclass(wlc_cm_info_t *wlc_cm, chanspec_t chanspec);
 extern bool wlc_channel_get_chanvec(struct wlc_info *wlc,
 				    const char *country_abbrev, int bandtype,
-				    chanvec_t * channels);
+				    chanvec_t *channels);
 
 #endif				/* _WLC_CHANNEL_H */
--- a/drivers/staging/brcm80211/sys/wlc_event.c
+++ b/drivers/staging/brcm80211/sys/wlc_event.c
@@ -53,8 +53,8 @@ struct wlc_eventq {
 /*
  * Export functions
  */
-wlc_eventq_t *BCMATTACHFN(wlc_eventq_attach) (wlc_pub_t * pub,
-					      struct wlc_info * wlc, void *wl,
+wlc_eventq_t *BCMATTACHFN(wlc_eventq_attach) (wlc_pub_t *pub,
+					      struct wlc_info *wlc, void *wl,
 					      wlc_eventq_cb_t cb) {
 	wlc_eventq_t *eq;
 
@@ -79,7 +79,7 @@ wlc_eventq_t *BCMATTACHFN(wlc_eventq_att
 	return eq;
 }
 
-int BCMATTACHFN(wlc_eventq_detach) (wlc_eventq_t * eq) {
+int BCMATTACHFN(wlc_eventq_detach) (wlc_eventq_t *eq) {
 	/* Clean up pending events */
 	wlc_eventq_down(eq);
 
@@ -97,7 +97,7 @@ int BCMATTACHFN(wlc_eventq_detach) (wlc_
 	return 0;
 }
 
-int BCMUNINITFN(wlc_eventq_down) (wlc_eventq_t * eq) {
+int BCMUNINITFN(wlc_eventq_down) (wlc_eventq_t *eq) {
 	int callbacks = 0;
 	if (eq->tpending && !eq->workpending) {
 		if (!wl_del_timer(eq->wl, eq->timer))
@@ -118,7 +118,7 @@ int BCMUNINITFN(wlc_eventq_down) (wlc_ev
 	return callbacks;
 }
 
-wlc_event_t *wlc_event_alloc(wlc_eventq_t * eq)
+wlc_event_t *wlc_event_alloc(wlc_eventq_t *eq)
 {
 	wlc_event_t *e;
 
@@ -131,14 +131,14 @@ wlc_event_t *wlc_event_alloc(wlc_eventq_
 	return e;
 }
 
-void wlc_event_free(wlc_eventq_t * eq, wlc_event_t * e)
+void wlc_event_free(wlc_eventq_t *eq, wlc_event_t *e)
 {
 	ASSERT(e->data == NULL);
 	ASSERT(e->next == NULL);
 	MFREE(eq->pub->osh, e, sizeof(wlc_event_t));
 }
 
-void wlc_eventq_enq(wlc_eventq_t * eq, wlc_event_t * e)
+void wlc_eventq_enq(wlc_eventq_t *eq, wlc_event_t *e)
 {
 	ASSERT(e->next == NULL);
 	e->next = NULL;
@@ -158,7 +158,7 @@ void wlc_eventq_enq(wlc_eventq_t * eq, w
 	}
 }
 
-wlc_event_t *wlc_eventq_deq(wlc_eventq_t * eq)
+wlc_event_t *wlc_eventq_deq(wlc_eventq_t *eq)
 {
 	wlc_event_t *e;
 
@@ -173,7 +173,7 @@ wlc_event_t *wlc_eventq_deq(wlc_eventq_t
 	return e;
 }
 
-wlc_event_t *wlc_eventq_next(wlc_eventq_t * eq, wlc_event_t * e)
+wlc_event_t *wlc_eventq_next(wlc_eventq_t *eq, wlc_event_t *e)
 {
 #ifdef BCMDBG
 	wlc_event_t *etmp;
@@ -188,7 +188,7 @@ wlc_event_t *wlc_eventq_next(wlc_eventq_
 	return e->next;
 }
 
-int wlc_eventq_cnt(wlc_eventq_t * eq)
+int wlc_eventq_cnt(wlc_eventq_t *eq)
 {
 	wlc_event_t *etmp;
 	int cnt = 0;
@@ -199,7 +199,7 @@ int wlc_eventq_cnt(wlc_eventq_t * eq)
 	return cnt;
 }
 
-bool wlc_eventq_avail(wlc_eventq_t * eq)
+bool wlc_eventq_avail(wlc_eventq_t *eq)
 {
 	return (eq->head != NULL);
 }
--- a/drivers/staging/brcm80211/sys/wlc_event.h
+++ b/drivers/staging/brcm80211/sys/wlc_event.h
@@ -21,30 +21,30 @@ typedef struct wlc_eventq wlc_eventq_t;
 
 typedef void (*wlc_eventq_cb_t) (void *arg);
 
-extern wlc_eventq_t *wlc_eventq_attach(wlc_pub_t * pub, struct wlc_info *wlc,
+extern wlc_eventq_t *wlc_eventq_attach(wlc_pub_t *pub, struct wlc_info *wlc,
 				       void *wl, wlc_eventq_cb_t cb);
-extern int wlc_eventq_detach(wlc_eventq_t * eq);
-extern int wlc_eventq_down(wlc_eventq_t * eq);
-extern void wlc_event_free(wlc_eventq_t * eq, wlc_event_t * e);
-extern wlc_event_t *wlc_eventq_next(wlc_eventq_t * eq, wlc_event_t * e);
-extern int wlc_eventq_cnt(wlc_eventq_t * eq);
-extern bool wlc_eventq_avail(wlc_eventq_t * eq);
-extern wlc_event_t *wlc_eventq_deq(wlc_eventq_t * eq);
-extern void wlc_eventq_enq(wlc_eventq_t * eq, wlc_event_t * e);
-extern wlc_event_t *wlc_event_alloc(wlc_eventq_t * eq);
+extern int wlc_eventq_detach(wlc_eventq_t *eq);
+extern int wlc_eventq_down(wlc_eventq_t *eq);
+extern void wlc_event_free(wlc_eventq_t *eq, wlc_event_t *e);
+extern wlc_event_t *wlc_eventq_next(wlc_eventq_t *eq, wlc_event_t *e);
+extern int wlc_eventq_cnt(wlc_eventq_t *eq);
+extern bool wlc_eventq_avail(wlc_eventq_t *eq);
+extern wlc_event_t *wlc_eventq_deq(wlc_eventq_t *eq);
+extern void wlc_eventq_enq(wlc_eventq_t *eq, wlc_event_t *e);
+extern wlc_event_t *wlc_event_alloc(wlc_eventq_t *eq);
 
-extern int wlc_eventq_register_ind(wlc_eventq_t * eq, void *bitvect);
-extern int wlc_eventq_query_ind(wlc_eventq_t * eq, void *bitvect);
-extern int wlc_eventq_test_ind(wlc_eventq_t * eq, int et);
-extern int wlc_eventq_set_ind(wlc_eventq_t * eq, uint et, bool on);
-extern void wlc_eventq_flush(wlc_eventq_t * eq);
-extern void wlc_assign_event_msg(wlc_info_t * wlc, wl_event_msg_t * msg,
-				 const wlc_event_t * e, uint8 * data,
+extern int wlc_eventq_register_ind(wlc_eventq_t *eq, void *bitvect);
+extern int wlc_eventq_query_ind(wlc_eventq_t *eq, void *bitvect);
+extern int wlc_eventq_test_ind(wlc_eventq_t *eq, int et);
+extern int wlc_eventq_set_ind(wlc_eventq_t *eq, uint et, bool on);
+extern void wlc_eventq_flush(wlc_eventq_t *eq);
+extern void wlc_assign_event_msg(wlc_info_t *wlc, wl_event_msg_t *msg,
+				 const wlc_event_t *e, uint8 *data,
 				 uint32 len);
 
 #ifdef MSGTRACE
-extern void wlc_event_sendup_trace(struct wlc_info *wlc, hndrte_dev_t * bus,
-				   uint8 * hdr, uint16 hdrlen, uint8 * buf,
+extern void wlc_event_sendup_trace(struct wlc_info *wlc, hndrte_dev_t *bus,
+				   uint8 *hdr, uint16 hdrlen, uint8 *buf,
 				   uint16 buflen);
 #endif
 
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.c
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -253,89 +253,89 @@ static const uint8 acbitmap2maxprio[] =
 
 /* local prototypes */
 extern void wlc_txq_enq(void *ctx, struct scb *scb, void *sdu, uint prec);
-static uint16 BCMFASTPATH wlc_d11hdrs_mac80211(wlc_info_t * wlc,
+static uint16 BCMFASTPATH wlc_d11hdrs_mac80211(wlc_info_t *wlc,
 					       struct ieee80211_hw *hw, void *p,
 					       struct scb *scb, uint frag,
 					       uint nfrags, uint queue,
 					       uint next_frag_len,
-					       wsec_key_t * key,
+					       wsec_key_t *key,
 					       ratespec_t rspec_override);
-bool wlc_sendpkt_mac80211(wlc_info_t * wlc, void *sdu, struct ieee80211_hw *hw);
-void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg, bool suspend);
-static void wlc_bss_default_init(wlc_info_t * wlc);
-static void wlc_ucode_mac_upd(wlc_info_t * wlc);
-static ratespec_t mac80211_wlc_set_nrate(wlc_info_t * wlc, wlcband_t * cur_band,
+bool wlc_sendpkt_mac80211(wlc_info_t *wlc, void *sdu, struct ieee80211_hw *hw);
+void wlc_wme_setparams(wlc_info_t *wlc, u16 aci, void *arg, bool suspend);
+static void wlc_bss_default_init(wlc_info_t *wlc);
+static void wlc_ucode_mac_upd(wlc_info_t *wlc);
+static ratespec_t mac80211_wlc_set_nrate(wlc_info_t *wlc, wlcband_t *cur_band,
 					 uint32 int_val);
-static void wlc_tx_prec_map_init(wlc_info_t * wlc);
+static void wlc_tx_prec_map_init(wlc_info_t *wlc);
 static void wlc_watchdog(void *arg);
 static void wlc_watchdog_by_timer(void *arg);
-static int wlc_set_rateset(wlc_info_t * wlc, wlc_rateset_t * rs_arg);
-static int wlc_iovar_rangecheck(wlc_info_t * wlc, uint32 val,
-				const bcm_iovar_t * vi);
-static uint8 wlc_local_constraint_qdbm(wlc_info_t * wlc);
+static int wlc_set_rateset(wlc_info_t *wlc, wlc_rateset_t *rs_arg);
+static int wlc_iovar_rangecheck(wlc_info_t *wlc, uint32 val,
+				const bcm_iovar_t *vi);
+static uint8 wlc_local_constraint_qdbm(wlc_info_t *wlc);
 
 #if defined(BCMDBG)
-static void wlc_print_dot11hdr(uint8 * buf, int len);
+static void wlc_print_dot11hdr(uint8 *buf, int len);
 #endif
 
 /* send and receive */
-static wlc_txq_info_t *wlc_txq_alloc(wlc_info_t * wlc, osl_t * osh);
-static void wlc_txq_free(wlc_info_t * wlc, osl_t * osh, wlc_txq_info_t * qi);
-static void wlc_txflowcontrol_signal(wlc_info_t * wlc, wlc_txq_info_t * qi,
+static wlc_txq_info_t *wlc_txq_alloc(wlc_info_t *wlc, osl_t *osh);
+static void wlc_txq_free(wlc_info_t *wlc, osl_t *osh, wlc_txq_info_t *qi);
+static void wlc_txflowcontrol_signal(wlc_info_t *wlc, wlc_txq_info_t *qi,
 				     bool on, int prio);
-static void wlc_txflowcontrol_reset(wlc_info_t * wlc);
-static uint16 wlc_compute_airtime(wlc_info_t * wlc, ratespec_t rspec,
+static void wlc_txflowcontrol_reset(wlc_info_t *wlc);
+static uint16 wlc_compute_airtime(wlc_info_t *wlc, ratespec_t rspec,
 				  uint length);
-static void wlc_compute_cck_plcp(ratespec_t rate, uint length, uint8 * plcp);
-static void wlc_compute_ofdm_plcp(ratespec_t rate, uint length, uint8 * plcp);
-static void wlc_compute_mimo_plcp(ratespec_t rate, uint length, uint8 * plcp);
-static uint16 wlc_compute_frame_dur(wlc_info_t * wlc, ratespec_t rate,
+static void wlc_compute_cck_plcp(ratespec_t rate, uint length, uint8 *plcp);
+static void wlc_compute_ofdm_plcp(ratespec_t rate, uint length, uint8 *plcp);
+static void wlc_compute_mimo_plcp(ratespec_t rate, uint length, uint8 *plcp);
+static uint16 wlc_compute_frame_dur(wlc_info_t *wlc, ratespec_t rate,
 				    uint8 preamble_type, uint next_frag_len);
-static void wlc_recvctl(wlc_info_t * wlc, osl_t * osh, d11rxhdr_t * rxh,
+static void wlc_recvctl(wlc_info_t *wlc, osl_t *osh, d11rxhdr_t *rxh,
 			void *p);
-static uint wlc_calc_frame_len(wlc_info_t * wlc, ratespec_t rate,
+static uint wlc_calc_frame_len(wlc_info_t *wlc, ratespec_t rate,
 			       uint8 preamble_type, uint dur);
-static uint wlc_calc_ack_time(wlc_info_t * wlc, ratespec_t rate,
+static uint wlc_calc_ack_time(wlc_info_t *wlc, ratespec_t rate,
 			      uint8 preamble_type);
-static uint wlc_calc_cts_time(wlc_info_t * wlc, ratespec_t rate,
+static uint wlc_calc_cts_time(wlc_info_t *wlc, ratespec_t rate,
 			      uint8 preamble_type);
 /* interrupt, up/down, band */
-static void wlc_setband(wlc_info_t * wlc, uint bandunit);
-static chanspec_t wlc_init_chanspec(wlc_info_t * wlc);
-static void wlc_bandinit_ordered(wlc_info_t * wlc, chanspec_t chanspec);
-static void wlc_bsinit(wlc_info_t * wlc);
-static int wlc_duty_cycle_set(wlc_info_t * wlc, int duty_cycle, bool isOFDM,
+static void wlc_setband(wlc_info_t *wlc, uint bandunit);
+static chanspec_t wlc_init_chanspec(wlc_info_t *wlc);
+static void wlc_bandinit_ordered(wlc_info_t *wlc, chanspec_t chanspec);
+static void wlc_bsinit(wlc_info_t *wlc);
+static int wlc_duty_cycle_set(wlc_info_t *wlc, int duty_cycle, bool isOFDM,
 			      bool writeToShm);
-static void wlc_radio_hwdisable_upd(wlc_info_t * wlc);
-static bool wlc_radio_monitor_start(wlc_info_t * wlc);
+static void wlc_radio_hwdisable_upd(wlc_info_t *wlc);
+static bool wlc_radio_monitor_start(wlc_info_t *wlc);
 static void wlc_radio_timer(void *arg);
-static void wlc_radio_enable(wlc_info_t * wlc);
-static void wlc_radio_upd(wlc_info_t * wlc);
+static void wlc_radio_enable(wlc_info_t *wlc);
+static void wlc_radio_upd(wlc_info_t *wlc);
 
 /* scan, association, BSS */
-static uint wlc_calc_ba_time(wlc_info_t * wlc, ratespec_t rate,
+static uint wlc_calc_ba_time(wlc_info_t *wlc, ratespec_t rate,
 			     uint8 preamble_type);
-static void wlc_update_mimo_band_bwcap(wlc_info_t * wlc, uint8 bwcap);
-static void wlc_ht_update_sgi_rx(wlc_info_t * wlc, int val);
-void wlc_ht_mimops_cap_update(wlc_info_t * wlc, uint8 mimops_mode);
-static void wlc_ht_update_ldpc(wlc_info_t * wlc, int8 val);
-static void wlc_war16165(wlc_info_t * wlc, bool tx);
+static void wlc_update_mimo_band_bwcap(wlc_info_t *wlc, uint8 bwcap);
+static void wlc_ht_update_sgi_rx(wlc_info_t *wlc, int val);
+void wlc_ht_mimops_cap_update(wlc_info_t *wlc, uint8 mimops_mode);
+static void wlc_ht_update_ldpc(wlc_info_t *wlc, int8 val);
+static void wlc_war16165(wlc_info_t *wlc, bool tx);
 
 static void wlc_process_eventq(void *arg);
-static void wlc_wme_retries_write(wlc_info_t * wlc);
-static bool wlc_attach_stf_ant_init(wlc_info_t * wlc);
-static uint wlc_attach_module(wlc_info_t * wlc);
-static void wlc_detach_module(wlc_info_t * wlc);
-static void wlc_timers_deinit(wlc_info_t * wlc);
-static void wlc_down_led_upd(wlc_info_t * wlc);
-static uint wlc_down_del_timer(wlc_info_t * wlc);
-static void wlc_ofdm_rateset_war(wlc_info_t * wlc);
-static int _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len,
+static void wlc_wme_retries_write(wlc_info_t *wlc);
+static bool wlc_attach_stf_ant_init(wlc_info_t *wlc);
+static uint wlc_attach_module(wlc_info_t *wlc);
+static void wlc_detach_module(wlc_info_t *wlc);
+static void wlc_timers_deinit(wlc_info_t *wlc);
+static void wlc_down_led_upd(wlc_info_t *wlc);
+static uint wlc_down_del_timer(wlc_info_t *wlc);
+static void wlc_ofdm_rateset_war(wlc_info_t *wlc);
+static int _wlc_ioctl(wlc_info_t *wlc, int cmd, void *arg, int len,
 		      struct wlc_if *wlcif);
 char *print_fk(uint16 fk);
 
 #if defined(BCMDBG)
-void wlc_get_rcmta(wlc_info_t * wlc, int idx, struct ether_addr *addr)
+void wlc_get_rcmta(wlc_info_t *wlc, int idx, struct ether_addr *addr)
 {
 	d11regs_t *regs = wlc->regs;
 	uint32 v32;
@@ -363,14 +363,14 @@ void wlc_get_rcmta(wlc_info_t * wlc, int
 #endif				/* defined(BCMDBG) */
 
 /* keep the chip awake if needed */
-bool wlc_stay_awake(wlc_info_t * wlc)
+bool wlc_stay_awake(wlc_info_t *wlc)
 {
 	return TRUE;
 }
 
 /* conditions under which the PM bit should be set in outgoing frames and STAY_AWAKE is meaningful
  */
-bool wlc_ps_allowed(wlc_info_t * wlc)
+bool wlc_ps_allowed(wlc_info_t *wlc)
 {
 	int idx;
 	wlc_bsscfg_t *cfg;
@@ -397,7 +397,7 @@ bool wlc_ps_allowed(wlc_info_t * wlc)
 	return TRUE;
 }
 
-void BCMINITFN(wlc_reset) (wlc_info_t * wlc) {
+void BCMINITFN(wlc_reset) (wlc_info_t *wlc) {
 	WL_TRACE(("wl%d: wlc_reset\n", wlc->pub->unit));
 
 	wlc->check_for_unaligned_tbtt = FALSE;
@@ -432,7 +432,7 @@ void BCMINITFN(wlc_reset) (wlc_info_t *
 #endif
 }
 
-void wlc_fatal_error(wlc_info_t * wlc)
+void wlc_fatal_error(wlc_info_t *wlc)
 {
 	WL_ERROR(("wl%d: fatal error, reinitializing\n", wlc->pub->unit));
 	wl_init(wlc->wl);
@@ -443,7 +443,7 @@ void wlc_fatal_error(wlc_info_t * wlc)
  * if other configurations are in conflict (bandlocked, 11n mode disabled,
  * invalid channel for current country, etc.)
  */
-static chanspec_t BCMINITFN(wlc_init_chanspec) (wlc_info_t * wlc) {
+static chanspec_t BCMINITFN(wlc_init_chanspec) (wlc_info_t *wlc) {
 	chanspec_t chanspec =
 	    1 | WL_CHANSPEC_BW_20 | WL_CHANSPEC_CTL_SB_NONE |
 	    WL_CHANSPEC_BAND_2G;
@@ -458,7 +458,7 @@ static chanspec_t BCMINITFN(wlc_init_cha
 
 struct scb global_scb;
 
-static void wlc_init_scb(wlc_info_t * wlc, struct scb *scb)
+static void wlc_init_scb(wlc_info_t *wlc, struct scb *scb)
 {
 	int i;
 	scb->flags = SCB_WMECAP | SCB_HTCAP;
@@ -466,7 +466,7 @@ static void wlc_init_scb(wlc_info_t * wl
 		scb->seqnum[i] = 0;
 }
 
-void BCMINITFN(wlc_init) (wlc_info_t * wlc) {
+void BCMINITFN(wlc_init) (wlc_info_t *wlc) {
 	d11regs_t *regs;
 	chanspec_t chanspec;
 	int i;
@@ -599,13 +599,13 @@ void BCMINITFN(wlc_init) (wlc_info_t * w
 	}
 }
 
-void wlc_mac_bcn_promisc_change(wlc_info_t * wlc, bool promisc)
+void wlc_mac_bcn_promisc_change(wlc_info_t *wlc, bool promisc)
 {
 	wlc->bcnmisc_monitor = promisc;
 	wlc_mac_bcn_promisc(wlc);
 }
 
-void wlc_mac_bcn_promisc(wlc_info_t * wlc)
+void wlc_mac_bcn_promisc(wlc_info_t *wlc)
 {
 	if ((AP_ENAB(wlc->pub) && (N_ENAB(wlc->pub) || wlc->band->gmode)) ||
 	    wlc->bcnmisc_ibss || wlc->bcnmisc_scan || wlc->bcnmisc_monitor)
@@ -615,7 +615,7 @@ void wlc_mac_bcn_promisc(wlc_info_t * wl
 }
 
 /* set or clear maccontrol bits MCTL_PROMISC and MCTL_KEEPCONTROL */
-void wlc_mac_promisc(wlc_info_t * wlc)
+void wlc_mac_promisc(wlc_info_t *wlc)
 {
 	uint32 promisc_bits = 0;
 
@@ -637,7 +637,7 @@ void wlc_mac_promisc(wlc_info_t * wlc)
 }
 
 /* check if hps and wake states of sw and hw are in sync */
-bool wlc_ps_check(wlc_info_t * wlc)
+bool wlc_ps_check(wlc_info_t *wlc)
 {
 	bool res = TRUE;
 	bool hps, wake;
@@ -695,7 +695,7 @@ bool wlc_ps_check(wlc_info_t * wlc)
 }
 
 /* push sw hps and wake state through hardware */
-void wlc_set_ps_ctrl(wlc_info_t * wlc)
+void wlc_set_ps_ctrl(wlc_info_t *wlc)
 {
 	uint32 v1, v2;
 	bool hps, wake;
@@ -727,7 +727,7 @@ void wlc_set_ps_ctrl(wlc_info_t * wlc)
  * Write this BSS config's MAC address to core.
  * Updates RXE match engine.
  */
-int wlc_set_mac(wlc_bsscfg_t * cfg)
+int wlc_set_mac(wlc_bsscfg_t *cfg)
 {
 	int err = 0;
 	wlc_info_t *wlc = cfg->wlc;
@@ -745,7 +745,7 @@ int wlc_set_mac(wlc_bsscfg_t * cfg)
 /* Write the BSS config's BSSID address to core (set_bssid in d11procs.tcl).
  * Updates RXE match engine.
  */
-void wlc_set_bssid(wlc_bsscfg_t * cfg)
+void wlc_set_bssid(wlc_bsscfg_t *cfg)
 {
 	wlc_info_t *wlc = cfg->wlc;
 
@@ -764,7 +764,7 @@ void wlc_set_bssid(wlc_bsscfg_t * cfg)
  * Suspend the the MAC and update the slot timing
  * for standard 11b/g (20us slots) or shortslot 11g (9us slots).
  */
-void wlc_switch_shortslot(wlc_info_t * wlc, bool shortslot)
+void wlc_switch_shortslot(wlc_info_t *wlc, bool shortslot)
 {
 	int idx;
 	wlc_bsscfg_t *cfg;
@@ -792,7 +792,7 @@ void wlc_switch_shortslot(wlc_info_t * w
 	wlc_bmac_set_shortslot(wlc->hw, shortslot);
 }
 
-static uint8 wlc_local_constraint_qdbm(wlc_info_t * wlc)
+static uint8 wlc_local_constraint_qdbm(wlc_info_t *wlc)
 {
 	uint8 local;
 	int16 local_max;
@@ -819,7 +819,7 @@ static uint8 wlc_local_constraint_qdbm(w
 }
 
 /* propagate home chanspec to all bsscfgs in case bsscfg->current_bss->chanspec is referenced */
-void wlc_set_home_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
+void wlc_set_home_chanspec(wlc_info_t *wlc, chanspec_t chanspec)
 {
 	if (wlc->home_chanspec != chanspec) {
 		int idx;
@@ -837,7 +837,7 @@ void wlc_set_home_chanspec(wlc_info_t *
 	}
 }
 
-static void wlc_set_phy_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
+static void wlc_set_phy_chanspec(wlc_info_t *wlc, chanspec_t chanspec)
 {
 	/* Save our copy of the chanspec */
 	wlc->chanspec = chanspec;
@@ -856,7 +856,7 @@ static void wlc_set_phy_chanspec(wlc_inf
 
 }
 
-void wlc_set_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
+void wlc_set_chanspec(wlc_info_t *wlc, chanspec_t chanspec)
 {
 	uint bandunit;
 	bool switchband = FALSE;
@@ -911,7 +911,7 @@ void wlc_set_chanspec(wlc_info_t * wlc,
 }
 
 #if defined(BCMDBG)
-static int wlc_get_current_txpwr(wlc_info_t * wlc, void *pwr, uint len)
+static int wlc_get_current_txpwr(wlc_info_t *wlc, void *pwr, uint len)
 {
 	txpwr_limits_t txpwr;
 	tx_power_t power;
@@ -1080,7 +1080,7 @@ static int wlc_get_current_txpwr(wlc_inf
 }
 #endif				/* defined(BCMDBG) */
 
-static uint32 wlc_watchdog_backup_bi(wlc_info_t * wlc)
+static uint32 wlc_watchdog_backup_bi(wlc_info_t *wlc)
 {
 	uint32 bi;
 	bi = 2 * wlc->cfg->current_bss->dtim_period *
@@ -1099,7 +1099,7 @@ static uint32 wlc_watchdog_backup_bi(wlc
 /* Change to run the watchdog either from a periodic timer or from tbtt handler.
  * Call watchdog from tbtt handler if tbtt is TRUE, watchdog timer otherwise.
  */
-void wlc_watchdog_upd(wlc_info_t * wlc, bool tbtt)
+void wlc_watchdog_upd(wlc_info_t *wlc, bool tbtt)
 {
 	/* make sure changing watchdog driver is allowed */
 	if (!wlc->pub->up || !wlc->pub->align_wd_tbtt)
@@ -1128,7 +1128,7 @@ void wlc_watchdog_upd(wlc_info_t * wlc,
 	}
 }
 
-ratespec_t wlc_lowest_basic_rspec(wlc_info_t * wlc, wlc_rateset_t * rs)
+ratespec_t wlc_lowest_basic_rspec(wlc_info_t *wlc, wlc_rateset_t *rs)
 {
 	ratespec_t lowest_basic_rspec;
 	uint i;
@@ -1156,7 +1156,7 @@ ratespec_t wlc_lowest_basic_rspec(wlc_in
  *  ratespec     CCK		ant = wlc->stf->txant
  *  		OFDM		ant = 3
  */
-void wlc_beacon_phytxctl_txant_upd(wlc_info_t * wlc, ratespec_t bcn_rspec)
+void wlc_beacon_phytxctl_txant_upd(wlc_info_t *wlc, ratespec_t bcn_rspec)
 {
 	uint16 phyctl;
 	uint16 phytxant = wlc->stf->phytxant;
@@ -1175,7 +1175,7 @@ void wlc_beacon_phytxctl_txant_upd(wlc_i
 /* centralized protection config change function to simplify debugging, no consistency checking
  * this should be called only on changes to avoid overhead in periodic function
 */
-void wlc_protection_upd(wlc_info_t * wlc, uint idx, int val)
+void wlc_protection_upd(wlc_info_t *wlc, uint idx, int val)
 {
 	WL_TRACE(("wlc_protection_upd: idx %d, val %d\n", idx, val));
 
@@ -1221,7 +1221,7 @@ void wlc_protection_upd(wlc_info_t * wlc
 
 }
 
-static void wlc_ht_update_sgi_rx(wlc_info_t * wlc, int val)
+static void wlc_ht_update_sgi_rx(wlc_info_t *wlc, int val)
 {
 	wlc->ht_cap.cap &= ~(HT_CAP_SHORT_GI_20 | HT_CAP_SHORT_GI_40);
 	wlc->ht_cap.cap |= (val & WLC_N_SGI_20) ? HT_CAP_SHORT_GI_20 : 0;
@@ -1233,7 +1233,7 @@ static void wlc_ht_update_sgi_rx(wlc_inf
 	}
 }
 
-static void wlc_ht_update_ldpc(wlc_info_t * wlc, int8 val)
+static void wlc_ht_update_ldpc(wlc_info_t *wlc, int8 val)
 {
 	wlc->stf->ldpc = val;
 
@@ -1252,7 +1252,7 @@ static void wlc_ht_update_ldpc(wlc_info_
  * ucode, hwmac update
  *    Channel dependent updates for ucode and hw
  */
-static void wlc_ucode_mac_upd(wlc_info_t * wlc)
+static void wlc_ucode_mac_upd(wlc_info_t *wlc)
 {
 	/* enable or disable any active IBSSs depending on whether or not
 	 * we are on the home channel
@@ -1279,7 +1279,7 @@ static void wlc_ucode_mac_upd(wlc_info_t
 	wlc_mac_promisc(wlc);
 }
 
-static void wlc_bandinit_ordered(wlc_info_t * wlc, chanspec_t chanspec)
+static void wlc_bandinit_ordered(wlc_info_t *wlc, chanspec_t chanspec)
 {
 	wlc_rateset_t default_rateset;
 	uint parkband;
@@ -1326,7 +1326,7 @@ static void wlc_bandinit_ordered(wlc_inf
 }
 
 /* band-specific init */
-static void WLBANDINITFN(wlc_bsinit) (wlc_info_t * wlc) {
+static void WLBANDINITFN(wlc_bsinit) (wlc_info_t *wlc) {
 	WL_TRACE(("wl%d: wlc_bsinit: bandunit %d\n", wlc->pub->unit,
 		  wlc->band->bandunit));
 
@@ -1343,7 +1343,7 @@ static void WLBANDINITFN(wlc_bsinit) (wl
 }
 
 /* switch to and initialize new band */
-static void WLBANDINITFN(wlc_setband) (wlc_info_t * wlc, uint bandunit) {
+static void WLBANDINITFN(wlc_setband) (wlc_info_t *wlc, uint bandunit) {
 	int idx;
 	wlc_bsscfg_t *cfg;
 
@@ -1367,7 +1367,7 @@ static void WLBANDINITFN(wlc_setband) (w
 }
 
 /* Initialize a WME Parameter Info Element with default STA parameters from WMM Spec, Table 12 */
-void wlc_wme_initparams_sta(wlc_info_t * wlc, wme_param_ie_t * pe)
+void wlc_wme_initparams_sta(wlc_info_t *wlc, wme_param_ie_t *pe)
 {
 	static const wme_param_ie_t stadef = {
 		WME_OUI,
@@ -1392,7 +1392,7 @@ void wlc_wme_initparams_sta(wlc_info_t *
 	memcpy(pe, &stadef, sizeof(*pe));
 }
 
-void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg, bool suspend)
+void wlc_wme_setparams(wlc_info_t *wlc, u16 aci, void *arg, bool suspend)
 {
 	int i;
 	shm_acparams_t acp_shm;
@@ -1471,7 +1471,7 @@ void wlc_wme_setparams(wlc_info_t * wlc,
 
 }
 
-void wlc_edcf_setparams(wlc_bsscfg_t * cfg, bool suspend)
+void wlc_edcf_setparams(wlc_bsscfg_t *cfg, bool suspend)
 {
 	wlc_info_t *wlc = cfg->wlc;
 	uint aci, i, j;
@@ -1562,7 +1562,7 @@ void wlc_edcf_setparams(wlc_bsscfg_t * c
 
 }
 
-bool BCMATTACHFN(wlc_timers_init) (wlc_info_t * wlc, int unit) {
+bool BCMATTACHFN(wlc_timers_init) (wlc_info_t *wlc, int unit) {
 	if (!
 	    (wlc->wdtimer =
 	     wl_init_timer(wlc->wl, wlc_watchdog_by_timer, wlc, "watchdog"))) {
@@ -1588,7 +1588,7 @@ bool BCMATTACHFN(wlc_timers_init) (wlc_i
  * Initialize wlc_info default values ...
  * may get overrides later in this function
  */
-void BCMATTACHFN(wlc_info_init) (wlc_info_t * wlc, int unit) {
+void BCMATTACHFN(wlc_info_init) (wlc_info_t *wlc, int unit) {
 	int i;
 	/* Assume the device is there until proven otherwise */
 	wlc->device_present = TRUE;
@@ -1698,7 +1698,7 @@ void BCMATTACHFN(wlc_info_init) (wlc_inf
 	wlc->pr80838_war = TRUE;
 }
 
-static bool wlc_state_bmac_sync(wlc_info_t * wlc)
+static bool wlc_state_bmac_sync(wlc_info_t *wlc)
 {
 	wlc_bmac_state_t state_bmac;
 
@@ -1712,7 +1712,7 @@ static bool wlc_state_bmac_sync(wlc_info
 	return TRUE;
 }
 
-static uint BCMATTACHFN(wlc_attach_module) (wlc_info_t * wlc) {
+static uint BCMATTACHFN(wlc_attach_module) (wlc_info_t *wlc) {
 	uint err = 0;
 	uint unit;
 	unit = wlc->pub->unit;
@@ -1760,9 +1760,9 @@ wlc_pub_t *wlc_pub(void *wlc)
  * The common driver entry routine. Error codes should be unique
  */
 void *BCMATTACHFN(wlc_attach) (void *wl, uint16 vendor, uint16 device,
-			       uint unit, bool piomode, osl_t * osh,
+			       uint unit, bool piomode, osl_t *osh,
 			       void *regsva, uint bustype, void *btparam,
-			       uint * perr) {
+			       uint *perr) {
 	wlc_info_t *wlc;
 	uint err = 0;
 	uint j;
@@ -2080,7 +2080,7 @@ void *BCMATTACHFN(wlc_attach) (void *wl,
 	return (NULL);
 }
 
-static void BCMNMIATTACHFN(wlc_attach_antgain_init) (wlc_info_t * wlc) {
+static void BCMNMIATTACHFN(wlc_attach_antgain_init) (wlc_info_t *wlc) {
 	uint unit;
 	unit = wlc->pub->unit;
 
@@ -2110,7 +2110,7 @@ static void BCMNMIATTACHFN(wlc_attach_an
 	}
 }
 
-static bool BCMATTACHFN(wlc_attach_stf_ant_init) (wlc_info_t * wlc) {
+static bool BCMATTACHFN(wlc_attach_stf_ant_init) (wlc_info_t *wlc) {
 	int aa;
 	uint unit;
 	char *vars;
@@ -2151,8 +2151,8 @@ static bool BCMATTACHFN(wlc_attach_stf_a
 #ifdef WLC_HIGH_ONLY
 /* HIGH_ONLY bmac_attach, which sync over LOW_ONLY bmac_attach states */
 int
-BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
-			      uint unit, bool piomode, osl_t * osh,
+BCMATTACHFN(wlc_bmac_attach) (wlc_info_t *wlc, uint16 vendor, uint16 device,
+			      uint unit, bool piomode, osl_t *osh,
 			      void *regsva, uint bustype, void *btparam) {
 	wlc_bmac_revinfo_t revinfo;
 	uint idx = 0;
@@ -2250,7 +2250,7 @@ BCMATTACHFN(wlc_bmac_attach) (wlc_info_t
 }
 
 /* Free the convenience handles */
-int wlc_bmac_detach(wlc_info_t * wlc)
+int wlc_bmac_detach(wlc_info_t *wlc)
 {
 	uint idx;
 
@@ -2277,7 +2277,7 @@ int wlc_bmac_detach(wlc_info_t * wlc)
 
 #endif				/* WLC_HIGH_ONLY */
 
-static void BCMATTACHFN(wlc_timers_deinit) (wlc_info_t * wlc) {
+static void BCMATTACHFN(wlc_timers_deinit) (wlc_info_t *wlc) {
 	/* free timer state */
 	if (wlc->wdtimer) {
 		wl_free_timer(wlc->wl, wlc->wdtimer);
@@ -2289,7 +2289,7 @@ static void BCMATTACHFN(wlc_timers_deini
 	}
 }
 
-static void BCMATTACHFN(wlc_detach_module) (wlc_info_t * wlc) {
+static void BCMATTACHFN(wlc_detach_module) (wlc_info_t *wlc) {
 	if (wlc->asi) {
 		wlc_antsel_detach(wlc->asi);
 		wlc->asi = NULL;
@@ -2311,7 +2311,7 @@ static void BCMATTACHFN(wlc_detach_modul
  *    One exception is sb register access, which is possible if crystal is turned on
  * After "down" state, driver should avoid software timer with the exception of radio_monitor.
  */
-uint BCMATTACHFN(wlc_detach) (wlc_info_t * wlc) {
+uint BCMATTACHFN(wlc_detach) (wlc_info_t *wlc) {
 	uint i;
 	uint callbacks = 0;
 
@@ -2397,7 +2397,7 @@ uint BCMATTACHFN(wlc_detach) (wlc_info_t
 }
 
 /* update state that depends on the current value of "ap" */
-void wlc_ap_upd(wlc_info_t * wlc)
+void wlc_ap_upd(wlc_info_t *wlc)
 {
 	if (AP_ENAB(wlc->pub))
 		wlc->PLCPHdr_override = WLC_PLCP_AUTO;	/* AP: short not allowed, but not enforced */
@@ -2412,7 +2412,7 @@ void wlc_ap_upd(wlc_info_t * wlc)
 }
 
 /* read hwdisable state and propagate to wlc flag */
-static void wlc_radio_hwdisable_upd(wlc_info_t * wlc)
+static void wlc_radio_hwdisable_upd(wlc_info_t *wlc)
 {
 	if (wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO || wlc->pub->hw_off)
 		return;
@@ -2425,17 +2425,17 @@ static void wlc_radio_hwdisable_upd(wlc_
 }
 
 /* return TRUE if Minimum Power Consumption should be entered, FALSE otherwise */
-bool wlc_is_non_delay_mpc(wlc_info_t * wlc)
+bool wlc_is_non_delay_mpc(wlc_info_t *wlc)
 {
 	return (FALSE);
 }
 
-bool wlc_ismpc(wlc_info_t * wlc)
+bool wlc_ismpc(wlc_info_t *wlc)
 {
 	return ((wlc->mpc_delay_off == 0) && (wlc_is_non_delay_mpc(wlc)));
 }
 
-void wlc_radio_mpc_upd(wlc_info_t * wlc)
+void wlc_radio_mpc_upd(wlc_info_t *wlc)
 {
 	bool mpc_radio, radio_state;
 
@@ -2491,7 +2491,7 @@ void wlc_radio_mpc_upd(wlc_info_t * wlc)
  * centralized radio disable/enable function,
  * invoke radio enable/disable after updating hwradio status
  */
-static void wlc_radio_upd(wlc_info_t * wlc)
+static void wlc_radio_upd(wlc_info_t *wlc)
 {
 	if (wlc->pub->radio_disabled)
 		wlc_radio_disable(wlc);
@@ -2500,7 +2500,7 @@ static void wlc_radio_upd(wlc_info_t * w
 }
 
 /* maintain LED behavior in down state */
-static void wlc_down_led_upd(wlc_info_t * wlc)
+static void wlc_down_led_upd(wlc_info_t *wlc)
 {
 	ASSERT(!wlc->pub->up);
 
@@ -2513,7 +2513,7 @@ static void wlc_down_led_upd(wlc_info_t
 	}
 }
 
-void wlc_radio_disable(wlc_info_t * wlc)
+void wlc_radio_disable(wlc_info_t *wlc)
 {
 	if (!wlc->pub->up) {
 		wlc_down_led_upd(wlc);
@@ -2524,7 +2524,7 @@ void wlc_radio_disable(wlc_info_t * wlc)
 	wl_down(wlc->wl);
 }
 
-static void wlc_radio_enable(wlc_info_t * wlc)
+static void wlc_radio_enable(wlc_info_t *wlc)
 {
 	if (wlc->pub->up)
 		return;
@@ -2558,7 +2558,7 @@ static void wlc_radio_timer(void *arg)
 	wlc_radio_upd(wlc);
 }
 
-static bool wlc_radio_monitor_start(wlc_info_t * wlc)
+static bool wlc_radio_monitor_start(wlc_info_t *wlc)
 {
 	/* Don't start the timer if HWRADIO feature is disabled */
 	if (wlc->radio_monitor || (wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO))
@@ -2570,7 +2570,7 @@ static bool wlc_radio_monitor_start(wlc_
 	return TRUE;
 }
 
-bool wlc_radio_monitor_stop(wlc_info_t * wlc)
+bool wlc_radio_monitor_stop(wlc_info_t *wlc)
 {
 	if (!wlc->radio_monitor)
 		return TRUE;
@@ -2584,7 +2584,7 @@ bool wlc_radio_monitor_stop(wlc_info_t *
 }
 
 /* bring the driver down, but don't reset hardware */
-void wlc_out(wlc_info_t * wlc)
+void wlc_out(wlc_info_t *wlc)
 {
 	wlc_bmac_set_noreset(wlc->hw, TRUE);
 	wlc_radio_upd(wlc);
@@ -2605,7 +2605,7 @@ void wlc_out(wlc_info_t * wlc)
  * if there is no packet pending for the FIFO, then the corresponding prec bits should be set
  * in prec_map. Of course, ignore this rule when block_datafifo is set
  */
-static bool wlc_tx_prec_map_verify(wlc_info_t * wlc)
+static bool wlc_tx_prec_map_verify(wlc_info_t *wlc)
 {
 	/* For non-WME, both fifos have overlapping prec_map. So it's an error only if both
 	 * fail the check.
@@ -2728,7 +2728,7 @@ static void wlc_watchdog(void *arg)
 }
 
 /* make interface operational */
-int BCMINITFN(wlc_up) (wlc_info_t * wlc) {
+int BCMINITFN(wlc_up) (wlc_info_t *wlc) {
 	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __func__));
 
 	/* HW is turned off so don't try to access it */
@@ -2835,7 +2835,7 @@ int BCMINITFN(wlc_up) (wlc_info_t * wlc)
 }
 
 /* Initialize the base precedence map for dequeueing from txq based on WME settings */
-static void BCMINITFN(wlc_tx_prec_map_init) (wlc_info_t * wlc) {
+static void BCMINITFN(wlc_tx_prec_map_init) (wlc_info_t *wlc) {
 	wlc->tx_prec_map = WLC_PREC_BMP_ALL;
 	bzero(wlc->fifo2prec_map, sizeof(uint16) * NFIFO);
 
@@ -2853,7 +2853,7 @@ static void BCMINITFN(wlc_tx_prec_map_in
 	}
 }
 
-static uint BCMUNINITFN(wlc_down_del_timer) (wlc_info_t * wlc) {
+static uint BCMUNINITFN(wlc_down_del_timer) (wlc_info_t *wlc) {
 	uint callbacks = 0;
 
 	return callbacks;
@@ -2864,7 +2864,7 @@ static uint BCMUNINITFN(wlc_down_del_tim
  * disable the hardware, free any transient buffer state.
  * Return a count of the number of driver callbacks still pending.
  */
-uint BCMUNINITFN(wlc_down) (wlc_info_t * wlc) {
+uint BCMUNINITFN(wlc_down) (wlc_info_t *wlc) {
 
 	uint callbacks = 0;
 	int i;
@@ -2953,7 +2953,7 @@ uint BCMUNINITFN(wlc_down) (wlc_info_t *
 }
 
 /* Set the current gmode configuration */
-int wlc_set_gmode(wlc_info_t * wlc, uint8 gmode, bool config)
+int wlc_set_gmode(wlc_info_t *wlc, uint8 gmode, bool config)
 {
 	int ret = 0;
 	uint i;
@@ -3103,7 +3103,7 @@ int wlc_set_gmode(wlc_info_t * wlc, uint
 	return ret;
 }
 
-static int wlc_nmode_validate(wlc_info_t * wlc, int32 nmode)
+static int wlc_nmode_validate(wlc_info_t *wlc, int32 nmode)
 {
 	int err = 0;
 
@@ -3127,7 +3127,7 @@ static int wlc_nmode_validate(wlc_info_t
 	return err;
 }
 
-int wlc_set_nmode(wlc_info_t * wlc, int32 nmode)
+int wlc_set_nmode(wlc_info_t *wlc, int32 nmode)
 {
 	uint i;
 	int err;
@@ -3186,7 +3186,7 @@ int wlc_set_nmode(wlc_info_t * wlc, int3
 	return err;
 }
 
-static int wlc_set_rateset(wlc_info_t * wlc, wlc_rateset_t * rs_arg)
+static int wlc_set_rateset(wlc_info_t *wlc, wlc_rateset_t *rs_arg)
 {
 	wlc_rateset_t rs, new;
 	uint bandunit;
@@ -3229,18 +3229,18 @@ static int wlc_set_rateset(wlc_info_t *
 }
 
 /* simplified integer set interface for common ioctl handler */
-int wlc_set(wlc_info_t * wlc, int cmd, int arg)
+int wlc_set(wlc_info_t *wlc, int cmd, int arg)
 {
 	return wlc_ioctl(wlc, cmd, (void *)&arg, sizeof(arg), NULL);
 }
 
 /* simplified integer get interface for common ioctl handler */
-int wlc_get(wlc_info_t * wlc, int cmd, int *arg)
+int wlc_get(wlc_info_t *wlc, int cmd, int *arg)
 {
 	return wlc_ioctl(wlc, cmd, arg, sizeof(int), NULL);
 }
 
-static void wlc_ofdm_rateset_war(wlc_info_t * wlc)
+static void wlc_ofdm_rateset_war(wlc_info_t *wlc)
 {
 	uint8 r;
 	bool war = FALSE;
@@ -3256,14 +3256,14 @@ static void wlc_ofdm_rateset_war(wlc_inf
 }
 
 int
-wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
+wlc_ioctl(wlc_info_t *wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 {
 	return (_wlc_ioctl(wlc, cmd, arg, len, wlcif));
 }
 
 /* common ioctl handler. return: 0=ok, -1=error, positive=particular error */
 static int
-_wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
+_wlc_ioctl(wlc_info_t *wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
 {
 	int val, *pval;
 	bool bool_val;
@@ -4422,7 +4422,7 @@ _wlc_ioctl(wlc_info_t * wlc, int cmd, vo
 
 #if defined(BCMDBG)
 /* consolidated register access ioctl error checking */
-int wlc_iocregchk(wlc_info_t * wlc, uint band)
+int wlc_iocregchk(wlc_info_t *wlc, uint band)
 {
 	/* if band is specified, it must be the current band */
 	if ((band != WLC_BAND_AUTO) && (band != (uint) wlc->band->bandtype))
@@ -4442,7 +4442,7 @@ int wlc_iocregchk(wlc_info_t * wlc, uint
 
 #if defined(BCMDBG)
 /* For some ioctls, make sure that the pi pointer matches the current phy */
-int wlc_iocpichk(wlc_info_t * wlc, uint phytype)
+int wlc_iocpichk(wlc_info_t *wlc, uint phytype)
 {
 	if (wlc->band->phytype != phytype)
 		return BCME_BADBAND;
@@ -4451,7 +4451,7 @@ int wlc_iocpichk(wlc_info_t * wlc, uint
 #endif
 
 /* Look up the given var name in the given table */
-static const bcm_iovar_t *wlc_iovar_lookup(const bcm_iovar_t * table,
+static const bcm_iovar_t *wlc_iovar_lookup(const bcm_iovar_t *table,
 					   const char *name)
 {
 	const bcm_iovar_t *vi;
@@ -4476,21 +4476,21 @@ static const bcm_iovar_t *wlc_iovar_look
 }
 
 /* simplified integer get interface for common WLC_GET_VAR ioctl handler */
-int wlc_iovar_getint(wlc_info_t * wlc, const char *name, int *arg)
+int wlc_iovar_getint(wlc_info_t *wlc, const char *name, int *arg)
 {
 	return wlc_iovar_op(wlc, name, NULL, 0, arg, sizeof(int32), IOV_GET,
 			    NULL);
 }
 
 /* simplified integer set interface for common WLC_SET_VAR ioctl handler */
-int wlc_iovar_setint(wlc_info_t * wlc, const char *name, int arg)
+int wlc_iovar_setint(wlc_info_t *wlc, const char *name, int arg)
 {
 	return wlc_iovar_op(wlc, name, NULL, 0, (void *)&arg, sizeof(arg),
 			    IOV_SET, NULL);
 }
 
 /* simplified int8 get interface for common WLC_GET_VAR ioctl handler */
-int wlc_iovar_getint8(wlc_info_t * wlc, const char *name, int8 * arg)
+int wlc_iovar_getint8(wlc_info_t *wlc, const char *name, int8 *arg)
 {
 	int iovar_int;
 	int err;
@@ -4510,7 +4510,7 @@ int wlc_iovar_getint8(wlc_info_t * wlc,
  * 'iovar' must have the last entry's name field being NULL as terminator.
  */
 int
-BCMATTACHFN(wlc_module_register) (wlc_pub_t * pub, const bcm_iovar_t * iovars,
+BCMATTACHFN(wlc_module_register) (wlc_pub_t *pub, const bcm_iovar_t *iovars,
 				  const char *name, void *hdl, iovar_fn_t i_fn,
 				  watchdog_fn_t w_fn, down_fn_t d_fn) {
 	wlc_info_t *wlc = (wlc_info_t *) pub->wlc;
@@ -4540,7 +4540,7 @@ BCMATTACHFN(wlc_module_register) (wlc_pu
 
 /* unregister module callbacks */
 int
-BCMATTACHFN(wlc_module_unregister) (wlc_pub_t * pub, const char *name,
+BCMATTACHFN(wlc_module_unregister) (wlc_pub_t *pub, const char *name,
 				    void *hdl) {
 	wlc_info_t *wlc = (wlc_info_t *) pub->wlc;
 	int i;
@@ -4563,7 +4563,7 @@ BCMATTACHFN(wlc_module_unregister) (wlc_
 }
 
 /* Write WME tunable parameters for retransmit/max rate from wlc struct to ucode */
-static void wlc_wme_retries_write(wlc_info_t * wlc)
+static void wlc_wme_retries_write(wlc_info_t *wlc)
 {
 	int ac;
 
@@ -4585,7 +4585,7 @@ static void wlc_wme_retries_write(wlc_in
  * All pointers may point into the same buffer.
  */
 int
-wlc_iovar_op(wlc_info_t * wlc, const char *name,
+wlc_iovar_op(wlc_info_t *wlc, const char *name,
 	     void *params, int p_len, void *arg, int len,
 	     bool set, struct wlc_if *wlcif)
 {
@@ -4660,7 +4660,7 @@ wlc_iovar_op(wlc_info_t * wlc, const cha
 }
 
 int
-wlc_iovar_check(wlc_pub_t * pub, const bcm_iovar_t * vi, void *arg, int len,
+wlc_iovar_check(wlc_pub_t *pub, const bcm_iovar_t *vi, void *arg, int len,
 		bool set)
 {
 	wlc_info_t *wlc = (wlc_info_t *) pub->wlc;
@@ -4726,7 +4726,7 @@ wlc_iovar_check(wlc_pub_t * pub, const b
  * Please use params for additional qualifying parameters.
  */
 int
-wlc_doiovar(void *hdl, const bcm_iovar_t * vi, uint32 actionid,
+wlc_doiovar(void *hdl, const bcm_iovar_t *vi, uint32 actionid,
 	    const char *name, void *params, uint p_len, void *arg, int len,
 	    int val_size, struct wlc_if *wlcif)
 {
@@ -4835,7 +4835,7 @@ wlc_doiovar(void *hdl, const bcm_iovar_t
 }
 
 static int
-wlc_iovar_rangecheck(wlc_info_t * wlc, uint32 val, const bcm_iovar_t * vi)
+wlc_iovar_rangecheck(wlc_info_t *wlc, uint32 val, const bcm_iovar_t *vi)
 {
 	int err = 0;
 	uint32 min_val = 0;
@@ -4943,7 +4943,7 @@ static void wlc_print_txs_status(uint16
 }
 #endif				/* BCMDBG */
 
-void wlc_print_txstatus(tx_status_t * txs)
+void wlc_print_txstatus(tx_status_t *txs)
 {
 #if defined(BCMDBG)
 	uint16 s = txs->status;
@@ -4970,7 +4970,7 @@ void wlc_print_txstatus(tx_status_t * tx
 #define MACSTATUPD(name) \
 	wlc_ctrupd_cache(macstats.name, &wlc->core->macstat_snapshot->name, &wlc->pub->_cnt->name)
 
-void wlc_statsupd(wlc_info_t * wlc)
+void wlc_statsupd(wlc_info_t *wlc)
 {
 	int i;
 #ifdef BCMDBG
@@ -5074,7 +5074,7 @@ bool wlc_chipmatch(uint16 vendor, uint16
 #if defined(BCMDBG)
 static const char *errstr = "802.11 Header INCOMPLETE\n";
 static const char *fillstr = "------------";
-static void wlc_print_dot11hdr(uint8 * buf, int len)
+static void wlc_print_dot11hdr(uint8 *buf, int len)
 {
 	char hexbuf[(2 * D11B_PHY_HDR_LEN) + 1];
 
@@ -5104,7 +5104,7 @@ static void wlc_print_dot11hdr(uint8 * b
 	wlc_print_dot11_mac_hdr(buf, len);
 }
 
-void wlc_print_dot11_mac_hdr(uint8 * buf, int len)
+void wlc_print_dot11_mac_hdr(uint8 *buf, int len)
 {
 	char hexbuf[(2 * D11B_PHY_HDR_LEN) + 1];
 	char a1[(2 * ETHER_ADDR_LEN) + 1], a2[(2 * ETHER_ADDR_LEN) + 1];
@@ -5296,7 +5296,7 @@ void wlc_print_dot11_mac_hdr(uint8 * buf
 #endif				/* defined(BCMDBG) */
 
 #if defined(BCMDBG)
-void wlc_print_txdesc(d11txh_t * txh)
+void wlc_print_txdesc(d11txh_t *txh)
 {
 	uint16 mtcl = ltoh16(txh->MacTxControlLow);
 	uint16 mtch = ltoh16(txh->MacTxControlHigh);
@@ -5385,7 +5385,7 @@ void wlc_print_txdesc(d11txh_t * txh)
 #endif				/* defined(BCMDBG) */
 
 #if defined(BCMDBG)
-void wlc_print_rxh(d11rxhdr_t * rxh)
+void wlc_print_rxh(d11rxhdr_t *rxh)
 {
 	uint16 len = rxh->RxFrameSize;
 	uint16 phystatus_0 = rxh->PhyRxStatus_0;
@@ -5422,8 +5422,8 @@ void wlc_print_rxh(d11rxhdr_t * rxh)
 }
 
 void
-wlc_print_hdrs(wlc_info_t * wlc, const char *prefix, uint8 * frame,
-	       d11txh_t * txh, d11rxhdr_t * rxh, uint len)
+wlc_print_hdrs(wlc_info_t *wlc, const char *prefix, uint8 *frame,
+	       d11txh_t *txh, d11rxhdr_t *rxh, uint len)
 {
 	ASSERT(!(txh && rxh));
 
@@ -5470,7 +5470,7 @@ int wlc_format_ssid(char *buf, const uch
 }
 #endif				/* defined(BCMDBG) */
 
-uint16 wlc_rate_shm_offset(wlc_info_t * wlc, uint8 rate)
+uint16 wlc_rate_shm_offset(wlc_info_t *wlc, uint8 rate)
 {
 	return (wlc_bmac_rate_shm_offset(wlc->hw, rate));
 }
@@ -5495,13 +5495,13 @@ void wlc_device_removed(void *arg)
  * Returns TRUE if packet consumed (queued), FALSE if not.
  */
 bool BCMFASTPATH
-wlc_prec_enq(wlc_info_t * wlc, struct pktq *q, void *pkt, int prec)
+wlc_prec_enq(wlc_info_t *wlc, struct pktq *q, void *pkt, int prec)
 {
 	return wlc_prec_enq_head(wlc, q, pkt, prec, FALSE);
 }
 
 bool BCMFASTPATH
-wlc_prec_enq_head(wlc_info_t * wlc, struct pktq * q, void *pkt, int prec,
+wlc_prec_enq_head(wlc_info_t *wlc, struct pktq *q, void *pkt, int prec,
 		  bool head)
 {
 	void *p;
@@ -5605,7 +5605,7 @@ void BCMFASTPATH wlc_txq_enq(void *ctx,
 }
 
 bool BCMFASTPATH
-wlc_sendpkt_mac80211(wlc_info_t * wlc, void *sdu, struct ieee80211_hw *hw)
+wlc_sendpkt_mac80211(wlc_info_t *wlc, void *sdu, struct ieee80211_hw *hw)
 {
 	uint8 prio;
 	uint fifo;
@@ -5640,7 +5640,7 @@ wlc_sendpkt_mac80211(wlc_info_t * wlc, v
 	return 0;
 }
 
-void BCMFASTPATH wlc_send_q(wlc_info_t * wlc, wlc_txq_info_t * qi)
+void BCMFASTPATH wlc_send_q(wlc_info_t *wlc, wlc_txq_info_t *qi)
 {
 	void *pkt[DOT11_MAXNUMFRAGS];
 	int prec;
@@ -5715,7 +5715,7 @@ void BCMFASTPATH wlc_send_q(wlc_info_t *
  * for MC frames so is used as part of the sequence number.
  */
 static INLINE uint16
-bcmc_fid_generate(wlc_info_t * wlc, wlc_bsscfg_t * bsscfg, d11txh_t * txh)
+bcmc_fid_generate(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, d11txh_t *txh)
 {
 	uint16 frameid;
 
@@ -5729,7 +5729,7 @@ bcmc_fid_generate(wlc_info_t * wlc, wlc_
 }
 
 void BCMFASTPATH
-wlc_txfifo(wlc_info_t * wlc, uint fifo, void *p, bool commit, int8 txpktpend)
+wlc_txfifo(wlc_info_t *wlc, uint fifo, void *p, bool commit, int8 txpktpend)
 {
 	uint16 frameid = INVALIDFID;
 	d11txh_t *txh;
@@ -5776,7 +5776,7 @@ wlc_txfifo(wlc_info_t * wlc, uint fifo,
 }
 
 static uint16
-wlc_compute_airtime(wlc_info_t * wlc, ratespec_t rspec, uint length)
+wlc_compute_airtime(wlc_info_t *wlc, ratespec_t rspec, uint length)
 {
 	uint16 usec = 0;
 	uint mac_rate = RSPEC2RATE(rspec);
@@ -5821,7 +5821,7 @@ wlc_compute_airtime(wlc_info_t * wlc, ra
 }
 
 void BCMFASTPATH
-wlc_compute_plcp(wlc_info_t * wlc, ratespec_t rspec, uint length, uint8 * plcp)
+wlc_compute_plcp(wlc_info_t *wlc, ratespec_t rspec, uint length, uint8 *plcp)
 {
 	if (IS_MCS(rspec)) {
 		wlc_compute_mimo_plcp(rspec, length, plcp);
@@ -5834,7 +5834,7 @@ wlc_compute_plcp(wlc_info_t * wlc, rates
 }
 
 /* Rate: 802.11 rate code, length: PSDU length in octets */
-static void wlc_compute_mimo_plcp(ratespec_t rspec, uint length, uint8 * plcp)
+static void wlc_compute_mimo_plcp(ratespec_t rspec, uint length, uint8 *plcp)
 {
 	uint8 mcs = (uint8) (rspec & RSPEC_RATE_MASK);
 	ASSERT(IS_MCS(rspec));
@@ -5850,7 +5850,7 @@ static void wlc_compute_mimo_plcp(ratesp
 
 /* Rate: 802.11 rate code, length: PSDU length in octets */
 static void BCMFASTPATH
-wlc_compute_ofdm_plcp(ratespec_t rspec, uint32 length, uint8 * plcp)
+wlc_compute_ofdm_plcp(ratespec_t rspec, uint32 length, uint8 *plcp)
 {
 	uint8 rate_signal;
 	uint32 tmp = 0;
@@ -5880,7 +5880,7 @@ wlc_compute_ofdm_plcp(ratespec_t rspec,
  * Broken out for PRQ.
  */
 
-static void wlc_cck_plcp_set(int rate_500, uint length, uint8 * plcp)
+static void wlc_cck_plcp_set(int rate_500, uint length, uint8 *plcp)
 {
 	uint16 usec = 0;
 	uint8 le = 0;
@@ -5925,7 +5925,7 @@ static void wlc_cck_plcp_set(int rate_50
 }
 
 /* Rate: 802.11 rate code, length: PSDU length in octets */
-static void wlc_compute_cck_plcp(ratespec_t rspec, uint length, uint8 * plcp)
+static void wlc_compute_cck_plcp(ratespec_t rspec, uint length, uint8 *plcp)
 {
 	int rate = RSPEC2RATE(rspec);
 
@@ -5945,7 +5945,7 @@ static void wlc_compute_cck_plcp(ratespe
  * preamble_type	use short/GF or long/MM PLCP header
  */
 static uint16 BCMFASTPATH
-wlc_compute_frame_dur(wlc_info_t * wlc, ratespec_t rate, uint8 preamble_type,
+wlc_compute_frame_dur(wlc_info_t *wlc, ratespec_t rate, uint8 preamble_type,
 		      uint next_frag_len)
 {
 	uint16 dur, sifs;
@@ -5979,7 +5979,7 @@ wlc_compute_frame_dur(wlc_info_t * wlc,
  * frame_len		next MPDU frame length in bytes
  */
 uint16 BCMFASTPATH
-wlc_compute_rtscts_dur(wlc_info_t * wlc, bool cts_only, ratespec_t rts_rate,
+wlc_compute_rtscts_dur(wlc_info_t *wlc, bool cts_only, ratespec_t rts_rate,
 		       ratespec_t frame_rate, uint8 rts_preamble_type,
 		       uint8 frame_preamble_type, uint frame_len, bool ba)
 {
@@ -6010,7 +6010,7 @@ wlc_compute_rtscts_dur(wlc_info_t * wlc,
 	return (dur);
 }
 
-static bool wlc_phy_rspec_check(wlc_info_t * wlc, uint16 bw, ratespec_t rspec)
+static bool wlc_phy_rspec_check(wlc_info_t *wlc, uint16 bw, ratespec_t rspec)
 {
 	if (IS_MCS(rspec)) {
 		uint mcs = rspec & RSPEC_RATE_MASK;
@@ -6036,7 +6036,7 @@ static bool wlc_phy_rspec_check(wlc_info
 	return TRUE;
 }
 
-uint16 BCMFASTPATH wlc_phytxctl1_calc(wlc_info_t * wlc, ratespec_t rspec)
+uint16 BCMFASTPATH wlc_phytxctl1_calc(wlc_info_t *wlc, ratespec_t rspec)
 {
 	uint16 phyctl1 = 0;
 	uint16 bw;
@@ -6094,7 +6094,7 @@ uint16 BCMFASTPATH wlc_phytxctl1_calc(wl
 }
 
 ratespec_t BCMFASTPATH
-wlc_rspec_to_rts_rspec(wlc_info_t * wlc, ratespec_t rspec, bool use_rspec,
+wlc_rspec_to_rts_rspec(wlc_info_t *wlc, ratespec_t rspec, bool use_rspec,
 		       uint16 mimo_ctlchbw)
 {
 	ratespec_t rts_rspec = 0;
@@ -6150,10 +6150,10 @@ wlc_rspec_to_rts_rspec(wlc_info_t * wlc,
  *
  */
 static uint16 BCMFASTPATH
-wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
+wlc_d11hdrs_mac80211(wlc_info_t *wlc, struct ieee80211_hw *hw,
 		     void *p, struct scb *scb, uint frag,
 		     uint nfrags, uint queue, uint next_frag_len,
-		     wsec_key_t * key, ratespec_t rspec_override)
+		     wsec_key_t *key, ratespec_t rspec_override)
 {
 	struct dot11_header *h;
 	d11txh_t *txh;
@@ -6821,7 +6821,7 @@ wlc_d11hdrs_mac80211(wlc_info_t * wlc, s
 	return 0;
 }
 
-void wlc_tbtt(wlc_info_t * wlc, d11regs_t * regs)
+void wlc_tbtt(wlc_info_t *wlc, d11regs_t *regs)
 {
 	wlc_bsscfg_t *cfg = wlc->cfg;
 
@@ -6857,19 +6857,19 @@ void wlc_tbtt(wlc_info_t * wlc, d11regs_
 }
 
 /* GP timer is a freerunning 32 bit counter, decrements at 1 us rate */
-void wlc_hwtimer_gptimer_set(wlc_info_t * wlc, uint us)
+void wlc_hwtimer_gptimer_set(wlc_info_t *wlc, uint us)
 {
 	ASSERT(wlc->pub->corerev >= 3);	/* no gptimer in earlier revs */
 	W_REG(wlc->osh, &wlc->regs->gptimer, us);
 }
 
-void wlc_hwtimer_gptimer_abort(wlc_info_t * wlc)
+void wlc_hwtimer_gptimer_abort(wlc_info_t *wlc)
 {
 	ASSERT(wlc->pub->corerev >= 3);
 	W_REG(wlc->osh, &wlc->regs->gptimer, 0);
 }
 
-static void wlc_hwtimer_gptimer_cb(wlc_info_t * wlc)
+static void wlc_hwtimer_gptimer_cb(wlc_info_t *wlc)
 {
 	/* when interrupt is generated, the counter is loaded with last value
 	 * written and continue to decrement. So it has to be cleaned first
@@ -6882,7 +6882,7 @@ static void wlc_hwtimer_gptimer_cb(wlc_i
  * POLICY: no macinstatus change, no bounding loop.
  *         All dpc bounding should be handled in BMAC dpc, like txstatus and rxint
  */
-void wlc_high_dpc(wlc_info_t * wlc, uint32 macintstatus)
+void wlc_high_dpc(wlc_info_t *wlc, uint32 macintstatus)
 {
 	d11regs_t *regs = wlc->regs;
 #ifdef BCMDBG
@@ -6977,7 +6977,7 @@ void wlc_high_dpc(wlc_info_t * wlc, uint
 #endif
 }
 
-static void *wlc_15420war(wlc_info_t * wlc, uint queue)
+static void *wlc_15420war(wlc_info_t *wlc, uint queue)
 {
 	hnddma_t *di;
 	void *p;
@@ -7007,7 +7007,7 @@ static void *wlc_15420war(wlc_info_t * w
 	return (p);
 }
 
-static void wlc_war16165(wlc_info_t * wlc, bool tx)
+static void wlc_war16165(wlc_info_t *wlc, bool tx)
 {
 	if (tx) {
 		/* the post-increment is used in STAY_AWAKE macro */
@@ -7023,7 +7023,7 @@ static void wlc_war16165(wlc_info_t * wl
 /* process an individual tx_status_t */
 /* WLC_HIGH_API */
 bool BCMFASTPATH
-wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2)
+wlc_dotxstatus(wlc_info_t *wlc, tx_status_t *txs, uint32 frm_tx2)
 {
 	void *p;
 	uint queue;
@@ -7196,7 +7196,7 @@ wlc_dotxstatus(wlc_info_t * wlc, tx_stat
 }
 
 void BCMFASTPATH
-wlc_txfifo_complete(wlc_info_t * wlc, uint fifo, int8 txpktpend)
+wlc_txfifo_complete(wlc_info_t *wlc, uint fifo, int8 txpktpend)
 {
 	TXPKTPENDDEC(wlc, fifo, txpktpend);
 	WL_TRACE(("wlc_txfifo_complete, pktpend dec %d to %d\n", txpktpend,
@@ -7300,7 +7300,7 @@ uint32 wlc_calc_tbtt_offset(uint32 bp, u
 }
 
 /* Update beacon listen interval in shared memory */
-void wlc_bcn_li_upd(wlc_info_t * wlc)
+void wlc_bcn_li_upd(wlc_info_t *wlc)
 {
 	if (AP_ENAB(wlc->pub))
 		return;
@@ -7314,7 +7314,7 @@ void wlc_bcn_li_upd(wlc_info_t * wlc)
 }
 
 static void
-prep_mac80211_status(wlc_info_t * wlc, d11rxhdr_t * rxh, void *p,
+prep_mac80211_status(wlc_info_t *wlc, d11rxhdr_t *rxh, void *p,
 		     struct ieee80211_rx_status *rx_status)
 {
 	uint32 tsf_l, tsf_h;
@@ -7513,7 +7513,7 @@ char *print_fk(uint16 fk)
 }
 
 static void
-wlc_recvctl(wlc_info_t * wlc, osl_t * osh, d11rxhdr_t * rxh, void *p)
+wlc_recvctl(wlc_info_t *wlc, osl_t *osh, d11rxhdr_t *rxh, void *p)
 {
 	int len_mpdu;
 	struct ieee80211_rx_status rx_status;
@@ -7547,7 +7547,7 @@ wlc_recvctl(wlc_info_t * wlc, osl_t * os
 	return;
 }
 
-void wlc_bss_list_free(wlc_info_t * wlc, wlc_bss_list_t * bss_list)
+void wlc_bss_list_free(wlc_info_t *wlc, wlc_bss_list_t *bss_list)
 {
 	uint index;
 	wlc_bss_info_t *bi;
@@ -7577,7 +7577,7 @@ void wlc_bss_list_free(wlc_info_t * wlc,
  * Param 'bound' indicates max. # frames to process before break out.
  */
 /* WLC_HIGH_API */
-void BCMFASTPATH wlc_recv(wlc_info_t * wlc, void *p)
+void BCMFASTPATH wlc_recv(wlc_info_t *wlc, void *p)
 {
 	d11rxhdr_t *rxh;
 	struct dot11_header *h;
@@ -7674,7 +7674,7 @@ void BCMFASTPATH wlc_recv(wlc_info_t * w
  *   len = 3(nsyms + nstream + 3) - 3
  */
 uint16 BCMFASTPATH
-wlc_calc_lsig_len(wlc_info_t * wlc, ratespec_t ratespec, uint mac_len)
+wlc_calc_lsig_len(wlc_info_t *wlc, ratespec_t ratespec, uint mac_len)
 {
 	uint nsyms, len = 0, kNdps;
 
@@ -7715,7 +7715,7 @@ wlc_calc_lsig_len(wlc_info_t * wlc, rate
 
 /* calculate frame duration of a given rate and length, return time in usec unit */
 uint BCMFASTPATH
-wlc_calc_frame_time(wlc_info_t * wlc, ratespec_t ratespec, uint8 preamble_type,
+wlc_calc_frame_time(wlc_info_t *wlc, ratespec_t ratespec, uint8 preamble_type,
 		    uint mac_len)
 {
 	uint nsyms, dur = 0, Ndps, kNdps;
@@ -7785,7 +7785,7 @@ wlc_calc_frame_time(wlc_info_t * wlc, ra
 
 /* The opposite of wlc_calc_frame_time */
 static uint
-wlc_calc_frame_len(wlc_info_t * wlc, ratespec_t ratespec, uint8 preamble_type,
+wlc_calc_frame_len(wlc_info_t *wlc, ratespec_t ratespec, uint8 preamble_type,
 		   uint dur)
 {
 	uint nsyms, mac_len, Ndps, kNdps;
@@ -7831,7 +7831,7 @@ wlc_calc_frame_len(wlc_info_t * wlc, rat
 }
 
 static uint
-wlc_calc_ba_time(wlc_info_t * wlc, ratespec_t rspec, uint8 preamble_type)
+wlc_calc_ba_time(wlc_info_t *wlc, ratespec_t rspec, uint8 preamble_type)
 {
 	WL_TRACE(("wl%d: wlc_calc_ba_time: rspec 0x%x, preamble_type %d\n",
 		  wlc->pub->unit, rspec, preamble_type));
@@ -7848,7 +7848,7 @@ wlc_calc_ba_time(wlc_info_t * wlc, rates
 }
 
 static uint BCMFASTPATH
-wlc_calc_ack_time(wlc_info_t * wlc, ratespec_t rspec, uint8 preamble_type)
+wlc_calc_ack_time(wlc_info_t *wlc, ratespec_t rspec, uint8 preamble_type)
 {
 	uint dur = 0;
 
@@ -7868,7 +7868,7 @@ wlc_calc_ack_time(wlc_info_t * wlc, rate
 }
 
 static uint
-wlc_calc_cts_time(wlc_info_t * wlc, ratespec_t rspec, uint8 preamble_type)
+wlc_calc_cts_time(wlc_info_t *wlc, ratespec_t rspec, uint8 preamble_type)
 {
 	WL_TRACE(("wl%d: wlc_calc_cts_time: ratespec 0x%x, preamble_type %d\n",
 		  wlc->pub->unit, rspec, preamble_type));
@@ -7876,7 +7876,7 @@ wlc_calc_cts_time(wlc_info_t * wlc, rate
 }
 
 /* derive wlc->band->basic_rate[] table from 'rateset' */
-void wlc_rate_lookup_init(wlc_info_t * wlc, wlc_rateset_t * rateset)
+void wlc_rate_lookup_init(wlc_info_t *wlc, wlc_rateset_t *rateset)
 {
 	uint8 rate;
 	uint8 mandatory;
@@ -7965,7 +7965,7 @@ void wlc_rate_lookup_init(wlc_info_t * w
 	}
 }
 
-static void wlc_write_rate_shm(wlc_info_t * wlc, uint8 rate, uint8 basic_rate)
+static void wlc_write_rate_shm(wlc_info_t *wlc, uint8 rate, uint8 basic_rate)
 {
 	uint8 phy_rate, index;
 	uint8 basic_phy_rate, basic_index;
@@ -7998,7 +7998,7 @@ static void wlc_write_rate_shm(wlc_info_
 	wlc_write_shm(wlc, (basic_table + index * 2), basic_ptr);
 }
 
-static const wlc_rateset_t *wlc_rateset_get_hwrs(wlc_info_t * wlc)
+static const wlc_rateset_t *wlc_rateset_get_hwrs(wlc_info_t *wlc)
 {
 	const wlc_rateset_t *rs_dflt;
 
@@ -8015,7 +8015,7 @@ static const wlc_rateset_t *wlc_rateset_
 	return rs_dflt;
 }
 
-void wlc_set_ratetable(wlc_info_t * wlc)
+void wlc_set_ratetable(wlc_info_t *wlc)
 {
 	const wlc_rateset_t *rs_dflt;
 	wlc_rateset_t rs;
@@ -8051,7 +8051,7 @@ void wlc_set_ratetable(wlc_info_t * wlc)
  * Return true if the specified rate is supported by the specified band.
  * WLC_BAND_AUTO indicates the current band.
  */
-bool wlc_valid_rate(wlc_info_t * wlc, ratespec_t rspec, int band, bool verbose)
+bool wlc_valid_rate(wlc_info_t *wlc, ratespec_t rspec, int band, bool verbose)
 {
 	wlc_rateset_t *hw_rateset;
 	uint i;
@@ -8084,7 +8084,7 @@ bool wlc_valid_rate(wlc_info_t * wlc, ra
 	return (FALSE);
 }
 
-static void wlc_update_mimo_band_bwcap(wlc_info_t * wlc, uint8 bwcap)
+static void wlc_update_mimo_band_bwcap(wlc_info_t *wlc, uint8 bwcap)
 {
 	uint i;
 	wlcband_t *band;
@@ -8111,7 +8111,7 @@ static void wlc_update_mimo_band_bwcap(w
 	wlc->mimo_band_bwcap = bwcap;
 }
 
-void wlc_mod_prb_rsp_rate_table(wlc_info_t * wlc, uint frame_len)
+void wlc_mod_prb_rsp_rate_table(wlc_info_t *wlc, uint frame_len)
 {
 	const wlc_rateset_t *rs_dflt;
 	wlc_rateset_t rs;
@@ -8154,7 +8154,7 @@ void wlc_mod_prb_rsp_rate_table(wlc_info
 }
 
 uint16
-wlc_compute_bcntsfoff(wlc_info_t * wlc, ratespec_t rspec, bool short_preamble,
+wlc_compute_bcntsfoff(wlc_info_t *wlc, ratespec_t rspec, bool short_preamble,
 		      bool phydelay)
 {
 	uint bcntsfoff = 0;
@@ -8201,8 +8201,8 @@ wlc_compute_bcntsfoff(wlc_info_t * wlc,
  *	and included up to, but not including, the 4 byte FCS.
  */
 static void
-wlc_bcn_prb_template(wlc_info_t * wlc, uint type, ratespec_t bcn_rspec,
-		     wlc_bsscfg_t * cfg, uint16 * buf, int *len)
+wlc_bcn_prb_template(wlc_info_t *wlc, uint type, ratespec_t bcn_rspec,
+		     wlc_bsscfg_t *cfg, uint16 *buf, int *len)
 {
 	cck_phy_hdr_t *plcp;
 	struct dot11_management_header *h;
@@ -8268,7 +8268,7 @@ int wlc_get_header_len()
  * template updated.
  * Otherwise, it updates the hardware template.
  */
-void wlc_bss_update_beacon(wlc_info_t * wlc, wlc_bsscfg_t * cfg)
+void wlc_bss_update_beacon(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
 {
 	int len = BCN_TMPL_LEN;
 
@@ -8321,7 +8321,7 @@ void wlc_bss_update_beacon(wlc_info_t *
 /*
  * Update all beacons for the system.
  */
-void wlc_update_beacon(wlc_info_t * wlc)
+void wlc_update_beacon(wlc_info_t *wlc)
 {
 	int idx;
 	wlc_bsscfg_t *bsscfg;
@@ -8334,7 +8334,7 @@ void wlc_update_beacon(wlc_info_t * wlc)
 }
 
 /* Write ssid into shared memory */
-void wlc_shm_ssid_upd(wlc_info_t * wlc, wlc_bsscfg_t * cfg)
+void wlc_shm_ssid_upd(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
 {
 	uint8 *ssidptr = cfg->SSID;
 	uint16 base = M_SSID;
@@ -8350,7 +8350,7 @@ void wlc_shm_ssid_upd(wlc_info_t * wlc,
 		wlc_write_shm(wlc, M_SSIDLEN, (uint16) cfg->SSID_len);
 }
 
-void wlc_update_probe_resp(wlc_info_t * wlc, bool suspend)
+void wlc_update_probe_resp(wlc_info_t *wlc, bool suspend)
 {
 	int idx;
 	wlc_bsscfg_t *bsscfg;
@@ -8363,7 +8363,7 @@ void wlc_update_probe_resp(wlc_info_t *
 }
 
 void
-wlc_bss_update_probe_resp(wlc_info_t * wlc, wlc_bsscfg_t * cfg, bool suspend)
+wlc_bss_update_probe_resp(wlc_info_t *wlc, wlc_bsscfg_t *cfg, bool suspend)
 {
 	uint16 prb_resp[BCN_TMPL_LEN / 2];
 	int len = BCN_TMPL_LEN;
@@ -8404,7 +8404,7 @@ wlc_bss_update_probe_resp(wlc_info_t * w
 }
 
 /* prepares pdu for transmission. returns BCM error codes */
-int wlc_prep_pdu(wlc_info_t * wlc, void *pdu, uint * fifop)
+int wlc_prep_pdu(wlc_info_t *wlc, void *pdu, uint *fifop)
 {
 	osl_t *osh;
 	uint fifo;
@@ -8443,7 +8443,7 @@ int wlc_prep_pdu(wlc_info_t * wlc, void
 }
 
 /* init tx reported rate mechanism */
-void wlc_reprate_init(wlc_info_t * wlc)
+void wlc_reprate_init(wlc_info_t *wlc)
 {
 	int i;
 	wlc_bsscfg_t *bsscfg;
@@ -8454,7 +8454,7 @@ void wlc_reprate_init(wlc_info_t * wlc)
 }
 
 /* per bsscfg init tx reported rate mechanism */
-void wlc_bsscfg_reprate_init(wlc_bsscfg_t * bsscfg)
+void wlc_bsscfg_reprate_init(wlc_bsscfg_t *bsscfg)
 {
 	bsscfg->txrspecidx = 0;
 	bzero((char *)bsscfg->txrspec, sizeof(bsscfg->txrspec));
@@ -8463,7 +8463,7 @@ void wlc_bsscfg_reprate_init(wlc_bsscfg_
 /* Retrieve a consolidated set of revision information,
  * typically for the WLC_GET_REVINFO ioctl
  */
-int wlc_get_revision_info(wlc_info_t * wlc, void *buf, uint len)
+int wlc_get_revision_info(wlc_info_t *wlc, void *buf, uint len)
 {
 	wlc_rev_info_t *rinfo = (wlc_rev_info_t *) buf;
 
@@ -8497,7 +8497,7 @@ int wlc_get_revision_info(wlc_info_t * w
 	return BCME_OK;
 }
 
-void wlc_default_rateset(wlc_info_t * wlc, wlc_rateset_t * rs)
+void wlc_default_rateset(wlc_info_t *wlc, wlc_rateset_t *rs)
 {
 	wlc_rateset_default(rs, NULL, wlc->band->phytype, wlc->band->bandtype,
 			    FALSE, RATE_MASK_FULL, (bool) N_ENAB(wlc->pub),
@@ -8505,7 +8505,7 @@ void wlc_default_rateset(wlc_info_t * wl
 			    wlc->stf->txstreams);
 }
 
-static void BCMATTACHFN(wlc_bss_default_init) (wlc_info_t * wlc) {
+static void BCMATTACHFN(wlc_bss_default_init) (wlc_info_t *wlc) {
 	chanspec_t chanspec;
 	wlcband_t *band;
 	wlc_bss_info_t *bi = wlc->default_bss;
@@ -8557,7 +8557,7 @@ static void wlc_process_eventq(void *arg
 }
 
 void
-wlc_uint64_sub(uint32 * a_high, uint32 * a_low, uint32 b_high, uint32 b_low)
+wlc_uint64_sub(uint32 *a_high, uint32 *a_low, uint32 b_high, uint32 b_low)
 {
 	if (b_low > *a_low) {
 		/* low half needs a carry */
@@ -8568,7 +8568,7 @@ wlc_uint64_sub(uint32 * a_high, uint32 *
 }
 
 static ratespec_t
-mac80211_wlc_set_nrate(wlc_info_t * wlc, wlcband_t * cur_band, uint32 int_val)
+mac80211_wlc_set_nrate(wlc_info_t *wlc, wlcband_t *cur_band, uint32 int_val)
 {
 	uint8 stf = (int_val & NRATE_STF_MASK) >> NRATE_STF_SHIFT;
 	uint8 rate = int_val & NRATE_RATE_MASK;
@@ -8682,7 +8682,7 @@ mac80211_wlc_set_nrate(wlc_info_t * wlc,
 
 /* formula:  IDLE_BUSY_RATIO_X_16 = (100-duty_cycle)/duty_cycle*16 */
 static int
-wlc_duty_cycle_set(wlc_info_t * wlc, int duty_cycle, bool isOFDM,
+wlc_duty_cycle_set(wlc_info_t *wlc, int duty_cycle, bool isOFDM,
 		   bool writeToShm)
 {
 	int idle_busy_ratio_x_16 = 0;
@@ -8709,7 +8709,7 @@ wlc_duty_cycle_set(wlc_info_t * wlc, int
 }
 
 void
-wlc_pktengtx(wlc_info_t * wlc, wl_pkteng_t * pkteng, uint8 rate,
+wlc_pktengtx(wlc_info_t *wlc, wl_pkteng_t *pkteng, uint8 rate,
 	     struct ether_addr *sa, uint32 wait_delay)
 {
 	bool suspend;
@@ -8771,7 +8771,7 @@ wlc_pktengtx(wlc_info_t * wlc, wl_pkteng
 /* Read a single uint16 from shared memory.
  * SHM 'offset' needs to be an even address
  */
-uint16 wlc_read_shm(wlc_info_t * wlc, uint offset)
+uint16 wlc_read_shm(wlc_info_t *wlc, uint offset)
 {
 	return wlc_bmac_read_shm(wlc->hw, offset);
 }
@@ -8779,7 +8779,7 @@ uint16 wlc_read_shm(wlc_info_t * wlc, ui
 /* Write a single uint16 to shared memory.
  * SHM 'offset' needs to be an even address
  */
-void wlc_write_shm(wlc_info_t * wlc, uint offset, uint16 v)
+void wlc_write_shm(wlc_info_t *wlc, uint offset, uint16 v)
 {
 	wlc_bmac_write_shm(wlc->hw, offset, v);
 }
@@ -8788,7 +8788,7 @@ void wlc_write_shm(wlc_info_t * wlc, uin
  * SHM 'offset' needs to be an even address and
  * Range length 'len' must be an even number of bytes
  */
-void wlc_set_shm(wlc_info_t * wlc, uint offset, uint16 v, int len)
+void wlc_set_shm(wlc_info_t *wlc, uint offset, uint16 v, int len)
 {
 	/* offset and len need to be even */
 	ASSERT((offset & 1) == 0);
@@ -8804,7 +8804,7 @@ void wlc_set_shm(wlc_info_t * wlc, uint
  * SHM 'offset' needs to be an even address and
  * Buffer length 'len' must be an even number of bytes
  */
-void wlc_copyto_shm(wlc_info_t * wlc, uint offset, const void *buf, int len)
+void wlc_copyto_shm(wlc_info_t *wlc, uint offset, const void *buf, int len)
 {
 	/* offset and len need to be even */
 	ASSERT((offset & 1) == 0);
@@ -8820,7 +8820,7 @@ void wlc_copyto_shm(wlc_info_t * wlc, ui
  * SHM 'offset' needs to be an even address and
  * Buffer length 'len' must be an even number of bytes
  */
-void wlc_copyfrom_shm(wlc_info_t * wlc, uint offset, void *buf, int len)
+void wlc_copyfrom_shm(wlc_info_t *wlc, uint offset, void *buf, int len)
 {
 	/* offset and len need to be even */
 	ASSERT((offset & 1) == 0);
@@ -8833,71 +8833,71 @@ void wlc_copyfrom_shm(wlc_info_t * wlc,
 }
 
 /* wrapper BMAC functions to for HIGH driver access */
-void wlc_mctrl(wlc_info_t * wlc, uint32 mask, uint32 val)
+void wlc_mctrl(wlc_info_t *wlc, uint32 mask, uint32 val)
 {
 	wlc_bmac_mctrl(wlc->hw, mask, val);
 }
 
-void wlc_corereset(wlc_info_t * wlc, uint32 flags)
+void wlc_corereset(wlc_info_t *wlc, uint32 flags)
 {
 	wlc_bmac_corereset(wlc->hw, flags);
 }
 
-void wlc_mhf(wlc_info_t * wlc, uint8 idx, uint16 mask, uint16 val, int bands)
+void wlc_mhf(wlc_info_t *wlc, uint8 idx, uint16 mask, uint16 val, int bands)
 {
 	wlc_bmac_mhf(wlc->hw, idx, mask, val, bands);
 }
 
-uint16 wlc_mhf_get(wlc_info_t * wlc, uint8 idx, int bands)
+uint16 wlc_mhf_get(wlc_info_t *wlc, uint8 idx, int bands)
 {
 	return wlc_bmac_mhf_get(wlc->hw, idx, bands);
 }
 
-int wlc_xmtfifo_sz_get(wlc_info_t * wlc, uint fifo, uint * blocks)
+int wlc_xmtfifo_sz_get(wlc_info_t *wlc, uint fifo, uint *blocks)
 {
 	return wlc_bmac_xmtfifo_sz_get(wlc->hw, fifo, blocks);
 }
 
-void wlc_write_template_ram(wlc_info_t * wlc, int offset, int len, void *buf)
+void wlc_write_template_ram(wlc_info_t *wlc, int offset, int len, void *buf)
 {
 	wlc_bmac_write_template_ram(wlc->hw, offset, len, buf);
 }
 
-void wlc_write_hw_bcntemplates(wlc_info_t * wlc, void *bcn, int len, bool both)
+void wlc_write_hw_bcntemplates(wlc_info_t *wlc, void *bcn, int len, bool both)
 {
 	wlc_bmac_write_hw_bcntemplates(wlc->hw, bcn, len, both);
 }
 
 void
-wlc_set_addrmatch(wlc_info_t * wlc, int match_reg_offset,
+wlc_set_addrmatch(wlc_info_t *wlc, int match_reg_offset,
 		  const struct ether_addr *addr)
 {
 	wlc_bmac_set_addrmatch(wlc->hw, match_reg_offset, addr);
 }
 
-void wlc_set_rcmta(wlc_info_t * wlc, int idx, const struct ether_addr *addr)
+void wlc_set_rcmta(wlc_info_t *wlc, int idx, const struct ether_addr *addr)
 {
 	wlc_bmac_set_rcmta(wlc->hw, idx, addr);
 }
 
-void wlc_read_tsf(wlc_info_t * wlc, uint32 * tsf_l_ptr, uint32 * tsf_h_ptr)
+void wlc_read_tsf(wlc_info_t *wlc, uint32 *tsf_l_ptr, uint32 *tsf_h_ptr)
 {
 	wlc_bmac_read_tsf(wlc->hw, tsf_l_ptr, tsf_h_ptr);
 }
 
-void wlc_set_cwmin(wlc_info_t * wlc, uint16 newmin)
+void wlc_set_cwmin(wlc_info_t *wlc, uint16 newmin)
 {
 	wlc->band->CWmin = newmin;
 	wlc_bmac_set_cwmin(wlc->hw, newmin);
 }
 
-void wlc_set_cwmax(wlc_info_t * wlc, uint16 newmax)
+void wlc_set_cwmax(wlc_info_t *wlc, uint16 newmax)
 {
 	wlc->band->CWmax = newmax;
 	wlc_bmac_set_cwmax(wlc->hw, newmax);
 }
 
-void wlc_fifoerrors(wlc_info_t * wlc)
+void wlc_fifoerrors(wlc_info_t *wlc)
 {
 
 	wlc_bmac_fifoerrors(wlc->hw);
@@ -8905,19 +8905,19 @@ void wlc_fifoerrors(wlc_info_t * wlc)
 
 /* Search mem rw utilities */
 
-void wlc_pllreq(wlc_info_t * wlc, bool set, mbool req_bit)
+void wlc_pllreq(wlc_info_t *wlc, bool set, mbool req_bit)
 {
 	wlc_bmac_pllreq(wlc->hw, set, req_bit);
 }
 
-void wlc_reset_bmac_done(wlc_info_t * wlc)
+void wlc_reset_bmac_done(wlc_info_t *wlc)
 {
 #ifdef WLC_HIGH_ONLY
 	wlc->reset_bmac_pending = FALSE;
 #endif
 }
 
-void wlc_ht_mimops_cap_update(wlc_info_t * wlc, uint8 mimops_mode)
+void wlc_ht_mimops_cap_update(wlc_info_t *wlc, uint8 mimops_mode)
 {
 	wlc->ht_cap.cap &= ~HT_CAP_MIMO_PS_MASK;
 	wlc->ht_cap.cap |= (mimops_mode << HT_CAP_MIMO_PS_SHIFT);
@@ -8930,7 +8930,7 @@ void wlc_ht_mimops_cap_update(wlc_info_t
 
 /* check for the particular priority flow control bit being set */
 bool
-wlc_txflowcontrol_prio_isset(wlc_info_t * wlc, wlc_txq_info_t * q, int prio)
+wlc_txflowcontrol_prio_isset(wlc_info_t *wlc, wlc_txq_info_t *q, int prio)
 {
 	uint prio_mask;
 
@@ -8945,7 +8945,7 @@ wlc_txflowcontrol_prio_isset(wlc_info_t
 }
 
 /* propogate the flow control to all interfaces using the given tx queue */
-void wlc_txflowcontrol(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on, int prio)
+void wlc_txflowcontrol(wlc_info_t *wlc, wlc_txq_info_t *qi, bool on, int prio)
 {
 	uint prio_bits;
 	uint cur_bits;
@@ -8987,7 +8987,7 @@ void wlc_txflowcontrol(wlc_info_t * wlc,
 }
 
 void
-wlc_txflowcontrol_override(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on,
+wlc_txflowcontrol_override(wlc_info_t *wlc, wlc_txq_info_t *qi, bool on,
 			   uint override)
 {
 	uint prev_override;
@@ -9034,7 +9034,7 @@ wlc_txflowcontrol_override(wlc_info_t *
 	}
 }
 
-static void wlc_txflowcontrol_reset(wlc_info_t * wlc)
+static void wlc_txflowcontrol_reset(wlc_info_t *wlc)
 {
 	wlc_txq_info_t *qi;
 
@@ -9047,7 +9047,7 @@ static void wlc_txflowcontrol_reset(wlc_
 }
 
 static void
-wlc_txflowcontrol_signal(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on,
+wlc_txflowcontrol_signal(wlc_info_t *wlc, wlc_txq_info_t *qi, bool on,
 			 int prio)
 {
 	wlc_if_t *wlcif;
@@ -9058,7 +9058,7 @@ wlc_txflowcontrol_signal(wlc_info_t * wl
 	}
 }
 
-static wlc_txq_info_t *wlc_txq_alloc(wlc_info_t * wlc, osl_t * osh)
+static wlc_txq_info_t *wlc_txq_alloc(wlc_info_t *wlc, osl_t *osh)
 {
 	wlc_txq_info_t *qi, *p;
 
@@ -9088,7 +9088,7 @@ static wlc_txq_info_t *wlc_txq_alloc(wlc
 	return qi;
 }
 
-static void wlc_txq_free(wlc_info_t * wlc, osl_t * osh, wlc_txq_info_t * qi)
+static void wlc_txq_free(wlc_info_t *wlc, osl_t *osh, wlc_txq_info_t *qi)
 {
 	wlc_txq_info_t *p;
 
--- a/drivers/staging/brcm80211/sys/wlc_mac80211.h
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.h
@@ -361,7 +361,7 @@ typedef struct wlcband {
 typedef void (*cb_fn_t) (void *);
 
 /* tx completion callback takes 3 args */
-typedef void (*pkcb_fn_t) (wlc_info_t * wlc, uint txstatus, void *arg);
+typedef void (*pkcb_fn_t) (wlc_info_t *wlc, uint txstatus, void *arg);
 
 typedef struct pkt_cb {
 	pkcb_fn_t fn;		/* function to call when tx frame completes */
@@ -871,169 +871,169 @@ struct antsel_info {
 	((len1 == len2) && !bcmp(ssid1, ssid2, len1))
 
 /* API shared by both WLC_HIGH and WLC_LOW driver */
-extern void wlc_high_dpc(wlc_info_t * wlc, uint32 macintstatus);
-extern void wlc_fatal_error(wlc_info_t * wlc);
-extern void wlc_bmac_rpc_watchdog(wlc_info_t * wlc);
-extern void wlc_recv(wlc_info_t * wlc, void *p);
-extern bool wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2);
-extern void wlc_txfifo(wlc_info_t * wlc, uint fifo, void *p, bool commit,
+extern void wlc_high_dpc(wlc_info_t *wlc, uint32 macintstatus);
+extern void wlc_fatal_error(wlc_info_t *wlc);
+extern void wlc_bmac_rpc_watchdog(wlc_info_t *wlc);
+extern void wlc_recv(wlc_info_t *wlc, void *p);
+extern bool wlc_dotxstatus(wlc_info_t *wlc, tx_status_t *txs, uint32 frm_tx2);
+extern void wlc_txfifo(wlc_info_t *wlc, uint fifo, void *p, bool commit,
 		       int8 txpktpend);
-extern void wlc_txfifo_complete(wlc_info_t * wlc, uint fifo, int8 txpktpend);
-extern void wlc_info_init(wlc_info_t * wlc, int unit);
-extern void wlc_print_txstatus(tx_status_t * txs);
-extern int wlc_xmtfifo_sz_get(wlc_info_t * wlc, uint fifo, uint * blocks);
-extern void wlc_write_template_ram(wlc_info_t * wlc, int offset, int len,
+extern void wlc_txfifo_complete(wlc_info_t *wlc, uint fifo, int8 txpktpend);
+extern void wlc_info_init(wlc_info_t *wlc, int unit);
+extern void wlc_print_txstatus(tx_status_t *txs);
+extern int wlc_xmtfifo_sz_get(wlc_info_t *wlc, uint fifo, uint *blocks);
+extern void wlc_write_template_ram(wlc_info_t *wlc, int offset, int len,
 				   void *buf);
-extern void wlc_write_hw_bcntemplates(wlc_info_t * wlc, void *bcn, int len,
+extern void wlc_write_hw_bcntemplates(wlc_info_t *wlc, void *bcn, int len,
 				      bool both);
 #if defined(BCMDBG)
-extern void wlc_get_rcmta(wlc_info_t * wlc, int idx, struct ether_addr *addr);
+extern void wlc_get_rcmta(wlc_info_t *wlc, int idx, struct ether_addr *addr);
 #endif
-extern void wlc_set_rcmta(wlc_info_t * wlc, int idx,
+extern void wlc_set_rcmta(wlc_info_t *wlc, int idx,
 			  const struct ether_addr *addr);
-extern void wlc_set_addrmatch(wlc_info_t * wlc, int match_reg_offset,
+extern void wlc_set_addrmatch(wlc_info_t *wlc, int match_reg_offset,
 			      const struct ether_addr *addr);
-extern void wlc_read_tsf(wlc_info_t * wlc, uint32 * tsf_l_ptr,
-			 uint32 * tsf_h_ptr);
-extern void wlc_set_cwmin(wlc_info_t * wlc, uint16 newmin);
-extern void wlc_set_cwmax(wlc_info_t * wlc, uint16 newmax);
-extern void wlc_fifoerrors(wlc_info_t * wlc);
-extern void wlc_pllreq(wlc_info_t * wlc, bool set, mbool req_bit);
-extern void wlc_reset_bmac_done(wlc_info_t * wlc);
-extern void wlc_protection_upd(wlc_info_t * wlc, uint idx, int val);
-extern void wlc_hwtimer_gptimer_set(wlc_info_t * wlc, uint us);
-extern void wlc_hwtimer_gptimer_abort(wlc_info_t * wlc);
-extern void wlc_pktengtx(wlc_info_t * wlc, wl_pkteng_t * pkteng, uint8 rate,
+extern void wlc_read_tsf(wlc_info_t *wlc, uint32 *tsf_l_ptr,
+			 uint32 *tsf_h_ptr);
+extern void wlc_set_cwmin(wlc_info_t *wlc, uint16 newmin);
+extern void wlc_set_cwmax(wlc_info_t *wlc, uint16 newmax);
+extern void wlc_fifoerrors(wlc_info_t *wlc);
+extern void wlc_pllreq(wlc_info_t *wlc, bool set, mbool req_bit);
+extern void wlc_reset_bmac_done(wlc_info_t *wlc);
+extern void wlc_protection_upd(wlc_info_t *wlc, uint idx, int val);
+extern void wlc_hwtimer_gptimer_set(wlc_info_t *wlc, uint us);
+extern void wlc_hwtimer_gptimer_abort(wlc_info_t *wlc);
+extern void wlc_pktengtx(wlc_info_t *wlc, wl_pkteng_t *pkteng, uint8 rate,
 			 struct ether_addr *sa, uint32 wait_delay);
 
 #if defined(BCMDBG)
-extern void wlc_print_rxh(d11rxhdr_t * rxh);
-extern void wlc_print_hdrs(wlc_info_t * wlc, const char *prefix, uint8 * frame,
-			   d11txh_t * txh, d11rxhdr_t * rxh, uint len);
-extern void wlc_print_txdesc(d11txh_t * txh);
+extern void wlc_print_rxh(d11rxhdr_t *rxh);
+extern void wlc_print_hdrs(wlc_info_t *wlc, const char *prefix, uint8 *frame,
+			   d11txh_t *txh, d11rxhdr_t *rxh, uint len);
+extern void wlc_print_txdesc(d11txh_t *txh);
 #endif
 #if defined(BCMDBG)
-extern void wlc_print_dot11_mac_hdr(uint8 * buf, int len);
+extern void wlc_print_dot11_mac_hdr(uint8 *buf, int len);
 #endif
 
 #ifdef WLC_LOW
-extern void wlc_setxband(wlc_hw_info_t * wlc_hw, uint bandunit);
-extern void wlc_coredisable(wlc_hw_info_t * wlc_hw);
+extern void wlc_setxband(wlc_hw_info_t *wlc_hw, uint bandunit);
+extern void wlc_coredisable(wlc_hw_info_t *wlc_hw);
 #endif
 
-extern bool wlc_valid_rate(wlc_info_t * wlc, ratespec_t rate, int band,
+extern bool wlc_valid_rate(wlc_info_t *wlc, ratespec_t rate, int band,
 			   bool verbose);
-extern void wlc_ap_upd(wlc_info_t * wlc);
+extern void wlc_ap_upd(wlc_info_t *wlc);
 
 /* helper functions */
-extern void wlc_shm_ssid_upd(wlc_info_t * wlc, wlc_bsscfg_t * cfg);
-extern int wlc_set_gmode(wlc_info_t * wlc, uint8 gmode, bool config);
+extern void wlc_shm_ssid_upd(wlc_info_t *wlc, wlc_bsscfg_t *cfg);
+extern int wlc_set_gmode(wlc_info_t *wlc, uint8 gmode, bool config);
 
-extern void wlc_mac_bcn_promisc_change(wlc_info_t * wlc, bool promisc);
-extern void wlc_mac_bcn_promisc(wlc_info_t * wlc);
-extern void wlc_mac_promisc(wlc_info_t * wlc);
-extern void wlc_txflowcontrol(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on,
+extern void wlc_mac_bcn_promisc_change(wlc_info_t *wlc, bool promisc);
+extern void wlc_mac_bcn_promisc(wlc_info_t *wlc);
+extern void wlc_mac_promisc(wlc_info_t *wlc);
+extern void wlc_txflowcontrol(wlc_info_t *wlc, wlc_txq_info_t *qi, bool on,
 			      int prio);
-extern void wlc_txflowcontrol_override(wlc_info_t * wlc, wlc_txq_info_t * qi,
+extern void wlc_txflowcontrol_override(wlc_info_t *wlc, wlc_txq_info_t *qi,
 				       bool on, uint override);
-extern bool wlc_txflowcontrol_prio_isset(wlc_info_t * wlc, wlc_txq_info_t * qi,
+extern bool wlc_txflowcontrol_prio_isset(wlc_info_t *wlc, wlc_txq_info_t *qi,
 					 int prio);
-extern void wlc_send_q(wlc_info_t * wlc, wlc_txq_info_t * qi);
-extern int wlc_prep_pdu(wlc_info_t * wlc, void *pdu, uint * fifo);
+extern void wlc_send_q(wlc_info_t *wlc, wlc_txq_info_t *qi);
+extern int wlc_prep_pdu(wlc_info_t *wlc, void *pdu, uint *fifo);
 
-extern uint16 wlc_calc_lsig_len(wlc_info_t * wlc, ratespec_t ratespec,
+extern uint16 wlc_calc_lsig_len(wlc_info_t *wlc, ratespec_t ratespec,
 				uint mac_len);
-extern ratespec_t wlc_rspec_to_rts_rspec(wlc_info_t * wlc, ratespec_t rspec,
+extern ratespec_t wlc_rspec_to_rts_rspec(wlc_info_t *wlc, ratespec_t rspec,
 					 bool use_rspec, uint16 mimo_ctlchbw);
-extern uint16 wlc_compute_rtscts_dur(wlc_info_t * wlc, bool cts_only,
+extern uint16 wlc_compute_rtscts_dur(wlc_info_t *wlc, bool cts_only,
 				     ratespec_t rts_rate, ratespec_t frame_rate,
 				     uint8 rts_preamble_type,
 				     uint8 frame_preamble_type, uint frame_len,
 				     bool ba);
 
-extern void wlc_tbtt(wlc_info_t * wlc, d11regs_t * regs);
+extern void wlc_tbtt(wlc_info_t *wlc, d11regs_t *regs);
 
 #if defined(BCMDBG)
-extern void wlc_dump_ie(wlc_info_t * wlc, bcm_tlv_t * ie, struct bcmstrbuf *b);
+extern void wlc_dump_ie(wlc_info_t *wlc, bcm_tlv_t *ie, struct bcmstrbuf *b);
 #endif
 
-extern bool wlc_ps_check(wlc_info_t * wlc);
-extern void wlc_reprate_init(wlc_info_t * wlc);
-extern void wlc_bsscfg_reprate_init(wlc_bsscfg_t * bsscfg);
-extern void wlc_uint64_sub(uint32 * a_high, uint32 * a_low, uint32 b_high,
+extern bool wlc_ps_check(wlc_info_t *wlc);
+extern void wlc_reprate_init(wlc_info_t *wlc);
+extern void wlc_bsscfg_reprate_init(wlc_bsscfg_t *bsscfg);
+extern void wlc_uint64_sub(uint32 *a_high, uint32 *a_low, uint32 b_high,
 			   uint32 b_low);
 extern uint32 wlc_calc_tbtt_offset(uint32 bi, uint32 tsf_h, uint32 tsf_l);
 
 /* Shared memory access */
-extern void wlc_write_shm(wlc_info_t * wlc, uint offset, uint16 v);
-extern uint16 wlc_read_shm(wlc_info_t * wlc, uint offset);
-extern void wlc_set_shm(wlc_info_t * wlc, uint offset, uint16 v, int len);
-extern void wlc_copyto_shm(wlc_info_t * wlc, uint offset, const void *buf,
+extern void wlc_write_shm(wlc_info_t *wlc, uint offset, uint16 v);
+extern uint16 wlc_read_shm(wlc_info_t *wlc, uint offset);
+extern void wlc_set_shm(wlc_info_t *wlc, uint offset, uint16 v, int len);
+extern void wlc_copyto_shm(wlc_info_t *wlc, uint offset, const void *buf,
 			   int len);
-extern void wlc_copyfrom_shm(wlc_info_t * wlc, uint offset, void *buf, int len);
+extern void wlc_copyfrom_shm(wlc_info_t *wlc, uint offset, void *buf, int len);
 
-extern void wlc_update_beacon(wlc_info_t * wlc);
-extern void wlc_bss_update_beacon(wlc_info_t * wlc, struct wlc_bsscfg *bsscfg);
+extern void wlc_update_beacon(wlc_info_t *wlc);
+extern void wlc_bss_update_beacon(wlc_info_t *wlc, struct wlc_bsscfg *bsscfg);
 
-extern void wlc_update_probe_resp(wlc_info_t * wlc, bool suspend);
-extern void wlc_bss_update_probe_resp(wlc_info_t * wlc, wlc_bsscfg_t * cfg,
+extern void wlc_update_probe_resp(wlc_info_t *wlc, bool suspend);
+extern void wlc_bss_update_probe_resp(wlc_info_t *wlc, wlc_bsscfg_t *cfg,
 				      bool suspend);
 
-extern bool wlc_ismpc(wlc_info_t * wlc);
-extern bool wlc_is_non_delay_mpc(wlc_info_t * wlc);
-extern void wlc_radio_mpc_upd(wlc_info_t * wlc);
-extern bool wlc_prec_enq(wlc_info_t * wlc, struct pktq *q, void *pkt, int prec);
-extern bool wlc_prec_enq_head(wlc_info_t * wlc, struct pktq *q, void *pkt,
+extern bool wlc_ismpc(wlc_info_t *wlc);
+extern bool wlc_is_non_delay_mpc(wlc_info_t *wlc);
+extern void wlc_radio_mpc_upd(wlc_info_t *wlc);
+extern bool wlc_prec_enq(wlc_info_t *wlc, struct pktq *q, void *pkt, int prec);
+extern bool wlc_prec_enq_head(wlc_info_t *wlc, struct pktq *q, void *pkt,
 			      int prec, bool head);
-extern uint16 wlc_phytxctl1_calc(wlc_info_t * wlc, ratespec_t rspec);
-extern void wlc_compute_plcp(wlc_info_t * wlc, ratespec_t rate, uint length,
-			     uint8 * plcp);
-extern uint wlc_calc_frame_time(wlc_info_t * wlc, ratespec_t ratespec,
+extern uint16 wlc_phytxctl1_calc(wlc_info_t *wlc, ratespec_t rspec);
+extern void wlc_compute_plcp(wlc_info_t *wlc, ratespec_t rate, uint length,
+			     uint8 *plcp);
+extern uint wlc_calc_frame_time(wlc_info_t *wlc, ratespec_t ratespec,
 				uint8 preamble_type, uint mac_len);
 
-extern void wlc_set_chanspec(wlc_info_t * wlc, chanspec_t chanspec);
+extern void wlc_set_chanspec(wlc_info_t *wlc, chanspec_t chanspec);
 
-extern bool wlc_timers_init(wlc_info_t * wlc, int unit);
+extern bool wlc_timers_init(wlc_info_t *wlc, int unit);
 
 extern const bcm_iovar_t wlc_iovars[];
 
-extern int wlc_doiovar(void *hdl, const bcm_iovar_t * vi, uint32 actionid,
+extern int wlc_doiovar(void *hdl, const bcm_iovar_t *vi, uint32 actionid,
 		       const char *name, void *params, uint p_len, void *arg,
-		       int len, int val_size, wlc_if_t * wlcif);
+		       int len, int val_size, wlc_if_t *wlcif);
 
 #if defined(BCMDBG)
-extern void wlc_print_ies(wlc_info_t * wlc, uint8 * ies, uint ies_len);
+extern void wlc_print_ies(wlc_info_t *wlc, uint8 *ies, uint ies_len);
 #endif
 
-extern int wlc_set_nmode(wlc_info_t * wlc, int32 nmode);
-extern void wlc_ht_mimops_cap_update(wlc_info_t * wlc, uint8 mimops_mode);
-extern void wlc_mimops_action_ht_send(wlc_info_t * wlc, wlc_bsscfg_t * bsscfg,
+extern int wlc_set_nmode(wlc_info_t *wlc, int32 nmode);
+extern void wlc_ht_mimops_cap_update(wlc_info_t *wlc, uint8 mimops_mode);
+extern void wlc_mimops_action_ht_send(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg,
 				      uint8 mimops_mode);
 
-extern void wlc_switch_shortslot(wlc_info_t * wlc, bool shortslot);
-extern void wlc_set_bssid(wlc_bsscfg_t * cfg);
-extern void wlc_edcf_setparams(wlc_bsscfg_t * cfg, bool suspend);
-extern void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg,
+extern void wlc_switch_shortslot(wlc_info_t *wlc, bool shortslot);
+extern void wlc_set_bssid(wlc_bsscfg_t *cfg);
+extern void wlc_edcf_setparams(wlc_bsscfg_t *cfg, bool suspend);
+extern void wlc_wme_setparams(wlc_info_t *wlc, u16 aci, void *arg,
 			      bool suspend);
 
-extern void wlc_set_ratetable(wlc_info_t * wlc);
-extern int wlc_set_mac(wlc_bsscfg_t * cfg);
-extern void wlc_beacon_phytxctl_txant_upd(wlc_info_t * wlc,
+extern void wlc_set_ratetable(wlc_info_t *wlc);
+extern int wlc_set_mac(wlc_bsscfg_t *cfg);
+extern void wlc_beacon_phytxctl_txant_upd(wlc_info_t *wlc,
 					  ratespec_t bcn_rate);
-extern void wlc_mod_prb_rsp_rate_table(wlc_info_t * wlc, uint frame_len);
-extern ratespec_t wlc_lowest_basic_rspec(wlc_info_t * wlc, wlc_rateset_t * rs);
-extern uint16 wlc_compute_bcntsfoff(wlc_info_t * wlc, ratespec_t rspec,
+extern void wlc_mod_prb_rsp_rate_table(wlc_info_t *wlc, uint frame_len);
+extern ratespec_t wlc_lowest_basic_rspec(wlc_info_t *wlc, wlc_rateset_t *rs);
+extern uint16 wlc_compute_bcntsfoff(wlc_info_t *wlc, ratespec_t rspec,
 				    bool short_preamble, bool phydelay);
-extern void wlc_radio_disable(wlc_info_t * wlc);
-extern void wlc_bcn_li_upd(wlc_info_t * wlc);
+extern void wlc_radio_disable(wlc_info_t *wlc);
+extern void wlc_bcn_li_upd(wlc_info_t *wlc);
 
-extern int wlc_get_revision_info(wlc_info_t * wlc, void *buf, uint len);
-extern void wlc_out(wlc_info_t * wlc);
-extern void wlc_set_home_chanspec(wlc_info_t * wlc, chanspec_t chanspec);
-extern void wlc_watchdog_upd(wlc_info_t * wlc, bool tbtt);
-extern bool wlc_ps_allowed(wlc_info_t * wlc);
-extern bool wlc_stay_awake(wlc_info_t * wlc);
-extern void wlc_wme_initparams_sta(wlc_info_t * wlc, wme_param_ie_t * pe);
+extern int wlc_get_revision_info(wlc_info_t *wlc, void *buf, uint len);
+extern void wlc_out(wlc_info_t *wlc);
+extern void wlc_set_home_chanspec(wlc_info_t *wlc, chanspec_t chanspec);
+extern void wlc_watchdog_upd(wlc_info_t *wlc, bool tbtt);
+extern bool wlc_ps_allowed(wlc_info_t *wlc);
+extern bool wlc_stay_awake(wlc_info_t *wlc);
+extern void wlc_wme_initparams_sta(wlc_info_t *wlc, wme_param_ie_t *pe);
 
-extern void wlc_bss_list_free(wlc_info_t * wlc, wlc_bss_list_t * bss_list);
+extern void wlc_bss_list_free(wlc_info_t *wlc, wlc_bss_list_t *bss_list);
 #endif				/* _wlc_h_ */
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.c
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.c
@@ -60,7 +60,7 @@ struct wlc_phy_shim_info {
 	void *wl;		/* pointer to os-specific private state */
 };
 
-wlc_phy_shim_info_t *BCMATTACHFN(wlc_phy_shim_attach) (wlc_hw_info_t * wlc_hw,
+wlc_phy_shim_info_t *BCMATTACHFN(wlc_phy_shim_attach) (wlc_hw_info_t *wlc_hw,
 						       void *wl, void *wlc) {
 	wlc_phy_shim_info_t *physhim = NULL;
 
@@ -79,172 +79,172 @@ wlc_phy_shim_info_t *BCMATTACHFN(wlc_phy
 	return physhim;
 }
 
-void BCMATTACHFN(wlc_phy_shim_detach) (wlc_phy_shim_info_t * physhim) {
+void BCMATTACHFN(wlc_phy_shim_detach) (wlc_phy_shim_info_t *physhim) {
 	if (!physhim)
 		return;
 
 	MFREE(physhim->wlc_hw->osh, physhim, sizeof(wlc_phy_shim_info_t));
 }
 
-struct wlapi_timer *wlapi_init_timer(wlc_phy_shim_info_t * physhim,
+struct wlapi_timer *wlapi_init_timer(wlc_phy_shim_info_t *physhim,
 				     void (*fn) (void *arg), void *arg,
 				     const char *name)
 {
 	return (struct wlapi_timer *)wl_init_timer(physhim->wl, fn, arg, name);
 }
 
-void wlapi_free_timer(wlc_phy_shim_info_t * physhim, struct wlapi_timer *t)
+void wlapi_free_timer(wlc_phy_shim_info_t *physhim, struct wlapi_timer *t)
 {
 	wl_free_timer(physhim->wl, (struct wl_timer *)t);
 }
 
 void
-wlapi_add_timer(wlc_phy_shim_info_t * physhim, struct wlapi_timer *t, uint ms,
+wlapi_add_timer(wlc_phy_shim_info_t *physhim, struct wlapi_timer *t, uint ms,
 		int periodic)
 {
 	wl_add_timer(physhim->wl, (struct wl_timer *)t, ms, periodic);
 }
 
-bool wlapi_del_timer(wlc_phy_shim_info_t * physhim, struct wlapi_timer *t)
+bool wlapi_del_timer(wlc_phy_shim_info_t *physhim, struct wlapi_timer *t)
 {
 	return wl_del_timer(physhim->wl, (struct wl_timer *)t);
 }
 
-void wlapi_intrson(wlc_phy_shim_info_t * physhim)
+void wlapi_intrson(wlc_phy_shim_info_t *physhim)
 {
 	wl_intrson(physhim->wl);
 }
 
-uint32 wlapi_intrsoff(wlc_phy_shim_info_t * physhim)
+uint32 wlapi_intrsoff(wlc_phy_shim_info_t *physhim)
 {
 	return wl_intrsoff(physhim->wl);
 }
 
-void wlapi_intrsrestore(wlc_phy_shim_info_t * physhim, uint32 macintmask)
+void wlapi_intrsrestore(wlc_phy_shim_info_t *physhim, uint32 macintmask)
 {
 	wl_intrsrestore(physhim->wl, macintmask);
 }
 
-void wlapi_bmac_write_shm(wlc_phy_shim_info_t * physhim, uint offset, uint16 v)
+void wlapi_bmac_write_shm(wlc_phy_shim_info_t *physhim, uint offset, uint16 v)
 {
 	wlc_bmac_write_shm(physhim->wlc_hw, offset, v);
 }
 
-uint16 wlapi_bmac_read_shm(wlc_phy_shim_info_t * physhim, uint offset)
+uint16 wlapi_bmac_read_shm(wlc_phy_shim_info_t *physhim, uint offset)
 {
 	return wlc_bmac_read_shm(physhim->wlc_hw, offset);
 }
 
 void
-wlapi_bmac_mhf(wlc_phy_shim_info_t * physhim, uint8 idx, uint16 mask,
+wlapi_bmac_mhf(wlc_phy_shim_info_t *physhim, uint8 idx, uint16 mask,
 	       uint16 val, int bands)
 {
 	wlc_bmac_mhf(physhim->wlc_hw, idx, mask, val, bands);
 }
 
-void wlapi_bmac_corereset(wlc_phy_shim_info_t * physhim, uint32 flags)
+void wlapi_bmac_corereset(wlc_phy_shim_info_t *physhim, uint32 flags)
 {
 	wlc_bmac_corereset(physhim->wlc_hw, flags);
 }
 
-void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t * physhim)
+void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t *physhim)
 {
 	wlc_suspend_mac_and_wait(physhim->wlc);
 }
 
-void wlapi_switch_macfreq(wlc_phy_shim_info_t * physhim, uint8 spurmode)
+void wlapi_switch_macfreq(wlc_phy_shim_info_t *physhim, uint8 spurmode)
 {
 	wlc_bmac_switch_macfreq(physhim->wlc_hw, spurmode);
 }
 
-void wlapi_enable_mac(wlc_phy_shim_info_t * physhim)
+void wlapi_enable_mac(wlc_phy_shim_info_t *physhim)
 {
 	wlc_enable_mac(physhim->wlc);
 }
 
-void wlapi_bmac_mctrl(wlc_phy_shim_info_t * physhim, uint32 mask, uint32 val)
+void wlapi_bmac_mctrl(wlc_phy_shim_info_t *physhim, uint32 mask, uint32 val)
 {
 	wlc_bmac_mctrl(physhim->wlc_hw, mask, val);
 }
 
-void wlapi_bmac_phy_reset(wlc_phy_shim_info_t * physhim)
+void wlapi_bmac_phy_reset(wlc_phy_shim_info_t *physhim)
 {
 	wlc_bmac_phy_reset(physhim->wlc_hw);
 }
 
-void wlapi_bmac_bw_set(wlc_phy_shim_info_t * physhim, uint16 bw)
+void wlapi_bmac_bw_set(wlc_phy_shim_info_t *physhim, uint16 bw)
 {
 	wlc_bmac_bw_set(physhim->wlc_hw, bw);
 }
 
-uint16 wlapi_bmac_get_txant(wlc_phy_shim_info_t * physhim)
+uint16 wlapi_bmac_get_txant(wlc_phy_shim_info_t *physhim)
 {
 	return wlc_bmac_get_txant(physhim->wlc_hw);
 }
 
-void wlapi_bmac_phyclk_fgc(wlc_phy_shim_info_t * physhim, bool clk)
+void wlapi_bmac_phyclk_fgc(wlc_phy_shim_info_t *physhim, bool clk)
 {
 	wlc_bmac_phyclk_fgc(physhim->wlc_hw, clk);
 }
 
-void wlapi_bmac_macphyclk_set(wlc_phy_shim_info_t * physhim, bool clk)
+void wlapi_bmac_macphyclk_set(wlc_phy_shim_info_t *physhim, bool clk)
 {
 	wlc_bmac_macphyclk_set(physhim->wlc_hw, clk);
 }
 
-void wlapi_bmac_core_phypll_ctl(wlc_phy_shim_info_t * physhim, bool on)
+void wlapi_bmac_core_phypll_ctl(wlc_phy_shim_info_t *physhim, bool on)
 {
 	wlc_bmac_core_phypll_ctl(physhim->wlc_hw, on);
 }
 
-void wlapi_bmac_core_phypll_reset(wlc_phy_shim_info_t * physhim)
+void wlapi_bmac_core_phypll_reset(wlc_phy_shim_info_t *physhim)
 {
 	wlc_bmac_core_phypll_reset(physhim->wlc_hw);
 }
 
-void wlapi_bmac_ucode_wake_override_phyreg_set(wlc_phy_shim_info_t * physhim)
+void wlapi_bmac_ucode_wake_override_phyreg_set(wlc_phy_shim_info_t *physhim)
 {
 	wlc_ucode_wake_override_set(physhim->wlc_hw, WLC_WAKE_OVERRIDE_PHYREG);
 }
 
-void wlapi_bmac_ucode_wake_override_phyreg_clear(wlc_phy_shim_info_t * physhim)
+void wlapi_bmac_ucode_wake_override_phyreg_clear(wlc_phy_shim_info_t *physhim)
 {
 	wlc_ucode_wake_override_clear(physhim->wlc_hw,
 				      WLC_WAKE_OVERRIDE_PHYREG);
 }
 
 void
-wlapi_bmac_write_template_ram(wlc_phy_shim_info_t * physhim, int offset,
+wlapi_bmac_write_template_ram(wlc_phy_shim_info_t *physhim, int offset,
 			      int len, void *buf)
 {
 	wlc_bmac_write_template_ram(physhim->wlc_hw, offset, len, buf);
 }
 
-uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t * physhim, uint8 rate)
+uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t *physhim, uint8 rate)
 {
 	return wlc_bmac_rate_shm_offset(physhim->wlc_hw, rate);
 }
 
-void wlapi_ucode_sample_init(wlc_phy_shim_info_t * physhim)
+void wlapi_ucode_sample_init(wlc_phy_shim_info_t *physhim)
 {
 }
 
 void
-wlapi_copyfrom_objmem(wlc_phy_shim_info_t * physhim, uint offset, void *buf,
+wlapi_copyfrom_objmem(wlc_phy_shim_info_t *physhim, uint offset, void *buf,
 		      int len, uint32 sel)
 {
 	wlc_bmac_copyfrom_objmem(physhim->wlc_hw, offset, buf, len, sel);
 }
 
 void
-wlapi_copyto_objmem(wlc_phy_shim_info_t * physhim, uint offset, const void *buf,
+wlapi_copyto_objmem(wlc_phy_shim_info_t *physhim, uint offset, const void *buf,
 		    int l, uint32 sel)
 {
 	wlc_bmac_copyto_objmem(physhim->wlc_hw, offset, buf, l, sel);
 }
 
 void
-wlapi_bmac_pktengtx(wlc_phy_shim_info_t * physhim, wl_pkteng_t * pkteng,
+wlapi_bmac_pktengtx(wlc_phy_shim_info_t *physhim, wl_pkteng_t *pkteng,
 		    uint8 rate, struct ether_addr *sa, uint32 wait_delay)
 {
 	wlc_pktengtx(physhim->wlc, pkteng, rate, sa, wait_delay);
--- a/drivers/staging/brcm80211/sys/wlc_phy_shim.h
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.h
@@ -57,59 +57,59 @@ typedef struct wlc_phy_shim_info wlc_phy
 
 extern wlc_phy_shim_info_t *wlc_phy_shim_attach(struct wlc_hw_info *wlc_hw,
 						void *wl, void *wlc);
-extern void wlc_phy_shim_detach(wlc_phy_shim_info_t * physhim);
+extern void wlc_phy_shim_detach(wlc_phy_shim_info_t *physhim);
 
 /* PHY to WL utility functions */
 struct wlapi_timer;
-extern struct wlapi_timer *wlapi_init_timer(wlc_phy_shim_info_t * physhim,
+extern struct wlapi_timer *wlapi_init_timer(wlc_phy_shim_info_t *physhim,
 					    void (*fn) (void *arg), void *arg,
 					    const char *name);
-extern void wlapi_free_timer(wlc_phy_shim_info_t * physhim,
+extern void wlapi_free_timer(wlc_phy_shim_info_t *physhim,
 			     struct wlapi_timer *t);
-extern void wlapi_add_timer(wlc_phy_shim_info_t * physhim,
+extern void wlapi_add_timer(wlc_phy_shim_info_t *physhim,
 			    struct wlapi_timer *t, uint ms, int periodic);
-extern bool wlapi_del_timer(wlc_phy_shim_info_t * physhim,
+extern bool wlapi_del_timer(wlc_phy_shim_info_t *physhim,
 			    struct wlapi_timer *t);
-extern void wlapi_intrson(wlc_phy_shim_info_t * physhim);
-extern uint32 wlapi_intrsoff(wlc_phy_shim_info_t * physhim);
-extern void wlapi_intrsrestore(wlc_phy_shim_info_t * physhim,
+extern void wlapi_intrson(wlc_phy_shim_info_t *physhim);
+extern uint32 wlapi_intrsoff(wlc_phy_shim_info_t *physhim);
+extern void wlapi_intrsrestore(wlc_phy_shim_info_t *physhim,
 			       uint32 macintmask);
 
-extern void wlapi_bmac_write_shm(wlc_phy_shim_info_t * physhim, uint offset,
+extern void wlapi_bmac_write_shm(wlc_phy_shim_info_t *physhim, uint offset,
 				 uint16 v);
-extern uint16 wlapi_bmac_read_shm(wlc_phy_shim_info_t * physhim, uint offset);
-extern void wlapi_bmac_mhf(wlc_phy_shim_info_t * physhim, uint8 idx,
+extern uint16 wlapi_bmac_read_shm(wlc_phy_shim_info_t *physhim, uint offset);
+extern void wlapi_bmac_mhf(wlc_phy_shim_info_t *physhim, uint8 idx,
 			   uint16 mask, uint16 val, int bands);
-extern void wlapi_bmac_corereset(wlc_phy_shim_info_t * physhim, uint32 flags);
-extern void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t * physhim);
-extern void wlapi_switch_macfreq(wlc_phy_shim_info_t * physhim, uint8 spurmode);
-extern void wlapi_enable_mac(wlc_phy_shim_info_t * physhim);
-extern void wlapi_bmac_mctrl(wlc_phy_shim_info_t * physhim, uint32 mask,
+extern void wlapi_bmac_corereset(wlc_phy_shim_info_t *physhim, uint32 flags);
+extern void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t *physhim);
+extern void wlapi_switch_macfreq(wlc_phy_shim_info_t *physhim, uint8 spurmode);
+extern void wlapi_enable_mac(wlc_phy_shim_info_t *physhim);
+extern void wlapi_bmac_mctrl(wlc_phy_shim_info_t *physhim, uint32 mask,
 			     uint32 val);
-extern void wlapi_bmac_phy_reset(wlc_phy_shim_info_t * physhim);
-extern void wlapi_bmac_bw_set(wlc_phy_shim_info_t * physhim, uint16 bw);
-extern void wlapi_bmac_phyclk_fgc(wlc_phy_shim_info_t * physhim, bool clk);
-extern void wlapi_bmac_macphyclk_set(wlc_phy_shim_info_t * physhim, bool clk);
-extern void wlapi_bmac_core_phypll_ctl(wlc_phy_shim_info_t * physhim, bool on);
-extern void wlapi_bmac_core_phypll_reset(wlc_phy_shim_info_t * physhim);
+extern void wlapi_bmac_phy_reset(wlc_phy_shim_info_t *physhim);
+extern void wlapi_bmac_bw_set(wlc_phy_shim_info_t *physhim, uint16 bw);
+extern void wlapi_bmac_phyclk_fgc(wlc_phy_shim_info_t *physhim, bool clk);
+extern void wlapi_bmac_macphyclk_set(wlc_phy_shim_info_t *physhim, bool clk);
+extern void wlapi_bmac_core_phypll_ctl(wlc_phy_shim_info_t *physhim, bool on);
+extern void wlapi_bmac_core_phypll_reset(wlc_phy_shim_info_t *physhim);
 extern void wlapi_bmac_ucode_wake_override_phyreg_set(wlc_phy_shim_info_t *
 						      physhim);
 extern void wlapi_bmac_ucode_wake_override_phyreg_clear(wlc_phy_shim_info_t *
 							physhim);
-extern void wlapi_bmac_write_template_ram(wlc_phy_shim_info_t * physhim, int o,
+extern void wlapi_bmac_write_template_ram(wlc_phy_shim_info_t *physhim, int o,
 					  int len, void *buf);
-extern uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t * physhim,
+extern uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t *physhim,
 					 uint8 rate);
-extern void wlapi_ucode_sample_init(wlc_phy_shim_info_t * physhim);
-extern void wlapi_copyfrom_objmem(wlc_phy_shim_info_t * physhim, uint,
+extern void wlapi_ucode_sample_init(wlc_phy_shim_info_t *physhim);
+extern void wlapi_copyfrom_objmem(wlc_phy_shim_info_t *physhim, uint,
 				  void *buf, int, uint32 sel);
-extern void wlapi_copyto_objmem(wlc_phy_shim_info_t * physhim, uint,
+extern void wlapi_copyto_objmem(wlc_phy_shim_info_t *physhim, uint,
 				const void *buf, int, uint32);
 
-extern void wlapi_high_update_phy_mode(wlc_phy_shim_info_t * physhim,
+extern void wlapi_high_update_phy_mode(wlc_phy_shim_info_t *physhim,
 				       uint32 phy_mode);
-extern void wlapi_bmac_pktengtx(wlc_phy_shim_info_t * physhim,
-				wl_pkteng_t * pkteng, uint8 rate,
+extern void wlapi_bmac_pktengtx(wlc_phy_shim_info_t *physhim,
+				wl_pkteng_t *pkteng, uint8 rate,
 				struct ether_addr *sa, uint32 wait_delay);
-extern uint16 wlapi_bmac_get_txant(wlc_phy_shim_info_t * physhim);
+extern uint16 wlapi_bmac_get_txant(wlc_phy_shim_info_t *physhim);
 #endif				/* _wlc_phy_shim_h_ */
--- a/drivers/staging/brcm80211/sys/wlc_pub.h
+++ b/drivers/staging/brcm80211/sys/wlc_pub.h
@@ -224,7 +224,7 @@ struct wlc_if;
 /* watchdog down and dump callback function proto's */
 typedef int (*watchdog_fn_t) (void *handle);
 typedef int (*down_fn_t) (void *handle);
-typedef int (*dump_fn_t) (void *handle, struct bcmstrbuf * b);
+typedef int (*dump_fn_t) (void *handle, struct bcmstrbuf *b);
 
 /* IOVar handler
  *
@@ -239,10 +239,10 @@ typedef int (*dump_fn_t) (void *handle,
  *
  * All pointers may point into the same buffer.
  */
-typedef int (*iovar_fn_t) (void *handle, const bcm_iovar_t * vi,
+typedef int (*iovar_fn_t) (void *handle, const bcm_iovar_t *vi,
 			   uint32 actionid, const char *name, void *params,
 			   uint plen, void *arg, int alen, int vsize,
-			   struct wlc_if * wlcif);
+			   struct wlc_if *wlcif);
 
 #define MAC80211_PROMISC_BCNS	(1 << 0)
 #define MAC80211_SCAN		(1 << 1)
@@ -516,7 +516,7 @@ static INLINE int8 wlc_pkttag_bsscfg_get
 
 #define PROMISC_ENAB(wlc)	(bcmspace && (wlc)->promisc)
 
-extern void wlc_pkttag_info_move(wlc_pub_t * pub, void *pkt_from, void *pkt_to);
+extern void wlc_pkttag_info_move(wlc_pub_t *pub, void *pkt_from, void *pkt_to);
 
 #define WLPKTTAGSCB(p) (WLPKTTAG(p)->_scb)
 
@@ -572,8 +572,8 @@ extern const uint8 wme_fifo2ac[];
 
 /* common functions for every port */
 extern void *wlc_attach(void *wl, uint16 vendor, uint16 device, uint unit,
-			bool piomode, osl_t * osh, void *regsva, uint bustype,
-			void *btparam, uint * perr);
+			bool piomode, osl_t *osh, void *regsva, uint bustype,
+			void *btparam, uint *perr);
 extern uint wlc_detach(struct wlc_info *wlc);
 extern int wlc_up(struct wlc_info *wlc);
 extern uint wlc_down(struct wlc_info *wlc);
@@ -590,9 +590,9 @@ extern void wlc_intrson(struct wlc_info
 extern uint32 wlc_intrsoff(struct wlc_info *wlc);
 extern void wlc_intrsrestore(struct wlc_info *wlc, uint32 macintmask);
 extern bool wlc_intrsupd(struct wlc_info *wlc);
-extern bool wlc_isr(struct wlc_info *wlc, bool * wantdpc);
+extern bool wlc_isr(struct wlc_info *wlc, bool *wantdpc);
 extern bool wlc_dpc(struct wlc_info *wlc, bool bounded);
-extern bool wlc_send80211_raw(struct wlc_info *wlc, wlc_if_t * wlcif, void *p,
+extern bool wlc_send80211_raw(struct wlc_info *wlc, wlc_if_t *wlcif, void *p,
 			      uint ac);
 extern int wlc_iovar_op(struct wlc_info *wlc, const char *name, void *params,
 			int p_len, void *arg, int len, bool set,
@@ -623,11 +623,11 @@ extern void wlc_mhf(struct wlc_info *wlc
 		    int bands);
 extern uint16 wlc_mhf_get(struct wlc_info *wlc, uint8 idx, int bands);
 extern uint32 wlc_delta_txfunfl(struct wlc_info *wlc, int fifo);
-extern void wlc_rate_lookup_init(struct wlc_info *wlc, wlc_rateset_t * rateset);
-extern void wlc_default_rateset(struct wlc_info *wlc, wlc_rateset_t * rs);
+extern void wlc_rate_lookup_init(struct wlc_info *wlc, wlc_rateset_t *rateset);
+extern void wlc_default_rateset(struct wlc_info *wlc, wlc_rateset_t *rs);
 extern void wlc_join_attempt(struct wlc_bsscfg *cfg);
 extern void wlc_join_bss_start(struct wlc_bsscfg *cfg);
-extern void wlc_join_BSS(struct wlc_bsscfg *cfg, wlc_bss_info_t * bi);
+extern void wlc_join_BSS(struct wlc_bsscfg *cfg, wlc_bss_info_t *bi);
 
 /* wlc_phy.c helper functions */
 extern bool wlc_scan_inprog(struct wlc_info *wlc);
@@ -640,16 +640,16 @@ extern void wlc_scb_ratesel_init_all(str
 
 /* ioctl */
 extern int wlc_iovar_getint8(struct wlc_info *wlc, const char *name,
-			     int8 * arg);
-extern int wlc_iovar_check(wlc_pub_t * pub, const bcm_iovar_t * vi, void *arg,
+			     int8 *arg);
+extern int wlc_iovar_check(wlc_pub_t *pub, const bcm_iovar_t *vi, void *arg,
 			   int len, bool set);
 
-extern int wlc_module_register(wlc_pub_t * pub, const bcm_iovar_t * iovars,
+extern int wlc_module_register(wlc_pub_t *pub, const bcm_iovar_t *iovars,
 			       const char *name, void *hdl, iovar_fn_t iovar_fn,
 			       watchdog_fn_t watchdog_fn, down_fn_t down_fn);
-extern int wlc_module_unregister(wlc_pub_t * pub, const char *name, void *hdl);
+extern int wlc_module_unregister(wlc_pub_t *pub, const char *name, void *hdl);
 extern void wlc_event_if(struct wlc_info *wlc, struct wlc_bsscfg *cfg,
-			 wlc_event_t * e, const struct ether_addr *addr);
+			 wlc_event_t *e, const struct ether_addr *addr);
 extern void wlc_suspend_mac_and_wait(struct wlc_info *wlc);
 extern void wlc_enable_mac(struct wlc_info *wlc);
 extern uint16 wlc_rate_shm_offset(struct wlc_info *wlc, uint8 rate);
@@ -657,13 +657,13 @@ extern uint32 wlc_get_rspec_history(stru
 extern uint32 wlc_get_current_highest_rate(struct wlc_bsscfg *cfg);
 
 static INLINE int wlc_iovar_getuint(struct wlc_info *wlc, const char *name,
-				    uint * arg)
+				    uint *arg)
 {
 	return wlc_iovar_getint(wlc, name, (int *)arg);
 }
 
 static INLINE int wlc_iovar_getuint8(struct wlc_info *wlc, const char *name,
-				     uint8 * arg)
+				     uint8 *arg)
 {
 	return wlc_iovar_getint8(wlc, name, (int8 *) arg);
 }
@@ -682,7 +682,7 @@ extern int wlc_iocpichk(struct wlc_info
 #endif
 
 /* helper functions */
-extern void wlc_getrand(struct wlc_info *wlc, uint8 * buf, int len);
+extern void wlc_getrand(struct wlc_info *wlc, uint8 *buf, int len);
 
 struct scb;
 extern void wlc_ps_on(struct wlc_info *wlc, struct scb *scb);
--- a/drivers/staging/brcm80211/sys/wlc_rate.c
+++ b/drivers/staging/brcm80211/sys/wlc_rate.c
@@ -253,12 +253,12 @@ const wlc_rateset_t cck_rates = {
 	 0x00, 0x00, 0x00, 0x00}
 };
 
-static bool wlc_rateset_valid(wlc_rateset_t * rs, bool check_brate);
+static bool wlc_rateset_valid(wlc_rateset_t *rs, bool check_brate);
 
 /* check if rateset is valid.
  * if check_brate is true, rateset without a basic rate is considered NOT valid.
  */
-static bool wlc_rateset_valid(wlc_rateset_t * rs, bool check_brate)
+static bool wlc_rateset_valid(wlc_rateset_t *rs, bool check_brate)
 {
 	uint idx;
 
@@ -276,7 +276,7 @@ static bool wlc_rateset_valid(wlc_ratese
 	return FALSE;
 }
 
-void wlc_rateset_mcs_upd(wlc_rateset_t * rs, uint8 txstreams)
+void wlc_rateset_mcs_upd(wlc_rateset_t *rs, uint8 txstreams)
 {
 	int i;
 	for (i = txstreams; i < MAX_STREAMS_SUPPORTED; i++)
@@ -287,8 +287,8 @@ void wlc_rateset_mcs_upd(wlc_rateset_t *
  * and check if resulting rateset is valid.
 */
 bool
-wlc_rate_hwrs_filter_sort_validate(wlc_rateset_t * rs,
-				   const wlc_rateset_t * hw_rs,
+wlc_rate_hwrs_filter_sort_validate(wlc_rateset_t *rs,
+				   const wlc_rateset_t *hw_rs,
 				   bool check_brate, uint8 txstreams)
 {
 	uint8 rateset[WLC_MAXRATE + 1];
@@ -330,7 +330,7 @@ wlc_rate_hwrs_filter_sort_validate(wlc_r
 }
 
 /* caluclate the rate of a rx'd frame and return it as a ratespec */
-ratespec_t BCMFASTPATH wlc_compute_rspec(d11rxhdr_t * rxh, uint8 * plcp)
+ratespec_t BCMFASTPATH wlc_compute_rspec(d11rxhdr_t *rxh, uint8 *plcp)
 {
 	int phy_type;
 	ratespec_t rspec = PHY_TXC1_BW_20MHZ << RSPEC_BW_SHIFT;
@@ -377,7 +377,7 @@ ratespec_t BCMFASTPATH wlc_compute_rspec
 }
 
 /* copy rateset src to dst as-is (no masking or sorting) */
-void wlc_rateset_copy(const wlc_rateset_t * src, wlc_rateset_t * dst)
+void wlc_rateset_copy(const wlc_rateset_t *src, wlc_rateset_t *dst)
 {
 	bcopy(src, dst, sizeof(wlc_rateset_t));
 }
@@ -392,7 +392,7 @@ void wlc_rateset_copy(const wlc_rateset_
  * 'xmask' is the copy mask (typically 0x7f or 0xff).
  */
 void
-wlc_rateset_filter(wlc_rateset_t * src, wlc_rateset_t * dst, bool basic_only,
+wlc_rateset_filter(wlc_rateset_t *src, wlc_rateset_t *dst, bool basic_only,
 		   uint8 rates, uint xmask, bool mcsallow)
 {
 	uint i;
@@ -423,7 +423,7 @@ wlc_rateset_filter(wlc_rateset_t * src,
  * and fill rs_tgt with result
  */
 void
-wlc_rateset_default(wlc_rateset_t * rs_tgt, const wlc_rateset_t * rs_hw,
+wlc_rateset_default(wlc_rateset_t *rs_tgt, const wlc_rateset_t *rs_hw,
 		    uint phy_type, int bandtype, bool cck_only, uint rate_mask,
 		    bool mcsallow, uint8 bw, uint8 txstreams)
 {
@@ -475,21 +475,21 @@ int16 BCMFASTPATH wlc_rate_legacy_phyctl
 	return -1;
 }
 
-void wlc_rateset_mcs_clear(wlc_rateset_t * rateset)
+void wlc_rateset_mcs_clear(wlc_rateset_t *rateset)
 {
 	uint i;
 	for (i = 0; i < MCSSET_LEN; i++)
 		rateset->mcs[i] = 0;
 }
 
-void wlc_rateset_mcs_build(wlc_rateset_t * rateset, uint8 txstreams)
+void wlc_rateset_mcs_build(wlc_rateset_t *rateset, uint8 txstreams)
 {
 	bcopy(&cck_ofdm_mimo_rates.mcs[0], &rateset->mcs[0], MCSSET_LEN);
 	wlc_rateset_mcs_upd(rateset, txstreams);
 }
 
 /* Based on bandwidth passed, allow/disallow MCS 32 in the rateset */
-void wlc_rateset_bw_mcs_filter(wlc_rateset_t * rateset, uint8 bw)
+void wlc_rateset_bw_mcs_filter(wlc_rateset_t *rateset, uint8 bw)
 {
 	if (bw == WLC_40_MHZ)
 		setbit(rateset->mcs, 32);
--- a/drivers/staging/brcm80211/sys/wlc_rate.h
+++ b/drivers/staging/brcm80211/sys/wlc_rate.h
@@ -151,7 +151,7 @@ extern void wlc_rateset_copy(const struc
 			     struct wlc_rateset *dst);
 
 /* would be nice to have these documented ... */
-extern ratespec_t wlc_compute_rspec(d11rxhdr_t * rxh, uint8 * plcp);
+extern ratespec_t wlc_compute_rspec(d11rxhdr_t *rxh, uint8 *plcp);
 
 extern void wlc_rateset_filter(struct wlc_rateset *src, struct wlc_rateset *dst,
 			       bool basic_only, uint8 rates, uint xmask,
--- a/drivers/staging/brcm80211/sys/wlc_rpc.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpc.h
@@ -420,7 +420,7 @@ typedef struct wlc_rpc_ctx {
 	wlc_hw_info_t *wlc_hw;
 } wlc_rpc_ctx_t;
 
-static INLINE rpc_buf_t *wlc_rpc_buf_alloc(rpc_info_t * rpc, bcm_xdr_buf_t * b,
+static INLINE rpc_buf_t *wlc_rpc_buf_alloc(rpc_info_t *rpc, bcm_xdr_buf_t *b,
 					   uint len, wlc_rpc_id_t rpc_id)
 {
 	rpc_buf_t *rpc_buf;
@@ -440,7 +440,7 @@ static INLINE rpc_buf_t *wlc_rpc_buf_all
 
 #if defined(BCMDBG)
 static __inline wlc_rpc_id_t
-wlc_rpc_id_get(struct rpc_info *rpc, rpc_buf_t * buf)
+wlc_rpc_id_get(struct rpc_info *rpc, rpc_buf_t *buf)
 {
 	wlc_rpc_id_t rpc_id;
 	bcm_xdr_buf_t b;
@@ -453,7 +453,7 @@ wlc_rpc_id_get(struct rpc_info *rpc, rpc
 }
 #endif
 
-static __inline int _wlc_rpc_call(struct rpc_info *rpc, rpc_buf_t * send)
+static __inline int _wlc_rpc_call(struct rpc_info *rpc, rpc_buf_t *send)
 {
 	int _err = 0;
 #if defined(BCMDBG)
@@ -481,11 +481,11 @@ static __inline int _wlc_rpc_call(struct
 #include <d11.h>
 
 #ifdef WLC_LOW
-extern void wlc_rpc_bmac_dispatch(wlc_rpc_ctx_t * rpc_ctx, struct rpc_buf *buf);
-extern void wlc_rpc_bmac_dump_txfifohist(wlc_hw_info_t * wlc_hw,
+extern void wlc_rpc_bmac_dispatch(wlc_rpc_ctx_t *rpc_ctx, struct rpc_buf *buf);
+extern void wlc_rpc_bmac_dump_txfifohist(wlc_hw_info_t *wlc_hw,
 					 bool dump_clear);
 #else
-extern void wlc_rpc_high_dispatch(wlc_rpc_ctx_t * ctx, struct rpc_buf *buf);
+extern void wlc_rpc_high_dispatch(wlc_rpc_ctx_t *ctx, struct rpc_buf *buf);
 #endif
 
 /* Packed structure for ease of transport across RPC bus along uint32 boundary */
@@ -497,8 +497,8 @@ typedef struct wlc_rpc_txstatus {
 } wlc_rpc_txstatus_t;
 
 static INLINE
-    void txstatus2rpc_txstatus(tx_status_t * txstatus,
-			       wlc_rpc_txstatus_t * rpc_txstatus)
+    void txstatus2rpc_txstatus(tx_status_t *txstatus,
+			       wlc_rpc_txstatus_t *rpc_txstatus)
 {
 	rpc_txstatus->PAD_framelen = txstatus->framelen;
 	rpc_txstatus->status_frameid =
@@ -510,8 +510,8 @@ static INLINE
 }
 
 static INLINE
-    void rpc_txstatus2txstatus(wlc_rpc_txstatus_t * rpc_txstatus,
-			       tx_status_t * txstatus)
+    void rpc_txstatus2txstatus(wlc_rpc_txstatus_t *rpc_txstatus,
+			       tx_status_t *txstatus)
 {
 	txstatus->framelen = rpc_txstatus->PAD_framelen & 0xffff;
 	txstatus->status = (rpc_txstatus->status_frameid >> 16) & 0xffff;
@@ -522,6 +522,6 @@ static INLINE
 	txstatus->phyerr = rpc_txstatus->ackphyrxsh_phyerr & 0xffff;
 }
 
-extern void wlc_bmac_dngl_reboot(rpc_info_t * rpc);
+extern void wlc_bmac_dngl_reboot(rpc_info_t *rpc);
 
 #endif				/* WLC_RPC_H */
--- a/drivers/staging/brcm80211/sys/wlc_rpctx.h
+++ b/drivers/staging/brcm80211/sys/wlc_rpctx.h
@@ -35,20 +35,20 @@ struct wlc_rpc_phy {
 };
 
 #define RPCTX_ENAB(pub)		(TRUE)
-extern rpctx_info_t *wlc_rpctx_attach(wlc_pub_t * pub, struct wlc_info *wlc);
-extern int wlc_rpctx_fifoinit(rpctx_info_t * rpctx, uint fifo, uint ntxd);
-extern void wlc_rpctx_detach(rpctx_info_t * rpctx);
-extern int wlc_rpctx_dump(rpctx_info_t * rpctx, struct bcmstrbuf *b);
-extern void *wlc_rpctx_getnexttxp(rpctx_info_t * rpctx, uint fifo);
-extern void wlc_rpctx_txreclaim(rpctx_info_t * rpctx);
-extern uint wlc_rpctx_txavail(rpctx_info_t * rpctx, uint fifo);
-extern int wlc_rpctx_pkteng(rpctx_info_t * rpctx, uint fifo, void *p);
-extern int wlc_rpctx_tx(rpctx_info_t * rpctx, uint fifo, void *p, bool commit,
+extern rpctx_info_t *wlc_rpctx_attach(wlc_pub_t *pub, struct wlc_info *wlc);
+extern int wlc_rpctx_fifoinit(rpctx_info_t *rpctx, uint fifo, uint ntxd);
+extern void wlc_rpctx_detach(rpctx_info_t *rpctx);
+extern int wlc_rpctx_dump(rpctx_info_t *rpctx, struct bcmstrbuf *b);
+extern void *wlc_rpctx_getnexttxp(rpctx_info_t *rpctx, uint fifo);
+extern void wlc_rpctx_txreclaim(rpctx_info_t *rpctx);
+extern uint wlc_rpctx_txavail(rpctx_info_t *rpctx, uint fifo);
+extern int wlc_rpctx_pkteng(rpctx_info_t *rpctx, uint fifo, void *p);
+extern int wlc_rpctx_tx(rpctx_info_t *rpctx, uint fifo, void *p, bool commit,
 			uint16 frameid, uint8 txpktpend);
-extern void wlc_rpctx_txpktpendinc(rpctx_info_t * rpctx, uint fifo, uint8 val);
-extern void wlc_rpctx_txpktpenddec(rpctx_info_t * rpctx, uint fifo, uint8 val);
-extern void wlc_rpctx_txpktpendclr(rpctx_info_t * rpctx, uint fifo);
-extern int wlc_rpctx_txpktpend(rpctx_info_t * rpctx, uint fifo, bool all);
+extern void wlc_rpctx_txpktpendinc(rpctx_info_t *rpctx, uint fifo, uint8 val);
+extern void wlc_rpctx_txpktpenddec(rpctx_info_t *rpctx, uint fifo, uint8 val);
+extern void wlc_rpctx_txpktpendclr(rpctx_info_t *rpctx, uint fifo);
+extern int wlc_rpctx_txpktpend(rpctx_info_t *rpctx, uint fifo, bool all);
 
 #else
 #define	RPCTX_ENAB(pub)			(FALSE)
--- a/drivers/staging/brcm80211/sys/wlc_scb.h
+++ b/drivers/staging/brcm80211/sys/wlc_scb.h
@@ -19,7 +19,7 @@
 
 #include <proto/802.1d.h>
 
-extern bool wlc_aggregatable(wlc_info_t * wlc, uint8 tid);
+extern bool wlc_aggregatable(wlc_info_t *wlc, uint8 tid);
 
 #define AMPDU_TX_BA_MAX_WSIZE	64	/* max Tx ba window size (in pdu) */
 /* structure to store per-tid state for the ampdu initiator */
--- a/drivers/staging/brcm80211/sys/wlc_stf.c
+++ b/drivers/staging/brcm80211/sys/wlc_stf.c
@@ -40,14 +40,14 @@
 #define WLC_STF_SS_STBC_RX(wlc) (WLCISNPHY(wlc->band) && \
 	NREV_GT(wlc->band->phyrev, 3) && NREV_LE(wlc->band->phyrev, 6))
 
-static int8 wlc_stf_stbc_rx_get(wlc_info_t * wlc);
-static bool wlc_stf_stbc_tx_set(wlc_info_t * wlc, int32 int_val);
-static int wlc_stf_txcore_set(wlc_info_t * wlc, uint8 Nsts, uint8 val);
-static int wlc_stf_spatial_policy_set(wlc_info_t * wlc, int val);
-static void wlc_stf_stbc_rx_ht_update(wlc_info_t * wlc, int val);
+static int8 wlc_stf_stbc_rx_get(wlc_info_t *wlc);
+static bool wlc_stf_stbc_tx_set(wlc_info_t *wlc, int32 int_val);
+static int wlc_stf_txcore_set(wlc_info_t *wlc, uint8 Nsts, uint8 val);
+static int wlc_stf_spatial_policy_set(wlc_info_t *wlc, int val);
+static void wlc_stf_stbc_rx_ht_update(wlc_info_t *wlc, int val);
 
-static void _wlc_stf_phy_txant_upd(wlc_info_t * wlc);
-static uint16 _wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec);
+static void _wlc_stf_phy_txant_upd(wlc_info_t *wlc);
+static uint16 _wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec);
 
 #define NSTS_1	1
 #define NSTS_2	2
@@ -61,7 +61,7 @@ const uint8 txcore_default[5] = {
 	(0x0f)			/* For Nsts = 4, enable all cores */
 };
 
-static void wlc_stf_stbc_rx_ht_update(wlc_info_t * wlc, int val)
+static void wlc_stf_stbc_rx_ht_update(wlc_info_t *wlc, int val)
 {
 	ASSERT((val == HT_CAP_RX_STBC_NO)
 	       || (val == HT_CAP_RX_STBC_ONE_STREAM));
@@ -82,7 +82,7 @@ static void wlc_stf_stbc_rx_ht_update(wl
 }
 
 /* every WLC_TEMPSENSE_PERIOD seconds temperature check to decide whether to turn on/off txchain */
-void wlc_tempsense_upd(wlc_info_t * wlc)
+void wlc_tempsense_upd(wlc_info_t *wlc)
 {
 	wlc_phy_t *pi = wlc->band->pi;
 	uint active_chains, txchain;
@@ -106,7 +106,7 @@ void wlc_tempsense_upd(wlc_info_t * wlc)
 }
 
 void
-wlc_stf_ss_algo_channel_get(wlc_info_t * wlc, uint16 * ss_algo_channel,
+wlc_stf_ss_algo_channel_get(wlc_info_t *wlc, uint16 *ss_algo_channel,
 			    chanspec_t chanspec)
 {
 	tx_power_t power;
@@ -147,12 +147,12 @@ wlc_stf_ss_algo_channel_get(wlc_info_t *
 		setbit(ss_algo_channel, PHY_TXC1_MODE_STBC);
 }
 
-static int8 wlc_stf_stbc_rx_get(wlc_info_t * wlc)
+static int8 wlc_stf_stbc_rx_get(wlc_info_t *wlc)
 {
 	return (wlc->ht_cap.cap & HT_CAP_RX_STBC_MASK) >> HT_CAP_RX_STBC_SHIFT;
 }
 
-static bool wlc_stf_stbc_tx_set(wlc_info_t * wlc, int32 int_val)
+static bool wlc_stf_stbc_tx_set(wlc_info_t *wlc, int32 int_val)
 {
 	if ((int_val != AUTO) && (int_val != OFF) && (int_val != ON)) {
 		return FALSE;
@@ -173,7 +173,7 @@ static bool wlc_stf_stbc_tx_set(wlc_info
 	return TRUE;
 }
 
-bool wlc_stf_stbc_rx_set(wlc_info_t * wlc, int32 int_val)
+bool wlc_stf_stbc_rx_set(wlc_info_t *wlc, int32 int_val)
 {
 	if ((int_val != HT_CAP_RX_STBC_NO)
 	    && (int_val != HT_CAP_RX_STBC_ONE_STREAM)) {
@@ -190,7 +190,7 @@ bool wlc_stf_stbc_rx_set(wlc_info_t * wl
 	return TRUE;
 }
 
-static int wlc_stf_txcore_set(wlc_info_t * wlc, uint8 Nsts, uint8 core_mask)
+static int wlc_stf_txcore_set(wlc_info_t *wlc, uint8 Nsts, uint8 core_mask)
 {
 	WL_TRACE(("wl%d: %s: Nsts %d core_mask %x\n",
 		  wlc->pub->unit, __func__, Nsts, core_mask));
@@ -227,7 +227,7 @@ static int wlc_stf_txcore_set(wlc_info_t
 	return BCME_OK;
 }
 
-static int wlc_stf_spatial_policy_set(wlc_info_t * wlc, int val)
+static int wlc_stf_spatial_policy_set(wlc_info_t *wlc, int val)
 {
 	int i;
 	uint8 core_mask = 0;
@@ -243,7 +243,7 @@ static int wlc_stf_spatial_policy_set(wl
 	return BCME_OK;
 }
 
-int wlc_stf_txchain_set(wlc_info_t * wlc, int32 int_val, bool force)
+int wlc_stf_txchain_set(wlc_info_t *wlc, int32 int_val, bool force)
 {
 	uint8 txchain = (uint8) int_val;
 	uint8 txstreams;
@@ -303,7 +303,7 @@ int wlc_stf_txchain_set(wlc_info_t * wlc
 	return BCME_OK;
 }
 
-int wlc_stf_rxchain_set(wlc_info_t * wlc, int32 int_val)
+int wlc_stf_rxchain_set(wlc_info_t *wlc, int32 int_val)
 {
 	uint8 rxchain_cnt;
 	uint8 rxchain = (uint8) int_val;
@@ -367,7 +367,7 @@ int wlc_stf_rxchain_set(wlc_info_t * wlc
 }
 
 /* update wlc->stf->ss_opmode which represents the operational stf_ss mode we're using */
-int wlc_stf_ss_update(wlc_info_t * wlc, wlcband_t * band)
+int wlc_stf_ss_update(wlc_info_t *wlc, wlcband_t *band)
 {
 	int ret_code = 0;
 	uint8 prev_stf_ss;
@@ -402,7 +402,7 @@ int wlc_stf_ss_update(wlc_info_t * wlc,
 	return ret_code;
 }
 
-int BCMATTACHFN(wlc_stf_attach) (wlc_info_t * wlc) {
+int BCMATTACHFN(wlc_stf_attach) (wlc_info_t *wlc) {
 	wlc->bandstate[BAND_2G_INDEX]->band_stf_ss_mode = PHY_TXC1_MODE_SISO;
 	wlc->bandstate[BAND_5G_INDEX]->band_stf_ss_mode = PHY_TXC1_MODE_CDD;
 
@@ -424,10 +424,10 @@ int BCMATTACHFN(wlc_stf_attach) (wlc_inf
 	return 0;
 }
 
-void BCMATTACHFN(wlc_stf_detach) (wlc_info_t * wlc) {
+void BCMATTACHFN(wlc_stf_detach) (wlc_info_t *wlc) {
 }
 
-int wlc_stf_ant_txant_validate(wlc_info_t * wlc, int8 val)
+int wlc_stf_ant_txant_validate(wlc_info_t *wlc, int8 val)
 {
 	int bcmerror = BCME_OK;
 
@@ -474,7 +474,7 @@ int wlc_stf_ant_txant_validate(wlc_info_
  *    do tx-antenna selection for SISO transmissions
  * for NREV>=7, bit 6 and bit 7 mean antenna 0 and 1 respectively, nit6+bit7 means both cores active
 */
-static void _wlc_stf_phy_txant_upd(wlc_info_t * wlc)
+static void _wlc_stf_phy_txant_upd(wlc_info_t *wlc)
 {
 	int8 txant;
 
@@ -515,12 +515,12 @@ static void _wlc_stf_phy_txant_upd(wlc_i
 	wlc_bmac_txant_set(wlc->hw, wlc->stf->phytxant);
 }
 
-void wlc_stf_phy_txant_upd(wlc_info_t * wlc)
+void wlc_stf_phy_txant_upd(wlc_info_t *wlc)
 {
 	_wlc_stf_phy_txant_upd(wlc);
 }
 
-void BCMATTACHFN(wlc_stf_phy_chain_calc) (wlc_info_t * wlc) {
+void BCMATTACHFN(wlc_stf_phy_chain_calc) (wlc_info_t *wlc) {
 	/* get available rx/tx chains */
 	wlc->stf->hw_txchain = (uint8) getintvar(wlc->pub->vars, "txchain");
 	wlc->stf->hw_rxchain = (uint8) getintvar(wlc->pub->vars, "rxchain");
@@ -556,7 +556,7 @@ void BCMATTACHFN(wlc_stf_phy_chain_calc)
 	wlc_stf_spatial_policy_set(wlc, MIN_SPATIAL_EXPANSION);
 }
 
-static uint16 _wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec)
+static uint16 _wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec)
 {
 	uint16 phytxant = wlc->stf->phytxant;
 
@@ -569,12 +569,12 @@ static uint16 _wlc_stf_phytxchain_sel(wl
 	return phytxant;
 }
 
-uint16 wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec)
+uint16 wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec)
 {
 	return _wlc_stf_phytxchain_sel(wlc, rspec);
 }
 
-uint16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t * wlc, ratespec_t rspec)
+uint16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t *wlc, ratespec_t rspec)
 {
 	uint16 phytxant = wlc->stf->phytxant;
 	uint16 mask = PHY_TXC_ANT_MASK;
--- a/drivers/staging/brcm80211/sys/wlc_stf.h
+++ b/drivers/staging/brcm80211/sys/wlc_stf.h
@@ -20,23 +20,23 @@
 #define MIN_SPATIAL_EXPANSION	0
 #define MAX_SPATIAL_EXPANSION	1
 
-extern int wlc_stf_attach(wlc_info_t * wlc);
-extern void wlc_stf_detach(wlc_info_t * wlc);
+extern int wlc_stf_attach(wlc_info_t *wlc);
+extern void wlc_stf_detach(wlc_info_t *wlc);
 
-extern void wlc_tempsense_upd(wlc_info_t * wlc);
-extern void wlc_stf_ss_algo_channel_get(wlc_info_t * wlc,
-					uint16 * ss_algo_channel,
+extern void wlc_tempsense_upd(wlc_info_t *wlc);
+extern void wlc_stf_ss_algo_channel_get(wlc_info_t *wlc,
+					uint16 *ss_algo_channel,
 					chanspec_t chanspec);
-extern int wlc_stf_ss_update(wlc_info_t * wlc, struct wlcband *band);
-extern void wlc_stf_phy_txant_upd(wlc_info_t * wlc);
-extern int wlc_stf_txchain_set(wlc_info_t * wlc, int32 int_val, bool force);
-extern int wlc_stf_rxchain_set(wlc_info_t * wlc, int32 int_val);
-extern bool wlc_stf_stbc_rx_set(wlc_info_t * wlc, int32 int_val);
+extern int wlc_stf_ss_update(wlc_info_t *wlc, struct wlcband *band);
+extern void wlc_stf_phy_txant_upd(wlc_info_t *wlc);
+extern int wlc_stf_txchain_set(wlc_info_t *wlc, int32 int_val, bool force);
+extern int wlc_stf_rxchain_set(wlc_info_t *wlc, int32 int_val);
+extern bool wlc_stf_stbc_rx_set(wlc_info_t *wlc, int32 int_val);
 
-extern int wlc_stf_ant_txant_validate(wlc_info_t * wlc, int8 val);
-extern void wlc_stf_phy_txant_upd(wlc_info_t * wlc);
-extern void wlc_stf_phy_chain_calc(wlc_info_t * wlc);
-extern uint16 wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec);
-extern uint16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t * wlc, ratespec_t rspec);
-extern uint16 wlc_stf_spatial_expansion_get(wlc_info_t * wlc, ratespec_t rspec);
+extern int wlc_stf_ant_txant_validate(wlc_info_t *wlc, int8 val);
+extern void wlc_stf_phy_txant_upd(wlc_info_t *wlc);
+extern void wlc_stf_phy_chain_calc(wlc_info_t *wlc);
+extern uint16 wlc_stf_phytxchain_sel(wlc_info_t *wlc, ratespec_t rspec);
+extern uint16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t *wlc, ratespec_t rspec);
+extern uint16 wlc_stf_spatial_expansion_get(wlc_info_t *wlc, ratespec_t rspec);
 #endif				/* _wlc_stf_h_ */
--- a/drivers/staging/brcm80211/util/aiutils.c
+++ b/drivers/staging/brcm80211/util/aiutils.c
@@ -31,7 +31,7 @@
 /* EROM parsing */
 
 static uint32
-get_erom_ent(si_t * sih, uint32 ** eromptr, uint32 mask, uint32 match)
+get_erom_ent(si_t *sih, uint32 **eromptr, uint32 mask, uint32 match)
 {
 	uint32 ent;
 	uint inv = 0, nom = 0;
@@ -66,8 +66,8 @@ get_erom_ent(si_t * sih, uint32 ** eromp
 }
 
 static uint32
-get_asd(si_t * sih, uint32 ** eromptr, uint sp, uint ad, uint st,
-	uint32 * addrl, uint32 * addrh, uint32 * sizel, uint32 * sizeh)
+get_asd(si_t *sih, uint32 **eromptr, uint sp, uint ad, uint st,
+	uint32 *addrl, uint32 *addrh, uint32 *sizel, uint32 *sizeh)
 {
 	uint32 asd, sz, szd;
 
@@ -100,12 +100,12 @@ get_asd(si_t * sih, uint32 ** eromptr, u
 	return asd;
 }
 
-static void ai_hwfixup(si_info_t * sii)
+static void ai_hwfixup(si_info_t *sii)
 {
 }
 
 /* parse the enumeration rom to identify all cores */
-void BCMATTACHFN(ai_scan) (si_t * sih, void *regs, uint devid) {
+void BCMATTACHFN(ai_scan) (si_t *sih, void *regs, uint devid) {
 	si_info_t *sii = SI_INFO(sih);
 	chipcregs_t *cc = (chipcregs_t *) regs;
 	uint32 erombase, *eromptr, *eromlim;
@@ -310,7 +310,7 @@ void BCMATTACHFN(ai_scan) (si_t * sih, v
 /* This function changes the logical "focus" to the indicated core.
  * Return the current core's virtual address.
  */
-void *ai_setcoreidx(si_t * sih, uint coreidx)
+void *ai_setcoreidx(si_t *sih, uint coreidx)
 {
 	si_info_t *sii = SI_INFO(sih);
 	uint32 addr = sii->coresba[coreidx];
@@ -371,13 +371,13 @@ void *ai_setcoreidx(si_t * sih, uint cor
 }
 
 /* Return the number of address spaces in current core */
-int ai_numaddrspaces(si_t * sih)
+int ai_numaddrspaces(si_t *sih)
 {
 	return 2;
 }
 
 /* Return the address of the nth address space in the current core */
-uint32 ai_addrspace(si_t * sih, uint asidx)
+uint32 ai_addrspace(si_t *sih, uint asidx)
 {
 	si_info_t *sii;
 	uint cidx;
@@ -396,7 +396,7 @@ uint32 ai_addrspace(si_t * sih, uint asi
 }
 
 /* Return the size of the nth address space in the current core */
-uint32 ai_addrspacesize(si_t * sih, uint asidx)
+uint32 ai_addrspacesize(si_t *sih, uint asidx)
 {
 	si_info_t *sii;
 	uint cidx;
@@ -414,7 +414,7 @@ uint32 ai_addrspacesize(si_t * sih, uint
 	}
 }
 
-uint ai_flag(si_t * sih)
+uint ai_flag(si_t *sih)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
@@ -429,11 +429,11 @@ uint ai_flag(si_t * sih)
 	return (R_REG(sii->osh, &ai->oobselouta30) & 0x1f);
 }
 
-void ai_setint(si_t * sih, int siflag)
+void ai_setint(si_t *sih, int siflag)
 {
 }
 
-void ai_write_wrap_reg(si_t * sih, uint32 offset, uint32 val)
+void ai_write_wrap_reg(si_t *sih, uint32 offset, uint32 val)
 {
 	si_info_t *sii = SI_INFO(sih);
 	uint32 *w = (uint32 *) sii->curwrap;
@@ -441,7 +441,7 @@ void ai_write_wrap_reg(si_t * sih, uint3
 	return;
 }
 
-uint ai_corevendor(si_t * sih)
+uint ai_corevendor(si_t *sih)
 {
 	si_info_t *sii;
 	uint32 cia;
@@ -451,7 +451,7 @@ uint ai_corevendor(si_t * sih)
 	return ((cia & CIA_MFG_MASK) >> CIA_MFG_SHIFT);
 }
 
-uint ai_corerev(si_t * sih)
+uint ai_corerev(si_t *sih)
 {
 	si_info_t *sii;
 	uint32 cib;
@@ -461,7 +461,7 @@ uint ai_corerev(si_t * sih)
 	return ((cib & CIB_REV_MASK) >> CIB_REV_SHIFT);
 }
 
-bool ai_iscoreup(si_t * sih)
+bool ai_iscoreup(si_t *sih)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
@@ -483,7 +483,7 @@ bool ai_iscoreup(si_t * sih)
  * Also, when using pci/pcie, we can optimize away the core switching for pci registers
  * and (on newer pci cores) chipcommon registers.
  */
-uint ai_corereg(si_t * sih, uint coreidx, uint regoff, uint mask, uint val)
+uint ai_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val)
 {
 	uint origidx = 0;
 	uint32 *r = NULL;
@@ -570,7 +570,7 @@ uint ai_corereg(si_t * sih, uint coreidx
 	return (w);
 }
 
-void ai_core_disable(si_t * sih, uint32 bits)
+void ai_core_disable(si_t *sih, uint32 bits)
 {
 	si_info_t *sii;
 	volatile uint32 dummy;
@@ -598,7 +598,7 @@ void ai_core_disable(si_t * sih, uint32
  * bits - core specific bits that are set during and after reset sequence
  * resetbits - core specific bits that are set only during reset sequence
  */
-void ai_core_reset(si_t * sih, uint32 bits, uint32 resetbits)
+void ai_core_reset(si_t *sih, uint32 bits, uint32 resetbits)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
@@ -626,7 +626,7 @@ void ai_core_reset(si_t * sih, uint32 bi
 	OSL_DELAY(1);
 }
 
-void ai_core_cflags_wo(si_t * sih, uint32 mask, uint32 val)
+void ai_core_cflags_wo(si_t *sih, uint32 mask, uint32 val)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
@@ -651,7 +651,7 @@ void ai_core_cflags_wo(si_t * sih, uint3
 	}
 }
 
-uint32 ai_core_cflags(si_t * sih, uint32 mask, uint32 val)
+uint32 ai_core_cflags(si_t *sih, uint32 mask, uint32 val)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
@@ -677,7 +677,7 @@ uint32 ai_core_cflags(si_t * sih, uint32
 	return R_REG(sii->osh, &ai->ioctrl);
 }
 
-uint32 ai_core_sflags(si_t * sih, uint32 mask, uint32 val)
+uint32 ai_core_sflags(si_t *sih, uint32 mask, uint32 val)
 {
 	si_info_t *sii;
 	aidmp_t *ai;
@@ -704,7 +704,7 @@ uint32 ai_core_sflags(si_t * sih, uint32
 }
 
 #ifdef BCMDBG
-void ai_view(si_t * sih, bool verbose)
+void ai_view(si_t *sih, bool verbose)
 {
 	si_info_t *sii;
 	osl_t *osh;
--- a/drivers/staging/brcm80211/util/bcmotp.c
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -55,11 +55,11 @@
 /* OTP common function type */
 typedef int (*otp_status_t) (void *oh);
 typedef int (*otp_size_t) (void *oh);
-typedef void *(*otp_init_t) (si_t * sih);
-typedef uint16(*otp_read_bit_t) (void *oh, chipcregs_t * cc, uint off);
-typedef int (*otp_read_region_t) (si_t * sih, int region, uint16 * data,
-				  uint * wlen);
-typedef int (*otp_nvread_t) (void *oh, char *data, uint * len);
+typedef void *(*otp_init_t) (si_t *sih);
+typedef uint16(*otp_read_bit_t) (void *oh, chipcregs_t *cc, uint off);
+typedef int (*otp_read_region_t) (si_t *sih, int region, uint16 *data,
+				  uint *wlen);
+typedef int (*otp_nvread_t) (void *oh, char *data, uint *len);
 
 /* OTP function struct */
 typedef struct otp_fn_s {
@@ -170,7 +170,7 @@ static int ipxotp_size(void *oh)
 	return (int)oi->wsize * 2;
 }
 
-static uint16 ipxotp_otpr(void *oh, chipcregs_t * cc, uint wn)
+static uint16 ipxotp_otpr(void *oh, chipcregs_t *cc, uint wn)
 {
 	otpinfo_t *oi;
 
@@ -182,7 +182,7 @@ static uint16 ipxotp_otpr(void *oh, chip
 	return R_REG(oi->osh, &cc->sromotp[wn]);
 }
 
-static uint16 ipxotp_read_bit(void *oh, chipcregs_t * cc, uint off)
+static uint16 ipxotp_read_bit(void *oh, chipcregs_t *cc, uint off)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint k, row, col;
@@ -214,7 +214,7 @@ static uint16 ipxotp_read_bit(void *oh,
 /* Calculate max HW/SW region byte size by substracting fuse region and checksum size,
  * osizew is oi->wsize (OTP size - GU size) in words
  */
-static int ipxotp_max_rgnsz(si_t * sih, int osizew)
+static int ipxotp_max_rgnsz(si_t *sih, int osizew)
 {
 	int ret = 0;
 
@@ -233,7 +233,7 @@ static int ipxotp_max_rgnsz(si_t * sih,
 	return ret;
 }
 
-static void BCMNMIATTACHFN(_ipxotp_init) (otpinfo_t * oi, chipcregs_t * cc) {
+static void BCMNMIATTACHFN(_ipxotp_init) (otpinfo_t *oi, chipcregs_t *cc) {
 	uint k;
 	uint32 otpp, st;
 
@@ -302,7 +302,7 @@ static void BCMNMIATTACHFN(_ipxotp_init)
 	oi->flim = oi->wsize;
 }
 
-static void *BCMNMIATTACHFN(ipxotp_init) (si_t * sih) {
+static void *BCMNMIATTACHFN(ipxotp_init) (si_t *sih) {
 	uint idx;
 	chipcregs_t *cc;
 	otpinfo_t *oi;
@@ -366,7 +366,7 @@ static void *BCMNMIATTACHFN(ipxotp_init)
 	return (void *)oi;
 }
 
-static int ipxotp_read_region(void *oh, int region, uint16 * data, uint * wlen)
+static int ipxotp_read_region(void *oh, int region, uint16 *data, uint *wlen)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint idx;
@@ -452,7 +452,7 @@ static int ipxotp_read_region(void *oh,
 	return 0;
 }
 
-static int ipxotp_nvread(void *oh, char *data, uint * len)
+static int ipxotp_nvread(void *oh, char *data, uint *len)
 {
 	return BCME_UNSUPPORTED;
 }
@@ -560,7 +560,7 @@ static int hndotp_size(void *oh)
 	return ((int)(oi->size));
 }
 
-static uint16 hndotp_otpr(void *oh, chipcregs_t * cc, uint wn)
+static uint16 hndotp_otpr(void *oh, chipcregs_t *cc, uint wn)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	osl_t *osh;
@@ -575,7 +575,7 @@ static uint16 hndotp_otpr(void *oh, chip
 	return (R_REG(osh, &ptr[wn]));
 }
 
-static uint16 hndotp_otproff(void *oh, chipcregs_t * cc, int woff)
+static uint16 hndotp_otproff(void *oh, chipcregs_t *cc, int woff)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	osl_t *osh;
@@ -592,7 +592,7 @@ static uint16 hndotp_otproff(void *oh, c
 	return (R_REG(osh, &ptr[(oi->size / 2) + woff]));
 }
 
-static uint16 hndotp_read_bit(void *oh, chipcregs_t * cc, uint idx)
+static uint16 hndotp_read_bit(void *oh, chipcregs_t *cc, uint idx)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint k, row, col;
@@ -623,7 +623,7 @@ static uint16 hndotp_read_bit(void *oh,
 	return (uint16) st;
 }
 
-static void *BCMNMIATTACHFN(hndotp_init) (si_t * sih) {
+static void *BCMNMIATTACHFN(hndotp_init) (si_t *sih) {
 	uint idx;
 	chipcregs_t *cc;
 	otpinfo_t *oi;
@@ -697,7 +697,7 @@ static void *BCMNMIATTACHFN(hndotp_init)
 	return ret;
 }
 
-static int hndotp_read_region(void *oh, int region, uint16 * data, uint * wlen)
+static int hndotp_read_region(void *oh, int region, uint16 *data, uint *wlen)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 	uint32 idx, st;
@@ -727,7 +727,7 @@ static int hndotp_read_region(void *oh,
 	return 0;
 }
 
-static int hndotp_nvread(void *oh, char *data, uint * len)
+static int hndotp_nvread(void *oh, char *data, uint *len)
 {
 	int rc = 0;
 	otpinfo_t *oi = (otpinfo_t *) oh;
@@ -885,7 +885,7 @@ uint16 otp_read_bit(void *oh, uint offse
 	return readBit;
 }
 
-void *BCMNMIATTACHFN(otp_init) (si_t * sih) {
+void *BCMNMIATTACHFN(otp_init) (si_t *sih) {
 	otpinfo_t *oi;
 	void *ret = NULL;
 
@@ -917,8 +917,8 @@ void *BCMNMIATTACHFN(otp_init) (si_t * s
 }
 
 int
-BCMNMIATTACHFN(otp_read_region) (si_t * sih, int region, uint16 * data,
-				 uint * wlen) {
+BCMNMIATTACHFN(otp_read_region) (si_t *sih, int region, uint16 *data,
+				 uint *wlen) {
 	bool wasup = FALSE;
 	void *oh;
 	int err = 0;
@@ -946,7 +946,7 @@ BCMNMIATTACHFN(otp_read_region) (si_t *
 	return err;
 }
 
-int otp_nvread(void *oh, char *data, uint * len)
+int otp_nvread(void *oh, char *data, uint *len)
 {
 	otpinfo_t *oi = (otpinfo_t *) oh;
 
--- a/drivers/staging/brcm80211/util/bcmsrom.c
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -65,38 +65,38 @@ extern uint _varsz;
 
 #define SROM_CIS_SINGLE	1
 
-static int initvars_srom_si(si_t * sih, osl_t * osh, void *curmap, char **vars,
-			    uint * count);
-static void _initvars_srom_pci(uint8 sromrev, uint16 * srom, uint off,
-			       varbuf_t * b);
-static int initvars_srom_pci(si_t * sih, void *curmap, char **vars,
-			     uint * count);
-static int initvars_flash_si(si_t * sih, char **vars, uint * count);
+static int initvars_srom_si(si_t *sih, osl_t *osh, void *curmap, char **vars,
+			    uint *count);
+static void _initvars_srom_pci(uint8 sromrev, uint16 *srom, uint off,
+			       varbuf_t *b);
+static int initvars_srom_pci(si_t *sih, void *curmap, char **vars,
+			     uint *count);
+static int initvars_flash_si(si_t *sih, char **vars, uint *count);
 #ifdef BCMSDIO
-static int initvars_cis_sdio(osl_t * osh, char **vars, uint * count);
-static int sprom_cmd_sdio(osl_t * osh, uint8 cmd);
-static int sprom_read_sdio(osl_t * osh, uint16 addr, uint16 * data);
+static int initvars_cis_sdio(osl_t *osh, char **vars, uint *count);
+static int sprom_cmd_sdio(osl_t *osh, uint8 cmd);
+static int sprom_read_sdio(osl_t *osh, uint16 addr, uint16 *data);
 #endif				/* BCMSDIO */
-static int sprom_read_pci(osl_t * osh, si_t * sih, uint16 * sprom, uint wordoff,
-			  uint16 * buf, uint nwords, bool check_crc);
+static int sprom_read_pci(osl_t *osh, si_t *sih, uint16 *sprom, uint wordoff,
+			  uint16 *buf, uint nwords, bool check_crc);
 #if defined(BCMNVRAMR)
-static int otp_read_pci(osl_t * osh, si_t * sih, uint16 * buf, uint bufsz);
+static int otp_read_pci(osl_t *osh, si_t *sih, uint16 *buf, uint bufsz);
 #endif
-static uint16 srom_cc_cmd(si_t * sih, osl_t * osh, void *ccregs, uint32 cmd,
+static uint16 srom_cc_cmd(si_t *sih, osl_t *osh, void *ccregs, uint32 cmd,
 			  uint wordoff, uint16 data);
 
-static int initvars_table(osl_t * osh, char *start, char *end, char **vars,
-			  uint * count);
-static int initvars_flash(si_t * sih, osl_t * osh, char **vp, uint len);
+static int initvars_table(osl_t *osh, char *start, char *end, char **vars,
+			  uint *count);
+static int initvars_flash(si_t *sih, osl_t *osh, char **vp, uint len);
 
 /* Initialization of varbuf structure */
-static void BCMATTACHFN(varbuf_init) (varbuf_t * b, char *buf, uint size) {
+static void BCMATTACHFN(varbuf_init) (varbuf_t *b, char *buf, uint size) {
 	b->size = size;
 	b->base = b->buf = buf;
 }
 
 /* append a null terminated var=value string */
-static int BCMATTACHFN(varbuf_append) (varbuf_t * b, const char *fmt, ...) {
+static int BCMATTACHFN(varbuf_append) (varbuf_t *b, const char *fmt, ...) {
 	va_list ap;
 	int r;
 	size_t len;
@@ -151,8 +151,8 @@ static int BCMATTACHFN(varbuf_append) (v
  * Return 0 on success, nonzero on error.
  */
 int
-BCMATTACHFN(srom_var_init) (si_t * sih, uint bustype, void *curmap, osl_t * osh,
-			    char **vars, uint * count) {
+BCMATTACHFN(srom_var_init) (si_t *sih, uint bustype, void *curmap, osl_t *osh,
+			    char **vars, uint *count) {
 	uint len;
 
 	len = 0;
@@ -189,8 +189,8 @@ BCMATTACHFN(srom_var_init) (si_t * sih,
 
 /* support only 16-bit word read from srom */
 int
-srom_read(si_t * sih, uint bustype, void *curmap, osl_t * osh,
-	  uint byteoff, uint nbytes, uint16 * buf, bool check_crc)
+srom_read(si_t *sih, uint bustype, void *curmap, osl_t *osh,
+	  uint byteoff, uint nbytes, uint16 *buf, bool check_crc)
 {
 	uint off, nw;
 #ifdef BCMSDIO
@@ -377,8 +377,8 @@ uint8 patch_pair = 0;
 #define BCMDONGLECASE(n)
 
 int
-BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
-			    char **vars, uint * count)
+BCMATTACHFN(srom_parsecis) (osl_t *osh, uint8 *pcis[], uint ciscnt,
+			    char **vars, uint *count)
 {
 	char eabuf[32];
 	char *base;
@@ -1411,7 +1411,7 @@ BCMATTACHFN(srom_parsecis) (osl_t * osh,
  * not in the bus cores.
  */
 static uint16
-srom_cc_cmd(si_t * sih, osl_t * osh, void *ccregs, uint32 cmd, uint wordoff,
+srom_cc_cmd(si_t *sih, osl_t *osh, void *ccregs, uint32 cmd, uint wordoff,
 	    uint16 data)
 {
 	chipcregs_t *cc = (chipcregs_t *) ccregs;
@@ -1445,8 +1445,8 @@ srom_cc_cmd(si_t * sih, osl_t * osh, voi
  * Return 0 on success, nonzero on error.
  */
 static int
-sprom_read_pci(osl_t * osh, si_t * sih, uint16 * sprom, uint wordoff,
-	       uint16 * buf, uint nwords, bool check_crc)
+sprom_read_pci(osl_t *osh, si_t *sih, uint16 *sprom, uint wordoff,
+	       uint16 *buf, uint nwords, bool check_crc)
 {
 	int err = 0;
 	uint i;
@@ -1505,7 +1505,7 @@ sprom_read_pci(osl_t * osh, si_t * sih,
 }
 
 #if defined(BCMNVRAMR)
-static int otp_read_pci(osl_t * osh, si_t * sih, uint16 * buf, uint bufsz)
+static int otp_read_pci(osl_t *osh, si_t *sih, uint16 *buf, uint bufsz)
 {
 	uint8 *otp;
 	uint sz = OTP_SZ_MAX / 2;	/* size in words */
@@ -1555,8 +1555,8 @@ static int otp_read_pci(osl_t * osh, si_
 * Return 0 on success, nonzero on error.
 */
 static int
-BCMATTACHFN(initvars_table) (osl_t * osh, char *start, char *end, char **vars,
-			     uint * count) {
+BCMATTACHFN(initvars_table) (osl_t *osh, char *start, char *end, char **vars,
+			     uint *count) {
 	int c = (int)(end - start);
 
 	/* do it only when there is more than just the null string */
@@ -1582,7 +1582,7 @@ BCMATTACHFN(initvars_table) (osl_t * osh
  * Return 0 on success, nonzero on error.
  */
 static int
-BCMATTACHFN(initvars_flash) (si_t * sih, osl_t * osh, char **base, uint len) {
+BCMATTACHFN(initvars_flash) (si_t *sih, osl_t *osh, char **base, uint len) {
 	char *vp = *base;
 	char *flash;
 	int err;
@@ -1638,7 +1638,7 @@ BCMATTACHFN(initvars_flash) (si_t * sih,
  * Return 0 on success, nonzero on error.
  */
 static int
-BCMATTACHFN(initvars_flash_si) (si_t * sih, char **vars, uint * count) {
+BCMATTACHFN(initvars_flash_si) (si_t *sih, char **vars, uint *count) {
 	osl_t *osh = si_osh(sih);
 	char *vp, *base;
 	int err;
@@ -1697,8 +1697,8 @@ static bool mask_valid(uint16 mask)
 #endif				/* BCMDBG */
 
 static void
-BCMATTACHFN(_initvars_srom_pci) (uint8 sromrev, uint16 * srom, uint off,
-				 varbuf_t * b) {
+BCMATTACHFN(_initvars_srom_pci) (uint8 sromrev, uint16 *srom, uint off,
+				 varbuf_t *b) {
 	uint16 w;
 	uint32 val;
 	const sromvar_t *srv;
@@ -1846,8 +1846,8 @@ BCMATTACHFN(_initvars_srom_pci) (uint8 s
  * Return 0 on success, nonzero on error.
  */
 static int
-BCMATTACHFN(initvars_srom_pci) (si_t * sih, void *curmap, char **vars,
-				uint * count) {
+BCMATTACHFN(initvars_srom_pci) (si_t *sih, void *curmap, char **vars,
+				uint *count) {
 	uint16 *srom, *sromwindow;
 	uint8 sromrev = 0;
 	uint32 sr;
@@ -1992,7 +1992,7 @@ BCMATTACHFN(initvars_srom_pci) (si_t * s
  * Return 0 on success, nonzero on error.
  */
 static int
-BCMATTACHFN(initvars_cis_sdio) (osl_t * osh, char **vars, uint * count) {
+BCMATTACHFN(initvars_cis_sdio) (osl_t *osh, char **vars, uint *count) {
 	uint8 *cis[SBSDIO_NUM_FUNCTION + 1];
 	uint fn, numfn;
 	int rc = 0;
@@ -2026,7 +2026,7 @@ BCMATTACHFN(initvars_cis_sdio) (osl_t *
 }
 
 /* set SDIO sprom command register */
-static int BCMATTACHFN(sprom_cmd_sdio) (osl_t * osh, uint8 cmd) {
+static int BCMATTACHFN(sprom_cmd_sdio) (osl_t *osh, uint8 cmd) {
 	uint8 status = 0;
 	uint wait_cnt = 1000;
 
@@ -2045,7 +2045,7 @@ static int BCMATTACHFN(sprom_cmd_sdio) (
 }
 
 /* read a word from the SDIO srom */
-static int sprom_read_sdio(osl_t * osh, uint16 addr, uint16 * data)
+static int sprom_read_sdio(osl_t *osh, uint16 addr, uint16 *data)
 {
 	uint8 addr_l, addr_h, data_l, data_h;
 
@@ -2074,8 +2074,8 @@ static int sprom_read_sdio(osl_t * osh,
 #endif				/* BCMSDIO */
 
 static int
-BCMATTACHFN(initvars_srom_si) (si_t * sih, osl_t * osh, void *curmap,
-			       char **vars, uint * varsz) {
+BCMATTACHFN(initvars_srom_si) (si_t *sih, osl_t *osh, void *curmap,
+			       char **vars, uint *varsz) {
 	/* Search flash nvram section for srom variables */
 	return initvars_flash_si(sih, vars, varsz);
 }
--- a/drivers/staging/brcm80211/util/bcmutils.c
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -34,7 +34,7 @@ static int vars_len = -1;
 #endif				/* WLC_LOW */
 
 /* copy a pkt buffer chain into a buffer */
-uint pktcopy(osl_t * osh, void *p, uint offset, int len, uchar * buf)
+uint pktcopy(osl_t *osh, void *p, uint offset, int len, uchar *buf)
 {
 	uint n, ret = 0;
 
@@ -65,7 +65,7 @@ uint pktcopy(osl_t * osh, void *p, uint
 }
 
 /* copy a buffer into a pkt buffer chain */
-uint pktfrombuf(osl_t * osh, void *p, uint offset, int len, uchar * buf)
+uint pktfrombuf(osl_t *osh, void *p, uint offset, int len, uchar *buf)
 {
 	uint n, ret = 0;
 
@@ -93,7 +93,7 @@ uint pktfrombuf(osl_t * osh, void *p, ui
 }
 
 /* return total length of buffer chain */
-uint BCMFASTPATH pkttotlen(osl_t * osh, void *p)
+uint BCMFASTPATH pkttotlen(osl_t *osh, void *p)
 {
 	uint total;
 
@@ -104,7 +104,7 @@ uint BCMFASTPATH pkttotlen(osl_t * osh,
 }
 
 /* return the last buffer of chained pkt */
-void *pktlast(osl_t * osh, void *p)
+void *pktlast(osl_t *osh, void *p)
 {
 	for (; PKTNEXT(p); p = PKTNEXT(p)) ;
 
@@ -112,7 +112,7 @@ void *pktlast(osl_t * osh, void *p)
 }
 
 /* count segments of a chained packet */
-uint BCMFASTPATH pktsegcnt(osl_t * osh, void *p)
+uint BCMFASTPATH pktsegcnt(osl_t *osh, void *p)
 {
 	uint cnt;
 
@@ -234,7 +234,7 @@ void *BCMFASTPATH pktq_pdeq_tail(struct
 }
 
 void
-pktq_pflush(osl_t * osh, struct pktq *pq, int prec, bool dir, ifpkt_cb_t fn,
+pktq_pflush(osl_t *osh, struct pktq *pq, int prec, bool dir, ifpkt_cb_t fn,
 	    int arg)
 {
 	struct pktq_prec *q;
@@ -419,7 +419,7 @@ void *pktq_peek_tail(struct pktq *pq, in
 	return (pq->q[prec].tail);
 }
 
-void pktq_flush(osl_t * osh, struct pktq *pq, bool dir, ifpkt_cb_t fn, int arg)
+void pktq_flush(osl_t *osh, struct pktq *pq, bool dir, ifpkt_cb_t fn, int arg)
 {
 	int prec;
 	for (prec = 0; prec < pq->num_prec; prec++)
@@ -778,7 +778,7 @@ int bcmstrnicmp(const char *s1, const ch
 }
 
 /* parse a xx:xx:xx:xx:xx:xx format ethernet address */
-int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr * ea) {
+int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr *ea) {
 	int i = 0;
 
 	for (;;) {
@@ -926,7 +926,7 @@ uint getgpiopin(char *vars, char *pin_na
 
 #if defined(BCMDBG)
 /* pretty hex print a pkt buffer chain */
-void prpkt(const char *msg, osl_t * osh, void *p0)
+void prpkt(const char *msg, osl_t *osh, void *p0)
 {
 	void *p;
 
@@ -983,7 +983,7 @@ static void BCMINITFN(bcm_nvram_refresh)
 		vars_len = 0;
 }
 
-char *bcm_nvram_vars(uint * length)
+char *bcm_nvram_vars(uint *length)
 {
 #ifndef BCMNVRAMR
 	/* cache may be stale if nvram is read/write */
@@ -1039,7 +1039,7 @@ int BCMINITFN(bcm_nvram_cache) (void *si
 #endif				/* WLC_LOW */
 
 /* iovar table lookup */
-const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t * table, const char *name)
+const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t *table, const char *name)
 {
 	const bcm_iovar_t *vi;
 	const char *lookup_name;
@@ -1062,7 +1062,7 @@ const bcm_iovar_t *bcm_iovar_lookup(cons
 	return NULL;		/* var name not found */
 }
 
-int bcm_iovar_lencheck(const bcm_iovar_t * vi, void *arg, int len, bool set)
+int bcm_iovar_lencheck(const bcm_iovar_t *vi, void *arg, int len, bool set)
 {
 	int bcmerror = 0;
 
@@ -1167,7 +1167,7 @@ static const uint8 crc8_table[256] = {
 #define CRC_INNER_LOOP(n, c, x) \
 	(c) = ((c) >> 8) ^ crc##n##_table[((c) ^ (x)) & 0xff]
 
-uint8 BCMROMFN(hndcrc8) (uint8 * pdata,	/* pointer to array of data to process */
+uint8 BCMROMFN(hndcrc8) (uint8 *pdata,	/* pointer to array of data to process */
 			 uint nbytes,	/* number of input data bytes to process */
 			 uint8 crc	/* either CRC8_INIT_VALUE or previous return value */
     ) {
@@ -1237,7 +1237,7 @@ static const uint16 crc16_table[256] = {
 	0x7BC7, 0x6A4E, 0x58D5, 0x495C, 0x3DE3, 0x2C6A, 0x1EF1, 0x0F78
 };
 
-uint16 BCMROMFN(hndcrc16) (uint8 * pdata,	/* pointer to array of data to process */
+uint16 BCMROMFN(hndcrc16) (uint8 *pdata,	/* pointer to array of data to process */
 			   uint nbytes,	/* number of input data bytes to process */
 			   uint16 crc	/* either CRC16_INIT_VALUE or previous return value */
     ) {
@@ -1254,7 +1254,7 @@ uint16 BCMROMFN(hndcrc16) (uint8 * pdata
  * *buflen is not modified if the TLV elt parameter is invalid, or is decremented
  * by the TLV parameter's length if it is valid.
  */
-bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t * elt, int *buflen) {
+bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t *elt, int *buflen) {
 	int len;
 
 	/* validate current elt */
@@ -1334,7 +1334,7 @@ bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tl
 
 #if defined(BCMDBG)
 int
-bcm_format_flags(const bcm_bit_desc_t * bd, uint32 flags, char *buf, int len)
+bcm_format_flags(const bcm_bit_desc_t *bd, uint32 flags, char *buf, int len)
 {
 	int i;
 	char *p = buf;
@@ -1402,7 +1402,7 @@ int bcm_format_hex(char *str, const void
 #endif				/* defined(BCMDBG) */
 
 /* pretty hex print a contiguous buffer */
-void prhex(const char *msg, uchar * buf, uint nbytes)
+void prhex(const char *msg, uchar *buf, uint nbytes)
 {
 	char line[128], *p;
 	int len = sizeof(line);
@@ -1517,7 +1517,7 @@ void printbig(char *buf)
 /* routine to dump fields in a fileddesc structure */
 uint
 bcmdumpfields(bcmutl_rdreg_rtn read_rtn, void *arg0, uint arg1,
-	      struct fielddesc * fielddesc_array, char *buf, uint32 bufsize)
+	      struct fielddesc *fielddesc_array, char *buf, uint32 bufsize)
 {
 	uint filled_len;
 	int len;
@@ -1642,7 +1642,7 @@ uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 m
 	return (qdbm);
 }
 
-uint BCMROMFN(bcm_bitcount) (uint8 * bitmap, uint length) {
+uint BCMROMFN(bcm_bitcount) (uint8 *bitmap, uint length) {
 	uint bitcount = 0, i;
 	uint8 tmp;
 	for (i = 0; i < length; i++) {
@@ -1687,7 +1687,7 @@ int bcm_bprintf(struct bcmstrbuf *b, con
 	return r;
 }
 
-void bcm_inc_bytes(uchar * num, int num_bytes, uint8 amount)
+void bcm_inc_bytes(uchar *num, int num_bytes, uint8 amount)
 {
 	int i;
 
@@ -1699,7 +1699,7 @@ void bcm_inc_bytes(uchar * num, int num_
 	}
 }
 
-int bcm_cmp_bytes(uchar * arg1, uchar * arg2, uint8 nbytes)
+int bcm_cmp_bytes(uchar *arg1, uchar *arg2, uint8 nbytes)
 {
 	int i;
 
@@ -1710,7 +1710,7 @@ int bcm_cmp_bytes(uchar * arg1, uchar *
 	return 0;
 }
 
-void bcm_print_bytes(char *name, const uchar * data, int len)
+void bcm_print_bytes(char *name, const uchar *data, int len)
 {
 	int i;
 	int per_line = 0;
--- a/drivers/staging/brcm80211/util/bcmwpa.c
+++ b/drivers/staging/brcm80211/util/bcmwpa.c
@@ -20,7 +20,7 @@
 /* Is this body of this tlvs entry a WFA entry? If
  * not update the tlvs buffer pointer/length.
  */
-bool bcm_is_wfa_ie(uint8 * ie, uint8 ** tlvs, uint * tlvs_len, uint8 type)
+bool bcm_is_wfa_ie(uint8 *ie, uint8 **tlvs, uint *tlvs_len, uint8 type)
 {
 	/* If the contents match the WFA_OUI and type */
 	if ((ie[TLV_LEN_OFF] > (WFA_OUI_LEN + 1)) &&
--- a/drivers/staging/brcm80211/util/hnddma.c
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -180,83 +180,83 @@ typedef struct dma_info {
 #define	PCI64ADDR_HIGH_SHIFT	31	/* address[63] */
 
 /* Common prototypes */
-static bool _dma_isaddrext(dma_info_t * di);
-static bool _dma_descriptor_align(dma_info_t * di);
-static bool _dma_alloc(dma_info_t * di, uint direction);
-static void _dma_detach(dma_info_t * di);
-static void _dma_ddtable_init(dma_info_t * di, uint direction, dmaaddr_t pa);
-static void _dma_rxinit(dma_info_t * di);
-static void *_dma_rx(dma_info_t * di);
-static bool _dma_rxfill(dma_info_t * di);
-static void _dma_rxreclaim(dma_info_t * di);
-static void _dma_rxenable(dma_info_t * di);
-static void *_dma_getnextrxp(dma_info_t * di, bool forceall);
-static void _dma_rx_param_get(dma_info_t * di, uint16 * rxoffset,
-			      uint16 * rxbufsize);
-
-static void _dma_txblock(dma_info_t * di);
-static void _dma_txunblock(dma_info_t * di);
-static uint _dma_txactive(dma_info_t * di);
-static uint _dma_rxactive(dma_info_t * di);
-static uint _dma_txpending(dma_info_t * di);
-static uint _dma_txcommitted(dma_info_t * di);
-
-static void *_dma_peeknexttxp(dma_info_t * di);
-static void *_dma_peeknextrxp(dma_info_t * di);
-static uintptr _dma_getvar(dma_info_t * di, const char *name);
-static void _dma_counterreset(dma_info_t * di);
-static void _dma_fifoloopbackenable(dma_info_t * di);
-static uint _dma_ctrlflags(dma_info_t * di, uint mask, uint flags);
+static bool _dma_isaddrext(dma_info_t *di);
+static bool _dma_descriptor_align(dma_info_t *di);
+static bool _dma_alloc(dma_info_t *di, uint direction);
+static void _dma_detach(dma_info_t *di);
+static void _dma_ddtable_init(dma_info_t *di, uint direction, dmaaddr_t pa);
+static void _dma_rxinit(dma_info_t *di);
+static void *_dma_rx(dma_info_t *di);
+static bool _dma_rxfill(dma_info_t *di);
+static void _dma_rxreclaim(dma_info_t *di);
+static void _dma_rxenable(dma_info_t *di);
+static void *_dma_getnextrxp(dma_info_t *di, bool forceall);
+static void _dma_rx_param_get(dma_info_t *di, uint16 *rxoffset,
+			      uint16 *rxbufsize);
+
+static void _dma_txblock(dma_info_t *di);
+static void _dma_txunblock(dma_info_t *di);
+static uint _dma_txactive(dma_info_t *di);
+static uint _dma_rxactive(dma_info_t *di);
+static uint _dma_txpending(dma_info_t *di);
+static uint _dma_txcommitted(dma_info_t *di);
+
+static void *_dma_peeknexttxp(dma_info_t *di);
+static void *_dma_peeknextrxp(dma_info_t *di);
+static uintptr _dma_getvar(dma_info_t *di, const char *name);
+static void _dma_counterreset(dma_info_t *di);
+static void _dma_fifoloopbackenable(dma_info_t *di);
+static uint _dma_ctrlflags(dma_info_t *di, uint mask, uint flags);
 static uint8 dma_align_sizetobits(uint size);
-static void *dma_ringalloc(osl_t * osh, uint32 boundary, uint size,
-			   uint16 * alignbits, uint * alloced,
-			   dmaaddr_t * descpa, osldma_t ** dmah);
+static void *dma_ringalloc(osl_t *osh, uint32 boundary, uint size,
+			   uint16 *alignbits, uint *alloced,
+			   dmaaddr_t *descpa, osldma_t **dmah);
 
 /* Prototypes for 32-bit routines */
-static bool dma32_alloc(dma_info_t * di, uint direction);
-static bool dma32_txreset(dma_info_t * di);
-static bool dma32_rxreset(dma_info_t * di);
-static bool dma32_txsuspendedidle(dma_info_t * di);
-static int dma32_txfast(dma_info_t * di, void *p0, bool commit);
-static void *dma32_getnexttxp(dma_info_t * di, txd_range_t range);
-static void *dma32_getnextrxp(dma_info_t * di, bool forceall);
-static void dma32_txrotate(dma_info_t * di);
-static bool dma32_rxidle(dma_info_t * di);
-static void dma32_txinit(dma_info_t * di);
-static bool dma32_txenabled(dma_info_t * di);
-static void dma32_txsuspend(dma_info_t * di);
-static void dma32_txresume(dma_info_t * di);
-static bool dma32_txsuspended(dma_info_t * di);
-static void dma32_txreclaim(dma_info_t * di, txd_range_t range);
-static bool dma32_txstopped(dma_info_t * di);
-static bool dma32_rxstopped(dma_info_t * di);
-static bool dma32_rxenabled(dma_info_t * di);
+static bool dma32_alloc(dma_info_t *di, uint direction);
+static bool dma32_txreset(dma_info_t *di);
+static bool dma32_rxreset(dma_info_t *di);
+static bool dma32_txsuspendedidle(dma_info_t *di);
+static int dma32_txfast(dma_info_t *di, void *p0, bool commit);
+static void *dma32_getnexttxp(dma_info_t *di, txd_range_t range);
+static void *dma32_getnextrxp(dma_info_t *di, bool forceall);
+static void dma32_txrotate(dma_info_t *di);
+static bool dma32_rxidle(dma_info_t *di);
+static void dma32_txinit(dma_info_t *di);
+static bool dma32_txenabled(dma_info_t *di);
+static void dma32_txsuspend(dma_info_t *di);
+static void dma32_txresume(dma_info_t *di);
+static bool dma32_txsuspended(dma_info_t *di);
+static void dma32_txreclaim(dma_info_t *di, txd_range_t range);
+static bool dma32_txstopped(dma_info_t *di);
+static bool dma32_rxstopped(dma_info_t *di);
+static bool dma32_rxenabled(dma_info_t *di);
 
-static bool _dma32_addrext(osl_t * osh, dma32regs_t * dma32regs);
+static bool _dma32_addrext(osl_t *osh, dma32regs_t *dma32regs);
 
 /* Prototypes for 64-bit routines */
-static bool dma64_alloc(dma_info_t * di, uint direction);
-static bool dma64_txreset(dma_info_t * di);
-static bool dma64_rxreset(dma_info_t * di);
-static bool dma64_txsuspendedidle(dma_info_t * di);
-static int dma64_txfast(dma_info_t * di, void *p0, bool commit);
-static int dma64_txunframed(dma_info_t * di, void *p0, uint len, bool commit);
-static void *dma64_getpos(dma_info_t * di, bool direction);
-static void *dma64_getnexttxp(dma_info_t * di, txd_range_t range);
-static void *dma64_getnextrxp(dma_info_t * di, bool forceall);
-static void dma64_txrotate(dma_info_t * di);
-
-static bool dma64_rxidle(dma_info_t * di);
-static void dma64_txinit(dma_info_t * di);
-static bool dma64_txenabled(dma_info_t * di);
-static void dma64_txsuspend(dma_info_t * di);
-static void dma64_txresume(dma_info_t * di);
-static bool dma64_txsuspended(dma_info_t * di);
-static void dma64_txreclaim(dma_info_t * di, txd_range_t range);
-static bool dma64_txstopped(dma_info_t * di);
-static bool dma64_rxstopped(dma_info_t * di);
-static bool dma64_rxenabled(dma_info_t * di);
-static bool _dma64_addrext(osl_t * osh, dma64regs_t * dma64regs);
+static bool dma64_alloc(dma_info_t *di, uint direction);
+static bool dma64_txreset(dma_info_t *di);
+static bool dma64_rxreset(dma_info_t *di);
+static bool dma64_txsuspendedidle(dma_info_t *di);
+static int dma64_txfast(dma_info_t *di, void *p0, bool commit);
+static int dma64_txunframed(dma_info_t *di, void *p0, uint len, bool commit);
+static void *dma64_getpos(dma_info_t *di, bool direction);
+static void *dma64_getnexttxp(dma_info_t *di, txd_range_t range);
+static void *dma64_getnextrxp(dma_info_t *di, bool forceall);
+static void dma64_txrotate(dma_info_t *di);
+
+static bool dma64_rxidle(dma_info_t *di);
+static void dma64_txinit(dma_info_t *di);
+static bool dma64_txenabled(dma_info_t *di);
+static void dma64_txsuspend(dma_info_t *di);
+static void dma64_txresume(dma_info_t *di);
+static bool dma64_txsuspended(dma_info_t *di);
+static void dma64_txreclaim(dma_info_t *di, txd_range_t range);
+static bool dma64_txstopped(dma_info_t *di);
+static bool dma64_rxstopped(dma_info_t *di);
+static bool dma64_rxenabled(dma_info_t *di);
+static bool _dma64_addrext(osl_t *osh, dma64regs_t *dma64regs);
 
 STATIC INLINE uint32 parity32(uint32 data);
 
@@ -354,10 +354,10 @@ static const di_fcn_t dma32proc = {
 	39
 };
 
-hnddma_t *dma_attach(osl_t * osh, char *name, si_t * sih, void *dmaregstx,
+hnddma_t *dma_attach(osl_t *osh, char *name, si_t *sih, void *dmaregstx,
 		     void *dmaregsrx, uint ntxd, uint nrxd, uint rxbufsize,
 		     int rxextheadroom, uint nrxpost, uint rxoffset,
-		     uint * msg_level)
+		     uint *msg_level)
 {
 	dma_info_t *di;
 	uint size;
@@ -569,8 +569,8 @@ hnddma_t *dma_attach(osl_t * osh, char *
 
 /* init the tx or rx descriptor */
 static INLINE void
-dma32_dd_upd(dma_info_t * di, dma32dd_t * ddring, dmaaddr_t pa, uint outidx,
-	     uint32 * flags, uint32 bufcount)
+dma32_dd_upd(dma_info_t *di, dma32dd_t *ddring, dmaaddr_t pa, uint outidx,
+	     uint32 *flags, uint32 bufcount)
 {
 	/* dma32 uses 32-bit control to fit both flags and bufcounter */
 	*flags = *flags | (bufcount & CTRL_BC_MASK);
@@ -608,8 +608,8 @@ STATIC INLINE uint32 parity32(uint32 dat
 #define DMA64_DD_PARITY(dd)  parity32((dd)->addrlow ^ (dd)->addrhigh ^ (dd)->ctrl1 ^ (dd)->ctrl2)
 
 static INLINE void
-dma64_dd_upd(dma_info_t * di, dma64dd_t * ddring, dmaaddr_t pa, uint outidx,
-	     uint32 * flags, uint32 bufcount)
+dma64_dd_upd(dma_info_t *di, dma64dd_t *ddring, dmaaddr_t pa, uint outidx,
+	     uint32 *flags, uint32 bufcount)
 {
 	uint32 ctrl2 = bufcount & D64_CTRL2_BC_MASK;
 
@@ -653,7 +653,7 @@ dma64_dd_upd(dma_info_t * di, dma64dd_t
 	}
 }
 
-static bool _dma32_addrext(osl_t * osh, dma32regs_t * dma32regs)
+static bool _dma32_addrext(osl_t *osh, dma32regs_t *dma32regs)
 {
 	uint32 w;
 
@@ -663,7 +663,7 @@ static bool _dma32_addrext(osl_t * osh,
 	return ((w & XC_AE) == XC_AE);
 }
 
-static bool _dma_alloc(dma_info_t * di, uint direction)
+static bool _dma_alloc(dma_info_t *di, uint direction)
 {
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		return dma64_alloc(di, direction);
@@ -674,7 +674,7 @@ static bool _dma_alloc(dma_info_t * di,
 }
 
 /* !! may be called with core in reset */
-static void _dma_detach(dma_info_t * di)
+static void _dma_detach(dma_info_t *di)
 {
 
 	DMA_TRACE(("%s: dma_detach\n", di->name));
@@ -730,7 +730,7 @@ static void _dma_detach(dma_info_t * di)
 
 }
 
-static bool _dma_descriptor_align(dma_info_t * di)
+static bool _dma_descriptor_align(dma_info_t *di)
 {
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		uint32 addrl;
@@ -752,7 +752,7 @@ static bool _dma_descriptor_align(dma_in
 }
 
 /* return TRUE if this dma engine supports DmaExtendedAddrChanges, otherwise FALSE */
-static bool _dma_isaddrext(dma_info_t * di)
+static bool _dma_isaddrext(dma_info_t *di)
 {
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		/* DMA64 supports full 32- or 64-bit operation. AE is always valid */
@@ -784,7 +784,7 @@ static bool _dma_isaddrext(dma_info_t *
 }
 
 /* initialize descriptor table base address */
-static void _dma_ddtable_init(dma_info_t * di, uint direction, dmaaddr_t pa)
+static void _dma_ddtable_init(dma_info_t *di, uint direction, dmaaddr_t pa)
 {
 	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
 		if (!di->aligndesc_4k) {
@@ -871,7 +871,7 @@ static void _dma_ddtable_init(dma_info_t
 		ASSERT(0);
 }
 
-static void _dma_fifoloopbackenable(dma_info_t * di)
+static void _dma_fifoloopbackenable(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_fifoloopbackenable\n", di->name));
 
@@ -883,7 +883,7 @@ static void _dma_fifoloopbackenable(dma_
 		ASSERT(0);
 }
 
-static void _dma_rxinit(dma_info_t * di)
+static void _dma_rxinit(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_rxinit\n", di->name));
 
@@ -916,7 +916,7 @@ static void _dma_rxinit(dma_info_t * di)
 		ASSERT(0);
 }
 
-static void _dma_rxenable(dma_info_t * di)
+static void _dma_rxenable(dma_info_t *di)
 {
 	uint dmactrlflags = di->hnddma.dmactrlflags;
 
@@ -952,7 +952,7 @@ static void _dma_rxenable(dma_info_t * d
 }
 
 static void
-_dma_rx_param_get(dma_info_t * di, uint16 * rxoffset, uint16 * rxbufsize)
+_dma_rx_param_get(dma_info_t *di, uint16 *rxoffset, uint16 *rxbufsize)
 {
 	/* the normal values fit into 16 bits */
 	*rxoffset = (uint16) di->rxoffset;
@@ -968,7 +968,7 @@ _dma_rx_param_get(dma_info_t * di, uint1
  *   After it reaches the max size of buffer, the data continues in next DMA descriptor
  *   buffer WITHOUT DMA header
  */
-static void *BCMFASTPATH _dma_rx(dma_info_t * di)
+static void *BCMFASTPATH _dma_rx(dma_info_t *di)
 {
 	void *p, *head, *tail;
 	uint len;
@@ -1043,7 +1043,7 @@ static void *BCMFASTPATH _dma_rx(dma_inf
  *  this will stall the rx dma and user might want to call rxfill again asap
  *  This unlikely happens on memory-rich NIC, but often on memory-constrained dongle
  */
-static bool BCMFASTPATH _dma_rxfill(dma_info_t * di)
+static bool BCMFASTPATH _dma_rxfill(dma_info_t *di)
 {
 	void *p;
 	uint16 rxin, rxout;
@@ -1155,7 +1155,7 @@ static bool BCMFASTPATH _dma_rxfill(dma_
 }
 
 /* like getnexttxp but no reclaim */
-static void *_dma_peeknexttxp(dma_info_t * di)
+static void *_dma_peeknexttxp(dma_info_t *di)
 {
 	uint end, i;
 
@@ -1182,7 +1182,7 @@ static void *_dma_peeknexttxp(dma_info_t
 }
 
 /* like getnextrxp but not take off the ring */
-static void *_dma_peeknextrxp(dma_info_t * di)
+static void *_dma_peeknextrxp(dma_info_t *di)
 {
 	uint end, i;
 
@@ -1208,7 +1208,7 @@ static void *_dma_peeknextrxp(dma_info_t
 	return (NULL);
 }
 
-static void _dma_rxreclaim(dma_info_t * di)
+static void _dma_rxreclaim(dma_info_t *di)
 {
 	void *p;
 
@@ -1223,7 +1223,7 @@ static void _dma_rxreclaim(dma_info_t *
 		PKTFREE(di->osh, p, FALSE);
 }
 
-static void *BCMFASTPATH _dma_getnextrxp(dma_info_t * di, bool forceall)
+static void *BCMFASTPATH _dma_getnextrxp(dma_info_t *di, bool forceall)
 {
 	if (di->nrxd == 0)
 		return (NULL);
@@ -1236,22 +1236,22 @@ static void *BCMFASTPATH _dma_getnextrxp
 		ASSERT(0);
 }
 
-static void _dma_txblock(dma_info_t * di)
+static void _dma_txblock(dma_info_t *di)
 {
 	di->hnddma.txavail = 0;
 }
 
-static void _dma_txunblock(dma_info_t * di)
+static void _dma_txunblock(dma_info_t *di)
 {
 	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
 }
 
-static uint _dma_txactive(dma_info_t * di)
+static uint _dma_txactive(dma_info_t *di)
 {
 	return NTXDACTIVE(di->txin, di->txout);
 }
 
-static uint _dma_txpending(dma_info_t * di)
+static uint _dma_txpending(dma_info_t *di)
 {
 	uint curr;
 
@@ -1270,7 +1270,7 @@ static uint _dma_txpending(dma_info_t *
 	return NTXDACTIVE(curr, di->txout);
 }
 
-static uint _dma_txcommitted(dma_info_t * di)
+static uint _dma_txcommitted(dma_info_t *di)
 {
 	uint ptr;
 	uint txin = di->txin;
@@ -1288,12 +1288,12 @@ static uint _dma_txcommitted(dma_info_t
 	return NTXDACTIVE(di->txin, ptr);
 }
 
-static uint _dma_rxactive(dma_info_t * di)
+static uint _dma_rxactive(dma_info_t *di)
 {
 	return NRXDACTIVE(di->rxin, di->rxout);
 }
 
-static void _dma_counterreset(dma_info_t * di)
+static void _dma_counterreset(dma_info_t *di)
 {
 	/* reset all software counter */
 	di->hnddma.rxgiants = 0;
@@ -1301,7 +1301,7 @@ static void _dma_counterreset(dma_info_t
 	di->hnddma.txnobuf = 0;
 }
 
-static uint _dma_ctrlflags(dma_info_t * di, uint mask, uint flags)
+static uint _dma_ctrlflags(dma_info_t *di, uint mask, uint flags)
 {
 	uint dmactrlflags = di->hnddma.dmactrlflags;
 
@@ -1354,7 +1354,7 @@ static uint _dma_ctrlflags(dma_info_t *
 }
 
 /* get the address of the var in order to change later */
-static uintptr _dma_getvar(dma_info_t * di, const char *name)
+static uintptr _dma_getvar(dma_info_t *di, const char *name)
 {
 	if (!strcmp(name, "&txavail"))
 		return ((uintptr) & (di->hnddma.txavail));
@@ -1364,7 +1364,7 @@ static uintptr _dma_getvar(dma_info_t *
 	return (0);
 }
 
-void dma_txpioloopback(osl_t * osh, dma32regs_t * regs)
+void dma_txpioloopback(osl_t *osh, dma32regs_t *regs)
 {
 	OR_REG(osh, &regs->control, XC_LE);
 }
@@ -1387,9 +1387,9 @@ uint8 dma_align_sizetobits(uint size)
  * descriptor ring size aligned location. This will ensure that the ring will
  * not cross page boundary
  */
-static void *dma_ringalloc(osl_t * osh, uint32 boundary, uint size,
-			   uint16 * alignbits, uint * alloced,
-			   dmaaddr_t * descpa, osldma_t ** dmah)
+static void *dma_ringalloc(osl_t *osh, uint32 boundary, uint size,
+			   uint16 *alignbits, uint *alloced,
+			   dmaaddr_t *descpa, osldma_t **dmah)
 {
 	void *va;
 	uint32 desc_strtaddr;
@@ -1414,7 +1414,7 @@ static void *dma_ringalloc(osl_t * osh,
 
 /* 32-bit DMA functions */
 
-static void dma32_txinit(dma_info_t * di)
+static void dma32_txinit(dma_info_t *di)
 {
 	uint32 control = XC_XE;
 
@@ -1435,7 +1435,7 @@ static void dma32_txinit(dma_info_t * di
 	_dma_ddtable_init(di, DMA_TX, di->txdpa);
 }
 
-static bool dma32_txenabled(dma_info_t * di)
+static bool dma32_txenabled(dma_info_t *di)
 {
 	uint32 xc;
 
@@ -1444,7 +1444,7 @@ static bool dma32_txenabled(dma_info_t *
 	return ((xc != 0xffffffff) && (xc & XC_XE));
 }
 
-static void dma32_txsuspend(dma_info_t * di)
+static void dma32_txsuspend(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_txsuspend\n", di->name));
 
@@ -1454,7 +1454,7 @@ static void dma32_txsuspend(dma_info_t *
 	OR_REG(di->osh, &di->d32txregs->control, XC_SE);
 }
 
-static void dma32_txresume(dma_info_t * di)
+static void dma32_txresume(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_txresume\n", di->name));
 
@@ -1464,13 +1464,13 @@ static void dma32_txresume(dma_info_t *
 	AND_REG(di->osh, &di->d32txregs->control, ~XC_SE);
 }
 
-static bool dma32_txsuspended(dma_info_t * di)
+static bool dma32_txsuspended(dma_info_t *di)
 {
 	return (di->ntxd == 0)
 	    || ((R_REG(di->osh, &di->d32txregs->control) & XC_SE) == XC_SE);
 }
 
-static void dma32_txreclaim(dma_info_t * di, txd_range_t range)
+static void dma32_txreclaim(dma_info_t *di, txd_range_t range)
 {
 	void *p;
 
@@ -1487,19 +1487,19 @@ static void dma32_txreclaim(dma_info_t *
 		PKTFREE(di->osh, p, TRUE);
 }
 
-static bool dma32_txstopped(dma_info_t * di)
+static bool dma32_txstopped(dma_info_t *di)
 {
 	return ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) ==
 		XS_XS_STOPPED);
 }
 
-static bool dma32_rxstopped(dma_info_t * di)
+static bool dma32_rxstopped(dma_info_t *di)
 {
 	return ((R_REG(di->osh, &di->d32rxregs->status) & RS_RS_MASK) ==
 		RS_RS_STOPPED);
 }
 
-static bool dma32_alloc(dma_info_t * di, uint direction)
+static bool dma32_alloc(dma_info_t *di, uint direction)
 {
 	uint size;
 	uint ddlen;
@@ -1564,7 +1564,7 @@ static bool dma32_alloc(dma_info_t * di,
 	return TRUE;
 }
 
-static bool dma32_txreset(dma_info_t * di)
+static bool dma32_txreset(dma_info_t *di)
 {
 	uint32 status;
 
@@ -1589,7 +1589,7 @@ static bool dma32_txreset(dma_info_t * d
 	return (status == XS_XS_DISABLED);
 }
 
-static bool dma32_rxidle(dma_info_t * di)
+static bool dma32_rxidle(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_rxidle\n", di->name));
 
@@ -1600,7 +1600,7 @@ static bool dma32_rxidle(dma_info_t * di
 		R_REG(di->osh, &di->d32rxregs->ptr));
 }
 
-static bool dma32_rxreset(dma_info_t * di)
+static bool dma32_rxreset(dma_info_t *di)
 {
 	uint32 status;
 
@@ -1615,7 +1615,7 @@ static bool dma32_rxreset(dma_info_t * d
 	return (status == RS_RS_DISABLED);
 }
 
-static bool dma32_rxenabled(dma_info_t * di)
+static bool dma32_rxenabled(dma_info_t *di)
 {
 	uint32 rc;
 
@@ -1623,7 +1623,7 @@ static bool dma32_rxenabled(dma_info_t *
 	return ((rc != 0xffffffff) && (rc & RC_RE));
 }
 
-static bool dma32_txsuspendedidle(dma_info_t * di)
+static bool dma32_txsuspendedidle(dma_info_t *di)
 {
 	if (di->ntxd == 0)
 		return TRUE;
@@ -1646,7 +1646,7 @@ static bool dma32_txsuspendedidle(dma_in
  * WARNING: call must check the return value for error.
  *   the error(toss frames) could be fatal and cause many subsequent hard to debug problems
  */
-static int dma32_txfast(dma_info_t * di, void *p0, bool commit)
+static int dma32_txfast(dma_info_t *di, void *p0, bool commit)
 {
 	void *p, *next;
 	uchar *data;
@@ -1772,7 +1772,7 @@ static int dma32_txfast(dma_info_t * di,
  * If range is HNDDMA_RANGE_ALL, reclaim all txd(s) posted to the ring and
  * return associated packet regardless of the value of hardware pointers.
  */
-static void *dma32_getnexttxp(dma_info_t * di, txd_range_t range)
+static void *dma32_getnexttxp(dma_info_t *di, txd_range_t range)
 {
 	uint16 start, end, i;
 	uint16 active_desc;
@@ -1857,7 +1857,7 @@ static void *dma32_getnexttxp(dma_info_t
 	return (NULL);
 }
 
-static void *dma32_getnextrxp(dma_info_t * di, bool forceall)
+static void *dma32_getnextrxp(dma_info_t *di, bool forceall)
 {
 	uint i, curr;
 	void *rxp;
@@ -1901,7 +1901,7 @@ static void *dma32_getnextrxp(dma_info_t
 /*
  * Rotate all active tx dma ring entries "forward" by (ActiveDescriptor - txin).
  */
-static void dma32_txrotate(dma_info_t * di)
+static void dma32_txrotate(dma_info_t *di)
 {
 	uint16 ad;
 	uint nactive;
@@ -1971,7 +1971,7 @@ static void dma32_txrotate(dma_info_t *
 
 /* 64-bit DMA functions */
 
-static void dma64_txinit(dma_info_t * di)
+static void dma64_txinit(dma_info_t *di)
 {
 	uint32 control = D64_XC_XE;
 
@@ -2003,7 +2003,7 @@ static void dma64_txinit(dma_info_t * di
 		_dma_ddtable_init(di, DMA_TX, di->txdpa);
 }
 
-static bool dma64_txenabled(dma_info_t * di)
+static bool dma64_txenabled(dma_info_t *di)
 {
 	uint32 xc;
 
@@ -2012,7 +2012,7 @@ static bool dma64_txenabled(dma_info_t *
 	return ((xc != 0xffffffff) && (xc & D64_XC_XE));
 }
 
-static void dma64_txsuspend(dma_info_t * di)
+static void dma64_txsuspend(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_txsuspend\n", di->name));
 
@@ -2022,7 +2022,7 @@ static void dma64_txsuspend(dma_info_t *
 	OR_REG(di->osh, &di->d64txregs->control, D64_XC_SE);
 }
 
-static void dma64_txresume(dma_info_t * di)
+static void dma64_txresume(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_txresume\n", di->name));
 
@@ -2032,14 +2032,14 @@ static void dma64_txresume(dma_info_t *
 	AND_REG(di->osh, &di->d64txregs->control, ~D64_XC_SE);
 }
 
-static bool dma64_txsuspended(dma_info_t * di)
+static bool dma64_txsuspended(dma_info_t *di)
 {
 	return (di->ntxd == 0) ||
 	    ((R_REG(di->osh, &di->d64txregs->control) & D64_XC_SE) ==
 	     D64_XC_SE);
 }
 
-static void BCMFASTPATH dma64_txreclaim(dma_info_t * di, txd_range_t range)
+static void BCMFASTPATH dma64_txreclaim(dma_info_t *di, txd_range_t range)
 {
 	void *p;
 
@@ -2059,19 +2059,19 @@ static void BCMFASTPATH dma64_txreclaim(
 	}
 }
 
-static bool dma64_txstopped(dma_info_t * di)
+static bool dma64_txstopped(dma_info_t *di)
 {
 	return ((R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK) ==
 		D64_XS0_XS_STOPPED);
 }
 
-static bool dma64_rxstopped(dma_info_t * di)
+static bool dma64_rxstopped(dma_info_t *di)
 {
 	return ((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_RS_MASK) ==
 		D64_RS0_RS_STOPPED);
 }
 
-static bool dma64_alloc(dma_info_t * di, uint direction)
+static bool dma64_alloc(dma_info_t *di, uint direction)
 {
 	uint16 size;
 	uint ddlen;
@@ -2131,7 +2131,7 @@ static bool dma64_alloc(dma_info_t * di,
 	return TRUE;
 }
 
-static bool dma64_txreset(dma_info_t * di)
+static bool dma64_txreset(dma_info_t *di)
 {
 	uint32 status;
 
@@ -2156,7 +2156,7 @@ static bool dma64_txreset(dma_info_t * d
 	return (status == D64_XS0_XS_DISABLED);
 }
 
-static bool dma64_rxidle(dma_info_t * di)
+static bool dma64_rxidle(dma_info_t *di)
 {
 	DMA_TRACE(("%s: dma_rxidle\n", di->name));
 
@@ -2167,7 +2167,7 @@ static bool dma64_rxidle(dma_info_t * di
 		(R_REG(di->osh, &di->d64rxregs->ptr) & D64_RS0_CD_MASK));
 }
 
-static bool dma64_rxreset(dma_info_t * di)
+static bool dma64_rxreset(dma_info_t *di)
 {
 	uint32 status;
 
@@ -2182,7 +2182,7 @@ static bool dma64_rxreset(dma_info_t * d
 	return (status == D64_RS0_RS_DISABLED);
 }
 
-static bool dma64_rxenabled(dma_info_t * di)
+static bool dma64_rxenabled(dma_info_t *di)
 {
 	uint32 rc;
 
@@ -2190,7 +2190,7 @@ static bool dma64_rxenabled(dma_info_t *
 	return ((rc != 0xffffffff) && (rc & D64_RC_RE));
 }
 
-static bool dma64_txsuspendedidle(dma_info_t * di)
+static bool dma64_txsuspendedidle(dma_info_t *di)
 {
 
 	if (di->ntxd == 0)
@@ -2210,7 +2210,7 @@ static bool dma64_txsuspendedidle(dma_in
  * We return a pointer to the beginning of the DATA buffer of the current descriptor.
  * If DMA is idle, we return NULL.
  */
-static void *dma64_getpos(dma_info_t * di, bool direction)
+static void *dma64_getpos(dma_info_t *di, bool direction)
 {
 	void *va;
 	bool idle;
@@ -2245,7 +2245,7 @@ static void *dma64_getpos(dma_info_t * d
  * Each call to this is results in a single descriptor being added for "len" bytes of
  * data starting at "buf", it doesn't handle chained buffers.
  */
-static int dma64_txunframed(dma_info_t * di, void *buf, uint len, bool commit)
+static int dma64_txunframed(dma_info_t *di, void *buf, uint len, bool commit)
 {
 	uint16 txout;
 	uint32 flags = 0;
@@ -2299,7 +2299,7 @@ static int dma64_txunframed(dma_info_t *
  * WARNING: call must check the return value for error.
  *   the error(toss frames) could be fatal and cause many subsequent hard to debug problems
  */
-static int BCMFASTPATH dma64_txfast(dma_info_t * di, void *p0, bool commit)
+static int BCMFASTPATH dma64_txfast(dma_info_t *di, void *p0, bool commit)
 {
 	void *p, *next;
 	uchar *data;
@@ -2424,7 +2424,7 @@ static int BCMFASTPATH dma64_txfast(dma_
  * If range is HNDDMA_RANGE_ALL, reclaim all txd(s) posted to the ring and
  * return associated packet regardless of the value of hardware pointers.
  */
-static void *BCMFASTPATH dma64_getnexttxp(dma_info_t * di, txd_range_t range)
+static void *BCMFASTPATH dma64_getnexttxp(dma_info_t *di, txd_range_t range)
 {
 	uint16 start, end, i;
 	uint16 active_desc;
@@ -2516,7 +2516,7 @@ static void *BCMFASTPATH dma64_getnexttx
 	return (NULL);
 }
 
-static void *BCMFASTPATH dma64_getnextrxp(dma_info_t * di, bool forceall)
+static void *BCMFASTPATH dma64_getnextrxp(dma_info_t *di, bool forceall)
 {
 	uint i, curr;
 	void *rxp;
@@ -2562,7 +2562,7 @@ static void *BCMFASTPATH dma64_getnextrx
 	return (rxp);
 }
 
-static bool _dma64_addrext(osl_t * osh, dma64regs_t * dma64regs)
+static bool _dma64_addrext(osl_t *osh, dma64regs_t * dma64regs)
 {
 	uint32 w;
 	OR_REG(osh, &dma64regs->control, D64_XC_AE);
@@ -2574,7 +2574,7 @@ static bool _dma64_addrext(osl_t * osh,
 /*
  * Rotate all active tx dma ring entries "forward" by (ActiveDescriptor - txin).
  */
-static void dma64_txrotate(dma_info_t * di)
+static void dma64_txrotate(dma_info_t *di)
 {
 	uint16 ad;
 	uint nactive;
@@ -2650,7 +2650,7 @@ static void dma64_txrotate(dma_info_t *
 	      di->xmtptrbase + I2B(di->txout, dma64dd_t));
 }
 
-uint dma_addrwidth(si_t * sih, void *dmaregs)
+uint dma_addrwidth(si_t *sih, void *dmaregs)
 {
 	dma32regs_t *dma32regs;
 	osl_t *osh;
--- a/drivers/staging/brcm80211/util/hndpmu.c
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -39,25 +39,25 @@
 #define	PMU_NONE(args)
 
 /* PLL controls/clocks */
-static void si_pmu1_pllinit0(si_t * sih, osl_t * osh, chipcregs_t * cc,
+static void si_pmu1_pllinit0(si_t *sih, osl_t *osh, chipcregs_t *cc,
 			     uint32 xtal);
-static uint32 si_pmu1_cpuclk0(si_t * sih, osl_t * osh, chipcregs_t * cc);
-static uint32 si_pmu1_alpclk0(si_t * sih, osl_t * osh, chipcregs_t * cc);
+static uint32 si_pmu1_cpuclk0(si_t *sih, osl_t *osh, chipcregs_t *cc);
+static uint32 si_pmu1_alpclk0(si_t *sih, osl_t *osh, chipcregs_t *cc);
 
 /* PMU resources */
-static bool si_pmu_res_depfltr_bb(si_t * sih);
-static bool si_pmu_res_depfltr_ncb(si_t * sih);
-static bool si_pmu_res_depfltr_paldo(si_t * sih);
-static bool si_pmu_res_depfltr_npaldo(si_t * sih);
-static uint32 si_pmu_res_deps(si_t * sih, osl_t * osh, chipcregs_t * cc,
+static bool si_pmu_res_depfltr_bb(si_t *sih);
+static bool si_pmu_res_depfltr_ncb(si_t *sih);
+static bool si_pmu_res_depfltr_paldo(si_t *sih);
+static bool si_pmu_res_depfltr_npaldo(si_t *sih);
+static uint32 si_pmu_res_deps(si_t *sih, osl_t *osh, chipcregs_t *cc,
 			      uint32 rsrcs, bool all);
-static uint si_pmu_res_uptime(si_t * sih, osl_t * osh, chipcregs_t * cc,
+static uint si_pmu_res_uptime(si_t *sih, osl_t *osh, chipcregs_t *cc,
 			      uint8 rsrc);
-static void si_pmu_res_masks(si_t * sih, uint32 * pmin, uint32 * pmax);
-static void si_pmu_spuravoid_pllupdate(si_t * sih, chipcregs_t * cc,
-				       osl_t * osh, uint8 spuravoid);
+static void si_pmu_res_masks(si_t *sih, uint32 * pmin, uint32 * pmax);
+static void si_pmu_spuravoid_pllupdate(si_t *sih, chipcregs_t *cc,
+				       osl_t *osh, uint8 spuravoid);
 
-static void si_pmu_set_4330_plldivs(si_t * sih);
+static void si_pmu_set_4330_plldivs(si_t *sih);
 
 /* FVCO frequency */
 #define FVCO_880	880000	/* 880MHz */
@@ -66,7 +66,7 @@ static void si_pmu_set_4330_plldivs(si_t
 #define FVCO_960	960000	/* 960MHz */
 
 /* Read/write a chipcontrol reg */
-uint32 si_pmu_chipcontrol(si_t * sih, uint reg, uint32 mask, uint32 val)
+uint32 si_pmu_chipcontrol(si_t *sih, uint reg, uint32 mask, uint32 val)
 {
 	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol_addr), ~0,
 		   reg);
@@ -75,7 +75,7 @@ uint32 si_pmu_chipcontrol(si_t * sih, ui
 }
 
 /* Read/write a regcontrol reg */
-uint32 si_pmu_regcontrol(si_t * sih, uint reg, uint32 mask, uint32 val)
+uint32 si_pmu_regcontrol(si_t *sih, uint reg, uint32 mask, uint32 val)
 {
 	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_addr), ~0,
 		   reg);
@@ -84,7 +84,7 @@ uint32 si_pmu_regcontrol(si_t * sih, uin
 }
 
 /* Read/write a pllcontrol reg */
-uint32 si_pmu_pllcontrol(si_t * sih, uint reg, uint32 mask, uint32 val)
+uint32 si_pmu_pllcontrol(si_t *sih, uint reg, uint32 mask, uint32 val)
 {
 	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pllcontrol_addr), ~0,
 		   reg);
@@ -93,7 +93,7 @@ uint32 si_pmu_pllcontrol(si_t * sih, uin
 }
 
 /* PMU PLL update */
-void si_pmu_pllupd(si_t * sih)
+void si_pmu_pllupd(si_t *sih)
 {
 	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pmucontrol),
 		   PCTL_PLL_PLLCTL_UPD, PCTL_PLL_PLLCTL_UPD);
@@ -101,7 +101,7 @@ void si_pmu_pllupd(si_t * sih)
 
 /* Setup switcher voltage */
 void
-BCMATTACHFN(si_pmu_set_switcher_voltage) (si_t * sih, osl_t * osh,
+BCMATTACHFN(si_pmu_set_switcher_voltage) (si_t *sih, osl_t *osh,
 					  uint8 bb_voltage, uint8 rf_voltage) {
 	chipcregs_t *cc;
 	uint origidx;
@@ -124,7 +124,7 @@ BCMATTACHFN(si_pmu_set_switcher_voltage)
 }
 
 void
-BCMATTACHFN(si_pmu_set_ldo_voltage) (si_t * sih, osl_t * osh, uint8 ldo,
+BCMATTACHFN(si_pmu_set_ldo_voltage) (si_t *sih, osl_t *osh, uint8 ldo,
 				     uint8 voltage) {
 	uint8 sr_cntl_shift = 0, rc_shift = 0, shift = 0, mask = 0;
 	uint8 addr = 0;
@@ -182,7 +182,7 @@ BCMATTACHFN(si_pmu_set_ldo_voltage) (si_
 /* d11 slow to fast clock transition time in slow clock cycles */
 #define D11SCC_SLOW2FAST_TRANSITION	2
 
-uint16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t * sih, osl_t * osh) {
+uint16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t *sih, osl_t *osh) {
 	uint delay = PMU_MAX_TRANSITION_DLY;
 	chipcregs_t *cc;
 	uint origidx;
@@ -258,7 +258,7 @@ uint16 BCMINITFN(si_pmu_fast_pwrup_delay
 	return (uint16) delay;
 }
 
-uint32 BCMATTACHFN(si_pmu_force_ilp) (si_t * sih, osl_t * osh, bool force) {
+uint32 BCMATTACHFN(si_pmu_force_ilp) (si_t *sih, osl_t *osh, bool force) {
 	chipcregs_t *cc;
 	uint origidx;
 	uint32 oldpmucontrol;
@@ -295,7 +295,7 @@ typedef struct {
 	uint32 res_mask;	/* resources (chip specific) */
 	int8 action;		/* action */
 	uint32 depend_mask;	/* changes to the dependancies mask */
-	 bool(*filter) (si_t * sih);	/* action is taken when filter is NULL or return TRUE */
+	 bool(*filter) (si_t *sih);	/* action is taken when filter is NULL or return TRUE */
 } pmu_res_depend_t;
 
 /* Resource dependancies mask change action */
@@ -578,23 +578,23 @@ static const pmu_res_depend_t BCMATTACHD
 };
 
 /* TRUE if the power topology uses the buck boost to provide 3.3V to VDDIO_RF and WLAN PA */
-static bool BCMATTACHFN(si_pmu_res_depfltr_bb) (si_t * sih) {
+static bool BCMATTACHFN(si_pmu_res_depfltr_bb) (si_t *sih) {
 	return (sih->boardflags & BFL_BUCKBOOST) != 0;
 }
 
 /* TRUE if the power topology doesn't use the cbuck. Key on chiprev also if the chip is BCM4325. */
-static bool BCMATTACHFN(si_pmu_res_depfltr_ncb) (si_t * sih) {
+static bool BCMATTACHFN(si_pmu_res_depfltr_ncb) (si_t *sih) {
 
 	return ((sih->boardflags & BFL_NOCBUCK) != 0);
 }
 
 /* TRUE if the power topology uses the PALDO */
-static bool BCMATTACHFN(si_pmu_res_depfltr_paldo) (si_t * sih) {
+static bool BCMATTACHFN(si_pmu_res_depfltr_paldo) (si_t *sih) {
 	return (sih->boardflags & BFL_PALDO) != 0;
 }
 
 /* TRUE if the power topology doesn't use the PALDO */
-static bool BCMATTACHFN(si_pmu_res_depfltr_npaldo) (si_t * sih) {
+static bool BCMATTACHFN(si_pmu_res_depfltr_npaldo) (si_t *sih) {
 	return (sih->boardflags & BFL_PALDO) == 0;
 }
 
@@ -602,7 +602,7 @@ static bool BCMATTACHFN(si_pmu_res_depfl
 					sih->boardtype == BCM94325BGABU_BOARD)
 
 /* Determine min/max rsrc masks. Value 0 leaves hardware at default. */
-static void si_pmu_res_masks(si_t * sih, uint32 * pmin, uint32 * pmax)
+static void si_pmu_res_masks(si_t *sih, uint32 * pmin, uint32 * pmax)
 {
 	uint32 min_mask = 0, max_mask = 0;
 	uint rsrcs;
@@ -688,7 +688,7 @@ static void si_pmu_res_masks(si_t * sih,
 }
 
 /* initialize PMU resources */
-void BCMATTACHFN(si_pmu_res_init) (si_t * sih, osl_t * osh) {
+void BCMATTACHFN(si_pmu_res_init) (si_t *sih, osl_t *osh) {
 	chipcregs_t *cc;
 	uint origidx;
 	const pmu_res_updown_t *pmu_res_updown_table = NULL;
@@ -1104,7 +1104,7 @@ static const pmu1_xtaltab0_t BCMINITDATA
 #define PMU1_XTALTAB0_960_48000K	15
 
 /* select xtal table for each chip */
-static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaltab0) (si_t * sih) {
+static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaltab0) (si_t *sih) {
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1130,7 +1130,7 @@ static const pmu1_xtaltab0_t *BCMINITFN(
 }
 
 /* select default xtal frequency for each chip */
-static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaldef0) (si_t * sih) {
+static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaldef0) (si_t *sih) {
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1161,7 +1161,7 @@ static const pmu1_xtaltab0_t *BCMINITFN(
 }
 
 /* select default pll fvco for each chip */
-static uint32 BCMINITFN(si_pmu1_pllfvco0) (si_t * sih) {
+static uint32 BCMINITFN(si_pmu1_pllfvco0) (si_t *sih) {
 #ifdef BCMDBG
 	char chn[8];
 #endif
@@ -1189,7 +1189,7 @@ static uint32 BCMINITFN(si_pmu1_pllfvco0
 
 /* query alp/xtal clock frequency */
 static uint32
-BCMINITFN(si_pmu1_alpclk0) (si_t * sih, osl_t * osh, chipcregs_t * cc) {
+BCMINITFN(si_pmu1_alpclk0) (si_t *sih, osl_t *osh, chipcregs_t *cc) {
 	const pmu1_xtaltab0_t *xt;
 	uint32 xf;
 
@@ -1214,7 +1214,7 @@ BCMINITFN(si_pmu1_alpclk0) (si_t * sih,
  * si_pmu1_xtaldef0() wherever it is needed to return a default value.
  */
 static void
-BCMATTACHFN(si_pmu1_pllinit0) (si_t * sih, osl_t * osh, chipcregs_t * cc,
+BCMATTACHFN(si_pmu1_pllinit0) (si_t *sih, osl_t *osh, chipcregs_t *cc,
 			       uint32 xtal) {
 	const pmu1_xtaltab0_t *xt;
 	uint32 tmp;
@@ -1459,7 +1459,7 @@ BCMATTACHFN(si_pmu1_pllinit0) (si_t * si
 
 /* query the CPU clock frequency */
 static uint32
-BCMINITFN(si_pmu1_cpuclk0) (si_t * sih, osl_t * osh, chipcregs_t * cc) {
+BCMINITFN(si_pmu1_cpuclk0) (si_t *sih, osl_t *osh, chipcregs_t *cc) {
 	uint32 tmp, m1div;
 #ifdef BCMDBG
 	uint32 ndiv_int, ndiv_frac, p2div, p1div, fvco;
@@ -1512,7 +1512,7 @@ BCMINITFN(si_pmu1_cpuclk0) (si_t * sih,
 }
 
 /* initialize PLL */
-void BCMATTACHFN(si_pmu_pll_init) (si_t * sih, osl_t * osh, uint xtalfreq) {
+void BCMATTACHFN(si_pmu_pll_init) (si_t *sih, osl_t *osh, uint xtalfreq) {
 	chipcregs_t *cc;
 	uint origidx;
 #ifdef BCMDBG
@@ -1564,7 +1564,7 @@ void BCMATTACHFN(si_pmu_pll_init) (si_t
 }
 
 /* query alp/xtal clock frequency */
-uint32 BCMINITFN(si_pmu_alp_clock) (si_t * sih, osl_t * osh) {
+uint32 BCMINITFN(si_pmu_alp_clock) (si_t *sih, osl_t *osh) {
 	chipcregs_t *cc;
 	uint origidx;
 	uint32 clock = ALP_CLOCK;
@@ -1624,7 +1624,7 @@ uint32 BCMINITFN(si_pmu_alp_clock) (si_t
  * pllreg "pll0" i.e. 12 for main 6 for phy, 0 for misc.
  */
 static uint32
-BCMINITFN(si_pmu5_clock) (si_t * sih, osl_t * osh, chipcregs_t * cc, uint pll0,
+BCMINITFN(si_pmu5_clock) (si_t *sih, osl_t *osh, chipcregs_t *cc, uint pll0,
 			  uint m) {
 	uint32 tmp, div, ndiv, p1, p2, fc;
 
@@ -1677,7 +1677,7 @@ BCMINITFN(si_pmu5_clock) (si_t * sih, os
 /* For designs that feed the same clock to both backplane
  * and CPU just return the CPU clock speed.
  */
-uint32 BCMINITFN(si_pmu_si_clock) (si_t * sih, osl_t * osh) {
+uint32 BCMINITFN(si_pmu_si_clock) (si_t *sih, osl_t *osh) {
 	chipcregs_t *cc;
 	uint origidx;
 	uint32 clock = HT_CLOCK;
@@ -1755,7 +1755,7 @@ uint32 BCMINITFN(si_pmu_si_clock) (si_t
 }
 
 /* query CPU clock frequency */
-uint32 BCMINITFN(si_pmu_cpu_clock) (si_t * sih, osl_t * osh) {
+uint32 BCMINITFN(si_pmu_cpu_clock) (si_t *sih, osl_t *osh) {
 	chipcregs_t *cc;
 	uint origidx;
 	uint32 clock;
@@ -1798,7 +1798,7 @@ uint32 BCMINITFN(si_pmu_cpu_clock) (si_t
 }
 
 /* query memory clock frequency */
-uint32 BCMINITFN(si_pmu_mem_clock) (si_t * sih, osl_t * osh) {
+uint32 BCMINITFN(si_pmu_mem_clock) (si_t *sih, osl_t *osh) {
 	chipcregs_t *cc;
 	uint origidx;
 	uint32 clock;
@@ -1846,7 +1846,7 @@ uint32 BCMINITFN(si_pmu_mem_clock) (si_t
 
 static uint32 ilpcycles_per_sec = 0;
 
-uint32 BCMINITFN(si_pmu_ilp_clock) (si_t * sih, osl_t * osh) {
+uint32 BCMINITFN(si_pmu_ilp_clock) (si_t *sih, osl_t *osh) {
 	if (ISSIM_ENAB(sih))
 		return ILP_CLOCK;
 
@@ -1909,7 +1909,7 @@ static const sdiod_drive_str_t BCMINITDA
 #define SDIOD_DRVSTR_KEY(chip, pmu)	(((chip) << 16) | (pmu))
 
 void
-BCMINITFN(si_sdiod_drive_strength_init) (si_t * sih, osl_t * osh,
+BCMINITFN(si_sdiod_drive_strength_init) (si_t *sih, osl_t *osh,
 					 uint32 drivestrength) {
 	chipcregs_t *cc;
 	uint origidx, intr_val = 0;
@@ -1969,7 +1969,7 @@ BCMINITFN(si_sdiod_drive_strength_init)
 }
 
 /* initialize PMU */
-void BCMATTACHFN(si_pmu_init) (si_t * sih, osl_t * osh) {
+void BCMATTACHFN(si_pmu_init) (si_t *sih, osl_t *osh) {
 	chipcregs_t *cc;
 	uint origidx;
 
@@ -2000,7 +2000,7 @@ void BCMATTACHFN(si_pmu_init) (si_t * si
 
 /* Return up time in ILP cycles for the given resource. */
 static uint
-BCMINITFN(si_pmu_res_uptime) (si_t * sih, osl_t * osh, chipcregs_t * cc,
+BCMINITFN(si_pmu_res_uptime) (si_t *sih, osl_t *osh, chipcregs_t *cc,
 			      uint8 rsrc) {
 	uint32 deps;
 	uint up, i, dup, dmax;
@@ -2037,7 +2037,7 @@ BCMINITFN(si_pmu_res_uptime) (si_t * sih
 
 /* Return dependancies (direct or all/indirect) for the given resources */
 static uint32
-si_pmu_res_deps(si_t * sih, osl_t * osh, chipcregs_t * cc, uint32 rsrcs,
+si_pmu_res_deps(si_t *sih, osl_t *osh, chipcregs_t *cc, uint32 rsrcs,
 		bool all)
 {
 	uint32 deps = 0;
@@ -2057,7 +2057,7 @@ si_pmu_res_deps(si_t * sih, osl_t * osh,
 }
 
 /* power up/down OTP through PMU resources */
-void si_pmu_otp_power(si_t * sih, osl_t * osh, bool on)
+void si_pmu_otp_power(si_t *sih, osl_t *osh, bool on)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -2127,7 +2127,7 @@ void si_pmu_otp_power(si_t * sih, osl_t
 	si_setcoreidx(sih, origidx);
 }
 
-void si_pmu_rcal(si_t * sih, osl_t * osh)
+void si_pmu_rcal(si_t *sih, osl_t *osh)
 {
 	chipcregs_t *cc;
 	uint origidx;
@@ -2210,7 +2210,7 @@ void si_pmu_rcal(si_t * sih, osl_t * osh
 	si_setcoreidx(sih, origidx);
 }
 
-void si_pmu_spuravoid(si_t * sih, osl_t * osh, uint8 spuravoid)
+void si_pmu_spuravoid(si_t *sih, osl_t *osh, uint8 spuravoid)
 {
 	chipcregs_t *cc;
 	uint origidx, intr_val;
@@ -2247,7 +2247,7 @@ void si_pmu_spuravoid(si_t * sih, osl_t
 }
 
 static void
-si_pmu_spuravoid_pllupdate(si_t * sih, chipcregs_t * cc, osl_t * osh,
+si_pmu_spuravoid_pllupdate(si_t *sih, chipcregs_t *cc, osl_t *osh,
 			   uint8 spuravoid)
 {
 	uint32 tmp = 0;
@@ -2443,7 +2443,7 @@ si_pmu_spuravoid_pllupdate(si_t * sih, c
 	W_REG(osh, &cc->pmucontrol, tmp);
 }
 
-bool si_pmu_is_otp_powered(si_t * sih, osl_t * osh)
+bool si_pmu_is_otp_powered(si_t *sih, osl_t *osh)
 {
 	uint idx;
 	chipcregs_t *cc;
@@ -2495,9 +2495,9 @@ bool si_pmu_is_otp_powered(si_t * sih, o
 
 void
 #if defined(BCMDBG)
-si_pmu_sprom_enable(si_t * sih, osl_t * osh, bool enable)
+si_pmu_sprom_enable(si_t *sih, osl_t *osh, bool enable)
 #else
-BCMATTACHFN(si_pmu_sprom_enable) (si_t * sih, osl_t * osh, bool enable)
+BCMATTACHFN(si_pmu_sprom_enable) (si_t *sih, osl_t *osh, bool enable)
 #endif
 {
 	chipcregs_t *cc;
@@ -2513,7 +2513,7 @@ BCMATTACHFN(si_pmu_sprom_enable) (si_t *
 }
 
 /* initialize PMU chip controls and other chip level stuff */
-void BCMATTACHFN(si_pmu_chip_init) (si_t * sih, osl_t * osh) {
+void BCMATTACHFN(si_pmu_chip_init) (si_t *sih, osl_t *osh) {
 	uint origidx;
 
 	ASSERT(sih->cccaps & CC_CAP_PMU);
@@ -2534,7 +2534,7 @@ void BCMATTACHFN(si_pmu_chip_init) (si_t
 }
 
 /* initialize PMU switch/regulators */
-void BCMATTACHFN(si_pmu_swreg_init) (si_t * sih, osl_t * osh) {
+void BCMATTACHFN(si_pmu_swreg_init) (si_t *sih, osl_t *osh) {
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
 	switch (CHIPID(sih->chip)) {
@@ -2559,7 +2559,7 @@ void BCMATTACHFN(si_pmu_swreg_init) (si_
 	}
 }
 
-void si_pmu_radio_enable(si_t * sih, bool enable)
+void si_pmu_radio_enable(si_t *sih, bool enable)
 {
 	ASSERT(sih->cccaps & CC_CAP_PMU);
 
@@ -2577,7 +2577,7 @@ void si_pmu_radio_enable(si_t * sih, boo
 
 /* Wait for a particular clock level to be on the backplane */
 uint32
-si_pmu_waitforclk_on_backplane(si_t * sih, osl_t * osh, uint32 clk,
+si_pmu_waitforclk_on_backplane(si_t *sih, osl_t *osh, uint32 clk,
 			       uint32 delay)
 {
 	chipcregs_t *cc;
@@ -2606,7 +2606,7 @@ si_pmu_waitforclk_on_backplane(si_t * si
 
 #define EXT_ILP_HZ 32768
 
-uint32 BCMATTACHFN(si_pmu_measure_alpclk) (si_t * sih, osl_t * osh) {
+uint32 BCMATTACHFN(si_pmu_measure_alpclk) (si_t *sih, osl_t *osh) {
 	chipcregs_t *cc;
 	uint origidx;
 	uint32 alp_khz;
@@ -2653,7 +2653,7 @@ uint32 BCMATTACHFN(si_pmu_measure_alpclk
 	return alp_khz;
 }
 
-static void BCMATTACHFN(si_pmu_set_4330_plldivs) (si_t * sih) {
+static void BCMATTACHFN(si_pmu_set_4330_plldivs) (si_t *sih) {
 	uint32 FVCO = si_pmu1_pllfvco0(sih) / 1000;
 	uint32 m1div, m2div, m3div, m4div, m5div, m6div;
 	uint32 pllc1, pllc2;
--- a/drivers/staging/brcm80211/util/linux_osl.c
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -166,7 +166,7 @@ osl_t *osl_attach(void *pdev, uint busty
 	return osh;
 }
 
-void osl_detach(osl_t * osh)
+void osl_detach(osl_t *osh)
 {
 	if (osh == NULL)
 		return;
@@ -176,7 +176,7 @@ void osl_detach(osl_t * osh)
 }
 
 /* Return a new packet. zero out pkttag */
-void *BCMFASTPATH osl_pktget(osl_t * osh, uint len)
+void *BCMFASTPATH osl_pktget(osl_t *osh, uint len)
 {
 	struct sk_buff *skb;
 
@@ -191,7 +191,7 @@ void *BCMFASTPATH osl_pktget(osl_t * osh
 }
 
 /* Free the driver packet. Free the tag if present */
-void BCMFASTPATH osl_pktfree(osl_t * osh, void *p, bool send)
+void BCMFASTPATH osl_pktfree(osl_t *osh, void *p, bool send)
 {
 	struct sk_buff *skb, *nskb;
 	int nest = 0;
@@ -224,7 +224,7 @@ void BCMFASTPATH osl_pktfree(osl_t * osh
 	}
 }
 
-uint32 osl_pci_read_config(osl_t * osh, uint offset, uint size)
+uint32 osl_pci_read_config(osl_t *osh, uint offset, uint size)
 {
 	uint val = 0;
 	uint retry = PCI_CFG_RETRY;
@@ -249,7 +249,7 @@ uint32 osl_pci_read_config(osl_t * osh,
 	return (val);
 }
 
-void osl_pci_write_config(osl_t * osh, uint offset, uint size, uint val)
+void osl_pci_write_config(osl_t *osh, uint offset, uint size, uint val)
 {
 	uint retry = PCI_CFG_RETRY;
 
@@ -274,7 +274,7 @@ void osl_pci_write_config(osl_t * osh, u
 }
 
 /* return bus # for the pci device pointed by osh->pdev */
-uint osl_pci_bus(osl_t * osh)
+uint osl_pci_bus(osl_t *osh)
 {
 	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
 
@@ -282,7 +282,7 @@ uint osl_pci_bus(osl_t * osh)
 }
 
 /* return slot # for the pci device pointed by osh->pdev */
-uint osl_pci_slot(osl_t * osh)
+uint osl_pci_slot(osl_t *osh)
 {
 	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
 
@@ -290,21 +290,21 @@ uint osl_pci_slot(osl_t * osh)
 }
 
 static void
-osl_pcmcia_attr(osl_t * osh, uint offset, char *buf, int size, bool write)
+osl_pcmcia_attr(osl_t *osh, uint offset, char *buf, int size, bool write)
 {
 }
 
-void osl_pcmcia_read_attr(osl_t * osh, uint offset, void *buf, int size)
+void osl_pcmcia_read_attr(osl_t *osh, uint offset, void *buf, int size)
 {
 	osl_pcmcia_attr(osh, offset, (char *)buf, size, FALSE);
 }
 
-void osl_pcmcia_write_attr(osl_t * osh, uint offset, void *buf, int size)
+void osl_pcmcia_write_attr(osl_t *osh, uint offset, void *buf, int size)
 {
 	osl_pcmcia_attr(osh, offset, (char *)buf, size, TRUE);
 }
 
-void *osl_malloc(osl_t * osh, uint size)
+void *osl_malloc(osl_t *osh, uint size)
 {
 	void *addr;
 
@@ -323,7 +323,7 @@ void *osl_malloc(osl_t * osh, uint size)
 	return (addr);
 }
 
-void osl_mfree(osl_t * osh, void *addr, uint size)
+void osl_mfree(osl_t *osh, void *addr, uint size)
 {
 	if (osh) {
 		ASSERT(osh->magic == OS_HANDLE_MAGIC);
@@ -332,13 +332,13 @@ void osl_mfree(osl_t * osh, void *addr,
 	kfree(addr);
 }
 
-uint osl_malloced(osl_t * osh)
+uint osl_malloced(osl_t *osh)
 {
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 	return (osh->malloced);
 }
 
-uint osl_malloc_failed(osl_t * osh)
+uint osl_malloc_failed(osl_t *osh)
 {
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 	return (osh->failed);
@@ -349,8 +349,8 @@ uint osl_dma_consistent_align(void)
 	return (PAGE_SIZE);
 }
 
-void *osl_dma_alloc_consistent(osl_t * osh, uint size, uint16 align_bits,
-			       uint * alloced, ulong * pap)
+void *osl_dma_alloc_consistent(osl_t *osh, uint size, uint16 align_bits,
+			       uint *alloced, ulong *pap)
 {
 	uint16 align = (1 << align_bits);
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
@@ -362,14 +362,14 @@ void *osl_dma_alloc_consistent(osl_t * o
 	return (pci_alloc_consistent(osh->pdev, size, (dma_addr_t *) pap));
 }
 
-void osl_dma_free_consistent(osl_t * osh, void *va, uint size, ulong pa)
+void osl_dma_free_consistent(osl_t *osh, void *va, uint size, ulong pa)
 {
 	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
 
 	pci_free_consistent(osh->pdev, size, va, (dma_addr_t) pa);
 }
 
-uint BCMFASTPATH osl_dma_map(osl_t * osh, void *va, uint size, int direction)
+uint BCMFASTPATH osl_dma_map(osl_t *osh, void *va, uint size, int direction)
 {
 	int dir;
 
@@ -378,7 +378,7 @@ uint BCMFASTPATH osl_dma_map(osl_t * osh
 	return (pci_map_single(osh->pdev, va, size, dir));
 }
 
-void BCMFASTPATH osl_dma_unmap(osl_t * osh, uint pa, uint size, int direction)
+void BCMFASTPATH osl_dma_unmap(osl_t *osh, uint pa, uint size, int direction)
 {
 	int dir;
 
@@ -448,7 +448,7 @@ void osl_delay(uint usec)
 /* Clone a packet.
  * The pkttag contents are NOT cloned.
  */
-void *osl_pktdup(osl_t * osh, void *skb)
+void *osl_pktdup(osl_t *osh, void *skb)
 {
 	void *p;
 
@@ -465,7 +465,7 @@ void *osl_pktdup(osl_t * osh, void *skb)
 }
 
 #ifdef BCMSDIO
-uint8 osl_readb(osl_t * osh, volatile uint8 * r)
+uint8 osl_readb(osl_t *osh, volatile uint8 *r)
 {
 	osl_rreg_fn_t rreg = ((osl_pubinfo_t *) osh)->rreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
@@ -473,7 +473,7 @@ uint8 osl_readb(osl_t * osh, volatile ui
 	return (uint8) ((rreg) (ctx, (void *)r, sizeof(uint8)));
 }
 
-uint16 osl_readw(osl_t * osh, volatile uint16 * r)
+uint16 osl_readw(osl_t *osh, volatile uint16 *r)
 {
 	osl_rreg_fn_t rreg = ((osl_pubinfo_t *) osh)->rreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
@@ -481,7 +481,7 @@ uint16 osl_readw(osl_t * osh, volatile u
 	return (uint16) ((rreg) (ctx, (void *)r, sizeof(uint16)));
 }
 
-uint32 osl_readl(osl_t * osh, volatile uint32 * r)
+uint32 osl_readl(osl_t *osh, volatile uint32 *r)
 {
 	osl_rreg_fn_t rreg = ((osl_pubinfo_t *) osh)->rreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
@@ -489,7 +489,7 @@ uint32 osl_readl(osl_t * osh, volatile u
 	return (uint32) ((rreg) (ctx, (void *)r, sizeof(uint32)));
 }
 
-void osl_writeb(osl_t * osh, volatile uint8 * r, uint8 v)
+void osl_writeb(osl_t *osh, volatile uint8 *r, uint8 v)
 {
 	osl_wreg_fn_t wreg = ((osl_pubinfo_t *) osh)->wreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
@@ -497,7 +497,7 @@ void osl_writeb(osl_t * osh, volatile ui
 	((wreg) (ctx, (void *)r, v, sizeof(uint8)));
 }
 
-void osl_writew(osl_t * osh, volatile uint16 * r, uint16 v)
+void osl_writew(osl_t *osh, volatile uint16 *r, uint16 v)
 {
 	osl_wreg_fn_t wreg = ((osl_pubinfo_t *) osh)->wreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
@@ -505,7 +505,7 @@ void osl_writew(osl_t * osh, volatile ui
 	((wreg) (ctx, (void *)r, v, sizeof(uint16)));
 }
 
-void osl_writel(osl_t * osh, volatile uint32 * r, uint32 v)
+void osl_writel(osl_t *osh, volatile uint32 *r, uint32 v)
 {
 	osl_wreg_fn_t wreg = ((osl_pubinfo_t *) osh)->wreg_fn;
 	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
--- a/drivers/staging/brcm80211/util/nicpci.c
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -49,24 +49,24 @@ typedef struct {
 #define PCIE_PUB(sih) ((BUSTYPE((sih)->bustype) == PCI_BUS) && ((sih)->buscoretype == PCIE_CORE_ID))
 
 /* routines to access mdio slave device registers */
-static bool pcie_mdiosetblock(pcicore_info_t * pi, uint blk);
-static int pcie_mdioop(pcicore_info_t * pi, uint physmedia, uint regaddr,
-		       bool write, uint * val);
-static int pcie_mdiowrite(pcicore_info_t * pi, uint physmedia, uint readdr,
+static bool pcie_mdiosetblock(pcicore_info_t *pi, uint blk);
+static int pcie_mdioop(pcicore_info_t *pi, uint physmedia, uint regaddr,
+		       bool write, uint *val);
+static int pcie_mdiowrite(pcicore_info_t *pi, uint physmedia, uint readdr,
 			  uint val);
-static int pcie_mdioread(pcicore_info_t * pi, uint physmedia, uint readdr,
-			 uint * ret_val);
+static int pcie_mdioread(pcicore_info_t *pi, uint physmedia, uint readdr,
+			 uint *ret_val);
 
-static void pcie_extendL1timer(pcicore_info_t * pi, bool extend);
-static void pcie_clkreq_upd(pcicore_info_t * pi, uint state);
+static void pcie_extendL1timer(pcicore_info_t *pi, bool extend);
+static void pcie_clkreq_upd(pcicore_info_t *pi, uint state);
 
-static void pcie_war_aspm_clkreq(pcicore_info_t * pi);
-static void pcie_war_serdes(pcicore_info_t * pi);
-static void pcie_war_noplldown(pcicore_info_t * pi);
-static void pcie_war_polarity(pcicore_info_t * pi);
-static void pcie_war_pci_setup(pcicore_info_t * pi);
+static void pcie_war_aspm_clkreq(pcicore_info_t *pi);
+static void pcie_war_serdes(pcicore_info_t *pi);
+static void pcie_war_noplldown(pcicore_info_t *pi);
+static void pcie_war_polarity(pcicore_info_t *pi);
+static void pcie_war_pci_setup(pcicore_info_t *pi);
 
-static bool pcicore_pmecap(pcicore_info_t * pi);
+static bool pcicore_pmecap(pcicore_info_t *pi);
 
 #define PCIE_ASPM(sih)	((PCIE_PUB(sih)) && (((sih)->buscorerev >= 3) && ((sih)->buscorerev <= 5)))
 
@@ -106,7 +106,7 @@ static bool pcicore_pmecap(pcicore_info_
 /* Initialize the PCI core. It's caller's responsibility to make sure that this is done
  * only once
  */
-void *pcicore_init(si_t * sih, osl_t * osh, void *regs)
+void *pcicore_init(si_t *sih, osl_t *osh, void *regs)
 {
 	pcicore_info_t *pi;
 
@@ -150,8 +150,8 @@ void pcicore_deinit(void *pch)
 /* return cap_offset if requested capability exists in the PCI config space */
 /* Note that it's caller's responsibility to make sure it's a pci bus */
 uint8
-pcicore_find_pci_capability(osl_t * osh, uint8 req_cap_id, uchar * buf,
-			    uint32 * buflen)
+pcicore_find_pci_capability(osl_t *osh, uint8 req_cap_id, uchar *buf,
+			    uint32 *buflen)
 {
 	uint8 cap_id;
 	uint8 cap_ptr = 0;
@@ -211,7 +211,7 @@ pcicore_find_pci_capability(osl_t * osh,
 
 /* ***** Register Access API */
 uint
-pcie_readreg(osl_t * osh, sbpcieregs_t * pcieregs, uint addrtype, uint offset)
+pcie_readreg(osl_t *osh, sbpcieregs_t *pcieregs, uint addrtype, uint offset)
 {
 	uint retval = 0xFFFFFFFF;
 
@@ -237,7 +237,7 @@ pcie_readreg(osl_t * osh, sbpcieregs_t *
 }
 
 uint
-pcie_writereg(osl_t * osh, sbpcieregs_t * pcieregs, uint addrtype, uint offset,
+pcie_writereg(osl_t *osh, sbpcieregs_t *pcieregs, uint addrtype, uint offset,
 	      uint val)
 {
 	ASSERT(pcieregs != NULL);
@@ -258,7 +258,7 @@ pcie_writereg(osl_t * osh, sbpcieregs_t
 	return 0;
 }
 
-static bool pcie_mdiosetblock(pcicore_info_t * pi, uint blk)
+static bool pcie_mdiosetblock(pcicore_info_t *pi, uint blk)
 {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	uint mdiodata, i = 0;
@@ -291,8 +291,8 @@ static bool pcie_mdiosetblock(pcicore_in
 }
 
 static int
-pcie_mdioop(pcicore_info_t * pi, uint physmedia, uint regaddr, bool write,
-	    uint * val)
+pcie_mdioop(pcicore_info_t *pi, uint physmedia, uint regaddr, bool write,
+	    uint *val)
 {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	uint mdiodata;
@@ -351,14 +351,14 @@ pcie_mdioop(pcicore_info_t * pi, uint ph
 
 /* use the mdio interface to read from mdio slaves */
 static int
-pcie_mdioread(pcicore_info_t * pi, uint physmedia, uint regaddr, uint * regval)
+pcie_mdioread(pcicore_info_t *pi, uint physmedia, uint regaddr, uint *regval)
 {
 	return pcie_mdioop(pi, physmedia, regaddr, FALSE, regval);
 }
 
 /* use the mdio interface to write to mdio slaves */
 static int
-pcie_mdiowrite(pcicore_info_t * pi, uint physmedia, uint regaddr, uint val)
+pcie_mdiowrite(pcicore_info_t *pi, uint physmedia, uint regaddr, uint val)
 {
 	return pcie_mdioop(pi, physmedia, regaddr, TRUE, &val);
 }
@@ -390,7 +390,7 @@ uint8 pcie_clkreq(void *pch, uint32 mask
 		return 0;
 }
 
-static void pcie_extendL1timer(pcicore_info_t * pi, bool extend)
+static void pcie_extendL1timer(pcicore_info_t *pi, bool extend)
 {
 	uint32 w;
 	si_t *sih = pi->sih;
@@ -410,7 +410,7 @@ static void pcie_extendL1timer(pcicore_i
 }
 
 /* centralized clkreq control policy */
-static void pcie_clkreq_upd(pcicore_info_t * pi, uint state)
+static void pcie_clkreq_upd(pcicore_info_t *pi, uint state)
 {
 	si_t *sih = pi->sih;
 	ASSERT(PCIE_PUB(sih));
@@ -452,7 +452,7 @@ static void pcie_clkreq_upd(pcicore_info
 
 /* ***** PCI core WARs ***** */
 /* Done only once at attach time */
-static void pcie_war_polarity(pcicore_info_t * pi)
+static void pcie_war_polarity(pcicore_info_t *pi)
 {
 	uint32 w;
 
@@ -477,7 +477,7 @@ static void pcie_war_polarity(pcicore_in
  *   : Coming out of 'standby'/'hibernate'
  *   : If pcie_war_aspm_ovr state changed
  */
-static void pcie_war_aspm_clkreq(pcicore_info_t * pi)
+static void pcie_war_aspm_clkreq(pcicore_info_t *pi)
 {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	si_t *sih = pi->sih;
@@ -525,7 +525,7 @@ static void pcie_war_aspm_clkreq(pcicore
 
 /* Apply the polarity determined at the start */
 /* Needs to happen when coming out of 'standby'/'hibernate' */
-static void pcie_war_serdes(pcicore_info_t * pi)
+static void pcie_war_serdes(pcicore_info_t *pi)
 {
 	uint32 w = 0;
 
@@ -542,7 +542,7 @@ static void pcie_war_serdes(pcicore_info
 
 /* Fix MISC config to allow coming out of L2/L3-Ready state w/o PRST */
 /* Needs to happen when coming out of 'standby'/'hibernate' */
-static void BCMINITFN(pcie_misc_config_fixup) (pcicore_info_t * pi) {
+static void BCMINITFN(pcie_misc_config_fixup) (pcicore_info_t *pi) {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	uint16 val16, *reg16;
 
@@ -557,7 +557,7 @@ static void BCMINITFN(pcie_misc_config_f
 
 /* quick hack for testing */
 /* Needs to happen when coming out of 'standby'/'hibernate' */
-static void pcie_war_noplldown(pcicore_info_t * pi)
+static void pcie_war_noplldown(pcicore_info_t *pi)
 {
 	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
 	uint16 *reg16;
@@ -574,7 +574,7 @@ static void pcie_war_noplldown(pcicore_i
 }
 
 /* Needs to happen when coming out of 'standby'/'hibernate' */
-static void pcie_war_pci_setup(pcicore_info_t * pi)
+static void pcie_war_pci_setup(pcicore_info_t *pi)
 {
 	si_t *sih = pi->sih;
 	osl_t *osh = pi->osh;
@@ -717,7 +717,7 @@ void pcicore_down(void *pch, int state)
 
 /* ***** Wake-on-wireless-LAN (WOWL) support functions ***** */
 /* Just uses PCI config accesses to find out, when needed before sb_attach is done */
-bool pcicore_pmecap_fast(osl_t * osh)
+bool pcicore_pmecap_fast(osl_t *osh)
 {
 	uint8 cap_ptr;
 	uint32 pmecap;
@@ -737,7 +737,7 @@ bool pcicore_pmecap_fast(osl_t * osh)
 /* return TRUE if PM capability exists in the pci config space
  * Uses and caches the information using core handle
  */
-static bool pcicore_pmecap(pcicore_info_t * pi)
+static bool pcicore_pmecap(pcicore_info_t *pi)
 {
 	uint8 cap_ptr;
 	uint32 pmecap;
--- a/drivers/staging/brcm80211/util/nvram/nvram_ro.c
+++ b/drivers/staging/brcm80211/util/nvram/nvram_ro.c
@@ -46,7 +46,7 @@ static char *findvar(char *vars, char *l
 
 #if defined(FLASH)
 /* copy flash to ram */
-static void BCMINITFN(get_flash_nvram) (si_t * sih, struct nvram_header * nvh) {
+static void BCMINITFN(get_flash_nvram) (si_t *sih, struct nvram_header *nvh) {
 	osl_t *osh;
 	uint nvs, bufsz;
 	vars_t *new;
--- a/drivers/staging/brcm80211/util/qmath.c
+++ b/drivers/staging/brcm80211/util/qmath.c
@@ -337,7 +337,7 @@ The qformat of the quotient is returned
 to this function. The qformat of quotient is adjusted appropriately such that
 the quotient occupies all 16 bits.
 */
-int16 qm_div16(int16 num, int16 denom, int16 * qQuotient)
+int16 qm_div16(int16 num, int16 denom, int16 *qQuotient)
 {
 	int16 sign;
 	int16 nNum, nDenom;
@@ -380,7 +380,7 @@ The qformat of the quotient is returned
 to this function. The qformat of quotient is adjusted appropriately such that
 the quotient occupies all 16 bits.
 */
-int16 qm_div163232(int32 num, int32 denom, int16 * qquotient)
+int16 qm_div163232(int32 num, int32 denom, int16 *qquotient)
 {
 	int32 sign;
 	int16 nNum, nDenom;
@@ -545,7 +545,7 @@ qLog10N - address where log10N qformat w
 Note/Problem:
 For accurate results input should be in normalized or near normalized form.
 */
-void qm_log10(int32 N, int16 qN, int16 * log10N, int16 * qLog10N)
+void qm_log10(int32 N, int16 qN, int16 *log10N, int16 *qLog10N)
 {
 	int16 s16norm, s16tableIndex, s16errorApproximation;
 	uint16 u16offset;
@@ -631,7 +631,7 @@ sqrtN - address where 1/N has to be writ
 qsqrtN - address where q format of 1/N has to be written.
 */
 #define qx 29
-void qm_1byN(int32 N, int16 qN, int32 * result, int16 * qResult)
+void qm_1byN(int32 N, int16 qN, int32 *result, int16 *qResult)
 {
 	int16 normN;
 	int32 s32firstTerm, s32secondTerm, x;
--- a/drivers/staging/brcm80211/util/siutils.c
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -52,20 +52,20 @@
 #endif
 
 /* local prototypes */
-static si_info_t *si_doattach(si_info_t * sii, uint devid, osl_t * osh,
+static si_info_t *si_doattach(si_info_t *sii, uint devid, osl_t *osh,
 			      void *regs, uint bustype, void *sdh, char **vars,
-			      uint * varsz);
-static bool si_buscore_prep(si_info_t * sii, uint bustype, uint devid,
+			      uint *varsz);
+static bool si_buscore_prep(si_info_t *sii, uint bustype, uint devid,
 			    void *sdh);
-static bool si_buscore_setup(si_info_t * sii, chipcregs_t * cc, uint bustype,
-			     uint32 savewin, uint * origidx, void *regs);
-static void si_nvram_process(si_info_t * sii, char *pvars);
+static bool si_buscore_setup(si_info_t *sii, chipcregs_t *cc, uint bustype,
+			     uint32 savewin, uint *origidx, void *regs);
+static void si_nvram_process(si_info_t *sii, char *pvars);
 
 /* dev path concatenation util */
-static char *si_devpathvar(si_t * sih, char *var, int len, const char *name);
-static bool _si_clkctl_cc(si_info_t * sii, uint mode);
-static bool si_ispcie(si_info_t * sii);
-static uint BCMINITFN(socram_banksize) (si_info_t * sii, sbsocramregs_t * r,
+static char *si_devpathvar(si_t *sih, char *var, int len, const char *name);
+static bool _si_clkctl_cc(si_info_t *sii, uint mode);
+static bool si_ispcie(si_info_t *sii);
+static uint BCMINITFN(socram_banksize) (si_info_t *sii, sbsocramregs_t *r,
 					uint8 idx, uint8 mtype);
 
 /* global variable to indicate reservation/release of gpio's */
@@ -82,9 +82,9 @@ static uint32 si_gpioreservation = 0;
  * vars - pointer to a pointer area for "environment" variables
  * varsz - pointer to int to return the size of the vars
  */
-si_t *BCMATTACHFN(si_attach) (uint devid, osl_t * osh, void *regs,
+si_t *BCMATTACHFN(si_attach) (uint devid, osl_t *osh, void *regs,
 			      uint bustype, void *sdh, char **vars,
-			      uint * varsz) {
+			      uint *varsz) {
 	si_info_t *sii;
 
 	/* alloc si_info_t */
@@ -111,7 +111,7 @@ static si_info_t ksii;
 static uint32 wd_msticks;	/* watchdog timer ticks normalized to ms */
 
 static bool
-BCMATTACHFN(si_buscore_prep) (si_info_t * sii, uint bustype, uint devid,
+BCMATTACHFN(si_buscore_prep) (si_info_t *sii, uint bustype, uint devid,
 			      void *sdh) {
 
 	/* kludge to enable the clock on the 4306 which lacks a slowclock */
@@ -165,8 +165,8 @@ BCMATTACHFN(si_buscore_prep) (si_info_t
 }
 
 static bool
-BCMATTACHFN(si_buscore_setup) (si_info_t * sii, chipcregs_t * cc, uint bustype,
-			       uint32 savewin, uint * origidx, void *regs) {
+BCMATTACHFN(si_buscore_setup) (si_info_t *sii, chipcregs_t *cc, uint bustype,
+			       uint32 savewin, uint *origidx, void *regs) {
 	bool pci, pcie;
 	uint i;
 	uint pciidx, pcieidx, pcirev, pcierev;
@@ -290,7 +290,7 @@ BCMATTACHFN(si_buscore_setup) (si_info_t
 	return TRUE;
 }
 
-static void BCMATTACHFN(si_nvram_process) (si_info_t * sii, char *pvars) {
+static void BCMATTACHFN(si_nvram_process) (si_info_t *sii, char *pvars) {
 	uint w = 0;
 
 	/* get boardtype and boardrev */
@@ -349,10 +349,10 @@ static void BCMATTACHFN(si_nvram_process
 /* this is will make Sonics calls directly, since Sonics is no longer supported in the Si abstraction */
 /* this has been customized for the bcm 4329 ONLY */
 #ifdef BCMSDIO
-static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
-					    osl_t * osh, void *regs,
+static si_info_t *BCMATTACHFN(si_doattach) (si_info_t *sii, uint devid,
+					    osl_t *osh, void *regs,
 					    uint bustype, void *sdh,
-					    char **vars, uint * varsz) {
+					    char **vars, uint *varsz) {
 	struct si_pub *sih = &sii->pub;
 	uint32 w, savewin;
 	chipcregs_t *cc;
@@ -471,10 +471,10 @@ static si_info_t *BCMATTACHFN(si_doattac
 }
 
 #else				/* BCMSDIO */
-static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
-					    osl_t * osh, void *regs,
+static si_info_t *BCMATTACHFN(si_doattach) (si_info_t *sii, uint devid,
+					    osl_t *osh, void *regs,
 					    uint bustype, void *sdh,
-					    char **vars, uint * varsz) {
+					    char **vars, uint *varsz) {
 	struct si_pub *sih = &sii->pub;
 	uint32 w, savewin;
 	chipcregs_t *cc;
@@ -666,7 +666,7 @@ static si_info_t *BCMATTACHFN(si_doattac
 #endif				/* BCMSDIO */
 
 /* may be called with core in reset */
-void BCMATTACHFN(si_detach) (si_t * sih) {
+void BCMATTACHFN(si_detach) (si_t *sih) {
 	si_info_t *sii;
 	uint idx;
 
@@ -698,7 +698,7 @@ void BCMATTACHFN(si_detach) (si_t * sih)
 		MFREE(sii->osh, sii, sizeof(si_info_t));
 }
 
-void *si_osh(si_t * sih)
+void *si_osh(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -706,7 +706,7 @@ void *si_osh(si_t * sih)
 	return sii->osh;
 }
 
-void si_setosh(si_t * sih, osl_t * osh)
+void si_setosh(si_t *sih, osl_t *osh)
 {
 	si_info_t *sii;
 
@@ -720,7 +720,7 @@ void si_setosh(si_t * sih, osl_t * osh)
 
 /* register driver interrupt disabling and restoring callback functions */
 void
-si_register_intr_callback(si_t * sih, void *intrsoff_fn, void *intrsrestore_fn,
+si_register_intr_callback(si_t *sih, void *intrsoff_fn, void *intrsrestore_fn,
 			  void *intrsenabled_fn, void *intr_arg)
 {
 	si_info_t *sii;
@@ -736,7 +736,7 @@ si_register_intr_callback(si_t * sih, vo
 	sii->dev_coreid = sii->coreid[sii->curidx];
 }
 
-void si_deregister_intr_callback(si_t * sih)
+void si_deregister_intr_callback(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -744,7 +744,7 @@ void si_deregister_intr_callback(si_t *
 	sii->intrsoff_fn = NULL;
 }
 
-uint si_intflag(si_t * sih)
+uint si_intflag(si_t *sih)
 {
 	si_info_t *sii = SI_INFO(sih);
 
@@ -758,7 +758,7 @@ uint si_intflag(si_t * sih)
 	}
 }
 
-uint si_flag(si_t * sih)
+uint si_flag(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_flag(sih);
@@ -768,7 +768,7 @@ uint si_flag(si_t * sih)
 	}
 }
 
-void si_setint(si_t * sih, int siflag)
+void si_setint(si_t *sih, int siflag)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		ai_setint(sih, siflag);
@@ -777,7 +777,7 @@ void si_setint(si_t * sih, int siflag)
 }
 
 #ifndef BCMSDIO
-uint si_coreid(si_t * sih)
+uint si_coreid(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -786,7 +786,7 @@ uint si_coreid(si_t * sih)
 }
 #endif
 
-uint si_coreidx(si_t * sih)
+uint si_coreidx(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -795,7 +795,7 @@ uint si_coreidx(si_t * sih)
 }
 
 /* return the core-type instantiation # of the current core */
-uint si_coreunit(si_t * sih)
+uint si_coreunit(si_t *sih)
 {
 	si_info_t *sii;
 	uint idx;
@@ -819,7 +819,7 @@ uint si_coreunit(si_t * sih)
 	return (coreunit);
 }
 
-uint si_corevendor(si_t * sih)
+uint si_corevendor(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_corevendor(sih);
@@ -829,13 +829,13 @@ uint si_corevendor(si_t * sih)
 	}
 }
 
-bool si_backplane64(si_t * sih)
+bool si_backplane64(si_t *sih)
 {
 	return ((sih->cccaps & CC_CAP_BKPLN64) != 0);
 }
 
 #ifndef BCMSDIO
-uint si_corerev(si_t * sih)
+uint si_corerev(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_corerev(sih);
@@ -847,7 +847,7 @@ uint si_corerev(si_t * sih)
 #endif
 
 /* return index of coreid or BADIDX if not found */
-uint si_findcoreidx(si_t * sih, uint coreid, uint coreunit)
+uint si_findcoreidx(si_t *sih, uint coreid, uint coreunit)
 {
 	si_info_t *sii;
 	uint found;
@@ -868,7 +868,7 @@ uint si_findcoreidx(si_t * sih, uint cor
 }
 
 /* return list of found cores */
-uint si_corelist(si_t * sih, uint coreid[])
+uint si_corelist(si_t *sih, uint coreid[])
 {
 	si_info_t *sii;
 
@@ -880,7 +880,7 @@ uint si_corelist(si_t * sih, uint coreid
 }
 
 /* return current register mapping */
-void *si_coreregs(si_t * sih)
+void *si_coreregs(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -895,7 +895,7 @@ void *si_coreregs(si_t * sih)
  * must be called with interrupts off.
  * Moreover, callers should keep interrupts off during switching out of and back to d11 core
  */
-void *si_setcore(si_t * sih, uint coreid, uint coreunit)
+void *si_setcore(si_t *sih, uint coreid, uint coreunit)
 {
 	uint idx;
 
@@ -916,7 +916,7 @@ void *si_setcore(si_t * sih, uint coreid
 }
 
 #ifndef BCMSDIO
-void *si_setcoreidx(si_t * sih, uint coreidx)
+void *si_setcoreidx(si_t *sih, uint coreidx)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_setcoreidx(sih, coreidx);
@@ -928,7 +928,7 @@ void *si_setcoreidx(si_t * sih, uint cor
 #endif
 
 /* Turn off interrupt as required by sb_setcore, before switch core */
-void *si_switch_core(si_t * sih, uint coreid, uint * origidx, uint * intr_val)
+void *si_switch_core(si_t *sih, uint coreid, uint *origidx, uint *intr_val)
 {
 	void *cc;
 	si_info_t *sii;
@@ -955,7 +955,7 @@ void *si_switch_core(si_t * sih, uint co
 }
 
 /* restore coreidx and restore interrupt */
-void si_restore_core(si_t * sih, uint coreid, uint intr_val)
+void si_restore_core(si_t *sih, uint coreid, uint intr_val)
 {
 	si_info_t *sii;
 
@@ -968,7 +968,7 @@ void si_restore_core(si_t * sih, uint co
 	INTR_RESTORE(sii, intr_val);
 }
 
-int si_numaddrspaces(si_t * sih)
+int si_numaddrspaces(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_numaddrspaces(sih);
@@ -978,7 +978,7 @@ int si_numaddrspaces(si_t * sih)
 	}
 }
 
-uint32 si_addrspace(si_t * sih, uint asidx)
+uint32 si_addrspace(si_t *sih, uint asidx)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_addrspace(sih, asidx);
@@ -988,7 +988,7 @@ uint32 si_addrspace(si_t * sih, uint asi
 	}
 }
 
-uint32 si_addrspacesize(si_t * sih, uint asidx)
+uint32 si_addrspacesize(si_t *sih, uint asidx)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_addrspacesize(sih, asidx);
@@ -998,7 +998,7 @@ uint32 si_addrspacesize(si_t * sih, uint
 	}
 }
 
-uint32 si_core_cflags(si_t * sih, uint32 mask, uint32 val)
+uint32 si_core_cflags(si_t *sih, uint32 mask, uint32 val)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_core_cflags(sih, mask, val);
@@ -1008,7 +1008,7 @@ uint32 si_core_cflags(si_t * sih, uint32
 	}
 }
 
-void si_core_cflags_wo(si_t * sih, uint32 mask, uint32 val)
+void si_core_cflags_wo(si_t *sih, uint32 mask, uint32 val)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		ai_core_cflags_wo(sih, mask, val);
@@ -1016,7 +1016,7 @@ void si_core_cflags_wo(si_t * sih, uint3
 		ASSERT(0);
 }
 
-uint32 si_core_sflags(si_t * sih, uint32 mask, uint32 val)
+uint32 si_core_sflags(si_t *sih, uint32 mask, uint32 val)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_core_sflags(sih, mask, val);
@@ -1026,7 +1026,7 @@ uint32 si_core_sflags(si_t * sih, uint32
 	}
 }
 
-bool si_iscoreup(si_t * sih)
+bool si_iscoreup(si_t *sih)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		return ai_iscoreup(sih);
@@ -1040,7 +1040,7 @@ bool si_iscoreup(si_t * sih)
 	}
 }
 
-void si_write_wrapperreg(si_t * sih, uint32 offset, uint32 val)
+void si_write_wrapperreg(si_t *sih, uint32 offset, uint32 val)
 {
 	/* only for 4319, no requirement for SOCI_SB */
 	if (CHIPTYPE(sih->socitype) == SOCI_AI) {
@@ -1048,7 +1048,7 @@ void si_write_wrapperreg(si_t * sih, uin
 	}
 }
 
-uint si_corereg(si_t * sih, uint coreidx, uint regoff, uint mask, uint val)
+uint si_corereg(si_t *sih, uint coreidx, uint regoff, uint mask, uint val)
 {
 
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
@@ -1063,7 +1063,7 @@ uint si_corereg(si_t * sih, uint coreidx
 	}
 }
 
-void si_core_disable(si_t * sih, uint32 bits)
+void si_core_disable(si_t *sih, uint32 bits)
 {
 
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
@@ -1074,7 +1074,7 @@ void si_core_disable(si_t * sih, uint32
 #endif
 }
 
-void si_core_reset(si_t * sih, uint32 bits, uint32 resetbits)
+void si_core_reset(si_t *sih, uint32 bits, uint32 resetbits)
 {
 	if (CHIPTYPE(sih->socitype) == SOCI_AI)
 		ai_core_reset(sih, bits, resetbits);
@@ -1085,7 +1085,7 @@ void si_core_reset(si_t * sih, uint32 bi
 }
 
 /* Run bist on current core. Caller needs to take care of core-specific bist hazards */
-int si_corebist(si_t * sih)
+int si_corebist(si_t *sih)
 {
 	uint32 cflags;
 	int result = 0;
@@ -1212,7 +1212,7 @@ uint32 BCMINITFN(si_clock_rate) (uint32
 	}
 }
 
-uint32 BCMINITFN(si_clock) (si_t * sih) {
+uint32 BCMINITFN(si_clock) (si_t *sih) {
 	si_info_t *sii;
 	chipcregs_t *cc;
 	uint32 n, m;
@@ -1254,14 +1254,14 @@ uint32 BCMINITFN(si_clock) (si_t * sih)
 	return rate;
 }
 
-uint32 BCMINITFN(si_alp_clock) (si_t * sih) {
+uint32 BCMINITFN(si_alp_clock) (si_t *sih) {
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_alp_clock(sih, si_osh(sih));
 
 	return ALP_CLOCK;
 }
 
-uint32 BCMINITFN(si_ilp_clock) (si_t * sih) {
+uint32 BCMINITFN(si_ilp_clock) (si_t *sih) {
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_ilp_clock(sih, si_osh(sih));
 
@@ -1269,7 +1269,7 @@ uint32 BCMINITFN(si_ilp_clock) (si_t * s
 }
 
 /* set chip watchdog reset timer to fire in 'ticks' */
-void si_watchdog(si_t * sih, uint ticks)
+void si_watchdog(si_t *sih, uint ticks)
 {
 	uint nb, maxt;
 
@@ -1313,12 +1313,12 @@ void si_watchdog(si_t * sih, uint ticks)
 }
 
 /* trigger watchdog reset after ms milliseconds */
-void si_watchdog_ms(si_t * sih, uint32 ms)
+void si_watchdog_ms(si_t *sih, uint32 ms)
 {
 	si_watchdog(sih, wd_msticks * ms);
 }
 
-uint16 BCMATTACHFN(si_d11_devid) (si_t * sih) {
+uint16 BCMATTACHFN(si_d11_devid) (si_t *sih) {
 	si_info_t *sii = SI_INFO(sih);
 	uint16 device;
 
@@ -1336,7 +1336,7 @@ uint16 BCMATTACHFN(si_d11_devid) (si_t *
 }
 
 /* return the slow clock source - LPO, XTAL, or PCI */
-static uint si_slowclk_src(si_info_t * sii)
+static uint si_slowclk_src(si_info_t *sii)
 {
 	chipcregs_t *cc;
 
@@ -1357,7 +1357,7 @@ static uint si_slowclk_src(si_info_t * s
 }
 
 /* return the ILP (slowclock) min or max frequency */
-static uint si_slowclk_freq(si_info_t * sii, bool max_freq, chipcregs_t * cc)
+static uint si_slowclk_freq(si_info_t *sii, bool max_freq, chipcregs_t *cc)
 {
 	uint32 slowclk;
 	uint div;
@@ -1398,7 +1398,7 @@ static uint si_slowclk_freq(si_info_t *
 	return (0);
 }
 
-static void BCMINITFN(si_clkctl_setdelay) (si_info_t * sii, void *chipcregs) {
+static void BCMINITFN(si_clkctl_setdelay) (si_info_t *sii, void *chipcregs) {
 	chipcregs_t *cc = (chipcregs_t *) chipcregs;
 	uint slowmaxfreq, pll_delay, slowclk;
 	uint pll_on_delay, fref_sel_delay;
@@ -1425,7 +1425,7 @@ static void BCMINITFN(si_clkctl_setdelay
 }
 
 /* initialize power control delay registers */
-void BCMINITFN(si_clkctl_init) (si_t * sih) {
+void BCMINITFN(si_clkctl_init) (si_t *sih) {
 	si_info_t *sii;
 	uint origidx = 0;
 	chipcregs_t *cc;
@@ -1457,7 +1457,7 @@ void BCMINITFN(si_clkctl_init) (si_t * s
 }
 
 /* return the value suitable for writing to the dot11 core FAST_PWRUP_DELAY register */
-uint16 BCMINITFN(si_clkctl_fast_pwrup_delay) (si_t * sih) {
+uint16 BCMINITFN(si_clkctl_fast_pwrup_delay) (si_t *sih) {
 	si_info_t *sii;
 	uint origidx = 0;
 	chipcregs_t *cc;
@@ -1502,7 +1502,7 @@ uint16 BCMINITFN(si_clkctl_fast_pwrup_de
 }
 
 /* turn primary xtal and/or pll off/on */
-int si_clkctl_xtal(si_t * sih, uint what, bool on)
+int si_clkctl_xtal(si_t *sih, uint what, bool on)
 {
 	si_info_t *sii;
 	uint32 in, out, outen;
@@ -1587,7 +1587,7 @@ int si_clkctl_xtal(si_t * sih, uint what
  *    this is a wrapper over the next internal function
  *      to allow flexible policy settings for outside caller
  */
-bool si_clkctl_cc(si_t * sih, uint mode)
+bool si_clkctl_cc(si_t *sih, uint mode)
 {
 	si_info_t *sii;
 
@@ -1604,7 +1604,7 @@ bool si_clkctl_cc(si_t * sih, uint mode)
 }
 
 /* clk control mechanism through chipcommon, no policy checking */
-static bool _si_clkctl_cc(si_info_t * sii, uint mode)
+static bool _si_clkctl_cc(si_info_t *sii, uint mode)
 {
 	uint origidx = 0;
 	chipcregs_t *cc;
@@ -1692,7 +1692,7 @@ static bool _si_clkctl_cc(si_info_t * si
 }
 
 /* Build device path. Support SI, PCI, and JTAG for now. */
-int BCMATTACHFN(si_devpath) (si_t * sih, char *path, int size) {
+int BCMATTACHFN(si_devpath) (si_t *sih, char *path, int size) {
 	int slen;
 
 	ASSERT(path != NULL);
@@ -1734,7 +1734,7 @@ int BCMATTACHFN(si_devpath) (si_t * sih,
 }
 
 /* Get a variable, but only if it has a devpath prefix */
-char *BCMATTACHFN(si_getdevpathvar) (si_t * sih, const char *name) {
+char *BCMATTACHFN(si_getdevpathvar) (si_t *sih, const char *name) {
 	char varname[SI_DEVPATH_BUFSZ + 32];
 
 	si_devpathvar(sih, varname, sizeof(varname), name);
@@ -1743,7 +1743,7 @@ char *BCMATTACHFN(si_getdevpathvar) (si_
 }
 
 /* Get a variable, but only if it has a devpath prefix */
-int BCMATTACHFN(si_getdevpathintvar) (si_t * sih, const char *name) {
+int BCMATTACHFN(si_getdevpathintvar) (si_t *sih, const char *name) {
 #if defined(BCMBUSTYPE) && (BCMBUSTYPE == SI_BUS)
 	return (getintvar(NULL, name));
 #else
@@ -1755,7 +1755,7 @@ int BCMATTACHFN(si_getdevpathintvar) (si
 #endif
 }
 
-char *si_getnvramflvar(si_t * sih, const char *name)
+char *si_getnvramflvar(si_t *sih, const char *name)
 {
 	return (getvar(NULL, name));
 }
@@ -1765,7 +1765,7 @@ char *si_getnvramflvar(si_t * sih, const
  * Nothing is done to the arguments if len == 0 or var is NULL, var is still returned.
  * On overflow, the first char will be set to '\0'.
  */
-static char *BCMATTACHFN(si_devpathvar) (si_t * sih, char *var, int len,
+static char *BCMATTACHFN(si_devpathvar) (si_t *sih, char *var, int len,
 					 const char *name) {
 	uint path_len;
 
@@ -1784,7 +1784,7 @@ static char *BCMATTACHFN(si_devpathvar)
 	return var;
 }
 
-uint32 si_pciereg(si_t * sih, uint32 offset, uint32 mask, uint32 val, uint type)
+uint32 si_pciereg(si_t *sih, uint32 offset, uint32 mask, uint32 val, uint type)
 {
 	si_info_t *sii;
 
@@ -1799,7 +1799,7 @@ uint32 si_pciereg(si_t * sih, uint32 off
 }
 
 uint32
-si_pcieserdesreg(si_t * sih, uint32 mdioslave, uint32 offset, uint32 mask,
+si_pcieserdesreg(si_t *sih, uint32 mdioslave, uint32 offset, uint32 mask,
 		 uint32 val)
 {
 	si_info_t *sii;
@@ -1816,7 +1816,7 @@ si_pcieserdesreg(si_t * sih, uint32 mdio
 }
 
 /* return TRUE if PCIE capability exists in the pci config space */
-static bool si_ispcie(si_info_t * sii)
+static bool si_ispcie(si_info_t *sii)
 {
 	uint8 cap_ptr;
 
@@ -1834,7 +1834,7 @@ static bool si_ispcie(si_info_t * sii)
 
 /* Wake-on-wireless-LAN (WOWL) support functions */
 /* Enable PME generation and disable clkreq */
-void si_pci_pmeen(si_t * sih)
+void si_pci_pmeen(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -1844,7 +1844,7 @@ void si_pci_pmeen(si_t * sih)
 }
 
 /* Return TRUE if PME status is set */
-bool si_pci_pmestat(si_t * sih)
+bool si_pci_pmestat(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -1854,7 +1854,7 @@ bool si_pci_pmestat(si_t * sih)
 }
 
 /* Disable PME generation, clear the PME status bit if set */
-void si_pci_pmeclr(si_t * sih)
+void si_pci_pmeclr(si_t *sih)
 {
 	si_info_t *sii;
 
@@ -1865,7 +1865,7 @@ void si_pci_pmeclr(si_t * sih)
 
 #ifdef BCMSDIO
 /* initialize the sdio core */
-void si_sdio_init(si_t * sih)
+void si_sdio_init(si_t *sih)
 {
 	si_info_t *sii = SI_INFO(sih);
 
@@ -1903,7 +1903,7 @@ void si_sdio_init(si_t * sih)
 }
 #endif				/* BCMSDIO */
 
-bool BCMATTACHFN(si_pci_war16165) (si_t * sih) {
+bool BCMATTACHFN(si_pci_war16165) (si_t *sih) {
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -1916,7 +1916,7 @@ bool BCMATTACHFN(si_pci_war16165) (si_t
  * but are in systems that still want the benefits of ASPM
  * Note that this should be done AFTER si_doattach
  */
-void si_pcie_war_ovr_update(si_t * sih, uint8 aspm)
+void si_pcie_war_ovr_update(si_t *sih, uint8 aspm)
 {
 	si_info_t *sii;
 
@@ -1929,7 +1929,7 @@ void si_pcie_war_ovr_update(si_t * sih,
 }
 
 /* back door for other module to override chippkg */
-void si_chippkg_set(si_t * sih, uint val)
+void si_chippkg_set(si_t *sih, uint val)
 {
 	si_info_t *sii;
 
@@ -1938,7 +1938,7 @@ void si_chippkg_set(si_t * sih, uint val
 	sii->pub.chippkg = val;
 }
 
-void BCMINITFN(si_pci_up) (si_t * sih) {
+void BCMINITFN(si_pci_up) (si_t *sih) {
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -1956,7 +1956,7 @@ void BCMINITFN(si_pci_up) (si_t * sih) {
 }
 
 /* Unconfigure and/or apply various WARs when system is going to sleep mode */
-void BCMUNINITFN(si_pci_sleep) (si_t * sih) {
+void BCMUNINITFN(si_pci_sleep) (si_t *sih) {
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -1965,7 +1965,7 @@ void BCMUNINITFN(si_pci_sleep) (si_t * s
 }
 
 /* Unconfigure and/or apply various WARs when going down */
-void BCMINITFN(si_pci_down) (si_t * sih) {
+void BCMINITFN(si_pci_down) (si_t *sih) {
 	si_info_t *sii;
 
 	sii = SI_INFO(sih);
@@ -1985,7 +1985,7 @@ void BCMINITFN(si_pci_down) (si_t * sih)
  * Configure the pci core for pci client (NIC) action
  * coremask is the bitvec of cores by index to be enabled.
  */
-void BCMATTACHFN(si_pci_setup) (si_t * sih, uint coremask) {
+void BCMATTACHFN(si_pci_setup) (si_t *sih, uint coremask) {
 	si_info_t *sii;
 	sbpciregs_t *pciregs = NULL;
 	uint32 siflag = 0, w;
@@ -2042,7 +2042,7 @@ void BCMATTACHFN(si_pci_setup) (si_t * s
 	}
 }
 
-uint8 si_pcieclkreq(si_t * sih, uint32 mask, uint32 val)
+uint8 si_pcieclkreq(si_t *sih, uint32 mask, uint32 val)
 {
 	si_info_t *sii;
 
@@ -2053,7 +2053,7 @@ uint8 si_pcieclkreq(si_t * sih, uint32 m
 	return pcie_clkreq(sii->pch, mask, val);
 }
 
-uint32 si_pcielcreg(si_t * sih, uint32 mask, uint32 val)
+uint32 si_pcielcreg(si_t *sih, uint32 mask, uint32 val)
 {
 	si_info_t *sii;
 
@@ -2077,7 +2077,7 @@ uint si_pcie_readreg(void *sih, uint add
  * Fixup SROMless PCI device's configuration.
  * The current core may be changed upon return.
  */
-int si_pci_fixcfg(si_t * sih)
+int si_pci_fixcfg(si_t *sih)
 {
 	uint origidx, pciidx;
 	sbpciregs_t *pciregs = NULL;
@@ -2123,13 +2123,13 @@ int si_pci_fixcfg(si_t * sih)
 }
 
 /* change logical "focus" to the gpio core for optimized access */
-void *si_gpiosetcore(si_t * sih)
+void *si_gpiosetcore(si_t *sih)
 {
 	return (si_setcoreidx(sih, SI_CC_IDX));
 }
 
 /* mask&set gpiocontrol bits */
-uint32 si_gpiocontrol(si_t * sih, uint32 mask, uint32 val, uint8 priority)
+uint32 si_gpiocontrol(si_t *sih, uint32 mask, uint32 val, uint8 priority)
 {
 	uint regoff;
 
@@ -2150,7 +2150,7 @@ uint32 si_gpiocontrol(si_t * sih, uint32
 }
 
 /* mask&set gpio output enable bits */
-uint32 si_gpioouten(si_t * sih, uint32 mask, uint32 val, uint8 priority)
+uint32 si_gpioouten(si_t *sih, uint32 mask, uint32 val, uint8 priority)
 {
 	uint regoff;
 
@@ -2171,7 +2171,7 @@ uint32 si_gpioouten(si_t * sih, uint32 m
 }
 
 /* mask&set gpio output bits */
-uint32 si_gpioout(si_t * sih, uint32 mask, uint32 val, uint8 priority)
+uint32 si_gpioout(si_t *sih, uint32 mask, uint32 val, uint8 priority)
 {
 	uint regoff;
 
@@ -2192,7 +2192,7 @@ uint32 si_gpioout(si_t * sih, uint32 mas
 }
 
 /* reserve one gpio */
-uint32 si_gpioreserve(si_t * sih, uint32 gpio_bitmask, uint8 priority)
+uint32 si_gpioreserve(si_t *sih, uint32 gpio_bitmask, uint8 priority)
 {
 	si_info_t *sii;
 
@@ -2227,7 +2227,7 @@ uint32 si_gpioreserve(si_t * sih, uint32
  * persists till some one overwrites it
  */
 
-uint32 si_gpiorelease(si_t * sih, uint32 gpio_bitmask, uint8 priority)
+uint32 si_gpiorelease(si_t *sih, uint32 gpio_bitmask, uint8 priority)
 {
 	si_info_t *sii;
 
@@ -2258,7 +2258,7 @@ uint32 si_gpiorelease(si_t * sih, uint32
 }
 
 /* return the current gpioin register value */
-uint32 si_gpioin(si_t * sih)
+uint32 si_gpioin(si_t *sih)
 {
 	si_info_t *sii;
 	uint regoff;
@@ -2271,7 +2271,7 @@ uint32 si_gpioin(si_t * sih)
 }
 
 /* mask&set gpio interrupt polarity bits */
-uint32 si_gpiointpolarity(si_t * sih, uint32 mask, uint32 val, uint8 priority)
+uint32 si_gpiointpolarity(si_t *sih, uint32 mask, uint32 val, uint8 priority)
 {
 	si_info_t *sii;
 	uint regoff;
@@ -2291,7 +2291,7 @@ uint32 si_gpiointpolarity(si_t * sih, ui
 }
 
 /* mask&set gpio interrupt mask bits */
-uint32 si_gpiointmask(si_t * sih, uint32 mask, uint32 val, uint8 priority)
+uint32 si_gpiointmask(si_t *sih, uint32 mask, uint32 val, uint8 priority)
 {
 	si_info_t *sii;
 	uint regoff;
@@ -2311,7 +2311,7 @@ uint32 si_gpiointmask(si_t * sih, uint32
 }
 
 /* assign the gpio to an led */
-uint32 si_gpioled(si_t * sih, uint32 mask, uint32 val)
+uint32 si_gpioled(si_t *sih, uint32 mask, uint32 val)
 {
 	si_info_t *sii;
 
@@ -2326,7 +2326,7 @@ uint32 si_gpioled(si_t * sih, uint32 mas
 }
 
 /* mask&set gpio timer val */
-uint32 si_gpiotimerval(si_t * sih, uint32 mask, uint32 gpiotimerval)
+uint32 si_gpiotimerval(si_t *sih, uint32 mask, uint32 gpiotimerval)
 {
 	si_info_t *sii;
 
@@ -2340,7 +2340,7 @@ uint32 si_gpiotimerval(si_t * sih, uint3
 			   gpiotimerval));
 }
 
-uint32 si_gpiopull(si_t * sih, bool updown, uint32 mask, uint32 val)
+uint32 si_gpiopull(si_t *sih, bool updown, uint32 mask, uint32 val)
 {
 	si_info_t *sii;
 	uint offs;
@@ -2355,7 +2355,7 @@ uint32 si_gpiopull(si_t * sih, bool updo
 	return (si_corereg(sih, SI_CC_IDX, offs, mask, val));
 }
 
-uint32 si_gpioevent(si_t * sih, uint regtype, uint32 mask, uint32 val)
+uint32 si_gpioevent(si_t *sih, uint regtype, uint32 mask, uint32 val)
 {
 	si_info_t *sii;
 	uint offs;
@@ -2376,7 +2376,7 @@ uint32 si_gpioevent(si_t * sih, uint reg
 	return (si_corereg(sih, SI_CC_IDX, offs, mask, val));
 }
 
-void *BCMATTACHFN(si_gpio_handler_register) (si_t * sih, uint32 event,
+void *BCMATTACHFN(si_gpio_handler_register) (si_t *sih, uint32 event,
 					     bool level, gpio_handler_t cb,
 					     void *arg) {
 	si_info_t *sii;
@@ -2404,7 +2404,7 @@ void *BCMATTACHFN(si_gpio_handler_regist
 	return (void *)(gi);
 }
 
-void BCMATTACHFN(si_gpio_handler_unregister) (si_t * sih, void *gpioh) {
+void BCMATTACHFN(si_gpio_handler_unregister) (si_t *sih, void *gpioh) {
 	si_info_t *sii;
 	gpioh_item_t *p, *n;
 
@@ -2434,7 +2434,7 @@ void BCMATTACHFN(si_gpio_handler_unregis
 	ASSERT(0);		/* Not found in list */
 }
 
-void si_gpio_handler_process(si_t * sih)
+void si_gpio_handler_process(si_t *sih)
 {
 	si_info_t *sii;
 	gpioh_item_t *h;
@@ -2455,7 +2455,7 @@ void si_gpio_handler_process(si_t * sih)
 	si_gpioevent(sih, GPIO_REGEVT, edge, edge);	/* clear edge-trigger status */
 }
 
-uint32 si_gpio_int_enable(si_t * sih, bool enable)
+uint32 si_gpio_int_enable(si_t *sih, bool enable)
 {
 	si_info_t *sii;
 	uint offs;
@@ -2471,7 +2471,7 @@ uint32 si_gpio_int_enable(si_t * sih, bo
 
 /* Return the size of the specified SOCRAM bank */
 static uint
-socram_banksize(si_info_t * sii, sbsocramregs_t * regs, uint8 index,
+socram_banksize(si_info_t *sii, sbsocramregs_t *regs, uint8 index,
 		uint8 mem_type)
 {
 	uint banksize, bankinfo;
@@ -2486,7 +2486,7 @@ socram_banksize(si_info_t * sii, sbsocra
 	return banksize;
 }
 
-void si_socdevram(si_t * sih, bool set, uint8 * enable, uint8 * protect)
+void si_socdevram(si_t *sih, bool set, uint8 *enable, uint8 *protect)
 {
 	si_info_t *sii;
 	uint origidx;
@@ -2561,7 +2561,7 @@ void si_socdevram(si_t * sih, bool set,
 	INTR_RESTORE(sii, intr_val);
 }
 
-bool si_socdevram_pkg(si_t * sih)
+bool si_socdevram_pkg(si_t *sih)
 {
 	if (si_socdevram_size(sih) > 0)
 		return TRUE;
@@ -2569,7 +2569,7 @@ bool si_socdevram_pkg(si_t * sih)
 		return FALSE;
 }
 
-uint32 si_socdevram_size(si_t * sih)
+uint32 si_socdevram_size(si_t *sih)
 {
 	si_info_t *sii;
 	uint origidx;
@@ -2620,7 +2620,7 @@ uint32 si_socdevram_size(si_t * sih)
 }
 
 /* Return the RAM size of the SOCRAM core */
-uint32 si_socram_size(si_t * sih)
+uint32 si_socram_size(si_t *sih)
 {
 	si_info_t *sii;
 	uint origidx;
@@ -2682,7 +2682,7 @@ uint32 si_socram_size(si_t * sih)
 	return memsize;
 }
 
-void si_chipcontrl_epa4331(si_t * sih, bool on)
+void si_chipcontrl_epa4331(si_t *sih, bool on)
 {
 	si_info_t *sii;
 	chipcregs_t *cc;
@@ -2716,7 +2716,7 @@ void si_chipcontrl_epa4331(si_t * sih, b
 }
 
 /* Enable BT-COEX & Ex-PA for 4313 */
-void si_epa_4313war(si_t * sih)
+void si_epa_4313war(si_t *sih)
 {
 	si_info_t *sii;
 	chipcregs_t *cc;
@@ -2735,7 +2735,7 @@ void si_epa_4313war(si_t * sih)
 }
 
 /* check if the device is removed */
-bool si_deviceremoved(si_t * sih)
+bool si_deviceremoved(si_t *sih)
 {
 	uint32 w;
 	si_info_t *sii;
@@ -2753,7 +2753,7 @@ bool si_deviceremoved(si_t * sih)
 	return FALSE;
 }
 
-bool si_is_sprom_available(si_t * sih)
+bool si_is_sprom_available(si_t *sih)
 {
 	if (sih->ccrev >= 31) {
 		si_info_t *sii;
@@ -2790,7 +2790,7 @@ bool si_is_sprom_available(si_t * sih)
 	}
 }
 
-bool si_is_otp_disabled(si_t * sih)
+bool si_is_otp_disabled(si_t *sih)
 {
 	switch (CHIPID(sih->chip)) {
 	case BCM4329_CHIP_ID:
@@ -2818,14 +2818,14 @@ bool si_is_otp_disabled(si_t * sih)
 	}
 }
 
-bool si_is_otp_powered(si_t * sih)
+bool si_is_otp_powered(si_t *sih)
 {
 	if (PMUCTL_ENAB(sih))
 		return si_pmu_is_otp_powered(sih, si_osh(sih));
 	return TRUE;
 }
 
-void si_otp_power(si_t * sih, bool on)
+void si_otp_power(si_t *sih, bool on)
 {
 	if (PMUCTL_ENAB(sih))
 		si_pmu_otp_power(sih, si_osh(sih), on);
@@ -2834,9 +2834,9 @@ void si_otp_power(si_t * sih, bool on)
 
 bool
 #if defined(BCMDBG)
-si_is_sprom_enabled(si_t * sih)
+si_is_sprom_enabled(si_t *sih)
 #else
-BCMATTACHFN(si_is_sprom_enabled) (si_t * sih)
+BCMATTACHFN(si_is_sprom_enabled) (si_t *sih)
 #endif
 {
 
@@ -2845,9 +2845,9 @@ BCMATTACHFN(si_is_sprom_enabled) (si_t *
 
 void
 #if defined(BCMDBG)
-si_sprom_enable(si_t * sih, bool enable)
+si_sprom_enable(si_t *sih, bool enable)
 #else
-BCMATTACHFN(si_sprom_enable) (si_t * sih, bool enable)
+BCMATTACHFN(si_sprom_enable) (si_t *sih, bool enable)
 #endif
 {
 	if (PMUCTL_ENAB(sih))
@@ -2855,7 +2855,7 @@ BCMATTACHFN(si_sprom_enable) (si_t * sih
 }
 
 /* Return BCME_NOTFOUND if the card doesn't have CIS format nvram */
-int si_cis_source(si_t * sih)
+int si_cis_source(si_t *sih)
 {
 	/* Many chips have the same mapping of their chipstatus field */
 	static const uint cis_sel[] =
--- a/drivers/staging/brcm80211/util/siutils_priv.h
+++ b/drivers/staging/brcm80211/util/siutils_priv.h
@@ -18,15 +18,15 @@
 #define	_siutils_priv_h_
 
 /* Silicon Backplane externs */
-extern void sb_scan(si_t * sih, void *regs, uint devid);
-uint sb_coreid(si_t * sih);
-uint sb_corerev(si_t * sih);
-extern uint sb_corereg(si_t * sih, uint coreidx, uint regoff, uint mask,
+extern void sb_scan(si_t *sih, void *regs, uint devid);
+uint sb_coreid(si_t *sih);
+uint sb_corerev(si_t *sih);
+extern uint sb_corereg(si_t *sih, uint coreidx, uint regoff, uint mask,
 		       uint val);
-extern bool sb_iscoreup(si_t * sih);
-void *sb_setcoreidx(si_t * sih, uint coreidx);
+extern bool sb_iscoreup(si_t *sih);
+void *sb_setcoreidx(si_t *sih, uint coreidx);
 extern uint32 sb_base(uint32 admatch);
-extern void sb_core_reset(si_t * sih, uint32 bits, uint32 resetbits);
-extern void sb_core_disable(si_t * sih, uint32 bits);
-extern bool sb_taclear(si_t * sih, bool details);
+extern void sb_core_reset(si_t *sih, uint32 bits, uint32 resetbits);
+extern void sb_core_disable(si_t *sih, uint32 bits);
+extern bool sb_taclear(si_t *sih, bool details);
 #endif				/* _siutils_priv_h_ */

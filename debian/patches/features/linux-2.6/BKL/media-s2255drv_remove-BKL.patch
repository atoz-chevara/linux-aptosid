commit a19a5cd7b328ae457f79092e711d4bd888e1ca50
Author: Pete Eberlein <pete@sensoray.com>
Date:   Mon Dec 20 19:18:59 2010 -0300

    [media] s2255drv: remove BKL
    
    Remove BKL ioctl and use unlocked_ioctl with core-assisted locking instead.
    
    Signed-off-by: Pete Eberlein <pete@sensoray.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

--- a/drivers/media/video/s2255drv.c
+++ b/drivers/media/video/s2255drv.c
@@ -268,7 +268,7 @@ struct s2255_dev {
 	struct v4l2_device 	v4l2_dev;
 	atomic_t                num_channels;
 	int			frames;
-	struct mutex		lock;
+	struct mutex		lock;	/* channels[].vdev.lock */
 	struct mutex		open_lock;
 	struct usb_device	*udev;
 	struct usb_interface	*interface;
@@ -780,20 +780,14 @@ static struct videobuf_queue_ops s2255_v
 
 static int res_get(struct s2255_fh *fh)
 {
-	struct s2255_dev *dev = fh->dev;
-	/* is it free? */
 	struct s2255_channel *channel = fh->channel;
-	mutex_lock(&dev->lock);
-	if (channel->resources) {
-		/* no, someone else uses it */
-		mutex_unlock(&dev->lock);
-		return 0;
-	}
+	/* is it free? */
+	if (channel->resources)
+		return 0; /* no, someone else uses it */
 	/* it's free, grab it */
 	channel->resources = 1;
 	fh->resources = 1;
 	dprintk(1, "s2255: res: get\n");
-	mutex_unlock(&dev->lock);
 	return 1;
 }
 
@@ -811,11 +805,8 @@ static int res_check(struct s2255_fh *fh
 static void res_free(struct s2255_fh *fh)
 {
 	struct s2255_channel *channel = fh->channel;
-	struct s2255_dev *dev = fh->dev;
-	mutex_lock(&dev->lock);
 	channel->resources = 0;
 	fh->resources = 0;
-	mutex_unlock(&dev->lock);
 	dprintk(1, "res: put\n");
 }
 
@@ -1218,7 +1209,6 @@ static int s2255_set_mode(struct s2255_c
 	__le32 *buffer;
 	unsigned long chn_rev;
 	struct s2255_dev *dev = to_s2255_dev(channel->vdev.v4l2_dev);
-	mutex_lock(&dev->lock);
 	chn_rev = G_chnmap[channel->idx];
 	dprintk(3, "%s channel: %d\n", __func__, channel->idx);
 	/* if JPEG, set the quality */
@@ -1235,7 +1225,6 @@ static int s2255_set_mode(struct s2255_c
 	buffer = kzalloc(512, GFP_KERNEL);
 	if (buffer == NULL) {
 		dev_err(&dev->udev->dev, "out of mem\n");
-		mutex_unlock(&dev->lock);
 		return -ENOMEM;
 	}
 	/* set the mode */
@@ -1260,7 +1249,6 @@ static int s2255_set_mode(struct s2255_c
 	}
 	/* clear the restart flag */
 	channel->mode.restart = 0;
-	mutex_unlock(&dev->lock);
 	dprintk(1, "%s chn %d, result: %d\n", __func__, channel->idx, res);
 	return res;
 }
@@ -1271,13 +1259,11 @@ static int s2255_cmd_status(struct s2255
 	__le32 *buffer;
 	u32 chn_rev;
 	struct s2255_dev *dev = to_s2255_dev(channel->vdev.v4l2_dev);
-	mutex_lock(&dev->lock);
 	chn_rev = G_chnmap[channel->idx];
 	dprintk(4, "%s chan %d\n", __func__, channel->idx);
 	buffer = kzalloc(512, GFP_KERNEL);
 	if (buffer == NULL) {
 		dev_err(&dev->udev->dev, "out of mem\n");
-		mutex_unlock(&dev->lock);
 		return -ENOMEM;
 	}
 	/* form the get vid status command */
@@ -1297,7 +1283,6 @@ static int s2255_cmd_status(struct s2255
 	}
 	*pstatus = channel->vidstatus;
 	dprintk(4, "%s, vid status %d\n", __func__, *pstatus);
-	mutex_unlock(&dev->lock);
 	return res;
 }
 
@@ -1816,7 +1801,8 @@ static int s2255_open(struct file *file)
 				    NULL, &dev->slock,
 				    fh->type,
 				    V4L2_FIELD_INTERLACED,
-				    sizeof(struct s2255_buffer), fh, NULL);
+				    sizeof(struct s2255_buffer),
+				    fh, vdev->lock);
 	return 0;
 }
 
@@ -1899,7 +1885,7 @@ static const struct v4l2_file_operations
 	.open = s2255_open,
 	.release = s2255_release,
 	.poll = s2255_poll,
-	.ioctl = video_ioctl2,	/* V4L2 ioctl handler */
+	.unlocked_ioctl = video_ioctl2,	/* V4L2 ioctl handler */
 	.mmap = s2255_mmap_v4l,
 };
 
@@ -1969,6 +1955,7 @@ static int s2255_probe_v4l(struct s2255_
 		channel->vidq.dev = dev;
 		/* register 4 video devices */
 		channel->vdev = template;
+		channel->vdev.lock = &dev->lock;
 		channel->vdev.v4l2_dev = &dev->v4l2_dev;
 		video_set_drvdata(&channel->vdev, channel);
 		if (video_nr == -1)
@@ -2675,7 +2662,9 @@ static void s2255_disconnect(struct usb_
 	struct s2255_dev *dev = to_s2255_dev(usb_get_intfdata(interface));
 	int i;
 	int channels = atomic_read(&dev->num_channels);
+	mutex_lock(&dev->lock);
 	v4l2_device_disconnect(&dev->v4l2_dev);
+	mutex_unlock(&dev->lock);
 	/*see comments in the uvc_driver.c usb disconnect function */
 	atomic_inc(&dev->num_channels);
 	/* unregister each video device. */

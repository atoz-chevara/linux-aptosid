From bd2240d7031e8fd77643d3b609f2b57eda1296da Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sun, 16 Feb 2014 13:25:43 -0600
Subject: [PATCH 190/210] rtl8192du: Convert Adapter to adapter

This commit also includes some cleanup of the firmware download code
in preparation for placing fw in external file.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_ap.c            |   79 +-
 core/rtw_efuse.c         |  150 +--
 core/rtw_ioctl_set.c     |   20 +-
 core/rtw_mlme.c          |    8 +-
 core/rtw_mlme_ext.c      |    2 +-
 core/rtw_pwrctrl.c       |   16 +-
 core/rtw_wlan_util.c     |   16 +-
 hal/hal_com.c            |    2 +-
 hal/rtl8192d_cmd.c       |   68 +-
 hal/rtl8192d_dm.c        |  662 +++++++-------
 hal/rtl8192d_hal_init.c  |  515 +++++------
 hal/rtl8192d_phycfg.c    | 2262 ++++++++++++++++++++++-----------------------
 hal/rtl8192d_rf6052.c    |  112 +--
 hal/usb_halinit.c        | 1556 +++++++++++++++----------------
 hal/usb_ops_linux.c      |    4 +-
 include/Hal8192DPhyCfg.h |   94 +-
 include/basic_types.h    |    8 +-
 include/h2clbk.h         |    6 +-
 include/hal_com.h        |    2 +-
 include/hal_intf.h       |  108 +--
 include/rtl8192d_cmd.h   |    4 +-
 include/rtl8192d_dm.h    |   10 +-
 include/rtl8192d_hal.h   |   22 +-
 include/rtl8192d_rf.h    |   14 +-
 include/rtw_efuse.h      |   26 +-
 include/rtw_io.h         |    2 +-
 include/rtw_ioctl.h      |    4 +-
 include/rtw_mlme_ext.h   |    6 +-
 include/rtw_mp.h         |   84 +-
 include/rtw_pwrctrl.h    |    4 +-
 include/usb_hal.h        |    4 +-
 os_dep/ioctl_linux.c     | 2266 +++++++++++++++++++---------------------------
 os_dep/os_intfs.c        |   19 +-
 os_dep/usb_intf.c        |   10 +-
 34 files changed, 3831 insertions(+), 4334 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_ap.c
+++ b/drivers/staging/rtl8192du/core/rtw_ap.c
@@ -24,7 +24,6 @@
 #include <drv_types.h>
 #include <wifi.h>
 
-
 #ifdef CONFIG_AP_MODE
 
 void init_mlme_ap_info(struct rtw_adapter *padapter)
@@ -34,13 +33,11 @@ void init_mlme_ap_info(struct rtw_adapte
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
 
-
 	_rtw_spinlock_init(&pmlmepriv->bcn_update_lock);
 
 	/* for ACL */
 	_rtw_init_queue(&pacl_list->acl_node_q);
 
-
 	start_ap_mode(padapter);
 }
 
@@ -52,7 +49,6 @@ void free_mlme_ap_info(struct rtw_adapte
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-
 	pmlmepriv->update_bcn = false;
 	pmlmeext->bstart_bss = false;
 
@@ -127,7 +123,6 @@ static void update_BCNTIM(struct rtw_ada
 			dst_ie = pie + offset;
 		}
 
-
 		if (remainder_ielen > 0) {
 			pbackup_remainder_ie = rtw_malloc(remainder_ielen);
 			if (pbackup_remainder_ie && premainder_ie)
@@ -329,7 +324,6 @@ void	expire_timeout_chk(struct rtw_adapt
 
 	psta = NULL;
 
-
 	spin_lock_bh(&pstapriv->asoc_list_lock);
 
 	phead = &pstapriv->asoc_list;
@@ -475,7 +469,6 @@ void	expire_timeout_chk(struct rtw_adapt
 	associated_clients_update(padapter, updated);
 }
 
-
 static void add_RATid(struct rtw_adapter *padapter, struct sta_info *psta)
 {
 	int i;
@@ -488,7 +481,6 @@ static void add_RATid(struct rtw_adapter
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct wlan_bssid_ex *pcur_network = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;
 
-
 	if (psta)
 		psta_ht = &psta->htpriv;
 	else
@@ -585,7 +577,6 @@ static void update_bmc_sta(struct rtw_ad
 
 		memset((void *)&psta->sta_stats, 0, sizeof(struct stainfo_stats));
 
-
 		/* prepare for add_RATid */
 		supportRateNum = rtw_get_rateset_len((u8 *)&pcur_network->SupportedRates);
 		network_type = rtw_check_network_type((u8 *)&pcur_network->SupportedRates, supportRateNum, 1);
@@ -663,7 +654,6 @@ void update_sta_info_apmode(struct rtw_a
 	else
 		psta->ieee8021x_blocked = false;
 
-
 	/* update sta's cap */
 
 	/* ERP */
@@ -701,15 +691,12 @@ void update_sta_info_apmode(struct rtw_a
 	phtpriv_sta->agg_enable_bitmap = 0x0;/* reset */
 	phtpriv_sta->candidate_tid_bitmap = 0x0;/* reset */
 
-
 	/* todo: init other variables */
 
 	memset((void *)&psta->sta_stats, 0, sizeof(struct stainfo_stats));
 
-
 	/* add ratid */
 
-
 	spin_lock_bh(&psta->lock);
 	psta->state |= _FW_LINKED;
 	spin_unlock_bh(&psta->lock);
@@ -725,7 +712,6 @@ static void update_hw_ht_param(struct rt
 
 	DBG_8192D("%s\n", __func__);
 
-
 	/* handle A-MPDU parameter field */
 	/*
 		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
@@ -773,7 +759,6 @@ static void start_bss_network(struct rtw
 	cur_bwmode = HT_CHANNEL_WIDTH_20;;
 	cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 
-
 	/* check if there is wps ie, */
 	/* if there is wpsie in beacon, the hostapd will update beacon twice when stating hostapd, */
 	/* and at first time the security ie (RSN/WPA IE) will not include in beacon. */
@@ -793,7 +778,6 @@ static void start_bss_network(struct rtw
 		update_hw_ht_param(padapter);
 	}
 
-
 	if (pmlmepriv->cur_network.join_res != true) { /* setting only at  first time */
 		/* WEP Key will be set before this function, do not clear CAM. */
 		if ((psecuritypriv->dot11PrivacyAlgrthm != _WEP40_) && (psecuritypriv->dot11PrivacyAlgrthm != _WEP104_))
@@ -832,7 +816,6 @@ static void start_bss_network(struct rtw
 
 		initialgain = 0x1e;
 
-
 		/* disable dynamic functions, such as high power, DIG */
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -1038,7 +1021,6 @@ int rtw_check_beacon_data(struct rtw_ada
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	u8 *ie = pbss_network->IEs;
 
-
 	/* SSID */
 	/* Supported rates */
 	/* DS Params */
@@ -1064,7 +1046,6 @@ int rtw_check_beacon_data(struct rtw_ada
 
 	memcpy(ie, pbuf, pbss_network->IELength);
 
-
 	if (pbss_network->InfrastructureMode != NDIS802_11APMODE)
 		return _FAIL;
 
@@ -1097,7 +1078,6 @@ int rtw_check_beacon_data(struct rtw_ada
 
 	pbss_network->Configuration.DSConfig = channel;
 
-
 	memset(supportRate, 0, NDIS_802_11_LENGTH_RATES_EX);
 	/*  get supported rates */
 	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _SUPPORTEDRATES_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
@@ -1117,7 +1097,6 @@ int rtw_check_beacon_data(struct rtw_ada
 
 	rtw_set_supported_rate(pbss_network->SupportedRates, network_type);
 
-
 	/* parsing ERP_IE */
 	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _ERPINFO_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
 	if (p && ie_len > 0)
@@ -1206,11 +1185,9 @@ int rtw_check_beacon_data(struct rtw_ada
 
 		pHT_caps_ie = p;
 
-
 		ht_cap = true;
 		network_type |= WIRELESS_11_24N;
 
-
 		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
 		if ((psecuritypriv->wpa_pairwise_cipher & WPA_CIPHER_CCMP) ||
@@ -1254,7 +1231,6 @@ int rtw_check_beacon_data(struct rtw_ada
 
 	pmlmepriv->cur_network.network_type = network_type;
 
-
 	pmlmepriv->htpriv.ht_option = false;
 #ifdef CONFIG_80211N_HT
 	/* ht_cap */
@@ -1271,13 +1247,11 @@ int rtw_check_beacon_data(struct rtw_ada
 	}
 #endif
 
-
 	pbss_network->Length = get_wlan_bssid_ex_sz((struct wlan_bssid_ex  *)pbss_network);
 
 	/* issue beacon to start bss network */
 	start_bss_network(padapter, (u8 *)pbss_network);
 
-
 	/* alloc sta_info for ap itself */
 	psta = rtw_get_stainfo(&padapter->stapriv, pbss_network->MacAddress);
 	if (!psta) {
@@ -1320,7 +1294,6 @@ int rtw_acl_add_sta(struct rtw_adapter *
 	if ((NUM_ACL-1) < pacl_list->num)
 		return -1;
 
-
 	spin_lock_bh(&(pacl_node_q->lock));
 
 	phead = get_list_head(pacl_node_q);
@@ -1341,11 +1314,9 @@ int rtw_acl_add_sta(struct rtw_adapter *
 
 	spin_unlock_bh(&(pacl_node_q->lock));
 
-
 	if (added)
 		return ret;
 
-
 	spin_lock_bh(&(pacl_node_q->lock));
 
 	for (i = 0; i < NUM_ACL; i++) {
@@ -1487,7 +1458,6 @@ static void update_bcn_wps_ie(struct rtw
 	unsigned char *ie = pnetwork->IEs;
 	u32 ielen = pnetwork->IELength;
 
-
 	DBG_8192D("%s\n", __func__);
 
 	pwps_ie = rtw_get_wps_ie(ie+_FIXED_IE_LENGTH_, ielen-_FIXED_IE_LENGTH_, NULL, &wps_ielen);
@@ -1507,12 +1477,10 @@ static void update_bcn_wps_ie(struct rtw
 			memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
 	}
 
-
 	pwps_ie_src = pmlmepriv->wps_beacon_ie;
 	if (pwps_ie_src == NULL)
 		return;
 
-
 	wps_ielen = (uint)pwps_ie_src[1];/* to get ie data len */
 	if ((wps_offset+wps_ielen+2+remainder_ielen) <= MAX_IE_SZ) {
 		memcpy(pwps_ie, pwps_ie_src, wps_ielen+2);
@@ -1717,7 +1685,6 @@ void bss_cap_update_on_sta_join(struct r
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
 
-
 	if (!(psta->flags & WLAN_STA_SHORT_PREAMBLE)) {
 		if (!psta->no_short_preamble_set) {
 			psta->no_short_preamble_set = 1;
@@ -1800,7 +1767,8 @@ void bss_cap_update_on_sta_join(struct r
 	if (psta->flags & WLAN_STA_HT) {
 		u16 ht_capab = psta->htpriv.ht_cap.cap_info;
 
-		DBG_8192D("HT: STA %pM HT Capabilities Info: 0x%04x\n", psta->hwaddr, ht_capab);
+		DBG_8192D("HT: STA %pM HT Capabilities Info: 0x%04x\n",
+			  psta->hwaddr, ht_capab);
 
 		if (psta->no_ht_set) {
 			psta->no_ht_set = 0;
@@ -1852,7 +1820,8 @@ void bss_cap_update_on_sta_join(struct r
 	DBG_8192D("%s, updated =%d\n", __func__, beacon_updated);
 }
 
-u8 bss_cap_update_on_sta_leave(struct rtw_adapter *padapter, struct sta_info *psta)
+u8 bss_cap_update_on_sta_leave(struct rtw_adapter *padapter,
+			       struct sta_info *psta)
 {
 	u8 beacon_updated = false;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -1921,7 +1890,8 @@ u8 bss_cap_update_on_sta_leave(struct rt
 	return beacon_updated;
 }
 
-u8 ap_free_sta(struct rtw_adapter *padapter, struct sta_info *psta, bool active, u16 reason)
+u8 ap_free_sta(struct rtw_adapter *padapter, struct sta_info *psta,
+	       bool active, u16 reason)
 {
 	u8 beacon_updated = false;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -1931,7 +1901,6 @@ u8 ap_free_sta(struct rtw_adapter *padap
 	if (!psta)
 		return beacon_updated;
 
-
 	/* tear down Rx AMPDU */
 	send_delba(padapter, 0, psta->hwaddr);/*  recipient */
 
@@ -1946,7 +1915,6 @@ u8 ap_free_sta(struct rtw_adapter *padap
 	/* clear cam entry / key */
 	rtw_clearstakey_cmd(padapter, (u8 *)psta, (u8)(psta->mac_id + 3), true);
 
-
 	spin_lock_bh(&psta->lock);
 	psta->state &= ~_FW_LINKED;
 	spin_unlock_bh(&psta->lock);
@@ -1956,10 +1924,9 @@ u8 ap_free_sta(struct rtw_adapter *padap
 		#ifdef COMPAT_KERNEL_RELEASE
 		rtw_cfg80211_indicate_sta_disassoc(padapter, psta->hwaddr, reason);
 		#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
-		rtw_cfg80211_indicate_sta_disassoc(padapter, psta->hwaddr, reason);
-		#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
-		/* will call rtw_cfg80211_indicate_sta_disassoc() in cmd_thread for old API context */
-		#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
+		rtw_cfg80211_indicate_sta_disassoc(padapter, psta->hwaddr,
+						   reason);
+		#endif
 	} else
 	#endif /* CONFIG_IOCTL_CFG80211 */
 	{
@@ -1976,7 +1943,8 @@ u8 ap_free_sta(struct rtw_adapter *padap
 	return beacon_updated;
 }
 
-int rtw_ap_inform_ch_switch (struct rtw_adapter *padapter, u8 new_ch, u8 ch_offset)
+int rtw_ap_inform_ch_switch(struct rtw_adapter *padapter, u8 new_ch,
+			    u8 ch_offset)
 {
 	struct list_head *phead, *plist;
 	int ret = 0;
@@ -2001,12 +1969,14 @@ int rtw_ap_inform_ch_switch (struct rtw_
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 		plist = get_next(plist);
 
-		issue_action_spct_ch_switch (padapter, psta->hwaddr, new_ch, ch_offset);
-		psta->expire_to = ((pstapriv->expire_to * 2) > 5) ? 5 : (pstapriv->expire_to * 2);
+		issue_action_spct_ch_switch(padapter, psta->hwaddr, new_ch,
+					    ch_offset);
+		psta->expire_to = ((pstapriv->expire_to * 2) > 5) ? 5 :
+				  (pstapriv->expire_to * 2);
 	}
 	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
-	issue_action_spct_ch_switch (padapter, bc_addr, new_ch, ch_offset);
+	issue_action_spct_ch_switch(padapter, bc_addr, new_ch, ch_offset);
 
 	return ret;
 }
@@ -2026,7 +1996,6 @@ int rtw_sta_flush(struct rtw_adapter *pa
 	if ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
 		return ret;
 
-
 	spin_lock_bh(&pstapriv->asoc_list_lock);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
@@ -2083,7 +2052,8 @@ void sta_info_update(struct rtw_adapter
 }
 
 /* called >= TSR LEVEL for USB or SDIO Interface*/
-void ap_sta_info_defer_update(struct rtw_adapter *padapter, struct sta_info *psta)
+void ap_sta_info_defer_update(struct rtw_adapter *padapter,
+			      struct sta_info *psta)
 {
 	if (psta->state & _FW_LINKED) {
 		/* add ratid */
@@ -2124,7 +2094,6 @@ void start_ap_mode(struct rtw_adapter *p
 	pmlmepriv->p2p_beacon_ie = NULL;
 	pmlmepriv->p2p_probe_resp_ie = NULL;
 
-
 	/* for ACL */
 	INIT_LIST_HEAD(&(pacl_list->acl_node_q.queue));
 	pacl_list->num = 0;
@@ -2149,8 +2118,10 @@ void stop_ap_mode(struct rtw_adapter *pa
 	pmlmepriv->update_bcn = false;
 	pmlmeext->bstart_bss = false;
 
-	/* reset and init security priv , this can refine with rtw_reset_securitypriv */
-	memset((unsigned char *)&padapter->securitypriv, 0, sizeof(struct security_priv));
+	/* reset and init security priv , this can refine with
+	 * rtw_reset_securitypriv */
+	memset((unsigned char *)&padapter->securitypriv, 0,
+	       sizeof(struct security_priv));
 	padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEOPEN;
 	padapter->securitypriv.ndisencryptstatus = NDIS802_11WEPDISABLED;
 
@@ -2159,7 +2130,8 @@ void stop_ap_mode(struct rtw_adapter *pa
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
 	while (!rtw_end_of_queue_search(phead, plist)) {
-		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
+		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node,
+					  list);
 		plist = get_next(plist);
 
 		if (paclnode->valid) {
@@ -2172,7 +2144,8 @@ void stop_ap_mode(struct rtw_adapter *pa
 	}
 	spin_unlock_bh(&(pacl_node_q->lock));
 
-	DBG_8192D("%s, free acl_node_queue, num =%d\n", __func__, pacl_list->num);
+	DBG_8192D("%s, free acl_node_queue, num =%d\n", __func__,
+		  pacl_list->num);
 
 	rtw_sta_flush(padapter);
 
--- a/drivers/staging/rtl8192du/core/rtw_efuse.c
+++ b/drivers/staging/rtl8192du/core/rtw_efuse.c
@@ -47,7 +47,7 @@ u8 fakeBTEfuseModifiedMap[EFUSE_BT_MAX_M
 #define EFUSE_CTRL			REG_EFUSE_CTRL		/*  E-Fuse Control. */
 /*  */
 
-static bool Efuse_Read1ByteFromFakeContent(struct rtw_adapter *pAdapter, u16 Offset, u8 *value)
+static bool Efuse_Read1ByteFromFakeContent(struct rtw_adapter *adapter, u16 Offset, u8 *value)
 {
 	if (Offset >= EFUSE_MAX_HW_SIZE)
 		return false;
@@ -58,7 +58,7 @@ static bool Efuse_Read1ByteFromFakeConte
 	return true;
 }
 
-static bool Efuse_Write1ByteToFakeContent(struct rtw_adapter *pAdapter, u16 Offset, u8 value)
+static bool Efuse_Write1ByteToFakeContent(struct rtw_adapter *adapter, u16 Offset, u8 value)
 {
 	if (Offset >= EFUSE_MAX_HW_SIZE)
 		return false;
@@ -87,9 +87,9 @@ static bool Efuse_Write1ByteToFakeConten
  * 11/17/2008	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-void Efuse_PowerSwitch(struct rtw_adapter *pAdapter, u8 write, u8 pwrstate)
+void Efuse_PowerSwitch(struct rtw_adapter *adapter, u8 write, u8 pwrstate)
 {
-	pAdapter->HalFunc.EfusePowerSwitch(pAdapter, write, pwrstate);
+	adapter->HalFunc.EfusePowerSwitch(adapter, write, pwrstate);
 }
 
 /*-----------------------------------------------------------------------------
@@ -108,11 +108,11 @@ void Efuse_PowerSwitch(struct rtw_adapte
  * 11/16/2008	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-u16 Efuse_GetCurrentSize(struct rtw_adapter *pAdapter, u8 efusetype, bool test)
+u16 Efuse_GetCurrentSize(struct rtw_adapter *adapter, u8 efusetype, bool test)
 {
 	u16 ret = 0;
 
-	ret = pAdapter->HalFunc.EfuseGetCurrentSize(pAdapter, efusetype, test);
+	ret = adapter->HalFunc.EfuseGetCurrentSize(adapter, efusetype, test);
 
 	return ret;
 }
@@ -144,31 +144,31 @@ Efuse_CalculateWordCnts(u8 word_en)
 /*  */
 /*	Created by Roger, 2008.10.21. */
 /*  */
-void ReadEFuseByte(struct rtw_adapter *Adapter, u16 _offset, u8 *pbuf, bool test)
+void ReadEFuseByte(struct rtw_adapter *adapter, u16 _offset, u8 *pbuf, bool test)
 {
 	u32 value32;
 	u8 readbyte;
 	u16 retry;
 
 	if (test) {
-		Efuse_Read1ByteFromFakeContent(Adapter, _offset, pbuf);
+		Efuse_Read1ByteFromFakeContent(adapter, _offset, pbuf);
 		return;
 	}
 
 	/* Write Address */
-	rtw_write8(Adapter, EFUSE_CTRL+1, (_offset & 0xff));
-	readbyte = rtw_read8(Adapter, EFUSE_CTRL+2);
-	rtw_write8(Adapter, EFUSE_CTRL+2, ((_offset >> 8) & 0x03) | (readbyte & 0xfc));
+	rtw_write8(adapter, EFUSE_CTRL+1, (_offset & 0xff));
+	readbyte = rtw_read8(adapter, EFUSE_CTRL+2);
+	rtw_write8(adapter, EFUSE_CTRL+2, ((_offset >> 8) & 0x03) | (readbyte & 0xfc));
 
 	/* Write bit 32 0 */
-	readbyte = rtw_read8(Adapter, EFUSE_CTRL+3);
-	rtw_write8(Adapter, EFUSE_CTRL+3, (readbyte & 0x7f));
+	readbyte = rtw_read8(adapter, EFUSE_CTRL+3);
+	rtw_write8(adapter, EFUSE_CTRL+3, (readbyte & 0x7f));
 
 	/* Check bit 32 read-ready */
 	retry = 0;
-	value32 = rtw_read32(Adapter, EFUSE_CTRL);
+	value32 = rtw_read32(adapter, EFUSE_CTRL);
 	while (!(((value32 >> 24) & 0xff) & 0x80) && (retry < 10000)) {
-		value32 = rtw_read32(Adapter, EFUSE_CTRL);
+		value32 = rtw_read32(adapter, EFUSE_CTRL);
 		retry++;
 	}
 
@@ -177,7 +177,7 @@ void ReadEFuseByte(struct rtw_adapter *A
 	/*  Designer says that there shall be some delay after ready bit is set, or the */
 	/*  result will always stay on last data we read. */
 	rtw_udelay_os(50);
-	value32 = rtw_read32(Adapter, EFUSE_CTRL);
+	value32 = rtw_read32(adapter, EFUSE_CTRL);
 
 	*pbuf = (u8)(value32 & 0xff);
 }
@@ -195,14 +195,14 @@ void ReadEFuseByte(struct rtw_adapter *A
 /*	2008/12/22 MH	Read Efuse must check if we write section 1 data again!!! Sec1 */
 /*					write addr must be after sec5. */
 
-static void efuse_ReadEFuse(struct rtw_adapter *Adapter, u8 efusetype, u16 _offset, u16 _size_byte, u8 *pbuf, bool test)
+static void efuse_ReadEFuse(struct rtw_adapter *adapter, u8 efusetype, u16 _offset, u16 _size_byte, u8 *pbuf, bool test)
 {
-	Adapter->HalFunc.ReadEFuse(Adapter, efusetype, _offset, _size_byte, pbuf, test);
+	adapter->HalFunc.ReadEFuse(adapter, efusetype, _offset, _size_byte, pbuf, test);
 }
 
-void EFUSE_GetEfuseDefinition(struct rtw_adapter *pAdapter, u8 efusetype, u8 type, void *out, bool test)
+void EFUSE_GetEfuseDefinition(struct rtw_adapter *adapter, u8 efusetype, u8 type, void *out, bool test)
 {
-	pAdapter->HalFunc.EFUSEGetEfuseDefinition(pAdapter, efusetype, type, out, test);
+	adapter->HalFunc.EFUSEGetEfuseDefinition(adapter, efusetype, type, out, test);
 }
 
 /*-----------------------------------------------------------------------------
@@ -221,7 +221,7 @@ void EFUSE_GetEfuseDefinition(struct rtw
  * 09/23/2008	MHC		Copy from WMAC.
  *
  *---------------------------------------------------------------------------*/
-u8 EFUSE_Read1Byte(struct rtw_adapter *Adapter, u16 address)
+u8 EFUSE_Read1Byte(struct rtw_adapter *adapter, u16 address)
 {
 	u8 data;
 	u8 bytetemp = {0x00};
@@ -229,33 +229,33 @@ u8 EFUSE_Read1Byte(struct rtw_adapter *A
 	u32 k = 0;
 	u16 contentlen = 0;
 
-	EFUSE_GetEfuseDefinition(Adapter, EFUSE_WIFI , TYPE_EFUSE_REAL_CONTENT_LEN, (void *)&contentlen, false);
+	EFUSE_GetEfuseDefinition(adapter, EFUSE_WIFI , TYPE_EFUSE_REAL_CONTENT_LEN, (void *)&contentlen, false);
 
 	if (address < contentlen) {	/* E-fuse 512Byte */
 		/* Write E-fuse Register address bit0~7 */
 		temp = address & 0xFF;
-		rtw_write8(Adapter, EFUSE_CTRL+1, temp);
-		bytetemp = rtw_read8(Adapter, EFUSE_CTRL+2);
+		rtw_write8(adapter, EFUSE_CTRL+1, temp);
+		bytetemp = rtw_read8(adapter, EFUSE_CTRL+2);
 		/* Write E-fuse Register address bit8~9 */
 		temp = ((address >> 8) & 0x03) | (bytetemp & 0xFC);
-		rtw_write8(Adapter, EFUSE_CTRL+2, temp);
+		rtw_write8(adapter, EFUSE_CTRL+2, temp);
 
 		/* Write 0x30[31]= 0 */
-		bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);
+		bytetemp = rtw_read8(adapter, EFUSE_CTRL+3);
 		temp = bytetemp & 0x7F;
-		rtw_write8(Adapter, EFUSE_CTRL+3, temp);
+		rtw_write8(adapter, EFUSE_CTRL+3, temp);
 
 		/* Wait Write-ready (0x30[31]= 1) */
-		bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);
+		bytetemp = rtw_read8(adapter, EFUSE_CTRL+3);
 		while (!(bytetemp & 0x80)) {
-			bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);
+			bytetemp = rtw_read8(adapter, EFUSE_CTRL+3);
 			k++;
 			if (k == 1000) {
 				k = 0;
 				break;
 			}
 		}
-		data = rtw_read8(Adapter, EFUSE_CTRL);
+		data = rtw_read8(adapter, EFUSE_CTRL);
 		return data;
 	} else {
 		return 0xFF;
@@ -263,27 +263,27 @@ u8 EFUSE_Read1Byte(struct rtw_adapter *A
 } /* EFUSE_Read1Byte */
 
 /*  11/16/2008 MH Read one byte from real Efuse. */
-u8 efuse_OneByteRead(struct rtw_adapter *pAdapter, u16 addr, u8 *data, bool test)
+u8 efuse_OneByteRead(struct rtw_adapter *adapter, u16 addr, u8 *data, bool test)
 {
 	u8 tmpidx = 0;
 	u8 result;
 
 	if (test) {
-		result = Efuse_Read1ByteFromFakeContent(pAdapter, addr, data);
+		result = Efuse_Read1ByteFromFakeContent(adapter, addr, data);
 		return result;
 	}
 	/*  -----------------e-fuse reg ctrl -------------------------------- */
 	/* address */
-	rtw_write8(pAdapter, EFUSE_CTRL+1, (u8)(addr&0xff));
-	rtw_write8(pAdapter, EFUSE_CTRL+2, ((u8)((addr >> 8) & 0x03)) |
-	(rtw_read8(pAdapter, EFUSE_CTRL+2)&0xFC));
+	rtw_write8(adapter, EFUSE_CTRL+1, (u8)(addr&0xff));
+	rtw_write8(adapter, EFUSE_CTRL+2, ((u8)((addr >> 8) & 0x03)) |
+	(rtw_read8(adapter, EFUSE_CTRL+2)&0xFC));
 
-	rtw_write8(pAdapter, EFUSE_CTRL+3,  0x72);/* read cmd */
+	rtw_write8(adapter, EFUSE_CTRL+3,  0x72);/* read cmd */
 
-	while (!(0x80 & rtw_read8(pAdapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+	while (!(0x80 & rtw_read8(adapter, EFUSE_CTRL+3)) && (tmpidx < 100))
 		tmpidx++;
 	if (tmpidx < 100) {
-		*data = rtw_read8(pAdapter, EFUSE_CTRL);
+		*data = rtw_read8(adapter, EFUSE_CTRL);
 		result = true;
 	} else {
 		*data = 0xff;
@@ -293,26 +293,26 @@ u8 efuse_OneByteRead(struct rtw_adapter
 }
 
 /*  11/16/2008 MH Write one byte to reald Efuse. */
-u8 efuse_OneByteWrite(struct rtw_adapter *pAdapter, u16 addr, u8 data, bool test)
+u8 efuse_OneByteWrite(struct rtw_adapter *adapter, u16 addr, u8 data, bool test)
 {
 	u8 tmpidx = 0;
 	u8 result;
 
 	if (test) {
-		result = Efuse_Write1ByteToFakeContent(pAdapter, addr, data);
+		result = Efuse_Write1ByteToFakeContent(adapter, addr, data);
 		return result;
 	}
 
 	/*  -----------------e-fuse reg ctrl ---------------------------- */
 	/* address */
-	rtw_write8(pAdapter, EFUSE_CTRL+1, (u8)(addr&0xff));
-	rtw_write8(pAdapter, EFUSE_CTRL+2,
-		   (rtw_read8(pAdapter, EFUSE_CTRL+2)&0xFC) | (u8)((addr>>8)&0x03));
-	rtw_write8(pAdapter, EFUSE_CTRL, data);/* data */
+	rtw_write8(adapter, EFUSE_CTRL+1, (u8)(addr&0xff));
+	rtw_write8(adapter, EFUSE_CTRL+2,
+		   (rtw_read8(adapter, EFUSE_CTRL+2)&0xFC) | (u8)((addr>>8)&0x03));
+	rtw_write8(adapter, EFUSE_CTRL, data);/* data */
 
-	rtw_write8(pAdapter, EFUSE_CTRL+3, 0xF2);/* write cmd */
+	rtw_write8(adapter, EFUSE_CTRL+3, 0xF2);/* write cmd */
 
-	while ((0x80 & rtw_read8(pAdapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+	while ((0x80 & rtw_read8(adapter, EFUSE_CTRL+3)) && (tmpidx < 100))
 		tmpidx++;
 
 	if (tmpidx < 100)
@@ -322,20 +322,20 @@ u8 efuse_OneByteWrite(struct rtw_adapter
 	return result;
 }
 
-int Efuse_PgPacketRead(struct rtw_adapter *pAdapter, u8 offset, u8 *data, bool test)
+int Efuse_PgPacketRead(struct rtw_adapter *adapter, u8 offset, u8 *data, bool test)
 {
 	int	ret = 0;
 
-	ret =  pAdapter->HalFunc.Efuse_PgPacketRead(pAdapter, offset, data, test);
+	ret =  adapter->HalFunc.Efuse_PgPacketRead(adapter, offset, data, test);
 	return ret;
 }
 
-int Efuse_PgPacketWrite(struct rtw_adapter *pAdapter, u8 offset, u8 word_en,
+int Efuse_PgPacketWrite(struct rtw_adapter *adapter, u8 offset, u8 word_en,
 			u8 *data, bool test)
 {
 	int ret;
 
-	ret =  pAdapter->HalFunc.Efuse_PgPacketWrite(pAdapter, offset, word_en, data, test);
+	ret =  adapter->HalFunc.Efuse_PgPacketWrite(adapter, offset, word_en, data, test);
 
 	return ret;
 }
@@ -377,12 +377,12 @@ void efuse_WordEnableDataRead(u8 word_en
 	}
 }
 
-u8 Efuse_WordEnableDataWrite(struct rtw_adapter *pAdapter, u16 efuse_addr,
+u8 Efuse_WordEnableDataWrite(struct rtw_adapter *adapter, u16 efuse_addr,
 			     u8 word_en, u8 *data, bool test)
 {
 	u8 ret = 0;
 
-	ret =  pAdapter->HalFunc.Efuse_WordEnableDataWrite(pAdapter, efuse_addr, word_en, data, test);
+	ret =  adapter->HalFunc.Efuse_WordEnableDataWrite(adapter, efuse_addr, word_en, data, test);
 
 	return ret;
 }
@@ -585,14 +585,14 @@ exit:
  * 11/11/2008	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-static void Efuse_ReadAllMap(struct rtw_adapter *pAdapter, u8 efusetype, u8 *efuse, bool test)
+static void Efuse_ReadAllMap(struct rtw_adapter *adapter, u8 efusetype, u8 *efuse, bool test)
 {
 	u16 maplen = 0;
 
-	Efuse_PowerSwitch(pAdapter, false, true);
-	EFUSE_GetEfuseDefinition(pAdapter, efusetype, TYPE_EFUSE_MAP_LEN, (void *)&maplen, test);
-	efuse_ReadEFuse(pAdapter, efusetype, 0, maplen, efuse, test);
-	Efuse_PowerSwitch(pAdapter, false, false);
+	Efuse_PowerSwitch(adapter, false, true);
+	EFUSE_GetEfuseDefinition(adapter, efusetype, TYPE_EFUSE_MAP_LEN, (void *)&maplen, test);
+	efuse_ReadEFuse(adapter, efusetype, 0, maplen, efuse, test);
+	Efuse_PowerSwitch(adapter, false, false);
 }
 
 /*-----------------------------------------------------------------------------
@@ -613,26 +613,26 @@ static void Efuse_ReadAllMap(struct rtw_
  * 11/12/2008	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-static void efuse_ShadowRead1Byte(struct rtw_adapter *pAdapter, u16 Offset, u8 *value)
+static void efuse_ShadowRead1Byte(struct rtw_adapter *adapter, u16 Offset, u8 *value)
 {
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(pAdapter);
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 
 	*value = pEEPROM->efuse_eeprom_data[Offset];
 }	/*  EFUSE_ShadowRead1Byte */
 
 /* Read Two Bytes */
-static void efuse_ShadowRead2Byte(struct rtw_adapter *pAdapter, u16 Offset, u16 *value)
+static void efuse_ShadowRead2Byte(struct rtw_adapter *adapter, u16 Offset, u16 *value)
 {
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(pAdapter);
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 
 	*value = pEEPROM->efuse_eeprom_data[Offset];
 	*value |= pEEPROM->efuse_eeprom_data[Offset+1]<<8;
 }	/*  EFUSE_ShadowRead2Byte */
 
 /* Read Four Bytes */
-static void efuse_ShadowRead4Byte(struct rtw_adapter *pAdapter, u16 Offset, u32 *value)
+static void efuse_ShadowRead4Byte(struct rtw_adapter *adapter, u16 Offset, u32 *value)
 {
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(pAdapter);
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 
 	*value = pEEPROM->efuse_eeprom_data[Offset];
 	*value |= pEEPROM->efuse_eeprom_data[Offset+1]<<8;
@@ -659,26 +659,26 @@ static void efuse_ShadowRead4Byte(struct
  * 11/12/2008	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-static void efuse_ShadowWrite1Byte(struct rtw_adapter *pAdapter, u16 Offset, u8 value)
+static void efuse_ShadowWrite1Byte(struct rtw_adapter *adapter, u16 Offset, u8 value)
 {
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(pAdapter);
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 
 	pEEPROM->efuse_eeprom_data[Offset] = value;
 }	/*  efuse_ShadowWrite1Byte */
 
 /* Write Two Bytes */
-static void efuse_ShadowWrite2Byte(struct rtw_adapter *pAdapter, u16 Offset, u16 value)
+static void efuse_ShadowWrite2Byte(struct rtw_adapter *adapter, u16 Offset, u16 value)
 {
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(pAdapter);
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 
 	pEEPROM->efuse_eeprom_data[Offset] = value&0x00FF;
 	pEEPROM->efuse_eeprom_data[Offset+1] = value>>8;
 }	/*  efuse_ShadowWrite1Byte */
 
 /* Write Four Bytes */
-static void efuse_ShadowWrite4Byte(struct rtw_adapter *pAdapter, u16 Offset, u32 value)
+static void efuse_ShadowWrite4Byte(struct rtw_adapter *adapter, u16 Offset, u32 value)
 {
-	struct eeprom_priv *EEPROM = GET_EEPROM_EFUSE_PRIV(pAdapter);
+	struct eeprom_priv *EEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 
 	EEPROM->efuse_eeprom_data[Offset] = (u8)(value&0x000000FF);
 	EEPROM->efuse_eeprom_data[Offset+1] = (u8)((value>>8)&0x0000FF);
@@ -702,24 +702,24 @@ static void efuse_ShadowWrite4Byte(struc
  * 11/13/2008	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-void EFUSE_ShadowMapUpdate(struct rtw_adapter *pAdapter, u8 efusetype, bool test)
+void EFUSE_ShadowMapUpdate(struct rtw_adapter *adapter, u8 efusetype, bool test)
 {
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(pAdapter);
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 	u16 maplen = 0;
 
-	EFUSE_GetEfuseDefinition(pAdapter, efusetype, TYPE_EFUSE_MAP_LEN, (void *)&maplen, test);
+	EFUSE_GetEfuseDefinition(adapter, efusetype, TYPE_EFUSE_MAP_LEN, (void *)&maplen, test);
 
 	if (pEEPROM->bautoload_fail_flag == true) {
 		memset(pEEPROM->efuse_eeprom_data, 0xFF, maplen);
 	} else {
 		#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
-		if (_SUCCESS != retriveAdaptorInfoFile(pAdapter->registrypriv.adaptor_info_caching_file_path, pEEPROM)) {
+		if (_SUCCESS != retriveAdaptorInfoFile(adapter->registrypriv.adaptor_info_caching_file_path, pEEPROM)) {
 		#endif
 
-			Efuse_ReadAllMap(pAdapter, efusetype, pEEPROM->efuse_eeprom_data, test);
+			Efuse_ReadAllMap(adapter, efusetype, pEEPROM->efuse_eeprom_data, test);
 
 		#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
-			storeAdaptorInfoFile(pAdapter->registrypriv.adaptor_info_caching_file_path, pEEPROM);
+			storeAdaptorInfoFile(adapter->registrypriv.adaptor_info_caching_file_path, pEEPROM);
 		}
 		#endif
 	}
--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -670,20 +670,20 @@ _func_enter_;
 		stainfo = rtw_get_stainfo(&padapter->stapriv, pbssid);
 
 		if ((stainfo != NULL) && (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)) {
-			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY:(stainfo != NULL) && (Adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)\n"));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY:(stainfo != NULL) && (adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)\n"));
 			encryptionalgo = stainfo->dot118021XPrivacy;
 		} else {
-			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: stainfo == NULL)||(Adapter->securitypriv.dot11AuthAlgrthm!= dot11AuthAlgrthm_8021X)\n"));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: stainfo == NULL)||(adapter->securitypriv.dot11AuthAlgrthm!= dot11AuthAlgrthm_8021X)\n"));
 			encryptionalgo = padapter->securitypriv.dot11PrivacyAlgrthm;
 		}
 
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 			 ("rtw_set_802_11_add_key: (encryptionalgo ==%d)!\n", encryptionalgo));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
-			 ("rtw_set_802_11_add_key: (Adapter->securitypriv.dot11PrivacyAlgrthm ==%d)!\n",
+			 ("rtw_set_802_11_add_key: (adapter->securitypriv.dot11PrivacyAlgrthm ==%d)!\n",
 			 padapter->securitypriv.dot11PrivacyAlgrthm));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
-			 ("rtw_set_802_11_add_key: (Adapter->securitypriv.dot11AuthAlgrthm ==%d)!\n",
+			 ("rtw_set_802_11_add_key: (adapter->securitypriv.dot11AuthAlgrthm ==%d)!\n",
 			 padapter->securitypriv.dot11AuthAlgrthm));
 
 		if ((stainfo != NULL))
@@ -752,7 +752,7 @@ _func_enter_;
 		if ((padapter->securitypriv.ndisauthtype <= 3) &&
 		    (padapter->securitypriv.dot118021XGrpPrivacy == 0)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
-				 ("keylen=%d(Adapter->securitypriv.dot11PrivacyAlgrthm =%x )padapter->securitypriv.dot118021XGrpPrivacy(%x)\n",
+				 ("keylen=%d(adapter->securitypriv.dot11PrivacyAlgrthm =%x )padapter->securitypriv.dot118021XGrpPrivacy(%x)\n",
 				 key->KeyLength, padapter->securitypriv.dot11PrivacyAlgrthm,
 				 padapter->securitypriv.dot118021XGrpPrivacy));
 
@@ -760,31 +760,31 @@ _func_enter_;
 			case 5:
 				padapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;
 				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
-					 ("Adapter->securitypriv.dot11PrivacyAlgrthm = %x key->KeyLength=%u\n",
+					 ("adapter->securitypriv.dot11PrivacyAlgrthm = %x key->KeyLength=%u\n",
 					 padapter->securitypriv.dot11PrivacyAlgrthm, key->KeyLength));
 				break;
 			case 13:
 				padapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;
 				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
-					 ("Adapter->securitypriv.dot11PrivacyAlgrthm = %x key->KeyLength=%u\n",
+					 ("adapter->securitypriv.dot11PrivacyAlgrthm = %x key->KeyLength=%u\n",
 					 padapter->securitypriv.dot11PrivacyAlgrthm, key->KeyLength));
 				break;
 			default:
 				padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
 				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
-					 ("Adapter->securitypriv.dot11PrivacyAlgrthm = %x key->KeyLength=%u\n",
+					 ("adapter->securitypriv.dot11PrivacyAlgrthm = %x key->KeyLength=%u\n",
 					 padapter->securitypriv.dot11PrivacyAlgrthm, key->KeyLength));
 				break;
 			}
 			encryptionalgo = padapter->securitypriv.dot11PrivacyAlgrthm;
 
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
-				 (" Adapter->securitypriv.dot11PrivacyAlgrthm =%x\n",
+				 (" adapter->securitypriv.dot11PrivacyAlgrthm =%x\n",
 				 padapter->securitypriv.dot11PrivacyAlgrthm));
 		} else {
 			encryptionalgo = padapter->securitypriv.dot118021XGrpPrivacy;
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
-				 ("(Adapter->securitypriv.dot11PrivacyAlgrthm =%x )encryptionalgo(%x) = padapter->securitypriv.dot118021XGrpPrivacy(%x)keylen=%d\n",
+				 ("(adapter->securitypriv.dot11PrivacyAlgrthm =%x )encryptionalgo(%x) = padapter->securitypriv.dot118021XGrpPrivacy(%x)keylen=%d\n",
 				 padapter->securitypriv.dot11PrivacyAlgrthm, encryptionalgo, padapter->securitypriv.dot118021XGrpPrivacy, key->KeyLength));
 		}
 
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -2706,9 +2706,9 @@ int rtw_restruct_wmm_ie(struct rtw_adapt
 /*  */
 /*  */
 
-static int SecIsInPMKIDList(struct rtw_adapter *Adapter, u8 *bssid)
+static int SecIsInPMKIDList(struct rtw_adapter *adapter, u8 *bssid)
 {
-	struct security_priv *psecuritypriv = &Adapter->securitypriv;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
 	int i = 0;
 
 	do {
@@ -2740,10 +2740,10 @@ static int SecIsInPMKIDList(struct rtw_a
 /*  13th element in the array is the IE length */
 /*  */
 
-static int rtw_append_pmkid(struct rtw_adapter *Adapter, int iEntry, u8 *ie,
+static int rtw_append_pmkid(struct rtw_adapter *adapter, int iEntry, u8 *ie,
 			    uint ie_len)
 {
-	struct security_priv *psecuritypriv = &Adapter->securitypriv;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
 
 	if (ie[13] <= 20) {
 		/*  The RSN IE didn't include the PMK ID, append the PMK information */
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -8619,7 +8619,7 @@ Following are some utitity fuctions for
 
 *****************************************************************************/
 
-bool IsLegal5GChannel(struct rtw_adapter *Adapter, u8 channel)
+bool IsLegal5GChannel(struct rtw_adapter *adapter, u8 channel)
 {
 	int i = 0;
 	u8 Channel_5G[45] = { 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -654,30 +654,30 @@ void rtw_lps_leave(struct rtw_adapter *p
 /*  Description: Leave all power save mode: LPS, FwLPS, IPS if needed. */
 /*  Move code to function by tynli. 2010.03.26. */
 /*  */
-void LeaveAllPowerSaveMode(struct rtw_adapter *Adapter)
+void LeaveAllPowerSaveMode(struct rtw_adapter *adapter)
 {
-	struct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 
 	_func_enter_;
 
 	/* DBG_8192D("%s.....\n",__func__); */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {	/* connect */
 #ifdef CONFIG_P2P_PS
-		p2p_ps_wk_cmd(Adapter, P2P_PS_DISABLE, 0);
+		p2p_ps_wk_cmd(adapter, P2P_PS_DISABLE, 0);
 #endif /*  CONFIG_P2P_PS */
 #ifdef CONFIG_LPS
 		/* DBG_8192D("==> leave LPS.......\n"); */
-		rtw_lps_leave(Adapter);
+		rtw_lps_leave(adapter);
 #endif
 	} else {
-		if (Adapter->pwrctrlpriv.rf_pwrstate == rf_off) {
+		if (adapter->pwrctrlpriv.rf_pwrstate == rf_off) {
 #ifdef CONFIG_AUTOSUSPEND
-			if (Adapter->registrypriv.usbss_enable) {
+			if (adapter->registrypriv.usbss_enable) {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
 				usb_disable_autosuspend(adapter_to_dvobj
-							(Adapter)->pusbdev);
+							(adapter)->pusbdev);
 #elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22) && LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34))
-				adapter_to_dvobj(Adapter)->pusbdev->autosuspend_disabled = Adapter->bDisableAutosuspend;	/* autosuspend disabled by the user */
+				adapter_to_dvobj(adapter)->pusbdev->autosuspend_disabled = adapter->bDisableAutosuspend;	/* autosuspend disabled by the user */
 #endif
 			} else
 #endif
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -251,7 +251,7 @@ void get_rate_set(struct rtw_adapter *pa
 }
 
 void UpdateBrateTbl(
-	struct rtw_adapter *Adapter,
+	struct rtw_adapter *adapter,
 	u8			*mBratesOS
 )
 {
@@ -560,9 +560,9 @@ unsigned int decide_wait_for_beacon_time
 		return bcn_interval << 2;
 }
 
-void CAM_empty_entry(struct rtw_adapter *Adapter, u8 ucIndex)
+void CAM_empty_entry(struct rtw_adapter *adapter, u8 ucIndex)
 {
-	rtw_hal_set_hwreg(Adapter, HW_VAR_CAM_EMPTY_ENTRY, (u8 *)(&ucIndex));
+	rtw_hal_set_hwreg(adapter, HW_VAR_CAM_EMPTY_ENTRY, (u8 *)(&ucIndex));
 }
 
 void invalidate_cam_all(struct rtw_adapter *padapter)
@@ -1420,9 +1420,9 @@ void update_IOT_info(struct rtw_adapter
 	}
 }
 
-void update_capinfo(struct rtw_adapter *Adapter, u16 updateCap)
+void update_capinfo(struct rtw_adapter *adapter, u16 updateCap)
 {
-	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	bool		shortpreamble;
 
@@ -1433,13 +1433,13 @@ void update_capinfo(struct rtw_adapter *
 		if (pmlmeinfo->preamble_mode != PREAMBLE_SHORT) { /*  PREAMBLE_LONG or PREAMBLE_AUTO */
 			shortpreamble = true;
 			pmlmeinfo->preamble_mode = PREAMBLE_SHORT;
-			rtw_hal_set_hwreg(Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&shortpreamble);
+			rtw_hal_set_hwreg(adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&shortpreamble);
 		}
 	} else { /*  Long Preamble */
 		if (pmlmeinfo->preamble_mode != PREAMBLE_LONG) {  /*  PREAMBLE_SHORT or PREAMBLE_AUTO */
 			shortpreamble = false;
 			pmlmeinfo->preamble_mode = PREAMBLE_LONG;
-			rtw_hal_set_hwreg(Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&shortpreamble);
+			rtw_hal_set_hwreg(adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&shortpreamble);
 		}
 	}
 
@@ -1464,7 +1464,7 @@ void update_capinfo(struct rtw_adapter *
 		}
 	}
 
-	rtw_hal_set_hwreg(Adapter, HW_VAR_SLOT_TIME, &pmlmeinfo->slotTime);
+	rtw_hal_set_hwreg(adapter, HW_VAR_SLOT_TIME, &pmlmeinfo->slotTime);
 }
 
 void update_wireless_mode(struct rtw_adapter *padapter)
--- a/drivers/staging/rtl8192du/hal/hal_com.c
+++ b/drivers/staging/rtl8192du/hal/hal_com.c
@@ -266,7 +266,7 @@ u8	ratetohwrate(u8 rate)
 	return ret;
 }
 
-void	halsetbratecfg(struct rtw_adapter * Adapter, u8 *brates, u16 *bratecfg)
+void	halsetbratecfg(struct rtw_adapter * adapter, u8 *brates, u16 *bratecfg)
 {
 	u8	i, is_brate, brate;
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -31,14 +31,14 @@
 
 static bool
 CheckWriteH2C(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8		BoxNum
 )
 {
 	u8	valHMETFR;
 	bool	Result = false;
 
-	valHMETFR = rtw_read8(Adapter, REG_HMETFR);
+	valHMETFR = rtw_read8(adapter, REG_HMETFR);
 
 	if (((valHMETFR>>BoxNum)&BIT0) == 1)
 		Result = true;
@@ -48,14 +48,14 @@ CheckWriteH2C(
 
 static bool
 CheckFwReadLastH2C(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8		BoxNum
 )
 {
 	u8	valHMETFR;
 	bool	 Result = false;
 
-	valHMETFR = rtw_read8(Adapter, REG_HMETFR);
+	valHMETFR = rtw_read8(adapter, REG_HMETFR);
 
 	/*  Do not seperate to 91C and 88C, we use the same setting. Suggested by SD4 Filen. 2009.12.03. */
 	if (((valHMETFR>>BoxNum)&BIT0) == 0)
@@ -252,7 +252,7 @@ _func_exit_;
 
 void
 FillH2CCmd92D(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8	ElementID,
 	u32	CmdLen,
 	u8*	pCmdBuffer
@@ -260,9 +260,9 @@ FillH2CCmd92D(
 {
 	u32	tmpCmdBuf[2];
 
-	/* Adapter = ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, TRUE); */
+	/* adapter = ADJUST_TO_ADAPTIVE_ADAPTER(adapter, TRUE); */
 
-	if (Adapter->bFWReady == false)
+	if (adapter->bFWReady == false)
 	{
 		DBG_8192D("FillH2CCmd92D(): return H2C cmd because of Fw download fail!!!\n");
 		return;
@@ -271,7 +271,7 @@ FillH2CCmd92D(
 	memset(tmpCmdBuf, 0, 8);
 	memcpy(tmpCmdBuf, pCmdBuffer, CmdLen);
 
-	_FillH2CCmd92D(Adapter, ElementID, CmdLen, (u8 *)&tmpCmdBuf);
+	_FillH2CCmd92D(adapter, ElementID, CmdLen, (u8 *)&tmpCmdBuf);
 
 	return;
 }
@@ -319,14 +319,14 @@ _func_exit_;
 /* bitmap[28:31]= Rate Adaptive id */
 /* arg[0:4] = macid */
 /* arg[5] = Short GI */
-void rtl8192d_Add_RateATid(struct rtw_adapter * pAdapter, u32 bitmap, u8 arg)
+void rtl8192d_Add_RateATid(struct rtw_adapter * adapter, u32 bitmap, u8 arg)
 {
 
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	if (pHalData->fw_ractrl == true)
 	{
-		rtl8192d_set_raid_cmd(pAdapter, bitmap, arg);
+		rtl8192d_set_raid_cmd(adapter, bitmap, arg);
 	}
 	else
 	{
@@ -341,7 +341,7 @@ void rtl8192d_Add_RateATid(struct rtw_ad
 		if (shortGIrate==true)
 			init_rate |= BIT(6);
 
-		rtw_write8(pAdapter, (REG_INIDATA_RATE_SEL+macid), (u8)init_rate);
+		rtw_write8(adapter, (REG_INIDATA_RATE_SEL+macid), (u8)init_rate);
 	}
 }
 
@@ -588,13 +588,13 @@ static void ConstructProbeRsp(struct rtw
 /*  */
 static void
 FillFakeTxDescriptor92D(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8*			pDesc,
 	u32			BufferLen,
 	bool		IsPsPoll
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct tx_desc	*ptxdesc = (struct tx_desc *)pDesc;
 
 	/*  Clear all status */
@@ -645,13 +645,13 @@ FillFakeTxDescriptor92D(
 /* 			      TRUE: At the second time, we should send the first packet (default:beacon) */
 /* 						to Hw again and set the lengh in descriptor to the real beacon lengh. */
 /*  2009.10.15 by tynli. */
-static void SetFwRsvdPagePkt(struct rtw_adapter * Adapter, bool dl_finish)
+static void SetFwRsvdPagePkt(struct rtw_adapter * adapter, bool dl_finish)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct xmit_frame	*pmgntframe;
 	struct pkt_attrib	*pattrib;
-	struct xmit_priv	*pxmitpriv = &(Adapter->xmitpriv);
-	struct mlme_ext_priv	*pmlmeext = &(Adapter->mlmeextpriv);
+	struct xmit_priv	*pxmitpriv = &(adapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(adapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u32	BeaconLength, ProbeRspLength, PSPollLength, NullFunctionDataLength;
 	u8	*reservedpagepacket;
@@ -677,7 +677,7 @@ static void SetFwRsvdPagePkt(struct rtw_
 	TxDescOffset = TxDescLen+8; /* Shift index for 8 bytes because the dummy bytes in the first descipstor. */
 
 	/* 1) beacon */
-	ConstructBeacon(Adapter,&reservedpagepacket[BufIndex],&BeaconLength);
+	ConstructBeacon(adapter,&reservedpagepacket[BufIndex],&BeaconLength);
 
 	RT_PRINT_DATA(_module_rtl8712_cmd_c_, _drv_info_,
 		"SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: BCN\n",
@@ -697,9 +697,9 @@ static void SetFwRsvdPagePkt(struct rtw_
 	BufIndex = (PageNum*128) + TxDescOffset;
 
 	/* 2) ps-poll */
-	ConstructPSPoll(Adapter, &reservedpagepacket[BufIndex],&PSPollLength);
+	ConstructPSPoll(adapter, &reservedpagepacket[BufIndex],&PSPollLength);
 
-	FillFakeTxDescriptor92D(Adapter, &reservedpagepacket[BufIndex-TxDescLen], PSPollLength, true);
+	FillFakeTxDescriptor92D(adapter, &reservedpagepacket[BufIndex-TxDescLen], PSPollLength, true);
 
 	RT_PRINT_DATA(_module_rtl8712_cmd_c_, _drv_info_,
 		"SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: PS-POLL\n",
@@ -716,13 +716,13 @@ static void SetFwRsvdPagePkt(struct rtw_
 
 	/* 3) null data */
 	ConstructNullFunctionData(
-		Adapter,
+		adapter,
 		&reservedpagepacket[BufIndex],
 		&NullFunctionDataLength,
 		get_my_bssid(&(pmlmeinfo->network)),
 		false);
 
-	FillFakeTxDescriptor92D(Adapter, &reservedpagepacket[BufIndex-TxDescLen], NullFunctionDataLength, false);
+	FillFakeTxDescriptor92D(adapter, &reservedpagepacket[BufIndex-TxDescLen], NullFunctionDataLength, false);
 
 	SET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(u1RsvdPageLoc, PageNum);
 
@@ -738,13 +738,13 @@ static void SetFwRsvdPagePkt(struct rtw_
 
 	/* 4) probe response */
 	ConstructProbeRsp(
-		Adapter,
+		adapter,
 		&reservedpagepacket[BufIndex],
 		&ProbeRspLength,
 		get_my_bssid(&(pmlmeinfo->network)),
 		false);
 
-	FillFakeTxDescriptor92D(Adapter, &reservedpagepacket[BufIndex-TxDescLen], ProbeRspLength, false);
+	FillFakeTxDescriptor92D(adapter, &reservedpagepacket[BufIndex-TxDescLen], ProbeRspLength, false);
 
 	SET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(u1RsvdPageLoc, PageNum);
 
@@ -767,18 +767,18 @@ static void SetFwRsvdPagePkt(struct rtw_
 
 	/* update attribute */
 	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(Adapter, pattrib);
+	update_mgntframe_attrib(adapter, pattrib);
 	pattrib->qsel = 0x10;
 	pattrib->pktlen = pattrib->last_txcmdsz = TotalPacketLen - TxDescLen;
 	memcpy(pmgntframe->buf_addr, reservedpagepacket, TotalPacketLen);
 
-	rtw_hal_mgnt_xmit(Adapter, pmgntframe);
+	rtw_hal_mgnt_xmit(adapter, pmgntframe);
 
 	dlok = true;
 
 	if (dlok) {
 		DBG_8192D("Set RSVD page location to Fw.\n");
-		FillH2CCmd92D(Adapter, H2C_RSVDPAGE, sizeof(u1RsvdPageLoc), u1RsvdPageLoc);
+		FillH2CCmd92D(adapter, H2C_RSVDPAGE, sizeof(u1RsvdPageLoc), u1RsvdPageLoc);
 	}
 
 	kfree(reservedpagepacket);
@@ -802,7 +802,7 @@ _func_enter_;
 		/*  Suggested by filen. Added by tynli. */
 		rtw_write16(padapter, REG_BCN_PSR_RPT, (0xC000|pmlmeinfo->aid));
 		/*  Do not set TSF again here or vWiFi beacon DMA INT will not work. */
-		/* rtw_hal_set_hwreg(Adapter, HW_VAR_CORRECT_TSF, (pu1Byte)(&bTypeIbss)); */
+		/* rtw_hal_set_hwreg(adapter, HW_VAR_CORRECT_TSF, (pu1Byte)(&bTypeIbss)); */
 		/*  Hw sequende enable by dedault. 2010.06.23. by tynli. */
 
 		/* set REG_CR bit 8 */
@@ -981,20 +981,20 @@ _func_exit_;
 	return res;
 }
 
-int reset_tsf(struct rtw_adapter * Adapter, u8 reset_port)
+int reset_tsf(struct rtw_adapter * adapter, u8 reset_port)
 {
 	u8 reset_cnt_before = 0, reset_cnt_after = 0, loop_cnt = 0;
 	u32 reg_reset_tsf_cnt = (IFACE_PORT0==reset_port) ?
 				REG_FW_RESET_TSF_CNT_0:REG_FW_RESET_TSF_CNT_1;
 
-	rtw_scan_abort(Adapter->pbuddy_adapter);	/*	site survey will cause reset_tsf fail	*/
-	reset_cnt_after = reset_cnt_before = rtw_read8(Adapter,reg_reset_tsf_cnt);
-	rtl8192d_reset_tsf(Adapter, reset_port);
+	rtw_scan_abort(adapter->pbuddy_adapter);	/*	site survey will cause reset_tsf fail	*/
+	reset_cnt_after = reset_cnt_before = rtw_read8(adapter,reg_reset_tsf_cnt);
+	rtl8192d_reset_tsf(adapter, reset_port);
 
 	while ((reset_cnt_after == reset_cnt_before) && (loop_cnt < 10)) {
 		rtw_msleep_os(100);
 		loop_cnt++;
-		reset_cnt_after = rtw_read8(Adapter, reg_reset_tsf_cnt);
+		reset_cnt_after = rtw_read8(adapter, reg_reset_tsf_cnt);
 	}
 
 	return(loop_cnt >= 10) ? _FAIL : true;
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -64,10 +64,10 @@ u32 EDCAParam[maxAP][3] =
  *
  *---------------------------------------------------------------------------*/
 static void dm_DIGInit(
-	struct rtw_adapter *	pAdapter
+	struct rtw_adapter *	adapter
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
 
@@ -106,19 +106,19 @@ static void dm_DIGInit(
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 static bool
-dm_DualMacGetParameterFromBuddyAdapter(
-		struct rtw_adapter *	Adapter
+dm_DualMacGetParameterFromBuddyadapter(
+		struct rtw_adapter *	adapter
 )
 {
-	struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	struct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);
-	struct mlme_priv *pbuddy_mlmepriv = &(BuddyAdapter->mlmepriv);
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct mlme_priv *pbuddy_mlmepriv = &(Buddyadapter->mlmepriv);
 
 	if (pHalData->MacPhyMode92D != DUALMAC_SINGLEPHY)
 		return false;
 
-	if (BuddyAdapter == NULL)
+	if (Buddyadapter == NULL)
 		return false;
 
 	if (pHalData->bSlaveOfDMSP)
@@ -135,32 +135,32 @@ dm_DualMacGetParameterFromBuddyAdapter(
 
 static void
 odm_FalseAlarmCounterStatistics_ForSlaveOfDMSP(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 )
 {
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct FALSE_ALARM_STATISTICS *falsealmcnt = &(pdmpriv->falsealmcnt);
 	struct dm_priv	*Buddydmpriv;
-	struct FALSE_ALARM_STATISTICS *FlaseAlmCntBuddyAdapter;
+	struct FALSE_ALARM_STATISTICS *FlaseAlmCntBuddyadapter;
 
-	if (BuddyAdapter == NULL)
+	if (Buddyadapter == NULL)
 		return;
 
-	if (Adapter->DualMacConcurrent == false)
+	if (adapter->DualMacConcurrent == false)
 		return;
 
-	Buddydmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
-	FlaseAlmCntBuddyAdapter = &(Buddydmpriv->falsealmcnt);
+	Buddydmpriv = &GET_HAL_DATA(Buddyadapter)->dmpriv;
+	FlaseAlmCntBuddyadapter = &(Buddydmpriv->falsealmcnt);
 
-	falsealmcnt->Cnt_Fast_Fsync =FlaseAlmCntBuddyAdapter->Cnt_Fast_Fsync;
-	falsealmcnt->Cnt_SB_Search_fail =FlaseAlmCntBuddyAdapter->Cnt_SB_Search_fail;
-	falsealmcnt->Cnt_Parity_Fail = FlaseAlmCntBuddyAdapter->Cnt_Parity_Fail;
-	falsealmcnt->Cnt_Rate_Illegal = FlaseAlmCntBuddyAdapter->Cnt_Rate_Illegal;
-	falsealmcnt->Cnt_Crc8_fail = FlaseAlmCntBuddyAdapter->Cnt_Crc8_fail;
-	falsealmcnt->Cnt_Mcs_fail = FlaseAlmCntBuddyAdapter->Cnt_Mcs_fail;
+	falsealmcnt->Cnt_Fast_Fsync =FlaseAlmCntBuddyadapter->Cnt_Fast_Fsync;
+	falsealmcnt->Cnt_SB_Search_fail =FlaseAlmCntBuddyadapter->Cnt_SB_Search_fail;
+	falsealmcnt->Cnt_Parity_Fail = FlaseAlmCntBuddyadapter->Cnt_Parity_Fail;
+	falsealmcnt->Cnt_Rate_Illegal = FlaseAlmCntBuddyadapter->Cnt_Rate_Illegal;
+	falsealmcnt->Cnt_Crc8_fail = FlaseAlmCntBuddyadapter->Cnt_Crc8_fail;
+	falsealmcnt->Cnt_Mcs_fail = FlaseAlmCntBuddyadapter->Cnt_Mcs_fail;
 
 	falsealmcnt->Cnt_Ofdm_fail =	falsealmcnt->Cnt_Parity_Fail + falsealmcnt->Cnt_Rate_Illegal +
 								falsealmcnt->Cnt_Crc8_fail + falsealmcnt->Cnt_Mcs_fail +
@@ -168,7 +168,7 @@ odm_FalseAlarmCounterStatistics_ForSlave
 
 
 	/* hold cck counter */
-	falsealmcnt->Cnt_Cck_fail = FlaseAlmCntBuddyAdapter->Cnt_Cck_fail;
+	falsealmcnt->Cnt_Cck_fail = FlaseAlmCntBuddyadapter->Cnt_Cck_fail;
 
 	falsealmcnt->Cnt_all = (	falsealmcnt->Cnt_Fast_Fsync +
 						falsealmcnt->Cnt_SB_Search_fail +
@@ -183,33 +183,33 @@ odm_FalseAlarmCounterStatistics_ForSlave
 
 static void
 odm_FalseAlarmCounterStatistics(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
 	u32	ret_value;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	struct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct FALSE_ALARM_STATISTICS *falsealmcnt = &(pdmpriv->falsealmcnt);
 	u8	BBReset;
 #ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter * pbuddy_adapter = Adapter->pbuddy_adapter;
+	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
 	struct hal_data_8192du *pbuddy_pHalData = GET_HAL_DATA(pbuddy_adapter);
 	struct mlme_priv *pbuddy_pmlmepriv = &(pbuddy_adapter->mlmepriv);
 #endif /* CONFIG_CONCURRENT_MODE */
 	/* hold ofdm counter */
-	PHY_SetBBReg(Adapter, rOFDM0_LSTF, BIT31, 1); /* hold page C counter */
-	PHY_SetBBReg(Adapter, rOFDM1_LSTF, BIT31, 1); /* hold page D counter */
+	PHY_SetBBReg(adapter, rOFDM0_LSTF, BIT31, 1); /* hold page C counter */
+	PHY_SetBBReg(adapter, rOFDM1_LSTF, BIT31, 1); /* hold page D counter */
 
-	ret_value = PHY_QueryBBReg(Adapter, rOFDM0_FrameSync, bMaskDWord);
+	ret_value = PHY_QueryBBReg(adapter, rOFDM0_FrameSync, bMaskDWord);
 	falsealmcnt->Cnt_Fast_Fsync = (ret_value&0xffff);
 	falsealmcnt->Cnt_SB_Search_fail = ((ret_value&0xffff0000)>>16);
-	ret_value = PHY_QueryBBReg(Adapter, rOFDM_PHYCounter1, bMaskDWord);
+	ret_value = PHY_QueryBBReg(adapter, rOFDM_PHYCounter1, bMaskDWord);
 	falsealmcnt->Cnt_Parity_Fail = ((ret_value&0xffff0000)>>16);
-	ret_value = PHY_QueryBBReg(Adapter, rOFDM_PHYCounter2, bMaskDWord);
+	ret_value = PHY_QueryBBReg(adapter, rOFDM_PHYCounter2, bMaskDWord);
 	falsealmcnt->Cnt_Rate_Illegal = (ret_value&0xffff);
 	falsealmcnt->Cnt_Crc8_fail = ((ret_value&0xffff0000)>>16);
-	ret_value = PHY_QueryBBReg(Adapter, rOFDM_PHYCounter3, bMaskDWord);
+	ret_value = PHY_QueryBBReg(adapter, rOFDM_PHYCounter3, bMaskDWord);
 	falsealmcnt->Cnt_Mcs_fail = (ret_value&0xffff);
 
 	falsealmcnt->Cnt_Ofdm_fail =	falsealmcnt->Cnt_Parity_Fail + falsealmcnt->Cnt_Rate_Illegal +
@@ -220,10 +220,10 @@ odm_FalseAlarmCounterStatistics(
 	{
 		/* hold cck counter */
 
-		ret_value = PHY_QueryBBReg(Adapter, rCCK0_FACounterLower, bMaskByte0);
+		ret_value = PHY_QueryBBReg(adapter, rCCK0_FACounterLower, bMaskByte0);
 		falsealmcnt->Cnt_Cck_fail = ret_value;
 
-		ret_value = PHY_QueryBBReg(Adapter, rCCK0_FACounterUpper, bMaskByte3);
+		ret_value = PHY_QueryBBReg(adapter, rCCK0_FACounterUpper, bMaskByte3);
 		falsealmcnt->Cnt_Cck_fail +=  (ret_value& 0xff)<<8;
 	}
 	else
@@ -239,39 +239,39 @@ odm_FalseAlarmCounterStatistics(
 						falsealmcnt->Cnt_Crc8_fail +
 						falsealmcnt->Cnt_Mcs_fail +
 						falsealmcnt->Cnt_Cck_fail);
-	Adapter->recvpriv.falsealmcnt_all = falsealmcnt->Cnt_all;
+	adapter->recvpriv.falsealmcnt_all = falsealmcnt->Cnt_all;
 #ifdef CONFIG_CONCURRENT_MODE
 	if (pbuddy_adapter)
 		pbuddy_adapter->recvpriv.falsealmcnt_all = falsealmcnt->Cnt_all;
 #endif /* CONFIG_CONCURRENT_MODE */
 
 	/* reset false alarm counter registers */
-	PHY_SetBBReg(Adapter, rOFDM1_LSTF, 0x08000000, 1);
-	PHY_SetBBReg(Adapter, rOFDM1_LSTF, 0x08000000, 0);
+	PHY_SetBBReg(adapter, rOFDM1_LSTF, 0x08000000, 1);
+	PHY_SetBBReg(adapter, rOFDM1_LSTF, 0x08000000, 0);
 	/* update ofdm counter */
-	PHY_SetBBReg(Adapter, rOFDM0_LSTF, BIT31, 0); /* update page C counter */
-	PHY_SetBBReg(Adapter, rOFDM1_LSTF, BIT31, 0); /* update page D counter */
+	PHY_SetBBReg(adapter, rOFDM0_LSTF, BIT31, 0); /* update page C counter */
+	PHY_SetBBReg(adapter, rOFDM1_LSTF, BIT31, 0); /* update page D counter */
 	if (pHalData->CurrentBandType92D != BAND_ON_5G) {
 		/* reset cck counter */
-		PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, 0x0000c000, 0);
+		PHY_SetBBReg(adapter, rCCK0_FalseAlarmReport, 0x0000c000, 0);
 		/* enable cck counter */
-		PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, 0x0000c000, 2);
+		PHY_SetBBReg(adapter, rCCK0_FalseAlarmReport, 0x0000c000, 2);
 	}
 
 	/* BB Reset */
-	if (IS_HARDWARE_TYPE_8192D(Adapter))
+	if (IS_HARDWARE_TYPE_8192D(adapter))
 	{
 		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
 			if ((pHalData->CurrentBandType92D == BAND_ON_2_4G) && pHalData->bMasterOfDMSP && (check_fwstate(pmlmepriv, _FW_LINKED) == false))
 			{
 				/* before BB reset should do clock gated */
-				rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
-				BBReset = rtw_read8(Adapter, 0x02);
-				rtw_write8(Adapter, 0x02, BBReset&(~BIT0));
-				rtw_write8(Adapter, 0x02, BBReset|BIT0);
+				rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
+				BBReset = rtw_read8(adapter, 0x02);
+				rtw_write8(adapter, 0x02, BBReset&(~BIT0));
+				rtw_write8(adapter, 0x02, BBReset|BIT0);
 				/* undo clock gated */
-				rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
+				rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
 			}
 		}
 		else
@@ -283,53 +283,53 @@ odm_FalseAlarmCounterStatistics(
 			)
 			{
 				/* before BB reset should do clock gated */
-				rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
-				BBReset = rtw_read8(Adapter, 0x02);
-				rtw_write8(Adapter, 0x02, BBReset&(~BIT0));
-				rtw_write8(Adapter, 0x02, BBReset|BIT0);
+				rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
+				BBReset = rtw_read8(adapter, 0x02);
+				rtw_write8(adapter, 0x02, BBReset&(~BIT0));
+				rtw_write8(adapter, 0x02, BBReset|BIT0);
 				/* undo clock gated */
-				rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
+				rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
 			}
 		}
 	}
 	else if (check_fwstate(pmlmepriv, _FW_LINKED) == false)
 	{
 		/* before BB reset should do clock gated */
-		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
-		BBReset = rtw_read8(Adapter, 0x02);
-		rtw_write8(Adapter, 0x02, BBReset&(~BIT0));
-		rtw_write8(Adapter, 0x02, BBReset|BIT0);
+		rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
+		BBReset = rtw_read8(adapter, 0x02);
+		rtw_write8(adapter, 0x02, BBReset&(~BIT0));
+		rtw_write8(adapter, 0x02, BBReset|BIT0);
 		/* undo clock gated */
-		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
+		rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
 	}
 }
 
 static void
 odm_FindMinimumRSSI_Dmsp(
-	struct rtw_adapter *	pAdapter
+	struct rtw_adapter *	adapter
 )
 {
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	s32	rssi_val_min_back_for_mac0;
-	bool		bGetValueFromBuddyAdapter = dm_DualMacGetParameterFromBuddyAdapter(pAdapter);
+	bool		bGetValueFromBuddyadapter = dm_DualMacGetParameterFromBuddyadapter(adapter);
 	bool		rest_rssi = false;
-	struct rtw_adapter *	BuddyAdapter = pAdapter->pbuddy_adapter;
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
 	struct dm_priv	*Buddydmpriv;
 
 	if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 	{
-		if (BuddyAdapter!= NULL)
+		if (Buddyadapter!= NULL)
 		{
-			Buddydmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
+			Buddydmpriv = &GET_HAL_DATA(Buddyadapter)->dmpriv;
 			if (pHalData->bSlaveOfDMSP)
 			{
 				Buddydmpriv->RssiValMinForAnotherMacOfDMSP = pdmpriv->MinUndecoratedPWDBForDM;
 			}
 			else
 			{
-				if (bGetValueFromBuddyAdapter)
+				if (bGetValueFromBuddyadapter)
 				{
 					rest_rssi = true;
 					rssi_val_min_back_for_mac0 = pdmpriv->MinUndecoratedPWDBForDM;
@@ -350,12 +350,12 @@ odm_FindMinimumRSSI_Dmsp(
 
 static void
 odm_FindMinimumRSSI_92D(
-struct rtw_adapter *	pAdapter
+struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	struct mlme_priv	*pmlmepriv = &pAdapter->mlmepriv;
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
 
 	/* 1 1.Determine the minimum RSSI */
 	if ((check_fwstate(pmlmepriv, _FW_LINKED) == false) &&
@@ -381,16 +381,16 @@ struct rtw_adapter *	pAdapter
 		pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
 	}
 
-	odm_FindMinimumRSSI_Dmsp(pAdapter);
+	odm_FindMinimumRSSI_Dmsp(adapter);
 
 }
 
 static u8
 odm_initial_gain_MinPWDB(
-	struct rtw_adapter *	pAdapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	s32	rssi_val_min = 0;
 	if (pdmpriv->EntryMinUndecoratedSmoothedPWDB != 0)
@@ -404,23 +404,23 @@ odm_initial_gain_MinPWDB(
 
 static void
 DM_Write_DIG_DMSP(
-	struct rtw_adapter *	pAdapter
+	struct rtw_adapter *	adapter
 	)
 {
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
-	struct rtw_adapter *	BuddyAdapter = pAdapter->pbuddy_adapter;
-	bool		bGetValueFromOtherMac = dm_DualMacGetParameterFromBuddyAdapter(pAdapter);
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+	bool		bGetValueFromOtherMac = dm_DualMacGetParameterFromBuddyadapter(adapter);
 	struct dm_priv	*Buddydmpriv;
 
-	if (BuddyAdapter == NULL)
+	if (Buddyadapter == NULL)
 	{
 		if (pHalData->bMasterOfDMSP)
 		{
-			PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
-			PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
+			PHY_SetBBReg(adapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
+			PHY_SetBBReg(adapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
 			dm_digtable->preigvalue = dm_digtable->curigvalue;
 		}
 		else
@@ -435,12 +435,12 @@ DM_Write_DIG_DMSP(
 		if (pdmpriv->bWriteDigForAnotherMacOfDMSP)
 		{
 			pdmpriv->bWriteDigForAnotherMacOfDMSP = false;
-			PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, pdmpriv->CurDigValueForAnotherMacOfDMSP);
-			PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, 0x7f, pdmpriv->CurDigValueForAnotherMacOfDMSP);
+			PHY_SetBBReg(adapter, rOFDM0_XAAGCCore1, 0x7f, pdmpriv->CurDigValueForAnotherMacOfDMSP);
+			PHY_SetBBReg(adapter, rOFDM0_XBAGCCore1, 0x7f, pdmpriv->CurDigValueForAnotherMacOfDMSP);
 		}
 	}
 
-	Buddydmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
+	Buddydmpriv = &GET_HAL_DATA(Buddyadapter)->dmpriv;
 
 	if (dm_digtable->preigvalue != dm_digtable->curigvalue)
 	{
@@ -456,8 +456,8 @@ DM_Write_DIG_DMSP(
 		{
 			if (!bGetValueFromOtherMac)
 			{
-				PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
-				PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
+				PHY_SetBBReg(adapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
+				PHY_SetBBReg(adapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
 			}
 		}
 		dm_digtable->preigvalue = dm_digtable->curigvalue;
@@ -467,35 +467,35 @@ DM_Write_DIG_DMSP(
 
 static void
 DM_Write_DIG(
-	struct rtw_adapter *	pAdapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
 
 	if (dm_digtable->dig_enable_flag == false)
 		return;
 
-	if ((dm_digtable->preigvalue != dm_digtable->curigvalue) || (pAdapter->bForceWriteInitGain))
+	if ((dm_digtable->preigvalue != dm_digtable->curigvalue) || (adapter->bForceWriteInitGain))
 	{
 		/*  Set initial gain. */
 		/*  20100211 Joseph: Set only BIT0~BIT6 for DIG. BIT7 is the function switch of Antenna diversity. */
 		/*  Just not to modified it for SD3 testing. */
-		PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
-		PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
+		PHY_SetBBReg(adapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
+		PHY_SetBBReg(adapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
 		if (dm_digtable->curigvalue != 0x17)
 			dm_digtable->preigvalue = dm_digtable->curigvalue;
 	}
 }
 
 static void odm_DIG(
-	struct rtw_adapter *	pAdapter)
+	struct rtw_adapter *	adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
-	struct mlme_priv	*pmlmepriv = &(pAdapter->mlmepriv);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	struct registry_priv	 *pregistrypriv = &pAdapter->registrypriv;
+	struct registry_priv	 *pregistrypriv = &adapter->registrypriv;
 	struct FALSE_ALARM_STATISTICS *falsealmcnt = &(pdmpriv->falsealmcnt);
 	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
 	static u8	DIG_Dynamic_MIN_0 = 0x25;
@@ -504,16 +504,16 @@ static void odm_DIG(
 	static bool	bMediaConnect_0 = false;
 	static bool	bMediaConnect_1 = false;
 	bool		FirstConnect;
-	u8	TxRate = rtw_read8(pAdapter, REG_INIDATA_RATE_SEL);
+	u8	TxRate = rtw_read8(adapter, REG_INIDATA_RATE_SEL);
 #ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter * pbuddy_adapter = pAdapter->pbuddy_adapter;
+	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
 	struct hal_data_8192du *pbuddy_pHalData = GET_HAL_DATA(pbuddy_adapter);
 	struct mlme_priv	*pbuddy_pmlmepriv = &(pbuddy_adapter->mlmepriv);
 	struct dm_priv	*pbuddy_pdmpriv = &pbuddy_pHalData->dmpriv;
 #endif /* CONFIG_CONCURRENT_MODE */
 
 
-	if (IS_HARDWARE_TYPE_8192D(pAdapter))
+	if (IS_HARDWARE_TYPE_8192D(adapter))
 	{
 		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
@@ -576,9 +576,9 @@ static void odm_DIG(
 		return;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (pAdapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS || pbuddy_adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)
+	if (adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS || pbuddy_adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)
 #else
-	if (pAdapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)
+	if (adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)
 #endif /* CONFIG_CONCURRENT_MODE */
 		return;
 
@@ -590,7 +590,7 @@ static void odm_DIG(
 #endif /* CONFIG_CONCURRENT_MODE */
 	{
 		/* 2 Get minimum RSSI value among associated devices */
-		dm_digtable->rssi_val_min = odm_initial_gain_MinPWDB(pAdapter);
+		dm_digtable->rssi_val_min = odm_initial_gain_MinPWDB(adapter);
 
 		/* 2 Modify DIG upper bound */
 		if ((dm_digtable->rssi_val_min + 20) > DM_DIG_MAX)
@@ -667,7 +667,7 @@ static void odm_DIG(
 		if (FirstConnect) {
 			dm_digtable->curigvalue = dm_digtable->rssi_val_min;
 		} else {
-			if (IS_HARDWARE_TYPE_8192D(pAdapter)) {
+			if (IS_HARDWARE_TYPE_8192D(adapter)) {
 				if (falsealmcnt->Cnt_all > DM_DIG_FA_TH2_92D)
 					dm_digtable->curigvalue = dm_digtable->preigvalue+2;
 				else if (falsealmcnt->Cnt_all > DM_DIG_FA_TH1_92D)
@@ -710,19 +710,19 @@ static void odm_DIG(
 	if (dm_digtable->curigvalue < dm_digtable->rx_gain_range_min)
 		dm_digtable->curigvalue = dm_digtable->rx_gain_range_min;
 
-	if (pAdapter->bRxRSSIDisplay)
+	if (adapter->bRxRSSIDisplay)
 	{
 		DBG_8192D("Modify DIG algorithm for DMP DIG: RxGainMin = %X, RxGainMax = %X\n",
 			dm_digtable->rx_gain_range_min,
 			dm_digtable->rx_gain_range_max);
 	}
 
-	if (IS_HARDWARE_TYPE_8192D(pAdapter))
+	if (IS_HARDWARE_TYPE_8192D(adapter))
 	{
 		/* sherry  delete DualMacSmartConncurrent 20110517 */
 		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
-			DM_Write_DIG_DMSP(pAdapter);
+			DM_Write_DIG_DMSP(adapter);
 			if (pHalData->bMasterOfDMSP)
 			{
 				bMediaConnect_0 = check_fwstate(pmlmepriv, _FW_LINKED);
@@ -736,7 +736,7 @@ static void odm_DIG(
 		}
 		else
 		{
-			DM_Write_DIG(pAdapter);
+			DM_Write_DIG(adapter);
 			if (pHalData->CurrentBandType92D==BAND_ON_5G)
 			{
 #ifdef CONFIG_CONCURRENT_MODE
@@ -759,7 +759,7 @@ static void odm_DIG(
 	}
 	else
 	{
-		DM_Write_DIG(pAdapter);
+		DM_Write_DIG(adapter);
 #ifdef CONFIG_CONCURRENT_MODE
 		bMediaConnect_0 = (check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED));
 #else
@@ -768,7 +768,7 @@ static void odm_DIG(
 		DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
 	}
 
-	if ((pregistrypriv->lowrate_two_xmit) && IS_HARDWARE_TYPE_8192D(pAdapter) &&
+	if ((pregistrypriv->lowrate_two_xmit) && IS_HARDWARE_TYPE_8192D(adapter) &&
 		(pHalData->MacPhyMode92D != DUALMAC_DUALPHY) && (!pregistrypriv->special_rf_path))
 	{
 		/* for Use 2 path Tx to transmit MCS0~7 and legacy mode */
@@ -788,13 +788,13 @@ static void odm_DIG(
 				/* RegA2F=0x10            (CDD 90ns for path-B) */
 				/* RegA75=0x01            (antenna selection enable) */
 
-				rtw_write32(pAdapter, 0x90C, 0x83321333);
-				rtw_write8(pAdapter, 0xA07, 0xc1);
-				rtw_write8(pAdapter, 0xA11, 0x9b);
-				rtw_write8(pAdapter, 0xA20, 0x10);
-				rtw_write8(pAdapter, 0xA2E, 0xdf);
-				rtw_write8(pAdapter, 0xA2F, 0x10);
-				rtw_write8(pAdapter, 0xA75, 0x01);
+				rtw_write32(adapter, 0x90C, 0x83321333);
+				rtw_write8(adapter, 0xA07, 0xc1);
+				rtw_write8(adapter, 0xA11, 0x9b);
+				rtw_write8(adapter, 0xA20, 0x10);
+				rtw_write8(adapter, 0xA2E, 0xdf);
+				rtw_write8(adapter, 0xA2F, 0x10);
+				rtw_write8(adapter, 0xA75, 0x01);
 
 			}
 			else if (dm_digtable->rssi_val_min  >= 35)  /* low rate 1T1R Settings */
@@ -807,13 +807,13 @@ static void odm_DIG(
 				/* RegA2F=0x00 */
 				/* RegA75=0x00 */
 
-				rtw_write32(pAdapter, 0x90C, 0x81121313);
-				rtw_write8(pAdapter, 0xA07, 0x80);
-				rtw_write8(pAdapter, 0xA11, 0xbb);
-				rtw_write8(pAdapter, 0xA20, 0x00);
-				rtw_write8(pAdapter, 0xA2E, 0xd3);
-				rtw_write8(pAdapter, 0xA2F, 0x00);
-				rtw_write8(pAdapter, 0xA75, 0x00);
+				rtw_write32(adapter, 0x90C, 0x81121313);
+				rtw_write8(adapter, 0xA07, 0x80);
+				rtw_write8(adapter, 0xA11, 0xbb);
+				rtw_write8(adapter, 0xA20, 0x00);
+				rtw_write8(adapter, 0xA2E, 0xd3);
+				rtw_write8(adapter, 0xA2F, 0x00);
+				rtw_write8(adapter, 0xA75, 0x00);
 			}
 
 		}
@@ -825,10 +825,10 @@ static void odm_DIG(
 
 static u8
 dm_initial_gain_MinPWDB(
-	struct rtw_adapter *	pAdapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	s32	rssi_val_min = 0;
 	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
@@ -852,19 +852,19 @@ dm_initial_gain_MinPWDB(
 }
 
 static void dm_CCK_PacketDetectionThresh_DMSP(
-	struct rtw_adapter *	pAdapter)
+	struct rtw_adapter *	adapter)
 {
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
-	struct rtw_adapter *	BuddyAdapter = pAdapter->pbuddy_adapter;
-	bool		bGetValueFromBuddyAdapter = dm_DualMacGetParameterFromBuddyAdapter(pAdapter);
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+	bool		bGetValueFromBuddyadapter = dm_DualMacGetParameterFromBuddyadapter(adapter);
 	struct dm_priv	*Buddydmpriv;
 
 	if (dm_digtable->curstaconnectstate == DIG_STA_CONNECT)
 	{
-		dm_digtable->rssi_val_min = dm_initial_gain_MinPWDB(pAdapter);
+		dm_digtable->rssi_val_min = dm_initial_gain_MinPWDB(adapter);
 		if (dm_digtable->precckpdstate == CCK_PD_STAGE_LOWRSSI)
 		{
 			if (dm_digtable->rssi_val_min <= 25)
@@ -882,7 +882,7 @@ static void dm_CCK_PacketDetectionThresh
 	else
 		dm_digtable->curcckpdstate=CCK_PD_STAGE_MAX;
 
-	if (bGetValueFromBuddyAdapter)
+	if (bGetValueFromBuddyadapter)
 	{
 		DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): mac 1 connect,mac 0 disconnect case\n");
 		if (pdmpriv->bChangeCCKPDStateForAnotherMacOfDMSP)
@@ -890,11 +890,11 @@ static void dm_CCK_PacketDetectionThresh
 			DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): mac 0 set for mac1\n");
 			if (pdmpriv->curcckpdstateForAnotherMacOfDMSP == CCK_PD_STAGE_LOWRSSI)
 			{
-				PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0x83);
+				PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0x83);
 			}
 			else
 			{
-				PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0xcd);
+				PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0xcd);
 
 			}
 			pdmpriv->bChangeCCKPDStateForAnotherMacOfDMSP = false;
@@ -903,9 +903,9 @@ static void dm_CCK_PacketDetectionThresh
 
 	if (dm_digtable->precckpdstate != dm_digtable->curcckpdstate)
 	{
-		if (BuddyAdapter == NULL)
+		if (Buddyadapter == NULL)
 		{
-			DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): BuddyAdapter == NULL case\n");
+			DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): Buddyadapter == NULL case\n");
 			if (pHalData->bSlaveOfDMSP)
 			{
 				dm_digtable->precckpdstate = dm_digtable->curcckpdstate;
@@ -914,11 +914,11 @@ static void dm_CCK_PacketDetectionThresh
 			{
 				if (dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
 				{
-					PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0x83);
+					PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0x83);
 				}
 				else
 				{
-					PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0xcd);
+					PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0xcd);
 
 				}
 				dm_digtable->precckpdstate = dm_digtable->curcckpdstate;
@@ -928,23 +928,23 @@ static void dm_CCK_PacketDetectionThresh
 
 		if (pHalData->bSlaveOfDMSP)
 		{
-			Buddydmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
+			Buddydmpriv = &GET_HAL_DATA(Buddyadapter)->dmpriv;
 			DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): bslave case\n");
 			Buddydmpriv->bChangeCCKPDStateForAnotherMacOfDMSP = true;
 			Buddydmpriv->curcckpdstateForAnotherMacOfDMSP = dm_digtable->curcckpdstate;
 		}
 		else
 		{
-			if (!bGetValueFromBuddyAdapter)
+			if (!bGetValueFromBuddyadapter)
 			{
 				DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): mac 0 set for mac0\n");
 				if (dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
 				{
-					PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0x83);
+					PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0x83);
 				}
 				else
 				{
-					PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0xcd);
+					PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0xcd);
 
 				}
 			}
@@ -954,9 +954,9 @@ static void dm_CCK_PacketDetectionThresh
 #endif
 }
 
-static void dm_CCK_PacketDetectionThresh(struct rtw_adapter *	pAdapter)
+static void dm_CCK_PacketDetectionThresh(struct rtw_adapter *	adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
 
@@ -978,19 +978,19 @@ static void dm_CCK_PacketDetectionThresh
 
 	if (dm_digtable->precckpdstate != dm_digtable->curcckpdstate) {
 		if (dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
-			PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0x83);
+			PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0x83);
 		else
-			PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0xcd);
+			PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0xcd);
 		dm_digtable->precckpdstate = dm_digtable->curcckpdstate;
 	}
 }
 
-static void dm_1R_CCA(struct rtw_adapter *pAdapter)
+static void dm_1R_CCA(struct rtw_adapter *adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct PS_T *dm_pstable = &pdmpriv->DM_PSTable;
-	struct registry_priv *pregistrypriv = &pAdapter->registrypriv;
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
 
       if (pHalData->CurrentBandType92D == BAND_ON_5G)
       {
@@ -1023,38 +1023,38 @@ static void dm_1R_CCA(struct rtw_adapter
 				if (pHalData->rf_type == RF_2T2R)
 				{
 					if (pregistrypriv->special_rf_path == 1) /*  path A only */
-						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
+						PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
 					else if (pregistrypriv->special_rf_path == 2) /* path B only */
-						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
+						PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
 					else
-						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x13);
-					/* PHY_SetBBReg(pAdapter, 0xe70, bMaskByte3, 0x20); */
+						PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x13);
+					/* PHY_SetBBReg(adapter, 0xe70, bMaskByte3, 0x20); */
 				}
 				else
 				{
 					if (pregistrypriv->special_rf_path == 1) /*  path A only */
-						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
+						PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
 					else if (pregistrypriv->special_rf_path == 2) /* path B only */
-						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
+						PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
 					else
-						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x23);
+						PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x23);
 				}
 			} else if (dm_pstable->curccastate == CCA_2R || dm_pstable->curccastate == CCA_MAX) {
 				if (pregistrypriv->special_rf_path == 1) /*  path A only */
-					PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
+					PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
 				else if (pregistrypriv->special_rf_path == 2) /* path B only */
-					PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
+					PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
 				else
-					PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x33);
+					PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x33);
 			}
 			dm_pstable->preccastate = dm_pstable->curccastate;
 		}
 	}
 }
 
-static void dm_InitDynamicTxPower(struct rtw_adapter *	Adapter)
+static void dm_InitDynamicTxPower(struct rtw_adapter *	adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
 	pdmpriv->bDynamicTxPowerEnable = false;
@@ -1063,17 +1063,17 @@ static void dm_InitDynamicTxPower(struct
 	pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
 }
 
-static void odm_DynamicTxPower_92D(struct rtw_adapter *	Adapter)
+static void odm_DynamicTxPower_92D(struct rtw_adapter *	adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	struct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	int	UndecoratedSmoothedPWDB;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
 	struct dm_priv	*pbuddy_dmpriv = NULL;
-	bool		bGetValueFromBuddyAdapter = dm_DualMacGetParameterFromBuddyAdapter(Adapter);
+	bool		bGetValueFromBuddyadapter = dm_DualMacGetParameterFromBuddyadapter(adapter);
 	u8		HighPowerLvlBackForMac0 = TxHighPwrLevel_Level1;
 #endif
 
@@ -1149,7 +1149,7 @@ static void odm_DynamicTxPower_92D(struc
 	}
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if (bGetValueFromBuddyAdapter)
+	if (bGetValueFromBuddyadapter)
 	{
 		DBG_8192D("dm_DynamicTxPower() mac 0 for mac 1\n");
 		if (pdmpriv->bChangeTxHighPowerLvlForAnotherMacOfDMSP)
@@ -1157,7 +1157,7 @@ static void odm_DynamicTxPower_92D(struc
 			DBG_8192D("dm_DynamicTxPower() change value\n");
 			HighPowerLvlBackForMac0 = pdmpriv->DynamicTxHighPowerLvl;
 			pdmpriv->DynamicTxHighPowerLvl = pdmpriv->CurTxHighLvlForAnotherMacOfDMSP;
-			PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
+			PHY_SetTxPowerLevel8192D(adapter, pHalData->CurrentChannel);
 			pdmpriv->DynamicTxHighPowerLvl = HighPowerLvlBackForMac0;
 			pdmpriv->bChangeTxHighPowerLvlForAnotherMacOfDMSP = false;
 		}
@@ -1167,49 +1167,49 @@ static void odm_DynamicTxPower_92D(struc
 	if ((pdmpriv->DynamicTxHighPowerLvl != pdmpriv->LastDTPLvl))
 	{
 #ifdef CONFIG_DUALMAC_CONCURRENT
-		if (Adapter->DualMacConcurrent == true)
+		if (adapter->DualMacConcurrent == true)
 		{
-			if (BuddyAdapter == NULL)
+			if (Buddyadapter == NULL)
 			{
-				DBG_8192D("dm_DynamicTxPower() BuddyAdapter == NULL case\n");
+				DBG_8192D("dm_DynamicTxPower() Buddyadapter == NULL case\n");
 				if (!pHalData->bSlaveOfDMSP)
 				{
-					PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
+					PHY_SetTxPowerLevel8192D(adapter, pHalData->CurrentChannel);
 				}
 			}
 			else
 			{
 				if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 				{
-					DBG_8192D("dm_DynamicTxPower() BuddyAdapter DMSP\n");
+					DBG_8192D("dm_DynamicTxPower() Buddyadapter DMSP\n");
 					if (pHalData->bSlaveOfDMSP)
 					{
 						DBG_8192D("dm_DynamicTxPower() bslave case\n");
-						pbuddy_dmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
+						pbuddy_dmpriv = &GET_HAL_DATA(Buddyadapter)->dmpriv;
 						pbuddy_dmpriv->bChangeTxHighPowerLvlForAnotherMacOfDMSP = true;
 						pbuddy_dmpriv->CurTxHighLvlForAnotherMacOfDMSP = pdmpriv->DynamicTxHighPowerLvl;
 					}
 					else
 					{
 						DBG_8192D("dm_DynamicTxPower() master case\n");
-						if (!bGetValueFromBuddyAdapter)
+						if (!bGetValueFromBuddyadapter)
 						{
 							DBG_8192D("dm_DynamicTxPower() mac 0 for mac 0\n");
-							PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
+							PHY_SetTxPowerLevel8192D(adapter, pHalData->CurrentChannel);
 						}
 					}
 				}
 				else
 				{
-					DBG_8192D("dm_DynamicTxPower() BuddyAdapter DMDP\n");
-					PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
+					DBG_8192D("dm_DynamicTxPower() Buddyadapter DMDP\n");
+					PHY_SetTxPowerLevel8192D(adapter, pHalData->CurrentChannel);
 				}
 			}
 		}
 		else
 #endif
 		{
-			PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
+			PHY_SetTxPowerLevel8192D(adapter, pHalData->CurrentChannel);
 		}
 	}
 	pdmpriv->LastDTPLvl = pdmpriv->DynamicTxHighPowerLvl;
@@ -1217,10 +1217,10 @@ static void odm_DynamicTxPower_92D(struc
 
 
 static void PWDB_Monitor(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	int	i;
 	int	tmpEntryMaxPWDB=0, tmpEntryMinPWDB=0xff;
@@ -1228,11 +1228,11 @@ static void PWDB_Monitor(
 	u32	PWDB_rssi[NUM_STA]={0};/* 0~15]:MACID, [16~31]:PWDB_rssi */
 
 
-	if (check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
+	if (check_fwstate(&adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
 	{
 		struct list_head *plist, *phead;
 		struct sta_info *psta;
-		struct sta_priv *pstapriv = &Adapter->stapriv;
+		struct sta_priv *pstapriv = &adapter->stapriv;
 		u8 bcast_addr[ETH_ALEN]= {0xff,0xff,0xff,0xff,0xff,0xff};
 
 		spin_lock_bh(&pstapriv->sta_hash_lock);
@@ -1249,7 +1249,7 @@ static void PWDB_Monitor(
 				plist = get_next(plist);
 
 				if (_rtw_memcmp(psta	->hwaddr, bcast_addr, ETH_ALEN) ||
-					_rtw_memcmp(psta->hwaddr, myid(&Adapter->eeprompriv), ETH_ALEN))
+					_rtw_memcmp(psta->hwaddr, myid(&adapter->eeprompriv), ETH_ALEN))
 					continue;
 
 				if (psta->state & WIFI_ASOC_STATE)
@@ -1261,7 +1261,7 @@ static void PWDB_Monitor(
 					if (psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
 						tmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
 
-					PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16) | ((Adapter->stapriv.asoc_sta_count+1) << 8));
+					PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16) | ((adapter->stapriv.asoc_sta_count+1) << 8));
 				}
 			}
 		}
@@ -1273,7 +1273,7 @@ static void PWDB_Monitor(
 			/*  Report every sta's RSSI to FW */
 			for (i=0; i< sta_cnt; i++)
 			{
-				FillH2CCmd92D(Adapter, H2C_RSSI_REPORT, 3, (u8 *)(&PWDB_rssi[i]));
+				FillH2CCmd92D(adapter, H2C_RSSI_REPORT, 3, (u8 *)(&PWDB_rssi[i]));
 			}
 		}
 	}
@@ -1297,8 +1297,8 @@ static void PWDB_Monitor(
 		pdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
 	}
 
-	if (check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == true
-		&& check_fwstate(&Adapter->mlmepriv, _FW_LINKED) == true)
+	if (check_fwstate(&adapter->mlmepriv, WIFI_STATION_STATE) == true
+		&& check_fwstate(&adapter->mlmepriv, _FW_LINKED) == true)
 	{
 		/*  Indicate Rx signal strength to FW. */
 		if (pHalData->fw_ractrl == true)
@@ -1313,30 +1313,30 @@ static void PWDB_Monitor(
 			/*  Commented by Kurt 20120705 */
 			/*  We could set max mac_id to FW without checking how many STAs we allocated */
 			/*  It's recommanded by SD3 */
-			/*  Original: temp = temp | ((Adapter->stapriv.asoc_sta_count+1) << 8); */
+			/*  Original: temp = temp | ((adapter->stapriv.asoc_sta_count+1) << 8); */
 			temp = temp | ((32) << 8);
 
-			FillH2CCmd92D(Adapter, H2C_RSSI_REPORT, 3, (u8 *)(&temp));
+			FillH2CCmd92D(adapter, H2C_RSSI_REPORT, 3, (u8 *)(&temp));
 		}
 		else
 		{
-			rtw_write8(Adapter, 0x4fe, (u8)pdmpriv->UndecoratedSmoothedPWDB);
+			rtw_write8(adapter, 0x4fe, (u8)pdmpriv->UndecoratedSmoothedPWDB);
 		}
 	}
 }
 
 static void
 DM_InitEdcaTurbo(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	pHalData->bCurrentTurboEDCA = false;
-	Adapter->recvpriv.bIsAnyNonBEPkts = false;
+	adapter->recvpriv.bIsAnyNonBEPkts = false;
 }	/*  DM_InitEdcaTurbo */
 
-static void dm_CheckEdcaTurbo(struct rtw_adapter *Adapter)
+static void dm_CheckEdcaTurbo(struct rtw_adapter *adapter)
 {
 	u32	trafficIndex;
 	u32	edca_param;
@@ -1344,12 +1344,12 @@ static void dm_CheckEdcaTurbo(struct rtw
 	u64	cur_rx_bytes = 0;
 	u32	EDCA_BE[2] = {0x5ea42b, 0x5ea42b};
 	u8	bbtchange = false;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv *pdmpriv = &pHalData->dmpriv;
-	struct xmit_priv *pxmitpriv = &(Adapter->xmitpriv);
-	struct recv_priv *precvpriv = &(Adapter->recvpriv);
-	struct registry_priv *pregpriv = &Adapter->registrypriv;
-	struct mlme_ext_priv *pmlmeext = &(Adapter->mlmeextpriv);
+	struct xmit_priv *pxmitpriv = &(adapter->xmitpriv);
+	struct recv_priv *precvpriv = &(adapter->recvpriv);
+	struct registry_priv *pregpriv = &adapter->registrypriv;
+	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	if (IS_92D_SINGLEPHY(pHalData->VersionID))
@@ -1432,7 +1432,7 @@ static void dm_CheckEdcaTurbo(struct rtw
 				}
 			}
 
-			rtw_write32(Adapter, REG_EDCA_BE_PARAM, edca_param);
+			rtw_write32(adapter, REG_EDCA_BE_PARAM, edca_param);
 
 			pdmpriv->prv_traffic_idx = trafficIndex;
 		}
@@ -1447,7 +1447,7 @@ static void dm_CheckEdcaTurbo(struct rtw
 		/*  */
 		 if (pHalData->bCurrentTurboEDCA)
 		{
-			rtw_write32(Adapter, REG_EDCA_BE_PARAM, pHalData->AcParam_BE);
+			rtw_write32(adapter, REG_EDCA_BE_PARAM, pHalData->AcParam_BE);
 			pHalData->bCurrentTurboEDCA = false;
 		}
 	}
@@ -1460,10 +1460,10 @@ dm_CheckEdcaTurbo_EXIT:
 }	/*  dm_CheckEdcaTurbo */
 
 static void dm_InitDynamicBBPowerSaving(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct PS_T *dm_pstable = &pdmpriv->DM_PSTable;
 
@@ -1475,10 +1475,10 @@ static void dm_InitDynamicBBPowerSaving(
 
 static void
 dm_DynamicBBPowerSaving(
-struct rtw_adapter *	pAdapter
+struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	/* 1 Power Saving for 92C */
 	if (IS_92D_SINGLEPHY(pHalData->VersionID))
@@ -1486,13 +1486,13 @@ struct rtw_adapter *	pAdapter
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		if (!pHalData->bSlaveOfDMSP)
 #endif
-			dm_1R_CCA(pAdapter);
+			dm_1R_CCA(adapter);
 	}
 }
 
 static	void
 dm_RXGainTrackingCallback_ThermalMeter_92D(
-	struct rtw_adapter *	Adapter)
+	struct rtw_adapter *	adapter)
 {
 	u8			index_mapping[Rx_index_mapping_NUM] = {
 						0x0f, 0x0f, 0x0f, 0x0f, 0x0b,
@@ -1502,22 +1502,22 @@ dm_RXGainTrackingCallback_ThermalMeter_9
 
 	u8			eRFPath;
 	u32			u4tmp;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
 	u4tmp = (index_mapping[(pHalData->EEPROMThermalMeter - pdmpriv->ThermalValue_RxGain)]) << 12;
 
 	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++) {
-		PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_RXRF_A3, bRFRegOffsetMask, (pdmpriv->RegRF3C[eRFPath]&(~(0xF000)))|u4tmp);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_RXRF_A3, bRFRegOffsetMask, (pdmpriv->RegRF3C[eRFPath]&(~(0xF000)))|u4tmp);
 	}
 };
 
 /* 091212 chiyokolin */
 static	void
 dm_TXPowerTrackingCallback_ThermalMeter_92D(
-            struct rtw_adapter *	Adapter)
+            struct rtw_adapter *	adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u8		ThermalValue = 0, delta, delta_LCK, delta_IQK, delta_RxGain, index, offset;
 	u8		ThermalValue_AVG_count = 0;
@@ -1572,10 +1572,10 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 		pdmpriv->bCCKinCH14 = false;
 
 
-	ThermalValue = (u8)PHY_QueryRFReg(Adapter, RF_PATH_A, RF_T_METER, 0xf800);	/* 0x42: RF Reg[15:11] 92D */
+	ThermalValue = (u8)PHY_QueryRFReg(adapter, RF_PATH_A, RF_T_METER, 0xf800);	/* 0x42: RF Reg[15:11] 92D */
 
 
-	rtl8192d_PHY_APCalibrate(Adapter, (ThermalValue - pHalData->EEPROMThermalMeter));/* notes:EEPROMThermalMeter is a fixed value from efuse/eeprom */
+	rtl8192d_PHY_APCalibrate(adapter, (ThermalValue - pHalData->EEPROMThermalMeter));/* notes:EEPROMThermalMeter is a fixed value from efuse/eeprom */
 
 	if (is2T)
 		rf = 2;
@@ -1586,7 +1586,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 	{
 		{
 			/* Query OFDM path A default setting */
-			ele_D = PHY_QueryBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord)&bMaskOFDM_D;
+			ele_D = PHY_QueryBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord)&bMaskOFDM_D;
 			for (i=0; i<OFDM_TABLE_SIZE_92D; i++)	/* find the index */
 			{
 				if (ele_D == (OFDMSwingTable[i]&bMaskOFDM_D))
@@ -1599,7 +1599,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 			/* Query OFDM path B default setting */
 			if (is2T)
 			{
-				ele_D = PHY_QueryBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord)&bMaskOFDM_D;
+				ele_D = PHY_QueryBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord)&bMaskOFDM_D;
 				for (i=0; i<OFDM_TABLE_SIZE_92D; i++)	/* find the index */
 				{
 					if (ele_D == (OFDMSwingTable[i]&bMaskOFDM_D))
@@ -1700,7 +1700,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 		if ((delta_LCK > pdmpriv->Delta_LCK) && (pdmpriv->Delta_LCK != 0))
 		{
 			pdmpriv->ThermalValue_LCK = ThermalValue;
-			rtl8192d_PHY_LCCalibrate(Adapter);
+			rtl8192d_PHY_LCCalibrate(adapter);
 		}
 
 		if (delta > 0 && pdmpriv->TxPowerTrackControl)
@@ -1866,44 +1866,44 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 
 					/* wirte new elements A, C, D to regC80 and regC94, element B is always 0 */
 					value32 = (ele_D<<22)|((ele_C&0x3F)<<16)|ele_A;
-					PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, value32);
+					PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, value32);
 
 					value32 = (ele_C&0x000003C0)>>6;
-					PHY_SetBBReg(Adapter, rOFDM0_XCTxAFE, bMaskH4Bits, value32);
+					PHY_SetBBReg(adapter, rOFDM0_XCTxAFE, bMaskH4Bits, value32);
 
 					value32 = ((X * ele_D)>>7)&0x01;
-					PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT24, value32);
+					PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT24, value32);
 
 				}
 				else
 				{
-					PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, OFDMSwingTable[(u8)OFDM_index[0]]);
-					PHY_SetBBReg(Adapter, rOFDM0_XCTxAFE, bMaskH4Bits, 0x00);
-					PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT24, 0x00);
+					PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, OFDMSwingTable[(u8)OFDM_index[0]]);
+					PHY_SetBBReg(adapter, rOFDM0_XCTxAFE, bMaskH4Bits, 0x00);
+					PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT24, 0x00);
 				}
 
 				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 				{
 					/* Adjust CCK according to IQK result */
 					if (!pdmpriv->bCCKinCH14) {
-						rtw_write8(Adapter, 0xa22, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][0]);
-						rtw_write8(Adapter, 0xa23, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][1]);
-						rtw_write8(Adapter, 0xa24, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][2]);
-						rtw_write8(Adapter, 0xa25, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][3]);
-						rtw_write8(Adapter, 0xa26, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][4]);
-						rtw_write8(Adapter, 0xa27, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][5]);
-						rtw_write8(Adapter, 0xa28, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][6]);
-						rtw_write8(Adapter, 0xa29, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][7]);
+						rtw_write8(adapter, 0xa22, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][0]);
+						rtw_write8(adapter, 0xa23, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][1]);
+						rtw_write8(adapter, 0xa24, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][2]);
+						rtw_write8(adapter, 0xa25, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][3]);
+						rtw_write8(adapter, 0xa26, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][4]);
+						rtw_write8(adapter, 0xa27, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][5]);
+						rtw_write8(adapter, 0xa28, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][6]);
+						rtw_write8(adapter, 0xa29, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][7]);
 					}
 					else {
-						rtw_write8(Adapter, 0xa22, CCKSwingTable_Ch14[(u8)CCK_index][0]);
-						rtw_write8(Adapter, 0xa23, CCKSwingTable_Ch14[(u8)CCK_index][1]);
-						rtw_write8(Adapter, 0xa24, CCKSwingTable_Ch14[(u8)CCK_index][2]);
-						rtw_write8(Adapter, 0xa25, CCKSwingTable_Ch14[(u8)CCK_index][3]);
-						rtw_write8(Adapter, 0xa26, CCKSwingTable_Ch14[(u8)CCK_index][4]);
-						rtw_write8(Adapter, 0xa27, CCKSwingTable_Ch14[(u8)CCK_index][5]);
-						rtw_write8(Adapter, 0xa28, CCKSwingTable_Ch14[(u8)CCK_index][6]);
-						rtw_write8(Adapter, 0xa29, CCKSwingTable_Ch14[(u8)CCK_index][7]);
+						rtw_write8(adapter, 0xa22, CCKSwingTable_Ch14[(u8)CCK_index][0]);
+						rtw_write8(adapter, 0xa23, CCKSwingTable_Ch14[(u8)CCK_index][1]);
+						rtw_write8(adapter, 0xa24, CCKSwingTable_Ch14[(u8)CCK_index][2]);
+						rtw_write8(adapter, 0xa25, CCKSwingTable_Ch14[(u8)CCK_index][3]);
+						rtw_write8(adapter, 0xa26, CCKSwingTable_Ch14[(u8)CCK_index][4]);
+						rtw_write8(adapter, 0xa27, CCKSwingTable_Ch14[(u8)CCK_index][5]);
+						rtw_write8(adapter, 0xa28, CCKSwingTable_Ch14[(u8)CCK_index][6]);
+						rtw_write8(adapter, 0xa29, CCKSwingTable_Ch14[(u8)CCK_index][7]);
 					}
 				}
 
@@ -1928,20 +1928,20 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 
 						/* wirte new elements A, C, D to regC88 and regC9C, element B is always 0 */
 						value32=(ele_D<<22)|((ele_C&0x3F)<<16) |ele_A;
-						PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, value32);
+						PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, value32);
 
 						value32 = (ele_C&0x000003C0)>>6;
-						PHY_SetBBReg(Adapter, rOFDM0_XDTxAFE, bMaskH4Bits, value32);
+						PHY_SetBBReg(adapter, rOFDM0_XDTxAFE, bMaskH4Bits, value32);
 
 						value32 = ((X * ele_D)>>7)&0x01;
-						PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT28, value32);
+						PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT28, value32);
 
 					}
 					else
 					{
-						PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, OFDMSwingTable[(u8)OFDM_index[1]]);
-						PHY_SetBBReg(Adapter, rOFDM0_XDTxAFE, bMaskH4Bits, 0x00);
-						PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT28, 0x00);
+						PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, OFDMSwingTable[(u8)OFDM_index[1]]);
+						PHY_SetBBReg(adapter, rOFDM0_XDTxAFE, bMaskH4Bits, 0x00);
+						PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT28, 0x00);
 					}
 
 				}
@@ -1951,21 +1951,21 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 
 		if ((delta_IQK > pdmpriv->Delta_IQK) && (pdmpriv->Delta_IQK != 0))
 		{
-			rtl8192d_PHY_ResetIQKResult(Adapter);
+			rtl8192d_PHY_ResetIQKResult(adapter);
 #ifdef CONFIG_CONCURRENT_MODE
-			if (rtw_buddy_adapter_up(Adapter)) {
-				rtl8192d_PHY_ResetIQKResult(Adapter->pbuddy_adapter);
+			if (rtw_buddy_adapter_up(adapter)) {
+				rtl8192d_PHY_ResetIQKResult(adapter->pbuddy_adapter);
 			}
 #endif
 			pdmpriv->ThermalValue_IQK = ThermalValue;
-			rtl8192d_PHY_IQCalibrate(Adapter);
+			rtl8192d_PHY_IQCalibrate(adapter);
 		}
 
 		if (delta_RxGain > 0 && pHalData->CurrentBandType92D == BAND_ON_5G
 			&& ThermalValue <= pHalData->EEPROMThermalMeter && pHalData->bNOPG == false)
 		{
 			pdmpriv->ThermalValue_RxGain = ThermalValue;
-			dm_RXGainTrackingCallback_ThermalMeter_92D(Adapter);
+			dm_RXGainTrackingCallback_ThermalMeter_92D(adapter);
 		}
 
 		/* update thermal meter value */
@@ -1983,9 +1983,9 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 
 static	void
 dm_InitializeTXPowerTracking_ThermalMeter(
-	struct rtw_adapter *		Adapter)
+	struct rtw_adapter *		adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
 	{
@@ -2002,11 +2002,11 @@ dm_InitializeTXPowerTracking_ThermalMete
 
 static void
 DM_InitializeTXPowerTracking(
-	struct rtw_adapter *		Adapter)
+	struct rtw_adapter *		adapter)
 {
 
 	{
-		dm_InitializeTXPowerTracking_ThermalMeter(Adapter);
+		dm_InitializeTXPowerTracking_ThermalMeter(adapter);
 	}
 }
 
@@ -2023,16 +2023,16 @@ DM_InitializeTXPowerTracking(
 /*  */
 static void
 DM_TXPowerTracking92CDirectCall(
-            struct rtw_adapter *		Adapter)
+            struct rtw_adapter *		adapter)
 {
-	dm_TXPowerTrackingCallback_ThermalMeter_92D(Adapter);
+	dm_TXPowerTrackingCallback_ThermalMeter_92D(adapter);
 }
 
 static void
 dm_CheckTXPowerTracking_ThermalMeter(
-	struct rtw_adapter *		Adapter)
+	struct rtw_adapter *		adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
 	if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_SS))
@@ -2048,13 +2048,13 @@ dm_CheckTXPowerTracking_ThermalMeter(
 	if (!pdmpriv->TM_Trigger)		/* at least delay 1 sec */
 	{
 
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_T_METER, BIT17 | BIT16, 0x03);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_T_METER, BIT17 | BIT16, 0x03);
 		pdmpriv->TM_Trigger = 1;
 		return;
 	}
 	else
 	{
-		DM_TXPowerTracking92CDirectCall(Adapter); /* Using direct call is instead, added by Roger, 2009.06.18. */
+		DM_TXPowerTracking92CDirectCall(adapter); /* Using direct call is instead, added by Roger, 2009.06.18. */
 		pdmpriv->TM_Trigger = 0;
 	}
 }
@@ -2062,13 +2062,13 @@ dm_CheckTXPowerTracking_ThermalMeter(
 
 void
 rtl8192d_dm_CheckTXPowerTracking(
-	struct rtw_adapter *		Adapter)
+	struct rtw_adapter *		adapter)
 {
 
 #if DISABLE_BB_RF
 	return;
 #endif
-	dm_CheckTXPowerTracking_ThermalMeter(Adapter);
+	dm_CheckTXPowerTracking_ThermalMeter(adapter);
 }
 
 
@@ -2090,7 +2090,7 @@ rtl8192d_dm_CheckTXPowerTracking(
  *---------------------------------------------------------------------------*/
 static void
 dm_CheckRfCtrlGPIO(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
 }	/* dm_CheckRfCtrlGPIO */
@@ -2167,9 +2167,9 @@ static void	dm_CheckPbcGPIO(struct rtw_a
 	}
 }
 
-static void dm_InitRateAdaptiveMask(struct rtw_adapter *	Adapter)
+static void dm_InitRateAdaptiveMask(struct rtw_adapter *	adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct rate_adaptive *ra = (struct rate_adaptive *)&pdmpriv->RateAdaptive;
 
@@ -2200,19 +2200,19 @@ static void dm_InitRateAdaptiveMask(stru
  *
  *---------------------------------------------------------------------------*/
 static void
-dm_RefreshRateAdaptiveMask(struct rtw_adapter *	pAdapter)
+dm_RefreshRateAdaptiveMask(struct rtw_adapter *	adapter)
 {
 }
 static void
 dm_CheckProtection(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
 }
 
 static void
 dm_CheckStatistics(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
 }
@@ -2222,33 +2222,33 @@ dm_CheckStatistics(
 /*  */
 static void
 dm_InitGPIOSetting(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
 	u8	tmp1byte;
 
-	tmp1byte = rtw_read8(Adapter, REG_GPIO_MUXCFG);
+	tmp1byte = rtw_read8(adapter, REG_GPIO_MUXCFG);
 	tmp1byte &= (GPIOSEL_GPIO | ~GPIOSEL_ENBT);
-	rtw_write8(Adapter, REG_GPIO_MUXCFG, tmp1byte);
+	rtw_write8(adapter, REG_GPIO_MUXCFG, tmp1byte);
 }
 
 /*  */
 /*  functions */
 /*  */
-void rtl8192d_init_dm_priv(struct rtw_adapter * Adapter)
+void rtl8192d_init_dm_priv(struct rtw_adapter * adapter)
 {
 }
 
-void rtl8192d_deinit_dm_priv(struct rtw_adapter * Adapter)
+void rtl8192d_deinit_dm_priv(struct rtw_adapter * adapter)
 {
 }
 
 void
 rtl8192d_InitHalDm(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u8	i;
 
@@ -2259,46 +2259,46 @@ rtl8192d_InitHalDm(
 	/* 1 DIG INIT */
 	pdmpriv->bDMInitialGainEnable = true;
 	pdmpriv->DMFlag |= DYNAMIC_FUNC_DIG;
-	dm_DIGInit(Adapter);
+	dm_DIGInit(adapter);
 
 	/* 2 DynamicTxPower INIT */
 	pdmpriv->DMFlag |= DYNAMIC_FUNC_HP;
-	dm_InitDynamicTxPower(Adapter);
+	dm_InitDynamicTxPower(adapter);
 
 	/* 3 */
-	DM_InitEdcaTurbo(Adapter);/* moved to  linked_status_chk() */
+	DM_InitEdcaTurbo(adapter);/* moved to  linked_status_chk() */
 
 	/* 4 RateAdaptive INIT */
-	dm_InitRateAdaptiveMask(Adapter);
+	dm_InitRateAdaptiveMask(adapter);
 
 	/* 5 Tx Power Tracking Init. */
 	pdmpriv->DMFlag |= DYNAMIC_FUNC_SS;
-	DM_InitializeTXPowerTracking(Adapter);
+	DM_InitializeTXPowerTracking(adapter);
 
-	dm_InitDynamicBBPowerSaving(Adapter);
+	dm_InitDynamicBBPowerSaving(adapter);
 
-	dm_InitGPIOSetting(Adapter);
+	dm_InitGPIOSetting(adapter);
 
 	pdmpriv->DMFlag_tmp = pdmpriv->DMFlag;
 
 	/*  Save REG_INIDATA_RATE_SEL value for TXDESC. */
 	for (i = 0 ; i<32 ; i++)
 	{
-		pdmpriv->INIDATA_RATE[i] = rtw_read8(Adapter, REG_INIDATA_RATE_SEL+i) & 0x3f;
+		pdmpriv->INIDATA_RATE[i] = rtw_read8(adapter, REG_INIDATA_RATE_SEL+i) & 0x3f;
 	}
 }
 
 #ifdef CONFIG_CONCURRENT_MODE
-static void FindMinimumRSSI(struct rtw_adapter * Adapter)
+static void FindMinimumRSSI(struct rtw_adapter * adapter)
 {
 	struct hal_data_8192du *pbuddy_HalData;
 	struct dm_priv *pbuddy_dmpriv;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	struct rtw_adapter * pbuddy_adapter = Adapter->pbuddy_adapter;
-	struct mlme_priv *pmlmepriv = &Adapter->mlmepriv;
+	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
 
-	if (!rtw_buddy_adapter_up(Adapter))
+	if (!rtw_buddy_adapter_up(adapter))
 		return;
 
 	pbuddy_HalData = GET_HAL_DATA(pbuddy_adapter);
@@ -2306,31 +2306,31 @@ static void FindMinimumRSSI(struct rtw_a
 
 	/* get min. [PWDB] when both interfaces are connected */
 	if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
-		&& Adapter->stapriv.asoc_sta_count > 2
-		&& check_buddy_fwstate(Adapter, _FW_LINKED)) ||
-		(check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true
+		&& adapter->stapriv.asoc_sta_count > 2
+		&& check_buddy_fwstate(adapter, _FW_LINKED)) ||
+		(check_buddy_fwstate(adapter, WIFI_AP_STATE) == true
 		&& pbuddy_adapter->stapriv.asoc_sta_count > 2
 		&& check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
 		(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
 		&& check_fwstate(pmlmepriv, _FW_LINKED)
-		&& check_buddy_fwstate(Adapter,WIFI_STATION_STATE)
-		&& check_buddy_fwstate(Adapter,_FW_LINKED)))
+		&& check_buddy_fwstate(adapter,WIFI_STATION_STATE)
+		&& check_buddy_fwstate(adapter,_FW_LINKED)))
 	{
 		/* select smaller PWDB */
 		if (pdmpriv->UndecoratedSmoothedPWDB > pbuddy_dmpriv->UndecoratedSmoothedPWDB)
 			pdmpriv->UndecoratedSmoothedPWDB = pbuddy_dmpriv->UndecoratedSmoothedPWDB;
 	}/* secondary interface is connected */
-	else if ((check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true
+	else if ((check_buddy_fwstate(adapter, WIFI_AP_STATE) == true
 		&& pbuddy_adapter->stapriv.asoc_sta_count > 2) ||
-		(check_buddy_fwstate(Adapter,WIFI_STATION_STATE)
-		&& check_buddy_fwstate(Adapter,_FW_LINKED)))
+		(check_buddy_fwstate(adapter,WIFI_STATION_STATE)
+		&& check_buddy_fwstate(adapter,_FW_LINKED)))
 	{
 		/* select buddy PWDB */
 		pdmpriv->UndecoratedSmoothedPWDB = pbuddy_dmpriv->UndecoratedSmoothedPWDB;
 	}
 	/* primary is connected */
 	else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
-		&& Adapter->stapriv.asoc_sta_count > 2) ||
+		&& adapter->stapriv.asoc_sta_count > 2) ||
 		(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
 		&& check_fwstate(pmlmepriv, _FW_LINKED)))
 	{
@@ -2345,11 +2345,11 @@ static void FindMinimumRSSI(struct rtw_a
 	}
 
 	/* primary interface is ap mode */
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true && Adapter->stapriv.asoc_sta_count > 2)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true && adapter->stapriv.asoc_sta_count > 2)
 	{
 		pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
 	}/* secondary interface is ap mode */
-	else if (check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true && pbuddy_adapter->stapriv.asoc_sta_count > 2)
+	else if (check_buddy_fwstate(adapter, WIFI_AP_STATE) == true && pbuddy_adapter->stapriv.asoc_sta_count > 2)
 	{
 		pdmpriv->EntryMinUndecoratedSmoothedPWDB = pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB;
 	}
@@ -2362,16 +2362,16 @@ static void FindMinimumRSSI(struct rtw_a
 
 void
 rtl8192d_HalDmWatchDog(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
 	bool		bFwCurrentInPSMode = false;
 	bool		bFwPSAwake = true;
 	u8 hw_init_completed = false;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 #ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter * pbuddy_adapter = Adapter->pbuddy_adapter;
+	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
 #endif /* CONFIG_CONCURRENT_MODE */
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -2383,12 +2383,12 @@ rtl8192d_HalDmWatchDog(
 #endif
 
 	#if defined(CONFIG_CONCURRENT_MODE)
-	if (Adapter->isprimary == false && pbuddy_adapter) {
+	if (adapter->isprimary == false && pbuddy_adapter) {
 		hw_init_completed = pbuddy_adapter->hw_init_completed;
 	} else
 	#endif
 	{
-		hw_init_completed = Adapter->hw_init_completed;
+		hw_init_completed = adapter->hw_init_completed;
 	}
 
 	if (hw_init_completed == false)
@@ -2396,21 +2396,21 @@ rtl8192d_HalDmWatchDog(
 
 #ifdef CONFIG_LPS
 	#if defined(CONFIG_CONCURRENT_MODE)
-	if (Adapter->iface_type != IFACE_PORT0 && pbuddy_adapter) {
+	if (adapter->iface_type != IFACE_PORT0 && pbuddy_adapter) {
 		bFwCurrentInPSMode = pbuddy_adapter->pwrctrlpriv.bFwCurrentInPSMode;
 		rtw_hal_get_hwreg(pbuddy_adapter, HW_VAR_FWLPS_RF_ON, (u8 *)(&bFwPSAwake));
 	} else
 	#endif
 	{
-		bFwCurrentInPSMode = Adapter->pwrctrlpriv.bFwCurrentInPSMode;
-		rtw_hal_get_hwreg(Adapter, HW_VAR_FWLPS_RF_ON, (u8 *)(&bFwPSAwake));
+		bFwCurrentInPSMode = adapter->pwrctrlpriv.bFwCurrentInPSMode;
+		rtw_hal_get_hwreg(adapter, HW_VAR_FWLPS_RF_ON, (u8 *)(&bFwPSAwake));
 	}
 #endif
 
 #ifdef CONFIG_P2P_PS
 	/*  Fw is under p2p powersaving mode, driver should stop dynamic mechanism. */
 	/*  modifed by thomas. 2011.06.11. */
-	if (Adapter->wdinfo.p2p_ps_mode)
+	if (adapter->wdinfo.p2p_ps_mode)
 		bFwPSAwake = false;
 #endif /*  CONFIG_P2P_PS */
 
@@ -2429,94 +2429,94 @@ rtl8192d_HalDmWatchDog(
 		/*  */
 		/*  Calculate Tx/Rx statistics. */
 		/*  */
-		dm_CheckStatistics(Adapter);
+		dm_CheckStatistics(adapter);
 
 		/*  */
 		/*  For PWDB monitor and record some value for later use. */
 		/*  */
-		PWDB_Monitor(Adapter);
+		PWDB_Monitor(adapter);
 #ifdef CONFIG_CONCURRENT_MODE
-		if (Adapter->adapter_type > PRIMARY_ADAPTER)
+		if (adapter->adapter_type > PRIMARY_ADAPTER)
 			goto _record_initrate;
-		FindMinimumRSSI(Adapter);
+		FindMinimumRSSI(adapter);
 #endif /* CONFIG_CONCURRENT_MODE */
 		/*  */
 		/*  Dynamic Initial Gain mechanism. */
 		/*  */
 /* sherry delete flag 20110517 */
-		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForGlobalAdapterList);
+		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForGlobaladapterList);
 		if (pHalData->bSlaveOfDMSP)
 		{
-			odm_FalseAlarmCounterStatistics_ForSlaveOfDMSP(Adapter);
+			odm_FalseAlarmCounterStatistics_ForSlaveOfDMSP(adapter);
 		}
 		else
 		{
-			odm_FalseAlarmCounterStatistics(Adapter);
+			odm_FalseAlarmCounterStatistics(adapter);
 		}
-		RELEASE_GLOBAL_MUTEX(GlobalMutexForGlobalAdapterList);
+		RELEASE_GLOBAL_MUTEX(GlobalMutexForGlobaladapterList);
 #ifndef CONFIG_CONCURRENT_MODE
-		odm_FindMinimumRSSI_92D(Adapter);
+		odm_FindMinimumRSSI_92D(adapter);
 #endif /* CONFIG_CONCURRENT_MODE */
-		odm_DIG(Adapter);
+		odm_DIG(adapter);
 		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
 			if (pHalData->CurrentBandType92D != BAND_ON_5G)
-				dm_CCK_PacketDetectionThresh_DMSP(Adapter);
+				dm_CCK_PacketDetectionThresh_DMSP(adapter);
 		}
 		else
 		{
 			if (pHalData->CurrentBandType92D != BAND_ON_5G)
-				dm_CCK_PacketDetectionThresh(Adapter);
+				dm_CCK_PacketDetectionThresh(adapter);
 		}
 
 		/*  */
 		/*  Dynamic Tx Power mechanism. */
 		/*  */
-		odm_DynamicTxPower_92D(Adapter);
+		odm_DynamicTxPower_92D(adapter);
 
 		/*  */
 		/*  Tx Power Tracking. */
 		/*  */
 		/* TX power tracking will make 92de DMDP MAC0's throughput bad. */
 #ifdef CONFIG_DUALMAC_CONCURRENT
-		if (!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
+		if (!pHalData->bSlaveOfDMSP || adapter->DualMacConcurrent == false)
 #endif
-			rtl8192d_dm_CheckTXPowerTracking(Adapter);
+			rtl8192d_dm_CheckTXPowerTracking(adapter);
 
 		/*  */
 		/*  Rate Adaptive by Rx Signal Strength mechanism. */
 		/*  */
-		dm_RefreshRateAdaptiveMask(Adapter);
+		dm_RefreshRateAdaptiveMask(adapter);
 
 		/*  EDCA turbo */
 		/* update the EDCA paramter according to the Tx/RX mode */
-		dm_CheckEdcaTurbo(Adapter);
+		dm_CheckEdcaTurbo(adapter);
 
 		/*  */
 		/*  Dynamically switch RTS/CTS protection. */
 		/*  */
-		/* dm_CheckProtection(Adapter); */
+		/* dm_CheckProtection(adapter); */
 
 		/*  */
 		/* Dynamic BB Power Saving Mechanism */
 		/* vivi, 20101014, to pass DTM item: softap_excludeunencrypted_ext.htm */
 		/* temporarily disable it advised for performance test by yn,2010-11-03. */
-		dm_DynamicBBPowerSaving(Adapter);
+		dm_DynamicBBPowerSaving(adapter);
 
 _record_initrate:
 
 		/*  Read REG_INIDATA_RATE_SEL value for TXDESC. */
-		if (check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == true)
+		if (check_fwstate(&adapter->mlmepriv, WIFI_STATION_STATE) == true)
 		{
-			pdmpriv->INIDATA_RATE[0] = rtw_read8(Adapter, REG_INIDATA_RATE_SEL) & 0x3f;
+			pdmpriv->INIDATA_RATE[0] = rtw_read8(adapter, REG_INIDATA_RATE_SEL) & 0x3f;
 
 #ifdef CONFIG_TDLS
-			if (Adapter->tdlsinfo.setup_state == TDLS_LINKED_STATE)
+			if (adapter->tdlsinfo.setup_state == TDLS_LINKED_STATE)
 			{
 				u8 i=1;
-				for (; i < (Adapter->tdlsinfo.macid_index) ; i++)
+				for (; i < (adapter->tdlsinfo.macid_index) ; i++)
 				{
-					pdmpriv->INIDATA_RATE[i] = rtw_read8(Adapter, (REG_INIDATA_RATE_SEL+i)) & 0x3f;
+					pdmpriv->INIDATA_RATE[i] = rtw_read8(adapter, (REG_INIDATA_RATE_SEL+i)) & 0x3f;
 				}
 			}
 #endif /* CONFIG_TDLS */
@@ -2525,9 +2525,9 @@ _record_initrate:
 		else
 		{
 			u8	i;
-			for (i=1 ; i < (Adapter->stapriv.asoc_sta_count + 1); i++)
+			for (i=1 ; i < (adapter->stapriv.asoc_sta_count + 1); i++)
 			{
-				pdmpriv->INIDATA_RATE[i] = rtw_read8(Adapter, (REG_INIDATA_RATE_SEL+i)) & 0x3f;
+				pdmpriv->INIDATA_RATE[i] = rtw_read8(adapter, (REG_INIDATA_RATE_SEL+i)) & 0x3f;
 			}
 		}
 	}
@@ -2538,6 +2538,6 @@ skip_dm:
 	/*  Not enable for 92CU now!!! */
 	/*  Check Hardware Radio ON/OFF or not */
 
-	dm_CheckPbcGPIO(Adapter);				/*  Add by hpfan 2008-03-11 */
+	dm_CheckPbcGPIO(adapter);				/*  Add by hpfan 2008-03-11 */
 
 }
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -27,7 +27,7 @@
 #include <usb_hal.h>
 #include <rtl8192d_hal.h>
 
-atomic_t GlobalMutexForGlobalAdapterList = ATOMIC_INIT(0);
+atomic_t GlobalMutexForGlobaladapterList = ATOMIC_INIT(0);
 atomic_t GlobalMutexForMac0_2G_Mac1_5G = ATOMIC_INIT(0);
 atomic_t GlobalMutexForPowerAndEfuse = ATOMIC_INIT(0);
 atomic_t GlobalMutexForPowerOnAndPowerOff = ATOMIC_INIT(0);
@@ -40,13 +40,13 @@ bool GlobalFirstConfigurationForNormalCh
 
 static bool
 _IsFWDownloaded(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	)
 {
-	return ((rtw_read32(Adapter, REG_MCUFWDL) & MCUFWDL_RDY) ? true : false);
+	return ((rtw_read32(adapter, REG_MCUFWDL) & MCUFWDL_RDY) ? true : false);
 }
 
-static void _FWDownloadEnable(struct rtw_adapter *Adapter, bool enable)
+static void _FWDownloadEnable(struct rtw_adapter *adapter, bool enable)
 {
 	u8	tmp;
 
@@ -54,29 +54,29 @@ static void _FWDownloadEnable(struct rtw
 		#ifdef DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE
 		{
 			u8 val;
-			if ((val=rtw_read8(Adapter, REG_MCUFWDL)))
+			if ((val=rtw_read8(adapter, REG_MCUFWDL)))
 				DBG_8192D("DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE %s:%d REG_MCUFWDL:0x%02x\n", __func__, __LINE__, val);
 		}
 		#endif
 		/*  8051 enable */
-		tmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
-		rtw_write8(Adapter, REG_SYS_FUNC_EN+1, tmp|0x04);
+		tmp = rtw_read8(adapter, REG_SYS_FUNC_EN+1);
+		rtw_write8(adapter, REG_SYS_FUNC_EN+1, tmp|0x04);
 
 		/*  MCU firmware download enable. */
-		tmp = rtw_read8(Adapter, REG_MCUFWDL);
-		rtw_write8(Adapter, REG_MCUFWDL, tmp|0x01);
+		tmp = rtw_read8(adapter, REG_MCUFWDL);
+		rtw_write8(adapter, REG_MCUFWDL, tmp|0x01);
 
 		/*  8051 reset */
-		tmp = rtw_read8(Adapter, REG_MCUFWDL+2);
-		rtw_write8(Adapter, REG_MCUFWDL+2, tmp&0xf7);
+		tmp = rtw_read8(adapter, REG_MCUFWDL+2);
+		rtw_write8(adapter, REG_MCUFWDL+2, tmp&0xf7);
 	} else {
 		/*  MCU firmware download enable. */
-		tmp = rtw_read8(Adapter, REG_MCUFWDL);
-		rtw_write8(Adapter, REG_MCUFWDL, tmp&0xfe);
+		tmp = rtw_read8(adapter, REG_MCUFWDL);
+		rtw_write8(adapter, REG_MCUFWDL, tmp&0xfe);
 	}
 }
 
-static int _BlockWrite_92d(struct rtw_adapter *Adapter, void *buffer, u32 size)
+static int _BlockWrite_92d(struct rtw_adapter *adapter, void *buffer, u32 size)
 {
 	int ret = _SUCCESS;
 	u32			blockSize8 = sizeof(u64);
@@ -90,7 +90,7 @@ static int _BlockWrite_92d(struct rtw_ad
 	remain8 = size % blockSize;
 	for (i = 0 ; i < blockCount ; i++) {
 		offset = i * blockSize;
-		ret = rtw_writeN(Adapter, (FW_8192D_START_ADDRESS + offset), 64,(bufferPtr + offset));
+		ret = rtw_writeN(adapter, (FW_8192D_START_ADDRESS + offset), 64,(bufferPtr + offset));
 
 		if (ret == _FAIL)
 			goto exit;
@@ -102,7 +102,7 @@ static int _BlockWrite_92d(struct rtw_ad
 		blockCount8=remain8/blockSize8;
 		remain4=remain8%blockSize8;
 		for (i = 0 ; i < blockCount8 ; i++) {
-			ret = rtw_writeN(Adapter, (FW_8192D_START_ADDRESS + offset+i*blockSize8), 8,(bufferPtr + offset+i*blockSize8));
+			ret = rtw_writeN(adapter, (FW_8192D_START_ADDRESS + offset+i*blockSize8), 8,(bufferPtr + offset+i*blockSize8));
 
 			if (ret == _FAIL)
 				goto exit;
@@ -114,7 +114,7 @@ static int _BlockWrite_92d(struct rtw_ad
 			remainSize=remain8%blocksize4;
 
 			for (i = 0 ; i < blockCount4 ; i++) {
-				ret = rtw_write32(Adapter, (FW_8192D_START_ADDRESS + offset+i*blocksize4), le32_to_cpu(*(__le32 *)(pu4BytePtr+ offset/4+i)));
+				ret = rtw_write32(adapter, (FW_8192D_START_ADDRESS + offset+i*blocksize4), le32_to_cpu(*(__le32 *)(pu4BytePtr+ offset/4+i)));
 
 				if (ret == _FAIL)
 					goto exit;
@@ -123,7 +123,7 @@ static int _BlockWrite_92d(struct rtw_ad
 			if (remainSize) {
 				offset=blockCount * blockSize+blockCount8*blockSize8+blockCount4*blocksize4;
 				for (i = 0 ; i < remainSize ; i++) {
-					ret = rtw_write8(Adapter, (FW_8192D_START_ADDRESS + offset + i), *(bufferPtr +offset+ i));
+					ret = rtw_write8(adapter, (FW_8192D_START_ADDRESS + offset + i), *(bufferPtr +offset+ i));
 
 					if (ret == _FAIL)
 						goto exit;
@@ -138,42 +138,34 @@ exit:
 	return ret;
 }
 
-static int
-_PageWrite(
-		struct rtw_adapter *		Adapter,
-		u32			page,
-		void *			buffer,
-		u32			size
-	)
+static int _PageWrite(struct rtw_adapter *adapter, u32 page,
+		      void *buffer, u32 size)
 {
 	u8 value8;
-	u8 u8Page = (u8) (page & 0x07) ;
+	u8 u8page = (u8)(page & 0x07) ;
 
-	value8 = (rtw_read8(Adapter, REG_MCUFWDL+2)& 0xF8) | u8Page ;
-	rtw_write8(Adapter, REG_MCUFWDL+2,value8);
-	return _BlockWrite_92d(Adapter,buffer,size);
+	value8 = (rtw_read8(adapter, REG_MCUFWDL+2)& 0xF8) | u8page ;
+	rtw_write8(adapter, REG_MCUFWDL+2,value8);
+	return _BlockWrite_92d(adapter, buffer, size);
 }
 
-static int
-_WriteFW(
-		struct rtw_adapter *		Adapter,
-		void *			buffer,
-		u32			size
-	)
+static int _WriteFW(struct rtw_adapter *adapter, void *buffer, u32 size)
 {
 	int ret = _SUCCESS;
-	/*  Since we need dynamic decide method of dwonload fw, so we call this function to get chip version. */
-	/*  We can remove _ReadChipVersion from ReadAdapterInfo8192C later. */
-	u32	pageNums,remainSize ;
-	u32	page,offset;
-	u8*	bufferPtr = (u8*)buffer;
+	/*  Since we need to dynamically decide method of download fw,
+	 *  we call this function to get chip version.
+	 *  We can remove _ReadChipVersion from ReadadapterInfo8192C later.
+	 */
+	u32 pageNums,remainSize ;
+	u32 page,offset;
+	u8 *bufferPtr = (u8*)buffer;
 
 	pageNums = size / MAX_PAGE_SIZE ;
 	remainSize = size % MAX_PAGE_SIZE;
 
 	for (page = 0; page < pageNums;  page++) {
 		offset = page *MAX_PAGE_SIZE;
-		ret = _PageWrite(Adapter,page, (bufferPtr+offset),MAX_PAGE_SIZE);
+		ret = _PageWrite(adapter,page, (bufferPtr+offset),MAX_PAGE_SIZE);
 
 		if (ret == _FAIL)
 			goto exit;
@@ -181,7 +173,7 @@ _WriteFW(
 	if (remainSize) {
 		offset = pageNums *MAX_PAGE_SIZE;
 		page = pageNums;
-		ret = _PageWrite(Adapter,page, (bufferPtr+offset),remainSize);
+		ret = _PageWrite(adapter,page, (bufferPtr+offset),remainSize);
 
 		if (ret == _FAIL)
 			goto exit;
@@ -192,14 +184,15 @@ exit:
 	return ret;
 }
 
-static int _FWFreeToGo_92D(struct rtw_adapter *Adapter)
+static int _FWFreeToGo_92D(struct rtw_adapter *adapter)
 {
-	u32			counter = 0;
-	u32			value32;
+	u32 counter = 0;
+	u32 value32;
 	/*  polling CheckSum report */
-	do{
-		value32 = rtw_read32(Adapter, REG_MCUFWDL);
-	}while ((counter ++ < POLLING_READY_TIMEOUT_COUNT) && (!(value32 & FWDL_ChkSum_rpt )));
+	do {
+		value32 = rtw_read32(adapter, REG_MCUFWDL);
+	} while ((counter ++ < POLLING_READY_TIMEOUT_COUNT) &&
+		 (!(value32 & FWDL_ChkSum_rpt )));
 
 	if (counter >= POLLING_READY_TIMEOUT_COUNT) {
 		DBG_8192D("chksum report faill ! REG_MCUFWDL:0x%08x .\n",value32);
@@ -207,129 +200,112 @@ static int _FWFreeToGo_92D(struct rtw_ad
 	}
 	DBG_8192D("Checksum report OK ! REG_MCUFWDL:0x%08x .\n",value32);
 
-	value32 = rtw_read32(Adapter, REG_MCUFWDL);
+	value32 = rtw_read32(adapter, REG_MCUFWDL);
 	value32 |= MCUFWDL_RDY;
-	rtw_write32(Adapter, REG_MCUFWDL, value32);
+	rtw_write32(adapter, REG_MCUFWDL, value32);
 	return _SUCCESS;
 }
 
-void
-rtl8192d_FirmwareSelfReset(
-	struct rtw_adapter *		Adapter
-)
+void rtl8192d_FirmwareSelfReset(struct rtw_adapter *adapter)
 {
 	u8	u1bTmp;
 	u8	Delay = 100;
 
-	rtw_write8(Adapter, REG_FSIMR, 0x00);
-	/*  2010/08/25 MH Accordign to RD alfred's suggestion, we need to disable other */
-	/*  HRCV INT to influence 8051 reset. */
-	rtw_write8(Adapter, REG_FWIMR, 0x20);
-	/*  2011/02/15 MH According to Alex's suggestion, close mask to prevent incorrect FW write operation. */
-	rtw_write8(Adapter, REG_FTIMR, 0x00);
+	rtw_write8(adapter, REG_FSIMR, 0x00);
+	/*  disable other HRCV INT to influence 8051 reset. */
+	rtw_write8(adapter, REG_FWIMR, 0x20);
+	/*  close mask to prevent incorrect FW write operation. */
+	rtw_write8(adapter, REG_FTIMR, 0x00);
 
 	/* 0x1cf=0x20. Inform 8051 to reset. 2009.12.25. tynli_test */
-	rtw_write8(Adapter, REG_HMETFR+3, 0x20);
+	rtw_write8(adapter, REG_HMETFR+3, 0x20);
 
-	u1bTmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
-	while (u1bTmp&BIT2)
-	{
+	u1bTmp = rtw_read8(adapter, REG_SYS_FUNC_EN+1);
+	while (u1bTmp & BIT2) {
 		Delay--;
 		if (Delay == 0)
 			break;
 		rtw_udelay_os(50);
-		u1bTmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
+		u1bTmp = rtw_read8(adapter, REG_SYS_FUNC_EN+1);
 	}
 
-	if ((u1bTmp&BIT2) && (Delay == 0))
-	{
-		rtw_write8(Adapter, REG_FWIMR, 0x00);
+	if ((u1bTmp&BIT2) && (Delay == 0)) {
+		rtw_write8(adapter, REG_FWIMR, 0x00);
 		/* debug reset fail */
-		printk("FirmwareDownload92C(): Fail!!!!!! 0x1c = %x, 0x130=>%08x, 0x134=>%08x, 0x138=>%08x, 0x1c4=>%08x\n, 0x1cc=>%08x, , 0x80=>%08x , 0x1c0=>%08x\n", rtw_read32(Adapter, 0x1c)
-		, rtw_read32(Adapter, 0x130), rtw_read32(Adapter, 0x134), rtw_read32(Adapter, 0x138), rtw_read32(Adapter, 0x1c4),
-		rtw_read32(Adapter, 0x1cc), rtw_read32(Adapter, 0x80), rtw_read32(Adapter, 0x1c0));
+		pr_info("FirmwareDownload92C(): Fail! 0x1c = %x, 0x130=>%08x, 0x134=>%08x, 0x138=>%08x, 0x1c4=>%08x\n, 0x1cc=>%08x, , 0x80=>%08x , 0x1c0=>%08x\n",
+		        rtw_read32(adapter, 0x1c), rtw_read32(adapter, 0x130),
+			rtw_read32(adapter, 0x134), rtw_read32(adapter, 0x138),
+			rtw_read32(adapter, 0x1c4), rtw_read32(adapter, 0x1cc),
+			rtw_read32(adapter, 0x80), rtw_read32(adapter, 0x1c0));
 	}
 }
 
-/*  */
 /*  description :polling fw ready */
-/*  */
-static int _FWInit(struct rtw_adapter *Adapter)
+static int _FWInit(struct rtw_adapter *adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	u32			counter = 0;
-
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u32 counter = 0;
 
 	DBG_8192D("FW already have download ;\n");
 
 	/*  polling for FW ready */
 	counter = 0;
-	do
-	{
-		if (pHalData->interfaceIndex==0) {
-			if (rtw_read8(Adapter, FW_MAC0_ready) & mac0_ready) {
-				DBG_8192D("Polling FW ready success!! FW_MAC0_ready:0x%x .\n",rtw_read8(Adapter, FW_MAC0_ready));
+	do {
+		if (!pHalData->interfaceIndex) {
+			if (rtw_read8(adapter, FW_MAC0_ready) & mac0_ready) {
+				DBG_8192D("Polling FW ready success!! FW_MAC0_ready:0x%x\n",
+					  rtw_read8(adapter, FW_MAC0_ready));
 				return _SUCCESS;
 			}
 			rtw_udelay_os(5);
-		}
-		else {
-			if (rtw_read8(Adapter, FW_MAC1_ready) &mac1_ready) {
-				DBG_8192D("Polling FW ready success!! FW_MAC1_ready:0x%x .\n",rtw_read8(Adapter, FW_MAC1_ready));
+		} else {
+			if (rtw_read8(adapter, FW_MAC1_ready) &mac1_ready) {
+				DBG_8192D("Polling FW ready success!! FW_MAC1_ready:0x%x\n",
+					  rtw_read8(adapter, FW_MAC1_ready));
 				return _SUCCESS;
 			}
 			rtw_udelay_os(5);
 		}
 
-	}while (counter++ < POLLING_READY_TIMEOUT_COUNT);
+	} while (counter++ < POLLING_READY_TIMEOUT_COUNT);
 
 	if (pHalData->interfaceIndex==0) {
-		DBG_8192D("Polling FW ready fail!! MAC0 FW init not ready:0x%x .\n",rtw_read8(Adapter, FW_MAC0_ready));
-	}
-	else {
-		DBG_8192D("Polling FW ready fail!! MAC1 FW init not ready:0x%x .\n",rtw_read8(Adapter, FW_MAC1_ready));
+		DBG_8192D("Polling FW ready fail!! MAC0 FW init not ready:0x%x\n",
+			  rtw_read8(adapter, FW_MAC0_ready));
+	} else {
+		DBG_8192D("Polling FW ready fail!! MAC1 FW init not ready:0x%x\n",
+			  rtw_read8(adapter, FW_MAC1_ready));
 	}
 
-	DBG_8192D("Polling FW ready fail!! REG_MCUFWDL:0x%x .\n",rtw_read32(Adapter, REG_MCUFWDL));
+	DBG_8192D("Polling FW ready fail!! REG_MCUFWDL:0x%x\n",
+		  rtw_read32(adapter, REG_MCUFWDL));
 	return _FAIL;
 }
 
-#ifdef CONFIG_FILE_FWIMG
-extern char *rtw_fw_file_path;
-u8	FwBuffer8192D[FW_8192D_SIZE];
-#endif /* CONFIG_FILE_FWIMG */
-/*  */
-/* 	Description: */
-/* 		Download 8192C firmware code. */
-/*  */
-/*  */
-int FirmwareDownload92D(
-	struct rtw_adapter *			Adapter,
-	bool			bUsedWoWLANFw
-)
+/* 	Description: Download 8192D firmware code. */
+int FirmwareDownload92D(struct rtw_adapter *adapter, bool bUsedWoWLANFw)
 {
-	int	rtStatus = _SUCCESS;
+	int rtStatus = _SUCCESS;
 	u8 writeFW_retry = 0;
 	u32 fwdl_start_time;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	s8				R92DFwImageFileName[] ={RTL8192D_FW_IMG};
-	u8*				FwImage;
-	u32				FwImageLen;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	s8 R92DFwImageFileName[] ={RTL8192D_FW_IMG};
+	u8 *FwImage;
+	u32 FwImageLen;
 #ifdef CONFIG_WOWLAN
-	u8*			FwImageWoWLAN;
-	u32			FwImageWoWLANLen;
+	u8 *FwImageWoWLAN;
+	u32 FwImageWoWLANLen;
 #endif /* CONFIG_WOWLAN */
 	struct RT_FIRMWARE_92D	*pFirmware = NULL;
 	struct rt_8192d_firmware_hdr *pFwHdr = NULL;
-	u8		*pFirmwareBuf;
-	u32		FirmwareLen;
-	u8		value;
-	u32		count;
-	bool	 bFwDownloaded = false,bFwDownloadInProcess = false;
+	u8 *pFirmwareBuf;
+	u32 FirmwareLen;
+	u8 value;
+	u32 count;
+	bool bFwDownloaded = false, bFwDownloadInProcess = false;
 
-	if (Adapter->bSurpriseRemoved) {
+	if (adapter->bSurpriseRemoved)
 		return _FAIL;
-	}
 
 	pFirmware = (struct RT_FIRMWARE_92D *)rtw_zvmalloc(sizeof(struct RT_FIRMWARE_92D));
 	if (!pFirmware) {
@@ -388,13 +364,6 @@ int FirmwareDownload92D(
 			break;
 	}
 
-	#ifdef DBG_FW_STORE_FILE_PATH /* used to store firmware to file... */
-	if (pFirmware->ulFwLength > 0)
-	{
-		rtw_store_to_file(DBG_FW_STORE_FILE_PATH, pFirmware->szFwBuffer, pFirmware->ulFwLength);
-	}
-	#endif
-
 #ifdef CONFIG_WOWLAN
 	if (bUsedWoWLANFw)	{
 		pFirmwareBuf = pFirmware->szWoWLANFwBuffer;
@@ -427,9 +396,9 @@ int FirmwareDownload92D(
 	if (bUsedWoWLANFw)
 	{
 		u8 test;
-		test = rtw_read8(Adapter, REG_APS_FSMCO+1);
+		test = rtw_read8(adapter, REG_APS_FSMCO+1);
 		test &= ~BIT(3);
-		rtw_write8(Adapter, REG_APS_FSMCO+1, test);
+		rtw_write8(adapter, REG_APS_FSMCO+1, test);
 	}
 
 #endif /* CONFIG_WOWLAN */
@@ -438,8 +407,8 @@ int FirmwareDownload92D(
 		pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 	{
 
-	bFwDownloaded = _IsFWDownloaded(Adapter);
-	if ((rtw_read8(Adapter, 0x1f)&BIT5) == BIT5)
+	bFwDownloaded = _IsFWDownloaded(adapter);
+	if ((rtw_read8(adapter, 0x1f)&BIT5) == BIT5)
 		bFwDownloadInProcess = true;
 	else
 		bFwDownloadInProcess = false;
@@ -457,8 +426,8 @@ int FirmwareDownload92D(
 		{
 			rtw_udelay_os(500);
 			ACQUIRE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
-			bFwDownloaded = _IsFWDownloaded(Adapter);
-			if ((rtw_read8(Adapter, 0x1f)&BIT5) == BIT5)
+			bFwDownloaded = _IsFWDownloaded(adapter);
+			if ((rtw_read8(adapter, 0x1f)&BIT5) == BIT5)
 				bFwDownloadInProcess = true;
 			else
 				bFwDownloadInProcess = false;
@@ -471,35 +440,35 @@ int FirmwareDownload92D(
 				DBG_8192D("Wait for another mac download fw\n");
 		}
 		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
-		value=rtw_read8(Adapter, 0x1f);
+		value=rtw_read8(adapter, 0x1f);
 		value|=BIT5;
-		rtw_write8(Adapter, 0x1f,value);
+		rtw_write8(adapter, 0x1f,value);
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 	}
 	else
 	{
-		value=rtw_read8(Adapter, 0x1f);
+		value=rtw_read8(adapter, 0x1f);
 		value|=BIT5;
-		rtw_write8(Adapter, 0x1f,value);
+		rtw_write8(adapter, 0x1f,value);
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 	}
 
 	/*  Suggested by Filen. If 8051 is running in RAM code, driver should inform Fw to reset by itself, */
 	/*  or it will cause download Fw fail. 2010.02.01. by tynli. */
-	if (rtw_read8(Adapter, REG_MCUFWDL)&BIT7) /* 8051 RAM code */
+	if (rtw_read8(adapter, REG_MCUFWDL)&BIT7) /* 8051 RAM code */
 	{
 		DBG_8192D("Firmware self reset\n");
-		rtl8192d_FirmwareSelfReset(Adapter);
-		rtw_write8(Adapter, REG_MCUFWDL, 0x00);
+		rtl8192d_FirmwareSelfReset(adapter);
+		rtw_write8(adapter, REG_MCUFWDL, 0x00);
 	}
 
-	_FWDownloadEnable(Adapter, true);
+	_FWDownloadEnable(adapter, true);
 	fwdl_start_time = rtw_get_current_time();
 	while (1) {
 		/* reset the FWDL chksum */
-		rtw_write8(Adapter, REG_MCUFWDL, rtw_read8(Adapter, REG_MCUFWDL)|FWDL_ChkSum_rpt);
+		rtw_write8(adapter, REG_MCUFWDL, rtw_read8(adapter, REG_MCUFWDL)|FWDL_ChkSum_rpt);
 
-		rtStatus = _WriteFW(Adapter, pFirmwareBuf, FirmwareLen);
+		rtStatus = _WriteFW(adapter, pFirmwareBuf, FirmwareLen);
 
 		if (rtStatus == _SUCCESS
 			||(rtw_get_passing_time_ms(fwdl_start_time) > 500 && writeFW_retry++ >= 3)
@@ -511,18 +480,18 @@ int FirmwareDownload92D(
 			, rtw_get_passing_time_ms(fwdl_start_time)
 		);
 	}
-	_FWDownloadEnable(Adapter, false);
+	_FWDownloadEnable(adapter, false);
 	if (_SUCCESS != rtStatus) {
 		DBG_8192D("DL Firmware failed!\n");
 		goto Exit;
 	}
 
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
-	rtStatus=_FWFreeToGo_92D(Adapter);
+	rtStatus=_FWFreeToGo_92D(adapter);
 	/*  download fw over,clear 0x1f[5] */
-	value=rtw_read8(Adapter, 0x1f);
+	value=rtw_read8(adapter, 0x1f);
 	value&=(~BIT5);
-	rtw_write8(Adapter, 0x1f,value);
+	rtw_write8(adapter, 0x1f,value);
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 
 	if (_SUCCESS != rtStatus) {
@@ -532,7 +501,7 @@ int FirmwareDownload92D(
 
 Exit:
 
-	rtStatus =_FWInit(Adapter);
+	rtStatus =_FWInit(adapter);
 
 	if (pFirmware) {
 		rtw_vmfree((u8*)pFirmware, sizeof(struct RT_FIRMWARE_92D));
@@ -544,15 +513,15 @@ Exit:
 #ifdef CONFIG_WOWLAN
 void
 InitializeFirmwareVars92D(
-	struct rtw_adapter *		Adapter
+	struct rtw_adapter *		adapter
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct pwrctrl_priv *pwrpriv;
-	pwrpriv = &Adapter->pwrctrlpriv;
+	pwrpriv = &adapter->pwrctrlpriv;
 
 	/*  Init Fw LPS related. */
-	Adapter->pwrctrlpriv.bFwCurrentInPSMode = false;
+	adapter->pwrctrlpriv.bFwCurrentInPSMode = false;
 
 	pwrpriv->bkeepfwalive = true;
 	/* Init H2C counter. by tynli. 2009.12.09. */
@@ -644,14 +613,14 @@ static u8 Hal_GetChnlGroupfromArray(u8 c
 
 void
 rtl8192d_ReadChipVersion(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	)
 {
 	u32	value32;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	enum VERSION_8192D	ChipVersion = VERSION_TEST_CHIP_88C;
 
-	value32 = rtw_read32(Adapter, REG_SYS_CFG);
+	value32 = rtw_read32(adapter, REG_SYS_CFG);
 	DBG_8192D("ReadChipVersion8192D 0xF0 = 0x%x\n", value32);
 
 	ChipVersion = (enum VERSION_8192D)(VERSION_NORMAL_CHIP_92D_SINGLEPHY | CHIP_92D);
@@ -680,20 +649,20 @@ rtl8192d_ReadChipVersion(
 
 void
 rtl8192d_EfuseParseChnlPlan(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8*			hwinfo,
 	bool		AutoLoadFail
 	)
 {
-	Adapter->mlmepriv.ChannelPlan = hal_com_get_channel_plan(
-		Adapter
+	adapter->mlmepriv.ChannelPlan = hal_com_get_channel_plan(
+		adapter
 		, hwinfo?hwinfo[EEPROM_CHANNEL_PLAN]:0xFF
-		, Adapter->registrypriv.channel_plan
+		, adapter->registrypriv.channel_plan
 		, RT_CHANNEL_DOMAIN_WORLD_WIDE_5G
 		, AutoLoadFail
 	);
 
-	DBG_8192D("mlmepriv.ChannelPlan = 0x%02x\n" , Adapter->mlmepriv.ChannelPlan);
+	DBG_8192D("mlmepriv.ChannelPlan = 0x%02x\n" , adapter->mlmepriv.ChannelPlan);
 }
 
 /*  */
@@ -704,7 +673,7 @@ rtl8192d_EfuseParseChnlPlan(
 
 static void
 hal_ReadPowerValueFromPROM92D(
-	struct rtw_adapter *Adapter,
+	struct rtw_adapter *adapter,
 	struct tx_power_info *pwrInfo,
 	u8*			PROMContent,
 	bool			AutoLoadFail
@@ -712,7 +681,7 @@ hal_ReadPowerValueFromPROM92D(
 {
 	u32	rfPath, eeAddr, group, offset1,offset2=0;
 	u8	i = 0;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	memset(pwrInfo, 0, sizeof(struct tx_power_info));
 
@@ -838,18 +807,18 @@ hal_ReadPowerValueFromPROM92D(
 
 void
 rtl8192d_ReadTxPowerInfo(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8*			PROMContent,
 	bool			AutoLoadFail
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct tx_power_info pwrInfo;
 	u32			rfPath, ch, group;
 	u8			pwr, diff,tempval[2], i;
 
-	hal_ReadPowerValueFromPROM92D(Adapter, &pwrInfo, PROMContent, AutoLoadFail);
+	hal_ReadPowerValueFromPROM92D(adapter, &pwrInfo, PROMContent, AutoLoadFail);
 
 	if (!AutoLoadFail)
 	{
@@ -1024,17 +993,17 @@ rtl8192d_ReadTxPowerInfo(
 /* 	Assumption: */
 /*  */
 void rtl8192d_ResetDualMacSwitchVariables(
-		struct rtw_adapter *			Adapter
+		struct rtw_adapter *			adapter
 )
 {
 }
 
-u8 GetEEPROMSize8192D(struct rtw_adapter * Adapter)
+u8 GetEEPROMSize8192D(struct rtw_adapter * adapter)
 {
 	u8	size = 0;
 	u32	curRCR;
 
-	curRCR = rtw_read16(Adapter, REG_9346CR);
+	curRCR = rtw_read16(adapter, REG_9346CR);
 	size = (curRCR & BOOT_FROM_EEPROM) ? 6 : 4; /*  6: EEPROM used is 93C46, 4: boot from E-Fuse. */
 
 	MSG_8192D("EEPROM type is %s\n", size==4 ? "E-FUSE" : "93C46");
@@ -1047,29 +1016,29 @@ Function: Synchrosize for power off with
 *************************************************************/
 bool
 PHY_CheckPowerOffFor8192D(
-	struct rtw_adapter *   Adapter
+	struct rtw_adapter *   adapter
 )
 {
 	u8 u1bTmp;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY) {
-		u1bTmp = rtw_read8(Adapter, REG_MAC0);
-		rtw_write8(Adapter, REG_MAC0, u1bTmp&(~MAC0_ON));
+		u1bTmp = rtw_read8(adapter, REG_MAC0);
+		rtw_write8(adapter, REG_MAC0, u1bTmp&(~MAC0_ON));
 		return true;
 	}
 
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
 	if (pHalData->interfaceIndex == 0) {
-		u1bTmp = rtw_read8(Adapter, REG_MAC0);
-		rtw_write8(Adapter, REG_MAC0, u1bTmp&(~MAC0_ON));
-		u1bTmp = rtw_read8(Adapter, REG_MAC1);
+		u1bTmp = rtw_read8(adapter, REG_MAC0);
+		rtw_write8(adapter, REG_MAC0, u1bTmp&(~MAC0_ON));
+		u1bTmp = rtw_read8(adapter, REG_MAC1);
 		u1bTmp &=MAC1_ON;
 
 	} else {
-		u1bTmp = rtw_read8(Adapter, REG_MAC1);
-		rtw_write8(Adapter, REG_MAC1, u1bTmp&(~MAC1_ON));
-		u1bTmp = rtw_read8(Adapter, REG_MAC0);
+		u1bTmp = rtw_read8(adapter, REG_MAC1);
+		rtw_write8(adapter, REG_MAC1, u1bTmp&(~MAC1_ON));
+		u1bTmp = rtw_read8(adapter, REG_MAC0);
 		u1bTmp &=MAC0_ON;
 	}
 
@@ -1079,9 +1048,9 @@ PHY_CheckPowerOffFor8192D(
 		return false;
 	}
 
-	u1bTmp=rtw_read8(Adapter, REG_POWER_OFF_IN_PROCESS);
+	u1bTmp=rtw_read8(adapter, REG_POWER_OFF_IN_PROCESS);
 	u1bTmp|=BIT7;
-	rtw_write8(Adapter, REG_POWER_OFF_IN_PROCESS, u1bTmp);
+	rtw_write8(adapter, REG_POWER_OFF_IN_PROCESS, u1bTmp);
 
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
 	return true;
@@ -1093,46 +1062,46 @@ Function: Synchrosize for power off/on w
 *************************************************************/
 void
 PHY_SetPowerOnFor8192D(
-	struct rtw_adapter *Adapter
+	struct rtw_adapter *adapter
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	value8;
 	u16	i;
 
 	/*  notice fw know band status  0x81[1]/0x53[1] = 0: 5G, 1: 2G */
 	if (pHalData->CurrentBandType92D==BAND_ON_2_4G)
 	{
-		value8 = rtw_read8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
+		value8 = rtw_read8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
 		value8 |= BIT1;
-		rtw_write8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1),value8);
+		rtw_write8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1),value8);
 	}
 	else
 	{
-		value8 = rtw_read8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
+		value8 = rtw_read8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
 		value8 &= (~BIT1);
-		rtw_write8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1),value8);
+		rtw_write8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1),value8);
 	}
 
 	if (pHalData->MacPhyMode92D ==SINGLEMAC_SINGLEPHY)
 	{
-		value8 = rtw_read8(Adapter, REG_MAC0);
-		rtw_write8(Adapter, REG_MAC0, value8|MAC0_ON);
+		value8 = rtw_read8(adapter, REG_MAC0);
+		rtw_write8(adapter, REG_MAC0, value8|MAC0_ON);
 	}
 	else
 	{
 		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
 		if (pHalData->interfaceIndex == 0)
 		{
-			value8 = rtw_read8(Adapter, REG_MAC0);
-			rtw_write8(Adapter, REG_MAC0, value8|MAC0_ON);
+			value8 = rtw_read8(adapter, REG_MAC0);
+			rtw_write8(adapter, REG_MAC0, value8|MAC0_ON);
 		}
 		else
 		{
-			value8 = rtw_read8(Adapter, REG_MAC1);
-			rtw_write8(Adapter, REG_MAC1, value8|MAC1_ON);
+			value8 = rtw_read8(adapter, REG_MAC1);
+			rtw_write8(adapter, REG_MAC1, value8|MAC1_ON);
 		}
-		value8 = rtw_read8(Adapter, REG_POWER_OFF_IN_PROCESS);
+		value8 = rtw_read8(adapter, REG_POWER_OFF_IN_PROCESS);
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
 
 		for (i=0;i<200;i++)
@@ -1145,7 +1114,7 @@ PHY_SetPowerOnFor8192D(
 			{
 				rtw_udelay_os(500);
 				ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
-				value8 = rtw_read8(Adapter, REG_POWER_OFF_IN_PROCESS);
+				value8 = rtw_read8(adapter, REG_POWER_OFF_IN_PROCESS);
 				RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
 			}
 		}
@@ -1178,7 +1147,7 @@ enum{
 
 static void
 rtl8192d_EfusePowerSwitch(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u8		bWrite,
 	u8		PwrState)
 {
@@ -1188,46 +1157,46 @@ rtl8192d_EfusePowerSwitch(
 	if (PwrState == true)
 	{
 		/*  1.2V Power: From VDDON with Power Cut(0x0000h[15]), defualt valid */
-		tmpV16 = rtw_read16(pAdapter, REG_SYS_ISO_CTRL);
+		tmpV16 = rtw_read16(adapter, REG_SYS_ISO_CTRL);
 		if (!(tmpV16 & PWC_EV12V)) {
 			tmpV16 |= PWC_EV12V ;
-			 rtw_write16(pAdapter, REG_SYS_ISO_CTRL, tmpV16);
+			 rtw_write16(adapter, REG_SYS_ISO_CTRL, tmpV16);
 		}
 		/*  Reset: 0x0000h[28], default valid */
-		tmpV16 = rtw_read16(pAdapter, REG_SYS_FUNC_EN);
+		tmpV16 = rtw_read16(adapter, REG_SYS_FUNC_EN);
 		if (!(tmpV16 & FEN_ELDR)) {
 			tmpV16 |= FEN_ELDR ;
-			rtw_write16(pAdapter,REG_SYS_FUNC_EN,tmpV16);
+			rtw_write16(adapter,REG_SYS_FUNC_EN,tmpV16);
 		}
 
 		/*  Clock: Gated(0x0008h[5]) 8M(0x0008h[1]) clock from ANA, default valid */
-		tmpV16 = rtw_read16(pAdapter, REG_SYS_CLKR);
+		tmpV16 = rtw_read16(adapter, REG_SYS_CLKR);
 		if ((!(tmpV16 & LOADER_CLK_EN)) || (!(tmpV16 & ANA8M))) {
 			tmpV16 |= (LOADER_CLK_EN | ANA8M);
-			rtw_write16(pAdapter, REG_SYS_CLKR, tmpV16);
+			rtw_write16(adapter, REG_SYS_CLKR, tmpV16);
 		}
 
 		if (bWrite == true) {
 			/*  Enable LDO 2.5V before read/write action */
-			tempval = rtw_read8(pAdapter, EFUSE_TEST+3);
+			tempval = rtw_read8(adapter, EFUSE_TEST+3);
 			tempval &= 0x0F;
 			tempval |= (VOLTAGE_V25 << 4);
-			rtw_write8(pAdapter, EFUSE_TEST+3, (tempval | 0x80));
+			rtw_write8(adapter, EFUSE_TEST+3, (tempval | 0x80));
 		}
 	}
 	else
 	{
 		if (bWrite == true) {
 			/*  Disable LDO 2.5V after read/write action */
-			tempval = rtw_read8(pAdapter, EFUSE_TEST+3);
-			rtw_write8(pAdapter, EFUSE_TEST+3, (tempval & 0x7F));
+			tempval = rtw_read8(adapter, EFUSE_TEST+3);
+			rtw_write8(adapter, EFUSE_TEST+3, (tempval & 0x7F));
 		}
 	}
 }
 
 static void
 ReadEFuse_RTL8192D(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8			efuseType,
 	u16			_offset,
 	u16			_size_byte,
@@ -1263,7 +1232,7 @@ ReadEFuse_RTL8192D(
 	/*  1. Read the first byte to check if efuse is empty!!! */
 	/*  */
 	/*  */
-	ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
+	ReadEFuseByte(adapter, eFuse_Addr, rtemp8, bPseudoTest);
 	if (*rtemp8 != 0xFF)
 	{
 		efuse_utilized++;
@@ -1285,12 +1254,12 @@ ReadEFuse_RTL8192D(
 
 			u1temp =((*rtemp8 & 0xE0) >> 5);
 
-			ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
+			ReadEFuseByte(adapter, eFuse_Addr, rtemp8, bPseudoTest);
 
 			if ((*rtemp8 & 0x0F) == 0x0F)
 			{
 				eFuse_Addr++;
-				ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
+				ReadEFuseByte(adapter, eFuse_Addr, rtemp8, bPseudoTest);
 
 				if (*rtemp8 != 0xFF && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN))
 				{
@@ -1320,7 +1289,7 @@ ReadEFuse_RTL8192D(
 				/*  Check word enable condition in the section */
 				if (!(wren & 0x01))
 				{
-					ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
+					ReadEFuseByte(adapter, eFuse_Addr, rtemp8, bPseudoTest);
 					eFuse_Addr++;
 					efuse_utilized++;
 					eFuseWord[offset][i] = (*rtemp8 & 0xff);
@@ -1329,7 +1298,7 @@ ReadEFuse_RTL8192D(
 					if (eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
 						break;
 
-					ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
+					ReadEFuseByte(adapter, eFuse_Addr, rtemp8, bPseudoTest);
 					eFuse_Addr++;
 
 					efuse_utilized++;
@@ -1345,7 +1314,7 @@ ReadEFuse_RTL8192D(
 		}
 
 		/*  Read next PG header */
-		ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
+		ReadEFuseByte(adapter, eFuse_Addr, rtemp8, bPseudoTest);
 
 		if (*rtemp8 != 0xFF && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN))
 		{
@@ -1377,21 +1346,21 @@ ReadEFuse_RTL8192D(
 	/*  */
 	/*  5. Calculate Efuse utilization. */
 	/*  */
-	rtw_hal_set_hwreg(Adapter, HW_VAR_EFUSE_BYTES, (u8*)&efuse_utilized);
+	rtw_hal_set_hwreg(adapter, HW_VAR_EFUSE_BYTES, (u8*)&efuse_utilized);
 }
 
 static void
 hal_EfuseUpdateNormalChipVersion_92D(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	enum VERSION_8192D	ChipVer = pHalData->VersionID;
 	u8	CutValue[2];
 	u16	ChipValue=0;
 
-	ReadEFuseByte(Adapter,EEPROME_CHIP_VERSION_H,&CutValue[1], false);
-	ReadEFuseByte(Adapter,EEPROME_CHIP_VERSION_L,&CutValue[0], false);
+	ReadEFuseByte(adapter,EEPROME_CHIP_VERSION_H,&CutValue[1], false);
+	ReadEFuseByte(adapter,EEPROME_CHIP_VERSION_L,&CutValue[0], false);
 
 	ChipValue= (CutValue[1]<<8)|CutValue[0];
 	switch (ChipValue) {
@@ -1418,16 +1387,16 @@ hal_EfuseUpdateNormalChipVersion_92D(
 
 static bool
 hal_EfuseMacMode_ISVS_92D(
-         struct rtw_adapter *     Adapter
+         struct rtw_adapter *     adapter
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	PartNo;
 	bool bResult = false;
 	/*  92D VS not support dual mac mode */
 	if (IS_NORMAL_CHIP92D(pHalData->VersionID))
 	{
-		ReadEFuseByte(Adapter,EEPROM_DEF_PART_NO,&PartNo, false);
+		ReadEFuseByte(adapter,EEPROM_DEF_PART_NO,&PartNo, false);
 
 		if ((((PartNo & 0xc0) ==  PARTNO_92D_NIC)&&((PartNo & 0x0c) == PARTNO_SINGLE_BAND_VS))||
 			(((PartNo & 0xF0) == PARTNO_92D_NIC_REMARK) &&((PartNo & 0x0F) == PARTNO_SINGLE_BAND_VS_REMARK)))
@@ -1436,7 +1405,7 @@ hal_EfuseMacMode_ISVS_92D(
 		}
 		else if (PartNo == 0x00)
 		{
-			ReadEFuseByte(Adapter,EEPROM_DEF_PART_NO+1,&PartNo, false);
+			ReadEFuseByte(adapter,EEPROM_DEF_PART_NO+1,&PartNo, false);
 			if ((((PartNo & 0xc0) ==  PARTNO_92D_NIC)&&((PartNo & 0x0c) == PARTNO_SINGLE_BAND_VS))||
 				(((PartNo & 0xF0) == PARTNO_92D_NIC_REMARK) &&((PartNo & 0x0F) == PARTNO_SINGLE_BAND_VS_REMARK)))
 			{
@@ -1450,7 +1419,7 @@ hal_EfuseMacMode_ISVS_92D(
 
 static void
 rtl8192d_ReadEFuse(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8			efuseType,
 	u16			_offset,
 	u16			_size_byte,
@@ -1458,17 +1427,17 @@ rtl8192d_ReadEFuse(
 	bool	bPseudoTest
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
-	ReadEFuse_RTL8192D(Adapter, efuseType, _offset, _size_byte, pbuf, bPseudoTest);
+	ReadEFuse_RTL8192D(adapter, efuseType, _offset, _size_byte, pbuf, bPseudoTest);
 
-	hal_EfuseUpdateNormalChipVersion_92D(Adapter);
-	pHalData->bIsVS = hal_EfuseMacMode_ISVS_92D(Adapter);
+	hal_EfuseUpdateNormalChipVersion_92D(adapter);
+	pHalData->bIsVS = hal_EfuseMacMode_ISVS_92D(adapter);
 }
 
 static void
 rtl8192d_EFUSE_GetEfuseDefinition(
-		struct rtw_adapter *	pAdapter,
+		struct rtw_adapter *	adapter,
 		u8		efuseType,
 		u8		type,
 		void *		*pOut,
@@ -1531,7 +1500,7 @@ rtl8192d_EFUSE_GetEfuseDefinition(
 
 static u16
 rtl8192d_EfuseGetCurrentSize(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u8			efuseType,
 	bool		bPseudoTest)
 {
@@ -1542,7 +1511,7 @@ rtl8192d_EfuseGetCurrentSize(
 	u8	efuse_data,word_cnts=0;
 
 	while (	bContinual &&
-			efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) &&
+			efuse_OneByteRead(adapter, efuse_addr ,&efuse_data, bPseudoTest) &&
 			(efuse_addr  < EFUSE_REAL_CONTENT_LEN))
 	{
 		if (efuse_data!=0xFF)
@@ -1551,7 +1520,7 @@ rtl8192d_EfuseGetCurrentSize(
 			{
 				hoffset = efuse_data;
 				efuse_addr++;
-				efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest);
+				efuse_OneByteRead(adapter, efuse_addr ,&efuse_data, bPseudoTest);
 				if ((efuse_data & 0x0F) == 0x0F)
 				{
 					efuse_addr++;
@@ -1582,7 +1551,7 @@ rtl8192d_EfuseGetCurrentSize(
 }
 
 static int
-rtl8192d_Efuse_PgPacketRead(	struct rtw_adapter *	pAdapter,
+rtl8192d_Efuse_PgPacketRead(	struct rtw_adapter *	adapter,
 					u8			offset,
 					u8			*data,
 					bool		bPseudoTest)
@@ -1616,13 +1585,13 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 		/*   Header Read ------------- */
 		if (ReadState & PG_STATE_HEADER)
 		{
-			if (efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest)&&(efuse_data!=0xFF))
+			if (efuse_OneByteRead(adapter, efuse_addr ,&efuse_data, bPseudoTest)&&(efuse_data!=0xFF))
 			{
 				if ((efuse_data & 0x1F) == 0x0F)
 				{
 					tmp_header = efuse_data;
 					efuse_addr++;
-					efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest);
+					efuse_OneByteRead(adapter, efuse_addr ,&efuse_data, bPseudoTest);
 					if ((efuse_data & 0x0F) != 0x0F)
 					{
 						hoffset = ((tmp_header & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);
@@ -1645,7 +1614,7 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 
 				if (hoffset==offset) {
 					for (tmpidx = 0;tmpidx< word_cnts*2 ;tmpidx++) {
-						if (efuse_OneByteRead(pAdapter, efuse_addr+1+tmpidx ,&efuse_data, bPseudoTest)) {
+						if (efuse_OneByteRead(adapter, efuse_addr+1+tmpidx ,&efuse_data, bPseudoTest)) {
 							tmpdata[tmpidx] = efuse_data;
 							if (efuse_data!=0xff) {
 								bDataEmpty = false;
@@ -1687,7 +1656,7 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 }
 
 static int
-rtl8192d_Efuse_PgPacketWrite(struct rtw_adapter *	pAdapter,
+rtl8192d_Efuse_PgPacketWrite(struct rtw_adapter *	adapter,
 					u8			offset,
 					u8			word_en,
 					u8			*data,
@@ -1727,7 +1696,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 	/*  (i.e., offset 0~497, and dummy 1bytes) expected after CP test. */
 	/*  2009.02.19. */
 	/*  */
-	if (Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest) >= (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))
+	if (Efuse_GetCurrentSize(adapter, efuseType, bPseudoTest) >= (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))
 	{
 		return false;
 	}
@@ -1756,14 +1725,14 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 			bDataEmpty=true;
 			badworden = 0x0F;
 			/*   so ******************* */
-			if (	efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) &&
+			if (	efuse_OneByteRead(adapter, efuse_addr ,&efuse_data, bPseudoTest) &&
 				(efuse_data!=0xFF))
 			{
 				if ((efuse_data&0x1F) == 0x0F)		/* extended header */
 				{
 					tmp_header = efuse_data;
 					efuse_addr++;
-					efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest);
+					efuse_OneByteRead(adapter, efuse_addr ,&efuse_data, bPseudoTest);
 					if ((efuse_data & 0x0F) == 0x0F)	/* wren fail */
 					{
 						efuse_addr++;
@@ -1796,7 +1765,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 					/*   so-2 ******************* */
 					for (tmpindex=0 ; tmpindex<(tmp_word_cnts*2) ; tmpindex++)
 					{
-						if (efuse_OneByteRead(pAdapter, (efuse_addr+1+tmpindex) ,&efuse_data, bPseudoTest)&&(efuse_data != 0xFF)) {
+						if (efuse_OneByteRead(adapter, (efuse_addr+1+tmpindex) ,&efuse_data, bPseudoTest)&&(efuse_data != 0xFF)) {
 							bDataEmpty = false;
 						}
 					}
@@ -1832,7 +1801,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 						/*   so-2-2-A ******************* */
 						if ((match_word_en&0x0F)!=0x0F)
 						{
-							badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1, tmp_pkt.word_en ,target_pkt.data, bPseudoTest);
+							badworden = Efuse_WordEnableDataWrite(adapter,efuse_addr+1, tmp_pkt.word_en ,target_pkt.data, bPseudoTest);
 
 							/*   so-2-2-A-1 ******************* */
 							/*  */
@@ -1840,7 +1809,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 							{
 								u8	reorg_offset = offset;
 								u8	reorg_worden=badworden;
-								Efuse_PgPacketWrite(pAdapter, reorg_offset, reorg_worden, target_pkt.data, bPseudoTest);
+								Efuse_PgPacketWrite(adapter, reorg_offset, reorg_worden, target_pkt.data, bPseudoTest);
 							}
 							/*  */
 
@@ -1865,7 +1834,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 							/*   so-2-2-A-2 ******************* */
 							if ((tmp_word_en&0x0F)!=0x0F) {
 								/* reorganize other pg packet */
-								efuse_addr = Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest);
+								efuse_addr = Efuse_GetCurrentSize(adapter, efuseType, bPseudoTest);
 								/*  */
 								target_pkt.offset = offset;
 								target_pkt.word_en= tmp_word_en;
@@ -1904,8 +1873,8 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 				{
 					pg_header = ((target_pkt.offset &0x07) << 5) | 0x0F;
 
-					efuse_OneByteWrite(pAdapter,efuse_addr, pg_header, bPseudoTest);
-					efuse_OneByteRead(pAdapter,efuse_addr, &tmp_header, bPseudoTest);
+					efuse_OneByteWrite(adapter,efuse_addr, pg_header, bPseudoTest);
+					efuse_OneByteRead(adapter,efuse_addr, &tmp_header, bPseudoTest);
 
 					while (tmp_header == 0xFF)
 					{
@@ -1917,8 +1886,8 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 							efuse_addr++;
 							break;
 						}
-						efuse_OneByteWrite(pAdapter,efuse_addr, pg_header, bPseudoTest);
-						efuse_OneByteRead(pAdapter,efuse_addr, &tmp_header, bPseudoTest);
+						efuse_OneByteWrite(adapter,efuse_addr, pg_header, bPseudoTest);
+						efuse_OneByteRead(adapter,efuse_addr, &tmp_header, bPseudoTest);
 					}
 
 					if (!bContinual)
@@ -1930,8 +1899,8 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 						pg_header_temp = pg_header;
 						pg_header = ((target_pkt.offset & 0x78) << 1) | target_pkt.word_en;
 
-						efuse_OneByteWrite(pAdapter,efuse_addr, pg_header, bPseudoTest);
-						efuse_OneByteRead(pAdapter,efuse_addr, &tmp_header, bPseudoTest);
+						efuse_OneByteWrite(adapter,efuse_addr, pg_header, bPseudoTest);
+						efuse_OneByteRead(adapter,efuse_addr, &tmp_header, bPseudoTest);
 
 						while (tmp_header == 0xFF)
 						{
@@ -1942,8 +1911,8 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 								bResult = false;
 								break;
 							}
-							efuse_OneByteWrite(pAdapter,efuse_addr, pg_header, bPseudoTest);
-							efuse_OneByteRead(pAdapter,efuse_addr, &tmp_header, bPseudoTest);
+							efuse_OneByteWrite(adapter,efuse_addr, pg_header, bPseudoTest);
+							efuse_OneByteRead(adapter,efuse_addr, &tmp_header, bPseudoTest);
 						}
 
 						if (!bContinual)
@@ -1981,8 +1950,8 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 				else
 				{
 					pg_header = ((target_pkt.offset << 4)&0xf0) |target_pkt.word_en;
-					efuse_OneByteWrite(pAdapter,efuse_addr, pg_header, bPseudoTest);
-					efuse_OneByteRead(pAdapter,efuse_addr, &tmp_header, bPseudoTest);
+					efuse_OneByteWrite(adapter,efuse_addr, pg_header, bPseudoTest);
+					efuse_OneByteRead(adapter,efuse_addr, &tmp_header, bPseudoTest);
 				}
 
 				if (tmp_header == pg_header)
@@ -2012,16 +1981,16 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 					/*   s1-2-A :cover the exist data ******************* */
 					memset((void *)originaldata, 0xff, sizeof(u8)*8);
 
-					if (Efuse_PgPacketRead(pAdapter, tmp_pkt.offset,originaldata, bPseudoTest))
+					if (Efuse_PgPacketRead(adapter, tmp_pkt.offset,originaldata, bPseudoTest))
 					{	/* check if data exist */
-						badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,tmp_pkt.word_en,originaldata, bPseudoTest);
+						badworden = Efuse_WordEnableDataWrite(adapter,efuse_addr+1,tmp_pkt.word_en,originaldata, bPseudoTest);
 						/*  */
 						if (0x0F != (badworden&0x0F))
 						{
 							u8	reorg_offset = tmp_pkt.offset;
 							u8	reorg_worden=badworden;
-							Efuse_PgPacketWrite(pAdapter,reorg_offset,reorg_worden,originaldata, bPseudoTest);
-							efuse_addr = Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest);
+							Efuse_PgPacketWrite(adapter,reorg_offset,reorg_worden,originaldata, bPseudoTest);
+							efuse_addr = Efuse_GetCurrentSize(adapter, efuseType, bPseudoTest);
 						}
 						/*  */
 						else {
@@ -2051,7 +2020,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 		else if (WriteState==PG_STATE_DATA)
 		{	/*   s1-1  ******************* */
 			badworden = 0x0f;
-			badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,target_pkt.word_en,target_pkt.data , bPseudoTest);
+			badworden = Efuse_WordEnableDataWrite(adapter,efuse_addr+1,target_pkt.word_en,target_pkt.data , bPseudoTest);
 			if ((badworden&0x0F)==0x0F)
 			{ /*   s1-1-A ******************* */
 				bContinual = false;
@@ -2080,7 +2049,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 }
 
 static u8
-rtl8192d_Efuse_WordEnableDataWrite(	struct rtw_adapter *	pAdapter,
+rtl8192d_Efuse_WordEnableDataWrite(	struct rtw_adapter *	adapter,
 							u16		efuse_addr,
 							u8		word_en,
 							u8		*data,
@@ -2095,11 +2064,11 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 	if (!(word_en&BIT0))
 	{
 		tmpaddr = start_addr;
-		efuse_OneByteWrite(pAdapter,start_addr++, data[0], bPseudoTest);
-		efuse_OneByteWrite(pAdapter,start_addr++, data[1], bPseudoTest);
+		efuse_OneByteWrite(adapter,start_addr++, data[0], bPseudoTest);
+		efuse_OneByteWrite(adapter,start_addr++, data[1], bPseudoTest);
 
-		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[0], bPseudoTest);
-		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[1], bPseudoTest);
+		efuse_OneByteRead(adapter,tmpaddr, &tmpdata[0], bPseudoTest);
+		efuse_OneByteRead(adapter,tmpaddr+1, &tmpdata[1], bPseudoTest);
 		if ((data[0]!=tmpdata[0])||(data[1]!=tmpdata[1])) {
 			badworden &= (~BIT0);
 		}
@@ -2107,11 +2076,11 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 	if (!(word_en&BIT1))
 	{
 		tmpaddr = start_addr;
-		efuse_OneByteWrite(pAdapter,start_addr++, data[2], bPseudoTest);
-		efuse_OneByteWrite(pAdapter,start_addr++, data[3], bPseudoTest);
+		efuse_OneByteWrite(adapter,start_addr++, data[2], bPseudoTest);
+		efuse_OneByteWrite(adapter,start_addr++, data[3], bPseudoTest);
 
-		efuse_OneByteRead(pAdapter,tmpaddr    , &tmpdata[2], bPseudoTest);
-		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[3], bPseudoTest);
+		efuse_OneByteRead(adapter,tmpaddr    , &tmpdata[2], bPseudoTest);
+		efuse_OneByteRead(adapter,tmpaddr+1, &tmpdata[3], bPseudoTest);
 		if ((data[2]!=tmpdata[2])||(data[3]!=tmpdata[3])) {
 			badworden &=(~BIT1);
 		}
@@ -2119,11 +2088,11 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 	if (!(word_en&BIT2))
 	{
 		tmpaddr = start_addr;
-		efuse_OneByteWrite(pAdapter,start_addr++, data[4], bPseudoTest);
-		efuse_OneByteWrite(pAdapter,start_addr++, data[5], bPseudoTest);
+		efuse_OneByteWrite(adapter,start_addr++, data[4], bPseudoTest);
+		efuse_OneByteWrite(adapter,start_addr++, data[5], bPseudoTest);
 
-		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[4], bPseudoTest);
-		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[5], bPseudoTest);
+		efuse_OneByteRead(adapter,tmpaddr, &tmpdata[4], bPseudoTest);
+		efuse_OneByteRead(adapter,tmpaddr+1, &tmpdata[5], bPseudoTest);
 		if ((data[4]!=tmpdata[4])||(data[5]!=tmpdata[5])) {
 			badworden &=(~BIT2);
 		}
@@ -2131,11 +2100,11 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 	if (!(word_en&BIT3))
 	{
 		tmpaddr = start_addr;
-		efuse_OneByteWrite(pAdapter,start_addr++, data[6], bPseudoTest);
-		efuse_OneByteWrite(pAdapter,start_addr++, data[7], bPseudoTest);
+		efuse_OneByteWrite(adapter,start_addr++, data[6], bPseudoTest);
+		efuse_OneByteWrite(adapter,start_addr++, data[7], bPseudoTest);
 
-		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[6], bPseudoTest);
-		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[7], bPseudoTest);
+		efuse_OneByteRead(adapter,tmpaddr, &tmpdata[6], bPseudoTest);
+		efuse_OneByteRead(adapter,tmpaddr+1, &tmpdata[7], bPseudoTest);
 		if ((data[6]!=tmpdata[6])||(data[7]!=tmpdata[7])) {
 			badworden &=(~BIT3);
 		}
--- a/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
@@ -77,7 +77,7 @@ extern atomic_t GlobalCounterForMutex;
 /*---------------------Define local function prototype-----------------------*/
 static void
 phy_PathAFillIQKMatrix(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool	bIQKOK,
 	int		result[][8],
 	u8		final_candidate,
@@ -86,7 +86,7 @@ phy_PathAFillIQKMatrix(
 
 static void
 phy_PathAFillIQKMatrix_5G_Normal(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool	bIQKOK,
 	int		result[][8],
 	u8		final_candidate,
@@ -95,7 +95,7 @@ phy_PathAFillIQKMatrix_5G_Normal(
 
 static void
 phy_PathBFillIQKMatrix(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool	bIQKOK,
 	int		result[][8],
 	u8		final_candidate,
@@ -104,7 +104,7 @@ phy_PathBFillIQKMatrix(
 
 static void
 phy_PathBFillIQKMatrix_5G_Normal(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool	bIQKOK,
 	int		result[][8],
 	u8		final_candidate,
@@ -195,7 +195,7 @@ phy_CalculateBitShift(
 /*  */
 void
 rtl8192d_PHY_SetBBReg1Byte(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u32		RegAddr,
 	u32		BitMask,
 	u32		Data
@@ -211,12 +211,12 @@ rtl8192d_PHY_SetBBReg1Byte(
 	BitShift = phy_CalculateBitShift(BitMask);
 	offset = BitShift /8;
 
-	OriginalValue = rtw_read32(Adapter, RegAddr);
+	OriginalValue = rtw_read32(adapter, RegAddr);
 	Data = ((OriginalValue & (~BitMask)) | ((Data << BitShift) & BitMask));
 
 	value =(u8)(Data>>(8*offset));
 
-	rtw_write8(Adapter, RegAddr+offset, value);
+	rtw_write8(adapter, RegAddr+offset, value);
 }
 
 /**
@@ -225,7 +225,7 @@ rtl8192d_PHY_SetBBReg1Byte(
 * OverView:	Read "sepcific bits" from BB register
 *
 * Input:
-*			struct rtw_adapter *		Adapter,
+*			struct rtw_adapter *		adapter,
 *			u4Byte			RegAddr,	The target address to be readback
 *			u4Byte			BitMask		The target bit position in the target address
 *								to be readback
@@ -235,7 +235,7 @@ rtl8192d_PHY_SetBBReg1Byte(
 */
 u32
 rtl8192d_PHY_QueryBBReg(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u32		RegAddr,
 	u32		BitMask
 	)
@@ -246,7 +246,7 @@ rtl8192d_PHY_QueryBBReg(
 	return 0;
 #endif
 
-	OriginalValue = rtw_read32(Adapter, RegAddr);
+	OriginalValue = rtw_read32(adapter, RegAddr);
 	BitShift = phy_CalculateBitShift(BitMask);
 	ReturnValue = (OriginalValue & BitMask) >> BitShift;
 	return (ReturnValue);
@@ -258,7 +258,7 @@ rtl8192d_PHY_QueryBBReg(
 * OverView:	Write "Specific bits" to BB register (page 8~)
 *
 * Input:
-*			struct rtw_adapter *		Adapter,
+*			struct rtw_adapter *		adapter,
 *			u4Byte			RegAddr,	The target address to be modified
 *			u4Byte			BitMask		The target bit position in the target address
 *								to be modified
@@ -272,7 +272,7 @@ rtl8192d_PHY_QueryBBReg(
 
 void
 rtl8192d_PHY_SetBBReg(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u32		RegAddr,
 	u32		BitMask,
 	u32		Data
@@ -286,12 +286,12 @@ rtl8192d_PHY_SetBBReg(
 
 	if (BitMask!= bMaskDWord)
 	{/* if not "double word" write */
-		OriginalValue = rtw_read32(Adapter, RegAddr);
+		OriginalValue = rtw_read32(adapter, RegAddr);
 		BitShift = phy_CalculateBitShift(BitMask);
 		Data = ((OriginalValue & (~BitMask)) | ((Data << BitShift) & BitMask));
 	}
 
-	rtw_write32(Adapter, RegAddr, Data);
+	rtw_write32(adapter, RegAddr, Data);
 }
 
 /*  */
@@ -315,7 +315,7 @@ rtl8192d_PHY_SetBBReg(
  *---------------------------------------------------------------------------*/
 static	u32
 phy_FwRFSerialRead(
-	struct rtw_adapter *			Adapter,
+	struct rtw_adapter *			adapter,
 	enum RF_RADIO_PATH_E	eRFPath,
 	u32				Offset	)
 {
@@ -342,7 +342,7 @@ phy_FwRFSerialRead(
  *---------------------------------------------------------------------------*/
 static	void
 phy_FwRFSerialWrite(
-	struct rtw_adapter *			Adapter,
+	struct rtw_adapter *			adapter,
 	enum RF_RADIO_PATH_E	eRFPath,
 	u32				Offset,
 	u32				Data	)
@@ -355,7 +355,7 @@ phy_FwRFSerialWrite(
 * OverView:	Read regster from RF chips
 *
 * Input:
-*			struct rtw_adapter *		Adapter,
+*			struct rtw_adapter *		adapter,
 *			enum RF_RADIO_PATH_E	eRFPath,	Radio path of A/B/C/D
 *			u4Byte			Offset,		The target address to be read
 *
@@ -370,13 +370,13 @@ phy_FwRFSerialWrite(
 */
 static	u32
 phy_RFSerialRead(
-	struct rtw_adapter *			Adapter,
+	struct rtw_adapter *			adapter,
 	enum RF_RADIO_PATH_E	eRFPath,
 	u32				Offset
 	)
 {
 	u32	retValue = 0;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct bb_register_def *pPhyReg = &pHalData->PHYRegDef[eRFPath];
 	u32	NewOffset;
 	u32	tmplong,tmplong2;
@@ -402,34 +402,34 @@ phy_RFSerialRead(
 	/*  For 92S LSSI Read RFLSSIRead */
 	/*  For RF A/B write 0x824/82c(does not work in the future) */
 	/*  We must use 0x824 for RF A and B to execute read trigger */
-	tmplong = PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord);
+	tmplong = PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord);
 	if (eRFPath == RF_PATH_A)
 		tmplong2 = tmplong;
 	else
-		tmplong2 = PHY_QueryBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, bMaskDWord);
+		tmplong2 = PHY_QueryBBReg(adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, bMaskDWord);
 
 	tmplong2 = (tmplong2 & (~bLSSIReadAddress)) | (NewOffset<<23) | bLSSIReadEdge;	/* T65 RF */
 
-	PHY_SetBBReg(Adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord, tmplong&(~bLSSIReadEdge));
+	PHY_SetBBReg(adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord, tmplong&(~bLSSIReadEdge));
 	rtw_udelay_os(10);
 
-	PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, bMaskDWord, tmplong2);
+	PHY_SetBBReg(adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, bMaskDWord, tmplong2);
 	for (i = 0; i < 2; i++)
 		rtw_udelay_os(MAX_STALL_TIME);
-	PHY_SetBBReg(Adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord, tmplong|bLSSIReadEdge);
+	PHY_SetBBReg(adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord, tmplong|bLSSIReadEdge);
 	rtw_udelay_os(10);
 
 	if (eRFPath == RF_PATH_A)
-		RfPiEnable = (u8)PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter1|MaskforPhySet, BIT8);
+		RfPiEnable = (u8)PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter1|MaskforPhySet, BIT8);
 	else if (eRFPath == RF_PATH_B)
-		RfPiEnable = (u8)PHY_QueryBBReg(Adapter, rFPGA0_XB_HSSIParameter1|MaskforPhySet, BIT8);
+		RfPiEnable = (u8)PHY_QueryBBReg(adapter, rFPGA0_XB_HSSIParameter1|MaskforPhySet, BIT8);
 
 	if (RfPiEnable) {
 		/*  Read from BBreg8b8, 12 bits for 8190, 20bits for T65 RF */
-		retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBackPi|MaskforPhySet, bLSSIReadBackData);
+		retValue = PHY_QueryBBReg(adapter, pPhyReg->rfLSSIReadBackPi|MaskforPhySet, bLSSIReadBackData);
 	} else {
 		/* Read from BBreg8a0, 12 bits for 8190, 20 bits for T65 RF */
-		retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBack|MaskforPhySet, bLSSIReadBackData);
+		retValue = PHY_QueryBBReg(adapter, pPhyReg->rfLSSIReadBack|MaskforPhySet, bLSSIReadBackData);
 	}
 
 	return retValue;
@@ -443,7 +443,7 @@ phy_RFSerialRead(
 * OverView:	Write data to RF register (page 8~)
 *
 * Input:
-*			struct rtw_adapter *		Adapter,
+*			struct rtw_adapter *		adapter,
 *			enum RF_RADIO_PATH_E	eRFPath,	Radio path of A/B/C/D
 *			u4Byte			Offset,		The target address to be read
 *			u4Byte			Data		The new register Data in the target bit position
@@ -482,14 +482,14 @@ phy_RFSerialRead(
 */
 static	void
 phy_RFSerialWrite(
-	struct rtw_adapter *			Adapter,
+	struct rtw_adapter *			adapter,
 	enum RF_RADIO_PATH_E	eRFPath,
 	u32				Offset,
 	u32				Data
 	)
 {
 	u32	DataAndAddr = 0;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct bb_register_def *pPhyReg = &pHalData->PHYRegDef[eRFPath];
 	u32	NewOffset,MaskforPhySet=0;
 
@@ -523,7 +523,7 @@ phy_RFSerialWrite(
 	/*  */
 	/*  Write Operation */
 	/*  */
-	PHY_SetBBReg(Adapter, pPhyReg->rf3wireOffset|MaskforPhySet, bMaskDWord, DataAndAddr);
+	PHY_SetBBReg(adapter, pPhyReg->rf3wireOffset|MaskforPhySet, bMaskDWord, DataAndAddr);
 }
 
 
@@ -533,7 +533,7 @@ phy_RFSerialWrite(
 * OverView:	Query "Specific bits" to RF register (page 8~)
 *
 * Input:
-*			struct rtw_adapter *		Adapter,
+*			struct rtw_adapter *		adapter,
 *			enum RF_RADIO_PATH_E	eRFPath,	Radio path of A/B/C/D
 *			u4Byte			RegAddr,	The target address to be read
 *			u4Byte			BitMask		The target bit position in the target address
@@ -545,14 +545,14 @@ phy_RFSerialWrite(
 */
 u32
 rtl8192d_PHY_QueryRFReg(
-	struct rtw_adapter *			Adapter,
+	struct rtw_adapter *			adapter,
 	enum RF_RADIO_PATH_E	eRFPath,
 	u32				RegAddr,
 	u32				BitMask
 	)
 {
 	u32 Original_Value, Readback_Value, BitShift;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 #if (DISABLE_BB_RF == 1)
 	return 0;
@@ -562,9 +562,9 @@ rtl8192d_PHY_QueryRFReg(
 		return 0;
 
 	if (pHalData->bReadRFbyFW)
-		Original_Value = rtw_read32(Adapter,(0x66<<24|eRFPath<<16)|RegAddr); /* 0x66 Just a identifier.by wl */
+		Original_Value = rtw_read32(adapter,(0x66<<24|eRFPath<<16)|RegAddr); /* 0x66 Just a identifier.by wl */
 	else
-		Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
+		Original_Value = phy_RFSerialRead(adapter, eRFPath, RegAddr);
 
 	BitShift =  phy_CalculateBitShift(BitMask);
 	Readback_Value = (Original_Value & BitMask) >> BitShift;
@@ -578,7 +578,7 @@ rtl8192d_PHY_QueryRFReg(
 * OverView:	Write "Specific bits" to RF register (page 8~)
 *
 * Input:
-*			struct rtw_adapter *		Adapter,
+*			struct rtw_adapter *		adapter,
 *			enum RF_RADIO_PATH_E	eRFPath,	Radio path of A/B/C/D
 *			u4Byte			RegAddr,	The target address to be modified
 *			u4Byte			BitMask		The target bit position in the target address
@@ -592,7 +592,7 @@ rtl8192d_PHY_QueryRFReg(
 */
 void
 rtl8192d_PHY_SetRFReg(
-	struct rtw_adapter *			Adapter,
+	struct rtw_adapter *			adapter,
 	enum RF_RADIO_PATH_E	eRFPath,
 	u32				RegAddr,
 	u32				BitMask,
@@ -600,7 +600,7 @@ rtl8192d_PHY_SetRFReg(
 	)
 {
 
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u32			Original_Value, BitShift;
 
 #if (DISABLE_BB_RF == 1)
@@ -616,12 +616,12 @@ rtl8192d_PHY_SetRFReg(
 	/*  RF data is 12 bits only */
 	if (BitMask != bRFRegOffsetMask)
 	{
-		Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
+		Original_Value = phy_RFSerialRead(adapter, eRFPath, RegAddr);
 		BitShift =  phy_CalculateBitShift(BitMask);
 		Data = (((Original_Value) & (~BitMask)) | (Data<< BitShift));
 	}
 
-	phy_RFSerialWrite(Adapter, eRFPath, RegAddr, Data);
+	phy_RFSerialWrite(adapter, eRFPath, RegAddr, Data);
 }
 
 /*  */
@@ -634,7 +634,7 @@ rtl8192d_PHY_SetRFReg(
  * Overview:    This function read BB parameters from general file format, and do register
  *			  Read/Write
  *
- * Input:	struct rtw_adapter *		Adapter
+ * Input:	struct rtw_adapter *		adapter
  *			ps1Byte				pFileName
  *
  * Output:      NONE
@@ -647,11 +647,11 @@ rtl8192d_PHY_SetRFReg(
 #ifndef CONFIG_EMBEDDED_FWIMG
 static	int
 phy_ConfigMACWithParaFile(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8*			pFileName
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	int		rtStatus = _SUCCESS;
 
@@ -664,7 +664,7 @@ phy_ConfigMACWithParaFile(
  * Overview:    This function read BB parameters from Header file we gen, and do register
  *			  Read/Write
  *
- * Input:	struct rtw_adapter *		Adapter
+ * Input:	struct rtw_adapter *		adapter
  *			ps1Byte				pFileName
  *
  * Output:      NONE
@@ -676,13 +676,13 @@ phy_ConfigMACWithParaFile(
  *---------------------------------------------------------------------------*/
 static	int
 phy_ConfigMACWithHeaderFile(
-	struct rtw_adapter *		Adapter
+	struct rtw_adapter *		adapter
 )
 {
 	u32					i = 0;
 	u32					ArrayLength = 0;
 	u32*				ptrArray;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	/* 2008.11.06 Modified by tynli. */
 
@@ -690,7 +690,7 @@ phy_ConfigMACWithHeaderFile(
 	ptrArray = (u32 *)Rtl8192D_MAC_Array;
 
 	for (i = 0 ;i < ArrayLength;i=i+2) { /*  Add by tynli for 2 column */
-		rtw_write8(Adapter, ptrArray[i], (u8)ptrArray[i+1]);
+		rtw_write8(adapter, ptrArray[i], (u8)ptrArray[i+1]);
 	}
 
 	return _SUCCESS;
@@ -712,16 +712,16 @@ phy_ConfigMACWithHeaderFile(
  *  08/12/2008	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-int PHY_MACConfig8192D(struct rtw_adapter *Adapter)
+int PHY_MACConfig8192D(struct rtw_adapter *adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 #ifndef CONFIG_EMBEDDED_FWIMG
 	char		*pszMACRegFile;
 #endif
 	char		sz92DMACRegFile[] = RTL8192D_PHY_MACREG;
 	int		rtStatus = _SUCCESS;
 
-	if (Adapter->bSurpriseRemoved) {
+	if (adapter->bSurpriseRemoved) {
 		rtStatus = _FAIL;
 		return rtStatus;
 	}
@@ -734,21 +734,21 @@ int PHY_MACConfig8192D(struct rtw_adapte
 	/*  Config MAC */
 	/*  */
 #ifdef CONFIG_EMBEDDED_FWIMG
-	rtStatus = phy_ConfigMACWithHeaderFile(Adapter);
+	rtStatus = phy_ConfigMACWithHeaderFile(adapter);
 #else
 
 	/*  Not make sure EEPROM, add later */
-	rtStatus = phy_ConfigMACWithParaFile(Adapter, pszMACRegFile);
+	rtStatus = phy_ConfigMACWithParaFile(adapter, pszMACRegFile);
 #endif
 
 	if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY)
 	{
 		/* improve 2-stream TX EVM by Jenyu */
 		/*  2010.07.13 AMPDU aggregation number 9 */
-		rtw_write8(Adapter, REG_MAX_AGGR_NUM, 0x0B); /* By tynli. 2010.11.18. */
+		rtw_write8(adapter, REG_MAX_AGGR_NUM, 0x0B); /* By tynli. 2010.11.18. */
 	}
 	else
-		rtw_write8(Adapter, REG_MAX_AGGR_NUM, 0x07); /* 92D need to test to decide the num. */
+		rtw_write8(adapter, REG_MAX_AGGR_NUM, 0x07); /* 92D need to test to decide the num. */
 
 	return rtStatus;
 }
@@ -760,7 +760,7 @@ int PHY_MACConfig8192D(struct rtw_adapte
 * OverView:	Initialize Register definition offset for Radio Path A/B/C/D
 *
 * Input:
-*			struct rtw_adapter *		Adapter,
+*			struct rtw_adapter *		adapter,
 *
 * Output:	None
 * Return:		None
@@ -768,10 +768,10 @@ int PHY_MACConfig8192D(struct rtw_adapte
 */
 static	void
 phy_InitBBRFRegisterDefinition(
-	struct rtw_adapter *		Adapter
+	struct rtw_adapter *		adapter
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	/*  RF Interface Sowrtware Control */
 	pHalData->PHYRegDef[RF_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW; /*  16 LSBs if read 32-bit from 0x870 */
@@ -877,7 +877,7 @@ phy_InitBBRFRegisterDefinition(
  * Overview:    This function read BB parameters from general file format, and do register
  *			  Read/Write
  *
- * Input:	struct rtw_adapter *		Adapter
+ * Input:	struct rtw_adapter *		adapter
  *			u1Byte			ConfigType     0 => PHY_CONFIG
  *										 1 =>AGC_TAB
  *
@@ -888,7 +888,7 @@ phy_InitBBRFRegisterDefinition(
  *---------------------------------------------------------------------------*/
 static	int
 phy_ConfigBBWithHeaderFile(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8			ConfigType
 )
 {
@@ -897,7 +897,7 @@ phy_ConfigBBWithHeaderFile(
 	u32*	Rtl819XAGCTAB_Array_Table=NULL;
 	u32*	Rtl819XAGCTAB_5GArray_Table=NULL;
 	u16	PHY_REGArrayLen=0, AGCTAB_ArrayLen=0, AGCTAB_5GArrayLen=0;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
 
@@ -939,7 +939,7 @@ phy_ConfigBBWithHeaderFile(
 				rtw_udelay_os(1);
 			else if (Rtl819XPHY_REGArray_Table[i] == 0xa24)
 				pdmpriv->RegA24 = Rtl819XPHY_REGArray_Table[i+1];
-			PHY_SetBBReg(Adapter, Rtl819XPHY_REGArray_Table[i], bMaskDWord, Rtl819XPHY_REGArray_Table[i+1]);
+			PHY_SetBBReg(adapter, Rtl819XPHY_REGArray_Table[i], bMaskDWord, Rtl819XPHY_REGArray_Table[i+1]);
 
 			/*  Add 1us delay between BB/RF register setting. */
 			rtw_udelay_os(1);
@@ -948,7 +948,7 @@ phy_ConfigBBWithHeaderFile(
 		/* especial for 5G, vivi, 20100528 */
 		if (pHalData->interfaceIndex == 0) {
 			for (i = 0; i < AGCTAB_ArrayLen; i = i+2) {
-				PHY_SetBBReg(Adapter, Rtl819XAGCTAB_Array_Table[i], bMaskDWord, Rtl819XAGCTAB_Array_Table[i+1]);
+				PHY_SetBBReg(adapter, Rtl819XAGCTAB_Array_Table[i], bMaskDWord, Rtl819XAGCTAB_Array_Table[i+1]);
 
 				/*  Add 1us delay between BB/RF register setting. */
 				rtw_udelay_os(1);
@@ -959,7 +959,7 @@ phy_ConfigBBWithHeaderFile(
 			{
 				for (i=0;i<AGCTAB_ArrayLen;i=i+2)
 				{
-					PHY_SetBBReg(Adapter, Rtl819XAGCTAB_Array_Table[i], bMaskDWord, Rtl819XAGCTAB_Array_Table[i+1]);
+					PHY_SetBBReg(adapter, Rtl819XAGCTAB_Array_Table[i], bMaskDWord, Rtl819XAGCTAB_Array_Table[i+1]);
 
 					/*  Add 1us delay between BB/RF register setting. */
 					rtw_udelay_os(1);
@@ -967,7 +967,7 @@ phy_ConfigBBWithHeaderFile(
 			} else {
 				for (i=0;i<AGCTAB_5GArrayLen;i=i+2)
 				{
-					PHY_SetBBReg(Adapter, Rtl819XAGCTAB_5GArray_Table[i], bMaskDWord, Rtl819XAGCTAB_5GArray_Table[i+1]);
+					PHY_SetBBReg(adapter, Rtl819XAGCTAB_5GArray_Table[i], bMaskDWord, Rtl819XAGCTAB_5GArray_Table[i+1]);
 
 					/*  Add 1us delay between BB/RF register setting. */
 					rtw_udelay_os(1);
@@ -985,7 +985,7 @@ phy_ConfigBBWithHeaderFile(
  * Overview:    This function read BB parameters from general file format, and do register
  *			  Read/Write
  *
- * Input:	struct rtw_adapter *		Adapter
+ * Input:	struct rtw_adapter *		adapter
  *			ps1Byte				pFileName
  *
  * Output:      NONE
@@ -998,11 +998,11 @@ phy_ConfigBBWithHeaderFile(
 #ifndef CONFIG_EMBEDDED_FWIMG
 static	int
 phy_ConfigBBWithParaFile(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8*			pFileName
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	int		rtStatus = _SUCCESS;
 
@@ -1012,13 +1012,13 @@ phy_ConfigBBWithParaFile(
 #if MP_DRIVER != 1
 static void
 storePwrIndexDiffRateOffset(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u32		RegAddr,
 	u32		BitMask,
 	u32		Data
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	if (RegAddr == rTxAGC_A_Rate18_06)
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][0] = Data;
@@ -1074,20 +1074,20 @@ storePwrIndexDiffRateOffset(
  *---------------------------------------------------------------------------*/
 static	int
 phy_ConfigBBWithPgHeaderFile(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8			ConfigType)
 {
 	int i;
 	u32*	Rtl819XPHY_REGArray_Table_PG;
 	u16	PHY_REGArrayPGLen;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	PHY_REGArrayPGLen = Rtl8192D_PHY_REG_Array_PGLength;
 	Rtl819XPHY_REGArray_Table_PG = (u32 *)Rtl8192D_PHY_REG_Array_PG;
 
 	if (ConfigType == BaseBand_Config_PHY_REG) {
 		for (i = 0; i < PHY_REGArrayPGLen; i = i+3) {
-			storePwrIndexDiffRateOffset(Adapter, Rtl819XPHY_REGArray_Table_PG[i],
+			storePwrIndexDiffRateOffset(adapter, Rtl819XPHY_REGArray_Table_PG[i],
 				Rtl819XPHY_REGArray_Table_PG[i+1],
 				Rtl819XPHY_REGArray_Table_PG[i+2]);
 		}
@@ -1116,10 +1116,10 @@ phy_ConfigBBWithPgHeaderFile(
 #ifndef CONFIG_EMBEDDED_FWIMG
 static	int
 phy_ConfigBBWithPgParaFile(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8*			pFileName)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	int		rtStatus = _SUCCESS;
 
@@ -1135,7 +1135,7 @@ phy_ConfigBBWithPgParaFile(
  * Overview:    This function read BB parameters from general file format, and do register
  *			  Read/Write
  *
- * Input:	struct rtw_adapter *		Adapter
+ * Input:	struct rtw_adapter *		adapter
  *			ps1Byte				pFileName
  *
  * Output:      NONE
@@ -1147,11 +1147,11 @@ phy_ConfigBBWithPgParaFile(
  *---------------------------------------------------------------------------*/
 static	int
 phy_ConfigBBWithMpParaFile(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	s8			*pFileName
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	int	rtStatus = _SUCCESS;
 
 	return rtStatus;
@@ -1174,7 +1174,7 @@ phy_ConfigBBWithMpParaFile(
  *---------------------------------------------------------------------------*/
 static	int
 phy_ConfigBBWithMpHeaderFile(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u1Byte			ConfigType)
 {
 	int	i;
@@ -1205,7 +1205,7 @@ phy_ConfigBBWithMpHeaderFile(
 				rtw_udelay_os(5);
 			else if (Rtl8192CPHY_REGArray_Table_MP[i] == 0xf9)
 				rtw_udelay_os(1);
-			PHY_SetBBReg(Adapter, Rtl8192CPHY_REGArray_Table_MP[i], bMaskDWord, Rtl8192CPHY_REGArray_Table_MP[i+1]);
+			PHY_SetBBReg(adapter, Rtl8192CPHY_REGArray_Table_MP[i], bMaskDWord, Rtl8192CPHY_REGArray_Table_MP[i+1]);
 
 			/*  Add 1us delay between BB/RF register setting. */
 
@@ -1220,13 +1220,13 @@ phy_ConfigBBWithMpHeaderFile(
 
 static	int
 phy_BB8192D_Config_ParaFile(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
 #if MP_DRIVER != 1
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 #endif
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	int		rtStatus = _SUCCESS;
 	s8		sz92DBBRegFile[] = RTL8192D_PHY_REG;
 	s8		sz92DBBRegPgFile[] = RTL8192D_PHY_REG_PG;
@@ -1261,11 +1261,11 @@ phy_BB8192D_Config_ParaFile(
 	/*  We will seperate as 88C / 92C according to chip version */
 	/*  */
 #ifdef CONFIG_EMBEDDED_FWIMG
-	rtStatus = phy_ConfigBBWithHeaderFile(Adapter, BaseBand_Config_PHY_REG);
+	rtStatus = phy_ConfigBBWithHeaderFile(adapter, BaseBand_Config_PHY_REG);
 #else
 	/*  No matter what kind of CHIP we always read PHY_REG.txt. We must copy different */
 	/*  type of parameter files to phy_reg.txt at first. */
-	rtStatus = phy_ConfigBBWithParaFile(Adapter,pszBBRegFile);
+	rtStatus = phy_ConfigBBWithParaFile(adapter,pszBBRegFile);
 #endif
 
 	if (rtStatus != _SUCCESS)
@@ -1277,11 +1277,11 @@ phy_BB8192D_Config_ParaFile(
 	/*  We will seperate as 88C / 92C according to chip version */
 	/*  */
 #ifdef CONFIG_EMBEDDED_FWIMG
-	rtStatus = phy_ConfigBBWithMpHeaderFile(Adapter, BaseBand_Config_PHY_REG);
+	rtStatus = phy_ConfigBBWithMpHeaderFile(adapter, BaseBand_Config_PHY_REG);
 #else
 	/*  No matter what kind of CHIP we always read PHY_REG.txt. We must copy different */
 	/*  type of parameter files to phy_reg.txt at first. */
-	rtStatus = phy_ConfigBBWithMpParaFile(Adapter,pszBBRegMpFile);
+	rtStatus = phy_ConfigBBWithMpParaFile(adapter,pszBBRegMpFile);
 #endif
 
 	if (rtStatus != _SUCCESS)
@@ -1297,9 +1297,9 @@ phy_BB8192D_Config_ParaFile(
 		pHalData->pwrGroupCnt = 0;
 
 #ifdef CONFIG_EMBEDDED_FWIMG
-		rtStatus = phy_ConfigBBWithPgHeaderFile(Adapter, BaseBand_Config_PHY_REG);
+		rtStatus = phy_ConfigBBWithPgHeaderFile(adapter, BaseBand_Config_PHY_REG);
 #else
-		rtStatus = phy_ConfigBBWithPgParaFile(Adapter, pszBBRegPgFile);
+		rtStatus = phy_ConfigBBWithPgParaFile(adapter, pszBBRegPgFile);
 #endif
 	}
 
@@ -1319,10 +1319,10 @@ phy_BB8192D_Config_ParaFile(
 	else
 #endif
 	{
-		rtStatus = phy_ConfigBBWithHeaderFile(Adapter, BaseBand_Config_AGC_TAB);
+		rtStatus = phy_ConfigBBWithHeaderFile(adapter, BaseBand_Config_AGC_TAB);
 	}
 #else
-	rtStatus = phy_ConfigBBWithParaFile(Adapter, pszAGCTableFile);
+	rtStatus = phy_ConfigBBWithParaFile(adapter, pszAGCTableFile);
 #endif
 
 	if (rtStatus != _SUCCESS)
@@ -1330,7 +1330,7 @@ phy_BB8192D_Config_ParaFile(
 
 	/*  Check if the CCK HighPower is turned ON. */
 	/*  This is used to calculate PWDB. */
-	pHalData->bCckHighPower = (bool)(PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter2, 0x200));
+	pHalData->bCckHighPower = (bool)(PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter2, 0x200));
 
 phy_BB8190_Config_ParaFile_Fail:
 
@@ -1339,89 +1339,89 @@ phy_BB8190_Config_ParaFile_Fail:
 
 int
 PHY_BBConfig8192D(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
 	int	rtStatus = _SUCCESS;
 	/* u8		PathMap = 0, index = 0, rf_num = 0; */
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u32	RegVal;
 	u8	value;
-	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
 
-	if (Adapter->bSurpriseRemoved) {
+	if (adapter->bSurpriseRemoved) {
 		rtStatus = _FAIL;
 		return rtStatus;
 	}
 
-	phy_InitBBRFRegisterDefinition(Adapter);
+	phy_InitBBRFRegisterDefinition(adapter);
 
 	/*  Enable BB and RF */
-	RegVal = rtw_read16(Adapter, REG_SYS_FUNC_EN);
-	rtw_write16(Adapter, REG_SYS_FUNC_EN, RegVal|BIT13|BIT0|BIT1);
+	RegVal = rtw_read16(adapter, REG_SYS_FUNC_EN);
+	rtw_write16(adapter, REG_SYS_FUNC_EN, RegVal|BIT13|BIT0|BIT1);
 
 	/*  20090923 Joseph: Advised by Steven and Jenyu. Power sequence before init RF. */
-	rtw_write8(Adapter, REG_AFE_PLL_CTRL, 0x83);
-	rtw_write8(Adapter, REG_AFE_PLL_CTRL+1, 0xdb);
-	value=rtw_read8(Adapter, REG_RF_CTRL);     /*   0x1f bit7 bit6 represent for mac0/mac1 driver ready */
-	rtw_write8(Adapter, REG_RF_CTRL, value|RF_EN|RF_RSTB|RF_SDMRSTB);
+	rtw_write8(adapter, REG_AFE_PLL_CTRL, 0x83);
+	rtw_write8(adapter, REG_AFE_PLL_CTRL+1, 0xdb);
+	value=rtw_read8(adapter, REG_RF_CTRL);     /*   0x1f bit7 bit6 represent for mac0/mac1 driver ready */
+	rtw_write8(adapter, REG_RF_CTRL, value|RF_EN|RF_RSTB|RF_SDMRSTB);
 
-	rtw_write8(Adapter, REG_SYS_FUNC_EN, FEN_USBA | FEN_USBD | FEN_BB_GLB_RSTn | FEN_BBRSTB);
+	rtw_write8(adapter, REG_SYS_FUNC_EN, FEN_USBA | FEN_USBD | FEN_BB_GLB_RSTn | FEN_BBRSTB);
 	/* undo clock gated */
-	rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
+	rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
 	/* To Fix MAC loopback mode fail. Suggested by SD4 Johnny. 2010.03.23. */
-	rtw_write8(Adapter, REG_LDOHCI12_CTRL, 0x0f);
-	rtw_write8(Adapter, 0x15, 0xe9);
+	rtw_write8(adapter, REG_LDOHCI12_CTRL, 0x0f);
+	rtw_write8(adapter, 0x15, 0xe9);
 
-	rtw_write8(Adapter, REG_AFE_XTAL_CTRL+1, 0x80);
+	rtw_write8(adapter, REG_AFE_XTAL_CTRL+1, 0x80);
 
 	/*  */
 	/*  Config BB and AGC */
 	/*  */
-	rtStatus = phy_BB8192D_Config_ParaFile(Adapter);
+	rtStatus = phy_BB8192D_Config_ParaFile(adapter);
 
 	/* Crystal Calibration */
-	PHY_SetBBReg(Adapter, 0x24, 0xF0, pHalData->CrystalCap & 0x0F);
-	PHY_SetBBReg(Adapter, 0x28, 0xF0000000, ((pHalData->CrystalCap & 0xF0) >> 4));
+	PHY_SetBBReg(adapter, 0x24, 0xF0, pHalData->CrystalCap & 0x0F);
+	PHY_SetBBReg(adapter, 0x28, 0xF0000000, ((pHalData->CrystalCap & 0xF0) >> 4));
 
 	/* to save power for special 1T1R */
 	if (pregistrypriv->special_rf_path == 1)
 	{
-		PHY_SetBBReg(Adapter, rFPGA0_XCD_SwitchControl, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rBlue_Tooth, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rRx_Wait_CCA, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rTx_CCK_RFON, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rTx_CCK_BBON, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rTx_OFDM_RFON, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rTx_OFDM_BBON, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rTx_To_Rx, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rTx_To_Tx, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rRx_CCK, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rRx_OFDM, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rRx_Wait_RIFS, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rRx_TO_Rx, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rStandby, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rSleep, BIT24|BIT25|BIT27|BIT30, 0);
-		PHY_SetBBReg(Adapter, rPMPD_ANAEN, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rFPGA0_XCD_SwitchControl, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rBlue_Tooth, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rRx_Wait_CCA, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_CCK_RFON, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_CCK_BBON, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_OFDM_RFON, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_OFDM_BBON, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_To_Rx, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_To_Tx, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rRx_CCK, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rRx_OFDM, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rRx_Wait_RIFS, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rRx_TO_Rx, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rStandby, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rSleep, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rPMPD_ANAEN, BIT24|BIT25|BIT27|BIT30, 0);
 	}
 	else if (pregistrypriv->special_rf_path == 2)
 	{
-		PHY_SetBBReg(Adapter, rFPGA0_XCD_SwitchControl, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rBlue_Tooth, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rRx_Wait_CCA, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rTx_CCK_RFON, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rTx_CCK_BBON, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rTx_OFDM_RFON, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rTx_OFDM_BBON, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rTx_To_Rx, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rTx_To_Tx, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rRx_CCK, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rRx_OFDM, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rRx_Wait_RIFS, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rRx_TO_Rx, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rStandby, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rSleep, BIT22|BIT23|BIT26|BIT29, 0);
-		PHY_SetBBReg(Adapter, rPMPD_ANAEN, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rFPGA0_XCD_SwitchControl, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rBlue_Tooth, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rRx_Wait_CCA, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rTx_CCK_RFON, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rTx_CCK_BBON, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rTx_OFDM_RFON, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rTx_OFDM_BBON, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rTx_To_Rx, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rTx_To_Tx, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rRx_CCK, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rRx_OFDM, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rRx_Wait_RIFS, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rRx_TO_Rx, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rStandby, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rSleep, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rPMPD_ANAEN, BIT22|BIT23|BIT26|BIT29, 0);
 	}
 
 	return rtStatus;
@@ -1430,12 +1430,12 @@ PHY_BBConfig8192D(
 
 int
 PHY_RFConfig8192D(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
 	int		rtStatus = _SUCCESS;
 
-	if (Adapter->bSurpriseRemoved) {
+	if (adapter->bSurpriseRemoved) {
 		rtStatus = _FAIL;
 		return rtStatus;
 	}
@@ -1443,7 +1443,7 @@ PHY_RFConfig8192D(
 	/*  */
 	/*  RF config */
 	/*  */
-	rtStatus = PHY_RF6052_Config8192D(Adapter);
+	rtStatus = PHY_RF6052_Config8192D(adapter);
 	return rtStatus;
 }
 
@@ -1453,7 +1453,7 @@ PHY_RFConfig8192D(
  *
  * Overview:    This function read RF parameters from general file format, and do RF 3-wire
  *
- * Input:	struct rtw_adapter *			Adapter
+ * Input:	struct rtw_adapter *			adapter
  *			ps1Byte					pFileName
  *			enum RF_RADIO_PATH_E	eRFPath
  *
@@ -1465,7 +1465,7 @@ PHY_RFConfig8192D(
  *---------------------------------------------------------------------------*/
 int
 rtl8192d_PHY_ConfigRFWithParaFile(
-	struct rtw_adapter *			Adapter,
+	struct rtw_adapter *			adapter,
 	u8*				pFileName,
 	enum RF_RADIO_PATH_E		eRFPath
 )
@@ -1482,7 +1482,7 @@ rtl8192d_PHY_ConfigRFWithParaFile(
  *
  * Overview:    This function read RF parameters from general file format, and do RF 3-wire
  *
- * Input:	struct rtw_adapter *			Adapter
+ * Input:	struct rtw_adapter *			adapter
  *			ps1Byte					pFileName
  *			enum RF_RADIO_PATH_E	eRFPath
  *
@@ -1494,7 +1494,7 @@ rtl8192d_PHY_ConfigRFWithParaFile(
  *---------------------------------------------------------------------------*/
 int
 rtl8192d_PHY_ConfigRFWithHeaderFile(
-	struct rtw_adapter *			Adapter,
+	struct rtw_adapter *			adapter,
 	enum RF_CONTENT			Content,
 	enum RF_RADIO_PATH_E		eRFPath
 )
@@ -1504,7 +1504,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 	u32*	Rtl819XRadioA_Array_Table;
 	u32*	Rtl819XRadioB_Array_Table;
 	u16		RadioA_ArrayLen,RadioB_ArrayLen;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u32	MaskforPhySet= (u32)(Content&0xE000);
 
 	Content &= 0x1FFF;
@@ -1574,7 +1574,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 				}
 				else
 				{
-					PHY_SetRFReg(Adapter, eRFPath, Rtl819XRadioA_Array_Table[i]|MaskforPhySet, bRFRegOffsetMask, Rtl819XRadioA_Array_Table[i+1]);
+					PHY_SetRFReg(adapter, eRFPath, Rtl819XRadioA_Array_Table[i]|MaskforPhySet, bRFRegOffsetMask, Rtl819XRadioA_Array_Table[i+1]);
 					/*  Add 1us delay between BB/RF register setting. */
 					rtw_udelay_os(1);
 				}
@@ -1617,7 +1617,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 				}
 				else
 				{
-					PHY_SetRFReg(Adapter, eRFPath, Rtl819XRadioB_Array_Table[i]|MaskforPhySet, bRFRegOffsetMask, Rtl819XRadioB_Array_Table[i+1]);
+					PHY_SetRFReg(adapter, eRFPath, Rtl819XRadioB_Array_Table[i]|MaskforPhySet, bRFRegOffsetMask, Rtl819XRadioB_Array_Table[i+1]);
 					/*  Add 1us delay between BB/RF register setting. */
 					rtw_udelay_os(1);
 				}
@@ -1639,7 +1639,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
  * Overview:    This function is write register and then readback to make sure whether
  *			  BB[PHY0, PHY1], RF[Patha, path b, path c, path d] is Ok
  *
- * Input:	struct rtw_adapter *			Adapter
+ * Input:	struct rtw_adapter *			adapter
  *			enum HW90_BLOCK		CheckBlock
  *			enum RF_RADIO_PATH_E	eRFPath		it is used only when CheckBlock is HW90_BLOCK_RF
  *
@@ -1651,7 +1651,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
  *---------------------------------------------------------------------------*/
 int
 rtl8192d_PHY_CheckBBAndRFOK(
-	struct rtw_adapter *			Adapter,
+	struct rtw_adapter *			adapter,
 	enum HW90_BLOCK		CheckBlock,
 	enum RF_RADIO_PATH_E	eRFPath
 	)
@@ -1682,8 +1682,8 @@ rtl8192d_PHY_CheckBBAndRFOK(
 
 		case HW90_BLOCK_PHY0:
 		case HW90_BLOCK_PHY1:
-			rtw_write32(Adapter, WriteAddr[CheckBlock], WriteData[i]);
-			ulRegRead = rtw_read32(Adapter, WriteAddr[CheckBlock]);
+			rtw_write32(adapter, WriteAddr[CheckBlock], WriteData[i]);
+			ulRegRead = rtw_read32(adapter, WriteAddr[CheckBlock]);
 			break;
 
 		case HW90_BLOCK_RF:
@@ -1691,14 +1691,14 @@ rtl8192d_PHY_CheckBBAndRFOK(
 			/*  ==> actually we call PlatformStallExecution()) to do NdisStallExecution() */
 			/*  [busy wait] instead of NdisMSleep(). So we acquire RT_INITIAL_SPINLOCK */
 			/*  to run at Dispatch level to achive it. */
-			/* cosa PlatformAcquireSpinLock(Adapter, RT_INITIAL_SPINLOCK); */
+			/* cosa PlatformAcquireSpinLock(adapter, RT_INITIAL_SPINLOCK); */
 			WriteData[i] &= 0xfff;
-			PHY_SetRFReg(Adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bRFRegOffsetMask, WriteData[i]);
+			PHY_SetRFReg(adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bRFRegOffsetMask, WriteData[i]);
 			/*  TODO: we should not delay for such a long time. Ask SD3 */
 			rtw_mdelay_os(10);
-			ulRegRead = PHY_QueryRFReg(Adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bRFRegOffsetMask);
+			ulRegRead = PHY_QueryRFReg(adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bRFRegOffsetMask);
 			rtw_mdelay_os(10);
-			/* cosa PlatformReleaseSpinLock(Adapter, RT_INITIAL_SPINLOCK); */
+			/* cosa PlatformReleaseSpinLock(adapter, RT_INITIAL_SPINLOCK); */
 			break;
 
 		default:
@@ -1723,20 +1723,20 @@ rtl8192d_PHY_CheckBBAndRFOK(
 
 void
 rtl8192d_PHY_GetHWRegOriginalValue(
-	struct rtw_adapter *		Adapter
+	struct rtw_adapter *		adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	/*  read rx initial gain */
-	pHalData->DefaultInitialGain[0] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XAAGCCore1, bMaskByte0);
-	pHalData->DefaultInitialGain[1] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XBAGCCore1, bMaskByte0);
-	pHalData->DefaultInitialGain[2] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XCAGCCore1, bMaskByte0);
-	pHalData->DefaultInitialGain[3] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XDAGCCore1, bMaskByte0);
+	pHalData->DefaultInitialGain[0] = (u8)PHY_QueryBBReg(adapter, rOFDM0_XAAGCCore1, bMaskByte0);
+	pHalData->DefaultInitialGain[1] = (u8)PHY_QueryBBReg(adapter, rOFDM0_XBAGCCore1, bMaskByte0);
+	pHalData->DefaultInitialGain[2] = (u8)PHY_QueryBBReg(adapter, rOFDM0_XCAGCCore1, bMaskByte0);
+	pHalData->DefaultInitialGain[3] = (u8)PHY_QueryBBReg(adapter, rOFDM0_XDAGCCore1, bMaskByte0);
 
 	/*  read framesync */
-	pHalData->framesync = (u8)PHY_QueryBBReg(Adapter, rOFDM0_RxDetector3, bMaskByte0);
-	pHalData->framesyncC34 = PHY_QueryBBReg(Adapter, rOFDM0_RxDetector2, bMaskDWord);
+	pHalData->framesync = (u8)PHY_QueryBBReg(adapter, rOFDM0_RxDetector3, bMaskByte0);
+	pHalData->framesyncC34 = PHY_QueryBBReg(adapter, rOFDM0_RxDetector2, bMaskDWord);
 }
 
 
@@ -1749,7 +1749,7 @@ rtl8192d_PHY_GetHWRegOriginalValue(
 /*  */
 static	u8
 phy_DbmToTxPwrIdx(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	enum WIRELESS_MODE	WirelessMode,
 	int			PowerInDbm
 	)
@@ -1806,7 +1806,7 @@ phy_DbmToTxPwrIdx(
 /*  */
 static int
 phy_TxPwrIdxToDbm(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	enum WIRELESS_MODE	WirelessMode,
 	u8			TxPwrIdx
 	)
@@ -1846,7 +1846,7 @@ phy_TxPwrIdxToDbm(
  *
  * Overview:    This function is export to "common" moudule
  *
- * Input:       struct rtw_adapter *		Adapter
+ * Input:       struct rtw_adapter *		adapter
  *			psByte			Power Level
  *
  * Output:      NONE
@@ -1856,11 +1856,11 @@ phy_TxPwrIdxToDbm(
  *---------------------------------------------------------------------------*/
 void
 PHY_GetTxPowerLevel8192D(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u32*		powerlevel
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8			TxPwrLevel = 0;
 	int			TxPwrDbm;
 
@@ -1871,34 +1871,34 @@ PHY_GetTxPowerLevel8192D(
 
 	/*  CCK */
 	TxPwrLevel = pHalData->CurrentCckTxPwrIdx;
-	TxPwrDbm = phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_B, TxPwrLevel);
+	TxPwrDbm = phy_TxPwrIdxToDbm(adapter, WIRELESS_MODE_B, TxPwrLevel);
 
 	/*  Legacy OFDM */
 	TxPwrLevel = pHalData->CurrentOfdm24GTxPwrIdx + pHalData->LegacyHTTxPowerDiff;
 
 	/*  Compare with Legacy OFDM Tx power. */
-	if (phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_G, TxPwrLevel) > TxPwrDbm)
-		TxPwrDbm = phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_G, TxPwrLevel);
+	if (phy_TxPwrIdxToDbm(adapter, WIRELESS_MODE_G, TxPwrLevel) > TxPwrDbm)
+		TxPwrDbm = phy_TxPwrIdxToDbm(adapter, WIRELESS_MODE_G, TxPwrLevel);
 
 	/*  HT OFDM */
 	TxPwrLevel = pHalData->CurrentOfdm24GTxPwrIdx;
 
 	/*  Compare with HT OFDM Tx power. */
-	if (phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_N_24G, TxPwrLevel) > TxPwrDbm)
-		TxPwrDbm = phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_N_24G, TxPwrLevel);
+	if (phy_TxPwrIdxToDbm(adapter, WIRELESS_MODE_N_24G, TxPwrLevel) > TxPwrDbm)
+		TxPwrDbm = phy_TxPwrIdxToDbm(adapter, WIRELESS_MODE_N_24G, TxPwrLevel);
 
 	*powerlevel = TxPwrDbm;
 }
 
 
 static void getTxPowerIndex(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8			channel,
 	u8*		cckPowerLevel,
 	u8*		ofdmPowerLevel
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	index = (channel -1);
 
 	/*  1. CCK */
@@ -1911,13 +1911,13 @@ static void getTxPowerIndex(
 		cckPowerLevel[RF_PATH_A] = cckPowerLevel[RF_PATH_B] = 0;
 
 	/*  2. OFDM for 1S or 2S */
-	if (GET_RF_TYPE(Adapter) == RF_1T2R || GET_RF_TYPE(Adapter) == RF_1T1R)
+	if (GET_RF_TYPE(adapter) == RF_1T2R || GET_RF_TYPE(adapter) == RF_1T1R)
 	{
 		/*  Read HT 40 OFDM TX power */
 		ofdmPowerLevel[RF_PATH_A] = pHalData->TxPwrLevelHT40_1S[RF_PATH_A][index];
 		ofdmPowerLevel[RF_PATH_B] = pHalData->TxPwrLevelHT40_1S[RF_PATH_B][index];
 	}
-	else if (GET_RF_TYPE(Adapter) == RF_2T2R)
+	else if (GET_RF_TYPE(adapter) == RF_2T2R)
 	{
 		/*  Read HT 40 OFDM TX power */
 		ofdmPowerLevel[RF_PATH_A] = pHalData->TxPwrLevelHT40_2S[RF_PATH_A][index];
@@ -1926,7 +1926,7 @@ static void getTxPowerIndex(
 }
 
 static void ccxPowerIndexCheck(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8			channel,
 	u8*		cckPowerLevel,
 	u8*		ofdmPowerLevel
@@ -1939,7 +1939,7 @@ static void ccxPowerIndexCheck(
  * Overview:    This function is export to "HalCommon" moudule
  *			We must consider RF path later!!!!!!!
  *
- * Input:       struct rtw_adapter *		Adapter
+ * Input:       struct rtw_adapter *		adapter
  *			u1Byte		channel
  *
  * Output:      NONE
@@ -1952,18 +1952,18 @@ static void ccxPowerIndexCheck(
  *---------------------------------------------------------------------------*/
 void
 PHY_SetTxPowerLevel8192D(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8			channel
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	cckPowerLevel[2], ofdmPowerLevel[2];	/*  [0]:RF-A, [1]:RF-B */
 
 #if (MP_DRIVER == 1)
 	return;
 #endif
 
-	if ((Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(adapter_to_dvobj(Adapter)->ishighspeed == false))
+	if ((adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(adapter_to_dvobj(adapter)->ishighspeed == false))
 		return;
 
 	if (pHalData->bTXPowerDataReadFromEEPORM == false)
@@ -1971,14 +1971,14 @@ PHY_SetTxPowerLevel8192D(
 
 	channel = GetRightChnlPlace(channel);
 
-	getTxPowerIndex(Adapter, channel, &cckPowerLevel[0], &ofdmPowerLevel[0]);
+	getTxPowerIndex(adapter, channel, &cckPowerLevel[0], &ofdmPowerLevel[0]);
 
 	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
-		ccxPowerIndexCheck(Adapter, channel, &cckPowerLevel[0], &ofdmPowerLevel[0]);
+		ccxPowerIndexCheck(adapter, channel, &cckPowerLevel[0], &ofdmPowerLevel[0]);
 
 	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
-		rtl8192d_PHY_RF6052SetCckTxPower(Adapter, &cckPowerLevel[0]);
-	rtl8192d_PHY_RF6052SetOFDMTxPower(Adapter, &ofdmPowerLevel[0], channel);
+		rtl8192d_PHY_RF6052SetCckTxPower(adapter, &cckPowerLevel[0]);
+	rtl8192d_PHY_RF6052SetOFDMTxPower(adapter, &ofdmPowerLevel[0], channel);
 }
 
 /*  */
@@ -1991,17 +1991,17 @@ PHY_SetTxPowerLevel8192D(
 /*  */
 bool
 PHY_UpdateTxPowerDbm8192D(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	int		powerInDbm
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	idx;
 	u8	rf_path;
 
 	/*  TODO: A mode Tx power. */
-	u8	CckTxPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_B, powerInDbm);
-	u8	OfdmTxPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_N_24G, powerInDbm);
+	u8	CckTxPwrIdx = phy_DbmToTxPwrIdx(adapter, WIRELESS_MODE_B, powerInDbm);
+	u8	OfdmTxPwrIdx = phy_DbmToTxPwrIdx(adapter, WIRELESS_MODE_N_24G, powerInDbm);
 
 	if (OfdmTxPwrIdx - pHalData->LegacyHTTxPowerDiff > 0)
 		OfdmTxPwrIdx -= pHalData->LegacyHTTxPowerDiff;
@@ -2036,7 +2036,7 @@ PHY_UpdateTxPowerDbm8192D(
 
 void
 rtl8192d_PHY_SetBeaconHwReg(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u16			BeaconInterval
 	)
 {
@@ -2045,7 +2045,7 @@ rtl8192d_PHY_SetBeaconHwReg(
 
 void
 PHY_ScanOperationBackup8192D(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8		Operation
 	)
 {
@@ -2068,17 +2068,17 @@ PHY_ScanOperationBackup8192D(
  *---------------------------------------------------------------------------*/
 static void
 _PHY_SetBWMode92D(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	regBwOpMode;
 	u8	regRRSR_RSC;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	/*  FOr 92D dual mac config. */
-	struct rtw_adapter *BuddyAdapter = Adapter->pbuddy_adapter;
-	struct hal_data_8192du *pHalDataBuddyAdapter;
+	struct rtw_adapter *Buddyadapter = adapter->pbuddy_adapter;
+	struct hal_data_8192du *pHalDataBuddyadapter;
 #endif
 
 
@@ -2089,33 +2089,33 @@ _PHY_SetBWMode92D(
 	if (pHalData->rf_chip==RF_8225)
 		return;
 
-	if (Adapter->bDriverStopped)
+	if (adapter->bDriverStopped)
 		return;
 
 
 	/* 3 */
 	/* 3<1>Set MAC register */
 	/* 3 */
-	/* Adapter->HalFunc.SetBWModeHandler(); */
+	/* adapter->HalFunc.SetBWModeHandler(); */
 
-	regBwOpMode = rtw_read8(Adapter, REG_BWOPMODE);
-	regRRSR_RSC = rtw_read8(Adapter, REG_RRSR+2);
+	regBwOpMode = rtw_read8(adapter, REG_BWOPMODE);
+	regRRSR_RSC = rtw_read8(adapter, REG_RRSR+2);
 
 	switch (pHalData->CurrentChannelBW)
 	{
 		case HT_CHANNEL_WIDTH_20:
 			regBwOpMode |= BW_OPMODE_20MHZ;
 			   /*  2007/02/07 Mark by Emily becasue we have not verify whether this register works */
-			rtw_write8(Adapter, REG_BWOPMODE, regBwOpMode);
+			rtw_write8(adapter, REG_BWOPMODE, regBwOpMode);
 			break;
 
 		case HT_CHANNEL_WIDTH_40:
 			regBwOpMode &= ~BW_OPMODE_20MHZ;
 				/*  2007/02/07 Mark by Emily becasue we have not verify whether this register works */
-			rtw_write8(Adapter, REG_BWOPMODE, regBwOpMode);
+			rtw_write8(adapter, REG_BWOPMODE, regBwOpMode);
 
 			regRRSR_RSC = (regRRSR_RSC&0x90) |(pHalData->nCur40MhzPrimeSC<<5);
-			rtw_write8(Adapter, REG_RRSR+2, regRRSR_RSC);
+			rtw_write8(adapter, REG_RRSR+2, regRRSR_RSC);
 			break;
 
 		default:
@@ -2131,30 +2131,30 @@ _PHY_SetBWMode92D(
 	{
 		/* 20 MHz channel*/
 		case HT_CHANNEL_WIDTH_20:
-			PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, bRFMOD, 0x0);
+			PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bRFMOD, 0x0);
 
-			PHY_SetBBReg(Adapter, rFPGA1_RFMOD, bRFMOD, 0x0);
+			PHY_SetBBReg(adapter, rFPGA1_RFMOD, bRFMOD, 0x0);
 
-			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter2, BIT10|BIT11, 3);/*  SET BIT10 BIT11  for receive cck */
+			PHY_SetBBReg(adapter, rFPGA0_AnalogParameter2, BIT10|BIT11, 3);/*  SET BIT10 BIT11  for receive cck */
 
 			break;
 
 		/* 40 MHz channel*/
 		case HT_CHANNEL_WIDTH_40:
-			PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, bRFMOD, 0x1);
+			PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bRFMOD, 0x1);
 
-			PHY_SetBBReg(Adapter, rFPGA1_RFMOD, bRFMOD, 0x1);
+			PHY_SetBBReg(adapter, rFPGA1_RFMOD, bRFMOD, 0x1);
 
 			/*  Set Control channel to upper or lower. These settings are required only for 40MHz */
 			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 			{
-				PHY_SetBBReg(Adapter, rCCK0_System, bCCKSideBand, (pHalData->nCur40MhzPrimeSC>>1));
+				PHY_SetBBReg(adapter, rCCK0_System, bCCKSideBand, (pHalData->nCur40MhzPrimeSC>>1));
 			}
-			PHY_SetBBReg(Adapter, rOFDM1_LSTF, 0xC00, pHalData->nCur40MhzPrimeSC);
+			PHY_SetBBReg(adapter, rOFDM1_LSTF, 0xC00, pHalData->nCur40MhzPrimeSC);
 
-			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter2, BIT10|BIT11, 0);/*  SET BIT10 BIT11  for receive cck */
+			PHY_SetBBReg(adapter, rFPGA0_AnalogParameter2, BIT10|BIT11, 0);/*  SET BIT10 BIT11  for receive cck */
 
-			PHY_SetBBReg(Adapter, 0x818, (BIT26|BIT27), (pHalData->nCur40MhzPrimeSC==HAL_PRIME_CHNL_OFFSET_LOWER)?2:1);
+			PHY_SetBBReg(adapter, 0x818, (BIT26|BIT27), (pHalData->nCur40MhzPrimeSC==HAL_PRIME_CHNL_OFFSET_LOWER)?2:1);
 
 			break;
 
@@ -2184,7 +2184,7 @@ _PHY_SetBWMode92D(
 			break;
 
 		case RF_6052:
-			rtl8192d_PHY_RF6052SetBandwidth(Adapter, pHalData->CurrentChannelBW);
+			rtl8192d_PHY_RF6052SetBandwidth(adapter, pHalData->CurrentChannelBW);
 			break;
 
 		default:
@@ -2193,13 +2193,13 @@ _PHY_SetBWMode92D(
 
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if (Adapter->DualMacConcurrent == true && BuddyAdapter != NULL)
+	if (adapter->DualMacConcurrent == true && Buddyadapter != NULL)
 	{
 		if (pHalData->bMasterOfDMSP)
 		{
-			pHalDataBuddyAdapter = GET_HAL_DATA(BuddyAdapter);
-			pHalDataBuddyAdapter->CurrentChannelBW=pHalData->CurrentChannelBW;
-			pHalDataBuddyAdapter->nCur40MhzPrimeSC = pHalData->nCur40MhzPrimeSC;
+			pHalDataBuddyadapter = GET_HAL_DATA(Buddyadapter);
+			pHalDataBuddyadapter->CurrentChannelBW=pHalData->CurrentChannelBW;
+			pHalDataBuddyadapter->nCur40MhzPrimeSC = pHalData->nCur40MhzPrimeSC;
 		}
 	}
 #endif
@@ -2211,7 +2211,7 @@ _PHY_SetBWMode92D(
  *
  * Overview:  This function is export to "HalCommon" moudule
  *
- * Input:		struct rtw_adapter *			Adapter
+ * Input:		struct rtw_adapter *			adapter
  *			HT_CHANNEL_WIDTH	Bandwidth	20M or 40M
  *
  * Output:      NONE
@@ -2222,15 +2222,15 @@ _PHY_SetBWMode92D(
  *---------------------------------------------------------------------------*/
 void
 PHY_SetBWMode8192D(
-	struct rtw_adapter *					Adapter,
+	struct rtw_adapter *					adapter,
 	enum HT_CHANNEL_WIDTH	Bandwidth,	/*  20M or 40M */
 	unsigned char	Offset		/*  Upper, Lower, or Don't care */
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	enum HT_CHANNEL_WIDTH	tmpBW= pHalData->CurrentChannelBW;
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
 #endif
 
 
@@ -2248,7 +2248,7 @@ PHY_SetBWMode8192D(
 	pHalData->nCur40MhzPrimeSC = Offset;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if ((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
+	if ((Buddyadapter !=NULL) && (pHalData->bSlaveOfDMSP))
 	{
 		{
 			DBG_8192D("PHY_SetBWMode92D():slave return when slave\n");
@@ -2257,10 +2257,10 @@ PHY_SetBWMode8192D(
 	}
 #endif
 
-	if ((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))
+	if ((!adapter->bDriverStopped) && (!adapter->bSurpriseRemoved))
 	{
 #ifndef USE_WORKITEM
-	_PHY_SetBWMode92D(Adapter);
+	_PHY_SetBWMode92D(adapter);
 #endif
 	}
 	else
@@ -2277,26 +2277,26 @@ Descriptor:
 ********************************************************************/
 void
 PHY_StopTRXBeforeChangeBand8192D(
-	  struct rtw_adapter *		Adapter
+	  struct rtw_adapter *		adapter
 )
 {
 #if MP_DRIVER == 1
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
-	pdmpriv->RegC04_MP = (u8)PHY_QueryBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0);
-	pdmpriv->RegD04_MP = PHY_QueryBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord);
+	pdmpriv->RegC04_MP = (u8)PHY_QueryBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0);
+	pdmpriv->RegD04_MP = PHY_QueryBBReg(adapter, rOFDM1_TRxPathEnable, bDWord);
 #endif
 
-	PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x00);
+	PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x00);
 
-	PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x00);
-	PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, 0x0);
+	PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x00);
+	PHY_SetBBReg(adapter, rOFDM1_TRxPathEnable, bDWord, 0x0);
 }
 
-static void PHY_SwitchWirelessBand(struct rtw_adapter *Adapter, u8 Band)
+static void PHY_SwitchWirelessBand(struct rtw_adapter *adapter, u8 Band)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u8	i, value8;/*  RegValue */
 
@@ -2324,21 +2324,21 @@ static void PHY_SwitchWirelessBand(struc
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (pHalData->bMasterOfDMSP)
 	{
-		struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
-		if (BuddyAdapter!=NULL)
+		struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+		if (Buddyadapter!=NULL)
 		{
-			if (BuddyAdapter->hw_init_completed)
+			if (Buddyadapter->hw_init_completed)
 			{
-				GET_HAL_DATA(BuddyAdapter)->BandSet92D = pHalData->BandSet92D;
-				GET_HAL_DATA(BuddyAdapter)->CurrentBandType92D = pHalData->CurrentBandType92D;
-				GET_HAL_DATA(BuddyAdapter)->CurrentWirelessMode = pHalData->CurrentWirelessMode;
+				GET_HAL_DATA(Buddyadapter)->BandSet92D = pHalData->BandSet92D;
+				GET_HAL_DATA(Buddyadapter)->CurrentBandType92D = pHalData->CurrentBandType92D;
+				GET_HAL_DATA(Buddyadapter)->CurrentWirelessMode = pHalData->CurrentWirelessMode;
 			}
 		}
 	}
 #endif
 
 	/* stop RX/Tx */
-	PHY_StopTRXBeforeChangeBand8192D(Adapter);
+	PHY_StopTRXBeforeChangeBand8192D(adapter);
 
 	/* reconfig BB/RF according to wireless mode */
 	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
@@ -2347,9 +2347,9 @@ static void PHY_SwitchWirelessBand(struc
 		if (pHalData->interfaceIndex == 1)
 		{
 #ifdef CONFIG_EMBEDDED_FWIMG
-			phy_ConfigBBWithHeaderFile(Adapter, BaseBand_Config_AGC_TAB);
+			phy_ConfigBBWithHeaderFile(adapter, BaseBand_Config_AGC_TAB);
 #else
-			PHY_SetAGCTab8192D(Adapter);
+			PHY_SetAGCTab8192D(adapter);
 #endif
 		}
 	}
@@ -2358,40 +2358,40 @@ static void PHY_SwitchWirelessBand(struc
 		if (pHalData->interfaceIndex == 1)
 		{
 #ifdef CONFIG_EMBEDDED_FWIMG
-			phy_ConfigBBWithHeaderFile(Adapter, BaseBand_Config_AGC_TAB);
+			phy_ConfigBBWithHeaderFile(adapter, BaseBand_Config_AGC_TAB);
 #else
-			PHY_SetAGCTab8192D(Adapter);
+			PHY_SetAGCTab8192D(adapter);
 #endif
 		}
 	}
 
-	PHY_UpdateBBRFConfiguration8192D(Adapter, true);
+	PHY_UpdateBBRFConfiguration8192D(adapter, true);
 
 	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 	{
-		update_tx_basic_rate(Adapter, WIRELESS_11BG_24N);
+		update_tx_basic_rate(adapter, WIRELESS_11BG_24N);
 
-		PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x3);
+		PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x3);
 	}
 	else
 	{
 		/* avoid using cck rate in 5G band */
 		/*  Set RRSR rate table. */
-		update_tx_basic_rate(Adapter, WIRELESS_11A_5N);
+		update_tx_basic_rate(adapter, WIRELESS_11A_5N);
 
-		PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x2);
+		PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x2);
 	}
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (pHalData->bMasterOfDMSP)
 	{
-		struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
-		if (BuddyAdapter!=NULL)
+		struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+		if (Buddyadapter!=NULL)
 		{
 			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
-				rtw_write16(BuddyAdapter, REG_RRSR, 0x15d);
+				rtw_write16(Buddyadapter, REG_RRSR, 0x15d);
 			else
-				rtw_write16(BuddyAdapter, REG_RRSR, 0x150);
+				rtw_write16(Buddyadapter, REG_RRSR, 0x150);
 		}
 	}
 #endif
@@ -2402,15 +2402,15 @@ static void PHY_SwitchWirelessBand(struc
 	/*  notice fw know band status  0x81[1]/0x53[1] = 0: 5G, 1: 2G */
 	if (pHalData->CurrentBandType92D==BAND_ON_2_4G)
 	{
-		value8 = rtw_read8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
+		value8 = rtw_read8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
 		value8 |= BIT1;
-		rtw_write8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1),value8);
+		rtw_write8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1),value8);
 	}
 	else
 	{
-		value8 = rtw_read8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
+		value8 = rtw_read8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
 		value8 &= (~BIT1);
-		rtw_write8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1),value8);
+		rtw_write8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1),value8);
 	}
 
 
@@ -2422,13 +2422,13 @@ static void PHY_SwitchWirelessBand(struc
 
 static void
 PHY_EnableRFENV(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8				eRFPath	,
 	u32				MaskforPhySet,
 	u32*			pu4RegValue
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct bb_register_def *pPhyReg = &pHalData->PHYRegDef[eRFPath];
 
 
@@ -2437,39 +2437,39 @@ PHY_EnableRFENV(
 	{
 		case RF_PATH_A:
 		case RF_PATH_C:
-			*pu4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV);
+			*pu4RegValue = PHY_QueryBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV);
 			break;
 		case RF_PATH_B:
 		case RF_PATH_D:
-			*pu4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16);
+			*pu4RegValue = PHY_QueryBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16);
 			break;
 	}
 
 	/*----Set RF_ENV enable----*/
-	PHY_SetBBReg(Adapter, pPhyReg->rfintfe|MaskforPhySet, bRFSI_RFENV<<16, 0x1);
+	PHY_SetBBReg(adapter, pPhyReg->rfintfe|MaskforPhySet, bRFSI_RFENV<<16, 0x1);
 	rtw_udelay_os(1);
 
 	/*----Set RF_ENV output high----*/
-	PHY_SetBBReg(Adapter, pPhyReg->rfintfo|MaskforPhySet, bRFSI_RFENV, 0x1);
+	PHY_SetBBReg(adapter, pPhyReg->rfintfo|MaskforPhySet, bRFSI_RFENV, 0x1);
 	rtw_udelay_os(1);
 
 	/* Set bit number of Address and Data for RF register */
-	PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireAddressLength, 0x0);	/*  Set 1 to 4 bits for 8255 */
+	PHY_SetBBReg(adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireAddressLength, 0x0);	/*  Set 1 to 4 bits for 8255 */
 	rtw_udelay_os(1);
 
-	PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireDataLength, 0x0); /*  Set 0 to 12	bits for 8255 */
+	PHY_SetBBReg(adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireDataLength, 0x0); /*  Set 0 to 12	bits for 8255 */
 	rtw_udelay_os(1);
 }
 
 static void
 PHY_RestoreRFENV(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8				eRFPath,
 	u32				MaskforPhySet,
 	u32*			pu4RegValue
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct bb_register_def *pPhyReg = &pHalData->PHYRegDef[eRFPath];
 
 	/* If another MAC is ON,need do this? */
@@ -2478,11 +2478,11 @@ PHY_RestoreRFENV(
 	{
 		case RF_PATH_A:
 		case RF_PATH_C:
-			PHY_SetBBReg(Adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV, *pu4RegValue);
+			PHY_SetBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV, *pu4RegValue);
 			break;
 		case RF_PATH_B :
 		case RF_PATH_D:
-			PHY_SetBBReg(Adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16, *pu4RegValue);
+			PHY_SetBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16, *pu4RegValue);
 			break;
 	}
 }
@@ -2493,7 +2493,7 @@ PHY_RestoreRFENV(
  *
  * Overview:	Change RF Setting when we siwthc channel for 92D C-cut.
  *
- * Input:       struct rtw_adapter *				pAdapter
+ * Input:       struct rtw_adapter *				adapter
  *
  * Output:      NONE
  *
@@ -2507,22 +2507,22 @@ PHY_RestoreRFENV(
  *---------------------------------------------------------------------------*/
  static	void
  phy_SwitchRfSetting(
-	struct rtw_adapter *			Adapter,
+	struct rtw_adapter *			adapter,
 	u8					channel
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8			path = pHalData->CurrentBandType92D==BAND_ON_5G?RF_PATH_A:RF_PATH_B;
 	u8			index = 0,	i = 0, eRFPath = RF_PATH_A;
 	bool		bNeedPowerDownRadio = false, bInteralPA = false;
 	u32			u4RegValue, mask = 0x1C000, value = 0, u4tmp, u4tmp2,MaskforPhySet=0;
 	/* Query regB30 bit27 */
-	u32			Regb30 = PHY_QueryBBReg(Adapter, 0xb30, BIT27);
+	u32			Regb30 = PHY_QueryBBReg(adapter, 0xb30, BIT27);
 
 
 	/* only for 92D C-cut SMSP */
 
-	if (adapter_to_dvobj(Adapter)->ishighspeed == false)
+	if (adapter_to_dvobj(adapter)->ishighspeed == false)
 		return;
 
 	/* config path A for 5G */
@@ -2551,11 +2551,11 @@ PHY_RestoreRFENV(
 
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
 		{
-			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
+			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(adapter, false);
 			MaskforPhySet = MAC1_ACCESS_PHY0;
 			/* asume no this case */
 			if (bNeedPowerDownRadio)
-				PHY_EnableRFENV(Adapter, path, MaskforPhySet, &u4RegValue);
+				PHY_EnableRFENV(adapter, path, MaskforPhySet, &u4RegValue);
 		}
 
 		/* DMDP, if band = 5G,Mac0 need to set PHY1 when regB30[27]=1 */
@@ -2563,18 +2563,18 @@ PHY_RestoreRFENV(
 		{
 			DBG_8192D("===============phy_SwitchRfSetting8192D interface %d,B30&BIT27=1!!!!\n", pHalData->interfaceIndex);
 
-			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
+			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(adapter, true);
 			MaskforPhySet= MAC0_ACCESS_PHY1;
 			/* asume no this case */
 			if (bNeedPowerDownRadio)
-				PHY_EnableRFENV(Adapter, path, MaskforPhySet, &u4RegValue);
+				PHY_EnableRFENV(adapter, path, MaskforPhySet, &u4RegValue);
 		}
 
 		for (i = 0; i < RF_REG_NUM_for_C_CUT_5G; i++)
 		{
 			if (i == 0 && (pHalData->MacPhyMode92D == DUALMAC_DUALPHY))
 			{
-				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, 0xE439D);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, 0xE439D);
 			}
 			else if (RF_REG_for_C_CUT_5G[i] == RF_SYN_G4)
 			{
@@ -2584,25 +2584,25 @@ PHY_RestoreRFENV(
 				if (channel == 36)
 					u4tmp2 &= ~(BIT7|BIT6);
 
-				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, u4tmp2);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, u4tmp2);
 #else
 				u4tmp2= RF_REG_Param_for_C_CUT_5G[index][i];
-				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, 0xFF8FF, u4tmp2);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, 0xFF8FF, u4tmp2);
 #endif
 			} else {
-				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, RF_REG_Param_for_C_CUT_5G[index][i]);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, RF_REG_Param_for_C_CUT_5G[index][i]);
 			}
 		}
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1) {
 			if (bNeedPowerDownRadio)
-				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
-			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
+				PHY_RestoreRFENV(adapter, path,MaskforPhySet, &u4RegValue);
+			rtl8192d_PHY_PowerDownAnotherPHY(adapter, false);
 		}
 
 		if (Regb30 && pHalData->interfaceIndex == 0) {
 			if (bNeedPowerDownRadio)
-				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
-			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
+				PHY_RestoreRFENV(adapter, path,MaskforPhySet, &u4RegValue);
+			rtl8192d_PHY_PowerDownAnotherPHY(adapter, true);
 		}
 
 		if (channel < 149)
@@ -2631,13 +2631,13 @@ PHY_RestoreRFENV(
 				{
 					if (RF_REG_for_C_CUT_5G_internalPA[i] == 0x03 &&
 						channel >=36 && channel <=64)
-						PHY_SetRFReg(Adapter, eRFPath, RF_REG_for_C_CUT_5G_internalPA[i], bRFRegOffsetMask, 0x7bdef);
+						PHY_SetRFReg(adapter, eRFPath, RF_REG_for_C_CUT_5G_internalPA[i], bRFRegOffsetMask, 0x7bdef);
 					else
-						PHY_SetRFReg(Adapter, eRFPath, RF_REG_for_C_CUT_5G_internalPA[i], bRFRegOffsetMask, RF_REG_Param_for_C_CUT_5G_internalPA[index][i]);
+						PHY_SetRFReg(adapter, eRFPath, RF_REG_for_C_CUT_5G_internalPA[i], bRFRegOffsetMask, RF_REG_Param_for_C_CUT_5G_internalPA[index][i]);
 				}
 			}
 			else
-				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_TXPA_AG, mask, value);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_TXPA_AG, mask, value);
 		}
 	}
 	else if (pHalData->CurrentBandType92D==BAND_ON_2_4G)
@@ -2657,21 +2657,21 @@ PHY_RestoreRFENV(
 			path = RF_PATH_A;
 			if (pHalData->interfaceIndex == 0)
 			{
-				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
+				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(adapter, true);
 				MaskforPhySet = MAC0_ACCESS_PHY1;
 				if (bNeedPowerDownRadio)
-					PHY_EnableRFENV(Adapter, path,MaskforPhySet,&u4RegValue);
+					PHY_EnableRFENV(adapter, path,MaskforPhySet,&u4RegValue);
 			}
 
 			/* DMDP, if band = 2G,MAC1 need to set PHY0 when regB30[27]=1 */
 			if (Regb30 && pHalData->interfaceIndex == 1)
 			{
 
-				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
+				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(adapter, false);
 				MaskforPhySet= MAC1_ACCESS_PHY0;
 				/* asume no this case */
 				if (bNeedPowerDownRadio)
-					PHY_EnableRFENV(Adapter, path,MaskforPhySet,&u4RegValue);
+					PHY_EnableRFENV(adapter, path,MaskforPhySet,&u4RegValue);
 			}
 		}
 
@@ -2680,29 +2680,29 @@ PHY_RestoreRFENV(
 		{
 #if SWLCK == 1
 			if (RF_REG_for_C_CUT_2G[i] == RF_SYN_G7)
-				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_2G[i]|MaskforPhySet, bRFRegOffsetMask, (RF_REG_Param_for_C_CUT_2G[index][i] | BIT17));
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_2G[i]|MaskforPhySet, bRFRegOffsetMask, (RF_REG_Param_for_C_CUT_2G[index][i] | BIT17));
 			else
 #endif
-			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_2G[i]|MaskforPhySet, bRFRegOffsetMask, RF_REG_Param_for_C_CUT_2G[index][i]);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_2G[i]|MaskforPhySet, bRFRegOffsetMask, RF_REG_Param_for_C_CUT_2G[index][i]);
 		}
 
 #if SWLCK == 1
 		/* for SWLCK */
 
-		PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_SYN_G4|MaskforPhySet, bRFRegOffsetMask, RF_REG_SYN_G4_for_C_CUT_2G | (u4tmp << 11));
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_SYN_G4|MaskforPhySet, bRFRegOffsetMask, RF_REG_SYN_G4_for_C_CUT_2G | (u4tmp << 11));
 #endif
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
 		{
 			if (bNeedPowerDownRadio) {
-				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
+				PHY_RestoreRFENV(adapter, path,MaskforPhySet, &u4RegValue);
 			}
-			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
+			rtl8192d_PHY_PowerDownAnotherPHY(adapter, true);
 		}
 
 		if (Regb30 && pHalData->interfaceIndex == 1) {
 			if (bNeedPowerDownRadio)
-				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
-			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
+				PHY_RestoreRFENV(adapter, path,MaskforPhySet, &u4RegValue);
+			rtl8192d_PHY_PowerDownAnotherPHY(adapter, false);
 		}
 	}
 }
@@ -2713,7 +2713,7 @@ PHY_RestoreRFENV(
  *
  * Overview:	Change RF Setting when we siwthc channel for 92D C-cut.
  *
- * Input:       struct rtw_adapter *				pAdapter
+ * Input:       struct rtw_adapter *				adapter
  *
  * Output:      NONE
  *
@@ -2727,11 +2727,11 @@ PHY_RestoreRFENV(
  *---------------------------------------------------------------------------*/
 static  void
  phy_ReloadLCKSetting(
-	struct rtw_adapter *				Adapter,
+	struct rtw_adapter *				adapter,
 	u8					channel
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8		eRFPath = pHalData->CurrentBandType92D == BAND_ON_5G?RF_PATH_A:IS_92D_SINGLEPHY(pHalData->VersionID)?RF_PATH_B:RF_PATH_A;
 	u32		u4tmp = 0, u4RegValue = 0;
 	bool		bNeedPowerDownRadio = false;
@@ -2747,18 +2747,18 @@ static  void
 
 			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
 			{
-				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
+				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(adapter, false);
 				MaskforPhySet = MAC1_ACCESS_PHY0;
 				/* asume no this case */
 				if (bNeedPowerDownRadio)
-					PHY_EnableRFENV(Adapter, eRFPath, MaskforPhySet,&u4RegValue);
+					PHY_EnableRFENV(adapter, eRFPath, MaskforPhySet,&u4RegValue);
 			}
 
-			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_SYN_G4|MaskforPhySet, 0x3f800, u4tmp);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_SYN_G4|MaskforPhySet, 0x3f800, u4tmp);
 
 			if (bNeedPowerDownRadio) {
-				PHY_RestoreRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
-				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
+				PHY_RestoreRFENV(adapter, eRFPath,MaskforPhySet, &u4RegValue);
+				rtl8192d_PHY_PowerDownAnotherPHY(adapter, false);
 			}
 		}
 	}
@@ -2770,16 +2770,16 @@ static  void
 
 			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
 			{
-				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
+				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(adapter, true);
 				MaskforPhySet = MAC0_ACCESS_PHY1;
 				if (bNeedPowerDownRadio)
-					PHY_EnableRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
+					PHY_EnableRFENV(adapter, eRFPath,MaskforPhySet, &u4RegValue);
 			}
-			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_SYN_G4|MaskforPhySet, 0x3f800, u4tmp);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_SYN_G4|MaskforPhySet, 0x3f800, u4tmp);
 
 			if (bNeedPowerDownRadio) {
-				PHY_RestoreRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
-				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
+				PHY_RestoreRFENV(adapter, eRFPath,MaskforPhySet, &u4RegValue);
+				rtl8192d_PHY_PowerDownAnotherPHY(adapter, true);
 			}
 		}
 	}
@@ -2794,7 +2794,7 @@ static  void
  *
  * Overview:	Change RF Setting when we siwthc channel for 92D C-cut.
  *
- * Input:       struct rtw_adapter *				pAdapter
+ * Input:       struct rtw_adapter *				adapter
  *
  * Output:      NONE
  *
@@ -2808,53 +2808,53 @@ static  void
  *---------------------------------------------------------------------------*/
  static void
  phy_ReloadIMRSetting(
-	struct rtw_adapter *				Adapter,
+	struct rtw_adapter *				adapter,
 	u8					channel,
 	u8					eRFPath
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u32		IMR_NUM = MAX_RF_IMR_INDEX;
 	u32		RFMask=bRFRegOffsetMask;
 	u8		group=0, i;
 
-	if (adapter_to_dvobj(Adapter)->ishighspeed == false)
+	if (adapter_to_dvobj(adapter)->ishighspeed == false)
 		return;
 
 	/* only for 92D C-cut SMSP */
 
 	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 	{
-		PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, BIT25|BIT24, 0);
-		PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,	0xf);
+		PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, BIT25|BIT24, 0);
+		PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000,	0xf);
 
 		/*  fc area 0xd2c */
 		if (channel>=149)
-			PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT13|BIT14,2);
+			PHY_SetBBReg(adapter, rOFDM1_CFOTracking, BIT13|BIT14,2);
 		else
-			PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT13|BIT14,1);
+			PHY_SetBBReg(adapter, rOFDM1_CFOTracking, BIT13|BIT14,1);
 
 		group = channel<=64?1:2; /* leave 0 for channel1-14. */
 		IMR_NUM = MAX_RF_IMR_INDEX_NORMAL;
 
 		for (i=0; i<IMR_NUM; i++) {
-			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_REG_FOR_5G_SWCHNL_NORMAL[i], RFMask,RF_IMR_Param_Normal[0][group][i]);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_REG_FOR_5G_SWCHNL_NORMAL[i], RFMask,RF_IMR_Param_Normal[0][group][i]);
 		}
-		PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,0);
-		PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 2);
+		PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000,0);
+		PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 2);
 	}
 	else { /* G band. */
 
 		if (!pHalData->bLoadIMRandIQKSettingFor2G) {
-			PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, BIT25|BIT24, 0);
-			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,	0xf);
+			PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, BIT25|BIT24, 0);
+			PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000,	0xf);
 
 			IMR_NUM = MAX_RF_IMR_INDEX_NORMAL;
 			for (i=0; i<IMR_NUM; i++) {
-				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_REG_FOR_5G_SWCHNL_NORMAL[i], bRFRegOffsetMask,RF_IMR_Param_Normal[0][0][i]);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_REG_FOR_5G_SWCHNL_NORMAL[i], bRFRegOffsetMask,RF_IMR_Param_Normal[0][0][i]);
 			}
-			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,0);
-			PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 3);
+			PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000,0);
+			PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 3);
 		}
 	}
 
@@ -2866,7 +2866,7 @@ static  void
  *
  * Overview:	Change RF Setting when we siwthc channel for 92D C-cut.
  *
- * Input:       struct rtw_adapter *				pAdapter
+ * Input:       struct rtw_adapter *				adapter
  *
  * Output:      NONE
  *
@@ -2880,16 +2880,16 @@ static  void
  *---------------------------------------------------------------------------*/
  static void
  phy_ReloadIQKSetting(
-	struct rtw_adapter *				Adapter,
+	struct rtw_adapter *				adapter,
 	u8					channel
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8		Indexforchannel;/* index, */
 
 	/* only for 92D C-cut SMSP */
 
-	if (adapter_to_dvobj(Adapter)->ishighspeed == false)
+	if (adapter_to_dvobj(adapter)->ishighspeed == false)
 		return;
 
 	/* Do IQK for normal chip and test chip 5G band---------------- */
@@ -2903,7 +2903,7 @@ static  void
 	if (pHalData->bNeedIQK && !pHalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone)
 	{ /* Re Do IQK. */
 		DBG_8192D("Do IQK Matrix reg for channel:%d....\n", channel);
-		rtl8192d_PHY_IQCalibrate(Adapter);
+		rtl8192d_PHY_IQCalibrate(adapter);
 	}
 	else /* Just load the value. */
 	{
@@ -2914,9 +2914,9 @@ static  void
 			if ((pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][0] != 0)/*&&(RegEA4 != 0)*/)
 			{
 				if (pHalData->CurrentBandType92D == BAND_ON_5G)
-					phy_PathAFillIQKMatrix_5G_Normal(Adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][2] == 0));
+					phy_PathAFillIQKMatrix_5G_Normal(adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][2] == 0));
 				else
-					phy_PathAFillIQKMatrix(Adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][2] == 0));
+					phy_PathAFillIQKMatrix(adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][2] == 0));
 			}
 
 			if (IS_92D_SINGLEPHY(pHalData->VersionID))
@@ -2924,13 +2924,13 @@ static  void
 				if ((pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][4] != 0)/*&&(RegEC4 != 0)*/)
 				{
 					if (pHalData->CurrentBandType92D == BAND_ON_5G)
-						phy_PathBFillIQKMatrix_5G_Normal(Adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][6] == 0));
+						phy_PathBFillIQKMatrix_5G_Normal(adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][6] == 0));
 					else
-						phy_PathBFillIQKMatrix(Adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][6] == 0));
+						phy_PathBFillIQKMatrix(adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][6] == 0));
 				}
 			}
 
-			if ((Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(Indexforchannel==0))
+			if ((adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(Indexforchannel==0))
 				pHalData->bLoadIMRandIQKSettingFor2G=true;
 		}
 	}
@@ -2938,19 +2938,19 @@ static  void
 }
 
 
-static void _PHY_SwChnl8192D(struct rtw_adapter * Adapter, u8 channel)
+static void _PHY_SwChnl8192D(struct rtw_adapter * adapter, u8 channel)
 {
 	u8	eRFPath;
 	u32	param1, param2;
 	u32	ret_value;
 	enum BAND_TYPE	bandtype, target_bandtype;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 #if defined(CONFIG_CONCURRENT_MODE) || defined(CONFIG_DUALMAC_CONCURRENT)
 	/*  FOr 92D dual mac config. and sw concurrent mode */
-	struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
 #endif
 
-	if (Adapter->bNotifyChannelChange)
+	if (adapter->bNotifyChannelChange)
 	{
 		DBG_8192D("[%s] ch = %d\n", __func__, channel);
 	}
@@ -2958,7 +2958,7 @@ static void _PHY_SwChnl8192D(struct rtw_
 	if (pHalData->BandSet92D == BAND_ON_BOTH) {
 		/*  Need change band? */
 		/*  BB {Reg878[0],[16]} bit0= 1 is 5G, bit0=0 is 2G. */
-		ret_value = PHY_QueryBBReg(Adapter, rFPGA0_XAB_RFParameter, bMaskDWord);
+		ret_value = PHY_QueryBBReg(adapter, rFPGA0_XAB_RFParameter, bMaskDWord);
 
 		if (ret_value & BIT0)
 			bandtype = BAND_ON_5G;
@@ -2976,12 +2976,12 @@ static void _PHY_SwChnl8192D(struct rtw_
 		}
 
 		if (target_bandtype != bandtype)
-			PHY_SwitchWirelessBand(Adapter,target_bandtype);
+			PHY_SwitchWirelessBand(adapter,target_bandtype);
 	}
 
 	do{
 		/* s1. pre common command - CmdID_SetTxPowerLevel */
-		PHY_SetTxPowerLevel8192D(Adapter, channel);
+		PHY_SetTxPowerLevel8192D(adapter, channel);
 
 		/* s2. RF dependent command - CmdID_RF_WriteReg, param1=RF_CHNLBW, param2=channel */
 		param1 = RF_CHNLBW;
@@ -3005,34 +3005,34 @@ static void _PHY_SwChnl8192D(struct rtw_
 			{
 				pHalData->RfRegChnlVal[eRFPath] &= ~(BIT8|BIT16|BIT18);
 			}
-			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, param1, bRFRegOffsetMask, pHalData->RfRegChnlVal[eRFPath]);
-			phy_ReloadIMRSetting(Adapter, channel, eRFPath);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, param1, bRFRegOffsetMask, pHalData->RfRegChnlVal[eRFPath]);
+			phy_ReloadIMRSetting(adapter, channel, eRFPath);
 		}
 
-		phy_SwitchRfSetting(Adapter, channel);
+		phy_SwitchRfSetting(adapter, channel);
 
 		/* do IQK when all parameters are ready */
-		phy_ReloadIQKSetting(Adapter, channel);
+		phy_ReloadIQKSetting(adapter, channel);
 		break;
 	}while (true);
 
 	/* s3. post common command - CmdID_End, None */
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (BuddyAdapter) {
-		GET_HAL_DATA(BuddyAdapter)->CurrentChannel = channel;
-		GET_HAL_DATA(BuddyAdapter)->BandSet92D = pHalData->BandSet92D;
-		GET_HAL_DATA(BuddyAdapter)->CurrentBandType92D = pHalData->CurrentBandType92D;
-		GET_HAL_DATA(BuddyAdapter)->CurrentWirelessMode = pHalData->CurrentWirelessMode;
+	if (Buddyadapter) {
+		GET_HAL_DATA(Buddyadapter)->CurrentChannel = channel;
+		GET_HAL_DATA(Buddyadapter)->BandSet92D = pHalData->BandSet92D;
+		GET_HAL_DATA(Buddyadapter)->CurrentBandType92D = pHalData->CurrentBandType92D;
+		GET_HAL_DATA(Buddyadapter)->CurrentWirelessMode = pHalData->CurrentWirelessMode;
 	}
 #endif
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if (Adapter->DualMacConcurrent == true && BuddyAdapter != NULL)
+	if (adapter->DualMacConcurrent == true && Buddyadapter != NULL)
 	{
 		if (pHalData->bMasterOfDMSP)
 		{
-			GET_HAL_DATA(BuddyAdapter)->CurrentChannel=channel;
+			GET_HAL_DATA(Buddyadapter)->CurrentChannel=channel;
 		}
 	}
 #endif
@@ -3041,18 +3041,18 @@ static void _PHY_SwChnl8192D(struct rtw_
 
 void
 PHY_SwChnl8192D(	/*  Call after initialization */
-	struct rtw_adapter *Adapter,
+	struct rtw_adapter *adapter,
 	u8		channel
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	tmpchannel = pHalData->CurrentChannel;
 	bool  bResult = true;
 	u32	timeout = 1000, timecount = 0;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct rtw_adapter *BuddyAdapter = Adapter->pbuddy_adapter;
-	struct hal_data_8192du *pHalDataBuddyAdapter;
+	struct rtw_adapter *Buddyadapter = adapter->pbuddy_adapter;
+	struct hal_data_8192du *pHalDataBuddyadapter;
 #endif
 
 	if (pHalData->rf_chip == RF_PSEUDO_11N)
@@ -3060,7 +3060,7 @@ PHY_SwChnl8192D(	/*  Call after initiali
 		return;									/* return immediately if it is peudo-phy */
 	}
 
-	if (Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_COMPLETE)
+	if (adapter->mlmeextpriv.sitesurvey_res.state == SCAN_COMPLETE)
 		pHalData->bLoadIMRandIQKSettingFor2G = false;
 
 
@@ -3072,12 +3072,12 @@ PHY_SwChnl8192D(	/*  Call after initiali
 		return;
 	}
 
-	if (BuddyAdapter != NULL &&
+	if (Buddyadapter != NULL &&
 		((pHalData->interfaceIndex == 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G) ||
 		(pHalData->interfaceIndex == 1 && pHalData->CurrentBandType92D == BAND_ON_5G)))
 	{
-		pHalDataBuddyAdapter=GET_HAL_DATA(BuddyAdapter);
-		while (pHalDataBuddyAdapter->bLCKInProgress && timecount < timeout)
+		pHalDataBuddyadapter=GET_HAL_DATA(Buddyadapter);
+		while (pHalDataBuddyadapter->bLCKInProgress && timecount < timeout)
 		{
 			#ifdef CONFIG_LONG_DELAY_ISSUE
 			rtw_msleep_os(50);
@@ -3127,17 +3127,17 @@ PHY_SwChnl8192D(	/*  Call after initiali
 
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if ((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
+	if ((Buddyadapter !=NULL) && (pHalData->bSlaveOfDMSP))
 	{
 		DBG_8192D("PHY_SwChnl8192D():slave return when slave\n");
 		return;
 	}
 #endif
 
-	if ((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))
+	if ((!adapter->bDriverStopped) && (!adapter->bSurpriseRemoved))
 	{
 #ifndef USE_WORKITEM
-		_PHY_SwChnl8192D(Adapter, channel);
+		_PHY_SwChnl8192D(adapter, channel);
 #endif
 		if (!bResult)
 				pHalData->CurrentChannel = tmpchannel;
@@ -3149,7 +3149,7 @@ PHY_SwChnl8192D(	/*  Call after initiali
 
 static	bool
 phy_SwChnlStepByStep(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8		channel,
 	u8		*stage,
 	u8		*step,
@@ -3189,7 +3189,7 @@ phy_SetSwChnlCmdArray(
 
 static	void
 phy_FinishSwChnlNow(	/*  We should not call this function directly */
-		struct rtw_adapter *	Adapter,
+		struct rtw_adapter *	adapter,
 		u8		channel
 		)
 {
@@ -3207,11 +3207,11 @@ phy_FinishSwChnlNow(	/*  We should not c
 /*  */
 void
 PHY_SwChnlPhy8192D(	/*  Only called during initialize */
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8		channel
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 
 	/*  Cannot IO. */
@@ -3229,7 +3229,7 @@ PHY_SwChnlPhy8192D(	/*  Only called duri
 
 	pHalData->CurrentChannel=channel;
 
-	phy_FinishSwChnlNow(Adapter,channel);
+	phy_FinishSwChnlNow(adapter,channel);
 
 }
 
@@ -3242,7 +3242,7 @@ PHY_SwChnlPhy8192D(	/*  Only called duri
 /*  */
 void
 PHY_SetMonitorMode8192D(
-	struct rtw_adapter *			pAdapter,
+	struct rtw_adapter *			adapter,
 	bool				bEnableMonitorMode
 	)
 {
@@ -3268,7 +3268,7 @@ PHY_SetMonitorMode8192D(
  *---------------------------------------------------------------------------*/
 bool
 PHY_CheckIsLegalRfPath8192D(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u32	eRFPath)
 {
 	bool				rtValue = true;
@@ -3288,61 +3288,61 @@ PHY_CheckIsLegalRfPath8192D(
 
 static u8			/* bit0 = 1 => Tx OK, bit1 = 1 => Rx OK */
 phy_PathA_IQK(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool		configPathB
 	)
 {
 	u32	regEAC, regE94, regE9C, regEA4;
 	u8	result = 0x00;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	/* path-A IQK setting */
 	if (pHalData->interfaceIndex == 0)
 	{
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
 	}
 	else
 	{
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x10008c22);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x10008c22);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x10008c22);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x10008c22);
 	}
 
-	PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82140102);
+	PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82140102);
 
-	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, configPathB ? 0x28160202 :
+	PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, configPathB ? 0x28160202 :
 		IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID)?0x28160202:0x28160502);
 
 	/* path-B IQK setting */
 	if (configPathB)
 	{
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x10008c22);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x10008c22);
-		PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82140102);
-		if (IS_HARDWARE_TYPE_8192D(pAdapter))
-			PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x28160206);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x10008c22);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x10008c22);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82140102);
+		if (IS_HARDWARE_TYPE_8192D(adapter))
+			PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x28160206);
 		else
-			PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x28160202);
+			PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x28160202);
 	}
 
 	/* LO calibration setting */
-	if (IS_HARDWARE_TYPE_8192D(pAdapter))
-		PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+	if (IS_HARDWARE_TYPE_8192D(adapter))
+		PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 	else
-		PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x001028d1);
+		PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x001028d1);
 
 	/* One shot, path A LOK & IQK */
-	PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-	PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+	PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
 	/*  delay x ms */
 	rtw_udelay_os(IQK_DELAY_TIME*1000);
 
 	/*  Check failed */
-	regEAC = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-	regE94 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord);
-	regE9C= PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord);
-	regEA4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
+	regEAC = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regE94 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord);
+	regE9C= PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord);
+	regEA4= PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
 
 	if (!(regEAC & BIT28) &&
 		(((regE94 & 0x03FF0000)>>16) != 0x142) &&
@@ -3364,11 +3364,11 @@ phy_PathA_IQK(
 
 static u8			/* bit0 = 1 => Tx OK, bit1 = 1 => Rx OK */
 phy_PathA_IQK_5G_Normal(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool		configPathB
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u32	regEAC, regE94, regEA4;
 	u8	result = 0x00;
@@ -3391,45 +3391,45 @@ phy_PathA_IQK_5G_Normal(
 
 	/* path-A IQK setting */
 
-	PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
-	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
-	PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82140307);
-	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68160960);
+	PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
+	PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
+	PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82140307);
+	PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68160960);
 
 	/* path-B IQK setting */
 	if (configPathB)
 	{
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
-		PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-		PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+		PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
 	}
 
 	/* LO calibration setting */
-	PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+	PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 
 	/* path-A PA on */
-	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x07000f60);
-	PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, 0x66e60e30);
+	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x07000f60);
+	PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, 0x66e60e30);
 
 	for (i = 0 ; i < retryCount ; i++)
 	{
 
 		/* One shot, path A LOK & IQK */
-		PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-		PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
 		/*  delay x ms */
 		rtw_mdelay_os(IQK_DELAY_TIME*10);
 
-		while (timecount < timeout && PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, BIT26) == 0x00)
+		while (timecount < timeout && PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, BIT26) == 0x00)
 		{
 			rtw_udelay_os(IQK_DELAY_TIME*1000*2);
 			timecount++;
 		}
 
 		timecount = 0;
-		while (timecount < timeout && PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, 0x3FF0000) == 0x00)
+		while (timecount < timeout && PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, 0x3FF0000) == 0x00)
 		{
 			rtw_udelay_os(IQK_DELAY_TIME*1000*2);
 			timecount++;
@@ -3437,9 +3437,9 @@ phy_PathA_IQK_5G_Normal(
 
 
 		/*  Check failed */
-		regEAC = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-		regE94 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord);
-		regEA4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
+		regEAC = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+		regE94 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord);
+		regEA4= PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
 
 		if (!(regEAC & TxOKBit) &&
 			(((regE94 & 0x03FF0000)>>16) != 0x142) )
@@ -3463,20 +3463,20 @@ phy_PathA_IQK_5G_Normal(
 	}
 
 	/* path A PA off */
-	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, pdmpriv->IQK_BB_backup[0]);
-	PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pdmpriv->IQK_BB_backup[1]);
+	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, pdmpriv->IQK_BB_backup[0]);
+	PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pdmpriv->IQK_BB_backup[1]);
 
 	if (!(result & 0x01))	/* Tx IQK fail */
 	{
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x19008c00);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x19008c00);
 	}
 
 	if (!(result & 0x02))	/* Rx IQK fail */
 	{
-		PHY_SetBBReg(pAdapter, rOFDM0_XARxIQImbalance , bMaskDWord, 0x40000100);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A , bMaskDWord, 0x19008c00);
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance , bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A , bMaskDWord, 0x19008c00);
 
-		DBG_8192D("Path A Rx IQK fail!!0xe34 = 0x%x\n", PHY_QueryBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord));
+		DBG_8192D("Path A Rx IQK fail!!0xe34 = 0x%x\n", PHY_QueryBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord));
 	}
 
 	return result;
@@ -3484,25 +3484,25 @@ phy_PathA_IQK_5G_Normal(
 
 static u8				/* bit0 = 1 => Tx OK, bit1 = 1 => Rx OK */
 phy_PathB_IQK(
-	struct rtw_adapter *	pAdapter
+	struct rtw_adapter *	adapter
 	)
 {
 	u32 regEAC, regEB4, regEBC, regEC4, regECC;
 	u8	result = 0x00;
 
 	/* One shot, path B LOK & IQK */
-	PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
-	PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
+	PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
+	PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
 
 	/*  delay x ms */
 	rtw_udelay_os(IQK_DELAY_TIME*1000);/* PlatformStallExecution(IQK_DELAY_TIME*1000); */
 
 	/*  Check failed */
-	regEAC = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-	regEB4 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord);
-	regEBC= PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord);
-	regEC4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
-	regECC= PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord);
+	regEAC = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regEB4 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord);
+	regEBC= PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord);
+	regEC4= PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
+	regECC= PHY_QueryBBReg(adapter, rRx_Power_After_IQK_B_2, bMaskDWord);
 
 	if (!(regEAC & BIT31) &&
 		(((regEB4 & 0x03FF0000)>>16) != 0x142) &&
@@ -3524,10 +3524,10 @@ phy_PathB_IQK(
 
 static u8				/* bit0 = 1 => Tx OK, bit1 = 1 => Rx OK */
 phy_PathB_IQK_5G_Normal(
-	struct rtw_adapter *	pAdapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u32	regEAC, regEB4, regEC4;
 	u8	result = 0x00;
@@ -3541,51 +3541,51 @@ phy_PathB_IQK_5G_Normal(
 
 
 	/* path-A IQK setting */
-	PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
-	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
+	PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
+	PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
 
-	PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
-	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
+	PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
+	PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
 
 	/* path-B IQK setting */
-	PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
-	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
-	PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82140307);
-	PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x68160960);
+	PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
+	PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
+	PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82140307);
+	PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68160960);
 
 	/* LO calibration setting */
-	PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+	PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 
 	/* path-B PA on */
-	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x0f600700);
-	PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, bMaskDWord, 0x061f0d30);
+	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x0f600700);
+	PHY_SetBBReg(adapter, rFPGA0_XB_RFInterfaceOE, bMaskDWord, 0x061f0d30);
 
 	for (i = 0 ; i < retryCount ; i++)
 	{
 		/* One shot, path B LOK & IQK */
-		PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xfa000000);
-		PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xfa000000);
+		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
 
 		/*  delay x ms */
 		rtw_mdelay_os(IQK_DELAY_TIME*10);
 
-		while (timecount < timeout && PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, BIT29) == 0x00) {
+		while (timecount < timeout && PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, BIT29) == 0x00) {
 			rtw_udelay_os(IQK_DELAY_TIME*1000*2);
 			timecount++;
 		}
 
 		timecount = 0;
-		while (timecount < timeout && PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, 0x3FF0000) == 0x00) {
+		while (timecount < timeout && PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, 0x3FF0000) == 0x00) {
 			rtw_udelay_os(IQK_DELAY_TIME*1000*2);
 			timecount++;
 		}
 
 
 		/*  Check failed */
-		regEAC = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-		regEB4 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord);
-		regEC4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
+		regEAC = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+		regEB4 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord);
+		regEC4= PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
 
 		if (!(regEAC & BIT31) &&
 			(((regEB4 & 0x03FF0000)>>16) != 0x142))
@@ -3605,19 +3605,19 @@ phy_PathB_IQK_5G_Normal(
 	}
 
 	/* path B PA off */
-	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, pdmpriv->IQK_BB_backup[0]);
-	PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, bMaskDWord, pdmpriv->IQK_BB_backup[2]);
+	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, pdmpriv->IQK_BB_backup[0]);
+	PHY_SetBBReg(adapter, rFPGA0_XB_RFInterfaceOE, bMaskDWord, pdmpriv->IQK_BB_backup[2]);
 
 	if (!(result & 0x01))	/* Tx IQK fail */
 	{
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x19008c00);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x19008c00);
 	}
 
 	if (!(result & 0x02))	/* Rx IQK fail */
 	{
-		PHY_SetBBReg(pAdapter, rOFDM0_XBRxIQImbalance , bMaskDWord, 0x40000100);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B , bMaskDWord, 0x19008c00);
-		DBG_8192D("Path B Rx IQK fail!!0xe54 = 0x%x\n", PHY_QueryBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord));
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance , bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_B , bMaskDWord, 0x19008c00);
+		DBG_8192D("Path B Rx IQK fail!!0xe54 = 0x%x\n", PHY_QueryBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord));
 	}
 
 	return result;
@@ -3625,7 +3625,7 @@ phy_PathB_IQK_5G_Normal(
 
 static void
 phy_PathAFillIQKMatrix(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool	bIQKOK,
 	int		result[][8],
 	u8		final_candidate,
@@ -3634,7 +3634,7 @@ phy_PathAFillIQKMatrix(
 {
 	u32	Oldval_0, X, TX0_A, reg;
 	int	Y, TX0_C;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 
 	if (final_candidate == 0xFF)
@@ -3642,17 +3642,17 @@ phy_PathAFillIQKMatrix(
 
 	else if (bIQKOK)
 	{
-		Oldval_0 = (PHY_QueryBBReg(pAdapter, rOFDM0_XATxIQImbalance, bMaskDWord) >> 22) & 0x3FF;/* OFDM0_D */
+		Oldval_0 = (PHY_QueryBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord) >> 22) & 0x3FF;/* OFDM0_D */
 
 		X = result[final_candidate][0];
 		if ((X & 0x00000200) != 0)
 			X = X | 0xFFFFFC00;
 		TX0_A = (X * Oldval_0) >> 8;
-		PHY_SetBBReg(pAdapter, rOFDM0_XATxIQImbalance, 0x3FF, TX0_A);
-		if (IS_HARDWARE_TYPE_8192D(pAdapter))
-			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT24, ((X* Oldval_0>>7) & 0x1));
+		PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, 0x3FF, TX0_A);
+		if (IS_HARDWARE_TYPE_8192D(adapter))
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT24, ((X* Oldval_0>>7) & 0x1));
 		else
-			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(31), ((X* Oldval_0>>7) & 0x1));
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT(31), ((X* Oldval_0>>7) & 0x1));
 
 		Y = result[final_candidate][1];
 		if ((Y & 0x00000200) != 0)
@@ -3663,12 +3663,12 @@ phy_PathAFillIQKMatrix(
 			Y += 3;
 
 		TX0_C = (Y * Oldval_0) >> 8;
-		PHY_SetBBReg(pAdapter, rOFDM0_XCTxAFE, 0xF0000000, ((TX0_C&0x3C0)>>6));
-		PHY_SetBBReg(pAdapter, rOFDM0_XATxIQImbalance, 0x003F0000, (TX0_C&0x3F));
-		if (IS_HARDWARE_TYPE_8192D(pAdapter)/*&&is2T*/)
-			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT26, ((Y* Oldval_0>>7) & 0x1));
+		PHY_SetBBReg(adapter, rOFDM0_XCTxAFE, 0xF0000000, ((TX0_C&0x3C0)>>6));
+		PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, 0x003F0000, (TX0_C&0x3F));
+		if (IS_HARDWARE_TYPE_8192D(adapter)/*&&is2T*/)
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT26, ((Y* Oldval_0>>7) & 0x1));
 		else
-			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(29), ((Y* Oldval_0>>7) & 0x1));
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT(29), ((Y* Oldval_0>>7) & 0x1));
 
 	        if (bTxOnly)
 		{
@@ -3676,19 +3676,19 @@ phy_PathAFillIQKMatrix(
 		}
 
 		reg = result[final_candidate][2];
-		PHY_SetBBReg(pAdapter, rOFDM0_XARxIQImbalance, 0x3FF, reg);
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance, 0x3FF, reg);
 
 		reg = result[final_candidate][3] & 0x3F;
-		PHY_SetBBReg(pAdapter, rOFDM0_XARxIQImbalance, 0xFC00, reg);
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance, 0xFC00, reg);
 
 		reg = (result[final_candidate][3] >> 6) & 0xF;
-		PHY_SetBBReg(pAdapter, rOFDM0_RxIQExtAnta, 0xF0000000, reg);
+		PHY_SetBBReg(adapter, rOFDM0_RxIQExtAnta, 0xF0000000, reg);
 	}
 }
 
 static void
 phy_PathAFillIQKMatrix_5G_Normal(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool	bIQKOK,
 	int		result[][8],
 	u8		final_candidate,
@@ -3697,7 +3697,7 @@ phy_PathAFillIQKMatrix_5G_Normal(
 {
 	u32	X, reg;
 	int	Y;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	if (bIQKOK && final_candidate != 0xFF)
 	{
@@ -3705,8 +3705,8 @@ phy_PathAFillIQKMatrix_5G_Normal(
 		if ((X & 0x00000200) != 0)
 			X = X | 0xFFFFFC00;
 
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, 0x3FF0000, X);
-		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT24, 0);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, 0x3FF0000, X);
+		PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT24, 0);
 
 		Y = result[final_candidate][1];
 		if ((Y & 0x00000200) != 0)
@@ -3716,8 +3716,8 @@ phy_PathAFillIQKMatrix_5G_Normal(
 		if (pHalData->CurrentBandType92D == BAND_ON_5G)
 			Y += 3;
 
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, 0x003FF, Y);
-		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT26, 0);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, 0x003FF, Y);
+		PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT26, 0);
 
 
 		if (bTxOnly)
@@ -3726,26 +3726,26 @@ phy_PathAFillIQKMatrix_5G_Normal(
 		}
 
 		reg = result[final_candidate][2];
-		PHY_SetBBReg(pAdapter, rOFDM0_XARxIQImbalance, 0x3FF, reg);
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance, 0x3FF, reg);
 
 		reg = result[final_candidate][3] & 0x3F;
-		PHY_SetBBReg(pAdapter, rOFDM0_XARxIQImbalance, 0xFC00, reg);
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance, 0xFC00, reg);
 
 		reg = (result[final_candidate][3] >> 6) & 0xF;
-		PHY_SetBBReg(pAdapter, rOFDM0_RxIQExtAnta, 0xF0000000, reg);
+		PHY_SetBBReg(adapter, rOFDM0_RxIQExtAnta, 0xF0000000, reg);
 	}
 	else
 	{
 		DBG_8192D("phy_PathAFillIQKMatrix Tx/Rx FAIL restore default value\n");
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x19008c00);
-		PHY_SetBBReg(pAdapter, rOFDM0_XARxIQImbalance , bMaskDWord, 0x40000100);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A , bMaskDWord, 0x19008c00);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x19008c00);
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance , bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A , bMaskDWord, 0x19008c00);
 	}
 }
 
 static void
 phy_PathBFillIQKMatrix(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool	bIQKOK,
 	int		result[][8],
 	u8		final_candidate,
@@ -3754,24 +3754,24 @@ phy_PathBFillIQKMatrix(
 {
 	u32	Oldval_1, X, TX1_A, reg;
 	int	Y, TX1_C;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
         if (final_candidate == 0xFF)
 		return;
 
 	else if (bIQKOK)
 	{
-		Oldval_1 = (PHY_QueryBBReg(pAdapter, rOFDM0_XBTxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
+		Oldval_1 = (PHY_QueryBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
 
 		X = result[final_candidate][4];
 		if ((X & 0x00000200) != 0)
 			X = X | 0xFFFFFC00;
 		TX1_A = (X * Oldval_1) >> 8;
-		PHY_SetBBReg(pAdapter, rOFDM0_XBTxIQImbalance, 0x3FF, TX1_A);
-		if (IS_HARDWARE_TYPE_8192D(pAdapter))
-			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT28, ((X* Oldval_1>>7) & 0x1));
+		PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, 0x3FF, TX1_A);
+		if (IS_HARDWARE_TYPE_8192D(adapter))
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT28, ((X* Oldval_1>>7) & 0x1));
 		else
-			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(27), ((X* Oldval_1>>7) & 0x1));
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT(27), ((X* Oldval_1>>7) & 0x1));
 
 		Y = result[final_candidate][5];
 		if ((Y & 0x00000200) != 0)
@@ -3779,30 +3779,30 @@ phy_PathBFillIQKMatrix(
 		if (pHalData->CurrentBandType92D == BAND_ON_5G)
 			Y += 3;		/* temp modify for preformance */
 		TX1_C = (Y * Oldval_1) >> 8;
-		PHY_SetBBReg(pAdapter, rOFDM0_XDTxAFE, 0xF0000000, ((TX1_C&0x3C0)>>6));
-		PHY_SetBBReg(pAdapter, rOFDM0_XBTxIQImbalance, 0x003F0000, (TX1_C&0x3F));
-		if (IS_HARDWARE_TYPE_8192D(pAdapter))
-			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT30, ((Y* Oldval_1>>7) & 0x1));
+		PHY_SetBBReg(adapter, rOFDM0_XDTxAFE, 0xF0000000, ((TX1_C&0x3C0)>>6));
+		PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, 0x003F0000, (TX1_C&0x3F));
+		if (IS_HARDWARE_TYPE_8192D(adapter))
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT30, ((Y* Oldval_1>>7) & 0x1));
 		else
-			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(25), ((Y* Oldval_1>>7) & 0x1));
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT(25), ((Y* Oldval_1>>7) & 0x1));
 
 		if (bTxOnly)
 			return;
 
 		reg = result[final_candidate][6];
-		PHY_SetBBReg(pAdapter, rOFDM0_XBRxIQImbalance, 0x3FF, reg);
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance, 0x3FF, reg);
 
 		reg = result[final_candidate][7] & 0x3F;
-		PHY_SetBBReg(pAdapter, rOFDM0_XBRxIQImbalance, 0xFC00, reg);
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance, 0xFC00, reg);
 
 		reg = (result[final_candidate][7] >> 6) & 0xF;
-		PHY_SetBBReg(pAdapter, rOFDM0_AGCRSSITable, 0x0000F000, reg);
+		PHY_SetBBReg(adapter, rOFDM0_AGCRSSITable, 0x0000F000, reg);
 	}
 }
 
 static void
 phy_PathBFillIQKMatrix_5G_Normal(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool	bIQKOK,
 	int		result[][8],
 	u8		final_candidate,
@@ -3811,7 +3811,7 @@ phy_PathBFillIQKMatrix_5G_Normal(
 {
 	u32	X, reg;
 	int	Y;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	if (bIQKOK && final_candidate != 0xFF)
 	{
@@ -3819,8 +3819,8 @@ phy_PathBFillIQKMatrix_5G_Normal(
 		if ((X & 0x00000200) != 0)
 			X = X | 0xFFFFFC00;
 
-		PHY_SetBBReg(pAdapter, 0xe50, 0x3FF0000, X);
-		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT28, 0);
+		PHY_SetBBReg(adapter, 0xe50, 0x3FF0000, X);
+		PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT28, 0);
 
 		Y = result[final_candidate][5];
 		if ((Y & 0x00000200) != 0)
@@ -3828,33 +3828,33 @@ phy_PathBFillIQKMatrix_5G_Normal(
 		if (pHalData->CurrentBandType92D == BAND_ON_5G)
 			Y += 3;		/* temp modify for preformance, suggest by Jenyu */
 
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, 0x003FF, Y);
-		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, 0x003FF, Y);
+		PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT30, 0);
 
 		if (bTxOnly)
 			return;
 
 		reg = result[final_candidate][6];
-		PHY_SetBBReg(pAdapter, rOFDM0_XBRxIQImbalance, 0x3FF, reg);
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance, 0x3FF, reg);
 
 		reg = result[final_candidate][7] & 0x3F;
-		PHY_SetBBReg(pAdapter, rOFDM0_XBRxIQImbalance, 0xFC00, reg);
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance, 0xFC00, reg);
 
 		reg = (result[final_candidate][7] >> 6) & 0xF;
-		PHY_SetBBReg(pAdapter, rOFDM0_AGCRSSITable, 0x0000F000, reg);
+		PHY_SetBBReg(adapter, rOFDM0_AGCRSSITable, 0x0000F000, reg);
 	}
 	else
 	{
 		DBG_8192D("phy_PathBFillIQKMatrix Tx/Rx FAIL\n");
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x19008c00);
-		PHY_SetBBReg(pAdapter, rOFDM0_XBRxIQImbalance , bMaskDWord, 0x40000100);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B , bMaskDWord, 0x19008c00);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x19008c00);
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance , bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_B , bMaskDWord, 0x19008c00);
 	}
 }
 
 static void
 phy_SaveADDARegisters(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u32*		ADDAReg,
 	u32*		ADDABackup,
 	u32			RegisterNum
@@ -3863,13 +3863,13 @@ phy_SaveADDARegisters(
 	u32	i;
 
 	for (i = 0 ; i < RegisterNum ; i++) {
-		ADDABackup[i] = PHY_QueryBBReg(pAdapter, ADDAReg[i], bMaskDWord);
+		ADDABackup[i] = PHY_QueryBBReg(adapter, ADDAReg[i], bMaskDWord);
 	}
 }
 
 static void
 phy_SaveMACRegisters(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u32*		MACReg,
 	u32*		MACBackup
 	)
@@ -3877,14 +3877,14 @@ phy_SaveMACRegisters(
 	u32	i;
 
 	for (i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++) {
-		MACBackup[i] = rtw_read8(pAdapter, MACReg[i]);
+		MACBackup[i] = rtw_read8(adapter, MACReg[i]);
 	}
-	MACBackup[i] = rtw_read32(pAdapter, MACReg[i]);
+	MACBackup[i] = rtw_read32(adapter, MACReg[i]);
 }
 
 static void
 phy_ReloadADDARegisters(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u32*		ADDAReg,
 	u32*		ADDABackup,
 	u32			RegiesterNum
@@ -3895,14 +3895,14 @@ phy_ReloadADDARegisters(
 	for (i = 0 ; i < RegiesterNum ; i++) {
 		/* path-A/B BB to initial gain */
 		if (ADDAReg[i] == rOFDM0_XAAGCCore1 || ADDAReg[i] == rOFDM0_XBAGCCore1)
-			PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, 0x50);
-		PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, ADDABackup[i]);
+			PHY_SetBBReg(adapter, ADDAReg[i], bMaskDWord, 0x50);
+		PHY_SetBBReg(adapter, ADDAReg[i], bMaskDWord, ADDABackup[i]);
 	}
 }
 
 static void
 phy_ReloadMACRegisters(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u32*		MACReg,
 	u32*		MACBackup
 	)
@@ -3910,20 +3910,20 @@ phy_ReloadMACRegisters(
 	u32	i;
 
 	for (i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++) {
-		rtw_write8(pAdapter, MACReg[i], (u8)MACBackup[i]);
+		rtw_write8(adapter, MACReg[i], (u8)MACBackup[i]);
 	}
-	rtw_write32(pAdapter, MACReg[i], MACBackup[i]);
+	rtw_write32(adapter, MACReg[i], MACBackup[i]);
 }
 
 static void
 phy_PathADDAOn(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u32*		ADDAReg,
 	bool		isPathAOn,
 	bool		is2T
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u32	pathOn;
 	u32	i;
 
@@ -3935,13 +3935,13 @@ phy_PathADDAOn(
 		pathOn = pHalData->interfaceIndex == 0? 0x04db25a4 : 0x0b1b25a4;
 
 	for (i = 0 ; i < IQK_ADDA_REG_NUM ; i++) {
-		PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, pathOn);
+		PHY_SetBBReg(adapter, ADDAReg[i], bMaskDWord, pathOn);
 	}
 }
 
 static void
 phy_MACSettingCalibration(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u32*		MACReg,
 	u32*		MACBackup
 	)
@@ -3949,28 +3949,28 @@ phy_MACSettingCalibration(
 	u32	i = 0;
 
 
-	rtw_write8(pAdapter, MACReg[i], 0x3F);
+	rtw_write8(adapter, MACReg[i], 0x3F);
 
 	for (i = 1 ; i < (IQK_MAC_REG_NUM - 1); i++) {
-		rtw_write8(pAdapter, MACReg[i], (u8)(MACBackup[i]&(~BIT3)));
+		rtw_write8(adapter, MACReg[i], (u8)(MACBackup[i]&(~BIT3)));
 	}
-	rtw_write8(pAdapter, MACReg[i], (u8)(MACBackup[i]&(~BIT5)));
+	rtw_write8(adapter, MACReg[i], (u8)(MACBackup[i]&(~BIT5)));
 }
 
 static void
 phy_PathAStandBy(
-	struct rtw_adapter *	pAdapter
+	struct rtw_adapter *	adapter
 	)
 {
 
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x0);
-	PHY_SetBBReg(pAdapter, 0x840, bMaskDWord, 0x00010000);
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x0);
+	PHY_SetBBReg(adapter, 0x840, bMaskDWord, 0x00010000);
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
 }
 
 static void
 phy_PIModeSwitch(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool		PIMode
 	)
 {
@@ -3978,20 +3978,20 @@ phy_PIModeSwitch(
 
 
 	mode = PIMode ? 0x01000100 : 0x01000000;
-	PHY_SetBBReg(pAdapter, 0x820, bMaskDWord, mode);
-	PHY_SetBBReg(pAdapter, 0x828, bMaskDWord, mode);
+	PHY_SetBBReg(adapter, 0x820, bMaskDWord, mode);
+	PHY_SetBBReg(adapter, 0x828, bMaskDWord, mode);
 }
 
 static bool
 phy_SimularityCompare_92D(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	int		result[][8],
 	u8		 c1,
 	u8		 c2
 	)
 {
 	u32	i, j, diff, SimularityBitMap, bound = 0, u4temp = 0;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	final_candidate[2] = {0xFF, 0xFF};	/* for path A and path B */
 	bool		bResult = true;
 	bool		is2T = IS_92D_SINGLEPHY(pHalData->VersionID);
@@ -4075,24 +4075,24 @@ return false => do IQK again
 */
 static bool
 phy_SimularityCompare(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	int		result[][8],
 	u8		 c1,
 	u8		 c2
 	)
 {
-	return phy_SimularityCompare_92D(pAdapter, result, c1, c2);
+	return phy_SimularityCompare_92D(adapter, result, c1, c2);
 }
 
 static void
 phy_IQCalibrate(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	int		result[][8],
 	u8		t,
 	bool		is2T
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u32			i;
 	u8			PathAOK, PathBOK;
@@ -4135,89 +4135,89 @@ phy_IQCalibrate(
 	/* 		PHY_REG.txt , and radio_a, radio_b.txt */
 	if (t == 0) {
 		/*  Save ADDA parameters, turn Path A ADDA on */
-		phy_SaveADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
-		phy_SaveMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
-		if (IS_HARDWARE_TYPE_8192D(pAdapter))
-			phy_SaveADDARegisters(pAdapter, IQK_BB_REG_92D, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
+		phy_SaveADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+		phy_SaveMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+		if (IS_HARDWARE_TYPE_8192D(adapter))
+			phy_SaveADDARegisters(adapter, IQK_BB_REG_92D, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
 		else
-			phy_SaveADDARegisters(pAdapter, IQK_BB_REG_92C, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92C);
+			phy_SaveADDARegisters(adapter, IQK_BB_REG_92C, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92C);
 	}
 
-	phy_PathADDAOn(pAdapter, ADDA_REG, true, is2T);
+	phy_PathADDAOn(adapter, ADDA_REG, true, is2T);
 
-	if (IS_HARDWARE_TYPE_8192D(pAdapter))
-		PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x01017038);
+	if (IS_HARDWARE_TYPE_8192D(adapter))
+		PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x01017038);
 
 	if (t==0)
-		pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
+		pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter1, BIT(8));
 
 	if (!pdmpriv->bRfPiEnable) {
 		/*  Switch BB to PI mode to do IQ Calibration. */
-		phy_PIModeSwitch(pAdapter, true);
+		phy_PIModeSwitch(adapter, true);
 	}
 
-	PHY_SetBBReg1Byte(pAdapter, rFPGA0_RFMOD, BIT24, 0x00);
-	PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
-	PHY_SetBBReg(pAdapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
-	PHY_SetBBReg(pAdapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22204000);
-	if (IS_HARDWARE_TYPE_8192D(pAdapter))
-		PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xf00000, 0x0f);
+	PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, BIT24, 0x00);
+	PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
+	PHY_SetBBReg(adapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
+	PHY_SetBBReg(adapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22204000);
+	if (IS_HARDWARE_TYPE_8192D(adapter))
+		PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xf00000, 0x0f);
 	else
 	{
-		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT10, 0x01);
-		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT26, 0x01);
-		PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, BIT10, 0x00);
-		PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, BIT10, 0x00);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT10, 0x01);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT26, 0x01);
+		PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, BIT10, 0x00);
+		PHY_SetBBReg(adapter, rFPGA0_XB_RFInterfaceOE, BIT10, 0x00);
 	}
 
 	if (is2T)
 	{
-		PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00010000);
-		PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00010000);
+		PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00010000);
+		PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00010000);
 	}
 
 	/* MAC settings */
-	phy_MACSettingCalibration(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+	phy_MACSettingCalibration(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
-	if (IS_HARDWARE_TYPE_8192D(pAdapter))
+	if (IS_HARDWARE_TYPE_8192D(adapter))
 	{
-		PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x0f600000);
+		PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x0f600000);
 
 		if (is2T)
 		{
-			PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x0f600000);
+			PHY_SetBBReg(adapter, rConfig_AntB, bMaskDWord, 0x0f600000);
 		}
 	}
 	else
 	{
 		/* Page B init */
-		PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x00080000);
+		PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x00080000);
 
 		if (is2T)
 		{
-			PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x00080000);
+			PHY_SetBBReg(adapter, rConfig_AntB, bMaskDWord, 0x00080000);
 		}
 	}
 
 	/*  IQ calibration setting */
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
-	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x01007c00);
-	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, 0x01007c00);
+	PHY_SetBBReg(adapter, rRx_IQK, bMaskDWord, 0x01004800);
 
 	for (i = 0 ; i < retryCount ; i++) {
-		PathAOK = phy_PathA_IQK(pAdapter, is2T);
+		PathAOK = phy_PathA_IQK(adapter, is2T);
 		if (PathAOK == 0x03) {
-			result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-			result[t][2] = (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
-			result[t][3] = (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+			result[t][0] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][1] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][2] = (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+			result[t][3] = (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
 			break;
 		}
 		else if (i == (retryCount-1) && PathAOK == 0x01)	/* Tx IQK OK */
 		{
 
-			result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][0] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][1] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 		}
 	}
 
@@ -4226,24 +4226,24 @@ phy_IQCalibrate(
 	}
 
 	if (is2T) {
-		phy_PathAStandBy(pAdapter);
+		phy_PathAStandBy(adapter);
 
 		/*  Turn Path B ADDA on */
-		phy_PathADDAOn(pAdapter, ADDA_REG, false, is2T);
+		phy_PathADDAOn(adapter, ADDA_REG, false, is2T);
 
 		for (i = 0 ; i < retryCount ; i++) {
-			PathBOK = phy_PathB_IQK(pAdapter);
+			PathBOK = phy_PathB_IQK(adapter);
 			if (PathBOK == 0x03) {
-				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
-				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
-				result[t][6] = (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
-				result[t][7] = (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+				result[t][4] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][6] = (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+				result[t][7] = (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
 				break;
 			}
 			else if (i == (retryCount - 1) && PathBOK == 0x01)	/* Tx IQK OK */
 			{
-				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
-				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][4] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 			}
 		}
 
@@ -4254,44 +4254,44 @@ phy_IQCalibrate(
 
 	/* Back to BB mode, load original value */
 	/* RTPRINT(FINIT, INIT_IQK, ("IQK:Back to BB mode, load original value!\n")); */
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0);
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0);
 
 	if (t!=0)
 	{
 		if (!pdmpriv->bRfPiEnable) {
 			/*  Switch back BB to SI mode after finish IQ Calibration. */
-			phy_PIModeSwitch(pAdapter, false);
+			phy_PIModeSwitch(adapter, false);
 		}
 
 		/*  Reload ADDA power saving parameters */
-		phy_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+		phy_ReloadADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 
 		/*  Reload MAC parameters */
-		phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+		phy_ReloadMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 		/*  Reload BB parameters */
-		if (IS_HARDWARE_TYPE_8192D(pAdapter))
+		if (IS_HARDWARE_TYPE_8192D(adapter))
 		{
 			if (is2T)
-				phy_ReloadADDARegisters(pAdapter, IQK_BB_REG_92D, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
+				phy_ReloadADDARegisters(adapter, IQK_BB_REG_92D, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
 			else
-				phy_ReloadADDARegisters(pAdapter, IQK_BB_REG_92D, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D -1);
+				phy_ReloadADDARegisters(adapter, IQK_BB_REG_92D, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D -1);
 		}
 		else
-			phy_ReloadADDARegisters(pAdapter, IQK_BB_REG_92C, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92C);
+			phy_ReloadADDARegisters(adapter, IQK_BB_REG_92C, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92C);
 
-		if (!IS_HARDWARE_TYPE_8192D(pAdapter))
+		if (!IS_HARDWARE_TYPE_8192D(adapter))
 		{
 			/*  Restore RX initial gain */
-			PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032ed3);
+			PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032ed3);
 			if (is2T) {
-				PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032ed3);
+				PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032ed3);
 			}
 		}
 
 		/* load 0xe30 IQC default value */
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);
 
 	}
 }
@@ -4299,11 +4299,11 @@ phy_IQCalibrate(
 
 static void
 phy_IQCalibrate_5G(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	int		result[][8]
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u32			extPAon, REG0xe5c, RX0REG0xe40, REG0xe40, REG0xe94;
 	u32			REG0xeac, RX1REG0xe40, REG0xeb4, REG0xea4,REG0xec4;
@@ -4336,97 +4336,97 @@ phy_IQCalibrate_5G(
 	DBG_8192D("IQ Calibration for %s\n", (is2T ? "2T2R" : "1T1R"));
 
 	/* Save MAC default value */
-	phy_SaveMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+	phy_SaveMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 	/* Save BB Parameter */
-	phy_SaveADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_test);
+	phy_SaveADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_test);
 
 	/* Save AFE Parameters */
-	phy_SaveADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+	phy_SaveADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 
 	/* 1 Path-A TX IQK */
 	/* Path-A AFE all on */
-	phy_PathADDAOn(pAdapter, ADDA_REG, true, true);
+	phy_PathADDAOn(adapter, ADDA_REG, true, true);
 
 	/* MAC register setting */
-	phy_MACSettingCalibration(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+	phy_MACSettingCalibration(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 	/* IQK must be done in PI mode */
-	pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
+	pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter1, BIT(8));
 	if (!pdmpriv->bRfPiEnable)
-		phy_PIModeSwitch(pAdapter, true);
+		phy_PIModeSwitch(adapter, true);
 
 	/* TXIQK RF setting */
-	PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01940000);
-	PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01940000);
+	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01940000);
+	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01940000);
 
 	/* BB setting */
-	PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
-	PHY_SetBBReg(pAdapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
-	PHY_SetBBReg(pAdapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
-	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT6|BIT5,  0x03);
-	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT22|BIT21,  0x03);
-	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xf00000,  0x0f);
+	PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
+	PHY_SetBBReg(adapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
+	PHY_SetBBReg(adapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
+	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT6|BIT5,  0x03);
+	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT22|BIT21,  0x03);
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xf00000,  0x0f);
 
 	/* AP or IQK */
-	PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x0f600000);
-	PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x0f600000);
+	PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x0f600000);
+	PHY_SetBBReg(adapter, rConfig_AntB, bMaskDWord, 0x0f600000);
 
 	/* IQK global setting */
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
-	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x10007c00);
-	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, 0x10007c00);
+	PHY_SetBBReg(adapter, rRx_IQK, bMaskDWord, 0x01004800);
 
 	/* path-A IQK setting */
 	if (pHalData->interfaceIndex == 0)
 	{
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c1f);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c1f);
 	}
 	else
 	{
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c22);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c22);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c22);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c22);
 	}
 
 	if (is2T)
-		PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x821402e2);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x821402e2);
 	else
-		PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x821402e6);
-	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x821402e6);
+	PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
 
 	/* path-B IQK setting */
 	if (is2T)
 	{
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x30008c22);
-		PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-		PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x30008c22);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+		PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
 	}
 
 	/* LO calibration setting */
-	PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+	PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 
 
 	/* One shot, path A LOK & IQK */
-	PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-	PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+	PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
 	/* Delay 1 ms */
 	rtw_udelay_os(IQK_DELAY_TIME*1000);
 
 	/* Exit IQK mode */
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 
 	/* Check_TX_IQK_A_result() */
-	REG0xe40 = PHY_QueryBBReg(pAdapter, rTx_IQK, bMaskDWord);
-	REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-	REG0xe94 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord);
+	REG0xe40 = PHY_QueryBBReg(adapter, rTx_IQK, bMaskDWord);
+	REG0xeac = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	REG0xe94 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord);
 
 	if (((REG0xeac&BIT(28)) == 0) && (((REG0xe94&0x3FF0000)>>16)!=0x142))
 	{
-		TX_X0 = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-		TX_Y0 = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+		TX_X0 = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+		TX_Y0 = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 		RX0REG0xe40 =  0x80000000 | (REG0xe40 & 0xfc00fc00) | (TX_X0<<16) | TX_Y0;
 		result[0][0] = TX_X0;
 		result[0][1] = TX_Y0;
@@ -4445,69 +4445,69 @@ phy_IQCalibrate_5G(
 		DBG_8192D("IQK for 5G: Path A Rx  START interface %u\n", pHalData->interfaceIndex);
 
 		/* TXIQK RF setting */
-		PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
-		PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
+		PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
+		PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
 
 		/* turn on external PA */
 		if (pHalData->interfaceIndex == 1)
-			PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT(30), 0x01);
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT(30), 0x01);
 
 		/* IQK global setting */
-		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+		PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
 
 		/* path-A IQK setting */
 		if (pHalData->interfaceIndex == 0)
 		{
-			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
-			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
+			PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
+			PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
 		}
 		else
 		{
-			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c22);
-			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x14008c22);
+			PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c22);
+			PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x14008c22);
 		}
-		PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
 		if (pHalData->interfaceIndex == 0)
-			PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, (pHalData->CurrentChannel<=140)?0x68160c62:0x68160c66);
+			PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, (pHalData->CurrentChannel<=140)?0x68160c62:0x68160c66);
 		else
-			PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68160962);
+			PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68160962);
 
 		/* path-B IQK setting */
 		if (is2T)
 		{
-			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
-			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x14008c22);
-			PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-			PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
+			PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
+			PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x14008c22);
+			PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+			PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
 		}
 
 		/* load TX0 IMR setting */
-		PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, RX0REG0xe40);
+		PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, RX0REG0xe40);
 		/* Sleep(5) -> delay 1ms */
 		rtw_udelay_os(IQK_DELAY_TIME*1000);
 
 		/* LO calibration setting */
-		PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
+		PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
 
 		/* One shot, path A LOK & IQK */
-		PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-		PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
 		/* Delay 3 ms */
 		rtw_udelay_os(3*IQK_DELAY_TIME*1000);
 
 		/* Exit IQK mode */
-		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+		PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 
 		/* Check_RX_IQK_A_result() */
-		REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-		REG0xea4 = PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
+		REG0xeac = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+		REG0xea4 = PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
 		if (pHalData->interfaceIndex == 0)
 		{
 			if (((REG0xeac&BIT(27)) == 0) && (((REG0xea4&0x3FF0000)>>16)!=0x132))
 			{
-				RX_X0 =  (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
-				RX_Y0 =  (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				RX_X0 =  (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				RX_Y0 =  (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
 				result[0][2] = RX_X0;
 				result[0][3] = RX_Y0;
 			}
@@ -4516,8 +4516,8 @@ phy_IQCalibrate_5G(
 		{
 			if (((REG0xeac&BIT(30)) == 0) && (((REG0xea4&0x3FF0000)>>16)!=0x132))
 			{
-				RX_X0 =  (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
-				RX_Y0 =  (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				RX_X0 =  (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				RX_Y0 =  (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
 				result[0][2] = RX_X0;
 				result[0][3] = RX_Y0;
 			}
@@ -4532,49 +4532,49 @@ phy_IQCalibrate_5G(
 
 	DBG_8192D("IQK for 5G: Path B Tx  START interface %u\n", pHalData->interfaceIndex);
 
-	phy_PathADDAOn(pAdapter, ADDA_REG, false, true);
+	phy_PathADDAOn(adapter, ADDA_REG, false, true);
 
 	/* TXIQK RF setting */
-	PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01940000);
-	PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01940000);
+	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01940000);
+	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01940000);
 
 	/* IQK global setting */
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
-	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x10007c00);
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, 0x10007c00);
 
 	/* path-A IQK setting */
-	PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
-	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c1f);
-	PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
-	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
+	PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
+	PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c1f);
+	PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
+	PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
 
 	/* path-B IQK setting */
-	PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
-	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x30008c22);
-	PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82140386);
-	PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
+	PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
+	PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x30008c22);
+	PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82140386);
+	PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
 
 	/* LO calibration setting */
-	PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+	PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 
 	/* One shot, path A LOK & IQK */
-	PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
-	PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
+	PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
+	PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
 
 	/* Delay 1 ms */
 	rtw_udelay_os(IQK_DELAY_TIME*1000);
 
 	/* Exit IQK mode */
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 
 	/*  Check_TX_IQK_B_result() */
-	REG0xe40 = PHY_QueryBBReg(pAdapter, rTx_IQK, bMaskDWord);
-	REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-	REG0xeb4 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord);
+	REG0xe40 = PHY_QueryBBReg(adapter, rTx_IQK, bMaskDWord);
+	REG0xeac = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	REG0xeb4 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord);
 	if (((REG0xeac&BIT(31)) == 0) && ((REG0xeb4&0x3FF0000)!=0x142))
 	{
-		TX_X1 = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
-		TX_Y1 = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+		TX_X1 = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+		TX_Y1 = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 		RX1REG0xe40 = 0x80000000 | (REG0xe40 & 0xfc00fc00) | (TX_X1<<16) | TX_Y1;
 		result[0][4] = TX_X1;
 		result[0][5] = TX_Y1;
@@ -4599,53 +4599,53 @@ phy_IQCalibrate_5G(
 		}
 
 		/* TXIQK RF setting */
-		PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
-		PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
+		PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
+		PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
 
 		/* turn on external PA */
-		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT(30), extPAon);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT(30), extPAon);
 
 		/* BB setting */
-		PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, bMaskDWord, 0xcc300080);
+		PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, bMaskDWord, 0xcc300080);
 
 		/* IQK global setting */
-		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+		PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
 
 		/* path-A IQK setting */
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x34008c1f);
-		PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
-		PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x34008c1f);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
+		PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
 
 		/* path-B IQK setting */
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x14008c22);
-		PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-		PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, REG0xe5c);
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x14008c22);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+		PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, REG0xe5c);
 
 		/* load TX0 IMR setting */
-		PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, RX1REG0xe40);
+		PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, RX1REG0xe40);
 
 		/* Sleep(5) -> delay 1ms */
 		rtw_udelay_os(IQK_DELAY_TIME*1000);
 
 		/* LO calibration setting */
-		PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
+		PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
 
 		/* One shot, path A LOK & IQK */
-		PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
-		PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
+		PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
+		PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
 
 		/* Delay 1 ms */
 		rtw_udelay_os(3*IQK_DELAY_TIME*1000);
 
 		/* Check_RX_IQK_B_result() */
-		REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-		REG0xec4 = PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
+		REG0xeac = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+		REG0xec4 = PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
 		if (((REG0xeac&BIT(30)) == 0) && (((REG0xec4&0x3FF0000)>>16)!=0x132))
 		{
-			RX_X1 =  (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
-			RX_Y1 =  (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+			RX_X1 =  (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+			RX_Y1 =  (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
 			result[0][6] = RX_X1;
 			result[0][7] = RX_Y1;
 		}
@@ -4654,35 +4654,35 @@ phy_IQCalibrate_5G(
 Exit_IQK:
 	/* turn off external PA */
 	if (pHalData->interfaceIndex == 1 || is2T)
-		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT(30), 0);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT(30), 0);
 
 	/* Exit IQK mode */
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
-	phy_ReloadADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_test);
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+	phy_ReloadADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_test);
 
-	PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
-	PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
-	PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032fff);
-	PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032fff);
+	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
+	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
+	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032fff);
+	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032fff);
 
 
 	/* reload MAC default value */
-	phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+	phy_ReloadMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 	if (!pdmpriv->bRfPiEnable)
-		phy_PIModeSwitch(pAdapter, false);
+		phy_PIModeSwitch(adapter, false);
 	/* Reload ADDA power saving parameters */
-	phy_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+	phy_ReloadADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 }
 
 static void
 phy_IQCalibrate_5G_Normal(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	int		result[][8],
 	u8		t
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u32			PathAOK, PathBOK;
 	u32			ADDA_REG[IQK_ADDA_REG_NUM] = {
@@ -4719,86 +4719,86 @@ phy_IQCalibrate_5G_Normal(
 
 	if (t==0) {
 		/*  Save ADDA parameters, turn Path A ADDA on */
-		phy_SaveADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
-		phy_SaveMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+		phy_SaveADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+		phy_SaveMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 		if (is2T)
-			phy_SaveADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
+			phy_SaveADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
 		else
-			phy_SaveADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D-1);
+			phy_SaveADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D-1);
 	}
 
 	/*  */
 	/* 3 Path Diversity */
 	/* Path-A AFE all on */
 	/* Neil Chen--2011--05--19 */
-	rfPathDiv =(u8) (PHY_QueryBBReg(pAdapter, 0xB30, bMaskDWord)>>27);
+	rfPathDiv =(u8) (PHY_QueryBBReg(adapter, 0xB30, bMaskDWord)>>27);
 
 	if ((rfPathDiv&0x01)==1)   /*  Div on */
 	{
-		phy_PathADDAOn(pAdapter, ADDA_REG, false, is2T);
+		phy_PathADDAOn(adapter, ADDA_REG, false, is2T);
 	}
 	else
-		phy_PathADDAOn(pAdapter, ADDA_REG, true, is2T);
+		phy_PathADDAOn(adapter, ADDA_REG, true, is2T);
 	/* 3 end */
        /*  */
 
 	/* Path-A AFE all on */
 
 	/* MAC settings */
-	phy_MACSettingCalibration(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+	phy_MACSettingCalibration(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 	if (t==0)
 	{
-		pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
+		pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter1, BIT(8));
 	}
 
 	if (!pdmpriv->bRfPiEnable) {
 		/*  Switch BB to PI mode to do IQ Calibration. */
-		phy_PIModeSwitch(pAdapter, true);
+		phy_PIModeSwitch(adapter, true);
 	}
 
-	PHY_SetBBReg1Byte(pAdapter, rFPGA0_RFMOD, BIT24, 0x00);
-	PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
-	PHY_SetBBReg(pAdapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
-	PHY_SetBBReg(pAdapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
-	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xf00000, 0x0f);
+	PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, BIT24, 0x00);
+	PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
+	PHY_SetBBReg(adapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
+	PHY_SetBBReg(adapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xf00000, 0x0f);
 
 	/* Page A AP setting for IQK */
-	PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x00000000);
-	PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x20000000);
+	PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x00000000);
+	PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x20000000);
 
 	/* Page B AP setting for IQK */
 	if (is2T) {
-		PHY_SetBBReg(pAdapter, rPdp_AntB, bMaskDWord, 0x00000000);
-		PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x20000000);
+		PHY_SetBBReg(adapter, rPdp_AntB, bMaskDWord, 0x00000000);
+		PHY_SetBBReg(adapter, rConfig_AntB, bMaskDWord, 0x20000000);
 	}
 	/*  IQ calibration setting */
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
-	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x10007c00);
-	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, 0x10007c00);
+	PHY_SetBBReg(adapter, rRx_IQK, bMaskDWord, 0x01004800);
 
 	{
-		PathAOK = phy_PathA_IQK_5G_Normal(pAdapter, is2T);
+		PathAOK = phy_PathA_IQK_5G_Normal(adapter, is2T);
 		if (PathAOK == 0x03) {
 			DBG_8192D("Path A IQK Success!!\n");
-			result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-			result[t][2] = (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
-			result[t][3] = (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+			result[t][0] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][1] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][2] = (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+			result[t][3] = (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
 		}
 		else if (PathAOK == 0x01)	/* Tx IQK OK */
 		{
 			DBG_8192D("Path A IQK Only  Tx Success!!\n");
 
-			result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][0] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][1] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 		}
 		else
 		{
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0);
-			DBG_8192D("0xe70 = 0x%x\n", PHY_QueryBBReg(pAdapter, rRx_Wait_CCA, bMaskDWord));
-			DBG_8192D("RF path A 0x0 = 0x%x\n", PHY_QueryRFReg(pAdapter, RF_PATH_A, RF_AC, bRFRegOffsetMask));
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+			PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0);
+			DBG_8192D("0xe70 = 0x%x\n", PHY_QueryBBReg(adapter, rRx_Wait_CCA, bMaskDWord));
+			DBG_8192D("RF path A 0x0 = 0x%x\n", PHY_QueryRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask));
+			PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
 			DBG_8192D("Path A IQK Fail!!\n");
 		}
 	}
@@ -4806,22 +4806,22 @@ phy_IQCalibrate_5G_Normal(
 	if (is2T) {
 
 		/*  Turn Path B ADDA on */
-		phy_PathADDAOn(pAdapter, ADDA_REG, false, is2T);
+		phy_PathADDAOn(adapter, ADDA_REG, false, is2T);
 
 		{
-			PathBOK = phy_PathB_IQK_5G_Normal(pAdapter);
+			PathBOK = phy_PathB_IQK_5G_Normal(adapter);
 			if (PathBOK == 0x03) {
 				DBG_8192D("Path B IQK Success!!\n");
-				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
-				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
-				result[t][6] = (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
-				result[t][7] = (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+				result[t][4] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][6] = (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+				result[t][7] = (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
 			}
 			else if (PathBOK == 0x01)	/* Tx IQK OK */
 			{
 				DBG_8192D("Path B Only Tx IQK Success!!\n");
-				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
-				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][4] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 			}
 			else {
 				DBG_8192D("Path B IQK failed!!\n");
@@ -4830,39 +4830,39 @@ phy_IQCalibrate_5G_Normal(
 	}
 
 	/* Back to BB mode, load original value */
-	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0);
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0);
 
 	if (t!=0)
 	{
 		if (is2T)
-			phy_ReloadADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
+			phy_ReloadADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
 		else
-			phy_ReloadADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D-1);
+			phy_ReloadADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D-1);
 
 		/* path A IQ path to DP block */
-		PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x010170b8);
+		PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x010170b8);
 
 		/* path B IQ path to DP block */
 		if (is2T)
-			PHY_SetBBReg(pAdapter, rPdp_AntB, bMaskDWord, 0x010170b8);
+			PHY_SetBBReg(adapter, rPdp_AntB, bMaskDWord, 0x010170b8);
 
 		/*  Reload MAC parameters */
-		phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+		phy_ReloadMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 		if (!pdmpriv->bRfPiEnable) {
 			/*  Switch back BB to SI mode after finish IQ Calibration. */
-			phy_PIModeSwitch(pAdapter, false);
+			phy_PIModeSwitch(adapter, false);
 		}
 
 		/*  Reload ADDA power saving parameters */
-		phy_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+		phy_ReloadADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 	}
 }
 
 #if SWLCK != 1
 static void
 phy_LCCalibrate92D(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool		is2T
 	)
 {
@@ -4874,35 +4874,35 @@ phy_LCCalibrate92D(
 #endif
 
 	/* Check continuous TX and Packet TX */
-	tmpReg = rtw_read8(pAdapter, 0xd03);
+	tmpReg = rtw_read8(adapter, 0xd03);
 
 	if ((tmpReg&0x70) != 0)			/* Deal with contisuous TX case */
-		rtw_write8(pAdapter, 0xd03, tmpReg&0x8F);	/* disable all continuous TX */
+		rtw_write8(adapter, 0xd03, tmpReg&0x8F);	/* disable all continuous TX */
 	else							/*  Deal with Packet TX case */
-		rtw_write8(pAdapter, REG_TXPAUSE, 0xFF);			/*  block all queues */
+		rtw_write8(adapter, REG_TXPAUSE, 0xFF);			/*  block all queues */
 
-	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xF00000, 0x0F);
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xF00000, 0x0F);
 
 	for (index = 0; index <path; index ++)
 	{
 		/* 1. Read original RF mode */
-		RF_mode[index] = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_AC, bRFRegOffsetMask);
+		RF_mode[index] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_AC, bRFRegOffsetMask);
 
 		/* 2. Set RF mode = standby mode */
-		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_AC, 0x70000, 0x01);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_AC, 0x70000, 0x01);
 
-		tmpu4Byte[index] = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask);
-		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, 0x700, 0x07);
+		tmpu4Byte[index] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, 0x700, 0x07);
 
 		/* 4. Set LC calibration begin */
-		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_CHNLBW, 0x08000, 0x01);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_CHNLBW, 0x08000, 0x01);
 
 	}
 
 #if SWLCK == 1
 	for (index = 0; index <path; index ++)
 	{
-		while (!(PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G6, BIT11)) &&
+		while (!(PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G6, BIT11)) &&
 			timecount <= timeout)
 		{
 
@@ -4925,21 +4925,21 @@ phy_LCCalibrate92D(
 	/* Restore original situation */
 	for (index = 0; index <path; index ++)
 	{
-		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask, tmpu4Byte[index]);
-		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_AC, bRFRegOffsetMask, RF_mode[index]);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask, tmpu4Byte[index]);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_AC, bRFRegOffsetMask, RF_mode[index]);
 	}
 
 	if ((tmpReg&0x70) != 0)
 	{
 		/* Path-A */
-		rtw_write8(pAdapter, 0xd03, tmpReg);
+		rtw_write8(adapter, 0xd03, tmpReg);
 	}
 	else /*  Deal with Packet TX case */
 	{
-		rtw_write8(pAdapter, REG_TXPAUSE, 0x00);
+		rtw_write8(adapter, REG_TXPAUSE, 0x00);
 	}
 
-	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xF00000, 0x00);
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xF00000, 0x00);
 }
 #endif  /* SWLCK != 1, amy, temp remove */
 
@@ -4968,7 +4968,7 @@ get_abs(
 
 static void
 phy_CalcCurvIndex(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u32*		TargetChnl,
 	u32*		CurveCountVal,
 	bool		is5G,
@@ -5037,7 +5037,7 @@ phy_CalcCurvIndex(
 
 static void
 phy_LCCalibrate92DSW(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool		is2T
 	)
 {
@@ -5045,50 +5045,50 @@ phy_LCCalibrate92DSW(
 #if (TESTFLAG == 0)
 	u32	tmpu4Byte[2];
 #endif /* TESTFLAG == 0) */
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	u1bTmp=0,path = is2T?2:1;
 	u32	i, u4tmp, offset;
 	u32	curveCountVal[CV_CURVE_CNT*2]={0};
 	u16	timeout = 800, timecount = 0;
 
 	/* Check continuous TX and Packet TX */
-	tmpReg = rtw_read8(pAdapter, 0xd03);
+	tmpReg = rtw_read8(adapter, 0xd03);
 
 	if ((tmpReg&0x70) != 0)			/* Deal with contisuous TX case */
-		rtw_write8(pAdapter, 0xd03, tmpReg&0x8F);	/* disable all continuous TX */
+		rtw_write8(adapter, 0xd03, tmpReg&0x8F);	/* disable all continuous TX */
 	else							/*  Deal with Packet TX case */
-		rtw_write8(pAdapter, REG_TXPAUSE, 0xFF);			/*  block all queues */
+		rtw_write8(adapter, REG_TXPAUSE, 0xFF);			/*  block all queues */
 
-	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xF00000, 0x0F);
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xF00000, 0x0F);
 
 	for (index = 0; index <path; index ++)
 	{
 
 		/* 1. Read original RF mode */
 		offset = index == 0?rOFDM0_XAAGCCore1:rOFDM0_XBAGCCore1;
-		RF_mode[index] = rtw_read8(pAdapter, offset);
+		RF_mode[index] = rtw_read8(adapter, offset);
 
 		/* 2. Set RF mode = standby mode */
-		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_AC, bRFRegOffsetMask, 0x010000);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_AC, bRFRegOffsetMask, 0x010000);
 #if (TESTFLAG == 0)
-		tmpu4Byte[index] = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask);
-		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, 0x700, 0x07);
+		tmpu4Byte[index] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, 0x700, 0x07);
 #endif
 
-		if (pAdapter->hw_init_completed)
+		if (adapter->hw_init_completed)
 		{
 			/*  switch CV-curve control by LC-calibration */
-			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G7, BIT17, 0x0);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G7, BIT17, 0x0);
 
 			/* 4. Set LC calibration begin */
-			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_CHNLBW, 0x08000, 0x01);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_CHNLBW, 0x08000, 0x01);
 
 		}
 	}
 
 	for (index = 0; index <path; index ++)
 	{
-		u4tmp = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G6, bRFRegOffsetMask);
+		u4tmp = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G6, bRFRegOffsetMask);
 
 		while ((!(u4tmp & BIT11)) &&
 			timecount <= timeout)
@@ -5099,7 +5099,7 @@ phy_LCCalibrate92DSW(
 				rtw_mdelay_os(50);
 				#endif
 			timecount += 50;
-			u4tmp = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G6, bRFRegOffsetMask);
+			u4tmp = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G6, bRFRegOffsetMask);
 		}
 	}
 	/* Disable TX only need during phy lck, To reduce LCK affect on chariot, */
@@ -5108,49 +5108,49 @@ phy_LCCalibrate92DSW(
 	if ((tmpReg&0x70) != 0)
 	{
 		/* Path-A */
-		rtw_write8(pAdapter, 0xd03, tmpReg);
+		rtw_write8(adapter, 0xd03, tmpReg);
 	}
 	else /*  Deal with Packet TX case */
 	{
-		rtw_write8(pAdapter, REG_TXPAUSE, 0x00);
+		rtw_write8(adapter, REG_TXPAUSE, 0x00);
 	}
-	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xF00000, 0x00);
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xF00000, 0x00);
 
 	for (index = 0; index <path; index ++)
 	{
-		u4tmp = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask);
+		u4tmp = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask);
 
 		{
 
 			memset(&curveCountVal[0], 0, CV_CURVE_CNT*2);
 
 			/* Set LC calibration off */
-			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_CHNLBW, 0x08000, 0x0);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_CHNLBW, 0x08000, 0x0);
 
 			/* save Curve-counting number */
 			for (i=0; i<CV_CURVE_CNT; i++)
 			{
 				u32	readVal=0, readVal2=0;
-				PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_TRSW, 0x7f, i);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_TRSW, 0x7f, i);
 
-				PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, 0x4D, bRFRegOffsetMask, 0x0);
-				readVal = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, 0x4F, bRFRegOffsetMask);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, 0x4D, bRFRegOffsetMask, 0x0);
+				readVal = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, 0x4F, bRFRegOffsetMask);
 
 				curveCountVal[2*i+1] = (readVal & 0xfffe0) >> 5;
 				/*  reg 0x4f [4:0] */
 				/*  reg 0x50 [19:10] */
-				readVal2 = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, 0x50, 0xffc00);
+				readVal2 = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, 0x50, 0xffc00);
 				curveCountVal[2*i] = (((readVal & 0x1F) << 10) | readVal2);
 
 			}
 
 			if (index == 0 && pHalData->interfaceIndex == 0)
-				phy_CalcCurvIndex(pAdapter, TargetChnl_5G, curveCountVal, true, CurveIndex);
+				phy_CalcCurvIndex(adapter, TargetChnl_5G, curveCountVal, true, CurveIndex);
 			else
-				phy_CalcCurvIndex(pAdapter, TargetChnl_2G, curveCountVal, false, CurveIndex);
+				phy_CalcCurvIndex(adapter, TargetChnl_2G, curveCountVal, false, CurveIndex);
 
 			/*  switch CV-curve control mode */
-			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G7, BIT17, 0x1);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G7, BIT17, 0x1);
 		}
 
 	}
@@ -5159,27 +5159,27 @@ phy_LCCalibrate92DSW(
 	for (index = 0; index <path; index ++)
 	{
 #if (TESTFLAG == 0)
-		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask, tmpu4Byte[index]);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask, tmpu4Byte[index]);
 #endif
 		offset = index == 0?rOFDM0_XAAGCCore1:rOFDM0_XBAGCCore1;
-		rtw_write8(pAdapter, offset, 0x50);
-		rtw_write8(pAdapter, offset, RF_mode[index]);
+		rtw_write8(adapter, offset, 0x50);
+		rtw_write8(adapter, offset, RF_mode[index]);
 	}
 
-	phy_ReloadLCKSetting(pAdapter, pHalData->CurrentChannel);
+	phy_ReloadLCKSetting(adapter, pHalData->CurrentChannel);
 }
 
 
 static void
 phy_LCCalibrate(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool		is2T
 	)
 {
 #if SWLCK == 1
-	phy_LCCalibrate92DSW(pAdapter, is2T);
+	phy_LCCalibrate92DSW(adapter, is2T);
 #else
-	phy_LCCalibrate92D(pAdapter, is2T);
+	phy_LCCalibrate92D(adapter, is2T);
 #endif
 }
 
@@ -5191,12 +5191,12 @@ phy_LCCalibrate(
 
 static void
 phy_APCalibrate(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	char		delta,
 	bool		is2T
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u32			regD[PATH_NUM];
 	u32			tmpReg, index, offset, path, i, pathbound = PATH_NUM, apkbound;
@@ -5290,7 +5290,7 @@ phy_APCalibrate(
 	int			BB_offset, delta_V, delta_offset;
 
 #if (MP_DRIVER == 1)
-	PMPT_CONTEXT	pMptCtx = &pAdapter->mppriv.MptCtx;
+	PMPT_CONTEXT	pMptCtx = &adapter->mppriv.MptCtx;
 
 	pMptCtx->APK_bound[0] = 45;
 	pMptCtx->APK_bound[1] = 52;
@@ -5332,14 +5332,14 @@ phy_APCalibrate(
 	{
 		if (index == 0)		/* skip */
 			continue;
-		BB_backup[index] = PHY_QueryBBReg(pAdapter, BB_REG[index], bMaskDWord);
+		BB_backup[index] = PHY_QueryBBReg(adapter, BB_REG[index], bMaskDWord);
 	}
 
 	/* save MAC default value */
-	phy_SaveMACRegisters(pAdapter, MAC_REG, MAC_backup);
+	phy_SaveMACRegisters(adapter, MAC_REG, MAC_backup);
 
 	/* save AFE default value */
-	phy_SaveADDARegisters(pAdapter, AFE_REG, AFE_backup, IQK_ADDA_REG_NUM);
+	phy_SaveADDARegisters(adapter, AFE_REG, AFE_backup, IQK_ADDA_REG_NUM);
 
 	for (path = 0; path < pathbound; path++)
 	{
@@ -5353,33 +5353,33 @@ phy_APCalibrate(
 			offset = rPdp_AntA;
 			for (index = 0; index < 11; index ++)
 			{
-				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+				PHY_SetBBReg(adapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
 
 				offset += 0x04;
 			}
 
-			PHY_SetBBReg(pAdapter, rConfig_Pmpd_AntB, bMaskDWord, 0x12680000);
+			PHY_SetBBReg(adapter, rConfig_Pmpd_AntB, bMaskDWord, 0x12680000);
 
 			offset = rConfig_AntA;
 			for (; index < 13; index ++)
 			{
-				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+				PHY_SetBBReg(adapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
 
 				offset += 0x04;
 			}
 
 			/* page-B1 */
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x40000000);
+			PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x40000000);
 
 			/* path A */
 			offset = rPdp_AntA;
 			for (index = 0; index < 16; index++)
 			{
-				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);
+				PHY_SetBBReg(adapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);
 
 				offset += 0x04;
 			}
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+			PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 		}
 		else if (path == RF_PATH_B)
 		{
@@ -5389,43 +5389,43 @@ phy_APCalibrate(
 			offset = rPdp_AntB;
 			for (index = 0; index < 10; index ++)
 			{
-				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+				PHY_SetBBReg(adapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
 
 				offset += 0x04;
 			}
-			PHY_SetBBReg(pAdapter, rConfig_Pmpd_AntA, bMaskDWord, 0x12680000);
+			PHY_SetBBReg(adapter, rConfig_Pmpd_AntA, bMaskDWord, 0x12680000);
 
-			PHY_SetBBReg(pAdapter, rConfig_Pmpd_AntB, bMaskDWord, 0x12680000);
+			PHY_SetBBReg(adapter, rConfig_Pmpd_AntB, bMaskDWord, 0x12680000);
 
 			offset = rConfig_AntA;
 			index = 11;
 			for (; index < 13; index ++) /* offset 0xb68, 0xb6c */
 			{
-				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+				PHY_SetBBReg(adapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
 
 				offset += 0x04;
 			}
 
 			/* page-B1 */
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x40000000);
+			PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x40000000);
 
 			/* path B */
 			offset = 0xb60;
 			for (index = 0; index < 16; index++)
 			{
-				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);
+				PHY_SetBBReg(adapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);
 
 				offset += 0x04;
 			}
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+			PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 		}
 
 		/* save RF default value */
-		regD[path] = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask);
+		regD[path] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask);
 
 		/* Path A AFE all on, path B AFE All off or vise versa */
 		for (index = 0; index < IQK_ADDA_REG_NUM ; index++)
-			PHY_SetBBReg(pAdapter, AFE_REG[index], bMaskDWord, AFE_on_off[path]);
+			PHY_SetBBReg(adapter, AFE_REG[index], bMaskDWord, AFE_on_off[path]);
 
 		/* BB to AP mode */
 		if (path == 0)
@@ -5436,36 +5436,36 @@ phy_APCalibrate(
 				if (index == 0)		/* skip */
 					continue;
 				else if (index < 5)
-				PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_AP_MODE[index]);
+				PHY_SetBBReg(adapter, BB_REG[index], bMaskDWord, BB_AP_MODE[index]);
 				else if (BB_REG[index] == 0x870)
-					PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_backup[index]|BIT10|BIT26);
+					PHY_SetBBReg(adapter, BB_REG[index], bMaskDWord, BB_backup[index]|BIT10|BIT26);
 				else
-					PHY_SetBBReg(pAdapter, BB_REG[index], BIT10, 0x0);
+					PHY_SetBBReg(adapter, BB_REG[index], BIT10, 0x0);
 			}
 
-			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);
-			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);
+			PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);
+			PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);
 		}
 		else		/* path B */
 		{
-			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x01008c00);
-			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x01008c00);
+			PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x01008c00);
+			PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x01008c00);
 
 		}
 
 
 		/* MAC settings */
-		phy_MACSettingCalibration(pAdapter, MAC_REG, MAC_backup);
+		phy_MACSettingCalibration(adapter, MAC_REG, MAC_backup);
 
 		if (path == RF_PATH_A)	/* Path B to standby mode */
 		{
-			PHY_SetRFReg(pAdapter, RF_PATH_B, RF_AC, bRFRegOffsetMask, 0x10000);
+			PHY_SetRFReg(adapter, RF_PATH_B, RF_AC, bRFRegOffsetMask, 0x10000);
 		}
 		else			/* Path A to standby mode */
 		{
-			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x10000);
-			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);
-			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20103);
+			PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x10000);
+			PHY_SetRFReg(adapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);
+			PHY_SetRFReg(adapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20103);
 		}
 
 		delta_offset = ((delta+14)/2);
@@ -5500,25 +5500,25 @@ phy_APCalibrate(
 				tmpReg = (tmpReg & 0xFFF0FFFF) | (BB_offset << 16);
 			}
 
-				PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_IPA_A, bRFRegOffsetMask, 0x8992e);
-			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_AC, bRFRegOffsetMask, APK_RF_value_0[path][index]);
-			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask, tmpReg);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_IPA_A, bRFRegOffsetMask, 0x8992e);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_AC, bRFRegOffsetMask, APK_RF_value_0[path][index]);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask, tmpReg);
 
 			/*  PA11+PAD01111, one shot */
 			i = 0;
 			do {
-				PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80000000);
-				PHY_SetBBReg(pAdapter, APK_offset[path], bMaskDWord, APK_value[0]);
+				PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80000000);
+				PHY_SetBBReg(adapter, APK_offset[path], bMaskDWord, APK_value[0]);
 				rtw_mdelay_os(3);
-				PHY_SetBBReg(pAdapter, APK_offset[path], bMaskDWord, APK_value[1]);
+				PHY_SetBBReg(adapter, APK_offset[path], bMaskDWord, APK_value[1]);
 
 				rtw_mdelay_os(20);
-				PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+				PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 
 				if (path == RF_PATH_A)
-				tmpReg = PHY_QueryBBReg(pAdapter, rAPK, 0x03E00000);
+				tmpReg = PHY_QueryBBReg(adapter, rAPK, 0x03E00000);
 				else
-					tmpReg = PHY_QueryBBReg(pAdapter, rAPK, 0xF8000000);
+					tmpReg = PHY_QueryBBReg(adapter, rAPK, 0xF8000000);
 
 
 				i++;
@@ -5530,7 +5530,7 @@ phy_APCalibrate(
 	}
 
 	/* reload MAC default value */
-	phy_ReloadMACRegisters(pAdapter, MAC_REG, MAC_backup);
+	phy_ReloadMACRegisters(adapter, MAC_REG, MAC_backup);
 
 	/* reload BB default value */
 	for (index = 0; index < APK_BB_REG_NUM ; index++)
@@ -5538,20 +5538,20 @@ phy_APCalibrate(
 
 		if (index == 0)		/* skip */
 			continue;
-		PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_backup[index]);
+		PHY_SetBBReg(adapter, BB_REG[index], bMaskDWord, BB_backup[index]);
 	}
 
 	/* reload AFE default value */
-	phy_ReloadADDARegisters(pAdapter, AFE_REG, AFE_backup, IQK_ADDA_REG_NUM);
+	phy_ReloadADDARegisters(adapter, AFE_REG, AFE_backup, IQK_ADDA_REG_NUM);
 
 	/* reload RF path default value */
 	for (path = 0; path < pathbound; path++)
 	{
-		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask, regD[path]);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask, regD[path]);
 		if (path == RF_PATH_B)
 		{
-			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);
-			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20101);
+			PHY_SetRFReg(adapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);
+			PHY_SetRFReg(adapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20101);
 		}
 
 		/* note no index == 0 */
@@ -5562,13 +5562,13 @@ phy_APCalibrate(
 
 	for (path = 0; path < pathbound; path++)
 	{
-		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G1_G4, bRFRegOffsetMask,
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G1_G4, bRFRegOffsetMask,
 		((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (APK_result[path][1] << 5) | APK_result[path][1]));
 		if (path == RF_PATH_A)
-			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask,
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask,
 			((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x00 << 5) | 0x05));
 		else
-		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask,
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask,
 			((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x02 << 5) | 0x05));
 
 	}
@@ -5578,31 +5578,31 @@ phy_APCalibrate(
 }
 
 static void phy_SetRFPathSwitch(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	bool		main,
 	bool		is2T
 	)
 {
 
-	if (!pAdapter->hw_init_completed)
+	if (!adapter->hw_init_completed)
 	{
-		PHY_SetBBReg(pAdapter, 0x4C, BIT23, 0x01);
-		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
+		PHY_SetBBReg(adapter, 0x4C, BIT23, 0x01);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
 	}
 
 	if (main)
-		PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x2);
+		PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x2);
 	else
-		PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x1);
+		PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x1);
 
 }
 
 void
 rtl8192d_PHY_IQCalibrate(
-	struct rtw_adapter *	pAdapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	int			result[4][8];	/* last is final result */
 	u8			i, final_candidate, Indexforchannel;
@@ -5613,9 +5613,9 @@ rtl8192d_PHY_IQCalibrate(
 
 
 #if (MP_DRIVER == 1)
-	bStartContTx = pAdapter->mppriv.MptCtx.bStartContTx;
-	bSingleTone = pAdapter->mppriv.MptCtx.bSingleTone;
-	bCarrierSuppression = pAdapter->mppriv.MptCtx.bCarrierSuppression;
+	bStartContTx = adapter->mppriv.MptCtx.bStartContTx;
+	bSingleTone = adapter->mppriv.MptCtx.bSingleTone;
+	bCarrierSuppression = adapter->mppriv.MptCtx.bCarrierSuppression;
 #endif
 
 	/* ignore IQK when continuous Tx */
@@ -5650,19 +5650,19 @@ rtl8192d_PHY_IQCalibrate(
 	{
 		if (pHalData->CurrentBandType92D == BAND_ON_5G)
 		{
-			phy_IQCalibrate_5G_Normal(pAdapter, result, i);
+			phy_IQCalibrate_5G_Normal(adapter, result, i);
 		}
 		else if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 		{
 			if (IS_92D_SINGLEPHY(pHalData->VersionID))
-				phy_IQCalibrate(pAdapter, result, i, true);
+				phy_IQCalibrate(adapter, result, i, true);
 			else
-				phy_IQCalibrate(pAdapter, result, i, false);
+				phy_IQCalibrate(adapter, result, i, false);
 		}
 
 		if (i == 1)
 		{
-			is12simular = phy_SimularityCompare(pAdapter, result, 0, 1);
+			is12simular = phy_SimularityCompare(adapter, result, 0, 1);
 			if (is12simular)
 			{
 				final_candidate = 0;
@@ -5672,14 +5672,14 @@ rtl8192d_PHY_IQCalibrate(
 
 		if (i == 2)
 		{
-			is13simular = phy_SimularityCompare(pAdapter, result, 0, 2);
+			is13simular = phy_SimularityCompare(adapter, result, 0, 2);
 			if (is13simular)
 			{
 				final_candidate = 0;
 				break;
 			}
 
-			is23simular = phy_SimularityCompare(pAdapter, result, 1, 2);
+			is23simular = phy_SimularityCompare(adapter, result, 1, 2);
 			if (is23simular)
 				final_candidate = 1;
 			else
@@ -5730,9 +5730,9 @@ rtl8192d_PHY_IQCalibrate(
 	if ((RegE94 != 0)/*&&(RegEA4 != 0)*/)
 	{
 		if (pHalData->CurrentBandType92D == BAND_ON_5G)
-			phy_PathAFillIQKMatrix_5G_Normal(pAdapter, bPathAOK, result, final_candidate, (RegEA4 == 0));
+			phy_PathAFillIQKMatrix_5G_Normal(adapter, bPathAOK, result, final_candidate, (RegEA4 == 0));
 		else
-			phy_PathAFillIQKMatrix(pAdapter, bPathAOK, result, final_candidate, (RegEA4 == 0));
+			phy_PathAFillIQKMatrix(adapter, bPathAOK, result, final_candidate, (RegEA4 == 0));
 	}
 
 	if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
@@ -5740,13 +5740,13 @@ rtl8192d_PHY_IQCalibrate(
 		if ((RegEB4 != 0)/*&&(RegEC4 != 0)*/)
 		{
 			if (pHalData->CurrentBandType92D == BAND_ON_5G)
-				phy_PathBFillIQKMatrix_5G_Normal(pAdapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
+				phy_PathBFillIQKMatrix_5G_Normal(adapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
 			else
-				phy_PathBFillIQKMatrix(pAdapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
+				phy_PathBFillIQKMatrix(adapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
 		}
 	}
 
-	if (IS_HARDWARE_TYPE_8192D(pAdapter) && final_candidate != 0xFF)
+	if (IS_HARDWARE_TYPE_8192D(adapter) && final_candidate != 0xFF)
 	{
 		Indexforchannel = rtl8192d_GetRightChnlPlaceforIQK(pHalData->CurrentChannel);
 
@@ -5759,8 +5759,8 @@ rtl8192d_PHY_IQCalibrate(
 		pHalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone = true;
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if (rtw_buddy_adapter_up(pAdapter)) {
-			struct rtw_adapter * pbuddy_adapter = pAdapter->pbuddy_adapter;
+		if (rtw_buddy_adapter_up(adapter)) {
+			struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
 			struct hal_data_8192du *pbuddy_HalData = GET_HAL_DATA(pbuddy_adapter);
 
 			for (i = 0; i < IQK_Matrix_REG_NUM; i++)
@@ -5778,22 +5778,22 @@ rtl8192d_PHY_IQCalibrate(
 
 void
 rtl8192d_PHY_LCCalibrate(
-	struct rtw_adapter *	pAdapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
-	struct mlme_ext_priv	*pmlmeext = &pAdapter->mlmeextpriv;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 	bool		bStartContTx = false, bSingleTone = false, bCarrierSuppression = false;
 	u32			timeout = 2000, timecount = 0;
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct rtw_adapter *	BuddyAdapter = pAdapter->pbuddy_adapter;
-	struct mlme_priv	*pmlmeprivBuddyAdapter;
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+	struct mlme_priv	*pmlmeprivBuddyadapter;
 #endif
 
 #if MP_DRIVER == 1
-	bStartContTx = pAdapter->mppriv.MptCtx.bStartContTx;
-	bSingleTone = pAdapter->mppriv.MptCtx.bSingleTone;
-	bCarrierSuppression = pAdapter->mppriv.MptCtx.bCarrierSuppression;
+	bStartContTx = adapter->mppriv.MptCtx.bStartContTx;
+	bSingleTone = adapter->mppriv.MptCtx.bSingleTone;
+	bCarrierSuppression = adapter->mppriv.MptCtx.bCarrierSuppression;
 #endif
 
 #if DISABLE_BB_RF
@@ -5805,12 +5805,12 @@ rtl8192d_PHY_LCCalibrate(
 		return;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if (BuddyAdapter != NULL &&
+	if (Buddyadapter != NULL &&
 		((pHalData->interfaceIndex == 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G) ||
 		(pHalData->interfaceIndex == 1 && pHalData->CurrentBandType92D == BAND_ON_5G)))
 	{
-		pmlmeprivBuddyAdapter = &BuddyAdapter->mlmepriv;
-		while ((check_fwstate(pmlmeprivBuddyAdapter, _FW_UNDER_LINKING|_FW_UNDER_SURVEY)==true) && timecount < timeout)
+		pmlmeprivBuddyadapter = &Buddyadapter->mlmepriv;
+		while ((check_fwstate(pmlmeprivBuddyadapter, _FW_UNDER_LINKING|_FW_UNDER_SURVEY)==true) && timecount < timeout)
 		{
 			rtw_msleep_os(50);
 			timecount += 50;
@@ -5826,11 +5826,11 @@ rtl8192d_PHY_LCCalibrate(
 
 	if (IS_92D_SINGLEPHY(pHalData->VersionID))
 	{
-		phy_LCCalibrate(pAdapter, true);
+		phy_LCCalibrate(adapter, true);
 	}
 	else {
 		/*  For 88C 1T1R */
-		phy_LCCalibrate(pAdapter, false);
+		phy_LCCalibrate(adapter, false);
 	}
 
 	pHalData->bLCKInProgress = false;
@@ -5839,7 +5839,7 @@ rtl8192d_PHY_LCCalibrate(
 
 void
 rtl8192d_PHY_APCalibrate(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	char		delta
 	)
 {
@@ -5847,15 +5847,15 @@ rtl8192d_PHY_APCalibrate(
 
 void
 PHY_UpdateBBRFConfiguration8192D(
-	struct rtw_adapter * Adapter,
+	struct rtw_adapter * adapter,
 	bool bisBandSwitch
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u8	eRFPath = 0;
 	bool			bInternalPA;
-	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
 
 	/* Update BB */
 	/* r_select_5G for path_A/B.0 for 2.4G,1 for 5G */
@@ -5863,63 +5863,63 @@ PHY_UpdateBBRFConfiguration8192D(
 	{/*  2.4G band */
 		/* r_select_5G for path_A/B,0x878 */
 
-		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT0, 0x0);
-		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT15, 0x0);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT0, 0x0);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT15, 0x0);
 		if (pHalData->MacPhyMode92D != DUALMAC_DUALPHY)
 		{
-			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT16, 0x0);
-			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT31, 0x0);
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT16, 0x0);
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT31, 0x0);
 		}
 
 		/* rssi_table_select:index 0 for 2.4G.1~3 for 5G,0xc78 */
-		PHY_SetBBReg(Adapter, rOFDM0_AGCRSSITable, BIT6|BIT7, 0x0);
+		PHY_SetBBReg(adapter, rOFDM0_AGCRSSITable, BIT6|BIT7, 0x0);
 
 		/* fc_area 0xd2c */
-		PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT14|BIT13, 0x0);
+		PHY_SetBBReg(adapter, rOFDM1_CFOTracking, BIT14|BIT13, 0x0);
 		/*  5G LAN ON */
-		PHY_SetBBReg(Adapter, 0xB30, 0x00F00000, 0xa);
+		PHY_SetBBReg(adapter, 0xB30, 0x00F00000, 0xa);
 
 		/* TX BB gain shift*1,Just for testchip,0xc80,0xc88 */
-		PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
-		PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x40000100);
 
 		if (pregistrypriv->special_rf_path == 1)
-			PHY_SetBBReg(Adapter, rCCK0_AFESetting, bMaskByte3, 0x80);
+			PHY_SetBBReg(adapter, rCCK0_AFESetting, bMaskByte3, 0x80);
 		else if (pregistrypriv->special_rf_path == 2)
-			PHY_SetBBReg(Adapter, rCCK0_AFESetting, bMaskByte3, 0x45);
+			PHY_SetBBReg(adapter, rCCK0_AFESetting, bMaskByte3, 0x45);
 
 
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
 		{
-			PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
+			PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
 			pdmpriv->OFDM_index[RF_PATH_A] = 0x0c;
-			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFInterfaceSW, BIT10|BIT6|BIT5,
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT10|BIT6|BIT5,
 				((pHalData->EEPROMC9&BIT3) >> 3)|(pHalData->EEPROMC9&BIT1)|((pHalData->EEPROMCC&BIT1) << 4));
-			PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, BIT10|BIT6|BIT5,
+			PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, BIT10|BIT6|BIT5,
 				((pHalData->EEPROMC9&BIT2) >> 2)|((pHalData->EEPROMC9&BIT0) << 1)|((pHalData->EEPROMCC&BIT0) << 5));
-			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT15, 0);
-			PHY_SetBBReg(Adapter, rPdp_AntA, bMaskDWord, 0x01017038);
-			PHY_SetBBReg(Adapter, rConfig_AntA, bMaskDWord, 0x0f600000);
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT15, 0);
+			PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x01017038);
+			PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x0f600000);
 		}
 		else
 		{
-			PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
-			PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x40000100);
+			PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
+			PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x40000100);
 			pdmpriv->OFDM_index[RF_PATH_A] = 0x0c;
 			pdmpriv->OFDM_index[RF_PATH_B] = 0x0c;
 
-			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFInterfaceSW, BIT26|BIT22|BIT21|BIT10|BIT6|BIT5,
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT26|BIT22|BIT21|BIT10|BIT6|BIT5,
 				((pHalData->EEPROMC9&BIT3) >> 3)|(pHalData->EEPROMC9&BIT1)|((pHalData->EEPROMCC&BIT1) << 4)|((pHalData->EEPROMC9&BIT7) << 9)|((pHalData->EEPROMC9&BIT5) << 12)|((pHalData->EEPROMCC&BIT3) << 18));
-			PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, BIT10|BIT6|BIT5,
+			PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, BIT10|BIT6|BIT5,
 				((pHalData->EEPROMC9&BIT2) >> 2)|((pHalData->EEPROMC9&BIT0) << 1)|((pHalData->EEPROMCC&BIT0) << 5));
-			PHY_SetBBReg(Adapter, rFPGA0_XB_RFInterfaceOE, BIT10|BIT6|BIT5,
+			PHY_SetBBReg(adapter, rFPGA0_XB_RFInterfaceOE, BIT10|BIT6|BIT5,
 				((pHalData->EEPROMC9&BIT6) >> 6)|((pHalData->EEPROMC9&BIT4) >> 3)|((pHalData->EEPROMCC&BIT2) << 3));
-			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT31|BIT15, 0);
-			PHY_SetBBReg(Adapter, rPdp_AntA, bMaskDWord, 0x01017038);
-			PHY_SetBBReg(Adapter, rPdp_AntB, bMaskDWord, 0x01017038);
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT31|BIT15, 0);
+			PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x01017038);
+			PHY_SetBBReg(adapter, rPdp_AntB, bMaskDWord, 0x01017038);
 
-			PHY_SetBBReg(Adapter, rConfig_AntA, bMaskDWord, 0x0f600000);
-			PHY_SetBBReg(Adapter, rConfig_AntB, bMaskDWord, 0x0f600000);
+			PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x0f600000);
+			PHY_SetBBReg(adapter, rConfig_AntB, bMaskDWord, 0x0f600000);
 		}
 		pdmpriv->CCK_index = 0x0c;
 
@@ -5928,21 +5928,21 @@ PHY_UpdateBBRFConfiguration8192D(
 	{
 
 		/* r_select_5G for path_A/B */
-		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT0, 0x1);
-		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT15, 0x1);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT0, 0x1);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT15, 0x1);
 		if (pHalData->MacPhyMode92D != DUALMAC_DUALPHY)
 		{
-			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT16, 0x1);
-			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT31, 0x1);
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT16, 0x1);
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT31, 0x1);
 		}
 
 		/* rssi_table_select:index 0 for 2.4G.1~3 for 5G */
-		PHY_SetBBReg(Adapter, rOFDM0_AGCRSSITable, BIT6|BIT7, 0x1);
+		PHY_SetBBReg(adapter, rOFDM0_AGCRSSITable, BIT6|BIT7, 0x1);
 
 		/* fc_area */
-		PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT14|BIT13, 0x1);
+		PHY_SetBBReg(adapter, rOFDM1_CFOTracking, BIT14|BIT13, 0x1);
 		/*  5G LAN ON */
-		PHY_SetBBReg(Adapter, 0xB30, 0x00F00000, 0x0);
+		PHY_SetBBReg(adapter, 0xB30, 0x00F00000, 0x0);
 
 		/* TX BB gain shift,Just for testchip,0xc80,0xc88 */
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
@@ -5954,12 +5954,12 @@ PHY_UpdateBBRFConfiguration8192D(
 
 			if (bInternalPA)
 			{
-				PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x2d4000b5);
+				PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x2d4000b5);
 				pdmpriv->OFDM_index[RF_PATH_A] = 0x12;
 			}
 			else
 			{
-				PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x20000080);
+				PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x20000080);
 				pdmpriv->OFDM_index[RF_PATH_A] = 0x18;
 			}
 		}
@@ -5967,75 +5967,75 @@ PHY_UpdateBBRFConfiguration8192D(
 		{
 			if (pHalData->InternalPA5G[0])
 			{
-				PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x2d4000b5);
+				PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x2d4000b5);
 				pdmpriv->OFDM_index[RF_PATH_A] = 0x12;
 			}
 			else
 			{
-				PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x20000080);
+				PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x20000080);
 				pdmpriv->OFDM_index[RF_PATH_A] = 0x18;
 			}
 
 			if (pHalData->InternalPA5G[1])
 			{
-				PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x2d4000b5);
+				PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x2d4000b5);
 				pdmpriv->OFDM_index[RF_PATH_B] = 0x12;
 			}
 			else
 			{
-				PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x20000080);
+				PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x20000080);
 				pdmpriv->OFDM_index[RF_PATH_A] = 0x18;
 			}
 		}
 
-		PHY_SetBBReg(Adapter, 0xB30, BIT27, 0x0);
+		PHY_SetBBReg(adapter, 0xB30, BIT27, 0x0);
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
 		{
-			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFInterfaceSW, BIT10|BIT6|BIT5,
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT10|BIT6|BIT5,
 				(pHalData->EEPROMCC&BIT5));
-			PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, BIT10,
+			PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, BIT10,
 				((pHalData->EEPROMCC&BIT4) >> 4));
-			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT15,
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT15,
 				(pHalData->EEPROMCC&BIT4) >> 4);
-			PHY_SetBBReg(Adapter, rPdp_AntA, bMaskDWord, 0x01017098);
+			PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x01017098);
 			if (pdmpriv->bDPKdone[RF_PATH_A])
-				PHY_SetBBReg(Adapter, 0xb68, bMaskDWord, 0x08080000);
+				PHY_SetBBReg(adapter, 0xb68, bMaskDWord, 0x08080000);
 			else
-				PHY_SetBBReg(Adapter, 0xb68, bMaskDWord, 0x20000000);
+				PHY_SetBBReg(adapter, 0xb68, bMaskDWord, 0x20000000);
 		}
 		else
 		{
-			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFInterfaceSW, BIT26|BIT22|BIT21|BIT10|BIT6|BIT5,
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT26|BIT22|BIT21|BIT10|BIT6|BIT5,
 				(pHalData->EEPROMCC&BIT5)|((pHalData->EEPROMCC&BIT7) << 14));
-			PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, BIT10,
+			PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, BIT10,
 				((pHalData->EEPROMCC&BIT4) >> 4));
-			PHY_SetBBReg(Adapter, rFPGA0_XB_RFInterfaceOE, BIT10,
+			PHY_SetBBReg(adapter, rFPGA0_XB_RFInterfaceOE, BIT10,
 				((pHalData->EEPROMCC&BIT6) >> 6));
-			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT31|BIT15,
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT31|BIT15,
 				((pHalData->EEPROMCC&BIT4) >> 4)|((pHalData->EEPROMCC&BIT6) << 10));
-			PHY_SetBBReg(Adapter, rPdp_AntA, bMaskDWord, 0x01017098);
-			PHY_SetBBReg(Adapter, rPdp_AntB, bMaskDWord, 0x01017098);
+			PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x01017098);
+			PHY_SetBBReg(adapter, rPdp_AntB, bMaskDWord, 0x01017098);
 			if (pdmpriv->bDPKdone[RF_PATH_A])
-				PHY_SetBBReg(Adapter, 0xb68, bMaskDWord, 0x08080000);
+				PHY_SetBBReg(adapter, 0xb68, bMaskDWord, 0x08080000);
 			else
-				PHY_SetBBReg(Adapter, 0xb68, bMaskDWord, 0x20000000);
+				PHY_SetBBReg(adapter, 0xb68, bMaskDWord, 0x20000000);
 			if (pdmpriv->bDPKdone[RF_PATH_B])
-				PHY_SetBBReg(Adapter, 0xb6c, bMaskDWord, 0x08080000);
+				PHY_SetBBReg(adapter, 0xb6c, bMaskDWord, 0x08080000);
 			else
-				PHY_SetBBReg(Adapter, 0xb6c, bMaskDWord, 0x20000000);
+				PHY_SetBBReg(adapter, 0xb6c, bMaskDWord, 0x20000000);
 		}
 
 	}
 
 	/* update IQK related settings */
 	{
-		PHY_SetBBReg(Adapter, rOFDM0_XARxIQImbalance, bMaskDWord, 0x40000100);
-		PHY_SetBBReg(Adapter, rOFDM0_XBRxIQImbalance, bMaskDWord, 0x40000100);
-		PHY_SetBBReg(Adapter, rOFDM0_XCTxAFE, 0xF0000000, 0x00);
-		PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold,  BIT30|BIT28|BIT26|BIT24,  0x00);
-		PHY_SetBBReg(Adapter, rOFDM0_XDTxAFE, 0xF0000000, 0x00);
-		PHY_SetBBReg(Adapter, rOFDM0_RxIQExtAnta, 0xF0000000, 0x00);
-		PHY_SetBBReg(Adapter, rOFDM0_AGCRSSITable, 0x0000F000, 0x00);
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance, bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance, bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rOFDM0_XCTxAFE, 0xF0000000, 0x00);
+		PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold,  BIT30|BIT28|BIT26|BIT24,  0x00);
+		PHY_SetBBReg(adapter, rOFDM0_XDTxAFE, 0xF0000000, 0x00);
+		PHY_SetBBReg(adapter, rOFDM0_RxIQExtAnta, 0xF0000000, 0x00);
+		PHY_SetBBReg(adapter, rOFDM0_AGCRSSITable, 0x0000F000, 0x00);
 	}
 
 	/* Update RF */
@@ -6043,14 +6043,14 @@ PHY_UpdateBBRFConfiguration8192D(
 	{
 		if (pHalData->CurrentBandType92D == BAND_ON_2_4G) {
 			/* MOD_AG for RF paht_A 0x18 BIT8,BIT16 */
-			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT8|BIT16|BIT18|0xFF, 1);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT8|BIT16|BIT18|0xFF, 1);
 
 			/* RF0x0b[16:14] =3b'111 */
-			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_TXPA_AG, 0x1c000, 0x07);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_TXPA_AG, 0x1c000, 0x07);
 		}
 		else { /* 5G band */
 			/* MOD_AG for RF paht_A 0x18 BIT8,BIT16 */
-			PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x97524); /* set channel 36 */
+			PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x97524); /* set channel 36 */
 
 		}
 
@@ -6059,16 +6059,16 @@ PHY_UpdateBBRFConfiguration8192D(
 			/* Set right channel on RF reg0x18 for another mac. */
 			if (pHalData->interfaceIndex == 0) /* set MAC1 default channel if MAC1 not up. */
 			{
-				if (!(rtw_read8(Adapter, REG_MAC1)&MAC1_ON)) {
-					rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
-					PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW|MAC0_ACCESS_PHY1, bRFRegOffsetMask, 0x97524); /* set channel 36 */
-					rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
+				if (!(rtw_read8(adapter, REG_MAC1)&MAC1_ON)) {
+					rtl8192d_PHY_EnableAnotherPHY(adapter, true);
+					PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW|MAC0_ACCESS_PHY1, bRFRegOffsetMask, 0x97524); /* set channel 36 */
+					rtl8192d_PHY_PowerDownAnotherPHY(adapter, true);
 				}
 			} else if (pHalData->interfaceIndex == 1) { /* set MAC0 default channel */
-				if (!(rtw_read8(Adapter, REG_MAC0)&MAC0_ON)) {
-					rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
-					PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW|MAC1_ACCESS_PHY0, bRFRegOffsetMask, 0x87401); /*  set channel 1 */
-					rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
+				if (!(rtw_read8(adapter, REG_MAC0)&MAC0_ON)) {
+					rtl8192d_PHY_EnableAnotherPHY(adapter, false);
+					PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW|MAC1_ACCESS_PHY0, bRFRegOffsetMask, 0x87401); /*  set channel 1 */
+					rtl8192d_PHY_PowerDownAnotherPHY(adapter, false);
 				}
 			}
 		}
@@ -6082,13 +6082,13 @@ PHY_UpdateBBRFConfiguration8192D(
 		if (!bisBandSwitch)
 #endif
 		{
-		PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x11);
-		PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, 0x1);
+		PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x11);
+		PHY_SetBBReg(adapter, rOFDM1_TRxPathEnable, bDWord, 0x1);
 		}
 
 		/* enable ad/da clock1 for dual-phy reg0x888 */
 		if (pHalData->interfaceIndex == 0)
-			PHY_SetBBReg(Adapter, rFPGA0_AdDaClockEn, BIT12|BIT13, 0x3);
+			PHY_SetBBReg(adapter, rFPGA0_AdDaClockEn, BIT12|BIT13, 0x3);
 		else
 		{
 			bool bMAC0NotUp =false;
@@ -6096,57 +6096,57 @@ PHY_UpdateBBRFConfiguration8192D(
 			/* 3 Path Div */
 			/*  Neil Chen---2011--05--31---Begin */
 
-			bMAC0NotUp = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
+			bMAC0NotUp = rtl8192d_PHY_EnableAnotherPHY(adapter, false);
 			if (bMAC0NotUp)
 			{
-				PHY_SetBBReg(Adapter, rFPGA0_AdDaClockEn|MAC1_ACCESS_PHY0, BIT12|BIT13, 0x3);
-				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
+				PHY_SetBBReg(adapter, rFPGA0_AdDaClockEn|MAC1_ACCESS_PHY0, BIT12|BIT13, 0x3);
+				rtl8192d_PHY_PowerDownAnotherPHY(adapter, false);
 			}
 		}
 
 		/* supported mcs */
-		PHY_SetBBReg(Adapter, rOFDM1_LSTF, BIT19|BIT20, 0x0);
+		PHY_SetBBReg(adapter, rOFDM1_LSTF, BIT19|BIT20, 0x0);
 	}
 	else /*  2T2R Single PHY */
 	{
 		if (pregistrypriv->special_rf_path == 2)
 		{
-			PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x22);
-			PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, 0x2);
-			PHY_SetBBReg(Adapter, rFPGA1_TxInfo, bMaskDWord, 0x82221322);	/* OFDM Tx */
+			PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x22);
+			PHY_SetBBReg(adapter, rOFDM1_TRxPathEnable, bDWord, 0x2);
+			PHY_SetBBReg(adapter, rFPGA1_TxInfo, bMaskDWord, 0x82221322);	/* OFDM Tx */
 		}
 		else if (pregistrypriv->special_rf_path == 1)
 		{
-			PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x11);
-			PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, 0x1);
-			PHY_SetBBReg(Adapter, rFPGA1_TxInfo, bMaskDWord, 0x81121311);	/* OFDM Tx */
+			PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x11);
+			PHY_SetBBReg(adapter, rOFDM1_TRxPathEnable, bDWord, 0x1);
+			PHY_SetBBReg(adapter, rFPGA1_TxInfo, bMaskDWord, 0x81121311);	/* OFDM Tx */
 		}
 		else
 		{
 			/* Use antenna 0 & 1,0xc04,0xd04 */
-			PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x33);
-			PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, 0x3);
+			PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x33);
+			PHY_SetBBReg(adapter, rOFDM1_TRxPathEnable, bDWord, 0x3);
 		}
 
 		/* disable ad/da clock1,0x888 */
-		PHY_SetBBReg(Adapter, rFPGA0_AdDaClockEn, BIT12|BIT13, 0);
+		PHY_SetBBReg(adapter, rFPGA0_AdDaClockEn, BIT12|BIT13, 0);
 
 		/* supported mcs */
-		PHY_SetBBReg(Adapter, rOFDM1_LSTF, BIT19|BIT20, 0x1);
+		PHY_SetBBReg(adapter, rOFDM1_LSTF, BIT19|BIT20, 0x1);
 	}
 
 #if MP_DRIVER == 1
 	if (bisBandSwitch)
 	{
-		PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, pdmpriv->RegC04_MP);
-		PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, pdmpriv->RegD04_MP);
+		PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0, pdmpriv->RegC04_MP);
+		PHY_SetBBReg(adapter, rOFDM1_TRxPathEnable, bDWord, pdmpriv->RegD04_MP);
 	}
 #endif
 
 	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 	{
-		pHalData->RfRegChnlVal[eRFPath] = PHY_QueryRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, bRFRegOffsetMask);
-		pdmpriv->RegRF3C[eRFPath] = PHY_QueryRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_RXRF_A3, bRFRegOffsetMask);
+		pHalData->RfRegChnlVal[eRFPath] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, bRFRegOffsetMask);
+		pdmpriv->RegRF3C[eRFPath] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_RXRF_A3, bRFRegOffsetMask);
 	}
 
 
@@ -6164,11 +6164,11 @@ PHY_UpdateBBRFConfiguration8192D(
 /* 		2. PASSIVE_LEVEL (USB interface) */
 /*  */
 void PHY_ReadMacPhyMode92D(
-		struct rtw_adapter *			Adapter,
+		struct rtw_adapter *			adapter,
 		bool		AutoloadFail
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	MacPhyCrValue = 0;
 
 	if (AutoloadFail)
@@ -6177,7 +6177,7 @@ void PHY_ReadMacPhyMode92D(
 		return;
 	}
 
-	MacPhyCrValue = rtw_read8(Adapter, REG_MAC_PHY_CTRL_NORMAL);
+	MacPhyCrValue = rtw_read8(adapter, REG_MAC_PHY_CTRL_NORMAL);
 
 	DBG_8192D("PHY_ReadMacPhyMode92D():   MAC_PHY_CTRL Value %x\n",MacPhyCrValue);
 
@@ -6207,26 +6207,26 @@ void PHY_ReadMacPhyMode92D(
 /* 		2. PASSIVE_LEVEL (USB interface) */
 /*  */
 void PHY_ConfigMacPhyMode92D(
-		struct rtw_adapter *			Adapter
+		struct rtw_adapter *			adapter
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	offset = REG_MAC_PHY_CTRL_NORMAL, temp;
 
-	temp = rtw_read8(Adapter, offset);
+	temp = rtw_read8(adapter, offset);
 	temp &= ~(BIT(0)|BIT(1)|BIT(2));
 	switch (pHalData->MacPhyMode92D) {
 		case DUALMAC_DUALPHY:
 			MSG_8192D("MacPhyMode: DUALMAC_DUALPHY\n");
-			rtw_write8(Adapter, offset, temp | BIT(0)|BIT(1));
+			rtw_write8(adapter, offset, temp | BIT(0)|BIT(1));
 			break;
 		case SINGLEMAC_SINGLEPHY:
 			MSG_8192D("MacPhyMode: SINGLEMAC_SINGLEPHY\n");
-			rtw_write8(Adapter, offset, temp | BIT(2));
+			rtw_write8(adapter, offset, temp | BIT(2));
 			break;
 		case DUALMAC_SINGLEPHY:
 			MSG_8192D("MacPhyMode: DUALMAC_SINGLEPHY\n");
-			rtw_write8(Adapter, offset, temp | BIT(0));
+			rtw_write8(adapter, offset, temp | BIT(0));
 			break;
 	}
 }
@@ -6242,12 +6242,12 @@ void PHY_ConfigMacPhyMode92D(
 /* 		1. Boot from EEPROM and CR9346 regiser has verified. */
 /* 		2. PASSIVE_LEVEL (USB interface) */
 /*  */
-void PHY_ConfigMacPhyModeInfo92D(struct rtw_adapter *Adapter)
+void PHY_ConfigMacPhyModeInfo92D(struct rtw_adapter *adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct rtw_adapter *BuddyAdapter = Adapter->pbuddy_adapter;
-	struct hal_data_8192du *pHalDataBuddyAdapter;
+	struct rtw_adapter *Buddyadapter = adapter->pbuddy_adapter;
+	struct hal_data_8192du *pHalDataBuddyadapter;
 #endif
 
 	switch (pHalData->MacPhyMode92D) {
@@ -6259,12 +6259,12 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 #ifdef CONFIG_DUALMAC_CONCURRENT
 /* get bMasetOfDMSP and bSlaveOfDMSP sync with buddy adapter */
 			ACQUIRE_GLOBAL_MUTEX(GlobalCounterForMutex);
-			if (BuddyAdapter != NULL)
+			if (Buddyadapter != NULL)
 			{
-				pHalDataBuddyAdapter = GET_HAL_DATA(BuddyAdapter);
-				pHalData->bMasterOfDMSP = !pHalDataBuddyAdapter->bMasterOfDMSP;
-				pHalData->bSlaveOfDMSP = !pHalDataBuddyAdapter->bSlaveOfDMSP;
-				pHalData->CurrentBandType92D = pHalDataBuddyAdapter->CurrentBandType92D;
+				pHalDataBuddyadapter = GET_HAL_DATA(Buddyadapter);
+				pHalData->bMasterOfDMSP = !pHalDataBuddyadapter->bMasterOfDMSP;
+				pHalData->bSlaveOfDMSP = !pHalDataBuddyadapter->bSlaveOfDMSP;
+				pHalData->CurrentBandType92D = pHalDataBuddyadapter->CurrentBandType92D;
 			}
 			else
 			{
@@ -6311,7 +6311,7 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 			break;
 	}
 
-	/*if (Adapter->bInHctTest&&(pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY))
+	/*if (adapter->bInHctTest&&(pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY))
 	{
 		pHalData->CurrentBandType92D=BAND_ON_2_4G;
 		pHalData->BandSet92D = BAND_ON_2_4G;
@@ -6322,7 +6322,7 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 	else
 		pHalData->CurrentChannel = 36;
 
-	Adapter->registrypriv.channel = pHalData->CurrentChannel;
+	adapter->registrypriv.channel = pHalData->CurrentChannel;
 
 #if DBG
 	switch (pHalData->VersionID)
@@ -6360,22 +6360,22 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 	switch (pHalData->BandSet92D)
 	{
 		case BAND_ON_2_4G:
-			Adapter->registrypriv.wireless_mode = WIRELESS_11BG_24N;
+			adapter->registrypriv.wireless_mode = WIRELESS_11BG_24N;
 			break;
 
 		case BAND_ON_5G:
-			Adapter->registrypriv.wireless_mode = WIRELESS_11A_5N;
+			adapter->registrypriv.wireless_mode = WIRELESS_11A_5N;
 			break;
 
 		case BAND_ON_BOTH:
-			Adapter->registrypriv.wireless_mode = WIRELESS_11ABGN;
+			adapter->registrypriv.wireless_mode = WIRELESS_11ABGN;
 			break;
 
 		default:
-			Adapter->registrypriv.wireless_mode = WIRELESS_11ABGN;
+			adapter->registrypriv.wireless_mode = WIRELESS_11ABGN;
 			break;
 	}
-	DBG_8192D("%s(): wireless_mode = %x\n",__func__,Adapter->registrypriv.wireless_mode);
+	DBG_8192D("%s(): wireless_mode = %x\n",__func__,adapter->registrypriv.wireless_mode);
 }
 
 /*  */
@@ -6387,27 +6387,27 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 /* 		2. PASSIVE_LEVEL (USB interface) */
 /*  */
 void PHY_ConfigMacCoexist_RFPage92D(
-		struct rtw_adapter *			Adapter
+		struct rtw_adapter *			adapter
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	switch (pHalData->MacPhyMode92D)
 	{
 		case DUALMAC_DUALPHY:
-			rtw_write8(Adapter,REG_DMC, 0x0);
-			rtw_write8(Adapter,REG_RX_PKT_LIMIT,0x08);
-			rtw_write16(Adapter,(REG_TRXFF_BNDY+2), 0x13ff);
+			rtw_write8(adapter,REG_DMC, 0x0);
+			rtw_write8(adapter,REG_RX_PKT_LIMIT,0x08);
+			rtw_write16(adapter,(REG_TRXFF_BNDY+2), 0x13ff);
 			break;
 		case DUALMAC_SINGLEPHY:
-			rtw_write8(Adapter,REG_DMC, 0xf8);
-			rtw_write8(Adapter,REG_RX_PKT_LIMIT,0x08);
-			rtw_write16(Adapter,(REG_TRXFF_BNDY+2), 0x13ff);
+			rtw_write8(adapter,REG_DMC, 0xf8);
+			rtw_write8(adapter,REG_RX_PKT_LIMIT,0x08);
+			rtw_write16(adapter,(REG_TRXFF_BNDY+2), 0x13ff);
 			break;
 		case SINGLEMAC_SINGLEPHY:
-			rtw_write8(Adapter,REG_DMC, 0x0);
-			rtw_write8(Adapter,REG_RX_PKT_LIMIT,0x10);
-			rtw_write16(Adapter, (REG_TRXFF_BNDY + 2), 0x27FF);
+			rtw_write8(adapter,REG_DMC, 0x0);
+			rtw_write8(adapter,REG_RX_PKT_LIMIT,0x10);
+			rtw_write16(adapter, (REG_TRXFF_BNDY + 2), 0x27FF);
 			break;
 		default:
 			break;
@@ -6416,29 +6416,29 @@ void PHY_ConfigMacCoexist_RFPage92D(
 
 void
 rtl8192d_PHY_InitRxSetting(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
 #if MP_DRIVER == 1
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	if (pHalData->interfaceIndex == 0)
 	{
-		rtw_write32(Adapter, REG_MACID, 0x87654321);
-		rtw_write32(Adapter, 0x0700, 0x87654321);
+		rtw_write32(adapter, REG_MACID, 0x87654321);
+		rtw_write32(adapter, 0x0700, 0x87654321);
 	}
 	else
 	{
-		rtw_write32(Adapter, REG_MACID, 0x12345678);
-		rtw_write32(Adapter, 0x0700, 0x12345678);
+		rtw_write32(adapter, REG_MACID, 0x12345678);
+		rtw_write32(adapter, 0x0700, 0x12345678);
 	}
 #endif
 }
 
 
-void rtl8192d_PHY_ResetIQKResult(struct rtw_adapter *Adapter)
+void rtl8192d_PHY_ResetIQKResult(struct rtw_adapter *adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8			i;
 
 	for (i = 0; i < IQK_Matrix_Settings_NUM; i++) {
@@ -6456,30 +6456,30 @@ void rtl8192d_PHY_ResetIQKResult(struct
 	}
 }
 
-void rtl8192d_PHY_SetRFPathSwitch(struct rtw_adapter *pAdapter, bool main)
+void rtl8192d_PHY_SetRFPathSwitch(struct rtw_adapter *adapter, bool main)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 #if DISABLE_BB_RF
 	return ;
 #else
 
 	if (IS_92D_SINGLEPHY(pHalData->VersionID)) {
-		phy_SetRFPathSwitch(pAdapter, main, true);
+		phy_SetRFPathSwitch(adapter, main, true);
 	} else {
 		/*  For 88C 1T1R */
-		phy_SetRFPathSwitch(pAdapter, main, false);
+		phy_SetRFPathSwitch(adapter, main, false);
 	}
 #endif
 }
 
 void
 HalChangeCCKStatus8192D(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	bool		bCCKDisable
 )
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	i;
 
 
@@ -6490,13 +6490,13 @@ HalChangeCCKStatus8192D(
 
 	if (bCCKDisable)
 	{
-		rtw_write16(Adapter, REG_RL,0x0101);
+		rtw_write16(adapter, REG_RL,0x0101);
 		for (i=0;i<30;i++)
 		{
-			if (rtw_read32(Adapter, 0x200) != rtw_read32(Adapter, 0x204))
+			if (rtw_read32(adapter, 0x200) != rtw_read32(adapter, 0x204))
 			{
-				DBG_8192D("packet in tx packet buffer aaaaaaaaa 0x204 %x\n", rtw_read32(Adapter, 0x204));
-				DBG_8192D("packet in tx packet buffer aaaaaaa 0x200 %x\n", rtw_read32(Adapter, 0x200));
+				DBG_8192D("packet in tx packet buffer aaaaaaaaa 0x204 %x\n", rtw_read32(adapter, 0x204));
+				DBG_8192D("packet in tx packet buffer aaaaaaa 0x200 %x\n", rtw_read32(adapter, 0x200));
 				rtw_udelay_os(1000);
 			}
 			else
@@ -6505,17 +6505,17 @@ HalChangeCCKStatus8192D(
 			}
 		}
 
-		/*if ((BuddyAdapter != NULL) && BuddyAdapter->bHWInitReady && (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY))
+		/*if ((Buddyadapter != NULL) && Buddyadapter->bHWInitReady && (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY))
 		{
-			if (ACTING_AS_AP(BuddyAdapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(BuddyAdapter, FALSE)) || BuddyAdapter->MgntInfo.mIbss)
-				StopTxBeacon(BuddyAdapter);
-			PlatformEFIOWrite2Byte(BuddyAdapter, REG_RL,0x0101);
+			if (ACTING_AS_AP(Buddyadapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(Buddyadapter, FALSE)) || Buddyadapter->MgntInfo.mIbss)
+				StopTxBeacon(Buddyadapter);
+			PlatformEFIOWrite2Byte(Buddyadapter, REG_RL,0x0101);
 			for (i=0;i<30;i++)
 			{
-				if (PlatformEFIORead4Byte(BuddyAdapter, 0x200) != PlatformEFIORead4Byte(BuddyAdapter, 0x204))
+				if (PlatformEFIORead4Byte(Buddyadapter, 0x200) != PlatformEFIORead4Byte(Buddyadapter, 0x204))
 				{
-					RT_TRACE(COMP_EASY_CONCURRENT,DBG_LOUD,("packet in tx packet buffer aaaaaaaaa 0x204 %x\n", PlatformEFIORead4Byte(BuddyAdapter, 0x204)));
-					RT_TRACE(COMP_EASY_CONCURRENT,DBG_LOUD,("packet in tx packet buffer aaaaaaa 0x200 %x\n", PlatformEFIORead4Byte(BuddyAdapter, 0x200)));
+					RT_TRACE(COMP_EASY_CONCURRENT,DBG_LOUD,("packet in tx packet buffer aaaaaaaaa 0x204 %x\n", PlatformEFIORead4Byte(Buddyadapter, 0x204)));
+					RT_TRACE(COMP_EASY_CONCURRENT,DBG_LOUD,("packet in tx packet buffer aaaaaaa 0x200 %x\n", PlatformEFIORead4Byte(Buddyadapter, 0x200)));
 					PlatformStallExecution(1000);
 				}
 				else
@@ -6527,80 +6527,80 @@ HalChangeCCKStatus8192D(
 
 		}*/
 
-		PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 3);
+		PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 3);
 	}
 	else
 	{
 		u8	RetryLimit = 0x30;
 
-		rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+		rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
 	}
 }
 
 void
-PHY_InitPABias92D(struct rtw_adapter * Adapter)
+PHY_InitPABias92D(struct rtw_adapter * adapter)
 {
 	u8	tmpU1b;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	bool		is92 = IS_92D_SINGLEPHY(pHalData->VersionID);
 	enum RF_RADIO_PATH_E eRFPath = RF_PATH_A;
 
-	tmpU1b = EFUSE_Read1Byte(Adapter, 0x3FA);
+	tmpU1b = EFUSE_Read1Byte(adapter, 0x3FA);
 
 	DBG_8192D("PHY_InitPABias92D 0x3FA 0x%x\n",tmpU1b);
 
 	if (!(tmpU1b & BIT0) && (is92 || pHalData->interfaceIndex == 0))
 	{
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x07401);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F425);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F425);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F425);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x07401);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F425);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F425);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F425);
 
 		/* Back to RX Mode */
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x30000);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x30000);
 		DBG_8192D("2G PA BIAS path A\n");
 	}
 
 	if (!(tmpU1b & BIT1) && (is92 || pHalData->interfaceIndex == 1))
 	{
 		eRFPath = pHalData->interfaceIndex == 1?RF_PATH_A:RF_PATH_B;
-		PHY_SetRFReg(Adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x07401);
-		PHY_SetRFReg(Adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
-		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F425);
-		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F425);
-		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F425);
+		PHY_SetRFReg(adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x07401);
+		PHY_SetRFReg(adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F425);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F425);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F425);
 
 		/* Back to RX Mode */
-		PHY_SetRFReg(Adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x30000);
+		PHY_SetRFReg(adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x30000);
 		DBG_8192D("2G PA BIAS path B\n");
 	}
 
 	if (!(tmpU1b & BIT2) && (is92 || pHalData->interfaceIndex == 0))
 	{
 		/* 5GL_channel */
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x17524);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F496);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F496);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x17524);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F496);
 
 		/* 5GM_channel */
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x37564);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F496);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F496);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x37564);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F496);
 
 		/* 5GH_channel */
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x57595);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F496);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F496);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x57595);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F496);
 
 		/* Back to RX Mode */
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x30000);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x30000);
 
 		DBG_8192D("5G PA BIAS path A\n");
 	}
@@ -6609,28 +6609,28 @@ PHY_InitPABias92D(struct rtw_adapter * A
 	{
 		eRFPath = (pHalData->interfaceIndex == 1)?RF_PATH_A:RF_PATH_B;
 		/* 5GL_channel */
-		PHY_SetRFReg(Adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x17524);
-		PHY_SetRFReg(Adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
-		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F496);
-		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F496);
-		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x17524);
+		PHY_SetRFReg(adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F496);
 
 		/* 5GM_channel */
-		PHY_SetRFReg(Adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x37564);
-		PHY_SetRFReg(Adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
-		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F496);
-		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F496);
-		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x37564);
+		PHY_SetRFReg(adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F496);
 
 		/* 5GH_channel */
-		PHY_SetRFReg(Adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x57595);
-		PHY_SetRFReg(Adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
-		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F496);
-		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F496);
-		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x57595);
+		PHY_SetRFReg(adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F496);
 
 		/* Back to RX Mode */
-		PHY_SetRFReg(Adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x30000);
+		PHY_SetRFReg(adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x30000);
 		DBG_8192D("5G PA BIAS path B\n");
 	}
 }
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
@@ -92,7 +92,7 @@ static	struct rf_shadow_compare_map RF_S
  *						Firmwaer support the utility later.
  *
  *---------------------------------------------------------------------------*/
-void rtl8192d_RF_ChangeTxPath(	struct rtw_adapter *	Adapter,
+void rtl8192d_RF_ChangeTxPath(	struct rtw_adapter *	adapter,
 										u16		DataRate)
 {
 /*  We do not support gain table change inACUT now !!!! Delete later !!! */
@@ -104,7 +104,7 @@ void rtl8192d_RF_ChangeTxPath(	struct rt
  *
  * Overview:    This function is called by SetBWModeCallback8190Pci() only
  *
- * Input:       struct rtw_adapter *				Adapter
+ * Input:       struct rtw_adapter *				adapter
  *			WIRELESS_BANDWIDTH_E	Bandwidth	20M or 40M
  *
  * Output:      NONE
@@ -115,11 +115,11 @@ void rtl8192d_RF_ChangeTxPath(	struct rt
  *---------------------------------------------------------------------------*/
 void
 rtl8192d_PHY_RF6052SetBandwidth(
-	struct rtw_adapter *				Adapter,
+	struct rtw_adapter *				adapter,
 	enum HT_CHANNEL_WIDTH		Bandwidth)	/* 20M or 40M */
 {
 	u8			eRFPath;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	switch (Bandwidth)
 	{
@@ -127,7 +127,7 @@ rtl8192d_PHY_RF6052SetBandwidth(
 			for (eRFPath=0;eRFPath<pHalData->NumTotalRFPath;eRFPath++)
 			{
 				pHalData->RfRegChnlVal[eRFPath] = ((pHalData->RfRegChnlVal[eRFPath] & 0xfffff3ff) | 0x0400);
-				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT10|BIT11, 0x01);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT10|BIT11, 0x01);
 
 			}
 			break;
@@ -136,7 +136,7 @@ rtl8192d_PHY_RF6052SetBandwidth(
 			for (eRFPath=0;eRFPath<pHalData->NumTotalRFPath;eRFPath++)
 			{
 				pHalData->RfRegChnlVal[eRFPath] = ((pHalData->RfRegChnlVal[eRFPath] & 0xfffff3ff));
-				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT10|BIT11, 0x00);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT10|BIT11, 0x00);
 			}
 			break;
 
@@ -165,11 +165,11 @@ rtl8192d_PHY_RF6052SetBandwidth(
 
 void
 rtl8192d_PHY_RF6052SetCckTxPower(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	u8*			pPowerlevel)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 	u32			TxAGC[2]={0, 0}, tmpval=0;
 	bool		TurboScanOff = false;
 	u8			idx1, idx2;
@@ -235,15 +235,15 @@ rtl8192d_PHY_RF6052SetCckTxPower(
 
 	/*  rf-A cck tx power */
 	tmpval = TxAGC[RF_PATH_A]&0xff;
-	PHY_SetBBReg(Adapter, rTxAGC_A_CCK1_Mcs32, bMaskByte1, tmpval);
+	PHY_SetBBReg(adapter, rTxAGC_A_CCK1_Mcs32, bMaskByte1, tmpval);
 	tmpval = TxAGC[RF_PATH_A]>>8;
-	PHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, 0xffffff00, tmpval);
+	PHY_SetBBReg(adapter, rTxAGC_B_CCK11_A_CCK2_11, 0xffffff00, tmpval);
 
 	/*  rf-B cck tx power */
 	tmpval = TxAGC[RF_PATH_B]>>24;
-	PHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, bMaskByte0, tmpval);
+	PHY_SetBBReg(adapter, rTxAGC_B_CCK11_A_CCK2_11, bMaskByte0, tmpval);
 	tmpval = TxAGC[RF_PATH_B]&0x00ffffff;
-	PHY_SetBBReg(Adapter, rTxAGC_B_CCK1_55_Mcs32, 0xffffff00, tmpval);
+	PHY_SetBBReg(adapter, rTxAGC_B_CCK1_55_Mcs32, 0xffffff00, tmpval);
 }	/* PHY_RF6052SetCckTxPower */
 
 /*  */
@@ -251,14 +251,14 @@ rtl8192d_PHY_RF6052SetCckTxPower(
 /*  powerbase1 for HT MCS rates */
 /*  */
 static void getPowerBase(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8		*pPowerLevel,
 	u8		Channel,
 	u32	*OfdmBase,
 	u32	*MCSBase
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u32	powerBase0, powerBase1;
 	u8	Legacy_pwrdiff=0;
 	s8	HT20_pwrdiff=0;
@@ -313,7 +313,7 @@ static u8 getChnlGroupByPG(u8 chnlindex)
 }
 
 static void getTxPowerWriteValByRegulatory(
-		struct rtw_adapter *	Adapter,
+		struct rtw_adapter *	adapter,
 		u8*			pPowerLevel,
 		u8			Channel,
 		u8			index,
@@ -322,7 +322,7 @@ static void getTxPowerWriteValByRegulato
 		u32*		pOutWriteVal
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u8	i, chnlGroup=0, pwr_diff_limit[4], customer_pwr_limit;
 	s8	pwr_diff=0;
@@ -422,12 +422,12 @@ static void getTxPowerWriteValByRegulato
 }
 
 static void writeOFDMPowerReg(
-		struct rtw_adapter *	Adapter,
+		struct rtw_adapter *	adapter,
 		u8			index,
 		u32			*pValue
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u16	RegOffset_A[6] = {rTxAGC_A_Rate18_06, rTxAGC_A_Rate54_24,
 				  rTxAGC_A_Mcs03_Mcs00, rTxAGC_A_Mcs07_Mcs04,
 				  rTxAGC_A_Mcs11_Mcs08, rTxAGC_A_Mcs15_Mcs12};
@@ -453,7 +453,7 @@ static void writeOFDMPowerReg(
 			RegOffset = RegOffset_A[index];
 		else
 			RegOffset = RegOffset_B[index];
-		PHY_SetBBReg(Adapter, RegOffset, bMaskDWord, writeVal);
+		PHY_SetBBReg(adapter, RegOffset, bMaskDWord, writeVal);
 
 		/*  201005115 Joseph: Set Tx Power diff for Tx power training mechanism. */
 		if (((pHalData->rf_type == RF_2T2R) &&
@@ -472,7 +472,7 @@ static void writeOFDMPowerReg(
 					writeVal = (writeVal>8)?(writeVal-8):0;
 				else
 					writeVal = (writeVal>6)?(writeVal-6):0;
-				rtw_write8(Adapter, (u32)(RegOffset+i), (u8)writeVal);
+				rtw_write8(adapter, (u32)(RegOffset+i), (u8)writeVal);
 			}
 		}
 	}
@@ -501,27 +501,27 @@ static void writeOFDMPowerReg(
  *---------------------------------------------------------------------------*/
 void
 rtl8192d_PHY_RF6052SetOFDMTxPower(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8*		pPowerLevel,
 	u8		Channel)
 {
 	u32	writeVal[2], powerBase0[2], powerBase1[2];
 	u8	index = 0;
 
-	getPowerBase(Adapter, pPowerLevel, Channel, &powerBase0[0], &powerBase1[0]);
+	getPowerBase(adapter, pPowerLevel, Channel, &powerBase0[0], &powerBase1[0]);
 
 	for (index=0; index<6; index++)
 	{
-		getTxPowerWriteValByRegulatory(Adapter, pPowerLevel, Channel, index,
+		getTxPowerWriteValByRegulatory(adapter, pPowerLevel, Channel, index,
 			&powerBase0[0], &powerBase1[0], &writeVal[0]);
 
-		writeOFDMPowerReg(Adapter, index, &writeVal[0]);
+		writeOFDMPowerReg(adapter, index, &writeVal[0]);
 	}
 }
 
 bool
 rtl8192d_PHY_EnableAnotherPHY(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	bool			bMac0
 	)
 {
@@ -532,7 +532,7 @@ rtl8192d_PHY_EnableAnotherPHY(
 	u32			MaskForPHYSet = 0;
 
 	/* MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write. */
-	u1bTmp = rtw_read8(Adapter, MAC_REG);
+	u1bTmp = rtw_read8(adapter, MAC_REG);
 
 	if (!(u1bTmp&MAC_ON_BIT))
 	{
@@ -541,8 +541,8 @@ rtl8192d_PHY_EnableAnotherPHY(
 			MaskForPHYSet = MAC0_ACCESS_PHY1;
 		else
 			MaskForPHYSet = MAC1_ACCESS_PHY0;
-		rtw_write16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet, rtw_read16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet)&0xFFFC);
-		rtw_write16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet, rtw_read16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet)|BIT13|BIT0|BIT1);
+		rtw_write16(adapter, REG_SYS_FUNC_EN|MaskForPHYSet, rtw_read16(adapter, REG_SYS_FUNC_EN|MaskForPHYSet)&0xFFFC);
+		rtw_write16(adapter, REG_SYS_FUNC_EN|MaskForPHYSet, rtw_read16(adapter, REG_SYS_FUNC_EN|MaskForPHYSet)|BIT13|BIT0|BIT1);
 	} else {
 		/*  We think if MAC1 is ON,then radio_a.txt and radio_b.txt has been load. */
 		bResult = false;
@@ -552,7 +552,7 @@ rtl8192d_PHY_EnableAnotherPHY(
 
 void
 rtl8192d_PHY_PowerDownAnotherPHY(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	bool			bMac0
 	)
 {
@@ -562,7 +562,7 @@ rtl8192d_PHY_PowerDownAnotherPHY(
 	u32	MaskforPhySet = 0;
 
 	/*  check MAC0 enable or not again now, if enabled, not power down radio A. */
-	u1bTmp = rtw_read8(Adapter, MAC_REG);
+	u1bTmp = rtw_read8(adapter, MAC_REG);
 
 	if (!(u1bTmp&MAC_ON_BIT)) {
 		/*  power down RF radio A according to YuNan's advice. */
@@ -570,21 +570,21 @@ rtl8192d_PHY_PowerDownAnotherPHY(
 			MaskforPhySet = MAC0_ACCESS_PHY1;
 		else
 			MaskforPhySet = MAC1_ACCESS_PHY0;
-		  rtw_write32(Adapter, rFPGA0_XA_LSSIParameter|MaskforPhySet, 0x00000000);
+		  rtw_write32(adapter, rFPGA0_XA_LSSIParameter|MaskforPhySet, 0x00000000);
 	}
 
 }
 
 static int
 phy_RF6052_Config_ParaFile(
-	struct rtw_adapter *		Adapter
+	struct rtw_adapter *		adapter
 	)
 {
 	u32	u4RegValue=0;
 	u8	eRFPath;
 	struct bb_register_def *pPhyReg;
 	int	rtStatus = _SUCCESS;
-	struct hal_data_8192du	*pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 #ifndef CONFIG_EMBEDDED_FWIMG
 	u8	*pszRadioAFile = NULL;
@@ -618,7 +618,7 @@ phy_RF6052_Config_ParaFile(
 		if (pHalData->CurrentBandType92D == BAND_ON_2_4G && pHalData->interfaceIndex == 0)
 		{
 			/* MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write. */
-			if (rtl8192d_PHY_EnableAnotherPHY(Adapter, true))
+			if (rtl8192d_PHY_EnableAnotherPHY(adapter, true))
 			{
 				pHalData->NumTotalRFPath = 2;
 				bMac0NeedInitRadioBFirst = true;
@@ -632,7 +632,7 @@ phy_RF6052_Config_ParaFile(
 		else if (pHalData->CurrentBandType92D == BAND_ON_5G && pHalData->interfaceIndex == 1)
 		{
 			/* MAC1 Need PHY0 load radio_a.txt . Driver use DBI to write. */
-			if (rtl8192d_PHY_EnableAnotherPHY(Adapter, false))
+			if (rtl8192d_PHY_EnableAnotherPHY(adapter, false))
 			{
 				pHalData->NumTotalRFPath = 2;
 				bMac1NeedInitRadioAFirst = true;
@@ -706,27 +706,27 @@ phy_RF6052_Config_ParaFile(
 		{
 			case RF_PATH_A:
 			case RF_PATH_C:
-				u4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV);
+				u4RegValue = PHY_QueryBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV);
 				break;
 			case RF_PATH_B :
 			case RF_PATH_D:
-				u4RegValue = PHY_QueryBBReg(Adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16);
+				u4RegValue = PHY_QueryBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16);
 				break;
 		}
 
 		/*----Set RF_ENV enable----*/
-		PHY_SetBBReg(Adapter, pPhyReg->rfintfe|MaskforPhySet, bRFSI_RFENV<<16, 0x1);
+		PHY_SetBBReg(adapter, pPhyReg->rfintfe|MaskforPhySet, bRFSI_RFENV<<16, 0x1);
 		rtw_udelay_os(1);/* PlatformStallExecution(1); */
 
 		/*----Set RF_ENV output high----*/
-		PHY_SetBBReg(Adapter, pPhyReg->rfintfo|MaskforPhySet, bRFSI_RFENV, 0x1);
+		PHY_SetBBReg(adapter, pPhyReg->rfintfo|MaskforPhySet, bRFSI_RFENV, 0x1);
 		rtw_udelay_os(1);/* PlatformStallExecution(1); */
 
 		/* Set bit number of Address and Data for RF register */
-		PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireAddressLength, 0x0);	/*  Set 1 to 4 bits for 8255 */
+		PHY_SetBBReg(adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireAddressLength, 0x0);	/*  Set 1 to 4 bits for 8255 */
 		rtw_udelay_os(1);/* PlatformStallExecution(1); */
 
-		PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireDataLength, 0x0);	/*  Set 0 to 12  bits for 8255 */
+		PHY_SetBBReg(adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireDataLength, 0x0);	/*  Set 0 to 12  bits for 8255 */
 		rtw_udelay_os(1);/* PlatformStallExecution(1); */
 
 		/*----Initialize RF fom connfiguration file----*/
@@ -736,18 +736,18 @@ phy_RF6052_Config_ParaFile(
 #ifdef CONFIG_EMBEDDED_FWIMG
 				/* vivi added this for read parameter from header, 20100908 */
 				if (bTrueBPath == true)
-					rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(Adapter,radiob_txt|MaskforPhySet, (enum RF_RADIO_PATH_E)eRFPath);
+					rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(adapter,radiob_txt|MaskforPhySet, (enum RF_RADIO_PATH_E)eRFPath);
 				else
-					rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(Adapter,radioa_txt|MaskforPhySet, (enum RF_RADIO_PATH_E)eRFPath);
+					rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(adapter,radioa_txt|MaskforPhySet, (enum RF_RADIO_PATH_E)eRFPath);
 #else
-				rtStatus = rtl8192d_PHY_ConfigRFWithParaFile(Adapter, pszRadioAFile, (enum RF_RADIO_PATH_E)eRFPath);
+				rtStatus = rtl8192d_PHY_ConfigRFWithParaFile(adapter, pszRadioAFile, (enum RF_RADIO_PATH_E)eRFPath);
 #endif
 				break;
 			case RF_PATH_B:
 #ifdef CONFIG_EMBEDDED_FWIMG
-			rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(Adapter,radiob_txt, (enum RF_RADIO_PATH_E)eRFPath);
+			rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(adapter,radiob_txt, (enum RF_RADIO_PATH_E)eRFPath);
 #else
-			rtStatus = rtl8192d_PHY_ConfigRFWithParaFile(Adapter, pszRadioBFile, (enum RF_RADIO_PATH_E)eRFPath);
+			rtStatus = rtl8192d_PHY_ConfigRFWithParaFile(adapter, pszRadioBFile, (enum RF_RADIO_PATH_E)eRFPath);
 #endif
 				break;
 			case RF_PATH_C:
@@ -761,11 +761,11 @@ phy_RF6052_Config_ParaFile(
 		{
 			case RF_PATH_A:
 			case RF_PATH_C:
-				PHY_SetBBReg(Adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV, u4RegValue);
+				PHY_SetBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV, u4RegValue);
 				break;
 			case RF_PATH_B :
 			case RF_PATH_D:
-				PHY_SetBBReg(Adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16, u4RegValue);
+				PHY_SetBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16, u4RegValue);
 				break;
 		}
 
@@ -778,20 +778,20 @@ phy_RF6052_Config_ParaFile(
 	if (bNeedPowerDownRadioA)
 	{
 		/*  check MAC0 enable or not again now, if enabled, not power down radio A. */
-		rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
+		rtl8192d_PHY_PowerDownAnotherPHY(adapter, false);
 	}
 	else  if (bNeedPowerDownRadioB)
 	{
 		/*  check MAC1 enable or not again now, if enabled, not power down radio B. */
-		rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
+		rtl8192d_PHY_PowerDownAnotherPHY(adapter, true);
 	}
 
 	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 	{
 #if MP_DRIVER == 1
-		PHY_SetRFReg(Adapter, eRFPath, RF_RXRF_A3, bRFRegOffsetMask, 0xff456);
+		PHY_SetRFReg(adapter, eRFPath, RF_RXRF_A3, bRFRegOffsetMask, 0xff456);
 #endif
-		pdmpriv->RegRF3C[eRFPath] = PHY_QueryRFReg(Adapter, eRFPath, RF_RXRF_A3, bRFRegOffsetMask);
+		pdmpriv->RegRF3C[eRFPath] = PHY_QueryRFReg(adapter, eRFPath, RF_RXRF_A3, bRFRegOffsetMask);
 	}
 
 	return rtStatus;
@@ -802,9 +802,9 @@ phy_RF6052_Config_ParaFile_Fail:
 
 int
 PHY_RF6052_Config8192D(
-	struct rtw_adapter *		Adapter)
+	struct rtw_adapter *		adapter)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	int rtStatus = _SUCCESS;
 
 	/*  */
@@ -827,7 +827,7 @@ PHY_RF6052_Config8192D(
 	/*  */
 	/*  Config BB and RF */
 	/*  */
-	rtStatus = phy_RF6052_Config_ParaFile(Adapter);
+	rtStatus = phy_RF6052_Config_ParaFile(adapter);
 
 	return rtStatus;
 }
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -157,12 +157,12 @@ static void _ThreeOutEpMapping(
 
 static bool
 _MappingOutEP(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u8		NumOutPipe
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
-	struct registry_priv *pregistrypriv = &pAdapter->registrypriv;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
 
 	bool	 bWIFICfg = (pregistrypriv->wifi_spec) ?true:false;
 
@@ -189,21 +189,21 @@ _MappingOutEP(
 
 static void
 _ConfigChipOutEP(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u8		NumOutPipe
 	)
 {
 	u8			value8;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	pHalData->OutEpQueueSel = 0;
 	pHalData->OutEpNumber = 0;
 
 	/*  Normal and High queue */
 	if (pHalData->interfaceIndex==0)
-		value8=rtw_read8(pAdapter, REG_USB_High_NORMAL_Queue_Select_MAC0);
+		value8=rtw_read8(adapter, REG_USB_High_NORMAL_Queue_Select_MAC0);
 	else
-		value8=rtw_read8(pAdapter, REG_USB_High_NORMAL_Queue_Select_MAC1);
+		value8=rtw_read8(adapter, REG_USB_High_NORMAL_Queue_Select_MAC1);
 
 	if (value8 & USB_NORMAL_SIE_EP_MASK) {
 		pHalData->OutEpQueueSel |= TX_SELE_HQ;
@@ -217,9 +217,9 @@ _ConfigChipOutEP(
 
 	/*  Low queue */
 	if (pHalData->interfaceIndex==0)
-		value8=rtw_read8(pAdapter, (REG_USB_High_NORMAL_Queue_Select_MAC0+1));
+		value8=rtw_read8(adapter, (REG_USB_High_NORMAL_Queue_Select_MAC0+1));
 	else
-		value8=rtw_read8(pAdapter, (REG_USB_High_NORMAL_Queue_Select_MAC1+1));
+		value8=rtw_read8(adapter, (REG_USB_High_NORMAL_Queue_Select_MAC1+1));
 
 	if (value8 & USB_NORMAL_SIE_EP_MASK) {
 		pHalData->OutEpQueueSel |= TX_SELE_LQ;
@@ -249,15 +249,15 @@ _ConfigChipOutEP(
 }
 
 static bool HalUsbSetQueuePipeMapping8192DUsb(
-	struct rtw_adapter *	pAdapter,
+	struct rtw_adapter *	adapter,
 	u8		NumInPipe,
 	u8		NumOutPipe
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	bool			result		= false;
 
-	_ConfigChipOutEP(pAdapter, NumOutPipe);
+	_ConfigChipOutEP(adapter, NumOutPipe);
 
 	/*  Normal chip with one IN and one OUT doesn't have interrupt IN EP. */
 	if (1 == pHalData->OutEpNumber) {
@@ -266,7 +266,7 @@ static bool HalUsbSetQueuePipeMapping819
 		}
 	}
 
-	result = _MappingOutEP(pAdapter, NumOutPipe);
+	result = _MappingOutEP(adapter, NumOutPipe);
 
 	return result;
 }
@@ -641,7 +641,7 @@ void rtw_wowlan_reload_pattern(struct rt
 /*  */
 /*  */
 static u8 _LLTWrite(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u32		address,
 	u32		data
 	)
@@ -650,12 +650,12 @@ static u8 _LLTWrite(
 	int	count = 0;
 	u32	value = _LLT_INIT_ADDR(address) | _LLT_INIT_DATA(data) | _LLT_OP(_LLT_WRITE_ACCESS);
 
-	rtw_write32(Adapter, REG_LLT_INIT, value);
+	rtw_write32(adapter, REG_LLT_INIT, value);
 
 	/* polling */
 	do{
 
-		value = rtw_read32(Adapter, REG_LLT_INIT);
+		value = rtw_read32(adapter, REG_LLT_INIT);
 		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)) {
 			break;
 		}
@@ -671,19 +671,19 @@ static u8 _LLTWrite(
 }
 
 static u8 _LLTRead(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u32		address
 	)
 {
 	int		count = 0;
 	u32		value = _LLT_INIT_ADDR(address) | _LLT_OP(_LLT_READ_ACCESS);
 
-	rtw_write32(Adapter, REG_LLT_INIT, value);
+	rtw_write32(adapter, REG_LLT_INIT, value);
 
 	/* polling and get value */
 	do{
 
-		value = rtw_read32(Adapter, REG_LLT_INIT);
+		value = rtw_read32(adapter, REG_LLT_INIT);
 		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)) {
 			return (u8)value;
 		}
@@ -698,7 +698,7 @@ static u8 _LLTRead(
 }
 
 static u8 InitLLTTable(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u32		boundary
 	)
 {
@@ -706,7 +706,7 @@ static u8 InitLLTTable(
 	u32		i;
 	u32		txpktbuf_bndy = boundary;
 	u32		Last_Entry_Of_TxPktBuf = LAST_ENTRY_OF_TX_PKT_BUFFER;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 
 	if (pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY) {
@@ -722,14 +722,14 @@ static u8 InitLLTTable(
 	}
 
 	for (i = 0 ; i < (txpktbuf_bndy - 1) ; i++) {
-		status = _LLTWrite(Adapter, i , i + 1);
+		status = _LLTWrite(adapter, i , i + 1);
 		if (_SUCCESS != status) {
 			return status;
 		}
 	}
 
 	/*  end of list */
-	status = _LLTWrite(Adapter, (txpktbuf_bndy - 1), 0xFF);
+	status = _LLTWrite(adapter, (txpktbuf_bndy - 1), 0xFF);
 	if (_SUCCESS != status) {
 		return status;
 	}
@@ -738,14 +738,14 @@ static u8 InitLLTTable(
 	/*  This ring buffer is used as beacon buffer if we config this MAC as two MAC transfer. */
 	/*  Otherwise used as local loopback buffer. */
 	for (i = txpktbuf_bndy ; i < Last_Entry_Of_TxPktBuf ; i++) {
-		status = _LLTWrite(Adapter, i, (i + 1));
+		status = _LLTWrite(adapter, i, (i + 1));
 		if (_SUCCESS != status) {
 			return status;
 		}
 	}
 
 	/*  Let last entry point to the start entry of ring buffer */
-	status = _LLTWrite(Adapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);
+	status = _LLTWrite(adapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);
 	if (_SUCCESS != status) {
 		return status;
 	}
@@ -760,60 +760,60 @@ static u8 InitLLTTable(
 /*  */
 static void
 _SetMacID(
-	struct rtw_adapter * Adapter, u8* MacID
+	struct rtw_adapter * adapter, u8* MacID
 	)
 {
 	u32 i;
 	for (i=0 ; i< MAC_ADDR_LEN ; i++) {
 #ifdef  CONFIG_CONCURRENT_MODE
-		if (Adapter->iface_type == IFACE_PORT1)
-			rtw_write32(Adapter, REG_MACID1+i, MacID[i]);
+		if (adapter->iface_type == IFACE_PORT1)
+			rtw_write32(adapter, REG_MACID1+i, MacID[i]);
 		else
 #endif
-		rtw_write32(Adapter, REG_MACID+i, MacID[i]);
+		rtw_write32(adapter, REG_MACID+i, MacID[i]);
 	}
 }
 
 static void
 _SetBSSID(
-	struct rtw_adapter * Adapter, u8* BSSID
+	struct rtw_adapter * adapter, u8* BSSID
 	)
 {
 	u32 i;
 	for (i=0 ; i< MAC_ADDR_LEN ; i++) {
 #ifdef  CONFIG_CONCURRENT_MODE
-		if (Adapter->iface_type == IFACE_PORT1)
-			rtw_write32(Adapter, REG_BSSID1+i, BSSID[i]);
+		if (adapter->iface_type == IFACE_PORT1)
+			rtw_write32(adapter, REG_BSSID1+i, BSSID[i]);
 		else
 #endif
-		rtw_write32(Adapter, REG_BSSID+i, BSSID[i]);
+		rtw_write32(adapter, REG_BSSID+i, BSSID[i]);
 	}
 }
 
 /*  Shall USB interface init this? */
 static void
 _InitInterrupt(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
 	u32	value32;
 
 	/*  HISR - turn all on */
 	value32 = 0xFFFFFFFF;
-	rtw_write32(Adapter, REG_HISR, value32);
+	rtw_write32(adapter, REG_HISR, value32);
 
 	/*  HIMR - turn all on */
-	rtw_write32(Adapter, REG_HIMR, value32);
+	rtw_write32(adapter, REG_HIMR, value32);
 }
 
 
 static void
 _InitQueueReservedPage(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
 
 	u32			outEPNum	= (u32)pHalData->OutEpNumber;
 	u32			numHQ		= 0;
@@ -866,7 +866,7 @@ _InitQueueReservedPage(
 				numNQ = txQPageUnit;
 
 			value8 = (u8)_NPQ(numNQ);
-			rtw_write8(Adapter, REG_RQPN_NPQ, value8);
+			rtw_write8(adapter, REG_RQPN_NPQ, value8);
 		}
 	}
 	else { /* for WMM */
@@ -887,22 +887,22 @@ _InitQueueReservedPage(
 		if (pHalData->OutEpQueueSel & TX_SELE_NQ) {
 			numNQ = (outEPNum==2)?WMM_NORMAL_PAGE_NUM_NPQ:WMM_NORMAL_PAGE_NUM_NPQ_92D;
 			value8 = (u8)_NPQ(numNQ);
-			rtw_write8(Adapter, REG_RQPN_NPQ, value8);
+			rtw_write8(adapter, REG_RQPN_NPQ, value8);
 		}
 	}
 
 	/*  TX DMA */
 	value32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;
-	rtw_write32(Adapter, REG_RQPN, value32);
+	rtw_write32(adapter, REG_RQPN, value32);
 }
 
 static void
 _InitTxBufferBoundary(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
-	struct hal_data_8192du *pHalData	= GET_HAL_DATA(Adapter);
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+	struct hal_data_8192du *pHalData	= GET_HAL_DATA(adapter);
 
 	/* u16	txdmactrl; */
 	u8	txpktbuf_bndy;
@@ -917,17 +917,17 @@ _InitTxBufferBoundary(
 	if (pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY)
 		txpktbuf_bndy = TX_PAGE_BOUNDARY_DUAL_MAC;
 
-	rtw_write8(Adapter, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);
-	rtw_write8(Adapter, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);
-	rtw_write8(Adapter, REG_TXPKTBUF_WMAC_LBK_BF_HD, txpktbuf_bndy);
-	rtw_write8(Adapter, REG_TRXFF_BNDY, txpktbuf_bndy);
-	rtw_write8(Adapter, REG_TDECTRL+1, txpktbuf_bndy);
+	rtw_write8(adapter, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);
+	rtw_write8(adapter, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);
+	rtw_write8(adapter, REG_TXPKTBUF_WMAC_LBK_BF_HD, txpktbuf_bndy);
+	rtw_write8(adapter, REG_TRXFF_BNDY, txpktbuf_bndy);
+	rtw_write8(adapter, REG_TDECTRL+1, txpktbuf_bndy);
 }
 
 
 static void
 _InitNormalChipRegPriority(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u16		beQ,
 	u16		bkQ,
 	u16		viQ,
@@ -936,21 +936,21 @@ _InitNormalChipRegPriority(
 	u16		hiQ
 	)
 {
-	u16 value16		= (rtw_read16(Adapter, REG_TRXDMA_CTRL) & 0x7);
+	u16 value16		= (rtw_read16(adapter, REG_TRXDMA_CTRL) & 0x7);
 
 	value16 |=	_TXDMA_BEQ_MAP(beQ)	| _TXDMA_BKQ_MAP(bkQ) |
 				_TXDMA_VIQ_MAP(viQ)	| _TXDMA_VOQ_MAP(voQ) |
 				_TXDMA_MGQ_MAP(mgtQ)| _TXDMA_HIQ_MAP(hiQ);
 
-	rtw_write16(Adapter, REG_TRXDMA_CTRL, value16);
+	rtw_write16(adapter, REG_TRXDMA_CTRL, value16);
 }
 
 static void
 _InitNormalChipOneOutEpPriority(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-	struct hal_data_8192du *pHalData	= GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData	= GET_HAL_DATA(adapter);
 
 	u16	value = 0;
 	switch (pHalData->OutEpQueueSel)
@@ -969,7 +969,7 @@ _InitNormalChipOneOutEpPriority(
 			break;
 	}
 
-	_InitNormalChipRegPriority(Adapter,
+	_InitNormalChipRegPriority(adapter,
 								value,
 								value,
 								value,
@@ -981,11 +981,11 @@ _InitNormalChipOneOutEpPriority(
 
 static void
 _InitNormalChipTwoOutEpPriority(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-	struct hal_data_8192du *pHalData	= GET_HAL_DATA(Adapter);
-	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
+	struct hal_data_8192du *pHalData	= GET_HAL_DATA(adapter);
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
 
 
@@ -1028,15 +1028,15 @@ _InitNormalChipTwoOutEpPriority(
 		hiQ		= valueHi;
 	}
 
-	_InitNormalChipRegPriority(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
+	_InitNormalChipRegPriority(adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
 }
 
 static void
 _InitNormalChipThreeOutEpPriority(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
 
 	if (!pregistrypriv->wifi_spec) {/*  typical setting */
@@ -1055,26 +1055,26 @@ _InitNormalChipThreeOutEpPriority(
 		mgtQ	= QUEUE_HIGH;
 		hiQ		= QUEUE_HIGH;
 	}
-	_InitNormalChipRegPriority(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
+	_InitNormalChipRegPriority(adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
 }
 
 static void
 _InitQueuePriority(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-	struct hal_data_8192du *pHalData	= GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData	= GET_HAL_DATA(adapter);
 
 	switch (pHalData->OutEpNumber)
 	{
 		case 1:
-			_InitNormalChipOneOutEpPriority(Adapter);
+			_InitNormalChipOneOutEpPriority(adapter);
 			break;
 		case 2:
-			_InitNormalChipTwoOutEpPriority(Adapter);
+			_InitNormalChipTwoOutEpPriority(adapter);
 			break;
 		case 3:
-			_InitNormalChipThreeOutEpPriority(Adapter);
+			_InitNormalChipThreeOutEpPriority(adapter);
 			break;
 		default:
 			/* RT_ASSERT(FALSE,("Shall not reach here!\n")); */
@@ -1084,22 +1084,22 @@ _InitQueuePriority(
 #if ENABLE_USB_DROP_INCORRECT_OUT /* amy,temp remove */
 static void
 _InitHardwareDropIncorrectBulkOut(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-	u32	value32 = rtw_read32(Adapter, REG_TXDMA_OFFSET_CHK);
+	u32	value32 = rtw_read32(adapter, REG_TXDMA_OFFSET_CHK);
 	value32 |= DROP_DATA_EN;
-	rtw_write32(Adapter, REG_TXDMA_OFFSET_CHK, value32);
+	rtw_write32(adapter, REG_TXDMA_OFFSET_CHK, value32);
 }
 #endif /* ENABLE_USB_DROP_INCORRECT_OUT, amy,temp remove */
 static void
 _InitNetworkType(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
 	u32	value32;
 
-	value32 = rtw_read32(Adapter, REG_CR);
+	value32 = rtw_read32(adapter, REG_CR);
 
 	/*  TODO: use the other function to set network type */
 #if RTL8191C_FPGA_NETWORKTYPE_ADHOC
@@ -1107,39 +1107,39 @@ _InitNetworkType(
 #else
 	value32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AP);
 #endif
-	rtw_write32(Adapter, REG_CR, value32);
+	rtw_write32(adapter, REG_CR, value32);
 /* 	RASSERT(pIoBase->rtw_read8(REG_CR + 2) == 0x2); */
 }
 
 static void
 _InitTransferPageSize(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
 	/*  Tx page size is always 128. */
 
 	u8	value8;
 	value8 = _PSRX(PBP_128) | _PSTX(PBP_128);
-	rtw_write8(Adapter, REG_PBP, value8);
+	rtw_write8(adapter, REG_PBP, value8);
 }
 
 static void
 _InitDriverInfoSize(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8		drvInfoSize
 	)
 {
-	rtw_write8(Adapter,REG_RX_DRVINFO_SZ, drvInfoSize);
+	rtw_write8(adapter,REG_RX_DRVINFO_SZ, drvInfoSize);
 }
 
 static void
 _InitWMACSetting(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
 	/* u4Byte			value32; */
 	/* u16			value16; */
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	/* pHalData->ReceiveConfig = AAP | APM | AM | AB | APP_ICV | ADF | AMF | APP_FCS | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS; */
 	/* pHalData->ReceiveConfig = AAP | APM | AM | AB | CBSSID |CBSSID_BCN | APP_ICV | AMF | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS; */
@@ -1152,35 +1152,35 @@ _InitWMACSetting(
 	pHalData->ReceiveConfig |= ACRC32;
 #endif
 
-	rtw_write32(Adapter, REG_RCR, pHalData->ReceiveConfig);
+	rtw_write32(adapter, REG_RCR, pHalData->ReceiveConfig);
 
 	/*  Accept all multicast address */
-	rtw_write32(Adapter, REG_MAR, 0xFFFFFFFF);
-	rtw_write32(Adapter, REG_MAR+4, 0xFFFFFFFF);
+	rtw_write32(adapter, REG_MAR, 0xFFFFFFFF);
+	rtw_write32(adapter, REG_MAR+4, 0xFFFFFFFF);
 
 	/*  Accept all data frames */
 	/* value16 = 0xFFFF; */
-	/* rtw_write16(Adapter, REG_RXFLTMAP2, value16); */
+	/* rtw_write16(adapter, REG_RXFLTMAP2, value16); */
 
 	/*  Accept all management frames */
 	/* value16 = 0xFFFF; */
-	/* rtw_write16(Adapter, REG_RXFLTMAP0, value16); */
+	/* rtw_write16(adapter, REG_RXFLTMAP0, value16); */
 
 	/* Reject all control frame - default value is 0 */
-	/* rtw_write16(Adapter,REG_RXFLTMAP1,0x0); */
+	/* rtw_write16(adapter,REG_RXFLTMAP1,0x0); */
 }
 
 static void
 _InitAdaptiveCtrl(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
 	u16	value16;
 	u32	value32;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	/*  Response Rate Set */
-	value32 = rtw_read32(Adapter, REG_RRSR);
+	value32 = rtw_read32(adapter, REG_RRSR);
 	value32 &= ~RATE_BITMAP_ALL;
 	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 	{
@@ -1190,169 +1190,169 @@ _InitAdaptiveCtrl(
 	{
 		value32 |= RATE_RRSR_CCK_ONLY_1M;
 	}
-	rtw_write32(Adapter, REG_RRSR, value32);
+	rtw_write32(adapter, REG_RRSR, value32);
 
 	/*  CF-END Threshold */
 	/* m_spIoBase->rtw_write8(REG_CFEND_TH, 0x1); */
 
 	/*  SIFS (used in NAV) */
 	value16 = _SPEC_SIFS_CCK(0x10) | _SPEC_SIFS_OFDM(0x10);
-	rtw_write16(Adapter, REG_SPEC_SIFS, value16);
+	rtw_write16(adapter, REG_SPEC_SIFS, value16);
 
 	/*  Retry Limit */
 	value16 = _LRL(0x30) | _SRL(0x30);
-	rtw_write16(Adapter, REG_RL, value16);
+	rtw_write16(adapter, REG_RL, value16);
 }
 
 static void
 _InitRateFallback(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
 	/*  Set Data Auto Rate Fallback Retry Count register. */
-	rtw_write32(Adapter, REG_DARFRC, 0x00000000);
-	rtw_write32(Adapter, REG_DARFRC+4, 0x10080404);
-	rtw_write32(Adapter, REG_RARFRC, 0x04030201);
-	rtw_write32(Adapter, REG_RARFRC+4, 0x08070605);
+	rtw_write32(adapter, REG_DARFRC, 0x00000000);
+	rtw_write32(adapter, REG_DARFRC+4, 0x10080404);
+	rtw_write32(adapter, REG_RARFRC, 0x04030201);
+	rtw_write32(adapter, REG_RARFRC+4, 0x08070605);
 }
 
 
 static void
 _InitEDCA(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-	/* PHAL_DATA_8192CUSB	pHalData = GetHalData8192CUsb(Adapter); */
+	/* PHAL_DATA_8192CUSB	pHalData = GetHalData8192CUsb(adapter); */
 	u16				value16;
 
 	/* disable EDCCA count down, to reduce collison and retry */
-	value16 = rtw_read16(Adapter, REG_RD_CTRL);
+	value16 = rtw_read16(adapter, REG_RD_CTRL);
 	value16 |= DIS_EDCA_CNT_DWN;
-	rtw_write16(Adapter, REG_RD_CTRL, value16);
+	rtw_write16(adapter, REG_RD_CTRL, value16);
 
 
 	/*  Update SIFS timing.  ?????????? */
 	/* pHalData->SifsTime = 0x0e0e0a0a; */
-	/* rtw_hal_set_hwreg(Adapter, HW_VAR_RESP_SIFS,  (pu1Byte)&pHalData->SifsTime); */
+	/* rtw_hal_set_hwreg(adapter, HW_VAR_RESP_SIFS,  (pu1Byte)&pHalData->SifsTime); */
 	/*  SIFS for CCK Data ACK */
-	rtw_write8(Adapter, REG_SIFS_CTX, 0xa);
+	rtw_write8(adapter, REG_SIFS_CTX, 0xa);
 	/*  SIFS for CCK consecutive tx like CTS data! */
-	rtw_write8(Adapter, REG_SIFS_CTX+1, 0xa);
+	rtw_write8(adapter, REG_SIFS_CTX+1, 0xa);
 
 	/*  SIFS for OFDM Data ACK */
-	rtw_write8(Adapter, REG_SIFS_TRX, 0xe);
+	rtw_write8(adapter, REG_SIFS_TRX, 0xe);
 	/*  SIFS for OFDM consecutive tx like CTS data! */
-	rtw_write8(Adapter, REG_SIFS_TRX+1, 0xe);
+	rtw_write8(adapter, REG_SIFS_TRX+1, 0xe);
 
 	/*  Set CCK/OFDM SIFS */
-	rtw_write16(Adapter, REG_SIFS_CTX, 0x0a0a); /*  CCK SIFS shall always be 10us. */
-	rtw_write16(Adapter, REG_SIFS_TRX, 0x1010);
+	rtw_write16(adapter, REG_SIFS_CTX, 0x0a0a); /*  CCK SIFS shall always be 10us. */
+	rtw_write16(adapter, REG_SIFS_TRX, 0x1010);
 
-	rtw_write16(Adapter, REG_PROT_MODE_CTRL, 0x0204);
+	rtw_write16(adapter, REG_PROT_MODE_CTRL, 0x0204);
 
-	rtw_write32(Adapter, REG_BAR_MODE_CTRL, 0x014004);
+	rtw_write32(adapter, REG_BAR_MODE_CTRL, 0x014004);
 
 
 	/*  TXOP */
-	rtw_write32(Adapter, REG_EDCA_BE_PARAM, 0x005EA42B);
-	rtw_write32(Adapter, REG_EDCA_BK_PARAM, 0x0000A44F);
-	rtw_write32(Adapter, REG_EDCA_VI_PARAM, 0x005EA324);
-	rtw_write32(Adapter, REG_EDCA_VO_PARAM, 0x002FA226);
+	rtw_write32(adapter, REG_EDCA_BE_PARAM, 0x005EA42B);
+	rtw_write32(adapter, REG_EDCA_BK_PARAM, 0x0000A44F);
+	rtw_write32(adapter, REG_EDCA_VI_PARAM, 0x005EA324);
+	rtw_write32(adapter, REG_EDCA_VO_PARAM, 0x002FA226);
 
 	/*  PIFS */
-	rtw_write8(Adapter, REG_PIFS, 0x1C);
+	rtw_write8(adapter, REG_PIFS, 0x1C);
 
 	/* AGGR BREAK TIME Register */
-	rtw_write8(Adapter, REG_AGGR_BREAK_TIME, 0x16);
+	rtw_write8(adapter, REG_AGGR_BREAK_TIME, 0x16);
 
-	rtw_write16(Adapter, REG_NAV_PROT_LEN, 0x0040);
+	rtw_write16(adapter, REG_NAV_PROT_LEN, 0x0040);
 
-	rtw_write8(Adapter, REG_BCNDMATIM, 0x02);
+	rtw_write8(adapter, REG_BCNDMATIM, 0x02);
 
-	rtw_write8(Adapter, REG_ATIMWND, 0x02);
+	rtw_write8(adapter, REG_ATIMWND, 0x02);
 }
 
 
 static void
 _InitAMPDUAggregation(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
-	/* rtw_write32(Adapter, REG_AGGLEN_LMT, 0x99997631); */
+	/* rtw_write32(adapter, REG_AGGLEN_LMT, 0x99997631); */
 
 	if (pHalData->MacPhyMode92D ==SINGLEMAC_SINGLEPHY)
-		rtw_write32(Adapter, REG_AGGLEN_LMT, 0x88728841);
+		rtw_write32(adapter, REG_AGGLEN_LMT, 0x88728841);
 	else if (pHalData->MacPhyMode92D ==DUALMAC_SINGLEPHY)
-		rtw_write32(Adapter, REG_AGGLEN_LMT, 0x44444441);
+		rtw_write32(adapter, REG_AGGLEN_LMT, 0x44444441);
 	else if (pHalData->MacPhyMode92D ==DUALMAC_DUALPHY)
-		rtw_write32(Adapter, REG_AGGLEN_LMT, 0x66525541);
+		rtw_write32(adapter, REG_AGGLEN_LMT, 0x66525541);
 
-	rtw_write8(Adapter, REG_AGGR_BREAK_TIME, 0x16);
+	rtw_write8(adapter, REG_AGGR_BREAK_TIME, 0x16);
 }
 
 static void
 _InitBeaconMaxError(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	bool		InfraMode
 	)
 {
 #ifdef RTL8192CU_ADHOC_WORKAROUND_SETTING
-	rtw_write8(Adapter, REG_BCN_MAX_ERR,  0xFF);
+	rtw_write8(adapter, REG_BCN_MAX_ERR,  0xFF);
 #else
-	/* rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10)); */
+	/* rtw_write8(adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10)); */
 #endif
 }
 
 static void
 _InitRDGSetting(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-	rtw_write8(Adapter,REG_RD_CTRL,0xFF);
-	rtw_write16(Adapter, REG_RD_NAV_NXT, 0x200);
-	rtw_write8(Adapter,REG_RD_RESP_PKT_TH,0x05);
+	rtw_write8(adapter,REG_RD_CTRL,0xFF);
+	rtw_write16(adapter, REG_RD_NAV_NXT, 0x200);
+	rtw_write8(adapter,REG_RD_RESP_PKT_TH,0x05);
 }
 
 static void
 _InitRetryFunction(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
 	u8	value8;
 
-	value8 = rtw_read8(Adapter, REG_FWHW_TXQ_CTRL);
+	value8 = rtw_read8(adapter, REG_FWHW_TXQ_CTRL);
 	value8 |= EN_AMPDU_RTY_NEW;
-	rtw_write8(Adapter, REG_FWHW_TXQ_CTRL, value8);
+	rtw_write8(adapter, REG_FWHW_TXQ_CTRL, value8);
 
 	/*  Set ACK timeout */
-	rtw_write8(Adapter, REG_ACKTO, 0x40);
+	rtw_write8(adapter, REG_ACKTO, 0x40);
 }
 
 
 static void
 _InitUsbAggregationSetting(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
 #ifdef CONFIG_USB_TX_AGGREGATION
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u32			value32;
 
-	if (Adapter->registrypriv.wifi_spec)
+	if (adapter->registrypriv.wifi_spec)
 		pHalData->UsbTxAggMode = false;
 
 	if (pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
 		pHalData->UsbTxAggDescNum = 2;
 
 	if (pHalData->UsbTxAggMode) {
-		value32 = rtw_read32(Adapter, REG_TDECTRL);
+		value32 = rtw_read32(adapter, REG_TDECTRL);
 		value32 = value32 & ~(BLK_DESC_NUM_MASK << BLK_DESC_NUM_SHIFT);
 		value32 |= ((pHalData->UsbTxAggDescNum & BLK_DESC_NUM_MASK) << BLK_DESC_NUM_SHIFT);
 
-		rtw_write32(Adapter, REG_TDECTRL, value32);
+		rtw_write32(adapter, REG_TDECTRL, value32);
 	}
 }
 #endif
@@ -1360,7 +1360,7 @@ _InitUsbAggregationSetting(
 	/*  Rx aggregation setting */
 #ifdef CONFIG_USB_RX_AGGREGATION
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8		valueDMA;
 	u8		valueUSB;
 
@@ -1369,8 +1369,8 @@ _InitUsbAggregationSetting(
 		pHalData->UsbRxAggPageTimeout = 0x6;
 	}
 
-	valueDMA = rtw_read8(Adapter, REG_TRXDMA_CTRL);
-	valueUSB = rtw_read8(Adapter, REG_USB_SPECIAL_OPTION);
+	valueDMA = rtw_read8(adapter, REG_TRXDMA_CTRL);
+	valueUSB = rtw_read8(adapter, REG_USB_SPECIAL_OPTION);
 
 	switch (pHalData->UsbRxAggMode) {
 	case USB_RX_AGG_DMA:
@@ -1392,22 +1392,22 @@ _InitUsbAggregationSetting(
 		break;
 	}
 
-	rtw_write8(Adapter, REG_TRXDMA_CTRL, valueDMA);
-	rtw_write8(Adapter, REG_USB_SPECIAL_OPTION, valueUSB);
+	rtw_write8(adapter, REG_TRXDMA_CTRL, valueDMA);
+	rtw_write8(adapter, REG_USB_SPECIAL_OPTION, valueUSB);
 	switch (pHalData->UsbRxAggMode) {
 		case USB_RX_AGG_DMA:
-			rtw_write8(Adapter, REG_RXDMA_AGG_PG_TH, pHalData->UsbRxAggPageCount);
-			rtw_write8(Adapter, REG_USB_DMA_AGG_TO, pHalData->UsbRxAggPageTimeout);
+			rtw_write8(adapter, REG_RXDMA_AGG_PG_TH, pHalData->UsbRxAggPageCount);
+			rtw_write8(adapter, REG_USB_DMA_AGG_TO, pHalData->UsbRxAggPageTimeout);
 			break;
 		case USB_RX_AGG_USB:
-			rtw_write8(Adapter, REG_USB_AGG_TH, pHalData->UsbRxAggBlockCount);
-			rtw_write8(Adapter, REG_USB_AGG_TO, pHalData->UsbRxAggBlockTimeout);
+			rtw_write8(adapter, REG_USB_AGG_TH, pHalData->UsbRxAggBlockCount);
+			rtw_write8(adapter, REG_USB_AGG_TO, pHalData->UsbRxAggBlockTimeout);
 			break;
 		case USB_RX_AGG_DMA_USB:
-			rtw_write8(Adapter, REG_RXDMA_AGG_PG_TH, pHalData->UsbRxAggPageCount);
-			rtw_write8(Adapter, REG_USB_DMA_AGG_TO, pHalData->UsbRxAggPageTimeout);
-			rtw_write8(Adapter, REG_USB_AGG_TH, pHalData->UsbRxAggBlockCount);
-			rtw_write8(Adapter, REG_USB_AGG_TO, pHalData->UsbRxAggBlockTimeout);
+			rtw_write8(adapter, REG_RXDMA_AGG_PG_TH, pHalData->UsbRxAggPageCount);
+			rtw_write8(adapter, REG_USB_DMA_AGG_TO, pHalData->UsbRxAggPageTimeout);
+			rtw_write8(adapter, REG_USB_AGG_TH, pHalData->UsbRxAggBlockCount);
+			rtw_write8(adapter, REG_USB_AGG_TO, pHalData->UsbRxAggBlockTimeout);
 			break;
 		case USB_RX_AGG_DISABLE:
 		default:
@@ -1442,10 +1442,10 @@ _InitUsbAggregationSetting(
 
 static void
 _InitOperationMode(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8 regBwOpMode = 0, MinSpaceCfg = 0;
 
 	/* 1 This part need to modified according to the rate set we filtered!! */
@@ -1478,7 +1478,7 @@ _InitOperationMode(
 	}
 
 	/*  Ziv ???????? */
-	rtw_write8(Adapter, REG_BWOPMODE, regBwOpMode);
+	rtw_write8(adapter, REG_BWOPMODE, regBwOpMode);
 
 	/*  For Min Spacing configuration. */
 	switch (pHalData->rf_type) {
@@ -1492,42 +1492,42 @@ _InitOperationMode(
 		break;
 	}
 
-	rtw_write8(Adapter, REG_AMPDU_MIN_SPACE, MinSpaceCfg);
+	rtw_write8(adapter, REG_AMPDU_MIN_SPACE, MinSpaceCfg);
 }
 
 static void
 _InitSecuritySetting(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-	invalidate_cam_all(Adapter);
+	invalidate_cam_all(adapter);
 }
 
  static void
 _InitBeaconParameters(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-/* 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter); */
+/* 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter); */
 
-	rtw_write16(Adapter, REG_BCN_CTRL, 0x1010);
+	rtw_write16(adapter, REG_BCN_CTRL, 0x1010);
 
 	 /* default value  for register 0x558 and 0x559 is  0x05 0x03 (92DU before bitfile0821) zhiyuan 2009/08/26 */
-	rtw_write16(Adapter, REG_TBTT_PROHIBIT,0x3c02);/*  ms */
-	rtw_write8(Adapter, REG_DRVERLYINT, 0x05);/* ms */
-	rtw_write8(Adapter, REG_BCNDMATIM, 0x03);
+	rtw_write16(adapter, REG_TBTT_PROHIBIT,0x3c02);/*  ms */
+	rtw_write8(adapter, REG_DRVERLYINT, 0x05);/* ms */
+	rtw_write8(adapter, REG_BCNDMATIM, 0x03);
 
 	/*  Suggested by designer timchen. Change beacon AIFS to the largest number */
 	/*  beacause test chip does not contension before sending beacon. by tynli. 2009.11.03 */
-	rtw_write16(Adapter, REG_BCNTCFG, 0x660F);
+	rtw_write16(adapter, REG_BCNTCFG, 0x660F);
 }
 
 static void
 _InitRFType(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 
 #if (DISABLE_BB_RF==1)
 	pHalData->rf_chip	= RF_PSEUDO_11N;
@@ -1547,20 +1547,20 @@ _InitRFType(
 }
 
 #if RTL8192CU_ADHOC_WORKAROUND_SETTING
-static void _InitAdhocWorkaroundParams(struct rtw_adapter * Adapter)
+static void _InitAdhocWorkaroundParams(struct rtw_adapter * adapter)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
-	pHalData->RegBcnCtrlVal = rtw_read8(Adapter, REG_BCN_CTRL);
-	pHalData->RegTxPause = rtw_read8(Adapter, REG_TXPAUSE);
-	pHalData->RegFwHwTxQCtrl = rtw_read8(Adapter, REG_FWHW_TXQ_CTRL+2);
-	pHalData->RegReg542 = rtw_read8(Adapter, REG_TBTT_PROHIBIT+2);
-	pHalData->RegCR_1 = rtw_read8(Adapter, REG_CR+1);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	pHalData->RegBcnCtrlVal = rtw_read8(adapter, REG_BCN_CTRL);
+	pHalData->RegTxPause = rtw_read8(adapter, REG_TXPAUSE);
+	pHalData->RegFwHwTxQCtrl = rtw_read8(adapter, REG_FWHW_TXQ_CTRL+2);
+	pHalData->RegReg542 = rtw_read8(adapter, REG_TBTT_PROHIBIT+2);
+	pHalData->RegCR_1 = rtw_read8(adapter, REG_CR+1);
 }
 #endif
 
 static void
 _BeaconFunctionEnable(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	bool			Enable,
 	bool			Linked
 	)
@@ -1570,33 +1570,33 @@ _BeaconFunctionEnable(
 	/*   enable ATIM function may invoke HW Tx stop operation. This may cause ping failed */
 	/*  sometimes in long run test. So just disable it now. */
 	/*  When ATIM function is disabled, High Queue should not use anymore. */
-	rtw_write8(Adapter, REG_BCN_CTRL, 0x1b);
-	rtw_write8(Adapter, REG_RD_CTRL+1, 0x6F);
+	rtw_write8(adapter, REG_BCN_CTRL, 0x1b);
+	rtw_write8(adapter, REG_RD_CTRL+1, 0x6F);
 }
 
 
 /*  Set CCK and OFDM Block "ON" */
 static void _BBTurnOnBlock(
-	struct rtw_adapter *		Adapter
+	struct rtw_adapter *		adapter
 	)
 {
-	struct hal_data_8192du 		*pHalData	= GET_HAL_DATA(Adapter);
+	struct hal_data_8192du 		*pHalData	= GET_HAL_DATA(adapter);
 #if (DISABLE_BB_RF)
 	return;
 #endif
 
 	if (pHalData->CurrentBandType92D == BAND_ON_5G)
-		PHY_SetBBReg(Adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x2);
+		PHY_SetBBReg(adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x2);
 	else
-		PHY_SetBBReg(Adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x3);
+		PHY_SetBBReg(adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x3);
 }
 
 static void _RfPowerSave(
-	struct rtw_adapter *		Adapter
+	struct rtw_adapter *		adapter
 	)
 {
-	struct hal_data_8192du 	*pHalData	= GET_HAL_DATA(Adapter);
-	struct pwrctrl_priv		*pwrctrlpriv = &Adapter->pwrctrlpriv;
+	struct hal_data_8192du 	*pHalData	= GET_HAL_DATA(adapter);
+	struct pwrctrl_priv		*pwrctrlpriv = &adapter->pwrctrlpriv;
 	u8			eRFPath;
 
 #if (DISABLE_BB_RF)
@@ -1604,33 +1604,33 @@ static void _RfPowerSave(
 #endif
 
 	if (pwrctrlpriv->reg_rfoff == true) { /*  User disable RF via registry. */
-		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RegRfOff.\n")); */
-		/* MgntActSet_RF_State(Adapter, rf_off, RF_CHANGE_BY_SW, true); */
+		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("Initializeadapter8192CUsb(): Turn off RF for RegRfOff.\n")); */
+		/* MgntActSet_RF_State(adapter, rf_off, RF_CHANGE_BY_SW, true); */
 		/*  Those action will be discard in MgntActSet_RF_State because off the same state */
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		if (pHalData->bSlaveOfDMSP)
 			return;
 #endif
 		for (eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
-			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
 	}
 	else if (pwrctrlpriv->rfoff_reason > RF_CHANGE_BY_PS) { /*  H/W or S/W RF OFF before sleep. */
-		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason)); */
-		/* MgntActSet_RF_State(Adapter, rf_off, pMgntInfo->RfOffReason, true); */
+		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("Initializeadapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason)); */
+		/* MgntActSet_RF_State(adapter, rf_off, pMgntInfo->RfOffReason, true); */
 	}
 	else {
 		pwrctrlpriv->rf_pwrstate = rf_on;
 		pwrctrlpriv->rfoff_reason = 0;
-		/* if (Adapter->bInSetPower || Adapter->bResetInProgress) */
-		/* 	PlatformUsbEnableInPipes(Adapter); */
-		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): RF is on.\n")); */
+		/* if (adapter->bInSetPower || adapter->bResetInProgress) */
+		/* 	PlatformUsbEnableInPipes(adapter); */
+		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("Initializeadapter8192CUsb(): RF is on.\n")); */
 	}
 }
 
 #ifdef CONFIG_LED
-static void _InitHWLed(struct rtw_adapter * Adapter)
+static void _InitHWLed(struct rtw_adapter * adapter)
 {
-	struct led_priv *pledpriv = &(Adapter->ledpriv);
+	struct led_priv *pledpriv = &(adapter->ledpriv);
 
 	if (pledpriv->LedStrategy != HW_LED)
 			return;
@@ -1686,7 +1686,7 @@ static u32 rtl8192du_hal_init(struct rtw
 	struct pwrctrl_priv		*pwrctrlpriv = &padapter->pwrctrlpriv;
 	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct rtw_adapter *	BuddyAdapter = padapter->pbuddy_adapter;
+	struct rtw_adapter *	Buddyadapter = padapter->pbuddy_adapter;
 #endif
 	u32 init_start_time = rtw_get_current_time();
 
@@ -1754,14 +1754,14 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEG
 	padapter->init_adpt_in_progress = true;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if (BuddyAdapter != NULL)
+	if (Buddyadapter != NULL)
 	{
-		if (BuddyAdapter->bHaltInProgress)
+		if (Buddyadapter->bHaltInProgress)
 		{
 			for (i=0;i<100;i++)
 			{
 				rtw_usleep_os(1000);
-				if (!BuddyAdapter->bHaltInProgress)
+				if (!Buddyadapter->bHaltInProgress)
 					break;
 			}
 
@@ -1773,7 +1773,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEG
 		}
 	}
 #endif
-	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("--->InitializeAdapter8192CUsb()\n")); */
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("--->Initializeadapter8192CUsb()\n")); */
 
 	if (padapter->bSurpriseRemoved)
 		return _FAIL;
@@ -2140,8 +2140,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 
 #if (MP_DRIVER == 1)
 	padapter->mppriv.channel = pHalData->CurrentChannel;
-	MPT_InitializeAdapter(padapter, padapter->mppriv.channel);
-	/* MPT_InitializeAdapter(padapter, Channel); */
+	MPT_Initializeadapter(padapter, padapter->mppriv.channel);
+	/* MPT_Initializeadapter(padapter, Channel); */
 #else /*  temply marked this for RF */
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (!pHalData->bSlaveOfDMSP)
@@ -2280,7 +2280,7 @@ _func_exit_;
 
 static void
 _DisableGPIO(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
 /***************************************
@@ -2295,41 +2295,41 @@ n. LEDCFG 0x4C[15:0] = 0x8080
 	u32	value32;
 
 	/* 1. Disable GPIO[7:0] */
-	rtw_write16(Adapter, REG_GPIO_PIN_CTRL+2, 0x0000);
-	value32 = rtw_read32(Adapter, REG_GPIO_PIN_CTRL) & 0xFFFF00FF;
+	rtw_write16(adapter, REG_GPIO_PIN_CTRL+2, 0x0000);
+	value32 = rtw_read32(adapter, REG_GPIO_PIN_CTRL) & 0xFFFF00FF;
 	value8 = (u8) (value32&0x000000FF);
 	value32 |= ((value8<<8) | 0x00FF0000);
-	rtw_write32(Adapter, REG_GPIO_PIN_CTRL, value32);
+	rtw_write32(adapter, REG_GPIO_PIN_CTRL, value32);
 
 	/* 2. Disable GPIO[10:8] */
-	rtw_write8(Adapter, REG_MAC_PINMUX_CFG, 0x00);
-	value16 = rtw_read16(Adapter, REG_GPIO_IO_SEL) & 0xFF0F;
+	rtw_write8(adapter, REG_MAC_PINMUX_CFG, 0x00);
+	value16 = rtw_read16(adapter, REG_GPIO_IO_SEL) & 0xFF0F;
 	value8 = (u8) (value16&0x000F);
 	value16 |= ((value8<<4) | 0x0780);
-	rtw_write16(Adapter, REG_GPIO_IO_SEL, value16);
+	rtw_write16(adapter, REG_GPIO_IO_SEL, value16);
 
 
 	/* 3. Disable LED0 & 1 */
-	rtw_write16(Adapter, REG_LEDCFG0, 0x8888);
+	rtw_write16(adapter, REG_LEDCFG0, 0x8888);
 
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable GPIO and LED.\n")); */
 } /* end of _DisableGPIO() */
 static void
 _ResetFWDownloadRegister(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	)
 {
 	u32	value32;
 
-	value32 = rtw_read32(Adapter, REG_MCUFWDL);
+	value32 = rtw_read32(adapter, REG_MCUFWDL);
 	value32 &= ~(MCUFWDL_EN | MCUFWDL_RDY);
-	rtw_write32(Adapter, REG_MCUFWDL, value32);
+	rtw_write32(adapter, REG_MCUFWDL, value32);
 }
 
 
 static int
 _DisableRF_AFE(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	)
 {
 	int		rtStatus = _SUCCESS;
@@ -2338,14 +2338,14 @@ _DisableRF_AFE(
 
 	/* disable RF/ AFE AD/DA */
 	value8 = APSDOFF;
-	rtw_write8(Adapter, REG_APSD_CTRL, value8);
+	rtw_write8(adapter, REG_APSD_CTRL, value8);
 
 
 #if (RTL8192CU_ASIC_VERIFICATION)
 
 	do
 	{
-		if (rtw_read8(Adapter, REG_APSD_CTRL) & APSDOFF_STATUS) {
+		if (rtw_read8(adapter, REG_APSD_CTRL) & APSDOFF_STATUS) {
 			/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE, AD, DA Done!\n")); */
 			break;
 		}
@@ -2365,90 +2365,90 @@ _DisableRF_AFE(
 
 static void
 _ResetBB(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	)
 {
 	u16	value16;
 	/* before BB reset should do clock gated */
-	rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
+	rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 	/* reset BB */
-	value16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);
+	value16 = rtw_read16(adapter, REG_SYS_FUNC_EN);
 	value16 &= ~(FEN_BBRSTB | FEN_BB_GLB_RSTn);
-	rtw_write16(Adapter, REG_SYS_FUNC_EN, value16);
+	rtw_write16(adapter, REG_SYS_FUNC_EN, value16);
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset BB.\n")); */
 }
 
 static void
 _ResetMCU(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	)
 {
 	u16	value16;
 
 	/*  reset MCU */
-	value16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);
+	value16 = rtw_read16(adapter, REG_SYS_FUNC_EN);
 	value16 &= ~FEN_CPUEN;
-	rtw_write16(Adapter, REG_SYS_FUNC_EN, value16);
+	rtw_write16(adapter, REG_SYS_FUNC_EN, value16);
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset MCU.\n")); */
 }
 
 static void
 _DisableMAC_AFE_PLL(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	)
 {
 	u32	value32;
 
 	/* disable MAC/ AFE PLL */
-	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
+	value32 = rtw_read32(adapter, REG_APS_FSMCO);
 	value32 |= APDM_MAC;
-	rtw_write32(Adapter, REG_APS_FSMCO, value32);
+	rtw_write32(adapter, REG_APS_FSMCO, value32);
 
 	value32 |= APFM_OFF;
-	rtw_write32(Adapter, REG_APS_FSMCO, value32);
+	rtw_write32(adapter, REG_APS_FSMCO, value32);
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable MAC, AFE PLL.\n")); */
 }
 
 static void
 _AutoPowerDownToHostOff(
-	struct rtw_adapter *		Adapter
+	struct rtw_adapter *		adapter
 	)
 {
 	u32			value32;
-	rtw_write8(Adapter, REG_SPS0_CTRL, 0x22);
+	rtw_write8(adapter, REG_SPS0_CTRL, 0x22);
 
-	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
+	value32 = rtw_read32(adapter, REG_APS_FSMCO);
 
 	value32 |= APDM_HOST;/* card disable */
-	rtw_write32(Adapter, REG_APS_FSMCO, value32);
+	rtw_write32(adapter, REG_APS_FSMCO, value32);
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Auto Power Down to Host-off state.\n")); */
 
 	/*  set USB suspend */
-	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
+	value32 = rtw_read32(adapter, REG_APS_FSMCO);
 	value32 &= ~AFSM_PCIE;
-	rtw_write32(Adapter, REG_APS_FSMCO, value32);
+	rtw_write32(adapter, REG_APS_FSMCO, value32);
 }
 
 static void
 _SetUsbSuspend(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	)
 {
 	u32			value32;
 
-	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
+	value32 = rtw_read32(adapter, REG_APS_FSMCO);
 
 	/*  set USB suspend */
 	value32 |= AFSM_HSUS;
-	rtw_write32(Adapter, REG_APS_FSMCO, value32);
+	rtw_write32(adapter, REG_APS_FSMCO, value32);
 
-	/* RT_ASSERT(0 == (rtw_read32(Adapter, REG_APS_FSMCO) & BIT(12)),("")); */
+	/* RT_ASSERT(0 == (rtw_read32(adapter, REG_APS_FSMCO) & BIT(12)),("")); */
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Set USB suspend.\n")); */
 }
 
 static void
 _DisableRFAFEAndResetBB8192D(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	)
 {
 /**************************************
@@ -2458,35 +2458,35 @@ c.	APSD_CTRL 0x600[7:0] = 0x40
 d.	SYS_FUNC_EN 0x02[7:0] = 0x16		reset BB state machine
 e.	SYS_FUNC_EN 0x02[7:0] = 0x14		reset BB state machine
 ***************************************/
-       struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+       struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 	u8	eRFPath = 0,value8 = 0;
 
-	PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,  0xf);
-	PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, 0x0,bRFRegOffsetMask, 0x0);
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000,  0xf);
+	PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, 0x0,bRFRegOffsetMask, 0x0);
 
 	value8 |= APSDOFF;
-	rtw_write8(Adapter, REG_APSD_CTRL, value8);/* 0x40 */
+	rtw_write8(adapter, REG_APSD_CTRL, value8);/* 0x40 */
 
 
 	/* testchip  should not do BB reset if another mac is alive; */
 	value8 = 0 ;
 	value8 |=(FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
-	rtw_write8(Adapter, REG_SYS_FUNC_EN,value8);/* 0x16 */
+	rtw_write8(adapter, REG_SYS_FUNC_EN,value8);/* 0x16 */
 
 	if (pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
 	{
 		if (pHalData->interfaceIndex!=0) {
 			/* before BB reset should do clock gated */
-			rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
+			rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 			value8 &=(~FEN_BB_GLB_RSTn);
-			rtw_write8(Adapter, REG_SYS_FUNC_EN, value8); /* 0x14 */
+			rtw_write8(adapter, REG_SYS_FUNC_EN, value8); /* 0x14 */
 		}
 	}
 	else {
 		/* before BB reset should do clock gated */
-		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
+		rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 		value8 &=(~FEN_BB_GLB_RSTn);
-		rtw_write8(Adapter, REG_SYS_FUNC_EN, value8); /* 0x14 */
+		rtw_write8(adapter, REG_SYS_FUNC_EN, value8); /* 0x14 */
 	}
 
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> RF off and reset BB.\n")); */
@@ -2494,45 +2494,45 @@ e.	SYS_FUNC_EN 0x02[7:0] = 0x14		reset B
 
 static void
 _DisableRFAFEAndResetBB(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	)
 {
-	_DisableRFAFEAndResetBB8192D(Adapter);
+	_DisableRFAFEAndResetBB8192D(adapter);
 }
 
 static void
 _ResetDigitalProcedure1(
-	struct rtw_adapter *			Adapter,
+	struct rtw_adapter *			adapter,
 	bool				bWithoutHWSM
 	)
 {
 
-	struct hal_data_8192du  *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du  *pHalData = GET_HAL_DATA(adapter);
 
 	u8 retry_cnts = 0;
 	/*  2010/08/12 MH For USB SS, we can not stop 8051 when we are trying to */
 	/*  enter IPS/HW&SW radio off. For S3/S4/S5/Disable, we can stop 8051 because */
 	/*  we will init FW when power on again. */
-	if (rtw_read8(Adapter, REG_MCUFWDL) & BIT1) { /* IF fw in RAM code, do reset */
+	if (rtw_read8(adapter, REG_MCUFWDL) & BIT1) { /* IF fw in RAM code, do reset */
 
-		if (Adapter->bFWReady) {
-			rtw_write8(Adapter, REG_FSIMR, 0x00);
+		if (adapter->bFWReady) {
+			rtw_write8(adapter, REG_FSIMR, 0x00);
 			/*  2010/08/25 MH Accordign to RD alfred's suggestion, we need to disable other */
 			/*  HRCV INT to influence 8051 reset. */
-			rtw_write8(Adapter, REG_FWIMR, 0x20);
+			rtw_write8(adapter, REG_FWIMR, 0x20);
 			/*  2011/02/15 MH According to Alex's suggestion, close mask to prevent incorrect FW write operation. */
-			rtw_write8(Adapter, REG_FTIMR, 0x00);
+			rtw_write8(adapter, REG_FTIMR, 0x00);
 
-			rtw_write8(Adapter, REG_MCUFWDL, 0);
-			rtw_write8(Adapter, REG_HMETFR+3, 0x20);/* 8051 reset by self */
+			rtw_write8(adapter, REG_MCUFWDL, 0);
+			rtw_write8(adapter, REG_HMETFR+3, 0x20);/* 8051 reset by self */
 
-			while ((retry_cnts++ <100) && (FEN_CPUEN &rtw_read16(Adapter, REG_SYS_FUNC_EN)))
+			while ((retry_cnts++ <100) && (FEN_CPUEN &rtw_read16(adapter, REG_SYS_FUNC_EN)))
 				rtw_udelay_os(50);/* us */
 
 			if (retry_cnts>= 100) {
-				rtw_write8(Adapter, REG_FWIMR, 0x00);
+				rtw_write8(adapter, REG_FWIMR, 0x00);
 				/*  2010/08/31 MH According to Filen's info, if 8051 reset fail, reset MAC directly. */
-				rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x50);	/* Reset MAC and Enable 8051 */
+				rtw_write8(adapter, REG_SYS_FUNC_EN+1, 0x50);	/* Reset MAC and Enable 8051 */
 				rtw_mdelay_os(10);
 			} else {
 				DBG_8192D("=====> 8051 reset success (%d) .\n",retry_cnts);
@@ -2545,13 +2545,13 @@ _ResetDigitalProcedure1(
 	#ifdef DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE
 	{
 		u8 val;
-		if ((val=rtw_read8(Adapter, REG_MCUFWDL)))
+		if ((val=rtw_read8(adapter, REG_MCUFWDL)))
 			DBG_8192D("DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE %s:%d REG_MCUFWDL:0x%02x\n", __func__, __LINE__, val);
 	}
 	#endif
 
-	rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x54);	/* Reset MAC and Enable 8051 */
-	rtw_write8(Adapter, REG_MCUFWDL, 0);
+	rtw_write8(adapter, REG_SYS_FUNC_EN+1, 0x54);	/* Reset MAC and Enable 8051 */
+	rtw_write8(adapter, REG_MCUFWDL, 0);
 
 	if (bWithoutHWSM) {
 	/*****************************
@@ -2561,18 +2561,18 @@ _ResetDigitalProcedure1(
 	i.	AFE_XTAL_CTRL 0x24[15:0] = 0x880F		gated AFE DIG_CLOCK
 	j.	SYS_ISO_CTRL 0x00[7:0] = 0xF9			isolated digital to PON
 	******************************/
-		/* rtw_write16(Adapter, REG_SYS_CLKR, 0x30A3); */
-		rtw_write16(Adapter, REG_SYS_CLKR, 0x70A3);/* modify to 0x70A3 by Scott. */
-		rtw_write8(Adapter, REG_AFE_PLL_CTRL, 0x80);
-		rtw_write16(Adapter, REG_AFE_XTAL_CTRL, 0x880F);
-		rtw_write8(Adapter, REG_SYS_ISO_CTRL, 0xF9);
+		/* rtw_write16(adapter, REG_SYS_CLKR, 0x30A3); */
+		rtw_write16(adapter, REG_SYS_CLKR, 0x70A3);/* modify to 0x70A3 by Scott. */
+		rtw_write8(adapter, REG_AFE_PLL_CTRL, 0x80);
+		rtw_write16(adapter, REG_AFE_XTAL_CTRL, 0x880F);
+		rtw_write8(adapter, REG_SYS_ISO_CTRL, 0xF9);
 	}
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Reset Digital.\n")); */
 }
 
 static void
 _ResetDigitalProcedure2(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 )
 {
 /*****************************
@@ -2580,13 +2580,13 @@ k.	SYS_FUNC_EN 0x03[7:0] = 0x44			disabl
 l.	SYS_CLKR 0x08[15:0] = 0x3083			disable ELDR clock
 m.	SYS_ISO_CTRL 0x01[7:0] = 0x83			isolated ELDR to PON
 ******************************/
-	rtw_write16(Adapter, REG_SYS_CLKR, 0x70a3); /* modify to 0x70a3 by Scott. */
-	rtw_write8(Adapter, REG_SYS_ISO_CTRL+1, 0x82); /* modify to 0x82 by Scott. */
+	rtw_write16(adapter, REG_SYS_CLKR, 0x70a3); /* modify to 0x70a3 by Scott. */
+	rtw_write8(adapter, REG_SYS_ISO_CTRL+1, 0x82); /* modify to 0x82 by Scott. */
 }
 
 static void
 _DisableAnalog(
-	struct rtw_adapter *			Adapter,
+	struct rtw_adapter *			adapter,
 	bool			bWithoutHWSM
 	)
 {
@@ -2600,12 +2600,12 @@ _DisableAnalog(
 	r.	When driver call disable, the ASIC will turn off remaining clock automatically
 	******************************/
 
-		rtw_write8(Adapter, REG_LDOA15_CTRL, 0x04);
-		/* PlatformIOWrite1Byte(Adapter, REG_LDOV12D_CTRL, 0x54); */
+		rtw_write8(adapter, REG_LDOA15_CTRL, 0x04);
+		/* PlatformIOWrite1Byte(adapter, REG_LDOV12D_CTRL, 0x54); */
 
-		value8 = rtw_read8(Adapter, REG_LDOV12D_CTRL);
+		value8 = rtw_read8(adapter, REG_LDOV12D_CTRL);
 		value8 &= (~LDV12_EN);
-		rtw_write8(Adapter, REG_LDOV12D_CTRL, value8);
+		rtw_write8(adapter, REG_LDOV12D_CTRL, value8);
 		/* RT_TRACE(COMP_INIT, DBG_LOUD, (" REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8)); */
 	}
 
@@ -2613,34 +2613,34 @@ _DisableAnalog(
 h.	SPS0_CTRL 0x11[7:0] = 0x23		enter PFM mode
 i.	APS_FSMCO 0x04[15:0] = 0x4802		set USB suspend
 ******************************/
-	rtw_write8(Adapter, REG_SPS0_CTRL, 0x23);
+	rtw_write8(adapter, REG_SPS0_CTRL, 0x23);
 
 	value16 |= (APDM_HOST | AFSM_HSUS |PFM_ALDN);
-	rtw_write16(Adapter, REG_APS_FSMCO,value16);/* 0x4802 */
+	rtw_write16(adapter, REG_APS_FSMCO,value16);/* 0x4802 */
 
-	rtw_write8(Adapter, REG_RSV_CTRL, 0x0e);
+	rtw_write8(adapter, REG_RSV_CTRL, 0x0e);
 
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable Analog Reg0x04:0x%04x.\n",value16)); */
 }
 
 static bool
 CanGotoPowerOff92D(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 	u8 u1bTmp;
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
 #endif
 
 	if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY)
 		return true;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if (BuddyAdapter != NULL)
+	if (Buddyadapter != NULL)
 	{
-		if (BuddyAdapter->init_adpt_in_progress)
+		if (Buddyadapter->init_adpt_in_progress)
 		{
 			DBG_8192D("do not power off during another adapter is initialization\n");
 			return false;
@@ -2650,38 +2650,38 @@ CanGotoPowerOff92D(
 
 	if (pHalData->interfaceIndex==0)
 	{	/*  query another mac status; */
-		u1bTmp = rtw_read8(Adapter, REG_MAC1);
+		u1bTmp = rtw_read8(adapter, REG_MAC1);
 		u1bTmp&=MAC1_ON;
 	}
 	else
 	{
-		u1bTmp = rtw_read8(Adapter, REG_MAC0);
+		u1bTmp = rtw_read8(adapter, REG_MAC0);
 		u1bTmp&=MAC0_ON;
 	}
 
 	/* 0x17[7]:1b' power off in process */
-	u1bTmp=rtw_read8(Adapter, 0x17);
+	u1bTmp=rtw_read8(adapter, 0x17);
 	u1bTmp|=BIT7;
-	rtw_write8(Adapter, 0x17, u1bTmp);
+	rtw_write8(adapter, 0x17, u1bTmp);
 
 	rtw_udelay_os(500);
 	/*  query another mac status; */
 	if (pHalData->interfaceIndex==0)
 	{	/*  query another mac status; */
-		u1bTmp = rtw_read8(Adapter, REG_MAC1);
+		u1bTmp = rtw_read8(adapter, REG_MAC1);
 		u1bTmp&=MAC1_ON;
 	}
 	else
 	{
-		u1bTmp = rtw_read8(Adapter, REG_MAC0);
+		u1bTmp = rtw_read8(adapter, REG_MAC0);
 		u1bTmp&=MAC0_ON;
 	}
 	/* if another mac is alive,do not do power off */
 	if (u1bTmp)
 	{
-		u1bTmp=rtw_read8(Adapter, 0x17);
+		u1bTmp=rtw_read8(adapter, 0x17);
 		u1bTmp&=(~BIT7);
-		rtw_write8(Adapter, 0x17, u1bTmp);
+		rtw_write8(adapter, 0x17, u1bTmp);
 		return false;
 	}
 	return true;
@@ -2689,49 +2689,49 @@ CanGotoPowerOff92D(
 
 static int
 CardDisableHWSM(/*  HW Auto state machine */
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *		adapter,
 	bool			resetMCU
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 	int		rtStatus = _SUCCESS;
 	u8		value;
 
-	if (Adapter->bSurpriseRemoved) {
+	if (adapter->bSurpriseRemoved) {
 		return rtStatus;
 	}
 
-	rtw_write8(Adapter, REG_TXPAUSE, 0xFF);
+	rtw_write8(adapter, REG_TXPAUSE, 0xFF);
 	rtw_udelay_os(500);
-	rtw_write8(Adapter,	REG_CR, 0x0);
+	rtw_write8(adapter,	REG_CR, 0x0);
 
 	/*  RF Off Sequence ==== */
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if (!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
+	if (!pHalData->bSlaveOfDMSP || adapter->DualMacConcurrent == false)
 #endif
-		_DisableRFAFEAndResetBB(Adapter);
+		_DisableRFAFEAndResetBB(adapter);
 
-	if (!PHY_CheckPowerOffFor8192D(Adapter))
+	if (!PHY_CheckPowerOffFor8192D(adapter))
 		return rtStatus;
 
 	/* 0x20:value 05-->04 */
-	rtw_write8(Adapter, REG_LDOA15_CTRL,0x04);
+	rtw_write8(adapter, REG_LDOA15_CTRL,0x04);
 	/* RF Control */
-	rtw_write8(Adapter, REG_RF_CTRL,0);
+	rtw_write8(adapter, REG_RF_CTRL,0);
 
 	/*   ==== Reset digital sequence   ====== */
-	_ResetDigitalProcedure1(Adapter, false);
+	_ResetDigitalProcedure1(adapter, false);
 
 	/*   ==== Pull GPIO PIN to balance level and LED control ====== */
-	_DisableGPIO(Adapter);
+	_DisableGPIO(adapter);
 
 	/*   ==== Disable analog sequence === */
-	_DisableAnalog(Adapter, false);
+	_DisableAnalog(adapter, false);
 
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
-	value=rtw_read8(Adapter, REG_POWER_OFF_IN_PROCESS);
+	value=rtw_read8(adapter, REG_POWER_OFF_IN_PROCESS);
 	value&=(~BIT7);
-	rtw_write8(Adapter, REG_POWER_OFF_IN_PROCESS, value);
+	rtw_write8(adapter, REG_POWER_OFF_IN_PROCESS, value);
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
 
 	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("======> Card disable finished.\n"));
@@ -2741,66 +2741,66 @@ CardDisableHWSM(/*  HW Auto state machin
 
 static int
 CardDisableWithoutHWSM(/*  without HW Auto state machine */
-	struct rtw_adapter *		Adapter
+	struct rtw_adapter *		adapter
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 	int		rtStatus = _SUCCESS;
 	u8		value;
 
-	if (Adapter->bSurpriseRemoved) {
+	if (adapter->bSurpriseRemoved) {
 		return rtStatus;
 	}
 
-	rtw_write8(Adapter, REG_TXPAUSE, 0xFF);
+	rtw_write8(adapter, REG_TXPAUSE, 0xFF);
 	rtw_udelay_os(500);
-	rtw_write8(Adapter,	REG_CR, 0x0);
+	rtw_write8(adapter,	REG_CR, 0x0);
 
 	/*  RF Off Sequence ==== */
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if (!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
+	if (!pHalData->bSlaveOfDMSP || adapter->DualMacConcurrent == false)
 #endif
-		_DisableRFAFEAndResetBB(Adapter);
+		_DisableRFAFEAndResetBB(adapter);
 
 	/*  stop tx/rx */
-	rtw_write8(Adapter, REG_TXPAUSE, 0xFF);
+	rtw_write8(adapter, REG_TXPAUSE, 0xFF);
 	rtw_udelay_os(500);
-	rtw_write8(Adapter,	REG_CR, 0x0);
+	rtw_write8(adapter,	REG_CR, 0x0);
 
-	if (!PHY_CheckPowerOffFor8192D(Adapter))
+	if (!PHY_CheckPowerOffFor8192D(adapter))
 	{
 		return rtStatus;
 	}
 
 	/* 0x20:value 05-->04 */
-	rtw_write8(Adapter, REG_LDOA15_CTRL,0x04);
+	rtw_write8(adapter, REG_LDOA15_CTRL,0x04);
 	/* RF Control */
-	rtw_write8(Adapter, REG_RF_CTRL,0);
+	rtw_write8(adapter, REG_RF_CTRL,0);
 
 	/*   ==== Reset digital sequence   ====== */
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	_ResetDigitalProcedure1(Adapter, false);
+	_ResetDigitalProcedure1(adapter, false);
 #else
-	_ResetDigitalProcedure1(Adapter,true);
+	_ResetDigitalProcedure1(adapter,true);
 #endif
 
 	/*   ==== Pull GPIO PIN to balance level and LED control ====== */
-	_DisableGPIO(Adapter);
+	_DisableGPIO(adapter);
 
 	/*   ==== Reset digital sequence   ====== */
-	_ResetDigitalProcedure2(Adapter);
+	_ResetDigitalProcedure2(adapter);
 
 	/*   ==== Disable analog sequence === */
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	_DisableAnalog(Adapter,false);
+	_DisableAnalog(adapter,false);
 #else
-	_DisableAnalog(Adapter,true);
+	_DisableAnalog(adapter,true);
 #endif
 
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
-	value=rtw_read8(Adapter, REG_POWER_OFF_IN_PROCESS);
+	value=rtw_read8(adapter, REG_POWER_OFF_IN_PROCESS);
 	value&=(~BIT7);
-	rtw_write8(Adapter, REG_POWER_OFF_IN_PROCESS, value);
+	rtw_write8(adapter, REG_POWER_OFF_IN_PROCESS, value);
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
 
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("<====== Card Disable Without HWSM .\n")); */
@@ -2818,7 +2818,7 @@ _func_enter_;
 
 	if (RT_IN_PS_LEVEL(pwrpriv, RT_RF_OFF_LEVL_HALT_NIC))
 	{
-		DBG_8192D("HaltAdapter8192DUsb(): Not to haltadapter if HW already halt\n");
+		DBG_8192D("Haltadapter8192DUsb(): Not to haltadapter if HW already halt\n");
 		return _FAIL;
 	}
 
@@ -2829,7 +2829,7 @@ _func_enter_;
 
 	rtw_write16(padapter, REG_GPIO_MUXCFG, rtw_read16(padapter, REG_GPIO_MUXCFG)&(~BIT12));
 
-	if (/*Adapter->bInUsbIfTest ||*/ !pHalData->bSupportRemoteWakeUp) {
+	if (/*adapter->bInUsbIfTest ||*/ !pHalData->bSupportRemoteWakeUp) {
 		if (padapter->bCardDisableWOHSM == false)
 			CardDisableHWSM(padapter, false);
 		else
@@ -2933,12 +2933,12 @@ static unsigned int rtl8192du_inirp_dein
 
 static void
 _ReadPROMVersion(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8*	PROMContent,
 	bool		AutoloadFail
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 
 	if (AutoloadFail) {
 		pHalData->EEPROMVersion = EEPROM_Default_Version;
@@ -2963,12 +2963,12 @@ static u32 _GetChannelGroup(u32 channel)
 
 static void
 _ReadIDs(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8*		PROMContent,
 	bool		AutoloadFail
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 
 
 	if (false == AutoloadFail) {
@@ -3008,13 +3008,13 @@ _ReadIDs(
 
 static void
 _ReadMACAddress(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8*		PROMContent,
 	bool		AutoloadFail
 	)
 {
-	struct hal_data_8192du 		*pHalData = GET_HAL_DATA(Adapter);
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	struct hal_data_8192du 		*pHalData = GET_HAL_DATA(adapter);
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 
 	/*  Dual MAC should assign diffrent MAC address ,or, it is wil cause hang in single phy mode  zhiyuan 04/07/2010 */
 	/* Temply random assigh mac address for  efuse mac address not ready now */
@@ -3053,11 +3053,11 @@ _ReadMACAddress(
 
 static void
 hal_ReadMacPhyModeFromPROM92DU(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8*		PROMContent
 )
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 	u8	MacPhyCrValue = 0;
 
 
@@ -3065,24 +3065,24 @@ hal_ReadMacPhyModeFromPROM92DU(
 	if (MacPhyCrValue & BIT0)
 	{
 #ifdef CONFIG_DUALMAC_CONCURRENT
-		if (Adapter->registrypriv.mac_phy_mode == 3)
+		if (adapter->registrypriv.mac_phy_mode == 3)
 		{
 			pHalData->MacPhyMode92D = DUALMAC_SINGLEPHY;
-			Adapter->DualMacConcurrent = true;
+			adapter->DualMacConcurrent = true;
 		}
 		else
 		{
 			pHalData->MacPhyMode92D = DUALMAC_DUALPHY;
-			Adapter->DualMacConcurrent = false;
+			adapter->DualMacConcurrent = false;
 		}
 #else
 		pHalData->MacPhyMode92D = DUALMAC_DUALPHY;
 		DBG_8192D("hal_ReadMacPhyModeFromPROM92DU:: MacPhyMode DUALMAC_DUALPHY\n");
 #endif
 
-		if (Adapter->registrypriv.mac_phy_mode == 1)
+		if (adapter->registrypriv.mac_phy_mode == 1)
 			pHalData->MacPhyMode92D = SINGLEMAC_SINGLEPHY;
-		else	 if (Adapter->registrypriv.mac_phy_mode == 2)
+		else	 if (adapter->registrypriv.mac_phy_mode == 2)
 			pHalData->MacPhyMode92D = DUALMAC_DUALPHY;
 	}
 	else
@@ -3095,26 +3095,26 @@ hal_ReadMacPhyModeFromPROM92DU(
 
 static void
 hal_ReadMacPhyMode_92D(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8			*PROMContent,
 	bool		AutoloadFail
 )
 {
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 #endif /* CONFIG_DUALMAC_CONCURRENT */
 	u8	Mac1EnableValue = 0;
 
 
 
 	if (AutoloadFail==true) {
-		Mac1EnableValue = rtw_read8(Adapter,0xFE64);
-		PHY_ReadMacPhyMode92D(Adapter, AutoloadFail);
+		Mac1EnableValue = rtw_read8(adapter,0xFE64);
+		PHY_ReadMacPhyMode92D(adapter, AutoloadFail);
 
 		DBG_8192D("_ReadMacPhyMode(): AutoloadFail %d 0xFE64 = 0x%x\n",AutoloadFail, Mac1EnableValue);
 	}
 	else {
-		hal_ReadMacPhyModeFromPROM92DU(Adapter, PROMContent);
+		hal_ReadMacPhyModeFromPROM92DU(adapter, PROMContent);
 	}
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -3125,7 +3125,7 @@ hal_ReadMacPhyMode_92D(
 	if (GlobalFirstConfigurationForNormalChip)
 	{
 		RELEASE_GLOBAL_MUTEX(GlobalCounterForMutex);
-		PHY_ConfigMacPhyMode92D(Adapter);
+		PHY_ConfigMacPhyMode92D(adapter);
 		ACQUIRE_GLOBAL_MUTEX(GlobalCounterForMutex);
 		GlobalFirstConfigurationForNormalChip = false;
 		RELEASE_GLOBAL_MUTEX(GlobalCounterForMutex);
@@ -3133,24 +3133,24 @@ hal_ReadMacPhyMode_92D(
 	else
 	{
 		RELEASE_GLOBAL_MUTEX(GlobalCounterForMutex);
-		PHY_ReadMacPhyMode92D(Adapter, AutoloadFail);
+		PHY_ReadMacPhyMode92D(adapter, AutoloadFail);
 	}
 #else
-	PHY_ConfigMacPhyMode92D(Adapter);
+	PHY_ConfigMacPhyMode92D(adapter);
 #endif
 
-	PHY_ConfigMacPhyModeInfo92D(Adapter);
-	rtl8192d_ResetDualMacSwitchVariables(Adapter);
+	PHY_ConfigMacPhyModeInfo92D(adapter);
+	rtl8192d_ResetDualMacSwitchVariables(adapter);
 }
 
 static void
 _ReadBoardType(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8*		PROMContent,
 	bool		AutoloadFail
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 	u8			boardType;
 
 	if (AutoloadFail) {
@@ -3167,13 +3167,13 @@ _ReadBoardType(
 
 static void
 _ReadLEDSetting(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8*		PROMContent,
 	bool		AutoloadFail
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
-	struct led_priv		*pledpriv = &(Adapter->ledpriv);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct led_priv		*pledpriv = &(adapter->ledpriv);
 
 	/*  Led mode */
 	switch (pHalData->CustomerID)
@@ -3195,52 +3195,52 @@ _ReadLEDSetting(
 #ifdef CONFIG_WOWLAN
 static void
 _ReadWOWLAN(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8*		PROMContent,
 	bool		AutoloadFail
 	)
 {
 	if (AutoloadFail)
-		Adapter->pwrctrlpriv.bSupportRemoteWakeup = false;
+		adapter->pwrctrlpriv.bSupportRemoteWakeup = false;
 	else
 	{
 		/*  decide hw if support remote wakeup function */
 		/*  if hw supported, 8051 (SIE) will generate WeakUP signal(D+/D- toggle) when autoresume */
-		Adapter->pwrctrlpriv.bSupportRemoteWakeup = (PROMContent[EEPROM_Option_Setting] & BIT1)?true :false;
-		DBG_8192D("efuse remote wakeup =%d\n", Adapter->pwrctrlpriv.bSupportRemoteWakeup);
+		adapter->pwrctrlpriv.bSupportRemoteWakeup = (PROMContent[EEPROM_Option_Setting] & BIT1)?true :false;
+		DBG_8192D("efuse remote wakeup =%d\n", adapter->pwrctrlpriv.bSupportRemoteWakeup);
 	}
 }
 #endif /* CONFIG_WOWLAN */
 
-static void _InitAdapterVariablesByPROM(
-	struct rtw_adapter *	Adapter,
+static void _InitadapterVariablesByPROM(
+	struct rtw_adapter *	adapter,
 	u8*		PROMContent,
 	unsigned char AutoloadFail
 	)
 {
-	_ReadPROMVersion(Adapter, PROMContent, AutoloadFail);
-	_ReadIDs(Adapter, PROMContent, AutoloadFail);
-	_ReadMACAddress(Adapter, PROMContent, AutoloadFail);
-	rtl8192d_ReadTxPowerInfo(Adapter, PROMContent, AutoloadFail);
-	hal_ReadMacPhyMode_92D(Adapter, PROMContent, AutoloadFail);
-	rtl8192d_EfuseParseChnlPlan(Adapter, PROMContent, AutoloadFail);
-	_ReadBoardType(Adapter, PROMContent, AutoloadFail);
-	_ReadLEDSetting(Adapter, PROMContent, AutoloadFail);
+	_ReadPROMVersion(adapter, PROMContent, AutoloadFail);
+	_ReadIDs(adapter, PROMContent, AutoloadFail);
+	_ReadMACAddress(adapter, PROMContent, AutoloadFail);
+	rtl8192d_ReadTxPowerInfo(adapter, PROMContent, AutoloadFail);
+	hal_ReadMacPhyMode_92D(adapter, PROMContent, AutoloadFail);
+	rtl8192d_EfuseParseChnlPlan(adapter, PROMContent, AutoloadFail);
+	_ReadBoardType(adapter, PROMContent, AutoloadFail);
+	_ReadLEDSetting(adapter, PROMContent, AutoloadFail);
 #ifdef CONFIG_WOWLAN
-	_ReadWOWLAN(Adapter, PROMContent, AutoloadFail);
+	_ReadWOWLAN(adapter, PROMContent, AutoloadFail);
 #endif /* CONFIG_WOWLAN */
 }
 
 static void _ReadPROMContent(
-	struct rtw_adapter *		Adapter
+	struct rtw_adapter *		adapter
 	)
 {
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 	u8			PROMContent[HWSET_MAX_SIZE]={0};
 	u8			eeValue;
 	u32			i;
 
-	eeValue = rtw_read8(Adapter, REG_9346CR);
+	eeValue = rtw_read8(adapter, REG_9346CR);
 	/*  To check system boot selection. */
 	pEEPROM->EepromOrEfuse		= (eeValue & BOOT_FROM_EEPROM) ? true : false;
 	pEEPROM->bautoload_fail_flag	= (eeValue & EEPROM_EN) ? false : true;
@@ -3256,7 +3256,7 @@ static void _ReadPROMContent(
 		} else {
 			/*  Read EFUSE real map to shadow. */
 			ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
-			EFUSE_ShadowMapUpdate(Adapter, EFUSE_WIFI, false);
+			EFUSE_ShadowMapUpdate(adapter, EFUSE_WIFI, false);
 			RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
 			memcpy((void*)PROMContent, (void*)pEEPROM->efuse_eeprom_data, HWSET_MAX_SIZE);
 		}
@@ -3276,16 +3276,16 @@ static void _ReadPROMContent(
 	}
 
 
-	_InitAdapterVariablesByPROM(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
+	_InitadapterVariablesByPROM(adapter, PROMContent, pEEPROM->bautoload_fail_flag);
 }
 
 
 static void
 _InitOtherVariable(
-	struct rtw_adapter *		Adapter
+	struct rtw_adapter *		adapter
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 
 
 	/*  2009/06/10 MH For 92S 1*1=1R/ 1*2&2*2 use 2R. We default set 1*1 use radio A */
@@ -3301,10 +3301,10 @@ _InitOtherVariable(
 
 static void
 _ReadRFType(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 
 #if DISABLE_BB_RF
 	pHalData->rf_chip = RF_PSEUDO_11N;
@@ -3313,16 +3313,16 @@ _ReadRFType(
 #endif
 }
 
-static int _ReadAdapterInfo8192DU(struct rtw_adapter *	Adapter)
+static int _ReadadapterInfo8192DU(struct rtw_adapter *	adapter)
 {
 	u32 start=rtw_get_current_time();
 
 	DBG_8192D("====> %s\n", __func__);
 
-	_ReadRFType(Adapter);
-	_ReadPROMContent(Adapter);
+	_ReadRFType(adapter);
+	_ReadPROMContent(adapter);
 
-	_InitOtherVariable(Adapter);
+	_InitOtherVariable(adapter);
 
 	/* For 92DU Phy and Mac mode set ,will initialize by EFUSE/EPPROM     zhiyuan 2010/03/25 */
 	DBG_8192D("<==== %s in %d ms\n", __func__, rtw_get_passing_time_ms(start));
@@ -3330,12 +3330,12 @@ static int _ReadAdapterInfo8192DU(struct
 	return _SUCCESS;
 }
 
-static void ReadAdapterInfo8192DU(struct rtw_adapter * Adapter)
+static void ReadadapterInfo8192DU(struct rtw_adapter * adapter)
 {
 	/*  Read EEPROM size before call any EEPROM function */
-	Adapter->EepromAddressSize = GetEEPROMSize8192D(Adapter);
+	adapter->EepromAddressSize = GetEEPROMSize8192D(adapter);
 
-	_ReadAdapterInfo8192DU(Adapter);
+	_ReadadapterInfo8192DU(adapter);
 }
 
 #define GPIO_DEBUG_PORT_NUM 0
@@ -3355,47 +3355,47 @@ static void rtl8192du_trigger_gpio_0(str
 
 static void
 StopTxBeacon(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *	pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *	pHalData = GET_HAL_DATA(adapter);
 
 
 	DBG_8192D("StopTxBeacon\n");
 
-	rtw_write8(Adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
+	rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
 	pHalData->RegFwHwTxQCtrl &= (~BIT6);
-	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xff);
-	rtw_write8(Adapter, REG_TBTT_PROHIBIT+1, 0x64);
+	rtw_write8(adapter, REG_BCN_MAX_ERR, 0xff);
+	rtw_write8(adapter, REG_TBTT_PROHIBIT+1, 0x64);
 }
 
 static void
 ResumeTxBeacon(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du *	pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *	pHalData = GET_HAL_DATA(adapter);
 
 
 	DBG_8192D("ResumeTxBeacon\n");
 
-	rtw_write8(Adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
+	rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
 	pHalData->RegFwHwTxQCtrl |= BIT6;
-	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0x0a);
-	rtw_write8(Adapter, REG_TBTT_PROHIBIT+1, 0x64);
+	rtw_write8(adapter, REG_BCN_MAX_ERR, 0x0a);
+	rtw_write8(adapter, REG_TBTT_PROHIBIT+1, 0x64);
 }
 
 /*  */
 /*  2010.11.17. Added by tynli. */
 /*  */
-static u8 SelectRTSInitialRate(struct rtw_adapter *Adapter)
+static u8 SelectRTSInitialRate(struct rtw_adapter *adapter)
 {
 	struct sta_info		*psta;
-	struct mlme_priv		*pmlmepriv = &Adapter->mlmepriv;
-	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+	struct mlme_priv		*pmlmepriv = &adapter->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
-	struct sta_priv		*pstapriv = &Adapter->stapriv;
+	struct sta_priv		*pstapriv = &adapter->stapriv;
 	u8	bUseProtection;
 	u16	BasicRateCfg=0;
 	u8	SupportRateSet[NDIS_802_11_LENGTH_RATES_EX];
@@ -3413,7 +3413,7 @@ static u8 SelectRTSInitialRate(struct rt
 
 	memcpy(SupportRateSet, cur_network->SupportedRates, NDIS_802_11_LENGTH_RATES_EX);
 
-	halsetbratecfg(Adapter, SupportRateSet, &BasicRateCfg);
+	halsetbratecfg(adapter, SupportRateSet, &BasicRateCfg);
 
 	if (bUseProtection &&
 		(!(pmlmeext->cur_wireless_mode == WIRELESS_11A|| pmlmeext->cur_wireless_mode == WIRELESS_11A_5N)))/*  5G not support cck rate */
@@ -3431,7 +3431,7 @@ static u8 SelectRTSInitialRate(struct rt
 		/* MacId 0: INFRA mode. */
 		if ((check_fwstate(pmlmepriv, _FW_LINKED)== true)&&(check_fwstate(pmlmepriv, WIFI_STATION_STATE)==true))
 		{
-			LowestRateIdx = rtw_read8(Adapter, REG_INIDATA_RATE_SEL)&0x3f;
+			LowestRateIdx = rtw_read8(adapter, REG_INIDATA_RATE_SEL)&0x3f;
 		}
 
 		/*  Adjust RTS Init rate when the data rate is MCS0~2, 8~10 which is lower than 24M. */
@@ -3473,94 +3473,94 @@ static u8 SelectRTSInitialRate(struct rt
 /*  */
 static void SetRTSRateWorkItemCallback(void *pContext)
 {
-	struct rtw_adapter *Adapter =  (struct rtw_adapter *)pContext;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct rtw_adapter *adapter =  (struct rtw_adapter *)pContext;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	NewRTSInitRate = 0;
 
-	NewRTSInitRate = SelectRTSInitialRate(Adapter);
+	NewRTSInitRate = SelectRTSInitialRate(adapter);
 	if (NewRTSInitRate != pHalData->RTSInitRate)
 	{
-		rtw_write8(Adapter, REG_INIRTS_RATE_SEL, NewRTSInitRate);
+		rtw_write8(adapter, REG_INIRTS_RATE_SEL, NewRTSInitRate);
 		pHalData->RTSInitRate = NewRTSInitRate;
 	}
 
 	DBG_8192D("HW_VAR_INIT_RTS_RATE: RateIndex(%d)\n", NewRTSInitRate);
 }
 
-static void hw_var_set_opmode(struct rtw_adapter * Adapter, u8 variable, u8* val)
+static void hw_var_set_opmode(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
 	u8	val8;
 	u8	mode = *((u8 *)val);
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (Adapter->iface_type == IFACE_PORT1)
+	if (adapter->iface_type == IFACE_PORT1)
 	{
 		/*  disable Port1 TSF update */
-		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
+		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(4));
 
 		/*  set net_type */
-		val8 = rtw_read8(Adapter, MSR)&0x03;
+		val8 = rtw_read8(adapter, MSR)&0x03;
 		val8 |= (mode<<2);
-		rtw_write8(Adapter, MSR, val8);
+		rtw_write8(adapter, MSR, val8);
 
 		/* reset TSF1 */
-		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1));
+		rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(1));
 
 		DBG_8192D("%s()-%d mode = %d\n", __func__, __LINE__, mode);
 
 		if ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
 		{
-			if (!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
+			if (!check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
 			{
-				StopTxBeacon(Adapter);
+				StopTxBeacon(adapter);
 			}
 
-			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x19);/* disable atim wnd */
+			rtw_write8(adapter,REG_BCN_CTRL_1, 0x19);/* disable atim wnd */
 		}
 		else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
 		{
-			ResumeTxBeacon(Adapter);
-			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x1a);
+			ResumeTxBeacon(adapter);
+			rtw_write8(adapter,REG_BCN_CTRL_1, 0x1a);
 		}
 		else if (mode == _HW_STATE_AP_)
 		{
-			ResumeTxBeacon(Adapter);
+			ResumeTxBeacon(adapter);
 
-			rtw_write8(Adapter, REG_BCN_CTRL_1, 0x12);
+			rtw_write8(adapter, REG_BCN_CTRL_1, 0x12);
 
 			/* Set RCR */
-			rtw_write32(Adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
+			rtw_write32(adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
 			/* enable to rx data frame */
-			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
+			rtw_write16(adapter, REG_RXFLTMAP2, 0xFFFF);
 			/* enable to rx ps-poll */
-			rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
+			rtw_write16(adapter, REG_RXFLTMAP1, 0x0400);
 
 			/* Beacon Control related register for first time */
-			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); /*  2ms */
-			rtw_write8(Adapter, REG_DRVERLYINT, 0x05);/*  5ms */
-			rtw_write8(Adapter, REG_ATIMWND_1, 0x0a); /*  10ms for port1 */
-			rtw_write16(Adapter, REG_BCNTCFG, 0x00);
-			rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);
-			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);/*  +32767 (~32ms) */
+			rtw_write8(adapter, REG_BCNDMATIM, 0x02); /*  2ms */
+			rtw_write8(adapter, REG_DRVERLYINT, 0x05);/*  5ms */
+			rtw_write8(adapter, REG_ATIMWND_1, 0x0a); /*  10ms for port1 */
+			rtw_write16(adapter, REG_BCNTCFG, 0x00);
+			rtw_write16(adapter, REG_TBTT_PROHIBIT, 0xff04);
+			rtw_write16(adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);/*  +32767 (~32ms) */
 
 
 		       /* enable BCN1 Function for if2 */
 			/* don't enable update TSF1 for if2 (due to TSF update when beacon/probe rsp are received) */
-			rtw_write8(Adapter, REG_BCN_CTRL_1, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
+			rtw_write8(adapter, REG_BCN_CTRL_1, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
 
-			DBG_8192D("%s()-%d: REG_BCN_CTRL_1 = %02x\n", __func__, __LINE__, rtw_read8(Adapter, REG_BCN_CTRL_1));
+			DBG_8192D("%s()-%d: REG_BCN_CTRL_1 = %02x\n", __func__, __LINE__, rtw_read8(adapter, REG_BCN_CTRL_1));
 
-			if (check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
-				rtw_write8(Adapter, REG_BCN_CTRL,
-					rtw_read8(Adapter, REG_BCN_CTRL) & ~EN_BCN_FUNCTION);
+			if (check_buddy_fwstate(adapter, WIFI_FW_NULL_STATE))
+				rtw_write8(adapter, REG_BCN_CTRL,
+					rtw_read8(adapter, REG_BCN_CTRL) & ~EN_BCN_FUNCTION);
 
 			/* dis BCN0 ATIM  WND if if1 is station */
-			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(0));
+			rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(0));
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 			/*  Reset TSF for STA+AP concurrent mode */
-			if (check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE))) {
-				if (reset_tsf(Adapter, IFACE_PORT1) == false)
+			if (check_buddy_fwstate(adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE))) {
+				if (reset_tsf(adapter, IFACE_PORT1) == false)
 					DBG_8192D("ERROR! %s()-%d: Reset port1 TSF fail\n",
 						__func__, __LINE__);
 			}
@@ -3568,76 +3568,76 @@ static void hw_var_set_opmode(struct rtw
 		}
 
 	}
-	else	/*  (Adapter->iface_type == IFACE_PORT1) */
+	else	/*  (adapter->iface_type == IFACE_PORT1) */
 #endif /* CONFIG_CONCURRENT_MODE */
 	{
 		/*  disable Port0 TSF update */
-		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+		rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
 
 		/*  set net_type */
-		val8 = rtw_read8(Adapter, MSR)&0x0c;
+		val8 = rtw_read8(adapter, MSR)&0x0c;
 		val8 |= mode;
-		rtw_write8(Adapter, MSR, val8);
+		rtw_write8(adapter, MSR, val8);
 
 		/* reset TSF0 */
-		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));
+		rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(0));
 
 		DBG_8192D("%s()-%d mode = %d\n", __func__, __LINE__, mode);
 
 		if ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
 		{
 #ifdef CONFIG_CONCURRENT_MODE
-			if (!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
+			if (!check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
 #endif /* CONFIG_CONCURRENT_MODE */
 			{
-				StopTxBeacon(Adapter);
+				StopTxBeacon(adapter);
 			}
 
-			rtw_write8(Adapter,REG_BCN_CTRL, 0x19);/* disable atim wnd */
+			rtw_write8(adapter,REG_BCN_CTRL, 0x19);/* disable atim wnd */
 		}
 		else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
 		{
-			ResumeTxBeacon(Adapter);
-			rtw_write8(Adapter,REG_BCN_CTRL, 0x1a);
+			ResumeTxBeacon(adapter);
+			rtw_write8(adapter,REG_BCN_CTRL, 0x1a);
 		}
 		else if (mode == _HW_STATE_AP_)
 		{
-			ResumeTxBeacon(Adapter);
+			ResumeTxBeacon(adapter);
 
-			rtw_write8(Adapter, REG_BCN_CTRL, 0x12);
+			rtw_write8(adapter, REG_BCN_CTRL, 0x12);
 
 			/* Set RCR */
-			rtw_write32(Adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
+			rtw_write32(adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
 			/* enable to rx data frame */
-			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
+			rtw_write16(adapter, REG_RXFLTMAP2, 0xFFFF);
 			/* enable to rx ps-poll */
-			rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
+			rtw_write16(adapter, REG_RXFLTMAP1, 0x0400);
 
 			/* Beacon Control related register for first time */
 
-			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); /*  2ms */
-			rtw_write8(Adapter, REG_DRVERLYINT, 0x05);/*  5ms */
+			rtw_write8(adapter, REG_BCNDMATIM, 0x02); /*  2ms */
+			rtw_write8(adapter, REG_DRVERLYINT, 0x05);/*  5ms */
 
-			rtw_write8(Adapter, REG_ATIMWND, 0x0a); /*  10ms for port0 */
-			rtw_write16(Adapter, REG_BCNTCFG, 0x00);
-			rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);
-			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);/*  +32767 (~32ms) */
+			rtw_write8(adapter, REG_ATIMWND, 0x0a); /*  10ms for port0 */
+			rtw_write16(adapter, REG_BCNTCFG, 0x00);
+			rtw_write16(adapter, REG_TBTT_PROHIBIT, 0xff04);
+			rtw_write16(adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);/*  +32767 (~32ms) */
 
 		        /* enable BCN0 Function for if1 */
 			/* don't enable update TSF0 for if1 (due to TSF update when beacon/probe rsp are received) */
-			rtw_write8(Adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
+			rtw_write8(adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
 
 #ifdef CONFIG_CONCURRENT_MODE
-			if (check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
-				rtw_write8(Adapter, REG_BCN_CTRL_1,
-					rtw_read8(Adapter, REG_BCN_CTRL_1) & ~EN_BCN_FUNCTION);
+			if (check_buddy_fwstate(adapter, WIFI_FW_NULL_STATE))
+				rtw_write8(adapter, REG_BCN_CTRL_1,
+					rtw_read8(adapter, REG_BCN_CTRL_1) & ~EN_BCN_FUNCTION);
 
 			/* dis BCN1 ATIM  WND if if2 is station */
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(0));
+			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(0));
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 			/*  Reset TSF for STA+AP concurrent mode */
-			if (check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE))) {
-				if (reset_tsf(Adapter, IFACE_PORT0) == false)
+			if (check_buddy_fwstate(adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE))) {
+				if (reset_tsf(adapter, IFACE_PORT0) == false)
 					DBG_8192D("ERROR! %s()-%d: Reset port0 TSF fail\n",
 						__func__, __LINE__);
 			}
@@ -3648,13 +3648,13 @@ static void hw_var_set_opmode(struct rtw
 	}
 }
 
-static void hw_var_set_macaddr(struct rtw_adapter * Adapter, u8 variable, u8* val)
+static void hw_var_set_macaddr(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
 	u8 idx = 0;
 	u32 reg_macid;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (Adapter->iface_type == IFACE_PORT1)
+	if (adapter->iface_type == IFACE_PORT1)
 	{
 		reg_macid = REG_MACID1;
 	}
@@ -3666,17 +3666,17 @@ static void hw_var_set_macaddr(struct rt
 
 	for (idx = 0 ; idx < 6; idx++)
 	{
-		rtw_write8(Adapter, (reg_macid+idx), val[idx]);
+		rtw_write8(adapter, (reg_macid+idx), val[idx]);
 	}
 }
 
-static void hw_var_set_bssid(struct rtw_adapter * Adapter, u8 variable, u8* val)
+static void hw_var_set_bssid(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
 	u8	idx = 0;
 	u32 reg_bssid;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (Adapter->iface_type == IFACE_PORT1)
+	if (adapter->iface_type == IFACE_PORT1)
 	{
 		reg_bssid = REG_BSSID1;
 	}
@@ -3688,26 +3688,26 @@ static void hw_var_set_bssid(struct rtw_
 
 	for (idx = 0 ; idx < 6; idx++)
 	{
-		rtw_write8(Adapter, (reg_bssid+idx), val[idx]);
+		rtw_write8(adapter, (reg_bssid+idx), val[idx]);
 	}
 }
 
-static void hw_var_set_bcn_func(struct rtw_adapter * Adapter, u8 variable, u8* val)
+static void hw_var_set_bcn_func(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
 	u32 bcn_ctrl_reg;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (Adapter->iface_type == IFACE_PORT1)
+	if (adapter->iface_type == IFACE_PORT1)
 	{
 		bcn_ctrl_reg = REG_BCN_CTRL_1;
 
 		if (*((u8 *)val))
 		{
-			rtw_write8(Adapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
+			rtw_write8(adapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
 		}
 		else
 		{
-			rtw_write8(Adapter, bcn_ctrl_reg, rtw_read8(Adapter, bcn_ctrl_reg)&(~(EN_BCN_FUNCTION | EN_TXBCN_RPT)));
+			rtw_write8(adapter, bcn_ctrl_reg, rtw_read8(adapter, bcn_ctrl_reg)&(~(EN_BCN_FUNCTION | EN_TXBCN_RPT)));
 		}
 	}
 	else
@@ -3716,20 +3716,20 @@ static void hw_var_set_bcn_func(struct r
 		bcn_ctrl_reg = REG_BCN_CTRL;
 		if (*((u8 *)val))
 		{
-			rtw_write8(Adapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
+			rtw_write8(adapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
 		}
 		else
 		{
-			rtw_write8(Adapter, bcn_ctrl_reg, (rtw_read8(Adapter, bcn_ctrl_reg)&(~(EN_TXBCN_RPT))) | DIS_TSF_UDT0_NORMAL_CHIP);
+			rtw_write8(adapter, bcn_ctrl_reg, (rtw_read8(adapter, bcn_ctrl_reg)&(~(EN_TXBCN_RPT))) | DIS_TSF_UDT0_NORMAL_CHIP);
 		}
 	}
 }
 
-static void hw_var_set_correct_tsf(struct rtw_adapter * Adapter, u8 variable, u8* val)
+static void hw_var_set_correct_tsf(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
 #ifdef CONFIG_CONCURRENT_MODE
 	u64	tsf;
-	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 
@@ -3737,63 +3737,63 @@ static void hw_var_set_correct_tsf(struc
 
 	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 	{
-		StopTxBeacon(Adapter);
+		StopTxBeacon(adapter);
 	}
 
-	if (Adapter->iface_type == IFACE_PORT1)
+	if (adapter->iface_type == IFACE_PORT1)
 	{
 		/* disable related TSF function */
-		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
+		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)&(~BIT(3)));
 
-		rtw_write32(Adapter, REG_TSFTR1, tsf);
-		rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
+		rtw_write32(adapter, REG_TSFTR1, tsf);
+		rtw_write32(adapter, REG_TSFTR1+4, tsf>>32);
 
 		/* enable related TSF function */
-		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));
+		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(3));
 
 
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 		/*  Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue! */
 		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)) {
-			if (reset_tsf(Adapter, IFACE_PORT0) == false)
+			&& check_buddy_fwstate(adapter, WIFI_AP_STATE)) {
+			if (reset_tsf(adapter, IFACE_PORT0) == false)
 				DBG_8192D("ERROR! %s()-%d: Reset port0 TSF fail\n",
 					__func__, __LINE__);
 		}
 #endif	/*  CONFIG_TSF_RESET_OFFLOAD */
 
 	}
-	else	/*  Adapter->iface_type == IFACE_PORT1 */
+	else	/*  adapter->iface_type == IFACE_PORT1 */
 	{
 		/* disable related TSF function */
-		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
+		rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(3)));
 		/*  disable TSF update instead! May induce burst beacon TX */
 
-		rtw_write32(Adapter, REG_TSFTR, tsf);
-		rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
+		rtw_write32(adapter, REG_TSFTR, tsf);
+		rtw_write32(adapter, REG_TSFTR+4, tsf>>32);
 
 		/* enable related TSF function */
-		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
+		rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(3));
 
 		/*  Update buddy port's TSF if it is SoftAP for beacon TX issue! */
 		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)
+			&& check_buddy_fwstate(adapter, WIFI_AP_STATE)
 		) {
 			/* disable related TSF function */
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
+			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)&(~BIT(3)));
 			/*  disable TSF update instead! */
 
-			rtw_write32(Adapter, REG_TSFTR1, tsf);
-			rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
+			rtw_write32(adapter, REG_TSFTR1, tsf);
+			rtw_write32(adapter, REG_TSFTR1+4, tsf>>32);
 
 			/* enable related TSF function */
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));
+			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(3));
 		}
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 		/*  Update buddy port's TSF if it is SoftAP for beacon TX issue! */
 		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)) {
-			if (reset_tsf(Adapter, IFACE_PORT1) == false)
+			&& check_buddy_fwstate(adapter, WIFI_AP_STATE)) {
+			if (reset_tsf(adapter, IFACE_PORT1) == false)
 				DBG_8192D("ERROR! %s()-%d: Reset port1 TSF fail\n",
 					__func__, __LINE__);
 		}
@@ -3803,42 +3803,42 @@ static void hw_var_set_correct_tsf(struc
 
 	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 	{
-		ResumeTxBeacon(Adapter);
+		ResumeTxBeacon(adapter);
 	}
 #endif	/*  CONFIG_CONCURRENT_MODE */
 }
 
 
-static void hw_var_set_mlme_disconnect(struct rtw_adapter * Adapter, u8 variable, u8* val)
+static void hw_var_set_mlme_disconnect(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
 #ifdef CONFIG_CONCURRENT_MODE
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	struct rtw_adapter * pbuddy_adapter = Adapter->pbuddy_adapter;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
 
 
-	if (check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))
-		rtw_write16(Adapter, REG_RXFLTMAP2, 0x00);
+	if (check_buddy_mlmeinfo_state(adapter, _HW_STATE_NOLINK_))
+		rtw_write16(adapter, REG_RXFLTMAP2, 0x00);
 
 
-	if (Adapter->iface_type == IFACE_PORT1)
+	if (adapter->iface_type == IFACE_PORT1)
 	{
 		int i;
 		u8 reg_bcn_ctrl_1;
 
 		/*  a.Driver set 0x422 bit 6 =0 */
-		rtw_write8(Adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
+		rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
 		pHalData->RegFwHwTxQCtrl &= (~BIT6);
 
 
 #ifdef CONFIG_BEACON_DISABLE_OFFLOAD
-		u8 reg_bcn_disable_cnt = rtw_read8(Adapter, REG_FW_BCN_DIS_CNT);
+		u8 reg_bcn_disable_cnt = rtw_read8(adapter, REG_FW_BCN_DIS_CNT);
 		DBG_8192D("%s()-%d: reg_bcn_disable_cnt=%02x\n", __func__, __LINE__, reg_bcn_disable_cnt);
 
-		reg_bcn_ctrl_1 = rtw_read8(Adapter, REG_BCN_CTRL_1);
+		reg_bcn_ctrl_1 = rtw_read8(adapter, REG_BCN_CTRL_1);
 		DBG_8192D("%s()-%d: reg_bcn_ctrl_1=%02x\n", __func__, __LINE__, reg_bcn_ctrl_1);
 
 		/*  b. driver set h2c cmd */
-		rtl8192c_dis_beacon_fun_cmd(Adapter);
+		rtl8192c_dis_beacon_fun_cmd(adapter);
 
 		/*
 			  FW Job for port 0
@@ -3857,65 +3857,65 @@ static void hw_var_set_mlme_disconnect(s
 		rtw_msleep_os(120);
 
 		for (i=0; i< 10; i++) {
-			reg_bcn_ctrl_1 = rtw_read8(Adapter, REG_BCN_CTRL_1);
+			reg_bcn_ctrl_1 = rtw_read8(adapter, REG_BCN_CTRL_1);
 			if ((reg_bcn_ctrl_1 & BIT(3)) == 0) {
 				break;
 			}
 			DBG_8192D("%s()-%d: BEACON_DISABLE_OFFLOAD not finished! REG_BCN_CTRL_1=%02x\n", __func__, __LINE__, reg_bcn_ctrl_1);
-			DBG_8192D("%s()-%d: reg_bcn_disable_cnt=%02x\n", __func__, __LINE__, rtw_read8(Adapter, REG_FW_BCN_DIS_CNT));
-			DBG_8192D("%s()-%d: REG_BCN_CTRL=%02x\n", __func__, __LINE__, rtw_read8(Adapter, REG_BCN_CTRL));
-			DBG_8192D("%s()-%d: FWISR=%08x\n", __func__, __LINE__, rtw_read32(Adapter, REG_FWISR));
+			DBG_8192D("%s()-%d: reg_bcn_disable_cnt=%02x\n", __func__, __LINE__, rtw_read8(adapter, REG_FW_BCN_DIS_CNT));
+			DBG_8192D("%s()-%d: REG_BCN_CTRL=%02x\n", __func__, __LINE__, rtw_read8(adapter, REG_BCN_CTRL));
+			DBG_8192D("%s()-%d: FWISR=%08x\n", __func__, __LINE__, rtw_read32(adapter, REG_FWISR));
 			rtw_msleep_os(100);
 		}
-		DBG_8192D("%s()-%d: reg_bcn_disable_cnt=%02x\n", __func__, __LINE__, rtw_read8(Adapter, REG_FW_BCN_DIS_CNT));
+		DBG_8192D("%s()-%d: reg_bcn_disable_cnt=%02x\n", __func__, __LINE__, rtw_read8(adapter, REG_FW_BCN_DIS_CNT));
 		DBG_8192D("%s()-%d: reg_bcn_ctrl_1=%02x\n", __func__, __LINE__, reg_bcn_ctrl_1);
 
 #else   /*  CONFIG_BEACON_DISABLE_OFFLOAD */
 
 		/* disable update TSF1 */
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
+			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(4));
 
 		/* reset TSF1 */
-		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1));
+		rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(1));
 
 		/*  disable Port1's beacon function */
-		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
+		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)&(~BIT(3)));
 
 #endif  /*  CONFIG_BEACON_DISABLE_OFFLOAD */
 
 		/*  j, Driver set 0x422 bit 6 =1 */
-		rtw_write8(Adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
+		rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
 		pHalData->RegFwHwTxQCtrl |= BIT6;
 
 		/*  k. re_download beacon pkt */
-		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
 			set_tx_beacon_cmd(pbuddy_adapter);
 
 
 	}
-	else	/*  (Adapter->iface_type == IFACE_PORT1) */
+	else	/*  (adapter->iface_type == IFACE_PORT1) */
 	{
 		/* disable update TSF */
-			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+			rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
 
 		/* reset TSF */
-		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));
+		rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(0));
 
 		/*  Can't disable Port0's beacon function due to it is used by RA */
 	}
 #endif
 }
 
-static void hw_var_set_mlme_sitesurvey(struct rtw_adapter * Adapter, u8 variable, u8* val)
+static void hw_var_set_mlme_sitesurvey(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
 	u32	value_rcr, rcr_clear_bit, reg_bcn_ctl;
 	u16	value_rxfltmap2;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	struct mlme_priv *pmlmepriv=&(Adapter->mlmepriv);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_priv *pmlmepriv=&(adapter->mlmepriv);
 
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (Adapter->iface_type == IFACE_PORT1)
+	if (adapter->iface_type == IFACE_PORT1)
 		reg_bcn_ctl = REG_BCN_CTRL_1;
 	else
 #endif
@@ -3925,11 +3925,11 @@ static void hw_var_set_mlme_sitesurvey(s
 
 	if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 #ifdef CONFIG_CONCURRENT_MODE
-		|| (check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true)
+		|| (check_buddy_fwstate(adapter, WIFI_AP_STATE) == true)
 #endif
 #ifdef CONFIG_TDLS
 		/*  TDLS will clear RCR_CBSSID_DATA bit for connection. */
-		|| (Adapter->tdlsinfo.setup_state & TDLS_LINKED_STATE)
+		|| (adapter->tdlsinfo.setup_state & TDLS_LINKED_STATE)
 #endif /*  CONFIG_TDLS */
 		)
 	{
@@ -3952,30 +3952,30 @@ static void hw_var_set_mlme_sitesurvey(s
 
 #endif /* CONFIG_FIND_BEST_CHANNEL */
 
-	value_rcr = rtw_read32(Adapter, REG_RCR);
+	value_rcr = rtw_read32(adapter, REG_RCR);
 
 	if (*((u8 *)val))/* under sitesurvey */
 	{
 		pHalData->bLoadIMRandIQKSettingFor2G = false;
 
 		value_rcr &= ~(rcr_clear_bit);
-		rtw_write32(Adapter, REG_RCR, value_rcr);
+		rtw_write32(adapter, REG_RCR, value_rcr);
 
-		rtw_write16(Adapter, REG_RXFLTMAP2, value_rxfltmap2);
+		rtw_write16(adapter, REG_RXFLTMAP2, value_rxfltmap2);
 
 		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE |WIFI_ADHOC_MASTER_STATE)) {
 			/* disable update TSF */
-			rtw_write8(Adapter, reg_bcn_ctl, rtw_read8(Adapter, reg_bcn_ctl)|BIT(4));
+			rtw_write8(adapter, reg_bcn_ctl, rtw_read8(adapter, reg_bcn_ctl)|BIT(4));
 		}
 
 		/*  Save orignal RRSR setting. */
-		pHalData->RegRRSR = rtw_read16(Adapter, REG_RRSR);
+		pHalData->RegRRSR = rtw_read16(adapter, REG_RRSR);
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(adapter, _FW_LINKED))
 		{
-			StopTxBeacon(Adapter);
+			StopTxBeacon(adapter);
 		}
 #endif
 	}
@@ -3983,58 +3983,58 @@ static void hw_var_set_mlme_sitesurvey(s
 	{
 		if (check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pmlmepriv, WIFI_AP_STATE)
 #ifdef CONFIG_CONCURRENT_MODE
-			|| check_buddy_fwstate(Adapter, _FW_LINKED) || check_buddy_fwstate(Adapter, WIFI_AP_STATE)
+			|| check_buddy_fwstate(adapter, _FW_LINKED) || check_buddy_fwstate(adapter, WIFI_AP_STATE)
 #endif
 			)
 		{
 			/* enable to rx data frame */
-			rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
+			rtw_write16(adapter, REG_RXFLTMAP2,0xFFFF);
 		}
 
 		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE |WIFI_ADHOC_MASTER_STATE)) {
 			/* enable update TSF */
-			rtw_write8(Adapter, reg_bcn_ctl, rtw_read8(Adapter, reg_bcn_ctl)&(~BIT(4)));
+			rtw_write8(adapter, reg_bcn_ctl, rtw_read8(adapter, reg_bcn_ctl)&(~BIT(4)));
 		}
 
 		value_rcr |= rcr_clear_bit;
-		rtw_write32(Adapter, REG_RCR, value_rcr);
+		rtw_write32(adapter, REG_RCR, value_rcr);
 
 		/*  Restore orignal RRSR setting. */
-		rtw_write16(Adapter, REG_RRSR, pHalData->RegRRSR);
+		rtw_write16(adapter, REG_RRSR, pHalData->RegRRSR);
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(adapter, _FW_LINKED))
 		{
-			ResumeTxBeacon(Adapter);
+			ResumeTxBeacon(adapter);
 		}
 #endif
 	}
 }
 
-static void hw_var_set_mlme_join(struct rtw_adapter * Adapter, u8 variable, u8* val)
+static void hw_var_set_mlme_join(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
 #ifdef CONFIG_CONCURRENT_MODE
 	u8	RetryLimit = 0x30;
 	u8	type = *((u8 *)val);
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
 
 	if (type == 0) /*  prepare to join */
 	{
-		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(adapter, _FW_LINKED))
 		{
-			StopTxBeacon(Adapter);
+			StopTxBeacon(adapter);
 		}
 
 		/* enable to rx data frame.Accept all data frame */
-		rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
+		rtw_write16(adapter, REG_RXFLTMAP2,0xFFFF);
 
-		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
-			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_BCN);
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
+			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_BCN);
 		else
-			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
 
 		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 		{
@@ -4050,96 +4050,96 @@ static void hw_var_set_mlme_join(struct
 	}
 	else if (type == 1) /* joinbss_event call back when join res < 0 */
 	{
-		if (check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))
-			rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
+		if (check_buddy_mlmeinfo_state(adapter, _HW_STATE_NOLINK_))
+			rtw_write16(adapter, REG_RXFLTMAP2,0x00);
 
-		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(adapter, _FW_LINKED))
 		{
-			ResumeTxBeacon(Adapter);
+			ResumeTxBeacon(adapter);
 		}
 	}
 	else if (type == 2) /* sta add event call back */
 	{
 
 		/* enable update TSF */
-		if (Adapter->iface_type == IFACE_PORT1)
-			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
+		if (adapter->iface_type == IFACE_PORT1)
+			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)&(~BIT(4)));
 		else
-			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
+			rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
 
 
 		if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
 		{
 			/* fixed beacon issue for 8191su........... */
-			rtw_write8(Adapter,0x542 ,0x02);
+			rtw_write8(adapter,0x542 ,0x02);
 			RetryLimit = 0x7;
 		}
 
 
-		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(adapter, _FW_LINKED))
 		{
-			ResumeTxBeacon(Adapter);
+			ResumeTxBeacon(adapter);
 		}
 
 	}
 
-	rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+	rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
 
 #endif
 }
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-static void dc_hw_var_mlme_sitesurvey(struct rtw_adapter * Adapter, u8 sitesurvey_state)
+static void dc_hw_var_mlme_sitesurvey(struct rtw_adapter * adapter, u8 sitesurvey_state)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	struct rtw_adapter *BuddyAdapter = Adapter->pbuddy_adapter;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct rtw_adapter *Buddyadapter = adapter->pbuddy_adapter;
 	struct mlme_priv *pbuddy_mlmepriv;
 	struct mlme_ext_priv *pbuddy_mlmeext;
 
-	if ((BuddyAdapter !=NULL) &&
-		Adapter->DualMacConcurrent == true)
+	if ((Buddyadapter !=NULL) &&
+		adapter->DualMacConcurrent == true)
 	{
-		pbuddy_mlmepriv = &(BuddyAdapter->mlmepriv);
-		pbuddy_mlmeext = &BuddyAdapter->mlmeextpriv;
+		pbuddy_mlmepriv = &(Buddyadapter->mlmepriv);
+		pbuddy_mlmeext = &Buddyadapter->mlmeextpriv;
 
 		if (sitesurvey_state)/* under sitesurvey */
 		{
-			if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-				check_buddy_fwstate(Adapter, _FW_LINKED))
+			if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+				check_buddy_fwstate(adapter, _FW_LINKED))
 			{
-				StopTxBeacon(BuddyAdapter);
+				StopTxBeacon(Buddyadapter);
 			}
 
-			rtw_write16(Adapter, REG_RRSR, 0x150);
+			rtw_write16(adapter, REG_RRSR, 0x150);
 		}
 		else/* sitesurvey done */
 		{
-			if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-				check_buddy_fwstate(Adapter, _FW_LINKED))
+			if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+				check_buddy_fwstate(adapter, _FW_LINKED))
 			{
-				ResumeTxBeacon(BuddyAdapter);
+				ResumeTxBeacon(Buddyadapter);
 			}
 		}
 	}
 }
 
-static void dc_hw_var_mlme_join(struct rtw_adapter * Adapter, u8 join_state)
+static void dc_hw_var_mlme_join(struct rtw_adapter * adapter, u8 join_state)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct rtw_adapter * BuddyAdapter = Adapter->pbuddy_adapter;
+	struct rtw_adapter * Buddyadapter = adapter->pbuddy_adapter;
 	struct mlme_priv *pbuddy_mlmepriv;
 	struct mlme_ext_priv *pbuddy_mlmeext;
 
 
-	if ((BuddyAdapter !=NULL) &&
-		Adapter->DualMacConcurrent == true)
+	if ((Buddyadapter !=NULL) &&
+		adapter->DualMacConcurrent == true)
 	{
-		pbuddy_mlmepriv = &(BuddyAdapter->mlmepriv);
-		pbuddy_mlmeext = &BuddyAdapter->mlmeextpriv;
+		pbuddy_mlmepriv = &(Buddyadapter->mlmepriv);
+		pbuddy_mlmeext = &Buddyadapter->mlmeextpriv;
 
 		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel ||
 			pmlmeext->cur_bwmode != pbuddy_mlmeext->cur_bwmode ||
@@ -4147,18 +4147,18 @@ static void dc_hw_var_mlme_join(struct r
 		{
 			if (join_state == 0)/*  prepare to join */
 			{
-				if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-					check_buddy_fwstate(Adapter, _FW_LINKED))
+				if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+					check_buddy_fwstate(adapter, _FW_LINKED))
 				{
-					StopTxBeacon(BuddyAdapter);
+					StopTxBeacon(Buddyadapter);
 				}
 			}
 			else/* join success or fail */
 			{
-				if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-					check_buddy_fwstate(Adapter, _FW_LINKED))
+				if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+					check_buddy_fwstate(adapter, _FW_LINKED))
 				{
-					ResumeTxBeacon(BuddyAdapter);
+					ResumeTxBeacon(Buddyadapter);
 				}
 			}
 		}
@@ -4166,9 +4166,9 @@ static void dc_hw_var_mlme_join(struct r
 }
 #endif
 
-static void SetHwReg8192DU(struct rtw_adapter * Adapter, u8 variable, u8* val)
+static void SetHwReg8192DU(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
 _func_enter_;
@@ -4179,23 +4179,23 @@ _func_enter_;
 			{
 				u8 val8;
 
-				val8 = rtw_read8(Adapter, MSR)&0x0c;
+				val8 = rtw_read8(adapter, MSR)&0x0c;
 				val8 |= *((u8 *)val);
-				rtw_write8(Adapter, MSR, val8);
+				rtw_write8(adapter, MSR, val8);
 			}
 			break;
 		case HW_VAR_MEDIA_STATUS1:
 			{
 				u8 val8;
 
-				val8 = rtw_read8(Adapter, MSR)&0x03;
+				val8 = rtw_read8(adapter, MSR)&0x03;
 				val8 |= *((u8 *)val) <<2;
-				rtw_write8(Adapter, MSR, val8);
+				rtw_write8(adapter, MSR, val8);
 			}
 			break;
 		case HW_VAR_SET_OPMODE:
 #if defined(CONFIG_CONCURRENT_MODE)
-			hw_var_set_opmode(Adapter, variable, val);
+			hw_var_set_opmode(adapter, variable, val);
 #else /* CONFIG_CONCURRENT_MODE */
 			{
 				u8	val8;
@@ -4203,80 +4203,80 @@ _func_enter_;
 
 				if ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
 				{
-					StopTxBeacon(Adapter);
-					rtw_write8(Adapter,REG_BCN_CTRL, 0x18);
+					StopTxBeacon(adapter);
+					rtw_write8(adapter,REG_BCN_CTRL, 0x18);
 				}
 				else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
 				{
-					ResumeTxBeacon(Adapter);
-					rtw_write8(Adapter,REG_BCN_CTRL, 0x1a);
+					ResumeTxBeacon(adapter);
+					rtw_write8(adapter,REG_BCN_CTRL, 0x1a);
 				}
 				else if (mode == _HW_STATE_AP_)
 				{
-					ResumeTxBeacon(Adapter);
+					ResumeTxBeacon(adapter);
 
-					rtw_write8(Adapter, REG_BCN_CTRL, 0x12);
+					rtw_write8(adapter, REG_BCN_CTRL, 0x12);
 
 
 					/* Set RCR */
-					rtw_write32(Adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
+					rtw_write32(adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
 					/* enable to rx data frame */
-					rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
+					rtw_write16(adapter, REG_RXFLTMAP2, 0xFFFF);
 					/* enable to rx ps-poll */
-					rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
+					rtw_write16(adapter, REG_RXFLTMAP1, 0x0400);
 
 					/* Beacon Control related register for first time */
-					rtw_write8(Adapter, REG_BCNDMATIM, 0x02); /*  2ms */
-					rtw_write8(Adapter, REG_DRVERLYINT, 0x05);/*  5ms */
-					rtw_write8(Adapter, REG_ATIMWND, 0x0a); /*  10ms */
-					rtw_write16(Adapter, REG_BCNTCFG, 0x00);
-					rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0x6404);
+					rtw_write8(adapter, REG_BCNDMATIM, 0x02); /*  2ms */
+					rtw_write8(adapter, REG_DRVERLYINT, 0x05);/*  5ms */
+					rtw_write8(adapter, REG_ATIMWND, 0x0a); /*  10ms */
+					rtw_write16(adapter, REG_BCNTCFG, 0x00);
+					rtw_write16(adapter, REG_TBTT_PROHIBIT, 0x6404);
 
 					/* reset TSF */
-					rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));
+					rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(0));
 
 					/* enable TSF Function for if1 */
-					rtw_write8(Adapter, REG_BCN_CTRL, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
+					rtw_write8(adapter, REG_BCN_CTRL, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
 
 					/* enable update TSF for if1 */
-					rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
+					rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
 				}
 
-				val8 = rtw_read8(Adapter, MSR)&0x0c;
+				val8 = rtw_read8(adapter, MSR)&0x0c;
 				val8 |= mode;
-				rtw_write8(Adapter, MSR, val8);
+				rtw_write8(adapter, MSR, val8);
 			}
 #endif /* CONFIG_CONCURRENT_MODE */
 			break;
 		case HW_VAR_MAC_ADDR:
-			hw_var_set_macaddr(Adapter, variable, val);
+			hw_var_set_macaddr(adapter, variable, val);
 			break;
 		case HW_VAR_BSSID:
 #if defined(CONFIG_CONCURRENT_MODE)
-			hw_var_set_bssid(Adapter, variable, val);
+			hw_var_set_bssid(adapter, variable, val);
 #else /* CONFIG_CONCURRENT_MODE */
 			{
 				u8	idx = 0;
 				for (idx = 0 ; idx < 6; idx++)
 				{
-					rtw_write8(Adapter, (REG_BSSID+idx), val[idx]);
+					rtw_write8(adapter, (REG_BSSID+idx), val[idx]);
 				}
 			}
 #endif /* CONFIG_CONCURRENT_MODE */
 			{
 #ifdef CONFIG_DUALMAC_CONCURRENT
-				struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
+				struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
 #endif
-				if (check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE) == true)
+				if (check_fwstate(&adapter->mlmepriv, WIFI_AP_STATE) == true)
 				{
 					DBG_8192D("%s(): pHalData->bNeedIQK = true\n",__func__);
 					pHalData->bNeedIQK = true; /* for 92D IQK */
 				}
 #ifdef CONFIG_DUALMAC_CONCURRENT
-				if ((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
+				if ((Buddyadapter !=NULL) && (pHalData->bSlaveOfDMSP))
 				{
-					if (check_fwstate(&BuddyAdapter->mlmepriv, WIFI_AP_STATE) == true)
-						GET_HAL_DATA(BuddyAdapter)->bNeedIQK = true; /* for 92D IQK */
+					if (check_fwstate(&Buddyadapter->mlmepriv, WIFI_AP_STATE) == true)
+						GET_HAL_DATA(Buddyadapter)->bNeedIQK = true; /* for 92D IQK */
 				}
 #endif
 			}
@@ -4285,17 +4285,17 @@ _func_enter_;
 			{
 				u8	init_data_rate = *((u8 *)val);
 #ifdef CONFIG_CONCURRENT_MODE
-				if (SECONDARY_ADAPTER == Adapter->adapter_type) {
-					rtw_write8(Adapter, REG_INIDATA_RATE_SEL+2, init_data_rate);
+				if (SECONDARY_ADAPTER == adapter->adapter_type) {
+					rtw_write8(adapter, REG_INIDATA_RATE_SEL+2, init_data_rate);
 					pdmpriv->INIDATA_RATE[2] = init_data_rate;
-					DBG_8192D("HW_VAR_INIT_DATA_RATE: Set Init Data Rate(%#x) for MACID 2\n", rtw_read8(Adapter, REG_INIDATA_RATE_SEL));
+					DBG_8192D("HW_VAR_INIT_DATA_RATE: Set Init Data Rate(%#x) for MACID 2\n", rtw_read8(adapter, REG_INIDATA_RATE_SEL));
 				}
 				else
 #endif
 				{
-					rtw_write8(Adapter, REG_INIDATA_RATE_SEL, init_data_rate);
+					rtw_write8(adapter, REG_INIDATA_RATE_SEL, init_data_rate);
 					pdmpriv->INIDATA_RATE[0] = init_data_rate;
-					DBG_8192D("HW_VAR_INIT_DATA_RATE: Set Init Data Rate(%#x) for MACID 0\n", rtw_read8(Adapter, REG_INIDATA_RATE_SEL));
+					DBG_8192D("HW_VAR_INIT_DATA_RATE: Set Init Data Rate(%#x) for MACID 0\n", rtw_read8(adapter, REG_INIDATA_RATE_SEL));
 				}
 			}
 			break;
@@ -4303,13 +4303,13 @@ _func_enter_;
 			{
 				u16	BrateCfg = 0;
 				u8	RateIndex = 0, b2GBand = false;
-				struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+				struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 
 				/*  2007.01.16, by Emily */
 				/*  Select RRSR (in Legacy-OFDM and CCK) */
 				/*  For 8190, we select only 24M, 12M, 6M, 11M, 5.5M, 2M, and 1M from the Basic rate. */
 				/*  We do not use other rates. */
-				halsetbratecfg(Adapter, val, &BrateCfg);
+				halsetbratecfg(adapter, val, &BrateCfg);
 
 				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 					b2GBand = true;
@@ -4333,53 +4333,53 @@ _func_enter_;
 				DBG_8192D("HW_VAR_BASIC_RATE: BrateCfg(%#x)\n", BrateCfg);
 
 				/*  Set RRSR rate table. */
-				rtw_write8(Adapter, REG_RRSR, BrateCfg&0xff);
-				rtw_write8(Adapter, REG_RRSR+1, (BrateCfg>>8)&0xff);
-				rtw_write8(Adapter, REG_RRSR+2, rtw_read8(Adapter, REG_RRSR+2)&0xf0);
+				rtw_write8(adapter, REG_RRSR, BrateCfg&0xff);
+				rtw_write8(adapter, REG_RRSR+1, (BrateCfg>>8)&0xff);
+				rtw_write8(adapter, REG_RRSR+2, rtw_read8(adapter, REG_RRSR+2)&0xf0);
 
 				/*  Set RTS initial rate */
 				while (BrateCfg > 0x1) {
 					BrateCfg = (BrateCfg>> 1);
 					RateIndex++;
 				}
-				rtw_write8(Adapter, REG_INIRTS_RATE_SEL, RateIndex);
+				rtw_write8(adapter, REG_INIRTS_RATE_SEL, RateIndex);
 			}
 			break;
 		case HW_VAR_TXPAUSE:
-			rtw_write8(Adapter, REG_TXPAUSE, *((u8 *)val));
+			rtw_write8(adapter, REG_TXPAUSE, *((u8 *)val));
 			break;
 		case HW_VAR_BCN_FUNC:
-			hw_var_set_bcn_func(Adapter, variable, val);
+			hw_var_set_bcn_func(adapter, variable, val);
 			break;
 		case HW_VAR_CORRECT_TSF:
 #ifdef CONFIG_CONCURRENT_MODE
-			hw_var_set_correct_tsf(Adapter, variable, val);
+			hw_var_set_correct_tsf(adapter, variable, val);
 #else /* CONFIG_CONCURRENT_MODE */
 			{
 				u64	tsf;
-				struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+				struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 				struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 				tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; /* us */
 
 				if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 				{
-					StopTxBeacon(Adapter);
+					StopTxBeacon(adapter);
 				}
 
 				/* disable related TSF function */
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(3)));
 
-				rtw_write32(Adapter, REG_TSFTR, tsf);
-				rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
+				rtw_write32(adapter, REG_TSFTR, tsf);
+				rtw_write32(adapter, REG_TSFTR+4, tsf>>32);
 
 				/* enable related TSF function */
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(3));
 
 
 				if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 				{
-					ResumeTxBeacon(Adapter);
+					ResumeTxBeacon(adapter);
 				}
 			}
 #endif /* CONFIG_CONCURRENT_MODE */
@@ -4387,59 +4387,59 @@ _func_enter_;
 		case HW_VAR_CHECK_BSSID:
 			if (*((u8 *)val))
 			{
-				rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+				rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
 			}
 			else
 			{
 				u32	val32;
 
-				val32 = rtw_read32(Adapter, REG_RCR);
+				val32 = rtw_read32(adapter, REG_RCR);
 
 				val32 &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);
 
-				rtw_write32(Adapter, REG_RCR, val32);
+				rtw_write32(adapter, REG_RCR, val32);
 			}
 			break;
 		case HW_VAR_MLME_DISCONNECT:
 #ifdef CONFIG_CONCURRENT_MODE
-			hw_var_set_mlme_disconnect(Adapter, variable, val);
+			hw_var_set_mlme_disconnect(adapter, variable, val);
 #else /* CONFIG_CONCURRENT_MODE */
 			{
 				/* Set RCR to not to receive data frame when NO LINK state */
-				rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
+				rtw_write16(adapter, REG_RXFLTMAP2,0x00);
 
 				/* reset TSF */
-				rtw_write8(Adapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));
+				rtw_write8(adapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));
 
 				/* disable update TSF */
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
 			}
 #endif /* CONFIG_CONCURRENT_MODE */
 			break;
 		case HW_VAR_MLME_SITESURVEY:
-			hw_var_set_mlme_sitesurvey(Adapter, variable,  val);
+			hw_var_set_mlme_sitesurvey(adapter, variable,  val);
 #ifdef CONFIG_DUALMAC_CONCURRENT
-			dc_hw_var_mlme_sitesurvey(Adapter, *((u8 *)val));
+			dc_hw_var_mlme_sitesurvey(adapter, *((u8 *)val));
 #endif /* CONFIG_DUALMAC_CONCURRENT */
 			break;
 		case HW_VAR_MLME_JOIN:
 #ifdef CONFIG_CONCURRENT_MODE
-			hw_var_set_mlme_join(Adapter, variable,  val);
+			hw_var_set_mlme_join(adapter, variable,  val);
 #else /* CONFIG_CONCURRENT_MODE */
 			{
 				u8	RetryLimit = 0x30;
 				u8	type = *((u8 *)val);
-				struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
+				struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
 #ifdef CONFIG_DUALMAC_CONCURRENT
-				struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
+				struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
 #endif
 
 				if (type == 0) /*  prepare to join */
 				{
 					/* enable to rx data frame.Accept all data frame */
-					rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
+					rtw_write16(adapter, REG_RXFLTMAP2,0xFFFF);
 
-					rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+					rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
 
 					if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 					{
@@ -4453,9 +4453,9 @@ _func_enter_;
 					DBG_8192D("%s(): pHalData->bNeedIQK = true\n",__func__);
 					pHalData->bNeedIQK = true; /* for 92D IQK */
 #ifdef CONFIG_DUALMAC_CONCURRENT
-					if ((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
+					if ((Buddyadapter !=NULL) && (pHalData->bSlaveOfDMSP))
 					{
-						GET_HAL_DATA(BuddyAdapter)->bNeedIQK = true; /* for 92D IQK */
+						GET_HAL_DATA(Buddyadapter)->bNeedIQK = true; /* for 92D IQK */
 					}
 #endif
 				}
@@ -4463,12 +4463,12 @@ _func_enter_;
 				{
 					/* config RCR to receive different BSSID & not to receive data frame during linking */
 
-					rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
+					rtw_write16(adapter, REG_RXFLTMAP2,0x00);
 				}
 				else if (type == 2) /* sta add event call back */
 				{
 					/* enable update TSF */
-					rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
+					rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
 
 					if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
 					{
@@ -4477,34 +4477,34 @@ _func_enter_;
 					}
 				}
 
-				rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+				rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
 #ifdef CONFIG_DUALMAC_CONCURRENT
-				dc_hw_var_mlme_join(Adapter, *((u8 *)val));
+				dc_hw_var_mlme_join(adapter, *((u8 *)val));
 #endif /* CONFIG_DUALMAC_CONCURRENT */
 			}
 #endif /* CONFIG_CONCURRENT_MODE */
 			break;
 
 		case HW_VAR_ON_RCR_AM:
-			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_AM);
-			DBG_8192D("%s, %d, RCR= %x\n", __func__,__LINE__, rtw_read32(Adapter, REG_RCR));
+			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_AM);
+			DBG_8192D("%s, %d, RCR= %x\n", __func__,__LINE__, rtw_read32(adapter, REG_RCR));
 			break;
 		case HW_VAR_OFF_RCR_AM:
-			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)& (~RCR_AM));
-			DBG_8192D("%s, %d, RCR= %x\n", __func__,__LINE__, rtw_read32(Adapter, REG_RCR));
+			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)& (~RCR_AM));
+			DBG_8192D("%s, %d, RCR= %x\n", __func__,__LINE__, rtw_read32(adapter, REG_RCR));
 			break;
 
 		case HW_VAR_BEACON_INTERVAL:
-			rtw_write16(Adapter, REG_BCN_INTERVAL, *((u16 *)val));
+			rtw_write16(adapter, REG_BCN_INTERVAL, *((u16 *)val));
 			break;
 		case HW_VAR_SLOT_TIME:
 			{
 				u8	u1bAIFS, aSifsTime;
-				struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
+				struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 				struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 				DBG_8192D("Set HW_VAR_SLOT_TIME: SlotTime(%#x)\n", val[0]);
-				rtw_write8(Adapter, REG_SLOT, val[0]);
+				rtw_write8(adapter, REG_SLOT, val[0]);
 
 				if (pmlmeinfo->WMM_enable == 0)
 				{
@@ -4516,10 +4516,10 @@ _func_enter_;
 					u1bAIFS = aSifsTime + (2 * pmlmeinfo->slotTime);
 
 					/*  <Roger_EXP> Temporary removed, 2008.06.20. */
-					rtw_write8(Adapter, REG_EDCA_VO_PARAM, u1bAIFS);
-					rtw_write8(Adapter, REG_EDCA_VI_PARAM, u1bAIFS);
-					rtw_write8(Adapter, REG_EDCA_BE_PARAM, u1bAIFS);
-					rtw_write8(Adapter, REG_EDCA_BK_PARAM, u1bAIFS);
+					rtw_write8(adapter, REG_EDCA_VO_PARAM, u1bAIFS);
+					rtw_write8(adapter, REG_EDCA_VI_PARAM, u1bAIFS);
+					rtw_write8(adapter, REG_EDCA_BE_PARAM, u1bAIFS);
+					rtw_write8(adapter, REG_EDCA_BK_PARAM, u1bAIFS);
 				}
 			}
 			break;
@@ -4533,14 +4533,14 @@ _func_enter_;
 				if (bShortPreamble)
 					regTmp |= 0x80;
 
-				rtw_write8(Adapter, REG_RRSR+2, regTmp);
+				rtw_write8(adapter, REG_RRSR+2, regTmp);
 			}
 			break;
 		case HW_VAR_SEC_CFG:
 #ifdef CONFIG_CONCURRENT_MODE
-			rtw_write8(Adapter, REG_SECCFG, 0x0c |BIT(5));/* only enable tx enc and rx dec engine. */
+			rtw_write8(adapter, REG_SECCFG, 0x0c |BIT(5));/* only enable tx enc and rx dec engine. */
 #else /* CONFIG_CONCURRENT_MODE */
-			rtw_write8(Adapter, REG_SECCFG, *((u8 *)val));
+			rtw_write8(adapter, REG_SECCFG, *((u8 *)val));
 #endif /* CONFIG_CONCURRENT_MODE */
 			break;
 		case HW_VAR_DM_FLAG:
@@ -4588,41 +4588,41 @@ _func_enter_;
 					ulCommand= CAM_CONTENT_COUNT*ucIndex+i;
 					ulCommand= ulCommand | CAM_POLLINIG|CAM_WRITE;
 					/*  write content 0 is equall to mark invalid */
-					rtw_write32(Adapter, WCAMI, ulContent);  /* delay_ms(40); */
-					rtw_write32(Adapter, RWCAM, ulCommand);  /* delay_ms(40); */
+					rtw_write32(adapter, WCAMI, ulContent);  /* delay_ms(40); */
+					rtw_write32(adapter, RWCAM, ulCommand);  /* delay_ms(40); */
 				}
 			}
 			break;
 		case HW_VAR_CAM_INVALID_ALL:
-			rtw_write32(Adapter, RWCAM, BIT(31)|BIT(30));
+			rtw_write32(adapter, RWCAM, BIT(31)|BIT(30));
 			break;
 		case HW_VAR_CAM_WRITE:
 			{
 				u32	cmd;
 				u32	*cam_val = (u32 *)val;
-				rtw_write32(Adapter, WCAMI, cam_val[0]);
+				rtw_write32(adapter, WCAMI, cam_val[0]);
 
 				cmd = CAM_POLLINIG | CAM_WRITE | cam_val[1];
-				rtw_write32(Adapter, RWCAM, cmd);
+				rtw_write32(adapter, RWCAM, cmd);
 			}
 			break;
 		case HW_VAR_AC_PARAM_VO:
-			rtw_write32(Adapter, REG_EDCA_VO_PARAM, ((u32 *)(val))[0]);
+			rtw_write32(adapter, REG_EDCA_VO_PARAM, ((u32 *)(val))[0]);
 			break;
 		case HW_VAR_AC_PARAM_VI:
-			rtw_write32(Adapter, REG_EDCA_VI_PARAM, ((u32 *)(val))[0]);
+			rtw_write32(adapter, REG_EDCA_VI_PARAM, ((u32 *)(val))[0]);
 			break;
 		case HW_VAR_AC_PARAM_BE:
 			pHalData->AcParam_BE = ((u32 *)(val))[0];
-			rtw_write32(Adapter, REG_EDCA_BE_PARAM, ((u32 *)(val))[0]);
+			rtw_write32(adapter, REG_EDCA_BE_PARAM, ((u32 *)(val))[0]);
 			break;
 		case HW_VAR_AC_PARAM_BK:
-			rtw_write32(Adapter, REG_EDCA_BK_PARAM, ((u32 *)(val))[0]);
+			rtw_write32(adapter, REG_EDCA_BK_PARAM, ((u32 *)(val))[0]);
 			break;
 		case HW_VAR_ACM_CTRL:
 			{
 				u8	acm_ctrl = *((u8 *)val);
-				u8	AcmCtrl = rtw_read8(Adapter, REG_ACMHWCTRL);
+				u8	AcmCtrl = rtw_read8(adapter, REG_ACMHWCTRL);
 
 				if (acm_ctrl > 1)
 					AcmCtrl = AcmCtrl | 0x1;
@@ -4643,7 +4643,7 @@ _func_enter_;
 					AcmCtrl &= (~AcmHw_BeqEn);
 
 				DBG_8192D("[HW_VAR_ACM_CTRL] Write 0x%X\n", AcmCtrl);
-				rtw_write8(Adapter, REG_ACMHWCTRL, AcmCtrl);
+				rtw_write8(adapter, REG_ACMHWCTRL, AcmCtrl);
 			}
 			break;
 		case HW_VAR_AMPDU_MIN_SPACE:
@@ -4654,7 +4654,7 @@ _func_enter_;
 				MinSpacingToSet = *((u8 *)val);
 				if (MinSpacingToSet <= 7)
 				{
-					switch (Adapter->securitypriv.dot11PrivacyAlgrthm)
+					switch (adapter->securitypriv.dot11PrivacyAlgrthm)
 					{
 						case _NO_PRIVACY_:
 						case _AES_:
@@ -4676,7 +4676,7 @@ _func_enter_;
 						MinSpacingToSet = SecMinSpace;
 					}
 
-					rtw_write8(Adapter, REG_AMPDU_MIN_SPACE, (rtw_read8(Adapter, REG_AMPDU_MIN_SPACE) & 0xf8) | MinSpacingToSet);
+					rtw_write8(adapter, REG_AMPDU_MIN_SPACE, (rtw_read8(adapter, REG_AMPDU_MIN_SPACE) & 0xf8) | MinSpacingToSet);
 				}
 			}
 			break;
@@ -4716,7 +4716,7 @@ _func_enter_;
 							*pTmpByte = (*pTmpByte & 0xf0) | (FactorToSet);
 					}
 
-					rtw_write32(Adapter, REG_AGGLEN_LMT, RegToSet);
+					rtw_write32(adapter, REG_AGGLEN_LMT, RegToSet);
 				}
 			}
 			break;
@@ -4728,7 +4728,7 @@ _func_enter_;
 				{
 					threshold = pHalData->UsbRxAggPageCount;
 				}
-				rtw_write8(Adapter, REG_RXDMA_AGG_PG_TH, threshold);
+				rtw_write8(adapter, REG_RXDMA_AGG_PG_TH, threshold);
 			}
 			#endif
 			break;
@@ -4737,45 +4737,45 @@ _func_enter_;
 				u8	RpwmVal = (*(u8 *)val);
 				RpwmVal = RpwmVal & 0xf;
 
-				FillH2CCmd92D(Adapter, H2C_PWRM, 1, (u8 *)(&RpwmVal));
+				FillH2CCmd92D(adapter, H2C_PWRM, 1, (u8 *)(&RpwmVal));
 			}
 			break;
 		case HW_VAR_H2C_FW_PWRMODE:
-			rtl8192d_set_FwPwrMode_cmd(Adapter, (*(u8 *)val));
+			rtl8192d_set_FwPwrMode_cmd(adapter, (*(u8 *)val));
 			break;
 		case HW_VAR_H2C_FW_JOINBSSRPT:
-			rtl8192d_set_FwJoinBssReport_cmd(Adapter, (*(u8 *)val));
+			rtl8192d_set_FwJoinBssReport_cmd(adapter, (*(u8 *)val));
 			break;
 #ifdef CONFIG_P2P_PS
 		case HW_VAR_H2C_FW_P2P_PS_OFFLOAD:
 			{
 				u8	p2p_ps_state = (*(u8 *)val);
-				rtl8192d_set_p2p_ps_offload_cmd(Adapter, p2p_ps_state);
+				rtl8192d_set_p2p_ps_offload_cmd(adapter, p2p_ps_state);
 			}
 			break;
 #endif /*  CONFIG_P2P_PS */
 #ifdef CONFIG_TDLS
 		case HW_VAR_TDLS_WRCR:
-			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)&(~ BIT(6)));
+			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)&(~ BIT(6)));
 			break;
 		case HW_VAR_TDLS_INIT_CH_SEN:
 			{
-				rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)&(~ BIT(6))&(~ BIT(7)));
-				rtw_write16(Adapter, REG_RXFLTMAP2,0xffff);
+				rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)&(~ BIT(6))&(~ BIT(7)));
+				rtw_write16(adapter, REG_RXFLTMAP2,0xffff);
 
 				/* disable update TSF */
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
 			}
 			break;
 		case HW_VAR_TDLS_DONE_CH_SEN:
 			{
 				/* enable update TSF */
-				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~ BIT(4)));
-				rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|(BIT(7)));
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~ BIT(4)));
+				rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|(BIT(7)));
 			}
 			break;
 		case HW_VAR_TDLS_RS_RCR:
-			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|(BIT(6)));
+			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|(BIT(6)));
 			break;
 #endif /* CONFIG_TDLS */
 		case HW_VAR_INITIAL_GAIN:
@@ -4785,19 +4785,19 @@ _func_enter_;
 
 				if (rx_gain == 0xff) {/* restore rx gain */
 					dig_table->curigvalue = dig_table->backupigvalue;
-					PHY_SetBBReg(Adapter, rOFDM0_XAAGCCore1, 0x7f,dig_table->curigvalue);
-					PHY_SetBBReg(Adapter, rOFDM0_XBAGCCore1, 0x7f,dig_table->curigvalue);
+					PHY_SetBBReg(adapter, rOFDM0_XAAGCCore1, 0x7f,dig_table->curigvalue);
+					PHY_SetBBReg(adapter, rOFDM0_XBAGCCore1, 0x7f,dig_table->curigvalue);
 				}
 				else {
 					dig_table->backupigvalue = dig_table->curigvalue;
-					PHY_SetBBReg(Adapter, rOFDM0_XAAGCCore1, 0x7f,rx_gain);
-					PHY_SetBBReg(Adapter, rOFDM0_XBAGCCore1, 0x7f,rx_gain);
+					PHY_SetBBReg(adapter, rOFDM0_XAAGCCore1, 0x7f,rx_gain);
+					PHY_SetBBReg(adapter, rOFDM0_XBAGCCore1, 0x7f,rx_gain);
 					dig_table->curigvalue = (u8)rx_gain;
 				}
 			}
 			break;
 		case HW_VAR_TRIGGER_GPIO_0:
-			rtl8192du_trigger_gpio_0(Adapter);
+			rtl8192du_trigger_gpio_0(adapter);
 			break;
 		case HW_VAR_EFUSE_BYTES: /*  To set EFUE total used bytes, added by Roger, 2008.12.22. */
 			pHalData->EfuseUsedBytes = *((u16 *)val);
@@ -4807,29 +4807,29 @@ _func_enter_;
 				#define RW_RELEASE_EN		BIT18
 				#define RXDMA_IDLE			BIT17
 
-				struct pwrctrl_priv *pwrpriv = &Adapter->pwrctrlpriv;
+				struct pwrctrl_priv *pwrpriv = &adapter->pwrctrlpriv;
 				u8 trycnt = 100;
 
 				/* pause tx */
-				rtw_write8(Adapter,REG_TXPAUSE,0xff);
+				rtw_write8(adapter,REG_TXPAUSE,0xff);
 
 				/* keep sn */
-				Adapter->xmitpriv.nqos_ssn = rtw_read16(Adapter,REG_NQOS_SEQ);
+				adapter->xmitpriv.nqos_ssn = rtw_read16(adapter,REG_NQOS_SEQ);
 
 				if (pwrpriv->bkeepfwalive != true)
 				{
 					/* RX DMA stop */
-					rtw_write32(Adapter,REG_RXPKT_NUM,(rtw_read32(Adapter,REG_RXPKT_NUM)|RW_RELEASE_EN));
+					rtw_write32(adapter,REG_RXPKT_NUM,(rtw_read32(adapter,REG_RXPKT_NUM)|RW_RELEASE_EN));
 					do{
-						if (!(rtw_read32(Adapter,REG_RXPKT_NUM)&RXDMA_IDLE))
+						if (!(rtw_read32(adapter,REG_RXPKT_NUM)&RXDMA_IDLE))
 							break;
 					}while (trycnt--);
 					if (trycnt ==0)
 						DBG_8192D("Stop RX DMA failed......\n");
 
 					/* RQPN Load 0 */
-					rtw_write16(Adapter,REG_RQPN_NPQ,0x0);
-					rtw_write32(Adapter,REG_RQPN,0x80000000);
+					rtw_write16(adapter,REG_RQPN_NPQ,0x0);
+					rtw_write32(adapter,REG_RQPN,0x80000000);
 					rtw_mdelay_os(10);
 				}
 
@@ -4848,37 +4848,37 @@ _func_enter_;
 						/* Turn on the Pattern Match feature */
 						DBG_8192D("\n PATTERN_MATCH poidparam->subcode_value=%d\n",poidparam->subcode_value);
 						if (poidparam->subcode_value==1) {
-							Adapter->pwrctrlpriv.wowlan_pattern=true;
-							DBG_8192D("%s Adapter->pwrctrlpriv.wowlan_pattern=%x\n",__func__,Adapter->pwrctrlpriv.wowlan_pattern);
+							adapter->pwrctrlpriv.wowlan_pattern=true;
+							DBG_8192D("%s adapter->pwrctrlpriv.wowlan_pattern=%x\n",__func__,adapter->pwrctrlpriv.wowlan_pattern);
 						}
 						else {
-							Adapter->pwrctrlpriv.wowlan_pattern=false;
+							adapter->pwrctrlpriv.wowlan_pattern=false;
 						}
 						break;
 					case WOWLAN_MAGIC_PACKET:
 						/* Turn on the Magic Packet feature */
 						DBG_8192D("\n MAGIC_PACKET poidparam->subcode_value=%d\n",poidparam->subcode_value);
 						if (poidparam->subcode_value==1) {
-							Adapter->pwrctrlpriv.wowlan_magic=true;
-							DBG_8192D("%s Adapter->pwrctrlpriv.wowlan_magic=%x\n",__func__,Adapter->pwrctrlpriv.wowlan_magic);
+							adapter->pwrctrlpriv.wowlan_magic=true;
+							DBG_8192D("%s adapter->pwrctrlpriv.wowlan_magic=%x\n",__func__,adapter->pwrctrlpriv.wowlan_magic);
 						}
 						else {
-							Adapter->pwrctrlpriv.wowlan_magic=false;
+							adapter->pwrctrlpriv.wowlan_magic=false;
 						}
 						break;
 					case WOWLAN_UNICAST:
 						/* Turn on the Unicast wakeup feature */
 						if (poidparam->subcode_value==1) {
-							Adapter->pwrctrlpriv.wowlan_unicast=true;
+							adapter->pwrctrlpriv.wowlan_unicast=true;
 						}
 						else {
-							Adapter->pwrctrlpriv.wowlan_unicast=false;
-							DBG_8192D("%s Adapter->pwrctrlpriv.wowlan_unicast=%x\n",__func__,Adapter->pwrctrlpriv.wowlan_unicast);
+							adapter->pwrctrlpriv.wowlan_unicast=false;
+							DBG_8192D("%s adapter->pwrctrlpriv.wowlan_unicast=%x\n",__func__,adapter->pwrctrlpriv.wowlan_unicast);
 						}
 						break;
 					case WOWLAN_SET_PATTERN:
 						/* Setting the Pattern for wowlan */
-						res=rtw_wowlan_set_pattern(Adapter,poidparam->pattern);
+						res=rtw_wowlan_set_pattern(adapter,poidparam->pattern);
 						if (res)
 							DBG_8192D("rtw_wowlan_set_pattern retern value=0x%x",res);
 						break;
@@ -4887,22 +4887,22 @@ _func_enter_;
 
 						break;
 					case WOWLAN_ENABLE:
-						SetFwRelatedForWoWLAN8192DU(Adapter, true);
+						SetFwRelatedForWoWLAN8192DU(adapter, true);
 						/* Set Pattern */
-						if (Adapter->pwrctrlpriv.wowlan_pattern==true)
-							rtw_wowlan_reload_pattern(Adapter);
-						rtl8192d_set_wowlan_cmd(Adapter);
+						if (adapter->pwrctrlpriv.wowlan_pattern==true)
+							rtw_wowlan_reload_pattern(adapter);
+						rtl8192d_set_wowlan_cmd(adapter);
 						rtw_msleep_os(10);
 						break;
 
 					case WOWLAN_DISABLE:
-						Adapter->pwrctrlpriv.wowlan_mode=false;
-						rtl8192d_set_wowlan_cmd(Adapter);
+						adapter->pwrctrlpriv.wowlan_mode=false;
+						rtl8192d_set_wowlan_cmd(adapter);
 						rtw_msleep_os(10);
 						break;
 
 					case WOWLAN_STATUS:
-						poidparam->wakeup_reason = rtw_read8(Adapter, REG_WOWLAN_REASON);
+						poidparam->wakeup_reason = rtw_read8(adapter, REG_WOWLAN_REASON);
 						DBG_8192D("wake on wlan reason 0x%02x\n", poidparam->wakeup_reason);
 						break;
 
@@ -4913,18 +4913,18 @@ _func_enter_;
 							u16 GPIO_val;
 							if (poidparam->subcode_value==1)
 							{
-								GPIO_val = rtw_read16(Adapter, REG_GPIO_PIN_CTRL+1);
+								GPIO_val = rtw_read16(adapter, REG_GPIO_PIN_CTRL+1);
 								GPIO_val |= BIT(0)|BIT(8);
 								/* set GPIO 0 to high for Toshiba */
-								rtw_write16(Adapter, REG_GPIO_PIN_CTRL+1, GPIO_val);
+								rtw_write16(adapter, REG_GPIO_PIN_CTRL+1, GPIO_val);
 							}
 							else
 							{
-								GPIO_val = rtw_read16(Adapter, REG_GPIO_PIN_CTRL+1);
+								GPIO_val = rtw_read16(adapter, REG_GPIO_PIN_CTRL+1);
 								GPIO_val |= BIT(8);
 								GPIO_val &= ~BIT(0);
 								/* set GPIO 0 to low for Toshiba */
-								rtw_write16(Adapter, REG_GPIO_PIN_CTRL+1, GPIO_val);
+								rtw_write16(adapter, REG_GPIO_PIN_CTRL+1, GPIO_val);
 							}
 						}
 						break;
@@ -4937,25 +4937,25 @@ _func_enter_;
 							{
 
 								/* prevent 8051 to be reset by PERST# wake on wlan by Alex & Baron */
-								reg = rtw_read8(Adapter, REG_RSV_CTRL);
-								rtw_write8(Adapter, REG_RSV_CTRL, reg| BIT(5));
-								rtw_write8(Adapter, REG_RSV_CTRL, reg| BIT(6)|BIT(5));
+								reg = rtw_read8(adapter, REG_RSV_CTRL);
+								rtw_write8(adapter, REG_RSV_CTRL, reg| BIT(5));
+								rtw_write8(adapter, REG_RSV_CTRL, reg| BIT(6)|BIT(5));
 								/* for Toshiba only, they should call rtw_suspend before suspend */
-								rtw_suspend_toshiba(Adapter);
+								rtw_suspend_toshiba(adapter);
 							}
 							else
 							{
 								/* unmask usb se0 reset by Alex and DD */
-								reg = rtw_read8(Adapter, 0xf8);
+								reg = rtw_read8(adapter, 0xf8);
 								reg |= BIT(3)|BIT(4);
-								rtw_write8(Adapter, 0xf8, reg);
+								rtw_write8(adapter, 0xf8, reg);
 
 								/* for Toshiba only, they should call rtw_resume before resume */
-								rtw_resume_toshiba(Adapter);
+								rtw_resume_toshiba(adapter);
 								/* suggest by Scott */
-								reg = rtw_read8(Adapter, REG_RSV_CTRL);
+								reg = rtw_read8(adapter, REG_RSV_CTRL);
 								reg &= ~(BIT(5)|BIT(6));
-								rtw_write8(Adapter, REG_RSV_CTRL, reg);
+								rtw_write8(adapter, REG_RSV_CTRL, reg);
 
 							}
 #endif /* CONFIG_WOWLAN_MANUAL */
@@ -4964,10 +4964,10 @@ _func_enter_;
 					default:
 						break;
 				}
-				if (Adapter->pwrctrlpriv.wowlan_unicast||Adapter->pwrctrlpriv.wowlan_magic || Adapter->pwrctrlpriv.wowlan_pattern)
-					Adapter->pwrctrlpriv.wowlan_mode =true;
+				if (adapter->pwrctrlpriv.wowlan_unicast||adapter->pwrctrlpriv.wowlan_magic || adapter->pwrctrlpriv.wowlan_pattern)
+					adapter->pwrctrlpriv.wowlan_mode =true;
 				else
-					Adapter->pwrctrlpriv.wowlan_mode =false;
+					adapter->pwrctrlpriv.wowlan_mode =false;
 			}
 			break;
 #endif /* CONFIG_WOWLAN */
@@ -4977,11 +4977,11 @@ _func_enter_;
 				int i;
 				u8	RetryLimit = 0x01;
 
-				rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+				rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
 
 				for (i=0;i<1000;i++)
 				{
-					if (rtw_read32(Adapter, 0x200) != rtw_read32(Adapter, 0x204))
+					if (rtw_read32(adapter, 0x200) != rtw_read32(adapter, 0x204))
 					{
 						rtw_msleep_os(10);
 					}
@@ -4993,14 +4993,14 @@ _func_enter_;
 				}
 
 				RetryLimit = 0x30;
-				rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+				rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
 
 			}
 #endif
 			break;
 		case HW_VAR_BCN_VALID:
 			/* BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2, write 1 to clear, Clear by sw */
-			rtw_write8(Adapter, REG_TDECTRL+2, rtw_read8(Adapter, REG_TDECTRL+2) | BIT0);
+			rtw_write8(adapter, REG_TDECTRL+2, rtw_read8(adapter, REG_TDECTRL+2) | BIT0);
 			break;
 		default:
 			break;
@@ -5009,9 +5009,9 @@ _func_enter_;
 _func_exit_;
 }
 
-static void GetHwReg8192DU(struct rtw_adapter * Adapter, u8 variable, u8* val)
+static void GetHwReg8192DU(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 _func_enter_;
 
@@ -5021,11 +5021,11 @@ _func_enter_;
 			*((u16 *)(val)) = pHalData->BasicRateSet;
 			break;
 		case HW_VAR_TXPAUSE:
-			val[0] = rtw_read8(Adapter, REG_TXPAUSE);
+			val[0] = rtw_read8(adapter, REG_TXPAUSE);
 			break;
 		case HW_VAR_BCN_VALID:
 			/* BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2 */
-			val[0] = (BIT0 & rtw_read8(Adapter, REG_TDECTRL+2))?true:false;
+			val[0] = (BIT0 & rtw_read8(adapter, REG_TDECTRL+2))?true:false;
 			break;
 		case HW_VAR_DM_FLAG:
 			val[0] = pHalData->dmpriv.DMFlag;
@@ -5038,7 +5038,7 @@ _func_enter_;
 				/* When we halt NIC, we should check if FW LPS is leave. */
 				u32	valRCR;
 
-				if (Adapter->pwrctrlpriv.rf_pwrstate == rf_off)
+				if (adapter->pwrctrlpriv.rf_pwrstate == rf_off)
 				{
 					/*  If it is in HW/SW Radio OFF or IPS state, we do not check Fw LPS Leave, */
 					/*  because Fw is unload. */
@@ -5046,7 +5046,7 @@ _func_enter_;
 				}
 				else
 				{
-					valRCR = rtw_read32(Adapter, REG_RCR);
+					valRCR = rtw_read32(adapter, REG_RCR);
 					valRCR &= 0x00070000;
 					if (valRCR)
 						val[0] = false;
@@ -5075,9 +5075,9 @@ _func_exit_;
 /* 	Description: */
 /* 		Query setting of specified variable. */
 /*  */
-static u8 GetHalDefVar8192DUsb(struct rtw_adapter * Adapter, enum HAL_DEF_VARIABLE eVariable, void  *pValue)
+static u8 GetHalDefVar8192DUsb(struct rtw_adapter * adapter, enum HAL_DEF_VARIABLE eVariable, void  *pValue)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8 bResult = true;
 
 	switch (eVariable) {
@@ -5108,12 +5108,12 @@ static u8 GetHalDefVar8192DUsb(struct rt
 /* 		Change default setting of specified variable. */
 /*  */
 static u8 SetHalDefVar8192DUsb(
-	struct rtw_adapter *				Adapter,
+	struct rtw_adapter *				adapter,
 	enum HAL_DEF_VARIABLE		eVariable,
 	void *pValue
 	)
 {
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8 bResult = true;
 
 	switch (eVariable) {
@@ -5148,7 +5148,7 @@ static u8 SetHalDefVar8192DUsb(
 					{
 						struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 						struct DIG_T	*dig_table = &pdmpriv->DM_DigTable;
-						dig_table->preigvalue = rtw_read8(Adapter,0xc50);
+						dig_table->preigvalue = rtw_read8(adapter,0xc50);
 					}
 
 					pdmpriv->DMFlag |= (DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS|
@@ -5432,7 +5432,7 @@ _func_enter_;
 
 	pHalFunc->init_default_value = &rtl8192du_init_default_value;
 	pHalFunc->intf_chip_configure = &rtl8192du_interface_configure;
-	pHalFunc->read_adapter_info = &ReadAdapterInfo8192DU;
+	pHalFunc->read_adapter_info = &ReadadapterInfo8192DU;
 
 
 	pHalFunc->hal_dm_watchdog = &rtl8192d_HalDmWatchDog;
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -180,8 +180,8 @@ static void usb_read_reg_rf_byfw(struct
 {
 	u16	wPage = 0x0000, offset;
 	u32	BufferLengthRead;
-	struct rtw_adapter *	Adapter = pintfhdl->padapter;
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+	struct rtw_adapter *	adapter = pintfhdl->padapter;
+	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
 	u8	RFPath=0,nPHY=0;
 
 	RFPath =(u8) ((registerIndex&0xff0000)>>16);
--- a/drivers/staging/rtl8192du/include/Hal8192DPhyCfg.h
+++ b/drivers/staging/rtl8192du/include/Hal8192DPhyCfg.h
@@ -43,7 +43,7 @@
 /*--------------------------Define Parameters-------------------------------*/
 #define LOOP_LIMIT				5
 #define MAX_STALL_TIME			50		/* us */
-#define AntennaDiversityValue	0x80	/* Adapter->bSoftwareAntennaDiversity ? 0x00:0x80) */
+#define AntennaDiversityValue	0x80	/* adapter->bSoftwareAntennaDiversity ? 0x00:0x80) */
 #define MAX_TXPWR_IDX_NMODE_92S	63
 #define Reset_Cnt_Limit			3
 
@@ -247,22 +247,22 @@ u8 rtl8192d_getChnlGroupfromArray(u8 chn
 /*  */
 /*  BB and RF register read/write */
 /*  */
-void	rtl8192d_PHY_SetBBReg1Byte(	struct rtw_adapter *	Adapter,
+void	rtl8192d_PHY_SetBBReg1Byte(	struct rtw_adapter *	adapter,
 								u32		RegAddr,
 								u32		BitMask,
 								u32		Data	);
-u32	rtl8192d_PHY_QueryBBReg(	struct rtw_adapter *	Adapter,
+u32	rtl8192d_PHY_QueryBBReg(	struct rtw_adapter *	adapter,
 								u32		RegAddr,
 								u32		BitMask	);
-void	rtl8192d_PHY_SetBBReg(	struct rtw_adapter *	Adapter,
+void	rtl8192d_PHY_SetBBReg(	struct rtw_adapter *	adapter,
 								u32		RegAddr,
 								u32		BitMask,
 								u32		Data	);
-u32	rtl8192d_PHY_QueryRFReg(	struct rtw_adapter *			Adapter,
+u32	rtl8192d_PHY_QueryRFReg(	struct rtw_adapter *			adapter,
 								enum RF_RADIO_PATH_E	eRFPath,
 								u32				RegAddr,
 								u32				BitMask	);
-void	rtl8192d_PHY_SetRFReg(	struct rtw_adapter *			Adapter,
+void	rtl8192d_PHY_SetRFReg(	struct rtw_adapter *			adapter,
 								enum RF_RADIO_PATH_E	eRFPath,
 								u32				RegAddr,
 								u32				BitMask,
@@ -272,22 +272,22 @@ void	rtl8192d_PHY_SetRFReg(	struct rtw_a
 /*  Initialization related function */
 /*  */
 /* MAC/BB/RF HAL config */
-int	PHY_MACConfig8192D(	struct rtw_adapter *	Adapter	);
-int	PHY_BBConfig8192D(	struct rtw_adapter *	Adapter	);
-int	PHY_RFConfig8192D(	struct rtw_adapter *	Adapter	);
+int	PHY_MACConfig8192D(	struct rtw_adapter *	adapter	);
+int	PHY_BBConfig8192D(	struct rtw_adapter *	adapter	);
+int	PHY_RFConfig8192D(	struct rtw_adapter *	adapter	);
 /* RF config */
-int	rtl8192d_PHY_ConfigRFWithParaFile(	struct rtw_adapter *	Adapter,
+int	rtl8192d_PHY_ConfigRFWithParaFile(	struct rtw_adapter *	adapter,
 						u8 *pFileName,
 						enum RF_RADIO_PATH_E	eRFPath);
-int	rtl8192d_PHY_ConfigRFWithHeaderFile(	struct rtw_adapter *			Adapter,
+int	rtl8192d_PHY_ConfigRFWithHeaderFile(	struct rtw_adapter *			adapter,
 						enum RF_CONTENT			Content,
 						enum RF_RADIO_PATH_E	eRFPath);
 /* BB/RF readback check for making sure init OK */
-int	rtl8192d_PHY_CheckBBAndRFOK(	struct rtw_adapter *			Adapter,
+int	rtl8192d_PHY_CheckBBAndRFOK(	struct rtw_adapter *			adapter,
 				enum HW90_BLOCK		CheckBlock,
 				enum RF_RADIO_PATH_E	eRFPath	 );
 /* Read initi reg value for tx power setting. */
-void	rtl8192d_PHY_GetHWRegOriginalValue(	struct rtw_adapter *		Adapter	);
+void	rtl8192d_PHY_GetHWRegOriginalValue(	struct rtw_adapter *		adapter	);
 
 /*  */
 /*  RF Power setting */
@@ -296,22 +296,22 @@ void	rtl8192d_PHY_GetHWRegOriginalValue(
 /*  */
 /*  BB TX Power R/W */
 /*  */
-void	PHY_GetTxPowerLevel8192D(	struct rtw_adapter *		Adapter,
+void	PHY_GetTxPowerLevel8192D(	struct rtw_adapter *		adapter,
 											u32*		powerlevel	);
-void	PHY_SetTxPowerLevel8192D(	struct rtw_adapter *		Adapter,
+void	PHY_SetTxPowerLevel8192D(	struct rtw_adapter *		adapter,
 											u8			channel	);
-bool	PHY_UpdateTxPowerDbm8192D(	struct rtw_adapter *	Adapter,
+bool	PHY_UpdateTxPowerDbm8192D(	struct rtw_adapter *	adapter,
 											int		powerInDbm	);
 
 /*  */
 void
-PHY_ScanOperationBackup8192D(struct rtw_adapter *	Adapter,
+PHY_ScanOperationBackup8192D(struct rtw_adapter *	adapter,
 										u8		Operation	);
 
 /*  */
 /*  Switch bandwidth for 8192S */
 /*  */
-void	PHY_SetBWMode8192D(	struct rtw_adapter *			pAdapter,
+void	PHY_SetBWMode8192D(	struct rtw_adapter *			adapter,
 			enum HT_CHANNEL_WIDTH	ChnlWidth,
 									unsigned char	Offset	);
 
@@ -322,7 +322,7 @@ void	PHY_SetBWMode8192D(	struct rtw_adap
 /*  */
 /*  Set A2 entry to fw for 8192S */
 /*  */
-extern	void FillA2Entry8192C(		struct rtw_adapter *			Adapter,
+extern	void FillA2Entry8192C(		struct rtw_adapter *			adapter,
 										u8				index,
 										u8*				val);
 
@@ -330,121 +330,121 @@ extern	void FillA2Entry8192C(		struct rt
 /*  */
 /*  channel switch related funciton */
 /*  */
-void	PHY_SwChnl8192D(	struct rtw_adapter *		pAdapter,
+void	PHY_SwChnl8192D(	struct rtw_adapter *		adapter,
 									u8			channel	);
 				/*  Call after initialization */
-void	PHY_SwChnlPhy8192D(	struct rtw_adapter *		pAdapter,
+void	PHY_SwChnlPhy8192D(	struct rtw_adapter *		adapter,
 									u8			channel	);
 
-extern void ChkFwCmdIoDone(	struct rtw_adapter *	Adapter);
+extern void ChkFwCmdIoDone(	struct rtw_adapter *	adapter);
 
 /*  */
 /*  BB/MAC/RF other monitor API */
 /*  */
-void	PHY_SetMonitorMode8192D(struct rtw_adapter *	pAdapter,
+void	PHY_SetMonitorMode8192D(struct rtw_adapter *	adapter,
 										bool		bEnableMonitorMode	);
 
-bool	PHY_CheckIsLegalRfPath8192D(struct rtw_adapter *	pAdapter,
+bool	PHY_CheckIsLegalRfPath8192D(struct rtw_adapter *	adapter,
 											u32		eRFPath	);
 
 /*  */
 /*  IQ calibrate */
 /*  */
-void	rtl8192d_PHY_IQCalibrate(	struct rtw_adapter *	pAdapter);
+void	rtl8192d_PHY_IQCalibrate(	struct rtw_adapter *	adapter);
 
 
 /*  */
 /*  LC calibrate */
 /*  */
-void	rtl8192d_PHY_LCCalibrate(struct rtw_adapter *	pAdapter);
+void	rtl8192d_PHY_LCCalibrate(struct rtw_adapter *	adapter);
 
 /*  */
 /*  AP calibrate */
 /*  */
-void	rtl8192d_PHY_APCalibrate(struct rtw_adapter *	pAdapter, char		delta);
+void	rtl8192d_PHY_APCalibrate(struct rtw_adapter *	adapter, char		delta);
 
 
 /*  */
 /*  Modify the value of the hw register when beacon interval be changed. */
 /*  */
 void
-rtl8192d_PHY_SetBeaconHwReg(	struct rtw_adapter *		Adapter,
+rtl8192d_PHY_SetBeaconHwReg(	struct rtw_adapter *		adapter,
 					u16			BeaconInterval	);
 
 
 extern	void
 PHY_SwitchEphyParameter(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	);
 
 extern	void
 PHY_EnableHostClkReq(
-	struct rtw_adapter *			Adapter
+	struct rtw_adapter *			adapter
 	);
 
 bool
 SetAntennaConfig92C(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	u8		DefaultAnt
 	);
 
 void
 PHY_StopTRXBeforeChangeBand8192D(
-	  struct rtw_adapter *		Adapter
+	  struct rtw_adapter *		adapter
 );
 
 void
 PHY_UpdateBBRFConfiguration8192D(
-	struct rtw_adapter * Adapter,
+	struct rtw_adapter * adapter,
 	bool bisBandSwitch
 );
 
 void PHY_ReadMacPhyMode92D(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	bool	AutoloadFail
 );
 
 void PHY_ConfigMacPhyMode92D(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 );
 
 void PHY_ConfigMacPhyModeInfo92D(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 );
 
 void PHY_ConfigMacCoexist_RFPage92D(
-	struct rtw_adapter *	Adapter
+	struct rtw_adapter *	adapter
 );
 
 void
 rtl8192d_PHY_InitRxSetting(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 );
 
 void
 rtl8192d_PHY_ResetIQKResult(
-	struct rtw_adapter * Adapter
+	struct rtw_adapter * adapter
 );
 
 
 void
-rtl8192d_PHY_SetRFPathSwitch(struct rtw_adapter *	pAdapter, bool		bMain);
+rtl8192d_PHY_SetRFPathSwitch(struct rtw_adapter *	adapter, bool		bMain);
 
 void
 HalChangeCCKStatus8192D(
-	struct rtw_adapter *	Adapter,
+	struct rtw_adapter *	adapter,
 	bool		bCCKDisable
 );
 
-void PHY_InitPABias92D(struct rtw_adapter * Adapter);
+void PHY_InitPABias92D(struct rtw_adapter * adapter);
 
 /*--------------------------Exported Function prototype---------------------*/
 
-#define PHY_SetBBReg1Byte(Adapter, RegAddr, BitMask, Data) rtl8192d_PHY_SetBBReg1Byte((Adapter), (RegAddr), (BitMask), (Data))
-#define PHY_QueryBBReg(Adapter, RegAddr, BitMask) rtl8192d_PHY_QueryBBReg((Adapter), (RegAddr), (BitMask))
-#define PHY_SetBBReg(Adapter, RegAddr, BitMask, Data) rtl8192d_PHY_SetBBReg((Adapter), (RegAddr), (BitMask), (Data))
-#define PHY_QueryRFReg(Adapter, eRFPath, RegAddr, BitMask) rtl8192d_PHY_QueryRFReg((Adapter), (eRFPath), (RegAddr), (BitMask))
-#define PHY_SetRFReg(Adapter, eRFPath, RegAddr, BitMask, Data) rtl8192d_PHY_SetRFReg((Adapter), (eRFPath), (RegAddr), (BitMask), (Data))
+#define PHY_SetBBReg1Byte(adapter, RegAddr, BitMask, Data) rtl8192d_PHY_SetBBReg1Byte((adapter), (RegAddr), (BitMask), (Data))
+#define PHY_QueryBBReg(adapter, RegAddr, BitMask) rtl8192d_PHY_QueryBBReg((adapter), (RegAddr), (BitMask))
+#define PHY_SetBBReg(adapter, RegAddr, BitMask, Data) rtl8192d_PHY_SetBBReg((adapter), (RegAddr), (BitMask), (Data))
+#define PHY_QueryRFReg(adapter, eRFPath, RegAddr, BitMask) rtl8192d_PHY_QueryRFReg((adapter), (eRFPath), (RegAddr), (BitMask))
+#define PHY_SetRFReg(adapter, eRFPath, RegAddr, BitMask, Data) rtl8192d_PHY_SetRFReg((adapter), (eRFPath), (RegAddr), (BitMask), (Data))
 
 #define PHY_SetMacReg	PHY_SetBBReg
 
--- a/drivers/staging/rtl8192du/include/basic_types.h
+++ b/drivers/staging/rtl8192du/include/basic_types.h
@@ -30,7 +30,7 @@
 
 #define FIELD_OFFSET(s,field)	((__kernel_ssize_t)&((s*)(0))->field)
 
-#define MEM_ALIGNMENT_OFFSET	(sizeof (__kernel_size_t))
+#define MEM_ALIGNMENT_OFFSET	(sizeof(__kernel_size_t))
 #define MEM_ALIGNMENT_PADDING	(sizeof(__kernel_size_t) - 1)
 
 #define SIZE_PTR __kernel_size_t
@@ -65,12 +65,12 @@
 
 /* Write data to memory */
 #define WRITEEF1BYTE(_ptr, _val)	\
-	(*((u8 *)(_ptr))) = EF1BYTE(_val)
+	((*((u8 *)(_ptr))) = EF1BYTE(_val))
 /* Write le data to memory in host ordering */
 #define WRITEEF2BYTE(_ptr, _val)	\
-	(*((u16 *)(_ptr))) = EF2BYTE(_val)
+	((*((u16 *)(_ptr))) = EF2BYTE(_val))
 #define WRITEEF4BYTE(_ptr, _val)	\
-	(*((u32 *)(_ptr))) = EF2BYTE(_val)
+	((*((u32 *)(_ptr))) = EF4BYTE(_val))
 
 /* Create a bit mask
  * Examples:
--- a/drivers/staging/rtl8192du/include/h2clbk.h
+++ b/drivers/staging/rtl8192du/include/h2clbk.h
@@ -26,10 +26,10 @@
 #include <TypeDef.h>
 
 
-void _lbk_cmd(PADAPTER Adapter);
+void _lbk_cmd(PADAPTER adapter);
 
-void _lbk_rsp(PADAPTER Adapter);
+void _lbk_rsp(PADAPTER adapter);
 
-void _lbk_evt(PADAPTER Adapter);
+void _lbk_evt(PADAPTER adapter);
 
 void h2c_event_callback(unsigned char *dev, unsigned char *pbuf);
--- a/drivers/staging/rtl8192du/include/hal_com.h
+++ b/drivers/staging/rtl8192du/include/hal_com.h
@@ -130,7 +130,7 @@ hal_com_get_channel_plan(
 	bool		AutoLoadFail
 	);
 
-void	halsetbratecfg(struct rtw_adapter * Adapter, u8 *mBratesOS, u16 *pBrateCfg);
+void	halsetbratecfg(struct rtw_adapter * adapter, u8 *mBratesOS, u16 *pBrateCfg);
 
 u8	ratetohwrate(u8 rate);
 
--- a/drivers/staging/rtl8192du/include/hal_intf.h
+++ b/drivers/staging/rtl8192du/include/hal_intf.h
@@ -136,77 +136,77 @@ enum HAL_INTF_PS_FUNC {
 typedef s32 (*c2h_id_filter)(u8 id);
 
 struct hal_ops {
-	u32	(*hal_init)(struct rtw_adapter * Adapter);
-	u32	(*hal_deinit)(struct rtw_adapter * Adapter);
+	u32	(*hal_init)(struct rtw_adapter * adapter);
+	u32	(*hal_deinit)(struct rtw_adapter * adapter);
 
-	void	(*free_hal_data)(struct rtw_adapter * Adapter);
+	void	(*free_hal_data)(struct rtw_adapter * adapter);
 
-	u32	(*inirp_init)(struct rtw_adapter * Adapter);
-	u32	(*inirp_deinit)(struct rtw_adapter * Adapter);
+	u32	(*inirp_init)(struct rtw_adapter * adapter);
+	u32	(*inirp_deinit)(struct rtw_adapter * adapter);
 
-	s32	(*init_xmit_priv)(struct rtw_adapter * Adapter);
-	void	(*free_xmit_priv)(struct rtw_adapter * Adapter);
+	s32	(*init_xmit_priv)(struct rtw_adapter * adapter);
+	void	(*free_xmit_priv)(struct rtw_adapter * adapter);
 
-	s32	(*init_recv_priv)(struct rtw_adapter * Adapter);
-	void	(*free_recv_priv)(struct rtw_adapter * Adapter);
+	s32	(*init_recv_priv)(struct rtw_adapter * adapter);
+	void	(*free_recv_priv)(struct rtw_adapter * adapter);
 
-	void	(*InitSwLeds)(struct rtw_adapter * Adapter);
-	void	(*DeInitSwLeds)(struct rtw_adapter * Adapter);
+	void	(*InitSwLeds)(struct rtw_adapter * adapter);
+	void	(*DeInitSwLeds)(struct rtw_adapter * adapter);
 
-	void	(*dm_init)(struct rtw_adapter * Adapter);
-	void	(*dm_deinit)(struct rtw_adapter * Adapter);
-	void	(*read_chip_version)(struct rtw_adapter * Adapter);
+	void	(*dm_init)(struct rtw_adapter * adapter);
+	void	(*dm_deinit)(struct rtw_adapter * adapter);
+	void	(*read_chip_version)(struct rtw_adapter * adapter);
 
-	void	(*init_default_value)(struct rtw_adapter * Adapter);
+	void	(*init_default_value)(struct rtw_adapter * adapter);
 
-	void	(*intf_chip_configure)(struct rtw_adapter * Adapter);
+	void	(*intf_chip_configure)(struct rtw_adapter * adapter);
 
-	void	(*read_adapter_info)(struct rtw_adapter * Adapter);
+	void	(*read_adapter_info)(struct rtw_adapter * adapter);
 
-	void	(*enable_interrupt)(struct rtw_adapter * Adapter);
-	void	(*disable_interrupt)(struct rtw_adapter * Adapter);
-	s32	(*interrupt_handler)(struct rtw_adapter * Adapter);
+	void	(*enable_interrupt)(struct rtw_adapter * adapter);
+	void	(*disable_interrupt)(struct rtw_adapter * adapter);
+	s32	(*interrupt_handler)(struct rtw_adapter * adapter);
 
-	void	(*set_bwmode_handler)(struct rtw_adapter * Adapter, enum HT_CHANNEL_WIDTH Bandwidth, u8 Offset);
-	void	(*set_channel_handler)(struct rtw_adapter * Adapter, u8 channel);
+	void	(*set_bwmode_handler)(struct rtw_adapter * adapter, enum HT_CHANNEL_WIDTH Bandwidth, u8 Offset);
+	void	(*set_channel_handler)(struct rtw_adapter * adapter, u8 channel);
 
-	void	(*hal_dm_watchdog)(struct rtw_adapter * Adapter);
+	void	(*hal_dm_watchdog)(struct rtw_adapter * adapter);
 
-	void	(*SetHwRegHandler)(struct rtw_adapter * Adapter, u8	variable,u8* val);
-	void	(*GetHwRegHandler)(struct rtw_adapter * Adapter, u8	variable,u8* val);
+	void	(*SetHwRegHandler)(struct rtw_adapter * adapter, u8	variable,u8* val);
+	void	(*GetHwRegHandler)(struct rtw_adapter * adapter, u8	variable,u8* val);
 
-	u8	(*GetHalDefVarHandler)(struct rtw_adapter * Adapter, enum HAL_DEF_VARIABLE eVariable, void * pValue);
-	u8	(*SetHalDefVarHandler)(struct rtw_adapter * Adapter, enum HAL_DEF_VARIABLE eVariable, void * pValue);
+	u8	(*GetHalDefVarHandler)(struct rtw_adapter * adapter, enum HAL_DEF_VARIABLE eVariable, void * pValue);
+	u8	(*SetHalDefVarHandler)(struct rtw_adapter * adapter, enum HAL_DEF_VARIABLE eVariable, void * pValue);
 
-	void	(*UpdateRAMaskHandler)(struct rtw_adapter * Adapter, u32 mac_id);
-	void	(*SetBeaconRelatedRegistersHandler)(struct rtw_adapter * Adapter);
+	void	(*UpdateRAMaskHandler)(struct rtw_adapter * adapter, u32 mac_id);
+	void	(*SetBeaconRelatedRegistersHandler)(struct rtw_adapter * adapter);
 
-	void	(*Add_RateATid)(struct rtw_adapter * Adapter, u32 bitmap, u8 arg);
+	void	(*Add_RateATid)(struct rtw_adapter * adapter, u32 bitmap, u8 arg);
 
 #ifdef CONFIG_ANTENNA_DIVERSITY
-	u8	(*AntDivBeforeLinkHandler)(struct rtw_adapter * Adapter);
-	void	(*AntDivCompareHandler)(struct rtw_adapter * Adapter, struct wlan_bssid_ex *dst, struct wlan_bssid_ex *src);
+	u8	(*AntDivBeforeLinkHandler)(struct rtw_adapter * adapter);
+	void	(*AntDivCompareHandler)(struct rtw_adapter * adapter, struct wlan_bssid_ex *dst, struct wlan_bssid_ex *src);
 #endif
-	u8	(*interface_ps_func)(struct rtw_adapter * Adapter, enum HAL_INTF_PS_FUNC efunc_id, u8* val);
+	u8	(*interface_ps_func)(struct rtw_adapter * adapter, enum HAL_INTF_PS_FUNC efunc_id, u8* val);
 
-	s32	(*hal_xmit)(struct rtw_adapter * Adapter, struct xmit_frame *pxmitframe);
-	s32	(*mgnt_xmit)(struct rtw_adapter * Adapter, struct xmit_frame *pmgntframe);
+	s32	(*hal_xmit)(struct rtw_adapter * adapter, struct xmit_frame *pxmitframe);
+	s32	(*mgnt_xmit)(struct rtw_adapter * adapter, struct xmit_frame *pmgntframe);
 
-	u32	(*read_bbreg)(struct rtw_adapter * Adapter, u32 RegAddr, u32 BitMask);
-	void	(*write_bbreg)(struct rtw_adapter * Adapter, u32 RegAddr, u32 BitMask, u32 Data);
-	u32	(*read_rfreg)(struct rtw_adapter * Adapter, enum RF_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask);
-	void	(*write_rfreg)(struct rtw_adapter * Adapter, enum RF_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
+	u32	(*read_bbreg)(struct rtw_adapter * adapter, u32 RegAddr, u32 BitMask);
+	void	(*write_bbreg)(struct rtw_adapter * adapter, u32 RegAddr, u32 BitMask, u32 Data);
+	u32	(*read_rfreg)(struct rtw_adapter * adapter, enum RF_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask);
+	void	(*write_rfreg)(struct rtw_adapter * adapter, enum RF_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
 
 #ifdef CONFIG_HOSTAPD_MLME
-	s32	(*hostap_mgnt_xmit_entry)(struct rtw_adapter * Adapter, struct sk_buff *pkt);
+	s32	(*hostap_mgnt_xmit_entry)(struct rtw_adapter * adapter, struct sk_buff *pkt);
 #endif
-	void (*EfusePowerSwitch)(struct rtw_adapter * pAdapter, u8 bWrite, u8 PwrState);
-	void (*ReadEFuse)(struct rtw_adapter * Adapter, u8 efuseType, u16 _offset, u16 _size_byte, u8 *pbuf, bool bPseudoTest);
-	void (*EFUSEGetEfuseDefinition)(struct rtw_adapter * pAdapter, u8 efuseType, u8 type, void * *pOut, bool bPseudoTest);
-	u16	(*EfuseGetCurrentSize)(struct rtw_adapter * pAdapter, u8 efuseType, bool bPseudoTest);
-	int	(*Efuse_PgPacketRead)(struct rtw_adapter * pAdapter, u8 offset, u8 *data, bool bPseudoTest);
-	int	(*Efuse_PgPacketWrite)(struct rtw_adapter * pAdapter, u8 offset, u8 word_en, u8 *data, bool bPseudoTest);
-	u8	(*Efuse_WordEnableDataWrite)(struct rtw_adapter * pAdapter, u16 efuse_addr, u8 word_en, u8 *data, bool bPseudoTest);
+	void (*EfusePowerSwitch)(struct rtw_adapter * adapter, u8 bWrite, u8 PwrState);
+	void (*ReadEFuse)(struct rtw_adapter * adapter, u8 efuseType, u16 _offset, u16 _size_byte, u8 *pbuf, bool bPseudoTest);
+	void (*EFUSEGetEfuseDefinition)(struct rtw_adapter * adapter, u8 efuseType, u8 type, void * *pOut, bool bPseudoTest);
+	u16	(*EfuseGetCurrentSize)(struct rtw_adapter * adapter, u8 efuseType, bool bPseudoTest);
+	int	(*Efuse_PgPacketRead)(struct rtw_adapter * adapter, u8 offset, u8 *data, bool bPseudoTest);
+	int	(*Efuse_PgPacketWrite)(struct rtw_adapter * adapter, u8 offset, u8 word_en, u8 *data, bool bPseudoTest);
+	u8	(*Efuse_WordEnableDataWrite)(struct rtw_adapter * adapter, u16 efuse_addr, u8 word_en, u8 *data, bool bPseudoTest);
 
 #ifdef DBG_CONFIG_ERROR_DETECT
 	void (*sreset_init_value)(struct rtw_adapter *padapter);
@@ -265,13 +265,13 @@ enum HARDWARE_TYPE {
 /*  */
 /*  RTL8192D Series */
 /*  */
-#define IS_HARDWARE_TYPE_8192DE(_Adapter)			\
-		(((struct rtw_adapter *)_Adapter)->HardwareType==HARDWARE_TYPE_RTL8192DE)
-#define IS_HARDWARE_TYPE_8192DU(_Adapter)			\
-		(((struct rtw_adapter *)_Adapter)->HardwareType==HARDWARE_TYPE_RTL8192DU)
-#define	IS_HARDWARE_TYPE_8192D(_Adapter)			\
-		(IS_HARDWARE_TYPE_8192DE(_Adapter) ||		\
-		 IS_HARDWARE_TYPE_8192DU(_Adapter))
+#define IS_HARDWARE_TYPE_8192DE(_adapter)			\
+		(((struct rtw_adapter *)_adapter)->HardwareType==HARDWARE_TYPE_RTL8192DE)
+#define IS_HARDWARE_TYPE_8192DU(_adapter)			\
+		(((struct rtw_adapter *)_adapter)->HardwareType==HARDWARE_TYPE_RTL8192DU)
+#define	IS_HARDWARE_TYPE_8192D(_adapter)			\
+		(IS_HARDWARE_TYPE_8192DE(_adapter) ||		\
+		 IS_HARDWARE_TYPE_8192DU(_adapter))
 
 #define GET_EEPROM_EFUSE_PRIV(priv)	(&priv->eeprompriv)
 
--- a/drivers/staging/rtl8192du/include/rtl8192d_cmd.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_cmd.h
@@ -102,13 +102,13 @@ void	rtl8192d_set_FwPwrMode_cmd(struct r
 void	rtl8192d_set_FwJoinBssReport_cmd(struct rtw_adapter* padapter, u8 mstatus);
 u8	rtl8192d_set_rssi_cmd(struct rtw_adapter*padapter, u8 *param);
 u8	rtl8192d_set_raid_cmd(struct rtw_adapter*padapter, u32 mask, u8 arg);
-void	rtl8192d_Add_RateATid(struct rtw_adapter * pAdapter, u32 bitmap, u8 arg);
+void	rtl8192d_Add_RateATid(struct rtw_adapter * adapter, u32 bitmap, u8 arg);
 #ifdef CONFIG_P2P
 void	rtl8192d_set_p2p_ps_offload_cmd(struct rtw_adapter* padapter, u8 p2p_ps_state);
 #endif /* CONFIG_P2P */
 
 #ifdef CONFIG_TSF_RESET_OFFLOAD
-int reset_tsf(struct rtw_adapter * Adapter, u8 reset_port);
+int reset_tsf(struct rtw_adapter * adapter, u8 reset_port);
 #endif	/*  CONFIG_TSF_RESET_OFFLOAD */
 
 #ifdef CONFIG_WOWLAN
--- a/drivers/staging/rtl8192du/include/rtl8192d_dm.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_dm.h
@@ -378,11 +378,11 @@ struct	dm_priv
 /*  */
 /*  function prototype */
 /*  */
-void rtl8192d_init_dm_priv(struct rtw_adapter * Adapter);
-void rtl8192d_deinit_dm_priv(struct rtw_adapter * Adapter);
-void	rtl8192d_InitHalDm(struct rtw_adapter * Adapter);
-void	rtl8192d_HalDmWatchDog(struct rtw_adapter * Adapter);
+void rtl8192d_init_dm_priv(struct rtw_adapter * adapter);
+void rtl8192d_deinit_dm_priv(struct rtw_adapter * adapter);
+void	rtl8192d_InitHalDm(struct rtw_adapter * adapter);
+void	rtl8192d_HalDmWatchDog(struct rtw_adapter * adapter);
 
-void rtl8192d_dm_CheckTXPowerTracking(struct rtw_adapter * Adapter);
+void rtl8192d_dm_CheckTXPowerTracking(struct rtw_adapter * adapter);
 
 #endif	/* __HAL8190PCIDM_H__ */
--- a/drivers/staging/rtl8192du/include/rtl8192d_hal.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_hal.h
@@ -50,7 +50,7 @@
 #define TARGET_CHNL_NUM_2G_5G	59
 #define CV_CURVE_CNT			64
 
-extern atomic_t GlobalMutexForGlobalAdapterList;
+extern atomic_t GlobalMutexForGlobaladapterList;
 /* add mutex to solve the problem that reading efuse and power on/fw download do */
 /* on the same time */
 extern atomic_t GlobalMutexForMac0_2G_Mac1_5G;
@@ -721,18 +721,18 @@ struct hal_data_8192du {
 #endif /* CONFIG_P2P */
 };
 
-#define GET_HAL_DATA(__pAdapter)	((struct hal_data_8192du *)((__pAdapter)->HalData))
+#define GET_HAL_DATA(__adapter)	((struct hal_data_8192du *)((__adapter)->HalData))
 #define GET_RF_TYPE(priv)	(GET_HAL_DATA(priv)->rf_type)
 
-int FirmwareDownload92D(struct rtw_adapter * Adapter,bool  bUsedWoWLANFw);
-void rtl8192d_FirmwareSelfReset(struct rtw_adapter * Adapter);
-void rtl8192d_ReadChipVersion(struct rtw_adapter * Adapter);
-void rtl8192d_EfuseParseChnlPlan(struct rtw_adapter * Adapter, u8 *hwinfo, bool AutoLoadFail);
-void rtl8192d_ReadTxPowerInfo(struct rtw_adapter * Adapter, u8* PROMContent, bool AutoLoadFail);
-void rtl8192d_ResetDualMacSwitchVariables(struct rtw_adapter * Adapter);
-u8 GetEEPROMSize8192D(struct rtw_adapter * Adapter);
-bool PHY_CheckPowerOffFor8192D(struct rtw_adapter * Adapter);
-void PHY_SetPowerOnFor8192D(struct rtw_adapter * Adapter);
+int FirmwareDownload92D(struct rtw_adapter * adapter,bool  bUsedWoWLANFw);
+void rtl8192d_FirmwareSelfReset(struct rtw_adapter * adapter);
+void rtl8192d_ReadChipVersion(struct rtw_adapter * adapter);
+void rtl8192d_EfuseParseChnlPlan(struct rtw_adapter * adapter, u8 *hwinfo, bool AutoLoadFail);
+void rtl8192d_ReadTxPowerInfo(struct rtw_adapter * adapter, u8* PROMContent, bool AutoLoadFail);
+void rtl8192d_ResetDualMacSwitchVariables(struct rtw_adapter * adapter);
+u8 GetEEPROMSize8192D(struct rtw_adapter * adapter);
+bool PHY_CheckPowerOffFor8192D(struct rtw_adapter * adapter);
+void PHY_SetPowerOnFor8192D(struct rtw_adapter * adapter);
 void rtl8192d_free_hal_data(struct rtw_adapter *padapter);
 void rtl8192d_set_hal_ops(struct hal_ops *pHalFunc);
 
--- a/drivers/staging/rtl8192du/include/rtl8192d_rf.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_rf.h
@@ -71,23 +71,23 @@
 /*  */
 /*  RF RL6052 Series API */
 /*  */
-void		rtl8192d_RF_ChangeTxPath(	struct rtw_adapter *	Adapter,
+void		rtl8192d_RF_ChangeTxPath(	struct rtw_adapter *	adapter,
 										u16		DataRate);
 void		rtl8192d_PHY_RF6052SetBandwidth(
-										struct rtw_adapter *				Adapter,
+										struct rtw_adapter *				adapter,
 					enum HT_CHANNEL_WIDTH		Bandwidth);
 void	rtl8192d_PHY_RF6052SetCckTxPower(
-										struct rtw_adapter *	Adapter,
+										struct rtw_adapter *	adapter,
 										u8*		pPowerlevel);
 void	rtl8192d_PHY_RF6052SetOFDMTxPower(
-										struct rtw_adapter *	Adapter,
+										struct rtw_adapter *	adapter,
 										u8*		pPowerLevel,
 										u8		Channel);
-int	PHY_RF6052_Config8192D(	struct rtw_adapter *		Adapter	);
+int	PHY_RF6052_Config8192D(	struct rtw_adapter *		adapter	);
 
-bool	rtl8192d_PHY_EnableAnotherPHY(struct rtw_adapter * Adapter, bool	 bMac0);
+bool	rtl8192d_PHY_EnableAnotherPHY(struct rtw_adapter * adapter, bool	 bMac0);
 
-void	rtl8192d_PHY_PowerDownAnotherPHY(struct rtw_adapter * Adapter, bool bMac0);
+void	rtl8192d_PHY_PowerDownAnotherPHY(struct rtw_adapter * adapter, bool bMac0);
 
 
 /*--------------------------Exported Function prototype---------------------*/
--- a/drivers/staging/rtl8192du/include/rtw_efuse.h
+++ b/drivers/staging/rtl8192du/include/rtw_efuse.h
@@ -103,21 +103,21 @@ u8	rtw_efuse_access(struct rtw_adapter *
 u8	rtw_efuse_map_read(struct rtw_adapter * padapter, u16 addr, u16 cnts, u8 *data);
 u8	rtw_efuse_map_write(struct rtw_adapter * padapter, u16 addr, u16 cnts, u8 *data);
 
-u16	Efuse_GetCurrentSize(struct rtw_adapter * pAdapter, u8 efuseType, bool bPseudoTest);
+u16	Efuse_GetCurrentSize(struct rtw_adapter * adapter, u8 efuseType, bool bPseudoTest);
 u8	Efuse_CalculateWordCnts(u8 word_en);
-void	ReadEFuseByte(struct rtw_adapter * Adapter, u16 _offset, u8 *pbuf, bool bPseudoTest) ;
-void	EFUSE_GetEfuseDefinition(struct rtw_adapter * pAdapter, u8 efuseType, u8 type, void *pOut, bool bPseudoTest);
-u8	efuse_OneByteRead(struct rtw_adapter * pAdapter, u16 addr, u8 *data, bool	 bPseudoTest);
-u8	efuse_OneByteWrite(struct rtw_adapter * pAdapter, u16 addr, u8 data, bool	 bPseudoTest);
+void	ReadEFuseByte(struct rtw_adapter * adapter, u16 _offset, u8 *pbuf, bool bPseudoTest) ;
+void	EFUSE_GetEfuseDefinition(struct rtw_adapter * adapter, u8 efuseType, u8 type, void *pOut, bool bPseudoTest);
+u8	efuse_OneByteRead(struct rtw_adapter * adapter, u16 addr, u8 *data, bool	 bPseudoTest);
+u8	efuse_OneByteWrite(struct rtw_adapter * adapter, u16 addr, u8 data, bool	 bPseudoTest);
 
-void	Efuse_PowerSwitch(struct rtw_adapter * pAdapter,u8	bWrite,u8	 PwrState);
-int	Efuse_PgPacketRead(struct rtw_adapter * pAdapter, u8 offset, u8 *data, bool bPseudoTest);
-int	Efuse_PgPacketWrite(struct rtw_adapter * pAdapter, u8 offset, u8 word_en, u8 *data, bool bPseudoTest);
+void	Efuse_PowerSwitch(struct rtw_adapter * adapter,u8	bWrite,u8	 PwrState);
+int	Efuse_PgPacketRead(struct rtw_adapter * adapter, u8 offset, u8 *data, bool bPseudoTest);
+int	Efuse_PgPacketWrite(struct rtw_adapter * adapter, u8 offset, u8 word_en, u8 *data, bool bPseudoTest);
 void	efuse_WordEnableDataRead(u8 word_en, u8 *sourdata, u8 *targetdata);
-u8	Efuse_WordEnableDataWrite(struct rtw_adapter * pAdapter, u16 efuse_addr, u8 word_en, u8 *data, bool bPseudoTest);
+u8	Efuse_WordEnableDataWrite(struct rtw_adapter * adapter, u16 efuse_addr, u8 word_en, u8 *data, bool bPseudoTest);
 
-u8	EFUSE_Read1Byte(struct rtw_adapter * pAdapter, u16 Address);
-void	EFUSE_ShadowMapUpdate(struct rtw_adapter * pAdapter, u8 efuseType, bool bPseudoTest);
-void	EFUSE_ShadowRead(struct rtw_adapter * pAdapter, u8 Type, u16 Offset, u32 *Value);
+u8	EFUSE_Read1Byte(struct rtw_adapter * adapter, u16 Address);
+void	EFUSE_ShadowMapUpdate(struct rtw_adapter * adapter, u8 efuseType, bool bPseudoTest);
+void	EFUSE_ShadowRead(struct rtw_adapter * adapter, u8 Type, u16 Offset, u32 *Value);
 
 #endif
--- a/drivers/staging/rtl8192du/include/rtw_io.h
+++ b/drivers/staging/rtl8192du/include/rtw_io.h
@@ -436,7 +436,7 @@ extern void free_io_queue(struct rtw_ada
 extern void async_bus_io(struct io_queue *pio_q);
 extern void bus_sync_io(struct io_queue *pio_q);
 extern u32 _ioreq2rwmem(struct io_queue *pio_q);
-extern void dev_power_down(struct rtw_adapter * Adapter, u8 bpwrup);
+extern void dev_power_down(struct rtw_adapter * adapter, u8 bpwrup);
 
 /*
 #define RTL_R8(reg)		rtw_read8(padapter, reg)
--- a/drivers/staging/rtl8192du/include/rtw_ioctl.h
+++ b/drivers/staging/rtl8192du/include/rtw_ioctl.h
@@ -107,7 +107,7 @@ extern struct iw_handler_def  rtw_handle
 #endif
 
 extern	uint drv_query_info(
-		struct net_device *MiniportAdapterContext,
+		struct net_device *MiniportadapterContext,
 		uint		Oid,
 		void *InformationBuffer,
 		u32 InformationBufferLength,
@@ -116,7 +116,7 @@ extern	uint drv_query_info(
 	);
 
 extern	uint	drv_set_info(
-		struct net_device *MiniportAdapterContext,
+		struct net_device *MiniportadapterContext,
 		uint		Oid,
 		void *InformationBuffer,
 		u32	InformationBufferLength,
--- a/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
@@ -513,13 +513,13 @@ void write_cam(struct rtw_adapter *padap
 void clear_cam_entry(struct rtw_adapter *padapter, u8 entry);
 
 void invalidate_cam_all(struct rtw_adapter *padapter);
-void CAM_empty_entry(struct rtw_adapter *Adapter, u8 ucIndex);
+void CAM_empty_entry(struct rtw_adapter *adapter, u8 ucIndex);
 
 
 int allocate_fw_sta_entry(struct rtw_adapter *padapter);
 void flush_all_cam_entry(struct rtw_adapter *padapter);
 
-bool IsLegal5GChannel(struct rtw_adapter *Adapter, u8 channel);
+bool IsLegal5GChannel(struct rtw_adapter *adapter, u8 channel);
 
 void site_survey(struct rtw_adapter *padapter);
 u8 collect_bss_info(struct rtw_adapter *padapter, union recv_frame *precv_frame, struct wlan_bssid_ex *bssid);
@@ -552,7 +552,7 @@ void update_beacon_info(struct rtw_adapt
 void process_csa_ie(struct rtw_adapter *padapter, u8 *pframe, uint len);
 #endif /* CONFIG_DFS */
 void update_IOT_info(struct rtw_adapter *padapter);
-void update_capinfo(struct rtw_adapter *Adapter, u16 updateCap);
+void update_capinfo(struct rtw_adapter *adapter, u16 updateCap);
 void update_wireless_mode(struct rtw_adapter *padapter);
 void update_tx_basic_rate(struct rtw_adapter *padapter, u8 modulation);
 void update_bmc_sta_support_rate(struct rtw_adapter *padapter, u32 mac_id);
--- a/drivers/staging/rtl8192du/include/rtw_mp.h
+++ b/drivers/staging/rtl8192du/include/rtw_mp.h
@@ -389,8 +389,8 @@ enum OFDM_TX_MODE {
 
 extern s32 init_mp_priv(struct rtw_adapter * padapter);
 extern void free_mp_priv(struct mp_priv *pmp_priv);
-extern s32 MPT_InitializeAdapter(struct rtw_adapter * padapter, u8 Channel);
-extern void MPT_DeInitAdapter(struct rtw_adapter * padapter);
+extern s32 MPT_Initializeadapter(struct rtw_adapter * padapter, u8 Channel);
+extern void MPT_DeInitadapter(struct rtw_adapter * padapter);
 extern s32 mp_start_test(struct rtw_adapter * padapter);
 extern void mp_stop_test(struct rtw_adapter * padapter);
 
@@ -408,63 +408,63 @@ extern void write_bbreg(struct rtw_adapt
 extern u32 read_rfreg(struct rtw_adapter * padapter, u8 rfpath, u32 addr);
 extern void write_rfreg(struct rtw_adapter * padapter, u8 rfpath, u32 addr, u32 val);
 
-extern void	SetChannel(struct rtw_adapter * pAdapter);
-extern void	SetBandwidth(struct rtw_adapter * pAdapter);
-extern void	SetTxPower(struct rtw_adapter * pAdapter);
-extern void	SetAntennaPathPower(struct rtw_adapter * pAdapter);
-extern void	SetDataRate(struct rtw_adapter * pAdapter);
-
-extern void	SetAntenna(struct rtw_adapter * pAdapter);
-
-
-extern s32	SetThermalMeter(struct rtw_adapter * pAdapter, u8 target_ther);
-extern void	GetThermalMeter(struct rtw_adapter * pAdapter, u8 *value);
-
-extern void	SetContinuousTx(struct rtw_adapter * pAdapter, u8 bStart);
-extern void	SetSingleCarrierTx(struct rtw_adapter * pAdapter, u8 bStart);
-extern void	SetSingleToneTx(struct rtw_adapter * pAdapter, u8 bStart);
-extern void	SetCarrierSuppressionTx(struct rtw_adapter * pAdapter, u8 bStart);
+extern void	SetChannel(struct rtw_adapter * adapter);
+extern void	SetBandwidth(struct rtw_adapter * adapter);
+extern void	SetTxPower(struct rtw_adapter * adapter);
+extern void	SetAntennaPathPower(struct rtw_adapter * adapter);
+extern void	SetDataRate(struct rtw_adapter * adapter);
+
+extern void	SetAntenna(struct rtw_adapter * adapter);
+
+
+extern s32	SetThermalMeter(struct rtw_adapter * adapter, u8 target_ther);
+extern void	GetThermalMeter(struct rtw_adapter * adapter, u8 *value);
+
+extern void	SetContinuousTx(struct rtw_adapter * adapter, u8 bStart);
+extern void	SetSingleCarrierTx(struct rtw_adapter * adapter, u8 bStart);
+extern void	SetSingleToneTx(struct rtw_adapter * adapter, u8 bStart);
+extern void	SetCarrierSuppressionTx(struct rtw_adapter * adapter, u8 bStart);
 
 extern void	fill_txdesc_for_mp(struct rtw_adapter * padapter, struct tx_desc *ptxdesc);
 extern void	SetPacketTx(struct rtw_adapter * padapter);
-extern void	SetPacketRx(struct rtw_adapter * pAdapter, u8 bStartRx);
+extern void	SetPacketRx(struct rtw_adapter * adapter, u8 bStartRx);
 
-extern void	ResetPhyRxPktCount(struct rtw_adapter * pAdapter);
-extern u32	GetPhyRxPktReceived(struct rtw_adapter * pAdapter);
-extern u32	GetPhyRxPktCRC32Error(struct rtw_adapter * pAdapter);
+extern void	ResetPhyRxPktCount(struct rtw_adapter * adapter);
+extern u32	GetPhyRxPktReceived(struct rtw_adapter * adapter);
+extern u32	GetPhyRxPktCRC32Error(struct rtw_adapter * adapter);
 
 extern s32	SetPowerTracking(struct rtw_adapter * padapter, u8 enable);
 extern void	GetPowerTracking(struct rtw_adapter * padapter, u8 *enable);
 
-extern u32	mp_query_psd(struct rtw_adapter * pAdapter, u8 *data);
+extern u32	mp_query_psd(struct rtw_adapter * adapter, u8 *data);
 
 
-extern void Hal_SetAntenna(struct rtw_adapter * pAdapter);
-extern void Hal_SetBandwidth(struct rtw_adapter * pAdapter);
+extern void Hal_SetAntenna(struct rtw_adapter * adapter);
+extern void Hal_SetBandwidth(struct rtw_adapter * adapter);
 
-extern void Hal_SetTxPower(struct rtw_adapter * pAdapter);
-extern void Hal_SetCarrierSuppressionTx(struct rtw_adapter * pAdapter, u8 bStart);
-extern void Hal_SetSingleToneTx (struct rtw_adapter * pAdapter, u8 bStart);
-extern void Hal_SetSingleCarrierTx (struct rtw_adapter * pAdapter, u8 bStart);
-extern void Hal_SetContinuousTx (struct rtw_adapter * pAdapter, u8 bStart);
-extern void Hal_SetBandwidth(struct rtw_adapter * pAdapter);
-
-extern void Hal_SetDataRate(struct rtw_adapter * pAdapter);
-extern void Hal_SetChannel(struct rtw_adapter * pAdapter);
-extern void Hal_SetAntennaPathPower(struct rtw_adapter * pAdapter);
-extern s32 Hal_SetThermalMeter(struct rtw_adapter * pAdapter, u8 target_ther);
+extern void Hal_SetTxPower(struct rtw_adapter * adapter);
+extern void Hal_SetCarrierSuppressionTx(struct rtw_adapter * adapter, u8 bStart);
+extern void Hal_SetSingleToneTx (struct rtw_adapter * adapter, u8 bStart);
+extern void Hal_SetSingleCarrierTx (struct rtw_adapter * adapter, u8 bStart);
+extern void Hal_SetContinuousTx (struct rtw_adapter * adapter, u8 bStart);
+extern void Hal_SetBandwidth(struct rtw_adapter * adapter);
+
+extern void Hal_SetDataRate(struct rtw_adapter * adapter);
+extern void Hal_SetChannel(struct rtw_adapter * adapter);
+extern void Hal_SetAntennaPathPower(struct rtw_adapter * adapter);
+extern s32 Hal_SetThermalMeter(struct rtw_adapter * adapter, u8 target_ther);
 extern s32 Hal_SetPowerTracking(struct rtw_adapter * padapter, u8 enable);
 extern void Hal_GetPowerTracking(struct rtw_adapter * padapter, u8 *enable);
-extern void Hal_GetThermalMeter(struct rtw_adapter * pAdapter, u8 *value);
-extern void Hal_mpt_SwitchRfSetting(struct rtw_adapter * pAdapter);
-extern void Hal_MPT_CCKTxPowerAdjust(struct rtw_adapter * Adapter, bool bInCH14);
-extern void Hal_MPT_CCKTxPowerAdjustbyIndex(struct rtw_adapter * pAdapter, bool beven);
-extern void Hal_SetCCKTxPower(struct rtw_adapter * pAdapter, u8 *TxPower);
-extern void Hal_SetOFDMTxPower(struct rtw_adapter * pAdapter, u8 *TxPower);
-extern void Hal_TriggerRFThermalMeter(struct rtw_adapter * pAdapter);
-extern u8 Hal_ReadRFThermalMeter(struct rtw_adapter * pAdapter);
-extern void Hal_SetCCKContinuousTx(struct rtw_adapter * pAdapter, u8 bStart);
-extern void Hal_SetOFDMContinuousTx(struct rtw_adapter * pAdapter, u8 bStart);
-extern void Hal_ProSetCrystalCap (struct rtw_adapter * pAdapter, u32 CrystalCapVal);
+extern void Hal_GetThermalMeter(struct rtw_adapter * adapter, u8 *value);
+extern void Hal_mpt_SwitchRfSetting(struct rtw_adapter * adapter);
+extern void Hal_MPT_CCKTxPowerAdjust(struct rtw_adapter * adapter, bool bInCH14);
+extern void Hal_MPT_CCKTxPowerAdjustbyIndex(struct rtw_adapter * adapter, bool beven);
+extern void Hal_SetCCKTxPower(struct rtw_adapter * adapter, u8 *TxPower);
+extern void Hal_SetOFDMTxPower(struct rtw_adapter * adapter, u8 *TxPower);
+extern void Hal_TriggerRFThermalMeter(struct rtw_adapter * adapter);
+extern u8 Hal_ReadRFThermalMeter(struct rtw_adapter * adapter);
+extern void Hal_SetCCKContinuousTx(struct rtw_adapter * adapter, u8 bStart);
+extern void Hal_SetOFDMContinuousTx(struct rtw_adapter * adapter, u8 bStart);
+extern void Hal_ProSetCrystalCap (struct rtw_adapter * adapter, u32 CrystalCapVal);
 
 #endif /* _RTW_MP_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_pwrctrl.h
+++ b/drivers/staging/rtl8192du/include/rtw_pwrctrl.h
@@ -293,7 +293,7 @@ extern void cpwm_int_hdl(struct rtw_adap
 
 extern void rtw_set_ps_mode(struct rtw_adapter * padapter, u8 ps_mode, u8 smart_ps);
 extern void rtw_set_rpwm(struct rtw_adapter * padapter, u8 val8);
-extern void LeaveAllPowerSaveMode(struct rtw_adapter * Adapter);
+extern void LeaveAllPowerSaveMode(struct rtw_adapter * adapter);
 #ifdef CONFIG_IPS
 void ips_enter(struct rtw_adapter * padapter);
 int ips_leave(struct rtw_adapter * padapter);
@@ -305,7 +305,7 @@ void rtw_ps_processor(struct rtw_adapter
 int autoresume_enter(struct rtw_adapter* padapter);
 #endif
 #ifdef SUPPORT_HW_RFOFF_DETECTED
-rt_rf_power_state RfOnOffDetect(IN	struct rtw_adapter * pAdapter);
+rt_rf_power_state RfOnOffDetect(IN	struct rtw_adapter * adapter);
 #endif
 
 
--- a/drivers/staging/rtl8192du/include/usb_hal.h
+++ b/drivers/staging/rtl8192du/include/usb_hal.h
@@ -26,8 +26,8 @@ void rtl8192cu_set_hal_ops(struct rtw_ad
 void rtl8192du_set_hal_ops(struct rtw_adapter * padapter);
 #ifdef CONFIG_WOWLAN
 #ifdef CONFIG_WOWLAN_MANUAL
-extern int rtw_suspend_toshiba(struct rtw_adapter * Adapter);
-extern int rtw_resume_toshiba(struct rtw_adapter * Adapter);
+extern int rtw_suspend_toshiba(struct rtw_adapter * adapter);
+extern int rtw_resume_toshiba(struct rtw_adapter * adapter);
 #endif /*  CONFIG_WOWLAN_MANUAL */
 #endif /* CONFIG_WOWLAN */
 
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -11,10 +11,6 @@
  * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
  *
  ******************************************************************************/
 #define  _IOCTL_LINUX_C_
@@ -40,8 +36,7 @@
 #define  iwe_stream_add_point(a, b, c, d, e)  iwe_stream_add_point(b, c, d, e)
 #endif
 
-
-#define RTL_IOCTL_WPA_SUPPLICANT	SIOCIWFIRSTPRIV+30
+#define RTL_IOCTL_WPA_SUPPLICANT	(SIOCIWFIRSTPRIV+30)
 
 #define SCAN_ITEM_SIZE 768
 #define MAX_CUSTOM_LEN 64
@@ -60,7 +55,6 @@
 #define WEXT_CSCAN_HOME_DWELL_SECTION	'H'
 #define WEXT_CSCAN_TYPE_SECTION		'T'
 
-
 static u32 rtw_rates[] = {
 	1000000, 2000000, 5500000, 11000000,
 	6000000, 9000000, 12000000, 18000000,
@@ -68,7 +62,8 @@ static u32 rtw_rates[] = {
 };
 
 static const char * const iw_operation_mode[] = {
-	"Auto", "Ad-Hoc", "Managed",  "Master", "Repeater", "Secondary", "Monitor"
+	"Auto", "Ad-Hoc", "Managed",  "Master", "Repeater",
+	"Secondary", "Monitor"
 };
 
 static int hex2num_i(char c)
@@ -128,7 +123,8 @@ static void indicate_wx_custom_event(str
 	union iwreq_data wrqu;
 
 	if ((u32)strlen(msg) > IW_CUSTOM_MAX) {
-		DBG_8192D("%s strlen(msg):%u > IW_CUSTOM_MAX:%u\n", __func__ , (u32)strlen(msg), IW_CUSTOM_MAX);
+		DBG_8192D("%s strlen(msg):%u > IW_CUSTOM_MAX:%u\n", __func__ ,
+			  (u32)strlen(msg), IW_CUSTOM_MAX);
 		return;
 	}
 
@@ -148,7 +144,6 @@ static void indicate_wx_custom_event(str
 #endif
 }
 
-
 static void request_wps_pbc_event(struct rtw_adapter *padapter)
 {
 #ifndef CONFIG_IOCTL_CFG80211
@@ -169,7 +164,8 @@ static void request_wps_pbc_event(struct
 
 	wrqu.data.length = p-buff;
 
-	wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
+	wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ?
+			   wrqu.data.length : IW_CUSTOM_MAX;
 
 	DBG_8192D("%s\n", __func__);
 
@@ -179,7 +175,6 @@ static void request_wps_pbc_event(struct
 #endif
 }
 
-
 void indicate_wx_scan_complete_event(struct rtw_adapter *padapter)
 {
 #ifndef CONFIG_IOCTL_CFG80211
@@ -192,7 +187,6 @@ void indicate_wx_scan_complete_event(str
 #endif
 }
 
-
 void rtw_indicate_wx_assoc_event(struct rtw_adapter *padapter)
 {
 #ifndef CONFIG_IOCTL_CFG80211
@@ -203,7 +197,8 @@ void rtw_indicate_wx_assoc_event(struct
 
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
 
-	memcpy(wrqu.ap_addr.sa_data, pmlmepriv->cur_network.network.MacAddress, ETH_ALEN);
+	memcpy(wrqu.ap_addr.sa_data,
+	       pmlmepriv->cur_network.network.MacAddress, ETH_ALEN);
 
 	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
 #endif
@@ -223,41 +218,10 @@ void rtw_indicate_wx_disassoc_event(stru
 #endif
 }
 
-/*
-uint	rtw_is_cckrates_included(u8 *rate)
-{
-		u32	i = 0;
-
-		while (rate[i]!= 0)
-		{
-			if  ((((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
-			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22))
-			return true;
-			i++;
-		}
-
-		return false;
-}
-
-uint	rtw_is_cckratesonly_included(u8 *rate)
-{
-	u32 i = 0;
-
-	while (rate[i]!= 0)
-	{
-			if  ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
-				(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22))
-			return false;
-			i++;
-	}
-
-	return true;
-}
-*/
-
 static char *translate_scan(struct rtw_adapter *padapter,
-				struct iw_request_info* info, struct wlan_network *pnetwork,
-				char *start, char *stop)
+			    struct iw_request_info *info,
+			    struct wlan_network *pnetwork,
+			    char *start, char *stop)
 {
 	struct iw_event iwe;
 	__le16 cap;
@@ -290,16 +254,16 @@ static char *translate_scan(struct rtw_a
 		{
 			u32	blnGotP2PIE = false;
 
-			/* 	User is doing the P2P device discovery */
-			/* 	The prefix of SSID should be "DIRECT-" and the IE should contains the P2P IE. */
-			/* 	If not, the driver should ignore this AP and go to the next AP. */
+			/*	User is doing the P2P device discovery */
+			/*	The prefix of SSID should be "DIRECT-" and the IE should contains the P2P IE. */
+			/*	If not, the driver should ignore this AP and go to the next AP. */
 
-			/* 	Verifying the SSID */
+			/*	Verifying the SSID */
 			if (!memcmp(pnetwork->network.Ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN))
 			{
 				u32	p2pielen = 0;
 
-				/* 	Verifying the P2P IE */
+				/*	Verifying the P2P IE */
 				if (rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen))
 				{
 					blnGotP2PIE = true;
@@ -330,20 +294,20 @@ static char *translate_scan(struct rtw_a
 			{
 				if (pwdinfo->wfd_info->wfd_device_type == WFD_DEVINFO_PSINK)
 				{
-					/* 	the first two bits will indicate the WFD device type */
+					/*	the first two bits will indicate the WFD device type */
 					if ((wfd_devinfo[1] & 0x03) == WFD_DEVINFO_SOURCE)
 					{
-						/* 	If this device is Miracast PSink device, the scan reuslt should just provide the Miracast source. */
+						/*	If this device is Miracast PSink device, the scan reuslt should just provide the Miracast source. */
 						blnGotWFD = true;
 					}
 				}
 				else if (pwdinfo->wfd_info->wfd_device_type == WFD_DEVINFO_SOURCE)
 				{
-					/* 	the first two bits will indicate the WFD device type */
+					/*	the first two bits will indicate the WFD device type */
 					if ((wfd_devinfo[1] & 0x03) == WFD_DEVINFO_PSINK)
 					{
-						/* 	If this device is Miracast source device, the scan reuslt should just provide the Miracast PSink. */
-						/* 	Todo: How about the SSink?! */
+						/*	If this device is Miracast source device, the scan reuslt should just provide the Miracast PSink. */
+						/*	Todo: How about the SSink?! */
 						blnGotWFD = true;
 					}
 				}
@@ -374,43 +338,35 @@ static char *translate_scan(struct rtw_a
 	/* parsing HT_CAP_IE */
 		p = rtw_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-12);
 
-	if (p && ht_ielen>0)
+	if (p && ht_ielen > 0)
 	{
 		struct rtw_ieee80211_ht_cap *pht_capie;
 		ht_cap = true;
 		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
 		memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
-		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
-		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
+		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1 : 0;
+		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1 : 0;
 	}
 
 	/* Add the protocol name */
 	iwe.cmd = SIOCGIWNAME;
-	if ((rtw_is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == true)
-	{
+	if (rtw_is_cckratesonly_included((u8 *)&pnetwork->network.SupportedRates)) {
 		if (ht_cap == true)
 			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");
 		else
-		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
-	}
-	else if ((rtw_is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == true)
-	{
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
+	} else if (rtw_is_cckrates_included((u8 *)&pnetwork->network.SupportedRates)) {
 		if (ht_cap == true)
 			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");
 		else
-		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
-	}
-	else
-	{
-		if (pnetwork->network.Configuration.DSConfig > 14)
-		{
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
+	} else {
+		if (pnetwork->network.Configuration.DSConfig > 14) {
 			if (ht_cap == true)
 				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11an");
 			else
 				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11a");
-		}
-		else
-		{
+		} else {
 			if (ht_cap == true)
 				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");
 			else
@@ -420,11 +376,10 @@ static char *translate_scan(struct rtw_a
 
 	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
 
-	  /* Add mode */
-        iwe.cmd = SIOCGIWMODE;
+	/* Add mode */
+	iwe.cmd = SIOCGIWMODE;
 	memcpy((u8 *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
 
-
 	cpu_cap = le16_to_cpu(cap);
 
 	if (cpu_cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)) {
@@ -459,8 +414,7 @@ static char *translate_scan(struct rtw_a
 	max_rate = 0;
 	p = custom;
 	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
-	while (pnetwork->network.SupportedRates[i]!= 0)
-	{
+	while (pnetwork->network.SupportedRates[i] != 0) {
 		rate = pnetwork->network.SupportedRates[i]&0x7F;
 		if (rate > max_rate)
 			max_rate = rate;
@@ -469,19 +423,13 @@ static char *translate_scan(struct rtw_a
 		i++;
 	}
 
-	if (ht_cap == true)
-	{
-		if (mcs_rate&0x8000)/* MCS15 */
-		{
+	if (ht_cap == true) {
+		if (mcs_rate&0x8000) { /* MCS15 */
 			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
 
-		}
-		else if (mcs_rate&0x0080)/* MCS7 */
-		{
+		} else if (mcs_rate&0x0080) { /* MCS7 */
 			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
-		}
-		else/* default MCS7 */
-		{
+		} else { /* default MCS7 */
 			DBG_8192D("wx_get_scan, mcs_rate_bitmap = 0x%x\n", mcs_rate);
 			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
 		}
@@ -505,14 +453,12 @@ static char *translate_scan(struct rtw_a
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan: ssid =%s\n", pnetwork->network.Ssid.Ssid));
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan: wpa_len =%d rsn_len =%d\n", wpa_len, rsn_len));
 
-		if (wpa_len > 0)
-		{
+		if (wpa_len > 0) {
 			p = buf;
 			memset(buf, 0, MAX_WPA_IE_LEN);
 			p += sprintf(p, "wpa_ie =");
-			for (i = 0; i < wpa_len; i++) {
+			for (i = 0; i < wpa_len; i++)
 				p += sprintf(p, "%02x", wpa_ie[i]);
-			}
 
 			memset(&iwe, 0, sizeof(iwe));
 			iwe.cmd = IWEVCUSTOM;
@@ -524,14 +470,12 @@ static char *translate_scan(struct rtw_a
 			iwe.u.data.length = wpa_len;
 			start = iwe_stream_add_point(info, start, stop, &iwe, wpa_ie);
 		}
-		if (rsn_len > 0)
-		{
+		if (rsn_len > 0) {
 			p = buf;
 			memset(buf, 0, MAX_WPA_IE_LEN);
 			p += sprintf(p, "rsn_ie =");
-			for (i = 0; i < rsn_len; i++) {
+			for (i = 0; i < rsn_len; i++)
 				p += sprintf(p, "%02x", rsn_ie[i]);
-			}
 			memset(&iwe, 0, sizeof(iwe));
 			iwe.cmd = IWEVCUSTOM;
 			iwe.u.data.length = strlen(buf);
@@ -552,10 +496,8 @@ static char *translate_scan(struct rtw_a
 		u8 *ie_ptr = pnetwork->network.IEs +_FIXED_IE_LENGTH_;
 		total_ielen = pnetwork->network.IELength - _FIXED_IE_LENGTH_;
 
-		while (cnt < total_ielen)
-		{
-			if (rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2))
-			{
+		while (cnt < total_ielen) {
+			if (rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2)) {
 				wpsie_ptr = &ie_ptr[cnt];
 				iwe.cmd = IWEVGENIE;
 				iwe.u.data.length = (u16)wps_ielen;
@@ -565,7 +507,6 @@ static char *translate_scan(struct rtw_a
 		}
 	}
 
-
 {
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	u8 ss, sq;
@@ -579,7 +520,7 @@ static char *translate_scan(struct rtw_a
 	;
 
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true &&
-		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network)) {
+	    is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network)) {
 		ss = padapter->recvpriv.signal_strength;
 		sq = padapter->recvpriv.signal_qual;
 	} else {
@@ -587,7 +528,6 @@ static char *translate_scan(struct rtw_a
 		sq = pnetwork->network.PhyInfo.SignalQuality;
 	}
 
-
 	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
 	iwe.u.qual.level = (u8) translate_percentage_to_dbm(ss);/* dbm */
 	#else
@@ -626,13 +566,9 @@ static int wpa_set_auth_algs(struct net_
 			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEOPEN;
 			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
 		}
-	}
-	else if (value & AUTH_ALG_LEAP)
-	{
+	} else if (value & AUTH_ALG_LEAP) {
 		DBG_8192D("wpa_set_auth_algs, AUTH_ALG_LEAP\n");
-	}
-	else
-	{
+	} else {
 		DBG_8192D("wpa_set_auth_algs, error!\n");
 		ret = -EINVAL;
 	}
@@ -657,18 +593,16 @@ _func_enter_;
 	param->u.crypt.err = 0;
 	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
 
-	if (param_len < (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
-	{
+	if (param_len < (u32) ((u8 *) param->u.crypt.key - (u8 *) param) +
+	    param->u.crypt.key_len) {
 		ret =  -EINVAL;
 		goto exit;
 	}
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
-	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
-	{
-		if (param->u.crypt.idx >= WEP_KEYS)
-		{
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+		if (param->u.crypt.idx >= WEP_KEYS) {
 			ret = -EINVAL;
 			goto exit;
 		}
@@ -677,9 +611,9 @@ _func_enter_;
 		goto exit;
 	}
 
-	if (strcmp(param->u.crypt.alg, "WEP") == 0)
-	{
-		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("wpa_set_encryption, crypt.alg = WEP\n"));
+	if (strcmp(param->u.crypt.alg, "WEP") == 0) {
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,
+			 ("wpa_set_encryption, crypt.alg = WEP\n"));
 		DBG_8192D("wpa_set_encryption, crypt.alg = WEP\n");
 
 		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
@@ -689,16 +623,17 @@ _func_enter_;
 		wep_key_idx = param->u.crypt.idx;
 		wep_key_len = param->u.crypt.key_len;
 
-		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("(1)wep_key_idx =%d\n", wep_key_idx));
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+			 ("(1)wep_key_idx =%d\n", wep_key_idx));
 		DBG_8192D("(1)wep_key_idx =%d\n", wep_key_idx);
 
 		if (wep_key_idx > WEP_KEYS)
 			return -EINVAL;
 
-		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("(2)wep_key_idx =%d\n", wep_key_idx));
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+			 ("(2)wep_key_idx =%d\n", wep_key_idx));
 
-		if (wep_key_len > 0)
-		{
+		if (wep_key_len > 0) {
 			wep_key_len = wep_key_len <= 5 ? 5 : 13;
 			wep_total_len = wep_key_len + FIELD_OFFSET(struct ndis_802_11_wep, KeyMaterial);
 			pwep = (struct ndis_802_11_wep *) rtw_malloc(wep_total_len);
@@ -712,13 +647,11 @@ _func_enter_;
 			pwep->KeyLength = wep_key_len;
 			pwep->Length = wep_total_len;
 
-			if (wep_key_len == 13)
-			{
+			if (wep_key_len == 13) {
 				padapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;
 				padapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;
 			}
-		}
-		else {
+		} else {
 			ret = -EINVAL;
 			goto exit;
 		}
@@ -728,17 +661,12 @@ _func_enter_;
 
 		memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
 
-		if (param->u.crypt.set_tx)
-		{
+		if (param->u.crypt.set_tx) {
 			DBG_8192D("wep, set_tx = 1\n");
 
 			if (rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
-			{
 				ret = -EOPNOTSUPP ;
-			}
-		}
-		else
-		{
+		} else {
 			DBG_8192D("wep, set_tx = 0\n");
 
 			if (wep_key_idx >= WEP_KEYS) {
@@ -746,7 +674,7 @@ _func_enter_;
 				goto exit;
 			}
 
-		      memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+			memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
 			psecuritypriv->dot11DefKeylen[wep_key_idx]= pwep->KeyLength;
 			rtw_set_key(padapter, psecuritypriv, wep_key_idx, 0);
 		}
@@ -754,34 +682,25 @@ _func_enter_;
 		goto exit;
 	}
 
-	if (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) /*  802_1x */
-	{
+	if (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) { /*  802_1x */
 		struct sta_info * psta,*pbcmc_sta;
 		struct sta_priv * pstapriv = &padapter->stapriv;
 
-		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true) /* sta mode */
-		{
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE)) { /* sta mode */
 			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
-			if (psta == NULL) {
-			}
-			else
-			{
+			if (psta) {
 				/* Jeff: don't disable ieee8021x_blocked while clearing key */
 				if (strcmp(param->u.crypt.alg, "none") != 0)
 					psta->ieee8021x_blocked = false;
 
 				if ((padapter->securitypriv.ndisencryptstatus == NDIS802_11ENCRYPTION2ENABLED)||
-						(padapter->securitypriv.ndisencryptstatus ==  NDIS802_11ENCRYPTION3ENABLED))
-				{
+				    (padapter->securitypriv.ndisencryptstatus ==  NDIS802_11ENCRYPTION3ENABLED))
 					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
-				}
 
-				if (param->u.crypt.set_tx == 1)/* pairwise key */
-				{
+				if (param->u.crypt.set_tx == 1)/* pairwise key */ {
 					memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
-					if (strcmp(param->u.crypt.alg, "TKIP") == 0)/* set mic key */
-					{
+					if (strcmp(param->u.crypt.alg, "TKIP") == 0) { /* set mic key */
 						memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 						memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
@@ -791,13 +710,11 @@ _func_enter_;
 					DBG_8192D("\n ~~~~stastakey:unicastkey\n");
 
 					rtw_setstakey_cmd(padapter, (unsigned char *)psta, true);
-				}
-				else/* group key */
-				{
+				} else { /* group key */
 					memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 					memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[16]), 8);
 					memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[24]), 8);
-                                        padapter->securitypriv.binstallGrpkey = true;
+					padapter->securitypriv.binstallGrpkey = true;
 					DBG_8192D("\n ~~~~stastakey:groupkey\n");
 
 					padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
@@ -805,34 +722,23 @@ _func_enter_;
 					rtw_set_key(padapter,&padapter->securitypriv, param->u.crypt.idx, 1);
 #ifdef CONFIG_P2P
 					if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
-					{
 						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_DONE);
-					}
 #endif /* CONFIG_P2P */
 
 				}
 			}
 
 			pbcmc_sta = rtw_get_bcmc_stainfo(padapter);
-			if (pbcmc_sta == NULL)
-			{
-			}
-			else
-			{
+			if (pbcmc_sta) {
 				/* Jeff: don't disable ieee8021x_blocked while clearing key */
 				if (strcmp(param->u.crypt.alg, "none") != 0)
 					pbcmc_sta->ieee8021x_blocked = false;
 
 				if ((padapter->securitypriv.ndisencryptstatus == NDIS802_11ENCRYPTION2ENABLED)||
-						(padapter->securitypriv.ndisencryptstatus ==  NDIS802_11ENCRYPTION3ENABLED))
-				{
+				    (padapter->securitypriv.ndisencryptstatus ==  NDIS802_11ENCRYPTION3ENABLED))
 					pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
-				}
 			}
 		}
-		else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) /* adhoc mode */
-		{
-		}
 	}
 
 exit:
@@ -851,6 +757,7 @@ static int rtw_set_wpa_ie(struct rtw_ada
 	int group_cipher = 0, pairwise_cipher = 0;
 	int ret = 0;
 	u8	null_addr[]= {0, 0, 0, 0, 0, 0};
+	int i;
 #ifdef CONFIG_P2P
 	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
 #endif /* CONFIG_P2P */
@@ -863,8 +770,7 @@ static int rtw_set_wpa_ie(struct rtw_ada
 			return -EINVAL;
 	}
 
-	if (ielen)
-	{
+	if (ielen) {
 		buf = rtw_zmalloc(ielen);
 		if (buf == NULL) {
 			ret =  -ENOMEM;
@@ -874,88 +780,80 @@ static int rtw_set_wpa_ie(struct rtw_ada
 		memcpy(buf, pie , ielen);
 
 		/* dump */
-		{
-			int i;
-			DBG_8192D("\n wpa_ie(length:%d):\n", ielen);
-			for (i = 0;i<ielen;i = i+8)
-				DBG_8192D("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n", buf[i], buf[i+1], buf[i+2], buf[i+3], buf[i+4], buf[i+5], buf[i+6], buf[i+7]);
-		}
+		DBG_8192D("\n wpa_ie(length:%d):\n", ielen);
+		for (i = 0;i<ielen;i = i+8)
+			DBG_8192D("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n",
+				  buf[i], buf[i+1], buf[i+2], buf[i+3],
+				  buf[i+4], buf[i+5], buf[i+6], buf[i+7]);
 
 		if (ielen < RSN_HEADER_LEN) {
-			RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("Ie len too short %d\n", ielen));
+			RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,
+				 ("Ie len too short %d\n", ielen));
 			ret  = -1;
 			goto exit;
 		}
 
-		if (rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
-		{
+		if (rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS) {
 			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
 			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPAPSK;
 			memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);
 		}
 
-		if (rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
-		{
+		if (rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS) {
 			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
 			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPA2PSK;
 			memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);
 		}
 
 		if (group_cipher == 0)
-		{
 			group_cipher = WPA_CIPHER_NONE;
-		}
 		if (pairwise_cipher == 0)
-		{
 			pairwise_cipher = WPA_CIPHER_NONE;
-		}
 
-		switch (group_cipher)
-		{
-			case WPA_CIPHER_NONE:
-				padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
-				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
-				break;
-			case WPA_CIPHER_WEP40:
-				padapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;
-				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
-				break;
-			case WPA_CIPHER_TKIP:
-				padapter->securitypriv.dot118021XGrpPrivacy = _TKIP_;
-				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION2ENABLED;
-				break;
-			case WPA_CIPHER_CCMP:
-				padapter->securitypriv.dot118021XGrpPrivacy = _AES_;
-				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION3ENABLED;
-				break;
-			case WPA_CIPHER_WEP104:
-				padapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;
-				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
-				break;
+		switch (group_cipher) {
+		case WPA_CIPHER_NONE:
+			padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
+			break;
+		case WPA_CIPHER_WEP40:
+			padapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			break;
+		case WPA_CIPHER_TKIP:
+			padapter->securitypriv.dot118021XGrpPrivacy = _TKIP_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION2ENABLED;
+			break;
+		case WPA_CIPHER_CCMP:
+			padapter->securitypriv.dot118021XGrpPrivacy = _AES_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION3ENABLED;
+			break;
+		case WPA_CIPHER_WEP104:
+			padapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			break;
 		}
 
-		switch (pairwise_cipher)
-		{
-			case WPA_CIPHER_NONE:
-				padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
-				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
-				break;
-			case WPA_CIPHER_WEP40:
-				padapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;
-				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
-				break;
-			case WPA_CIPHER_TKIP:
-				padapter->securitypriv.dot11PrivacyAlgrthm = _TKIP_;
-				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION2ENABLED;
-				break;
-			case WPA_CIPHER_CCMP:
-				padapter->securitypriv.dot11PrivacyAlgrthm = _AES_;
-				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION3ENABLED;
-				break;
-			case WPA_CIPHER_WEP104:
-				padapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;
-				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
-				break;
+		switch (pairwise_cipher) {
+		case WPA_CIPHER_NONE:
+			padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
+			break;
+		case WPA_CIPHER_WEP40:
+			padapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			break;
+		case WPA_CIPHER_TKIP:
+			padapter->securitypriv.dot11PrivacyAlgrthm = _TKIP_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION2ENABLED;
+			break;
+		case WPA_CIPHER_CCMP:
+			padapter->securitypriv.dot11PrivacyAlgrthm = _AES_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION3ENABLED;
+			break;
+		case WPA_CIPHER_WEP104:
+			padapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			break;
 		}
 
 		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
@@ -989,9 +887,9 @@ static int rtw_set_wpa_ie(struct rtw_ada
 	}
 
 	/* TKIP and AES disallow multicast packets until installing group key */
-	if (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_
-		|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_
-		|| padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
+	if (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_ ||
+	    padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_ ||
+	    padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
 		/* WPS open need to enable multicast */
 		rtw_hal_set_hwreg(padapter, HW_VAR_OFF_RCR_AM, null_addr);
 
@@ -1007,8 +905,8 @@ exit:
 }
 
 static int rtw_wx_get_name(struct net_device *dev,
-			     struct iw_request_info *info,
-			     union iwreq_data *wrqu, char *extra)
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	u16 cap;
@@ -1023,51 +921,38 @@ static int rtw_wx_get_name(struct net_de
 
 	_func_enter_;
 
-	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true)
-	{
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {
 		/* parsing HT_CAP_IE */
 		p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
-		if (p && ht_ielen>0)
-		{
+		if (p && ht_ielen > 0)
 			ht_cap = true;
-		}
 
 		memcpy(prates, pcur_bss->SupportedRates, NDIS_802_11_LENGTH_RATES_EX);
 
-		if (rtw_is_cckratesonly_included((u8*)prates) == true)
-		{
-			if (ht_cap == true)
+		if (rtw_is_cckratesonly_included((u8 *)prates)) {
+			if (ht_cap)
 				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bn");
 			else
 				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11b");
-		}
-		else if ((rtw_is_cckrates_included((u8*)prates)) == true)
-		{
-			if (ht_cap == true)
+		} else if ((rtw_is_cckrates_included((u8 *)prates))) {
+			if (ht_cap)
 				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bgn");
 			else
 				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bg");
-		}
-		else
-		{
-			if (pcur_bss->Configuration.DSConfig > 14)
-			{
-				if (ht_cap == true)
+		} else {
+			if (pcur_bss->Configuration.DSConfig > 14) {
+				if (ht_cap)
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11an");
 				else
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11a");
-			}
-			else
-			{
-				if (ht_cap == true)
+			} else {
+				if (ht_cap)
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11gn");
 				else
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
 			}
 		}
-	}
-	else
-	{
+	} else {
 		snprintf(wrqu->name, IFNAMSIZ, "unassociated");
 	}
 
@@ -1077,8 +962,8 @@ static int rtw_wx_get_name(struct net_de
 }
 
 static int rtw_wx_set_freq(struct net_device *dev,
-			     struct iw_request_info *info,
-			     union iwreq_data *wrqu, char *extra)
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
 {
 	_func_enter_;
 
@@ -1090,21 +975,18 @@ static int rtw_wx_set_freq(struct net_de
 }
 
 static int rtw_wx_get_freq(struct net_device *dev,
-			     struct iw_request_info *info,
-			     union iwreq_data *wrqu, char *extra)
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct	mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
 
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-	{
+	if (check_fwstate(pmlmepriv, _FW_LINKED)) {
 		wrqu->freq.m = rtw_ch2freq(pcur_bss->Configuration.DSConfig) * 100000;
 		wrqu->freq.e = 1;
 		wrqu->freq.i = pcur_bss->Configuration.DSConfig;
-
-	}
-	else {
+	} else {
 		wrqu->freq.m = rtw_ch2freq(padapter->mlmeextpriv.cur_channel) * 100000;
 		wrqu->freq.e = 1;
 		wrqu->freq.i = padapter->mlmeextpriv.cur_channel;
@@ -1114,7 +996,7 @@ static int rtw_wx_get_freq(struct net_de
 }
 
 static int rtw_wx_set_mode(struct net_device *dev, struct iw_request_info *a,
-			     union iwreq_data *wrqu, char *b)
+			   union iwreq_data *wrqu, char *b)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	enum NDIS_802_11_NETWORK_INFRASTRUCTURE networkType ;
@@ -1133,41 +1015,31 @@ static int rtw_wx_set_mode(struct net_de
 		goto exit;
 	}
 
-	switch (wrqu->mode)
-	{
-		case IW_MODE_AUTO:
-			networkType = NDIS802_11AUTOUNK;
-			DBG_8192D("set_mode = IW_MODE_AUTO\n");
-			break;
-		case IW_MODE_ADHOC:
-			networkType = NDIS802_11IBSS;
-			DBG_8192D("set_mode = IW_MODE_ADHOC\n");
-			break;
-		case IW_MODE_MASTER:
-			networkType = NDIS802_11APMODE;
-			DBG_8192D("set_mode = IW_MODE_MASTER\n");
-			break;
-		case IW_MODE_INFRA:
-			networkType = NDIS802_11INFRA;
-			DBG_8192D("set_mode = IW_MODE_INFRA\n");
-			break;
-
-		default :
-			ret = -EINVAL;;
-			RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("\n Mode: %s is not supported\n", iw_operation_mode[wrqu->mode]));
-			goto exit;
+	switch (wrqu->mode) {
+	case IW_MODE_AUTO:
+		networkType = NDIS802_11AUTOUNK;
+		DBG_8192D("set_mode = IW_MODE_AUTO\n");
+		break;
+	case IW_MODE_ADHOC:
+		networkType = NDIS802_11IBSS;
+		DBG_8192D("set_mode = IW_MODE_ADHOC\n");
+		break;
+	case IW_MODE_MASTER:
+		networkType = NDIS802_11APMODE;
+		DBG_8192D("set_mode = IW_MODE_MASTER\n");
+		break;
+	case IW_MODE_INFRA:
+		networkType = NDIS802_11INFRA;
+		DBG_8192D("set_mode = IW_MODE_INFRA\n");
+		break;
+	default :
+		ret = -EINVAL;;
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,
+			 ("\n Mode: %s is not supported\n",
+			 iw_operation_mode[wrqu->mode]));
+		goto exit;
 	}
 
-/*
-	if (NDIS802_11APMODE == networkType)
-	{
-		rtw_setopmode_cmd(padapter, networkType);
-	}
-	else
-	{
-		rtw_setopmode_cmd(padapter, NDIS802_11AUTOUNK);
-	}
-*/
 	spin_lock_bh(&pmlmepriv->lock);
 	spin_lock_bh(&queue->lock);
 	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) == false) {
@@ -1190,7 +1062,7 @@ exit:
 }
 
 static int rtw_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
-			     union iwreq_data *wrqu, char *b)
+			   union iwreq_data *wrqu, char *b)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
@@ -1200,61 +1072,50 @@ static int rtw_wx_get_mode(struct net_de
 	_func_enter_;
 
 	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
-	{
 		wrqu->mode = IW_MODE_INFRA;
-	}
-	else if  ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
-		       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
-
-	{
+	else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+		 (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
 		wrqu->mode = IW_MODE_ADHOC;
-	}
 	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
-	{
 		wrqu->mode = IW_MODE_MASTER;
-	}
 	else
-	{
 		wrqu->mode = IW_MODE_AUTO;
-	}
 
 	_func_exit_;
 
 	return 0;
 }
 
-
 static int rtw_wx_set_pmkid(struct net_device *dev,
-	                     struct iw_request_info *a,
-			     union iwreq_data *wrqu, char *extra)
+	                    struct iw_request_info *a,
+			    union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	u8          j, blInserted = false;
-	int         intReturn = false;
 	struct mlme_priv  *pmlmepriv = &padapter->mlmepriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
-        struct iw_pmksa*  pPMK = (struct iw_pmksa*) extra;
-        u8     strZeroMacAddress[ETH_ALEN] = { 0x00 };
-        u8     strIssueBssid[ETH_ALEN] = { 0x00 };
+	struct iw_pmksa*  pPMK = (struct iw_pmksa*) extra;
+	u8          j, blInserted = false;
+	int         intReturn = false;
+	u8     strZeroMacAddress[ETH_ALEN] = { 0x00 };
+	u8     strIssueBssid[ETH_ALEN] = { 0x00 };
 
 	memcpy(strIssueBssid, pPMK->bssid.sa_data, ETH_ALEN);
-        if (pPMK->cmd == IW_PMKSA_ADD)
-        {
-                DBG_8192D("[rtw_wx_set_pmkid] IW_PMKSA_ADD!\n");
-                if (!memcmp(strIssueBssid, strZeroMacAddress, ETH_ALEN))
-                    return(intReturn);
-                else
-                    intReturn = true;
+	if (pPMK->cmd == IW_PMKSA_ADD) {
+		DBG_8192D("[rtw_wx_set_pmkid] IW_PMKSA_ADD!\n");
+		if (!memcmp(strIssueBssid, strZeroMacAddress, ETH_ALEN))
+			return(intReturn);
+		else
+			intReturn = true;
 		blInserted = false;
 
 		/* overwrite PMKID */
 		for (j = 0; j < NUM_PMKID_CACHE; j++) {
 			if (!memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN)) {
 				/*  BSSID is matched, the same AP => rewrite with new PMKID. */
-                                DBG_8192D("[rtw_wx_set_pmkid] BSSID exists in the PMKList.\n");
+				DBG_8192D("[rtw_wx_set_pmkid] BSSID exists in the PMKList.\n");
 
 				memcpy(psecuritypriv->PMKIDList[j].PMKID, pPMK->pmkid, IW_PMKID_LEN);
-                                psecuritypriv->PMKIDList[j].bUsed = true;
+				psecuritypriv->PMKIDList[j].bUsed = true;
 				psecuritypriv->PMKIDIndex = j+1;
 				blInserted = true;
 				break;
@@ -1262,41 +1123,41 @@ static int rtw_wx_set_pmkid(struct net_d
 	        }
 
 	        if (!blInserted) {
-		    /*  Find a new entry */
-                    DBG_8192D("[rtw_wx_set_pmkid] Use the new entry index = %d for this PMKID.\n",
-                            psecuritypriv->PMKIDIndex);
-
-	            memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);
-		    memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);
-
-                    psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = true;
-		    psecuritypriv->PMKIDIndex++ ;
-		    if (psecuritypriv->PMKIDIndex == 16)
-		        psecuritypriv->PMKIDIndex = 0;
-		}
-        } else if (pPMK->cmd == IW_PMKSA_REMOVE) {
-                DBG_8192D("[rtw_wx_set_pmkid] IW_PMKSA_REMOVE!\n");
-                intReturn = true;
+			/*  Find a new entry */
+			DBG_8192D("[rtw_wx_set_pmkid] Use the new entry index = %d for this PMKID.\n",
+				  psecuritypriv->PMKIDIndex);
+
+			memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);
+			memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+
+			psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = true;
+			psecuritypriv->PMKIDIndex++ ;
+			if (psecuritypriv->PMKIDIndex == 16)
+				psecuritypriv->PMKIDIndex = 0;
+		}
+	} else if (pPMK->cmd == IW_PMKSA_REMOVE) {
+		DBG_8192D("[rtw_wx_set_pmkid] IW_PMKSA_REMOVE!\n");
+		intReturn = true;
 		for (j = 0; j < NUM_PMKID_CACHE; j++) {
 			if (!memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN)) {
 				/*  BSSID is matched, the same AP => Remove this PMKID information and reset it. */
-                                memset(psecuritypriv->PMKIDList[j].Bssid, 0x00, ETH_ALEN);
-                                psecuritypriv->PMKIDList[j].bUsed = false;
+				memset(psecuritypriv->PMKIDList[j].Bssid, 0x00, ETH_ALEN);
+				psecuritypriv->PMKIDList[j].bUsed = false;
 				break;
 			}
 	        }
-        } else if (pPMK->cmd == IW_PMKSA_FLUSH) {
+	} else if (pPMK->cmd == IW_PMKSA_FLUSH) {
 		DBG_8192D("[rtw_wx_set_pmkid] IW_PMKSA_FLUSH!\n");
 		memset(&psecuritypriv->PMKIDList[0], 0x00, sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
 		psecuritypriv->PMKIDIndex = 0;
 		intReturn = true;
-        }
-	return(intReturn);
+	}
+	return intReturn;
 }
 
 static int rtw_wx_get_sens(struct net_device *dev,
-			     struct iw_request_info *info,
-			     union iwreq_data *wrqu, char *extra)
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
 {
 	wrqu->sens.value = 0;
 	wrqu->sens.fixed = 0;	/* no auto select */
@@ -1305,8 +1166,8 @@ static int rtw_wx_get_sens(struct net_de
 }
 
 static int rtw_wx_get_range(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *extra)
 {
 	struct iw_range *range = (struct iw_range *)extra;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
@@ -1333,8 +1194,7 @@ static int rtw_wx_get_range(struct net_d
 	/* ~5 Mb/s real (802.11b) */
 	range->throughput = 5 * 1000 * 1000;
 
-
-        /* Old Frequency (backward compat - moved lower) */
+	/* Old Frequency (backward compat - moved lower) */
 	/* signal level threshold range */
 
 	/* percent values between 0 and 100. */
@@ -1343,7 +1203,6 @@ static int rtw_wx_get_range(struct net_d
 	range->max_qual.noise = 100;
 	range->max_qual.updated = 7; /* Updated all three */
 
-
 	range->avg_qual.qual = 92; /* > 8% missed beacons is 'bad' */
 	/* TODO: Find real 'good' to 'bad' threshol value for RSSI */
 	range->avg_qual.level = 178; /* -78 dBm */
@@ -1364,7 +1223,6 @@ static int rtw_wx_get_range(struct net_d
 	range->we_version_compiled = WIRELESS_EXT;
 	range->we_version_source = 16;
 
-
 	for (i = 0, val = 0; i < MAX_CHANNEL_NUM; i++) {
 
 		/*  Include only legal frequencies for some countries */
@@ -1409,7 +1267,6 @@ static int rtw_wx_get_range(struct net_d
 					IW_SCAN_CAPA_CHANNEL|IW_SCAN_CAPA_MODE|IW_SCAN_CAPA_RATE;
 #endif
 
-
 	_func_exit_;
 
 	return 0;
@@ -1477,7 +1334,6 @@ static int rtw_wx_set_wap(struct net_dev
 		goto exit;
 	}
 
-
 	if (temp->sa_family != ARPHRD_ETHER) {
 		ret = -EINVAL;
 		goto exit;
@@ -1571,7 +1427,6 @@ static int rtw_wx_set_mlme(struct net_de
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_mlme *mlme = (struct iw_mlme *) extra;
 
-
 	if (mlme == NULL)
 		return -1;
 
@@ -1579,7 +1434,6 @@ static int rtw_wx_set_mlme(struct net_de
 
 	reason = cpu_to_le16(mlme->reason_code);
 
-
 	DBG_8192D("%s, cmd =%d, reason =%d\n", __func__, mlme->cmd, reason);
 
 	switch (mlme->cmd) {
@@ -1623,7 +1477,7 @@ _func_enter_;
 	}
 
 	if (padapter->bDriverStopped) {
-           DBG_8192D("bDriverStopped =%d\n", padapter->bDriverStopped);
+		DBG_8192D("bDriverStopped =%d\n", padapter->bDriverStopped);
 		ret = -1;
 		goto exit;
 	}
@@ -1677,10 +1531,10 @@ _func_enter_;
 	}
 #endif
 
-/* 	Mareded by Albert 20101103 */
-/* 	For the DMP WiFi Display project, the driver won't to scan because */
-/* 	the pmlmepriv->scan_interval is always equal to 3. */
-/* 	So, the wpa_supplicant won't find out the WPS SoftAP. */
+/*	Mareded by Albert 20101103 */
+/*	For the DMP WiFi Display project, the driver won't to scan because */
+/*	the pmlmepriv->scan_interval is always equal to 3. */
+/*	So, the wpa_supplicant won't find out the WPS SoftAP. */
 
 #ifdef CONFIG_P2P
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -1744,7 +1598,7 @@ _func_enter_;
 
 					sec_len = *(pos++); len-= 1;
 
-					if (sec_len>0 && sec_len<= len) {
+					if (sec_len > 0 && sec_len<= len) {
 						ssid[ssid_index].SsidLength = sec_len;
 						memcpy(ssid[ssid_index].Ssid, pos, ssid[ssid_index].SsidLength);
 						ssid_index++;
@@ -1753,7 +1607,6 @@ _func_enter_;
 					pos+= sec_len; len-= sec_len;
 					break;
 
-
 				case WEXT_CSCAN_CHANNEL_SECTION:
 					pos+= 1; len-= 1;
 					break;
@@ -1830,15 +1683,15 @@ static int rtw_wx_get_scan(struct net_de
 #ifdef CONFIG_P2P
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
-		/* 	P2P is enabled */
+		/*	P2P is enabled */
 		if (padapter->chip_type == RTL8192D)
-			wait_for_surveydone = 300;	/* 	Because the 8192du supports more channels. */
+			wait_for_surveydone = 300;	/*	Because the 8192du supports more channels. */
 		else
 			wait_for_surveydone = 200;
 	}
 	else
 	{
-		/* 	P2P is disabled */
+		/*	P2P is disabled */
 		wait_for_surveydone = 100;
 	}
 #else
@@ -1904,7 +1757,7 @@ static int rtw_wx_get_scan(struct net_de
 
 	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
-       wrqu->data.length = ev-extra;
+	wrqu->data.length = ev-extra;
 	wrqu->data.flags = 0;
 
 exit:
@@ -2009,12 +1862,12 @@ static int rtw_wx_set_essid(struct net_d
 	{
 		/*  Commented by Albert 20100519 */
 		/*  We got the codes in "set_info" function of iwconfig source code. */
-		/* 	========================================= */
-		/* 	wrq.u.essid.length = strlen(essid) + 1; */
-		/* 	if (we_kernel_version > 20) */
-		/* 		wrq.u.essid.length--; */
-		/* 	========================================= */
-		/* 	That means, if the WIRELESS_EXT less than or equal to 20, the correct ssid len should subtract 1. */
+		/*	========================================= */
+		/*	wrq.u.essid.length = strlen(essid) + 1; */
+		/*	if (we_kernel_version > 20) */
+		/*		wrq.u.essid.length--; */
+		/*	========================================= */
+		/*	That means, if the WIRELESS_EXT less than or equal to 20, the correct ssid len should subtract 1. */
 #if WIRELESS_EXT <= 20
 		len = ((wrqu->essid.length-1) < IW_ESSID_MAX_SIZE) ? (wrqu->essid.length-1) : IW_ESSID_MAX_SIZE;
 #else
@@ -2495,7 +2348,6 @@ static int rtw_wx_get_enc(struct net_dev
 	}
 	}
 
-
 	key = erq->flags & IW_ENCODE_INDEX;
 
 	if (key) {
@@ -2585,7 +2437,7 @@ static int rtw_wx_set_gen_ie(struct net_
 	int ret;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-       ret = rtw_set_wpa_ie(padapter, extra, wrqu->data.length);
+	ret = rtw_set_wpa_ie(padapter, extra, wrqu->data.length);
 
 	return ret;
 }
@@ -2612,50 +2464,42 @@ static int rtw_wx_set_auth(struct net_de
 		 *  ??? does not use these parameters
 		 */
 		break;
-
 	case IW_AUTH_TKIP_COUNTERMEASURES:
-        {
-	    if (param->value)
-            {  /*  wpa_supplicant is enabling the tkip countermeasure. */
-               padapter->securitypriv.btkip_countermeasure = true;
-            }
-            else
-            {  /*  wpa_supplicant is disabling the tkip countermeasure. */
-               padapter->securitypriv.btkip_countermeasure = false;
-            }
+		if (param->value) {
+			/*  wpa_supplicant is enabling the tkip countermeasure. */
+			padapter->securitypriv.btkip_countermeasure = true;
+		} else {
+			/*  wpa_supplicant is disabling the tkip countermeasure. */
+			padapter->securitypriv.btkip_countermeasure = false;
+		}
 		break;
-        }
 	case IW_AUTH_DROP_UNENCRYPTED:
-		{
-			/* HACK:
-			 *
-			 * wpa_supplicant calls set_wpa_enabled when the driver
-			 * is loaded and unloaded, regardless of if WPA is being
-			 * used.  No other calls are made which can be used to
-			 * determine if encryption will be used or not prior to
-			 * association being expected.  If encryption is not being
-			 * used, drop_unencrypted is set to false, else true -- we
-			 * can use this to determine if the CAP_PRIVACY_ON bit should
-			 * be set.
-			 */
-
-			if (padapter->securitypriv.ndisencryptstatus == NDIS802_11ENCRYPTION1ENABLED)
-			{
-				break;/* it means init value, or using wep, ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED, */
-						/*  then it needn't reset it; */
-			}
+		/* HACK:
+		 *
+		 * wpa_supplicant calls set_wpa_enabled when the driver
+		 * is loaded and unloaded, regardless of if WPA is being
+		 * used.  No other calls are made which can be used to
+		 * determine if encryption will be used or not prior to
+		 * association being expected.  If encryption is not being
+		 * used, drop_unencrypted is set to false, else true -- we
+		 * can use this to determine if the CAP_PRIVACY_ON bit should
+		 * be set.
+		 */
 
-			if (param->value) {
-				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
-				padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
-				padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
-				padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
-				padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEOPEN;
-			}
+		if (padapter->securitypriv.ndisencryptstatus == NDIS802_11ENCRYPTION1ENABLED) {
+			break;/* it means init value, or using wep, ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED, */
+					/*  then it needn't reset it; */
+		}
 
-			break;
+		if (param->value) {
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
+			padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+			padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
+			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
+			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEOPEN;
 		}
 
+		break;
 	case IW_AUTH_80211_AUTH_ALG:
 
 		#if defined(CONFIG_ANDROID) || 1
@@ -2707,7 +2551,6 @@ static int rtw_wx_set_enc_ext(struct net
 	param->cmd = IEEE_CMD_SET_ENCRYPTION;
 	memset(param->sta_addr, 0xff, ETH_ALEN);
 
-
 	switch (pext->alg) {
 	case IW_ENCODE_ALG_NONE:
 		/* todo: remove key */
@@ -2729,7 +2572,6 @@ static int rtw_wx_set_enc_ext(struct net
 
 	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
 
-
 	if (pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)/*  */
 	{
 		param->u.crypt.set_tx = 0;
@@ -2753,7 +2595,6 @@ static int rtw_wx_set_enc_ext(struct net
 		memcpy(param->u.crypt.key, pext + 1, pext->key_len);
 	}
 
-
 	if (pencoding->flags & IW_ENCODE_DISABLED)
 	{
 		/* todo: remove key */
@@ -2762,14 +2603,11 @@ static int rtw_wx_set_enc_ext(struct net
 
 	ret =  wpa_set_encryption(dev, param, param_len);
 
-
 	kfree(param);
 
-
 	return ret;
 }
 
-
 static int rtw_wx_get_nick(struct net_device *dev,
 			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
@@ -2786,8 +2624,8 @@ static int rtw_wx_get_nick(struct net_de
 }
 
 static int rtw_wx_read32(struct net_device *dev,
-                            struct iw_request_info *info,
-                            union iwreq_data *wrqu, char *extra)
+			 struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter * padapter;
 	struct iw_point *p;
@@ -2797,11 +2635,10 @@ static int rtw_wx_read32(struct net_devi
 	u32 bytes;
 	u8 *ptmp;
 
-
 	padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	p = &wrqu->data;
 	len = p->length;
-	ptmp = (u8*)rtw_malloc(len);
+	ptmp = (u8 *)rtw_malloc(len);
 	if (NULL == ptmp)
 		return -ENOMEM;
 
@@ -2839,8 +2676,8 @@ static int rtw_wx_read32(struct net_devi
 }
 
 static int rtw_wx_write32(struct net_device *dev,
-                            struct iw_request_info *info,
-                            union iwreq_data *wrqu, char *extra)
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter * padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
@@ -2848,7 +2685,6 @@ static int rtw_wx_write32(struct net_dev
 	u32 data32;
 	u32 bytes;
 
-
 	bytes = 0;
 	addr = 0;
 	data32 = 0;
@@ -2876,13 +2712,12 @@ static int rtw_wx_write32(struct net_dev
 }
 
 static int rtw_wx_read_rf(struct net_device *dev,
-                            struct iw_request_info *info,
-                            union iwreq_data *wrqu, char *extra)
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	u32 path, addr, data32;
 
-
 	path = *(u32*)extra;
 	addr = *((u32*)extra + 1);
 	data32 = rtw_hal_read_rfreg(padapter, path, addr, 0xFFFFF);
@@ -2897,13 +2732,12 @@ static int rtw_wx_read_rf(struct net_dev
 }
 
 static int rtw_wx_write_rf(struct net_device *dev,
-                            struct iw_request_info *info,
-                            union iwreq_data *wrqu, char *extra)
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	u32 path, addr, data32;
 
-
 	path = *(u32*)extra;
 	addr = *((u32*)extra + 1);
 	data32 = *((u32*)extra + 2);
@@ -2922,13 +2756,12 @@ static int dummy(struct net_device *dev,
 		 union iwreq_data *wrqu, char *b)
 {
 
-
 	return -1;
 }
 
 static int rtw_wx_set_channel_plan(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+				   struct iw_request_info *info,
+				   union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv *pregistrypriv = &padapter->registrypriv;
@@ -2988,10 +2821,9 @@ static  int rtw_drvext_hdl(struct net_de
 		goto _rtw_drvext_hdl_exit;
 	}
 
-
 	bset = (u8)(p->flags&0xFFFF);
 	len = p->length;
-	pparmbuf = (u8*)rtw_malloc(len);
+	pparmbuf = (u8 *)rtw_malloc(len);
 	if (pparmbuf == NULL) {
 		ret = -ENOMEM;
 		goto _rtw_drvext_hdl_exit;
@@ -3010,14 +2842,12 @@ static  int rtw_drvext_hdl(struct net_de
 
 	}
 
-
 	/*  */
 	poidparam = (struct drvext_oidparam *)pparmbuf;
 
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("drvext set oid subcode [%d], len[%d], InformationBufferLength[%d]\r\n",
 						 poidparam->subcode, poidparam->len, len));
 
-
 	/* check subcode */
 	if (poidparam->subcode >= MAX_DRVEXT_HANDLERS)
 	{
@@ -3026,7 +2856,6 @@ static  int rtw_drvext_hdl(struct net_de
 		goto _rtw_drvext_hdl_exit;
 	}
 
-
 	if (poidparam->subcode >= MAX_DRVEXT_OID_SUBCODES)
 	{
 		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("no matching drvext subcodes\r\n"));
@@ -3034,7 +2863,6 @@ static  int rtw_drvext_hdl(struct net_de
 		goto _rtw_drvext_hdl_exit;
 	}
 
-
 	phandler = drvextoidhandlers + poidparam->subcode;
 
 	if (poidparam->len != phandler->parmsize)
@@ -3045,7 +2873,6 @@ static  int rtw_drvext_hdl(struct net_de
 		goto _rtw_drvext_hdl_exit;
 	}
 
-
 	res = phandler->handler(&padapter->drvextpriv, bset, poidparam->data);
 
 	if (res == 0)
@@ -3060,7 +2887,6 @@ static  int rtw_drvext_hdl(struct net_de
 	else
 		ret = -EFAULT;
 
-
 _rtw_drvext_hdl_exit:
 
 	return ret;
@@ -3142,9 +2968,8 @@ static void rtw_dbg_mode_hdl(struct rtw_
 			value = prfreg->value;
 
 			rtw_hal_write_rfreg(padapter, path, offset, 0xffffffff, value);
-
 			break;
-                case GEN_MP_IOCTL_SUBCODE(TRIGGER_GPIO):
+		case GEN_MP_IOCTL_SUBCODE(TRIGGER_GPIO):
 			DBG_8192D("==> trigger gpio 0\n");
 			rtw_hal_set_hwreg(padapter, HW_VAR_TRIGGER_GPIO_0, NULL);
 			break;
@@ -3191,7 +3016,7 @@ static int rtw_mp_ioctl_hdl(struct net_d
 	pparmbuf = NULL;
 	bset = (u8)(p->flags & 0xFFFF);
 	len = p->length;
-	pparmbuf = (u8*)rtw_malloc(len);
+	pparmbuf = (u8 *)rtw_malloc(len);
 	if (pparmbuf == NULL) {
 		ret = -ENOMEM;
 		goto _rtw_mp_ioctl_hdl_exit;
@@ -3232,8 +3057,8 @@ _rtw_mp_ioctl_hdl_exit:
 }
 
 static int rtw_get_ap_info(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
 {
 	int bssid_match, ret = 0;
 	u32 cnt = 0, wpa_ielen;
@@ -3249,14 +3074,12 @@ static int rtw_get_ap_info(struct net_de
 
 	DBG_8192D("+rtw_get_aplist_info\n");
 
-	if ((padapter->bDriverStopped) || (pdata == NULL))
-	{
+	if ((padapter->bDriverStopped) || (pdata == NULL)) {
 		ret = -EINVAL;
 		goto exit;
 	}
 
-	while ((check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) == true)
-	{
+	while (check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) {
 		rtw_msleep_os(30);
 		cnt++;
 		if (cnt > 100)
@@ -3264,16 +3087,12 @@ static int rtw_get_ap_info(struct net_de
 	}
 
 	pdata->flags = 0;
-	if (pdata->length>= 32)
-	{
-		if (copy_from_user(data, pdata->pointer, 32))
-		{
+	if (pdata->length >= 32) {
+		if (copy_from_user(data, pdata->pointer, 32)) {
 			ret = -EINVAL;
 			goto exit;
 		}
-	}
-	else
-	{
+	} else {
 		ret = -EINVAL;
 		goto exit;
 	}
@@ -3283,36 +3102,30 @@ static int rtw_get_ap_info(struct net_de
 	phead = get_list_head(queue);
 	plist = get_next(phead);
 
-	while (1)
-	{
+	while (1) {
 		if (rtw_end_of_queue_search(phead, plist) == true)
 			break;
 
-
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		if (hwaddr_aton_i(data, bssid))
-		{
-			DBG_8192D("Invalid BSSID '%s'.\n", (u8*)data);
+		if (hwaddr_aton_i(data, bssid)) {
+			DBG_8192D("Invalid BSSID '%s'.\n", (u8 *)data);
 			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 			return -EINVAL;
 		}
 
-
 		if (!memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN)) {
 			/* BSSID match, then check if supporting wpa/wpa2 */
 			DBG_8192D("BSSID:%pM\n", bssid);
 
 			pbuf = rtw_get_wpa_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
-			if (pbuf && (wpa_ielen>0))
-			{
+			if (pbuf && (wpa_ielen > 0)) {
 				pdata->flags = 1;
 				break;
 			}
 
 			pbuf = rtw_get_wpa2_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
-			if (pbuf && (wpa_ielen>0))
-			{
+			if (pbuf && (wpa_ielen > 0)) {
 				pdata->flags = 2;
 				break;
 			}
@@ -3326,7 +3139,7 @@ static int rtw_get_ap_info(struct net_de
 	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	if (pdata->length>= 34) {
-		if (copy_to_user((u8 __user *)pdata->pointer+32, (u8*)&pdata->flags, 1)) {
+		if (copy_to_user((u8 __user *)pdata->pointer+32, (u8 *)&pdata->flags, 1)) {
 			ret = -EINVAL;
 			goto exit;
 		}
@@ -3338,8 +3151,8 @@ exit:
 }
 
 static int rtw_set_pid(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+		       struct iw_request_info *info,
+		       union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
@@ -3365,16 +3178,16 @@ exit:
 }
 
 static int rtw_wps_start(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			 struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point *pdata = &wrqu->data;
 	u32   u32wps_start = 0;
-        unsigned int uintRet = 0;
+	unsigned int uintRet = 0;
 
-        uintRet = copy_from_user((void*) &u32wps_start, pdata->pointer, 4);
+	uintRet = copy_from_user((void*) &u32wps_start, pdata->pointer, 4);
 	if (uintRet || padapter->bDriverStopped || pdata == NULL) {
 		ret = -EINVAL;
 		goto exit;
@@ -3409,8 +3222,8 @@ exit:
 
 #ifdef CONFIG_P2P
 static int rtw_wext_p2p_enable(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
@@ -3445,7 +3258,7 @@ static int rtw_wext_p2p_enable(struct ne
 
 		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN))
 		{
-			/* 	Stay at the listen state and wait for discovery. */
+			/*	Stay at the listen state and wait for discovery. */
 			channel = pwdinfo->listen_channel;
 			pwdinfo->operating_channel = pwdinfo->listen_channel;
 			ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
@@ -3462,7 +3275,7 @@ static int rtw_wext_p2p_enable(struct ne
 			if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
 			{
 				pwdinfo->operating_channel = pbuddy_mlmeext->cur_channel;
-				/* 	How about the ch_offset and bwmode ?? */
+				/*	How about the ch_offset and bwmode ?? */
 			}
 			else
 			{
@@ -3491,11 +3304,9 @@ exit:
 }
 
 static int rtw_p2p_set_go_nego_ssid(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+				    struct iw_request_info *info,
+				    union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct iw_point *pdata = &wrqu->data;
@@ -3505,15 +3316,14 @@ static int rtw_p2p_set_go_nego_ssid(stru
 	memcpy(pwdinfo->nego_ssid, extra, strlen(extra));
 	pwdinfo->nego_ssidlen = strlen(extra);
 
-	return ret;
+	return 0;
 }
 
-
 static int rtw_p2p_set_intent(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			      struct iw_request_info *info,
+			      union iwreq_data *wrqu, char *extra)
 {
-	int							ret = 0;
+	int	ret = 0;
 	struct rtw_adapter						*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info			*pwdinfo = &(padapter->wdinfo);
 	u8							intent = pwdinfo->intent;
@@ -3547,14 +3357,14 @@ static int rtw_p2p_set_intent(struct net
 }
 
 static int rtw_p2p_set_listen_ch(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+				 struct iw_request_info *info,
+       				 union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-	u8	listen_ch = pwdinfo->listen_channel;	/* 	Listen channel number */
+	u8	listen_ch = pwdinfo->listen_channel;	/*	Listen channel number */
 
 	switch (wrqu->data.length)
 	{
@@ -3586,16 +3396,16 @@ static int rtw_p2p_set_listen_ch(struct
 }
 
 static int rtw_p2p_set_op_ch(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
 {
-/* 	Commented by Albert 20110524 */
-/* 	This function is used to set the operating channel if the driver will become the group owner */
+/*	Commented by Albert 20110524 */
+/*	This function is used to set the operating channel if the driver will become the group owner */
 
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-	u8	op_ch = pwdinfo->operating_channel;	/* 	Operating channel number */
+	u8	op_ch = pwdinfo->operating_channel;	/*	Operating channel number */
 
 	switch (wrqu->data.length)
 	{
@@ -3625,35 +3435,32 @@ static int rtw_p2p_set_op_ch(struct net_
 	return ret;
 }
 
-
 static int rtw_p2p_profilefound(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
 {
-
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
 
-	/* 	Comment by Albert 2010/10/13 */
-	/* 	Input data format: */
-	/* 	Ex:  0 */
-	/* 	Ex:  1XX:XX:XX:XX:XX:XXYYSSID */
-	/* 	0 => Reflush the profile record list. */
-	/* 	1 => Add the profile list */
-	/* 	XX:XX:XX:XX:XX:XX => peer's MAC Address (ex: 00:E0:4C:00:00:01) */
-	/* 	YY => SSID Length */
-	/* 	SSID => SSID for persistence group */
+	/*	Comment by Albert 2010/10/13 */
+	/*	Input data format: */
+	/*	Ex:  0 */
+	/*	Ex:  1XX:XX:XX:XX:XX:XXYYSSID */
+	/*	0 => Reflush the profile record list. */
+	/*	1 => Add the profile list */
+	/*	XX:XX:XX:XX:XX:XX => peer's MAC Address (ex: 00:E0:4C:00:00:01) */
+	/*	YY => SSID Length */
+	/*	SSID => SSID for persistence group */
 
 	DBG_8192D("[%s] In value = %s, len = %d\n", __func__, extra, wrqu->data.length -1);
 
-
-	/* 	The upper application should pass the SSID to driver by using this rtw_p2p_profilefound function. */
+	/*	The upper application should pass the SSID to driver by using this rtw_p2p_profilefound function. */
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		if (extra[0] == '0')
 		{
-			/* 	Remove all the profile information of wifidirect_info structure. */
+			/*	Remove all the profile information of wifidirect_info structure. */
 			memset(&pwdinfo->profileinfo[0], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
 			pwdinfo->profileindex = 0;
 		}
@@ -3667,8 +3474,8 @@ static int rtw_p2p_profilefound(struct n
 		{
 				int jj, kk;
 
-				/* 	Add this profile information into pwdinfo->profileinfo */
-				/* 	Ex:  1XX:XX:XX:XX:XX:XXYYSSID */
+				/*	Add this profile information into pwdinfo->profileinfo */
+				/*	Ex:  1XX:XX:XX:XX:XX:XXYYSSID */
 				for (jj = 0, kk = 1; jj < ETH_ALEN; jj++, kk += 3)
 				{
 					pwdinfo->profileinfo[pwdinfo->profileindex].peermac[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
@@ -3683,59 +3490,56 @@ static int rtw_p2p_profilefound(struct n
 }
 
 static int rtw_p2p_setDN(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			 struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
 
-
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
-
 	memset(pwdinfo->device_name, 0x00, WPS_MAX_DEVICE_NAME_LEN);
 	memcpy(pwdinfo->device_name, extra, wrqu->data.length - 1);
 	pwdinfo->device_name_len = wrqu->data.length - 1;
-	return ret;
+	return 0;
 }
 
-
 static int rtw_p2p_get_status(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			      struct iw_request_info *info,
+			      union iwreq_data *wrqu, char *extra)
 {
-
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-
-	if (padapter->bShowGetP2PState)
-	{
-		DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-				pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
-				pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
+	if (padapter->bShowGetP2PState) {
+		DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n",
+			  __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
+			  pwdinfo->p2p_peer_interface_addr[0],
+			  pwdinfo->p2p_peer_interface_addr[1],
+			  pwdinfo->p2p_peer_interface_addr[2],
+			  pwdinfo->p2p_peer_interface_addr[3],
+			  pwdinfo->p2p_peer_interface_addr[4],
+			  pwdinfo->p2p_peer_interface_addr[5]);
 	}
 
-	/* 	Commented by Albert 2010/10/12 */
-	/* 	Because of the output size limitation, I had removed the "Role" information. */
-	/* 	About the "Role" information, we will use the new private IOCTL to get the "Role" information. */
+	/*	Commented by Albert 2010/10/12 */
+	/*	Because of the output size limitation, I had removed the "Role" information. */
+	/*	About the "Role" information, we will use the new private IOCTL to get the "Role" information. */
 	sprintf(extra, "\n\nStatus =%.2d\n", rtw_p2p_state(pwdinfo));
 	wrqu->data.length = strlen(extra);
 
 	return ret;
 }
 
-/* 	Commented by Albert 20110520 */
-/* 	This function will return the config method description */
-/* 	This config method description will show us which config method the remote P2P device is intented to use */
-/* 	by sending the provisioning discovery request frame. */
+/*	Commented by Albert 20110520 */
+/*	This function will return the config method description */
+/*	This config method description will show us which config method the remote P2P device is intented to use */
+/*	by sending the provisioning discovery request frame. */
 
 static int rtw_p2p_get_req_cm(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			      struct iw_request_info *info,
+			      union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
@@ -3748,10 +3552,9 @@ static int rtw_p2p_get_req_cm(struct net
 	return ret;
 }
 
-
 static int rtw_p2p_get_role(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
@@ -3759,20 +3562,23 @@ static int rtw_p2p_get_role(struct net_d
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-
-	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-			pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
-			pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
+	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n",
+		  __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
+		  pwdinfo->p2p_peer_interface_addr[0],
+		  pwdinfo->p2p_peer_interface_addr[1],
+		  pwdinfo->p2p_peer_interface_addr[2],
+		  pwdinfo->p2p_peer_interface_addr[3],
+		  pwdinfo->p2p_peer_interface_addr[4],
+		  pwdinfo->p2p_peer_interface_addr[5]);
 
 	sprintf(extra, "\n\nRole =%.2d\n", rtw_p2p_role(pwdinfo));
 	wrqu->data.length = strlen(extra);
 	return ret;
 }
 
-
 static int rtw_p2p_get_peer_ifaddr(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+				   struct iw_request_info *info,
+				   union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
@@ -3780,7 +3586,6 @@ static int rtw_p2p_get_peer_ifaddr(struc
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-
 	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
 			pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
 			pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
@@ -3793,8 +3598,8 @@ static int rtw_p2p_get_peer_ifaddr(struc
 }
 
 static int rtw_p2p_get_peer_devaddr(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+				    struct iw_request_info *info,
+				    union iwreq_data *wrqu, char *extra)
 
 {
 
@@ -3816,12 +3621,9 @@ static int rtw_p2p_get_peer_devaddr(stru
 }
 
 static int rtw_p2p_get_peer_devaddr_by_invitation(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
-
+						  struct iw_request_info *info,
+						  union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
@@ -3835,46 +3637,38 @@ static int rtw_p2p_get_peer_devaddr_by_i
 			pwdinfo->p2p_peer_device_addr[2], pwdinfo->p2p_peer_device_addr[3],
 			pwdinfo->p2p_peer_device_addr[4], pwdinfo->p2p_peer_device_addr[5]);
 	wrqu->data.length = strlen(extra);
-	return ret;
+	return 0;
 }
 
 static int rtw_p2p_get_groupid(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
 
 {
-
-	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-	sprintf(extra, "\n%.2X:%.2X:%.2X:%.2X:%.2X:%.2X %s",
-			pwdinfo->groupid_info.go_device_addr[0], pwdinfo->groupid_info.go_device_addr[1],
-			pwdinfo->groupid_info.go_device_addr[2], pwdinfo->groupid_info.go_device_addr[3],
-			pwdinfo->groupid_info.go_device_addr[4], pwdinfo->groupid_info.go_device_addr[5],
-			pwdinfo->groupid_info.ssid);
+	sprintf(extra, "\n%pM %s",
+		pwdinfo->groupid_info.go_device_addr,
+		pwdinfo->groupid_info.ssid);
 	wrqu->data.length = strlen(extra);
-	return ret;
+	return 0;
 }
 
 static int rtw_p2p_get_op_ch(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
-
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-
 	DBG_8192D("[%s] Op_ch = %02x\n", __func__, pwdinfo->operating_channel);
 
 	sprintf(extra, "\n\nOp_ch =%.2d\n", pwdinfo->operating_channel);
 	wrqu->data.length = strlen(extra);
-	return ret;
+	return 0;
 }
 
 inline static void macstr2num(u8 *dst, u8 *src)
@@ -3903,10 +3697,10 @@ static int rtw_p2p_get_wps_configmethod(
 	uint attr_contentlen = 0;
 	u8	attr_content_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
 
-	/* 	Commented by Albert 20110727 */
-	/* 	The input data is the MAC address which the application wants to know its WPS config method. */
-	/* 	After knowing its WPS config method, the application can decide the config method for provisioning discovery. */
-	/* 	Format: iwpriv wlanx p2p_get_wpsCM 00:E0:4C:00:00:05 */
+	/*	Commented by Albert 20110727 */
+	/*	The input data is the MAC address which the application wants to know its WPS config method. */
+	/*	After knowing its WPS config method, the application can decide the config method for provisioning discovery. */
+	/*	Format: iwpriv wlanx p2p_get_wpsCM 00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
 
@@ -3927,7 +3721,7 @@ static int rtw_p2p_get_wps_configmethod(
 			u8 *wpsie;
 			uint	wpsie_len = 0;
 
-			/* 	The mac address is matched. */
+			/*	The mac address is matched. */
 
 			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
 			{
@@ -3960,8 +3754,8 @@ static int rtw_p2p_get_wps_configmethod(
 
 #ifdef CONFIG_WFD
 static int rtw_p2p_get_peer_wfd_port(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+				     struct iw_request_info *info,
+				     union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
@@ -3979,8 +3773,8 @@ static int rtw_p2p_get_peer_wfd_port(str
 }
 
 static int rtw_p2p_get_peer_wfd_preferred_connection(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+						     struct iw_request_info *info,
+						     union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
@@ -3992,13 +3786,13 @@ static int rtw_p2p_get_peer_wfd_preferre
 	DBG_8192D("[%s] wfd_pc = %d\n", __func__, pwdinfo->wfd_info->wfd_pc);
 
 	wrqu->data.length = strlen(extra);
-	pwdinfo->wfd_info->wfd_pc = false;	/* 	Reset the WFD preferred connection to P2P */
+	pwdinfo->wfd_info->wfd_pc = false;	/*	Reset the WFD preferred connection to P2P */
 	return ret;
 }
 
 static int rtw_p2p_get_peer_wfd_session_available(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+						  struct iw_request_info *info,
+						  union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
@@ -4010,7 +3804,7 @@ static int rtw_p2p_get_peer_wfd_session_
 	DBG_8192D("[%s] wfd_sa = %d\n", __func__, pwdinfo->wfd_info->peer_session_avail);
 
 	wrqu->data.length = strlen(extra);
-	pwdinfo->wfd_info->peer_session_avail = true;	/* 	Reset the WFD session available */
+	pwdinfo->wfd_info->peer_session_avail = true;	/*	Reset the WFD session available */
 	return ret;
 }
 
@@ -4034,9 +3828,9 @@ static int rtw_p2p_get_go_device_address
 	u8 attr_content[100] = { 0x00 };
 	u8 go_devadd_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
 
-	/* 	Commented by Albert 20121209 */
-	/* 	The input data is the GO's interface address which the application wants to know its device address. */
-	/* 	Format: iwpriv wlanx p2p_get2 go_devadd = 00:E0:4C:00:00:05 */
+	/*	Commented by Albert 20121209 */
+	/*	The input data is the GO's interface address which the application wants to know its device address. */
+	/*	Format: iwpriv wlanx p2p_get2 go_devadd = 00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
 
@@ -4054,27 +3848,27 @@ static int rtw_p2p_get_go_device_address
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 		if (!memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
 		{
-			/* 	Commented by Albert 2011/05/18 */
-			/* 	Match the device address located in the P2P IE */
-			/* 	This is for the case that the P2P device address is not the same as the P2P interface address. */
+			/*	Commented by Albert 2011/05/18 */
+			/*	Match the device address located in the P2P IE */
+			/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
 
 			if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
 			{
 				while (p2pie)
 				{
-					/* 	The P2P Device ID attribute is included in the Beacon frame. */
-					/* 	The P2P Device Info attribute is included in the probe response frame. */
+					/*	The P2P Device ID attribute is included in the Beacon frame. */
+					/*	The P2P Device Info attribute is included in the probe response frame. */
 
 					memset(attr_content, 0x00, 100);
 					if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
 					{
-						/* 	Handle the P2P Device ID attribute of Beacon first */
+						/*	Handle the P2P Device ID attribute of Beacon first */
 						blnMatch = 1;
 						break;
 
 					} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
 					{
-						/* 	Handle the P2P Device Info attribute of probe response */
+						/*	Handle the P2P Device Info attribute of probe response */
 						blnMatch = 1;
 						break;
 					}
@@ -4123,10 +3917,10 @@ static int rtw_p2p_get_device_type(struc
 	uint dev_type_len = 0;
 	u8 dev_type_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };    /*  +9 is for the str "dev_type =", we have to clear it at wrqu->data.pointer */
 
-	/* 	Commented by Albert 20121209 */
-	/* 	The input data is the MAC address which the application wants to know its device type. */
-	/* 	Such user interface could know the device type. */
-	/* 	Format: iwpriv wlanx p2p_get2 dev_type = 00:E0:4C:00:00:05 */
+	/*	Commented by Albert 20121209 */
+	/*	The input data is the MAC address which the application wants to know its device type. */
+	/*	Such user interface could know the device type. */
+	/*	Format: iwpriv wlanx p2p_get2 dev_type = 00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
 
@@ -4147,7 +3941,7 @@ static int rtw_p2p_get_device_type(struc
 			u8 *wpsie;
 			uint	wpsie_len = 0;
 
-			/* 	The mac address is matched. */
+			/*	The mac address is matched. */
 
 			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
 			{
@@ -4198,10 +3992,10 @@ static int rtw_p2p_get_device_name(struc
 	uint dev_len = 0;
 	u8 dev_name_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
 
-	/* 	Commented by Albert 20121225 */
-	/* 	The input data is the MAC address which the application wants to know its device name. */
-	/* 	Such user interface could show peer device's device name instead of ssid. */
-	/* 	Format: iwpriv wlanx p2p_get2 devN = 00:E0:4C:00:00:05 */
+	/*	Commented by Albert 20121225 */
+	/*	The input data is the MAC address which the application wants to know its device name. */
+	/*	Such user interface could show peer device's device name instead of ssid. */
+	/*	Format: iwpriv wlanx p2p_get2 devN = 00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
 
@@ -4222,7 +4016,7 @@ static int rtw_p2p_get_device_name(struc
 			u8 *wpsie;
 			uint	wpsie_len = 0;
 
-			/* 	The mac address is matched. */
+			/*	The mac address is matched. */
 
 			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
 			{
@@ -4271,9 +4065,9 @@ static int rtw_p2p_get_invitation_proced
 	u8 attr_content[2] = { 0x00 };
 	u8 inv_proc_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
 
-	/* 	Commented by Ouden 20121226 */
-	/* 	The application wants to know P2P initation procedure is support or not. */
-	/* 	Format: iwpriv wlanx p2p_get2 InvProc = 00:E0:4C:00:00:05 */
+	/*	Commented by Ouden 20121226 */
+	/*	The application wants to know P2P initation procedure is support or not. */
+	/*	Format: iwpriv wlanx p2p_get2 InvProc = 00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
 
@@ -4291,9 +4085,9 @@ static int rtw_p2p_get_invitation_proced
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 		if (!memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
 		{
-			/* 	Commented by Albert 20121226 */
-			/* 	Match the device address located in the P2P IE */
-			/* 	This is for the case that the P2P device address is not the same as the P2P interface address. */
+			/*	Commented by Albert 20121226 */
+			/*	Match the device address located in the P2P IE */
+			/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
 
 			if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
 			{
@@ -4301,7 +4095,7 @@ static int rtw_p2p_get_invitation_proced
 				{
 					if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_CAPABILITY, attr_content, &attr_contentlen))
 					{
-						/* 	Handle the P2P capability attribute */
+						/*	Handle the P2P capability attribute */
 						blnMatch = 1;
 						break;
 
@@ -4340,10 +4134,9 @@ static int rtw_p2p_get_invitation_proced
 }
 
 static int rtw_p2p_connect(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
 {
-
 	int ret = 0;
 	struct rtw_adapter				*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
@@ -4360,13 +4153,12 @@ static int rtw_p2p_connect(struct net_de
 	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 #endif /*  CONFIG_CONCURRENT_MODE */
 
-
-	/* 	Commented by Albert 20110304 */
-	/* 	The input data contains two informations. */
-	/* 	1. First information is the MAC address which wants to formate with */
-	/* 	2. Second information is the WPS PINCode or "pbc" string for push button method */
-	/* 	Format: 00:E0:4C:00:00:05 */
-	/* 	Format: 00:E0:4C:00:00:05 */
+	/*	Commented by Albert 20110304 */
+	/*	The input data contains two informations. */
+	/*	1. First information is the MAC address which wants to formate with */
+	/*	2. Second information is the WPS PINCode or "pbc" string for push button method */
+	/*	Format: 00:E0:4C:00:00:05 */
+	/*	Format: 00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
@@ -4397,11 +4189,10 @@ static int rtw_p2p_connect(struct net_de
 			break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
-		if (!memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
-		{
+		if (!memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN)) {
 			uintPeerChannel = pnetwork->network.Configuration.DSConfig;
 			break;
-              }
+		}
 
 		plist = get_next(plist);
 
@@ -4428,7 +4219,7 @@ static int rtw_p2p_connect(struct net_de
 		_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
 		if (rtw_p2p_state(pwdinfo) != P2P_STATE_GONEGO_OK)
 		{
-			/* 	Restore to the listen state if the current p2p state is not nego OK */
+			/*	Restore to the listen state if the current p2p state is not nego OK */
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
 		}
 
@@ -4438,7 +4229,7 @@ static int rtw_p2p_connect(struct net_de
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_buddy_fwstate(padapter, _FW_LINKED))
 		{
-			/* 	Have to enter the power saving with the AP */
+			/*	Have to enter the power saving with the AP */
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 
 			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
@@ -4472,10 +4263,9 @@ exit:
 }
 
 static int rtw_p2p_invite_req(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			      struct iw_request_info *info,
+			      union iwreq_data *wrqu, char *extra)
 {
-
 	int ret = 0;
 	struct rtw_adapter					*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point				*pdata = &wrqu->data;
@@ -4501,12 +4291,12 @@ static int rtw_p2p_invite_req(struct net
 	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
 #endif /*  CONFIG_WFD */
 
-	/* 	Commented by Albert 20120321 */
-	/* 	The input data contains two informations. */
-	/* 	1. First information is the P2P device address which you want to send to. */
-	/* 	2. Second information is the group id which combines with GO's mac address, space and GO's ssid. */
-	/* 	Command line sample: iwpriv wlan0 p2p_set invite ="00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy" */
-	/* 	Format: 00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy */
+	/*	Commented by Albert 20120321 */
+	/*	The input data contains two informations. */
+	/*	1. First information is the P2P device address which you want to send to. */
+	/*	2. Second information is the group id which combines with GO's mac address, space and GO's ssid. */
+	/*	Command line sample: iwpriv wlan0 p2p_set invite ="00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy" */
+	/*	Format: 00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
@@ -4523,7 +4313,7 @@ static int rtw_p2p_invite_req(struct net
 	}
 	else
 	{
-		/* 	Reset the content of struct tx_invite_req_info */
+		/*	Reset the content of struct tx_invite_req_info */
 		pinvite_req_info->benable = false;
 		memset(pinvite_req_info->go_bssid, 0x00, ETH_ALEN);
 		memset(pinvite_req_info->go_ssid, 0x00, WLAN_SSID_MAXLEN);
@@ -4550,18 +4340,18 @@ static int rtw_p2p_invite_req(struct net
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		/* 	Commented by Albert 2011/05/18 */
-		/* 	Match the device address located in the P2P IE */
-		/* 	This is for the case that the P2P device address is not the same as the P2P interface address. */
+		/*	Commented by Albert 2011/05/18 */
+		/*	Match the device address located in the P2P IE */
+		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
 
 		if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
 		{
-			/* 	The P2P Device ID attribute is included in the Beacon frame. */
-			/* 	The P2P Device Info attribute is included in the probe response frame. */
+			/*	The P2P Device ID attribute is included in the Beacon frame. */
+			/*	The P2P Device Info attribute is included in the probe response frame. */
 
 			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
 			{
-				/* 	Handle the P2P Device ID attribute of Beacon first */
+				/*	Handle the P2P Device ID attribute of Beacon first */
 				if (!memcmp(attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN))
 				{
 					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
@@ -4570,7 +4360,7 @@ static int rtw_p2p_invite_req(struct net
 			}
 			else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
 			{
-				/* 	Handle the P2P Device Info attribute of probe response */
+				/*	Handle the P2P Device Info attribute of probe response */
 				if (!memcmp(attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN))
 				{
 					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
@@ -4602,9 +4392,9 @@ static int rtw_p2p_invite_req(struct net
 			{
 				u16	wfd_devinfo_field = 0;
 
-				/* 	Commented by Albert 20120319 */
-				/* 	The first two bytes are the WFD device information field of WFD device information subelement. */
-				/* 	In big endian format. */
+				/*	Commented by Albert 20120319 */
+				/*	The first two bytes are the WFD device information field of WFD device information subelement. */
+				/*	In big endian format. */
 				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
 				if (wfd_devinfo_field & WFD_DEVINFO_SESSION_AVAIL)
 				{
@@ -4634,13 +4424,13 @@ static int rtw_p2p_invite_req(struct net
 		}
 #endif /*  CONFIG_CONCURRENT_MODE */
 
-		/* 	Store the GO's bssid */
+		/*	Store the GO's bssid */
 		for (jj = 0, kk = 18; jj < ETH_ALEN; jj++, kk += 3)
 		{
 			pinvite_req_info->go_bssid[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
 		}
 
-		/* 	Store the GO's ssid */
+		/*	Store the GO's ssid */
 		pinvite_req_info->ssidlen = wrqu->data.length - 36;
 		memcpy(pinvite_req_info->go_ssid, &extra[36], (u32) pinvite_req_info->ssidlen);
 		pinvite_req_info->benable = true;
@@ -4652,7 +4442,7 @@ static int rtw_p2p_invite_req(struct net
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
 		{
-			/* 	Have to enter the power saving with the AP */
+			/*	Have to enter the power saving with the AP */
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 
 			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
@@ -4680,7 +4470,6 @@ static int rtw_p2p_invite_req(struct net
 		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT);
 #endif /*  CONFIG_CONCURRENT_MODE */
 
-
 	}
 	else
 	{
@@ -4692,10 +4481,9 @@ exit:
 }
 
 static int rtw_p2p_set_persistent(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+				  struct iw_request_info *info,
+				  union iwreq_data *wrqu, char *extra)
 {
-
 	int ret = 0;
 	struct rtw_adapter					*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point				*pdata = &wrqu->data;
@@ -4721,10 +4509,10 @@ static int rtw_p2p_set_persistent(struct
 	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
 #endif /*  CONFIG_WFD */
 
-	/* 	Commented by Albert 20120328 */
-	/* 	The input data is 0 or 1 */
-	/* 	0: disable persistent group functionality */
-	/* 	1: enable persistent group founctionality */
+	/*	Commented by Albert 20120328 */
+	/*	The input data is 0 or 1 */
+	/*	0: disable persistent group functionality */
+	/*	1: enable persistent group founctionality */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
@@ -4735,11 +4523,11 @@ static int rtw_p2p_set_persistent(struct
 	}
 	else
 	{
-		if (extra[0] == '0')	/* 	Disable the persistent group function. */
+		if (extra[0] == '0')	/*	Disable the persistent group function. */
 		{
 			pwdinfo->persistent_supported = false;
 		}
-		else if (extra[0] == '1')	/* 	Enable the persistent group function. */
+		else if (extra[0] == '1')	/*	Enable the persistent group function. */
 		{
 			pwdinfo->persistent_supported = true;
 		}
@@ -4757,8 +4545,8 @@ exit:
 
 #ifdef CONFIG_WFD
 static int rtw_p2p_set_pc(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
@@ -4782,9 +4570,9 @@ static int rtw_p2p_set_pc(struct net_dev
 #endif /*  CONFIG_CONCURRENT_MODE */
 	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
 
-	/* 	Commented by Albert 20120512 */
-	/* 	1. Input information is the MAC address which wants to know the Preferred Connection bit (PC bit) */
-	/* 	Format: 00:E0:4C:00:00:05 */
+	/*	Commented by Albert 20120512 */
+	/*	1. Input information is the MAC address which wants to know the Preferred Connection bit (PC bit) */
+	/*	Format: 00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
@@ -4811,18 +4599,18 @@ static int rtw_p2p_set_pc(struct net_dev
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		/* 	Commented by Albert 2011/05/18 */
-		/* 	Match the device address located in the P2P IE */
-		/* 	This is for the case that the P2P device address is not the same as the P2P interface address. */
+		/*	Commented by Albert 2011/05/18 */
+		/*	Match the device address located in the P2P IE */
+		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
 
 		if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
 		{
-			/* 	The P2P Device ID attribute is included in the Beacon frame. */
-			/* 	The P2P Device Info attribute is included in the probe response frame. */
+			/*	The P2P Device ID attribute is included in the Beacon frame. */
+			/*	The P2P Device Info attribute is included in the probe response frame. */
 			DBG_8192D("[%s] Got P2P IE\n", __func__);
 			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
 			{
-				/* 	Handle the P2P Device ID attribute of Beacon first */
+				/*	Handle the P2P Device ID attribute of Beacon first */
 				DBG_8192D("[%s] P2P_ATTR_DEVICE_ID\n", __func__);
 				if (!memcmp(attr_content, peerMAC, ETH_ALEN))
 				{
@@ -4832,7 +4620,7 @@ static int rtw_p2p_set_pc(struct net_dev
 			}
 			else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
 			{
-				/* 	Handle the P2P Device Info attribute of probe response */
+				/*	Handle the P2P Device Info attribute of probe response */
 				DBG_8192D("[%s] P2P_ATTR_DEVICE_INFO\n", __func__);
 				if (!memcmp(attr_content, peerMAC, ETH_ALEN))
 				{
@@ -4865,9 +4653,9 @@ static int rtw_p2p_set_pc(struct net_dev
 			{
 				u16	wfd_devinfo_field = 0;
 
-				/* 	Commented by Albert 20120319 */
-				/* 	The first two bytes are the WFD device information field of WFD device information subelement. */
-				/* 	In big endian format. */
+				/*	Commented by Albert 20120319 */
+				/*	The first two bytes are the WFD device information field of WFD device information subelement. */
+				/*	In big endian format. */
 				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
 				if (wfd_devinfo_field & WFD_DEVINFO_PC_TDLS)
 				{
@@ -4891,28 +4679,27 @@ exit:
 }
 
 static int rtw_p2p_set_wfd_device_type(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+				       struct iw_request_info *info,
+				       union iwreq_data *wrqu, char *extra)
 {
-
 	int ret = 0;
 	struct rtw_adapter					*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point				*pdata = &wrqu->data;
 	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
 	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
 
-	/* 	Commented by Albert 20120328 */
-	/* 	The input data is 0 or 1 */
-	/* 	0: specify to Miracast source device */
-	/* 	1 or others: specify to Miracast sink device (display device) */
+	/*	Commented by Albert 20120328 */
+	/*	The input data is 0 or 1 */
+	/*	0: specify to Miracast source device */
+	/*	1 or others: specify to Miracast sink device (display device) */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
-	if (extra[0] == '0')	/* 	Set to Miracast source device. */
+	if (extra[0] == '0')	/*	Set to Miracast source device. */
 	{
 		pwfd_info->wfd_device_type = WFD_DEVINFO_SOURCE;
 	}
-	else					/* 	Set to Miracast sink device. */
+	else					/*	Set to Miracast sink device. */
 	{
 		pwfd_info->wfd_device_type = WFD_DEVINFO_PSINK;
 	}
@@ -4923,8 +4710,8 @@ exit:
 }
 
 static int rtw_p2p_set_scan_result_type(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+					struct iw_request_info *info,
+					union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
@@ -4933,13 +4720,13 @@ static int rtw_p2p_set_scan_result_type(
 	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
 	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
 
-	/* 	Commented by Albert 20120328 */
-	/* 	The input data is 0 , 1 , 2 */
-	/* 	0: when the P2P is enabled, the scan result will return all the found P2P device. */
-	/* 	1: when the P2P is enabled, the scan result will return all the found P2P device and AP. */
-	/* 	2: when the P2P is enabled, the scan result will show up the found Miracast devices base on... */
-	/* 	It will show up all the Miracast source device if this device is sink. */
-	/* 	It will show up all the Miracast sink device if this device is source. */
+	/*	Commented by Albert 20120328 */
+	/*	The input data is 0 , 1 , 2 */
+	/*	0: when the P2P is enabled, the scan result will return all the found P2P device. */
+	/*	1: when the P2P is enabled, the scan result will return all the found P2P device and AP. */
+	/*	2: when the P2P is enabled, the scan result will show up the found Miracast devices base on... */
+	/*	It will show up all the Miracast source device if this device is sink. */
+	/*	It will show up all the Miracast sink device if this device is source. */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
@@ -4965,10 +4752,10 @@ exit:
 	return ret;
 }
 
-/* 	To set the WFD session available to enable or disable */
+/*	To set the WFD session available to enable or disable */
 static int rtw_p2p_set_sa(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
@@ -4979,9 +4766,9 @@ static int rtw_p2p_set_sa(struct net_dev
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
-	if (extra[0] == '0')	/* 	Disable the session available. */
+	if (extra[0] == '0')	/*	Disable the session available. */
 		pwdinfo->session_available = false;
-	else if (extra[0] == '1')	/* 	Enable the session available. */
+	else if (extra[0] == '1')	/*	Enable the session available. */
 		pwdinfo->session_available = true;
 	else
 		pwdinfo->session_available = false;
@@ -4994,8 +4781,8 @@ exit:
 #endif /* CONFIG_WFD */
 
 static int rtw_p2p_prov_disc(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
 	struct rtw_adapter				*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
@@ -5020,14 +4807,14 @@ static int rtw_p2p_prov_disc(struct net_
 	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
 #endif /*  CONFIG_WFD */
 
-	/* 	Commented by Albert 20110301 */
-	/* 	The input data contains two informations. */
-	/* 	1. First information is the MAC address which wants to issue the provisioning discovery request frame. */
-	/* 	2. Second information is the WPS configuration method which wants to discovery */
-	/* 	Format: 00:E0:4C:00:00:05_display */
-	/* 	Format: 00:E0:4C:00:00:05_keypad */
-	/* 	Format: 00:E0:4C:00:00:05_pbc */
-	/* 	Format: 00:E0:4C:00:00:05_label */
+	/*	Commented by Albert 20110301 */
+	/*	The input data contains two informations. */
+	/*	1. First information is the MAC address which wants to issue the provisioning discovery request frame. */
+	/*	2. Second information is the WPS configuration method which wants to discovery */
+	/*	Format: 00:E0:4C:00:00:05_display */
+	/*	Format: 00:E0:4C:00:00:05_keypad */
+	/*	Format: 00:E0:4C:00:00:05_pbc */
+	/*	Format: 00:E0:4C:00:00:05_label */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
@@ -5038,7 +4825,7 @@ static int rtw_p2p_prov_disc(struct net_
 	}
 	else
 	{
-		/* 	Reset the content of struct tx_provdisc_req_info excluded the wps_config_method_request. */
+		/*	Reset the content of struct tx_provdisc_req_info excluded the wps_config_method_request. */
 		memset(pwdinfo->tx_prov_disc_info.peerDevAddr, 0x00, ETH_ALEN);
 		memset(pwdinfo->tx_prov_disc_info.peerIFAddr, 0x00, ETH_ALEN);
 		memset(&pwdinfo->tx_prov_disc_info.ssid, 0x00, sizeof(struct ndis_802_11_ssid));
@@ -5089,20 +4876,20 @@ static int rtw_p2p_prov_disc(struct net_
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		/* 	Commented by Albert 2011/05/18 */
-		/* 	Match the device address located in the P2P IE */
-		/* 	This is for the case that the P2P device address is not the same as the P2P interface address. */
+		/*	Commented by Albert 2011/05/18 */
+		/*	Match the device address located in the P2P IE */
+		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
 
 		if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
 		{
 			while (p2pie)
 			{
-				/* 	The P2P Device ID attribute is included in the Beacon frame. */
-				/* 	The P2P Device Info attribute is included in the probe response frame. */
+				/*	The P2P Device ID attribute is included in the Beacon frame. */
+				/*	The P2P Device Info attribute is included in the probe response frame. */
 
 				if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
 				{
-					/* 	Handle the P2P Device ID attribute of Beacon first */
+					/*	Handle the P2P Device ID attribute of Beacon first */
 					if (!memcmp(attr_content, peerMAC, ETH_ALEN))
 					{
 						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
@@ -5111,7 +4898,7 @@ static int rtw_p2p_prov_disc(struct net_
 				}
 				else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
 				{
-					/* 	Handle the P2P Device Info attribute of probe response */
+					/*	Handle the P2P Device Info attribute of probe response */
 					if (!memcmp(attr_content, peerMAC, ETH_ALEN))
 					{
 						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
@@ -5145,9 +4932,9 @@ static int rtw_p2p_prov_disc(struct net_
 			{
 				u16	wfd_devinfo_field = 0;
 
-				/* 	Commented by Albert 20120319 */
-				/* 	The first two bytes are the WFD device information field of WFD device information subelement. */
-				/* 	In big endian format. */
+				/*	Commented by Albert 20120319 */
+				/*	The first two bytes are the WFD device information field of WFD device information subelement. */
+				/*	In big endian format. */
 				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
 				if (wfd_devinfo_field & WFD_DEVINFO_SESSION_AVAIL)
 				{
@@ -5198,7 +4985,7 @@ static int rtw_p2p_prov_disc(struct net_
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_buddy_fwstate(padapter, _FW_LINKED))
 		{
-			/* 	Have to enter the power saving with the AP */
+			/*	Have to enter the power saving with the AP */
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 
 			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
@@ -5226,7 +5013,6 @@ static int rtw_p2p_prov_disc(struct net_
 		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
 #endif /*  CONFIG_CONCURRENT_MODE */
 
-
 	}
 	else
 	{
@@ -5237,26 +5023,25 @@ exit:
 	return ret;
 }
 
-/* 	Added by Albert 20110328 */
-/* 	This function is used to inform the driver the user had specified the pin code value or pbc */
-/* 	to application. */
+/*	Added by Albert 20110328 */
+/*	This function is used to inform the driver the user had specified the pin code value or pbc */
+/*	to application. */
 
 static int rtw_p2p_got_wpsinfo(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
 	struct rtw_adapter				*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
-	/* 	Added by Albert 20110328 */
-	/* 	if the input data is P2P_NO_WPSINFO -> reset the wpsinfo */
-	/* 	if the input data is P2P_GOT_WPSINFO_PEER_DISPLAY_PIN -> the utility just input the PIN code got from the peer P2P device. */
-	/* 	if the input data is P2P_GOT_WPSINFO_SELF_DISPLAY_PIN -> the utility just got the PIN code from itself. */
-	/* 	if the input data is P2P_GOT_WPSINFO_PBC -> the utility just determine to use the PBC */
+	/*	Added by Albert 20110328 */
+	/*	if the input data is P2P_NO_WPSINFO -> reset the wpsinfo */
+	/*	if the input data is P2P_GOT_WPSINFO_PEER_DISPLAY_PIN -> the utility just input the PIN code got from the peer P2P device. */
+	/*	if the input data is P2P_GOT_WPSINFO_SELF_DISPLAY_PIN -> the utility just got the PIN code from itself. */
+	/*	if the input data is P2P_GOT_WPSINFO_PBC -> the utility just determine to use the PBC */
 
 	if (*extra == '0')
 	{
@@ -5285,10 +5070,9 @@ static int rtw_p2p_got_wpsinfo(struct ne
 #endif /* CONFIG_P2P */
 
 static int rtw_p2p_set(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+		       struct iw_request_info *info,
+		       union iwreq_data *wrqu, char *extra)
 {
-
 	int ret = 0;
 #ifdef CONFIG_P2P
 
@@ -5326,9 +5110,9 @@ static int rtw_p2p_set(struct net_device
 	}
 	else if (!memcmp(extra, "intent =", 7))
 	{
-		/* 	Commented by Albert 2011/03/23 */
-		/* 	The wrqu->data.length will include the null character */
-		/* 	So, we will decrease 7 + 1 */
+		/*	Commented by Albert 2011/03/23 */
+		/*	The wrqu->data.length will include the null character */
+		/*	So, we will decrease 7 + 1 */
 		wrqu->data.length -= 8;
 		rtw_p2p_set_intent(dev, info, wrqu, &extra[7]);
 	}
@@ -5344,17 +5128,17 @@ static int rtw_p2p_set(struct net_device
 	}
 	else if (!memcmp(extra, "listen_ch =", 10))
 	{
-		/* 	Commented by Albert 2011/05/24 */
-		/* 	The wrqu->data.length will include the null character */
-		/* 	So, we will decrease (10 + 1) */
+		/*	Commented by Albert 2011/05/24 */
+		/*	The wrqu->data.length will include the null character */
+		/*	So, we will decrease (10 + 1) */
 		wrqu->data.length -= 11;
 		rtw_p2p_set_listen_ch(dev, info, wrqu, &extra[10]);
 	}
 	else if (!memcmp(extra, "op_ch =", 6))
 	{
-		/* 	Commented by Albert 2011/05/24 */
-		/* 	The wrqu->data.length will include the null character */
-		/* 	So, we will decrease (6 + 1) */
+		/*	Commented by Albert 2011/05/24 */
+		/*	The wrqu->data.length will include the null character */
+		/*	So, we will decrease (6 + 1) */
 		wrqu->data.length -= 7;
 		rtw_p2p_set_op_ch(dev, info, wrqu, &extra[6]);
 	}
@@ -5371,19 +5155,19 @@ static int rtw_p2p_set(struct net_device
 #ifdef CONFIG_WFD
 	else if (!memcmp(extra, "sa =", 3))
 	{
-		/* 	sa: WFD Session Available information */
+		/*	sa: WFD Session Available information */
 		wrqu->data.length -= 3;
 		rtw_p2p_set_sa(dev, info, wrqu, &extra[3]);
 	}
 	else if (!memcmp(extra, "pc =", 3))
 	{
-		/* 	pc: WFD Preferred Connection */
+		/*	pc: WFD Preferred Connection */
 		wrqu->data.length -= 3;
 		rtw_p2p_set_pc(dev, info, wrqu, &extra[3]);
 	}
 	else if (!memcmp(extra, "wfd_type =", 9))
 	{
-		/* 	Specify this device is Mircast source or sink */
+		/*	Specify this device is Mircast source or sink */
 		wrqu->data.length -= 9;
 		rtw_p2p_set_wfd_device_type(dev, info, wrqu, &extra[9]);
 	}
@@ -5400,10 +5184,9 @@ static int rtw_p2p_set(struct net_device
 }
 
 static int rtw_p2p_get(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+		       struct iw_request_info *info,
+		       union iwreq_data *wrqu, char *extra)
 {
-
 	int ret = 0;
 
 #ifdef CONFIG_P2P
@@ -5426,12 +5209,12 @@ static int rtw_p2p_get(struct net_device
 	} else if (!memcmp(wrqu->data.pointer, "req_cm", 6)) {
 		rtw_p2p_get_req_cm(dev, info, wrqu, extra);
 	} else if (!memcmp(wrqu->data.pointer, "peer_deva", 9)) {
-		/* 	Get the P2P device address when receiving the provision discovery request frame. */
+		/*	Get the P2P device address when receiving the provision discovery request frame. */
 		rtw_p2p_get_peer_devaddr(dev, info, wrqu, extra);
 	} else if (!memcmp(wrqu->data.pointer, "group_id", 8)) {
 		rtw_p2p_get_groupid(dev, info, wrqu, extra);
 	} else if (!memcmp(wrqu->data.pointer, "peer_deva_inv", 9)) {
-		/* 	Get the P2P device address when receiving the P2P Invitation request frame. */
+		/*	Get the P2P device address when receiving the P2P Invitation request frame. */
 		rtw_p2p_get_peer_devaddr_by_invitation(dev, info, wrqu, extra);
 	} else if (!memcmp((void const *)wrqu->data.pointer, "op_ch", 5)) {
 		rtw_p2p_get_op_ch(dev, info, wrqu, extra);
@@ -5507,8 +5290,8 @@ bad:
 }
 
 static int rtw_rereg_nd_name(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
 	struct rtw_adapter *padapter = rtw_netdev_priv(dev);
@@ -5651,7 +5434,6 @@ static int rtw_dbg_port(struct net_devic
 	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
-
 	pdata = (u32*)&wrqu->data;
 
 	val32 = *pdata;
@@ -5799,16 +5581,14 @@ static int rtw_dbg_port(struct net_devic
 					DBG_8192D("bSurpriseRemoved =%d, bDriverStopped =%d\n",
 						padapter->bSurpriseRemoved, padapter->bDriverStopped);
 					break;
-                                case 0x08:
-					{
-						struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
-						struct recv_priv  *precvpriv = &padapter->recvpriv;
-
-						DBG_8192D("free_xmitbuf_cnt =%d, free_xmitframe_cnt =%d, free_xmit_extbuf_cnt =%d\n",
-							pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt, pxmitpriv->free_xmit_extbuf_cnt);
-						DBG_8192D("rx_urb_pending_cn =%d\n", precvpriv->rx_pending_cnt);
-					}
-					break;
+				case 0x08: {
+					struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+					struct recv_priv  *precvpriv = &padapter->recvpriv;
+
+					DBG_8192D("free_xmitbuf_cnt =%d, free_xmitframe_cnt =%d, free_xmit_extbuf_cnt =%d\n",
+						pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt, pxmitpriv->free_xmit_extbuf_cnt);
+					DBG_8192D("rx_urb_pending_cn =%d\n", precvpriv->rx_pending_cnt);
+					break; }
 				case 0x09:
 					{
 						int i, j;
@@ -5851,7 +5631,6 @@ static int rtw_dbg_port(struct net_devic
 									DBG_8192D("dot118021XPrivacy = 0x%x\n", psta->dot118021XPrivacy);
 
 
-
 									for (j = 0;j<16;j++)
 									{
 										preorder_ctrl = &psta->recvreorder_ctrl[j];
@@ -5871,12 +5650,10 @@ static int rtw_dbg_port(struct net_devic
 					}
 					break;
 
-                                case 0x0c:/* dump rx packet */
-					{
-						DBG_8192D("dump rx packet (%d)\n", extra_arg);
-						/* pHalData->bDumpRxPkt = extra_arg; */
-						rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DUMP_RXPKT, &(extra_arg));
-					}
+				case 0x0c:/* dump rx packet */
+					DBG_8192D("dump rx packet (%d)\n", extra_arg);
+					/* pHalData->bDumpRxPkt = extra_arg; */
+					rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DUMP_RXPKT, &(extra_arg));
 					break;
 		#ifdef DBG_CONFIG_ERROR_DETECT
 				case 0x0f:
@@ -6022,7 +5799,6 @@ static int rtw_dbg_port(struct net_devic
 
 						DBG_8192D("dbg(0x664) = 0x%x\n", rtw_read32(padapter, 0x664));
 
-
 						DBG_8192D("\n");
 
 						DBG_8192D("dbg(0x430) = 0x%x\n", rtw_read32(padapter, 0x430));
@@ -6048,7 +5824,6 @@ static int rtw_dbg_port(struct net_devic
 			break;
 	}
 
-
 	return ret;
 }
 
@@ -6136,10 +5911,8 @@ static int wpa_set_param(struct net_devi
 	default:
 
 
-
 		ret = -EOPNOTSUPP;
 
-
 		break;
 
 	}
@@ -6210,7 +5983,7 @@ static int wpa_supplicant_ioctl(struct n
 
 	case IEEE_CMD_SET_WPA_IE:
 		/* ret = wpa_set_wpa_ie(dev, param, p->length); */
-		ret =  rtw_set_wpa_ie((struct rtw_adapter *)rtw_netdev_priv(dev), (char*)param->u.wpa_ie.data, (u16)param->u.wpa_ie.len);
+		ret =  rtw_set_wpa_ie((struct rtw_adapter *)rtw_netdev_priv(dev), (char *)param->u.wpa_ie.data, (u16)param->u.wpa_ie.len);
 		break;
 
 	case IEEE_CMD_SET_ENCRYPTION:
@@ -6263,14 +6036,12 @@ static u8 set_pairwise_key(struct rtw_ad
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SETSTAKEY_CMD_);
 
-
 	psetstakey_para->algorithm = (u8)psta->dot118021XPrivacy;
 
 	memcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);
 
 	memcpy(psetstakey_para->key, &psta->dot118021x_UncstKey, 16);
 
-
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
 exit:
@@ -6331,7 +6102,6 @@ static int set_group_key(struct rtw_adap
 	pcmd->rsp = NULL;
 	pcmd->rspsz = 0;
 
-
 	INIT_LIST_HEAD(&pcmd->list);
 
 	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
@@ -6361,7 +6131,6 @@ static int set_wep_key(struct rtw_adapte
 	return set_group_key(padapter, key, alg, keyid);
 }
 
-
 static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
 {
 	int ret = 0;
@@ -6416,7 +6185,6 @@ static int rtw_set_encryption(struct net
 		goto exit;
 	}
 
-
 	if (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta == NULL))
 	{
 		DBG_8192D("r871x_set_encryption, crypt.alg = WEP\n");
@@ -6432,7 +6200,6 @@ static int rtw_set_encryption(struct net
 			goto exit;
 		}
 
-
 		if (wep_key_len > 0)
 		{
 			wep_key_len = wep_key_len <= 5 ? 5 : 13;
@@ -6468,7 +6235,6 @@ static int rtw_set_encryption(struct net
 				psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
 			}
 
-
 			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
 
 			memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
@@ -6477,7 +6243,6 @@ static int rtw_set_encryption(struct net
 
 			set_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx);
 
-
 		}
 		else
 		{
@@ -6498,7 +6263,6 @@ static int rtw_set_encryption(struct net
 
 	}
 
-
 	if (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) /*  group key */
 	{
 		if (param->u.crypt.set_tx == 1)
@@ -6692,7 +6456,6 @@ static int rtw_set_beacon(struct net_dev
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	unsigned char *pbuf = param->u.bcn_ie.buf;
 
-
 	DBG_8192D("%s, len =%d\n", __func__, len);
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
@@ -6703,13 +6466,11 @@ static int rtw_set_beacon(struct net_dev
 	if ((pstapriv->max_num_sta>NUM_STA) || (pstapriv->max_num_sta<= 0))
 		pstapriv->max_num_sta = NUM_STA;
 
-
 	if (rtw_check_beacon_data(padapter, pbuf,  (len-12-2)) == _SUCCESS)/*  12 = param header, 2:no packed */
 		ret = 0;
 	else
 		ret = -EINVAL;
 
-
 	return ret;
 }
 
@@ -6773,7 +6534,6 @@ static int rtw_add_sta(struct net_device
 
 		memcpy(psta->bssrateset, param->u.add_sta.tx_supp_rates, 16);
 
-
 		/* check wmm cap. */
 		if (WLAN_STA_WME&flags)
 			psta->qos_option = 1;
@@ -6783,7 +6543,6 @@ static int rtw_add_sta(struct net_device
 		if (pmlmepriv->qospriv.qos_option == 0)
 			psta->qos_option = 0;
 
-
 #ifdef CONFIG_80211N_HT
 		/* chec 802.11n ht cap. */
 		if (WLAN_STA_HT&flags)
@@ -6801,10 +6560,8 @@ static int rtw_add_sta(struct net_device
 			psta->htpriv.ht_option = false;
 #endif
 
-
 		update_sta_info_apmode(padapter, psta);
 
-
 	}
 	else
 	{
@@ -6860,7 +6617,6 @@ static int rtw_del_sta(struct net_device
 		/* ret = -1; */
 	}
 
-
 	return ret;
 }
 
@@ -6924,7 +6680,6 @@ static int rtw_ioctl_get_sta_data(struct
 		psta_data->tx_bytes = psta->sta_stats.tx_bytes;
 		psta_data->tx_drops = psta->sta_stats.tx_drops;
 
-
 	}
 	else
 	{
@@ -7003,19 +6758,16 @@ static int rtw_set_wps_beacon(struct net
 
 	ie_len = len-12-2;/*  12 = param header, 2:no packed */
 
-
 	kfree(pmlmepriv->wps_beacon_ie);
 	pmlmepriv->wps_beacon_ie = NULL;
 
-	if (ie_len>0)
-	{
+	if (ie_len > 0) {
 		pmlmepriv->wps_beacon_ie = rtw_malloc(ie_len);
 		pmlmepriv->wps_beacon_ie_len = ie_len;
 		if (pmlmepriv->wps_beacon_ie == NULL) {
 			DBG_8192D("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 			return -EINVAL;
 		}
-
 		memcpy(pmlmepriv->wps_beacon_ie, param->u.bcn_ie.buf, ie_len);
 
 		update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, true);
@@ -7023,8 +6775,6 @@ static int rtw_set_wps_beacon(struct net
 		pmlmeext->bstart_bss = true;
 
 	}
-
-
 	return ret;
 }
 
@@ -7042,12 +6792,10 @@ static int rtw_set_wps_probe_resp(struct
 
 	ie_len = len-12-2;/*  12 = param header, 2:no packed */
 
-
 	kfree(pmlmepriv->wps_probe_resp_ie);
 	pmlmepriv->wps_probe_resp_ie = NULL;
 
-	if (ie_len>0)
-	{
+	if (ie_len > 0) {
 		pmlmepriv->wps_probe_resp_ie = rtw_malloc(ie_len);
 		pmlmepriv->wps_probe_resp_ie_len = ie_len;
 		if (pmlmepriv->wps_probe_resp_ie == NULL) {
@@ -7056,8 +6804,6 @@ static int rtw_set_wps_probe_resp(struct
 		}
 		memcpy(pmlmepriv->wps_probe_resp_ie, param->u.bcn_ie.buf, ie_len);
 	}
-
-
 	return ret;
 }
 
@@ -7075,7 +6821,6 @@ static int rtw_set_wps_assoc_resp(struct
 
 	ie_len = len-12-2;/*  12 = param header, 2:no packed */
 
-
 	kfree(pmlmepriv->wps_assoc_resp_ie);
 	pmlmepriv->wps_assoc_resp_ie = NULL;
 
@@ -7089,8 +6834,6 @@ static int rtw_set_wps_assoc_resp(struct
 
 		memcpy(pmlmepriv->wps_assoc_resp_ie, param->u.bcn_ie.buf, ie_len);
 	}
-
-
 	return ret;
 }
 
@@ -7150,9 +6893,7 @@ static int rtw_ioctl_acl_remove_sta(stru
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
 	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
-	{
 		return -EINVAL;
-	}
 
 	ret = rtw_acl_remove_sta(padapter, param->sta_addr);
 
@@ -7171,9 +6912,7 @@ static int rtw_ioctl_acl_add_sta(struct
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
 	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
-	{
 		return -EINVAL;
-	}
 
 	ret = rtw_acl_add_sta(padapter, param->sta_addr);
 
@@ -7212,7 +6951,6 @@ static int rtw_hostapd_ioctl(struct net_
 		goto out;
 	}
 
-
 	/* if (p->length < sizeof(struct ieee_param) || !p->pointer) { */
 	if (!p->pointer) {
 		ret = -EINVAL;
@@ -7220,118 +6958,68 @@ static int rtw_hostapd_ioctl(struct net_
 	}
 
 	param = (struct ieee_param *)rtw_malloc(p->length);
-	if (param == NULL)
-	{
+	if (param == NULL) {
 		ret = -ENOMEM;
 		goto out;
 	}
 
-	if (copy_from_user(param, p->pointer, p->length))
-	{
+	if (copy_from_user(param, p->pointer, p->length)) {
 		kfree(param);
 		ret = -EFAULT;
 		goto out;
 	}
-
-	/* DBG_8192D("%s, cmd =%d\n", __func__, param->cmd); */
-
-	switch (param->cmd)
-	{
-		case RTL871X_HOSTAPD_FLUSH:
-
-			ret = rtw_hostapd_sta_flush(dev);
-
-			break;
-
-		case RTL871X_HOSTAPD_ADD_STA:
-
-			ret = rtw_add_sta(dev, param);
-
-			break;
-
-		case RTL871X_HOSTAPD_REMOVE_STA:
-
-			ret = rtw_del_sta(dev, param);
-
-			break;
-
-		case RTL871X_HOSTAPD_SET_BEACON:
-
-			ret = rtw_set_beacon(dev, param, p->length);
-
-			break;
-
-		case RTL871X_SET_ENCRYPTION:
-
-			ret = rtw_set_encryption(dev, param, p->length);
-
-			break;
-
-		case RTL871X_HOSTAPD_GET_WPAIE_STA:
-
-			ret = rtw_get_sta_wpaie(dev, param);
-
-			break;
-
-		case RTL871X_HOSTAPD_SET_WPS_BEACON:
-
-			ret = rtw_set_wps_beacon(dev, param, p->length);
-
-			break;
-
-		case RTL871X_HOSTAPD_SET_WPS_PROBE_RESP:
-
-			ret = rtw_set_wps_probe_resp(dev, param, p->length);
-
-			break;
-
-		case RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP:
-
-			ret = rtw_set_wps_assoc_resp(dev, param, p->length);
-
-			break;
-
-		case RTL871X_HOSTAPD_SET_HIDDEN_SSID:
-
-			ret = rtw_set_hidden_ssid(dev, param, p->length);
-
-			break;
-
-		case RTL871X_HOSTAPD_GET_INFO_STA:
-
-			ret = rtw_ioctl_get_sta_data(dev, param, p->length);
-
-			break;
-
-		case RTL871X_HOSTAPD_SET_MACADDR_ACL:
-
-			ret = rtw_ioctl_set_macaddr_acl(dev, param, p->length);
-
-			break;
-
-		case RTL871X_HOSTAPD_ACL_ADD_STA:
-
-			ret = rtw_ioctl_acl_add_sta(dev, param, p->length);
-
-			break;
-
-		case RTL871X_HOSTAPD_ACL_REMOVE_STA:
-
-			ret = rtw_ioctl_acl_remove_sta(dev, param, p->length);
-
-			break;
-
-		default:
-			DBG_8192D("Unknown hostapd request: %d\n", param->cmd);
-			ret = -EOPNOTSUPP;
-			break;
-
+	switch (param->cmd) {
+	case RTL871X_HOSTAPD_FLUSH:
+		ret = rtw_hostapd_sta_flush(dev);
+		break;
+	case RTL871X_HOSTAPD_ADD_STA:
+		ret = rtw_add_sta(dev, param);
+		break;
+	case RTL871X_HOSTAPD_REMOVE_STA:
+		ret = rtw_del_sta(dev, param);
+		break;
+	case RTL871X_HOSTAPD_SET_BEACON:
+		ret = rtw_set_beacon(dev, param, p->length);
+		break;
+	case RTL871X_SET_ENCRYPTION:
+		ret = rtw_set_encryption(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_GET_WPAIE_STA:
+		ret = rtw_get_sta_wpaie(dev, param);
+		break;
+	case RTL871X_HOSTAPD_SET_WPS_BEACON:
+		ret = rtw_set_wps_beacon(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_SET_WPS_PROBE_RESP:
+		ret = rtw_set_wps_probe_resp(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP:
+		ret = rtw_set_wps_assoc_resp(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_SET_HIDDEN_SSID:
+		ret = rtw_set_hidden_ssid(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_GET_INFO_STA:
+		ret = rtw_ioctl_get_sta_data(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_SET_MACADDR_ACL:
+		ret = rtw_ioctl_set_macaddr_acl(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_ACL_ADD_STA:
+		ret = rtw_ioctl_acl_add_sta(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_ACL_REMOVE_STA:
+		ret = rtw_ioctl_acl_remove_sta(dev, param, p->length);
+		break;
+	default:
+		DBG_8192D("Unknown hostapd request: %d\n", param->cmd);
+		ret = -EOPNOTSUPP;
+		break;
 	}
 
 	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
 		ret = -EFAULT;
 
-
 	kfree(param);
 
 out:
@@ -7355,11 +7043,9 @@ static int rtw_wx_set_priv(struct net_de
 	int len = 0;
 	char *ext;
 	int i;
-
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point *dwrq = (struct iw_point*)awrq;
 
-	/* RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+rtw_wx_set_priv\n")); */
 	if (dwrq->length == 0)
 		return -EFAULT;
 	len = dwrq->length;
@@ -7371,14 +7057,8 @@ static int rtw_wx_set_priv(struct net_de
 		return -EFAULT;
 	}
 
-
-	/* RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, */
-	/* 	 ("rtw_wx_set_priv: %s req =%s\n", */
-	/* 	  dev->name, ext)); */
-
 	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
-	if (!(ext_dbg = rtw_vmalloc(len)))
-	{
+	if (!(ext_dbg = rtw_vmalloc(len))) {
 		rtw_vmfree(ext, len);
 		return -ENOMEM;
 	}
@@ -7387,8 +7067,7 @@ static int rtw_wx_set_priv(struct net_de
 	#endif
 
 	/* added for wps2.0 @20110524 */
-	if (dwrq->flags == 0x8766 && len > 8)
-	{
+	if (dwrq->flags == 0x8766 && len > 8) {
 		u32 cp_sz;
 		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 		u8 *probereq_wpsie = ext;
@@ -7404,8 +7083,7 @@ static int rtw_wx_set_priv(struct net_de
 
 			DBG_8192D("probe_req_wps_ielen =%d\n", cp_sz);
 
-			if (pmlmepriv->wps_probe_req_ie)
-			{
+			if (pmlmepriv->wps_probe_req_ie) {
 				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 				pmlmepriv->wps_probe_req_ie_len = 0;
 				kfree(pmlmepriv->wps_probe_req_ie);
@@ -7441,62 +7119,50 @@ static int rtw_wx_set_priv(struct net_de
 	i = rtw_android_cmdstr_to_num(ext);
 
 	switch (i) {
-		case ANDROID_WIFI_CMD_START :
-			indicate_wx_custom_event(padapter, "START");
-			break;
-		case ANDROID_WIFI_CMD_STOP :
-			indicate_wx_custom_event(padapter, "STOP");
-			break;
-		case ANDROID_WIFI_CMD_RSSI :
-			{
-				struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-				struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
-
-				if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
-					sprintf(ext, "%s rssi %d", pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
-				} else {
-					sprintf(ext, "OK");
-				}
-			}
-			break;
-		case ANDROID_WIFI_CMD_LINKSPEED :
-			{
-				u16 mbps = rtw_get_cur_max_rate(padapter)/10;
-				sprintf(ext, "LINKSPEED %d", mbps);
-			}
-			break;
-		case ANDROID_WIFI_CMD_MACADDR :
-			sprintf(ext, "MACADDR = %pM", dev->dev_addr);
-			break;
-		case ANDROID_WIFI_CMD_SCAN_ACTIVE :
-			{
-				/* rtw_set_scan_mode(padapter, SCAN_ACTIVE); */
-				sprintf(ext, "OK");
-			}
-			break;
-		case ANDROID_WIFI_CMD_SCAN_PASSIVE :
-			{
-				/* rtw_set_scan_mode(padapter, SCAN_PASSIVE); */
-				sprintf(ext, "OK");
-			}
-			break;
-
-		case ANDROID_WIFI_CMD_COUNTRY :
-			{
-				char country_code[10];
-				sscanf(ext, "%*s %s", country_code);
-				rtw_set_country(padapter, country_code);
-				sprintf(ext, "OK");
-			}
-			break;
-		default :
-			#ifdef  CONFIG_DEBUG_RTW_WX_SET_PRIV
-			DBG_8192D("%s: %s unknowned req =%s\n", __func__,
-				dev->name, ext_dbg);
-			#endif
+	case ANDROID_WIFI_CMD_START :
+		indicate_wx_custom_event(padapter, "START");
+		break;
+	case ANDROID_WIFI_CMD_STOP :
+		indicate_wx_custom_event(padapter, "STOP");
+		break;
+	case ANDROID_WIFI_CMD_RSSI : {
+		struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+		struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
 
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+			sprintf(ext, "%s rssi %d", pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
+		else
 			sprintf(ext, "OK");
+		break; }
+	case ANDROID_WIFI_CMD_LINKSPEED : {
+		u16 mbps = rtw_get_cur_max_rate(padapter)/10;
+		sprintf(ext, "LINKSPEED %d", mbps);
+		break; }
+	case ANDROID_WIFI_CMD_MACADDR :
+		sprintf(ext, "MACADDR = %pM", dev->dev_addr);
+		break;
+	case ANDROID_WIFI_CMD_SCAN_ACTIVE :
+		/* rtw_set_scan_mode(padapter, SCAN_ACTIVE); */
+		sprintf(ext, "OK");
+		break;
+	case ANDROID_WIFI_CMD_SCAN_PASSIVE :
+		/* rtw_set_scan_mode(padapter, SCAN_PASSIVE); */
+		sprintf(ext, "OK");
+		break;
+
+	case ANDROID_WIFI_CMD_COUNTRY : {
+		char country_code[10];
+		sscanf(ext, "%*s %s", country_code);
+		rtw_set_country(padapter, country_code);
+		sprintf(ext, "OK");
+		break; }
+	default :
+		#ifdef  CONFIG_DEBUG_RTW_WX_SET_PRIV
+		DBG_8192D("%s: %s unknowned req =%s\n", __func__,
+			dev->name, ext_dbg);
+		#endif
 
+		sprintf(ext, "OK");
 	}
 
 	if (copy_to_user(dwrq->pointer, ext, min(dwrq->length, (u16)(strlen(ext)+1))))
@@ -7508,7 +7174,6 @@ static int rtw_wx_set_priv(struct net_de
 	#endif
 #endif /* end of CONFIG_ANDROID */
 
-
 FREE_EXT:
 
 	rtw_vmfree(ext, len);
@@ -7517,7 +7182,7 @@ FREE_EXT:
 	#endif
 
 	/* DBG_8192D("rtw_wx_set_priv: (SIOCSIWPRIV) %s ret =%d\n", */
-	/* 		dev->name, ret); */
+	/*		dev->name, ret); */
 
 	return ret;
 }
@@ -7548,11 +7213,11 @@ static int rtw_mp_efuse_get(struct net_d
 
 	i = 0;
 	/* mac 16 "00e04c871200" rmap, 00, 2 */
-	while ((token = strsep (&pch,","))!= NULL)
-	{
-			if (i>2) break;
-			tmp[i] = token;
-			i++;
+	while ((token = strsep(&pch,",")) != NULL) {
+		if (i > 2)
+			 break;
+		tmp[i] = token;
+		i++;
 	}
 
 	if (strcmp(tmp[0],"realmap") == 0) {
@@ -7567,15 +7232,13 @@ static int rtw_mp_efuse_get(struct net_d
 			DBG_8192D("\t  rtw_efuse_map_read : Fail\n");
 			return -EFAULT;
 		}
-		memset(extra, '\0', sizeof(extra));
+		memset(extra, '\0', 1);
 		DBG_8192D("\tOFFSET\tVALUE(hex)\n");
 		sprintf(extra, "%s\n", extra);
-		for (i = 0; i < EFUSE_MAP_SIZE; i += 16)
-		{
+		for (i = 0; i < EFUSE_MAP_SIZE; i += 16) {
 			DBG_8192D("\t0x%02x\t", i);
 			sprintf(extra, "%s \t0x%02x\t", extra, i);
-			for (j = 0; j < 8; j++)
-			{
+			for (j = 0; j < 8; j++) {
 				DBG_8192D("%02X ", data[i+j]);
 				sprintf(extra, "%s %02X", extra, data[i+j]);
 			}
@@ -7592,8 +7255,7 @@ static int rtw_mp_efuse_get(struct net_d
 		wrqu->length = strlen(extra);
 
 		return 0;
-	}
-	else if (strcmp(tmp[0],"rmap") == 0) {
+	} else if (strcmp(tmp[0],"rmap") == 0) {
 		if (tmp[1]== NULL || tmp[2]== NULL) return	-EINVAL;
 		/*  rmap addr cnts */
 		addr = simple_strtoul(tmp[1], &ptmp, 16);
@@ -7601,7 +7263,8 @@ static int rtw_mp_efuse_get(struct net_d
 		DBG_8192D("addr = %x\n" , addr);
 
 		cnts = simple_strtoul(tmp[2], &ptmp, 10);
-		if (cnts == 0) return -EINVAL;
+		if (cnts == 0)
+			return -EINVAL;
 
 		DBG_8192D("cnts = %d\n" , cnts);
 		/* memset(extra, '\0', wrqu->data.length); */
@@ -7613,14 +7276,11 @@ static int rtw_mp_efuse_get(struct net_d
 		}
 
 		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL)
-		{
 			DBG_8192D("rtw_efuse_access error\n");
-		}
-		else {
+		else
 			DBG_8192D("rtw_efuse_access ok\n");
-		}
 
-		memset(extra, '\0', sizeof(extra));
+		memset(extra, '\0', 1);
 		for (i = 0; i < cnts; i ++) {
 			DBG_8192D("0x%02x", data[i]);
 			sprintf(extra, "%s 0x%02X", extra, data[i]);
@@ -7633,38 +7293,33 @@ static int rtw_mp_efuse_get(struct net_d
 		DBG_8192D("extra = %s ", extra);
 
 		return 0;
-	}
-	else if (strcmp(tmp[0],"realraw") == 0) {
+	} else if (strcmp(tmp[0],"realraw") == 0) {
 		addr = 0;
 		mapLen = EFUSE_MAX_SIZE;
 
-		if (rtw_efuse_access(padapter, false, addr, mapLen, rawdata) == _FAIL)
-		{
+		if (rtw_efuse_access(padapter, false, addr, mapLen, rawdata) == _FAIL) {
 			DBG_8192D("\t  rtw_efuse_map_read : Fail\n");
 			return -EFAULT;
-		} else
-		{
+		} else {
 			DBG_8192D("\t  rtw_efuse_access raw ok\n");
 		}
 
-		memset(extra, '\0', sizeof(extra));
-		for (i = 0; i<mapLen; i++) {
+		memset(extra, '\0', 1);
+		for (i = 0; i < mapLen; i++) {
 			DBG_8192D(" %02x", rawdata[i]);
 			sprintf(extra, "%s %02x", extra, rawdata[i]);
 
 			if ((i & 0xF) == 0xF) {
 				DBG_8192D("\n\t");
 				sprintf(extra, "%s\n\t", extra);
-			}
-			else if ((i & 0x7) == 0x7) {
+			} else if ((i & 0x7) == 0x7) {
 				DBG_8192D("\t");
 				sprintf(extra, "%s\t", extra);
 			}
 		}
 		wrqu->length = strlen(extra);
 		return 0;
-	}
-	else if (strcmp(tmp[0],"mac") == 0) {
+	} else if (strcmp(tmp[0],"mac") == 0) {
 		if (tmp[1]== NULL || tmp[2]== NULL) return	-EINVAL;
 		addr = 0x19;
 		cnts = 6;
@@ -7674,13 +7329,10 @@ static int rtw_mp_efuse_get(struct net_d
 			return -EFAULT;
 		}
 		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL)
-		{
 			DBG_8192D("rtw_efuse_access error\n");
-		}
-		else {
+		else
 			DBG_8192D("rtw_efuse_access ok\n");
-		}
-		memset(extra, '\0', sizeof(extra));
+		memset(extra, '\0', 1);
 		for (i = 0; i < cnts; i ++) {
 			DBG_8192D("0x%02x", data[i]);
 			sprintf(extra, "%s 0x%02X", extra, data[i+j]);
@@ -7689,9 +7341,9 @@ static int rtw_mp_efuse_get(struct net_d
 		}
 		wrqu->length = strlen(extra);
 		return 0;
-	}
-	else if (strcmp(tmp[0],"vidpid") == 0) {
-		if (tmp[1]== NULL || tmp[2]== NULL) return	-EINVAL;
+	} else if (strcmp(tmp[0],"vidpid") == 0) {
+		if (tmp[1]== NULL || tmp[2]== NULL)
+			return	-EINVAL;
 		addr = 0x0c;
 		cnts = 4;
 		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
@@ -7699,14 +7351,12 @@ static int rtw_mp_efuse_get(struct net_d
 			DBG_8192D("(addr + cnts parameter error\n");
 			return -EFAULT;
 		}
-		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL)
-		{
+		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL) {
 			DBG_8192D("rtw_efuse_access error\n");
-		}
-		else {
+		} else {
 			DBG_8192D("rtw_efuse_access ok\n");
 		}
-		memset(extra, '\0', sizeof(extra));
+		memset(extra, '\0', 1);
 		for (i = 0; i < cnts; i ++) {
 			DBG_8192D("0x%02x", data[i]);
 			sprintf(extra, "%s 0x%02X", extra, data[i+j]);
@@ -7715,16 +7365,14 @@ static int rtw_mp_efuse_get(struct net_d
 		}
 		wrqu->length = strlen(extra);
 		return 0;
-	}
-	else if (strcmp(tmp[0],"ableraw") == 0) {
+	} else if (strcmp(tmp[0],"ableraw") == 0) {
 		efuse_GetCurrentSize(padapter,&raw_cursize);
 		raw_maxsize = efuse_GetMaxSize(padapter);
 		sprintf(extra, "%s : [available raw size] = %d", extra, raw_maxsize-raw_cursize);
 		wrqu->length = strlen(extra);
 
 		return 0;
-	} else
-	{
+	} else {
 		 sprintf(extra, "%s : Command not found\n", extra);
 		  wrqu->length = strlen(extra);
 		  return 0;
@@ -7738,7 +7386,7 @@ static int rtw_mp_efuse_set(struct net_d
 			union iwreq_data *wdata, char *extra)
 {
 	struct iw_point *wrqu = (struct iw_point *)wdata;
-	struct rtw_adapter * padapter = rtw_netdev_priv(dev);
+	struct rtw_adapter *padapter = rtw_netdev_priv(dev);
 
 	u8 buffer[40];
 	u32 i, jj, kk;
@@ -7753,8 +7401,7 @@ static int rtw_mp_efuse_set(struct net_d
 	DBG_8192D("%s: in =%s\n", __func__, extra);
 
 	i = 0;
-	while ((token = strsep (&pch,","))!= NULL)
-	{
+	while ((token = strsep (&pch,","))!= NULL) {
 		if (i>2) break;
 		tmp[i] = token;
 		i++;
@@ -7763,39 +7410,38 @@ static int rtw_mp_efuse_set(struct net_d
 	/*  tmp[0],[1],[2] */
 	/*  wmap, addr, 00e04c871200 */
 	if (strcmp(tmp[0],"wmap") == 0) {
-		 if (tmp[1]== NULL || tmp[2]== NULL) return	-EINVAL;
-			if (! strlen(tmp[2])/2 > 1) return -EFAULT;
+		 if (tmp[1]== NULL || tmp[2]== NULL)
+			return	-EINVAL;
+		if (!strlen(tmp[2])/2 > 1)
+			return -EFAULT;
 
-			addr = simple_strtoul(tmp[1], &ptmp, 16);
-			addr = addr & 0xFF;
-			DBG_8192D("addr = %x\n" , addr);
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+		addr = addr & 0xFF;
+		DBG_8192D("addr = %x\n" , addr);
 
-			cnts = strlen(tmp[2])/2;
-			if (cnts == 0) return -EFAULT;
+		cnts = strlen(tmp[2])/2;
+		if (cnts == 0) return -EFAULT;
 
-			DBG_8192D("cnts = %d\n" , cnts);
-			DBG_8192D("target data = %s\n" , tmp[2]);
+		DBG_8192D("cnts = %d\n" , cnts);
+		DBG_8192D("target data = %s\n" , tmp[2]);
 
-			for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
-			{
-				setdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+ 1]);
-			}
+		for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
+			setdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+ 1]);
 
-			EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
 
-			if ((addr + cnts) > max_available_size) {
-						DBG_8192D("parameter error\n");
-						return -EFAULT;
-			}
-			if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
-					DBG_8192D("rtw_efuse_map_write error\n");
+		if ((addr + cnts) > max_available_size) {
+					DBG_8192D("parameter error\n");
 					return -EFAULT;
-			} else
-			   DBG_8192D("rtw_efuse_map_write ok\n");
+		}
+		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
+				DBG_8192D("rtw_efuse_map_write error\n");
+				return -EFAULT;
+		} else
+		   DBG_8192D("rtw_efuse_map_write ok\n");
 
 		return 0;
-	}
-	else if (strcmp(tmp[0],"wraw") == 0) {
+	} else if (strcmp(tmp[0],"wraw") == 0) {
 			 if (tmp[1]== NULL || tmp[2]== NULL) return	-EINVAL;
 			 if (! strlen(tmp[2])/2 > 1) return -EFAULT;
 			addr = simple_strtoul(tmp[1], &ptmp, 16);
@@ -7809,19 +7455,16 @@ static int rtw_mp_efuse_set(struct net_d
 			DBG_8192D("target data = %s\n" , tmp[2]);
 
 			for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
-			{
 					setrawdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+ 1]);
-			}
 
 			if (rtw_efuse_access(padapter, true, addr, cnts, setrawdata) == _FAIL) {
 					DBG_8192D("\t  rtw_efuse_map_read : Fail\n");
 						return -EFAULT;
-			} else
+			} else {
 			  DBG_8192D("\t  rtw_efuse_access raw ok\n");
-
-					return 0;
-		}
-	else if (strcmp(tmp[0],"mac") == 0) {
+			}
+			return 0;
+		} else if (strcmp(tmp[0],"mac") == 0) {
 			 if (tmp[1]== NULL || tmp[2]== NULL) return	-EINVAL;
 			/* mac, 00e04c871200 */
 				addr = 0x19;
@@ -7835,16 +7478,14 @@ static int rtw_mp_efuse_set(struct net_d
 				DBG_8192D("target data = %s\n" , tmp[1]);
 
 				for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
-				{
 					setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk+ 1]);
-				}
 
 				EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
 
 				if ((addr + cnts) > max_available_size) {
 						DBG_8192D("parameter error\n");
 						return -EFAULT;
-					}
+				}
 				if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
 					DBG_8192D("rtw_efuse_map_write error\n");
 					return -EFAULT;
@@ -7852,8 +7493,7 @@ static int rtw_mp_efuse_set(struct net_d
 					DBG_8192D("rtw_efuse_map_write ok\n");
 
 			return 0;
-		}
-		else if (strcmp(tmp[0],"vidpid") == 0) {
+		} else if (strcmp(tmp[0],"vidpid") == 0) {
 			if (tmp[1]== NULL || tmp[2]== NULL)
 				return	-EINVAL;
 				/*  pidvid, da0b7881 */
@@ -7865,9 +7505,7 @@ static int rtw_mp_efuse_set(struct net_d
 			DBG_8192D("target data = %s\n" , tmp[1]);
 
 			for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
-				{
 				setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk+ 1]);
-			}
 
 			EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
 
@@ -7905,13 +7543,9 @@ static int rtw_wfd_tdls_enable(struct ne
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	if (extra[0] == '0')
-	{
 		padapter->wdinfo.wfd_tdls_enable = 0;
-	}
 	else
-	{
 		padapter->wdinfo.wfd_tdls_enable = 1;
-	}
 
 #endif /* CONFIG_WFD */
 #endif /* CONFIG_TDLS */
@@ -7932,12 +7566,9 @@ static int rtw_tdls_weaksec(struct net_d
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	if (extra[0] == '0')
-	{
+	if (extra[0] == '0') {
 		padapter->wdinfo.wfd_tdls_weaksec = 0;
-	}
-	else
-	{
+	} else {
 		padapter->wdinfo.wfd_tdls_weaksec = 1;
 	}
 #endif
@@ -7945,7 +7576,6 @@ static int rtw_tdls_weaksec(struct net_d
 	return ret;
 }
 
-
 static int rtw_tdls_enable(struct net_device *dev,
 				struct iw_request_info *info,
 				union iwreq_data *wrqu, char *extra)
@@ -7967,37 +7597,30 @@ static int rtw_tdls_enable(struct net_de
 
 	memset(tdls_sta, 0x00, sizeof(tdls_sta));
 
-	if (extra[0] == '0')
-	{
+	if (extra[0] == '0') {
 		ptdlsinfo->enable = 0;
 
 		if (pstapriv->asoc_sta_count == 1)
 			return ret;
 
 		spin_lock_bh(&pstapriv->sta_hash_lock);
-		for (index = 0; index< NUM_STA; index++)
-		{
+		for (index = 0; index< NUM_STA; index++) {
 			phead = &(pstapriv->sta_hash[index]);
 			plist = get_next(phead);
 
-			while ((rtw_end_of_queue_search(phead, plist)) == false)
-			{
+			while ((rtw_end_of_queue_search(phead, plist)) == false) {
 				psta = LIST_CONTAINOR(plist, struct sta_info , hash_list);
 
 				plist = get_next(plist);
 
 				if (psta->tdls_sta_state != TDLS_STATE_NONE)
-				{
 					memcpy(tdls_sta[index], psta->hwaddr, ETH_ALEN);
-				}
 			}
 		}
 		spin_unlock_bh(&pstapriv->sta_hash_lock);
 
-		for (index = 0; index< NUM_STA; index++)
-		{
-			if (!!memcmp(tdls_sta[index], empty_hwaddr, ETH_ALEN))
-			{
+		for (index = 0; index< NUM_STA; index++) {
+			if (!!memcmp(tdls_sta[index], empty_hwaddr, ETH_ALEN)) {
 				DBG_8192D("issue tear down to %pM\n", tdls_sta[index]);
 				issue_tdls_teardown(padapter, tdls_sta[index]);
 			}
@@ -8030,21 +7653,16 @@ static int rtw_tdls_setup(struct net_dev
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3) {
+	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3)
 		mac_addr[i]= key_2char2num(*(extra+j), *(extra+j+1));
-	}
 
 #ifdef CONFIG_WFD
-	if (_AES_ != padapter->securitypriv.dot11PrivacyAlgrthm)
-	{
-		/* 	Weak Security situation with AP. */
-		if (0 == pwdinfo->wfd_tdls_weaksec)
-		{
-			/* 	Can't send the tdls setup request out!! */
+	if (_AES_ != padapter->securitypriv.dot11PrivacyAlgrthm) {
+		/*	Weak Security situation with AP. */
+		if (0 == pwdinfo->wfd_tdls_weaksec) {
+			/*	Can't send the tdls setup request out!! */
 			DBG_8192D("[%s] Current link is not AES, SKIP sending the tdls setup request!!\n", __func__);
-		}
-		else
-		{
+		} else {
 			issue_tdls_setup_req(padapter, mac_addr);
 		}
 	}
@@ -8073,14 +7691,12 @@ static int rtw_tdls_teardown(struct net_
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3) {
+	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3)
 		mac_addr[i]= key_2char2num(*(extra+j), *(extra+j+1));
-	}
 
 	ptdls_sta = rtw_get_stainfo(&(padapter->stapriv), mac_addr);
 
-	if (ptdls_sta != NULL)
-	{
+	if (ptdls_sta != NULL) {
 		ptdls_sta->stat_code = _RSON_TDLS_TEAR_UN_RSN_;
 		issue_tdls_teardown(padapter, mac_addr);
 	}
@@ -8126,9 +7742,8 @@ static int rtw_tdls_ch_switch (struct ne
 
 	DBG_8192S("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3) {
+	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3)
 		mac_addr[i]= key_2char2num(*(extra+j), *(extra+j+1));
-	}
 
 	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
 	if (ptdls_sta == NULL)
@@ -8158,9 +7773,8 @@ static int rtw_tdls_pson(struct net_devi
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3) {
+	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3)
 		mac_addr[i]= key_2char2num(*(extra+j), *(extra+j+1));
-	}
 
 	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
 
@@ -8187,9 +7801,8 @@ static int rtw_tdls_psoff(struct net_dev
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3) {
+	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3)
 		mac_addr[i]= key_2char2num(*(extra+j), *(extra+j+1));
-	}
 
 	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
 
@@ -8216,13 +7829,9 @@ static int rtw_tdls_setip(struct net_dev
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length - 1);
 
-
-	while (i < 4)
-	{
-		for (j = 0; j < 4; j++)
-		{
-			if (*(extra + j + tag) == '.' || *(extra + j + tag) == '\0')
-			{
+	while (i < 4) {
+		for (j = 0; j < 4; j++) {
+			if (*(extra + j + tag) == '.' || *(extra + j + tag) == '\0') {
 				if (j == 1)
 					pwfd_info->ip_address[i]= convert_ip_addr('0', '0', *(extra+(j-1)+tag));
 				if (j == 2)
@@ -8265,13 +7874,11 @@ static int rtw_tdls_getip(struct net_dev
 
 	sprintf(extra, "\n\n%u.%u.%u.%u\n",
 		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1],
-		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]
-		);
+		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]);
 
 	DBG_8192D("[%s] IP =%u.%u.%u.%u\n", __func__,
 		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1],
-		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]
-		);
+		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]);
 
 	wrqu->data.length = strlen(extra);
 
@@ -8282,10 +7889,9 @@ static int rtw_tdls_getip(struct net_dev
 }
 
 static int rtw_tdls_getport(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *extra)
 {
-
 	int ret = 0;
 
 #ifdef CONFIG_TDLS
@@ -8310,8 +7916,8 @@ static int rtw_tdls_getport(struct net_d
 
 /* WFDTDLS, for sigma test */
 static int rtw_tdls_dis_result(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
@@ -8325,8 +7931,7 @@ static int rtw_tdls_dis_result(struct ne
 
 	DBG_8192D("[%s]\n", __func__);
 
-	if (ptdlsinfo->dev_discovered == 1)
-	{
+	if (ptdlsinfo->dev_discovered == 1) {
 		sprintf(extra, "\n\nDis = 1\n");
 		ptdlsinfo->dev_discovered = 0;
 	}
@@ -8341,10 +7946,9 @@ static int rtw_tdls_dis_result(struct ne
 
 /* WFDTDLS, for sigma test */
 static int rtw_wfd_tdls_status(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
 {
-
 	int ret = 0;
 
 #ifdef CONFIG_TDLS
@@ -8357,13 +7961,9 @@ static int rtw_wfd_tdls_status(struct ne
 	DBG_8192D("[%s]\n", __func__);
 
 	if (ptdlsinfo->setup_state == TDLS_LINKED_STATE)
-	{
 		sprintf(extra, "\n\nStatus = 1\n");
-	}
 	else
-	{
 		sprintf(extra, "\n\nStatus = 0\n");
-	}
 
 	wrqu->data.length = strlen(extra);
 
@@ -8394,13 +7994,6 @@ static int rtw_tdls_ch_switch_off(struct
 	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
 
 	ptdls_sta->tdls_sta_state |= TDLS_SW_OFF_STATE;
-/*
-	if ((ptdls_sta->tdls_sta_state & TDLS_AT_OFF_CH_STATE) && (ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE)) {
-		pmlmeinfo->tdls_candidate_ch = pmlmeext->cur_channel;
-		issue_tdls_ch_switch_req(padapter, mac_addr);
-		DBG_8192D("issue tdls ch switch req back to base channel\n");
-	}
-*/
 
 #endif /* CONFIG_TDLS */
 
@@ -8408,8 +8001,8 @@ static int rtw_tdls_ch_switch_off(struct
 }
 
 static int rtw_tdls(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
+		    struct iw_request_info *info,
+		    union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
 
@@ -8417,75 +8010,53 @@ static int rtw_tdls(struct net_device *d
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
 	DBG_8192D("[%s] extra = %s\n", __func__, extra);
-	/* 	WFD Sigma will use the tdls enable command to let the driver know we want to test the tdls now! */
-	if (!memcmp(extra, "wfdenable =", 10))
-	{
+	/*	WFD Sigma will use the tdls enable command to let the driver know we want to test the tdls now! */
+	if (!memcmp(extra, "wfdenable =", 10)) {
 		wrqu->data.length -= 10;
 		rtw_wfd_tdls_enable(dev, info, wrqu, &extra[10]);
 		return ret;
-	}
-	else if (!memcmp(extra, "weaksec =", 8))
-	{
+	} else if (!memcmp(extra, "weaksec =", 8)) {
 		wrqu->data.length -= 8;
 		rtw_tdls_weaksec(dev, info, wrqu, &extra[8]);
 		return ret;
-	}
-	else if (!memcmp(extra, "tdlsenable =", 11))
-	{
+	} else if (!memcmp(extra, "tdlsenable =", 11)) {
 		wrqu->data.length -= 11;
 		rtw_tdls_enable(dev, info, wrqu, &extra[11]);
 		return ret;
 	}
 
-	if (padapter->tdlsinfo.enable == 0)
-	{
+	if (padapter->tdlsinfo.enable == 0) {
 		DBG_8192D("tdls haven't enabled\n");
 		return 0;
 	}
 
-	if (!memcmp(extra, "setup =", 6))
-	{
+	if (!memcmp(extra, "setup =", 6)) {
 		wrqu->data.length -= 6;
 		rtw_tdls_setup(dev, info, wrqu, &extra[6]);
-	}
-	else if (!memcmp(extra, "tear =", 5))
-	{
+	} else if (!memcmp(extra, "tear =", 5)) {
 		wrqu->data.length -= 5;
 		rtw_tdls_teardown(dev, info, wrqu, &extra[5]);
-	}
-	else if (!memcmp(extra, "dis =", 4))
-	{
+	} else if (!memcmp(extra, "dis =", 4)) {
 		wrqu->data.length -= 4;
 		rtw_tdls_discovery(dev, info, wrqu, &extra[4]);
-	}
-	else if (!memcmp(extra, "sw =", 3))
-	{
+	} else if (!memcmp(extra, "sw =", 3)) {
 		wrqu->data.length -= 3;
 		rtw_tdls_ch_switch (dev, info, wrqu, &extra[3]);
-	}
-	else if (!memcmp(extra, "swoff =", 6))
-	{
+	} else if (!memcmp(extra, "swoff =", 6)) {
 		wrqu->data.length -= 6;
 		rtw_tdls_ch_switch_off(dev, info, wrqu, &extra[6]);
-	}
-	else if (!memcmp(extra, "pson =", 5))
-	{
+	} else if (!memcmp(extra, "pson =", 5)) {
 		wrqu->data.length -= 5;
 		rtw_tdls_pson(dev, info, wrqu, &extra[5]);
-	}
-	else if (!memcmp(extra, "psoff =", 6))
-	{
+	} else if (!memcmp(extra, "psoff =", 6)) {
 		wrqu->data.length -= 6;
 		rtw_tdls_psoff(dev, info, wrqu, &extra[6]);
 	}
 #ifdef CONFIG_WFD
-	else if (!memcmp(extra, "setip =", 6))
-	{
+	else if (!memcmp(extra, "setip =", 6)) {
 		wrqu->data.length -= 6;
 		rtw_tdls_setip(dev, info, wrqu, &extra[6]);
-	}
-	else if (!memcmp(extra, "tprobe =", 6))
-	{
+	} else if (!memcmp(extra, "tprobe =", 6)) {
 		issue_tunneled_probe_req((struct rtw_adapter *)rtw_netdev_priv(dev));
 	}
 #endif /* CONFIG_WFD */
@@ -8495,44 +8066,33 @@ static int rtw_tdls(struct net_device *d
 	return ret;
 }
 
-
 static int rtw_tdls_get(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
 {
-	int ret = 0;
-
 #ifdef CONFIG_WFD
 
-	DBG_8192D("[%s] extra = %s\n", __func__, (char*) wrqu->data.pointer);
+	DBG_8192D("[%s] extra = %s\n", __func__, (char *)wrqu->data.pointer);
 
 	if (!memcmp(wrqu->data.pointer, "ip", 2))
-	{
 		rtw_tdls_getip(dev, info, wrqu, extra);
-	}
 	if (!memcmp(wrqu->data.pointer, "port", 4))
-	{
 		rtw_tdls_getport(dev, info, wrqu, extra);
-	}
 
 	/* WFDTDLS, for sigma test */
 	if (!memcmp(wrqu->data.pointer, "dis", 3))
-	{
 		rtw_tdls_dis_result(dev, info, wrqu, extra);
-	}
 	if (!memcmp(wrqu->data.pointer, "status", 6))
-	{
 		rtw_wfd_tdls_status(dev, info, wrqu, extra);
-	}
 
 #endif /* CONFIG_WFD */
 
-	return ret;
+	return 0;
 }
 
 static int rtw_pm_set(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+		      struct iw_request_info *info,
+		      union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
 	unsigned	mode = 0;
@@ -8554,8 +8114,8 @@ static int rtw_pm_set(struct net_device
 
 #ifdef CONFIG_WOWLAN
 static int rtw_wowlan_ctrl(struct net_device *dev,
-	struct iw_request_info *info,
-	union iwreq_data *wrqu, char *extra)
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
 	struct oid_par_priv	oid_par;
@@ -8567,10 +8127,6 @@ static int rtw_wowlan_ctrl(struct net_de
 
 	struct iw_point *p = &wrqu->data;
 
-	/* DBG_8192D("+rtw_wowlan_ctrl\n"); */
-
-	/* mutex_lock(&ioctl_mutex); */
-
 	if ((!p->length) || (!p->pointer)) {
 		ret = -EINVAL;
 		goto _rtw_wowlan_ctrl_exit;
@@ -8579,7 +8135,7 @@ static int rtw_wowlan_ctrl(struct net_de
 	pparmbuf = NULL;
 	bset = (u8)(p->flags & 0xFFFF);
 	len = p->length;
-	pparmbuf = (u8*)rtw_malloc(len);
+	pparmbuf = (u8 *)rtw_malloc(len);
 	if (pparmbuf == NULL) {
 		ret = -ENOMEM;
 		goto _rtw_wowlan_ctrl_exit;
@@ -8591,7 +8147,7 @@ static int rtw_wowlan_ctrl(struct net_de
 	}
 	poidparam = (struct wowlan_ioctl_param *)pparmbuf;
 
-	if (padapter->pwrctrlpriv.bSupportRemoteWakeup == false) {
+	if (!padapter->pwrctrlpriv.bSupportRemoteWakeup) {
 		ret = -EPERM;
 		DBG_8192D("+rtw_wowlan_ctrl: Device didn't support the remote wakeup!!\n");
 		goto _rtw_wowlan_ctrl_exit_free;
@@ -8601,55 +8157,48 @@ static int rtw_wowlan_ctrl(struct net_de
 	DBG_8192D("rtw_wowlan_ctrl: subcode [%d], len[%d], buffer_len[%d]\r\n",
 		  poidparam->subcode, poidparam->len, len);
 
-	if (copy_to_user(p->pointer, pparmbuf, len)) {
+	if (copy_to_user(p->pointer, pparmbuf, len))
 		ret = -EFAULT;
-	}
-
 
 _rtw_wowlan_ctrl_exit_free:
 	kfree(pparmbuf);
 _rtw_wowlan_ctrl_exit:
 
-
 	return ret;
 }
 #endif /* CONFIG_WOWLAN */
 
 #ifdef CONFIG_INTEL_WIDI
 static int rtw_widi_set(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
 {
-	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
 	process_intel_widi_cmd(padapter, extra);
 
-	return ret;
+	return 0;
 }
 
 static int rtw_widi_set_probe_request(struct net_device *dev,
-                               struct iw_request_info *info,
-                               union iwreq_data *wrqu, char *extra)
+				      struct iw_request_info *info,
+				      union iwreq_data *wrqu, char *extra)
 {
-	int	ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	u8	*pbuf = NULL;
-	struct rtw_adapter	*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
 	pbuf = rtw_malloc(sizeof(l2_msg_t));
 	if (pbuf) {
 		memcpy(pbuf, wrqu->data.pointer, wrqu->data.length);
 		intel_widi_wk_cmd(padapter, INTEL_WIDI_ISSUE_PROB_WK, pbuf);
 	}
-	return ret;
+	return 0;
 }
 
 #endif /*  CONFIG_INTEL_WIDI */
 
-static int rtw_test(
-	struct net_device *dev,
-	struct iw_request_info *info,
-	union iwreq_data *wrqu, char *extra)
+static int rtw_test(struct net_device *dev, struct iw_request_info *info,
+		    union iwreq_data *wrqu, char *extra)
 {
 	DBG_8192D("%s\n", __func__);
 	return 0;
@@ -8661,90 +8210,88 @@ int rtw_ioctl(struct net_device *dev, st
 	struct iwreq *wrq = (struct iwreq *)rq;
 	int ret = 0;
 
-	switch (cmd)
-	{
-	    case RTL_IOCTL_WPA_SUPPLICANT:
-			ret = wpa_supplicant_ioctl(dev, &wrq->u.data);
-			break;
+	switch (cmd) {
+	case RTL_IOCTL_WPA_SUPPLICANT:
+		ret = wpa_supplicant_ioctl(dev, &wrq->u.data);
+		break;
 #ifdef CONFIG_AP_MODE
-		case RTL_IOCTL_HOSTAPD:
-			ret = rtw_hostapd_ioctl(dev, &wrq->u.data);
-			break;
+	case RTL_IOCTL_HOSTAPD:
+		ret = rtw_hostapd_ioctl(dev, &wrq->u.data);
+		break;
 #ifdef CONFIG_NO_WIRELESS_HANDLERS
-		case SIOCSIWMODE:
-			ret = rtw_wx_set_mode(dev, NULL, &wrq->u, NULL);
-			break;
+	case SIOCSIWMODE:
+		ret = rtw_wx_set_mode(dev, NULL, &wrq->u, NULL);
+		break;
 #endif
 #endif
-		case (SIOCDEVPRIVATE+1):
-			ret = rtw_android_priv_cmd(dev, rq, cmd);
-			break;
-	    default:
-			ret = -EOPNOTSUPP;
-			break;
+	case (SIOCDEVPRIVATE+1):
+		ret = rtw_android_priv_cmd(dev, rq, cmd);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
 	}
 
 	return ret;
 }
 
-static iw_handler rtw_handlers[] =
-{
-	NULL,					/* SIOCSIWCOMMIT */
-	rtw_wx_get_name,		/* SIOCGIWNAME */
-	dummy,					/* SIOCSIWNWID */
-	dummy,					/* SIOCGIWNWID */
-	rtw_wx_set_freq,		/* SIOCSIWFREQ */
-	rtw_wx_get_freq,		/* SIOCGIWFREQ */
-	rtw_wx_set_mode,		/* SIOCSIWMODE */
-	rtw_wx_get_mode,		/* SIOCGIWMODE */
-	dummy,					/* SIOCSIWSENS */
-	rtw_wx_get_sens,		/* SIOCGIWSENS */
-	NULL,					/* SIOCSIWRANGE */
-	rtw_wx_get_range,		/* SIOCGIWRANGE */
-	rtw_wx_set_priv,		/* SIOCSIWPRIV */
-	NULL,					/* SIOCGIWPRIV */
-	NULL,					/* SIOCSIWSTATS */
-	NULL,					/* SIOCGIWSTATS */
-	dummy,					/* SIOCSIWSPY */
-	dummy,					/* SIOCGIWSPY */
-	NULL,					/* SIOCGIWTHRSPY */
-	NULL,					/* SIOCWIWTHRSPY */
+static iw_handler rtw_handlers[] = {
+	NULL,			/* SIOCSIWCOMMIT */
+	rtw_wx_get_name,	/* SIOCGIWNAME */
+	dummy,			/* SIOCSIWNWID */
+	dummy,			/* SIOCGIWNWID */
+	rtw_wx_set_freq,	/* SIOCSIWFREQ */
+	rtw_wx_get_freq,	/* SIOCGIWFREQ */
+	rtw_wx_set_mode,	/* SIOCSIWMODE */
+	rtw_wx_get_mode,	/* SIOCGIWMODE */
+	dummy,			/* SIOCSIWSENS */
+	rtw_wx_get_sens,	/* SIOCGIWSENS */
+	NULL,			/* SIOCSIWRANGE */
+	rtw_wx_get_range,	/* SIOCGIWRANGE */
+	rtw_wx_set_priv,	/* SIOCSIWPRIV */
+	NULL,			/* SIOCGIWPRIV */
+	NULL,			/* SIOCSIWSTATS */
+	NULL,			/* SIOCGIWSTATS */
+	dummy,			/* SIOCSIWSPY */
+	dummy,			/* SIOCGIWSPY */
+	NULL,			/* SIOCGIWTHRSPY */
+	NULL,			/* SIOCWIWTHRSPY */
 	rtw_wx_set_wap,		/* SIOCSIWAP */
 	rtw_wx_get_wap,		/* SIOCGIWAP */
-	rtw_wx_set_mlme,		/* request MLME operation; uses struct iw_mlme */
-	dummy,					/* SIOCGIWAPLIST -- depricated */
-	rtw_wx_set_scan,		/* SIOCSIWSCAN */
-	rtw_wx_get_scan,		/* SIOCGIWSCAN */
-	rtw_wx_set_essid,		/* SIOCSIWESSID */
-	rtw_wx_get_essid,		/* SIOCGIWESSID */
-	dummy,					/* SIOCSIWNICKN */
-	rtw_wx_get_nick,		/* SIOCGIWNICKN */
-	NULL,					/* -- hole -- */
-	NULL,					/* -- hole -- */
-	rtw_wx_set_rate,		/* SIOCSIWRATE */
-	rtw_wx_get_rate,		/* SIOCGIWRATE */
-	rtw_wx_set_rts,			/* SIOCSIWRTS */
-	rtw_wx_get_rts,			/* SIOCGIWRTS */
-	rtw_wx_set_frag,		/* SIOCSIWFRAG */
-	rtw_wx_get_frag,		/* SIOCGIWFRAG */
-	dummy,					/* SIOCSIWTXPOW */
-	dummy,					/* SIOCGIWTXPOW */
-	dummy,					/* SIOCSIWRETRY */
-	rtw_wx_get_retry,		/* SIOCGIWRETRY */
-	rtw_wx_set_enc,			/* SIOCSIWENCODE */
-	rtw_wx_get_enc,			/* SIOCGIWENCODE */
-	dummy,					/* SIOCSIWPOWER */
-	rtw_wx_get_power,		/* SIOCGIWPOWER */
-	NULL,					/*---hole---*/
-	NULL,					/*---hole---*/
-	rtw_wx_set_gen_ie,		/* SIOCSIWGENIE */
-	NULL,					/* SIOCGWGENIE */
-	rtw_wx_set_auth,		/* SIOCSIWAUTH */
-	NULL,					/* SIOCGIWAUTH */
-	rtw_wx_set_enc_ext,		/* SIOCSIWENCODEEXT */
-	NULL,					/* SIOCGIWENCODEEXT */
-	rtw_wx_set_pmkid,		/* SIOCSIWPMKSA */
-	NULL,					/*---hole---*/
+	rtw_wx_set_mlme,	/* request MLME op; uses struct iw_mlme */
+	dummy,			/* SIOCGIWAPLIST -- depricated */
+	rtw_wx_set_scan,	/* SIOCSIWSCAN */
+	rtw_wx_get_scan,	/* SIOCGIWSCAN */
+	rtw_wx_set_essid,	/* SIOCSIWESSID */
+	rtw_wx_get_essid,	/* SIOCGIWESSID */
+	dummy,			/* SIOCSIWNICKN */
+	rtw_wx_get_nick,	/* SIOCGIWNICKN */
+	NULL,			/* -- hole -- */
+	NULL,			/* -- hole -- */
+	rtw_wx_set_rate,	/* SIOCSIWRATE */
+	rtw_wx_get_rate,	/* SIOCGIWRATE */
+	rtw_wx_set_rts,		/* SIOCSIWRTS */
+	rtw_wx_get_rts,		/* SIOCGIWRTS */
+	rtw_wx_set_frag,	/* SIOCSIWFRAG */
+	rtw_wx_get_frag,	/* SIOCGIWFRAG */
+	dummy,			/* SIOCSIWTXPOW */
+	dummy,			/* SIOCGIWTXPOW */
+	dummy,			/* SIOCSIWRETRY */
+	rtw_wx_get_retry,	/* SIOCGIWRETRY */
+	rtw_wx_set_enc,		/* SIOCSIWENCODE */
+	rtw_wx_get_enc,		/* SIOCGIWENCODE */
+	dummy,			/* SIOCSIWPOWER */
+	rtw_wx_get_power,	/* SIOCGIWPOWER */
+	NULL,			/*---hole---*/
+	NULL,			/*---hole---*/
+	rtw_wx_set_gen_ie,	/* SIOCSIWGENIE */
+	NULL,			/* SIOCGWGENIE */
+	rtw_wx_set_auth,	/* SIOCSIWAUTH */
+	NULL,			/* SIOCGIWAUTH */
+	rtw_wx_set_enc_ext,	/* SIOCSIWENCODEEXT */
+	NULL,			/* SIOCGIWENCODEEXT */
+	rtw_wx_set_pmkid,	/* SIOCSIWPMKSA */
+	NULL,			/*---hole---*/
 };
 
 static const struct iw_priv_args rtw_private_args[] = {
@@ -8803,7 +8350,8 @@ static const struct iw_priv_args rtw_pri
 	},
 	{
 		SIOCIWFIRSTPRIV + 0xD,
-		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "rfr"
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, IW_PRIV_TYPE_CHAR |
+		IW_PRIV_SIZE_FIXED | IFNAMSIZ, "rfr"
 	},
 #ifdef CONFIG_WOWLAN
 	{
@@ -8816,7 +8364,9 @@ static const struct iw_priv_args rtw_pri
 	},
 	{
 		SIOCIWFIRSTPRIV + 0x11,
-		IW_PRIV_TYPE_CHAR | P2P_PRIVATE_IOCTL_SET_LEN, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | P2P_PRIVATE_IOCTL_SET_LEN , "p2p_get"
+		IW_PRIV_TYPE_CHAR | P2P_PRIVATE_IOCTL_SET_LEN,
+		IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED |
+		P2P_PRIVATE_IOCTL_SET_LEN , "p2p_get"
 	},
 	{
 		SIOCIWFIRSTPRIV + 0x12, 0, 0, "NULL"
@@ -8831,17 +8381,21 @@ static const struct iw_priv_args rtw_pri
 	},
 	{
 		SIOCIWFIRSTPRIV + 0x15,
-		IW_PRIV_TYPE_CHAR | P2P_PRIVATE_IOCTL_SET_LEN, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | P2P_PRIVATE_IOCTL_SET_LEN , "tdls_get"
+		IW_PRIV_TYPE_CHAR | P2P_PRIVATE_IOCTL_SET_LEN,
+		IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED |
+		P2P_PRIVATE_IOCTL_SET_LEN, "tdls_get"
 	},
 	{
 		SIOCIWFIRSTPRIV + 0x16,
 		IW_PRIV_TYPE_CHAR | 64, 0, "pm_set"
 	},
 
-	{SIOCIWFIRSTPRIV + 0x18, IW_PRIV_TYPE_CHAR | IFNAMSIZ , 0 , "rereg_nd_name"},
+	{SIOCIWFIRSTPRIV + 0x18, IW_PRIV_TYPE_CHAR | IFNAMSIZ , 0 ,
+	 "rereg_nd_name"},
 
 	{SIOCIWFIRSTPRIV + 0x1A, IW_PRIV_TYPE_CHAR | 128, 0, "efuse_set"},
-	{SIOCIWFIRSTPRIV + 0x1B, IW_PRIV_TYPE_CHAR | 128, IW_PRIV_TYPE_CHAR |IW_PRIV_SIZE_FIXED |0x700 ,"efuse_get"},
+	{SIOCIWFIRSTPRIV + 0x1B, IW_PRIV_TYPE_CHAR | 128, IW_PRIV_TYPE_CHAR |
+	 IW_PRIV_SIZE_FIXED | 0x700, "efuse_get"},
 	{
 		SIOCIWFIRSTPRIV + 0x1D,
 		IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 0x7FF, "test"
@@ -8858,77 +8412,74 @@ static const struct iw_priv_args rtw_pri
 #endif /*  CONFIG_INTEL_WIDI */
 };
 
-static iw_handler rtw_private_handler[] =
-{
-	rtw_wx_write32,					/* 0x00 */
-	rtw_wx_read32,					/* 0x01 */
-	rtw_drvext_hdl,					/* 0x02 */
-	rtw_mp_ioctl_hdl,				/* 0x03 */
+static iw_handler rtw_private_handler[] = {
+	rtw_wx_write32,			/* 0x00 */
+	rtw_wx_read32,			/* 0x01 */
+	rtw_drvext_hdl,			/* 0x02 */
+	rtw_mp_ioctl_hdl,		/* 0x03 */
 
 /*  for MM DTV platform */
-	rtw_get_ap_info,					/* 0x04 */
+	rtw_get_ap_info,		/* 0x04 */
 
-	rtw_set_pid,						/* 0x05 */
-	rtw_wps_start,					/* 0x06 */
+	rtw_set_pid,			/* 0x05 */
+	rtw_wps_start,			/* 0x06 */
 
-	rtw_wx_get_sensitivity,			/* 0x07 */
+	rtw_wx_get_sensitivity,		/* 0x07 */
 	rtw_wx_set_mtk_wps_probe_ie,	/* 0x08 */
-	rtw_wx_set_mtk_wps_ie,			/* 0x09 */
+	rtw_wx_set_mtk_wps_ie,		/* 0x09 */
 
 /*  Set Channel depend on the country code */
-	rtw_wx_set_channel_plan,		/* 0x0A */
+	rtw_wx_set_channel_plan,	/* 0x0A */
 
-	rtw_dbg_port,					/* 0x0B */
-	rtw_wx_write_rf,					/* 0x0C */
-	rtw_wx_read_rf,					/* 0x0D */
+	rtw_dbg_port,			/* 0x0B */
+	rtw_wx_write_rf,		/* 0x0C */
+	rtw_wx_read_rf,			/* 0x0D */
 
 #ifdef CONFIG_WOWLAN
-	rtw_wowlan_ctrl,					/* 0x0E */
+	rtw_wowlan_ctrl,		/* 0x0E */
 #else
-	rtw_wx_priv_null,				/* 0x0E */
+	rtw_wx_priv_null,		/* 0x0E */
 #endif /* CONFIG_WOWLAN */
-	rtw_wx_priv_null,				/* 0x0F */
+	rtw_wx_priv_null,		/* 0x0F */
 
-	rtw_p2p_set,					/* 0x10 */
-	rtw_p2p_get,					/* 0x11 */
-	NULL,							/* 0x12 */
-	rtw_p2p_get2,					/* 0x13 */
-
-	rtw_tdls,						/* 0x14 */
-	rtw_tdls_get,					/* 0x15 */
-
-	rtw_pm_set,						/* 0x16 */
-	rtw_wx_priv_null,				/* 0x17 */
-	rtw_rereg_nd_name,				/* 0x18 */
-	rtw_wx_priv_null,				/* 0x19 */
-
-	rtw_mp_efuse_set,				/* 0x1A */
-	rtw_mp_efuse_get,				/* 0x1B */
-	NULL,							/*  0x1C is reserved for hostapd */
-	rtw_test	,						/*  0x1D */
+	rtw_p2p_set,			/* 0x10 */
+	rtw_p2p_get,			/* 0x11 */
+	NULL,				/* 0x12 */
+	rtw_p2p_get2,			/* 0x13 */
+
+	rtw_tdls,			/* 0x14 */
+	rtw_tdls_get,			/* 0x15 */
+
+	rtw_pm_set,			/* 0x16 */
+	rtw_wx_priv_null,		/* 0x17 */
+	rtw_rereg_nd_name,		/* 0x18 */
+	rtw_wx_priv_null,		/* 0x19 */
+
+	rtw_mp_efuse_set,		/* 0x1A */
+	rtw_mp_efuse_get,		/* 0x1B */
+	NULL,				/*  0x1C is reserved for hostapd */
+	rtw_test	,		/*  0x1D */
 #ifdef CONFIG_INTEL_WIDI
-	rtw_widi_set,					/* 0x1E */
-	rtw_widi_set_probe_request,		/* 0x1F */
+	rtw_widi_set,			/* 0x1E */
+	rtw_widi_set_probe_request,	/* 0x1F */
 #endif /*  CONFIG_INTEL_WIDI */
 };
 
 #if WIRELESS_EXT >= 17
 static struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)
 {
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_statistics *piwstats =&padapter->iwstats;
+	struct rtw_adapter *padapter =
+		(struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct iw_statistics *piwstats = &padapter->iwstats;
 	int tmp_level = 0;
 	int tmp_qual = 0;
 	int tmp_noise = 0;
 
-	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) != true)
-	{
+	if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {
 		piwstats->qual.qual = 0;
 		piwstats->qual.level = 0;
 		piwstats->qual.noise = 0;
-		/* DBG_8192D("No link  level:%d, qual:%d, noise:%d\n", tmp_level, tmp_qual, tmp_noise); */
-	}
-	else {
+	} else {
 		#ifdef CONFIG_SIGNAL_DISPLAY_DBM
 		tmp_level = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);
 		#else
@@ -8937,7 +8488,6 @@ static struct iw_statistics *rtw_get_wir
 
 		tmp_qual = padapter->recvpriv.signal_qual;
 		tmp_noise = padapter->recvpriv.noise;
-		/* DBG_8192D("level:%d, qual:%d, noise:%d, rssi (%d)\n", tmp_level, tmp_qual, tmp_noise, padapter->recvpriv.rssi); */
 
 		piwstats->qual.level = tmp_level;
 		piwstats->qual.qual = tmp_qual;
@@ -8957,15 +8507,15 @@ static struct iw_statistics *rtw_get_wir
 #endif
 
 #ifdef CONFIG_WIRELESS_EXT
-struct iw_handler_def rtw_handlers_def =
-{
+struct iw_handler_def rtw_handlers_def = {
 	.standard = rtw_handlers,
 	.num_standard = sizeof(rtw_handlers) / sizeof(iw_handler),
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)) || defined(CONFIG_WEXT_PRIV)
 	.private = rtw_private_handler,
 	.private_args = (struct iw_priv_args *)rtw_private_args,
 	.num_private = sizeof(rtw_private_handler) / sizeof(iw_handler),
-	.num_private_args = sizeof(rtw_private_args) / sizeof(struct iw_priv_args),
+	.num_private_args = sizeof(rtw_private_args) /
+			    sizeof(struct iw_priv_args),
 #endif
 #if WIRELESS_EXT >= 17
 	.get_wireless_stats = rtw_get_wireless_stats,
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -845,7 +845,12 @@ static unsigned int rtw_classify8021d(st
 	return dscp >> 5;
 }
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 12, 0))
 static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb)
+#else
+static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb,
+			    void *accel)
+#endif
 {
 	struct rtw_adapter	*padapter = rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -907,7 +912,7 @@ int rtw_init_netdev_name(struct net_devi
 
 #ifdef CONFIG_EASY_REPLACEMENT
 	struct net_device	*TargetNetdev = NULL;
-	struct rtw_adapter			*TargetAdapter = NULL;
+	struct rtw_adapter			*target_adapter = NULL;
 	struct net		*devnet = NULL;
 
 	if (padapter->bDongle == 1)
@@ -924,17 +929,17 @@ int rtw_init_netdev_name(struct net_devi
 #endif
 		if (TargetNetdev) {
 			DBG_8192D("Force onboard module driver disappear !!!\n");
-			TargetAdapter = rtw_netdev_priv(TargetNetdev);
-			TargetAdapter->DriverState = DRIVER_DISAPPEAR;
+			target_adapter = rtw_netdev_priv(TargetNetdev);
+			target_adapter->DriverState = DRIVER_DISAPPEAR;
 
-			padapter->pid[0] = TargetAdapter->pid[0];
-			padapter->pid[1] = TargetAdapter->pid[1];
-			padapter->pid[2] = TargetAdapter->pid[2];
+			padapter->pid[0] = target_adapter->pid[0];
+			padapter->pid[1] = target_adapter->pid[1];
+			padapter->pid[2] = target_adapter->pid[2];
 
 			dev_put(TargetNetdev);
 			unregister_netdev(TargetNetdev);
 
-			if (TargetAdapter->chip_type == padapter->chip_type)
+			if (target_adapter->chip_type == padapter->chip_type)
 				rtw_proc_remove_one(TargetNetdev);
 
 			padapter->DriverState = DRIVER_REPLACE_DONGLE;
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -1104,7 +1104,7 @@ static struct rtw_adapter *rtw_usb_if1_i
 		goto free_hal_data;
 	}
 
-	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-drv_init - Adapter->bDriverStopped=%d, Adapter->bSurpriseRemoved=%d\n",padapter->bDriverStopped, padapter->bSurpriseRemoved));
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-drv_init - adapter->bDriverStopped=%d, adapter->bSurpriseRemoved=%d\n",padapter->bDriverStopped, padapter->bSurpriseRemoved));
 	DBG_8192D("bDriverStopped:%d, bSurpriseRemoved:%d, bup:%d, hw_init_completed:%d\n"
 		,padapter->bDriverStopped
 		,padapter->bSurpriseRemoved
@@ -1342,20 +1342,20 @@ module_exit(rtw_drv_halt);
 #ifdef CONFIG_WOWLAN
 #ifdef CONFIG_WOWLAN_MANUAL
 
-int rtw_resume_toshiba(struct rtw_adapter * Adapter)
+int rtw_resume_toshiba(struct rtw_adapter * adapter)
 {
 	struct dvobj_priv *pdvobjpriv;
-	pdvobjpriv = adapter_to_dvobj(Adapter);
+	pdvobjpriv = adapter_to_dvobj(adapter);
 
 	rtw_resume(pdvobjpriv->pusbintf);
 	return 0;
 }
 
-int rtw_suspend_toshiba(struct rtw_adapter * Adapter)
+int rtw_suspend_toshiba(struct rtw_adapter * adapter)
 {
 	pm_message_t msg;
 	struct dvobj_priv *pdvobjpriv;
-	pdvobjpriv = adapter_to_dvobj(Adapter);
+	pdvobjpriv = adapter_to_dvobj(adapter);
 	msg.event=0;
 	/* for Toshiba only, they should call rtw_suspend before suspend */
 	rtw_suspend(pdvobjpriv->pusbintf, msg);

From 618660ad46a5fe1f671ea3adaa77229cd2e72b6a Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sat, 15 Mar 2014 11:49:26 -0500
Subject: [PATCH 258/390] Remove CONFIG_P2P_PS

This variable is never selected.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_cmd.c      |  10 ---
 core/rtw_mlme.c     |  10 ---
 core/rtw_mlme_ext.c |  18 +----
 core/rtw_p2p.c      | 189 ----------------------------------------------------
 core/rtw_pwrctrl.c  |  33 +++------
 hal/rtl8192d_cmd.c  | 105 -----------------------------
 hal/rtl8192d_dm.c   |  12 +---
 hal/usb_halinit.c   |   8 ---
 include/rtw_mlme.h  |  12 ----
 include/rtw_p2p.h   |   6 --
 include/wifi.h      |  19 ------
 11 files changed, 13 insertions(+), 409 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -408,11 +408,6 @@ u8 rtw_sitesurvey_cmd(struct rtw_adapter
 	if (check_fwstate(pmlmepriv, _FW_LINKED))
 		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SCAN, 1);
 
-#ifdef CONFIG_P2P_PS
-	if (check_fwstate(pmlmepriv, _FW_LINKED))
-		p2p_ps_wk_cmd(padapter, P2P_PS_SCAN, 1);
-#endif /*  CONFIG_P2P_PS */
-
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL)
 		return _FAIL;
@@ -1904,11 +1899,6 @@ u8 rtw_drvextra_cmd_hdl(struct rtw_adapt
 	case LPS_CTRL_WK_CID:
 		lps_ctrl_wk_hdl(padapter, (u8)pdrvextra_cmd->type_size);
 		break;
-#ifdef CONFIG_P2P_PS
-	case P2P_PS_WK_CID:
-		p2p_ps_wk_hdl(padapter, pdrvextra_cmd->type_size);
-		break;
-#endif /*  CONFIG_P2P_PS */
 	case P2P_PROTO_WK_CID:
 		/*	I used the type_size as the type command */
 		p2p_protocol_wk_hdl(padapter, pdrvextra_cmd->type_size);
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -1026,12 +1026,6 @@ void rtw_surveydone_event_callback(struc
 
 	spin_unlock_bh(&pmlmepriv->lock);
 
-#ifdef CONFIG_P2P_PS
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
-		p2p_ps_wk_cmd(adapter, P2P_PS_SCAN_DONE, 0);
-	}
-#endif /*  CONFIG_P2P_PS */
-
 	rtw_os_xmit_schedule(adapter);
 #ifdef CONFIG_CONCURRENT_MODE
 	rtw_os_xmit_schedule(adapter->pbuddy_adapter);
@@ -1212,10 +1206,6 @@ void rtw_indicate_disconnect(struct rtw_
 		rtw_led_control(padapter, LED_CTL_NO_LINK);
 		rtw_clear_scan_deny(padapter);
 	}
-#ifdef CONFIG_P2P_PS
-	p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
-#endif /*  CONFIG_P2P_PS */
-
 #ifdef CONFIG_WOWLAN
 	if (padapter->pwrctrlpriv.wowlan_mode == false)
 #endif /* CONFIG_WOWLAN */
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -923,17 +923,8 @@ unsigned int OnBeacon(struct rtw_adapter
 		if (pmlmeinfo->state & WIFI_FW_AUTH_NULL) {
 			/* check the vendor of the assoc AP */
 			pmlmeinfo->assoc_AP_vendor =
-			    check_assoc_AP(pframe +
-					   sizeof(struct
-						  ieee80211_hdr_3addr),
-					   len -
-					   sizeof(struct
-						  ieee80211_hdr_3addr));
-#ifdef CONFIG_P2P_PS
-			/*  do P2P PS Before link ? , ToDo */
-			/*process_p2p_ps_ie(adapt, (pframe + WLAN_HDR_A3_LEN), (len - WLAN_HDR_A3_LEN)); */
-#endif /*  CONFIG_P2P_PS */
-
+			    check_assoc_AP(pframe + sizeof(struct ieee80211_hdr_3addr),
+					   len - sizeof(struct ieee80211_hdr_3addr));
 			/* update TSF Value */
 			update_TSF(pmlmeext, pframe, len);
 
@@ -974,11 +965,6 @@ unsigned int OnBeacon(struct rtw_adapter
 					update_beacon_info(adapt, pframe,
 							   len, psta);
 				}
-#ifdef CONFIG_P2P_PS
-				process_p2p_ps_ie(adapt,
-						  (pframe + WLAN_HDR_A3_LEN),
-						  (len - WLAN_HDR_A3_LEN));
-#endif /* CONFIG_P2P_PS */
 			}
 		} else if ((pmlmeinfo->state & 0x03) == WIFI_FW_ADHOC_STATE) {
 			psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -2093,195 +2093,6 @@ void p2p_protocol_wk_hdl(struct rtw_adap
 
 }
 
-#ifdef CONFIG_P2P_PS
-void process_p2p_ps_ie(struct rtw_adapter *padapter, u8 *IEs, u32 IELength)
-{
-	u8 *ies;
-	u32 ies_len;
-	u8 *p2p_ie;
-	u32	p2p_ielen = 0;
-	u8 noa_attr[MAX_P2P_IE_LEN] = {0x00};/*  NoA length should be n*(13) + 2 */
-	u32	attr_contentlen = 0;
-
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	u8 find_p2p = false, find_p2p_ps = false;
-	u8 noa_offset, noa_num, noa_index;
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		return;
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (padapter->iface_type != IFACE_PORT0)
-		return;
-#endif
-	if (IELength <= _BEACON_IE_OFFSET_)
-		return;
-
-	ies = IEs + _BEACON_IE_OFFSET_;
-	ies_len = IELength - _BEACON_IE_OFFSET_;
-
-	p2p_ie = rtw_get_p2p_ie(ies, ies_len, NULL, &p2p_ielen);
-
-	while (p2p_ie) {
-		find_p2p = true;
-		/*  Get Notice of Absence IE. */
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_NOA, noa_attr, &attr_contentlen)) {
-			find_p2p_ps = true;
-			noa_index = noa_attr[0];
-
-			if ((pwdinfo->p2p_ps_mode == P2P_PS_NONE) ||
-			    (noa_index != pwdinfo->noa_index)) {
-				/*  if index change, driver should reconfigure related setting. */
-				pwdinfo->noa_index = noa_index;
-				pwdinfo->opp_ps = noa_attr[1] >> 7;
-				pwdinfo->ctwindow = noa_attr[1] & 0x7F;
-
-				noa_offset = 2;
-				noa_num = 0;
-				/*  NoA length should be n*(13) + 2 */
-				if (attr_contentlen > 2) {
-					while (noa_offset < attr_contentlen) {
-						/* memcpy(&wifidirect_info->noa_count[noa_num], &noa_attr[noa_offset], 1); */
-						pwdinfo->noa_count[noa_num] = noa_attr[noa_offset];
-						noa_offset += 1;
-
-						memcpy(&pwdinfo->noa_duration[noa_num], &noa_attr[noa_offset], 4);
-						noa_offset += 4;
-
-						memcpy(&pwdinfo->noa_interval[noa_num], &noa_attr[noa_offset], 4);
-						noa_offset += 4;
-
-						memcpy(&pwdinfo->noa_start_time[noa_num], &noa_attr[noa_offset], 4);
-						noa_offset += 4;
-
-						noa_num++;
-					}
-				}
-				pwdinfo->noa_num = noa_num;
-
-				if (pwdinfo->opp_ps == 1) {
-					pwdinfo->p2p_ps_mode = P2P_PS_CTWINDOW;
-					/*  driver should wait LPS for entering CTWindow */
-					if (padapter->pwrctrlpriv.bFwCurrentInPSMode == true)
-						p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 1);
-				} else if (pwdinfo->noa_num > 0) {
-					pwdinfo->p2p_ps_mode = P2P_PS_NOA;
-					p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 1);
-				} else if (pwdinfo->p2p_ps_mode > P2P_PS_NONE) {
-					p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
-				}
-			}
-			break; /*  find target, just break. */
-		}
-
-		/* Get the next P2P IE */
-		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len - (p2p_ie - ies + p2p_ielen), NULL, &p2p_ielen);
-	}
-
-	if (find_p2p == true) {
-		if ((pwdinfo->p2p_ps_mode > P2P_PS_NONE) && (find_p2p_ps == false))
-			p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
-	}
-
-}
-
-void p2p_ps_wk_hdl(struct rtw_adapter *padapter, u8 p2p_ps_state)
-{
-	struct pwrctrl_priv		*pwrpriv = &padapter->pwrctrlpriv;
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	switch (p2p_ps_state) {
-	case P2P_PS_DISABLE:
-		pwdinfo->p2p_ps_state = p2p_ps_state;
-
-		rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_P2P_PS_OFFLOAD, (u8 *)(&p2p_ps_state));
-
-		pwdinfo->noa_index = 0;
-		pwdinfo->ctwindow = 0;
-		pwdinfo->opp_ps = 0;
-		pwdinfo->noa_num = 0;
-		pwdinfo->p2p_ps_mode = P2P_PS_NONE;
-		if (padapter->pwrctrlpriv.bFwCurrentInPSMode == true) {
-			if (pwrpriv->smart_ps == 0) {
-				pwrpriv->smart_ps = 2;
-				rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&(padapter->pwrctrlpriv.pwr_mode)));
-			}
-		}
-		break;
-	case P2P_PS_ENABLE:
-		if (pwdinfo->p2p_ps_mode > P2P_PS_NONE) {
-			pwdinfo->p2p_ps_state = p2p_ps_state;
-
-			if (pwdinfo->ctwindow > 0) {
-				if (pwrpriv->smart_ps != 0) {
-					pwrpriv->smart_ps = 0;
-					DBG_8192D("%s(): Enter CTW, change SmartPS\n", __func__);
-					rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&(padapter->pwrctrlpriv.pwr_mode)));
-				}
-			}
-			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_P2P_PS_OFFLOAD, (u8 *)(&p2p_ps_state));
-		}
-		break;
-	case P2P_PS_SCAN:
-	case P2P_PS_SCAN_DONE:
-	case P2P_PS_ALLSTASLEEP:
-		if (pwdinfo->p2p_ps_mode > P2P_PS_NONE) {
-			pwdinfo->p2p_ps_state = p2p_ps_state;
-			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_P2P_PS_OFFLOAD, (u8 *)(&p2p_ps_state));
-		}
-		break;
-	default:
-		break;
-	}
-
-}
-
-u8 p2p_ps_wk_cmd(struct rtw_adapter *padapter, u8 p2p_ps_state, u8 enqueue)
-{
-	struct cmd_obj	*ph2c;
-	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
-#ifdef CONFIG_CONCURRENT_MODE
-		|| (padapter->iface_type != IFACE_PORT0)
-#endif
-		)
-		return res;
-
-	if (enqueue) {
-		ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
-		if (ph2c == NULL) {
-			res = _FAIL;
-			goto exit;
-		}
-
-		pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_KERNEL);
-		if (pdrvextra_cmd_parm == NULL) {
-			kfree(ph2c);
-			res = _FAIL;
-			goto exit;
-		}
-
-		pdrvextra_cmd_parm->ec_id = P2P_PS_WK_CID;
-		pdrvextra_cmd_parm->type_size = p2p_ps_state;
-		pdrvextra_cmd_parm->pbuf = NULL;
-
-		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
-
-		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-	} else {
-		p2p_ps_wk_hdl(padapter, p2p_ps_state);
-	}
-
-exit:
-
-	return res;
-}
-#endif /*  CONFIG_P2P_PS */
-
 static void reset_ch_sitesurvey_timer_process(void *FunctionContext)
 {
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -299,21 +299,16 @@ void rtw_set_ps_mode(struct rtw_adapter
 
 	/* if (pwrpriv->pwr_mode == PS_MODE_ACTIVE) */
 	if (ps_mode == PS_MODE_ACTIVE) {
-#ifdef CONFIG_P2P_PS
-		if (pwdinfo->opp_ps == 0)
-#endif /*  CONFIG_P2P_PS */
-		{
-			DBG_8192D
-			    ("rtw_set_ps_mode(): Busy Traffic , Leave 802.11 power save..\n");
+		DBG_8192D
+		    ("rtw_set_ps_mode(): Busy Traffic , Leave 802.11 power save..\n");
 
-			pwrpriv->smart_ps = smart_ps;
-			pwrpriv->pwr_mode = ps_mode;
+		pwrpriv->smart_ps = smart_ps;
+		pwrpriv->pwr_mode = ps_mode;
 
-			rtw_set_rpwm(padapter, PS_STATE_S4);
-			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE,
-					  (u8 *)(&ps_mode));
-			pwrpriv->bFwCurrentInPSMode = false;
-		}
+		rtw_set_rpwm(padapter, PS_STATE_S4);
+		rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE,
+				  (u8 *)(&ps_mode));
+		pwrpriv->bFwCurrentInPSMode = false;
 	} else {
 		if (ps_rdy_check(padapter)) {
 			DBG_8192D
@@ -323,11 +318,6 @@ void rtw_set_ps_mode(struct rtw_adapter
 			pwrpriv->pwr_mode = ps_mode;
 			pwrpriv->bFwCurrentInPSMode = true;
 			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&ps_mode));
-#ifdef CONFIG_P2P_PS
-			/*  Set CTWindow after LPS */
-			if (pwdinfo->opp_ps == 1)
-				p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 0);
-#endif /*  CONFIG_P2P_PS */
 			rtw_set_rpwm(padapter, PS_STATE_S2);
 		}
 	}
@@ -444,13 +434,8 @@ void LeaveAllPowerSaveMode(struct rtw_ad
 {
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 
-	/* DBG_8192D("%s.....\n",__func__); */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {	/* connect */
-#ifdef CONFIG_P2P_PS
-		p2p_ps_wk_cmd(adapter, P2P_PS_DISABLE, 0);
-#endif /*  CONFIG_P2P_PS */
+	if (check_fwstate(pmlmepriv, _FW_LINKED))
 		rtw_lps_leave(adapter);
-	}
 }
 
 void rtw_init_pwrctrl_priv(struct rtw_adapter *padapter)
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -818,111 +818,6 @@ void rtl8192d_set_FwJoinBssReport_cmd(st
 
 }
 
-#ifdef CONFIG_P2P_PS
-void rtl8192d_set_p2p_ctw_period_cmd(struct rtw_adapter* padapter, u8 ctwindow)
-{
-	u8	CTWPeriod = ctwindow;
-
-	FillH2CCmd92D(padapter, H2C_P2P_PS_CTW_CMD, 1, (u8 *)(&CTWPeriod));
-}
-
-void rtl8192d_set_p2p_ps_offload_cmd(struct rtw_adapter* padapter, u8 p2p_ps_state)
-{
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
-	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	struct P2P_PS_Offload_t	*p2p_ps_offload = &pHalData->p2p_ps_offload;
-	u8	i;
-	u16	ctwindow;
-	u32	start_time, tsf_low;
-
-	switch (p2p_ps_state)
-	{
-		case P2P_PS_DISABLE:
-			DBG_8192D("P2P_PS_DISABLE\n");
-			memset(p2p_ps_offload, 0 ,1);
-			break;
-		case P2P_PS_ENABLE:
-			DBG_8192D("P2P_PS_ENABLE\n");
-			/*  update CTWindow value. */
-			if (pwdinfo->ctwindow > 0)
-			{
-				p2p_ps_offload->CTWindow_En = 1;
-				ctwindow = pwdinfo->ctwindow;
-				rtl8192d_set_p2p_ctw_period_cmd(padapter, ctwindow);
-			}
-
-			/*  hw only support 2 set of NoA */
-			for (i=0 ; i<pwdinfo->noa_num ; i++)
-			{
-				/*  To control the register setting for which NOA */
-				rtw_write8(padapter, 0x5CF, (i << 4));
-				if (i == 0)
-					p2p_ps_offload->NoA0_En = 1;
-				else
-					p2p_ps_offload->NoA1_En = 1;
-
-				/*  config P2P NoA Descriptor Register */
-				rtw_write32(padapter, 0x5E0, pwdinfo->noa_duration[i]);
-
-				rtw_write32(padapter, 0x5E4, pwdinfo->noa_interval[i]);
-
-				/* Get Current TSF value */
-				tsf_low = rtw_read32(padapter, REG_TSFTR);
-
-				start_time = pwdinfo->noa_start_time[i];
-				if (pwdinfo->noa_count[i] != 1)
-				{
-					while (start_time <= (tsf_low+(50*1024)))
-					{
-						start_time += pwdinfo->noa_interval[i];
-						if (pwdinfo->noa_count[i] != 255)
-							pwdinfo->noa_count[i]--;
-					}
-				}
-				rtw_write32(padapter, 0x5E8, start_time);
-
-				rtw_write8(padapter, 0x5EC, pwdinfo->noa_count[i]);
-			}
-
-			if ((pwdinfo->opp_ps == 1) || (pwdinfo->noa_num > 0))
-			{
-				/*  rst p2p circuit */
-				rtw_write8(padapter, REG_DUAL_TSF_RST, BIT(4));
-
-				p2p_ps_offload->Offload_En = 1;
-
-				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
-				{
-					p2p_ps_offload->role= 1;
-					p2p_ps_offload->AllStaSleep = 0;
-				}
-				else
-				{
-					p2p_ps_offload->role= 0;
-				}
-
-				p2p_ps_offload->discovery = 0;
-			}
-			break;
-		case P2P_PS_SCAN:
-			DBG_8192D("P2P_PS_SCAN\n");
-			p2p_ps_offload->discovery = 1;
-			break;
-		case P2P_PS_SCAN_DONE:
-			DBG_8192D("P2P_PS_SCAN_DONE\n");
-			p2p_ps_offload->discovery = 0;
-			pwdinfo->p2p_ps_state = P2P_PS_ENABLE;
-			break;
-		default:
-			break;
-	}
-
-	FillH2CCmd92D(padapter, H2C_P2P_PS_OFFLOAD, 1, (u8 *)p2p_ps_offload);
-
-}
-#endif /*  CONFIG_P2P_PS */
-
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 /*
 	ask FW to Reset sync register at Beacon early interrupt
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -2382,13 +2382,6 @@ rtl8192d_HalDmWatchDog(
 		rtw_hal_get_hwreg(adapter, HW_VAR_FWLPS_RF_ON, (u8 *)(&bFwPSAwake));
 	}
 
-#ifdef CONFIG_P2P_PS
-	/*  Fw is under p2p powersaving mode, driver should stop dynamic mechanism. */
-	/*  modifed by thomas. 2011.06.11. */
-	if (adapter->wdinfo.p2p_ps_mode)
-		bFwPSAwake = false;
-#endif /*  CONFIG_P2P_PS */
-
 	/*  Stop dynamic mechanism when: */
 	/*  1. RF is OFF. (No need to do DM.) */
 	/*  2. Fw is under power saving mode for FwLPS. (Prevent from SW/FW I/O racing.) */
@@ -2398,9 +2391,8 @@ rtl8192d_HalDmWatchDog(
 	/*      wating to long for RFChangeInProgress.) */
 	/*  4. RFChangeInProgress is TRUE. (Prevent from broken by IPS/HW/SW Rf off.) */
 	/*  Noted by tynli. 2010.06.01. */
-	if ((hw_init_completed == true)
-		&& ((!bFwCurrentInPSMode) && bFwPSAwake))
-	{
+	if ((hw_init_completed == true) && ((!bFwCurrentInPSMode) &&
+	    bFwPSAwake)) {
 		/*  */
 		/*  Calculate Tx/Rx statistics. */
 		/*  */
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -4399,14 +4399,6 @@ static void SetHwReg8192DU(struct rtw_ad
 		case HW_VAR_H2C_FW_JOINBSSRPT:
 			rtl8192d_set_FwJoinBssReport_cmd(adapter, (*(u8 *)val));
 			break;
-#ifdef CONFIG_P2P_PS
-		case HW_VAR_H2C_FW_P2P_PS_OFFLOAD:
-			{
-				u8	p2p_ps_state = (*(u8 *)val);
-				rtl8192d_set_p2p_ps_offload_cmd(adapter, p2p_ps_state);
-			}
-			break;
-#endif /*  CONFIG_P2P_PS */
 		case HW_VAR_INITIAL_GAIN:
 			{
 				struct DIG_T *dig_table = &pdmpriv->DM_DigTable;
--- a/drivers/staging/rtl8192du/include/rtw_mlme.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme.h
@@ -283,18 +283,6 @@ struct wifidirect_info{
 	u16				ext_listen_interval;	/* 	The interval to be available with legacy AP (ms) */
 	u16						ext_listen_period;	/* 	The time period to be available for P2P listen state (ms) */
 #endif
-#ifdef CONFIG_P2P_PS
-	enum P2P_PS_MODE		p2p_ps_mode; /*  indicate p2p ps mode */
-	enum P2P_PS_STATE		p2p_ps_state; /*  indicate p2p ps state */
-	u8						noa_index; /*  Identifies and instance of Notice of Absence timing. */
-	u8						ctwindow; /*  Client traffic window. A period of time in TU after TBTT. */
-	u8						opp_ps; /*  opportunistic power save. */
-	u8						noa_num; /*  number of NoA descriptor in P2P IE. */
-	u8						noa_count[P2P_MAX_NOA_NUM]; /*  Count for owner, Type of client. */
-	u32						noa_duration[P2P_MAX_NOA_NUM]; /*  Max duration for owner, preferred or min acceptable duration for client. */
-	u32						noa_interval[P2P_MAX_NOA_NUM]; /*  Length of interval for owner, preferred or max acceptable interval of client. */
-	u32						noa_start_time[P2P_MAX_NOA_NUM]; /*  schedule expressed in terms of the lower 4 bytes of the TSF timer. */
-#endif /*  CONFIG_P2P_PS */
 };
 
 struct tdls_ss_record{	/* signal strength record; recording the tdls sta with lowerest ss */
--- a/drivers/staging/rtl8192du/include/rtw_p2p.h
+++ b/drivers/staging/rtl8192du/include/rtw_p2p.h
@@ -36,12 +36,6 @@ u8 process_p2p_presence_req(struct wifid
 
 void p2p_protocol_wk_hdl(struct rtw_adapter *padapter, int intCmdType);
 
-#ifdef CONFIG_P2P_PS
-void	process_p2p_ps_ie(PADAPTER padapter, u8 *IEs, u32 IELength);
-void	p2p_ps_wk_hdl(struct rtw_adapter *padapter, u8 p2p_ps_state);
-u8	p2p_ps_wk_cmd(struct rtw_adapter*padapter, u8 p2p_ps_state, u8 enqueue);
-#endif /*  CONFIG_P2P_PS */
-
 #ifdef CONFIG_IOCTL_CFG80211
 void rtw_init_cfg80211_wifidirect_info(struct rtw_adapter *padapter);
 int rtw_p2p_check_frames(struct rtw_adapter *padapter, const u8 *buf, u32 len, u8 tx);
--- a/drivers/staging/rtl8192du/include/wifi.h
+++ b/drivers/staging/rtl8192du/include/wifi.h
@@ -1007,25 +1007,6 @@ enum P2P_PROTO_WK_ID
 	P2P_RO_CH_WK = 6,
 };
 
-#ifdef CONFIG_P2P_PS
-enum P2P_PS_STATE
-{
-	P2P_PS_DISABLE = 0,
-	P2P_PS_ENABLE = 1,
-	P2P_PS_SCAN = 2,
-	P2P_PS_SCAN_DONE = 3,
-	P2P_PS_ALLSTASLEEP = 4, /*  for P2P GO */
-};
-
-enum P2P_PS_MODE
-{
-	P2P_PS_NONE = 0,
-	P2P_PS_CTWINDOW = 1,
-	P2P_PS_NOA	 = 2,
-	P2P_PS_MIX = 3, /*  CTWindow and NoA */
-};
-#endif /*  CONFIG_P2P_PS */
-
 /* 	=====================WFD Section===================== */
 /* 	For Wi-Fi Display */
 #define	WFD_ATTR_DEVICE_INFO			0x00

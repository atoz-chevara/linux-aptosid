From 9978a7bdea8e6b752aa0ec445f4e46f0249208a7 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sat, 4 May 2013 18:31:54 -0500
Subject: [PATCH 120/210] Convert all "if(" to "if ("

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_io.c           |   8 +-
 core/rtw_ioctl_set.c    | 136 ++++----
 core/rtw_iol.c          |  12 +-
 core/rtw_mlme.c         | 342 +++++++++----------
 core/rtw_mlme_ext.c     | 858 ++++++++++++++++++++++++------------------------
 core/rtw_p2p.c          | 190 +++++------
 core/rtw_pwrctrl.c      | 112 +++----
 core/rtw_recv.c         | 316 +++++++++---------
 core/rtw_security.c     |  68 ++--
 core/rtw_sreset.c       |   8 +-
 core/rtw_sta_mgt.c      |  28 +-
 core/rtw_tdls.c         | 290 ++++++++--------
 core/rtw_wlan_util.c    | 116 +++----
 core/rtw_xmit.c         | 276 ++++++++--------
 hal/hal_intf.c          |  94 +++---
 hal/rtl8192d_cmd.c      |  60 ++--
 hal/rtl8192d_dm.c       | 472 +++++++++++++-------------
 hal/rtl8192d_hal_init.c | 318 +++++++++---------
 hal/rtl8192d_mp.c       | 150 ++++-----
 hal/rtl8192d_phycfg.c   | 796 ++++++++++++++++++++++----------------------
 hal/rtl8192d_rf6052.c   |  74 ++---
 hal/rtl8192d_rxdesc.c   | 122 +++----
 hal/rtl8192du_led.c     | 558 +++++++++++++++----------------
 hal/rtl8192du_recv.c    |  14 +-
 hal/rtl8192du_xmit.c    |  82 ++---
 hal/usb_halinit.c       | 578 ++++++++++++++++----------------
 hal/usb_ops_linux.c     | 128 ++++----
 include/osdep_intf.h    |   2 +-
 include/rtw_debug.h     |   4 +-
 include/rtw_ioctl.h     |   2 +-
 include/rtw_led.h       |   2 +-
 include/rtw_p2p.h       |   6 +-
 include/rtw_recv.h      |  22 +-
 include/rtw_security.h  |   2 +-
 include/usb_ops.h       |   2 +-
 include/wifi.h          |   2 +-
 os_dep/ioctl_cfg80211.c | 378 ++++++++++-----------
 os_dep/mlme_linux.c     |  26 +-
 os_dep/osdep_service.c  |  44 +--
 os_dep/recv_linux.c     |  32 +-
 os_dep/rtw_android.c    |   4 +-
 os_dep/usb_intf.c       |  98 +++---
 os_dep/usb_ops_linux.c  |  24 +-
 os_dep/xmit_linux.c     |  16 +-
 44 files changed, 3436 insertions(+), 3436 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_io.c
+++ b/drivers/staging/rtl8192du/core/rtw_io.c
@@ -208,7 +208,7 @@ void _rtw_read_mem(struct rtw_adapter *a
 
 	_func_enter_;
 
-	if( (adapter->bDriverStopped ==true) || (adapter->bSurpriseRemoved == true))
+	if ( (adapter->bDriverStopped ==true) || (adapter->bSurpriseRemoved == true))
 	{
 	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_mem:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));
 	     return;
@@ -248,7 +248,7 @@ void _rtw_read_port(struct rtw_adapter *
 
 	_func_enter_;
 
-	if( (adapter->bDriverStopped ==true) || (adapter->bSurpriseRemoved == true))
+	if ( (adapter->bDriverStopped ==true) || (adapter->bSurpriseRemoved == true))
 	{
 	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_port:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));
 	     return;
@@ -270,7 +270,7 @@ void _rtw_read_port_cancel(struct rtw_ad
 
 	_read_port_cancel = pintfhdl->io_ops._read_port_cancel;
 
-	if(_read_port_cancel)
+	if (_read_port_cancel)
 		_read_port_cancel(pintfhdl);
 
 }
@@ -319,7 +319,7 @@ void _rtw_write_port_cancel(struct rtw_a
 
 	_write_port_cancel = pintfhdl->io_ops._write_port_cancel;
 
-	if(_write_port_cancel)
+	if (_write_port_cancel)
 		_write_port_cancel(pintfhdl);
 
 }
--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -53,7 +53,7 @@ _func_enter_;
 	for(i = 0; i < ssid->SsidLength; i++)
 	{
 		//wifi, printable ascii code must be supported
-		if(!( (ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e) )){
+		if (!( (ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e) )){
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid has nonprintabl ascii\n"));
 			ret= false;
 			break;
@@ -92,7 +92,7 @@ _func_enter_;
 
 	pmlmepriv->to_join = true;
 
-	if(_rtw_queue_empty(queue)== true)
+	if (_rtw_queue_empty(queue)== true)
 	{
 		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
@@ -106,7 +106,7 @@ _func_enter_;
 		{
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_do_join(): site survey if scanned_queue is empty\n."));
 			// submit site_survey_cmd
-			if(_SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)) ) {
+			if (_SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)) ) {
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_do_join(): site survey return error\n."));
 			}
 		}
@@ -117,12 +117,12 @@ _func_enter_;
 	{
 		int select_ret;
 		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-		if((select_ret=rtw_select_and_join_from_scanned_queue(pmlmepriv))==_SUCCESS)
+		if ((select_ret=rtw_select_and_join_from_scanned_queue(pmlmepriv))==_SUCCESS)
 		{
 			pmlmepriv->to_join = false;
 			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
 		}
-		else if(ret == 2)//there is no need to wait for join
+		else if (ret == 2)//there is no need to wait for join
 		{
 			ret = _SUCCESS;
 			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
@@ -130,7 +130,7 @@ _func_enter_;
 		}
 		else
 		{
-			if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true)
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true)
 			{
 				// submit createbss_cmd to change to a ADHOC_MASTER
 
@@ -148,7 +148,7 @@ _func_enter_;
 
 				rtw_generate_random_ibss(pibss);
 
-				if(rtw_createbss_cmd(padapter)!=_SUCCESS)
+				if (rtw_createbss_cmd(padapter)!=_SUCCESS)
 				{
 					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("***Error=>do_goin: rtw_createbss_cmd status FAIL*** \n "));
 					ret =  false;
@@ -166,14 +166,14 @@ _func_enter_;
 				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
 #if 0
-				if((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true))
+				if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true))
 				{
-					if(_rtw_memcmp(pmlmepriv->cur_network.network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength))
+					if (_rtw_memcmp(pmlmepriv->cur_network.network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength))
 					{
 						// for funk to do roaming
 						// funk will reconnect, but funk will not sitesurvey before reconnect
 						RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("for funk to do roaming"));
-						if(pmlmepriv->sitesurveyctrl.traffic_busy==false)
+						if (pmlmepriv->sitesurveyctrl.traffic_busy==false)
 							rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);
 					}
 
@@ -182,12 +182,12 @@ _func_enter_;
 
 				//when set_ssid/set_bssid for rtw_do_join(), but there are no desired bss in scanning queue
 				//we try to issue sitesurvey firstly
-				if(pmlmepriv->LinkDetectInfo.bBusyTraffic==false
+				if (pmlmepriv->LinkDetectInfo.bBusyTraffic==false
 					|| rtw_to_roaming(padapter) > 0
 				)
 				{
 					//DBG_8192D("rtw_do_join() when   no desired bss in scanning queue \n");
-					if( _SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)) ){
+					if ( _SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)) ){
 						RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("do_join(): site survey return error\n."));
 					}
 				}
@@ -269,7 +269,7 @@ handle_tkip_countermeasure:
 	if (padapter->securitypriv.btkip_countermeasure == true) {
 		cur_time = rtw_get_current_time();
 
-		if( (cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ )
+		if ( (cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ )
 		{
 			padapter->securitypriv.btkip_countermeasure = false;
 			padapter->securitypriv.btkip_countermeasure_time = 0;
@@ -317,7 +317,7 @@ _func_enter_;
 		 ("+rtw_set_802_11_ssid: ssid=[%s] fw_state=0x%08x\n",
 		  ssid->Ssid, get_fwstate(pmlmepriv)));
 
-	if(padapter->hw_init_completed==false){
+	if (padapter->hw_init_completed==false){
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 			 ("set_ssid: hw_init_completed==false=>exit!!!\n"));
 		status = _FAIL;
@@ -341,13 +341,13 @@ _func_enter_;
 		if ((pmlmepriv->assoc_ssid.SsidLength == ssid->SsidLength) &&
 		    (_rtw_memcmp(&pmlmepriv->assoc_ssid.Ssid, ssid->Ssid, ssid->SsidLength) == true))
 		{
-			if((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false))
+			if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false))
 			{
 				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 					 ("Set SSID is the same ssid, fw_state=0x%08x\n",
 					  get_fwstate(pmlmepriv)));
 
-				if(rtw_is_same_ibss(padapter, pnetwork) == false)
+				if (rtw_is_same_ibss(padapter, pnetwork) == false)
 				{
 					//if in WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE, create bss or rejoin again
 					rtw_disassoc_cmd(padapter, 0, true);
@@ -398,7 +398,7 @@ handle_tkip_countermeasure:
 	if (padapter->securitypriv.btkip_countermeasure == true) {
 		cur_time = rtw_get_current_time();
 
-		if( (cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ )
+		if ( (cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ )
 		{
 			padapter->securitypriv.btkip_countermeasure = false;
 			padapter->securitypriv.btkip_countermeasure_time = 0;
@@ -458,7 +458,7 @@ _func_enter_;
 		 ("+rtw_set_802_11_infrastructure_mode: old=%d new=%d fw_state=0x%08x\n",
 		  *pold_state, networktype, get_fwstate(pmlmepriv)));
 
-	if(*pold_state != networktype)
+	if (*pold_state != networktype)
 	{
 
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,(" change mode!"));
@@ -473,16 +473,16 @@ _func_enter_;
 #endif
 		}
 
-		if((check_fwstate(pmlmepriv, _FW_LINKED)== true) ||(*pold_state==NDIS802_11IBSS))
+		if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) ||(*pold_state==NDIS802_11IBSS))
 			rtw_disassoc_cmd(padapter, 0, true);
 
-		if((check_fwstate(pmlmepriv, _FW_LINKED)== true) ||
+		if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) ||
 			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)== true) )
 			rtw_free_assoc_resources(padapter, 0);
 
-		if((*pold_state == NDIS802_11INFRA) ||(*pold_state == NDIS802_11IBSS))
+		if ((*pold_state == NDIS802_11INFRA) ||(*pold_state == NDIS802_11IBSS))
 	       {
-			if(check_fwstate(pmlmepriv, _FW_LINKED) == true)
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 			{
 				rtw_indicate_disconnect(padapter); //will clr Linked_state; before this function, we must have chked whether  issue dis-assoc_cmd or not
 			}
@@ -579,7 +579,7 @@ _func_enter_;
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_bssid_list_scan fail since fw_state = %x\n", get_fwstate(pmlmepriv)));
 		res = true;
 
-		if(check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))== true){
+		if (check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))== true){
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n###_FW_UNDER_SURVEY|_FW_UNDER_LINKING\n\n"));
 		} else {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n###pmlmepriv->sitesurveyctrl.traffic_busy==true\n\n"));
@@ -618,12 +618,12 @@ _func_enter_;
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_authentication_mode:psecuritypriv->ndisauthtype=%d", psecuritypriv->ndisauthtype));
 
-	if(psecuritypriv->ndisauthtype>3)
+	if (psecuritypriv->ndisauthtype>3)
 		psecuritypriv->dot11AuthAlgrthm=dot11AuthAlgrthm_8021X;
 
 	res=rtw_set_auth(padapter,psecuritypriv);
 
-	if(res==_SUCCESS)
+	if (res==_SUCCESS)
 		ret=true;
 	else
 		ret=false;
@@ -647,7 +647,7 @@ _func_enter_;
 	btransmitkey= (wep->KeyIndex & 0x80000000) > 0 ? true  : false;	//for ???
 	keyid=wep->KeyIndex & 0x3fffffff;
 
-	if(keyid>4)
+	if (keyid>4)
 	{
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("MgntActrtw_set_802_11_add_wep:keyid>4=>fail\n"));
 		ret=false;
@@ -687,7 +687,7 @@ _func_enter_;
 
 	res=rtw_set_key(padapter,psecuritypriv, keyid, 1);
 
-	if(res==_FAIL)
+	if (res==_FAIL)
 		ret= false;
 exit:
 
@@ -713,7 +713,7 @@ _func_enter_;
 	{
 		int res;
 		struct security_priv* psecuritypriv=&(padapter->securitypriv);
-		if( keyindex < 4 ){
+		if ( keyindex < 4 ){
 
 			memset(&psecuritypriv->dot11DefKey[keyindex], 0, 16);
 
@@ -721,7 +721,7 @@ _func_enter_;
 
 			psecuritypriv->dot11DefKeylen[keyindex]=0;
 
-			if(res==_FAIL)
+			if (res==_FAIL)
 				ret=_FAIL;
 
 		}
@@ -762,7 +762,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	if(key->KeyIndex & 0x40000000)
+	if (key->KeyIndex & 0x40000000)
 	{
 		// Pairwise key
 
@@ -771,7 +771,7 @@ _func_enter_;
 		pbssid=get_bssid(&padapter->mlmepriv);
 		stainfo=rtw_get_stainfo(&padapter->stapriv, pbssid);
 
-		if((stainfo!=NULL)&&(padapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)){
+		if ((stainfo!=NULL)&&(padapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)){
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY:( stainfo!=NULL)&&(Adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)\n"));
 			encryptionalgo=stainfo->dot118021XPrivacy;
 		}
@@ -784,11 +784,11 @@ _func_enter_;
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (Adapter->securitypriv.dot11PrivacyAlgrthm ==%d)!\n",padapter->securitypriv.dot11PrivacyAlgrthm));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (Adapter->securitypriv.dot11AuthAlgrthm ==%d)!\n",padapter->securitypriv.dot11AuthAlgrthm));
 
-		if((stainfo!=NULL)){
+		if ((stainfo!=NULL)){
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (stainfo->dot118021XPrivacy ==%d)!\n", stainfo->dot118021XPrivacy));
 		}
 
-		if(key->KeyIndex & 0x000000FF){
+		if (key->KeyIndex & 0x000000FF){
 			// The key index is specified in the lower 8 bits by values of zero to 255.
 			// The key index should be set to zero for a Pairwise key, and the driver should fail with
 			// NDIS_STATUS_INVALID_DATA if the lower 8 bits is not zero
@@ -806,8 +806,8 @@ _func_enter_;
 		}
 
 		// Check key length for TKIP.
-		//if(encryptionAlgorithm == RT_ENC_TKIP_ENCRYPTION && key->KeyLength != 32)
-		if((encryptionalgo== _TKIP_)&& (key->KeyLength != 32)){
+		//if (encryptionAlgorithm == RT_ENC_TKIP_ENCRYPTION && key->KeyLength != 32)
+		if ((encryptionalgo== _TKIP_)&& (key->KeyLength != 32)){
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("TKIP KeyLength:0x%x != 32\n", key->KeyLength));
 			ret=_FAIL;
 			goto exit;
@@ -815,9 +815,9 @@ _func_enter_;
 		}
 
 		// Check key length for AES.
-		if((encryptionalgo== _AES_)&& (key->KeyLength != 16)) {
+		if ((encryptionalgo== _AES_)&& (key->KeyLength != 16)) {
 			// For our supplicant, EAPPkt9x.vxd, cannot differentiate TKIP and AES case.
-			if(key->KeyLength == 32) {
+			if (key->KeyLength == 32) {
 				key->KeyLength = 16;
 			} else {
 				ret= _FAIL;
@@ -826,7 +826,7 @@ _func_enter_;
 		}
 
 		// Check key length for WEP. For NDTEST, 2005.01.27, by rcnjko.
-		if(	(encryptionalgo== _WEP40_|| encryptionalgo== _WEP104_) && (key->KeyLength != 5 || key->KeyLength != 13)) {
+		if (	(encryptionalgo== _WEP40_|| encryptionalgo== _WEP104_) && (key->KeyLength != 5 || key->KeyLength != 13)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("WEP KeyLength:0x%x != 5 or 13\n", key->KeyLength));
 			ret=_FAIL;
 			goto exit;
@@ -850,7 +850,7 @@ _func_enter_;
 
 
 		// when add wep key through add key and didn't assigned encryption type before
-		if((padapter->securitypriv.ndisauthtype<=3)&&(padapter->securitypriv.dot118021XGrpPrivacy==0))
+		if ((padapter->securitypriv.ndisauthtype<=3)&&(padapter->securitypriv.dot118021XGrpPrivacy==0))
 		{
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("keylen=%d( Adapter->securitypriv.dot11PrivacyAlgrthm=%x  )padapter->securitypriv.dot118021XGrpPrivacy(%x)\n", key->KeyLength,padapter->securitypriv.dot11PrivacyAlgrthm,padapter->securitypriv.dot118021XGrpPrivacy));
 
@@ -882,20 +882,20 @@ _func_enter_;
 
 		}
 
-		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==true) && (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == false)) {
+		if ((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==true) && (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == false)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" IBSS but BSSID is not Broadcast Address.\n"));
 			ret= _FAIL;
 			goto exit;
 		}
 
 		// Check key length for TKIP
-		if((encryptionalgo== _TKIP_) && (key->KeyLength != 32)) {
+		if ((encryptionalgo== _TKIP_) && (key->KeyLength != 32)) {
 
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" TKIP GTK KeyLength:%u != 32\n", key->KeyLength));
 			ret= _FAIL;
 			goto exit;
 
-		} else if(encryptionalgo== _AES_ && (key->KeyLength != 16 && key->KeyLength != 32) ) {
+		} else if (encryptionalgo== _AES_ && (key->KeyLength != 16 && key->KeyLength != 32) ) {
 
 			// Check key length for AES
 			// For NDTEST, we allow keylen=32 in this case. 2005.01.27, by rcnjko.
@@ -905,16 +905,16 @@ _func_enter_;
 		}
 
 		// Change the key length for EAPPkt9x.vxd. Added by Annie, 2005-11-03.
-		if((encryptionalgo==  _AES_) && (key->KeyLength == 32) ) {
+		if ((encryptionalgo==  _AES_) && (key->KeyLength == 32) ) {
 			key->KeyLength = 16;
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("AES key length changed: %u\n", key->KeyLength) );
 		}
 
-		if(key->KeyIndex & 0x8000000) {//error ??? 0x8000_0000
+		if (key->KeyIndex & 0x8000000) {//error ??? 0x8000_0000
 			bgrouptkey = true;
 		}
 
-		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==true)&&(check_fwstate(&padapter->mlmepriv, _FW_LINKED)==true))
+		if ((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==true)&&(check_fwstate(&padapter->mlmepriv, _FW_LINKED)==true))
 		{
 			bgrouptkey = true;
 		}
@@ -931,7 +931,7 @@ _func_enter_;
 	}
 
 	// If WEP encryption algorithm, just call rtw_set_802_11_add_wep().
-	if((padapter->securitypriv.dot11AuthAlgrthm !=dot11AuthAlgrthm_8021X)&&(encryptionalgo== _WEP40_  || encryptionalgo== _WEP104_))
+	if ((padapter->securitypriv.dot11AuthAlgrthm !=dot11AuthAlgrthm_8021X)&&(encryptionalgo== _WEP40_  || encryptionalgo== _WEP104_))
 	{
 		u8 ret;
 		u32 keyindex;
@@ -959,10 +959,10 @@ _func_enter_;
 
 	}
 
-	if(key->KeyIndex & 0x20000000){
+	if (key->KeyIndex & 0x20000000){
 		// SetRSC
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ SetRSC+++++\n"));
-		if(bgroup == true)
+		if (bgroup == true)
 		{
 			unsigned long long keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;
 			memcpy(&padapter->securitypriv.dot11Grprxpn, &keysrc, 8);
@@ -977,16 +977,16 @@ _func_enter_;
 
 	// Indicate this key idx is used for TX
 	// Save the key in KeyMaterial
-	if(bgroup == true) // Group transmit key
+	if (bgroup == true) // Group transmit key
 	{
 		int res;
 
-		if(bgrouptkey == true)
+		if (bgrouptkey == true)
 		{
 			padapter->securitypriv.dot118021XGrpKeyid=(u8)key->KeyIndex;
 		}
 
-		if((key->KeyIndex&0x3) == 0){
+		if ((key->KeyIndex&0x3) == 0){
 			ret = _FAIL;
 			goto exit;
 		}
@@ -995,7 +995,7 @@ _func_enter_;
 		memset(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], 0, 16);
 		memset(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], 0, 16);
 
-		if((key->KeyIndex & 0x10000000))
+		if ((key->KeyIndex & 0x10000000))
 		{
 			memcpy(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 16, 8);
 			memcpy(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 24, 8);
@@ -1035,7 +1035,7 @@ _func_enter_;
 
 		res=rtw_set_key(padapter,&padapter->securitypriv, key->KeyIndex, 1);
 
-		if(res==_FAIL)
+		if (res==_FAIL)
 			ret= _FAIL;
 
 		goto exit;
@@ -1048,13 +1048,13 @@ _func_enter_;
 		pbssid=get_bssid(&padapter->mlmepriv);
 		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid );
 
-		if(stainfo!=NULL)
+		if (stainfo!=NULL)
 		{
 			memset( &stainfo->dot118021x_UncstKey, 0, 16);// clear keybuffer
 
 			memcpy(&stainfo->dot118021x_UncstKey, key->KeyMaterial, 16);
 
-			if(encryptionalgo== _TKIP_)
+			if (encryptionalgo== _TKIP_)
 			{
 				padapter->securitypriv.busetkipkey=false;
 
@@ -1063,7 +1063,7 @@ _func_enter_;
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n ==========_set_timer\n"));
 
 				// if TKIP, save the Receive/Transmit MIC key in KeyMaterial[128-255]
-				if((key->KeyIndex & 0x10000000)){
+				if ((key->KeyIndex & 0x10000000)){
 					memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 16, 8);
 					memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 24, 8);
 
@@ -1074,14 +1074,14 @@ _func_enter_;
 				}
 
 			}
-			else if(encryptionalgo == _AES_)
+			else if (encryptionalgo == _AES_)
 			{
 
 			}
 
 
 			//Set key to CAM through H2C command
-			if(bgrouptkey)//never go to here
+			if (bgrouptkey)//never go to here
 			{
 				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, false);
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(group)\n"));
@@ -1091,7 +1091,7 @@ _func_enter_;
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(unicast)\n"));
 			}
 
-			if(res ==false)
+			if (res ==false)
 				ret= _FAIL;
 
 		}
@@ -1135,7 +1135,7 @@ _func_enter_;
 
 		pbssid=get_bssid(&padapter->mlmepriv);
 		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid );
-		if(stainfo !=NULL){
+		if (stainfo !=NULL){
 			encryptionalgo=stainfo->dot118021XPrivacy;
 
 		// clear key by BSSID
@@ -1190,14 +1190,14 @@ u16 rtw_get_cur_max_rate(struct rtw_adap
 	}
 #endif
 
-	if((check_fwstate(pmlmepriv, _FW_LINKED) != true)
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) != true)
 		&& (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != true))
 		return 0;
 
 #ifdef CONFIG_80211N_HT
 	if (pmlmeext->cur_wireless_mode & (WIRELESS_11_24N|WIRELESS_11_5N)) {
 		p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
-		if(p && ht_ielen>0)
+		if (p && ht_ielen>0)
 		{
 			pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
 
@@ -1227,7 +1227,7 @@ u16 rtw_get_cur_max_rate(struct rtw_adap
 		while( (pcur_bss->SupportedRates[i]!=0) && (pcur_bss->SupportedRates[i]!=0xFF))
 		{
 			rate = pcur_bss->SupportedRates[i]&0x7F;
-			if(rate>max_rate)
+			if (rate>max_rate)
 				max_rate = rate;
 			i++;
 		}
@@ -1247,7 +1247,7 @@ u16 rtw_get_cur_max_rate(struct rtw_adap
 */
 int rtw_set_scan_mode(struct rtw_adapter *adapter, enum RT_SCAN_TYPE scan_mode)
 {
-	if(scan_mode != SCAN_ACTIVE && scan_mode != SCAN_PASSIVE)
+	if (scan_mode != SCAN_ACTIVE && scan_mode != SCAN_PASSIVE)
 		return _FAIL;
 
 	adapter->mlmepriv.scan_mode = scan_mode;
@@ -1286,13 +1286,13 @@ int rtw_set_country(struct rtw_adapter *
 
 	//TODO: should have a table to match country code and RT_CHANNEL_DOMAIN
 	//TODO: should consider 2-character and 3-character country code
-	if(0 == strcmp(country_code, "US"))
+	if (0 == strcmp(country_code, "US"))
 		channel_plan = RT_CHANNEL_DOMAIN_FCC;
-	else if(0 == strcmp(country_code, "EU"))
+	else if (0 == strcmp(country_code, "EU"))
 		channel_plan = RT_CHANNEL_DOMAIN_ETSI;
-	else if(0 == strcmp(country_code, "JP"))
+	else if (0 == strcmp(country_code, "JP"))
 		channel_plan = RT_CHANNEL_DOMAIN_MKK;
-	else if(0 == strcmp(country_code, "CN"))
+	else if (0 == strcmp(country_code, "CN"))
 		channel_plan = RT_CHANNEL_DOMAIN_CHINA;
 	else
 		DBG_8192D("%s unknown country_code:%s\n", __func__, country_code);
--- a/drivers/staging/rtl8192du/core/rtw_iol.c
+++ b/drivers/staging/rtl8192du/core/rtw_iol.c
@@ -82,7 +82,7 @@ int rtw_IOL_append_cmds(struct xmit_fram
 	ori_len = buf_offset+pattrib->pktlen;
 
 	//check if the io_buf can accommodate new cmds
-	if(ori_len + cmd_len + 8 > MAX_XMITBUF_SZ) {
+	if (ori_len + cmd_len + 8 > MAX_XMITBUF_SZ) {
 		DBG_871X("%s %u is large than MAX_XMITBUF_SZ:%u, can't accommodate new cmds\n", __func__
 			, ori_len + cmd_len + 8, MAX_XMITBUF_SZ);
 		return _FAIL;
@@ -194,7 +194,7 @@ int rtw_IOL_append_END_cmd(struct xmit_f
 	ori_len = buf_offset+pattrib->pktlen;
 
 	//check if the io_buf can accommodate new cmds
-	if(ori_len + 8 > MAX_XMITBUF_SZ) {
+	if (ori_len + 8 > MAX_XMITBUF_SZ) {
 		DBG_871X("%s %u is large than MAX_XMITBUF_SZ:%u, can't accommodate end cmd\n", __func__
 			, ori_len + 8, MAX_XMITBUF_SZ);
 		return _FAIL;
@@ -216,10 +216,10 @@ int rtw_IOL_exec_cmd_array_sync(PADAPTER
 {
 	struct xmit_frame	*xmit_frame;
 
-	if((xmit_frame=rtw_IOL_accquire_xmit_frame(adapter)) == NULL)
+	if ((xmit_frame=rtw_IOL_accquire_xmit_frame(adapter)) == NULL)
 		return _FAIL;
 
-	if(rtw_IOL_append_cmds(xmit_frame, IOL_cmds, cmd_num<<3) == _FAIL)
+	if (rtw_IOL_append_cmds(xmit_frame, IOL_cmds, cmd_num<<3) == _FAIL)
 		return _FAIL;
 
 	return rtw_IOL_exec_cmds_sync(adapter, xmit_frame, max_wating_ms);
@@ -233,9 +233,9 @@ int rtw_IOL_exec_empty_cmds_sync(ADAPTER
 
 bool rtw_IOL_applied(ADAPTER *adapter)
 {
-	if(adapter->registrypriv.force_iol)
+	if (adapter->registrypriv.force_iol)
 		return true;
-	if(!adapter_to_dvobj(adapter)->ishighspeed)
+	if (!adapter_to_dvobj(adapter)->ishighspeed)
 		return true;
 	return false;
 }
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -152,7 +152,7 @@ _func_enter_;
 
 	rtw_free_mlme_priv_ie_data(pmlmepriv);
 
-	if(pmlmepriv){
+	if (pmlmepriv){
 		rtw_mfree_mlme_priv_lock (pmlmepriv);
 
 		if (pmlmepriv->free_bss_buf) {
@@ -267,11 +267,11 @@ _func_enter_;
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true ) )
 		lifetime = 1;
 
-	if(!isfreeall)
+	if (!isfreeall)
 	{
 		delta_time = (curr_time -pnetwork->last_scanned)/HZ;
 
-		if(delta_time < lifetime)// unit:sec
+		if (delta_time < lifetime)// unit:sec
 		{
 			goto exit;
 		}
@@ -333,7 +333,7 @@ struct wlan_network *_rtw_find_network(s
 
 _func_enter_;
 
-	if(_rtw_memcmp(zero_addr, addr, ETH_ALEN)){
+	if (_rtw_memcmp(zero_addr, addr, ETH_ALEN)){
 		pnetwork=NULL;
 		goto exit;
 	}
@@ -353,7 +353,7 @@ _func_enter_;
 		plist = get_next(plist);
         }
 
-	if(plist == phead)
+	if (plist == phead)
 		pnetwork = NULL;
 
 	//spin_unlock_bh(&scanned_queue->lock);
@@ -407,7 +407,7 @@ int rtw_if_up(struct rtw_adapter *padapt
 	int res;
 _func_enter_;
 
-	if( padapter->bDriverStopped || padapter->bSurpriseRemoved ||
+	if ( padapter->bDriverStopped || padapter->bSurpriseRemoved ||
 		(check_fwstate(&padapter->mlmepriv, _FW_LINKED)== false)){
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_if_up:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
 		res=false;
@@ -555,7 +555,7 @@ int rtw_is_same_ibss(struct rtw_adapter
 	{
 		ret=false;
 	}
-	else if((psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_ ) &&
+	else if ((psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_ ) &&
 		 ( pnetwork->network.Privacy == 1 ) )
 	{
 		ret=false;
@@ -622,7 +622,7 @@ _func_enter_;
 
 		pwlan= LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		if(pwlan->fixed!=true)
+		if (pwlan->fixed!=true)
 		{
 			if (oldest == NULL ||time_after(oldest->last_scanned, pwlan->last_scanned))
 				oldest = pwlan;
@@ -657,7 +657,7 @@ _func_enter_;
 #endif
 
 	#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING) && 1
-	if(strcmp(dst->Ssid.Ssid, DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED) == 0) {
+	if (strcmp(dst->Ssid.Ssid, DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED) == 0) {
 		DBG_8192D("%s %s(%pM, ch%u) ss_ori:%3u, sq_ori:%3u, rssi_ori:%3ld, ss_smp:%3u, sq_smp:%3u, rssi_smp:%3ld\n"
 			, __func__
 			, src->Ssid.Ssid, src->MacAddress, src->Configuration.DSConfig
@@ -673,13 +673,13 @@ _func_enter_;
 		ss_final = padapter->recvpriv.signal_strength;
 		sq_final = padapter->recvpriv.signal_qual;
 		/* the rssi value here is undecorated, and will be used for antenna diversity */
-		if(sq_smp != 101) /* from the right channel */
+		if (sq_smp != 101) /* from the right channel */
 			rssi_final = (src->Rssi+dst->Rssi*4)/5;
 		else
 			rssi_final = rssi_ori;
 	}
 	else {
-		if(sq_smp != 101) { /* from the right channel */
+		if (sq_smp != 101) { /* from the right channel */
 			ss_final = ((u32)(src->PhyInfo.SignalStrength)+(u32)(dst->PhyInfo.SignalStrength)*4)/5;
 			sq_final = ((u32)(src->PhyInfo.SignalQuality)+(u32)(dst->PhyInfo.SignalQuality)*4)/5;
 			rssi_final = (src->Rssi+dst->Rssi*4)/5;
@@ -700,7 +700,7 @@ _func_enter_;
 	dst->Rssi = rssi_final;
 
 	#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING) && 1
-	if(strcmp(dst->Ssid.Ssid, DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED) == 0) {
+	if (strcmp(dst->Ssid.Ssid, DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED) == 0) {
 		DBG_8192D("%s %s(%pM), SignalStrength:%u, SignalQuality:%u, RawRSSI:%ld\n"
 			, __func__
 			, dst->Ssid.Ssid, dst->MacAddress, dst->PhyInfo.SignalStrength, dst->PhyInfo.SignalQuality, dst->Rssi);
@@ -719,7 +719,7 @@ _func_enter_;
 	{
 		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"Same Network\n");
 
-		//if(pmlmepriv->cur_network.network.IELength<= pnetwork->IELength)
+		//if (pmlmepriv->cur_network.network.IELength<= pnetwork->IELength)
 		{
 			update_network(&(pmlmepriv->cur_network.network), pnetwork,adapter, true);
 			rtw_update_protection(adapter, (pmlmepriv->cur_network.network.IEs) + sizeof (struct ndis_802_11_fixed_ies),
@@ -808,7 +808,7 @@ _func_enter_;
 
 			pnetwork = rtw_alloc_network(pmlmepriv); // will update scan_time
 
-			if(pnetwork==NULL){
+			if (pnetwork==NULL){
 				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n\n\nsomething wrong here\n\n\n"));
 				goto exit;
 			}
@@ -841,7 +841,7 @@ _func_enter_;
 		pnetwork->last_scanned = rtw_get_current_time();
 
 		//target.Reserved[0]==1, means that scaned network is a bcn frame.
-		if((pnetwork->network.IELength>target->IELength) && (target->Reserved[0]==1))
+		if ((pnetwork->network.IELength>target->IELength) && (target->Reserved[0]==1))
 			update_ie = false;
 
 		update_network(&(pnetwork->network), target,adapter, update_ie);
@@ -897,9 +897,9 @@ int rtw_is_desired_network(struct rtw_ad
 	desired_encmode = psecuritypriv->ndisencryptstatus;
 	privacy = pnetwork->network.Privacy;
 
-	if(check_fwstate(pmlmepriv, WIFI_UNDER_WPS))
+	if (check_fwstate(pmlmepriv, WIFI_UNDER_WPS))
 	{
-		if(rtw_get_wps_ie(pnetwork->network.IEs+_FIXED_IE_LENGTH_, pnetwork->network.IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen)!=NULL)
+		if (rtw_get_wps_ie(pnetwork->network.IEs+_FIXED_IE_LENGTH_, pnetwork->network.IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen)!=NULL)
 		{
 			return true;
 		}
@@ -920,9 +920,9 @@ int rtw_is_desired_network(struct rtw_ad
 		bselected = false;
 	}
 
-	if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)
 	{
-		if(pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
+		if (pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
 			bselected = false;
 	}
 
@@ -954,7 +954,7 @@ _func_enter_;
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_survey_event_callback, ssid=%s\n",  pnetwork->Ssid.Ssid));
 
 	len = get_wlan_bssid_ex_sz(pnetwork);
-	if(len > (sizeof(struct wlan_bssid_ex)))
+	if (len > (sizeof(struct wlan_bssid_ex)))
 	{
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n ****rtw_survey_event_callback: return a wrong bss ***\n"));
 		return;
@@ -965,13 +965,13 @@ _func_enter_;
 
 	// update IBSS_network 's timestamp
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) {
-		if(_rtw_memcmp(&(pmlmepriv->cur_network.network.MacAddress), pnetwork->MacAddress, ETH_ALEN)) {
+		if (_rtw_memcmp(&(pmlmepriv->cur_network.network.MacAddress), pnetwork->MacAddress, ETH_ALEN)) {
 			struct wlan_network* ibss_wlan = NULL;
 
 			memcpy(pmlmepriv->cur_network.network.IEs, pnetwork->IEs, 8);
 			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 			ibss_wlan = rtw_find_network(&pmlmepriv->scanned_queue,  pnetwork->MacAddress);
-			if(ibss_wlan)
+			if (ibss_wlan)
 			{
 				memcpy(ibss_wlan->network.IEs , pnetwork->IEs, 8);
 				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
@@ -984,7 +984,7 @@ _func_enter_;
 	// lock pmlmepriv->lock when you accessing network_q
 	if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == false)
 	{
-	        if( pnetwork->Ssid.Ssid[0] == 0 )
+	        if ( pnetwork->Ssid.Ssid[0] == 0 )
 		{
 			pnetwork->Ssid.SsidLength = 0;
 		}
@@ -1015,7 +1015,7 @@ _func_enter_;
 
 	spin_lock_bh(&pmlmepriv->lock);
 
-	if(pmlmepriv->wps_probe_req_ie)
+	if (pmlmepriv->wps_probe_req_ie)
 	{
 		u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 		pmlmepriv->wps_probe_req_ie_len = 0;
@@ -1042,15 +1042,15 @@ _func_enter_;
 	rtw_set_signal_stat_timer(&adapter->recvpriv);
 	#endif
 
-	if(pmlmepriv->to_join == true)
+	if (pmlmepriv->to_join == true)
 	{
-		if((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true) )
+		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true) )
 		{
-			if(check_fwstate(pmlmepriv, _FW_LINKED)==false)
+			if (check_fwstate(pmlmepriv, _FW_LINKED)==false)
 			{
 				set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
 
-				if(rtw_select_and_join_from_scanned_queue(pmlmepriv)==_SUCCESS)
+				if (rtw_select_and_join_from_scanned_queue(pmlmepriv)==_SUCCESS)
 				{
 					_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT );
 				}
@@ -1072,7 +1072,7 @@ _func_enter_;
 
 					pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
 
-					if(rtw_createbss_cmd(adapter)!=_SUCCESS)
+					if (rtw_createbss_cmd(adapter)!=_SUCCESS)
 					{
 					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Error=>rtw_createbss_cmd status FAIL\n"));
 					}
@@ -1086,11 +1086,11 @@ _func_enter_;
 			int s_ret;
 			set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
 			pmlmepriv->to_join = false;
-			if(_SUCCESS == (s_ret=rtw_select_and_join_from_scanned_queue(pmlmepriv)))
+			if (_SUCCESS == (s_ret=rtw_select_and_join_from_scanned_queue(pmlmepriv)))
 			{
 			     _set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
 			}
-			else if(s_ret == 2)//there is no need to wait for join
+			else if (s_ret == 2)//there is no need to wait for join
 			{
 				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 				rtw_indicate_connect(adapter);
@@ -1100,12 +1100,12 @@ _func_enter_;
 				DBG_8192D("try_to_join, but select scanning queue fail, to_roaming:%d\n", rtw_to_roaming(adapter));
 				#ifdef CONFIG_LAYER2_ROAMING
 				if (rtw_to_roaming(adapter) != 0) {
-					if( --pmlmepriv->to_roaming == 0
+					if ( --pmlmepriv->to_roaming == 0
 						|| _SUCCESS != rtw_sitesurvey_cmd(adapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)
 					) {
 						rtw_set_roaming(adapter, 0);
 #ifdef CONFIG_INTEL_WIDI
-						if(adapter->mlmepriv.widi_state == INTEL_WIDI_STATE_ROAMING)
+						if (adapter->mlmepriv.widi_state == INTEL_WIDI_STATE_ROAMING)
 						{
 							memset(pmlmepriv->sa_ext, 0x00, L2SDTA_SERVICE_VE_LEN);
 							intel_widi_wk_cmd(adapter, INTEL_WIDI_LISTEN_WK, NULL);
@@ -1153,7 +1153,7 @@ _func_enter_;
 #endif
 	{
 		struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
-		if(pmlmeext->sitesurvey_res.bss_cnt == 0){
+		if (pmlmeext->sitesurvey_res.bss_cnt == 0){
 			rtw_hal_sreset_reset(adapter);
 		}
 	}
@@ -1226,14 +1226,14 @@ _func_enter_;
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("tgt_network->network.MacAddress=%pM ssid=%s\n",
 		tgt_network->network.MacAddress, tgt_network->network.Ssid.Ssid));
 
-	if(check_fwstate( pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE))
+	if (check_fwstate( pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE))
 	{
 		struct sta_info* psta;
 
 		psta = rtw_get_stainfo(&adapter->stapriv, tgt_network->network.MacAddress);
 
 #ifdef CONFIG_TDLS
-		if(ptdlsinfo->setup_state != TDLS_STATE_NONE)
+		if (ptdlsinfo->setup_state != TDLS_STATE_NONE)
 		{
 			rtw_tdls_cmd(adapter, myid(&(adapter->eeprompriv)), TDLS_RS_RCR);
 			rtw_reset_tdls_info(adapter);
@@ -1251,7 +1251,7 @@ _func_enter_;
 
 	}
 
-	if(check_fwstate( pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE))
+	if (check_fwstate( pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE))
 	{
 		struct sta_info* psta;
 
@@ -1265,11 +1265,11 @@ _func_enter_;
 		rtw_init_bcmc_stainfo(adapter);
 	}
 
-	if(lock_scanned_queue)
+	if (lock_scanned_queue)
 		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
-	if(pwlan)
+	if (pwlan)
 	{
 		pwlan->fixed = false;
 	}
@@ -1279,13 +1279,13 @@ _func_enter_;
 	}
 
 
-	if((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) && (adapter->stapriv.asoc_sta_count== 1))
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) && (adapter->stapriv.asoc_sta_count== 1))
 		/*||check_fwstate(pmlmepriv, WIFI_STATION_STATE)*/)
 	{
 		rtw_free_network_nolock(pmlmepriv, pwlan);
 	}
 
-	if(lock_scanned_queue)
+	if (lock_scanned_queue)
 		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	pmlmepriv->key_mask = 0;
@@ -1308,7 +1308,7 @@ _func_enter_;
 
 	pmlmepriv->to_join = false;
 
-	if(!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
+	if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
 	{
 
 #ifdef CONFIG_SW_ANTENNA_DIVERSITY
@@ -1319,7 +1319,7 @@ _func_enter_;
 	rtw_led_control(padapter, LED_CTL_LINK);
 
 #ifdef CONFIG_DRVEXT_MODULE
-	if(padapter->drvextpriv.enable_wpa)
+	if (padapter->drvextpriv.enable_wpa)
 	{
 		indicate_l2_connect(padapter);
 	}
@@ -1334,7 +1334,7 @@ _func_enter_;
 	rtw_set_roaming(padapter, 0);
 
 #ifdef CONFIG_INTEL_WIDI
-	if(padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_ROAMING)
+	if (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_ROAMING)
 	{
 		memset(pmlmepriv->sa_ext, 0x00, L2SDTA_SERVICE_VE_LEN);
 		intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_WK, NULL);
@@ -1364,10 +1364,10 @@ _func_enter_;
 
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING|WIFI_UNDER_WPS);
 
-	if(rtw_to_roaming(padapter) > 0)
+	if (rtw_to_roaming(padapter) > 0)
 		_clr_fwstate_(pmlmepriv, _FW_LINKED);
 
-	if(check_fwstate(&padapter->mlmepriv, _FW_LINKED)
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED)
 		|| (rtw_to_roaming(padapter) <= 0)
 	)
 	{
@@ -1387,7 +1387,7 @@ _func_enter_;
 
 #ifdef CONFIG_LPS
 #ifdef CONFIG_WOWLAN
-	if(padapter->pwrctrlpriv.wowlan_mode==false)
+	if (padapter->pwrctrlpriv.wowlan_mode==false)
 #endif //CONFIG_WOWLAN
 	rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_DISCONNECT, 1);
 
@@ -1437,18 +1437,18 @@ static struct sta_info *rtw_joinbss_upda
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 
 	psta = rtw_get_stainfo(pstapriv, pnetwork->network.MacAddress);
-	if(psta==NULL) {
+	if (psta==NULL) {
 		psta = rtw_alloc_stainfo(pstapriv, pnetwork->network.MacAddress);
 	}
 
-	if(psta) //update ptarget_sta
+	if (psta) //update ptarget_sta
 	{
 		DBG_8192D("%s\n", __func__);
 
 		psta->aid  = pnetwork->join_res;
 #ifdef CONFIG_CONCURRENT_MODE
 
-		if(PRIMARY_ADAPTER == padapter->adapter_type)
+		if (PRIMARY_ADAPTER == padapter->adapter_type)
 			psta->mac_id=0;
 		else
 			psta->mac_id=2;
@@ -1459,7 +1459,7 @@ static struct sta_info *rtw_joinbss_upda
 		psta->raid = networktype_to_raid(pmlmeext->cur_wireless_mode);
 
 		//security related
-		if(padapter->securitypriv.dot11AuthAlgrthm== dot11AuthAlgrthm_8021X)
+		if (padapter->securitypriv.dot11AuthAlgrthm== dot11AuthAlgrthm_8021X)
 		{
 			padapter->securitypriv.binstallGrpkey=false;
 			padapter->securitypriv.busetkipkey=false;
@@ -1506,7 +1506,7 @@ static struct sta_info *rtw_joinbss_upda
 
 
 		bmc_sta = rtw_get_bcmc_stainfo(padapter);
-		if(bmc_sta)
+		if (bmc_sta)
 		{
 			for(i=0; i < 16 ; i++)
 			{
@@ -1577,7 +1577,7 @@ static void rtw_joinbss_update_network(s
 	{
 		case NDIS802_11INFRA:
 
-				if(pmlmepriv->fw_state&WIFI_UNDER_WPS)
+				if (pmlmepriv->fw_state&WIFI_UNDER_WPS)
 					pmlmepriv->fw_state = WIFI_STATION_STATE|WIFI_UNDER_WPS;
 				else
 					pmlmepriv->fw_state = WIFI_STATION_STATE;
@@ -1641,7 +1641,7 @@ _func_enter_;
 	the_same_macaddr = _rtw_memcmp(pnetwork->network.MacAddress, cur_network->network.MacAddress, ETH_ALEN);
 
 	pnetwork->network.Length = get_wlan_bssid_ex_sz(&pnetwork->network);
-	if(pnetwork->network.Length > sizeof(struct wlan_bssid_ex))
+	if (pnetwork->network.Length > sizeof(struct wlan_bssid_ex))
 	{
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n\n ***joinbss_evt_callback return a wrong bss ***\n\n"));
 		goto ignore_joinbss_callback;
@@ -1651,34 +1651,34 @@ _func_enter_;
 
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n rtw_joinbss_event_callback !! _enter_critical \n"));
 
-	if(pnetwork->join_res > 0)
+	if (pnetwork->join_res > 0)
 	{
 		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 		retry = 0;
 		if (check_fwstate(pmlmepriv,_FW_UNDER_LINKING) )
 		{
 			//s1. find ptarget_wlan
-			if(check_fwstate(pmlmepriv, _FW_LINKED) )
+			if (check_fwstate(pmlmepriv, _FW_LINKED) )
 			{
-				if(the_same_macaddr == true)
+				if (the_same_macaddr == true)
 				{
 					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
 				}
 				else
 				{
 					pcur_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
-					if(pcur_wlan)	pcur_wlan->fixed = false;
+					if (pcur_wlan)	pcur_wlan->fixed = false;
 
 					pcur_sta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
-					if(pcur_sta){
+					if (pcur_sta){
 						spin_lock_bh(&(pstapriv->sta_hash_lock));
 						rtw_free_stainfo(adapter,  pcur_sta);
 						spin_unlock_bh(&(pstapriv->sta_hash_lock));
 					}
 
 					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
-					if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true){
-						if(ptarget_wlan)	ptarget_wlan->fixed = true;
+					if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true){
+						if (ptarget_wlan)	ptarget_wlan->fixed = true;
 					}
 				}
 
@@ -1686,13 +1686,13 @@ _func_enter_;
 			else
 			{
 				ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
-				if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true){
-					if(ptarget_wlan)	ptarget_wlan->fixed = true;
+				if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true){
+					if (ptarget_wlan)	ptarget_wlan->fixed = true;
 				}
 			}
 
 			//s2. update cur_network
-			if(ptarget_wlan)
+			if (ptarget_wlan)
 			{
 				rtw_joinbss_update_network(adapter, ptarget_wlan, pnetwork);
 			}
@@ -1705,10 +1705,10 @@ _func_enter_;
 
 
 			//s3. find ptarget_sta & update ptarget_sta after update cur_network only for station mode
-			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 			{
 				ptarget_sta = rtw_joinbss_update_stainfo(adapter, pnetwork);
-				if(ptarget_sta==NULL)
+				if (ptarget_sta==NULL)
 				{
 					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't update stainfo when joinbss_event callback\n"));
 					spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
@@ -1717,7 +1717,7 @@ _func_enter_;
 			}
 
 			//s4. indicate connect
-			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 			{
 				rtw_indicate_connect(adapter);
 			}
@@ -1744,14 +1744,14 @@ _func_enter_;
 		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	}
-	else if(pnetwork->join_res == -4)
+	else if (pnetwork->join_res == -4)
 	{
 		rtw_reset_securitypriv(adapter);
 		_set_timer(&pmlmepriv->assoc_timer, 1);
 
 		//rtw_free_assoc_resources(adapter, 1);
 
-		if((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == true)
+		if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == true)
 		{
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("fail! clear _FW_UNDER_LINKING ^^^fw_state=%x\n", get_fwstate(pmlmepriv)));
 			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
@@ -1763,18 +1763,18 @@ _func_enter_;
 
 		#ifdef REJOIN
 		res = _FAIL;
-		if(retry < 2) {
+		if (retry < 2) {
 			res = rtw_select_and_join_from_scanned_queue(pmlmepriv);
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_select_and_join_from_scanned_queue again! res:%d\n",res));
 		}
 
-		 if(res == _SUCCESS)
+		 if (res == _SUCCESS)
 		{
 			//extend time of assoc_timer
 			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
 			retry++;
 		}
-		else if(res == 2)//there is no need to wait for join
+		else if (res == 2)//there is no need to wait for join
 		{
 			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 			rtw_indicate_connect(adapter);
@@ -1831,14 +1831,14 @@ void rtw_stassoc_event_callback(struct r
 
 _func_enter_;
 
-	if(rtw_access_ctrl(adapter, pstassoc->macaddr) == false)
+	if (rtw_access_ctrl(adapter, pstassoc->macaddr) == false)
 		return;
 
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE))
 	{
 		psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);
-		if(psta)
+		if (psta)
 		{
 #ifdef CONFIG_IOCTL_CFG80211
 #ifdef COMPAT_KERNEL_RELEASE
@@ -1848,10 +1848,10 @@ _func_enter_;
 			u32 assoc_req_len;
 
 			spin_lock_bh(&psta->lock);
-			if(psta->passoc_req && psta->assoc_req_len>0)
+			if (psta->passoc_req && psta->assoc_req_len>0)
 			{
 				passoc_req = rtw_zmalloc(psta->assoc_req_len);
-				if(passoc_req)
+				if (passoc_req)
 				{
 					assoc_req_len = psta->assoc_req_len;
 					memcpy(passoc_req, psta->passoc_req, assoc_req_len);
@@ -1878,7 +1878,7 @@ _func_enter_;
 #endif
 
 	psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);
-	if( psta != NULL)
+	if ( psta != NULL)
 	{
 		//the sta have been in sta_info_queue => do nothing
 
@@ -1898,7 +1898,7 @@ _func_enter_;
 	psta->mac_id = (uint)pstassoc->cam_id;
 	//psta->aid = (uint)pstassoc->cam_id;
 
-	if(adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)
+	if (adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)
 		psta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;
 
 	psta->ieee8021x_blocked = false;
@@ -1908,11 +1908,11 @@ _func_enter_;
 	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==true ) ||
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true ) )
 	{
-		if(adapter->stapriv.asoc_sta_count== 2)
+		if (adapter->stapriv.asoc_sta_count== 2)
 		{
 			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 			ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
-			if(ptarget_wlan)	ptarget_wlan->fixed = true;
+			if (ptarget_wlan)	ptarget_wlan->fixed = true;
 			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 			// a sta + bc/mc_stainfo (not Ibss_stainfo)
 			rtw_indicate_connect(adapter);
@@ -1941,7 +1941,7 @@ void rtw_stadel_event_callback(struct rt
 
 _func_enter_;
 
-        if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
+        if (check_fwstate(pmlmepriv, WIFI_AP_STATE))
         {
 #ifdef CONFIG_IOCTL_CFG80211
 #ifdef COMPAT_KERNEL_RELEASE
@@ -1959,7 +1959,7 @@ _func_enter_;
 
 	spin_lock_bh(&pmlmepriv->lock);
 
-	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
 	{
 		#ifdef CONFIG_LAYER2_ROAMING
 		if (rtw_to_roaming(adapter) > 0)
@@ -1967,9 +1967,9 @@ _func_enter_;
 		else if (rtw_to_roaming(adapter) == 0)
 			rtw_set_roaming(adapter, adapter->registrypriv.max_roaming_times);
 #ifdef CONFIG_INTEL_WIDI
-		if(adapter->mlmepriv.widi_state != INTEL_WIDI_STATE_CONNECTED)
+		if (adapter->mlmepriv.widi_state != INTEL_WIDI_STATE_CONNECTED)
 #endif // CONFIG_INTEL_WIDI
-		if(*((unsigned short *)(pstadel->rsvd)) != WLAN_REASON_EXPIRATION_CHK)
+		if (*((unsigned short *)(pstadel->rsvd)) != WLAN_REASON_EXPIRATION_CHK)
 			rtw_set_roaming(adapter, 0); /* don't roam */
 		#endif
 
@@ -2003,14 +2003,14 @@ _func_enter_;
 		rtw_free_stainfo(adapter,  psta);
 		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
-		if(adapter->stapriv.asoc_sta_count== 1) //a sta + bc/mc_stainfo (not Ibss_stainfo)
+		if (adapter->stapriv.asoc_sta_count== 1) //a sta + bc/mc_stainfo (not Ibss_stainfo)
 		{
 			//rtw_indicate_disconnect(adapter);//removed@20091105
 			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 			//free old ibss network
 			//pwlan = rtw_find_network(&pmlmepriv->scanned_queue, pstadel->macaddr);
 			pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
-			if(pwlan)
+			if (pwlan)
 			{
 				pwlan->fixed = false;
 				rtw_free_network_nolock(pmlmepriv, pwlan);
@@ -2029,13 +2029,13 @@ _func_enter_;
 
 			rtw_generate_random_ibss(pibss);
 
-			if(check_fwstate(pmlmepriv,WIFI_ADHOC_STATE))
+			if (check_fwstate(pmlmepriv,WIFI_ADHOC_STATE))
 			{
 				set_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
 				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_STATE);
 			}
 
-			if(rtw_createbss_cmd(adapter)!=_SUCCESS)
+			if (rtw_createbss_cmd(adapter)!=_SUCCESS)
 			{
 
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("***Error=>stadel_event_callback: rtw_createbss_cmd status FAIL*** \n "));
@@ -2087,7 +2087,7 @@ void _rtw_join_timeout_handler (struct r
 _func_enter_;
 	DBG_8192D("%s, fw_state=%x\n", __func__, get_fwstate(pmlmepriv));
 
-	if(adapter->bDriverStopped ||adapter->bSurpriseRemoved)
+	if (adapter->bDriverStopped ||adapter->bSurpriseRemoved)
 		return;
 
 
@@ -2099,14 +2099,14 @@ _func_enter_;
 			pmlmepriv->to_roaming--;
 			if (rtw_to_roaming(adapter) != 0) { /* try another */
 				DBG_8192D("%s try another roaming\n", __func__);
-				if( _SUCCESS!=(do_join_r=rtw_do_join(adapter)) ) {
+				if ( _SUCCESS!=(do_join_r=rtw_do_join(adapter)) ) {
 					DBG_8192D("%s roaming do_join return %d\n", __func__ ,do_join_r);
 					continue;
 				}
 				break;
 			} else {
 #ifdef CONFIG_INTEL_WIDI
-				if(adapter->mlmepriv.widi_state == INTEL_WIDI_STATE_ROAMING)
+				if (adapter->mlmepriv.widi_state == INTEL_WIDI_STATE_ROAMING)
 				{
 					memset(pmlmepriv->sa_ext, 0x00, L2SDTA_SERVICE_VE_LEN);
 					intel_widi_wk_cmd(adapter, INTEL_WIDI_LISTEN_WK, NULL);
@@ -2163,10 +2163,10 @@ static void rtw_auto_scan_handler(struct
 	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 
 	//auto site survey per 60sec
-	if(pmlmepriv->scan_interval >0)
+	if (pmlmepriv->scan_interval >0)
 	{
 		pmlmepriv->scan_interval--;
-		if(pmlmepriv->scan_interval==0)
+		if (pmlmepriv->scan_interval==0)
 		{
 /*
 			if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
@@ -2175,7 +2175,7 @@ static void rtw_auto_scan_handler(struct
 				return;
 			}
 
-			if(pmlmepriv->sitesurveyctrl.traffic_busy == true)
+			if (pmlmepriv->sitesurveyctrl.traffic_busy == true)
 			{
 				DBG_8192D("%s exit cause traffic_busy(%x)\n",__func__, pmlmepriv->sitesurveyctrl.traffic_busy);
 				return;
@@ -2216,10 +2216,10 @@ void rtw_dynamic_check_timer_handlder(st
 	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
 #endif
 
-	if(!adapter)
+	if (!adapter)
 		return;
 
-	if(adapter->hw_init_completed == false)
+	if (adapter->hw_init_completed == false)
 		return;
 
 	if ((adapter->bDriverStopped == true)||(adapter->bSurpriseRemoved== true))
@@ -2227,27 +2227,27 @@ void rtw_dynamic_check_timer_handlder(st
 
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(pbuddy_adapter)
+	if (pbuddy_adapter)
 	{
-		if(adapter->net_closed == true && pbuddy_adapter->net_closed == true)
+		if (adapter->net_closed == true && pbuddy_adapter->net_closed == true)
 		{
 			return;
 		}
 	}
 	else
 #endif //CONFIG_CONCURRENT_MODE
-	if(adapter->net_closed == true)
+	if (adapter->net_closed == true)
 	{
 		return;
 	}
 
 	rtw_dynamic_chk_wk_cmd(adapter);
 
-	if(pregistrypriv->wifi_spec==1)
+	if (pregistrypriv->wifi_spec==1)
 	{
 #ifdef CONFIG_P2P
 		struct wifidirect_info *pwdinfo = &adapter->wdinfo;
-		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 #endif
 		{
 			//auto site survey
@@ -2257,7 +2257,7 @@ void rtw_dynamic_check_timer_handlder(st
 
 #ifndef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
 #ifdef CONFIG_AP_MODE
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		expire_timeout_chk(adapter);
 	}
@@ -2271,9 +2271,9 @@ void rtw_dynamic_check_timer_handlder(st
 #endif	// (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-	if( adapter->pnetdev->br_port)
+	if ( adapter->pnetdev->br_port)
 #else	// (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-	if( rcu_dereference(adapter->pnetdev->rx_handler_data)
+	if ( rcu_dereference(adapter->pnetdev->rx_handler_data)
 #endif	// (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 		&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) )
 	{
@@ -2365,38 +2365,38 @@ static int rtw_check_join_candidate(stru
 
 
 	//check bssid, if needed
-	if(pmlmepriv->assoc_by_bssid==true) {
-		if(_rtw_memcmp(competitor->network.MacAddress, pmlmepriv->assoc_bssid, ETH_ALEN) ==false)
+	if (pmlmepriv->assoc_by_bssid==true) {
+		if (_rtw_memcmp(competitor->network.MacAddress, pmlmepriv->assoc_bssid, ETH_ALEN) ==false)
 			goto exit;
 	}
 
 	//check ssid, if needed
-	if(pmlmepriv->assoc_ssid.Ssid && pmlmepriv->assoc_ssid.SsidLength) {
-		if(	competitor->network.Ssid.SsidLength != pmlmepriv->assoc_ssid.SsidLength
+	if (pmlmepriv->assoc_ssid.Ssid && pmlmepriv->assoc_ssid.SsidLength) {
+		if (	competitor->network.Ssid.SsidLength != pmlmepriv->assoc_ssid.SsidLength
 			|| _rtw_memcmp(competitor->network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength) == false
 		)
 			goto exit;
 	}
 
-	if(rtw_is_desired_network(adapter, competitor)  == false)
+	if (rtw_is_desired_network(adapter, competitor)  == false)
 		goto exit;
 
 #ifdef  CONFIG_LAYER2_ROAMING
-	if(rtw_to_roaming(adapter) > 0) {
-		if(	rtw_get_passing_time_ms((u32)competitor->last_scanned) >= RTW_SCAN_RESULT_EXPIRE
+	if (rtw_to_roaming(adapter) > 0) {
+		if (	rtw_get_passing_time_ms((u32)competitor->last_scanned) >= RTW_SCAN_RESULT_EXPIRE
 			|| is_same_ess(&competitor->network, &pmlmepriv->cur_network.network) == false
 		)
 			goto exit;
 	}
 #endif
 
-	if(*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi )
+	if (*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi )
 	{
 		*candidate = competitor;
 		updated = true;
 	}
 
-	if(updated){
+	if (updated){
 		DBG_8192D("[by_bssid:%u][assoc_ssid:%s]"
 			#ifdef  CONFIG_LAYER2_ROAMING
 			"[to_roaming:%u] "
@@ -2449,7 +2449,7 @@ _func_enter_;
 	while (!rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) {
 
 		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
-		if(pnetwork==NULL){
+		if (pnetwork==NULL){
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s return _FAIL:(pnetwork==NULL)\n", __func__));
 			ret = _FAIL;
 			goto exit;
@@ -2460,7 +2460,7 @@ _func_enter_;
 		rtw_check_join_candidate(pmlmepriv, &candidate, pnetwork);
 	}
 
-	if(candidate == NULL) {
+	if (candidate == NULL) {
 		DBG_8192D("%s: return _FAIL(candidate == NULL)\n", __func__);
 		ret = _FAIL;
 		goto exit;
@@ -2483,7 +2483,7 @@ _func_enter_;
 
 	#ifdef CONFIG_ANTENNA_DIVERSITY
 	rtw_hal_get_def_var(adapter, HAL_DEF_IS_SUPPORT_ANT_DIV, &(bSupportAntDiv));
-	if(true == bSupportAntDiv)
+	if (true == bSupportAntDiv)
 	{
 		u8 CurrentAntenna;
 		rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(CurrentAntenna));
@@ -2514,13 +2514,13 @@ int rtw_set_auth(struct rtw_adapter * ad
 _func_enter_;
 
 	pcmd = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if(pcmd==NULL){
+	if (pcmd==NULL){
 		res= _FAIL;  //try again
 		goto exit;
 	}
 
 	psetauthparm=(struct setauth_parm*)rtw_zmalloc(sizeof(struct setauth_parm));
-	if(psetauthparm==NULL){
+	if (psetauthparm==NULL){
 		kfree(pcmd);
 		res= _FAIL;
 		goto exit;
@@ -2563,12 +2563,12 @@ int rtw_set_key(struct rtw_adapter * ada
 _func_enter_;
 
 	pcmd = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if(pcmd==NULL){
+	if (pcmd==NULL){
 		res= _FAIL;  //try again
 		goto exit;
 	}
 	psetkeyparm=(struct setkey_parm*)rtw_zmalloc(sizeof(struct setkey_parm));
-	if(psetkeyparm==NULL){
+	if (psetkeyparm==NULL){
 		kfree(pcmd);
 		res= _FAIL;
 		goto exit;
@@ -2576,7 +2576,7 @@ _func_enter_;
 
 	memset(psetkeyparm, 0, sizeof(struct setkey_parm));
 
-	if(psecuritypriv->dot11AuthAlgrthm ==dot11AuthAlgrthm_8021X){
+	if (psecuritypriv->dot11AuthAlgrthm ==dot11AuthAlgrthm_8021X){
 		psetkeyparm->algorithm=(unsigned char)psecuritypriv->dot118021XGrpPrivacy;
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key: psetkeyparm->algorithm=(unsigned char)psecuritypriv->dot118021XGrpPrivacy=%d \n", psetkeyparm->algorithm));
 	}
@@ -2589,7 +2589,7 @@ _func_enter_;
 	psetkeyparm->set_tx = set_tx;
 	pmlmepriv->key_mask |= BIT(psetkeyparm->keyid);
 #ifdef CONFIG_AUTOSUSPEND
-	if( true  == adapter->pwrctrlpriv.bInternalAutoSuspend)
+	if ( true  == adapter->pwrctrlpriv.bInternalAutoSuspend)
 	{
 		adapter->pwrctrlpriv.wepkeymask = pmlmepriv->key_mask;
 		DBG_8192D("....AutoSuspend pwrctrlpriv.wepkeymask(%x)\n",adapter->pwrctrlpriv.wepkeymask);
@@ -2656,7 +2656,7 @@ int rtw_restruct_wmm_ie(struct rtw_adapt
 	{
 		ielength = initial_out_len;
 
-		if(in_ie[i] == 0xDD && in_ie[i+2] == 0x00 && in_ie[i+3] == 0x50  && in_ie[i+4] == 0xF2 && in_ie[i+5] == 0x02 && i+5 < in_len) //WMM element ID and OUI
+		if (in_ie[i] == 0xDD && in_ie[i+2] == 0x00 && in_ie[i+3] == 0x50  && in_ie[i+4] == 0xF2 && in_ie[i+5] == 0x02 && i+5 < in_len) //WMM element ID and OUI
 		{
 
 			//Append WMM IE to the last index of out_ie
@@ -2707,7 +2707,7 @@ static int SecIsInPMKIDList(struct rtw_a
 
 	do
 	{
-		if( ( psecuritypriv->PMKIDList[i].bUsed ) &&
+		if ( ( psecuritypriv->PMKIDList[i].bUsed ) &&
                     (  _rtw_memcmp( psecuritypriv->PMKIDList[i].Bssid, bssid, ETH_ALEN ) == true ) )
 		{
 			break;
@@ -2720,7 +2720,7 @@ static int SecIsInPMKIDList(struct rtw_a
 
 	}while(i<NUM_PMKID_CACHE);
 
-	if( i == NUM_PMKID_CACHE )
+	if ( i == NUM_PMKID_CACHE )
 	{
 		i = -1;// Could not find.
 	}
@@ -2745,7 +2745,7 @@ static int rtw_append_pmkid(struct rtw_a
 {
 	struct security_priv *psecuritypriv=&Adapter->securitypriv;
 
-	if(ie[13]<=20){
+	if (ie[13]<=20){
 		// The RSN IE didn't include the PMK ID, append the PMK information
 			ie[ie_len]=1;
 			ie_len++;
@@ -2782,18 +2782,18 @@ _func_enter_;
 	//copy fixed ie only
 	memcpy(out_ie, in_ie,12);
 	ielength=12;
-	if((ndisauthmode==NDIS802_11AUTHMODEWPA)||(ndisauthmode==NDIS802_11AUTHMODEWPAPSK))
+	if ((ndisauthmode==NDIS802_11AUTHMODEWPA)||(ndisauthmode==NDIS802_11AUTHMODEWPAPSK))
 			authmode=_WPA_IE_ID_;
-	if((ndisauthmode==NDIS802_11AUTHMODEWPA2)||(ndisauthmode==NDIS802_11AUTHMODEWPA2PSK))
+	if ((ndisauthmode==NDIS802_11AUTHMODEWPA2)||(ndisauthmode==NDIS802_11AUTHMODEWPA2PSK))
 			authmode=_WPA2_IE_ID_;
 
-	if(check_fwstate(pmlmepriv, WIFI_UNDER_WPS))
+	if (check_fwstate(pmlmepriv, WIFI_UNDER_WPS))
 	{
 		memcpy(out_ie+ielength, psecuritypriv->wps_ie, psecuritypriv->wps_ie_len);
 
 		ielength += psecuritypriv->wps_ie_len;
 	}
-	else if((authmode==_WPA_IE_ID_)||(authmode==_WPA2_IE_ID_))
+	else if ((authmode==_WPA_IE_ID_)||(authmode==_WPA2_IE_ID_))
 	{
 		//copy RSN or SSN
 		memcpy(&out_ie[ielength], &psecuritypriv->supplicant_ie[0], psecuritypriv->supplicant_ie[1]+2);
@@ -2806,13 +2806,13 @@ _func_enter_;
 	}
 
 	iEntry = SecIsInPMKIDList(adapter, pmlmepriv->assoc_bssid);
-	if(iEntry<0)
+	if (iEntry<0)
 	{
 		return ielength;
 	}
 	else
 	{
-		if(authmode == _WPA2_IE_ID_)
+		if (authmode == _WPA2_IE_ID_)
 		{
 			ielength=rtw_append_pmkid(adapter, iEntry, out_ie, ielength);
 		}
@@ -2879,7 +2879,7 @@ _func_enter_;
 		pdev_network->NetworkTypeInUse = (NDIS802_11OFDM5);
 		break;
 	case WIRELESS_11ABGN:
-		if(pregistrypriv->channel > 14)
+		if (pregistrypriv->channel > 14)
 			pdev_network->NetworkTypeInUse = (NDIS802_11OFDM5);
 		else
 			pdev_network->NetworkTypeInUse = (NDIS802_11OFDM24);
@@ -2892,7 +2892,7 @@ _func_enter_;
 	pdev_network->Configuration.DSConfig = (pregistrypriv->channel);
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("pregistrypriv->channel=%d, pdev_network->Configuration.DSConfig=0x%x\n", pregistrypriv->channel, pdev_network->Configuration.DSConfig));
 
-	if(cur_network->network.InfrastructureMode == NDIS802_11IBSS)
+	if (cur_network->network.InfrastructureMode == NDIS802_11IBSS)
 		pdev_network->Configuration.ATIMWindow = (0);
 
 	pdev_network->InfrastructureMode = (cur_network->network.InfrastructureMode);
@@ -2948,9 +2948,9 @@ void rtw_joinbss_reset(struct rtw_adapte
 
 	// TH=1 => means that invalidate usb rx aggregation
 	// TH=0 => means that validate usb rx aggregation, use init value.
-	if(phtpriv->ht_option)
+	if (phtpriv->ht_option)
 	{
-		if(padapter->registrypriv.wifi_spec==1)
+		if (padapter->registrypriv.wifi_spec==1)
 			threshold = 1;
 		else
 			threshold = 0;
@@ -2983,9 +2983,9 @@ unsigned int rtw_restructure_ht_ie(struc
 
 	p = rtw_get_ie(in_ie+12, _HT_CAPABILITY_IE_, &ielen, in_len-12);
 
-	if(p && ielen>0)
+	if (p && ielen>0)
 	{
-		if(pqospriv->qos_option == 0)
+		if (pqospriv->qos_option == 0)
 		{
 			out_len = *pout_len;
 			pframe = rtw_set_ie(out_ie+out_len, _VENDOR_SPECIFIC_IE_,
@@ -3001,13 +3001,13 @@ unsigned int rtw_restructure_ht_ie(struc
 		ht_capie.cap_info =  IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_TX_STBC |
 							IEEE80211_HT_CAP_DSSSCCK40;
 		//if insert module set only support 20MHZ, don't add the 40MHZ and SGI_40
-		if( channel > 14 )
+		if ( channel > 14 )
 		{
-			if( pregpriv->cbw40_enable & BIT(1) )
+			if ( pregpriv->cbw40_enable & BIT(1) )
 				cbw40_enable = 1;
 		}
 		else
-			if( pregpriv->cbw40_enable & BIT(0) )
+			if ( pregpriv->cbw40_enable & BIT(0) )
 				cbw40_enable = 1;
 
 		if ( cbw40_enable != 0 )
@@ -3019,7 +3019,7 @@ unsigned int rtw_restructure_ht_ie(struc
 			u32 rx_packet_offset, max_recvbuf_sz;
 			rtw_hal_get_def_var(padapter, HAL_DEF_RX_PACKET_OFFSET, &rx_packet_offset);
 			rtw_hal_get_def_var(padapter, HAL_DEF_MAX_RECVBUF_SZ, &max_recvbuf_sz);
-			//if(max_recvbuf_sz-rx_packet_offset>(8191-256)) {
+			//if (max_recvbuf_sz-rx_packet_offset>(8191-256)) {
 			//	DBG_8192D("%s IEEE80211_HT_CAP_MAX_AMSDU is set\n", __func__);
 			//	ht_capie.cap_info = ht_capie.cap_info |IEEE80211_HT_CAP_MAX_AMSDU;
 			//}
@@ -3027,7 +3027,7 @@ unsigned int rtw_restructure_ht_ie(struc
 
 		ht_capie.ampdu_params_info = (IEEE80211_HT_CAP_AMPDU_FACTOR&0x03);
 
-		if(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_ )
+		if (padapter->securitypriv.dot11PrivacyAlgrthm == _AES_ )
 			ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&(0x07<<2));
 		else
 			ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);
@@ -3044,7 +3044,7 @@ unsigned int rtw_restructure_ht_ie(struc
 		phtpriv->ht_option = true;
 
 		p = rtw_get_ie(in_ie+12, _HT_ADD_INFO_IE_, &ielen, in_len-12);
-		if(p && (ielen==sizeof(struct ieee80211_ht_addt_info)))
+		if (p && (ielen==sizeof(struct ieee80211_ht_addt_info)))
 		{
 			out_len = *pout_len;
 			pframe = rtw_set_ie(out_ie+out_len, _HT_ADD_INFO_IE_, ielen, p+2 , pout_len);
@@ -3074,7 +3074,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u8 cbw40_enable=0;
 
-	if(!phtpriv->ht_option)
+	if (!phtpriv->ht_option)
 		return;
 
 	if ((!pmlmeinfo->HT_info_enable) || (!pmlmeinfo->HT_caps_enable))
@@ -3083,9 +3083,9 @@ void rtw_update_ht_cap(struct rtw_adapte
 	DBG_8192D("+rtw_update_ht_cap()\n");
 
 	//maybe needs check if ap supports rx ampdu.
-	if((phtpriv->ampdu_enable==false) &&(pregistrypriv->ampdu_enable==1))
+	if ((phtpriv->ampdu_enable==false) &&(pregistrypriv->ampdu_enable==1))
 	{
-		if(pregistrypriv->wifi_spec==1)
+		if (pregistrypriv->wifi_spec==1)
 		{
 			phtpriv->ampdu_enable = false;
 		}
@@ -3094,7 +3094,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 			phtpriv->ampdu_enable = true;
 		}
 	}
-	else if(pregistrypriv->ampdu_enable==2)
+	else if (pregistrypriv->ampdu_enable==2)
 	{
 		phtpriv->ampdu_enable = true;
 	}
@@ -3103,7 +3103,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 	//check Max Rx A-MPDU Size
 	len = 0;
 	p = rtw_get_ie(pie+sizeof (struct ndis_802_11_fixed_ies), _HT_CAPABILITY_IE_, &len, ie_len-sizeof (struct ndis_802_11_fixed_ies));
-	if(p && len>0)
+	if (p && len>0)
 	{
 		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
 		max_ampdu_sz = (pht_capie->ampdu_params_info & IEEE80211_HT_CAP_AMPDU_FACTOR);
@@ -3117,19 +3117,19 @@ void rtw_update_ht_cap(struct rtw_adapte
 
 	len=0;
 	p = rtw_get_ie(pie+sizeof (struct ndis_802_11_fixed_ies), _HT_ADD_INFO_IE_, &len, ie_len-sizeof (struct ndis_802_11_fixed_ies));
-	if(p && len>0)
+	if (p && len>0)
 	{
 		pht_addtinfo = (struct ieee80211_ht_addt_info *)(p+2);
 		//todo:
 	}
 
-	if( channel > 14 )
+	if ( channel > 14 )
 	{
-		if( pregistrypriv->cbw40_enable & BIT(1) )
+		if ( pregistrypriv->cbw40_enable & BIT(1) )
 			cbw40_enable = 1;
 	}
 	else
-		if( pregistrypriv->cbw40_enable & BIT(0) )
+		if ( pregistrypriv->cbw40_enable & BIT(0) )
 			cbw40_enable = 1;
 
 
@@ -3146,14 +3146,14 @@ void rtw_update_ht_cap(struct rtw_adapte
 		//update the MCS rates
 		for (i = 0; i < 16; i++)
 		{
-			if((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
+			if ((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
 			{
 				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
 			}
 			else
 			{
 				#ifdef CONFIG_DISABLE_MCS13TO15
-				if(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40 && pregistrypriv->wifi_spec != 1 )
+				if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40 && pregistrypriv->wifi_spec != 1 )
 				{
 					pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R_MCS13TO15_OFF[i];
 				}
@@ -3169,7 +3169,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 			}
 			#endif
 
-			if(pregistrypriv->special_rf_path)
+			if (pregistrypriv->special_rf_path)
 				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
 
 		}
@@ -3195,7 +3195,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 	// Config SM Power Save setting
 	//
 	pmlmeinfo->SM_PS = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 0x0C) >> 2;
-	if(pmlmeinfo->SM_PS == WLAN_HT_CAP_SM_PS_STATIC)
+	if (pmlmeinfo->SM_PS == WLAN_HT_CAP_SM_PS_STATIC)
 	{
 		/*u8 i;
 		//update the MCS rates
@@ -3221,7 +3221,7 @@ void rtw_issue_addbareq_cmd(struct rtw_a
 	struct pkt_attrib *pattrib =&pxmitframe->attrib;
 	s32 bmcst = IS_MCAST(pattrib->ra);
 
-	if(bmcst || (padapter->mlmepriv.LinkDetectInfo.bTxBusyTraffic == false))
+	if (bmcst || (padapter->mlmepriv.LinkDetectInfo.bTxBusyTraffic == false))
 		return;
 
 	priority = pattrib->priority;
@@ -3231,17 +3231,17 @@ void rtw_issue_addbareq_cmd(struct rtw_a
 	else
 		psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
 
-	if(psta==NULL)
+	if (psta==NULL)
 		return;
 
 	phtpriv = &psta->htpriv;
 
-	if((phtpriv->ht_option==true) && (phtpriv->ampdu_enable==true))
+	if ((phtpriv->ht_option==true) && (phtpriv->ampdu_enable==true))
 	{
 		issued = (phtpriv->agg_enable_bitmap>>priority)&0x1;
 		issued |= (phtpriv->candidate_tid_bitmap>>priority)&0x1;
 
-		if(0==issued)
+		if (0==issued)
 		{
 			DBG_8192D("rtw_issue_addbareq_cmd, p=%d\n", priority);
 			psta->htpriv.candidate_tid_bitmap |= BIT((u8)priority);
@@ -3281,12 +3281,12 @@ void _rtw_roaming(struct rtw_adapter *pa
 
 	struct wlan_network *pnetwork;
 
-	if(tgt_network != NULL)
+	if (tgt_network != NULL)
 		pnetwork = tgt_network;
 	else
 		pnetwork = &pmlmepriv->cur_network;
 
-	if(0 < rtw_to_roaming(padapter)) {
+	if (0 < rtw_to_roaming(padapter)) {
 		DBG_8192D("roaming from %s(%pM), length:%d\n",
 				pnetwork->network.Ssid.Ssid, pnetwork->network.MacAddress,
 				pnetwork->network.Ssid.SsidLength);
@@ -3295,13 +3295,13 @@ void _rtw_roaming(struct rtw_adapter *pa
 		pmlmepriv->assoc_by_bssid = false;
 
 		while(1) {
-			if( _SUCCESS==(do_join_r=rtw_do_join(padapter)) ) {
+			if ( _SUCCESS==(do_join_r=rtw_do_join(padapter)) ) {
 				break;
 			} else {
 				DBG_8192D("roaming do_join return %d\n", do_join_r);
 				pmlmepriv->to_roaming--;
 
-				if(0< rtw_to_roaming(padapter)) {
+				if (0< rtw_to_roaming(padapter)) {
 					continue;
 				} else {
 					DBG_8192D("%s(%d) -to roaming fail, indicate_disconnect\n", __func__,__LINE__);
@@ -3320,15 +3320,15 @@ int rtw_buddy_adapter_up(struct rtw_adap
 {
 	int res = false;
 
-	if(padapter == NULL)
+	if (padapter == NULL)
 		return res;
 
 
-	if(padapter->pbuddy_adapter == NULL)
+	if (padapter->pbuddy_adapter == NULL)
 	{
 		res = false;
 	}
-	else if( (padapter->pbuddy_adapter->bDriverStopped) || (padapter->pbuddy_adapter->bSurpriseRemoved) ||
+	else if ( (padapter->pbuddy_adapter->bDriverStopped) || (padapter->pbuddy_adapter->bSurpriseRemoved) ||
 		(padapter->pbuddy_adapter->bup == false) || (padapter->pbuddy_adapter->hw_init_completed == false))
 	{
 		res = false;
@@ -3344,10 +3344,10 @@ int rtw_buddy_adapter_up(struct rtw_adap
 
 int check_buddy_fwstate(struct rtw_adapter *padapter, int state)
 {
-	if(padapter == NULL)
+	if (padapter == NULL)
 		return false;
 
-	if(padapter->pbuddy_adapter == NULL)
+	if (padapter->pbuddy_adapter == NULL)
 		return false;
 
 	if ((state == WIFI_FW_NULL_STATE) &&
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -261,11 +261,11 @@ int rtw_ch_set_search_ch(struct rt_chann
 {
 	int i;
 	for(i=0;ch_set[i].ChannelNum!=0;i++){
-		if(ch == ch_set[i].ChannelNum)
+		if (ch == ch_set[i].ChannelNum)
 			break;
 	}
 
-	if(i >= ch_set[i].ChannelNum)
+	if (i >= ch_set[i].ChannelNum)
 		return -1;
 	return i;
 }
@@ -312,7 +312,7 @@ static void init_mlme_ext_priv_value(str
 	memcpy(pmlmeext->datarate, mixed_datarate, NUMRATES);
 	memcpy(pmlmeext->basicrate, mixed_basicrate, NUMRATES);
 
-	if(pmlmeext->cur_channel > 14)
+	if (pmlmeext->cur_channel > 14)
 		pmlmeext->tx_rate = IEEE80211_OFDM_RATE_6MB;
 	else
 		pmlmeext->tx_rate = IEEE80211_CCK_RATE_1MB;
@@ -419,48 +419,48 @@ static u8 init_channel_set(struct rtw_ad
 
 	memset(channel_set, 0, sizeof(struct rt_channel_info) * MAX_CHANNEL_NUM);
 
-	if(ChannelPlan >= RT_CHANNEL_DOMAIN_MAX && ChannelPlan != RT_CHANNEL_DOMAIN_REALTEK_DEFINE)
+	if (ChannelPlan >= RT_CHANNEL_DOMAIN_MAX && ChannelPlan != RT_CHANNEL_DOMAIN_REALTEK_DEFINE)
 	{
 		DBG_8192D("ChannelPlan ID %x error !!!!!\n",ChannelPlan);
 		return chanset_size;
 	}
 
-	if(padapter->registrypriv.wireless_mode & WIRELESS_11G)
+	if (padapter->registrypriv.wireless_mode & WIRELESS_11G)
 	{
 		b2_4GBand = true;
-		if(RT_CHANNEL_DOMAIN_REALTEK_DEFINE == ChannelPlan)
+		if (RT_CHANNEL_DOMAIN_REALTEK_DEFINE == ChannelPlan)
 			Index2G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index2G;
 		else
 			Index2G = RTW_ChannelPlanMap[ChannelPlan].Index2G;
 	}
 
-	if(padapter->registrypriv.wireless_mode & WIRELESS_11A)
+	if (padapter->registrypriv.wireless_mode & WIRELESS_11A)
 	{
 		b5GBand = true;
-		if(RT_CHANNEL_DOMAIN_REALTEK_DEFINE == ChannelPlan)
+		if (RT_CHANNEL_DOMAIN_REALTEK_DEFINE == ChannelPlan)
 			Index5G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index5G;
 		else
 			Index5G = RTW_ChannelPlanMap[ChannelPlan].Index5G;
 	}
 
-	if(b2_4GBand)
+	if (b2_4GBand)
 	{
 		for(index=0;index<RTW_ChannelPlan2G[Index2G].Len;index++)
 		{
 			channel_set[chanset_size].ChannelNum = RTW_ChannelPlan2G[Index2G].Channel[index];
 
-			if(RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN == ChannelPlan) //Channel 1~11 is active, and 12~14 is passive
+			if (RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN == ChannelPlan) //Channel 1~11 is active, and 12~14 is passive
 			{
-				if(channel_set[chanset_size].ChannelNum >= 1 && channel_set[chanset_size].ChannelNum <= 11)
+				if (channel_set[chanset_size].ChannelNum >= 1 && channel_set[chanset_size].ChannelNum <= 11)
 					channel_set[chanset_size].ScanType = SCAN_ACTIVE;
-				else if((channel_set[chanset_size].ChannelNum  >= 12 && channel_set[chanset_size].ChannelNum  <= 14))
+				else if ((channel_set[chanset_size].ChannelNum  >= 12 && channel_set[chanset_size].ChannelNum  <= 14))
 					channel_set[chanset_size].ScanType  = SCAN_PASSIVE;
 			}
-			else if(RT_CHANNEL_DOMAIN_WORLD_WIDE_13 == ChannelPlan ||
+			else if (RT_CHANNEL_DOMAIN_WORLD_WIDE_13 == ChannelPlan ||
 				RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan ||
 				RT_CHANNEL_DOMAIN_2G_WORLD == Index2G)// channel 12~13, passive scan
 			{
-				if(channel_set[chanset_size].ChannelNum <= 11)
+				if (channel_set[chanset_size].ChannelNum <= 11)
 					channel_set[chanset_size].ScanType = SCAN_ACTIVE;
 				else
 					channel_set[chanset_size].ScanType = SCAN_PASSIVE;
@@ -474,7 +474,7 @@ static u8 init_channel_set(struct rtw_ad
 		}
 	}
 
-	if(b5GBand)
+	if (b5GBand)
 	{
 		for(index=0;index<RTW_ChannelPlan5G[Index5G].Len;index++)
 		{
@@ -483,7 +483,7 @@ static u8 init_channel_set(struct rtw_ad
 			if ( channel_set[chanset_size].ChannelNum <= 48
 				|| channel_set[chanset_size].ChannelNum >= 149 )
 			{
-				if(RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)//passive scan for all 5G channels
+				if (RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)//passive scan for all 5G channels
 					channel_set[chanset_size].ScanType = SCAN_PASSIVE;
 				else
 					channel_set[chanset_size].ScanType = SCAN_ACTIVE;
@@ -497,7 +497,7 @@ static u8 init_channel_set(struct rtw_ad
 			if ( RTW_ChannelPlan5G[Index5G].Channel[index] <= 48
 				|| RTW_ChannelPlan5G[Index5G].Channel[index] >= 149 ) {
 				channel_set[chanset_size].ChannelNum = RTW_ChannelPlan5G[Index5G].Channel[index];
-				if(RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)//passive scan for all 5G channels
+				if (RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)//passive scan for all 5G channels
 					channel_set[chanset_size].ScanType = SCAN_PASSIVE;
 				else
 					channel_set[chanset_size].ScanType = SCAN_ACTIVE;
@@ -574,7 +574,7 @@ static u8 cmp_pkt_chnl_diff(struct rtw_a
 	if (p)
 	{
 		channel = *(p + 2);
-		if(padapter->mlmeextpriv.cur_channel >= channel)
+		if (padapter->mlmeextpriv.cur_channel >= channel)
 		{
 			return (padapter->mlmeextpriv.cur_channel - channel);
 		}
@@ -594,7 +594,7 @@ static void _mgt_dispatcher(struct rtw_a
 	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 
-	  if(ptable->func)
+	  if (ptable->func)
         {
 	 //receive the frames that ra(a1) is my address or ra(a1) is bc address.
 		if (!_rtw_memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN) &&
@@ -641,9 +641,9 @@ void mgt_dispatcher(struct rtw_adapter *
 	index = GetFrameSubType(pframe) >> 4;
 
 #ifdef CONFIG_TDLS
-	if((index << 4)==WIFI_ACTION){
+	if ((index << 4)==WIFI_ACTION){
 		//category==RTW_WLAN_CATEGORY_PUBLIC, action==TDLS_DISCOVERY_RESPONSE
-		if(*(pframe + IEEE80211_MGMT_HDR_LEN ) == RTW_WLAN_CATEGORY_PUBLIC
+		if (*(pframe + IEEE80211_MGMT_HDR_LEN ) == RTW_WLAN_CATEGORY_PUBLIC
 			&& *(pframe + IEEE80211_MGMT_HDR_LEN + 1) == TDLS_DISCOVERY_RESPONSE )
 		{
 			DBG_8192D("recv tdls discovery response frame\n");
@@ -675,7 +675,7 @@ void mgt_dispatcher(struct rtw_adapter *
 	}
 #else
 
-	if(GetRetry(pframe))
+	if (GetRetry(pframe))
 	{
 		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("drop due to decache!\n"));
 		//return;
@@ -686,7 +686,7 @@ void mgt_dispatcher(struct rtw_adapter *
 	switch (GetFrameSubType(pframe))
 	{
 		case WIFI_AUTH:
-			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+			if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 				ptable->func = &OnAuth;
 			else
 				ptable->func = &OnAuthClient;
@@ -695,12 +695,12 @@ void mgt_dispatcher(struct rtw_adapter *
 		case WIFI_REASSOCREQ:
 			_mgt_dispatcher(padapter, ptable, precv_frame);
 #ifdef CONFIG_HOSTAPD_MLME
-			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+			if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 				rtw_hostapd_mlme_rx(padapter, precv_frame);
 #endif
 			break;
 		case WIFI_PROBEREQ:
-			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+			if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 			{
 #ifdef CONFIG_HOSTAPD_MLME
 				rtw_hostapd_mlme_rx(padapter, precv_frame);
@@ -715,12 +715,12 @@ void mgt_dispatcher(struct rtw_adapter *
 			_mgt_dispatcher(padapter, ptable, precv_frame);
 			break;
 		case WIFI_ACTION:
-			//if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+			//if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 			_mgt_dispatcher(padapter, ptable, precv_frame);
 			break;
 		default:
 			_mgt_dispatcher(padapter, ptable, precv_frame);
-			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+			if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 				rtw_hostapd_mlme_rx(padapter, precv_frame);
 			break;
 	}
@@ -811,18 +811,18 @@ unsigned int OnProbeReq(struct rtw_adapt
 		}
 #endif //CONFIG_WIFI_TEST
 
-		if( wifi_test_chk_rate == 1 )
+		if ( wifi_test_chk_rate == 1 )
 		{
-			if((is_valid_p2p_probereq = process_probe_req_p2p_ie(pwdinfo, pframe, len)) == true)
+			if ((is_valid_p2p_probereq = process_probe_req_p2p_ie(pwdinfo, pframe, len)) == true)
 			{
-				if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE))
+				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE))
 				{
 					p2p_listen_state_process( padapter,  get_sa(pframe));
 
 					return _SUCCESS;
 				}
 
-				if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 				{
 					goto _continue;
 				}
@@ -833,12 +833,12 @@ unsigned int OnProbeReq(struct rtw_adapt
 _continue:
 #endif //CONFIG_P2P
 
-	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
 	{
 		return _SUCCESS;
 	}
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == false &&
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == false &&
 		check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE)==false)
 	{
 		return _SUCCESS;
@@ -848,7 +848,7 @@ _continue:
 	//DBG_8192D("+OnProbeReq\n");
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
+	if (((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 		check_buddy_fwstate(padapter, _FW_UNDER_LINKING|_FW_UNDER_SURVEY))
 	{
 		//don't process probe req
@@ -863,7 +863,7 @@ _continue:
 	//check (wildcard) SSID
 	if (p != NULL)
 	{
-		if(is_valid_p2p_probereq == true)
+		if (is_valid_p2p_probereq == true)
 		{
 			goto _issue_probersp;
 		}
@@ -877,7 +877,7 @@ _continue:
 
 _issue_probersp:
 
-		if(check_fwstate(pmlmepriv, _FW_LINKED) == true &&
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true &&
 			pmlmepriv->cur_network.join_res == true)
 		{
 			//DBG_8192D("+issue_probersp during ap mode\n");
@@ -903,13 +903,13 @@ unsigned int OnProbeRsp(struct rtw_adapt
 
 
 #ifdef CONFIG_P2P
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
 	{
 		if ( true == pwdinfo->tx_prov_disc_info.benable )
 		{
-			if( _rtw_memcmp( pwdinfo->tx_prov_disc_info.peerIFAddr, GetAddr2Ptr(pframe), ETH_ALEN ) )
+			if ( _rtw_memcmp( pwdinfo->tx_prov_disc_info.peerIFAddr, GetAddr2Ptr(pframe), ETH_ALEN ) )
 			{
-				if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
+				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
 				{
 					pwdinfo->tx_prov_disc_info.benable = false;
 					issue_p2p_provision_request( padapter,
@@ -929,24 +929,24 @@ unsigned int OnProbeRsp(struct rtw_adapt
 		}
 		return _SUCCESS;
 	}
-	else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
+	else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
 	{
 		if ( true == pwdinfo->nego_req_info.benable )
 		{
 			DBG_8192D( "[%s] P2P State is GONEGO ING!\n", __func__ );
-			if( _rtw_memcmp( pwdinfo->nego_req_info.peerDevAddr, GetAddr2Ptr(pframe), ETH_ALEN ) )
+			if ( _rtw_memcmp( pwdinfo->nego_req_info.peerDevAddr, GetAddr2Ptr(pframe), ETH_ALEN ) )
 			{
 				pwdinfo->nego_req_info.benable = false;
 				issue_p2p_GO_request( padapter, pwdinfo->nego_req_info.peerDevAddr);
 			}
 		}
 	}
-	else if( rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ ) )
+	else if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ ) )
 	{
 		if ( true == pwdinfo->invitereq_info.benable )
 		{
 			DBG_8192D( "[%s] P2P_STATE_TX_INVITE_REQ!\n", __func__ );
-			if( _rtw_memcmp( pwdinfo->invitereq_info.peer_macaddr, GetAddr2Ptr(pframe), ETH_ALEN ) )
+			if ( _rtw_memcmp( pwdinfo->invitereq_info.peer_macaddr, GetAddr2Ptr(pframe), ETH_ALEN ) )
 			{
 				pwdinfo->invitereq_info.benable = false;
 				issue_p2p_invitation_request( padapter, pwdinfo->invitereq_info.peer_macaddr );
@@ -1016,7 +1016,7 @@ unsigned int OnBeacon(struct rtw_adapter
 			return _SUCCESS;
 		}
 
-		if(((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) && (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
+		if (((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) && (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
 		{
 			if ((psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe))) != NULL)
 			{
@@ -1045,12 +1045,12 @@ unsigned int OnBeacon(struct rtw_adapter
 #endif //CONFIG_DFS
 
 #ifdef CONFIG_P2P_PS
-				//if(psta->ieee8021x_blocked == false) // do not allow P2P PS during EAPOL handshake ?
+				//if (psta->ieee8021x_blocked == false) // do not allow P2P PS during EAPOL handshake ?
 				process_p2p_ps_ie(padapter, (pframe + WLAN_HDR_A3_LEN), (len - WLAN_HDR_A3_LEN));
 #endif //CONFIG_P2P_PS
 
 			}
-		} else if((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {
+		} else if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {
 			if ((psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe))) != NULL) {
 				//update WMM, ERP in the beacon
 				//todo: the timer is used instead of the number of the beacon received
@@ -1102,7 +1102,7 @@ unsigned int OnAuth(struct rtw_adapter *
 
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
+	if (((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 		check_buddy_fwstate(padapter, _FW_UNDER_LINKING|_FW_UNDER_SURVEY))
 	{
 		//don't process auth request;
@@ -1110,7 +1110,7 @@ unsigned int OnAuth(struct rtw_adapter *
 	}
 #endif //CONFIG_CONCURRENT_MODE
 
-	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+	if ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
 		return _FAIL;
 
 	DBG_8192D("+OnAuth\n");
@@ -1144,7 +1144,7 @@ unsigned int OnAuth(struct rtw_adapter *
 		goto auth_fail;
 	}
 
-	if(rtw_access_ctrl(padapter, sa) == false) {
+	if (rtw_access_ctrl(padapter, sa) == false) {
 		status = _STATS_UNABLE_HANDLE_STA_;
 		goto auth_fail;
 	}
@@ -1165,7 +1165,7 @@ unsigned int OnAuth(struct rtw_adapter *
 		pstat->auth_seq = 0;
 	} else {
 		spin_lock_bh(&pstapriv->asoc_list_lock);
-		if(rtw_is_list_empty(&pstat->asoc_list)==false) {
+		if (rtw_is_list_empty(&pstat->asoc_list)==false) {
 			rtw_list_delete(&pstat->asoc_list);
 			pstapriv->asoc_list_cnt--;
 			if (pstat->expire_to > 0)
@@ -1237,7 +1237,7 @@ unsigned int OnAuth(struct rtw_adapter *
 			p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + 4 + _AUTH_IE_OFFSET_ , _CHLGETXT_IE_, (int *)&ie_len,
 					len - WLAN_HDR_A3_LEN - _AUTH_IE_OFFSET_ - 4);
 
-			if((p==NULL) || (ie_len<=0))
+			if ((p==NULL) || (ie_len<=0))
 			{
 				DBG_8192D("auth rejected because challenge failure!(1)\n");
 				status = _STATS_CHALLENGE_FAIL_;
@@ -1283,7 +1283,7 @@ unsigned int OnAuth(struct rtw_adapter *
 
 auth_fail:
 
-	if(pstat)
+	if (pstat)
 		rtw_free_stainfo(padapter , pstat);
 
 	pstat = &stat;
@@ -1328,9 +1328,9 @@ unsigned int OnAuthClient(struct rtw_ada
 	if (status != 0)
 	{
 		DBG_8192D("clnt auth fail, status: %d\n", status);
-		if(status == 13)//&& pmlmeinfo->auth_algo == dot11AuthAlgrthm_Auto)
+		if (status == 13)//&& pmlmeinfo->auth_algo == dot11AuthAlgrthm_Auto)
 		{
-			if(pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)
+			if (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)
 				pmlmeinfo->auth_algo = dot11AuthAlgrthm_Open;
 			else
 				pmlmeinfo->auth_algo = dot11AuthAlgrthm_Shared;
@@ -1433,7 +1433,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 #endif //CONFIG_P2P
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
+	if (((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 		check_buddy_fwstate(padapter, _FW_UNDER_LINKING|_FW_UNDER_SURVEY))
 	{
 		//don't process assoc request;
@@ -1441,7 +1441,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 	}
 #endif //CONFIG_CONCURRENT_MODE
 
-	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+	if ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
 		return _FAIL;
 
 	frame_type = GetFrameSubType(pframe);
@@ -1534,7 +1534,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 			status = _STATS_FAILURE_;
 	}
 
-	if(_STATS_SUCCESSFUL_ != status)
+	if (_STATS_SUCCESSFUL_ != status)
 		goto OnAssocReqFail;
 
 	// check if the supported rate is ok
@@ -1556,7 +1556,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 				pkt_len - WLAN_HDR_A3_LEN - ie_offset);
 		if (p !=  NULL) {
 
-			if(supportRateNum<=sizeof(supportRate))
+			if (supportRateNum<=sizeof(supportRate))
 			{
 				memcpy(supportRate+supportRateNum, p+2, ie_len);
 				supportRateNum += ie_len;
@@ -1580,14 +1580,14 @@ unsigned int OnAssocReq(struct rtw_adapt
 	pstat->wpa_pairwise_cipher = 0;
 	pstat->wpa2_pairwise_cipher = 0;
 	memset(pstat->wpa_ie, 0, sizeof(pstat->wpa_ie));
-	if((psecuritypriv->wpa_psk & BIT(1)) && elems.rsn_ie) {
+	if ((psecuritypriv->wpa_psk & BIT(1)) && elems.rsn_ie) {
 
 		int group_cipher=0, pairwise_cipher=0;
 
 		wpa_ie = elems.rsn_ie;
 		wpa_ie_len = elems.rsn_ie_len;
 
-		if(rtw_parse_wpa2_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		if (rtw_parse_wpa2_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
 			pstat->dot8021xalg = 1;//psk,  todo:802.1x
 			pstat->wpa_psk |= BIT(1);
@@ -1595,10 +1595,10 @@ unsigned int OnAssocReq(struct rtw_adapt
 			pstat->wpa2_group_cipher = group_cipher&psecuritypriv->wpa2_group_cipher;
 			pstat->wpa2_pairwise_cipher = pairwise_cipher&psecuritypriv->wpa2_pairwise_cipher;
 
-			if(!pstat->wpa2_group_cipher)
+			if (!pstat->wpa2_group_cipher)
 				status = WLAN_STATUS_GROUP_CIPHER_NOT_VALID;
 
-			if(!pstat->wpa2_pairwise_cipher)
+			if (!pstat->wpa2_pairwise_cipher)
 				status = WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID;
 		}
 		else
@@ -1613,7 +1613,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 		wpa_ie = elems.wpa_ie;
 		wpa_ie_len = elems.wpa_ie_len;
 
-		if(rtw_parse_wpa_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		if (rtw_parse_wpa_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
 			pstat->dot8021xalg = 1;//psk,  todo:802.1x
 			pstat->wpa_psk |= BIT(0);
@@ -1621,10 +1621,10 @@ unsigned int OnAssocReq(struct rtw_adapt
 			pstat->wpa_group_cipher = group_cipher&psecuritypriv->wpa_group_cipher;
 			pstat->wpa_pairwise_cipher = pairwise_cipher&psecuritypriv->wpa_pairwise_cipher;
 
-			if(!pstat->wpa_group_cipher)
+			if (!pstat->wpa_group_cipher)
 				status = WLAN_STATUS_GROUP_CIPHER_NOT_VALID;
 
-			if(!pstat->wpa_pairwise_cipher)
+			if (!pstat->wpa_pairwise_cipher)
 				status = WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID;
 
 		}
@@ -1638,12 +1638,12 @@ unsigned int OnAssocReq(struct rtw_adapt
 		wpa_ie_len = 0;
 	}
 
-	if(_STATS_SUCCESSFUL_ != status)
+	if (_STATS_SUCCESSFUL_ != status)
 		goto OnAssocReqFail;
 
 	pstat->flags &= ~(WLAN_STA_WPS | WLAN_STA_MAYBE_WPS);
 	//if (hapd->conf->wps_state && wpa_ie == NULL) { //todo: to check ap if supporting WPS
-	if(wpa_ie == NULL) {
+	if (wpa_ie == NULL) {
 		if (elems.wps_ie) {
 			DBG_8192D("STA included WPS IE in "
 				   "(Re)Association Request - assume WPS is "
@@ -1662,16 +1662,16 @@ unsigned int OnAssocReq(struct rtw_adapt
 
 		// AP support WPA/RSN, and sta is going to do WPS, but AP is not ready
 		// that the selected registrar of AP is _FLASE
-		if((psecuritypriv->wpa_psk >0)
+		if ((psecuritypriv->wpa_psk >0)
 			&& (pstat->flags & (WLAN_STA_WPS|WLAN_STA_MAYBE_WPS)))
 		{
-			if(pmlmepriv->wps_beacon_ie)
+			if (pmlmepriv->wps_beacon_ie)
 			{
 				u8 selected_registrar = 0;
 
 				rtw_get_wps_attr_content(pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len, WPS_ATTR_SELECTED_REGISTRAR , &selected_registrar, NULL);
 
-				if(!selected_registrar)
+				if (!selected_registrar)
 				{
 					DBG_8192D("selected_registrar is false , or AP is not ready to do WPS\n");
 
@@ -1687,7 +1687,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 	{
 		int copy_len;
 
-		if(psecuritypriv->wpa_psk == 0)
+		if (psecuritypriv->wpa_psk == 0)
 		{
 			DBG_8192D("STA %pM: WPA/RSN IE in association "
 			"request, but AP don't support WPA/RSN\n", pstat->hwaddr);
@@ -1711,7 +1711,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 		}
 
 
-		if(copy_len>0)
+		if (copy_len>0)
 			memcpy(pstat->wpa_ie, wpa_ie-2, copy_len);
 
 	}
@@ -1742,29 +1742,29 @@ unsigned int OnAssocReq(struct rtw_adapt
 
 					pstat->max_sp_len = (pstat->qos_info>>5)&0x3;
 
-					if((pstat->qos_info&0xf) !=0xf)
+					if ((pstat->qos_info&0xf) !=0xf)
 						pstat->has_legacy_ac = true;
 					else
 						pstat->has_legacy_ac = false;
 
-					if(pstat->qos_info&0xf)
+					if (pstat->qos_info&0xf)
 					{
-						if(pstat->qos_info&BIT(0))
+						if (pstat->qos_info&BIT(0))
 							pstat->uapsd_vo = BIT(0)|BIT(1);
 						else
 							pstat->uapsd_vo = 0;
 
-						if(pstat->qos_info&BIT(1))
+						if (pstat->qos_info&BIT(1))
 							pstat->uapsd_vi = BIT(0)|BIT(1);
 						else
 							pstat->uapsd_vi = 0;
 
-						if(pstat->qos_info&BIT(2))
+						if (pstat->qos_info&BIT(2))
 							pstat->uapsd_bk = BIT(0)|BIT(1);
 						else
 							pstat->uapsd_bk = 0;
 
-						if(pstat->qos_info&BIT(3))
+						if (pstat->qos_info&BIT(3))
 							pstat->uapsd_be = BIT(0)|BIT(1);
 						else
 							pstat->uapsd_be = 0;
@@ -1797,7 +1797,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 		pstat->flags &= ~WLAN_STA_HT;
 
 
-	if((pmlmepriv->htpriv.ht_option == false) && (pstat->flags&WLAN_STA_HT))
+	if ((pmlmepriv->htpriv.ht_option == false) && (pstat->flags&WLAN_STA_HT))
 	{
 		status = _STATS_FAILURE_;
 		goto OnAssocReqFail;
@@ -1838,12 +1838,12 @@ unsigned int OnAssocReq(struct rtw_adapt
 
 #ifdef CONFIG_P2P
 	pstat->is_p2p_device = false;
-	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
-		if( (p2pie=rtw_get_p2p_ie(pframe + WLAN_HDR_A3_LEN + ie_offset , pkt_len - WLAN_HDR_A3_LEN - ie_offset , NULL, &p2pielen)))
+		if ( (p2pie=rtw_get_p2p_ie(pframe + WLAN_HDR_A3_LEN + ie_offset , pkt_len - WLAN_HDR_A3_LEN - ie_offset , NULL, &p2pielen)))
 		{
 			pstat->is_p2p_device = true;
-			if((p2p_status_code=(u8)process_assoc_req_p2p_ie(pwdinfo, pframe, pkt_len, pstat))>0)
+			if ((p2p_status_code=(u8)process_assoc_req_p2p_ie(pwdinfo, pframe, pkt_len, pstat))>0)
 			{
 				pstat->p2p_status_code = p2p_status_code;
 				status = _STATS_CAP_FAIL_;
@@ -1851,7 +1851,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 			}
 		}
 #ifdef CONFIG_WFD
-		if(rtw_get_wfd_ie(pframe + WLAN_HDR_A3_LEN + ie_offset , pkt_len - WLAN_HDR_A3_LEN - ie_offset , wfd_ie, &wfd_ielen ))
+		if (rtw_get_wfd_ie(pframe + WLAN_HDR_A3_LEN + ie_offset , pkt_len - WLAN_HDR_A3_LEN - ie_offset , wfd_ie, &wfd_ielen ))
 		{
 			u8	attr_content[ 10 ] = { 0x00 };
 			u32	attr_contentlen = 0;
@@ -1925,7 +1925,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	// now the station is qualified to join our BSS...
-	if(pstat && (pstat->state & WIFI_FW_ASSOC_SUCCESS) && (_STATS_SUCCESSFUL_==status))
+	if (pstat && (pstat->state & WIFI_FW_ASSOC_SUCCESS) && (_STATS_SUCCESSFUL_==status))
 	{
 #ifdef CONFIG_NATIVEAP_MLME
 		//.1 bss_cap_update & sta_info_update
@@ -1953,7 +1953,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 			pstat->assoc_req_len = 0;
 
 			pstat->passoc_req =  rtw_zmalloc(pkt_len);
-			if(pstat->passoc_req) {
+			if (pstat->passoc_req) {
 				memcpy(pstat->passoc_req, pframe, pkt_len);
 				pstat->assoc_req_len = pkt_len;
 			}
@@ -2140,7 +2140,7 @@ unsigned int OnDeAuth(struct rtw_adapter
 	DBG_8192D("%s Reason code(%d)\n", __func__,reason);
 
 #ifdef CONFIG_AP_MODE
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &padapter->stapriv;
@@ -2148,12 +2148,12 @@ unsigned int OnDeAuth(struct rtw_adapter
 		DBG_8192D("%s, STA: %pM\n", __func__, GetAddr2Ptr(pframe));
 
 		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
-		if(psta)
+		if (psta)
 		{
 			u8 updated;
 
 			spin_lock_bh(&pstapriv->asoc_list_lock);
-			if(rtw_is_list_empty(&psta->asoc_list)==false)
+			if (rtw_is_list_empty(&psta->asoc_list)==false)
 			{
 				rtw_list_delete(&psta->asoc_list);
 				pstapriv->asoc_list_cnt--;
@@ -2208,7 +2208,7 @@ unsigned int OnDisassoc(struct rtw_adapt
         DBG_8192D("%s Reason code(%d)\n", __func__,reason);
 
 #ifdef CONFIG_AP_MODE
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &padapter->stapriv;
@@ -2216,12 +2216,12 @@ unsigned int OnDisassoc(struct rtw_adapt
 		DBG_8192D("%s, STA: %pM\n", __func__, GetAddr2Ptr(pframe));
 
 		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
-		if(psta)
+		if (psta)
 		{
 			u8 updated;
 
 			spin_lock_bh(&pstapriv->asoc_list_lock);
-			if(rtw_is_list_empty(&psta->asoc_list)==false)
+			if (rtw_is_list_empty(&psta->asoc_list)==false)
 			{
 				rtw_list_delete(&psta->asoc_list);
 				pstapriv->asoc_list_cnt--;
@@ -2330,7 +2330,7 @@ unsigned int on_action_spct(struct rtw_a
 		goto exit;
 
 	category = frame_body[0];
-	if(category != RTW_WLAN_CATEGORY_SPECTRUM_MGMT)
+	if (category != RTW_WLAN_CATEGORY_SPECTRUM_MGMT)
 		goto exit;
 
 	action = frame_body[1];
@@ -2388,14 +2388,14 @@ unsigned int OnAction_back(struct rtw_ad
 */
 	DBG_8192D("%s\n", __func__);
 
-	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+	if ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
 		if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
 			return _SUCCESS;
 
 	addr = GetAddr2Ptr(pframe);
 	psta = rtw_get_stainfo(pstapriv, addr);
 
-	if(psta==NULL)
+	if (psta==NULL)
 		return _SUCCESS;
 
 	frame_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
@@ -2404,7 +2404,7 @@ unsigned int OnAction_back(struct rtw_ad
 	if (category == RTW_WLAN_CATEGORY_BACK)// representing Block Ack
 	{
 #ifdef CONFIG_TDLS
-		if((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
+		if ((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
 			(psta->htpriv.ht_option==true) &&
 			(psta->htpriv.ampdu_enable==true) )
 		{
@@ -2427,7 +2427,7 @@ unsigned int OnAction_back(struct rtw_ad
 				//process_addba_req(padapter, (u8*)&(pmlmeinfo->ADDBA_req), GetAddr3Ptr(pframe));
 				process_addba_req(padapter, (u8*)&(pmlmeinfo->ADDBA_req), addr);
 
-				if(pmlmeinfo->bAcceptAddbaReq == true)
+				if (pmlmeinfo->bAcceptAddbaReq == true)
 				{
 					issue_action_BA(padapter, addr, RTW_WLAN_ACTION_ADDBA_RESP, 0);
 				}
@@ -2467,7 +2467,7 @@ unsigned int OnAction_back(struct rtw_ad
 					//reason_code = frame_body[4] | (frame_body[5] << 8);
 					reason_code = RTW_GET_LE16(&frame_body[4]);
 				}
-				else if((frame_body[3] & BIT(3)) == BIT(3))
+				else if ((frame_body[3] & BIT(3)) == BIT(3))
 				{
 					tid = (frame_body[3] >> 4) & 0x0F;
 
@@ -3097,7 +3097,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	//	Commented by Kurt 20120113
 	//	If some device wants to do p2p handshake without sending prov_disc_req
 	//	We have to get peer_req_cm from here.
-	if(_rtw_memcmp( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3) )
+	if (_rtw_memcmp( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3) )
 	{
 		if ( wps_devicepassword_id == WPS_DPID_USER_SPEC )
 		{
@@ -4130,9 +4130,9 @@ void issue_p2p_invitation_response(struc
 	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P GO
 	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P Client
 
-	if( status_code == P2P_STATUS_SUCCESS )
+	if ( status_code == P2P_STATUS_SUCCESS )
 	{
-		if( rtw_p2p_chk_role( pwdinfo, P2P_ROLE_GO ) )
+		if ( rtw_p2p_chk_role( pwdinfo, P2P_ROLE_GO ) )
 		{
 			//	The P2P Invitation request frame asks this Wi-Fi device to be the P2P GO
 			//	In this case, the P2P Invitation response frame should carry the two more P2P attributes.
@@ -4524,7 +4524,7 @@ void issue_probersp_p2p(struct rtw_adapt
 
 	// DS parameter set
 #ifdef CONFIG_IOCTL_CFG80211
-	if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && listen_channel !=0 )
+	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && listen_channel !=0 )
 	{
 		pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&listen_channel, &pattrib->pktlen);
 	}
@@ -4536,9 +4536,9 @@ void issue_probersp_p2p(struct rtw_adapt
 
 
 #ifdef CONFIG_IOCTL_CFG80211
-	if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
+	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
 	{
-		if( pmlmepriv->wps_probe_resp_ie != NULL && pmlmepriv->p2p_probe_resp_ie != NULL )
+		if ( pmlmepriv->wps_probe_resp_ie != NULL && pmlmepriv->p2p_probe_resp_ie != NULL )
 		{
 			//WPS IE
 			memcpy(pframe, pmlmepriv->wps_probe_resp_ie, pmlmepriv->wps_probe_resp_ie_len);
@@ -4579,7 +4579,7 @@ void issue_probersp_p2p(struct rtw_adapt
 #ifdef CONFIG_INTEL_WIDI
 		//	Commented by Kurt
 		//	Appended WiDi info. only if we did issued_probereq_widi(), and then we saved ven. ext. in pmlmepriv->sa_ext.
-		if(  _rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == false )
+		if (  _rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == false )
 		{
 			//Sec dev type
 			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_SEC_DEV_TYPE_LIST );
@@ -4852,7 +4852,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 	pframe += sizeof (struct rtw_ieee80211_hdr_3addr);
 	pattrib->pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
 	{
 		pframe = rtw_set_ie(pframe, _SSID_IE_, pwdinfo->tx_prov_disc_info.ssid.SsidLength, pwdinfo->tx_prov_disc_info.ssid.Ssid, &(pattrib->pktlen));
 	}
@@ -4864,9 +4864,9 @@ int _issue_probereq_p2p(struct rtw_adapt
 	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pwdinfo->support_rate, &pattrib->pktlen);
 
 #ifdef CONFIG_IOCTL_CFG80211
-	if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
+	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
 	{
-		if( pmlmepriv->wps_probe_req_ie != NULL && pmlmepriv->p2p_probe_req_ie != NULL )
+		if ( pmlmepriv->wps_probe_req_ie != NULL && pmlmepriv->p2p_probe_req_ie != NULL )
 		{
 			//WPS IE
 			memcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);
@@ -4904,7 +4904,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 		//	Value:
 		wpsie[wpsielen++] = WPS_VERSION_1;	//	Version 1.0
 
-		if( pmlmepriv->wps_probe_req_ie == NULL )
+		if ( pmlmepriv->wps_probe_req_ie == NULL )
 		{
 			//	UUID-E
 			//	Type:
@@ -5086,7 +5086,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 
 		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
 
-		if( pmlmepriv->wps_probe_req_ie != NULL )
+		if ( pmlmepriv->wps_probe_req_ie != NULL )
 		{
 			//WPS IE
 			memcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);
@@ -5150,7 +5150,7 @@ int issue_probereq_p2p_ex(struct rtw_ada
 		if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
 			break;
 
-		if(i < try_cnt && wait_ms > 0 && ret==_FAIL)
+		if (i < try_cnt && wait_ms > 0 && ret==_FAIL)
 			rtw_msleep_os(wait_ms);
 
 	}while((i<try_cnt) && ((ret==_FAIL)||(wait_ms==0)));
@@ -5237,7 +5237,7 @@ unsigned int on_action_public_p2p(union
 #ifdef CONFIG_P2P
 	_cancel_timer_ex( &pwdinfo->reset_ch_sitesurvey );
 #ifdef CONFIG_IOCTL_CFG80211
-	if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
+	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
 	{
 		rtw_cfg80211_rx_p2p_action_public(padapter, pframe, len);
 	}
@@ -5245,7 +5245,7 @@ unsigned int on_action_public_p2p(union
 #endif //CONFIG_IOCTL_CFG80211
 	{
 		//	Do nothing if the driver doesn't enable the P2P function.
-		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
+		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 			return _SUCCESS;
 
 		len -= sizeof(struct rtw_ieee80211_hdr_3addr);
@@ -5257,12 +5257,12 @@ unsigned int on_action_public_p2p(union
 				DBG_8192D( "[%s] Got GO Nego Req Frame\n", __func__);
 				memset( &pwdinfo->groupid_info, 0x00, sizeof( struct group_id_info ) );
 
-				if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ))
+				if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ))
 				{
 					rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
 				}
 
-				if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
+				if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
 				{
 					//	Commented by Albert 20110526
 					//	In this case, this means the previous nego fail doesn't be reset yet.
@@ -5280,18 +5280,18 @@ unsigned int on_action_public_p2p(union
 
 				//	Commented by Kurt 20110902
 				//Add if statement to avoid receiving duplicate prov disc req. such that pre_p2p_state would be covered.
-				if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
+				if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
 					rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
 
 				//	Commented by Kurt 20120113
 				//	Get peer_dev_addr here if peer doesn't issue prov_disc frame.
-				if( _rtw_memcmp(pwdinfo->rx_prov_disc_info.peerDevAddr, empty_addr, ETH_ALEN) );
+				if ( _rtw_memcmp(pwdinfo->rx_prov_disc_info.peerDevAddr, empty_addr, ETH_ALEN) );
 					memcpy(pwdinfo->rx_prov_disc_info.peerDevAddr, GetAddr2Ptr(pframe), ETH_ALEN);
 
 				result = process_p2p_group_negotation_req( pwdinfo, frame_body, len );
 				issue_p2p_GO_response( padapter, GetAddr2Ptr(pframe), frame_body, len, result );
 #ifdef CONFIG_INTEL_WIDI
-				if( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
+				if ( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
 				{
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
@@ -5312,7 +5312,7 @@ unsigned int on_action_public_p2p(union
 			{
 				DBG_8192D( "[%s] Got GO Nego Resp Frame\n", __func__);
 
-				if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
+				if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
 				{
 					//	Commented by Albert 20110425
 					//	The restore timer is enabled when issuing the nego request frame of rtw_p2p_connect function.
@@ -5333,7 +5333,7 @@ unsigned int on_action_public_p2p(union
 					//	Reset the dialog token for group negotiation frames.
 					pwdinfo->negotiation_dialog_token = 1;
 
-					if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
+					if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
 					{
 						_set_timer( &pwdinfo->restore_p2p_state_timer, 5000 );
 					}
@@ -5417,7 +5417,7 @@ unsigned int on_action_public_p2p(union
 										u8 operatingch_info[5] = { 0x00 };
 										if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen) )
 										{
-											if( rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, (u32)operatingch_info[4] ) )
+											if ( rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, (u32)operatingch_info[4] ) )
 											{
 												//	The operating channel is acceptable for this device.
 												pwdinfo->rx_invitereq_info.operation_ch[0]= operatingch_info[4];
@@ -5511,7 +5511,7 @@ unsigned int on_action_public_p2p(union
 					issue_p2p_invitation_response( padapter, GetAddr2Ptr(pframe), pwdinfo->inviteresp_info.token, status_code );
 				}
 #ifdef CONFIG_INTEL_WIDI
-				if( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
+				if ( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
 				{
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
@@ -5590,13 +5590,13 @@ unsigned int on_action_public_p2p(union
 
 				//20110902 Kurt
 				//Add the following statement to avoid receiving duplicate prov disc req. such that pre_p2p_state would be covered.
-				if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ))
+				if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ))
 					rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
 
 				rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ);
 				_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT );
 #ifdef CONFIG_INTEL_WIDI
-				if( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
+				if ( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
 				{
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
@@ -5677,7 +5677,7 @@ unsigned int on_action_public(struct rtw
 		goto exit;
 
 	category = frame_body[0];
-	if(category != RTW_WLAN_CATEGORY_PUBLIC)
+	if (category != RTW_WLAN_CATEGORY_PUBLIC)
 		goto exit;
 
 	action = frame_body[1];
@@ -5723,14 +5723,14 @@ unsigned int OnAction_p2p(struct rtw_ada
 	frame_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
 
 	category = frame_body[0];
-	if(category != RTW_WLAN_CATEGORY_P2P)
+	if (category != RTW_WLAN_CATEGORY_P2P)
 		return _SUCCESS;
 
 	if ( cpu_to_be32( *( ( u32* ) ( frame_body + 1 ) ) ) != P2POUI )
 		return _SUCCESS;
 
 #ifdef CONFIG_IOCTL_CFG80211
-	if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
+	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
 	{
 		rtw_cfg80211_rx_action_p2p(padapter, pframe, len);
 		return _SUCCESS;
@@ -5789,7 +5789,7 @@ unsigned int OnAction(struct rtw_adapter
 	{
 		ptable = &OnAction_tbl[i];
 
-		if(category == ptable->num)
+		if (category == ptable->num)
 			ptable->func(padapter, precv_frame);
 
 	}
@@ -5865,7 +5865,7 @@ void update_mgntframe_attrib(struct rtw_
 
 	pattrib->pktlen = 0;
 
-	if(pmlmeext->cur_wireless_mode & WIRELESS_11B)
+	if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
 		pattrib->raid = 6;//b mode
 	else
 		pattrib->raid = 5;//a/g mode
@@ -5887,7 +5887,7 @@ void update_mgntframe_attrib(struct rtw_
 
 void dump_mgntframe(struct rtw_adapter *padapter, struct xmit_frame *pmgntframe)
 {
-	if(padapter->bSurpriseRemoved == true ||
+	if (padapter->bSurpriseRemoved == true ||
 		padapter->bDriverStopped == true)
 		return;
 
@@ -5900,7 +5900,7 @@ s32 dump_mgntframe_and_wait(struct rtw_a
 	struct xmit_buf *pxmitbuf = pmgntframe->pxmitbuf;
 	struct submit_ctx sctx;
 
-	if(padapter->bSurpriseRemoved == true ||
+	if (padapter->bSurpriseRemoved == true ||
 		padapter->bDriverStopped == true)
 		return ret;
 
@@ -5926,7 +5926,7 @@ s32 dump_mgntframe_and_wait_ack(struct r
 		pxmitpriv = &(padapter->pbuddy_adapter->xmitpriv);
 	#endif
 
-	if(padapter->bSurpriseRemoved == true ||
+	if (padapter->bSurpriseRemoved == true ||
 		padapter->bDriverStopped == true)
 		return -1;
 
@@ -5959,7 +5959,7 @@ int update_hidden_ssid(u8 *ies, u32 ies_
 
 	//DBG_8192D("%s hidden_ssid_mode:%u, ssid_ie:%p, ssid_len_ori:%d\n", __func__, hidden_ssid_mode, ssid_ie, ssid_len_ori);
 
-	if(ssid_ie && ssid_len_ori>0)
+	if (ssid_ie && ssid_len_ori>0)
 	{
 		switch(hidden_ssid_mode)
 		{
@@ -6044,7 +6044,7 @@ void issue_beacon(struct rtw_adapter *pa
 	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
 	pattrib->pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
 
-	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	if ( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 		//DBG_8192D("ie len=%d\n", cur_network->IELength);
 #ifdef CONFIG_P2P
@@ -6053,7 +6053,7 @@ void issue_beacon(struct rtw_adapter *pa
 		u8 *wpsie=NULL;
 		wpsie = rtw_get_wps_ie(cur_network->IEs+_FIXED_IE_LENGTH_, cur_network->IELength-_FIXED_IE_LENGTH_, NULL, &wpsielen);
 
-		if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && wpsie && wpsielen>0)
+		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && wpsie && wpsielen>0)
 		{
 			uint wps_offset, remainder_ielen;
 			u8 *premainder_ie, *pframe_wscie;
@@ -6065,9 +6065,9 @@ void issue_beacon(struct rtw_adapter *pa
 			remainder_ielen = cur_network->IELength - wps_offset - wpsielen;
 
 #ifdef CONFIG_IOCTL_CFG80211
-			if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
+			if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
 			{
-				if(pmlmepriv->wps_beacon_ie && pmlmepriv->wps_beacon_ie_len>0)
+				if (pmlmepriv->wps_beacon_ie && pmlmepriv->wps_beacon_ie_len>0)
 				{
 					memcpy(pframe, cur_network->IEs, wps_offset);
 					pframe += wps_offset;
@@ -6178,14 +6178,14 @@ void issue_beacon(struct rtw_adapter *pa
 		}
 
 #ifdef CONFIG_P2P
-		if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 		{
 			u32 len;
 #ifdef CONFIG_IOCTL_CFG80211
-			if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
+			if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
 			{
 				len = pmlmepriv->p2p_beacon_ie_len;
-				if(pmlmepriv->p2p_beacon_ie && len>0)
+				if (pmlmepriv->p2p_beacon_ie && len>0)
 					memcpy(pframe, pmlmepriv->p2p_beacon_ie, len);
 			}
 			else
@@ -6198,7 +6198,7 @@ void issue_beacon(struct rtw_adapter *pa
 			pattrib->pktlen += len;
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
-			if(true == pwdinfo->wfd_info->wfd_enable)
+			if (true == pwdinfo->wfd_info->wfd_enable)
 #endif //CONFIG_IOCTL_CFG80211
 			{
 			len = build_beacon_wfd_ie( pwdinfo, pframe );
@@ -6207,7 +6207,7 @@ void issue_beacon(struct rtw_adapter *pa
 			else
 			{
 				len = 0;
-				if(pmlmepriv->wfd_beacon_ie && pmlmepriv->wfd_beacon_ie_len>0)
+				if (pmlmepriv->wfd_beacon_ie && pmlmepriv->wfd_beacon_ie_len>0)
 				{
 					len = pmlmepriv->wfd_beacon_ie_len;
 					memcpy(pframe, pmlmepriv->wfd_beacon_ie, len);
@@ -6254,7 +6254,7 @@ void issue_beacon(struct rtw_adapter *pa
 	// DS parameter set
 	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pattrib->pktlen);
 
-	//if( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	//if ( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
 	{
 		u8 erpinfo=0;
 		u32 ATIMWindow;
@@ -6360,16 +6360,16 @@ void issue_probersp(struct rtw_adapter *
 	pframe += pattrib->hdrlen;
 
 
-	if(cur_network->IELength>MAX_IE_SZ)
+	if (cur_network->IELength>MAX_IE_SZ)
 		return;
 
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
-	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	if ( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 		pwps_ie = rtw_get_wps_ie(cur_network->IEs+_FIXED_IE_LENGTH_, cur_network->IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen);
 
 		//inerset & update wps_probe_resp_ie
-		if((pmlmepriv->wps_probe_resp_ie!=NULL) && pwps_ie && (wps_ielen>0))
+		if ((pmlmepriv->wps_probe_resp_ie!=NULL) && pwps_ie && (wps_ielen>0))
 		{
 			uint wps_offset, remainder_ielen;
 			u8 *premainder_ie;
@@ -6385,14 +6385,14 @@ void issue_probersp(struct rtw_adapter *
 			pattrib->pktlen += wps_offset;
 
 			wps_ielen = (uint)pmlmepriv->wps_probe_resp_ie[1];//to get ie data len
-			if((wps_offset+wps_ielen+2)<=MAX_IE_SZ)
+			if ((wps_offset+wps_ielen+2)<=MAX_IE_SZ)
 			{
 				memcpy(pframe, pmlmepriv->wps_probe_resp_ie, wps_ielen+2);
 				pframe += wps_ielen+2;
 				pattrib->pktlen += wps_ielen+2;
 			}
 
-			if((wps_offset+wps_ielen+2+remainder_ielen)<=MAX_IE_SZ)
+			if ((wps_offset+wps_ielen+2+remainder_ielen)<=MAX_IE_SZ)
 			{
 				memcpy(pframe, premainder_ie, remainder_ielen);
 				pframe += remainder_ielen;
@@ -6474,7 +6474,7 @@ void issue_probersp(struct rtw_adapter *
 		// DS parameter set
 		pframe =rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pattrib->pktlen);
 
-		if( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+		if ( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
 		{
 			u8 erpinfo=0;
 			u32 ATIMWindow;
@@ -6500,15 +6500,15 @@ void issue_probersp(struct rtw_adapter *
 	}
 
 #ifdef CONFIG_P2P
-	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && is_valid_p2p_probereq)
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && is_valid_p2p_probereq)
 	{
 		u32 len;
 #ifdef CONFIG_IOCTL_CFG80211
-		if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
+		if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
 		{
 			//if pwdinfo->role == P2P_ROLE_DEVICE will call issue_probersp_p2p()
 			len = pmlmepriv->p2p_go_probe_resp_ie_len;
-			if(pmlmepriv->p2p_go_probe_resp_ie && len>0)
+			if (pmlmepriv->p2p_go_probe_resp_ie && len>0)
 				memcpy(pframe, pmlmepriv->p2p_go_probe_resp_ie, len);
 		}
 		else
@@ -6522,7 +6522,7 @@ void issue_probersp(struct rtw_adapter *
 
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
-		if(true == pwdinfo->wfd_info->wfd_enable)
+		if (true == pwdinfo->wfd_info->wfd_enable)
 #endif //CONFIG_IOCTL_CFG80211
 		{
 			len = build_probe_resp_wfd_ie(pwdinfo, pframe, 0);
@@ -6531,7 +6531,7 @@ void issue_probersp(struct rtw_adapter *
 		else
 		{
 			len = 0;
-			if(pmlmepriv->wfd_probe_resp_ie && pmlmepriv->wfd_probe_resp_ie_len>0)
+			if (pmlmepriv->wfd_probe_resp_ie && pmlmepriv->wfd_probe_resp_ie_len>0)
 			{
 				len = pmlmepriv->wfd_probe_resp_ie_len;
 				memcpy(pframe, pmlmepriv->wfd_probe_resp_ie, len);
@@ -6616,7 +6616,7 @@ int _issue_probereq(struct rtw_adapter *
 	pframe += sizeof (struct rtw_ieee80211_hdr_3addr);
 	pattrib->pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
 
-	if(pssid)
+	if (pssid)
 		pframe = rtw_set_ie(pframe, _SSID_IE_, pssid->SsidLength, pssid->Ssid, &(pattrib->pktlen));
 	else
 		pframe = rtw_set_ie(pframe, _SSID_IE_, 0, NULL, &(pattrib->pktlen));
@@ -6634,7 +6634,7 @@ int _issue_probereq(struct rtw_adapter *
 	}
 
 	//add wps_ie for wps2.0
-	if(pmlmepriv->wps_probe_req_ie_len>0 && pmlmepriv->wps_probe_req_ie)
+	if (pmlmepriv->wps_probe_req_ie_len>0 && pmlmepriv->wps_probe_req_ie)
 	{
 		memcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);
 		pframe += pmlmepriv->wps_probe_req_ie_len;
@@ -6678,7 +6678,7 @@ int issue_probereq_ex(struct rtw_adapter
 		if (padapter->bDriverStopped || padapter->bSurpriseRemoved)
 			break;
 
-		if(i < try_cnt && wait_ms > 0 && ret==_FAIL)
+		if (i < try_cnt && wait_ms > 0 && ret==_FAIL)
 			rtw_msleep_os(wait_ms);
 
 	}while((i<try_cnt) && ((ret==_FAIL)||(wait_ms==0)));
@@ -6744,7 +6744,7 @@ void issue_auth(struct rtw_adapter *pada
 	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 
 
-	if(psta)// for AP mode
+	if (psta)// for AP mode
 	{
 #ifdef CONFIG_NATIVEAP_MLME
 
@@ -6756,7 +6756,7 @@ void issue_auth(struct rtw_adapter *pada
 		// setting auth algo number
 		val16 = (u16)psta->authalg;
 
-		if(status != _STATS_SUCCESSFUL_)
+		if (status != _STATS_SUCCESSFUL_)
 			val16 = 0;
 
 		if (val16)	{
@@ -6937,7 +6937,7 @@ void issue_asocrsp(struct rtw_adapter *p
 		//FILL HT CAP INFO IE
 		//p = hostapd_eid_ht_capabilities_info(hapd, p);
 		pbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_CAPABILITY_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_));
-		if(pbuf && ie_len>0)
+		if (pbuf && ie_len>0)
 		{
 			memcpy(pframe, pbuf, ie_len+2);
 			pframe += (ie_len+2);
@@ -6947,7 +6947,7 @@ void issue_asocrsp(struct rtw_adapter *p
 		//FILL HT ADD INFO IE
 		//p = hostapd_eid_ht_operation(hapd, p);
 		pbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_ADD_INFO_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_));
-		if(pbuf && ie_len>0)
+		if (pbuf && ie_len>0)
 		{
 			memcpy(pframe, pbuf, ie_len+2);
 			pframe += (ie_len+2);
@@ -6966,7 +6966,7 @@ void issue_asocrsp(struct rtw_adapter *p
 		for (pbuf = ie + _BEACON_IE_OFFSET_; ;pbuf+= (ie_len + 2))
 		{
 			pbuf = rtw_get_ie(pbuf, _VENDOR_SPECIFIC_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));
-			if(pbuf && _rtw_memcmp(pbuf+2, WMM_PARA_IE, 6))
+			if (pbuf && _rtw_memcmp(pbuf+2, WMM_PARA_IE, 6))
 			{
 				memcpy(pframe, pbuf, ie_len+2);
 				pframe += (ie_len+2);
@@ -6990,7 +6990,7 @@ void issue_asocrsp(struct rtw_adapter *p
 	}
 
 	//add WPS IE ie for wps 2.0
-	if(pmlmepriv->wps_assoc_resp_ie && pmlmepriv->wps_assoc_resp_ie_len>0)
+	if (pmlmepriv->wps_assoc_resp_ie && pmlmepriv->wps_assoc_resp_ie_len>0)
 	{
 		memcpy(pframe, pmlmepriv->wps_assoc_resp_ie, pmlmepriv->wps_assoc_resp_ie_len);
 
@@ -7000,7 +7000,7 @@ void issue_asocrsp(struct rtw_adapter *p
 
 #ifdef CONFIG_P2P
 #ifndef CONFIG_IOCTL_CFG80211
-	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && (pstat->is_p2p_device == true))
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && (pstat->is_p2p_device == true))
 	{
 		u32 len;
 
@@ -7011,7 +7011,7 @@ void issue_asocrsp(struct rtw_adapter *p
 	}
 #endif //CONFIG_IOCTL_CFG80211
 #ifdef CONFIG_WFD
-	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)
 #ifdef CONFIG_IOCTL_CFG80211
 		&& (true == pwdinfo->wfd_info->wfd_enable)
 #endif //CONFIG_IOCTL_CFG80211
@@ -7095,7 +7095,7 @@ void issue_assocreq(struct rtw_adapter *
 
 #ifdef CONFIG_DFS
 	memcpy(&cap, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
-	if(pmlmeext->cur_channel > 14)
+	if (pmlmeext->cur_channel > 14)
 		cap |= BIT(8); //Spectrum Mgmt. Enabled
 	memcpy(pframe, &cap, 2);
 #else
@@ -7121,7 +7121,7 @@ void issue_assocreq(struct rtw_adapter *
 	get_rate_set(padapter, sta_bssrate, &sta_bssrate_len);
 	//DBG_8192D("sta_bssrate_len=%d\n", sta_bssrate_len);
 
-	if(pmlmeext->cur_channel == 14)// for JAPAN, channel 14 can only uses B Mode(CCK)
+	if (pmlmeext->cur_channel == 14)// for JAPAN, channel 14 can only uses B Mode(CCK)
 	{
 		sta_bssrate_len = 4;
 	}
@@ -7194,7 +7194,7 @@ void issue_assocreq(struct rtw_adapter *
 	}
 
 #ifdef CONFIG_DFS
-	if(pmlmeext->cur_channel > 14)
+	if (pmlmeext->cur_channel > 14)
 	{
 		pow_cap_ele[0] = 13;	// Minimum transmit power capability
 		pow_cap_ele[1] = 21;	// Maximum transmit power capability
@@ -7202,7 +7202,7 @@ void issue_assocreq(struct rtw_adapter *
 
 		//supported channels
 		do{
-			if( pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14 )
+			if ( pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14 )
 			{
 				sup_ch[0] = 1;	//First channel number
 				sup_ch[1] = pmlmeext->channel_set[sup_ch_idx].ChannelNum;	//Number of channel
@@ -7228,7 +7228,7 @@ void issue_assocreq(struct rtw_adapter *
 
 #ifdef CONFIG_80211N_HT
 	//HT caps
-	if(padapter->mlmepriv.htpriv.ht_option==true)
+	if (padapter->mlmepriv.htpriv.ht_option==true)
 	{
 		p = rtw_get_ie((pmlmeinfo->network.IEs + sizeof(struct ndis_802_11_fixed_ies)), _HT_CAPABILITY_IE_, &ie_len, (pmlmeinfo->network.IELength - sizeof(struct ndis_802_11_fixed_ies)));
 		if ((p != NULL) && (!(is_ap_in_tkip(padapter))))
@@ -7236,13 +7236,13 @@ void issue_assocreq(struct rtw_adapter *
 			memcpy(&(pmlmeinfo->HT_caps), (p + 2), sizeof(struct HT_caps_element));
 
 			//to disable 40M Hz support while gd_bw_40MHz_en = 0
-			if( pmlmeext->cur_channel > 14)
+			if ( pmlmeext->cur_channel > 14)
 			{
-				if(pregpriv->cbw40_enable & BIT(1) )
+				if (pregpriv->cbw40_enable & BIT(1) )
 					cbw40_enable=1;
 			}
 			else
-				if(pregpriv->cbw40_enable & BIT(0) )
+				if (pregpriv->cbw40_enable & BIT(0) )
 					cbw40_enable=1;
 
 			if (cbw40_enable == 0)
@@ -7263,7 +7263,7 @@ void issue_assocreq(struct rtw_adapter *
 			{
 				case RF_1T1R:
 
-					if(pregpriv->rx_stbc)
+					if (pregpriv->rx_stbc)
 						pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);//RX STBC One spatial stream
 
 					memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_1R, 16);
@@ -7274,15 +7274,15 @@ void issue_assocreq(struct rtw_adapter *
 				default:
 
 
-					if(pregpriv->special_rf_path)
+					if (pregpriv->special_rf_path)
 					{
-						if(pregpriv->rx_stbc)
+						if (pregpriv->rx_stbc)
 							pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);//RX STBC One spatial stream
 						memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_1R, 16);
 						break;
 					}
 
-					if((pregpriv->rx_stbc == 0x3) ||//enable for 2.4/5 GHz
+					if ((pregpriv->rx_stbc == 0x3) ||//enable for 2.4/5 GHz
 						((pmlmeext->cur_wireless_mode & WIRELESS_11_24N) && (pregpriv->rx_stbc == 0x1)) || //enable for 2.4GHz
 						((pmlmeext->cur_wireless_mode & WIRELESS_11_5N) && (pregpriv->rx_stbc == 0x2)) || //enable for 5GHz
 						(pregpriv->wifi_spec==1))
@@ -7291,7 +7291,7 @@ void issue_assocreq(struct rtw_adapter *
 						pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0200);//RX STBC two spatial stream
 					}
 					#ifdef CONFIG_DISABLE_MCS13TO15
-					if(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40 && (pregpriv->wifi_spec!=1))
+					if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40 && (pregpriv->wifi_spec!=1))
 						memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_2R_MCS13TO15_OFF, 16);
 					else
 					memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_2R, 16);
@@ -7302,7 +7302,7 @@ void issue_assocreq(struct rtw_adapter *
 			}
 #ifdef RTL8192C_RECONFIG_TO_1T1R
 			{
-				if(pregpriv->rx_stbc)
+				if (pregpriv->rx_stbc)
 					pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);//RX STBC One spatial stream
 
 				memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_1R, 16);
@@ -7327,12 +7327,12 @@ void issue_assocreq(struct rtw_adapter *
 						(_rtw_memcmp(pIE->data, WMM_OUI, 4)) ||
 						(_rtw_memcmp(pIE->data, WPS_OUI, 4)))
 				{
-					if(!padapter->registrypriv.wifi_spec)
+					if (!padapter->registrypriv.wifi_spec)
 					{
 						//Commented by Kurt 20110629
 						//In some older APs, WPS handshake
 						//would be fail if we append vender extensions informations to AP
-						if(_rtw_memcmp(pIE->data, WPS_OUI, 4)){
+						if (_rtw_memcmp(pIE->data, WPS_OUI, 4)){
 							pIE->Length=14;
 						}
 					}
@@ -7355,9 +7355,9 @@ void issue_assocreq(struct rtw_adapter *
 #ifdef CONFIG_P2P
 
 #ifdef CONFIG_IOCTL_CFG80211
-	if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
+	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
 	{
-		if(pmlmepriv->p2p_assoc_req_ie && pmlmepriv->p2p_assoc_req_ie_len>0)
+		if (pmlmepriv->p2p_assoc_req_ie && pmlmepriv->p2p_assoc_req_ie_len>0)
 		{
 			memcpy(pframe, pmlmepriv->p2p_assoc_req_ie, pmlmepriv->p2p_assoc_req_ie_len);
 			pframe += pmlmepriv->p2p_assoc_req_ie_len;
@@ -7367,7 +7367,7 @@ void issue_assocreq(struct rtw_adapter *
 	else
 #endif //CONFIG_IOCTL_CFG80211
 	{
-		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
+		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 		{
 			//	Should add the P2P IE in the association request frame.
 			//	P2P OUI
@@ -7557,7 +7557,7 @@ static int _issue_nulldata(struct rtw_ad
 
 	//DBG_8192D("%s:%d\n", __func__, power_mode);
 
-	if(!padapter)
+	if (!padapter)
 		goto exit;
 
 	pxmitpriv = &(padapter->xmitpriv);
@@ -7582,11 +7582,11 @@ static int _issue_nulldata(struct rtw_ad
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
 
-	if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 		SetFrDs(fctrl);
 	}
-	else if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+	else if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
 	{
 		SetToDs(fctrl);
 	}
@@ -7609,7 +7609,7 @@ static int _issue_nulldata(struct rtw_ad
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
-	if(wait_ack)
+	if (wait_ack)
 	{
 		ret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);
 	}
@@ -7647,7 +7647,7 @@ int issue_nulldata(struct rtw_adapter *p
 		if (padapter->bDriverStopped || padapter->bSurpriseRemoved)
 			break;
 
-		if(i < try_cnt && wait_ms > 0 && ret==_FAIL)
+		if (i < try_cnt && wait_ms > 0 && ret==_FAIL)
 			rtw_msleep_os(wait_ms);
 
 	}while((i<try_cnt) && ((ret==_FAIL)||(wait_ms==0)));
@@ -7711,16 +7711,16 @@ static int _issue_qos_nulldata(struct rt
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
 
-	if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 		SetFrDs(fctrl);
 	}
-	else if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+	else if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
 	{
 		SetToDs(fctrl);
 	}
 
-	if(pattrib->mdata)
+	if (pattrib->mdata)
 		SetMData(fctrl);
 
 	qc = (unsigned short *)(pframe + pattrib->hdrlen - 2);
@@ -7744,7 +7744,7 @@ static int _issue_qos_nulldata(struct rt
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
-	if(wait_ack)
+	if (wait_ack)
 	{
 		ret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);
 	}
@@ -7781,7 +7781,7 @@ int issue_qos_nulldata(struct rtw_adapte
 		if (padapter->bDriverStopped || padapter->bSurpriseRemoved)
 			break;
 
-		if(i < try_cnt && wait_ms > 0 && ret==_FAIL)
+		if (i < try_cnt && wait_ms > 0 && ret==_FAIL)
 			rtw_msleep_os(wait_ms);
 
 	}while((i<try_cnt) && ((ret==_FAIL)||(wait_ms==0)));
@@ -7865,7 +7865,7 @@ static int _issue_deauth(struct rtw_adap
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 
-	if(wait_ack)
+	if (wait_ack)
 	{
 		ret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);
 	}
@@ -7901,7 +7901,7 @@ int issue_deauth_ex(struct rtw_adapter *
 		if (padapter->bDriverStopped || padapter->bSurpriseRemoved)
 			break;
 
-		if(i < try_cnt && wait_ms > 0 && ret==_FAIL)
+		if (i < try_cnt && wait_ms > 0 && ret==_FAIL)
 			rtw_msleep_os(wait_ms);
 
 	}while((i<try_cnt) && ((ret==_FAIL)||(wait_ms==0)));
@@ -8091,9 +8091,9 @@ void issue_action_BA(struct rtw_adapter
 				//BA_para_set = cpu_to_le16((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000); //64 buffer size
 				BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000); //64 buffer size
 
-				if(pregpriv->ampdu_amsdu==0)//disabled
+				if (pregpriv->ampdu_amsdu==0)//disabled
 					BA_para_set = cpu_to_le16(BA_para_set & ~BIT(0));
-				else if(pregpriv->ampdu_amsdu==1)//enabled
+				else if (pregpriv->ampdu_amsdu==1)//enabled
 					BA_para_set = cpu_to_le16(BA_para_set | BIT(0));
 				else //auto
 					BA_para_set = cpu_to_le16(BA_para_set);
@@ -8138,10 +8138,10 @@ static void issue_action_BSSCoexistPacke
 	u8 InfoContent[16] = {0};
 	u8 ICS[8][15];
 
-	if((pmlmepriv->num_FortyMHzIntolerant==0) || (pmlmepriv->num_sta_no_ht==0))
+	if ((pmlmepriv->num_FortyMHzIntolerant==0) || (pmlmepriv->num_sta_no_ht==0))
 		return;
 
-	if(true == pmlmeinfo->bwmode_updated)
+	if (true == pmlmeinfo->bwmode_updated)
 		return;
 
 
@@ -8184,7 +8184,7 @@ static void issue_action_BSSCoexistPacke
 
 
 	//
-	if(pmlmepriv->num_FortyMHzIntolerant>0)
+	if (pmlmepriv->num_FortyMHzIntolerant>0)
 	{
 		u8 iedata=0;
 
@@ -8197,7 +8197,7 @@ static void issue_action_BSSCoexistPacke
 
 	//
 	memset(ICS, 0, sizeof(ICS));
-	if(pmlmepriv->num_sta_no_ht>0)
+	if (pmlmepriv->num_sta_no_ht>0)
 	{
 		int i;
 
@@ -8222,14 +8222,14 @@ static void issue_action_BSSCoexistPacke
 			pbss_network = (struct wlan_bssid_ex *)&pnetwork->network;
 
 			p = rtw_get_ie(pbss_network->IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, pbss_network->IELength - _FIXED_IE_LENGTH_);
-			if((p==NULL) || (len==0))//non-HT
+			if ((p==NULL) || (len==0))//non-HT
 			{
-				if((pbss_network->Configuration.DSConfig<=0) || (pbss_network->Configuration.DSConfig>14))
+				if ((pbss_network->Configuration.DSConfig<=0) || (pbss_network->Configuration.DSConfig>14))
 					continue;
 
 				ICS[0][pbss_network->Configuration.DSConfig]=1;
 
-				if(ICS[0][0] == 0)
+				if (ICS[0][0] == 0)
 					ICS[0][0] = 1;
 			}
 
@@ -8240,7 +8240,7 @@ static void issue_action_BSSCoexistPacke
 
 		for(i= 0;i<8;i++)
 		{
-			if(ICS[i][0] == 1)
+			if (ICS[i][0] == 1)
 			{
 				int j, k = 0;
 
@@ -8250,9 +8250,9 @@ static void issue_action_BSSCoexistPacke
 
 				for(j=1;j<=14;j++)
 				{
-					if(ICS[i][j]==1)
+					if (ICS[i][j]==1)
 					{
-						if(k<16)
+						if (k<16)
 						{
 							InfoContent[k] = j; //channel number
 							//SET_BSS_INTOLERANT_ELE_CHANNEL(InfoContent+k, j);
@@ -8286,21 +8286,21 @@ unsigned int send_delba(struct rtw_adapt
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u16 tid;
 
-	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+	if ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
 		if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
 			return _SUCCESS;
 
 	psta = rtw_get_stainfo(pstapriv, addr);
-	if(psta==NULL)
+	if (psta==NULL)
 		return _SUCCESS;
 
 	//DBG_8192D("%s:%s\n", __func__, (initiator==0)?"RX_DIR":"TX_DIR");
 
-	if(initiator==0) // recipient
+	if (initiator==0) // recipient
 	{
 		for(tid = 0;tid<MAXTID;tid++)
 		{
-			if(psta->recvreorder_ctrl[tid].enable == true)
+			if (psta->recvreorder_ctrl[tid].enable == true)
 			{
 				DBG_8192D("rx agg disable tid(%d)\n",tid);
 				issue_action_BA(padapter, addr, RTW_WLAN_ACTION_DELBA, (((tid <<1) |initiator)&0x1F));
@@ -8313,12 +8313,12 @@ unsigned int send_delba(struct rtw_adapt
 			}
 		}
 	}
-	else if(initiator == 1)// originator
+	else if (initiator == 1)// originator
 	{
 		//DBG_8192D("tx agg_enable_bitmap(0x%08x)\n", psta->htpriv.agg_enable_bitmap);
 		for(tid = 0;tid<MAXTID;tid++)
 		{
-			if(psta->htpriv.agg_enable_bitmap & BIT(tid))
+			if (psta->htpriv.agg_enable_bitmap & BIT(tid))
 			{
 				DBG_8192D("tx agg disable tid(%d)\n",tid);
 				issue_action_BA(padapter, addr, RTW_WLAN_ACTION_DELBA, (((tid <<1) |initiator)&0x1F) );
@@ -8353,15 +8353,15 @@ unsigned int send_beacon(struct rtw_adap
 
 	}while(false == bxmitok && issue<100 && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);
 
-	if(padapter->bSurpriseRemoved || padapter->bDriverStopped)
+	if (padapter->bSurpriseRemoved || padapter->bDriverStopped)
 		return _FAIL;
-	if(false == bxmitok) {
+	if (false == bxmitok) {
 		DBG_8192D("%s fail! %u ms\n", __func__, rtw_get_passing_time_ms(start));
 		return _FAIL;
 	} else {
 		u32 passing_time = rtw_get_passing_time_ms(start);
 
-		if(passing_time > 100 || issue > 3)
+		if (passing_time > 100 || issue > 3)
 			DBG_8192D("%s success, issue:%d, poll:%d, %u ms\n", __func__, issue, poll, rtw_get_passing_time_ms(start));
 		return _SUCCESS;
 	}
@@ -8384,7 +8384,7 @@ bool IsLegal5GChannel(
 		124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,
 		161,163,165};
 	for(i=0;i<sizeof(Channel_5G);i++)
-		if(channel == Channel_5G[i])
+		if (channel == Channel_5G[i])
 			return true;
 	return false;
 }
@@ -8427,7 +8427,7 @@ void site_survey(struct rtw_adapter *pad
 		}
 		ScanType = SCAN_ACTIVE;
 	}
-	else if(rtw_p2p_findphase_ex_is_social(pwdinfo))
+	else if (rtw_p2p_findphase_ex_is_social(pwdinfo))
 	{
 		//	Commented by Albert 2011/06/03
 		//	The driver is in the find phase, it should go through the social channel.
@@ -8460,7 +8460,7 @@ void site_survey(struct rtw_adapter *pad
 		, pmlmeext->sitesurvey_res.ssid[0].SsidLength?'S':' '
 	);
 
-	if(survey_channel != 0)
+	if (survey_channel != 0)
 	{
 		//PAUSE 4-AC Queue when site_survey
 		//rtw_hal_get_hwreg(padapter, HW_VAR_TXPAUSE, (u8 *)(&val8));
@@ -8468,9 +8468,9 @@ void site_survey(struct rtw_adapter *pad
 		//rtw_hal_set_hwreg(padapter, HW_VAR_TXPAUSE, (u8 *)(&val8));
 #ifdef CONFIG_CONCURRENT_MODE
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-		if((padapter->pbuddy_adapter->mlmeextpriv.mlmext_info.state&0x03) == WIFI_FW_AP_STATE)
+		if ((padapter->pbuddy_adapter->mlmeextpriv.mlmext_info.state&0x03) == WIFI_FW_AP_STATE)
 		{
-			if( pmlmeinfo->scan_cnt == RTW_SCAN_NUM_OF_CH )
+			if ( pmlmeinfo->scan_cnt == RTW_SCAN_NUM_OF_CH )
 			{
 				pmlmeinfo->scan_cnt = 0;
 				survey_channel = pbuddy_mlmeext->cur_channel;
@@ -8479,14 +8479,14 @@ void site_survey(struct rtw_adapter *pad
 			}
 			else
 			{
-				if( pmlmeinfo->scan_cnt == 0 )
+				if ( pmlmeinfo->scan_cnt == 0 )
 					stay_buddy_ch = 2;
 				pmlmeinfo->scan_cnt++;
 			}
 		}
 #endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 #endif //CONFIG_CONCURRENT_MODE
-		if(pmlmeext->sitesurvey_res.channel_idx == 0)
+		if (pmlmeext->sitesurvey_res.channel_idx == 0)
 		{
 			set_channel_bwmode(padapter, survey_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 		}
@@ -8496,28 +8496,28 @@ void site_survey(struct rtw_adapter *pad
 		}
 
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-		if( stay_buddy_ch == 1 )
+		if ( stay_buddy_ch == 1 )
 		{
 			val8 = 0; //survey done
 			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 
-			if(check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&
+			if (check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&
 				check_buddy_fwstate(padapter, _FW_LINKED))
 			{
 				update_beacon(padapter->pbuddy_adapter, 0, NULL, true);
 			}
 		}
-		else if( stay_buddy_ch == 2 )
+		else if ( stay_buddy_ch == 2 )
 		{
 			val8 = 1; //under site survey
 			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 		}
 #endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 
-		if(ScanType == SCAN_ACTIVE) //obey the channel plan setting...
+		if (ScanType == SCAN_ACTIVE) //obey the channel plan setting...
 		{
 			#ifdef CONFIG_P2P
-			if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) ||
+			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) ||
 				rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH)
 			)
 			{
@@ -8530,7 +8530,7 @@ void site_survey(struct rtw_adapter *pad
 			{
 				int i;
 				for(i=0;i<RTW_SSID_SCAN_AMOUNT;i++){
-					if(pmlmeext->sitesurvey_res.ssid[i].SsidLength) {
+					if (pmlmeext->sitesurvey_res.ssid[i].SsidLength) {
 						//todo: to issue two probe req???
 						issue_probereq(padapter, &(pmlmeext->sitesurvey_res.ssid[i]), NULL);
 						//rtw_msleep_os(SURVEY_TO>>1);
@@ -8540,7 +8540,7 @@ void site_survey(struct rtw_adapter *pad
 					}
 				}
 
-				if(pmlmeext->sitesurvey_res.scan_mode == SCAN_ACTIVE) {
+				if (pmlmeext->sitesurvey_res.scan_mode == SCAN_ACTIVE) {
 					//todo: to issue two probe req???
 					issue_probereq(padapter, NULL, NULL);
 					//rtw_msleep_os(SURVEY_TO>>1);
@@ -8550,7 +8550,7 @@ void site_survey(struct rtw_adapter *pad
 		}
 
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-		if( stay_buddy_ch == 1 )
+		if ( stay_buddy_ch == 1 )
 			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time * RTW_STAY_AP_CH_MILLISECOND );
 		else
 #endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
@@ -8567,14 +8567,14 @@ void site_survey(struct rtw_adapter *pad
 		u8 cur_bwmode;
 		u8 cur_ch_offset;
 
-		if(check_fwstate(pmlmepriv, _FW_LINKED))
+		if (check_fwstate(pmlmepriv, _FW_LINKED))
 		{
 			cur_channel = pmlmeext->cur_channel;
 			cur_bwmode = pmlmeext->cur_bwmode;
 			cur_ch_offset = pmlmeext->cur_ch_offset;
 		}
-		//else if((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
-		else if(check_buddy_fwstate(padapter, _FW_LINKED)) // for AP or STA
+		//else if ((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+		else if (check_buddy_fwstate(padapter, _FW_LINKED)) // for AP or STA
 		{
 			cur_channel = pbuddy_mlmeext->cur_channel;
 			cur_bwmode = pbuddy_mlmeext->cur_bwmode;
@@ -8590,9 +8590,9 @@ void site_survey(struct rtw_adapter *pad
 
 
 #ifdef CONFIG_P2P
-		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH))
+		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH))
 		{
-			if( ( pwdinfo->rx_invitereq_info.scan_op_ch_only ) || ( pwdinfo->p2p_info.scan_op_ch_only ) )
+			if ( ( pwdinfo->rx_invitereq_info.scan_op_ch_only ) || ( pwdinfo->p2p_info.scan_op_ch_only ) )
 			{
 				//	Set the find_phase_state_exchange_cnt to P2P_FINDPHASE_EX_CNT.
 				//	This will let the following flow to run the scanning end.
@@ -8603,7 +8603,7 @@ void site_survey(struct rtw_adapter *pad
 			#endif
 		}
 
-		if(rtw_p2p_findphase_ex_is_needed(pwdinfo))
+		if (rtw_p2p_findphase_ex_is_needed(pwdinfo))
 		{
 			//	Set the P2P State to the listen state of find phase and set the current channel to the listen channel
 			set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
@@ -8630,7 +8630,7 @@ void site_survey(struct rtw_adapter *pad
 			// 20100721:Interrupt scan operation here.
 			// For SW antenna diversity before link, it needs to switch to another antenna and scan again.
 			// It compares the scan result and select beter one to do connection.
-			if(rtw_hal_antdiv_before_linked(padapter))
+			if (rtw_hal_antdiv_before_linked(padapter))
 			{
 				pmlmeext->sitesurvey_res.bss_cnt = 0;
 				pmlmeext->sitesurvey_res.channel_idx = -1;
@@ -8641,7 +8641,7 @@ void site_survey(struct rtw_adapter *pad
 #endif
 
 #ifdef CONFIG_P2P
-			if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH))
+			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH))
 			{
 			#ifdef CONFIG_CONCURRENT_MODE
 				#ifndef CONFIG_IOCTL_CFG80211
@@ -8668,7 +8668,7 @@ void site_survey(struct rtw_adapter *pad
 				dc_set_channel_bwmode_survey_done(padapter);
 #else
 #ifndef CONFIG_IOCTL_CFG80211
-				if( rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN) )
+				if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN) )
 				{
 					set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 				}
@@ -8703,7 +8703,7 @@ void site_survey(struct rtw_adapter *pad
 				issue_nulldata(padapter, NULL, 0, 3, 500);
 
 #ifdef CONFIG_CONCURRENT_MODE
-				if(is_client_associated_to_ap(padapter->pbuddy_adapter) == true)
+				if (is_client_associated_to_ap(padapter->pbuddy_adapter) == true)
 				{
 					DBG_8192D("adapter is surveydone(buddy_adapter is linked), issue nulldata(pwrbit=0)\n");
 
@@ -8712,7 +8712,7 @@ void site_survey(struct rtw_adapter *pad
 #endif
 			}
 #ifdef CONFIG_CONCURRENT_MODE
-			else if(is_client_associated_to_ap(padapter->pbuddy_adapter) == true)
+			else if (is_client_associated_to_ap(padapter->pbuddy_adapter) == true)
 			{
 				issue_nulldata(padapter->pbuddy_adapter, NULL, 0, 3, 500);
 			}
@@ -8730,7 +8730,7 @@ void site_survey(struct rtw_adapter *pad
 		}
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if(check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&
+		if (check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&
 			check_buddy_fwstate(padapter, _FW_LINKED))
 		{
 
@@ -8773,7 +8773,7 @@ u8 collect_bss_info(struct rtw_adapter *
 
 	subtype = GetFrameSubType(pframe);
 
-	if(subtype==WIFI_BEACON)
+	if (subtype==WIFI_BEACON)
 		bssid->Reserved[0] = 1;
 	else
 		bssid->Reserved[0] = 0;
@@ -8863,7 +8863,7 @@ u8 collect_bss_info(struct rtw_adapter *
 	{// In 5G, some ap do not have DSSET IE
 		// checking HT info for channel
 		p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_ADD_INFO_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
-		if(p)
+		if (p)
 		{
 			struct HT_info_element *HT_info = (struct HT_info_element *)(p + 2);
 			bssid->Configuration.DSConfig = HT_info->primary_channel;
@@ -8898,17 +8898,17 @@ u8 collect_bss_info(struct rtw_adapter *
 	bssid->Configuration.ATIMWindow = 0;
 
 	//20/40 BSS Coexistence check
-	if((pregistrypriv->wifi_spec==1) && (false == pmlmeinfo->bwmode_updated))
+	if ((pregistrypriv->wifi_spec==1) && (false == pmlmeinfo->bwmode_updated))
 	{
 		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
 		p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
-		if(p && len>0)
+		if (p && len>0)
 		{
 			struct HT_caps_element	*pHT_caps;
 			pHT_caps = (struct HT_caps_element	*)(p + 2);
 
-			if(pHT_caps->u.HT_cap_element.HT_caps_info&BIT(14))
+			if (pHT_caps->u.HT_cap_element.HT_caps_info&BIT(14))
 			{
 				pmlmepriv->num_FortyMHzIntolerant++;
 			}
@@ -8922,14 +8922,14 @@ u8 collect_bss_info(struct rtw_adapter *
 
 #ifdef CONFIG_INTEL_WIDI
 	//process_intel_widi_query_or_tigger(padapter, bssid);
-	if(process_intel_widi_query_or_tigger(padapter, bssid))
+	if (process_intel_widi_query_or_tigger(padapter, bssid))
 	{
 		return _FAIL;
 	}
 #endif // CONFIG_INTEL_WIDI
 
 	#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING) & 1
-	if(strcmp(bssid->Ssid.Ssid, DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED) == 0) {
+	if (strcmp(bssid->Ssid.Ssid, DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED) == 0) {
 		DBG_8192D("Receiving %s(%pM, DSConfig:%u) from ch%u with ss:%3u, sq:%3u, RawRSSI:%3ld\n"
 			, bssid->Ssid.Ssid, bssid->MacAddress, bssid->Configuration.DSConfig
 			, rtw_get_oper_ch(padapter)
@@ -8939,7 +8939,7 @@ u8 collect_bss_info(struct rtw_adapter *
 	#endif
 
 	// mark bss info receving from nearby channel as SignalQuality 101
-	if(bssid->Configuration.DSConfig != rtw_get_oper_ch(padapter))
+	if (bssid->Configuration.DSConfig != rtw_get_oper_ch(padapter))
 	{
 		bssid->PhyInfo.SignalQuality= 101;
 	}
@@ -8964,7 +8964,7 @@ void start_create_ibss(struct rtw_adapte
 	//udpate capability
 	caps = rtw_get_capability((struct wlan_bssid_ex *)pnetwork);
 	update_capinfo(padapter, caps);
-	if(caps&cap_IBSS)//adhoc master
+	if (caps&cap_IBSS)//adhoc master
 	{
 		//set_opmode_cmd(padapter, adhoc);//removed
 
@@ -8982,7 +8982,7 @@ void start_create_ibss(struct rtw_adapte
 		Set_MSR(padapter, (pmlmeinfo->state & 0x3));
 
 		//issue beacon
-		if(send_beacon(padapter)==_FAIL)
+		if (send_beacon(padapter)==_FAIL)
 		{
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("issuing beacon frame fail....\n"));
 
@@ -9031,14 +9031,14 @@ void start_clnt_join(struct rtw_adapter*
 	{
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		dc_join_status = dc_handle_join_request(padapter);
-		if(dc_join_status == _FAIL)
+		if (dc_join_status == _FAIL)
 		{
 			DBG_8192D("dc_handle_join_request for STA fail !!!\n");
 			return;
 		}
 #endif
 #ifdef CONFIG_CONCURRENT_MODE
-		if(concurrent_chk_start_clnt_join(padapter) == _FAIL)
+		if (concurrent_chk_start_clnt_join(padapter) == _FAIL)
 			return;
 #endif
 
@@ -9060,7 +9060,7 @@ void start_clnt_join(struct rtw_adapter*
 	{
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		dc_join_status = dc_handle_join_request(padapter);
-		if(dc_join_status == _FAIL)
+		if (dc_join_status == _FAIL)
 		{
 			DBG_8192D("dc_handle_join_request for Ad-hoc fail !!!\n");
 			return;
@@ -9146,7 +9146,7 @@ unsigned int receive_disconnect(struct r
 
 	DBG_8192D("%s\n", __func__);
 
-	if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
 	{
 		if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
 		{
@@ -9417,7 +9417,7 @@ static void process_80211d(struct rtw_ad
 			if (chplan_new[i].ScanType == SCAN_PASSIVE)
 			{
 				//5G Bnad 2, 3 (DFS) doesn't change to active scan
-				if(channel >= 52 && channel <= 144)
+				if (channel >= 52 && channel <= 144)
 					break;
 
 				chplan_new[i].ScanType = SCAN_ACTIVE;
@@ -9450,7 +9450,7 @@ void report_survey_event(struct rtw_adap
 	//u8 *pframe = precv_frame->u.hdr.rx_data;
 	//uint len = precv_frame->u.hdr.len;
 
-	if(!padapter)
+	if (!padapter)
 		return;
 
 	pmlmeext = &padapter->mlmeextpriv;
@@ -9644,7 +9644,7 @@ void report_del_sta_event(struct rtw_ada
 
 
 	psta = rtw_get_stainfo(&padapter->stapriv, MacAddr);
-	if(psta)
+	if (psta)
 		mac_id = (int)psta->mac_id;
 	else
 		mac_id = (-1);
@@ -9724,7 +9724,7 @@ void update_sta_info(struct rtw_adapter
 
 
 	//HT
-	if(pmlmepriv->htpriv.ht_option)
+	if (pmlmepriv->htpriv.ht_option)
 	{
 		psta->htpriv.ht_option = true;
 
@@ -9756,7 +9756,7 @@ void update_sta_info(struct rtw_adapter
 
 
 	//QoS
-	if(pmlmepriv->qospriv.qos_option)
+	if (pmlmepriv->qospriv.qos_option)
 		psta->qos_option = true;
 
 
@@ -9773,7 +9773,7 @@ void mlmeext_joinbss_event_callback(stru
 	struct sta_priv		*pstapriv = &padapter->stapriv;
 	u8	join_type;
 
-	if(join_res < 0) {
+	if (join_res < 0) {
 		join_type = 1;
 		rtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));
 		rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, null_addr);
@@ -9783,10 +9783,10 @@ void mlmeext_joinbss_event_callback(stru
 		goto exit_mlmeext_joinbss_event_callback;
 	}
 
-	if((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {
 		//for bc/mc
 		psta_bmc = rtw_get_bcmc_stainfo(padapter);
-		if(psta_bmc)
+		if (psta_bmc)
 		{
 			pmlmeinfo->FW_sta_info[psta_bmc->mac_id].psta = psta_bmc;
 			update_bmc_sta_support_rate(padapter, psta_bmc->mac_id);
@@ -9835,7 +9835,7 @@ void mlmeext_joinbss_event_callback(stru
 	join_type = 2;
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));
 
-	if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
 	{
 		// correcting TSF
 		correct_TSF(padapter, pmlmeext);
@@ -9868,9 +9868,9 @@ void mlmeext_sta_add_event_callback(stru
 
 	DBG_8192D("%s\n", __func__);
 
-	if((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
 	{
-		if(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)//adhoc master or sta_count>1
+		if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)//adhoc master or sta_count>1
 		{
 			//nothing to do
 		}
@@ -9883,7 +9883,7 @@ void mlmeext_sta_add_event_callback(stru
 			correct_TSF(padapter, pmlmeext);
 
 			//start beacon
-			if(send_beacon(padapter)==_FAIL)
+			if (send_beacon(padapter)==_FAIL)
 			{
 				pmlmeinfo->FW_sta_info[psta->mac_id].status = 0;
 
@@ -9929,7 +9929,7 @@ void mlmeext_sta_del_event_callback(stru
 		dc_set_channel_bwmode_disconnect(padapter);
 #else
 #ifdef CONFIG_CONCURRENT_MODE
-		if((check_buddy_fwstate(padapter, _FW_LINKED)) != true)
+		if ((check_buddy_fwstate(padapter, _FW_LINKED)) != true)
 		{
 #endif //CONFIG_CONCURRENT_MODE
 
@@ -10036,7 +10036,7 @@ u8 chk_ap_is_alive(struct rtw_adapter *p
 	);
 	#endif
 
-	if((sta_rx_data_pkts(psta) == sta_last_rx_data_pkts(psta))
+	if ((sta_rx_data_pkts(psta) == sta_last_rx_data_pkts(psta))
 		&& sta_rx_beacon_pkts(psta) == sta_last_rx_beacon_pkts(psta)
 		&& sta_rx_probersp_pkts(psta) == sta_last_rx_probersp_pkts(psta)
 	)
@@ -10062,7 +10062,7 @@ void linked_status_chk(struct rtw_adapte
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct sta_priv		*pstapriv = &padapter->stapriv;
 
-	if(padapter->bRxRSSIDisplay)
+	if (padapter->bRxRSSIDisplay)
 		 _linked_rx_signal_strehgth_display(padapter);
 
 	#ifdef DBG_CONFIG_ERROR_DETECT
@@ -10123,7 +10123,7 @@ void linked_status_chk(struct rtw_adapte
 				}
 
 				/* back to the original operation channel */
-				if(backup_oper_channel>0)
+				if (backup_oper_channel>0)
 					SelectChannel(padapter, backup_oper_channel);
 
 			}
@@ -10181,12 +10181,12 @@ void linked_status_chk(struct rtw_adapte
 			{
 				psta = pmlmeinfo->FW_sta_info[i].psta;
 
-				if(NULL==psta) continue;
+				if (NULL==psta) continue;
 
 				if (pmlmeinfo->FW_sta_info[i].rx_pkt == sta_rx_pkts(psta))
 				{
 
-					if(pmlmeinfo->FW_sta_info[i].retry<3)
+					if (pmlmeinfo->FW_sta_info[i].retry<3)
 					{
 						pmlmeinfo->FW_sta_info[i].retry++;
 					}
@@ -10226,18 +10226,18 @@ void survey_timer_hdl(struct rtw_adapter
 	//issue rtw_sitesurvey_cmd
 	if (pmlmeext->sitesurvey_res.state > SCAN_START)
 	{
-		if(pmlmeext->sitesurvey_res.state ==  SCAN_PROCESS)
+		if (pmlmeext->sitesurvey_res.state ==  SCAN_PROCESS)
 		{
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-			if( padapter->mlmeextpriv.mlmext_info.scan_cnt != RTW_SCAN_NUM_OF_CH )
+			if ( padapter->mlmeextpriv.mlmext_info.scan_cnt != RTW_SCAN_NUM_OF_CH )
 #endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 				pmlmeext->sitesurvey_res.channel_idx++;
 		}
 
-		if(pmlmeext->scan_abort == true)
+		if (pmlmeext->scan_abort == true)
 		{
 			#ifdef CONFIG_P2P
-			if(!rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE))
+			if (!rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE))
 			{
 				rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_MAX);
 				pmlmeext->sitesurvey_res.channel_idx = 3;
@@ -10321,14 +10321,14 @@ void addba_timer_hdl(struct sta_info *ps
 {
 	struct ht_priv	*phtpriv;
 
-	if(!psta)
+	if (!psta)
 		return;
 
 	phtpriv = &psta->htpriv;
 
-	if((phtpriv->ht_option==true) && (phtpriv->ampdu_enable==true))
+	if ((phtpriv->ht_option==true) && (phtpriv->ampdu_enable==true))
 	{
-		if(phtpriv->candidate_tid_bitmap)
+		if (phtpriv->candidate_tid_bitmap)
 			phtpriv->candidate_tid_bitmap=0x0;
 
 	}
@@ -10346,7 +10346,7 @@ u8 setopmode_hdl(struct rtw_adapter *pad
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct setopmode_parm *psetop = (struct setopmode_parm *)pbuf;
 
-	if(psetop->mode == NDIS802_11APMODE)
+	if (psetop->mode == NDIS802_11APMODE)
 	{
 		pmlmeinfo->state = WIFI_FW_AP_STATE;
 		type = _HW_STATE_AP_;
@@ -10354,13 +10354,13 @@ u8 setopmode_hdl(struct rtw_adapter *pad
 		//start_ap_mode(padapter);
 #endif
 	}
-	else if(psetop->mode == NDIS802_11INFRA)
+	else if (psetop->mode == NDIS802_11INFRA)
 	{
 		pmlmeinfo->state &= ~(BIT(0)|BIT(1));// clear state
 		pmlmeinfo->state |= WIFI_FW_STATION_STATE;//set to	STATION_STATE
 		type = _HW_STATE_STATION_;
 	}
-	else if(psetop->mode == NDIS802_11IBSS)
+	else if (psetop->mode == NDIS802_11IBSS)
 	{
 		type = _HW_STATE_ADHOC_;
 	}
@@ -10385,11 +10385,11 @@ u8 createbss_hdl(struct rtw_adapter *pad
 	u32	initialgain;
 
 
-	if(pparm->network.InfrastructureMode == NDIS802_11APMODE)
+	if (pparm->network.InfrastructureMode == NDIS802_11APMODE)
 	{
 #ifdef CONFIG_AP_MODE
 
-		if(pmlmeinfo->state == WIFI_FW_AP_STATE)
+		if (pmlmeinfo->state == WIFI_FW_AP_STATE)
 		{
 			//todo:
 			return H2C_SUCCESS;
@@ -10398,7 +10398,7 @@ u8 createbss_hdl(struct rtw_adapter *pad
 	}
 
 	//below is for ad-hoc master
-	if(pparm->network.InfrastructureMode == NDIS802_11IBSS)
+	if (pparm->network.InfrastructureMode == NDIS802_11IBSS)
 	{
 		rtw_joinbss_reset(padapter);
 
@@ -10429,7 +10429,7 @@ u8 createbss_hdl(struct rtw_adapter *pad
 		memcpy(pnetwork, pbuf, FIELD_OFFSET(struct wlan_bssid_ex, IELength));
 		pnetwork->IELength = ((struct wlan_bssid_ex *)pbuf)->IELength;
 
-		if(pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
+		if (pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
 			return H2C_PARAMETERS_ERROR;
 
 		memcpy(pnetwork->IEs, ((struct wlan_bssid_ex *)pbuf)->IEs, pnetwork->IELength);
@@ -10501,7 +10501,7 @@ u8 join_cmd_hdl(struct rtw_adapter *pada
 	memcpy(pnetwork, pbuf, FIELD_OFFSET(struct wlan_bssid_ex, IELength));
 	pnetwork->IELength = ((struct wlan_bssid_ex *)pbuf)->IELength;
 
-	if(pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
+	if (pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
 		return H2C_PARAMETERS_ERROR;
 
 	memcpy(pnetwork->IEs, ((struct wlan_bssid_ex *)pbuf)->IEs, pnetwork->IELength);
@@ -10531,18 +10531,18 @@ u8 join_cmd_hdl(struct rtw_adapter *pada
 
 				//spec case only for cisco's ap because cisco's ap issue assoc rsp using mcs rate @40MHz or @20MHz
 //#if !defined(CONFIG_CONCURRENT_MODE) && !defined(CONFIG_DUALMAC_CONCURRENT)
-//				if(pmlmeinfo->assoc_AP_vendor == ciscoAP)
+//				if (pmlmeinfo->assoc_AP_vendor == ciscoAP)
 //#endif
 				{
 					struct HT_info_element *pht_info = (struct HT_info_element *)(pIE->data);
 
-					if( pnetwork->Configuration.DSConfig > 14 )
+					if ( pnetwork->Configuration.DSConfig > 14 )
 					{
-						if( pregpriv->cbw40_enable & BIT(1) )
+						if ( pregpriv->cbw40_enable & BIT(1) )
 							cbw40_enable = 1;
 					}
 					else
-						if( pregpriv->cbw40_enable & BIT(0) )
+						if ( pregpriv->cbw40_enable & BIT(0) )
 							cbw40_enable = 1;
 
 					if ((cbw40_enable) &&	 (pht_info->infos[0] & BIT(2)))
@@ -10620,7 +10620,7 @@ u8 disconnect_hdl(struct rtw_adapter *pa
 	//restore to initial setting.
 	update_tx_basic_rate(padapter, padapter->registrypriv.wireless_mode);
 
-	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 	{
 		//Stop BCN
 		val8 = 0;
@@ -10637,7 +10637,7 @@ u8 disconnect_hdl(struct rtw_adapter *pa
 	dc_set_channel_bwmode_disconnect(padapter);
 #else
 #ifdef CONFIG_CONCURRENT_MODE
-	if((check_buddy_fwstate(padapter, _FW_LINKED)) != true)
+	if ((check_buddy_fwstate(padapter, _FW_LINKED)) != true)
 	{
 #endif //CONFIG_CONCURRENT_MODE
 		//switch to the 20M Hz mode after disconnect
@@ -10675,27 +10675,27 @@ int rtw_scan_ch_decision(struct rtw_adap
 	for (i=0;i<in_num;i++) {
 		if (0)
 		DBG_8192D(FUNC_ADPT_FMT" "CHAN_FMT"\n", FUNC_ADPT_ARG(padapter), CHAN_ARG(&in[i]));
-		if(in[i].hw_value && !(in[i].flags & RTW_IEEE80211_CHAN_DISABLED)
+		if (in[i].hw_value && !(in[i].flags & RTW_IEEE80211_CHAN_DISABLED)
 			&& (set_idx=rtw_ch_set_search_ch(pmlmeext->channel_set, in[i].hw_value)) >=0
 		)
 		{
 			memcpy(&out[j], &in[i], sizeof(struct rtw_ieee80211_channel));
 
-			if(pmlmeext->channel_set[set_idx].ScanType == SCAN_PASSIVE)
+			if (pmlmeext->channel_set[set_idx].ScanType == SCAN_PASSIVE)
 				out[j].flags &= RTW_IEEE80211_CHAN_PASSIVE_SCAN;
 
 			j++;
 		}
-		if(j>=out_num)
+		if (j>=out_num)
 			break;
 	}
 
 	/* if out is empty, use channel_set as default */
-	if(j == 0) {
+	if (j == 0) {
 		for (i=0;i<pmlmeext->max_chan_nums;i++) {
 			out[i].hw_value = pmlmeext->channel_set[i].ChannelNum;
 
-			if(pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
+			if (pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
 				out[i].flags &= RTW_IEEE80211_CHAN_PASSIVE_SCAN;
 
 			j++;
@@ -10746,7 +10746,7 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 		pmlmeext->sitesurvey_res.channel_idx = 0;
 
 		for(i=0;i<RTW_SSID_SCAN_AMOUNT;i++){
-			if(pparm->ssid[i].SsidLength) {
+			if (pparm->ssid[i].SsidLength) {
 				memcpy(pmlmeext->sitesurvey_res.ssid[i].Ssid, pparm->ssid[i].Ssid, IW_ESSID_MAX_SIZE);
 				pmlmeext->sitesurvey_res.ssid[i].SsidLength= pparm->ssid[i].SsidLength;
 			} else {
@@ -10773,7 +10773,7 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 			issue_nulldata(padapter, NULL, 1, 3, 500);
 
 #ifdef CONFIG_CONCURRENT_MODE
-			if(is_client_associated_to_ap(padapter->pbuddy_adapter) == true)
+			if (is_client_associated_to_ap(padapter->pbuddy_adapter) == true)
 			{
 				DBG_8192D("adapter is scanning(buddy_adapter is linked), issue nulldata(pwrbit=1)\n");
 
@@ -10783,10 +10783,10 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 			bdelayscan = true;
 		}
 #ifdef CONFIG_CONCURRENT_MODE
-		else if(is_client_associated_to_ap(padapter->pbuddy_adapter) == true)
+		else if (is_client_associated_to_ap(padapter->pbuddy_adapter) == true)
 		{
 			#ifdef CONFIG_TDLS
-			if(padapter->pbuddy_adapter->wdinfo.wfd_tdls_enable == 1)
+			if (padapter->pbuddy_adapter->wdinfo.wfd_tdls_enable == 1)
 			{
 				issue_tunneled_probe_req(padapter->pbuddy_adapter);
 			}
@@ -10799,7 +10799,7 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 			bdelayscan = true;
 		}
 #endif
-		if(bdelayscan)
+		if (bdelayscan)
 		{
 			//delay 50ms to protect nulldata(1).
 			set_survey_timer(pmlmeext, 50);
@@ -10818,7 +10818,7 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 
 		//config the initial gain under scaning, need to write the BB registers
 #ifdef CONFIG_IOCTL_CFG80211
-		if((wdev_to_priv(padapter->rtw_wdev))->p2p_enabled == true)
+		if ((wdev_to_priv(padapter->rtw_wdev))->p2p_enabled == true)
 			initialgain = 0x27;
 		else
 			initialgain = 0x17;
@@ -10873,7 +10873,7 @@ u8 setkey_hdl(struct rtw_adapter *padapt
 	unsigned char					null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
 
 	//main tx key for wep.
-	if(pparm->set_tx)
+	if (pparm->set_tx)
 		pmlmeinfo->key_index = pparm->keyid;
 
 	//write cam
@@ -10914,14 +10914,14 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 	//cam_entry = 5 //mapping to macid=2
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
 	{
 		struct sta_priv	*pstapriv = &padapter->stapriv;
 		struct sta_info	*psta;
 
 		psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
 
-		if(psta && psta->mac_id==2)
+		if (psta && psta->mac_id==2)
 		{
 			cam_id = 5;
 		}
@@ -10930,7 +10930,7 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 			cam_id = 4;
 		}
 /*
-		if(padapter->iface_type > PRIMARY_IFACE)
+		if (padapter->iface_type > PRIMARY_IFACE)
 		{
 			cam_id = 5;
 		}
@@ -10945,26 +10945,26 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 #endif
 
 
-	if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &padapter->stapriv;
 
-		if(pparm->algorithm == _NO_PRIVACY_)	// clear cam entry
+		if (pparm->algorithm == _NO_PRIVACY_)	// clear cam entry
 		{
 			clear_cam_entry(padapter, pparm->id);
 			return H2C_SUCCESS_RSP;
 		}
 
 		psta = rtw_get_stainfo(pstapriv, pparm->addr);
-		if(psta)
+		if (psta)
 		{
 			ctrl = (BIT(15) | ((pparm->algorithm) << 2));
 
 			DBG_8192D("r871x_set_stakey_hdl(): enc_algorithm=%d\n", pparm->algorithm);
 
-			if((psta->mac_id<1) || (psta->mac_id>(NUM_STA-4)))
+			if ((psta->mac_id<1) || (psta->mac_id>(NUM_STA-4)))
 			{
 				DBG_8192D("r871x_set_stakey_hdl():set_stakey failed, mac_id(aid)=%d\n", psta->mac_id);
 				return H2C_REJECTED;
@@ -10991,7 +10991,7 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 
 	//below for sta mode
 
-	if(pparm->algorithm == _NO_PRIVACY_)	// clear cam entry
+	if (pparm->algorithm == _NO_PRIVACY_)	// clear cam entry
 	{
 		clear_cam_entry(padapter, pparm->id);
 		return H2C_SUCCESS;
@@ -11000,7 +11000,7 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 	ctrl = BIT(15) | ((pparm->algorithm) << 2);
 
 #ifdef CONFIG_TDLS
-	if(ptdlsinfo->clear_cam!=0){
+	if (ptdlsinfo->clear_cam!=0){
 		clear_cam_entry(padapter, ptdlsinfo->clear_cam);
 		ptdlsinfo->clear_cam=0;
 
@@ -11008,7 +11008,7 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 	}
 
 	psta = rtw_get_stainfo(pstapriv, pparm->addr);//Get TDLS Peer STA
-	if( psta->tdls_sta_state&TDLS_LINKED_STATE ){
+	if ( psta->tdls_sta_state&TDLS_LINKED_STATE ){
 		write_cam(padapter, psta->mac_id, ctrl, pparm->addr, pparm->key);
 	}
 	else
@@ -11028,7 +11028,7 @@ u8 add_ba_hdl(struct rtw_adapter *padapt
 
 	struct sta_info *psta = rtw_get_stainfo(&padapter->stapriv, pparm->addr);
 
-	if(!psta)
+	if (!psta)
 		return	H2C_SUCCESS;
 
 
@@ -11043,7 +11043,7 @@ u8 add_ba_hdl(struct rtw_adapter *padapt
 		_set_timer(&psta->addba_retry_timer, ADDBA_TO);
 	}
 #ifdef CONFIG_TDLS
-	else if((psta->tdls_sta_state & TDLS_LINKED_STATE)&&
+	else if ((psta->tdls_sta_state & TDLS_LINKED_STATE)&&
 		(psta->htpriv.ht_option==true) &&
 		(psta->htpriv.ampdu_enable==true) )
 	{
@@ -11155,7 +11155,7 @@ u8 mlme_evt_hdl(struct rtw_adapter *pada
 
 	peventbuf += 2;
 
-	if(peventbuf)
+	if (peventbuf)
 	{
 		event_callback = wlanevents[evt_code].event_callback;
 		event_callback(padapter, (u8*)peventbuf);
@@ -11173,7 +11173,7 @@ _abort_event_:
 
 u8 h2c_msg_hdl(struct rtw_adapter *padapter, unsigned char *pbuf)
 {
-	if(!pbuf)
+	if (!pbuf)
 		return H2C_PARAMETERS_ERROR;
 
 	return H2C_SUCCESS;
@@ -11181,7 +11181,7 @@ u8 h2c_msg_hdl(struct rtw_adapter *padap
 
 u8 tx_beacon_hdl(struct rtw_adapter *padapter, unsigned char *pbuf)
 {
-	if(send_beacon(padapter)==_FAIL)
+	if (send_beacon(padapter)==_FAIL)
 	{
 		DBG_8192D("issue_beacon, fail!\n");
 		return H2C_PARAMETERS_ERROR;
@@ -11196,10 +11196,10 @@ u8 tx_beacon_hdl(struct rtw_adapter *pad
 
 		//for BC/MC Frames
 		psta_bmc = rtw_get_bcmc_stainfo(padapter);
-		if(!psta_bmc)
+		if (!psta_bmc)
 			return H2C_SUCCESS;
 
-		if((pstapriv->tim_bitmap&BIT(0)) && (psta_bmc->sleepq_len>0)) {
+		if ((pstapriv->tim_bitmap&BIT(0)) && (psta_bmc->sleepq_len>0)) {
 			rtw_msleep_os(10);// 10ms, ATIM(HIQ) Windows
 			spin_lock_bh(&psta_bmc->sleep_q.lock);
 
@@ -11215,7 +11215,7 @@ u8 tx_beacon_hdl(struct rtw_adapter *pad
 				rtw_list_delete(&pxmitframe->list);
 
 				psta_bmc->sleepq_len--;
-				if(psta_bmc->sleepq_len>0)
+				if (psta_bmc->sleepq_len>0)
 					pxmitframe->attrib.mdata = 1;
 				else
 					pxmitframe->attrib.mdata = 0;
@@ -11225,7 +11225,7 @@ u8 tx_beacon_hdl(struct rtw_adapter *pad
 				pxmitframe->attrib.qsel = 0x11;//HIQ
 
 				spin_unlock_bh(&psta_bmc->sleep_q.lock);
-				if(rtw_hal_xmit(padapter, pxmitframe) == true)
+				if (rtw_hal_xmit(padapter, pxmitframe) == true)
 				{
 					rtw_os_xmit_complete(padapter, pxmitframe);
 				}
@@ -11255,7 +11255,7 @@ void change_band_update_ie(struct rtw_ad
 
 	//DBG_8192D("%s\n", __func__);
 
-	if(pmlmeext->cur_channel >= 36)
+	if (pmlmeext->cur_channel >= 36)
 	{
 		network_type = WIRELESS_11A;
 		total_rate_len = IEEE80211_NUM_OFDM_RATESLEN;
@@ -11275,7 +11275,7 @@ void change_band_update_ie(struct rtw_ad
 	UpdateBrateTbl(padapter, pnetwork->SupportedRates);
 	rtw_hal_set_hwreg(padapter, HW_VAR_BASIC_RATE, pnetwork->SupportedRates);
 
-	if(total_rate_len > 8)
+	if (total_rate_len > 8)
 	{
 		rate_len = 8;
 		remainder_rate_len = total_rate_len - 8;
@@ -11288,7 +11288,7 @@ void change_band_update_ie(struct rtw_ad
 
 	rtw_add_bcn_ie(padapter, pnetwork, _SUPPORTEDRATES_IE_, pnetwork->SupportedRates, rate_len);
 
-	if(remainder_rate_len)
+	if (remainder_rate_len)
 	{
 		rtw_add_bcn_ie(padapter, pnetwork, _EXT_SUPPORTEDRATES_IE_, (pnetwork->SupportedRates+8), remainder_rate_len);
 	}
@@ -11304,7 +11304,7 @@ void dc_SelectChannel(struct rtw_adapter
 {
 	struct rtw_adapter * ptarget_adapter;
 
-	if( (padapter->pbuddy_adapter != NULL) &&
+	if ( (padapter->pbuddy_adapter != NULL) &&
 		(padapter->DualMacConcurrent == true) &&
 		(padapter->adapter_type == SECONDARY_ADAPTER))
 	{
@@ -11327,7 +11327,7 @@ void dc_SetBWMode(struct rtw_adapter *pa
 {
 	struct rtw_adapter * ptarget_adapter;
 
-	if( (padapter->pbuddy_adapter != NULL) &&
+	if ( (padapter->pbuddy_adapter != NULL) &&
 		(padapter->DualMacConcurrent == true) &&
 		(padapter->adapter_type == SECONDARY_ADAPTER))
 	{
@@ -11352,11 +11352,11 @@ void dc_set_channel_bwmode_disconnect(st
 	struct rtw_adapter * pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
 
-	if(pbuddy_adapter != NULL &&
+	if (pbuddy_adapter != NULL &&
 		padapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
-		if((check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) != true)
+		if ((check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) != true)
 		{
 			//switch to the 20M Hz mode after disconnect
 			pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
@@ -11385,17 +11385,17 @@ u8 dc_handle_join_request(struct rtw_ada
 	struct mlme_priv	*pbuddy_mlmepriv = NULL;
 	u8	ret = _SUCCESS;
 
-	if(pbuddy_adapter != NULL &&
+	if (pbuddy_adapter != NULL &&
 		padapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 
-		if(pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel ||
+		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel ||
 			pmlmeext->cur_bwmode != pbuddy_mlmeext->cur_bwmode ||
 			pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset)
 		{
-			if((check_fwstate(pbuddy_mlmepriv, WIFI_AP_STATE)) == true)
+			if ((check_fwstate(pbuddy_mlmepriv, WIFI_AP_STATE)) == true)
 			{
 				//issue deauth to all stas if if2 is at ap mode
 				rtw_sta_flush(pbuddy_adapter);
@@ -11403,12 +11403,12 @@ u8 dc_handle_join_request(struct rtw_ada
 				//rtw_hal_set_hwreg(padapter, HW_VAR_CHECK_TXBUF, 0);
 				rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_CHECK_TXBUF, 0);
 			}
-			else if(check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == true)
+			else if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == true)
 			{
-				if(pmlmeext->cur_channel == pbuddy_mlmeext->cur_channel)
+				if (pmlmeext->cur_channel == pbuddy_mlmeext->cur_channel)
 				{
 					// HT_CHANNEL_WIDTH_40 or HT_CHANNEL_WIDTH_20 but channel offset is different
-					if((pmlmeext->cur_bwmode == pbuddy_mlmeext->cur_bwmode) &&
+					if ((pmlmeext->cur_bwmode == pbuddy_mlmeext->cur_bwmode) &&
 						(pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset) )
 					{
 						report_join_res(padapter, -4);
@@ -11443,7 +11443,7 @@ void dc_handle_join_done(struct rtw_adap
 	u8	change_band = false;
 
 
-	if(pbuddy_adapter != NULL &&
+	if (pbuddy_adapter != NULL &&
 		padapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
@@ -11451,19 +11451,19 @@ void dc_handle_join_done(struct rtw_adap
 		pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
 		pbuddy_network_mlmeext = &(pbuddy_mlmeinfo->network);
 
-		if(((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
+		if (((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 				check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
 		{
 			//restart and update beacon
 			DBG_8192D("after join, current adapter, CH=%d, BW=%d, offset=%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
 
-			if(join_res >= 0)
+			if (join_res >= 0)
 			{
 				u8 *p;
 				int	ie_len;
 				struct HT_info_element *pht_info=NULL;
 
-				if((pbuddy_mlmeext->cur_channel <= 14 && pmlmeext->cur_channel >= 36) ||
+				if ((pbuddy_mlmeext->cur_channel <= 14 && pmlmeext->cur_channel >= 36) ||
 					(pbuddy_mlmeext->cur_channel >= 36 && pmlmeext->cur_channel <= 14))
 				{
 					change_band = true;
@@ -11472,21 +11472,21 @@ void dc_handle_join_done(struct rtw_adap
 				//sync channel/bwmode/ch_offset with another adapter
 				pbuddy_mlmeext->cur_channel = pmlmeext->cur_channel;
 
-				if(pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
+				if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 				{
 					p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(struct ndis_802_11_fixed_ies)), _HT_ADD_INFO_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-					if( p && ie_len)
+					if ( p && ie_len)
 					{
 						pht_info = (struct HT_info_element *)(p+2);
 						pht_info->infos[0] &= ~(BIT(0)|BIT(1)); //no secondary channel is present
 					}
 
-					if(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
+					if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 					{
 						pbuddy_mlmeext->cur_ch_offset = pmlmeext->cur_ch_offset;
 
 						//to update cur_ch_offset value in beacon
-						if( pht_info )
+						if ( pht_info )
 						{
 							switch(pmlmeext->cur_ch_offset)
 							{
@@ -11502,23 +11502,23 @@ void dc_handle_join_done(struct rtw_adap
 							}
 						}
 					}
-					else if(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_20)
+					else if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_20)
 					{
 						pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
 						pbuddy_mlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 
-						if(pmlmeext->cur_channel>0 && pmlmeext->cur_channel<5)
+						if (pmlmeext->cur_channel>0 && pmlmeext->cur_channel<5)
 						{
-							if(pht_info)
+							if (pht_info)
 								pht_info->infos[0] |= 0x1;
 
 							pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
 							pbuddy_mlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
 						}
 
-						if(pmlmeext->cur_channel>7 && pmlmeext->cur_channel<(14+1))
+						if (pmlmeext->cur_channel>7 && pmlmeext->cur_channel<(14+1))
 						{
-							if(pht_info)
+							if (pht_info)
 								pht_info->infos[0] |= 0x3;
 
 							pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
@@ -11532,11 +11532,11 @@ void dc_handle_join_done(struct rtw_adap
 				// to update channel value in beacon
 				pbuddy_network_mlmeext->Configuration.DSConfig = pmlmeext->cur_channel;
 				p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(struct ndis_802_11_fixed_ies)), _DSSET_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-				if(p && ie_len>0)
+				if (p && ie_len>0)
 					*(p + 2) = pmlmeext->cur_channel;
 
 				p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(struct ndis_802_11_fixed_ies)), _HT_ADD_INFO_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-				if( p && ie_len)
+				if ( p && ie_len)
 				{
 					pht_info = (struct HT_info_element *)(p+2);
 					pht_info->primary_channel = pmlmeext->cur_channel;
@@ -11553,7 +11553,7 @@ void dc_handle_join_done(struct rtw_adap
 
 			DBG_8192D("after join, another adapter, CH=%d, BW=%d, offset=%d\n", pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_bwmode, pbuddy_mlmeext->cur_ch_offset);
 
-			if(change_band == true)
+			if (change_band == true)
 				change_band_update_ie(pbuddy_adapter, pbuddy_network_mlmeext);
 
 			DBG_8192D("update pbuddy_adapter's beacon\n");
@@ -11562,7 +11562,7 @@ void dc_handle_join_done(struct rtw_adap
 		}
 		else	 if (is_client_associated_to_ap(pbuddy_adapter) == true)
 		{
-			if((pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
+			if ((pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
 				(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_20))
 			{
 				set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
@@ -11578,7 +11578,7 @@ int	dc_check_fwstate(struct rtw_adapter
 	struct rtw_adapter * pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
 
-	if(padapter->pbuddy_adapter != NULL &&
+	if (padapter->pbuddy_adapter != NULL &&
 		padapter->DualMacConcurrent == true)
 
 	{
@@ -11597,7 +11597,7 @@ u8 dc_handle_site_survey(struct rtw_adap
 	struct rtw_adapter * pbuddy_adapter = padapter->pbuddy_adapter;
 
 	// only mac0 can do scan request, help issue nulldata(1) for mac1
-	if(pbuddy_adapter != NULL &&
+	if (pbuddy_adapter != NULL &&
 		padapter->DualMacConcurrent == true)
 	{
 		if (is_client_associated_to_ap(pbuddy_adapter) == true)
@@ -11615,7 +11615,7 @@ u8 dc_handle_site_survey(struct rtw_adap
 
 void	dc_report_survey_event(struct rtw_adapter *padapter, union recv_frame *precv_frame)
 {
-	if(padapter->pbuddy_adapter != NULL &&
+	if (padapter->pbuddy_adapter != NULL &&
 		padapter->DualMacConcurrent == true)
 	{
 		report_survey_event(padapter->pbuddy_adapter, precv_frame);
@@ -11634,16 +11634,16 @@ void dc_set_channel_bwmode_survey_done(s
 	u8 cur_bwmode;
 	u8 cur_ch_offset;
 
-	if(pbuddy_adapter != NULL &&
+	if (pbuddy_adapter != NULL &&
 		padapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 		pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
 
-		if(check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
+		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
 		{
-			if(check_fwstate(pmlmepriv, _FW_LINKED) &&
+			if (check_fwstate(pmlmepriv, _FW_LINKED) &&
 				(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40))
 			{
 				cur_channel = pmlmeext->cur_channel;
@@ -11672,7 +11672,7 @@ void dc_set_channel_bwmode_survey_done(s
 			issue_nulldata(pbuddy_adapter, NULL, 0, 0, 0);
 		}
 
-		if(((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
+		if (((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 			check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
 		{
 
@@ -11712,22 +11712,22 @@ void dc_set_ap_channel_bandwidth(struct
 	change_band = false;
 
 	p = rtw_get_ie((pnetwork->IEs + sizeof(struct ndis_802_11_fixed_ies)), _HT_ADD_INFO_IE_, &ie_len, (pnetwork->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-	if( p && ie_len)
+	if ( p && ie_len)
 	{
 		pht_info = (struct HT_info_element *)(p+2);
 	}
 
-	if(pbuddy_adapter != NULL &&
+	if (pbuddy_adapter != NULL &&
 		padapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
-		if(!check_fwstate(pbuddy_mlmepriv, _FW_LINKED|_FW_UNDER_LINKING|_FW_UNDER_SURVEY))
+		if (!check_fwstate(pbuddy_mlmepriv, _FW_LINKED|_FW_UNDER_LINKING|_FW_UNDER_SURVEY))
 		{
 			set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
 		}
-		else if(check_fwstate(pbuddy_mlmepriv, _FW_LINKED)==true)
+		else if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED)==true)
 		{
 			//To sync cur_channel/cur_bwmode/cur_ch_offset with another adapter
 			DBG_8192D("Another iface is at linked state, sync cur_channel/cur_bwmode/cur_ch_offset\n");
@@ -11735,17 +11735,17 @@ void dc_set_ap_channel_bandwidth(struct
 			DBG_8192D("Current adapter, CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
 
 			cur_channel = pbuddy_mlmeext->cur_channel;
-			if(cur_bwmode == HT_CHANNEL_WIDTH_40)
+			if (cur_bwmode == HT_CHANNEL_WIDTH_40)
 			{
-				if(pht_info)
+				if (pht_info)
 					pht_info->infos[0] &= ~(BIT(0)|BIT(1));
 
-				if(pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
+				if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 				{
 					cur_ch_offset = pbuddy_mlmeext->cur_ch_offset;
 
 					//to update cur_ch_offset value in beacon
-					if(pht_info)
+					if (pht_info)
 					{
 						switch(cur_ch_offset)
 						{
@@ -11761,23 +11761,23 @@ void dc_set_ap_channel_bandwidth(struct
 						}
 					}
 				}
-				else if(pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_20)
+				else if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_20)
 				{
 					cur_bwmode = HT_CHANNEL_WIDTH_20;
 					cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 
-					if(cur_channel>0 && cur_channel<5)
+					if (cur_channel>0 && cur_channel<5)
 					{
-						if(pht_info)
+						if (pht_info)
 							pht_info->infos[0] |= 0x1;
 
 						cur_bwmode = HT_CHANNEL_WIDTH_40;
 						cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
 					}
 
-					if(cur_channel>7 && cur_channel<(14+1))
+					if (cur_channel>7 && cur_channel<(14+1))
 					{
-						if(pht_info)
+						if (pht_info)
 							pht_info->infos[0] |= 0x3;
 
 						cur_bwmode = HT_CHANNEL_WIDTH_40;
@@ -11791,10 +11791,10 @@ void dc_set_ap_channel_bandwidth(struct
 			// to update channel value in beacon
 			pnetwork->Configuration.DSConfig = cur_channel;
 			p = rtw_get_ie((pnetwork->IEs + sizeof(struct ndis_802_11_fixed_ies)), _DSSET_IE_, &ie_len, (pnetwork->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-			if(p && ie_len>0)
+			if (p && ie_len>0)
 				*(p + 2) = cur_channel;
 
-			if(pht_info)
+			if (pht_info)
 				pht_info->primary_channel = cur_channel;
 		}
 	}
@@ -11805,7 +11805,7 @@ void dc_set_ap_channel_bandwidth(struct
 
 	DBG_8192D("CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
 
-	if((channel <= 14 && cur_channel >= 36) ||
+	if ((channel <= 14 && cur_channel >= 36) ||
 		(channel >= 36 && cur_channel <= 14))
 	{
 		change_band = true;
@@ -11815,7 +11815,7 @@ void dc_set_ap_channel_bandwidth(struct
 	pmlmeext->cur_bwmode = cur_bwmode;
 	pmlmeext->cur_ch_offset = cur_ch_offset;
 
-	if(change_band == true)
+	if (change_band == true)
 		change_band_update_ie(padapter, pnetwork);
 
 	DBG_8192D("dualmac_concurrent_ap_set_channel_bwmode <==\n");
@@ -11825,7 +11825,7 @@ void dc_resume_xmit(struct rtw_adapter *
 {
 	struct rtw_adapter * pbuddy_adapter = padapter->pbuddy_adapter;
 
-	if(pbuddy_adapter != NULL &&
+	if (pbuddy_adapter != NULL &&
 		padapter->DualMacConcurrent == true)
 	{
 		DBG_8192D("dc_resume_xmit,  resume pbuddy_adapter Tx\n");
@@ -11838,7 +11838,7 @@ u8	dc_check_xmit(struct rtw_adapter *pad
 	struct rtw_adapter * pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
 
-	if(pbuddy_adapter != NULL &&
+	if (pbuddy_adapter != NULL &&
 		padapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
@@ -11860,19 +11860,19 @@ int check_buddy_mlmeinfo_state(struct rt
 	struct mlme_ext_priv *pbuddy_mlmeext;
 	struct mlme_ext_info *pbuddy_mlmeinfo;
 
-	if(padapter == NULL)
+	if (padapter == NULL)
 		return false;
 
 	pbuddy_adapter = padapter->pbuddy_adapter;
 
-	if(pbuddy_adapter == NULL)
+	if (pbuddy_adapter == NULL)
 		return false;
 
 
 	pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 	pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
 
-	if((pbuddy_mlmeinfo->state&0x03) == state)
+	if ((pbuddy_mlmeinfo->state&0x03) == state)
 		return true;
 
 	return false;
@@ -11889,7 +11889,7 @@ int concurrent_chk_start_clnt_join(struc
 	struct mlme_ext_info	*pbuddy_pmlmeinfo;
 	struct mlme_priv *pbuddy_mlmepriv;
 
-	if(!rtw_buddy_adapter_up(padapter))
+	if (!rtw_buddy_adapter_up(padapter))
 		return _SUCCESS;
 
 	pmlmeext = &padapter->mlmeextpriv;
@@ -11900,14 +11900,14 @@ int concurrent_chk_start_clnt_join(struc
 	pbuddy_pmlmeinfo = &(pbuddy_mlmeext->mlmext_info);
 	pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 
-	if((pbuddy_pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)//for AP MODE
+	if ((pbuddy_pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)//for AP MODE
 	{
 		bool inform_ch_switch = false;
-		if(pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel)
+		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel)
 		{
 			inform_ch_switch = true;
 		}
-		else if((pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
+		else if ((pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
 			(pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
 			(pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset))
 		{
@@ -11927,16 +11927,16 @@ int concurrent_chk_start_clnt_join(struc
 			rtw_hal_set_hwreg(padapter, HW_VAR_CHECK_TXBUF, 0);
 		}
 	}
-	else if(check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == true &&
+	else if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == true &&
 		check_fwstate(pbuddy_mlmepriv, WIFI_STATION_STATE) == true) //for Client Mode/p2p client
 	{
 #if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
 		struct wifidirect_info *pbuddy_wdinfo = &(pbuddy_adapter->wdinfo);
-		if(!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
+		if (!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
 			return _SUCCESS; //wlan0-sta mode has higher priority than p2p0-p2p client
 #endif //CONFIG_P2P && CONFIG_IOCTL_CFG80211
 
-		if(pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel)
+		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel)
 		{
 			DBG_8192D("start_clnt_join(ch=%d), but channel mismatch with buddy(ch=%d) interface\n",
 				pmlmeext->cur_channel, pbuddy_mlmeext->cur_channel);
@@ -11946,7 +11946,7 @@ int concurrent_chk_start_clnt_join(struc
 			return ret;
 		}
 
-		if((pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
+		if ((pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
 			(pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
 			(pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset))
 		{
@@ -11974,7 +11974,7 @@ void concurrent_chk_joinbss_done(struct
 	struct mlme_ext_info *pbuddy_mlmeinfo;
 	struct wlan_bssid_ex *pbuddy_network_mlmeext;
 
-	if(!rtw_buddy_adapter_up(padapter))
+	if (!rtw_buddy_adapter_up(padapter))
 		return;
 
 	pmlmeext = &padapter->mlmeextpriv;
@@ -11986,7 +11986,7 @@ void concurrent_chk_joinbss_done(struct
 	pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
 	pbuddy_network_mlmeext = &(pbuddy_mlmeinfo->network);
 
-	if(((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
+	if (((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 			check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
 	{
 		//restart and update beacon
@@ -11995,33 +11995,33 @@ void concurrent_chk_joinbss_done(struct
 			, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
 
 
-		if(join_res >= 0) {
+		if (join_res >= 0) {
 			u8 *p;
 			int	ie_len;
 			u8	change_band = false;
 			struct HT_info_element *pht_info=NULL;
 
-			if((pmlmeext->cur_channel <= 14 && pbuddy_mlmeext->cur_channel >= 36) ||
+			if ((pmlmeext->cur_channel <= 14 && pbuddy_mlmeext->cur_channel >= 36) ||
 				(pmlmeext->cur_channel >= 36 && pbuddy_mlmeext->cur_channel <= 14))
 				change_band = true;
 
 			//sync channel/bwmode/ch_offset with primary adapter
 			pbuddy_mlmeext->cur_channel = pmlmeext->cur_channel;
-			if(pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
+			if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 			{
 				p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(struct ndis_802_11_fixed_ies)), _HT_ADD_INFO_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-				if( p && ie_len)
+				if ( p && ie_len)
 				{
 					pht_info = (struct HT_info_element *)(p+2);
 					pht_info->infos[0] &= ~(BIT(0)|BIT(1)); //no secondary channel is present
 				}
 
-				if(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
+				if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 				{
 					pbuddy_mlmeext->cur_ch_offset = pmlmeext->cur_ch_offset;
 
 					//to update cur_ch_offset value in beacon
-					if( pht_info )
+					if ( pht_info )
 					{
 						switch(pmlmeext->cur_ch_offset)
 						{
@@ -12039,19 +12039,19 @@ void concurrent_chk_joinbss_done(struct
 					}
 
 				}
-				else if(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_20)
+				else if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_20)
 				{
-					if(pmlmeext->cur_channel>=1 && pmlmeext->cur_channel<=4)
+					if (pmlmeext->cur_channel>=1 && pmlmeext->cur_channel<=4)
 					{
-						if(pht_info)
+						if (pht_info)
 							pht_info->infos[0] |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE;
 
 						pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
 						pbuddy_mlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
 					}
-					else if(pmlmeext->cur_channel>=5 && pmlmeext->cur_channel<=14)
+					else if (pmlmeext->cur_channel>=5 && pmlmeext->cur_channel<=14)
 					{
-						if(pht_info)
+						if (pht_info)
 							pht_info->infos[0] |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW;
 
 						pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
@@ -12073,7 +12073,7 @@ void concurrent_chk_joinbss_done(struct
 							case 149:
 							case 157:
 							{
-								if(pht_info)
+								if (pht_info)
 									pht_info->infos[0] |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE;
 								pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
 								pbuddy_mlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
@@ -12091,7 +12091,7 @@ void concurrent_chk_joinbss_done(struct
 							case 153:
 							case 161:
 							{
-								if(pht_info)
+								if (pht_info)
 									pht_info->infos[0] |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW;
 
 								pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
@@ -12099,7 +12099,7 @@ void concurrent_chk_joinbss_done(struct
 								break;
 							}
 							default:
-								if(pht_info)
+								if (pht_info)
 									pht_info->infos[0] &= ~HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW;
 								pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
 								pbuddy_mlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
@@ -12118,18 +12118,18 @@ void concurrent_chk_joinbss_done(struct
 			// to update channel value in beacon
 			pbuddy_network_mlmeext->Configuration.DSConfig = pmlmeext->cur_channel;
 			p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(struct ndis_802_11_fixed_ies)), _DSSET_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-			if(p && ie_len>0)
+			if (p && ie_len>0)
 				*(p + 2) = pmlmeext->cur_channel;
 
 			p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(struct ndis_802_11_fixed_ies)), _HT_ADD_INFO_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-			if( p && ie_len)
+			if ( p && ie_len)
 			{
 				pht_info = (struct HT_info_element *)(p+2);
 				pht_info->primary_channel = pmlmeext->cur_channel;
 			}
 
 			//buddy interface band is different from current interface, update ERP, support rate, ext support rate IE
-			if(change_band == true)
+			if (change_band == true)
 				change_band_update_ie(pbuddy_adapter, pbuddy_network_mlmeext);
 		}
 		else
@@ -12145,15 +12145,15 @@ void concurrent_chk_joinbss_done(struct
 		update_beacon(pbuddy_adapter, 0, NULL, true);
 
 	}
-	else if(((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) &&
+	else if (((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) &&
 			check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
 	{
-		if(join_res >= 0)
+		if (join_res >= 0)
 		{
 			pbuddy_mlmeext->cur_channel = pmlmeext->cur_channel;
-			if(pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
+			if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 				set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-			else if(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
+			else if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 				set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 			else
 				set_channel_bwmode(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
@@ -12174,7 +12174,7 @@ u8 set_ch_hdl(struct rtw_adapter *padapt
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 
-	if(!pbuf)
+	if (!pbuf)
 		return H2C_PARAMETERS_ERROR;
 
 	set_ch_parm = (struct set_ch_parm *)pbuf;
@@ -12198,7 +12198,7 @@ u8 set_chplan_hdl(struct rtw_adapter *pa
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 
-	if(!pbuf)
+	if (!pbuf)
 		return H2C_PARAMETERS_ERROR;
 
 	setchannelplan_param = (struct setchannelplan_param *)pbuf;
@@ -12213,7 +12213,7 @@ u8 led_blink_hdl(struct rtw_adapter *pad
 {
 	struct LedBlink_param *ledBlink_param;
 
-	if(!pbuf)
+	if (!pbuf)
 		return H2C_PARAMETERS_ERROR;
 
 	ledBlink_param = (struct LedBlink_param *)pbuf;
@@ -12236,7 +12236,7 @@ u8 set_csa_hdl(struct rtw_adapter *padap
 	u8 new_ch_no;
 	u8 gval8 = 0x00, sval8 = 0xff;
 
-	if(!pbuf)
+	if (!pbuf)
 		return H2C_PARAMETERS_ERROR;
 
 	setchannelswitch_param = (struct setchannelswitch_param *)pbuf;
@@ -12288,7 +12288,7 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 	struct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;
 	u8 survey_channel, i, min, option;
 
-	if(!pbuf)
+	if (!pbuf)
 		return H2C_PARAMETERS_ERROR;
 
 	TDLSoption = (struct TDLSoption_param *)pbuf;
@@ -12296,9 +12296,9 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 	ptdls_sta = rtw_get_stainfo( &(padapter->stapriv), TDLSoption->addr );
 	option = TDLSoption->option;
 
-	if( ptdls_sta == NULL )
+	if ( ptdls_sta == NULL )
 	{
-		if( option != TDLS_RS_RCR )
+		if ( option != TDLS_RS_RCR )
 			return H2C_REJECTED;
 	}
 
@@ -12337,7 +12337,7 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 			break;
 		case TDLS_DONE_CH_SEN:
 			survey_channel = pmlmeext->channel_set[pmlmeext->sitesurvey_res.channel_idx].ChannelNum;
-			if(survey_channel){
+			if (survey_channel){
 				SelectChannel(padapter, survey_channel);
 				ptdlsinfo->cur_channel = survey_channel;
 				pmlmeext->sitesurvey_res.channel_idx++;
@@ -12347,12 +12347,12 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 
 				rtw_hal_set_hwreg(padapter, HW_VAR_TDLS_DONE_CH_SEN, 0);
 
-				if(ptdlsinfo->ch_sensing==1){
+				if (ptdlsinfo->ch_sensing==1){
 					ptdlsinfo->ch_sensing=0;
 					ptdlsinfo->cur_channel=1;
 					min=ptdlsinfo->collect_pkt_num[0];
 					for(i=1; i<MAX_CHANNEL_NUM-1; i++){
-						if(min > ptdlsinfo->collect_pkt_num[i]){
+						if (min > ptdlsinfo->collect_pkt_num[i]){
 							ptdlsinfo->cur_channel=i+1;
 							min=ptdlsinfo->collect_pkt_num[i];
 						}
@@ -12365,7 +12365,7 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 
 				}
 
-				if(ptdls_sta->tdls_sta_state & TDLS_PEER_SLEEP_STATE){
+				if (ptdls_sta->tdls_sta_state & TDLS_PEER_SLEEP_STATE){
 					ptdls_sta->tdls_sta_state |= TDLS_APSD_CHSW_STATE;
 				}else{
 					//send null data with pwrbit==1 before send ch_switching_req to peer STA.
@@ -12410,7 +12410,7 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 			SelectChannel(padapter, ptdls_sta->off_ch);
 			DBG_8192D("change channel to off ch:%02x\n", ptdls_sta->off_ch);
 			ptdls_sta->tdls_sta_state |= TDLS_AT_OFF_CH_STATE;
-			if((ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE) != TDLS_PEER_AT_OFF_STATE){
+			if ((ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE) != TDLS_PEER_AT_OFF_STATE){
 				issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 0);
 			}
 			_set_timer(&ptdls_sta->base_ch_timer, TDLS_STAY_TIME);
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -101,7 +101,7 @@ static u32 go_add_group_info_attr(struct
 		plist = get_next(plist);
 
 
-		if(psta->is_p2p_device)
+		if (psta->is_p2p_device)
 		{
 			tmplen = 0;
 
@@ -131,7 +131,7 @@ static u32 go_add_group_info_attr(struct
 			memcpy(pcur, psta->secdev_types_list, psta->num_of_secdev_type*8);
 			pcur += psta->num_of_secdev_type*8;
 
-			if(psta->dev_name_len>0)
+			if (psta->dev_name_len>0)
 			{
 				//*(u16*)(pcur) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
 				RTW_PUT_BE16(pcur, WPS_ATTR_DEVICE_NAME);
@@ -161,7 +161,7 @@ static u32 go_add_group_info_attr(struct
 	}
 	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
-	if(attr_len>0)
+	if (attr_len>0)
 	{
 		len = rtw_set_p2p_attr_content(pbuf, P2P_ATTR_GROUP_INFO, attr_len, pdata_attr);
 	}
@@ -515,7 +515,7 @@ u32 build_beacon_p2p_ie(struct wifidirec
 	//	Group Capability Bitmap, 1 byte
 	capability = P2P_DEVCAP_INVITATION_PROC|P2P_DEVCAP_CLIENT_DISCOVERABILITY;
 	capability |=  ((P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS) << 8);
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
 		capability |= (P2P_GRPCAP_GROUP_FORMATION<<8);
 
 	capability = cpu_to_le16(capability);
@@ -977,7 +977,7 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 	struct wifi_display_info		*pwfd_info = NULL;
 
 	//	WFD OUI
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 	{
 		return 0;
 	}
@@ -1931,11 +1931,11 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 
 	//	Group Capability Bitmap, 1 byte
-	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
 		p2pie[ p2pielen ] = (P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS);
 
-		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
+		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
 			p2pie[ p2pielen ] |= P2P_GRPCAP_GROUP_FORMATION;
 
 		p2pielen++;
@@ -1975,7 +1975,7 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	//	Type:
 	//	Length:
 	//	Value:
-	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
 		//go_add_noa_attr(pwdinfo);
 	}
@@ -1989,7 +1989,7 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
 	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
 #ifdef CONFIG_INTEL_WIDI
-	if( _rtw_memcmp( pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN ) == false )
+	if ( _rtw_memcmp( pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN ) == false )
 	{
 		RTW_PUT_LE16(p2pie + p2pielen, 21 + 8 + pwdinfo->device_name_len);
 	}
@@ -2027,7 +2027,7 @@ u32 build_probe_resp_p2p_ie(struct wifid
 
 	//	Number of Secondary Device Types
 #ifdef CONFIG_INTEL_WIDI
-	if( _rtw_memcmp( pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN ) == false )
+	if ( _rtw_memcmp( pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN ) == false )
 	{
 		p2pie[ p2pielen++ ] = 0x01;
 
@@ -2063,7 +2063,7 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	//	Type:
 	//	Length:
 	//	Value:
-	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
 		p2pielen += go_add_group_info_attr(pwdinfo, p2pie + p2pielen);
 	}
@@ -2302,9 +2302,9 @@ u32 process_probe_req_p2p_ie(struct wifi
 			len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
 
 	ssid_len &= 0xff;	//	Just last 1 byte is valid for ssid len of the probe request
-	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
-		if((p2pie=rtw_get_p2p_ie( pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_ , len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_ , NULL, &p2pielen)))
+		if ((p2pie=rtw_get_p2p_ie( pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_ , len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_ , NULL, &p2pielen)))
 		{
 			if ( (p != NULL) && _rtw_memcmp( ( void * ) ( p+2 ), ( void * ) pwdinfo->p2p_wildcard_ssid , 7 ))
 			{
@@ -2343,7 +2343,7 @@ u32 process_assoc_req_p2p_ie(struct wifi
 	u8 * p2p_ie;
 	u32	p2p_ielen = 0;
 
-	if(!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+	if (!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 		return P2P_STATUS_FAIL_REQUEST_UNABLE;
 
 	frame_type = GetFrameSubType(pframe);
@@ -2374,7 +2374,7 @@ u32 process_assoc_req_p2p_ie(struct wifi
 	while ( p2p_ie )
 	{
 		//Check P2P Capability ATTR
-		if( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*) &attr_contentlen) )
+		if ( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*) &attr_contentlen) )
 		{
 			DBG_8192D( "[%s] Got P2P Capability Attr!!\n", __func__ );
 			cap_attr = le16_to_cpu(cap_attr);
@@ -2385,11 +2385,11 @@ u32 process_assoc_req_p2p_ie(struct wifi
 
 
 		//Check P2P Device Info ATTR
-		if(rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, NULL, (uint*)&attr_contentlen))
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, NULL, (uint*)&attr_contentlen))
 		{
 			DBG_8192D( "[%s] Got P2P DEVICE INFO Attr!!\n", __func__ );
 			pattr_content = pbuf = rtw_zmalloc(attr_contentlen);
-			if(pattr_content)
+			if (pattr_content)
 			{
 				u8 num_of_secdev_type;
 				u16 dev_name_len;
@@ -2413,7 +2413,7 @@ u32 process_assoc_req_p2p_ie(struct wifi
 				num_of_secdev_type = *pattr_content;
 				pattr_content += 1;
 
-				if(num_of_secdev_type==0)
+				if (num_of_secdev_type==0)
 				{
 					psta->num_of_secdev_type = 0;
 				}
@@ -2433,7 +2433,7 @@ u32 process_assoc_req_p2p_ie(struct wifi
 
 				//dev_name_len = attr_contentlen - ETH_ALEN - 2 - 8 - 1 - (num_of_secdev_type*8);
 				psta->dev_name_len=0;
-				if(WPS_ATTR_DEVICE_NAME == be16_to_cpu(*(u16*)pattr_content))
+				if (WPS_ATTR_DEVICE_NAME == be16_to_cpu(*(u16*)pattr_content))
 				{
 					dev_name_len = be16_to_cpu(*(u16*)(pattr_content+2));
 
@@ -2478,13 +2478,13 @@ u32 process_p2p_devdisc_req(struct wifid
 		u8 dev_addr[ETH_ALEN] = { 0x00 };
 		u32	attr_contentlen = 0;
 
-		if(rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen))
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen))
 		{
-			if(_rtw_memcmp(pwdinfo->device_addr, groupid, ETH_ALEN) &&
+			if (_rtw_memcmp(pwdinfo->device_addr, groupid, ETH_ALEN) &&
 				_rtw_memcmp(pwdinfo->p2p_group_ssid, groupid+ETH_ALEN, pwdinfo->p2p_group_ssid_len))
 			{
 				attr_contentlen=0;
-				if(rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_ID, dev_addr, &attr_contentlen))
+				if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_ID, dev_addr, &attr_contentlen))
 				{
 					struct list_head *phead, *plist;
 
@@ -2499,7 +2499,7 @@ u32 process_p2p_devdisc_req(struct wifid
 
 						plist = get_next(plist);
 
-						if(psta->is_p2p_device && (psta->dev_cap&P2P_DEVCAP_CLIENT_DISCOVERABILITY) &&
+						if (psta->is_p2p_device && (psta->dev_cap&P2P_DEVCAP_CLIENT_DISCOVERABILITY) &&
 							_rtw_memcmp(psta->dev_addr, dev_addr, ETH_ALEN))
 						{
 
@@ -2648,7 +2648,7 @@ u8 rtw_p2p_ch_inclusion(struct mlme_ext_
 	{
 		for( j = temp; j < pmlmeext->max_chan_nums; j++ )
 		{
-			if( *( peer_ch_list + i ) == pmlmeext->channel_set[ j ].ChannelNum )
+			if ( *( peer_ch_list + i ) == pmlmeext->channel_set[ j ].ChannelNum )
 			{
 				ch_list_inclusioned[ ch_no++ ] = *( peer_ch_list + i );
 				temp = j;
@@ -2690,7 +2690,7 @@ u8 process_p2p_group_negotation_req( str
 		//	Commented by Kurt 20120113
 		//	If some device wants to do p2p handshake without sending prov_disc_req
 		//	We have to get peer_req_cm from here.
-		if(_rtw_memcmp( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3) )
+		if (_rtw_memcmp( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3) )
 		{
 			rtw_get_wps_attr_content( wpsie, wps_ielen, WPS_ATTR_DEVICE_PWID, (u8*) &wps_devicepassword_id, &wps_devicepassword_id_len);
 			wps_devicepassword_id = be16_to_cpu( wps_devicepassword_id );
@@ -2751,12 +2751,12 @@ u8 process_p2p_group_negotation_req( str
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);
 
 		//Check P2P Capability ATTR
-		if(rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*)&attr_contentlen) )
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*)&attr_contentlen) )
 		{
 			cap_attr = le16_to_cpu(cap_attr);
 
 #if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
-			if(!(cap_attr & P2P_GRPCAP_INTRABSS) )
+			if (!(cap_attr & P2P_GRPCAP_INTRABSS) )
 				ptdlsinfo->ap_prohibited = true;
 #endif //defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 		}
@@ -2795,7 +2795,7 @@ u8 process_p2p_group_negotation_req( str
 				rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 			}
 
-			if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+			if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 			{
 				//	Store the group id information.
 				memcpy( pwdinfo->groupid_info.go_device_addr, pwdinfo->device_addr, ETH_ALEN );
@@ -2818,7 +2818,7 @@ u8 process_p2p_group_negotation_req( str
 			peer_ch_num = rtw_p2p_get_peer_ch_list(pwdinfo, ch_content, ch_cnt, peer_ch_list);
 			ch_num_inclusioned = rtw_p2p_ch_inclusion(&padapter->mlmeextpriv, peer_ch_list, peer_ch_num, ch_list_inclusioned);
 
-			if( ch_num_inclusioned == 0)
+			if ( ch_num_inclusioned == 0)
 			{
 				DBG_8192D( "[%s] No common channel in channel list!\n", __func__ );
 				result = P2P_STATUS_FAIL_NO_COMMON_CH;
@@ -2826,7 +2826,7 @@ u8 process_p2p_group_negotation_req( str
 				break;
 			}
 
-			if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+			if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 			{
 				if ( !rtw_p2p_is_channel_list_ok( pwdinfo->operating_channel,
 												ch_list_inclusioned, ch_num_inclusioned) )
@@ -2954,11 +2954,11 @@ u8 process_p2p_group_negotation_resp( st
 		{
 
 			//Check P2P Capability ATTR
-			if(rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*)&attr_contentlen) )
+			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*)&attr_contentlen) )
 			{
 				cap_attr = le16_to_cpu(cap_attr);
 #if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
-			if(!(cap_attr & P2P_GRPCAP_INTRABSS) )
+			if (!(cap_attr & P2P_GRPCAP_INTRABSS) )
 				ptdlsinfo->ap_prohibited = true;
 #endif //defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 			}
@@ -3038,7 +3038,7 @@ u8 process_p2p_group_negotation_resp( st
 					rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 				}
 
-				if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 				{
 					//	Store the group id information.
 					memcpy( pwdinfo->groupid_info.go_device_addr, pwdinfo->device_addr, ETH_ALEN );
@@ -3064,7 +3064,7 @@ u8 process_p2p_group_negotation_resp( st
 				peer_ch_num = rtw_p2p_get_peer_ch_list(pwdinfo, pwdinfo->channel_list_attr, pwdinfo->channel_list_attr_len, peer_ch_list);
 				ch_num_inclusioned = rtw_p2p_ch_inclusion(&padapter->mlmeextpriv, peer_ch_list, peer_ch_num, ch_list_inclusioned);
 
-				if( ch_num_inclusioned == 0)
+				if ( ch_num_inclusioned == 0)
 				{
 					DBG_8192D( "[%s] No common channel in channel list!\n", __func__ );
 					result = P2P_STATUS_FAIL_NO_COMMON_CH;
@@ -3072,7 +3072,7 @@ u8 process_p2p_group_negotation_resp( st
 					break;
 				}
 
-				if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 				{
 					if ( !rtw_p2p_is_channel_list_ok( pwdinfo->operating_channel,
 													ch_list_inclusioned, ch_num_inclusioned) )
@@ -3304,7 +3304,7 @@ void restore_p2p_state_handler(struct rt
 
 _func_enter_;
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
 	{
 		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
 	}
@@ -3316,7 +3316,7 @@ _func_enter_;
 		struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
 		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
-		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_RSP))
+		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_RSP))
 		{
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 
@@ -3327,7 +3327,7 @@ _func_enter_;
 
 	rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
 
-	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE))
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE))
 	{
 #ifdef CONFIG_CONCURRENT_MODE
 		p2p_concurrent_handler( padapter );
@@ -3408,7 +3408,7 @@ _func_enter_;
 		issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
 
 #else //CONFIG_IOCTL_CFG80211
-		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
+		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 		{
 			//	Now, the driver stays on the AP's channel.
 			//	If the pwdinfo->ext_listen_period = 0, that means the P2P listen state is not available on listen channel.
@@ -3455,7 +3455,7 @@ _func_enter_;
 			//	Todo: To check the value of pwdinfo->ext_listen_interval is equal to 0 or not.
 			_set_timer( &pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_interval );
 		}
-		else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_OK))
+		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_OK))
 		{
 			//	The driver had finished the P2P handshake successfully.
 			val8 = 0;
@@ -3463,7 +3463,7 @@ _func_enter_;
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 			issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
 		}
-		else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
+		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
 		{
 			val8 = 1;
 			set_channel_bwmode(padapter, pwdinfo->tx_prov_disc_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
@@ -3471,7 +3471,7 @@ _func_enter_;
 			issue_probereq_p2p(padapter, NULL);
 			_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
 		}
-		else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == true)
+		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == true)
 		{
 			val8 = 1;
 			set_channel_bwmode(padapter, pwdinfo->nego_req_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
@@ -3479,7 +3479,7 @@ _func_enter_;
 			issue_probereq_p2p(padapter, NULL);
 			_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
 		}
-		else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ ) && pwdinfo->invitereq_info.benable == true)
+		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ ) && pwdinfo->invitereq_info.benable == true)
 		{
 			/*
 			val8 = 1;
@@ -3525,7 +3525,7 @@ _func_enter_;
 
 		}else
 #endif //CONFIG_CONCURRENT_MODE
-		if( pcfg80211_wdinfo->restore_channel != pmlmeext->cur_channel )
+		if ( pcfg80211_wdinfo->restore_channel != pmlmeext->cur_channel )
 		{
 			if ( !check_fwstate(&padapter->mlmepriv, _FW_LINKED ) )
 				pmlmeext->cur_channel = pcfg80211_wdinfo->restore_channel;
@@ -3584,7 +3584,7 @@ static void rtw_cfg80211_adjust_p2pie_ch
 		u8 *pattr = NULL;
 
 		//Check P2P_ATTR_CH_LIST
-		if((pattr=rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, NULL, (uint*)&attr_contentlen))!=NULL)
+		if ((pattr=rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, NULL, (uint*)&attr_contentlen))!=NULL)
 		{
 			int i;
 			u32 num_of_ch;
@@ -3607,7 +3607,7 @@ static void rtw_cfg80211_adjust_p2pie_ch
 		//Check P2P_ATTR_OPERATING_CH
 		attr_contentlen = 0;
 		pattr = NULL;
-		if((pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, (uint*)&attr_contentlen))!=NULL)
+		if ((pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, (uint*)&attr_contentlen))!=NULL)
 		{
 			*(pattr+4) = pbuddy_mlmeext->cur_channel;//forcing to the same channel
 		}
@@ -3631,7 +3631,7 @@ void rtw_append_wfd_ie(struct rtw_adapte
 	frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));
 	category = frame_body[0];
 
-	if(category == RTW_WLAN_CATEGORY_PUBLIC)
+	if (category == RTW_WLAN_CATEGORY_PUBLIC)
 	{
 		action = frame_body[1];
 		if (action == ACT_PUBLIC_VENDOR
@@ -3697,7 +3697,7 @@ void rtw_append_wfd_ie(struct rtw_adapte
 		}
 
 	}
-	else if(category == RTW_WLAN_CATEGORY_P2P)
+	else if (category == RTW_WLAN_CATEGORY_P2P)
 	{
 		OUI_Subtype = frame_body[5];
 		dialogToken = frame_body[6];
@@ -3749,7 +3749,7 @@ int rtw_p2p_check_frames(struct rtw_adap
 	frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));
 	category = frame_body[0];
 	//just for check
-	if(category == RTW_WLAN_CATEGORY_PUBLIC)
+	if (category == RTW_WLAN_CATEGORY_PUBLIC)
 	{
 		action = frame_body[1];
 		if (action == ACT_PUBLIC_VENDOR
@@ -3776,10 +3776,10 @@ int rtw_p2p_check_frames(struct rtw_adap
 				case P2P_GO_NEGO_REQ:
 					DBG_8192D("RTW_%s:P2P_GO_NEGO_REQ, dialogToken=%d\n", (tx==true)?"Tx":"Rx", dialogToken);
 
-					if(tx)
+					if (tx)
 					{
 #ifdef CONFIG_DRV_ISSUE_PROV_REQ // IOT FOR S2
-						if(pwdev_priv->provdisc_req_issued == false)
+						if (pwdev_priv->provdisc_req_issued == false)
 						{
 							rtw_cfg80211_issue_p2p_provision_request(padapter, buf, len);
 							pwdev_priv->provdisc_req_issued = true;
@@ -3788,7 +3788,7 @@ int rtw_p2p_check_frames(struct rtw_adap
 #endif //CONFIG_DRV_ISSUE_PROV_REQ
 
 #ifdef CONFIG_CONCURRENT_MODE
-						if(check_buddy_fwstate(padapter, _FW_LINKED))
+						if (check_buddy_fwstate(padapter, _FW_LINKED))
 							rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr));
 #endif
 					}
@@ -3798,14 +3798,14 @@ int rtw_p2p_check_frames(struct rtw_adap
 					cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
 					DBG_8192D("RTW_%s:P2P_GO_NEGO_RESP, dialogToken=%d, status:%d\n", (tx==true)?"Tx":"Rx", dialogToken, cont?*cont:-1);
 
-					if(!tx)
+					if (!tx)
 					{
 						pwdev_priv->provdisc_req_issued = false;
 					}
 #ifdef CONFIG_CONCURRENT_MODE
 					else
 					{
-						if(check_buddy_fwstate(padapter, _FW_LINKED))
+						if (check_buddy_fwstate(padapter, _FW_LINKED))
 							rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr));
 					}
 #endif
@@ -3814,9 +3814,9 @@ int rtw_p2p_check_frames(struct rtw_adap
 					cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
 					DBG_8192D("RTW_%s:P2P_GO_NEGO_CONF, dialogToken=%d, status:%d\n", (tx==true)?"Tx":"Rx", dialogToken, cont?*cont:-1);
 #ifdef CONFIG_CONCURRENT_MODE
-					if(tx)
+					if (tx)
 					{
-						if(check_buddy_fwstate(padapter, _FW_LINKED))
+						if (check_buddy_fwstate(padapter, _FW_LINKED))
 							rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr));
 					}
 #endif
@@ -3827,10 +3827,10 @@ int rtw_p2p_check_frames(struct rtw_adap
 					int flags = -1;
 					int op_ch = 0;
 
-					if(tx)
+					if (tx)
 					{
 						#ifdef CONFIG_CONCURRENT_MODE
-						if(check_buddy_fwstate(padapter, _FW_LINKED))
+						if (check_buddy_fwstate(padapter, _FW_LINKED))
 							rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr));
 						#endif
 					}
@@ -3856,10 +3856,10 @@ int rtw_p2p_check_frames(struct rtw_adap
 					int status = -1;
 					int op_ch = 0;
 
-					if(tx)
+					if (tx)
 					{
 						#ifdef CONFIG_CONCURRENT_MODE
-						if(check_buddy_fwstate(padapter, _FW_LINKED))
+						if (check_buddy_fwstate(padapter, _FW_LINKED))
 							rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct rtw_ieee80211_hdr_3addr));
 						#endif
 					}
@@ -3896,14 +3896,14 @@ int rtw_p2p_check_frames(struct rtw_adap
 
 					DBG_8192D("RTW_%s:P2P_PROVISION_DISC_REQ, dialogToken=%d\n", (tx==true)?"Tx":"Rx", dialogToken);
 
-					//if(tx)
+					//if (tx)
 					{
 						pwdev_priv->provdisc_req_issued = false;
 
-						if( (p2p_ie=rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)))
+						if ( (p2p_ie=rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)))
 						{
 
-							if(rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, NULL, &contentlen))
+							if (rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, NULL, &contentlen))
 							{
 								pwdev_priv->provdisc_req_issued = false;//case: p2p_client join p2p GO
 							}
@@ -3930,7 +3930,7 @@ int rtw_p2p_check_frames(struct rtw_adap
 		}
 
 	}
-	else if(category == RTW_WLAN_CATEGORY_P2P)
+	else if (category == RTW_WLAN_CATEGORY_P2P)
 	{
 		OUI_Subtype = frame_body[5];
 		dialogToken = frame_body[6];
@@ -4085,16 +4085,16 @@ void process_p2p_ps_ie(struct rtw_adapte
 
 _func_enter_;
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		return;
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->iface_type != IFACE_PORT0)
+	if (padapter->iface_type != IFACE_PORT0)
 		return;
 #endif
-	if(IELength <= _BEACON_IE_OFFSET_)
+	if (IELength <= _BEACON_IE_OFFSET_)
 		return;
 
 	ies = IEs + _BEACON_IE_OFFSET_;
@@ -4106,12 +4106,12 @@ _func_enter_;
 	{
 		find_p2p = true;
 		// Get Notice of Absence IE.
-		if(rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_NOA, noa_attr, &attr_contentlen))
+		if (rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_NOA, noa_attr, &attr_contentlen))
 		{
 			find_p2p_ps = true;
 			noa_index = noa_attr[0];
 
-			if( (pwdinfo->p2p_ps_mode == P2P_PS_NONE) ||
+			if ( (pwdinfo->p2p_ps_mode == P2P_PS_NONE) ||
 				(noa_index != pwdinfo->noa_index) )// if index change, driver should reconfigure related setting.
 			{
 				pwdinfo->noa_index = noa_index;
@@ -4121,7 +4121,7 @@ _func_enter_;
 				noa_offset = 2;
 				noa_num = 0;
 				// NoA length should be n*(13) + 2
-				if(attr_contentlen > 2)
+				if (attr_contentlen > 2)
 				{
 					while(noa_offset < attr_contentlen)
 					{
@@ -4143,21 +4143,21 @@ _func_enter_;
 				}
 				pwdinfo->noa_num = noa_num;
 
-				if( pwdinfo->opp_ps == 1 )
+				if ( pwdinfo->opp_ps == 1 )
 				{
 					pwdinfo->p2p_ps_mode = P2P_PS_CTWINDOW;
 					// driver should wait LPS for entering CTWindow
-					if(padapter->pwrctrlpriv.bFwCurrentInPSMode == true)
+					if (padapter->pwrctrlpriv.bFwCurrentInPSMode == true)
 					{
 						p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 1);
 					}
 				}
-				else if( pwdinfo->noa_num > 0 )
+				else if ( pwdinfo->noa_num > 0 )
 				{
 					pwdinfo->p2p_ps_mode = P2P_PS_NOA;
 					p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 1);
 				}
-				else if( pwdinfo->p2p_ps_mode > P2P_PS_NONE)
+				else if ( pwdinfo->p2p_ps_mode > P2P_PS_NONE)
 				{
 					p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
 				}
@@ -4171,9 +4171,9 @@ _func_enter_;
 
 	}
 
-	if(find_p2p == true)
+	if (find_p2p == true)
 	{
-		if( (pwdinfo->p2p_ps_mode > P2P_PS_NONE) && (find_p2p_ps == false) )
+		if ( (pwdinfo->p2p_ps_mode > P2P_PS_NONE) && (find_p2p_ps == false) )
 		{
 			p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
 		}
@@ -4201,9 +4201,9 @@ _func_enter_;
 			pwdinfo->opp_ps = 0;
 			pwdinfo->noa_num = 0;
 			pwdinfo->p2p_ps_mode = P2P_PS_NONE;
-			if(padapter->pwrctrlpriv.bFwCurrentInPSMode == true)
+			if (padapter->pwrctrlpriv.bFwCurrentInPSMode == true)
 			{
-				if(pwrpriv->smart_ps == 0)
+				if (pwrpriv->smart_ps == 0)
 				{
 					pwrpriv->smart_ps = 2;
 					rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&(padapter->pwrctrlpriv.pwr_mode)));
@@ -4214,9 +4214,9 @@ _func_enter_;
 			if (pwdinfo->p2p_ps_mode > P2P_PS_NONE) {
 				pwdinfo->p2p_ps_state = p2p_ps_state;
 
-				if( pwdinfo->ctwindow > 0 )
+				if ( pwdinfo->ctwindow > 0 )
 				{
-					if(pwrpriv->smart_ps != 0)
+					if (pwrpriv->smart_ps != 0)
 					{
 						pwrpriv->smart_ps = 0;
 						DBG_8192D("%s(): Enter CTW, change SmartPS\n", __func__);
@@ -4260,16 +4260,16 @@ _func_enter_;
 		return res;
 	}
 
-	if(enqueue)
+	if (enqueue)
 	{
 		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-		if(ph2c==NULL){
+		if (ph2c==NULL){
 			res= _FAIL;
 			goto exit;
 		}
 
 		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
-		if(pdrvextra_cmd_parm==NULL){
+		if (pdrvextra_cmd_parm==NULL){
 			kfree(ph2c);
 			res= _FAIL;
 			goto exit;
@@ -4302,7 +4302,7 @@ static void reset_ch_sitesurvey_timer_pr
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 
 	DBG_8192D( "[%s] In\n", __func__ );
@@ -4316,7 +4316,7 @@ static void reset_ch_sitesurvey_timer_pr
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 
 	DBG_8192D( "[%s] In\n", __func__ );
@@ -4330,7 +4330,7 @@ static void restore_p2p_state_timer_proc
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 
 	p2p_protocol_wk_cmd( adapter, P2P_RESTORE_STATE_WK );
@@ -4343,7 +4343,7 @@ static void pre_tx_scan_timer_process (v
 	struct mlme_priv					*pmlmepriv = &adapter->mlmepriv;
 	u8								_status = 0;
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 
 	spin_lock_bh(&pmlmepriv->lock);
@@ -4351,7 +4351,7 @@ static void pre_tx_scan_timer_process (v
 	//	Commented by Albert 20110805
 	//	Todo: Use the issuing probe request directly instead of using the rtw_sitesurvey_cmd!!
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
 	{
 		if ( true == pwdinfo->tx_prov_disc_info.benable )	//	the provision discovery request frame is trigger to send or not
 		{
@@ -4389,7 +4389,7 @@ static void find_phase_timer_process (vo
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 
 	adapter->wdinfo.find_phase_state_exchange_cnt++;
@@ -4406,7 +4406,7 @@ void ap_p2p_switch_timer_process (void *
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
 #endif
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 
 #ifdef CONFIG_IOCTL_CFG80211
@@ -4664,7 +4664,7 @@ char * p2p_state_str[] = {
 
 void dbg_rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line)
 {
-	if(!_rtw_p2p_chk_state(wdinfo, state)) {
+	if (!_rtw_p2p_chk_state(wdinfo, state)) {
 		enum P2P_STATE old_state = _rtw_p2p_state(wdinfo);
 		_rtw_p2p_set_state(wdinfo, state);
 		DBG_8192D("[CONFIG_DBG_P2P]%s:%d set_state from %s to %s\n", caller, line
@@ -4678,7 +4678,7 @@ void dbg_rtw_p2p_set_state(struct wifidi
 }
 void dbg_rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line)
 {
-	if(_rtw_p2p_pre_state(wdinfo) != state) {
+	if (_rtw_p2p_pre_state(wdinfo) != state) {
 		enum P2P_STATE old_state = _rtw_p2p_pre_state(wdinfo);
 		_rtw_p2p_set_pre_state(wdinfo, state);
 		DBG_8192D("[CONFIG_DBG_P2P]%s:%d set_pre_state from %s to %s\n", caller, line
@@ -4693,7 +4693,7 @@ void dbg_rtw_p2p_set_pre_state(struct wi
 
 void dbg_rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role, const char *caller, int line)
 {
-	if(wdinfo->role != role) {
+	if (wdinfo->role != role) {
 		enum P2P_ROLE old_role = wdinfo->role;
 		_rtw_p2p_set_role(wdinfo, role);
 		DBG_8192D("[CONFIG_DBG_P2P]%s:%d set_role from %s to %s\n", caller, line
@@ -4725,7 +4725,7 @@ int rtw_p2p_enable(struct rtw_adapter *p
 		//	Commented by Albert 2011/12/30
 		//	The driver just supports 1 P2P group operation.
 		//	So, this function will do nothing if the buddy adapter had enabled the P2P function.
-		if(!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
+		if (!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
 		{
 			//	The buddy adapter had enabled the P2P function.
 			return ret;
@@ -4755,7 +4755,7 @@ int rtw_p2p_enable(struct rtw_adapter *p
 		}
 
 		//Disable P2P function
-		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
 			_cancel_timer_ex( &pwdinfo->find_phase_timer );
 			_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -41,9 +41,9 @@ void ips_enter(struct rtw_adapter * pada
 	pwrpriv->ips_enter_cnts++;
 	DBG_8192D("==>ips_enter cnts:%d\n",pwrpriv->ips_enter_cnts);
 
-	if(rf_off == pwrpriv->change_rfpwrstate )
+	if (rf_off == pwrpriv->change_rfpwrstate )
 	{
-		if(pwrpriv->ips_mode == IPS_LEVEL_2)
+		if (pwrpriv->ips_mode == IPS_LEVEL_2)
 			pwrpriv->bkeepfwalive = true;
 
 		rtw_ips_pwr_down(padapter);
@@ -62,7 +62,7 @@ int ips_leave(struct rtw_adapter * padap
 	int result = _SUCCESS;
 	int keyid;
 	_enter_pwrlock(&pwrpriv->lock);
-	if((pwrpriv->rf_pwrstate == rf_off) &&(!pwrpriv->bips_processing))
+	if ((pwrpriv->rf_pwrstate == rf_off) &&(!pwrpriv->bips_processing))
 	{
 		pwrpriv->bips_processing = true;
 		pwrpriv->change_rfpwrstate = rf_on;
@@ -73,13 +73,13 @@ int ips_leave(struct rtw_adapter * padap
 			pwrpriv->rf_pwrstate = rf_on;
 		}
 
-		if((_WEP40_ == psecuritypriv->dot11PrivacyAlgrthm) ||(_WEP104_ == psecuritypriv->dot11PrivacyAlgrthm))
+		if ((_WEP40_ == psecuritypriv->dot11PrivacyAlgrthm) ||(_WEP104_ == psecuritypriv->dot11PrivacyAlgrthm))
 		{
 			DBG_8192D("==>%s,channel(%d),processing(%x)\n",__func__,padapter->mlmeextpriv.cur_channel,pwrpriv->bips_processing);
 			set_channel_bwmode(padapter, padapter->mlmeextpriv.cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 			for(keyid=0;keyid<4;keyid++){
-				if(pmlmepriv->key_mask & BIT(keyid)){
-					if(keyid == psecuritypriv->dot11PrivacyKeyIndex)
+				if (pmlmepriv->key_mask & BIT(keyid)){
+					if (keyid == psecuritypriv->dot11PrivacyKeyIndex)
 						result=rtw_set_key(padapter,psecuritypriv, keyid, 1);
 					else
 						result=rtw_set_key(padapter,psecuritypriv, keyid, 0);
@@ -185,25 +185,25 @@ void rtw_ps_processor(struct rtw_adapter
 	pwrpriv->ps_processing = true;
 
 #ifdef SUPPORT_HW_RFOFF_DETECTED
-	if(pwrpriv->bips_processing == true)
+	if (pwrpriv->bips_processing == true)
 		goto exit;
 
 	//DBG_8192D("==> fw report state(0x%x)\n",rtw_read8(padapter,0x1ca));
-	if(padapter->pwrctrlpriv.bHWPwrPindetect)
+	if (padapter->pwrctrlpriv.bHWPwrPindetect)
 	{
 	#ifdef CONFIG_AUTOSUSPEND
-		if(padapter->registrypriv.usbss_enable)
+		if (padapter->registrypriv.usbss_enable)
 		{
-			if(pwrpriv->rf_pwrstate == rf_on)
+			if (pwrpriv->rf_pwrstate == rf_on)
 			{
-				if(padapter->net_closed == true)
+				if (padapter->net_closed == true)
 					pwrpriv->ps_flag = true;
 
 				rfpwrstate = RfOnOffDetect(padapter);
 				DBG_8192D("@@@@- #1  %s==> rfstate:%s \n",__func__,(rfpwrstate==rf_on)?"rf_on":"rf_off");
-				if(rfpwrstate!= pwrpriv->rf_pwrstate)
+				if (rfpwrstate!= pwrpriv->rf_pwrstate)
 				{
-					if(rfpwrstate == rf_off)
+					if (rfpwrstate == rf_off)
 					{
 						pwrpriv->change_rfpwrstate = rf_off;
 
@@ -221,9 +221,9 @@ void rtw_ps_processor(struct rtw_adapter
 			rfpwrstate = RfOnOffDetect(padapter);
 			DBG_8192D("@@@@- #2  %s==> rfstate:%s \n",__func__,(rfpwrstate==rf_on)?"rf_on":"rf_off");
 
-			if(rfpwrstate!= pwrpriv->rf_pwrstate)
+			if (rfpwrstate!= pwrpriv->rf_pwrstate)
 			{
-				if(rfpwrstate == rf_off)
+				if (rfpwrstate == rf_off)
 				{
 					pwrpriv->change_rfpwrstate = rf_off;
 					pwrpriv->brfoffbyhw = true;
@@ -252,24 +252,24 @@ void rtw_ps_processor(struct rtw_adapter
 	if (rtw_pwr_unassociated_idle(padapter) == false)
 		goto exit;
 
-	if((pwrpriv->rf_pwrstate == rf_on) && ((pwrpriv->pwr_state_check_cnts%4)==0))
+	if ((pwrpriv->rf_pwrstate == rf_on) && ((pwrpriv->pwr_state_check_cnts%4)==0))
 	{
 		DBG_8192D("==>%s .fw_state(%x)\n",__func__,get_fwstate(pmlmepriv));
 		pwrpriv->change_rfpwrstate = rf_off;
 
 		#ifdef CONFIG_AUTOSUSPEND
-		if(padapter->registrypriv.usbss_enable)
+		if (padapter->registrypriv.usbss_enable)
 		{
-			if(pwrpriv->bHWPwrPindetect)
+			if (pwrpriv->bHWPwrPindetect)
 				pwrpriv->bkeepfwalive = true;
 
-			if(padapter->net_closed == true)
+			if (padapter->net_closed == true)
 				pwrpriv->ps_flag = true;
 
 			padapter->bCardDisableWOHSM = true;
 			autosuspend_enter(padapter);
 		}
-		else if(pwrpriv->bHWPwrPindetect)
+		else if (pwrpriv->bHWPwrPindetect)
 		{
 		}
 		else
@@ -354,7 +354,7 @@ u8 PS_RDY_CHECK(struct rtw_adapter * pad
 
 	delta_time = curr_time -pwrpriv->DelayLPSLastTimeStamp;
 
-	if(delta_time < LPS_DELAY_TIME)
+	if (delta_time < LPS_DELAY_TIME)
 	{
 		return false;
 	}
@@ -365,10 +365,10 @@ u8 PS_RDY_CHECK(struct rtw_adapter * pad
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) )
 		return false;
 
-	if(true == pwrpriv->bInSuspend )
+	if (true == pwrpriv->bInSuspend )
 		return false;
 
-	if( (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) && (padapter->securitypriv.binstallGrpkey == false) )
+	if ( (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) && (padapter->securitypriv.binstallGrpkey == false) )
 	{
 		DBG_8192D("Group handshake still in progress !!!\n");
 		return false;
@@ -400,21 +400,21 @@ _func_enter_;
 			 ("%s: PowerMode=%d Smart_PS=%d\n",
 			  __func__, ps_mode, smart_ps));
 
-	if(ps_mode > PM_Card_Disable) {
+	if (ps_mode > PM_Card_Disable) {
 		RT_TRACE(_module_rtl871x_pwrctrl_c_,_drv_err_,("ps_mode:%d error\n", ps_mode));
 		return;
 	}
 
-	if((pwrpriv->pwr_mode == ps_mode) &&
+	if ((pwrpriv->pwr_mode == ps_mode) &&
 		(pwrpriv->smart_ps == smart_ps)){
 		return;
 	}
 
-	//if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
-	if(ps_mode == PS_MODE_ACTIVE)
+	//if (pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+	if (ps_mode == PS_MODE_ACTIVE)
 	{
 #ifdef CONFIG_P2P_PS
-		if(pwdinfo->opp_ps == 0)
+		if (pwdinfo->opp_ps == 0)
 #endif // CONFIG_P2P_PS
 		{
 #ifdef CONFIG_LPS_LCLK
@@ -433,7 +433,7 @@ _func_enter_;
 				{
 					ptdls_sta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
-					if( ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE )
+					if ( ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE )
 						issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 0);
 					plist = get_next(plist);
 				}
@@ -468,7 +468,7 @@ _func_enter_;
 	}
 	else
 	{
-		if(PS_RDY_CHECK(padapter))
+		if (PS_RDY_CHECK(padapter))
 		{
 #ifdef CONFIG_LPS_LCLK
 			_enter_pwrlock(&pwrpriv->lock);
@@ -487,7 +487,7 @@ _func_enter_;
 				{
 					ptdls_sta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
-					if( ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE )
+					if ( ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE )
 						issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 1);
 					plist = get_next(plist);
 				}
@@ -502,7 +502,7 @@ _func_enter_;
 			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&ps_mode));
 #ifdef CONFIG_P2P_PS
 			// Set CTWindow after LPS
-			if(pwdinfo->opp_ps == 1)
+			if (pwdinfo->opp_ps == 1)
 				p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 0);
 #endif // CONFIG_P2P_PS
 #ifdef CONFIG_LPS_LCLK
@@ -581,9 +581,9 @@ _func_enter_;
 
 	if (pwrpriv->bLeisurePs) {
 		// Idle for a while if we connect to AP a while ago.
-		if(pwrpriv->LpsIdleCount >= 2) //  4 Sec
+		if (pwrpriv->LpsIdleCount >= 2) //  4 Sec
 		{
-			if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+			if (pwrpriv->pwr_mode == PS_MODE_ACTIVE)
 			{
 				rtw_set_ps_mode(padapter, pwrpriv->power_mgnt, 2);
 			}
@@ -621,21 +621,21 @@ _func_enter_;
 
 	if (pwrpriv->bLeisurePs)
 	{
-		if(pwrpriv->pwr_mode != PS_MODE_ACTIVE)
+		if (pwrpriv->pwr_mode != PS_MODE_ACTIVE)
 		{
 			rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0);
 
-			if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+			if (pwrpriv->pwr_mode == PS_MODE_ACTIVE)
 			{
 				start_time = rtw_get_current_time();
 				while(1)
 				{
 					rtw_hal_get_hwreg(padapter, HW_VAR_FWLPS_RF_ON, (u8 *)(&bAwake));
 
-					if(bAwake || padapter->bSurpriseRemoved)
+					if (bAwake || padapter->bSurpriseRemoved)
 						break;
 
-					if(rtw_get_passing_time_ms(start_time)>LPS_LEAVE_TIMEOUT_MS)
+					if (rtw_get_passing_time_ms(start_time)>LPS_LEAVE_TIMEOUT_MS)
 					{
 						DBG_8192D("Wait for FW LPS leave more than %u ms!!!\n", LPS_LEAVE_TIMEOUT_MS);
 						break;
@@ -677,10 +677,10 @@ _func_enter_;
 	}
 	else
 	{
-		if(Adapter->pwrctrlpriv.rf_pwrstate== rf_off)
+		if (Adapter->pwrctrlpriv.rf_pwrstate== rf_off)
 		{
 			#ifdef CONFIG_AUTOSUSPEND
-			if(Adapter->registrypriv.usbss_enable)
+			if (Adapter->registrypriv.usbss_enable)
 			{
 				#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 				usb_disable_autosuspend(adapter_to_dvobj(Adapter)->pusbdev);
@@ -693,7 +693,7 @@ _func_enter_;
 			{
 			/*
 				#ifdef CONFIG_IPS
-				if(false == ips_leave(Adapter))
+				if (false == ips_leave(Adapter))
 				{
 					DBG_8192D("======> ips_leave fail.............\n");
 				}
@@ -1175,7 +1175,7 @@ static void rtw_late_resume(struct early
 	struct rtw_adapter *adapter = container_of(pwrpriv, _adapter, pwrctrlpriv);
 
 	DBG_8192D("%s\n",__func__);
-	if(pwrpriv->do_late_resume) {
+	if (pwrpriv->do_late_resume) {
 		rtw_set_do_late_resume(pwrpriv, false);
 		rtw_resume_process(adapter);
 	}
@@ -1224,7 +1224,7 @@ static void rtw_late_resume(android_earl
 	struct rtw_adapter *adapter = container_of(pwrpriv, _adapter, pwrctrlpriv);
 
 	DBG_8192D("%s\n",__func__);
-	if(pwrpriv->do_late_resume) {
+	if (pwrpriv->do_late_resume) {
 		rtw_set_do_late_resume(pwrpriv, false);
 		rtw_resume_process(adapter);
 	}
@@ -1323,13 +1323,13 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 	}
 
 	//System suspend is not allowed to wakeup
-	if((pwrpriv->bInternalAutoSuspend == false) && (true == pwrpriv->bInSuspend )){
+	if ((pwrpriv->bInternalAutoSuspend == false) && (true == pwrpriv->bInSuspend )){
 		ret = _FAIL;
 		goto exit;
 	}
 
 	//block???
-	if((pwrpriv->bInternalAutoSuspend == true)  && (padapter->net_closed == true)) {
+	if ((pwrpriv->bInternalAutoSuspend == true)  && (padapter->net_closed == true)) {
 		ret = _FAIL;
 		goto exit;
 	}
@@ -1341,19 +1341,19 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 		goto exit;
 	}
 
-	if(rf_off == pwrpriv->rf_pwrstate )
+	if (rf_off == pwrpriv->rf_pwrstate )
 	{
 #ifdef CONFIG_AUTOSUSPEND
-		 if(pwrpriv->brfoffbyhw==true)
+		 if (pwrpriv->brfoffbyhw==true)
 		{
 			DBG_8192D("hw still in rf_off state ...........\n");
 			ret = _FAIL;
 			goto exit;
 		}
-		else if(padapter->registrypriv.usbss_enable)
+		else if (padapter->registrypriv.usbss_enable)
 		{
 			DBG_8192D("%s call autoresume_enter....\n",__func__);
-			if(_FAIL ==  autoresume_enter(padapter))
+			if (_FAIL ==  autoresume_enter(padapter))
 			{
 				DBG_8192D("======> autoresume fail.............\n");
 				ret = _FAIL;
@@ -1365,7 +1365,7 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 		{
 #ifdef CONFIG_IPS
 			DBG_8192D("%s call ips_leave....\n",__func__);
-			if(_FAIL ==  ips_leave(padapter))
+			if (_FAIL ==  ips_leave(padapter))
 			{
 				DBG_8192D("======> ips_leave fail.............\n");
 				ret = _FAIL;
@@ -1376,7 +1376,7 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 	}
 
 	//TODO: the following checking need to be merged...
-	if(padapter->bDriverStopped
+	if (padapter->bDriverStopped
 		|| !padapter->bup
 		|| !padapter->hw_init_completed
 	){
@@ -1403,9 +1403,9 @@ int rtw_pm_set_lps(struct rtw_adapter *p
 
 	if ( mode < PS_MODE_NUM )
 	{
-		if(pwrctrlpriv->power_mgnt !=mode)
+		if (pwrctrlpriv->power_mgnt !=mode)
 		{
-			if(PS_MODE_ACTIVE == mode)
+			if (PS_MODE_ACTIVE == mode)
 			{
 				LeaveAllPowerSaveMode(padapter);
 			}
@@ -1429,15 +1429,15 @@ int rtw_pm_set_ips(struct rtw_adapter *p
 {
 	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 
-	if( mode == IPS_NORMAL || mode == IPS_LEVEL_2 ) {
+	if ( mode == IPS_NORMAL || mode == IPS_LEVEL_2 ) {
 		rtw_ips_mode_req(pwrctrlpriv, mode);
 		DBG_8192D("%s %s\n", __func__, mode == IPS_NORMAL?"IPS_NORMAL":"IPS_LEVEL_2");
 		return 0;
 	}
-	else if(mode ==IPS_NONE){
+	else if (mode ==IPS_NONE){
 		rtw_ips_mode_req(pwrctrlpriv, mode);
 		DBG_8192D("%s %s\n", __func__, "IPS_NONE");
-		if((padapter->bSurpriseRemoved ==0)&&(_FAIL == rtw_pwr_wakeup(padapter)) )
+		if ((padapter->bSurpriseRemoved ==0)&&(_FAIL == rtw_pwr_wakeup(padapter)) )
 			return -EFAULT;
 	}
 	else {
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -81,7 +81,7 @@ _func_enter_;
 
 	precvpriv->pallocated_frame_buf = rtw_zvmalloc(NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
 
-	if(precvpriv->pallocated_frame_buf==NULL){
+	if (precvpriv->pallocated_frame_buf==NULL){
 		res= _FAIL;
 		goto exit;
 	}
@@ -163,7 +163,7 @@ _func_enter_;
 
 	rtw_os_recv_resource_free(precvpriv);
 
-	if(precvpriv->pallocated_frame_buf) {
+	if (precvpriv->pallocated_frame_buf) {
 		rtw_vmfree(precvpriv->pallocated_frame_buf, NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
 	}
 
@@ -182,7 +182,7 @@ union recv_frame *_rtw_alloc_recvframe (
 	struct recv_priv *precvpriv;
 _func_enter_;
 
-	if(_rtw_queue_empty(pfree_recv_queue) == true)
+	if (_rtw_queue_empty(pfree_recv_queue) == true)
 	{
 		precvframe = NULL;
 	}
@@ -196,9 +196,9 @@ _func_enter_;
 
 		rtw_list_delete(&precvframe->u.hdr.list);
 		padapter=precvframe->u.hdr.adapter;
-		if(padapter !=NULL){
+		if (padapter !=NULL){
 			precvpriv=&padapter->recvpriv;
-			if(pfree_recv_queue == &precvpriv->free_recv_queue)
+			if (pfree_recv_queue == &precvpriv->free_recv_queue)
 				precvpriv->free_recvframe_cnt--;
 		}
 	}
@@ -238,7 +238,7 @@ int rtw_free_recvframe(union recv_frame
 _func_enter_;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->adapter_type > PRIMARY_ADAPTER)
+	if (padapter->adapter_type > PRIMARY_ADAPTER)
 	{
 		padapter = padapter->pbuddy_adapter;//get primary_padapter
 		precvpriv = &padapter->recvpriv;
@@ -246,7 +246,7 @@ _func_enter_;
 		precvframe->u.hdr.adapter = padapter;
 	}
 #endif
-	if(precvframe->u.hdr.pkt) {
+	if (precvframe->u.hdr.pkt) {
 #ifdef CONFIG_BSD_RX_USE_MBUF
 		m_freem(precvframe->u.hdr.pkt);
 #else	// CONFIG_BSD_RX_USE_MBUF
@@ -261,8 +261,8 @@ _func_enter_;
 
 	rtw_list_insert_tail(&(precvframe->u.hdr.list), get_list_head(pfree_recv_queue));
 
-	if(padapter !=NULL){
-		if(pfree_recv_queue == &precvpriv->free_recv_queue)
+	if (padapter !=NULL){
+		if (pfree_recv_queue == &precvpriv->free_recv_queue)
 				precvpriv->free_recvframe_cnt++;
 	}
 
@@ -399,7 +399,7 @@ struct recv_buf *rtw_dequeue_recvbuf(str
 
 	spin_lock_irqsave(&queue->lock, irqL);
 
-	if(_rtw_queue_empty(queue) == true)
+	if (_rtw_queue_empty(queue) == true)
 	{
 		precvbuf = NULL;
 	}
@@ -442,16 +442,16 @@ _func_enter_;
 
 	stainfo=rtw_get_stainfo(&adapter->stapriv ,&prxattrib->ta[0]);
 
-	if(prxattrib->encrypt ==_TKIP_)
+	if (prxattrib->encrypt ==_TKIP_)
 	{
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n recvframe_chkmic:prxattrib->encrypt ==_TKIP_\n"));
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n recvframe_chkmic:da=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
 			prxattrib->ra[0],prxattrib->ra[1],prxattrib->ra[2],prxattrib->ra[3],prxattrib->ra[4],prxattrib->ra[5]));
 
 		//calculate mic code
-		if(stainfo!= NULL)
+		if (stainfo!= NULL)
 		{
-			if(IS_MCAST(prxattrib->ra))
+			if (IS_MCAST(prxattrib->ra))
 			{
 				//mickey=&psecuritypriv->dot118021XGrprxmickey.skey[0];
 				//iv = precvframe->u.hdr.rx_data+prxattrib->hdrlen;
@@ -462,7 +462,7 @@ _func_enter_;
 				//DBG_8192D("\n recvframe_chkmic: bcmc key psecuritypriv->dot118021XGrpKeyid(%d),pmlmeinfo->key_index(%d) ,recv key_id(%d)\n",
 				//								psecuritypriv->dot118021XGrpKeyid,pmlmeinfo->key_index,rxdata_key_idx);
 
-				if(psecuritypriv->binstallGrpkey==false)
+				if (psecuritypriv->binstallGrpkey==false)
 				{
 					res=_FAIL;
 					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n recvframe_chkmic:didn't install group key!!!!!!!!!!\n"));
@@ -490,14 +490,14 @@ _func_enter_;
 			bmic_err=false;
 
 			for(i=0;i<8;i++){
-				if(miccode[i] != *(pframemic+i)){
+				if (miccode[i] != *(pframemic+i)){
 					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvframe_chkmic:miccode[%d](%02x) != *(pframemic+%d)(%02x) ",i,miccode[i],i,*(pframemic+i)));
 					bmic_err=true;
 				}
 			}
 
 
-			if(bmic_err==true){
+			if (bmic_err==true){
 
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n *(pframemic-8)-*(pframemic-1)=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
 					*(pframemic-8),*(pframemic-7),*(pframemic-6),*(pframemic-5),*(pframemic-4),*(pframemic-3),*(pframemic-2),*(pframemic-1)));
@@ -524,10 +524,10 @@ _func_enter_;
 
 				// double check key_index for some timing issue ,
 				// cannot compare with psecuritypriv->dot118021XGrpKeyid also cause timing issue
-				if((IS_MCAST(prxattrib->ra)==true)  && (prxattrib->key_index != pmlmeinfo->key_index ))
+				if ((IS_MCAST(prxattrib->ra)==true)  && (prxattrib->key_index != pmlmeinfo->key_index ))
 					brpt_micerror = false;
 
-				if(brpt_micerror == true)
+				if (brpt_micerror == true)
 				{
 					rtw_handle_tkip_mic_err(adapter,(u8)IS_MCAST(prxattrib->ra));
 					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" mic error :prxattrib->bdecrypted=%d \n", brpt_micerror));
@@ -539,7 +539,7 @@ _func_enter_;
 			}
 			else{
 				//mic checked ok
-				if((psecuritypriv->bcheck_grpkey ==false)&&(IS_MCAST(prxattrib->ra)==true)){
+				if ((psecuritypriv->bcheck_grpkey ==false)&&(IS_MCAST(prxattrib->ra)==true)){
 					psecuritypriv->bcheck_grpkey =true;
 					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("psecuritypriv->bcheck_grpkey =true"));
 				}
@@ -576,12 +576,12 @@ _func_enter_;
 
 	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("prxstat->decrypted=%x prxattrib->encrypt = 0x%03x\n",prxattrib->bdecrypted,prxattrib->encrypt));
 
-	if(prxattrib->encrypt>0)
+	if (prxattrib->encrypt>0)
 	{
 		u8 *iv = precv_frame->u.hdr.rx_data+prxattrib->hdrlen;
 		prxattrib->key_index = ( ((iv[3])>>6)&0x3) ;
 
-		if(prxattrib->key_index > WEP_KEYS)
+		if (prxattrib->key_index > WEP_KEYS)
 		{
 			DBG_8192D("prxattrib->key_index(%d) > WEP_KEYS \n", prxattrib->key_index);
 
@@ -599,11 +599,11 @@ _func_enter_;
 		}
 	}
 
-	if((prxattrib->encrypt>0) && ((prxattrib->bdecrypted==0) ||(psecuritypriv->sw_decrypt==true)))
+	if ((prxattrib->encrypt>0) && ((prxattrib->bdecrypted==0) ||(psecuritypriv->sw_decrypt==true)))
 	{
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if(!IS_MCAST(prxattrib->ra))//bc/mc packets use sw decryption for concurrent mode
+		if (!IS_MCAST(prxattrib->ra))//bc/mc packets use sw decryption for concurrent mode
 #endif
 		psecuritypriv->hw_decrypted=false;
 
@@ -627,7 +627,7 @@ _func_enter_;
 				break;
 		}
 	}
-	else if(prxattrib->bdecrypted==1
+	else if (prxattrib->bdecrypted==1
 		&& prxattrib->encrypt >0
 		&& (psecuritypriv->busetkipkey==1 || prxattrib->encrypt !=_TKIP_ )
 		)
@@ -645,7 +645,7 @@ _func_enter_;
 		#endif
 	}
 
-	if(res == _FAIL) {
+	if (res == _FAIL) {
 		rtw_free_recvframe(return_packet,&padapter->recvpriv.free_recv_queue);
 		return_packet = NULL;
 	}
@@ -681,7 +681,7 @@ _func_enter_;
 
 	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("########portctrl:adapter->securitypriv.dot11AuthAlgrthm= 0x%d\n",adapter->securitypriv.dot11AuthAlgrthm));
 
-	if(auth_alg==2)
+	if (auth_alg==2)
 	{
 		if ((psta!=NULL) && (psta->ieee8021x_blocked))
 		{
@@ -712,12 +712,12 @@ _func_enter_;
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("########portctrl:psta->ieee8021x_blocked==0\n"));
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("portctrl:precv_frame->hdr.attrib.privacy=%x\n",precv_frame->u.hdr.attrib.privacy));
 
-			if(pattrib->bdecrypted==0)
+			if (pattrib->bdecrypted==0)
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("portctrl:prxstat->decrypted=%x\n", pattrib->bdecrypted));
 
 			prtnframe=precv_frame;
 			//check is the EAPOL frame or not (Rekey)
-			if(ether_type == eapol_type){
+			if (ether_type == eapol_type){
 
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("########portctrl:ether_type == 0x888e\n"));
 				//check Rekey
@@ -750,16 +750,16 @@ int recv_decache(union recv_frame *precv
 
 _func_enter_;
 
-	if(tid>15)
+	if (tid>15)
 	{
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("recv_decache, (tid>15)! seq_ctrl=0x%x, tid=0x%x\n", seq_ctrl, tid));
 
 		return _FAIL;
 	}
 
-	if(1)//if(bretry)
+	if (1)//if (bretry)
 	{
-		if(seq_ctrl == prxcache->tid_rxseq[tid])
+		if (seq_ctrl == prxcache->tid_rxseq[tid])
 		{
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("recv_decache, seq_ctrl=0x%x, tid=0x%x, tid_rxseq=0x%x\n", seq_ctrl, tid, prxcache->tid_rxseq[tid]));
 
@@ -789,11 +789,11 @@ void process_pwrbit_data(struct rtw_adap
 
 	pwrbit = GetPwrMgt(ptr);
 
-	if(psta)
+	if (psta)
 	{
-		if(pwrbit)
+		if (pwrbit)
 		{
-			if(!(psta->state & WIFI_SLEEP_STATE))
+			if (!(psta->state & WIFI_SLEEP_STATE))
 			{
 				//psta->state |= WIFI_SLEEP_STATE;
 				//pstapriv->sta_dz_bitmap |= BIT(psta->aid);
@@ -805,7 +805,7 @@ void process_pwrbit_data(struct rtw_adap
 		}
 		else
 		{
-			if(psta->state & WIFI_SLEEP_STATE)
+			if (psta->state & WIFI_SLEEP_STATE)
 			{
 				//psta->state ^= WIFI_SLEEP_STATE;
 				//pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);
@@ -831,24 +831,24 @@ void process_wmmps_data(struct rtw_adapt
 
 	psta = rtw_get_stainfo(pstapriv, pattrib->src);
 
-	if(!psta) return;
+	if (!psta) return;
 
 #ifdef CONFIG_TDLS
-	if( !(psta->tdls_sta_state & TDLS_LINKED_STATE ) )
+	if ( !(psta->tdls_sta_state & TDLS_LINKED_STATE ) )
 	{
 #endif //CONFIG_TDLS
 
-	if(!psta->qos_option)
+	if (!psta->qos_option)
 		return;
 
-	if(!(psta->qos_info&0xf))
+	if (!(psta->qos_info&0xf))
 		return;
 
 #ifdef CONFIG_TDLS
 	}
 #endif //CONFIG_TDLS
 
-	if(psta->state&WIFI_SLEEP_STATE)
+	if (psta->state&WIFI_SLEEP_STATE)
 	{
 		u8 wmmps_ac=0;
 
@@ -873,9 +873,9 @@ void process_wmmps_data(struct rtw_adapt
 				break;
 		}
 
-		if(wmmps_ac)
+		if (wmmps_ac)
 		{
-			if(psta->sleepq_ac_len>0)
+			if (psta->sleepq_ac_len>0)
 			{
 				//process received triggered frame
 				xmit_delivery_enabled_frames(padapter, psta);
@@ -914,7 +914,7 @@ int OnTDLS(struct rtw_adapter *adapter,
 			+ PAYLOAD_TYPE_LEN
 			+ category_field;
 
-	if(ptdlsinfo->enable == 0)
+	if (ptdlsinfo->enable == 0)
 	{
 		DBG_8192D("recv tdls frame, "
 				"but tdls haven't enabled\n");
@@ -957,16 +957,16 @@ int OnTDLS(struct rtw_adapter *adapter,
 			break;
 #ifdef CONFIG_WFD
 		case 0x50:	//First byte of WFA OUI
-			if( _rtw_memcmp(WFA_OUI, (paction), 3) )
+			if ( _rtw_memcmp(WFA_OUI, (paction), 3) )
 			{
-				if( *(paction + 3) == 0x04)	//Probe request frame
+				if ( *(paction + 3) == 0x04)	//Probe request frame
 				{
 					//WFDTDLS: for sigma test, do not setup direct link automatically
 					ptdlsinfo->dev_discovered = 1;
 					DBG_8192D("recv tunneled probe request frame\n");
 					issue_tunneled_probe_rsp(adapter, precv_frame);
 				}
-				if( *(paction + 3) == 0x05)	//Probe response frame
+				if ( *(paction + 3) == 0x05)	//Probe response frame
 				{
 					//WFDTDLS: for sigma test, do not setup direct link automatically
 					ptdlsinfo->dev_discovered = 1;
@@ -1001,16 +1001,16 @@ void count_rx_stats(struct rtw_adapter *
 
 	padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod++;
 
-	if( (!MacAddr_isBcst(pattrib->dst)) && (!IS_MCAST(pattrib->dst))){
+	if ( (!MacAddr_isBcst(pattrib->dst)) && (!IS_MCAST(pattrib->dst))){
 		padapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod++;
 	}
 
-	if(sta)
+	if (sta)
 		psta = sta;
 	else
 		psta = prframe->u.hdr.psta;
 
-	if(psta)
+	if (psta)
 	{
 		pstats = &psta->sta_stats;
 
@@ -1061,12 +1061,12 @@ _func_enter_;
 			goto exit;
 		}
 
-		if( (!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))	&& (!bmcast) ){
+		if ( (!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))	&& (!bmcast) ){
 			ret= _FAIL;
 			goto exit;
 		}
 
-		if( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		if ( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 		   _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 		   (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) ) {
 			ret= _FAIL;
@@ -1076,23 +1076,23 @@ _func_enter_;
 		sta_addr = pattrib->src;
 
 	}
-	else if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+	else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 	{
 #ifdef CONFIG_TDLS
 		//direct link data transfer
-		if(ptdlsinfo->setup_state == TDLS_LINKED_STATE){
+		if (ptdlsinfo->setup_state == TDLS_LINKED_STATE){
 			ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->src);
-			if(ptdls_sta==NULL)
+			if (ptdls_sta==NULL)
 			{
 				ret=_FAIL;
 				goto exit;
 			}
-			else if(ptdls_sta->tdls_sta_state&TDLS_LINKED_STATE)
+			else if (ptdls_sta->tdls_sta_state&TDLS_LINKED_STATE)
 			{
 				//drop QoS-SubType Data, including QoS NULL, excluding QoS-Data
-				if( (GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE )== WIFI_QOS_DATA_TYPE)
+				if ( (GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE )== WIFI_QOS_DATA_TYPE)
 				{
-					if(GetFrameSubType(ptr)&(BIT(4)|BIT(5)|BIT(6)))
+					if (GetFrameSubType(ptr)&(BIT(4)|BIT(5)|BIT(6)))
 					{
 						DBG_8192D("drop QoS-Sybtype Data\n");
 						ret= _FAIL;
@@ -1105,13 +1105,13 @@ _func_enter_;
 					goto exit;
 				}
 				// da should be for me
-				if((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))&& (!bmcast))
+				if ((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))&& (!bmcast))
 				{
 					ret= _FAIL;
 					goto exit;
 				}
 				// check BSSID
-				if( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+				if ( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 				     _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 				     (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) )
 				{
@@ -1126,16 +1126,16 @@ _func_enter_;
 				if ((GetFrameSubType(ptr)) == WIFI_DATA_NULL)
 				{
 					//NULL-frame with pwrbit=1, buffer_STA should buffer frames for sleep_STA
-					if(GetPwrMgt(ptr))
+					if (GetPwrMgt(ptr))
 					{
 						DBG_8192D("TDLS: recv peer null frame with pwr bit 1\n");
 						ptdls_sta->tdls_sta_state|=TDLS_PEER_SLEEP_STATE;
 					}
 					// it would be triggered when we are off channel and receiving NULL DATA
 					// we can confirm that peer STA is at off channel
-					else if(ptdls_sta->tdls_sta_state&TDLS_CH_SWITCH_ON_STATE)
+					else if (ptdls_sta->tdls_sta_state&TDLS_CH_SWITCH_ON_STATE)
 					{
-						if((ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE) != TDLS_PEER_AT_OFF_STATE)
+						if ((ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE) != TDLS_PEER_AT_OFF_STATE)
 						{
 							issue_nulldata_to_TDLS_peer_STA(adapter, ptdls_sta, 0);
 							ptdls_sta->tdls_sta_state |= TDLS_PEER_AT_OFF_STATE;
@@ -1147,7 +1147,7 @@ _func_enter_;
 					goto exit;
 				}
 				//receive some of all TDLS management frames, process it at ON_TDLS
-				if((_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_TDLS, 2))){
+				if ((_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_TDLS, 2))){
 					ret= OnTDLS(adapter, precv_frame);
 					goto exit;
 				}
@@ -1161,7 +1161,7 @@ _func_enter_;
 #endif //CONFIG_TDLS
 		{
 			// For Station mode, sa and bssid should always be BSSID, and DA is my mac-address
-			if(!_rtw_memcmp(pattrib->bssid, pattrib->src, ETH_ALEN) )
+			if (!_rtw_memcmp(pattrib->bssid, pattrib->src, ETH_ALEN) )
 			{
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("bssid != TA under STATION_MODE; drop pkt\n"));
 				ret= _FAIL;
@@ -1171,7 +1171,7 @@ _func_enter_;
 			sta_addr = pattrib->bssid;
 		}
 	}
-	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		if (bmcast)
 		{
@@ -1184,7 +1184,7 @@ _func_enter_;
 		else // not mc-frame
 		{
 			// For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID
-			if(!_rtw_memcmp(pattrib->bssid, pattrib->dst, ETH_ALEN)) {
+			if (!_rtw_memcmp(pattrib->bssid, pattrib->dst, ETH_ALEN)) {
 				ret= _FAIL;
 				goto exit;
 			}
@@ -1193,7 +1193,7 @@ _func_enter_;
 		}
 
 	}
-	else if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
+	else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
 	{
 		memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
 		memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
@@ -1210,13 +1210,13 @@ _func_enter_;
 
 
 
-	if(bmcast)
+	if (bmcast)
 		*psta = rtw_get_bcmc_stainfo(adapter);
 	else
 		*psta = rtw_get_stainfo(pstapriv, sta_addr); // get ap_info
 
 #ifdef CONFIG_TDLS
-	if(ptdls_sta != NULL)
+	if (ptdls_sta != NULL)
 		*psta = ptdls_sta;
 #endif //CONFIG_TDLS
 
@@ -1224,7 +1224,7 @@ _func_enter_;
 	if (*psta == NULL) {
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("can't get psta under sta2sta_data_frame ; drop pkt\n"));
 #ifdef CONFIG_MP_INCLUDED
-		if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
+		if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
 		adapter->mppriv.rx_pktloss++;
 #endif
 		ret= _FAIL;
@@ -1278,7 +1278,7 @@ _func_enter_;
 		}
 
 		// da should be for me
-		if((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))&& (!bmcast))
+		if ((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))&& (!bmcast))
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,
 				(" ap2sta_data_frame:  compare DA fail; DA=%pM\n", pattrib->dst));
@@ -1291,7 +1291,7 @@ _func_enter_;
 
 
 		// check BSSID
-		if( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		if ( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 		     _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 		     (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) )
 		{
@@ -1304,7 +1304,7 @@ _func_enter_;
 			DBG_8192D( "this adapter = %d, buddy adapter = %d\n", adapter->adapter_type, adapter->pbuddy_adapter->adapter_type );
 			#endif
 
-			if(!bmcast) {
+			if (!bmcast) {
 				DBG_8192D("issue_deauth to the nonassociated ap=%pM for the reason(7)\n", pattrib->bssid);
 				issue_deauth(adapter, pattrib->bssid, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
 			}
@@ -1313,7 +1313,7 @@ _func_enter_;
 			goto exit;
 		}
 
-		if(bmcast)
+		if (bmcast)
 			*psta = rtw_get_bcmc_stainfo(adapter);
 		else
 			*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); // get ap_info
@@ -1371,7 +1371,7 @@ _func_enter_;
 	}
 	else
 	{
-		if(_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN)&& (!bmcast))
+		if (_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN)&& (!bmcast))
 		{
 			*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); // get sta_info
 			if (*psta == NULL)
@@ -1417,7 +1417,7 @@ _func_enter_;
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		//For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR
-		if(!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN))
+		if (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN))
 		{
 			ret= _FAIL;
 			goto exit;
@@ -1491,7 +1491,7 @@ int validate_recv_ctrl_frame(struct rtw_
 	}
 
 	//only handle ps-poll
-	if(GetFrameSubType(pframe) == WIFI_PSPOLL)
+	if (GetFrameSubType(pframe) == WIFI_PSPOLL)
 	{
 		u16 aid;
 		u8 wmmps_ac=0;
@@ -1500,7 +1500,7 @@ int validate_recv_ctrl_frame(struct rtw_
 		aid = GetAid(pframe);
 		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
 
-		if((psta==NULL) || (psta->aid!=aid))
+		if ((psta==NULL) || (psta->aid!=aid))
 		{
 			return _FAIL;
 		}
@@ -1529,17 +1529,17 @@ int validate_recv_ctrl_frame(struct rtw_
 				break;
 		}
 
-		if(wmmps_ac)
+		if (wmmps_ac)
 			return _FAIL;
 
-		if(psta->state & WIFI_STA_ALIVE_CHK_STATE)
+		if (psta->state & WIFI_STA_ALIVE_CHK_STATE)
 		{
 			DBG_8192D("%s alive check-rx ps-poll\n", __func__);
 			psta->expire_to = pstapriv->expire_to;
 			psta->state ^= WIFI_STA_ALIVE_CHK_STATE;
 		}
 
-		if((psta->state&WIFI_SLEEP_STATE) && (pstapriv->sta_dz_bitmap&BIT(psta->aid)))
+		if ((psta->state&WIFI_SLEEP_STATE) && (pstapriv->sta_dz_bitmap&BIT(psta->aid)))
 		{
 			struct list_head *xmitframe_plist, *xmitframe_phead;
 			struct xmit_frame *pxmitframe=NULL;
@@ -1559,7 +1559,7 @@ int validate_recv_ctrl_frame(struct rtw_
 
 				psta->sleepq_len--;
 
-				if(psta->sleepq_len>0)
+				if (psta->sleepq_len>0)
 					pxmitframe->attrib.mdata = 1;
                                 else
 					pxmitframe->attrib.mdata = 0;
@@ -1569,13 +1569,13 @@ int validate_recv_ctrl_frame(struct rtw_
 	                        //DBG_8192D("handling ps-poll, q_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
 
 				spin_unlock_bh(&psta->sleep_q.lock);
-				if(rtw_hal_xmit(padapter, pxmitframe) == true)
+				if (rtw_hal_xmit(padapter, pxmitframe) == true)
 				{
 					rtw_os_xmit_complete(padapter, pxmitframe);
 				}
 				spin_lock_bh(&psta->sleep_q.lock);
 
-				if(psta->sleepq_len==0)
+				if (psta->sleepq_len==0)
 				{
 					pstapriv->tim_bitmap &= ~BIT(psta->aid);
 
@@ -1590,9 +1590,9 @@ int validate_recv_ctrl_frame(struct rtw_
 			else
 			{
 				//DBG_8192D("no buffered packets to xmit\n");
-				if(pstapriv->tim_bitmap&BIT(psta->aid))
+				if (pstapriv->tim_bitmap&BIT(psta->aid))
 				{
-					if(psta->sleepq_len==0)
+					if (psta->sleepq_len==0)
 					{
 						DBG_8192D("no buffered packets to xmit\n");
 
@@ -1685,7 +1685,7 @@ _func_enter_;
 	psa = get_sa(ptr);
 	pbssid = get_hdr_bssid(ptr);
 
-	if(pbssid == NULL){
+	if (pbssid == NULL){
 		ret= _FAIL;
 		goto exit;
 	}
@@ -1728,7 +1728,7 @@ _func_enter_;
 
 	}
 
-	if(ret ==_FAIL){
+	if (ret ==_FAIL){
 		#ifdef DBG_RX_DROP_FRAME
 		DBG_8192D("DBG_RX_DROP_FRAME %s case:%d, res:%d\n", __func__, pattrib->to_fr_ds, ret);
 		#endif
@@ -1738,7 +1738,7 @@ _func_enter_;
 	}
 
 
-	if(psta==NULL){
+	if (psta==NULL){
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" after to_fr_ds_chk; psta==NULL \n"));
 		ret= _FAIL;
 		goto exit;
@@ -1752,14 +1752,14 @@ _func_enter_;
 	pattrib->amsdu=0;
 	pattrib->ack_policy = 0;
 	//parsing QC field
-	if(pattrib->qos == 1)
+	if (pattrib->qos == 1)
 	{
 		pattrib->priority = GetPriority((ptr + 24));
 		pattrib->ack_policy = GetAckpolicy((ptr + 24));
 		pattrib->amsdu = GetAMsdu((ptr + 24));
 		pattrib->hdrlen = pattrib->to_fr_ds==3 ? 32 : 26;
 
-		if(pattrib->priority!=0 && pattrib->priority!=3)
+		if (pattrib->priority!=0 && pattrib->priority!=3)
 		{
 			adapter->recvpriv.bIsAnyNonBEPkts = true;
 		}
@@ -1771,7 +1771,7 @@ _func_enter_;
 	}
 
 
-	if(pattrib->order)//HT-CTRL 11n
+	if (pattrib->order)//HT-CTRL 11n
 	{
 		pattrib->hdrlen += 4;
 	}
@@ -1779,20 +1779,20 @@ _func_enter_;
 	precv_frame->u.hdr.preorder_ctrl = &psta->recvreorder_ctrl[pattrib->priority];
 
 	// decache, drop duplicate recv packets
-	if(recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) == _FAIL)
+	if (recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) == _FAIL)
 	{
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("decache : drop pkt\n"));
 		ret= _FAIL;
 		goto exit;
 	}
 
-	if(pattrib->privacy){
+	if (pattrib->privacy){
 
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("validate_recv_data_frame:pattrib->privacy=%x\n", pattrib->privacy));
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n ^^^^^^^^^^^IS_MCAST(pattrib->ra(0x%02x))=%d^^^^^^^^^^^^^^^6\n", pattrib->ra[0],IS_MCAST(pattrib->ra)));
 
 #ifdef CONFIG_TDLS
-		if((psta->tdls_sta_state & TDLS_LINKED_STATE) && (psta->dot118021XPrivacy==_AES_))
+		if ((psta->tdls_sta_state & TDLS_LINKED_STATE) && (psta->dot118021XPrivacy==_AES_))
 		{
 				pattrib->encrypt=psta->dot118021XPrivacy;
 		}
@@ -1852,13 +1852,13 @@ _func_enter_;
 #endif
 
 #ifdef CONFIG_TDLS
-	if(ptdlsinfo->ch_sensing==1 && ptdlsinfo->cur_channel !=0){
+	if (ptdlsinfo->ch_sensing==1 && ptdlsinfo->cur_channel !=0){
 		ptdlsinfo->collect_pkt_num[ptdlsinfo->cur_channel-1]++;
 	}
 #endif //CONFIG_TDLS
 
 	//add version chk
-	if(ver!=0){
+	if (ver!=0){
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_data_frame fail! (ver!=0)\n"));
 		retval= _FAIL;
 		goto exit;
@@ -1935,7 +1935,7 @@ int wlanhdr_to_ethhdr ( union recv_frame
 
 _func_enter_;
 
-	if(pattrib->encrypt){
+	if (pattrib->encrypt){
 		recvframe_pull_tail(precvframe, pattrib->icv_len);
 	}
 
@@ -1943,7 +1943,7 @@ _func_enter_;
 	psnap_type=ptr+pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
 	/* convert hdr + possible LLC headers into Ethernet header */
 	//eth_type = (psnap_type[0] << 8) | psnap_type[1];
-	if((_rtw_memcmp(psnap, rtw_rfc1042_header, SNAP_SIZE) &&
+	if ((_rtw_memcmp(psnap, rtw_rfc1042_header, SNAP_SIZE) &&
 		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == false) &&
 		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2)==false) )||
 		//eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
@@ -1984,7 +1984,7 @@ _func_enter_;
 	memcpy(ptr, pattrib->dst, ETH_ALEN);
 	memcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);
 
-	if(!bsnaphdr) {
+	if (!bsnaphdr) {
 		len = htons(len);
 		memcpy(ptr+12, &len, 2);
 	}
@@ -2015,7 +2015,7 @@ _func_enter_;
 	pfhdr=&prframe->u.hdr;
 	rtw_list_delete(&(prframe->u.list));
 
-	if(curfragnum!=pfhdr->attrib.frag_num)
+	if (curfragnum!=pfhdr->attrib.frag_num)
 	{
 		//the first fragment number must be 0
 		//free the whole queue
@@ -2041,7 +2041,7 @@ _func_enter_;
 
 		//check the fragment sequence  (2nd ~n fragment frame)
 
-		if(curfragnum!=pnfhdr->attrib.frag_num)
+		if (curfragnum!=pnfhdr->attrib.frag_num)
 		{
 			//the fragment number must be increasing  (after decache)
 			//release the defrag_q & prframe
@@ -2130,12 +2130,12 @@ _func_enter_;
 	{
 		//0~(n-1) fragment frame
 		//enqueue to defraf_g
-		if(pdefrag_q != NULL)
+		if (pdefrag_q != NULL)
 		{
-			if(fragnum==0)
+			if (fragnum==0)
 			{
 				//the first fragment
-				if(_rtw_queue_empty(pdefrag_q) == false)
+				if (_rtw_queue_empty(pdefrag_q) == false)
 				{
 					//free current defrag_q
 					rtw_free_recvframe_queue(pdefrag_q, pfree_recv_queue);
@@ -2165,11 +2165,11 @@ _func_enter_;
 
 	}
 
-	if((ismfrag==0)&&(fragnum!=0))
+	if ((ismfrag==0)&&(fragnum!=0))
 	{
 		//the last fragment frame
 		//enqueue the last fragment
-		if(pdefrag_q != NULL)
+		if (pdefrag_q != NULL)
 		{
 			//_rtw_spinlock(&pdefrag_q->lock);
 			phead = get_list_head(pdefrag_q);
@@ -2193,10 +2193,10 @@ _func_enter_;
 	}
 
 
-	if((prtnframe!=NULL)&&(prtnframe->u.hdr.attrib.privacy))
+	if ((prtnframe!=NULL)&&(prtnframe->u.hdr.attrib.privacy))
 	{
 		//after defrag we must check tkip mic code
-		if(recvframe_chkmic(padapter,  prtnframe)==_FAIL)
+		if (recvframe_chkmic(padapter,  prtnframe)==_FAIL)
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvframe_chkmic(padapter,  prtnframe)==_FAIL\n"));
 			rtw_free_recvframe(prtnframe,pfree_recv_queue);
@@ -2230,7 +2230,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 
 	recvframe_pull(prframe, prframe->u.hdr.attrib.hdrlen);
 
-	if(prframe->u.hdr.attrib.iv_len >0)
+	if (prframe->u.hdr.attrib.iv_len >0)
 		recvframe_pull(prframe, prframe->u.hdr.attrib.iv_len);
 
 	a_len = prframe->u.hdr.len;
@@ -2250,7 +2250,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 		//ntohs(nSubframe_Length);
 #endif // ENDIAN_FREE
 
-		if( a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length) ) {
+		if ( a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length) ) {
 			DBG_8192D("nRemain_Length is %d and nSubframe_Length is : %d\n",a_len,nSubframe_Length);
 			goto exit;
 		}
@@ -2262,7 +2262,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 		/* Allocate new skb for releasing to upper layer */
 #ifdef CONFIG_SKB_COPY
 		sub_skb = dev_alloc_skb(nSubframe_Length + 12);
-		if(sub_skb)
+		if (sub_skb)
 		{
 			skb_reserve(sub_skb, 12);
 			data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
@@ -2272,7 +2272,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 #endif // CONFIG_SKB_COPY
 		{
 			sub_skb = skb_clone(prframe->u.hdr.pkt, GFP_ATOMIC);
-			if(sub_skb)
+			if (sub_skb)
 			{
 				sub_skb->data = pdata;
 				sub_skb->len = nSubframe_Length;
@@ -2287,20 +2287,20 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 
 
 		subframes[nr_subframes++] = sub_skb;
-		if(nr_subframes >= MAX_SUBFRAME_COUNT) {
+		if (nr_subframes >= MAX_SUBFRAME_COUNT) {
 			DBG_8192D("ParseSubframe(): Too many Subframes! Packets dropped!\n");
 			break;
 		}
 
 		pdata += nSubframe_Length;
 		a_len -= nSubframe_Length;
-		if(a_len != 0) {
+		if (a_len != 0) {
 			padding_len = 4 - ((nSubframe_Length + ETH_HLEN) & (4-1));
-			if(padding_len == 4) {
+			if (padding_len == 4) {
 				padding_len = 0;
 			}
 
-			if(a_len < padding_len) {
+			if (a_len < padding_len) {
 				goto exit;
 			}
 			pdata += padding_len;
@@ -2352,7 +2352,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 #endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 
 
-			if( br_port && (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) )
+			if ( br_port && (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) )
 			{
 				int nat25_handle_frame(struct rtw_adapter *priv, struct sk_buff *skb);
 				if (nat25_handle_frame(padapter, sub_skb) == -1) {
@@ -2416,7 +2416,7 @@ int check_indicate_seq(struct recv_reord
 	//DbgPrint("enter->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
 
 	// Drop out the packet which SeqNum is smaller than WinStart
-	if( SN_LESS(seq_num, preorder_ctrl->indicate_seq) )
+	if ( SN_LESS(seq_num, preorder_ctrl->indicate_seq) )
 	{
 		//RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum));
 		//DbgPrint("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
@@ -2435,7 +2435,7 @@ int check_indicate_seq(struct recv_reord
 	// 1. Incoming SeqNum is equal to WinStart =>Window shift 1
 	// 2. Incoming SeqNum is larger than the WinEnd => Window shift N
 	//
-	if( SN_EQUAL(seq_num, preorder_ctrl->indicate_seq) )
+	if ( SN_EQUAL(seq_num, preorder_ctrl->indicate_seq) )
 	{
 		preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1) & 0xFFF;
 		#ifdef DBG_RX_SEQ
@@ -2443,13 +2443,13 @@ int check_indicate_seq(struct recv_reord
 			preorder_ctrl->indicate_seq, seq_num);
 		#endif
 	}
-	else if(SN_LESS(wend, seq_num))
+	else if (SN_LESS(wend, seq_num))
 	{
 		//RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Window Shift! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum));
 		//DbgPrint("CheckRxTsIndicateSeq(): Window Shift! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
 
 		// boundary situation, when seq_num cross 0xFFF
-		if(seq_num >= (wsize - 1))
+		if (seq_num >= (wsize - 1))
 			preorder_ctrl->indicate_seq = seq_num + 1 -wsize;
 		else
 			preorder_ctrl->indicate_seq = 0xFFF - (wsize - (seq_num + 1)) + 1;
@@ -2482,11 +2482,11 @@ int enqueue_reorder_recvframe(struct rec
 		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pnextattrib = &pnextrframe->u.hdr.attrib;
 
-		if(SN_LESS(pnextattrib->seq_num, pattrib->seq_num))
+		if (SN_LESS(pnextattrib->seq_num, pattrib->seq_num))
 		{
 			plist = get_next(plist);
 		}
-		else if( SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))
+		else if ( SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))
 		{
 			//Duplicate entry is found!! Do not insert current entry.
 			//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
@@ -2535,9 +2535,9 @@ int recv_indicatepkts_in_order(struct rt
 	plist = get_next(phead);
 
 	// Handling some condition for forced indicate case.
-	if(bforced==true)
+	if (bforced==true)
 	{
-		if(rtw_is_list_empty(phead))
+		if (rtw_is_list_empty(phead))
 		{
 			// spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
 			//_rtw_spinunlock_ex(&ppending_recvframe_queue->lock);
@@ -2561,7 +2561,7 @@ int recv_indicatepkts_in_order(struct rt
 		prframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pattrib = &prframe->u.hdr.attrib;
 
-		if(!SN_LESS(preorder_ctrl->indicate_seq, pattrib->seq_num))
+		if (!SN_LESS(preorder_ctrl->indicate_seq, pattrib->seq_num))
 		{
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
 				 ("recv_indicatepkts_in_order: indicate=%d seq=%d amsdu=%d\n",
@@ -2570,7 +2570,7 @@ int recv_indicatepkts_in_order(struct rt
 			plist = get_next(plist);
 			rtw_list_delete(&(prframe->u.hdr.list));
 
-			if(SN_EQUAL(preorder_ctrl->indicate_seq, pattrib->seq_num))
+			if (SN_EQUAL(preorder_ctrl->indicate_seq, pattrib->seq_num))
 			{
 				preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1) & 0xFFF;
 				#ifdef DBG_RX_SEQ
@@ -2580,15 +2580,15 @@ int recv_indicatepkts_in_order(struct rt
 			}
 
 			//indicate this recv_frame
-			if(!pattrib->amsdu)
+			if (!pattrib->amsdu)
 			{
 				if ((padapter->bDriverStopped == false) &&
 				    (padapter->bSurpriseRemoved == false))
 
 					rtw_recv_indicatepkt(padapter, prframe);//indicate this recv_frame
 
-			} else if(pattrib->amsdu==1) {
-				if(amsdu_to_msdu(padapter, prframe)!=_SUCCESS)
+			} else if (pattrib->amsdu==1) {
+				if (amsdu_to_msdu(padapter, prframe)!=_SUCCESS)
 				{
 					rtw_free_recvframe(prframe, &precvpriv->free_recv_queue);
 				}
@@ -2618,7 +2618,7 @@ int recv_indicatepkts_in_order(struct rt
 
 /*
 	//Release the indication lock and set to new indication step.
-	if(bPktInBuf)
+	if (bPktInBuf)
 	{
 		// Set new pending timer.
 		//pTS->RxIndicateState = RXTS_INDICATE_REORDER;
@@ -2646,7 +2646,7 @@ int recv_indicatepkt_reorder(struct rtw_
 	struct recv_reorder_ctrl *preorder_ctrl = prframe->u.hdr.preorder_ctrl;
 	struct __queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
 
-	if(!pattrib->amsdu)
+	if (!pattrib->amsdu)
 	{
 		//s1.
 		wlanhdr_to_ethhdr(prframe);
@@ -2699,7 +2699,7 @@ int recv_indicatepkt_reorder(struct rtw_
 #endif
 
 	}
-	else if(pattrib->amsdu==1) //temp filter -> means didn't support A-MSDUs in a A-MPDU
+	else if (pattrib->amsdu==1) //temp filter -> means didn't support A-MSDUs in a A-MPDU
 	{
 		if (preorder_ctrl->enable == false)
 		{
@@ -2717,7 +2717,7 @@ int recv_indicatepkt_reorder(struct rtw_
 				preorder_ctrl->indicate_seq, pattrib->seq_num);
 			#endif
 
-			if(retval != _SUCCESS){
+			if (retval != _SUCCESS){
 				#ifdef DBG_RX_DROP_FRAME
 				DBG_8192D("DBG_RX_DROP_FRAME %s amsdu_to_msdu fail\n", __func__);
 				#endif
@@ -2738,7 +2738,7 @@ int recv_indicatepkt_reorder(struct rtw_
 		  preorder_ctrl->indicate_seq, pattrib->seq_num));
 
 	//s2. check if winstart_b(indicate_seq) needs to been updated
-	if(!check_indicate_seq(preorder_ctrl, pattrib->seq_num))
+	if (!check_indicate_seq(preorder_ctrl, pattrib->seq_num))
 	{
 		//pHTInfo->RxReorderDropCounter++;
 		//ReturnRFDList(Adapter, pRfd);
@@ -2754,7 +2754,7 @@ int recv_indicatepkt_reorder(struct rtw_
 
 
 	//s3. Insert all packet into Reorder Queue to maintain its ordering.
-	if(!enqueue_reorder_recvframe(preorder_ctrl, prframe))
+	if (!enqueue_reorder_recvframe(preorder_ctrl, prframe))
 	{
 		//DbgPrint("recv_indicatepkt_reorder, enqueue_reorder_recvframe fail!\n");
 		//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
@@ -2777,7 +2777,7 @@ int recv_indicatepkt_reorder(struct rtw_
 	//
 
 	//recv_indicatepkts_in_order(padapter, preorder_ctrl, true);
-	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, false)==true)
+	if (recv_indicatepkts_in_order(padapter, preorder_ctrl, false)==true)
 	{
 		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
 		spin_unlock_bh(&ppending_recvframe_queue->lock);
@@ -2808,7 +2808,7 @@ void rtw_reordering_ctrl_timeout_handler
 	struct __queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
 
 
-	if(padapter->bDriverStopped ||padapter->bSurpriseRemoved)
+	if (padapter->bDriverStopped ||padapter->bSurpriseRemoved)
 	{
 		return;
 	}
@@ -2817,7 +2817,7 @@ void rtw_reordering_ctrl_timeout_handler
 
 	spin_lock_bh(&ppending_recvframe_queue->lock);
 
-	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, true)==true)
+	if (recv_indicatepkts_in_order(padapter, preorder_ctrl, true)==true)
 	{
 		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
 	}
@@ -2840,17 +2840,17 @@ int process_recv_indicatepkts(struct rtw
 	struct ht_priv	*phtpriv = &pmlmepriv->htpriv;
 
 #ifdef CONFIG_TDLS
-	if( (phtpriv->ht_option==true) ||
+	if ( (phtpriv->ht_option==true) ||
 		((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
 		 (psta->htpriv.ht_option==true) &&
 		 (psta->htpriv.ampdu_enable==true))) //B/G/N Mode
 #else
-	if(phtpriv->ht_option==true)  //B/G/N Mode
+	if (phtpriv->ht_option==true)  //B/G/N Mode
 #endif //CONFIG_TDLS
 	{
 		//prframe->u.hdr.preorder_ctrl = &precvpriv->recvreorder_ctrl[pattrib->priority];
 
-		if(recv_indicatepkt_reorder(padapter, prframe)!=_SUCCESS)// including perform A-MPDU Rx Ordering Buffer Control
+		if (recv_indicatepkt_reorder(padapter, prframe)!=_SUCCESS)// including perform A-MPDU Rx Ordering Buffer Control
 		{
 			#ifdef DBG_RX_DROP_FRAME
 			DBG_8192D("DBG_RX_DROP_FRAME %s recv_indicatepkt_reorder error!\n", __func__);
@@ -2868,7 +2868,7 @@ int process_recv_indicatepkts(struct rtw
 #endif
 	{
 		retval=wlanhdr_to_ethhdr (prframe);
-		if(retval != _SUCCESS)
+		if (retval != _SUCCESS)
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("wlanhdr_to_ethhdr: drop pkt \n"));
 			#ifdef DBG_RX_DROP_FRAME
@@ -2978,7 +2978,7 @@ int recv_func_posthandle(struct rtw_adap
 	psnap_type+=pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
 	pcategory = psnap_type + ETH_TYPE_LEN + PAYLOAD_TYPE_LEN;
 
-	if((_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_TDLS, ETH_TYPE_LEN)) &&
+	if ((_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_TDLS, ETH_TYPE_LEN)) &&
 		((*pcategory==RTW_WLAN_CATEGORY_TDLS) || (*pcategory==RTW_WLAN_CATEGORY_P2P))){
 		ret = OnTDLS(padapter, prframe);	//all of functions will return _FAIL
 		goto _exit_recv_func;
@@ -2986,7 +2986,7 @@ int recv_func_posthandle(struct rtw_adap
 #endif //CONFIG_TDLS
 
 	prframe = recvframe_chk_defrag(padapter, prframe);
-	if(prframe==NULL)	{
+	if (prframe==NULL)	{
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvframe_chk_defrag: drop pkt\n"));
 		#ifdef DBG_RX_DROP_FRAME
 		DBG_8192D("DBG_RX_DROP_FRAME %s recvframe_chk_defrag: drop pkt\n", __func__);
@@ -3005,7 +3005,7 @@ int recv_func_posthandle(struct rtw_adap
 	}
 
 #ifdef CONFIG_TDLS
-	if(padapter->tdlsinfo.setup_state == TDLS_LINKED_STATE)
+	if (padapter->tdlsinfo.setup_state == TDLS_LINKED_STATE)
 		ptdls_sta = rtw_get_stainfo(&padapter->stapriv, pattrib->src);
 	count_rx_stats(padapter, prframe, ptdls_sta);
 #else
@@ -3066,11 +3066,11 @@ int recv_func_posthandle(struct rtw_adap
 		}
 
 	}
-	else if(pattrib->amsdu==1)
+	else if (pattrib->amsdu==1)
 	{
 
 		ret = amsdu_to_msdu(padapter, prframe);
-		if(ret != _SUCCESS)
+		if (ret != _SUCCESS)
 		{
 			#ifdef DBG_RX_DROP_FRAME
 			DBG_8192D("DBG_RX_DROP_FRAME %s amsdu_to_msdu fail\n", __func__);
@@ -3119,7 +3119,7 @@ int recv_func(struct rtw_adapter *padapt
 
 	ret = recv_func_prehandle(padapter, rframe);
 
-	if(ret == _SUCCESS) {
+	if (ret == _SUCCESS) {
 
 		/* check if need to enqueue into uc_swdec_pending_queue*/
 		if (check_fwstate(mlmepriv, WIFI_STATION_STATE) &&
@@ -3193,20 +3193,20 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 	u32 num_signal_qual = 0;
 	u8 _alpha = 3; // this value is based on converging_constant = 5000 and sampling_interval = 1000
 
-	if(adapter->recvpriv.is_signal_dbg) {
+	if (adapter->recvpriv.is_signal_dbg) {
 		//update the user specific value, signal_strength_dbg, to signal_strength, rssi
 		adapter->recvpriv.signal_strength= adapter->recvpriv.signal_strength_dbg;
 		adapter->recvpriv.rssi=(s8)translate_percentage_to_dbm((u8)adapter->recvpriv.signal_strength_dbg);
 	} else {
 
-		if(recvpriv->signal_strength_data.update_req == 0) {// update_req is clear, means we got rx
+		if (recvpriv->signal_strength_data.update_req == 0) {// update_req is clear, means we got rx
 			avg_signal_strength = recvpriv->signal_strength_data.avg_val;
 			num_signal_strength = recvpriv->signal_strength_data.total_num;
 			// after avg_vals are accquired, we can re-stat the signal values
 			recvpriv->signal_strength_data.update_req = 1;
 		}
 
-		if(recvpriv->signal_qual_data.update_req == 0) {// update_req is clear, means we got rx
+		if (recvpriv->signal_qual_data.update_req == 0) {// update_req is clear, means we got rx
 			avg_signal_qual = recvpriv->signal_qual_data.avg_val;
 			num_signal_qual = recvpriv->signal_qual_data.total_num;
 			// after avg_vals are accquired, we can re-stat the signal values
@@ -3214,21 +3214,21 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 		}
 
 		//update value of signal_strength, rssi, signal_qual
-		if(check_fwstate(&adapter->mlmepriv, _FW_UNDER_SURVEY) == false) {
+		if (check_fwstate(&adapter->mlmepriv, _FW_UNDER_SURVEY) == false) {
 			tmp_s = (avg_signal_strength+(_alpha-1)*recvpriv->signal_strength);
-			if(tmp_s %_alpha)
+			if (tmp_s %_alpha)
 				tmp_s = tmp_s/_alpha + 1;
 			else
 				tmp_s = tmp_s/_alpha;
-			if(tmp_s>100)
+			if (tmp_s>100)
 				tmp_s = 100;
 
 			tmp_q = (avg_signal_qual+(_alpha-1)*recvpriv->signal_qual);
-			if(tmp_q %_alpha)
+			if (tmp_q %_alpha)
 				tmp_q = tmp_q/_alpha + 1;
 			else
 				tmp_q = tmp_q/_alpha;
-			if(tmp_q>100)
+			if (tmp_q>100)
 				tmp_q = 100;
 
 			recvpriv->signal_strength = tmp_s;
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -178,7 +178,7 @@ void rtw_wep_encrypt(struct rtw_adapter
 _func_enter_;
 
 
-	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
+	if (((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
 		return;
 
 #ifdef CONFIG_USB_TX_AGGREGATION
@@ -189,7 +189,7 @@ _func_enter_;
 #endif
 
 	//start to encrypt each fragment
-	if((pattrib->encrypt==_WEP40_)||(pattrib->encrypt==_WEP104_))
+	if ((pattrib->encrypt==_WEP40_)||(pattrib->encrypt==_WEP104_))
 	{
 		keylength=psecuritypriv->dot11DefKeylen[psecuritypriv->dot11PrivacyKeyIndex];
 
@@ -200,7 +200,7 @@ _func_enter_;
 			memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[psecuritypriv->dot11PrivacyKeyIndex].skey[0],keylength);
 			payload=pframe+pattrib->iv_len+pattrib->hdrlen;
 
-			if((curfragnum+1)==pattrib->nr_frags)
+			if ((curfragnum+1)==pattrib->nr_frags)
 			{	//the last fragment
 
 				length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
@@ -250,7 +250,7 @@ _func_enter_;
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
 
 	//start to decrypt recvframe
-	if((prxattrib->encrypt==_WEP40_)||(prxattrib->encrypt==_WEP104_))
+	if ((prxattrib->encrypt==_WEP40_)||(prxattrib->encrypt==_WEP104_))
 	{
 		iv=pframe+prxattrib->hdrlen;
 		//keyindex=(iv[3]&0x3);
@@ -270,7 +270,7 @@ _func_enter_;
 		//calculate icv and compare the icv
 		*((unsigned long *)crc)=le32_to_cpu(getcrc32(payload,length-4));
 
-		if(crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4])
+		if (crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4])
 		{
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_wep_decrypt:icv error crc[3](%x)!=payload[length-1](%x) || crc[2](%x)!=payload[length-2](%x) || crc[1](%x)!=payload[length-3](%x) || crc[0](%x)!=payload[length-4](%x)\n",
 						crc[3],payload[length-1],crc[2],payload[length-2],crc[1],payload[length-3],crc[0],payload[length-4]));
@@ -342,7 +342,7 @@ _func_enter_;
 	pmicdata->M |= ((unsigned long)b) << (8*pmicdata->nBytesInM);
 	pmicdata->nBytesInM++;
 	// Process the word if it is full.
-	if( pmicdata->nBytesInM >= 4 )
+	if ( pmicdata->nBytesInM >= 4 )
 	{
 		pmicdata->L ^= pmicdata->M;
 		pmicdata->R ^= ROL32( pmicdata->L, 17 );
@@ -405,16 +405,16 @@ _func_enter_;
 	priority[0]=pri;
 
 	/* Michael MIC pseudo header: DA, SA, 3 x 0, Priority */
-	if(header[1]&1){   //ToDS==1
+	if (header[1]&1){   //ToDS==1
 			rtw_secmicappend(&micdata, &header[16], 6);  //DA
-		if(header[1]&2)  //From Ds==1
+		if (header[1]&2)  //From Ds==1
 			rtw_secmicappend(&micdata, &header[24], 6);
 		else
 			rtw_secmicappend(&micdata, &header[10], 6);
 	}
 	else{	//ToDS==0
 		rtw_secmicappend(&micdata, &header[4], 6);   //DA
-		if(header[1]&2)  //From Ds==1
+		if (header[1]&2)  //From Ds==1
 			rtw_secmicappend(&micdata, &header[16], 6);
 		else
 			rtw_secmicappend(&micdata, &header[10], 6);
@@ -661,7 +661,7 @@ u32	rtw_tkip_encrypt(struct rtw_adapter
 	u32	res=_SUCCESS;
 _func_enter_;
 
-	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
+	if (((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
 		return _FAIL;
 
 #ifdef CONFIG_USB_TX_AGGREGATION
@@ -672,9 +672,9 @@ _func_enter_;
 #endif
 
 	//4 start to encrypt each fragment
-	if(pattrib->encrypt==_TKIP_){
+	if (pattrib->encrypt==_TKIP_){
 
-		if(pattrib->psta)
+		if (pattrib->psta)
 		{
 			stainfo = pattrib->psta;
 		}
@@ -686,7 +686,7 @@ _func_enter_;
 		if (stainfo!=NULL){
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_encrypt: stainfo!=NULL!!!\n"));
 
-			if(IS_MCAST(pattrib->ra))
+			if (IS_MCAST(pattrib->ra))
 			{
 				prwskey=psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
 			}
@@ -710,7 +710,7 @@ _func_enter_;
 
 				phase2(&rc4key[0],prwskey,(u16 *)&ttkey[0],pnl);
 
-				if((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
+				if ((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
 					RT_TRACE(_module_rtl871x_security_c_,_drv_info_,("pattrib->iv_len =%x, pattrib->icv_len =%x\n", pattrib->iv_len,pattrib->icv_len));
 					*((u32 *)crc)=cpu_to_le32(getcrc32(payload,length));/* modified by Amy*/
@@ -772,14 +772,14 @@ _func_enter_;
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
 
 	//4 start to decrypt recvframe
-	if(prxattrib->encrypt==_TKIP_){
+	if (prxattrib->encrypt==_TKIP_){
 
 		stainfo=rtw_get_stainfo(&padapter->stapriv ,&prxattrib->ta[0] );
 		if (stainfo!=NULL){
 
-			if(IS_MCAST(prxattrib->ra))
+			if (IS_MCAST(prxattrib->ra))
 			{
-				if(psecuritypriv->binstallGrpkey==false)
+				if (psecuritypriv->binstallGrpkey==false)
 				{
 					res=_FAIL;
 					DBG_8192D("%s:rx bc/mc packets,but didn't install group key!!!!!!!!!!\n",__func__);
@@ -816,7 +816,7 @@ _func_enter_;
 
 			*((u32 *)crc)=le32_to_cpu(getcrc32(payload,length-4));
 
-			if(crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4])
+			if (crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4])
 			{
 			    RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_wep_decrypt:icv error crc[3](%x)!=payload[length-1](%x) || crc[2](%x)!=payload[length-2](%x) || crc[1](%x)!=payload[length-3](%x) || crc[0](%x)!=payload[length-4](%x)\n",
 						crc[3],payload[length-1],crc[2],payload[length-2],crc[1],payload[length-3],crc[0],payload[length-4]));
@@ -1344,7 +1344,7 @@ _func_enter_;
 		(frtype == WIFI_DATA_CFACKPOLL))
 		{
 			qc_exists = 1;
-					if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+					if (hdrlen !=  WLAN_HDR_A3_QOS_LEN){
 
 					hdrlen += 2;
 			}
@@ -1355,7 +1355,7 @@ _func_enter_;
 		(frsubtype == 0x0a)||
 		(frsubtype == 0x0b))
 		{
-			if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN){
 
 					hdrlen += 2;
 			}
@@ -1513,7 +1513,7 @@ u32	rtw_aes_encrypt(struct rtw_adapter *
 	u32 res=_SUCCESS;
 _func_enter_;
 
-	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
+	if (((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
 		return _FAIL;
 
 #ifdef CONFIG_USB_TX_AGGREGATION
@@ -1524,9 +1524,9 @@ _func_enter_;
 #endif
 
 	//4 start to encrypt each fragment
-	if((pattrib->encrypt==_AES_)){
+	if ((pattrib->encrypt==_AES_)){
 
-		if(pattrib->psta)
+		if (pattrib->psta)
 		{
 			stainfo = pattrib->psta;
 		}
@@ -1538,7 +1538,7 @@ _func_enter_;
 		if (stainfo!=NULL){
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_encrypt: stainfo!=NULL!!!\n"));
 
-			if(IS_MCAST(pattrib->ra))
+			if (IS_MCAST(pattrib->ra))
 			{
 				prwskey=psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
 			}
@@ -1551,7 +1551,7 @@ _func_enter_;
 			{
 				struct	sta_info		*ptdls_sta;
 				ptdls_sta=rtw_get_stainfo(&padapter->stapriv ,&pattrib->dst[0] );
-				if((ptdls_sta != NULL) && (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) )
+				if ((ptdls_sta != NULL) && (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) )
 				{
 					DBG_8192D("[%s] for tdls link\n", __func__);
 					prwskey=&ptdls_sta->tpk.tk[0];
@@ -1563,7 +1563,7 @@ _func_enter_;
 
 			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
 
-				if((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
+				if ((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
 
 					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
@@ -1652,7 +1652,7 @@ _func_enter_;
 		(frtype == WIFI_DATA_CFACKPOLL))
 		{
 			qc_exists = 1;
-					if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+					if (hdrlen !=  WLAN_HDR_A3_QOS_LEN){
 
 					hdrlen += 2;
 			}
@@ -1663,7 +1663,7 @@ _func_enter_;
 		(frsubtype == 0x0a)||
 		(frsubtype == 0x0b))
 		{
-			if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN){
 
 					hdrlen += 2;
 			}
@@ -1847,7 +1847,7 @@ _func_enter_;
 
 	//compare the mic
 	for(i=0;i<8;i++){
-		if(pframe[hdrlen+8+plen-8+i] != message[hdrlen+8+plen-8+i])
+		if (pframe[hdrlen+8+plen-8+i] != message[hdrlen+8+plen-8+i])
 		{
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("aes_decipher:mic check error mic[%d]: pframe(%x) != message(%x) \n",
 						i,pframe[hdrlen+8+plen-8+i],message[hdrlen+8+plen-8+i]));
@@ -1857,7 +1857,7 @@ _func_enter_;
 		}
 	}
 
-	if(res == _FAIL)
+	if (res == _FAIL)
 	{
 		int gg=0;
 		for(gg=0; gg < 32; gg++)
@@ -1890,25 +1890,25 @@ u32	rtw_aes_decrypt(struct rtw_adapter *
 _func_enter_;
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
 	//4 start to encrypt each fragment
-	if((prxattrib->encrypt==_AES_)){
+	if ((prxattrib->encrypt==_AES_)){
 
 		stainfo=rtw_get_stainfo(&padapter->stapriv ,&prxattrib->ta[0] );
 		if (stainfo!=NULL){
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_decrypt: stainfo!=NULL!!!\n"));
 
-			if(IS_MCAST(prxattrib->ra))
+			if (IS_MCAST(prxattrib->ra))
 			{
 				//in concurrent we should use sw descrypt in group key, so we remove this message
 				//DBG_8192D("rx bc/mc packets, to perform sw rtw_aes_decrypt\n");
 				//prwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
-				if(psecuritypriv->binstallGrpkey==false) {
+				if (psecuritypriv->binstallGrpkey==false) {
 					res=_FAIL;
 					DBG_8192D("%s:rx bc/mc packets,but didn't install group key!!!!!!!!!!\n",__func__);
 					goto exit;
 				}
 				prwskey = psecuritypriv->dot118021XGrpKey[prxattrib->key_index].skey;
 
-				if(psecuritypriv->dot118021XGrpKeyid != prxattrib->key_index) {
+				if (psecuritypriv->dot118021XGrpKeyid != prxattrib->key_index) {
 					DBG_8192D("not match packet_index=%d, install_index=%d \n"
 					, prxattrib->key_index, psecuritypriv->dot118021XGrpKeyid);
 					res=_FAIL;
--- a/drivers/staging/rtl8192du/core/rtw_sreset.c
+++ b/drivers/staging/rtl8192du/core/rtw_sreset.c
@@ -50,20 +50,20 @@ u8 sreset_get_wifi_status(_adapter *pada
 
 	u8 status = WIFI_STATUS_SUCCESS;
 	u32 val32 = 0;
-	if(psrtpriv->silent_reset_inprogress == true)
+	if (psrtpriv->silent_reset_inprogress == true)
         {
 		return status;
 	}
 	val32 =rtw_read32(padapter,REG_TXDMA_STATUS);
-	if(val32==0xeaeaeaea){
+	if (val32==0xeaeaeaea){
 		psrtpriv->Wifi_Error_Status = WIFI_IF_NOT_EXIST;
 	}
-	else if(val32!=0){
+	else if (val32!=0){
 		DBG_8192C("txdmastatu(%x)\n",val32);
 		psrtpriv->Wifi_Error_Status = WIFI_MAC_TXDMA_ERROR;
 	}
 
-	if(WIFI_STATUS_SUCCESS !=psrtpriv->Wifi_Error_Status)
+	if (WIFI_STATUS_SUCCESS !=psrtpriv->Wifi_Error_Status)
 	{
 		DBG_8192C("==>%s error_status(0x%x) \n",__func__,psrtpriv->Wifi_Error_Status);
 		status = (psrtpriv->Wifi_Error_Status &( ~(USB_READ_PORT_FAIL|USB_WRITE_PORT_FAIL)));
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -85,7 +85,7 @@ _func_enter_;
 
 	pstapriv->pallocated_stainfo_buf = rtw_zvmalloc (sizeof(struct sta_info) * NUM_STA+ 4);
 
-	if(!pstapriv->pallocated_stainfo_buf)
+	if (!pstapriv->pallocated_stainfo_buf)
 		return _FAIL;
 
 	pstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -
@@ -193,7 +193,7 @@ void rtw_mfree_stainfo(struct sta_info *
 {
 _func_enter_;
 
-	if(&psta->lock != NULL)
+	if (&psta->lock != NULL)
 		 _rtw_spinlock_free(&psta->lock);
 
 	_rtw_free_sta_xmit_priv_lock(&psta->sta_xmitpriv);
@@ -260,7 +260,7 @@ u32	_rtw_free_sta_priv(struct	sta_priv *
 	int	index;
 
 _func_enter_;
-	if(pstapriv){
+	if (pstapriv){
 
 		/*	delete all reordering_ctrl_timer		*/
 		spin_lock_bh(&pstapriv->sta_hash_lock);
@@ -287,7 +287,7 @@ _func_enter_;
 
 		rtw_mfree_sta_priv_lock(pstapriv);
 
-		if(pstapriv->pallocated_stainfo_buf) {
+		if (pstapriv->pallocated_stainfo_buf) {
 			rtw_vmfree(pstapriv->pallocated_stainfo_buf, sizeof(struct sta_info)*NUM_STA+4);
 		}
 	}
@@ -338,7 +338,7 @@ _func_enter_;
 
 		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_info_,("rtw_alloc_stainfo: index  = %x", index));
 
-		if(index >= NUM_STA){
+		if (index >= NUM_STA){
 			RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("ERROR=> rtw_alloc_stainfo: index >= NUM_STA"));
 			psta= NULL;
 			goto exit;
@@ -582,7 +582,7 @@ void rtw_free_all_stainfo(struct rtw_ada
 
 _func_enter_;
 
-	if(pstapriv->asoc_sta_count==1)
+	if (pstapriv->asoc_sta_count==1)
 		goto exit;
 
 	spin_lock_bh(&pstapriv->sta_hash_lock);
@@ -598,7 +598,7 @@ _func_enter_;
 
 			plist = get_next(plist);
 
-			if(pbcmc_stainfo!=psta)
+			if (pbcmc_stainfo!=psta)
 				rtw_free_stainfo(padapter , psta);
 
 		}
@@ -624,10 +624,10 @@ struct sta_info *rtw_get_stainfo(struct
 
 _func_enter_;
 
-	if(hwaddr==NULL)
+	if (hwaddr==NULL)
 		return NULL;
 
-	if(IS_MCAST(hwaddr))
+	if (IS_MCAST(hwaddr))
 		addr = bc_addr;
 	else
 		addr = hwaddr;
@@ -673,7 +673,7 @@ _func_enter_;
 
 	psta = rtw_alloc_stainfo(pstapriv, bcast_addr);
 
-	if(psta==NULL){
+	if (psta==NULL){
 		res=_FAIL;
 		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("rtw_alloc_stainfo fail"));
 		goto exit;
@@ -722,9 +722,9 @@ u8 rtw_access_ctrl(struct rtw_adapter *p
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
 		plist = get_next(plist);
 
-		if(_rtw_memcmp(paclnode->addr, mac_addr, ETH_ALEN))
+		if (_rtw_memcmp(paclnode->addr, mac_addr, ETH_ALEN))
 		{
-			if(paclnode->valid == true)
+			if (paclnode->valid == true)
 			{
 				match = true;
 				break;
@@ -734,9 +734,9 @@ u8 rtw_access_ctrl(struct rtw_adapter *p
 	spin_unlock_bh(&(pacl_node_q->lock));
 
 
-	if(pacl_list->mode == 1)//accept unless in deny list
+	if (pacl_list->mode == 1)//accept unless in deny list
 		res = (match == true) ?  false:true;
-	else if(pacl_list->mode == 2)//deny unless in accept list
+	else if (pacl_list->mode == 2)//deny unless in accept list
 		res = (match == true) ?  true:false;
 	else
 		 res = true;
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ b/drivers/staging/rtl8192du/core/rtw_tdls.c
@@ -200,7 +200,7 @@ s32 update_tdls_attrib(_adapter *padapte
 		case _TKIP_:
 			pattrib->iv_len = 8;
 			pattrib->icv_len = 4;
-			if(padapter->securitypriv.busetkipkey==_FAIL)
+			if (padapter->securitypriv.busetkipkey==_FAIL)
 			{
 				res =_FAIL;
 				goto exit;
@@ -233,9 +233,9 @@ s32 update_tdls_attrib(_adapter *padapte
 	pattrib->sgi= psta->htpriv.sgi;
 	pattrib->ampdu_en = false;
 
-	//if(pattrib->ht_en && psta->htpriv.ampdu_enable)
+	//if (pattrib->ht_en && psta->htpriv.ampdu_enable)
 	//{
-	//	if(psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
+	//	if (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
 	//		pattrib->ampdu_en = true;
 	//}
 
@@ -251,21 +251,21 @@ void free_tdls_sta(_adapter *padapter, s
 
 	//free peer sta_info
 	spin_lock_bh(&(pstapriv->sta_hash_lock));
-	if(ptdlsinfo->sta_cnt != 0)
+	if (ptdlsinfo->sta_cnt != 0)
 		ptdlsinfo->sta_cnt--;
 	spin_unlock_bh(&(pstapriv->sta_hash_lock));
-	if( ptdlsinfo->sta_cnt < (NUM_STA - 2) )	// -2: AP + BC/MC sta
+	if ( ptdlsinfo->sta_cnt < (NUM_STA - 2) )	// -2: AP + BC/MC sta
 	{
 		ptdlsinfo->sta_maximum = false;
 		memset( &ptdlsinfo->ss_record, 0x00, sizeof(struct tdls_ss_record) );
 	}
 	//ready to clear cam
-	if(ptdls_sta->mac_id!=0){
+	if (ptdls_sta->mac_id!=0){
 		ptdlsinfo->clear_cam=ptdls_sta->mac_id;
 		rtw_setstakey_cmd(padapter, (u8 *)ptdls_sta, true);
 	}
 
-	if(ptdlsinfo->sta_cnt==0){
+	if (ptdlsinfo->sta_cnt==0){
 		rtw_tdls_cmd(padapter, myid(&(padapter->eeprompriv)), TDLS_RS_RCR);
 		ptdlsinfo->setup_state=TDLS_STATE_NONE;
 	}
@@ -279,10 +279,10 @@ void free_tdls_sta(_adapter *padapter, s
 // cam entry will be the same as mac_id
 void rtw_tdls_set_mac_id(struct tdls_info *ptdlsinfo, struct sta_info *ptdls_sta)
 {
-	if(ptdls_sta->mac_id==0)
+	if (ptdls_sta->mac_id==0)
 	{
 		ptdls_sta->mac_id = ptdlsinfo->macid_index;
-		if( (++ptdlsinfo->macid_index) > (NUM_STA -2) )
+		if ( (++ptdlsinfo->macid_index) > (NUM_STA -2) )
 			ptdlsinfo->macid_index= TDLS_INI_MACID_ENTRY;
 	}
 }
@@ -290,7 +290,7 @@ void rtw_tdls_set_mac_id(struct tdls_inf
 //TDLS encryption(if needed) will always be CCMP
 void rtw_tdls_set_key(_adapter *adapter, struct rx_pkt_attrib *prx_pkt_attrib, struct sta_info *ptdls_sta)
 {
-	if(prx_pkt_attrib->encrypt)
+	if (prx_pkt_attrib->encrypt)
 	{
 		ptdls_sta->dot118021XPrivacy=_AES_;
 		rtw_setstakey_cmd(adapter, (u8*)ptdls_sta, true);
@@ -312,9 +312,9 @@ void rtw_tdls_process_ht_cap(_adapter *a
 	} else
 		ptdls_sta->flags &= ~WLAN_STA_HT;
 
-	if(ptdls_sta->flags & WLAN_STA_HT)
+	if (ptdls_sta->flags & WLAN_STA_HT)
 	{
-		if(adapter->registrypriv.ht_enable == true)
+		if (adapter->registrypriv.ht_enable == true)
 		{
 			ptdls_sta->htpriv.ht_option = true;
 		}
@@ -326,20 +326,20 @@ void rtw_tdls_process_ht_cap(_adapter *a
 	}
 
 	//HT related cap
-	if(ptdls_sta->htpriv.ht_option)
+	if (ptdls_sta->htpriv.ht_option)
 	{
 		//check if sta supports rx ampdu
-		if(adapter->registrypriv.ampdu_enable==1)
+		if (adapter->registrypriv.ampdu_enable==1)
 			ptdls_sta->htpriv.ampdu_enable = true;
 
 		//check if sta support s Short GI
-		if(ptdls_sta->htpriv.ht_cap.cap_info & cpu_to_le16(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))
+		if (ptdls_sta->htpriv.ht_cap.cap_info & cpu_to_le16(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))
 		{
 			ptdls_sta->htpriv.sgi = true;
 		}
 
 		// bwmode would still followed AP's setting
-		if(ptdls_sta->htpriv.ht_cap.cap_info & cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH))
+		if (ptdls_sta->htpriv.ht_cap.cap_info & cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH))
 		{
 			ptdls_sta->htpriv.bwmode = adapter->mlmeextpriv.cur_bwmode;
 			ptdls_sta->htpriv.ch_offset = adapter->mlmeextpriv.cur_ch_offset;
@@ -362,7 +362,7 @@ u8 *rtw_tdls_set_ht_cap(_adapter *padapt
 		u32 rx_packet_offset, max_recvbuf_sz;
 		rtw_hal_get_def_var(padapter, HAL_DEF_RX_PACKET_OFFSET, &rx_packet_offset);
 		rtw_hal_get_def_var(padapter, HAL_DEF_MAX_RECVBUF_SZ, &max_recvbuf_sz);
-		if(max_recvbuf_sz-rx_packet_offset>(8191-256))
+		if (max_recvbuf_sz-rx_packet_offset>(8191-256))
 			ht_capie.cap_info = ht_capie.cap_info |IEEE80211_HT_CAP_MAX_AMSDU;
 	}
 
@@ -392,7 +392,7 @@ u8 *rtw_tdls_set_sup_ch(struct mlme_ext_
 {
 	u8 sup_ch[ 30 * 2 ] = { 0x00 }, sup_ch_idx = 0, idx_5g = 2;	//For supported channel
 	do{
-		if( pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14 )
+		if ( pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14 )
 		{
 			sup_ch[0] = 1;	//First channel number
 			sup_ch[1] = pmlmeext->channel_set[sup_ch_idx].ChannelNum;	//Number of channel
@@ -548,7 +548,7 @@ void issue_tdls_setup_req(_adapter *pada
 	static u8 dialogtoken = 0;
 	u32 timeout_interval= TPK_RESEND_COUNT * 1000;	//retry timer should set at least 301 sec, using TPK_count counting 301 times.
 
-	if(ptdlsinfo->ap_prohibited == true)
+	if (ptdlsinfo->ap_prohibited == true)
 		goto exit;
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
@@ -573,16 +573,16 @@ void issue_tdls_setup_req(_adapter *pada
 
 	//init peer sta_info
 	ptdls_sta = rtw_get_stainfo(pstapriv, mac_addr);
-	if(ptdls_sta==NULL)
+	if (ptdls_sta==NULL)
 	{
 		ptdls_sta = rtw_alloc_stainfo(pstapriv, mac_addr);
-		if(ptdls_sta)
+		if (ptdls_sta)
 		{
 			spin_lock_bh(&(pstapriv->sta_hash_lock));
-			if(!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
+			if (!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 				ptdlsinfo->sta_cnt++;
 			spin_unlock_bh(&(pstapriv->sta_hash_lock));
-			if( ptdlsinfo->sta_cnt == (NUM_STA - 2) )	// -2: AP + BC/MC sta
+			if ( ptdlsinfo->sta_cnt == (NUM_STA - 2) )	// -2: AP + BC/MC sta
 			{
 				ptdlsinfo->sta_maximum  = true;
 			}
@@ -595,7 +595,7 @@ void issue_tdls_setup_req(_adapter *pada
 		}
 	}
 
-	if(ptdls_sta){
+	if (ptdls_sta){
 		ptdls_sta->tdls_sta_state |= TDLS_RESPONDER_STATE;
 		//for tdls; ptdls_sta->aid is used to fill dialogtoken
 		ptdls_sta->dialog = dialogtoken;
@@ -605,7 +605,7 @@ void issue_tdls_setup_req(_adapter *pada
 	}
 
 	pattrib->qsel=pattrib->priority;
-	if(rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_SETUP_REQUEST) !=_SUCCESS ){
+	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_SETUP_REQUEST) !=_SUCCESS ){
 		rtw_free_xmitbuf(pxmitpriv,pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
 		goto exit;
@@ -627,7 +627,7 @@ void issue_tdls_teardown(_adapter *padap
 	struct sta_info	*ptdls_sta=NULL;
 
 	ptdls_sta = rtw_get_stainfo(pstapriv, mac_addr);
-	if(ptdls_sta==NULL){
+	if (ptdls_sta==NULL){
 		DBG_871X("issue tdls teardown unsuccessful\n");
 		return;
 	}else{
@@ -661,11 +661,11 @@ void issue_tdls_teardown(_adapter *padap
 	}
 	rtw_dump_xframe(padapter, pmgntframe);
 
-	if(ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE){
+	if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE){
 		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
 	}
 
-	if( ptdls_sta->timer_flag == 1 )
+	if ( ptdls_sta->timer_flag == 1 )
 	{
 		spin_lock_bh(&(padapter->tdlsinfo.hdl_lock));
 		ptdls_sta->timer_flag = 2;
@@ -700,7 +700,7 @@ void issue_tdls_dis_req(_adapter *padapt
 	pattrib->ether_type = 0x890d;
 	pattrib->pctrl =0;
 
-	if(mac_addr == NULL)
+	if (mac_addr == NULL)
 		memcpy(pattrib->dst, baddr, ETH_ALEN);
 	else
 		memcpy(pattrib->dst, mac_addr, ETH_ALEN);
@@ -943,7 +943,7 @@ void issue_tdls_ch_switch_req(_adapter *
 	update_tdls_attrib(padapter, pattrib);
 
 	pattrib->qsel=pattrib->priority;
-	if(rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_REQUEST) !=_SUCCESS ){
+	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_REQUEST) !=_SUCCESS ){
 		rtw_free_xmitbuf(pxmitpriv,pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
 		goto exit;
@@ -984,7 +984,7 @@ void issue_tdls_ch_switch_rsp(_adapter *
 	update_tdls_attrib(padapter, pattrib);
 
 	pattrib->qsel=pattrib->priority;
-	if(rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_RESPONSE) !=_SUCCESS ){
+	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_RESPONSE) !=_SUCCESS ){
 		rtw_free_xmitbuf(pxmitpriv,pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
 		goto exit;
@@ -1014,21 +1014,21 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, u
 	psa = get_sa(ptr);
 	ptdls_sta = rtw_get_stainfo(&(adapter->stapriv), psa);
 
-	if(ptdls_sta != NULL)
+	if (ptdls_sta != NULL)
 	{
 		ptdls_sta->tdls_sta_state |= TDLS_ALIVE_STATE;
 
 		//Record the tdls sta with lowest signal strength
-		if( (ptdlsinfo->sta_maximum == true) && (ptdls_sta->alive_count >= 1) )
+		if ( (ptdlsinfo->sta_maximum == true) && (ptdls_sta->alive_count >= 1) )
 		{
-			if( _rtw_memcmp(ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN) )
+			if ( _rtw_memcmp(ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN) )
 			{
 				memcpy(ptdlsinfo->ss_record.macaddr, psa, ETH_ALEN);
 				ptdlsinfo->ss_record.RxPWDBAll = pattrib->RxPWDBAll;
 			}
 			else
 			{
-				if( ptdlsinfo->ss_record.RxPWDBAll < pattrib->RxPWDBAll )
+				if ( ptdlsinfo->ss_record.RxPWDBAll < pattrib->RxPWDBAll )
 				{
 					memcpy(ptdlsinfo->ss_record.macaddr, psa, ETH_ALEN);
 					ptdlsinfo->ss_record.RxPWDBAll = pattrib->RxPWDBAll;
@@ -1039,16 +1039,16 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, u
 	}
 	else
 	{
-		if( ptdlsinfo->sta_maximum == true)
+		if ( ptdlsinfo->sta_maximum == true)
 		{
-			if( _rtw_memcmp( ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN ) )
+			if ( _rtw_memcmp( ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN ) )
 			{
 				//All traffics are busy, do not set up another direct link.
 				return _FAIL;
 			}
 			else
 			{
-				if( pattrib->RxPWDBAll > ptdlsinfo->ss_record.RxPWDBAll )
+				if ( pattrib->RxPWDBAll > ptdlsinfo->ss_record.RxPWDBAll )
 				{
 					issue_tdls_teardown(adapter, ptdlsinfo->ss_record.macaddr);
 				}
@@ -1061,7 +1061,7 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, u
 
 		rtw_hal_get_def_var(adapter, HAL_DEF_UNDERCORATEDSMOOTHEDPWDB, &UndecoratedSmoothedPWDB);
 
-		if( pattrib->RxPWDBAll + TDLS_SIGNAL_THRESH >= UndecoratedSmoothedPWDB);
+		if ( pattrib->RxPWDBAll + TDLS_SIGNAL_THRESH >= UndecoratedSmoothedPWDB);
 		{
 			DBG_871X("pattrib->RxPWDBAll=%d, pdmpriv->UndecoratedSmoothedPWDB=%d\n", pattrib->RxPWDBAll, UndecoratedSmoothedPWDB);
 			issue_tdls_setup_req(adapter, psa);
@@ -1108,34 +1108,34 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 			-PAYLOAD_TYPE_LEN
 			-FIXED_IE;
 
-	if(ptdlsinfo->ap_prohibited == true)
+	if (ptdlsinfo->ap_prohibited == true)
 	{
 		goto exit;
 	}
 
-	if(ptdls_sta==NULL){
+	if (ptdls_sta==NULL){
 		ptdls_sta = rtw_alloc_stainfo(pstapriv, psa);
 	}else{
-		if(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE){
+		if (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE){
 			//If the direct link is already set up
 			//Process as re-setup after tear down
 			DBG_871X("re-setup a direct link\n");
 		}
 		//already receiving TDLS setup request
-		else if(ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE){
+		else if (ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE){
 			DBG_871X("receive duplicated TDLS setup request frame in handshaking\n");
 			goto exit;
 		}
 		//When receiving and sending setup_req to the same link at the same time, STA with higher MAC_addr would be initiator
 		//following is to check out MAC_addr
-		else if(ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE){
+		else if (ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE){
 			DBG_871X("receive setup_req after sending setup_req\n");
 			for (i=0;i<6;i++){
-				if(*(pmyid+i)==*(psa+i)){
+				if (*(pmyid+i)==*(psa+i)){
 				}
-				else if(*(pmyid+i)>*(psa+i)){
+				else if (*(pmyid+i)>*(psa+i)){
 					goto exit;
-				}else if(*(pmyid+i)<*(psa+i)){
+				}else if (*(pmyid+i)<*(psa+i)){
 					ptdls_sta->tdls_sta_state=TDLS_INITIATOR_STATE;
 					break;
 				}
@@ -1143,7 +1143,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 		}
 	}
 
-	if(ptdls_sta)
+	if (ptdls_sta)
 	{
 		ptdls_sta->dialog = *(ptr+2);	//copy dialog token
 		ptdls_sta->stat_code = 0;
@@ -1162,7 +1162,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 				case _COUNTRY_IE_:
 					break;
 				case _EXT_SUPPORTEDRATES_IE_:
-					if(supportRateNum<=sizeof(supportRate))
+					if (supportRateNum<=sizeof(supportRate))
 					{
 						memcpy(supportRate+supportRateNum, pIE->data, pIE->Length);
 						supportRateNum += pIE->Length;
@@ -1172,16 +1172,16 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 					break;
 				case _RSN_IE_2_:
 					rsnie_have=1;
-					if(prx_pkt_attrib->encrypt){
+					if (prx_pkt_attrib->encrypt){
 						prsnie=(u8*)pIE;
 						//check whether initiator STA has CCMP pairwise_cipher.
 						ppairwise_cipher=prsnie+10;
 						memcpy(&pairwise_count, (u16*)(ppairwise_cipher-2), 1);
 						for(k=0;k<pairwise_count;k++){
-							if(_rtw_memcmp( ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==true)
+							if (_rtw_memcmp( ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==true)
 								ccmp_have=1;
 						}
-						if(ccmp_have==0){
+						if (ccmp_have==0){
 							//invalid contents of RSNIE
 							ptdls_sta->stat_code=72;
 						}
@@ -1192,11 +1192,11 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 				case _VENDOR_SPECIFIC_IE_:
 					break;
 				case _FTIE_:
-					if(prx_pkt_attrib->encrypt)
+					if (prx_pkt_attrib->encrypt)
 						memcpy(SNonce, (ptr+j+52), 32);
 					break;
 				case _TIMEOUT_ITVL_IE_:
-					if(prx_pkt_attrib->encrypt)
+					if (prx_pkt_attrib->encrypt)
 						timeout_interval = (u32 *)(ptr+j+3);
 					break;
 				case _RIC_Descriptor_IE_:
@@ -1207,7 +1207,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 				case EID_BSSCoexistence:
 					break;
 				case _LINK_ID_IE_:
-					if(_rtw_memcmp(get_bssid(pmlmepriv), pIE->data, 6) == false)
+					if (_rtw_memcmp(get_bssid(pmlmepriv), pIE->data, 6) == false)
 					{
 						//not in the same BSS
 						ptdls_sta->stat_code=7;
@@ -1227,12 +1227,12 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 
 		//check status code
 		//if responder STA has/hasn't security on AP, but request hasn't/has RSNIE, it should reject
-		if(ptdls_sta->stat_code == 0 )
+		if (ptdls_sta->stat_code == 0 )
 		{
-			if(rsnie_have && (prx_pkt_attrib->encrypt==0)){
+			if (rsnie_have && (prx_pkt_attrib->encrypt==0)){
 				//security disabled
 				ptdls_sta->stat_code = 5;
-			}else if(rsnie_have==0 && (prx_pkt_attrib->encrypt)){
+			}else if (rsnie_have==0 && (prx_pkt_attrib->encrypt)){
 				//request haven't RSNIE
 				ptdls_sta->stat_code = 38;
 			}
@@ -1242,7 +1242,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 			//SoUT does not use TDLS if AP uses weak security
 			if ( adapter->wdinfo.wfd_tdls_enable )
 			{
-				if(rsnie_have && (prx_pkt_attrib->encrypt != _AES_))
+				if (rsnie_have && (prx_pkt_attrib->encrypt != _AES_))
 				{
 					ptdls_sta->stat_code = 5;
 				}
@@ -1251,15 +1251,15 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 		}
 
 		ptdls_sta->tdls_sta_state|= TDLS_INITIATOR_STATE;
-		if(prx_pkt_attrib->encrypt){
+		if (prx_pkt_attrib->encrypt){
 			memcpy(ptdls_sta->SNonce, SNonce, 32);
 			memcpy(&(ptdls_sta->TDLS_PeerKey_Lifetime), timeout_interval, 4);
 		}
 		spin_lock_bh(&(pstapriv->sta_hash_lock));
-		if(!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
+		if (!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 			ptdlsinfo->sta_cnt++;
 		spin_unlock_bh(&(pstapriv->sta_hash_lock));
-		if( ptdlsinfo->sta_cnt == (NUM_STA - 2) )	// -2: AP + BC/MC sta
+		if ( ptdlsinfo->sta_cnt == (NUM_STA - 2) )	// -2: AP + BC/MC sta
 		{
 			ptdlsinfo->sta_maximum = true;
 		}
@@ -1276,7 +1276,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 
 	issue_tdls_setup_rsp(adapter, precv_frame);
 
-	if(ptdls_sta->stat_code==0)
+	if (ptdls_sta->stat_code==0)
 	{
 		_set_timer( &ptdls_sta->handshake_timer, TDLS_HANDSHAKE_TIME);
 	}
@@ -1328,7 +1328,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 
 	memcpy(&stat_code, ptr+2, 2);
 
-	if(stat_code!=0)
+	if (stat_code!=0)
 	{
 		DBG_871X( "[%s] status_code = %d, free_tdls_sta\n", __func__, stat_code );
 		free_tdls_sta(adapter, ptdls_sta);
@@ -1351,7 +1351,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 			case _COUNTRY_IE_:
 				break;
 			case _EXT_SUPPORTEDRATES_IE_:
-				if(supportRateNum<=sizeof(supportRate))
+				if (supportRateNum<=sizeof(supportRate))
 				{
 					memcpy(supportRate+supportRateNum, pIE->data, pIE->Length);
 					supportRateNum += pIE->Length;
@@ -1365,7 +1365,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 				ppairwise_cipher=prsnie+10;
 				memcpy(&pairwise_count, (u16*)(ppairwise_cipher-2), 2);
 				for(k=0;k<pairwise_count;k++){
-					if(_rtw_memcmp( ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==true)
+					if (_rtw_memcmp( ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==true)
 						verify_ccmp=1;
 				}
 			case _EXT_CAP_IE_:
@@ -1405,19 +1405,19 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 	rtw_tdls_process_wfd_ie(ptdlsinfo, ptr + FIXED_IE, parsing_length - FIXED_IE);
 #endif // CONFIG_WFD
 
-	if(stat_code != 0)
+	if (stat_code != 0)
 	{
 		ptdls_sta->stat_code = stat_code;
 	}
 	else
 	{
-		if(prx_pkt_attrib->encrypt)
+		if (prx_pkt_attrib->encrypt)
 		{
-			if(verify_ccmp==1)
+			if (verify_ccmp==1)
 			{
 				wpa_tdls_generate_tpk(adapter, ptdls_sta);
 				ptdls_sta->stat_code=0;
-				if(tdls_verify_mic(ptdls_sta->tpk.kck, 2, plinkid_ie, prsnie, ptimeout_ie, pftie)==0)	//0: Invalid, 1: valid
+				if (tdls_verify_mic(ptdls_sta->tpk.kck, 2, plinkid_ie, prsnie, ptimeout_ie, pftie)==0)	//0: Invalid, 1: valid
 				{
 					free_tdls_sta(adapter, ptdls_sta);
 					return _FAIL;
@@ -1436,11 +1436,11 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 	DBG_871X("issue_tdls_setup_cfm\n");
 	issue_tdls_setup_cfm(adapter, precv_frame);
 
-	if(ptdls_sta->stat_code==0)
+	if (ptdls_sta->stat_code==0)
 	{
 		ptdlsinfo->setup_state = TDLS_LINKED_STATE;
 
-		if( ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE )
+		if ( ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE )
 		{
 			ptdls_sta->tdls_sta_state |= TDLS_LINKED_STATE;
 			_cancel_timer_ex( &ptdls_sta->handshake_timer);
@@ -1493,13 +1493,13 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 			-FIXED_IE;
 	memcpy(&stat_code, ptr+2, 2);
 
-	if(stat_code!=0){
+	if (stat_code!=0){
 		DBG_871X( "[%s] stat_code = %d\n, free_tdls_sta", __func__, stat_code );
 		free_tdls_sta(adapter, ptdls_sta);
 		return _FAIL;
 	}
 
-	if(prx_pkt_attrib->encrypt){
+	if (prx_pkt_attrib->encrypt){
 		//parsing information element
 		for(j=FIXED_IE; j<parsing_length;){
 
@@ -1532,7 +1532,7 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 		}
 
 		//verify mic in FTIE MIC field
-		if(tdls_verify_mic(ptdls_sta->tpk.kck, 3, plinkid_ie, prsnie, ptimeout_ie, pftie)==0){	//0: Invalid, 1: Valid
+		if (tdls_verify_mic(ptdls_sta->tpk.kck, 3, plinkid_ie, prsnie, ptimeout_ie, pftie)==0){	//0: Invalid, 1: Valid
 			free_tdls_sta(adapter, ptdls_sta);
 			return _FAIL;
 		}
@@ -1540,7 +1540,7 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 	}
 
 	ptdlsinfo->setup_state = TDLS_LINKED_STATE;
-	if( ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE )
+	if ( ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE )
 	{
 		ptdls_sta->tdls_sta_state|=TDLS_LINKED_STATE;
 		_cancel_timer_ex( &ptdls_sta->handshake_timer);
@@ -1590,12 +1590,12 @@ int On_TDLS_Dis_Req(_adapter *adapter, u
 		{
 			case _LINK_ID_IE_:
 				psta_ap = rtw_get_stainfo(pstapriv, pIE->data);
-				if(psta_ap == NULL)
+				if (psta_ap == NULL)
 				{
 					goto exit;
 				}
 				dst = pIE->data + 12;
-				if( (MacAddr_isBcst(dst) == false) && (_rtw_memcmp(myid(&(adapter->eeprompriv)), dst, 6) == false) )
+				if ( (MacAddr_isBcst(dst) == false) && (_rtw_memcmp(myid(&(adapter->eeprompriv)), dst, 6) == false) )
 				{
 					goto exit;
 				}
@@ -1631,8 +1631,8 @@ int On_TDLS_Teardown(_adapter *adapter,
 	psa = get_sa(ptr);
 
 	ptdls_sta = rtw_get_stainfo(pstapriv, psa);
-	if(ptdls_sta!=NULL){
-		if(ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE){
+	if (ptdls_sta!=NULL){
+		if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE){
 			rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
 		}
 		free_tdls_sta(adapter, ptdls_sta);
@@ -1643,11 +1643,11 @@ int On_TDLS_Teardown(_adapter *adapter,
 }
 
 u8 TDLS_check_ch_state(uint state){
-	if(	(state & TDLS_CH_SWITCH_ON_STATE) &&
+	if (	(state & TDLS_CH_SWITCH_ON_STATE) &&
 		(state & TDLS_AT_OFF_CH_STATE) &&
 		(state & TDLS_PEER_AT_OFF_STATE) ){
 
-		if(state & TDLS_PEER_SLEEP_STATE)
+		if (state & TDLS_PEER_SLEEP_STATE)
 			return 2;	//U-APSD + ch. switch
 		else
 			return 1;	//ch. switch
@@ -1675,19 +1675,19 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 
 	// if noticed peer STA wakes up by receiving peer traffic response
 	// and we want to do channel swtiching, then we will transmit channel switch request first
-	if(ptdls_sta->tdls_sta_state & TDLS_APSD_CHSW_STATE){
+	if (ptdls_sta->tdls_sta_state & TDLS_APSD_CHSW_STATE){
 		issue_tdls_ch_switch_req(adapter, pattrib->src);
 		ptdls_sta->tdls_sta_state &= ~(TDLS_APSD_CHSW_STATE);
 		return  _FAIL;
 	}
 
 	//check 4-AC queue bit
-	if(ptdls_sta->uapsd_vo || ptdls_sta->uapsd_vi || ptdls_sta->uapsd_be || ptdls_sta->uapsd_bk)
+	if (ptdls_sta->uapsd_vo || ptdls_sta->uapsd_vi || ptdls_sta->uapsd_be || ptdls_sta->uapsd_bk)
 		wmmps_ac=1;
 
 	//if it's a direct link and have buffered frame
-	if(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE){
-		if(wmmps_ac && state)
+	if (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE){
+		if (wmmps_ac && state)
 		{
 			_list	*xmitframe_plist, *xmitframe_phead;
 			struct xmit_frame *pxmitframe=NULL;
@@ -1705,7 +1705,7 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 				rtw_list_delete(&pxmitframe->list);
 
 				ptdls_sta->sleepq_len--;
-				if(ptdls_sta->sleepq_len>0){
+				if (ptdls_sta->sleepq_len>0){
 					pxmitframe->attrib.mdata = 1;
 					pxmitframe->attrib.eosp = 0;
 				}else{
@@ -1713,21 +1713,21 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 					pxmitframe->attrib.eosp = 1;
 				}
 				//pxmitframe->attrib.triggered = 1;	//maybe doesn't need in TDLS
-				if(rtw_hal_xmit(adapter, pxmitframe) == true)
+				if (rtw_hal_xmit(adapter, pxmitframe) == true)
 				{
 					rtw_os_xmit_complete(adapter, pxmitframe);
 				}
 
 			}
 
-			if(ptdls_sta->sleepq_len==0)
+			if (ptdls_sta->sleepq_len==0)
 			{
 				DBG_871X("no buffered packets for tdls to xmit\n");
 				//on U-APSD + CH. switch state, when there is no buffered date to xmit,
 				// we should go back to base channel
-				if(state==2){
+				if (state==2){
 					rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
-				}else if(ptdls_sta->tdls_sta_state&TDLS_SW_OFF_STATE){
+				}else if (ptdls_sta->tdls_sta_state&TDLS_SW_OFF_STATE){
 						ptdls_sta->tdls_sta_state &= ~(TDLS_SW_OFF_STATE);
 						ptdlsinfo->candidate_ch= pmlmeext->cur_channel;
 						issue_tdls_ch_switch_req(adapter, pattrib->src);
@@ -1812,7 +1812,7 @@ int On_TDLS_Ch_Switch_Req(_adapter *adap
 
 	DBG_871X("issue tdls channel switch response\n");
 
-	if((ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE) && ptdls_sta->off_ch==pmlmeext->cur_channel){
+	if ((ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE) && ptdls_sta->off_ch==pmlmeext->cur_channel){
 		DBG_871X("back to base channel %x\n", pmlmeext->cur_channel);
 		ptdls_sta->option=7;
 		rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_BASE_CH);
@@ -1841,8 +1841,8 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 
 	//if channel switch is running and receiving Unsolicited TDLS Channel Switch Response,
 	//it will go back to base channel and terminate this channel switch procedure
-	if(ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE ){
-		if(pmlmeext->cur_channel==ptdls_sta->off_ch){
+	if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE ){
+		if (pmlmeext->cur_channel==ptdls_sta->off_ch){
 			DBG_871X("back to base channel %x\n", pmlmeext->cur_channel);
 			ptdls_sta->option=7;
 			rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_OFF_CH);
@@ -1854,7 +1854,7 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 	}
 
 	//avoiding duplicated or unconditional ch. switch. rsp
-	if((ptdls_sta->tdls_sta_state & TDLS_CH_SW_INITIATOR_STATE) != TDLS_CH_SW_INITIATOR_STATE)
+	if ((ptdls_sta->tdls_sta_state & TDLS_CH_SW_INITIATOR_STATE) != TDLS_CH_SW_INITIATOR_STATE)
 		return _FAIL;
 
 	ptr +=prx_pkt_attrib->hdrlen + prx_pkt_attrib->iv_len+LLC_HEADER_SIZE+TYPE_LENGTH_FIELD_SIZE+1;
@@ -1869,7 +1869,7 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 
 	memcpy(&stat_code, ptr+2, 2);
 
-	if(stat_code!=0){
+	if (stat_code!=0){
 		return _FAIL;
 	}
 
@@ -1884,11 +1884,11 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 				break;
 			case _CH_SWITCH_TIMING_:
 				memcpy(&switch_time, pIE->data, 2);
-				if(switch_time > ptdls_sta->ch_switch_time)
+				if (switch_time > ptdls_sta->ch_switch_time)
 					memcpy(&ptdls_sta->ch_switch_time, &switch_time, 2);
 
 				memcpy(&switch_timeout, pIE->data+2, 2);
-				if(switch_timeout > ptdls_sta->ch_switch_timeout)
+				if (switch_timeout > ptdls_sta->ch_switch_timeout)
 					memcpy(&ptdls_sta->ch_switch_timeout, &switch_timeout, 2);
 
 			default:
@@ -2023,7 +2023,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	u32 time;
 
 	//SNonce
-	if(pattrib->encrypt){
+	if (pattrib->encrypt){
 		for(i=0;i<8;i++){
 			time=rtw_get_current_time();
 			memcpy(&ptdls_sta->SNonce[4*i], (u8 *)&time, 4);
@@ -2040,7 +2040,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	//capability
 	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
 
-	if(pattrib->encrypt)
+	if (pattrib->encrypt)
 		*pframe =*pframe | BIT(4);
 	pframe += 2;
 	pattrib->pktlen += 2;
@@ -2061,7 +2061,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 
 	//country(optional)
 	//extended supported rates
-	if(more_supportedrates==1){
+	if (more_supportedrates==1){
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
 	}
 
@@ -2072,7 +2072,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	pframe = rtw_set_ie( pframe, _SRC_IE_, 16, TDLS_SRC, &(pattrib->pktlen));
 
 	//RSNIE
-	if(pattrib->encrypt)
+	if (pattrib->encrypt)
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
 
 	//extended capabilities
@@ -2082,7 +2082,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 7, TDLS_WMMIE,  &(pattrib->pktlen));
 
 
-	if(pattrib->encrypt){
+	if (pattrib->encrypt){
 		//FTIE
 		memset(pframe, 0, 84);	//All fields except SNonce shall be set to 0
 		memset(pframe, _FTIE_, 1);	//version
@@ -2102,7 +2102,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	pframe = rtw_tdls_set_ht_cap(padapter, pframe, pattrib);
 
 	//20/40 BSS coexistence
-	if(pmlmepriv->num_FortyMHzIntolerant>0)
+	if (pmlmepriv->num_FortyMHzIntolerant>0)
 		iedata |= BIT(2);//20 MHz BSS Width Request
 	pframe = rtw_set_ie(pframe, EID_BSSCoexistence,  1, &iedata, &(pattrib->pktlen));
 
@@ -2145,13 +2145,13 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 
 	ptdls_sta = rtw_get_stainfo( &(padapter->stapriv) , pattrib->dst);
 
-	if(ptdls_sta == NULL )
+	if (ptdls_sta == NULL )
 	{
 		DBG_871X("[%s] %d\n", __func__, __LINE__);
 		return;
 	}
 
-	if(pattrib->encrypt){
+	if (pattrib->encrypt){
 		for(k=0;k<8;k++){
 			time=rtw_get_current_time();
 			memcpy(&ptdls_sta->ANonce[4*k], (u8*)&time, 4);
@@ -2165,7 +2165,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 2, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
 
-	if(ptdls_sta->stat_code!=0)	//invalid setup request
+	if (ptdls_sta->stat_code!=0)	//invalid setup request
 	{
 		DBG_871X("ptdls_sta->stat_code:%04x \n", ptdls_sta->stat_code);
 		return;
@@ -2177,7 +2177,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	//capability
 	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
 
-	if(pattrib->encrypt )
+	if (pattrib->encrypt )
 		*pframe =*pframe | BIT(4);
 	pframe += 2;
 	pattrib->pktlen += 2;
@@ -2198,7 +2198,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 
 	//country(optional)
 	//extended supported rates
-	if(more_supportedrates==1){
+	if (more_supportedrates==1){
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
 	}
 
@@ -2209,7 +2209,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	pframe = rtw_set_ie(pframe, _SRC_IE_ , 16, TDLS_SRC, &(pattrib->pktlen));
 
 	//RSNIE
-	if(pattrib->encrypt){
+	if (pattrib->encrypt){
 		prsnie = pframe;
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
 	}
@@ -2220,7 +2220,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	//QoS capability(WMM_IE)
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 7, TDLS_WMMIE,  &(pattrib->pktlen));
 
-	if(pattrib->encrypt){
+	if (pattrib->encrypt){
 		wpa_tdls_generate_tpk(padapter, ptdls_sta);
 
 		//FTIE
@@ -2246,7 +2246,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	pframe = rtw_tdls_set_ht_cap(padapter, pframe, pattrib);
 
 	//20/40 BSS coexistence
-	if(pmlmepriv->num_FortyMHzIntolerant>0)
+	if (pmlmepriv->num_FortyMHzIntolerant>0)
 		iedata |= BIT(2);//20 MHz BSS Width Request
 	pframe = rtw_set_ie(pframe, EID_BSSCoexistence,  1, &iedata, &(pattrib->pktlen));
 
@@ -2258,7 +2258,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
 
 	//fill FTIE mic
-	if(pattrib->encrypt)
+	if (pattrib->encrypt)
 		wpa_tdls_ftie_mic(ptdls_sta->tpk.kck, 2, plinkid_ie, prsnie, ptimeout_ie, pftie, pftie_mic);
 
 #ifdef CONFIG_WFD
@@ -2294,17 +2294,17 @@ void rtw_build_tdls_setup_cfm_ies(_adapt
 	pframe = rtw_set_fixed_ie(pframe, 2, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(ptdls_sta->dialog), &(pattrib->pktlen));
 
-	if(ptdls_sta->stat_code!=0)	//invalid setup request
+	if (ptdls_sta->stat_code!=0)	//invalid setup request
 		return;
 
 	//RSNIE
-	if(pattrib->encrypt){
+	if (pattrib->encrypt){
 		prsnie = pframe;
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
 	}
 
 	//EDCA param set; WMM param ele.
-	if(pattrib->encrypt){
+	if (pattrib->encrypt){
 		//FTIE
 		pftie = pframe;
 		pftie_mic = pframe+4;
@@ -2334,7 +2334,7 @@ void rtw_build_tdls_setup_cfm_ies(_adapt
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
 
 	//fill FTIE mic
-	if(pattrib->encrypt)
+	if (pattrib->encrypt)
 		wpa_tdls_ftie_mic(ptdls_sta->tpk.kck, 3, plinkid_ie, prsnie, ptimeout_ie, pftie, pftie_mic);
 
 }
@@ -2359,11 +2359,11 @@ void rtw_build_tdls_teardown_ies(_adapte
 	pframe = rtw_set_fixed_ie(pframe, 1, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
 
 	//Link identifier
-	if(ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE){
+	if (ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE){
 		memcpy(link_id_addr, pattrib->ra, 6);
 		memcpy((link_id_addr+6), pattrib->src, 6);
 		memcpy((link_id_addr+12), pattrib->dst, 6);
-	}else  if(ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE){
+	}else  if (ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE){
 		memcpy(link_id_addr, pattrib->ra, 6);
 		memcpy((link_id_addr+6), pattrib->dst, 6);
 		memcpy((link_id_addr+12), pattrib->src, 6);
@@ -2425,7 +2425,7 @@ void rtw_build_tdls_dis_rsp_ies(_adapter
 	//capability
 	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
 
-	if(pattrib->encrypt)
+	if (pattrib->encrypt)
 		*pframe =*pframe | BIT(4);
 	pframe += 2;
 	pattrib->pktlen += 2;
@@ -2445,7 +2445,7 @@ void rtw_build_tdls_dis_rsp_ies(_adapter
 	}
 
 	//extended supported rates
-	if(more_supportedrates==1){
+	if (more_supportedrates==1){
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
 	}
 
@@ -2453,13 +2453,13 @@ void rtw_build_tdls_dis_rsp_ies(_adapter
 	pframe = rtw_tdls_set_sup_ch(pmlmeext, pframe, pattrib);
 
 	//RSNIE
-	if(pattrib->encrypt)
+	if (pattrib->encrypt)
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
 
 	//extended capability
 	pframe = rtw_set_ie(pframe, _EXT_CAP_IE_ , 5, TDLS_EXT_CAPIE, &(pattrib->pktlen));
 
-	if(pattrib->encrypt){
+	if (pattrib->encrypt){
 		//FTIE
 		memset(pframe, 0, 84);	//All fields shall be set to 0
 		memset(pframe, _FTIE_, 1);	//version
@@ -2478,7 +2478,7 @@ void rtw_build_tdls_dis_rsp_ies(_adapter
 	pframe = rtw_tdls_set_ht_cap(padapter, pframe, pattrib);
 
 	//20/40 BSS coexistence
-	if(pmlmepriv->num_FortyMHzIntolerant>0)
+	if (pmlmepriv->num_FortyMHzIntolerant>0)
 		iedata |= BIT(2);//20 MHz BSS Width Request
 	pframe = rtw_set_ie(pframe, EID_BSSCoexistence, 1, &iedata, &(pattrib->pktlen));
 
@@ -2518,13 +2518,13 @@ void rtw_build_tdls_peer_traffic_indicat
 
 	//PTI control
 	//PU buffer status
-	if(ptdls_sta->uapsd_bk&BIT(1))
+	if (ptdls_sta->uapsd_bk&BIT(1))
 		AC_queue=BIT(0);
-	if(ptdls_sta->uapsd_be&BIT(1))
+	if (ptdls_sta->uapsd_be&BIT(1))
 		AC_queue=BIT(1);
-	if(ptdls_sta->uapsd_vi&BIT(1))
+	if (ptdls_sta->uapsd_vi&BIT(1))
 		AC_queue=BIT(2);
-	if(ptdls_sta->uapsd_vo&BIT(1))
+	if (ptdls_sta->uapsd_vo&BIT(1))
 		AC_queue=BIT(3);
 	pframe = rtw_set_ie(pframe, _PTI_BUFFER_STATUS_, 1, &AC_queue, &(pattrib->pktlen));
 
@@ -2623,13 +2623,13 @@ void rtw_build_tunneled_probe_req_ies(_a
 	pframe = rtw_set_fixed_ie(pframe, 3, WFA_OUI, &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(probe_req), &(pattrib->pktlen));
 
-	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		wfdielen = build_probe_req_wfd_ie(pwdinfo, pframe);
 		pframe += wfdielen;
 		pattrib->pktlen += wfdielen;
 	}
-	else if(!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
+	else if (!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
 	{
 		wfdielen = build_probe_req_wfd_ie(pbuddy_wdinfo, pframe);
 		pframe += wfdielen;
@@ -2657,13 +2657,13 @@ void rtw_build_tunneled_probe_rsp_ies(_a
 	pframe = rtw_set_fixed_ie(pframe, 3, WFA_OUI, &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(probe_rsp), &(pattrib->pktlen));
 
-	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		wfdielen = build_probe_resp_wfd_ie(pwdinfo, pframe, 1);
 		pframe += wfdielen;
 		pattrib->pktlen += wfdielen;
 	}
-	else if(!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
+	else if (!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
 	{
 		wfdielen = build_probe_resp_wfd_ie(pbuddy_wdinfo, pframe, 1);
 		pframe += wfdielen;
@@ -2680,7 +2680,7 @@ void _TPK_timer_hdl(void *FunctionContex
 	ptdls_sta->TPK_count++;
 	//TPK_timer set 1000 as default
 	//retry timer should set at least 301 sec.
-	if(ptdls_sta->TPK_count==TPK_RESEND_COUNT){
+	if (ptdls_sta->TPK_count==TPK_RESEND_COUNT){
 		ptdls_sta->TPK_count=0;
 		issue_tdls_setup_req(ptdls_sta->padapter, ptdls_sta->hwaddr);
 	}
@@ -2704,12 +2704,12 @@ void _ch_switch_timer_hdl(void *Function
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
 	_adapter *padapter = ptdls_sta->padapter;
 
-	if( ptdls_sta->option == TDLS_DONE_CH_SEN ){
+	if ( ptdls_sta->option == TDLS_DONE_CH_SEN ){
 		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_DONE_CH_SEN);
-	}else if( ptdls_sta->option == TDLS_OFF_CH ){
+	}else if ( ptdls_sta->option == TDLS_OFF_CH ){
 		issue_nulldata_to_TDLS_peer_STA(ptdls_sta->padapter, ptdls_sta, 0);
 		_set_timer(&ptdls_sta->base_ch_timer, 500);
-	}else if( ptdls_sta->option == TDLS_BASE_CH){
+	}else if ( ptdls_sta->option == TDLS_BASE_CH){
 		issue_nulldata_to_TDLS_peer_STA(ptdls_sta->padapter, ptdls_sta, 0);
 	}
 }
@@ -2748,9 +2748,9 @@ void _tdls_handshake_timer_hdl(void *Fun
 {
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
 
-	if(ptdls_sta != NULL)
+	if (ptdls_sta != NULL)
 	{
-		if( !(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) )
+		if ( !(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) )
 		{
 			DBG_871X("tdls handshake time out\n");
 			free_tdls_sta(ptdls_sta->padapter, ptdls_sta);
@@ -2803,7 +2803,7 @@ void _tdls_alive_timer_phase2_hdl(void *
 	ptdls_sta->timer_flag = 1;
 	spin_unlock_bh(&ptdlsinfo->hdl_lock);
 
-	if( (ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE) &&
+	if ( (ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE) &&
 		(sta_last_rx_pkts(ptdls_sta) + 3 <= sta_rx_pkts(ptdls_sta)) )
 	{
 		DBG_871X("TDLS STA ALIVE, ptdls_sta->sta_stats.last_rx_pkts:%llu, ptdls_sta->sta_stats.rx_pkts:%llu\n",
@@ -2814,14 +2814,14 @@ void _tdls_alive_timer_phase2_hdl(void *
 	}
 	else
 	{
-		if( !(ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE) )
+		if ( !(ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE) )
 			DBG_871X("TDLS STA TOO FAR\n");
-		if( !(sta_last_rx_pkts(ptdls_sta) + 3 <= sta_rx_pkts(ptdls_sta)))
+		if ( !(sta_last_rx_pkts(ptdls_sta) + 3 <= sta_rx_pkts(ptdls_sta)))
 			DBG_871X("TDLS LINK WITH LOW TRAFFIC, ptdls_sta->sta_stats.last_rx_pkts:%llu, ptdls_sta->sta_stats.rx_pkts:%llu\n",
 				sta_last_rx_pkts(ptdls_sta), sta_rx_pkts(ptdls_sta));
 
 		ptdls_sta->alive_count++;
-		if( ptdls_sta->alive_count == TDLS_ALIVE_COUNT )
+		if ( ptdls_sta->alive_count == TDLS_ALIVE_COUNT )
 		{
 			ptdls_sta->stat_code = _RSON_TDLS_TEAR_TOOFAR_;
 			issue_tdls_teardown(padapter, ptdls_sta->hwaddr);
@@ -2855,7 +2855,7 @@ int update_sgi_tdls(_adapter *padapter,
 	struct ht_priv	*psta_ht = NULL;
 	psta_ht = &psta->htpriv;
 
-	if(psta_ht->ht_option)
+	if (psta_ht->ht_option)
 		return psta_ht->sgi;
 	else
 		return false;
@@ -2881,10 +2881,10 @@ u32 update_mask_tdls(_adapter *padapter,
 	}
 
 	//n mode ra_bitmap
-	if(psta_ht->ht_option)
+	if (psta_ht->ht_option)
 	{
 		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-		if(rf_type == RF_2T2R)
+		if (rf_type == RF_2T2R)
 			limit=16;// 2R
 		else
 			limit=8;//  1R
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -146,7 +146,7 @@ int judge_network_type(struct rtw_adapte
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 
-	if(pmlmeext->cur_channel > 14)
+	if (pmlmeext->cur_channel > 14)
 	{
 		if (pmlmeinfo->HT_enable)
 		{
@@ -166,7 +166,7 @@ int judge_network_type(struct rtw_adapte
 		{
 			network_type |= WIRELESS_11B;
 		}
-		else if((cckrates_included(rate, ratelen)) == true)
+		else if ((cckrates_included(rate, ratelen)) == true)
 		{
 			network_type |= WIRELESS_11BG;
 		}
@@ -364,7 +364,7 @@ void Save_DM_Func_Flag(struct rtw_adapte
 
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
-	if(pbuddy_adapter)
+	if (pbuddy_adapter)
 	rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));
 #endif
 
@@ -377,7 +377,7 @@ void Restore_DM_Func_Flag(struct rtw_ada
 	u8	bSaveFlag = false;
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
-	if(pbuddy_adapter)
+	if (pbuddy_adapter)
 	rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));
 #endif
 	rtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));
@@ -389,10 +389,10 @@ void Switch_DM_Func(struct rtw_adapter *
 	struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 #endif
 
-	if(enable == true)
+	if (enable == true)
 	{
 #ifdef CONFIG_CONCURRENT_MODE
-		if(pbuddy_adapter)
+		if (pbuddy_adapter)
 		rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_DM_FUNC_SET, (u8 *)(&mode));
 #endif
 		rtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_SET, (u8 *)(&mode));
@@ -400,7 +400,7 @@ void Switch_DM_Func(struct rtw_adapter *
 	else
 	{
 #ifdef CONFIG_CONCURRENT_MODE
-		if(pbuddy_adapter)
+		if (pbuddy_adapter)
 		rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_DM_FUNC_CLR, (u8 *)(&mode));
 #endif
 		rtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_CLR, (u8 *)(&mode));
@@ -420,7 +420,7 @@ static void Set_NETYPE0_MSR(struct rtw_a
 void Set_MSR(struct rtw_adapter *padapter, u8 type)
 {
 #ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->iface_type == IFACE_PORT1)
+	if (padapter->iface_type == IFACE_PORT1)
 	{
 		Set_NETYPE1_MSR(padapter, type);
 	}
@@ -517,7 +517,7 @@ void set_channel_bwmode(struct rtw_adapt
 		DBG_8192D( "[%s] ch = %d, offset = %d, bwmode = %d\n", __func__, channel, channel_offset, bwmode );
 	}
 
-	if((bwmode == HT_CHANNEL_WIDTH_20)||(channel_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE))
+	if ((bwmode == HT_CHANNEL_WIDTH_20)||(channel_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE))
 	{
 		//SelectChannel(padapter, channel);
 		center_ch = channel;
@@ -602,7 +602,7 @@ int is_client_associated_to_ap(struct rt
 	struct mlme_ext_priv	*pmlmeext;
 	struct mlme_ext_info	*pmlmeinfo;
 
-	if(!padapter)
+	if (!padapter)
 		return _FAIL;
 
 	pmlmeext = &padapter->mlmeextpriv;
@@ -760,25 +760,25 @@ void flush_all_cam_entry(struct rtw_adap
 
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-	//if(check_buddy_mlmeinfo_state(padapter, _HW_STATE_NOLINK_))
-	if(check_buddy_fwstate(padapter, _FW_LINKED) == false)
+	//if (check_buddy_mlmeinfo_state(padapter, _HW_STATE_NOLINK_))
+	if (check_buddy_fwstate(padapter, _FW_LINKED) == false)
 	{
 		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);
 	}
 	else
 	{
-		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
 		{
 			struct sta_priv	*pstapriv = &padapter->stapriv;
 			struct sta_info	*psta;
 			u8 cam_id;//cam_entry
 
 			psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
-			if(psta) {
-				if(psta->state & WIFI_AP_STATE)
+			if (psta) {
+				if (psta->state & WIFI_AP_STATE)
 				{}   //clear cam when ap free per sta_info
 				else {
-					if(psta->mac_id==2)
+					if (psta->mac_id==2)
 						cam_id = 5;
 					else
 						cam_id = 4;
@@ -787,7 +787,7 @@ void flush_all_cam_entry(struct rtw_adap
 				rtw_clearstakey_cmd(padapter, (u8*)psta, cam_id, false);
 			}
 		}
-		else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+		else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		{
 			//clear cam when ap free per sta_info
 		}
@@ -845,7 +845,7 @@ int WMM_param_handler(struct rtw_adapter
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	if(pmlmepriv->qospriv.qos_option==0)
+	if (pmlmepriv->qospriv.qos_option==0)
 	{
 		pmlmeinfo->WMM_enable = 0;
 		return _FAIL;
@@ -894,7 +894,7 @@ void WMMOnAssocRsp(struct rtw_adapter *p
 
 	acm_mask = 0;
 
-	if( pmlmeext->cur_wireless_mode == WIRELESS_11B)
+	if ( pmlmeext->cur_wireless_mode == WIRELESS_11B)
 		aSifsTime = 10;
 	else
 		aSifsTime = 16;
@@ -939,7 +939,7 @@ void WMMOnAssocRsp(struct rtw_adapter *p
 		DBG_8192D("WMM(%x): %x, %x\n", ACI, ACM, acParm);
 	}
 
-	if(padapter->registrypriv.acm_method == 1)
+	if (padapter->registrypriv.acm_method == 1)
 		rtw_hal_set_hwreg(padapter, HW_VAR_ACM_CTRL, (u8 *)(&acm_mask));
 	else
 		padapter->mlmepriv.acm_mask = acm_mask;
@@ -959,12 +959,12 @@ static void bwmode_update_check(struct r
 	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
 	u8 cbw40_enable=0;
 
-	if(!pIE)
+	if (!pIE)
 		return;
 
-	if(phtpriv->ht_option == false)	return;
+	if (phtpriv->ht_option == false)	return;
 
-	if(pIE->Length > sizeof(struct HT_info_element))
+	if (pIE->Length > sizeof(struct HT_info_element))
 		return;
 
 	pHT_info = (struct HT_info_element *)pIE->data;
@@ -977,7 +977,7 @@ static void bwmode_update_check(struct r
 			cbw40_enable = 1;
 	}
 
-	if((pHT_info->infos[0] & BIT(2)) && cbw40_enable )
+	if ((pHT_info->infos[0] & BIT(2)) && cbw40_enable )
 	{
 		new_bwmode = HT_CHANNEL_WIDTH_40;
 
@@ -1003,7 +1003,7 @@ static void bwmode_update_check(struct r
 	}
 
 
-	if((new_bwmode!= pmlmeext->cur_bwmode) || (new_ch_offset!=pmlmeext->cur_ch_offset))
+	if ((new_bwmode!= pmlmeext->cur_bwmode) || (new_ch_offset!=pmlmeext->cur_ch_offset))
 	{
 		pmlmeinfo->bwmode_updated = true;
 
@@ -1019,7 +1019,7 @@ static void bwmode_update_check(struct r
 	}
 
 
-	if(true == pmlmeinfo->bwmode_updated)
+	if (true == pmlmeinfo->bwmode_updated)
 	{
 		struct sta_info *psta;
 		struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
@@ -1030,11 +1030,11 @@ static void bwmode_update_check(struct r
 
 		//update ap's stainfo
 		psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
-		if(psta)
+		if (psta)
 		{
 			struct ht_priv	*phtpriv_sta = &psta->htpriv;
 
-			if(phtpriv_sta->ht_option)
+			if (phtpriv_sta->ht_option)
 			{
 				// bwmode
 				phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
@@ -1065,9 +1065,9 @@ void HT_caps_handler(struct rtw_adapter
 	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
 	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
 
-	if(pIE==NULL) return;
+	if (pIE==NULL) return;
 
-	if(phtpriv->ht_option == false)	return;
+	if (phtpriv->ht_option == false)	return;
 
 	pmlmeinfo->HT_caps_enable = 1;
 
@@ -1115,14 +1115,14 @@ void HT_caps_handler(struct rtw_adapter
 	//update the MCS rates
 	for (i = 0; i < 16; i++)
 	{
-		if((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
+		if ((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
 		{
 			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
 		}
 		else
 		{
 			#ifdef CONFIG_DISABLE_MCS13TO15
-			if(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40 && (pregistrypriv->wifi_spec!=1))
+			if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40 && (pregistrypriv->wifi_spec!=1))
 				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R_MCS13TO15_OFF[i];
 			else
 			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
@@ -1136,7 +1136,7 @@ void HT_caps_handler(struct rtw_adapter
 		}
 		#endif
 
-		if(pregistrypriv->special_rf_path)
+		if (pregistrypriv->special_rf_path)
 			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
 
 	}
@@ -1151,12 +1151,12 @@ void HT_info_handler(struct rtw_adapter
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
 
-	if(pIE==NULL) return;
+	if (pIE==NULL) return;
 
-	if(phtpriv->ht_option == false)	return;
+	if (phtpriv->ht_option == false)	return;
 
 
-	if(pIE->Length > sizeof(struct HT_info_element))
+	if (pIE->Length > sizeof(struct HT_info_element))
 		return;
 
 	pmlmeinfo->HT_info_enable = 1;
@@ -1206,7 +1206,7 @@ void ERP_IE_handler(struct rtw_adapter *
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	if(pIE->Length>1)
+	if (pIE->Length>1)
 		return;
 
 	pmlmeinfo->ERP_enable = 1;
@@ -1268,13 +1268,13 @@ int check_ap_tdls_prohibited(u8 *pframe,
 {
 	u8 tdls_prohibited_bit = 0x40; //bit(38); TDLS_prohibited
 
-	if(pkt_len < 5)
+	if (pkt_len < 5)
 	{
 		return false;
 	}
 
 	pframe += 4;
-	if( (*pframe) & tdls_prohibited_bit )
+	if ( (*pframe) & tdls_prohibited_bit )
 		return true;
 
 	return false;
@@ -1307,7 +1307,7 @@ void update_beacon_info(struct rtw_adapt
 			break;
 #ifdef CONFIG_TDLS
 		case _EXT_CAP_IE_:
-			if( check_ap_tdls_prohibited(pIE->data, pIE->Length) == true )
+			if ( check_ap_tdls_prohibited(pIE->data, pIE->Length) == true )
 				ptdlsinfo->ap_prohibited = true;
 			break;
 #endif //CONFIG_TDLS
@@ -1523,7 +1523,7 @@ unsigned char get_highest_rate_idx(u32 m
 
 	for(i=27; i>=0; i--)
 	{
-		if(mask & BIT(i))
+		if (mask & BIT(i))
 		{
 			rate_idx = i;
 			break;
@@ -1579,7 +1579,7 @@ void update_tx_basic_rate(struct rtw_ada
 	//	Added by Albert 2011/03/22
 	//	In the P2P mode, the driver should not support the b mode.
 	//	So, the Tx packet shouldn't use the CCK rate
-	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 #endif //CONFIG_P2P
 #ifdef CONFIG_INTEL_WIDI
@@ -1590,7 +1590,7 @@ void update_tx_basic_rate(struct rtw_ada
 	memset(supported_rates, 0, NDIS_802_11_LENGTH_RATES_EX);
 
 	//clear B mod if current channel is in 5G band, avoid tx cck rate in 5G band.
-	if(pmlmeext->cur_channel > 14)
+	if (pmlmeext->cur_channel > 14)
 		wirelessmode &= ~(WIRELESS_11B);
 
 	if ((wirelessmode & WIRELESS_11B) && (wirelessmode == WIRELESS_11B)) {
@@ -1714,12 +1714,12 @@ void update_capinfo(struct rtw_adapter *
 
 	// Check preamble mode, 2005.01.06, by rcnjko.
 	// Mark to update preamble value forever, 2008.03.18 by lanhsin
-	//if( pMgntInfo->RegPreambleMode == PREAMBLE_AUTO )
+	//if ( pMgntInfo->RegPreambleMode == PREAMBLE_AUTO )
 	{
 
-		if(updateCap & cShortPreamble)
+		if (updateCap & cShortPreamble)
 		{ // Short Preamble
-			if(pmlmeinfo->preamble_mode != PREAMBLE_SHORT) // PREAMBLE_LONG or PREAMBLE_AUTO
+			if (pmlmeinfo->preamble_mode != PREAMBLE_SHORT) // PREAMBLE_LONG or PREAMBLE_AUTO
 			{
 				ShortPreamble = true;
 				pmlmeinfo->preamble_mode = PREAMBLE_SHORT;
@@ -1728,7 +1728,7 @@ void update_capinfo(struct rtw_adapter *
 		}
 		else
 		{ // Long Preamble
-			if(pmlmeinfo->preamble_mode != PREAMBLE_LONG)  // PREAMBLE_SHORT or PREAMBLE_AUTO
+			if (pmlmeinfo->preamble_mode != PREAMBLE_LONG)  // PREAMBLE_SHORT or PREAMBLE_AUTO
 			{
 				ShortPreamble = false;
 				pmlmeinfo->preamble_mode = PREAMBLE_LONG;
@@ -1744,24 +1744,24 @@ void update_capinfo(struct rtw_adapter *
 	else
 	{
 		//Filen: See 802.11-2007 p.90
-		if( pmlmeext->cur_wireless_mode & (WIRELESS_11G | WIRELESS_11_24N))
+		if ( pmlmeext->cur_wireless_mode & (WIRELESS_11G | WIRELESS_11_24N))
 		{
-			if( (updateCap & cShortSlotTime) /* && (!(pMgntInfo->pHTInfo->RT2RT_HT_Mode & RT_HT_CAP_USE_LONG_PREAMBLE)) */)
+			if ( (updateCap & cShortSlotTime) /* && (!(pMgntInfo->pHTInfo->RT2RT_HT_Mode & RT_HT_CAP_USE_LONG_PREAMBLE)) */)
 			{ // Short Slot Time
-				if(pmlmeinfo->slotTime != SHORT_SLOT_TIME)
+				if (pmlmeinfo->slotTime != SHORT_SLOT_TIME)
 				{
 					pmlmeinfo->slotTime = SHORT_SLOT_TIME;
 				}
 			}
 			else
 			{ // Long Slot Time
-				if(pmlmeinfo->slotTime != NON_SHORT_SLOT_TIME)
+				if (pmlmeinfo->slotTime != NON_SHORT_SLOT_TIME)
 				{
 					pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
 				}
 			}
 		}
-		else if( pmlmeext->cur_wireless_mode & (WIRELESS_11A | WIRELESS_11_5N))
+		else if ( pmlmeext->cur_wireless_mode & (WIRELESS_11A | WIRELESS_11_5N))
 		{
 			pmlmeinfo->slotTime = SHORT_SLOT_TIME;
 		}
@@ -1796,7 +1796,7 @@ void update_wireless_mode(struct rtw_ada
 		pmlmeinfo->HT_enable = 1;
 	}
 
-	if(pmlmeext->cur_channel > 14)
+	if (pmlmeext->cur_channel > 14)
 	{
 		if (pmlmeinfo->HT_enable)
 		{
@@ -1816,7 +1816,7 @@ void update_wireless_mode(struct rtw_ada
 		{
 			network_type |= WIRELESS_11B;
 		}
-		else if((cckrates_included(rate, ratelen)) == true)
+		else if ((cckrates_included(rate, ratelen)) == true)
 		{
 			network_type |= WIRELESS_11BG;
 		}
@@ -1835,7 +1835,7 @@ void update_wireless_mode(struct rtw_ada
 	rtw_hal_set_hwreg( padapter, HW_VAR_INIT_DATA_RATE,  (u8 *)&init_rate);
 
 /*
-	if((pmlmeext->cur_wireless_mode==WIRELESS_11G) ||
+	if ((pmlmeext->cur_wireless_mode==WIRELESS_11G) ||
 		(pmlmeext->cur_wireless_mode==WIRELESS_11BG))//WIRELESS_MODE_G)
 		SIFS_Timer = 0x0a0a;//CCK
 	else
@@ -1853,7 +1853,7 @@ void update_wireless_mode(struct rtw_ada
 	{
 		update_mgnt_tx_rate(padapter, IEEE80211_OFDM_RATE_6MB);
 #ifdef CONFIG_CONCURRENT_MODE
-		if(pbuddy_adapter && (pmlmeext->cur_wireless_mode & WIRELESS_11A))
+		if (pbuddy_adapter && (pmlmeext->cur_wireless_mode & WIRELESS_11A))
 			update_mgnt_tx_rate(pbuddy_adapter, IEEE80211_OFDM_RATE_6MB);
 #endif //CONFIG_CONCURRENT_MODE
 	}
@@ -1869,7 +1869,7 @@ void update_bmc_sta_support_rate(struct
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	if(pmlmeext->cur_wireless_mode & WIRELESS_11B)
+	if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
 	{
 		// Only B, B/G, and B/G/N AP could use CCK rate
 		memcpy((pmlmeinfo->FW_sta_info[mac_id].SupportedRates), rtw_basic_rate_cck, 4);
@@ -1917,7 +1917,7 @@ void process_addba_req(struct rtw_adapte
 
 	psta = rtw_get_stainfo(pstapriv, addr);
 
-	if(psta)
+	if (psta)
 	{
 		start_seq = le16_to_cpu(preq->BA_starting_seqctrl) >> 4;
 
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -184,7 +184,7 @@ _func_enter_;
 		//pxmitbuf->pbuf = pxmitbuf->pallocated_buf + XMITBUF_ALIGN_SZ -((SIZE_PTR) (pxmitbuf->pallocated_buf) &(XMITBUF_ALIGN_SZ-1));
 */
 
-		if((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ))) == _FAIL) {
+		if ((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ))) == _FAIL) {
 			res= _FAIL;
 			goto exit;
 		}
@@ -236,7 +236,7 @@ _func_enter_;
 		pxmitbuf->pbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitbuf->pallocated_buf), 4);
 */
 
-		if((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ)) == _FAIL) {
+		if ((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ)) == _FAIL) {
 			res= _FAIL;
 			goto exit;
 		}
@@ -314,7 +314,7 @@ void _rtw_free_xmit_priv (struct xmit_pr
 
 	rtw_mfree_xmit_priv_lock(pxmitpriv);
 
-	if(pxmitpriv->pxmit_frame_buf==NULL)
+	if (pxmitpriv->pxmit_frame_buf==NULL)
 		goto out;
 
 	for(i=0; i<NR_XMITFRAME; i++)
@@ -330,12 +330,12 @@ void _rtw_free_xmit_priv (struct xmit_pr
 		pxmitbuf++;
 	}
 
-	if(pxmitpriv->pallocated_frame_buf) {
+	if (pxmitpriv->pallocated_frame_buf) {
 		rtw_vmfree(pxmitpriv->pallocated_frame_buf, NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
 	}
 
 
-	if(pxmitpriv->pallocated_xmitbuf) {
+	if (pxmitpriv->pallocated_xmitbuf) {
 		rtw_vmfree(pxmitpriv->pallocated_xmitbuf, NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
 	}
 
@@ -350,7 +350,7 @@ void _rtw_free_xmit_priv (struct xmit_pr
 		pxmitbuf++;
 	}
 
-	if(pxmitpriv->pallocated_xmit_extbuf) {
+	if (pxmitpriv->pallocated_xmit_extbuf) {
 		rtw_vmfree(pxmitpriv->pallocated_xmit_extbuf, NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);
 	}
 
@@ -388,17 +388,17 @@ static void update_attrib_vcs_info(struc
 	// (2) If there are more than one frag in  this MSDU, only the first frag uses protection frame.
 	//		Other fragments are protected by previous fragment.
 	//		So we only need to check the length of first fragment.
-	if(pmlmeext->cur_wireless_mode < WIRELESS_11_24N  || padapter->registrypriv.wifi_spec)
+	if (pmlmeext->cur_wireless_mode < WIRELESS_11_24N  || padapter->registrypriv.wifi_spec)
 	{
-		if(sz > padapter->registrypriv.rts_thresh)
+		if (sz > padapter->registrypriv.rts_thresh)
 		{
 			pattrib->vcs_mode = RTS_CTS;
 		}
 		else
 		{
-			if(psta->rtsen)
+			if (psta->rtsen)
 				pattrib->vcs_mode = RTS_CTS;
-			else if(psta->cts2self)
+			else if (psta->cts2self)
 				pattrib->vcs_mode = CTS_TO_SELF;
 			else
 				pattrib->vcs_mode = NONE_VCS;
@@ -410,13 +410,13 @@ static void update_attrib_vcs_info(struc
 		{
 #if 0 //Todo
 			//check IOT action
-			if(pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF)
+			if (pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF)
 			{
 				pattrib->vcs_mode = CTS_TO_SELF;
 				pattrib->rts_rate = MGN_24M;
 				break;
 			}
-			else if(pHTInfo->IOTAction & (HT_IOT_ACT_FORCED_RTS|HT_IOT_ACT_PURE_N_MODE))
+			else if (pHTInfo->IOTAction & (HT_IOT_ACT_FORCED_RTS|HT_IOT_ACT_PURE_N_MODE))
 			{
 				pattrib->vcs_mode = RTS_CTS;
 				pattrib->rts_rate = MGN_24M;
@@ -425,7 +425,7 @@ static void update_attrib_vcs_info(struc
 #endif
 
 			//IOT action
-			if((pmlmeinfo->assoc_AP_vendor == atherosAP) && (pattrib->ampdu_en==true) &&
+			if ((pmlmeinfo->assoc_AP_vendor == atherosAP) && (pattrib->ampdu_en==true) &&
 				(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_ ))
 			{
 				pattrib->vcs_mode = CTS_TO_SELF;
@@ -434,21 +434,21 @@ static void update_attrib_vcs_info(struc
 
 
 			//check ERP protection
-			if(psta->rtsen || psta->cts2self)
+			if (psta->rtsen || psta->cts2self)
 			{
-				if(psta->rtsen)
+				if (psta->rtsen)
 					pattrib->vcs_mode = RTS_CTS;
-				else if(psta->cts2self)
+				else if (psta->cts2self)
 					pattrib->vcs_mode = CTS_TO_SELF;
 
 				break;
 			}
 
 			//check HT op mode
-			if(pattrib->ht_en)
+			if (pattrib->ht_en)
 			{
 				u8 HTOpMode = pmlmeinfo->HT_protection;
-				if((pmlmeext->cur_bwmode && (HTOpMode == 2 || HTOpMode == 3)) ||
+				if ((pmlmeext->cur_bwmode && (HTOpMode == 2 || HTOpMode == 3)) ||
 					(!pmlmeext->cur_bwmode && HTOpMode == 3) )
 				{
 					pattrib->vcs_mode = RTS_CTS;
@@ -457,7 +457,7 @@ static void update_attrib_vcs_info(struc
 			}
 
 			//check rts
-			if(sz > padapter->registrypriv.rts_thresh)
+			if (sz > padapter->registrypriv.rts_thresh)
 			{
 				pattrib->vcs_mode = RTS_CTS;
 				break;
@@ -466,7 +466,7 @@ static void update_attrib_vcs_info(struc
 			//to do list: check MIMO power save condition.
 
 			//check AMPDU aggregation for TXOP
-			if(pattrib->ampdu_en==true)
+			if (pattrib->ampdu_en==true)
 			{
 				pattrib->vcs_mode = RTS_CTS;
 				break;
@@ -480,9 +480,9 @@ static void update_attrib_vcs_info(struc
 
 static void update_attrib_phy_info(struct pkt_attrib *pattrib, struct sta_info *psta)
 {
-	/*if(psta->rtsen)
+	/*if (psta->rtsen)
 		pattrib->vcs_mode = RTS_CTS;
-	else if(psta->cts2self)
+	else if (psta->cts2self)
 		pattrib->vcs_mode = CTS_TO_SELF;
 	else
 		pattrib->vcs_mode = NONE_VCS;*/
@@ -500,9 +500,9 @@ static void update_attrib_phy_info(struc
 	pattrib->sgi= psta->htpriv.sgi;
 	pattrib->ampdu_en = false;
 
-	//if(pattrib->ht_en && psta->htpriv.ampdu_enable)
+	//if (pattrib->ht_en && psta->htpriv.ampdu_enable)
 	//{
-	//	if(psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
+	//	if (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
 	//		pattrib->ampdu_en = true;
 	//}
 
@@ -519,7 +519,7 @@ u8	qos_acm(u8 acm_mask, u8 priority)
 	{
 		case 0:
 		case 3:
-			if(acm_mask & BIT(1))
+			if (acm_mask & BIT(1))
 				change_priority = 1;
 			break;
 		case 1:
@@ -527,12 +527,12 @@ u8	qos_acm(u8 acm_mask, u8 priority)
 			break;
 		case 4:
 		case 5:
-			if(acm_mask & BIT(2))
+			if (acm_mask & BIT(2))
 				change_priority = 0;
 			break;
 		case 6:
 		case 7:
-			if(acm_mask & BIT(3))
+			if (acm_mask & BIT(3))
 				change_priority = 5;
 			break;
 		default:
@@ -627,7 +627,7 @@ static s32 update_attrib(struct rtw_adap
 					// 67 : UDP BOOTP server
 					RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("======================update_attrib: get DHCP Packet \n"));
 					// Use low rate to send DHCP packet.
-					//if(pMgntInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom)
+					//if (pMgntInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom)
 					//{
 					//	tcb_desc->DataRate = MgntQuery_TxRateExcludeCCKRates(ieee);//0xc;//ofdm 6m
 					//	tcb_desc->bTxDisableRateFallBack = false;
@@ -669,7 +669,7 @@ static s32 update_attrib(struct rtw_adap
 			res =_FAIL;
 			goto exit;
 		}
-		else if((check_fwstate(pmlmepriv, WIFI_AP_STATE)==true)&&(!(psta->state & _FW_LINKED)))
+		else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE)==true)&&(!(psta->state & _FW_LINKED)))
 		{
 			res =_FAIL;
 			goto exit;
@@ -702,16 +702,16 @@ static s32 update_attrib(struct rtw_adap
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
 	{
-		if(psta->qos_option)
+		if (psta->qos_option)
 			set_qos(&pktfile, pattrib);
 	}
 	else
 	{
-		if(pqospriv->qos_option)
+		if (pqospriv->qos_option)
 		{
 			set_qos(&pktfile, pattrib);
 
-			if(pmlmepriv->acm_mask != 0)
+			if (pmlmepriv->acm_mask != 0)
 			{
 				pattrib->priority = qos_acm(pmlmepriv->acm_mask, pattrib->priority);
 			}
@@ -726,7 +726,7 @@ static s32 update_attrib(struct rtw_adap
 
 		pattrib->encrypt = 0;
 
-		if((pattrib->ether_type != 0x888e) && (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false))
+		if ((pattrib->ether_type != 0x888e) && (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false))
 		{
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\npsta->ieee8021x_blocked == true,  pattrib->ether_type(%.4x) != 0x888e\n",pattrib->ether_type));
 			#ifdef DBG_TX_DROP_FRAME
@@ -748,7 +748,7 @@ static s32 update_attrib(struct rtw_adap
 				pattrib->key_idx = (u8)psecuritypriv->dot11PrivacyKeyIndex;
 				break;
 			case dot11AuthAlgrthm_8021X:
-				if(bmcast)
+				if (bmcast)
 					pattrib->key_idx = (u8)psecuritypriv->dot118021XGrpKeyid;
 				else
 					pattrib->key_idx = 0;
@@ -773,7 +773,7 @@ static s32 update_attrib(struct rtw_adap
 			pattrib->iv_len = 8;
 			pattrib->icv_len = 4;
 
-			if(padapter->securitypriv.busetkipkey==_FAIL)
+			if (padapter->securitypriv.busetkipkey==_FAIL)
 			{
 				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\npadapter->securitypriv.busetkipkey(%d)==_FAIL drop packet\n", padapter->securitypriv.busetkipkey));
 				#ifdef DBG_TX_DROP_FRAME
@@ -813,7 +813,7 @@ static s32 update_attrib(struct rtw_adap
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if((pattrib->encrypt && bmcast) || (pattrib->encrypt ==_WEP40_) || (pattrib->encrypt ==_WEP104_))
+	if ((pattrib->encrypt && bmcast) || (pattrib->encrypt ==_WEP40_) || (pattrib->encrypt ==_WEP104_))
 	{
 		pattrib->bswenc = true;//force using sw enc.
 	}
@@ -842,7 +842,7 @@ static s32 xmitframe_addmic(struct rtw_a
 	u8 priority[4]={0x0,0x0,0x0,0x0};
 	int bmcst = IS_MCAST(pattrib->ra);
 
-	if(pattrib->psta)
+	if (pattrib->psta)
 	{
 		stainfo = pattrib->psta;
 	}
@@ -855,10 +855,10 @@ static s32 xmitframe_addmic(struct rtw_a
 
 _func_enter_;
 
-	if(pattrib->encrypt ==_TKIP_)//if(psecuritypriv->dot11PrivacyAlgrthm==_TKIP_PRIVACY_)
+	if (pattrib->encrypt ==_TKIP_)//if (psecuritypriv->dot11PrivacyAlgrthm==_TKIP_PRIVACY_)
 	{
 		//encode mic code
-		if(stainfo!= NULL){
+		if (stainfo!= NULL){
 			u8 null_key[16]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
 
 #ifdef CONFIG_USB_TX_AGGREGATION
@@ -867,9 +867,9 @@ _func_enter_;
 			pframe = pxmitframe->buf_addr + TXDESC_OFFSET;
 #endif
 
-			if(bmcst)
+			if (bmcst)
 			{
-				if(_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16)==true){
+				if (_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16)==true){
 					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
 					//rtw_msleep_os(10);
 					return _FAIL;
@@ -879,7 +879,7 @@ _func_enter_;
 			}
 			else
 			{
-				if(_rtw_memcmp(&stainfo->dot11tkiptxmickey.skey[0],null_key, 16)==true){
+				if (_rtw_memcmp(&stainfo->dot11tkiptxmickey.skey[0],null_key, 16)==true){
 					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
 					//rtw_msleep_os(10);
 					return _FAIL;
@@ -888,24 +888,24 @@ _func_enter_;
 				rtw_secmicsetkey(&micdata, &stainfo->dot11tkiptxmickey.skey[0]);
 			}
 
-			if(pframe[1]&1){   //ToDS==1
+			if (pframe[1]&1){   //ToDS==1
 				rtw_secmicappend(&micdata, &pframe[16], 6);  //DA
-				if(pframe[1]&2)  //From Ds==1
+				if (pframe[1]&2)  //From Ds==1
 					rtw_secmicappend(&micdata, &pframe[24], 6);
 				else
 				rtw_secmicappend(&micdata, &pframe[10], 6);
 			}
 			else{	//ToDS==0
 				rtw_secmicappend(&micdata, &pframe[4], 6);   //DA
-				if(pframe[1]&2)  //From Ds==1
+				if (pframe[1]&2)  //From Ds==1
 					rtw_secmicappend(&micdata, &pframe[16], 6);
 				else
 					rtw_secmicappend(&micdata, &pframe[10], 6);
 
 			}
 
-                    //if(pqospriv->qos_option==1)
-                    if(pattrib->qos_en)
+                    //if (pqospriv->qos_option==1)
+                    if (pattrib->qos_en)
 				priority[0]=(u8)pxmitframe->attrib.priority;
 
 
@@ -920,7 +920,7 @@ _func_enter_;
 
 				payload=payload+pattrib->hdrlen+pattrib->iv_len;
 				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("curfragnum=%d pattrib->hdrlen=%d pattrib->iv_len=%d",curfragnum,pattrib->hdrlen,pattrib->iv_len));
-				if((curfragnum+1)==pattrib->nr_frags){
+				if ((curfragnum+1)==pattrib->nr_frags){
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-( (pattrib->bswenc) ? pattrib->icv_len : 0);
 					rtw_secmicappend(&micdata, payload,length);
 					payload=payload+length;
@@ -967,8 +967,8 @@ static s32 xmitframe_swencrypt(struct rt
 
 _func_enter_;
 
-	//if((psecuritypriv->sw_encrypt)||(pattrib->bswenc))
-	if(pattrib->bswenc)
+	//if ((psecuritypriv->sw_encrypt)||(pattrib->bswenc))
+	if (pattrib->bswenc)
 	{
 		//DBG_8192D("start xmitframe_swencrypt\n");
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_alert_,("### xmitframe_swencrypt\n"));
@@ -1023,7 +1023,7 @@ _func_enter_;
 	if (pattrib->psta) {
 		psta = pattrib->psta;
 	} else {
-		if(bmcst) {
+		if (bmcst) {
 			psta = rtw_get_bcmc_stainfo(padapter);
 		} else {
 			psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
@@ -1039,9 +1039,9 @@ _func_enter_;
 		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == true)) {
 			//to_ds = 1, fr_ds = 0;
 #ifdef CONFIG_TDLS
-			if((ptdlsinfo->setup_state == TDLS_LINKED_STATE)){
+			if ((ptdlsinfo->setup_state == TDLS_LINKED_STATE)){
 				ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
-				if((ptdls_sta!=NULL)&&(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE)&&(pattrib->ether_type!=0x0806)){
+				if ((ptdls_sta!=NULL)&&(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE)&&(pattrib->ether_type!=0x0806)){
 					//TDLS data transfer, ToDS=0, FrDs=0
 					memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
 					memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
@@ -1076,7 +1076,7 @@ _func_enter_;
 			memcpy(pwlanhdr->addr2, get_bssid(pmlmepriv), ETH_ALEN);
 			memcpy(pwlanhdr->addr3, pattrib->src, ETH_ALEN);
 
-			if(psta->qos_option)
+			if (psta->qos_option)
 				qos_option = true;
 		}
 		else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
@@ -1085,7 +1085,7 @@ _func_enter_;
 			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 			memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
 
-			if(psta->qos_option)
+			if (psta->qos_option)
 				qos_option = true;
 		}
 		else {
@@ -1094,7 +1094,7 @@ _func_enter_;
 			goto exit;
 		}
 
-		if(pattrib->mdata)
+		if (pattrib->mdata)
 			SetMData(fctrl);
 
 		if (pattrib->encrypt)
@@ -1116,9 +1116,9 @@ _func_enter_;
 
 		//Update Seq Num will be handled by f/w
 		{
-			if(psta){
+			if (psta){
 #ifdef CONFIG_TDLS
-				if(direct_link==1)
+				if (direct_link==1)
 				{
 					psta_backup = psta;
 					psta = ptdls_sta;
@@ -1134,26 +1134,26 @@ _func_enter_;
 
 
 				//check if enable ampdu
-				if(pattrib->ht_en && psta->htpriv.ampdu_enable)
+				if (pattrib->ht_en && psta->htpriv.ampdu_enable)
 				{
-					if(psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
+					if (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
 					pattrib->ampdu_en = true;
 				}
 
 				//re-check if enable ampdu by BA_starting_seqctrl
-				if(pattrib->ampdu_en == true)
+				if (pattrib->ampdu_en == true)
 				{
 					u16 tx_seq;
 
 					tx_seq = psta->BA_starting_seqctrl[pattrib->priority & 0x0f];
 
 					//check BA_starting_seqctrl
-					if(SN_LESS(pattrib->seqnum, tx_seq))
+					if (SN_LESS(pattrib->seqnum, tx_seq))
 					{
 						//DBG_8192D("tx ampdu seqnum(%d) < tx_seq(%d)\n", pattrib->seqnum, tx_seq);
 						pattrib->ampdu_en = false;//AGG BK
 					}
-					else if(SN_EQUAL(pattrib->seqnum, tx_seq))
+					else if (SN_EQUAL(pattrib->seqnum, tx_seq))
 					{
 						psta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (tx_seq+1)&0xfff;
 
@@ -1169,7 +1169,7 @@ _func_enter_;
 				}
 
 #ifdef CONFIG_TDLS
-				if(direct_link==1)
+				if (direct_link==1)
 				{
 					if (pattrib->encrypt){
 						pattrib->encrypt= _AES_;
@@ -1340,7 +1340,7 @@ _func_enter_;
 			tdls_seq=1;
 			break;
 		case TDLS_DISCOVERY_REQUEST:	//unicast: directly to peer sta, Bcast: via AP
-			if(_rtw_memcmp(pattrib->dst, baddr, ETH_ALEN) )
+			if (_rtw_memcmp(pattrib->dst, baddr, ETH_ALEN) )
 			{
 				SetToDs(fctrl);
 				memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
@@ -1372,9 +1372,9 @@ _func_enter_;
 
 	//  1. update seq_num per link by sta_info
 	//  2. rewrite encrypt to _AES_, also rewrite iv_len, icv_len
-	if(tdls_seq==1){
+	if (tdls_seq==1){
 		ptdls_sta=rtw_get_stainfo(pstapriv, pattrib->dst);
-		if(ptdls_sta){
+		if (ptdls_sta){
 			ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
 			ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
 			pattrib->seqnum = ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority];
@@ -1389,7 +1389,7 @@ _func_enter_;
 			res=_FAIL;
 			goto exit;
 		}
-	}else if(psta){
+	}else if (psta){
 		psta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
 		psta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
 		pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[pattrib->priority];
@@ -1423,14 +1423,14 @@ _func_enter_;
 	if (pattrib->psta) {
 		psta = pattrib->psta;
 	} else {
-		if(bmcst) {
+		if (bmcst) {
 			psta = rtw_get_bcmc_stainfo(padapter);
 		} else {
 			psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
 	        }
 	}
 
-	if(psta==NULL)
+	if (psta==NULL)
 		return _FAIL;
 
 	if (pxmitframe->buf_addr == NULL)
@@ -1459,13 +1459,13 @@ _func_enter_;
 						WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
 					break;
 				case _TKIP_:
-					if(bmcst)
+					if (bmcst)
 						TKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
 					else
 						TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
 					break;
 				case _AES_:
-					if(bmcst)
+					if (bmcst)
 						AES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
 					else
 						AES_IV(pattrib->iv, psta->dot11txpn, 0);
@@ -1572,7 +1572,7 @@ _func_enter_;
 		psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
 	}
 
-	if(psta==NULL)
+	if (psta==NULL)
 		return _FAIL;
 
 	if (pxmitframe->buf_addr == NULL)
@@ -1628,13 +1628,13 @@ _func_enter_;
 							WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
 						break;
 					case _TKIP_:
-						if(bmcst)
+						if (bmcst)
 							TKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
 						else
 							TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
 						break;
 					case _AES_:
-						if(bmcst)
+						if (bmcst)
 							AES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
 						else
 							AES_IV(pattrib->iv, psta->dot11txpn, 0);
@@ -1709,7 +1709,7 @@ _func_enter_;
 
 	xmitframe_swencrypt(padapter, pxmitframe);
 
-	if(bmcst == false)
+	if (bmcst == false)
 		update_attrib_vcs_info(padapter, pxmitframe);
 	else
 		pattrib->vcs_mode = NONE_VCS;
@@ -1779,7 +1779,7 @@ _func_enter_;
 		case AUTO_VCS:
 		default:
 			perp = rtw_get_ie(ie, _ERPINFO_IE_, &erp_len, ie_len);
-			if(perp == NULL)
+			if (perp == NULL)
 			{
 				pxmitpriv->vcs = NONE_VCS;
 			}
@@ -1788,7 +1788,7 @@ _func_enter_;
 				protection = (*(perp + 2)) & BIT(1);
 				if (protection)
 				{
-					if(pregistrypriv->vcs_type == RTS_CTS)
+					if (pregistrypriv->vcs_type == RTS_CTS)
 						pxmitpriv->vcs = RTS_CTS;
 					else
 						pxmitpriv->vcs = CTS_TO_SELF;
@@ -1812,7 +1812,7 @@ void rtw_count_tx_stats(struct rtw_adapt
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 
-	if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
+	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
 	{
 		pxmitpriv->tx_bytes += sz;
 #ifdef CONFIG_USB_TX_AGGREGATION
@@ -1823,7 +1823,7 @@ void rtw_count_tx_stats(struct rtw_adapt
 
 		psta = pxmitframe->attrib.psta;
 
-		if(psta)
+		if (psta)
 		{
 			pstats = &psta->sta_stats;
 #ifdef CONFIG_USB_TX_AGGREGATION
@@ -1848,7 +1848,7 @@ _func_enter_;
 
 	spin_lock_irqsave(&pfree_queue->lock, irqL);
 
-	if(_rtw_queue_empty(pfree_queue) == true) {
+	if (_rtw_queue_empty(pfree_queue) == true) {
 		pxmitbuf = NULL;
 	} else {
 
@@ -1892,7 +1892,7 @@ s32 rtw_free_xmitbuf_ext(struct xmit_pri
 
 _func_enter_;
 
-	if(pxmitbuf==NULL)
+	if (pxmitbuf==NULL)
 	{
 		return _FAIL;
 	}
@@ -1927,7 +1927,7 @@ _func_enter_;
 
 	spin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);
 
-	if(_rtw_queue_empty(pfree_xmitbuf_queue) == true) {
+	if (_rtw_queue_empty(pfree_xmitbuf_queue) == true) {
 		pxmitbuf = NULL;
 	} else {
 
@@ -1978,7 +1978,7 @@ _func_enter_;
 
 	//DBG_8192D("+rtw_free_xmitbuf\n");
 
-	if(pxmitbuf==NULL)
+	if (pxmitbuf==NULL)
 	{
 		return _FAIL;
 	}
@@ -1988,7 +1988,7 @@ _func_enter_;
 		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_FREE);
 	}
 
-	if(pxmitbuf->ext_tag)
+	if (pxmitbuf->ext_tag)
 	{
 		rtw_free_xmitbuf_ext(pxmitpriv, pxmitbuf);
 	}
@@ -2077,7 +2077,7 @@ _func_enter_;
 #endif
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
-		if(pxmitpriv->free_xmitframe_cnt==1)
+		if (pxmitpriv->free_xmitframe_cnt==1)
 		{
 			if (!rtw_netif_queue_stopped(padapter->pnetdev))
 				rtw_netif_stop_queue(padapter->pnetdev);
@@ -2127,7 +2127,7 @@ _func_enter_;
 	spin_unlock_bh(&pfree_xmit_queue->lock);
 
 
-	if(pndis_pkt)
+	if (pndis_pkt)
 		rtw_os_pkt_complete(padapter, pndis_pkt);
 
 exit:
@@ -2222,7 +2222,7 @@ _func_enter_;
 
 	inx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;
 
-	if(pregpriv->wifi_spec==1)
+	if (pregpriv->wifi_spec==1)
 	{
 		int j, tmp, acirp_cnt[4];
 		//entry indx: 0->vo, 1->vi, 2->be, 3->bk.
@@ -2235,7 +2235,7 @@ _func_enter_;
 		{
 			for(j=i+1; j<4; j++)
 			{
-				if(acirp_cnt[j]<acirp_cnt[i])
+				if (acirp_cnt[j]<acirp_cnt[i])
 				{
 					tmp = acirp_cnt[i];
 					acirp_cnt[i] = acirp_cnt[j];
@@ -2267,12 +2267,12 @@ _func_enter_;
 
 			pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
 
-			if(pxmitframe)
+			if (pxmitframe)
 			{
 				phwxmit->accnt--;
 
 				//Remove sta node when there is no pending packets.
-				if(_rtw_queue_empty(pframe_queue)) //must be done after get_next and before break
+				if (_rtw_queue_empty(pframe_queue)) //must be done after get_next and before break
 					rtw_list_delete(&ptxservq->tx_pending);
 
 				goto exit;
@@ -2386,7 +2386,7 @@ void rtw_alloc_hwxmits(struct rtw_adapte
 
 	hwxmits = pxmitpriv->hwxmits;
 
-	if(pxmitpriv->hwxmit_entry == 5)
+	if (pxmitpriv->hwxmit_entry == 5)
 	{
 		//pxmitpriv->bmc_txqueue.head = 0;
 		//hwxmits[0] .phwtxqueue = &pxmitpriv->bmc_txqueue;
@@ -2409,7 +2409,7 @@ void rtw_alloc_hwxmits(struct rtw_adapte
 		hwxmits[4] .sta_queue = &pxmitpriv->be_pending;
 
 	}
-	else if(pxmitpriv->hwxmit_entry == 4)
+	else if (pxmitpriv->hwxmit_entry == 4)
 	{
 
 		//pxmitpriv->vo_txqueue.head = 0;
@@ -2608,13 +2608,13 @@ int rtw_br_client_tx(struct rtw_adapter
 				is_vlan_tag = 1;
 			}
 
-			if(is_vlan_tag){
-				if(ICMPV6_MCAST_MAC(skb->data) && ICMPV6_PROTO1A_VALN(skb->data)){
+			if (is_vlan_tag){
+				if (ICMPV6_MCAST_MAC(skb->data) && ICMPV6_PROTO1A_VALN(skb->data)){
                                         memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
 				}
 			}else
 			{
-				if(ICMPV6_MCAST_MAC(skb->data) && ICMPV6_PROTO1A(skb->data)){
+				if (ICMPV6_MCAST_MAC(skb->data) && ICMPV6_PROTO1A(skb->data)){
                                         memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
 				}
 			}
@@ -2689,7 +2689,7 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 	rcu_read_unlock();
 #endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 
-	if( br_port	&& check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true)
+	if ( br_port	&& check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true)
 	{
 		res = rtw_br_client_tx(padapter, ppkt);
 		if (res == -1)
@@ -2718,7 +2718,7 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 
 #if defined(CONFIG_AP_MODE) || defined(CONFIG_TDLS)
 	spin_lock_bh(&pxmitpriv->lock);
-	if(xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == true)
+	if (xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == true)
 	{
 		spin_unlock_bh(&pxmitpriv->lock);
 		return 1;
@@ -2744,11 +2744,11 @@ int xmitframe_enqueue_for_tdls_sleeping_
 	int i;
 
 	ptdls_sta=rtw_get_stainfo(pstapriv, pattrib->dst);
-	if(ptdls_sta==NULL){
+	if (ptdls_sta==NULL){
 		return ret;
-	}else if(ptdls_sta->tdls_sta_state&TDLS_LINKED_STATE){
+	}else if (ptdls_sta->tdls_sta_state&TDLS_LINKED_STATE){
 
-		if(pattrib->triggered==1)
+		if (pattrib->triggered==1)
 		{
 			ret = true;
 			return ret;
@@ -2756,7 +2756,7 @@ int xmitframe_enqueue_for_tdls_sleeping_
 
 		spin_lock_bh(&ptdls_sta->sleep_q.lock);
 
-		if(ptdls_sta->state&WIFI_SLEEP_STATE)
+		if (ptdls_sta->state&WIFI_SLEEP_STATE)
 		{
 			rtw_list_delete(&pxmitframe->list);
 
@@ -2787,7 +2787,7 @@ int xmitframe_enqueue_for_tdls_sleeping_
 					break;
 			}
 
-			if(ptdls_sta->sleepq_len==1)
+			if (ptdls_sta->sleepq_len==1)
 			{
 				//transmit TDLS PTI via AP
 				rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_SD_PTI);
@@ -2817,7 +2817,7 @@ int xmitframe_enqueue_for_sleeping_sta(s
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 
-	if( ptdlsinfo->setup_state == TDLS_LINKED_STATE )
+	if ( ptdlsinfo->setup_state == TDLS_LINKED_STATE )
 	{
 		ret = xmitframe_enqueue_for_tdls_sleeping_sta(padapter, pxmitframe);
 		return ret;
@@ -2827,7 +2827,7 @@ int xmitframe_enqueue_for_sleeping_sta(s
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == false)
 	    return ret;
 
-	if(pattrib->psta)
+	if (pattrib->psta)
 	{
 		psta = pattrib->psta;
 	}
@@ -2836,16 +2836,16 @@ int xmitframe_enqueue_for_sleeping_sta(s
 		psta=rtw_get_stainfo(pstapriv, pattrib->ra);
 	}
 
-	if(psta==NULL)
+	if (psta==NULL)
 		return ret;
 
-	if(pattrib->triggered==1)
+	if (pattrib->triggered==1)
 	{
 		//DBG_8192D("directly xmit pspoll_triggered packet\n");
 
 		//pattrib->triggered=0;
 
-		if(bmcst)
+		if (bmcst)
 			pattrib->qsel = 0x11;//HIQ
 
 
@@ -2853,11 +2853,11 @@ int xmitframe_enqueue_for_sleeping_sta(s
 	}
 
 
-	if(bmcst)
+	if (bmcst)
 	{
 		spin_lock_bh(&psta->sleep_q.lock);
 
-		if(pstapriv->sta_dz_bitmap)//if anyone sta is in ps mode
+		if (pstapriv->sta_dz_bitmap)//if anyone sta is in ps mode
 		{
 			rtw_list_delete(&pxmitframe->list);
 
@@ -2883,11 +2883,11 @@ int xmitframe_enqueue_for_sleeping_sta(s
 
 	spin_lock_bh(&psta->sleep_q.lock);
 
-	if(psta->state&WIFI_SLEEP_STATE)
+	if (psta->state&WIFI_SLEEP_STATE)
 	{
 		u8 wmmps_ac=0;
 
-		if(pstapriv->sta_dz_bitmap&BIT(psta->aid))
+		if (pstapriv->sta_dz_bitmap&BIT(psta->aid))
 		{
 			rtw_list_delete(&pxmitframe->list);
 
@@ -2916,14 +2916,14 @@ int xmitframe_enqueue_for_sleeping_sta(s
 					break;
 			}
 
-			if(wmmps_ac)
+			if (wmmps_ac)
 				psta->sleepq_ac_len++;
 
-			if(((psta->has_legacy_ac) && (!wmmps_ac)) ||((!psta->has_legacy_ac)&&(wmmps_ac)))
+			if (((psta->has_legacy_ac) && (!wmmps_ac)) ||((!psta->has_legacy_ac)&&(wmmps_ac)))
 			{
 				pstapriv->tim_bitmap |= BIT(psta->aid);
 
-				if(psta->sleepq_len==1)
+				if (psta->sleepq_len==1)
 				{
 					update_beacon(padapter, _TIM_IE_, NULL, false);
 				}
@@ -2986,7 +2986,7 @@ void stop_sta_xmit(struct rtw_adapter *p
 	psta->state |= WIFI_SLEEP_STATE;
 
 #ifdef CONFIG_TDLS
-	if( !(psta->tdls_sta_state & TDLS_LINKED_STATE) )
+	if ( !(psta->tdls_sta_state & TDLS_LINKED_STATE) )
 #endif //CONFIG_TDLS
 	pstapriv->sta_dz_bitmap |= BIT(psta->aid);
 
@@ -3008,9 +3008,9 @@ void stop_sta_xmit(struct rtw_adapter *p
 	rtw_list_delete(&(pstaxmitpriv->bk_q.tx_pending));
 
 #ifdef CONFIG_TDLS
-	if( !(psta->tdls_sta_state & TDLS_LINKED_STATE) )
+	if ( !(psta->tdls_sta_state & TDLS_LINKED_STATE) )
 	{
-		if( psta_bmc != NULL )
+		if ( psta_bmc != NULL )
 		{
 #endif //CONFIG_TDLS
 
@@ -3071,15 +3071,15 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 		}
 
 		psta->sleepq_len--;
-		if(psta->sleepq_len>0)
+		if (psta->sleepq_len>0)
 			pxmitframe->attrib.mdata = 1;
 		else
 			pxmitframe->attrib.mdata = 0;
 
-		if(wmmps_ac)
+		if (wmmps_ac)
 		{
 			psta->sleepq_ac_len--;
-			if(psta->sleepq_ac_len>0)
+			if (psta->sleepq_ac_len>0)
 			{
 				pxmitframe->attrib.mdata = 1;
 				pxmitframe->attrib.eosp = 0;
@@ -3094,18 +3094,18 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 		pxmitframe->attrib.triggered = 1;
 
 		spin_unlock_bh(&psta->sleep_q.lock);
-		if(rtw_hal_xmit(padapter, pxmitframe) == true)
+		if (rtw_hal_xmit(padapter, pxmitframe) == true)
 			rtw_os_xmit_complete(padapter, pxmitframe);
 		spin_lock_bh(&psta->sleep_q.lock);
 
 	}
 
-	if(psta->sleepq_len==0)
+	if (psta->sleepq_len==0)
 	{
 #ifdef CONFIG_TDLS
-		if( psta->tdls_sta_state & TDLS_LINKED_STATE )
+		if ( psta->tdls_sta_state & TDLS_LINKED_STATE )
 		{
-			if(psta->state&WIFI_SLEEP_STATE)
+			if (psta->state&WIFI_SLEEP_STATE)
 				psta->state ^= WIFI_SLEEP_STATE;
 
 			spin_unlock_bh(&psta->sleep_q.lock);
@@ -3116,10 +3116,10 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 
 		update_mask = BIT(0);
 
-		if(psta->state&WIFI_SLEEP_STATE)
+		if (psta->state&WIFI_SLEEP_STATE)
 			psta->state ^= WIFI_SLEEP_STATE;
 
-		if(psta->state & WIFI_STA_ALIVE_CHK_STATE)
+		if (psta->state & WIFI_STA_ALIVE_CHK_STATE)
 		{
 			psta->expire_to = pstapriv->expire_to;
 			psta->state ^= WIFI_STA_ALIVE_CHK_STATE;
@@ -3133,10 +3133,10 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 
 	//for BC/MC Frames
 	psta_bmc = rtw_get_bcmc_stainfo(padapter);
-	if(!psta_bmc)
+	if (!psta_bmc)
 		return;
 
-	if((pstapriv->sta_dz_bitmap&0xfffe) == 0x0)//no any sta in ps mode
+	if ((pstapriv->sta_dz_bitmap&0xfffe) == 0x0)//no any sta in ps mode
 	{
 		spin_lock_bh(&psta_bmc->sleep_q.lock);
 
@@ -3152,7 +3152,7 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 			rtw_list_delete(&pxmitframe->list);
 
 			psta_bmc->sleepq_len--;
-			if(psta_bmc->sleepq_len>0)
+			if (psta_bmc->sleepq_len>0)
 				pxmitframe->attrib.mdata = 1;
 			else
 				pxmitframe->attrib.mdata = 0;
@@ -3161,7 +3161,7 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 			pxmitframe->attrib.triggered = 1;
 
 			spin_unlock_bh(&psta_bmc->sleep_q.lock);
-			if(rtw_hal_xmit(padapter, pxmitframe) == true)
+			if (rtw_hal_xmit(padapter, pxmitframe) == true)
 			{
 				rtw_os_xmit_complete(padapter, pxmitframe);
 			}
@@ -3170,7 +3170,7 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 
 		}
 
-		if(psta_bmc->sleepq_len==0)
+		if (psta_bmc->sleepq_len==0)
 		{
 			pstapriv->tim_bitmap &= ~BIT(0);
 			pstapriv->sta_dz_bitmap &= ~BIT(0);
@@ -3186,7 +3186,7 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 	}
 
 
-	if(update_mask)
+	if (update_mask)
 	{
 		//update_BCNTIM(padapter);
 		update_beacon(padapter, _TIM_IE_, NULL, false);
@@ -3233,7 +3233,7 @@ void xmit_delivery_enabled_frames(struct
 				break;
 		}
 
-		if(!wmmps_ac)
+		if (!wmmps_ac)
 			continue;
 
 		rtw_list_delete(&pxmitframe->list);
@@ -3241,7 +3241,7 @@ void xmit_delivery_enabled_frames(struct
 		psta->sleepq_len--;
 		psta->sleepq_ac_len--;
 
-		if(psta->sleepq_ac_len>0)
+		if (psta->sleepq_ac_len>0)
 		{
 			pxmitframe->attrib.mdata = 1;
 			pxmitframe->attrib.eosp = 0;
@@ -3254,15 +3254,15 @@ void xmit_delivery_enabled_frames(struct
 
 		pxmitframe->attrib.triggered = 1;
 
-		if(rtw_hal_xmit(padapter, pxmitframe) == true)
+		if (rtw_hal_xmit(padapter, pxmitframe) == true)
 		{
 			rtw_os_xmit_complete(padapter, pxmitframe);
 		}
 
-		if((psta->sleepq_ac_len==0) && (!psta->has_legacy_ac) && (wmmps_ac))
+		if ((psta->sleepq_ac_len==0) && (!psta->has_legacy_ac) && (wmmps_ac))
 		{
 #ifdef CONFIG_TDLS
-			if(psta->tdls_sta_state & TDLS_LINKED_STATE )
+			if (psta->tdls_sta_state & TDLS_LINKED_STATE )
 			{
 				spin_unlock_bh(&psta->sleep_q.lock);
 				return;
--- a/drivers/staging/rtl8192du/hal/hal_intf.c
+++ b/drivers/staging/rtl8192du/hal/hal_intf.c
@@ -28,56 +28,56 @@
 
 void rtw_hal_chip_configure(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.intf_chip_configure)
+	if (padapter->HalFunc.intf_chip_configure)
 		padapter->HalFunc.intf_chip_configure(padapter);
 }
 
 void rtw_hal_read_chip_info(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.read_adapter_info)
+	if (padapter->HalFunc.read_adapter_info)
 		padapter->HalFunc.read_adapter_info(padapter);
 }
 
 void rtw_hal_read_chip_version(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.read_chip_version)
+	if (padapter->HalFunc.read_chip_version)
 		padapter->HalFunc.read_chip_version(padapter);
 }
 
 void rtw_hal_def_value_init(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.init_default_value)
+	if (padapter->HalFunc.init_default_value)
 		padapter->HalFunc.init_default_value(padapter);
 }
 
 void rtw_hal_free_data(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.free_hal_data)
+	if (padapter->HalFunc.free_hal_data)
 		padapter->HalFunc.free_hal_data(padapter);
 }
 
 void rtw_hal_dm_init(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.dm_init)
+	if (padapter->HalFunc.dm_init)
 		padapter->HalFunc.dm_init(padapter);
 }
 
 void rtw_hal_dm_deinit(struct rtw_adapter *padapter)
 {
 	// cancel dm  timer
-	if(padapter->HalFunc.dm_deinit)
+	if (padapter->HalFunc.dm_deinit)
 		padapter->HalFunc.dm_deinit(padapter);
 }
 
 void rtw_hal_sw_led_init(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.InitSwLeds)
+	if (padapter->HalFunc.InitSwLeds)
 		padapter->HalFunc.InitSwLeds(padapter);
 }
 
 void rtw_hal_sw_led_deinit(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.DeInitSwLeds)
+	if (padapter->HalFunc.DeInitSwLeds)
 		padapter->HalFunc.DeInitSwLeds(padapter);
 }
 
@@ -85,14 +85,14 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 {
 	uint	status = _SUCCESS;
 
-	if(padapter->hw_init_completed == true)
+	if (padapter->hw_init_completed == true)
 	{
 		DBG_8192D("rtw_hal_init: hw_init_completed == true\n");
 		return status;
 	}
 #ifdef CONFIG_DEINIT_BEFORE_INIT
 	status = padapter->HalFunc.hal_deinit(padapter);
-	if(status != _SUCCESS){
+	if (status != _SUCCESS){
 		DBG_8192D("rtw_hal_init: hal_deinit before hal_init FAIL !!\n");
 		return status;
 	}
@@ -100,10 +100,10 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	// before init mac0, driver must init mac1 first to avoid usb rx error.
-	if((padapter->pbuddy_adapter != NULL) && (padapter->DualMacConcurrent == true)
+	if ((padapter->pbuddy_adapter != NULL) && (padapter->DualMacConcurrent == true)
 		&& (padapter->adapter_type == PRIMARY_ADAPTER))
 	{
-		if(padapter->pbuddy_adapter->hw_init_completed == true)
+		if (padapter->pbuddy_adapter->hw_init_completed == true)
 		{
 			DBG_8192D("rtw_hal_init: pbuddy_adapter hw_init_completed == true\n");
 		}
@@ -111,13 +111,13 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 		{
 #ifdef CONFIG_DEINIT_BEFORE_INIT
 			status = padapter->HalFunc.hal_deinit(padapter->pbuddy_adapter);
-			if(status != _SUCCESS){
+			if (status != _SUCCESS){
 				DBG_8192D("rtw_hal_init: hal_deinit before hal_init FAIL !!(pbuddy_adapter)\n");
 				return status;
 			}
 #endif
 			status =	padapter->HalFunc.hal_init(padapter->pbuddy_adapter);
-			if(status == _SUCCESS){
+			if (status == _SUCCESS){
 				padapter->pbuddy_adapter->hw_init_completed = true;
 			}
 			else{
@@ -128,21 +128,21 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 		}
 	}
 #else
-	if(adapter_to_dvobj(padapter)->NumInterfaces == 2 && padapter->registrypriv.mac_phy_mode != 1)
+	if (adapter_to_dvobj(padapter)->NumInterfaces == 2 && padapter->registrypriv.mac_phy_mode != 1)
 	{
 		if (WARN_ON_ONCE(!padapter->pbuddy_adapter))
 			return _FAIL;
-		if(padapter->pbuddy_adapter->hw_init_completed == false)
+		if (padapter->pbuddy_adapter->hw_init_completed == false)
 		{
 #ifdef CONFIG_DEINIT_BEFORE_INIT
 			status = padapter->HalFunc.hal_deinit(padapter->pbuddy_adapter);
-			if(status != _SUCCESS){
+			if (status != _SUCCESS){
 				DBG_8192D("rtw_hal_init: hal_deinit before hal_init FAIL !!(pbuddy_adapter)\n");
 				return status;
 			}
 #endif
 			status = padapter->HalFunc.hal_init(padapter->pbuddy_adapter);
-			if(status == _SUCCESS){
+			if (status == _SUCCESS){
 				padapter->pbuddy_adapter->hw_init_completed = true;
 			}
 			else{
@@ -157,7 +157,7 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 
 	status = padapter->HalFunc.hal_init(padapter);
 
-	if(status == _SUCCESS){
+	if (status == _SUCCESS){
 		padapter->hw_init_completed = true;
 
 		if (padapter->registrypriv.notch_filter == 1)
@@ -184,7 +184,7 @@ _func_enter_;
 
 	status = padapter->HalFunc.hal_deinit(padapter);
 
-	if(status == _SUCCESS){
+	if (status == _SUCCESS){
 		padapter->hw_init_completed = false;
 	}
 	else
@@ -211,14 +211,14 @@ void rtw_hal_get_hwreg(struct rtw_adapte
 
 u8 rtw_hal_set_def_var(struct rtw_adapter *padapter, enum HAL_DEF_VARIABLE eVariable, void * pValue)
 {
-	if(padapter->HalFunc.SetHalDefVarHandler)
+	if (padapter->HalFunc.SetHalDefVarHandler)
 		return padapter->HalFunc.SetHalDefVarHandler(padapter,eVariable,pValue);
 	return _FAIL;
 }
 
 u8 rtw_hal_get_def_var(struct rtw_adapter *padapter, enum HAL_DEF_VARIABLE eVariable, void * pValue)
 {
-	if(padapter->HalFunc.GetHalDefVarHandler)
+	if (padapter->HalFunc.GetHalDefVarHandler)
 		return padapter->HalFunc.GetHalDefVarHandler(padapter,eVariable,pValue);
 	return _FAIL;
 }
@@ -243,7 +243,7 @@ void rtw_hal_disable_interrupt(struct rt
 u32	rtw_hal_inirp_init(struct rtw_adapter *padapter)
 {
 	u32 rst = _FAIL;
-	if(padapter->HalFunc.inirp_init)
+	if (padapter->HalFunc.inirp_init)
 		rst = padapter->HalFunc.inirp_init(padapter);
 	else
 		DBG_8192D(" %s HalFunc.inirp_init is NULL!!!\n",__func__);
@@ -253,7 +253,7 @@ u32	rtw_hal_inirp_init(struct rtw_adapte
 u32	rtw_hal_inirp_deinit(struct rtw_adapter *padapter)
 {
 
-	if(padapter->HalFunc.inirp_deinit)
+	if (padapter->HalFunc.inirp_deinit)
 		return padapter->HalFunc.inirp_deinit(padapter);
 
 	return _FAIL;
@@ -262,14 +262,14 @@ u32	rtw_hal_inirp_deinit(struct rtw_adap
 
 u8 rtw_hal_intf_ps_func(struct rtw_adapter *padapter, enum HAL_INTF_PS_FUNC efunc_id, u8* val)
 {
-	if(padapter->HalFunc.interface_ps_func)
+	if (padapter->HalFunc.interface_ps_func)
 		return padapter->HalFunc.interface_ps_func(padapter,efunc_id,val);
 	return _FAIL;
 }
 
 s32 rtw_hal_xmit(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
 {
-	if(padapter->HalFunc.hal_xmit)
+	if (padapter->HalFunc.hal_xmit)
 		return padapter->HalFunc.hal_xmit(padapter, pxmitframe);
 
 	return false;
@@ -278,27 +278,27 @@ s32 rtw_hal_xmit(struct rtw_adapter *pad
 s32	rtw_hal_mgnt_xmit(struct rtw_adapter *padapter, struct xmit_frame *pmgntframe)
 {
 	s32 ret = _FAIL;
-	if(padapter->HalFunc.mgnt_xmit)
+	if (padapter->HalFunc.mgnt_xmit)
 		ret = padapter->HalFunc.mgnt_xmit(padapter, pmgntframe);
 	return ret;
 }
 
 s32 rtw_hal_init_xmit_priv(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.init_xmit_priv != NULL)
+	if (padapter->HalFunc.init_xmit_priv != NULL)
 		return padapter->HalFunc.init_xmit_priv(padapter);
 	return _FAIL;
 }
 
 void rtw_hal_free_xmit_priv(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.free_xmit_priv != NULL)
+	if (padapter->HalFunc.free_xmit_priv != NULL)
 		padapter->HalFunc.free_xmit_priv(padapter);
 }
 
 s32 rtw_hal_init_recv_priv(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.init_recv_priv)
+	if (padapter->HalFunc.init_recv_priv)
 		return padapter->HalFunc.init_recv_priv(padapter);
 
 	return _FAIL;
@@ -306,19 +306,19 @@ s32 rtw_hal_init_recv_priv(struct rtw_ad
 
 void rtw_hal_free_recv_priv(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.free_recv_priv)
+	if (padapter->HalFunc.free_recv_priv)
 		padapter->HalFunc.free_recv_priv(padapter);
 }
 
 void rtw_hal_update_ra_mask(struct rtw_adapter *padapter, u32 mac_id)
 {
-	if(padapter->HalFunc.UpdateRAMaskHandler)
+	if (padapter->HalFunc.UpdateRAMaskHandler)
 		padapter->HalFunc.UpdateRAMaskHandler(padapter,mac_id);
 }
 
 void rtw_hal_add_ra_tid(struct rtw_adapter *padapter, u32 bitmap, u8 arg)
 {
-	if(padapter->HalFunc.Add_RateATid)
+	if (padapter->HalFunc.Add_RateATid)
 		padapter->HalFunc.Add_RateATid(padapter, bitmap, arg);
 }
 
@@ -352,32 +352,32 @@ void rtw_hal_write_rfreg(struct rtw_adap
 
 s32 rtw_hal_interrupt_handler(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.interrupt_handler)
+	if (padapter->HalFunc.interrupt_handler)
 		return padapter->HalFunc.interrupt_handler(padapter);
 	return _FAIL;
 }
 
 void rtw_hal_set_bwmode(struct rtw_adapter *padapter, enum HT_CHANNEL_WIDTH Bandwidth, u8 Offset)
 {
-	if(padapter->HalFunc.set_bwmode_handler)
+	if (padapter->HalFunc.set_bwmode_handler)
 		padapter->HalFunc.set_bwmode_handler(padapter, Bandwidth, Offset);
 }
 
 void rtw_hal_set_chan(struct rtw_adapter *padapter, u8 channel)
 {
-	if(padapter->HalFunc.set_channel_handler)
+	if (padapter->HalFunc.set_channel_handler)
 		padapter->HalFunc.set_channel_handler(padapter, channel);
 }
 
 void rtw_hal_dm_watchdog(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.hal_dm_watchdog)
+	if (padapter->HalFunc.hal_dm_watchdog)
 		padapter->HalFunc.hal_dm_watchdog(padapter);
 }
 
 void rtw_hal_bcn_related_reg_setting(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.SetBeaconRelatedRegistersHandler)
+	if (padapter->HalFunc.SetBeaconRelatedRegistersHandler)
 		padapter->HalFunc.SetBeaconRelatedRegistersHandler(padapter);
 }
 
@@ -408,19 +408,19 @@ s32	rtw_hal_hostap_mgnt_xmit_entry(struc
 #ifdef DBG_CONFIG_ERROR_DETECT
 void rtw_hal_sreset_init(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.sreset_init_value)
+	if (padapter->HalFunc.sreset_init_value)
 		padapter->HalFunc.sreset_init_value(padapter);
 }
 
 void rtw_hal_sreset_reset(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.silentreset)
+	if (padapter->HalFunc.silentreset)
 		padapter->HalFunc.silentreset(padapter);
 }
 
 void rtw_hal_sreset_reset_value(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.sreset_reset_value)
+	if (padapter->HalFunc.sreset_reset_value)
 		padapter->HalFunc.sreset_reset_value(padapter);
 }
 
@@ -430,20 +430,20 @@ void rtw_hal_sreset_xmit_status_check(st
 	if (padapter->adapter_type != PRIMARY_ADAPTER)
 		return;
 #endif
-	if(padapter->HalFunc.sreset_xmit_status_check)
+	if (padapter->HalFunc.sreset_xmit_status_check)
 		padapter->HalFunc.sreset_xmit_status_check(padapter);
 }
 
 void rtw_hal_sreset_linked_status_check(struct rtw_adapter *padapter)
 {
-	if(padapter->HalFunc.sreset_linked_status_check)
+	if (padapter->HalFunc.sreset_linked_status_check)
 		padapter->HalFunc.sreset_linked_status_check(padapter);
 }
 
 u8 rtw_hal_sreset_get_wifi_status(struct rtw_adapter *padapter)
 {
 	u8 status = 0;
-	if(padapter->HalFunc.sreset_get_wifi_status)
+	if (padapter->HalFunc.sreset_get_wifi_status)
 		status = padapter->HalFunc.sreset_get_wifi_status(padapter);
 	return status;
 }
@@ -460,13 +460,13 @@ int rtw_hal_iol_cmd(ADAPTER *adapter, st
 
 void rtw_hal_notch_filter(struct rtw_adapter *adapter, bool enable)
 {
-	if(adapter->HalFunc.hal_notch_filter)
+	if (adapter->HalFunc.hal_notch_filter)
 		adapter->HalFunc.hal_notch_filter(adapter,enable);
 }
 
 void rtw_hal_reset_security_engine(struct rtw_adapter * adapter)
 {
-	if(adapter->HalFunc.hal_reset_security_engine)
+	if (adapter->HalFunc.hal_reset_security_engine)
 		adapter->HalFunc.hal_reset_security_engine(adapter);
 }
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -42,7 +42,7 @@ CheckWriteH2C(
 
 	valHMETFR = rtw_read8(Adapter, REG_HMETFR);
 
-	if(((valHMETFR>>BoxNum)&BIT0) == 1)
+	if (((valHMETFR>>BoxNum)&BIT0) == 1)
 		Result = true;
 
 	return Result;
@@ -62,7 +62,7 @@ CheckFwReadLastH2C(
 	//RT_TRACE(COMP_INIT,DBG_LOUD,("REG[%x] = %x\n",	REG_HMETFR, valHMETFR));
 
 	// Do not seperate to 91C and 88C, we use the same setting. Suggested by SD4 Filen. 2009.12.03.
-	if(((valHMETFR>>BoxNum)&BIT0) == 0)
+	if (((valHMETFR>>BoxNum)&BIT0) == 0)
 		Result = true;
 
 	return Result;
@@ -112,7 +112,7 @@ _func_enter_;
 	while(!bWriteSucess)
 	{
 		WaitWriteH2cLimmit--;
-		if(WaitWriteH2cLimmit == 0)
+		if (WaitWriteH2cLimmit == 0)
 		{
 			DBG_8192D("FillH2CCmd92C():Write H2C fail because no trigger for FW INT!!!!!!!!\n");
 			break;
@@ -148,7 +148,7 @@ _func_enter_;
 		{
 			//wait until Fw read
 			WaitH2cLimmit--;
-			if(WaitH2cLimmit == 0)
+			if (WaitH2cLimmit == 0)
 			{
 				DBG_8192D("FillH2CCmd92C(): Wating too long for FW read clear HMEBox(%d)!!!\n", BoxNum);
 				break;
@@ -160,7 +160,7 @@ _func_enter_;
 		}
 
 		// If Fw has not read the last H2C cmd, break and give up this H2C.
-		if(!IsFwRead)
+		if (!IsFwRead)
 		{
 			DBG_8192D("FillH2CCmd92C():  Write H2C register BOX[%d] fail!!!!! Fw do not read. \n", BoxNum);
 			break;
@@ -257,7 +257,7 @@ _func_enter_;
 
 		// Record the next BoxNum
 		pHalData->LastHMEBoxNum = BoxNum+1;
-		if(pHalData->LastHMEBoxNum == 4) // loop to 0
+		if (pHalData->LastHMEBoxNum == 4) // loop to 0
 			pHalData->LastHMEBoxNum = 0;
 
 		//DBG_8192D("FillH2CCmd92C():pHalData->LastHMEBoxNum  = %d\n", pHalData->LastHMEBoxNum);
@@ -281,7 +281,7 @@ FillH2CCmd92D(
 
 	//Adapter = ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, TRUE);
 
-	if(Adapter->bFWReady == false)
+	if (Adapter->bFWReady == false)
 	{
 		DBG_8192D("FillH2CCmd92D(): return H2C cmd because of Fw download fail!!!\n");
 		return;
@@ -302,7 +302,7 @@ u8 rtl8192d_h2c_msg_hdl(struct rtw_adapt
 	u8 *pCmdBuffer;
 	struct cmd_msg_parm  *pcmdmsg;
 
-	if(!pbuf)
+	if (!pbuf)
 		return H2C_PARAMETERS_ERROR;
 
 	pcmdmsg = (struct cmd_msg_parm*)pbuf;
@@ -345,7 +345,7 @@ void rtl8192d_Add_RateATid(struct rtw_ad
 
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 
-	if(pHalData->fw_ractrl == true)
+	if (pHalData->fw_ractrl == true)
 	{
 		rtl8192d_set_raid_cmd(pAdapter, bitmap, arg);
 	}
@@ -434,7 +434,7 @@ void ConstructBeacon(struct rtw_adapter
 	pktlen += 2;
 
 
-	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	if ( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 		DBG_8192D("ie len=%u\n", cur_network->IELength);
 		pktlen += cur_network->IELength - sizeof(struct ndis_802_11_fixed_ies);
@@ -455,7 +455,7 @@ void ConstructBeacon(struct rtw_adapter
 	// DS parameter set
 	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pktlen);
 
-	if( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	if ( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
 	{
 		u32 ATIMWindow;
 		// IBSS Parameter Set...
@@ -606,7 +606,7 @@ void ConstructProbeRsp(struct rtw_adapte
 	pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 	pframe += pktlen;
 
-	if(cur_network->IELength>MAX_IE_SZ)
+	if (cur_network->IELength>MAX_IE_SZ)
 		return;
 
 	memcpy(pframe, cur_network->IEs, cur_network->IELength);
@@ -647,7 +647,7 @@ FillFakeTxDescriptor92D(
 	ptxdesc->txdw1 |= cpu_to_le32((QSLT_MGNT<<QSEL_SHT)&0x00001f00); // Fixed queue of Mgnt queue
 
 	//Set NAVUSEHDR to prevent Ps-poll AId filed to be changed to error vlaue by Hw.
-	if(IsPsPoll)
+	if (IsPsPoll)
 	{
 		ptxdesc->txdw1 |= cpu_to_le32(NAVUSEHDR);
 	}
@@ -660,7 +660,7 @@ FillFakeTxDescriptor92D(
 	//offset 16
 	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
 
-	if(pHalData->CurrentBandType92D == BAND_ON_5G)
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 		ptxdesc->txdw5 |= cpu_to_le32(BIT(2));// use OFDM 6Mbps
 
 	// USB interface drop packet if the checksum of descriptor isn't correct.
@@ -700,7 +700,7 @@ void SetFwRsvdPagePkt(struct rtw_adapter
 	DBG_8192D("%s\n", __func__);
 
 	reservedpagepacket = (u8*)rtw_malloc(1000);
-	if(reservedpagepacket == NULL){
+	if (reservedpagepacket == NULL){
 		DBG_8192D("%s(): alloc reservedpagepacket fail !!!\n", __func__);
 		return;
 	}
@@ -726,7 +726,7 @@ void SetFwRsvdPagePkt(struct rtw_adapter
 	U1bTmp = (u8)PageNum_128(BeaconLength+TxDescLen);
 	PageNum += U1bTmp;
 	// To reserved 2 pages for beacon buffer. 2010.06.24.
-	if(PageNum == 1)
+	if (PageNum == 1)
 		PageNum+=1;
 	pHalData->FwRsvdPageStartOffset = PageNum;
 
@@ -812,7 +812,7 @@ void SetFwRsvdPagePkt(struct rtw_adapter
 
 	dlok = true;
 
-	if(dlok) {
+	if (dlok) {
 		DBG_8192D("Set RSVD page location to Fw.\n");
 		FillH2CCmd92D(Adapter, H2C_RSVDPAGE, sizeof(u1RsvdPageLoc), u1RsvdPageLoc);
 	}
@@ -832,7 +832,7 @@ _func_enter_;
 
 	DBG_8192D("%s\n", __func__);
 
-	if(mstatus == 1)
+	if (mstatus == 1)
 	{
 		// We should set AID, correct TSF, HW seq enable before set JoinBssReport to Fw in 88/92C.
 		// Suggested by filen. Added by tynli.
@@ -854,7 +854,7 @@ _func_enter_;
 		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4));
 
 		// Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame.
-		if(pHalData->RegFwHwTxQCtrl&BIT6)
+		if (pHalData->RegFwHwTxQCtrl&BIT6)
 			bRecover = true;
 		rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl&(~BIT6)));
 		pHalData->RegFwHwTxQCtrl &= (~BIT6);
@@ -871,7 +871,7 @@ _func_enter_;
 		// prevent from setting 0x422[6] to 0 after download reserved page, or it will cause
 		// the beacon cannot be sent by HW.
 		// 2010.06.23. Added by tynli.
-		if(bRecover)
+		if (bRecover)
 		{
 			rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl|BIT6));
 			pHalData->RegFwHwTxQCtrl |= BIT6;
@@ -919,7 +919,7 @@ _func_enter_;
 		case P2P_PS_ENABLE:
 			DBG_8192D("P2P_PS_ENABLE \n");
 			// update CTWindow value.
-			if( pwdinfo->ctwindow > 0 )
+			if ( pwdinfo->ctwindow > 0 )
 			{
 				p2p_ps_offload->CTWindow_En = 1;
 				ctwindow = pwdinfo->ctwindow;
@@ -932,7 +932,7 @@ _func_enter_;
 			{
 				// To control the register setting for which NOA
 				rtw_write8(padapter, 0x5CF, (i << 4));
-				if(i == 0)
+				if (i == 0)
 					p2p_ps_offload->NoA0_En = 1;
 				else
 					p2p_ps_offload->NoA1_En = 1;
@@ -946,12 +946,12 @@ _func_enter_;
 				tsf_low = rtw_read32(padapter, REG_TSFTR);
 
 				start_time = pwdinfo->noa_start_time[i];
-				if(pwdinfo->noa_count[i] != 1)
+				if (pwdinfo->noa_count[i] != 1)
 				{
 					while( start_time <= (tsf_low+(50*1024) ) )
 					{
 						start_time += pwdinfo->noa_interval[i];
-						if(pwdinfo->noa_count[i] != 255)
+						if (pwdinfo->noa_count[i] != 255)
 							pwdinfo->noa_count[i]--;
 					}
 				}
@@ -961,14 +961,14 @@ _func_enter_;
 				rtw_write8(padapter, 0x5EC, pwdinfo->noa_count[i]);
 			}
 
-			if( (pwdinfo->opp_ps == 1) || (pwdinfo->noa_num > 0) )
+			if ( (pwdinfo->opp_ps == 1) || (pwdinfo->noa_num > 0) )
 			{
 				// rst p2p circuit
 				rtw_write8(padapter, REG_DUAL_TSF_RST, BIT(4));
 
 				p2p_ps_offload->Offload_En = 1;
 
-				if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 				{
 					p2p_ps_offload->role= 1;
 					p2p_ps_offload->AllStaSleep = 0;
@@ -1068,7 +1068,7 @@ _func_enter_;
 
 
 
-	if(pwrpriv->wowlan_mode ==true){
+	if (pwrpriv->wowlan_mode ==true){
 		//pause RX DMA
 		test = rtw_read8(padapter, REG_RXPKT_NUM+2);
 		test |= BIT(2);
@@ -1091,15 +1091,15 @@ _func_enter_;
 
 		pwowlan_parm.mode |=FW_WOWLAN_FUN_EN;
 		//printk("\n %s 1.pwowlan_parm.mode=0x%x \n",__func__,pwowlan_parm.mode );
-		if(pwrpriv->wowlan_pattern ==true){
+		if (pwrpriv->wowlan_pattern ==true){
 			pwowlan_parm.mode |= FW_WOWLAN_PATTERN_MATCH;
 		//printk("\n %s 2.pwowlan_parm.mode=0x%x \n",__func__,pwowlan_parm.mode );
 		}
-		if(pwrpriv->wowlan_magic ==true){
+		if (pwrpriv->wowlan_magic ==true){
 			//pwowlan_parm.mode |=FW_WOWLAN_MAGIC_PKT;
 		//printk("\n %s 3.pwowlan_parm.mode=0x%x \n",__func__,pwowlan_parm.mode );
 		}
-		if(pwrpriv->wowlan_unicast ==true){
+		if (pwrpriv->wowlan_unicast ==true){
 			pwowlan_parm.mode |=FW_WOWLAN_UNICAST;
 		//printk("\n %s 4.pwowlan_parm.mode=0x%x \n",__func__,pwowlan_parm.mode );
 		}
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -120,17 +120,17 @@ dm_DualMacGetParameterFromBuddyAdapter(
 	struct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);
 	struct mlme_priv *pbuddy_mlmepriv = &(BuddyAdapter->mlmepriv);
 
-	if(pHalData->MacPhyMode92D != DUALMAC_SINGLEPHY)
+	if (pHalData->MacPhyMode92D != DUALMAC_SINGLEPHY)
 		return false;
 
-	if(BuddyAdapter == NULL)
+	if (BuddyAdapter == NULL)
 		return false;
 
-	if(pHalData->bSlaveOfDMSP)
+	if (pHalData->bSlaveOfDMSP)
 		return false;
 
 //sherry sync with 92C_92D, 20110701
-	if((check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) && (!check_fwstate(pmlmepriv, _FW_LINKED))
+	if ((check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) && (!check_fwstate(pmlmepriv, _FW_LINKED))
 		&& (!check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) ))
 		return true;
 	else
@@ -151,7 +151,7 @@ odm_FalseAlarmCounterStatistics_ForSlave
 	struct dm_priv	*Buddydmpriv;
 	struct FALSE_ALARM_STATISTICS *FlaseAlmCntBuddyAdapter;
 
-	if(BuddyAdapter == NULL)
+	if (BuddyAdapter == NULL)
 		return;
 
 	if (Adapter->DualMacConcurrent == false)
@@ -229,7 +229,7 @@ odm_FalseAlarmCounterStatistics(
 								falsealmcnt->Cnt_Crc8_fail + falsealmcnt->Cnt_Mcs_fail +
 								falsealmcnt->Cnt_Fast_Fsync + falsealmcnt->Cnt_SB_Search_fail;
 
-	if(pHalData->CurrentBandType92D != BAND_ON_5G)
+	if (pHalData->CurrentBandType92D != BAND_ON_5G)
 	{
 		//hold cck counter
 		//AcquireCCKAndRWPageAControl(Adapter);
@@ -257,7 +257,7 @@ odm_FalseAlarmCounterStatistics(
 						falsealmcnt->Cnt_Cck_fail);
 	Adapter->recvpriv.falsealmcnt_all = falsealmcnt->Cnt_all;
 #ifdef CONFIG_CONCURRENT_MODE
-	if(pbuddy_adapter)
+	if (pbuddy_adapter)
 		pbuddy_adapter->recvpriv.falsealmcnt_all = falsealmcnt->Cnt_all;
 #endif //CONFIG_CONCURRENT_MODE
 
@@ -267,7 +267,7 @@ odm_FalseAlarmCounterStatistics(
 	//update ofdm counter
 	PHY_SetBBReg(Adapter, rOFDM0_LSTF, BIT31, 0); //update page C counter
 	PHY_SetBBReg(Adapter, rOFDM1_LSTF, BIT31, 0); //update page D counter
-	if(pHalData->CurrentBandType92D != BAND_ON_5G) {
+	if (pHalData->CurrentBandType92D != BAND_ON_5G) {
 		//reset cck counter
 		PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, 0x0000c000, 0);
 		//enable cck counter
@@ -275,11 +275,11 @@ odm_FalseAlarmCounterStatistics(
 	}
 
 	//BB Reset
-	if(IS_HARDWARE_TYPE_8192D(Adapter))
+	if (IS_HARDWARE_TYPE_8192D(Adapter))
 	{
-		if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
-			if((pHalData->CurrentBandType92D == BAND_ON_2_4G) && pHalData->bMasterOfDMSP && (check_fwstate(pmlmepriv, _FW_LINKED) == false))
+			if ((pHalData->CurrentBandType92D == BAND_ON_2_4G) && pHalData->bMasterOfDMSP && (check_fwstate(pmlmepriv, _FW_LINKED) == false))
 			{
 				//before BB reset should do clock gated
 				rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
@@ -292,7 +292,7 @@ odm_FalseAlarmCounterStatistics(
 		}
 		else
 		{
-			if((pHalData->CurrentBandType92D == BAND_ON_2_4G) &&(check_fwstate(pmlmepriv, _FW_LINKED) == false)
+			if ((pHalData->CurrentBandType92D == BAND_ON_2_4G) &&(check_fwstate(pmlmepriv, _FW_LINKED) == false)
 #ifdef CONFIG_CONCURRENT_MODE
 				 && (check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == false)
 #endif //CONFIG_CONCURRENT_MODE
@@ -308,7 +308,7 @@ odm_FalseAlarmCounterStatistics(
 			}
 		}
 	}
-	else if(check_fwstate(pmlmepriv, _FW_LINKED) == false)
+	else if (check_fwstate(pmlmepriv, _FW_LINKED) == false)
 	{
 		//before BB reset should do clock gated
 		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
@@ -334,19 +334,19 @@ odm_FindMinimumRSSI_Dmsp(
 	struct rtw_adapter *	BuddyAdapter = pAdapter->pbuddy_adapter;
 	struct dm_priv	*Buddydmpriv;
 
-	if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+	if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 	{
-		if(BuddyAdapter!= NULL)
+		if (BuddyAdapter!= NULL)
 		{
 			Buddydmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
-			if(pHalData->bSlaveOfDMSP)
+			if (pHalData->bSlaveOfDMSP)
 			{
 				//DBG_8192D("bSlavecase of dmsp\n");
 				Buddydmpriv->RssiValMinForAnotherMacOfDMSP = pdmpriv->MinUndecoratedPWDBForDM;
 			}
 			else
 			{
-				if(bGetValueFromBuddyAdapter)
+				if (bGetValueFromBuddyAdapter)
 				{
 					//DBG_8192D("get new RSSI\n");
 					rest_rssi = true;
@@ -358,7 +358,7 @@ odm_FindMinimumRSSI_Dmsp(
 
 	}
 
-	if(rest_rssi)
+	if (rest_rssi)
 	{
 		rest_rssi = false;
 		pdmpriv->MinUndecoratedPWDBForDM = rssi_val_min_back_for_mac0;
@@ -376,15 +376,15 @@ struct rtw_adapter *	pAdapter
 	struct mlme_priv	*pmlmepriv = &pAdapter->mlmepriv;
 
 	//1 1.Determine the minimum RSSI
-	if((check_fwstate(pmlmepriv, _FW_LINKED) == false) &&
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == false) &&
 		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
 	{
 		pdmpriv->MinUndecoratedPWDBForDM = 0;
 		//RT_TRACE(COMP_BB_POWERSAVING, DBG_LOUD, ("Not connected to any \n"));
 	}
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == true)	// Default port
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)	// Default port
 	{
-		if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) ||
+		if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) ||
 			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
 			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
 		{
@@ -416,7 +416,7 @@ odm_initial_gain_MinPWDB(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	s32	rssi_val_min = 0;
-	if(pdmpriv->EntryMinUndecoratedSmoothedPWDB != 0)
+	if (pdmpriv->EntryMinUndecoratedSmoothedPWDB != 0)
 		rssi_val_min  =  (pdmpriv->EntryMinUndecoratedSmoothedPWDB > pdmpriv->UndecoratedSmoothedPWDB)?
 					pdmpriv->UndecoratedSmoothedPWDB:pdmpriv->EntryMinUndecoratedSmoothedPWDB;
 	else
@@ -440,10 +440,10 @@ DM_Write_DIG_DMSP(
 
 	//DBG_8192D(("curigvalue = 0x%x, preigvalue = 0x%x\n", dm_digtable->curigvalue, dm_digtable->preigvalue);
 
-	if(BuddyAdapter == NULL)
+	if (BuddyAdapter == NULL)
 	{
 		//DBG_8192D("DM_Write_DIG_DMSP(): not find buddyAdapter\n");
-		if(pHalData->bMasterOfDMSP)
+		if (pHalData->bMasterOfDMSP)
 		{
 			PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
 			PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
@@ -457,10 +457,10 @@ DM_Write_DIG_DMSP(
 	}
 
 	//DBG_8192D("bGetValueFromOtherMac %d \n",bGetValueFromOtherMac);
-	if(bGetValueFromOtherMac)
+	if (bGetValueFromOtherMac)
 	{
 		//DBG_8192D("DM_Write_DIG_DMSP(): mac 0 set mac 1 value \n");
-		if(pdmpriv->bWriteDigForAnotherMacOfDMSP)
+		if (pdmpriv->bWriteDigForAnotherMacOfDMSP)
 		{
 			pdmpriv->bWriteDigForAnotherMacOfDMSP = false;
 			PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, pdmpriv->CurDigValueForAnotherMacOfDMSP);
@@ -470,14 +470,14 @@ DM_Write_DIG_DMSP(
 
 	Buddydmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
 
-	if(dm_digtable->preigvalue != dm_digtable->curigvalue)
+	if (dm_digtable->preigvalue != dm_digtable->curigvalue)
 	{
 		// Set initial gain.
 		// 20100211 Joseph: Set only BIT0~BIT6 for DIG. BIT7 is the function switch of Antenna diversity.
 		// Just not to modified it for SD3 testing.
 		//PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, bMaskByte0, dm_digtable->curigvalue);
 		//PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, bMaskByte0, dm_digtable->curigvalue);
-		 if(pHalData->bSlaveOfDMSP)
+		 if (pHalData->bSlaveOfDMSP)
 		 {
 			//DBG_8192D("DM_Write_DIG_DMSP(): slave case \n");
 			Buddydmpriv->bWriteDigForAnotherMacOfDMSP = true;
@@ -486,7 +486,7 @@ DM_Write_DIG_DMSP(
 		else
 		{
 			//DBG_8192D("DM_Write_DIG_DMSP(): master case \n");
-			if(!bGetValueFromOtherMac)
+			if (!bGetValueFromOtherMac)
 			{
 				//DBG_8192D("DM_Write_DIG_DMSP(): mac 0 set mac 0 value \n");
 				PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
@@ -510,14 +510,14 @@ DM_Write_DIG(
 	if (dm_digtable->dig_enable_flag == false)
 		return;
 
-	if( (dm_digtable->preigvalue != dm_digtable->curigvalue) || ( pAdapter->bForceWriteInitGain ) )
+	if ( (dm_digtable->preigvalue != dm_digtable->curigvalue) || ( pAdapter->bForceWriteInitGain ) )
 	{
 		// Set initial gain.
 		// 20100211 Joseph: Set only BIT0~BIT6 for DIG. BIT7 is the function switch of Antenna diversity.
 		// Just not to modified it for SD3 testing.
 		PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
 		PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
-		if(dm_digtable->curigvalue != 0x17)
+		if (dm_digtable->curigvalue != 0x17)
 			dm_digtable->preigvalue = dm_digtable->curigvalue;
 	}
 }
@@ -547,11 +547,11 @@ static void odm_DIG(
 
 	//RT_TRACE(COMP_DIG, DBG_LOUD, ("odm_DIG() ==>\n"));
 
-	if(IS_HARDWARE_TYPE_8192D(pAdapter))
+	if (IS_HARDWARE_TYPE_8192D(pAdapter))
 	{
-		if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
-			if(pHalData->bMasterOfDMSP)
+			if (pHalData->bMasterOfDMSP)
 			{
 				DIG_Dynamic_MIN = DIG_Dynamic_MIN_0;
 				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_0 == false);
@@ -567,7 +567,7 @@ static void odm_DIG(
 		}
 		else
 		{
-			if(pHalData->CurrentBandType92D==BAND_ON_5G)
+			if (pHalData->CurrentBandType92D==BAND_ON_5G)
 			{
 				DIG_Dynamic_MIN = DIG_Dynamic_MIN_0;
 #ifdef CONFIG_CONCURRENT_MODE
@@ -614,14 +614,14 @@ static void odm_DIG(
 	//DBG_8192D("RX Rate =  0x%x, TX Rate = 0x%x \n", pHalData->RxRate, TxRate);
 
 #ifndef CONFIG_CONCURRENT_MODE
-	if(pdmpriv->bDMInitialGainEnable == false)
+	if (pdmpriv->bDMInitialGainEnable == false)
 		return;
 #endif //CONFIG_CONCURRENT_MODE
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG) || !(pbuddy_pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
+	if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG) || !(pbuddy_pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
 #else
-	if(!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
+	if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
 #endif //CONFIG_CONCURRENT_MODE
 		return;
 
@@ -634,25 +634,25 @@ static void odm_DIG(
 
 	//1 Boundary Decision
 #ifdef CONFIG_CONCURRENT_MODE
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
 #else
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == true)
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 #endif //CONFIG_CONCURRENT_MODE
 	{
 		//2 Get minimum RSSI value among associated devices
 		dm_digtable->rssi_val_min = odm_initial_gain_MinPWDB(pAdapter);
 
 		//2 Modify DIG upper bound
-		if((dm_digtable->rssi_val_min + 20) > DM_DIG_MAX )
+		if ((dm_digtable->rssi_val_min + 20) > DM_DIG_MAX )
 			dm_digtable->rx_gain_range_max = DM_DIG_MAX;
 		else
 			dm_digtable->rx_gain_range_max = dm_digtable->rssi_val_min + 20;
 		//2 Modify DIG lower bound
-		if((falsealmcnt->Cnt_all > 500)&&(DIG_Dynamic_MIN < 0x25))
+		if ((falsealmcnt->Cnt_all > 500)&&(DIG_Dynamic_MIN < 0x25))
 			DIG_Dynamic_MIN++;
-		if((falsealmcnt->Cnt_all < 500)&&(DIG_Dynamic_MIN > DM_DIG_MIN))
+		if ((falsealmcnt->Cnt_all < 500)&&(DIG_Dynamic_MIN > DM_DIG_MIN))
 			DIG_Dynamic_MIN--;
-		if((dm_digtable->rssi_val_min < 8) && (DIG_Dynamic_MIN > DM_DIG_MIN))
+		if ((dm_digtable->rssi_val_min < 8) && (DIG_Dynamic_MIN > DM_DIG_MIN))
 			DIG_Dynamic_MIN--;
 	} else {
 		dm_digtable->rx_gain_range_max = DM_DIG_MAX;
@@ -660,20 +660,20 @@ static void odm_DIG(
 	}
 
 	//1 Modify DIG lower bound, deal with abnorally large false alarm
-	if(falsealmcnt->Cnt_all > 10000)
+	if (falsealmcnt->Cnt_all > 10000)
 	{
 		//DBG_8192D("dm_DIG(): Abnornally false alarm case. \n");
 
 		dm_digtable->largefahit++;
-		if(dm_digtable->forbiddenigi < dm_digtable->curigvalue)
+		if (dm_digtable->forbiddenigi < dm_digtable->curigvalue)
 		{
 			dm_digtable->forbiddenigi = dm_digtable->curigvalue;
 			dm_digtable->largefahit = 1;
 		}
 
-		if(dm_digtable->largefahit >= 3)
+		if (dm_digtable->largefahit >= 3)
 		{
-			if((dm_digtable->forbiddenigi+1) >dm_digtable->rx_gain_range_max)
+			if ((dm_digtable->forbiddenigi+1) >dm_digtable->rx_gain_range_max)
 				dm_digtable->rx_gain_range_min = dm_digtable->rx_gain_range_max;
 			else
 				dm_digtable->rx_gain_range_min = (dm_digtable->forbiddenigi + 1);
@@ -684,13 +684,13 @@ static void odm_DIG(
 	else
 	{
 		//Recovery mechanism for IGI lower bound
-		if(dm_digtable->recover_cnt != 0)
+		if (dm_digtable->recover_cnt != 0)
 			dm_digtable->recover_cnt --;
 		else
 		{
-			if(dm_digtable->largefahit == 0 )
+			if (dm_digtable->largefahit == 0 )
 			{
-				if((dm_digtable->forbiddenigi -1) < DIG_Dynamic_MIN) //DM_DIG_MIN)
+				if ((dm_digtable->forbiddenigi -1) < DIG_Dynamic_MIN) //DM_DIG_MIN)
 				{
 					dm_digtable->forbiddenigi = DIG_Dynamic_MIN; //DM_DIG_MIN;
 					dm_digtable->rx_gain_range_min = DIG_Dynamic_MIN; //DM_DIG_MIN;
@@ -701,7 +701,7 @@ static void odm_DIG(
 					dm_digtable->rx_gain_range_min = (dm_digtable->forbiddenigi + 1);
 				}
 			}
-			else if(dm_digtable->largefahit == 3 )
+			else if (dm_digtable->largefahit == 3 )
 			{
 				dm_digtable->largefahit = 0;
 			}
@@ -711,27 +711,27 @@ static void odm_DIG(
 
 	//1 Adjust initial gain by false alarm
 #ifdef CONFIG_CONCURRENT_MODE
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
 #else
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == true)
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 #endif //CONFIG_CONCURRENT_MODE
 	{
-		if(FirstConnect) {
+		if (FirstConnect) {
 			dm_digtable->curigvalue = dm_digtable->rssi_val_min;
 		} else {
-			if(IS_HARDWARE_TYPE_8192D(pAdapter)) {
-				if(falsealmcnt->Cnt_all > DM_DIG_FA_TH2_92D)
+			if (IS_HARDWARE_TYPE_8192D(pAdapter)) {
+				if (falsealmcnt->Cnt_all > DM_DIG_FA_TH2_92D)
 					dm_digtable->curigvalue = dm_digtable->preigvalue+2;
 				else if (falsealmcnt->Cnt_all > DM_DIG_FA_TH1_92D)
 					dm_digtable->curigvalue = dm_digtable->preigvalue+1;
-				else if(falsealmcnt->Cnt_all < DM_DIG_FA_TH0_92D)
+				else if (falsealmcnt->Cnt_all < DM_DIG_FA_TH0_92D)
 					dm_digtable->curigvalue =dm_digtable->preigvalue-1;
 			} else {
-				if(falsealmcnt->Cnt_all > DM_DIG_FA_TH2)
+				if (falsealmcnt->Cnt_all > DM_DIG_FA_TH2)
 					dm_digtable->curigvalue = dm_digtable->preigvalue+2;
 				else if (falsealmcnt->Cnt_all > DM_DIG_FA_TH1)
 					dm_digtable->curigvalue = dm_digtable->preigvalue+1;
-				else if(falsealmcnt->Cnt_all < DM_DIG_FA_TH0)
+				else if (falsealmcnt->Cnt_all < DM_DIG_FA_TH0)
 					dm_digtable->curigvalue = dm_digtable->preigvalue-1;
 			}
 		}
@@ -756,10 +756,10 @@ static void odm_DIG(
 		dm_digtable->curigvalue = dm_digtable->rx_gain_range_min_nolink;
 	}
 	//1 Check initial gain by upper/lower bound
-	if(dm_digtable->curigvalue > dm_digtable->rx_gain_range_max)
+	if (dm_digtable->curigvalue > dm_digtable->rx_gain_range_max)
 		dm_digtable->curigvalue = dm_digtable->rx_gain_range_max;
 
-	if(dm_digtable->curigvalue < dm_digtable->rx_gain_range_min)
+	if (dm_digtable->curigvalue < dm_digtable->rx_gain_range_min)
 		dm_digtable->curigvalue = dm_digtable->rx_gain_range_min;
 
 	if ( pAdapter->bRxRSSIDisplay )
@@ -769,13 +769,13 @@ static void odm_DIG(
 			dm_digtable->rx_gain_range_max );
 	}
 
-	if(IS_HARDWARE_TYPE_8192D(pAdapter))
+	if (IS_HARDWARE_TYPE_8192D(pAdapter))
 	{
 		//sherry  delete DualMacSmartConncurrent 20110517
-		if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
 			DM_Write_DIG_DMSP(pAdapter);
-			if(pHalData->bMasterOfDMSP)
+			if (pHalData->bMasterOfDMSP)
 			{
 				bMediaConnect_0 = check_fwstate(pmlmepriv, _FW_LINKED);
 				DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
@@ -789,7 +789,7 @@ static void odm_DIG(
 		else
 		{
 			DM_Write_DIG(pAdapter);
-			if(pHalData->CurrentBandType92D==BAND_ON_5G)
+			if (pHalData->CurrentBandType92D==BAND_ON_5G)
 			{
 #ifdef CONFIG_CONCURRENT_MODE
 				bMediaConnect_0 = (check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED));
@@ -820,17 +820,17 @@ static void odm_DIG(
 		DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
 	}
 
-	if((pregistrypriv->lowrate_two_xmit) && IS_HARDWARE_TYPE_8192D(pAdapter) &&
+	if ((pregistrypriv->lowrate_two_xmit) && IS_HARDWARE_TYPE_8192D(pAdapter) &&
 		(pHalData->MacPhyMode92D != DUALMAC_DUALPHY) && (!pregistrypriv->special_rf_path))
 	{
 		//for Use 2 path Tx to transmit MCS0~7 and legacy mode
 #ifdef CONFIG_CONCURRENT_MODE
-		if(check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
 #else
-		if(check_fwstate(pmlmepriv, _FW_LINKED) == true)
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 #endif //CONFIG_CONCURRENT_MODE
 		{
-			if(dm_digtable->rssi_val_min  <= 30)   //low rate 2T2R settings
+			if (dm_digtable->rssi_val_min  <= 30)   //low rate 2T2R settings
 			{
 				//Reg90C=0x83321333 (OFDM 2T)
 				//RegA07=0xc1            (CCK 2T2R)
@@ -849,7 +849,7 @@ static void odm_DIG(
 				rtw_write8(pAdapter, 0xA75, 0x01);
 
 			}
-			else if(dm_digtable->rssi_val_min  >= 35)  //low rate 1T1R Settings
+			else if (dm_digtable->rssi_val_min  >= 35)  //low rate 1T1R Settings
 			{
 				//Reg90C=0x81121313
 				//RegA07=0x80
@@ -888,18 +888,18 @@ dm_initial_gain_MinPWDB(
 	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
 
 
-	if((dm_digtable->curmultistaconnectstate == DIG_MultiSTA_CONNECT) &&
+	if ((dm_digtable->curmultistaconnectstate == DIG_MultiSTA_CONNECT) &&
 	   (dm_digtable->curstaconnectstate == DIG_STA_CONNECT) ) {
-		if(pdmpriv->EntryMinUndecoratedSmoothedPWDB != 0)
+		if (pdmpriv->EntryMinUndecoratedSmoothedPWDB != 0)
 			rssi_val_min  =  (pdmpriv->EntryMinUndecoratedSmoothedPWDB > pdmpriv->UndecoratedSmoothedPWDB)?
 					pdmpriv->UndecoratedSmoothedPWDB:pdmpriv->EntryMinUndecoratedSmoothedPWDB;
 		else
 			rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
 	}
-	else if(	dm_digtable->curstaconnectstate == DIG_STA_CONNECT ||
+	else if (	dm_digtable->curstaconnectstate == DIG_STA_CONNECT ||
 			dm_digtable->curstaconnectstate == DIG_STA_BEFORE_CONNECT)
 		rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
-	else if(dm_digtable->curmultistaconnectstate == DIG_MultiSTA_CONNECT)
+	else if (dm_digtable->curmultistaconnectstate == DIG_MultiSTA_CONNECT)
 		rssi_val_min = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
 
 	return (u8)rssi_val_min;
@@ -920,18 +920,18 @@ static void dm_CCK_PacketDetectionThresh
 	//if (pAdapter->DualMacSmartConcurrent == false)
 	//	return;
 
-	if(dm_digtable->curstaconnectstate == DIG_STA_CONNECT)
+	if (dm_digtable->curstaconnectstate == DIG_STA_CONNECT)
 	{
 		dm_digtable->rssi_val_min = dm_initial_gain_MinPWDB(pAdapter);
-		if(dm_digtable->precckpdstate == CCK_PD_STAGE_LOWRSSI)
+		if (dm_digtable->precckpdstate == CCK_PD_STAGE_LOWRSSI)
 		{
-			if(dm_digtable->rssi_val_min <= 25)
+			if (dm_digtable->rssi_val_min <= 25)
 				dm_digtable->curcckpdstate = CCK_PD_STAGE_LOWRSSI;
 			else
 				dm_digtable->curcckpdstate = CCK_PD_STAGE_HIGHRSSI;
 		}
 		else{
-			if(dm_digtable->rssi_val_min <= 20)
+			if (dm_digtable->rssi_val_min <= 20)
 				dm_digtable->curcckpdstate = CCK_PD_STAGE_LOWRSSI;
 			else
 				dm_digtable->curcckpdstate = CCK_PD_STAGE_HIGHRSSI;
@@ -940,13 +940,13 @@ static void dm_CCK_PacketDetectionThresh
 	else
 		dm_digtable->curcckpdstate=CCK_PD_STAGE_MAX;
 
-	if(bGetValueFromBuddyAdapter)
+	if (bGetValueFromBuddyAdapter)
 	{
 		DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): mac 1 connect,mac 0 disconnect case  \n");
-		if(pdmpriv->bChangeCCKPDStateForAnotherMacOfDMSP)
+		if (pdmpriv->bChangeCCKPDStateForAnotherMacOfDMSP)
 		{
 			DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): mac 0 set for mac1 \n");
-			if(pdmpriv->curcckpdstateForAnotherMacOfDMSP == CCK_PD_STAGE_LOWRSSI)
+			if (pdmpriv->curcckpdstateForAnotherMacOfDMSP == CCK_PD_STAGE_LOWRSSI)
 			{
 				//AcquireCCKAndRWPageAControl(pAdapter);
 				//RT_TRACE(COMP_INIT,DBG_LOUD,("Acquiere mutex in dm_cck_packetdetection \n"));
@@ -954,7 +954,7 @@ static void dm_CCK_PacketDetectionThresh
 				//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_cck_packetdetection \n"));
 				//ReleaseCCKAndRWPageAControl(pAdapter);
 				//PHY_SetBBReg(pAdapter, rCCK0_System, bMaskByte1, 0x40);
-				//if(IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
+				//if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
 					//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , maskbyte2, 0xd7);
 			}
 			else
@@ -966,25 +966,25 @@ static void dm_CCK_PacketDetectionThresh
 				//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_cck_packetdetection \n"));
 
 				//PHY_SetBBReg(pAdapter,rCCK0_System, bMaskByte1, 0x47);
-				//if(IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
+				//if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
 					//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , maskbyte2, 0xd3);
 			}
 			pdmpriv->bChangeCCKPDStateForAnotherMacOfDMSP = false;
 		}
 	}
 
-	if(dm_digtable->precckpdstate != dm_digtable->curcckpdstate)
+	if (dm_digtable->precckpdstate != dm_digtable->curcckpdstate)
 	{
-		if(BuddyAdapter == NULL)
+		if (BuddyAdapter == NULL)
 		{
 			DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): BuddyAdapter == NULL case \n");
-			if(pHalData->bSlaveOfDMSP)
+			if (pHalData->bSlaveOfDMSP)
 			{
 				dm_digtable->precckpdstate = dm_digtable->curcckpdstate;
 			}
 			else
 			{
-				if(dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
+				if (dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
 				{
 					//AcquireCCKAndRWPageAControl(pAdapter);
 					//RT_TRACE(COMP_INIT,DBG_LOUD,("Acquiere mutex in dm_cck_packetdetection \n"));
@@ -992,7 +992,7 @@ static void dm_CCK_PacketDetectionThresh
 					//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_cck_packetdetection \n"));
 					//ReleaseCCKAndRWPageAControl(pAdapter);
 					//PHY_SetBBReg(pAdapter, rCCK0_System, bMaskByte1, 0x40);
-					//if(IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
+					//if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
 						//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , maskbyte2, 0xd7);
 				}
 				else
@@ -1004,7 +1004,7 @@ static void dm_CCK_PacketDetectionThresh
 					//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_cck_packetdetection \n"));
 
 					//PHY_SetBBReg(pAdapter,rCCK0_System, bMaskByte1, 0x47);
-					//if(IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
+					//if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
 						//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , maskbyte2, 0xd3);
 				}
 				dm_digtable->precckpdstate = dm_digtable->curcckpdstate;
@@ -1012,7 +1012,7 @@ static void dm_CCK_PacketDetectionThresh
 			return;
 		}
 
-		if(pHalData->bSlaveOfDMSP)
+		if (pHalData->bSlaveOfDMSP)
 		{
 			Buddydmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
 			DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): bslave case \n");
@@ -1021,10 +1021,10 @@ static void dm_CCK_PacketDetectionThresh
 		}
 		else
 		{
-			if(!bGetValueFromBuddyAdapter)
+			if (!bGetValueFromBuddyAdapter)
 			{
 				DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): mac 0 set for mac0 \n");
-				if(dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
+				if (dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
 				{
 					//AcquireCCKAndRWPageAControl(pAdapter);
 					//RT_TRACE(COMP_INIT,DBG_LOUD,("Acquiere mutex in dm_cck_packetdetection \n"));
@@ -1032,7 +1032,7 @@ static void dm_CCK_PacketDetectionThresh
 					//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_cck_packetdetection \n"));
 					//ReleaseCCKAndRWPageAControl(pAdapter);
 					//PHY_SetBBReg(pAdapter, rCCK0_System, bMaskByte1, 0x40);
-					//if(IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
+					//if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
 						//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , maskbyte2, 0xd7);
 				}
 				else
@@ -1044,7 +1044,7 @@ static void dm_CCK_PacketDetectionThresh
 					//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_cck_packetdetection \n"));
 
 					//PHY_SetBBReg(pAdapter,rCCK0_System, bMaskByte1, 0x47);
-					//if(IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
+					//if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
 						//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , maskbyte2, 0xd3);
 				}
 			}
@@ -1063,14 +1063,14 @@ static void dm_CCK_PacketDetectionThresh
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
 
-	if(dm_digtable->curstaconnectstate == DIG_STA_CONNECT) {
-		if(dm_digtable->precckpdstate == CCK_PD_STAGE_LOWRSSI) {
-			if(pdmpriv->MinUndecoratedPWDBForDM <= 25)
+	if (dm_digtable->curstaconnectstate == DIG_STA_CONNECT) {
+		if (dm_digtable->precckpdstate == CCK_PD_STAGE_LOWRSSI) {
+			if (pdmpriv->MinUndecoratedPWDBForDM <= 25)
 				dm_digtable->curcckpdstate = CCK_PD_STAGE_LOWRSSI;
 			else
 				dm_digtable->curcckpdstate = CCK_PD_STAGE_HIGHRSSI;
 		} else {
-			if(pdmpriv->MinUndecoratedPWDBForDM <= 20)
+			if (pdmpriv->MinUndecoratedPWDBForDM <= 20)
 				dm_digtable->curcckpdstate = CCK_PD_STAGE_LOWRSSI;
 			else
 				dm_digtable->curcckpdstate = CCK_PD_STAGE_HIGHRSSI;
@@ -1079,8 +1079,8 @@ static void dm_CCK_PacketDetectionThresh
 		dm_digtable->curcckpdstate=CCK_PD_STAGE_LOWRSSI;
 	}
 
-	if(dm_digtable->precckpdstate != dm_digtable->curcckpdstate) {
-		if(dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
+	if (dm_digtable->precckpdstate != dm_digtable->curcckpdstate) {
+		if (dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
 			PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0x83);
 		else
 			PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0xcd);
@@ -1096,20 +1096,20 @@ static void dm_1R_CCA(struct rtw_adapter
 	struct PS_T *dm_pstable = &pdmpriv->DM_PSTable;
 	struct registry_priv *pregistrypriv = &pAdapter->registrypriv;
 
-      if(pHalData->CurrentBandType92D == BAND_ON_5G)
+      if (pHalData->CurrentBandType92D == BAND_ON_5G)
       {
-		if(pdmpriv->MinUndecoratedPWDBForDM != 0)
+		if (pdmpriv->MinUndecoratedPWDBForDM != 0)
 		{
-			if(dm_pstable->preccastate == CCA_2R || dm_pstable->preccastate == CCA_MAX)
+			if (dm_pstable->preccastate == CCA_2R || dm_pstable->preccastate == CCA_MAX)
 			{
-				if(pdmpriv->MinUndecoratedPWDBForDM >= 35)
+				if (pdmpriv->MinUndecoratedPWDBForDM >= 35)
 					dm_pstable->curccastate = CCA_1R;
 				else
 					dm_pstable->curccastate = CCA_2R;
 
 			}
 			else{
-				if(pdmpriv->MinUndecoratedPWDBForDM <= 30)
+				if (pdmpriv->MinUndecoratedPWDBForDM <= 30)
 					dm_pstable->curccastate = CCA_2R;
 				else
 					dm_pstable->curccastate = CCA_1R;
@@ -1120,15 +1120,15 @@ static void dm_1R_CCA(struct rtw_adapter
 			dm_pstable->curccastate=CCA_MAX;
 		}
 
-		if(dm_pstable->preccastate != dm_pstable->curccastate)
+		if (dm_pstable->preccastate != dm_pstable->curccastate)
 		{
-			if(dm_pstable->curccastate == CCA_1R)
+			if (dm_pstable->curccastate == CCA_1R)
 			{
-				if(pHalData->rf_type == RF_2T2R)
+				if (pHalData->rf_type == RF_2T2R)
 				{
-					if(pregistrypriv->special_rf_path == 1) // path A only
+					if (pregistrypriv->special_rf_path == 1) // path A only
 						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
-					else if(pregistrypriv->special_rf_path == 2) //path B only
+					else if (pregistrypriv->special_rf_path == 2) //path B only
 						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
 					else
 						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x13);
@@ -1136,18 +1136,18 @@ static void dm_1R_CCA(struct rtw_adapter
 				}
 				else
 				{
-					if(pregistrypriv->special_rf_path == 1) // path A only
+					if (pregistrypriv->special_rf_path == 1) // path A only
 						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
-					else if(pregistrypriv->special_rf_path == 2) //path B only
+					else if (pregistrypriv->special_rf_path == 2) //path B only
 						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
 					else
 						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x23);
 					//PHY_SetBBReg(pAdapter, 0xe70, 0x7fc00000, 0x10c); // Set RegE70[30:22] = 9b'100001100
 				}
 			} else if (dm_pstable->curccastate == CCA_2R || dm_pstable->curccastate == CCA_MAX) {
-				if(pregistrypriv->special_rf_path == 1) // path A only
+				if (pregistrypriv->special_rf_path == 1) // path A only
 					PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
-				else if(pregistrypriv->special_rf_path == 2) //path B only
+				else if (pregistrypriv->special_rf_path == 2) //path B only
 					PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
 				else
 					PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x33);
@@ -1183,7 +1183,7 @@ static void odm_DynamicTxPower_92D(struc
 #endif
 
 	// If dynamic high power is disabled.
-	if( (pdmpriv->bDynamicTxPowerEnable != true) ||
+	if ( (pdmpriv->bDynamicTxPowerEnable != true) ||
 		(!(pdmpriv->DMFlag & DYNAMIC_FUNC_HP)) )
 	{
 		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
@@ -1191,7 +1191,7 @@ static void odm_DynamicTxPower_92D(struc
 	}
 
 	// STA not connected and AP not connected
-	if((check_fwstate(pmlmepriv, _FW_LINKED) != true) &&
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) != true) &&
 		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
 	{
 		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("Not connected to any \n"));
@@ -1204,7 +1204,7 @@ static void odm_DynamicTxPower_92D(struc
 		return;
 	}
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == true)	// Default port
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)	// Default port
 	{
 		//todo: AP Mode
 		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
@@ -1225,19 +1225,19 @@ static void odm_DynamicTxPower_92D(struc
 		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
 	}
 
-	if(pHalData->CurrentBandType92D == BAND_ON_5G){
-		if(UndecoratedSmoothedPWDB >= 0x33)
+	if (pHalData->CurrentBandType92D == BAND_ON_5G){
+		if (UndecoratedSmoothedPWDB >= 0x33)
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
 			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level2 (TxPwr=0x0)\n"));
 		}
-		else if((UndecoratedSmoothedPWDB <0x33) &&
+		else if ((UndecoratedSmoothedPWDB <0x33) &&
 			(UndecoratedSmoothedPWDB >= 0x2b) )
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
 			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
 		}
-		else if(UndecoratedSmoothedPWDB < 0x2b)
+		else if (UndecoratedSmoothedPWDB < 0x2b)
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
 			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Normal\n"));
@@ -1245,18 +1245,18 @@ static void odm_DynamicTxPower_92D(struc
 	}
 	else
 	{
-		if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
+		if (UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
 			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
 		}
-		else if((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
+		else if ((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
 			(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
 			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
 		}
-		else if(UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
+		else if (UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
 			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
@@ -1264,10 +1264,10 @@ static void odm_DynamicTxPower_92D(struc
 	}
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(bGetValueFromBuddyAdapter)
+	if (bGetValueFromBuddyAdapter)
 	{
 		DBG_8192D("dm_DynamicTxPower() mac 0 for mac 1 \n");
-		if(pdmpriv->bChangeTxHighPowerLvlForAnotherMacOfDMSP)
+		if (pdmpriv->bChangeTxHighPowerLvlForAnotherMacOfDMSP)
 		{
 			DBG_8192D("dm_DynamicTxPower() change value \n");
 			HighPowerLvlBackForMac0 = pdmpriv->DynamicTxHighPowerLvl;
@@ -1279,26 +1279,26 @@ static void odm_DynamicTxPower_92D(struc
 	}
 #endif
 
-	if( (pdmpriv->DynamicTxHighPowerLvl != pdmpriv->LastDTPLvl) )
+	if ( (pdmpriv->DynamicTxHighPowerLvl != pdmpriv->LastDTPLvl) )
 	{
 		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192D() Channel = %d \n" , pHalData->CurrentChannel));
 #ifdef CONFIG_DUALMAC_CONCURRENT
-		if(Adapter->DualMacConcurrent == true)
+		if (Adapter->DualMacConcurrent == true)
 		{
-			if(BuddyAdapter == NULL)
+			if (BuddyAdapter == NULL)
 			{
 				DBG_8192D("dm_DynamicTxPower() BuddyAdapter == NULL case \n");
-				if(!pHalData->bSlaveOfDMSP)
+				if (!pHalData->bSlaveOfDMSP)
 				{
 					PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
 				}
 			}
 			else
 			{
-				if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+				if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 				{
 					DBG_8192D("dm_DynamicTxPower() BuddyAdapter DMSP \n");
-					if(pHalData->bSlaveOfDMSP)
+					if (pHalData->bSlaveOfDMSP)
 					{
 						DBG_8192D("dm_DynamicTxPower() bslave case  \n");
 						pbuddy_dmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
@@ -1308,7 +1308,7 @@ static void odm_DynamicTxPower_92D(struc
 					else
 					{
 						DBG_8192D("dm_DynamicTxPower() master case  \n");
-						if(!bGetValueFromBuddyAdapter)
+						if (!bGetValueFromBuddyAdapter)
 						{
 							DBG_8192D("dm_DynamicTxPower() mac 0 for mac 0 \n");
 							PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
@@ -1345,7 +1345,7 @@ static void PWDB_Monitor(
 	u32	PWDB_rssi[NUM_STA]={0};//[0~15]:MACID, [16~31]:PWDB_rssi
 
 
-	if(check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
+	if (check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
 	{
 		struct list_head *plist, *phead;
 		struct sta_info *psta;
@@ -1365,17 +1365,17 @@ static void PWDB_Monitor(
 
 				plist = get_next(plist);
 
-				if(_rtw_memcmp(psta	->hwaddr, bcast_addr, ETH_ALEN) ||
+				if (_rtw_memcmp(psta	->hwaddr, bcast_addr, ETH_ALEN) ||
 					_rtw_memcmp(psta->hwaddr, myid(&Adapter->eeprompriv), ETH_ALEN))
 					continue;
 
-				if(psta->state & WIFI_ASOC_STATE)
+				if (psta->state & WIFI_ASOC_STATE)
 				{
 
-					if(psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
+					if (psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
 						tmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
 
-					if(psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
+					if (psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
 						tmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
 
 					PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16) | ((Adapter->stapriv.asoc_sta_count+1) << 8));
@@ -1385,7 +1385,7 @@ static void PWDB_Monitor(
 
 		spin_unlock_bh(&pstapriv->sta_hash_lock);
 
-		if(pHalData->fw_ractrl == true)
+		if (pHalData->fw_ractrl == true)
 		{
 			// Report every sta's RSSI to FW
 			for(i=0; i< sta_cnt; i++)
@@ -1396,7 +1396,7 @@ static void PWDB_Monitor(
 	}
 
 
-	if(tmpEntryMaxPWDB != 0)	// If associated entry is found
+	if (tmpEntryMaxPWDB != 0)	// If associated entry is found
 	{
 		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;
 	}
@@ -1405,7 +1405,7 @@ static void PWDB_Monitor(
 		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = 0;
 	}
 
-	if(tmpEntryMinPWDB != 0xff) // If associated entry is found
+	if (tmpEntryMinPWDB != 0xff) // If associated entry is found
 	{
 		pdmpriv->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;
 	}
@@ -1414,11 +1414,11 @@ static void PWDB_Monitor(
 		pdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
 	}
 
-	if(check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == true
+	if (check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == true
 		&& check_fwstate(&Adapter->mlmepriv, _FW_LINKED) == true)
 	{
 		// Indicate Rx signal strength to FW.
-		if(pHalData->fw_ractrl == true)
+		if (pHalData->fw_ractrl == true)
 		{
 			u32	temp = 0;
 			//DBG_8192D("RxSS: %lx =%ld\n", pdmpriv->UndecoratedSmoothedPWDB, pdmpriv->UndecoratedSmoothedPWDB);
@@ -1472,7 +1472,7 @@ static void dm_CheckEdcaTurbo(struct rtw
 	struct mlme_ext_priv *pmlmeext = &(Adapter->mlmeextpriv);
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	if(IS_92D_SINGLEPHY(pHalData->VersionID))
+	if (IS_92D_SINGLEPHY(pHalData->VersionID))
 	{
 		EDCA_BE[UP_LINK] = 0x5ea42b;
 		EDCA_BE[DOWN_LINK] = 0x5ea42b;
@@ -1494,13 +1494,13 @@ static void dm_CheckEdcaTurbo(struct rtw
 	}
 
 	// Check if the status needs to be changed.
-	if((bbtchange) || (!precvpriv->bIsAnyNonBEPkts) )
+	if ((bbtchange) || (!precvpriv->bIsAnyNonBEPkts) )
 	{
 		cur_tx_bytes = pxmitpriv->tx_bytes - pxmitpriv->last_tx_bytes;
 		cur_rx_bytes = precvpriv->rx_bytes - precvpriv->last_rx_bytes;
 
 		//traffic, TX or RX
-		if((pmlmeinfo->assoc_AP_vendor == ralinkAP)||(pmlmeinfo->assoc_AP_vendor == atherosAP))
+		if ((pmlmeinfo->assoc_AP_vendor == ralinkAP)||(pmlmeinfo->assoc_AP_vendor == atherosAP))
 		{
 			if (cur_tx_bytes > (cur_rx_bytes << 2))
 			{ // Uplink TP is present.
@@ -1526,22 +1526,22 @@ static void dm_CheckEdcaTurbo(struct rtw
 		if ((pdmpriv->prv_traffic_idx != trafficIndex) || (!pHalData->bCurrentTurboEDCA))
 		{
 			{
-				if((pmlmeinfo->assoc_AP_vendor == ciscoAP) && (pmlmeext->cur_wireless_mode & (WIRELESS_11_24N)))
+				if ((pmlmeinfo->assoc_AP_vendor == ciscoAP) && (pmlmeext->cur_wireless_mode & (WIRELESS_11_24N)))
 				{
 					edca_param = EDCAParam[pmlmeinfo->assoc_AP_vendor][trafficIndex];
 				}
-				else if((pmlmeinfo->assoc_AP_vendor == airgocapAP) &&
+				else if ((pmlmeinfo->assoc_AP_vendor == airgocapAP) &&
 					((pmlmeext->cur_wireless_mode == WIRELESS_11G) ||(pmlmeext->cur_wireless_mode == WIRELESS_11BG)))
 				{
-					if(trafficIndex == DOWN_LINK)
+					if (trafficIndex == DOWN_LINK)
 						edca_param = 0xa630;
 					else
 						edca_param = EDCA_BE[trafficIndex];
 				}
-				else if( (pmlmeinfo->assoc_AP_vendor == atherosAP) &&
+				else if ( (pmlmeinfo->assoc_AP_vendor == atherosAP) &&
 					(pmlmeext->cur_wireless_mode&WIRELESS_11_5N) )
 				{
-					if(trafficIndex == DOWN_LINK)
+					if (trafficIndex == DOWN_LINK)
 						edca_param = 0xa42b;
 					else
 						edca_param = EDCA_BE[trafficIndex];
@@ -1565,7 +1565,7 @@ static void dm_CheckEdcaTurbo(struct rtw
 		// Turn Off EDCA turbo here.
 		// Restore original EDCA according to the declaration of AP.
 		//
-		 if(pHalData->bCurrentTurboEDCA)
+		 if (pHalData->bCurrentTurboEDCA)
 		{
 			rtw_write32(Adapter, REG_EDCA_BE_PARAM, pHalData->AcParam_BE);
 			pHalData->bCurrentTurboEDCA = false;
@@ -1602,10 +1602,10 @@ struct rtw_adapter *	pAdapter
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 
 	//1 Power Saving for 92C
-	if(IS_92D_SINGLEPHY(pHalData->VersionID))
+	if (IS_92D_SINGLEPHY(pHalData->VersionID))
 	{
 #ifdef CONFIG_DUALMAC_CONCURRENT
-		if(!pHalData->bSlaveOfDMSP)
+		if (!pHalData->bSlaveOfDMSP)
 #endif
 			dm_1R_CCA(pAdapter);
 	}
@@ -1694,9 +1694,9 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 	pdmpriv->TXPowerTrackingCallbackCnt++;	//cosa add for debug
 	pdmpriv->bTXPowerTrackingInit = true;
 
-	if(pHalData->CurrentChannel == 14 && !pdmpriv->bCCKinCH14)
+	if (pHalData->CurrentChannel == 14 && !pdmpriv->bCCKinCH14)
 		pdmpriv->bCCKinCH14 = true;
-	else if(pHalData->CurrentChannel != 14 && pdmpriv->bCCKinCH14)
+	else if (pHalData->CurrentChannel != 14 && pdmpriv->bCCKinCH14)
 		pdmpriv->bCCKinCH14 = false;
 
 	//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("===>dm_TXPowerTrackingCallback_ThermalMeter_92D interface %d txpowercontrol %d\n", pHalData->interfaceIndex, pdmpriv->TxPowerTrackControl));
@@ -1707,23 +1707,23 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 
 	rtl8192d_PHY_APCalibrate(Adapter, (ThermalValue - pHalData->EEPROMThermalMeter));//notes:EEPROMThermalMeter is a fixed value from efuse/eeprom
 
-//	if(!pHalData->TxPowerTrackControl)
+//	if (!pHalData->TxPowerTrackControl)
 //		return;
 
-	if(is2T)
+	if (is2T)
 		rf = 2;
 	else
 		rf = 1;
 
-	if(ThermalValue)
+	if (ThermalValue)
 	{
-//		if(!pHalData->ThermalValue)
+//		if (!pHalData->ThermalValue)
 		{
 			//Query OFDM path A default setting
 			ele_D = PHY_QueryBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord)&bMaskOFDM_D;
 			for(i=0; i<OFDM_TABLE_SIZE_92D; i++)	//find the index
 			{
-				if(ele_D == (OFDMSwingTable[i]&bMaskOFDM_D))
+				if (ele_D == (OFDMSwingTable[i]&bMaskOFDM_D))
 				{
 					OFDM_index_old[0] = (u8)i;
 					//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Initial pathA ele_D reg0x%x = 0x%lx, OFDM_index=0x%x\n",
@@ -1733,12 +1733,12 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 			}
 
 			//Query OFDM path B default setting
-			if(is2T)
+			if (is2T)
 			{
 				ele_D = PHY_QueryBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord)&bMaskOFDM_D;
 				for(i=0; i<OFDM_TABLE_SIZE_92D; i++)	//find the index
 				{
-					if(ele_D == (OFDMSwingTable[i]&bMaskOFDM_D))
+					if (ele_D == (OFDMSwingTable[i]&bMaskOFDM_D))
 					{
 						OFDM_index_old[1] = (u8)i;
 						//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Initial pathB ele_D reg0x%x = 0x%lx, OFDM_index=0x%x\n",
@@ -1748,16 +1748,16 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 				}
 			}
 
-			if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 			{
 				//Query CCK default setting From 0xa24
 				TempCCk = pdmpriv->RegA24;
 
 				for(i=0 ; i<CCK_TABLE_SIZE ; i++)
 				{
-					if(pdmpriv->bCCKinCH14)
+					if (pdmpriv->bCCKinCH14)
 					{
-						if(_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch14[i][2], 4)==true)
+						if (_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch14[i][2], 4)==true)
 						{
 							CCK_index_old =(u8)i;
 							//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Initial reg0x%x = 0x%lx, CCK_index=0x%x, ch 14 %d\n",
@@ -1767,7 +1767,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 					}
 					else
 					{
-						if(_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch1_Ch13[i][2], 4)==true)
+						if (_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch1_Ch13[i][2], 4)==true)
 						{
 							CCK_index_old =(u8)i;
 							//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Initial reg0x%x = 0x%lx, CCK_index=0x%x, ch14 %d\n",
@@ -1783,7 +1783,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 				CCK_index_old = 12;
 			}
 
-			if(!pdmpriv->ThermalValue)
+			if (!pdmpriv->ThermalValue)
 			{
 				pdmpriv->ThermalValue = pHalData->EEPROMThermalMeter;
 				pdmpriv->ThermalValue_LCK = ThermalValue;
@@ -1795,7 +1795,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 				pdmpriv->CCK_index = CCK_index_old;
 			}
 
-			if(pdmpriv->bReloadtxpowerindex)
+			if (pdmpriv->bReloadtxpowerindex)
 			{
 				DBG_8192D("reload ofdm index for band switch\n");
 			}
@@ -1804,30 +1804,30 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 			{
 				pdmpriv->ThermalValue_AVG[pdmpriv->ThermalValue_AVG_index] = ThermalValue;
 				pdmpriv->ThermalValue_AVG_index++;
-				if(pdmpriv->ThermalValue_AVG_index == AVG_THERMAL_NUM)
+				if (pdmpriv->ThermalValue_AVG_index == AVG_THERMAL_NUM)
 					pdmpriv->ThermalValue_AVG_index = 0;
 
 				for(i = 0; i < AVG_THERMAL_NUM; i++)
 				{
-					if(pdmpriv->ThermalValue_AVG[i])
+					if (pdmpriv->ThermalValue_AVG[i])
 					{
 						ThermalValue_AVG += pdmpriv->ThermalValue_AVG[i];
 						ThermalValue_AVG_count++;
 					}
 				}
 
-				if(ThermalValue_AVG_count)
+				if (ThermalValue_AVG_count)
 					ThermalValue = (u8)(ThermalValue_AVG / ThermalValue_AVG_count);
 			}
 		}
 
-		if(pdmpriv->bReloadtxpowerindex)
+		if (pdmpriv->bReloadtxpowerindex)
 		{
 			delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);
 			pdmpriv->bReloadtxpowerindex = false;
 			pdmpriv->bDoneTxpower = false;
 		}
-		else if(pdmpriv->bDoneTxpower)
+		else if (pdmpriv->bDoneTxpower)
 		{
 			delta = (ThermalValue > pdmpriv->ThermalValue)?(ThermalValue - pdmpriv->ThermalValue):(pdmpriv->ThermalValue - ThermalValue);
 		}
@@ -1842,28 +1842,28 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 		//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("interface %d Readback Thermal Meter = 0x%lx pre thermal meter 0x%lx EEPROMthermalmeter 0x%lx delta 0x%lx delta_LCK 0x%lx delta_IQK 0x%lx delta_RxGain 0x%lx\n",  pHalData->interfaceIndex, ThermalValue, pdmpriv->ThermalValue, pHalData->EEPROMThermalMeter, delta, delta_LCK, delta_IQK, delta_RxGain));
 		//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("interface %d pre thermal meter LCK 0x%lx pre thermal meter IQK 0x%lx delta_LCK_bound 0x%lx delta_IQK_bound 0x%lx\n",  pHalData->interfaceIndex, pdmpriv->ThermalValue_LCK, pdmpriv->ThermalValue_IQK, pdmpriv->Delta_LCK, pdmpriv->Delta_IQK));
 
-		if((delta_LCK > pdmpriv->Delta_LCK) && (pdmpriv->Delta_LCK != 0))
+		if ((delta_LCK > pdmpriv->Delta_LCK) && (pdmpriv->Delta_LCK != 0))
 		{
 			pdmpriv->ThermalValue_LCK = ThermalValue;
 			rtl8192d_PHY_LCCalibrate(Adapter);
 		}
 
-		if(delta > 0 && pdmpriv->TxPowerTrackControl)
+		if (delta > 0 && pdmpriv->TxPowerTrackControl)
 		{
 			delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);
 
 			//calculate new OFDM / CCK offset
 			{
-				if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 				{
 					offset = 4;
 
-					if(delta > index_mapping_NUM-1)
+					if (delta > index_mapping_NUM-1)
 						index = index_mapping[offset][index_mapping_NUM-1];
 					else
 						index = index_mapping[offset][delta];
 
-					if(ThermalValue > pHalData->EEPROMThermalMeter)
+					if (ThermalValue > pHalData->EEPROMThermalMeter)
 					{
 						for(i = 0; i < rf; i++)
 							OFDM_index[i] = pdmpriv->OFDM_index[i] -delta;
@@ -1876,55 +1876,55 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 						CCK_index = pdmpriv->CCK_index + index;
 					}
 				}
-				else if(pHalData->CurrentBandType92D == BAND_ON_5G)
+				else if (pHalData->CurrentBandType92D == BAND_ON_5G)
 				{
 					for(i = 0; i < rf; i++)
 					{
-						if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY &&
+						if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY &&
 							pHalData->interfaceIndex == 1)		//MAC 1 5G
 							bInteralPA = pHalData->InternalPA5G[1];
 						else
 							bInteralPA = pHalData->InternalPA5G[i];
 
-						if(bInteralPA)
+						if (bInteralPA)
 						{
-							if(pHalData->interfaceIndex == 1 || i == rf)
+							if (pHalData->interfaceIndex == 1 || i == rf)
 								offset = 4;
 							else
 								offset = 0;
 
-							if(pHalData->CurrentChannel >= 100 && pHalData->CurrentChannel <= 165)
+							if (pHalData->CurrentChannel >= 100 && pHalData->CurrentChannel <= 165)
 								offset += 2;
 						}
 						else
 						{
-							if(pHalData->interfaceIndex == 1 || i == rf)
+							if (pHalData->interfaceIndex == 1 || i == rf)
 								offset = 2;
 							else
 								offset = 0;
 						}
 
-						if(ThermalValue > pHalData->EEPROMThermalMeter)	//set larger Tx power
+						if (ThermalValue > pHalData->EEPROMThermalMeter)	//set larger Tx power
 							offset++;
 
-						if(bInteralPA)
+						if (bInteralPA)
 						{
-							if(delta > index_mapping_NUM-1)
+							if (delta > index_mapping_NUM-1)
 								index = index_mapping_internalPA[offset][index_mapping_NUM-1];
 							else
 								index = index_mapping_internalPA[offset][delta];
 						}
 						else
 						{
-							if(delta > index_mapping_NUM-1)
+							if (delta > index_mapping_NUM-1)
 								index = index_mapping[offset][index_mapping_NUM-1];
 							else
 								index = index_mapping[offset][delta];
 						}
 
-						if(ThermalValue > pHalData->EEPROMThermalMeter)	//set larger Tx power
+						if (ThermalValue > pHalData->EEPROMThermalMeter)	//set larger Tx power
 						{
-							if(bInteralPA && ThermalValue > 0x12)
+							if (bInteralPA && ThermalValue > 0x12)
 							{
 								OFDM_index[i] = pdmpriv->OFDM_index[i] -((delta/2)*3+(delta%2));
 							}
@@ -1940,7 +1940,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 					}
 				}
 
-				/*if(is2T)
+				/*if (is2T)
 				{
 					DBG_8192D("temp OFDM_A_index=0x%x, OFDM_B_index=0x%x, CCK_index=0x%x\n",
 						pdmpriv->OFDM_index[0], pdmpriv->OFDM_index[1], pdmpriv->CCK_index);
@@ -1953,11 +1953,11 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 
 				for(i = 0; i < rf; i++)
 				{
-					if(OFDM_index[i] > OFDM_TABLE_SIZE_92D-1)
+					if (OFDM_index[i] > OFDM_TABLE_SIZE_92D-1)
 					{
 						OFDM_index[i] = OFDM_TABLE_SIZE_92D-1;
 					}
-					else if(bInteralPA || pHalData->CurrentBandType92D == BAND_ON_2_4G)
+					else if (bInteralPA || pHalData->CurrentBandType92D == BAND_ON_2_4G)
 					{
 						if (OFDM_index[i] < OFDM_min_index_internalPA)
 							OFDM_index[i] = OFDM_min_index_internalPA;
@@ -1968,15 +1968,15 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 					}
 				}
 
-				if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 				{
-					if(CCK_index > CCK_TABLE_SIZE-1)
+					if (CCK_index > CCK_TABLE_SIZE-1)
 						CCK_index = CCK_TABLE_SIZE-1;
 					else if (CCK_index < 0)
 						CCK_index = 0;
 				}
 
-				/*if(is2T)
+				/*if (is2T)
 				{
 					DBG_8192D("new OFDM_A_index=0x%x, OFDM_B_index=0x%x, CCK_index=0x%x\n",
 						OFDM_index[0], OFDM_index[1], CCK_index);
@@ -1989,7 +1989,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 			}
 
 			//Config by SwingTable
-			if(pdmpriv->TxPowerTrackControl && !pHalData->bNOPG)
+			if (pdmpriv->TxPowerTrackControl && !pHalData->bNOPG)
 			{
 				pdmpriv->bDoneTxpower = true;
 
@@ -2000,7 +2000,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 				X = pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][0];
 				Y = pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][1];
 
-				if(X != 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G)
+				if (X != 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G)
 				{
 					if ((X & 0x00000200) != 0)
 						X = X | 0xFFFFFC00;
@@ -2031,10 +2031,10 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 
 				//DBG_8192D("TxPwrTracking for interface %d path A: X = 0x%x, Y = 0x%x ele_A = 0x%x ele_C = 0x%x ele_D = 0x%x 0xe94 = 0x%x 0xe9c = 0x%x\n", Adapter->interfaceIndex, X, Y, ele_A, ele_C, ele_D, X, Y);
 
-				if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 				{
 					//Adjust CCK according to IQK result
-					if(!pdmpriv->bCCKinCH14){
+					if (!pdmpriv->bCCKinCH14){
 						rtw_write8(Adapter, 0xa22, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][0]);
 						rtw_write8(Adapter, 0xa23, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][1]);
 						rtw_write8(Adapter, 0xa24, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][2]);
@@ -2056,7 +2056,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 					}
 				}
 
-				if(is2T)
+				if (is2T)
 				{
 					ele_D = (OFDMSwingTable[(u8)OFDM_index[1]] & 0xFFC00000)>>22;
 
@@ -2066,7 +2066,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 					X = pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][4];
 					Y = pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][5];
 
-					if(X != 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G)
+					if (X != 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G)
 					{
 						if ((X & 0x00000200) != 0)	//consider minus
 							X = X | 0xFFFFFC00;
@@ -2102,7 +2102,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 			}
 		}
 
-		if((delta_IQK > pdmpriv->Delta_IQK) && (pdmpriv->Delta_IQK != 0))
+		if ((delta_IQK > pdmpriv->Delta_IQK) && (pdmpriv->Delta_IQK != 0))
 		{
 			rtl8192d_PHY_ResetIQKResult(Adapter);
 #ifdef CONFIG_CONCURRENT_MODE
@@ -2114,7 +2114,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 			rtl8192d_PHY_IQCalibrate(Adapter);
 		}
 
-		if(delta_RxGain > 0 && pHalData->CurrentBandType92D == BAND_ON_5G
+		if (delta_RxGain > 0 && pHalData->CurrentBandType92D == BAND_ON_5G
 			&& ThermalValue <= pHalData->EEPROMThermalMeter && pHalData->bNOPG == false)
 		{
 			pdmpriv->ThermalValue_RxGain = ThermalValue;
@@ -2122,7 +2122,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 		}
 
 		//update thermal meter value
-		if(pdmpriv->TxPowerTrackControl)
+		if (pdmpriv->TxPowerTrackControl)
 		{
 			pdmpriv->ThermalValue = ThermalValue;
 		}
@@ -2143,7 +2143,7 @@ dm_InitializeTXPowerTracking_ThermalMete
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
-	//if(IS_HARDWARE_TYPE_8192C(pHalData))
+	//if (IS_HARDWARE_TYPE_8192C(pHalData))
 	{
 		pdmpriv->bTXPowerTracking = true;
 		pdmpriv->TXPowercount = 0;
@@ -2162,7 +2162,7 @@ DM_InitializeTXPowerTracking(
 {
 	//struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
-	//if(IS_HARDWARE_TYPE_8192C(pHalData))
+	//if (IS_HARDWARE_TYPE_8192C(pHalData))
 	{
 		dm_InitializeTXPowerTracking_ThermalMeter(Adapter);
 	}
@@ -2194,17 +2194,17 @@ dm_CheckTXPowerTracking_ThermalMeter(
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	//u1Byte TxPowerCheckCnt = 5;	//10 sec
 
-	if(!(pdmpriv->DMFlag & DYNAMIC_FUNC_SS))
+	if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_SS))
 	{
 		return;
 	}
 
-	if(!pdmpriv->bTXPowerTracking /*|| (!pHalData->TxPowerTrackControl && pHalData->bAPKdone)*/)
+	if (!pdmpriv->bTXPowerTracking /*|| (!pHalData->TxPowerTrackControl && pHalData->bAPKdone)*/)
 	{
 		return;
 	}
 
-	if(!pdmpriv->TM_Trigger)		//at least delay 1 sec
+	if (!pdmpriv->TM_Trigger)		//at least delay 1 sec
 	{
 		//pHalData->TxPowerCheckCnt++;	//cosa add for debug
 
@@ -2282,7 +2282,7 @@ static void	dm_CheckPbcGPIO(struct rtw_a
 	u8	bPbcPressed = false;
 	int i=0;
 
-	if(!padapter->registrypriv.hw_wps_pbc)
+	if (!padapter->registrypriv.hw_wps_pbc)
 		return;
 
 	do
@@ -2311,12 +2311,12 @@ static void	dm_CheckPbcGPIO(struct rtw_a
 	{
 		bPbcPressed = true;
 
-		if(i<=3)
+		if (i<=3)
 			rtw_msleep_os(50);
 	}
 	}while(i<=3 && bPbcPressed == true);
 
-	if( true == bPbcPressed)
+	if ( true == bPbcPressed)
 	{
 		// Here we only set bPbcPressed to true
 		// After trigger PBC, the variable will be set to false
@@ -2473,14 +2473,14 @@ static void FindMinimumRSSI(struct rtw_a
 	struct rtw_adapter * pbuddy_adapter = Adapter->pbuddy_adapter;
 	struct mlme_priv *pmlmepriv = &Adapter->mlmepriv;
 
-	if(!rtw_buddy_adapter_up(Adapter))
+	if (!rtw_buddy_adapter_up(Adapter))
 		return;
 
 	pbuddy_HalData = GET_HAL_DATA(pbuddy_adapter);
 	pbuddy_dmpriv = &pbuddy_HalData->dmpriv;
 
 	//get min. [PWDB] when both interfaces are connected
-	if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
+	if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
 		&& Adapter->stapriv.asoc_sta_count > 2
 		&& check_buddy_fwstate(Adapter, _FW_LINKED)) ||
 		(check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true
@@ -2492,10 +2492,10 @@ static void FindMinimumRSSI(struct rtw_a
 		&& check_buddy_fwstate(Adapter,_FW_LINKED)))
 	{
 		//select smaller PWDB
-		if(pdmpriv->UndecoratedSmoothedPWDB > pbuddy_dmpriv->UndecoratedSmoothedPWDB)
+		if (pdmpriv->UndecoratedSmoothedPWDB > pbuddy_dmpriv->UndecoratedSmoothedPWDB)
 			pdmpriv->UndecoratedSmoothedPWDB = pbuddy_dmpriv->UndecoratedSmoothedPWDB;
 	}//secondary interface is connected
-	else if((check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true
+	else if ((check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true
 		&& pbuddy_adapter->stapriv.asoc_sta_count > 2) ||
 		(check_buddy_fwstate(Adapter,WIFI_STATION_STATE)
 		&& check_buddy_fwstate(Adapter,_FW_LINKED)))
@@ -2504,7 +2504,7 @@ static void FindMinimumRSSI(struct rtw_a
 		pdmpriv->UndecoratedSmoothedPWDB = pbuddy_dmpriv->UndecoratedSmoothedPWDB;
 	}
 	//primary is connected
-	else if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
+	else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
 		&& Adapter->stapriv.asoc_sta_count > 2) ||
 		(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
 		&& check_fwstate(pmlmepriv, _FW_LINKED)))
@@ -2520,11 +2520,11 @@ static void FindMinimumRSSI(struct rtw_a
 	}
 
 	//primary interface is ap mode
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true && Adapter->stapriv.asoc_sta_count > 2)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true && Adapter->stapriv.asoc_sta_count > 2)
 	{
 		pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
 	}//secondary interface is ap mode
-	else if(check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true && pbuddy_adapter->stapriv.asoc_sta_count > 2)
+	else if (check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true && pbuddy_adapter->stapriv.asoc_sta_count > 2)
 	{
 		pdmpriv->EntryMinUndecoratedSmoothedPWDB = pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB;
 	}
@@ -2550,7 +2550,7 @@ rtl8192d_HalDmWatchDog(
 #endif //CONFIG_CONCURRENT_MODE
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if((pHalData->bInModeSwitchProcess))
+	if ((pHalData->bInModeSwitchProcess))
 	{
 		DBG_8192D("HalDmWatchDog(): During dual mac mode switch or slave mac \n");
 		return;
@@ -2585,7 +2585,7 @@ rtl8192d_HalDmWatchDog(
 #ifdef CONFIG_P2P_PS
 	// Fw is under p2p powersaving mode, driver should stop dynamic mechanism.
 	// modifed by thomas. 2011.06.11.
-	if(Adapter->wdinfo.p2p_ps_mode)
+	if (Adapter->wdinfo.p2p_ps_mode)
 		bFwPSAwake = false;
 #endif // CONFIG_P2P_PS
 
@@ -2598,8 +2598,8 @@ rtl8192d_HalDmWatchDog(
 	//     wating to long for RFChangeInProgress.)
 	// 4. RFChangeInProgress is TRUE. (Prevent from broken by IPS/HW/SW Rf off.)
 	// Noted by tynli. 2010.06.01.
-	//if(rfState == eRfOn)
-	if( (hw_init_completed == true)
+	//if (rfState == eRfOn)
+	if ( (hw_init_completed == true)
 		&& ((!bFwCurrentInPSMode) && bFwPSAwake))
 	{
 		//
@@ -2612,7 +2612,7 @@ rtl8192d_HalDmWatchDog(
 		//
 		PWDB_Monitor(Adapter);
 #ifdef CONFIG_CONCURRENT_MODE
-		if(Adapter->adapter_type > PRIMARY_ADAPTER)
+		if (Adapter->adapter_type > PRIMARY_ADAPTER)
 			goto _record_initrate;
 		FindMinimumRSSI(Adapter);
 #endif //CONFIG_CONCURRENT_MODE
@@ -2621,7 +2621,7 @@ rtl8192d_HalDmWatchDog(
 		//
 //sherry delete flag 20110517
 		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForGlobalAdapterList);
-		if(pHalData->bSlaveOfDMSP)
+		if (pHalData->bSlaveOfDMSP)
 		{
 			odm_FalseAlarmCounterStatistics_ForSlaveOfDMSP(Adapter);
 		}
@@ -2634,14 +2634,14 @@ rtl8192d_HalDmWatchDog(
 		odm_FindMinimumRSSI_92D(Adapter);
 #endif //CONFIG_CONCURRENT_MODE
 		odm_DIG(Adapter);
-		if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
-			if(pHalData->CurrentBandType92D != BAND_ON_5G)
+			if (pHalData->CurrentBandType92D != BAND_ON_5G)
 				dm_CCK_PacketDetectionThresh_DMSP(Adapter);
 		}
 		else
 		{
-			if(pHalData->CurrentBandType92D != BAND_ON_5G)
+			if (pHalData->CurrentBandType92D != BAND_ON_5G)
 				dm_CCK_PacketDetectionThresh(Adapter);
 		}
 
@@ -2655,7 +2655,7 @@ rtl8192d_HalDmWatchDog(
 		//
 		//TX power tracking will make 92de DMDP MAC0's throughput bad.
 #ifdef CONFIG_DUALMAC_CONCURRENT
-		if(!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
+		if (!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
 #endif
 			rtl8192d_dm_CheckTXPowerTracking(Adapter);
 
@@ -2677,18 +2677,18 @@ rtl8192d_HalDmWatchDog(
 		//Dynamic BB Power Saving Mechanism
 		//vivi, 20101014, to pass DTM item: softap_excludeunencrypted_ext.htm
 		//temporarily disable it advised for performance test by yn,2010-11-03.
-		//if(!Adapter->bInHctTest)
+		//if (!Adapter->bInHctTest)
 			dm_DynamicBBPowerSaving(Adapter);
 
 _record_initrate:
 
 		// Read REG_INIDATA_RATE_SEL value for TXDESC.
-		if(check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == true)
+		if (check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == true)
 		{
 			pdmpriv->INIDATA_RATE[0] = rtw_read8(Adapter, REG_INIDATA_RATE_SEL) & 0x3f;
 
 #ifdef CONFIG_TDLS
-			if(Adapter->tdlsinfo.setup_state == TDLS_LINKED_STATE)
+			if (Adapter->tdlsinfo.setup_state == TDLS_LINKED_STATE)
 			{
 				u8 i=1;
 				for(; i < (Adapter->tdlsinfo.macid_index) ; i++)
@@ -2714,7 +2714,7 @@ skip_dm:
 	// Check GPIO to determine current RF on/off and Pbc status.
 	// Not enable for 92CU now!!!
 	// Check Hardware Radio ON/OFF or not
-	//if(Adapter->MgntInfo.PowerSaveControl.bGpioRfSw)
+	//if (Adapter->MgntInfo.PowerSaveControl.bGpioRfSw)
 	//{
 		//RTPRINT(FPWR, PWRHW, ("dm_CheckRfCtrlGPIO \n"));
 	//	dm_CheckRfCtrlGPIO(Adapter);
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -56,7 +56,7 @@ _FWDownloadEnable(
 #if 0
 	u32	value32 = rtw_read32(Adapter, REG_MCUFWDL);
 
-	if(enable){
+	if (enable){
 		value32 |= MCUFWDL_EN;
 	}
 	else{
@@ -68,12 +68,12 @@ _FWDownloadEnable(
 #else
 	u8	tmp;
 
-	if(enable)
+	if (enable)
 	{
 		#ifdef DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE
 		{
 			u8 val;
-			if( (val=rtw_read8(Adapter, REG_MCUFWDL)))
+			if ( (val=rtw_read8(Adapter, REG_MCUFWDL)))
 				DBG_8192D("DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE %s:%d REG_MCUFWDL:0x%02x\n", __func__, __LINE__, val);
 		}
 		#endif
@@ -123,12 +123,12 @@ _BlockWrite_92d(
 		offset = i * blockSize;
 		ret = rtw_writeN(Adapter, (FW_8192D_START_ADDRESS + offset), 64,(bufferPtr + offset));
 
-		if(ret == _FAIL)
+		if (ret == _FAIL)
 			goto exit;
 	}
 
 
-	if(remain8){
+	if (remain8){
 		offset = blockCount * blockSize;
 
 		blockCount8=remain8/blockSize8;
@@ -137,11 +137,11 @@ _BlockWrite_92d(
 		for(i = 0 ; i < blockCount8 ; i++){
 			ret = rtw_writeN(Adapter, (FW_8192D_START_ADDRESS + offset+i*blockSize8), 8,(bufferPtr + offset+i*blockSize8));
 
-			if(ret == _FAIL)
+			if (ret == _FAIL)
 				goto exit;
 		}
 
-		if(remain4){
+		if (remain4){
 			offset=blockCount * blockSize+blockCount8*blockSize8;
 			blockCount4=remain4/blocksize4;
 			remainSize=remain8%blocksize4;
@@ -149,16 +149,16 @@ _BlockWrite_92d(
 			for(i = 0 ; i < blockCount4 ; i++){
 				ret = rtw_write32(Adapter, (FW_8192D_START_ADDRESS + offset+i*blocksize4), cpu_to_le32(*(pu4BytePtr+ offset/4+i)));
 
-				if(ret == _FAIL)
+				if (ret == _FAIL)
 					goto exit;
 			}
 
-			if(remainSize){
+			if (remainSize){
 				offset=blockCount * blockSize+blockCount8*blockSize8+blockCount4*blocksize4;
 				for(i = 0 ; i < remainSize ; i++){
 					ret = rtw_write8(Adapter, (FW_8192D_START_ADDRESS + offset + i), *(bufferPtr +offset+ i));
 
-					if(ret == _FAIL)
+					if (ret == _FAIL)
 						goto exit;
 				}
 			}
@@ -208,15 +208,15 @@ _WriteFW(
 		offset = page *MAX_PAGE_SIZE;
 		ret = _PageWrite(Adapter,page, (bufferPtr+offset),MAX_PAGE_SIZE);
 
-		if(ret == _FAIL)
+		if (ret == _FAIL)
 			goto exit;
 	}
-	if(remainSize){
+	if (remainSize){
 		offset = pageNums *MAX_PAGE_SIZE;
 		page = pageNums;
 		ret = _PageWrite(Adapter,page, (bufferPtr+offset),remainSize);
 
-		if(ret == _FAIL)
+		if (ret == _FAIL)
 			goto exit;
 	}
 	DBG_8192D("_WriteFW Done- for Normal chip.\n");
@@ -238,7 +238,7 @@ int _FWFreeToGo_92D(
 		value32 = rtw_read32(Adapter, REG_MCUFWDL);
 	}while((counter ++ < POLLING_READY_TIMEOUT_COUNT) && (!(value32 & FWDL_ChkSum_rpt  )));
 
-	if(counter >= POLLING_READY_TIMEOUT_COUNT){
+	if (counter >= POLLING_READY_TIMEOUT_COUNT){
 		DBG_8192D("chksum report faill ! REG_MCUFWDL:0x%08x .\n",value32);
 		return _FAIL;
 	}
@@ -260,7 +260,7 @@ rtl8192d_FirmwareSelfReset(
 	u8	u1bTmp;
 	u8	Delay = 100;
 
-	//if((pHalData->FirmwareVersion > 0x21) ||
+	//if ((pHalData->FirmwareVersion > 0x21) ||
 	//	(pHalData->FirmwareVersion == 0x21 &&
 	//	pHalData->FirmwareSubVersion >= 0x01))
 	{
@@ -279,13 +279,13 @@ rtl8192d_FirmwareSelfReset(
 		{
 			Delay--;
 			//RT_TRACE(COMP_INIT, DBG_LOUD, ("PowerOffAdapter8192CE(): polling 0x03[2] Delay = %d \n", Delay));
-			if(Delay == 0)
+			if (Delay == 0)
 				break;
 			rtw_udelay_os(50);
 			u1bTmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
 		}
 
-		if((u1bTmp&BIT2) && (Delay == 0))
+		if ((u1bTmp&BIT2) && (Delay == 0))
 		{
 			//DbgPrint("FirmwareDownload92C(): Fail!!!!!! 0x03 = %x\n", u1bTmp);
 			rtw_write8(Adapter, REG_FWIMR, 0x00);
@@ -317,15 +317,15 @@ int _FWInit(
 	counter = 0;
 	do
 	{
-		if(pHalData->interfaceIndex==0){
-			if(rtw_read8(Adapter, FW_MAC0_ready) & mac0_ready){
+		if (pHalData->interfaceIndex==0){
+			if (rtw_read8(Adapter, FW_MAC0_ready) & mac0_ready){
 				DBG_8192D("Polling FW ready success!! FW_MAC0_ready:0x%x .\n",rtw_read8(Adapter, FW_MAC0_ready));
 				return _SUCCESS;
 			}
 			rtw_udelay_os(5);
 		}
 		else{
-			if(rtw_read8(Adapter, FW_MAC1_ready) &mac1_ready){
+			if (rtw_read8(Adapter, FW_MAC1_ready) &mac1_ready){
 				DBG_8192D("Polling FW ready success!! FW_MAC1_ready:0x%x .\n",rtw_read8(Adapter, FW_MAC1_ready));
 				return _SUCCESS;
 			}
@@ -334,7 +334,7 @@ int _FWInit(
 
 	}while(counter++ < POLLING_READY_TIMEOUT_COUNT);
 
-	if(pHalData->interfaceIndex==0){
+	if (pHalData->interfaceIndex==0){
 		DBG_8192D("Polling FW ready fail!! MAC0 FW init not ready:0x%x .\n",rtw_read8(Adapter, FW_MAC0_ready) );
 	}
 	else{
@@ -380,12 +380,12 @@ int FirmwareDownload92D(
 	u32		count;
 	bool	 bFwDownloaded = false,bFwDownloadInProcess = false;
 
-	if(Adapter->bSurpriseRemoved){
+	if (Adapter->bSurpriseRemoved){
 		return _FAIL;
 	}
 
 	pFirmware = (struct RT_FIRMWARE_92D *)rtw_zvmalloc(sizeof(struct RT_FIRMWARE_92D));
-	if(!pFirmware) {
+	if (!pFirmware) {
 		rtStatus = _FAIL;
 		goto Exit;
 	}
@@ -400,7 +400,7 @@ int FirmwareDownload92D(
 	DBG_8192D(" ===> FirmwareDownload92D() fw:Rtl8192D_FwImageArray\n");
 
 	#ifdef CONFIG_FILE_FWIMG
-	if(rtw_is_file_readable(rtw_fw_file_path) == true)
+	if (rtw_is_file_readable(rtw_fw_file_path) == true)
 	{
 		DBG_8192D("%s accquire FW from file:%s\n", __func__, rtw_fw_file_path);
 		pFirmware->eFWSource = FW_SOURCE_IMG_FILE; // We should decided by Reg.
@@ -423,7 +423,7 @@ int FirmwareDownload92D(
 			pFirmware->szFwBuffer = FwBuffer8192D;
 			#endif //CONFIG_FILE_FWIMG
 
-			if(pFirmware->ulFwLength <= 0)
+			if (pFirmware->ulFwLength <= 0)
 			{
 				rtStatus = _FAIL;
 				goto Exit;
@@ -431,7 +431,7 @@ int FirmwareDownload92D(
 			break;
 		case FW_SOURCE_HEADER_FILE:
 #if 0
-			if(ImgArrayLength > FW_8192C_SIZE){
+			if (ImgArrayLength > FW_8192C_SIZE){
 				rtStatus = _FAIL;
 				//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Firmware size exceed 0x%X. Check it.\n", FW_8192C_SIZE) );
 				goto Exit;
@@ -440,7 +440,7 @@ int FirmwareDownload92D(
 			pFirmware->szFwBuffer = FwImage;
 			pFirmware->ulFwLength = FwImageLen;
 #ifdef CONFIG_WOWLAN
-			if(bUsedWoWLANFw)
+			if (bUsedWoWLANFw)
 			{
 				pFirmware->szWoWLANFwBuffer=FwImageWoWLAN;
 				pFirmware->ulWoWLANFwLength = FwImageWoWLANLen;
@@ -450,14 +450,14 @@ int FirmwareDownload92D(
 	}
 
 	#ifdef DBG_FW_STORE_FILE_PATH //used to store firmware to file...
-	if(pFirmware->ulFwLength > 0)
+	if (pFirmware->ulFwLength > 0)
 	{
 		rtw_store_to_file(DBG_FW_STORE_FILE_PATH, pFirmware->szFwBuffer, pFirmware->ulFwLength);
 	}
 	#endif
 
 #ifdef CONFIG_WOWLAN
-	if(bUsedWoWLANFw)	{
+	if (bUsedWoWLANFw)	{
 		pFirmwareBuf = pFirmware->szWoWLANFwBuffer;
 		FirmwareLen = pFirmware->ulWoWLANFwLength;
 		pFwHdr = (struct rt_8192d_firmware_hdr *)pFirmware->szWoWLANFwBuffer;
@@ -477,7 +477,7 @@ int FirmwareDownload92D(
 
 	DBG_8192D(" FirmwareVersion(%#x), Signature(%#x)\n", pHalData->FirmwareVersion, le16_to_cpu(pFwHdr->Signature));
 
-	if(IS_FW_HEADER_EXIST(pFwHdr))
+	if (IS_FW_HEADER_EXIST(pFwHdr))
 	{
 		//DBG_8192D("Shift 32 bytes for FW header!!\n");
 		pFirmwareBuf = pFirmwareBuf + 32;
@@ -486,7 +486,7 @@ int FirmwareDownload92D(
 
 #ifdef CONFIG_WOWLAN
 	//write 0x5 BIT(3), don't suspend to reset MAC
-	if(bUsedWoWLANFw)
+	if (bUsedWoWLANFw)
 	{
 		u8 test;
 		test = rtw_read8(Adapter, REG_APS_FSMCO+1);
@@ -496,23 +496,23 @@ int FirmwareDownload92D(
 
 #endif //CONFIG_WOWLAN
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
-	if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY ||
+	if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY ||
 		pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 	{
 
 	bFwDownloaded = _IsFWDownloaded(Adapter);
-	if((rtw_read8(Adapter, 0x1f)&BIT5) == BIT5)
+	if ((rtw_read8(Adapter, 0x1f)&BIT5) == BIT5)
 		bFwDownloadInProcess = true;
 	else
 		bFwDownloadInProcess = false;
 	}
 
-	if(bFwDownloaded)
+	if (bFwDownloaded)
 	{
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 		goto Exit;
 	}
-	else if(bFwDownloadInProcess)
+	else if (bFwDownloadInProcess)
 	{
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 		for(count=0;count<5000;count++)
@@ -520,14 +520,14 @@ int FirmwareDownload92D(
 			rtw_udelay_os(500);
 			ACQUIRE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 			bFwDownloaded = _IsFWDownloaded(Adapter);
-			if((rtw_read8(Adapter, 0x1f)&BIT5) == BIT5)
+			if ((rtw_read8(Adapter, 0x1f)&BIT5) == BIT5)
 				bFwDownloadInProcess = true;
 			else
 				bFwDownloadInProcess = false;
 			RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
-			if(bFwDownloaded)
+			if (bFwDownloaded)
 				goto Exit;
-			else if(!bFwDownloadInProcess)
+			else if (!bFwDownloadInProcess)
 				break;
 			else
 				DBG_8192D("Wait for another mac download fw \n");
@@ -548,7 +548,7 @@ int FirmwareDownload92D(
 
 	// Suggested by Filen. If 8051 is running in RAM code, driver should inform Fw to reset by itself,
 	// or it will cause download Fw fail. 2010.02.01. by tynli.
-	if(rtw_read8(Adapter, REG_MCUFWDL)&BIT7) //8051 RAM code
+	if (rtw_read8(Adapter, REG_MCUFWDL)&BIT7) //8051 RAM code
 	{
 		DBG_8192D("Firmware self reset\n");
 		rtl8192d_FirmwareSelfReset(Adapter);
@@ -563,7 +563,7 @@ int FirmwareDownload92D(
 
 		rtStatus = _WriteFW(Adapter, pFirmwareBuf, FirmwareLen);
 
-		if(rtStatus == _SUCCESS
+		if (rtStatus == _SUCCESS
 			||(rtw_get_passing_time_ms(fwdl_start_time) > 500 && writeFW_retry++ >= 3)
 		)
 			break;
@@ -574,7 +574,7 @@ int FirmwareDownload92D(
 		);
 	}
 	_FWDownloadEnable(Adapter, false);
-	if(_SUCCESS != rtStatus){
+	if (_SUCCESS != rtStatus){
 		DBG_8192D("DL Firmware failed!\n");
 		goto Exit;
 	}
@@ -587,7 +587,7 @@ int FirmwareDownload92D(
 	rtw_write8(Adapter, 0x1f,value);
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 
-	if(_SUCCESS != rtStatus){
+	if (_SUCCESS != rtStatus){
 		DBG_8192D("Firmware is not ready to run!\n");
 		goto Exit;
 	}
@@ -596,7 +596,7 @@ Exit:
 
 	rtStatus =_FWInit(Adapter);
 
-	if(pFirmware) {
+	if (pFirmware) {
 		rtw_vmfree((u8*)pFirmware, sizeof(struct RT_FIRMWARE_92D));
 	}
 
@@ -644,13 +644,13 @@ SetFwRelatedForWoWLAN8192DU(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
 	u8	 bRecover = false;
 
-	if(bHostIsGoingtoSleep)
+	if (bHostIsGoingtoSleep)
 	{
 		//
 		// 1. Before WoWLAN we need to re-download WoWLAN Fw.
 		//
 		status = FirmwareDownload92D(padapter, bHostIsGoingtoSleep);
-		if(status != _SUCCESS)
+		if (status != _SUCCESS)
 		{
 			DBG_8192D("ConfigFwRelatedForWoWLAN8192DU(): Re-Download Firmware failed!!\n");
 			return;
@@ -681,24 +681,24 @@ static u8 Hal_GetChnlGroupfromArray(u8 c
 		group = 0;
 	else if (channel_info[chnl] <= 9)		// Channel 4-9
 		group = 1;
-	else	if(channel_info[chnl] <=14)				// Channel 10-14
+	else	if (channel_info[chnl] <=14)				// Channel 10-14
 		group = 2;
 	// For TX_POWER_FOR_5G_BAND
-	else if(channel_info[chnl] <= 44)
+	else if (channel_info[chnl] <= 44)
 		group = 3;
-	else if(channel_info[chnl] <= 54)
+	else if (channel_info[chnl] <= 54)
 		group = 4;
-	else if(channel_info[chnl] <= 64)
+	else if (channel_info[chnl] <= 64)
 		group = 5;
-	else if(channel_info[chnl] <= 112)
+	else if (channel_info[chnl] <= 112)
 		group = 6;
-	else if(channel_info[chnl] <= 126)
+	else if (channel_info[chnl] <= 126)
 		group = 7;
-	else if(channel_info[chnl] <= 140)
+	else if (channel_info[chnl] <= 140)
 		group = 8;
-	else if(channel_info[chnl] <= 153)
+	else if (channel_info[chnl] <= 153)
 		group = 9;
-	else if(channel_info[chnl] <= 159)
+	else if (channel_info[chnl] <= 159)
 		group = 10;
 	else
 		group = 11;
@@ -781,10 +781,10 @@ hal_ReadPowerValueFromPROM92D(
 
 	memset(pwrInfo, 0, sizeof(struct tx_power_info));
 
-	if(AutoLoadFail){
+	if (AutoLoadFail){
 		for(group = 0 ; group < CHANNEL_GROUP_MAX ; group++){
 			for(rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
-				if(group< CHANNEL_GROUP_MAX_2G)
+				if (group< CHANNEL_GROUP_MAX_2G)
 				{
 					pwrInfo->CCKIndex[rfPath][group]		= EEPROM_Default_TxPowerLevel_2G;
 					pwrInfo->HT40_1SIndex[rfPath][group]		= EEPROM_Default_TxPowerLevel_2G;
@@ -817,7 +817,7 @@ hal_ReadPowerValueFromPROM92D(
 			eeAddr = EEPROM_CCK_TX_PWR_INX_2G + (rfPath * 3) + group;
 			pwrInfo->CCKIndex[rfPath][group] =
 				(PROMContent[eeAddr] == 0xFF)?(eeAddr>0x7B?EEPROM_Default_TxPowerLevel_5G:EEPROM_Default_TxPowerLevel_2G):PROMContent[eeAddr];
-			if(PROMContent[eeAddr] == 0xFF)
+			if (PROMContent[eeAddr] == 0xFF)
 				pHalData->bNOPG = true;
 		}
 	}
@@ -837,7 +837,7 @@ hal_ReadPowerValueFromPROM92D(
 			offset1 = group / 3;
 			offset2 = group % 3;
 
-			if(PROMContent[EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G+ offset2 + offset1*21] != 0xFF)
+			if (PROMContent[EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G+ offset2 + offset1*21] != 0xFF)
 				pwrInfo->HT40_2SIndexDiff[rfPath][group] =
 					(PROMContent[EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G+ offset2 + offset1*21] >> (rfPath * 4)) & 0xF;
 					//RT_TRACE(COMP_INIT,DBG_LOUD,
@@ -845,11 +845,11 @@ hal_ReadPowerValueFromPROM92D(
 			else
 				pwrInfo->HT40_2SIndexDiff[rfPath][group]	= EEPROM_Default_HT40_2SDiff;
 
-			if(PROMContent[EEPROM_HT20_TX_PWR_INX_DIFF_2G + offset2 + offset1*21] != 0xFF)
+			if (PROMContent[EEPROM_HT20_TX_PWR_INX_DIFF_2G + offset2 + offset1*21] != 0xFF)
 			{
 				pwrInfo->HT20IndexDiff[rfPath][group] =
 					(PROMContent[EEPROM_HT20_TX_PWR_INX_DIFF_2G+ offset2 + offset1*21] >> (rfPath * 4)) & 0xF;
-				if(pwrInfo->HT20IndexDiff[rfPath][group] & BIT3)	//4bit sign number to 8 bit sign number
+				if (pwrInfo->HT20IndexDiff[rfPath][group] & BIT3)	//4bit sign number to 8 bit sign number
 					pwrInfo->HT20IndexDiff[rfPath][group] |= 0xF0;
 			}
 			else
@@ -857,19 +857,19 @@ hal_ReadPowerValueFromPROM92D(
 				pwrInfo->HT20IndexDiff[rfPath][group]		= EEPROM_Default_HT20_Diff;
 			}
 
-			if(PROMContent[EEPROM_OFDM_TX_PWR_INX_DIFF_2G + offset2 + offset1*21] != 0xFF)
+			if (PROMContent[EEPROM_OFDM_TX_PWR_INX_DIFF_2G + offset2 + offset1*21] != 0xFF)
 				pwrInfo->OFDMIndexDiff[rfPath][group] =
 					(PROMContent[EEPROM_OFDM_TX_PWR_INX_DIFF_2G + offset2 + offset1*21] >> (rfPath * 4)) & 0xF;
 			else
 				pwrInfo->OFDMIndexDiff[rfPath][group]	= EEPROM_Default_LegacyHTTxPowerDiff;
 
-			if(PROMContent[EEPROM_HT40_MAX_PWR_OFFSET_2G + offset2 + offset1*21] != 0xFF)
+			if (PROMContent[EEPROM_HT40_MAX_PWR_OFFSET_2G + offset2 + offset1*21] != 0xFF)
 				pwrInfo->HT40MaxOffset[rfPath][group] =
 					(PROMContent[EEPROM_HT40_MAX_PWR_OFFSET_2G + offset2 + offset1*21] >> (rfPath * 4)) & 0xF;
 			else
 				pwrInfo->HT40MaxOffset[rfPath][group]	= EEPROM_Default_HT40_PwrMaxOffset;
 
-			if(PROMContent[EEPROM_HT20_MAX_PWR_OFFSET_2G + offset2 + offset1*21] != 0xFF)
+			if (PROMContent[EEPROM_HT20_MAX_PWR_OFFSET_2G + offset2 + offset1*21] != 0xFF)
 				pwrInfo->HT20MaxOffset[rfPath][group] =
 					(PROMContent[EEPROM_HT20_MAX_PWR_OFFSET_2G + offset2 + offset1*21] >> (rfPath * 4)) & 0xF;
 			else
@@ -878,7 +878,7 @@ hal_ReadPowerValueFromPROM92D(
 		}
 	}
 
-	if(PROMContent[EEPROM_TSSI_A_5G] != 0xFF){
+	if (PROMContent[EEPROM_TSSI_A_5G] != 0xFF){
 		//5GL
 		pwrInfo->TSSI_A_5G[0] = PROMContent[EEPROM_TSSI_A_5G] & 0x3F;	//[0:5]
 		pwrInfo->TSSI_B_5G[0] = PROMContent[EEPROM_TSSI_B_5G] & 0x3F;
@@ -918,7 +918,7 @@ rtl8192d_ReadTxPowerInfo(
 
 	hal_ReadPowerValueFromPROM92D(Adapter, &pwrInfo, PROMContent, AutoLoadFail);
 
-	if(!AutoLoadFail)
+	if (!AutoLoadFail)
 	{
 		pHalData->EEPROMRegulatory = (PROMContent[EEPROM_RF_OPT1]&0x7);	//bit0~2
 		pHalData->EEPROMThermalMeter = PROMContent[EEPROM_THERMAL_METER]&0x1f;
@@ -926,7 +926,7 @@ rtl8192d_ReadTxPowerInfo(
 		tempval[0] = PROMContent[EEPROM_IQK_DELTA]&0x03;
 		tempval[1] = (PROMContent[EEPROM_LCK_DELTA]&0x0C) >> 2;
 		pHalData->bTXPowerDataReadFromEEPORM = true;
-		if(IS_92D_D_CUT(pHalData->VersionID)||IS_92D_E_CUT(pHalData->VersionID))
+		if (IS_92D_D_CUT(pHalData->VersionID)||IS_92D_E_CUT(pHalData->VersionID))
 		{
 			pHalData->InternalPA5G[0] = !((PROMContent[EEPROM_TSSI_A_5G] & BIT6) >> 6);
 			pHalData->InternalPA5G[1] = !((PROMContent[EEPROM_TSSI_B_5G] & BIT6) >> 6);
@@ -945,7 +945,7 @@ rtl8192d_ReadTxPowerInfo(
 
 	pHalData->PAMode = PA_MODE_INTERNAL_SP3T;
 
-	if(pHalData->EEPROMC9 == 0xFF || AutoLoadFail)
+	if (pHalData->EEPROMC9 == 0xFF || AutoLoadFail)
 	{
 		switch(pHalData->PAMode)
 		{
@@ -982,16 +982,16 @@ rtl8192d_ReadTxPowerInfo(
 	//Use default value to fill parameters if efuse is not filled on some place.
 
 	// ThermalMeter from EEPROM
-	if(pHalData->EEPROMThermalMeter < 0x06 || pHalData->EEPROMThermalMeter > 0x1c)
+	if (pHalData->EEPROMThermalMeter < 0x06 || pHalData->EEPROMThermalMeter > 0x1c)
 		pHalData->EEPROMThermalMeter = 0x12;
 
 	pdmpriv->ThermalMeter[0] = pHalData->EEPROMThermalMeter;
 
 	//check XTAL_K
-	if(pHalData->CrystalCap == 0xFF)
+	if (pHalData->CrystalCap == 0xFF)
 		pHalData->CrystalCap = 0;
 
-	if(pHalData->EEPROMRegulatory >3)
+	if (pHalData->EEPROMRegulatory >3)
 		pHalData->EEPROMRegulatory = 0;
 
 	for(i = 0; i < 2; i++)
@@ -1027,7 +1027,7 @@ rtl8192d_ReadTxPowerInfo(
 	pHalData->Delta_LCK = 0;
 #endif
 
-	if(pHalData->EEPROMC9 == 0xFF)
+	if (pHalData->EEPROMC9 == 0xFF)
 		pHalData->EEPROMC9 = 0x00;
 
 	//RTPRINT(FINIT, INIT_TxPower, ("EEPROMRegulatory = 0x%x\n", pHalData->EEPROMRegulatory));
@@ -1039,7 +1039,7 @@ rtl8192d_ReadTxPowerInfo(
 		for(ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
 			group = Hal_GetChnlGroupfromArray((u8)ch);
 
-			if(ch < CHANNEL_MAX_NUMBER_2G)
+			if (ch < CHANNEL_MAX_NUMBER_2G)
 				pHalData->TxPwrLevelCck[rfPath][ch]		= pwrInfo.CCKIndex[rfPath][group];
 			pHalData->TxPwrLevelHT40_1S[rfPath][ch]	= pwrInfo.HT40_1SIndex[rfPath][group];
 
@@ -1059,7 +1059,7 @@ rtl8192d_ReadTxPowerInfo(
 
 	for(rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
 		for(ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
-			if(ch < CHANNEL_MAX_NUMBER_2G)
+			if (ch < CHANNEL_MAX_NUMBER_2G)
 			{
 				DBG_8192D("RF(%d)-Ch(%d) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\n",
 					rfPath, ch,
@@ -1118,7 +1118,7 @@ void rtl8192d_ResetDualMacSwitchVariable
 	Adapter->bInModeSwitchProcess = false;
 	Adapter->bDoTurnOffPhyRf  = false;
 
-	if(BuddyAdapter != NULL)
+	if (BuddyAdapter != NULL)
 	{
 		Adapter->PreChangeAction = BuddyAdapter->PreChangeAction;
 	}
@@ -1162,14 +1162,14 @@ PHY_CheckPowerOffFor8192D(
 	u8 u1bTmp;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
-	if(pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY) {
+	if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY) {
 		u1bTmp = rtw_read8(Adapter, REG_MAC0);
 		rtw_write8(Adapter, REG_MAC0, u1bTmp&(~MAC0_ON));
 		return true;
 	}
 
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
-	if(pHalData->interfaceIndex == 0){
+	if (pHalData->interfaceIndex == 0){
 		u1bTmp = rtw_read8(Adapter, REG_MAC0);
 		rtw_write8(Adapter, REG_MAC0, u1bTmp&(~MAC0_ON));
 		u1bTmp = rtw_read8(Adapter, REG_MAC1);
@@ -1182,7 +1182,7 @@ PHY_CheckPowerOffFor8192D(
 		u1bTmp &=MAC0_ON;
 	}
 
-	if(u1bTmp)
+	if (u1bTmp)
 	{
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
 		return false;
@@ -1210,7 +1210,7 @@ PHY_SetPowerOnFor8192D(
 	u16	i;
 
 	// notice fw know band status  0x81[1]/0x53[1] = 0: 5G, 1: 2G
-	if(pHalData->CurrentBandType92D==BAND_ON_2_4G)
+	if (pHalData->CurrentBandType92D==BAND_ON_2_4G)
 	{
 		value8 = rtw_read8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
 		value8 |= BIT1;
@@ -1223,7 +1223,7 @@ PHY_SetPowerOnFor8192D(
 		rtw_write8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1),value8);
 	}
 
-	if(pHalData->MacPhyMode92D ==SINGLEMAC_SINGLEPHY)
+	if (pHalData->MacPhyMode92D ==SINGLEMAC_SINGLEPHY)
 	{
 		value8 = rtw_read8(Adapter, REG_MAC0);
 		rtw_write8(Adapter, REG_MAC0, value8|MAC0_ON);
@@ -1231,7 +1231,7 @@ PHY_SetPowerOnFor8192D(
 	else
 	{
 		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
-		if(pHalData->interfaceIndex == 0)
+		if (pHalData->interfaceIndex == 0)
 		{
 			value8 = rtw_read8(Adapter, REG_MAC0);
 			rtw_write8(Adapter, REG_MAC0, value8|MAC0_ON);
@@ -1246,7 +1246,7 @@ PHY_SetPowerOnFor8192D(
 
 		for(i=0;i<200;i++)
 		{
-			if((value8&BIT7) == 0)
+			if ((value8&BIT7) == 0)
 			{
 				break;
 			}
@@ -1259,7 +1259,7 @@ PHY_SetPowerOnFor8192D(
 			}
 		}
 
-		if(i==200)
+		if (i==200)
 			DBG_8192D("Another mac power off over time \n");
 	}
 }
@@ -1316,7 +1316,7 @@ rtl8192d_EfusePowerSwitch(
 			rtw_write16(pAdapter, REG_SYS_CLKR, tmpV16);
 		}
 
-		if(bWrite == true){
+		if (bWrite == true){
 			// Enable LDO 2.5V before read/write action
 			tempval = rtw_read8(pAdapter, EFUSE_TEST+3);
 			tempval &= 0x0F;
@@ -1357,7 +1357,7 @@ ReadEFuse_RTL8192D(
 	//
 	// Do NOT excess total size of EFuse table. Added by Roger, 2008.11.10.
 	//
-	if((_offset + _size_byte)>EFUSE_MAP_LEN)
+	if ((_offset + _size_byte)>EFUSE_MAP_LEN)
 	{// total E-Fuse table is 128bytes
 		DBG_8192D("ReadEFuse(): Invalid offset(%#x) with read bytes(%#x)!!\n",_offset, _size_byte);
 		return;
@@ -1374,7 +1374,7 @@ ReadEFuse_RTL8192D(
 	//
 	//
 	ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
-	if(*rtemp8 != 0xFF)
+	if (*rtemp8 != 0xFF)
 	{
 		efuse_utilized++;
 		//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Addr=%d\n", eFuse_Addr));
@@ -1392,7 +1392,7 @@ ReadEFuse_RTL8192D(
 	while((*rtemp8 != 0xFF) && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN))
 	{
 		// Check PG header for section num.
-		if((*rtemp8 & 0x1F ) == 0x0F)		//extended header
+		if ((*rtemp8 & 0x1F ) == 0x0F)		//extended header
 		{
 
 			//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("extended header u1temp=%x *rtemp&0xE0 0x%x\n", u1temp, *rtemp8 & 0xE0));
@@ -1405,12 +1405,12 @@ ReadEFuse_RTL8192D(
 
 			//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("extended header efuse_Addr-%d efuse_data=%x\n", eFuse_Addr, *rtemp8));
 
-			if((*rtemp8 & 0x0F) == 0x0F)
+			if ((*rtemp8 & 0x0F) == 0x0F)
 			{
 				eFuse_Addr++;
 				ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
 
-				if(*rtemp8 != 0xFF && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN))
+				if (*rtemp8 != 0xFF && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN))
 				{
 					eFuse_Addr++;
 				}
@@ -1429,7 +1429,7 @@ ReadEFuse_RTL8192D(
 			wren = (*rtemp8 & 0x0f);
 		}
 
-		if(offset < EFUSE_MAX_SECTION)
+		if (offset < EFUSE_MAX_SECTION)
 		{
 			// Get word enable value from PG header
 			//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Offset-%d Worden=%x\n", offset, wren));
@@ -1437,7 +1437,7 @@ ReadEFuse_RTL8192D(
 			for(i=0; i<EFUSE_MAX_WORD_UNIT; i++)
 			{
 				// Check word enable condition in the section
-				if(!(wren & 0x01))
+				if (!(wren & 0x01))
 				{
 					//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Addr=%d\n", eFuse_Addr));
 					ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
@@ -1447,7 +1447,7 @@ ReadEFuse_RTL8192D(
 					eFuseWord[offset][i] = (*rtemp8 & 0xff);
 
 
-					if(eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
+					if (eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
 						break;
 
 					//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Addr=%d\n", eFuse_Addr));
@@ -1458,7 +1458,7 @@ ReadEFuse_RTL8192D(
 					efuse_utilized++;
 					eFuseWord[offset][i] |= (((u16)*rtemp8 << 8) & 0xff00);
 
-					if(eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
+					if (eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
 						break;
 				}
 
@@ -1471,7 +1471,7 @@ ReadEFuse_RTL8192D(
 		ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
 		//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Addr=%d rtemp 0x%x\n", eFuse_Addr, *rtemp8));
 
-		if(*rtemp8 != 0xFF && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN))
+		if (*rtemp8 != 0xFF && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN))
 		{
 			efuse_utilized++;
 			eFuse_Addr++;
@@ -1556,22 +1556,22 @@ hal_EfuseMacMode_ISVS_92D(
 	u8	PartNo;
 	bool bResult = false;
 	// 92D VS not support dual mac mode
-	if(IS_NORMAL_CHIP92D(pHalData->VersionID))
+	if (IS_NORMAL_CHIP92D(pHalData->VersionID))
 	{
 		ReadEFuseByte(Adapter,EEPROM_DEF_PART_NO,&PartNo, false);
 		//RT_TRACE(COMP_INIT, DBG_LOUD, ("92D efuse byte 1021 content :%d \n",PartNo));
 
-		if((((PartNo & 0xc0) ==  PARTNO_92D_NIC)&&((PartNo & 0x0c) == PARTNO_SINGLE_BAND_VS))||
+		if ((((PartNo & 0xc0) ==  PARTNO_92D_NIC)&&((PartNo & 0x0c) == PARTNO_SINGLE_BAND_VS))||
 			(((PartNo & 0xF0) == PARTNO_92D_NIC_REMARK) &&((PartNo & 0x0F) == PARTNO_SINGLE_BAND_VS_REMARK)))
 		{
 			//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("92D VS !\n"));
 			bResult = true;
 		}
-		else if(PartNo == 0x00)
+		else if (PartNo == 0x00)
 		{
 			ReadEFuseByte(Adapter,EEPROM_DEF_PART_NO+1,&PartNo, false);
 			//RT_TRACE(COMP_INIT, DBG_LOUD, ("92D efuse byte 1022 content :%d \n",PartNo));
-			if((((PartNo & 0xc0) ==  PARTNO_92D_NIC)&&((PartNo & 0x0c) == PARTNO_SINGLE_BAND_VS))||
+			if ((((PartNo & 0xc0) ==  PARTNO_92D_NIC)&&((PartNo & 0x0c) == PARTNO_SINGLE_BAND_VS))||
 				(((PartNo & 0xF0) == PARTNO_92D_NIC_REMARK) &&((PartNo & 0x0F) == PARTNO_SINGLE_BAND_VS_REMARK)))
 			{
 				//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("92D VS !\n"));
@@ -1680,14 +1680,14 @@ rtl8192d_EfuseGetCurrentSize(
 			efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) &&
 			(efuse_addr  < EFUSE_REAL_CONTENT_LEN) )
 	{
-		if(efuse_data!=0xFF)
+		if (efuse_data!=0xFF)
 		{
-			if((efuse_data&0x1F) == 0x0F)		//extended header
+			if ((efuse_data&0x1F) == 0x0F)		//extended header
 			{
 				hoffset = efuse_data;
 				efuse_addr++;
 				efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest);
-				if((efuse_data & 0x0F) == 0x0F)
+				if ((efuse_data & 0x0F) == 0x0F)
 				{
 					efuse_addr++;
 					continue;
@@ -1735,8 +1735,8 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 	u8	tmpdata[8];
 	u8	tmp_header = 0;
 
-	if(data==NULL)	return false;
-	if(offset>=EFUSE_MAX_SECTION)		return false;
+	if (data==NULL)	return false;
+	if (offset>=EFUSE_MAX_SECTION)		return false;
 
 
 	memset((void *)data, 0xff, sizeof(u8)*PGPKT_DATA_SIZE);
@@ -1752,16 +1752,16 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 	while(bContinual && (efuse_addr  < EFUSE_REAL_CONTENT_LEN) )
 	{
 		//-------  Header Read -------------
-		if(ReadState & PG_STATE_HEADER)
+		if (ReadState & PG_STATE_HEADER)
 		{
-			if(efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest)&&(efuse_data!=0xFF))
+			if (efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest)&&(efuse_data!=0xFF))
 			{
-				if((efuse_data & 0x1F) == 0x0F)
+				if ((efuse_data & 0x1F) == 0x0F)
 				{
 					tmp_header = efuse_data;
 					efuse_addr++;
 					efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest);
-					if((efuse_data & 0x0F) != 0x0F)
+					if ((efuse_data & 0x0F) != 0x0F)
 					{
 						hoffset = ((tmp_header & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);
 						hworden = efuse_data & 0x0F;
@@ -1781,16 +1781,16 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 				word_cnts = Efuse_CalculateWordCnts(hworden);
 				bDataEmpty = true ;
 
-				if(hoffset==offset){
+				if (hoffset==offset){
 					for(tmpidx = 0;tmpidx< word_cnts*2 ;tmpidx++){
-						if(efuse_OneByteRead(pAdapter, efuse_addr+1+tmpidx ,&efuse_data, bPseudoTest) ){
+						if (efuse_OneByteRead(pAdapter, efuse_addr+1+tmpidx ,&efuse_data, bPseudoTest) ){
 							tmpdata[tmpidx] = efuse_data;
-							if(efuse_data!=0xff){
+							if (efuse_data!=0xff){
 								bDataEmpty = false;
 							}
 						}
 					}
-					if(bDataEmpty==false){
+					if (bDataEmpty==false){
 						ReadState = PG_STATE_DATA;
 					}else{//read next header
 						efuse_addr = efuse_addr + (word_cnts*2)+1;
@@ -1808,7 +1808,7 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 			}
 		}
 		//-------  Data section Read -------------
-		else if(ReadState & PG_STATE_DATA)
+		else if (ReadState & PG_STATE_DATA)
 		{
 			efuse_WordEnableDataRead(hworden,tmpdata,data);
 			efuse_addr = efuse_addr + (word_cnts*2)+1;
@@ -1820,7 +1820,7 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 
 	//RT_PRINT_DATA(COMP_EFUSE, DBG_LOUD, ("efuse_PgPacketRead-2\n"), data, 8);
 
-	if(	(data[0]==0xff) &&(data[1]==0xff) && (data[2]==0xff)  && (data[3]==0xff) &&
+	if (	(data[0]==0xff) &&(data[1]==0xff) && (data[2]==0xff)  && (data[3]==0xff) &&
 		(data[4]==0xff) &&(data[5]==0xff) && (data[6]==0xff)  && (data[7]==0xff))
 		return false;
 	else
@@ -1869,7 +1869,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 	// (i.e., offset 0~497, and dummy 1bytes) expected after CP test.
 	// 2009.02.19.
 	//
-	if( Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest) >= (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))
+	if ( Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest) >= (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))
 	{
 		//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite error \n"));
 		return false;
@@ -1899,7 +1899,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 	while( bContinual && (efuse_addr  < (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES)) )
 	{
 
-		if(WriteState==PG_STATE_HEADER)
+		if (WriteState==PG_STATE_HEADER)
 		{
 			bDataEmpty=true;
 			badworden = 0x0F;
@@ -1908,12 +1908,12 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 			if (	efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) &&
 				(efuse_data!=0xFF))
 			{
-				if((efuse_data&0x1F) == 0x0F)		//extended header
+				if ((efuse_data&0x1F) == 0x0F)		//extended header
 				{
 					tmp_header = efuse_data;
 					efuse_addr++;
 					efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest);
-					if((efuse_data & 0x0F) == 0x0F)	//wren fail
+					if ((efuse_data & 0x0F) == 0x0F)	//wren fail
 					{
 						efuse_addr++;
 						continue;
@@ -1935,7 +1935,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 				//RTPRINT(FEEPROM, EFUSE_PG, ("section offset 0x%x worden 0x%x\n", tmp_pkt.offset, tmp_pkt.word_en));
 
 				//************  so-1 *******************
-				if(tmp_pkt.offset  != target_pkt.offset)
+				if (tmp_pkt.offset  != target_pkt.offset)
 				{
 					efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet
 #if (EFUSE_ERROE_HANDLE == 1)
@@ -1949,12 +1949,12 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 					//************  so-2 *******************
 					for(tmpindex=0 ; tmpindex<(tmp_word_cnts*2) ; tmpindex++)
 					{
-						if(efuse_OneByteRead(pAdapter, (efuse_addr+1+tmpindex) ,&efuse_data, bPseudoTest)&&(efuse_data != 0xFF)){
+						if (efuse_OneByteRead(pAdapter, (efuse_addr+1+tmpindex) ,&efuse_data, bPseudoTest)&&(efuse_data != 0xFF)){
 							bDataEmpty = false;
 						}
 					}
 					//************  so-2-1 *******************
-					if(bDataEmpty == false)
+					if (bDataEmpty == false)
 					{
 						//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite section offset the same and data is NOT empty\n"));
 
@@ -1969,31 +1969,31 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 						//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite section data empty\n"));
 
 						match_word_en = 0x0F;			//same bit as original wren
-						if(   !( (target_pkt.word_en&BIT0)|(tmp_pkt.word_en&BIT0)  ))
+						if (   !( (target_pkt.word_en&BIT0)|(tmp_pkt.word_en&BIT0)  ))
 						{
 							 match_word_en &= (~BIT0);
 						}
-						if(   !( (target_pkt.word_en&BIT1)|(tmp_pkt.word_en&BIT1)  ))
+						if (   !( (target_pkt.word_en&BIT1)|(tmp_pkt.word_en&BIT1)  ))
 						{
 							 match_word_en &= (~BIT1);
 						}
-						if(   !( (target_pkt.word_en&BIT2)|(tmp_pkt.word_en&BIT2)  ))
+						if (   !( (target_pkt.word_en&BIT2)|(tmp_pkt.word_en&BIT2)  ))
 						{
 							 match_word_en &= (~BIT2);
 						}
-						if(   !( (target_pkt.word_en&BIT3)|(tmp_pkt.word_en&BIT3)  ))
+						if (   !( (target_pkt.word_en&BIT3)|(tmp_pkt.word_en&BIT3)  ))
 						{
 							 match_word_en &= (~BIT3);
 						}
 
 						//************  so-2-2-A *******************
-						if((match_word_en&0x0F)!=0x0F)
+						if ((match_word_en&0x0F)!=0x0F)
 						{
 							badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1, tmp_pkt.word_en ,target_pkt.data, bPseudoTest);
 
 							//************  so-2-2-A-1 *******************
 							//############################
-							if(0x0F != (badworden&0x0F))
+							if (0x0F != (badworden&0x0F))
 							{
 								u8	reorg_offset = offset;
 								u8	reorg_worden=badworden;
@@ -2002,25 +2002,25 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 							//############################
 
 							tmp_word_en = 0x0F;		//not the same bit as original wren
-							if(  (target_pkt.word_en&BIT0)^(match_word_en&BIT0)  )
+							if (  (target_pkt.word_en&BIT0)^(match_word_en&BIT0)  )
 							{
 								tmp_word_en &= (~BIT0);
 							}
-							if(   (target_pkt.word_en&BIT1)^(match_word_en&BIT1) )
+							if (   (target_pkt.word_en&BIT1)^(match_word_en&BIT1) )
 							{
 								tmp_word_en &=  (~BIT1);
 							}
-							if(   (target_pkt.word_en&BIT2)^(match_word_en&BIT2) )
+							if (   (target_pkt.word_en&BIT2)^(match_word_en&BIT2) )
 							{
 								tmp_word_en &= (~BIT2);
 							}
-							if(   (target_pkt.word_en&BIT3)^(match_word_en&BIT3) )
+							if (   (target_pkt.word_en&BIT3)^(match_word_en&BIT3) )
 							{
 								tmp_word_en &=(~BIT3);
 							}
 
 							//************  so-2-2-A-2 *******************
-							if((tmp_word_en&0x0F)!=0x0F){
+							if ((tmp_word_en&0x0F)!=0x0F){
 								//reorganize other pg packet
 //								efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr
 								efuse_addr = Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest);
@@ -2034,7 +2034,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 #if (EFUSE_ERROE_HANDLE == 1)
 							WriteState=PG_STATE_HEADER;
 							repeat_times++;
-							if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
+							if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
 								bContinual = false;
 								bResult = false;
 							}
@@ -2059,7 +2059,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 			{
 				bExtendedHeader = false;
 
-				if(target_pkt.offset >= EFUSE_MAX_SECTION_BASE)
+				if (target_pkt.offset >= EFUSE_MAX_SECTION_BASE)
 				{
 					pg_header = ((target_pkt.offset &0x07) << 5) | 0x0F;
 
@@ -2074,7 +2074,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 
 						repeat_times++;
 
-						if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
+						if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
 							bContinual = false;
 							bResult = false;
 							efuse_addr++;
@@ -2084,10 +2084,10 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 						efuse_OneByteRead(pAdapter,efuse_addr, &tmp_header, bPseudoTest);
 					}
 
-					if(!bContinual)
+					if (!bContinual)
 						break;
 
-					if(tmp_header == pg_header)
+					if (tmp_header == pg_header)
 					{
 						efuse_addr++;
 						pg_header_temp = pg_header;
@@ -2102,7 +2102,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 						{
 							repeat_times++;
 
-							if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
+							if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
 								bContinual = false;
 								bResult = false;
 								break;
@@ -2111,14 +2111,14 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 							efuse_OneByteRead(pAdapter,efuse_addr, &tmp_header, bPseudoTest);
 						}
 
-						if(!bContinual)
+						if (!bContinual)
 							break;
 
-						if((tmp_header & 0x0F) == 0x0F)	//wren PG fail
+						if ((tmp_header & 0x0F) == 0x0F)	//wren PG fail
 						{
 							repeat_times++;
 
-							if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
+							if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
 								bContinual = false;
 								bResult = false;
 								break;
@@ -2129,7 +2129,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 								continue;
 							}
 						}
-						else if(pg_header != tmp_header)	//offset PG fail
+						else if (pg_header != tmp_header)	//offset PG fail
 						{
 							bExtendedHeader = true;
 							tmp_pkt.offset = ((pg_header_temp & 0xE0) >> 5) | ((tmp_header & 0xF0) >> 1);
@@ -2150,16 +2150,16 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 					efuse_OneByteRead(pAdapter,efuse_addr, &tmp_header, bPseudoTest);
 				}
 
-				if(tmp_header == pg_header)
+				if (tmp_header == pg_header)
 				{ //************  s1-1*******************
 					WriteState = PG_STATE_DATA;
 				}
 #if (EFUSE_ERROE_HANDLE == 1)
-				else if(tmp_header == 0xFF){//************  s1-3: if Write or read func doesn't work *******************
+				else if (tmp_header == 0xFF){//************  s1-3: if Write or read func doesn't work *******************
 					//efuse_addr doesn't change
 					WriteState = PG_STATE_HEADER;
 					repeat_times++;
-					if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
+					if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
 						bContinual = false;
 						bResult = false;
 					}
@@ -2167,7 +2167,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 #endif
 				else
 				{//************  s1-2 : fixed the header procedure *******************
-					if(!bExtendedHeader)
+					if (!bExtendedHeader)
 					{
 						tmp_pkt.offset = (tmp_header>>4) & 0x0F;
 						tmp_pkt.word_en=  tmp_header & 0x0F;
@@ -2178,12 +2178,12 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 					//memset(originaldata,0xff,sizeof(UINT8)*8);
 					memset((void *)originaldata, 0xff, sizeof(u8)*8);
 
-					if(Efuse_PgPacketRead( pAdapter, tmp_pkt.offset,originaldata, bPseudoTest))
+					if (Efuse_PgPacketRead( pAdapter, tmp_pkt.offset,originaldata, bPseudoTest))
 					{	//check if data exist
 						//efuse_reg_ctrl(pAdapter,true);//power on
 						badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,tmp_pkt.word_en,originaldata, bPseudoTest);
 						//############################
-						if(0x0F != (badworden&0x0F))
+						if (0x0F != (badworden&0x0F))
 						{
 							u8	reorg_offset = tmp_pkt.offset;
 							u8	reorg_worden=badworden;
@@ -2204,7 +2204,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 #if (EFUSE_ERROE_HANDLE == 1)
 					WriteState=PG_STATE_HEADER;
 					repeat_times++;
-					if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
+					if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
 						bContinual = false;
 						bResult = false;
 					}
@@ -2217,12 +2217,12 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 
 		}
 		//write data state
-		else if(WriteState==PG_STATE_DATA)
+		else if (WriteState==PG_STATE_DATA)
 		{	//************  s1-1  *******************
 			//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE PG_STATE_DATA\n"));
 			badworden = 0x0f;
 			badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,target_pkt.word_en,target_pkt.data , bPseudoTest);
-			if((badworden&0x0F)==0x0F)
+			if ((badworden&0x0F)==0x0F)
 			{ //************  s1-1-A *******************
 				bContinual = false;
 			}
@@ -2238,7 +2238,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 #if (EFUSE_ERROE_HANDLE == 1)
 				WriteState=PG_STATE_HEADER;
 				repeat_times++;
-				if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
+				if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
 					bContinual = false;
 					bResult = false;
 				}
@@ -2248,7 +2248,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 		}
 	}
 
-	if(efuse_addr  >= (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))
+	if (efuse_addr  >= (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))
 	{
 		//RT_TRACE(COMP_EFUSE, DBG_LOUD, ("efuse_PgPacketWrite(): efuse_addr(%#x) Out of size!!\n", efuse_addr));
 	}
@@ -2275,7 +2275,7 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 
 	//RT_PRINT_DATA(COMP_EFUSE, DBG_LOUD, ("U-EFUSE\n"), data, 8);
 
-	if(!(word_en&BIT0))
+	if (!(word_en&BIT0))
 	{
 		tmpaddr = start_addr;
 		efuse_OneByteWrite(pAdapter,start_addr++, data[0], bPseudoTest);
@@ -2283,11 +2283,11 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 
 		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[0], bPseudoTest);
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[1], bPseudoTest);
-		if((data[0]!=tmpdata[0])||(data[1]!=tmpdata[1])){
+		if ((data[0]!=tmpdata[0])||(data[1]!=tmpdata[1])){
 			badworden &= (~BIT0);
 		}
 	}
-	if(!(word_en&BIT1))
+	if (!(word_en&BIT1))
 	{
 		tmpaddr = start_addr;
 		efuse_OneByteWrite(pAdapter,start_addr++, data[2], bPseudoTest);
@@ -2295,11 +2295,11 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 
 		efuse_OneByteRead(pAdapter,tmpaddr    , &tmpdata[2], bPseudoTest);
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[3], bPseudoTest);
-		if((data[2]!=tmpdata[2])||(data[3]!=tmpdata[3])){
+		if ((data[2]!=tmpdata[2])||(data[3]!=tmpdata[3])){
 			badworden &=( ~BIT1);
 		}
 	}
-	if(!(word_en&BIT2))
+	if (!(word_en&BIT2))
 	{
 		tmpaddr = start_addr;
 		efuse_OneByteWrite(pAdapter,start_addr++, data[4], bPseudoTest);
@@ -2307,11 +2307,11 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 
 		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[4], bPseudoTest);
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[5], bPseudoTest);
-		if((data[4]!=tmpdata[4])||(data[5]!=tmpdata[5])){
+		if ((data[4]!=tmpdata[4])||(data[5]!=tmpdata[5])){
 			badworden &=( ~BIT2);
 		}
 	}
-	if(!(word_en&BIT3))
+	if (!(word_en&BIT3))
 	{
 		tmpaddr = start_addr;
 		efuse_OneByteWrite(pAdapter,start_addr++, data[6], bPseudoTest);
@@ -2319,7 +2319,7 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 
 		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[6], bPseudoTest);
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[7], bPseudoTest);
-		if((data[6]!=tmpdata[6])||(data[7]!=tmpdata[7])){
+		if ((data[6]!=tmpdata[6])||(data[7]!=tmpdata[7])){
 			badworden &=( ~BIT3);
 		}
 	}
--- a/drivers/staging/rtl8192du/hal/rtl8192d_mp.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_mp.c
@@ -257,7 +257,7 @@ void Hal_SetAntenna(PADAPTER pAdapter)
 			PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable, 0x0000000f, r_rx_antenna_ofdm);	//OFDM Rx
 			PHY_SetBBReg(pAdapter, rOFDM1_TRxPathEnable, 0x0000000f, r_rx_antenna_ofdm);	//OFDM Rx
 			PHY_SetBBReg(pAdapter, rCCK0_AFESetting, bMaskByte3, r_ant_select_cck_val);//r_ant_sel_cck_val);		//CCK TxRx
-			if(pHalData->CurrentBandType92D == BAND_ON_2_4G || IS_92D_SINGLEPHY(pHalData->VersionID))
+			if (pHalData->CurrentBandType92D == BAND_ON_2_4G || IS_92D_SINGLEPHY(pHalData->VersionID))
 					rtw_write8(pAdapter, rCCK0_AFESetting+3, r_ant_select_cck_val);
 			break;
 		default:
@@ -309,14 +309,14 @@ void Hal_SetCarrierSuppressionTx(PADAPTE
     PMPT_CONTEXT	pMptCtx = &pAdapter->mppriv.MptCtx;
 
 
-    if(bStart)
+    if (bStart)
     { // Start Carrier Suppression.
-        //if(pMgntInfo->dot11CurrentWirelessMode == WIRELESS_MODE_B)
-        if( pMptCtx->MptRateIndex >= MPT_RATE_1M &&
+        //if (pMgntInfo->dot11CurrentWirelessMode == WIRELESS_MODE_B)
+        if ( pMptCtx->MptRateIndex >= MPT_RATE_1M &&
             pMptCtx->MptRateIndex <= MPT_RATE_11M )
         { // Start CCK Carrier Suppression
             // 1. if CCK block on?
-            if(!PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bCCKEn))
+            if (!PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bCCKEn))
                 PHY_SetBBReg(pAdapter, rFPGA0_RFMOD, bCCKEn, bEnable);//set CCK block on
 
             //Turn Off All Test Mode
@@ -333,8 +333,8 @@ void Hal_SetCarrierSuppressionTx(PADAPTE
     }
     else
     { // Stop Carrier Suppression.
-        //if(pMgntInfo->dot11CurrentWirelessMode == WIRELESS_MODE_B)
-        if( pMptCtx->MptRateIndex >= MPT_RATE_1M &&
+        //if (pMgntInfo->dot11CurrentWirelessMode == WIRELESS_MODE_B)
+        if ( pMptCtx->MptRateIndex >= MPT_RATE_1M &&
             pMptCtx->MptRateIndex <= MPT_RATE_11M )
         { // Stop Carrier Suppression
             PHY_SetBBReg(pAdapter, rCCK0_System, bCCKBBMode, 0x0);    //normal mode
@@ -368,13 +368,13 @@ void Hal_SetSingleToneTx ( PADAPTER pAda
             rfPath = RF_PATH_A;
             break;
     }
-    if(bStart)
+    if (bStart)
     {   // Start Single Tone.
 
 	RT_TRACE(_module_mp_,_drv_alert_, ("SetSingleToneTx: test start\n"));
 		write_bbreg(pAdapter, rFPGA0_RFMOD, bCCKEn, 0x0);
 		write_bbreg(pAdapter, rFPGA0_RFMOD, bOFDMEn, 0x0);
-		if(is92C)
+		if (is92C)
 	{
 			_write_rfreg(pAdapter, RF_PATH_A, 0x21, BIT19, 0x01);
 			rtw_usleep_os(100);
@@ -401,7 +401,7 @@ void Hal_SetSingleToneTx ( PADAPTER pAda
 		write_bbreg(pAdapter, rFPGA0_RFMOD, bCCKEn, 0x1);
 		write_bbreg(pAdapter, rFPGA0_RFMOD, bOFDMEn, 0x1);
 
-		if(is92C)
+		if (is92C)
 		{
 			_write_rfreg(pAdapter, RF_PATH_A, 0x21, BIT19, 0x00);
 			rtw_usleep_os(100);
@@ -498,7 +498,7 @@ void Hal_SetTxPower (PADAPTER pAdapter)
 
 	for(rf=0; rf<2; rf++)
 	{
-		if(IS_HARDWARE_TYPE_8192D(pAdapter))
+		if (IS_HARDWARE_TYPE_8192D(pAdapter))
 		{
 			//RT_TRACE(COMP_MP, DBG_LOUD, ("antenna settings txpath 0x%x\n", pHalData->AntennaTxPath));
 			switch(pHalData->AntennaTxPath)
@@ -542,10 +542,10 @@ void Hal_SetSingleCarrierTx (PADAPTER pA
     if ( bStart )
     {// Start Single Carrier.
         // 1. if OFDM block on?
-        if(!PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
+        if (!PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
             PHY_SetBBReg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);//set OFDM block on
 
-        if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+        if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
         {
             // 2. set CCK test mode off, set to CCK normal mode
             PHY_SetBBReg(pAdapter, rCCK0_System, bCCKBBMode, bDisable);
@@ -584,7 +584,7 @@ static  void Hal_mpt_StartCckContTx(PADA
     u32          cckrate;
 
     // 1. if CCK block on?
-    if(!PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bCCKEn))
+    if (!PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bCCKEn))
         PHY_SetBBReg(pAdapter, rFPGA0_RFMOD, bCCKEn, bEnable);//set CCK block on
 
     //Turn Off All Test Mode
@@ -651,10 +651,10 @@ static  void Hal_mpt_StartOfdmContTx( PA
     //u1Byte            OfdmTxAGC;
 
     // 1. if OFDM block on?
-    if(!PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
+    if (!PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
         PHY_SetBBReg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);//set OFDM block on
 
-    if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+    if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
     {
         // 2. set CCK test mode off, set to CCK normal mode
         PHY_SetBBReg(pAdapter, rCCK0_System, bCCKBBMode, bDisable);
@@ -702,12 +702,12 @@ void Hal_SetContinuousTx (PADAPTER pAdap
     HAL_DATA_TYPE       *pHalData   = GET_HAL_DATA(pAdapter);
     PMPT_CONTEXT        pMptCtx = &(pAdapter->mppriv.MptCtx);
 
-    if(bStart)
+    if (bStart)
     { // Start Continuous Tx.
-        if( pAdapter->mppriv.rateidx >= MPT_RATE_1M &&
+        if ( pAdapter->mppriv.rateidx >= MPT_RATE_1M &&
             pAdapter->mppriv.rateidx <= MPT_RATE_11M )
             Hal_mpt_StartCckContTx(pAdapter, true);
-        else if(pAdapter->mppriv.rateidx >= MPT_RATE_6M &&
+        else if (pAdapter->mppriv.rateidx >= MPT_RATE_6M &&
                 pAdapter->mppriv.rateidx <= MPT_RATE_MCS15 )
             Hal_mpt_StartOfdmContTx(pAdapter);
         else
@@ -724,15 +724,15 @@ void Hal_SetContinuousTx (PADAPTER pAdap
         bool bCckContTx = pMptCtx->bCckContTx;
         bool bOfdmContTx = pMptCtx->bOfdmContTx;
 
-        if(bCckContTx == true && bOfdmContTx == false)
+        if (bCckContTx == true && bOfdmContTx == false)
         { // Stop CCK Continuous Tx.
             Hal_mpt_StopCckCoNtTx(pAdapter);
         }
-        else if(bCckContTx == false && bOfdmContTx == true)
+        else if (bCckContTx == false && bOfdmContTx == true)
         { // Stop OFDM Continuous Tx.
             Hal_mpt_StopOfdmContTx(pAdapter);
         }
-        else if(bCckContTx == false && bOfdmContTx == false)
+        else if (bCckContTx == false && bOfdmContTx == false)
         { // We've already stopped Continuous Tx.
         }
         else
@@ -764,9 +764,9 @@ u4Byte RT8192DU_Reg_Offset_Conver(PADAPT
 {
 	//if (Adapter->interfaceIndex!=0)
 	//{
-		if(offset < 0x1000)
+		if (offset < 0x1000)
 			offset|=0x4000;
-		else if( (offset&MAC1_ACCESS_PHY0) && !(offset&0x8000))// MAC1 need to access PHY0
+		else if ( (offset&MAC1_ACCESS_PHY0) && !(offset&0x8000))// MAC1 need to access PHY0
 			offset &= 0xFFF;
 	//}
 
@@ -842,7 +842,7 @@ PHY_PowerDownAnotherPHY(
 	{
 
 		// power down RF radio A according to YuNan's advice.
-		if(bMac0)
+		if (bMac0)
 			MaskforPhySet = MAC0_ACCESS_PHY1;
 		else
 			MaskforPhySet = MAC1_ACCESS_PHY0;
@@ -869,7 +869,7 @@ PHY_EnableAnotherPHY(
 
 	  if (!(u1bTmp&MAC_ON_BIT)) {
 	   // Enable BB and RF power
-		if(bMac0)
+		if (bMac0)
 			MaskForPHYSet = MAC0_ACCESS_PHY1;
 		else
 			MaskForPHYSet = MAC1_ACCESS_PHY0;
@@ -983,11 +983,11 @@ static u8 GetRightChnlPlace(u8 chnl)
 	u8	channel_5G[TARGET_CHNL_NUM_2G_5G] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
 	u8	place = chnl;
 
-	if(chnl > 14)
+	if (chnl > 14)
 	{
 		for(place = 14; place<sizeof(channel_5G); place++)
 		{
-			if(channel_5G[place] == chnl)
+			if (channel_5G[place] == chnl)
 			{
 				place++;
 				break;
@@ -1014,56 +1014,56 @@ void
 	u32		Regb30 = PHY_QueryBBReg(Adapter, 0xb30, BIT27);
 
 	//only for 92D SMSP >= C-cut
-	if(!IS_HARDWARE_TYPE_8192D(Adapter))
+	if (!IS_HARDWARE_TYPE_8192D(Adapter))
 		return;
 
 	//config path A for 5G
-	if(pHalData->CurrentBandType92D == BAND_ON_5G)
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 	{
 		u4tmp = CurveIndex[GetRightChnlPlace(channel)-1];
 
 		for(i = 0; i < RF_CHNL_NUM_5G; i++) {
-			if(channel == RF_CHNL_5G[i] && channel <= 140)
+			if (channel == RF_CHNL_5G[i] && channel <= 140)
 				index = 0;
 		}
 
 		for(i = 0; i < RF_CHNL_NUM_5G_40M; i++) {
-			if(channel == RF_CHNL_5G_40M[i] && channel <= 140)
+			if (channel == RF_CHNL_5G_40M[i] && channel <= 140)
 				index = 1;
 		}
 
-		if(channel ==149 || channel == 155 || channel ==161)
+		if (channel ==149 || channel == 155 || channel ==161)
 			index = 2;
-		else if(channel == 151 || channel == 153 || channel == 163 || channel == 165)
+		else if (channel == 151 || channel == 153 || channel == 163 || channel == 165)
 			index = 3;
-		else if(channel == 157 || channel == 159 )
+		else if (channel == 157 || channel == 159 )
 			index = 4;
 
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
 		{
 			bNeedPowerDownRadio = PHY_EnableAnotherPHY(Adapter, false);
 			MaskforPhySet = MAC1_ACCESS_PHY0;
 			//asume no this case
-			if(bNeedPowerDownRadio)
+			if (bNeedPowerDownRadio)
 				phy_EnableRFENV(Adapter, path, MaskforPhySet, &u4RegValue);
 		}
 
 		//DMDP, if band = 5G,Mac0 need to set PHY1 when regB30[27]=1
-		if(Regb30 && pHalData->interfaceIndex == 0)
+		if (Regb30 && pHalData->interfaceIndex == 0)
 		{
 			//RT_TRACE(COMP_MLME, DBG_LOUD, ("===============phy_SwitchRfSetting8192D interface %ld,B30&BIT27=1!!!!\n", Adapter->interfaceIndex));
 
 			bNeedPowerDownRadio = PHY_EnableAnotherPHY(Adapter, true);
 			MaskforPhySet= MAC0_ACCESS_PHY1;
 			//asume no this case
-			if(bNeedPowerDownRadio)
+			if (bNeedPowerDownRadio)
 				phy_EnableRFENV(Adapter, path, MaskforPhySet, &u4RegValue);
 		}
 
 		for(i = 0; i < RF_REG_NUM_for_C_CUT_5G; i++)
 		{
 #if 1
-			if(i == 0 && (pHalData->MacPhyMode92D == DUALMAC_DUALPHY))
+			if (i == 0 && (pHalData->MacPhyMode92D == DUALMAC_DUALPHY))
 			{
 				PHY_SetRFReg(Adapter, path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, 0xE439D);
 			}
@@ -1072,7 +1072,7 @@ void
 #if SWLCK == 1
 				u4tmp2= (RF_REG_Param_for_C_CUT_5G[index][i]&0x7FF)|(u4tmp << 11);
 
-				if(channel == 36)
+				if (channel == 36)
 					u4tmp2 &= ~(BIT7|BIT6);
 
 				PHY_SetRFReg(Adapter, path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, u4tmp2);
@@ -1086,7 +1086,7 @@ void
 				PHY_SetRFReg(Adapter, path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, RF_REG_Param_for_C_CUT_5G[index][i]);
 			}
 #else
-			if(i == 0 && (pHalData->MacPhyMode92D == DUALMAC_DUALPHY))
+			if (i == 0 && (pHalData->MacPhyMode92D == DUALMAC_DUALPHY))
 				PHY_SetRFReg(Adapter, path, RF_REG_for_C_CUT_5G[i], RF_REG_MASK_for_C_CUT_5G[i], 0xE439D);
 			else
 				PHY_SetRFReg(Adapter, path, RF_REG_for_C_CUT_5G[i], RF_REG_MASK_for_C_CUT_5G[i], RF_REG_Param_for_C_CUT_5G[index][i]);
@@ -1097,49 +1097,49 @@ void
 
 		}
 
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
 		{
-			if(bNeedPowerDownRadio)
+			if (bNeedPowerDownRadio)
 			{
 				phy_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
 			PHY_PowerDownAnotherPHY(Adapter, false);
 		}
 
-		if(Regb30 && pHalData->interfaceIndex == 0)
+		if (Regb30 && pHalData->interfaceIndex == 0)
 		{
-			if(bNeedPowerDownRadio)
+			if (bNeedPowerDownRadio)
 			{
 				phy_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
 			PHY_PowerDownAnotherPHY(Adapter, true);
 		}
 
-		if(channel < 149)
+		if (channel < 149)
 			value = 0x07;
-		else if(channel >= 149)
+		else if (channel >= 149)
 			value = 0x02;
 
-		if(channel >= 36 && channel <= 64)
+		if (channel >= 36 && channel <= 64)
 			index = 0;
-		else if(channel >=100 && channel <= 140)
+		else if (channel >=100 && channel <= 140)
 			index = 1;
 		else
 			index = 2;
 
 		for(eRFPath = RF_PATH_A; eRFPath < pHalData->NumTotalRFPath; eRFPath++)
 		{
-			if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY &&
+			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY &&
 				pHalData->interfaceIndex == 1)		//MAC 1 5G
 				bInteralPA = pHalData->InternalPA5G[1];
 			else
 				bInteralPA = pHalData->InternalPA5G[eRFPath];
 
-			if(bInteralPA)
+			if (bInteralPA)
 			{
 				for(i = 0; i < RF_REG_NUM_for_C_CUT_5G_internalPA; i++)
 				{
-					if(RF_REG_for_C_CUT_5G_internalPA[i] == 0x03 &&
+					if (RF_REG_for_C_CUT_5G_internalPA[i] == 0x03 &&
 						channel >=36 && channel <=64)
 						PHY_SetRFReg(Adapter, eRFPath, RF_REG_for_C_CUT_5G_internalPA[i], bRFRegOffsetMask, 0x7bdef);
 					else
@@ -1153,40 +1153,40 @@ void
 		}
 
 	}
-	else if(pHalData->CurrentBandType92D==BAND_ON_2_4G)
+	else if (pHalData->CurrentBandType92D==BAND_ON_2_4G)
 	{
 		//RT_TRACE(COMP_CMD, DBG_LOUD, ("====>phy_SwitchRfSetting8192D interface %d 2.4G\n", Adapter->interfaceIndex));
 		//u4tmp = CurveIndex[channel-1];
 		//RT_DISP(FINIT, INIT_IQK, ("ver 3 set RF-B, 2G, 0x28 = 0x%x !!\n", u4tmp));
 
-		if(channel == 1 || channel == 2 || channel ==4 || channel == 9 || channel == 10 ||
+		if (channel == 1 || channel == 2 || channel ==4 || channel == 9 || channel == 10 ||
 			channel == 11 || channel ==12)
 			index = 0;
-		else if(channel ==3 || channel == 13 || channel == 14)
+		else if (channel ==3 || channel == 13 || channel == 14)
 			index = 1;
-		else if(channel >= 5 && channel <= 8)
+		else if (channel >= 5 && channel <= 8)
 			index = 2;
 
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
 		{
 			path = RF_PATH_A;
-			if(pHalData->interfaceIndex == 0)
+			if (pHalData->interfaceIndex == 0)
 			{
 				bNeedPowerDownRadio = PHY_EnableAnotherPHY(Adapter, true);
 				MaskforPhySet = MAC0_ACCESS_PHY1;
-				if(bNeedPowerDownRadio)
+				if (bNeedPowerDownRadio)
 					phy_EnableRFENV(Adapter, path,MaskforPhySet,&u4RegValue);
 			}
 
 			//DMDP, if band = 2G,MAC1 need to set PHY0 when regB30[27]=1
-			if(Regb30 && pHalData->interfaceIndex == 1)
+			if (Regb30 && pHalData->interfaceIndex == 1)
 			{
 				//RT_TRACE(COMP_MLME, DBG_LOUD, ("===============phy_SwitchRfSetting8192D interface %ld,B30&BIT27=1!!!!\n", Adapter->interfaceIndex));
 
 				bNeedPowerDownRadio = PHY_EnableAnotherPHY(Adapter, false);
 				MaskforPhySet= MAC1_ACCESS_PHY0;
 				//asume no this case
-				if(bNeedPowerDownRadio)
+				if (bNeedPowerDownRadio)
 					phy_EnableRFENV(Adapter, path,MaskforPhySet,&u4RegValue);
 			}
 		}
@@ -1216,17 +1216,17 @@ void
 		PHY_SetRFReg(Adapter, path, RF_SYN_G4|MaskforPhySet, bRFRegOffsetMask, RF_REG_SYN_G4_for_C_CUT_2G | (u4tmp << 11));
 #endif
 
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
 		{
-			if(bNeedPowerDownRadio){
+			if (bNeedPowerDownRadio){
 				phy_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
 			PHY_PowerDownAnotherPHY(Adapter, true);
 		}
 
-		if(Regb30 && pHalData->interfaceIndex == 1)
+		if (Regb30 && pHalData->interfaceIndex == 1)
 		{
-			if(bNeedPowerDownRadio)
+			if (bNeedPowerDownRadio)
 			{
 				phy_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
@@ -1269,13 +1269,13 @@ void Hal_mpt_SwitchRfSetting(PADAPTER pA
 
     for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
     {
-        if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY &&
+        if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY &&
             pHalData->interfaceIndex == 1)      //MAC 1 5G
             bInteralPA = pHalData->InternalPA5G[1];
         else
             bInteralPA = pHalData->InternalPA5G[eRFPath];
 
-        if(!bInteralPA ||  pHalData->CurrentBandType92D==BAND_ON_2_4G)
+        if (!bInteralPA ||  pHalData->CurrentBandType92D==BAND_ON_2_4G)
 		_write_rfreg(pAdapter, (RF_RADIO_PATH_E)eRFPath, 0x03, bRFRegOffsetMask, value);
     }
  #endif
@@ -1302,13 +1302,13 @@ void MPT_CCKTxPowerAdjust(PADAPTER Adapt
 
 	CurrCCKSwingVal = PHY_QueryBBReg(Adapter, rCCK0_TxFilter1, bMaskHWord);
 
-	if(!bInCH14)
+	if (!bInCH14)
 	{
 		// Readback the current bb cck swing value and compare with the table to
 		// get the current swing index
 		for(i=0 ; i<CCK_TABLE_SIZE ; i++)
 		{
-			if( ((CurrCCKSwingVal&0xff) == (u4Byte)CCKSwingTable_Ch1_Ch13[i][0]) &&
+			if ( ((CurrCCKSwingVal&0xff) == (u4Byte)CCKSwingTable_Ch1_Ch13[i][0]) &&
 				( ((CurrCCKSwingVal&0xff00)>>8) == (u4Byte)CCKSwingTable_Ch1_Ch13[i][1]) )
 			{
 				CCKSwingIndex = i;
@@ -1340,7 +1340,7 @@ void MPT_CCKTxPowerAdjust(PADAPTER Adapt
 	{
 		for(i=0 ; i<CCK_TABLE_SIZE ; i++)
 		{
-			if( ((CurrCCKSwingVal&0xff) == (u4Byte)CCKSwingTable_Ch14[i][0]) &&
+			if ( ((CurrCCKSwingVal&0xff) == (u4Byte)CCKSwingTable_Ch14[i][0]) &&
 				( ((CurrCCKSwingVal&0xff00)>>8) == (u4Byte)CCKSwingTable_Ch14[i][1]) )
 			{
 				CCKSwingIndex = i;
@@ -1396,7 +1396,7 @@ void Hal_SetChannel(PADAPTER pAdapter)
 	// set RF channel register
 	for (eRFPath = 0; eRFPath < pHalData->NumTotalRFPath; eRFPath++)
 	{
-	  if(IS_HARDWARE_TYPE_8192D(pAdapter))
+	  if (IS_HARDWARE_TYPE_8192D(pAdapter))
 			_write_rfreg(pAdapter, (RF_RADIO_PATH_E)eRFPath, rRfChannel, 0xFF, channel);
 		else
 			_write_rfreg(pAdapter, eRFPath, rRfChannel, 0x3FF, channel);
@@ -1525,7 +1525,7 @@ void Hal_SetOFDMContinuousTx(PADAPTER pA
 	if (bStart) {
 		RT_TRACE(_module_mp_, _drv_info_, ("SetOFDMContinuousTx: test start\n"));
 		// 1. if OFDM block on?
-		if(!read_bbreg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
+		if (!read_bbreg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
 			write_bbreg(pAdapter, rFPGA0_RFMOD, bOFDMEn, bEnable);//set OFDM block on
 		{
 
@@ -1566,7 +1566,7 @@ void Hal_SetCCKContinuousTx(PADAPTER pAd
 			 ("SetCCKContinuousTx: test start\n"));
 
 		// 1. if CCK block on?
-		if(!read_bbreg(pAdapter, rFPGA0_RFMOD, bCCKEn))
+		if (!read_bbreg(pAdapter, rFPGA0_RFMOD, bCCKEn))
 			write_bbreg(pAdapter, rFPGA0_RFMOD, bCCKEn, bEnable);//set CCK block on
 
 		//Turn Off All Test Mode
@@ -1621,7 +1621,7 @@ void Hal_ProSetCrystalCap (PADAPTER pAda
 {
 	HAL_DATA_TYPE		*pHalData	= GET_HAL_DATA(pAdapter);
 
-	if(!IS_HARDWARE_TYPE_8192D(pAdapter))
+	if (!IS_HARDWARE_TYPE_8192D(pAdapter))
 		return;
 
 	//CrystalCap = pHalData->CrystalCap;
--- a/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
@@ -118,11 +118,11 @@ static u8 GetRightChnlPlace(u8 chnl)
 	u8	channel_5G[TARGET_CHNL_NUM_2G_5G] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
 	u8	place = chnl;
 
-	if(chnl > 14)
+	if (chnl > 14)
 	{
 		for(place = 14; place<sizeof(channel_5G); place++)
 		{
-			if(channel_5G[place] == chnl)
+			if (channel_5G[place] == chnl)
 			{
 				place++;
 				break;
@@ -146,11 +146,11 @@ u8 rtl8192d_GetRightChnlPlaceforIQK(u8 c
 	u8	place = chnl;
 
 
-	if(chnl > 14)
+	if (chnl > 14)
 	{
 		for(place = 14; place<sizeof(channel_all); place++)
 		{
-			if(channel_all[place] == chnl)
+			if (channel_all[place] == chnl)
 			{
 				return place-13;
 			}
@@ -287,7 +287,7 @@ rtl8192d_PHY_SetBBReg(
 	return;
 #endif
 
-	if(BitMask!= bMaskDWord)
+	if (BitMask!= bMaskDWord)
 	{//if not "double word" write
 		OriginalValue = rtw_read32(Adapter, RegAddr);
 		BitShift = phy_CalculateBitShift(BitMask);
@@ -393,9 +393,9 @@ phy_RFSerialRead(
 	//
 	// Make sure RF register offset is correct
 	//
-	if(Offset & MAC1_ACCESS_PHY0)
+	if (Offset & MAC1_ACCESS_PHY0)
 		MaskforPhySet = MAC1_ACCESS_PHY0;
-	else if(Offset & MAC0_ACCESS_PHY1)
+	else if (Offset & MAC0_ACCESS_PHY1)
 		MaskforPhySet = MAC0_ACCESS_PHY1;
 
 	Offset &=0x7F;
@@ -406,7 +406,7 @@ phy_RFSerialRead(
 	NewOffset = Offset;
 
 	// 2009/06/17 MH We can not execute IO for power save or other accident mode.
-	//if(RT_CANNOT_IO(Adapter))
+	//if (RT_CANNOT_IO(Adapter))
 	//{
 	//	RTPRINT(FPHY, PHY_RFR, ("phy_RFSerialRead return all one\n"));
 	//	return	0xFFFFFFFF;
@@ -416,7 +416,7 @@ phy_RFSerialRead(
 	// For RF A/B write 0x824/82c(does not work in the future)
 	// We must use 0x824 for RF A and B to execute read trigger
 	tmplong = PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord);
-	if(eRFPath == RF_PATH_A)
+	if (eRFPath == RF_PATH_A)
 		tmplong2 = tmplong;
 	else
 		tmplong2 = PHY_QueryBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, bMaskDWord);
@@ -433,12 +433,12 @@ phy_RFSerialRead(
 	PHY_SetBBReg(Adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord, tmplong|bLSSIReadEdge);
 	rtw_udelay_os(10);
 
-	if(eRFPath == RF_PATH_A)
+	if (eRFPath == RF_PATH_A)
 		RfPiEnable = (u8)PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter1|MaskforPhySet, BIT8);
-	else if(eRFPath == RF_PATH_B)
+	else if (eRFPath == RF_PATH_B)
 		RfPiEnable = (u8)PHY_QueryBBReg(Adapter, rFPGA0_XB_HSSIParameter1|MaskforPhySet, BIT8);
 
-	if(RfPiEnable)
+	if (RfPiEnable)
 	{	// Read from BBreg8b8, 12 bits for 8190, 20bits for T65 RF
 		retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBackPi|MaskforPhySet, bLSSIReadBackData);
 		//RTPRINT(FINIT, INIT_RF, ("Readback from RF-PI : 0x%x\n", retValue));
@@ -514,15 +514,15 @@ phy_RFSerialWrite(
 
 
 	// 2009/06/17 MH We can not execute IO for power save or other accident mode.
-	//if(RT_CANNOT_IO(Adapter))
+	//if (RT_CANNOT_IO(Adapter))
 	//{
 	//	RTPRINT(FPHY, PHY_RFW, ("phy_RFSerialWrite stop\n"));
 	//	return;
 	//}
 
-	if(Offset & MAC1_ACCESS_PHY0)
+	if (Offset & MAC1_ACCESS_PHY0)
 		MaskforPhySet = MAC1_ACCESS_PHY0;
-	else if(Offset & MAC0_ACCESS_PHY1)
+	else if (Offset & MAC0_ACCESS_PHY1)
 		MaskforPhySet = MAC0_ACCESS_PHY1;
 
 	Offset &=0x7F;
@@ -587,10 +587,10 @@ rtl8192d_PHY_QueryRFReg(
 	return 0;
 #endif
 
-	if(!pHalData->bPhyValueInitReady)
+	if (!pHalData->bPhyValueInitReady)
 		return 0;
 
-	if(pHalData->bReadRFbyFW)
+	if (pHalData->bReadRFbyFW)
 		Original_Value = rtw_read32(Adapter,(0x66<<24|eRFPath<<16)|RegAddr ); //0x66 Just a identifier.by wl
 	else
 		Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
@@ -636,10 +636,10 @@ rtl8192d_PHY_SetRFReg(
 	return;
 #endif
 
-	if(!pHalData->bPhyValueInitReady)
+	if (!pHalData->bPhyValueInitReady)
 		return;
 
-	if(BitMask == 0)
+	if (BitMask == 0)
 		return;
 
 	// RF data is 12 bits only
@@ -754,7 +754,7 @@ PHY_MACConfig8192D(
 	char		sz92DMACRegFile[] = RTL8192D_PHY_MACREG;
 	int		rtStatus = _SUCCESS;
 
-	if(Adapter->bSurpriseRemoved){
+	if (Adapter->bSurpriseRemoved){
 		rtStatus = _FAIL;
 		return rtStatus;
 	}
@@ -773,7 +773,7 @@ PHY_MACConfig8192D(
 	rtStatus = phy_ConfigMACWithParaFile(Adapter, pszMACRegFile);
 #endif
 
-	if(pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY)
+	if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY)
 	{
 		//improve 2-stream TX EVM by Jenyu
 		//rtw_write8(Adapter, 0x14,0x71);
@@ -939,7 +939,7 @@ phy_ConfigBBWithHeaderFile(
 
 
 	//Normal chip,Mac0 use AGC_TAB.txt for 2G and 5G band.
-	if(pHalData->interfaceIndex == 0)
+	if (pHalData->interfaceIndex == 0)
 	{
 		AGCTAB_ArrayLen = Rtl8192D_AGCTAB_ArrayLength;
 		Rtl819XAGCTAB_Array_Table = (u32 *)Rtl8192D_AGCTAB_Array;
@@ -947,7 +947,7 @@ phy_ConfigBBWithHeaderFile(
 	}
 	else
 	{
-		if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+		if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 		{
 			AGCTAB_ArrayLen = Rtl8192D_AGCTAB_2GArrayLength;
 			Rtl819XAGCTAB_Array_Table = (u32 *)Rtl8192D_AGCTAB_2GArray;
@@ -965,7 +965,7 @@ phy_ConfigBBWithHeaderFile(
 	Rtl819XPHY_REGArray_Table = (u32 *)Rtl8192D_PHY_REG_2TArray;
 	//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> phy_ConfigBBWithHeaderFile() phy:Rtl819XPHY_REG_Array_PG\n"));
 
-	if(ConfigType == BaseBand_Config_PHY_REG)
+	if (ConfigType == BaseBand_Config_PHY_REG)
 	{
 		for(i=0;i<PHY_REGArrayLen;i=i+2)
 		{
@@ -996,10 +996,10 @@ phy_ConfigBBWithHeaderFile(
 			//RT_TRACE(COMP_INIT, DBG_TRACE, ("The Rtl819XPHY_REGArray_Table[0] is %lx Rtl819XPHY_REGArray[1] is %lx \n",Rtl819XPHY_REGArray_Table[i], Rtl819XPHY_REGArray_Table[i+1]));
 		}
 	}
-	else if(ConfigType == BaseBand_Config_AGC_TAB)
+	else if (ConfigType == BaseBand_Config_AGC_TAB)
 	{
 		//especial for 5G, vivi, 20100528
-		if(pHalData->interfaceIndex == 0)
+		if (pHalData->interfaceIndex == 0)
 		{
 			for(i=0;i<AGCTAB_ArrayLen;i=i+2)
 			{
@@ -1014,7 +1014,7 @@ phy_ConfigBBWithHeaderFile(
 		}
 		else
 		{
-			if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 			{
 				for(i=0;i<AGCTAB_ArrayLen;i=i+2)
 				{
@@ -1088,97 +1088,97 @@ storePwrIndexDiffRateOffset(
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
-	if(RegAddr == rTxAGC_A_Rate18_06)
+	if (RegAddr == rTxAGC_A_Rate18_06)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][0] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][0] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][0]));
 	}
-	if(RegAddr == rTxAGC_A_Rate54_24)
+	if (RegAddr == rTxAGC_A_Rate54_24)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][1] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][1] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][1]));
 	}
-	if(RegAddr == rTxAGC_A_CCK1_Mcs32)
+	if (RegAddr == rTxAGC_A_CCK1_Mcs32)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][6] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][6] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][6]));
 	}
-	if(RegAddr == rTxAGC_B_CCK11_A_CCK2_11 && BitMask == 0xffffff00)
+	if (RegAddr == rTxAGC_B_CCK11_A_CCK2_11 && BitMask == 0xffffff00)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][7] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][7] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][7]));
 	}
-	if(RegAddr == rTxAGC_A_Mcs03_Mcs00)
+	if (RegAddr == rTxAGC_A_Mcs03_Mcs00)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][2] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][2] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][2]));
 	}
-	if(RegAddr == rTxAGC_A_Mcs07_Mcs04)
+	if (RegAddr == rTxAGC_A_Mcs07_Mcs04)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][3] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][3] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][3]));
 	}
-	if(RegAddr == rTxAGC_A_Mcs11_Mcs08)
+	if (RegAddr == rTxAGC_A_Mcs11_Mcs08)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][4] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][4] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][4]));
 	}
-	if(RegAddr == rTxAGC_A_Mcs15_Mcs12)
+	if (RegAddr == rTxAGC_A_Mcs15_Mcs12)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][5] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][5] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][5]));
 	}
-	if(RegAddr == rTxAGC_B_Rate18_06)
+	if (RegAddr == rTxAGC_B_Rate18_06)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][8] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][8] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][8]));
 	}
-	if(RegAddr == rTxAGC_B_Rate54_24)
+	if (RegAddr == rTxAGC_B_Rate54_24)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][9] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][9] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][9]));
 	}
-	if(RegAddr == rTxAGC_B_CCK1_55_Mcs32)
+	if (RegAddr == rTxAGC_B_CCK1_55_Mcs32)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][14] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][14] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][14]));
 	}
-	if(RegAddr == rTxAGC_B_CCK11_A_CCK2_11 && BitMask == 0x000000ff)
+	if (RegAddr == rTxAGC_B_CCK11_A_CCK2_11 && BitMask == 0x000000ff)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][15] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][15] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][15]));
 	}
-	if(RegAddr == rTxAGC_B_Mcs03_Mcs00)
+	if (RegAddr == rTxAGC_B_Mcs03_Mcs00)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][10] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][10] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][10]));
 	}
-	if(RegAddr == rTxAGC_B_Mcs07_Mcs04)
+	if (RegAddr == rTxAGC_B_Mcs07_Mcs04)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][11] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][11] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][11]));
 	}
-	if(RegAddr == rTxAGC_B_Mcs11_Mcs08)
+	if (RegAddr == rTxAGC_B_Mcs11_Mcs08)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][12] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][12] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][12]));
 	}
-	if(RegAddr == rTxAGC_B_Mcs15_Mcs12)
+	if (RegAddr == rTxAGC_B_Mcs15_Mcs12)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][13] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][13] = 0x%lx\n", pHalData->pwrGroupCnt,
@@ -1216,7 +1216,7 @@ phy_ConfigBBWithPgHeaderFile(
 	PHY_REGArrayPGLen = Rtl8192D_PHY_REG_Array_PGLength;
 	Rtl819XPHY_REGArray_Table_PG = (u32 *)Rtl8192D_PHY_REG_Array_PG;
 
-	if(ConfigType == BaseBand_Config_PHY_REG)
+	if (ConfigType == BaseBand_Config_PHY_REG)
 	{
 		for(i=0;i<PHY_REGArrayPGLen;i=i+3)
 		{
@@ -1344,7 +1344,7 @@ phy_ConfigBBWithMpHeaderFile(
 	PHY_REGArrayMPLen = Rtl8192D_PHY_REG_Array_MPLength;
 	Rtl8192CPHY_REGArray_Table_MP = (u32 *)Rtl8192D_PHY_REG_Array_MP;
 
-	if(ConfigType == BaseBand_Config_PHY_REG)
+	if (ConfigType == BaseBand_Config_PHY_REG)
 	{
 		for(i=0;i<PHY_REGArrayMPLen;i=i+2)
 		{
@@ -1409,11 +1409,11 @@ phy_BB8192D_Config_ParaFile(
 	pszBBRegPgFile = sz92DBBRegPgFile;
 
 	//Normal chip,Mac0 use AGC_TAB.txt for 2G and 5G band.
-	if(pHalData->interfaceIndex == 0)
+	if (pHalData->interfaceIndex == 0)
 		pszAGCTableFile = sz92DAGCTableFile;
 	else
 	{
-		if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+		if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 			pszAGCTableFile = sz92D2GAGCTableFile;
 		else
 			pszAGCTableFile = sz92D5GAGCTableFile;
@@ -1436,7 +1436,7 @@ phy_BB8192D_Config_ParaFile(
 	rtStatus = phy_ConfigBBWithParaFile(Adapter,pszBBRegFile);
 #endif
 
-	if(rtStatus != _SUCCESS){
+	if (rtStatus != _SUCCESS){
 		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():Write BB Reg Fail!!"));
 		goto phy_BB8190_Config_ParaFile_Fail;
 	}
@@ -1454,7 +1454,7 @@ phy_BB8192D_Config_ParaFile(
 	rtStatus = phy_ConfigBBWithMpParaFile(Adapter,pszBBRegMpFile);
 #endif
 
-	if(rtStatus != _SUCCESS){
+	if (rtStatus != _SUCCESS){
 		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():Write BB Reg MP Fail!!"));
 		goto phy_BB8190_Config_ParaFile_Fail;
 	}
@@ -1475,7 +1475,7 @@ phy_BB8192D_Config_ParaFile(
 #endif
 	}
 
-	if(rtStatus != _SUCCESS){
+	if (rtStatus != _SUCCESS){
 		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():BB_PG Reg Fail!!"));
 		goto phy_BB8190_Config_ParaFile_Fail;
 	}
@@ -1486,7 +1486,7 @@ phy_BB8192D_Config_ParaFile(
 	//
 #ifdef CONFIG_EMBEDDED_FWIMG
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(pHalData->bSlaveOfDMSP)
+	if (pHalData->bSlaveOfDMSP)
 	{
 		DBG_8192D("BB config slave skip  2222 \n");
 	}
@@ -1500,7 +1500,7 @@ phy_BB8192D_Config_ParaFile(
 	rtStatus = phy_ConfigBBWithParaFile(Adapter, pszAGCTableFile);
 #endif
 
-	if(rtStatus != _SUCCESS){
+	if (rtStatus != _SUCCESS){
 		//RT_TRACE(COMP_FPGA, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():AGC Table Fail\n"));
 		goto phy_BB8190_Config_ParaFile_Fail;
 	}
@@ -1526,7 +1526,7 @@ PHY_BBConfig8192D(
 	u8	value;
 	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
 
-	if(Adapter->bSurpriseRemoved){
+	if (Adapter->bSurpriseRemoved){
 		rtStatus = _FAIL;
 		return rtStatus;
 	}
@@ -1562,7 +1562,7 @@ PHY_BBConfig8192D(
 	PHY_SetBBReg(Adapter, 0x28, 0xF0000000, ((pHalData->CrystalCap & 0xF0) >> 4));
 
 	//to save power for special 1T1R
-	if(pregistrypriv->special_rf_path == 1)
+	if (pregistrypriv->special_rf_path == 1)
 	{
 		PHY_SetBBReg(Adapter, rFPGA0_XCD_SwitchControl, BIT24|BIT25|BIT27|BIT30, 0);
 		PHY_SetBBReg(Adapter, rBlue_Tooth, BIT24|BIT25|BIT27|BIT30, 0);
@@ -1581,7 +1581,7 @@ PHY_BBConfig8192D(
 		PHY_SetBBReg(Adapter, rSleep, BIT24|BIT25|BIT27|BIT30, 0);
 		PHY_SetBBReg(Adapter, rPMPD_ANAEN, BIT24|BIT25|BIT27|BIT30, 0);
 	}
-	else if(pregistrypriv->special_rf_path == 2)
+	else if (pregistrypriv->special_rf_path == 2)
 	{
 		PHY_SetBBReg(Adapter, rFPGA0_XCD_SwitchControl, BIT22|BIT23|BIT26|BIT29, 0);
 		PHY_SetBBReg(Adapter, rBlue_Tooth, BIT22|BIT23|BIT26|BIT29, 0);
@@ -1613,7 +1613,7 @@ PHY_RFConfig8192D(
 	//struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	int		rtStatus = _SUCCESS;
 
-	if(Adapter->bSurpriseRemoved){
+	if (Adapter->bSurpriseRemoved){
 		rtStatus = _FAIL;
 		return rtStatus;
 	}
@@ -1695,13 +1695,13 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 	RadioB_ArrayLen = Rtl8192D_RadioB_2TArrayLength;
 	Rtl819XRadioB_Array_Table = (u32 *)Rtl8192D_RadioB_2TArray;
 
-	if(pHalData->InternalPA5G[0])
+	if (pHalData->InternalPA5G[0])
 	{
 		RadioA_ArrayLen = Rtl8192D_RadioA_2T_intPAArrayLength;
 		Rtl819XRadioA_Array_Table = (u32 *)Rtl8192D_RadioA_2T_intPAArray;
 	}
 
-	if(pHalData->InternalPA5G[1])
+	if (pHalData->InternalPA5G[1])
 	{
 		RadioB_ArrayLen = Rtl8192D_RadioB_2T_intPAArrayLength;
 		Rtl819XRadioB_Array_Table = (u32 *)Rtl8192D_RadioB_2T_intPAArray;
@@ -1716,7 +1716,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 	//vivi added this for read parameter from header, 20100908
 	//1this only happens when DMDP, mac0 start on 2.4G, mac1 start on 5G,
 	//1mac 0 has to set phy0&phy1 pathA or mac1 has to set phy0&phy1 pathA
-	if((Content == radiob_txt)&&(eRFPath == RF_PATH_A))
+	if ((Content == radiob_txt)&&(eRFPath == RF_PATH_A))
 	{
 		//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> PHY_ConfigRFWithHeaderFile(), althougth Path A, we load radiob.txt\n"));
 		RadioA_ArrayLen = RadioB_ArrayLen;
@@ -1727,7 +1727,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 		case RF_PATH_A:
 			for(i = 0;i<RadioA_ArrayLen; i=i+2)
 			{
-				if(Rtl819XRadioA_Array_Table[i] == 0xfe)
+				if (Rtl819XRadioA_Array_Table[i] == 0xfe)
 				{
 					#ifdef CONFIG_LONG_DELAY_ISSUE
 					rtw_msleep_os(50);
@@ -1770,7 +1770,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 		case RF_PATH_B:
 			for(i = 0;i<RadioB_ArrayLen; i=i+2)
 			{
-				if(Rtl819XRadioB_Array_Table[i] == 0xfe)
+				if (Rtl819XRadioB_Array_Table[i] == 0xfe)
 				{ // Deay specific ms. Only RF configuration require delay.
 					#ifdef CONFIG_LONG_DELAY_ISSUE
 					rtw_msleep_os(50);
@@ -1900,7 +1900,7 @@ rtl8192d_PHY_CheckBBAndRFOK(
 		//
 		// Check whether readback data is correct
 		//
-		if(ulRegRead != WriteData[i])
+		if (ulRegRead != WriteData[i])
 		{
 			//RT_TRACE(COMP_FPGA, DBG_LOUD, ("ulRegRead: %lx, WriteData: %lx \n", ulRegRead, WriteData[i]));
 			rtStatus = _FAIL;
@@ -1977,7 +1977,7 @@ phy_DbmToTxPwrIdx(
 		break;
 	}
 
-	if((PowerInDbm - Offset) > 0)
+	if ((PowerInDbm - Offset) > 0)
 	{
 		TxPwrIdx = (u8)((PowerInDbm - Offset) * 2);
 	}
@@ -1987,7 +1987,7 @@ phy_DbmToTxPwrIdx(
 	}
 
 	// Tx Power Index is too large.
-	if(TxPwrIdx > MAX_TXPWR_IDX_NMODE_92S)
+	if (TxPwrIdx > MAX_TXPWR_IDX_NMODE_92S)
 		TxPwrIdx = MAX_TXPWR_IDX_NMODE_92S;
 
 	return TxPwrIdx;
@@ -2074,14 +2074,14 @@ PHY_GetTxPowerLevel8192D(
 	TxPwrLevel = pHalData->CurrentOfdm24GTxPwrIdx + pHalData->LegacyHTTxPowerDiff;
 
 	// Compare with Legacy OFDM Tx power.
-	if(phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_G, TxPwrLevel) > TxPwrDbm)
+	if (phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_G, TxPwrLevel) > TxPwrDbm)
 		TxPwrDbm = phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_G, TxPwrLevel);
 
 	// HT OFDM
 	TxPwrLevel = pHalData->CurrentOfdm24GTxPwrIdx;
 
 	// Compare with HT OFDM Tx power.
-	if(phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_N_24G, TxPwrLevel) > TxPwrDbm)
+	if (phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_N_24G, TxPwrLevel) > TxPwrDbm)
 		TxPwrDbm = phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_N_24G, TxPwrLevel);
 
 	*powerlevel = TxPwrDbm;
@@ -2099,7 +2099,7 @@ static void getTxPowerIndex(
 	u8	index = (channel -1);
 
 	// 1. CCK
-	if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 	{
 		cckPowerLevel[RF_PATH_A] = pHalData->TxPwrLevelCck[RF_PATH_A][index];	//RF-A
 		cckPowerLevel[RF_PATH_B] = pHalData->TxPwrLevelCck[RF_PATH_B][index];	//RF-B
@@ -2157,24 +2157,24 @@ PHY_SetTxPowerLevel8192D(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	u8	cckPowerLevel[2], ofdmPowerLevel[2];	// [0]:RF-A, [1]:RF-B
 
-#if(MP_DRIVER == 1)
+#if (MP_DRIVER == 1)
 	return;
 #endif
 
-	if((Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(adapter_to_dvobj(Adapter)->ishighspeed == false))
+	if ((Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(adapter_to_dvobj(Adapter)->ishighspeed == false))
 		return;
 
-	if(pHalData->bTXPowerDataReadFromEEPORM == false)
+	if (pHalData->bTXPowerDataReadFromEEPORM == false)
 		return;
 
 	channel = GetRightChnlPlace(channel);
 
 	getTxPowerIndex(Adapter, channel, &cckPowerLevel[0], &ofdmPowerLevel[0]);
 
-	if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 		ccxPowerIndexCheck(Adapter, channel, &cckPowerLevel[0], &ofdmPowerLevel[0]);
 
-	if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 		rtl8192d_PHY_RF6052SetCckTxPower(Adapter, &cckPowerLevel[0]);
 	rtl8192d_PHY_RF6052SetOFDMTxPower(Adapter, &ofdmPowerLevel[0], channel);
 }
@@ -2201,7 +2201,7 @@ PHY_UpdateTxPowerDbm8192D(
 	u8	CckTxPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_B, powerInDbm);
 	u8	OfdmTxPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_N_24G, powerInDbm);
 
-	if(OfdmTxPwrIdx - pHalData->LegacyHTTxPowerDiff > 0)
+	if (OfdmTxPwrIdx - pHalData->LegacyHTTxPowerDiff > 0)
 		OfdmTxPwrIdx -= pHalData->LegacyHTTxPowerDiff;
 	else
 		OfdmTxPwrIdx = 0;
@@ -2212,7 +2212,7 @@ PHY_UpdateTxPowerDbm8192D(
 	{
 		for (rf_path = 0; rf_path < 2; rf_path++)
 		{
-			if(idx < CHANNEL_MAX_NUMBER_2G)
+			if (idx < CHANNEL_MAX_NUMBER_2G)
 				pHalData->TxPwrLevelCck[rf_path][idx] = CckTxPwrIdx;
 			pHalData->TxPwrLevelHT40_1S[rf_path][idx] =
 			pHalData->TxPwrLevelHT40_2S[rf_path][idx] = OfdmTxPwrIdx;
@@ -2284,17 +2284,17 @@ _PHY_SetBWMode92D(
 
 	//DBG_8192D("==>[%d]: _PHY_SetBWMode92D()  Switch to %s bandwidth\n", pHalData->interfaceIndex, pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz");
 
-	if(pHalData->rf_chip == RF_PSEUDO_11N)
+	if (pHalData->rf_chip == RF_PSEUDO_11N)
 	{
 		//pHalData->SetBWModeInProgress= false;
 		return;
 	}
 
 	// There is no 40MHz mode in RF_8225.
-	if(pHalData->rf_chip==RF_8225)
+	if (pHalData->rf_chip==RF_8225)
 		return;
 
-	if(Adapter->bDriverStopped)
+	if (Adapter->bDriverStopped)
 		return;
 
 
@@ -2352,7 +2352,7 @@ _PHY_SetBWMode92D(
 			PHY_SetBBReg(Adapter, rFPGA1_RFMOD, bRFMOD, 0x1);
 
 			// Set Control channel to upper or lower. These settings are required only for 40MHz
-			if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 			{
 				//AcquireCCKAndRWPageAControl(Adapter);
 				PHY_SetBBReg(Adapter, rCCK0_System, bCCKSideBand, (pHalData->nCur40MhzPrimeSC>>1));
@@ -2406,9 +2406,9 @@ _PHY_SetBWMode92D(
 	//pHalData->SetBWModeInProgress= FALSE;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(Adapter->DualMacConcurrent == true && BuddyAdapter != NULL)
+	if (Adapter->DualMacConcurrent == true && BuddyAdapter != NULL)
 	{
-		if(pHalData->bMasterOfDMSP)
+		if (pHalData->bMasterOfDMSP)
 		{
 			pHalDataBuddyAdapter = GET_HAL_DATA(BuddyAdapter);
 			pHalDataBuddyAdapter->CurrentChannelBW=pHalData->CurrentChannelBW;
@@ -2447,11 +2447,11 @@ PHY_SetBWMode8192D(
 	struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
 #endif
 
-	//if(pHalData->SetBWModeInProgress)
+	//if (pHalData->SetBWModeInProgress)
 	//	return;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(pHalData->bInModeSwitchProcess)
+	if (pHalData->bInModeSwitchProcess)
 	{
 		DBG_8192D("PHY_SwChnl8192D(): During mode switch \n");
 		//pHalData->SetBWModeInProgress=false;
@@ -2466,9 +2466,9 @@ PHY_SetBWMode8192D(
 	pHalData->nCur40MhzPrimeSC = Offset;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
+	if ((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
 	{
-		//if((BuddyAdapter->MgntInfo.bJoinInProgress) ||(BuddyAdapter->MgntInfo.bScanInProgress))
+		//if ((BuddyAdapter->MgntInfo.bJoinInProgress) ||(BuddyAdapter->MgntInfo.bScanInProgress))
 		{
 			DBG_8192D("PHY_SetBWMode92D():slave return when slave \n");
 			//pHalData->SetBWModeInProgress=false;
@@ -2477,7 +2477,7 @@ PHY_SetBWMode8192D(
 	}
 #endif
 
-	if((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))
+	if ((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))
 	{
 #ifdef USE_WORKITEM
 		//PlatformScheduleWorkItem(&(pHalData->SetBWModeWorkItem));
@@ -2536,7 +2536,7 @@ PHY_SwitchWirelessBand(
 	u8	i, value8;//, RegValue
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(pHalData->bInModeSwitchProcess || pHalData->bSlaveOfDMSP)
+	if (pHalData->bInModeSwitchProcess || pHalData->bSlaveOfDMSP)
 	{
 		DBG_8192D("PHY_SwitchWirelessBand(): skip for mode switch or slave \n");
 		return;
@@ -2545,10 +2545,10 @@ PHY_SwitchWirelessBand(
 	//DBG_8192D("PHY_SwitchWirelessBand():Before Switch Band \n");
 
 	pHalData->BandSet92D = pHalData->CurrentBandType92D = (enum BAND_TYPE)Band;
-	if(IS_92D_SINGLEPHY(pHalData->VersionID))
+	if (IS_92D_SINGLEPHY(pHalData->VersionID))
 		pHalData->BandSet92D = BAND_ON_BOTH;
 
-	if(pHalData->CurrentBandType92D == BAND_ON_5G)
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 	{
 		pHalData->CurrentWirelessMode = WIRELESS_MODE_N_5G;
 	}
@@ -2558,12 +2558,12 @@ PHY_SwitchWirelessBand(
 	}
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(pHalData->bMasterOfDMSP)
+	if (pHalData->bMasterOfDMSP)
 	{
 		struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
-		if(BuddyAdapter!=NULL)
+		if (BuddyAdapter!=NULL)
 		{
-			if(BuddyAdapter->hw_init_completed)
+			if (BuddyAdapter->hw_init_completed)
 			{
 				GET_HAL_DATA(BuddyAdapter)->BandSet92D = pHalData->BandSet92D;
 				GET_HAL_DATA(BuddyAdapter)->CurrentBandType92D = pHalData->CurrentBandType92D;
@@ -2577,10 +2577,10 @@ PHY_SwitchWirelessBand(
 	PHY_StopTRXBeforeChangeBand8192D(Adapter);
 
 	//reconfig BB/RF according to wireless mode
-	if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 	{
 		//BB & RF Config
-		if(pHalData->interfaceIndex == 1)
+		if (pHalData->interfaceIndex == 1)
 		{
 #ifdef CONFIG_EMBEDDED_FWIMG
 			phy_ConfigBBWithHeaderFile(Adapter, BaseBand_Config_AGC_TAB);
@@ -2591,7 +2591,7 @@ PHY_SwitchWirelessBand(
 	}
 	else	//5G band
 	{
-		if(pHalData->interfaceIndex == 1)
+		if (pHalData->interfaceIndex == 1)
 		{
 #ifdef CONFIG_EMBEDDED_FWIMG
 			phy_ConfigBBWithHeaderFile(Adapter, BaseBand_Config_AGC_TAB);
@@ -2603,7 +2603,7 @@ PHY_SwitchWirelessBand(
 
 	PHY_UpdateBBRFConfiguration8192D(Adapter, true);
 
-	if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 	{
 		update_tx_basic_rate(Adapter, WIRELESS_11BG_24N);
 
@@ -2619,12 +2619,12 @@ PHY_SwitchWirelessBand(
 	}
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(pHalData->bMasterOfDMSP)
+	if (pHalData->bMasterOfDMSP)
 	{
 		struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
-		if(BuddyAdapter!=NULL)
+		if (BuddyAdapter!=NULL)
 		{
-			if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 				rtw_write16(BuddyAdapter, REG_RRSR, 0x15d);
 			else
 				rtw_write16(BuddyAdapter, REG_RRSR, 0x150);
@@ -2636,7 +2636,7 @@ PHY_SwitchWirelessBand(
 	pdmpriv->bReloadtxpowerindex = true;
 
 	// notice fw know band status  0x81[1]/0x53[1] = 0: 5G, 1: 2G
-	if(pHalData->CurrentBandType92D==BAND_ON_2_4G)
+	if (pHalData->CurrentBandType92D==BAND_ON_2_4G)
 	{
 		value8 = rtw_read8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
 		value8 |= BIT1;
@@ -2767,58 +2767,58 @@ PHY_RestoreRFENV(
 
 	//only for 92D C-cut SMSP
 
-	if(adapter_to_dvobj(Adapter)->ishighspeed == false)
+	if (adapter_to_dvobj(Adapter)->ishighspeed == false)
 		return;
 
 	//config path A for 5G
-	if(pHalData->CurrentBandType92D==BAND_ON_5G)
+	if (pHalData->CurrentBandType92D==BAND_ON_5G)
 	{
 		u4tmp = CurveIndex[GetRightChnlPlace(channel)-1];
 
 		for(i = 0; i < RF_CHNL_NUM_5G; i++)
 		{
-			if(channel == RF_CHNL_5G[i] && channel <= 140)
+			if (channel == RF_CHNL_5G[i] && channel <= 140)
 				index = 0;
 		}
 
 		for(i = 0; i < RF_CHNL_NUM_5G_40M; i++)
 		{
-			if(channel == RF_CHNL_5G_40M[i] && channel <= 140)
+			if (channel == RF_CHNL_5G_40M[i] && channel <= 140)
 				index = 1;
 		}
 
-		if(channel ==149 || channel == 155 || channel ==161)
+		if (channel ==149 || channel == 155 || channel ==161)
 			index = 2;
-		else if(channel == 151 || channel == 153 || channel == 163 || channel == 165)
+		else if (channel == 151 || channel == 153 || channel == 163 || channel == 165)
 			index = 3;
-		else if(channel == 157 || channel == 159 )
+		else if (channel == 157 || channel == 159 )
 			index = 4;
 
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
 		{
 			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 			MaskforPhySet = MAC1_ACCESS_PHY0;
 			//asume no this case
-			if(bNeedPowerDownRadio)
+			if (bNeedPowerDownRadio)
 				PHY_EnableRFENV(Adapter, path, MaskforPhySet, &u4RegValue);
 		}
 
 		//DMDP, if band = 5G,Mac0 need to set PHY1 when regB30[27]=1
-		if(Regb30 && pHalData->interfaceIndex == 0)
+		if (Regb30 && pHalData->interfaceIndex == 0)
 		{
 			DBG_8192D("===============phy_SwitchRfSetting8192D interface %d,B30&BIT27=1!!!!\n", pHalData->interfaceIndex);
 
 			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
 			MaskforPhySet= MAC0_ACCESS_PHY1;
 			//asume no this case
-			if(bNeedPowerDownRadio)
+			if (bNeedPowerDownRadio)
 				PHY_EnableRFENV(Adapter, path, MaskforPhySet, &u4RegValue);
 		}
 
 		for(i = 0; i < RF_REG_NUM_for_C_CUT_5G; i++)
 		{
 #if 1
-			if(i == 0 && (pHalData->MacPhyMode92D == DUALMAC_DUALPHY))
+			if (i == 0 && (pHalData->MacPhyMode92D == DUALMAC_DUALPHY))
 			{
 				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, 0xE439D);
 			}
@@ -2827,7 +2827,7 @@ PHY_RestoreRFENV(
 #if SWLCK == 1
 				u4tmp2= (RF_REG_Param_for_C_CUT_5G[index][i]&0x7FF)|(u4tmp << 11);
 
-				if(channel == 36)
+				if (channel == 36)
 					u4tmp2 &= ~(BIT7|BIT6);
 
 				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, u4tmp2);
@@ -2841,7 +2841,7 @@ PHY_RestoreRFENV(
 				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, RF_REG_Param_for_C_CUT_5G[index][i]);
 			}
 #else
-			if(i == 0 && (pHalData->MacPhyMode92D == DUALMAC_DUALPHY))
+			if (i == 0 && (pHalData->MacPhyMode92D == DUALMAC_DUALPHY))
 				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i], RF_REG_MASK_for_C_CUT_5G[i], 0xE439D);
 			else
 				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i], RF_REG_MASK_for_C_CUT_5G[i], RF_REG_Param_for_C_CUT_5G[index][i]);
@@ -2850,49 +2850,49 @@ PHY_RestoreRFENV(
 			//	RF_REG_for_C_CUT_5G[i], RF_REG_Param_for_C_CUT_5G[index][i], path,  index,
 			//	PHY_QueryRFReg(Adapter, (enum RF_RADIO_PATH_E) path, RF_REG_for_C_CUT_5G[i]|MaskforPhyAccess, bRFRegOffsetMask)));
 		}
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
 		{
-			if(bNeedPowerDownRadio)
+			if (bNeedPowerDownRadio)
 			{
 				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
 			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
 		}
 
-		if(Regb30 && pHalData->interfaceIndex == 0)
+		if (Regb30 && pHalData->interfaceIndex == 0)
 		{
-			if(bNeedPowerDownRadio)
+			if (bNeedPowerDownRadio)
 			{
 				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
 			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
 		}
 
-		if(channel < 149)
+		if (channel < 149)
 			value = 0x07;
-		else if(channel >= 149)
+		else if (channel >= 149)
 			value = 0x02;
 
-		if(channel >= 36 && channel <= 64)
+		if (channel >= 36 && channel <= 64)
 			index = 0;
-		else if(channel >=100 && channel <= 140)
+		else if (channel >=100 && channel <= 140)
 			index = 1;
 		else
 			index = 2;
 
 		for(eRFPath = RF_PATH_A; eRFPath < pHalData->NumTotalRFPath; eRFPath++)
 		{
-			if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY &&
+			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY &&
 				pHalData->interfaceIndex == 1)		//MAC 1 5G
 				bInteralPA = pHalData->InternalPA5G[1];
 			else
 				bInteralPA = pHalData->InternalPA5G[eRFPath];
 
-			if(bInteralPA)
+			if (bInteralPA)
 			{
 				for(i = 0; i < RF_REG_NUM_for_C_CUT_5G_internalPA; i++)
 				{
-					if(RF_REG_for_C_CUT_5G_internalPA[i] == 0x03 &&
+					if (RF_REG_for_C_CUT_5G_internalPA[i] == 0x03 &&
 						channel >=36 && channel <=64)
 						PHY_SetRFReg(Adapter, eRFPath, RF_REG_for_C_CUT_5G_internalPA[i], bRFRegOffsetMask, 0x7bdef);
 					else
@@ -2905,40 +2905,40 @@ PHY_RestoreRFENV(
 				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_TXPA_AG, mask, value);
 		}
 	}
-	else if(pHalData->CurrentBandType92D==BAND_ON_2_4G)
+	else if (pHalData->CurrentBandType92D==BAND_ON_2_4G)
 	{
 		//DBG_8192D("====>phy_SwitchRfSetting interface %d 2.4G\n", pHalData->interfaceIndex);
 		u4tmp = CurveIndex[channel-1];
 		//RTPRINT(FINIT, INIT_IQK, ("cosa ver 3 set RF-B, 2G, 0x28 = 0x%x !!\n", u4tmp));
 
-		if(channel == 1 || channel == 2 || channel ==4 || channel == 9 || channel == 10 ||
+		if (channel == 1 || channel == 2 || channel ==4 || channel == 9 || channel == 10 ||
 			channel == 11 || channel ==12)
 			index = 0;
-		else if(channel ==3 || channel == 13 || channel == 14)
+		else if (channel ==3 || channel == 13 || channel == 14)
 			index = 1;
-		else if(channel >= 5 && channel <= 8)
+		else if (channel >= 5 && channel <= 8)
 			index = 2;
 
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
 		{
 			path = RF_PATH_A;
-			if(pHalData->interfaceIndex == 0)
+			if (pHalData->interfaceIndex == 0)
 			{
 				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
 				MaskforPhySet = MAC0_ACCESS_PHY1;
-				if(bNeedPowerDownRadio)
+				if (bNeedPowerDownRadio)
 					PHY_EnableRFENV(Adapter, path,MaskforPhySet,&u4RegValue);
 			}
 
 			//DMDP, if band = 2G,MAC1 need to set PHY0 when regB30[27]=1
-			if(Regb30 && pHalData->interfaceIndex == 1)
+			if (Regb30 && pHalData->interfaceIndex == 1)
 			{
 				//RT_TRACE(COMP_MLME, DBG_LOUD, ("===============phy_SwitchRfSetting interface %ld,B30&BIT27=1!!!!\n", Adapter->interfaceIndex));
 
 				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 				MaskforPhySet= MAC1_ACCESS_PHY0;
 				//asume no this case
-				if(bNeedPowerDownRadio)
+				if (bNeedPowerDownRadio)
 					PHY_EnableRFENV(Adapter, path,MaskforPhySet,&u4RegValue);
 			}
 		}
@@ -2967,17 +2967,17 @@ PHY_RestoreRFENV(
 
 		PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_SYN_G4|MaskforPhySet, bRFRegOffsetMask, RF_REG_SYN_G4_for_C_CUT_2G | (u4tmp << 11));
 #endif
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
 		{
-			if(bNeedPowerDownRadio){
+			if (bNeedPowerDownRadio){
 				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
 			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
 		}
 
-		if(Regb30 && pHalData->interfaceIndex == 1)
+		if (Regb30 && pHalData->interfaceIndex == 1)
 		{
-			if(bNeedPowerDownRadio)
+			if (bNeedPowerDownRadio)
 			{
 				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
@@ -3025,48 +3025,48 @@ static  void
 
 	//RTPRINT(FINIT, INIT_IQK, ("cosa pHalData->CurrentBandType92D = %d\n", pHalData->CurrentBandType92D));
 	//RTPRINT(FINIT, INIT_IQK, ("cosa channel = %d\n", channel));
-	if(pHalData->CurrentBandType92D == BAND_ON_5G)
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 	{
 		//Path-A for 5G
 		{
 			u4tmp = CurveIndex[GetRightChnlPlace(channel)-1];
 			//RTPRINT(FINIT, INIT_IQK, ("cosa ver 1 set RF-A, 5G,	0x28 = 0x%x !!\n", u4tmp));
 
-			if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
+			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
 			{
 				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 				MaskforPhySet = MAC1_ACCESS_PHY0;
 				//asume no this case
-				if(bNeedPowerDownRadio)
+				if (bNeedPowerDownRadio)
 					PHY_EnableRFENV(Adapter, eRFPath, MaskforPhySet,&u4RegValue);
 			}
 
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_SYN_G4|MaskforPhySet, 0x3f800, u4tmp);
 
-			if(bNeedPowerDownRadio){
+			if (bNeedPowerDownRadio){
 				PHY_RestoreRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
 				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
 			}
 		}
 	}
-	else if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	else if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 	{
 		{
 			u32 u4tmp=0;
 			u4tmp = CurveIndex[channel-1];
 			//RTPRINT(FINIT, INIT_IQK, ("cosa ver 3 set RF-B, 2G, 0x28 = 0x%x !!\n", u4tmp));
 
-			if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
+			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
 			{
 				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
 				MaskforPhySet = MAC0_ACCESS_PHY1;
-				if(bNeedPowerDownRadio)
+				if (bNeedPowerDownRadio)
 					PHY_EnableRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
 			}
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_SYN_G4|MaskforPhySet, 0x3f800, u4tmp);
 			//RTPRINT(FINIT, INIT_IQK, ("cosa ver 3 set RF-B, 2G, 0x28 = 0x%lx !!\n", PHY_QueryRFReg(Adapter, (enum RF_RADIO_PATH_E) eRFPath, RF_SYN_G4|MaskforPhyAccess, 0x3f800)));
 
-			if(bNeedPowerDownRadio){
+			if (bNeedPowerDownRadio){
 				PHY_RestoreRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
 				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
 			}
@@ -3109,18 +3109,18 @@ static  void
 	u32		RFMask=bRFRegOffsetMask;
 	u8		group=0, i;
 
-	if(adapter_to_dvobj(Adapter)->ishighspeed == false)
+	if (adapter_to_dvobj(Adapter)->ishighspeed == false)
 		return;
 
 	//only for 92D C-cut SMSP
 
-	if(pHalData->CurrentBandType92D == BAND_ON_5G)
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 	{
 		PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, BIT25|BIT24, 0);
 		PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,	0xf);
 
 		// fc area 0xd2c
-		if(channel>=149)
+		if (channel>=149)
 			PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT13|BIT14,2);
 		else
 			PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT13|BIT14,1);
@@ -3137,7 +3137,7 @@ static  void
 	else{ //G band.
 		//RT_TRACE(COMP_SCAN,DBG_LOUD,("Load RF IMR parameters for G band. IMR already setting %d \n",pMgntInfo->bLoadIMRandIQKSettingFor2G));
 
-		if(!pHalData->bLoadIMRandIQKSettingFor2G){
+		if (!pHalData->bLoadIMRandIQKSettingFor2G){
 			//RT_TRACE(COMP_SCAN,DBG_LOUD,("Load RF IMR parameters for G band. %d \n",eRFPath));
 			//AcquireCCKAndRWPageAControl(Adapter);
 			PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, BIT25|BIT24, 0);
@@ -3186,7 +3186,7 @@ static  void
 
 	//only for 92D C-cut SMSP
 
-	if(adapter_to_dvobj(Adapter)->ishighspeed == false)
+	if (adapter_to_dvobj(Adapter)->ishighspeed == false)
 		return;
 
 	//---------Do IQK for normal chip and test chip 5G band----------------
@@ -3197,7 +3197,7 @@ static  void
 	pHalData->bLoadIMRandIQKSettingFor2G = false;
 #endif
 
-	if(pHalData->bNeedIQK && !pHalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone)
+	if (pHalData->bNeedIQK && !pHalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone)
 	{ //Re Do IQK.
 		DBG_8192D("Do IQK Matrix reg for channel:%d....\n", channel);
 		rtl8192d_PHY_IQCalibrate(Adapter);
@@ -3205,13 +3205,13 @@ static  void
 	else //Just load the value.
 	{
 		// 2G band just load once.
-		if(((!pHalData->bLoadIMRandIQKSettingFor2G) && Indexforchannel==0) ||Indexforchannel>0)
+		if (((!pHalData->bLoadIMRandIQKSettingFor2G) && Indexforchannel==0) ||Indexforchannel>0)
 		{
 			//DBG_8192D("Just Read IQK Matrix reg for channel:%d....\n", channel);
 
-			if((pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][0] != 0)/*&&(RegEA4 != 0)*/)
+			if ((pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][0] != 0)/*&&(RegEA4 != 0)*/)
 			{
-				if(pHalData->CurrentBandType92D == BAND_ON_5G)
+				if (pHalData->CurrentBandType92D == BAND_ON_5G)
 					phy_PathAFillIQKMatrix_5G_Normal(Adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][2] == 0));
 				else
 					phy_PathAFillIQKMatrix(Adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][2] == 0));
@@ -3219,16 +3219,16 @@ static  void
 
 			if (IS_92D_SINGLEPHY(pHalData->VersionID))
 			{
-				if((pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][4] != 0)/*&&(RegEC4 != 0)*/)
+				if ((pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][4] != 0)/*&&(RegEC4 != 0)*/)
 				{
-					if(pHalData->CurrentBandType92D == BAND_ON_5G)
+					if (pHalData->CurrentBandType92D == BAND_ON_5G)
 						phy_PathBFillIQKMatrix_5G_Normal(Adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][6] == 0));
 					else
 						phy_PathBFillIQKMatrix(Adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][6] == 0));
 				}
 			}
 
-			if((Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(Indexforchannel==0))
+			if ((Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(Indexforchannel==0))
 				pHalData->bLoadIMRandIQKSettingFor2G=true;
 		}
 	}
@@ -3256,18 +3256,18 @@ static void _PHY_SwChnl8192D(struct rtw_
 		DBG_8192D( "[%s] ch = %d\n", __func__, channel );
 	}
 
-	if(pHalData->BandSet92D == BAND_ON_BOTH){
+	if (pHalData->BandSet92D == BAND_ON_BOTH){
 		// Need change band?
 		// BB {Reg878[0],[16]} bit0= 1 is 5G, bit0=0 is 2G.
 		ret_value = PHY_QueryBBReg(Adapter, rFPGA0_XAB_RFParameter, bMaskDWord);
 
-		if(ret_value & BIT0)
+		if (ret_value & BIT0)
 			bandtype = BAND_ON_5G;
 		else
 			bandtype = BAND_ON_2_4G;
 
 		// Use current channel to judge Band Type and switch Band if need.
-		if(channel > 14)
+		if (channel > 14)
 		{
 			target_bandtype = BAND_ON_5G;
 		}
@@ -3276,7 +3276,7 @@ static void _PHY_SwChnl8192D(struct rtw_
 			target_bandtype = BAND_ON_2_4G;
 		}
 
-		if(target_bandtype != bandtype)
+		if (target_bandtype != bandtype)
 			PHY_SwitchWirelessBand(Adapter,target_bandtype);
 	}
 
@@ -3293,9 +3293,9 @@ static void _PHY_SwChnl8192D(struct rtw_
 			//pHalData->RfRegChnlVal[eRFPath] = PHY_QueryRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, bRFRegOffsetMask);
 			// & 0xFFFFFC00 just for 2.4G. So for 5G band,bit[9:8]= 1. we change this setting for 5G. by wl
 			pHalData->RfRegChnlVal[eRFPath] = ((pHalData->RfRegChnlVal[eRFPath] & 0xffffff00) | param2);
-			if(pHalData->CurrentBandType92D == BAND_ON_5G)
+			if (pHalData->CurrentBandType92D == BAND_ON_5G)
 			{
-				if(param2>99)
+				if (param2>99)
 				{
 					pHalData->RfRegChnlVal[eRFPath]=pHalData->RfRegChnlVal[eRFPath]|(BIT18);
 				}
@@ -3336,9 +3336,9 @@ static void _PHY_SwChnl8192D(struct rtw_
 #endif
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(Adapter->DualMacConcurrent == true && BuddyAdapter != NULL)
+	if (Adapter->DualMacConcurrent == true && BuddyAdapter != NULL)
 	{
-		if(pHalData->bMasterOfDMSP)
+		if (pHalData->bMasterOfDMSP)
 		{
 			GET_HAL_DATA(BuddyAdapter)->CurrentChannel=channel;
 		}
@@ -3364,30 +3364,30 @@ PHY_SwChnl8192D(	// Call after initializ
 	struct hal_data_8192du *pHalDataBuddyAdapter;
 #endif
 
-	if(pHalData->rf_chip == RF_PSEUDO_11N)
+	if (pHalData->rf_chip == RF_PSEUDO_11N)
 	{
 		//pHalData->SwChnlInProgress=FALSE;
 		return;									//return immediately if it is peudo-phy
 	}
 
-	if(Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_COMPLETE)
+	if (Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_COMPLETE)
 		pHalData->bLoadIMRandIQKSettingFor2G = false;
 
-	//if(pHalData->SwChnlInProgress)
+	//if (pHalData->SwChnlInProgress)
 	//	return;
 
-	//if(pHalData->SetBWModeInProgress)
+	//if (pHalData->SetBWModeInProgress)
 	//	return;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(pHalData->bInModeSwitchProcess)
+	if (pHalData->bInModeSwitchProcess)
 	{
 		DBG_8192D("PHY_SwChnl8192D(): During mode switch \n");
 		//pHalData->SwChnlInProgress=false;
 		return;
 	}
 
-	if(BuddyAdapter != NULL &&
+	if (BuddyAdapter != NULL &&
 		((pHalData->interfaceIndex == 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G) ||
 		(pHalData->interfaceIndex == 1 && pHalData->CurrentBandType92D == BAND_ON_5G)))
 	{
@@ -3421,13 +3421,13 @@ PHY_SwChnl8192D(	// Call after initializ
 		case WIRELESS_MODE_N_5G:
 			//Get first channel error when change between 5G and 2.4G band.
 			//FIX ME!!!
-			//if(channel <=14)
+			//if (channel <=14)
 			//	return;
 			//RT_ASSERT((channel>14), ("WIRELESS_MODE_A but channel<=14"));
 			break;
 
 		case WIRELESS_MODE_B:
-			//if(channel>14)
+			//if (channel>14)
 			//	return;
 			//RT_ASSERT((channel<=14), ("WIRELESS_MODE_B but channel>14"));
 			break;
@@ -3436,7 +3436,7 @@ PHY_SwChnl8192D(	// Call after initializ
 		case WIRELESS_MODE_N_24G:
 			//Get first channel error when change between 5G and 2.4G band.
 			//FIX ME!!!
-			//if(channel > 14)
+			//if (channel > 14)
 			//	return;
 			//RT_ASSERT((channel<=14), ("WIRELESS_MODE_G but channel>14"));
 			break;
@@ -3448,7 +3448,7 @@ PHY_SwChnl8192D(	// Call after initializ
 	//--------------------------------------------
 
 	//pHalData->SwChnlInProgress = TRUE;
-	if( channel == 0){//FIXME!!!A band?
+	if ( channel == 0){//FIXME!!!A band?
 		channel = 1;
 	}
 
@@ -3458,7 +3458,7 @@ PHY_SwChnl8192D(	// Call after initializ
 	//pHalData->SwChnlStep=0;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
+	if ((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
 	{
 		DBG_8192D("PHY_SwChnl8192D():slave return when slave  \n");
 		//pHalData->SwChnlInProgress=false;
@@ -3466,21 +3466,21 @@ PHY_SwChnl8192D(	// Call after initializ
 	}
 #endif
 
-	if((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))
+	if ((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))
 	{
 #ifdef USE_WORKITEM
 		//bResult = PlatformScheduleWorkItem(&(pHalData->SwChnlWorkItem));
 #else
 		_PHY_SwChnl8192D(Adapter, channel);
 #endif
-		if(bResult)
+		if (bResult)
 		{
 			//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress TRUE schdule workitem done\n"));
 		}
 		else
 		{
 			//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress FALSE schdule workitem error\n"));
-			//if(IS_HARDWARE_TYPE_8192SU(Adapter))
+			//if (IS_HARDWARE_TYPE_8192SU(Adapter))
 			//{
 			//	pHalData->SwChnlInProgress = FALSE;
 				pHalData->CurrentChannel = tmpchannel;
@@ -3491,7 +3491,7 @@ PHY_SwChnl8192D(	// Call after initializ
 	else
 	{
 		//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress FALSE driver sleep or unload\n"));
-		//if(IS_HARDWARE_TYPE_8192SU(Adapter))
+		//if (IS_HARDWARE_TYPE_8192SU(Adapter))
 		//{
 		//	pHalData->SwChnlInProgress = FALSE;
 			pHalData->CurrentChannel = tmpchannel;
@@ -3525,9 +3525,9 @@ phy_SetSwChnlCmdArray(
 {
 	struct sw_chnl_cmd *cmd;
 
-	if(cmdtable == NULL)
+	if (cmdtable == NULL)
 		return false;
-	if(cmdtableidx >= cmdtablesz)
+	if (cmdtableidx >= cmdtablesz)
 		return false;
 
 	cmd = cmdtable + cmdtableidx;
@@ -3568,22 +3568,22 @@ PHY_SwChnlPhy8192D(	// Only called durin
 	//RT_TRACE(COMP_SCAN | COMP_RM, DBG_LOUD, ("==>PHY_SwChnlPhy8192S(), switch from channel %d to channel %d.\n", pHalData->CurrentChannel, channel));
 
 	// Cannot IO.
-	//if(RT_CANNOT_IO(Adapter))
+	//if (RT_CANNOT_IO(Adapter))
 	//	return;
 
 	// Channel Switching is in progress.
-	//if(pHalData->SwChnlInProgress)
+	//if (pHalData->SwChnlInProgress)
 	//	return;
 
 	//return immediately if it is peudo-phy
-	if(pHalData->rf_chip == RF_PSEUDO_11N)
+	if (pHalData->rf_chip == RF_PSEUDO_11N)
 	{
 		//pHalData->SwChnlInProgress=FALSE;
 		return;
 	}
 
 	//pHalData->SwChnlInProgress = TRUE;
-	if( channel == 0)
+	if ( channel == 0)
 		channel = 1;
 
 	pHalData->CurrentChannel=channel;
@@ -3665,7 +3665,7 @@ phy_PathA_IQK(
 
 	//path-A IQK setting
 	//RTPRINT(FINIT, INIT_IQK, ("Path-A IQK setting!\n"));
-	if(pHalData->interfaceIndex == 0)
+	if (pHalData->interfaceIndex == 0)
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
@@ -3682,12 +3682,12 @@ phy_PathA_IQK(
 		IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID)?0x28160202:0x28160502);
 
 	//path-B IQK setting
-	if(configPathB)
+	if (configPathB)
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x10008c22);
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x10008c22);
 		PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82140102);
-		if(IS_HARDWARE_TYPE_8192D(pAdapter))
+		if (IS_HARDWARE_TYPE_8192D(pAdapter))
 			PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x28160206);
 		else
 			PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x28160202);
@@ -3695,7 +3695,7 @@ phy_PathA_IQK(
 
 	//LO calibration setting
 	//RTPRINT(FINIT, INIT_IQK, ("LO calibration setting!\n"));
-	if(IS_HARDWARE_TYPE_8192D(pAdapter))
+	if (IS_HARDWARE_TYPE_8192D(pAdapter))
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 	else
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x001028d1);
@@ -3719,14 +3719,14 @@ phy_PathA_IQK(
 	regEA4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
 	//RTPRINT(FINIT, INIT_IQK, ("0xea4 = 0x%x\n", regEA4));
 
-	if(!(regEAC & BIT28) &&
+	if (!(regEAC & BIT28) &&
 		(((regE94 & 0x03FF0000)>>16) != 0x142) &&
 		(((regE9C & 0x03FF0000)>>16) != 0x42) )
 		result |= 0x01;
 	else							//if Tx not OK, ignore Rx
 		return result;
 
-	if(!(regEAC & BIT27) &&		//if Tx is OK, check whether Rx is OK
+	if (!(regEAC & BIT27) &&		//if Tx is OK, check whether Rx is OK
 		(((regEA4 & 0x03FF0000)>>16) != 0x132) &&
 		(((regEAC & 0x03FF0000)>>16) != 0x36))
 		result |= 0x02;
@@ -3758,7 +3758,7 @@ phy_PathA_IQK_5G_Normal(
 
 	u32	TxOKBit = BIT28, RxOKBit = BIT27;
 
-	if(pHalData->interfaceIndex == 1)	//PHY1
+	if (pHalData->interfaceIndex == 1)	//PHY1
 	{
 		TxOKBit = BIT31;
 		RxOKBit = BIT30;
@@ -3775,7 +3775,7 @@ phy_PathA_IQK_5G_Normal(
 	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68160960);
 
 	//path-B IQK setting
-	if(configPathB)
+	if (configPathB)
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f );
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x18008c2f );
@@ -3829,7 +3829,7 @@ phy_PathA_IQK_5G_Normal(
 		regEA4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
 		//RTPRINT(FINIT, INIT_IQK, ("0xea4 = 0x%lx\n", regEA4));
 
-		if(!(regEAC & TxOKBit) &&
+		if (!(regEAC & TxOKBit) &&
 			(((regE94 & 0x03FF0000)>>16) != 0x142)  )
 		{
 			result |= 0x01;
@@ -3840,7 +3840,7 @@ phy_PathA_IQK_5G_Normal(
 			continue;
 		}
 
-		if(!(regEAC & RxOKBit) &&			//if Tx is OK, check whether Rx is OK
+		if (!(regEAC & RxOKBit) &&			//if Tx is OK, check whether Rx is OK
 			(((regEA4 & 0x03FF0000)>>16) != 0x132))
 		{
 			result |= 0x02;
@@ -3856,12 +3856,12 @@ phy_PathA_IQK_5G_Normal(
 	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, pdmpriv->IQK_BB_backup[0]);
 	PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pdmpriv->IQK_BB_backup[1]);
 
-	if(!(result & 0x01))	//Tx IQK fail
+	if (!(result & 0x01))	//Tx IQK fail
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x19008c00);
 	}
 
-	if(!(result & 0x02))	//Rx IQK fail
+	if (!(result & 0x02))	//Rx IQK fail
 	{
 		PHY_SetBBReg(pAdapter, rOFDM0_XARxIQImbalance , bMaskDWord, 0x40000100);
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A , bMaskDWord, 0x19008c00);
@@ -3902,14 +3902,14 @@ phy_PathB_IQK(
 	regECC= PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord);
 	//RTPRINT(FINIT, INIT_IQK, ("0xecc = 0x%x\n", regECC));
 
-	if(!(regEAC & BIT31) &&
+	if (!(regEAC & BIT31) &&
 		(((regEB4 & 0x03FF0000)>>16) != 0x142) &&
 		(((regEBC & 0x03FF0000)>>16) != 0x42))
 		result |= 0x01;
 	else
 		return result;
 
-	if(!(regEAC & BIT30) &&
+	if (!(regEAC & BIT30) &&
 		(((regEC4 & 0x03FF0000)>>16) != 0x132) &&
 		(((regECC & 0x03FF0000)>>16) != 0x36))
 		result |= 0x02;
@@ -3999,13 +3999,13 @@ phy_PathB_IQK_5G_Normal(
 		regECC= PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord);
 		//RTPRINT(FINIT, INIT_IQK, ("0xecc = 0x%lx\n", regECC));
 
-		if(!(regEAC & BIT31) &&
+		if (!(regEAC & BIT31) &&
 			(((regEB4 & 0x03FF0000)>>16) != 0x142))
 			result |= 0x01;
 		else
 			continue;
 
-		if(!(regEAC & BIT30) &&
+		if (!(regEAC & BIT30) &&
 			(((regEC4 & 0x03FF0000)>>16) != 0x132))
 		{
 			result |= 0x02;
@@ -4021,12 +4021,12 @@ phy_PathB_IQK_5G_Normal(
 	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, pdmpriv->IQK_BB_backup[0]);
 	PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, bMaskDWord, pdmpriv->IQK_BB_backup[2]);
 
-	if(!(result & 0x01))	//Tx IQK fail
+	if (!(result & 0x01))	//Tx IQK fail
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x19008c00);
 	}
 
-	if(!(result & 0x02))	//Rx IQK fail
+	if (!(result & 0x02))	//Rx IQK fail
 	{
 		PHY_SetBBReg(pAdapter, rOFDM0_XBRxIQImbalance , bMaskDWord, 0x40000100);
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B , bMaskDWord, 0x19008c00);
@@ -4051,10 +4051,10 @@ phy_PathAFillIQKMatrix(
 
 	//DBG_8192D("Path A IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed");
 
-	if(final_candidate == 0xFF)
+	if (final_candidate == 0xFF)
 		return;
 
-	else if(bIQKOK)
+	else if (bIQKOK)
 	{
 		Oldval_0 = (PHY_QueryBBReg(pAdapter, rOFDM0_XATxIQImbalance, bMaskDWord) >> 22) & 0x3FF;//OFDM0_D
 
@@ -4064,7 +4064,7 @@ phy_PathAFillIQKMatrix(
 		TX0_A = (X * Oldval_0) >> 8;
 		//RTPRINT(FINIT, INIT_IQK, ("X = 0x%lx, TX0_A = 0x%lx, Oldval_0 0x%lx\n", X, TX0_A, Oldval_0));
 		PHY_SetBBReg(pAdapter, rOFDM0_XATxIQImbalance, 0x3FF, TX0_A);
-		if(IS_HARDWARE_TYPE_8192D(pAdapter))
+		if (IS_HARDWARE_TYPE_8192D(pAdapter))
 			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT24, ((X* Oldval_0>>7) & 0x1));
 		else
 			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(31), ((X* Oldval_0>>7) & 0x1));
@@ -4074,19 +4074,19 @@ phy_PathAFillIQKMatrix(
 			Y = Y | 0xFFFFFC00;
 
 		//path B IQK result + 3
-		if(pHalData->interfaceIndex == 1 && pHalData->CurrentBandType92D == BAND_ON_5G)
+		if (pHalData->interfaceIndex == 1 && pHalData->CurrentBandType92D == BAND_ON_5G)
 			Y += 3;
 
 		TX0_C = (Y * Oldval_0) >> 8;
 		//RTPRINT(FINIT, INIT_IQK, ("Y = 0x%lx, TX0_C = 0x%lx\n", Y, TX0_C));
 		PHY_SetBBReg(pAdapter, rOFDM0_XCTxAFE, 0xF0000000, ((TX0_C&0x3C0)>>6));
 		PHY_SetBBReg(pAdapter, rOFDM0_XATxIQImbalance, 0x003F0000, (TX0_C&0x3F));
-		if(IS_HARDWARE_TYPE_8192D(pAdapter)/*&&is2T*/)
+		if (IS_HARDWARE_TYPE_8192D(pAdapter)/*&&is2T*/)
 			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT26, ((Y* Oldval_0>>7) & 0x1));
 		else
 			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(29), ((Y* Oldval_0>>7) & 0x1));
 
-	        if(bTxOnly)
+	        if (bTxOnly)
 		{
 			//DBG_8192D("_PHY_PathAFillIQKMatrix only Tx OK\n");
 			return;
@@ -4120,7 +4120,7 @@ phy_PathAFillIQKMatrix_5G_Normal(
 
 	//DBG_8192D("Path A IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed");
 
-	if(bIQKOK && final_candidate != 0xFF)
+	if (bIQKOK && final_candidate != 0xFF)
 	{
 		X = result[final_candidate][0];
 		if ((X & 0x00000200) != 0)
@@ -4137,17 +4137,17 @@ phy_PathAFillIQKMatrix_5G_Normal(
 			Y = Y | 0xFFFFFC00;
 
 		//path A/B IQK result + 3, suggest by Jenyu
-		if(pHalData->CurrentBandType92D == BAND_ON_5G)
+		if (pHalData->CurrentBandType92D == BAND_ON_5G)
 			Y += 3;
 
 		//RTPRINT(FINIT, INIT_IQK, ("Y = 0x%lx\n", Y));
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, 0x003FF, Y);
-		//if(is2T)
+		//if (is2T)
 			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT26, 0);
 
 		//RTPRINT(FINIT, INIT_IQK, ("0xe30 = 0x%lx\n", PHY_QueryBBReg(pAdapter, 0xe30, bMaskDWord)));
 
-		if(bTxOnly)
+		if (bTxOnly)
 		{
 			//DBG_8192D("_PHY_PathAFillIQKMatrix only Tx OK\n");
 			return;
@@ -4186,10 +4186,10 @@ phy_PathBFillIQKMatrix(
 
 	//DBG_8192D("Path B IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed");
 
-        if(final_candidate == 0xFF)
+        if (final_candidate == 0xFF)
 		return;
 
-	else if(bIQKOK)
+	else if (bIQKOK)
 	{
 		Oldval_1 = (PHY_QueryBBReg(pAdapter, rOFDM0_XBTxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
 
@@ -4199,7 +4199,7 @@ phy_PathBFillIQKMatrix(
 		TX1_A = (X * Oldval_1) >> 8;
 		//RTPRINT(FINIT, INIT_IQK, ("X = 0x%lx, TX1_A = 0x%lx\n", X, TX1_A));
 		PHY_SetBBReg(pAdapter, rOFDM0_XBTxIQImbalance, 0x3FF, TX1_A);
-		if(IS_HARDWARE_TYPE_8192D(pAdapter))
+		if (IS_HARDWARE_TYPE_8192D(pAdapter))
 			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT28, ((X* Oldval_1>>7) & 0x1));
 		else
 			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(27), ((X* Oldval_1>>7) & 0x1));
@@ -4207,18 +4207,18 @@ phy_PathBFillIQKMatrix(
 		Y = result[final_candidate][5];
 		if ((Y & 0x00000200) != 0)
 			Y = Y | 0xFFFFFC00;
-		if(pHalData->CurrentBandType92D == BAND_ON_5G)
+		if (pHalData->CurrentBandType92D == BAND_ON_5G)
 			Y += 3;		//temp modify for preformance
 		TX1_C = (Y * Oldval_1) >> 8;
 		//RTPRINT(FINIT, INIT_IQK, ("Y = 0x%lx, TX1_C = 0x%lx\n", Y, TX1_C));
 		PHY_SetBBReg(pAdapter, rOFDM0_XDTxAFE, 0xF0000000, ((TX1_C&0x3C0)>>6));
 		PHY_SetBBReg(pAdapter, rOFDM0_XBTxIQImbalance, 0x003F0000, (TX1_C&0x3F));
-		if(IS_HARDWARE_TYPE_8192D(pAdapter))
+		if (IS_HARDWARE_TYPE_8192D(pAdapter))
 			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT30, ((Y* Oldval_1>>7) & 0x1));
 		else
 			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT(25), ((Y* Oldval_1>>7) & 0x1));
 
-		if(bTxOnly)
+		if (bTxOnly)
 			return;
 
 		reg = result[final_candidate][6];
@@ -4247,7 +4247,7 @@ phy_PathBFillIQKMatrix_5G_Normal(
 
 	//DBG_8192D("Path B IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed");
 
-	if(bIQKOK && final_candidate != 0xFF)
+	if (bIQKOK && final_candidate != 0xFF)
 	{
 		X = result[final_candidate][4];
 		if ((X & 0x00000200) != 0)
@@ -4260,14 +4260,14 @@ phy_PathBFillIQKMatrix_5G_Normal(
 		Y = result[final_candidate][5];
 		if ((Y & 0x00000200) != 0)
 			Y = Y | 0xFFFFFC00;
-		if(pHalData->CurrentBandType92D == BAND_ON_5G)
+		if (pHalData->CurrentBandType92D == BAND_ON_5G)
 			Y += 3;		//temp modify for preformance, suggest by Jenyu
 
 		//RTPRINT(FINIT, INIT_IQK, ("Y = 0x%lx\n", Y));
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, 0x003FF, Y);
 		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT30, 0);
 
-		if(bTxOnly)
+		if (bTxOnly)
 			return;
 
 		reg = result[final_candidate][6];
@@ -4337,7 +4337,7 @@ phy_ReloadADDARegisters(
 	//RTPRINT(FINIT, INIT_IQK, ("Reload ADDA power saving parameters !\n"));
 	for(i = 0 ; i < RegiesterNum ; i++){
 		//path-A/B BB to initial gain
-		if(ADDAReg[i] == rOFDM0_XAAGCCore1 || ADDAReg[i] == rOFDM0_XBAGCCore1)
+		if (ADDAReg[i] == rOFDM0_XAAGCCore1 || ADDAReg[i] == rOFDM0_XBAGCCore1)
 			PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, 0x50);
 		PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, ADDABackup[i]);
 	}
@@ -4376,7 +4376,7 @@ phy_PathADDAOn(
 	pathOn = isPathAOn ? 0x04db25a4 : 0x0b1b25a4;
 	// Modified by Neil Chen
 	// for Path diversity and original IQK
-	if(isPathAOn)     // Neil Chen
+	if (isPathAOn)     // Neil Chen
 		pathOn = pHalData->interfaceIndex == 0? 0x04db25a4 : 0x0b1b25a4;
 
 	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++){
@@ -4445,7 +4445,7 @@ phy_SimularityCompare_92D(
 	bool		bResult = true;
 	bool		is2T = IS_92D_SINGLEPHY(pHalData->VersionID);
 
-	if(is2T)
+	if (is2T)
 		bound = 8;
 	else
 		bound = 4;
@@ -4458,9 +4458,9 @@ phy_SimularityCompare_92D(
 		diff = (result[c1][i] > result[c2][i]) ? (result[c1][i] - result[c2][i]) : (result[c2][i] - result[c1][i]);
 		if (diff > MAX_TOLERANCE_92D)
 		{
-			if((i == 2 || i == 6) && !SimularityBitMap)
+			if ((i == 2 || i == 6) && !SimularityBitMap)
 			{
-				if(result[c1][i]+result[c1][i+1] == 0)
+				if (result[c1][i]+result[c1][i+1] == 0)
 					final_candidate[(i/4)] = c2;
 				else if (result[c2][i]+result[c2][i+1] == 0)
 					final_candidate[(i/4)] = c1;
@@ -4476,7 +4476,7 @@ phy_SimularityCompare_92D(
 	{
 		for( i = 0; i < (bound/4); i++ )
 		{
-			if(final_candidate[i] != 0xFF)
+			if (final_candidate[i] != 0xFF)
 			{
 				for( j = i*4; j < (i+1)*4-2; j++)
 					result[3][j] = result[final_candidate[i]][j];
@@ -4488,7 +4488,7 @@ phy_SimularityCompare_92D(
 		{
 			u4temp += (result[c1][i]+	result[c2][i]);
 		}
-		if(u4temp == 0)	//IQK fail for c1 & c2
+		if (u4temp == 0)	//IQK fail for c1 & c2
 			bResult = false;
 
 		return bResult;
@@ -4586,7 +4586,7 @@ phy_IQCalibrate(
 
 	u32 bbvalue;
 
-	if(t==0)
+	if (t==0)
 	{
 		bbvalue = PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bMaskDWord);
 		//RTPRINT(FINIT, INIT_IQK, ("PHY_IQCalibrate()==>0x%08lx\n",bbvalue));
@@ -4595,7 +4595,7 @@ phy_IQCalibrate(
 		// Save ADDA parameters, turn Path A ADDA on
 		phy_SaveADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 		phy_SaveMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
-		if(IS_HARDWARE_TYPE_8192D(pAdapter))
+		if (IS_HARDWARE_TYPE_8192D(pAdapter))
 			phy_SaveADDARegisters(pAdapter, IQK_BB_REG_92D, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
 		else
 			phy_SaveADDARegisters(pAdapter, IQK_BB_REG_92C, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92C);
@@ -4603,15 +4603,15 @@ phy_IQCalibrate(
 
 	phy_PathADDAOn(pAdapter, ADDA_REG, true, is2T);
 
-	if(IS_HARDWARE_TYPE_8192D(pAdapter))
+	if (IS_HARDWARE_TYPE_8192D(pAdapter))
 		PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x01017038);
 
-	if(t==0)
+	if (t==0)
 	{
 		pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
 	}
 
-	if(!pdmpriv->bRfPiEnable){
+	if (!pdmpriv->bRfPiEnable){
 		// Switch BB to PI mode to do IQ Calibration.
 		phy_PIModeSwitch(pAdapter, true);
 	}
@@ -4620,7 +4620,7 @@ phy_IQCalibrate(
 	PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
 	PHY_SetBBReg(pAdapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
 	PHY_SetBBReg(pAdapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22204000);
-	if(IS_HARDWARE_TYPE_8192D(pAdapter))
+	if (IS_HARDWARE_TYPE_8192D(pAdapter))
 		PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xf00000, 0x0f);
 	else
 	{
@@ -4630,7 +4630,7 @@ phy_IQCalibrate(
 		PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, BIT10, 0x00);
 	}
 
-	if(is2T)
+	if (is2T)
 	{
 		PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00010000);
 		PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00010000);
@@ -4639,11 +4639,11 @@ phy_IQCalibrate(
 	//MAC settings
 	phy_MACSettingCalibration(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
-	if(IS_HARDWARE_TYPE_8192D(pAdapter))
+	if (IS_HARDWARE_TYPE_8192D(pAdapter))
 	{
 		PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x0f600000);
 
-		if(is2T)
+		if (is2T)
 		{
 			PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x0f600000);
 		}
@@ -4653,7 +4653,7 @@ phy_IQCalibrate(
 		//Page B init
 		PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x00080000);
 
-		if(is2T)
+		if (is2T)
 		{
 			PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x00080000);
 		}
@@ -4667,7 +4667,7 @@ phy_IQCalibrate(
 
 	for(i = 0 ; i < retryCount ; i++){
 		PathAOK = phy_PathA_IQK(pAdapter, is2T);
-		if(PathAOK == 0x03){
+		if (PathAOK == 0x03){
 			//RTPRINT(FINIT, INIT_IQK, ("Path A IQK Success!!\n"));
 			result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
@@ -4684,11 +4684,11 @@ phy_IQCalibrate(
 		}
 	}
 
-	if(0x00 == PathAOK){
+	if (0x00 == PathAOK){
 		DBG_8192D("Path A IQK failed!!\n");
 	}
 
-	if(is2T){
+	if (is2T){
 		phy_PathAStandBy(pAdapter);
 
 		// Turn Path B ADDA on
@@ -4696,7 +4696,7 @@ phy_IQCalibrate(
 
 		for(i = 0 ; i < retryCount ; i++){
 			PathBOK = phy_PathB_IQK(pAdapter);
-			if(PathBOK == 0x03){
+			if (PathBOK == 0x03){
 				//RTPRINT(FINIT, INIT_IQK, ("Path B IQK Success!!\n"));
 				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
@@ -4712,7 +4712,7 @@ phy_IQCalibrate(
 			}
 		}
 
-		if(0x00 == PathBOK){
+		if (0x00 == PathBOK){
 			DBG_8192D("Path B IQK failed!!\n");
 		}
 	}
@@ -4721,9 +4721,9 @@ phy_IQCalibrate(
 	//RTPRINT(FINIT, INIT_IQK, ("IQK:Back to BB mode, load original value!\n"));
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0);
 
-	if(t!=0)
+	if (t!=0)
 	{
-		if(!pdmpriv->bRfPiEnable){
+		if (!pdmpriv->bRfPiEnable){
 			// Switch back BB to SI mode after finish IQ Calibration.
 			phy_PIModeSwitch(pAdapter, false);
 		}
@@ -4735,9 +4735,9 @@ phy_IQCalibrate(
 		phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 		// Reload BB parameters
-		if(IS_HARDWARE_TYPE_8192D(pAdapter))
+		if (IS_HARDWARE_TYPE_8192D(pAdapter))
 		{
-			if(is2T)
+			if (is2T)
 				phy_ReloadADDARegisters(pAdapter, IQK_BB_REG_92D, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
 			else
 				phy_ReloadADDARegisters(pAdapter, IQK_BB_REG_92D, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D -1);
@@ -4745,11 +4745,11 @@ phy_IQCalibrate(
 		else
 			phy_ReloadADDARegisters(pAdapter, IQK_BB_REG_92C, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92C);
 
-		if(!IS_HARDWARE_TYPE_8192D(pAdapter))
+		if (!IS_HARDWARE_TYPE_8192D(pAdapter))
 		{
 			// Restore RX initial gain
 			PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032ed3);
-			if(is2T){
+			if (is2T){
 				PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032ed3);
 			}
 		}
@@ -4820,7 +4820,7 @@ phy_IQCalibrate_5G(
 
 	//IQK must be done in PI mode
 	pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
-	if(!pdmpriv->bRfPiEnable)
+	if (!pdmpriv->bRfPiEnable)
 		phy_PIModeSwitch(pAdapter, true);
 
 	//TXIQK RF setting
@@ -4845,7 +4845,7 @@ phy_IQCalibrate_5G(
 	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
 
 	//path-A IQK setting
-	if(pHalData->interfaceIndex == 0)
+	if (pHalData->interfaceIndex == 0)
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c1f);
@@ -4856,14 +4856,14 @@ phy_IQCalibrate_5G(
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c22);
 	}
 
-	if(is2T)
+	if (is2T)
 		PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x821402e2);
 	else
 		PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x821402e6);
 	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
 
 	//path-B IQK setting
-	if(is2T)
+	if (is2T)
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x30008c22);
@@ -4891,7 +4891,7 @@ phy_IQCalibrate_5G(
 	REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
 	REG0xe94 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord);
 
-	if(((REG0xeac&BIT(28)) == 0) && (((REG0xe94&0x3FF0000)>>16)!=0x142))
+	if (((REG0xeac&BIT(28)) == 0) && (((REG0xe94&0x3FF0000)>>16)!=0x142))
 	{
 		REG0xe9c = PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord);
 		TX_X0 = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
@@ -4908,7 +4908,7 @@ phy_IQCalibrate_5G(
 	}
 
 	//1 path A RX IQK
-	if(TX0IQKOK == true)
+	if (TX0IQKOK == true)
 	{
 
 		DBG_8192D("IQK for 5G: Path A Rx  START interface %u\n", pHalData->interfaceIndex);
@@ -4918,14 +4918,14 @@ phy_IQCalibrate_5G(
 		PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
 
 		//turn on external PA
-		if(pHalData->interfaceIndex == 1)
+		if (pHalData->interfaceIndex == 1)
 			PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT(30), 0x01);
 
 		//IQK global setting
 		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
 
 		//path-A IQK setting
-		if(pHalData->interfaceIndex == 0)
+		if (pHalData->interfaceIndex == 0)
 		{
 			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
 			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
@@ -4936,13 +4936,13 @@ phy_IQCalibrate_5G(
 			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x14008c22);
 		}
 		PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
-		if(pHalData->interfaceIndex == 0)
+		if (pHalData->interfaceIndex == 0)
 			PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, (pHalData->CurrentChannel<=140)?0x68160c62:0x68160c66);
 		else
 			PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68160962);
 
 		//path-B IQK setting
-		if(is2T)
+		if (is2T)
 		{
 			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
 			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x14008c22);
@@ -4971,9 +4971,9 @@ phy_IQCalibrate_5G(
 		//Check_RX_IQK_A_result()
 		REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
 		REG0xea4 = PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
-		if(pHalData->interfaceIndex == 0)
+		if (pHalData->interfaceIndex == 0)
 		{
-			if(((REG0xeac&BIT(27)) == 0) && (((REG0xea4&0x3FF0000)>>16)!=0x132))
+			if (((REG0xeac&BIT(27)) == 0) && (((REG0xea4&0x3FF0000)>>16)!=0x132))
 			{
 				RX_X0 =  (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
 				RX_Y0 =  (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
@@ -4983,7 +4983,7 @@ phy_IQCalibrate_5G(
 		}
 		else
 		{
-			if(((REG0xeac&BIT(30)) == 0) && (((REG0xea4&0x3FF0000)>>16)!=0x132))
+			if (((REG0xeac&BIT(30)) == 0) && (((REG0xea4&0x3FF0000)>>16)!=0x132))
 			{
 				RX_X0 =  (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
 				RX_Y0 =  (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
@@ -4993,7 +4993,7 @@ phy_IQCalibrate_5G(
 		}
 	}
 
-	if(!is2T)
+	if (!is2T)
 		goto Exit_IQK;
 
 	//1 path B TX IQK
@@ -5040,7 +5040,7 @@ phy_IQCalibrate_5G(
 	REG0xe40 = PHY_QueryBBReg(pAdapter, rTx_IQK, bMaskDWord);
 	REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
 	REG0xeb4 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord);
-	if(((REG0xeac&BIT(31)) == 0) && ((REG0xeb4&0x3FF0000)!=0x142))
+	if (((REG0xeac&BIT(31)) == 0) && ((REG0xeb4&0x3FF0000)!=0x142))
 	{
 		TX_X1 = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 		TX_Y1 = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
@@ -5051,12 +5051,12 @@ phy_IQCalibrate_5G(
 	}
 
 	//1 path B RX IQK
-	if(TX1IQKOK == true)
+	if (TX1IQKOK == true)
 	{
 
 		DBG_8192D("IQK for 5G: Path B Rx  START interface %u\n", pHalData->interfaceIndex);
 
-		if(pHalData->CurrentChannel<=140)
+		if (pHalData->CurrentChannel<=140)
 		{
 			REG0xe5c = 0x68160960;
 			extPAon = 0x1;
@@ -5111,7 +5111,7 @@ phy_IQCalibrate_5G(
 		//Check_RX_IQK_B_result()
 		REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
 		REG0xec4 = PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
-		if(((REG0xeac&BIT(30)) == 0) && (((REG0xec4&0x3FF0000)>>16)!=0x132))
+		if (((REG0xeac&BIT(30)) == 0) && (((REG0xec4&0x3FF0000)>>16)!=0x132))
 		{
 			RX_X1 =  (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
 			RX_Y1 =  (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
@@ -5122,7 +5122,7 @@ phy_IQCalibrate_5G(
 
 Exit_IQK:
 	//turn off external PA
-	if(pHalData->interfaceIndex == 1 || is2T)
+	if (pHalData->interfaceIndex == 1 || is2T)
 		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT(30), 0);
 
 	//Exit IQK mode
@@ -5138,7 +5138,7 @@ Exit_IQK:
 	//reload MAC default value
 	phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
-	if(!pdmpriv->bRfPiEnable)
+	if (!pdmpriv->bRfPiEnable)
 		phy_PIModeSwitch(pAdapter, false);
 	//Reload ADDA power saving parameters
 	phy_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
@@ -5193,7 +5193,7 @@ phy_IQCalibrate_5G_Normal(
 	//rtw_udelay_os(IQK_DELAY_TIME*1000*20);
 	rtw_mdelay_os(IQK_DELAY_TIME*20);
 
-	if(t==0)
+	if (t==0)
 	{
 		bbvalue = PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bMaskDWord);
 		//RTPRINT(FINIT, INIT_IQK, ("PHY_IQCalibrate()==>0x%08lx\n",bbvalue));
@@ -5202,7 +5202,7 @@ phy_IQCalibrate_5G_Normal(
 		// Save ADDA parameters, turn Path A ADDA on
 		phy_SaveADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 		phy_SaveMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
-		if(is2T)
+		if (is2T)
 			phy_SaveADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
 		else
 			phy_SaveADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D-1);
@@ -5214,7 +5214,7 @@ phy_IQCalibrate_5G_Normal(
 	//Neil Chen--2011--05--19
 	rfPathDiv =(u8) (PHY_QueryBBReg(pAdapter, 0xB30, bMaskDWord)>>27);
 
-	if((rfPathDiv&0x01)==1)   // Div on
+	if ((rfPathDiv&0x01)==1)   // Div on
 	{
 		phy_PathADDAOn(pAdapter, ADDA_REG, false, is2T);
 		//DbgPrint("=STEP= change ADDA Path to B Path\n");
@@ -5230,12 +5230,12 @@ phy_IQCalibrate_5G_Normal(
 	//MAC settings
 	phy_MACSettingCalibration(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
-	if(t==0)
+	if (t==0)
 	{
 		pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
 	}
 
-	if(!pdmpriv->bRfPiEnable){
+	if (!pdmpriv->bRfPiEnable){
 		// Switch BB to PI mode to do IQ Calibration.
 		phy_PIModeSwitch(pAdapter, true);
 	}
@@ -5251,7 +5251,7 @@ phy_IQCalibrate_5G_Normal(
 	PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x20000000);
 
 	//Page B AP setting for IQK
-	if(is2T) {
+	if (is2T) {
 		PHY_SetBBReg(pAdapter, rPdp_AntB, bMaskDWord, 0x00000000);
 		PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x20000000);
 	}
@@ -5262,7 +5262,7 @@ phy_IQCalibrate_5G_Normal(
 
 	{
 		PathAOK = phy_PathA_IQK_5G_Normal(pAdapter, is2T);
-		if(PathAOK == 0x03){
+		if (PathAOK == 0x03){
 			DBG_8192D("Path A IQK Success!!\n");
 			result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
@@ -5286,7 +5286,7 @@ phy_IQCalibrate_5G_Normal(
 		}
 	}
 
-	if(is2T){
+	if (is2T){
 		//_PHY_PathAStandBy(pAdapter);
 
 		// Turn Path B ADDA on
@@ -5294,7 +5294,7 @@ phy_IQCalibrate_5G_Normal(
 
 		{
 			PathBOK = phy_PathB_IQK_5G_Normal(pAdapter);
-			if(PathBOK == 0x03){
+			if (PathBOK == 0x03){
 				DBG_8192D("Path B IQK Success!!\n");
 				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
@@ -5317,9 +5317,9 @@ phy_IQCalibrate_5G_Normal(
 	//RTPRINT(FINIT, INIT_IQK, ("IQK:Back to BB mode, load original value!\n"));
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0);
 
-	if(t!=0)
+	if (t!=0)
 	{
-		if(is2T)
+		if (is2T)
 			phy_ReloadADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
 		else
 			phy_ReloadADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D-1);
@@ -5329,14 +5329,14 @@ phy_IQCalibrate_5G_Normal(
 		PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x010170b8);
 
 		//path B IQ path to DP block
-		if(is2T)
+		if (is2T)
 			PHY_SetBBReg(pAdapter, rPdp_AntB, bMaskDWord, 0x010170b8);
 #endif
 
 		// Reload MAC parameters
 		phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
-		if(!pdmpriv->bRfPiEnable){
+		if (!pdmpriv->bRfPiEnable){
 			// Switch back BB to SI mode after finish IQ Calibration.
 			phy_PIModeSwitch(pAdapter, false);
 		}
@@ -5370,7 +5370,7 @@ phy_LCCalibrate92D(
 	//Check continuous TX and Packet TX
 	tmpReg = rtw_read8(pAdapter, 0xd03);
 
-	if((tmpReg&0x70) != 0)			//Deal with contisuous TX case
+	if ((tmpReg&0x70) != 0)			//Deal with contisuous TX case
 		rtw_write8(pAdapter, 0xd03, tmpReg&0x8F);	//disable all continuous TX
 	else							// Deal with Packet TX case
 		rtw_write8(pAdapter, REG_TXPAUSE, 0xFF);			// block all queues
@@ -5424,7 +5424,7 @@ phy_LCCalibrate92D(
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_AC, bRFRegOffsetMask, RF_mode[index]);
 	}
 
-	if((tmpReg&0x70) != 0)
+	if ((tmpReg&0x70) != 0)
 	{
 		//Path-A
 		rtw_write8(pAdapter, 0xd03, tmpReg);
@@ -5447,7 +5447,7 @@ get_abs(
 {
 	u32 ret=0;
 
-	if(val1 >= val2)
+	if (val1 >= val2)
 	{
 		ret = val1 - val2;
 	}
@@ -5482,22 +5482,22 @@ phy_CalcCurvIndex(
 
 	for(i=start; i<chnl_num; i++)
 	{
-		if(is5G)
+		if (is5G)
 		{
-			if(i != start)
+			if (i != start)
 				pre_channel = channel;
 			channel = GetChnlFromPlace(i);	//actual channel number
 
-			if(i == start)
+			if (i == start)
 				pre_channel = channel;
 		}
 		else
 		{
-			if(i != start)
+			if (i != start)
 				pre_channel = channel;
 			channel = i+1;
 
-			if(i == start)
+			if (i == start)
 				pre_channel = channel;
 		}
 
@@ -5506,25 +5506,25 @@ phy_CalcCurvIndex(
 
 		for(j = start_base; j < end_base; j++)
 		{
-			if(channel == Base_chnl[j])
+			if (channel == Base_chnl[j])
 			{
 				bBase = true;
 				base_index = 0;
 				search_bound = (CV_CURVE_CNT*2);	//search every 128
 				break;
 			}
-			else if(channel < Base_chnl[j] || j == end_base-1)
+			else if (channel < Base_chnl[j] || j == end_base-1)
 			{
 #if 1
 				base_index = CurveIndex[GetRightChnlPlace(pre_channel)-1];
 #else
-				if(j > start_base && channel < Base_chnl[j])
+				if (j > start_base && channel < Base_chnl[j])
 					base_index = CurveIndex[GetRightChnlPlace(Base_chnl[j-1])-1];
 				else
 					base_index = CurveIndex[GetRightChnlPlace(Base_chnl[j])-1];
 #endif
 
-				if(base_index > 5)
+				if (base_index > 5)
 					base_index -= 5;	//search -5~5, not every 128
 				else
 					base_index = 0;
@@ -5540,7 +5540,7 @@ phy_CalcCurvIndex(
 		{
 			u4tmp = get_abs(TargetChnl[channel-1], CurveCountVal[j]);
 
-			if(u4tmp < smallestABSVal)
+			if (u4tmp < smallestABSVal)
 			{
 				CurveIndex[i] = j;
 				smallestABSVal = u4tmp;
@@ -5549,7 +5549,7 @@ phy_CalcCurvIndex(
 #endif
 
 		smallestABSVal = 0xffffffff;
-		//if(i == 0)
+		//if (i == 0)
 		//	RTPRINT(FINIT, INIT_IQK,("cosa, CurveIndex[%d] = %d channel %d\n", i, CurveIndex[i], index));
 		//RTPRINT(FINIT, INIT_IQK,("CurveIndex[%d] = 0x%x channel %d base_index 0x%x\n", i, CurveIndex[i], channel, base_index));
 	}
@@ -5574,7 +5574,7 @@ phy_LCCalibrate92DSW(
 	//Check continuous TX and Packet TX
 	tmpReg = rtw_read8(pAdapter, 0xd03);
 
-	if((tmpReg&0x70) != 0)			//Deal with contisuous TX case
+	if ((tmpReg&0x70) != 0)			//Deal with contisuous TX case
 		rtw_write8(pAdapter, 0xd03, tmpReg&0x8F);	//disable all continuous TX
 	else							// Deal with Packet TX case
 		rtw_write8(pAdapter, REG_TXPAUSE, 0xFF);			// block all queues
@@ -5597,7 +5597,7 @@ phy_LCCalibrate92DSW(
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, 0x700, 0x07);
 #endif
 
-		if(pAdapter->hw_init_completed)
+		if (pAdapter->hw_init_completed)
 		{
 			// switch CV-curve control by LC-calibration
 			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G7, BIT17, 0x0);
@@ -5629,7 +5629,7 @@ phy_LCCalibrate92DSW(
 	//Disable TX only need during phy lck, To reduce LCK affect on chariot,
 	// move enable tx here after PHY LCK finish, it will not affect sw lck result.
 	// zhiyuan 2011/06/03
-	if((tmpReg&0x70) != 0)
+	if ((tmpReg&0x70) != 0)
 	{
 		//Path-A
 		rtw_write8(pAdapter, 0xd03, tmpReg);
@@ -5646,7 +5646,7 @@ phy_LCCalibrate92DSW(
 
 		{
 
-			//if(index == 0 && pHalData->interfaceIndex == 0)
+			//if (index == 0 && pHalData->interfaceIndex == 0)
 			//{
 			//	RTPRINT(FINIT, INIT_IQK,("cosa, path-A / 5G LCK\n"));
 			//}
@@ -5677,7 +5677,7 @@ phy_LCCalibrate92DSW(
 
 			}
 
-			if(index == 0 && pHalData->interfaceIndex == 0)
+			if (index == 0 && pHalData->interfaceIndex == 0)
 				phy_CalcCurvIndex(pAdapter, TargetChnl_5G, curveCountVal, true, CurveIndex);
 			else
 				phy_CalcCurvIndex(pAdapter, TargetChnl_2G, curveCountVal, false, CurveIndex);
@@ -5836,7 +5836,7 @@ phy_APCalibrate(
 	//RTPRINT(FINIT, INIT_IQK, ("==>PHY_APCalibrate() delta %d\n", delta));
 	//RTPRINT(FINIT, INIT_IQK, ("AP Calibration for %s\n", (is2T ? "2T2R" : "1T1R")));
 
-	if(!is2T)
+	if (!is2T)
 		pathbound = 1;
 
 	//2 FOR NORMAL CHIP SETTINGS
@@ -5872,7 +5872,7 @@ phy_APCalibrate(
 	//save BB default value
 	for(index = 0; index < APK_BB_REG_NUM ; index++)
 	{
-		if(index == 0)		//skip
+		if (index == 0)		//skip
 			continue;
 		BB_backup[index] = PHY_QueryBBReg(pAdapter, BB_REG[index], bMaskDWord);
 	}
@@ -5887,7 +5887,7 @@ phy_APCalibrate(
 	{
 
 
-		if(path == RF_PATH_A)
+		if (path == RF_PATH_A)
 		{
 			//path A APK
 			//load APK setting
@@ -5926,7 +5926,7 @@ phy_APCalibrate(
 			}
 			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 		}
-		else if(path == RF_PATH_B)
+		else if (path == RF_PATH_B)
 		{
 			//path B APK
 			//load APK setting
@@ -5977,12 +5977,12 @@ phy_APCalibrate(
 		//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0xe70 %x\n", PHY_QueryBBReg(pAdapter, rRx_Wait_CCA, bMaskDWord)));
 
 		//BB to AP mode
-		if(path == 0)
+		if (path == 0)
 		{
 			for(index = 0; index < APK_BB_REG_NUM ; index++)
 			{
 
-				if(index == 0)		//skip
+				if (index == 0)		//skip
 					continue;
 				else if (index < 5)
 				PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_AP_MODE[index]);
@@ -6007,7 +6007,7 @@ phy_APCalibrate(
 		//MAC settings
 		phy_MACSettingCalibration(pAdapter, MAC_REG, MAC_backup);
 
-		if(path == RF_PATH_A)	//Path B to standby mode
+		if (path == RF_PATH_A)	//Path B to standby mode
 		{
 			PHY_SetRFReg(pAdapter, RF_PATH_B, RF_AC, bRFRegOffsetMask, 0x10000);
 		}
@@ -6019,7 +6019,7 @@ phy_APCalibrate(
 		}
 
 		delta_offset = ((delta+14)/2);
-		if(delta_offset < 0)
+		if (delta_offset < 0)
 			delta_offset = 0;
 		else if (delta_offset > 12)
 			delta_offset = 12;
@@ -6027,16 +6027,16 @@ phy_APCalibrate(
 		//AP calibration
 		for(index = 0; index < APK_BB_REG_NUM; index++)
 		{
-			if(index != 1)	//only DO PA11+PAD01001, AP RF setting
+			if (index != 1)	//only DO PA11+PAD01001, AP RF setting
 				continue;
 
 			tmpReg = APK_RF_init_value[path][index];
 #if 1
-			if(!pdmpriv->bAPKThermalMeterIgnore)
+			if (!pdmpriv->bAPKThermalMeterIgnore)
 			{
 				BB_offset = (tmpReg & 0xF0000) >> 16;
 
-				if(!(tmpReg & BIT15)) //sign bit 0
+				if (!(tmpReg & BIT15)) //sign bit 0
 				{
 					BB_offset = -BB_offset;
 				}
@@ -6047,7 +6047,7 @@ phy_APCalibrate(
 
 				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() APK index %d tmpReg 0x%x delta_V %d delta_offset %d\n", index, tmpReg, delta_V, delta_offset));
 
-				if(BB_offset < 0)
+				if (BB_offset < 0)
 				{
 					tmpReg = tmpReg & (~BIT15);
 					BB_offset = -BB_offset;
@@ -6078,7 +6078,7 @@ phy_APCalibrate(
 				}
 				PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 
-				if(path == RF_PATH_A)
+				if (path == RF_PATH_A)
 					tmpReg = PHY_QueryBBReg(pAdapter, rAPK, 0x03E00000);
 				else
 					tmpReg = PHY_QueryBBReg(pAdapter, rAPK, 0xF8000000);
@@ -6100,7 +6100,7 @@ phy_APCalibrate(
 	for(index = 0; index < APK_BB_REG_NUM ; index++)
 	{
 
-		if(index == 0)		//skip
+		if (index == 0)		//skip
 			continue;
 		PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_backup[index]);
 	}
@@ -6112,7 +6112,7 @@ phy_APCalibrate(
 	for(path = 0; path < pathbound; path++)
 	{
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask, regD[path]);
-		if(path == RF_PATH_B)
+		if (path == RF_PATH_B)
 		{
 			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);
 			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20101);
@@ -6130,14 +6130,14 @@ phy_APCalibrate(
 	{
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G1_G4, bRFRegOffsetMask,
 		((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (APK_result[path][1] << 5) | APK_result[path][1]));
-		if(path == RF_PATH_A)
+		if (path == RF_PATH_A)
 			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask,
 			((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x00 << 5) | 0x05));
 		else
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask,
 			((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x02 << 5) | 0x05));
 
-		//if(!IS_HARDWARE_TYPE_8723A(pAdapter))
+		//if (!IS_HARDWARE_TYPE_8723A(pAdapter))
 		//	PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G9_G11, bRFRegOffsetMask,
 		//	((0x08 << 15) | (0x08 << 10) | (0x08 << 5) | 0x08));
 	}
@@ -6154,13 +6154,13 @@ static void phy_SetRFPathSwitch(
 	)
 {
 
-	if(!pAdapter->hw_init_completed)
+	if (!pAdapter->hw_init_completed)
 	{
 		PHY_SetBBReg(pAdapter, 0x4C, BIT23, 0x01);
 		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
 	}
 
-	if(main)
+	if (main)
 		PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x2);
 	else
 		PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x1);
@@ -6193,7 +6193,7 @@ rtl8192d_PHY_IQCalibrate(
 #endif
 
 	//ignore IQK when continuous Tx
-	if(bStartContTx || bSingleTone || bCarrierSuppression)
+	if (bStartContTx || bSingleTone || bCarrierSuppression)
 		return;
 
 #if DISABLE_BB_RF
@@ -6201,7 +6201,7 @@ rtl8192d_PHY_IQCalibrate(
 #endif
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(pHalData->bSlaveOfDMSP)
+	if (pHalData->bSlaveOfDMSP)
 		return;
 #endif
 
@@ -6226,46 +6226,46 @@ rtl8192d_PHY_IQCalibrate(
 	//RT_TRACE(COMP_INIT,DBG_LOUD,("Acquire Mutex in IQCalibrate \n"));
 	for (i=0; i<3; i++)
 	{
-		if(pHalData->CurrentBandType92D == BAND_ON_5G)
+		if (pHalData->CurrentBandType92D == BAND_ON_5G)
 		{
 			phy_IQCalibrate_5G_Normal(pAdapter, result, i);
 		}
-		else if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+		else if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 		{
-			if(IS_92D_SINGLEPHY(pHalData->VersionID))
+			if (IS_92D_SINGLEPHY(pHalData->VersionID))
 				phy_IQCalibrate(pAdapter, result, i, true);
 			else
 				phy_IQCalibrate(pAdapter, result, i, false);
 		}
 
-		if(i == 1)
+		if (i == 1)
 		{
 			is12simular = phy_SimularityCompare(pAdapter, result, 0, 1);
-			if(is12simular)
+			if (is12simular)
 			{
 				final_candidate = 0;
 				break;
 			}
 		}
 
-		if(i == 2)
+		if (i == 2)
 		{
 			is13simular = phy_SimularityCompare(pAdapter, result, 0, 2);
-			if(is13simular)
+			if (is13simular)
 			{
 				final_candidate = 0;
 				break;
 			}
 
 			is23simular = phy_SimularityCompare(pAdapter, result, 1, 2);
-			if(is23simular)
+			if (is23simular)
 				final_candidate = 1;
 			else
 			{
 				for(i = 0; i < 8; i++)
 					RegTmp += result[3][i];
 
-				if(RegTmp != 0)
+				if (RegTmp != 0)
 					final_candidate = 3;
 				else
 					final_candidate = 0xFF;
@@ -6288,7 +6288,7 @@ rtl8192d_PHY_IQCalibrate(
 		//RTPRINT(FINIT, INIT_IQK, ("IQK: RegE94=%lx RegE9C=%lx RegEA4=%lx RegEAC=%lx RegEB4=%lx RegEBC=%lx RegEC4=%lx RegECC=%lx\n ", RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC));
 	}
 
-	if(final_candidate != 0xff)
+	if (final_candidate != 0xff)
 	{
 		pdmpriv->RegE94 = RegE94 = result[final_candidate][0];
 		pdmpriv->RegE9C = RegE9C = result[final_candidate][1];
@@ -6308,9 +6308,9 @@ rtl8192d_PHY_IQCalibrate(
 		pdmpriv->RegE9C = pdmpriv->RegEBC = 0x0;		//Y default value
 	}
 
-	if((RegE94 != 0)/*&&(RegEA4 != 0)*/)
+	if ((RegE94 != 0)/*&&(RegEA4 != 0)*/)
 	{
-		if(pHalData->CurrentBandType92D == BAND_ON_5G)
+		if (pHalData->CurrentBandType92D == BAND_ON_5G)
 			phy_PathAFillIQKMatrix_5G_Normal(pAdapter, bPathAOK, result, final_candidate, (RegEA4 == 0));
 		else
 			phy_PathAFillIQKMatrix(pAdapter, bPathAOK, result, final_candidate, (RegEA4 == 0));
@@ -6318,16 +6318,16 @@ rtl8192d_PHY_IQCalibrate(
 
 	if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
 	{
-		if((RegEB4 != 0)/*&&(RegEC4 != 0)*/)
+		if ((RegEB4 != 0)/*&&(RegEC4 != 0)*/)
 		{
-			if(pHalData->CurrentBandType92D == BAND_ON_5G)
+			if (pHalData->CurrentBandType92D == BAND_ON_5G)
 				phy_PathBFillIQKMatrix_5G_Normal(pAdapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
 			else
 				phy_PathBFillIQKMatrix(pAdapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
 		}
 	}
 
-	if(IS_HARDWARE_TYPE_8192D(pAdapter) && final_candidate != 0xFF)
+	if (IS_HARDWARE_TYPE_8192D(pAdapter) && final_candidate != 0xFF)
 	{
 		Indexforchannel = rtl8192d_GetRightChnlPlaceforIQK(pHalData->CurrentChannel);
 
@@ -6384,11 +6384,11 @@ rtl8192d_PHY_LCCalibrate(
 #endif
 
 	//ignore IQK when continuous Tx
-	if(bStartContTx || bSingleTone || bCarrierSuppression)
+	if (bStartContTx || bSingleTone || bCarrierSuppression)
 		return;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(BuddyAdapter != NULL &&
+	if (BuddyAdapter != NULL &&
 		((pHalData->interfaceIndex == 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G) ||
 		(pHalData->interfaceIndex == 1 && pHalData->CurrentBandType92D == BAND_ON_5G)))
 	{
@@ -6401,14 +6401,14 @@ rtl8192d_PHY_LCCalibrate(
 	}
 #endif
 
-	if(pmlmeext->sitesurvey_res.state == SCAN_PROCESS)
+	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS)
 		return;
 
 	pHalData->bLCKInProgress = true;
 
 	//DBG_8192D("LCK:Start!!!interface %d currentband %x delay %d ms\n", pHalData->interfaceIndex, pHalData->CurrentBandType92D, timecount);
 
-	if(IS_92D_SINGLEPHY(pHalData->VersionID))
+	if (IS_92D_SINGLEPHY(pHalData->VersionID))
 	{
 		phy_LCCalibrate(pAdapter, true);
 	}
@@ -6435,13 +6435,13 @@ rtl8192d_PHY_APCalibrate(
 	return;
 #endif
 
-	//if(IS_HARDWARE_TYPE_8192D(pAdapter))
+	//if (IS_HARDWARE_TYPE_8192D(pAdapter))
 		return;
 
-	if(pdmpriv->bAPKdone)
+	if (pdmpriv->bAPKdone)
 		return;
 
-	if(IS_92D_SINGLEPHY(pHalData->VersionID)){
+	if (IS_92D_SINGLEPHY(pHalData->VersionID)){
 		phy_APCalibrate(pAdapter, delta, true);
 	}
 	else{
@@ -6464,13 +6464,13 @@ PHY_UpdateBBRFConfiguration8192D(
 
 	//Update BB
 	//r_select_5G for path_A/B.0 for 2.4G,1 for 5G
-	if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 	{// 2.4G band
 		//r_select_5G for path_A/B,0x878
 
 		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT0, 0x0);
 		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT15, 0x0);
-		if(pHalData->MacPhyMode92D != DUALMAC_DUALPHY)
+		if (pHalData->MacPhyMode92D != DUALMAC_DUALPHY)
 		{
 			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT16, 0x0);
 			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT31, 0x0);
@@ -6488,13 +6488,13 @@ PHY_UpdateBBRFConfiguration8192D(
 		PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
 		PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x40000100);
 
-		if(pregistrypriv->special_rf_path == 1)
+		if (pregistrypriv->special_rf_path == 1)
 			PHY_SetBBReg(Adapter, rCCK0_AFESetting, bMaskByte3, 0x80);
-		else if(pregistrypriv->special_rf_path == 2)
+		else if (pregistrypriv->special_rf_path == 2)
 			PHY_SetBBReg(Adapter, rCCK0_AFESetting, bMaskByte3, 0x45);
 
 
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
 		{
 			PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
 			pdmpriv->OFDM_index[RF_PATH_A] = 0x0c;
@@ -6536,7 +6536,7 @@ PHY_UpdateBBRFConfiguration8192D(
 		//r_select_5G for path_A/B
 		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT0, 0x1);
 		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT15, 0x1);
-		if(pHalData->MacPhyMode92D != DUALMAC_DUALPHY)
+		if (pHalData->MacPhyMode92D != DUALMAC_DUALPHY)
 		{
 			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT16, 0x1);
 			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT31, 0x1);
@@ -6551,14 +6551,14 @@ PHY_UpdateBBRFConfiguration8192D(
 		PHY_SetBBReg(Adapter, 0xB30, 0x00F00000, 0x0);
 
 		//TX BB gain shift,Just for testchip,0xc80,0xc88
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
 		{
-			if(pHalData->interfaceIndex == 0)
+			if (pHalData->interfaceIndex == 0)
 				bInternalPA = pHalData->InternalPA5G[0];
 			else
 				bInternalPA = pHalData->InternalPA5G[1];
 
-			if(bInternalPA)
+			if (bInternalPA)
 			{
 				PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x2d4000b5);
 				pdmpriv->OFDM_index[RF_PATH_A] = 0x12;
@@ -6571,7 +6571,7 @@ PHY_UpdateBBRFConfiguration8192D(
 		}
 		else
 		{
-			if(pHalData->InternalPA5G[0])
+			if (pHalData->InternalPA5G[0])
 			{
 				PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x2d4000b5);
 				pdmpriv->OFDM_index[RF_PATH_A] = 0x12;
@@ -6582,7 +6582,7 @@ PHY_UpdateBBRFConfiguration8192D(
 				pdmpriv->OFDM_index[RF_PATH_A] = 0x18;
 			}
 
-			if(pHalData->InternalPA5G[1])
+			if (pHalData->InternalPA5G[1])
 			{
 				PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x2d4000b5);
 				pdmpriv->OFDM_index[RF_PATH_B] = 0x12;
@@ -6596,7 +6596,7 @@ PHY_UpdateBBRFConfiguration8192D(
 
 		//DBG_8192D("==>PHY_UpdateBBRFConfiguration8192D() interface %d BAND_ON_5G settings OFDM index 0x%x\n", pHalData->interfaceIndex, pdmpriv->OFDM_index[RF_PATH_A]);
 		PHY_SetBBReg(Adapter, 0xB30, BIT27, 0x0);
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
 		{
 			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFInterfaceSW, BIT10|BIT6|BIT5,
 				(pHalData->EEPROMCC&BIT5));
@@ -6605,7 +6605,7 @@ PHY_UpdateBBRFConfiguration8192D(
 			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT15,
 				(pHalData->EEPROMCC&BIT4) >> 4);
 			PHY_SetBBReg(Adapter, rPdp_AntA, bMaskDWord, 0x01017098);
-			if(pdmpriv->bDPKdone[RF_PATH_A])
+			if (pdmpriv->bDPKdone[RF_PATH_A])
 				PHY_SetBBReg(Adapter, 0xb68, bMaskDWord, 0x08080000);
 			else
 				PHY_SetBBReg(Adapter, 0xb68, bMaskDWord, 0x20000000);
@@ -6622,11 +6622,11 @@ PHY_UpdateBBRFConfiguration8192D(
 				((pHalData->EEPROMCC&BIT4) >> 4)|((pHalData->EEPROMCC&BIT6) << 10));
 			PHY_SetBBReg(Adapter, rPdp_AntA, bMaskDWord, 0x01017098);
 			PHY_SetBBReg(Adapter, rPdp_AntB, bMaskDWord, 0x01017098);
-			if(pdmpriv->bDPKdone[RF_PATH_A])
+			if (pdmpriv->bDPKdone[RF_PATH_A])
 				PHY_SetBBReg(Adapter, 0xb68, bMaskDWord, 0x08080000);
 			else
 				PHY_SetBBReg(Adapter, 0xb68, bMaskDWord, 0x20000000);
-			if(pdmpriv->bDPKdone[RF_PATH_B])
+			if (pdmpriv->bDPKdone[RF_PATH_B])
 				PHY_SetBBReg(Adapter, 0xb6c, bMaskDWord, 0x08080000);
 			else
 				PHY_SetBBReg(Adapter, 0xb6c, bMaskDWord, 0x20000000);
@@ -6648,7 +6648,7 @@ PHY_UpdateBBRFConfiguration8192D(
 	//Update RF
 	for(eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 	{
-		if(pHalData->CurrentBandType92D == BAND_ON_2_4G){
+		if (pHalData->CurrentBandType92D == BAND_ON_2_4G){
 			//MOD_AG for RF paht_A 0x18 BIT8,BIT16
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT8|BIT16|BIT18|0xFF, 1);
 
@@ -6662,13 +6662,13 @@ PHY_UpdateBBRFConfiguration8192D(
 		}
 
 #if 1
-		if((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
+		if ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G))
 		{
 			//Set right channel on RF reg0x18 for another mac.
-			if(pHalData->interfaceIndex == 0) //set MAC1 default channel if MAC1 not up.
+			if (pHalData->interfaceIndex == 0) //set MAC1 default channel if MAC1 not up.
 			{
-				if(!(rtw_read8(Adapter, REG_MAC1)&MAC1_ON))
+				if (!(rtw_read8(Adapter, REG_MAC1)&MAC1_ON))
 				{
 					rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
 					PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW|MAC0_ACCESS_PHY1, bRFRegOffsetMask, 0x97524); //set channel 36
@@ -6677,9 +6677,9 @@ PHY_UpdateBBRFConfiguration8192D(
 				}
 			}
 			else
-			if(pHalData->interfaceIndex == 1)//set MAC0 default channel
+			if (pHalData->interfaceIndex == 1)//set MAC0 default channel
 			{
-				if(!(rtw_read8(Adapter, REG_MAC0)&MAC0_ON))
+				if (!(rtw_read8(Adapter, REG_MAC0)&MAC0_ON))
 				{
 					rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 					PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW|MAC1_ACCESS_PHY0, bRFRegOffsetMask, 0x87401); // set channel 1
@@ -6693,11 +6693,11 @@ PHY_UpdateBBRFConfiguration8192D(
 	}
 
 	//Update for all band.
-	if(pHalData->rf_type == RF_1T1R)
+	if (pHalData->rf_type == RF_1T1R)
 	{ //DMDP
 		//Use antenna 0,0xc04,0xd04
 #if MP_DRIVER == 1
-		if(!bisBandSwitch)
+		if (!bisBandSwitch)
 #endif
 		{
 		PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x11);
@@ -6705,7 +6705,7 @@ PHY_UpdateBBRFConfiguration8192D(
 		}
 
 		//enable ad/da clock1 for dual-phy reg0x888
-		if(pHalData->interfaceIndex == 0)
+		if (pHalData->interfaceIndex == 0)
 			PHY_SetBBReg(Adapter, rFPGA0_AdDaClockEn, BIT12|BIT13, 0x3);
 		else
 		{
@@ -6717,7 +6717,7 @@ PHY_UpdateBBRFConfiguration8192D(
 			//--------------------------------------end
 
 			bMAC0NotUp = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
-			if(bMAC0NotUp)
+			if (bMAC0NotUp)
 			{
 				PHY_SetBBReg(Adapter, rFPGA0_AdDaClockEn|MAC1_ACCESS_PHY0, BIT12|BIT13, 0x3);
 				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
@@ -6729,13 +6729,13 @@ PHY_UpdateBBRFConfiguration8192D(
 	}
 	else // 2T2R //Single PHY
 	{
-		if(pregistrypriv->special_rf_path == 2)
+		if (pregistrypriv->special_rf_path == 2)
 		{
 			PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x22);
 			PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, 0x2);
 			PHY_SetBBReg(Adapter, rFPGA1_TxInfo, bMaskDWord, 0x82221322);	//OFDM Tx
 		}
-		else if(pregistrypriv->special_rf_path == 1)
+		else if (pregistrypriv->special_rf_path == 1)
 		{
 			PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x11);
 			PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, 0x1);
@@ -6756,7 +6756,7 @@ PHY_UpdateBBRFConfiguration8192D(
 	}
 
 #if MP_DRIVER == 1
-	if(bisBandSwitch)
+	if (bisBandSwitch)
 	{
 		PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, pdmpriv->RegC04_MP);
 		PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, pdmpriv->RegD04_MP);
@@ -6795,7 +6795,7 @@ void PHY_ReadMacPhyMode92D(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	u8	MacPhyCrValue = 0;
 
-	if(AutoloadFail)
+	if (AutoloadFail)
 	{
 		pHalData->MacPhyMode92D = SINGLEMAC_SINGLEPHY;
 		return;
@@ -6805,11 +6805,11 @@ void PHY_ReadMacPhyMode92D(
 
 	DBG_8192D("PHY_ReadMacPhyMode92D():   MAC_PHY_CTRL Value %x \n",MacPhyCrValue);
 
-	if((MacPhyCrValue&0x03) == 0x03)
+	if ((MacPhyCrValue&0x03) == 0x03)
 	{
 		pHalData->MacPhyMode92D = DUALMAC_DUALPHY;
 	}
-	else if((MacPhyCrValue&0x03) == 0x01)
+	else if ((MacPhyCrValue&0x03) == 0x01)
 	{
 		pHalData->MacPhyMode92D = DUALMAC_SINGLEPHY;
 	}
@@ -6886,7 +6886,7 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 #ifdef CONFIG_DUALMAC_CONCURRENT
 //get bMasetOfDMSP and bSlaveOfDMSP sync with buddy adapter
 			ACQUIRE_GLOBAL_MUTEX(GlobalCounterForMutex);
-			if(BuddyAdapter != NULL)
+			if (BuddyAdapter != NULL)
 			{
 				pHalDataBuddyAdapter = GET_HAL_DATA(BuddyAdapter);
 				pHalData->bMasterOfDMSP = !pHalDataBuddyAdapter->bMasterOfDMSP;
@@ -6895,12 +6895,12 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 			}
 			else
 			{
-				if(pHalData->interfaceIndex == 0)
+				if (pHalData->interfaceIndex == 0)
 				{
 					pHalData->bMasterOfDMSP = true;
 					pHalData->bSlaveOfDMSP = false;
 				}
-				else if(pHalData->interfaceIndex == 1)
+				else if (pHalData->interfaceIndex == 1)
 				{
 					pHalData->bMasterOfDMSP = false;
 					pHalData->bSlaveOfDMSP = true;
@@ -6922,7 +6922,7 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 		case DUALMAC_DUALPHY:
 			pHalData->rf_type = RF_1T1R;
 			pHalData->VersionID = (enum VERSION_8192D)(pHalData->VersionID & RF_TYPE_1T1R);
-			if(pHalData->interfaceIndex == 1){
+			if (pHalData->interfaceIndex == 1){
 				pHalData->BandSet92D = BAND_ON_5G;
 				pHalData->CurrentBandType92D = BAND_ON_5G;//Now we let MAC1 run on 5G band.
 			}
@@ -6938,13 +6938,13 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 			break;
 	}
 
-	/*if(Adapter->bInHctTest&&(pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY))
+	/*if (Adapter->bInHctTest&&(pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY))
 	{
 		pHalData->CurrentBandType92D=BAND_ON_2_4G;
 		pHalData->BandSet92D = BAND_ON_2_4G;
 	}*/
 
-	if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 		pHalData->CurrentChannel = 1;
 	else
 		pHalData->CurrentChannel = 36;
@@ -7052,7 +7052,7 @@ rtl8192d_PHY_InitRxSetting(
 	return;
 #endif
 
-	if(pHalData->interfaceIndex == 0)
+	if (pHalData->interfaceIndex == 0)
 	{
 		rtw_write32(Adapter, REG_MACID, 0x87654321);
 		rtw_write32(Adapter, 0x0700, 0x87654321);
@@ -7114,20 +7114,20 @@ HalChangeCCKStatus8192D(
 
 	//DBG_8192D("MAC %d: =====> ChangeCCKStatus8192D \n",pHalData->interfaceIndex);
 
-	if(pHalData->BandSet92D != BAND_ON_BOTH)
+	if (pHalData->BandSet92D != BAND_ON_BOTH)
 	{
 		//DBG_8192D("ChangeCCKStatus8192D():  Skip \n");
 		return;
 	}
 
-	if(bCCKDisable)
+	if (bCCKDisable)
 	{
-		//if(ACTING_AS_AP(Adapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, FALSE)) || (Adapter->MgntInfo.mIbss))
+		//if (ACTING_AS_AP(Adapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, FALSE)) || (Adapter->MgntInfo.mIbss))
 		//	StopTxBeacon(Adapter);
 		rtw_write16(Adapter, REG_RL,0x0101);
 		for(i=0;i<30;i++)
 		{
-			if(rtw_read32(Adapter, 0x200) != rtw_read32(Adapter, 0x204))
+			if (rtw_read32(Adapter, 0x200) != rtw_read32(Adapter, 0x204))
 			{
 				DBG_8192D("packet in tx packet buffer aaaaaaaaa 0x204 %x  \n", rtw_read32(Adapter, 0x204));
 				DBG_8192D("packet in tx packet buffer aaaaaaa 0x200 %x  \n", rtw_read32(Adapter, 0x200));
@@ -7140,14 +7140,14 @@ HalChangeCCKStatus8192D(
 			}
 		}
 
-		/*if((BuddyAdapter != NULL) && BuddyAdapter->bHWInitReady && (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY))
+		/*if ((BuddyAdapter != NULL) && BuddyAdapter->bHWInitReady && (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY))
 		{
-			if(ACTING_AS_AP(BuddyAdapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(BuddyAdapter, FALSE)) || BuddyAdapter->MgntInfo.mIbss)
+			if (ACTING_AS_AP(BuddyAdapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(BuddyAdapter, FALSE)) || BuddyAdapter->MgntInfo.mIbss)
 				StopTxBeacon(BuddyAdapter);
 			PlatformEFIOWrite2Byte(BuddyAdapter, REG_RL,0x0101);
 			for(i=0;i<30;i++)
 			{
-				if(PlatformEFIORead4Byte(BuddyAdapter, 0x200) != PlatformEFIORead4Byte(BuddyAdapter, 0x204))
+				if (PlatformEFIORead4Byte(BuddyAdapter, 0x200) != PlatformEFIORead4Byte(BuddyAdapter, 0x204))
 				{
 					RT_TRACE(COMP_EASY_CONCURRENT,DBG_LOUD,("packet in tx packet buffer aaaaaaaaa 0x204 %x  \n", PlatformEFIORead4Byte(BuddyAdapter, 0x204)));
 					RT_TRACE(COMP_EASY_CONCURRENT,DBG_LOUD,("packet in tx packet buffer aaaaaaa 0x200 %x  \n", PlatformEFIORead4Byte(BuddyAdapter, 0x200)));
@@ -7167,14 +7167,14 @@ HalChangeCCKStatus8192D(
 	else
 	{
 		u8	RetryLimit = 0x30;
-		//if(ACTING_AS_AP(Adapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, FALSE)) || Adapter->MgntInfo.mIbss)
+		//if (ACTING_AS_AP(Adapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, FALSE)) || Adapter->MgntInfo.mIbss)
 		//	ResumeTxBeacon(Adapter);
 
 		rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
 
-		/*if((BuddyAdapter != NULL) && (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY))
+		/*if ((BuddyAdapter != NULL) && (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY))
 		{
-			if(ACTING_AS_AP(BuddyAdapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(BuddyAdapter, FALSE)) || BuddyAdapter->MgntInfo.mIbss)
+			if (ACTING_AS_AP(BuddyAdapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(BuddyAdapter, FALSE)) || BuddyAdapter->MgntInfo.mIbss)
 				ResumeTxBeacon(BuddyAdapter);
 
 			PlatformEFIOWrite2Byte(BuddyAdapter, REG_RL,
@@ -7196,7 +7196,7 @@ PHY_InitPABias92D(struct rtw_adapter * A
 
 	DBG_8192D("PHY_InitPABias92D 0x3FA 0x%x \n",tmpU1b);
 
-	if(!(tmpU1b & BIT0) && (is92 || pHalData->interfaceIndex == 0))
+	if (!(tmpU1b & BIT0) && (is92 || pHalData->interfaceIndex == 0))
 	{
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x07401);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
@@ -7209,7 +7209,7 @@ PHY_InitPABias92D(struct rtw_adapter * A
 		DBG_8192D("2G PA BIAS path A\n");
 	}
 
-	if(!(tmpU1b & BIT1) && (is92 || pHalData->interfaceIndex == 1))
+	if (!(tmpU1b & BIT1) && (is92 || pHalData->interfaceIndex == 1))
 	{
 		eRFPath = pHalData->interfaceIndex == 1?RF_PATH_A:RF_PATH_B;
 		PHY_SetRFReg(Adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x07401);
@@ -7223,7 +7223,7 @@ PHY_InitPABias92D(struct rtw_adapter * A
 		DBG_8192D("2G PA BIAS path B\n");
 	}
 
-	if(!(tmpU1b & BIT2) && (is92 || pHalData->interfaceIndex == 0))
+	if (!(tmpU1b & BIT2) && (is92 || pHalData->interfaceIndex == 0))
 	{
 		//5GL_channel
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x17524);
@@ -7252,7 +7252,7 @@ PHY_InitPABias92D(struct rtw_adapter * A
 		DBG_8192D("5G PA BIAS path A\n");
 	}
 
-	if(!(tmpU1b & BIT3) && (is92 || pHalData->interfaceIndex == 1))
+	if (!(tmpU1b & BIT3) && (is92 || pHalData->interfaceIndex == 1))
 	{
 		eRFPath = (pHalData->interfaceIndex == 1)?RF_PATH_A:RF_PATH_B;
 		//5GL_channel
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
@@ -181,17 +181,17 @@ rtl8192d_PHY_RF6052SetCckTxPower(
 	u8			idx1, idx2;
 	u8*			ptr;
 
-	if(pHalData->EEPROMRegulatory != 0)
+	if (pHalData->EEPROMRegulatory != 0)
 		TurboScanOff = true;
 
-	if(pmlmeext->sitesurvey_res.state == SCAN_PROCESS)
+	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS)
 	{
 		TxAGC[RF_PATH_A] = 0x3f3f3f3f;
 		TxAGC[RF_PATH_B] = 0x3f3f3f3f;
 
 		TurboScanOff =  true;//disable Turbo scan
 
-		if(TurboScanOff)
+		if (TurboScanOff)
 		{
 			for(idx1=RF_PATH_A; idx1<=RF_PATH_B; idx1++)
 			{
@@ -215,7 +215,7 @@ rtl8192d_PHY_RF6052SetCckTxPower(
 					(pPowerlevel[idx1]<<16) | (pPowerlevel[idx1]<<24);
 			}
 
-			if(pHalData->EEPROMRegulatory==0)
+			if (pHalData->EEPROMRegulatory==0)
 			{
 				tmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][6]) +
 						(pHalData->MCSTxPowerLevelOriginalOffset[0][7]<<8);
@@ -233,7 +233,7 @@ rtl8192d_PHY_RF6052SetCckTxPower(
 		ptr = (u8 *)(&(TxAGC[idx1]));
 		for(idx2=0; idx2<4; idx2++)
 		{
-			if(*ptr > RF6052_MAX_TX_PWR)
+			if (*ptr > RF6052_MAX_TX_PWR)
 				*ptr = RF6052_MAX_TX_PWR;
 			ptr++;
 		}
@@ -290,7 +290,7 @@ static void getPowerBase(
 	for(i=0; i<2; i++)
 	{
 		//Check HT20 to HT40 diff
-		if(pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
+		if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
 		{
 			HT20_pwrdiff = pHalData->TxPwrHt20Diff[i][Channel-1];
 			powerlevel[i] += HT20_pwrdiff;
@@ -314,11 +314,11 @@ static u8 getChnlGroupByPG(u8 chnlindex)
 		group = 0;
 	else if (channel_info[chnlindex] <= 9)		// Channel 4-9
 		group = 1;
-	else if(channel_info[chnlindex] <=14)				// Channel 10-14
+	else if (channel_info[chnlindex] <=14)				// Channel 10-14
 		group = 2;
-	else if(channel_info[chnlindex] <= 64)
+	else if (channel_info[chnlindex] <= 64)
 		group = 6;
-	else if(channel_info[chnlindex] <= 140)
+	else if (channel_info[chnlindex] <= 140)
 		group = 7;
 	else
 		group = 8;
@@ -360,13 +360,13 @@ static void getTxPowerWriteValByRegulato
 				break;
 			case 1:	// Realtek regulatory
 					// increase power diff defined by Realtek for regulatory
-					if(pHalData->pwrGroupCnt == 1)
+					if (pHalData->pwrGroupCnt == 1)
 						chnlGroup = 0;
-					if(pHalData->pwrGroupCnt >= MAX_PG_GROUP)
+					if (pHalData->pwrGroupCnt >= MAX_PG_GROUP)
 					{
 						chnlGroup = getChnlGroupByPG(Channel-1);
 
-						if(pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
+						if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
 							chnlGroup++;
 						else	   // 40M BW
 							chnlGroup += 4;
@@ -400,7 +400,7 @@ static void getTxPowerWriteValByRegulato
 					//	((rf==0)?'A':'B'), pHalData->PwrGroupHT20[rf][Channel-1]));
 				//}
 
-				if(index < 2)
+				if (index < 2)
 					pwr_diff = pHalData->TxPwrLegacyHtDiff[rf][Channel-1];
 				else if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
 					pwr_diff = pHalData->TxPwrHt20Diff[rf][Channel-1];
@@ -414,7 +414,7 @@ static void getTxPowerWriteValByRegulato
 
 				//RTPRINT(FPHY, PHY_TXPWR, ("customer pwr limit  rf(%c) = 0x%x\n", ((rf==0)?'A':'B'), customer_pwr_limit));
 
-				if(pwr_diff >= customer_pwr_limit)
+				if (pwr_diff >= customer_pwr_limit)
 					pwr_diff = 0;
 				else
 					pwr_diff = customer_pwr_limit - pwr_diff;
@@ -423,7 +423,7 @@ static void getTxPowerWriteValByRegulato
 				{
 					pwr_diff_limit[i] = (u8)((pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]&(0x7f<<(i*8)))>>(i*8));
 
-					if(pwr_diff_limit[i] > pwr_diff)
+					if (pwr_diff_limit[i] > pwr_diff)
 						pwr_diff_limit[i] = pwr_diff;
 				}
 
@@ -444,18 +444,18 @@ static void getTxPowerWriteValByRegulato
 
 		// 20100628 Joseph: High power mode for BT-Coexist mechanism.
 		// This mechanism is only applied when Driver-Highpower-Mechanism is OFF.
-		if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_BT1)
+		if (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_BT1)
 		{
 			//RTPRINT(FBT, BT_TRACE, ("Tx Power (-6)\n"));
 			writeVal = writeVal - 0x06060606;
 		}
-		else if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_BT2)
+		else if (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_BT2)
 		{
 			//RTPRINT(FBT, BT_TRACE, ("Tx Power (-0)\n"));
 			writeVal = writeVal ;
 		}
 
-		//if(pMgntInfo->bDisableTXPowerByRate)
+		//if (pMgntInfo->bDisableTXPowerByRate)
 		//{
 			// add for  OID_RT_11N_TX_POWER_BY_RATE ,disable tx powre change by rate
 		//	writeVal = 0x2c2c2c2c;
@@ -492,7 +492,7 @@ static void writeOFDMPowerReg(
 		}
 		writeVal = (pwr_val[3]<<24) | (pwr_val[2]<<16) |(pwr_val[1]<<8) |pwr_val[0];
 
-		if(rf == 0)
+		if (rf == 0)
 			RegOffset = RegOffset_A[index];
 		else
 			RegOffset = RegOffset_B[index];
@@ -500,19 +500,19 @@ static void writeOFDMPowerReg(
 		//RTPRINT(FPHY, PHY_TXPWR, ("Set 0x%x = %08x\n", RegOffset, writeVal));
 
 		// 201005115 Joseph: Set Tx Power diff for Tx power training mechanism.
-		if(((pHalData->rf_type == RF_2T2R) &&
+		if (((pHalData->rf_type == RF_2T2R) &&
 				(RegOffset == rTxAGC_A_Mcs15_Mcs12 || RegOffset == rTxAGC_B_Mcs15_Mcs12))||
 		     ((pHalData->rf_type != RF_2T2R) &&
 				(RegOffset == rTxAGC_A_Mcs07_Mcs04 || RegOffset == rTxAGC_B_Mcs07_Mcs04))	)
 		{
 			writeVal = pwr_val[3];
-			if(RegOffset == rTxAGC_A_Mcs15_Mcs12 || RegOffset == rTxAGC_A_Mcs07_Mcs04)
+			if (RegOffset == rTxAGC_A_Mcs15_Mcs12 || RegOffset == rTxAGC_A_Mcs07_Mcs04)
 				RegOffset = 0xc90;
-			if(RegOffset == rTxAGC_B_Mcs15_Mcs12 || RegOffset == rTxAGC_B_Mcs07_Mcs04)
+			if (RegOffset == rTxAGC_B_Mcs15_Mcs12 || RegOffset == rTxAGC_B_Mcs07_Mcs04)
 				RegOffset = 0xc98;
 			for(i=0; i<3; i++)
 			{
-				if(i!=2)
+				if (i!=2)
 					writeVal = (writeVal>8)?(writeVal-8):0;
 				else
 					writeVal = (writeVal>6)?(writeVal-6):0;
@@ -583,7 +583,7 @@ rtl8192d_PHY_EnableAnotherPHY(
 	if (!(u1bTmp&MAC_ON_BIT))
 	{
 		// Enable BB and RF power
-		if(bMac0)
+		if (bMac0)
 			MaskForPHYSet = MAC0_ACCESS_PHY1;
 		else
 			MaskForPHYSet = MAC1_ACCESS_PHY0;
@@ -612,7 +612,7 @@ rtl8192d_PHY_PowerDownAnotherPHY(
 
 	if (!(u1bTmp&MAC_ON_BIT)) {
 		// power down RF radio A according to YuNan's advice.
-		if(bMac0)
+		if (bMac0)
 			MaskforPhySet = MAC0_ACCESS_PHY1;
 		else
 			MaskforPhySet = MAC1_ACCESS_PHY0;
@@ -647,18 +647,18 @@ phy_RF6052_Config_ParaFile(
 	pszRadioAFile = sz92DRadioAFile;
 	pszRadioBFile = sz92DRadioBFile;
 
-	if(pHalData->InternalPA5G[0])
+	if (pHalData->InternalPA5G[0])
 		pszRadioAFile = sz92DRadioAintPAFile;
-	if(pHalData->InternalPA5G[1])
+	if (pHalData->InternalPA5G[1])
 		pszRadioBFile = sz92DRadioBintPAFile;
 
 	//DMDP,MAC0 on G band,MAC1 on A band.
-	if(pHalData->MacPhyMode92D==DUALMAC_DUALPHY)
+	if (pHalData->MacPhyMode92D==DUALMAC_DUALPHY)
 	{
-		if(pHalData->CurrentBandType92D == BAND_ON_2_4G && pHalData->interfaceIndex == 0)
+		if (pHalData->CurrentBandType92D == BAND_ON_2_4G && pHalData->interfaceIndex == 0)
 		{
 			//MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write.
-			if(rtl8192d_PHY_EnableAnotherPHY(Adapter, true))
+			if (rtl8192d_PHY_EnableAnotherPHY(Adapter, true))
 			{
 				pHalData->NumTotalRFPath = 2;
 				bMac0NeedInitRadioBFirst = true;
@@ -669,10 +669,10 @@ phy_RF6052_Config_ParaFile(
 				return rtStatus;
 			}
 		}
-		else if(pHalData->CurrentBandType92D == BAND_ON_5G && pHalData->interfaceIndex == 1)
+		else if (pHalData->CurrentBandType92D == BAND_ON_5G && pHalData->interfaceIndex == 1)
 		{
 			//MAC1 Need PHY0 load radio_a.txt . Driver use DBI to write.
-			if(rtl8192d_PHY_EnableAnotherPHY(Adapter, false))
+			if (rtl8192d_PHY_EnableAnotherPHY(Adapter, false))
 			{
 				pHalData->NumTotalRFPath = 2;
 				bMac1NeedInitRadioAFirst = true;
@@ -683,7 +683,7 @@ phy_RF6052_Config_ParaFile(
 				return rtStatus;
 			}
 		}
-		else if(pHalData->interfaceIndex == 1)
+		else if (pHalData->interfaceIndex == 1)
 		{
 			// MAC0 enabled, only init radia B.
 			pszRadioAFile = pszRadioBFile;
@@ -771,7 +771,7 @@ phy_RF6052_Config_ParaFile(
 			case RF_PATH_A:
 #ifdef CONFIG_EMBEDDED_FWIMG
 				//vivi added this for read parameter from header, 20100908
-				if(bTrueBPath == true)
+				if (bTrueBPath == true)
 					rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(Adapter,radiob_txt|MaskforPhySet, (enum RF_RADIO_PATH_E)eRFPath);
 				else
 					rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(Adapter,radioa_txt|MaskforPhySet, (enum RF_RADIO_PATH_E)eRFPath);
@@ -805,7 +805,7 @@ phy_RF6052_Config_ParaFile(
 				break;
 		}
 
-		if(rtStatus != _SUCCESS){
+		if (rtStatus != _SUCCESS){
 			//RT_TRACE(COMP_FPGA, DBG_LOUD, ("phy_RF6052_Config_ParaFile():Radio[%d] Fail!!", eRFPath));
 			goto phy_RF6052_Config_ParaFile_Fail;
 		}
@@ -849,13 +849,13 @@ PHY_RF6052_Config8192D(
 	// Initialize general global value
 	//
 	// TODO: Extend RF_PATH_C and RF_PATH_D in the future
-	if(pHalData->rf_type == RF_1T1R)
+	if (pHalData->rf_type == RF_1T1R)
 		pHalData->NumTotalRFPath = 1;
 	else
 		pHalData->NumTotalRFPath = 2;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(pHalData->bSlaveOfDMSP)
+	if (pHalData->bSlaveOfDMSP)
 	{
 		DBG_871X(("PHY_RF6052_Config() skip configuration RF \n"));
 		return rtStatus;
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
@@ -35,15 +35,15 @@ static u8 evm_db2percentage(s8 value)
 
 	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("EVMdbToPercentage92S Value=%d / %x \n", ret_val, ret_val));
 
-	if(ret_val >= 0)
+	if (ret_val >= 0)
 		ret_val = 0;
-	if(ret_val <= -33)
+	if (ret_val <= -33)
 		ret_val = -33;
 
 	ret_val = 0 - ret_val;
 	ret_val*=3;
 
-	if(ret_val == 99)
+	if (ret_val == 99)
 		ret_val = 100;
 
 	return(ret_val);
@@ -54,19 +54,19 @@ static s32 signal_scale_mapping(struct r
 {
 	s32 ret_sig;
 
-	if(cur_sig >= 51 && cur_sig <= 100)
+	if (cur_sig >= 51 && cur_sig <= 100)
 		ret_sig = 100;
-	else if(cur_sig >= 41 && cur_sig <= 50)
+	else if (cur_sig >= 41 && cur_sig <= 50)
 		ret_sig = 80 + ((cur_sig - 40)*2);
-	else if(cur_sig >= 31 && cur_sig <= 40)
+	else if (cur_sig >= 31 && cur_sig <= 40)
 		ret_sig = 66 + (cur_sig - 30);
-	else if(cur_sig >= 21 && cur_sig <= 30)
+	else if (cur_sig >= 21 && cur_sig <= 30)
 		ret_sig = 54 + (cur_sig - 20);
-	else if(cur_sig >= 10 && cur_sig <= 20)
+	else if (cur_sig >= 10 && cur_sig <= 20)
 		ret_sig = 42 + (((cur_sig - 10) * 2) / 3);
-	else if(cur_sig >= 5 && cur_sig <= 9)
+	else if (cur_sig >= 5 && cur_sig <= 9)
 		ret_sig = 22 + (((cur_sig - 5) * 3) / 2);
-	else if(cur_sig >= 1 && cur_sig <= 4)
+	else if (cur_sig >= 1 && cur_sig <= 4)
 		ret_sig = 6 + (((cur_sig - 1) * 3) / 2);
 	else
 		ret_sig = cur_sig;
@@ -109,7 +109,7 @@ static void query_rx_phy_status(union re
 	pattrib->rx_mimo_signal_qual[0]= -1;
 	pattrib->rx_mimo_signal_qual[1]= -1;
 
-	if(bcck_rate) //CCK
+	if (bcck_rate) //CCK
 	{
 		u8 report;
 
@@ -122,12 +122,12 @@ static void query_rx_phy_status(union re
 		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
 		//
 
-		if(padapter->pwrctrlpriv.rf_pwrstate == rf_on)
+		if (padapter->pwrctrlpriv.rf_pwrstate == rf_on)
 			cck_highpwr = (u8)pHalData->bCckHighPower;
 		else
 			cck_highpwr = false;
 
-		if(!cck_highpwr)
+		if (!cck_highpwr)
 		{
 			report = pCck_buf->cck_agc_rpt&0xc0;
 			report = report>>6;
@@ -172,21 +172,21 @@ static void query_rx_phy_status(union re
 		}
 
 		pwdb_all= query_rx_pwr_percentage(rx_pwr_all);
-		//if(pHalData->CustomerID == RT_CID_819x_Lenovo)
+		//if (pHalData->CustomerID == RT_CID_819x_Lenovo)
 		{
 			// CCK gain is smaller than OFDM/MCS gain,
 			// so we add gain diff by experiences, the val is 6
 			pwdb_all+=6;
-			if(pwdb_all > 100)
+			if (pwdb_all > 100)
 				pwdb_all = 100;
 			// modify the offset to make the same gain index with OFDM.
-			if(pwdb_all > 34 && pwdb_all <= 42)
+			if (pwdb_all > 34 && pwdb_all <= 42)
 				pwdb_all -= 2;
-			else if(pwdb_all > 26 && pwdb_all <= 34)
+			else if (pwdb_all > 26 && pwdb_all <= 34)
 				pwdb_all -= 6;
-			else if(pwdb_all > 14 && pwdb_all <= 26)
+			else if (pwdb_all > 14 && pwdb_all <= 26)
 				pwdb_all -= 8;
-			else if(pwdb_all > 4 && pwdb_all <= 14)
+			else if (pwdb_all > 4 && pwdb_all <= 14)
 				pwdb_all -= 4;
 		}
 
@@ -197,29 +197,29 @@ static void query_rx_phy_status(union re
 		//
 		// (3) Get Signal Quality (EVM)
 		//
-		if(bPacketMatchBSSID)
+		if (bPacketMatchBSSID)
 		{
 			u8	sq;
 
-			if(pHalData->CustomerID == RT_CID_819x_Lenovo)
+			if (pHalData->CustomerID == RT_CID_819x_Lenovo)
 			{
 				// mapping to 5 bars for vista signal strength
 				// signal quality in driver will be displayed to signal strength
 				// in vista.
-				if(pwdb_all >= 50)
+				if (pwdb_all >= 50)
 					sq = 100;
-				else if(pwdb_all >= 35 && pwdb_all < 50)
+				else if (pwdb_all >= 35 && pwdb_all < 50)
 					sq = 80;
-				else if(pwdb_all >= 22 && pwdb_all < 35)
+				else if (pwdb_all >= 22 && pwdb_all < 35)
 					sq = 60;
-				else if(pwdb_all >= 18 && pwdb_all < 22)
+				else if (pwdb_all >= 18 && pwdb_all < 22)
 					sq = 40;
 				else
 					sq = 20;
 			}
 			else
 			{
-				if(pwdb_all> 40)
+				if (pwdb_all> 40)
 				{
 					sq = 100;
 				}
@@ -227,7 +227,7 @@ static void query_rx_phy_status(union re
 				{
 					sq = pCck_buf->SQ_rpt;
 
-					if(pCck_buf->SQ_rpt > 64)
+					if (pCck_buf->SQ_rpt > 64)
 						sq = 0;
 					else if (pCck_buf->SQ_rpt < 20)
 						sq= 100;
@@ -258,9 +258,9 @@ static void query_rx_phy_status(union re
 				//continue;
 
 			rx_pwr[i] = ((pOfdm_buf->trsw_gain_X[+i]&0x3F)*2) - 110;
-			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
 			{
-				if(bPacketMatchBSSID)
+				if (bPacketMatchBSSID)
 					padapter->recvpriv.RxRssi[i] = rx_pwr[i];
 			}
 			else
@@ -278,27 +278,27 @@ static void query_rx_phy_status(union re
 			padapter->recvpriv.RxSNRdB[i] =  (int)rx_snrX;
 
 			/* Record Signal Strength for next packet */
-			if(bPacketMatchBSSID)
+			if (bPacketMatchBSSID)
 			{
 				//pRfd->Status.RxMIMOSignalStrength[i] =(u8) rssi;
 
 				//The following is for lenovo signal strength in vista
-				if(pHalData->CustomerID == RT_CID_819x_Lenovo)
+				if (pHalData->CustomerID == RT_CID_819x_Lenovo)
 				{
 					u8	SQ;
 
-					if(i == 0)
+					if (i == 0)
 					{
 						// mapping to 5 bars for vista signal strength
 						// signal quality in driver will be displayed to signal strength
 						// in vista.
-						if(rssi >= 50)
+						if (rssi >= 50)
 							SQ = 100;
-						else if(rssi >= 35 && rssi < 50)
+						else if (rssi >= 35 && rssi < 50)
 							SQ = 80;
-						else if(rssi >= 22 && rssi < 35)
+						else if (rssi >= 22 && rssi < 35)
 							SQ = 60;
-						else if(rssi >= 18 && rssi < 22)
+						else if (rssi >= 18 && rssi < 22)
 							SQ = 40;
 						else
 							SQ = 20;
@@ -326,9 +326,9 @@ static void query_rx_phy_status(union re
 		//
 		// (3)EVM of HT rate
 		//
-		if(pHalData->CustomerID != RT_CID_819x_Lenovo)
+		if (pHalData->CustomerID != RT_CID_819x_Lenovo)
 		{
-			if(pattrib->rxht &&  pattrib->mcs_rate >=20 && pattrib->mcs_rate<=27)
+			if (pattrib->rxht &&  pattrib->mcs_rate >=20 && pattrib->mcs_rate<=27)
 				max_spatial_stream = 2; //both spatial stream make sense
 			else
 				max_spatial_stream = 1; //only spatial stream 1 makes sense
@@ -343,9 +343,9 @@ static void query_rx_phy_status(union re
 				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("RXRATE=%x RXEVM=%x EVM=%s%d\n",
 					pattrib->mcs_rate, pOfdm_buf->rxevm_X[i], "%",evm));
 
-				if(bPacketMatchBSSID)
+				if (bPacketMatchBSSID)
 				{
-					if(i==0) // Fill value in RFD, Get the first spatial stream only
+					if (i==0) // Fill value in RFD, Get the first spatial stream only
 					{
 						pattrib->signal_qual = (u8)(evm & 0xff);
 					}
@@ -364,7 +364,7 @@ static void query_rx_phy_status(union re
 
 	//UI BSS List signal strength(in percentage), make it good looking, from 0~100.
 	//It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp().
-	if(bcck_rate)
+	if (bcck_rate)
 	{
 		pattrib->signal_strength=(u8)signal_scale_mapping(padapter, pwdb_all);
 	}
@@ -387,10 +387,10 @@ static void process_rssi(struct rtw_adap
 	struct signal_stat * signal_stat = &padapter->recvpriv.signal_strength_data;
 #endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
 
-	//if(pRfd->Status.bPacketToSelf || pRfd->Status.bPacketBeacon)
+	//if (pRfd->Status.bPacketToSelf || pRfd->Status.bPacketBeacon)
 	{
 	#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
-		if(signal_stat->update_req) {
+		if (signal_stat->update_req) {
 			signal_stat->total_num = 0;
 			signal_stat->total_val = 0;
 			signal_stat->update_req = 0;
@@ -402,7 +402,7 @@ static void process_rssi(struct rtw_adap
 	#else //CONFIG_NEW_SIGNAL_STAT_PROCESS
 
 		//Adapter->RxStats.RssiCalculateCnt++;	//For antenna Test
-		if(padapter->recvpriv.signal_strength_data.total_num++ >= PHY_RSSI_SLID_WIN_MAX)
+		if (padapter->recvpriv.signal_strength_data.total_num++ >= PHY_RSSI_SLID_WIN_MAX)
 		{
 			padapter->recvpriv.signal_strength_data.total_num = PHY_RSSI_SLID_WIN_MAX;
 			last_rssi = padapter->recvpriv.signal_strength_data.elements[padapter->recvpriv.signal_strength_data.index];
@@ -411,7 +411,7 @@ static void process_rssi(struct rtw_adap
 		padapter->recvpriv.signal_strength_data.total_val  +=pattrib->signal_strength;
 
 		padapter->recvpriv.signal_strength_data.elements[padapter->recvpriv.signal_strength_data.index++] = pattrib->signal_strength;
-		if(padapter->recvpriv.signal_strength_data.index >= PHY_RSSI_SLID_WIN_MAX)
+		if (padapter->recvpriv.signal_strength_data.index >= PHY_RSSI_SLID_WIN_MAX)
 			padapter->recvpriv.signal_strength_data.index = 0;
 
 
@@ -434,7 +434,7 @@ static void process_PWDB(struct rtw_adap
 	struct rx_pkt_attrib	*pattrib= &prframe->u.hdr.attrib;
 	struct sta_info		*psta = prframe->u.hdr.psta;
 
-	if(psta)
+	if (psta)
 	{
 		UndecoratedSmoothedPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
 	}
@@ -443,14 +443,14 @@ static void process_PWDB(struct rtw_adap
 		UndecoratedSmoothedPWDB = pdmpriv->UndecoratedSmoothedPWDB;
 	}
 
-	//if(pRfd->Status.bPacketToSelf || pRfd->Status.bPacketBeacon)
+	//if (pRfd->Status.bPacketToSelf || pRfd->Status.bPacketBeacon)
 	{
-		if(UndecoratedSmoothedPWDB == 0) // initialize
+		if (UndecoratedSmoothedPWDB == 0) // initialize
 		{
 			UndecoratedSmoothedPWDB = pattrib->RxPWDBAll;
 		}
 
-		if(pattrib->RxPWDBAll > (u32)UndecoratedSmoothedPWDB)
+		if (pattrib->RxPWDBAll > (u32)UndecoratedSmoothedPWDB)
 		{
 			UndecoratedSmoothedPWDB =
 					( ((UndecoratedSmoothedPWDB)*(Rx_Smooth_Factor-1)) +
@@ -465,7 +465,7 @@ static void process_PWDB(struct rtw_adap
 					(pattrib->RxPWDBAll)) /(Rx_Smooth_Factor);
 		}
 
-		if(psta)
+		if (psta)
 		{
 			psta->rssi_stat.UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
 			pdmpriv->UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
@@ -488,7 +488,7 @@ static void process_link_qual(struct rtw
 	struct signal_stat * signal_stat;
 #endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
 
-	if(prframe == NULL || padapter==NULL){
+	if (prframe == NULL || padapter==NULL){
 		return;
 	}
 
@@ -498,7 +498,7 @@ static void process_link_qual(struct rtw
 #endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
-	if(signal_stat->update_req) {
+	if (signal_stat->update_req) {
 		signal_stat->total_num = 0;
 		signal_stat->total_val = 0;
 		signal_stat->update_req = 0;
@@ -509,12 +509,12 @@ static void process_link_qual(struct rtw
 	signal_stat->avg_val = signal_stat->total_val / signal_stat->total_num;
 
 #else //CONFIG_NEW_SIGNAL_STAT_PROCESS
-	if(pattrib->signal_qual != 0)
+	if (pattrib->signal_qual != 0)
 	{
 			//
 			// 1. Record the general EVM to the sliding window.
 			//
-			if(padapter->recvpriv.signal_qual_data.total_num++ >= PHY_LINKQUALITY_SLID_WIN_MAX)
+			if (padapter->recvpriv.signal_qual_data.total_num++ >= PHY_LINKQUALITY_SLID_WIN_MAX)
 			{
 				padapter->recvpriv.signal_qual_data.total_num = PHY_LINKQUALITY_SLID_WIN_MAX;
 				last_evm = padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index];
@@ -523,7 +523,7 @@ static void process_link_qual(struct rtw
 			padapter->recvpriv.signal_qual_data.total_val += pattrib->signal_qual;
 
 			padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index++] = pattrib->signal_qual;
-			if(padapter->recvpriv.signal_qual_data.index >= PHY_LINKQUALITY_SLID_WIN_MAX)
+			if (padapter->recvpriv.signal_qual_data.index >= PHY_LINKQUALITY_SLID_WIN_MAX)
 				padapter->recvpriv.signal_qual_data.index = 0;
 
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("Total SQ=%d  pattrib->signal_qual= %d\n", padapter->recvpriv.signal_qual_data.total_val, pattrib->signal_qual));
@@ -567,7 +567,7 @@ void rtl8192d_translate_rx_signal_stuff(
 	u8	bPacketToSelf = false;
 	u8	bPacketBeacon = false;
 
-	if((pattrib->physt) && (pphy_info != NULL))
+	if ((pattrib->physt) && (pphy_info != NULL))
 	{
 		bPacketMatchBSSID = ((!IsFrameTypeCtrl(precvframe->u.hdr.rx_data)) && !(pattrib->icv_err) && !(pattrib->crc_err) &&
 			_rtw_memcmp(get_hdr_bssid(precvframe->u.hdr.rx_data), get_my_bssid(&padapter->mlmeextpriv.mlmext_info.network), ETH_ALEN));
@@ -580,7 +580,7 @@ void rtl8192d_translate_rx_signal_stuff(
 		query_rx_phy_status(precvframe, pphy_info, bPacketMatchBSSID);
 
 		precvframe->u.hdr.psta = NULL;
-		if(bPacketMatchBSSID && check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == true)
+		if (bPacketMatchBSSID && check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == true)
 		{
 			u8 *sa;
 			struct sta_info *psta=NULL;
@@ -589,15 +589,15 @@ void rtl8192d_translate_rx_signal_stuff(
 			sa = get_sa(precvframe->u.hdr.rx_data);
 
 			psta = rtw_get_stainfo(pstapriv, sa);
-			if(psta)
+			if (psta)
 			{
 				precvframe->u.hdr.psta = psta;
 				process_phy_info(padapter, precvframe);
 			}
 		}
-		else if(bPacketToSelf || bPacketBeacon)
+		else if (bPacketToSelf || bPacketBeacon)
 		{
-			if(check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
+			if (check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
 			{
 				u8 *sa;
 				struct sta_info *psta=NULL;
@@ -606,7 +606,7 @@ void rtl8192d_translate_rx_signal_stuff(
 				sa = get_sa(precvframe->u.hdr.rx_data);
 
 				psta = rtw_get_stainfo(pstapriv, sa);
-				if(psta)
+				if (psta)
 				{
 					precvframe->u.hdr.psta = psta;
 				}
--- a/drivers/staging/rtl8192du/hal/rtl8192du_led.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_led.c
@@ -146,7 +146,7 @@ SwLedOn(
 {
 	u8	LedCfg;
 
-	if( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
+	if ( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
 	{
 		return;
 	}
@@ -198,7 +198,7 @@ SwLedOff(
 {
 	u8	LedCfg;
 
-	if((padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
+	if ((padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
 	{
              return;
 	}
@@ -253,7 +253,7 @@ SwLedBlink(
 	u8				bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
+	if ( pLed->BlinkingLedState == RTW_LED_ON )
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
@@ -270,30 +270,30 @@ SwLedBlink(
 	{
 
 	case LED_BLINK_NORMAL:
-		if(pLed->BlinkTimes == 0)
+		if (pLed->BlinkTimes == 0)
 		{
 			bStopBlinking = true;
 		}
 		break;
 
 	case LED_BLINK_StartToBlink:
-		if( check_fwstate(pmlmepriv, _FW_LINKED) && check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
+		if ( check_fwstate(pmlmepriv, _FW_LINKED) && check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
 		{
 			bStopBlinking = true;
 		}
-		if( check_fwstate(pmlmepriv, _FW_LINKED) &&
+		if ( check_fwstate(pmlmepriv, _FW_LINKED) &&
 			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) )
 		{
 			bStopBlinking = true;
 		}
-		else if(pLed->BlinkTimes == 0)
+		else if (pLed->BlinkTimes == 0)
 		{
 			bStopBlinking = true;
 		}
 		break;
 
 	case LED_BLINK_WPS:
-		if( pLed->BlinkTimes == 0 )
+		if ( pLed->BlinkTimes == 0 )
 		{
 			bStopBlinking = true;
 		}
@@ -306,17 +306,17 @@ SwLedBlink(
 
 	}
 
-	if(bStopBlinking)
+	if (bStopBlinking)
 	{
-		if( padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+		if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 		{
 			SwLedOff(padapter, pLed);
 		}
-		else if( (check_fwstate(pmlmepriv, _FW_LINKED)== true) && (pLed->bLedOn == false))
+		else if ( (check_fwstate(pmlmepriv, _FW_LINKED)== true) && (pLed->bLedOn == false))
 		{
 			SwLedOn(padapter, pLed);
 		}
-		else if( (check_fwstate(pmlmepriv, _FW_LINKED)== true) &&  pLed->bLedOn == true)
+		else if ( (check_fwstate(pmlmepriv, _FW_LINKED)== true) &&  pLed->bLedOn == true)
 		{
 			SwLedOff(padapter, pLed);
 		}
@@ -327,7 +327,7 @@ SwLedBlink(
 	else
 	{
 		// Assign LED state to toggle.
-		if( pLed->BlinkingLedState == RTW_LED_ON )
+		if ( pLed->BlinkingLedState == RTW_LED_ON )
 			pLed->BlinkingLedState = RTW_LED_OFF;
 		else
 			pLed->BlinkingLedState = RTW_LED_ON;
@@ -346,7 +346,7 @@ SwLedBlink(
 
 		case LED_BLINK_WPS:
 			{
-				if( pLed->BlinkingLedState == RTW_LED_ON )
+				if ( pLed->BlinkingLedState == RTW_LED_ON )
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
 				else
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
@@ -375,11 +375,11 @@ SwLedBlink1(
 	struct LED_871X *			pLed1 = &(ledpriv->SwLed1);
 	u8					bStopBlinking = false;
 
-	if(pHalData->CustomerID == RT_CID_819x_CAMEO)
+	if (pHalData->CustomerID == RT_CID_819x_CAMEO)
 		pLed = &(ledpriv->SwLed1);
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
+	if ( pLed->BlinkingLedState == RTW_LED_ON )
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,( "Blinktimes (%d): turn on\n", pLed->BlinkTimes));
@@ -391,27 +391,27 @@ SwLedBlink1(
 	}
 
 
-	if(pHalData->CustomerID == RT_CID_DEFAULT)
+	if (pHalData->CustomerID == RT_CID_DEFAULT)
 	{
-		if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
+		if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 		{
-			if(!pLed1->bSWLedCtrl)
+			if (!pLed1->bSWLedCtrl)
 			{
 				SwLedOn(padapter, pLed1);
 				pLed1->bSWLedCtrl = true;
 			}
-			else if(!pLed1->bLedOn)
+			else if (!pLed1->bLedOn)
 				SwLedOn(padapter, pLed1);
 			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn on pLed1\n"));
 		}
 		else
 		{
-			if(!pLed1->bSWLedCtrl)
+			if (!pLed1->bSWLedCtrl)
 			{
 				SwLedOff(padapter, pLed1);
 				pLed1->bSWLedCtrl = true;
 			}
-			else if(pLed1->bLedOn)
+			else if (pLed1->bLedOn)
 				SwLedOff(padapter, pLed1);
 			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn off pLed1\n"));
 		}
@@ -420,7 +420,7 @@ SwLedBlink1(
 	switch(pLed->CurrLedState)
 	{
 		case LED_BLINK_SLOWLY:
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -428,7 +428,7 @@ SwLedBlink1(
 			break;
 
 		case LED_BLINK_NORMAL:
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -437,22 +437,22 @@ SwLedBlink1(
 
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
+			if ( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = true;
 			}
 
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
 					pLed->bLedLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_NORMAL;
-					if( pLed->bLedOn )
+					if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -460,11 +460,11 @@ SwLedBlink1(
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
 					pLed->bLedNoLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if( pLed->bLedOn )
+					if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -475,13 +475,13 @@ SwLedBlink1(
 			}
 			else
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if( pLed->bLedOn )
+					 if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -492,32 +492,32 @@ SwLedBlink1(
 
 		case LED_TXRX_BLINK:
 			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
+			if ( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = true;
 			}
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
 					pLed->bLedLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_NORMAL;
-					if( pLed->bLedOn )
+					if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
 					pLed->bLedNoLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if( pLed->bLedOn )
+					if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -529,13 +529,13 @@ SwLedBlink1(
 			}
 			else
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if( pLed->bLedOn )
+					 if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -545,7 +545,7 @@ SwLedBlink1(
 			break;
 
 		case LED_BLINK_WPS:
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -553,7 +553,7 @@ SwLedBlink1(
 			break;
 
 		case LED_BLINK_WPS_STOP:	//WPS success
-			if(pLed->BlinkingLedState == RTW_LED_ON)
+			if (pLed->BlinkingLedState == RTW_LED_ON)
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
@@ -564,9 +564,9 @@ SwLedBlink1(
 				bStopBlinking = true;
 			}
 
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -574,7 +574,7 @@ SwLedBlink1(
 				{
 					pLed->bLedLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_NORMAL;
-					if( pLed->bLedOn )
+					if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -604,7 +604,7 @@ SwLedBlink2(
 	u8					bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON)
+	if ( pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
@@ -619,18 +619,18 @@ SwLedBlink2(
 	{
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
+			if ( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = true;
 			}
 
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
 					pLed->CurrLedState = RTW_LED_ON;
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -638,7 +638,7 @@ SwLedBlink2(
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
 
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
@@ -649,13 +649,13 @@ SwLedBlink2(
 			}
 			else
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if( pLed->bLedOn )
+					 if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -666,17 +666,17 @@ SwLedBlink2(
 
 		case LED_TXRX_BLINK:
 			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
+			if ( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = true;
 			}
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
 					pLed->CurrLedState = RTW_LED_ON;
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -684,7 +684,7 @@ SwLedBlink2(
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
 
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
@@ -695,13 +695,13 @@ SwLedBlink2(
 			}
 			else
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if( pLed->bLedOn )
+					 if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -729,14 +729,14 @@ SwLedBlink3(
 	u8				bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
+	if ( pLed->BlinkingLedState == RTW_LED_ON )
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
 	}
 	else
 	{
-		if(pLed->CurrLedState != LED_BLINK_WPS_STOP)
+		if (pLed->CurrLedState != LED_BLINK_WPS_STOP)
 			SwLedOff(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
 	}
@@ -745,31 +745,31 @@ SwLedBlink3(
 	{
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
+			if ( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = true;
 			}
 
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
 					pLed->CurrLedState = RTW_LED_ON;
 					pLed->BlinkingLedState = RTW_LED_ON;
-					if( !pLed->bLedOn )
+					if ( !pLed->bLedOn )
 						SwLedOn(padapter, pLed);
 
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
-					if( pLed->bLedOn )
+					if ( pLed->bLedOn )
 						SwLedOff(padapter, pLed);
 
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
@@ -778,13 +778,13 @@ SwLedBlink3(
 			}
 			else
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					if( pLed->bLedOn )
+					if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -795,32 +795,32 @@ SwLedBlink3(
 
 		case LED_TXRX_BLINK:
 			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
+			if ( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = true;
 			}
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
 					pLed->CurrLedState = RTW_LED_ON;
 					pLed->BlinkingLedState = RTW_LED_ON;
 
-					if( !pLed->bLedOn )
+					if ( !pLed->bLedOn )
 						SwLedOn(padapter, pLed);
 
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
 
-					if( pLed->bLedOn )
+					if ( pLed->bLedOn )
 						SwLedOff(padapter, pLed);
 
 
@@ -830,13 +830,13 @@ SwLedBlink3(
 			}
 			else
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					if( pLed->bLedOn )
+					if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -846,7 +846,7 @@ SwLedBlink3(
 			break;
 
 		case LED_BLINK_WPS:
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -854,7 +854,7 @@ SwLedBlink3(
 			break;
 
 		case LED_BLINK_WPS_STOP:	//WPS success
-			if(pLed->BlinkingLedState == RTW_LED_ON)
+			if (pLed->BlinkingLedState == RTW_LED_ON)
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
@@ -865,9 +865,9 @@ SwLedBlink3(
 				bStopBlinking = true;
 			}
 
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -903,7 +903,7 @@ SwLedBlink4(
 	u8				bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
+	if ( pLed->BlinkingLedState == RTW_LED_ON )
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
@@ -914,7 +914,7 @@ SwLedBlink4(
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
 	}
 
-	if(!pLed1->bLedWPSBlinkInProgress && pLed1->BlinkingLedState == LED_UNKNOWN)
+	if (!pLed1->bLedWPSBlinkInProgress && pLed1->BlinkingLedState == LED_UNKNOWN)
 	{
 		pLed1->BlinkingLedState = RTW_LED_OFF;
 		pLed1->CurrLedState = RTW_LED_OFF;
@@ -924,7 +924,7 @@ SwLedBlink4(
 	switch(pLed->CurrLedState)
 	{
 		case LED_BLINK_SLOWLY:
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -932,7 +932,7 @@ SwLedBlink4(
 			break;
 
 		case LED_BLINK_StartToBlink:
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
@@ -946,14 +946,14 @@ SwLedBlink4(
 
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
+			if ( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = false;
 			}
 
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -961,7 +961,7 @@ SwLedBlink4(
 				{
 					pLed->bLedNoLinkBlinkInProgress = false;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if( pLed->bLedOn )
+					if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -971,13 +971,13 @@ SwLedBlink4(
 			}
 			else
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if( pLed->bLedOn )
+					 if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -988,13 +988,13 @@ SwLedBlink4(
 
 		case LED_TXRX_BLINK:
 			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
+			if ( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = true;
 			}
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -1002,7 +1002,7 @@ SwLedBlink4(
 				{
 					pLed->bLedNoLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if( pLed->bLedOn )
+					if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -1012,13 +1012,13 @@ SwLedBlink4(
 			}
 			else
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if( pLed->bLedOn )
+					 if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -1028,7 +1028,7 @@ SwLedBlink4(
 			break;
 
 		case LED_BLINK_WPS:
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
@@ -1041,7 +1041,7 @@ SwLedBlink4(
 			break;
 
 		case LED_BLINK_WPS_STOP:	//WPS authentication fail
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -1051,9 +1051,9 @@ SwLedBlink4(
 
 		case LED_BLINK_WPS_STOP_OVERLAP:	//WPS session overlap
 			pLed->BlinkTimes--;
-			if(pLed->BlinkTimes == 0)
+			if (pLed->BlinkTimes == 0)
 			{
-				if(pLed->bLedOn)
+				if (pLed->bLedOn)
 				{
 					pLed->BlinkTimes = 1;
 				}
@@ -1063,7 +1063,7 @@ SwLedBlink4(
 				}
 			}
 
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
 				pLed->BlinkTimes = 10;
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -1071,7 +1071,7 @@ SwLedBlink4(
 			}
 			else
 			{
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1102,7 +1102,7 @@ SwLedBlink5(
 	u8				bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
+	if ( pLed->BlinkingLedState == RTW_LED_ON )
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
@@ -1117,24 +1117,24 @@ SwLedBlink5(
 	{
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
+			if ( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = true;
 			}
 
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
-					if(pLed->bLedOn)
+					if (pLed->bLedOn)
 						SwLedOff(padapter, pLed);
 				}
 				else
 				{		pLed->CurrLedState = RTW_LED_ON;
 						pLed->BlinkingLedState = RTW_LED_ON;
-						if(!pLed->bLedOn)
+						if (!pLed->bLedOn)
 							_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 
@@ -1142,13 +1142,13 @@ SwLedBlink5(
 			}
 			else
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					if( pLed->bLedOn )
+					if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -1160,25 +1160,25 @@ SwLedBlink5(
 
 		case LED_TXRX_BLINK:
 			pLed->BlinkTimes--;
-			if( pLed->BlinkTimes == 0 )
+			if ( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = true;
 			}
 
-			if(bStopBlinking)
+			if (bStopBlinking)
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
-					if(pLed->bLedOn)
+					if (pLed->bLedOn)
 						SwLedOff(padapter, pLed);
 				}
 				else
 				{
 					pLed->CurrLedState = RTW_LED_ON;
 					pLed->BlinkingLedState = RTW_LED_ON;
-					if(!pLed->bLedOn)
+					if (!pLed->bLedOn)
 						_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 
@@ -1186,13 +1186,13 @@ SwLedBlink5(
 			}
 			else
 			{
-				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if( pLed->bLedOn )
+					 if ( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -1223,7 +1223,7 @@ BlinkTimerCallback(
 	struct LED_871X *	 pLed = (struct LED_871X *)data;
 	struct rtw_adapter		*padapter = pLed->padapter;
 
-	 if( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
+	 if ( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
        {
              return;
        }
@@ -1243,7 +1243,7 @@ void BlinkWorkItemCallback(struct work_s
 	struct led_priv	*ledpriv = &(pLed->padapter->ledpriv);
 	struct rtw_adapter		*padapter = pLed->padapter;
 
-	 if( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
+	 if ( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
        {
              return;
        }
@@ -1309,14 +1309,14 @@ SwLedControlMode0(
 	{
 	case LED_CTL_TX:
 	case LED_CTL_RX:
-		if( pLed->bLedBlinkInProgress == false )
+		if ( pLed->bLedBlinkInProgress == false )
 		{
 			pLed->bLedBlinkInProgress = true;
 
 			pLed->CurrLedState = LED_BLINK_NORMAL;
 			pLed->BlinkTimes = 2;
 
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -1325,14 +1325,14 @@ SwLedControlMode0(
 		break;
 
 	case LED_CTL_START_TO_LINK:
-		if( pLed->bLedBlinkInProgress == false )
+		if ( pLed->bLedBlinkInProgress == false )
 		{
 			pLed->bLedBlinkInProgress = true;
 
 			pLed->CurrLedState = LED_BLINK_StartToBlink;
 			pLed->BlinkTimes = 24;
 
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -1346,7 +1346,7 @@ SwLedControlMode0(
 
 	case LED_CTL_LINK:
 		pLed->CurrLedState = RTW_LED_ON;
-		if( pLed->bLedBlinkInProgress == false )
+		if ( pLed->bLedBlinkInProgress == false )
 		{
 			SwLedOn(padapter, pLed);
 		}
@@ -1354,7 +1354,7 @@ SwLedControlMode0(
 
 	case LED_CTL_NO_LINK:
 		pLed->CurrLedState = RTW_LED_OFF;
-		if( pLed->bLedBlinkInProgress == false )
+		if ( pLed->bLedBlinkInProgress == false )
 		{
 			SwLedOff(padapter, pLed);
 		}
@@ -1364,7 +1364,7 @@ SwLedControlMode0(
 		pLed->CurrLedState = RTW_LED_OFF;
 		pLed->BlinkingLedState = RTW_LED_OFF;
 
-		if(pLed->bLedBlinkInProgress)
+		if (pLed->bLedBlinkInProgress)
 		{
 			_cancel_timer_ex(&(pLed->BlinkTimer));
 			pLed->bLedBlinkInProgress = false;
@@ -1373,14 +1373,14 @@ SwLedControlMode0(
 		break;
 
 	case LED_CTL_START_WPS:
-		if( pLed->bLedBlinkInProgress == false || pLed->CurrLedState == RTW_LED_ON)
+		if ( pLed->bLedBlinkInProgress == false || pLed->CurrLedState == RTW_LED_ON)
 		{
 			pLed->bLedBlinkInProgress = true;
 
 			pLed->CurrLedState = LED_BLINK_WPS;
 			pLed->BlinkTimes = 20;
 
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
@@ -1394,7 +1394,7 @@ SwLedControlMode0(
 		break;
 
 	case LED_CTL_STOP_WPS:
-		if(pLed->bLedBlinkInProgress)
+		if (pLed->bLedBlinkInProgress)
 		{
 			pLed->CurrLedState = RTW_LED_OFF;
 			_cancel_timer_ex(&(pLed->BlinkTimer));
@@ -1428,25 +1428,25 @@ SwLedControlMode1(
 	struct LED_871X *			pLed = &(ledpriv->SwLed0);
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
 
-	if(pHalData->CustomerID == RT_CID_819x_CAMEO)
+	if (pHalData->CustomerID == RT_CID_819x_CAMEO)
 		pLed = &(ledpriv->SwLed1);
 
 	switch(LedAction)
 	{
 		case LED_CTL_START_TO_LINK:
 		case LED_CTL_NO_LINK:
-			if( pLed->bLedNoLinkBlinkInProgress == false )
+			if ( pLed->bLedNoLinkBlinkInProgress == false )
 			{
-				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if( pLed->bLedLinkBlinkInProgress == true )
+				if ( pLed->bLedLinkBlinkInProgress == true )
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedLinkBlinkInProgress = false;
 				}
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
@@ -1454,7 +1454,7 @@ SwLedControlMode1(
 
 				pLed->bLedNoLinkBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_SLOWLY;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1463,25 +1463,25 @@ SwLedControlMode1(
 			break;
 
 		case LED_CTL_LINK:
-			if( pLed->bLedLinkBlinkInProgress == false )
+			if ( pLed->bLedLinkBlinkInProgress == false )
 			{
-				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if(pLed->bLedNoLinkBlinkInProgress == true)
+				if (pLed->bLedNoLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
 				}
 				pLed->bLedLinkBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_NORMAL;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1490,24 +1490,24 @@ SwLedControlMode1(
 			break;
 
 		case LED_CTL_SITE_SURVEY:
-			 if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
+			 if ((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 				;
-			 else if(pLed->bLedScanBlinkInProgress ==false)
+			 else if (pLed->bLedScanBlinkInProgress ==false)
 			 {
-				if(IS_LED_WPS_BLINKING(pLed))
+				if (IS_LED_WPS_BLINKING(pLed))
 					return;
 
-				if(pLed->bLedNoLinkBlinkInProgress == true)
+				if (pLed->bLedNoLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				if( pLed->bLedLinkBlinkInProgress == true )
+				if ( pLed->bLedLinkBlinkInProgress == true )
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					 pLed->bLedLinkBlinkInProgress = false;
 				}
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
@@ -1515,7 +1515,7 @@ SwLedControlMode1(
 				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1525,18 +1525,18 @@ SwLedControlMode1(
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if(pLed->bLedBlinkInProgress ==false)
+			if (pLed->bLedBlinkInProgress ==false)
 			{
-                            if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+                            if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
                             {
 					return;
                             }
-                            if(pLed->bLedNoLinkBlinkInProgress == true)
+                            if (pLed->bLedNoLinkBlinkInProgress == true)
                             {
                                 _cancel_timer_ex(&(pLed->BlinkTimer));
                                 pLed->bLedNoLinkBlinkInProgress = false;
                             }
-                            if( pLed->bLedLinkBlinkInProgress == true )
+                            if ( pLed->bLedLinkBlinkInProgress == true )
                             {
                                 _cancel_timer_ex(&(pLed->BlinkTimer));
                                 pLed->bLedLinkBlinkInProgress = false;
@@ -1544,7 +1544,7 @@ SwLedControlMode1(
                             pLed->bLedBlinkInProgress = true;
                             pLed->CurrLedState = LED_TXRX_BLINK;
                             pLed->BlinkTimes = 2;
-                            if( pLed->bLedOn )
+                            if ( pLed->bLedOn )
                                 pLed->BlinkingLedState = RTW_LED_OFF;
                             else
                                 pLed->BlinkingLedState = RTW_LED_ON;
@@ -1554,31 +1554,31 @@ SwLedControlMode1(
 
 		case LED_CTL_START_WPS: //wait until xinpin finish
 		case LED_CTL_START_WPS_BOTTON:
-			 if(pLed->bLedWPSBlinkInProgress ==false)
+			 if (pLed->bLedWPSBlinkInProgress ==false)
 			 {
-				if(pLed->bLedNoLinkBlinkInProgress == true)
+				if (pLed->bLedNoLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				if( pLed->bLedLinkBlinkInProgress == true )
+				if ( pLed->bLedLinkBlinkInProgress == true )
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					 pLed->bLedLinkBlinkInProgress = false;
 				}
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
 				}
-				if(pLed->bLedScanBlinkInProgress ==true)
+				if (pLed->bLedScanBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedScanBlinkInProgress = false;
 				}
 				pLed->bLedWPSBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_WPS;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1588,27 +1588,27 @@ SwLedControlMode1(
 
 
 		case LED_CTL_STOP_WPS:
-			if(pLed->bLedNoLinkBlinkInProgress == true)
+			if (pLed->bLedNoLinkBlinkInProgress == true)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedNoLinkBlinkInProgress = false;
 			}
-			if( pLed->bLedLinkBlinkInProgress == true )
+			if ( pLed->bLedLinkBlinkInProgress == true )
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				 pLed->bLedLinkBlinkInProgress = false;
 			}
-			if(pLed->bLedBlinkInProgress ==true)
+			if (pLed->bLedBlinkInProgress ==true)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if(pLed->bLedScanBlinkInProgress ==true)
+			if (pLed->bLedScanBlinkInProgress ==true)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
 			}
-			if(pLed->bLedWPSBlinkInProgress)
+			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 			}
@@ -1618,7 +1618,7 @@ SwLedControlMode1(
 			}
 
 			pLed->CurrLedState = LED_BLINK_WPS_STOP;
-			if(pLed->bLedOn)
+			if (pLed->bLedOn)
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
@@ -1631,7 +1631,7 @@ SwLedControlMode1(
 			break;
 
 		case LED_CTL_STOP_WPS_FAIL:
-			if(pLed->bLedWPSBlinkInProgress)
+			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
@@ -1639,7 +1639,7 @@ SwLedControlMode1(
 
 			pLed->bLedNoLinkBlinkInProgress = true;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -1650,27 +1650,27 @@ SwLedControlMode1(
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
 
-			if( pLed->bLedNoLinkBlinkInProgress)
+			if ( pLed->bLedNoLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedNoLinkBlinkInProgress = false;
 			}
-			if( pLed->bLedLinkBlinkInProgress)
+			if ( pLed->bLedLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedLinkBlinkInProgress = false;
 			}
-			if( pLed->bLedBlinkInProgress)
+			if ( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if( pLed->bLedWPSBlinkInProgress )
+			if ( pLed->bLedWPSBlinkInProgress )
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
 			}
-			if( pLed->bLedScanBlinkInProgress)
+			if ( pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
@@ -1706,14 +1706,14 @@ SwLedControlMode2(
 	switch(LedAction)
 	{
 		case LED_CTL_SITE_SURVEY:
-			 if(pmlmepriv->LinkDetectInfo.bBusyTraffic)
+			 if (pmlmepriv->LinkDetectInfo.bBusyTraffic)
 				;
-			 else if(pLed->bLedScanBlinkInProgress ==false)
+			 else if (pLed->bLedScanBlinkInProgress ==false)
 			 {
-				if(IS_LED_WPS_BLINKING(pLed))
+				if (IS_LED_WPS_BLINKING(pLed))
 					return;
 
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
@@ -1721,7 +1721,7 @@ SwLedControlMode2(
 				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1731,9 +1731,9 @@ SwLedControlMode2(
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if((pLed->bLedBlinkInProgress ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
+			if ((pLed->bLedBlinkInProgress ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 			{
-				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
@@ -1741,7 +1741,7 @@ SwLedControlMode2(
 				pLed->bLedBlinkInProgress = true;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1752,12 +1752,12 @@ SwLedControlMode2(
 		case LED_CTL_LINK:
 			pLed->CurrLedState = RTW_LED_ON;
 			pLed->BlinkingLedState = RTW_LED_ON;
-			if( pLed->bLedBlinkInProgress)
+			if ( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if( pLed->bLedScanBlinkInProgress)
+			if ( pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
@@ -1768,14 +1768,14 @@ SwLedControlMode2(
 
 		case LED_CTL_START_WPS: //wait until xinpin finish
 		case LED_CTL_START_WPS_BOTTON:
-			if(pLed->bLedWPSBlinkInProgress ==false)
+			if (pLed->bLedWPSBlinkInProgress ==false)
 			{
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
 				}
-				if(pLed->bLedScanBlinkInProgress ==true)
+				if (pLed->bLedScanBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedScanBlinkInProgress = false;
@@ -1789,7 +1789,7 @@ SwLedControlMode2(
 
 		case LED_CTL_STOP_WPS:
 			pLed->bLedWPSBlinkInProgress = false;
-			if(padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+			if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 			{
 				SwLedOff(padapter, pLed);
 			}
@@ -1804,7 +1804,7 @@ SwLedControlMode2(
 
 		case LED_CTL_STOP_WPS_FAIL:
 			pLed->bLedWPSBlinkInProgress = false;
-			if(padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+			if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 			{
 				SwLedOff(padapter, pLed);
 			}
@@ -1819,7 +1819,7 @@ SwLedControlMode2(
 
 		case LED_CTL_START_TO_LINK:
 		case LED_CTL_NO_LINK:
-			if(!IS_LED_BLINKING(pLed))
+			if (!IS_LED_BLINKING(pLed))
 			{
 				pLed->CurrLedState = RTW_LED_OFF;
 				pLed->BlinkingLedState = RTW_LED_OFF;
@@ -1830,17 +1830,17 @@ SwLedControlMode2(
 		case LED_CTL_POWER_OFF:
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
-			if( pLed->bLedBlinkInProgress)
+			if ( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if( pLed->bLedScanBlinkInProgress)
+			if ( pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
 			}
-			if( pLed->bLedWPSBlinkInProgress )
+			if ( pLed->bLedWPSBlinkInProgress )
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
@@ -1876,14 +1876,14 @@ SwLedControlMode2(
 	switch(LedAction)
 	{
 		case LED_CTL_SITE_SURVEY:
-			if(pmlmepriv->LinkDetectInfo.bBusyTraffic)
+			if (pmlmepriv->LinkDetectInfo.bBusyTraffic)
 				;
-			else if(pLed->bLedScanBlinkInProgress ==false)
+			else if (pLed->bLedScanBlinkInProgress ==false)
 			{
-				if(IS_LED_WPS_BLINKING(pLed))
+				if (IS_LED_WPS_BLINKING(pLed))
 					return;
 
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
@@ -1891,7 +1891,7 @@ SwLedControlMode2(
 				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1901,9 +1901,9 @@ SwLedControlMode2(
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if((pLed->bLedBlinkInProgress ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
+			if ((pLed->bLedBlinkInProgress ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 			{
-				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
@@ -1911,7 +1911,7 @@ SwLedControlMode2(
 				pLed->bLedBlinkInProgress = true;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1920,17 +1920,17 @@ SwLedControlMode2(
 			break;
 
 		case LED_CTL_LINK:
-			if(IS_LED_WPS_BLINKING(pLed))
+			if (IS_LED_WPS_BLINKING(pLed))
 				return;
 
 			pLed->CurrLedState = RTW_LED_ON;
 			pLed->BlinkingLedState = RTW_LED_ON;
-			if( pLed->bLedBlinkInProgress)
+			if ( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if( pLed->bLedScanBlinkInProgress)
+			if ( pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
@@ -1941,21 +1941,21 @@ SwLedControlMode2(
 
 		case LED_CTL_START_WPS: //wait until xinpin finish
 		case LED_CTL_START_WPS_BOTTON:
-			if(pLed->bLedWPSBlinkInProgress ==false)
+			if (pLed->bLedWPSBlinkInProgress ==false)
 			{
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
 				}
-				if(pLed->bLedScanBlinkInProgress ==true)
+				if (pLed->bLedScanBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedScanBlinkInProgress = false;
 				}
 				pLed->bLedWPSBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_WPS;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1964,7 +1964,7 @@ SwLedControlMode2(
 			break;
 
 		case LED_CTL_STOP_WPS:
-			if(pLed->bLedWPSBlinkInProgress)
+			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
@@ -1975,7 +1975,7 @@ SwLedControlMode2(
 			}
 
 			pLed->CurrLedState = LED_BLINK_WPS_STOP;
-			if(pLed->bLedOn)
+			if (pLed->bLedOn)
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
@@ -1989,7 +1989,7 @@ SwLedControlMode2(
 			break;
 
 		case LED_CTL_STOP_WPS_FAIL:
-			if(pLed->bLedWPSBlinkInProgress)
+			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
@@ -2002,7 +2002,7 @@ SwLedControlMode2(
 
 		case LED_CTL_START_TO_LINK:
 		case LED_CTL_NO_LINK:
-			if(!IS_LED_BLINKING(pLed))
+			if (!IS_LED_BLINKING(pLed))
 			{
 				pLed->CurrLedState = RTW_LED_OFF;
 				pLed->BlinkingLedState = RTW_LED_OFF;
@@ -2013,17 +2013,17 @@ SwLedControlMode2(
 		case LED_CTL_POWER_OFF:
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
-			if( pLed->bLedBlinkInProgress)
+			if ( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if( pLed->bLedScanBlinkInProgress)
+			if ( pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
 			}
-			if( pLed->bLedWPSBlinkInProgress )
+			if ( pLed->bLedWPSBlinkInProgress )
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
@@ -2061,7 +2061,7 @@ SwLedControlMode4(
 	switch(LedAction)
 	{
 		case LED_CTL_START_TO_LINK:
-			if(pLed1->bLedWPSBlinkInProgress)
+			if (pLed1->bLedWPSBlinkInProgress)
 			{
 				pLed1->bLedWPSBlinkInProgress = false;
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
@@ -2069,22 +2069,22 @@ SwLedControlMode4(
 				pLed1->BlinkingLedState = RTW_LED_OFF;
 				pLed1->CurrLedState = RTW_LED_OFF;
 
-				if(pLed1->bLedOn)
+				if (pLed1->bLedOn)
 					_set_timer(&(pLed->BlinkTimer), 0);
 			}
 
-			if( pLed->bLedStartToLinkBlinkInProgress == false )
+			if ( pLed->bLedStartToLinkBlinkInProgress == false )
 			{
-				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
 				}
-				if(pLed->bLedNoLinkBlinkInProgress ==true)
+				if (pLed->bLedNoLinkBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedNoLinkBlinkInProgress = false;
@@ -2092,7 +2092,7 @@ SwLedControlMode4(
 
 				pLed->bLedStartToLinkBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_StartToBlink;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 				{
 					pLed->BlinkingLedState = RTW_LED_OFF;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
@@ -2108,9 +2108,9 @@ SwLedControlMode4(
 		case LED_CTL_LINK:
 		case LED_CTL_NO_LINK:
 			//LED1 settings
-			if(LedAction == LED_CTL_LINK)
+			if (LedAction == LED_CTL_LINK)
 			{
-				if(pLed1->bLedWPSBlinkInProgress)
+				if (pLed1->bLedWPSBlinkInProgress)
 				{
 					pLed1->bLedWPSBlinkInProgress = false;
 					_cancel_timer_ex(&(pLed1->BlinkTimer));
@@ -2118,18 +2118,18 @@ SwLedControlMode4(
 					pLed1->BlinkingLedState = RTW_LED_OFF;
 					pLed1->CurrLedState = RTW_LED_OFF;
 
-					if(pLed1->bLedOn)
+					if (pLed1->bLedOn)
 						_set_timer(&(pLed->BlinkTimer), 0);
 				}
 			}
 
-			if( pLed->bLedNoLinkBlinkInProgress == false )
+			if ( pLed->bLedNoLinkBlinkInProgress == false )
 			{
-				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
@@ -2137,7 +2137,7 @@ SwLedControlMode4(
 
 				pLed->bLedNoLinkBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_SLOWLY;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -2146,19 +2146,19 @@ SwLedControlMode4(
 			break;
 
 		case LED_CTL_SITE_SURVEY:
-			if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
+			if ((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 				;
-			else if(pLed->bLedScanBlinkInProgress ==false)
+			else if (pLed->bLedScanBlinkInProgress ==false)
 			{
-				if(IS_LED_WPS_BLINKING(pLed))
+				if (IS_LED_WPS_BLINKING(pLed))
 					return;
 
-				if(pLed->bLedNoLinkBlinkInProgress == true)
+				if (pLed->bLedNoLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
@@ -2166,7 +2166,7 @@ SwLedControlMode4(
 				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -2176,13 +2176,13 @@ SwLedControlMode4(
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if(pLed->bLedBlinkInProgress ==false)
+			if (pLed->bLedBlinkInProgress ==false)
 			{
-				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if(pLed->bLedNoLinkBlinkInProgress == true)
+				if (pLed->bLedNoLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedNoLinkBlinkInProgress = false;
@@ -2190,7 +2190,7 @@ SwLedControlMode4(
 				pLed->bLedBlinkInProgress = true;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -2200,7 +2200,7 @@ SwLedControlMode4(
 
 		case LED_CTL_START_WPS: //wait until xinpin finish
 		case LED_CTL_START_WPS_BOTTON:
-			if(pLed1->bLedWPSBlinkInProgress)
+			if (pLed1->bLedWPSBlinkInProgress)
 			{
 				pLed1->bLedWPSBlinkInProgress = false;
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
@@ -2208,30 +2208,30 @@ SwLedControlMode4(
 				pLed1->BlinkingLedState = RTW_LED_OFF;
 				pLed1->CurrLedState = RTW_LED_OFF;
 
-				if(pLed1->bLedOn)
+				if (pLed1->bLedOn)
 					_set_timer(&(pLed->BlinkTimer), 0);
 			}
 
-			if(pLed->bLedWPSBlinkInProgress ==false)
+			if (pLed->bLedWPSBlinkInProgress ==false)
 			{
-				if(pLed->bLedNoLinkBlinkInProgress == true)
+				if (pLed->bLedNoLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
 				}
-				if(pLed->bLedScanBlinkInProgress ==true)
+				if (pLed->bLedScanBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedScanBlinkInProgress = false;
 				}
 				pLed->bLedWPSBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_WPS;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 				{
 					pLed->BlinkingLedState = RTW_LED_OFF;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
@@ -2245,7 +2245,7 @@ SwLedControlMode4(
 			break;
 
 		case LED_CTL_STOP_WPS:	//WPS connect success
-			if(pLed->bLedWPSBlinkInProgress)
+			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
@@ -2253,7 +2253,7 @@ SwLedControlMode4(
 
 			pLed->bLedNoLinkBlinkInProgress = true;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -2262,7 +2262,7 @@ SwLedControlMode4(
 			break;
 
 		case LED_CTL_STOP_WPS_FAIL:		//WPS authentication fail
-			if(pLed->bLedWPSBlinkInProgress)
+			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
@@ -2270,20 +2270,20 @@ SwLedControlMode4(
 
 			pLed->bLedNoLinkBlinkInProgress = true;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 
 			//LED1 settings
-			if(pLed1->bLedWPSBlinkInProgress)
+			if (pLed1->bLedWPSBlinkInProgress)
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
 			else
 				pLed1->bLedWPSBlinkInProgress = true;
 
 			pLed1->CurrLedState = LED_BLINK_WPS_STOP;
-			if( pLed1->bLedOn )
+			if ( pLed1->bLedOn )
 				pLed1->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed1->BlinkingLedState = RTW_LED_ON;
@@ -2292,7 +2292,7 @@ SwLedControlMode4(
 			break;
 
 		case LED_CTL_STOP_WPS_FAIL_OVERLAP:	//WPS session overlap
-			if(pLed->bLedWPSBlinkInProgress)
+			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
@@ -2300,21 +2300,21 @@ SwLedControlMode4(
 
 			pLed->bLedNoLinkBlinkInProgress = true;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if( pLed->bLedOn )
+			if ( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 
 			//LED1 settings
-			if(pLed1->bLedWPSBlinkInProgress)
+			if (pLed1->bLedWPSBlinkInProgress)
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
 			else
 				pLed1->bLedWPSBlinkInProgress = true;
 
 			pLed1->CurrLedState = LED_BLINK_WPS_STOP_OVERLAP;
 			pLed1->BlinkTimes = 10;
-			if( pLed1->bLedOn )
+			if ( pLed1->bLedOn )
 				pLed1->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed1->BlinkingLedState = RTW_LED_ON;
@@ -2326,38 +2326,38 @@ SwLedControlMode4(
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
 
-			if( pLed->bLedNoLinkBlinkInProgress)
+			if ( pLed->bLedNoLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedNoLinkBlinkInProgress = false;
 			}
-			if( pLed->bLedLinkBlinkInProgress)
+			if ( pLed->bLedLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedLinkBlinkInProgress = false;
 			}
-			if( pLed->bLedBlinkInProgress)
+			if ( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if( pLed->bLedWPSBlinkInProgress )
+			if ( pLed->bLedWPSBlinkInProgress )
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
 			}
-			if( pLed->bLedScanBlinkInProgress)
+			if ( pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
 			}
-			if( pLed->bLedStartToLinkBlinkInProgress)
+			if ( pLed->bLedStartToLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedStartToLinkBlinkInProgress = false;
 			}
 
-			if( pLed1->bLedWPSBlinkInProgress )
+			if ( pLed1->bLedWPSBlinkInProgress )
 			{
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
 				pLed1->bLedWPSBlinkInProgress = false;
@@ -2395,7 +2395,7 @@ SwLedControlMode5(
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct LED_871X *		pLed = &(ledpriv->SwLed0);
 
-	if(pHalData->EEPROMCustomerID == RT_CID_819x_CAMEO)
+	if (pHalData->EEPROMCustomerID == RT_CID_819x_CAMEO)
 		pLed = &(ledpriv->SwLed1);
 
 	switch(LedAction)
@@ -2410,11 +2410,11 @@ SwLedControlMode5(
 			break;
 
 		case LED_CTL_SITE_SURVEY:
-			if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
+			if ((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 				;
-			else if(pLed->bLedScanBlinkInProgress ==false)
+			else if (pLed->bLedScanBlinkInProgress ==false)
 			{
-				if(pLed->bLedBlinkInProgress ==true)
+				if (pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = false;
@@ -2422,7 +2422,7 @@ SwLedControlMode5(
 				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -2432,16 +2432,16 @@ SwLedControlMode5(
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if(pLed->bLedBlinkInProgress ==false)
+			if (pLed->bLedBlinkInProgress ==false)
 			{
-				if(pLed->CurrLedState == LED_SCAN_BLINK)
+				if (pLed->CurrLedState == LED_SCAN_BLINK)
 				{
 					return;
 				}
 				pLed->bLedBlinkInProgress = true;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
-				if( pLed->bLedOn )
+				if ( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -2453,7 +2453,7 @@ SwLedControlMode5(
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
 
-			if( pLed->bLedBlinkInProgress)
+			if ( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
@@ -2488,21 +2488,21 @@ LedControl871x(
 {
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 
-       if( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
+       if ( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
        {
              return;
        }
 
-	if( ledpriv->bRegUseLed == false)
+	if ( ledpriv->bRegUseLed == false)
 		return;
 
 	//if (!priv->up)
 	//	return;
 
-	//if(priv->bInHctTest)
+	//if (priv->bInHctTest)
 	//	return;
 
-	if(	padapter->pwrctrlpriv.rf_pwrstate != rf_on &&
+	if (	padapter->pwrctrlpriv.rf_pwrstate != rf_on &&
 		(LedAction == LED_CTL_TX || LedAction == LED_CTL_RX ||
 		 LedAction == LED_CTL_SITE_SURVEY ||
 		 LedAction == LED_CTL_LINK ||
--- a/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
@@ -40,7 +40,7 @@ void rtl8192du_init_recvbuf(struct rtw_a
 
 	precvbuf->ref_cnt = 0;
 
-	if(precvbuf->pbuf)
+	if (precvbuf->pbuf)
 	{
 		precvbuf->pdata = precvbuf->phead = precvbuf->ptail = precvbuf->pbuf;
 		precvbuf->pend = precvbuf->pdata + MAX_RECVBUF_SZ;
@@ -70,11 +70,11 @@ int	rtl8192du_init_recv_priv(struct rtw_
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
 
 	precvpriv->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);
-	if(precvpriv->int_in_urb == NULL){
+	if (precvpriv->int_in_urb == NULL){
 		DBG_8192D("alloc_urb for interrupt in endpoint fail !!!!\n");
 	}
 	precvpriv->int_in_buf = rtw_malloc(sizeof(INTERRUPT_MSG_FORMAT_EX));
-	if(precvpriv->int_in_buf == NULL){
+	if (precvpriv->int_in_buf == NULL){
 		DBG_8192D("alloc_mem for interrupt in endpoint fail !!!!\n");
 	}
 #endif //CONFIG_USB_INTERRUPT_IN_PIPE
@@ -83,7 +83,7 @@ int	rtl8192du_init_recv_priv(struct rtw_
 	_rtw_init_queue(&precvpriv->free_recv_buf_queue);
 
 	precvpriv->pallocated_recv_buf = rtw_zmalloc(NR_RECVBUFF *sizeof(struct recv_buf) + 4);
-	if(precvpriv->pallocated_recv_buf==NULL){
+	if (precvpriv->pallocated_recv_buf==NULL){
 		res= _FAIL;
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("alloc recv_buf fail!\n"));
 		goto exit;
@@ -102,7 +102,7 @@ int	rtl8192du_init_recv_priv(struct rtw_
 		precvbuf->alloc_sz = MAX_RECVBUF_SZ;
 
 		res = rtw_os_recvbuf_resource_alloc(padapter, precvbuf);
-		if(res==_FAIL)
+		if (res==_FAIL)
 			break;
 
 		precvbuf->ref_cnt = 0;
@@ -140,7 +140,7 @@ int	rtl8192du_init_recv_priv(struct rtw_
 			pskb = netdev_alloc_skb(padapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
 	#endif //(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
 
-			if(pskb)
+			if (pskb)
 			{
 				pskb->dev = padapter->pnetdev;
 
@@ -179,7 +179,7 @@ void rtl8192du_free_recv_priv (struct rt
 	kfree(precvpriv->pallocated_recv_buf);
 
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
-	if(precvpriv->int_in_urb)
+	if (precvpriv->int_in_urb)
 		usb_free_urb(precvpriv->int_in_urb);
 	kfree(precvpriv->int_in_buf);
 #endif
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -177,19 +177,19 @@ static void fill_txdesc_vcs(struct pkt_a
 			break;
 	}
 
-	if(pattrib->vcs_mode) {
+	if (pattrib->vcs_mode) {
 		*pdw |= cpu_to_le32(BIT(13));
 
 		// Set RTS BW
-		if(pattrib->ht_en)
+		if (pattrib->ht_en)
 		{
 			*pdw |= (pattrib->bwmode&HT_CHANNEL_WIDTH_40)?	cpu_to_le32(BIT(27)):0;
 
-			if(pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
+			if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
 				*pdw |= cpu_to_le32((0x01<<28)&0x30000000);
-			else if(pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)
+			else if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)
 				*pdw |= cpu_to_le32((0x02<<28)&0x30000000);
-			else if(pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)
+			else if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)
 				*pdw |= 0;
 			else
 				*pdw |= cpu_to_le32((0x03<<28)&0x30000000);
@@ -201,15 +201,15 @@ static void fill_txdesc_phy(struct pkt_a
 {
 	//DBG_8192D("bwmode=%d, ch_off=%d\n", pattrib->bwmode, pattrib->ch_offset);
 
-	if(pattrib->ht_en)
+	if (pattrib->ht_en)
 	{
 		*pdw |= (pattrib->bwmode&HT_CHANNEL_WIDTH_40)?	cpu_to_le32(BIT(25)):0;
 
-		if(pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
+		if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
 			*pdw |= cpu_to_le32((0x01<<20)&0x00300000);
-		else if(pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)
+		else if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)
 			*pdw |= cpu_to_le32((0x02<<20)&0x00300000);
-		else if(pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)
+		else if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)
 			*pdw |= 0;
 		else
 			*pdw |= cpu_to_le32((0x03<<20)&0x00300000);
@@ -263,7 +263,7 @@ static s32 update_txdesc(struct xmit_fra
 if (padapter->registrypriv.mp_mode == 0)
 {
 
-	if((false == bagg_pkt) && (urb_zero_packet_chk(padapter, sz)==0))
+	if ((false == bagg_pkt) && (urb_zero_packet_chk(padapter, sz)==0))
 	{
 		ptxdesc = (struct tx_desc *)(pmem+PACKET_OFFSET_SZ);
 		pull = 1;
@@ -274,7 +274,7 @@ if (padapter->registrypriv.mp_mode == 0)
 
 	memset(ptxdesc, 0, sizeof(struct tx_desc));
 
-	if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
+	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
 	{
 		//DBG_8192D("pxmitframe->frame_tag == DATA_FRAMETAG\n");
 
@@ -288,12 +288,12 @@ if (padapter->registrypriv.mp_mode == 0)
 
 		fill_txdesc_sectype(pattrib, ptxdesc);
 
-		if(pattrib->ampdu_en==true){
+		if (pattrib->ampdu_en==true){
 			ptxdesc->txdw1 |= cpu_to_le32(BIT(5));//AGG EN
 			//Insert Early Mode Content after tx desc position.
-			if((pHalData->bEarlyModeEnable) && (true == bagg_pkt)){
+			if ((pHalData->bEarlyModeEnable) && (true == bagg_pkt)){
 				ptxdesc->txdw0 |= cpu_to_le32(((USB_HWDESC_HEADER_LEN-8) << OFFSET_SHT) & 0x00ff0000);//32 bytes for TX Desc
-				if(pxmitframe->EMPktNum > 0){
+				if (pxmitframe->EMPktNum > 0){
 					InsertEMContent(pxmitframe, pmem+TXDESC_SIZE);
 				}
 			}
@@ -328,11 +328,11 @@ if (padapter->registrypriv.mp_mode == 0)
 			//use REG_INIDATA_RATE_SEL value
 			ptxdesc->txdw5 |= cpu_to_le32(pdmpriv->INIDATA_RATE[pattrib->mac_id]);
 
-		if(0)//for driver dbg
+		if (0)//for driver dbg
 			{
 				ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
 
-				if(pattrib->ht_en)
+				if (pattrib->ht_en)
 					ptxdesc->txdw5 |= cpu_to_le32(BIT(6));//SGI
 
 				ptxdesc->txdw5 |= cpu_to_le32(0x00000013);//init rate - mcs7
@@ -356,7 +356,7 @@ if (padapter->registrypriv.mp_mode == 0)
 		}
 
 #ifdef CONFIG_P2P
-		if(pregistrypriv->wifi_spec==1 && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		if (pregistrypriv->wifi_spec==1 && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
 			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));//AGG BK
 
@@ -378,7 +378,7 @@ if (padapter->registrypriv.mp_mode == 0)
 		}
 #endif
 	}
-	else if((pxmitframe->frame_tag&0x0f)== MGNT_FRAMETAG)
+	else if ((pxmitframe->frame_tag&0x0f)== MGNT_FRAMETAG)
 	{
 		//DBG_8192D("pxmitframe->frame_tag == MGNT_FRAMETAG\n");
 
@@ -411,10 +411,10 @@ if (padapter->registrypriv.mp_mode == 0)
 
 		//offset 20
 #ifdef CONFIG_AP_MODE
-		if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
 			ptxdesc->txdw5 |= cpu_to_le32(BIT(17));//retry limit enable
 #ifdef CONFIG_P2P
-			if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
+			if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
 				ptxdesc->txdw5 |= cpu_to_le32(0x00080000);//retry limit = 2
 			} else
 #endif //CONFIG_P2P
@@ -423,11 +423,11 @@ if (padapter->registrypriv.mp_mode == 0)
 #endif
 
 		ptxdesc->txdw5 |= cpu_to_le32(ratetohwrate(pmlmeext->tx_rate));
-	} else if((pxmitframe->frame_tag&0x0f) == TXAGG_FRAMETAG) {
+	} else if ((pxmitframe->frame_tag&0x0f) == TXAGG_FRAMETAG) {
 		DBG_8192D("pxmitframe->frame_tag == TXAGG_FRAMETAG\n");
 	}
 #ifdef CONFIG_MP_INCLUDED
-	else if((pxmitframe->frame_tag&0x0f) == MP_FRAMETAG) {
+	else if ((pxmitframe->frame_tag&0x0f) == MP_FRAMETAG) {
 		fill_txdesc_for_mp(padapter, ptxdesc);
 	}
 #endif
@@ -459,7 +459,7 @@ if (padapter->registrypriv.mp_mode == 0)
 	// (2) Enable HW SEQ control for beacon packet, because we use Hw beacon.
 	// (3) Use HW Qos SEQ to control the seq num of Ext port non-Qos packets.
 	// 2010.06.23. Added by tynli.
-	if(!pattrib->qos_en)
+	if (!pattrib->qos_en)
 	{
 		ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); // Hw set sequence number
 		ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); //set bit3 to 1. Suugested by TimChen. 2009.12.29.
@@ -470,7 +470,7 @@ if (padapter->registrypriv.mp_mode == 0)
 	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
 	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);//32 bytes for TX Desc
 
-	if(bmcst)
+	if (bmcst)
 	{
 		ptxdesc->txdw0 |= cpu_to_le32(BIT(24));
 	}
@@ -517,7 +517,7 @@ s32 rtw_dump_xframe(struct rtw_adapter *
 	{
 #ifdef CONFIG_TDLS
 		ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
-		if((ptdls_sta!=NULL)&&(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
+		if ((ptdls_sta!=NULL)&&(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 		{
 			psta_backup = pattrib->psta;
 			pattrib->psta = ptdls_sta;
@@ -554,7 +554,7 @@ s32 rtw_dump_xframe(struct rtw_adapter *
 
 		pull = update_txdesc(pxmitframe, mem_addr, sz, false);
 
-		if(pull)
+		if (pull)
 		{
 			mem_addr += PACKET_OFFSET_SZ; //pull txdesc head
 
@@ -606,7 +606,7 @@ static u32 xmitframe_need_length(struct
 		pattrib->pktlen +
 		((pattrib->bswenc) ? pattrib->icv_len : 0);
 
-	if(pattrib->encrypt ==_TKIP_)
+	if (pattrib->encrypt ==_TKIP_)
 		len += 8;
 
 	return len;
@@ -621,7 +621,7 @@ void UpdateEarlyModeInfo8192D(struct rtw
 	struct list_head *xmitframe_plist = NULL, *xmitframe_phead = NULL;
 
 	//Some macaddr can't do early mode.
-	if(MacAddr_isBcst(pattrib->dst) ||IS_MCAST(pattrib->dst) || !!pattrib->qos_en)
+	if (MacAddr_isBcst(pattrib->dst) ||IS_MCAST(pattrib->dst) || !!pattrib->qos_en)
 		return;
 
 	pxmitframe->EMPktNum = 0;
@@ -683,14 +683,14 @@ s32 rtl8192du_xmitframe_complete(struct
 		if (pxmitbuf == NULL) return false;
 	}
 
-	if(pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY)
+	if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY)
 		aggMaxLength = MAX_XMITBUF_SZ;
 	else
 		aggMaxLength = 0x3D00;
 
 	do {
 		//3 1. pick up first frame
-		if(bfirst)
+		if (bfirst)
 		{
 			pxmitframe = rtw_dequeue_xframe(pxmitpriv, pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);
 			if (pxmitframe == NULL) {
@@ -748,7 +748,7 @@ s32 rtl8192du_xmitframe_complete(struct
 
 			spin_unlock_bh(&pxmitpriv->lock);
 
-			if(bulkstart)
+			if (bulkstart)
 			{
 				break;
 			}
@@ -759,7 +759,7 @@ s32 rtl8192du_xmitframe_complete(struct
 			pxmitframe->pkt_offset = USB_92D_DUMMY_OFFSET - 1; // not first frame of aggregation, reserve 1 offset for early mode
 		}
 
-		if(pHalData->bEarlyModeEnable)
+		if (pHalData->bEarlyModeEnable)
 			UpdateEarlyModeInfo8192D(padapter, pxmitframe,ptxservq);
 
 #ifdef IDEA_CONDITION
@@ -775,7 +775,7 @@ s32 rtl8192du_xmitframe_complete(struct
 		// always return ndis_packet after rtw_xmitframe_coalesce
 		rtw_os_xmit_complete(padapter, pxmitframe);
 
-		if(bfirst)
+		if (bfirst)
 		{
 			len = xmitframe_need_length(pfirstframe) + USB_HWDESC_HEADER_LEN;
 			pbuf_tail = len;
@@ -866,10 +866,10 @@ s32 rtl8192du_xmitframe_complete(struct
 
 	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("xmitframe_complete()\n"));
 
-	if(pxmitbuf==NULL)
+	if (pxmitbuf==NULL)
 	{
 		pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
-		if(!pxmitbuf)
+		if (!pxmitbuf)
 		{
 			return false;
 		}
@@ -879,7 +879,7 @@ s32 rtl8192du_xmitframe_complete(struct
 	{
 		pxmitframe =  rtw_dequeue_xframe(pxmitpriv, phwxmits, hwentry);
 
-		if(pxmitframe)
+		if (pxmitframe)
 		{
 			pxmitframe->pxmitbuf = pxmitbuf;
 
@@ -887,9 +887,9 @@ s32 rtl8192du_xmitframe_complete(struct
 
 			pxmitbuf->priv_data = pxmitframe;
 
-			if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
+			if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
 			{
-				if(pxmitframe->attrib.priority<=15)//TID0~15
+				if (pxmitframe->attrib.priority<=15)//TID0~15
 				{
 					res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
 				}
@@ -901,7 +901,7 @@ s32 rtl8192du_xmitframe_complete(struct
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("xmitframe_complete(): rtw_dump_xframe\n"));
 
 
-			if(res == _SUCCESS)
+			if (res == _SUCCESS)
 			{
 				rtw_dump_xframe(padapter, pxmitframe);
 			}
@@ -1067,7 +1067,7 @@ s32 rtl8192du_hostap_mgnt_xmit_entry(str
 	pxmit_skb = netdev_alloc_skb(pnetdev, len + TXDESC_SIZE);
 #endif
 
-	if(!pxmit_skb)
+	if (!pxmit_skb)
 		goto _exit;
 
 	pxmitbuf = pxmit_skb->data;
@@ -1085,7 +1085,7 @@ s32 rtl8192du_hostap_mgnt_xmit_entry(str
 	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);//default = 32 bytes for TX Desc
 	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
 
-	if(bmcst)
+	if (bmcst)
 	{
 		ptxdesc->txdw0 |= cpu_to_le32(BIT(24));
 	}
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -87,7 +87,7 @@ _TwoOutEpMapping(
 	)
 {
 
-	if(bWIFICfg){ // Normal chip && wmm
+	if (bWIFICfg){ // Normal chip && wmm
 
 		//	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA
 		//{  0,		1,	0,	1,	0,	0,	0,	0,		0	};
@@ -131,7 +131,7 @@ static void _ThreeOutEpMapping(
 	bool			bWIFICfg
 	)
 {
-	if(bWIFICfg){//for WMM
+	if (bWIFICfg){//for WMM
 
 		//	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA
 		//{  1,		2,	1,	0,	0,	0,	0,	0,		0	};
@@ -214,28 +214,28 @@ _ConfigChipOutEP(
 	pHalData->OutEpNumber = 0;
 
 	// Normal and High queue
-	if(pHalData->interfaceIndex==0)
+	if (pHalData->interfaceIndex==0)
 		value8=rtw_read8(pAdapter, REG_USB_High_NORMAL_Queue_Select_MAC0);
 	else
 		value8=rtw_read8(pAdapter, REG_USB_High_NORMAL_Queue_Select_MAC1);
 
-	if(value8 & USB_NORMAL_SIE_EP_MASK){
+	if (value8 & USB_NORMAL_SIE_EP_MASK){
 		pHalData->OutEpQueueSel |= TX_SELE_HQ;
 		pHalData->OutEpNumber++;
 	}
 
-	if((value8 >> USB_NORMAL_SIE_EP_SHIFT) & USB_NORMAL_SIE_EP_MASK){
+	if ((value8 >> USB_NORMAL_SIE_EP_SHIFT) & USB_NORMAL_SIE_EP_MASK){
 		pHalData->OutEpQueueSel |= TX_SELE_NQ;
 		pHalData->OutEpNumber++;
 	}
 
 	// Low queue
-	if(pHalData->interfaceIndex==0)
+	if (pHalData->interfaceIndex==0)
 		value8=rtw_read8(pAdapter, (REG_USB_High_NORMAL_Queue_Select_MAC0+1));
 	else
 		value8=rtw_read8(pAdapter, (REG_USB_High_NORMAL_Queue_Select_MAC1+1));
 
-	if(value8 & USB_NORMAL_SIE_EP_MASK){
+	if (value8 & USB_NORMAL_SIE_EP_MASK){
 		pHalData->OutEpQueueSel |= TX_SELE_LQ;
 		pHalData->OutEpNumber++;
 	}
@@ -275,8 +275,8 @@ static bool HalUsbSetQueuePipeMapping819
 	_ConfigChipOutEP(pAdapter, NumOutPipe);
 
 	// Normal chip with one IN and one OUT doesn't have interrupt IN EP.
-	if(1 == pHalData->OutEpNumber){
-		if(1 != NumInPipe){
+	if (1 == pHalData->OutEpNumber){
+		if (1 != NumInPipe){
 			return result;
 		}
 	}
@@ -338,19 +338,19 @@ static u8 _InitPowerOn(struct rtw_adapte
 	// polling autoload done.
 	u32	pollingCount = 0;
 
-	if(padapter->bSurpriseRemoved){
+	if (padapter->bSurpriseRemoved){
 		return _FAIL;
 	}
 
 	pollingCount = 0;
 	do
 	{
-		if(rtw_read8(padapter, REG_APS_FSMCO) & PFM_ALDN){
+		if (rtw_read8(padapter, REG_APS_FSMCO) & PFM_ALDN){
 			//RT_TRACE(COMP_INIT,DBG_LOUD,("Autoload Done!\n"));
 			break;
 		}
 
-		if(pollingCount++ > POLLING_READY_TIMEOUT_COUNT){
+		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT){
 			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling REG_APS_FSMCO[PFM_ALDN] done!\n"));
 			return _FAIL;
 		}
@@ -366,7 +366,7 @@ static u8 _InitPowerOn(struct rtw_adapte
 	rtw_usleep_os(100);//PlatformSleepUs(150);//this is not necessary when initially power on
 
 	value8 = rtw_read8(padapter, REG_LDOV12D_CTRL);
-	if(0== (value8 & LDV12_EN) ){
+	if (0== (value8 & LDV12_EN) ){
 		value8 |= LDV12_EN;
 		rtw_write8(padapter, REG_LDOV12D_CTRL, value8);
 		//RT_TRACE(COMP_INIT, DBG_LOUD, (" power-on :REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8));
@@ -384,12 +384,12 @@ static u8 _InitPowerOn(struct rtw_adapte
 
 	do
 	{
-		if(0 == (rtw_read16(padapter, REG_APS_FSMCO) & APFM_ONMAC)){
+		if (0 == (rtw_read16(padapter, REG_APS_FSMCO) & APFM_ONMAC)){
 			//RT_TRACE(COMP_INIT,DBG_LOUD,("MAC auto ON okay!\n"));
 			break;
 		}
 
-		if(pollingCount++ > POLLING_READY_TIMEOUT_COUNT){
+		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT){
 			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling REG_APS_FSMCO[APFM_ONMAC] done!\n"));
 			return _FAIL;
 		}
@@ -428,7 +428,7 @@ u16 CRC16(u8 data,u16 CRC)
 		//set BIT0
 		//	printf("CRC =%x\n",CRC_Result);
 		//CRC bit 0 =shift_in,
-		if(shift_in==0)
+		if (shift_in==0)
 		{
 			CRC_Result&=(~BIT0);
 		}
@@ -439,7 +439,7 @@ u16 CRC16(u8 data,u16 CRC)
 		//printf("CRC =%x\n",CRC_Result);
 
 		CRC_BIT11 = ((CRC&BIT11) ? 1:0)^shift_in;
-		if(CRC_BIT11==0)
+		if (CRC_BIT11==0)
 		{
 			CRC_Result&=(~BIT12);
 		}
@@ -450,7 +450,7 @@ u16 CRC16(u8 data,u16 CRC)
 		//printf("bit12 CRC =%x\n",CRC_Result);
 
 		CRC_BIT4 = ((CRC&BIT4) ? 1:0)^shift_in;
-		if(CRC_BIT4==0)
+		if (CRC_BIT4==0)
 		{
 			CRC_Result&=(~BIT5);
 		}
@@ -513,7 +513,7 @@ static int rtw_wowlan_set_pattern(struct
 
 	// Write to the Wakeup CAM
 	//offset 0
-	if(pattern_len>=4){
+	if (pattern_len>=4){
 		content=pdata[1];
 	}
 	else{
@@ -525,7 +525,7 @@ static int rtw_wowlan_set_pattern(struct
 	//cmd=BIT(31)|BIT(16)|(idx+0);
 	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 	//offset 4
-	if(pattern_len>=8){
+	if (pattern_len>=8){
 		content=pdata[2];
 	}
 	else{
@@ -538,7 +538,7 @@ static int rtw_wowlan_set_pattern(struct
 	//cmd=BIT(31)|BIT(16)|(idx+1);
 	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 	//offset 8
-	if(pattern_len>=12){
+	if (pattern_len>=12){
 		content=pdata[3];
 	}
 	else{
@@ -550,7 +550,7 @@ static int rtw_wowlan_set_pattern(struct
 	//cmd=BIT(31)|BIT(16)|(idx+2);
 	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 	//offset 12
-	if(pattern_len>=16){
+	if (pattern_len>=16){
 		content=pdata[4];
 	}
 	else{
@@ -562,7 +562,7 @@ static int rtw_wowlan_set_pattern(struct
 	//cmd=BIT(31)|BIT(16)|(idx+3);
 	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 
-	if(crc){
+	if (crc){
 		// Have the CRC value
 		crc_val=*(u16 *)(&pbuf[2]);
 		DBG_8192D("rtw_wowlan_set_pattern crc_val  0x%x  \n", crc_val);
@@ -574,7 +574,7 @@ static int rtw_wowlan_set_pattern(struct
 		// calculate the CRC the write to the Wakeup CAM
 		crc_idx=0;
 		for(i=0;i<packet_len;i++){
-			if(pbuf[4+(i/8)]&(0x01<<(i%8)))
+			if (pbuf[4+(i/8)]&(0x01<<(i%8)))
 			{
 				packet[crc_idx++]=pbuf[20+i];
 		//		DBG_8192D("\n i=%d packet[i]=%x pbuf[20+i(%d)]=%x \n",i,packet[i],20+i,pbuf[20+i]);
@@ -606,7 +606,7 @@ void rtw_wowlan_reload_pattern(struct rt
 	u8 idx;
 
 	for (idx=0;idx<8;idx ++){
-		if(pwrpriv->wowlan_pattern_idx & BIT(idx)){
+		if (pwrpriv->wowlan_pattern_idx & BIT(idx)){
 			//offset 0
 			rtw_write32(padapter, REG_WKFMCAM_RWD, pwrpriv->wowlan_pattern_context[idx][0]);
 			cmd=BIT(31)|BIT(16)|(idx+0);
@@ -677,11 +677,11 @@ static u8 _LLTWrite(
 	do{
 
 		value = rtw_read32(Adapter, REG_LLT_INIT);
-		if(_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)){
+		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)){
 			break;
 		}
 
-		if(count > POLLING_LLT_THRESHOLD){
+		if (count > POLLING_LLT_THRESHOLD){
 			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling write LLT done at address %d!\n", address));
 			status = _FAIL;
 			break;
@@ -706,11 +706,11 @@ static u8 _LLTRead(
 	do{
 
 		value = rtw_read32(Adapter, REG_LLT_INIT);
-		if(_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)){
+		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)){
 			return (u8)value;
 		}
 
-		if(count > POLLING_LLT_THRESHOLD){
+		if (count > POLLING_LLT_THRESHOLD){
 			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling read LLT done at address %d!\n", address));
 			break;
 		}
@@ -732,7 +732,7 @@ static u8 InitLLTTable(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
 
-	if(pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY){
+	if (pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY){
 		//for 92du two mac: The page size is different from 92c and 92s
 		txpktbuf_bndy =TX_PAGE_BOUNDARY_DUAL_MAC;
 		Last_Entry_Of_TxPktBuf=LAST_ENTRY_OF_TX_PKT_BUFFER_DUAL_MAC;
@@ -746,14 +746,14 @@ static u8 InitLLTTable(
 
 	for(i = 0 ; i < (txpktbuf_bndy - 1) ; i++){
 		status = _LLTWrite(Adapter, i , i + 1);
-		if(_SUCCESS != status){
+		if (_SUCCESS != status){
 			return status;
 		}
 	}
 
 	// end of list
 	status = _LLTWrite(Adapter, (txpktbuf_bndy - 1), 0xFF);
-	if(_SUCCESS != status){
+	if (_SUCCESS != status){
 		return status;
 	}
 
@@ -762,14 +762,14 @@ static u8 InitLLTTable(
 	// Otherwise used as local loopback buffer.
 	for(i = txpktbuf_bndy ; i < Last_Entry_Of_TxPktBuf ; i++){
 		status = _LLTWrite(Adapter, i, (i + 1));
-		if(_SUCCESS != status){
+		if (_SUCCESS != status){
 			return status;
 		}
 	}
 
 	// Let last entry point to the start entry of ring buffer
 	status = _LLTWrite(Adapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);
-	if(_SUCCESS != status){
+	if (_SUCCESS != status){
 		return status;
 	}
 
@@ -790,7 +790,7 @@ _SetMacID(
 	u32 i;
 	for(i=0 ; i< MAC_ADDR_LEN ; i++){
 #ifdef  CONFIG_CONCURRENT_MODE
-		if(Adapter->iface_type == IFACE_PORT1)
+		if (Adapter->iface_type == IFACE_PORT1)
 			rtw_write32(Adapter, REG_MACID1+i, MacID[i]);
 		else
 #endif
@@ -806,7 +806,7 @@ _SetBSSID(
 	u32 i;
 	for(i=0 ; i< MAC_ADDR_LEN ; i++){
 #ifdef  CONFIG_CONCURRENT_MODE
-		if(Adapter->iface_type == IFACE_PORT1)
+		if (Adapter->iface_type == IFACE_PORT1)
 			rtw_write32(Adapter, REG_BSSID1+i, BSSID[i]);
 		else
 #endif
@@ -848,9 +848,9 @@ _InitQueueReservedPage(
 	u8			value8;
 	u32			txQPageNum, txQPageUnit,txQRemainPage;
 
-	if(!pregistrypriv->wifi_spec)
+	if (!pregistrypriv->wifi_spec)
 	{
-		if(pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY)
+		if (pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY)
 		{
 			numPubQ = NORMAL_PAGE_NUM_PUBQ_92D_DUAL_MAC;
 			txQPageNum = TX_TOTAL_PAGE_NUMBER_92D_DUAL_MAC- numPubQ;
@@ -862,7 +862,7 @@ _InitQueueReservedPage(
 			txQPageNum = TX_TOTAL_PAGE_NUMBER - numPubQ;
 		}
 
-		if((pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY)&&(outEPNum==3))
+		if ((pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY)&&(outEPNum==3))
 		{// temply for DMDP/DMSP Page allocate
 			numHQ=NORMAL_PAGE_NUM_HPQ_92D_DUAL_MAC;
 			numLQ=NORMAL_PAGE_NUM_LPQ_92D_DUAL_MAC;
@@ -873,20 +873,20 @@ _InitQueueReservedPage(
 			txQPageUnit = txQPageNum/outEPNum;
 			txQRemainPage = txQPageNum % outEPNum;
 
-			if(pHalData->OutEpQueueSel & TX_SELE_HQ){
+			if (pHalData->OutEpQueueSel & TX_SELE_HQ){
 				numHQ = txQPageUnit;
 			}
-			if(pHalData->OutEpQueueSel & TX_SELE_LQ){
+			if (pHalData->OutEpQueueSel & TX_SELE_LQ){
 				numLQ = txQPageUnit;
 			}
 			// HIGH priority queue always present in the configuration of 2 or 3 out-ep
 			// so ,remainder pages have assigned to High queue
-			if((outEPNum>1) && (txQRemainPage)){
+			if ((outEPNum>1) && (txQRemainPage)){
 				numHQ += txQRemainPage;
 			}
 
 			// NOTE: This step shall be proceed before writting REG_RQPN.
-			if(pHalData->OutEpQueueSel & TX_SELE_NQ)
+			if (pHalData->OutEpQueueSel & TX_SELE_NQ)
 				numNQ = txQPageUnit;
 
 			value8 = (u8)_NPQ(numNQ);
@@ -900,15 +900,15 @@ _InitQueueReservedPage(
 
 		numPubQ = (outEPNum==2)?WMM_NORMAL_PAGE_NUM_PUBQ:WMM_NORMAL_PAGE_NUM_PUBQ_92D;
 
-		if(pHalData->OutEpQueueSel & TX_SELE_HQ){
+		if (pHalData->OutEpQueueSel & TX_SELE_HQ){
 			numHQ = (outEPNum==2)?WMM_NORMAL_PAGE_NUM_HPQ:WMM_NORMAL_PAGE_NUM_HPQ_92D;
 		}
 
-		if(pHalData->OutEpQueueSel & TX_SELE_LQ){
+		if (pHalData->OutEpQueueSel & TX_SELE_LQ){
 			numLQ = (outEPNum==2)?WMM_NORMAL_PAGE_NUM_LPQ:WMM_NORMAL_PAGE_NUM_LPQ_92D;
 		}
 
-		if(pHalData->OutEpQueueSel & TX_SELE_NQ){
+		if (pHalData->OutEpQueueSel & TX_SELE_NQ){
 			numNQ = (outEPNum==2)?WMM_NORMAL_PAGE_NUM_NPQ:WMM_NORMAL_PAGE_NUM_NPQ_92D;
 			value8 = (u8)_NPQ(numNQ);
 			rtw_write8(Adapter, REG_RQPN_NPQ, value8);
@@ -931,14 +931,14 @@ _InitTxBufferBoundary(
 	//u16	txdmactrl;
 	u8	txpktbuf_bndy;
 
-	if(!pregistrypriv->wifi_spec){
+	if (!pregistrypriv->wifi_spec){
 		txpktbuf_bndy = TX_PAGE_BOUNDARY;
 	}
 	else{//for WMM
 		txpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY;
 	}
 
-	if(pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY)
+	if (pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY)
 		txpktbuf_bndy = TX_PAGE_BOUNDARY_DUAL_MAC;
 
 	rtw_write8(Adapter, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);
@@ -1036,7 +1036,7 @@ _InitNormalChipTwoOutEpPriority(
 			break;
 	}
 
-	if(!pregistrypriv->wifi_spec ){
+	if (!pregistrypriv->wifi_spec ){
 		beQ		= valueLow;
 		bkQ		= valueLow;
 		viQ		= valueHi;
@@ -1065,7 +1065,7 @@ _InitNormalChipThreeOutEpPriority(
 	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
 
-	if(!pregistrypriv->wifi_spec ){// typical setting
+	if (!pregistrypriv->wifi_spec ){// typical setting
 		beQ		= QUEUE_LOW;
 		bkQ		= QUEUE_LOW;
 		viQ		= QUEUE_NORMAL;
@@ -1208,7 +1208,7 @@ _InitAdaptiveCtrl(
 	// Response Rate Set
 	value32 = rtw_read32(Adapter, REG_RRSR);
 	value32 &= ~RATE_BITMAP_ALL;
-	if(pHalData->CurrentBandType92D == BAND_ON_5G)
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 	{
 		value32 |= RATE_RRSR_WITHOUT_CCK;
 	}
@@ -1310,11 +1310,11 @@ _InitAMPDUAggregation(
 
 	//rtw_write32(Adapter, REG_AGGLEN_LMT, 0x99997631);
 
-	if(pHalData->MacPhyMode92D ==SINGLEMAC_SINGLEPHY)
+	if (pHalData->MacPhyMode92D ==SINGLEMAC_SINGLEPHY)
 		rtw_write32(Adapter, REG_AGGLEN_LMT, 0x88728841);
-	else if(pHalData->MacPhyMode92D ==DUALMAC_SINGLEPHY)
+	else if (pHalData->MacPhyMode92D ==DUALMAC_SINGLEPHY)
 		rtw_write32(Adapter, REG_AGGLEN_LMT, 0x44444441);
-	else if(pHalData->MacPhyMode92D ==DUALMAC_DUALPHY)
+	else if (pHalData->MacPhyMode92D ==DUALMAC_DUALPHY)
 		rtw_write32(Adapter, REG_AGGLEN_LMT, 0x66525541);
 
 	rtw_write8(Adapter, REG_AGGR_BREAK_TIME, 0x16);
@@ -1369,13 +1369,13 @@ _InitUsbAggregationSetting(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	u32			value32;
 
-	if(Adapter->registrypriv.wifi_spec)
+	if (Adapter->registrypriv.wifi_spec)
 		pHalData->UsbTxAggMode = false;
 
-	if(pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
+	if (pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
 		pHalData->UsbTxAggDescNum = 2;
 
-	if(pHalData->UsbTxAggMode){
+	if (pHalData->UsbTxAggMode){
 		value32 = rtw_read32(Adapter, REG_TDECTRL);
 		value32 = value32 & ~(BLK_DESC_NUM_MASK << BLK_DESC_NUM_SHIFT);
 		value32 |= ((pHalData->UsbTxAggDescNum & BLK_DESC_NUM_MASK) << BLK_DESC_NUM_SHIFT);
@@ -1392,7 +1392,7 @@ _InitUsbAggregationSetting(
 	u8		valueDMA;
 	u8		valueUSB;
 
-	if(pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
+	if (pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
 	{
 		pHalData->UsbRxAggPageCount	= 24;
 		pHalData->UsbRxAggPageTimeout = 0x6;
@@ -1611,7 +1611,7 @@ _InitRFType(
 
 	pHalData->rf_chip	= RF_6052;
 
-	if(pHalData->MacPhyMode92D==DUALMAC_DUALPHY)
+	if (pHalData->MacPhyMode92D==DUALMAC_DUALPHY)
 	{
 		pHalData->rf_type = RF_1T1R;
 	}
@@ -1660,7 +1660,7 @@ static void _BBTurnOnBlock(
 	return;
 #endif
 
-	if(pHalData->CurrentBandType92D == BAND_ON_5G)
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 		PHY_SetBBReg(Adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x2);
 	else
 		PHY_SetBBReg(Adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x3);
@@ -1678,25 +1678,25 @@ static void _RfPowerSave(
 	return;
 #endif
 
-	if(pwrctrlpriv->reg_rfoff == true){ // User disable RF via registry.
+	if (pwrctrlpriv->reg_rfoff == true){ // User disable RF via registry.
 		//RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RegRfOff.\n"));
 		//MgntActSet_RF_State(Adapter, rf_off, RF_CHANGE_BY_SW, true);
 		// Those action will be discard in MgntActSet_RF_State because off the same state
 #ifdef CONFIG_DUALMAC_CONCURRENT
-		if(pHalData->bSlaveOfDMSP)
+		if (pHalData->bSlaveOfDMSP)
 			return;
 #endif
 		for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
 	}
-	else if(pwrctrlpriv->rfoff_reason > RF_CHANGE_BY_PS){ // H/W or S/W RF OFF before sleep.
+	else if (pwrctrlpriv->rfoff_reason > RF_CHANGE_BY_PS){ // H/W or S/W RF OFF before sleep.
 		//RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason));
 		//MgntActSet_RF_State(Adapter, rf_off, pMgntInfo->RfOffReason, true);
 	}
 	else{
 		pwrctrlpriv->rf_pwrstate = rf_on;
 		pwrctrlpriv->rfoff_reason = 0;
-		//if(Adapter->bInSetPower || Adapter->bResetInProgress)
+		//if (Adapter->bInSetPower || Adapter->bResetInProgress)
 		//	PlatformUsbEnableInPipes(Adapter);
 		//RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): RF is on.\n"));
 	}
@@ -1707,7 +1707,7 @@ static void _InitHWLed(struct rtw_adapte
 {
 	struct led_priv *pledpriv = &(Adapter->ledpriv);
 
-	if( pledpriv->LedStrategy != HW_LED)
+	if ( pledpriv->LedStrategy != HW_LED)
 			return;
 
 // HW led control
@@ -1831,18 +1831,18 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEG
 	padapter->init_adpt_in_progress = true;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(BuddyAdapter != NULL)
+	if (BuddyAdapter != NULL)
 	{
-		if(BuddyAdapter->bHaltInProgress)
+		if (BuddyAdapter->bHaltInProgress)
 		{
 			for(i=0;i<100;i++)
 			{
 				rtw_usleep_os(1000);
-				if(!BuddyAdapter->bHaltInProgress)
+				if (!BuddyAdapter->bHaltInProgress)
 					break;
 			}
 
-			if(i==100)
+			if (i==100)
 			{
 				DBG_8192D("fail to initialization due to another adapter is in halt \n");
 				return _FAIL;
@@ -1852,11 +1852,11 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEG
 #endif
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("--->InitializeAdapter8192CUsb()\n"));
 
-	if(padapter->bSurpriseRemoved)
+	if (padapter->bSurpriseRemoved)
 		return _FAIL;
 
 	//Let the first starting mac load RF parameters and do LCK in this case,by wl
-	if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+	if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
 		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
 		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
@@ -1869,7 +1869,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEG
 	rtw_write8(padapter, 0x0003, val8);
 
 #ifdef CONFIG_WOWLAN
-	if(rtw_read8(padapter, REG_MCUFWDL)&BIT7)
+	if (rtw_read8(padapter, REG_MCUFWDL)&BIT7)
 	{
 		u8 reg_val=0;
 		rtl8192d_FirmwareSelfReset(padapter);
@@ -1904,10 +1904,10 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEG
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PW_ON);
 	status = _InitPowerOn(padapter);
-	if(status == _FAIL){
+	if (status == _FAIL){
 		RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init power on!\n"));
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
 		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
 			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
@@ -1915,7 +1915,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INI
 	}
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_LLTT);
-	if(!pregistrypriv->wifi_spec){
+	if (!pregistrypriv->wifi_spec){
 		boundary = TX_PAGE_BOUNDARY;
 	}
 	else{// for WMM
@@ -1925,10 +1925,10 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INI
 	PHY_ConfigMacCoexist_RFPage92D(padapter);
 
 	status =  InitLLTTable(padapter, boundary);
-	if(status == _FAIL){
+	if (status == _FAIL){
 		RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init power on!\n"));
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
 		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
 			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
@@ -1949,15 +1949,15 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOW
 
 	status = FirmwareDownload92D(padapter, false);
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
-	if(status == _FAIL){
+	if (status == _FAIL){
 		padapter->bFWReady = false;
 		pHalData->fw_ractrl = false;
 		DBG_8192D("fw download fail!\n");
 
 		//return fail only when part number check fail,suggested by alex
-		if(0xE0 == rtw_read8(padapter, 0x1c5))
+		if (0xE0 == rtw_read8(padapter, 0x1c5))
 		{
-			if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
 			&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 				|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
 				RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
@@ -1975,7 +1975,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOW
 
 	pHalData->LastHMEBoxNum = 0;
 
-	if(pwrctrlpriv->reg_rfoff == true){
+	if (pwrctrlpriv->reg_rfoff == true){
 		pwrctrlpriv->rf_pwrstate = rf_off;
 	}
 
@@ -1989,9 +1989,9 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOW
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MAC);
 #if (HAL_MAC_ENABLE == 1)
 	status = PHY_MACConfig8192D(padapter);
-	if(status == _FAIL)
+	if (status == _FAIL)
 	{
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
 		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
 			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
@@ -2042,7 +2042,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 #if ENABLE_USB_DROP_INCORRECT_OUT
 	_InitHardwareDropIncorrectBulkOut(padapter);
 #endif
-	if(pHalData->bRDGEnable){
+	if (pHalData->bRDGEnable){
 		_InitRDGSetting(padapter);
 	}
 
@@ -2051,13 +2051,13 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 		rtw_write32(padapter, REG_ARFR0+i*4, 0x1f8ffff0);
 	}
 
-	if(pregistrypriv->wifi_spec)
+	if (pregistrypriv->wifi_spec)
 	{
 		rtw_write16(padapter, REG_FAST_EDCA_CTRL, 0);
 	}
 	else{
-		if(pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY){
-			if(pHalData->OutEpNumber == 2)  // suggested by chunchu
+		if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY){
+			if (pHalData->OutEpNumber == 2)  // suggested by chunchu
 				rtw_write32(padapter, REG_FAST_EDCA_CTRL, 0x03066666);
 		       else
 				rtw_write16(padapter, REG_FAST_EDCA_CTRL, 0x8888);
@@ -2090,7 +2090,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 	val8 |=(BIT0|BIT1);
 	rtw_write8(padapter, 0xfe56, val8);
 
-	if(pHalData->bEarlyModeEnable)
+	if (pHalData->bEarlyModeEnable)
 	{
 		DBG_8192D("EarlyMode Enabled!!!\n");
 
@@ -2115,9 +2115,9 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB);
 #if (HAL_BB_ENABLE == 1)
 	status = PHY_BBConfig8192D(padapter);
-	if(status == _FAIL)
+	if (status == _FAIL)
 	{
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
 		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
 			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
@@ -2126,14 +2126,14 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB)
 #endif
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(pHalData->bSlaveOfDMSP)
+	if (pHalData->bSlaveOfDMSP)
 	{
 		DBG_8192D("slave of dmsp close phy1 \n");
 		PHY_StopTRXBeforeChangeBand8192D(padapter);
 	}
 #endif
 
-	if(padapter->bFWReady && pHalData->FirmwareVersion >= 0x13)
+	if (padapter->bFWReady && pHalData->FirmwareVersion >= 0x13)
 	{
 		pHalData->bReadRFbyFW = true;
 		DBG_8192D("Enable 92du query RF by FW.\n");
@@ -2155,9 +2155,9 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF)
 	PHY_SetBBReg(padapter, rFPGA0_AnalogParameter4, 0x00f00000,  0xf);
 
 	status = PHY_RFConfig8192D(padapter);
-	if(status == _FAIL)
+	if (status == _FAIL)
 	{
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
 		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
 			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
@@ -2168,7 +2168,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF)
 	PHY_SetBBReg(padapter, rFPGA0_AnalogParameter4, 0x00f00000,  0);
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(!pHalData->bSlaveOfDMSP)
+	if (!pHalData->bSlaveOfDMSP)
 #endif
 		PHY_UpdateBBRFConfiguration8192D(padapter, false);
 
@@ -2180,13 +2180,13 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF)
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_TURN_ON_BLOCK);
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(!pHalData->bSlaveOfDMSP)
+	if (!pHalData->bSlaveOfDMSP)
 #endif
 		_BBTurnOnBlock(padapter);
 
 	//NicIFSetMacAddress(padapter, padapter->PermanentAddress);
 
-	if(pHalData->CurrentBandType92D == BAND_ON_5G)
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 	{
 		pHalData->CurrentWirelessMode = WIRELESS_MODE_N_5G;
 	}
@@ -2223,13 +2223,13 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 	//MPT_InitializeAdapter(padapter, Channel);
 #else // temply marked this for RF
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(!pHalData->bSlaveOfDMSP)
+	if (!pHalData->bSlaveOfDMSP)
 #endif
 	{
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_IQK);
 		// do IQK for 2.4G for better scan result, if current bandtype is 2.4G.
-		if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+		if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 			rtl8192d_PHY_IQCalibrate(padapter);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_PW_TRACK);
@@ -2237,7 +2237,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_PW_
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_LCK);
 		rtl8192d_PHY_LCCalibrate(padapter);
-		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
 		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
 			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
@@ -2249,20 +2249,20 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_LCK
 			for(j=0;j<10000;j++)
 			{
 				rtw_udelay_os(MAX_STALL_TIME);
-				if(pHalData->rf_type == RF_1T1R)
+				if (pHalData->rf_type == RF_1T1R)
 				{
 					tmpRega = PHY_QueryRFReg(padapter, (enum RF_RADIO_PATH_E)RF_PATH_A, 0x2a, bMaskDWord);
-					if((tmpRega&BIT11)==BIT11)
+					if ((tmpRega&BIT11)==BIT11)
 						break;
 				}
 				else
 				{
 					tmpRega = PHY_QueryRFReg(padapter, (enum RF_RADIO_PATH_E)RF_PATH_A, 0x2a, bMaskDWord);
 					tmpRegb = PHY_QueryRFReg(padapter, (enum RF_RADIO_PATH_E)RF_PATH_B, 0x2a, bMaskDWord);
-					if(((tmpRega&BIT11)==BIT11)&&((tmpRegb&BIT11)==BIT11))
+					if (((tmpRega&BIT11)==BIT11)&&((tmpRegb&BIT11)==BIT11))
 						break;
 					// temply add for DMSP
-					if(pHalData->MacPhyMode92D==DUALMAC_SINGLEPHY&&(pHalData->interfaceIndex!=0))
+					if (pHalData->MacPhyMode92D==DUALMAC_SINGLEPHY&&(pHalData->interfaceIndex!=0))
 						break;
 				}
 			}
@@ -2283,7 +2283,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 
 	{
 		//pHalData->LoopbackMode=LOOPBACK_MODE;
-		//if(padapter->ResetProgress == RESET_TYPE_NORESET)
+		//if (padapter->ResetProgress == RESET_TYPE_NORESET)
 		//{
 		       u32					ulRegRead;
 			//3//
@@ -2293,7 +2293,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 			//	because setting of System_Reset bit reset MAC to default transmission mode.
 			ulRegRead = rtw_read32(padapter, 0x100);	//CPU_GEN  0x100
 
-			//if(pHalData->LoopbackMode == RTL8192SU_NO_LOOPBACK)
+			//if (pHalData->LoopbackMode == RTL8192SU_NO_LOOPBACK)
 			{
 				ulRegRead |= ulRegRead ;
 			}
@@ -2302,7 +2302,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 				//RT_TRACE(COMP_INIT, DBG_LOUD, ("==>start loop back mode %x\n",ulRegRead));
 			//	ulRegRead |= 0x0b000000; //0x0b000000 CPU_CCK_LOOPBACK;
 			//}
-			//else if(pHalData->LoopbackMode == RTL8192SU_DMA_LOOPBACK)
+			//else if (pHalData->LoopbackMode == RTL8192SU_DMA_LOOPBACK)
 			//{
 				//RT_TRACE(COMP_INIT, DBG_LOUD, ("==>start dule mac loop back mode %x\n",ulRegRead));
 			//	ulRegRead |= 0x07000000; //0x07000000 CPU_CCK_LOOPBACK;
@@ -2323,7 +2323,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 	RT_CLEAR_PS_LEVEL(pwrctrlpriv, RT_RF_OFF_LEVL_HALT_NIC);
 
 
-	if((pregistrypriv->lowrate_two_xmit) && (pHalData->MacPhyMode92D != DUALMAC_DUALPHY))
+	if ((pregistrypriv->lowrate_two_xmit) && (pHalData->MacPhyMode92D != DUALMAC_DUALPHY))
 	{
 		//for Use 2 path Tx to transmit MCS0~7 and legacy mode
 		//Reg90C[30]=1'b0 (OFDM TX by Reg, default PHY parameter)
@@ -2362,7 +2362,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END
 _func_exit_;
 
 #ifdef CONFIG_WOWLAN
-	if(padapter->pwrctrlpriv.wowlan_mode == true)
+	if (padapter->pwrctrlpriv.wowlan_mode == true)
 		dump_wakup_reason(padapter);
 	{
 		u16 GPIO_val;
@@ -2447,12 +2447,12 @@ _DisableRF_AFE(
 
 	do
 	{
-		if(rtw_read8(Adapter, REG_APSD_CTRL) & APSDOFF_STATUS){
+		if (rtw_read8(Adapter, REG_APSD_CTRL) & APSDOFF_STATUS){
 			//RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE, AD, DA Done!\n"));
 			break;
 		}
 
-		if(pollingCount++ > POLLING_READY_TIMEOUT_COUNT){
+		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT){
 			//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling APSDOFF_STATUS done!\n"));
 			return _FAIL;
 		}
@@ -2578,9 +2578,9 @@ e.	SYS_FUNC_EN 0x02[7:0] = 0x14		//reset
 	value8 |=( FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
 	rtw_write8(Adapter, REG_SYS_FUNC_EN,value8 );//0x16
 
-	if(pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
+	if (pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
 	{
-		if(pHalData->interfaceIndex!=0){
+		if (pHalData->interfaceIndex!=0){
 			//before BB reset should do clock gated
 			rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 			value8 &=( ~FEN_BB_GLB_RSTn );
@@ -2618,9 +2618,9 @@ _ResetDigitalProcedure1(
 	// 2010/08/12 MH For USB SS, we can not stop 8051 when we are trying to
 	// enter IPS/HW&SW radio off. For S3/S4/S5/Disable, we can stop 8051 because
 	// we will init FW when power on again.
-	if(rtw_read8(Adapter, REG_MCUFWDL) & BIT1) { //IF fw in RAM code, do reset
+	if (rtw_read8(Adapter, REG_MCUFWDL) & BIT1) { //IF fw in RAM code, do reset
 
-		if(Adapter->bFWReady) {
+		if (Adapter->bFWReady) {
 			rtw_write8(Adapter, REG_FSIMR, 0x00);
 			// 2010/08/25 MH Accordign to RD alfred's suggestion, we need to disable other
 			// HRCV INT to influence 8051 reset.
@@ -2650,7 +2650,7 @@ _ResetDigitalProcedure1(
 	#ifdef DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE
 	{
 		u8 val;
-		if( (val=rtw_read8(Adapter, REG_MCUFWDL)))
+		if ( (val=rtw_read8(Adapter, REG_MCUFWDL)))
 			DBG_8192D("DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE %s:%d REG_MCUFWDL:0x%02x\n", __func__, __LINE__, val);
 	}
 	#endif
@@ -2658,7 +2658,7 @@ _ResetDigitalProcedure1(
 	rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x54);	//Reset MAC and Enable 8051
 	rtw_write8(Adapter, REG_MCUFWDL, 0);
 
-	if(bWithoutHWSM){
+	if (bWithoutHWSM){
 	/*****************************
 		Without HW auto state machine
 	g.	SYS_CLKR 0x08[15:0] = 0x30A3			//disable MAC clock
@@ -2703,7 +2703,7 @@ _DisableAnalog(
 	u32 value16 = 0;
 	u8 value8=0;
 
-	if(bWithoutHWSM){
+	if (bWithoutHWSM){
 	/*****************************
 	n.	LDOA15_CTRL 0x20[7:0] = 0x04		// disable A15 power
 	o.	LDOV12D_CTRL 0x21[7:0] = 0x54		// disable digital core power
@@ -2744,13 +2744,13 @@ CanGotoPowerOff92D(
 	struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
 #endif
 
-	if(pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY)
+	if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY)
 		return true;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(BuddyAdapter != NULL)
+	if (BuddyAdapter != NULL)
 	{
-		if(BuddyAdapter->init_adpt_in_progress)
+		if (BuddyAdapter->init_adpt_in_progress)
 		{
 			DBG_8192D("do not power off during another adapter is initialization \n");
 			return false;
@@ -2758,7 +2758,7 @@ CanGotoPowerOff92D(
 	}
 #endif
 
-	if(pHalData->interfaceIndex==0)
+	if (pHalData->interfaceIndex==0)
 	{	// query another mac status;
 		u1bTmp = rtw_read8(Adapter, REG_MAC1);
 		u1bTmp&=MAC1_ON;
@@ -2776,7 +2776,7 @@ CanGotoPowerOff92D(
 
 	rtw_udelay_os(500);
 	// query another mac status;
-	if(pHalData->interfaceIndex==0)
+	if (pHalData->interfaceIndex==0)
 	{	// query another mac status;
 		u1bTmp = rtw_read8(Adapter, REG_MAC1);
 		u1bTmp&=MAC1_ON;
@@ -2787,7 +2787,7 @@ CanGotoPowerOff92D(
 		u1bTmp&=MAC0_ON;
 	}
 	//if another mac is alive,do not do power off
-	if(u1bTmp)
+	if (u1bTmp)
 	{
 		u1bTmp=rtw_read8(Adapter, 0x17);
 		u1bTmp&=(~BIT7);
@@ -2807,7 +2807,7 @@ CardDisableHWSM( // HW Auto state machin
 	int		rtStatus = _SUCCESS;
 	u8		value;
 
-	if(Adapter->bSurpriseRemoved){
+	if (Adapter->bSurpriseRemoved){
 		return rtStatus;
 	}
 
@@ -2817,11 +2817,11 @@ CardDisableHWSM( // HW Auto state machin
 
 	//==== RF Off Sequence ====
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
+	if (!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
 #endif
 		_DisableRFAFEAndResetBB(Adapter);
 
-	if(!PHY_CheckPowerOffFor8192D(Adapter))
+	if (!PHY_CheckPowerOffFor8192D(Adapter))
 		return rtStatus;
 
 	//0x20:value 05-->04
@@ -2858,7 +2858,7 @@ CardDisableWithoutHWSM( // without HW Au
 	int		rtStatus = _SUCCESS;
 	u8		value;
 
-	if(Adapter->bSurpriseRemoved){
+	if (Adapter->bSurpriseRemoved){
 		return rtStatus;
 	}
 
@@ -2868,7 +2868,7 @@ CardDisableWithoutHWSM( // without HW Au
 
 	//==== RF Off Sequence ====
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
+	if (!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
 #endif
 		_DisableRFAFEAndResetBB(Adapter);
 
@@ -2877,7 +2877,7 @@ CardDisableWithoutHWSM( // without HW Au
 	rtw_udelay_os(500);
 	rtw_write8(Adapter,	REG_CR, 0x0);
 
-	if(!PHY_CheckPowerOffFor8192D(Adapter))
+	if (!PHY_CheckPowerOffFor8192D(Adapter))
 	{
 		return rtStatus;
 	}
@@ -2927,7 +2927,7 @@ u32 rtl8192du_hal_deinit(struct rtw_adap
 
 _func_enter_;
 
-	if(RT_IN_PS_LEVEL(pwrpriv, RT_RF_OFF_LEVL_HALT_NIC))
+	if (RT_IN_PS_LEVEL(pwrpriv, RT_RF_OFF_LEVL_HALT_NIC))
 	{
 		DBG_8192D("HaltAdapter8192DUsb(): Not to haltadapter if HW already halt\n");
 		return _FAIL;
@@ -2940,8 +2940,8 @@ _func_enter_;
 
 	rtw_write16(padapter, REG_GPIO_MUXCFG, rtw_read16(padapter, REG_GPIO_MUXCFG)&(~BIT12));
 
-	if(/*Adapter->bInUsbIfTest ||*/ !pHalData->bSupportRemoteWakeUp){
-		if( padapter->bCardDisableWOHSM == false)
+	if (/*Adapter->bInUsbIfTest ||*/ !pHalData->bSupportRemoteWakeUp){
+		if ( padapter->bCardDisableWOHSM == false)
 			CardDisableHWSM(padapter, false);
 		else
 			CardDisableWithoutHWSM(padapter);
@@ -2950,7 +2950,7 @@ _func_enter_;
 		// Wake on WLAN
 	}
 
-	if(pHalData->bInSetPower)
+	if (pHalData->bInSetPower)
 	{
 		//0xFE10[4] clear before suspend	 suggested by zhouzhou
 		u1bTmp=rtw_read8(padapter,0xfe10);
@@ -2996,7 +2996,7 @@ _func_enter_;
 	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
 	for(i=0; i<NR_RECVBUFF; i++)
 	{
-		if(_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == false )
+		if (_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == false )
 		{
 			RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_port error \n"));
 			status = _FAIL;
@@ -3009,7 +3009,7 @@ _func_enter_;
 
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
 	_read_interrupt = pintfhdl->io_ops._read_interrupt;
-	if(_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == false )
+	if (_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == false )
 	{
 		RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_interrupt error \n"));
 		status = _FAIL;
@@ -3054,7 +3054,7 @@ _ReadPROMVersion(
 {
 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
 
-	if(AutoloadFail){
+	if (AutoloadFail){
 		pHalData->EEPROMVersion = EEPROM_Default_Version;
 	}
 	else{
@@ -3073,10 +3073,10 @@ _GetChannelGroup(
 {
 	//RT_ASSERT((channel < 14), ("Channel %d no is supported!\n"));
 
-	if(channel < 3){	// Channel 1~3
+	if (channel < 3){	// Channel 1~3
 		return 0;
 	}
-	else if(channel < 9){ // Channel 4~9
+	else if (channel < 9){ // Channel 4~9
 		return 1;
 	}
 
@@ -3093,7 +3093,7 @@ _ReadIDs(
 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
 
 
-	if(false == AutoloadFail){
+	if (false == AutoloadFail){
 		// VID, PID
 		pHalData->EEPROMVID = le16_to_cpu( *(u16 *)&PROMContent[EEPROM_VID]);
 		pHalData->EEPROMPID = le16_to_cpu( *(u16 *)&PROMContent[EEPROM_PID]);
@@ -3153,8 +3153,8 @@ _ReadMACAddress(
 
 	// Dual MAC should assign diffrent MAC address ,or, it is wil cause hang in single phy mode  zhiyuan 04/07/2010
 	//Temply random assigh mac address for  efuse mac address not ready now
-	if(AutoloadFail == false  ){
-		if(pHalData->interfaceIndex == 0){
+	if (AutoloadFail == false  ){
+		if (pHalData->interfaceIndex == 0){
 			//change to use memcpy, in order to avoid alignment issue. Baron 2011/6/20
 			memcpy(&pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR_MAC0_92D], ETH_ALEN);
 		}
@@ -3163,12 +3163,12 @@ _ReadMACAddress(
 			memcpy(&pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR_MAC1_92D], ETH_ALEN);
 		}
 
-		if(is_broadcast_mac_addr(pEEPROM->mac_addr) || is_multicast_mac_addr(pEEPROM->mac_addr))
+		if (is_broadcast_mac_addr(pEEPROM->mac_addr) || is_multicast_mac_addr(pEEPROM->mac_addr))
 		{
 			//Random assigh MAC address
 			u8 sMacAddr[MAC_ADDR_LEN] = {0x00, 0xE0, 0x4C, 0x81, 0x92, 0x00};
 			//u32	curtime = rtw_get_current_time();
-			if(pHalData->interfaceIndex == 1){
+			if (pHalData->interfaceIndex == 1){
 				sMacAddr[5] = 0x01;
 				//sMacAddr[5] = (u8)(curtime & 0xff);
 				//sMacAddr[5] = (u8)GetRandomNumber(1, 254);
@@ -3181,7 +3181,7 @@ _ReadMACAddress(
 		//Random assigh MAC address
 		u8 sMacAddr[MAC_ADDR_LEN] = {0x00, 0xE0, 0x4C, 0x81, 0x92, 0x00};
 		//u32	curtime = rtw_get_current_time();
-		if(pHalData->interfaceIndex == 1){
+		if (pHalData->interfaceIndex == 1){
 			sMacAddr[5] = 0x01;
 			//sMacAddr[5] = (u8)(curtime & 0xff);
 			//sMacAddr[5] = (u8)GetRandomNumber(1, 254);
@@ -3206,10 +3206,10 @@ hal_ReadMacPhyModeFromPROM92DU(
 
 
 	MacPhyCrValue=PROMContent[EEPROM_ENDPOINT_SETTING];
-	if(MacPhyCrValue & BIT0)
+	if (MacPhyCrValue & BIT0)
 	{
 #ifdef CONFIG_DUALMAC_CONCURRENT
-		if(Adapter->registrypriv.mac_phy_mode == 3)
+		if (Adapter->registrypriv.mac_phy_mode == 3)
 		{
 			pHalData->MacPhyMode92D = DUALMAC_SINGLEPHY;
 			Adapter->DualMacConcurrent = true;
@@ -3224,9 +3224,9 @@ hal_ReadMacPhyModeFromPROM92DU(
 		DBG_8192D("hal_ReadMacPhyModeFromPROM92DU:: MacPhyMode DUALMAC_DUALPHY \n");
 #endif
 
-		if(Adapter->registrypriv.mac_phy_mode == 1)
+		if (Adapter->registrypriv.mac_phy_mode == 1)
 			pHalData->MacPhyMode92D = SINGLEMAC_SINGLEPHY;
-		else	 if(Adapter->registrypriv.mac_phy_mode == 2)
+		else	 if (Adapter->registrypriv.mac_phy_mode == 2)
 			pHalData->MacPhyMode92D = DUALMAC_DUALPHY;
 	}
 	else
@@ -3252,7 +3252,7 @@ hal_ReadMacPhyMode_92D(
 
 
 
-	if(AutoloadFail==true){
+	if (AutoloadFail==true){
 		Mac1EnableValue = rtw_read8(Adapter,0xFE64);
 		PHY_ReadMacPhyMode92D(Adapter, AutoloadFail);
 
@@ -3268,7 +3268,7 @@ hal_ReadMacPhyMode_92D(
 
 //get Dual Mac Mode from 0x2C for test chip and 0xF8 for normal chip
 	ACQUIRE_GLOBAL_MUTEX(GlobalCounterForMutex);
-	if(GlobalFirstConfigurationForNormalChip)
+	if (GlobalFirstConfigurationForNormalChip)
 	{
 		RELEASE_GLOBAL_MUTEX(GlobalCounterForMutex);
 		PHY_ConfigMacPhyMode92D(Adapter);
@@ -3300,7 +3300,7 @@ _ReadBoardType(
 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
 	u8			boardType;
 
-	if(AutoloadFail){
+	if (AutoloadFail){
 		pHalData->rf_type = RF_2T2R;
 		pHalData->BluetoothCoexist = false;
 		return;
@@ -3348,7 +3348,7 @@ _ReadWOWLAN(
 	bool		AutoloadFail
 	)
 {
-	if(AutoloadFail)
+	if (AutoloadFail)
 		Adapter->pwrctrlpriv.bSupportRemoteWakeup = false;
 	else
 	{
@@ -3421,7 +3421,7 @@ static void _ReadPROMContent(
 		}
 
 		//Double check 0x8192 autoload status again
-		if(RTL8192_EEPROM_ID != le16_to_cpu(*((u16 *)PROMContent)))
+		if (RTL8192_EEPROM_ID != le16_to_cpu(*((u16 *)PROMContent)))
 		{
 			pEEPROM->bautoload_fail_flag = true;
 			DBG_8192D("Autoload OK but EEPROM ID content is incorrect!!\n");
@@ -3447,7 +3447,7 @@ _InitOtherVariable(
 {
 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
 
-	//if(Adapter->bInHctTest){
+	//if (Adapter->bInHctTest){
 	//	pMgntInfo->PowerSaveControl.bInactivePs = false;
 	//	pMgntInfo->PowerSaveControl.bIPSModeBackup = false;
 	//	pMgntInfo->PowerSaveControl.bLeisurePs = false;
@@ -3587,19 +3587,19 @@ SelectRTSInitialRate(
 
 
 	psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
-	if(psta == NULL)
+	if (psta == NULL)
 	{
 		return RTSRateIndex;
 	}
 
-	if(psta->rtsen || psta->cts2self)
+	if (psta->rtsen || psta->cts2self)
 		bUseProtection = true;
 
 	memcpy(SupportRateSet, cur_network->SupportedRates, NDIS_802_11_LENGTH_RATES_EX);
 
 	halsetbratecfg( Adapter, SupportRateSet, &BasicRateCfg );
 
-	if( bUseProtection &&
+	if ( bUseProtection &&
 		(!(pmlmeext->cur_wireless_mode == WIRELESS_11A|| pmlmeext->cur_wireless_mode == WIRELESS_11A_5N)))// 5G not support cck rate
 	{
 		// Use CCK rate
@@ -3610,10 +3610,10 @@ SelectRTSInitialRate(
 			RTSRateIndex++;
 		}
 	}
-	else //if(pMgntInfo->pHTInfo->CurrentOpMode)
+	else //if (pMgntInfo->pHTInfo->CurrentOpMode)
 	{
 		//MacId 0: INFRA mode.
-		if((check_fwstate(pmlmepriv, _FW_LINKED)== true)&&(check_fwstate(pmlmepriv, WIFI_STATION_STATE)==true))
+		if ((check_fwstate(pmlmepriv, _FW_LINKED)== true)&&(check_fwstate(pmlmepriv, WIFI_STATION_STATE)==true))
 		{
 			LowestRateIdx = rtw_read8(Adapter, REG_INIDATA_RATE_SEL)&0x3f;
 		}
@@ -3621,40 +3621,40 @@ SelectRTSInitialRate(
 		//Todo: for AP mode and IBSS mode.
 		/*for(i = 0; i < ASSOCIATE_ENTRY_NUM; i++)
 		{
-			if(AsocEntry[i].bUsed && AsocEntry[i].bAssociated)
+			if (AsocEntry[i].bUsed && AsocEntry[i].bAssociated)
 			{
 				//Get the lowest data rate.
-				if(AsocEntry[i].AID != 0)
+				if (AsocEntry[i].AID != 0)
 				{
 					TempRateIdx = rtw_read8(Adapter, REG_INIDATA_RATE_SEL+4*(AsocEntry[i].AID+1));
 					TempRateIdx &= 0x3f; // bit 0-5: rate index
 
-					if(TempRateIdx < LowestRateIdx)
+					if (TempRateIdx < LowestRateIdx)
 						LowestRateIdx = TempRateIdx;
 				}
 			}
 		}*/
 
 		// Adjust RTS Init rate when the data rate is MCS0~2, 8~10 which is lower than 24M.
-		if(LowestRateIdx == 12 || LowestRateIdx == 20) //MCS0, MCS8
+		if (LowestRateIdx == 12 || LowestRateIdx == 20) //MCS0, MCS8
 		{
 			RTSRateIndex = 4; // 6M
 		}
-		else if(LowestRateIdx == 13 || LowestRateIdx == 14 ||
+		else if (LowestRateIdx == 13 || LowestRateIdx == 14 ||
 			LowestRateIdx == 21 || LowestRateIdx == 22) //MCS1, MCS2, MCS9, MCS10
 		{
 			RTSRateIndex = 6; // 12M
 		}
 		else
 		{
-			//if((pmlmeext->cur_wireless_mode == WIRELESS_11BG_24N) &&
+			//if ((pmlmeext->cur_wireless_mode == WIRELESS_11BG_24N) &&
 				//(!pMgntInfo->pHTInfo->bCurSuppCCK) &&
 			//	(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40))
 			//{
 			//	BasicRateCfg &= 0xfff0; //disable CCK
 			//}
 
-			if(BasicRateCfg != 0)
+			if (BasicRateCfg != 0)
 			{
 				// Select RTS Init rate
 				while(BasicRateCfg > 0x1)
@@ -3693,7 +3693,7 @@ SetRTSRateWorkItemCallback(
 	u8	NewRTSInitRate = 0;
 
 	NewRTSInitRate = SelectRTSInitialRate(Adapter);
-	if(NewRTSInitRate != pHalData->RTSInitRate)
+	if (NewRTSInitRate != pHalData->RTSInitRate)
 	{
 		rtw_write8(Adapter, REG_INIRTS_RATE_SEL, NewRTSInitRate);
 		pHalData->RTSInitRate = NewRTSInitRate;
@@ -3709,7 +3709,7 @@ static void hw_var_set_opmode(struct rtw
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(Adapter->iface_type == IFACE_PORT1)
+	if (Adapter->iface_type == IFACE_PORT1)
 	{
 		// disable Port1 TSF update
 		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
@@ -3724,9 +3724,9 @@ static void hw_var_set_opmode(struct rtw
 
 		DBG_8192D("%s()-%d mode = %d\n", __func__, __LINE__, mode);
 
-		if((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
+		if ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
 		{
-			if(!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
+			if (!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
 			{
 				StopTxBeacon(Adapter);
 			}
@@ -3734,12 +3734,12 @@ static void hw_var_set_opmode(struct rtw
 			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x19);//disable atim wnd
 			//rtw_write8(Adapter,REG_BCN_CTRL_1, 0x18);
 		}
-		else if((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
+		else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
 		{
 			ResumeTxBeacon(Adapter);
 			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x1a);
 		}
-		else if(mode == _HW_STATE_AP_)
+		else if (mode == _HW_STATE_AP_)
 		{
 			ResumeTxBeacon(Adapter);
 
@@ -3769,7 +3769,7 @@ static void hw_var_set_opmode(struct rtw
 
 			DBG_8192D("%s()-%d: REG_BCN_CTRL_1 = %02x\n", __func__, __LINE__, rtw_read8(Adapter, REG_BCN_CTRL_1));
 
-			if(check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
+			if (check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
 				rtw_write8(Adapter, REG_BCN_CTRL,
 					rtw_read8(Adapter, REG_BCN_CTRL) & ~EN_BCN_FUNCTION);
 
@@ -3802,10 +3802,10 @@ static void hw_var_set_opmode(struct rtw
 
 		DBG_8192D("%s()-%d mode = %d\n", __func__, __LINE__, mode);
 
-		if((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
+		if ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
 		{
 #ifdef CONFIG_CONCURRENT_MODE
-			if(!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
+			if (!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
 #endif //CONFIG_CONCURRENT_MODE
 			{
 				StopTxBeacon(Adapter);
@@ -3814,12 +3814,12 @@ static void hw_var_set_opmode(struct rtw
 			rtw_write8(Adapter,REG_BCN_CTRL, 0x19);//disable atim wnd
 			//rtw_write8(Adapter,REG_BCN_CTRL, 0x18);
 		}
-		else if((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
+		else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
 		{
 			ResumeTxBeacon(Adapter);
 			rtw_write8(Adapter,REG_BCN_CTRL, 0x1a);
 		}
-		else if(mode == _HW_STATE_AP_)
+		else if (mode == _HW_STATE_AP_)
 		{
 			ResumeTxBeacon(Adapter);
 
@@ -3849,7 +3849,7 @@ static void hw_var_set_opmode(struct rtw
 			rtw_write8(Adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
 
 #ifdef CONFIG_CONCURRENT_MODE
-			if(check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
+			if (check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
 				rtw_write8(Adapter, REG_BCN_CTRL_1,
 					rtw_read8(Adapter, REG_BCN_CTRL_1) & ~EN_BCN_FUNCTION);
 
@@ -3875,7 +3875,7 @@ static void hw_var_set_macaddr(struct rt
 	u32 reg_macid;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(Adapter->iface_type == IFACE_PORT1)
+	if (Adapter->iface_type == IFACE_PORT1)
 	{
 		reg_macid = REG_MACID1;
 	}
@@ -3898,7 +3898,7 @@ static void hw_var_set_bssid(struct rtw_
 	u32 reg_bssid;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(Adapter->iface_type == IFACE_PORT1)
+	if (Adapter->iface_type == IFACE_PORT1)
 	{
 		reg_bssid = REG_BSSID1;
 	}
@@ -3920,11 +3920,11 @@ static void hw_var_set_bcn_func(struct r
 	u32 bcn_ctrl_reg;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(Adapter->iface_type == IFACE_PORT1)
+	if (Adapter->iface_type == IFACE_PORT1)
 	{
 		bcn_ctrl_reg = REG_BCN_CTRL_1;
 
-		if(*((u8 *)val))
+		if (*((u8 *)val))
 		{
 			rtw_write8(Adapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
 		}
@@ -3937,7 +3937,7 @@ static void hw_var_set_bcn_func(struct r
 #endif
 	{
 		bcn_ctrl_reg = REG_BCN_CTRL;
-		if(*((u8 *)val))
+		if (*((u8 *)val))
 		{
 			rtw_write8(Adapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
 		}
@@ -3960,14 +3960,14 @@ static void hw_var_set_correct_tsf(struc
 	//tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
 	tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
 
-	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 	{
 		//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
 		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
 		StopTxBeacon(Adapter);
 	}
 
-	if(Adapter->iface_type == IFACE_PORT1)
+	if (Adapter->iface_type == IFACE_PORT1)
 	{
 		//disable related TSF function
 		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
@@ -4032,7 +4032,7 @@ static void hw_var_set_correct_tsf(struc
 	}
 
 
-	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 	{
 		//pHalData->RegTxPause  &= (~STOP_BCNQ);
 		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)&(~BIT(6))));
@@ -4049,11 +4049,11 @@ static void hw_var_set_mlme_disconnect(s
 	struct rtw_adapter * pbuddy_adapter = Adapter->pbuddy_adapter;
 
 
-	if(check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))
+	if (check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))
 		rtw_write16(Adapter, REG_RXFLTMAP2, 0x00);
 
 
-	if(Adapter->iface_type == IFACE_PORT1)
+	if (Adapter->iface_type == IFACE_PORT1)
 	{
 		int i;
 		u8 reg_bcn_ctrl_1;
@@ -4122,7 +4122,7 @@ static void hw_var_set_mlme_disconnect(s
 		pHalData->RegFwHwTxQCtrl |= BIT6;
 
 		// k. re_download beacon pkt
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
+		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
 			set_tx_beacon_cmd(pbuddy_adapter);
 
 
@@ -4149,7 +4149,7 @@ static void hw_var_set_mlme_sitesurvey(s
 
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(Adapter->iface_type == IFACE_PORT1)
+	if (Adapter->iface_type == IFACE_PORT1)
 		reg_bcn_ctl = REG_BCN_CTRL_1;
 	else
 #endif
@@ -4157,7 +4157,7 @@ static void hw_var_set_mlme_sitesurvey(s
 
 #ifdef CONFIG_FIND_BEST_CHANNEL
 
-	if( (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	if ( (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 #ifdef CONFIG_CONCURRENT_MODE
 		|| (check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true)
 #endif
@@ -4188,7 +4188,7 @@ static void hw_var_set_mlme_sitesurvey(s
 
 	value_rcr = rtw_read32(Adapter, REG_RCR);
 
-	if(*((u8 *)val))//under sitesurvey
+	if (*((u8 *)val))//under sitesurvey
 	{
 		pHalData->bLoadIMRandIQKSettingFor2G = false;
 
@@ -4206,7 +4206,7 @@ static void hw_var_set_mlme_sitesurvey(s
 		pHalData->RegRRSR = rtw_read16(Adapter, REG_RRSR);
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 			check_buddy_fwstate(Adapter, _FW_LINKED))
 		{
 			StopTxBeacon(Adapter);
@@ -4215,7 +4215,7 @@ static void hw_var_set_mlme_sitesurvey(s
 	}
 	else//sitesurvey done
 	{
-		if(check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pmlmepriv, WIFI_AP_STATE)
+		if (check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pmlmepriv, WIFI_AP_STATE)
 #ifdef CONFIG_CONCURRENT_MODE
 			|| check_buddy_fwstate(Adapter, _FW_LINKED) || check_buddy_fwstate(Adapter, WIFI_AP_STATE)
 #endif
@@ -4237,7 +4237,7 @@ static void hw_var_set_mlme_sitesurvey(s
 		rtw_write16(Adapter, REG_RRSR, pHalData->RegRRSR);
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 			check_buddy_fwstate(Adapter, _FW_LINKED))
 		{
 			ResumeTxBeacon(Adapter);
@@ -4254,9 +4254,9 @@ static void hw_var_set_mlme_join(struct
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
 
-	if(type == 0) // prepare to join
+	if (type == 0) // prepare to join
 	{
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 			check_buddy_fwstate(Adapter, _FW_LINKED))
 		{
 			StopTxBeacon(Adapter);
@@ -4266,12 +4266,12 @@ static void hw_var_set_mlme_join(struct
 		//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
 		rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
 
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
+		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
 			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_BCN);
 		else
 			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
 
-		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 		{
 			RetryLimit = (pHalData->CustomerID == RT_CID_CCX) ? 7 : 48;
 		}
@@ -4283,28 +4283,28 @@ static void hw_var_set_mlme_join(struct
 		DBG_8192D("%s(): pHalData->bNeedIQK = true\n",__func__);
 		pHalData->bNeedIQK = true; //for 92D IQK
 	}
-	else if(type == 1) //joinbss_event call back when join res < 0
+	else if (type == 1) //joinbss_event call back when join res < 0
 	{
-		if(check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))
+		if (check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))
 			rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
 
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 			check_buddy_fwstate(Adapter, _FW_LINKED))
 		{
 			ResumeTxBeacon(Adapter);
 		}
 	}
-	else if(type == 2) //sta add event call back
+	else if (type == 2) //sta add event call back
 	{
 
 		//enable update TSF
-		if(Adapter->iface_type == IFACE_PORT1)
+		if (Adapter->iface_type == IFACE_PORT1)
 			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
 		else
 			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
 
 
-		if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
+		if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
 		{
 			//fixed beacon issue for 8191su...........
 			rtw_write8(Adapter,0x542 ,0x02);
@@ -4312,7 +4312,7 @@ static void hw_var_set_mlme_join(struct
 		}
 
 
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 			check_buddy_fwstate(Adapter, _FW_LINKED))
 		{
 			ResumeTxBeacon(Adapter);
@@ -4333,15 +4333,15 @@ static void dc_hw_var_mlme_sitesurvey(st
 	struct mlme_priv *pbuddy_mlmepriv;
 	struct mlme_ext_priv *pbuddy_mlmeext;
 
-	if((BuddyAdapter !=NULL) &&
+	if ((BuddyAdapter !=NULL) &&
 		Adapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(BuddyAdapter->mlmepriv);
 		pbuddy_mlmeext = &BuddyAdapter->mlmeextpriv;
 
-		if(sitesurvey_state)//under sitesurvey
+		if (sitesurvey_state)//under sitesurvey
 		{
-			if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+			if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 				check_buddy_fwstate(Adapter, _FW_LINKED))
 			{
 				StopTxBeacon(BuddyAdapter);
@@ -4351,7 +4351,7 @@ static void dc_hw_var_mlme_sitesurvey(st
 		}
 		else//sitesurvey done
 		{
-			if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+			if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 				check_buddy_fwstate(Adapter, _FW_LINKED))
 			{
 				ResumeTxBeacon(BuddyAdapter);
@@ -4370,19 +4370,19 @@ static void dc_hw_var_mlme_join(struct r
 	struct mlme_ext_priv *pbuddy_mlmeext;
 
 
-	if((BuddyAdapter !=NULL) &&
+	if ((BuddyAdapter !=NULL) &&
 		Adapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(BuddyAdapter->mlmepriv);
 		pbuddy_mlmeext = &BuddyAdapter->mlmeextpriv;
 
-		if(pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel ||
+		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel ||
 			pmlmeext->cur_bwmode != pbuddy_mlmeext->cur_bwmode ||
 			pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset)
 		{
-			if(join_state == 0)// prepare to join
+			if (join_state == 0)// prepare to join
 			{
-				if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+				if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 					check_buddy_fwstate(Adapter, _FW_LINKED))
 				{
 					StopTxBeacon(BuddyAdapter);
@@ -4390,7 +4390,7 @@ static void dc_hw_var_mlme_join(struct r
 			}
 			else//join success or fail
 			{
-				if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
+				if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 					check_buddy_fwstate(Adapter, _FW_LINKED))
 				{
 					ResumeTxBeacon(BuddyAdapter);
@@ -4437,17 +4437,17 @@ _func_enter_;
 				u8	val8;
 				u8	mode = *((u8 *)val);
 
-				if((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
+				if ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
 				{
 					StopTxBeacon(Adapter);
 					rtw_write8(Adapter,REG_BCN_CTRL, 0x18);
 				}
-				else if((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
+				else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
 				{
 					ResumeTxBeacon(Adapter);
 					rtw_write8(Adapter,REG_BCN_CTRL, 0x1a);
 				}
-				else if(mode == _HW_STATE_AP_)
+				else if (mode == _HW_STATE_AP_)
 				{
 					ResumeTxBeacon(Adapter);
 
@@ -4505,15 +4505,15 @@ _func_enter_;
 #ifdef CONFIG_DUALMAC_CONCURRENT
 				struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
 #endif
-				if(check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE) == true)
+				if (check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE) == true)
 				{
 					DBG_8192D("%s(): pHalData->bNeedIQK = true\n",__func__);
 					pHalData->bNeedIQK = true; //for 92D IQK
 				}
 #ifdef CONFIG_DUALMAC_CONCURRENT
-				if((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
+				if ((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
 				{
-					if(check_fwstate(&BuddyAdapter->mlmepriv, WIFI_AP_STATE) == true)
+					if (check_fwstate(&BuddyAdapter->mlmepriv, WIFI_AP_STATE) == true)
 						GET_HAL_DATA(BuddyAdapter)->bNeedIQK = true; //for 92D IQK
 				}
 #endif
@@ -4523,7 +4523,7 @@ _func_enter_;
 			{
 				u8	init_data_rate = *((u8 *)val);
 #ifdef CONFIG_CONCURRENT_MODE
-				if(SECONDARY_ADAPTER == Adapter->adapter_type) {
+				if (SECONDARY_ADAPTER == Adapter->adapter_type) {
 					rtw_write8(Adapter, REG_INIDATA_RATE_SEL+2, init_data_rate);
 					pdmpriv->INIDATA_RATE[2] = init_data_rate;
 					DBG_8192D("HW_VAR_INIT_DATA_RATE: Set Init Data Rate(%#x) for MACID 2\n", rtw_read8(Adapter, REG_INIDATA_RATE_SEL));
@@ -4549,12 +4549,12 @@ _func_enter_;
 				// We do not use other rates.
 				halsetbratecfg( Adapter, val, &BrateCfg );
 
-				if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
+				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 					b2GBand = true;
 				else
 					b2GBand = false;
 
-				if(b2GBand)
+				if (b2GBand)
 				{
 					//CCK 2M ACK should be disabled for some BCM and Atheros AP IOT
 					//because CCK 2M has poor TXEVM
@@ -4575,7 +4575,7 @@ _func_enter_;
 				rtw_write8(Adapter, REG_RRSR+1, (BrateCfg>>8)&0xff);
 				rtw_write8(Adapter, REG_RRSR+2, rtw_read8(Adapter, REG_RRSR+2)&0xf0);
 
-				//if(pHalData->FirmwareVersion > 0xe)
+				//if (pHalData->FirmwareVersion > 0xe)
 				//{
 				//	SetRTSRateWorkItemCallback(Adapter);
 				//}
@@ -4598,7 +4598,7 @@ _func_enter_;
 #if 1
 			hw_var_set_bcn_func(Adapter, variable, val);
 #else
-			if(*((u8 *)val))
+			if (*((u8 *)val))
 			{
 				rtw_write8(Adapter, REG_BCN_CTRL, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
 			}
@@ -4620,7 +4620,7 @@ _func_enter_;
 				//tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
 				tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
 
-				if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+				if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 				{
 					//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
 					//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
@@ -4637,7 +4637,7 @@ _func_enter_;
 				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
 
 
-				if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+				if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 				{
 					//pHalData->RegTxPause  &= (~STOP_BCNQ);
 					//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)&(~BIT(6))));
@@ -4647,7 +4647,7 @@ _func_enter_;
 #endif //CONFIG_CONCURRENT_MODE
 			break;
 		case HW_VAR_CHECK_BSSID:
-			if(*((u8 *)val))
+			if (*((u8 *)val))
 			{
 				rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
 			}
@@ -4697,7 +4697,7 @@ _func_enter_;
 				struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
 #endif
 
-				if(type == 0) // prepare to join
+				if (type == 0) // prepare to join
 				{
 					//enable to rx data frame.Accept all data frame
 					//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
@@ -4705,7 +4705,7 @@ _func_enter_;
 
 					rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
 
-					if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+					if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 					{
 						RetryLimit = (pHalData->CustomerID == RT_CID_CCX) ? 7 : 48;
 					}
@@ -4717,13 +4717,13 @@ _func_enter_;
 					DBG_8192D("%s(): pHalData->bNeedIQK = true\n",__func__);
 					pHalData->bNeedIQK = true; //for 92D IQK
 #ifdef CONFIG_DUALMAC_CONCURRENT
-					if((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
+					if ((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
 					{
 						GET_HAL_DATA(BuddyAdapter)->bNeedIQK = true; //for 92D IQK
 					}
 #endif
 				}
-				else if(type == 1) //joinbss_event call back when join res < 0
+				else if (type == 1) //joinbss_event call back when join res < 0
 				{
 					//config RCR to receive different BSSID & not to receive data frame during linking
 					//u32 v = rtw_read32(Adapter, REG_RCR);
@@ -4732,12 +4732,12 @@ _func_enter_;
 
 					rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
 				}
-				else if(type == 2) //sta add event call back
+				else if (type == 2) //sta add event call back
 				{
 					//enable update TSF
 					rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
 
-					if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
+					if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
 					{
 						//fixed beacon issue for 8191su...........
 						//rtw_write8(Adapter,0x542 ,0x02);
@@ -4774,9 +4774,9 @@ _func_enter_;
 				DBG_8192D("Set HW_VAR_SLOT_TIME: SlotTime(%#x)\n", val[0]);
 				rtw_write8(Adapter, REG_SLOT, val[0]);
 
-				if(pmlmeinfo->WMM_enable == 0)
+				if (pmlmeinfo->WMM_enable == 0)
 				{
-					if(pmlmeext->cur_wireless_mode == WIRELESS_11B)
+					if (pmlmeext->cur_wireless_mode == WIRELESS_11B)
 						aSifsTime = 10;
 					else
 						aSifsTime = 16;
@@ -4798,7 +4798,7 @@ _func_enter_;
 				// Joseph marked out for Netgear 3500 TKIP channel 7 issue.(Temporarily)
 				regTmp = (pHalData->nCur40MhzPrimeSC)<<5;
 				//regTmp = 0;
-				if(bShortPreamble)
+				if (bShortPreamble)
 					regTmp |= 0x80;
 
 				rtw_write8(Adapter, REG_RRSR+2, regTmp);
@@ -4815,7 +4815,7 @@ _func_enter_;
 			pdmpriv->DMFlag = *((u8 *)val);
 			break;
 		case HW_VAR_DM_FUNC_OP:
-			if(val[0])
+			if (val[0])
 			{// save dm flag
 				pdmpriv->DMFlag_tmp = pdmpriv->DMFlag;
 			}
@@ -4844,7 +4844,7 @@ _func_enter_;
 				for(i=0;i<CAM_CONTENT_COUNT;i++)
 				{
 					// filled id in CAM config 2 byte
-					if( i == 0)
+					if ( i == 0)
 					{
 						ulContent |=(ucIndex & 0x03) | ((u16)(ulEncAlgo)<<2);
 						//ulContent |= CAM_VALID;
@@ -4895,20 +4895,20 @@ _func_enter_;
 				u8	acm_ctrl = *((u8 *)val);
 				u8	AcmCtrl = rtw_read8( Adapter, REG_ACMHWCTRL);
 
-				if(acm_ctrl > 1)
+				if (acm_ctrl > 1)
 					AcmCtrl = AcmCtrl | 0x1;
 
-				if(acm_ctrl & BIT(3))
+				if (acm_ctrl & BIT(3))
 					AcmCtrl |= AcmHw_VoqEn;
 				else
 					AcmCtrl &= (~AcmHw_VoqEn);
 
-				if(acm_ctrl & BIT(2))
+				if (acm_ctrl & BIT(2))
 					AcmCtrl |= AcmHw_ViqEn;
 				else
 					AcmCtrl &= (~AcmHw_ViqEn);
 
-				if(acm_ctrl & BIT(1))
+				if (acm_ctrl & BIT(1))
 					AcmCtrl |= AcmHw_BeqEn;
 				else
 					AcmCtrl &= (~AcmHw_BeqEn);
@@ -4923,7 +4923,7 @@ _func_enter_;
 				u8	SecMinSpace;
 
 				MinSpacingToSet = *((u8 *)val);
-				if(MinSpacingToSet <= 7)
+				if (MinSpacingToSet <= 7)
 				{
 					switch(Adapter->securitypriv.dot11PrivacyAlgrthm)
 					{
@@ -4943,7 +4943,7 @@ _func_enter_;
 							break;
 					}
 
-					if(MinSpacingToSet < SecMinSpace){
+					if (MinSpacingToSet < SecMinSpace){
 						MinSpacingToSet = SecMinSpace;
 					}
 
@@ -4960,31 +4960,31 @@ _func_enter_;
 				u8	index = 0;
 
 				RegToSet = 0xb972a841;
-				if(pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY){
+				if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY){
 					RegToSet = 0x88728841;
 				}
-				else if(pHalData->MacPhyMode92D==DUALMAC_DUALPHY){
+				else if (pHalData->MacPhyMode92D==DUALMAC_DUALPHY){
 					RegToSet = 0x66525541;
 				}
-				else if(pHalData->MacPhyMode92D==DUALMAC_SINGLEPHY){
+				else if (pHalData->MacPhyMode92D==DUALMAC_SINGLEPHY){
 					RegToSet = 0x44444441;
 				}
 
 				FactorToSet = *((u8 *)val);
-				if(FactorToSet <= 3)
+				if (FactorToSet <= 3)
 				{
 					FactorToSet = (1<<(FactorToSet + 2));
-					if(FactorToSet>0xf)
+					if (FactorToSet>0xf)
 						FactorToSet = 0xf;
 
 					for(index=0; index<4; index++)
 					{
 						pTmpByte = (u8 *)(&RegToSet) + index;
 
-						if((*pTmpByte & 0xf0) > (FactorToSet<<4))
+						if ((*pTmpByte & 0xf0) > (FactorToSet<<4))
 							*pTmpByte = (*pTmpByte & 0x0f) | (FactorToSet<<4);
 
-						if((*pTmpByte & 0x0f) > FactorToSet)
+						if ((*pTmpByte & 0x0f) > FactorToSet)
 							*pTmpByte = (*pTmpByte & 0xf0) | (FactorToSet);
 					}
 
@@ -4997,7 +4997,7 @@ _func_enter_;
 			#ifdef CONFIG_USB_RX_AGGREGATION
 			{
 				u8	threshold = *((u8 *)val);
-				if( threshold == 0)
+				if ( threshold == 0)
 				{
 					threshold = pHalData->UsbRxAggPageCount;
 				}
@@ -5010,7 +5010,7 @@ _func_enter_;
 				u8	RpwmVal = (*(u8 *)val);
 				RpwmVal = RpwmVal & 0xf;
 
-				/*if(pHalData->PreRpwmVal & BIT7) //bit7: 1
+				/*if (pHalData->PreRpwmVal & BIT7) //bit7: 1
 				{
 					PlatformEFIOWrite1Byte(Adapter, REG_USB_HRPWM, (*(pu1Byte)val));
 					pHalData->PreRpwmVal = (*(pu1Byte)val);
@@ -5066,7 +5066,7 @@ _func_enter_;
 				struct DIG_T *dig_table = &pdmpriv->DM_DigTable;
 				u32		rx_gain = ((u32 *)(val))[0];
 
-				if(rx_gain == 0xff){//restore rx gain
+				if (rx_gain == 0xff){//restore rx gain
 					dig_table->curigvalue = dig_table->backupigvalue;
 					PHY_SetBBReg(Adapter, rOFDM0_XAAGCCore1, 0x7f,dig_table->curigvalue );
 					PHY_SetBBReg(Adapter, rOFDM0_XBAGCCore1, 0x7f,dig_table->curigvalue);
@@ -5099,15 +5099,15 @@ _func_enter_;
 				//keep sn
 				Adapter->xmitpriv.nqos_ssn = rtw_read16(Adapter,REG_NQOS_SEQ);
 
-				if(pwrpriv->bkeepfwalive != true)
+				if (pwrpriv->bkeepfwalive != true)
 				{
 					//RX DMA stop
 					rtw_write32(Adapter,REG_RXPKT_NUM,(rtw_read32(Adapter,REG_RXPKT_NUM)|RW_RELEASE_EN));
 					do{
-						if(!(rtw_read32(Adapter,REG_RXPKT_NUM)&RXDMA_IDLE))
+						if (!(rtw_read32(Adapter,REG_RXPKT_NUM)&RXDMA_IDLE))
 							break;
 					}while(trycnt--);
-					if(trycnt ==0)
+					if (trycnt ==0)
 						DBG_8192D("Stop RX DMA failed...... \n");
 
 					//RQPN Load 0
@@ -5130,7 +5130,7 @@ _func_enter_;
 					case WOWLAN_PATTERN_MATCH:
 						//Turn on the Pattern Match feature
 						DBG_8192D("\n PATTERN_MATCH poidparam->subcode_value=%d\n",poidparam->subcode_value);
-						if(poidparam->subcode_value==1){
+						if (poidparam->subcode_value==1){
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(1)));
 							Adapter->pwrctrlpriv.wowlan_pattern=true;
 							DBG_8192D("%s Adapter->pwrctrlpriv.wowlan_pattern=%x\n",__func__,Adapter->pwrctrlpriv.wowlan_pattern);
@@ -5143,7 +5143,7 @@ _func_enter_;
 					case WOWLAN_MAGIC_PACKET:
 						//Turn on the Magic Packet feature
 						DBG_8192D("\n MAGIC_PACKET poidparam->subcode_value=%d\n",poidparam->subcode_value);
-						if(poidparam->subcode_value==1){
+						if (poidparam->subcode_value==1){
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(2)));
 							Adapter->pwrctrlpriv.wowlan_magic=true;
 							DBG_8192D("%s Adapter->pwrctrlpriv.wowlan_magic=%x\n",__func__,Adapter->pwrctrlpriv.wowlan_magic);
@@ -5155,7 +5155,7 @@ _func_enter_;
 						break;
 					case WOWLAN_UNICAST:
 						//Turn on the Unicast wakeup feature
-						if(poidparam->subcode_value==1){
+						if (poidparam->subcode_value==1){
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(3)));
 							Adapter->pwrctrlpriv.wowlan_unicast=true;
 						}
@@ -5168,7 +5168,7 @@ _func_enter_;
 					case WOWLAN_SET_PATTERN:
 						//Setting the Pattern for wowlan
 						res=rtw_wowlan_set_pattern(Adapter,poidparam->pattern);
-						if(res)
+						if (res)
 							DBG_8192D("rtw_wowlan_set_pattern retern value=0x%x",res);
 						break;
 					case WOWLAN_DUMP_REG:
@@ -5188,13 +5188,13 @@ _func_enter_;
 					case WOWLAN_ENABLE:
 						SetFwRelatedForWoWLAN8192DU(Adapter, true);
 						//Set Pattern
-						if(Adapter->pwrctrlpriv.wowlan_pattern==true)
+						if (Adapter->pwrctrlpriv.wowlan_pattern==true)
 							rtw_wowlan_reload_pattern(Adapter);
 						rtl8192d_set_wowlan_cmd(Adapter);
 						//rtw_write8(Adapter, 0x6, rtw_read8(Adapter, 0x6)|BIT(3));
 						rtw_msleep_os(10);
 						//DBG_8192D(" \n REG_WOW_CTRL=0x%x \n",rtw_read8(Adapter, REG_WOW_CTRL));
-//						if(rtw_read8(Adapter, REG_WOW_CTRL)==0)
+//						if (rtw_read8(Adapter, REG_WOW_CTRL)==0)
 //							rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(1)|BIT(2)|BIT(3)));
 						//DBG_8192D(" \n REG_WOW_CTRL=0x%x \n",rtw_read8(Adapter, REG_WOW_CTRL));
 						break;
@@ -5215,7 +5215,7 @@ _func_enter_;
 						/*
 						SetFwRelatedForWoWLAN8192DU(Adapter, true);
 						//Set Pattern
-						if(Adapter->pwrctrlpriv.wowlan_pattern==true)
+						if (Adapter->pwrctrlpriv.wowlan_pattern==true)
 							rtw_wowlan_reload_pattern(Adapter);
 						rtl8192d_set_wowlan_cmd(Adapter);
 						rtw_write8(Adapter, 0x6, rtw_read8(Adapter, 0x6)|BIT(3));
@@ -5225,7 +5225,7 @@ _func_enter_;
 					case WOWLAN_DEBUG_1:
 						{
 							u16 GPIO_val;
-							if(poidparam->subcode_value==1)
+							if (poidparam->subcode_value==1)
 							{
 								GPIO_val = rtw_read16(Adapter, REG_GPIO_PIN_CTRL+1);
 								GPIO_val |= BIT(0)|BIT(8);
@@ -5247,7 +5247,7 @@ _func_enter_;
 							u16 GPIO_val;
 							u8 reg=0;
 #ifdef CONFIG_WOWLAN_MANUAL
-							if(poidparam->subcode_value==1)
+							if (poidparam->subcode_value==1)
 							{
 
 								//prevent 8051 to be reset by PERST# wake on wlan by Alex & Baron
@@ -5296,7 +5296,7 @@ _func_enter_;
 
 				for(i=0;i<1000;i++)
 				{
-					if(rtw_read32(Adapter, 0x200) != rtw_read32(Adapter, 0x204))
+					if (rtw_read32(Adapter, 0x200) != rtw_read32(Adapter, 0x204))
 					{
 						//DBG_8192D("packet in tx packet buffer - 0x204=%x, 0x200=%x (%d)\n", rtw_read32(Adapter, 0x204), rtw_read32(Adapter, 0x200), i);
 						rtw_msleep_os(10);
@@ -5355,7 +5355,7 @@ _func_enter_;
 				//When we halt NIC, we should check if FW LPS is leave.
 				u32	valRCR;
 
-				if(Adapter->pwrctrlpriv.rf_pwrstate == rf_off)
+				if (Adapter->pwrctrlpriv.rf_pwrstate == rf_off)
 				{
 					// If it is in HW/SW Radio OFF or IPS state, we do not check Fw LPS Leave,
 					// because Fw is unload.
@@ -5365,7 +5365,7 @@ _func_enter_;
 				{
 					valRCR = rtw_read32(Adapter, REG_RCR);
 					valRCR &= 0x00070000;
-					if(valRCR)
+					if (valRCR)
 						val[0] = false;
 					else
 						val[0] = true;
@@ -5446,29 +5446,29 @@ SetHalDefVar8192DUsb(
 				u8 dm_func = *(( u8*)pValue);
 				struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
-				if(dm_func == 0){ //disable all dynamic func
+				if (dm_func == 0){ //disable all dynamic func
 					pdmpriv->DMFlag = DYNAMIC_FUNC_DISABLE;
 					DBG_8192D("==> Disable all dynamic function...\n");
 				}
-				else if(dm_func == 1){//disable DIG
+				else if (dm_func == 1){//disable DIG
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_DIG);
 					DBG_8192D("==> Disable DIG...\n");
 				}
-				else if(dm_func == 2){//disable High power
+				else if (dm_func == 2){//disable High power
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_HP);
 				}
-				else if(dm_func == 3){//disable tx power tracking
+				else if (dm_func == 3){//disable tx power tracking
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_SS);
 					DBG_8192D("==> Disable tx power tracking...\n");
 				}
-				else if(dm_func == 4){//disable BT coexistence
+				else if (dm_func == 4){//disable BT coexistence
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_BT);
 				}
-				else if(dm_func == 5){//disable antenna diversity
+				else if (dm_func == 5){//disable antenna diversity
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_ANT_DIV);
 				}
-				else if(dm_func == 6){//turn on all dynamic func
-					if(!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
+				else if (dm_func == 6){//turn on all dynamic func
+					if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
 					{
 						struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 						struct DIG_T	*dig_table = &pdmpriv->DM_DigTable;
@@ -5499,7 +5499,7 @@ u32  _update_92cu_basic_rate(struct rtw_
 	unsigned int BrateCfg = 0;
 
 #ifdef CONFIG_BT_COEXIST
-	if(	(pbtpriv->BT_Coexist) &&	(pbtpriv->BT_CoexistType == BT_CSR_BC4)	)
+	if (	(pbtpriv->BT_Coexist) &&	(pbtpriv->BT_CoexistType == BT_CSR_BC4)	)
 	{
 		BrateCfg = mask  & 0x151;
 		//DBG_8192D("BT temp disable cck 2/5.5/11M, (0x%x = 0x%x)\n", REG_RRSR, BrateCfg & 0x151);
@@ -5507,7 +5507,7 @@ u32  _update_92cu_basic_rate(struct rtw_
 	else
 #endif
 	{
-		if(pHalData->VersionID != VERSION_TEST_CHIP_88C)
+		if (pHalData->VersionID != VERSION_TEST_CHIP_88C)
 			BrateCfg = mask  & 0x15F;
 		else	//for 88CU 46PING setting, Disable CCK 2M, 5.5M, Others must tuning
 			BrateCfg = mask  & 0x159;
@@ -5561,7 +5561,7 @@ void UpdateHalRAMask8192DUsb(struct rtw_
 	}
 
 	psta = pmlmeinfo->FW_sta_info[mac_id].psta;
-	if(psta == NULL)
+	if (psta == NULL)
 	{
 		return;
 	}
@@ -5591,7 +5591,7 @@ void UpdateHalRAMask8192DUsb(struct rtw_
 
 		case 1://for broadcast/multicast
 			supportRateNum = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[mac_id].SupportedRates);
-			if(pmlmeext->cur_wireless_mode & WIRELESS_11B)
+			if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
 				networkType = WIRELESS_11B;
 			else
 				networkType = WIRELESS_11G;
@@ -5604,7 +5604,7 @@ void UpdateHalRAMask8192DUsb(struct rtw_
 
 		default: //for each sta in IBSS
 #ifdef CONFIG_TDLS
-			if(psta->tdls_sta_state & TDLS_LINKED_STATE)
+			if (psta->tdls_sta_state & TDLS_LINKED_STATE)
 			{
 				shortGIrate = update_sgi_tdls(padapter, psta);
 				mask = update_mask_tdls(padapter, psta);
@@ -5629,7 +5629,7 @@ void UpdateHalRAMask8192DUsb(struct rtw_
 	}
 
 #ifdef CONFIG_BT_COEXIST
-	if( (pbtpriv->BT_Coexist) &&
+	if ( (pbtpriv->BT_Coexist) &&
 		(pbtpriv->BT_CoexistType == BT_CSR_BC4) &&
 		(pbtpriv->BT_CUR_State) &&
 		(pbtpriv->BT_Ant_isolation) &&
@@ -5643,7 +5643,7 @@ void UpdateHalRAMask8192DUsb(struct rtw_
 
 	init_rate = get_highest_rate_idx(mask)&0x3f;
 
-	if(pHalData->fw_ractrl == true)
+	if (pHalData->fw_ractrl == true)
 	{
 		value[0] = mask;
 		value[1] = mac_id | (shortGIrate?0x20:0x00) | 0x80;
@@ -5724,7 +5724,7 @@ static void rtl8192du_init_default_value
 
 	//init default value
 	pHalData->fw_ractrl = false;
-	if(!pwrctrlpriv->bkeepfwalive)
+	if (!pwrctrlpriv->bkeepfwalive)
 		pHalData->LastHMEBoxNum = 0;
 
 	pHalData->bEarlyModeEnable = 0;
@@ -5747,7 +5747,7 @@ void rtl8192du_set_hal_ops(struct rtw_ad
 _func_enter_;
 
 	padapter->HalData = rtw_zmalloc(sizeof(struct hal_data_8192du));
-	if(padapter->HalData == NULL){
+	if (padapter->HalData == NULL){
 		DBG_8192D("cant not alloc memory for HAL DATA \n");
 	}
 	//memset(padapter->HalData, 0, sizeof(struct hal_data_8192du));
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -48,7 +48,7 @@ static int usbctrl_vendorreq(struct intf
 	#endif
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->adapter_type > PRIMARY_ADAPTER)
+	if (padapter->adapter_type > PRIMARY_ADAPTER)
 	{
 		padapter = padapter->pbuddy_adapter;
 		pdvobjpriv = adapter_to_dvobj(padapter);
@@ -59,13 +59,13 @@ static int usbctrl_vendorreq(struct intf
 
 	//DBG_8192D("%s %s:%d\n",__func__, current->comm, current->pid);
 
-	if((padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx)){
+	if ((padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx)){
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usbctrl_vendorreq:(padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
 		status = -EPERM;
 		goto exit;
 	}
 
-	if(len>MAX_VENDOR_REQ_CMD_SIZE){
+	if (len>MAX_VENDOR_REQ_CMD_SIZE){
 		DBG_8192D( "[%s] Buffer len error ,vendor request failed\n", __func__ );
 		status = -EINVAL;
 		goto exit;
@@ -130,7 +130,7 @@ static int usbctrl_vendorreq(struct intf
 				, value,(requesttype == 0x01)?"read":"write" , len, status, *(u32*)pdata, vendorreq_times);
 
 			if (status < 0) {
-				if(status == (-ESHUTDOWN)	|| status == -ENODEV	)
+				if (status == (-ESHUTDOWN)	|| status == -ENODEV	)
 				{
 					padapter->bSurpriseRemoved = true;
 				} else {
@@ -144,7 +144,7 @@ static int usbctrl_vendorreq(struct intf
 			}
 			else // status != len && status >= 0
 			{
-				if(status > 0) {
+				if (status > 0) {
 					if ( requesttype == 0x01 )
 					{   // For Control read transfer, we have to copy the read data from pIo_buf to pdata.
 						memcpy( pdata, pIo_buf,  len );
@@ -152,7 +152,7 @@ static int usbctrl_vendorreq(struct intf
 				}
 			}
 
-			if(rtw_inc_and_chk_continual_urb_error(pdvobjpriv) == true ){
+			if (rtw_inc_and_chk_continual_urb_error(pdvobjpriv) == true ){
 				padapter->bSurpriseRemoved = true;
 				break;
 			}
@@ -160,7 +160,7 @@ static int usbctrl_vendorreq(struct intf
 		}
 
 		// firmware download is checksumed, don't retry
-		if( (value >= FW_8192D_START_ADDRESS && value <= FW_8192D_END_ADDRESS) || status == len )
+		if ( (value >= FW_8192D_START_ADDRESS && value <= FW_8192D_END_ADDRESS) || status == len )
 			break;
 
 	}
@@ -192,12 +192,12 @@ static void usb_read_reg_rf_byfw(struct
 	if (pHalData->interfaceIndex!=0)
 	{
 		nPHY = 1; //MAC1
-		if(registerIndex&MAC1_ACCESS_PHY0)// MAC1 need to access PHY0
+		if (registerIndex&MAC1_ACCESS_PHY0)// MAC1 need to access PHY0
 			nPHY = 0;
 	}
 	else
 	{
-		if(registerIndex&MAC0_ACCESS_PHY1)
+		if (registerIndex&MAC0_ACCESS_PHY1)
 			nPHY = 1;
 	}
 	registerIndex &= 0xFF;
@@ -225,7 +225,7 @@ static void usb_read_reg(struct intf_hdl
 
 	if (pHalData->interfaceIndex!=0)
 	{
-		if(value<0x1000)
+		if (value<0x1000)
 			value|=0x4000;
 		else if ((value&MAC1_ACCESS_PHY0) && !(value&0x8000))
 			value &= 0xFFF;
@@ -248,9 +248,9 @@ static int usb_write_reg(struct intf_hdl
 
 	if (pHalData->interfaceIndex!=0)
 	{
-		if(value<0x1000)
+		if (value<0x1000)
 			value|=0x4000;
-		else if((value&MAC1_ACCESS_PHY0) && !(value&0x8000))// MAC1 need to access PHY0
+		else if ((value&MAC1_ACCESS_PHY0) && !(value&0x8000))// MAC1 need to access PHY0
 			value &= 0xFFF;
 	}
 
@@ -306,7 +306,7 @@ static u32 usb_read32(struct intf_hdl *p
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 4;
 
-	if((addr&0xff000000)>>24 == 0x66){
+	if ((addr&0xff000000)>>24 == 0x66){
 		usb_read_reg_rf_byfw(pintfhdl, len, addr, &data);
 	}
 	else {
@@ -413,7 +413,7 @@ static void usb_read_interrupt_complete(
 	struct rtw_adapter		*padapter = (struct rtw_adapter	 *)purb->context;
 
 	padapter->recvpriv.int_cnt ++;
-	if(purb->status==0)//SUCCESS
+	if (purb->status==0)//SUCCESS
 	{
 		if (purb->actual_length > sizeof(INTERRUPT_MSG_FORMAT_EX))
 		{
@@ -421,7 +421,7 @@ static void usb_read_interrupt_complete(
 		}
 
 		err = usb_submit_urb(purb, GFP_ATOMIC);
-		if((err) && (err != (-EPERM)))
+		if ((err) && (err != (-EPERM)))
 		{
 			DBG_8192D("cannot submit interrupt in-token(err = 0x%08x),urb_status = %d\n",err, purb->status);
 		}
@@ -475,7 +475,7 @@ _func_enter_;
 					3);
 
 	err = usb_submit_urb(precvpriv->int_in_urb, GFP_ATOMIC);
-	if((err) && (err != (-EPERM)))
+	if ((err) && (err != (-EPERM)))
 	{
 		DBG_8192D("cannot submit interrupt in-token(err = 0x%08x),urb_status = %d\n",err, precvpriv->int_in_urb->status);
 		ret = _FAIL;
@@ -499,17 +499,17 @@ static s32 pre_recv_entry(union recv_fra
 	struct __queue *pfree_recv_queue = &precvpriv->free_recv_queue;
 	u8	*pbuf = precvframe->u.hdr.rx_data;
 
-	if(!secondary_padapter)
+	if (!secondary_padapter)
 		return ret;
 
 	paddr1 = GetAddr1Ptr(precvframe->u.hdr.rx_data);
 
-	if(IS_MCAST(paddr1) == false)//unicast packets
+	if (IS_MCAST(paddr1) == false)//unicast packets
 	{
 		//primary_myid = myid(&primary_padapter->eeprompriv);
 		secondary_myid = myid(&secondary_padapter->eeprompriv);
 
-		if(_rtw_memcmp(paddr1, secondary_myid, ETH_ALEN))
+		if (_rtw_memcmp(paddr1, secondary_myid, ETH_ALEN))
 		{
 			//change to secondary interface
 			precvframe->u.hdr.adapter = secondary_padapter;
@@ -522,7 +522,7 @@ static s32 pre_recv_entry(union recv_fra
 	{
 		u8 clone = true;
 
-		if(true == clone)
+		if (true == clone)
 		{
 			//clone/copy to if2
 			u8 shift_sz = 0;
@@ -531,7 +531,7 @@ static s32 pre_recv_entry(union recv_fra
 			struct rx_pkt_attrib *pattrib = NULL;
 
 			precvframe_if2 = rtw_alloc_recvframe(pfree_recv_queue);
-			if(precvframe_if2)
+			if (precvframe_if2)
 			{
 				precvframe_if2->u.hdr.adapter = secondary_padapter;
 
@@ -558,9 +558,9 @@ static s32 pre_recv_entry(union recv_fra
 
 				// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
 				// modify alloc_sz for recvive crc error packet by thomas 2011-06-02
-				if((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)){
+				if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)){
 					//alloc_sz = 1664;	//1664 is 128 alignment.
-					if(skb_len <= 1650)
+					if (skb_len <= 1650)
 						alloc_sz = 1664;
 					else
 						alloc_sz = skb_len + 14;
@@ -577,7 +577,7 @@ static s32 pre_recv_entry(union recv_fra
 #else
 				pkt_copy = netdev_alloc_skb(secondary_padapter->pnetdev, alloc_sz);
 #endif
-				if(pkt_copy)
+				if (pkt_copy)
 				{
 					pkt_copy->dev = secondary_padapter->pnetdev;
 					precvframe_if2->u.hdr.pkt = pkt_copy;
@@ -644,7 +644,7 @@ static int recvbuf2recvframe(struct rtw_
 		prxstat = (struct recv_stat *)pbuf;
 
 		precvframe = rtw_alloc_recvframe(pfree_recv_queue);
-		if(precvframe==NULL)
+		if (precvframe==NULL)
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: precvframe==NULL\n"));
 			DBG_8192D("%s()-%d: rtw_alloc_recvframe() failed! RX Drop!\n", __func__, __LINE__);
@@ -658,14 +658,14 @@ static int recvbuf2recvframe(struct rtw_
 		rtl8192d_query_rx_desc_status(precvframe, prxstat);
 
 		pattrib = &precvframe->u.hdr.attrib;
-		if(pattrib->physt)
+		if (pattrib->physt)
 		{
 			pphy_info = (struct phy_stat *)(pbuf + RXDESC_OFFSET);
 		}
 
 		pkt_offset = RXDESC_SIZE + pattrib->drvinfo_sz + pattrib->shift_sz + pattrib->pkt_len;
 
-		if((pattrib->pkt_len<=0) || (pkt_offset>transfer_len))
+		if ((pattrib->pkt_len<=0) || (pkt_offset>transfer_len))
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: pkt_len<=0\n"));
 			DBG_8192D("%s()-%d: RX Warning!\n", __func__, __LINE__);
@@ -688,9 +688,9 @@ static int recvbuf2recvframe(struct rtw_
 
 		// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
 		// modify alloc_sz for recvive crc error packet by thomas 2011-06-02
-		if((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)){
+		if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)){
 			//alloc_sz = 1664;	//1664 is 128 alignment.
-			if(skb_len <= 1650)
+			if (skb_len <= 1650)
 				alloc_sz = 1664;
 			else
 				alloc_sz = skb_len + 14;
@@ -707,7 +707,7 @@ static int recvbuf2recvframe(struct rtw_
 #else
 		pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
 #endif
-		if(pkt_copy)
+		if (pkt_copy)
 		{
 			precvframe->u.hdr.pkt = pkt_copy;
 			precvframe->u.hdr.rx_head = pkt_copy->data;
@@ -750,9 +750,9 @@ static int recvbuf2recvframe(struct rtw_
 #endif
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if(rtw_buddy_adapter_up(padapter))
+		if (rtw_buddy_adapter_up(padapter))
 		{
-			if(pre_recv_entry(precvframe, prxstat, pphy_info) != _SUCCESS)
+			if (pre_recv_entry(precvframe, prxstat, pphy_info) != _SUCCESS)
 			{
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: recv_entry(precvframe) != _SUCCESS\n"));
 			}
@@ -760,14 +760,14 @@ static int recvbuf2recvframe(struct rtw_
 		else
 		{
 			rtl8192d_translate_rx_signal_stuff(precvframe, pphy_info);
-			if(rtw_recv_entry(precvframe) != _SUCCESS)
+			if (rtw_recv_entry(precvframe) != _SUCCESS)
 			{
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
 			}
 		}
 #else
 		rtl8192d_translate_rx_signal_stuff(precvframe, pphy_info);
-		if(rtw_recv_entry(precvframe) != _SUCCESS)
+		if (rtw_recv_entry(precvframe) != _SUCCESS)
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
 		}
@@ -780,7 +780,7 @@ static int recvbuf2recvframe(struct rtw_
 		precvframe = NULL;
 		pkt_copy = NULL;
 
-		if(transfer_len>0 && pkt_cnt==0)
+		if (transfer_len>0 && pkt_cnt==0)
 			pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
 
 	}while((transfer_len>0) && (pkt_cnt>0));
@@ -824,14 +824,14 @@ static void usb_read_port_complete(struc
 
 	precvpriv->rx_pending_cnt --;
 
-	if(padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
+	if (padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));
 
 		goto exit;
 	}
 
-	if(purb->status==0)//SUCCESS
+	if (purb->status==0)//SUCCESS
 	{
 		if ((purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE))
 		{
@@ -898,17 +898,17 @@ static u32 usb_read_port(struct intf_hdl
 
 _func_enter_;
 
-	if(adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
+	if (adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
 		return _FAIL;
 	}
 
-	if(precvbuf !=NULL)
+	if (precvbuf !=NULL)
 	{
 		rtl8192du_init_recvbuf(adapter, precvbuf);
 
-		if(precvbuf->pbuf)
+		if (precvbuf->pbuf)
 		{
 			precvpriv->rx_pending_cnt++;
 
@@ -927,7 +927,7 @@ _func_enter_;
 			purb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
 			err = usb_submit_urb(purb, GFP_ATOMIC);
-			if((err) && (err != (-EPERM)))
+			if ((err) && (err != (-EPERM)))
 			{
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cannot submit rx in-token(err=0x%.8x), URB_STATUS =0x%.8x", err, purb->status));
 				DBG_8192D("cannot submit rx in-token(err = 0x%08x),urb_status = %d\n",err,purb->status);
@@ -978,7 +978,7 @@ static int recvbuf2recvframe(struct rtw_
 		prxstat = (struct recv_stat *)pbuf;
 
 		precvframe = rtw_alloc_recvframe(pfree_recv_queue);
-		if(precvframe==NULL)
+		if (precvframe==NULL)
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: precvframe==NULL\n"));
 			DBG_8192D("%s()-%d: rtw_alloc_recvframe() failed! RX Drop!\n", __func__, __LINE__);
@@ -992,14 +992,14 @@ static int recvbuf2recvframe(struct rtw_
 		rtl8192d_query_rx_desc_status(precvframe, prxstat);
 
 		pattrib = &precvframe->u.hdr.attrib;
-		if(pattrib->physt)
+		if (pattrib->physt)
 		{
 			pphy_info = (struct phy_stat *)(pbuf + RXDESC_OFFSET);
 		}
 
 		pkt_offset = RXDESC_SIZE + pattrib->drvinfo_sz + pattrib->shift_sz + pattrib->pkt_len;
 
-		if((pattrib->pkt_len<=0) || (pkt_offset>transfer_len))
+		if ((pattrib->pkt_len<=0) || (pkt_offset>transfer_len))
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: pkt_len<=0\n"));
 			DBG_8192D("%s()-%d: RX Warning!\n", __func__, __LINE__);
@@ -1022,9 +1022,9 @@ static int recvbuf2recvframe(struct rtw_
 
 		// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
 		// modify alloc_sz for recvive crc error packet by thomas 2011-06-02
-		if((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)){
+		if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)){
 			//alloc_sz = 1664;	//1664 is 128 alignment.
-			if(skb_len <= 1650)
+			if (skb_len <= 1650)
 				alloc_sz = 1664;
 			else
 				alloc_sz = skb_len + 14;
@@ -1041,7 +1041,7 @@ static int recvbuf2recvframe(struct rtw_
 #else
 		pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
 #endif
-		if(pkt_copy)
+		if (pkt_copy)
 		{
 			precvframe->u.hdr.pkt = pkt_copy;
 			precvframe->u.hdr.rx_head = pkt_copy->data;
@@ -1054,7 +1054,7 @@ static int recvbuf2recvframe(struct rtw_
 		else
 		{
 			precvframe->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC);
-			if(pkt_copy)
+			if (pkt_copy)
 			{
 				precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pbuf;
 				precvframe->u.hdr.rx_end = pbuf + alloc_sz;
@@ -1086,9 +1086,9 @@ static int recvbuf2recvframe(struct rtw_
 		}
 #endif
 #ifdef CONFIG_CONCURRENT_MODE
-		if(rtw_buddy_adapter_up(padapter))
+		if (rtw_buddy_adapter_up(padapter))
 		{
-			if(pre_recv_entry(precvframe, prxstat, pphy_info) != _SUCCESS)
+			if (pre_recv_entry(precvframe, prxstat, pphy_info) != _SUCCESS)
 			{
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: recv_entry(precvframe) != _SUCCESS\n"));
 			}
@@ -1096,14 +1096,14 @@ static int recvbuf2recvframe(struct rtw_
 		else
 		{
 			rtl8192d_translate_rx_signal_stuff(precvframe, pphy_info);
-			if(rtw_recv_entry(precvframe) != _SUCCESS)
+			if (rtw_recv_entry(precvframe) != _SUCCESS)
 			{
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
 			}
 		}
 #else
 		rtl8192d_translate_rx_signal_stuff(precvframe, pphy_info);
-		if(rtw_recv_entry(precvframe) != _SUCCESS)
+		if (rtw_recv_entry(precvframe) != _SUCCESS)
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
 		}
@@ -1115,7 +1115,7 @@ static int recvbuf2recvframe(struct rtw_
 		precvframe = NULL;
 		pkt_copy = NULL;
 
-		if(transfer_len>0 && pkt_cnt==0)
+		if (transfer_len>0 && pkt_cnt==0)
 			pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
 
 	}while((transfer_len>0) && (pkt_cnt>0));
@@ -1170,14 +1170,14 @@ static void usb_read_port_complete(struc
 
 	precvpriv->rx_pending_cnt --;
 
-	if(padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
+	if (padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));
 
 	#ifdef CONFIG_PREALLOC_RECV_SKB
 		precvbuf->reuse = true;
 	#else
-		if(precvbuf->pskb){
+		if (precvbuf->pskb){
 			DBG_8192D("==> free skb(%p)\n",precvbuf->pskb);
 			dev_kfree_skb_any(precvbuf->pskb);
 		}
@@ -1186,7 +1186,7 @@ static void usb_read_port_complete(struc
 		goto exit;
 	}
 
-	if(purb->status==0)//SUCCESS
+	if (purb->status==0)//SUCCESS
 	{
 		if ((purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE))
 		{
@@ -1261,14 +1261,14 @@ static u32 usb_read_port(struct intf_hdl
 
 _func_enter_;
 
-	if(adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
+	if (adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
 		return _FAIL;
 	}
 
 #ifdef CONFIG_PREALLOC_RECV_SKB
-	if((precvbuf->reuse == false) || (precvbuf->pskb == NULL))
+	if ((precvbuf->reuse == false) || (precvbuf->pskb == NULL))
 	{
 		if (NULL != (precvbuf->pskb = skb_dequeue(&precvpriv->free_recv_skb_queue)))
 		{
@@ -1278,12 +1278,12 @@ _func_enter_;
 #endif
 
 
-	if(precvbuf !=NULL)
+	if (precvbuf !=NULL)
 	{
 		rtl8192du_init_recvbuf(adapter, precvbuf);
 
 		//re-assign for linux based on skb
-		if((precvbuf->reuse == false) || (precvbuf->pskb == NULL))
+		if ((precvbuf->reuse == false) || (precvbuf->pskb == NULL))
 		{
 			//precvbuf->pskb = alloc_skb(MAX_RECVBUF_SZ, GFP_ATOMIC);//don't use this after v2.6.25
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
@@ -1291,7 +1291,7 @@ _func_enter_;
 #else
 			precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
 #endif
-			if(precvbuf->pskb == NULL)
+			if (precvbuf->pskb == NULL)
 			{
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("init_recvbuf(): alloc_skb fail!\n"));
 				return _FAIL;
@@ -1332,7 +1332,7 @@ _func_enter_;
 						precvbuf);//context is precvbuf
 
 		err = usb_submit_urb(purb, GFP_ATOMIC);
-		if((err) && (err != (-EPERM)))
+		if ((err) && (err != (-EPERM)))
 		{
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cannot submit rx in-token(err=0x%.8x), URB_STATUS =0x%.8x", err, purb->status));
 			DBG_8192D("cannot submit rx in-token(err = 0x%08x),urb_status = %d\n",err,purb->status);
@@ -1357,7 +1357,7 @@ void rtl8192du_xmit_tasklet(void *priv)
 	struct rtw_adapter *padapter = (struct rtw_adapter*)priv;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
-	if(check_fwstate(&padapter->mlmepriv, _FW_UNDER_SURVEY) == true
+	if (check_fwstate(&padapter->mlmepriv, _FW_UNDER_SURVEY) == true
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		|| (dc_check_xmit(padapter)== false)
 #endif
@@ -1374,7 +1374,7 @@ void rtl8192du_xmit_tasklet(void *priv)
 
 		ret = rtl8192du_xmitframe_complete(padapter, pxmitpriv, NULL);
 
-		if(ret==false)
+		if (ret==false)
 			break;
 	}
 
--- a/drivers/staging/rtl8192du/include/osdep_intf.h
+++ b/drivers/staging/rtl8192du/include/osdep_intf.h
@@ -105,7 +105,7 @@ void rtw_drv_if2_free(struct rtw_adapter
 void rtw_drv_if2_stop(struct rtw_adapter *if2);
 #ifdef CONFIG_MULTI_VIR_IFACES
 struct dvobj_priv;
-_adapter *rtw_drv_add_vir_if(struct rtw_adapter *primary_padapter, char *name,	void (*set_intf_ops)(struct _io_ops *pops));
+_adapter *rtw_drv_add_vir_if (struct rtw_adapter *primary_padapter, char *name,	void (*set_intf_ops)(struct _io_ops *pops));
 void rtw_drv_stop_vir_ifaces(struct dvobj_priv *dvobj);
 void rtw_drv_free_vir_ifaces(struct dvobj_priv *dvobj);
 #endif //CONFIG_MULTI_VIR_IFACES
--- a/drivers/staging/rtl8192du/include/rtw_debug.h
+++ b/drivers/staging/rtl8192du/include/rtw_debug.h
@@ -175,7 +175,7 @@
 		#undef RT_TRACE
 		#define RT_TRACE(_Comp, _Level, Fmt)\
 		do {\
-			if((_Comp & GlobalDebugComponents) && (_Level <= GlobalDebugLevel)) {\
+			if ((_Comp & GlobalDebugComponents) && (_Level <= GlobalDebugLevel)) {\
 				_dbgdump("%s [0x%08x,%d]", RTL871X_MODULE_NAME, (unsigned int)_Comp, _Level);\
 				_dbgdump Fmt;\
 			}\
@@ -206,7 +206,7 @@
 
 		#undef RT_PRINT_DATA
 		#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen)			\
-			if(((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
+			if (((_Comp) & GlobalDebugComponents) && (_Level <= GlobalDebugLevel))	\
 			{									\
 				int __i;								\
 				u8	*ptr = (u8 *)_HexData;				\
--- a/drivers/staging/rtl8192du/include/rtw_ioctl.h
+++ b/drivers/staging/rtl8192du/include/rtw_ioctl.h
@@ -64,7 +64,7 @@
 #define OID_MP_SEG4		0xFF011100
 
 #define DEBUG_OID(dbg, str)			\
-       if((!dbg))							\
+       if ((!dbg))							\
 	{								\
 	   RT_TRACE(_module_rtl871x_ioctl_c_,_drv_info_,("%s(%d): %s", __func__, __LINE__, str));	\
 	}
--- a/drivers/staging/rtl8192du/include/rtw_led.h
+++ b/drivers/staging/rtl8192du/include/rtw_led.h
@@ -130,7 +130,7 @@ struct led_priv{
 #ifdef CONFIG_SW_LED
 #define rtw_led_control(adapter, LedAction) \
 	do { \
-		if((adapter)->ledpriv.LedControlHandler) \
+		if ((adapter)->ledpriv.LedControlHandler) \
 			(adapter)->ledpriv.LedControlHandler((adapter), (LedAction)); \
 	} while(0)
 #else //CONFIG_SW_LED
--- a/drivers/staging/rtl8192du/include/rtw_p2p.h
+++ b/drivers/staging/rtl8192du/include/rtw_p2p.h
@@ -76,21 +76,21 @@ int rtw_p2p_enable(struct rtw_adapter *p
 
 static inline void _rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
 {
-	if(wdinfo->p2p_state != state) {
+	if (wdinfo->p2p_state != state) {
 		//wdinfo->pre_p2p_state = wdinfo->p2p_state;
 		wdinfo->p2p_state = state;
 	}
 }
 static inline void _rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
 {
-	if(wdinfo->pre_p2p_state != state) {
+	if (wdinfo->pre_p2p_state != state) {
 		wdinfo->pre_p2p_state = state;
 	}
 }
 
 static inline void _rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
 {
-	if(wdinfo->role != role) {
+	if (wdinfo->role != role) {
 		wdinfo->role = role;
 	}
 }
--- a/drivers/staging/rtl8192du/include/rtw_recv.h
+++ b/drivers/staging/rtl8192du/include/rtw_recv.h
@@ -396,7 +396,7 @@ void rtw_reordering_ctrl_timeout_handler
 static inline u8 *get_rxmem(union recv_frame *precvframe)
 {
 	//always return rx_head...
-	if(precvframe==NULL)
+	if (precvframe==NULL)
 		return NULL;
 
 	return precvframe->u.hdr.rx_head;
@@ -413,7 +413,7 @@ static inline u8 *get_recvframe_data(uni
 {
 
 	//alwasy return rx_data
-	if(precvframe==NULL)
+	if (precvframe==NULL)
 		return NULL;
 
 	return precvframe->u.hdr.rx_data;
@@ -430,12 +430,12 @@ static inline u8 *recvframe_push(union r
  *      start. rx_data must be still larger than rx_head, after pushing.
  */
 
-	if(precvframe==NULL)
+	if (precvframe==NULL)
 		return NULL;
 
 
 	precvframe->u.hdr.rx_data -= sz ;
-	if( precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head )
+	if ( precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head )
 	{
 		precvframe->u.hdr.rx_data += sz ;
 		return NULL;
@@ -455,13 +455,13 @@ static inline u8 *recvframe_pull(union r
 	//used for extract sz bytes from rx_data, update rx_data and return the updated rx_data to the caller
 
 
-	if(precvframe==NULL)
+	if (precvframe==NULL)
 		return NULL;
 
 
 	precvframe->u.hdr.rx_data += sz;
 
-	if(precvframe->u.hdr.rx_data > precvframe->u.hdr.rx_tail)
+	if (precvframe->u.hdr.rx_data > precvframe->u.hdr.rx_tail)
 	{
 		precvframe->u.hdr.rx_data -= sz;
 		return NULL;
@@ -481,14 +481,14 @@ static inline u8 *recvframe_put(union re
 	//after putting, rx_tail must be still larger than rx_end.
 	unsigned char * prev_rx_tail;
 
-	if(precvframe==NULL)
+	if (precvframe==NULL)
 		return NULL;
 
 	prev_rx_tail = precvframe->u.hdr.rx_tail;
 
 	precvframe->u.hdr.rx_tail += sz;
 
-	if(precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end)
+	if (precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end)
 	{
 		precvframe->u.hdr.rx_tail -= sz;
 		return NULL;
@@ -509,12 +509,12 @@ static inline u8 *recvframe_pull_tail(un
 	//used for extract sz bytes from rx_end, update rx_end and return the updated rx_end to the caller
 	//after pulling, rx_end must be still larger than rx_data.
 
-	if(precvframe==NULL)
+	if (precvframe==NULL)
 		return NULL;
 
 	precvframe->u.hdr.rx_tail -= sz;
 
-	if(precvframe->u.hdr.rx_tail < precvframe->u.hdr.rx_data)
+	if (precvframe->u.hdr.rx_tail < precvframe->u.hdr.rx_data)
 	{
 		precvframe->u.hdr.rx_tail += sz;
 		return NULL;
@@ -532,7 +532,7 @@ static inline unsigned char *get_rxbuf_d
 {
 	unsigned char *buf_desc;
 
-	if(precvframe==NULL)
+	if (precvframe==NULL)
 		return NULL;
 	return buf_desc;
 }
--- a/drivers/staging/rtl8192du/include/rtw_security.h
+++ b/drivers/staging/rtl8192du/include/rtw_security.h
@@ -191,7 +191,7 @@ do{\
 			encry_algo = (u8)psecuritypriv->dot11PrivacyAlgrthm;\
 			break;\
 		case dot11AuthAlgrthm_8021X:\
-			if(bmcst)\
+			if (bmcst)\
 				encry_algo = (u8)psecuritypriv->dot118021XGrpPrivacy;\
 			else\
 				encry_algo =(u8) psta->dot118021XPrivacy;\
--- a/drivers/staging/rtl8192du/include/usb_ops.h
+++ b/drivers/staging/rtl8192du/include/usb_ops.h
@@ -69,7 +69,7 @@ static inline int rtw_inc_and_chk_contin
 {
 	int ret = false;
 	int value;
-	if( (value=ATOMIC_INC_RETURN(&dvobj->continual_urb_error)) > MAX_CONTINUAL_URB_ERR) {
+	if ( (value=ATOMIC_INC_RETURN(&dvobj->continual_urb_error)) > MAX_CONTINUAL_URB_ERR) {
 		DBG_8192D("[dvobj:%p][ERROR] continual_urb_error:%d > %d\n", dvobj, value, MAX_CONTINUAL_URB_ERR);
 		ret = true;
 	} else {
--- a/drivers/staging/rtl8192du/include/wifi.h
+++ b/drivers/staging/rtl8192du/include/wifi.h
@@ -504,7 +504,7 @@ __inline static unsigned char * get_hdr_
 
 __inline static int IsFrameTypeCtrl(unsigned char *pframe)
 {
-	if(WIFI_CTRL_TYPE == GetFrameType(pframe))
+	if (WIFI_CTRL_TYPE == GetFrameType(pframe))
 		return true;
 	else
 		return false;
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -168,12 +168,12 @@ struct ieee80211_supported_band *rtw_spt
 	struct ieee80211_supported_band *spt_band = NULL;
 	int n_channels, n_bitrates;
 
-	if(band == IEEE80211_BAND_2GHZ)
+	if (band == IEEE80211_BAND_2GHZ)
 	{
 		n_channels = RTW_2G_CHANNELS_NUM;
 		n_bitrates = RTW_G_RATES_NUM;
 	}
-	else if(band == IEEE80211_BAND_5GHZ)
+	else if (band == IEEE80211_BAND_5GHZ)
 	{
 		n_channels = RTW_5G_CHANNELS_NUM;
 		n_bitrates = RTW_A_RATES_NUM;
@@ -188,7 +188,7 @@ struct ieee80211_supported_band *rtw_spt
 		+ sizeof(struct ieee80211_channel)*n_channels
 		+ sizeof(struct ieee80211_rate)*n_bitrates
 	);
-	if(!spt_band)
+	if (!spt_band)
 		goto exit;
 
 	spt_band->channels = (struct ieee80211_channel*)(((u8*)spt_band)+sizeof(struct ieee80211_supported_band));
@@ -197,12 +197,12 @@ struct ieee80211_supported_band *rtw_spt
 	spt_band->n_channels = n_channels;
 	spt_band->n_bitrates = n_bitrates;
 
-	if(band == IEEE80211_BAND_2GHZ)
+	if (band == IEEE80211_BAND_2GHZ)
 	{
 		rtw_2g_channels_init(spt_band->channels);
 		rtw_2g_rates_init(spt_band->bitrates);
 	}
-	else if(band == IEEE80211_BAND_5GHZ)
+	else if (band == IEEE80211_BAND_5GHZ)
 	{
 		rtw_5g_channels_init(spt_band->channels);
 		rtw_5g_rates_init(spt_band->bitrates);
@@ -219,16 +219,16 @@ void rtw_spt_band_free(struct ieee80211_
 {
 	u32 size;
 
-	if(!spt_band)
+	if (!spt_band)
 		return;
 
-	if(spt_band->band == IEEE80211_BAND_2GHZ)
+	if (spt_band->band == IEEE80211_BAND_2GHZ)
 	{
 		size = sizeof(struct ieee80211_supported_band)
 			+ sizeof(struct ieee80211_channel)*RTW_2G_CHANNELS_NUM
 			+ sizeof(struct ieee80211_rate)*RTW_G_RATES_NUM;
 	}
-	else if(spt_band->band == IEEE80211_BAND_5GHZ)
+	else if (spt_band->band == IEEE80211_BAND_5GHZ)
 	{
 		size = sizeof(struct ieee80211_supported_band)
 			+ sizeof(struct ieee80211_channel)*RTW_5G_CHANNELS_NUM
@@ -341,7 +341,7 @@ static int rtw_cfg80211_inform_bss(_adap
 	//DBG_8192C("%s\n", __func__);
 
 	bssinf_len = pnetwork->network.IELength+sizeof (struct rtw_ieee80211_hdr_3addr);
-	if(bssinf_len > MAX_BSSINFO_LEN){
+	if (bssinf_len > MAX_BSSINFO_LEN){
 		DBG_871X("%s IE Length too long > %d byte \n",__func__,MAX_BSSINFO_LEN);
 		goto exit;
 	}
@@ -411,7 +411,7 @@ static int rtw_cfg80211_inform_bss(_adap
 	len += pnetwork->network.IELength;
 
 	//#ifdef CONFIG_P2P
-	//if(rtw_get_p2p_ie(pnetwork->network.IEs+12, pnetwork->network.IELength-12, NULL, NULL))
+	//if (rtw_get_p2p_ie(pnetwork->network.IEs+12, pnetwork->network.IELength-12, NULL, NULL))
 	//{
 	//	DBG_8192C("%s, got p2p_ie\n", __func__);
 	//}
@@ -438,7 +438,7 @@ static int rtw_cfg80211_inform_bss(_adap
 	//patch for cfg80211, update beacon ies to information_elements
 	if (pnetwork->network.Reserved[0] == 1) { // WIFI_BEACON
 
-		 if(bss->len_information_elements != bss->len_beacon_ies)
+		 if (bss->len_information_elements != bss->len_beacon_ies)
 		 {
 			bss->information_elements = bss->beacon_ies;
 			bss->len_information_elements =  bss->len_beacon_ies;
@@ -449,15 +449,15 @@ static int rtw_cfg80211_inform_bss(_adap
 
 /*
 	{
-		if( bss->information_elements == bss->proberesp_ies)
+		if ( bss->information_elements == bss->proberesp_ies)
 		{
-			if( bss->len_information_elements !=  bss->len_proberesp_ies)
+			if ( bss->len_information_elements !=  bss->len_proberesp_ies)
 			{
 				DBG_8192C("error!, len_information_elements !=  bss->len_proberesp_ies\n");
 			}
 
 		}
-		else if(bss->len_information_elements <  bss->len_beacon_ies)
+		else if (bss->len_information_elements <  bss->len_beacon_ies)
 		{
 			bss->information_elements = bss->beacon_ies;
 			bss->len_information_elements =  bss->len_beacon_ies;
@@ -492,11 +492,11 @@ void rtw_cfg80211_indicate_connect(_adap
 		return;
 	}
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		return;
 
 #ifdef CONFIG_P2P
-	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
 		rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
@@ -565,11 +565,11 @@ void rtw_cfg80211_indicate_disconnect(_a
 		return;
 	}
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		return;
 
 #ifdef CONFIG_P2P
-	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		_cancel_timer_ex( &pwdinfo->find_phase_timer );
 		_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
@@ -585,10 +585,10 @@ void rtw_cfg80211_indicate_disconnect(_a
 	if (!padapter->mlmepriv.not_indic_disco) {
 		DBG_8192C("pwdev->sme_state(b)=%d\n", pwdev->sme_state);
 
-		if(pwdev->sme_state==CFG80211_SME_CONNECTING)
+		if (pwdev->sme_state==CFG80211_SME_CONNECTING)
 			cfg80211_connect_result(padapter->pnetdev, NULL, NULL, 0, NULL, 0,
 				WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC/*GFP_KERNEL*/);
-		else if(pwdev->sme_state==CFG80211_SME_CONNECTED)
+		else if (pwdev->sme_state==CFG80211_SME_CONNECTED)
 			cfg80211_disconnected(padapter->pnetdev, 0, NULL, 0, GFP_ATOMIC);
 		//else
 			//DBG_8192C("pwdev->sme_state=%d\n", pwdev->sme_state);
@@ -613,7 +613,7 @@ static u8 set_pairwise_key(_adapter *pad
 	}
 
 	psetstakey_para = (struct set_stakey_parm*)rtw_zmalloc(sizeof(struct set_stakey_parm));
-	if(psetstakey_para==NULL){
+	if (psetstakey_para==NULL){
 		kfree(ph2c);
 		res=_FAIL;
 		goto exit;
@@ -648,12 +648,12 @@ static int set_group_key(_adapter *padap
 	DBG_8192C("%s\n", __func__);
 
 	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if(pcmd==NULL){
+	if (pcmd==NULL){
 		res= _FAIL;
 		goto exit;
 	}
 	psetkeyparm=(struct setkey_parm*)rtw_zmalloc(sizeof(struct setkey_parm));
-	if(psetkeyparm==NULL){
+	if (psetkeyparm==NULL){
 		kfree(pcmd);
 		res= _FAIL;
 		goto exit;
@@ -759,7 +759,7 @@ static int rtw_cfg80211_ap_set_encryptio
 	else
 	{
 		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
-		if(!psta)
+		if (!psta)
 		{
 			//ret = -EINVAL;
 			DBG_8192C("rtw_set_encryption(), sta has already been removed or never been added\n");
@@ -786,7 +786,7 @@ static int rtw_cfg80211_ap_set_encryptio
 
 		DBG_8192C("r871x_set_encryption, wep_key_idx=%d, len=%d\n", wep_key_idx, wep_key_len);
 
-		if((wep_key_idx >= WEP_KEYS) || (wep_key_len<=0))
+		if ((wep_key_idx >= WEP_KEYS) || (wep_key_len<=0))
 		{
 			ret = -EINVAL;
 			goto exit;
@@ -805,7 +805,7 @@ static int rtw_cfg80211_ap_set_encryptio
 			psecuritypriv->dot11PrivacyAlgrthm=_WEP40_;
 			psecuritypriv->dot118021XGrpPrivacy=_WEP40_;
 
-			if(wep_key_len == 13)
+			if (wep_key_len == 13)
 			{
 				psecuritypriv->dot11PrivacyAlgrthm=_WEP104_;
 				psecuritypriv->dot118021XGrpPrivacy=_WEP104_;
@@ -825,24 +825,24 @@ static int rtw_cfg80211_ap_set_encryptio
 	}
 
 
-	if(!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) // //group key
+	if (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) // //group key
 	{
-		if(param->u.crypt.set_tx == 0) //group key
+		if (param->u.crypt.set_tx == 0) //group key
 		{
-			if(strcmp(param->u.crypt.alg, "WEP") == 0)
+			if (strcmp(param->u.crypt.alg, "WEP") == 0)
 			{
 				DBG_8192C("%s, set group_key, WEP\n", __func__);
 
 				memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
 				psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
-				if(param->u.crypt.key_len==13)
+				if (param->u.crypt.key_len==13)
 				{
 						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
 				}
 
 			}
-			else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+			else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
 			{
 				DBG_8192C("%s, set group_key, TKIP\n", __func__);
 
@@ -858,7 +858,7 @@ static int rtw_cfg80211_ap_set_encryptio
 				psecuritypriv->busetkipkey = true;
 
 			}
-			else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+			else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
 			{
 				DBG_8192C("%s, set group_key, CCMP\n", __func__);
 
@@ -882,7 +882,7 @@ static int rtw_cfg80211_ap_set_encryptio
 			set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
 
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
-			if(pbcmc_sta)
+			if (pbcmc_sta)
 			{
 				pbcmc_sta->ieee8021x_blocked = false;
 				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
@@ -894,25 +894,25 @@ static int rtw_cfg80211_ap_set_encryptio
 
 	}
 
-	if(psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) // psk/802_1x
+	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) // psk/802_1x
 	{
-		if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE))
 		{
-			if(param->u.crypt.set_tx ==1) //pairwise key
+			if (param->u.crypt.set_tx ==1) //pairwise key
 			{
 				memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
-				if(strcmp(param->u.crypt.alg, "WEP") == 0)
+				if (strcmp(param->u.crypt.alg, "WEP") == 0)
 				{
 					DBG_8192C("%s, set pairwise key, WEP\n", __func__);
 
 					psta->dot118021XPrivacy = _WEP40_;
-					if(param->u.crypt.key_len==13)
+					if (param->u.crypt.key_len==13)
 					{
 						psta->dot118021XPrivacy = _WEP104_;
 					}
 				}
-				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+				else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
 				{
 					DBG_8192C("%s, set pairwise key, TKIP\n", __func__);
 
@@ -926,7 +926,7 @@ static int rtw_cfg80211_ap_set_encryptio
 					psecuritypriv->busetkipkey = true;
 
 				}
-				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+				else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
 				{
 
 					DBG_8192C("%s, set pairwise key, CCMP\n", __func__);
@@ -949,17 +949,17 @@ static int rtw_cfg80211_ap_set_encryptio
 			}
 			else//group key???
 			{
-				if(strcmp(param->u.crypt.alg, "WEP") == 0)
+				if (strcmp(param->u.crypt.alg, "WEP") == 0)
 				{
 					memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
 					psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
-					if(param->u.crypt.key_len==13)
+					if (param->u.crypt.key_len==13)
 					{
 						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
 					}
 				}
-				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+				else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
 				{
 					psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
 
@@ -973,7 +973,7 @@ static int rtw_cfg80211_ap_set_encryptio
 					psecuritypriv->busetkipkey = true;
 
 				}
-				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+				else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
 				{
 					psecuritypriv->dot118021XGrpPrivacy = _AES_;
 
@@ -993,7 +993,7 @@ static int rtw_cfg80211_ap_set_encryptio
 				set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
 
 				pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
-				if(pbcmc_sta)
+				if (pbcmc_sta)
 				{
 					pbcmc_sta->ieee8021x_blocked = false;
 					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
@@ -1074,7 +1074,7 @@ _func_enter_;
 			psecuritypriv->dot11PrivacyAlgrthm = _WEP40_;
 			psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
 
-			if(wep_key_len==13)
+			if (wep_key_len==13)
 			{
 				psecuritypriv->dot11PrivacyAlgrthm = _WEP104_;
 				psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
@@ -1092,7 +1092,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	if(padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) // 802_1x
+	if (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) // 802_1x
 	{
 		struct sta_info * psta,*pbcmc_sta;
 		struct sta_priv * pstapriv = &padapter->stapriv;
@@ -1113,20 +1113,20 @@ _func_enter_;
 					psta->ieee8021x_blocked = false;
 
 
-				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+				if ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
 						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
 				{
 					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
 				}
 
-				if(param->u.crypt.set_tx ==1)//pairwise key
+				if (param->u.crypt.set_tx ==1)//pairwise key
 				{
 
 					DBG_8192C("%s, : param->u.crypt.set_tx ==1 \n", __func__);
 
 					memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
-					if(strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
+					if (strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
 					{
 						//DEBUG_ERR(("\nset key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
 						memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
@@ -1154,7 +1154,7 @@ _func_enter_;
 
 					rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1);
 #ifdef CONFIG_P2P
-					if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
+					if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
 					{
 						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_DONE);
 					}
@@ -1164,7 +1164,7 @@ _func_enter_;
 			}
 
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
-			if(pbcmc_sta==NULL)
+			if (pbcmc_sta==NULL)
 			{
 				//DEBUG_ERR( ("Set OID_802_11_ADD_KEY: bcmc stainfo is null \n"));
 			}
@@ -1174,14 +1174,14 @@ _func_enter_;
 				if (strcmp(param->u.crypt.alg, "none") != 0)
 					pbcmc_sta->ieee8021x_blocked = false;
 
-				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+				if ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
 						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
 				{
 					pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
 				}
 			}
 		}
-		else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
+		else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
 		{
 		}
 	}
@@ -1269,20 +1269,20 @@ static int cfg80211_rtw_add_key(struct w
 		memcpy(param->u.crypt.seq, params->seq, params->seq_len);
 	}
 
-	if(params->key_len && params->key)
+	if (params->key_len && params->key)
 	{
 		param->u.crypt.key_len = params->key_len;
 		memcpy(param->u.crypt.key, params->key, params->key_len);
 	}
 
-	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 	{
 		ret =  rtw_cfg80211_set_encryption(ndev, param, param_len);
 	}
-	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 #ifdef CONFIG_AP_MODE
-		if(mac_addr)
+		if (mac_addr)
 			memcpy(param->sta_addr, (void*)mac_addr, ETH_ALEN);
 
 		ret = rtw_cfg80211_ap_set_encryption(ndev, param, param_len);
@@ -1291,7 +1291,7 @@ static int cfg80211_rtw_add_key(struct w
 		DBG_8192C("error! fw_state=0x%x, iftype=%d\n", pmlmepriv->fw_state, rtw_wdev->iftype);
 	}
 
-	if(param)
+	if (param)
 		kfree(param);
 
 	return ret;
@@ -1404,7 +1404,7 @@ static int cfg80211_rtw_get_station(stru
 #endif
 
 	//for infra./P2PClient mode
-	if(	check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+	if (	check_fwstate(pmlmepriv, WIFI_STATION_STATE)
 		&& check_fwstate(pmlmepriv, _FW_LINKED)
 	)
 	{
@@ -1485,25 +1485,25 @@ static int cfg80211_rtw_change_iface(str
 	u8 change = false;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->adapter_type == SECONDARY_ADAPTER)
+	if (padapter->adapter_type == SECONDARY_ADAPTER)
 	{
 		DBG_871X(FUNC_NDEV_FMT" call netdev_if2_open\n", FUNC_NDEV_ARG(ndev));
-		if(netdev_if2_open(ndev) != 0) {
+		if (netdev_if2_open(ndev) != 0) {
 			ret= -EPERM;
 			goto exit;
 		}
 	}
-	else if(padapter->adapter_type == PRIMARY_ADAPTER)
+	else if (padapter->adapter_type == PRIMARY_ADAPTER)
 #endif //CONFIG_CONCURRENT_MODE
 	{
 		DBG_871X(FUNC_NDEV_FMT" call netdev_open\n", FUNC_NDEV_ARG(ndev));
-		if(netdev_open(ndev) != 0) {
+		if (netdev_open(ndev) != 0) {
 			ret= -EPERM;
 			goto exit;
 		}
 	}
 
-	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (_FAIL == rtw_pwr_wakeup(padapter)) {
 		ret= -EPERM;
 		goto exit;
 	}
@@ -1512,7 +1512,7 @@ static int cfg80211_rtw_change_iface(str
 	DBG_871X(FUNC_NDEV_FMT" old_iftype=%d, new_iftype=%d\n",
 		FUNC_NDEV_ARG(ndev), old_type, type);
 
-	if(old_type != type)
+	if (old_type != type)
 	{
 		change = true;
 		pmlmeext->action_public_rxseq = 0xffff;
@@ -1529,7 +1529,7 @@ static int cfg80211_rtw_change_iface(str
 	case NL80211_IFTYPE_STATION:
 		networkType = Ndis802_11Infrastructure;
 		#ifdef CONFIG_P2P
-		if(change && rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+		if (change && rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 		{
 			_cancel_timer_ex( &pwdinfo->find_phase_timer );
 			_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
@@ -1549,7 +1549,7 @@ static int cfg80211_rtw_change_iface(str
 	case NL80211_IFTYPE_AP:
 		networkType = Ndis802_11APMode;
 		#ifdef CONFIG_P2P
-		if(change && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		if (change && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
 			//it means P2P Group created, we will be GO and change mode from  P2P DEVICE to AP(GO)
 			rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
@@ -1587,7 +1587,7 @@ void rtw_cfg80211_indicate_scan_done(str
 {
 
 	spin_lock_bh(&pwdev_priv->scan_req_lock);
-	if(pwdev_priv->scan_request != NULL)
+	if (pwdev_priv->scan_request != NULL)
 	{
 		//struct cfg80211_scan_request *scan_request = pwdev_priv->scan_request;
 
@@ -1596,8 +1596,8 @@ void rtw_cfg80211_indicate_scan_done(str
 		#endif
 
 		//avoid WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req);
-		//if(scan_request == wiphy_to_dev(scan_request->wiphy)->scan_req)
-		if(pwdev_priv->scan_request->wiphy != pwdev_priv->rtw_wdev->wiphy)
+		//if (scan_request == wiphy_to_dev(scan_request->wiphy)->scan_req)
+		if (pwdev_priv->scan_request->wiphy != pwdev_priv->rtw_wdev->wiphy)
 		{
 			DBG_8192C("error wiphy compare\n");
 		}
@@ -1648,7 +1648,7 @@ void rtw_cfg80211_surveydone_event_callb
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
 		//report network only if the current channel set contains the channel to which this network belongs
-		if(rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
+		if (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
 			#ifdef CONFIG_VALIDATE_SSID
 			&& true == rtw_validate_ssid(&(pnetwork->network.Ssid))
 			#endif
@@ -1683,15 +1683,15 @@ static int rtw_cfg80211_set_probe_req_wp
 	DBG_8192C("%s, ielen=%d\n", __func__, len);
 #endif
 
-	if(len>0)
+	if (len>0)
 	{
-		if((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
+		if ((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
 		{
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("probe_req_wps_ielen=%d\n", wps_ielen);
 			#endif
 
-			if(pmlmepriv->wps_probe_req_ie)
+			if (pmlmepriv->wps_probe_req_ie)
 			{
 				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 				pmlmepriv->wps_probe_req_ie_len = 0;
@@ -1713,13 +1713,13 @@ static int rtw_cfg80211_set_probe_req_wp
 		//len -= wps_ielen;
 
 		#ifdef CONFIG_P2P
-		if((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
+		if ((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
 		{
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("probe_req_p2p_ielen=%d\n", p2p_ielen);
 			#endif
 
-			if(pmlmepriv->p2p_probe_req_ie)
+			if (pmlmepriv->p2p_probe_req_ie)
 			{
 				u32 free_len = pmlmepriv->p2p_probe_req_ie_len;
 				pmlmepriv->p2p_probe_req_ie_len = 0;
@@ -1742,13 +1742,13 @@ static int rtw_cfg80211_set_probe_req_wp
 		//len -= p2p_ielen;
 
 		#ifdef CONFIG_WFD
-		if(rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
+		if (rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
 		{
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("probe_req_wfd_ielen=%d\n", wfd_ielen);
 			#endif
 
-			if(pmlmepriv->wfd_probe_req_ie)
+			if (pmlmepriv->wfd_probe_req_ie)
 			{
 				u32 free_len = pmlmepriv->wfd_probe_req_ie_len;
 				pmlmepriv->wfd_probe_req_ie_len = 0;
@@ -1806,7 +1806,7 @@ static int cfg80211_rtw_scan(struct wiph
 #endif
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(rtw_buddy_adapter_up(padapter))
+	if (rtw_buddy_adapter_up(padapter))
 	{
 		pbuddy_adapter = padapter->pbuddy_adapter;
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
@@ -1835,18 +1835,18 @@ static int cfg80211_rtw_scan(struct wiph
 		//goto check_need_indicate_scan_done;
 	}
 
-	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (_FAIL == rtw_pwr_wakeup(padapter)) {
 		need_indicate_scan_done = true;
 		goto check_need_indicate_scan_done;
 	}
 
 	#ifdef CONFIG_P2P
-	if(ssids->ssid != NULL
+	if (ssids->ssid != NULL
 		&& _rtw_memcmp(ssids->ssid, "DIRECT-", 7)
 		&& rtw_get_p2p_ie((u8 *)request->ie, request->ie_len, NULL, NULL)
 	)
 	{
-		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
 			rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
 			wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = true;
@@ -1860,7 +1860,7 @@ static int cfg80211_rtw_scan(struct wiph
 		}
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
 
-		if(request->n_channels == 3 &&
+		if (request->n_channels == 3 &&
 			request->channels[0]->hw_value == 1 &&
 			request->channels[1]->hw_value == 6 &&
 			request->channels[2]->hw_value == 11
@@ -1871,7 +1871,7 @@ static int cfg80211_rtw_scan(struct wiph
 	}
 	#endif //CONFIG_P2P
 
-	if(request->ie && request->ie_len>0)
+	if (request->ie && request->ie_len>0)
 	{
 		rtw_cfg80211_set_probe_req_wpsp2pie(padapter, (u8 *)request->ie, request->ie_len );
 	}
@@ -1889,7 +1889,7 @@ static int cfg80211_rtw_scan(struct wiph
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(pbuddy_mlmepriv && (pbuddy_mlmepriv->LinkDetectInfo.bBusyTraffic == true))
+	if (pbuddy_mlmepriv && (pbuddy_mlmepriv->LinkDetectInfo.bBusyTraffic == true))
 	{
 		DBG_8192C("%s, bBusyTraffic == true at buddy_intf\n", __func__);
 		need_indicate_scan_done = true;
@@ -1908,7 +1908,7 @@ static int cfg80211_rtw_scan(struct wiph
 	if (check_buddy_fwstate(padapter,
 		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == true)
 	{
-		if(check_buddy_fwstate(padapter, _FW_UNDER_SURVEY))
+		if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY))
 		{
 			DBG_8192C("scanning_via_buddy_intf\n");
 			pmlmepriv->scanning_via_buddy_intf = true;
@@ -1923,12 +1923,12 @@ static int cfg80211_rtw_scan(struct wiph
 
 
 #ifdef CONFIG_P2P
-	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
+	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 	{
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
 		rtw_free_network_queue(padapter, true);
 
-		if(social_channel == 0)
+		if (social_channel == 0)
 			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
 		else
 			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_SOCIAL_LAST);
@@ -1969,13 +1969,13 @@ static int cfg80211_rtw_scan(struct wiph
 	spin_unlock_bh(&pmlmepriv->lock);
 
 
-	if(_status == false)
+	if (_status == false)
 	{
 		ret = -1;
 	}
 
 check_need_indicate_scan_done:
-	if(need_indicate_scan_done)
+	if (need_indicate_scan_done)
 		rtw_cfg80211_surveydone_event_callback(padapter);
 
 exit:
@@ -2045,7 +2045,7 @@ static int rtw_cfg80211_set_auth_type(st
 
 		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
 
-		if(psecuritypriv->ndisauthtype>Ndis802_11AuthModeWPA)
+		if (psecuritypriv->ndisauthtype>Ndis802_11AuthModeWPA)
 			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
 
 		break;
@@ -2108,11 +2108,11 @@ static int rtw_cfg80211_set_cipher(struc
 		return -ENOTSUPP;
 	}
 
-	if(ucast)
+	if (ucast)
 	{
 		psecuritypriv->ndisencryptstatus = ndisencryptstatus;
 
-		//if(psecuritypriv->dot11PrivacyAlgrthm >= _AES_)
+		//if (psecuritypriv->dot11PrivacyAlgrthm >= _AES_)
 		//	psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPA2PSK;
 	}
 
@@ -2175,16 +2175,16 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 	}
 
 	pos = buf;
-	if(ielen < RSN_HEADER_LEN){
+	if (ielen < RSN_HEADER_LEN){
 		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie len too short %d\n", ielen));
 		ret  = -1;
 		goto exit;
 	}
 
 	pwpa = rtw_get_wpa_ie(buf, &wpa_ielen, ielen);
-	if(pwpa && wpa_ielen>0)
+	if (pwpa && wpa_ielen>0)
 	{
-		if(rtw_parse_wpa_ie(pwpa, wpa_ielen+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		if (rtw_parse_wpa_ie(pwpa, wpa_ielen+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
 			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
 			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPAPSK;
@@ -2195,9 +2195,9 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 	}
 
 	pwpa2 = rtw_get_wpa2_ie(buf, &wpa2_ielen, ielen);
-	if(pwpa2 && wpa2_ielen>0)
+	if (pwpa2 && wpa2_ielen>0)
 	{
-		if(rtw_parse_wpa2_ie(pwpa2, wpa2_ielen+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		if (rtw_parse_wpa2_ie(pwpa2, wpa2_ielen+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
 			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
 			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPA2PSK;
@@ -2285,13 +2285,13 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 		u8 *p2p_ie;
 		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-		if((p2p_ie=rtw_get_p2p_ie(buf, ielen, NULL, &p2p_ielen)))
+		if ((p2p_ie=rtw_get_p2p_ie(buf, ielen, NULL, &p2p_ielen)))
 		{
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("%s p2p_assoc_req_ielen=%d\n", __func__, p2p_ielen);
 			#endif
 
-			if(pmlmepriv->p2p_assoc_req_ie)
+			if (pmlmepriv->p2p_assoc_req_ie)
 			{
 				u32 free_len = pmlmepriv->p2p_assoc_req_ie_len;
 				pmlmepriv->p2p_assoc_req_ie_len = 0;
@@ -2316,13 +2316,13 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 		u8 *wfd_ie;
 		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-		if(rtw_get_wfd_ie(buf, ielen, NULL, &wfd_ielen))
+		if (rtw_get_wfd_ie(buf, ielen, NULL, &wfd_ielen))
 		{
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("%s wfd_assoc_req_ielen=%d\n", __func__, wfd_ielen);
 			#endif
 
-			if(pmlmepriv->wfd_assoc_req_ie)
+			if (pmlmepriv->wfd_assoc_req_ie)
 			{
 				u32 free_len = pmlmepriv->wfd_assoc_req_ie_len;
 				pmlmepriv->wfd_assoc_req_ie_len = 0;
@@ -2341,7 +2341,7 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 	#endif //CONFIG_WFD
 
 	//TKIP and AES disallow multicast packets until installing group key
-	if(padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_
+	if (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
 		//WPS open need to enable multicast
@@ -2383,19 +2383,19 @@ static int cfg80211_rtw_connect(struct w
 		sme->privacy, sme->key, sme->key_len, sme->key_idx);
 
 
-	if(wdev_to_priv(padapter->rtw_wdev)->block == true)
+	if (wdev_to_priv(padapter->rtw_wdev)->block == true)
 	{
 		ret = -EBUSY;
 		DBG_871X("%s wdev_priv.block is set\n", __func__);
 		goto exit;
 	}
 
-	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (_FAIL == rtw_pwr_wakeup(padapter)) {
 		ret= -EPERM;
 		goto exit;
 	}
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 		ret = -EPERM;
 		goto exit;
 	}
@@ -2463,13 +2463,13 @@ static int cfg80211_rtw_connect(struct w
 		dst_ssid = pnetwork->network.Ssid.Ssid;
 		dst_bssid = pnetwork->network.MacAddress;
 
-		if(sme->bssid)  {
-			if(_rtw_memcmp(pnetwork->network.MacAddress, sme->bssid, ETH_ALEN) == false)
+		if (sme->bssid)  {
+			if (_rtw_memcmp(pnetwork->network.MacAddress, sme->bssid, ETH_ALEN) == false)
 				continue;
 		}
 
-		if(sme->ssid && sme->ssid_len) {
-			if(	pnetwork->network.Ssid.SsidLength != sme->ssid_len
+		if (sme->ssid && sme->ssid_len) {
+			if (	pnetwork->network.Ssid.SsidLength != sme->ssid_len
 				|| _rtw_memcmp(pnetwork->network.Ssid.Ssid, sme->ssid, sme->ssid_len) == false
 			)
 				continue;
@@ -2507,7 +2507,7 @@ static int cfg80211_rtw_connect(struct w
 
 	}
 
-	if((matched == false) || (pnetwork== NULL))
+	if ((matched == false) || (pnetwork== NULL))
 	{
 		ret = -ENOENT;
 		DBG_8192C("connect, matched == false, goto exit\n");
@@ -2555,7 +2555,7 @@ static int cfg80211_rtw_connect(struct w
 	}
 
 	//For WEP Shared auth
-	if((psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Shared
+	if ((psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Shared
 		|| psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Auto) && sme->key
 	)
 	{
@@ -2576,7 +2576,7 @@ static int cfg80211_rtw_connect(struct w
 			wep_key_len = wep_key_len <= 5 ? 5 : 13;
 			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
 			pwep =(NDIS_802_11_WEP	 *) rtw_malloc(wep_total_len);
-			if(pwep == NULL){
+			if (pwep == NULL){
 				DBG_871X(" wpa_set_encryption: pwep allocate fail !!!\n");
 				ret = -ENOMEM;
 				goto exit;
@@ -2587,7 +2587,7 @@ static int cfg80211_rtw_connect(struct w
 			pwep->KeyLength = wep_key_len;
 			pwep->Length = wep_total_len;
 
-			if(wep_key_len==13)
+			if (wep_key_len==13)
 			{
 				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
 				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
@@ -2603,13 +2603,13 @@ static int cfg80211_rtw_connect(struct w
 
 		memcpy(pwep->KeyMaterial,  (void *)sme->key, pwep->KeyLength);
 
-		if(rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
+		if (rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
 			ret = -EOPNOTSUPP ;
 
 		if (pwep)
 			kfree((u8 *)pwep);
 
-		if(ret < 0)
+		if (ret < 0)
 			goto exit;
 	}
 
@@ -2652,7 +2652,7 @@ static int cfg80211_rtw_disconnect(struc
 
 	rtw_set_roaming(padapter, 0);
 
-	if(check_fwstate(&padapter->mlmepriv, _FW_LINKED))
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED))
 	{
 		rtw_scan_abort(padapter);
 		LeaveAllPowerSaveMode(padapter);
@@ -2742,7 +2742,7 @@ static int cfg80211_rtw_set_pmksa(struct
 	//overwrite PMKID
 	for(index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
-		if( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==true )
+		if ( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==true )
 		{ // BSSID is matched, the same AP => rewrite with new PMKID.
 			DBG_871X(FUNC_NDEV_FMT" BSSID exists in the PMKList.\n", FUNC_NDEV_ARG(netdev));
 
@@ -2754,7 +2754,7 @@ static int cfg80211_rtw_set_pmksa(struct
 		}
 	}
 
-	if(!blInserted)
+	if (!blInserted)
 	{
 		// Find a new entry
 		DBG_871X(FUNC_NDEV_FMT" Use the new entry index = %d for this PMKID.\n",
@@ -2765,7 +2765,7 @@ static int cfg80211_rtw_set_pmksa(struct
 
 		psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = true;
 		psecuritypriv->PMKIDIndex++ ;
-		if(psecuritypriv->PMKIDIndex==16)
+		if (psecuritypriv->PMKIDIndex==16)
 		{
 			psecuritypriv->PMKIDIndex =0;
 		}
@@ -2786,7 +2786,7 @@ static int cfg80211_rtw_del_pmksa(struct
 
 	for(index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
-		if( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==true )
+		if ( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==true )
 		{ // BSSID is matched, the same AP => Remove this PMKID information and reset it.
 			memset( psecuritypriv->PMKIDList[index].Bssid, 0x00, ETH_ALEN );
 			memset( psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN );
@@ -2796,7 +2796,7 @@ static int cfg80211_rtw_del_pmksa(struct
 		}
 	}
 
-	if(false == bMatched)
+	if (false == bMatched)
 	{
 		DBG_871X(FUNC_NDEV_FMT" do not have matched BSSID\n"
 			, FUNC_NDEV_ARG(netdev));
@@ -2974,7 +2974,7 @@ static int rtw_cfg80211_monitor_if_xmit_
 	if (unlikely(skb->len < rtap_len))
 		goto fail;
 
-	if(rtap_len != 14)
+	if (rtap_len != 14)
 	{
 		DBG_8192C("radiotap len (should be 14): %d\n", rtap_len);
 		goto fail;
@@ -3041,7 +3041,7 @@ static int rtw_cfg80211_monitor_if_xmit_
 		DBG_8192C("RTW_Tx:da=%pM via "FUNC_NDEV_FMT"\n",
 			GetAddr1Ptr(buf), FUNC_NDEV_ARG(ndev));
 		#ifdef CONFIG_P2P
-		if((type = rtw_p2p_check_frames(padapter, buf, len, true)) >= 0)
+		if ((type = rtw_p2p_check_frames(padapter, buf, len, true)) >= 0)
 			goto dump;
 		#endif
 		if (category == RTW_WLAN_CATEGORY_PUBLIC)
@@ -3133,7 +3133,7 @@ static const struct net_device_ops rtw_c
 };
 #endif
 
-static int rtw_cfg80211_add_monitor_if(_adapter *padapter, char *name, struct net_device **ndev)
+static int rtw_cfg80211_add_monitor_if (_adapter *padapter, char *name, struct net_device **ndev)
 {
 	int ret = 0;
 	struct net_device* mon_ndev = NULL;
@@ -3245,7 +3245,7 @@ static int
 		ret = -ENODEV;
 		break;
 	case NL80211_IFTYPE_MONITOR:
-		ret = rtw_cfg80211_add_monitor_if(padapter, (char *)name, &ndev);
+		ret = rtw_cfg80211_add_monitor_if (padapter, (char *)name, &ndev);
 		break;
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
@@ -3322,21 +3322,21 @@ static int rtw_add_beacon(_adapter *adap
 	DBG_8192C("%s beacon_head_len=%zu, beacon_tail_len=%zu\n", __func__, head_len, tail_len);
 
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
-	if(head_len<24)
+	if (head_len<24)
 		return -EINVAL;
 
 
 	pbuf = rtw_zmalloc(head_len+tail_len);
-	if(!pbuf)
+	if (!pbuf)
 		return -ENOMEM;
 
 
 	//memcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);
 
-	//if((pstapriv->max_num_sta>NUM_STA) || (pstapriv->max_num_sta<=0))
+	//if ((pstapriv->max_num_sta>NUM_STA) || (pstapriv->max_num_sta<=0))
 	//	pstapriv->max_num_sta = NUM_STA;
 
 
@@ -3346,12 +3346,12 @@ static int rtw_add_beacon(_adapter *adap
 	len = head_len+tail_len-24;
 
 	//check wps ie if inclued
-	if(rtw_get_wps_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &wps_ielen))
+	if (rtw_get_wps_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &wps_ielen))
 		DBG_8192C("add bcn, wps_ielen=%d\n", wps_ielen);
 
 #ifdef CONFIG_P2P
 	//check p2p ie if inclued
-	if(rtw_get_p2p_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &p2p_ielen))
+	if (rtw_get_p2p_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &p2p_ielen))
 	{
 		DBG_8192C("got p2p_ie, len=%d\n", p2p_ielen);
 		got_p2p_ie = true;
@@ -3361,17 +3361,17 @@ static int rtw_add_beacon(_adapter *adap
 	rtw_ies_remove_ie(pbuf, &len, _BEACON_IE_OFFSET_, _VENDOR_SPECIFIC_IE_, P2P_OUI, 4);
 
 	// pbss_network->IEs will not include p2p_ie
-	if(rtw_check_beacon_data(adapter, pbuf,  len) == _SUCCESS)
-	//if(rtw_check_beacon_data(padapter, pbuf,  len) == _SUCCESS)
+	if (rtw_check_beacon_data(adapter, pbuf,  len) == _SUCCESS)
+	//if (rtw_check_beacon_data(padapter, pbuf,  len) == _SUCCESS)
 	{
 #ifdef  CONFIG_P2P
 		//check p2p if enable
-		if(got_p2p_ie == true)
+		if (got_p2p_ie == true)
 		{
 			struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
 			struct wifidirect_info *pwdinfo= &(adapter->wdinfo);
 
-			if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 			{
 				DBG_8192C("Enable P2P function for the first time\n");
 				rtw_p2p_enable(adapter, P2P_ROLE_GO);
@@ -3462,7 +3462,7 @@ static int cfg80211_rtw_start_ap(struct
 		struct wlan_bssid_ex *pbss_network = &adapter->mlmepriv.cur_network.network;
 		struct wlan_bssid_ex *pbss_network_ext = &adapter->mlmeextpriv.mlmext_info.network;
 
-		if(0)
+		if (0)
 		DBG_871X(FUNC_ADPT_FMT" ssid:(%s,%d), from ie:(%s,%d)\n", FUNC_ADPT_ARG(adapter),
 			settings->ssid, settings->ssid_len,
 			pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength);
@@ -3472,7 +3472,7 @@ static int cfg80211_rtw_start_ap(struct
 		memcpy(pbss_network_ext->Ssid.Ssid, (void *)settings->ssid, settings->ssid_len);
 		pbss_network_ext->Ssid.SsidLength = settings->ssid_len;
 
-		if(0)
+		if (0)
 		DBG_871X(FUNC_ADPT_FMT" after ssid:(%s,%d), (%s,%d)\n", FUNC_ADPT_ARG(adapter),
 			pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength,
 			pbss_network_ext->Ssid.Ssid, pbss_network_ext->Ssid.SsidLength);
@@ -3523,14 +3523,14 @@ static int	cfg80211_rtw_del_station(stru
 
 	DBG_871X("+"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
-	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)
 	{
 		DBG_8192C("%s, fw_state != FW_LINKED|WIFI_AP_STATE\n", __func__);
 		return -EINVAL;
 	}
 
 
-	if(!mac)
+	if (!mac)
 	{
 		DBG_8192C("flush all sta, and cam_entry\n");
 
@@ -3564,9 +3564,9 @@ static int	cfg80211_rtw_del_station(stru
 
 		plist = get_next(plist);
 
-		if(_rtw_memcmp(mac, psta->hwaddr, ETH_ALEN))
+		if (_rtw_memcmp(mac, psta->hwaddr, ETH_ALEN))
 		{
-			if(psta->dot8021xalg == 1 && psta->bpairwise_key_installed == false)
+			if (psta->dot8021xalg == 1 && psta->bpairwise_key_installed == false)
 			{
 				DBG_8192C("%s, sta's dot8021xalg = 1 and key_installed = false\n", __func__);
 			}
@@ -3990,7 +3990,7 @@ void rtw_cfg80211_issue_p2p_provision_re
 	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS)
 		DBG_8192C("%s, ack to\n", __func__);
 
-	//if(wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC)
+	//if (wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC)
 	//{
 	//	DBG_8192C("waiting for p2p peer key-in PIN CODE\n");
 	//	rtw_msleep_os(15000); // 15 sec for key in PIN CODE, workaround for GS2 before issuing Nego Req.
@@ -4021,7 +4021,7 @@ static s32 cfg80211_rtw_remain_on_channe
 
 	DBG_871X(FUNC_ADPT_FMT" ch:%u duration:%d\n", FUNC_ADPT_ARG(padapter), remain_ch, duration);
 
-	if(pcfg80211_wdinfo->is_ro_ch == true)
+	if (pcfg80211_wdinfo->is_ro_ch == true)
 	{
 		DBG_8192C("%s, cancel ro ch timer\n", __func__);
 
@@ -4036,7 +4036,7 @@ static s32 cfg80211_rtw_remain_on_channe
 
 	pcfg80211_wdinfo->is_ro_ch = true;
 
-	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (_FAIL == rtw_pwr_wakeup(padapter)) {
 		err = -EFAULT;
 		goto exit;
 	}
@@ -4049,12 +4049,12 @@ static s32 cfg80211_rtw_remain_on_channe
 
 	rtw_scan_abort(padapter);
 #ifdef CONFIG_CONCURRENT_MODE
-	if(rtw_buddy_adapter_up(padapter))
+	if (rtw_buddy_adapter_up(padapter))
 		rtw_scan_abort(padapter->pbuddy_adapter);
 #endif //CONFIG_CONCURRENT_MODE
 
-	//if(!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) && !rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	//if (!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) && !rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
 		wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = true;
@@ -4071,12 +4071,12 @@ static s32 cfg80211_rtw_remain_on_channe
 	rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
 
 
-	if(duration < 400)
+	if (duration < 400)
 		duration = duration*3;//extend from exper.
 
 
 #ifdef	CONFIG_CONCURRENT_MODE
-	if(check_buddy_fwstate(padapter, _FW_LINKED) &&
+	if (check_buddy_fwstate(padapter, _FW_LINKED) &&
 		(duration<pwdinfo->ext_listen_interval))
 	{
 		duration = duration +	pwdinfo->ext_listen_interval;
@@ -4085,16 +4085,16 @@ static s32 cfg80211_rtw_remain_on_channe
 
 	pcfg80211_wdinfo->restore_channel = pmlmeext->cur_channel;
 
-	if(rtw_ch_set_search_ch(pmlmeext->channel_set, remain_ch) >= 0) {
+	if (rtw_ch_set_search_ch(pmlmeext->channel_set, remain_ch) >= 0) {
 #ifdef	CONFIG_CONCURRENT_MODE
 		if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
 		{
 			PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
 			struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
-			if(remain_ch != pbuddy_mlmeext->cur_channel)
+			if (remain_ch != pbuddy_mlmeext->cur_channel)
 			{
-				if(ATOMIC_READ(&pwdev_priv->switch_ch_to)==1 ||
+				if (ATOMIC_READ(&pwdev_priv->switch_ch_to)==1 ||
 					(remain_ch != pmlmeext->cur_channel))
 				{
 					DBG_8192C("%s, issue nulldata pwrbit=1\n", __func__);
@@ -4112,7 +4112,7 @@ static s32 cfg80211_rtw_remain_on_channe
 			//set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 		}else
 #endif //CONFIG_CONCURRENT_MODE
-		if(remain_ch != pmlmeext->cur_channel )
+		if (remain_ch != pmlmeext->cur_channel )
 		{
 			ready_on_channel = true;
 			//pmlmeext->cur_channel = remain_ch;
@@ -4125,14 +4125,14 @@ static s32 cfg80211_rtw_remain_on_channe
 
 	//call this after other things have been done
 #ifdef	CONFIG_CONCURRENT_MODE
-	if(ATOMIC_READ(&pwdev_priv->ro_ch_to)==1 ||
+	if (ATOMIC_READ(&pwdev_priv->ro_ch_to)==1 ||
 		(remain_ch != pmlmeext->cur_channel))
 	{
 		u8 co_channel = 0xff;
 		ATOMIC_SET(&pwdev_priv->ro_ch_to, 0);
 #endif
 
-		if(ready_on_channel == true)
+		if (ready_on_channel == true)
 		{
 			if ( !check_fwstate(&padapter->mlmepriv, _FW_LINKED ) )
 				pmlmeext->cur_channel = remain_ch;
@@ -4140,7 +4140,7 @@ static s32 cfg80211_rtw_remain_on_channe
 #ifdef	CONFIG_CONCURRENT_MODE
 			co_channel = rtw_get_oper_ch(padapter);
 
-			if(co_channel !=remain_ch)
+			if (co_channel !=remain_ch)
 #endif
 				set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 		}
@@ -4215,7 +4215,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 	//struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 
-	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (_FAIL == rtw_pwr_wakeup(padapter)) {
 		ret = -EFAULT;
 		goto exit;
 	}
@@ -4224,7 +4224,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 
 	rtw_scan_abort(padapter);
 	#ifdef CONFIG_CONCURRENT_MODE
-	if(rtw_buddy_adapter_up(padapter))
+	if (rtw_buddy_adapter_up(padapter))
 		rtw_scan_abort(padapter->pbuddy_adapter);
 	#endif /* CONFIG_CONCURRENT_MODE */
 
@@ -4269,7 +4269,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 	}else
 #endif //CONFIG_CONCURRENT_MODE
 	//if (tx_ch != pmlmeext->cur_channel) {
-	if(tx_ch != rtw_get_oper_ch(padapter)) {
+	if (tx_ch != rtw_get_oper_ch(padapter)) {
 		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED ))
 			pmlmeext->cur_channel = tx_ch;
 		set_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
@@ -4420,7 +4420,7 @@ static int cfg80211_rtw_mgmt_tx(struct w
 
 	DBG_8192C("RTW_Tx:tx_ch=%d, da=%pM\n", tx_ch, GetAddr1Ptr(buf));
 	#ifdef CONFIG_P2P
-	if((type = rtw_p2p_check_frames(padapter, buf, len, true)) >= 0)
+	if ((type = rtw_p2p_check_frames(padapter, buf, len, true)) >= 0)
 		goto dump;
 	#endif
 	if (category == RTW_WLAN_CATEGORY_PUBLIC)
@@ -4497,15 +4497,15 @@ static int rtw_cfg80211_set_beacon_wpsp2
 
 	DBG_871X(FUNC_NDEV_FMT" ielen=%d\n", FUNC_NDEV_ARG(ndev), len);
 
-	if(len>0)
+	if (len>0)
 	{
-		if((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
+		if ((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
 		{
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("bcn_wps_ielen=%d\n", wps_ielen);
 			#endif
 
-			if(pmlmepriv->wps_beacon_ie)
+			if (pmlmepriv->wps_beacon_ie)
 			{
 				u32 free_len = pmlmepriv->wps_beacon_ie_len;
 				pmlmepriv->wps_beacon_ie_len = 0;
@@ -4531,13 +4531,13 @@ static int rtw_cfg80211_set_beacon_wpsp2
 		//len -= wps_ielen;
 
 		#ifdef CONFIG_P2P
-		if((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
+		if ((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
 		{
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("bcn_p2p_ielen=%d\n", p2p_ielen);
 			#endif
 
-			if(pmlmepriv->p2p_beacon_ie)
+			if (pmlmepriv->p2p_beacon_ie)
 			{
 				u32 free_len = pmlmepriv->p2p_beacon_ie_len;
 				pmlmepriv->p2p_beacon_ie_len = 0;
@@ -4562,13 +4562,13 @@ static int rtw_cfg80211_set_beacon_wpsp2
 		//len -= p2p_ielen;
 
 		#ifdef CONFIG_WFD
-		if(rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
+		if (rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
 		{
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("bcn_wfd_ielen=%d\n", wfd_ielen);
 			#endif
 
-			if(pmlmepriv->wfd_beacon_ie)
+			if (pmlmepriv->wfd_beacon_ie)
 			{
 				u32 free_len = pmlmepriv->wfd_beacon_ie_len;
 				pmlmepriv->wfd_beacon_ie_len = 0;
@@ -4610,9 +4610,9 @@ static int rtw_cfg80211_set_probe_resp_w
 	DBG_8192C("%s, ielen=%d\n", __func__, len);
 #endif
 
-	if(len>0)
+	if (len>0)
 	{
-		if((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
+		if ((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
 		{
 			uint	attr_contentlen = 0;
 			u16	uconfig_method, *puconfig_method = NULL;
@@ -4621,7 +4621,7 @@ static int rtw_cfg80211_set_probe_resp_w
 			DBG_8192C("probe_resp_wps_ielen=%d\n", wps_ielen);
 			#endif
 
-			if(pmlmepriv->wps_probe_resp_ie)
+			if (pmlmepriv->wps_probe_resp_ie)
 			{
 				u32 free_len = pmlmepriv->wps_probe_resp_ie_len;
 				pmlmepriv->wps_probe_resp_ie_len = 0;
@@ -4658,7 +4658,7 @@ static int rtw_cfg80211_set_probe_resp_w
 		//len -= wps_ielen;
 
 		#ifdef CONFIG_P2P
-		if((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
+		if ((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
 		{
 			u8 is_GO = false;
 			u32 attr_contentlen = 0;
@@ -4669,7 +4669,7 @@ static int rtw_cfg80211_set_probe_resp_w
 			#endif
 
 			//Check P2P Capability ATTR
-			if( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*) &attr_contentlen) )
+			if ( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*) &attr_contentlen) )
 			{
 				u8 grp_cap=0;
 				//DBG_8192C( "[%s] Got P2P Capability Attr!!\n", __func__ );
@@ -4678,14 +4678,14 @@ static int rtw_cfg80211_set_probe_resp_w
 
 				is_GO = (grp_cap&BIT(0)) ? true:false;
 
-				if(is_GO)
+				if (is_GO)
 					DBG_8192C("Got P2P Capability Attr, grp_cap=0x%x, is_GO\n", grp_cap);
 			}
 
 
-			if(is_GO == false)
+			if (is_GO == false)
 			{
-				if(pmlmepriv->p2p_probe_resp_ie)
+				if (pmlmepriv->p2p_probe_resp_ie)
 				{
 					u32 free_len = pmlmepriv->p2p_probe_resp_ie_len;
 					pmlmepriv->p2p_probe_resp_ie_len = 0;
@@ -4704,7 +4704,7 @@ static int rtw_cfg80211_set_probe_resp_w
 			}
 			else
 			{
-				if(pmlmepriv->p2p_go_probe_resp_ie)
+				if (pmlmepriv->p2p_go_probe_resp_ie)
 				{
 					u32 free_len = pmlmepriv->p2p_go_probe_resp_ie_len;
 					pmlmepriv->p2p_go_probe_resp_ie_len = 0;
@@ -4729,13 +4729,13 @@ static int rtw_cfg80211_set_probe_resp_w
 		//len -= p2p_ielen;
 
 		#ifdef CONFIG_WFD
-		if(rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
+		if (rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
 		{
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("probe_resp_wfd_ielen=%d\n", wfd_ielen);
 			#endif
 
-			if(pmlmepriv->wfd_probe_resp_ie)
+			if (pmlmepriv->wfd_probe_resp_ie)
 			{
 				u32 free_len = pmlmepriv->wfd_probe_resp_ie_len;
 				pmlmepriv->wfd_probe_resp_ie_len = 0;
@@ -4767,9 +4767,9 @@ static int rtw_cfg80211_set_assoc_resp_w
 
 	DBG_8192C("%s, ielen=%d\n", __func__, len);
 
-	if(len>0)
+	if (len>0)
 	{
-		if(pmlmepriv->wps_assoc_resp_ie)
+		if (pmlmepriv->wps_assoc_resp_ie)
 		{
 			u32 free_len = pmlmepriv->wps_assoc_resp_ie_len;
 			pmlmepriv->wps_assoc_resp_ie_len = 0;
@@ -4802,7 +4802,7 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struc
 	DBG_8192C("%s, ielen=%d\n", __func__, len);
 #endif
 
-	if(	(rtw_get_wps_ie(buf, len, NULL, &wps_ielen) && (wps_ielen>0))
+	if (	(rtw_get_wps_ie(buf, len, NULL, &wps_ielen) && (wps_ielen>0))
 		#ifdef CONFIG_P2P
 		|| (rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen) && (p2p_ielen>0))
 		#endif
@@ -4921,7 +4921,7 @@ static void rtw_cfg80211_init_ht_capab(s
 	 *if BW_40 rx_mask[4]=0x01;
 	 *highest supported RX rate
 	 */
-	if(rf_type == RF_1T1R)
+	if (rf_type == RF_1T1R)
 	{
 		ht_cap->mcs.rx_mask[0] = 0xFF;
 		ht_cap->mcs.rx_mask[1] = 0x00;
@@ -4929,7 +4929,7 @@ static void rtw_cfg80211_init_ht_capab(s
 
 		ht_cap->mcs.rx_highest = MAX_BIT_RATE_40MHZ_MCS7;
 	}
-	else if((rf_type == RF_1T2R) || (rf_type==RF_2T2R))
+	else if ((rf_type == RF_1T2R) || (rf_type==RF_2T2R))
 	{
 		ht_cap->mcs.rx_mask[0] = 0xFF;
 		ht_cap->mcs.rx_mask[1] = 0xFF;
@@ -4958,14 +4958,14 @@ void rtw_cfg80211_init_wiphy(_adapter *p
 	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11G) */
 	{
 		bands = wiphy->bands[IEEE80211_BAND_2GHZ];
-		if(bands)
+		if (bands)
 			rtw_cfg80211_init_ht_capab(&bands->ht_cap, IEEE80211_BAND_2GHZ, rf_type);
 	}
 
 	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11A) */
 	{
 		bands = wiphy->bands[IEEE80211_BAND_5GHZ];
-		if(bands)
+		if (bands)
 			rtw_cfg80211_init_ht_capab(&bands->ht_cap, IEEE80211_BAND_5GHZ, rf_type);
 	}
 }
@@ -5048,7 +5048,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 	wiphy->flags |= WIPHY_FLAG_OFFCHAN_TX | WIPHY_FLAG_HAVE_AP_SME;
 #endif
 
-	if(padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
+	if (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
 		wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
 	else
 		wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
@@ -5109,7 +5109,7 @@ int rtw_wdev_alloc(_adapter *padapter, s
 
 	pwdev_priv->bandroid_scan = false;
 
-	if(padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
+	if (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
 		pwdev_priv->power_mgmt = true;
 	else
 		pwdev_priv->power_mgmt = false;
--- a/drivers/staging/rtl8192du/os_dep/mlme_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/mlme_linux.c
@@ -88,7 +88,7 @@ _func_enter_;
 	rtw_indicate_wx_assoc_event(adapter);
 	netif_carrier_on(adapter->pnetdev);
 
-	if(adapter->pid[2] !=0)
+	if (adapter->pid[2] !=0)
 		rtw_signal_process(adapter->pid[2], SIGALRM);
 
 _func_exit_;
@@ -110,7 +110,7 @@ void rtw_reset_securitypriv(struct rtw_a
 	u8	backupTKIPCountermeasure = 0x00;
 	u32	backupTKIPcountermeasure_time = 0;
 
-	if(adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)//802.1x
+	if (adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)//802.1x
 	{
 		// Added by Albert 2009/02/18
 		// We have to backup the PMK information for WiFi PMK Caching test item.
@@ -141,7 +141,7 @@ void rtw_reset_securitypriv(struct rtw_a
 	}
 	else //reset values in securitypriv
 	{
-		//if(adapter->mlmepriv.fw_state & WIFI_STATION_STATE)
+		//if (adapter->mlmepriv.fw_state & WIFI_STATION_STATE)
 		//{
 		struct security_priv *psec_priv=&adapter->securitypriv;
 
@@ -189,7 +189,7 @@ _func_enter_;
 	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+rtw_report_sec_ie, authmode=%d\n", authmode));
 
 	buff = NULL;
-	if(authmode==_WPA_IE_ID_)
+	if (authmode==_WPA_IE_ID_)
 	{
 		RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("rtw_report_sec_ie, authmode=%d\n", authmode));
 
@@ -284,13 +284,13 @@ void rtw_indicate_sta_assoc_event(struct
 	union iwreq_data wrqu;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
-	if(psta==NULL)
+	if (psta==NULL)
 		return;
 
-	if(psta->aid > NUM_STA)
+	if (psta->aid > NUM_STA)
 		return;
 
-	if(pstapriv->sta_aid[psta->aid - 1] != psta)
+	if (pstapriv->sta_aid[psta->aid - 1] != psta)
 		return;
 
 
@@ -309,13 +309,13 @@ void rtw_indicate_sta_disassoc_event(str
 	union iwreq_data wrqu;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
-	if(psta==NULL)
+	if (psta==NULL)
 		return;
 
-	if(psta->aid > NUM_STA)
+	if (psta->aid > NUM_STA)
 		return;
 
-	if(pstapriv->sta_aid[psta->aid - 1] != psta)
+	if (pstapriv->sta_aid[psta->aid - 1] != psta)
 		return;
 
 
@@ -351,7 +351,7 @@ static int mgnt_netdev_open(struct net_d
 
 	init_usb_anchor(&phostapdpriv->anchored);
 
-	if(!netif_queue_stopped(pnetdev))
+	if (!netif_queue_stopped(pnetdev))
 		netif_start_queue(pnetdev);
 	else
 		netif_wake_queue(pnetdev);
@@ -446,7 +446,7 @@ int hostapd_mode_init(struct rtw_adapter
 
 
 
-	if(dev_alloc_name(pnetdev,"mgnt.wlan%d") < 0)
+	if (dev_alloc_name(pnetdev,"mgnt.wlan%d") < 0)
 	{
 		DBG_8192D("hostapd_mode_init(): dev_alloc_name, fail! \n");
 	}
@@ -473,7 +473,7 @@ int hostapd_mode_init(struct rtw_adapter
 	{
 		DBG_8192D("hostapd_mode_init(): register_netdev fail!\n");
 
-		if(pnetdev)
+		if (pnetdev)
 		{
 			rtw_free_netdev(pnetdev);
 		}
--- a/drivers/staging/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8192du/os_dep/osdep_service.c
@@ -34,7 +34,7 @@
 * @return: one of RTW_STATUS_CODE
 */
 inline int RTW_STATUS_CODE(int error_code){
-	if(error_code >=0)
+	if (error_code >=0)
 		return _SUCCESS;
 
 	switch(error_code) {
@@ -52,15 +52,15 @@ u32 rtw_atoi(u8* s)
 	int i;
 	for(i=0;i<=strlen(s);i++)
 	{
-	  if(s[i] >= '0' && s[i] <= '9')
+	  if (s[i] >= '0' && s[i] <= '9')
 		 num = num * 10 + s[i] -'0';
-	  else if(s[0] == '-' && i==0)
+	  else if (s[0] == '-' && i==0)
 		 flag =1;
 	  else
 		  break;
 	 }
 
-	if(flag == 1)
+	if (flag == 1)
 	   num = num * -1;
 
 	 return(num);
@@ -430,7 +430,7 @@ static int openFile(struct file **fpp, c
 	struct file *fp;
 
 	fp=filp_open(path, flag, mode);
-	if(IS_ERR(fp)) {
+	if (IS_ERR(fp)) {
 		*fpp=NULL;
 		return PTR_ERR(fp);
 	}
@@ -460,9 +460,9 @@ static int readFile(struct file *fp,char
 
 	while(sum<len) {
 		rlen=fp->f_op->read(fp,buf+sum,len-sum, &fp->f_pos);
-		if(rlen>0)
+		if (rlen>0)
 			sum+=rlen;
-		else if(0 != rlen)
+		else if (0 != rlen)
 			return rlen;
 		else
 			break;
@@ -481,9 +481,9 @@ static int writeFile(struct file *fp,cha
 
 	while(sum<len) {
 		wlen=fp->f_op->write(fp,buf+sum,len-sum, &fp->f_pos);
-		if(wlen>0)
+		if (wlen>0)
 			sum+=wlen;
-		else if(0 != wlen)
+		else if (0 != wlen)
 			return wlen;
 		else
 			break;
@@ -506,13 +506,13 @@ static int isFileReadable(char *path)
 	char buf;
 
 	fp=filp_open(path, O_RDONLY, 0);
-	if(IS_ERR(fp)) {
+	if (IS_ERR(fp)) {
 		ret = PTR_ERR(fp);
 	}
 	else {
 		oldfs = get_fs(); set_fs(get_ds());
 
-		if(1!=readFile(fp, &buf, 1))
+		if (1!=readFile(fp, &buf, 1))
 			ret = PTR_ERR(fp);
 
 		set_fs(oldfs);
@@ -534,8 +534,8 @@ static int retriveFromFile(char *path, u
 	mm_segment_t oldfs;
 	struct file *fp;
 
-	if(path && buf) {
-		if( 0 == (ret=openFile(&fp,path, O_RDONLY, 0)) ){
+	if (path && buf) {
+		if ( 0 == (ret=openFile(&fp,path, O_RDONLY, 0)) ){
 			DBG_8192D("%s openFile path:%s fp=%p\n",__func__, path ,fp);
 
 			oldfs = get_fs(); set_fs(get_ds());
@@ -568,8 +568,8 @@ static int storeToFile(char *path, u8* b
 	mm_segment_t oldfs;
 	struct file *fp;
 
-	if(path && buf) {
-		if( 0 == (ret=openFile(&fp, path, O_CREAT|O_WRONLY, 0666)) ) {
+	if (path && buf) {
+		if ( 0 == (ret=openFile(&fp, path, O_CREAT|O_WRONLY, 0666)) ) {
 			DBG_8192D("%s openFile path:%s fp=%p\n",__func__, path ,fp);
 
 			oldfs = get_fs(); set_fs(get_ds());
@@ -596,7 +596,7 @@ static int storeToFile(char *path, u8* b
 */
 int rtw_is_file_readable(char *path)
 {
-	if(isFileReadable(path) == 0)
+	if (isFileReadable(path) == 0)
 		return true;
 	else
 		return false;
@@ -680,12 +680,12 @@ void rtw_free_netdev(struct net_device *
 {
 	struct rtw_netdev_priv_indicator *pnpi;
 
-	if(!netdev)
+	if (!netdev)
 		goto RETURN;
 
 	pnpi = netdev_priv(netdev);
 
-	if(!pnpi->priv)
+	if (!pnpi->priv)
 		goto RETURN;
 
 	rtw_vmfree(pnpi->priv, pnpi->sizeof_priv);
@@ -706,19 +706,19 @@ int rtw_change_ifname(struct rtw_adapter
 	struct rereg_nd_name_data *rereg_priv;
 	int ret;
 
-	if(!padapter)
+	if (!padapter)
 		goto error;
 
 	rereg_priv = &padapter->rereg_nd_name_priv;
 
 	//free the old_pnetdev
-	if(rereg_priv->old_pnetdev) {
+	if (rereg_priv->old_pnetdev) {
 		free_netdev(rereg_priv->old_pnetdev);
 		rereg_priv->old_pnetdev = NULL;
 	}
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
-	if(!rtnl_is_locked())
+	if (!rtnl_is_locked())
 		unregister_netdev(cur_pnetdev);
 	else
 #endif
@@ -741,7 +741,7 @@ int rtw_change_ifname(struct rtw_adapter
 	memcpy(pnetdev->dev_addr, padapter->eeprompriv.mac_addr, ETH_ALEN);
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
-	if(!rtnl_is_locked())
+	if (!rtnl_is_locked())
 		ret = register_netdev(pnetdev);
 	else
 #endif
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -67,7 +67,7 @@ int rtw_os_recvbuf_resource_alloc(struct
 
 	precvbuf->irp_pending = false;
 	precvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);
-	if(precvbuf->purb == NULL){
+	if (precvbuf->purb == NULL){
 		res = _FAIL;
 	}
 
@@ -86,7 +86,7 @@ int rtw_os_recvbuf_resource_alloc(struct
 	#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
 	precvbuf->pallocated_buf = rtw_usb_buffer_alloc(pusbd, (size_t)precvbuf->alloc_sz, GFP_ATOMIC, &precvbuf->dma_transfer_addr);
 	precvbuf->pbuf = precvbuf->pallocated_buf;
-	if(precvbuf->pallocated_buf == NULL)
+	if (precvbuf->pallocated_buf == NULL)
 		return _FAIL;
 	#endif //CONFIG_USE_USB_BUFFER_ALLOC_RX
 	return res;
@@ -108,13 +108,13 @@ int rtw_os_recvbuf_resource_free(struct
 
 #endif //CONFIG_USE_USB_BUFFER_ALLOC_RX
 
-	if(precvbuf->purb)
+	if (precvbuf->purb)
 	{
 		//usb_kill_urb(precvbuf->purb);
 		usb_free_urb(precvbuf->purb);
 	}
 
-	if(precvbuf->pskb)
+	if (precvbuf->pskb)
 		dev_kfree_skb_any(precvbuf->pskb);
 
 
@@ -133,7 +133,7 @@ void rtw_handle_tkip_mic_err(struct rtw_
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 	u32 cur_time = 0;
 
-	if( psecuritypriv->last_mic_err_time == 0 )
+	if ( psecuritypriv->last_mic_err_time == 0 )
 	{
 		psecuritypriv->last_mic_err_time = rtw_get_current_time();
 	}
@@ -141,7 +141,7 @@ void rtw_handle_tkip_mic_err(struct rtw_
 	{
 		cur_time = rtw_get_current_time();
 
-		if( cur_time - psecuritypriv->last_mic_err_time < 60*HZ )
+		if ( cur_time - psecuritypriv->last_mic_err_time < 60*HZ )
 		{
 			psecuritypriv->btkip_countermeasure = true;
 			psecuritypriv->last_mic_err_time = 0;
@@ -205,7 +205,7 @@ void rtw_hostapd_mlme_rx(struct rtw_adap
 	skb->len = precv_frame->u.hdr.len;
 
 	//pskb_copy = skb_copy(skb, GFP_ATOMIC);
-//	if(skb == NULL) goto _exit;
+//	if (skb == NULL) goto _exit;
 
 	skb->dev = pmgnt_netdev;
 	skb->ip_summed = CHECKSUM_NONE;
@@ -254,7 +254,7 @@ _func_enter_;
 #endif
 
 	skb = precv_frame->u.hdr.pkt;
-	if(skb == NULL)
+	if (skb == NULL)
 	{
 		RT_TRACE(_module_recv_osdep_c_,_drv_err_,("rtw_recv_indicatepkt():skb==NULL something wrong!!!!\n"));
 		goto _recv_indicatepkt_drop;
@@ -272,7 +272,7 @@ _func_enter_;
 
 	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n skb->head=%p skb->data=%p skb->tail=%p skb->end=%p skb->len=%d\n", skb->head, skb->data, skb->tail, skb->end, skb->len));
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		struct sk_buff *pskb2=NULL;
 		struct sta_info *psta = NULL;
@@ -282,11 +282,11 @@ _func_enter_;
 
 		//DBG_871X("bmcast=%d\n", bmcast);
 
-		if(_rtw_memcmp(pattrib->dst, myid(&padapter->eeprompriv), ETH_ALEN)==false)
+		if (_rtw_memcmp(pattrib->dst, myid(&padapter->eeprompriv), ETH_ALEN)==false)
 		{
 			//DBG_871X("not ap psta=%p, addr=%pM\n", psta, pattrib->dst);
 
-			if(bmcast)
+			if (bmcast)
 			{
 				psta = rtw_get_bcmc_stainfo(padapter);
 				pskb2 = skb_clone(skb, GFP_ATOMIC);
@@ -294,7 +294,7 @@ _func_enter_;
 				psta = rtw_get_stainfo(pstapriv, pattrib->dst);
 			}
 
-			if(psta)
+			if (psta)
 			{
 				struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;
 
@@ -308,7 +308,7 @@ _func_enter_;
 
 				rtw_xmit_entry(skb, pnetdev);
 
-				if(bmcast)
+				if (bmcast)
 					skb = pskb2;
 				else
 					goto _recv_indicatepkt_end;
@@ -333,7 +333,7 @@ _func_enter_;
 	rcu_read_unlock();
 #endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 
-	if( br_port	&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) )
+	if ( br_port	&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) )
 	{
 		int nat25_handle_frame(struct rtw_adapter *priv, struct sk_buff *skb);
 		if (nat25_handle_frame(padapter, skb) == -1) {
@@ -385,7 +385,7 @@ _func_exit_;
 _recv_indicatepkt_drop:
 
 	 //enqueue back to free_recv_queue
-	 if(precv_frame)
+	 if (precv_frame)
 		 rtw_free_recvframe(precv_frame, pfree_recv_queue);
 
 	 return _FAIL;
@@ -406,7 +406,7 @@ void rtw_os_read_port(struct rtw_adapter
 	precvbuf->pskb = NULL;
 	precvbuf->reuse = false;
 
-	if(precvbuf->irp_pending == false)
+	if (precvbuf->irp_pending == false)
 		rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
 }
 
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -228,7 +228,7 @@ int rtw_android_cmdstr_to_num(char *cmds
 {
 	int cmd_num;
 	for(cmd_num=0 ; cmd_num<ANDROID_WIFI_CMD_MAX; cmd_num++)
-		if(0 == strnicmp(cmdstr , android_wifi_cmd_str[cmd_num], strlen(android_wifi_cmd_str[cmd_num])) )
+		if (0 == strnicmp(cmdstr , android_wifi_cmd_str[cmd_num], strlen(android_wifi_cmd_str[cmd_num])) )
 			break;
 
 	return cmd_num;
@@ -241,7 +241,7 @@ static int rtw_android_get_rssi(struct n
 	struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
 	int bytes_written = 0;
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
 		bytes_written += snprintf(&command[bytes_written], total_len, "%s rssi %d",
 			pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
 	}
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -518,7 +518,7 @@ static void usb_intf_stop(struct rtw_ada
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+usb_intf_stop\n"));
 
 	//disabel_hw_interrupt
-	if(padapter->bSurpriseRemoved == false)
+	if (padapter->bSurpriseRemoved == false)
 	{
 		//device still exists, so driver can do i/o operation
 		//TODO:
@@ -543,7 +543,7 @@ static void rtw_dev_unload(struct rtw_ad
 	u8 val8;
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_dev_unload\n"));
 
-	if(padapter->bup == true)
+	if (padapter->bup == true)
 	{
 		DBG_8192D("===> rtw_dev_unload\n");
 
@@ -554,22 +554,22 @@ static void rtw_dev_unload(struct rtw_ad
 		#endif
 
 		//s3.
-		if(padapter->intf_stop)
+		if (padapter->intf_stop)
 		{
 			padapter->intf_stop(padapter);
 		}
 
 		//s4.
-		if(!padapter->pwrctrlpriv.bInternalAutoSuspend )
+		if (!padapter->pwrctrlpriv.bInternalAutoSuspend )
 		rtw_stop_drv_threads(padapter);
 
 
 		//s5.
-		if(padapter->bSurpriseRemoved == false)
+		if (padapter->bSurpriseRemoved == false)
 		{
 			//DBG_8192D("r871x_dev_unload()->rtl871x_hal_deinit()\n");
 #ifdef CONFIG_WOWLAN
-			if((padapter->pwrctrlpriv.bSupportRemoteWakeup==true)&&(padapter->pwrctrlpriv.wowlan_mode==true)){
+			if ((padapter->pwrctrlpriv.bSupportRemoteWakeup==true)&&(padapter->pwrctrlpriv.wowlan_mode==true)){
 				DBG_8192D("%s bSupportWakeOnWlan==true  do not run rtw_hal_deinit()\n",__func__);
 			}
 			else
@@ -610,7 +610,7 @@ static void process_spec_devid(const str
 		flags = specific_device_id_tbl[i].flags;
 
 #ifdef CONFIG_80211N_HT
-		if((pdid->idVendor==vid) && (pdid->idProduct==pid) && (flags&SPEC_DEV_ID_DISABLE_HT))
+		if ((pdid->idVendor==vid) && (pdid->idProduct==pid) && (flags&SPEC_DEV_ID_DISABLE_HT))
 		{
 			 rtw_ht_enable = 0;
 			 rtw_cbw40_enable = 0;
@@ -630,14 +630,14 @@ int rtw_hw_suspend(struct rtw_adapter *p
 
 	_func_enter_;
 
-	if((!padapter->bup) || (padapter->bDriverStopped)||(padapter->bSurpriseRemoved))
+	if ((!padapter->bup) || (padapter->bDriverStopped)||(padapter->bSurpriseRemoved))
 	{
 		DBG_8192D("padapter->bup=%d bDriverStopped=%d bSurpriseRemoved = %d\n",
 			padapter->bup, padapter->bDriverStopped,padapter->bSurpriseRemoved);
 		goto error_exit;
 	}
 
-	if(padapter)//system suspend
+	if (padapter)//system suspend
 	{
 		LeaveAllPowerSaveMode(padapter);
 
@@ -646,7 +646,7 @@ int rtw_hw_suspend(struct rtw_adapter *p
 		pwrpriv->bips_processing = true;
 		//padapter->net_closed = true;
 		//s1.
-		if(pnetdev)
+		if (pnetdev)
 		{
 			netif_carrier_off(pnetdev);
 			rtw_netif_stop_queue(pnetdev);
@@ -660,7 +660,7 @@ int rtw_hw_suspend(struct rtw_adapter *p
 		{
 			struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-			if(check_fwstate(pmlmepriv, _FW_LINKED))
+			if (check_fwstate(pmlmepriv, _FW_LINKED))
 			{
 				_clr_fwstate_(pmlmepriv, _FW_LINKED);
 
@@ -708,14 +708,14 @@ int rtw_hw_resume(struct rtw_adapter *pa
 
 	_func_enter_;
 
-	if(padapter)//system resume
+	if (padapter)//system resume
 	{
 		DBG_8192D("==> rtw_hw_resume\n");
 		_enter_pwrlock(&pwrpriv->lock);
 		pwrpriv->bips_processing = true;
 		rtw_reset_drv_sw(padapter);
 
-		if(pm_netdev_open(pnetdev,false) != 0)
+		if (pm_netdev_open(pnetdev,false) != 0)
 		{
 			_exit_pwrlock(&pwrpriv->lock);
 			goto error_exit;
@@ -724,7 +724,7 @@ int rtw_hw_resume(struct rtw_adapter *pa
 		netif_device_attach(pnetdev);
 		netif_carrier_on(pnetdev);
 
-		if(!netif_queue_stopped(pnetdev))
+		if (!netif_queue_stopped(pnetdev))
 			netif_start_queue(pnetdev);
 		else
 			netif_wake_queue(pnetdev);
@@ -768,19 +768,19 @@ static int rtw_suspend(struct usb_interf
 
 	DBG_8192D("==> %s (%s:%d)\n",__func__, current->comm, current->pid);
 
-	if((!padapter->bup) || (padapter->bDriverStopped)||(padapter->bSurpriseRemoved))
+	if ((!padapter->bup) || (padapter->bDriverStopped)||(padapter->bSurpriseRemoved))
 	{
 		DBG_8192D("padapter->bup=%d bDriverStopped=%d bSurpriseRemoved = %d\n",
 			padapter->bup, padapter->bDriverStopped,padapter->bSurpriseRemoved);
 		goto exit;
 	}
 
-	if(pwrpriv->bInternalAutoSuspend )
+	if (pwrpriv->bInternalAutoSuspend )
 	{
 	#ifdef CONFIG_AUTOSUSPEND
 	#ifdef SUPPORT_HW_RFOFF_DETECTED
 		// The FW command register update must after MAC and FW init ready.
-		if((padapter->bFWReady) && ( padapter->pwrctrlpriv.bHWPwrPindetect ) && (padapter->registrypriv.usbss_enable ))
+		if ((padapter->bFWReady) && ( padapter->pwrctrlpriv.bHWPwrPindetect ) && (padapter->registrypriv.usbss_enable ))
 		{
 			u8 bOpen = true;
 			rtw_interface_ps_func(padapter,HAL_USB_SELECT_SUSPEND,&bOpen);
@@ -796,13 +796,13 @@ static int rtw_suspend(struct usb_interf
 	_enter_pwrlock(&pwrpriv->lock);
 	//padapter->net_closed = true;
 	//s1.
-	if(pnetdev)
+	if (pnetdev)
 	{
 		netif_carrier_off(pnetdev);
 		rtw_netif_stop_queue(pnetdev);
 	}
 #ifdef CONFIG_WOWLAN
-	if(padapter->pwrctrlpriv.bSupportRemoteWakeup==true&&padapter->pwrctrlpriv.wowlan_mode==true){
+	if (padapter->pwrctrlpriv.bSupportRemoteWakeup==true&&padapter->pwrctrlpriv.wowlan_mode==true){
 		u8 ps_mode=PS_MODE_MIN;
 		//set H2C command
 		poidparam.subcode=WOWLAN_ENABLE;
@@ -818,7 +818,7 @@ static int rtw_suspend(struct usb_interf
 	}
 
 #ifdef CONFIG_LAYER2_ROAMING_RESUME
-	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) && check_fwstate(pmlmepriv, _FW_LINKED) )
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) && check_fwstate(pmlmepriv, _FW_LINKED) )
 	{
 		//DBG_8192D("%s:%d assoc_ssid:%s\n", __func__, __LINE__, pmlmepriv->assoc_ssid.Ssid);
 		DBG_8192D("%s:%d %s(%pM), length:%d assoc_ssid.length:%d\n",__func__, __LINE__,
@@ -834,7 +834,7 @@ static int rtw_suspend(struct usb_interf
 	//s2-3.
 	rtw_free_assoc_resources(padapter, 1);
 #ifdef CONFIG_AUTOSUSPEND
-	if(!pwrpriv->bInternalAutoSuspend )
+	if (!pwrpriv->bInternalAutoSuspend )
 #endif
 	//s2-4.
 	rtw_free_network_queue(padapter, true);
@@ -846,10 +846,10 @@ static int rtw_suspend(struct usb_interf
 #endif
 	_exit_pwrlock(&pwrpriv->lock);
 
-	if(check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))
 		rtw_indicate_scan_done(padapter, 1);
 
-	if(check_fwstate(pmlmepriv, _FW_UNDER_LINKING))
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))
 		rtw_indicate_disconnect(padapter);
 
 exit:
@@ -868,7 +868,7 @@ static int rtw_resume(struct usb_interfa
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	 int ret = 0;
 
-	if(pwrpriv->bInternalAutoSuspend ){
+	if (pwrpriv->bInternalAutoSuspend ){
 		ret = rtw_resume_process(padapter);
 	} else {
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
@@ -901,7 +901,7 @@ int rtw_resume_process(struct rtw_adapte
 
 	DBG_8192D("==> %s (%s:%d)\n",__func__, current->comm, current->pid);
 
-	if(padapter) {
+	if (padapter) {
 		pnetdev= padapter->pnetdev;
 		pwrpriv = &padapter->pwrctrlpriv;
 	} else {
@@ -913,19 +913,19 @@ int rtw_resume_process(struct rtw_adapte
 	pwrpriv->bkeepfwalive = false;
 
 	DBG_8192D("bkeepfwalive(%x)\n",pwrpriv->bkeepfwalive);
-	if(pm_netdev_open(pnetdev,true) != 0)
+	if (pm_netdev_open(pnetdev,true) != 0)
 		goto exit;
 
 	netif_device_attach(pnetdev);
 	netif_carrier_on(pnetdev);
 
 #ifdef CONFIG_AUTOSUSPEND
-	if(pwrpriv->bInternalAutoSuspend )
+	if (pwrpriv->bInternalAutoSuspend )
 	{
 		#ifdef CONFIG_AUTOSUSPEND
 		#ifdef SUPPORT_HW_RFOFF_DETECTED
 			// The FW command register update must after MAC and FW init ready.
-		if((padapter->bFWReady) && ( padapter->pwrctrlpriv.bHWPwrPindetect ) && (padapter->registrypriv.usbss_enable ))
+		if ((padapter->bFWReady) && ( padapter->pwrctrlpriv.bHWPwrPindetect ) && (padapter->registrypriv.usbss_enable ))
 		{
 			//rtl8192c_set_FwSelectSuspend_cmd(padapter,false ,500);//note fw to support hw power down ping detect
 			u8 bOpen = false;
@@ -939,14 +939,14 @@ int rtw_resume_process(struct rtw_adapte
 		{
 			DBG_8192D("enc_algorithm(%x),wepkeymask(%x)\n",
 				padapter->securitypriv.dot11PrivacyAlgrthm,pwrpriv->wepkeymask);
-			if(	(_WEP40_ == padapter->securitypriv.dot11PrivacyAlgrthm) ||
+			if (	(_WEP40_ == padapter->securitypriv.dot11PrivacyAlgrthm) ||
 				(_WEP104_ == padapter->securitypriv.dot11PrivacyAlgrthm))
 			{
 				int keyid;
 
 				for(keyid=0;keyid<4;keyid++){
-					if(pwrpriv->wepkeymask & BIT(keyid)) {
-						if(keyid == padapter->securitypriv.dot11PrivacyKeyIndex)
+					if (pwrpriv->wepkeymask & BIT(keyid)) {
+						if (keyid == padapter->securitypriv.dot11PrivacyKeyIndex)
 							rtw_set_key(padapter,&padapter->securitypriv, keyid, 1);
 						else
 							rtw_set_key(padapter,&padapter->securitypriv, keyid, 0);
@@ -958,7 +958,7 @@ int rtw_resume_process(struct rtw_adapte
 #endif
 	_exit_pwrlock(&pwrpriv->lock);
 
-	if( padapter->pid[1]!=0) {
+	if ( padapter->pid[1]!=0) {
 		DBG_8192D("pid[1]:%d\n",padapter->pid[1]);
 		rtw_signal_process(padapter->pid[1], SIGUSR2);
 	}
@@ -993,7 +993,7 @@ void autosuspend_enter(struct rtw_adapte
 
 	DBG_8192D("==>autosuspend_enter...........\n");
 
-	if(rf_off == pwrpriv->change_rfpwrstate )
+	if (rf_off == pwrpriv->change_rfpwrstate )
 	{
 		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 		usb_enable_autosuspend(dvobj->pusbdev);
@@ -1028,7 +1028,7 @@ int autoresume_enter(struct rtw_adapter*
 
 	DBG_8192D("====> autoresume_enter \n");
 
-	if(rf_off == pwrpriv->rf_pwrstate )
+	if (rf_off == pwrpriv->rf_pwrstate )
 	{
 		pwrpriv->ps_flag = false;
 		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,33))
@@ -1091,7 +1091,7 @@ struct rtw_adapter *rtw_usb_if1_init(str
 	decide_chip_type_by_usb_device_id(padapter, pdid);
 	#endif
 
-	if((pnetdev = rtw_init_netdev(padapter)) == NULL) {
+	if ((pnetdev = rtw_init_netdev(padapter)) == NULL) {
 		goto free_adapter;
 	}
 	SET_NETDEV_DEV(pnetdev, dvobj_to_dev(dvobj));
@@ -1101,13 +1101,13 @@ struct rtw_adapter *rtw_usb_if1_init(str
 		goto free_adapter;
 
 #ifdef CONFIG_IOCTL_CFG80211
-	if(rtw_wdev_alloc(padapter, dvobj_to_dev(dvobj)) != 0) {
+	if (rtw_wdev_alloc(padapter, dvobj_to_dev(dvobj)) != 0) {
 		goto handle_dualmac;
 	}
 #endif
 
 	//step 2. hook HalFunc, allocate HalData
-	if(padapter->chip_type == RTL8192D) {
+	if (padapter->chip_type == RTL8192D) {
 		rtl8192du_set_hal_ops(padapter);
 	} else {
 		DBG_8192D("Detect NULL_CHIP_TYPE\n");
@@ -1140,7 +1140,7 @@ struct rtw_adapter *rtw_usb_if1_init(str
 
 #ifdef CONFIG_PM
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
-	if(padapter->pwrctrlpriv.bSupportRemoteWakeup)
+	if (padapter->pwrctrlpriv.bSupportRemoteWakeup)
 	{
 		dvobj->pusbdev->do_remote_wakeup=1;
 		pusb_intf->needs_remote_wakeup = 1;
@@ -1152,9 +1152,9 @@ struct rtw_adapter *rtw_usb_if1_init(str
 #endif
 
 #ifdef CONFIG_AUTOSUSPEND
-	if( padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE )
+	if ( padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE )
 	{
-		if(padapter->registrypriv.usbss_enable ){	/* autosuspend (2s delay) */
+		if (padapter->registrypriv.usbss_enable ){	/* autosuspend (2s delay) */
 			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,38))
 			dvobj->pusbdev->dev.power.autosuspend_delay = 0 * HZ;//15 * HZ; idle-delay time
 			#else
@@ -1207,10 +1207,10 @@ struct rtw_adapter *rtw_usb_if1_init(str
 	status = _SUCCESS;
 
 free_hal_data:
-	if(status != _SUCCESS && padapter->HalData)
+	if (status != _SUCCESS && padapter->HalData)
 		kfree(padapter->HalData);
 free_wdev:
-	if(status != _SUCCESS) {
+	if (status != _SUCCESS) {
 		#ifdef CONFIG_IOCTL_CFG80211
 		rtw_wdev_unregister(padapter->rtw_wdev);
 		rtw_wdev_free(padapter->rtw_wdev);
@@ -1236,7 +1236,7 @@ static void rtw_usb_if1_deinit(struct rt
 	struct net_device *pnetdev = if1->pnetdev;
 	struct mlme_priv *pmlmepriv= &if1->mlmepriv;
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED))
+	if (check_fwstate(pmlmepriv, _FW_LINKED))
 		rtw_disassoc_cmd(if1, 0, false);
 
 
@@ -1247,9 +1247,9 @@ static void rtw_usb_if1_deinit(struct rt
 	#endif
 #endif
 
-	if(if1->DriverState != DRIVER_DISAPPEAR)
+	if (if1->DriverState != DRIVER_DISAPPEAR)
 	{
-		if(pnetdev) {
+		if (pnetdev) {
 			unregister_netdev(pnetdev); //will call netdev_close()
 			rtw_proc_remove_one(pnetdev);
 		}
@@ -1273,7 +1273,7 @@ static void rtw_usb_if1_deinit(struct rt
 
 	rtw_free_drv_sw(if1);
 
-	if(pnetdev)
+	if (pnetdev)
 		rtw_free_netdev(pnetdev);
 }
 
@@ -1315,13 +1315,13 @@ static int rtw_drv_init(struct usb_inter
 
 	/* Initialize if2 */
 #ifdef CONFIG_CONCURRENT_MODE
-	if((if2 = rtw_drv_if2_init(if1, NULL, usb_set_intf_ops)) == NULL) {
+	if ((if2 = rtw_drv_if2_init(if1, NULL, usb_set_intf_ops)) == NULL) {
 		goto free_if1;
 	}
 #ifdef CONFIG_MULTI_VIR_IFACES
 	for(i=0; i<if1->registrypriv.ext_iface_num;i++)
 	{
-		if(rtw_drv_add_vir_if(if1, "wlan%d", usb_set_intf_ops) == NULL)
+		if (rtw_drv_add_vir_if (if1, "wlan%d", usb_set_intf_ops) == NULL)
 		{
 			DBG_8192D("rtw_drv_add_iface failed! (%d)\n", i);
 			break;
@@ -1359,7 +1359,7 @@ _func_exit_;
 	DBG_8192D("+rtw_dev_remove\n");
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+dev_remove()\n"));
 
-	if(usb_drv->drv_registered == true)
+	if (usb_drv->drv_registered == true)
 	{
 		//DBG_8192D("r871xu_dev_remove():padapter->bSurpriseRemoved == true\n");
 		padapter->bSurpriseRemoved = true;
--- a/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
@@ -193,10 +193,10 @@ static void usb_bulkout_zero_complete(st
 
 	//DBG_8192D("+usb_bulkout_zero_complete\n");
 
-	if(pcontext) {
+	if (pcontext) {
 		kfree(pcontext->pbuf);
 
-		if(pcontext->purb && (pcontext->purb==purb))
+		if (pcontext->purb && (pcontext->purb==purb))
 			usb_free_urb(pcontext->purb);
 
 		kfree(pcontext);
@@ -217,7 +217,7 @@ static u32 usb_bulkout_zero(struct intf_
 	//DBG_8192D("%s\n", __func__);
 
 
-	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
+	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
 	{
 		return _FAIL;
 	}
@@ -368,7 +368,7 @@ _func_enter_;
 	spin_unlock_irqrestore(&pxmitpriv->lock, irqL);
 
 
-	if(pxmitpriv->txirp_cnt==0)
+	if (pxmitpriv->txirp_cnt==0)
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));
 		_rtw_up_sema(&(pxmitpriv->tx_retevt));
@@ -376,7 +376,7 @@ _func_enter_;
 */
         //rtw_free_xmitframe(pxmitpriv, pxmitframe);
 
-	if(padapter->bSurpriseRemoved || padapter->bDriverStopped ||padapter->bWritePortCancel)
+	if (padapter->bSurpriseRemoved || padapter->bDriverStopped ||padapter->bWritePortCancel)
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
 		DBG_8192D("%s(): TX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bWritePortCancel(%d) pxmitbuf->ext_tag(%x) \n",
@@ -391,7 +391,7 @@ _func_enter_;
 	} else {
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete : purb->status(%d) != 0 \n", purb->status));
 		DBG_8192D("###=> urb_write_port_complete status(%d)\n",purb->status);
-		if((purb->status==-EPIPE)||(purb->status==-EPROTO))
+		if ((purb->status==-EPIPE)||(purb->status==-EPROTO))
 		{
 			//usb_clear_halt(pusbdev, purb->pipe);
 			//msleep(10);
@@ -439,7 +439,7 @@ check_completion:
 
 	rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
 
-	//if(rtw_txframes_pending(padapter))
+	//if (rtw_txframes_pending(padapter))
 	{
 		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
 	}
@@ -510,9 +510,9 @@ _func_enter_;
 	purb	= pxmitbuf->pxmit_urb[0];
 
 #if 0
-	if(pdvobj->ishighspeed)
+	if (pdvobj->ishighspeed)
 	{
-		if(cnt> 0 && cnt%512 == 0)
+		if (cnt> 0 && cnt%512 == 0)
 		{
 			//DBG_8192D("ishighspeed, cnt=%d\n", cnt);
 			bwritezero = true;
@@ -520,7 +520,7 @@ _func_enter_;
 	}
 	else
 	{
-		if(cnt > 0 && cnt%64 == 0)
+		if (cnt > 0 && cnt%64 == 0)
 		{
 			//DBG_8192D("cnt=%d\n", cnt);
 			bwritezero = true;
@@ -590,7 +590,7 @@ _func_enter_;
 //   Commented by Albert 2009/10/13
 //   We add the URB_ZERO_PACKET flag to urb so that the host will send the zero packet automatically.
 /*
-	if(bwritezero == true)
+	if (bwritezero == true)
 	{
 		usb_bulkout_zero(pintfhdl, addr);
 	}
@@ -628,7 +628,7 @@ void usb_write_port_cancel(struct intf_h
 	pxmitbuf = (struct xmit_buf*)padapter->xmitpriv.pxmit_extbuf;
 	for (i = 0; i < NR_XMIT_EXTBUFF; i++) {
 		for (j=0; j<8; j++) {
-			if(pxmitbuf->pxmit_urb[j]) {
+			if (pxmitbuf->pxmit_urb[j]) {
 				usb_kill_urb(pxmitbuf->pxmit_urb[j]);
 			}
 		}
--- a/drivers/staging/rtl8192du/os_dep/xmit_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/xmit_linux.c
@@ -60,7 +60,7 @@ _func_enter_;
        len =  rtw_remainder_len(pfile);
 	len = (rlen > len)? len: rlen;
 
-       if(rmem)
+       if (rmem)
 	  skb_copy_bits(pfile->pkt, pfile->buf_len-pfile->pkt_len, rmem, len);
 
        pfile->cur_addr += len;
@@ -133,7 +133,7 @@ int rtw_os_xmit_resource_alloc(struct rt
 #ifdef CONFIG_USE_USB_BUFFER_ALLOC_TX
 	pxmitbuf->pallocated_buf = rtw_usb_buffer_alloc(pusbd, (size_t)alloc_sz, GFP_ATOMIC, &pxmitbuf->dma_transfer_addr);
 	pxmitbuf->pbuf = pxmitbuf->pallocated_buf;
-	if(pxmitbuf->pallocated_buf == NULL)
+	if (pxmitbuf->pallocated_buf == NULL)
 		return _FAIL;
 #else // CONFIG_USE_USB_BUFFER_ALLOC_TX
 
@@ -151,7 +151,7 @@ int rtw_os_xmit_resource_alloc(struct rt
 	for(i=0; i<8; i++)
 	{
 		pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
-		if(pxmitbuf->pxmit_urb[i] == NULL)
+		if (pxmitbuf->pxmit_urb[i] == NULL)
 		{
 			DBG_8192D("pxmitbuf->pxmit_urb[i]==NULL");
 			return _FAIL;
@@ -170,7 +170,7 @@ void rtw_os_xmit_resource_free(struct rt
 
 	for(i=0; i<8; i++)
 	{
-		if(pxmitbuf->pxmit_urb[i])
+		if (pxmitbuf->pxmit_urb[i])
 		{
 			//usb_kill_urb(pxmitbuf->pxmit_urb[i]);
 			usb_free_urb(pxmitbuf->pxmit_urb[i]);
@@ -193,7 +193,7 @@ void rtw_os_pkt_complete(struct rtw_adap
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
 	queue = skb_get_queue_mapping(pkt);
-	if(__netif_subqueue_stopped(padapter->pnetdev, queue) &&
+	if (__netif_subqueue_stopped(padapter->pnetdev, queue) &&
 		(pxmitpriv->hwxmits[queue].accnt < NR_XMITFRAME/2))
 	{
 		netif_wake_subqueue(padapter->pnetdev, queue);
@@ -208,7 +208,7 @@ void rtw_os_pkt_complete(struct rtw_adap
 
 void rtw_os_xmit_complete(struct rtw_adapter *padapter, struct xmit_frame *pxframe)
 {
-	if(pxframe->pkt)
+	if (pxframe->pkt)
 	{
 		//RT_TRACE(_module_xmit_osdep_c_,_drv_err_,("linux : rtw_os_xmit_complete, dev_kfree_skb()\n"));
 
@@ -224,14 +224,14 @@ void rtw_os_xmit_schedule(struct rtw_ada
 {
 	struct xmit_priv *pxmitpriv;
 
-	if(!padapter)
+	if (!padapter)
 		return;
 
 	pxmitpriv = &padapter->xmitpriv;
 
 	spin_lock_bh(&pxmitpriv->lock);
 
-	if(rtw_txframes_pending(padapter))
+	if (rtw_txframes_pending(padapter))
 	{
 		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
 	}

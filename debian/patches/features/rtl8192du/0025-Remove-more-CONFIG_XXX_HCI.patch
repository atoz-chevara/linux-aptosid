From 8dba3c0e71e27630893bc35f3acf3d454eb604e6 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Wed, 17 Apr 2013 17:20:36 -0500
Subject: [PATCH 025/210] Remove more CONFIG_XXX_HCI

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_recv.c         |  10 ---
 hal/HalPwrSeqCmd.c      | 175 ------------------------------------------------
 hal/hal_intf.c          |  10 +--
 hal/rtl8192d_dm.c       |  54 ---------------
 hal/rtl8192d_hal_init.c | 100 ---------------------------
 hal/rtl8192d_mp.c       |  84 +++--------------------
 include/osdep_service.h |   9 ---
 include/rtl8192d_recv.h |   7 --
 include/rtl8192d_spec.h |  87 ------------------------
 include/rtw_recv.h      |  37 ----------
 include/rtw_xmit.h      |  76 ---------------------
 11 files changed, 10 insertions(+), 639 deletions(-)
 delete mode 100644 hal/HalPwrSeqCmd.c

--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -106,15 +106,9 @@ _func_enter_;
 		precvframe++;
 
 	}
-
-#ifdef CONFIG_USB_HCI
-
 	precvpriv->rx_pending_cnt=1;
 
 	_rtw_init_sema(&precvpriv->allrxreturnevt, 0);
-
-#endif
-
 	res = rtw_hal_init_recv_priv(padapter);
 
 	precvpriv->recvbuf_skb_alloc_fail_cnt = 0;
@@ -2219,10 +2213,6 @@ _func_enter_;
 		return NULL;
 	}
 
-#ifdef CONFIG_SDIO_HCI
-	recvframe_expand_pkt(adapter, prframe);
-#endif
-
 	curfragnum++;
 
 	plist= get_list_head(defrag_q);
--- a/drivers/staging/rtl8192du/hal/HalPwrSeqCmd.c
+++ /dev/null
@@ -1,175 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-/*++
-Copyright (c) Realtek Semiconductor Corp. All rights reserved.
-
-Module Name:
-	HalPwrSeqCmd.c
-
-Abstract:
-	Implement HW Power sequence configuration CMD handling routine for Realtek devices.
-
-Major Change History:
-	When       Who               What
-	---------- ---------------   -------------------------------
-	2011-10-26 Lucas            Modify to be compatible with SD4-CE driver.
-	2011-07-07 Roger            Create.
-
---*/
-#include <HalPwrSeqCmd.h>
-#include <sdio_ops.h>
-
-
-//
-//	Description:
-//		This routine deal with the Power Configuration CMDs parsing for RTL8723/RTL8188E Series IC.
-//
-//	Assumption:
-//		We should follow specific format which was released from HW SD.
-//
-//	2011.07.07, added by Roger.
-//
-u8 HalPwrSeqCmdParsing(
-	PADAPTER		padapter,
-	u8				CutVersion,
-	u8				FabVersion,
-	u8				InterfaceType,
-	WLAN_PWR_CFG	PwrSeqCmd[])
-{
-	WLAN_PWR_CFG	PwrCfgCmd = {0};
-	u8				bPollingBit = _FALSE;
-	u32				AryIdx = 0;
-	u8				value = 0;
-	u32				offset = 0;
-	u32				pollingCount = 0; // polling autoload done.
-	u32				maxPollingCnt = 5000;
-
-	do {
-		PwrCfgCmd = PwrSeqCmd[AryIdx];
-
-		RT_TRACE(_module_hal_init_c_ , _drv_info_,
-				 ("HalPwrSeqCmdParsing: offset(%#x) cut_msk(%#x) fab_msk(%#x) interface_msk(%#x) base(%#x) cmd(%#x) msk(%#x) value(%#x)\n",
-					GET_PWR_CFG_OFFSET(PwrCfgCmd),
-					GET_PWR_CFG_CUT_MASK(PwrCfgCmd),
-					GET_PWR_CFG_FAB_MASK(PwrCfgCmd),
-					GET_PWR_CFG_INTF_MASK(PwrCfgCmd),
-					GET_PWR_CFG_BASE(PwrCfgCmd),
-					GET_PWR_CFG_CMD(PwrCfgCmd),
-					GET_PWR_CFG_MASK(PwrCfgCmd),
-					GET_PWR_CFG_VALUE(PwrCfgCmd)));
-
-		//2 Only Handle the command whose FAB, CUT, and Interface are matched
-		if ((GET_PWR_CFG_FAB_MASK(PwrCfgCmd) & FabVersion) &&
-			(GET_PWR_CFG_CUT_MASK(PwrCfgCmd) & CutVersion) &&
-			(GET_PWR_CFG_INTF_MASK(PwrCfgCmd) & InterfaceType))
-		{
-			switch (GET_PWR_CFG_CMD(PwrCfgCmd))
-			{
-				case PWR_CMD_READ:
-					RT_TRACE(_module_hal_init_c_ , _drv_info_, ("HalPwrSeqCmdParsing: PWR_CMD_READ\n"));
-					break;
-
-				case PWR_CMD_WRITE:
-					RT_TRACE(_module_hal_init_c_ , _drv_info_, ("HalPwrSeqCmdParsing: PWR_CMD_WRITE\n"));
-					offset = GET_PWR_CFG_OFFSET(PwrCfgCmd);
-
-#ifdef CONFIG_SDIO_HCI
-					//
-					// <Roger_Notes> We should deal with interface specific address mapping for some interfaces, e.g., SDIO interface
-					// 2011.07.07.
-					//
-					if (GET_PWR_CFG_BASE(PwrCfgCmd) == PWR_BASEADDR_SDIO)
-					{
-						// Read Back SDIO Local value
-						value = SdioLocalCmd52Read1Byte(padapter, offset);
-
-						value &= ~(GET_PWR_CFG_MASK(PwrCfgCmd));
-						value |= (GET_PWR_CFG_VALUE(PwrCfgCmd) & GET_PWR_CFG_MASK(PwrCfgCmd));
-
-						// Write Back SDIO Local value
-						SdioLocalCmd52Write1Byte(padapter, offset, value);
-					}
-					else
-#endif
-					{
-						// Read the value from system register
-						value = rtw_read8(padapter, offset);
-
-						value &= ~(GET_PWR_CFG_MASK(PwrCfgCmd));
-						value |= (GET_PWR_CFG_VALUE(PwrCfgCmd) & GET_PWR_CFG_MASK(PwrCfgCmd));
-
-						// Write the value back to sytem register
-						rtw_write8(padapter, offset, value);
-					}
-					break;
-
-				case PWR_CMD_POLLING:
-					RT_TRACE(_module_hal_init_c_ , _drv_info_, ("HalPwrSeqCmdParsing: PWR_CMD_POLLING\n"));
-
-					bPollingBit = _FALSE;
-					offset = GET_PWR_CFG_OFFSET(PwrCfgCmd);
-
-					do {
-#ifdef CONFIG_SDIO_HCI
-						if (GET_PWR_CFG_BASE(PwrCfgCmd) == PWR_BASEADDR_SDIO)
-							value = SdioLocalCmd52Read1Byte(padapter, offset);
-						else
-#endif
-							value = rtw_read8(padapter, offset);
-
-						value &= GET_PWR_CFG_MASK(PwrCfgCmd);
-						if (value == (GET_PWR_CFG_VALUE(PwrCfgCmd) & GET_PWR_CFG_MASK(PwrCfgCmd)))
-							bPollingBit = _TRUE;
-						else
-							rtw_udelay_os(10);
-
-						if (pollingCount++ > maxPollingCnt) {
-							RT_TRACE(_module_hal_init_c_ , _drv_err_, ("Fail to polling Offset[%#x]\n", offset));
-							return _FALSE;
-						}
-					} while (!bPollingBit);
-
-					break;
-
-				case PWR_CMD_DELAY:
-					RT_TRACE(_module_hal_init_c_ , _drv_info_, ("HalPwrSeqCmdParsing: PWR_CMD_DELAY\n"));
-					if (GET_PWR_CFG_VALUE(PwrCfgCmd) == PWRSEQ_DELAY_US)
-						rtw_udelay_os(GET_PWR_CFG_OFFSET(PwrCfgCmd));
-					else
-						rtw_udelay_os(GET_PWR_CFG_OFFSET(PwrCfgCmd)*1000);
-					break;
-
-				case PWR_CMD_END:
-					// When this command is parsed, end the process
-					RT_TRACE(_module_hal_init_c_ , _drv_info_, ("HalPwrSeqCmdParsing: PWR_CMD_END\n"));
-					return _TRUE;
-					break;
-
-				default:
-					RT_TRACE(_module_hal_init_c_ , _drv_err_, ("HalPwrSeqCmdParsing: Unknown CMD!!\n"));
-					break;
-			}
-		}
-
-		AryIdx++;//Add Array Index
-	}while(1);
-
-	return _TRUE;
-}
--- a/drivers/staging/rtl8192du/hal/hal_intf.c
+++ b/drivers/staging/rtl8192du/hal/hal_intf.c
@@ -23,16 +23,8 @@
 #include <osdep_service.h>
 #include <drv_types.h>
 #include <rtw_byteorder.h>
-
 #include <hal_intf.h>
-
-#ifdef CONFIG_SDIO_HCI
-	#include <sdio_hal.h>
-#elif defined(CONFIG_USB_HCI)
-	#include <usb_hal.h>
-#elif defined(CONFIG_GSPI_HCI)
-	#include <gspi_hal.h>
-#endif
+#include <usb_hal.h>
 
 void rtw_hal_chip_configure(_adapter *padapter)
 {
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -1160,11 +1160,8 @@ static void dm_1R_CCA(
 	pPS_T pDM_PSTable = &pdmpriv->DM_PSTable;
 	struct registry_priv *pregistrypriv = &pAdapter->registrypriv;
 
-#ifdef CONFIG_USB_HCI // Add by Gary for 92DU 1RCCA 5G->Enable, 2G->Disable 20110624
       if(pHalData->CurrentBandType92D == BAND_ON_5G)
       {
-#endif
-              //RT_TRACE(COMP_BB_POWERSAVING,DBG_LOUD,("=Gary=: 92D 5G 1RCCA on\n"));
 		if(pdmpriv->MinUndecoratedPWDBForDM != 0)
 		{
 			if(pDM_PSTable->PreCCAState == CCA_2R || pDM_PSTable->PreCCAState == CCA_MAX)
@@ -1225,11 +1222,7 @@ static void dm_1R_CCA(
 			pDM_PSTable->PreCCAState = pDM_PSTable->CurCCAState;
 		}
 		//RT_TRACE(	COMP_BB_POWERSAVING|COMP_INIT, DBG_LOUD, ("CCAStage = %d\n",pDM_PSTable->CurCCAState));
-#ifdef CONFIG_USB_HCI
 	}
-	//else  // pHalData->CurrentBandType92D == BAND_ON_2_4G  92DU 2.4G 1RCCA Disable
-	//	RT_TRACE(COMP_BB_POWERSAVING,DBG_LOUD,("=Gary=: 92D 2G 1RCCA off\n"));
-#endif
 }
 
 static void dm_InitDynamicTxPower(IN	PADAPTER	Adapter)
@@ -1237,7 +1230,6 @@ static void dm_InitDynamicTxPower(IN	PAD
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
-	//pdmpriv->bDynamicTxPowerEnable = _TRUE;
 	pdmpriv->bDynamicTxPowerEnable = _FALSE;
 
 	pdmpriv->LastDTPLvl = TxHighPwrLevel_Normal;
@@ -2376,7 +2368,6 @@ static void	dm_CheckPbcGPIO(IN PADAPTER
 	do
 	{
 		i++;
-#ifdef CONFIG_USB_HCI
 	tmp1byte = rtw_read8(padapter, GPIO_IO_SEL);
 	tmp1byte |= (HAL_8192C_HW_GPIO_WPS_BIT);
 	rtw_write8(padapter, GPIO_IO_SEL, tmp1byte);	//enable GPIO[2] as output mode
@@ -2403,24 +2394,6 @@ static void	dm_CheckPbcGPIO(IN PADAPTER
 		if(i<=3)
 			rtw_msleep_os(50);
 	}
-#else
-	tmp1byte = rtw_read8(padapter, GPIO_IN);
-	//RT_TRACE(COMP_IO, DBG_TRACE, ("dm_CheckPbcGPIO - %x\n", tmp1byte));
-
-	if (tmp1byte == 0xff || padapter->init_adpt_in_progress)
-	{
-		bPbcPressed = _FALSE;
-		break ;
-	}
-
-	if((tmp1byte&HAL_8192C_HW_GPIO_WPS_BIT)==0)
-	{
-		bPbcPressed = _TRUE;
-
-		if(i<=3)
-			rtw_msleep_os(50);
-	}
-#endif
 	}while(i<=3 && bPbcPressed == _TRUE);
 
 	if( _TRUE == bPbcPressed)
@@ -2730,11 +2703,7 @@ rtl8192d_HalDmWatchDog(
 		// Dynamic Initial Gain mechanism.
 		//
 //sherry delete flag 20110517
-#ifdef CONFIG_PCI_HCI
-//		ACQUIRE_GLOBAL_SPINLOCK(&GlobalSpinlockForGlobalAdapterList);
-#else
 		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForGlobalAdapterList);
-#endif
 		if(pHalData->bSlaveOfDMSP)
 		{
 			odm_FalseAlarmCounterStatistics_ForSlaveOfDMSP(Adapter);
@@ -2743,18 +2712,11 @@ rtl8192d_HalDmWatchDog(
 		{
 			odm_FalseAlarmCounterStatistics(Adapter);
 		}
-#ifdef CONFIG_PCI_HCI
-//		RELEASE_GLOBAL_SPINLOCK(&GlobalSpinlockForGlobalAdapterList);
-#else
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForGlobalAdapterList);
-#endif
-		//odm_RSSIMonitorCheck(Adapter);
 #ifndef CONFIG_CONCURRENT_MODE
 		odm_FindMinimumRSSI_92D(Adapter);
 #endif //CONFIG_CONCURRENT_MODE
 		odm_DIG(Adapter);
-		//PHY_SetBBReg( Adapter, 0xC50, 0x7f, 0x32 );
-		//PHY_SetBBReg( Adapter, 0xC58, 0x7f, 0x32 );
 		if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
 			if(pHalData->CurrentBandType92D != BAND_ON_5G)
@@ -2766,10 +2728,6 @@ rtl8192d_HalDmWatchDog(
 				dm_CCK_PacketDetectionThresh(Adapter);
 		}
 
-//#ifdef CONFIG_PCI_HCI
-//		odm_DynamicEarlyMode(Adapter);
-//#endif
-
 		//
 		// Dynamic Tx Power mechanism.
 		//
@@ -2789,20 +2747,8 @@ rtl8192d_HalDmWatchDog(
 		//
 		dm_RefreshRateAdaptiveMask(Adapter);
 
-//#ifdef CONFIG_PCI_HCI
-		//BT-Coexist
-//		dm_BTCoexist(Adapter);
-//#endif
-
-#ifdef CONFIG_PCI_HCI
-		// Tx Migration settings.
-		//migration, 92d just for normal chip, vivi, 20100708
-		//dm_InterruptMigration(Adapter);
-#endif
-
 		// EDCA turbo
 		//update the EDCA paramter according to the Tx/RX mode
-		//update_EDCA_param(Adapter);
 		dm_CheckEdcaTurbo(Adapter);
 
 		//
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -24,13 +24,8 @@
 #include <drv_types.h>
 #include <rtw_byteorder.h>
 #include <rtw_efuse.h>
-
 #include <hal_intf.h>
-
-#ifdef CONFIG_USB_HCI
 #include <usb_hal.h>
-#endif
-
 #include <rtl8192d_hal.h>
 
 atomic_t GlobalMutexForGlobalAdapterList = ATOMIC_INIT(0);
@@ -106,7 +101,6 @@ _FWDownloadEnable(
 #endif
 }
 
-#ifdef CONFIG_USB_HCI
 static int
 _BlockWrite_92d(
 	IN		PADAPTER		Adapter,
@@ -176,70 +170,7 @@ _BlockWrite_92d(
 exit:
 	return ret;
 }
-#endif
-#ifndef CONFIG_USB_HCI
-static int
-_BlockWrite(
-	IN		PADAPTER		Adapter,
-	IN		PVOID			buffer,
-	IN		u32			size
-	)
-{
-	int ret = _SUCCESS;
 
-	u32			blockSize	= sizeof(u32);	// Use 4-byte write to download FW
-	u8*			bufferPtr	= (u8*)buffer;
-	u32*			pu4BytePtr	= (u32*)buffer;
-	u32			i, offset, blockCount, remainSize;
-#ifdef CONFIG_PCI_HCI
-	u8			remainFW[4] = {0, 0, 0, 0};
-	u8			*p = NULL;
-#endif
-	blockCount = size / blockSize;
-	remainSize = size % blockSize;
-
-	for(i = 0 ; i < blockCount ; i++){
-		offset = i * blockSize;
-		ret = rtw_write32(Adapter, (FW_8192D_START_ADDRESS + offset), cpu_to_le32(*(pu4BytePtr + i)));
-
-		if(ret == _FAIL)
-			goto exit;
-	}
-#ifdef CONFIG_PCI_HCI
-	p = (u8*)((u32*)(bufferPtr + blockCount * blockSize));
-	if (remainSize) {
-		switch (remainSize) {
-		case 0:
-			break;
-		case 3:
-			remainFW[2]=*(p+2);
-		case 2:
-			remainFW[1]=*(p+1);
-		case 1:
-			remainFW[0]=*(p);
-			ret = rtw_write32(Adapter, (FW_8192D_START_ADDRESS + blockCount * blockSize),
-				 le32_to_cpu(*(u32*)remainFW));
-		}
-		return ret;
-	}
-#endif
-	if(remainSize){
-		offset = blockCount * blockSize;
-		bufferPtr += offset;
-
-		for(i = 0 ; i < remainSize ; i++){
-			ret = rtw_write8(Adapter, (FW_8192D_START_ADDRESS + offset + i), *(bufferPtr + i));
-
-			if(ret == _FAIL)
-				goto exit;
-		}
-	}
-
-exit:
-	return ret;
-
-}
-#endif //CONFIG_USB_HCI
 static int
 _PageWrite(
 	IN		PADAPTER		Adapter,
@@ -253,33 +184,9 @@ _PageWrite(
 
 	value8 = (rtw_read8(Adapter, REG_MCUFWDL+2)& 0xF8 ) | u8Page ;
 	rtw_write8(Adapter, REG_MCUFWDL+2,value8);
-#ifdef CONFIG_USB_HCI
 	return _BlockWrite_92d(Adapter,buffer,size);
-#else
-	return _BlockWrite(Adapter,buffer,size);
-#endif
 }
-#ifdef CONFIG_PCI_HCI
-static VOID
-_FillDummy(
-	u8*		pFwBuf,
-	u32*	pFwLen
-	)
-{
-	u32	FwLen = *pFwLen;
-	u8	remain = (u8)(FwLen%4);
-	remain = (remain==0)?0:(4-remain);
 
-	while(remain>0)
-	{
-		pFwBuf[FwLen] = 0;
-		FwLen++;
-		remain--;
-	}
-
-	*pFwLen = FwLen;
-}
-#endif //CONFIG_PCI_HCI
 static int
 _WriteFW(
 	IN		PADAPTER		Adapter,
@@ -294,14 +201,7 @@ _WriteFW(
 	u32	page,offset;
 	u8*	bufferPtr = (u8*)buffer;
 
-#ifdef CONFIG_PCI_HCI
-	// 20100120 Joseph: Add for 88CE normal chip.
-	// Fill in zero to make firmware image to dword alignment.
-//	_FillDummy(bufferPtr, &size);
-#endif
-
 	pageNums = size / MAX_PAGE_SIZE ;
-	//RT_ASSERT((pageNums <= 4), ("Page numbers should not greater then 4 \n"));
 	remainSize = size % MAX_PAGE_SIZE;
 
 	for(page = 0; page < pageNums;  page++){
--- a/drivers/staging/rtl8192du/hal/rtl8192d_mp.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_mp.c
@@ -841,41 +841,23 @@ PHY_PowerDownAnotherPHY(
 {
 //	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u1Byte					u1bTmp;
-#if defined(CONFIG_PCI_HCI)
-	u1Byte			Direct = (bMac0==_TRUE)? BIT3|BIT2:BIT3;
-#endif
 	u1Byte			MAC_REG = (bMac0==_TRUE)? REG_MAC1:REG_MAC0;
 	u1Byte			MAC_ON_BIT = (bMac0==_TRUE)? MAC1_ON:MAC0_ON;
-#if defined(CONFIG_USB_HCI)
 	u4Byte			MaskforPhySet = 0;
-#endif
-
-	 // RT_TRACE(COMP_RF, DBG_LOUD, ("====>PHY_PowerDownAnotherPHY\n"));
 
 	  // check MAC0 enable or not again now, if enabled, not power down radio A.
 	u1bTmp = _rtw_read8(Adapter, MAC_REG);
 
 	if (!(u1bTmp&MAC_ON_BIT))
 	{
-		//RT_TRACE(COMP_INIT, DBG_LOUD, ("PHY_PowerDownAnotherPHY power down\n"));
 
 		// power down RF radio A according to YuNan's advice.
-#if defined(CONFIG_PCI_HCI)
-			  HalWritePCIDwordDBI8192C(Adapter,
-						rFPGA0_XA_LSSIParameter,
-						0x00000000,
-						Direct);
-#elif defined(CONFIG_USB_HCI)
-			if(bMac0)
-				MaskforPhySet = MAC0_ACCESS_PHY1;
-			else
-				MaskforPhySet = MAC1_ACCESS_PHY0;
-			  _rtw_write32(Adapter, rFPGA0_XA_LSSIParameter|MaskforPhySet, 0x00000000);
-
-#endif
+		if(bMac0)
+			MaskforPhySet = MAC0_ACCESS_PHY1;
+		else
+			MaskforPhySet = MAC1_ACCESS_PHY0;
+		  _rtw_write32(Adapter, rFPGA0_XA_LSSIParameter|MaskforPhySet, 0x00000000);
 	}
-
-	 // RT_TRACE(COMP_RF, DBG_LOUD, ("<====PHY_PowerDownAnotherPHY\n"));
 }
 
 /*------------------------Define function prototype--------------------------*/
@@ -889,51 +871,25 @@ PHY_EnableAnotherPHY(
 	)
 {
 	u1Byte					u1bTmp;
-#ifdef CONFIG_PCI_HCI
-	u1Byte			Direct = (bMac0==_TRUE)? BIT3|BIT2:BIT3;
-#endif
 	u1Byte			MAC_REG = (bMac0==_TRUE)?REG_MAC1:REG_MAC0;
 	u1Byte			MAC_ON_BIT = bMac0==_TRUE?MAC1_ON:MAC0_ON;
 	BOOLEAN			bResult = _TRUE; //true: need to enable BB/RF power
-#ifdef CONFIG_USB_HCI
-	u4Byte			MaskForPHYSet = 0;
-#endif
-
-//	RT_TRACE(COMP_RF, DBG_LOUD, ("===>PHY_EnableAnotherPHY\n"));
-
 	//MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write.
 	 u1bTmp = _rtw_read8(Adapter, MAC_REG);
 
-	  if (!(u1bTmp&MAC_ON_BIT))
-	{
-
-	//   RT_TRACE(COMP_INIT, DBG_LOUD, ("PHY_EnableAnotherPHY enable BB & RF\n"));
-
+	  if (!(u1bTmp&MAC_ON_BIT)) {
 	   // Enable BB and RF power
-#if defined(CONFIG_PCI_HCI)
-		HalWritePCIDwordDBI8192C(Adapter,
-			REG_SYS_ISO_CTRL,
-			HalReadPCIDwordDBI8192C(Adapter, REG_SYS_ISO_CTRL, Direct)|BIT29|BIT16|BIT17,
-			Direct);
-#elif defined(CONFIG_USB_HCI)
 		if(bMac0)
 			MaskForPHYSet = MAC0_ACCESS_PHY1;
 		else
 			MaskForPHYSet = MAC1_ACCESS_PHY0;
 		_rtw_write16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet, _rtw_read16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet)&0xFFFC);
 		_rtw_write16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet, _rtw_read16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet)|BIT13|BIT0|BIT1);
-#endif
-	}
-	else
-	{
+	} else {
 		// We think if MAC1 is ON,then radio_a.txt and radio_b.txt has been load.
 		bResult = _FALSE;
 	}
-
-	//RT_TRACE(COMP_RF, DBG_LOUD, ("<===PHY_EnableAnotherPHY\n"));
-
 	return bResult;
-
 }
 
 
@@ -1067,43 +1023,21 @@ VOID
 	//Query regB30 bit27
 	u32		Regb30 = PHY_QueryBBReg(Adapter, 0xb30, BIT27);
 
-#ifdef CONFIG_PCI_HCI
-	if(IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID))
-	{
-		if(channel == 6 && pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
-			PHY_SetRFReg(Adapter, RF_PATH_A, RF_RX_G1, bRFRegOffsetMask, 0x00255);
-		else
-			PHY_SetRFReg(Adapter, RF_PATH_A, RF_RX_G1, bRFRegOffsetMask, pHalData->backupRF0x1A);
-	}
-#endif
 	//only for 92D SMSP >= C-cut
 	if(!IS_HARDWARE_TYPE_8192D(Adapter))
 		return;
-/*
-#ifdef CONFIG_USB_HCI
-#ifndef UNDER_CE
-	 if(!IS_HIGH_SPEED_USB(Adapter))
-			return;
-#endif
-#endif
-*/
 
 	//config path A for 5G
 	if(pHalData->CurrentBandType92D == BAND_ON_5G)
 	{
-		//RT_TRACE(COMP_CMD, DBG_LOUD, ("====>phy_SwitchRfSetting8192D interface %d 5G\n", Adapter->interfaceIndex));
-
 		u4tmp = CurveIndex[GetRightChnlPlace(channel)-1];
-		//RT_DISP(FINIT, INIT_IQK, ("ver 1 set RF-A, 5G, 0x28 = 0x%x !!\n", u4tmp));
 
-		for(i = 0; i < RF_CHNL_NUM_5G; i++)
-		{
+		for(i = 0; i < RF_CHNL_NUM_5G; i++) {
 			if(channel == RF_CHNL_5G[i] && channel <= 140)
 				index = 0;
 		}
 
-		for(i = 0; i < RF_CHNL_NUM_5G_40M; i++)
-		{
+		for(i = 0; i < RF_CHNL_NUM_5G_40M; i++) {
 			if(channel == RF_CHNL_5G_40M[i] && channel <= 140)
 				index = 1;
 		}
--- a/drivers/staging/rtl8192du/include/osdep_service.h
+++ b/drivers/staging/rtl8192du/include/osdep_service.h
@@ -83,28 +83,19 @@
 	#include <linux/udp.h>
 #endif
 
-#ifdef CONFIG_USB_HCI
 	#include <linux/usb.h>
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
 	#include <linux/usb_ch9.h>
 #else
 	#include <linux/usb/ch9.h>
 #endif
-#endif
-
-#ifdef CONFIG_PCI_HCI
-	#include <linux/pci.h>
-#endif
 
-
-#ifdef CONFIG_USB_HCI
 	typedef struct urb *  PURB;
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22))
 #ifdef CONFIG_USB_SUSPEND
 #define CONFIG_AUTOSUSPEND	1
 #endif
 #endif
-#endif
 
 	typedef struct	semaphore _sema;
 	typedef	spinlock_t	_lock;
--- a/drivers/staging/rtl8192du/include/rtl8192d_recv.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_recv.h
@@ -106,7 +106,6 @@ typedef struct _Phy_CCK_Rx_Status_Report
 // Rx smooth factor
 #define	Rx_Smooth_Factor (20)
 
-#ifdef CONFIG_USB_HCI
 typedef struct _INTERRUPT_MSG_FORMAT_EX{
 	unsigned int C2H_MSG0;
 	unsigned int C2H_MSG1;
@@ -120,12 +119,6 @@ typedef struct _INTERRUPT_MSG_FORMAT_EX{
 void rtl8192du_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
 int	rtl8192du_init_recv_priv(_adapter * padapter);
 void	rtl8192du_free_recv_priv(_adapter * padapter);
-#endif
-
-#ifdef CONFIG_PCI_HCI
-int	rtl8192de_init_recv_priv(_adapter * padapter);
-void rtl8192de_free_recv_priv(_adapter * padapter);
-#endif
 
 void rtl8192d_translate_rx_signal_stuff(union recv_frame *precvframe, struct phy_stat *pphy_info);
 void rtl8192d_query_rx_desc_status(union recv_frame *precvframe, struct recv_stat *pdesc);
--- a/drivers/staging/rtl8192du/include/rtl8192d_spec.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_spec.h
@@ -762,11 +762,7 @@ Default: 00b.
 #define	EEPROM_Default_internalPA_SP3T_C9	0xAA
 #define	EEPROM_Default_internalPA_SP3T_CC	0xAF
 #define	EEPROM_Default_internalPA_SPDT_C9	0xAA
-#ifdef CONFIG_PCI_HCI
-#define	EEPROM_Default_internalPA_SPDT_CC	0xA0
-#else
 #define	EEPROM_Default_internalPA_SPDT_CC	0xFA
-#endif
 
 #define	EEPROM_CHANNEL_PLAN_FCC				0x0
 #define	EEPROM_CHANNEL_PLAN_IC				0x1
@@ -793,87 +789,6 @@ Default: 00b.
 #define	RTL8192_EEPROM_ID						0x8129
 #define	EEPROM_WAPI_SUPPORT					0x78
 
-
-#ifdef CONFIG_PCI_HCI
-#define RT_IBSS_INT_MASKS				(IMR_BcnInt | IMR_TBDOK | IMR_TBDER)
-#define RT_AC_INT_MASKS				(IMR_VIDOK | IMR_VODOK | IMR_BEDOK|IMR_BKDOK)
-#define RT_BSS_INT_MASKS				(RT_IBSS_INT_MASKS)
-
-#define RTL8190_EEPROM_ID						0x8129	// 0-1
-#define EEPROM_HPON							0x02 // LDO settings.2-5
-#define EEPROM_CLK								0x06 // Clock settings.6-7
-#define EEPROM_MAC_FUNCTION					0x08 // SE Test mode.8
-
-#define EEPROM_VID								0x28 // SE Vendor ID.A-B
-#define EEPROM_DID								0x2A // SE Device ID. C-D
-#define EEPROM_SVID								0x2C // SE Vendor ID.E-F
-#define EEPROM_SMID							0x2E // SE PCI Subsystem ID. 10-11
-
-#define EEPROM_MAC_ADDR						0x16 // SEMAC Address. 12-17
-#define EEPROM_MAC_ADDR_MAC0_92D			0x55
-#define EEPROM_MAC_ADDR_MAC1_92D			0x5B
-//----------------------------------------------------------------
-// 2.4G band Tx power index setting
-#define EEPROM_CCK_TX_PWR_INX_2G				0x61
-#define EEPROM_HT40_1S_TX_PWR_INX_2G		0x67
-#define EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G	0x6D
-#define EEPROM_HT20_TX_PWR_INX_DIFF_2G		0x70
-#define EEPROM_OFDM_TX_PWR_INX_DIFF_2G		0x73
-#define EEPROM_HT40_MAX_PWR_OFFSET_2G		0x76
-#define EEPROM_HT20_MAX_PWR_OFFSET_2G		0x79
-
-//5GL channel 32-64
-#define EEPROM_HT40_1S_TX_PWR_INX_5GL		0x7C
-#define EEPROM_HT40_2S_TX_PWR_INX_DIFF_5GL	0x82
-#define EEPROM_HT20_TX_PWR_INX_DIFF_5GL		0x85
-#define EEPROM_OFDM_TX_PWR_INX_DIFF_5GL		0x88
-#define EEPROM_HT40_MAX_PWR_OFFSET_5GL		0x8B
-#define EEPROM_HT20_MAX_PWR_OFFSET_5GL		0x8E
-
-//5GM channel 100-140
-#define EEPROM_HT40_1S_TX_PWR_INX_5GM		0x91
-#define EEPROM_HT40_2S_TX_PWR_INX_DIFF_5GM	0x97
-#define EEPROM_HT20_TX_PWR_INX_DIFF_5GM		0x9A
-#define EEPROM_OFDM_TX_PWR_INX_DIFF_5GM	0x9D
-#define EEPROM_HT40_MAX_PWR_OFFSET_5GM		0xA0
-#define EEPROM_HT20_MAX_PWR_OFFSET_5GM		0xA3
-
-//5GH channel 149-165
-#define EEPROM_HT40_1S_TX_PWR_INX_5GH		0xA6
-#define EEPROM_HT40_2S_TX_PWR_INX_DIFF_5GH	0xAC
-#define EEPROM_HT20_TX_PWR_INX_DIFF_5GH		0xAF
-#define EEPROM_OFDM_TX_PWR_INX_DIFF_5GH		0xB2
-#define EEPROM_HT40_MAX_PWR_OFFSET_5GH		0xB5
-#define EEPROM_HT20_MAX_PWR_OFFSET_5GH		0xB8
-
-#define EEPROM_CHANNEL_PLAN					0xBB // Map of supported channels.
-#define EEPROM_IQK_DELTA						0xBC
-#define EEPROM_LCK_DELTA						0xBC
-#define EEPROM_XTAL_K							0xBD	//[7:5]
-#define EEPROM_TSSI_A_5G						0xBE
-#define EEPROM_TSSI_B_5G						0xBF
-#define EEPROM_TSSI_AB_5G						0xC0
-#define EEPROM_THERMAL_METER					0xC3	//[4:0]
-#define EEPROM_PATHDIV							0xC4
-#define EEPROM_RF_OPT1							0xC4
-#define EEPROM_RF_OPT2							0xC5
-#define EEPROM_RF_OPT3							0xC6
-#define EEPROM_RF_OPT4							0xC7
-#define EEPROM_RF_OPT5							0xC8
-#define EEPROM_RF_OPT6							0xC9
-#define EEPROM_VERSION							0xCA
-#define EEPROM_CUSTOMER_ID					0xCB
-#define EEPROM_RF_OPT7							0xCC
-
-#define EEPROM_WIDIPAIRING_ADDR				0xF0
-#define EEPROM_WIDIPAIRING_KEY				0xF6
-
-#define EEPROM_DEF_PART_NO					0x3FD  //Byte
-#define EEPROME_CHIP_VERSION_L				0x3FF
-#define EEPROME_CHIP_VERSION_H				0x3FE
-#endif
-
-#ifdef CONFIG_USB_HCI
 #define RTL8190_EEPROM_ID						0x8129	// 0-1
 #define EEPROM_HPON							0x02 // LDO settings.2-5
 #define EEPROM_CLK								0x06 // Clock settings.6-7
@@ -1012,8 +927,6 @@ Default: 00b.
 #define	EEPROM_USB_DEVICE_PWR				BIT(2)
 #define	EEPROM_EP_NUMBER						(BIT(3)|BIT(4))
 
-#endif
-
 
 /*===================================================================
 =====================================================================
--- a/drivers/staging/rtl8192du/include/rtw_recv.h
+++ b/drivers/staging/rtl8192du/include/rtw_recv.h
@@ -172,38 +172,15 @@ struct rx_pkt_attrib
 struct recv_stat
 {
 	unsigned int rxdw0;
-
 	unsigned int rxdw1;
-
 	unsigned int rxdw2;
-
 	unsigned int rxdw3;
-
 	unsigned int rxdw4;
-
 	unsigned int rxdw5;
-
-#ifdef CONFIG_PCI_HCI
-	unsigned int rxdw6;
-
-	unsigned int rxdw7;
-#endif
 };
 
 #define EOR BIT(30)
 
-#ifdef CONFIG_PCI_HCI
-#define PCI_MAX_RX_QUEUE		1// MSDU packet queue, Rx Command Queue
-#define PCI_MAX_RX_COUNT		128
-
-struct rtw_rx_ring {
-	struct recv_stat	*desc;
-	dma_addr_t		dma;
-	unsigned int		idx;
-	struct sk_buff	*rx_buf[PCI_MAX_RX_COUNT];
-};
-#endif
-
 /*
 accesser of recv_priv: rtw_recv_entry(dispatch / passive level); recv_thread(passive) ; returnpkt(dispatch)
 ; halt(passive) ;
@@ -243,8 +220,6 @@ struct recv_priv
 	uint  rx_smallpacket_crcerr;
 	uint  rx_middlepacket_crcerr;
 
-#ifdef CONFIG_USB_HCI
-	//u8 *pallocated_urb_buf;
 	_sema allrxreturnevt;
 	uint	ff_hwaddr;
 	u8	rx_pending_cnt;
@@ -255,7 +230,6 @@ struct recv_priv
 	u8	*int_in_buf;
 #endif
 
-#endif
 	struct tasklet_struct irq_prepare_beacon_tasklet;
 	struct tasklet_struct recv_tasklet;
 	struct sk_buff_head free_recv_skb_queue;
@@ -274,17 +248,6 @@ struct recv_priv
 	_queue	free_recv_buf_queue;
 	u32	free_recv_buf_queue_cnt;
 
-#ifdef CONFIG_SDIO_HCI
-	_queue	recv_buf_pending_queue;
-#endif
-
-#ifdef CONFIG_PCI_HCI
-	// Rx
-	struct rtw_rx_ring	rx_ring[PCI_MAX_RX_QUEUE];
-	int	rxringcount;
-	u16	rxbuffersize;
-#endif
-
 	//For display the phy informatiom
 	u8 is_signal_dbg;	// for debug
 	u8 signal_strength_dbg;	// for debug
--- a/drivers/staging/rtl8192du/include/rtw_xmit.h
+++ b/drivers/staging/rtl8192du/include/rtw_xmit.h
@@ -23,11 +23,6 @@
 #include <drv_conf.h>
 #include <osdep_service.h>
 #include <drv_types.h>
-#ifdef CONFIG_SDIO_HCI
-#define MAX_XMITBUF_SZ (12288)
-#define NR_XMITBUFF	(16)
-
-#elif defined (CONFIG_USB_HCI)
 #ifdef CONFIG_USB_TX_AGGREGATION
 	#define MAX_XMITBUF_SZ	(20480)	// 20k
 #else
@@ -39,11 +34,6 @@
 #define NR_XMITBUFF	(4)
 #endif //CONFIG_SINGLE_XMIT_BUF
 
-#elif defined (CONFIG_PCI_HCI)
-#define MAX_XMITBUF_SZ	(1664)
-#define NR_XMITBUFF	(128)
-#endif
-
 #define XMITBUF_ALIGN_SZ 512
 
 // xmit extension buff defination
@@ -72,12 +62,6 @@
 
 #define HW_QUEUE_ENTRY	8
 
-#ifdef CONFIG_PCI_HCI
-//#define TXDESC_NUM						64
-#define TXDESC_NUM						128
-#define TXDESC_NUM_BE_QUEUE			128
-#endif
-
 #define WEP_IV(pattrib_iv, dot11txpn, keyidx)\
 do{\
 	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
@@ -119,19 +103,8 @@ do{\
 
 #define TXDESC_SIZE 32
 
-#ifdef CONFIG_SDIO_HCI
-#define TXDESC_OFFSET TXDESC_SIZE
-#endif
-
-#ifdef CONFIG_USB_HCI
 #define PACKET_OFFSET_SZ (8)
 #define TXDESC_OFFSET (TXDESC_SIZE + PACKET_OFFSET_SZ)
-#endif
-
-#ifdef CONFIG_PCI_HCI
-#define TXDESC_OFFSET 0
-#define TX_DESC_NEXT_DESC_OFFSET	40
-#endif
 
 //
 //defined for TX DESC Operation
@@ -174,44 +147,15 @@ do{\
 #define SGI		BIT(6)
 
 struct tx_desc{
-
 	//DWORD 0
 	unsigned int txdw0;
-
 	unsigned int txdw1;
-
 	unsigned int txdw2;
-
 	unsigned int txdw3;
-
 	unsigned int txdw4;
-
 	unsigned int txdw5;
-
 	unsigned int txdw6;
-
 	unsigned int txdw7;
-#ifdef CONFIG_PCI_HCI
-	unsigned int txdw8;
-
-	unsigned int txdw9;
-
-	unsigned int txdw10;
-
-	unsigned int txdw11;
-
-	// 2008/05/15 MH Because PCIE HW memory R/W 4K limit. And now,  our descriptor
-	// size is 40 bytes. If you use more than 102 descriptor( 103*40>4096), HW will execute
-	// memoryR/W CRC error. And then all DMA fetch will fail. We must decrease descriptor
-	// number or enlarge descriptor size as 64 bytes.
-	unsigned int txdw12;
-
-	unsigned int txdw13;
-
-	unsigned int txdw14;
-
-	unsigned int txdw15;
-#endif
 };
 
 
@@ -220,19 +164,6 @@ union txdesc {
 	unsigned int value[TXDESC_SIZE>>2];
 };
 
-#ifdef CONFIG_PCI_HCI
-#define PCI_MAX_TX_QUEUE_COUNT	8
-
-struct rtw_tx_ring {
-	struct tx_desc	*desc;
-	dma_addr_t		dma;
-	unsigned int		idx;
-	unsigned int		entries;
-	_queue			queue;
-	u32				qlen;
-};
-#endif
-
 struct	hw_xmit	{
 	//_lock xmit_lock;
 	//_list	pending;
@@ -377,12 +308,6 @@ struct xmit_frame
 
 	struct xmit_buf *pxmitbuf;
 
-#ifdef CONFIG_SDIO_HCI
-	u8	pg_num;
-	u8	agg_num;
-#endif
-
-#ifdef CONFIG_USB_HCI
 #ifdef CONFIG_USB_TX_AGGREGATION
 	u8	agg_num;
 #endif
@@ -391,7 +316,6 @@ struct xmit_frame
 	u8	EMPktNum;
 	u16	EMPktLen[5];//The max value by HW
 #endif
-#endif
 #ifdef CONFIG_XMIT_ACK
 	u8 ack_report;
 #endif

From 37fa62a1a8ca214c59d091e335db90697f7da855 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Wed, 19 Feb 2014 20:35:39 -0600
Subject: [PATCH 211/390] rtl8192du: More cleanup

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 include/drv_types.h      |   2 +-
 include/ioctl_cfg80211.h |   4 +-
 include/osdep_service.h  | 109 +++++++++++++++++++++++------------------------
 include/rtw_cmd.h        |   2 +-
 include/rtw_mlme.h       |   4 +-
 include/rtw_mlme_ext.h   |   2 +-
 os_dep/osdep_service.c   |  20 ++++-----
 7 files changed, 71 insertions(+), 72 deletions(-)

--- a/drivers/staging/rtl8192du/include/drv_types.h
+++ b/drivers/staging/rtl8192du/include/drv_types.h
@@ -250,7 +250,7 @@ struct dvobj_priv {
 	u8 *usb_vendor_req_buf;
 	struct usb_interface *pusbintf;
 	struct usb_device *pusbdev;
-	ATOMIC_T continual_urb_error;
+	atomic_t continual_urb_error;
 };
 
 static struct device *dvobj_to_dev(struct dvobj_priv *dvobj)
--- a/drivers/staging/rtl8192du/include/ioctl_cfg80211.h
+++ b/drivers/staging/rtl8192du/include/ioctl_cfg80211.h
@@ -65,8 +65,8 @@ struct rtw_wdev_priv
 	bool power_mgmt;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	ATOMIC_T ro_ch_to;
-	ATOMIC_T switch_ch_to;
+	atomic_t ro_ch_to;
+	atomic_t switch_ch_to;
 #endif
 
 };
--- a/drivers/staging/rtl8192du/include/osdep_service.h
+++ b/drivers/staging/rtl8192du/include/osdep_service.h
@@ -167,7 +167,7 @@ static inline void rtw_netif_stop_queue(
 	#define BIT(x)	(1 << (x))
 #endif
 
-extern int RTW_STATUS_CODE(int error_code);
+int RTW_STATUS_CODE(int error_code);
 
 /* flags used for rtw_update_mem_stat() */
 enum {
@@ -189,53 +189,53 @@ enum {
 
 #define rtw_update_mem_stat(flag, sz) do {} while (0)
 
-extern int	_rtw_memcmp(void *dst, void *src, u32 sz);
+int	_rtw_memcmp(void *dst, void *src, u32 sz);
 
-extern u32	rtw_is_list_empty(struct list_head *phead);
-extern void	rtw_list_insert_head(struct list_head *plist, struct list_head *phead);
-extern void	rtw_list_insert_tail(struct list_head *plist, struct list_head *phead);
-
-extern void	_rtw_init_sema(struct  semaphore *sema, int init_val);
-extern void	_rtw_free_sema(struct  semaphore *sema);
-extern void	_rtw_up_sema(struct  semaphore *sema);
-extern u32	_rtw_down_sema(struct  semaphore *sema);
-extern void	_rtw_mutex_init(_mutex *pmutex);
-extern void	_rtw_mutex_free(_mutex *pmutex);
-extern void	_rtw_spinlock_init(spinlock_t *plock);
-extern void	_rtw_spinlock_free(spinlock_t *plock);
-extern void	_rtw_spinlock(spinlock_t	*plock);
-extern void	_rtw_spinunlock(spinlock_t	*plock);
-extern void	_rtw_spinlock_ex(spinlock_t	*plock);
-extern void	_rtw_spinunlock_ex(spinlock_t	*plock);
-
-extern void	_rtw_init_queue(struct __queue *pqueue);
-extern u32	_rtw_queue_empty(struct __queue *pqueue);
-extern u32	rtw_end_of_queue_search(struct list_head *queue, struct list_head *pelement);
-
-extern u32	rtw_get_current_time(void);
-extern u32	rtw_systime_to_ms(u32 systime);
-extern u32	rtw_ms_to_systime(u32 ms);
-extern s32	rtw_get_passing_time_ms(u32 start);
-extern s32	rtw_get_time_interval_ms(u32 start, u32 end);
+u32	rtw_is_list_empty(struct list_head *phead);
+void	rtw_list_insert_head(struct list_head *plist, struct list_head *phead);
+void	rtw_list_insert_tail(struct list_head *plist, struct list_head *phead);
+
+void	_rtw_init_sema(struct  semaphore *sema, int init_val);
+void	_rtw_free_sema(struct  semaphore *sema);
+void	_rtw_up_sema(struct  semaphore *sema);
+u32	_rtw_down_sema(struct  semaphore *sema);
+void	_rtw_mutex_init(_mutex *pmutex);
+void	_rtw_mutex_free(_mutex *pmutex);
+void	_rtw_spinlock_init(spinlock_t *plock);
+void	_rtw_spinlock_free(spinlock_t *plock);
+void	_rtw_spinlock(spinlock_t	*plock);
+void	_rtw_spinunlock(spinlock_t	*plock);
+void	_rtw_spinlock_ex(spinlock_t	*plock);
+void	_rtw_spinunlock_ex(spinlock_t	*plock);
+
+void	_rtw_init_queue(struct __queue *pqueue);
+u32	_rtw_queue_empty(struct __queue *pqueue);
+u32	rtw_end_of_queue_search(struct list_head *queue, struct list_head *pelement);
+
+u32	rtw_get_current_time(void);
+u32	rtw_systime_to_ms(u32 systime);
+u32	rtw_ms_to_systime(u32 ms);
+s32	rtw_get_passing_time_ms(u32 start);
+s32	rtw_get_time_interval_ms(u32 start, u32 end);
 
-extern void	rtw_sleep_schedulable(int ms);
+void	rtw_sleep_schedulable(int ms);
 
-extern void	rtw_msleep_os(int ms);
-extern void	rtw_usleep_os(int us);
+void	rtw_msleep_os(int ms);
+void	rtw_usleep_os(int us);
 
-extern u32	rtw_atoi(u8* s);
+u32	rtw_atoi(u8* s);
 
 #ifdef DBG_DELAY_OS
 #define rtw_mdelay_os(ms) _rtw_mdelay_os((ms), __func__, __LINE__)
 #define rtw_udelay_os(ms) _rtw_udelay_os((ms), __func__, __LINE__)
-extern void _rtw_mdelay_os(int ms, const char *func, const int line);
-extern void _rtw_udelay_os(int us, const char *func, const int line);
+void _rtw_mdelay_os(int ms, const char *func, const int line);
+void _rtw_udelay_os(int us, const char *func, const int line);
 #else
-extern void	rtw_mdelay_os(int ms);
-extern void	rtw_udelay_os(int us);
+void	rtw_mdelay_os(int ms);
+void	rtw_udelay_os(int us);
 #endif
 
-extern void rtw_yield_os(void);
+void rtw_yield_os(void);
 
 
 static inline unsigned char _cancel_timer_ex(struct timer_list *timer)
@@ -343,42 +343,41 @@ static inline u32 bitshift(u32 bitmask)
 #include <linux/android_power.h>
 #endif
 
-extern void rtw_suspend_lock_init(void);
-extern void rtw_suspend_lock_uninit(void);
-extern void rtw_lock_suspend(void);
-extern void rtw_unlock_suspend(void);
+void rtw_suspend_lock_init(void);
+void rtw_suspend_lock_uninit(void);
+void rtw_lock_suspend(void);
+void rtw_unlock_suspend(void);
 
 
 /* Atomic integer operations */
-	#define ATOMIC_T atomic_t
 
-extern void ATOMIC_SET(ATOMIC_T *v, int i);
-extern int ATOMIC_READ(ATOMIC_T *v);
-extern void ATOMIC_ADD(ATOMIC_T *v, int i);
-extern void ATOMIC_SUB(ATOMIC_T *v, int i);
-extern void ATOMIC_INC(ATOMIC_T *v);
-extern void ATOMIC_DEC(ATOMIC_T *v);
-extern int ATOMIC_ADD_RETURN(ATOMIC_T *v, int i);
-extern int ATOMIC_SUB_RETURN(ATOMIC_T *v, int i);
-extern int ATOMIC_INC_RETURN(ATOMIC_T *v);
-extern int ATOMIC_DEC_RETURN(ATOMIC_T *v);
+void ATOMIC_SET(atomic_t *v, int i);
+int ATOMIC_READ(atomic_t *v);
+void ATOMIC_ADD(atomic_t *v, int i);
+void ATOMIC_SUB(atomic_t *v, int i);
+void ATOMIC_INC(atomic_t *v);
+void ATOMIC_DEC(atomic_t *v);
+int ATOMIC_ADD_RETURN(atomic_t *v, int i);
+int ATOMIC_SUB_RETURN(atomic_t *v, int i);
+int ATOMIC_INC_RETURN(atomic_t *v);
+int ATOMIC_DEC_RETURN(atomic_t *v);
 
 /* File operation APIs, just for linux now */
 int rtw_is_file_readable(char *path);
 int rtw_retrive_from_file(char *path, u8 __user *buf, u32 sz);
 int rtw_store_to_file(char *path, u8 __user *buf, u32 sz);
 
-
 struct rtw_netdev_priv_indicator {
 	void *priv;
 	u32 sizeof_priv;
 };
+
 struct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv);
-extern struct net_device * rtw_alloc_etherdev(int sizeof_priv);
+struct net_device *rtw_alloc_etherdev(int sizeof_priv);
 
 #define rtw_netdev_priv(netdev) (((struct rtw_netdev_priv_indicator *)netdev_priv(netdev))->priv)
 
-extern void rtw_free_netdev(struct net_device * netdev);
+void rtw_free_netdev(struct net_device * netdev);
 
 #define NDEV_FMT "%s"
 #define NDEV_ARG(ndev) ndev->name
@@ -391,8 +390,8 @@ extern void rtw_free_netdev(struct net_d
 
 #define rtw_signal_process(pid, sig) kill_pid(find_vpid((pid)),(sig), 1)
 
-extern u64 rtw_modular64(u64 x, u64 y);
-extern u64 rtw_division64(u64 x, u64 y);
+u64 rtw_modular64(u64 x, u64 y);
+u64 rtw_division64(u64 x, u64 y);
 
 
 /* Macros for handling unaligned memory accesses */
--- a/drivers/staging/rtl8192du/include/rtw_cmd.h
+++ b/drivers/staging/rtl8192du/include/rtw_cmd.h
@@ -93,7 +93,7 @@
 		u8	lbkevt_num;
 		u8	*cmdevt_parm;
 #endif
-		ATOMIC_T event_seq;
+		atomic_t event_seq;
 		u8	*evt_buf;	/* shall be non-paged, and 4 bytes aligned */
 		u8	*evt_allocated_buf;
 		u32	evt_done_cnt;
--- a/drivers/staging/rtl8192du/include/rtw_mlme.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme.h
@@ -395,7 +395,7 @@ struct mlme_priv {
 
 	#ifdef CONFIG_SET_SCAN_DENY_TIMER
 	struct timer_list set_scan_deny_timer;
-	ATOMIC_T set_scan_deny; /* 0: allowed, 1: deny */
+	atomic_t set_scan_deny; /* 0: allowed, 1: deny */
 	#endif
 
 	struct qos_priv qospriv;
@@ -505,7 +505,7 @@ struct mlme_priv {
 	int	widi_state;
 	int	listen_state;
 	struct timer_list listen_timer;
-	ATOMIC_T	rx_probe_rsp; /*  1:receive probe respone from RDS source. */
+	atomic_t	rx_probe_rsp; /*  1:receive probe respone from RDS source. */
 	u8	*l2sdTaBuffer;
 	u8	channel_idx;
 	s8	group_cnt;	/* For WiDi 3.5, they specified another scan algo. for WFD/RDS co-existed */
--- a/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
@@ -426,7 +426,7 @@ struct mlme_ext_priv
 {
 	struct rtw_adapter *padapter;
 	u8	mlmeext_init;
-	ATOMIC_T		event_seq;
+	atomic_t		event_seq;
 	u16	mgnt_seq;
 
 	unsigned char	cur_channel;
--- a/drivers/staging/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8192du/os_dep/osdep_service.c
@@ -310,52 +310,52 @@ inline void rtw_unlock_suspend(void)
 	#endif
 }
 
-inline void ATOMIC_SET(ATOMIC_T *v, int i)
+inline void ATOMIC_SET(atomic_t *v, int i)
 {
 	atomic_set(v,i);
 }
 
-inline int ATOMIC_READ(ATOMIC_T *v)
+inline int ATOMIC_READ(atomic_t *v)
 {
 	return atomic_read(v);
 }
 
-inline void ATOMIC_ADD(ATOMIC_T *v, int i)
+inline void ATOMIC_ADD(atomic_t *v, int i)
 {
 	atomic_add(i,v);
 }
 
-inline void ATOMIC_SUB(ATOMIC_T *v, int i)
+inline void ATOMIC_SUB(atomic_t *v, int i)
 {
 	atomic_sub(i,v);
 }
 
-inline void ATOMIC_INC(ATOMIC_T *v)
+inline void ATOMIC_INC(atomic_t *v)
 {
 	atomic_inc(v);
 }
 
-inline void ATOMIC_DEC(ATOMIC_T *v)
+inline void ATOMIC_DEC(atomic_t *v)
 {
 	atomic_dec(v);
 }
 
-inline int ATOMIC_ADD_RETURN(ATOMIC_T *v, int i)
+inline int ATOMIC_ADD_RETURN(atomic_t *v, int i)
 {
 	return atomic_add_return(i,v);
 }
 
-inline int ATOMIC_SUB_RETURN(ATOMIC_T *v, int i)
+inline int ATOMIC_SUB_RETURN(atomic_t *v, int i)
 {
 	return atomic_sub_return(i,v);
 }
 
-inline int ATOMIC_INC_RETURN(ATOMIC_T *v)
+inline int ATOMIC_INC_RETURN(atomic_t *v)
 {
 	return atomic_inc_return(v);
 }
 
-inline int ATOMIC_DEC_RETURN(ATOMIC_T *v)
+inline int ATOMIC_DEC_RETURN(atomic_t *v)
 {
 	return atomic_dec_return(v);
 }

From d88f1fa05583fae4b2a0020b6bcbe71e6064af10 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sat, 22 Jun 2013 15:37:59 -0500
Subject: [PATCH 164/210] rtl8192du: Fix sparse and W=1 warnings

This commit fixes all the warnings that are issued with W=1 on the make line.

Most sparse warnings are also fixed; however, some of the endian issues remain.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 Makefile                 |  1 +
 core/rtw_br_ext.c        | 91 +++++++++++++++---------------------------------
 core/rtw_cmd.c           |  6 ++--
 core/rtw_debug.c         | 11 +++---
 core/rtw_efuse.c         |  4 +--
 core/rtw_ieee80211.c     |  8 ++---
 core/rtw_ioctl_set.c     | 11 +-----
 core/rtw_mlme.c          | 38 +++++---------------
 core/rtw_mlme_ext.c      | 69 ++++++++++++++++--------------------
 core/rtw_p2p.c           | 28 ++++++---------
 core/rtw_recv.c          | 10 ++++--
 core/rtw_security.c      |  9 -----
 core/rtw_sta_mgt.c       |  7 +---
 core/rtw_wlan_util.c     |  9 +++--
 core/rtw_xmit.c          |  3 +-
 hal/rtl8192d_cmd.c       |  2 --
 hal/rtl8192d_hal_init.c  |  6 +---
 hal/rtl8192d_phycfg.c    | 73 ++++++++++++++------------------------
 hal/rtl8192d_rf6052.c    | 15 +++++++-
 hal/usb_halinit.c        | 13 -------
 hal/usb_ops_linux.c      | 18 +++++-----
 include/ieee80211.h      |  4 +--
 include/rtw_recv.h       | 19 ++++------
 os_dep/ioctl_linux.c     | 78 +++++++++++++++++++----------------------
 os_dep/os_intfs.c        | 22 ++++--------
 os_dep/osdep_service.c   |  4 ---
 os_dep/recv_linux.c      | 17 ---------
 os_dep/usb_intf.c        |  3 --
 os_dep/usb_ops_linux.c   |  2 +-
 30 files changed, 245 insertions(+), 371 deletions(-)

--- a/drivers/staging/rtl8192du/Makefile
+++ b/drivers/staging/rtl8192du/Makefile
@@ -32,6 +32,7 @@ CONFIG_DRVEXT_MODULE = n
 
 export TopDIR ?= $(shell pwd)
 
+ccflags-y += -D__CHECK_ENDIAN__
 
 RTL871X = rtl8192d
 
--- a/drivers/staging/rtl8192du/core/rtw_br_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_br_ext.c
@@ -714,12 +714,12 @@ int nat25_db_handle(struct rtw_adapter *
 	if ((method <= NAT25_MIN) || (method >= NAT25_MAX))
 		return -1;
 
-	protocol = *((unsigned short *)(skb->data + 2 * ETH_ALEN));
+	protocol = be16_to_cpu(*((__be16 *)(skb->data + 2 * ETH_ALEN)));
 
 	/*---------------------------------------------------*/
 	/*                 Handle IP frame                   */
 	/*---------------------------------------------------*/
-	if (protocol == __constant_htons(ETH_P_IP)) {
+	if (protocol == ETH_P_IP) {
 		struct iphdr *iph = (struct iphdr *)(skb->data + ETH_HLEN);
 
 		if (((unsigned char *)(iph) + (iph->ihl<<2)) >= (skb->data + ETH_HLEN + skb->len)) {
@@ -778,7 +778,7 @@ int nat25_db_handle(struct rtw_adapter *
 	/*---------------------------------------------------*/
 	/*                 Handle ARP frame                  */
 	/*---------------------------------------------------*/
-	} else if (protocol == __constant_htons(ETH_P_ARP)) {
+	} else if (protocol == ETH_P_ARP) {
 		struct arphdr *arp = (struct arphdr *)(skb->data + ETH_HLEN);
 		unsigned char *arp_ptr = (unsigned char *)(arp + 1);
 		unsigned int *sender, *target;
@@ -831,18 +831,18 @@ int nat25_db_handle(struct rtw_adapter *
 	/*---------------------------------------------------*/
 	/*         Handle IPX and Apple Talk frame           */
 	/*---------------------------------------------------*/
-	} else if ((protocol == __constant_htons(ETH_P_IPX)) ||
-		   (protocol <= __constant_htons(ETH_FRAME_LEN))) {
+	} else if ((protocol == ETH_P_IPX) ||
+		   (protocol <= ETH_FRAME_LEN)) {
 		unsigned char ipx_header[2] = {0xFF, 0xFF};
 		struct ipxhdr	*ipx = NULL;
 		struct elapaarp	*ea = NULL;
 		struct ddpehdr	*ddp = NULL;
 		unsigned char *frameptr = skb->data + ETH_HLEN;
 
-		if (protocol == __constant_htons(ETH_P_IPX)) {
+		if (protocol == ETH_P_IPX) {
 			DBG_8192D("NAT25: Protocol = IPX (Ethernet II)\n");
 			ipx = (struct ipxhdr *)frameptr;
-		} else if (protocol <= __constant_htons(ETH_FRAME_LEN)) {
+		} else if (protocol <= ETH_FRAME_LEN) {
 			if (!memcmp(ipx_header, frameptr, 2)) {
 				DBG_8192D("NAT25: Protocol = IPX (Ethernet 802.3)\n");
 				ipx = (struct ipxhdr *)frameptr;
@@ -1032,8 +1032,8 @@ int nat25_db_handle(struct rtw_adapter *
 	/*---------------------------------------------------*/
 	/*                Handle PPPoE frame                 */
 	/*---------------------------------------------------*/
-	} else if ((protocol == __constant_htons(ETH_P_PPP_DISC)) ||
-		(protocol == __constant_htons(ETH_P_PPP_SES))) {
+	} else if ((protocol == ETH_P_PPP_DISC) ||
+		(protocol == ETH_P_PPP_SES)) {
 		struct pppoe_hdr *ph = (struct pppoe_hdr *)(skb->data + ETH_HLEN);
 		unsigned short *magic;
 
@@ -1042,7 +1042,6 @@ int nat25_db_handle(struct rtw_adapter *
 			if (ph->sid == 0)
 				return 0;
 			return 1;
-
 		case NAT25_INSERT:
 			if (ph->sid == 0) {	/*  Discovery phase according to tag */
 				if (ph->code == PADI_CODE || ph->code == PADR_CODE) {
@@ -1059,20 +1058,16 @@ int nat25_db_handle(struct rtw_adapter *
 								ERR_8192D("SID tag length too long!\n");
 								return -1;
 							}
-
 							memcpy(tag->tag_data+MAGIC_CODE_LEN+RTL_RELAY_TAG_LEN,
 							       old_tag->tag_data, old_tag_len);
-
 							if (skb_pull_and_merge(skb, (unsigned char *)old_tag, TAG_HDR_LEN+old_tag_len) < 0) {
 								ERR_8192D("call skb_pull_and_merge() failed in PADI/R packet!\n");
 								return -1;
 							}
 							ph->length = htons(ntohs(ph->length)-TAG_HDR_LEN-old_tag_len);
 						}
-
 						tag->tag_type = PTT_RELAY_SID;
 						tag->tag_len = htons(MAGIC_CODE_LEN+RTL_RELAY_TAG_LEN+old_tag_len);
-
 						/*  insert the magic_code+client mac in relay tag */
 						magic = (unsigned short *)tag->tag_data;
 						*magic = htons(MAGIC_CODE);
@@ -1081,7 +1076,6 @@ int nat25_db_handle(struct rtw_adapter *
 						/* Add relay tag */
 						if (__nat25_add_pppoe_tag(skb, tag) < 0)
 							return -1;
-
 						DBG_8192D("NAT25: Insert PPPoE, forward %s packet\n",
 							  (ph->code == PADI_CODE ? "PADI" : "PADR"));
 					} else { /*  not add relay tag */
@@ -1090,10 +1084,8 @@ int nat25_db_handle(struct rtw_adapter *
 							ERR_8192D("Discard PPPoE packet due to another PPPoE connection is in progress!\n");
 							return -2;
 						}
-
 						if (priv->pppoe_connection_in_progress == 0)
 							memcpy(priv->pppoe_addr, skb->data+ETH_ALEN, ETH_ALEN);
-
 						priv->pppoe_connection_in_progress = WAIT_TIME_PPPOE;
 					}
 				} else {
@@ -1101,13 +1093,9 @@ int nat25_db_handle(struct rtw_adapter *
 				}
 			} else {	/*  session phase */
 				DBG_8192D("NAT25: Insert PPPoE, insert session packet to %s\n", skb->dev->name);
-
 				__nat25_generate_pppoe_network_addr(networkAddr, skb->data, &(ph->sid));
-
 				__nat25_db_network_insert(priv, skb->data+ETH_ALEN, networkAddr);
-
 				__nat25_db_print(priv);
-
 				if (!priv->eth_br_ext_info.addPPPoETag &&
 				    priv->pppoe_connection_in_progress &&
 				    !memcmp(skb->data+ETH_ALEN, priv->pppoe_addr, ETH_ALEN))
@@ -1127,11 +1115,9 @@ int nat25_db_handle(struct rtw_adapter *
 						ERR_8192D("Fail to find PTT_RELAY_SID in FADO!\n");
 						return -1;
 					}
-
 					tag = (struct pppoe_tag *)ptr;
 					tagType = (unsigned short)((ptr[0] << 8) + ptr[1]);
 					tagLen = (unsigned short)((ptr[2] << 8) + ptr[3]);
-
 					if ((tagType != ntohs(PTT_RELAY_SID)) || (tagLen < (MAGIC_CODE_LEN+RTL_RELAY_TAG_LEN))) {
 						ERR_8192D("Invalid PTT_RELAY_SID tag length [%d]!\n", tagLen);
 						return -1;
@@ -1171,9 +1157,7 @@ int nat25_db_handle(struct rtw_adapter *
 				if (ph->sid != 0) {
 					DBG_8192D("NAT25: Lookup PPPoE, lookup session packet from %s\n", skb->dev->name);
 					__nat25_generate_pppoe_network_addr(networkAddr, skb->data+ETH_ALEN, &(ph->sid));
-
 					__nat25_db_network_lookup_and_replace(priv, skb, networkAddr);
-
 					__nat25_db_print(priv);
 				} else {
 					return -1;
@@ -1187,17 +1171,14 @@ int nat25_db_handle(struct rtw_adapter *
 	/*---------------------------------------------------*/
 	/*                 Handle EAP frame                  */
 	/*---------------------------------------------------*/
-	} else if (protocol == __constant_htons(0x888e)) {
+	} else if (protocol == 0x888e) {
 		switch (method) {
 		case NAT25_CHECK:
 			return -1;
-
 		case NAT25_INSERT:
 			return 0;
-
 		case NAT25_LOOKUP:
 			return 0;
-
 		default:
 			return -1;
 		}
@@ -1205,18 +1186,15 @@ int nat25_db_handle(struct rtw_adapter *
 	/*---------------------------------------------------*/
 	/*         Handle C-Media proprietary frame          */
 	/*---------------------------------------------------*/
-	} else if ((protocol == __constant_htons(0xe2ae)) ||
-		(protocol == __constant_htons(0xe2af))) {
+	} else if ((protocol == 0xe2ae) ||
+		(protocol == 0xe2af)) {
 		switch (method) {
 		case NAT25_CHECK:
 			return -1;
-
 		case NAT25_INSERT:
 			return 0;
-
 		case NAT25_LOOKUP:
 			return 0;
-
 		default:
 			return -1;
 		}
@@ -1226,7 +1204,7 @@ int nat25_db_handle(struct rtw_adapter *
 	/*         Handle IPV6 frame								  */
 	/*---------------------------------------------------*/
 #ifdef CL_IPV6_PASS
-	else if (protocol == __constant_htons(ETH_P_IPV6)) {
+	else if (protocol == ETH_P_IPV6) {
 		struct ipv6hdr *iph = (struct ipv6hdr *)(skb->data + ETH_HLEN);
 
 		if (sizeof(*iph) >= (skb->len - ETH_HLEN)) {
@@ -1240,23 +1218,9 @@ int nat25_db_handle(struct rtw_adapter *
 				return 0;
 			return -1;
 		case NAT25_INSERT:
-			DBG_8192D("NAT25: Insert IP, SA =%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x, DA =%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n",
-				  iph->saddr.s6_addr16[0],
-				  iph->saddr.s6_addr16[1],
-				  iph->saddr.s6_addr16[2],
-				  iph->saddr.s6_addr16[3],
-				  iph->saddr.s6_addr16[4],
-				  iph->saddr.s6_addr16[5],
-				  iph->saddr.s6_addr16[6],
-				  iph->saddr.s6_addr16[7],
-				  iph->daddr.s6_addr16[0],
-				  iph->daddr.s6_addr16[1],
-				  iph->daddr.s6_addr16[2],
-				  iph->daddr.s6_addr16[3],
-				  iph->daddr.s6_addr16[4],
-				  iph->daddr.s6_addr16[5],
-				  iph->daddr.s6_addr16[6],
-				  iph->daddr.s6_addr16[7]);
+			DBG_8192D("NAT25: Insert IP, SA =%8ph, DA = %8ph\n",
+				  iph->saddr.s6_addr16,
+				  iph->daddr.s6_addr16);
 
 			if (memcmp(&iph->saddr, "\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0", 16)) {
 				__nat25_generate_ipv6_network_addr(networkAddr, (unsigned int *)&iph->saddr);
@@ -1271,7 +1235,7 @@ int nat25_db_handle(struct rtw_adapter *
 						struct icmp6hdr  *hdr = (struct icmp6hdr *)(skb->data + ETH_HLEN + sizeof(*iph));
 						hdr->icmp6_cksum = 0;
 						hdr->icmp6_cksum = csum_ipv6_magic(&iph->saddr, &iph->daddr,
-										iph->payload_len,
+										be16_to_cpu(iph->payload_len),
 										IPPROTO_ICMPV6,
 										csum_partial((__u8 *)hdr, iph->payload_len, 0));
 					}
@@ -1321,8 +1285,10 @@ int nat25_handle_frame(struct rtw_adapte
 	if (!(skb->data[0] & 1)) {
 		int is_vlan_tag = 0, i, retval = 0;
 		unsigned short vlan_hdr = 0;
+		unsigned short protocol;
 
-		if (*((unsigned short *)(skb->data+ETH_ALEN*2)) == __constant_htons(ETH_P_8021Q)) {
+		protocol = be16_to_cpu(*((__be16 *)(skb->data + 2 * ETH_ALEN)));
+		if (protocol == ETH_P_8021Q) {
 			is_vlan_tag = 1;
 			vlan_hdr = *((unsigned short *)(skb->data+ETH_ALEN*2+2));
 			for (i = 0; i < 6; i++)
@@ -1338,7 +1304,7 @@ int nat25_handle_frame(struct rtw_adapte
 			 *	corresponding network protocol is NOT support.
 			 */
 			if (!priv->eth_br_ext_info.nat25sc_disable &&
-			    (*((unsigned short *)(skb->data+ETH_ALEN*2)) == __constant_htons(ETH_P_IP)) &&
+			    (be16_to_cpu(*((__be16 *)(skb->data+ETH_ALEN*2))) == ETH_P_IP) &&
 			    !memcmp(priv->scdb_ip, skb->data+ETH_HLEN+16, 4)) {
 				memcpy(skb->data, priv->scdb_mac, ETH_ALEN);
 
@@ -1349,9 +1315,9 @@ int nat25_handle_frame(struct rtw_adapte
 				retval = nat25_db_handle(priv, skb, NAT25_LOOKUP);
 			}
 		} else {
-			if (((*((unsigned short *)(skb->data+ETH_ALEN*2)) == __constant_htons(ETH_P_IP)) &&
+			if (((be16_to_cpu(*((__be16 *)(skb->data+ETH_ALEN*2))) == ETH_P_IP) &&
 			     !memcmp(priv->br_ip, skb->data+ETH_HLEN+16, 4)) ||
-			     ((*((unsigned short *)(skb->data+ETH_ALEN*2)) == __constant_htons(ETH_P_ARP)) &&
+			     ((be16_to_cpu(*((__be16 *)(skb->data+ETH_ALEN*2))) == ETH_P_ARP) &&
 			     !memcmp(priv->br_ip, skb->data+ETH_HLEN+24, 4))) {
 				/*  for traffic to upper TCP/IP */
 				retval = nat25_db_handle(priv, skb, NAT25_LOOKUP);
@@ -1362,8 +1328,8 @@ int nat25_handle_frame(struct rtw_adapte
 			skb_push(skb, 4);
 			for (i = 0; i < 6; i++)
 				*((unsigned short *)(skb->data+i*2)) = *((unsigned short *)(skb->data+4+i*2));
-			*((unsigned short *)(skb->data+ETH_ALEN*2)) = __constant_htons(ETH_P_8021Q);
-			*((unsigned short *)(skb->data+ETH_ALEN*2+2)) = vlan_hdr;
+			*((__be16 *)(skb->data+ETH_ALEN*2)) = __constant_htons(ETH_P_8021Q);
+			*((__be16 *)(skb->data+ETH_ALEN*2+2)) = cpu_to_be16(vlan_hdr);
 		}
 
 		if (retval == -1)
@@ -1392,7 +1358,7 @@ struct dhcp_message {
 	u_int8_t chaddr[16];
 	u_int8_t sname[64];
 	u_int8_t file[128];
-	u_int32_t cookie;
+	__be32 cookie;
 	u_int8_t options[308]; /* 312 - cookie */
 };
 
@@ -1402,7 +1368,7 @@ void dhcp_flag_bcast(struct rtw_adapter
 		return;
 
 	if (!priv->eth_br_ext_info.dhcp_bcst_disable) {
-		unsigned short protocol = *((unsigned short *)(skb->data + 2 * ETH_ALEN));
+		__be16 protocol = *((__be16 *)(skb->data + 2 * ETH_ALEN));
 
 		if (protocol == __constant_htons(ETH_P_IP)) { /*  IP */
 			struct iphdr *iph = (struct iphdr *)(skb->data + ETH_HLEN);
@@ -1414,8 +1380,9 @@ void dhcp_flag_bcast(struct rtw_adapter
 				    (udph->dest == __constant_htons(SERVER_PORT))) { /*  DHCP request */
 					struct dhcp_message *dhcph =
 						(struct dhcp_message *)((SIZE_PTR)udph + sizeof(struct udphdr));
+					u32 cookie = be32_to_cpu((__be32)dhcph->cookie);
 
-					if (dhcph->cookie == __constant_htonl(DHCP_MAGIC)) { /*  match magic word */
+					if (cookie == DHCP_MAGIC) { /*  match magic word */
 						if (!(dhcph->flags & htons(BROADCAST_FLAG))) { /*  if not broadcast */
 							register int sum = 0;
 
--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -367,7 +367,7 @@ int rtw_cmd_thread(void *context)
 {
 	u8 ret;
 	struct cmd_obj *pcmd;
-	u8 *pcmdbuf, *prspbuf;
+	u8 *pcmdbuf;
 	u8 (*cmd_hdl)(struct rtw_adapter *padapter, u8 *pbuf);
 	void (*pcmd_callback)(struct rtw_adapter *dev, struct cmd_obj *pcmd);
 	struct rtw_adapter *padapter = (struct rtw_adapter *)context;
@@ -378,7 +378,6 @@ _func_enter_;
 	thread_enter("RTW_CMD_THREAD");
 
 	pcmdbuf = pcmdpriv->cmd_buf;
-	prspbuf = pcmdpriv->rsp_buf;
 
 	pcmdpriv->cmdthd_running = true;
 	_rtw_up_sema(&pcmdpriv->terminate_cmdthread_sema);
@@ -1022,7 +1021,7 @@ _func_exit_;
 
 u8 rtw_joinbss_cmd(struct rtw_adapter *padapter, struct wlan_network *pnetwork)
 {
-	u8 *auth, res = _SUCCESS;
+	u8 res = _SUCCESS;
 	uint	t_len = 0;
 	struct wlan_bssid_ex	*psecnetwork;
 	struct cmd_obj *pcmd;
@@ -1084,7 +1083,6 @@ _func_enter_;
 
 	memcpy(psecnetwork, &pnetwork->network, get_wlan_bssid_ex_sz(&pnetwork->network));
 
-	auth = &psecuritypriv->authenticator_ie[0];
 	psecuritypriv->authenticator_ie[0] = (unsigned char)psecnetwork->IELength;
 
 	if ((psecnetwork->IELength-12) < (256-1)) {
--- a/drivers/staging/rtl8192du/core/rtw_debug.c
+++ b/drivers/staging/rtl8192du/core/rtw_debug.c
@@ -98,7 +98,7 @@ int proc_set_log_level(struct file *file
 	struct net_device *dev = (struct net_device *)data;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	char tmp[32];
-	u32 is_signal_dbg;
+	s32 is_signal_dbg;
 
 	if (count < 1)
 		return -EFAULT;
@@ -673,7 +673,8 @@ int proc_set_rx_signal(struct file *file
 	struct net_device *dev = (struct net_device *)data;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	char tmp[32];
-	u32 is_signal_dbg, signal_strength;
+	u32 is_signal_dbg;
+	s32 signal_strength;
 
 	if (count < 1)
 		return -EFAULT;
@@ -727,7 +728,7 @@ int proc_set_ht_enable(struct file *file
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
 	char tmp[32];
-	u32 mode;
+	s32 mode;
 
 	if (count < 1)
 		return -EFAULT;
@@ -771,7 +772,7 @@ int proc_set_cbw40_enable(struct file *f
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
 	char tmp[32];
-	u32 mode;
+	s32 mode;
 
 	if (count < 1)
 		return -EFAULT;
@@ -814,7 +815,7 @@ int proc_set_ampdu_enable(struct file *f
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
 	char tmp[32];
-	u32 mode;
+	s32 mode;
 
 	if (count < 1)
 		return -EFAULT;
--- a/drivers/staging/rtl8192du/core/rtw_efuse.c
+++ b/drivers/staging/rtl8192du/core/rtw_efuse.c
@@ -479,7 +479,7 @@ u8 rtw_efuse_map_write(struct rtw_adapte
 	u8 offset, word_en;
 	u8 *map;
 	u8 newdata[PGPKT_DATA_SIZE];
-	s32	i, j, idx;
+	s32	i, idx;
 	u8 ret = _SUCCESS;
 	u16 maplen = 0;
 
@@ -502,7 +502,6 @@ u8 rtw_efuse_map_write(struct rtw_adapte
 	word_en = 0xF;
 	memset(newdata, 0xFF, PGPKT_DATA_SIZE);
 	i = addr & 0x7;	/*  index of one package */
-	j = 0;		/*  index of new package */
 	idx = 0;	/*  data index */
 
 	if (i & 0x1) {
@@ -556,7 +555,6 @@ u8 rtw_efuse_map_write(struct rtw_adapte
 
 		offset++;
 		i = 0;
-		j = 0;
 		word_en = 0xF;
 		memset(newdata, 0xFF, PGPKT_DATA_SIZE);
 	} while (1);
--- a/drivers/staging/rtl8192du/core/rtw_ieee80211.c
+++ b/drivers/staging/rtl8192du/core/rtw_ieee80211.c
@@ -651,7 +651,7 @@ int rtw_parse_wpa2_ie(u8 *rsn_ie, int rs
 
 int rtw_get_sec_ie(u8 *in_ie, uint in_len, u8 *rsn_ie, u16 *rsn_len, u8 *wpa_ie, u16 *wpa_len)
 {
-	u8 authmode, sec_idx, i;
+	u8 authmode, i;
 	u8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};
 	uint	cnt;
 
@@ -661,16 +661,14 @@ _func_enter_;
 
 	cnt = (_TIMESTAMP_ + _BEACON_ITERVAL_ + _CAPABILITY_);
 
-	sec_idx = 0;
-
 	while (cnt < in_len) {
 		authmode = in_ie[cnt];
 
 		if ((authmode == _WPA_IE_ID_) &&
 		    (_rtw_memcmp(&in_ie[cnt+2], &wpa_oui[0], 4) == true)) {
 				RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
-					 ("\n rtw_get_wpa_ie: sec_idx =%d in_ie[cnt+1]+2 =%d\n",
-					 sec_idx, in_ie[cnt+1]+2));
+					 ("\n rtw_get_wpa_ie: in_ie[cnt+1]+2 =%d\n",
+					 in_ie[cnt+1]+2));
 
 				memcpy(wpa_ie, &in_ie[cnt], in_ie[cnt+1]+2);
 
--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -551,16 +551,12 @@ _func_exit_;
 
 u8 rtw_set_802_11_add_wep(struct rtw_adapter *padapter, struct ndis_802_11_wep *wep)
 {
-	u8		bdefaultkey;
-	u8		btransmitkey;
 	int		keyid, res;
 	struct security_priv *psecuritypriv = &(padapter->securitypriv);
 	u8		ret = _SUCCESS;
 
 _func_enter_;
 
-	bdefaultkey = (wep->KeyIndex & 0x40000000) > 0 ? false : true;   /* for ??? */
-	btransmitkey = (wep->KeyIndex & 0x80000000) > 0 ? true  : false;	/* for ??? */
 	keyid = wep->KeyIndex & 0x3fffffff;
 
 	if (keyid > 4) {
@@ -837,7 +833,6 @@ _func_enter_;
 	/*  If WEP encryption algorithm, just call rtw_set_802_11_add_wep(). */
 	if ((padapter->securitypriv.dot11AuthAlgrthm != dot11AuthAlgrthm_8021X) && (encryptionalgo == _WEP40_ ||
 	    encryptionalgo == _WEP104_)) {
-		u8 ret;
 		u32 keyindex;
 		u32 len = FIELD_OFFSET(struct ndis_802_11_key, KeyMaterial) + key->KeyLength;
 		struct ndis_802_11_wep *wep = &padapter->securitypriv.ndiswep;
@@ -997,7 +992,6 @@ _func_exit_;
 u8 rtw_set_802_11_remove_key(struct rtw_adapter *padapter,
 			     struct ndis_802_11_remove_key *key)
 {
-	uint	encryptionalgo;
 	u8 *pbssid;
 	struct sta_info *stainfo;
 	u8	bgroup = (key->KeyIndex & 0x4000000) > 0 ? false : true;
@@ -1011,7 +1005,6 @@ _func_enter_;
 		goto exit;
 	}
 	if (bgroup == true) {
-		encryptionalgo = padapter->securitypriv.dot118021XGrpPrivacy;
 		/*  clear group key by index */
 
 		memset(&padapter->securitypriv.dot118021XGrpKey[keyIndex], 0, 16);
@@ -1021,8 +1014,6 @@ _func_enter_;
 		pbssid = get_bssid(&padapter->mlmepriv);
 		stainfo = rtw_get_stainfo(&padapter->stapriv, pbssid);
 		if (stainfo != NULL) {
-			encryptionalgo = stainfo->dot118021XPrivacy;
-
 			/*  clear key by BSSID */
 			memset(&stainfo->dot118021x_UncstKey, 0, 16);
 			/*  \todo Send a H2C Command to Firmware for disable this Key in CAM Entry. */
@@ -1036,7 +1027,7 @@ exit:
 
 _func_exit_;
 
-	return true;
+	return ret;
 }
 
 /*
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -560,7 +560,7 @@ int rtw_is_same_ibss(struct rtw_adapter
 	return ret;
 }
 
-inline int is_same_ess(struct wlan_bssid_ex *a, struct wlan_bssid_ex *b)
+static inline int is_same_ess(struct wlan_bssid_ex *a, struct wlan_bssid_ex *b)
 {
 	/* RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("(%s,%d)(%s,%d)\n", */
 	/*              a->Ssid.Ssid,a->Ssid.SsidLength,b->Ssid.Ssid,b->Ssid.SsidLength)); */
@@ -1612,7 +1612,9 @@ static void rtw_joinbss_update_network(s
 /* define REJOIN */
 void rtw_joinbss_event_prehandle(struct rtw_adapter *adapter, u8 *pbuf)
 {
+#ifdef REJOIN
 	static u8 retry;
+#endif
 	u8 timer_cancelled;
 	struct sta_info *ptarget_sta = NULL, *pcur_sta = NULL;
 	struct sta_priv *pstapriv = &adapter->stapriv;
@@ -1657,7 +1659,9 @@ void rtw_joinbss_event_prehandle(struct
 
 	if (pnetwork->join_res > 0) {
 		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+#ifdef REJOIN
 		retry = 0;
+#endif
 		if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {
 			/* s1. find ptarget_wlan */
 			if (check_fwstate(pmlmepriv, _FW_LINKED)) {
@@ -2958,8 +2962,8 @@ unsigned int rtw_restructure_ht_ie(struc
 				   u8 *out_ie, uint in_len, uint *pout_len,
 				   u8 channel)
 {
-	u32 ielen, out_len;
-	unsigned char *p, *pframe;
+	u32 ielen;
+	unsigned char *p;
 	struct rtw_ieee80211_ht_cap ht_capie;
 	unsigned char WMM_IE[] = { 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00 };
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -2973,16 +2977,8 @@ unsigned int rtw_restructure_ht_ie(struc
 	p = rtw_get_ie(in_ie + 12, _HT_CAPABILITY_IE_, &ielen, in_len - 12);
 
 	if (p && ielen > 0) {
-		if (pqospriv->qos_option == 0) {
-			out_len = *pout_len;
-			pframe =
-			    rtw_set_ie(out_ie + out_len, _VENDOR_SPECIFIC_IE_,
-				       _WMM_IE_Length_, WMM_IE, pout_len);
-
+		if (pqospriv->qos_option == 0)
 			pqospriv->qos_option = 1;
-		}
-
-		out_len = *pout_len;
 
 		memset(&ht_capie, 0, sizeof(struct rtw_ieee80211_ht_cap));
 
@@ -3008,10 +3004,6 @@ unsigned int rtw_restructure_ht_ie(struc
 					    &rx_packet_offset);
 			rtw_hal_get_def_var(padapter, HAL_DEF_MAX_RECVBUF_SZ,
 					    &max_recvbuf_sz);
-			/* if (max_recvbuf_sz-rx_packet_offset>(8191-256)) { */
-			/*      DBG_8192D("%s IEEE80211_HT_CAP_MAX_AMSDU is set\n", __func__); */
-			/*      ht_capie.cap_info = ht_capie.cap_info |IEEE80211_HT_CAP_MAX_AMSDU; */
-			/*  */
 		}
 
 		ht_capie.ampdu_params_info =
@@ -3024,19 +3016,10 @@ unsigned int rtw_restructure_ht_ie(struc
 			ht_capie.ampdu_params_info |=
 			    (IEEE80211_HT_CAP_AMPDU_DENSITY & 0x00);
 
-		pframe = rtw_set_ie(out_ie + out_len, _HT_CAPABILITY_IE_,
-				    sizeof(struct rtw_ieee80211_ht_cap),
-				    (unsigned char *)&ht_capie, pout_len);
 		phtpriv->ht_option = true;
 
 		p = rtw_get_ie(in_ie + 12, _HT_ADD_INFO_IE_, &ielen,
 			       in_len - 12);
-		if (p && (ielen == sizeof(struct ieee80211_ht_addt_info))) {
-			out_len = *pout_len;
-			pframe =
-			    rtw_set_ie(out_ie + out_len, _HT_ADD_INFO_IE_,
-				       ielen, p + 2, pout_len);
-		}
 	}
 	return phtpriv->ht_option;
 }
@@ -3049,7 +3032,6 @@ void rtw_update_ht_cap(struct rtw_adapte
 	int len;
 	/* struct sta_info *bmc_sta, *psta; */
 	struct rtw_ieee80211_ht_cap *pht_capie;
-	struct ieee80211_ht_addt_info *pht_addtinfo;
 	/* struct recv_reorder_ctrl *preorder_ctrl; */
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
@@ -3100,10 +3082,6 @@ void rtw_update_ht_cap(struct rtw_adapte
 	p = rtw_get_ie(pie + sizeof(struct ndis_802_11_fixed_ies),
 		       _HT_ADD_INFO_IE_, &len,
 		       ie_len - sizeof(struct ndis_802_11_fixed_ies));
-	if (p && len > 0) {
-		pht_addtinfo = (struct ieee80211_ht_addt_info *)(p + 2);
-		/* todo: */
-	}
 
 	if (channel > 14) {
 		if (pregistrypriv->cbw40_enable & BIT(1))
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -1268,7 +1268,7 @@ auth_fail:
 unsigned int OnAuthClient(struct rtw_adapter *adapt,
 			  union recv_frame *precv_frame)
 {
-	unsigned int seq, len, status, algthm, offset;
+	unsigned int seq, len, status, offset;
 	unsigned char *p;
 	unsigned int go2asoc = 0;
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
@@ -1288,14 +1288,9 @@ unsigned int OnAuthClient(struct rtw_ada
 
 	offset = (GetPrivacy(pframe)) ? 4 : 0;
 
-	algthm =
-	    le16_to_cpu(*(unsigned short *)
-			((SIZE_PTR) pframe + WLAN_HDR_A3_LEN + offset));
-	seq =
-	    le16_to_cpu(*(unsigned short *)
+	seq = le16_to_cpu(*(unsigned short *)
 			((SIZE_PTR) pframe + WLAN_HDR_A3_LEN + offset + 2));
-	status =
-	    le16_to_cpu(*(unsigned short *)
+	status = le16_to_cpu(*(unsigned short *)
 			((SIZE_PTR) pframe + WLAN_HDR_A3_LEN + offset + 4));
 
 	if (status != 0) {
@@ -1359,7 +1354,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 			union recv_frame *precv_frame)
 {
 #ifdef CONFIG_AP_MODE
-	u16 capab_info, listen_interval;
+	u16 capab_info;
 	struct rtw_ieee802_11_elems elems;
 	struct sta_info *pstat;
 	unsigned char reassoc, *p, *pos, *wpa_ie;
@@ -1423,7 +1418,6 @@ unsigned int OnAssocReq(struct rtw_adapt
 	}
 
 	capab_info = RTW_GET_LE16(pframe + WLAN_HDR_A3_LEN);
-	listen_interval = RTW_GET_LE16(pframe + WLAN_HDR_A3_LEN + 2);
 
 	left = pkt_len - (IEEE80211_3ADDR_LEN + ie_offset);
 	pos = pframe + (IEEE80211_3ADDR_LEN + ie_offset);
@@ -2881,7 +2875,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	return;
 }
 
-void issue_p2p_GO_response(struct rtw_adapter *adapt, u8 *raddr,
+static void issue_p2p_GO_response(struct rtw_adapter *adapt, u8 *raddr,
 			   u8 *frame_body, uint len, u8 result)
 {
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
@@ -3358,7 +3352,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	return;
 }
 
-void issue_p2p_GO_confirm(struct rtw_adapter *adapt, u8 *raddr, u8 result)
+static void issue_p2p_GO_confirm(struct rtw_adapter *adapt, u8 *raddr, u8 result)
 {
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8 action = P2P_PUB_ACTION_ACTION;
@@ -4321,7 +4315,7 @@ void issue_p2p_provision_request(struct
 	return;
 }
 
-u8 is_matched_in_profilelist(u8 *peermacaddr,
+static u8 is_matched_in_profilelist(u8 *peermacaddr,
 			     struct profile_info *profileinfo)
 {
 	u8 i, match_result = 0;
@@ -4715,7 +4709,7 @@ void issue_probersp_p2p(struct rtw_adapt
 	return;
 }
 
-int _issue_probereq_p2p(struct rtw_adapter *adapt, u8 *da, int wait_ack)
+static int _issue_probereq_p2p(struct rtw_adapter *adapt, u8 *da, int wait_ack)
 {
 	int ret = _FAIL;
 	struct xmit_frame *pmgntframe;
@@ -5134,7 +5128,7 @@ exit:
 
 #endif /* CONFIG_P2P */
 
-s32 rtw_action_public_decache(union recv_frame *recv_frame, s32 token)
+static s32 rtw_action_public_decache(union recv_frame *recv_frame, s32 token)
 {
 	struct rtw_adapter *adapter = recv_frame->u.hdr.adapter;
 	struct mlme_ext_priv *mlmeext = &(adapter->mlmeextpriv);
@@ -5171,7 +5165,7 @@ s32 rtw_action_public_decache(union recv
 	return _SUCCESS;
 }
 
-unsigned int on_action_public_p2p(union recv_frame *precv_frame)
+static unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 {
 	struct rtw_adapter *adapt = precv_frame->u.hdr.adapter;
 	u8 *pframe = precv_frame->u.hdr.rx_data;
@@ -5255,11 +5249,9 @@ unsigned int on_action_public_p2p(union
 			/*      Commented by Kurt 20120113 */
 			/*      Get peer_dev_addr here if peer doesn't issue prov_disc frame. */
 /* XXXXXXXX */
-			if (_rtw_memcmp
-			    (pwdinfo->rx_prov_disc_info.peerDevAddr,
-			     empty_addr, ETH_ALEN)) ;
-			memcpy(pwdinfo->rx_prov_disc_info.peerDevAddr,
-			       GetAddr2Ptr(pframe), ETH_ALEN);
+			if (_rtw_memcmp(pwdinfo->rx_prov_disc_info.peerDevAddr, empty_addr, ETH_ALEN))
+				memcpy(pwdinfo->rx_prov_disc_info.peerDevAddr,
+			GetAddr2Ptr(pframe), ETH_ALEN);
 
 			result =
 			    process_p2p_group_negotation_req(pwdinfo,
@@ -5760,7 +5752,7 @@ unsigned int on_action_public_p2p(union
 	return _SUCCESS;
 }
 
-unsigned int on_action_public_vendor(union recv_frame *precv_frame)
+static unsigned int on_action_public_vendor(union recv_frame *precv_frame)
 {
 	unsigned int ret = _FAIL;
 	u8 *pframe = precv_frame->u.hdr.rx_data;
@@ -5774,7 +5766,7 @@ unsigned int on_action_public_vendor(uni
 	return ret;
 }
 
-unsigned int on_action_public_default(union recv_frame *precv_frame, u8 action)
+static unsigned int on_action_public_default(union recv_frame *precv_frame, u8 action)
 {
 	unsigned int ret = _FAIL;
 	u8 *pframe = precv_frame->u.hdr.rx_data;
@@ -5852,7 +5844,7 @@ unsigned int OnAction_p2p(struct rtw_ada
 {
 #ifdef CONFIG_P2P
 	u8 *frame_body;
-	u8 category, OUI_Subtype, dialogToken = 0;
+	u8 category, OUI_Subtype;
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	uint len = precv_frame->u.hdr.len;
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
@@ -5882,7 +5874,6 @@ unsigned int OnAction_p2p(struct rtw_ada
 	{
 		len -= sizeof(struct rtw_ieee80211_hdr_3addr);
 		OUI_Subtype = frame_body[5];
-		dialogToken = frame_body[6];
 		switch (OUI_Subtype) {
 		case P2P_NOTICE_OF_ABSENCE:
 			break;
@@ -6077,7 +6068,7 @@ s32 dump_mgntframe_and_wait_ack(struct r
 #endif /* CONFIG_XMIT_ACK */
 }
 
-int update_hidden_ssid(u8 *ies, u32 ies_len, u8 hidden_ssid_mode)
+static int update_hidden_ssid(u8 *ies, u32 ies_len, u8 hidden_ssid_mode)
 {
 	u8 *ssid_ie;
 	int ssid_len_ori;
@@ -6727,7 +6718,7 @@ void issue_probersp(struct rtw_adapter *
 	return;
 }
 
-int _issue_probereq(struct rtw_adapter *adapt,
+static int _issue_probereq(struct rtw_adapter *adapt,
 		    struct ndis_802_11_ssid *pssid, u8 *da, int wait_ack)
 {
 	int ret = _FAIL;
@@ -10203,7 +10194,7 @@ void mlmeext_sta_del_event_callback(stru
 Following are the functions for the timer handlers
 
 *****************************************************************************/
-void _linked_rx_signal_strehgth_display(struct rtw_adapter *adapt)
+static void _linked_rx_signal_strehgth_display(struct rtw_adapter *adapt)
 {
 	int UndecoratedSmoothedPWDB;
 
@@ -10265,7 +10256,7 @@ void _linked_rx_signal_strehgth_display(
 	DBG_8192D(" FalseAlmCnt_all(%d)\n", adapt->recvpriv.falsealmcnt_all);
 }
 
-u8 chk_ap_is_alive(struct rtw_adapter *adapt, struct sta_info *psta)
+static u8 chk_ap_is_alive(struct rtw_adapter *adapt, struct sta_info *psta)
 {
 	u8 ret = false;
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
@@ -10908,7 +10899,7 @@ u8 disconnect_hdl(struct rtw_adapter *ad
 	return H2C_SUCCESS;
 }
 
-int rtw_scan_ch_decision(struct rtw_adapter *adapt,
+static int rtw_scan_ch_decision(struct rtw_adapter *adapt,
 			 struct rtw_ieee80211_channel *out, u32 out_num,
 			 struct rtw_ieee80211_channel *in, u32 in_num)
 {
@@ -11336,7 +11327,10 @@ exit:
 
 u8 mlme_evt_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
 {
-	u8 evt_code, evt_seq;
+	u8 evt_code;
+#ifdef CHECK_EVENT_SEQ
+	u8 evt_seq;
+#endif
 	u16 evt_sz;
 	uint *peventbuf;
 	void (*event_callback) (struct rtw_adapter *dev, u8 *pbuf);
@@ -11344,7 +11338,9 @@ u8 mlme_evt_hdl(struct rtw_adapter *adap
 
 	peventbuf = (uint *)pbuf;
 	evt_sz = (u16) (*peventbuf & 0xffff);
+#ifdef CHECK_EVENT_SEQ
 	evt_seq = (u8) ((*peventbuf >> 24) & 0x7f);
+#endif
 	evt_code = (u8) ((*peventbuf >> 16) & 0xff);
 
 #ifdef CHECK_EVENT_SEQ
@@ -12146,7 +12142,6 @@ int concurrent_chk_start_clnt_join(struc
 {
 	int ret = _FAIL;
 	struct mlme_ext_priv *pmlmeext;
-	struct mlme_ext_info *pmlmeinfo;
 	struct rtw_adapter *pbuddy_adapter;
 	struct mlme_ext_priv *pbuddy_mlmeext;
 	struct mlme_ext_info *pbuddy_pmlmeinfo;
@@ -12156,7 +12151,6 @@ int concurrent_chk_start_clnt_join(struc
 		return _SUCCESS;
 
 	pmlmeext = &adapt->mlmeextpriv;
-	pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	pbuddy_adapter = adapt->pbuddy_adapter;
 	pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -12226,7 +12220,6 @@ int concurrent_chk_start_clnt_join(struc
 void concurrent_chk_joinbss_done(struct rtw_adapter *adapt, int join_res)
 {
 	struct mlme_ext_priv *pmlmeext;
-	struct mlme_ext_info *pmlmeinfo;
 	struct rtw_adapter *pbuddy_adapter;
 	struct mlme_priv *pbuddy_mlmepriv;
 	struct mlme_ext_priv *pbuddy_mlmeext;
@@ -12237,7 +12230,6 @@ void concurrent_chk_joinbss_done(struct
 		return;
 
 	pmlmeext = &adapt->mlmeextpriv;
-	pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	pbuddy_adapter = adapt->pbuddy_adapter;
 	pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
@@ -12522,17 +12514,16 @@ u8 set_chplan_hdl(struct rtw_adapter *ad
 
 u8 led_blink_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
 {
+#ifdef CONFIG_LED_HANDLED_BY_CMD_THREAD
 	struct LedBlink_param *ledBlink_param;
-
+#endif
 	if (!pbuf)
 		return H2C_PARAMETERS_ERROR;
 
-	ledBlink_param = (struct LedBlink_param *)pbuf;
-
 #ifdef CONFIG_LED_HANDLED_BY_CMD_THREAD
+	ledBlink_param = (struct LedBlink_param *)pbuf;
 	BlinkHandler(ledBlink_param->pLed);
 #endif
-
 	return H2C_SUCCESS;
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -2325,7 +2325,7 @@ u8 process_p2p_provdisc_resp(struct wifi
 	return true;
 }
 
-u8 rtw_p2p_get_peer_ch_list(struct wifidirect_info *pwdinfo, u8 *ch_content, u8 ch_cnt, u8 *peer_ch_list)
+static u8 rtw_p2p_get_peer_ch_list(struct wifidirect_info *pwdinfo, u8 *ch_content, u8 ch_cnt, u8 *peer_ch_list)
 {
 	u8 i = 0, j = 0;
 	u8 temp = 0;
@@ -2347,7 +2347,7 @@ u8 rtw_p2p_get_peer_ch_list(struct wifid
 	return ch_no;
 }
 
-u8 rtw_p2p_check_peer_oper_ch(struct mlme_ext_priv *pmlmeext, u8 ch)
+static u8 rtw_p2p_check_peer_oper_ch(struct mlme_ext_priv *pmlmeext, u8 ch)
 {
 	u8 i = 0;
 
@@ -2359,7 +2359,7 @@ u8 rtw_p2p_check_peer_oper_ch(struct mlm
 	return _FAIL;
 }
 
-u8 rtw_p2p_ch_inclusion(struct mlme_ext_priv *pmlmeext, u8 *peer_ch_list, u8 peer_ch_num, u8 *ch_list_inclusioned)
+static u8 rtw_p2p_ch_inclusion(struct mlme_ext_priv *pmlmeext, u8 *peer_ch_list, u8 peer_ch_num, u8 *ch_list_inclusioned)
 {
 	int	i = 0, j = 0, temp = 0;
 	u8 ch_no = 0;
@@ -2870,12 +2870,11 @@ u8 process_p2p_presence_req(struct wifid
 	return true;
 }
 
-void find_phase_handler(struct rtw_adapter *padapter)
+static void find_phase_handler(struct rtw_adapter *padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct ndis_802_11_ssid	ssid;
-	u8 _status = 0;
 
 _func_enter_;
 
@@ -2886,7 +2885,7 @@ _func_enter_;
 	rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
 
 	spin_lock_bh(&pmlmepriv->lock);
-	_status = rtw_sitesurvey_cmd(padapter, &ssid, 1, NULL, 0);
+	rtw_sitesurvey_cmd(padapter, &ssid, 1, NULL, 0);
 	spin_unlock_bh(&pmlmepriv->lock);
 
 
@@ -2895,7 +2894,7 @@ _func_exit_;
 
 void p2p_concurrent_handler(struct rtw_adapter *padapter);
 
-void restore_p2p_state_handler(struct rtw_adapter *padapter)
+static void restore_p2p_state_handler(struct rtw_adapter *padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -2934,7 +2933,7 @@ _func_enter_;
 _func_exit_;
 }
 
-void pre_tx_invitereq_handler(struct rtw_adapter *padapter)
+static void pre_tx_invitereq_handler(struct rtw_adapter *padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	u8 val8 = 1;
@@ -2948,7 +2947,7 @@ _func_enter_;
 _func_exit_;
 }
 
-void pre_tx_provdisc_handler(struct rtw_adapter *padapter)
+static void pre_tx_provdisc_handler(struct rtw_adapter *padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	u8 val8 = 1;
@@ -2962,7 +2961,7 @@ _func_enter_;
 _func_exit_;
 }
 
-void pre_tx_negoreq_handler(struct rtw_adapter *padapter)
+static void pre_tx_negoreq_handler(struct rtw_adapter *padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	u8 val8 = 1;
@@ -3843,7 +3842,7 @@ static void find_phase_timer_process(voi
 }
 
 #ifdef CONFIG_CONCURRENT_MODE
-void ap_p2p_switch_timer_process(void *FunctionContext)
+static void ap_p2p_switch_timer_process(void *FunctionContext)
 {
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
@@ -3931,8 +3930,6 @@ void init_wifidirect_info(struct rtw_ada
 #endif
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
-	struct wifidirect_info	*pbuddy_wdinfo;
-	struct mlme_priv		*pbuddy_mlmepriv;
 	struct mlme_ext_priv	*pbuddy_mlmeext;
 #endif
 
@@ -3947,11 +3944,8 @@ void init_wifidirect_info(struct rtw_ada
 	pwdinfo->social_chan[3] = 0;	/*	channel 0 for scanning ending in site survey function. */
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (pbuddy_adapter) {
-		pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
-		pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
+	if (pbuddy_adapter)
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-	}
 
 	if ((check_buddy_fwstate(padapter, _FW_LINKED) == true) &&
 	    ((pbuddy_mlmeext->cur_channel == 1) ||
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -1964,7 +1964,7 @@ static union recv_frame *recvframe_defra
 				   struct __queue *defrag_q)
 {
 	struct list_head *plist, *phead;
-	u8 *data, wlanhdr_offset;
+	u8 wlanhdr_offset;
 	u8 curfragnum;
 	struct recv_frame_hdr *pfhdr, *pnfhdr;
 	union recv_frame *prframe, *pnextrframe;
@@ -1996,8 +1996,6 @@ static union recv_frame *recvframe_defra
 
 	plist = get_next(plist);
 
-	data = get_recvframe_data(prframe);
-
 	while (rtw_end_of_queue_search(phead, plist) == false) {
 		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pnfhdr = &pnextrframe->u.hdr;
@@ -3000,8 +2998,10 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 	u32 tmp_s, tmp_q;
 	u8 avg_signal_strength = 0;
 	u8 avg_signal_qual = 0;
+#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING)
 	u32 num_signal_strength = 0;
 	u32 num_signal_qual = 0;
+#endif
 	u8 _alpha = 3;		/*  this value is based on converging_constant = 5000 and sampling_interval = 1000 */
 
 	if (adapter->recvpriv.is_signal_dbg) {
@@ -3015,15 +3015,19 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 		if (recvpriv->signal_strength_data.update_req == 0) {	/*  update_req is clear, means we got rx */
 			avg_signal_strength =
 			    recvpriv->signal_strength_data.avg_val;
+#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING)
 			num_signal_strength =
 			    recvpriv->signal_strength_data.total_num;
+#endif
 			/*  after avg_vals are accquired, we can re-stat the signal values */
 			recvpriv->signal_strength_data.update_req = 1;
 		}
 
 		if (recvpriv->signal_qual_data.update_req == 0) {	/*  update_req is clear, means we got rx */
 			avg_signal_qual = recvpriv->signal_qual_data.avg_val;
+#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING)
 			num_signal_qual = recvpriv->signal_qual_data.total_num;
+#endif
 			/*  after avg_vals are accquired, we can re-stat the signal values */
 			recvpriv->signal_qual_data.update_req = 1;
 		}
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -640,7 +640,6 @@ u32 rtw_tkip_encrypt(struct rtw_adapter
 	u8 crc[4];
 	struct arc4context mycontext;
 	int curfragnum, length;
-	u32 prwskeylen;
 	u8 *pframe, *payload, *iv, *prwskey;
 	union pn48 dot11txpn;
 	struct sta_info *stainfo;
@@ -681,8 +680,6 @@ u32 rtw_tkip_encrypt(struct rtw_adapter
 			else
 				prwskey = &stainfo->dot118021x_UncstKey.skey[0];
 
-			prwskeylen = 16;
-
 			for (curfragnum = 0; curfragnum < pattrib->nr_frags;
 			     curfragnum++) {
 				iv = pframe + pattrib->hdrlen;
@@ -755,7 +752,6 @@ u32 rtw_tkip_decrypt(struct rtw_adapter
 	u8 crc[4];
 	struct arc4context mycontext;
 	int length;
-	u32 prwskeylen;
 
 	u8 *pframe, *payload, *iv, *prwskey;
 	union pn48 dot11txpn;
@@ -786,12 +782,10 @@ u32 rtw_tkip_decrypt(struct rtw_adapter
 				    psecuritypriv->dot118021XGrpKey[prxattrib->
 								    key_index].
 				    skey;
-				prwskeylen = 16;
 			} else {
 				RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
 					 ("rtw_tkip_decrypt: stainfo!= NULL!!!\n"));
 				prwskey = &stainfo->dot118021x_UncstKey.skey[0];
-				prwskeylen = 16;
 			}
 
 			iv = pframe + prxattrib->hdrlen;
@@ -1393,7 +1387,6 @@ u32 rtw_aes_encrypt(struct rtw_adapter *
 
 	/* Intermediate Buffers */
 	int curfragnum, length;
-	u32 prwskeylen;
 	u8 *pframe, *prwskey;	/*  *payload,*iv */
 	struct sta_info *stainfo;
 	struct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
@@ -1451,8 +1444,6 @@ u32 rtw_aes_encrypt(struct rtw_adapter *
 			}
 #endif /* CONFIG_TDLS */
 
-			prwskeylen = 16;
-
 			for (curfragnum = 0; curfragnum < pattrib->nr_frags;
 			     curfragnum++) {
 				if ((curfragnum + 1) == pattrib->nr_frags) {	/* 4 the last fragment */
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -285,7 +285,6 @@ _func_exit_;
 
 struct	sta_info *rtw_alloc_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
 {
-	uint tmp_aid;
 	s32	index;
 	struct list_head *phash_list;
 	struct sta_info	*psta;
@@ -311,8 +310,6 @@ _func_enter_;
 
 		spin_unlock_bh(&(pfree_sta_queue->lock));
 
-		tmp_aid = psta->aid;
-
 		_rtw_init_stainfo(psta);
 
 		memcpy(psta->hwaddr, hwaddr, ETH_ALEN);
@@ -631,7 +628,6 @@ _func_exit_;
 u32 rtw_init_bcmc_stainfo(struct rtw_adapter *padapter)
 {
 	struct sta_info		*psta;
-	struct tx_servq	*ptxservq;
 	u32 res = _SUCCESS;
 	unsigned char bcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 
@@ -651,11 +647,10 @@ _func_enter_;
 	/*  default broadcast & multicast use macid 1 */
 	psta->mac_id = 1;
 
-	ptxservq = &(psta->sta_xmitpriv.be_q);
 
 exit:
 _func_exit_;
-	return _SUCCESS;
+	return res;
 }
 
 
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -1568,7 +1568,11 @@ int update_sta_support_rate(struct rtw_a
 void process_addba_req(struct rtw_adapter *padapter, u8 *paddba_req, u8 *addr)
 {
 	struct sta_info *psta;
-	u16 tid, start_seq, param;
+	u16 tid;
+#ifdef CONFIG_UPDATE_INDICATE_SEQ_WHILE_PROCESS_ADDBA_REQ
+	u16 start_seq;
+#endif
+	u16 param;
 	struct recv_reorder_ctrl *preorder_ctrl;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct ADDBA_request	*preq = (struct ADDBA_request *)paddba_req;
@@ -1578,8 +1582,9 @@ void process_addba_req(struct rtw_adapte
 	psta = rtw_get_stainfo(pstapriv, addr);
 
 	if (psta) {
+		#ifdef CONFIG_UPDATE_INDICATE_SEQ_WHILE_PROCESS_ADDBA_REQ
 		start_seq = le16_to_cpu(preq->BA_starting_seqctrl) >> 4;
-
+		#endif
 		param = le16_to_cpu(preq->BA_para_set);
 		tid = (param>>2)&0x0f;
 
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -453,7 +453,6 @@ static void set_qos(struct pkt_file *ppk
 
 static s32 update_attrib(struct rtw_adapter *padapter, struct sk_buff *pkt, struct pkt_attrib *pattrib)
 {
-	uint i;
 	struct pkt_file pktfile;
 	struct sta_info *psta = NULL;
 	struct ethhdr etherhdr;
@@ -468,7 +467,7 @@ static s32 update_attrib(struct rtw_adap
 _func_enter_;
 
 	_rtw_open_pktfile(pkt, &pktfile);
-	i = _rtw_pktfile_read(&pktfile, (u8 *)&etherhdr, ETH_HLEN);
+	_rtw_pktfile_read(&pktfile, (u8 *)&etherhdr, ETH_HLEN);
 
 	pattrib->ether_type = ntohs(etherhdr.h_proto);
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -89,7 +89,6 @@ static void _FillH2CCmd92D(struct rtw_ad
 	u16	BOXReg=0, BOXExtReg=0;
 	u8	BoxContent[4], BoxExtContent[2];
 	u8	BufIndex=0;
-	u8	U1btmp; /* Read 0x1bf */
 	u8	bWriteSucess = false;
 	u8	IsFwRead = false;
 	u8	WaitH2cLimmit = 100;
@@ -150,7 +149,6 @@ _func_enter_;
 			}
 			rtw_udelay_os(10); /* us */
 			IsFwRead = CheckFwReadLastH2C(padapter, BoxNum);
-			U1btmp = rtw_read8(padapter, 0x1BF);
 		}
 
 		/*  If Fw has not read the last H2C cmd, break and give up this H2C. */
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -315,7 +315,6 @@ int FirmwareDownload92D(
 	s8				R92DFwImageFileName[] ={RTL8192D_FW_IMG};
 	u8*				FwImage;
 	u32				FwImageLen;
-	char*			pFwImageFileName;
 #ifdef CONFIG_WOWLAN
 	u8*			FwImageWoWLAN;
 	u32			FwImageWoWLANLen;
@@ -338,7 +337,6 @@ int FirmwareDownload92D(
 		goto Exit;
 	}
 
-	pFwImageFileName = R92DFwImageFileName;
 	FwImage = (u8 *)Rtl8192D_FwImageArray;
 	FwImageLen = Rtl8192D_FwImageArrayLength;
 #ifdef CONFIG_WOWLAN
@@ -1244,7 +1242,6 @@ ReadEFuse_RTL8192D(
 	u16  i, j;
 	u16	eFuseWord[EFUSE_MAX_SECTION][EFUSE_MAX_WORD_UNIT];
 	u16	efuse_utilized = 0;
-	u8	efuse_usage = 0;
 	u8	u1temp = 0;
 
 	/*  */
@@ -1380,7 +1377,6 @@ ReadEFuse_RTL8192D(
 	/*  */
 	/*  5. Calculate Efuse utilization. */
 	/*  */
-	efuse_usage = (u8)((efuse_utilized*100)/EFUSE_REAL_CONTENT_LEN);
 	rtw_hal_set_hwreg(Adapter, HW_VAR_EFUSE_BYTES, (u8*)&efuse_utilized);
 }
 
@@ -2080,7 +2076,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 			}
 		}
 	}
-	return true;
+	return bResult;
 }
 
 static u8
--- a/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
@@ -712,13 +712,12 @@ phy_ConfigMACWithHeaderFile(
  *  08/12/2008	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-int
-PHY_MACConfig8192D(
-	struct rtw_adapter *	Adapter
-	)
+int PHY_MACConfig8192D(struct rtw_adapter *Adapter)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
+#ifndef CONFIG_EMBEDDED_FWIMG
 	char		*pszMACRegFile;
+#endif
 	char		sz92DMACRegFile[] = RTL8192D_PHY_MACREG;
 	int		rtStatus = _SUCCESS;
 
@@ -727,7 +726,9 @@ PHY_MACConfig8192D(
 		return rtStatus;
 	}
 
+#ifndef CONFIG_EMBEDDED_FWIMG
 	pszMACRegFile = sz92DMACRegFile;
+#endif
 
 	/*  */
 	/*  Config MAC */
@@ -1233,22 +1234,28 @@ phy_BB8192D_Config_ParaFile(
 	s8		sz92DAGCTableFile[] = RTL8192D_AGC_TAB;
 	s8		sz92D2GAGCTableFile[] = RTL8192D_AGC_TAB_2G;
 	s8		sz92D5GAGCTableFile[] = RTL8192D_AGC_TAB_5G;
-	char		*pszBBRegFile, *pszAGCTableFile, *pszBBRegPgFile, *pszBBRegMpFile;
+#ifndef CONFIG_EMBEDDED_FWIMG
+	char		*pszBBRegFile;
+	char *pszAGCTableFile;
+	char *pszBBRegPgFile;
+	char *pszBBRegMpFile;
+#endif
 
+#ifndef CONFIG_EMBEDDED_FWIMG
 	pszBBRegFile = sz92DBBRegFile;
 	pszBBRegPgFile = sz92DBBRegPgFile;
 
 	/* Normal chip,Mac0 use AGC_TAB.txt for 2G and 5G band. */
-	if (pHalData->interfaceIndex == 0)
+	if (pHalData->interfaceIndex == 0) {
 		pszAGCTableFile = sz92DAGCTableFile;
-	else
-	{
+	} else {
 		if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 			pszAGCTableFile = sz92D2GAGCTableFile;
 		else
 			pszAGCTableFile = sz92D5GAGCTableFile;
 	}
 	pszBBRegMpFile = sz92DBBRegMpFile;
+#endif
 
 	/*  1. Read PHY_REG.TXT BB INIT!! */
 	/*  We will seperate as 88C / 92C according to chip version */
@@ -1622,7 +1629,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 			break;
 	}
 
-	return _SUCCESS;
+	return rtStatus;
 }
 
 
@@ -3363,7 +3370,7 @@ phy_PathA_IQK_5G_Normal(
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	u32	regEAC, regE94, regE9C, regEA4;
+	u32	regEAC, regE94, regEA4;
 	u8	result = 0x00;
 	u8	i = 0;
 #if MP_DRIVER == 1
@@ -3432,7 +3439,6 @@ phy_PathA_IQK_5G_Normal(
 		/*  Check failed */
 		regEAC = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
 		regE94 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord);
-		regE9C= PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord);
 		regEA4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
 
 		if (!(regEAC & TxOKBit) &&
@@ -3523,7 +3529,7 @@ phy_PathB_IQK_5G_Normal(
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	u32	regEAC, regEB4, regEBC, regEC4, regECC;
+	u32	regEAC, regEB4, regEC4;
 	u8	result = 0x00;
 	u8	i = 0;
 #if MP_DRIVER == 1
@@ -3579,9 +3585,7 @@ phy_PathB_IQK_5G_Normal(
 		/*  Check failed */
 		regEAC = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
 		regEB4 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord);
-		regEBC= PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord);
 		regEC4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
-		regECC= PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord);
 
 		if (!(regEAC & BIT31) &&
 			(((regEB4 & 0x03FF0000)>>16) != 0x142))
@@ -4129,13 +4133,7 @@ phy_IQCalibrate(
 
 	/*  Note: IQ calibration must be performed after loading */
 	/* 		PHY_REG.txt , and radio_a, radio_b.txt */
-
-	u32 bbvalue;
-
-	if (t==0)
-	{
-		bbvalue = PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bMaskDWord);
-
+	if (t == 0) {
 		/*  Save ADDA parameters, turn Path A ADDA on */
 		phy_SaveADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 		phy_SaveMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
@@ -4151,9 +4149,7 @@ phy_IQCalibrate(
 		PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x01017038);
 
 	if (t==0)
-	{
 		pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
-	}
 
 	if (!pdmpriv->bRfPiEnable) {
 		/*  Switch BB to PI mode to do IQ Calibration. */
@@ -4309,7 +4305,7 @@ phy_IQCalibrate_5G(
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	u32			extPAon, REG0xe5c, RX0REG0xe40, REG0xe40, REG0xe94, REG0xe9c;
+	u32			extPAon, REG0xe5c, RX0REG0xe40, REG0xe40, REG0xe94;
 	u32			REG0xeac, RX1REG0xe40, REG0xeb4, REG0xea4,REG0xec4;
 	u8			TX0IQKOK = false, TX1IQKOK = false ;
 	u32			TX_X0, TX_Y0, TX_X1, TX_Y1, RX_X0, RX_Y0, RX_X1, RX_Y1;
@@ -4429,7 +4425,6 @@ phy_IQCalibrate_5G(
 
 	if (((REG0xeac&BIT(28)) == 0) && (((REG0xe94&0x3FF0000)>>16)!=0x142))
 	{
-		REG0xe9c = PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord);
 		TX_X0 = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 		TX_Y0 = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 		RX0REG0xe40 =  0x80000000 | (REG0xe40 & 0xfc00fc00) | (TX_X0<<16) | TX_Y0;
@@ -4718,15 +4713,11 @@ phy_IQCalibrate_5G_Normal(
 	u8                 rfPathDiv;   /* for Path Diversity */
 	/*  */
 
-	u32	bbvalue;
 	bool		is2T =  IS_92D_SINGLEPHY(pHalData->VersionID);
 
 	rtw_mdelay_os(IQK_DELAY_TIME*20);
 
-	if (t==0)
-	{
-		bbvalue = PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bMaskDWord);
-
+	if (t==0) {
 		/*  Save ADDA parameters, turn Path A ADDA on */
 		phy_SaveADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 		phy_SaveMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
@@ -4990,22 +4981,17 @@ phy_CalcCurvIndex(
 		end_base = is5G?BASE_CHNL_NUM:BASE_CHNL_NUM_2G;
 	u8	chnl_num = is5G?TARGET_CHNL_NUM_2G_5G:TARGET_CHNL_NUM_2G;
 	u8	Base_chnl[BASE_CHNL_NUM] = {1, 14, 36, 100, 149};
-	u32	j, base_index = 0, search_bound=128;
-	bool	bBase = false;
+	u32	j, base_index = 0, search_bound = 128;
 
-	for (i=start; i<chnl_num; i++)
-	{
-		if (is5G)
-		{
+	for (i = start; i < chnl_num; i++) {
+		if (is5G) {
 			if (i != start)
 				pre_channel = channel;
 			channel = GetChnlFromPlace(i);	/* actual channel number */
 
 			if (i == start)
 				pre_channel = channel;
-		}
-		else
-		{
+		} else {
 			if (i != start)
 				pre_channel = channel;
 			channel = i+1;
@@ -5014,13 +5000,8 @@ phy_CalcCurvIndex(
 				pre_channel = channel;
 		}
 
-		bBase = false;
-
-		for (j = start_base; j < end_base; j++)
-		{
-			if (channel == Base_chnl[j])
-			{
-				bBase = true;
+		for (j = start_base; j < end_base; j++) {
+			if (channel == Base_chnl[j]) {
 				base_index = 0;
 				search_bound = (CV_CURVE_CNT*2);	/* search every 128 */
 				break;
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
@@ -586,7 +586,10 @@ phy_RF6052_Config_ParaFile(
 	int	rtStatus = _SUCCESS;
 	struct hal_data_8192du	*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	u8	*pszRadioAFile = NULL, *pszRadioBFile = NULL;
+#ifndef CONFIG_EMBEDDED_FWIMG
+	u8	*pszRadioAFile = NULL;
+	u8	*pszRadioBFile = NULL;
+#endif
 	static s8		sz92DRadioAFile[] = RTL8192D_PHY_RADIO_A;
 	static s8		sz92DRadioBFile[] = RTL8192D_PHY_RADIO_B;
 	static s8		sz92DRadioAintPAFile[] = RTL8192D_PHY_RADIO_A_intPA;
@@ -597,13 +600,17 @@ phy_RF6052_Config_ParaFile(
 	u32	MaskforPhySet = 0; /* For 92d PHY cross access, 88c must set value 0. */
 
 
+#ifndef CONFIG_EMBEDDED_FWIMG
 	pszRadioAFile = sz92DRadioAFile;
 	pszRadioBFile = sz92DRadioBFile;
+#endif
 
+#ifndef CONFIG_EMBEDDED_FWIMG
 	if (pHalData->InternalPA5G[0])
 		pszRadioAFile = sz92DRadioAintPAFile;
 	if (pHalData->InternalPA5G[1])
 		pszRadioBFile = sz92DRadioBintPAFile;
+#endif
 
 	/* DMDP,MAC0 on G band,MAC1 on A band. */
 	if (pHalData->MacPhyMode92D==DUALMAC_DUALPHY)
@@ -639,7 +646,9 @@ phy_RF6052_Config_ParaFile(
 		else if (pHalData->interfaceIndex == 1)
 		{
 			/*  MAC0 enabled, only init radia B. */
+#ifndef CONFIG_EMBEDDED_FWIMG
 			pszRadioAFile = pszRadioBFile;
+#endif
 			bTrueBPath = true;  /* vivi added this for read parameter from header, 20100909 */
 		}
 	}
@@ -663,7 +672,9 @@ phy_RF6052_Config_ParaFile(
 				bMac1NeedInitRadioAFirst = false;
 				eRFPath = RF_PATH_A;
 				bTrueBPath = true;
+#ifndef CONFIG_EMBEDDED_FWIMG
 				pszRadioAFile = pszRadioBFile;
+#endif
 				pHalData->NumTotalRFPath = 1;
 			}
 		}
@@ -681,7 +692,9 @@ phy_RF6052_Config_ParaFile(
 				bNeedPowerDownRadioB = true;
 				eRFPath = RF_PATH_A;
 				bTrueBPath = true;
+#ifndef CONFIG_EMBEDDED_FWIMG
 				pszRadioAFile = pszRadioBFile;
+#endif
 				pHalData->NumTotalRFPath = 1;
 			}
 		}
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -1447,7 +1447,6 @@ _InitOperationMode(
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	u8 regBwOpMode = 0, MinSpaceCfg = 0;
-	u32 regRATR = 0, regRRSR = 0;
 
 	/* 1 This part need to modified according to the rate set we filtered!! */
 	/*  */
@@ -1456,37 +1455,25 @@ _InitOperationMode(
 	switch (pHalData->CurrentWirelessMode) {
 	case WIRELESS_MODE_B:
 		regBwOpMode = BW_OPMODE_20MHZ;
-		regRATR = RATE_ALL_CCK;
-		regRRSR = RATE_ALL_CCK;
 		break;
 	case WIRELESS_MODE_A:
 		/* RT_ASSERT(FALSE,("Error wireless a mode\n")); */
 		regBwOpMode = BW_OPMODE_5G |BW_OPMODE_20MHZ;
-		regRATR = RATE_ALL_OFDM_AG;
-		regRRSR = RATE_ALL_OFDM_AG;
 		break;
 	case WIRELESS_MODE_G:
 		regBwOpMode = BW_OPMODE_20MHZ;
-		regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
-		regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 		break;
 	case WIRELESS_MODE_UNKNOWN:
 	case WIRELESS_MODE_AUTO:
 		regBwOpMode = BW_OPMODE_20MHZ;
-		regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
-		regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 		break;
 	case WIRELESS_MODE_N_24G:
 		/*  It support CCK rate by default. */
 		/*  CCK rate will be filtered out only when associated AP does not support it. */
 		regBwOpMode = BW_OPMODE_20MHZ;
-			regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
-			regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 		break;
 	case WIRELESS_MODE_N_5G:
 		regBwOpMode = BW_OPMODE_5G;
-		regRATR = RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
-		regRRSR = RATE_ALL_OFDM_AG;
 		break;
 	}
 
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -257,7 +257,7 @@ static u8 usb_read8(struct intf_hdl *pin
 {
 	u16 wvalue;
 	u16 len;
-	u32 data=0;
+	__le32 data;
 
 	_func_enter_;
 
@@ -275,7 +275,7 @@ static u16 usb_read16(struct intf_hdl *p
 {
 	u16 wvalue;
 	u16 len;
-	u32 data=0;
+	__le32 data;
 
 	_func_enter_;
 
@@ -293,7 +293,7 @@ static u32 usb_read32(struct intf_hdl *p
 {
 	u16 wvalue;
 	u16 len;
-	u32 data=0;
+	__le32 data;
 
 	_func_enter_;
 
@@ -316,7 +316,7 @@ static int usb_write8(struct intf_hdl *p
 {
 	u16 wvalue;
 	u16 len;
-	u32 data;
+	__le32 data;
 	int ret;
 
 	_func_enter_;
@@ -324,8 +324,7 @@ static int usb_write8(struct intf_hdl *p
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 1;
 
-	data = val;
-	data = cpu_to_le32(data&0x000000ff);
+	data = cpu_to_le32(val & 0x000000ff);
 
 	ret = usb_write_reg(pintfhdl, wvalue, &data, len);
 
@@ -338,7 +337,7 @@ static int usb_write16(struct intf_hdl *
 {
 	u16 wvalue;
 	u16 len;
-	u32 data;
+	__le32 data;
 	int ret;
 
 	_func_enter_;
@@ -346,8 +345,7 @@ static int usb_write16(struct intf_hdl *
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 2;
 
-	data = val;
-	data = cpu_to_le32(data&0x0000ffff);
+	data = cpu_to_le32(val & 0x0000ffff);
 
 	ret = usb_write_reg(pintfhdl, wvalue, &data, len);
 
@@ -360,7 +358,7 @@ static int usb_write32(struct intf_hdl *
 {
 	u16 wvalue;
 	u16 len;
-	u32 data;
+	__le32 data;
 	int ret;
 
 	_func_enter_;
--- a/drivers/staging/rtl8192du/include/ieee80211.h
+++ b/drivers/staging/rtl8192du/include/ieee80211.h
@@ -941,12 +941,12 @@ enum ieee80211_state {
 #define DEFAULT_MAX_SCAN_AGE (15 * HZ)
 #define DEFAULT_FTS 2346
 
-extern __inline int is_multicast_mac_addr(const u8 *addr)
+static __inline int is_multicast_mac_addr(const u8 *addr)
 {
         return ((addr[0] != 0xff) && (0x01 & addr[0]));
 }
 
-extern __inline int is_broadcast_mac_addr(const u8 *addr)
+static __inline int is_broadcast_mac_addr(const u8 *addr)
 {
 	return ((addr[0] == 0xff) && (addr[1] == 0xff) && (addr[2] == 0xff) &&   \
 		(addr[3] == 0xff) && (addr[4] == 0xff) && (addr[5] == 0xff));
--- a/drivers/staging/rtl8192du/include/rtw_recv.h
+++ b/drivers/staging/rtl8192du/include/rtw_recv.h
@@ -166,12 +166,12 @@ struct rx_pkt_attrib {
 
 struct recv_stat
 {
-	unsigned int rxdw0;
-	unsigned int rxdw1;
-	unsigned int rxdw2;
-	unsigned int rxdw3;
-	unsigned int rxdw4;
-	unsigned int rxdw5;
+	__le32 rxdw0;
+	__le32 rxdw1;
+	__le32 rxdw2;
+	__le32 rxdw3;
+	__le32 rxdw4;
+	__le32 rxdw5;
 };
 
 #define EOR BIT(30)
@@ -474,17 +474,13 @@ static inline u8 *recvframe_put(union re
 
 	/* used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller */
 	/* after putting, rx_tail must be still larger than rx_end. */
-	unsigned char * prev_rx_tail;
 
 	if (precvframe==NULL)
 		return NULL;
 
-	prev_rx_tail = precvframe->u.hdr.rx_tail;
-
 	precvframe->u.hdr.rx_tail += sz;
 
-	if (precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end)
-	{
+	if (precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end) {
 		precvframe->u.hdr.rx_tail -= sz;
 		return NULL;
 	}
@@ -492,7 +488,6 @@ static inline u8 *recvframe_put(union re
 	precvframe->u.hdr.len +=sz;
 
 	return precvframe->u.hdr.rx_tail;
-
 }
 
 
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -260,7 +260,8 @@ static char *translate_scan(struct rtw_a
 				char *start, char *stop)
 {
 	struct iw_event iwe;
-	u16 cap;
+	__le16 cap;
+	u16 cpu_cap;
 	u32 ht_ielen = 0;
 	char custom[MAX_CUSTOM_LEN];
 	char *p;
@@ -424,10 +425,10 @@ static char *translate_scan(struct rtw_a
 	memcpy((u8 *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
 
 
-	cap = le16_to_cpu(cap);
+	cpu_cap = le16_to_cpu(cap);
 
-	if (cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)) {
-		if (cap & WLAN_CAPABILITY_BSS)
+	if (cpu_cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)) {
+		if (cpu_cap & WLAN_CAPABILITY_BSS)
 			iwe.u.mode = IW_MODE_MASTER;
 		else
 			iwe.u.mode = IW_MODE_ADHOC;
@@ -447,7 +448,7 @@ static char *translate_scan(struct rtw_a
 
 	/* Add encryption capability */
 	iwe.cmd = SIOCGIWENCODE;
-	if (cap & WLAN_CAPABILITY_PRIVACY)
+	if (cpu_cap & WLAN_CAPABILITY_PRIVACY)
 		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
 	else
 		iwe.u.data.flags = IW_ENCODE_DISABLED;
@@ -499,8 +500,8 @@ static char *translate_scan(struct rtw_a
 		u8 wpa_ie[255], rsn_ie[255];
 		u16 wpa_len = 0, rsn_len = 0;
 		u8 *p;
-		int out_len = 0;
-		out_len = rtw_get_sec_ie(pnetwork->network.IEs , pnetwork->network.IELength, rsn_ie,&rsn_len, wpa_ie,&wpa_len);
+
+		rtw_get_sec_ie(pnetwork->network.IEs , pnetwork->network.IELength, rsn_ie,&rsn_len, wpa_ie,&wpa_len);
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan: ssid =%s\n", pnetwork->network.Ssid.Ssid));
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan: wpa_len =%d rsn_len =%d\n", wpa_len, rsn_len));
 
@@ -845,7 +846,7 @@ exit:
 
 static int rtw_set_wpa_ie(struct rtw_adapter *padapter, char *pie, unsigned short ielen)
 {
-	u8 *buf = NULL, *pos = NULL;
+	u8 *buf = NULL;
 	u32 left;
 	int group_cipher = 0, pairwise_cipher = 0;
 	int ret = 0;
@@ -880,7 +881,6 @@ static int rtw_set_wpa_ie(struct rtw_ada
 				DBG_8192D("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n", buf[i], buf[i+1], buf[i+2], buf[i+3], buf[i+4], buf[i+5], buf[i+6], buf[i+7]);
 		}
 
-		pos = buf;
 		if (ielen < RSN_HEADER_LEN) {
 			RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("Ie len too short %d\n", ielen));
 			ret  = -1;
@@ -1586,7 +1586,7 @@ static int rtw_wx_set_mlme(struct net_de
 			     union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
-	u16 reason;
+	__le16 reason;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_mlme *mlme = (struct iw_mlme *) extra;
 
@@ -1601,23 +1601,18 @@ static int rtw_wx_set_mlme(struct net_de
 
 	DBG_8192D("%s, cmd =%d, reason =%d\n", __func__, mlme->cmd, reason);
 
-	switch (mlme->cmd)
-	{
-		case IW_MLME_DEAUTH:
-				if (!rtw_set_802_11_disassociate(padapter))
-				ret = -1;
-				break;
-
-		case IW_MLME_DISASSOC:
-				if (!rtw_set_802_11_disassociate(padapter))
-						ret = -1;
-
-				break;
-
-		default:
-			return -EOPNOTSUPP;
+	switch (mlme->cmd) {
+	case IW_MLME_DEAUTH:
+			if (!rtw_set_802_11_disassociate(padapter))
+			ret = -1;
+			break;
+	case IW_MLME_DISASSOC:
+			if (!rtw_set_802_11_disassociate(padapter))
+					ret = -1;
+			break;
+	default:
+		return -EOPNOTSUPP;
 	}
-
 	return ret;
 }
 
@@ -3403,8 +3398,7 @@ static int rtw_wps_start(struct net_devi
         unsigned int uintRet = 0;
 
         uintRet = copy_from_user((void*) &u32wps_start, pdata->pointer, 4);
-
-	if ((padapter->bDriverStopped) || (pdata == NULL)) {
+	if (uintRet || padapter->bDriverStopped || pdata == NULL) {
 		ret = -EINVAL;
 		goto exit;
 	}
@@ -3916,10 +3910,9 @@ inline static void macstr2num(u8 *dst, u
 }
 
 static int rtw_p2p_get_wps_configmethod(struct net_device *dev,
-										struct iw_request_info *info,
-										union iwreq_data *wrqu, char *extra, char *subcmd)
+					struct iw_request_info *info,
+					union iwreq_data *wrqu, char *extra, char *subcmd)
 {
-
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	u8 peerMAC[ETH_ALEN] = { 0x00 };
@@ -3928,7 +3921,8 @@ static int rtw_p2p_get_wps_configmethod(
 	struct __queue *queue = &(pmlmepriv->scanned_queue);
 	struct wlan_network *pnetwork = NULL;
 	u8 blnMatch = 0;
-	u16	attr_content = 0;
+	__be16	attr_content = 0;
+	u16 c_attr_content;
 	uint attr_contentlen = 0;
 	u8	attr_content_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
 
@@ -3961,14 +3955,12 @@ static int rtw_p2p_get_wps_configmethod(
 			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
 			{
 				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_CONF_METHOD, (u8 *)&attr_content, &attr_contentlen);
-				if (attr_contentlen)
-				{
-					attr_content = be16_to_cpu(attr_content);
-					sprintf(attr_content_str, "\n\nM =%.4d", attr_content);
+				if (attr_contentlen) {
+					c_attr_content = be16_to_cpu(attr_content);
+					sprintf(attr_content_str, "\n\nM =%.4d", c_attr_content);
 					blnMatch = 1;
 				}
 			}
-
 			break;
 		}
 
@@ -4138,8 +4130,8 @@ static int rtw_p2p_get_go_device_address
 }
 
 static int rtw_p2p_get_device_type(struct net_device *dev,
-								   struct iw_request_info *info,
-								   union iwreq_data *wrqu, char *extra, char *subcmd)
+				   struct iw_request_info *info,
+				   union iwreq_data *wrqu, char *extra, char *subcmd)
 {
 
 	int ret = 0;
@@ -4185,11 +4177,10 @@ static int rtw_p2p_get_device_type(struc
 				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_PRIMARY_DEV_TYPE, dev_type, &dev_type_len);
 				if (dev_type_len)
 				{
-					u16	type = 0;
+					__be16 type;
 
 					memcpy(&type, dev_type, 2);
-					type = be16_to_cpu(type);
-					sprintf(dev_type_str, "\n\nN =%.2d", type);
+					sprintf(dev_type_str, "\n\nN =%.2d", be16_to_cpu(type));
 					blnMatch = 1;
 				}
 			}
@@ -5673,7 +5664,8 @@ static int rtw_dbg_port(struct net_devic
 	int ret = 0;
 	u8 major_cmd, minor_cmd;
 	u16 arg;
-	u32 extra_arg, *pdata, val32;
+	s32 extra_arg;
+	u32 *pdata, val32;
 	struct sta_info *psta;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -871,17 +871,13 @@ u16 rtw_recv_select_queue(struct sk_buff
 	memcpy(&eth_type, pdata+(ETH_ALEN<<1), 2);
 
 	switch (eth_type) {
-		case htons(ETH_P_IP):
-
-			piphdr = (struct iphdr *)(pdata+ETH_HLEN);
-
-			dscp = piphdr->tos & 0xfc;
-
-			priority = dscp >> 5;
-
-			break;
-		default:
-			priority = 0;
+	case __constant_htons(ETH_P_IP):
+		piphdr = (struct iphdr *)(pdata+ETH_HLEN);
+		dscp = piphdr->tos & 0xfc;
+		priority = dscp >> 5;
+		break;
+	default:
+		priority = 0;
 	}
 
 	return rtw_1d_to_queue[priority];
@@ -1930,7 +1926,6 @@ static const struct net_device_ops rtw_n
 struct rtw_adapter *rtw_drv_if2_init(struct rtw_adapter *primary_padapter, char *name,
 	void (*set_intf_ops)(struct _io_ops *pops))
 {
-	int res = _FAIL;
 	struct net_device *pnetdev;
 	struct rtw_adapter *padapter = NULL;
 	struct dvobj_priv *pdvobjpriv;
@@ -2064,11 +2059,8 @@ struct rtw_adapter *rtw_drv_if2_init(str
 		goto error_rtw_drv_if2_init;
 	}
 
-	res = _SUCCESS;
-
 	return padapter;
 
-
 error_rtw_drv_if2_init:
 
 	if (padapter)
--- a/drivers/staging/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8192du/os_dep/osdep_service.c
@@ -764,13 +764,9 @@ u64 rtw_division64(u64 x, u64 y)
 
 void rtw_buf_free(u8 **buf, u32 *buf_len)
 {
-	u32 ori_len;
-
 	if (!buf || !buf_len)
 		return;
 
-	ori_len = *buf_len;
-
 	if (*buf) {
 		*buf_len = 0;
 		kfree(*buf);
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -226,10 +226,6 @@ int rtw_recv_indicatepkt(struct rtw_adap
 	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
 #endif
 
-#ifdef CONFIG_BR_EXT
-	void *br_port = NULL;
-#endif
-
 _func_enter_;
 
 	precvpriv = &(padapter->recvpriv);
@@ -299,19 +295,6 @@ _func_enter_;
 		}
 	}
 
-
-#ifdef CONFIG_BR_EXT
-
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-	br_port = padapter->pnetdev->br_port;
-#else   /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
-	rcu_read_lock();
-	br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
-	rcu_read_unlock();
-#endif  /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
-
-#endif	/*  CONFIG_BR_EXT */
-
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
 	if ((pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1)) {
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -293,7 +293,6 @@ static struct dvobj_priv *usb_dvobj_init
 	int	status = _FAIL;
 	struct dvobj_priv *pdvobjpriv = NULL;
 	struct usb_device				*pusbd;
-	struct usb_device_descriptor	*pdev_desc;
 	struct usb_host_config			*phost_conf;
 	struct usb_config_descriptor		*pconf_desc;
 	struct usb_host_interface		*phost_iface;
@@ -320,8 +319,6 @@ _func_enter_;
 	pdvobjpriv->RtNumInPipes = 0;
 	pdvobjpriv->RtNumOutPipes = 0;
 
-
-	pdev_desc = &pusbd->descriptor;
 	phost_conf = pusbd->actconfig;
 	pconf_desc = &phost_conf->desc;
 
--- a/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
@@ -252,7 +252,7 @@ static u32 usb_bulkout_zero(struct intf_
 	}
 
 
-	return _SUCCESS;
+	return ret;
 }
 
 void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)

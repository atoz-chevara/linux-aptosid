From 6ba99220a5ab69b75e6b277ae6e56e4a6048853d Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Mon, 17 Feb 2014 16:47:50 -0600
Subject: [PATCH 201/390] rtl8192du: Remove instances of 2 or more blank lines

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_br_ext.c           | 18 ---------
 core/rtw_cmd.c              |  2 -
 core/rtw_debug.c            | 11 ------
 core/rtw_efuse.c            |  2 -
 core/rtw_ieee80211.c        | 18 ---------
 core/rtw_io.c               | 21 -----------
 core/rtw_ioctl_set.c        | 51 --------------------------
 core/rtw_mlme_ext.c         |  4 --
 core/rtw_p2p.c              | 67 ----------------------------------
 core/rtw_pwrctrl.c          | 50 -------------------------
 core/rtw_recv.c             | 70 -----------------------------------
 core/rtw_security.c         | 18 ---------
 core/rtw_tdls.c             |  4 --
 core/rtw_wlan_util.c        |  8 ----
 hal/hal_com.c               |  3 --
 hal/hal_intf.c              |  3 --
 hal/rtl8192d_cmd.c          | 43 ----------------------
 hal/rtl8192d_dm.c           | 19 ----------
 hal/rtl8192d_hal_init.c     |  9 -----
 hal/rtl8192d_phycfg.c       | 86 -------------------------------------------
 hal/rtl8192d_rf6052.c       | 10 -----
 hal/rtl8192d_rxdesc.c       | 12 ------
 hal/rtl8192du_led.c         | 23 +-----------
 hal/rtl8192du_xmit.c        | 17 ---------
 hal/usb_halinit.c           | 89 ---------------------------------------------
 os_dep/ioctl_cfg80211.c     | 57 -----------------------------
 os_dep/ioctl_linux.c        | 75 --------------------------------------
 os_dep/mlme_linux.c         | 27 +-------------
 os_dep/os_intfs.c           | 53 ---------------------------
 os_dep/osdep_service.c      |  5 ---
 os_dep/recv_linux.c         |  9 -----
 os_dep/rtw_android.c        |  2 -
 os_dep/usb_intf.c           | 27 --------------
 os_dep/usb_ops_linux.c      | 20 ----------
 os_dep/xmit_linux.c         | 16 --------
 36 files changed, 2 insertions(+), 948 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_br_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_br_ext.c
@@ -69,7 +69,6 @@
   PPPoE |type|   SID   |           AC MAC            |
 -----------------------------------------------------------------*/
 
-
 /* Find a tag in pppoe frame and return the pointer */
 static inline unsigned char *__nat25_find_pppoe_tag(struct pppoe_hdr *ph, unsigned short type)
 {
@@ -138,7 +137,6 @@ static inline unsigned long __nat25_time
 	return timeout;
 }
 
-
 static inline int  __nat25_has_expired(struct rtw_adapter *priv,
 				struct nat25_network_db_entry *fdb)
 {
@@ -148,7 +146,6 @@ static inline int  __nat25_has_expired(s
 	return 0;
 }
 
-
 static inline void __nat25_generate_ipv4_network_addr(unsigned char *networkAddr,
 				__be32 *ipaddr)
 {
@@ -158,7 +155,6 @@ static inline void __nat25_generate_ipv4
 	memcpy(networkAddr+7, (unsigned char *)ipaddr, 4);
 }
 
-
 static inline void __nat25_generate_ipx_network_addr_with_node(unsigned char *networkAddr,
 				__be32 *ipxNetAddr, unsigned char *ipxNodeAddr)
 {
@@ -169,7 +165,6 @@ static inline void __nat25_generate_ipx_
 	memcpy(networkAddr+5, ipxNodeAddr, 6);
 }
 
-
 static inline void __nat25_generate_ipx_network_addr_with_socket(unsigned char *networkAddr,
 				__be32 *ipxNetAddr, unsigned short *ipxSocketAddr)
 {
@@ -210,7 +205,6 @@ static  void __nat25_generate_ipv6_netwo
 	memcpy(networkAddr+1, (unsigned char *)ipaddr, 16);
 }
 
-
 static unsigned char *scan_tlv(unsigned char *data, int len, unsigned char tag, unsigned char len8b)
 {
 	while (len > 0) {
@@ -296,7 +290,6 @@ static int update_nd_link_layer_addr(uns
 	return 0;
 }
 
-
 static void convert_ipv6_mac_to_mc(struct sk_buff *skb)
 {
 	struct ipv6hdr *iph = (struct ipv6hdr *)(skb->data + ETH_HLEN);
@@ -312,7 +305,6 @@ static void convert_ipv6_mac_to_mc(struc
 }
 #endif /* CL_IPV6_PASS */
 
-
 static inline int __nat25_network_hash(unsigned char *networkAddr)
 {
 	if (networkAddr[0] == NAT25_IPV4) {
@@ -364,7 +356,6 @@ static inline int __nat25_network_hash(u
 	}
 }
 
-
 static inline void __network_hash_link(struct rtw_adapter *priv,
 				struct nat25_network_db_entry *ent, int hash)
 {
@@ -460,7 +451,6 @@ static int __nat25_db_network_lookup_and
 	return 0;
 }
 
-
 static void __nat25_db_network_insert(struct rtw_adapter *priv,
 				unsigned char *macaddr, unsigned char *networkAddr)
 {
@@ -497,7 +487,6 @@ static void __nat25_db_network_insert(st
 	spin_unlock_bh(&priv->br_ext_lock);
 }
 
-
 static void __nat25_db_print(struct rtw_adapter *priv)
 {
 	spin_lock_bh(&priv->br_ext_lock);
@@ -554,9 +543,6 @@ static void __nat25_db_print(struct rtw_
 	spin_unlock_bh(&priv->br_ext_lock);
 }
 
-
-
-
 /*
  *	NAT2.5 interface
  */
@@ -588,7 +574,6 @@ void nat25_db_cleanup(struct rtw_adapter
 	spin_unlock_bh(&priv->br_ext_lock);
 }
 
-
 void nat25_db_expire(struct rtw_adapter *priv)
 {
 	int i;
@@ -670,7 +655,6 @@ void nat25_db_expire(struct rtw_adapter
 	spin_unlock_bh(&priv->br_ext_lock);
 }
 
-
 #ifdef SUPPORT_TX_MCAST2UNI
 static int checkIPMcAndReplace(struct rtw_adapter *priv, struct sk_buff *skb, unsigned int *dst_ip)
 {
@@ -1266,7 +1250,6 @@ int nat25_db_handle(struct rtw_adapter *
 	return -1;
 }
 
-
 int nat25_handle_frame(struct rtw_adapter *priv, struct sk_buff *skb)
 {
 #ifdef BR_EXT_DEBUG
@@ -1400,7 +1383,6 @@ void dhcp_flag_bcast(struct rtw_adapter
 	}
 }
 
-
 void *scdb_findentry(struct rtw_adapter *priv, unsigned char *macaddr,
 				unsigned char *ipaddr)
 {
--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -855,7 +855,6 @@ exit:
 void rtw_getbbrfreg_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
 {
 
-
 	kfree(pcmd->parmbuf);
 	kfree(pcmd);
 
@@ -864,7 +863,6 @@ void rtw_getbbrfreg_cmdrsp_callback(stru
 void rtw_readtssi_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
 {
 
-
 	kfree(pcmd->parmbuf);
 	kfree(pcmd);
 
--- a/drivers/staging/rtl8192du/core/rtw_debug.c
+++ b/drivers/staging/rtl8192du/core/rtw_debug.c
@@ -15,7 +15,6 @@
  ******************************************************************************/
 #define _RTW_DEBUG_C_
 
-
 #include <rtw_debug.h>
 
 u32 GlobalDebugLevel = _drv_err_;
@@ -395,8 +394,6 @@ int proc_get_trx_info(char *page, char *
 	return len;
 }
 
-
-
 int proc_get_mac_reg_dump1(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -555,7 +552,6 @@ int proc_get_rf_reg_dump1(char *page, ch
 	return len;
 }
 
-
 int proc_get_rf_reg_dump2(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -581,7 +577,6 @@ int proc_get_rf_reg_dump2(char *page, ch
 	return len;
 }
 
-
 int proc_get_rf_reg_dump3(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -608,7 +603,6 @@ int proc_get_rf_reg_dump3(char *page, ch
 	return len;
 }
 
-
 int proc_get_rf_reg_dump4(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -634,8 +628,6 @@ int proc_get_rf_reg_dump4(char *page, ch
 	return len;
 }
 
-
-
 int proc_get_rx_signal(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -740,7 +732,6 @@ int proc_set_ht_enable(struct file *file
 	return count;
 }
 
-
 int proc_get_cbw40_enable(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -968,7 +959,6 @@ int proc_set_rssi_disp(struct file *file
 	return count;
 }
 
-
 #ifdef CONFIG_AP_MODE
 
 int proc_get_all_sta_info(char *page, char **start,
@@ -984,7 +974,6 @@ int proc_get_all_sta_info(char *page, ch
 	struct recv_reorder_ctrl *preorder_ctrl;
 	int len = 0;
 
-
 	len += snprintf(page + len, count - len, "sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
 
 	spin_lock_bh(&pstapriv->sta_hash_lock);
--- a/drivers/staging/rtl8192du/core/rtw_efuse.c
+++ b/drivers/staging/rtl8192du/core/rtw_efuse.c
@@ -564,7 +564,6 @@ exit:
 	return ret;
 }
 
-
 /*-----------------------------------------------------------------------------
  * Function:	Efuse_ReadAllMap
  *
@@ -636,7 +635,6 @@ static void efuse_ShadowRead4Byte(struct
 	*value |= pEEPROM->efuse_eeprom_data[Offset+3]<<24;
 }	/*  efuse_ShadowRead4Byte */
 
-
 /*-----------------------------------------------------------------------------
  * Function:	efuse_ShadowWrite1Byte
  *			efuse_ShadowWrite2Byte
--- a/drivers/staging/rtl8192du/core/rtw_ieee80211.c
+++ b/drivers/staging/rtl8192du/core/rtw_ieee80211.c
@@ -65,7 +65,6 @@ static u8	WIFI_OFDMRATES[] = {
 	IEEE80211_OFDM_RATE_54MB
 };
 
-
 int rtw_get_bit_value_from_ieee_value(u8 val)
 {
 	unsigned char dot11_rate_table[] = {
@@ -99,7 +98,6 @@ uint	rtw_is_cckratesonly_included(u8 *ra
 {
 	u32 i = 0;
 
-
 	while (rate[i] != 0) {
 		if ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
 		    (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22))
@@ -147,7 +145,6 @@ u8 *rtw_set_ie(u8 *pbuf, int index, uint
 
 	*frlen = *frlen + (len + 2);
 
-
 	return pbuf + len + 2;
 }
 
@@ -325,7 +322,6 @@ exit:
 void rtw_set_supported_rate(u8 *SupportedRates, uint mode)
 {
 
-
 	memset(SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
 
 	switch (mode) {
@@ -373,8 +369,6 @@ int rtw_generate_ie(struct registry_priv
 	struct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;
 	u8 *ie = pdev_network->IEs;
 
-
-
 	/* timestamp will be inserted by hardware */
 	sz += 8;
 	ie += sz;
@@ -423,7 +417,6 @@ int rtw_generate_ie(struct registry_priv
 	/* DS parameter set */
 	ie = rtw_set_ie(ie, _DSSET_IE_, 1, (u8 *)&(pdev_network->Configuration.DSConfig), &sz);
 
-
 	/* IBSS Parameter Set */
 
 	ie = rtw_set_ie(ie, _IBSS_PARA_IE_, 2, (u8 *)&(pdev_network->Configuration.ATIMWindow), &sz);
@@ -518,7 +511,6 @@ int rtw_get_wpa2_cipher_suite(u8 *s)
 	return 0;
 }
 
-
 int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher)
 {
 	int i, ret = _SUCCESS;
@@ -530,7 +522,6 @@ int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa
 		return _FAIL;
 	}
 
-
 	if ((*wpa_ie != _WPA_IE_ID_) || (*(wpa_ie+1) != (u8)(wpa_ie_len - 2)) ||
 	    (_rtw_memcmp(wpa_ie+2, RTW_WPA_OUI_TYPE, WPA_SELECTOR_LEN) != true))
 		return _FAIL;
@@ -540,7 +531,6 @@ int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa
 	pos += 8;
 	left = wpa_ie_len - 8;
 
-
 	/* group_cipher */
 	if (left >= WPA_SELECTOR_LEN) {
 		*group_cipher = rtw_get_wpa_cipher_suite(pos);
@@ -554,7 +544,6 @@ int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa
 		return _FAIL;
 	}
 
-
 	/* pairwise_cipher */
 	if (left >= 2) {
 		/* count = le16_to_cpu(*(u16 *)pos); */
@@ -581,7 +570,6 @@ int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa
 		return _FAIL;
 	}
 
-
 	return ret;
 }
 
@@ -596,7 +584,6 @@ int rtw_parse_wpa2_ie(u8 *rsn_ie, int rs
 		return _FAIL;
 	}
 
-
 	if ((*rsn_ie != _WPA2_IE_ID_) ||
 	    (*(rsn_ie+1) != (u8)(rsn_ie_len - 2)))
 		return _FAIL;
@@ -642,7 +629,6 @@ int rtw_parse_wpa2_ie(u8 *rsn_ie, int rs
 		return _FAIL;
 	}
 
-
 	return ret;
 }
 
@@ -652,8 +638,6 @@ int rtw_get_sec_ie(u8 *in_ie, uint in_le
 	u8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};
 	uint	cnt;
 
-
-
 	/* Search required WPA or WPA2 IE and copy to sec_ie[] */
 
 	cnt = (_TIMESTAMP_ + _BEACON_ITERVAL_ + _CAPABILITY_);
@@ -1393,7 +1377,6 @@ int rtw_get_wfd_ie(u8 *in_ie, int in_len
 	uint cnt = 0;
 	u8 eid, wfd_oui[4] = {0x50, 0x6F, 0x9A, 0x0A};
 
-
 	match = false;
 
 	if (in_len < 0)
@@ -1437,7 +1420,6 @@ int rtw_get_wfd_attr_content(u8 *wfd_ie,
 	uint cnt = 0;
 	u8 attr_id, wfd_oui[4] = {0x50, 0x6F, 0x9A, 0x0A};
 
-
 	match = false;
 
 	if ((wfd_ie[0] != _VENDOR_SPECIFIC_IE_) ||
--- a/drivers/staging/rtl8192du/core/rtw_io.c
+++ b/drivers/staging/rtl8192du/core/rtw_io.c
@@ -23,7 +23,6 @@ b. provides the protocol engine
 
 c. provides the software interface between caller and the hardware interface
 
-
 Compiler Flag Option:
 
 1. default USB configuration
@@ -96,7 +95,6 @@ int _rtw_write8(struct rtw_adapter *adap
 
 	ret = _write8(pintfhdl, addr, val);
 
-
 	return RTW_STATUS_CODE(ret);
 }
 
@@ -111,7 +109,6 @@ int _rtw_write16(struct rtw_adapter *ada
 
 	ret = _write16(pintfhdl, addr, val);
 
-
 	return RTW_STATUS_CODE(ret);
 }
 int _rtw_write32(struct rtw_adapter *adapter, u32 addr, u32 val)
@@ -125,7 +122,6 @@ int _rtw_write32(struct rtw_adapter *ada
 
 	ret = _write32(pintfhdl, addr, val);
 
-
 	return RTW_STATUS_CODE(ret);
 }
 
@@ -141,7 +137,6 @@ int _rtw_writeN(struct rtw_adapter *adap
 
 	ret = _writeN(pintfhdl, addr, length, pdata);
 
-
 	return RTW_STATUS_CODE(ret);
 }
 int _rtw_write8_async(struct rtw_adapter *adapter, u32 addr, u8 val)
@@ -155,7 +150,6 @@ int _rtw_write8_async(struct rtw_adapter
 
 	ret = _write8_async(pintfhdl, addr, val);
 
-
 	return RTW_STATUS_CODE(ret);
 }
 int _rtw_write16_async(struct rtw_adapter *adapter, u32 addr, u16 val)
@@ -169,7 +163,6 @@ int _rtw_write16_async(struct rtw_adapte
 
 	ret = _write16_async(pintfhdl, addr, val);
 
-
 	return RTW_STATUS_CODE(ret);
 }
 int _rtw_write32_async(struct rtw_adapter *adapter, u32 addr, u32 val)
@@ -183,7 +176,6 @@ int _rtw_write32_async(struct rtw_adapte
 
 	ret = _write32_async(pintfhdl, addr, val);
 
-
 	return RTW_STATUS_CODE(ret);
 }
 
@@ -194,8 +186,6 @@ void _rtw_read_mem(struct rtw_adapter *a
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 
-
-
 	if ((adapter->bDriverStopped == true) ||
 	    (adapter->bSurpriseRemoved == true)) {
 		RT_TRACE(_module_rtl871x_io_c_, _drv_info_,
@@ -208,7 +198,6 @@ void _rtw_read_mem(struct rtw_adapter *a
 
 	_read_mem(pintfhdl, addr, cnt, pmem);
 
-
 }
 
 void _rtw_write_mem(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
@@ -218,13 +207,10 @@ void _rtw_write_mem(struct rtw_adapter *
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl *pintfhdl = &(pio_priv->intf);
 
-
-
 	_write_mem = pintfhdl->io_ops._write_mem;
 
 	_write_mem(pintfhdl, addr, cnt, pmem);
 
-
 }
 
 void _rtw_read_port(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
@@ -234,8 +220,6 @@ void _rtw_read_port(struct rtw_adapter *
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl *pintfhdl = &(pio_priv->intf);
 
-
-
 	if ((adapter->bDriverStopped == true) ||
 	    (adapter->bSurpriseRemoved == true)) {
 		RT_TRACE(_module_rtl871x_io_c_, _drv_info_,
@@ -248,7 +232,6 @@ void _rtw_read_port(struct rtw_adapter *
 
 	_read_port(pintfhdl, addr, cnt, pmem);
 
-
 }
 
 void _rtw_read_port_cancel(struct rtw_adapter *adapter)
@@ -271,14 +254,10 @@ u32 _rtw_write_port(struct rtw_adapter *
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	u32 ret = _SUCCESS;
 
-
-
 	_write_port = pintfhdl->io_ops._write_port;
 
 	ret = _write_port(pintfhdl, addr, cnt, pmem);
 
-
-
 	return ret;
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -15,7 +15,6 @@
  ******************************************************************************/
 #define _RTW_IOCTL_SET_C_
 
-
 #include <drv_conf.h>
 #include <osdep_service.h>
 #include <drv_types.h>
@@ -37,8 +36,6 @@ u8 rtw_validate_ssid(struct ndis_802_11_
 	u8	 i;
 	u8	ret = true;
 
-
-
 	if (ssid->SsidLength > 32) {
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid length >32\n"));
 		ret = false;
@@ -56,8 +53,6 @@ u8 rtw_validate_ssid(struct ndis_802_11_
 
 exit:
 
-
-
 	return ret;
 }
 
@@ -69,8 +64,6 @@ u8 rtw_do_join(struct rtw_adapter *padap
 	struct __queue *queue = &(pmlmepriv->scanned_queue);
 	u8 ret = _SUCCESS;
 
-
-
 	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 	phead = get_list_head(queue);
 	plist = phead->next;
@@ -163,8 +156,6 @@ u8 rtw_do_join(struct rtw_adapter *padap
 
 exit:
 
-
-
 	return ret;
 }
 
@@ -175,8 +166,6 @@ u8 rtw_set_802_11_bssid(struct rtw_adapt
 
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-
-
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
 		 ("+rtw_set_802_11_bssid: bssid =%pM\n", bssid));
 
@@ -249,8 +238,6 @@ exit:
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 		 ("rtw_set_802_11_bssid: status=%d\n", status));
 
-
-
 	return status;
 }
 
@@ -262,8 +249,6 @@ u8 rtw_set_802_11_ssid(struct rtw_adapte
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct wlan_network *pnetwork = &pmlmepriv->cur_network;
 
-
-
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
 		 ("+rtw_set_802_11_ssid: ssid =[%s] fw_state= 0x%08x\n",
 		  ssid->Ssid, get_fwstate(pmlmepriv)));
@@ -371,8 +356,6 @@ exit:
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 		 ("-rtw_set_802_11_ssid: status=%d\n", status));
 
-
-
 	return status;
 }
 
@@ -383,8 +366,6 @@ u8 rtw_set_802_11_infrastructure_mode(st
 	struct	wlan_network	*cur_network = &pmlmepriv->cur_network;
 	enum NDIS_802_11_NETWORK_INFRASTRUCTURE *pold_state = &(cur_network->network.InfrastructureMode);
 
-
-
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
 		 ("+rtw_set_802_11_infrastructure_mode: old=%d new=%d fw_state= 0x%08x\n",
 		  *pold_state, networktype, get_fwstate(pmlmepriv)));
@@ -436,18 +417,13 @@ u8 rtw_set_802_11_infrastructure_mode(st
 		}
 	}
 
-
-
 	return true;
 }
 
-
 u8 rtw_set_802_11_disassociate(struct rtw_adapter *padapter)
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-
-
 	spin_lock_bh(&pmlmepriv->lock);
 
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
@@ -460,8 +436,6 @@ u8 rtw_set_802_11_disassociate(struct rt
 
 	spin_unlock_bh(&pmlmepriv->lock);
 
-
-
 	return true;
 }
 
@@ -470,8 +444,6 @@ u8 rtw_set_802_11_bssid_list_scan(struct
 	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	u8	res = true;
 
-
-
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("+rtw_set_802_11_bssid_list_scan(), fw_state=%x\n", get_fwstate(pmlmepriv)));
 
 	if (padapter == NULL) {
@@ -509,8 +481,6 @@ u8 rtw_set_802_11_bssid_list_scan(struct
 	}
 exit:
 
-
-
 	return res;
 }
 
@@ -520,8 +490,6 @@ u8 rtw_set_802_11_authentication_mode(st
 	int res;
 	u8 ret;
 
-
-
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_802_11_auth.mode(): mode=%x\n", authmode));
 
 	psecuritypriv->ndisauthtype = authmode;
@@ -540,8 +508,6 @@ u8 rtw_set_802_11_authentication_mode(st
 	else
 		ret = false;
 
-
-
 	return ret;
 }
 
@@ -551,8 +517,6 @@ u8 rtw_set_802_11_add_wep(struct rtw_ada
 	struct security_priv *psecuritypriv = &(padapter->securitypriv);
 	u8		ret = _SUCCESS;
 
-
-
 	keyid = wep->KeyIndex & 0x3fffffff;
 
 	if (keyid >= 4) {
@@ -598,8 +562,6 @@ u8 rtw_set_802_11_add_wep(struct rtw_ada
 		ret = false;
 exit:
 
-
-
 	return ret;
 }
 
@@ -607,8 +569,6 @@ u8 rtw_set_802_11_remove_wep(struct rtw_
 {
 	u8 ret = _SUCCESS;
 
-
-
 	if (keyindex >= 0x80000000 || padapter == NULL) {
 		ret = false;
 		goto exit;
@@ -631,8 +591,6 @@ u8 rtw_set_802_11_remove_wep(struct rtw_
 
 exit:
 
-
-
 	return ret;
 }
 
@@ -645,8 +603,6 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 	u8	bgrouptkey = false;/* can be remove later */
 	u8	ret = _SUCCESS;
 
-
-
 	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)) {
 		/*  It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination, */
 		/*  it must fail the request and return NDIS_STATUS_INVALID_DATA. */
@@ -743,7 +699,6 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 		/*  Group key - KeyIndex(BIT30== 0) */
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: +++++ Group key +++++\n"));
 
-
 		/*  when add wep key through add key and didn't assigned encryption type before */
 		if ((padapter->securitypriv.ndisauthtype <= 3) &&
 		    (padapter->securitypriv.dot118021XGrpPrivacy == 0)) {
@@ -981,8 +936,6 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 
 exit:
 
-
-
 	return ret;
 }
 
@@ -995,8 +948,6 @@ u8 rtw_set_802_11_remove_key(struct rtw_
 	u8	keyIndex = (u8)key->KeyIndex & 0x03;
 	u8	ret = _SUCCESS;
 
-
-
 	if ((key->KeyIndex & 0xbffffffc) > 0) {
 		ret = _FAIL;
 		goto exit;
@@ -1022,8 +973,6 @@ u8 rtw_set_802_11_remove_key(struct rtw_
 
 exit:
 
-
-
 	return ret;
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -11249,8 +11249,6 @@ u8 set_tx_beacon_cmd(struct rtw_adapter
 	u8 res = _SUCCESS;
 	int len_diff = 0;
 
-
-
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		res = _FAIL;
@@ -11280,8 +11278,6 @@ u8 set_tx_beacon_cmd(struct rtw_adapter
 
 exit:
 
-
-
 	return res;
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -87,7 +87,6 @@ static u32 go_add_group_info_attr(struct
 
 		plist = plist->next;
 
-
 		if (psta->is_p2p_device) {
 			tmplen = 0;
 
@@ -127,7 +126,6 @@ static u32 go_add_group_info_attr(struct
 				pcur += psta->dev_name_len;
 			}
 
-
 			tmplen = (u8)(pcur-pstart);
 
 			*pstart = (tmplen-1);
@@ -258,7 +256,6 @@ static void issue_p2p_devdisc_resp(struc
 	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
-
 	/* Build P2P IE */
 	/*	P2P OUI */
 	p2pielen = 0;
@@ -300,7 +297,6 @@ static void issue_p2p_provision_resp(str
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
 	if (pmgntframe == NULL)
 		return;
@@ -419,7 +415,6 @@ static void issue_p2p_presence_resp(stru
 	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
-
 	/* Add P2P IE header */
 	/*	P2P OUI */
 	p2pielen = 0;
@@ -439,11 +434,8 @@ static void issue_p2p_presence_resp(stru
 
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_NOA, 2, noa_attr_content);
 
-
-
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, p2pie, &(pattrib->pktlen));
 
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(padapter, pmgntframe);
@@ -463,7 +455,6 @@ u32 build_beacon_p2p_ie(struct wifidirec
 	p2pie[p2pielen++] = 0x9A;
 	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
 
-
 	/*	According to the P2P Specification, the beacon frame should contain 3 P2P attributes */
 	/*	1. P2P Capability */
 	/*	2. P2P Device ID */
@@ -486,11 +477,9 @@ u32 build_beacon_p2p_ie(struct wifidirec
 
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_CAPABILITY, 2, (u8 *)&le_tmp);
 
-
 	/*  P2P Device ID ATTR */
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_DEVICE_ID, ETH_ALEN, pwdinfo->device_addr);
 
-
 	/*  Notice of Absence ATTR */
 	/*	Type: */
 	/*	Length: */
@@ -498,10 +487,8 @@ u32 build_beacon_p2p_ie(struct wifidirec
 
 	/* go_add_noa_attr(pwdinfo); */
 
-
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *)p2pie, &len);
 
-
 	return len;
 }
 
@@ -527,7 +514,6 @@ u32 build_beacon_wfd_ie(struct wifidirec
 	/*	2. Associated BSSID */
 	/*	3. Coupled Sink Information */
 
-
 	/*	WFD Device Information ATTR */
 	/*	Type: */
 	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
@@ -633,7 +619,6 @@ u32 build_probe_req_wfd_ie(struct wifidi
 	/*	2. Associated BSSID */
 	/*	3. Coupled Sink Information */
 
-
 	/*	WFD Device Information ATTR */
 	/*	Type: */
 	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
@@ -739,7 +724,6 @@ u32 build_probe_resp_wfd_ie(struct wifid
 	/*	3. Coupled Sink Information */
 	/*	4. WFD Session Information */
 
-
 	/*	WFD Device Information ATTR */
 	/*	Type: */
 	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
@@ -911,7 +895,6 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 	/*	2. Associated BSSID */
 	/*	3. Coupled Sink Information */
 
-
 	/*	WFD Device Information ATTR */
 	/*	Type: */
 	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
@@ -1004,7 +987,6 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 	/*	2. Associated BSSID */
 	/*	3. Coupled Sink Information */
 
-
 	/*	WFD Device Information ATTR */
 	/*	Type: */
 	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
@@ -1097,7 +1079,6 @@ u32 build_nego_req_wfd_ie(struct wifidir
 	/*	2. Associated BSSID (Optional) */
 	/*	3. Local IP Adress (Optional) */
 
-
 	/*	WFD Device Information ATTR */
 	/*	Type: */
 	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
@@ -1190,7 +1171,6 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 	/*	2. Associated BSSID (Optional) */
 	/*	3. Local IP Adress (Optional) */
 
-
 	/*	WFD Device Information ATTR */
 	/*	Type: */
 	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
@@ -1257,7 +1237,6 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 	wfdie[wfdielen++] = 0;
 	wfdie[wfdielen++] = 0;
 
-
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
 
 	return len;
@@ -1284,7 +1263,6 @@ u32 build_nego_confirm_wfd_ie(struct wif
 	/*	2. Associated BSSID (Optional) */
 	/*	3. Local IP Adress (Optional) */
 
-
 	/*	WFD Device Information ATTR */
 	/*	Type: */
 	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
@@ -1375,7 +1353,6 @@ u32 build_invitation_req_wfd_ie(struct w
 	/*	2. Associated BSSID (Optional) */
 	/*	3. Local IP Adress (Optional) */
 
-
 	/*	WFD Device Information ATTR */
 	/*	Type: */
 	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
@@ -1479,7 +1456,6 @@ u32 build_invitation_resp_wfd_ie(struct
 	/*	2. Associated BSSID (Optional) */
 	/*	3. Local IP Adress (Optional) */
 
-
 	/*	WFD Device Information ATTR */
 	/*	Type: */
 	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
@@ -1582,7 +1558,6 @@ u32 build_provdisc_req_wfd_ie(struct wif
 	/*	2. Associated BSSID (Optional) */
 	/*	3. Local IP Adress (Optional) */
 
-
 	/*	WFD Device Information ATTR */
 	/*	Type: */
 	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
@@ -1673,7 +1648,6 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 	/*	2. Associated BSSID (Optional) */
 	/*	3. Local IP Adress (Optional) */
 
-
 	/*	WFD Device Information ATTR */
 	/*	Type: */
 	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
@@ -1812,7 +1786,6 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	RTW_PUT_LE16(p2pie + p2pielen, 0xFFFF);
 	p2pielen += 2;
 
-
 	/*  Notice of Absence ATTR */
 	/*	Type: */
 	/*	Length: */
@@ -1893,10 +1866,8 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 		p2pielen += go_add_group_info_attr(pwdinfo, p2pie + p2pielen);
 
-
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *)p2pie, &len);
 
-
 	return len;
 }
 
@@ -1936,7 +1907,6 @@ u32 build_prov_disc_request_p2p_ie(struc
 	else
 		p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
 
-
 	/*	Device Info ATTR */
 	/*	Type: */
 	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
@@ -2013,7 +1983,6 @@ u32 build_prov_disc_request_p2p_ie(struc
 	return len;
 }
 
-
 u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 status_code)
 {
 	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
@@ -2030,11 +1999,9 @@ u32 build_assoc_resp_p2p_ie(struct wifid
 	/*	1. Status */
 	/*	2. Extended Listen Timing (optional) */
 
-
 	/*	Status ATTR */
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status_code);
 
-
 	/*  Extended Listen Timing ATTR */
 	/*	Type: */
 	/*	Length: */
@@ -2160,7 +2127,6 @@ u32 process_assoc_req_p2p_ie(struct wifi
 
 		/* Check Extended Listen Timing ATTR */
 
-
 		/* Check P2P Device Info ATTR */
 		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, NULL, (uint *)&attr_contentlen)) {
 			DBG_8192D("[%s] Got P2P DEVICE INFO Attr!!\n", __func__);
@@ -2170,7 +2136,6 @@ u32 process_assoc_req_p2p_ie(struct wifi
 				u8 num_of_secdev_type;
 				u16 dev_name_len;
 
-
 				rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, pattr_content, (uint *)&attr_contentlen);
 
 				memcpy(psta->dev_addr,	pattr_content, ETH_ALEN);/* P2P Device Address */
@@ -2493,7 +2458,6 @@ u8 process_p2p_group_negotation_req(stru
 			}
 		}
 
-
 		attr_contentlen = 0;
 		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INTENTED_IF_ADDR, pwdinfo->p2p_peer_interface_addr, &attr_contentlen)) {
 			if (attr_contentlen != ETH_ALEN)
@@ -2877,8 +2841,6 @@ static void find_phase_handler(struct rt
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct ndis_802_11_ssid	ssid;
 
-
-
 	memset((unsigned char *)&ssid, 0, sizeof(struct ndis_802_11_ssid));
 	memcpy(ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN);
 	ssid.SsidLength = P2P_WILDCARD_SSID_LEN;
@@ -2889,8 +2851,6 @@ static void find_phase_handler(struct rt
 	rtw_sitesurvey_cmd(padapter, &ssid, 1, NULL, 0);
 	spin_unlock_bh(&pmlmepriv->lock);
 
-
-
 }
 
 void p2p_concurrent_handler(struct rtw_adapter *padapter);
@@ -2900,8 +2860,6 @@ static void restore_p2p_state_handler(st
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 
-
-
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) ||
 	    rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
 		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
@@ -2939,13 +2897,11 @@ static void pre_tx_invitereq_handler(str
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	u8 val8 = 1;
 
-
 	set_channel_bwmode(padapter, pwdinfo->invitereq_info.peer_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 	issue_probereq_p2p(padapter, NULL);
 	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 
-
 }
 
 static void pre_tx_provdisc_handler(struct rtw_adapter *padapter)
@@ -2953,13 +2909,11 @@ static void pre_tx_provdisc_handler(stru
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	u8 val8 = 1;
 
-
 	set_channel_bwmode(padapter, pwdinfo->tx_prov_disc_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 	issue_probereq_p2p(padapter, NULL);
 	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 
-
 }
 
 static void pre_tx_negoreq_handler(struct rtw_adapter *padapter)
@@ -2967,13 +2921,11 @@ static void pre_tx_negoreq_handler(struc
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	u8 val8 = 1;
 
-
 	set_channel_bwmode(padapter, pwdinfo->nego_req_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 	issue_probereq_p2p(padapter, NULL);
 	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 
-
 }
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -2986,7 +2938,6 @@ void p2p_concurrent_handler(struct rtw_a
 	/* struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv; */
 	u8 val8;
 
-
 	if (check_buddy_fwstate(padapter, _FW_LINKED)) {
 		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -3067,7 +3018,6 @@ void p2p_concurrent_handler(struct rtw_a
 		set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	}
 
-
 }
 #endif
 
@@ -3079,7 +3029,6 @@ static void ro_ch_handler(struct rtw_ada
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
-
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter, _FW_LINKED)) {
 		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
@@ -3115,7 +3064,6 @@ static void ro_ch_handler(struct rtw_ada
 		&pcfg80211_wdinfo->remain_on_ch_channel,
 		pcfg80211_wdinfo->remain_on_ch_type, GFP_KERNEL);
 
-
 }
 
 static void ro_ch_timer_process (void *FunctionContext)
@@ -3497,8 +3445,6 @@ void p2p_protocol_wk_hdl(struct rtw_adap
 {
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-
-
 	switch (intCmdType) {
 	case P2P_FIND_PHASE_WK:
 		find_phase_handler(padapter);
@@ -3550,7 +3496,6 @@ void p2p_protocol_wk_hdl(struct rtw_adap
 #endif /* CONFIG_IOCTL_CFG80211 */
 	}
 
-
 }
 
 #ifdef CONFIG_P2P_PS
@@ -3567,8 +3512,6 @@ void process_p2p_ps_ie(struct rtw_adapte
 	u8 find_p2p = false, find_p2p_ps = false;
 	u8 noa_offset, noa_num, noa_index;
 
-
-
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 
@@ -3645,7 +3588,6 @@ void process_p2p_ps_ie(struct rtw_adapte
 			p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
 	}
 
-
 }
 
 void p2p_ps_wk_hdl(struct rtw_adapter *padapter, u8 p2p_ps_state)
@@ -3653,8 +3595,6 @@ void p2p_ps_wk_hdl(struct rtw_adapter *p
 	struct pwrctrl_priv		*pwrpriv = &padapter->pwrctrlpriv;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-
-
 	switch (p2p_ps_state) {
 	case P2P_PS_DISABLE:
 		pwdinfo->p2p_ps_state = p2p_ps_state;
@@ -3699,7 +3639,6 @@ void p2p_ps_wk_hdl(struct rtw_adapter *p
 		break;
 	}
 
-
 }
 
 u8 p2p_ps_wk_cmd(struct rtw_adapter *padapter, u8 p2p_ps_state, u8 enqueue)
@@ -3710,8 +3649,6 @@ u8 p2p_ps_wk_cmd(struct rtw_adapter *pad
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-
-
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
 #ifdef CONFIG_CONCURRENT_MODE
 		|| (padapter->iface_type != IFACE_PORT0)
@@ -3746,8 +3683,6 @@ u8 p2p_ps_wk_cmd(struct rtw_adapter *pad
 
 exit:
 
-
-
 	return res;
 }
 #endif /*  CONFIG_P2P_PS */
@@ -4131,7 +4066,6 @@ void dbg_rtw_p2p_set_role(struct wifidir
 }
 #endif /* CONFIG_DBG_P2P */
 
-
 int rtw_p2p_enable(struct rtw_adapter *padapter, enum P2P_ROLE role)
 {
 	int ret = _SUCCESS;
@@ -4161,7 +4095,6 @@ int rtw_p2p_enable(struct rtw_adapter *p
 			goto exit;
 		}
 
-
 		/*	Added by Albert 2011/03/22 */
 		/*	In the P2P mode, the driver should not support the b mode. */
 		/*	So, the Tx packet shouldn't use the CCK rate */
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -300,8 +300,6 @@ void rtw_set_rpwm(struct rtw_adapter *pa
 	u8 rpwm;
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 
-
-
 	pslv = PS_STATE(pslv);
 
 	if (pwrpriv->rpwm == pslv) {
@@ -337,7 +335,6 @@ void rtw_set_rpwm(struct rtw_adapter *pa
 	if (!(rpwm & PS_ACK))
 		pwrpriv->cpwm = pslv;
 
-
 }
 
 static u8 ps_rdy_check(struct rtw_adapter *padapter)
@@ -388,8 +385,6 @@ void rtw_set_ps_mode(struct rtw_adapter
 	struct sta_info *ptdls_sta;
 #endif /* CONFIG_TDLS */
 
-
-
 	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
 		 ("%s: PowerMode=%d Smart_PS=%d\n",
 		  __func__, ps_mode, smart_ps));
@@ -527,7 +522,6 @@ void rtw_set_ps_mode(struct rtw_adapter
 		/*  */
 	}
 
-
 }
 
 /*  */
@@ -540,8 +534,6 @@ void rtw_lps_enter(struct rtw_adapter *p
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct rtw_adapter *buddy = padapter->pbuddy_adapter;
 
-
-
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type != IFACE_PORT0)
 		return;		/* Skip power saving for concurrent mode port 1 */
@@ -594,7 +586,6 @@ void rtw_lps_enter(struct rtw_adapter *p
 		}
 	}
 
-
 }
 
 /*  */
@@ -609,8 +600,6 @@ void rtw_lps_leave(struct rtw_adapter *p
 	u32 start_time;
 	bool bAwake = false;
 
-
-
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type != IFACE_PORT0)
 		return;		/* Skip power saving for concurrent mode port 1 */
@@ -654,8 +643,6 @@ void LeaveAllPowerSaveMode(struct rtw_ad
 {
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 
-
-
 	/* DBG_8192D("%s.....\n",__func__); */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {	/* connect */
 #ifdef CONFIG_P2P_PS
@@ -682,7 +669,6 @@ void LeaveAllPowerSaveMode(struct rtw_ad
 		}
 	}
 
-
 }
 
 #ifdef CONFIG_LPS_LCLK
@@ -698,8 +684,6 @@ void cpwm_int_hdl(struct rtw_adapter *pa
 {
 	struct pwrctrl_priv *pwrpriv;
 
-
-
 	pwrpriv = &padapter->pwrctrlpriv;
 	pwrpriv->cpwm = PS_STATE(preportpwrstate->state);
 	pwrpriv->cpwm_tog = preportpwrstate->state & PS_TOGGLE;
@@ -716,7 +700,6 @@ exit:
 	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
 		 ("cpwm_int_hdl: cpwm=0x%02x\n", pwrpriv->cpwm));
 
-
 }
 
 static inline void register_task_alive(struct pwrctrl_priv *pwrctrl, u32 tag)
@@ -748,8 +731,6 @@ s32 rtw_register_tx_alive(struct rtw_ada
 	s32 res;
 	struct pwrctrl_priv *pwrctrl;
 
-
-
 	res = _SUCCESS;
 	pwrctrl = &padapter->pwrctrlpriv;
 
@@ -771,8 +752,6 @@ s32 rtw_register_tx_alive(struct rtw_ada
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-
-
 	return res;
 }
 
@@ -794,8 +773,6 @@ s32 rtw_register_cmd_alive(struct rtw_ad
 	s32 res;
 	struct pwrctrl_priv *pwrctrl;
 
-
-
 	res = _SUCCESS;
 	pwrctrl = &padapter->pwrctrlpriv;
 
@@ -817,8 +794,6 @@ s32 rtw_register_cmd_alive(struct rtw_ad
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-
-
 	return res;
 }
 
@@ -835,8 +810,6 @@ s32 rtw_register_rx_alive(struct rtw_ada
 {
 	struct pwrctrl_priv *pwrctrl;
 
-
-
 	pwrctrl = &padapter->pwrctrlpriv;
 
 	_enter_pwrlock(&pwrctrl->lock);
@@ -848,8 +821,6 @@ s32 rtw_register_rx_alive(struct rtw_ada
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-
-
 	return _SUCCESS;
 }
 
@@ -866,8 +837,6 @@ s32 rtw_register_evt_alive(struct rtw_ad
 {
 	struct pwrctrl_priv *pwrctrl;
 
-
-
 	pwrctrl = &padapter->pwrctrlpriv;
 
 	_enter_pwrlock(&pwrctrl->lock);
@@ -879,8 +848,6 @@ s32 rtw_register_evt_alive(struct rtw_ad
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-
-
 	return _SUCCESS;
 }
 
@@ -895,8 +862,6 @@ void rtw_unregister_tx_alive(struct rtw_
 {
 	struct pwrctrl_priv *pwrctrl;
 
-
-
 	pwrctrl = &padapter->pwrctrlpriv;
 
 	_enter_pwrlock(&pwrctrl->lock);
@@ -915,7 +880,6 @@ void rtw_unregister_tx_alive(struct rtw_
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-
 }
 
 /*
@@ -929,8 +893,6 @@ void rtw_unregister_cmd_alive(struct rtw
 {
 	struct pwrctrl_priv *pwrctrl;
 
-
-
 	pwrctrl = &padapter->pwrctrlpriv;
 
 	_enter_pwrlock(&pwrctrl->lock);
@@ -949,7 +911,6 @@ void rtw_unregister_cmd_alive(struct rtw
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-
 }
 
 /*
@@ -959,8 +920,6 @@ void rtw_unregister_rx_alive(struct rtw_
 {
 	struct pwrctrl_priv *pwrctrl;
 
-
-
 	pwrctrl = &padapter->pwrctrlpriv;
 
 	_enter_pwrlock(&pwrctrl->lock);
@@ -973,15 +932,12 @@ void rtw_unregister_rx_alive(struct rtw_
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-
 }
 
 void rtw_unregister_evt_alive(struct rtw_adapter *padapter)
 {
 	struct pwrctrl_priv *pwrctrl;
 
-
-
 	pwrctrl = &padapter->pwrctrlpriv;
 
 	unregister_task_alive(pwrctrl, EVT_ALIVE);
@@ -992,7 +948,6 @@ void rtw_unregister_evt_alive(struct rtw
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-
 }
 #endif /* CONFIG_LPS_LCLK */
 
@@ -1004,8 +959,6 @@ void rtw_init_pwrctrl_priv(struct rtw_ad
 {
 	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 
-
-
 	_init_pwrlock(&pwrctrlpriv->lock);
 	pwrctrlpriv->rf_pwrstate = rf_on;
 	pwrctrlpriv->ips_enter_cnts = 0;
@@ -1057,14 +1010,12 @@ void rtw_init_pwrctrl_priv(struct rtw_ad
 	rtw_register_early_suspend(pwrctrlpriv);
 #endif /* CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER */
 
-
 }
 
 void rtw_free_pwrctrl_priv(struct rtw_adapter *adapter)
 {
 	struct pwrctrl_priv *pwrctrlpriv = &adapter->pwrctrlpriv;
 
-
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
 	if (pwrctrlpriv->rtw_workqueue) {
 		flush_workqueue(pwrctrlpriv->rtw_workqueue);
@@ -1078,7 +1029,6 @@ void rtw_free_pwrctrl_priv(struct rtw_ad
 
 	_free_pwrlock(&pwrctrlpriv->lock);
 
-
 }
 
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -34,7 +34,6 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
 {
 
-
 	memset((u8 *)psta_recvpriv, 0, sizeof(struct sta_recv_priv));
 
 	_rtw_spinlock_init(&psta_recvpriv->lock);
@@ -44,7 +43,6 @@ void _rtw_init_sta_recv_priv(struct sta_
 
 	_rtw_init_queue(&psta_recvpriv->defrag_q);
 
-
 }
 
 int _rtw_init_recv_priv(struct recv_priv *precvpriv,
@@ -56,8 +54,6 @@ int _rtw_init_recv_priv(struct recv_priv
 
 	int res = _SUCCESS;
 
-
-
 	_rtw_spinlock_init(&precvpriv->lock);
 
 	_rtw_init_queue(&precvpriv->free_recv_queue);
@@ -114,8 +110,6 @@ int _rtw_init_recv_priv(struct recv_priv
 
 exit:
 
-
-
 	return res;
 }
 
@@ -141,8 +135,6 @@ void _rtw_free_recv_priv(struct recv_pri
 {
 	struct rtw_adapter *padapter = precvpriv->adapter;
 
-
-
 	rtw_free_uc_swdec_pending_queue(padapter);
 
 	rtw_mfree_recv_priv_lock(precvpriv);
@@ -154,7 +146,6 @@ void _rtw_free_recv_priv(struct recv_pri
 
 	rtw_hal_free_recv_priv(padapter);
 
-
 }
 
 struct recv_frame_hdr *_rtw_alloc_recvframe(struct __queue *pfree_recv_queue)
@@ -164,7 +155,6 @@ struct recv_frame_hdr *_rtw_alloc_recvfr
 	struct rtw_adapter *padapter;
 	struct recv_priv *precvpriv;
 
-
 	if (_rtw_queue_empty(pfree_recv_queue) == true) {
 		hdr = NULL;
 	} else {
@@ -183,8 +173,6 @@ struct recv_frame_hdr *_rtw_alloc_recvfr
 		}
 	}
 
-
-
 	return hdr;
 }
 
@@ -216,8 +204,6 @@ int rtw_free_recvframe(struct recv_frame
 	struct rtw_adapter *padapter = precvframe->adapter;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 
-
-
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->adapter_type > PRIMARY_ADAPTER) {
 		padapter = padapter->pbuddy_adapter;	/* get primary_padapter */
@@ -249,8 +235,6 @@ int rtw_free_recvframe(struct recv_frame
 
 	spin_unlock_bh(&pfree_recv_queue->lock);
 
-
-
 	return _SUCCESS;
 }
 
@@ -259,8 +243,6 @@ int _rtw_enqueue_recvframe(struct recv_f
 	struct rtw_adapter *padapter = precvframe->adapter;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 
-
-
 	/* INIT_LIST_HEAD(&(precvframe->list)); */
 	list_del_init(&(precvframe->list));
 
@@ -271,8 +253,6 @@ int _rtw_enqueue_recvframe(struct recv_f
 			precvpriv->free_recvframe_cnt++;
 	}
 
-
-
 	return _SUCCESS;
 }
 
@@ -301,7 +281,6 @@ void rtw_free_recvframe_queue(struct __q
 	struct recv_frame_hdr *precvframe;
 	struct list_head *plist, *phead;
 
-
 	_rtw_spinlock(&pframequeue->lock);
 
 	phead = get_list_head(pframequeue);
@@ -317,7 +296,6 @@ void rtw_free_recvframe_queue(struct __q
 
 	_rtw_spinunlock(&pframequeue->lock);
 
-
 }
 
 u32 rtw_free_uc_swdec_pending_queue(struct rtw_adapter *adapter)
@@ -405,7 +383,6 @@ static int recvframe_chkmic(struct rtw_a
 	struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 
-
 	stainfo = rtw_get_stainfo(&adapter->stapriv, &prxattrib->ta[0]);
 
 	if (prxattrib->encrypt == _TKIP_) {
@@ -589,7 +566,6 @@ static struct recv_frame_hdr *decryptor(
 	struct recv_frame_hdr *return_packet = precv_frame;
 	u32 res = _SUCCESS;
 
-
 	RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
 		 ("prxstat->decrypted=%x prxattrib->encrypt = 0x%03x\n",
 		  prxattrib->bdecrypted, prxattrib->encrypt));
@@ -673,8 +649,6 @@ static struct recv_frame_hdr *decryptor(
 		return_packet = NULL;
 	}
 
-
-
 	return return_packet;
 }
 
@@ -693,8 +667,6 @@ static struct recv_frame_hdr *portctrl(s
 	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
 	__be16 be_tmp;
 
-
-
 	pstapriv = &adapter->stapriv;
 	ptr = get_recvframe_data(precv_frame);
 	pfhdr = precv_frame;
@@ -764,8 +736,6 @@ static struct recv_frame_hdr *portctrl(s
 		prtnframe = precv_frame;
 	}
 
-
-
 	return prtnframe;
 }
 
@@ -777,8 +747,6 @@ static int recv_decache(struct recv_fram
 	u16 seq_ctrl = ((precv_frame->attrib.seq_num & 0xffff) << 4) |
 	    (precv_frame->attrib.frag_num & 0xf);
 
-
-
 	if (tid > 15) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
 			 ("recv_decache, (tid>15)! seq_ctrl=0x%x, tid=0x%x\n",
@@ -799,8 +767,6 @@ static int recv_decache(struct recv_fram
 
 	prxcache->tid_rxseq[tid] = seq_ctrl;
 
-
-
 	return _SUCCESS;
 }
 
@@ -1032,8 +998,6 @@ static int sta2sta_data_frame(struct rtw
 	u8 *pframe_body = psnap_type + ETH_TYPE_LEN + PAYLOAD_TYPE_LEN;
 #endif /* CONFIG_TDLS */
 
-
-
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
 	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
 		/*  filter packets that SA is myself or multicast or broadcast */
@@ -1223,8 +1187,6 @@ static int ap2sta_data_frame(struct rtw_
 	u8 *myhwaddr = myid(&adapter->eeprompriv);
 	int bmcast = IS_MCAST(pattrib->dst);
 
-
-
 	if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) &&
 	    (check_fwstate(pmlmepriv, _FW_LINKED) == true ||
 	    check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)) {
@@ -1362,8 +1324,6 @@ static int ap2sta_data_frame(struct rtw_
 
 exit:
 
-
-
 	return ret;
 }
 
@@ -1377,8 +1337,6 @@ static int sta2ap_data_frame(struct rtw_
 	unsigned char *mybssid = get_bssid(pmlmepriv);
 	int ret = _SUCCESS;
 
-
-
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
 		/* For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR */
 		if (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) {
@@ -1429,8 +1387,6 @@ static int sta2ap_data_frame(struct rtw_
 
 exit:
 
-
-
 	return ret;
 }
 
@@ -1536,7 +1492,6 @@ static int validate_recv_ctrl_frame(stru
 				if (psta->sleepq_len == 0) {
 					pstapriv->tim_bitmap &= ~BIT(psta->aid);
 
-
 					/* upate BCN for TIM IE */
 					update_beacon(padapter, _TIM_IE_, NULL,
 						      false);
@@ -1629,8 +1584,6 @@ static int validate_recv_data_frame(stru
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
 #endif /* CONFIG_TDLS */
 
-
-
 	bretry = GetRetry(ptr);
 	pda = get_da(ptr);
 	psa = get_sa(ptr);
@@ -1756,8 +1709,6 @@ static int validate_recv_data_frame(stru
 
 exit:
 
-
-
 	return ret;
 }
 
@@ -1784,8 +1735,6 @@ static int validate_recv_frame(struct rt
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
 #endif /* CONFIG_TDLS */
 
-
-
 #ifdef CONFIG_FIND_BEST_CHANNEL
 	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {
 		int ch_set_idx =
@@ -1862,8 +1811,6 @@ static int validate_recv_frame(struct rt
 
 exit:
 
-
-
 	return retval;
 }
 
@@ -1885,8 +1832,6 @@ static int wlanhdr_to_ethhdr(struct recv
 	u8 *ptr = get_recvframe_data(precvframe);	/*  point to frame_ctrl field */
 	struct rx_pkt_attrib *pattrib = &precvframe->attrib;
 
-
-
 	if (pattrib->encrypt)
 		recvframe_pull_tail(precvframe, pattrib->icv_len);
 
@@ -1948,7 +1893,6 @@ static int wlanhdr_to_ethhdr(struct recv
 		memcpy(ptr + 12, &be_tmp, 2);
 	}
 
-
 	return ret;
 }
 
@@ -1963,8 +1907,6 @@ static struct recv_frame_hdr *recvframe_
 	struct recv_frame_hdr *prframe, *pnextrframe;
 	struct __queue *pfree_recv_queue;
 
-
-
 	curfragnum = 0;
 	pfree_recv_queue = &adapter->recvpriv.free_recv_queue;
 
@@ -2031,8 +1973,6 @@ static struct recv_frame_hdr *recvframe_
 	RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
 		 ("Performance defrag!!!!!\n"));
 
-
-
 	return prframe;
 }
 
@@ -2050,8 +1990,6 @@ struct recv_frame_hdr *recvframe_chk_def
 	struct recv_frame_hdr *prtnframe = NULL;
 	struct __queue *pfree_recv_queue, *pdefrag_q;
 
-
-
 	pstapriv = &padapter->stapriv;
 
 	pfhdr = precv_frame;
@@ -2150,8 +2088,6 @@ struct recv_frame_hdr *recvframe_chk_def
 		}
 	}
 
-
-
 	return prtnframe;
 }
 
@@ -2955,8 +2891,6 @@ s32 rtw_recv_entry(struct recv_frame_hdr
 	struct recv_priv *precvpriv;
 	s32 ret = _SUCCESS;
 
-
-
 	padapter = precvframe->adapter;
 
 	precvpriv = &padapter->recvpriv;
@@ -2970,14 +2904,10 @@ s32 rtw_recv_entry(struct recv_frame_hdr
 
 	precvpriv->rx_pkts++;
 
-
-
 	return ret;
 
 _recv_entry_drop:
 
-
-
 	return ret;
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -39,7 +39,6 @@ static void arcfour_init(struct arc4cont
 	u8 *state;
 	u32 counter;
 
-
 	state = parc4ctx->state;
 	parc4ctx->x = 0;
 	parc4ctx->y = 0;
@@ -66,7 +65,6 @@ static u32 arcfour_byte(struct arc4conte
 	u32 sx, sy;
 	u8 *state;
 
-
 	state = parc4ctx->state;
 	x = (parc4ctx->x + 1) & 0xff;
 	sx = state[x];
@@ -85,7 +83,6 @@ static void arcfour_encrypt(struct arc4c
 {
 	u32 i;
 
-
 	for (i = 0; i < len; i++)
 		dest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);
 
@@ -137,7 +134,6 @@ static __le32 getcrc32(u8 *buf, int len)
 	u8 *p;
 	u32 crc;
 
-
 	if (bcrc32initialized == 0)
 		crc32_init();
 
@@ -165,7 +161,6 @@ void rtw_wep_encrypt(struct rtw_adapter
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
-
 	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
 		return;
 
@@ -222,7 +217,6 @@ void rtw_wep_encrypt(struct rtw_adapter
 		}
 	}
 
-
 }
 
 void rtw_wep_decrypt(struct rtw_adapter *padapter, u8 *precvframe)
@@ -238,8 +232,6 @@ void rtw_wep_decrypt(struct rtw_adapter
 	    &(((struct recv_frame_hdr *)precvframe)->attrib);
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 
-
-
 	pframe =
 	    (unsigned char *)((struct recv_frame_hdr *)precvframe)->rx_data;
 
@@ -639,7 +631,6 @@ u32 rtw_tkip_encrypt(struct rtw_adapter
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	u32 res = _SUCCESS;
 
-
 	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
 		return _FAIL;
 
@@ -752,7 +743,6 @@ u32 rtw_tkip_decrypt(struct rtw_adapter
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	u32 res = _SUCCESS;
 
-
 	pframe =
 	    (unsigned char *)((struct recv_frame_hdr *)precvframe)->rx_data;
 
@@ -1173,7 +1163,6 @@ static void construct_mic_header2(u8 *mi
 		mic_header2[15] = mpdu[31] & 0x00;
 	}
 
-
 }
 
 /************************************************/
@@ -1244,7 +1233,6 @@ static int aes_cipher(u8 *key, uint hdrl
 	uint frtype = GetFrameType(pframe);
 	uint frsubtype = GetFrameSubType(pframe);
 
-
 	frsubtype = frsubtype >> 4;
 
 	memset((void *)mic_iv, 0, 16);
@@ -1384,8 +1372,6 @@ u32 rtw_aes_encrypt(struct rtw_adapter *
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	u32 res = _SUCCESS;
 
-
-
 	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
 		return _FAIL;
 
@@ -1684,7 +1670,6 @@ static int aes_decipher(u8 *key, uint hd
 		DBG_8192D("error packet header\n");
 	}
 
-
 	return res;
 }
 
@@ -2584,8 +2569,6 @@ void rtw_use_tkipkey_handler(void *Funct
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)FunctionContext;
 
-
-
 	RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
 		 ("^^^rtw_use_tkipkey_handler ^^^\n"));
 
@@ -2595,5 +2578,4 @@ void rtw_use_tkipkey_handler(void *Funct
 		 ("^^^rtw_use_tkipkey_handler padapter->securitypriv.busetkipkey =%d^^^\n",
 		  padapter->securitypriv.busetkipkey));
 
-
 }
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ b/drivers/staging/rtl8192du/core/rtw_tdls.c
@@ -615,7 +615,6 @@ void issue_tdls_teardown(_adapter *padap
 		rtw_tdls_cmd(padapter, mac_addr, TDLS_FREE_STA);
 	}
 
-
 exit:
 
 	return;
@@ -895,7 +894,6 @@ void issue_tdls_ch_switch_rsp(_adapter *
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 
-
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
 	if (pmgntframe == NULL)
 		return;
@@ -938,7 +936,6 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, s
 	u8 empty_addr[ETH_ALEN] = { 0x00 };
 	int UndecoratedSmoothedPWDB;
 
-
 	/* WFDTDLS: for sigma test, not to setup direct link automatically */
 	ptdlsinfo->dev_discovered = 1;
 
@@ -1910,7 +1907,6 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	/* QoS capability(WMM_IE) */
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 7, TDLS_WMMIE,  &(pattrib->pktlen));
 
-
 	if (pattrib->encrypt) {
 		/* FTIE */
 		memset(pframe, 0, 84);	/* All fields except SNonce shall be set to 0 */
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -20,7 +20,6 @@
 #include <drv_types.h>
 #include <wifi.h>
 
-
 static unsigned char ARTHEROS_OUI1[] = {0x00, 0x03, 0x7f};
 static unsigned char ARTHEROS_OUI2[] = {0x00, 0x13, 0x74};
 
@@ -59,7 +58,6 @@ static u8 rtw_basic_rate_mix[7] = {
 	IEEE80211_OFDM_RATE_24MB|IEEE80211_BASIC_RATE_MASK
 };
 
-
 int cckrates_included(unsigned char *rate, int ratelen)
 {
 	int	i;
@@ -126,7 +124,6 @@ int judge_network_type(struct rtw_adapte
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-
 	if (pmlmeext->cur_channel > 14) {
 		if (pmlmeinfo->HT_enable)
 			network_type = WIRELESS_11_5N;
@@ -236,7 +233,6 @@ static unsigned int ratetbl2rateset(stru
 	return len;
 }
 
-
 void get_rate_set(struct rtw_adapter *padapter, unsigned char *pbssrate, int *bssrate_len)
 {
 	unsigned char supportedrates[NUMRATES];
@@ -477,7 +473,6 @@ void set_channel_bwmode(struct rtw_adapt
 
 #endif /*  CONFIG_DUALMAC_CONCURRENT */
 
-
 	/* set BandWidth */
 	SetBWMode(padapter, bwmode, channel_offset);
 }
@@ -825,7 +820,6 @@ static void bwmode_update_check(struct r
 		new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 	}
 
-
 	if ((new_bwmode != pmlmeext->cur_bwmode) ||
 	    (new_ch_offset != pmlmeext->cur_ch_offset)) {
 		pmlmeinfo->bwmode_updated = true;
@@ -839,7 +833,6 @@ static void bwmode_update_check(struct r
 		pmlmeinfo->bwmode_updated = false;
 	}
 
-
 	if (true == pmlmeinfo->bwmode_updated) {
 		struct sta_info *psta;
 		struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
@@ -949,7 +942,6 @@ void HT_info_handler(struct rtw_adapter
 	if (phtpriv->ht_option == false)
 		return;
 
-
 	if (pIE->Length > sizeof(struct HT_info_element))
 		return;
 
--- a/drivers/staging/rtl8192du/hal/hal_com.c
+++ b/drivers/staging/rtl8192du/hal/hal_com.c
@@ -71,7 +71,6 @@ u32 OFDMSwingTable[OFDM_TABLE_SIZE_92D]
 	0x0b40002d,/*  42, -15.0dB */
 };
 
-
 u8 CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8] = {
 	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},/*  0, +0dB */
 	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},/*  1, -0.5dB */
@@ -108,7 +107,6 @@ u8 CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE
 	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01} /*  32, -16.0dB */
 };
 
-
 u8 CCKSwingTable_Ch14[CCK_TABLE_SIZE][8] = {
 	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},/*  0, +0dB */
 	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},/*  1, -0.5dB */
@@ -145,7 +143,6 @@ u8 CCKSwingTable_Ch14[CCK_TABLE_SIZE][8]
 	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00} /*  32, -16.0dB */
 };
 
-
 #ifdef CONFIG_CHIP_VER_INTEGRATION
 void dump_chip_info(HAL_VERSION	chip_ver)
 {
--- a/drivers/staging/rtl8192du/hal/hal_intf.c
+++ b/drivers/staging/rtl8192du/hal/hal_intf.c
@@ -130,8 +130,6 @@ uint rtw_hal_deinit(struct rtw_adapter *
 {
 	uint	status = _SUCCESS;
 
-
-
 	status = padapter->HalFunc.hal_deinit(padapter);
 
 	if (status == _SUCCESS)
@@ -139,7 +137,6 @@ uint rtw_hal_deinit(struct rtw_adapter *
 	else
 		RT_TRACE(_module_hal_init_c_,_drv_err_,("\n rtw_hal_deinit: hal_init fail\n"));
 
-
 	return status;
 }
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -60,7 +60,6 @@ CheckFwReadLastH2C(
 	return Result;
 }
 
-
 /*  */
 /*  Description: */
 /*	Fill H2C command */
@@ -91,14 +90,11 @@ static void _FillH2CCmd92D(struct rtw_ad
 	u8	WaitWriteH2cLimmit = 100;
 	u8	idx=0;
 
-
-
 	padapter = GET_PRIMARY_ADAPTER(padapter);
 	pHalData = GET_HAL_DATA(padapter);
 
 	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex));
 
-
 	while (!bWriteSucess)
 	{
 		WaitWriteH2cLimmit--;
@@ -160,7 +156,6 @@ static void _FillH2CCmd92D(struct rtw_ad
 
 		BoxContent[0] = ElementID; /*  Fill element ID */
 
-
 		switch (CmdLen)
 		{
 			case 1:
@@ -228,7 +223,6 @@ static void _FillH2CCmd92D(struct rtw_ad
 				break;
 		}
 
-
 		/*  5. Normal chip does not need to check if the H2C cmd has be written successfully. */
 		/*  92D test chip does not need to check, */
 		bWriteSucess = true;
@@ -238,12 +232,10 @@ static void _FillH2CCmd92D(struct rtw_ad
 		if (pHalData->LastHMEBoxNum == 4) /*  loop to 0 */
 			pHalData->LastHMEBoxNum = 0;
 
-
 	}
 
 	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex));
 
-
 }
 
 void
@@ -291,14 +283,12 @@ static u8 rtl8192d_h2c_msg_hdl(struct rt
 	return H2C_SUCCESS;
 }
 
-
 u8 rtl8192d_set_raid_cmd(struct rtw_adapter*padapter, u32 mask, u8 arg)
 {
 	u8	buf[5];
 	u8	res=_SUCCESS;
 	__le32	le_mask;
 
-
 	memset(buf, 0, 5);
 	le_mask = cpu_to_le32(mask);
 	memcpy(buf, &le_mask, 4);
@@ -306,8 +296,6 @@ u8 rtl8192d_set_raid_cmd(struct rtw_adap
 
 	FillH2CCmd92D(padapter, H2C_RA_MASK, 5, buf);
 
-
-
 	return res;
 }
 
@@ -341,15 +329,12 @@ void rtl8192d_Add_RateATid(struct rtw_ad
 	}
 }
 
-
 void rtl8192d_set_FwPwrMode_cmd(struct rtw_adapter*padapter, u8 Mode)
 {
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	u8	u1H2CSetPwrMode[3]={0};
 	u8	beacon_interval = 1;
 
-
-
 	DBG_8192D("%s(): Mode = %d, SmartPS = %d\n", __func__,Mode,pwrpriv->smart_ps);
 
 	SET_H2CCMD_PWRMODE_PARM_MODE(u1H2CSetPwrMode, Mode);
@@ -358,7 +343,6 @@ void rtl8192d_set_FwPwrMode_cmd(struct r
 
 	FillH2CCmd92D(padapter, H2C_SETPWRMODE, 3, u1H2CSetPwrMode);
 
-
 }
 
 static void ConstructBeacon(struct rtw_adapter *padapter, u8 *pframe, u32 *pLength)
@@ -403,7 +387,6 @@ static void ConstructBeacon(struct rtw_a
 	pframe += 2;
 	pktlen += 2;
 
-
 	if ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 		DBG_8192D("ie len=%u\n", cur_network->IELength);
@@ -433,17 +416,14 @@ static void ConstructBeacon(struct rtw_a
 		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pktlen);
 	}
 
-
 	/* todo: ERP IE */
 
-
 	/*  EXTERNDED SUPPORTED RATE */
 	if (rate_len > 8)
 	{
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pktlen);
 	}
 
-
 	/* todo:HT for adhoc */
 
 _ConstructBeacon:
@@ -465,7 +445,6 @@ static void ConstructPSPoll(struct rtw_a
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 
 	/*  Frame control. */
@@ -496,7 +475,6 @@ static void ConstructNullFunctionData(st
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 
 	fctrl = &(pwlanhdr->frame_ctl);
@@ -548,7 +526,6 @@ static void ConstructProbeRsp(struct rtw
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
 
-
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 
 	mac = myid(&(padapter->eeprompriv));
@@ -630,7 +607,6 @@ FillFakeTxDescriptor92D(
 	RT_PRINT_DATA(_module_rtl8712_cmd_c_, _drv_info_, "FillFakeTxDescriptor92D(): H2C Tx Desc Content ----->\n", pDesc, TXDESC_SIZE);
 }
 
-
 /*  */
 /*  Description: Fill the reserved packets that FW will use to RSVD page. */
 /*			Now we just send 4 types packet to rsvd page. */
@@ -788,8 +764,6 @@ void rtl8192d_set_FwJoinBssReport_cmd(st
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	bool	bRecover = false;
 
-
-
 	DBG_8192D("%s\n", __func__);
 
 	if (mstatus == 1)
@@ -842,7 +816,6 @@ void rtl8192d_set_FwJoinBssReport_cmd(st
 
 	FillH2CCmd92D(padapter, H2C_JOINBSSRPT, 1, u1JoinBssRptParm);
 
-
 }
 
 #ifdef CONFIG_P2P_PS
@@ -863,8 +836,6 @@ void rtl8192d_set_p2p_ps_offload_cmd(str
 	u16	ctwindow;
 	u32	start_time, tsf_low;
 
-
-
 	switch (p2p_ps_state)
 	{
 		case P2P_PS_DISABLE:
@@ -949,12 +920,9 @@ void rtl8192d_set_p2p_ps_offload_cmd(str
 
 	FillH2CCmd92D(padapter, H2C_P2P_PS_OFFLOAD, 1, (u8 *)p2p_ps_offload);
 
-
 }
 #endif /*  CONFIG_P2P_PS */
 
-
-
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 /*
 	ask FW to Reset sync register at Beacon early interrupt
@@ -964,7 +932,6 @@ static u8 rtl8192d_reset_tsf(struct rtw_
 	u8	buf[2];
 	u8	res=_SUCCESS;
 
-
 	if (IFACE_PORT0==reset_port) {
 		buf[0] = 0x1; buf[1] = 0;
 
@@ -973,7 +940,6 @@ static u8 rtl8192d_reset_tsf(struct rtw_
 	}
 	FillH2CCmd92D(padapter, H2C_92D_RESET_TSF, 2, buf);
 
-
 	return res;
 }
 
@@ -996,7 +962,6 @@ int reset_tsf(struct rtw_adapter * adapt
 	return(loop_cnt >= 10) ? _FAIL : true;
 }
 
-
 #endif	/*  CONFIG_TSF_RESET_OFFLOAD */
 
 #ifdef CONFIG_WOWLAN
@@ -1010,16 +975,12 @@ void rtl8192d_set_wowlan_cmd(struct rtw_
 	struct set_wowlan_parm pwowlan_parm;
 	struct pwrctrl_priv *pwrpriv=&padapter->pwrctrlpriv;
 
-
-
 	pwowlan_parm.mode =0;
 	pwowlan_parm.gpio_index=0;
 	pwowlan_parm.gpio_duration=0;
 	pwowlan_parm.second_mode =0;
 	pwowlan_parm.reserve=0;
 
-
-
 	if (pwrpriv->wowlan_mode ==true) {
 		/* pause RX DMA */
 		test = rtw_read8(padapter, REG_RXPKT_NUM+2);
@@ -1068,7 +1029,6 @@ void rtl8192d_set_wowlan_cmd(struct rtw_
 		}
 		FillH2CCmd92D(padapter, H2C_WO_WLAN_CMD, 4, (u8 *)&pwowlan_parm);
 
-
 		/* keep alive period = 3 * 10 BCN interval */
 		pwowlan_parm.mode =3;
 		pwowlan_parm.gpio_index=3;
@@ -1092,9 +1052,6 @@ void rtl8192d_set_wowlan_cmd(struct rtw_
 	else
 		FillH2CCmd92D(padapter, H2C_WO_WLAN_CMD, 4, (u8 *)&pwowlan_parm);
 
-
-
-
 	return ;
 }
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -67,7 +67,6 @@ static void dm_DIGInit(
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
 
-
 	dm_digtable->dig_enable_flag = true;
 	dm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_MAX;
 
@@ -83,7 +82,6 @@ static void dm_DIGInit(
 	dm_digtable->falowthresh	= DM_FALSEALARM_THRESH_LOW;
 	dm_digtable->fahighthresh	= DM_FALSEALARM_THRESH_HIGH;
 
-
 	dm_digtable->rx_gain_range_max = DM_DIG_MAX;
 	dm_digtable->rx_gain_range_min = DM_DIG_MIN;
 	dm_digtable->rx_gain_range_min_nolink = 0;
@@ -162,7 +160,6 @@ odm_FalseAlarmCounterStatistics_ForSlave
 								falsealmcnt->Cnt_Crc8_fail + falsealmcnt->Cnt_Mcs_fail +
 								falsealmcnt->Cnt_Fast_Fsync + falsealmcnt->Cnt_SB_Search_fail;
 
-
 	/* hold cck counter */
 	falsealmcnt->Cnt_Cck_fail = FlaseAlmCntBuddyadapter->Cnt_Cck_fail;
 
@@ -227,7 +224,6 @@ odm_FalseAlarmCounterStatistics(
 		falsealmcnt->Cnt_Cck_fail = 0;
 	}
 
-
 	falsealmcnt->Cnt_all = (	falsealmcnt->Cnt_Fast_Fsync +
 						falsealmcnt->Cnt_SB_Search_fail +
 						falsealmcnt->Cnt_Parity_Fail +
@@ -508,7 +504,6 @@ static void odm_DIG(
 	struct dm_priv	*pbuddy_pdmpriv = &pbuddy_pHalData->dmpriv;
 #endif /* CONFIG_CONCURRENT_MODE */
 
-
 	if (IS_HARDWARE_TYPE_8192D(adapter))
 	{
 		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
@@ -816,7 +811,6 @@ static void odm_DIG(
 
 	}
 
-
 }
 
 static u8
@@ -829,7 +823,6 @@ dm_initial_gain_MinPWDB(
 	s32	rssi_val_min = 0;
 	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
 
-
 	if ((dm_digtable->curmultistaconnectstate == DIG_MultiSTA_CONNECT) &&
 	   (dm_digtable->curstaconnectstate == DIG_STA_CONNECT)) {
 		if (pdmpriv->EntryMinUndecoratedSmoothedPWDB != 0)
@@ -1211,7 +1204,6 @@ static void odm_DynamicTxPower_92D(struc
 	pdmpriv->LastDTPLvl = pdmpriv->DynamicTxHighPowerLvl;
 }
 
-
 static void PWDB_Monitor(
 	struct rtw_adapter *	adapter
 	)
@@ -1223,7 +1215,6 @@ static void PWDB_Monitor(
 	u8	sta_cnt=0;
 	u32	PWDB_rssi[NUM_STA]={0};/* 0~15]:MACID, [16~31]:PWDB_rssi */
 
-
 	if (check_fwstate(&adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
 	{
 		struct list_head *plist, *phead;
@@ -1274,7 +1265,6 @@ static void PWDB_Monitor(
 		}
 	}
 
-
 	if (tmpEntryMaxPWDB != 0)	/*  If associated entry is found */
 	{
 		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;
@@ -1567,10 +1557,8 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 	else if (pHalData->CurrentChannel != 14 && pdmpriv->bCCKinCH14)
 		pdmpriv->bCCKinCH14 = false;
 
-
 	ThermalValue = (u8)PHY_QueryRFReg(adapter, RF_PATH_A, RF_T_METER, 0xf800);	/* 0x42: RF Reg[15:11] 92D */
 
-
 	rtl8192d_PHY_APCalibrate(adapter, (ThermalValue - pHalData->EEPROMThermalMeter));/* notes:EEPROMThermalMeter is a fixed value from efuse/eeprom */
 
 	if (is2T)
@@ -1972,11 +1960,9 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 
 	}
 
-
 	pdmpriv->TXPowercount = 0;
 }
 
-
 static	void
 dm_InitializeTXPowerTracking_ThermalMeter(
 	struct rtw_adapter *		adapter)
@@ -1995,7 +1981,6 @@ dm_InitializeTXPowerTracking_ThermalMete
 	MSG_8192D("pdmpriv->TxPowerTrackControl = %d\n", pdmpriv->TxPowerTrackControl);
 }
 
-
 static void
 DM_InitializeTXPowerTracking(
 	struct rtw_adapter *		adapter)
@@ -2055,7 +2040,6 @@ dm_CheckTXPowerTracking_ThermalMeter(
 	}
 }
 
-
 void
 rtl8192d_dm_CheckTXPowerTracking(
 	struct rtw_adapter *		adapter)
@@ -2067,7 +2051,6 @@ rtl8192d_dm_CheckTXPowerTracking(
 	dm_CheckTXPowerTracking_ThermalMeter(adapter);
 }
 
-
 /*-----------------------------------------------------------------------------
  * Function:	dm_CheckRfCtrlGPIO()
  *
@@ -2153,7 +2136,6 @@ static void	dm_CheckPbcGPIO(struct rtw_a
 		/*  After trigger PBC, the variable will be set to false */
 		DBG_8192D("CheckPbcGPIO - PBC is pressed, try_cnt=%d\n", i-1);
 
-
 		if (padapter->pid[0] == 0)
 		{	/*	0 is the default value and it means the application monitors the HW PBC doesn't privde its pid to driver. */
 			return;
@@ -2178,7 +2160,6 @@ static void dm_InitRateAdaptiveMask(stru
 		pdmpriv->bUseRAMask = false;
 }
 
-
 /*-----------------------------------------------------------------------------
  * Function:	dm_RefreshRateAdaptiveMask()
  *
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -34,7 +34,6 @@ atomic_t GlobalCounterForMutex = ATOMIC_
 bool GlobalFirstConfigurationForNormalChip = true;
 #endif
 
-
 static bool
 _IsFWDownloaded(
 	struct rtw_adapter *			adapter
@@ -525,7 +524,6 @@ InitializeFirmwareVars92D(
 	pHalData->LastHMEBoxNum = 0;
 }
 
-
 /*  */
 
 /*  */
@@ -567,7 +565,6 @@ SetFwRelatedForWoWLAN8192DU(
 		/*  */
 		InitializeFirmwareVars92D(padapter);
 
-
 	}
 }
 #endif /* CONFIG_WOWLAN */
@@ -1053,7 +1050,6 @@ PHY_CheckPowerOffFor8192D(
 	return true;
 }
 
-
 /************************************************************
 Function: Synchrosize for power off/on with dual mac
 *************************************************************/
@@ -1124,7 +1120,6 @@ PHY_SetPowerOnFor8192D(
 void rtl8192d_free_hal_data(struct rtw_adapter * padapter)
 {
 
-
 	DBG_8192D("===== rtl8192du_free_hal_data =====\n");
 
 	kfree(padapter->HalData);
@@ -1224,7 +1219,6 @@ ReadEFuse_RTL8192D(
 		for (j = 0; j < EFUSE_MAX_WORD_UNIT; j++)
 			eFuseWord[i][j] = 0xFFFF;
 
-
 	/*  */
 	/*  1. Read the first byte to check if efuse is empty!!! */
 	/*  */
@@ -1291,7 +1285,6 @@ ReadEFuse_RTL8192D(
 					efuse_utilized++;
 					eFuseWord[offset][i] = (*rtemp8 & 0xff);
 
-
 					if (eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
 						break;
 
@@ -1568,7 +1561,6 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 	if (data==NULL)	return false;
 	if (offset>=EFUSE_MAX_SECTION)		return false;
 
-
 	memset((void *)data, 0xff, sizeof(u8)*PGPKT_DATA_SIZE);
 	memset((void *)tmpdata, 0xff, sizeof(u8)*PGPKT_DATA_SIZE);
 
@@ -1707,7 +1699,6 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 	efuse_WordEnableDataRead(word_en, data, target_pkt.data);
 	target_word_cnts = Efuse_CalculateWordCnts(target_pkt.word_en);
 
-
 	/*  */
 	/*  <Roger_Notes> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP. */
 	/*  So we have to prevent unexpected data string connection, which will cause */
--- a/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
@@ -15,7 +15,6 @@
  ******************************************************************************/
 /******************************************************************************
 
-
  Module:	rtl8192d_phycfg.c
 
  Note:		Merge 92DE/SDU PHY config as below
@@ -58,14 +57,12 @@
 
 /*---------------------------Define Local Constant---------------------------*/
 
-
 /*------------------------Define global variable-----------------------------*/
 #ifdef CONFIG_DUALMAC_CONCURRENT
 extern atomic_t GlobalCounterForMutex;
 #endif
 /*------------------------Define local variable------------------------------*/
 
-
 /*--------------------Define export function prototype-----------------------*/
 /*  Please refer to header file */
 /*--------------------Define export function prototype-----------------------*/
@@ -140,7 +137,6 @@ u8 rtl8192d_GetRightChnlPlaceforIQK(u8 c
 	u8	channel_all[TARGET_CHNL_NUM_2G_5G] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
 	u8	place = chnl;
 
-
 	if (chnl > 14)
 	{
 		for (place = 14; place<sizeof(channel_all); place++)
@@ -155,7 +151,6 @@ u8 rtl8192d_GetRightChnlPlaceforIQK(u8 c
 	return 0;
 }
 
-
 /*  */
 /*  1. BB register R/W API */
 /*  */
@@ -319,7 +314,6 @@ phy_FwRFSerialRead(
 	return	(retValue);
 }	/* phy_FwRFSerialRead */
 
-
 /*-----------------------------------------------------------------------------
  * Function:	phy_FwRFSerialWrite()
  *
@@ -431,8 +425,6 @@ phy_RFSerialRead(
 	return retValue;
 }
 
-
-
 /**
 * Function:	phy_RFSerialWrite
 *
@@ -489,7 +481,6 @@ phy_RFSerialWrite(
 	struct bb_register_def *pPhyReg = &pHalData->PHYRegDef[eRFPath];
 	u32	NewOffset,MaskforPhySet=0;
 
-
 	/*  2009/06/17 MH We can not execute IO for power save or other accident mode. */
 
 	if (Offset & MAC1_ACCESS_PHY0)
@@ -522,7 +513,6 @@ phy_RFSerialWrite(
 	PHY_SetBBReg(adapter, pPhyReg->rf3wireOffset|MaskforPhySet, bMaskDWord, DataAndAddr);
 }
 
-
 /**
 * Function:	PHY_QueryRFReg
 *
@@ -749,7 +739,6 @@ int PHY_MACConfig8192D(struct rtw_adapte
 	return rtStatus;
 }
 
-
 /**
 * Function:	phy_InitBBRFRegisterDefinition
 *
@@ -896,7 +885,6 @@ phy_ConfigBBWithHeaderFile(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
-
 	/* Normal chip,Mac0 use AGC_TAB.txt for 2G and 5G band. */
 	if (pHalData->interfaceIndex == 0) {
 		AGCTAB_ArrayLen = Rtl8192D_AGCTAB_ArrayLength;
@@ -1119,7 +1107,6 @@ phy_ConfigBBWithPgParaFile(
 
 	int		rtStatus = _SUCCESS;
 
-
 	return rtStatus;
 }	/* phy_ConfigBBWithPgParaFile */
 #endif /* CONFIG_EMBEDDED_FWIMG */
@@ -1423,7 +1410,6 @@ PHY_BBConfig8192D(
 	return rtStatus;
 }
 
-
 int
 PHY_RFConfig8192D(
 	struct rtw_adapter *	adapter
@@ -1443,7 +1429,6 @@ PHY_RFConfig8192D(
 	return rtStatus;
 }
 
-
 /*-----------------------------------------------------------------------------
  * Function:    PHY_ConfigRFWithParaFile()
  *
@@ -1468,7 +1453,6 @@ rtl8192d_PHY_ConfigRFWithParaFile(
 {
 	int	rtStatus = _SUCCESS;
 
-
 	return rtStatus;
 }
 
@@ -1628,7 +1612,6 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 	return rtStatus;
 }
 
-
 /*-----------------------------------------------------------------------------
  * Function:    PHY_CheckBBAndRFOK()
  *
@@ -1702,7 +1685,6 @@ rtl8192d_PHY_CheckBBAndRFOK(
 			break;
 		}
 
-
 		/*  */
 		/*  Check whether readback data is correct */
 		/*  */
@@ -1716,7 +1698,6 @@ rtl8192d_PHY_CheckBBAndRFOK(
 	return rtStatus;
 }
 
-
 void
 rtl8192d_PHY_GetHWRegOriginalValue(
 	struct rtw_adapter *		adapter
@@ -1735,7 +1716,6 @@ rtl8192d_PHY_GetHWRegOriginalValue(
 	pHalData->framesyncC34 = PHY_QueryBBReg(adapter, rOFDM0_RxDetector2, bMaskDWord);
 }
 
-
 /*  */
 /*	Description: */
 /*		Map dBm into Tx power index according to */
@@ -1753,7 +1733,6 @@ phy_DbmToTxPwrIdx(
 	u8				TxPwrIdx = 0;
 	int				Offset = 0;
 
-
 	/*  */
 	/*  Tested by MP, we found that CCK Index 0 equals to 8dbm, OFDM legacy equals to */
 	/*  3dbm, and OFDM HT equals to 0dbm repectively. */
@@ -1792,7 +1771,6 @@ phy_DbmToTxPwrIdx(
 	return TxPwrIdx;
 }
 
-
 /*  */
 /*	Description: */
 /*		Map Tx power index into dBm according to */
@@ -1836,7 +1814,6 @@ phy_TxPwrIdxToDbm(
 	return PwrOutDbm;
 }
 
-
 /*-----------------------------------------------------------------------------
  * Function:    GetTxPowerLevel8190()
  *
@@ -1886,7 +1863,6 @@ PHY_GetTxPowerLevel8192D(
 	*powerlevel = TxPwrDbm;
 }
 
-
 static void getTxPowerIndex(
 	struct rtw_adapter *		adapter,
 	u8			channel,
@@ -2004,7 +1980,6 @@ PHY_UpdateTxPowerDbm8192D(
 	else
 		OfdmTxPwrIdx = 0;
 
-
 	for (idx = 0; idx < CHANNEL_MAX_NUMBER; idx++)
 	{
 		for (rf_path = 0; rf_path < 2; rf_path++)
@@ -2016,11 +1991,9 @@ PHY_UpdateTxPowerDbm8192D(
 		}
 	}
 
-
 	return true;
 }
 
-
 /*
 	Description:
 		When beacon interval is changed, the values of the
@@ -2029,7 +2002,6 @@ PHY_UpdateTxPowerDbm8192D(
 
 */
 
-
 void
 rtl8192d_PHY_SetBeaconHwReg(
 	struct rtw_adapter *		adapter,
@@ -2038,7 +2010,6 @@ rtl8192d_PHY_SetBeaconHwReg(
 {
 }
 
-
 void
 PHY_ScanOperationBackup8192D(
 	struct rtw_adapter *	adapter,
@@ -2077,7 +2048,6 @@ _PHY_SetBWMode92D(
 	struct hal_data_8192du *pHalDataBuddyadapter;
 #endif
 
-
 	if (pHalData->rf_chip == RF_PSEUDO_11N)
 		return;
 
@@ -2088,7 +2058,6 @@ _PHY_SetBWMode92D(
 	if (adapter->bDriverStopped)
 		return;
 
-
 	/* 3 */
 	/* 3<1>Set MAC register */
 	/* 3 */
@@ -2187,7 +2156,6 @@ _PHY_SetBWMode92D(
 			break;
 	}
 
-
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (adapter->DualMacConcurrent == true && Buddyadapter != NULL)
 	{
@@ -2229,7 +2197,6 @@ PHY_SetBWMode8192D(
 	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
 #endif
 
-
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (pHalData->bInModeSwitchProcess)
 	{
@@ -2238,7 +2205,6 @@ PHY_SetBWMode8192D(
 	}
 #endif
 
-
 	pHalData->CurrentChannelBW = Bandwidth;
 
 	pHalData->nCur40MhzPrimeSC = Offset;
@@ -2265,7 +2231,6 @@ PHY_SetBWMode8192D(
 	}
 }
 
-
 /*******************************************************************
 Descriptor:
 			stop TRX Before change bandType dynamically
@@ -2392,7 +2357,6 @@ static void PHY_SwitchWirelessBand(struc
 	}
 #endif
 
-
 	pdmpriv->bReloadtxpowerindex = true;
 
 	/*  notice fw know band status  0x81[1]/0x53[1] = 0: 5G, 1: 2G */
@@ -2409,13 +2373,11 @@ static void PHY_SwitchWirelessBand(struc
 		rtw_write8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1),value8);
 	}
 
-
 	for (i=0;i<20;i++)
 			rtw_udelay_os(MAX_STALL_TIME);
 
 }
 
-
 static void
 PHY_EnableRFENV(
 	struct rtw_adapter *		adapter,
@@ -2427,7 +2389,6 @@ PHY_EnableRFENV(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct bb_register_def *pPhyReg = &pHalData->PHYRegDef[eRFPath];
 
-
 	/*----Store original RFENV control type----*/
 	switch (eRFPath)
 	{
@@ -2483,7 +2444,6 @@ PHY_RestoreRFENV(
 	}
 }
 
-
 /*-----------------------------------------------------------------------------
  * Function:	phy_SwitchRfSetting
  *
@@ -2515,7 +2475,6 @@ PHY_RestoreRFENV(
 	/* Query regB30 bit27 */
 	u32			Regb30 = PHY_QueryBBReg(adapter, 0xb30, BIT27);
 
-
 	/* only for 92D C-cut SMSP */
 
 	if (adapter_to_dvobj(adapter)->ishighspeed == false)
@@ -2671,7 +2630,6 @@ PHY_RestoreRFENV(
 			}
 		}
 
-
 		for (i = 0; i < RF_REG_NUM_for_C_CUT_2G; i++)
 		{
 #if SWLCK == 1
@@ -2703,7 +2661,6 @@ PHY_RestoreRFENV(
 	}
 }
 
-
 /*-----------------------------------------------------------------------------
  * Function:	phy_ReloadLCKSetting
  *
@@ -2780,11 +2737,8 @@ static  void
 		}
 	}
 
-
-
 }
 
-
 /*-----------------------------------------------------------------------------
  * Function:	phy_ReloadIMRSetting
  *
@@ -2856,7 +2810,6 @@ static  void
 
 }
 
-
 /*-----------------------------------------------------------------------------
  * Function:	phy_ReloadIQKSetting
  *
@@ -2933,7 +2886,6 @@ static  void
 	pHalData->bNeedIQK = false;
 }
 
-
 static void _PHY_SwChnl8192D(struct rtw_adapter * adapter, u8 channel)
 {
 	u8	eRFPath;
@@ -3034,7 +2986,6 @@ static void _PHY_SwChnl8192D(struct rtw_
 #endif
 }
 
-
 void
 PHY_SwChnl8192D(	/*  Call after initialization */
 	struct rtw_adapter *adapter,
@@ -3059,8 +3010,6 @@ PHY_SwChnl8192D(	/*  Call after initiali
 	if (adapter->mlmeextpriv.sitesurvey_res.state == SCAN_COMPLETE)
 		pHalData->bLoadIMRandIQKSettingFor2G = false;
 
-
-
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (pHalData->bInModeSwitchProcess)
 	{
@@ -3121,7 +3070,6 @@ PHY_SwChnl8192D(	/*  Call after initiali
 
 	pHalData->CurrentChannel=channel;
 
-
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if ((Buddyadapter !=NULL) && (pHalData->bSlaveOfDMSP))
 	{
@@ -3155,7 +3103,6 @@ phy_SwChnlStepByStep(
 	return true;
 }
 
-
 static	bool
 phy_SetSwChnlCmdArray(
 	struct sw_chnl_cmd *cmdtable,
@@ -3191,7 +3138,6 @@ phy_FinishSwChnlNow(	/*  We should not c
 {
 }
 
-
 /*  */
 /*  Description: */
 /*	Switch channel synchronously. Called by SwChnlByDelayHandler. */
@@ -3209,7 +3155,6 @@ PHY_SwChnlPhy8192D(	/*  Only called duri
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
-
 	/*  Cannot IO. */
 
 	/*  Channel Switching is in progress. */
@@ -3229,7 +3174,6 @@ PHY_SwChnlPhy8192D(	/*  Only called duri
 
 }
 
-
 /*  */
 /*	Description: */
 /*		Configure H/W functionality to enable/disable Monitor mode. */
@@ -3244,7 +3188,6 @@ PHY_SetMonitorMode8192D(
 {
 }
 
-
 /*-----------------------------------------------------------------------------
  * Function:	PHYCheckIsLegalRfPath8190Pci()
  *
@@ -3384,7 +3327,6 @@ phy_PathA_IQK_5G_Normal(
 		RxOKBit = BIT30;
 	}
 
-
 	/* path-A IQK setting */
 
 	PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
@@ -3431,7 +3373,6 @@ phy_PathA_IQK_5G_Normal(
 			timecount++;
 		}
 
-
 		/*  Check failed */
 		regEAC = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
 		regE94 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord);
@@ -3514,7 +3455,6 @@ phy_PathB_IQK(
 	else
 		DBG_8192D("Path B Rx IQK fail!!\n");
 
-
 	return result;
 }
 
@@ -3535,7 +3475,6 @@ phy_PathB_IQK_5G_Normal(
 #endif
 	u8	timeout = 20, timecount = 0;
 
-
 	/* path-A IQK setting */
 	PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
 	PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
@@ -3562,7 +3501,6 @@ phy_PathB_IQK_5G_Normal(
 		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xfa000000);
 		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
-
 		/*  delay x ms */
 		rtw_mdelay_os(IQK_DELAY_TIME*10);
 
@@ -3577,7 +3515,6 @@ phy_PathB_IQK_5G_Normal(
 			timecount++;
 		}
 
-
 		/*  Check failed */
 		regEAC = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
 		regEB4 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord);
@@ -3632,7 +3569,6 @@ phy_PathAFillIQKMatrix(
 	int	Y, TX0_C;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
-
 	if (final_candidate == 0xFF)
 		return;
 
@@ -3715,7 +3651,6 @@ phy_PathAFillIQKMatrix_5G_Normal(
 		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, 0x003FF, Y);
 		PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT26, 0);
 
-
 		if (bTxOnly)
 		{
 			return;
@@ -3923,7 +3858,6 @@ phy_PathADDAOn(
 	u32	pathOn;
 	u32	i;
 
-
 	pathOn = isPathAOn ? 0x04db25a4 : 0x0b1b25a4;
 	/*  Modified by Neil Chen */
 	/*  for Path diversity and original IQK */
@@ -3944,7 +3878,6 @@ phy_MACSettingCalibration(
 {
 	u32	i = 0;
 
-
 	rtw_write8(adapter, MACReg[i], 0x3F);
 
 	for (i = 1 ; i < (IQK_MAC_REG_NUM - 1); i++) {
@@ -3972,7 +3905,6 @@ phy_PIModeSwitch(
 {
 	u32	mode;
 
-
 	mode = PIMode ? 0x01000100 : 0x01000000;
 	PHY_SetBBReg(adapter, 0x820, bMaskDWord, mode);
 	PHY_SetBBReg(adapter, 0x828, bMaskDWord, mode);
@@ -4292,7 +4224,6 @@ phy_IQCalibrate(
 	}
 }
 
-
 static void
 phy_IQCalibrate_5G(
 	struct rtw_adapter *	adapter,
@@ -4403,7 +4334,6 @@ phy_IQCalibrate_5G(
 	/* LO calibration setting */
 	PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 
-
 	/* One shot, path A LOK & IQK */
 	PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
 	PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
@@ -4661,7 +4591,6 @@ Exit_IQK:
 	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032fff);
 	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032fff);
 
-
 	/* reload MAC default value */
 	phy_ReloadMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
@@ -5165,7 +5094,6 @@ phy_LCCalibrate92DSW(
 	phy_ReloadLCKSetting(adapter, pHalData->CurrentChannel);
 }
 
-
 static void
 phy_LCCalibrate(
 	struct rtw_adapter *	adapter,
@@ -5179,7 +5107,6 @@ phy_LCCalibrate(
 #endif
 }
 
-
 /* Analog Pre-distortion calibration */
 #define		APK_BB_REG_NUM	8
 #define		APK_CURVE_REG_NUM 4
@@ -5340,7 +5267,6 @@ phy_APCalibrate(
 	for (path = 0; path < pathbound; path++)
 	{
 
-
 		if (path == RF_PATH_A)
 		{
 			/* path A APK */
@@ -5449,7 +5375,6 @@ phy_APCalibrate(
 
 		}
 
-
 		/* MAC settings */
 		phy_MACSettingCalibration(adapter, MAC_REG, MAC_backup);
 
@@ -5486,7 +5411,6 @@ phy_APCalibrate(
 
 				BB_offset += delta_V;
 
-
 				if (BB_offset < 0) {
 					tmpReg = tmpReg & (~BIT15);
 					BB_offset = -BB_offset;
@@ -5516,7 +5440,6 @@ phy_APCalibrate(
 				else
 					tmpReg = PHY_QueryBBReg(adapter, rAPK, 0xF8000000);
 
-
 				i++;
 			}
 			while (tmpReg > apkbound && i < 4);
@@ -5555,7 +5478,6 @@ phy_APCalibrate(
 			APK_result[path][1] = 6;
 	}
 
-
 	for (path = 0; path < pathbound; path++)
 	{
 		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G1_G4, bRFRegOffsetMask,
@@ -5607,7 +5529,6 @@ rtl8192d_PHY_IQCalibrate(
 	bool		is12simular, is13simular, is23simular;
 	bool		bStartContTx = false, bSingleTone = false, bCarrierSuppression = false;
 
-
 #if (MP_DRIVER == 1)
 	bStartContTx = adapter->mppriv.MptCtx.bStartContTx;
 	bSingleTone = adapter->mppriv.MptCtx.bSingleTone;
@@ -5627,7 +5548,6 @@ rtl8192d_PHY_IQCalibrate(
 		return;
 #endif
 
-
 	for (i = 0; i < 8; i++)
 	{
 		result[0][i] = 0;
@@ -5771,7 +5691,6 @@ rtl8192d_PHY_IQCalibrate(
 	}
 }
 
-
 void
 rtl8192d_PHY_LCCalibrate(
 	struct rtw_adapter *	adapter
@@ -5819,7 +5738,6 @@ rtl8192d_PHY_LCCalibrate(
 
 	pHalData->bLCKInProgress = true;
 
-
 	if (IS_92D_SINGLEPHY(pHalData->VersionID))
 	{
 		phy_LCCalibrate(adapter, true);
@@ -5884,7 +5802,6 @@ PHY_UpdateBBRFConfiguration8192D(
 		else if (pregistrypriv->special_rf_path == 2)
 			PHY_SetBBReg(adapter, rCCK0_AFESetting, bMaskByte3, 0x45);
 
-
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
 		{
 			PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
@@ -6145,7 +6062,6 @@ PHY_UpdateBBRFConfiguration8192D(
 		pdmpriv->RegRF3C[eRFPath] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_RXRF_A3, bRFRegOffsetMask);
 	}
 
-
 }
 
 /*  */
@@ -6431,7 +6347,6 @@ rtl8192d_PHY_InitRxSetting(
 #endif
 }
 
-
 void rtl8192d_PHY_ResetIQKResult(struct rtw_adapter *adapter)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
@@ -6478,7 +6393,6 @@ HalChangeCCKStatus8192D(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u8	i;
 
-
 	if (pHalData->BandSet92D != BAND_ON_BOTH)
 	{
 		return;
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
@@ -60,17 +60,14 @@ struct rf_shadow_compare_map {
 };
 /*---------------------------Define Local Constant---------------------------*/
 
-
 /*------------------------Define global variable-----------------------------*/
 /*------------------------Define global variable-----------------------------*/
 
-
 /*------------------------Define local variable------------------------------*/
 /*  2008/11/20 MH For Debug only, RF */
 static	struct rf_shadow_compare_map RF_Shadow[RF6052_MAX_PATH][RF6052_MAX_REG];
 /*------------------------Define local variable------------------------------*/
 
-
 /*-----------------------------------------------------------------------------
  * Function:	RF_ChangeTxPath
  *
@@ -94,7 +91,6 @@ void rtl8192d_RF_ChangeTxPath(	struct rt
 /*  We do not support gain table change inACUT now !!!! Delete later !!! */
 }	/* RF_ChangeTxPath */
 
-
 /*-----------------------------------------------------------------------------
  * Function:    PHY_RF6052SetBandwidth()
  *
@@ -141,7 +137,6 @@ rtl8192d_PHY_RF6052SetBandwidth(
 	}
 }
 
-
 /*-----------------------------------------------------------------------------
  * Function:	PHY_RF6052SetCckTxPower
  *
@@ -362,19 +357,16 @@ static void getTxPowerWriteValByRegulato
 					/*  increase power diff defined by customer. */
 				chnlGroup = 0;
 
-
 				if (index < 2)
 					pwr_diff = pHalData->TxPwrLegacyHtDiff[rf][Channel-1];
 				else if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
 					pwr_diff = pHalData->TxPwrHt20Diff[rf][Channel-1];
 
-
 				if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_40)
 					customer_pwr_limit = pHalData->PwrGroupHT40[rf][Channel-1];
 				else
 					customer_pwr_limit = pHalData->PwrGroupHT20[rf][Channel-1];
 
-
 				if (pwr_diff >= customer_pwr_limit)
 					pwr_diff = 0;
 				else
@@ -595,7 +587,6 @@ phy_RF6052_Config_ParaFile(
 	bool		bTrueBPath = false;/* vivi added this for read parameter from header, 20100908 */
 	u32	MaskforPhySet = 0; /* For 92d PHY cross access, 88c must set value 0. */
 
-
 #ifndef CONFIG_EMBEDDED_FWIMG
 	pszRadioAFile = sz92DRadioAFile;
 	pszRadioBFile = sz92DRadioBFile;
@@ -649,7 +640,6 @@ phy_RF6052_Config_ParaFile(
 		}
 	}
 
-
 	/* 3----------------------------------------------------------------- */
 	/* 3 <2> Initialize RF */
 	/* 3----------------------------------------------------------------- */
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
@@ -45,7 +45,6 @@ static u8 evm_db2percentage(s8 value)
 	return(ret_val);
 }
 
-
 static s32 signal_scale_mapping(struct rtw_adapter *padapter, s32 cur_sig)
 {
 	s32 ret_sig;
@@ -73,7 +72,6 @@ static s32  translate2dbm(u8 signal_stre
 {
 	s32	signal_power; /*  in dBm. */
 
-
 	/*  Translate to dBm (x=0.5y-95). */
 	signal_power = (s32)((signal_strength_idx + 1) >> 1);
 	signal_power -= 95;
@@ -81,7 +79,6 @@ static s32  translate2dbm(u8 signal_stre
 	return signal_power;
 }
 
-
 static void query_rx_phy_status(struct recv_frame_hdr *prframe, struct phy_stat *pphy_stat, bool bPacketMatchBSSID)
 {
 	struct phy_ofdm_rx_status_report_8192cd	*pOfdm_buf;
@@ -98,7 +95,6 @@ static void query_rx_phy_status(struct r
 	s8	rx_snrX;
 	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 
-
 	bcck_rate=(pattrib->mcs_rate<=3? 1:0);
 
 	/*  Record it for next packet processing */
@@ -301,7 +297,6 @@ static void query_rx_phy_status(struct r
 			}
 		}
 
-
 		/*  */
 		/*  (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive) */
 		/*  */
@@ -352,7 +347,6 @@ static void query_rx_phy_status(struct r
 
 	}
 
-
 	/* UI BSS List signal strength(in percentage), make it good looking, from 0~100. */
 	/* It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp(). */
 	if (bcck_rate)
@@ -368,7 +362,6 @@ static void query_rx_phy_status(struct r
 	}
 }
 
-
 static void process_rssi(struct rtw_adapter *padapter,struct recv_frame_hdr *prframe)
 {
 	u32	last_rssi, tmp_val;
@@ -402,7 +395,6 @@ static void process_rssi(struct rtw_adap
 		if (padapter->recvpriv.signal_strength_data.index >= PHY_RSSI_SLID_WIN_MAX)
 			padapter->recvpriv.signal_strength_data.index = 0;
 
-
 		tmp_val = padapter->recvpriv.signal_strength_data.total_val/padapter->recvpriv.signal_strength_data.total_num;
 		padapter->recvpriv.signal_strength= tmp_val;
 		padapter->recvpriv.rssi=(s8)translate2dbm((u8)tmp_val);
@@ -412,7 +404,6 @@ static void process_rssi(struct rtw_adap
 	}
 }/*  Process_UI_RSSI_8192S */
 
-
 static void process_PWDB(struct rtw_adapter *padapter, struct recv_frame_hdr *prframe)
 {
 	int	UndecoratedSmoothedPWDB;
@@ -463,7 +454,6 @@ static void process_PWDB(struct rtw_adap
 	}
 }
 
-
 static void process_link_qual(struct rtw_adapter *padapter,struct recv_frame_hdr *prframe)
 {
 	u32	last_evm=0,  tmpVal;
@@ -523,7 +513,6 @@ static void process_link_qual(struct rtw
 #endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 }/*  Process_UiLinkQuality8192S */
 
-
 static void process_phy_info(struct rtw_adapter *padapter, struct recv_frame_hdr *prframe)
 {
 	struct recv_frame_hdr *precvframe = (struct recv_frame_hdr *)prframe;
@@ -555,7 +544,6 @@ void rtl8192d_translate_rx_signal_stuff(
 		bPacketMatchBSSID = ((!IsFrameTypeCtrl(precvframe->rx_data)) && !(pattrib->icv_err) && !(pattrib->crc_err) &&
 			_rtw_memcmp(get_hdr_bssid(precvframe->rx_data), get_my_bssid(&padapter->mlmeextpriv.mlmext_info.network), ETH_ALEN));
 
-
 		bPacketToSelf = bPacketMatchBSSID &&  (_rtw_memcmp(get_da(precvframe->rx_data), myid(&padapter->eeprompriv), ETH_ALEN));
 
 		bPacketBeacon =bPacketMatchBSSID && (GetFrameSubType(precvframe->rx_data) ==  WIFI_BEACON);
--- a/drivers/staging/rtl8192du/hal/rtl8192du_led.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_led.c
@@ -39,7 +39,6 @@
 /*  LED object. */
 /*  */
 
-
 /*  */
 /*	Prototype of protected function. */
 /*  */
@@ -96,7 +95,6 @@ static void InitLed871x(struct rtw_adapt
 	_init_workitem(&(pLed->BlinkWorkItem), BlinkWorkItemCallback, pLed);
 }
 
-
 /*  */
 /*	Description: */
 /*		DeInitialize an struct LED_871X object. */
@@ -113,7 +111,6 @@ static void DeInitLed871x(struct LED_871
 	ResetLedStatus(pLed);
 }
 
-
 /*  */
 /*	Description: */
 /*		Turn on LED according to LedPin specified. */
@@ -128,7 +125,6 @@ static void SwLedOn(struct rtw_adapter *
 		return;
 	}
 
-
 	switch (pLed->LedPin)
 	{
 		case LED_PIN_GPIO0:
@@ -153,7 +149,6 @@ static void SwLedOn(struct rtw_adapter *
 	pLed->bLedOn = true;
 }
 
-
 /*  */
 /*	Description: */
 /*		Turn off LED according to LedPin specified. */
@@ -167,7 +162,6 @@ static void SwLedOff(struct rtw_adapter
              return;
 	}
 
-
 	switch (pLed->LedPin)
 	{
 		case LED_PIN_GPIO0:
@@ -252,7 +246,6 @@ static void SwLedBlink(struct LED_871X *
 		}
 		break;
 
-
 	default:
 		bStopBlinking = true;
 		break;
@@ -337,7 +330,6 @@ static void SwLedBlink1(struct LED_871X
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
 	}
 
-
 	if (pHalData->CustomerID == RT_CID_DEFAULT)
 	{
 		if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
@@ -756,7 +748,6 @@ static void SwLedBlink3(struct LED_871X
 					if (pLed->bLedOn)
 						SwLedOff(padapter, pLed);
 
-
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
 				pLed->bLedBlinkInProgress = false;
@@ -815,7 +806,6 @@ static void SwLedBlink3(struct LED_871X
 			}
 			break;
 
-
 		default:
 			break;
 	}
@@ -1006,7 +996,6 @@ static void SwLedBlink4(struct LED_871X
 			}
 			break;
 
-
 		default:
 			break;
 	}
@@ -1076,7 +1065,6 @@ static void SwLedBlink5(struct LED_871X
 			}
 			break;
 
-
 		case LED_TXRX_BLINK:
 			pLed->BlinkTimes--;
 			if (pLed->BlinkTimes == 0)
@@ -1149,7 +1137,6 @@ BlinkTimerCallback(
 	_set_workitem(&(pLed->BlinkWorkItem));
 }
 
-
 /*  */
 /*	Description: */
 /*		Callback function of LED BlinkWorkItem. */
@@ -1198,7 +1185,6 @@ static void BlinkWorkItemCallback(struct
 	}
 }
 
-
 /*  */
 /*  Default LED behavior. */
 /*  */
@@ -1314,7 +1300,6 @@ static void SwLedControlMode0(
 		}
 		break;
 
-
 	default:
 		break;
 	}
@@ -1491,7 +1476,6 @@ static void SwLedControlMode1(
 			 }
 			break;
 
-
 		case LED_CTL_STOP_WPS:
 			if (pLed->bLedNoLinkBlinkInProgress == true)
 			{
@@ -1933,7 +1917,6 @@ static void SwLedControlMode3(
 	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 }
 
-
  /* Edimax-Belkin, added by chiyoko, 20090413 */
 static void SwLedControlMode4(
 	struct rtw_adapter				*padapter,
@@ -2263,9 +2246,7 @@ static void SwLedControlMode4(
 	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
 }
 
-
-
- /* Sercomm-Belkin, added by chiyoko, 20090415 */
+/* Sercomm-Belkin, added by chiyoko, 20090415 */
 static void SwLedControlMode5(
 	struct rtw_adapter				*padapter,
 	enum LED_CTL_MODE		LedAction
@@ -2351,7 +2332,6 @@ static void SwLedControlMode5(
 	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
 }
 
-
 /*  */
 /*	Description: */
 /*		Dispatch LED action according to pHalData->LedStrategy. */
@@ -2432,7 +2412,6 @@ void rtl8192du_InitSwLeds(struct rtw_ada
 	InitLed871x(padapter,&(pledpriv->SwLed1), LED_PIN_LED1);
 }
 
-
 /*  */
 /*	Description: */
 /*		DeInitialize all LED_819xUsb objects. */
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -237,7 +237,6 @@ static s32 update_txdesc(struct xmit_fra
 	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
 #endif /* CONFIG_P2P */
 
-
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
 if (padapter->registrypriv.mp_mode == 0)
 {
@@ -283,11 +282,9 @@ if (padapter->registrypriv.mp_mode == 0)
 
 		/* offset 8 */
 
-
 		/* offset 12 */
 		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
 
-
 		/* offset 16 , offset 20 */
 		if (pattrib->qos_en)
 			ptxdesc->txdw4 |= cpu_to_le32(BIT(6));/* QoS */
@@ -355,7 +352,6 @@ if (padapter->registrypriv.mp_mode == 0)
 
 		ptxdesc->txdw1 |= cpu_to_le32((pattrib->raid<< 16) & 0x000f0000);
 
-
 		/* offset 8 */
 #ifdef CONFIG_XMIT_ACK
 		/* CCX-TXRPT ack for xmit mgmt frames. */
@@ -530,7 +526,6 @@ s32 rtw_dump_xframe(struct rtw_adapter *
 
 		rtw_count_tx_stats(padapter, pxmitframe, sz);
 
-
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_write_port, w_sz=%d\n", w_sz));
 
 		mem_addr += w_sz;
@@ -547,7 +542,6 @@ s32 rtw_dump_xframe(struct rtw_adapter *
 	return ret;
 }
 
-
 #ifdef CONFIG_USB_TX_AGGREGATION
 static u32 xmitframe_need_length(struct xmit_frame *pxmitframe)
 {
@@ -678,7 +672,6 @@ s32 rtl8192du_xmitframe_complete(struct
 
 				pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
 
-
 				len = xmitframe_need_length(pxmitframe) + TXDESC_SIZE + ((USB_92D_DUMMY_OFFSET - 1) * PACKET_OFFSET_SZ);
 				if (pbuf + _RND8(len) > aggMaxLength)
 				{
@@ -849,10 +842,8 @@ s32 rtl8192du_xmitframe_complete(struct
 				rtw_os_xmit_complete(padapter, pxmitframe);/* always return ndis_packet after rtw_xmitframe_coalesce */
 			}
 
-
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("xmitframe_complete(): rtw_dump_xframe\n"));
 
-
 			if (res == _SUCCESS)
 			{
 				rtw_dump_xframe(padapter, pxmitframe);
@@ -880,12 +871,10 @@ s32 rtl8192du_xmitframe_complete(struct
 }
 #endif
 
-
 static s32 xmitframe_direct(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
 {
 	s32 res = _SUCCESS;
 
-
 	res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
 	if (res == _SUCCESS) {
 		rtw_dump_xframe(padapter, pxmitframe);
@@ -916,8 +905,6 @@ static s32 pre_xmitframe(struct rtw_adap
 		)
 		goto enqueue;
 
-
-
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
 		goto enqueue;
 
@@ -1054,12 +1041,10 @@ s32 rtl8192du_hostap_mgnt_xmit_entry(str
 
 	/* offset 20 */
 
-
 	/* HW append seq */
 	ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); /*  Hw set sequence number */
 	ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); /* set bit3 to 1. Suugested by TimChen. 2009.12.29. */
 
-
 	rtl8192cu_cal_txdesc_chksum(ptxdesc);
 	/*  ----- end of fill tx desc ----- */
 
@@ -1068,8 +1053,6 @@ s32 rtl8192du_hostap_mgnt_xmit_entry(str
 	pxmitbuf = pxmitbuf + TXDESC_SIZE;
 	memcpy(pxmitbuf, skb->data, len);
 
-
-
 	/*  ----- prepare urb for submit ----- */
 
 	/* translate DMA FIFO addr to pipehandle */
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -27,7 +27,6 @@
 #include <usb_hal.h>
 #include <usb_osintf.h>
 
-
 #if DISABLE_BB_RF
 	#define		HAL_MAC_ENABLE	0
 	#define		HAL_BB_ENABLE		0
@@ -45,7 +44,6 @@
 /*  interrupt in: 4 */
 /*  bult out: 5 (Low) for 3 out_ep */
 
-
 static void
 _OneOutEpMapping(
 	struct hal_data_8192du *pHalData
@@ -64,7 +62,6 @@ _OneOutEpMapping(
 	pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];/* BCN */
 }
 
-
 static void
 _TwoOutEpMapping(
 	struct hal_data_8192du	*pHalData,
@@ -91,7 +88,6 @@ _TwoOutEpMapping(
 	}
 	else {/* typical setting */
 
-
 		/* BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA */
 		/*   1,		1,	0,	0,	0,	0,	0,	0,		0	}; */
 		/* 0:H(end_number=0x02), 1:L (end_number=0x03) */
@@ -109,7 +105,6 @@ _TwoOutEpMapping(
 	}
 }
 
-
 static void _ThreeOutEpMapping(
 	struct hal_data_8192du *pHalData,
 	bool			bWIFICfg
@@ -134,7 +129,6 @@ static void _ThreeOutEpMapping(
 	}
 	else {/* typical setting */
 
-
 		/*	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA */
 		/*   2,		2,	1,	0,	0,	0,	0,	0,		0	}; */
 		/* 0:H(end_number=0x02), 1:N(end_number=0x03), 2:L (end_number=0x05) */
@@ -334,7 +328,6 @@ static u8 _InitPowerOn(struct rtw_adapte
 
 	}while (true);
 
-
 	/* For hardware power on sequence. */
 	/* 0.	RSV_CTRL 0x1C[7:0] = 0x00			unlock ISO/CLK/Power control register */
 	rtw_write8(padapter, REG_RSV_CTRL, 0x0);
@@ -465,7 +458,6 @@ static u16 calc_crc(u8 * pdata,int lengt
 	return CRC;
 }
 
-
 #ifdef CONFIG_WOWLAN
 static int rtw_wowlan_set_pattern(struct rtw_adapter *padapter ,u8* pbuf) {
 	struct pwrctrl_priv *pwrpriv=&padapter->pwrctrlpriv;
@@ -573,8 +565,6 @@ _rtw_wowlan_set_pattern_exit:
 	return res;
 }
 
-
-
 void rtw_wowlan_reload_pattern(struct rtw_adapter *padapter) {
 	struct pwrctrl_priv *pwrpriv=&padapter->pwrctrlpriv;
 	u32 content=0,cmd=0;
@@ -625,12 +615,10 @@ void rtw_wowlan_reload_pattern(struct rt
 		rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 		DBG_8192D("print WOWCAM  offset[4]  =%x\n",rtw_read32(padapter, REG_WKFMCAM_RWD));
 
-
 	}
 }
 #endif /* CONFIG_WOWLAN */
 
-
 /*  */
 /*  */
 /*  LLT R/W/Init function */
@@ -704,7 +692,6 @@ static u8 InitLLTTable(
 	u32		Last_Entry_Of_TxPktBuf = LAST_ENTRY_OF_TX_PKT_BUFFER;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
-
 	if (pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY) {
 		/* for 92du two mac: The page size is different from 92c and 92s */
 		txpktbuf_bndy =TX_PAGE_BOUNDARY_DUAL_MAC;
@@ -802,7 +789,6 @@ _InitInterrupt(
 	rtw_write32(adapter, REG_HIMR, value32);
 }
 
-
 static void
 _InitQueueReservedPage(
 	struct rtw_adapter * adapter
@@ -920,7 +906,6 @@ _InitTxBufferBoundary(
 	rtw_write8(adapter, REG_TDECTRL+1, txpktbuf_bndy);
 }
 
-
 static void
 _InitNormalChipRegPriority(
 	struct rtw_adapter *	adapter,
@@ -984,7 +969,6 @@ _InitNormalChipTwoOutEpPriority(
 	struct registry_priv *pregistrypriv = &adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
 
-
 	u16	valueHi = 0;
 	u16	valueLow = 0;
 
@@ -1143,7 +1127,6 @@ _InitWMACSetting(
 	/*  don't turn on AAP, it will allow all packets to driver */
 	pHalData->ReceiveConfig = APM | AM | AB | CBSSID |CBSSID_BCN | APP_ICV | AMF | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;
 
-
 #if (0 == RTL8192C_RX_PACKET_NO_INCLUDE_CRC)
 	pHalData->ReceiveConfig |= ACRC32;
 #endif
@@ -1212,7 +1195,6 @@ _InitRateFallback(
 	rtw_write32(adapter, REG_RARFRC+4, 0x08070605);
 }
 
-
 static void
 _InitEDCA(
 	struct rtw_adapter * adapter
@@ -1226,7 +1208,6 @@ _InitEDCA(
 	value16 |= DIS_EDCA_CNT_DWN;
 	rtw_write16(adapter, REG_RD_CTRL, value16);
 
-
 	/*  Update SIFS timing.  ?????????? */
 	/* pHalData->SifsTime = 0x0e0e0a0a; */
 	/* rtw_hal_set_hwreg(adapter, HW_VAR_RESP_SIFS,  (pu1Byte)&pHalData->SifsTime); */
@@ -1248,7 +1229,6 @@ _InitEDCA(
 
 	rtw_write32(adapter, REG_BAR_MODE_CTRL, 0x014004);
 
-
 	/*  TXOP */
 	rtw_write32(adapter, REG_EDCA_BE_PARAM, 0x005EA42B);
 	rtw_write32(adapter, REG_EDCA_BK_PARAM, 0x0000A44F);
@@ -1268,7 +1248,6 @@ _InitEDCA(
 	rtw_write8(adapter, REG_ATIMWND, 0x02);
 }
 
-
 static void
 _InitAMPDUAggregation(
 	struct rtw_adapter * adapter
@@ -1326,7 +1305,6 @@ _InitRetryFunction(
 	rtw_write8(adapter, REG_ACKTO, 0x40);
 }
 
-
 static void
 _InitUsbAggregationSetting(
 	struct rtw_adapter * adapter
@@ -1435,7 +1413,6 @@ _InitUsbAggregationSetting(
 #endif
 }
 
-
 static void
 _InitOperationMode(
 	struct rtw_adapter *			adapter
@@ -1570,7 +1547,6 @@ _BeaconFunctionEnable(
 	rtw_write8(adapter, REG_RD_CTRL+1, 0x6F);
 }
 
-
 /*  Set CCK and OFDM Block "ON" */
 static void _BBTurnOnBlock(
 	struct rtw_adapter *		adapter
@@ -1686,7 +1662,6 @@ static u32 rtl8192du_hal_init(struct rtw
 #endif
 	u32 init_start_time = rtw_get_current_time();
 
-
 #ifdef DBG_HAL_INIT_PROFILING
 
 	enum HAL_INIT_STAGES {
@@ -1745,7 +1720,6 @@ static u32 rtl8192du_hal_init(struct rtw
 	#define HAL_INIT_PROFILE_TAG(stage) do {} while (0)
 #endif /* DBG_HAL_INIT_PROFILING */
 
-
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 	padapter->init_adpt_in_progress = true;
 
@@ -1854,7 +1828,6 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INI
 		return status;
 	}
 
-
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOWNLOAD_FW);
 #if ((1 == MP_DRIVER) ||  (0 == FW_PROCESS_VENDOR_CMD))
 
@@ -1917,7 +1890,6 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MAC
 	}
 #endif
 
-
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC01);
 	_InitQueueReservedPage(padapter);
 	_InitTxBufferBoundary(padapter);
@@ -2217,7 +2189,6 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 
 	RT_CLEAR_PS_LEVEL(pwrctrlpriv, RT_RF_OFF_LEVL_HALT_NIC);
 
-
 	if ((pregistrypriv->lowrate_two_xmit) && (pHalData->MacPhyMode92D != DUALMAC_DUALPHY))
 	{
 		/* for Use 2 path Tx to transmit MCS0~7 and legacy mode */
@@ -2254,8 +2225,6 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END
 	}
 	#endif
 
-
-
 #ifdef CONFIG_WOWLAN
 	if (padapter->pwrctrlpriv.wowlan_mode == true)
 		dump_wakup_reason(padapter);
@@ -2273,7 +2242,6 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END
 	return status;
 }
 
-
 static void
 _DisableGPIO(
 	struct rtw_adapter *	adapter
@@ -2304,7 +2272,6 @@ n. LEDCFG 0x4C[15:0] = 0x8080
 	value16 |= ((value8<<4) | 0x0780);
 	rtw_write16(adapter, REG_GPIO_IO_SEL, value16);
 
-
 	/* 3. Disable LED0 & 1 */
 	rtw_write16(adapter, REG_LEDCFG0, 0x8888);
 
@@ -2322,7 +2289,6 @@ _ResetFWDownloadRegister(
 	rtw_write32(adapter, REG_MCUFWDL, value32);
 }
 
-
 static int
 _DisableRF_AFE(
 	struct rtw_adapter *			adapter
@@ -2336,7 +2302,6 @@ _DisableRF_AFE(
 	value8 = APSDOFF;
 	rtw_write8(adapter, REG_APSD_CTRL, value8);
 
-
 #if (RTL8192CU_ASIC_VERIFICATION)
 
 	do
@@ -2463,7 +2428,6 @@ e.	SYS_FUNC_EN 0x02[7:0] = 0x14		reset B
 	value8 |= APSDOFF;
 	rtw_write8(adapter, REG_APSD_CTRL, value8);/* 0x40 */
 
-
 	/* testchip  should not do BB reset if another mac is alive; */
 	value8 = 0 ;
 	value8 |=(FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
@@ -2810,8 +2774,6 @@ static u32 rtl8192du_hal_deinit(struct r
 	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
 	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
 
-
-
 	if (RT_IN_PS_LEVEL(pwrpriv, RT_RF_OFF_LEVL_HALT_NIC))
 	{
 		DBG_8192D("Haltadapter8192DUsb(): Not to haltadapter if HW already halt\n");
@@ -2849,8 +2811,6 @@ static u32 rtl8192du_hal_deinit(struct r
 
 	padapter->bHaltInProgress = false;
 
-
-
 	return _SUCCESS;
  }
 
@@ -2866,8 +2826,6 @@ static unsigned int rtl8192du_inirp_init
 	u32 (*_read_interrupt)(struct intf_hdl *pintfhdl, u32 addr);
 #endif
 
-
-
 	_read_port = pintfhdl->io_ops._read_port;
 
 	status = _SUCCESS;
@@ -2904,8 +2862,6 @@ exit:
 
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("<=== usb_inirp_init\n"));
 
-
-
 	return status;
 }
 
@@ -2915,7 +2871,6 @@ static unsigned int rtl8192du_inirp_dein
 
 	rtw_read_port_cancel(padapter);
 
-
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n <=== usb_rx_deinit\n"));
 
 	return _SUCCESS;
@@ -2966,7 +2921,6 @@ _ReadIDs(
 {
 	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 
-
 	if (false == AutoloadFail) {
 		/*  VID, PID */
 		pHalData->EEPROMVID = le16_to_cpu(*(__le16 *)&PROMContent[EEPROM_VID]);
@@ -3046,7 +3000,6 @@ _ReadMACAddress(
 	DBG_8192D("MAC Address from EFUSE = %pM\n", pEEPROM->mac_addr);
 }
 
-
 static void
 hal_ReadMacPhyModeFromPROM92DU(
 	struct rtw_adapter *	adapter,
@@ -3056,7 +3009,6 @@ hal_ReadMacPhyModeFromPROM92DU(
 	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	u8	MacPhyCrValue = 0;
 
-
 	MacPhyCrValue=PROMContent[EEPROM_ENDPOINT_SETTING];
 	if (MacPhyCrValue & BIT0)
 	{
@@ -3101,8 +3053,6 @@ hal_ReadMacPhyMode_92D(
 #endif /* CONFIG_DUALMAC_CONCURRENT */
 	u8	Mac1EnableValue = 0;
 
-
-
 	if (AutoloadFail==true) {
 		Mac1EnableValue = rtw_read8(adapter,0xFE64);
 		PHY_ReadMacPhyMode92D(adapter, AutoloadFail);
@@ -3160,7 +3110,6 @@ _ReadBoardType(
 	boardType >>= 5;
 }
 
-
 static void
 _ReadLEDSetting(
 	struct rtw_adapter *	adapter,
@@ -3241,11 +3190,9 @@ static void _ReadPROMContent(
 	pEEPROM->EepromOrEfuse		= (eeValue & BOOT_FROM_EEPROM) ? true : false;
 	pEEPROM->bautoload_fail_flag	= (eeValue & EEPROM_EN) ? false : true;
 
-
 	DBG_8192D("Boot from %s, Autoload %s !\n", (pEEPROM->EepromOrEfuse ? "EEPROM" : "EFUSE"),
 				(pEEPROM->bautoload_fail_flag ? "Fail" : "OK"));
 
-
 	if (pEEPROM->bautoload_fail_flag == false) {
 		if (pEEPROM->EepromOrEfuse == true) {
 			/*  Read all Content from EEPROM or EFUSE. */
@@ -3271,11 +3218,9 @@ static void _ReadPROMContent(
 		memcpy((void*)PROMContent, (void*)pEEPROM->efuse_eeprom_data, HWSET_MAX_SIZE);
 	}
 
-
 	_InitadapterVariablesByPROM(adapter, PROMContent, pEEPROM->bautoload_fail_flag);
 }
 
-
 static void
 _InitOtherVariable(
 	struct rtw_adapter *		adapter
@@ -3283,7 +3228,6 @@ _InitOtherVariable(
 {
 	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 
-
 	/*  2009/06/10 MH For 92S 1*1=1R/ 1*2&2*2 use 2R. We default set 1*1 use radio A */
 	/*  So if you want to use radio B. Please modify RF path enable bit for correct signal */
 	/*  strength calculate. */
@@ -3356,7 +3300,6 @@ StopTxBeacon(
 {
 	struct hal_data_8192du *	pHalData = GET_HAL_DATA(adapter);
 
-
 	DBG_8192D("StopTxBeacon\n");
 
 	rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
@@ -3372,7 +3315,6 @@ ResumeTxBeacon(
 {
 	struct hal_data_8192du *	pHalData = GET_HAL_DATA(adapter);
 
-
 	DBG_8192D("ResumeTxBeacon\n");
 
 	rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
@@ -3540,7 +3482,6 @@ static void hw_var_set_opmode(struct rtw
 			rtw_write16(adapter, REG_TBTT_PROHIBIT, 0xff04);
 			rtw_write16(adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);/*  +32767 (~32ms) */
 
-
 		       /* enable BCN1 Function for if2 */
 			/* don't enable update TSF1 for if2 (due to TSF update when beacon/probe rsp are received) */
 			rtw_write8(adapter, REG_BCN_CTRL_1, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
@@ -3728,7 +3669,6 @@ static void hw_var_set_correct_tsf(struc
 	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-
 	tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; /* us */
 
 	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
@@ -3747,7 +3687,6 @@ static void hw_var_set_correct_tsf(struc
 		/* enable related TSF function */
 		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(3));
 
-
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 		/*  Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue! */
 		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
@@ -3796,7 +3735,6 @@ static void hw_var_set_correct_tsf(struc
 #endif	/*  CONFIG_TSF_RESET_OFFLOAD */
 	}
 
-
 	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 	{
 		ResumeTxBeacon(adapter);
@@ -3804,18 +3742,15 @@ static void hw_var_set_correct_tsf(struc
 #endif	/*  CONFIG_CONCURRENT_MODE */
 }
 
-
 static void hw_var_set_mlme_disconnect(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
 #ifdef CONFIG_CONCURRENT_MODE
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
 
-
 	if (check_buddy_mlmeinfo_state(adapter, _HW_STATE_NOLINK_))
 		rtw_write16(adapter, REG_RXFLTMAP2, 0x00);
 
-
 	if (adapter->iface_type == IFACE_PORT1)
 	{
 		int i;
@@ -3825,7 +3760,6 @@ static void hw_var_set_mlme_disconnect(s
 		rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
 		pHalData->RegFwHwTxQCtrl &= (~BIT6);
 
-
 #ifdef CONFIG_BEACON_DISABLE_OFFLOAD
 		u8 reg_bcn_disable_cnt = rtw_read8(adapter, REG_FW_BCN_DIS_CNT);
 		DBG_8192D("%s()-%d: reg_bcn_disable_cnt=%02x\n", __func__, __LINE__, reg_bcn_disable_cnt);
@@ -3887,7 +3821,6 @@ static void hw_var_set_mlme_disconnect(s
 		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
 			set_tx_beacon_cmd(pbuddy_adapter);
 
-
 	}
 	else	/*  (adapter->iface_type == IFACE_PORT1) */
 	{
@@ -3909,7 +3842,6 @@ static void hw_var_set_mlme_sitesurvey(s
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct mlme_priv *pmlmepriv=&(adapter->mlmepriv);
 
-
 #ifdef CONFIG_CONCURRENT_MODE
 	if (adapter->iface_type == IFACE_PORT1)
 		reg_bcn_ctl = REG_BCN_CTRL_1;
@@ -4064,7 +3996,6 @@ static void hw_var_set_mlme_join(struct
 		else
 			rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
 
-
 		if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
 		{
 			/* fixed beacon issue for 8191su........... */
@@ -4072,7 +4003,6 @@ static void hw_var_set_mlme_join(struct
 			RetryLimit = 0x7;
 		}
 
-
 		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
 			check_buddy_fwstate(adapter, _FW_LINKED))
 		{
@@ -4130,7 +4060,6 @@ static void dc_hw_var_mlme_join(struct r
 	struct mlme_priv *pbuddy_mlmepriv;
 	struct mlme_ext_priv *pbuddy_mlmeext;
 
-
 	if ((Buddyadapter !=NULL) &&
 		adapter->DualMacConcurrent == true)
 	{
@@ -4167,8 +4096,6 @@ static void SetHwReg8192DU(struct rtw_ad
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
-
-
 	switch (variable)
 	{
 		case HW_VAR_MEDIA_STATUS:
@@ -4213,7 +4140,6 @@ static void SetHwReg8192DU(struct rtw_ad
 
 					rtw_write8(adapter, REG_BCN_CTRL, 0x12);
 
-
 					/* Set RCR */
 					rtw_write32(adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
 					/* enable to rx data frame */
@@ -4372,7 +4298,6 @@ static void SetHwReg8192DU(struct rtw_ad
 				/* enable related TSF function */
 				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(3));
 
-
 				if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 				{
 					ResumeTxBeacon(adapter);
@@ -5002,15 +4927,12 @@ static void SetHwReg8192DU(struct rtw_ad
 			break;
 	}
 
-
 }
 
 static void GetHwReg8192DU(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
-
-
 	switch (variable)
 	{
 		case HW_VAR_BASIC_RATE:
@@ -5064,7 +4986,6 @@ static void GetHwReg8192DU(struct rtw_ad
 			break;
 	}
 
-
 }
 
 /*  */
@@ -5195,7 +5116,6 @@ static void _update_response_rate(struct
 	rtw_write8(padapter, REG_RRSR, mask&0xff);
 	rtw_write8(padapter,REG_RRSR+1, (mask>>8)&0xff);
 
-
 	/*  Set RTS initial rate */
 	while (mask > 0x1)
 	{
@@ -5306,7 +5226,6 @@ static void UpdateHalRAMask8192DUsb(stru
 #endif
 		mask &=0xffffffff;
 
-
 	init_rate = get_highest_rate_idx(mask)&0x3f;
 
 	if (pHalData->fw_ractrl == true)
@@ -5326,7 +5245,6 @@ static void UpdateHalRAMask8192DUsb(stru
 		rtw_write8(padapter, (REG_INIDATA_RATE_SEL+mac_id), init_rate);
 	}
 
-
 	/* set ra_id */
 	psta->raid = raid;
 	psta->init_rate = init_rate;
@@ -5341,7 +5259,6 @@ static void SetBeaconRelatedRegisters819
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-
 	rtw_write8(padapter, REG_ATIMWND, 0x02);
 
 	rtw_write16(padapter, REG_BCN_INTERVAL, pmlmeinfo->bcn_interval);
@@ -5394,13 +5311,10 @@ static void rtl8192du_init_default_value
 	rtl8192d_PHY_ResetIQKResult(padapter);
 }
 
-
 void rtl8192du_set_hal_ops(struct rtw_adapter * padapter)
 {
 	struct hal_ops	*pHalFunc = &padapter->HalFunc;
 
-
-
 	padapter->HalData = kzalloc(sizeof(struct hal_data_8192du), GFP_KERNEL);
 	if (padapter->HalData == NULL) {
 		DBG_8192D("cant not alloc memory for HAL DATA\n");
@@ -5430,7 +5344,6 @@ void rtl8192du_set_hal_ops(struct rtw_ad
 	pHalFunc->intf_chip_configure = &rtl8192du_interface_configure;
 	pHalFunc->read_adapter_info = &ReadadapterInfo8192DU;
 
-
 	pHalFunc->hal_dm_watchdog = &rtl8192d_HalDmWatchDog;
 
 	pHalFunc->SetHwRegHandler = &SetHwReg8192DU;
@@ -5444,12 +5357,10 @@ void rtl8192du_set_hal_ops(struct rtw_ad
 	pHalFunc->hal_xmit = &rtl8192du_hal_xmit;
 	pHalFunc->mgnt_xmit = &rtl8192du_mgnt_xmit;
 
-
 #ifdef CONFIG_HOSTAPD_MLME
 	pHalFunc->hostap_mgnt_xmit_entry = &rtl8192du_hostap_mgnt_xmit_entry;
 #endif
 
 	rtl8192d_set_hal_ops(pHalFunc);
 
-
 }
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -128,7 +128,6 @@ static struct ieee80211_channel rtw_5ghz
 	CHAN5G(216, 0),
 };
 
-
 void rtw_2g_channels_init(struct ieee80211_channel *channels)
 {
 	memcpy((void*)channels, (void*)rtw_2ghz_channels,
@@ -332,7 +331,6 @@ static int rtw_cfg80211_inform_bss(_adap
 	struct wiphy *wiphy = wdev->wiphy;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-
 	bssinf_len = pnetwork->network.IELength+sizeof (struct rtw_ieee80211_hdr_3addr);
 	if (bssinf_len > MAX_BSSINFO_LEN) {
 		DBG_871X("%s IE Length too long > %d byte\n",__func__,MAX_BSSINFO_LEN);
@@ -352,7 +350,6 @@ static int rtw_cfg80211_inform_bss(_adap
 	notify_interval = le16_to_cpu(*(u16*)rtw_get_beacon_interval_from_ie(pnetwork->network.IEs));
 	notify_capability = le16_to_cpu(*(u16*)rtw_get_capability_from_ie(pnetwork->network.IEs));
 
-
 	notify_ie = pnetwork->network.IEs+_FIXED_IE_LENGTH_;
 	notify_ielen = pnetwork->network.IELength-_FIXED_IE_LENGTH_;
 
@@ -394,7 +391,6 @@ static int rtw_cfg80211_inform_bss(_adap
 	memcpy(pwlanhdr->addr2, pnetwork->network.MacAddress, ETH_ALEN);
 	memcpy(pwlanhdr->addr3, pnetwork->network.MacAddress, ETH_ALEN);
 
-
 	pbuf += sizeof(struct rtw_ieee80211_hdr_3addr);
 	len = sizeof (struct rtw_ieee80211_hdr_3addr);
 
@@ -403,7 +399,6 @@ static int rtw_cfg80211_inform_bss(_adap
 
 	/* ifdef CONFIG_P2P */
 
-
 	bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)buf,
 		len, notify_signal, GFP_ATOMIC);
 	if (unlikely(!bss)) {
@@ -458,7 +453,6 @@ void rtw_cfg80211_indicate_connect(_adap
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 #endif
 
-
 	DBG_8192C("%s(padapter=%p)\n", __func__, padapter);
 
 	if (pwdev->iftype != NL80211_IFTYPE_STATION
@@ -572,7 +566,6 @@ void rtw_cfg80211_indicate_disconnect(_a
 	}
 }
 
-
 #ifdef CONFIG_AP_MODE
 static u8 set_pairwise_key(_adapter *padapter, struct sta_info *psta)
 {
@@ -596,14 +589,12 @@ static u8 set_pairwise_key(_adapter *pad
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);
 
-
 	psetstakey_para->algorithm = (u8)psta->dot118021XPrivacy;
 
 	memcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);
 
 	memcpy(psetstakey_para->key, &psta->dot118021x_UncstKey, 16);
 
-
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
 exit:
@@ -665,7 +656,6 @@ static int set_group_key(_adapter *padap
 	pcmd->rsp = NULL;
 	pcmd->rspsz = 0;
 
-
 	INIT_LIST_HEAD(&pcmd->list);
 
 	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
@@ -746,7 +736,6 @@ static int rtw_cfg80211_ap_set_encryptio
 		goto exit;
 	}
 
-
 	if (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta==NULL))
 	{
 		DBG_8192C("r871x_set_encryption, crypt.alg = WEP\n");
@@ -794,7 +783,6 @@ static int rtw_cfg80211_ap_set_encryptio
 
 	}
 
-
 	if (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) /*  group key */
 	{
 		if (param->u.crypt.set_tx == 0) /* group key */
@@ -989,8 +977,6 @@ static int rtw_cfg80211_set_encryption(s
 	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
 #endif /* CONFIG_P2P */
 
-
-
 	DBG_8192C("%s\n", __func__);
 
 	param->u.crypt.err = 0;
@@ -1063,7 +1049,6 @@ static int rtw_cfg80211_set_encryption(s
 		struct sta_info * psta,*pbcmc_sta;
 		struct sta_priv * pstapriv = &padapter->stapriv;
 
-
 		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true) /* sta mode */
 		{
 			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
@@ -1076,7 +1061,6 @@ static int rtw_cfg80211_set_encryption(s
 				if (strcmp(param->u.crypt.alg, "none") != 0)
 					psta->ieee8021x_blocked = false;
 
-
 				if ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
 						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
 				{
@@ -1149,8 +1133,6 @@ exit:
 
 	DBG_8192C("%s, ret=%d\n", __func__, ret);
 
-
-
 	return ret;
 }
 
@@ -1211,7 +1193,6 @@ static int cfg80211_rtw_add_key(struct w
 
 	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
 
-
 	if (!mac_addr || is_broadcast_ether_addr(mac_addr))
 	{
 		param->u.crypt.set_tx = 0; /* for wpa/wpa2 group key */
@@ -1219,7 +1200,6 @@ static int cfg80211_rtw_add_key(struct w
 		param->u.crypt.set_tx = 1; /* for wpa/wpa2 pairwise key */
 	}
 
-
 	param->u.crypt.idx = key_index;
 
 	if (params->seq_len && params->seq)
@@ -1840,7 +1820,6 @@ static int cfg80211_rtw_scan(struct wiph
 	}
 #endif
 
-
 #ifdef CONFIG_P2P
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 	{
@@ -1854,7 +1833,6 @@ static int cfg80211_rtw_scan(struct wiph
 	}
 #endif /* CONFIG_P2P */
 
-
 	memset(ssid, 0, sizeof(struct ndis_802_11_ssid)*RTW_SSID_SCAN_AMOUNT);
 	/* parsing request ssids, n_ssids */
 	for (i = 0; i < request->n_ssids && i < RTW_SSID_SCAN_AMOUNT; i++) {
@@ -1865,7 +1843,6 @@ static int cfg80211_rtw_scan(struct wiph
 		ssid[i].SsidLength = ssids[i].ssid_len;
 	}
 
-
 	/* parsing channels, n_channels */
 	memset(ch, 0, sizeof(struct rtw_ieee80211_channel)*RTW_CHANNEL_SCAN_AMOUNT);
 	if (request->n_channels == 1)
@@ -1887,7 +1864,6 @@ static int cfg80211_rtw_scan(struct wiph
 	}
 	spin_unlock_bh(&pmlmepriv->lock);
 
-
 	if (_status == false)
 	{
 		ret = -1;
@@ -1930,7 +1906,6 @@ static int rtw_cfg80211_set_wpa_version(
 		return 0;
 	}
 
-
 	if (wpa_version & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))
 	{
 		psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPAPSK;
@@ -1951,7 +1926,6 @@ static int rtw_cfg80211_set_auth_type(st
 {
 	DBG_8192C("%s, nl80211_auth_type=%d\n", __func__, sme_auth_type);
 
-
 	switch (sme_auth_type) {
 	case NL80211_AUTHTYPE_AUTOMATIC:
 
@@ -1972,7 +1946,6 @@ static int rtw_cfg80211_set_auth_type(st
 
 		psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
 
-
 		break;
 	default:
 		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
@@ -1991,7 +1964,6 @@ static int rtw_cfg80211_set_cipher(struc
 
 	DBG_8192C("%s, ucast=%d, cipher=0x%x\n", __func__, ucast, cipher);
 
-
 	if (!cipher) {
 		*profile_cipher = _NO_PRIVACY_;
 		psecuritypriv->ndisencryptstatus = ndisencryptstatus;
@@ -2288,7 +2260,6 @@ static int cfg80211_rtw_connect(struct w
 	DBG_871X("privacy=%d, key=%p, key_len=%d, key_idx=%d\n",
 		sme->privacy, sme->key, sme->key_len, sme->key_idx);
 
-
 	if (wdev_to_priv(padapter->rtw_wdev)->block == true)
 	{
 		ret = -EBUSY;
@@ -2329,18 +2300,15 @@ static int cfg80211_rtw_connect(struct w
 		goto exit;
 	}
 
-
 	memset(&ndis_ssid, 0, sizeof(struct ndis_802_11_ssid));
 	ndis_ssid.SsidLength = sme->ssid_len;
 	memcpy(ndis_ssid.Ssid, sme->ssid, sme->ssid_len);
 
 	DBG_8192C("ssid=%s, len=%zu\n", ndis_ssid.Ssid, sme->ssid_len);
 
-
 	if (sme->bssid)
 		DBG_8192C("bssid=%pM\n", sme->bssid);
 
-
 	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {
 		ret = -EBUSY;
 		DBG_8192C("%s, fw_state=0x%x, goto exit\n", __func__, pmlmepriv->fw_state);
@@ -2381,7 +2349,6 @@ static int cfg80211_rtw_connect(struct w
 				continue;
 		}
 
-
 		if (sme->bssid)
 		{
 			src_bssid = sme->bssid;
@@ -2422,7 +2389,6 @@ static int cfg80211_rtw_connect(struct w
 		goto exit;
 	}
 
-
 	if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == false)
 	{
 		ret = -EPERM;
@@ -2439,7 +2405,6 @@ static int cfg80211_rtw_connect(struct w
 	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
 	psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;
 
-
 	ret = rtw_cfg80211_set_wpa_version(psecuritypriv, sme->crypto.wpa_versions);
 	if (ret < 0)
 		goto exit;
@@ -2537,7 +2502,6 @@ static int cfg80211_rtw_connect(struct w
 		goto exit;
 	}
 
-
 	DBG_8192C("set ssid:dot11AuthAlgrthm=%d, dot11PrivacyAlgrthm=%d, dot118021XGrpPrivacy=%d\n", psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm, psecuritypriv->dot118021XGrpPrivacy);
 
 exit:
@@ -2985,7 +2949,6 @@ dump:
 		pattrib->seqnum = pmlmeext->mgnt_seq;
 		pmlmeext->mgnt_seq++;
 
-
 		pattrib->last_txcmdsz = pattrib->pktlen;
 
 		dump_mgntframe(padapter, pmgntframe);
@@ -2996,7 +2959,6 @@ dump:
 		DBG_8192C("frame_ctl=0x%x\n", frame_ctl & (RTW_IEEE80211_FCTL_FTYPE|RTW_IEEE80211_FCTL_STYPE));
 	}
 
-
 fail:
 
 	dev_kfree_skb(skb);
@@ -3216,14 +3178,12 @@ static int rtw_add_beacon(_adapter *adap
 
 	DBG_8192C("%s beacon_head_len=%zu, beacon_tail_len=%zu\n", __func__, head_len, tail_len);
 
-
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
 	if (head_len<24)
 		return -EINVAL;
 
-
 	pbuf = kzalloc(head_len+tail_len, GFP_KERNEL);
 	if (!pbuf)
 		return -ENOMEM;
@@ -3290,7 +3250,6 @@ static int rtw_add_beacon(_adapter *adap
 		ret = -EINVAL;
 	}
 
-
 	kfree(pbuf);
 
 	return ret;
@@ -3406,7 +3365,6 @@ static int	cfg80211_rtw_del_station(stru
 		return -EINVAL;
 	}
 
-
 	if (!mac)
 	{
 		DBG_8192C("flush all sta, and cam_entry\n");
@@ -3418,7 +3376,6 @@ static int	cfg80211_rtw_del_station(stru
 		return ret;
 	}
 
-
 	DBG_8192C("free sta macaddr = %pM\n", mac);
 
 	if (mac[0] == 0xff && mac[1] == 0xff &&
@@ -3428,7 +3385,6 @@ static int	cfg80211_rtw_del_station(stru
 		return -EINVAL;
 	}
 
-
 	spin_lock_bh(&pstapriv->asoc_list_lock);
 
 	phead = &pstapriv->asoc_list;
@@ -3667,7 +3623,6 @@ void rtw_cfg80211_issue_p2p_provision_re
 	u8 *frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));
 	size_t frame_body_len = len - sizeof(struct rtw_ieee80211_hdr_3addr);
 
-
 	DBG_871X("[%s] In\n", __func__);
 
 	/* prepare for building provision_request frame */
@@ -3702,7 +3657,6 @@ void rtw_cfg80211_issue_p2p_provision_re
 			break;
 	}
 
-
 	if (rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, p2p_ie, &p2p_ielen))
 	{
 
@@ -3711,7 +3665,6 @@ void rtw_cfg80211_issue_p2p_provision_re
 
 	}
 
-
 	/* start to build provision_request frame */
 	memset(wpsie, 0, sizeof(wpsie));
 	memset(p2p_ie, 0, sizeof(p2p_ie));
@@ -3722,7 +3675,6 @@ void rtw_cfg80211_issue_p2p_provision_re
 		return;
 	}
 
-
 	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
@@ -3752,7 +3704,6 @@ void rtw_cfg80211_issue_p2p_provision_re
 	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
-
 	/* build_prov_disc_request_p2p_ie */
 	/*	P2P OUI */
 	p2pielen = 0;
@@ -3781,7 +3732,6 @@ void rtw_cfg80211_issue_p2p_provision_re
 	memcpy(p2p_ie + p2pielen, &capability, 2);
 	p2pielen += 2;
 
-
 	/*	Device Info ATTR */
 	/*	Type: */
 	p2p_ie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
@@ -3796,7 +3746,6 @@ void rtw_cfg80211_issue_p2p_provision_re
 	memcpy(p2p_ie + p2pielen, devinfo_content, devinfo_contentlen);
 	p2pielen += devinfo_contentlen;
 
-
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2p_ie, &p2p_ielen);
 	pattrib->pktlen += p2p_ielen;
 
@@ -3832,7 +3781,6 @@ void rtw_cfg80211_issue_p2p_provision_re
 
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
 
-
 #ifdef CONFIG_WFD
 	wfdielen = build_provdisc_req_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
@@ -3914,14 +3862,11 @@ static s32 cfg80211_rtw_remain_on_channe
 #endif
 	}
 
-
 	rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
 
-
 	if (duration < 400)
 		duration = duration*3;/* extend from exper. */
 
-
 #ifdef	CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter, _FW_LINKED) &&
 		(duration<pwdinfo->ext_listen_interval))
@@ -3965,7 +3910,6 @@ static s32 cfg80211_rtw_remain_on_channe
 		DBG_871X("%s remain_ch:%u not in channel plan!!!!\n", __func__, remain_ch);
 	}
 
-
 	/* call this after other things have been done */
 #ifdef	CONFIG_CONCURRENT_MODE
 	if (ATOMIC_READ(&pwdev_priv->ro_ch_to)==1 ||
@@ -4502,7 +4446,6 @@ static int rtw_cfg80211_set_probe_resp_w
 					DBG_8192C("Got P2P Capability Attr, grp_cap=0x%x, is_GO\n", grp_cap);
 			}
 
-
 			if (is_GO == false)
 			{
 				if (pmlmepriv->p2p_probe_resp_ie)
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -587,8 +587,6 @@ static int wpa_set_encryption(struct net
 	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
 #endif /* CONFIG_P2P */
 
-
-
 	param->u.crypt.err = 0;
 	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
 
@@ -744,8 +742,6 @@ exit:
 
 	kfree(pwep);
 
-
-
 	return ret;
 }
 
@@ -918,8 +914,6 @@ static int rtw_wx_get_name(struct net_de
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("cmd_code =%x\n", info->cmd));
 
-
-
 	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {
 		/* parsing HT_CAP_IE */
 		p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
@@ -955,8 +949,6 @@ static int rtw_wx_get_name(struct net_de
 		snprintf(wrqu->name, IFNAMSIZ, "unassociated");
 	}
 
-
-
 	return 0;
 }
 
@@ -965,11 +957,8 @@ static int rtw_wx_set_freq(struct net_de
 			   union iwreq_data *wrqu, char *extra)
 {
 
-
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+rtw_wx_set_freq\n"));
 
-
-
 	return 0;
 }
 
@@ -1003,7 +992,6 @@ static int rtw_wx_set_mode(struct net_de
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct __queue *queue = &pmlmepriv->scanned_queue;
 
-
 	if (_FAIL == rtw_pwr_wakeup(padapter)) {
 		ret = -EPERM;
 		goto exit;
@@ -1055,8 +1043,6 @@ static int rtw_wx_set_mode(struct net_de
 
 exit:
 
-
-
 	return ret;
 }
 
@@ -1068,8 +1054,6 @@ static int rtw_wx_get_mode(struct net_de
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, (" rtw_wx_get_mode\n"));
 
-
-
 	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 		wrqu->mode = IW_MODE_INFRA;
 	else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
@@ -1080,8 +1064,6 @@ static int rtw_wx_get_mode(struct net_de
 	else
 		wrqu->mode = IW_MODE_AUTO;
 
-
-
 	return 0;
 }
 
@@ -1175,8 +1157,6 @@ static int rtw_wx_get_range(struct net_d
 	u16 val;
 	int i;
 
-
-
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_range. cmd_code =%x\n", info->cmd));
 
 	wrqu->data.length = sizeof(*range);
@@ -1266,8 +1246,6 @@ static int rtw_wx_get_range(struct net_d
 					IW_SCAN_CAPA_CHANNEL|IW_SCAN_CAPA_MODE|IW_SCAN_CAPA_RATE;
 #endif
 
-
-
 	return 0;
 }
 
@@ -1291,7 +1269,6 @@ static int rtw_wx_set_wap(struct net_dev
 	struct	wlan_network	*pnetwork = NULL;
 	enum NDIS_802_11_AUTHENTICATION_MODE	authmode;
 
-
 /*
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type > PRIMARY_IFACE)
@@ -1378,8 +1355,6 @@ static int rtw_wx_set_wap(struct net_dev
 
 exit:
 
-
-
 	return ret;
 }
 
@@ -1398,8 +1373,6 @@ static int rtw_wx_get_wap(struct net_dev
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_wap\n"));
 
-
-
 	if  (((check_fwstate(pmlmepriv, _FW_LINKED)) == true) ||
 			((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) ||
 			((check_fwstate(pmlmepriv, WIFI_AP_STATE)) == true))
@@ -1412,8 +1385,6 @@ static int rtw_wx_get_wap(struct net_dev
 		memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
 	}
 
-
-
 	return 0;
 }
 
@@ -1463,8 +1434,6 @@ static int rtw_wx_set_scan(struct net_de
 #endif /* CONFIG_P2P */
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_set_scan\n"));
 
-
-
 	#ifdef DBG_IOCTL
 	DBG_8192D("DBG_IOCTL %s:%d\n", __func__, __LINE__);
 	#endif
@@ -1640,8 +1609,6 @@ exit:
 	DBG_8192D("DBG_IOCTL %s:%d return %d\n", __func__, __LINE__, ret);
 	#endif
 
-
-
 	return ret;
 }
 
@@ -1667,8 +1634,6 @@ static int rtw_wx_get_scan(struct net_de
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan\n"));
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, (" Start of Query SIOCGIWSCAN .\n"));
 
-
-
 	#ifdef DBG_IOCTL
 	DBG_8192D("DBG_IOCTL %s:%d\n", __func__, __LINE__);
 	#endif
@@ -1761,8 +1726,6 @@ static int rtw_wx_get_scan(struct net_de
 
 exit:
 
-
-
 	#ifdef DBG_IOCTL
 	DBG_8192D("DBG_IOCTL %s:%d return %d\n", __func__, __LINE__, ret);
 	#endif
@@ -1792,8 +1755,6 @@ static int rtw_wx_set_essid(struct net_d
 
 	uint ret = 0, len;
 
-
-
 	#ifdef DBG_IOCTL
 	DBG_8192D("DBG_IOCTL %s:%d\n", __func__, __LINE__);
 	#endif
@@ -1945,8 +1906,6 @@ exit:
 	DBG_8192D("DBG_IOCTL %s:%d return %d\n", __func__, __LINE__, ret);
 	#endif
 
-
-
 	return ret;
 }
 
@@ -1961,8 +1920,6 @@ static int rtw_wx_get_essid(struct net_d
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_essid\n"));
 
-
-
 	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
 	      (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))
 	{
@@ -1982,8 +1939,6 @@ static int rtw_wx_get_essid(struct net_d
 
 exit:
 
-
-
 	return ret;
 }
 
@@ -1999,8 +1954,6 @@ static int rtw_wx_set_rate(struct net_de
 	u32	ratevalue = 0;
 	 u8 mpdatarate[NUMRATES]={11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};
 
-
-
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, (" rtw_wx_set_rate\n"));
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("target_rate = %d, fixed = %d\n", target_rate, fixed));
 
@@ -2071,8 +2024,6 @@ set_rate:
 		ret = -1;
 	}
 
-
-
 	return ret;
 }
 
@@ -2099,8 +2050,6 @@ static int rtw_wx_set_rts(struct net_dev
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-
-
 	if (wrqu->rts.disabled)
 		padapter->registrypriv.rts_thresh = 2347;
 	else {
@@ -2113,8 +2062,6 @@ static int rtw_wx_set_rts(struct net_dev
 
 	DBG_8192D("%s, rts_thresh =%d\n", __func__, padapter->registrypriv.rts_thresh);
 
-
-
 	return 0;
 }
 
@@ -2124,15 +2071,11 @@ static int rtw_wx_get_rts(struct net_dev
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-
-
 	DBG_8192D("%s, rts_thresh =%d\n", __func__, padapter->registrypriv.rts_thresh);
 
 	wrqu->rts.value = padapter->registrypriv.rts_thresh;
 	wrqu->rts.fixed = 0;	/* no auto select */
 
-
-
 	return 0;
 }
 
@@ -2142,8 +2085,6 @@ static int rtw_wx_set_frag(struct net_de
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-
-
 	if (wrqu->frag.disabled)
 		padapter->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;
 	else {
@@ -2156,8 +2097,6 @@ static int rtw_wx_set_frag(struct net_de
 
 	DBG_8192D("%s, frag_len =%d\n", __func__, padapter->xmitpriv.frag_len);
 
-
-
 	return 0;
 }
 
@@ -2167,15 +2106,11 @@ static int rtw_wx_get_frag(struct net_de
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-
-
 	DBG_8192D("%s, frag_len =%d\n", __func__, padapter->xmitpriv.frag_len);
 
 	wrqu->frag.value = padapter->xmitpriv.frag_len;
 	wrqu->frag.fixed = 0;	/* no auto select */
 
-
-
 	return 0;
 }
 
@@ -2208,8 +2143,6 @@ static int rtw_wx_set_enc(struct net_dev
 
 	key = erq->flags & IW_ENCODE_INDEX;
 
-
-
 	if (erq->flags & IW_ENCODE_DISABLED)
 	{
 		DBG_8192D("EncryptionDisabled\n");
@@ -2321,8 +2254,6 @@ static int rtw_wx_set_enc(struct net_dev
 
 exit:
 
-
-
 	return ret;
 }
 
@@ -2335,8 +2266,6 @@ static int rtw_wx_get_enc(struct net_dev
 	struct iw_point *erq = &(wrqu->encoding);
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 
-
-
 	if (check_fwstate(pmlmepriv, _FW_LINKED) != true)
 	{
 		 if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != true)
@@ -2413,8 +2342,6 @@ static int rtw_wx_get_enc(struct net_dev
 
 	}
 
-
-
 	return ret;
 }
 
@@ -5629,7 +5556,6 @@ static int rtw_dbg_port(struct net_devic
 #endif
 									DBG_8192D("dot118021XPrivacy = 0x%x\n", psta->dot118021XPrivacy);
 
-
 									for (j = 0;j<16;j++)
 									{
 										preorder_ctrl = &psta->recvreorder_ctrl[j];
@@ -5909,7 +5835,6 @@ static int wpa_set_param(struct net_devi
 
 	default:
 
-
 		ret = -EOPNOTSUPP;
 
 		break;
--- a/drivers/staging/rtl8192du/os_dep/mlme_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/mlme_linux.c
@@ -14,7 +14,6 @@
  *
  ******************************************************************************/
 
-
 #define _MLME_OSDEP_C_
 
 #include <drv_conf.h>
@@ -28,14 +27,12 @@ void rtw_join_timeout_handler (void *Fun
 	_rtw_join_timeout_handler(adapter);
 }
 
-
 void _rtw_scan_timeout_handler (void *FunctionContext)
 {
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
 	rtw_scan_timeout_handler(adapter);
 }
 
-
 static void _dynamic_check_timer_handlder (void *FunctionContext)
 {
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
@@ -53,7 +50,6 @@ void _rtw_set_scan_deny_timer_hdl(void *
 }
 #endif
 
-
 void rtw_init_mlme_timer(struct rtw_adapter *padapter)
 {
 	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -71,8 +67,6 @@ void rtw_init_mlme_timer(struct rtw_adap
 void rtw_os_indicate_connect(struct rtw_adapter *adapter)
 {
 
-
-
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_cfg80211_indicate_connect(adapter);
 #endif /* CONFIG_IOCTL_CFG80211 */
@@ -83,7 +77,6 @@ void rtw_os_indicate_connect(struct rtw_
 	if (adapter->pid[2] !=0)
 		rtw_signal_process(adapter->pid[2], SIGALRM);
 
-
 }
 
 void rtw_os_indicate_scan_done(struct rtw_adapter *padapter, bool aborted)
@@ -149,8 +142,6 @@ void rtw_reset_securitypriv(struct rtw_a
 void rtw_os_indicate_disconnect(struct rtw_adapter *adapter)
 {
 
-
-
 	netif_carrier_off(adapter->pnetdev); /*  Do it first for tx broadcast pkt after disconnection issue! */
 
 #ifdef CONFIG_IOCTL_CFG80211
@@ -161,7 +152,6 @@ void rtw_os_indicate_disconnect(struct r
 
 	 rtw_reset_securitypriv(adapter);
 
-
 }
 
 void rtw_report_sec_ie(struct rtw_adapter *adapter,u8 authmode,u8 *sec_ie)
@@ -170,13 +160,10 @@ void rtw_report_sec_ie(struct rtw_adapte
 	u8	*buff,*p,i;
 	union iwreq_data wrqu;
 
-
-
 	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+rtw_report_sec_ie, authmode=%d\n", authmode));
 
 	buff = NULL;
-	if (authmode==_WPA_IE_ID_)
-	{
+	if (authmode==_WPA_IE_ID_) {
 		RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("rtw_report_sec_ie, authmode=%d\n", authmode));
 
 		buff = kmalloc(IW_CUSTOM_MAX, GFP_KERNEL);
@@ -208,7 +195,6 @@ void rtw_report_sec_ie(struct rtw_adapte
 
 	}
 
-
 }
 
 static void _survey_timer_hdl (void *FunctionContext)
@@ -274,7 +260,6 @@ void rtw_indicate_sta_assoc_event(struct
 	if (pstapriv->sta_aid[psta->aid - 1] != psta)
 		return;
 
-
 	wrqu.addr.sa_family = ARPHRD_ETHER;
 
 	memcpy(wrqu.addr.sa_data, psta->hwaddr, ETH_ALEN);
@@ -298,7 +283,6 @@ void rtw_indicate_sta_disassoc_event(str
 	if (pstapriv->sta_aid[psta->aid - 1] != psta)
 		return;
 
-
 	wrqu.addr.sa_family = ARPHRD_ETHER;
 
 	memcpy(wrqu.addr.sa_data, psta->hwaddr, ETH_ALEN);
@@ -308,7 +292,6 @@ void rtw_indicate_sta_disassoc_event(str
 	wireless_send_event(padapter->pnetdev, IWEVEXPIRED, &wrqu, NULL);
 }
 
-
 #ifdef CONFIG_HOSTAPD_MLME
 
 static int mgnt_xmit_entry(struct sk_buff *skb, struct net_device *pnetdev)
@@ -325,7 +308,6 @@ static int mgnt_netdev_open(struct net_d
 
 	DBG_8192D("mgnt_netdev_open: MAC Address:%pM\n", pnetdev->dev_addr);
 
-
 	init_usb_anchor(&phostapdpriv->anchored);
 
 	if (!netif_queue_stopped(pnetdev))
@@ -333,7 +315,6 @@ static int mgnt_netdev_open(struct net_d
 	else
 		netif_wake_queue(pnetdev);
 
-
 	netif_carrier_on(pnetdev);
 
 	return 0;
@@ -351,7 +332,6 @@ static int mgnt_netdev_close(struct net_
 	if (!rtw_netif_queue_stopped(pnetdev))
 		rtw_netif_stop_queue(pnetdev);
 
-
 	return 0;
 }
 
@@ -375,13 +355,11 @@ int hostapd_mode_init(struct rtw_adapter
 
        ether_setup(pnetdev);
 
-
 	phostapdpriv = rtw_netdev_priv(pnetdev);
 	phostapdpriv->pmgnt_netdev = pnetdev;
 	phostapdpriv->padapter= padapter;
 	padapter->phostapdpriv = phostapdpriv;
 
-
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
 
 	DBG_8192D("register rtl871x_mgnt_netdev_ops to netdev_ops\n");
@@ -406,7 +384,6 @@ int hostapd_mode_init(struct rtw_adapter
 	if (dev_alloc_name(pnetdev,"mgnt.wlan%d") < 0)
 		DBG_8192D("hostapd_mode_init(): dev_alloc_name, fail!\n");
 
-
 	mac[0]=0x00;
 	mac[1]=0xe0;
 	mac[2]=0x4c;
@@ -416,10 +393,8 @@ int hostapd_mode_init(struct rtw_adapter
 
 	memcpy(pnetdev->dev_addr, mac, ETH_ALEN);
 
-
 	netif_carrier_off(pnetdev);
 
-
 	/* Tell the network stack we exist */
 	if (register_netdev(pnetdev) != 0)
 	{
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -40,7 +40,6 @@ static int rtw_chip_version = 0x00;
 static int rtw_rfintfs = HWPI;
 static int rtw_lbkmode = 0;/* RTL8712_AIR_TRX; */
 
-
 static int rtw_network_mode = NDIS802_11IBSS;
 static int rtw_channel = 1;/* ad-hoc support requirement */
 static int rtw_wireless_mode = WIRELESS_11BG_24N;
@@ -191,7 +190,6 @@ module_param(rtw_special_rf_path, int, 0
 
 module_param(rtw_antdiv_cfg, int, 0644);
 
-
 module_param(rtw_enusbss, int, 0644);
 module_param(rtw_hwpdn_mode, int, 0644);
 module_param(rtw_hwpwrp_detect, int, 0644);
@@ -296,8 +294,6 @@ void rtw_proc_init_one(struct net_device
 		entry->write_proc = proc_set_log_level;
 	}
 
-
-
 	if (padapter->dir_dev == NULL) {
 		padapter->dir_dev = create_proc_entry(dev->name,
 					  S_IFDIR | S_IRUGO | S_IXUGO,
@@ -342,7 +338,6 @@ void rtw_proc_init_one(struct net_device
 	}
 	entry->write_proc = proc_set_read_reg;
 
-
 	entry = create_proc_read_entry("fwstate", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_fwstate, dev);
 	if (!entry) {
@@ -350,7 +345,6 @@ void rtw_proc_init_one(struct net_device
 		return;
 	}
 
-
 	entry = create_proc_read_entry("sec_info", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_sec_info, dev);
 	if (!entry) {
@@ -358,7 +352,6 @@ void rtw_proc_init_one(struct net_device
 		return;
 	}
 
-
 	entry = create_proc_read_entry("mlmext_state", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_mlmext_state, dev);
 	if (!entry) {
@@ -366,7 +359,6 @@ void rtw_proc_init_one(struct net_device
 		return;
 	}
 
-
 	entry = create_proc_read_entry("qos_option", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_qos_option, dev);
 	if (!entry) {
@@ -541,7 +533,6 @@ void rtw_proc_init_one(struct net_device
 	}
 	entry->write_proc = proc_set_rx_stbc;
 
-
 	entry = create_proc_read_entry("path_rssi", S_IFREG | S_IRUGO,
 					dir_dev, proc_get_two_path_rssi, dev);
 
@@ -662,8 +653,6 @@ static uint loadparam(struct rtw_adapter
 	uint status = _SUCCESS;
 	struct registry_priv  *registry_par = &padapter->registrypriv;
 
-
-
 	registry_par->chip_version = (u8)rtw_chip_version;
 	registry_par->rfintfs = (u8)rtw_rfintfs;
 	registry_par->lbkmode = (u8)rtw_lbkmode;
@@ -719,7 +708,6 @@ static uint loadparam(struct rtw_adapter
 	registry_par->rf_config = (u8)rtw_rf_config;
 	registry_par->low_power = (u8)rtw_low_power;
 
-
 	registry_par->wifi_spec = (u8)rtw_wifi_spec;
 	registry_par->special_rf_path = (u8)rtw_special_rf_path;
 	registry_par->channel_plan = (u8)rtw_channel_plan;
@@ -771,8 +759,6 @@ static uint loadparam(struct rtw_adapter
 	registry_par->ext_iface_num = (u8)rtw_ext_iface_num;
 #endif /* CONFIG_MULTI_VIR_IFACES */
 
-
-
 	return status;
 }
 
@@ -991,7 +977,6 @@ struct net_device *rtw_init_netdev(struc
 	pnetdev->do_ioctl = rtw_ioctl;
 #endif
 
-
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
 	pnetdev->features |= NETIF_F_IP_CSUM;
 #endif
@@ -1035,7 +1020,6 @@ u32 rtw_start_drv_threads(struct rtw_ada
 			_rtw_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema); /* wait for cmd_thread to run */
 	}
 
-
 #ifdef CONFIG_EVENT_THREAD_MODE
 	padapter->evtThread = kthread_run(event_thread, padapter, "RTW_EVENT_THREAD");
 	if (IS_ERR(padapter->evtThread))
@@ -1098,11 +1082,8 @@ u8 rtw_init_default_value(struct rtw_ada
 	pxmitpriv->vcs_type = pregistrypriv->vcs_type;
 	pxmitpriv->frag_len = pregistrypriv->frag_thresh;
 
-
-
 	/* recv_priv */
 
-
 	/* mlme_priv */
 	pmlmepriv->scan_interval = SCAN_INTERVAL;/*  30*2 sec = 60sec */
 	pmlmepriv->scan_mode = SCAN_ACTIVE;
@@ -1130,15 +1111,12 @@ u8 rtw_init_default_value(struct rtw_ada
 	psecuritypriv->ndisauthtype = NDIS802_11AUTHMODEOPEN;
 	psecuritypriv->ndisencryptstatus = NDIS802_11WEPDISABLED;
 
-
 	/* pwrctrl_priv */
 
-
 	/* registry_priv */
 	rtw_init_registrypriv_dev_network(padapter);
 	rtw_update_registrypriv_dev_network(padapter);
 
-
 	/* hal_priv */
 	rtw_hal_def_value_init(padapter);
 
@@ -1198,14 +1176,11 @@ u8 rtw_reset_drv_sw(struct rtw_adapter *
 	return ret8;
 }
 
-
 u8 rtw_init_drv_sw(struct rtw_adapter *padapter)
 {
 
 	u8	ret8 = _SUCCESS;
 
-
-
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_init_drv_sw\n"));
 
 	if ((rtw_init_cmd_priv(&padapter->cmdpriv)) == _FAIL)
@@ -1224,7 +1199,6 @@ u8 rtw_init_drv_sw(struct rtw_adapter *p
 		goto exit;
 	}
 
-
 	if (rtw_init_mlme_priv(padapter) == _FAIL)
 	{
 		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init mlme_priv\n"));
@@ -1317,8 +1291,6 @@ exit:
 
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-rtw_init_drv_sw\n"));
 
-
-
 	return ret8;
 }
 
@@ -1365,7 +1337,6 @@ u8 rtw_free_drv_sw(struct rtw_adapter *p
 {
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("==>rtw_free_drv_sw"));
 
-
 	/* we can call rtw_p2p_enable here, but: */
 	/*  1. rtw_p2p_enable may have IO operation */
 	/*  2. rtw_p2p_enable is bundled with wext interface */
@@ -1385,7 +1356,6 @@ u8 rtw_free_drv_sw(struct rtw_adapter *p
 	}
 	#endif
 
-
 #ifdef CONFIG_BR_EXT
 	_rtw_spinlock_free(&padapter->br_ext_lock);
 #endif	/*  CONFIG_BR_EXT */
@@ -1496,7 +1466,6 @@ int _netdev_vir_if_open(struct net_devic
 	else
 		rtw_netif_wake_queue(pnetdev);
 
-
 	DBG_8192D(FUNC_NDEV_FMT" exit\n", FUNC_NDEV_ARG(pnetdev));
 	return 0;
 
@@ -1599,7 +1568,6 @@ _adapter *rtw_drv_add_vir_if (struct rtw
 	padapter->net_closed = true;
 	padapter->hw_init_completed = false;
 
-
 	/* set adapter_type/iface type */
 	padapter->isprimary = false;
 	padapter->adapter_type = MAX_ADAPTER;
@@ -1644,12 +1612,10 @@ _adapter *rtw_drv_add_vir_if (struct rtw
 	/* step usb endpoint mapping */
 	rtw_hal_chip_configure(padapter);
 
-
 	/* init drv data */
 	if (rtw_init_drv_sw(padapter)!= _SUCCESS)
 		goto error_rtw_drv_add_iface;
 
-
 	/*  alloc dev name after got efuse data. */
 	if (name == NULL)
 		name = padapter->registrypriv.if2name;
@@ -1680,7 +1646,6 @@ _adapter *rtw_drv_add_vir_if (struct rtw
 
 	memcpy(pnetdev->dev_addr, mac, ETH_ALEN);
 
-
 	padapter->dir_dev = NULL;
 
 	/* Tell the network stack we exist */
@@ -1696,7 +1661,6 @@ _adapter *rtw_drv_add_vir_if (struct rtw
 
 	return padapter;
 
-
 error_rtw_drv_add_iface:
 
 	if (padapter)
@@ -1837,26 +1801,17 @@ static int _netdev_if2_open(struct net_d
 
 		rtw_hal_set_hwreg(padapter, HW_VAR_DM_INIT_PWDB, NULL);
 
-
-
 		if (rtw_start_drv_threads(padapter) == _FAIL)
-		{
 			goto netdev_if2_open_error;
-		}
-
 
 		if (padapter->intf_start)
-		{
 			padapter->intf_start(padapter);
-		}
-
 
 		padapter->hw_init_completed = true;
 
 		padapter->dir_dev = NULL;
 		rtw_proc_init_one(pnetdev);
 
-
 #ifdef CONFIG_IOCTL_CFG80211
 		rtw_cfg80211_init_wiphy(padapter);
 #endif
@@ -2016,12 +1971,10 @@ struct rtw_adapter *rtw_drv_if2_init(str
 	/* step usb endpoint mapping */
 	rtw_hal_chip_configure(padapter);
 
-
 	/* init drv data */
 	if (rtw_init_drv_sw(padapter)!= _SUCCESS)
 		goto error_rtw_drv_if2_init;
 
-
 	/*  alloc dev name after got efuse data. */
 	if (name == NULL)
 		name = padapter->registrypriv.if2name;
@@ -2095,7 +2048,6 @@ void rtw_drv_if2_free(struct rtw_adapter
 	rtw_wdev_free(padapter->rtw_wdev);
 #endif /* CONFIG_IOCTL_CFG80211 */
 
-
 	rtw_free_drv_sw(padapter);
 
 	rtw_free_netdev(pnetdev);
@@ -2217,7 +2169,6 @@ int _netdev_open(struct net_device *pnet
 
 		DBG_8192D("MAC Address = %pM\n", pnetdev->dev_addr);
 
-
 		status = rtw_start_drv_threads(padapter);
 		if (status == _FAIL)
 		{
@@ -2225,14 +2176,12 @@ int _netdev_open(struct net_device *pnet
 			goto netdev_open_error;
 		}
 
-
 		if (init_hw_mlme_ext(padapter) == _FAIL)
 		{
 			RT_TRACE(_module_os_intfs_c_, _drv_err_, ("can't init mlme_ext_priv\n"));
 			goto netdev_open_error;
 		}
 
-
 #ifdef CONFIG_DRVEXT_MODULE
 		init_drvext(padapter);
 #endif
@@ -2314,7 +2263,6 @@ static int  ips_netdrv_open(struct rtw_a
 	padapter->net_closed = false;
 	DBG_8192D("===> %s.........\n", __func__);
 
-
 	padapter->bDriverStopped = false;
 	padapter->bSurpriseRemoved = false;
 	padapter->bCardDisableWOHSM = false;
@@ -2342,7 +2290,6 @@ netdev_open_error:
 	return _FAIL;
 }
 
-
 int rtw_ips_pwr_up(struct rtw_adapter *padapter)
 {
 	int result;
--- a/drivers/staging/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8192du/os_dep/osdep_service.c
@@ -14,7 +14,6 @@
  *
  ******************************************************************************/
 
-
 #define _OSDEP_SERVICE_C_
 
 #include <drv_conf.h>
@@ -180,7 +179,6 @@ u32	  _rtw_queue_empty(struct __queue *p
 	return (rtw_is_list_empty(&(pqueue->queue)));
 }
 
-
 u32 rtw_end_of_queue_search(struct list_head *head, struct list_head *plist)
 {
 	if (head == plist)
@@ -189,7 +187,6 @@ u32 rtw_end_of_queue_search(struct list_
 		return false;
 }
 
-
 u32	rtw_get_current_time(void)
 {
 	return jiffies;
@@ -319,7 +316,6 @@ inline void rtw_unlock_suspend(void)
 	#endif
 }
 
-
 inline void ATOMIC_SET(ATOMIC_T *v, int i)
 {
 	atomic_set(v,i);
@@ -769,7 +765,6 @@ keep_ori:
 		kfree(ori);
 }
 
-
 /**
  * rtw_cbuf_full - test if cbuf is full
  * @cbuf: pointer of struct rtw_cbuf
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -50,7 +50,6 @@ void rtw_os_recv_resource_free(struct re
 {
 }
 
-
 /* alloc os related resource in struct recv_buf */
 int rtw_os_recvbuf_resource_alloc(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
 {
@@ -110,7 +109,6 @@ int rtw_os_recvbuf_resource_free(struct
 	if (precvbuf->pskb)
 		dev_kfree_skb_any(precvbuf->pskb);
 
-
 	return ret;
 }
 
@@ -201,7 +199,6 @@ void rtw_hostapd_mlme_rx(struct rtw_adap
 	skb->pkt_type = PACKET_OTHERHOST;
 	skb->protocol = __constant_htons(0x0003); /*ETH_P_80211_RAW*/
 
-
 	skb_reset_mac_header(skb);
 
        memset(skb->cb, 0, sizeof(skb->cb));
@@ -222,8 +219,6 @@ int rtw_recv_indicatepkt(struct rtw_adap
 	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
 #endif
 
-
-
 	precvpriv = &(padapter->recvpriv);
 	pfree_recv_queue = &(precvpriv->free_recv_queue);
 
@@ -291,7 +286,6 @@ int rtw_recv_indicatepkt(struct rtw_adap
 					goto _recv_indicatepkt_end;
 			}
 
-
 		}
 	}
 
@@ -320,8 +314,6 @@ _recv_indicatepkt_end:
 
 	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n rtw_recv_indicatepkt :after netif_rx!!!!\n"));
 
-
-
         return _SUCCESS;
 
 _recv_indicatepkt_drop:
@@ -329,7 +321,6 @@ _recv_indicatepkt_drop:
 	 /* enqueue back to free_recv_queue */
 	 rtw_free_recvframe(precv_frame, pfree_recv_queue);
 
-
 	 return _FAIL;
 }
 
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -107,7 +107,6 @@ struct android_wifi_priv_cmd {
  */
 static int g_wifi_on = true;
 
-
 #ifdef PNO_SUPPORT
 static int wl_android_set_pno_setup(struct net_device *dev, char *command, int total_len)
 {
@@ -540,7 +539,6 @@ exit:
 	return ret;
 }
 
-
 /**
  * Functions for Android WiFi card detection
  */
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -31,7 +31,6 @@ static int rtw_suspend(struct usb_interf
 static int rtw_resume(struct usb_interface *intf);
 int rtw_resume_process(struct rtw_adapter *padapter);
 
-
 static int rtw_drv_init(struct usb_interface *pusb_intf,const struct usb_device_id *pdid);
 static void rtw_dev_remove(struct usb_interface *pusb_intf);
 
@@ -252,7 +251,6 @@ static u8 rtw_init_intf_priv(struct dvob
 	_rtw_mutex_init(&dvobj->usb_vendor_req_mutex);
 	#endif
 
-
 	#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
 	dvobj->usb_alloc_vendor_req_buf = kzalloc(MAX_USB_IO_CTL_SIZE, GFP_KERNEL);
 	if (dvobj->usb_alloc_vendor_req_buf == NULL) {
@@ -297,8 +295,6 @@ static struct dvobj_priv *usb_dvobj_init
 	struct usb_host_endpoint		*phost_endp;
 	struct usb_endpoint_descriptor	*pendp_desc;
 
-
-
 	pdvobjpriv = (struct dvobj_priv*)kzalloc(sizeof(*pdvobjpriv), GFP_KERNEL);
 	if (!pdvobjpriv)
 		goto exit;
@@ -308,7 +304,6 @@ static struct dvobj_priv *usb_dvobj_init
 	_rtw_mutex_init(&pdvobjpriv->setch_mutex);
 	_rtw_mutex_init(&pdvobjpriv->setbw_mutex);
 
-
 	pdvobjpriv->pusbintf = usb_intf ;
 	pusbd = pdvobjpriv->pusbdev = interface_to_usbdev(usb_intf);
 	usb_set_intfdata(usb_intf, pdvobjpriv);
@@ -395,8 +390,6 @@ static void usb_dvobj_deinit(struct usb_
 {
 	struct dvobj_priv *dvobj = usb_get_intfdata(usb_intf);
 
-
-
 	usb_set_intfdata(usb_intf, NULL);
 	if (dvobj) {
 		/* Modify condition for 92DU DMDP 2010.11.18, by Thomas */
@@ -410,7 +403,6 @@ static void usb_dvobj_deinit(struct usb_
 
 	usb_put_dev(interface_to_usbdev(usb_intf));
 
-
 }
 
 static void decide_chip_type_by_usb_device_id(struct rtw_adapter *padapter, const struct usb_device_id *pdid)
@@ -478,7 +470,6 @@ static void rtw_dev_unload(struct rtw_ad
 		if (!padapter->pwrctrlpriv.bInternalAutoSuspend)
 		rtw_stop_drv_threads(padapter);
 
-
 		/* s5. */
 		if (padapter->bSurpriseRemoved == false)
 		{
@@ -541,8 +532,6 @@ int rtw_hw_suspend(struct rtw_adapter *p
 	struct usb_interface *pusb_intf = adapter_to_dvobj(padapter)->pusbintf;
 	struct net_device *pnetdev = padapter->pnetdev;
 
-
-
 	if ((!padapter->bup) || (padapter->bDriverStopped)||(padapter->bSurpriseRemoved))
 	{
 		DBG_8192D("padapter->bup=%d bDriverStopped=%d bSurpriseRemoved = %d\n",
@@ -602,7 +591,6 @@ int rtw_hw_suspend(struct rtw_adapter *p
 	else
 		goto error_exit;
 
-
 	return 0;
 
 error_exit:
@@ -616,8 +604,6 @@ int rtw_hw_resume(struct rtw_adapter *pa
 	struct usb_interface *pusb_intf = adapter_to_dvobj(padapter)->pusbintf;
 	struct net_device *pnetdev = padapter->pnetdev;
 
-
-
 	if (padapter)/* system resume */
 	{
 		DBG_8192D("==> rtw_hw_resume\n");
@@ -652,8 +638,6 @@ int rtw_hw_resume(struct rtw_adapter *pa
 		goto error_exit;
 	}
 
-
-
 	return 0;
 error_exit:
 	DBG_8192D("%s, Open net dev failed\n",__func__);
@@ -675,7 +659,6 @@ static int rtw_suspend(struct usb_interf
 	int ret = 0;
 	u32 start_time = rtw_get_current_time();
 
-
 	DBG_8192D("==> %s (%s:%d)\n",__func__, current->comm, current->pid);
 
 	if ((!padapter->bup) || (padapter->bDriverStopped)||(padapter->bSurpriseRemoved))
@@ -761,7 +744,6 @@ exit:
 	DBG_8192D("<===  %s return %d.............. in %dms\n", __func__
 		, ret, rtw_get_passing_time_ms(start_time));
 
-
 	return ret;
 }
 
@@ -802,7 +784,6 @@ int rtw_resume_process(struct rtw_adapte
 	int ret = -1;
 	u32 start_time = rtw_get_current_time();
 
-
 	DBG_8192D("==> %s (%s:%d)\n",__func__, current->comm, current->pid);
 
 	if (padapter) {
@@ -881,8 +862,6 @@ exit:
 	DBG_8192D("<===  %s return %d.............. in %dms\n", __func__
 		, ret, rtw_get_passing_time_ms(start_time));
 
-
-
 	return ret;
 }
 
@@ -929,7 +908,6 @@ int autoresume_enter(struct rtw_adapter*
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
 
-
 	DBG_8192D("====> autoresume_enter\n");
 
 	if (rf_off == pwrpriv->rf_pwrstate)
@@ -1144,7 +1122,6 @@ static void rtw_usb_if1_deinit(struct rt
 	if (check_fwstate(pmlmepriv, _FW_LINKED))
 		rtw_disassoc_cmd(if1, 0, false);
 
-
 #ifdef CONFIG_AP_MODE
 	free_mlme_ap_info(if1);
 	#ifdef CONFIG_HOSTAPD_MLME
@@ -1202,7 +1179,6 @@ static int rtw_drv_init(struct usb_inter
 
 	RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("+rtw_drv_init\n"));
 
-
 	/* step 0. */
 	process_spec_devid(did);
 
@@ -1259,8 +1235,6 @@ static void rtw_dev_remove(struct usb_in
 	struct dvobj_priv *dvobj = usb_get_intfdata(pusb_intf);
 	struct rtw_adapter *padapter = dvobj->if1;
 
-
-
 	DBG_8192D("+rtw_dev_remove\n");
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+dev_remove()\n"));
 
@@ -1332,7 +1306,6 @@ static void __exit rtw_drv_halt(void)
 	DBG_8192D("-rtw_drv_halt\n");
 }
 
-
 module_init(rtw_drv_entry);
 module_exit(rtw_drv_halt);
 
--- a/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
@@ -42,7 +42,6 @@ static int _usbctrl_vendorreq_async_writ
 		struct usb_ctrlrequest dr;
 	} *buf;
 
-
 	if (requesttype == VENDOR_READ) {
 		pipe = usb_rcvctrlpipe(udev, 0);/* read_in */
 		reqtype =  REALTEK_USB_VENQT_READ;
@@ -117,11 +116,9 @@ int usb_async_write8(struct intf_hdl *pi
 	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
 	struct usb_device *udev=pdvobjpriv->pusbdev;
 
-
 	data = val;
 	ret = usb_write_async(udev, addr, &data, 1);
 
-
 	return ret;
 }
 
@@ -132,11 +129,9 @@ int usb_async_write16(struct intf_hdl *p
 	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
 	struct usb_device *udev=pdvobjpriv->pusbdev;
 
-
 	data = val;
 	ret = usb_write_async(udev, addr, data, 2);
 
-
 	return ret;
 }
 
@@ -147,11 +142,9 @@ int usb_async_write32(struct intf_hdl *p
 	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
 	struct usb_device *udev=pdvobjpriv->pusbdev;
 
-
 	data = val;
 	ret = usb_write_async(udev, addr, data, 4);
 
-
 	return ret;
 }
 #endif /* CONFIG_USB_SUPPORT_ASYNC_VDN_REQ */
@@ -210,14 +203,11 @@ static u32 usb_bulkout_zero(struct intf_
 	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
 	struct usb_device *pusbd = pdvobj->pusbdev;
 
-
-
 	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
 	{
 		return _FAIL;
 	}
 
-
 	pcontext = (struct zero_bulkout_context *)kzalloc(sizeof(struct zero_bulkout_context), GFP_KERNEL);
 
 	pbuf = (unsigned char *)kzalloc(sizeof(int), GFP_KERNEL);
@@ -229,7 +219,6 @@ static u32 usb_bulkout_zero(struct intf_
 	pcontext->pirp = NULL;
 	pcontext->padapter = padapter;
 
-
 	/* translate DMA FIFO addr to pipehandle */
 
 	usb_fill_bulk_urb(purb, pusbd, pipe,
@@ -249,7 +238,6 @@ static u32 usb_bulkout_zero(struct intf_
 		ret= _FAIL;
 	}
 
-
 	return ret;
 }
 
@@ -261,7 +249,6 @@ void usb_write_mem(struct intf_hdl *pint
 {
 }
 
-
 void usb_read_port_cancel(struct intf_hdl *pintfhdl)
 {
 	int i;
@@ -295,8 +282,6 @@ static void usb_write_port_complete(stru
 	struct rtw_adapter	*padapter = pxmitbuf->padapter;
        struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 
-
-
 	switch (pxmitbuf->flags)
 	{
 		case VO_QUEUE_INX:
@@ -329,7 +314,6 @@ static void usb_write_port_complete(stru
 		goto check_completion;
 	}
 
-
 	if (purb->status==0) {
 
 	} else {
@@ -384,7 +368,6 @@ check_completion:
 		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
 	}
 
-
 }
 
 u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
@@ -402,8 +385,6 @@ u32 usb_write_port(struct intf_hdl *pint
 	struct usb_device *pusbd = pdvobj->pusbdev;
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
 
-
-
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port\n"));
 
 	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx)) {
@@ -459,7 +440,6 @@ u32 usb_write_port(struct intf_hdl *pint
 		purb->transfer_flags  |=  URB_NO_INTERRUPT;
 #endif
 
-
 	usb_fill_bulk_urb(purb, pusbd, pipe,
 				pxmitframe->buf_addr, /*  pxmitbuf->pbuf */
 				cnt,
--- a/drivers/staging/rtl8192du/os_dep/xmit_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/xmit_linux.c
@@ -35,22 +35,18 @@ uint rtw_remainder_len(struct pkt_file *
 void _rtw_open_pktfile (struct sk_buff *pktptr, struct pkt_file *pfile)
 {
 
-
 	pfile->pkt = pktptr;
 	pfile->cur_addr = pfile->buf_start = pktptr->data;
 	pfile->pkt_len = pfile->buf_len = pktptr->len;
 
 	pfile->cur_buffer = pfile->buf_start ;
 
-
 }
 
 uint _rtw_pktfile_read (struct pkt_file *pfile, u8 *rmem, uint rlen)
 {
 	uint	len = 0;
 
-
-
        len =  rtw_remainder_len(pfile);
 	len = (rlen > len)? len: rlen;
 
@@ -60,22 +56,17 @@ uint _rtw_pktfile_read (struct pkt_file
        pfile->cur_addr += len;
        pfile->pkt_len -= len;
 
-
-
 	return len;
 }
 
 int rtw_endofpktfile(struct pkt_file *pfile)
 {
 
-
 	if (pfile->pkt_len == 0) {
 
 		return true;
 	}
 
-
-
 	return false;
 }
 
@@ -152,7 +143,6 @@ void rtw_os_xmit_resource_free(struct rt
 	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
 	struct usb_device	*pusbd = pdvobjpriv->pusbdev;
 
-
 	for (i=0; i<8; i++)
 	{
 		if (pxmitbuf->pxmit_urb[i])
@@ -221,8 +211,6 @@ void rtw_os_xmit_schedule(struct rtw_ada
 	spin_unlock_bh(&pxmitpriv->lock);
 }
 
-
-
 static int rtw_mlcst2unicst(struct rtw_adapter *padapter, struct sk_buff *skb)
 {
 	struct	sta_priv *pstapriv = &padapter->stapriv;
@@ -282,8 +270,6 @@ int rtw_xmit_entry(struct sk_buff *pkt,
 	u16 queue;
 #endif
 
-
-
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("+xmit_enry\n"));
 
 	if (rtw_if_up(padapter) == false) {
@@ -337,7 +323,5 @@ drop_packet:
 
 exit:
 
-
-
 	return 0;
 }

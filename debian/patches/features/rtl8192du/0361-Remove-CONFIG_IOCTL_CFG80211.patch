From 52504da48cccae3fa917863ab5f5e2705d794d12 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sun, 16 Mar 2014 17:07:44 -0500
Subject: [PATCH 361/390] Remove CONFIG_IOCTL_CFG80211

This option will always be selected.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_ap.c           |   3 +-
 core/rtw_mlme.c         |  14 +---
 core/rtw_mlme_ext.c     | 186 ++++++++++--------------------------------------
 core/rtw_p2p.c          |  87 ++--------------------
 core/rtw_pwrctrl.c      |   8 ---
 include/autoconf.h      |   2 -
 include/drv_types.h     |  25 ++-----
 include/osdep_service.h |   8 +--
 include/rtw_mlme.h      |  45 +++++-------
 include/rtw_p2p.h       |  65 +++++++++++------
 include/sta_info.h      |   2 -
 os_dep/ioctl_cfg80211.c |   5 --
 os_dep/ioctl_linux.c    |  82 ---------------------
 os_dep/mlme_linux.c     |  14 +---
 os_dep/os_intfs.c       |  30 +-------
 os_dep/recv_linux.c     |  32 ++-------
 os_dep/rtw_android.c    |  14 +---
 os_dep/usb_intf.c       |   9 +--
 18 files changed, 127 insertions(+), 504 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_ap.c
+++ b/drivers/staging/rtl8192du/core/rtw_ap.c
@@ -1975,8 +1975,7 @@ u8 ap_free_sta(struct rtw_adapter *padap
 
 #ifdef CONFIG_92D_AP_MODE
 	rtw_cfg80211_indicate_sta_disassoc(padapter, psta->hwaddr, reason);
-#endif /* CONFIG_IOCTL_CFG80211 */
-
+#endif
 	report_del_sta_event(padapter, psta->hwaddr, reason);
 
 	beacon_updated = bss_cap_update_on_sta_leave(padapter, psta);
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -999,11 +999,7 @@ void rtw_surveydone_event_callback(struc
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	dc_resume_xmit(adapter);
 #endif
-
-#ifdef CONFIG_IOCTL_CFG80211
 	rtw_cfg80211_surveydone_event_callback(adapter);
-#endif /* CONFIG_IOCTL_CFG80211 */
-
 }
 
 void rtw_dummy_event_callback(struct rtw_adapter *adapter, u8 *pbuf)
@@ -1585,7 +1581,6 @@ void rtw_stassoc_event_callback(struct r
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 		psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);
 		if (psta) {
-#ifdef CONFIG_IOCTL_CFG80211
 			u8 *passoc_req = NULL;
 			u32 assoc_req_len;
 
@@ -1611,8 +1606,6 @@ void rtw_stassoc_event_callback(struct r
 
 				kfree(passoc_req);
 			}
-#endif /* CONFIG_IOCTL_CFG80211 */
-
 			ap_sta_info_defer_update(adapter, psta);
 		}
 		return;
@@ -1680,14 +1673,13 @@ void rtw_stadel_event_callback(struct rt
 	struct sta_priv *pstapriv = &adapter->stapriv;
 	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
 
+#ifdef CONFIG_92D_AP_MODE
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
-#if defined(CONFIG_92D_AP_MODE)
 		rtw_cfg80211_indicate_sta_disassoc(adapter, pstadel->macaddr,
 						   *(u16 *)pstadel->rsvd);
-#endif /* defined(CONFIG_IOCTL_CFG80211) */
 		return;
 	}
-
+#endif
 	mlmeext_sta_del_event_callback(adapter);
 
 	spin_lock_bh(&pmlmepriv->lock);
@@ -1922,7 +1914,6 @@ void rtw_dynamic_check_timer_handlder(st
 	}
 }
 
-#ifdef CONFIG_IOCTL_CFG80211
 inline bool rtw_is_scan_deny(struct rtw_adapter *adapter)
 {
 	struct mlme_priv *mlmepriv = &adapter->mlmepriv;
@@ -1958,7 +1949,6 @@ void rtw_set_scan_deny(struct rtw_adapte
 	_set_timer(&b_mlmepriv->set_scan_deny_timer, ms);
 #endif
 }
-#endif
 
 #define RTW_SCAN_RESULT_EXPIRE 2000
 
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -647,7 +647,6 @@ static u32 p2p_listen_state_process(stru
 {
 	bool response = true;
 
-#ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled == false ||
 	    adapt->mlmepriv.wps_probe_resp_ie == NULL ||
 	    adapt->mlmepriv.p2p_probe_resp_ie == NULL) {
@@ -658,12 +657,6 @@ static u32 p2p_listen_state_process(stru
 		     adapt->mlmepriv.p2p_probe_resp_ie);
 		response = false;
 	}
-#else
-	/*      do nothing if the device name is empty */
-	if (!adapt->wdinfo.device_name_len) {
-		response = false;
-	}
-#endif
 
 	if (response == true)
 		issue_probersp_p2p(adapt, da);
@@ -1718,27 +1711,8 @@ unsigned int OnAssocReq(struct rtw_adapt
 
 		/* 2 - report to upper layer */
 		DBG_8192D("indicate_sta_join_event to upper layer - hostapd\n");
-#ifdef CONFIG_IOCTL_CFG80211
-		if (1) {
-			rtw_cfg80211_indicate_sta_assoc(adapt, pframe,
-							pkt_len);
-#else /* !defined(CONFIG_IOCTL_CFG80211) */
-			spin_lock_bh(&pstat->lock);
-			kfree(pstat->passoc_req);
-			pstat->passoc_req = NULL;
-			pstat->assoc_req_len = 0;
-
-			pstat->passoc_req = kzalloc(pkt_len, GFP_ATOMIC);
-			if (pstat->passoc_req) {
-				memcpy(pstat->passoc_req, pframe, pkt_len);
-				pstat->assoc_req_len = pkt_len;
-			}
-			spin_unlock_bh(&pstat->lock);
-#endif /* !defined(CONFIG_IOCTL_CFG80211) */
-		} else
-		{
-			rtw_indicate_sta_assoc_event(adapt, pstat);
-		}
+		rtw_cfg80211_indicate_sta_assoc(adapt, pframe,
+						pkt_len);
 
 		/* 3-(1) report sta add event */
 		report_add_sta_event(adapt, pstat->hwaddr, pstat->aid);
@@ -4054,28 +4028,25 @@ void issue_probersp_p2p(struct rtw_adapt
 {
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
-	unsigned char *pframe;
 	struct ieee80211_hdr *pwlanhdr;
-	unsigned short *fctrl;
-	unsigned char *mac;
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
-	/* struct wlan_bssid_ex *cur_network = &(pmlmeinfo->network); */
-	u16 beacon_interval = 100;
-	u16 capInfo = 0;
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-	u8 wpsie[255] = { 0x00 };
-	u32 wpsielen = 0, p2pielen = 0;
-#ifdef CONFIG_IOCTL_CFG80211
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo =
 	    &adapt->cfg80211_wdinfo;
 	struct ieee80211_channel *ieee_ch =
 	    &pcfg80211_wdinfo->remain_on_ch_channel;
+	unsigned char *pframe;
+	unsigned short *fctrl;
+	unsigned char *mac;
+	u16 beacon_interval = 100;
+	u16 capInfo = 0;
+	u8 wpsie[255] = { 0x00 };
+	u32 wpsielen = 0, p2pielen = 0;
 	u8 listen_channel =
 	    (u8) ieee80211_frequency_to_channel(ieee_ch->center_freq);
-#endif /* CONFIG_IOCTL_CFG80211 */
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
 	if (pmgntframe == NULL)
@@ -4138,23 +4109,19 @@ void issue_probersp_p2p(struct rtw_adapt
 		       &pattrib->pktlen);
 
 	/*  DS parameter set */
-#ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled &&
 	    listen_channel != 0) {
 		pframe =
 		    rtw_set_ie(pframe, _DSSET_IE_, 1,
 			       (unsigned char *)&listen_channel,
 			       &pattrib->pktlen);
-	} else
-#endif /* CONFIG_IOCTL_CFG80211 */
-	{
+	} else {
 		pframe =
 		    rtw_set_ie(pframe, _DSSET_IE_, 1,
 			       (unsigned char *)&pwdinfo->listen_channel,
 			       &pattrib->pktlen);
 	}
 
-#ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
 		if (pmlmepriv->wps_probe_resp_ie != NULL &&
 		    pmlmepriv->p2p_probe_resp_ie != NULL) {
@@ -4170,9 +4137,7 @@ void issue_probersp_p2p(struct rtw_adapt
 			pattrib->pktlen += pmlmepriv->p2p_probe_resp_ie_len;
 			pframe += pmlmepriv->p2p_probe_resp_ie_len;
 		}
-	} else
-#endif /* CONFIG_IOCTL_CFG80211 */
-	{
+	} else {
 		/*      Todo: WPS IE */
 		/*      Noted by Albert 20100907 */
 		/*      According to the WPS specification, all the WPS attribute is presented by Big Endian. */
@@ -4433,7 +4398,6 @@ static int _issue_probereq_p2p(struct rt
 	    rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pwdinfo->support_rate,
 		       &pattrib->pktlen);
 
-#ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
 		if (pmlmepriv->wps_probe_req_ie != NULL &&
 		    pmlmepriv->p2p_probe_req_ie != NULL) {
@@ -4449,9 +4413,7 @@ static int _issue_probereq_p2p(struct rt
 			pattrib->pktlen += pmlmepriv->p2p_probe_req_ie_len;
 			pframe += pmlmepriv->p2p_probe_req_ie_len;
 		}
-	} else
-#endif /* CONFIG_IOCTL_CFG80211 */
-	{
+	} else {
 		/*      WPS IE */
 		/*      Noted by Albert 20110221 */
 		/*      According to the WPS specification, all the WPS attribute is presented by Big Endian. */
@@ -4806,12 +4768,9 @@ static unsigned int on_action_public_p2p
 
 #ifdef CONFIG_P2P
 	_cancel_timer_ex(&pwdinfo->reset_ch_sitesurvey);
-#ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
 		rtw_cfg80211_rx_p2p_action_public(adapt, pframe, len);
-	} else
-#endif /* CONFIG_IOCTL_CFG80211 */
-	{
+	} else {
 		/*      Do nothing if the driver doesn't enable the P2P function. */
 		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) ||
 		    rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
@@ -5338,12 +5297,12 @@ static unsigned int on_action_public_ven
 
 static unsigned int on_action_public_default(struct recv_frame_hdr *precv_frame, u8 action)
 {
+	struct rtw_adapter *adapter = precv_frame->adapter;
 	unsigned int ret = _FAIL;
 	u8 *pframe = precv_frame->rx_data;
 	uint frame_len = precv_frame->len;
 	u8 *frame_body = pframe + sizeof(struct ieee80211_hdr_3addr);
 	u8 token;
-	struct rtw_adapter *adapter = precv_frame->adapter;
 	int cnt = 0;
 	char msg[64];
 
@@ -5352,12 +5311,9 @@ static unsigned int on_action_public_def
 	if (rtw_action_public_decache(precv_frame, token) == _FAIL)
 		goto exit;
 
-#ifdef CONFIG_IOCTL_CFG80211
-	cnt +=
-	    sprintf((msg + cnt), "%s(token:%u)", action_public_str(action),
-		    token);
+	cnt += sprintf((msg + cnt), "%s(token:%u)", action_public_str(action),
+		       token);
 	rtw_cfg80211_rx_action(adapter, pframe, frame_len, msg);
-#endif
 
 	ret = _SUCCESS;
 
@@ -5435,13 +5391,10 @@ unsigned int OnAction_p2p(struct rtw_ada
 	if (be32_to_cpu(*((__be32 *)(frame_body + 1))) != P2POUI)
 		return _SUCCESS;
 
-#ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
 		rtw_cfg80211_rx_action_p2p(adapt, pframe, len);
 		return _SUCCESS;
-	} else
-#endif /* CONFIG_IOCTL_CFG80211 */
-	{
+	} else {
 		len -= sizeof(struct ieee80211_hdr_3addr);
 		OUI_Subtype = frame_body[5];
 		switch (OUI_Subtype) {
@@ -5673,21 +5626,19 @@ void issue_beacon(struct rtw_adapter *ad
 {
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
-	unsigned char *pframe;
 	struct ieee80211_hdr *pwlanhdr;
-	unsigned short *fctrl;
-	unsigned int rate_len;
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
-#ifdef CONFIG_IOCTL_CFG80211
 	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
-#endif
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);
-	u8 bc_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 #endif /* CONFIG_P2P */
+	unsigned char *pframe;
+	unsigned short *fctrl;
+	unsigned int rate_len;
+	u8 bc_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
 	if (pmgntframe == NULL) {
@@ -5744,7 +5695,6 @@ void issue_beacon(struct rtw_adapter *ad
 			remainder_ielen =
 			    cur_network->IELength - wps_offset - wpsielen;
 
-#ifdef CONFIG_IOCTL_CFG80211
 			if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
 				if (pmlmepriv->wps_beacon_ie && pmlmepriv->wps_beacon_ie_len > 0) {
 					memcpy(pframe, cur_network->IEs,
@@ -5770,9 +5720,7 @@ void issue_beacon(struct rtw_adapter *ad
 					pattrib->pktlen +=
 					    cur_network->IELength;
 				}
-			} else
-#endif /* CONFIG_IOCTL_CFG80211 */
-			{
+			} else {
 				pframe_wscie = pframe + wps_offset;
 				memcpy(pframe, cur_network->IEs,
 				       wps_offset + wpsielen);
@@ -5880,15 +5828,12 @@ void issue_beacon(struct rtw_adapter *ad
 #ifdef CONFIG_P2P
 		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
 			u32 len;
-#ifdef CONFIG_IOCTL_CFG80211
 			if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
 				len = pmlmepriv->p2p_beacon_ie_len;
 				if (pmlmepriv->p2p_beacon_ie && len > 0)
 					memcpy(pframe, pmlmepriv->p2p_beacon_ie,
 					       len);
-			} else
-#endif /* CONFIG_IOCTL_CFG80211 */
-			{
+			} else {
 				len = build_beacon_p2p_ie(pwdinfo, pframe);
 			}
 
@@ -5994,27 +5939,23 @@ void issue_probersp(struct rtw_adapter *
 {
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
-	unsigned char *pframe;
 	struct ieee80211_hdr *pwlanhdr;
-	unsigned short *fctrl;
-	unsigned char *mac, *bssid;
-	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
-#if defined (CONFIG_92D_AP_MODE)
-	u8 *pwps_ie;
-	uint wps_ielen;
-#endif /* if defined (CONFIG_92D_AP_MODE) */
-#ifdef CONFIG_IOCTL_CFG80211
 	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
-#endif
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);
-	unsigned int rate_len;
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 #endif /* CONFIG_P2P */
-
-	/* DBG_8192D("%s\n", __func__); */
+	unsigned char *pframe;
+	unsigned short *fctrl;
+	unsigned char *mac, *bssid;
+#if defined (CONFIG_92D_AP_MODE)
+	u8 *pwps_ie;
+	uint wps_ielen;
+#endif /* if defined (CONFIG_92D_AP_MODE) */
+	unsigned int rate_len;
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
 	if (pmgntframe == NULL) {
@@ -6214,16 +6155,13 @@ void issue_probersp(struct rtw_adapter *
 #ifdef CONFIG_P2P
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && is_valid_p2p_probereq) {
 		u32 len;
-#ifdef CONFIG_IOCTL_CFG80211
 		if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
 			/* if pwdinfo->role == P2P_ROLE_DEVICE will call issue_probersp_p2p() */
 			len = pmlmepriv->p2p_go_probe_resp_ie_len;
 			if (pmlmepriv->p2p_go_probe_resp_ie && len > 0)
 				memcpy(pframe, pmlmepriv->p2p_go_probe_resp_ie,
 				       len);
-		} else
-#endif /* CONFIG_IOCTL_CFG80211 */
-		{
+		} else {
 			len = build_probe_resp_p2p_ie(pwdinfo, pframe);
 		}
 
@@ -6715,20 +6653,6 @@ void issue_asocrsp(struct rtw_adapter *a
 		pframe += pmlmepriv->wps_assoc_resp_ie_len;
 		pattrib->pktlen += pmlmepriv->wps_assoc_resp_ie_len;
 	}
-#ifdef CONFIG_P2P
-#ifndef CONFIG_IOCTL_CFG80211
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && pstat->is_p2p_device) {
-		u32 len;
-
-		len =
-		    build_assoc_resp_p2p_ie(pwdinfo, pframe,
-					    pstat->p2p_status_code);
-
-		pframe += len;
-		pattrib->pktlen += len;
-	}
-#endif /* CONFIG_IOCTL_CFG80211 */
-#endif /* CONFIG_P2P */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -7036,7 +6960,6 @@ void issue_assocreq(struct rtw_adapter *
 	}
 #ifdef CONFIG_P2P
 
-#ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
 		if (pmlmepriv->p2p_assoc_req_ie &&
 		    pmlmepriv->p2p_assoc_req_ie_len > 0) {
@@ -7045,9 +6968,7 @@ void issue_assocreq(struct rtw_adapter *
 			pframe += pmlmepriv->p2p_assoc_req_ie_len;
 			pattrib->pktlen += pmlmepriv->p2p_assoc_req_ie_len;
 		}
-	} else
-#endif /* CONFIG_IOCTL_CFG80211 */
-	{
+	} else {
 		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) &&
 		    !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE)) {
 			/*      Should add the P2P IE in the association request frame. */
@@ -8282,21 +8203,9 @@ void site_survey(struct rtw_adapter *ada
 		{
 #ifdef CONFIG_P2P
 			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) || rtw_p2p_chk_state(pwdinfo,
-			    P2P_STATE_FIND_PHASE_SEARCH)) {
-#ifdef CONFIG_CONCURRENT_MODE
-#ifndef CONFIG_IOCTL_CFG80211
-				if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-					_set_timer(&pwdinfo->
-						   ap_p2p_switch_timer, 500);
-				}
-#endif /* CONFIG_IOCTL_CFG80211 */
-				rtw_p2p_set_state(pwdinfo,
-						  rtw_p2p_pre_state(pwdinfo));
-#else
+			    P2P_STATE_FIND_PHASE_SEARCH))
 				rtw_p2p_set_state(pwdinfo,
 						  rtw_p2p_pre_state(pwdinfo));
-#endif
-			}
 			rtw_p2p_findphase_ex_set(pwdinfo,
 						 P2P_FINDPHASE_EX_NONE);
 #endif /* CONFIG_P2P */
@@ -8310,16 +8219,6 @@ void site_survey(struct rtw_adapter *ada
 #ifdef CONFIG_DUALMAC_CONCURRENT
 				dc_set_channel_bwmode_survey_done(adapt);
 #else
-#ifndef CONFIG_IOCTL_CFG80211
-				if (rtw_p2p_chk_state
-				    (pwdinfo, P2P_STATE_LISTEN)) {
-					set_channel_bwmode(adapt,
-							   pwdinfo->
-							   listen_channel,
-							   HAL_PRIME_CHNL_OFFSET_DONT_CARE,
-							   HT_CHANNEL_WIDTH_20);
-				} else
-#endif /* CONFIG_IOCTL_CFG80211 */
 #ifdef CONFIG_CONCURRENT_MODE
 					set_channel_bwmode(adapt,
 							   cur_channel,
@@ -10351,21 +10250,10 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 		Switch_DM_Func(adapt, DYNAMIC_FUNC_DISABLE, false);
 
 		/* config the initial gain under scaning, need to write the BB registers */
-#ifdef CONFIG_IOCTL_CFG80211
 		if ((wdev_to_priv(adapt->rtw_wdev))->p2p_enabled == true)
 			initialgain = 0x27;
 		else
 			initialgain = 0x17;
-#else /*      go through the WEXT interface CONFIG_IOCTL_CFG80211 */
-#ifdef CONFIG_P2P
-		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-			initialgain = 0x17;
-		else
-			initialgain = 0x28;
-#else /*  CONFIG_P2P */
-		initialgain = 0x17;
-#endif /*  CONFIG_P2P */
-#endif /*  CONFIG_IOCTL_CFG80211 */
 
 		rtw_hal_set_hwreg(adapt, HW_VAR_INITIAL_GAIN,
 				  (u8 *)(&initialgain));
@@ -11412,12 +11300,12 @@ int concurrent_chk_start_clnt_join(struc
 			rtw_hal_set_hwreg(adapt, HW_VAR_CHECK_TXBUF, 0);
 		}
 	} else if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == true && check_fwstate(pbuddy_mlmepriv, WIFI_STATION_STATE) == true) {	/* for Client Mode/p2p client */
-#if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
+#if defined(CONFIG_P2P)
 		struct wifidirect_info *pbuddy_wdinfo =
 		    &(pbuddy_adapter->wdinfo);
 		if (!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
 			return _SUCCESS;	/* wlan0-sta mode has higher priority than p2p0-p2p client */
-#endif /* CONFIG_P2P && CONFIG_IOCTL_CFG80211 */
+#endif /* CONFIG_P2P */
 
 		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel) {
 			DBG_8192D
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -1624,77 +1624,12 @@ void p2p_concurrent_handler(struct rtw_a
 		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
 		pwdinfo->operating_channel = pbuddy_mlmeext->cur_channel;
-#ifdef CONFIG_IOCTL_CFG80211
 
 		DBG_8192D("%s, switch ch back to buddy's cur_channel =%d\n", __func__, pbuddy_mlmeext->cur_channel);
 
 		set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 
 		issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
-
-#else /* CONFIG_IOCTL_CFG80211 */
-		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE)) {
-			/*	Now, the driver stays on the AP's channel. */
-			/*	If the pwdinfo->ext_listen_period = 0, that means the P2P listen state is not available on listen channel. */
-			if (pwdinfo->ext_listen_period > 0) {
-				DBG_8192D("[%s] P2P_STATE_IDLE, ext_listen_period = %d\n", __func__, pwdinfo->ext_listen_period);
-
-				if (pbuddy_mlmeext->cur_channel != pwdinfo->listen_channel) {
-					/*	Will switch to listen channel so that need to send the NULL data with PW bit to AP. */
-					issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
-					set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-				}
-
-				rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
-				val8 = 1;
-				rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
-
-				/*	Todo: To check the value of pwdinfo->ext_listen_period is equal to 0 or not. */
-				_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_period);
-			}
-		} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN) ||
-			   rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL) ||
-			   (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == false) ||
-			   rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ)) {
-			/*	Now, the driver is in the listen state of P2P mode. */
-			DBG_8192D("[%s] P2P_STATE_IDLE, ext_listen_interval = %d\n", __func__, pwdinfo->ext_listen_interval);
-
-			/*	Commented by Albert 2012/11/01 */
-			/*	If the AP's channel is the same as the listen channel, we should still be in the listen state */
-			/*	Other P2P device is still able to find this device out even this device is in the AP's channel. */
-			/*	So, configure this device to be able to receive the probe request frame and set it to listen state. */
-			if (pbuddy_mlmeext->cur_channel != pwdinfo->listen_channel) {
-				set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-				val8 = 0;
-				padapter->HalFunc.SetHwRegHandler(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
-				rtw_p2p_set_state(pwdinfo, P2P_STATE_IDLE);
-				issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
-			}
-
-			/*	Todo: To check the value of pwdinfo->ext_listen_interval is equal to 0 or not. */
-			_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_interval);
-		} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_OK)) {
-			/*	The driver had finished the P2P handshake successfully. */
-			val8 = 0;
-			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
-			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-			issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
-		} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ)) {
-			val8 = 1;
-			set_channel_bwmode(padapter, pwdinfo->tx_prov_disc_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
-			issue_probereq_p2p(padapter, NULL);
-			_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
-		} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == true) {
-			val8 = 1;
-			set_channel_bwmode(padapter, pwdinfo->nego_req_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
-			issue_probereq_p2p(padapter, NULL);
-			_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
-		} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ) && pwdinfo->invitereq_info.benable == true) {
-			;
-		}
-#endif /* CONFIG_IOCTL_CFG80211 */
 	} else {
 		set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	}
@@ -1702,7 +1637,6 @@ void p2p_concurrent_handler(struct rtw_a
 }
 #endif
 
-#ifdef CONFIG_IOCTL_CFG80211
 static void ro_ch_handler(struct rtw_adapter *padapter)
 {
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
@@ -1715,10 +1649,12 @@ static void ro_ch_handler(struct rtw_ada
 		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
-		DBG_8192D("%s, switch ch back to buddy's cur_channel =%d\n", __func__, pbuddy_mlmeext->cur_channel);
-
-		set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
+		DBG_8192D("%s, switch ch back to buddy's cur_channel =%d\n",
+			  __func__, pbuddy_mlmeext->cur_channel);
 
+		set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel,
+				   pbuddy_mlmeext->cur_ch_offset,
+				   pbuddy_mlmeext->cur_bwmode);
 		pmlmeext->cur_channel = pbuddy_mlmeext->cur_channel;
 
 	} else
@@ -2009,7 +1945,6 @@ void rtw_init_cfg80211_wifidirect_info(s
 
 	_init_timer(&pcfg80211_wdinfo->remain_on_ch_timer, padapter->pnetdev, ro_ch_timer_process, padapter);
 }
-#endif /* CONFIG_IOCTL_CFG80211 */
 
 void p2p_protocol_wk_hdl(struct rtw_adapter *padapter, int intCmdType)
 {
@@ -2059,11 +1994,9 @@ void p2p_protocol_wk_hdl(struct rtw_adap
 		break;
 #endif
 #endif
-#ifdef CONFIG_IOCTL_CFG80211
 	case P2P_RO_CH_WK:
 		ro_ch_handler(padapter);
 		break;
-#endif /* CONFIG_IOCTL_CFG80211 */
 	}
 
 }
@@ -2163,17 +2096,12 @@ static void ap_p2p_switch_timer_process(
 {
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
-#ifdef CONFIG_IOCTL_CFG80211
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
-#endif
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 
-#ifdef CONFIG_IOCTL_CFG80211
 	atomic_set(&pwdev_priv->switch_ch_to, 1);
-#endif
-
 	p2p_protocol_wk_cmd(adapter, P2P_AP_P2P_CH_SWITCH_PROCESS_WK);
 }
 #endif
@@ -2322,13 +2250,8 @@ void init_wifidirect_info(struct rtw_ada
 	memset(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, '0', 3);
 	memset(&pwdinfo->groupid_info, 0x00, sizeof(struct group_id_info));
 #ifdef CONFIG_CONCURRENT_MODE
-#ifdef CONFIG_IOCTL_CFG80211
 	pwdinfo->ext_listen_interval = 1000; /* The interval to be available with legacy AP during p2p0-find/scan */
 	pwdinfo->ext_listen_period = 3000; /* The time period to be available for P2P during nego */
-#else /* CONFIG_IOCTL_CFG80211 */
-	pwdinfo->ext_listen_interval = 1000;
-	pwdinfo->ext_listen_period = 1000;
-#endif /* CONFIG_IOCTL_CFG80211 */
 #endif
 	pwdinfo->wfd_tdls_enable = 0;
 	memset(pwdinfo->p2p_peer_interface_addr, 0x00, ETH_ALEN);
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -106,11 +106,9 @@ static bool rtw_pwr_unassociated_idle(st
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &(adapter->wdinfo);
-#ifdef CONFIG_IOCTL_CFG80211
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo =
 	    &adapter->cfg80211_wdinfo;
 #endif
-#endif
 
 	bool ret = false;
 
@@ -133,11 +131,9 @@ static bool rtw_pwr_unassociated_idle(st
 		struct mlme_priv *b_pmlmepriv = &(buddy->mlmepriv);
 #ifdef CONFIG_P2P
 		struct wifidirect_info *b_pwdinfo = &(buddy->wdinfo);
-#ifdef CONFIG_IOCTL_CFG80211
 		struct cfg80211_wifidirect_info *b_pcfg80211_wdinfo =
 		    &buddy->cfg80211_wdinfo;
 #endif
-#endif
 
 		if (check_fwstate(b_pmlmepriv, WIFI_ASOC_STATE | WIFI_SITE_MONITOR) ||
 		    check_fwstate(b_pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS) ||
@@ -264,10 +260,8 @@ static u8 ps_rdy_check(struct rtw_adapte
 		DBG_8192D("Group handshake still in progress !!!\n");
 		return false;
 	}
-#ifdef CONFIG_IOCTL_CFG80211
 	if (!rtw_cfg80211_pwr_mgmt(padapter))
 		return false;
-#endif
 
 	return true;
 }
@@ -336,11 +330,9 @@ void rtw_lps_enter(struct rtw_adapter *p
 		struct mlme_priv *b_pmlmepriv = &(buddy->mlmepriv);
 #ifdef CONFIG_P2P
 		struct wifidirect_info *b_pwdinfo = &(buddy->wdinfo);
-#ifdef CONFIG_IOCTL_CFG80211
 		struct cfg80211_wifidirect_info *b_pcfg80211_wdinfo =
 		    &buddy->cfg80211_wdinfo;
 #endif
-#endif
 
 		if (check_fwstate
 		    (b_pmlmepriv, WIFI_ASOC_STATE | WIFI_SITE_MONITOR) ||
--- a/drivers/staging/rtl8192du/include/autoconf.h
+++ b/drivers/staging/rtl8192du/include/autoconf.h
@@ -27,8 +27,6 @@
 
 //#define CONFIG_P2P	1
 
-#define CONFIG_IOCTL_CFG80211
-
 #define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable,*/
 
 //#define CONFIG_CONCURRENT_MODE 1
--- a/drivers/staging/rtl8192du/include/drv_types.h
+++ b/drivers/staging/rtl8192du/include/drv_types.h
@@ -45,9 +45,7 @@
 #include <rtw_p2p.h>
 #include <rtw_ap.h>
 
-#ifdef CONFIG_IOCTL_CFG80211
-	#include "ioctl_cfg80211.h"
-#endif /* CONFIG_IOCTL_CFG80211 */
+#include "ioctl_cfg80211.h"
 
 #define SPEC_DEV_ID_NONE BIT(0)
 #define SPEC_DEV_ID_DISABLE_HT BIT(1)
@@ -262,42 +260,31 @@ struct rtw_adapter {
 	struct	pwrctrl_priv	pwrctrlpriv;
 	struct	eeprom_priv eeprompriv;
 	struct	led_priv	ledpriv;
-
+	struct cfg80211_wifidirect_info	cfg80211_wdinfo;
 #ifdef CONFIG_92D_AP_MODE
 	struct	hostapd_priv	*phostapdpriv;
 #endif
-
-#ifdef CONFIG_IOCTL_CFG80211
-	struct cfg80211_wifidirect_info	cfg80211_wdinfo;
-#endif /* CONFIG_IOCTL_CFG80211 */
-	u32	setband;
 	struct wifidirect_info	wdinfo;
-
+	struct hal_ops	HalFunc;
+	u32	setband;
 	void *HalData;
 	u32 hal_data_sz;
-	struct hal_ops	HalFunc;
-
 	s32	bDriverStopped;
 	s32	bSurpriseRemoved;
 	s32  bCardDisableWOHSM;
-
 	u32	IsrContent;
 	u32	ImrContent;
-
 	u8	EepromAddressSize;
 	u8	hw_init_completed;
 	u8	bDriverIsGoingToUnload;
 	u8	init_adpt_in_progress;
 	u8	bHaltInProgress;
-
 	void *cmdThread;
 	void *evtThread;
 	void *xmitThread;
 	void *recvThread;
-
 	void (*intf_start)(struct rtw_adapter *adapter);
 	void (*intf_stop)(struct rtw_adapter *adapter);
-
 	struct net_device *pnetdev;
 
 	/*  used by rtw_rereg_nd_name related function */
@@ -312,11 +299,7 @@ struct rtw_adapter {
 	struct net_device_stats stats;
 	struct iw_statistics iwstats;
 	struct proc_dir_entry *dir_dev;/*  for proc directory */
-
-#ifdef CONFIG_IOCTL_CFG80211
 	struct wireless_dev *rtw_wdev;
-#endif /* CONFIG_IOCTL_CFG80211 */
-
 	int net_closed;
 
 	u8 bFWReady;
--- a/drivers/staging/rtl8192du/include/osdep_service.h
+++ b/drivers/staging/rtl8192du/include/osdep_service.h
@@ -51,12 +51,8 @@
 #include <linux/interrupt.h>	/*  for struct tasklet_struct */
 #include <linux/ip.h>
 #include <linux/kthread.h>
-
-#ifdef CONFIG_IOCTL_CFG80211
-        #include <net/ieee80211_radiotap.h>
-	#include <net/cfg80211.h>
-#endif /* CONFIG_IOCTL_CFG80211 */
-
+#include <net/ieee80211_radiotap.h>
+#include <net/cfg80211.h>
 #include <linux/usb.h>
 #include <linux/usb/ch9.h>
 
--- a/drivers/staging/rtl8192du/include/rtw_mlme.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme.h
@@ -179,8 +179,7 @@ struct scan_limit_info{
 	u8					operation_ch[2];				/* 	Store the operation channel of invitation request frame */
 };
 
-#ifdef CONFIG_IOCTL_CFG80211
-struct cfg80211_wifidirect_info{
+struct cfg80211_wifidirect_info {
 	struct timer_list		remain_on_ch_timer;
 	u8				restore_channel;
 	struct ieee80211_channel	remain_on_ch_channel;
@@ -188,9 +187,8 @@ struct cfg80211_wifidirect_info{
 	u64				remain_on_ch_cookie;
 	bool is_ro_ch;
 };
-#endif /* CONFIG_IOCTL_CFG80211 */
 
-struct wifidirect_info{
+struct wifidirect_info {
 	struct rtw_adapter *padapter;
 	struct timer_list			find_phase_timer;
 	struct timer_list			restore_p2p_state_timer;
@@ -327,10 +325,8 @@ struct mlme_priv {
 	struct timer_list scan_to_timer; /*  driver itself handles scan_timeout status. */
 	u32 scan_start_time; /*  used to evaluate the time spent in scanning */
 
-	#ifdef CONFIG_IOCTL_CFG80211
 	struct timer_list set_scan_deny_timer;
 	atomic_t set_scan_deny; /* 0: allowed, 1: deny */
-	#endif
 
 	struct qos_priv qospriv;
 
@@ -387,11 +383,11 @@ struct mlme_priv {
 
 	u8 *wps_beacon_ie;
 	u8 *wps_probe_resp_ie;
-	u8 *wps_assoc_resp_ie; /*  for CONFIG_IOCTL_CFG80211, this IE could include p2p ie / wfd ie */
+	u8 *wps_assoc_resp_ie; /*  for IOCTL_CFG80211, this IE could include p2p ie / wfd ie */
 
 	u32 wps_beacon_ie_len;
 	u32 wps_probe_resp_ie_len;
-	u32 wps_assoc_resp_ie_len; /*  for CONFIG_IOCTL_CFG80211, this IE len could include p2p ie / wfd ie */
+	u32 wps_assoc_resp_ie_len; /*  for IOCTL_CFG80211, this IE len could include p2p ie / wfd ie */
 
 	u8 *p2p_beacon_ie;
 	u8 *p2p_probe_req_ie;
@@ -550,18 +546,10 @@ void _rtw_join_timeout_handler(struct rt
 void rtw_scan_timeout_handler(struct rtw_adapter *adapter);
 
 void rtw_dynamic_check_timer_handlder(struct rtw_adapter *adapter);
-#ifdef CONFIG_IOCTL_CFG80211
 bool rtw_is_scan_deny(struct rtw_adapter *adapter);
 void rtw_clear_scan_deny(struct rtw_adapter *adapter);
 void rtw_set_scan_deny_timer_hdl(struct rtw_adapter *adapter);
 void rtw_set_scan_deny(struct rtw_adapter *adapter, u32 ms);
-#else
-#define rtw_is_scan_deny(adapter) false
-#define rtw_clear_scan_deny(adapter) do {} while (0)
-#define rtw_set_scan_deny_timer_hdl(adapter) do {} while (0)
-#define rtw_set_scan_deny(adapter, ms) do {} while (0)
-#endif
-
 
 int _rtw_init_mlme_priv(struct rtw_adapter *padapter);
 
@@ -575,9 +563,10 @@ struct wlan_network* _rtw_dequeue_networ
 
 struct wlan_network* _rtw_alloc_network(struct mlme_priv *pmlmepriv);
 
-
-void _rtw_free_network(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork, u8 isfreeall);
-void _rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork);
+void _rtw_free_network(struct mlme_priv *pmlmepriv,
+		       struct wlan_network *pnetwork, u8 isfreeall);
+void _rtw_free_network_nolock(struct mlme_priv *pmlmepriv,
+			      struct wlan_network *pnetwork);
 void rtw_indicate_wx_assoc_event(struct rtw_adapter *padapter);
 void rtw_indicate_wx_disassoc_event(struct rtw_adapter *padapter);
 
@@ -587,22 +576,26 @@ void _rtw_free_network_queue(struct rtw_
 
 int rtw_if_up(struct rtw_adapter *padapter);
 
-
 u8 *rtw_get_capability_from_ie(u8 *ie);
 u8 *rtw_get_timestampe_from_ie(u8 *ie);
 u8 *rtw_get_beacon_interval_from_ie(u8 *ie);
 
-
 void rtw_joinbss_reset(struct rtw_adapter *padapter);
 
-unsigned int rtw_restructure_ht_ie(struct rtw_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len, u8 channel);
-void rtw_update_ht_cap(struct rtw_adapter *padapter, u8 *pie, uint ie_len, u8 channel);
-void rtw_issue_addbareq_cmd(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe);
+unsigned int rtw_restructure_ht_ie(struct rtw_adapter *padapter, u8 *in_ie,
+				   u8 *out_ie, uint in_len, uint *pout_len,
+				   u8 channel);
+void rtw_update_ht_cap(struct rtw_adapter *padapter, u8 *pie, uint ie_len,
+		       u8 channel);
+void rtw_issue_addbareq_cmd(struct rtw_adapter *padapter,
+			    struct xmit_frame *pxmitframe);
 
-int rtw_is_same_ibss(struct rtw_adapter *adapter, struct wlan_network *pnetwork);
+int rtw_is_same_ibss(struct rtw_adapter *adapter,
+		     struct wlan_network *pnetwork);
 int is_same_network(struct wlan_bssid_ex *src, struct wlan_bssid_ex *dst);
 
-void _rtw_roaming(struct rtw_adapter *adapter, struct wlan_network *tgt_network);
+void _rtw_roaming(struct rtw_adapter *adapter,
+		  struct wlan_network *tgt_network);
 void rtw_roaming(struct rtw_adapter *adapter, struct wlan_network *tgt_network);
 void rtw_set_roaming(struct rtw_adapter *adapter, u8 to_roaming);
 u8 rtw_to_roaming(struct rtw_adapter *adapter);
--- a/drivers/staging/rtl8192du/include/rtw_p2p.h
+++ b/drivers/staging/rtl8192du/include/rtw_p2p.h
@@ -20,77 +20,100 @@
 
 u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
 u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8* pssid, u8 ussidlen, u8* pdev_raddr);
-u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 status_code);
+u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo,
+				   u8 *pbuf, u8 *pssid, u8 ussidlen,
+				   u8 *pdev_raddr);
+u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo,
+			    u8 *pbuf, u8 status_code);
 u32 build_deauth_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
-u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len, struct sta_info *psta);
-u32 process_p2p_devdisc_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
-u32 process_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
-u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,  u8 *pframe, uint len);
+u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo,
+			     u8 *pframe, uint len);
+u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo,
+			     u8 *pframe, uint len, struct sta_info *psta);
+u32 process_p2p_devdisc_req(struct wifidirect_info *pwdinfo,
+			    u8 *pframe, uint len);
+u32 process_p2p_devdisc_resp(struct wifidirect_info *pwdinfo,
+			     u8 *pframe, uint len);
+u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,
+			    u8 *pframe, uint len);
 u8 process_p2p_provdisc_resp(struct wifidirect_info *pwdinfo,  u8 *pframe);
-u8 process_p2p_group_negotation_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
-u8 process_p2p_group_negotation_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
-u8 process_p2p_group_negotation_confirm(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
-u8 process_p2p_presence_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u8 process_p2p_group_negotation_req(struct wifidirect_info *pwdinfo,
+				    u8 *pframe, uint len);
+u8 process_p2p_group_negotation_resp(struct wifidirect_info *pwdinfo,
+				     u8 *pframe, uint len);
+u8 process_p2p_group_negotation_confirm(struct wifidirect_info *pwdinfo,
+					u8 *pframe, uint len);
+u8 process_p2p_presence_req(struct wifidirect_info *pwdinfo,
+			    u8 *pframe, uint len);
 
 void p2p_protocol_wk_hdl(struct rtw_adapter *padapter, int intCmdType);
 
-#ifdef CONFIG_IOCTL_CFG80211
 void rtw_init_cfg80211_wifidirect_info(struct rtw_adapter *padapter);
-int rtw_p2p_check_frames(struct rtw_adapter *padapter, const u8 *buf, u32 len, u8 tx);
+int rtw_p2p_check_frames(struct rtw_adapter *padapter, const u8 *buf,
+			 u32 len, u8 tx);
 void rtw_append_wfd_ie(struct rtw_adapter *padapter, u8 *buf, u32 *len);
-#endif /* CONFIG_IOCTL_CFG80211 */
 
 void reset_global_wifidirect_info(struct rtw_adapter *padapter);
 int rtw_init_wifi_display_info(struct rtw_adapter *padapter);
 void rtw_init_wifidirect_timers(struct rtw_adapter *padapter);
-void rtw_init_wifidirect_addrs(struct rtw_adapter *padapter, u8 *dev_addr, u8 *iface_addr);
+void rtw_init_wifidirect_addrs(struct rtw_adapter *padapter, u8 *dev_addr,
+			       u8 *iface_addr);
 void init_wifidirect_info(struct rtw_adapter *padapter, enum P2P_ROLE role);
 int rtw_p2p_enable(struct rtw_adapter *padapter, enum P2P_ROLE role);
 
-static inline void _rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
+static inline void _rtw_p2p_set_state(struct wifidirect_info *wdinfo,
+				      enum P2P_STATE state)
 {
 	if (wdinfo->p2p_state != state) {
 		wdinfo->p2p_state = state;
 	}
 }
-static inline void _rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
+static inline void _rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo,
+					  enum P2P_STATE state)
 {
 	if (wdinfo->pre_p2p_state != state) {
 		wdinfo->pre_p2p_state = state;
 	}
 }
 
-static inline void _rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
+static inline void _rtw_p2p_set_role(struct wifidirect_info *wdinfo,
+				     enum P2P_ROLE role)
 {
 	if (wdinfo->role != role) {
 		wdinfo->role = role;
 	}
 }
+
 static inline int _rtw_p2p_state(struct wifidirect_info *wdinfo)
 {
 	return wdinfo->p2p_state;
 }
+
 static inline int _rtw_p2p_pre_state(struct wifidirect_info *wdinfo)
 {
 	return wdinfo->pre_p2p_state;
 }
+
 static inline int _rtw_p2p_role(struct wifidirect_info *wdinfo)
 {
 	return wdinfo->role;
 }
-static inline bool _rtw_p2p_chk_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
+
+static inline bool _rtw_p2p_chk_state(struct wifidirect_info *wdinfo,
+				      enum P2P_STATE state)
 {
 	return wdinfo->p2p_state == state;
 }
-static inline bool _rtw_p2p_chk_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
+
+static inline bool _rtw_p2p_chk_role(struct wifidirect_info *wdinfo,
+				     enum P2P_ROLE role)
 {
 	return wdinfo->role == role;
 }
 
 #define rtw_p2p_set_state(wdinfo, state) _rtw_p2p_set_state(wdinfo, state)
-#define rtw_p2p_set_pre_state(wdinfo, state) _rtw_p2p_set_pre_state(wdinfo, state)
+#define rtw_p2p_set_pre_state(wdinfo, state)			\
+	_rtw_p2p_set_pre_state(wdinfo, state)
 #define rtw_p2p_set_role(wdinfo, role) _rtw_p2p_set_role(wdinfo, role)
 
 #define rtw_p2p_state(wdinfo) _rtw_p2p_state(wdinfo)
--- a/drivers/staging/rtl8192du/include/sta_info.h
+++ b/drivers/staging/rtl8192du/include/sta_info.h
@@ -199,10 +199,8 @@ struct sta_info {
 
 	u8 keep_alive_trycnt;
 
-#ifdef CONFIG_IOCTL_CFG80211
 	u8 *passoc_req;
 	u32 assoc_req_len;
-#endif
 
 	/* for DM */
 	struct rssi_sta	 rssi_stat;
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -22,9 +22,6 @@
 #include <rtw_ioctl_set.h>
 #include <xmit_osdep.h>
 #include <wlan_bssdef.h>
-
-#ifdef CONFIG_IOCTL_CFG80211
-
 #include "ioctl_cfg80211.h"
 
 #define RTW_MAX_MGMT_TX_CNT (8)
@@ -4186,5 +4183,3 @@ void rtw_wdev_unregister(struct wireless
 
 	wiphy_unregister(wdev->wiphy);
 }
-
-#endif /* CONFIG_IOCTL_CFG80211 */
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -112,104 +112,22 @@ static int hwaddr_aton_i(const char *txt
 
 static void indicate_wx_custom_event(struct rtw_adapter *padapter, char *msg)
 {
-#ifndef CONFIG_IOCTL_CFG80211
-	u8 *buff, *p;
-	union iwreq_data wrqu;
-
-	if ((u32)strlen(msg) > IW_CUSTOM_MAX) {
-		DBG_8192D("%s strlen(msg):%u > IW_CUSTOM_MAX:%u\n", __func__ ,
-			  (u32)strlen(msg), IW_CUSTOM_MAX);
-		return;
-	}
-
-	buff = kzalloc(IW_CUSTOM_MAX+1, GFP_KERNEL);
-	if (!buff)
-		return;
-
-	memcpy(buff, msg, strlen(msg));
-
-	memset(&wrqu, 0, sizeof(wrqu));
-	wrqu.data.length = strlen(msg);
-
-	DBG_8192D("%s %s\n", __func__, buff);
-	wireless_send_event(padapter->pnetdev, IWEVCUSTOM, &wrqu, buff);
-
-	kfree(buff);
-#endif
 }
 
 static void request_wps_pbc_event(struct rtw_adapter *padapter)
 {
-#ifndef CONFIG_IOCTL_CFG80211
-	u8 *buff, *p;
-	union iwreq_data wrqu;
-
-	buff = kmalloc(IW_CUSTOM_MAX, GFP_KERNEL);
-	if (!buff)
-		return;
-
-	memset(buff, 0, IW_CUSTOM_MAX);
-
-	p = buff;
-
-	p+= sprintf(p, "WPS_PBC_START.request = TRUE");
-
-	memset(&wrqu, 0, sizeof(wrqu));
-
-	wrqu.data.length = p-buff;
-
-	wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ?
-			   wrqu.data.length : IW_CUSTOM_MAX;
-
-	DBG_8192D("%s\n", __func__);
-
-	wireless_send_event(padapter->pnetdev, IWEVCUSTOM, &wrqu, buff);
-
-	kfree(buff);
-#endif
 }
 
 void indicate_wx_scan_complete_event(struct rtw_adapter *padapter)
 {
-#ifndef CONFIG_IOCTL_CFG80211
-	union iwreq_data wrqu;
-	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
-
-	memset(&wrqu, 0, sizeof(union iwreq_data));
-
-	wireless_send_event(padapter->pnetdev, SIOCGIWSCAN, &wrqu, NULL);
-#endif
 }
 
 void rtw_indicate_wx_assoc_event(struct rtw_adapter *padapter)
 {
-#ifndef CONFIG_IOCTL_CFG80211
-	union iwreq_data wrqu;
-	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
-
-	memset(&wrqu, 0, sizeof(union iwreq_data));
-
-	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-
-	memcpy(wrqu.ap_addr.sa_data,
-	       pmlmepriv->cur_network.network.MacAddress, ETH_ALEN);
-
-	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
-#endif
 }
 
 void rtw_indicate_wx_disassoc_event(struct rtw_adapter *padapter)
 {
-#ifndef CONFIG_IOCTL_CFG80211
-	union iwreq_data wrqu;
-
-	memset(&wrqu, 0, sizeof(union iwreq_data));
-
-	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-	memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
-
-	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
-#endif
 }
 
 static char *translate_scan(struct rtw_adapter *padapter,
--- a/drivers/staging/rtl8192du/os_dep/mlme_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/mlme_linux.c
@@ -38,17 +38,15 @@ static void _dynamic_check_timer_handlde
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
 
 	rtw_dynamic_check_timer_handlder(adapter);
-
 	_set_timer(&adapter->mlmepriv.dynamic_chk_timer, 2000);
 }
 
-#ifdef CONFIG_IOCTL_CFG80211
 static void _rtw_set_scan_deny_timer_hdl(void *FunctionContext)
 {
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
+
 	rtw_set_scan_deny_timer_hdl(adapter);
 }
-#endif
 
 void rtw_init_mlme_timer(struct rtw_adapter *padapter)
 {
@@ -59,17 +57,13 @@ void rtw_init_mlme_timer(struct rtw_adap
 
 	_init_timer(&(pmlmepriv->dynamic_chk_timer), padapter->pnetdev, _dynamic_check_timer_handlder, padapter);
 
-	#ifdef CONFIG_IOCTL_CFG80211
 	_init_timer(&(pmlmepriv->set_scan_deny_timer), padapter->pnetdev, _rtw_set_scan_deny_timer_hdl, padapter);
-	#endif
 }
 
 void rtw_os_indicate_connect(struct rtw_adapter *adapter)
 {
 
-#ifdef CONFIG_IOCTL_CFG80211
 	rtw_cfg80211_indicate_connect(adapter);
-#endif /* CONFIG_IOCTL_CFG80211 */
 
 	rtw_indicate_wx_assoc_event(adapter);
 	netif_carrier_on(adapter->pnetdev);
@@ -81,9 +75,7 @@ void rtw_os_indicate_connect(struct rtw_
 
 void rtw_os_indicate_scan_done(struct rtw_adapter *padapter, bool aborted)
 {
-#ifdef CONFIG_IOCTL_CFG80211
 	rtw_cfg80211_indicate_scan_done(wdev_to_priv(padapter->rtw_wdev), aborted);
-#endif
 	indicate_wx_scan_complete_event(padapter);
 }
 
@@ -141,17 +133,13 @@ void rtw_reset_securitypriv(struct rtw_a
 
 void rtw_os_indicate_disconnect(struct rtw_adapter *adapter)
 {
-
 	netif_carrier_off(adapter->pnetdev); /*  Do it first for tx broadcast pkt after disconnection issue! */
 
-#ifdef CONFIG_IOCTL_CFG80211
 	rtw_cfg80211_indicate_disconnect(adapter);
-#endif /* CONFIG_IOCTL_CFG80211 */
 
 	rtw_indicate_wx_disassoc_event(adapter);
 
 	 rtw_reset_securitypriv(adapter);
-
 }
 
 void rtw_report_sec_ie(struct rtw_adapter *adapter,u8 authmode,u8 *sec_ie)
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -592,9 +592,7 @@ u8 rtw_init_drv_sw(struct rtw_adapter *p
 	rtw_init_wifidirect_timers(padapter);
 	init_wifidirect_info(padapter, P2P_ROLE_DISABLE);
 	reset_global_wifidirect_info(padapter);
-	#ifdef CONFIG_IOCTL_CFG80211
 	rtw_init_cfg80211_wifidirect_info(padapter);
-	#endif
 #endif /* CONFIG_P2P */
 
 	if (init_mlme_ext_priv(padapter) == _FAIL) {
@@ -660,17 +658,13 @@ void rtw_cancel_all_timer(struct rtw_ada
 
 	_cancel_timer_ex(&padapter->pwrctrlpriv.pwr_state_check_timer);
 
-#ifdef CONFIG_IOCTL_CFG80211
 #ifdef CONFIG_P2P
 	_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
 #endif /* CONFIG_P2P */
-#endif /* CONFIG_IOCTL_CFG80211 */
 
-#ifdef CONFIG_IOCTL_CFG80211
 	_cancel_timer_ex(&padapter->mlmepriv.set_scan_deny_timer);
 	rtw_clear_scan_deny(padapter);
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel set_scan_deny_timer!\n"));
-#endif
 
 	_cancel_timer_ex(&padapter->recvpriv.signal_stat_timer);
 
@@ -777,9 +771,7 @@ static int _netdev_if2_open(struct net_d
 
 		padapter->dir_dev = NULL;
 
-#ifdef CONFIG_IOCTL_CFG80211
 		rtw_cfg80211_init_wiphy(padapter);
-#endif
 
 		padapter->bup = true;
 
@@ -823,18 +815,12 @@ static int netdev_if2_close(struct net_d
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(pnetdev);
 
 	padapter->net_closed = true;
-
-	if (pnetdev)
-	{
+	if (pnetdev) {
 		if (!rtw_netif_queue_stopped(pnetdev))
 			rtw_netif_stop_queue(pnetdev);
 	}
-
-#ifdef CONFIG_IOCTL_CFG80211
 	rtw_scan_abort(padapter);
 	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = false;
-#endif
-
 	return 0;
 }
 
@@ -888,9 +874,7 @@ struct rtw_adapter *rtw_drv_if2_init(str
 	pdvobjpriv->padapters[pdvobjpriv->iface_nums++] = padapter;
 
 	SET_NETDEV_DEV(pnetdev, dvobj_to_dev(pdvobjpriv));
-	#ifdef CONFIG_IOCTL_CFG80211
 	rtw_wdev_alloc(padapter, dvobj_to_dev(pdvobjpriv));
-	#endif /* CONFIG_IOCTL_CFG80211 */
 
 	/* set interface_type/chip_type/HardwareType */
 	padapter->interface_type = primary_padapter->interface_type;
@@ -992,9 +976,7 @@ void rtw_drv_if2_free(struct rtw_adapter
 
 	pnetdev = padapter->pnetdev;
 
-#ifdef CONFIG_IOCTL_CFG80211
 	rtw_wdev_free(padapter->rtw_wdev);
-#endif /* CONFIG_IOCTL_CFG80211 */
 
 	rtw_free_drv_sw(padapter);
 
@@ -1029,9 +1011,7 @@ void rtw_drv_if2_stop(struct rtw_adapter
 		padapter->bup = false;
 	}
 
-	#ifdef CONFIG_IOCTL_CFG80211
 	rtw_wdev_unregister(padapter->rtw_wdev);
-	#endif
 }
 #endif /* end of CONFIG_CONCURRENT_MODE */
 
@@ -1079,9 +1059,7 @@ int _netdev_open(struct net_device *pnet
 		if (padapter->intf_start)
 			padapter->intf_start(padapter);
 
-#ifdef CONFIG_IOCTL_CFG80211
 		rtw_cfg80211_init_wiphy(padapter);
-#endif
 
 		rtw_led_control(padapter, LED_CTL_NO_LINK);
 
@@ -1263,18 +1241,14 @@ static int netdev_close(struct net_devic
 	}
 
 #ifdef CONFIG_P2P
-	#ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled == true)
 		wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = false;
-	#endif
 	rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
 #endif /* CONFIG_P2P */
 
-#ifdef CONFIG_IOCTL_CFG80211
 	rtw_scan_abort(padapter);
 	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = false;
 	padapter->rtw_wdev->iftype = NL80211_IFTYPE_MONITOR; /* set this at the end */
-#endif /* CONFIG_IOCTL_CFG80211 */
 
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-871x_drv - drv_close\n"));
 	DBG_8192D("-871x_drv - drv_close, bup =%d\n", padapter->bup);
@@ -1291,8 +1265,6 @@ void rtw_ndev_destructor(struct net_devi
 {
 	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
-#ifdef CONFIG_IOCTL_CFG80211
 	kfree(ndev->ieee80211_ptr);
-#endif
 	free_netdev(ndev);
 }
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -91,58 +91,40 @@ int rtw_os_recvbuf_resource_free(struct
 
 void rtw_handle_tkip_mic_err(struct rtw_adapter *padapter,u8 bgroup)
 {
-#ifdef CONFIG_IOCTL_CFG80211
-	enum nl80211_key_type key_type;
-#endif
-	union iwreq_data wrqu;
 	struct iw_michaelmicfailure    ev;
-	struct mlme_priv*              pmlmepriv  = &padapter->mlmepriv;
+	struct mlme_priv *pmlmepriv  = &padapter->mlmepriv;
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	enum nl80211_key_type key_type;
+	union iwreq_data wrqu;
 	u32 cur_time = 0;
 
-	if (psecuritypriv->last_mic_err_time == 0)
-	{
+	if (psecuritypriv->last_mic_err_time == 0) {
 		psecuritypriv->last_mic_err_time = rtw_get_current_time();
-	}
-	else
-	{
+	} else {
 		cur_time = rtw_get_current_time();
 
-		if (cur_time - psecuritypriv->last_mic_err_time < 60*HZ)
-		{
+		if (cur_time - psecuritypriv->last_mic_err_time < 60*HZ) {
 			psecuritypriv->btkip_countermeasure = true;
 			psecuritypriv->last_mic_err_time = 0;
 			psecuritypriv->btkip_countermeasure_time = cur_time;
-		}
-		else
-		{
+		} else {
 			psecuritypriv->last_mic_err_time = rtw_get_current_time();
 		}
 	}
 
-#ifdef CONFIG_IOCTL_CFG80211
 	if (bgroup)
-	{
 		key_type |= NL80211_KEYTYPE_GROUP;
-	}
 	else
-	{
 		key_type |= NL80211_KEYTYPE_PAIRWISE;
-	}
 
 	cfg80211_michael_mic_failure(padapter->pnetdev, (u8 *)&pmlmepriv->assoc_bssid[0], key_type, -1,
 		NULL, GFP_ATOMIC);
-#endif
 
 	memset(&ev, 0x00, sizeof(ev));
 	if (bgroup)
-	{
 	    ev.flags |= IW_MICFAILURE_GROUP;
-	}
 	else
-	{
 	    ev.flags |= IW_MICFAILURE_PAIRWISE;
-	}
 
 	ev.src_addr.sa_family = ARPHRD_ETHER;
 	memcpy(ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -145,14 +145,11 @@ static int rtw_android_get_p2p_dev_addr(
 
 static int rtw_android_set_block(struct net_device *net, char *command, int total_len)
 {
-	int ret;
 	struct rtw_adapter *adapter = (struct rtw_adapter *)rtw_netdev_priv(net);
+	int ret;
 	char *block_value = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_BLOCK]) + 1;
 
-	#ifdef CONFIG_IOCTL_CFG80211
 	wdev_to_priv(adapter->rtw_wdev)->block = (*block_value=='0')?false:true;
-	#endif
-
 	return 0;
 }
 
@@ -160,10 +157,8 @@ static int get_int_from_command(char* pc
 {
 	int i = 0;
 
-	for (i = 0; i < strlen(pcmd); i++)
-	{
-		if (pcmd[i] == '=')
-		{
+	for (i = 0; i < strlen(pcmd); i++) {
+		if (pcmd[i] == '=') {
 			/*	Skip the '=' and space characters. */
 			i += 2;
 			break;
@@ -284,15 +279,12 @@ int rtw_android_priv_cmd(struct net_devi
 		break;
 	case ANDROID_WIFI_CMD_P2P_SET_PS:
 		break;
-#ifdef CONFIG_IOCTL_CFG80211
 	case ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE:
 	{
 		int skip = strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE]) + 3;
 		bytes_written = rtw_cfg80211_set_mgnt_wpsp2pie(net, command + skip, priv_cmd.total_len - skip, *(command + skip - 2) - '0');
 		break;
 	}
-#endif /* CONFIG_IOCTL_CFG80211 */
-
 	default:
 		DBG_8192D("Unknown PRIVATE command %s - ignored\n", command);
 		snprintf(command, 3, "OK");
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -678,11 +678,8 @@ static struct rtw_adapter *rtw_usb_if1_i
 	if (rtw_handle_dualmac(padapter, 1) != _SUCCESS)
 		goto free_adapter;
 
-#ifdef CONFIG_IOCTL_CFG80211
-	if (rtw_wdev_alloc(padapter, dvobj_to_dev(dvobj)) != 0) {
+	if (rtw_wdev_alloc(padapter, dvobj_to_dev(dvobj)) != 0)
 		goto handle_dualmac;
-	}
-#endif
 
 	/* step 2. hook HalFunc, allocate HalData */
 	if (padapter->chip_type == RTL8192D) {
@@ -756,10 +753,8 @@ free_hal_data:
 		kfree(padapter->HalData);
 free_wdev:
 	if (status != _SUCCESS) {
-		#ifdef CONFIG_IOCTL_CFG80211
 		rtw_wdev_unregister(padapter->rtw_wdev);
 		rtw_wdev_free(padapter->rtw_wdev);
-		#endif
 	}
 handle_dualmac:
 	if (status != _SUCCESS)
@@ -804,10 +799,8 @@ static void rtw_usb_if1_deinit(struct rt
 	/* s6. */
 	rtw_handle_dualmac(if1, 0);
 
-#ifdef CONFIG_IOCTL_CFG80211
 	rtw_wdev_unregister(if1->rtw_wdev);
 	rtw_wdev_free(if1->rtw_wdev);
-#endif /* CONFIG_IOCTL_CFG80211 */
 
 	rtw_free_drv_sw(if1);
 

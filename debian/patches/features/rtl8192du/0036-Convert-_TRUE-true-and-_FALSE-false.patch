From bf7587ae8b0e4da2e7a8c9e3dc26d92a8943d934 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Thu, 18 Apr 2013 21:28:42 -0500
Subject: [PATCH 036/210] Convert _TRUE => true and _FALSE => false

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_ap.c           | 232 ++++++++++++-----------
 core/rtw_cmd.c          | 104 +++++------
 core/rtw_debug.c        |   2 +-
 core/rtw_eeprom.c       |  64 +++----
 core/rtw_efuse.c        |  66 +++----
 core/rtw_ieee80211.c    |  76 ++++----
 core/rtw_io.c           |  12 +-
 core/rtw_ioctl_set.c    | 196 ++++++++++----------
 core/rtw_iol.c          |   6 +-
 core/rtw_mlme.c         | 248 ++++++++++++-------------
 core/rtw_mlme_ext.c     | 387 +++++++++++++++++++--------------------
 core/rtw_p2p.c          | 156 ++++++++--------
 core/rtw_pwrctrl.c      | 156 ++++++++--------
 core/rtw_recv.c         | 164 ++++++++---------
 core/rtw_security.c     |  17 +-
 core/rtw_sreset.c       |   6 +-
 core/rtw_sta_mgt.c      |  40 ++--
 core/rtw_tdls.c         |  66 ++++---
 core/rtw_wlan_util.c    |  96 +++++-----
 core/rtw_xmit.c         | 150 +++++++--------
 hal/hal_com.c           |   8 +-
 hal/hal_intf.c          |  32 ++--
 hal/rtl8192d_cmd.c      |  52 +++---
 hal/rtl8192d_dm.c       | 208 ++++++++++-----------
 hal/rtl8192d_hal_init.c | 170 ++++++++---------
 hal/rtl8192d_mp.c       |  82 ++++-----
 hal/rtl8192d_phycfg.c   | 236 ++++++++++++------------
 hal/rtl8192d_rf6052.c   |  80 ++++----
 hal/rtl8192d_rxdesc.c   |  12 +-
 hal/rtl8192du_led.c     | 478 ++++++++++++++++++++++++------------------------
 hal/rtl8192du_xmit.c    |  66 +++----
 hal/usb_halinit.c       | 260 +++++++++++++-------------
 hal/usb_ops_linux.c     |  58 +++---
 include/basic_types.h   |  12 --
 include/ieee80211.h     |  12 +-
 include/osdep_service.h |   8 +-
 include/rtl8192d_hal.h  |  34 ++--
 include/rtl8192d_spec.h |  10 +-
 include/rtw_mlme.h      |  10 +-
 include/rtw_mp.h        |   4 +-
 include/rtw_pwrctrl.h   |   6 +-
 include/rtw_security.h  |   2 +-
 include/usb_ops.h       |   8 +-
 include/wifi.h          |  10 +-
 os_dep/ioctl_cfg80211.c | 266 +++++++++++++--------------
 os_dep/ioctl_linux.c    | 362 ++++++++++++++++++------------------
 os_dep/os_intfs.c       | 160 ++++++++--------
 os_dep/osdep_service.c  |  28 +--
 os_dep/recv_linux.c     |  20 +-
 os_dep/rtw_android.c    |  10 +-
 os_dep/usb_intf.c       | 106 +++++------
 os_dep/usb_ops_linux.c  |  22 +--
 os_dep/xmit_linux.c     |  16 +-
 53 files changed, 2524 insertions(+), 2568 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_ap.c
+++ b/drivers/staging/rtl8192du/core/rtw_ap.c
@@ -46,7 +46,7 @@ void init_mlme_ap_info(_adapter *padapte
 	//for ACL
 	_rtw_init_queue(&pacl_list->acl_node_q);
 
-	//pmlmeext->bstart_bss = _FALSE;
+	//pmlmeext->bstart_bss = false;
 
 	start_ap_mode(padapter);
 }
@@ -62,8 +62,8 @@ void free_mlme_ap_info(_adapter *padapte
 
 	//stop_ap_mode(padapter);
 
-	pmlmepriv->update_bcn = _FALSE;
-	pmlmeext->bstart_bss = _FALSE;
+	pmlmepriv->update_bcn = false;
+	pmlmeext->bstart_bss = false;
 
 	rtw_sta_flush(padapter);
 
@@ -95,7 +95,7 @@ static void update_BCNTIM(_adapter *pada
 
 	//update TIM IE
 	//if(pstapriv->tim_bitmap)
-	if(_TRUE)
+	if(true)
 	{
 		u8 *p, *dst_ie, *premainder_ie=NULL, *pbackup_remainder_ie=NULL;
 		u16 tim_bitmap_le;
@@ -208,7 +208,7 @@ static void update_BCNTIM(_adapter *pada
 void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *data, u8 len)
 {
 	PNDIS_802_11_VARIABLE_IEs	pIE;
-	u8	bmatch = _FALSE;
+	u8	bmatch = false;
 	u8	*pie = pnetwork->IEs;
 	u8	*p, *dst_ie, *premainder_ie=NULL, *pbackup_remainder_ie=NULL;
 	u32	i, offset, ielen, ie_offset, remainder_ielen = 0;
@@ -225,7 +225,7 @@ void rtw_add_bcn_ie(_adapter *padapter,
 		{
 			p = (u8 *)pIE;
 			ielen = pIE->Length;
-			bmatch = _TRUE;
+			bmatch = true;
 			break;
 		}
 
@@ -318,7 +318,7 @@ void rtw_remove_bcn_ie(_adapter *padapte
 u8 chk_sta_is_alive(struct sta_info *psta);
 u8 chk_sta_is_alive(struct sta_info *psta)
 {
-	u8 ret = _FALSE;
+	u8 ret = false;
 	#ifdef DBG_EXPIRATION_CHK
 	DBG_871X("sta:"MAC_FMT", rssi:%d, rx:"STA_PKTS_FMT", expire_to:%u, %s%ssq_len:%u\n"
 		, MAC_ARG(psta->hwaddr)
@@ -337,12 +337,12 @@ u8 chk_sta_is_alive(struct sta_info *pst
 	{
 		#if 0
 		if(psta->state&WIFI_SLEEP_STATE)
-			ret = _TRUE;
+			ret = true;
 		#endif
 	}
 	else
 	{
-		ret = _TRUE;
+		ret = true;
 	}
 
 	sta_update_last_rx_pkts(psta);
@@ -368,12 +368,12 @@ void	expire_timeout_chk(_adapter *padapt
 
 	//check auth_queue
 	#ifdef DBG_EXPIRATION_CHK
-	if (rtw_end_of_queue_search(phead, plist) == _FALSE) {
+	if (rtw_end_of_queue_search(phead, plist) == false) {
 		DBG_871X(FUNC_NDEV_FMT" auth_list, cnt:%u\n"
 			, FUNC_NDEV_ARG(padapter->pnetdev), pstapriv->auth_list_cnt);
 	}
 	#endif
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, auth_list);
 		plist = get_next(plist);
@@ -413,12 +413,12 @@ void	expire_timeout_chk(_adapter *padapt
 
 	//check asoc_queue
 	#ifdef DBG_EXPIRATION_CHK
-	if (rtw_end_of_queue_search(phead, plist) == _FALSE) {
+	if (rtw_end_of_queue_search(phead, plist) == false) {
 		DBG_871X(FUNC_NDEV_FMT" asoc_list, cnt:%u\n"
 			, FUNC_NDEV_ARG(padapter->pnetdev), pstapriv->asoc_list_cnt);
 	}
 	#endif
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 		plist = get_next(plist);
@@ -472,7 +472,7 @@ void	expire_timeout_chk(_adapter *padapt
 
 					//to update bcn with tim_bitmap for this station
 					pstapriv->tim_bitmap |= BIT(psta->aid);
-					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+					update_beacon(padapter, _TIM_IE_, NULL, false);
 
 					if(!pmlmeext->active_keep_alive_check)
 						continue;
@@ -495,7 +495,7 @@ void	expire_timeout_chk(_adapter *padapt
 			pstapriv->asoc_list_cnt--;
 
 			DBG_871X("asoc expire "MAC_FMT", state=0x%x\n", MAC_ARG(psta->hwaddr), psta->state);
-			updated = ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_DEAUTH_LEAVING);
+			updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
 		}
 		else
 		{
@@ -557,7 +557,7 @@ if (chk_alive_num) {
 		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 		rtw_list_delete(&psta->asoc_list);
 		pstapriv->asoc_list_cnt--;
-		updated = ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_DEAUTH_LEAVING);
+		updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
 		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
 	}
@@ -576,7 +576,7 @@ static void add_RATid(_adapter *padapter
 	int i;
 	u8 rf_type;
 	u32 init_rate=0;
-	unsigned char sta_band = 0, raid, shortGIrate = _FALSE;
+	unsigned char sta_band = 0, raid, shortGIrate = false;
 	unsigned char limit;
 	unsigned int tx_ra_bitmap=0;
 	struct ht_priv	*psta_ht = NULL;
@@ -760,7 +760,7 @@ static void add_RATid(_adapter *padapter
 
 		arg |= BIT(7);//support entry 2~31
 
-		if (shortGIrate==_TRUE)
+		if (shortGIrate==true)
 			arg |= BIT(5);
 
 		tx_ra_bitmap |= ((raid<<28)&0xf0000000);
@@ -774,7 +774,7 @@ static void add_RATid(_adapter *padapter
 		//arg[5] = Short GI
 		rtw_hal_add_ra_tid(padapter, tx_ra_bitmap, arg);
 
-		if (shortGIrate==_TRUE)
+		if (shortGIrate==true)
 			init_rate |= BIT(6);
 
 		//set ra_id, init_rate
@@ -807,7 +807,7 @@ static void update_bmc_sta(_adapter *pad
 		psta->mac_id = psta->aid + 1;
 
 		psta->qos_option = 0;
-		psta->htpriv.ht_option = _FALSE;
+		psta->htpriv.ht_option = false;
 
 		psta->ieee8021x_blocked = 0;
 
@@ -848,7 +848,7 @@ static void update_bmc_sta(_adapter *pad
 
 		//DBG_871X("Add id %d val %08x to ratr for bmc sta\n", psta->aid, tx_ra_bitmap);
 
-		//if(pHalData->fw_ractrl == _TRUE)
+		//if(pHalData->fw_ractrl == true)
 		{
 			u8 arg = 0;
 
@@ -856,7 +856,7 @@ static void update_bmc_sta(_adapter *pad
 
 			arg |= BIT(7);
 
-			//if (shortGIrate==_TRUE)
+			//if (shortGIrate==true)
 			//	arg |= BIT(5);
 
 			tx_ra_bitmap |= ((raid<<28)&0xf0000000);
@@ -910,9 +910,9 @@ void update_sta_info_apmode(_adapter *pa
 	psta->mac_id = psta->aid+1;
 
 	if(psecuritypriv->dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)
-		psta->ieee8021x_blocked = _TRUE;
+		psta->ieee8021x_blocked = true;
 	else
-		psta->ieee8021x_blocked = _FALSE;
+		psta->ieee8021x_blocked = false;
 
 
 	//update sta's cap
@@ -929,7 +929,7 @@ void update_sta_info_apmode(_adapter *pa
 		//check if sta support s Short GI
 		if((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))
 		{
-			phtpriv_sta->sgi = _TRUE;
+			phtpriv_sta->sgi = true;
 		}
 
 		// bwmode
@@ -941,14 +941,14 @@ void update_sta_info_apmode(_adapter *pa
 
 		}
 
-		psta->qos_option = _TRUE;
+		psta->qos_option = true;
 
 	}
 	else
 	{
-		phtpriv_sta->ampdu_enable = _FALSE;
+		phtpriv_sta->ampdu_enable = false;
 
-		phtpriv_sta->sgi = _FALSE;
+		phtpriv_sta->sgi = false;
 		phtpriv_sta->bwmode = HT_CHANNEL_WIDTH_20;
 		phtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 	}
@@ -1043,7 +1043,7 @@ static void start_bss_network(_adapter *
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 #endif //CONFIG_P2P
 	u8 cbw40_enable=0;
-	u8 change_band = _FALSE;
+	u8 change_band = false;
 	//DBG_871X("%s\n", __FUNCTION__);
 
 	bcn_interval = (u16)pnetwork->Configuration.BeaconPeriod;
@@ -1057,27 +1057,27 @@ static void start_bss_network(_adapter *
 	//and at first time the security ie ( RSN/WPA IE) will not include in beacon.
 	if(NULL == rtw_get_wps_ie(pnetwork->IEs+_FIXED_IE_LENGTH_, pnetwork->IELength-_FIXED_IE_LENGTH_, NULL, NULL))
 	{
-		pmlmeext->bstart_bss = _TRUE;
+		pmlmeext->bstart_bss = true;
 	}
 
 	//todo: update wmm, ht cap
 	//pmlmeinfo->WMM_enable;
 	//pmlmeinfo->HT_enable;
 	if(pmlmepriv->qospriv.qos_option)
-		pmlmeinfo->WMM_enable = _TRUE;
+		pmlmeinfo->WMM_enable = true;
 
 	if(pmlmepriv->htpriv.ht_option)
 	{
-		pmlmeinfo->WMM_enable = _TRUE;
-		pmlmeinfo->HT_enable = _TRUE;
-		//pmlmeinfo->HT_info_enable = _TRUE;
-		//pmlmeinfo->HT_caps_enable = _TRUE;
+		pmlmeinfo->WMM_enable = true;
+		pmlmeinfo->HT_enable = true;
+		//pmlmeinfo->HT_info_enable = true;
+		//pmlmeinfo->HT_caps_enable = true;
 
 		update_hw_ht_param(padapter);
 	}
 
 
-	if(pmlmepriv->cur_network.join_res != _TRUE) //setting only at  first time
+	if(pmlmepriv->cur_network.join_res != true) //setting only at  first time
 	{
 		//WEP Key will be set before this function, do not clear CAM.
 		if ((psecuritypriv->dot11PrivacyAlgrthm != _WEP40_) && (psecuritypriv->dot11PrivacyAlgrthm != _WEP104_))
@@ -1112,7 +1112,7 @@ static void start_bss_network(_adapter *
 	//Beacon Control related register
 	rtw_hal_set_hwreg(padapter, HW_VAR_BEACON_INTERVAL, (u8 *)(&bcn_interval));
 
-	if(pmlmepriv->cur_network.join_res != _TRUE) //setting only at  first time
+	if(pmlmepriv->cur_network.join_res != true) //setting only at  first time
 	{
 		u32 initialgain;
 
@@ -1121,7 +1121,7 @@ static void start_bss_network(_adapter *
 
 		//disable dynamic functions, such as high power, DIG
 		//Save_DM_Func_Flag(padapter);
-		//Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
+		//Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, false);
 
 #ifdef CONFIG_CONCURRENT_MODE
 		if(padapter->adapter_type > PRIMARY_ADAPTER)
@@ -1131,7 +1131,7 @@ static void start_bss_network(_adapter *
 				_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 
 				//turn on dynamic functions on PRIMARY_ADAPTER, dynamic functions only runs at PRIMARY_ADAPTER
-				Switch_DM_Func(pbuddy_adapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, _TRUE);
+				Switch_DM_Func(pbuddy_adapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true);
 
 				rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
 			}
@@ -1140,7 +1140,7 @@ static void start_bss_network(_adapter *
 #endif
 		{
 			//turn on dynamic functions
-			Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, _TRUE);
+			Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true);
 
 			rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
 		}
@@ -1199,7 +1199,7 @@ static void start_bss_network(_adapter *
 	{
 		set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
 	}
-	else if(check_buddy_fwstate(padapter, _FW_LINKED)==_TRUE)//only second adapter can enter AP Mode
+	else if(check_buddy_fwstate(padapter, _FW_LINKED)==true)//only second adapter can enter AP Mode
 	{
 		_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -1211,7 +1211,7 @@ static void start_bss_network(_adapter *
 
 		if((cur_channel <= 14 && pbuddy_mlmeext->cur_channel >= 36) ||
 		(cur_channel >= 36 && pbuddy_mlmeext->cur_channel <= 14))
-			change_band = _TRUE;
+			change_band = true;
 
 		cur_channel = pbuddy_mlmeext->cur_channel;
 		if(cur_bwmode == HT_CHANNEL_WIDTH_40)
@@ -1284,7 +1284,7 @@ static void start_bss_network(_adapter *
 		pmlmeext->cur_ch_offset = cur_ch_offset;
 
 		//buddy interface band is different from current interface, update ERP, support rate, ext support rate IE
-		if(change_band == _TRUE)
+		if(change_band == true)
 			change_band_update_ie(padapter, pnetwork);
 	}
 #else
@@ -1318,9 +1318,9 @@ static void start_bss_network(_adapter *
 	pwdinfo->p2p_group_ssid_len = pnetwork->Ssid.SsidLength;
 #endif //CONFIG_P2P
 
-	if(_TRUE == pmlmeext->bstart_bss)
+	if(true == pmlmeext->bstart_bss)
 	{
-		update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+		update_beacon(padapter, _TIM_IE_, NULL, false);
 
 #ifndef CONFIG_INTERRUPT_BASED_TXBCN //other case will  tx beacon when bcn interrupt coming in.
 		//issue beacon frame
@@ -1341,7 +1341,7 @@ int rtw_check_beacon_data(_adapter *pada
 	u8 *pHT_caps_ie=NULL;
 	u8 *pHT_info_ie=NULL;
 	struct sta_info *psta = NULL;
-	u16 cap, ht_cap=_FALSE;
+	u16 cap, ht_cap=false;
 	uint ie_len = 0;
 	int group_cipher, pairwise_cipher;
 	u8	channel, network_type, supportRate[NDIS_802_11_LENGTH_RATES_EX];
@@ -1370,7 +1370,7 @@ int rtw_check_beacon_data(_adapter *pada
 
 	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return _FAIL;
 
 
@@ -1631,7 +1631,7 @@ int rtw_check_beacon_data(_adapter *pada
 		pHT_caps_ie=p;
 
 
-		ht_cap = _TRUE;
+		ht_cap = true;
 		network_type |= WIRELESS_11_24N;
 
 
@@ -1688,24 +1688,24 @@ int rtw_check_beacon_data(_adapter *pada
 	pmlmepriv->cur_network.network_type = network_type;
 
 
-	pmlmepriv->htpriv.ht_option = _FALSE;
+	pmlmepriv->htpriv.ht_option = false;
 #ifdef CONFIG_80211N_HT
 	if( (psecuritypriv->wpa2_pairwise_cipher&WPA_CIPHER_TKIP) ||
 		      (psecuritypriv->wpa_pairwise_cipher&WPA_CIPHER_TKIP))
 	{
 		//todo:
-		//ht_cap = _FALSE;
+		//ht_cap = false;
 	}
 
 	//ht_cap
-	if(pregistrypriv->ht_enable && ht_cap==_TRUE)
+	if(pregistrypriv->ht_enable && ht_cap==true)
 	{
-		pmlmepriv->htpriv.ht_option = _TRUE;
+		pmlmepriv->htpriv.ht_option = true;
 		pmlmepriv->qospriv.qos_option = 1;
 
 		if(pregistrypriv->ampdu_enable==1)
 		{
-			pmlmepriv->htpriv.ampdu_enable = _TRUE;
+			pmlmepriv->htpriv.ampdu_enable = true;
 		}
 
 		HT_caps_handler(padapter, (PNDIS_802_11_VARIABLE_IEs)pHT_caps_ie);
@@ -1734,7 +1734,7 @@ int rtw_check_beacon_data(_adapter *pada
 	psta->state |= WIFI_AP_STATE;		//Aries, add,fix bug of flush_cam_entry at STOP AP mode , 0724
 	rtw_indicate_connect( padapter);
 
-	pmlmepriv->cur_network.join_res = _TRUE;//for check if already set beacon
+	pmlmepriv->cur_network.join_res = true;//for check if already set beacon
 
 	//update bc/mc sta_info
 	//update_bmc_sta(padapter);
@@ -1757,7 +1757,7 @@ int rtw_acl_add_sta(_adapter *padapter,
 {
 	_irqL irqL;
 	_list	*plist, *phead;
-	u8 added = _FALSE;
+	u8 added = false;
 	int i, ret=0;
 	struct rtw_wlan_acl_node *paclnode;
 	struct sta_priv *pstapriv = &padapter->stapriv;
@@ -1775,16 +1775,16 @@ int rtw_acl_add_sta(_adapter *padapter,
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
 
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
 		plist = get_next(plist);
 
 		if(_rtw_memcmp(paclnode->addr, addr, ETH_ALEN))
 		{
-			if(paclnode->valid == _TRUE)
+			if(paclnode->valid == true)
 			{
-				added = _TRUE;
+				added = true;
 				DBG_871X("%s, sta has been added\n", __func__);
 				break;
 			}
@@ -1794,7 +1794,7 @@ int rtw_acl_add_sta(_adapter *padapter,
 	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
 
 
-	if(added == _TRUE)
+	if(added == true)
 		return ret;
 
 
@@ -1804,13 +1804,13 @@ int rtw_acl_add_sta(_adapter *padapter,
 	{
 		paclnode = &pacl_list->aclnode[i];
 
-		if(paclnode->valid == _FALSE)
+		if(paclnode->valid == false)
 		{
 			_rtw_init_listhead(&paclnode->list);
 
 			_rtw_memcpy(paclnode->addr, addr, ETH_ALEN);
 
-			paclnode->valid = _TRUE;
+			paclnode->valid = true;
 
 			rtw_list_insert_tail(&paclnode->list, get_list_head(pacl_node_q));
 
@@ -1844,16 +1844,16 @@ int rtw_acl_remove_sta(_adapter *padapte
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
 
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
 		plist = get_next(plist);
 
 		if(_rtw_memcmp(paclnode->addr, addr, ETH_ALEN))
 		{
-			if(paclnode->valid == _TRUE)
+			if(paclnode->valid == true)
 			{
-				paclnode->valid = _FALSE;
+				paclnode->valid = false;
 
 				rtw_list_delete(&paclnode->list);
 
@@ -2048,7 +2048,7 @@ void update_beacon(_adapter *padapter, u
 	pmlmeext = &(padapter->mlmeextpriv);
 	//pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	if(_FALSE == pmlmeext->bstart_bss)
+	if(false == pmlmeext->bstart_bss)
 		return;
 
 	_enter_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);
@@ -2101,7 +2101,7 @@ void update_beacon(_adapter *padapter, u
 			break;
 	}
 
-	pmlmepriv->update_bcn = _TRUE;
+	pmlmepriv->update_bcn = true;
 
 	_exit_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);
 
@@ -2132,7 +2132,7 @@ static int rtw_ht_operation_update(_adap
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct ht_priv	*phtpriv_ap = &pmlmepriv->htpriv;
 
-	if(pmlmepriv->htpriv.ht_option == _TRUE)
+	if(pmlmepriv->htpriv.ht_option == true)
 		return 0;
 
 	//if (!iface->conf->ieee80211n || iface->conf->ht_op_mode_fixed)
@@ -2201,7 +2201,7 @@ static int rtw_ht_operation_update(_adap
 void associated_clients_update(_adapter *padapter, u8 updated)
 {
 	//update associcated stations cap.
-	if(updated == _TRUE)
+	if(updated == true)
 	{
 		_irqL irqL;
 		_list	*phead, *plist;
@@ -2214,7 +2214,7 @@ void associated_clients_update(_adapter
 		plist = get_next(phead);
 
 		//check asoc_queue
-		while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+		while ((rtw_end_of_queue_search(phead, plist)) == false)
 		{
 			psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 
@@ -2232,7 +2232,7 @@ void associated_clients_update(_adapter
 /* called > TSR LEVEL for USB or SDIO Interface*/
 void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta)
 {
-	u8 beacon_updated = _FALSE;
+	u8 beacon_updated = false;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
 
@@ -2260,8 +2260,8 @@ void bss_cap_update_on_sta_join(_adapter
 			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
 				(pmlmepriv->num_sta_no_short_preamble == 1))
 			{
-				beacon_updated = _TRUE;
-				update_beacon(padapter, 0xFF, NULL, _TRUE);
+				beacon_updated = true;
+				update_beacon(padapter, 0xFF, NULL, true);
 			}
 
 		}
@@ -2277,8 +2277,8 @@ void bss_cap_update_on_sta_join(_adapter
 			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
 				(pmlmepriv->num_sta_no_short_preamble == 0))
 			{
-				beacon_updated = _TRUE;
-				update_beacon(padapter, 0xFF, NULL, _TRUE);
+				beacon_updated = true;
+				update_beacon(padapter, 0xFF, NULL, true);
 			}
 
 		}
@@ -2303,8 +2303,8 @@ void bss_cap_update_on_sta_join(_adapter
 
 			if (pmlmepriv->num_sta_non_erp == 1)
 			{
-				beacon_updated = _TRUE;
-				update_beacon(padapter, _ERPINFO_IE_, NULL, _TRUE);
+				beacon_updated = true;
+				update_beacon(padapter, _ERPINFO_IE_, NULL, true);
 			}
 		}
 
@@ -2319,8 +2319,8 @@ void bss_cap_update_on_sta_join(_adapter
 
 			if (pmlmepriv->num_sta_non_erp == 0)
 			{
-				beacon_updated = _TRUE;
-				update_beacon(padapter, _ERPINFO_IE_, NULL, _TRUE);
+				beacon_updated = true;
+				update_beacon(padapter, _ERPINFO_IE_, NULL, true);
 			}
 		}
 
@@ -2349,8 +2349,8 @@ void bss_cap_update_on_sta_join(_adapter
 			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
 				 (pmlmepriv->num_sta_no_short_slot_time == 1))
 			{
-				beacon_updated = _TRUE;
-				update_beacon(padapter, 0xFF, NULL, _TRUE);
+				beacon_updated = true;
+				update_beacon(padapter, 0xFF, NULL, true);
 			}
 
 		}
@@ -2366,8 +2366,8 @@ void bss_cap_update_on_sta_join(_adapter
 			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
 				 (pmlmepriv->num_sta_no_short_slot_time == 0))
 			{
-				beacon_updated = _TRUE;
-				update_beacon(padapter, 0xFF, NULL, _TRUE);
+				beacon_updated = true;
+				update_beacon(padapter, 0xFF, NULL, true);
 			}
 		}
 	}
@@ -2415,7 +2415,7 @@ void bss_cap_update_on_sta_join(_adapter
 			psta->no_ht_set = 1;
 			pmlmepriv->num_sta_no_ht++;
 		}
-		if(pmlmepriv->htpriv.ht_option == _TRUE) {
+		if(pmlmepriv->htpriv.ht_option == true) {
 			DBG_871X("%s STA " MAC_FMT
 				   " - no HT, num of non-HT stations %d\n",
 				   __FUNCTION__, MAC_ARG(psta->hwaddr),
@@ -2425,8 +2425,8 @@ void bss_cap_update_on_sta_join(_adapter
 
 	if (rtw_ht_operation_update(padapter) > 0)
 	{
-		update_beacon(padapter, _HT_CAPABILITY_IE_, NULL, _FALSE);
-		update_beacon(padapter, _HT_ADD_INFO_IE_, NULL, _TRUE);
+		update_beacon(padapter, _HT_CAPABILITY_IE_, NULL, false);
+		update_beacon(padapter, _HT_ADD_INFO_IE_, NULL, true);
 	}
 
 #endif /* CONFIG_80211N_HT */
@@ -2440,7 +2440,7 @@ void bss_cap_update_on_sta_join(_adapter
 
 u8 bss_cap_update_on_sta_leave(_adapter *padapter, struct sta_info *psta)
 {
-	u8 beacon_updated = _FALSE;
+	u8 beacon_updated = false;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
 
@@ -2453,8 +2453,8 @@ u8 bss_cap_update_on_sta_leave(_adapter
 		if (pmlmeext->cur_wireless_mode > WIRELESS_11B
 		    && pmlmepriv->num_sta_no_short_preamble == 0)
 		{
-			beacon_updated = _TRUE;
-			update_beacon(padapter, 0xFF, NULL, _TRUE);
+			beacon_updated = true;
+			update_beacon(padapter, 0xFF, NULL, true);
 		}
 	}
 
@@ -2463,8 +2463,8 @@ u8 bss_cap_update_on_sta_leave(_adapter
 		pmlmepriv->num_sta_non_erp--;
 		if (pmlmepriv->num_sta_non_erp == 0)
 		{
-			beacon_updated = _TRUE;
-			update_beacon(padapter, _ERPINFO_IE_, NULL, _TRUE);
+			beacon_updated = true;
+			update_beacon(padapter, _ERPINFO_IE_, NULL, true);
 		}
 	}
 
@@ -2474,8 +2474,8 @@ u8 bss_cap_update_on_sta_leave(_adapter
 		if (pmlmeext->cur_wireless_mode > WIRELESS_11B
 		    && pmlmepriv->num_sta_no_short_slot_time == 0)
 		{
-			beacon_updated = _TRUE;
-			update_beacon(padapter, 0xFF, NULL, _TRUE);
+			beacon_updated = true;
+			update_beacon(padapter, 0xFF, NULL, true);
 		}
 	}
 
@@ -2498,8 +2498,8 @@ u8 bss_cap_update_on_sta_leave(_adapter
 
 	if (rtw_ht_operation_update(padapter) > 0)
 	{
-		update_beacon(padapter, _HT_CAPABILITY_IE_, NULL, _FALSE);
-		update_beacon(padapter, _HT_ADD_INFO_IE_, NULL, _TRUE);
+		update_beacon(padapter, _HT_CAPABILITY_IE_, NULL, false);
+		update_beacon(padapter, _HT_ADD_INFO_IE_, NULL, true);
 	}
 
 #endif /* CONFIG_80211N_HT */
@@ -2516,7 +2516,7 @@ u8 bss_cap_update_on_sta_leave(_adapter
 u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, bool active, u16 reason)
 {
 	_irqL irqL;
-	u8 beacon_updated = _FALSE;
+	u8 beacon_updated = false;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct sta_priv *pstapriv = &padapter->stapriv;
@@ -2533,14 +2533,14 @@ u8 ap_free_sta(_adapter *padapter, struc
 	psta->htpriv.agg_enable_bitmap = 0x0;//reset
 	psta->htpriv.candidate_tid_bitmap = 0x0;//reset
 
-	if (active == _TRUE)
+	if (active == true)
 		issue_deauth(padapter, psta->hwaddr, reason);
 
 	//report_del_sta_event(padapter, psta->hwaddr, reason);
 
 	//clear cam entry / key
 	//clear_cam_entry(padapter, (psta->mac_id + 3));
-	rtw_clearstakey_cmd(padapter, (u8*)psta, (u8)(psta->mac_id + 3), _TRUE);
+	rtw_clearstakey_cmd(padapter, (u8*)psta, (u8)(psta->mac_id + 3), true);
 
 
 	_enter_critical_bh(&psta->lock, &irqL);
@@ -2597,7 +2597,7 @@ int rtw_ap_inform_ch_switch(_adapter *pa
 	plist = get_next(phead);
 
 	/* for each sta in asoc_queue */
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 		plist = get_next(plist);
@@ -2634,7 +2634,7 @@ int rtw_sta_flush(_adapter *padapter)
 	plist = get_next(phead);
 
 	//free sta asoc_queue
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 
@@ -2644,7 +2644,7 @@ int rtw_sta_flush(_adapter *padapter)
 		pstapriv->asoc_list_cnt--;
 
 		//_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-		ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_DEAUTH_LEAVING);
+		ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
 		//_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	}
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
@@ -2652,7 +2652,7 @@ int rtw_sta_flush(_adapter *padapter)
 
 	issue_deauth(padapter, bc_addr, WLAN_REASON_DEAUTH_LEAVING);
 
-	associated_clients_update(padapter, _TRUE);
+	associated_clients_update(padapter, true);
 
 	return ret;
 
@@ -2679,16 +2679,16 @@ void sta_info_update(_adapter *padapter,
 	//update 802.11n ht cap.
 	if(WLAN_STA_HT&flags)
 	{
-		psta->htpriv.ht_option = _TRUE;
+		psta->htpriv.ht_option = true;
 		psta->qos_option = 1;
 	}
 	else
 	{
-		psta->htpriv.ht_option = _FALSE;
+		psta->htpriv.ht_option = false;
 	}
 
-	if(pmlmepriv->htpriv.ht_option == _FALSE)
-		psta->htpriv.ht_option = _FALSE;
+	if(pmlmepriv->htpriv.ht_option == false)
+		psta->htpriv.ht_option = false;
 #endif
 
 
@@ -2715,10 +2715,10 @@ void start_ap_mode(_adapter *padapter)
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
 
-	pmlmepriv->update_bcn = _FALSE;
+	pmlmepriv->update_bcn = false;
 
 	//init_mlme_ap_info(padapter);
-	pmlmeext->bstart_bss = _FALSE;
+	pmlmeext->bstart_bss = false;
 
 	pmlmepriv->num_sta_non_erp = 0;
 
@@ -2732,9 +2732,9 @@ void start_ap_mode(_adapter *padapter)
 
 	pmlmepriv->num_sta_ht_20mhz = 0;
 
-	pmlmepriv->olbc = _FALSE;
+	pmlmepriv->olbc = false;
 
-	pmlmepriv->olbc_ht = _FALSE;
+	pmlmepriv->olbc_ht = false;
 
 #ifdef CONFIG_80211N_HT
 	pmlmepriv->ht_op_mode = 0;
@@ -2758,7 +2758,7 @@ void start_ap_mode(_adapter *padapter)
 	for(i = 0; i < NUM_ACL; i++)
 	{
 		_rtw_init_listhead(&pacl_list->aclnode[i].list);
-		pacl_list->aclnode[i].valid = _FALSE;
+		pacl_list->aclnode[i].valid = false;
 	}
 
 }
@@ -2775,8 +2775,8 @@ void stop_ap_mode(_adapter *padapter)
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
 	_queue	*pacl_node_q =&pacl_list->acl_node_q;
 
-	pmlmepriv->update_bcn = _FALSE;
-	pmlmeext->bstart_bss = _FALSE;
+	pmlmepriv->update_bcn = false;
+	pmlmeext->bstart_bss = false;
 	//_rtw_spinlock_free(&pmlmepriv->bcn_update_lock);
 
 	//reset and init security priv , this can refine with rtw_reset_securitypriv
@@ -2788,14 +2788,12 @@ void stop_ap_mode(_adapter *padapter)
 	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
-	{
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
 		plist = get_next(plist);
 
-		if(paclnode->valid == _TRUE)
-		{
-			paclnode->valid = _FALSE;
+		if(paclnode->valid == true) {
+			paclnode->valid = false;
 
 			rtw_list_delete(&paclnode->list);
 
--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -114,7 +114,7 @@ exit:
 
 #ifdef CONFIG_C2H_WK
 	_init_workitem(&pevtpriv->c2h_wk, c2h_wk_callback, NULL);
-	pevtpriv->c2h_wk_alive = _FALSE;
+	pevtpriv->c2h_wk_alive = false;
 	pevtpriv->c2h_queue = rtw_cbuf_alloc(C2H_QUEUE_MAX_LEN+1);
 #endif
 
@@ -268,7 +268,7 @@ _func_exit_;
 int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj);
 int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
 {
-	u8 bAllow = _FALSE; //set to _TRUE to allow enqueuing cmd when hw_init_completed is _FALSE
+	u8 bAllow = false; //set to true to allow enqueuing cmd when hw_init_completed is false
 
 	#ifdef SUPPORT_HW_RFOFF_DETECTED
 	//To decide allow or not
@@ -280,16 +280,16 @@ int rtw_cmd_filter(struct cmd_priv *pcmd
 		{
 			struct drvextra_cmd_parm	*pdrvextra_cmd_parm = (struct drvextra_cmd_parm	*)cmd_obj->parmbuf;
 			if(pdrvextra_cmd_parm->ec_id == POWER_SAVING_CTRL_WK_CID)
-				bAllow = _TRUE;
+				bAllow = true;
 		}
 	}
 	#endif
 
 	if(cmd_obj->cmdcode == GEN_CMD_CODE(_SetChannelPlan))
-		bAllow = _TRUE;
+		bAllow = true;
 
-	if( (pcmdpriv->padapter->hw_init_completed ==_FALSE && bAllow == _FALSE)
-		|| pcmdpriv->cmdthd_running== _FALSE	//com_thread not running
+	if( (pcmdpriv->padapter->hw_init_completed ==false && bAllow == false)
+		|| pcmdpriv->cmdthd_running== false	//com_thread not running
 	)
 	{
 		return _FAIL;
@@ -395,7 +395,7 @@ _func_enter_;
 	pcmdbuf = pcmdpriv->cmd_buf;
 	prspbuf = pcmdpriv->rsp_buf;
 
-	pcmdpriv->cmdthd_running=_TRUE;
+	pcmdpriv->cmdthd_running=true;
 	_rtw_up_sema(&pcmdpriv->terminate_cmdthread_sema);
 
 	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("start r871x rtw_cmd_thread !!!!\n"));
@@ -413,7 +413,7 @@ _func_enter_;
 #endif
 
 _next:
-		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+		if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
 		{
 			DBG_871X("###> rtw_cmd_thread break.................\n");
 			RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("rtw_cmd_thread:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
@@ -486,7 +486,7 @@ post_process:
 		goto _next;
 
 	}
-	pcmdpriv->cmdthd_running=_FALSE;
+	pcmdpriv->cmdthd_running=false;
 
 
 	// free all cmd_obj resources
@@ -642,13 +642,13 @@ u8 rtw_sitesurvey_cmd(_adapter  *padapte
 _func_enter_;
 
 #ifdef CONFIG_LPS
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE){
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == true){
 		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SCAN, 1);
 	}
 #endif
 
 #ifdef CONFIG_P2P_PS
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
 		p2p_ps_wk_cmd(padapter, P2P_PS_SCAN, 1);
 	}
 #endif // CONFIG_P2P_PS
@@ -663,7 +663,7 @@ _func_enter_;
 		return _FAIL;
 	}
 
-	rtw_free_network_queue(padapter, _FALSE);
+	rtw_free_network_queue(padapter, false);
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("\nflush  network queue\n\n"));
 
@@ -990,7 +990,7 @@ void rtw_getbbrfreg_cmdrsp_callback(_ada
 	rtw_mfree((unsigned char*) pcmd, sizeof(struct cmd_obj));
 
 #ifdef CONFIG_MP_INCLUDED
-	padapter->mppriv.workparam.bcompleted= _TRUE;
+	padapter->mppriv.workparam.bcompleted= true;
 #endif
 _func_exit_;
 }
@@ -1003,7 +1003,7 @@ void rtw_readtssi_cmdrsp_callback(_adapt
 	rtw_mfree((unsigned char*) pcmd, sizeof(struct cmd_obj));
 
 #ifdef CONFIG_MP_INCLUDED
-	padapter->mppriv.workparam.bcompleted= _TRUE;
+	padapter->mppriv.workparam.bcompleted= true;
 #endif
 
 _func_exit_;
@@ -1133,7 +1133,7 @@ _func_enter_;
 
 
 	//for hidden ap to set fw_state here
-	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) != true)
 	{
 		switch(ndis_network_mode)
 		{
@@ -1185,7 +1185,7 @@ _func_enter_;
 	// If not,  we have to copy the connecting AP's MAC address to it so that
 	// the driver just has the bssid information for PMKIDList searching.
 
-	if ( pmlmepriv->assoc_by_bssid == _FALSE )
+	if ( pmlmepriv->assoc_by_bssid == false )
 	{
 		_rtw_memcpy( &pmlmepriv->assoc_bssid[ 0 ], &pnetwork->network.MacAddress[ 0 ], ETH_ALEN );
 	}
@@ -1213,7 +1213,7 @@ _func_enter_;
 	}
 
 #ifdef CONFIG_80211N_HT
-	phtpriv->ht_option = _FALSE;
+	phtpriv->ht_option = false;
 	if(pregistrypriv->ht_enable)
 	{
 		//	Added by Albert 2010/06/23
@@ -1337,14 +1337,14 @@ _func_enter_;
 
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 	if(ph2c==NULL){
-		res= _FALSE;
+		res= false;
 		goto exit;
 	}
 	psetop = (struct setopmode_parm*)rtw_zmalloc(sizeof(struct setopmode_parm));
 
 	if(psetop==NULL){
 		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res=_FALSE;
+		res=false;
 		goto exit;
 	}
 
@@ -1409,10 +1409,10 @@ _func_enter_;
 #endif //CONFIG_TDLS
 		psetstakey_para->algorithm =(unsigned char) psecuritypriv->dot11PrivacyAlgrthm;
 	}else{
-		GET_ENCRY_ALGO(psecuritypriv, sta, psetstakey_para->algorithm, _FALSE);
+		GET_ENCRY_ALGO(psecuritypriv, sta, psetstakey_para->algorithm, false);
 	}
 
-	if (unicast_key == _TRUE) {
+	if (unicast_key == true) {
 #ifdef CONFIG_TDLS
 		if(sta->tdls_sta_state&TDLS_LINKED_STATE)
 			_rtw_memcpy(&psetstakey_para->key, sta->tpk.tk, 16);
@@ -1424,7 +1424,7 @@ _func_enter_;
         }
 
 	//jeff: set this becasue at least sw key is ready
-	padapter->securitypriv.busetkipkey=_TRUE;
+	padapter->securitypriv.busetkipkey=true;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
@@ -1662,7 +1662,7 @@ u8 rtw_dynamic_chk_wk_cmd(_adapter*padap
 
 _func_enter_;
 
-	if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+	if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
 		goto exit;
 
 
@@ -1941,8 +1941,8 @@ static void traffic_status_watchdog(_ada
 #ifdef CONFIG_LPS
 	u8	bEnterPS;
 #endif
-	u8	bBusyTraffic = _FALSE, bTxBusyTraffic = _FALSE, bRxBusyTraffic = _FALSE;
-	u8	bHigherBusyTraffic = _FALSE, bHigherBusyRxTraffic = _FALSE, bHigherBusyTxTraffic = _FALSE;
+	u8	bBusyTraffic = false, bTxBusyTraffic = false, bRxBusyTraffic = false;
+	u8	bHigherBusyTraffic = false, bHigherBusyRxTraffic = false, bHigherBusyTxTraffic = false;
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &(padapter->tdlsinfo);
@@ -1951,35 +1951,35 @@ static void traffic_status_watchdog(_ada
 	//
 	// Determine if our traffic is busy now
 	//
-	if((check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+	if((check_fwstate(pmlmepriv, _FW_LINKED)== true)
 		/*&& !MgntInitAdapterInProgress(pMgntInfo)*/)
 	{
 
 		if( pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 100 ||
 			pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 100 )
 		{
-			bBusyTraffic = _TRUE;
+			bBusyTraffic = true;
 
 			if(pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 100)
-				bRxBusyTraffic = _TRUE;
+				bRxBusyTraffic = true;
 
 			if(pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 100)
-				bTxBusyTraffic = _TRUE;
+				bTxBusyTraffic = true;
 		}
 
 		// Higher Tx/Rx data.
 		if( pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 4000 ||
 			pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 4000 )
 		{
-			bHigherBusyTraffic = _TRUE;
+			bHigherBusyTraffic = true;
 
 			// Extremely high Rx data.
 			if(pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 5000)
-				bHigherBusyRxTraffic = _TRUE;
+				bHigherBusyRxTraffic = true;
 
 			// Extremely high Tx data.
 			if(pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 5000)
-				bHigherBusyTxTraffic = _TRUE;
+				bHigherBusyTxTraffic = true;
 		}
 
 #ifdef CONFIG_TDLS
@@ -1996,11 +1996,11 @@ static void traffic_status_watchdog(_ada
 			(pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2) )
 		{
 			//DBG_871X("Tx = %d, Rx = %d \n",pmlmepriv->LinkDetectInfo.NumTxOkInPeriod,pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod);
-			bEnterPS= _FALSE;
+			bEnterPS= false;
 		}
 		else
 		{
-			bEnterPS= _TRUE;
+			bEnterPS= true;
 		}
 
 		// LeisurePS only work in infra mode.
@@ -2038,7 +2038,7 @@ void dynamic_chk_wk_hdl(_adapter *padapt
 {
 	struct mlme_priv *pmlmepriv;
 
-	if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+	if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
 		return;
 
 	if((void*)padapter != (void*)pbuf && padapter->pbuddy_adapter == NULL)
@@ -2046,14 +2046,14 @@ void dynamic_chk_wk_hdl(_adapter *padapt
 
 	padapter = (_adapter *)pbuf;
 
-	if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+	if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
 		return;
 
 	pmlmepriv = &(padapter->mlmepriv);
 
 #ifdef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
 #ifdef CONFIG_AP_MODE
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		expire_timeout_chk(padapter);
 	}
@@ -2064,7 +2064,7 @@ void dynamic_chk_wk_hdl(_adapter *padapt
 	rtw_hal_sreset_xmit_status_check(padapter);
 	#endif
 
-	//if(check_fwstate(pmlmepriv, _FW_UNDER_LINKING|_FW_UNDER_SURVEY)==_FALSE)
+	//if(check_fwstate(pmlmepriv, _FW_UNDER_LINKING|_FW_UNDER_SURVEY)==false)
 	{
 		linked_status_chk(padapter);
 		traffic_status_watchdog(padapter);
@@ -2087,8 +2087,8 @@ void lps_ctrl_wk_hdl(_adapter *padapter,
 
 _func_enter_;
 
-	if((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)
-		|| (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
+	if((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)
+		|| (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
 	{
 		return;
 	}
@@ -2196,14 +2196,14 @@ u8 rtw_antenna_select_cmd(_adapter*padap
 	struct cmd_obj		*ph2c;
 	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8	bSupportAntDiv = _FALSE;
+	u8	bSupportAntDiv = false;
 	u8	res = _SUCCESS;
 
 _func_enter_;
 	rtw_hal_get_def_var(padapter, HAL_DEF_IS_SUPPORT_ANT_DIV, &(bSupportAntDiv));
-	if(_FALSE == bSupportAntDiv )	return res;
+	if(false == bSupportAntDiv )	return res;
 
-	if(_TRUE == enqueue)
+	if(true == enqueue)
 	{
 		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 		if(ph2c==NULL){
@@ -2360,7 +2360,7 @@ static void rtw_chk_hi_queue_hdl(_adapte
 			pstapriv->tim_bitmap &= ~BIT(0);
 			pstapriv->sta_dz_bitmap &= ~BIT(0);
 
-			update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+			update_beacon(padapter, _TIM_IE_, NULL, false);
 		}
 	}
 
@@ -2444,14 +2444,14 @@ s32 c2h_evt_hdl(_adapter *adapter, struc
 		if (c2h_evt_read(adapter, buf) == _SUCCESS) {
 			c2h_evt = (struct c2h_evt_hdr *)buf;
 
-			if (filter && filter(c2h_evt->id) == _FALSE)
+			if (filter && filter(c2h_evt->id) == false)
 				goto exit;
 
 			ret = rtw_hal_c2h_handler(adapter, c2h_evt);
 		}
 	} else {
 
-		if (filter && filter(c2h_evt->id) == _FALSE)
+		if (filter && filter(c2h_evt->id) == false)
 			goto exit;
 
 		ret = rtw_hal_c2h_handler(adapter, c2h_evt);
@@ -2468,7 +2468,7 @@ static void c2h_wk_callback(_workitem *w
 	struct c2h_evt_hdr *c2h_evt;
 	c2h_id_filter ccx_id_filter = rtw_hal_c2h_id_filter_ccx(adapter);
 
-	evtpriv->c2h_wk_alive = _TRUE;
+	evtpriv->c2h_wk_alive = true;
 
 	while (!rtw_cbuf_empty(evtpriv->c2h_queue)) {
 		if ((c2h_evt = (struct c2h_evt_hdr *)rtw_cbuf_pop(evtpriv->c2h_queue)) != NULL) {
@@ -2489,7 +2489,7 @@ static void c2h_wk_callback(_workitem *w
 			continue;
 		}
 
-		if (ccx_id_filter(c2h_evt->id) == _TRUE) {
+		if (ccx_id_filter(c2h_evt->id) == true) {
 			/* Handle CCX report here */
 			rtw_hal_c2h_handler(adapter, c2h_evt);
 			rtw_mfree((u8*)c2h_evt, 16);
@@ -2499,7 +2499,7 @@ static void c2h_wk_callback(_workitem *w
 		}
 	}
 
-	evtpriv->c2h_wk_alive = _FALSE;
+	evtpriv->c2h_wk_alive = false;
 }
 #endif
 
@@ -2727,7 +2727,7 @@ _func_enter_;
 
 		pnetwork->Length = get_WLAN_BSSID_EX_sz(pnetwork);
 		_rtw_memcpy(&(pwlan->network), pnetwork, pnetwork->Length);
-		//pwlan->fixed = _TRUE;
+		//pwlan->fixed = true;
 
 		//rtw_list_insert_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
 
@@ -2818,7 +2818,7 @@ _func_enter_;
 
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
-	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) && (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE))
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) && (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true))
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
        set_fwstate(pmlmepriv, _FW_LINKED);
@@ -2837,7 +2837,7 @@ _func_enter_;
 
 	rtw_free_cmd_obj(pcmd);
 #ifdef CONFIG_MP_INCLUDED
-	padapter->mppriv.workparam.bcompleted=_TRUE;
+	padapter->mppriv.workparam.bcompleted=true;
 #endif
 
 _func_exit_;
--- a/drivers/staging/rtl8192du/core/rtw_debug.c
+++ b/drivers/staging/rtl8192du/core/rtw_debug.c
@@ -1062,7 +1062,7 @@ int proc_get_all_sta_info(char *page, ch
 		phead = &(pstapriv->sta_hash[i]);
 		plist = get_next(phead);
 
-		while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+		while ((rtw_end_of_queue_search(phead, plist)) == false)
 		{
 			psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
--- a/drivers/staging/rtl8192du/core/rtw_eeprom.c
+++ b/drivers/staging/rtl8192du/core/rtw_eeprom.c
@@ -48,8 +48,8 @@ void shift_out_bits(_adapter * padapter,
 	u16 x,mask;
 _func_enter_;
 
-	if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+	if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 	}
 	mask = 0x01 << (count - 1);
@@ -62,8 +62,8 @@ _func_enter_;
 		x &= ~_EEDI;
 		if(data & mask)
 			x |= _EEDI;
-		if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 		}
 		rtw_write8(padapter, EE_9346CR, (u8)x);
@@ -72,8 +72,8 @@ _func_enter_;
 		down_clk(padapter, &x);
 		mask = mask >> 1;
 	} while(mask);
-	if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+	if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 	}
 	x &= ~_EEDI;
@@ -86,8 +86,8 @@ u16 shift_in_bits (_adapter * padapter)
 {
 	u16 x,d=0,i;
 _func_enter_;
-	if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+	if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 	}
 	x = rtw_read8(padapter, EE_9346CR);
@@ -99,8 +99,8 @@ _func_enter_;
 	{
 		d = d << 1;
 		up_clk(padapter, &x);
-	if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+	if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 	}
 		x = rtw_read8(padapter, EE_9346CR);
@@ -136,14 +136,14 @@ _func_exit_;
 u16 wait_eeprom_cmd_done(_adapter* padapter)
 {
 	u8	x;
-	u16	i,res=_FALSE;
+	u16	i,res=false;
 _func_enter_;
 	standby(padapter );
 	for (i=0; i<200; i++)
 	{
 		x = rtw_read8(padapter, EE_9346CR);
 		if (x & _EEDO){
-			res=_TRUE;
+			res=true;
 			goto exit;
 			}
 		rtw_udelay_os(CLOCK_RATE);
@@ -157,24 +157,24 @@ void eeprom_clean(_adapter * padapter)
 {
 	u16 x;
 _func_enter_;
-	if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+	if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 	}
 	x = rtw_read8(padapter, EE_9346CR);
-	if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+	if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 	}
 	x &= ~(_EECS | _EEDI);
 	rtw_write8(padapter, EE_9346CR, (u8)x);
-	if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+	if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 	}
 	up_clk(padapter, &x);
-		if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+		if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 	}
 	down_clk(padapter, &x);
@@ -242,12 +242,8 @@ _func_enter_;
 	// write the data to the selected EEPROM word.
 	shift_out_bits(padapter, data, 16);
 
-	if (wait_eeprom_cmd_done(padapter ) == _FALSE)
-	{
-
+	if (wait_eeprom_cmd_done(padapter ) == false)
 		goto exit;
-	}
-
 	standby(padapter );
 
 	shift_out_bits(padapter, EEPROM_EWDS_OPCODE, 5);
@@ -288,15 +284,15 @@ u16 eeprom_read16(_adapter * padapter, u
 #endif
 _func_enter_;
 
-	if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+	if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 	}
 	// select EEPROM, reset bits, set _EECS
 	x = rtw_read8(padapter, EE_9346CR);
 
-	if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+	if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 	}
 
@@ -337,15 +333,15 @@ void eeprom_read_sz(_adapter * padapter,
 	u16 x, data16;
 	u32 i;
 _func_enter_;
-	if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+	if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 	}
 	// select EEPROM, reset bits, set _EECS
 	x = rtw_read8(padapter, EE_9346CR);
 
-	if(padapter->bSurpriseRemoved==_TRUE){
-		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
+	if(padapter->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==true"));
 		goto out;
 	}
 
@@ -407,7 +403,7 @@ _func_enter_;
 		rbuf[idx] = (u8)(stmp & 0xff);
 	}
 _func_exit_;
-	return _TRUE;
+	return true;
 }
 
 
--- a/drivers/staging/rtl8192du/core/rtw_efuse.c
+++ b/drivers/staging/rtl8192du/core/rtw_efuse.c
@@ -63,14 +63,14 @@ Efuse_Read1ByteFromFakeContent(
 {
 	if(Offset >= EFUSE_MAX_HW_SIZE)
 	{
-		return _FALSE;
+		return false;
 	}
 	//DbgPrint("Read fake content, offset = %d\n", Offset);
 	if(fakeEfuseBank == 0)
 		*Value = fakeEfuseContent[Offset];
 	else
 		*Value = fakeBTEfuseContent[fakeEfuseBank-1][Offset];
-	return _TRUE;
+	return true;
 }
 
 bool
@@ -86,7 +86,7 @@ Efuse_Write1ByteToFakeContent(
 {
 	if(Offset >= EFUSE_MAX_HW_SIZE)
 	{
-		return _FALSE;
+		return false;
 	}
 	if(fakeEfuseBank == 0)
 		fakeEfuseContent[Offset] = Value;
@@ -94,7 +94,7 @@ Efuse_Write1ByteToFakeContent(
 	{
 		fakeBTEfuseContent[fakeEfuseBank-1][Offset] = Value;
 	}
-	return _TRUE;
+	return true;
 }
 
 /*-----------------------------------------------------------------------------
@@ -305,7 +305,7 @@ EFUSE_Read1Byte(
 	u32	k=0;
 	u16	contentLen=0;
 
-	EFUSE_GetEfuseDefinition(Adapter, EFUSE_WIFI , TYPE_EFUSE_REAL_CONTENT_LEN, (PVOID)&contentLen, _FALSE);
+	EFUSE_GetEfuseDefinition(Adapter, EFUSE_WIFI , TYPE_EFUSE_REAL_CONTENT_LEN, (PVOID)&contentLen, false);
 
 	if (Address < contentLen)	//E-fuse 512Byte
 	{
@@ -376,7 +376,7 @@ EFUSE_Write1Byte(
 	u16	contentLen=0;
 
 	//RT_TRACE(COMP_EFUSE, DBG_LOUD, ("Addr=%x Data =%x\n", Address, Value));
-	EFUSE_GetEfuseDefinition(Adapter, EFUSE_WIFI , TYPE_EFUSE_REAL_CONTENT_LEN, (PVOID)&contentLen, _FALSE);
+	EFUSE_GetEfuseDefinition(Adapter, EFUSE_WIFI , TYPE_EFUSE_REAL_CONTENT_LEN, (PVOID)&contentLen, false);
 
 	if( Address < contentLen)	//E-fuse 512Byte
 	{
@@ -442,12 +442,12 @@ efuse_OneByteRead(
 	if(tmpidx<100)
 	{
 		*data=rtw_read8(pAdapter, EFUSE_CTRL);
-		bResult = _TRUE;
+		bResult = true;
 	}
 	else
 	{
 		*data = 0xff;
-		bResult = _FALSE;
+		bResult = false;
 	}
 	return bResult;
 }
@@ -487,11 +487,11 @@ efuse_OneByteWrite(
 
 	if(tmpidx<100)
 	{
-		bResult = _TRUE;
+		bResult = true;
 	}
 	else
 	{
-		bResult = _FALSE;
+		bResult = false;
 	}
 
 	return bResult;
@@ -585,12 +585,12 @@ Efuse_WordEnableDataWrite(	PADAPTER	pAda
 
 static u8 efuse_read8(PADAPTER padapter, u16 address, u8 *value)
 {
-	return efuse_OneByteRead(padapter,address, value, _FALSE);
+	return efuse_OneByteRead(padapter,address, value, false);
 }
 
 static u8 efuse_write8(PADAPTER padapter, u16 address, u8 *value)
 {
-	return efuse_OneByteWrite(padapter,address, *value, _FALSE);
+	return efuse_OneByteWrite(padapter,address, *value, false);
 }
 
 /*
@@ -603,20 +603,20 @@ u8 rtw_efuse_access(PADAPTER padapter, u
 	u8 res = _FAIL ;
 	u8 (*rw8)(PADAPTER, u16, u8*);
 
-	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_REAL_CONTENT_LEN, (PVOID)&real_content_len, _FALSE);
-	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_REAL_CONTENT_LEN, (PVOID)&real_content_len, false);
+	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, false);
 
 	if (start_addr > real_content_len)
 		return _FAIL;
 
-	if (_TRUE == bWrite) {
+	if (true == bWrite) {
 		if ((start_addr + cnts) > max_available_size)
 			return _FAIL;
 		rw8 = &efuse_write8;
 	} else
 		rw8 = &efuse_read8;
 
-	Efuse_PowerSwitch(padapter, bWrite, _TRUE);
+	Efuse_PowerSwitch(padapter, bWrite, true);
 
 	// e-fuse one byte read / write
 	for (i = 0; i < cnts; i++) {
@@ -629,7 +629,7 @@ u8 rtw_efuse_access(PADAPTER padapter, u
 		if (_FAIL == res) break;
 	}
 
-	Efuse_PowerSwitch(padapter, bWrite, _FALSE);
+	Efuse_PowerSwitch(padapter, bWrite, false);
 
 	return res;
 }
@@ -637,15 +637,15 @@ u8 rtw_efuse_access(PADAPTER padapter, u
 u16 efuse_GetMaxSize(PADAPTER padapter)
 {
 	u16	max_size;
-	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI , TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_size, _FALSE);
+	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI , TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_size, false);
 	return max_size;
 }
 //------------------------------------------------------------------------------
 u8 efuse_GetCurrentSize(PADAPTER padapter, u16 *size)
 {
-	Efuse_PowerSwitch(padapter, _FALSE, _TRUE);
-	*size = Efuse_GetCurrentSize(padapter, EFUSE_WIFI, _FALSE);
-	Efuse_PowerSwitch(padapter, _FALSE, _FALSE);
+	Efuse_PowerSwitch(padapter, false, true);
+	*size = Efuse_GetCurrentSize(padapter, EFUSE_WIFI, false);
+	Efuse_PowerSwitch(padapter, false, false);
 
 	return _SUCCESS;
 }
@@ -654,16 +654,16 @@ u8 rtw_efuse_map_read(PADAPTER padapter,
 {
 	u16	mapLen=0;
 
-	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (PVOID)&mapLen, _FALSE);
+	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (PVOID)&mapLen, false);
 
 	if ((addr + cnts) > mapLen)
 		return _FAIL;
 
-	Efuse_PowerSwitch(padapter, _FALSE, _TRUE);
+	Efuse_PowerSwitch(padapter, false, true);
 
-	efuse_ReadEFuse(padapter, EFUSE_WIFI, addr, cnts, data, _FALSE);
+	efuse_ReadEFuse(padapter, EFUSE_WIFI, addr, cnts, data, false);
 
-	Efuse_PowerSwitch(padapter, _FALSE, _FALSE);
+	Efuse_PowerSwitch(padapter, false, false);
 
 	return _SUCCESS;
 }
@@ -677,7 +677,7 @@ u8 rtw_efuse_map_write(PADAPTER padapter
 	u8	ret = _SUCCESS;
 	u16	mapLen=0;
 
-	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (PVOID)&mapLen, _FALSE);
+	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (PVOID)&mapLen, false);
 
 	if ((addr + cnts) > mapLen)
 		return _FAIL;
@@ -690,7 +690,7 @@ u8 rtw_efuse_map_write(PADAPTER padapter
 	ret = rtw_efuse_map_read(padapter, 0, mapLen, map);
 	if (ret == _FAIL) goto exit;
 
-	Efuse_PowerSwitch(padapter, _TRUE, _TRUE);
+	Efuse_PowerSwitch(padapter, true, true);
 
 	offset = (addr >> 3);
 	word_en = 0xF;
@@ -735,7 +735,7 @@ u8 rtw_efuse_map_write(PADAPTER padapter
 		}
 
 		if (word_en != 0xF) {
-			ret = Efuse_PgPacketWrite(padapter, offset, word_en, newdata, _FALSE);
+			ret = Efuse_PgPacketWrite(padapter, offset, word_en, newdata, false);
 			DBG_871X("offset=%x \n",offset);
 			DBG_871X("word_en=%x \n",word_en);
 
@@ -755,7 +755,7 @@ u8 rtw_efuse_map_write(PADAPTER padapter
 		_rtw_memset(newdata, 0xFF, PGPKT_DATA_SIZE);
 	} while (1);
 
-	Efuse_PowerSwitch(padapter, _TRUE, _FALSE);
+	Efuse_PowerSwitch(padapter, true, false);
 
 exit:
 
@@ -796,13 +796,13 @@ Efuse_ReadAllMap(
 {
 	u16	mapLen=0;
 
-	Efuse_PowerSwitch(pAdapter,_FALSE, _TRUE);
+	Efuse_PowerSwitch(pAdapter,false, true);
 
 	EFUSE_GetEfuseDefinition(pAdapter, efuseType, TYPE_EFUSE_MAP_LEN, (PVOID)&mapLen, bPseudoTest);
 
 	efuse_ReadEFuse(pAdapter, efuseType, 0, mapLen, Efuse, bPseudoTest);
 
-	Efuse_PowerSwitch(pAdapter,_FALSE, _FALSE);
+	Efuse_PowerSwitch(pAdapter,false, false);
 }
 
 /*-----------------------------------------------------------------------------
@@ -952,7 +952,7 @@ void EFUSE_ShadowMapUpdate(
 
 	EFUSE_GetEfuseDefinition(pAdapter, efuseType, TYPE_EFUSE_MAP_LEN, (PVOID)&mapLen, bPseudoTest);
 
-	if (pEEPROM->bautoload_fail_flag == _TRUE)
+	if (pEEPROM->bautoload_fail_flag == true)
 	{
 		_rtw_memset(pEEPROM->efuse_eeprom_data, 0xFF, mapLen);
 	}
@@ -1083,7 +1083,7 @@ Efuse_InitSomeVar(
 
  int isAdaptorInfoFileValid(void)
 {
-	return _TRUE;
+	return true;
 }
 
 int storeAdaptorInfoFile(char *path, struct eeprom_priv * eeprom_priv)
--- a/drivers/staging/rtl8192du/core/rtw_ieee80211.c
+++ b/drivers/staging/rtl8192du/core/rtw_ieee80211.c
@@ -88,11 +88,11 @@ uint	rtw_is_cckrates_included(u8 *rate)
 		{
 			if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
 			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )
-			return _TRUE;
+			return true;
 			i++;
 		}
 
-		return _FALSE;
+		return false;
 }
 
 uint	rtw_is_cckratesonly_included(u8 *rate)
@@ -105,12 +105,12 @@ uint	rtw_is_cckratesonly_included(u8 *ra
 			if  (  (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
 				(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
 
-			return _FALSE;
+			return false;
 
 			i++;
 	}
 
-	return _TRUE;
+	return true;
 
 }
 
@@ -118,16 +118,16 @@ int rtw_check_network_type(unsigned char
 {
 	if (channel > 14)
 	{
-		if ((rtw_is_cckrates_included(rate)) == _TRUE)
+		if ((rtw_is_cckrates_included(rate)) == true)
 			return WIRELESS_INVALID;
 		else
 			return WIRELESS_11A;
 	}
 	else  // could be pure B, pure G, or B/G
 	{
-		if ((rtw_is_cckratesonly_included(rate)) == _TRUE)
+		if ((rtw_is_cckratesonly_included(rate)) == true)
 			return WIRELESS_11B;
-		else if((rtw_is_cckrates_included(rate)) == _TRUE)
+		else if((rtw_is_cckrates_included(rate)) == true)
 			return	WIRELESS_11BG;
 		else
 			return WIRELESS_11G;
@@ -285,7 +285,7 @@ u8 *rtw_get_ie_ex(u8 *in_ie, uint in_len
 	while(cnt<in_len)
 	{
 		if(eid == in_ie[cnt]
-			&& ( !oui || _rtw_memcmp(&in_ie[cnt+2], oui, oui_len) == _TRUE))
+			&& ( !oui || _rtw_memcmp(&in_ie[cnt+2], oui, oui_len) == true))
 		{
 			target_ie = &in_ie[cnt];
 
@@ -481,7 +481,7 @@ _func_enter_;
 
 	//HT Cap.
 	if(((pregistrypriv->wireless_mode&WIRELESS_11_5N)||(pregistrypriv->wireless_mode&WIRELESS_11_24N))
-		&& (pregistrypriv->ht_enable==_TRUE))
+		&& (pregistrypriv->ht_enable==true))
 	{
 		//todo:
 	}
@@ -510,7 +510,7 @@ unsigned char *rtw_get_wpa_ie(unsigned c
 		if (pbuf) {
 
 			//check if oui matches...
-			if (_rtw_memcmp((pbuf + 2), wpa_oui_type, sizeof (wpa_oui_type)) == _FALSE) {
+			if (_rtw_memcmp((pbuf + 2), wpa_oui_type, sizeof (wpa_oui_type)) == false) {
 
 				goto check_next_ie;
 			}
@@ -556,15 +556,15 @@ unsigned char *rtw_get_wpa2_ie(unsigned
 
 int rtw_get_wpa_cipher_suite(u8 *s)
 {
-	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN) == _TRUE)
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN) == true)
 		return WPA_CIPHER_NONE;
-	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN) == _TRUE)
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN) == true)
 		return WPA_CIPHER_WEP40;
-	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN) == _TRUE)
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN) == true)
 		return WPA_CIPHER_TKIP;
-	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN) == _TRUE)
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN) == true)
 		return WPA_CIPHER_CCMP;
-	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN) == _TRUE)
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN) == true)
 		return WPA_CIPHER_WEP104;
 
 	return 0;
@@ -572,15 +572,15 @@ int rtw_get_wpa_cipher_suite(u8 *s)
 
 int rtw_get_wpa2_cipher_suite(u8 *s)
 {
-	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN) == _TRUE)
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN) == true)
 		return WPA_CIPHER_NONE;
-	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN) == _TRUE)
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN) == true)
 		return WPA_CIPHER_WEP40;
-	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN) == _TRUE)
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN) == true)
 		return WPA_CIPHER_TKIP;
-	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN) == _TRUE)
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN) == true)
 		return WPA_CIPHER_CCMP;
-	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN) == _TRUE)
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN) == true)
 		return WPA_CIPHER_WEP104;
 
 	return 0;
@@ -600,7 +600,7 @@ int rtw_parse_wpa_ie(u8* wpa_ie, int wpa
 
 
 	if ((*wpa_ie != _WPA_IE_ID_) || (*(wpa_ie+1) != (u8)(wpa_ie_len - 2)) ||
-	   (_rtw_memcmp(wpa_ie+2, RTW_WPA_OUI_TYPE, WPA_SELECTOR_LEN) != _TRUE) )
+	   (_rtw_memcmp(wpa_ie+2, RTW_WPA_OUI_TYPE, WPA_SELECTOR_LEN) != true) )
 	{
 		return _FAIL;
 	}
@@ -749,7 +749,7 @@ _func_enter_;
 	{
 		authmode=in_ie[cnt];
 
-		if((authmode==_WPA_IE_ID_)&&(_rtw_memcmp(&in_ie[cnt+2], &wpa_oui[0],4)==_TRUE))
+		if((authmode==_WPA_IE_ID_)&&(_rtw_memcmp(&in_ie[cnt+2], &wpa_oui[0],4)==true))
 		{
 				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n rtw_get_wpa_ie: sec_idx=%d in_ie[cnt+1]+2=%d\n",sec_idx,in_ie[cnt+1]+2));
 
@@ -793,18 +793,18 @@ _func_exit_;
 
 u8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_ielen)
 {
-	u8 match = _FALSE;
+	u8 match = false;
 	u8 eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
 
 	if(ie_ptr == NULL) return match;
 
 	eid = ie_ptr[0];
 
-	if((eid==_WPA_IE_ID_)&&(_rtw_memcmp(&ie_ptr[2], wps_oui, 4)==_TRUE))
+	if((eid==_WPA_IE_ID_)&&(_rtw_memcmp(&ie_ptr[2], wps_oui, 4)==true))
 	{
 		//printk("==> found WPS_IE.....\n");
 		*wps_ielen = ie_ptr[1]+2;
-		match=_TRUE;
+		match=true;
 	}
 	return match;
 }
@@ -836,7 +836,7 @@ u8 *rtw_get_wps_ie(u8 *in_ie, uint in_le
 	{
 		eid = in_ie[cnt];
 
-		if((eid==_WPA_IE_ID_)&&(_rtw_memcmp(&in_ie[cnt+2], wps_oui, 4)==_TRUE))
+		if((eid==_WPA_IE_ID_)&&(_rtw_memcmp(&in_ie[cnt+2], wps_oui, 4)==true))
 		{
 			wpsie_ptr = &in_ie[cnt];
 
@@ -880,7 +880,7 @@ u8 *rtw_get_wps_attr(u8 *wps_ie, uint wp
 		*len_attr = 0;
 
 	if ( ( wps_ie[0] != _VENDOR_SPECIFIC_IE_ ) ||
-		( _rtw_memcmp( wps_ie + 2, wps_oui , 4 ) != _TRUE ) )
+		( _rtw_memcmp( wps_ie + 2, wps_oui , 4 ) != true ) )
 	{
 		return attr_ptr;
 	}
@@ -1344,7 +1344,7 @@ u8 *rtw_get_p2p_ie(u8 *in_ie, int in_len
 			dump_stack();
 			return NULL;
 		}
-		if( ( eid == _VENDOR_SPECIFIC_IE_ ) && ( _rtw_memcmp( &in_ie[cnt+2], p2p_oui, 4) == _TRUE ) )
+		if( ( eid == _VENDOR_SPECIFIC_IE_ ) && ( _rtw_memcmp( &in_ie[cnt+2], p2p_oui, 4) == true ) )
 		{
 			p2p_ie_ptr = in_ie + cnt;
 
@@ -1393,7 +1393,7 @@ u8 *rtw_get_p2p_attr(u8 *p2p_ie, uint p2
 		*len_attr = 0;
 
 	if ( !p2p_ie || ( p2p_ie[0] != _VENDOR_SPECIFIC_IE_ ) ||
-		( _rtw_memcmp( p2p_ie + 2, p2p_oui , 4 ) != _TRUE ) )
+		( _rtw_memcmp( p2p_ie + 2, p2p_oui , 4 ) != true ) )
 	{
 		return attr_ptr;
 	}
@@ -1568,7 +1568,7 @@ int rtw_get_wfd_ie(u8 *in_ie, int in_len
 	u8 eid, wfd_oui[4]={0x50,0x6F,0x9A,0x0A};
 
 
-	match=_FALSE;
+	match=false;
 
 	if ( in_len < 0 )
 	{
@@ -1579,7 +1579,7 @@ int rtw_get_wfd_ie(u8 *in_ie, int in_len
 	{
 		eid = in_ie[cnt];
 
-		if( ( eid == _VENDOR_SPECIFIC_IE_ ) && ( _rtw_memcmp( &in_ie[cnt+2], wfd_oui, 4) == _TRUE ) )
+		if( ( eid == _VENDOR_SPECIFIC_IE_ ) && ( _rtw_memcmp( &in_ie[cnt+2], wfd_oui, 4) == true ) )
 		{
 			if ( wfd_ie != NULL )
 			{
@@ -1601,7 +1601,7 @@ int rtw_get_wfd_ie(u8 *in_ie, int in_len
 
 			cnt += in_ie[ cnt + 1 ] + 2;
 
-			match = _TRUE;
+			match = true;
 			break;
 		}
 		else
@@ -1611,7 +1611,7 @@ int rtw_get_wfd_ie(u8 *in_ie, int in_len
 
 	}
 
-	if ( match == _TRUE )
+	if ( match == true )
 	{
 		match = cnt;
 	}
@@ -1629,10 +1629,10 @@ int rtw_get_wfd_attr_content(u8 *wfd_ie,
 	u8 attr_id, wfd_oui[4]={0x50,0x6F,0x9A,0x0A};
 
 
-	match=_FALSE;
+	match=false;
 
 	if ( ( wfd_ie[ 0 ] != _VENDOR_SPECIFIC_IE_ ) ||
-		( _rtw_memcmp( wfd_ie + 2, wfd_oui , 4 ) != _TRUE ) )
+		( _rtw_memcmp( wfd_ie + 2, wfd_oui , 4 ) != true ) )
 	{
 		return( match );
 	}
@@ -1655,7 +1655,7 @@ int rtw_get_wfd_attr_content(u8 *wfd_ie,
 
 			cnt += attrlen + 3;
 
-			match = _TRUE;
+			match = true;
 			break;
 		}
 		else
@@ -1794,7 +1794,7 @@ int rtw_action_frame_parse(const u8 *fra
 		!= (RTW_IEEE80211_FTYPE_MGMT|RTW_IEEE80211_STYPE_ACTION)
 	)
 	{
-		return _FALSE;
+		return false;
 	}
 
 	c = frame_body[0];
@@ -1811,7 +1811,7 @@ int rtw_action_frame_parse(const u8 *fra
 	if (action)
 		*action = a;
 
-	return _TRUE;
+	return true;
 }
 
 static const char *_action_public_str[] = {
--- a/drivers/staging/rtl8192du/core/rtw_io.c
+++ b/drivers/staging/rtl8192du/core/rtw_io.c
@@ -208,7 +208,7 @@ void _rtw_read_mem(_adapter *adapter, u3
 
 	_func_enter_;
 
-	if( (adapter->bDriverStopped ==_TRUE) || (adapter->bSurpriseRemoved == _TRUE))
+	if( (adapter->bDriverStopped ==true) || (adapter->bSurpriseRemoved == true))
 	{
 	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_mem:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));
 	     return;
@@ -248,7 +248,7 @@ void _rtw_read_port(_adapter *adapter, u
 
 	_func_enter_;
 
-	if( (adapter->bDriverStopped ==_TRUE) || (adapter->bSurpriseRemoved == _TRUE))
+	if( (adapter->bDriverStopped ==true) || (adapter->bSurpriseRemoved == true))
 	{
 	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_port:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));
 	     return;
@@ -360,10 +360,10 @@ bool match_read_sniff_ranges(u16 addr, u
 	int i;
 	for (i = 0; i<read_sniff_num; i++) {
 		if (addr + len > read_sniff_ranges[i][0] && addr <= read_sniff_ranges[i][1])
-			return _TRUE;
+			return true;
 	}
 
-	return _FALSE;
+	return false;
 }
 
 bool match_write_sniff_ranges(u16 addr, u16 len)
@@ -371,10 +371,10 @@ bool match_write_sniff_ranges(u16 addr,
 	int i;
 	for (i = 0; i<write_sniff_num; i++) {
 		if (addr + len > write_sniff_ranges[i][0] && addr <= write_sniff_ranges[i][1])
-			return _TRUE;
+			return true;
 	}
 
-	return _FALSE;
+	return false;
 }
 
 u8 dbg_rtw_read8(_adapter *adapter, u32 addr, const char *caller, const int line)
--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -34,19 +34,19 @@ extern void indicate_wx_scan_complete_ev
 ( \
 	( (addr[0] == 0xff) && (addr[1] == 0xff) && \
 		(addr[2] == 0xff) && (addr[3] == 0xff) && \
-		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? _TRUE : _FALSE \
+		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? true : false \
 )
 
 u8 rtw_validate_ssid(NDIS_802_11_SSID *ssid)
 {
 	u8	 i;
-	u8	ret=_TRUE;
+	u8	ret=true;
 
 _func_enter_;
 
 	if (ssid->SsidLength > 32) {
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid length >32\n"));
-		ret= _FALSE;
+		ret= false;
 		goto exit;
 	}
 
@@ -55,7 +55,7 @@ _func_enter_;
 		//wifi, printable ascii code must be supported
 		if(!( (ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e) )){
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid has nonprintabl ascii\n"));
-			ret= _FALSE;
+			ret= false;
 			break;
 		}
 	}
@@ -91,9 +91,9 @@ _func_enter_;
 
 	pmlmepriv->pscanned = plist;
 
-	pmlmepriv->to_join = _TRUE;
+	pmlmepriv->to_join = true;
 
-	if(_rtw_queue_empty(queue)== _TRUE)
+	if(_rtw_queue_empty(queue)== true)
 	{
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
@@ -101,7 +101,7 @@ _func_enter_;
 		//when set_ssid/set_bssid for rtw_do_join(), but scanning queue is empty
 		//we try to issue sitesurvey firstly
 
-		if (pmlmepriv->LinkDetectInfo.bBusyTraffic ==_FALSE
+		if (pmlmepriv->LinkDetectInfo.bBusyTraffic ==false
 			|| rtw_to_roaming(padapter) > 0
 		)
 		{
@@ -120,7 +120,7 @@ _func_enter_;
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 		if((select_ret=rtw_select_and_join_from_scanned_queue(pmlmepriv))==_SUCCESS)
 		{
-			pmlmepriv->to_join = _FALSE;
+			pmlmepriv->to_join = false;
 			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
 		}
 		else if(ret == 2)//there is no need to wait for join
@@ -131,7 +131,7 @@ _func_enter_;
 		}
 		else
 		{
-			if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE)
+			if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true)
 			{
 				// submit createbss_cmd to change to a ADHOC_MASTER
 
@@ -152,11 +152,11 @@ _func_enter_;
 				if(rtw_createbss_cmd(padapter)!=_SUCCESS)
 				{
 					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("***Error=>do_goin: rtw_createbss_cmd status FAIL*** \n "));
-					ret =  _FALSE;
+					ret =  false;
 					goto exit;
 				}
 
-				pmlmepriv->to_join = _FALSE;
+				pmlmepriv->to_join = false;
 
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("***Error=> rtw_select_and_join_from_scanned_queue FAIL under STA_Mode*** \n "));
 
@@ -167,14 +167,14 @@ _func_enter_;
 				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
 #if 0
-				if((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE))
+				if((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true))
 				{
 					if(_rtw_memcmp(pmlmepriv->cur_network.network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength))
 					{
 						// for funk to do roaming
 						// funk will reconnect, but funk will not sitesurvey before reconnect
 						RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("for funk to do roaming"));
-						if(pmlmepriv->sitesurveyctrl.traffic_busy==_FALSE)
+						if(pmlmepriv->sitesurveyctrl.traffic_busy==false)
 							rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);
 					}
 
@@ -183,7 +183,7 @@ _func_enter_;
 
 				//when set_ssid/set_bssid for rtw_do_join(), but there are no desired bss in scanning queue
 				//we try to issue sitesurvey firstly
-				if(pmlmepriv->LinkDetectInfo.bBusyTraffic==_FALSE
+				if(pmlmepriv->LinkDetectInfo.bBusyTraffic==false
 					|| rtw_to_roaming(padapter) > 0
 				)
 				{
@@ -232,33 +232,33 @@ _func_enter_;
 
 
 	DBG_871X("Set BSSID under fw_state=0x%08x\n", get_fwstate(pmlmepriv));
-	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
 		goto handle_tkip_countermeasure;
-	} else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE) {
+	} else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {
 		goto release_mlme_lock;
 	}
 
-	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true)
 	{
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_bssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));
 
-		if (_rtw_memcmp(&pmlmepriv->cur_network.network.MacAddress, bssid, ETH_ALEN) == _TRUE)
+		if (_rtw_memcmp(&pmlmepriv->cur_network.network.MacAddress, bssid, ETH_ALEN) == true)
 		{
-			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _FALSE)
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false)
 				goto release_mlme_lock;//it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again.
 		} else {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("Set BSSID not the same bssid\n"));
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_bssid="MAC_FMT"\n", MAC_ARG(bssid) ));
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("cur_bssid="MAC_FMT"\n", MAC_ARG(pmlmepriv->cur_network.network.MacAddress) ));
 
-			rtw_disassoc_cmd(padapter, 0, _TRUE);
+			rtw_disassoc_cmd(padapter, 0, true);
 
-			if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 				rtw_indicate_disconnect(padapter);
 
 			rtw_free_assoc_resources(padapter, 1);
 
-			if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
+			if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
 				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
 				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
 			}
@@ -268,12 +268,12 @@ _func_enter_;
 handle_tkip_countermeasure:
 	//should we add something here...?
 
-	if (padapter->securitypriv.btkip_countermeasure == _TRUE) {
+	if (padapter->securitypriv.btkip_countermeasure == true) {
 		cur_time = rtw_get_current_time();
 
 		if( (cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ )
 		{
-			padapter->securitypriv.btkip_countermeasure = _FALSE;
+			padapter->securitypriv.btkip_countermeasure = false;
 			padapter->securitypriv.btkip_countermeasure_time = 0;
 		}
 		else
@@ -284,10 +284,10 @@ handle_tkip_countermeasure:
 	}
 
 	_rtw_memcpy(&pmlmepriv->assoc_bssid, bssid, ETH_ALEN);
-	pmlmepriv->assoc_by_bssid=_TRUE;
+	pmlmepriv->assoc_by_bssid=true;
 
-	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
-		pmlmepriv->to_join = _TRUE;
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
+		pmlmepriv->to_join = true;
 	}
 	else {
 		status = rtw_do_join(padapter);
@@ -320,9 +320,9 @@ _func_enter_;
 		 ("+rtw_set_802_11_ssid: ssid=[%s] fw_state=0x%08x\n",
 		  ssid->Ssid, get_fwstate(pmlmepriv)));
 
-	if(padapter->hw_init_completed==_FALSE){
+	if(padapter->hw_init_completed==false){
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
-			 ("set_ssid: hw_init_completed==_FALSE=>exit!!!\n"));
+			 ("set_ssid: hw_init_completed==false=>exit!!!\n"));
 		status = _FAIL;
 		goto exit;
 	}
@@ -330,37 +330,37 @@ _func_enter_;
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
 	DBG_871X("Set SSID under fw_state=0x%08x\n", get_fwstate(pmlmepriv));
-	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
 		goto handle_tkip_countermeasure;
-	} else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE) {
+	} else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {
 		goto release_mlme_lock;
 	}
 
-	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true)
 	{
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,
 			 ("set_ssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));
 
 		if ((pmlmepriv->assoc_ssid.SsidLength == ssid->SsidLength) &&
-		    (_rtw_memcmp(&pmlmepriv->assoc_ssid.Ssid, ssid->Ssid, ssid->SsidLength) == _TRUE))
+		    (_rtw_memcmp(&pmlmepriv->assoc_ssid.Ssid, ssid->Ssid, ssid->SsidLength) == true))
 		{
-			if((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _FALSE))
+			if((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false))
 			{
 				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 					 ("Set SSID is the same ssid, fw_state=0x%08x\n",
 					  get_fwstate(pmlmepriv)));
 
-				if(rtw_is_same_ibss(padapter, pnetwork) == _FALSE)
+				if(rtw_is_same_ibss(padapter, pnetwork) == false)
 				{
 					//if in WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE, create bss or rejoin again
-					rtw_disassoc_cmd(padapter, 0, _TRUE);
+					rtw_disassoc_cmd(padapter, 0, true);
 
-					if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+					if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 						rtw_indicate_disconnect(padapter);
 
 					rtw_free_assoc_resources(padapter, 1);
 
-					if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) {
+					if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {
 						_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
 						set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
 					}
@@ -382,14 +382,14 @@ _func_enter_;
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_ssid=[%s] len=0x%x\n", ssid->Ssid, (unsigned int)ssid->SsidLength));
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("assoc_ssid=[%s] len=0x%x\n", pmlmepriv->assoc_ssid.Ssid, (unsigned int)pmlmepriv->assoc_ssid.SsidLength));
 
-			rtw_disassoc_cmd(padapter, 0, _TRUE);
+			rtw_disassoc_cmd(padapter, 0, true);
 
-			if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 				rtw_indicate_disconnect(padapter);
 
 			rtw_free_assoc_resources(padapter, 1);
 
-			if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) {
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {
 				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
 				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
 			}
@@ -398,12 +398,12 @@ _func_enter_;
 
 handle_tkip_countermeasure:
 
-	if (padapter->securitypriv.btkip_countermeasure == _TRUE) {
+	if (padapter->securitypriv.btkip_countermeasure == true) {
 		cur_time = rtw_get_current_time();
 
 		if( (cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ )
 		{
-			padapter->securitypriv.btkip_countermeasure = _FALSE;
+			padapter->securitypriv.btkip_countermeasure = false;
 			padapter->securitypriv.btkip_countermeasure_time = 0;
 		}
 		else
@@ -414,17 +414,17 @@ handle_tkip_countermeasure:
 	}
 
 	#ifdef CONFIG_VALIDATE_SSID
-	if (rtw_validate_ssid(ssid) == _FALSE) {
+	if (rtw_validate_ssid(ssid) == false) {
 		status = _FAIL;
 		goto release_mlme_lock;
 	}
 	#endif
 
 	_rtw_memcpy(&pmlmepriv->assoc_ssid, ssid, sizeof(NDIS_802_11_SSID));
-	pmlmepriv->assoc_by_bssid=_FALSE;
+	pmlmepriv->assoc_by_bssid=false;
 
-	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
-		pmlmepriv->to_join = _TRUE;
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
+		pmlmepriv->to_join = true;
 	}
 	else {
 		status = rtw_do_join(padapter);
@@ -478,16 +478,16 @@ _func_enter_;
 #endif
 		}
 
-		if((check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) ||(*pold_state==Ndis802_11IBSS))
-			rtw_disassoc_cmd(padapter, 0, _TRUE);
+		if((check_fwstate(pmlmepriv, _FW_LINKED)== true) ||(*pold_state==Ndis802_11IBSS))
+			rtw_disassoc_cmd(padapter, 0, true);
 
-		if((check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) ||
-			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)== _TRUE) )
+		if((check_fwstate(pmlmepriv, _FW_LINKED)== true) ||
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)== true) )
 			rtw_free_assoc_resources(padapter, 0);
 
 		if((*pold_state == Ndis802_11Infrastructure) ||(*pold_state == Ndis802_11IBSS))
 	       {
-			if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+			if(check_fwstate(pmlmepriv, _FW_LINKED) == true)
 			{
 				rtw_indicate_disconnect(padapter); //will clr Linked_state; before this function, we must have chked whether  issue dis-assoc_cmd or not
 			}
@@ -530,7 +530,7 @@ _func_enter_;
 
 _func_exit_;
 
-	return _TRUE;
+	return true;
 }
 
 
@@ -543,11 +543,11 @@ _func_enter_;
 
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActrtw_set_802_11_disassociate: rtw_indicate_disconnect\n"));
 
-		rtw_disassoc_cmd(padapter, 0, _TRUE);
+		rtw_disassoc_cmd(padapter, 0, true);
 		rtw_indicate_disconnect(padapter);
 		rtw_free_assoc_resources(padapter, 1);
 	}
@@ -556,40 +556,40 @@ _func_enter_;
 
 _func_exit_;
 
-	return _TRUE;
+	return true;
 }
 
 u8 rtw_set_802_11_bssid_list_scan(_adapter* padapter, NDIS_802_11_SSID *pssid, int ssid_max_num)
 {
 	_irqL	irqL;
 	struct	mlme_priv		*pmlmepriv= &padapter->mlmepriv;
-	u8	res=_TRUE;
+	u8	res=true;
 
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("+rtw_set_802_11_bssid_list_scan(), fw_state=%x\n", get_fwstate(pmlmepriv)));
 
 	if (padapter == NULL) {
-		res=_FALSE;
+		res=false;
 		goto exit;
 	}
-	if (padapter->hw_init_completed==_FALSE){
-		res = _FALSE;
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n===rtw_set_802_11_bssid_list_scan:hw_init_completed==_FALSE===\n"));
+	if (padapter->hw_init_completed==false){
+		res = false;
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n===rtw_set_802_11_bssid_list_scan:hw_init_completed==false===\n"));
 		goto exit;
 	}
 
-	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) ||
-		(pmlmepriv->LinkDetectInfo.bBusyTraffic == _TRUE))
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true) ||
+		(pmlmepriv->LinkDetectInfo.bBusyTraffic == true))
 	{
 		// Scan or linking is in progress, do nothing.
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_bssid_list_scan fail since fw_state = %x\n", get_fwstate(pmlmepriv)));
-		res = _TRUE;
+		res = true;
 
-		if(check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))== _TRUE){
+		if(check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))== true){
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n###_FW_UNDER_SURVEY|_FW_UNDER_LINKING\n\n"));
 		} else {
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n###pmlmepriv->sitesurveyctrl.traffic_busy==_TRUE\n\n"));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n###pmlmepriv->sitesurveyctrl.traffic_busy==true\n\n"));
 		}
 	} else {
 		if (rtw_is_scan_deny(padapter)) {
@@ -631,9 +631,9 @@ _func_enter_;
 	res=rtw_set_auth(padapter,psecuritypriv);
 
 	if(res==_SUCCESS)
-		ret=_TRUE;
+		ret=true;
 	else
-		ret=_FALSE;
+		ret=false;
 
 _func_exit_;
 
@@ -650,14 +650,14 @@ u8 rtw_set_802_11_add_wep(_adapter* pada
 
 _func_enter_;
 
-	bdefaultkey=(wep->KeyIndex & 0x40000000) > 0 ? _FALSE : _TRUE;   //for ???
-	btransmitkey= (wep->KeyIndex & 0x80000000) > 0 ? _TRUE  : _FALSE;	//for ???
+	bdefaultkey=(wep->KeyIndex & 0x40000000) > 0 ? false : true;   //for ???
+	btransmitkey= (wep->KeyIndex & 0x80000000) > 0 ? true  : false;	//for ???
 	keyid=wep->KeyIndex & 0x3fffffff;
 
 	if(keyid>4)
 	{
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("MgntActrtw_set_802_11_add_wep:keyid>4=>fail\n"));
-		ret=_FALSE;
+		ret=false;
 		goto exit;
 	}
 
@@ -695,7 +695,7 @@ _func_enter_;
 	res=rtw_set_key(padapter,psecuritypriv, keyid, 1);
 
 	if(res==_FAIL)
-		ret= _FALSE;
+		ret= false;
 exit:
 
 _func_exit_;
@@ -712,7 +712,7 @@ _func_enter_;
 
 	if (keyindex >= 0x80000000 || padapter == NULL){
 
-		ret=_FALSE;
+		ret=false;
 		goto exit;
 
 	}
@@ -752,8 +752,8 @@ u8 rtw_set_802_11_add_key(_adapter* pada
 	uint	encryptionalgo;
 	u8 * pbssid;
 	struct sta_info *stainfo;
-	u8	bgroup = _FALSE;
-	u8	bgrouptkey = _FALSE;//can be remove later
+	u8	bgroup = false;
+	u8	bgrouptkey = false;//can be remove later
 	u8	ret=_SUCCESS;
 
 _func_enter_;
@@ -805,10 +805,10 @@ _func_enter_;
 		}
 
 		// check BSSID
-		if (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == _TRUE){
+		if (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == true){
 
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("MacAddr_isBcst(key->BSSID)\n"));
-			ret= _FALSE;
+			ret= false;
 			goto exit;
 		}
 
@@ -839,7 +839,7 @@ _func_enter_;
 			goto exit;
 		}
 
-		bgroup = _FALSE;
+		bgroup = false;
 
 		// Check the pairwise key. Added by Annie, 2005-07-06.
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
@@ -889,7 +889,7 @@ _func_enter_;
 
 		}
 
-		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==_TRUE) && (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == _FALSE)) {
+		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==true) && (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == false)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" IBSS but BSSID is not Broadcast Address.\n"));
 			ret= _FAIL;
 			goto exit;
@@ -918,15 +918,15 @@ _func_enter_;
 		}
 
 		if(key->KeyIndex & 0x8000000) {//error ??? 0x8000_0000
-			bgrouptkey = _TRUE;
+			bgrouptkey = true;
 		}
 
-		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==_TRUE)&&(check_fwstate(&padapter->mlmepriv, _FW_LINKED)==_TRUE))
+		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==true)&&(check_fwstate(&padapter->mlmepriv, _FW_LINKED)==true))
 		{
-			bgrouptkey = _TRUE;
+			bgrouptkey = true;
 		}
 
-		bgroup = _TRUE;
+		bgroup = true;
 
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n") );
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("[Group Key set]\n") );
@@ -969,7 +969,7 @@ _func_enter_;
 	if(key->KeyIndex & 0x20000000){
 		// SetRSC
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ SetRSC+++++\n"));
-		if(bgroup == _TRUE)
+		if(bgroup == true)
 		{
 			NDIS_802_11_KEY_RSC keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;
 			_rtw_memcpy(&padapter->securitypriv.dot11Grprxpn, &keysrc, 8);
@@ -984,11 +984,11 @@ _func_enter_;
 
 	// Indicate this key idx is used for TX
 	// Save the key in KeyMaterial
-	if(bgroup == _TRUE) // Group transmit key
+	if(bgroup == true) // Group transmit key
 	{
 		int res;
 
-		if(bgrouptkey == _TRUE)
+		if(bgrouptkey == true)
 		{
 			padapter->securitypriv.dot118021XGrpKeyid=(u8)key->KeyIndex;
 		}
@@ -1034,9 +1034,9 @@ _func_enter_;
 
 		key->KeyIndex=key->KeyIndex & 0x03;
 
-		padapter->securitypriv.binstallGrpkey=_TRUE;
+		padapter->securitypriv.binstallGrpkey=true;
 
-		padapter->securitypriv.bcheck_grpkey=_FALSE;
+		padapter->securitypriv.bcheck_grpkey=false;
 
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("reset group key"));
 
@@ -1063,7 +1063,7 @@ _func_enter_;
 
 			if(encryptionalgo== _TKIP_)
 			{
-				padapter->securitypriv.busetkipkey=_FALSE;
+				padapter->securitypriv.busetkipkey=false;
 
 				//_set_timer(&padapter->securitypriv.tkip_timer, 50);
 
@@ -1090,15 +1090,15 @@ _func_enter_;
 			//Set key to CAM through H2C command
 			if(bgrouptkey)//never go to here
 			{
-				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, _FALSE);
+				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, false);
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(group)\n"));
 			}
 			else{
-				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, _TRUE);
+				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, true);
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(unicast)\n"));
 			}
 
-			if(res ==_FALSE)
+			if(res ==false)
 				ret= _FAIL;
 
 		}
@@ -1117,7 +1117,7 @@ u8 rtw_set_802_11_remove_key(_adapter*	p
 	uint				encryptionalgo;
 	u8 * pbssid;
 	struct sta_info *stainfo;
-	u8	bgroup = (key->KeyIndex & 0x4000000) > 0 ? _FALSE: _TRUE;
+	u8	bgroup = (key->KeyIndex & 0x4000000) > 0 ? false : true;
 	u8	keyIndex = (u8)key->KeyIndex & 0x03;
 	u8	ret=_SUCCESS;
 
@@ -1128,7 +1128,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	if (bgroup == _TRUE) {
+	if (bgroup == true) {
 		encryptionalgo= padapter->securitypriv.dot118021XGrpPrivacy;
 		// clear group key by index
 		//NdisZeroMemory(Adapter->MgntInfo.SecurityInfo.KeyBuf[keyIndex], MAX_WEP_KEY_LEN);
@@ -1161,7 +1161,7 @@ exit:
 
 _func_exit_;
 
-	return _TRUE;
+	return true;
 
 }
 
@@ -1192,13 +1192,13 @@ u16 rtw_get_cur_max_rate(_adapter *adapt
 #ifdef CONFIG_MP_INCLUDED
 	if (adapter->registrypriv.mp_mode == 1)
 	{
-		if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+		if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
 			return 0;
 	}
 #endif
 
-	if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE)
-		&& (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != _TRUE))
+	if((check_fwstate(pmlmepriv, _FW_LINKED) != true)
+		&& (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != true))
 		return 0;
 
 #ifdef CONFIG_80211N_HT
--- a/drivers/staging/rtl8192du/core/rtw_iol.c
+++ b/drivers/staging/rtl8192du/core/rtw_iol.c
@@ -234,10 +234,10 @@ int rtw_IOL_exec_empty_cmds_sync(ADAPTER
 bool rtw_IOL_applied(ADAPTER *adapter)
 {
 	if(adapter->registrypriv.force_iol)
-		return _TRUE;
+		return true;
 	if(!adapter_to_dvobj(adapter)->ishighspeed)
-		return _TRUE;
-	return _FALSE;
+		return true;
+	return false;
 }
 
 #endif //CONFIG_IOL
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -196,7 +196,7 @@ _func_enter_;
 
 	_enter_critical_bh(&queue->lock, &irqL);
 
-	if (_rtw_queue_empty(queue) == _TRUE)
+	if (_rtw_queue_empty(queue) == true)
 
 		pnetwork = NULL;
 
@@ -225,7 +225,7 @@ _func_enter_;
 
 	_enter_critical_bh(&free_queue->lock, &irqL);
 
-	if (_rtw_queue_empty(free_queue) == _TRUE) {
+	if (_rtw_queue_empty(free_queue) == true) {
 		pnetwork=NULL;
 		goto exit;
 	}
@@ -237,7 +237,7 @@ _func_enter_;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("_rtw_alloc_network: ptr=%p\n", plist));
 	pnetwork->network_type = 0;
-	pnetwork->fixed = _FALSE;
+	pnetwork->fixed = false;
 	pnetwork->last_scanned = rtw_get_current_time();
 	pnetwork->aid=0;
 	pnetwork->join_res=0;
@@ -264,13 +264,13 @@ _func_enter_;
 	if (pnetwork == NULL)
 		goto exit;
 
-	if (pnetwork->fixed == _TRUE)
+	if (pnetwork->fixed == true)
 		goto exit;
 
 	curr_time = rtw_get_current_time();
 
-	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_TRUE ) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE ) )
+	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==true ) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true ) )
 		lifetime = 1;
 
 	if(!isfreeall)
@@ -309,7 +309,7 @@ _func_enter_;
 	if (pnetwork == NULL)
 		goto exit;
 
-	if (pnetwork->fixed == _TRUE)
+	if (pnetwork->fixed == true)
 		goto exit;
 
 	//_enter_critical(&free_queue->lock, &irqL);
@@ -358,7 +358,7 @@ _func_enter_;
        {
                 pnetwork = LIST_CONTAINOR(plist, struct wlan_network ,list);
 
-		if (_rtw_memcmp(addr, pnetwork->network.MacAddress, ETH_ALEN) == _TRUE)
+		if (_rtw_memcmp(addr, pnetwork->network.MacAddress, ETH_ALEN) == true)
                         break;
 
 		plist = get_next(plist);
@@ -394,7 +394,7 @@ _func_enter_;
 	phead = get_list_head(scanned_queue);
 	plist = get_next(phead);
 
-	while (rtw_end_of_queue_search(phead, plist) == _FALSE)
+	while (rtw_end_of_queue_search(phead, plist) == false)
 	{
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -420,12 +420,12 @@ sint rtw_if_up(_adapter *padapter)	{
 _func_enter_;
 
 	if( padapter->bDriverStopped || padapter->bSurpriseRemoved ||
-		(check_fwstate(&padapter->mlmepriv, _FW_LINKED)== _FALSE)){
+		(check_fwstate(&padapter->mlmepriv, _FW_LINKED)== false)){
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_if_up:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
-		res=_FALSE;
+		res=false;
 	}
 	else
-		res=  _TRUE;
+		res=  true;
 
 _func_exit_;
 	return res;
@@ -561,22 +561,22 @@ struct	wlan_network *rtw_find_network(_q
 
 int rtw_is_same_ibss(_adapter *adapter, struct wlan_network *pnetwork)
 {
-	int ret=_TRUE;
+	int ret=true;
 	struct security_priv *psecuritypriv = &adapter->securitypriv;
 
 	if ( (psecuritypriv->dot11PrivacyAlgrthm != _NO_PRIVACY_ ) &&
 		    ( pnetwork->network.Privacy == 0 ) )
 	{
-		ret=_FALSE;
+		ret=false;
 	}
 	else if((psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_ ) &&
 		 ( pnetwork->network.Privacy == 1 ) )
 	{
-		ret=_FALSE;
+		ret=false;
 	}
 	else
 	{
-		ret=_TRUE;
+		ret=true;
 	}
 
 	return ret;
@@ -589,7 +589,7 @@ inline int is_same_ess(WLAN_BSSID_EX *a,
 	//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("(%s,%d)(%s,%d)\n",
 	//		a->Ssid.Ssid,a->Ssid.SsidLength,b->Ssid.Ssid,b->Ssid.SsidLength));
 	return (a->Ssid.SsidLength == b->Ssid.SsidLength)
-		&&  _rtw_memcmp(a->Ssid.Ssid, b->Ssid.Ssid, a->Ssid.SsidLength)==_TRUE;
+		&&  _rtw_memcmp(a->Ssid.Ssid, b->Ssid.Ssid, a->Ssid.SsidLength)==true;
 }
 
 int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst)
@@ -609,8 +609,8 @@ _func_exit_;
 
 	return ((src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
 		//	(src->Configuration.DSConfig == dst->Configuration.DSConfig) &&
-			( (_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == _TRUE) &&
-			( (_rtw_memcmp(src->Ssid.Ssid, dst->Ssid.Ssid, src->Ssid.SsidLength)) == _TRUE) &&
+			( (_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == true) &&
+			( (_rtw_memcmp(src->Ssid.Ssid, dst->Ssid.Ssid, src->Ssid.SsidLength)) == true) &&
 			((s_cap & WLAN_CAPABILITY_IBSS) ==
 			(d_cap & WLAN_CAPABILITY_IBSS)) &&
 			((s_cap & WLAN_CAPABILITY_BSS) ==
@@ -633,12 +633,12 @@ _func_enter_;
 	while(1)
 	{
 
-		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+		if (rtw_end_of_queue_search(phead,plist)== true)
 			break;
 
 		pwlan= LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		if(pwlan->fixed!=_TRUE)
+		if(pwlan->fixed!=true)
 		{
 			if (oldest == NULL ||time_after(oldest->last_scanned, pwlan->last_scanned))
 				oldest = pwlan;
@@ -731,13 +731,13 @@ static void update_current_network(_adap
 
 _func_enter_;
 
-	if ( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) && (is_same_network(&(pmlmepriv->cur_network.network), pnetwork)))
+	if ( (check_fwstate(pmlmepriv, _FW_LINKED)== true) && (is_same_network(&(pmlmepriv->cur_network.network), pnetwork)))
 	{
 		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"Same Network\n");
 
 		//if(pmlmepriv->cur_network.network.IELength<= pnetwork->IELength)
 		{
-			update_network(&(pmlmepriv->cur_network.network), pnetwork,adapter, _TRUE);
+			update_network(&(pmlmepriv->cur_network.network), pnetwork,adapter, true);
 			rtw_update_protection(adapter, (pmlmepriv->cur_network.network.IEs) + sizeof (NDIS_802_11_FIXED_IEs),
 									pmlmepriv->cur_network.network.IELength);
 		}
@@ -772,7 +772,7 @@ _func_enter_;
 
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+		if (rtw_end_of_queue_search(phead,plist)== true)
 			break;
 
 		pnetwork	= LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -795,9 +795,9 @@ _func_enter_;
 
 	/* If we didn't find a match, then get a new network slot to initialize
 	 * with this beacon's information */
-	if (rtw_end_of_queue_search(phead,plist)== _TRUE) {
+	if (rtw_end_of_queue_search(phead,plist)== true) {
 
-		if (_rtw_queue_empty(&(pmlmepriv->free_bss_pool)) == _TRUE) {
+		if (_rtw_queue_empty(&(pmlmepriv->free_bss_pool)) == true) {
 			/* If there are no more slots, expire the oldest */
 			//list_del_init(&oldest->list);
 			pnetwork = oldest;
@@ -809,7 +809,7 @@ _func_enter_;
 			_rtw_memcpy(&(pnetwork->network), target,  get_WLAN_BSSID_EX_sz(target));
 			//pnetwork->last_scanned = rtw_get_current_time();
 			// variable initialize
-			pnetwork->fixed = _FALSE;
+			pnetwork->fixed = false;
 			pnetwork->last_scanned = rtw_get_current_time();
 
 			pnetwork->network_type = 0;
@@ -853,13 +853,13 @@ _func_enter_;
 		 * be already expired. In this case we do the same as we found a new
 		 * net and call the new_net handler
 		 */
-		bool update_ie = _TRUE;
+		bool update_ie = true;
 
 		pnetwork->last_scanned = rtw_get_current_time();
 
 		//target.Reserved[0]==1, means that scaned network is a bcn frame.
 		if((pnetwork->network.IELength>target->IELength) && (target->Reserved[0]==1))
-			update_ie = _FALSE;
+			update_ie = false;
 
 		update_network(&(pnetwork->network), target,adapter, update_ie);
 	}
@@ -911,7 +911,7 @@ int rtw_is_desired_network(_adapter *ada
 	//u8 wps_ie[512];
 	uint wps_ielen;
 
-	int bselected = _TRUE;
+	int bselected = true;
 
 	desired_encmode = psecuritypriv->ndisencryptstatus;
 	privacy = pnetwork->network.Privacy;
@@ -920,29 +920,29 @@ int rtw_is_desired_network(_adapter *ada
 	{
 		if(rtw_get_wps_ie(pnetwork->network.IEs+_FIXED_IE_LENGTH_, pnetwork->network.IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen)!=NULL)
 		{
-			return _TRUE;
+			return true;
 		}
 		else
 		{
-			return _FALSE;
+			return false;
 		}
 	}
 	if (adapter->registrypriv.wifi_spec == 1) //for  correct flow of 8021X  to do....
 	{
 		if ((desired_encmode == Ndis802_11EncryptionDisabled) && (privacy != 0))
-	            bselected = _FALSE;
+	            bselected = false;
 	}
 
 
 	if ((desired_encmode != Ndis802_11EncryptionDisabled) && (privacy == 0)) {
 		DBG_871X("desired_encmode: %d, privacy: %d\n", desired_encmode, privacy);
-		bselected = _FALSE;
+		bselected = false;
 	}
 
-	if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+	if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)
 	{
 		if(pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
-			bselected = _FALSE;
+			bselected = false;
 	}
 
 
@@ -1003,7 +1003,7 @@ _func_enter_;
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
 	// update IBSS_network 's timestamp
-	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == _TRUE)
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true)
 	{
 		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"rtw_survey_event_callback : WIFI_ADHOC_MASTER_STATE \n\n");
 		if(_rtw_memcmp(&(pmlmepriv->cur_network.network.MacAddress), pnetwork->MacAddress, ETH_ALEN))
@@ -1025,7 +1025,7 @@ _func_enter_;
 	}
 
 	// lock pmlmepriv->lock when you accessing network_q
-	if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == _FALSE)
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == false)
 	{
 	        if( pnetwork->Ssid.Ssid[0] == 0 )
 		{
@@ -1086,11 +1086,11 @@ _func_enter_;
 	rtw_set_signal_stat_timer(&adapter->recvpriv);
 	#endif
 
-	if(pmlmepriv->to_join == _TRUE)
+	if(pmlmepriv->to_join == true)
 	{
-		if((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE) )
+		if((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true) )
 		{
-			if(check_fwstate(pmlmepriv, _FW_LINKED)==_FALSE)
+			if(check_fwstate(pmlmepriv, _FW_LINKED)==false)
 			{
 				set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
 
@@ -1121,7 +1121,7 @@ _func_enter_;
 					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Error=>rtw_createbss_cmd status FAIL\n"));
 					}
 
-					pmlmepriv->to_join = _FALSE;
+					pmlmepriv->to_join = false;
 				}
 			}
 		}
@@ -1129,7 +1129,7 @@ _func_enter_;
 		{
 			int s_ret;
 			set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
-			pmlmepriv->to_join = _FALSE;
+			pmlmepriv->to_join = false;
 			if(_SUCCESS == (s_ret=rtw_select_and_join_from_scanned_queue(pmlmepriv)))
 			{
 			     _set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
@@ -1159,7 +1159,7 @@ _func_enter_;
 						rtw_free_assoc_resources(adapter, 1);
 						rtw_indicate_disconnect(adapter);
 					} else {
-						pmlmepriv->to_join = _TRUE;
+						pmlmepriv->to_join = true;
 					}
 				}
 				#endif
@@ -1174,7 +1174,7 @@ _func_enter_;
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 
 #ifdef CONFIG_P2P_PS
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
 		p2p_ps_wk_cmd(adapter, P2P_PS_SCAN_DONE, 0);
 	}
 #endif // CONFIG_P2P_PS
@@ -1317,7 +1317,7 @@ _func_enter_;
 	pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
 	if(pwlan)
 	{
-		pwlan->fixed = _FALSE;
+		pwlan->fixed = false;
 	}
 	else
 	{
@@ -1352,7 +1352,7 @@ _func_enter_;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("+rtw_indicate_connect\n"));
 
-	pmlmepriv->to_join = _FALSE;
+	pmlmepriv->to_join = false;
 
 	if(!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
 	{
@@ -1433,7 +1433,7 @@ _func_enter_;
 
 #ifdef CONFIG_LPS
 #ifdef CONFIG_WOWLAN
-	if(padapter->pwrctrlpriv.wowlan_mode==_FALSE)
+	if(padapter->pwrctrlpriv.wowlan_mode==false)
 #endif //CONFIG_WOWLAN
 	rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_DISCONNECT, 1);
 
@@ -1455,7 +1455,7 @@ void rtw_scan_abort(_adapter *adapter)
 	struct mlme_ext_priv	*pmlmeext = &(adapter->mlmeextpriv);
 
 	start = rtw_get_current_time();
-	pmlmeext->scan_abort = _TRUE;
+	pmlmeext->scan_abort = true;
 	while (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)
 		&& rtw_get_passing_time_ms(start) <= 200) {
 
@@ -1469,9 +1469,9 @@ void rtw_scan_abort(_adapter *adapter)
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {
 		if (!adapter->bDriverStopped && !adapter->bSurpriseRemoved)
 			DBG_871X(FUNC_NDEV_FMT"waiting for scan_abort time out!\n", FUNC_NDEV_ARG(adapter->pnetdev));
-		rtw_indicate_scan_done(adapter, _TRUE);
+		rtw_indicate_scan_done(adapter, true);
 	}
-	pmlmeext->scan_abort = _FALSE;
+	pmlmeext->scan_abort = false;
 }
 
 static struct sta_info *rtw_joinbss_update_stainfo(_adapter *padapter, struct wlan_network *pnetwork)
@@ -1507,11 +1507,11 @@ static struct sta_info *rtw_joinbss_upda
 		//security related
 		if(padapter->securitypriv.dot11AuthAlgrthm== dot11AuthAlgrthm_8021X)
 		{
-			padapter->securitypriv.binstallGrpkey=_FALSE;
-			padapter->securitypriv.busetkipkey=_FALSE;
-			padapter->securitypriv.bgrpkey_handshake=_FALSE;
+			padapter->securitypriv.binstallGrpkey=false;
+			padapter->securitypriv.busetkipkey=false;
+			padapter->securitypriv.bgrpkey_handshake=false;
 
-			psta->ieee8021x_blocked=_TRUE;
+			psta->ieee8021x_blocked=true;
 			psta->dot118021XPrivacy=padapter->securitypriv.dot11PrivacyAlgrthm;
 
 			_rtw_memset((u8 *)&psta->dot118021x_UncstKey, 0, sizeof (union Keytype));
@@ -1528,7 +1528,7 @@ static struct sta_info *rtw_joinbss_upda
 		//	And the Wi-Fi driver shouldn't allow the data packet to be tramsmitted.
 		if ( padapter->securitypriv.wps_ie_len != 0 )
 		{
-			psta->ieee8021x_blocked=_TRUE;
+			psta->ieee8021x_blocked=true;
 			padapter->securitypriv.wps_ie_len = 0;
 		}
 
@@ -1540,7 +1540,7 @@ static struct sta_info *rtw_joinbss_upda
 		{
 			//preorder_ctrl = &precvpriv->recvreorder_ctrl[i];
 			preorder_ctrl = &psta->recvreorder_ctrl[i];
-			preorder_ctrl->enable = _FALSE;
+			preorder_ctrl->enable = false;
 			preorder_ctrl->indicate_seq = 0xffff;
 			#ifdef DBG_RX_SEQ
 			DBG_871X("DBG_RX_SEQ %s:%d indicate_seq:%u \n", __FUNCTION__, __LINE__,
@@ -1558,7 +1558,7 @@ static struct sta_info *rtw_joinbss_upda
 			{
 				//preorder_ctrl = &precvpriv->recvreorder_ctrl[i];
 				preorder_ctrl = &bmc_sta->recvreorder_ctrl[i];
-				preorder_ctrl->enable = _FALSE;
+				preorder_ctrl->enable = false;
 				preorder_ctrl->indicate_seq = 0xffff;
 				#ifdef DBG_RX_SEQ
 				DBG_871X("DBG_RX_SEQ %s:%d indicate_seq:%u \n", __FUNCTION__, __LINE__,
@@ -1667,7 +1667,7 @@ void rtw_joinbss_event_prehandle(_adapte
 	struct wlan_network	*pnetwork	= (struct wlan_network *)pbuf;
 	struct wlan_network	*cur_network = &(pmlmepriv->cur_network);
 	struct wlan_network	*pcur_wlan = NULL, *ptarget_wlan = NULL;
-	unsigned int		the_same_macaddr = _FALSE;
+	unsigned int		the_same_macaddr = false;
 
 _func_enter_;
 
@@ -1728,14 +1728,14 @@ _func_enter_;
 			//s1. find ptarget_wlan
 			if(check_fwstate(pmlmepriv, _FW_LINKED) )
 			{
-				if(the_same_macaddr == _TRUE)
+				if(the_same_macaddr == true)
 				{
 					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
 				}
 				else
 				{
 					pcur_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
-					if(pcur_wlan)	pcur_wlan->fixed = _FALSE;
+					if(pcur_wlan)	pcur_wlan->fixed = false;
 
 					pcur_sta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
 					if(pcur_sta){
@@ -1745,8 +1745,8 @@ _func_enter_;
 					}
 
 					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
-					if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE){
-						if(ptarget_wlan)	ptarget_wlan->fixed = _TRUE;
+					if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true){
+						if(ptarget_wlan)	ptarget_wlan->fixed = true;
 					}
 				}
 
@@ -1754,8 +1754,8 @@ _func_enter_;
 			else
 			{
 				ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
-				if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE){
-					if(ptarget_wlan)	ptarget_wlan->fixed = _TRUE;
+				if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true){
+					if(ptarget_wlan)	ptarget_wlan->fixed = true;
 				}
 			}
 
@@ -1773,7 +1773,7 @@ _func_enter_;
 
 
 			//s3. find ptarget_sta & update ptarget_sta after update cur_network only for station mode
-			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 			{
 				ptarget_sta = rtw_joinbss_update_stainfo(adapter, pnetwork);
 				if(ptarget_sta==NULL)
@@ -1785,7 +1785,7 @@ _func_enter_;
 			}
 
 			//s4. indicate connect
-			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 			{
 				rtw_indicate_connect(adapter);
 			}
@@ -1819,7 +1819,7 @@ _func_enter_;
 
 		//rtw_free_assoc_resources(adapter, 1);
 
-		if((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == _TRUE)
+		if((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == true)
 		{
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("fail! clear _FW_UNDER_LINKING ^^^fw_state=%x\n", get_fwstate(pmlmepriv)));
 			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
@@ -1900,7 +1900,7 @@ void rtw_stassoc_event_callback(_adapter
 
 _func_enter_;
 
-	if(rtw_access_ctrl(adapter, pstassoc->macaddr) == _FALSE)
+	if(rtw_access_ctrl(adapter, pstassoc->macaddr) == false)
 		return;
 
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
@@ -1974,18 +1974,18 @@ _func_enter_;
 	if(adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)
 		psta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;
 
-	psta->ieee8021x_blocked = _FALSE;
+	psta->ieee8021x_blocked = false;
 
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
-	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_TRUE ) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE ) )
+	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==true ) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true ) )
 	{
 		if(adapter->stapriv.asoc_sta_count== 2)
 		{
 			_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 			ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
-			if(ptarget_wlan)	ptarget_wlan->fixed = _TRUE;
+			if(ptarget_wlan)	ptarget_wlan->fixed = true;
 			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 			// a sta + bc/mc_stainfo (not Ibss_stainfo)
 			rtw_indicate_connect(adapter);
@@ -1999,7 +1999,7 @@ _func_enter_;
 
 #ifdef CONFIG_RTL8711
 	//submit SetStaKey_cmd to tell fw, fw will allocate an CAM entry for this sta
-	rtw_setstakey_cmd(adapter, (unsigned char*)psta, _FALSE);
+	rtw_setstakey_cmd(adapter, (unsigned char*)psta, false);
 #endif
 
 exit:
@@ -2062,7 +2062,7 @@ _func_enter_;
 		// remove the network entry in scanned_queue
 		pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
 		if (pwlan) {
-			pwlan->fixed = _FALSE;
+			pwlan->fixed = false;
 			rtw_free_network_nolock(pmlmepriv, pwlan);
 		}
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
@@ -2093,7 +2093,7 @@ _func_enter_;
 			pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
 			if(pwlan)
 			{
-				pwlan->fixed = _FALSE;
+				pwlan->fixed = false;
 				rtw_free_network_nolock(pmlmepriv, pwlan);
 			}
 			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
@@ -2236,7 +2236,7 @@ void rtw_scan_timeout_handler (_adapter
 
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 
-	rtw_indicate_scan_done(adapter, _TRUE);
+	rtw_indicate_scan_done(adapter, true);
 
 }
 
@@ -2252,13 +2252,13 @@ static void rtw_auto_scan_handler(_adapt
 		if(pmlmepriv->scan_interval==0)
 		{
 /*
-			if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+			if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
 			{
 				DBG_871X("exit %s when _FW_UNDER_SURVEY|_FW_UNDER_LINKING -> \n", __FUNCTION__);
 				return;
 			}
 
-			if(pmlmepriv->sitesurveyctrl.traffic_busy == _TRUE)
+			if(pmlmepriv->sitesurveyctrl.traffic_busy == true)
 			{
 				DBG_871X("%s exit cause traffic_busy(%x)\n",__FUNCTION__, pmlmepriv->sitesurveyctrl.traffic_busy);
 				return;
@@ -2268,8 +2268,8 @@ static void rtw_auto_scan_handler(_adapt
 #ifdef CONFIG_CONCURRENT_MODE
 			if (rtw_buddy_adapter_up(padapter))
 			{
-				if ((check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) ||
-					(padapter->pbuddy_adapter->mlmepriv.LinkDetectInfo.bBusyTraffic == _TRUE))
+				if ((check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true) ||
+					(padapter->pbuddy_adapter->mlmepriv.LinkDetectInfo.bBusyTraffic == true))
 				{
 					DBG_871X("%s, but buddy_intf is under scanning or linking or BusyTraffic\n", __FUNCTION__);
 					return;
@@ -2302,24 +2302,24 @@ void rtw_dynamic_check_timer_handlder(_a
 	if(!adapter)
 		return;
 
-	if(adapter->hw_init_completed == _FALSE)
+	if(adapter->hw_init_completed == false)
 		return;
 
-	if ((adapter->bDriverStopped == _TRUE)||(adapter->bSurpriseRemoved== _TRUE))
+	if ((adapter->bDriverStopped == true)||(adapter->bSurpriseRemoved== true))
 		return;
 
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if(pbuddy_adapter)
 	{
-		if(adapter->net_closed == _TRUE && pbuddy_adapter->net_closed == _TRUE)
+		if(adapter->net_closed == true && pbuddy_adapter->net_closed == true)
 		{
 			return;
 		}
 	}
 	else
 #endif //CONFIG_CONCURRENT_MODE
-	if(adapter->net_closed == _TRUE)
+	if(adapter->net_closed == true)
 	{
 		return;
 	}
@@ -2340,7 +2340,7 @@ void rtw_dynamic_check_timer_handlder(_a
 
 #ifndef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
 #ifdef CONFIG_AP_MODE
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		expire_timeout_chk(adapter);
 	}
@@ -2358,7 +2358,7 @@ void rtw_dynamic_check_timer_handlder(_a
 #else	// (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 	if( rcu_dereference(adapter->pnetdev->rx_handler_data)
 #endif	// (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-		&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == _TRUE) )
+		&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) )
 	{
 		// expire NAT2.5 entry
 		void nat25_db_expire(_adapter *priv);
@@ -2387,7 +2387,7 @@ void rtw_dynamic_check_timer_handlder(_a
 inline bool rtw_is_scan_deny(_adapter *adapter)
 {
 	struct mlme_priv *mlmepriv = &adapter->mlmepriv;
-	return (ATOMIC_READ(&mlmepriv->set_scan_deny) != 0) ? _TRUE : _FALSE;
+	return (ATOMIC_READ(&mlmepriv->set_scan_deny) != 0) ? true : false;
 }
 
 inline void rtw_clear_scan_deny(_adapter *adapter)
@@ -2437,37 +2437,37 @@ void rtw_set_scan_deny(_adapter *adapter
 
 /*
 * Select a new join candidate from the original @param candidate and @param competitor
-* @return _TRUE: candidate is updated
-* @return _FALSE: candidate is not updated
+* @return true: candidate is updated
+* @return false: candidate is not updated
 */
 static int rtw_check_join_candidate(struct mlme_priv *pmlmepriv
 	, struct wlan_network **candidate, struct wlan_network *competitor)
 {
-	int updated = _FALSE;
+	int updated = false;
 	_adapter *adapter = container_of(pmlmepriv, _adapter, mlmepriv);
 
 
 	//check bssid, if needed
-	if(pmlmepriv->assoc_by_bssid==_TRUE) {
-		if(_rtw_memcmp(competitor->network.MacAddress, pmlmepriv->assoc_bssid, ETH_ALEN) ==_FALSE)
+	if(pmlmepriv->assoc_by_bssid==true) {
+		if(_rtw_memcmp(competitor->network.MacAddress, pmlmepriv->assoc_bssid, ETH_ALEN) ==false)
 			goto exit;
 	}
 
 	//check ssid, if needed
 	if(pmlmepriv->assoc_ssid.Ssid && pmlmepriv->assoc_ssid.SsidLength) {
 		if(	competitor->network.Ssid.SsidLength != pmlmepriv->assoc_ssid.SsidLength
-			|| _rtw_memcmp(competitor->network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength) == _FALSE
+			|| _rtw_memcmp(competitor->network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength) == false
 		)
 			goto exit;
 	}
 
-	if(rtw_is_desired_network(adapter, competitor)  == _FALSE)
+	if(rtw_is_desired_network(adapter, competitor)  == false)
 		goto exit;
 
 #ifdef  CONFIG_LAYER2_ROAMING
 	if(rtw_to_roaming(adapter) > 0) {
 		if(	rtw_get_passing_time_ms((u32)competitor->last_scanned) >= RTW_SCAN_RESULT_EXPIRE
-			|| is_same_ess(&competitor->network, &pmlmepriv->cur_network.network) == _FALSE
+			|| is_same_ess(&competitor->network, &pmlmepriv->cur_network.network) == false
 		)
 			goto exit;
 	}
@@ -2476,7 +2476,7 @@ static int rtw_check_join_candidate(stru
 	if(*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi )
 	{
 		*candidate = competitor;
-		updated = _TRUE;
+		updated = true;
 	}
 
 	if(updated){
@@ -2520,7 +2520,7 @@ int rtw_select_and_join_from_scanned_que
 	_queue	*queue	= &(pmlmepriv->scanned_queue);
 	struct	wlan_network	*pnetwork = NULL;
 	struct	wlan_network	*candidate = NULL;
-	u8		bSupportAntDiv = _FALSE;
+	u8		bSupportAntDiv = false;
 
 _func_enter_;
 
@@ -2556,18 +2556,18 @@ _func_enter_;
 
 
 	// check for situation of  _FW_LINKED
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		DBG_871X("%s: _FW_LINKED while ask_for_joinbss!!!\n", __FUNCTION__);
 
-		rtw_disassoc_cmd(adapter, 0, _TRUE);
+		rtw_disassoc_cmd(adapter, 0, true);
 		rtw_indicate_disconnect(adapter);
 		rtw_free_assoc_resources(adapter, 0);
 	}
 
 	#ifdef CONFIG_ANTENNA_DIVERSITY
 	rtw_hal_get_def_var(adapter, HAL_DEF_IS_SUPPORT_ANT_DIV, &(bSupportAntDiv));
-	if(_TRUE == bSupportAntDiv)
+	if(true == bSupportAntDiv)
 	{
 		u8 CurrentAntenna;
 		rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(CurrentAntenna));
@@ -2673,7 +2673,7 @@ _func_enter_;
 	psetkeyparm->set_tx = set_tx;
 	pmlmepriv->key_mask |= BIT(psetkeyparm->keyid);
 #ifdef CONFIG_AUTOSUSPEND
-	if( _TRUE  == adapter->pwrctrlpriv.bInternalAutoSuspend)
+	if( true  == adapter->pwrctrlpriv.bInternalAutoSuspend)
 	{
 		adapter->pwrctrlpriv.wepkeymask = pmlmepriv->key_mask;
 		DBG_871X("....AutoSuspend pwrctrlpriv.wepkeymask(%x)\n",adapter->pwrctrlpriv.wepkeymask);
@@ -2792,7 +2792,7 @@ static int SecIsInPMKIDList(_adapter *Ad
 	do
 	{
 		if( ( psecuritypriv->PMKIDList[i].bUsed ) &&
-                    (  _rtw_memcmp( psecuritypriv->PMKIDList[i].Bssid, bssid, ETH_ALEN ) == _TRUE ) )
+                    (  _rtw_memcmp( psecuritypriv->PMKIDList[i].Bssid, bssid, ETH_ALEN ) == true ) )
 		{
 			break;
 		}
@@ -3029,7 +3029,7 @@ void rtw_joinbss_reset(_adapter *padapte
 
 	pmlmepriv->num_sta_no_ht = 0;
 
-	phtpriv->ampdu_enable = _FALSE;//reset to disabled
+	phtpriv->ampdu_enable = false;//reset to disabled
 
 	// TH=1 => means that invalidate usb rx aggregation
 	// TH=0 => means that validate usb rx aggregation, use init value.
@@ -3064,7 +3064,7 @@ unsigned int rtw_restructure_ht_ie(_adap
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
 	u8 cbw40_enable = 0;
 
-	phtpriv->ht_option = _FALSE;
+	phtpriv->ht_option = false;
 
 	p = rtw_get_ie(in_ie+12, _HT_CAPABILITY_IE_, &ielen, in_len-12);
 
@@ -3126,7 +3126,7 @@ unsigned int rtw_restructure_ht_ie(_adap
 		//*pout_len = *pout_len + (ielen+2);
 
 
-		phtpriv->ht_option = _TRUE;
+		phtpriv->ht_option = true;
 
 		p = rtw_get_ie(in_ie+12, _HT_ADD_INFO_IE_, &ielen, in_len-12);
 		if(p && (ielen==sizeof(struct ieee80211_ht_addt_info)))
@@ -3168,20 +3168,20 @@ void rtw_update_ht_cap(_adapter *padapte
 	DBG_871X("+rtw_update_ht_cap()\n");
 
 	//maybe needs check if ap supports rx ampdu.
-	if((phtpriv->ampdu_enable==_FALSE) &&(pregistrypriv->ampdu_enable==1))
+	if((phtpriv->ampdu_enable==false) &&(pregistrypriv->ampdu_enable==1))
 	{
 		if(pregistrypriv->wifi_spec==1)
 		{
-			phtpriv->ampdu_enable = _FALSE;
+			phtpriv->ampdu_enable = false;
 		}
 		else
 		{
-			phtpriv->ampdu_enable = _TRUE;
+			phtpriv->ampdu_enable = true;
 		}
 	}
 	else if(pregistrypriv->ampdu_enable==2)
 	{
-		phtpriv->ampdu_enable = _TRUE;
+		phtpriv->ampdu_enable = true;
 	}
 
 
@@ -3306,7 +3306,7 @@ void rtw_issue_addbareq_cmd(_adapter *pa
 	struct pkt_attrib *pattrib =&pxmitframe->attrib;
 	s32 bmcst = IS_MCAST(pattrib->ra);
 
-	if(bmcst || (padapter->mlmepriv.LinkDetectInfo.bTxBusyTraffic == _FALSE))
+	if(bmcst || (padapter->mlmepriv.LinkDetectInfo.bTxBusyTraffic == false))
 		return;
 
 	priority = pattrib->priority;
@@ -3321,7 +3321,7 @@ void rtw_issue_addbareq_cmd(_adapter *pa
 
 	phtpriv = &psta->htpriv;
 
-	if((phtpriv->ht_option==_TRUE) && (phtpriv->ampdu_enable==_TRUE))
+	if((phtpriv->ht_option==true) && (phtpriv->ampdu_enable==true))
 	{
 		issued = (phtpriv->agg_enable_bitmap>>priority)&0x1;
 		issued |= (phtpriv->candidate_tid_bitmap>>priority)&0x1;
@@ -3342,7 +3342,7 @@ void rtw_issue_addbareq_cmd(_adapter *pa
 inline void rtw_set_roaming(_adapter *adapter, u8 to_roaming)
 {
 	if (to_roaming == 0)
-		adapter->mlmepriv.to_join = _FALSE;
+		adapter->mlmepriv.to_join = false;
 	adapter->mlmepriv.to_roaming = to_roaming;
 }
 
@@ -3378,7 +3378,7 @@ void _rtw_roaming(_adapter *padapter, st
 				pnetwork->network.Ssid.SsidLength);
 		_rtw_memcpy(&pmlmepriv->assoc_ssid, &pnetwork->network.Ssid, sizeof(NDIS_802_11_SSID));
 
-		pmlmepriv->assoc_by_bssid = _FALSE;
+		pmlmepriv->assoc_by_bssid = false;
 
 		while(1) {
 			if( _SUCCESS==(do_join_r=rtw_do_join(padapter)) ) {
@@ -3404,7 +3404,7 @@ void _rtw_roaming(_adapter *padapter, st
 #ifdef CONFIG_CONCURRENT_MODE
 sint rtw_buddy_adapter_up(_adapter *padapter)
 {
-	sint res = _FALSE;
+	sint res = false;
 
 	if(padapter == NULL)
 		return res;
@@ -3412,16 +3412,16 @@ sint rtw_buddy_adapter_up(_adapter *pada
 
 	if(padapter->pbuddy_adapter == NULL)
 	{
-		res = _FALSE;
+		res = false;
 	}
 	else if( (padapter->pbuddy_adapter->bDriverStopped) || (padapter->pbuddy_adapter->bSurpriseRemoved) ||
-		(padapter->pbuddy_adapter->bup == _FALSE) || (padapter->pbuddy_adapter->hw_init_completed == _FALSE))
+		(padapter->pbuddy_adapter->bup == false) || (padapter->pbuddy_adapter->hw_init_completed == false))
 	{
-		res = _FALSE;
+		res = false;
 	}
 	else
 	{
-		res = _TRUE;
+		res = true;
 	}
 
 	return res;
@@ -3431,18 +3431,18 @@ sint rtw_buddy_adapter_up(_adapter *pada
 sint check_buddy_fwstate(_adapter *padapter, sint state)
 {
 	if(padapter == NULL)
-		return _FALSE;
+		return false;
 
 	if(padapter->pbuddy_adapter == NULL)
-		return _FALSE;
+		return false;
 
 	if ((state == WIFI_FW_NULL_STATE) &&
 		(padapter->pbuddy_adapter->mlmepriv.fw_state == WIFI_FW_NULL_STATE))
-		return _TRUE;
+		return true;
 
 	if (padapter->pbuddy_adapter->mlmepriv.fw_state & state)
-		return _TRUE;
+		return true;
 
-	return _FALSE;
+	return false;
 }
 #endif //CONFIG_CONCURRENT_MODE
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -320,7 +320,7 @@ static void init_mlme_ext_priv_value(_ad
 	pmlmeext->sitesurvey_res.state = SCAN_DISABLE;
 	pmlmeext->sitesurvey_res.channel_idx = 0;
 	pmlmeext->sitesurvey_res.bss_cnt = 0;
-	pmlmeext->scan_abort = _FALSE;
+	pmlmeext->scan_abort = false;
 
 	pmlmeinfo->state = WIFI_FW_NULL_STATE;
 	pmlmeinfo->reauth_count = 0;
@@ -414,7 +414,7 @@ static void init_channel_list(_adapter *
 static u8 init_channel_set(_adapter* padapter, u8 ChannelPlan, RT_CHANNEL_INFO *channel_set)
 {
 	u8	index,chanset_size = 0;
-	u8	b5GBand = _FALSE, b2_4GBand = _FALSE;
+	u8	b5GBand = false, b2_4GBand = false;
 	u8	Index2G = 0, Index5G=0;
 
 	_rtw_memset(channel_set, 0, sizeof(RT_CHANNEL_INFO)*MAX_CHANNEL_NUM);
@@ -427,7 +427,7 @@ static u8 init_channel_set(_adapter* pad
 
 	if(padapter->registrypriv.wireless_mode & WIRELESS_11G)
 	{
-		b2_4GBand = _TRUE;
+		b2_4GBand = true;
 		if(RT_CHANNEL_DOMAIN_REALTEK_DEFINE == ChannelPlan)
 			Index2G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index2G;
 		else
@@ -436,7 +436,7 @@ static u8 init_channel_set(_adapter* pad
 
 	if(padapter->registrypriv.wireless_mode & WIRELESS_11A)
 	{
-		b5GBand = _TRUE;
+		b5GBand = true;
 		if(RT_CHANNEL_DOMAIN_REALTEK_DEFINE == ChannelPlan)
 			Index5G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index5G;
 		else
@@ -539,11 +539,11 @@ int	init_mlme_ext_priv(_adapter* padapte
 	init_channel_list(padapter, pmlmeext->channel_set, pmlmeext->max_chan_nums, &pmlmeext->channel_list);
 
 	pmlmeext->chan_scan_time = SURVEY_TO;
-	pmlmeext->mlmeext_init = _TRUE;
+	pmlmeext->mlmeext_init = true;
 
 
 #ifdef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
-	pmlmeext->active_keep_alive_check = _TRUE;
+	pmlmeext->active_keep_alive_check = true;
 #endif
 
 	return res;
@@ -557,7 +557,7 @@ void free_mlme_ext_priv (struct mlme_ext
 	if (!padapter)
 		return;
 
-	if (padapter->bDriverStopped == _TRUE)
+	if (padapter->bDriverStopped == true)
 	{
 		_cancel_timer_ex(&pmlmeext->survey_timer);
 		_cancel_timer_ex(&pmlmeext->link_timer);
@@ -686,7 +686,7 @@ void mgt_dispatcher(_adapter *padapter,
 	switch (GetFrameSubType(pframe))
 	{
 		case WIFI_AUTH:
-			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 				ptable->func = &OnAuth;
 			else
 				ptable->func = &OnAuthClient;
@@ -695,12 +695,12 @@ void mgt_dispatcher(_adapter *padapter,
 		case WIFI_REASSOCREQ:
 			_mgt_dispatcher(padapter, ptable, precv_frame);
 #ifdef CONFIG_HOSTAPD_MLME
-			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 				rtw_hostapd_mlme_rx(padapter, precv_frame);
 #endif
 			break;
 		case WIFI_PROBEREQ:
-			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 			{
 #ifdef CONFIG_HOSTAPD_MLME
 				rtw_hostapd_mlme_rx(padapter, precv_frame);
@@ -715,12 +715,12 @@ void mgt_dispatcher(_adapter *padapter,
 			_mgt_dispatcher(padapter, ptable, precv_frame);
 			break;
 		case WIFI_ACTION:
-			//if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+			//if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 			_mgt_dispatcher(padapter, ptable, precv_frame);
 			break;
 		default:
 			_mgt_dispatcher(padapter, ptable, precv_frame);
-			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 				rtw_hostapd_mlme_rx(padapter, precv_frame);
 			break;
 	}
@@ -735,10 +735,10 @@ void mgt_dispatcher(_adapter *padapter,
 #ifdef CONFIG_P2P
 u32 p2p_listen_state_process(_adapter *padapter, unsigned char *da)
 {
-	bool response = _TRUE;
+	bool response = true;
 
 #ifdef CONFIG_IOCTL_CFG80211
-	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled == _FALSE
+	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled == false
 		|| padapter->mlmepriv.wps_probe_resp_ie == NULL
 		|| padapter->mlmepriv.p2p_probe_resp_ie == NULL
 	)
@@ -747,17 +747,17 @@ u32 p2p_listen_state_process(_adapter *p
 			wdev_to_priv(padapter->rtw_wdev)->p2p_enabled,
 			padapter->mlmepriv.wps_probe_resp_ie,
 			padapter->mlmepriv.p2p_probe_resp_ie);
-		response = _FALSE;
+		response = false;
 	}
 #else
 	//	do nothing if the device name is empty
 	if ( !padapter->wdinfo.device_name_len )
 	{
-		response	= _FALSE;
+		response	= false;
 	}
 #endif
 
-	if (response == _TRUE)
+	if (response == true)
 		issue_probersp_p2p( padapter, da);
 
 	return _SUCCESS;
@@ -781,7 +781,7 @@ unsigned int OnProbeReq(_adapter *padapt
 	WLAN_BSSID_EX	*cur = &(pmlmeinfo->network);
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	uint len = precv_frame->u.hdr.len;
-	u8 is_valid_p2p_probereq = _FALSE;
+	u8 is_valid_p2p_probereq = false;
 
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
@@ -813,7 +813,7 @@ unsigned int OnProbeReq(_adapter *padapt
 
 		if( wifi_test_chk_rate == 1 )
 		{
-			if((is_valid_p2p_probereq = process_probe_req_p2p_ie(pwdinfo, pframe, len)) == _TRUE)
+			if((is_valid_p2p_probereq = process_probe_req_p2p_ie(pwdinfo, pframe, len)) == true)
 			{
 				if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE))
 				{
@@ -838,8 +838,8 @@ _continue:
 		return _SUCCESS;
 	}
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE &&
-		check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE)==_FALSE)
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == false &&
+		check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE)==false)
 	{
 		return _SUCCESS;
 	}
@@ -863,12 +863,12 @@ _continue:
 	//check (wildcard) SSID
 	if (p != NULL)
 	{
-		if(is_valid_p2p_probereq == _TRUE)
+		if(is_valid_p2p_probereq == true)
 		{
 			goto _issue_probersp;
 		}
 
-		if ( (ielen != 0 && _FALSE ==_rtw_memcmp((void *)(p+2), (void *)cur->Ssid.Ssid, cur->Ssid.SsidLength))
+		if ( (ielen != 0 && false ==_rtw_memcmp((void *)(p+2), (void *)cur->Ssid.Ssid, cur->Ssid.SsidLength))
 			|| (ielen == 0 && pmlmeinfo->hidden_ssid_mode)
 		)
 		{
@@ -877,8 +877,8 @@ _continue:
 
 _issue_probersp:
 
-		if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE &&
-			pmlmepriv->cur_network.join_res == _TRUE)
+		if(check_fwstate(pmlmepriv, _FW_LINKED) == true &&
+			pmlmepriv->cur_network.join_res == true)
 		{
 			//DBG_871X("+issue_probersp during ap mode\n");
 			issue_probersp(padapter, get_sa(pframe), is_valid_p2p_probereq);
@@ -905,13 +905,13 @@ unsigned int OnProbeRsp(_adapter *padapt
 #ifdef CONFIG_P2P
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
 	{
-		if ( _TRUE == pwdinfo->tx_prov_disc_info.benable )
+		if ( true == pwdinfo->tx_prov_disc_info.benable )
 		{
 			if( _rtw_memcmp( pwdinfo->tx_prov_disc_info.peerIFAddr, GetAddr2Ptr(pframe), ETH_ALEN ) )
 			{
 				if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
 				{
-					pwdinfo->tx_prov_disc_info.benable = _FALSE;
+					pwdinfo->tx_prov_disc_info.benable = false;
 					issue_p2p_provision_request( padapter,
 												pwdinfo->tx_prov_disc_info.ssid.Ssid,
 												pwdinfo->tx_prov_disc_info.ssid.SsidLength,
@@ -919,7 +919,7 @@ unsigned int OnProbeRsp(_adapter *padapt
 				}
 				else if ( rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) )
 				{
-					pwdinfo->tx_prov_disc_info.benable = _FALSE;
+					pwdinfo->tx_prov_disc_info.benable = false;
 					issue_p2p_provision_request( padapter,
 												NULL,
 												0,
@@ -931,24 +931,24 @@ unsigned int OnProbeRsp(_adapter *padapt
 	}
 	else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
 	{
-		if ( _TRUE == pwdinfo->nego_req_info.benable )
+		if ( true == pwdinfo->nego_req_info.benable )
 		{
 			DBG_871X( "[%s] P2P State is GONEGO ING!\n", __FUNCTION__ );
 			if( _rtw_memcmp( pwdinfo->nego_req_info.peerDevAddr, GetAddr2Ptr(pframe), ETH_ALEN ) )
 			{
-				pwdinfo->nego_req_info.benable = _FALSE;
+				pwdinfo->nego_req_info.benable = false;
 				issue_p2p_GO_request( padapter, pwdinfo->nego_req_info.peerDevAddr);
 			}
 		}
 	}
 	else if( rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ ) )
 	{
-		if ( _TRUE == pwdinfo->invitereq_info.benable )
+		if ( true == pwdinfo->invitereq_info.benable )
 		{
 			DBG_871X( "[%s] P2P_STATE_TX_INVITE_REQ!\n", __FUNCTION__ );
 			if( _rtw_memcmp( pwdinfo->invitereq_info.peer_macaddr, GetAddr2Ptr(pframe), ETH_ALEN ) )
 			{
-				pwdinfo->invitereq_info.benable = _FALSE;
+				pwdinfo->invitereq_info.benable = false;
 				issue_p2p_invitation_request( padapter, pwdinfo->invitereq_info.peer_macaddr );
 			}
 		}
@@ -1045,7 +1045,7 @@ unsigned int OnBeacon(_adapter *padapter
 #endif //CONFIG_DFS
 
 #ifdef CONFIG_P2P_PS
-				//if(psta->ieee8021x_blocked == _FALSE) // do not allow P2P PS during EAPOL handshake ?
+				//if(psta->ieee8021x_blocked == false) // do not allow P2P PS during EAPOL handshake ?
 				process_p2p_ps_ie(padapter, (pframe + WLAN_HDR_A3_LEN), (len - WLAN_HDR_A3_LEN));
 #endif //CONFIG_P2P_PS
 
@@ -1145,7 +1145,7 @@ unsigned int OnAuth(_adapter *padapter,
 		goto auth_fail;
 	}
 
-	if(rtw_access_ctrl(padapter, sa) == _FALSE) {
+	if(rtw_access_ctrl(padapter, sa) == false) {
 		status = _STATS_UNABLE_HANDLE_STA_;
 		goto auth_fail;
 	}
@@ -1166,7 +1166,7 @@ unsigned int OnAuth(_adapter *padapter,
 		pstat->auth_seq = 0;
 	} else {
 		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-		if(rtw_is_list_empty(&pstat->asoc_list)==_FALSE) {
+		if(rtw_is_list_empty(&pstat->asoc_list)==false) {
 			rtw_list_delete(&pstat->asoc_list);
 			pstapriv->asoc_list_cnt--;
 			if (pstat->expire_to > 0)
@@ -1675,7 +1675,7 @@ unsigned int OnAssocReq(_adapter *padapt
 
 				if(!selected_registrar)
 				{
-					DBG_871X("selected_registrar is _FALSE , or AP is not ready to do WPS\n");
+					DBG_871X("selected_registrar is false , or AP is not ready to do WPS\n");
 
 					status = _STATS_UNABLE_HANDLE_STA_;
 
@@ -1723,7 +1723,7 @@ unsigned int OnAssocReq(_adapter *padapt
 	pstat->flags &= ~WLAN_STA_WME;
 	pstat->qos_option = 0;
 	pstat->qos_info = 0;
-	pstat->has_legacy_ac = _TRUE;
+	pstat->has_legacy_ac = true;
 	pstat->uapsd_vo = 0;
 	pstat->uapsd_vi = 0;
 	pstat->uapsd_be = 0;
@@ -1745,9 +1745,9 @@ unsigned int OnAssocReq(_adapter *padapt
 					pstat->max_sp_len = (pstat->qos_info>>5)&0x3;
 
 					if((pstat->qos_info&0xf) !=0xf)
-						pstat->has_legacy_ac = _TRUE;
+						pstat->has_legacy_ac = true;
 					else
-						pstat->has_legacy_ac = _FALSE;
+						pstat->has_legacy_ac = false;
 
 					if(pstat->qos_info&0xf)
 					{
@@ -1799,7 +1799,7 @@ unsigned int OnAssocReq(_adapter *padapt
 		pstat->flags &= ~WLAN_STA_HT;
 
 
-	if((pmlmepriv->htpriv.ht_option == _FALSE) && (pstat->flags&WLAN_STA_HT))
+	if((pmlmepriv->htpriv.ht_option == false) && (pstat->flags&WLAN_STA_HT))
 	{
 		status = _STATS_FAILURE_;
 		goto OnAssocReqFail;
@@ -1839,12 +1839,12 @@ unsigned int OnAssocReq(_adapter *padapt
 		goto OnAssocReqFail;
 
 #ifdef CONFIG_P2P
-	pstat->is_p2p_device = _FALSE;
+	pstat->is_p2p_device = false;
 	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
 		if( (p2pie=rtw_get_p2p_ie(pframe + WLAN_HDR_A3_LEN + ie_offset , pkt_len - WLAN_HDR_A3_LEN - ie_offset , NULL, &p2pielen)))
 		{
-			pstat->is_p2p_device = _TRUE;
+			pstat->is_p2p_device = true;
 			if((p2p_status_code=(u8)process_assoc_req_p2p_ie(pwdinfo, pframe, pkt_len, pstat))>0)
 			{
 				pstat->p2p_status_code = p2p_status_code;
@@ -2146,7 +2146,7 @@ unsigned int OnDeAuth(_adapter *padapter
 	DBG_871X("%s Reason code(%d)\n", __FUNCTION__,reason);
 
 #ifdef CONFIG_AP_MODE
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		_irqL irqL;
 		struct sta_info *psta;
@@ -2164,11 +2164,11 @@ unsigned int OnDeAuth(_adapter *padapter
 			u8 updated;
 
 			_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-			if(rtw_is_list_empty(&psta->asoc_list)==_FALSE)
+			if(rtw_is_list_empty(&psta->asoc_list)==false)
 			{
 				rtw_list_delete(&psta->asoc_list);
 				pstapriv->asoc_list_cnt--;
-				updated = ap_free_sta(padapter, psta, _FALSE, reason);
+				updated = ap_free_sta(padapter, psta, false, reason);
 
 			}
 			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
@@ -2186,7 +2186,7 @@ unsigned int OnDeAuth(_adapter *padapter
 
 		receive_disconnect(padapter, GetAddr3Ptr(pframe) ,reason);
 	}
-	pmlmepriv->LinkDetectInfo.bBusyTraffic = _FALSE;
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
 	return _SUCCESS;
 
 }
@@ -2219,7 +2219,7 @@ unsigned int OnDisassoc(_adapter *padapt
         DBG_871X("%s Reason code(%d)\n", __FUNCTION__,reason);
 
 #ifdef CONFIG_AP_MODE
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		_irqL irqL;
 		struct sta_info *psta;
@@ -2237,11 +2237,11 @@ unsigned int OnDisassoc(_adapter *padapt
 			u8 updated;
 
 			_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-			if(rtw_is_list_empty(&psta->asoc_list)==_FALSE)
+			if(rtw_is_list_empty(&psta->asoc_list)==false)
 			{
 				rtw_list_delete(&psta->asoc_list);
 				pstapriv->asoc_list_cnt--;
-				updated = ap_free_sta(padapter, psta, _FALSE, reason);
+				updated = ap_free_sta(padapter, psta, false, reason);
 
 			}
 			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
@@ -2258,7 +2258,7 @@ unsigned int OnDisassoc(_adapter *padapt
 
 		receive_disconnect(padapter, GetAddr3Ptr(pframe), reason);
 	}
-	pmlmepriv->LinkDetectInfo.bBusyTraffic = _FALSE;
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
 	return _SUCCESS;
 
 }
@@ -2320,7 +2320,7 @@ unsigned int on_action_spct_ch_switch(_a
 		 * 2. things after channel switching
 		 */
 
-		ret = rtw_set_ch_cmd(padapter, ch, bwmode, ch_offset, _TRUE);
+		ret = rtw_set_ch_cmd(padapter, ch, bwmode, ch_offset, true);
 	}
 
 exit:
@@ -2421,8 +2421,8 @@ unsigned int OnAction_back(_adapter *pad
 	{
 #ifdef CONFIG_TDLS
 		if((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
-			(psta->htpriv.ht_option==_TRUE) &&
-			(psta->htpriv.ampdu_enable==_TRUE) )
+			(psta->htpriv.ht_option==true) &&
+			(psta->htpriv.ampdu_enable==true) )
 		{
 			//do nothing; just don't want to return _SUCCESS;
 		}
@@ -2443,7 +2443,7 @@ unsigned int OnAction_back(_adapter *pad
 				//process_addba_req(padapter, (u8*)&(pmlmeinfo->ADDBA_req), GetAddr3Ptr(pframe));
 				process_addba_req(padapter, (u8*)&(pmlmeinfo->ADDBA_req), addr);
 
-				if(pmlmeinfo->bAcceptAddbaReq == _TRUE)
+				if(pmlmeinfo->bAcceptAddbaReq == true)
 				{
 					issue_action_BA(padapter, addr, RTW_WLAN_ACTION_ADDBA_RESP, 0);
 				}
@@ -2488,7 +2488,7 @@ unsigned int OnAction_back(_adapter *pad
 					tid = (frame_body[3] >> 4) & 0x0F;
 
 					preorder_ctrl =  &psta->recvreorder_ctrl[tid];
-					preorder_ctrl->enable = _FALSE;
+					preorder_ctrl->enable = false;
 					preorder_ctrl->indicate_seq = 0xffff;
 					#ifdef DBG_RX_SEQ
 					DBG_871X("DBG_RX_SEQ %s:%d indicate_seq:%u \n", __FUNCTION__, __LINE__,
@@ -4595,7 +4595,7 @@ void issue_probersp_p2p(_adapter *padapt
 #ifdef CONFIG_INTEL_WIDI
 		//	Commented by Kurt
 		//	Appended WiDi info. only if we did issued_probereq_widi(), and then we saved ven. ext. in pmlmepriv->sa_ext.
-		if(  _rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == _FALSE )
+		if(  _rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == false )
 		{
 			//Sec dev type
 			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_SEC_DEV_TYPE_LIST );
@@ -4770,7 +4770,7 @@ void issue_probersp_p2p(_adapter *padapt
 
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
-	if ( _TRUE == pwdinfo->wfd_info->wfd_enable )
+	if ( true == pwdinfo->wfd_info->wfd_enable )
 #endif //CONFIG_IOCTL_CFG80211
 	{
 		wfdielen = build_probe_resp_wfd_ie(pwdinfo, pframe, 0);
@@ -5113,7 +5113,7 @@ int _issue_probereq_p2p(_adapter *padapt
 
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
-	if ( _TRUE == pwdinfo->wfd_info->wfd_enable )
+	if ( true == pwdinfo->wfd_info->wfd_enable )
 #endif
 	{
 		wfdielen = build_probe_req_wfd_ie(pwdinfo, pframe);
@@ -5148,7 +5148,7 @@ exit:
 
 inline void issue_probereq_p2p(_adapter *adapter, u8 *da)
 {
-	_issue_probereq_p2p(adapter, da, _FALSE);
+	_issue_probereq_p2p(adapter, da, false);
 }
 
 int issue_probereq_p2p_ex(_adapter *adapter, u8 *da, int try_cnt, int wait_ms)
@@ -5159,7 +5159,7 @@ int issue_probereq_p2p_ex(_adapter *adap
 
 	do
 	{
-		ret = _issue_probereq_p2p(adapter, da, wait_ms>0?_TRUE:_FALSE);
+		ret = _issue_probereq_p2p(adapter, da, wait_ms>0?true:false);
 
 		i++;
 
@@ -5333,7 +5333,7 @@ unsigned int on_action_public_p2p(union
 					//	Commented by Albert 20110425
 					//	The restore timer is enabled when issuing the nego request frame of rtw_p2p_connect function.
 					_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
-					pwdinfo->nego_req_info.benable = _FALSE;
+					pwdinfo->nego_req_info.benable = false;
 					result = process_p2p_group_negotation_resp( pwdinfo, frame_body, len);
 					issue_p2p_GO_confirm( pwdinfo->padapter, GetAddr2Ptr(pframe), result);
 					if ( P2P_STATUS_SUCCESS == result )
@@ -5549,7 +5549,7 @@ unsigned int on_action_public_p2p(union
 					if ( attr_contentlen == 1 )
 					{
 						DBG_871X( "[%s] Status = %d\n", __FUNCTION__, attr_content );
-						pwdinfo->invitereq_info.benable = _FALSE;
+						pwdinfo->invitereq_info.benable = false;
 
 						if ( attr_content == P2P_STATUS_SUCCESS )
 						{
@@ -5646,7 +5646,7 @@ unsigned int on_action_public_vendor(uni
 	uint frame_len = precv_frame->u.hdr.len;
 	u8 *frame_body = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
 
-	if (_rtw_memcmp(frame_body + 2, P2P_OUI, 4) == _TRUE) {
+	if (_rtw_memcmp(frame_body + 2, P2P_OUI, 4) == true) {
 		ret = on_action_public_p2p(precv_frame);
 	}
 
@@ -5887,24 +5887,24 @@ void update_mgntframe_attrib(_adapter *p
 		pattrib->raid = 5;//a/g mode
 
 	pattrib->encrypt = _NO_PRIVACY_;
-	pattrib->bswenc = _FALSE;
+	pattrib->bswenc = false;
 
-	pattrib->qos_en = _FALSE;
-	pattrib->ht_en = _FALSE;
+	pattrib->qos_en = false;
+	pattrib->ht_en = false;
 	pattrib->bwmode = HT_CHANNEL_WIDTH_20;
 	pattrib->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
-	pattrib->sgi = _FALSE;
+	pattrib->sgi = false;
 
 	pattrib->seqnum = pmlmeext->mgnt_seq;
 
-	pattrib->retry_ctrl = _TRUE;
+	pattrib->retry_ctrl = true;
 
 }
 
 void dump_mgntframe(_adapter *padapter, struct xmit_frame *pmgntframe)
 {
-	if(padapter->bSurpriseRemoved == _TRUE ||
-		padapter->bDriverStopped == _TRUE)
+	if(padapter->bSurpriseRemoved == true ||
+		padapter->bDriverStopped == true)
 		return;
 
 	rtw_hal_mgnt_xmit(padapter, pmgntframe);
@@ -5916,8 +5916,8 @@ s32 dump_mgntframe_and_wait(_adapter *pa
 	struct xmit_buf *pxmitbuf = pmgntframe->pxmitbuf;
 	struct submit_ctx sctx;
 
-	if(padapter->bSurpriseRemoved == _TRUE ||
-		padapter->bDriverStopped == _TRUE)
+	if(padapter->bSurpriseRemoved == true ||
+		padapter->bDriverStopped == true)
 		return ret;
 
 	rtw_sctx_init(&sctx, timeout_ms);
@@ -5942,19 +5942,19 @@ s32 dump_mgntframe_and_wait_ack(_adapter
 		pxmitpriv = &(padapter->pbuddy_adapter->xmitpriv);
 	#endif
 
-	if(padapter->bSurpriseRemoved == _TRUE ||
-		padapter->bDriverStopped == _TRUE)
+	if(padapter->bSurpriseRemoved == true ||
+		padapter->bDriverStopped == true)
 		return -1;
 
 	_enter_critical_mutex(&pxmitpriv->ack_tx_mutex, NULL);
-	pxmitpriv->ack_tx = _TRUE;
+	pxmitpriv->ack_tx = true;
 
 	pmgntframe->ack_report = 1;
 	if (rtw_hal_mgnt_xmit(padapter, pmgntframe) == _SUCCESS) {
 		ret = rtw_ack_tx_wait(pxmitpriv, timeout_ms);
 	}
 
-	pxmitpriv->ack_tx = _FALSE;
+	pxmitpriv->ack_tx = false;
 	_exit_critical_mutex(&pxmitpriv->ack_tx_mutex, NULL);
 
 	 return ret;
@@ -6215,7 +6215,7 @@ void issue_beacon(_adapter *padapter)
 			pattrib->pktlen += len;
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
-			if(_TRUE == pwdinfo->wfd_info->wfd_enable)
+			if(true == pwdinfo->wfd_info->wfd_enable)
 #endif //CONFIG_IOCTL_CFG80211
 			{
 			len = build_beacon_wfd_ie( pwdinfo, pframe );
@@ -6297,7 +6297,7 @@ void issue_beacon(_adapter *padapter)
 _issue_bcn:
 
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
-	pmlmepriv->update_bcn = _FALSE;
+	pmlmepriv->update_bcn = false;
 
 	_exit_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);
 #endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
@@ -6539,7 +6539,7 @@ void issue_probersp(_adapter *padapter,
 
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
-		if(_TRUE == pwdinfo->wfd_info->wfd_enable)
+		if(true == pwdinfo->wfd_info->wfd_enable)
 #endif //CONFIG_IOCTL_CFG80211
 		{
 			len = build_probe_resp_wfd_ie(pwdinfo, pframe, 0);
@@ -6676,7 +6676,7 @@ exit:
 
 inline void issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da)
 {
-	_issue_probereq(padapter, pssid, da, _FALSE);
+	_issue_probereq(padapter, pssid, da, false);
 }
 
 int issue_probereq_ex(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da,
@@ -6688,7 +6688,7 @@ int issue_probereq_ex(_adapter *padapter
 
 	do
 	{
-		ret = _issue_probereq(padapter, pssid, da, wait_ms>0?_TRUE:_FALSE);
+		ret = _issue_probereq(padapter, pssid, da, wait_ms>0?true:false);
 
 		i++;
 
@@ -7017,7 +7017,7 @@ void issue_asocrsp(_adapter *padapter, u
 
 #ifdef CONFIG_P2P
 #ifndef CONFIG_IOCTL_CFG80211
-	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && (pstat->is_p2p_device == _TRUE))
+	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && (pstat->is_p2p_device == true))
 	{
 		u32 len;
 
@@ -7030,7 +7030,7 @@ void issue_asocrsp(_adapter *padapter, u
 #ifdef CONFIG_WFD
 	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)
 #ifdef CONFIG_IOCTL_CFG80211
-		&& (_TRUE == pwdinfo->wfd_info->wfd_enable)
+		&& (true == pwdinfo->wfd_info->wfd_enable)
 #endif //CONFIG_IOCTL_CFG80211
 	)
 	{
@@ -7245,7 +7245,7 @@ void issue_assocreq(_adapter *padapter)
 
 #ifdef CONFIG_80211N_HT
 	//HT caps
-	if(padapter->mlmepriv.htpriv.ht_option==_TRUE)
+	if(padapter->mlmepriv.htpriv.ht_option==true)
 	{
 		p = rtw_get_ie((pmlmeinfo->network.IEs + sizeof(NDIS_802_11_FIXED_IEs)), _HT_CAPABILITY_IE_, &ie_len, (pmlmeinfo->network.IELength - sizeof(NDIS_802_11_FIXED_IEs)));
 		if ((p != NULL) && (!(is_ap_in_tkip(padapter))))
@@ -7527,7 +7527,7 @@ void issue_assocreq(_adapter *padapter)
 
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
-	if ( _TRUE == pwdinfo->wfd_info->wfd_enable )
+	if ( true == pwdinfo->wfd_info->wfd_enable )
 #endif //CONFIG_IOCTL_CFG80211
 	{
 		wfdielen = build_assoc_req_wfd_ie(pwdinfo, pframe);
@@ -7589,7 +7589,7 @@ static int _issue_nulldata(_adapter *pad
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
-	pattrib->retry_ctrl = _FALSE;
+	pattrib->retry_ctrl = false;
 
 	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
 
@@ -7657,7 +7657,7 @@ int issue_nulldata(_adapter *padapter, u
 
 	do
 	{
-		ret = _issue_nulldata(padapter, da, power_mode, wait_ms>0?_TRUE:_FALSE);
+		ret = _issue_nulldata(padapter, da, power_mode, wait_ms>0?true:false);
 
 		i++;
 
@@ -7715,7 +7715,7 @@ static int _issue_qos_nulldata(_adapter
 	update_mgntframe_attrib(padapter, pattrib);
 
 	pattrib->hdrlen +=2;
-	pattrib->qos_en = _TRUE;
+	pattrib->qos_en = true;
 	pattrib->eosp = 1;
 	pattrib->ack_policy = 0;
 	pattrib->mdata = 0;
@@ -7791,7 +7791,7 @@ int issue_qos_nulldata(_adapter *padapte
 
 	do
 	{
-		ret = _issue_qos_nulldata(padapter, da, tid, wait_ms>0?_TRUE:_FALSE);
+		ret = _issue_qos_nulldata(padapter, da, tid, wait_ms>0?true:false);
 
 		i++;
 
@@ -7857,7 +7857,7 @@ static int _issue_deauth(_adapter *padap
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
-	pattrib->retry_ctrl = _FALSE;
+	pattrib->retry_ctrl = false;
 
 	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
 
@@ -7901,7 +7901,7 @@ exit:
 int issue_deauth(_adapter *padapter, unsigned char *da, unsigned short reason)
 {
 	DBG_871X("%s to "MAC_FMT"\n", __func__, MAC_ARG(da));
-	return _issue_deauth(padapter, da, reason, _FALSE);
+	return _issue_deauth(padapter, da, reason, false);
 }
 
 int issue_deauth_ex(_adapter *padapter, u8 *da, unsigned short reason, int try_cnt,
@@ -7913,7 +7913,7 @@ int issue_deauth_ex(_adapter *padapter,
 
 	do
 	{
-		ret = _issue_deauth(padapter, da, reason, wait_ms>0?_TRUE:_FALSE);
+		ret = _issue_deauth(padapter, da, reason, wait_ms>0?true:false);
 
 		i++;
 
@@ -8162,7 +8162,7 @@ static void issue_action_BSSCoexistPacke
 	if((pmlmepriv->num_FortyMHzIntolerant==0) || (pmlmepriv->num_sta_no_ht==0))
 		return;
 
-	if(_TRUE == pmlmeinfo->bwmode_updated)
+	if(true == pmlmeinfo->bwmode_updated)
 		return;
 
 
@@ -8233,7 +8233,7 @@ static void issue_action_BSSCoexistPacke
 			u8 *p;
 			WLAN_BSSID_EX *pbss_network;
 
-			if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+			if (rtw_end_of_queue_search(phead,plist)== true)
 				break;
 
 			pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -8321,11 +8321,11 @@ unsigned int send_delba(_adapter *padapt
 	{
 		for(tid = 0;tid<MAXTID;tid++)
 		{
-			if(psta->recvreorder_ctrl[tid].enable == _TRUE)
+			if(psta->recvreorder_ctrl[tid].enable == true)
 			{
 				DBG_871X("rx agg disable tid(%d)\n",tid);
 				issue_action_BA(padapter, addr, RTW_WLAN_ACTION_DELBA, (((tid <<1) |initiator)&0x1F));
-				psta->recvreorder_ctrl[tid].enable = _FALSE;
+				psta->recvreorder_ctrl[tid].enable = false;
 				psta->recvreorder_ctrl[tid].indicate_seq = 0xffff;
 				#ifdef DBG_RX_SEQ
 				DBG_871X("DBG_RX_SEQ %s:%d indicate_seq:%u \n", __FUNCTION__, __LINE__,
@@ -8356,7 +8356,7 @@ unsigned int send_delba(_adapter *padapt
 
 unsigned int send_beacon(_adapter *padapter)
 {
-	u8	bxmitok = _FALSE;
+	u8	bxmitok = false;
 	int	issue=0;
 	int poll = 0;
 
@@ -8370,13 +8370,13 @@ unsigned int send_beacon(_adapter *padap
 			rtw_yield_os();
 			rtw_hal_get_hwreg(padapter, HW_VAR_BCN_VALID, (u8 *)(&bxmitok));
 			poll++;
-		}while((poll%10)!=0 && _FALSE == bxmitok && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);
+		}while((poll%10)!=0 && false == bxmitok && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);
 
-	}while(_FALSE == bxmitok && issue<100 && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);
+	}while(false == bxmitok && issue<100 && !padapter->bSurpriseRemoved && !padapter->bDriverStopped);
 
 	if(padapter->bSurpriseRemoved || padapter->bDriverStopped)
 		return _FAIL;
-	if(_FALSE == bxmitok) {
+	if(false == bxmitok) {
 		DBG_871X("%s fail! %u ms\n", __FUNCTION__, rtw_get_passing_time_ms(start));
 		return _FAIL;
 	} else {
@@ -8406,8 +8406,8 @@ bool IsLegal5GChannel(
 		161,163,165};
 	for(i=0;i<sizeof(Channel_5G);i++)
 		if(channel == Channel_5G[i])
-			return _TRUE;
-	return _FALSE;
+			return true;
+	return false;
 }
 
 void site_survey(_adapter *padapter)
@@ -8525,7 +8525,7 @@ void site_survey(_adapter *padapter)
 			if(check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&
 				check_buddy_fwstate(padapter, _FW_LINKED))
 			{
-				update_beacon(padapter->pbuddy_adapter, 0, NULL, _TRUE);
+				update_beacon(padapter->pbuddy_adapter, 0, NULL, true);
 			}
 		}
 		else if( stay_buddy_ch == 2 )
@@ -8635,7 +8635,7 @@ void site_survey(_adapter *padapter)
 			rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
 			//turn on dynamic functions
 			Restore_DM_Func_Flag(padapter);
-			//Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, _TRUE);
+			//Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true);
 
 			_set_timer( &pwdinfo->find_phase_timer, ( u32 ) ( ( u32 ) ( pwdinfo->listen_dwell ) * 100 ) );
 		}
@@ -8717,14 +8717,14 @@ void site_survey(_adapter *padapter)
 			rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
 			//turn on dynamic functions
 			Restore_DM_Func_Flag(padapter);
-			//Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, _TRUE);
+			//Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true);
 
-			if (is_client_associated_to_ap(padapter) == _TRUE)
+			if (is_client_associated_to_ap(padapter) == true)
 			{
 				issue_nulldata(padapter, NULL, 0, 3, 500);
 
 #ifdef CONFIG_CONCURRENT_MODE
-				if(is_client_associated_to_ap(padapter->pbuddy_adapter) == _TRUE)
+				if(is_client_associated_to_ap(padapter->pbuddy_adapter) == true)
 				{
 					DBG_871X("adapter is surveydone(buddy_adapter is linked), issue nulldata(pwrbit=0)\n");
 
@@ -8733,7 +8733,7 @@ void site_survey(_adapter *padapter)
 #endif
 			}
 #ifdef CONFIG_CONCURRENT_MODE
-			else if(is_client_associated_to_ap(padapter->pbuddy_adapter) == _TRUE)
+			else if(is_client_associated_to_ap(padapter->pbuddy_adapter) == true)
 			{
 				issue_nulldata(padapter->pbuddy_adapter, NULL, 0, 3, 500);
 			}
@@ -8759,7 +8759,7 @@ void site_survey(_adapter *padapter)
 
 			DBG_871X("restart pbuddy_adapter's beacon\n");
 
-			update_beacon(padapter->pbuddy_adapter, 0, NULL, _TRUE);
+			update_beacon(padapter->pbuddy_adapter, 0, NULL, true);
 		}
 #endif
 
@@ -8919,7 +8919,7 @@ u8 collect_bss_info(_adapter *padapter,
 	bssid->Configuration.ATIMWindow = 0;
 
 	//20/40 BSS Coexistence check
-	if((pregistrypriv->wifi_spec==1) && (_FALSE == pmlmeinfo->bwmode_updated))
+	if((pregistrypriv->wifi_spec==1) && (false == pmlmeinfo->bwmode_updated))
 	{
 		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
@@ -9751,25 +9751,25 @@ void update_sta_info(_adapter *padapter,
 	//HT
 	if(pmlmepriv->htpriv.ht_option)
 	{
-		psta->htpriv.ht_option = _TRUE;
+		psta->htpriv.ht_option = true;
 
 		psta->htpriv.ampdu_enable = pmlmepriv->htpriv.ampdu_enable;
 
 		if (support_short_GI(padapter, &(pmlmeinfo->HT_caps)))
-			psta->htpriv.sgi = _TRUE;
+			psta->htpriv.sgi = true;
 
-		psta->qos_option = _TRUE;
+		psta->qos_option = true;
 
 	}
 	else
 	{
-		psta->htpriv.ht_option = _FALSE;
+		psta->htpriv.ht_option = false;
 
-		psta->htpriv.ampdu_enable = _FALSE;
+		psta->htpriv.ampdu_enable = false;
 
-		psta->htpriv.sgi = _FALSE;
+		psta->htpriv.sgi = false;
 
-		psta->qos_option = _FALSE;
+		psta->qos_option = false;
 
 	}
 
@@ -9782,7 +9782,7 @@ void update_sta_info(_adapter *padapter,
 
 	//QoS
 	if(pmlmepriv->qospriv.qos_option)
-		psta->qos_option = _TRUE;
+		psta->qos_option = true;
 
 
 	psta->state = _FW_LINKED;
@@ -9821,7 +9821,7 @@ void mlmeext_joinbss_event_callback(_ada
 
 
 	//turn on dynamic functions
-	Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, _TRUE);
+	Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true);
 
 	// update IOT-releated issue
 	update_IOT_info(padapter);
@@ -9954,7 +9954,7 @@ void mlmeext_sta_del_event_callback(_ada
 		dc_set_channel_bwmode_disconnect(padapter);
 #else
 #ifdef CONFIG_CONCURRENT_MODE
-		if((check_buddy_fwstate(padapter, _FW_LINKED)) != _TRUE)
+		if((check_buddy_fwstate(padapter, _FW_LINKED)) != true)
 		{
 #endif //CONFIG_CONCURRENT_MODE
 
@@ -10036,7 +10036,7 @@ void _linked_rx_signal_strehgth_display(
 
 u8 chk_ap_is_alive(_adapter *padapter, struct sta_info *psta)
 {
-	u8 ret = _FALSE;
+	u8 ret = false;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
@@ -10066,11 +10066,11 @@ u8 chk_ap_is_alive(_adapter *padapter, s
 		&& sta_rx_probersp_pkts(psta) == sta_last_rx_probersp_pkts(psta)
 	)
 	{
-		ret = _FALSE;
+		ret = false;
 	}
 	else
 	{
-		ret = _TRUE;
+		ret = true;
 	}
 
 	sta_update_last_rx_pkts(psta);
@@ -10116,12 +10116,12 @@ void linked_status_chk(_adapter *padapte
 
 		if ((psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress)) != NULL)
 		{
-			bool is_p2p_enable = _FALSE;
+			bool is_p2p_enable = false;
 			#ifdef CONFIG_P2P
 			is_p2p_enable = !rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE);
 			#endif
 
-			if (chk_ap_is_alive(padapter, psta) == _FALSE)
+			if (chk_ap_is_alive(padapter, psta) == false)
 				rx_chk = _FAIL;
 
 			if (pxmitpriv->last_tx_pkts == pxmitpriv->tx_pkts)
@@ -10259,7 +10259,7 @@ void survey_timer_hdl(_adapter *padapter
 				pmlmeext->sitesurvey_res.channel_idx++;
 		}
 
-		if(pmlmeext->scan_abort == _TRUE)
+		if(pmlmeext->scan_abort == true)
 		{
 			#ifdef CONFIG_P2P
 			if(!rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE))
@@ -10280,7 +10280,7 @@ void survey_timer_hdl(_adapter *padapter
 				);
 			}
 
-			pmlmeext->scan_abort = _FALSE;//reset
+			pmlmeext->scan_abort = false;//reset
 		}
 
 		if ((ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
@@ -10351,7 +10351,7 @@ void addba_timer_hdl(struct sta_info *ps
 
 	phtpriv = &psta->htpriv;
 
-	if((phtpriv->ht_option==_TRUE) && (phtpriv->ampdu_enable==_TRUE))
+	if((phtpriv->ht_option==true) && (phtpriv->ampdu_enable==true))
 	{
 		if(phtpriv->candidate_tid_bitmap)
 			phtpriv->candidate_tid_bitmap=0x0;
@@ -10439,7 +10439,7 @@ u8 createbss_hdl(_adapter *padapter, u8
 
 		//disable dynamic functions, such as high power, DIG
 		Save_DM_Func_Flag(padapter);
-		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
+		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, false);
 
 		//config the initial gain under linking, need to write the BB registers
 		initialgain = 0x1E;
@@ -10506,7 +10506,7 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *
 	}
 
 #ifdef CONFIG_ANTENNA_DIVERSITY
-	rtw_antenna_select_cmd(padapter, pparm->network.PhyInfo.Optimum_antenna, _FALSE);
+	rtw_antenna_select_cmd(padapter, pparm->network.PhyInfo.Optimum_antenna, false);
 #endif
 
 	rtw_joinbss_reset(padapter);
@@ -10520,7 +10520,7 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *
 	pmlmeinfo->HT_info_enable = 0;
 	pmlmeinfo->agg_enable_bitmap = 0;
 	pmlmeinfo->candidate_tid_bitmap = 0;
-	pmlmeinfo->bwmode_updated = _FALSE;
+	pmlmeinfo->bwmode_updated = false;
 	//pmlmeinfo->assoc_AP_vendor = maxAP;
 
 	_rtw_memcpy(pnetwork, pbuf, FIELD_OFFSET(WLAN_BSSID_EX, IELength));
@@ -10662,7 +10662,7 @@ u8 disconnect_hdl(_adapter *padapter, un
 	dc_set_channel_bwmode_disconnect(padapter);
 #else
 #ifdef CONFIG_CONCURRENT_MODE
-	if((check_buddy_fwstate(padapter, _FW_LINKED)) != _TRUE)
+	if((check_buddy_fwstate(padapter, _FW_LINKED)) != true)
 	{
 #endif //CONFIG_CONCURRENT_MODE
 		//switch to the 20M Hz mode after disconnect
@@ -10752,7 +10752,7 @@ u8 sitesurvey_cmd_hdl(_adapter *padapter
 {
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct sitesurvey_parm	*pparm = (struct sitesurvey_parm *)pbuf;
-	u8	bdelayscan = _FALSE;
+	u8	bdelayscan = false;
 	u8	val8;
 	u32	initialgain;
 	u32	i;
@@ -10791,24 +10791,24 @@ u8 sitesurvey_cmd_hdl(_adapter *padapter
 #endif
 
 		//issue null data if associating to the AP
-		if (is_client_associated_to_ap(padapter) == _TRUE)
+		if (is_client_associated_to_ap(padapter) == true)
 		{
 			pmlmeext->sitesurvey_res.state = SCAN_TXNULL;
 
 			issue_nulldata(padapter, NULL, 1, 3, 500);
 
 #ifdef CONFIG_CONCURRENT_MODE
-			if(is_client_associated_to_ap(padapter->pbuddy_adapter) == _TRUE)
+			if(is_client_associated_to_ap(padapter->pbuddy_adapter) == true)
 			{
 				DBG_871X("adapter is scanning(buddy_adapter is linked), issue nulldata(pwrbit=1)\n");
 
 				issue_nulldata(padapter->pbuddy_adapter, NULL, 1, 3, 500);
 			}
 #endif
-			bdelayscan = _TRUE;
+			bdelayscan = true;
 		}
 #ifdef CONFIG_CONCURRENT_MODE
-		else if(is_client_associated_to_ap(padapter->pbuddy_adapter) == _TRUE)
+		else if(is_client_associated_to_ap(padapter->pbuddy_adapter) == true)
 		{
 			#ifdef CONFIG_TDLS
 			if(padapter->pbuddy_adapter->wdinfo.wfd_tdls_enable == 1)
@@ -10821,7 +10821,7 @@ u8 sitesurvey_cmd_hdl(_adapter *padapter
 
 			issue_nulldata(padapter->pbuddy_adapter, NULL, 1, 3, 500);
 
-			bdelayscan = _TRUE;
+			bdelayscan = true;
 		}
 #endif
 		if(bdelayscan)
@@ -10839,11 +10839,11 @@ u8 sitesurvey_cmd_hdl(_adapter *padapter
 
 		//disable dynamic functions, such as high power, DIG
 		Save_DM_Func_Flag(padapter);
-		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
+		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, false);
 
 		//config the initial gain under scaning, need to write the BB registers
 #ifdef CONFIG_IOCTL_CFG80211
-		if((wdev_to_priv(padapter->rtw_wdev))->p2p_enabled == _TRUE)
+		if((wdev_to_priv(padapter->rtw_wdev))->p2p_enabled == true)
 			initialgain = 0x27;
 		else
 			initialgain = 0x17;
@@ -11069,8 +11069,8 @@ u8 add_ba_hdl(_adapter *padapter, unsign
 	}
 #ifdef CONFIG_TDLS
 	else if((psta->tdls_sta_state & TDLS_LINKED_STATE)&&
-		(psta->htpriv.ht_option==_TRUE) &&
-		(psta->htpriv.ampdu_enable==_TRUE) )
+		(psta->htpriv.ht_option==true) &&
+		(psta->htpriv.ampdu_enable==true) )
 	{
 		issue_action_BA(padapter, pparm->addr, RTW_WLAN_ACTION_ADDBA_REQ, (u16)pparm->tid);
 		//_set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO);
@@ -11232,7 +11232,7 @@ u8 tx_beacon_hdl(_adapter *padapter, uns
 			xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
 			xmitframe_plist = get_next(xmitframe_phead);
 
-			while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
+			while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
 			{
 				pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
@@ -11251,7 +11251,7 @@ u8 tx_beacon_hdl(_adapter *padapter, uns
 				pxmitframe->attrib.qsel = 0x11;//HIQ
 
 				_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
-				if(rtw_hal_xmit(padapter, pxmitframe) == _TRUE)
+				if(rtw_hal_xmit(padapter, pxmitframe) == true)
 				{
 					rtw_os_xmit_complete(padapter, pxmitframe);
 				}
@@ -11331,7 +11331,7 @@ void dc_SelectChannel(_adapter *padapter
 	PADAPTER ptarget_adapter;
 
 	if( (padapter->pbuddy_adapter != NULL) &&
-		(padapter->DualMacConcurrent == _TRUE) &&
+		(padapter->DualMacConcurrent == true) &&
 		(padapter->adapter_type == SECONDARY_ADAPTER))
 	{
 		// only mac0 could control BB&RF
@@ -11354,7 +11354,7 @@ void dc_SetBWMode(_adapter *padapter, un
 	PADAPTER ptarget_adapter;
 
 	if( (padapter->pbuddy_adapter != NULL) &&
-		(padapter->DualMacConcurrent == _TRUE) &&
+		(padapter->DualMacConcurrent == true) &&
 		(padapter->adapter_type == SECONDARY_ADAPTER))
 	{
 		// only mac0 could control BB&RF
@@ -11379,10 +11379,10 @@ void dc_set_channel_bwmode_disconnect(_a
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
 
 	if(pbuddy_adapter != NULL &&
-		padapter->DualMacConcurrent == _TRUE)
+		padapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
-		if((check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) != _TRUE)
+		if((check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) != true)
 		{
 			//switch to the 20M Hz mode after disconnect
 			pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
@@ -11412,7 +11412,7 @@ u8 dc_handle_join_request(_adapter *pada
 	u8	ret = _SUCCESS;
 
 	if(pbuddy_adapter != NULL &&
-		padapter->DualMacConcurrent == _TRUE)
+		padapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
@@ -11421,7 +11421,7 @@ u8 dc_handle_join_request(_adapter *pada
 			pmlmeext->cur_bwmode != pbuddy_mlmeext->cur_bwmode ||
 			pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset)
 		{
-			if((check_fwstate(pbuddy_mlmepriv, WIFI_AP_STATE)) == _TRUE)
+			if((check_fwstate(pbuddy_mlmepriv, WIFI_AP_STATE)) == true)
 			{
 				//issue deauth to all stas if if2 is at ap mode
 				rtw_sta_flush(pbuddy_adapter);
@@ -11429,7 +11429,7 @@ u8 dc_handle_join_request(_adapter *pada
 				//rtw_hal_set_hwreg(padapter, HW_VAR_CHECK_TXBUF, 0);
 				rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_CHECK_TXBUF, 0);
 			}
-			else if(check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == _TRUE)
+			else if(check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == true)
 			{
 				if(pmlmeext->cur_channel == pbuddy_mlmeext->cur_channel)
 				{
@@ -11448,7 +11448,7 @@ u8 dc_handle_join_request(_adapter *pada
 				}
 			}
 		}
-		else	 if (is_client_associated_to_ap(pbuddy_adapter) == _TRUE)
+		else	 if (is_client_associated_to_ap(pbuddy_adapter) == true)
 		{
 			issue_nulldata(pbuddy_adapter, NULL, 1, 0, 0);
 		}
@@ -11466,11 +11466,11 @@ void dc_handle_join_done(_adapter *padap
 	struct mlme_ext_priv *pbuddy_mlmeext = NULL;
 	struct mlme_ext_info *pbuddy_mlmeinfo = NULL;
 	WLAN_BSSID_EX *pbuddy_network_mlmeext = NULL;
-	u8	change_band = _FALSE;
+	u8	change_band = false;
 
 
 	if(pbuddy_adapter != NULL &&
-		padapter->DualMacConcurrent == _TRUE)
+		padapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -11492,7 +11492,7 @@ void dc_handle_join_done(_adapter *padap
 				if((pbuddy_mlmeext->cur_channel <= 14 && pmlmeext->cur_channel >= 36) ||
 					(pbuddy_mlmeext->cur_channel >= 36 && pmlmeext->cur_channel <= 14))
 				{
-					change_band = _TRUE;
+					change_band = true;
 				}
 
 				//sync channel/bwmode/ch_offset with another adapter
@@ -11579,14 +11579,14 @@ void dc_handle_join_done(_adapter *padap
 
 			DBG_871X("after join, another adapter, CH=%d, BW=%d, offset=%d\n", pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_bwmode, pbuddy_mlmeext->cur_ch_offset);
 
-			if(change_band == _TRUE)
+			if(change_band == true)
 				change_band_update_ie(pbuddy_adapter, pbuddy_network_mlmeext);
 
 			DBG_871X("update pbuddy_adapter's beacon\n");
 
-			update_beacon(pbuddy_adapter, 0, NULL, _TRUE);
+			update_beacon(pbuddy_adapter, 0, NULL, true);
 		}
-		else	 if (is_client_associated_to_ap(pbuddy_adapter) == _TRUE)
+		else	 if (is_client_associated_to_ap(pbuddy_adapter) == true)
 		{
 			if((pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
 				(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_20))
@@ -11605,7 +11605,7 @@ sint	dc_check_fwstate(_adapter *padapter
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
 
 	if(padapter->pbuddy_adapter != NULL &&
-		padapter->DualMacConcurrent == _TRUE)
+		padapter->DualMacConcurrent == true)
 
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
@@ -11613,7 +11613,7 @@ sint	dc_check_fwstate(_adapter *padapter
 		return check_fwstate(pbuddy_mlmepriv, fw_state);
 	}
 
-	return _FALSE;
+	return false;
 }
 
 u8 dc_handle_site_survey(_adapter *padapter)
@@ -11624,25 +11624,25 @@ u8 dc_handle_site_survey(_adapter *padap
 
 	// only mac0 can do scan request, help issue nulldata(1) for mac1
 	if(pbuddy_adapter != NULL &&
-		padapter->DualMacConcurrent == _TRUE)
+		padapter->DualMacConcurrent == true)
 	{
-		if (is_client_associated_to_ap(pbuddy_adapter) == _TRUE)
+		if (is_client_associated_to_ap(pbuddy_adapter) == true)
 		{
 			pmlmeext->sitesurvey_res.state = SCAN_TXNULL;
 
 			issue_nulldata(pbuddy_adapter, NULL, 1, 2, 0);
 
-			return _TRUE;
+			return true;
 		}
 	}
 
-	return _FALSE;
+	return false;
 }
 
 void	dc_report_survey_event(_adapter *padapter, union recv_frame *precv_frame)
 {
 	if(padapter->pbuddy_adapter != NULL &&
-		padapter->DualMacConcurrent == _TRUE)
+		padapter->DualMacConcurrent == true)
 	{
 		report_survey_event(padapter->pbuddy_adapter, precv_frame);
 	}
@@ -11661,7 +11661,7 @@ void dc_set_channel_bwmode_survey_done(_
 	u8 cur_ch_offset;
 
 	if(pbuddy_adapter != NULL &&
-		padapter->DualMacConcurrent == _TRUE)
+		padapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -11692,7 +11692,7 @@ void dc_set_channel_bwmode_survey_done(_
 
 		set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
 
-		if (is_client_associated_to_ap(pbuddy_adapter) == _TRUE)
+		if (is_client_associated_to_ap(pbuddy_adapter) == true)
 		{
 			//issue null data
 			issue_nulldata(pbuddy_adapter, NULL, 0, 0, 0);
@@ -11706,7 +11706,7 @@ void dc_set_channel_bwmode_survey_done(_
 
 			DBG_871X("restart pbuddy_adapter's beacon\n");
 
-			update_beacon(pbuddy_adapter, 0, NULL, _TRUE);
+			update_beacon(pbuddy_adapter, 0, NULL, true);
 		}
 	}
 	else
@@ -11735,7 +11735,7 @@ void dc_set_ap_channel_bandwidth(_adapte
 	cur_channel = channel;
 	cur_bwmode = bwmode;
 	cur_ch_offset = channel_offset;
-	change_band = _FALSE;
+	change_band = false;
 
 	p = rtw_get_ie((pnetwork->IEs + sizeof(NDIS_802_11_FIXED_IEs)), _HT_ADD_INFO_IE_, &ie_len, (pnetwork->IELength - sizeof(NDIS_802_11_FIXED_IEs)));
 	if( p && ie_len)
@@ -11744,7 +11744,7 @@ void dc_set_ap_channel_bandwidth(_adapte
 	}
 
 	if(pbuddy_adapter != NULL &&
-		padapter->DualMacConcurrent == _TRUE)
+		padapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -11753,7 +11753,7 @@ void dc_set_ap_channel_bandwidth(_adapte
 		{
 			set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
 		}
-		else if(check_fwstate(pbuddy_mlmepriv, _FW_LINKED)==_TRUE)
+		else if(check_fwstate(pbuddy_mlmepriv, _FW_LINKED)==true)
 		{
 			//To sync cur_channel/cur_bwmode/cur_ch_offset with another adapter
 			DBG_871X("Another iface is at linked state, sync cur_channel/cur_bwmode/cur_ch_offset\n");
@@ -11834,14 +11834,14 @@ void dc_set_ap_channel_bandwidth(_adapte
 	if((channel <= 14 && cur_channel >= 36) ||
 		(channel >= 36 && cur_channel <= 14))
 	{
-		change_band = _TRUE;
+		change_band = true;
 	}
 
 	pmlmeext->cur_channel = cur_channel;
 	pmlmeext->cur_bwmode = cur_bwmode;
 	pmlmeext->cur_ch_offset = cur_ch_offset;
 
-	if(change_band == _TRUE)
+	if(change_band == true)
 		change_band_update_ie(padapter, pnetwork);
 
 	DBG_871X("dualmac_concurrent_ap_set_channel_bwmode <==\n");
@@ -11852,7 +11852,7 @@ void dc_resume_xmit(_adapter *padapter)
 	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
 
 	if(pbuddy_adapter != NULL &&
-		padapter->DualMacConcurrent == _TRUE)
+		padapter->DualMacConcurrent == true)
 	{
 		DBG_871X("dc_resume_xmit,  resume pbuddy_adapter Tx\n");
 		rtw_os_xmit_schedule(pbuddy_adapter);
@@ -11865,17 +11865,17 @@ u8	dc_check_xmit(_adapter *padapter)
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
 
 	if(pbuddy_adapter != NULL &&
-		padapter->DualMacConcurrent == _TRUE)
+		padapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
-		if (check_fwstate(pbuddy_mlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+		if (check_fwstate(pbuddy_mlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
 		{
 			DBG_871X("dc_check_xmit  pbuddy_adapter is under survey or under linking\n");
-			return _FALSE;
+			return false;
 		}
 	}
 
-	return _TRUE;
+	return true;
 }
 #endif
 
@@ -11887,21 +11887,21 @@ sint check_buddy_mlmeinfo_state(_adapter
 	struct mlme_ext_info *pbuddy_mlmeinfo;
 
 	if(padapter == NULL)
-		return _FALSE;
+		return false;
 
 	pbuddy_adapter = padapter->pbuddy_adapter;
 
 	if(pbuddy_adapter == NULL)
-		return _FALSE;
+		return false;
 
 
 	pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 	pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
 
 	if((pbuddy_mlmeinfo->state&0x03) == state)
-		return _TRUE;
+		return true;
 
-	return _FALSE;
+	return false;
 
 }
 
@@ -11928,16 +11928,16 @@ int concurrent_chk_start_clnt_join(_adap
 
 	if((pbuddy_pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)//for AP MODE
 	{
-		bool inform_ch_switch = _FALSE;
+		bool inform_ch_switch = false;
 		if(pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel)
 		{
-			inform_ch_switch = _TRUE;
+			inform_ch_switch = true;
 		}
 		else if((pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
 			(pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
 			(pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset))
 		{
-			inform_ch_switch = _TRUE;
+			inform_ch_switch = true;
 		}
 
 		if (inform_ch_switch) {
@@ -11953,8 +11953,8 @@ int concurrent_chk_start_clnt_join(_adap
 			rtw_hal_set_hwreg(padapter, HW_VAR_CHECK_TXBUF, 0);
 		}
 	}
-	else if(check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == _TRUE &&
-		check_fwstate(pbuddy_mlmepriv, WIFI_STATION_STATE) == _TRUE) //for Client Mode/p2p client
+	else if(check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == true &&
+		check_fwstate(pbuddy_mlmepriv, WIFI_STATION_STATE) == true) //for Client Mode/p2p client
 	{
 #if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
 		struct wifidirect_info *pbuddy_wdinfo = &(pbuddy_adapter->wdinfo);
@@ -12021,16 +12021,15 @@ void concurrent_chk_joinbss_done(_adapte
 			, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
 
 
-		if(join_res >= 0)
-		{
+		if(join_res >= 0) {
 			u8 *p;
 			int	ie_len;
-			u8	change_band = _FALSE;
+			u8	change_band = false;
 			struct HT_info_element *pht_info=NULL;
 
 			if((pmlmeext->cur_channel <= 14 && pbuddy_mlmeext->cur_channel >= 36) ||
 				(pmlmeext->cur_channel >= 36 && pbuddy_mlmeext->cur_channel <= 14))
-				change_band = _TRUE;
+				change_band = true;
 
 			//sync channel/bwmode/ch_offset with primary adapter
 			pbuddy_mlmeext->cur_channel = pmlmeext->cur_channel;
@@ -12156,7 +12155,7 @@ void concurrent_chk_joinbss_done(_adapte
 			}
 
 			//buddy interface band is different from current interface, update ERP, support rate, ext support rate IE
-			if(change_band == _TRUE)
+			if(change_band == true)
 				change_band_update_ie(pbuddy_adapter, pbuddy_network_mlmeext);
 		}
 		else
@@ -12169,7 +12168,7 @@ void concurrent_chk_joinbss_done(_adapte
 
 		DBG_871X("update pbuddy_adapter's beacon\n");
 
-		update_beacon(pbuddy_adapter, 0, NULL, _TRUE);
+		update_beacon(pbuddy_adapter, 0, NULL, true);
 
 	}
 	else if(((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) &&
@@ -12278,7 +12277,7 @@ u8 set_csa_hdl(_adapter *padapter, unsig
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_TXPAUSE, &gval8);
 
-	rtw_free_network_queue(padapter, _TRUE);
+	rtw_free_network_queue(padapter, true);
 	rtw_indicate_disconnect(padapter);
 
 	if ( ((new_ch_no >= 52) && (new_ch_no <= 64)) ||((new_ch_no >= 100) && (new_ch_no <= 140)) ) {
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -44,7 +44,7 @@ int	is_any_client_associated( _adapter *
 {
 	_irqL irqL;
 	_list	*phead, *plist;
-	int	intFound = _FALSE;
+	int	intFound = false;
 
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
@@ -52,17 +52,17 @@ int	is_any_client_associated( _adapter *
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
-	if ( rtw_end_of_queue_search(phead, plist) == _TRUE )
+	if ( rtw_end_of_queue_search(phead, plist) == true )
 	{
-		intFound = _FALSE;
+		intFound = false;
 	}
 	else
 	{
-		intFound = _TRUE;
+		intFound = true;
 	}
 
-	if ((intFound == _FALSE && pstapriv->asoc_list_cnt)
-		|| (intFound == _TRUE && !pstapriv->asoc_list_cnt)) {
+	if ((intFound == false && pstapriv->asoc_list_cnt)
+		|| (intFound == true && !pstapriv->asoc_list_cnt)) {
 		DBG_871X("%s intFound:%d, asoc_list_cnt:%u mismatch\n", __func__
 			, intFound, pstapriv->asoc_list_cnt);
 	}
@@ -96,7 +96,7 @@ static u32 go_add_group_info_attr(struct
 	plist = get_next(phead);
 
 	//look up sta asoc_queue
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 
@@ -624,7 +624,7 @@ u32 build_beacon_wfd_ie(struct wifidirec
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -737,7 +737,7 @@ u32 build_probe_req_wfd_ie(struct wifidi
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -811,7 +811,7 @@ u32 build_probe_resp_wfd_ie(struct wifid
 	//	WFD device information
 	//	WFD primary sink + available for WFD session + WiFi Direct mode
 
-	if (  _TRUE == pwdinfo->session_available )
+	if (  true == pwdinfo->session_available )
 	{
 		if ( P2P_ROLE_GO == pwdinfo->role )
 		{
@@ -895,7 +895,7 @@ u32 build_probe_resp_wfd_ie(struct wifid
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -1039,7 +1039,7 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -1137,7 +1137,7 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -1235,7 +1235,7 @@ u32 build_nego_req_wfd_ie(struct wifidir
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -1333,7 +1333,7 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -1432,7 +1432,7 @@ u32 build_nego_confirm_wfd_ie(struct wif
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -1531,7 +1531,7 @@ u32 build_invitation_req_wfd_ie(struct w
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -1644,7 +1644,7 @@ u32 build_invitation_resp_wfd_ie(struct
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -1757,7 +1757,7 @@ u32 build_provdisc_req_wfd_ie(struct wif
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -1856,7 +1856,7 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -1991,7 +1991,7 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
 	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
 #ifdef CONFIG_INTEL_WIDI
-	if( _rtw_memcmp( pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN ) == _FALSE )
+	if( _rtw_memcmp( pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN ) == false )
 	{
 		RTW_PUT_LE16(p2pie + p2pielen, 21 + 8 + pwdinfo->device_name_len);
 	}
@@ -2029,7 +2029,7 @@ u32 build_probe_resp_p2p_ie(struct wifid
 
 	//	Number of Secondary Device Types
 #ifdef CONFIG_INTEL_WIDI
-	if( _rtw_memcmp( pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN ) == _FALSE )
+	if( _rtw_memcmp( pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN ) == false )
 	{
 		p2pie[ p2pielen++ ] = 0x01;
 
@@ -2255,7 +2255,7 @@ u32 build_deauth_p2p_ie(struct wifidirec
 u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
 {
 	u8 *p;
-	u32 ret=_FALSE;
+	u32 ret=false;
 	u8 *p2pie;
 	u32	p2pielen = 0;
 	int ssid_len=0, rate_cnt = 0;
@@ -2314,11 +2314,11 @@ u32 process_probe_req_p2p_ie(struct wifi
 				//Check Requested Device Type attributes in WSC IE.
 				//Check Device ID attribute in P2P IE
 
-				ret = _TRUE;
+				ret = true;
 			}
 			else if ( (p != NULL) && ( ssid_len == 0 ) )
 			{
-				ret = _TRUE;
+				ret = true;
 			}
 		}
 		else
@@ -2496,7 +2496,7 @@ u32 process_p2p_devdisc_req(struct wifid
 					plist = get_next(phead);
 
 					//look up sta asoc_queue
-					while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+					while ((rtw_end_of_queue_search(phead, plist)) == false)
 					{
 						psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 
@@ -2544,13 +2544,13 @@ u32 process_p2p_devdisc_req(struct wifid
 	issue_p2p_devdisc_resp(pwdinfo, GetAddr2Ptr(pframe), status, dialogToken);
 
 
-	return (status==P2P_STATUS_SUCCESS) ? _TRUE:_FALSE;
+	return (status==P2P_STATUS_SUCCESS) ? true:false;
 
 }
 
 u32 process_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
 {
-	return _TRUE;
+	return true;
 }
 
 u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,  u8 *pframe, uint len )
@@ -2595,14 +2595,14 @@ u8 process_p2p_provdisc_req(struct wifid
 		}
 	}
 	DBG_871X( "[%s] config method = %s\n", __FUNCTION__, pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req );
-	return _TRUE;
+	return true;
 
 }
 
 u8 process_p2p_provdisc_resp(struct wifidirect_info *pwdinfo,  u8 *pframe)
 {
 
-	return _TRUE;
+	return true;
 }
 
 u8 rtw_p2p_get_peer_ch_list(struct wifidirect_info *pwdinfo, u8 *ch_content, u8 ch_cnt, u8 *peer_ch_list)
@@ -2763,7 +2763,7 @@ u8 process_p2p_group_negotation_req( str
 
 #if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 			if(!(cap_attr & P2P_GRPCAP_INTRABSS) )
-				ptdlsinfo->ap_prohibited = _TRUE;
+				ptdlsinfo->ap_prohibited = true;
 #endif //defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 		}
 
@@ -2965,7 +2965,7 @@ u8 process_p2p_group_negotation_resp( st
 				cap_attr = le16_to_cpu(cap_attr);
 #if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 			if(!(cap_attr & P2P_GRPCAP_INTRABSS) )
-				ptdlsinfo->ap_prohibited = _TRUE;
+				ptdlsinfo->ap_prohibited = true;
 #endif //defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 			}
 
@@ -3275,7 +3275,7 @@ u8 process_p2p_presence_req(struct wifid
 
 	issue_p2p_presence_resp(pwdinfo, GetAddr2Ptr(pframe), status, dialogToken);
 
-	return _TRUE;
+	return true;
 }
 
 void find_phase_handler( _adapter*	padapter )
@@ -3440,7 +3440,7 @@ _func_enter_;
 		}
 		else if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN) ||
 				rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL) ||
-				( rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == _FALSE ) ||
+				( rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == false ) ||
 				rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ) )
 		{
 			//	Now, the driver is in the listen state of P2P mode.
@@ -3478,7 +3478,7 @@ _func_enter_;
 			issue_probereq_p2p(padapter, NULL);
 			_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
 		}
-		else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == _TRUE)
+		else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == true)
 		{
 			val8 = 1;
 			set_channel_bwmode(padapter, pwdinfo->nego_req_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
@@ -3486,7 +3486,7 @@ _func_enter_;
 			issue_probereq_p2p(padapter, NULL);
 			_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
 		}
-		else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ ) && pwdinfo->invitereq_info.benable == _TRUE)
+		else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ ) && pwdinfo->invitereq_info.benable == true)
 		{
 			/*
 			val8 = 1;
@@ -3546,7 +3546,7 @@ _func_enter_;
 #endif
 	}
 
-	pcfg80211_wdinfo->is_ro_ch = _FALSE;
+	pcfg80211_wdinfo->is_ro_ch = false;
 
 	DBG_871X("cfg80211_remain_on_channel_expired\n");
 
@@ -3642,7 +3642,7 @@ void rtw_append_wfd_ie(_adapter *padapte
 	{
 		action = frame_body[1];
 		if (action == ACT_PUBLIC_VENDOR
-			&& _rtw_memcmp(frame_body+2, P2P_OUI, 4) == _TRUE
+			&& _rtw_memcmp(frame_body+2, P2P_OUI, 4) == true
 		)
 		{
 			OUI_Subtype = frame_body[6];
@@ -3760,7 +3760,7 @@ int rtw_p2p_check_frames(_adapter *padap
 	{
 		action = frame_body[1];
 		if (action == ACT_PUBLIC_VENDOR
-			&& _rtw_memcmp(frame_body+2, P2P_OUI, 4) == _TRUE
+			&& _rtw_memcmp(frame_body+2, P2P_OUI, 4) == true
 		)
 		{
 			OUI_Subtype = frame_body[6];
@@ -3781,15 +3781,15 @@ int rtw_p2p_check_frames(_adapter *padap
 				u8 *cont;
 				uint cont_len;
 				case P2P_GO_NEGO_REQ:
-					DBG_871X("RTW_%s:P2P_GO_NEGO_REQ, dialogToken=%d\n", (tx==_TRUE)?"Tx":"Rx", dialogToken);
+					DBG_871X("RTW_%s:P2P_GO_NEGO_REQ, dialogToken=%d\n", (tx==true)?"Tx":"Rx", dialogToken);
 
 					if(tx)
 					{
 #ifdef CONFIG_DRV_ISSUE_PROV_REQ // IOT FOR S2
-						if(pwdev_priv->provdisc_req_issued == _FALSE)
+						if(pwdev_priv->provdisc_req_issued == false)
 						{
 							rtw_cfg80211_issue_p2p_provision_request(padapter, buf, len);
-							pwdev_priv->provdisc_req_issued = _TRUE;
+							pwdev_priv->provdisc_req_issued = true;
 							rtw_msleep_os(200);
 						}
 #endif //CONFIG_DRV_ISSUE_PROV_REQ
@@ -3803,11 +3803,11 @@ int rtw_p2p_check_frames(_adapter *padap
 					break;
 				case P2P_GO_NEGO_RESP:
 					cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
-					DBG_871X("RTW_%s:P2P_GO_NEGO_RESP, dialogToken=%d, status:%d\n", (tx==_TRUE)?"Tx":"Rx", dialogToken, cont?*cont:-1);
+					DBG_871X("RTW_%s:P2P_GO_NEGO_RESP, dialogToken=%d, status:%d\n", (tx==true)?"Tx":"Rx", dialogToken, cont?*cont:-1);
 
 					if(!tx)
 					{
-						pwdev_priv->provdisc_req_issued = _FALSE;
+						pwdev_priv->provdisc_req_issued = false;
 					}
 #ifdef CONFIG_CONCURRENT_MODE
 					else
@@ -3819,7 +3819,7 @@ int rtw_p2p_check_frames(_adapter *padap
 					break;
 				case P2P_GO_NEGO_CONF:
 					cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
-					DBG_871X("RTW_%s:P2P_GO_NEGO_CONF, dialogToken=%d, status:%d\n", (tx==_TRUE)?"Tx":"Rx", dialogToken, cont?*cont:-1);
+					DBG_871X("RTW_%s:P2P_GO_NEGO_CONF, dialogToken=%d, status:%d\n", (tx==true)?"Tx":"Rx", dialogToken, cont?*cont:-1);
 #ifdef CONFIG_CONCURRENT_MODE
 					if(tx)
 					{
@@ -3854,7 +3854,7 @@ int rtw_p2p_check_frames(_adapter *padap
 					invit_info->flags = (flags==-1) ? 0x0 : flags;
 					invit_info->req_op_ch= op_ch;
 
-					DBG_871X("RTW_%s:P2P_INVIT_REQ, dialogToken=%d, flags:0x%02x, op_ch:%d\n", (tx==_TRUE)?"Tx":"Rx", dialogToken, flags, op_ch);
+					DBG_871X("RTW_%s:P2P_INVIT_REQ, dialogToken=%d, flags:0x%02x, op_ch:%d\n", (tx==true)?"Tx":"Rx", dialogToken, flags, op_ch);
 					break;
 				}
 				case P2P_INVIT_RESP:
@@ -3884,15 +3884,15 @@ int rtw_p2p_check_frames(_adapter *padap
 						invit_info->rsp_op_ch= op_ch;
 					}
 
-					DBG_871X("RTW_%s:P2P_INVIT_RESP, dialogToken=%d, status:%d, op_ch:%d\n", (tx==_TRUE)?"Tx":"Rx", dialogToken, status, op_ch);
+					DBG_871X("RTW_%s:P2P_INVIT_RESP, dialogToken=%d, status:%d, op_ch:%d\n", (tx==true)?"Tx":"Rx", dialogToken, status, op_ch);
 					break;
 				}
 				case P2P_DEVDISC_REQ:
-					DBG_871X("RTW_%s:P2P_DEVDISC_REQ, dialogToken=%d\n", (tx==_TRUE)?"Tx":"Rx", dialogToken);
+					DBG_871X("RTW_%s:P2P_DEVDISC_REQ, dialogToken=%d\n", (tx==true)?"Tx":"Rx", dialogToken);
 					break;
 				case P2P_DEVDISC_RESP:
 					cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
-					DBG_871X("RTW_%s:P2P_DEVDISC_RESP, dialogToken=%d, status:%d\n", (tx==_TRUE)?"Tx":"Rx", dialogToken, cont?*cont:-1);
+					DBG_871X("RTW_%s:P2P_DEVDISC_RESP, dialogToken=%d, status:%d\n", (tx==true)?"Tx":"Rx", dialogToken, cont?*cont:-1);
 					break;
 				case P2P_PROVISION_DISC_REQ:
 				{
@@ -3901,25 +3901,25 @@ int rtw_p2p_check_frames(_adapter *padap
 					uint p2p_ielen = 0;
 					uint contentlen = 0;
 
-					DBG_871X("RTW_%s:P2P_PROVISION_DISC_REQ, dialogToken=%d\n", (tx==_TRUE)?"Tx":"Rx", dialogToken);
+					DBG_871X("RTW_%s:P2P_PROVISION_DISC_REQ, dialogToken=%d\n", (tx==true)?"Tx":"Rx", dialogToken);
 
 					//if(tx)
 					{
-						pwdev_priv->provdisc_req_issued = _FALSE;
+						pwdev_priv->provdisc_req_issued = false;
 
 						if( (p2p_ie=rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)))
 						{
 
 							if(rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, NULL, &contentlen))
 							{
-								pwdev_priv->provdisc_req_issued = _FALSE;//case: p2p_client join p2p GO
+								pwdev_priv->provdisc_req_issued = false;//case: p2p_client join p2p GO
 							}
 							else
 							{
 								#ifdef CONFIG_DEBUG_CFG80211
-								DBG_871X("provdisc_req_issued is _TRUE\n");
+								DBG_871X("provdisc_req_issued is true\n");
 								#endif //CONFIG_DEBUG_CFG80211
-								pwdev_priv->provdisc_req_issued = _TRUE;//case: p2p_devices connection before Nego req.
+								pwdev_priv->provdisc_req_issued = true;//case: p2p_devices connection before Nego req.
 							}
 
 						}
@@ -3927,10 +3927,10 @@ int rtw_p2p_check_frames(_adapter *padap
 				}
 					break;
 				case P2P_PROVISION_DISC_RESP:
-					DBG_871X("RTW_%s:P2P_PROVISION_DISC_RESP, dialogToken=%d\n", (tx==_TRUE)?"Tx":"Rx", dialogToken);
+					DBG_871X("RTW_%s:P2P_PROVISION_DISC_RESP, dialogToken=%d\n", (tx==true)?"Tx":"Rx", dialogToken);
 					break;
 				default:
-					DBG_871X("RTW_%s:OUI_Subtype=%d, dialogToken=%d\n", (tx==_TRUE)?"Tx":"Rx", OUI_Subtype, dialogToken);
+					DBG_871X("RTW_%s:OUI_Subtype=%d, dialogToken=%d\n", (tx==true)?"Tx":"Rx", OUI_Subtype, dialogToken);
 					break;
 			}
 
@@ -3952,26 +3952,26 @@ int rtw_p2p_check_frames(_adapter *padap
 		switch(OUI_Subtype)
 		{
 			case P2P_NOTICE_OF_ABSENCE:
-				DBG_871X("RTW_%s:P2P_NOTICE_OF_ABSENCE, dialogToken=%d\n", (tx==_TRUE)?"TX":"RX", dialogToken);
+				DBG_871X("RTW_%s:P2P_NOTICE_OF_ABSENCE, dialogToken=%d\n", (tx==true)?"TX":"RX", dialogToken);
 				break;
 			case P2P_PRESENCE_REQUEST:
-				DBG_871X("RTW_%s:P2P_PRESENCE_REQUEST, dialogToken=%d\n", (tx==_TRUE)?"TX":"RX", dialogToken);
+				DBG_871X("RTW_%s:P2P_PRESENCE_REQUEST, dialogToken=%d\n", (tx==true)?"TX":"RX", dialogToken);
 				break;
 			case P2P_PRESENCE_RESPONSE:
-				DBG_871X("RTW_%s:P2P_PRESENCE_RESPONSE, dialogToken=%d\n", (tx==_TRUE)?"TX":"RX", dialogToken);
+				DBG_871X("RTW_%s:P2P_PRESENCE_RESPONSE, dialogToken=%d\n", (tx==true)?"TX":"RX", dialogToken);
 				break;
 			case P2P_GO_DISC_REQUEST:
-				DBG_871X("RTW_%s:P2P_GO_DISC_REQUEST, dialogToken=%d\n", (tx==_TRUE)?"TX":"RX", dialogToken);
+				DBG_871X("RTW_%s:P2P_GO_DISC_REQUEST, dialogToken=%d\n", (tx==true)?"TX":"RX", dialogToken);
 				break;
 			default:
-				DBG_871X("RTW_%s:OUI_Subtype=%d, dialogToken=%d\n", (tx==_TRUE)?"TX":"RX", OUI_Subtype, dialogToken);
+				DBG_871X("RTW_%s:OUI_Subtype=%d, dialogToken=%d\n", (tx==true)?"TX":"RX", OUI_Subtype, dialogToken);
 				break;
 		}
 
 	}
 	else
 	{
-		DBG_871X("RTW_%s:action frame category=%d\n", (tx==_TRUE)?"TX":"RX", category);
+		DBG_871X("RTW_%s:action frame category=%d\n", (tx==true)?"TX":"RX", category);
 		//is_p2p_frame = (-1);
 	}
 
@@ -4087,7 +4087,7 @@ void process_p2p_ps_ie(PADAPTER padapter
 	u32	attr_contentlen = 0;
 
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
-	u8	find_p2p = _FALSE, find_p2p_ps = _FALSE;
+	u8	find_p2p = false, find_p2p_ps = false;
 	u8	noa_offset, noa_num, noa_index;
 
 _func_enter_;
@@ -4111,11 +4111,11 @@ _func_enter_;
 
 	while(p2p_ie)
 	{
-		find_p2p = _TRUE;
+		find_p2p = true;
 		// Get Notice of Absence IE.
 		if(rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_NOA, noa_attr, &attr_contentlen))
 		{
-			find_p2p_ps = _TRUE;
+			find_p2p_ps = true;
 			noa_index = noa_attr[0];
 
 			if( (pwdinfo->p2p_ps_mode == P2P_PS_NONE) ||
@@ -4154,7 +4154,7 @@ _func_enter_;
 				{
 					pwdinfo->p2p_ps_mode = P2P_PS_CTWINDOW;
 					// driver should wait LPS for entering CTWindow
-					if(padapter->pwrctrlpriv.bFwCurrentInPSMode == _TRUE)
+					if(padapter->pwrctrlpriv.bFwCurrentInPSMode == true)
 					{
 						p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 1);
 					}
@@ -4178,9 +4178,9 @@ _func_enter_;
 
 	}
 
-	if(find_p2p == _TRUE)
+	if(find_p2p == true)
 	{
-		if( (pwdinfo->p2p_ps_mode > P2P_PS_NONE) && (find_p2p_ps == _FALSE) )
+		if( (pwdinfo->p2p_ps_mode > P2P_PS_NONE) && (find_p2p_ps == false) )
 		{
 			p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
 		}
@@ -4208,7 +4208,7 @@ _func_enter_;
 			pwdinfo->opp_ps = 0;
 			pwdinfo->noa_num = 0;
 			pwdinfo->p2p_ps_mode = P2P_PS_NONE;
-			if(padapter->pwrctrlpriv.bFwCurrentInPSMode == _TRUE)
+			if(padapter->pwrctrlpriv.bFwCurrentInPSMode == true)
 			{
 				if(pwrpriv->smart_ps == 0)
 				{
@@ -4361,7 +4361,7 @@ static void pre_tx_scan_timer_process (v
 
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
 	{
-		if ( _TRUE == pwdinfo->tx_prov_disc_info.benable )	//	the provision discovery request frame is trigger to send or not
+		if ( true == pwdinfo->tx_prov_disc_info.benable )	//	the provision discovery request frame is trigger to send or not
 		{
 			p2p_protocol_wk_cmd( adapter, P2P_PRE_TX_PROVDISC_PROCESS_WK );
 			//issue_probereq_p2p(adapter, NULL);
@@ -4370,7 +4370,7 @@ static void pre_tx_scan_timer_process (v
 	}
 	else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
 	{
-		if ( _TRUE == pwdinfo->nego_req_info.benable )
+		if ( true == pwdinfo->nego_req_info.benable )
 		{
 			p2p_protocol_wk_cmd( adapter, P2P_PRE_TX_NEGOREQ_PROCESS_WK );
 			//issue_probereq_p2p(adapter, NULL);
@@ -4379,7 +4379,7 @@ static void pre_tx_scan_timer_process (v
 	}
 	else if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ ) )
 	{
-		if ( _TRUE == pwdinfo->invitereq_info.benable )
+		if ( true == pwdinfo->invitereq_info.benable )
 		{
 			p2p_protocol_wk_cmd( adapter, P2P_PRE_TX_INVITEREQ_PROCESS_WK );
 		}
@@ -4431,7 +4431,7 @@ void reset_global_wifidirect_info( _adap
 
 	pwdinfo = &padapter->wdinfo;
 	pwdinfo->persistent_supported = 0;
-	pwdinfo->session_available = _TRUE;
+	pwdinfo->session_available = true;
 	pwdinfo->wfd_tdls_enable = 0;
 	pwdinfo->wfd_tdls_weaksec = 0;
 }
@@ -4445,13 +4445,13 @@ int rtw_init_wifi_display_info(_adapter*
 	// Used in P2P and TDLS
 	pwfd_info->rtsp_ctrlport = 554;
 	pwfd_info->peer_rtsp_ctrlport = 0;	//	Reset to 0
-	pwfd_info->wfd_enable = _FALSE;
+	pwfd_info->wfd_enable = false;
 	pwfd_info->wfd_device_type = WFD_DEVINFO_PSINK;
 	pwfd_info->scan_result_type = SCAN_RESULT_P2P_ONLY;
 
 	// Used in P2P
-	pwfd_info->peer_session_avail = _TRUE;
-	pwfd_info->wfd_pc = _FALSE;
+	pwfd_info->peer_session_avail = true;
+	pwfd_info->wfd_pc = false;
 
 	// Used in TDLS
 	_rtw_memset( pwfd_info->ip_address, 0x00, 4 );
@@ -4520,7 +4520,7 @@ void init_wifidirect_info( _adapter* pad
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 	}
 
-	if ( ( check_buddy_fwstate(padapter, _FW_LINKED ) == _TRUE ) &&
+	if ( ( check_buddy_fwstate(padapter, _FW_LINKED ) == true ) &&
 	      ( ( pbuddy_mlmeext->cur_channel == 1) || ( pbuddy_mlmeext->cur_channel == 6 ) || ( pbuddy_mlmeext->cur_channel == 11 ) )
 	   )
 	{
@@ -4539,7 +4539,7 @@ void init_wifidirect_info( _adapter* pad
 	{
 		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
 		#ifdef CONFIG_CONCURRENT_MODE
-		if ( check_buddy_fwstate(padapter, _FW_LINKED ) == _TRUE )
+		if ( check_buddy_fwstate(padapter, _FW_LINKED ) == true )
 		{
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_IDLE);
 		}
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -32,13 +32,13 @@ void ips_enter(_adapter * padapter)
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
 #ifdef CONFIG_INTEL_PROXIM
-	if(padapter->proximity.proxim_on==_TRUE){
+	if(padapter->proximity.proxim_on==true){
 		return;
 	}
 #endif
 	_enter_pwrlock(&pwrpriv->lock);
 
-	pwrpriv->bips_processing = _TRUE;
+	pwrpriv->bips_processing = true;
 
 	// syn ips_mode with request
 	pwrpriv->ips_mode = pwrpriv->ips_mode_req;
@@ -49,12 +49,12 @@ void ips_enter(_adapter * padapter)
 	if(rf_off == pwrpriv->change_rfpwrstate )
 	{
 		if(pwrpriv->ips_mode == IPS_LEVEL_2)
-			pwrpriv->bkeepfwalive = _TRUE;
+			pwrpriv->bkeepfwalive = true;
 
 		rtw_ips_pwr_down(padapter);
 		pwrpriv->rf_pwrstate = rf_off;
 	}
-	pwrpriv->bips_processing = _FALSE;
+	pwrpriv->bips_processing = false;
 	_exit_pwrlock(&pwrpriv->lock);
 
 }
@@ -69,7 +69,7 @@ int ips_leave(_adapter * padapter)
 	_enter_pwrlock(&pwrpriv->lock);
 	if((pwrpriv->rf_pwrstate == rf_off) &&(!pwrpriv->bips_processing))
 	{
-		pwrpriv->bips_processing = _TRUE;
+		pwrpriv->bips_processing = true;
 		pwrpriv->change_rfpwrstate = rf_on;
 		pwrpriv->ips_leave_cnts++;
 		DBG_871X("==>ips_leave cnts:%d\n",pwrpriv->ips_leave_cnts);
@@ -93,9 +93,9 @@ int ips_leave(_adapter * padapter)
 		}
 
 		DBG_871X("==> ips_leave.....LED(0x%08x)...\n",rtw_read32(padapter,0x4c));
-		pwrpriv->bips_processing = _FALSE;
+		pwrpriv->bips_processing = false;
 
-		pwrpriv->bkeepfwalive = _FALSE;
+		pwrpriv->bkeepfwalive = false;
 
 
 	}
@@ -127,7 +127,7 @@ bool rtw_pwr_unassociated_idle(_adapter
 #endif
 #endif
 
-	bool ret = _FALSE;
+	bool ret = false;
 
 	if (adapter->pwrctrlpriv.ips_deny_time >= rtw_get_current_time()) {
 		//DBG_871X("%s ips_deny_time\n", __func__);
@@ -170,7 +170,7 @@ bool rtw_pwr_unassociated_idle(_adapter
 			goto exit;
 		}
 	}
-	ret = _TRUE;
+	ret = true;
 
 exit:
 	return ret;
@@ -187,10 +187,10 @@ void rtw_ps_processor(_adapter*padapter)
 	rt_rf_power_state rfpwrstate;
 #endif //SUPPORT_HW_RFOFF_DETECTED
 
-	pwrpriv->ps_processing = _TRUE;
+	pwrpriv->ps_processing = true;
 
 #ifdef SUPPORT_HW_RFOFF_DETECTED
-	if(pwrpriv->bips_processing == _TRUE)
+	if(pwrpriv->bips_processing == true)
 		goto exit;
 
 	//DBG_871X("==> fw report state(0x%x)\n",rtw_read8(padapter,0x1ca));
@@ -201,8 +201,8 @@ void rtw_ps_processor(_adapter*padapter)
 		{
 			if(pwrpriv->rf_pwrstate == rf_on)
 			{
-				if(padapter->net_closed == _TRUE)
-					pwrpriv->ps_flag = _TRUE;
+				if(padapter->net_closed == true)
+					pwrpriv->ps_flag = true;
 
 				rfpwrstate = RfOnOffDetect(padapter);
 				DBG_871X("@@@@- #1  %s==> rfstate:%s \n",__FUNCTION__,(rfpwrstate==rf_on)?"rf_on":"rf_off");
@@ -212,8 +212,8 @@ void rtw_ps_processor(_adapter*padapter)
 					{
 						pwrpriv->change_rfpwrstate = rf_off;
 
-						pwrpriv->bkeepfwalive = _TRUE;
-						pwrpriv->brfoffbyhw = _TRUE;
+						pwrpriv->bkeepfwalive = true;
+						pwrpriv->brfoffbyhw = true;
 
 						autosuspend_enter(padapter);
 					}
@@ -231,8 +231,8 @@ void rtw_ps_processor(_adapter*padapter)
 				if(rfpwrstate == rf_off)
 				{
 					pwrpriv->change_rfpwrstate = rf_off;
-					pwrpriv->brfoffbyhw = _TRUE;
-					padapter->bCardDisableWOHSM = _TRUE;
+					pwrpriv->brfoffbyhw = true;
+					padapter->bCardDisableWOHSM = true;
 					rtw_hw_suspend(padapter );
 				}
 				else
@@ -254,7 +254,7 @@ void rtw_ps_processor(_adapter*padapter)
 	)
 		goto exit;
 
-	if (rtw_pwr_unassociated_idle(padapter) == _FALSE)
+	if (rtw_pwr_unassociated_idle(padapter) == false)
 		goto exit;
 
 	if((pwrpriv->rf_pwrstate == rf_on) && ((pwrpriv->pwr_state_check_cnts%4)==0))
@@ -266,12 +266,12 @@ void rtw_ps_processor(_adapter*padapter)
 		if(padapter->registrypriv.usbss_enable)
 		{
 			if(pwrpriv->bHWPwrPindetect)
-				pwrpriv->bkeepfwalive = _TRUE;
+				pwrpriv->bkeepfwalive = true;
 
-			if(padapter->net_closed == _TRUE)
-				pwrpriv->ps_flag = _TRUE;
+			if(padapter->net_closed == true)
+				pwrpriv->ps_flag = true;
 
-			padapter->bCardDisableWOHSM = _TRUE;
+			padapter->bCardDisableWOHSM = true;
 			autosuspend_enter(padapter);
 		}
 		else if(pwrpriv->bHWPwrPindetect)
@@ -287,7 +287,7 @@ void rtw_ps_processor(_adapter*padapter)
 	}
 exit:
 	rtw_set_pwr_state_check_timer(&padapter->pwrctrlpriv);
-	pwrpriv->ps_processing = _FALSE;
+	pwrpriv->ps_processing = false;
 	return;
 }
 
@@ -321,8 +321,8 @@ _func_enter_;
 		return;
 	}
 
-	if ((padapter->bDriverStopped == _TRUE) ||
-		(padapter->bSurpriseRemoved == _TRUE)) {
+	if ((padapter->bDriverStopped == true) ||
+		(padapter->bSurpriseRemoved == true)) {
 		RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_err_,
 				 ("%s: bDriverStopped(%d) bSurpriseRemoved(%d)\n",
 				  __FUNCTION__, padapter->bDriverStopped, padapter->bSurpriseRemoved));
@@ -361,29 +361,29 @@ u8 PS_RDY_CHECK(_adapter * padapter)
 
 	if(delta_time < LPS_DELAY_TIME)
 	{
-		return _FALSE;
+		return false;
 	}
 
-	if (	(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE) ||
-		(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) )
-		return _FALSE;
+	if (	(check_fwstate(pmlmepriv, _FW_LINKED) == false) ||
+		(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) )
+		return false;
 
-	if(_TRUE == pwrpriv->bInSuspend )
-		return _FALSE;
+	if(true == pwrpriv->bInSuspend )
+		return false;
 
-	if( (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) && (padapter->securitypriv.binstallGrpkey == _FALSE) )
+	if( (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) && (padapter->securitypriv.binstallGrpkey == false) )
 	{
 		DBG_871X("Group handshake still in progress !!!\n");
-		return _FALSE;
+		return false;
 	}
 #ifdef CONFIG_IOCTL_CFG80211
 	if (!rtw_cfg80211_pwr_mgmt(padapter))
-		return _FALSE;
+		return false;
 #endif
 
-	return _TRUE;
+	return true;
 }
 
 void rtw_set_ps_mode(PADAPTER padapter, u8 ps_mode, u8 smart_ps)
@@ -436,7 +436,7 @@ _func_enter_;
 				phead = &(pstapriv->sta_hash[i]);
 				plist = get_next(phead);
 
-				while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+				while ((rtw_end_of_queue_search(phead, plist)) == false)
 				{
 					ptdls_sta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
@@ -459,7 +459,7 @@ _func_enter_;
 			while (pwrpriv->cpwm != PS_STATE_S4) {
 				n++;
 				if (n == 10000) break;
-				if (padapter->bSurpriseRemoved == _TRUE) break;
+				if (padapter->bSurpriseRemoved == true) break;
 				rtw_msleep_os(1);
 			}
 			if (n == 10000)
@@ -467,7 +467,7 @@ _func_enter_;
 }
 #endif
 			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&ps_mode));
-			pwrpriv->bFwCurrentInPSMode = _FALSE;
+			pwrpriv->bFwCurrentInPSMode = false;
 #ifdef CONFIG_LPS_LCLK
 			_exit_pwrlock(&pwrpriv->lock);
 #endif
@@ -490,7 +490,7 @@ _func_enter_;
 				phead = &(pstapriv->sta_hash[i]);
 				plist = get_next(phead);
 
-				while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+				while ((rtw_end_of_queue_search(phead, plist)) == false)
 				{
 					ptdls_sta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
@@ -505,7 +505,7 @@ _func_enter_;
 
 			pwrpriv->smart_ps = smart_ps;
 			pwrpriv->pwr_mode = ps_mode;
-			pwrpriv->bFwCurrentInPSMode = _TRUE;
+			pwrpriv->bFwCurrentInPSMode = true;
 			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&ps_mode));
 #ifdef CONFIG_P2P_PS
 			// Set CTWindow after LPS
@@ -577,18 +577,18 @@ _func_enter_;
 #endif
 
 #ifdef CONFIG_INTEL_PROXIM
-	if(padapter->proximity.proxim_on==_TRUE){
+	if(padapter->proximity.proxim_on==true){
 		return;
 	}
 #endif
-	if (	(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE) ||
-		(check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) ||
-		(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) )
+	if (	(check_fwstate(pmlmepriv, _FW_LINKED) == false) ||
+		(check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) )
 		return;
 
-	if(_TRUE == pwrpriv->bInSuspend )
+	if(true == pwrpriv->bInSuspend )
 		return ;
 
 	if (pwrpriv->bLeisurePs)
@@ -621,7 +621,7 @@ void LPS_Leave(PADAPTER padapter)
 
 	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
 	u32 start_time;
-	bool bAwake = _FALSE;
+	bool bAwake = false;
 
 _func_enter_;
 
@@ -678,7 +678,7 @@ void LeaveAllPowerSaveMode(IN PADAPTER A
 _func_enter_;
 
 	//DBG_871X("%s.....\n",__FUNCTION__);
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{ //connect
 #ifdef CONFIG_P2P_PS
 		p2p_ps_wk_cmd(Adapter, P2P_PS_DISABLE, 0);
@@ -706,7 +706,7 @@ _func_enter_;
 			{
 			/*
 				#ifdef CONFIG_IPS
-				if(_FALSE == ips_leave(Adapter))
+				if(false == ips_leave(Adapter))
 				{
 					DBG_871X("======> ips_leave fail.............\n");
 				}
@@ -792,7 +792,7 @@ _func_enter_;
 
 	register_task_alive(pwrctrl, XMIT_ALIVE);
 
-	if (pwrctrl->bFwCurrentInPSMode == _TRUE)
+	if (pwrctrl->bFwCurrentInPSMode == true)
 	{
 		RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_err_,
 				 ("rtw_register_tx_alive: cpwm=0x%02x alives=0x%08x\n",
@@ -839,7 +839,7 @@ _func_enter_;
 
 	register_task_alive(pwrctrl, CMD_ALIVE);
 
-	if (pwrctrl->bFwCurrentInPSMode == _TRUE)
+	if (pwrctrl->bFwCurrentInPSMode == true)
 	{
 		RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
 				 ("rtw_register_cmd_alive: cpwm=0x%02x alives=0x%08x\n",
@@ -941,7 +941,7 @@ _func_enter_;
 	unregister_task_alive(pwrctrl, XMIT_ALIVE);
 
 	if ((pwrctrl->pwr_mode != PS_MODE_ACTIVE) &&
-		(pwrctrl->bFwCurrentInPSMode == _TRUE))
+		(pwrctrl->bFwCurrentInPSMode == true))
 	{
 		if ((pwrctrl->alives == 0) &&
 			(pwrctrl->cpwm > PS_STATE_S0))
@@ -979,7 +979,7 @@ _func_enter_;
 	unregister_task_alive(pwrctrl, CMD_ALIVE);
 
 	if ((pwrctrl->pwr_mode != PS_MODE_ACTIVE) &&
-		(pwrctrl->bFwCurrentInPSMode == _TRUE))
+		(pwrctrl->bFwCurrentInPSMode == true))
 	{
 		if ((pwrctrl->alives == 0) &&
 			(pwrctrl->cpwm > PS_STATE_S0))
@@ -1061,9 +1061,9 @@ _func_enter_;
 
 	pwrctrlpriv->pwr_state_check_interval = RTW_PWR_STATE_CHK_INTERVAL;
 	pwrctrlpriv->pwr_state_check_cnts = 0;
-	pwrctrlpriv->bInternalAutoSuspend = _FALSE;
-	pwrctrlpriv->bInSuspend = _FALSE;
-	pwrctrlpriv->bkeepfwalive = _FALSE;
+	pwrctrlpriv->bInternalAutoSuspend = false;
+	pwrctrlpriv->bInSuspend = false;
+	pwrctrlpriv->bkeepfwalive = false;
 
 #ifdef CONFIG_AUTOSUSPEND
 #ifdef SUPPORT_HW_RFOFF_DETECTED
@@ -1074,9 +1074,9 @@ _func_enter_;
 	pwrctrlpriv->LpsIdleCount = 0;
 	//pwrctrlpriv->FWCtrlPSMode =padapter->registrypriv.power_mgnt;// PS_MODE_MIN;
 	pwrctrlpriv->power_mgnt =padapter->registrypriv.power_mgnt;// PS_MODE_MIN;
-	pwrctrlpriv->bLeisurePs = (PS_MODE_ACTIVE != pwrctrlpriv->power_mgnt)?_TRUE:_FALSE;
+	pwrctrlpriv->bLeisurePs = (PS_MODE_ACTIVE != pwrctrlpriv->power_mgnt)?true:false;
 
-	pwrctrlpriv->bFwCurrentInPSMode = _FALSE;
+	pwrctrlpriv->bFwCurrentInPSMode = false;
 
 	pwrctrlpriv->cpwm = PS_STATE_S4;
 
@@ -1158,12 +1158,12 @@ void rtw_resume_in_workqueue(struct pwrc
 #if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
 inline bool rtw_is_earlysuspend_registered(struct pwrctrl_priv *pwrpriv)
 {
-	return (pwrpriv->early_suspend.suspend) ? _TRUE : _FALSE;
+	return (pwrpriv->early_suspend.suspend) ? true : false;
 }
 
 inline bool rtw_is_do_late_resume(struct pwrctrl_priv *pwrpriv)
 {
-	return (pwrpriv->do_late_resume) ? _TRUE : _FALSE;
+	return (pwrpriv->do_late_resume) ? true : false;
 }
 
 inline void rtw_set_do_late_resume(struct pwrctrl_priv *pwrpriv, bool enable)
@@ -1179,7 +1179,7 @@ static void rtw_early_suspend(struct ear
 	struct pwrctrl_priv *pwrpriv = container_of(h, struct pwrctrl_priv, early_suspend);
 	DBG_871X("%s\n",__FUNCTION__);
 
-	rtw_set_do_late_resume(pwrpriv, _FALSE);
+	rtw_set_do_late_resume(pwrpriv, false);
 }
 
 static void rtw_late_resume(struct early_suspend *h)
@@ -1189,7 +1189,7 @@ static void rtw_late_resume(struct early
 
 	DBG_871X("%s\n",__FUNCTION__);
 	if(pwrpriv->do_late_resume) {
-		rtw_set_do_late_resume(pwrpriv, _FALSE);
+		rtw_set_do_late_resume(pwrpriv, false);
 		rtw_resume_process(adapter);
 	}
 }
@@ -1211,7 +1211,7 @@ void rtw_unregister_early_suspend(struct
 {
 	DBG_871X("%s\n", __FUNCTION__);
 
-	rtw_set_do_late_resume(pwrpriv, _FALSE);
+	rtw_set_do_late_resume(pwrpriv, false);
 
 	if (pwrpriv->early_suspend.suspend)
 		unregister_early_suspend(&pwrpriv->early_suspend);
@@ -1228,7 +1228,7 @@ static void rtw_early_suspend(android_ea
 	struct pwrctrl_priv *pwrpriv = container_of(h, struct pwrctrl_priv, early_suspend);
 	DBG_871X("%s\n",__FUNCTION__);
 
-	rtw_set_do_late_resume(pwrpriv, _FALSE);
+	rtw_set_do_late_resume(pwrpriv, false);
 }
 
 static void rtw_late_resume(android_early_suspend_t *h)
@@ -1238,7 +1238,7 @@ static void rtw_late_resume(android_earl
 
 	DBG_871X("%s\n",__FUNCTION__);
 	if(pwrpriv->do_late_resume) {
-		rtw_set_do_late_resume(pwrpriv, _FALSE);
+		rtw_set_do_late_resume(pwrpriv, false);
 		rtw_resume_process(adapter);
 	}
 }
@@ -1258,7 +1258,7 @@ void rtw_unregister_early_suspend(struct
 {
 	DBG_871X("%s\n", __FUNCTION__);
 
-	rtw_set_do_late_resume(pwrpriv, _FALSE);
+	rtw_set_do_late_resume(pwrpriv, false);
 
 	if (pwrpriv->early_suspend.suspend)
 		android_unregister_early_suspend(&pwrpriv->early_suspend);
@@ -1270,7 +1270,7 @@ void rtw_unregister_early_suspend(struct
 
 u8 rtw_interface_ps_func(_adapter *padapter,HAL_INTF_PS_FUNC efunc_id,u8* val)
 {
-	u8 bResult = _TRUE;
+	u8 bResult = true;
 
 	rtw_hal_intf_ps_func(padapter,efunc_id,val);
 
@@ -1301,7 +1301,7 @@ int _rtw_pwr_wakeup(_adapter *padapter,
 	if (padapter->pbuddy_adapter)
 		LeaveAllPowerSaveMode(padapter->pbuddy_adapter);
 
-	if ((padapter->isprimary == _FALSE) && padapter->pbuddy_adapter){
+	if ((padapter->isprimary == false) && padapter->pbuddy_adapter){
 		padapter = padapter->pbuddy_adapter;
 		pwrpriv = &padapter->pwrctrlpriv;
 		pmlmepriv = &padapter->mlmepriv;
@@ -1321,7 +1321,7 @@ int _rtw_pwr_wakeup(_adapter *padapter,
 			DBG_871X("%s wait ps_processing done\n", __func__);
 	}
 
-	if (pwrpriv->bInternalAutoSuspend == _FALSE && pwrpriv->bInSuspend) {
+	if (pwrpriv->bInternalAutoSuspend == false && pwrpriv->bInSuspend) {
 		DBG_871X("%s wait bInSuspend...\n", __func__);
 		while (pwrpriv->bInSuspend
 			&& ((rtw_get_passing_time_ms(start) <= 3000 && !rtw_is_do_late_resume(pwrpriv))
@@ -1336,19 +1336,19 @@ int _rtw_pwr_wakeup(_adapter *padapter,
 	}
 
 	//System suspend is not allowed to wakeup
-	if((pwrpriv->bInternalAutoSuspend == _FALSE) && (_TRUE == pwrpriv->bInSuspend )){
+	if((pwrpriv->bInternalAutoSuspend == false) && (true == pwrpriv->bInSuspend )){
 		ret = _FAIL;
 		goto exit;
 	}
 
 	//block???
-	if((pwrpriv->bInternalAutoSuspend == _TRUE)  && (padapter->net_closed == _TRUE)) {
+	if((pwrpriv->bInternalAutoSuspend == true)  && (padapter->net_closed == true)) {
 		ret = _FAIL;
 		goto exit;
 	}
 
 	//I think this should be check in IPS, LPS, autosuspend functions...
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		ret = _SUCCESS;
 		goto exit;
@@ -1357,7 +1357,7 @@ int _rtw_pwr_wakeup(_adapter *padapter,
 	if(rf_off == pwrpriv->rf_pwrstate )
 	{
 #ifdef CONFIG_AUTOSUSPEND
-		 if(pwrpriv->brfoffbyhw==_TRUE)
+		 if(pwrpriv->brfoffbyhw==true)
 		{
 			DBG_8192C("hw still in rf_off state ...........\n");
 			ret = _FAIL;
@@ -1398,7 +1398,7 @@ int _rtw_pwr_wakeup(_adapter *padapter,
 			, padapter->bDriverStopped
 			, padapter->bup
 			, padapter->hw_init_completed);
-		ret= _FALSE;
+		ret= false;
 		goto exit;
 	}
 
@@ -1427,7 +1427,7 @@ int rtw_pm_set_lps(_adapter *padapter, u
 				pwrctrlpriv->LpsIdleCount = 2;
 			}
 			pwrctrlpriv->power_mgnt = mode;
-			pwrctrlpriv->bLeisurePs = (PS_MODE_ACTIVE != pwrctrlpriv->power_mgnt)?_TRUE:_FALSE;
+			pwrctrlpriv->bLeisurePs = (PS_MODE_ACTIVE != pwrctrlpriv->power_mgnt)?true:false;
 		}
 	}
 	else
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -182,7 +182,7 @@ union recv_frame *_rtw_alloc_recvframe (
 	struct recv_priv *precvpriv;
 _func_enter_;
 
-	if(_rtw_queue_empty(pfree_recv_queue) == _TRUE)
+	if(_rtw_queue_empty(pfree_recv_queue) == true)
 	{
 		precvframe = NULL;
 	}
@@ -346,7 +346,7 @@ _func_enter_;
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
 
-	while(rtw_end_of_queue_search(phead, plist) == _FALSE)
+	while(rtw_end_of_queue_search(phead, plist) == false)
 	{
 		precvframe = LIST_CONTAINOR(plist, union recv_frame, u);
 
@@ -416,7 +416,7 @@ struct recv_buf *rtw_dequeue_recvbuf (_q
 
 	_enter_critical(&queue->lock, &irqL);
 
-	if(_rtw_queue_empty(queue) == _TRUE)
+	if(_rtw_queue_empty(queue) == true)
 	{
 		precvbuf = NULL;
 	}
@@ -445,7 +445,7 @@ sint recvframe_chkmic(_adapter *adapter,
 	sint	i,res=_SUCCESS;
 	u32	datalen;
 	u8	miccode[8];
-	u8	bmic_err=_FALSE,brpt_micerror = _TRUE;
+	u8	bmic_err=false,brpt_micerror = true;
 	u8	*pframe, *payload,*pframemic;
 	u8	*mickey;
 	//u8	*iv,rxdata_key_idx=0;
@@ -479,7 +479,7 @@ _func_enter_;
 				//DBG_871X("\n recvframe_chkmic: bcmc key psecuritypriv->dot118021XGrpKeyid(%d),pmlmeinfo->key_index(%d) ,recv key_id(%d)\n",
 				//								psecuritypriv->dot118021XGrpKeyid,pmlmeinfo->key_index,rxdata_key_idx);
 
-				if(psecuritypriv->binstallGrpkey==_FALSE)
+				if(psecuritypriv->binstallGrpkey==false)
 				{
 					res=_FAIL;
 					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n recvframe_chkmic:didn't install group key!!!!!!!!!!\n"));
@@ -504,17 +504,17 @@ _func_enter_;
 
 			pframemic=payload+datalen;
 
-			bmic_err=_FALSE;
+			bmic_err=false;
 
 			for(i=0;i<8;i++){
 				if(miccode[i] != *(pframemic+i)){
 					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvframe_chkmic:miccode[%d](%02x) != *(pframemic+%d)(%02x) ",i,miccode[i],i,*(pframemic+i)));
-					bmic_err=_TRUE;
+					bmic_err=true;
 				}
 			}
 
 
-			if(bmic_err==_TRUE){
+			if(bmic_err==true){
 
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n *(pframemic-8)-*(pframemic-1)=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
 					*(pframemic-8),*(pframemic-7),*(pframemic-6),*(pframemic-5),*(pframemic-4),*(pframemic-3),*(pframemic-2),*(pframemic-1)));
@@ -541,10 +541,10 @@ _func_enter_;
 
 				// double check key_index for some timing issue ,
 				// cannot compare with psecuritypriv->dot118021XGrpKeyid also cause timing issue
-				if((IS_MCAST(prxattrib->ra)==_TRUE)  && (prxattrib->key_index != pmlmeinfo->key_index ))
-					brpt_micerror = _FALSE;
+				if((IS_MCAST(prxattrib->ra)==true)  && (prxattrib->key_index != pmlmeinfo->key_index ))
+					brpt_micerror = false;
 
-				if(brpt_micerror == _TRUE)
+				if(brpt_micerror == true)
 				{
 					rtw_handle_tkip_mic_err(adapter,(u8)IS_MCAST(prxattrib->ra));
 					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" mic error :prxattrib->bdecrypted=%d \n", brpt_micerror));
@@ -556,9 +556,9 @@ _func_enter_;
 			}
 			else{
 				//mic checked ok
-				if((psecuritypriv->bcheck_grpkey ==_FALSE)&&(IS_MCAST(prxattrib->ra)==_TRUE)){
-					psecuritypriv->bcheck_grpkey =_TRUE;
-					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("psecuritypriv->bcheck_grpkey =_TRUE"));
+				if((psecuritypriv->bcheck_grpkey ==false)&&(IS_MCAST(prxattrib->ra)==true)){
+					psecuritypriv->bcheck_grpkey =true;
+					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("psecuritypriv->bcheck_grpkey =true"));
 				}
 			}
 
@@ -616,13 +616,13 @@ _func_enter_;
 		}
 	}
 
-	if((prxattrib->encrypt>0) && ((prxattrib->bdecrypted==0) ||(psecuritypriv->sw_decrypt==_TRUE)))
+	if((prxattrib->encrypt>0) && ((prxattrib->bdecrypted==0) ||(psecuritypriv->sw_decrypt==true)))
 	{
 
 #ifdef CONFIG_CONCURRENT_MODE
 		if(!IS_MCAST(prxattrib->ra))//bc/mc packets use sw decryption for concurrent mode
 #endif
-		psecuritypriv->hw_decrypted=_FALSE;
+		psecuritypriv->hw_decrypted=false;
 
 		#ifdef DBG_RX_DECRYPTOR
 		DBG_871X("prxstat->bdecrypted:%d,  prxattrib->encrypt:%d,  Setting psecuritypriv->hw_decrypted = %d\n"
@@ -649,7 +649,7 @@ _func_enter_;
 		&& (psecuritypriv->busetkipkey==1 || prxattrib->encrypt !=_TKIP_ )
 		)
 	{
-		psecuritypriv->hw_decrypted=_TRUE;
+		psecuritypriv->hw_decrypted=true;
 		#ifdef DBG_RX_DECRYPTOR
 		DBG_871X("prxstat->bdecrypted:%d,  prxattrib->encrypt:%d,  Setting psecuritypriv->hw_decrypted = %d\n"
 		, prxattrib->bdecrypted ,prxattrib->encrypt, psecuritypriv->hw_decrypted);
@@ -1067,8 +1067,8 @@ sint sta2sta_data_frame(
 
 _func_enter_;
 
-	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE))
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))
 	{
 
 		// filter packets that SA is myself or multicast or broadcast
@@ -1093,7 +1093,7 @@ _func_enter_;
 		sta_addr = pattrib->src;
 
 	}
-	else if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+	else if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 	{
 #ifdef CONFIG_TDLS
 		//direct link data transfer
@@ -1188,7 +1188,7 @@ _func_enter_;
 			sta_addr = pattrib->bssid;
 		}
 	}
-	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		if (bmcast)
 		{
@@ -1210,7 +1210,7 @@ _func_enter_;
 		}
 
 	}
-	else if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+	else if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
 	{
 		_rtw_memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
 		_rtw_memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
@@ -1241,7 +1241,7 @@ _func_enter_;
 	if (*psta == NULL) {
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("can't get psta under sta2sta_data_frame ; drop pkt\n"));
 #ifdef CONFIG_MP_INCLUDED
-		if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+		if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
 		adapter->mppriv.rx_pktloss++;
 #endif
 		ret= _FAIL;
@@ -1274,9 +1274,9 @@ sint ap2sta_data_frame(
 
 _func_enter_;
 
-	if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
-		&& (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE
-			|| check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE	)
+	if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+		&& (check_fwstate(pmlmepriv, _FW_LINKED) == true
+			|| check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true	)
 		)
 	{
 
@@ -1356,8 +1356,8 @@ _func_enter_;
 		}
 
 	}
-	else if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) &&
-		     (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) )
+	else if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) &&
+		     (check_fwstate(pmlmepriv, _FW_LINKED) == true) )
 	{
 		_rtw_memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
 		_rtw_memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
@@ -1381,7 +1381,7 @@ _func_enter_;
 
 
 	}
-	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		/* Special case */
 		ret = RTW_RX_HANDLED;
@@ -1432,7 +1432,7 @@ sint sta2ap_data_frame(
 
 _func_enter_;
 
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		//For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR
 		if(!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN))
@@ -1568,7 +1568,7 @@ sint validate_recv_ctrl_frame(_adapter *
 			xmitframe_phead = get_list_head(&psta->sleep_q);
 			xmitframe_plist = get_next(xmitframe_phead);
 
-			if ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
+			if ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
 			{
 				pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
@@ -1588,7 +1588,7 @@ sint validate_recv_ctrl_frame(_adapter *
 	                        //DBG_871X("handling ps-poll, q_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
 
 				_exit_critical_bh(&psta->sleep_q.lock, &irqL);
-				if(rtw_hal_xmit(padapter, pxmitframe) == _TRUE)
+				if(rtw_hal_xmit(padapter, pxmitframe) == true)
 				{
 					rtw_os_xmit_complete(padapter, pxmitframe);
 				}
@@ -1602,7 +1602,7 @@ sint validate_recv_ctrl_frame(_adapter *
 
 					//upate BCN for TIM IE
 					//update_BCNTIM(padapter);
-					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+					update_beacon(padapter, _TIM_IE_, NULL, false);
 				}
 
 			}
@@ -1628,7 +1628,7 @@ sint validate_recv_ctrl_frame(_adapter *
 
 					//upate BCN for TIM IE
 					//update_BCNTIM(padapter);
-					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+					update_beacon(padapter, _TIM_IE_, NULL, false);
 				}
 
 			}
@@ -1667,7 +1667,7 @@ sint validate_recv_mgnt_frame(PADAPTER p
 			else if (GetFrameSubType(precv_frame->u.hdr.rx_data) == WIFI_PROBEREQ)
 				psta->sta_stats.rx_probereq_pkts++;
 			else if (GetFrameSubType(precv_frame->u.hdr.rx_data) == WIFI_PROBERSP) {
-				if (_rtw_memcmp(padapter->eeprompriv.mac_addr, GetAddr1Ptr(precv_frame->u.hdr.rx_data), ETH_ALEN) == _TRUE)
+				if (_rtw_memcmp(padapter->eeprompriv.mac_addr, GetAddr1Ptr(precv_frame->u.hdr.rx_data), ETH_ALEN) == true)
 					psta->sta_stats.rx_probersp_pkts++;
 				else if (is_broadcast_mac_addr(GetAddr1Ptr(precv_frame->u.hdr.rx_data))
 					|| is_multicast_mac_addr(GetAddr1Ptr(precv_frame->u.hdr.rx_data)))
@@ -1679,7 +1679,7 @@ sint validate_recv_mgnt_frame(PADAPTER p
 	}
 
 #ifdef CONFIG_INTEL_PROXIM
-	if(padapter->proximity.proxim_on==_TRUE)
+	if(padapter->proximity.proxim_on==true)
 	{
 		struct rx_pkt_attrib * pattrib=&precv_frame->u.hdr.attrib;
 		 struct recv_stat* prxstat=( struct recv_stat * )  precv_frame->u.hdr.rx_head ;
@@ -1831,7 +1831,7 @@ _func_enter_;
 
 		if(pattrib->priority!=0 && pattrib->priority!=3)
 		{
-			adapter->recvpriv.bIsAnyNonBEPkts = _TRUE;
+			adapter->recvpriv.bIsAnyNonBEPkts = true;
 		}
 	}
 	else
@@ -2017,16 +2017,16 @@ _func_enter_;
 	/* convert hdr + possible LLC headers into Ethernet header */
 	//eth_type = (psnap_type[0] << 8) | psnap_type[1];
 	if((_rtw_memcmp(psnap, rtw_rfc1042_header, SNAP_SIZE) &&
-		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == _FALSE) &&
-		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2)==_FALSE) )||
+		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == false) &&
+		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2)==false) )||
 		//eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
 		 _rtw_memcmp(psnap, rtw_bridge_tunnel_header, SNAP_SIZE)){
 		/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
-		bsnaphdr = _TRUE;
+		bsnaphdr = true;
 	}
 	else {
 		/* Leave Ethernet header part of hdr and full payload */
-		bsnaphdr = _FALSE;
+		bsnaphdr = false;
 	}
 
 	rmv_len = pattrib->hdrlen + pattrib->iv_len +(bsnaphdr?SNAP_SIZE:0);
@@ -2038,7 +2038,7 @@ _func_enter_;
 	eth_type= ntohs((unsigned short )eth_type); //pattrib->ether_type
 	pattrib->eth_type = eth_type;
 
-	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE))
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true))
 	{
 		ptr += rmv_len ;
 		*ptr = 0x87;
@@ -2092,12 +2092,12 @@ _func_enter_;
 	if (psnap->dsap==0xaa && psnap->ssap==0xaa && psnap->ctrl==0x03)
 	{
 		if (_rtw_memcmp(psnap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN))
-			bsnaphdr=_TRUE;//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_RFC1042;
+			bsnaphdr=true;//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_RFC1042;
 		else if (_rtw_memcmp(psnap->oui, SNAP_HDR_APPLETALK_DDP, WLAN_IEEE_OUI_LEN) &&
 			_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_DDP, 2) )
-			bsnaphdr=_TRUE;	//wlan_pkt_format = WLAN_PKT_FORMAT_APPLETALK;
+			bsnaphdr=true;	//wlan_pkt_format = WLAN_PKT_FORMAT_APPLETALK;
 		else if (_rtw_memcmp( psnap->oui, oui_8021h, WLAN_IEEE_OUI_LEN))
-			bsnaphdr=_TRUE;	//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_TUNNEL;
+			bsnaphdr=true;	//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_TUNNEL;
 		else {
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("drop pkt due to invalid frame format!\n"));
 			ret= _FAIL;
@@ -2105,12 +2105,12 @@ _func_enter_;
 		}
 
 	} else
-		bsnaphdr=_FALSE;//wlan_pkt_format = WLAN_PKT_FORMAT_OTHERS;
+		bsnaphdr=false;//wlan_pkt_format = WLAN_PKT_FORMAT_OTHERS;
 
 	rmv_len = pattrib->hdrlen + pattrib->iv_len +(bsnaphdr?SNAP_SIZE:0);
 	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("===pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n", pattrib->hdrlen,  pattrib->iv_len));
 
-	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
 	{
 		ptr += rmv_len ;
 		*ptr = 0x87;
@@ -2221,7 +2221,7 @@ _func_enter_;
 
 	data=get_recvframe_data(prframe);
 
-	while(rtw_end_of_queue_search(phead, plist) == _FALSE)
+	while(rtw_end_of_queue_search(phead, plist) == false)
 	{
 		pnextrframe = LIST_CONTAINOR(plist, union recv_frame , u);
 		pnfhdr=&pnextrframe->u.hdr;
@@ -2323,7 +2323,7 @@ _func_enter_;
 			if(fragnum==0)
 			{
 				//the first fragment
-				if(_rtw_queue_empty(pdefrag_q) == _FALSE)
+				if(_rtw_queue_empty(pdefrag_q) == false)
 				{
 					//free current defrag_q
 					rtw_free_recvframe_queue(pdefrag_q, pfree_recv_queue);
@@ -2540,7 +2540,7 @@ int amsdu_to_msdu(_adapter *padapter, un
 #endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 
 
-			if( br_port && (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == _TRUE) )
+			if( br_port && (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) )
 			{
 				int nat25_handle_frame(_adapter *priv, struct sk_buff *skb);
 				if (nat25_handle_frame(padapter, sub_skb) == -1) {
@@ -2615,7 +2615,7 @@ int check_indicate_seq(struct recv_reord
 		#endif
 
 
-		return _FALSE;
+		return false;
 	}
 
 	//
@@ -2650,7 +2650,7 @@ int check_indicate_seq(struct recv_reord
 
 	//DbgPrint("exit->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
 
-	return _TRUE;
+	return true;
 }
 
 int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl, union recv_frame *prframe);
@@ -2671,7 +2671,7 @@ int enqueue_reorder_recvframe(struct rec
 	phead = get_list_head(ppending_recvframe_queue);
 	plist = get_next(phead);
 
-	while(rtw_end_of_queue_search(phead, plist) == _FALSE)
+	while(rtw_end_of_queue_search(phead, plist) == false)
 	{
 		pnextrframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pnextattrib = &pnextrframe->u.hdr.attrib;
@@ -2687,7 +2687,7 @@ int enqueue_reorder_recvframe(struct rec
 
 			//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
 
-			return _FALSE;
+			return false;
 		}
 		else
 		{
@@ -2711,7 +2711,7 @@ int enqueue_reorder_recvframe(struct rec
 
 
 	//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
-	return _TRUE;
+	return true;
 
 }
 
@@ -2724,7 +2724,7 @@ int recv_indicatepkts_in_order(_adapter
 	union recv_frame *prframe;
 	struct rx_pkt_attrib *pattrib;
 	//u8 index = 0;
-	int bPktInBuf = _FALSE;
+	int bPktInBuf = false;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 	_queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
 
@@ -2737,13 +2737,13 @@ int recv_indicatepkts_in_order(_adapter
 	plist = get_next(phead);
 
 	// Handling some condition for forced indicate case.
-	if(bforced==_TRUE)
+	if(bforced==true)
 	{
 		if(rtw_is_list_empty(phead))
 		{
 			// _exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
 			//_rtw_spinunlock_ex(&ppending_recvframe_queue->lock);
-			return _TRUE;
+			return true;
 		}
 
 		 prframe = LIST_CONTAINOR(plist, union recv_frame, u);
@@ -2784,8 +2784,8 @@ int recv_indicatepkts_in_order(_adapter
 			//indicate this recv_frame
 			if(!pattrib->amsdu)
 			{
-				if ((padapter->bDriverStopped == _FALSE) &&
-				    (padapter->bSurpriseRemoved == _FALSE))
+				if ((padapter->bDriverStopped == false) &&
+				    (padapter->bSurpriseRemoved == false))
 
 					rtw_recv_indicatepkt(padapter, prframe);//indicate this recv_frame
 
@@ -2802,12 +2802,12 @@ int recv_indicatepkts_in_order(_adapter
 
 
 			//Update local variables.
-			bPktInBuf = _FALSE;
+			bPktInBuf = false;
 
 		}
 		else
 		{
-			bPktInBuf = _TRUE;
+			bPktInBuf = true;
 			break;
 		}
 
@@ -2835,7 +2835,7 @@ int recv_indicatepkts_in_order(_adapter
 */
 	//_exit_critical_ex(&ppending_recvframe_queue->lock, &irql);
 
-	//return _TRUE;
+	//return true;
 	return bPktInBuf;
 
 }
@@ -2857,8 +2857,8 @@ int recv_indicatepkt_reorder(_adapter *p
 		if ((pattrib->qos!=1) /*|| pattrib->priority!=0 || IS_MCAST(pattrib->ra)*/
 			|| (pattrib->eth_type==0x0806) || (pattrib->ack_policy!=0))
 		{
-			if ((padapter->bDriverStopped == _FALSE) &&
-			    (padapter->bSurpriseRemoved == _FALSE))
+			if ((padapter->bDriverStopped == false) &&
+			    (padapter->bSurpriseRemoved == false))
 			{
 				RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@  recv_indicatepkt_reorder -recv_func recv_indicatepkt\n" ));
 
@@ -2875,7 +2875,7 @@ int recv_indicatepkt_reorder(_adapter *p
 
 		}
 
-		if (preorder_ctrl->enable == _FALSE)
+		if (preorder_ctrl->enable == false)
 		{
 			//indicate this recv_frame
 			preorder_ctrl->indicate_seq = pattrib->seq_num;
@@ -2904,7 +2904,7 @@ int recv_indicatepkt_reorder(_adapter *p
 	}
 	else if(pattrib->amsdu==1) //temp filter -> means didn't support A-MSDUs in a A-MPDU
 	{
-		if (preorder_ctrl->enable == _FALSE)
+		if (preorder_ctrl->enable == false)
 		{
 			preorder_ctrl->indicate_seq = pattrib->seq_num;
 			#ifdef DBG_RX_SEQ
@@ -2979,8 +2979,8 @@ int recv_indicatepkt_reorder(_adapter *p
 	// 2. All packets with SeqNum larger than or equal to WinStart => Buffer it.
 	//
 
-	//recv_indicatepkts_in_order(padapter, preorder_ctrl, _TRUE);
-	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, _FALSE)==_TRUE)
+	//recv_indicatepkts_in_order(padapter, preorder_ctrl, true);
+	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, false)==true)
 	{
 		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
 		_exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
@@ -3021,7 +3021,7 @@ void rtw_reordering_ctrl_timeout_handler
 
 	_enter_critical_bh(&ppending_recvframe_queue->lock, &irql);
 
-	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, _TRUE)==_TRUE)
+	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, true)==true)
 	{
 		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
 	}
@@ -3046,12 +3046,12 @@ int process_recv_indicatepkts(_adapter *
 	struct ht_priv	*phtpriv = &pmlmepriv->htpriv;
 
 #ifdef CONFIG_TDLS
-	if( (phtpriv->ht_option==_TRUE) ||
+	if( (phtpriv->ht_option==true) ||
 		((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
-		 (psta->htpriv.ht_option==_TRUE) &&
-		 (psta->htpriv.ampdu_enable==_TRUE))) //B/G/N Mode
+		 (psta->htpriv.ht_option==true) &&
+		 (psta->htpriv.ampdu_enable==true))) //B/G/N Mode
 #else
-	if(phtpriv->ht_option==_TRUE)  //B/G/N Mode
+	if(phtpriv->ht_option==true)  //B/G/N Mode
 #endif //CONFIG_TDLS
 	{
 		//prframe->u.hdr.preorder_ctrl = &precvpriv->recvreorder_ctrl[pattrib->priority];
@@ -3062,8 +3062,8 @@ int process_recv_indicatepkts(_adapter *
 			DBG_871X("DBG_RX_DROP_FRAME %s recv_indicatepkt_reorder error!\n", __FUNCTION__);
 			#endif
 
-			if ((padapter->bDriverStopped == _FALSE) &&
-			    (padapter->bSurpriseRemoved == _FALSE))
+			if ((padapter->bDriverStopped == false) &&
+			    (padapter->bSurpriseRemoved == false))
 			{
 				retval = _FAIL;
 				return retval;
@@ -3083,7 +3083,7 @@ int process_recv_indicatepkts(_adapter *
 			return retval;
 		}
 
-		if ((padapter->bDriverStopped ==_FALSE)&&( padapter->bSurpriseRemoved==_FALSE))
+		if ((padapter->bDriverStopped ==false)&&( padapter->bSurpriseRemoved==false))
 		{
 			//indicate this recv_frame
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("@@@@ process_recv_indicatepkts- recv_func recv_indicatepkt\n" ));
@@ -3118,14 +3118,14 @@ int recv_func_prehandle(_adapter *padapt
 #endif //CONFIG_MP_INCLUDED
 
 #ifdef CONFIG_MP_INCLUDED
-	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE))//&&(padapter->mppriv.check_mp_pkt == 0))
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true))//&&(padapter->mppriv.check_mp_pkt == 0))
 	{
 		if (pattrib->crc_err == 1)
 			padapter->mppriv.rx_crcerrpktcount++;
 		else
 			padapter->mppriv.rx_pktcount++;
 
-		if (check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE) == _FALSE) {
+		if (check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE) == false) {
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("MP - Not in loopback mode , drop pkt \n"));
 			ret = _FAIL;
 			rtw_free_recvframe(rframe, pfree_recv_queue);//free this recv_frame
@@ -3246,7 +3246,7 @@ int recv_func_posthandle(_adapter *padap
 			goto _recv_data_drop;
 		}
 
-		if ((padapter->bDriverStopped == _FALSE) && (padapter->bSurpriseRemoved == _FALSE))
+		if ((padapter->bDriverStopped == false) && (padapter->bSurpriseRemoved == false))
 		{
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@ recv_func: recv_func rtw_recv_indicatepkt\n" ));
 			//indicate this recv_frame
@@ -3331,7 +3331,7 @@ int recv_func(_adapter *padapter, union
 		/* check if need to enqueue into uc_swdec_pending_queue*/
 		if (check_fwstate(mlmepriv, WIFI_STATION_STATE) &&
 			!IS_MCAST(prxattrib->ra) && prxattrib->encrypt>0 &&
-			(prxattrib->bdecrypted == 0 ||psecuritypriv->sw_decrypt == _TRUE) &&
+			(prxattrib->bdecrypted == 0 ||psecuritypriv->sw_decrypt == true) &&
 			!is_wep_enc(psecuritypriv->dot11PrivacyAlgrthm) &&
 			!psecuritypriv->busetkipkey) {
 			rtw_enqueue_recvframe(rframe, &padapter->recvpriv.uc_swdec_pending_queue);
@@ -3421,7 +3421,7 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 		}
 
 		//update value of signal_strength, rssi, signal_qual
-		if(check_fwstate(&adapter->mlmepriv, _FW_UNDER_SURVEY) == _FALSE) {
+		if(check_fwstate(&adapter->mlmepriv, _FW_UNDER_SURVEY) == false) {
 			tmp_s = (avg_signal_strength+(_alpha-1)*recvpriv->signal_strength);
 			if(tmp_s %_alpha)
 				tmp_s = tmp_s/_alpha + 1;
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -779,7 +779,7 @@ _func_enter_;
 
 			if(IS_MCAST(prxattrib->ra))
 			{
-				if(psecuritypriv->binstallGrpkey==_FALSE)
+				if(psecuritypriv->binstallGrpkey==false)
 				{
 					res=_FAIL;
 					DBG_8192C("%s:rx bc/mc packets,but didn't install group key!!!!!!!!!!\n",__FUNCTION__);
@@ -1901,32 +1901,27 @@ _func_enter_;
 				//in concurrent we should use sw descrypt in group key, so we remove this message
 				//DBG_871X("rx bc/mc packets, to perform sw rtw_aes_decrypt\n");
 				//prwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
-				if(psecuritypriv->binstallGrpkey==_FALSE)
-				{
+				if(psecuritypriv->binstallGrpkey==false) {
 					res=_FAIL;
 					DBG_8192C("%s:rx bc/mc packets,but didn't install group key!!!!!!!!!!\n",__FUNCTION__);
 					goto exit;
 				}
 				prwskey = psecuritypriv->dot118021XGrpKey[prxattrib->key_index].skey;
 
-				if(psecuritypriv->dot118021XGrpKeyid != prxattrib->key_index)
-				{
+				if(psecuritypriv->dot118021XGrpKeyid != prxattrib->key_index) {
 					DBG_871X("not match packet_index=%d, install_index=%d \n"
 					, prxattrib->key_index, psecuritypriv->dot118021XGrpKeyid);
 					res=_FAIL;
 					goto exit;
 				}
-			}
-			else
-			{
+			} else {
 				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
 			}
 
 			length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
 
 			res= aes_decipher(prwskey,prxattrib->hdrlen,pframe, length);
-		}
-		else{
+		} else {
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_encrypt: stainfo==NULL!!!\n"));
 			res=_FAIL;
 		}
@@ -2825,7 +2820,7 @@ _func_enter_;
 
 	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler ^^^\n"));
 
-	padapter->securitypriv.busetkipkey=_TRUE;
+	padapter->securitypriv.busetkipkey=true;
 
 	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler padapter->securitypriv.busetkipkey=%d^^^\n",padapter->securitypriv.busetkipkey));
 
--- a/drivers/staging/rtl8192du/core/rtw_sreset.c
+++ b/drivers/staging/rtl8192du/core/rtw_sreset.c
@@ -27,7 +27,7 @@ void sreset_init_value(_adapter *padapte
 	struct sreset_priv *psrtpriv = &pHalData->srestpriv;
 
 	_rtw_mutex_init(&psrtpriv->silentreset_mutex);
-	psrtpriv->silent_reset_inprogress = _FALSE;
+	psrtpriv->silent_reset_inprogress = false;
 	psrtpriv->Wifi_Error_Status = WIFI_STATUS_SUCCESS;
 	psrtpriv->last_tx_time =0;
 	psrtpriv->last_tx_complete_time =0;
@@ -37,7 +37,7 @@ void sreset_reset_value(_adapter *padapt
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
 	struct sreset_priv *psrtpriv = &pHalData->srestpriv;
 
-	psrtpriv->silent_reset_inprogress = _FALSE;
+	psrtpriv->silent_reset_inprogress = false;
 	psrtpriv->Wifi_Error_Status = WIFI_STATUS_SUCCESS;
 	psrtpriv->last_tx_time =0;
 	psrtpriv->last_tx_complete_time =0;
@@ -51,7 +51,7 @@ u8 sreset_get_wifi_status(_adapter *pada
 	u8 status = WIFI_STATUS_SUCCESS;
 	u32 val32 = 0;
 	_irqL irqL;
-	if(psrtpriv->silent_reset_inprogress == _TRUE)
+	if(psrtpriv->silent_reset_inprogress == true)
         {
 		return status;
 	}
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -60,7 +60,7 @@ _func_enter_;
 
 	psta->capability = 0;
 
-	psta->bpairwise_key_installed = _FALSE;
+	psta->bpairwise_key_installed = false;
 
 
 #ifdef CONFIG_NATIVEAP_MLME
@@ -225,7 +225,7 @@ _func_enter_;
 	phead = get_list_head(&pstapriv->free_sta_queue);
 	plist = get_next(phead);
 
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info ,list);
 		plist = get_next(plist);
@@ -280,7 +280,7 @@ _func_enter_;
 			phead = &(pstapriv->sta_hash[index]);
 			plist = get_next(phead);
 
-			while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+			while ((rtw_end_of_queue_search(phead, plist)) == false)
 			{
 				int i;
 				psta = LIST_CONTAINOR(plist, struct sta_info ,hash_list);
@@ -327,7 +327,7 @@ _func_enter_;
 
 	_enter_critical_bh(&(pfree_sta_queue->lock), &irqL);
 
-	if (_rtw_queue_empty(pfree_sta_queue) == _TRUE)
+	if (_rtw_queue_empty(pfree_sta_queue) == true)
 	{
 		_exit_critical_bh(&(pfree_sta_queue->lock), &irqL);
 		psta = NULL;
@@ -397,7 +397,7 @@ _func_enter_;
 
 			preorder_ctrl->padapter = pstapriv->padapter;
 
-			preorder_ctrl->enable = _FALSE;
+			preorder_ctrl->enable = false;
 
 			preorder_ctrl->indicate_seq = 0xffff;
 			#ifdef DBG_RX_SEQ
@@ -636,7 +636,7 @@ _func_enter_;
 		phead = &(pstapriv->sta_hash[index]);
 		plist = get_next(phead);
 
-		while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+		while ((rtw_end_of_queue_search(phead, plist)) == false)
 		{
 			psta = LIST_CONTAINOR(plist, struct sta_info ,hash_list);
 
@@ -694,12 +694,12 @@ _func_enter_;
 	plist = get_next(phead);
 
 
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 
 		psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
-		if ((_rtw_memcmp(psta->hwaddr, addr, ETH_ALEN))== _TRUE)
+		if ((_rtw_memcmp(psta->hwaddr, addr, ETH_ALEN))== true)
 		{ // if found the matched address
 			break;
 		}
@@ -769,12 +769,12 @@ _func_exit_;
 
 u8 rtw_access_ctrl(_adapter *padapter, u8 *mac_addr)
 {
-	u8 res = _TRUE;
+	u8 res = true;
 #ifdef  CONFIG_AP_MODE
 	_irqL irqL;
 	_list	*plist, *phead;
 	struct rtw_wlan_acl_node *paclnode;
-	u8 match = _FALSE;
+	u8 match = false;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
 	_queue	*pacl_node_q =&pacl_list->acl_node_q;
@@ -782,16 +782,16 @@ u8 rtw_access_ctrl(_adapter *padapter, u
 	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
 		plist = get_next(plist);
 
 		if(_rtw_memcmp(paclnode->addr, mac_addr, ETH_ALEN))
 		{
-			if(paclnode->valid == _TRUE)
+			if(paclnode->valid == true)
 			{
-				match = _TRUE;
+				match = true;
 				break;
 			}
 		}
@@ -800,20 +800,12 @@ u8 rtw_access_ctrl(_adapter *padapter, u
 
 
 	if(pacl_list->mode == 1)//accept unless in deny list
-	{
-		res = (match == _TRUE) ?  _FALSE:_TRUE;
-	}
+		res = (match == true) ?  false:true;
 	else if(pacl_list->mode == 2)//deny unless in accept list
-	{
-		res = (match == _TRUE) ?  _TRUE:_FALSE;
-	}
+		res = (match == true) ?  true:false;
 	else
-	{
-		 res = _TRUE;
-	}
+		 res = true;
 
 #endif
-
 	return res;
-
 }
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ b/drivers/staging/rtl8192du/core/rtw_tdls.c
@@ -34,10 +34,10 @@ void rtw_reset_tdls_info(_adapter* padap
 {
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 
-	ptdlsinfo->ap_prohibited = _FALSE;
+	ptdlsinfo->ap_prohibited = false;
 	ptdlsinfo->setup_state = TDLS_STATE_NONE;
 	ptdlsinfo->sta_cnt = 0;
-	ptdlsinfo->sta_maximum = _FALSE;
+	ptdlsinfo->sta_maximum = false;
 	ptdlsinfo->macid_index= 6;
 	ptdlsinfo->clear_cam= 0;
 	ptdlsinfo->ch_sensing = 0;
@@ -166,7 +166,7 @@ s32 update_tdls_attrib(_adapter *padapte
 		pattrib->priority = 0;
 	}
 
-	if (psta->ieee8021x_blocked == _TRUE)
+	if (psta->ieee8021x_blocked == true)
 	{
 		pattrib->encrypt = 0;
 	}
@@ -217,11 +217,11 @@ s32 update_tdls_attrib(_adapter *padapte
 	}
 
 	if (pattrib->encrypt &&
-	    ((padapter->securitypriv.sw_encrypt == _TRUE) || (psecuritypriv->hw_decrypted == _FALSE)))
+	    ((padapter->securitypriv.sw_encrypt == true) || (psecuritypriv->hw_decrypted == false)))
 	{
-		pattrib->bswenc = _TRUE;
+		pattrib->bswenc = true;
 	} else {
-		pattrib->bswenc = _FALSE;
+		pattrib->bswenc = false;
 	}
 
 	//qos_en, ht_en, init rate, ,bw, ch_offset, sgi
@@ -231,12 +231,12 @@ s32 update_tdls_attrib(_adapter *padapte
 	pattrib->bwmode = psta->htpriv.bwmode;
 	pattrib->ch_offset = psta->htpriv.ch_offset;
 	pattrib->sgi= psta->htpriv.sgi;
-	pattrib->ampdu_en = _FALSE;
+	pattrib->ampdu_en = false;
 
 	//if(pattrib->ht_en && psta->htpriv.ampdu_enable)
 	//{
 	//	if(psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
-	//		pattrib->ampdu_en = _TRUE;
+	//		pattrib->ampdu_en = true;
 	//}
 
 exit:
@@ -257,13 +257,13 @@ void free_tdls_sta(_adapter *padapter, s
 	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 	if( ptdlsinfo->sta_cnt < (NUM_STA - 2) )	// -2: AP + BC/MC sta
 	{
-		ptdlsinfo->sta_maximum = _FALSE;
+		ptdlsinfo->sta_maximum = false;
 		_rtw_memset( &ptdlsinfo->ss_record, 0x00, sizeof(struct tdls_ss_record) );
 	}
 	//ready to clear cam
 	if(ptdls_sta->mac_id!=0){
 		ptdlsinfo->clear_cam=ptdls_sta->mac_id;
-		rtw_setstakey_cmd(padapter, (u8 *)ptdls_sta, _TRUE);
+		rtw_setstakey_cmd(padapter, (u8 *)ptdls_sta, true);
 	}
 
 	if(ptdlsinfo->sta_cnt==0){
@@ -294,7 +294,7 @@ void rtw_tdls_set_key(_adapter *adapter,
 	if(prx_pkt_attrib->encrypt)
 	{
 		ptdls_sta->dot118021XPrivacy=_AES_;
-		rtw_setstakey_cmd(adapter, (u8*)ptdls_sta, _TRUE);
+		rtw_setstakey_cmd(adapter, (u8*)ptdls_sta, true);
 	}
 }
 
@@ -315,13 +315,13 @@ void rtw_tdls_process_ht_cap(_adapter *a
 
 	if(ptdls_sta->flags & WLAN_STA_HT)
 	{
-		if(adapter->registrypriv.ht_enable == _TRUE)
+		if(adapter->registrypriv.ht_enable == true)
 		{
-			ptdls_sta->htpriv.ht_option = _TRUE;
+			ptdls_sta->htpriv.ht_option = true;
 		}
 		else
 		{
-			ptdls_sta->htpriv.ht_option = _FALSE;
+			ptdls_sta->htpriv.ht_option = false;
 			ptdls_sta->stat_code = _STATS_FAILURE_;
 		}
 	}
@@ -331,12 +331,12 @@ void rtw_tdls_process_ht_cap(_adapter *a
 	{
 		//check if sta supports rx ampdu
 		if(adapter->registrypriv.ampdu_enable==1)
-			ptdls_sta->htpriv.ampdu_enable = _TRUE;
+			ptdls_sta->htpriv.ampdu_enable = true;
 
 		//check if sta support s Short GI
 		if(ptdls_sta->htpriv.ht_cap.cap_info & cpu_to_le16(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))
 		{
-			ptdls_sta->htpriv.sgi = _TRUE;
+			ptdls_sta->htpriv.sgi = true;
 		}
 
 		// bwmode would still followed AP's setting
@@ -550,7 +550,7 @@ void issue_tdls_setup_req(_adapter *pada
 	static u8 dialogtoken = 0;
 	u32 timeout_interval= TPK_RESEND_COUNT * 1000;	//retry timer should set at least 301 sec, using TPK_count counting 301 times.
 
-	if(ptdlsinfo->ap_prohibited == _TRUE)
+	if(ptdlsinfo->ap_prohibited == true)
 		goto exit;
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
@@ -586,7 +586,7 @@ void issue_tdls_setup_req(_adapter *pada
 			_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 			if( ptdlsinfo->sta_cnt == (NUM_STA - 2) )	// -2: AP + BC/MC sta
 			{
-				ptdlsinfo->sta_maximum  = _TRUE;
+				ptdlsinfo->sta_maximum  = true;
 			}
 		}
 		else
@@ -992,9 +992,9 @@ void issue_tdls_ch_switch_rsp(_adapter *
 	pattrib->qsel=pattrib->priority;
 /*
 	_enter_critical_bh(&pxmitpriv->lock, &irqL);
-	if(xmitframe_enqueue_for_tdls_sleeping_sta(padapter, pmgntframe)==_TRUE){
+	if(xmitframe_enqueue_for_tdls_sleeping_sta(padapter, pmgntframe)==true){
 		_exit_critical_bh(&pxmitpriv->lock, &irqL);
-		return _FALSE;
+		return false;
 	}
 */
 	if(rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_RESPONSE) !=_SUCCESS ){
@@ -1032,7 +1032,7 @@ sint On_TDLS_Dis_Rsp(_adapter *adapter,
 		ptdls_sta->tdls_sta_state |= TDLS_ALIVE_STATE;
 
 		//Record the tdls sta with lowest signal strength
-		if( (ptdlsinfo->sta_maximum == _TRUE) && (ptdls_sta->alive_count >= 1) )
+		if( (ptdlsinfo->sta_maximum == true) && (ptdls_sta->alive_count >= 1) )
 		{
 			if( _rtw_memcmp(ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN) )
 			{
@@ -1052,7 +1052,7 @@ sint On_TDLS_Dis_Rsp(_adapter *adapter,
 	}
 	else
 	{
-		if( ptdlsinfo->sta_maximum == _TRUE)
+		if( ptdlsinfo->sta_maximum == true)
 		{
 			if( _rtw_memcmp( ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN ) )
 			{
@@ -1122,7 +1122,7 @@ sint On_TDLS_Setup_Req(_adapter *adapter
 			-PAYLOAD_TYPE_LEN
 			-FIXED_IE;
 
-	if(ptdlsinfo->ap_prohibited == _TRUE)
+	if(ptdlsinfo->ap_prohibited == true)
 	{
 		goto exit;
 	}
@@ -1192,7 +1192,7 @@ sint On_TDLS_Setup_Req(_adapter *adapter
 						ppairwise_cipher=prsnie+10;
 						_rtw_memcpy(&pairwise_count, (u16*)(ppairwise_cipher-2), 1);
 						for(k=0;k<pairwise_count;k++){
-							if(_rtw_memcmp( ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==_TRUE)
+							if(_rtw_memcmp( ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==true)
 								ccmp_have=1;
 						}
 						if(ccmp_have==0){
@@ -1221,7 +1221,7 @@ sint On_TDLS_Setup_Req(_adapter *adapter
 				case EID_BSSCoexistence:
 					break;
 				case _LINK_ID_IE_:
-					if(_rtw_memcmp(get_bssid(pmlmepriv), pIE->data, 6) == _FALSE)
+					if(_rtw_memcmp(get_bssid(pmlmepriv), pIE->data, 6) == false)
 					{
 						//not in the same BSS
 						ptdls_sta->stat_code=7;
@@ -1275,7 +1275,7 @@ sint On_TDLS_Setup_Req(_adapter *adapter
 		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 		if( ptdlsinfo->sta_cnt == (NUM_STA - 2) )	// -2: AP + BC/MC sta
 		{
-			ptdlsinfo->sta_maximum = _TRUE;
+			ptdlsinfo->sta_maximum = true;
 		}
 
 #ifdef CONFIG_WFD
@@ -1380,7 +1380,7 @@ sint On_TDLS_Setup_Rsp(_adapter *adapter
 				ppairwise_cipher=prsnie+10;
 				_rtw_memcpy(&pairwise_count, (u16*)(ppairwise_cipher-2), 2);
 				for(k=0;k<pairwise_count;k++){
-					if(_rtw_memcmp( ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==_TRUE)
+					if(_rtw_memcmp( ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==true)
 						verify_ccmp=1;
 				}
 			case _EXT_CAP_IE_:
@@ -1611,7 +1611,7 @@ sint On_TDLS_Dis_Req(_adapter *adapter,
 					goto exit;
 				}
 				dst = pIE->data + 12;
-				if( (MacAddr_isBcst(dst) == _FALSE) && (_rtw_memcmp(myid(&(adapter->eeprompriv)), dst, 6) == _FALSE) )
+				if( (MacAddr_isBcst(dst) == false) && (_rtw_memcmp(myid(&(adapter->eeprompriv)), dst, 6) == false) )
 				{
 					goto exit;
 				}
@@ -1716,7 +1716,7 @@ sint On_TDLS_Peer_Traffic_Rsp(_adapter *
 			xmitframe_plist = get_next(xmitframe_phead);
 
 			//transmit buffered frames
-			while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
+			while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
 			{
 				pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 				xmitframe_plist = get_next(xmitframe_plist);
@@ -1731,7 +1731,7 @@ sint On_TDLS_Peer_Traffic_Rsp(_adapter *
 					pxmitframe->attrib.eosp = 1;
 				}
 				//pxmitframe->attrib.triggered = 1;	//maybe doesn't need in TDLS
-				if(rtw_hal_xmit(adapter, pxmitframe) == _TRUE)
+				if(rtw_hal_xmit(adapter, pxmitframe) == true)
 				{
 					rtw_os_xmit_complete(adapter, pxmitframe);
 				}
@@ -1987,7 +1987,7 @@ void wfd_ie_tdls(_adapter * padapter, u8
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate( pmlmepriv, _FW_LINKED) == _TRUE )
+	if ( check_fwstate( pmlmepriv, _FW_LINKED) == true )
 	{
 		_rtw_memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
 	}
@@ -2876,11 +2876,9 @@ int update_sgi_tdls(_adapter *padapter,
 	psta_ht = &psta->htpriv;
 
 	if(psta_ht->ht_option)
-	{
 		return psta_ht->sgi;
-	}
 	else
-		return _FALSE;
+		return false;
 }
 
 u32 update_mask_tdls(_adapter *padapter, struct sta_info *psta)
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -81,10 +81,10 @@ int cckrates_included(unsigned char *rat
 	{
 		if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
 			   (((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )
-		return _TRUE;
+		return true;
 	}
 
-	return _FALSE;
+	return false;
 
 }
 
@@ -96,10 +96,10 @@ int cckratesonly_included(unsigned char
 	{
 		if  ( (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
 			   (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
-		return _FALSE;
+		return false;
 	}
 
-	return _TRUE;
+	return true;
 }
 
 unsigned char networktype_to_raid(unsigned char network_type)
@@ -162,11 +162,11 @@ int judge_network_type(_adapter *padapte
 			network_type = WIRELESS_11_24N;
 		}
 
-		if ((cckratesonly_included(rate, ratelen)) == _TRUE)
+		if ((cckratesonly_included(rate, ratelen)) == true)
 		{
 			network_type |= WIRELESS_11B;
 		}
-		else if((cckrates_included(rate, ratelen)) == _TRUE)
+		else if((cckrates_included(rate, ratelen)) == true)
 		{
 			network_type |= WIRELESS_11BG;
 		}
@@ -255,12 +255,12 @@ int is_basicrate(_adapter *padapter, uns
 		{
 			if (rate == ratetbl_val_2wifirate(val))
 			{
-				return _TRUE;
+				return true;
 			}
 		}
 	}
 
-	return _FALSE;
+	return false;
 }
 
 unsigned int ratetbl2rateset(_adapter *padapter, unsigned char *rateset);
@@ -286,7 +286,7 @@ unsigned int ratetbl2rateset(_adapter *p
 			default:
 				rate = ratetbl_val_2wifirate(rate);
 
-				if (is_basicrate(padapter, rate) == _TRUE)
+				if (is_basicrate(padapter, rate) == true)
 				{
 					rate |= IEEE80211_BASIC_RATE_MASK;
 				}
@@ -360,7 +360,7 @@ void UpdateBrateTblForSoftAP(u8 *bssrate
 
 void Save_DM_Func_Flag(_adapter *padapter)
 {
-	u8	bSaveFlag = _TRUE;
+	u8	bSaveFlag = true;
 
 #ifdef CONFIG_CONCURRENT_MODE
 	_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
@@ -374,7 +374,7 @@ void Save_DM_Func_Flag(_adapter *padapte
 
 void Restore_DM_Func_Flag(_adapter *padapter)
 {
-	u8	bSaveFlag = _FALSE;
+	u8	bSaveFlag = false;
 #ifdef CONFIG_CONCURRENT_MODE
 	_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 	if(pbuddy_adapter)
@@ -389,7 +389,7 @@ void Switch_DM_Func(_adapter *padapter,
 	_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 #endif
 
-	if(enable == _TRUE)
+	if(enable == true)
 	{
 #ifdef CONFIG_CONCURRENT_MODE
 		if(pbuddy_adapter)
@@ -610,7 +610,7 @@ int is_client_associated_to_ap(_adapter
 
 	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE))
 	{
-		return _TRUE;
+		return true;
 	}
 	else
 	{
@@ -625,7 +625,7 @@ int is_client_associated_to_ibss(_adapte
 
 	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))
 	{
-		return _TRUE;
+		return true;
 	}
 	else
 	{
@@ -647,7 +647,7 @@ int is_IBSS_empty(_adapter *padapter)
 		}
 	}
 
-	return _TRUE;
+	return true;
 
 }
 
@@ -761,7 +761,7 @@ void flush_all_cam_entry(_adapter *padap
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
 	//if(check_buddy_mlmeinfo_state(padapter, _HW_STATE_NOLINK_))
-	if(check_buddy_fwstate(padapter, _FW_LINKED) == _FALSE)
+	if(check_buddy_fwstate(padapter, _FW_LINKED) == false)
 	{
 		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);
 	}
@@ -784,10 +784,10 @@ void flush_all_cam_entry(_adapter *padap
 						cam_id = 4;
 				}
 				//clear_cam_entry(padapter, cam_id);
-				rtw_clearstakey_cmd(padapter, (u8*)psta, cam_id, _FALSE);
+				rtw_clearstakey_cmd(padapter, (u8*)psta, cam_id, false);
 			}
 		}
-		else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+		else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		{
 			//clear cam when ap free per sta_info
 		}
@@ -826,7 +826,7 @@ int WFD_info_handler(_adapter *padapter,
 		{
 			pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16( attr_content + 2 );
 			DBG_8192C( "[%s] Peer PORT NUM = %d\n", __FUNCTION__, pwdinfo->wfd_info->peer_rtsp_ctrlport );
-			return( _TRUE );
+			return( true );
 		}
 	}
 	else
@@ -853,7 +853,7 @@ int WMM_param_handler(_adapter *padapter
 
 	pmlmeinfo->WMM_enable = 1;
 	_rtw_memcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));
-	return _TRUE;
+	return true;
 
 	/*if (pregpriv->wifi_spec == 1)
 	{
@@ -866,7 +866,7 @@ int WMM_param_handler(_adapter *padapter
 		{
 			pmlmeinfo->WMM_enable = 1;
 			_rtw_rtw_memcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));
-			return _TRUE;
+			return true;
 		}
 	}
 	else
@@ -962,7 +962,7 @@ static void bwmode_update_check(_adapter
 	if(!pIE)
 		return;
 
-	if(phtpriv->ht_option == _FALSE)	return;
+	if(phtpriv->ht_option == false)	return;
 
 	if(pIE->Length > sizeof(struct HT_info_element))
 		return;
@@ -1005,7 +1005,7 @@ static void bwmode_update_check(_adapter
 
 	if((new_bwmode!= pmlmeext->cur_bwmode) || (new_ch_offset!=pmlmeext->cur_ch_offset))
 	{
-		pmlmeinfo->bwmode_updated = _TRUE;
+		pmlmeinfo->bwmode_updated = true;
 
 		pmlmeext->cur_bwmode = new_bwmode;
 		pmlmeext->cur_ch_offset = new_ch_offset;
@@ -1015,11 +1015,11 @@ static void bwmode_update_check(_adapter
 	}
 	else
 	{
-		pmlmeinfo->bwmode_updated = _FALSE;
+		pmlmeinfo->bwmode_updated = false;
 	}
 
 
-	if(_TRUE == pmlmeinfo->bwmode_updated)
+	if(true == pmlmeinfo->bwmode_updated)
 	{
 		struct sta_info *psta;
 		WLAN_BSSID_EX	*cur_network = &(pmlmeinfo->network);
@@ -1048,7 +1048,7 @@ static void bwmode_update_check(_adapter
 
 		}
 
-		//pmlmeinfo->bwmode_updated = _FALSE;//bwmode_updated done, reset it!
+		//pmlmeinfo->bwmode_updated = false;//bwmode_updated done, reset it!
 
 	}
 
@@ -1067,7 +1067,7 @@ void HT_caps_handler(_adapter *padapter,
 
 	if(pIE==NULL) return;
 
-	if(phtpriv->ht_option == _FALSE)	return;
+	if(phtpriv->ht_option == false)	return;
 
 	pmlmeinfo->HT_caps_enable = 1;
 
@@ -1153,7 +1153,7 @@ void HT_info_handler(_adapter *padapter,
 
 	if(pIE==NULL) return;
 
-	if(phtpriv->ht_option == _FALSE)	return;
+	if(phtpriv->ht_option == false)	return;
 
 
 	if(pIE->Length > sizeof(struct HT_info_element))
@@ -1270,14 +1270,14 @@ int check_ap_tdls_prohibited(u8 *pframe,
 
 	if(pkt_len < 5)
 	{
-		return _FALSE;
+		return false;
 	}
 
 	pframe += 4;
 	if( (*pframe) & tdls_prohibited_bit )
-		return _TRUE;
+		return true;
 
-	return _FALSE;
+	return false;
 }
 #endif //CONFIG_TDLS
 
@@ -1307,8 +1307,8 @@ void update_beacon_info(_adapter *padapt
 			break;
 #ifdef CONFIG_TDLS
 		case _EXT_CAP_IE_:
-			if( check_ap_tdls_prohibited(pIE->data, pIE->Length) == _TRUE )
-				ptdlsinfo->ap_prohibited = _TRUE;
+			if( check_ap_tdls_prohibited(pIE->data, pIE->Length) == true )
+				ptdlsinfo->ap_prohibited = true;
 			break;
 #endif //CONFIG_TDLS
 		default:
@@ -1368,14 +1368,14 @@ unsigned int is_ap_in_tkip(_adapter *pad
 				case _VENDOR_SPECIFIC_IE_:
 					if ((_rtw_memcmp(pIE->data, RTW_WPA_OUI, 4)) && (_rtw_memcmp((pIE->data + 12), WPA_TKIP_CIPHER, 4)))
 					{
-						return _TRUE;
+						return true;
 					}
 					break;
 
 				case _RSN_IE_2_:
 					if (_rtw_memcmp((pIE->data + 8), RSN_TKIP_CIPHER, 4))
 					{
-						return _TRUE;
+						return true;
 					}
 
 				default:
@@ -1385,11 +1385,11 @@ unsigned int is_ap_in_tkip(_adapter *pad
 			i += (pIE->Length + 2);
 		}
 
-		return _FALSE;
+		return false;
 	}
 	else
 	{
-		return _FALSE;
+		return false;
 	}
 
 }
@@ -1692,13 +1692,13 @@ void update_IOT_info(_adapter *padapter)
 			pmlmeinfo->turboMode_cts2self = 0;
 			pmlmeinfo->turboMode_rtsen = 1;
 			//disable high power
-			Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), _FALSE);
+			Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), false);
 			break;
 		case realtekAP:
 			//rtw_write16(padapter, 0x4cc, 0xffff);
 			//rtw_write16(padapter, 0x546, 0x01c0);
 			//disable high power
-			Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), _FALSE);
+			Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), false);
 			break;
 		default:
 			pmlmeinfo->turboMode_cts2self = 0;
@@ -1723,7 +1723,7 @@ void update_capinfo(PADAPTER Adapter, u1
 		{ // Short Preamble
 			if(pmlmeinfo->preamble_mode != PREAMBLE_SHORT) // PREAMBLE_LONG or PREAMBLE_AUTO
 			{
-				ShortPreamble = _TRUE;
+				ShortPreamble = true;
 				pmlmeinfo->preamble_mode = PREAMBLE_SHORT;
 				rtw_hal_set_hwreg( Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&ShortPreamble );
 			}
@@ -1732,7 +1732,7 @@ void update_capinfo(PADAPTER Adapter, u1
 		{ // Long Preamble
 			if(pmlmeinfo->preamble_mode != PREAMBLE_LONG)  // PREAMBLE_SHORT or PREAMBLE_AUTO
 			{
-				ShortPreamble = _FALSE;
+				ShortPreamble = false;
 				pmlmeinfo->preamble_mode = PREAMBLE_LONG;
 				rtw_hal_set_hwreg( Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&ShortPreamble );
 			}
@@ -1814,11 +1814,11 @@ void update_wireless_mode(_adapter *pada
 			network_type = WIRELESS_11_24N;
 		}
 
-		if ((cckratesonly_included(rate, ratelen)) == _TRUE)
+		if ((cckratesonly_included(rate, ratelen)) == true)
 		{
 			network_type |= WIRELESS_11B;
 		}
-		else if((cckrates_included(rate, ratelen)) == _TRUE)
+		else if((cckrates_included(rate, ratelen)) == true)
 		{
 			network_type |= WIRELESS_11BG;
 		}
@@ -1940,7 +1940,7 @@ void process_addba_req(_adapter *padapte
 		preorder_ctrl->indicate_seq = 0xffff;
 		#endif
 
-		preorder_ctrl->enable =(pmlmeinfo->bAcceptAddbaReq == _TRUE)? _TRUE :_FALSE;
+		preorder_ctrl->enable =(pmlmeinfo->bAcceptAddbaReq == true)? true :false;
 	}
 
 }
@@ -1979,13 +1979,13 @@ int rtw_handle_dualmac(_adapter *adapter
 
 	if (init) {
 		if ((dvobj->NumInterfaces == 2) && (adapter->registrypriv.mac_phy_mode != 1)) {
-			dvobj->DualMacMode = _TRUE;
+			dvobj->DualMacMode = true;
 			// temply disable IPS For 92D-VC
 			adapter->registrypriv.ips_mode = IPS_NONE;
 		}
 
 		/* For SMSP on 92DU-VC, driver do not probe another Interface. */
-		if ((dvobj->DualMacMode != _TRUE) && (dvobj->InterfaceNumber != 0)) {
+		if ((dvobj->DualMacMode != true) && (dvobj->InterfaceNumber != 0)) {
 			DBG_871X("%s(): Do not init another USB Interface because SMSP\n",__FUNCTION__);
 			status = _FAIL;
 			goto exit;
@@ -2004,13 +2004,13 @@ int rtw_handle_dualmac(_adapter *adapter
 
 		if (dvobj->InterfaceNumber == 0) {
 			//set adapter_type/iface type
-			adapter->isprimary = _TRUE;
+			adapter->isprimary = true;
 			adapter->adapter_type = PRIMARY_ADAPTER;
 			adapter->iface_type = IFACE_PORT0;
 			DBG_871X("%s(): PRIMARY_ADAPTER\n",__FUNCTION__);
 		} else {
 			//set adapter_type/iface type
-			adapter->isprimary = _FALSE;
+			adapter->isprimary = false;
 			adapter->adapter_type = SECONDARY_ADAPTER;
 			adapter->iface_type = IFACE_PORT1;
 			DBG_871X("%s(): SECONDARY_ADAPTER\n",__FUNCTION__);
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -170,7 +170,7 @@ _func_enter_;
 
 		pxmitbuf->priv_data = NULL;
 		pxmitbuf->padapter = padapter;
-		pxmitbuf->ext_tag = _FALSE;
+		pxmitbuf->ext_tag = false;
 
 /*
 		pxmitbuf->pallocated_buf = rtw_zmalloc(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ);
@@ -223,7 +223,7 @@ _func_enter_;
 
 		pxmitbuf->priv_data = NULL;
 		pxmitbuf->padapter = padapter;
-		pxmitbuf->ext_tag = _TRUE;
+		pxmitbuf->ext_tag = true;
 
 /*
 		pxmitbuf->pallocated_buf = rtw_zmalloc(MAX_XMIT_EXTBUF_SZ);
@@ -265,7 +265,7 @@ _func_enter_;
 	pxmitpriv->voq_cnt = 0;
 
 #ifdef CONFIG_XMIT_ACK
-	pxmitpriv->ack_tx = _FALSE;
+	pxmitpriv->ack_tx = false;
 	_rtw_mutex_init(&pxmitpriv->ack_tx_mutex);
 	rtw_sctx_init(&pxmitpriv->ack_tx_ops, 0);
 #endif
@@ -413,7 +413,7 @@ static void update_attrib_vcs_info(_adap
 	}
 	else
 	{
-		while (_TRUE)
+		while (true)
 		{
 #if 0 //Todo
 			//check IOT action
@@ -432,7 +432,7 @@ static void update_attrib_vcs_info(_adap
 #endif
 
 			//IOT action
-			if((pmlmeinfo->assoc_AP_vendor == atherosAP) && (pattrib->ampdu_en==_TRUE) &&
+			if((pmlmeinfo->assoc_AP_vendor == atherosAP) && (pattrib->ampdu_en==true) &&
 				(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_ ))
 			{
 				pattrib->vcs_mode = CTS_TO_SELF;
@@ -473,7 +473,7 @@ static void update_attrib_vcs_info(_adap
 			//to do list: check MIMO power save condition.
 
 			//check AMPDU aggregation for TXOP
-			if(pattrib->ampdu_en==_TRUE)
+			if(pattrib->ampdu_en==true)
 			{
 				pattrib->vcs_mode = RTS_CTS;
 				break;
@@ -505,16 +505,16 @@ static void update_attrib_phy_info(struc
 	pattrib->bwmode = psta->htpriv.bwmode;
 	pattrib->ch_offset = psta->htpriv.ch_offset;
 	pattrib->sgi= psta->htpriv.sgi;
-	pattrib->ampdu_en = _FALSE;
+	pattrib->ampdu_en = false;
 
 	//if(pattrib->ht_en && psta->htpriv.ampdu_enable)
 	//{
 	//	if(psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
-	//		pattrib->ampdu_en = _TRUE;
+	//		pattrib->ampdu_en = true;
 	//}
 
 
-	pattrib->retry_ctrl = _FALSE;
+	pattrib->retry_ctrl = false;
 
 }
 
@@ -603,8 +603,8 @@ static s32 update_attrib(_adapter *padap
 
 	pattrib->pctrl = 0;
 
-	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
 		_rtw_memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
 		_rtw_memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
 	}
@@ -676,7 +676,7 @@ static s32 update_attrib(_adapter *padap
 			res =_FAIL;
 			goto exit;
 		}
-		else if((check_fwstate(pmlmepriv, WIFI_AP_STATE)==_TRUE)&&(!(psta->state & _FW_LINKED)))
+		else if((check_fwstate(pmlmepriv, WIFI_AP_STATE)==true)&&(!(psta->state & _FW_LINKED)))
 		{
 			res =_FAIL;
 			goto exit;
@@ -727,17 +727,17 @@ static s32 update_attrib(_adapter *padap
 
 	//pattrib->priority = 5; //force to used VI queue, for testing
 
-	if (psta->ieee8021x_blocked == _TRUE)
+	if (psta->ieee8021x_blocked == true)
 	{
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\n psta->ieee8021x_blocked == _TRUE \n"));
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\n psta->ieee8021x_blocked == true \n"));
 
 		pattrib->encrypt = 0;
 
-		if((pattrib->ether_type != 0x888e) && (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _FALSE))
+		if((pattrib->ether_type != 0x888e) && (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false))
 		{
-			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\npsta->ieee8021x_blocked == _TRUE,  pattrib->ether_type(%.4x) != 0x888e\n",pattrib->ether_type));
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\npsta->ieee8021x_blocked == true,  pattrib->ether_type(%.4x) != 0x888e\n",pattrib->ether_type));
 			#ifdef DBG_TX_DROP_FRAME
-			DBG_871X("DBG_TX_DROP_FRAME %s psta->ieee8021x_blocked == _TRUE,  pattrib->ether_type(%.4x) != 0x888e\n", __FUNCTION__,pattrib->ether_type);
+			DBG_871X("DBG_TX_DROP_FRAME %s psta->ieee8021x_blocked == true,  pattrib->ether_type(%.4x) != 0x888e\n", __FUNCTION__,pattrib->ether_type);
 			#endif
 			res = _FAIL;
 			goto exit;
@@ -808,21 +808,21 @@ static s32 update_attrib(_adapter *padap
 		  pattrib->encrypt, padapter->securitypriv.sw_encrypt));
 
 	if (pattrib->encrypt &&
-	    ((padapter->securitypriv.sw_encrypt == _TRUE) || (psecuritypriv->hw_decrypted == _FALSE)))
+	    ((padapter->securitypriv.sw_encrypt == true) || (psecuritypriv->hw_decrypted == false)))
 	{
-		pattrib->bswenc = _TRUE;
+		pattrib->bswenc = true;
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,
-			 ("update_attrib: encrypt=%d securitypriv.hw_decrypted=%d bswenc=_TRUE\n",
+			 ("update_attrib: encrypt=%d securitypriv.hw_decrypted=%d bswenc=true\n",
 			  pattrib->encrypt, padapter->securitypriv.sw_encrypt));
 	} else {
-		pattrib->bswenc = _FALSE;
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("update_attrib: bswenc=_FALSE\n"));
+		pattrib->bswenc = false;
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("update_attrib: bswenc=false\n"));
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if((pattrib->encrypt && bmcast) || (pattrib->encrypt ==_WEP40_) || (pattrib->encrypt ==_WEP104_))
 	{
-		pattrib->bswenc = _TRUE;//force using sw enc.
+		pattrib->bswenc = true;//force using sw enc.
 	}
 #endif
 
@@ -876,7 +876,7 @@ _func_enter_;
 
 			if(bmcst)
 			{
-				if(_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16)==_TRUE){
+				if(_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16)==true){
 					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
 					//rtw_msleep_os(10);
 					return _FAIL;
@@ -886,7 +886,7 @@ _func_enter_;
 			}
 			else
 			{
-				if(_rtw_memcmp(&stainfo->dot11tkiptxmickey.skey[0],null_key, 16)==_TRUE){
+				if(_rtw_memcmp(&stainfo->dot11tkiptxmickey.skey[0],null_key, 16)==true){
 					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
 					//rtw_msleep_os(10);
 					return _FAIL;
@@ -1010,7 +1010,7 @@ s32 rtw_make_wlanhdr (_adapter *padapter
 	struct rtw_ieee80211_hdr *pwlanhdr = (struct rtw_ieee80211_hdr *)hdr;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
-	u8 qos_option = _FALSE;
+	u8 qos_option = false;
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	struct sta_priv		*pstapriv = &padapter->stapriv;
@@ -1043,7 +1043,7 @@ _func_enter_;
 
 	if (pattrib->subtype & WIFI_DATA_TYPE)
 	{
-		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == _TRUE)) {
+		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == true)) {
 			//to_ds = 1, fr_ds = 0;
 #ifdef CONFIG_TDLS
 			if((ptdlsinfo->setup_state == TDLS_LINKED_STATE)){
@@ -1073,10 +1073,10 @@ _func_enter_;
 			}
 
 			if (pqospriv->qos_option)
-				qos_option = _TRUE;
+				qos_option = true;
 
 		}
-		else if ((check_fwstate(pmlmepriv,  WIFI_AP_STATE) == _TRUE) ) {
+		else if ((check_fwstate(pmlmepriv,  WIFI_AP_STATE) == true) ) {
 			//to_ds = 0, fr_ds = 1;
 			SetFrDs(fctrl);
 			_rtw_memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
@@ -1084,16 +1084,16 @@ _func_enter_;
 			_rtw_memcpy(pwlanhdr->addr3, pattrib->src, ETH_ALEN);
 
 			if(psta->qos_option)
-				qos_option = _TRUE;
+				qos_option = true;
 		}
-		else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
+		else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
 			_rtw_memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
 			_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 			_rtw_memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
 
 			if(psta->qos_option)
-				qos_option = _TRUE;
+				qos_option = true;
 		}
 		else {
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("fw_state:%x is not allowed to xmit frame\n", get_fwstate(pmlmepriv)));
@@ -1144,11 +1144,11 @@ _func_enter_;
 				if(pattrib->ht_en && psta->htpriv.ampdu_enable)
 				{
 					if(psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
-					pattrib->ampdu_en = _TRUE;
+					pattrib->ampdu_en = true;
 				}
 
 				//re-check if enable ampdu by BA_starting_seqctrl
-				if(pattrib->ampdu_en == _TRUE)
+				if(pattrib->ampdu_en == true)
 				{
 					u16 tx_seq;
 
@@ -1158,19 +1158,19 @@ _func_enter_;
 					if(SN_LESS(pattrib->seqnum, tx_seq))
 					{
 						//DBG_871X("tx ampdu seqnum(%d) < tx_seq(%d)\n", pattrib->seqnum, tx_seq);
-						pattrib->ampdu_en = _FALSE;//AGG BK
+						pattrib->ampdu_en = false;//AGG BK
 					}
 					else if(SN_EQUAL(pattrib->seqnum, tx_seq))
 					{
 						psta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (tx_seq+1)&0xfff;
 
-						pattrib->ampdu_en = _TRUE;//AGG EN
+						pattrib->ampdu_en = true;//AGG EN
 					}
 					else
 					{
 						//DBG_871X("tx ampdu over run\n");
 						psta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (pattrib->seqnum+1)&0xfff;
-						pattrib->ampdu_en = _TRUE;//AGG EN
+						pattrib->ampdu_en = true;//AGG EN
 					}
 
 				}
@@ -1218,10 +1218,10 @@ s32 rtw_txframes_pending(_adapter *padap
 {
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
-	return ((_rtw_queue_empty(&pxmitpriv->be_pending) == _FALSE) ||
-			 (_rtw_queue_empty(&pxmitpriv->bk_pending) == _FALSE) ||
-			 (_rtw_queue_empty(&pxmitpriv->vi_pending) == _FALSE) ||
-			 (_rtw_queue_empty(&pxmitpriv->vo_pending) == _FALSE));
+	return ((_rtw_queue_empty(&pxmitpriv->be_pending) == false) ||
+			 (_rtw_queue_empty(&pxmitpriv->bk_pending) == false) ||
+			 (_rtw_queue_empty(&pxmitpriv->vi_pending) == false) ||
+			 (_rtw_queue_empty(&pxmitpriv->vo_pending) == false));
 }
 
 s32 rtw_txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib)
@@ -1687,7 +1687,7 @@ _func_enter_;
 
 		frg_inx++;
 
-		if (bmcst || (rtw_endofpktfile(&pktfile) == _TRUE))
+		if (bmcst || (rtw_endofpktfile(&pktfile) == true))
 		{
 			pattrib->nr_frags = frg_inx;
 
@@ -1716,7 +1716,7 @@ _func_enter_;
 
 	xmitframe_swencrypt(padapter, pxmitframe);
 
-	if(bmcst == _FALSE)
+	if(bmcst == false)
 		update_attrib_vcs_info(padapter, pxmitframe);
 	else
 		pattrib->vcs_mode = NONE_VCS;
@@ -1855,7 +1855,7 @@ _func_enter_;
 
 	_enter_critical(&pfree_queue->lock, &irqL);
 
-	if(_rtw_queue_empty(pfree_queue) == _TRUE) {
+	if(_rtw_queue_empty(pfree_queue) == true) {
 		pxmitbuf = NULL;
 	} else {
 
@@ -1934,7 +1934,7 @@ _func_enter_;
 
 	_enter_critical(&pfree_xmitbuf_queue->lock, &irqL);
 
-	if(_rtw_queue_empty(pfree_xmitbuf_queue) == _TRUE) {
+	if(_rtw_queue_empty(pfree_xmitbuf_queue) == true) {
 		pxmitbuf = NULL;
 	} else {
 
@@ -2050,7 +2050,7 @@ _func_enter_;
 
 	_enter_critical_bh(&pfree_xmit_queue->lock, &irqL);
 
-	if (_rtw_queue_empty(pfree_xmit_queue) == _TRUE) {
+	if (_rtw_queue_empty(pfree_xmit_queue) == true) {
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_alloc_xmitframe:%d\n", pxmitpriv->free_xmitframe_cnt));
 		pxframe =  NULL;
 	} else {
@@ -2159,7 +2159,7 @@ _func_enter_;
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
 
-	while (rtw_end_of_queue_search(phead, plist) == _FALSE)
+	while (rtw_end_of_queue_search(phead, plist) == false)
 	{
 
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
@@ -2195,7 +2195,7 @@ static struct xmit_frame *dequeue_one_xm
 	xmitframe_phead = get_list_head(pframe_queue);
 	xmitframe_plist = get_next(xmitframe_phead);
 
-	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
 	{
 		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
@@ -2268,7 +2268,7 @@ _func_enter_;
 		sta_phead = get_list_head(phwxmit->sta_queue);
 		sta_plist = get_next(sta_phead);
 
-		while ((rtw_end_of_queue_search(sta_phead, sta_plist)) == _FALSE)
+		while ((rtw_end_of_queue_search(sta_phead, sta_plist)) == false)
 		{
 
 			ptxservq= LIST_CONTAINOR(sta_plist, struct tx_servq, tx_pending);
@@ -2561,7 +2561,7 @@ int rtw_br_client_tx(_adapter *padapter,
 	struct sk_buff *skb = *pskb;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	_irqL irqL;
-	//if(check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == _TRUE)
+	//if(check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true)
 	{
 		void dhcp_flag_bcast(_adapter *priv, struct sk_buff *skb);
 		int res, is_vlan_tag=0, i, do_nat25=1;
@@ -2746,7 +2746,7 @@ static void do_queue_select(_adapter	*pa
 	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("### do_queue_select priority=%d ,qsel = %d\n",pattrib->priority ,qsel));
 
 #ifdef CONFIG_CONCURRENT_MODE
-//	if (check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == _TRUE)
+//	if (check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == true)
 //		qsel = 7;//
 #endif
 
@@ -2794,7 +2794,7 @@ s32 rtw_xmit(_adapter *padapter, _pkt **
 	rcu_read_unlock();
 #endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 
-	if( br_port	&& check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == _TRUE)
+	if( br_port	&& check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true)
 	{
 		res = rtw_br_client_tx(padapter, ppkt);
 		if (res == -1)
@@ -2823,7 +2823,7 @@ s32 rtw_xmit(_adapter *padapter, _pkt **
 
 #if defined(CONFIG_AP_MODE) || defined(CONFIG_TDLS)
 	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
-	if(xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == _TRUE)
+	if(xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == true)
 	{
 		_exit_critical_bh(&pxmitpriv->lock, &irqL0);
 		return 1;
@@ -2831,7 +2831,7 @@ s32 rtw_xmit(_adapter *padapter, _pkt **
 	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
 #endif
 
-	if (rtw_hal_xmit(padapter, pxmitframe) == _FALSE)
+	if (rtw_hal_xmit(padapter, pxmitframe) == false)
 		return 1;
 
 	return 0;
@@ -2840,7 +2840,7 @@ s32 rtw_xmit(_adapter *padapter, _pkt **
 #ifdef CONFIG_TDLS
 sint xmitframe_enqueue_for_tdls_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe)
 {
-	sint ret=_FALSE;
+	sint ret=false;
 
 	_irqL irqL;
 	struct sta_info *ptdls_sta=NULL;
@@ -2856,7 +2856,7 @@ sint xmitframe_enqueue_for_tdls_sleeping
 
 		if(pattrib->triggered==1)
 		{
-			ret = _TRUE;
+			ret = true;
 			return ret;
 			}
 
@@ -2900,7 +2900,7 @@ sint xmitframe_enqueue_for_tdls_sleeping
 				//transmit TDLS PTI via AP
 				rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_SD_PTI);
 			}
-			ret = _TRUE;
+			ret = true;
 
 		}
 
@@ -2917,7 +2917,7 @@ sint xmitframe_enqueue_for_tdls_sleeping
 sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe)
 {
 	_irqL irqL;
-	sint ret=_FALSE;
+	sint ret=false;
 	struct sta_info *psta=NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
@@ -2933,7 +2933,7 @@ sint xmitframe_enqueue_for_sleeping_sta(
 	}
 #endif //CONFIG_TDLS
 
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _FALSE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == false)
 	    return ret;
 
 	if(pattrib->psta)
@@ -2983,11 +2983,11 @@ sint xmitframe_enqueue_for_sleeping_sta(
 
 			//DBG_871X("enqueue, sq_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
 
-			update_beacon(padapter, _TIM_IE_, NULL, _FALSE);//tx bc/mc packets after upate bcn
+			update_beacon(padapter, _TIM_IE_, NULL, false);//tx bc/mc packets after upate bcn
 
 			//_exit_critical_bh(&psta->sleep_q.lock, &irqL);
 
-			ret = _TRUE;
+			ret = true;
 
 		}
 
@@ -3048,7 +3048,7 @@ sint xmitframe_enqueue_for_sleeping_sta(
 				{
 					//DBG_871X("sleepq_len==1, update BCNTIM\n");
 					//upate BCN for TIM IE
-					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+					update_beacon(padapter, _TIM_IE_, NULL, false);
 				}
 			}
 
@@ -3059,7 +3059,7 @@ sint xmitframe_enqueue_for_sleeping_sta(
 			//	wakeup_sta_to_xmit(padapter, psta);
 			//}
 
-			ret = _TRUE;
+			ret = true;
 
 		}
 
@@ -3083,7 +3083,7 @@ static void dequeue_xmitframes_to_sleepi
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
 
-	while (rtw_end_of_queue_search(phead, plist) == _FALSE)
+	while (rtw_end_of_queue_search(phead, plist) == false)
 	{
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 
@@ -3178,7 +3178,7 @@ void wakeup_sta_to_xmit(_adapter *padapt
 	xmitframe_phead = get_list_head(&psta->sleep_q);
 	xmitframe_plist = get_next(xmitframe_phead);
 
-	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
 	{
 		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
@@ -3231,7 +3231,7 @@ void wakeup_sta_to_xmit(_adapter *padapt
 		pxmitframe->attrib.triggered = 1;
 
 		_exit_critical_bh(&psta->sleep_q.lock, &irqL);
-		if(rtw_hal_xmit(padapter, pxmitframe) == _TRUE)
+		if(rtw_hal_xmit(padapter, pxmitframe) == true)
 		{
 			rtw_os_xmit_complete(padapter, pxmitframe);
 		}
@@ -3285,7 +3285,7 @@ void wakeup_sta_to_xmit(_adapter *padapt
 		xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
 		xmitframe_plist = get_next(xmitframe_phead);
 
-		while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
+		while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
 		{
 			pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
@@ -3303,7 +3303,7 @@ void wakeup_sta_to_xmit(_adapter *padapt
 			pxmitframe->attrib.triggered = 1;
 
 			_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
-			if(rtw_hal_xmit(padapter, pxmitframe) == _TRUE)
+			if(rtw_hal_xmit(padapter, pxmitframe) == true)
 			{
 				rtw_os_xmit_complete(padapter, pxmitframe);
 			}
@@ -3331,7 +3331,7 @@ void wakeup_sta_to_xmit(_adapter *padapt
 	if(update_mask)
 	{
 		//update_BCNTIM(padapter);
-		update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+		update_beacon(padapter, _TIM_IE_, NULL, false);
 	}
 
 }
@@ -3349,7 +3349,7 @@ void xmit_delivery_enabled_frames(_adapt
 	xmitframe_phead = get_list_head(&psta->sleep_q);
 	xmitframe_plist = get_next(xmitframe_phead);
 
-	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
 	{
 		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
@@ -3397,7 +3397,7 @@ void xmit_delivery_enabled_frames(_adapt
 
 		pxmitframe->attrib.triggered = 1;
 
-		if(rtw_hal_xmit(padapter, pxmitframe) == _TRUE)
+		if(rtw_hal_xmit(padapter, pxmitframe) == true)
 		{
 			rtw_os_xmit_complete(padapter, pxmitframe);
 		}
@@ -3416,7 +3416,7 @@ void xmit_delivery_enabled_frames(_adapt
 			//DBG_871X("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap);
 			//upate BCN for TIM IE
 			//update_BCNTIM(padapter);
-			update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
+			update_beacon(padapter, _TIM_IE_, NULL, false);
 			//update_mask = BIT(0);
 		}
 
@@ -3467,9 +3467,9 @@ bool rtw_sctx_chk_waring_status(int stat
 
 	case RTW_SCTX_DONE_DRV_STOP:
 	case RTW_SCTX_DONE_DEV_REMOVE:
-		return _TRUE;
+		return true;
 	default:
-		return _FALSE;
+		return false;
 	}
 }
 
--- a/drivers/staging/rtl8192du/hal/hal_com.c
+++ b/drivers/staging/rtl8192du/hal/hal_com.c
@@ -200,15 +200,15 @@ hal_com_get_channel_plan(
 	u8 swconfig;
 	u8 chnlplan;
 
-	swconfig = _TRUE;
+	swconfig = true;
 	if (!autoloadfail) {
 		if (!rtw_is_channel_plan_valid(sw_channel_plan))
-			swconfig = _FALSE;
+			swconfig = false;
 		if (hw_channel_plan & EEPROM_CHANNEL_PLAN_BY_HW_MASK)
-			swconfig = _FALSE;
+			swconfig = false;
 	}
 
-	if (swconfig == _TRUE)
+	if (swconfig == true)
 		chnlplan = sw_channel_plan;
 	else
 		chnlplan = hw_channel_plan & (~EEPROM_CHANNEL_PLAN_BY_HW_MASK);
--- a/drivers/staging/rtl8192du/hal/hal_intf.c
+++ b/drivers/staging/rtl8192du/hal/hal_intf.c
@@ -85,9 +85,9 @@ uint	 rtw_hal_init(_adapter *padapter)
 {
 	uint	status = _SUCCESS;
 
-	if(padapter->hw_init_completed == _TRUE)
+	if(padapter->hw_init_completed == true)
 	{
-		DBG_871X("rtw_hal_init: hw_init_completed == _TRUE\n");
+		DBG_871X("rtw_hal_init: hw_init_completed == true\n");
 		return status;
 	}
 #ifdef CONFIG_DEINIT_BEFORE_INIT
@@ -100,12 +100,12 @@ uint	 rtw_hal_init(_adapter *padapter)
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	// before init mac0, driver must init mac1 first to avoid usb rx error.
-	if((padapter->pbuddy_adapter != NULL) && (padapter->DualMacConcurrent == _TRUE)
+	if((padapter->pbuddy_adapter != NULL) && (padapter->DualMacConcurrent == true)
 		&& (padapter->adapter_type == PRIMARY_ADAPTER))
 	{
-		if(padapter->pbuddy_adapter->hw_init_completed == _TRUE)
+		if(padapter->pbuddy_adapter->hw_init_completed == true)
 		{
-			DBG_871X("rtw_hal_init: pbuddy_adapter hw_init_completed == _TRUE\n");
+			DBG_871X("rtw_hal_init: pbuddy_adapter hw_init_completed == true\n");
 		}
 		else
 		{
@@ -118,10 +118,10 @@ uint	 rtw_hal_init(_adapter *padapter)
 #endif
 			status =	padapter->HalFunc.hal_init(padapter->pbuddy_adapter);
 			if(status == _SUCCESS){
-				padapter->pbuddy_adapter->hw_init_completed = _TRUE;
+				padapter->pbuddy_adapter->hw_init_completed = true;
 			}
 			else{
-				padapter->pbuddy_adapter->hw_init_completed = _FALSE;
+				padapter->pbuddy_adapter->hw_init_completed = false;
 				RT_TRACE(_module_hal_init_c_,_drv_err_,("rtw_hal_init: hal__init fail(pbuddy_adapter)\n"));
 				return status;
 			}
@@ -132,7 +132,7 @@ uint	 rtw_hal_init(_adapter *padapter)
 	{
 		if (WARN_ON_ONCE(!padapter->pbuddy_adapter))
 			return _FAIL;
-		if(padapter->pbuddy_adapter->hw_init_completed == _FALSE)
+		if(padapter->pbuddy_adapter->hw_init_completed == false)
 		{
 #ifdef CONFIG_DEINIT_BEFORE_INIT
 			status = padapter->HalFunc.hal_deinit(padapter->pbuddy_adapter);
@@ -143,22 +143,22 @@ uint	 rtw_hal_init(_adapter *padapter)
 #endif
 			status = padapter->HalFunc.hal_init(padapter->pbuddy_adapter);
 			if(status == _SUCCESS){
-				padapter->pbuddy_adapter->hw_init_completed = _TRUE;
+				padapter->pbuddy_adapter->hw_init_completed = true;
 			}
 			else{
-				padapter->pbuddy_adapter->hw_init_completed = _FALSE;
+				padapter->pbuddy_adapter->hw_init_completed = false;
 				RT_TRACE(_module_hal_init_c_,_drv_err_,("rtw_hal_init: hal__init fail for another interface\n"));
 			}
 		}
 	}
 #endif
 
-	padapter->hw_init_completed=_FALSE;
+	padapter->hw_init_completed=false;
 
 	status = padapter->HalFunc.hal_init(padapter);
 
 	if(status == _SUCCESS){
-		padapter->hw_init_completed = _TRUE;
+		padapter->hw_init_completed = true;
 
 		if (padapter->registrypriv.notch_filter == 1)
 			rtw_hal_notch_filter(padapter, 1);
@@ -166,7 +166,7 @@ uint	 rtw_hal_init(_adapter *padapter)
 		rtw_hal_reset_security_engine(padapter);
 	}
 	else{
-		padapter->hw_init_completed = _FALSE;
+		padapter->hw_init_completed = false;
 		RT_TRACE(_module_hal_init_c_,_drv_err_,("rtw_hal_init: hal__init fail\n"));
 	}
 
@@ -185,7 +185,7 @@ _func_enter_;
 	status = padapter->HalFunc.hal_deinit(padapter);
 
 	if(status == _SUCCESS){
-		padapter->hw_init_completed = _FALSE;
+		padapter->hw_init_completed = false;
 	}
 	else
 	{
@@ -272,7 +272,7 @@ s32 rtw_hal_xmit(_adapter *padapter, str
 	if(padapter->HalFunc.hal_xmit)
 		return padapter->HalFunc.hal_xmit(padapter, pxmitframe);
 
-	return _FALSE;
+	return false;
 }
 
 s32	rtw_hal_mgnt_xmit(_adapter *padapter, struct xmit_frame *pmgntframe)
@@ -386,7 +386,7 @@ u8 rtw_hal_antdiv_before_linked(_adapter
 {
 	if (padapter->HalFunc.AntDivBeforeLinkHandler)
 		return padapter->HalFunc.AntDivBeforeLinkHandler(padapter);
-	return _FALSE;
+	return false;
 }
 
 void rtw_hal_antdiv_rssi_compared(_adapter *padapter, WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src)
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -38,12 +38,12 @@ CheckWriteH2C(
 )
 {
 	u8	valHMETFR;
-	bool	Result = _FALSE;
+	bool	Result = false;
 
 	valHMETFR = rtw_read8(Adapter, REG_HMETFR);
 
 	if(((valHMETFR>>BoxNum)&BIT0) == 1)
-		Result = _TRUE;
+		Result = true;
 
 	return Result;
 
@@ -56,14 +56,14 @@ CheckFwReadLastH2C(
 )
 {
 	u8	valHMETFR;
-	bool	 Result = _FALSE;
+	bool	 Result = false;
 
 	valHMETFR = rtw_read8(Adapter, REG_HMETFR);
 	//RT_TRACE(COMP_INIT,DBG_LOUD,("REG[%x] = %x\n",	REG_HMETFR, valHMETFR));
 
 	// Do not seperate to 91C and 88C, we use the same setting. Suggested by SD4 Filen. 2009.12.03.
 	if(((valHMETFR>>BoxNum)&BIT0) == 0)
-		Result = _TRUE;
+		Result = true;
 
 	return Result;
 }
@@ -94,8 +94,8 @@ static void _FillH2CCmd92D(_adapter* pad
 	u8	BoxContent[4], BoxExtContent[2];
 	u8	BufIndex=0;
 	u8	U1btmp; //Read 0x1bf
-	u8	bWriteSucess = _FALSE;
-	u8	IsFwRead = _FALSE;
+	u8	bWriteSucess = false;
+	u8	IsFwRead = false;
 	u8	WaitH2cLimmit = 100;
 	u8	WaitWriteH2cLimmit = 100;
 	u8	idx=0;
@@ -253,7 +253,7 @@ _func_enter_;
 
 		// 5. Normal chip does not need to check if the H2C cmd has be written successfully.
 		// 92D test chip does not need to check,
-		bWriteSucess = _TRUE;
+		bWriteSucess = true;
 
 		// Record the next BoxNum
 		pHalData->LastHMEBoxNum = BoxNum+1;
@@ -281,7 +281,7 @@ FillH2CCmd92D(
 
 	//Adapter = ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, TRUE);
 
-	if(Adapter->bFWReady == _FALSE)
+	if(Adapter->bFWReady == false)
 	{
 		DBG_8192C("FillH2CCmd92D(): return H2C cmd because of Fw download fail!!!\n");
 		return;
@@ -345,21 +345,21 @@ void rtl8192d_Add_RateATid(PADAPTER pAda
 
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 
-	if(pHalData->fw_ractrl == _TRUE)
+	if(pHalData->fw_ractrl == true)
 	{
 		rtl8192d_set_raid_cmd(pAdapter, bitmap, arg);
 	}
 	else
 	{
-		u8 macid, init_rate, shortGIrate=_FALSE;
+		u8 macid, init_rate, shortGIrate=false;
 
 		init_rate = get_highest_rate_idx(bitmap&0x0fffffff)&0x3f;
 
 		macid = arg&0x1f;
 
-		shortGIrate = (arg&BIT(5)) ? _TRUE:_FALSE;
+		shortGIrate = (arg&BIT(5)) ? true:false;
 
-		if (shortGIrate==_TRUE)
+		if (shortGIrate==true)
 			init_rate |= BIT(6);
 
 		rtw_write8(pAdapter, (REG_INIDATA_RATE_SEL+macid), (u8)init_rate);
@@ -696,7 +696,7 @@ void SetFwRsvdPagePkt(PADAPTER Adapter,
 	u16	BufIndex=0;
 	u32	TotalPacketLen;
 	u8	u1RsvdPageLoc[3]={0};
-	bool	bDLOK = _FALSE;
+	bool	bDLOK = false;
 
 	DBG_871X("%s\n", __FUNCTION__);
 
@@ -736,7 +736,7 @@ void SetFwRsvdPagePkt(PADAPTER Adapter,
 	//(2) ps-poll
 	ConstructPSPoll(Adapter, &ReservedPagePacket[BufIndex],&PSPollLength);
 
-	FillFakeTxDescriptor92D(Adapter, &ReservedPagePacket[BufIndex-TxDescLen], PSPollLength, _TRUE);
+	FillFakeTxDescriptor92D(Adapter, &ReservedPagePacket[BufIndex-TxDescLen], PSPollLength, true);
 
 	RT_PRINT_DATA(_module_rtl8712_cmd_c_, _drv_info_,
 		"SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: PS-POLL\n",
@@ -757,9 +757,9 @@ void SetFwRsvdPagePkt(PADAPTER Adapter,
 		&ReservedPagePacket[BufIndex],
 		&NullFunctionDataLength,
 		get_my_bssid(&(pmlmeinfo->network)),
-		_FALSE);
+		false);
 
-	FillFakeTxDescriptor92D(Adapter, &ReservedPagePacket[BufIndex-TxDescLen], NullFunctionDataLength, _FALSE);
+	FillFakeTxDescriptor92D(Adapter, &ReservedPagePacket[BufIndex-TxDescLen], NullFunctionDataLength, false);
 
 	SET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(u1RsvdPageLoc, PageNum);
 
@@ -779,9 +779,9 @@ void SetFwRsvdPagePkt(PADAPTER Adapter,
 		&ReservedPagePacket[BufIndex],
 		&ProbeRspLength,
 		get_my_bssid(&(pmlmeinfo->network)),
-		_FALSE);
+		false);
 
-	FillFakeTxDescriptor92D(Adapter, &ReservedPagePacket[BufIndex-TxDescLen], ProbeRspLength, _FALSE);
+	FillFakeTxDescriptor92D(Adapter, &ReservedPagePacket[BufIndex-TxDescLen], ProbeRspLength, false);
 
 	SET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(u1RsvdPageLoc, PageNum);
 
@@ -811,7 +811,7 @@ void SetFwRsvdPagePkt(PADAPTER Adapter,
 
 	rtw_hal_mgnt_xmit(Adapter, pmgntframe);
 
-	bDLOK = _TRUE;
+	bDLOK = true;
 
 	if(bDLOK)
 	{
@@ -829,7 +829,7 @@ void rtl8192d_set_FwJoinBssReport_cmd(_a
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	bool	bRecover = _FALSE;
+	bool	bRecover = false;
 
 _func_enter_;
 
@@ -858,7 +858,7 @@ _func_enter_;
 
 		// Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame.
 		if(pHalData->RegFwHwTxQCtrl&BIT6)
-			bRecover = _TRUE;
+			bRecover = true;
 		rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl&(~BIT6)));
 		pHalData->RegFwHwTxQCtrl &= (~BIT6);
 		SetFwRsvdPagePkt(padapter, 0);
@@ -1044,7 +1044,7 @@ int reset_tsf(PADAPTER Adapter, u8 reset
 		reset_cnt_after = rtw_read8(Adapter, reg_reset_tsf_cnt);
 	}
 
-	return(loop_cnt >= 10) ? _FAIL : _TRUE;
+	return(loop_cnt >= 10) ? _FAIL : true;
 }
 
 
@@ -1071,7 +1071,7 @@ _func_enter_;
 
 
 
-	if(pwrpriv->wowlan_mode ==_TRUE){
+	if(pwrpriv->wowlan_mode ==true){
 		//pause RX DMA
 		test = rtw_read8(padapter, REG_RXPKT_NUM+2);
 		test |= BIT(2);
@@ -1094,15 +1094,15 @@ _func_enter_;
 
 		pwowlan_parm.mode |=FW_WOWLAN_FUN_EN;
 		//printk("\n %s 1.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
-		if(pwrpriv->wowlan_pattern ==_TRUE){
+		if(pwrpriv->wowlan_pattern ==true){
 			pwowlan_parm.mode |= FW_WOWLAN_PATTERN_MATCH;
 		//printk("\n %s 2.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
 		}
-		if(pwrpriv->wowlan_magic ==_TRUE){
+		if(pwrpriv->wowlan_magic ==true){
 			//pwowlan_parm.mode |=FW_WOWLAN_MAGIC_PKT;
 		//printk("\n %s 3.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
 		}
-		if(pwrpriv->wowlan_unicast ==_TRUE){
+		if(pwrpriv->wowlan_unicast ==true){
 			pwowlan_parm.mode |=FW_WOWLAN_UNICAST;
 		//printk("\n %s 4.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
 		}
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -77,7 +77,7 @@ static void dm_DIGInit(
 	pDIG_T	pDM_DigTable = &pdmpriv->DM_DigTable;
 
 
-	pDM_DigTable->Dig_Enable_Flag = _TRUE;
+	pDM_DigTable->Dig_Enable_Flag = true;
 	pDM_DigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_MAX;
 
 	pDM_DigTable->CurIGValue = 0x20;
@@ -121,20 +121,20 @@ dm_DualMacGetParameterFromBuddyAdapter(
 	struct mlme_priv *pbuddy_mlmepriv = &(BuddyAdapter->mlmepriv);
 
 	if(pHalData->MacPhyMode92D != DUALMAC_SINGLEPHY)
-		return _FALSE;
+		return false;
 
 	if(BuddyAdapter == NULL)
-		return _FALSE;
+		return false;
 
 	if(pHalData->bSlaveOfDMSP)
-		return _FALSE;
+		return false;
 
 //sherry sync with 92C_92D, 20110701
 	if((check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) && (!check_fwstate(pmlmepriv, _FW_LINKED))
 		&& (!check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) ))
-		return _TRUE;
+		return true;
 	else
-		return _FALSE;
+		return false;
 }
 #endif
 
@@ -154,7 +154,7 @@ odm_FalseAlarmCounterStatistics_ForSlave
 	if(BuddyAdapter == NULL)
 		return;
 
-	if (Adapter->DualMacConcurrent == _FALSE)
+	if (Adapter->DualMacConcurrent == false)
 		return;
 
 	Buddydmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
@@ -279,7 +279,7 @@ odm_FalseAlarmCounterStatistics(
 	{
 		if(pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
-			if((pHalData->CurrentBandType92D == BAND_ON_2_4G) && pHalData->bMasterOfDMSP && (check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE))
+			if((pHalData->CurrentBandType92D == BAND_ON_2_4G) && pHalData->bMasterOfDMSP && (check_fwstate(pmlmepriv, _FW_LINKED) == false))
 			{
 				//before BB reset should do clock gated
 				rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
@@ -292,9 +292,9 @@ odm_FalseAlarmCounterStatistics(
 		}
 		else
 		{
-			if((pHalData->CurrentBandType92D == BAND_ON_2_4G) &&(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)
+			if((pHalData->CurrentBandType92D == BAND_ON_2_4G) &&(check_fwstate(pmlmepriv, _FW_LINKED) == false)
 #ifdef CONFIG_CONCURRENT_MODE
-				 && (check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == _FALSE)
+				 && (check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == false)
 #endif //CONFIG_CONCURRENT_MODE
 			)
 			{
@@ -308,7 +308,7 @@ odm_FalseAlarmCounterStatistics(
 			}
 		}
 	}
-	else if(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)
+	else if(check_fwstate(pmlmepriv, _FW_LINKED) == false)
 	{
 		//before BB reset should do clock gated
 		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
@@ -330,7 +330,7 @@ odm_FindMinimumRSSI_Dmsp(
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	s32	Rssi_val_min_back_for_mac0;
 	bool		bGetValueFromBuddyAdapter = dm_DualMacGetParameterFromBuddyAdapter(pAdapter);
-	bool		bRestoreRssi = _FALSE;
+	bool		bRestoreRssi = false;
 	PADAPTER	BuddyAdapter = pAdapter->pbuddy_adapter;
 	struct dm_priv	*Buddydmpriv;
 
@@ -349,7 +349,7 @@ odm_FindMinimumRSSI_Dmsp(
 				if(bGetValueFromBuddyAdapter)
 				{
 					//DBG_871X("get new RSSI\n");
-					bRestoreRssi = _TRUE;
+					bRestoreRssi = true;
 					Rssi_val_min_back_for_mac0 = pdmpriv->MinUndecoratedPWDBForDM;
 					pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->RssiValMinForAnotherMacOfDMSP;
 				}
@@ -360,7 +360,7 @@ odm_FindMinimumRSSI_Dmsp(
 
 	if(bRestoreRssi)
 	{
-		bRestoreRssi = _FALSE;
+		bRestoreRssi = false;
 		pdmpriv->MinUndecoratedPWDBForDM = Rssi_val_min_back_for_mac0;
 	}
 #endif
@@ -376,17 +376,17 @@ IN	PADAPTER	pAdapter
 	struct mlme_priv	*pmlmepriv = &pAdapter->mlmepriv;
 
 	//1 1.Determine the minimum RSSI
-	if((check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE) &&
+	if((check_fwstate(pmlmepriv, _FW_LINKED) == false) &&
 		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
 	{
 		pdmpriv->MinUndecoratedPWDBForDM = 0;
 		//RT_TRACE(COMP_BB_POWERSAVING, DBG_LOUD, ("Not connected to any \n"));
 	}
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	// Default port
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == true)	// Default port
 	{
-		if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE) ||
-			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
-			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
+		if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) ||
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
 		{
 			pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
 			//RT_TRACE(COMP_BB_POWERSAVING, DBG_LOUD, ("AP Client PWDB = 0x%x \n", pHalData->MinUndecoratedPWDBForDM));
@@ -462,7 +462,7 @@ DM_Write_DIG_DMSP(
 		//DBG_871X("DM_Write_DIG_DMSP(): mac 0 set mac 1 value \n");
 		if(pdmpriv->bWriteDigForAnotherMacOfDMSP)
 		{
-			pdmpriv->bWriteDigForAnotherMacOfDMSP = _FALSE;
+			pdmpriv->bWriteDigForAnotherMacOfDMSP = false;
 			PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, pdmpriv->CurDigValueForAnotherMacOfDMSP);
 			PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, 0x7f, pdmpriv->CurDigValueForAnotherMacOfDMSP);
 		}
@@ -480,7 +480,7 @@ DM_Write_DIG_DMSP(
 		 if(pHalData->bSlaveOfDMSP)
 		 {
 			//DBG_871X("DM_Write_DIG_DMSP(): slave case \n");
-			Buddydmpriv->bWriteDigForAnotherMacOfDMSP = _TRUE;
+			Buddydmpriv->bWriteDigForAnotherMacOfDMSP = true;
 			Buddydmpriv->CurDigValueForAnotherMacOfDMSP =  pDM_DigTable->CurIGValue;
 		 }
 		else
@@ -511,7 +511,7 @@ DM_Write_DIG(
 	//			pDM_DigTable->CurIGValue, pDM_DigTable->PreIGValue, pDM_DigTable->BackoffVal));
 	//DBG_871X("CurIGValue = 0x%x, PreIGValue = 0x%x\n", pDM_DigTable->CurIGValue, pDM_DigTable->PreIGValue);
 
-	if (pDM_DigTable->Dig_Enable_Flag == _FALSE)
+	if (pDM_DigTable->Dig_Enable_Flag == false)
 	{
 		//DBG_871X("DIG is disabled\n");
 		//pDM_DigTable->PreIGValue = 0x17;
@@ -544,8 +544,8 @@ static void odm_DIG(
 	static u8	DIG_Dynamic_MIN_0 = 0x25;
 	static u8	DIG_Dynamic_MIN_1 = 0x25;
 	u8	DIG_Dynamic_MIN;
-	static bool	bMediaConnect_0 = _FALSE;
-	static bool	bMediaConnect_1 = _FALSE;
+	static bool	bMediaConnect_0 = false;
+	static bool	bMediaConnect_1 = false;
 	bool		FirstConnect;
 	u8	TxRate = rtw_read8(pAdapter, REG_INIDATA_RATE_SEL);
 #ifdef CONFIG_CONCURRENT_MODE
@@ -564,13 +564,13 @@ static void odm_DIG(
 			if(pHalData->bMasterOfDMSP)
 			{
 				DIG_Dynamic_MIN = DIG_Dynamic_MIN_0;
-				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) && (bMediaConnect_0 == _FALSE);
+				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_0 == false);
 				//DBG_871X("bMediaConnect_0=%d,  pMgntInfo->bMediaConnect=%d\n", bMediaConnect_0, check_fwstate(pmlmepriv, _FW_LINKED));
 			}
 			else
 			{
 				DIG_Dynamic_MIN = DIG_Dynamic_MIN_1;
-				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) && (bMediaConnect_1 == _FALSE);
+				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_1 == false);
 				//DBG_871X("bMediaConnect_1=%d,  pMgntInfo->bMediaConnect=%d\n", bMediaConnect_1, check_fwstate(pmlmepriv, _FW_LINKED));
 			}
 			//DBG_871X("pHalData->CurrentBandType92D = %s\n",(pHalData->CurrentBandType92D==BAND_ON_2_4G)?"2.4G":"5G");
@@ -581,10 +581,10 @@ static void odm_DIG(
 			{
 				DIG_Dynamic_MIN = DIG_Dynamic_MIN_0;
 #ifdef CONFIG_CONCURRENT_MODE
-				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE ||check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == _TRUE
-				) && (bMediaConnect_0 == _FALSE);
+				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true ||check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true
+				) && (bMediaConnect_0 == false);
 #else
-				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) && (bMediaConnect_0 == _FALSE);
+				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_0 == false);
 #endif //CONFIG_CONCURRENT_MODE
 				//DBG_871X("bMediaConnect_5G=%d,  pMgntInfo->bMediaConnect=%d\n", bMediaConnect_0, check_fwstate(pmlmepriv, _FW_LINKED));
 			}
@@ -592,10 +592,10 @@ static void odm_DIG(
 			{
 				DIG_Dynamic_MIN = DIG_Dynamic_MIN_1;
 #ifdef CONFIG_CONCURRENT_MODE
-				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == _TRUE
-				) && (bMediaConnect_1 == _FALSE);
+				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true
+				) && (bMediaConnect_1 == false);
 #else
-				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) && (bMediaConnect_1 == _FALSE);
+				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_1 == false);
 #endif //CONFIG_CONCURRENT_MODE
 				//DBG_871X("bMediaConnect_2.4G=%d,  pMgntInfo->bMediaConnect=%d\n", bMediaConnect_1, check_fwstate(pmlmepriv, _FW_LINKED));
 			}
@@ -605,10 +605,10 @@ static void odm_DIG(
 	{
 		DIG_Dynamic_MIN = DIG_Dynamic_MIN_0;
 #ifdef CONFIG_CONCURRENT_MODE
-		FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == _TRUE
-		) && (bMediaConnect_0 == _FALSE);
+		FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true
+		) && (bMediaConnect_0 == false);
 #else
-		FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) && (bMediaConnect_0 == _FALSE);
+		FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_0 == false);
 #endif //CONFIG_CONCURRENT_MODE
 		//DBG_871X("bMediaConnect=%d,  pMgntInfo->bMediaConnect=%d\n", bMediaConnect_0, check_fwstate(pmlmepriv, _FW_LINKED));
 	}
@@ -624,7 +624,7 @@ static void odm_DIG(
 	//DBG_871X("RX Rate =  0x%x, TX Rate = 0x%x \n", pHalData->RxRate, TxRate);
 
 #ifndef CONFIG_CONCURRENT_MODE
-	if(pdmpriv->bDMInitialGainEnable == _FALSE)
+	if(pdmpriv->bDMInitialGainEnable == false)
 		return;
 #endif //CONFIG_CONCURRENT_MODE
 
@@ -651,9 +651,9 @@ static void odm_DIG(
 
 	//1 Boundary Decision
 #ifdef CONFIG_CONCURRENT_MODE
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == _TRUE)
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
 #else
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == true)
 #endif //CONFIG_CONCURRENT_MODE
 	{
 		//2 Get minimum RSSI value among associated devices
@@ -728,9 +728,9 @@ static void odm_DIG(
 
 	//1 Adjust initial gain by false alarm
 #ifdef CONFIG_CONCURRENT_MODE
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == _TRUE)
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
 #else
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == true)
 #endif //CONFIG_CONCURRENT_MODE
 	{
 		if(FirstConnect)
@@ -860,9 +860,9 @@ static void odm_DIG(
 	{
 		//for Use 2 path Tx to transmit MCS0~7 and legacy mode
 #ifdef CONFIG_CONCURRENT_MODE
-		if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == _TRUE)
+		if(check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
 #else
-		if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+		if(check_fwstate(pmlmepriv, _FW_LINKED) == true)
 #endif //CONFIG_CONCURRENT_MODE
 		{
 			if(pDM_DigTable->Rssi_val_min  <= 30)   //low rate 2T2R settings
@@ -953,7 +953,7 @@ static void dm_CCK_PacketDetectionThresh
 	struct dm_priv	*Buddydmpriv;
 
 
-	//if (pAdapter->DualMacSmartConcurrent == _FALSE)
+	//if (pAdapter->DualMacSmartConcurrent == false)
 	//	return;
 
 	if(pDM_DigTable->CurSTAConnectState == DIG_STA_CONNECT)
@@ -1005,7 +1005,7 @@ static void dm_CCK_PacketDetectionThresh
 				//if(IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
 					//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , bMaskByte2, 0xd3);
 			}
-			pdmpriv->bChangeCCKPDStateForAnotherMacOfDMSP = _FALSE;
+			pdmpriv->bChangeCCKPDStateForAnotherMacOfDMSP = false;
 		}
 	}
 
@@ -1052,7 +1052,7 @@ static void dm_CCK_PacketDetectionThresh
 		{
 			Buddydmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
 			DBG_871X("dm_CCK_PacketDetectionThresh_DMSP(): bslave case \n");
-			Buddydmpriv->bChangeCCKPDStateForAnotherMacOfDMSP = _TRUE;
+			Buddydmpriv->bChangeCCKPDStateForAnotherMacOfDMSP = true;
 			Buddydmpriv->CurCCKPDStateForAnotherMacOfDMSP = pDM_DigTable->CurCCKPDState;
 		}
 		else
@@ -1230,7 +1230,7 @@ static void dm_InitDynamicTxPower(IN	PAD
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
-	pdmpriv->bDynamicTxPowerEnable = _FALSE;
+	pdmpriv->bDynamicTxPowerEnable = false;
 
 	pdmpriv->LastDTPLvl = TxHighPwrLevel_Normal;
 	pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
@@ -1251,7 +1251,7 @@ static void odm_DynamicTxPower_92D(IN	PA
 #endif
 
 	// If dynamic high power is disabled.
-	if( (pdmpriv->bDynamicTxPowerEnable != _TRUE) ||
+	if( (pdmpriv->bDynamicTxPowerEnable != true) ||
 		(!(pdmpriv->DMFlag & DYNAMIC_FUNC_HP)) )
 	{
 		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
@@ -1259,7 +1259,7 @@ static void odm_DynamicTxPower_92D(IN	PA
 	}
 
 	// STA not connected and AP not connected
-	if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE) &&
+	if((check_fwstate(pmlmepriv, _FW_LINKED) != true) &&
 		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
 	{
 		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("Not connected to any \n"));
@@ -1272,11 +1272,11 @@ static void odm_DynamicTxPower_92D(IN	PA
 		return;
 	}
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	// Default port
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == true)	// Default port
 	{
 		//todo: AP Mode
-		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
-		       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
+		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+		       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
 		{
 			UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
 			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("AP Client PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
@@ -1342,7 +1342,7 @@ static void odm_DynamicTxPower_92D(IN	PA
 			pdmpriv->DynamicTxHighPowerLvl = pdmpriv->CurTxHighLvlForAnotherMacOfDMSP;
 			PHY_SetTxPowerLevel8192D(Adapter, pHalData->CurrentChannel);
 			pdmpriv->DynamicTxHighPowerLvl = HighPowerLvlBackForMac0;
-			pdmpriv->bChangeTxHighPowerLvlForAnotherMacOfDMSP = _FALSE;
+			pdmpriv->bChangeTxHighPowerLvlForAnotherMacOfDMSP = false;
 		}
 	}
 #endif
@@ -1351,7 +1351,7 @@ static void odm_DynamicTxPower_92D(IN	PA
 	{
 		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192D() Channel = %d \n" , pHalData->CurrentChannel));
 #ifdef CONFIG_DUALMAC_CONCURRENT
-		if(Adapter->DualMacConcurrent == _TRUE)
+		if(Adapter->DualMacConcurrent == true)
 		{
 			if(BuddyAdapter == NULL)
 			{
@@ -1370,7 +1370,7 @@ static void odm_DynamicTxPower_92D(IN	PA
 					{
 						DBG_871X("dm_DynamicTxPower() bslave case  \n");
 						pbuddy_dmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
-						pbuddy_dmpriv->bChangeTxHighPowerLvlForAnotherMacOfDMSP = _TRUE;
+						pbuddy_dmpriv->bChangeTxHighPowerLvlForAnotherMacOfDMSP = true;
 						pbuddy_dmpriv->CurTxHighLvlForAnotherMacOfDMSP = pdmpriv->DynamicTxHighPowerLvl;
 					}
 					else
@@ -1413,7 +1413,7 @@ static VOID PWDB_Monitor(
 	u32	PWDB_rssi[NUM_STA]={0};//[0~15]:MACID, [16~31]:PWDB_rssi
 
 
-	if(check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	if(check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
 	{
 		_irqL irqL;
 		_list	*plist, *phead;
@@ -1428,7 +1428,7 @@ static VOID PWDB_Monitor(
 			phead = &(pstapriv->sta_hash[i]);
 			plist = get_next(phead);
 
-			while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+			while ((rtw_end_of_queue_search(phead, plist)) == false)
 			{
 				psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
@@ -1454,7 +1454,7 @@ static VOID PWDB_Monitor(
 
 		_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 
-		if(pHalData->fw_ractrl == _TRUE)
+		if(pHalData->fw_ractrl == true)
 		{
 			// Report every sta's RSSI to FW
 			for(i=0; i< sta_cnt; i++)
@@ -1483,11 +1483,11 @@ static VOID PWDB_Monitor(
 		pdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
 	}
 
-	if(check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == _TRUE
-		&& check_fwstate(&Adapter->mlmepriv, _FW_LINKED) == _TRUE)
+	if(check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == true
+		&& check_fwstate(&Adapter->mlmepriv, _FW_LINKED) == true)
 	{
 		// Indicate Rx signal strength to FW.
-		if(pHalData->fw_ractrl == _TRUE)
+		if(pHalData->fw_ractrl == true)
 		{
 			u32	temp = 0;
 			//DBG_8192C("RxSS: %lx =%ld\n", pdmpriv->UndecoratedSmoothedPWDB, pdmpriv->UndecoratedSmoothedPWDB);
@@ -1521,8 +1521,8 @@ DM_InitEdcaTurbo(
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
-	pHalData->bCurrentTurboEDCA = _FALSE;
-	Adapter->recvpriv.bIsAnyNonBEPkts = _FALSE;
+	pHalData->bCurrentTurboEDCA = false;
+	Adapter->recvpriv.bIsAnyNonBEPkts = false;
 }	// DM_InitEdcaTurbo
 
 static void
@@ -1535,7 +1535,7 @@ dm_CheckEdcaTurbo(
 	u64	cur_tx_bytes = 0;
 	u64	cur_rx_bytes = 0;
 	u32	EDCA_BE[2] = {0x5ea42b, 0x5ea42b};
-	u8	bbtchange = _FALSE;
+	u8	bbtchange = false;
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv		*pdmpriv = &pHalData->dmpriv;
 	struct xmit_priv		*pxmitpriv = &(Adapter->xmitpriv);
@@ -1629,7 +1629,7 @@ dm_CheckEdcaTurbo(
 			pdmpriv->prv_traffic_idx = trafficIndex;
 		}
 
-		pHalData->bCurrentTurboEDCA = _TRUE;
+		pHalData->bCurrentTurboEDCA = true;
 	}
 	else
 	{
@@ -1640,13 +1640,13 @@ dm_CheckEdcaTurbo(
 		 if(pHalData->bCurrentTurboEDCA)
 		{
 			rtw_write32(Adapter, REG_EDCA_BE_PARAM, pHalData->AcParam_BE);
-			pHalData->bCurrentTurboEDCA = _FALSE;
+			pHalData->bCurrentTurboEDCA = false;
 		}
 	}
 
 dm_CheckEdcaTurbo_EXIT:
 	// Set variables for next time.
-	precvpriv->bIsAnyNonBEPkts = _FALSE;
+	precvpriv->bIsAnyNonBEPkts = false;
 	pxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;
 	precvpriv->last_rx_bytes = precvpriv->rx_bytes;
 
@@ -1676,7 +1676,7 @@ IN	PADAPTER	pAdapter
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	//s32			Rssi_val_min_back_for_mac0;
 	//bool		bGetValueFromBuddyAdapter = dm_DualMacGetParameterFromBuddyAdapter(pAdapter);
-	//bool		bRestoreRssi = _FALSE;
+	//bool		bRestoreRssi = false;
 	//PADAPTER	BuddyAdapter = pAdapter->pbuddy_adapter;
 #endif
 
@@ -1731,7 +1731,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 	s8			OFDM_index[2], CCK_index=0, OFDM_index_old[2], CCK_index_old=0;
 	s32			i = 0;
 	bool		is2T = IS_92D_SINGLEPHY(pHalData->VersionID);
-	bool		bInteralPA = _FALSE;
+	bool		bInteralPA = false;
 
 	u8			OFDM_min_index = 6, OFDM_min_index_internalPA = 12, rf; //OFDM BB Swing should be less than +3.0dB, which is required by Arthur
 	u8			Indexforchannel = rtl8192d_GetRightChnlPlaceforIQK(pHalData->CurrentChannel);
@@ -1772,12 +1772,12 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 //#endif
 
 	pdmpriv->TXPowerTrackingCallbackCnt++;	//cosa add for debug
-	pdmpriv->bTXPowerTrackingInit = _TRUE;
+	pdmpriv->bTXPowerTrackingInit = true;
 
 	if(pHalData->CurrentChannel == 14 && !pdmpriv->bCCKinCH14)
-		pdmpriv->bCCKinCH14 = _TRUE;
+		pdmpriv->bCCKinCH14 = true;
 	else if(pHalData->CurrentChannel != 14 && pdmpriv->bCCKinCH14)
-		pdmpriv->bCCKinCH14 = _FALSE;
+		pdmpriv->bCCKinCH14 = false;
 
 	//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("===>dm_TXPowerTrackingCallback_ThermalMeter_92D interface %d txpowercontrol %d\n", pHalData->interfaceIndex, pdmpriv->TxPowerTrackControl));
 
@@ -1837,7 +1837,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 				{
 					if(pdmpriv->bCCKinCH14)
 					{
-						if(_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch14[i][2], 4)==_TRUE)
+						if(_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch14[i][2], 4)==true)
 						{
 							CCK_index_old =(u8)i;
 							//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Initial reg0x%x = 0x%lx, CCK_index=0x%x, ch 14 %d\n",
@@ -1847,7 +1847,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 					}
 					else
 					{
-						if(_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch1_Ch13[i][2], 4)==_TRUE)
+						if(_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch1_Ch13[i][2], 4)==true)
 						{
 							CCK_index_old =(u8)i;
 							//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Initial reg0x%x = 0x%lx, CCK_index=0x%x, ch14 %d\n",
@@ -1904,8 +1904,8 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 		if(pdmpriv->bReloadtxpowerindex)
 		{
 			delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);
-			pdmpriv->bReloadtxpowerindex = _FALSE;
-			pdmpriv->bDoneTxpower = _FALSE;
+			pdmpriv->bReloadtxpowerindex = false;
+			pdmpriv->bDoneTxpower = false;
 		}
 		else if(pdmpriv->bDoneTxpower)
 		{
@@ -2071,7 +2071,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 			//Config by SwingTable
 			if(pdmpriv->TxPowerTrackControl && !pHalData->bNOPG)
 			{
-				pdmpriv->bDoneTxpower = _TRUE;
+				pdmpriv->bDoneTxpower = true;
 
 				//Adujst OFDM Ant_A according to IQK result
 				ele_D = (OFDMSwingTable[(u8)OFDM_index[0]] & 0xFFC00000)>>22;
@@ -2195,7 +2195,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 		}
 
 		if(delta_RxGain > 0 && pHalData->CurrentBandType92D == BAND_ON_5G
-			&& ThermalValue <= pHalData->EEPROMThermalMeter && pHalData->bNOPG == _FALSE)
+			&& ThermalValue <= pHalData->EEPROMThermalMeter && pHalData->bNOPG == false)
 		{
 			pdmpriv->ThermalValue_RxGain = ThermalValue;
 			dm_RXGainTrackingCallback_ThermalMeter_92D(Adapter);
@@ -2225,11 +2225,11 @@ dm_InitializeTXPowerTracking_ThermalMete
 
 	//if(IS_HARDWARE_TYPE_8192C(pHalData))
 	{
-		pdmpriv->bTXPowerTracking = _TRUE;
+		pdmpriv->bTXPowerTracking = true;
 		pdmpriv->TXPowercount = 0;
-		pdmpriv->bTXPowerTrackingInit = _FALSE;
+		pdmpriv->bTXPowerTrackingInit = false;
 #if	(MP_DRIVER != 1)		//for mp driver, turn off txpwrtracking as default
-		pdmpriv->TxPowerTrackControl = _TRUE;
+		pdmpriv->TxPowerTrackControl = true;
 #endif
 	}
 	MSG_8192C("pdmpriv->TxPowerTrackControl = %d\n", pdmpriv->TxPowerTrackControl);
@@ -2359,7 +2359,7 @@ dm_CheckRfCtrlGPIO(
 static void	dm_CheckPbcGPIO(IN PADAPTER padapter)
 {
 	u8	tmp1byte;
-	u8	bPbcPressed = _FALSE;
+	u8	bPbcPressed = false;
 	int i=0;
 
 	if(!padapter->registrypriv.hw_wps_pbc)
@@ -2383,20 +2383,20 @@ static void	dm_CheckPbcGPIO(IN PADAPTER
 
 	if (tmp1byte == 0xff)
 	{
-		bPbcPressed = _FALSE;
+		bPbcPressed = false;
 		break ;
 	}
 
 	if (tmp1byte&HAL_8192C_HW_GPIO_WPS_BIT)
 	{
-		bPbcPressed = _TRUE;
+		bPbcPressed = true;
 
 		if(i<=3)
 			rtw_msleep_os(50);
 	}
-	}while(i<=3 && bPbcPressed == _TRUE);
+	}while(i<=3 && bPbcPressed == true);
 
-	if( _TRUE == bPbcPressed)
+	if( true == bPbcPressed)
 	{
 		// Here we only set bPbcPressed to true
 		// After trigger PBC, the variable will be set to false
@@ -2425,9 +2425,9 @@ dm_InitRateAdaptiveMask(
 	pRA->PreRATRState = DM_RATR_STA_INIT;
 
 	if (pdmpriv->DM_Type == DM_Type_ByDriver)
-		pdmpriv->bUseRAMask = _TRUE;
+		pdmpriv->bUseRAMask = true;
 	else
-		pdmpriv->bUseRAMask = _FALSE;
+		pdmpriv->bUseRAMask = false;
 }
 
 
@@ -2515,7 +2515,7 @@ rtl8192d_InitHalDm(
 	//pdmpriv->UndecoratedSmoothedCCK = (-1);
 
 	//.1 DIG INIT
-	pdmpriv->bDMInitialGainEnable = _TRUE;
+	pdmpriv->bDMInitialGainEnable = true;
 	pdmpriv->DMFlag |= DYNAMIC_FUNC_DIG;
 	dm_DIGInit(Adapter);
 
@@ -2563,12 +2563,12 @@ static void FindMinimumRSSI(PADAPTER Ada
 	pbuddy_dmpriv = &pbuddy_HalData->dmpriv;
 
 	//get min. [PWDB] when both interfaces are connected
-	if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE
+	if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
 		&& Adapter->stapriv.asoc_sta_count > 2
 		&& check_buddy_fwstate(Adapter, _FW_LINKED)) ||
-		(check_buddy_fwstate(Adapter, WIFI_AP_STATE) == _TRUE
+		(check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true
 		&& pbuddy_adapter->stapriv.asoc_sta_count > 2
-		&& check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) ||
+		&& check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
 		(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
 		&& check_fwstate(pmlmepriv, _FW_LINKED)
 		&& check_buddy_fwstate(Adapter,WIFI_STATION_STATE)
@@ -2578,7 +2578,7 @@ static void FindMinimumRSSI(PADAPTER Ada
 		if(pdmpriv->UndecoratedSmoothedPWDB > pbuddy_dmpriv->UndecoratedSmoothedPWDB)
 			pdmpriv->UndecoratedSmoothedPWDB = pbuddy_dmpriv->UndecoratedSmoothedPWDB;
 	}//secondary interface is connected
-	else if((check_buddy_fwstate(Adapter, WIFI_AP_STATE) == _TRUE
+	else if((check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true
 		&& pbuddy_adapter->stapriv.asoc_sta_count > 2) ||
 		(check_buddy_fwstate(Adapter,WIFI_STATION_STATE)
 		&& check_buddy_fwstate(Adapter,_FW_LINKED)))
@@ -2587,7 +2587,7 @@ static void FindMinimumRSSI(PADAPTER Ada
 		pdmpriv->UndecoratedSmoothedPWDB = pbuddy_dmpriv->UndecoratedSmoothedPWDB;
 	}
 	//primary is connected
-	else if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE
+	else if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
 		&& Adapter->stapriv.asoc_sta_count > 2) ||
 		(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
 		&& check_fwstate(pmlmepriv, _FW_LINKED)))
@@ -2603,11 +2603,11 @@ static void FindMinimumRSSI(PADAPTER Ada
 	}
 
 	//primary interface is ap mode
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE && Adapter->stapriv.asoc_sta_count > 2)
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true && Adapter->stapriv.asoc_sta_count > 2)
 	{
 		pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
 	}//secondary interface is ap mode
-	else if(check_buddy_fwstate(Adapter, WIFI_AP_STATE) == _TRUE && pbuddy_adapter->stapriv.asoc_sta_count > 2)
+	else if(check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true && pbuddy_adapter->stapriv.asoc_sta_count > 2)
 	{
 		pdmpriv->EntryMinUndecoratedSmoothedPWDB = pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB;
 	}
@@ -2623,9 +2623,9 @@ rtl8192d_HalDmWatchDog(
 	IN	PADAPTER	Adapter
 	)
 {
-	bool		bFwCurrentInPSMode = _FALSE;
-	bool		bFwPSAwake = _TRUE;
-	u8 hw_init_completed = _FALSE;
+	bool		bFwCurrentInPSMode = false;
+	bool		bFwPSAwake = true;
+	u8 hw_init_completed = false;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 #ifdef CONFIG_CONCURRENT_MODE
@@ -2641,7 +2641,7 @@ rtl8192d_HalDmWatchDog(
 #endif
 
 	#if defined(CONFIG_CONCURRENT_MODE)
-	if (Adapter->isprimary == _FALSE && pbuddy_adapter) {
+	if (Adapter->isprimary == false && pbuddy_adapter) {
 		hw_init_completed = pbuddy_adapter->hw_init_completed;
 	} else
 	#endif
@@ -2649,7 +2649,7 @@ rtl8192d_HalDmWatchDog(
 		hw_init_completed = Adapter->hw_init_completed;
 	}
 
-	if (hw_init_completed == _FALSE)
+	if (hw_init_completed == false)
 		goto skip_dm;
 
 #ifdef CONFIG_LPS
@@ -2669,7 +2669,7 @@ rtl8192d_HalDmWatchDog(
 	// Fw is under p2p powersaving mode, driver should stop dynamic mechanism.
 	// modifed by thomas. 2011.06.11.
 	if(Adapter->wdinfo.p2p_ps_mode)
-		bFwPSAwake = _FALSE;
+		bFwPSAwake = false;
 #endif // CONFIG_P2P_PS
 
 	// Stop dynamic mechanism when:
@@ -2682,7 +2682,7 @@ rtl8192d_HalDmWatchDog(
 	// 4. RFChangeInProgress is TRUE. (Prevent from broken by IPS/HW/SW Rf off.)
 	// Noted by tynli. 2010.06.01.
 	//if(rfState == eRfOn)
-	if( (hw_init_completed == _TRUE)
+	if( (hw_init_completed == true)
 		&& ((!bFwCurrentInPSMode) && bFwPSAwake))
 	{
 		//
@@ -2738,7 +2738,7 @@ rtl8192d_HalDmWatchDog(
 		//
 		//TX power tracking will make 92de DMDP MAC0's throughput bad.
 #ifdef CONFIG_DUALMAC_CONCURRENT
-		if(!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == _FALSE)
+		if(!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
 #endif
 			rtl8192d_dm_CheckTXPowerTracking(Adapter);
 
@@ -2766,7 +2766,7 @@ rtl8192d_HalDmWatchDog(
 _record_initrate:
 
 		// Read REG_INIDATA_RATE_SEL value for TXDESC.
-		if(check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == _TRUE)
+		if(check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == true)
 		{
 			pdmpriv->INIDATA_RATE[0] = rtw_read8(Adapter, REG_INIDATA_RATE_SEL) & 0x3f;
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -35,7 +35,7 @@ atomic_t GlobalMutexForPowerOnAndPowerOf
 atomic_t GlobalMutexForFwDownload = ATOMIC_INIT(0);
 #ifdef CONFIG_DUALMAC_CONCURRENT
 atomic_t GlobalCounterForMutex = ATOMIC_INIT(0);
-bool GlobalFirstConfigurationForNormalChip = _TRUE;
+bool GlobalFirstConfigurationForNormalChip = true;
 #endif
 
 
@@ -44,7 +44,7 @@ _IsFWDownloaded(
 	PADAPTER			Adapter
 	)
 {
-	return ((rtw_read32(Adapter, REG_MCUFWDL) & MCUFWDL_RDY) ? _TRUE : _FALSE);
+	return ((rtw_read32(Adapter, REG_MCUFWDL) & MCUFWDL_RDY) ? true : false);
 }
 
 static VOID
@@ -378,7 +378,7 @@ int FirmwareDownload92D(
 	u32		FirmwareLen;
 	u8		value;
 	u32		count;
-	bool	 bFwDownloaded = _FALSE,bFwDownloadInProcess = _FALSE;
+	bool	 bFwDownloaded = false,bFwDownloadInProcess = false;
 
 	if(Adapter->bSurpriseRemoved){
 		return _FAIL;
@@ -401,7 +401,7 @@ int FirmwareDownload92D(
 	DBG_8192C(" ===> FirmwareDownload92D() fw:Rtl8192D_FwImageArray\n");
 
 	#ifdef CONFIG_FILE_FWIMG
-	if(rtw_is_file_readable(rtw_fw_file_path) == _TRUE)
+	if(rtw_is_file_readable(rtw_fw_file_path) == true)
 	{
 		DBG_871X("%s accquire FW from file:%s\n", __FUNCTION__, rtw_fw_file_path);
 		pFirmware->eFWSource = FW_SOURCE_IMG_FILE; // We should decided by Reg.
@@ -503,9 +503,9 @@ int FirmwareDownload92D(
 
 	bFwDownloaded = _IsFWDownloaded(Adapter);
 	if((rtw_read8(Adapter, 0x1f)&BIT5) == BIT5)
-		bFwDownloadInProcess = _TRUE;
+		bFwDownloadInProcess = true;
 	else
-		bFwDownloadInProcess = _FALSE;
+		bFwDownloadInProcess = false;
 	}
 
 	if(bFwDownloaded)
@@ -522,9 +522,9 @@ int FirmwareDownload92D(
 			ACQUIRE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 			bFwDownloaded = _IsFWDownloaded(Adapter);
 			if((rtw_read8(Adapter, 0x1f)&BIT5) == BIT5)
-				bFwDownloadInProcess = _TRUE;
+				bFwDownloadInProcess = true;
 			else
-				bFwDownloadInProcess = _FALSE;
+				bFwDownloadInProcess = false;
 			RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 			if(bFwDownloaded)
 				goto Exit;
@@ -556,7 +556,7 @@ int FirmwareDownload92D(
 		rtw_write8(Adapter, REG_MCUFWDL, 0x00);
 	}
 
-	_FWDownloadEnable(Adapter, _TRUE);
+	_FWDownloadEnable(Adapter, true);
 	fwdl_start_time = rtw_get_current_time();
 	while(1) {
 		//reset the FWDL chksum
@@ -574,7 +574,7 @@ int FirmwareDownload92D(
 			, rtw_get_passing_time_ms(fwdl_start_time)
 		);
 	}
-	_FWDownloadEnable(Adapter, _FALSE);
+	_FWDownloadEnable(Adapter, false);
 	if(_SUCCESS != rtStatus){
 		DBG_871X("DL Firmware failed!\n");
 		goto Exit;
@@ -617,9 +617,9 @@ InitializeFirmwareVars92D(
 	pwrpriv = &Adapter->pwrctrlpriv;
 
 	// Init Fw LPS related.
-	Adapter->pwrctrlpriv.bFwCurrentInPSMode = _FALSE;
+	Adapter->pwrctrlpriv.bFwCurrentInPSMode = false;
 
-	pwrpriv->bkeepfwalive = _TRUE;
+	pwrpriv->bkeepfwalive = true;
 	//Init H2C counter. by tynli. 2009.12.09.
 	pHalData->LastHMEBoxNum = 0;
 }
@@ -643,7 +643,7 @@ SetFwRelatedForWoWLAN8192DU(
 {
 	int	status=_FAIL;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
-	u8	 bRecover = _FALSE;
+	u8	 bRecover = false;
 
 	if(bHostIsGoingtoSleep)
 	{
@@ -807,7 +807,7 @@ hal_ReadPowerValueFromPROM92D(
 			pwrInfo->TSSI_A_5G[i] = EEPROM_Default_TSSI;
 			pwrInfo->TSSI_B_5G[i] = EEPROM_Default_TSSI;
 		}
-		pHalData->bNOPG = _TRUE;
+		pHalData->bNOPG = true;
 		return;
 	}
 
@@ -819,7 +819,7 @@ hal_ReadPowerValueFromPROM92D(
 			pwrInfo->CCKIndex[rfPath][group] =
 				(PROMContent[eeAddr] == 0xFF)?(eeAddr>0x7B?EEPROM_Default_TxPowerLevel_5G:EEPROM_Default_TxPowerLevel_2G):PROMContent[eeAddr];
 			if(PROMContent[eeAddr] == 0xFF)
-				pHalData->bNOPG = _TRUE;
+				pHalData->bNOPG = true;
 		}
 	}
 	for(rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
@@ -926,7 +926,7 @@ rtl8192d_ReadTxPowerInfo(
 		pHalData->CrystalCap = PROMContent[EEPROM_XTAL_K];
 		tempval[0] = PROMContent[EEPROM_IQK_DELTA]&0x03;
 		tempval[1] = (PROMContent[EEPROM_LCK_DELTA]&0x0C) >> 2;
-		pHalData->bTXPowerDataReadFromEEPORM = _TRUE;
+		pHalData->bTXPowerDataReadFromEEPORM = true;
 		if(IS_92D_D_CUT(pHalData->VersionID)||IS_92D_E_CUT(pHalData->VersionID))
 		{
 			pHalData->InternalPA5G[0] = !((PROMContent[EEPROM_TSSI_A_5G] & BIT6) >> 6);
@@ -954,24 +954,24 @@ rtl8192d_ReadTxPowerInfo(
 			case 0:
 				pHalData->EEPROMC9 = EEPROM_Default_externalPA_C9;
 				pHalData->EEPROMCC = EEPROM_Default_externalPA_CC;
-				pHalData->InternalPA5G[0] = _FALSE;
-				pHalData->InternalPA5G[1] = _FALSE;
+				pHalData->InternalPA5G[0] = false;
+				pHalData->InternalPA5G[1] = false;
 				break;
 
 			// internal pa - SP3T
 			case 1:
 				pHalData->EEPROMC9 = EEPROM_Default_internalPA_SP3T_C9;
 				pHalData->EEPROMCC = EEPROM_Default_internalPA_SP3T_CC;
-				pHalData->InternalPA5G[0] = _TRUE;
-				pHalData->InternalPA5G[1] = _TRUE;
+				pHalData->InternalPA5G[0] = true;
+				pHalData->InternalPA5G[1] = true;
 				break;
 
 			//intermal pa = SPDT
 			case 2:
 				pHalData->EEPROMC9 = EEPROM_Default_internalPA_SPDT_C9;
 				pHalData->EEPROMCC = EEPROM_Default_internalPA_SPDT_CC;
-				pHalData->InternalPA5G[0] = _TRUE;
-				pHalData->InternalPA5G[1] = _TRUE;
+				pHalData->InternalPA5G[0] = true;
+				pHalData->InternalPA5G[1] = true;
 				break;
 
 			default:
@@ -1112,12 +1112,12 @@ VOID rtl8192d_ResetDualMacSwitchVariable
 /*	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	PADAPTER		BuddyAdapter = Adapter->BuddyAdapter;
 
-	Adapter->bNeedReConfigMac = _FALSE;
-	Adapter->bNeedReConfigPhyRf = _FALSE;
-	Adapter->bNeedTurnOffAdapterInModeSwitchProcess = _FALSE;
-	Adapter->bNeedRecoveryAfterModeSwitch = _FALSE;
-	Adapter->bInModeSwitchProcess = _FALSE;
-	Adapter->bDoTurnOffPhyRf  = _FALSE;
+	Adapter->bNeedReConfigMac = false;
+	Adapter->bNeedReConfigPhyRf = false;
+	Adapter->bNeedTurnOffAdapterInModeSwitchProcess = false;
+	Adapter->bNeedRecoveryAfterModeSwitch = false;
+	Adapter->bInModeSwitchProcess = false;
+	Adapter->bDoTurnOffPhyRf  = false;
 
 	if(BuddyAdapter != NULL)
 	{
@@ -1167,7 +1167,7 @@ PHY_CheckPowerOffFor8192D(
 	{
 		u1bTmp = rtw_read8(Adapter, REG_MAC0);
 		rtw_write8(Adapter, REG_MAC0, u1bTmp&(~MAC0_ON));
-		return _TRUE;
+		return true;
 	}
 
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
@@ -1188,7 +1188,7 @@ PHY_CheckPowerOffFor8192D(
 	if(u1bTmp)
 	{
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
-		return _FALSE;
+		return false;
 	}
 
 	u1bTmp=rtw_read8(Adapter, REG_POWER_OFF_IN_PROCESS);
@@ -1196,7 +1196,7 @@ PHY_CheckPowerOffFor8192D(
 	rtw_write8(Adapter, REG_POWER_OFF_IN_PROCESS, u1bTmp);
 
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
-	return _TRUE;
+	return true;
 }
 
 
@@ -1276,7 +1276,7 @@ _func_enter_;
 	if(padapter->HalData)
 		rtw_mfree(padapter->HalData, sizeof(HAL_DATA_TYPE));
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	GlobalFirstConfigurationForNormalChip = _TRUE;
+	GlobalFirstConfigurationForNormalChip = true;
 #endif
 _func_exit_;
 }
@@ -1298,7 +1298,7 @@ rtl8192d_EfusePowerSwitch(
 	u8	tempval;
 	u16	tmpV16;
 
-	if (PwrState == _TRUE)
+	if (PwrState == true)
 	{
 		// 1.2V Power: From VDDON with Power Cut(0x0000h[15]), defualt valid
 		tmpV16 = rtw_read16(pAdapter, REG_SYS_ISO_CTRL);
@@ -1320,7 +1320,7 @@ rtl8192d_EfusePowerSwitch(
 			rtw_write16(pAdapter, REG_SYS_CLKR, tmpV16);
 		}
 
-		if(bWrite == _TRUE){
+		if(bWrite == true){
 			// Enable LDO 2.5V before read/write action
 			tempval = rtw_read8(pAdapter, EFUSE_TEST+3);
 			tempval &= 0x0F;
@@ -1330,7 +1330,7 @@ rtl8192d_EfusePowerSwitch(
 	}
 	else
 	{
-		if (bWrite == _TRUE) {
+		if (bWrite == true) {
 			// Disable LDO 2.5V after read/write action
 			tempval = rtw_read8(pAdapter, EFUSE_TEST+3);
 			rtw_write8(pAdapter, EFUSE_TEST+3, (tempval & 0x7F));
@@ -1522,8 +1522,8 @@ hal_EfuseUpdateNormalChipVersion_92D(
 	u8	CutValue[2];
 	u16	ChipValue=0;
 
-	ReadEFuseByte(Adapter,EEPROME_CHIP_VERSION_H,&CutValue[1], _FALSE);
-	ReadEFuseByte(Adapter,EEPROME_CHIP_VERSION_L,&CutValue[0], _FALSE);
+	ReadEFuseByte(Adapter,EEPROME_CHIP_VERSION_H,&CutValue[1], false);
+	ReadEFuseByte(Adapter,EEPROME_CHIP_VERSION_L,&CutValue[0], false);
 
 	ChipValue= (CutValue[1]<<8)|CutValue[0];
 	switch(ChipValue){
@@ -1558,28 +1558,28 @@ hal_EfuseMacMode_ISVS_92D(
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u8	PartNo;
-	bool bResult = _FALSE;
+	bool bResult = false;
 	// 92D VS not support dual mac mode
 	if(IS_NORMAL_CHIP92D(pHalData->VersionID))
 	{
-		ReadEFuseByte(Adapter,EEPROM_DEF_PART_NO,&PartNo, _FALSE);
+		ReadEFuseByte(Adapter,EEPROM_DEF_PART_NO,&PartNo, false);
 		//RT_TRACE(COMP_INIT, DBG_LOUD, ("92D efuse byte 1021 content :%d \n",PartNo));
 
 		if((((PartNo & 0xc0) ==  PARTNO_92D_NIC)&&((PartNo & 0x0c) == PARTNO_SINGLE_BAND_VS))||
 			(((PartNo & 0xF0) == PARTNO_92D_NIC_REMARK) &&((PartNo & 0x0F) == PARTNO_SINGLE_BAND_VS_REMARK)))
 		{
 			//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("92D VS !\n"));
-			bResult = _TRUE;
+			bResult = true;
 		}
 		else if(PartNo == 0x00)
 		{
-			ReadEFuseByte(Adapter,EEPROM_DEF_PART_NO+1,&PartNo, _FALSE);
+			ReadEFuseByte(Adapter,EEPROM_DEF_PART_NO+1,&PartNo, false);
 			//RT_TRACE(COMP_INIT, DBG_LOUD, ("92D efuse byte 1022 content :%d \n",PartNo));
 			if((((PartNo & 0xc0) ==  PARTNO_92D_NIC)&&((PartNo & 0x0c) == PARTNO_SINGLE_BAND_VS))||
 				(((PartNo & 0xF0) == PARTNO_92D_NIC_REMARK) &&((PartNo & 0x0F) == PARTNO_SINGLE_BAND_VS_REMARK)))
 			{
 				//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("92D VS !\n"));
-				bResult = _TRUE;
+				bResult = true;
 			}
 		}
 	}
@@ -1674,7 +1674,7 @@ rtl8192d_EfuseGetCurrentSize(
 	u8			efuseType,
 	bool		bPseudoTest)
 {
-	int	bContinual = _TRUE;
+	int	bContinual = true;
 
 	u16	efuse_addr = 0;
 	u8	hoffset=0,hworden=0;
@@ -1713,7 +1713,7 @@ rtl8192d_EfuseGetCurrentSize(
 		}
 		else
 		{
-			bContinual = _FALSE ;
+			bContinual = false ;
 		}
 	}
 
@@ -1729,8 +1729,8 @@ rtl8192d_Efuse_PgPacketRead(	PADAPTER	pA
 {
 	u8	ReadState = PG_STATE_HEADER;
 
-	int	bContinual = _TRUE;
-	int	bDataEmpty = _TRUE ;
+	int	bContinual = true;
+	int	bDataEmpty = true ;
 
 	u8	efuse_data,word_cnts=0;
 	u16	efuse_addr = 0;
@@ -1739,8 +1739,8 @@ rtl8192d_Efuse_PgPacketRead(	PADAPTER	pA
 	u8	tmpdata[8];
 	u8	tmp_header = 0;
 
-	if(data==NULL)	return _FALSE;
-	if(offset>=EFUSE_MAX_SECTION)		return _FALSE;
+	if(data==NULL)	return false;
+	if(offset>=EFUSE_MAX_SECTION)		return false;
 
 
 	_rtw_memset((PVOID)data, 0xff, sizeof(u8)*PGPKT_DATA_SIZE);
@@ -1783,18 +1783,18 @@ rtl8192d_Efuse_PgPacketRead(	PADAPTER	pA
 					hworden =  efuse_data & 0x0F;
 				}
 				word_cnts = Efuse_CalculateWordCnts(hworden);
-				bDataEmpty = _TRUE ;
+				bDataEmpty = true ;
 
 				if(hoffset==offset){
 					for(tmpidx = 0;tmpidx< word_cnts*2 ;tmpidx++){
 						if(efuse_OneByteRead(pAdapter, efuse_addr+1+tmpidx ,&efuse_data, bPseudoTest) ){
 							tmpdata[tmpidx] = efuse_data;
 							if(efuse_data!=0xff){
-								bDataEmpty = _FALSE;
+								bDataEmpty = false;
 							}
 						}
 					}
-					if(bDataEmpty==_FALSE){
+					if(bDataEmpty==false){
 						ReadState = PG_STATE_DATA;
 					}else{//read next header
 						efuse_addr = efuse_addr + (word_cnts*2)+1;
@@ -1808,7 +1808,7 @@ rtl8192d_Efuse_PgPacketRead(	PADAPTER	pA
 
 			}
 			else{
-				bContinual = _FALSE ;
+				bContinual = false ;
 			}
 		}
 		//-------  Data section Read -------------
@@ -1820,15 +1820,15 @@ rtl8192d_Efuse_PgPacketRead(	PADAPTER	pA
 		}
 
 	}
-	//efuse_reg_ctrl(pAdapter,_FALSE);//power off
+	//efuse_reg_ctrl(pAdapter,false);//power off
 
 	//RT_PRINT_DATA(COMP_EFUSE, DBG_LOUD, ("efuse_PgPacketRead-2\n"), data, 8);
 
 	if(	(data[0]==0xff) &&(data[1]==0xff) && (data[2]==0xff)  && (data[3]==0xff) &&
 		(data[4]==0xff) &&(data[5]==0xff) && (data[6]==0xff)  && (data[7]==0xff))
-		return _FALSE;
+		return false;
 	else
-		return _TRUE;
+		return true;
 
 }
 
@@ -1841,7 +1841,7 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 {
 	u8	WriteState = PG_STATE_HEADER;
 
-	int	bContinual = _TRUE,bDataEmpty=_TRUE, bResult = _TRUE;
+	int	bContinual = true,bDataEmpty=true, bResult = true;
 	u16	efuse_addr = 0;
 	u8	efuse_data;
 
@@ -1864,7 +1864,7 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 
 	static int	repeat_times = 0;
 
-	bool		bExtendedHeader = _FALSE;
+	bool		bExtendedHeader = false;
 	u8	efuseType=EFUSE_WIFI;
 
 	//
@@ -1877,7 +1877,7 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 	if( Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest) >= (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))
 	{
 		//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite error \n"));
-		return _FALSE;
+		return false;
 	}
 
 	// Init the 8 bytes content as 0xff
@@ -1892,7 +1892,7 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 	efuse_WordEnableDataRead(word_en, data, target_pkt.data);
 	target_word_cnts = Efuse_CalculateWordCnts(target_pkt.word_en);
 
-	//efuse_reg_ctrl(pAdapter,_TRUE);//power on
+	//efuse_reg_ctrl(pAdapter,true);//power on
 	//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE Power ON\n"));
 
 	//
@@ -1906,7 +1906,7 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 
 		if(WriteState==PG_STATE_HEADER)
 		{
-			bDataEmpty=_TRUE;
+			bDataEmpty=true;
 			badworden = 0x0F;
 			//************  so *******************
 			//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE PG_STATE_HEADER\n"));
@@ -1955,11 +1955,11 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 					for(tmpindex=0 ; tmpindex<(tmp_word_cnts*2) ; tmpindex++)
 					{
 						if(efuse_OneByteRead(pAdapter, (efuse_addr+1+tmpindex) ,&efuse_data, bPseudoTest)&&(efuse_data != 0xFF)){
-							bDataEmpty = _FALSE;
+							bDataEmpty = false;
 						}
 					}
 					//************  so-2-1 *******************
-					if(bDataEmpty == _FALSE)
+					if(bDataEmpty == false)
 					{
 						//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite section offset the same and data is NOT empty\n"));
 
@@ -2034,14 +2034,14 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 								target_pkt.word_en= tmp_word_en;
 								//===========================
 							}else{
-								bContinual = _FALSE;
+								bContinual = false;
 							}
 #if (EFUSE_ERROE_HANDLE == 1)
 							WriteState=PG_STATE_HEADER;
 							repeat_times++;
 							if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
-								bContinual = _FALSE;
-								bResult = _FALSE;
+								bContinual = false;
+								bResult = false;
 							}
 #endif
 						}
@@ -2062,7 +2062,7 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 			}
 			else		//************  s1: header == oxff  *******************
 			{
-				bExtendedHeader = _FALSE;
+				bExtendedHeader = false;
 
 				if(target_pkt.offset >= EFUSE_MAX_SECTION_BASE)
 				{
@@ -2080,8 +2080,8 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 						repeat_times++;
 
 						if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
-							bContinual = _FALSE;
-							bResult = _FALSE;
+							bContinual = false;
+							bResult = false;
 							efuse_addr++;
 							break;
 						}
@@ -2108,8 +2108,8 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 							repeat_times++;
 
 							if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
-								bContinual = _FALSE;
-								bResult = _FALSE;
+								bContinual = false;
+								bResult = false;
 								break;
 							}
 							efuse_OneByteWrite(pAdapter,efuse_addr, pg_header, bPseudoTest);
@@ -2124,8 +2124,8 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 							repeat_times++;
 
 							if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
-								bContinual = _FALSE;
-								bResult = _FALSE;
+								bContinual = false;
+								bResult = false;
 								break;
 							}
 							else
@@ -2136,7 +2136,7 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 						}
 						else if(pg_header != tmp_header)	//offset PG fail
 						{
-							bExtendedHeader = _TRUE;
+							bExtendedHeader = true;
 							tmp_pkt.offset = ((pg_header_temp & 0xE0) >> 5) | ((tmp_header & 0xF0) >> 1);
 							tmp_pkt.word_en=  tmp_header & 0x0F;
 							tmp_word_cnts =  Efuse_CalculateWordCnts(tmp_pkt.word_en);
@@ -2165,8 +2165,8 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 					WriteState = PG_STATE_HEADER;
 					repeat_times++;
 					if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
-						bContinual = _FALSE;
-						bResult = _FALSE;
+						bContinual = false;
+						bResult = false;
 					}
 				}
 #endif
@@ -2185,7 +2185,7 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 
 					if(Efuse_PgPacketRead( pAdapter, tmp_pkt.offset,originaldata, bPseudoTest))
 					{	//check if data exist
-						//efuse_reg_ctrl(pAdapter,_TRUE);//power on
+						//efuse_reg_ctrl(pAdapter,true);//power on
 						badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,tmp_pkt.word_en,originaldata, bPseudoTest);
 						//############################
 						if(0x0F != (badworden&0x0F))
@@ -2210,8 +2210,8 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 					WriteState=PG_STATE_HEADER;
 					repeat_times++;
 					if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
-						bContinual = _FALSE;
-						bResult = _FALSE;
+						bContinual = false;
+						bResult = false;
 					}
 #endif
 
@@ -2229,7 +2229,7 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 			badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,target_pkt.word_en,target_pkt.data , bPseudoTest);
 			if((badworden&0x0F)==0x0F)
 			{ //************  s1-1-A *******************
-				bContinual = _FALSE;
+				bContinual = false;
 			}
 			else
 			{//reorganize other pg packet //************  s1-1-B *******************
@@ -2244,8 +2244,8 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 				WriteState=PG_STATE_HEADER;
 				repeat_times++;
 				if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
-					bContinual = _FALSE;
-					bResult = _FALSE;
+					bContinual = false;
+					bResult = false;
 				}
 #endif
 				//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE PG_STATE_HEADER-3\n"));
@@ -2257,9 +2257,9 @@ rtl8192d_Efuse_PgPacketWrite(PADAPTER	pA
 	{
 		//RT_TRACE(COMP_EFUSE, DBG_LOUD, ("efuse_PgPacketWrite(): efuse_addr(%#x) Out of size!!\n", efuse_addr));
 	}
-	//efuse_reg_ctrl(pAdapter,_FALSE);//power off
+	//efuse_reg_ctrl(pAdapter,false);//power off
 
-	return _TRUE;
+	return true;
 }
 
 static u8
@@ -2343,9 +2343,9 @@ void hal_notch_filter_8192d(_adapter *ad
 
 static s32 c2h_id_filter_ccx_8192d(u8 id)
 {
-	s32 ret = _FALSE;
+	s32 ret = false;
 	if (id == C2H_CCX_TX_RPT)
-		ret = _TRUE;
+		ret = true;
 
 	return ret;
 }
--- a/drivers/staging/rtl8192du/hal/rtl8192d_mp.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_mp.c
@@ -278,15 +278,15 @@ s32 Hal_SetPowerTracking(PADAPTER padapt
 		return _FAIL;
 	}
 
-	if (check_fwstate(&padapter->mlmepriv, WIFI_MP_STATE) == _FALSE) {
+	if (check_fwstate(&padapter->mlmepriv, WIFI_MP_STATE) == false) {
 		RT_TRACE(_module_mp_, _drv_warning_, ("SetPowerTracking! Fail: not in MP mode!\n"));
 		return _FAIL;
 	}
 
 	if (enable)
-		pdmpriv->TxPowerTrackControl = _TRUE;
+		pdmpriv->TxPowerTrackControl = true;
 	else
-		pdmpriv->TxPowerTrackControl = _FALSE;
+		pdmpriv->TxPowerTrackControl = false;
 
 	return _SUCCESS;
 }
@@ -432,7 +432,7 @@ s32 Hal_SetThermalMeter(PADAPTER pAdapte
 		return _FAIL;
 	}
 
-	if (check_fwstate(&pAdapter->mlmepriv, WIFI_MP_STATE) == _FALSE) {
+	if (check_fwstate(&pAdapter->mlmepriv, WIFI_MP_STATE) == false) {
 		RT_TRACE(_module_mp_, _drv_warning_, ("SetThermalMeter: Fail! not in MP mode!\n"));
 		return _FAIL;
 	}
@@ -615,8 +615,8 @@ static  VOID Hal_mpt_StartCckContTx(PADA
     PHY_SetBBReg(pAdapter, rCCK0_System, bCCKBBMode, 0x2);    //transmit mode
     PHY_SetBBReg(pAdapter, rCCK0_System, bCCKScramble, 0x1);  //turn on scramble setting
 
-    pMptCtx->bCckContTx = _TRUE;
-    pMptCtx->bOfdmContTx = _FALSE;
+    pMptCtx->bCckContTx = true;
+    pMptCtx->bOfdmContTx = false;
 
 }   /* mpt_StartCckContTx */
 
@@ -628,8 +628,8 @@ static  VOID Hal_mpt_StopCckCoNtTx(PADAP
 
     u8          u1bReg;
 
-    pMptCtx->bCckContTx = _FALSE;
-    pMptCtx->bOfdmContTx = _FALSE;
+    pMptCtx->bCckContTx = false;
+    pMptCtx->bOfdmContTx = false;
 
     PHY_SetBBReg(pAdapter, rCCK0_System, bCCKBBMode, 0x0);    //normal mode
     PHY_SetBBReg(pAdapter, rCCK0_System, bCCKScramble, 0x1);  //turn on scramble setting
@@ -668,9 +668,9 @@ static  VOID Hal_mpt_StartOfdmContTx( PA
        PHY_SetBBReg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
        PHY_SetBBReg(pAdapter, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
 
-    pMptCtx->bCckContTx = _FALSE;
-    pMptCtx->bOfdmContTx = _TRUE;
-    //pMptCtx->bCtxTriggerPktSent = _FALSE;
+    pMptCtx->bCckContTx = false;
+    pMptCtx->bOfdmContTx = true;
+    //pMptCtx->bCtxTriggerPktSent = false;
 
 }   /* mpt_StartOfdmContTx */
 
@@ -682,8 +682,8 @@ static  VOID Hal_mpt_StopOfdmContTx( PAD
     u8          u1bReg;
     u32          data;
 
-    pMptCtx->bCckContTx = _FALSE;
-    pMptCtx->bOfdmContTx = _FALSE;
+    pMptCtx->bCckContTx = false;
+    pMptCtx->bOfdmContTx = false;
 
     PHY_SetBBReg(pAdapter, rOFDM1_LSTF, bOFDMContinueTx, bDisable);
     PHY_SetBBReg(pAdapter, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
@@ -706,16 +706,16 @@ void Hal_SetContinuousTx (PADAPTER pAdap
     { // Start Continuous Tx.
         if( pAdapter->mppriv.rateidx >= MPT_RATE_1M &&
             pAdapter->mppriv.rateidx <= MPT_RATE_11M )
-            Hal_mpt_StartCckContTx(pAdapter, _TRUE);
+            Hal_mpt_StartCckContTx(pAdapter, true);
         else if(pAdapter->mppriv.rateidx >= MPT_RATE_6M &&
                 pAdapter->mppriv.rateidx <= MPT_RATE_MCS15 )
             Hal_mpt_StartOfdmContTx(pAdapter);
         else
         {
-            //RT_ASSERT(_FALSE, ("MPT_ProSetUpContTx(): Unknown wireless rate index: %d\n", pMptCtx->MptRateIndex));
-            pMptCtx->bStartContTx = _FALSE;
-            pMptCtx->bCckContTx = _FALSE;
-            pMptCtx->bOfdmContTx = _FALSE;
+            //RT_ASSERT(false, ("MPT_ProSetUpContTx(): Unknown wireless rate index: %d\n", pMptCtx->MptRateIndex));
+            pMptCtx->bStartContTx = false;
+            pMptCtx->bCckContTx = false;
+            pMptCtx->bOfdmContTx = false;
         }
 
     }
@@ -724,15 +724,15 @@ void Hal_SetContinuousTx (PADAPTER pAdap
         bool bCckContTx = pMptCtx->bCckContTx;
         bool bOfdmContTx = pMptCtx->bOfdmContTx;
 
-        if(bCckContTx == _TRUE && bOfdmContTx == _FALSE)
+        if(bCckContTx == true && bOfdmContTx == false)
         { // Stop CCK Continuous Tx.
             Hal_mpt_StopCckCoNtTx(pAdapter);
         }
-        else if(bCckContTx == _FALSE && bOfdmContTx == _TRUE)
+        else if(bCckContTx == false && bOfdmContTx == true)
         { // Stop OFDM Continuous Tx.
             Hal_mpt_StopOfdmContTx(pAdapter);
         }
-        else if(bCckContTx == _FALSE && bOfdmContTx == _FALSE)
+        else if(bCckContTx == false && bOfdmContTx == false)
         { // We've already stopped Continuous Tx.
         }
         else
@@ -831,8 +831,8 @@ PHY_PowerDownAnotherPHY(
 {
 //	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u1Byte					u1bTmp;
-	u1Byte			MAC_REG = (bMac0==_TRUE)? REG_MAC1:REG_MAC0;
-	u1Byte			MAC_ON_BIT = (bMac0==_TRUE)? MAC1_ON:MAC0_ON;
+	u1Byte			MAC_REG = (bMac0==true)? REG_MAC1:REG_MAC0;
+	u1Byte			MAC_ON_BIT = (bMac0==true)? MAC1_ON:MAC0_ON;
 	u4Byte			MaskforPhySet = 0;
 
 	  // check MAC0 enable or not again now, if enabled, not power down radio A.
@@ -861,9 +861,9 @@ PHY_EnableAnotherPHY(
 	)
 {
 	u1Byte					u1bTmp;
-	u1Byte			MAC_REG = (bMac0==_TRUE)?REG_MAC1:REG_MAC0;
-	u1Byte			MAC_ON_BIT = bMac0==_TRUE?MAC1_ON:MAC0_ON;
-	bool			bResult = _TRUE; //true: need to enable BB/RF power
+	u1Byte			MAC_REG = (bMac0==true)?REG_MAC1:REG_MAC0;
+	u1Byte			MAC_ON_BIT = bMac0==true?MAC1_ON:MAC0_ON;
+	bool			bResult = true; //true: need to enable BB/RF power
 	//MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write.
 	 u1bTmp = _rtw_read8(Adapter, MAC_REG);
 
@@ -877,7 +877,7 @@ PHY_EnableAnotherPHY(
 		_rtw_write16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet, _rtw_read16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet)|BIT13|BIT0|BIT1);
 	} else {
 		// We think if MAC1 is ON,then radio_a.txt and radio_b.txt has been load.
-		bResult = _FALSE;
+		bResult = false;
 	}
 	return bResult;
 }
@@ -1008,7 +1008,7 @@ VOID
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
 	u8		path = pHalData->CurrentBandType92D == BAND_ON_5G?RF_PATH_A:RF_PATH_B;
 	u8		index = 0,	i = 0, eRFPath = RF_PATH_A;
-	bool		bNeedPowerDownRadio = _FALSE, bInteralPA = _FALSE;
+	bool		bNeedPowerDownRadio = false, bInteralPA = false;
 	u32		u4RegValue = 0, mask = 0x1C000, value = 0, u4tmp, u4tmp2,MaskforPhySet=0;
 	//Query regB30 bit27
 	u32		Regb30 = PHY_QueryBBReg(Adapter, 0xb30, BIT27);
@@ -1041,7 +1041,7 @@ VOID
 
 		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
 		{
-			bNeedPowerDownRadio = PHY_EnableAnotherPHY(Adapter, _FALSE);
+			bNeedPowerDownRadio = PHY_EnableAnotherPHY(Adapter, false);
 			MaskforPhySet = MAC1_ACCESS_PHY0;
 			//asume no this case
 			if(bNeedPowerDownRadio)
@@ -1053,7 +1053,7 @@ VOID
 		{
 			//RT_TRACE(COMP_MLME, DBG_LOUD, ("===============phy_SwitchRfSetting8192D interface %ld,B30&BIT27=1!!!!\n", Adapter->interfaceIndex));
 
-			bNeedPowerDownRadio = PHY_EnableAnotherPHY(Adapter, _TRUE);
+			bNeedPowerDownRadio = PHY_EnableAnotherPHY(Adapter, true);
 			MaskforPhySet= MAC0_ACCESS_PHY1;
 			//asume no this case
 			if(bNeedPowerDownRadio)
@@ -1103,7 +1103,7 @@ VOID
 			{
 				phy_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
-			PHY_PowerDownAnotherPHY(Adapter, _FALSE);
+			PHY_PowerDownAnotherPHY(Adapter, false);
 		}
 
 		if(Regb30 && pHalData->interfaceIndex == 0)
@@ -1112,7 +1112,7 @@ VOID
 			{
 				phy_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
-			PHY_PowerDownAnotherPHY(Adapter, _TRUE);
+			PHY_PowerDownAnotherPHY(Adapter, true);
 		}
 
 		if(channel < 149)
@@ -1172,7 +1172,7 @@ VOID
 			path = RF_PATH_A;
 			if(pHalData->interfaceIndex == 0)
 			{
-				bNeedPowerDownRadio = PHY_EnableAnotherPHY(Adapter, _TRUE);
+				bNeedPowerDownRadio = PHY_EnableAnotherPHY(Adapter, true);
 				MaskforPhySet = MAC0_ACCESS_PHY1;
 				if(bNeedPowerDownRadio)
 					phy_EnableRFENV(Adapter, path,MaskforPhySet,&u4RegValue);
@@ -1183,7 +1183,7 @@ VOID
 			{
 				//RT_TRACE(COMP_MLME, DBG_LOUD, ("===============phy_SwitchRfSetting8192D interface %ld,B30&BIT27=1!!!!\n", Adapter->interfaceIndex));
 
-				bNeedPowerDownRadio = PHY_EnableAnotherPHY(Adapter, _FALSE);
+				bNeedPowerDownRadio = PHY_EnableAnotherPHY(Adapter, false);
 				MaskforPhySet= MAC1_ACCESS_PHY0;
 				//asume no this case
 				if(bNeedPowerDownRadio)
@@ -1221,7 +1221,7 @@ VOID
 			if(bNeedPowerDownRadio){
 				phy_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
-			PHY_PowerDownAnotherPHY(Adapter, _TRUE);
+			PHY_PowerDownAnotherPHY(Adapter, true);
 		}
 
 		if(Regb30 && pHalData->interfaceIndex == 1)
@@ -1230,7 +1230,7 @@ VOID
 			{
 				phy_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
-			PHY_PowerDownAnotherPHY(Adapter, _FALSE);
+			PHY_PowerDownAnotherPHY(Adapter, false);
 		}
 	}
 
@@ -1247,7 +1247,7 @@ void Hal_mpt_SwitchRfSetting(PADAPTER pA
 	u8 ulRateIdx = pmp->rateidx;
 	u8 ulbandwidth = pmp->bandwidth;
 	PMPT_CONTEXT	pMptCtx = &(pAdapter->mppriv.MptCtx);
-    bool             bInteralPA = _FALSE;
+    bool             bInteralPA = false;
     u32				value = 0;
     phy_SwitchRfSetting8192D(pAdapter,ChannelToSw);
 #if 0
@@ -1407,11 +1407,11 @@ void Hal_SetChannel(PADAPTER pAdapter)
 	SelectChannel(pAdapter, channel);
 
 	if (pHalData->CurrentChannel == 14 && !pHalData->dmpriv.bCCKinCH14) {
-		pHalData->dmpriv.bCCKinCH14 = _TRUE;
+		pHalData->dmpriv.bCCKinCH14 = true;
 		MPT_CCKTxPowerAdjust(pAdapter, pHalData->dmpriv.bCCKinCH14);
 	}
 	else if (pHalData->CurrentChannel != 14 && pHalData->dmpriv.bCCKinCH14) {
-		pHalData->dmpriv.bCCKinCH14 = _FALSE;
+		pHalData->dmpriv.bCCKinCH14 = false;
 		MPT_CCKTxPowerAdjust(pAdapter, pHalData->dmpriv.bCCKinCH14);
 	}
 
@@ -1551,7 +1551,7 @@ void Hal_SetOFDMContinuousTx(PADAPTER pA
 		write_bbreg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
 	}
 
-	pAdapter->mppriv.MptCtx.bCckContTx = _FALSE;
+	pAdapter->mppriv.MptCtx.bCckContTx = false;
 	pAdapter->mppriv.MptCtx.bOfdmContTx = bStart;
 }/* mpt_StartOfdmContTx */
 
@@ -1613,7 +1613,7 @@ void Hal_SetCCKContinuousTx(PADAPTER pAd
 	}
 
 	pAdapter->mppriv.MptCtx.bCckContTx = bStart;
-	pAdapter->mppriv.MptCtx.bOfdmContTx = _FALSE;
+	pAdapter->mppriv.MptCtx.bOfdmContTx = false;
 }/* mpt_StartCckContTx */
 
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
@@ -906,7 +906,7 @@ phy_InitBBRFRegisterDefinition(
 	pHalData->PHYRegDef[RF_PATH_B].rfLSSIReadBackPi = TransceiverB_HSPI_Readback;
 	//pHalData->PHYRegDef[RF_PATH_C].rfLSSIReadBackPi = rFPGA0_XC_LSSIReadBack;
 	//pHalData->PHYRegDef[RF_PATH_D].rfLSSIReadBackPi = rFPGA0_XD_LSSIReadBack;
-	pHalData->bPhyValueInitReady = _TRUE;
+	pHalData->bPhyValueInitReady = true;
 }
 
 /*-----------------------------------------------------------------------------
@@ -1465,7 +1465,7 @@ phy_BB8192D_Config_ParaFile(
 	//
 	// 2. If EEPROM or EFUSE autoload OK, We must config by PHY_REG_PG.txt
 	//
-	if (pEEPROM->bautoload_fail_flag == _FALSE)
+	if (pEEPROM->bautoload_fail_flag == false)
 	{
 		pHalData->pwrGroupCnt = 0;
 
@@ -2162,10 +2162,10 @@ PHY_SetTxPowerLevel8192D(
 	return;
 #endif
 
-	if((Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(adapter_to_dvobj(Adapter)->ishighspeed == _FALSE))
+	if((Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(adapter_to_dvobj(Adapter)->ishighspeed == false))
 		return;
 
-	if(pHalData->bTXPowerDataReadFromEEPORM == _FALSE)
+	if(pHalData->bTXPowerDataReadFromEEPORM == false)
 		return;
 
 	channel = GetRightChnlPlace(channel);
@@ -2222,7 +2222,7 @@ PHY_UpdateTxPowerDbm8192D(
 
 	//Adapter->HalFunc.SetTxPowerLevelHandler(Adapter, pHalData->CurrentChannel);//gtest:todo
 
-	return _TRUE;
+	return true;
 }
 
 
@@ -2287,7 +2287,7 @@ _PHY_SetBWMode92D(
 
 	if(pHalData->rf_chip == RF_PSEUDO_11N)
 	{
-		//pHalData->SetBWModeInProgress= _FALSE;
+		//pHalData->SetBWModeInProgress= false;
 		return;
 	}
 
@@ -2407,7 +2407,7 @@ _PHY_SetBWMode92D(
 	//pHalData->SetBWModeInProgress= FALSE;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(Adapter->DualMacConcurrent == _TRUE && BuddyAdapter != NULL)
+	if(Adapter->DualMacConcurrent == true && BuddyAdapter != NULL)
 	{
 		if(pHalData->bMasterOfDMSP)
 		{
@@ -2455,12 +2455,12 @@ PHY_SetBWMode8192D(
 	if(pHalData->bInModeSwitchProcess)
 	{
 		DBG_871X("PHY_SwChnl8192D(): During mode switch \n");
-		//pHalData->SetBWModeInProgress=_FALSE;
+		//pHalData->SetBWModeInProgress=false;
 		return;
 	}
 #endif
 
-	//pHalData->SetBWModeInProgress= _TRUE;
+	//pHalData->SetBWModeInProgress= true;
 
 	pHalData->CurrentChannelBW = Bandwidth;
 
@@ -2472,7 +2472,7 @@ PHY_SetBWMode8192D(
 		//if((BuddyAdapter->MgntInfo.bJoinInProgress) ||(BuddyAdapter->MgntInfo.bScanInProgress))
 		{
 			DBG_871X("PHY_SetBWMode92D():slave return when slave \n");
-			//pHalData->SetBWModeInProgress=_FALSE;
+			//pHalData->SetBWModeInProgress=false;
 			return;
 		}
 	}
@@ -2602,7 +2602,7 @@ PHY_SwitchWirelessBand(
 		}
 	}
 
-	PHY_UpdateBBRFConfiguration8192D(Adapter, _TRUE);
+	PHY_UpdateBBRFConfiguration8192D(Adapter, true);
 
 	if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
 	{
@@ -2634,7 +2634,7 @@ PHY_SwitchWirelessBand(
 #endif
 
 
-	pdmpriv->bReloadtxpowerindex = _TRUE;
+	pdmpriv->bReloadtxpowerindex = true;
 
 	// notice fw know band status  0x81[1]/0x53[1] = 0: 5G, 1: 2G
 	if(pHalData->CurrentBandType92D==BAND_ON_2_4G)
@@ -2759,7 +2759,7 @@ PHY_RestoreRFENV(
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
 	u8			path = pHalData->CurrentBandType92D==BAND_ON_5G?RF_PATH_A:RF_PATH_B;
 	u8			index = 0,	i = 0, eRFPath = RF_PATH_A;
-	bool		bNeedPowerDownRadio = _FALSE, bInteralPA = _FALSE;
+	bool		bNeedPowerDownRadio = false, bInteralPA = false;
 	u32			u4RegValue, mask = 0x1C000, value = 0, u4tmp, u4tmp2,MaskforPhySet=0;
 	//Query regB30 bit27
 	u32			Regb30 = PHY_QueryBBReg(Adapter, 0xb30, BIT27);
@@ -2768,7 +2768,7 @@ PHY_RestoreRFENV(
 
 	//only for 92D C-cut SMSP
 
-	if(adapter_to_dvobj(Adapter)->ishighspeed == _FALSE)
+	if(adapter_to_dvobj(Adapter)->ishighspeed == false)
 		return;
 
 	//config path A for 5G
@@ -2797,7 +2797,7 @@ PHY_RestoreRFENV(
 
 		if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
 		{
-			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, _FALSE);
+			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 			MaskforPhySet = MAC1_ACCESS_PHY0;
 			//asume no this case
 			if(bNeedPowerDownRadio)
@@ -2809,7 +2809,7 @@ PHY_RestoreRFENV(
 		{
 			DBG_8192C("===============phy_SwitchRfSetting8192D interface %d,B30&BIT27=1!!!!\n", pHalData->interfaceIndex);
 
-			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, _TRUE);
+			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
 			MaskforPhySet= MAC0_ACCESS_PHY1;
 			//asume no this case
 			if(bNeedPowerDownRadio)
@@ -2857,7 +2857,7 @@ PHY_RestoreRFENV(
 			{
 				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
-			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, _FALSE);
+			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
 		}
 
 		if(Regb30 && pHalData->interfaceIndex == 0)
@@ -2866,7 +2866,7 @@ PHY_RestoreRFENV(
 			{
 				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
-			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, _TRUE);
+			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
 		}
 
 		if(channel < 149)
@@ -2925,7 +2925,7 @@ PHY_RestoreRFENV(
 			path = RF_PATH_A;
 			if(pHalData->interfaceIndex == 0)
 			{
-				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, _TRUE);
+				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
 				MaskforPhySet = MAC0_ACCESS_PHY1;
 				if(bNeedPowerDownRadio)
 					PHY_EnableRFENV(Adapter, path,MaskforPhySet,&u4RegValue);
@@ -2936,7 +2936,7 @@ PHY_RestoreRFENV(
 			{
 				//RT_TRACE(COMP_MLME, DBG_LOUD, ("===============phy_SwitchRfSetting interface %ld,B30&BIT27=1!!!!\n", Adapter->interfaceIndex));
 
-				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, _FALSE);
+				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 				MaskforPhySet= MAC1_ACCESS_PHY0;
 				//asume no this case
 				if(bNeedPowerDownRadio)
@@ -2973,7 +2973,7 @@ PHY_RestoreRFENV(
 			if(bNeedPowerDownRadio){
 				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
-			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, _TRUE);
+			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
 		}
 
 		if(Regb30 && pHalData->interfaceIndex == 1)
@@ -2982,7 +2982,7 @@ PHY_RestoreRFENV(
 			{
 				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
-			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, _FALSE);
+			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
 		}
 	}
 
@@ -3017,7 +3017,7 @@ static  VOID
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
 	u8		eRFPath = pHalData->CurrentBandType92D == BAND_ON_5G?RF_PATH_A:IS_92D_SINGLEPHY(pHalData->VersionID)?RF_PATH_B:RF_PATH_A;
 	u32		u4tmp = 0, u4RegValue = 0;
-	bool		bNeedPowerDownRadio = _FALSE;
+	bool		bNeedPowerDownRadio = false;
 	u32		MaskforPhySet = 0;
 
 	//RT_TRACE(COMP_CMD, DBG_LOUD, ("====>phy_ReloadLCKSetting interface %d path %d\n", Adapter->interfaceIndex, eRFPath));
@@ -3035,7 +3035,7 @@ static  VOID
 
 			if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
 			{
-				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, _FALSE);
+				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 				MaskforPhySet = MAC1_ACCESS_PHY0;
 				//asume no this case
 				if(bNeedPowerDownRadio)
@@ -3046,7 +3046,7 @@ static  VOID
 
 			if(bNeedPowerDownRadio){
 				PHY_RestoreRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
-				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, _FALSE);
+				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
 			}
 		}
 	}
@@ -3059,7 +3059,7 @@ static  VOID
 
 			if(pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
 			{
-				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, _TRUE);
+				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
 				MaskforPhySet = MAC0_ACCESS_PHY1;
 				if(bNeedPowerDownRadio)
 					PHY_EnableRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
@@ -3069,7 +3069,7 @@ static  VOID
 
 			if(bNeedPowerDownRadio){
 				PHY_RestoreRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
-				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, _TRUE);
+				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
 			}
 		}
 	}
@@ -3110,7 +3110,7 @@ static  VOID
 	u32		RFMask=bRFRegOffsetMask;
 	u8		group=0, i;
 
-	if(adapter_to_dvobj(Adapter)->ishighspeed == _FALSE)
+	if(adapter_to_dvobj(Adapter)->ishighspeed == false)
 		return;
 
 	//only for 92D C-cut SMSP
@@ -3187,15 +3187,15 @@ static  VOID
 
 	//only for 92D C-cut SMSP
 
-	if(adapter_to_dvobj(Adapter)->ishighspeed == _FALSE)
+	if(adapter_to_dvobj(Adapter)->ishighspeed == false)
 		return;
 
 	//---------Do IQK for normal chip and test chip 5G band----------------
 	Indexforchannel = rtl8192d_GetRightChnlPlaceforIQK(channel);
 
 #if MP_DRIVER == 1
-	pHalData->bNeedIQK = _TRUE;
-	pHalData->bLoadIMRandIQKSettingFor2G = _FALSE;
+	pHalData->bNeedIQK = true;
+	pHalData->bLoadIMRandIQKSettingFor2G = false;
 #endif
 
 	if(pHalData->bNeedIQK && !pHalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone)
@@ -3213,9 +3213,9 @@ static  VOID
 			if((pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][0] != 0)/*&&(RegEA4 != 0)*/)
 			{
 				if(pHalData->CurrentBandType92D == BAND_ON_5G)
-					phy_PathAFillIQKMatrix_5G_Normal(Adapter, _TRUE, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][2] == 0));
+					phy_PathAFillIQKMatrix_5G_Normal(Adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][2] == 0));
 				else
-					phy_PathAFillIQKMatrix(Adapter, _TRUE, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][2] == 0));
+					phy_PathAFillIQKMatrix(Adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][2] == 0));
 			}
 
 			if (IS_92D_SINGLEPHY(pHalData->VersionID))
@@ -3223,17 +3223,17 @@ static  VOID
 				if((pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][4] != 0)/*&&(RegEC4 != 0)*/)
 				{
 					if(pHalData->CurrentBandType92D == BAND_ON_5G)
-						phy_PathBFillIQKMatrix_5G_Normal(Adapter, _TRUE, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][6] == 0));
+						phy_PathBFillIQKMatrix_5G_Normal(Adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][6] == 0));
 					else
-						phy_PathBFillIQKMatrix(Adapter, _TRUE, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][6] == 0));
+						phy_PathBFillIQKMatrix(Adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][6] == 0));
 				}
 			}
 
 			if((Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(Indexforchannel==0))
-				pHalData->bLoadIMRandIQKSettingFor2G=_TRUE;
+				pHalData->bLoadIMRandIQKSettingFor2G=true;
 		}
 	}
-	pHalData->bNeedIQK = _FALSE;
+	pHalData->bNeedIQK = false;
 
 	//RT_TRACE(COMP_CMD, DBG_LOUD, ("<====phy_ReloadIQKSetting\n"));
 
@@ -3323,7 +3323,7 @@ static void _PHY_SwChnl8192D(PADAPTER Ad
 		//do IQK when all parameters are ready
 		phy_ReloadIQKSetting(Adapter, channel);
 		break;
-	}while(_TRUE);
+	}while(true);
 
 	//s3. post common command - CmdID_End, None
 
@@ -3337,7 +3337,7 @@ static void _PHY_SwChnl8192D(PADAPTER Ad
 #endif
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(Adapter->DualMacConcurrent == _TRUE && BuddyAdapter != NULL)
+	if(Adapter->DualMacConcurrent == true && BuddyAdapter != NULL)
 	{
 		if(pHalData->bMasterOfDMSP)
 		{
@@ -3354,10 +3354,10 @@ PHY_SwChnl8192D(	// Call after initializ
 	IN	u8		channel
 	)
 {
-	//PADAPTER Adapter =  ADJUST_TO_ADAPTIVE_ADAPTER(pAdapter, _TRUE);
+	//PADAPTER Adapter =  ADJUST_TO_ADAPTIVE_ADAPTER(pAdapter, true);
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u8	tmpchannel = pHalData->CurrentChannel;
-	bool  bResult = _TRUE;
+	bool  bResult = true;
 	u32	timeout = 1000, timecount = 0;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -3372,7 +3372,7 @@ PHY_SwChnl8192D(	// Call after initializ
 	}
 
 	if(Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_COMPLETE)
-		pHalData->bLoadIMRandIQKSettingFor2G = _FALSE;
+		pHalData->bLoadIMRandIQKSettingFor2G = false;
 
 	//if(pHalData->SwChnlInProgress)
 	//	return;
@@ -3384,7 +3384,7 @@ PHY_SwChnl8192D(	// Call after initializ
 	if(pHalData->bInModeSwitchProcess)
 	{
 		DBG_871X("PHY_SwChnl8192D(): During mode switch \n");
-		//pHalData->SwChnlInProgress=_FALSE;
+		//pHalData->SwChnlInProgress=false;
 		return;
 	}
 
@@ -3462,7 +3462,7 @@ PHY_SwChnl8192D(	// Call after initializ
 	if((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
 	{
 		DBG_871X("PHY_SwChnl8192D():slave return when slave  \n");
-		//pHalData->SwChnlInProgress=_FALSE;
+		//pHalData->SwChnlInProgress=false;
 		return;
 	}
 #endif
@@ -3509,7 +3509,7 @@ phy_SwChnlStepByStep(
 	OUT u32		*delay
 	)
 {
-	return _TRUE;
+	return true;
 }
 
 
@@ -3527,9 +3527,9 @@ phy_SetSwChnlCmdArray(
 	SwChnlCmd* pCmd;
 
 	if(CmdTable == NULL)
-		return _FALSE;
+		return false;
 	if(CmdTableIdx >= CmdTableSz)
-		return _FALSE;
+		return false;
 
 	pCmd = CmdTable + CmdTableIdx;
 	pCmd->CmdID = CmdID;
@@ -3537,7 +3537,7 @@ phy_SetSwChnlCmdArray(
 	pCmd->Para2 = Para2;
 	pCmd->msDelay = msDelay;
 
-	return _TRUE;
+	return true;
 }
 
 static	void
@@ -3636,7 +3636,7 @@ PHY_CheckIsLegalRfPath8192D(
 	IN	u32	eRFPath)
 {
 //	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-	bool				rtValue = _TRUE;
+	bool				rtValue = true;
 
 	// NOt check RF Path now.!
 	return	rtValue;
@@ -4299,7 +4299,7 @@ phy_SaveADDARegisters(
 {
 	u32	i;
 
-	//if (ODM_CheckPowerStatus(pAdapter) == _FALSE)
+	//if (ODM_CheckPowerStatus(pAdapter) == false)
 	//	return;
 
 	//RTPRINT(FINIT, INIT_IQK, ("Save ADDA parameters.\n"));
@@ -4443,7 +4443,7 @@ phy_SimularityCompare_92D(
 	u32	i, j, diff, SimularityBitMap, bound = 0, u4temp = 0;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	u8	final_candidate[2] = {0xFF, 0xFF};	//for path A and path B
-	bool		bResult = _TRUE;
+	bool		bResult = true;
 	bool		is2T = IS_92D_SINGLEPHY(pHalData->VersionID);
 
 	if(is2T)
@@ -4481,7 +4481,7 @@ phy_SimularityCompare_92D(
 			{
 				for( j = i*4; j < (i+1)*4-2; j++)
 					result[3][j] = result[final_candidate[i]][j];
-				bResult = _FALSE;
+				bResult = false;
 			}
 		}
 
@@ -4490,7 +4490,7 @@ phy_SimularityCompare_92D(
 			u4temp += (result[c1][i]+	result[c2][i]);
 		}
 		if(u4temp == 0)	//IQK fail for c1 & c2
-			bResult = _FALSE;
+			bResult = false;
 
 		return bResult;
 	}
@@ -4517,12 +4517,12 @@ phy_SimularityCompare_92D(
 			result[3][i] = result[c1][i];
 	}
 
-	return _FALSE;
+	return false;
 
 }
 
 /*
-return _FALSE => do IQK again
+return false => do IQK again
 */
 static bool
 phy_SimularityCompare(
@@ -4602,7 +4602,7 @@ phy_IQCalibrate(
 			phy_SaveADDARegisters(pAdapter, IQK_BB_REG_92C, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92C);
 	}
 
-	phy_PathADDAOn(pAdapter, ADDA_REG, _TRUE, is2T);
+	phy_PathADDAOn(pAdapter, ADDA_REG, true, is2T);
 
 	if(IS_HARDWARE_TYPE_8192D(pAdapter))
 		PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x01017038);
@@ -4614,7 +4614,7 @@ phy_IQCalibrate(
 
 	if(!pdmpriv->bRfPiEnable){
 		// Switch BB to PI mode to do IQ Calibration.
-		phy_PIModeSwitch(pAdapter, _TRUE);
+		phy_PIModeSwitch(pAdapter, true);
 	}
 
 	PHY_SetBBReg1Byte(pAdapter, rFPGA0_RFMOD, BIT24, 0x00);
@@ -4693,7 +4693,7 @@ phy_IQCalibrate(
 		phy_PathAStandBy(pAdapter);
 
 		// Turn Path B ADDA on
-		phy_PathADDAOn(pAdapter, ADDA_REG, _FALSE, is2T);
+		phy_PathADDAOn(pAdapter, ADDA_REG, false, is2T);
 
 		for(i = 0 ; i < retryCount ; i++){
 			PathBOK = phy_PathB_IQK(pAdapter);
@@ -4726,7 +4726,7 @@ phy_IQCalibrate(
 	{
 		if(!pdmpriv->bRfPiEnable){
 			// Switch back BB to SI mode after finish IQ Calibration.
-			phy_PIModeSwitch(pAdapter, _FALSE);
+			phy_PIModeSwitch(pAdapter, false);
 		}
 
 		// Reload ADDA power saving parameters
@@ -4775,7 +4775,7 @@ phy_IQCalibrate_5G(
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u32			extPAon, REG0xe5c, RX0REG0xe40, REG0xe40, REG0xe94, REG0xe9c;
 	u32			REG0xeac, RX1REG0xe40, REG0xeb4, REG0xea4,REG0xec4;
-	u8			TX0IQKOK = _FALSE, TX1IQKOK = _FALSE ;
+	u8			TX0IQKOK = false, TX1IQKOK = false ;
 	u32			TX_X0, TX_Y0, TX_X1, TX_Y1, RX_X0, RX_Y0, RX_X1, RX_Y1;
 	u32			ADDA_REG[IQK_ADDA_REG_NUM] = {
 						rFPGA0_XCD_SwitchControl,	rBlue_Tooth,
@@ -4814,7 +4814,7 @@ phy_IQCalibrate_5G(
 
 	//1 Path-A TX IQK
 	//Path-A AFE all on
-	phy_PathADDAOn(pAdapter, ADDA_REG, _TRUE, _TRUE);
+	phy_PathADDAOn(pAdapter, ADDA_REG, true, true);
 
 	//MAC register setting
 	phy_MACSettingCalibration(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
@@ -4822,7 +4822,7 @@ phy_IQCalibrate_5G(
 	//IQK must be done in PI mode
 	pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
 	if(!pdmpriv->bRfPiEnable)
-		phy_PIModeSwitch(pAdapter, _TRUE);
+		phy_PIModeSwitch(pAdapter, true);
 
 	//TXIQK RF setting
 	PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01940000);
@@ -4900,7 +4900,7 @@ phy_IQCalibrate_5G(
 		RX0REG0xe40 =  0x80000000 | (REG0xe40 & 0xfc00fc00) | (TX_X0<<16) | TX_Y0;
 		result[0][0] = TX_X0;
 		result[0][1] = TX_Y0;
-		TX0IQKOK = _TRUE;
+		TX0IQKOK = true;
 		DBG_8192C("IQK for 5G: Path A TxOK interface %u\n", pHalData->interfaceIndex);
 	}
 	else
@@ -4909,7 +4909,7 @@ phy_IQCalibrate_5G(
 	}
 
 	//1 path A RX IQK
-	if(TX0IQKOK == _TRUE)
+	if(TX0IQKOK == true)
 	{
 
 		DBG_8192C("IQK for 5G: Path A Rx  START interface %u\n", pHalData->interfaceIndex);
@@ -5002,7 +5002,7 @@ phy_IQCalibrate_5G(
 
 	DBG_8192C("IQK for 5G: Path B Tx  START interface %u\n", pHalData->interfaceIndex);
 
-	phy_PathADDAOn(pAdapter, ADDA_REG, _FALSE, _TRUE);
+	phy_PathADDAOn(pAdapter, ADDA_REG, false, true);
 
 	//TXIQK RF setting
 	PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01940000);
@@ -5048,11 +5048,11 @@ phy_IQCalibrate_5G(
 		RX1REG0xe40 = 0x80000000 | (REG0xe40 & 0xfc00fc00) | (TX_X1<<16) | TX_Y1;
 		result[0][4] = TX_X1;
 		result[0][5] = TX_Y1;
-		TX1IQKOK = _TRUE;
+		TX1IQKOK = true;
 	}
 
 	//1 path B RX IQK
-	if(TX1IQKOK == _TRUE)
+	if(TX1IQKOK == true)
 	{
 
 		DBG_8192C("IQK for 5G: Path B Rx  START interface %u\n", pHalData->interfaceIndex);
@@ -5140,7 +5140,7 @@ Exit_IQK:
 	phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 	if(!pdmpriv->bRfPiEnable)
-		phy_PIModeSwitch(pAdapter, _FALSE);
+		phy_PIModeSwitch(pAdapter, false);
 	//Reload ADDA power saving parameters
 	phy_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 
@@ -5217,16 +5217,16 @@ phy_IQCalibrate_5G_Normal(
 
 	if((rfPathDiv&0x01)==1)   // Div on
 	{
-		phy_PathADDAOn(pAdapter, ADDA_REG, _FALSE, is2T);
+		phy_PathADDAOn(pAdapter, ADDA_REG, false, is2T);
 		//DbgPrint("=STEP= change ADDA Path to B Path\n");
 	}
 	else
-		phy_PathADDAOn(pAdapter, ADDA_REG, _TRUE, is2T);
+		phy_PathADDAOn(pAdapter, ADDA_REG, true, is2T);
 	//3 end
        //=============================================//
 
 	//Path-A AFE all on
-	//phy_PathADDAOn(pAdapter, ADDA_REG, _TRUE, is2T);
+	//phy_PathADDAOn(pAdapter, ADDA_REG, true, is2T);
 
 	//MAC settings
 	phy_MACSettingCalibration(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
@@ -5238,7 +5238,7 @@ phy_IQCalibrate_5G_Normal(
 
 	if(!pdmpriv->bRfPiEnable){
 		// Switch BB to PI mode to do IQ Calibration.
-		phy_PIModeSwitch(pAdapter, _TRUE);
+		phy_PIModeSwitch(pAdapter, true);
 	}
 
 	PHY_SetBBReg1Byte(pAdapter, rFPGA0_RFMOD, BIT24, 0x00);
@@ -5291,7 +5291,7 @@ phy_IQCalibrate_5G_Normal(
 		//_PHY_PathAStandBy(pAdapter);
 
 		// Turn Path B ADDA on
-		phy_PathADDAOn(pAdapter, ADDA_REG, _FALSE, is2T);
+		phy_PathADDAOn(pAdapter, ADDA_REG, false, is2T);
 
 		{
 			PathBOK = phy_PathB_IQK_5G_Normal(pAdapter);
@@ -5339,7 +5339,7 @@ phy_IQCalibrate_5G_Normal(
 
 		if(!pdmpriv->bRfPiEnable){
 			// Switch back BB to SI mode after finish IQ Calibration.
-			phy_PIModeSwitch(pAdapter, _FALSE);
+			phy_PIModeSwitch(pAdapter, false);
 		}
 
 		// Reload ADDA power saving parameters
@@ -5479,7 +5479,7 @@ phy_CalcCurvIndex(
 	u8	chnl_num = is5G?TARGET_CHNL_NUM_2G_5G:TARGET_CHNL_NUM_2G;
 	u8	Base_chnl[BASE_CHNL_NUM] = {1, 14, 36, 100, 149};
 	u32	j, base_index = 0, search_bound=128;
-	bool	bBase = _FALSE;
+	bool	bBase = false;
 
 	for(i=start; i<chnl_num; i++)
 	{
@@ -5503,13 +5503,13 @@ phy_CalcCurvIndex(
 		}
 
 #if 1
-		bBase = _FALSE;
+		bBase = false;
 
 		for(j = start_base; j < end_base; j++)
 		{
 			if(channel == Base_chnl[j])
 			{
-				bBase = _TRUE;
+				bBase = true;
 				base_index = 0;
 				search_bound = (CV_CURVE_CNT*2);	//search every 128
 				break;
@@ -5679,9 +5679,9 @@ phy_LCCalibrate92DSW(
 			}
 
 			if(index == 0 && pHalData->interfaceIndex == 0)
-				phy_CalcCurvIndex(pAdapter, TargetChnl_5G, curveCountVal, _TRUE, CurveIndex);
+				phy_CalcCurvIndex(pAdapter, TargetChnl_5G, curveCountVal, true, CurveIndex);
 			else
-				phy_CalcCurvIndex(pAdapter, TargetChnl_2G, curveCountVal, _FALSE, CurveIndex);
+				phy_CalcCurvIndex(pAdapter, TargetChnl_2G, curveCountVal, false, CurveIndex);
 
 			// switch CV-curve control mode
 			PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)index, RF_SYN_G7, BIT17, 0x1);
@@ -6143,7 +6143,7 @@ phy_APCalibrate(
 		//	((0x08 << 15) | (0x08 << 10) | (0x08 << 5) | 0x08));
 	}
 
-	pdmpriv->bAPKdone = _TRUE;
+	pdmpriv->bAPKdone = true;
 
 	//RTPRINT(FINIT, INIT_IQK, ("<==PHY_APCalibrate()\n"));
 }
@@ -6182,9 +6182,9 @@ rtl8192d_PHY_IQCalibrate(
 	bool		bPathAOK, bPathBOK;
 	int			RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC, RegTmp = 0;
 	bool		is12simular, is13simular, is23simular;
-	bool		bStartContTx = _FALSE, bSingleTone = _FALSE, bCarrierSuppression = _FALSE;
+	bool		bStartContTx = false, bSingleTone = false, bCarrierSuppression = false;
 
-	//if (ODM_CheckPowerStatus(pAdapter) == _FALSE)
+	//if (ODM_CheckPowerStatus(pAdapter) == false)
 	//	return;
 
 #if (MP_DRIVER == 1)
@@ -6216,11 +6216,11 @@ rtl8192d_PHY_IQCalibrate(
 		result[3][i] = 0;
 	}
 	final_candidate = 0xff;
-	bPathAOK = _FALSE;
-	bPathBOK = _FALSE;
-	is12simular = _FALSE;
-	is23simular = _FALSE;
-	is13simular = _FALSE;
+	bPathAOK = false;
+	bPathBOK = false;
+	is12simular = false;
+	is23simular = false;
+	is13simular = false;
 
 	//RTPRINT(FINIT, INIT_IQK, ("IQK !!!interface %d currentband %d ishardwareD %d \n", pAdapter->interfaceIndex, pHalData->CurrentBandType92D, IS_HARDWARE_TYPE_8192D(pAdapter)));
 	//AcquireCCKAndRWPageAControl(pAdapter);
@@ -6234,9 +6234,9 @@ rtl8192d_PHY_IQCalibrate(
 		else if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
 		{
 			if(IS_92D_SINGLEPHY(pHalData->VersionID))
-				phy_IQCalibrate(pAdapter, result, i, _TRUE);
+				phy_IQCalibrate(pAdapter, result, i, true);
 			else
-				phy_IQCalibrate(pAdapter, result, i, _FALSE);
+				phy_IQCalibrate(pAdapter, result, i, false);
 		}
 
 		if(i == 1)
@@ -6301,7 +6301,7 @@ rtl8192d_PHY_IQCalibrate(
 		RegECC = result[final_candidate][7];
 		DBG_8192C("IQK: final_candidate is %x\n", final_candidate);
 		DBG_8192C("IQK: RegE94=%x RegE9C=%x RegEA4=%x RegEAC=%x RegEB4=%x RegEBC=%x RegEC4=%x RegECC=%x\n", RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC);
-		bPathAOK = bPathBOK = _TRUE;
+		bPathAOK = bPathBOK = true;
 	}
 	else
 	{
@@ -6338,7 +6338,7 @@ rtl8192d_PHY_IQCalibrate(
 				result[final_candidate][i];
 		}
 
-		pHalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone = _TRUE;
+		pHalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone = true;
 
 		//RT_TRACE(COMP_SCAN|COMP_MLME,DBG_LOUD,("\nIQK OK Indexforchannel %d.\n", Indexforchannel));
 #ifdef CONFIG_CONCURRENT_MODE
@@ -6352,7 +6352,7 @@ rtl8192d_PHY_IQCalibrate(
 					result[final_candidate][i];
 			}
 
-			pbuddy_HalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone = _TRUE;
+			pbuddy_HalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone = true;
 		}
 #endif
 	}
@@ -6367,7 +6367,7 @@ rtl8192d_PHY_LCCalibrate(
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	struct mlme_ext_priv	*pmlmeext = &pAdapter->mlmeextpriv;
-	bool		bStartContTx = _FALSE, bSingleTone = _FALSE, bCarrierSuppression = _FALSE;
+	bool		bStartContTx = false, bSingleTone = false, bCarrierSuppression = false;
 	u32			timeout = 2000, timecount = 0;
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	PADAPTER	BuddyAdapter = pAdapter->pbuddy_adapter;
@@ -6394,7 +6394,7 @@ rtl8192d_PHY_LCCalibrate(
 		(pHalData->interfaceIndex == 1 && pHalData->CurrentBandType92D == BAND_ON_5G)))
 	{
 		pmlmeprivBuddyAdapter = &BuddyAdapter->mlmepriv;
-		while((check_fwstate(pmlmeprivBuddyAdapter, _FW_UNDER_LINKING|_FW_UNDER_SURVEY)==_TRUE) && timecount < timeout)
+		while((check_fwstate(pmlmeprivBuddyAdapter, _FW_UNDER_LINKING|_FW_UNDER_SURVEY)==true) && timecount < timeout)
 		{
 			rtw_msleep_os(50);
 			timecount += 50;
@@ -6405,20 +6405,20 @@ rtl8192d_PHY_LCCalibrate(
 	if(pmlmeext->sitesurvey_res.state == SCAN_PROCESS)
 		return;
 
-	pHalData->bLCKInProgress = _TRUE;
+	pHalData->bLCKInProgress = true;
 
 	//DBG_8192C("LCK:Start!!!interface %d currentband %x delay %d ms\n", pHalData->interfaceIndex, pHalData->CurrentBandType92D, timecount);
 
 	if(IS_92D_SINGLEPHY(pHalData->VersionID))
 	{
-		phy_LCCalibrate(pAdapter, _TRUE);
+		phy_LCCalibrate(pAdapter, true);
 	}
 	else{
 		// For 88C 1T1R
-		phy_LCCalibrate(pAdapter, _FALSE);
+		phy_LCCalibrate(pAdapter, false);
 	}
 
-	pHalData->bLCKInProgress = _FALSE;
+	pHalData->bLCKInProgress = false;
 
 	//RTPRINT(FINIT, INIT_IQK, ("LCK:Finish!!!interface %d\n", pHalData->interfaceIndex));
 }
@@ -6443,11 +6443,11 @@ rtl8192d_PHY_APCalibrate(
 		return;
 
 	if(IS_92D_SINGLEPHY(pHalData->VersionID)){
-		phy_APCalibrate(pAdapter, delta, _TRUE);
+		phy_APCalibrate(pAdapter, delta, true);
 	}
 	else{
 		// For 88C 1T1R
-		phy_APCalibrate(pAdapter, delta, _FALSE);
+		phy_APCalibrate(pAdapter, delta, false);
 	}
 }
 
@@ -6671,10 +6671,10 @@ PHY_UpdateBBRFConfiguration8192D(
 			{
 				if(!(rtw_read8(Adapter, REG_MAC1)&MAC1_ON))
 				{
-					rtl8192d_PHY_EnableAnotherPHY(Adapter, _TRUE);
+					rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
 					PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW|MAC0_ACCESS_PHY1, bRFRegOffsetMask, 0x97524); //set channel 36
 					//DBG_871X("PHY_UpdateBBRFConfiguration8192D(),MAC0 set MAC1 RF0x18:%x.\n",PHY_QueryRFReg(Adapter,RF_PATH_A,RF_CHNLBW|MAC0_ACCESS_PHY1,bRFRegOffsetMask));
-					rtl8192d_PHY_PowerDownAnotherPHY(Adapter, _TRUE);
+					rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
 				}
 			}
 			else
@@ -6682,10 +6682,10 @@ PHY_UpdateBBRFConfiguration8192D(
 			{
 				if(!(rtw_read8(Adapter, REG_MAC0)&MAC0_ON))
 				{
-					rtl8192d_PHY_EnableAnotherPHY(Adapter, _FALSE);
+					rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 					PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW|MAC1_ACCESS_PHY0, bRFRegOffsetMask, 0x87401); // set channel 1
 					//DBG_871X("PHY_UpdateBBRFConfiguration8192D(),MAC1 set MAC0 RF0x18:%x.\n",PHY_QueryRFReg(Adapter,RF_PATH_A,RF_CHNLBW|MAC1_ACCESS_PHY0,bRFRegOffsetMask));
-					rtl8192d_PHY_PowerDownAnotherPHY(Adapter, _FALSE);
+					rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
 				}
 			}
 		}
@@ -6710,18 +6710,18 @@ PHY_UpdateBBRFConfiguration8192D(
 			PHY_SetBBReg(Adapter, rFPGA0_AdDaClockEn, BIT12|BIT13, 0x3);
 		else
 		{
-			bool bMAC0NotUp =_FALSE;
+			bool bMAC0NotUp =false;
 
 			//3 Path Div
 			// Neil Chen---2011--05--31---Begin
 			//PHY_SetBBReg(Adapter, rFPGA0_AdDaClockEn, BIT12|BIT13, 0x3);
 			//--------------------------------------end
 
-			bMAC0NotUp = rtl8192d_PHY_EnableAnotherPHY(Adapter, _FALSE);
+			bMAC0NotUp = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 			if(bMAC0NotUp)
 			{
 				PHY_SetBBReg(Adapter, rFPGA0_AdDaClockEn|MAC1_ACCESS_PHY0, BIT12|BIT13, 0x3);
-				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, _FALSE);
+				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
 			}
 		}
 
@@ -6900,13 +6900,13 @@ VOID PHY_ConfigMacPhyModeInfo92D(
 			{
 				if(pHalData->interfaceIndex == 0)
 				{
-					pHalData->bMasterOfDMSP = _TRUE;
-					pHalData->bSlaveOfDMSP = _FALSE;
+					pHalData->bMasterOfDMSP = true;
+					pHalData->bSlaveOfDMSP = false;
 				}
 				else if(pHalData->interfaceIndex == 1)
 				{
-					pHalData->bMasterOfDMSP = _FALSE;
-					pHalData->bSlaveOfDMSP = _TRUE;
+					pHalData->bMasterOfDMSP = false;
+					pHalData->bSlaveOfDMSP = true;
 				}
 			}
 			RELEASE_GLOBAL_MUTEX(GlobalCounterForMutex);
@@ -6918,8 +6918,8 @@ VOID PHY_ConfigMacPhyModeInfo92D(
 			pHalData->VersionID = (VERSION_8192D)(pHalData->VersionID | RF_TYPE_2T2R);
 			pHalData->BandSet92D = BAND_ON_BOTH;
 			pHalData->CurrentBandType92D = BAND_ON_2_4G;
-			pHalData->bMasterOfDMSP = _FALSE;
-			pHalData->bSlaveOfDMSP = _FALSE;
+			pHalData->bMasterOfDMSP = false;
+			pHalData->bSlaveOfDMSP = false;
 			break;
 
 		case DUALMAC_DUALPHY:
@@ -6933,8 +6933,8 @@ VOID PHY_ConfigMacPhyModeInfo92D(
 				pHalData->BandSet92D = BAND_ON_2_4G;
 				pHalData->CurrentBandType92D = BAND_ON_2_4G;//
 			}
-			pHalData->bMasterOfDMSP = _FALSE;
-			pHalData->bSlaveOfDMSP = _FALSE;
+			pHalData->bMasterOfDMSP = false;
+			pHalData->bSlaveOfDMSP = false;
 			break;
 
 		default:
@@ -7092,7 +7092,7 @@ rtl8192d_PHY_ResetIQKResult(
 				pHalData->IQKMatrixRegSetting[i].Value[0][5] =
 				pHalData->IQKMatrixRegSetting[i].Value[0][7] = 0x0;
 
-			pHalData->IQKMatrixRegSetting[i].bIQKDone = _FALSE;
+			pHalData->IQKMatrixRegSetting[i].bIQKDone = false;
 
 		}
 	}
@@ -7111,11 +7111,11 @@ VOID rtl8192d_PHY_SetRFPathSwitch(
 
 	if (IS_92D_SINGLEPHY(pHalData->VersionID))
 	{
-		phy_SetRFPathSwitch(pAdapter, bMain, _TRUE);
+		phy_SetRFPathSwitch(pAdapter, bMain, true);
 	}
 	else{
 		// For 88C 1T1R
-		phy_SetRFPathSwitch(pAdapter, bMain, _FALSE);
+		phy_SetRFPathSwitch(pAdapter, bMain, false);
 	}
 }
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
@@ -178,19 +178,19 @@ rtl8192d_PHY_RF6052SetCckTxPower(
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
 	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
 	u32			TxAGC[2]={0, 0}, tmpval=0;
-	bool		TurboScanOff = _FALSE;
+	bool		TurboScanOff = false;
 	u8			idx1, idx2;
 	u8*			ptr;
 
 	if(pHalData->EEPROMRegulatory != 0)
-		TurboScanOff = _TRUE;
+		TurboScanOff = true;
 
 	if(pmlmeext->sitesurvey_res.state == SCAN_PROCESS)
 	{
 		TxAGC[RF_PATH_A] = 0x3f3f3f3f;
 		TxAGC[RF_PATH_B] = 0x3f3f3f3f;
 
-		TurboScanOff =  _TRUE;//disable Turbo scan
+		TurboScanOff =  true;//disable Turbo scan
 
 		if(TurboScanOff)
 		{
@@ -573,9 +573,9 @@ rtl8192d_PHY_EnableAnotherPHY(
 	)
 {
 	u8			u1bTmp;
-	u8			MAC_REG = bMac0==_TRUE?REG_MAC1:REG_MAC0;
-	u8			MAC_ON_BIT = bMac0==_TRUE?MAC1_ON:MAC0_ON;
-	bool		bResult = _TRUE;	//true: need to enable BB/RF power
+	u8			MAC_REG = bMac0==true?REG_MAC1:REG_MAC0;
+	u8			MAC_ON_BIT = bMac0==true?MAC1_ON:MAC0_ON;
+	bool		bResult = true;	//true: need to enable BB/RF power
 	u32			MaskForPHYSet = 0;
 
 	//MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write.
@@ -592,7 +592,7 @@ rtl8192d_PHY_EnableAnotherPHY(
 		rtw_write16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet, rtw_read16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet)|BIT13|BIT0|BIT1);
 	} else {
 		// We think if MAC1 is ON,then radio_a.txt and radio_b.txt has been load.
-		bResult = _FALSE;
+		bResult = false;
 	}
 	return bResult;
 }
@@ -604,8 +604,8 @@ rtl8192d_PHY_PowerDownAnotherPHY(
 	)
 {
 	u8	u1bTmp;
-	u8	MAC_REG = bMac0==_TRUE?REG_MAC1:REG_MAC0;
-	u8	MAC_ON_BIT = bMac0==_TRUE?MAC1_ON:MAC0_ON;
+	u8	MAC_REG = bMac0==true?REG_MAC1:REG_MAC0;
+	u8	MAC_ON_BIT = bMac0==true?MAC1_ON:MAC0_ON;
 	u32	MaskforPhySet = 0;
 
 	// check MAC0 enable or not again now, if enabled, not power down radio A.
@@ -639,9 +639,9 @@ phy_RF6052_Config_ParaFile(
 	static s8		sz92DRadioBFile[] = RTL8192D_PHY_RADIO_B;
 	static s8		sz92DRadioAintPAFile[] = RTL8192D_PHY_RADIO_A_intPA;
 	static s8		sz92DRadioBintPAFile[] = RTL8192D_PHY_RADIO_B_intPA;
-	bool		bMac1NeedInitRadioAFirst = _FALSE,bMac0NeedInitRadioBFirst = _FALSE;
-	bool		bNeedPowerDownRadioA = _FALSE,bNeedPowerDownRadioB = _FALSE;
-	bool		bTrueBPath = _FALSE;//vivi added this for read parameter from header, 20100908
+	bool		bMac1NeedInitRadioAFirst = false,bMac0NeedInitRadioBFirst = false;
+	bool		bNeedPowerDownRadioA = false,bNeedPowerDownRadioB = false;
+	bool		bTrueBPath = false;//vivi added this for read parameter from header, 20100908
 	u32	MaskforPhySet = 0; //For 92d PHY cross access, 88c must set value 0.
 
 
@@ -659,10 +659,10 @@ phy_RF6052_Config_ParaFile(
 		if(pHalData->CurrentBandType92D == BAND_ON_2_4G && pHalData->interfaceIndex == 0)
 		{
 			//MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write.
-			if(rtl8192d_PHY_EnableAnotherPHY(Adapter, _TRUE))
+			if(rtl8192d_PHY_EnableAnotherPHY(Adapter, true))
 			{
 				pHalData->NumTotalRFPath = 2;
-				bMac0NeedInitRadioBFirst = _TRUE;
+				bMac0NeedInitRadioBFirst = true;
 			}
 			else
 			{
@@ -673,10 +673,10 @@ phy_RF6052_Config_ParaFile(
 		else if(pHalData->CurrentBandType92D == BAND_ON_5G && pHalData->interfaceIndex == 1)
 		{
 			//MAC1 Need PHY0 load radio_a.txt . Driver use DBI to write.
-			if(rtl8192d_PHY_EnableAnotherPHY(Adapter, _FALSE))
+			if(rtl8192d_PHY_EnableAnotherPHY(Adapter, false))
 			{
 				pHalData->NumTotalRFPath = 2;
-				bMac1NeedInitRadioAFirst = _TRUE;
+				bMac1NeedInitRadioAFirst = true;
 			}
 			else
 			{
@@ -688,7 +688,7 @@ phy_RF6052_Config_ParaFile(
 		{
 			// MAC0 enabled, only init radia B.
 			pszRadioAFile = pszRadioBFile;
-			bTrueBPath = _TRUE;  //vivi added this for read parameter from header, 20100909
+			bTrueBPath = true;  //vivi added this for read parameter from header, 20100909
 		}
 	}
 
@@ -704,15 +704,15 @@ phy_RF6052_Config_ParaFile(
 		{
 			if (eRFPath == RF_PATH_A)
 			{
-				bNeedPowerDownRadioA = _TRUE;
+				bNeedPowerDownRadioA = true;
 				MaskforPhySet = MAC1_ACCESS_PHY0;
 			}
 			else if (eRFPath == RF_PATH_B)
 			{
 				MaskforPhySet = 0;
-				bMac1NeedInitRadioAFirst = _FALSE;
+				bMac1NeedInitRadioAFirst = false;
 				eRFPath = RF_PATH_A;
-				bTrueBPath = _TRUE;
+				bTrueBPath = true;
 				pszRadioAFile = pszRadioBFile;
 				pHalData->NumTotalRFPath = 1;
 			}
@@ -727,10 +727,10 @@ phy_RF6052_Config_ParaFile(
 			if (eRFPath == RF_PATH_B)
 			{
 				MaskforPhySet = MAC0_ACCESS_PHY1;
-				bMac0NeedInitRadioBFirst = _FALSE;
-				bNeedPowerDownRadioB = _TRUE;
+				bMac0NeedInitRadioBFirst = false;
+				bNeedPowerDownRadioB = true;
 				eRFPath = RF_PATH_A;
-				bTrueBPath = _TRUE;
+				bTrueBPath = true;
 				pszRadioAFile = pszRadioBFile;
 				pHalData->NumTotalRFPath = 1;
 			}
@@ -772,7 +772,7 @@ phy_RF6052_Config_ParaFile(
 			case RF_PATH_A:
 #ifdef CONFIG_EMBEDDED_FWIMG
 				//vivi added this for read parameter from header, 20100908
-				if(bTrueBPath == _TRUE)
+				if(bTrueBPath == true)
 					rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(Adapter,radiob_txt|MaskforPhySet, (RF_RADIO_PATH_E)eRFPath);
 				else
 					rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(Adapter,radioa_txt|MaskforPhySet, (RF_RADIO_PATH_E)eRFPath);
@@ -816,12 +816,12 @@ phy_RF6052_Config_ParaFile(
 	if (bNeedPowerDownRadioA)
 	{
 		// check MAC0 enable or not again now, if enabled, not power down radio A.
-		rtl8192d_PHY_PowerDownAnotherPHY(Adapter, _FALSE);
+		rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
 	}
 	else  if (bNeedPowerDownRadioB)
 	{
 		// check MAC1 enable or not again now, if enabled, not power down radio B.
-		rtl8192d_PHY_PowerDownAnotherPHY(Adapter, _TRUE);
+		rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
 	}
 
 	for(eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
@@ -921,7 +921,7 @@ PHY_RFShadowWrite(
 	u32				Data)
 {
 	RF_Shadow[eRFPath][Offset].Value = (Data & bRFRegOffsetMask);
-	RF_Shadow[eRFPath][Offset].Driver_Write = _TRUE;
+	RF_Shadow[eRFPath][Offset].Driver_Write = true;
 
 }	/* PHY_RFShadowWrite */
 
@@ -938,21 +938,21 @@ PHY_RFShadowCompare(
 {
 	u32	reg;
 	// Check if we need to check the register
-	if (RF_Shadow[eRFPath][Offset].Compare == _TRUE)
+	if (RF_Shadow[eRFPath][Offset].Compare == true)
 	{
 		reg = PHY_QueryRFReg(Adapter, eRFPath, Offset, bRFRegOffsetMask);
 		// Compare shadow and real rf register for 20bits!!
 		if (RF_Shadow[eRFPath][Offset].Value != reg)
 		{
 			// Locate error position.
-			RF_Shadow[eRFPath][Offset].ErrorOrNot = _TRUE;
+			RF_Shadow[eRFPath][Offset].ErrorOrNot = true;
 			//RT_TRACE(COMP_INIT, DBG_LOUD,
 			//("PHY_RFShadowCompare RF-%d Addr%02lx Err = %05lx\n",
 			//eRFPath, Offset, reg));
 		}
 		return RF_Shadow[eRFPath][Offset].ErrorOrNot ;
 	}
-	return _FALSE;
+	return false;
 }	/* PHY_RFShadowCompare */
 VOID
 PHY_RFShadowRecorver(
@@ -966,10 +966,10 @@ PHY_RFShadowRecorver(
 	u32				Offset)
 {
 	// Check if the address is error
-	if (RF_Shadow[eRFPath][Offset].ErrorOrNot == _TRUE)
+	if (RF_Shadow[eRFPath][Offset].ErrorOrNot == true)
 	{
 		// Check if we need to recorver the register.
-		if (RF_Shadow[eRFPath][Offset].Recorver == _TRUE)
+		if (RF_Shadow[eRFPath][Offset].Recorver == true)
 		{
 			PHY_SetRFReg(Adapter, eRFPath, Offset, bRFRegOffsetMask,
 							RF_Shadow[eRFPath][Offset].Value);
@@ -1068,9 +1068,9 @@ PHY_RFShadowCompareFlagSetAll(
 		{
 			// 2008/11/20 MH For S3S4 test, we only check reg 26/27 now!!!!
 			if (Offset != 0x26 && Offset != 0x27)
-				PHY_RFShadowCompareFlagSet(Adapter, (RF_RADIO_PATH_E)eRFPath, Offset, _FALSE);
+				PHY_RFShadowCompareFlagSet(Adapter, (RF_RADIO_PATH_E)eRFPath, Offset, false);
 			else
-				PHY_RFShadowCompareFlagSet(Adapter, (RF_RADIO_PATH_E)eRFPath, Offset, _TRUE);
+				PHY_RFShadowCompareFlagSet(Adapter, (RF_RADIO_PATH_E)eRFPath, Offset, true);
 		}
 	}
 
@@ -1091,9 +1091,9 @@ PHY_RFShadowRecorverFlagSetAll(
 		{
 			// 2008/11/20 MH For S3S4 test, we only check reg 26/27 now!!!!
 			if (Offset != 0x26 && Offset != 0x27)
-				PHY_RFShadowRecorverFlagSet(Adapter, (RF_RADIO_PATH_E)eRFPath, Offset, _FALSE);
+				PHY_RFShadowRecorverFlagSet(Adapter, (RF_RADIO_PATH_E)eRFPath, Offset, false);
 			else
-				PHY_RFShadowRecorverFlagSet(Adapter, (RF_RADIO_PATH_E)eRFPath, Offset, _TRUE);
+				PHY_RFShadowRecorverFlagSet(Adapter, (RF_RADIO_PATH_E)eRFPath, Offset, true);
 		}
 	}
 
@@ -1113,10 +1113,10 @@ PHY_RFShadowRefresh(
 		for (Offset = 0; Offset <= RF6052_MAX_REG; Offset++)
 		{
 			RF_Shadow[eRFPath][Offset].Value = 0;
-			RF_Shadow[eRFPath][Offset].Compare = _FALSE;
-			RF_Shadow[eRFPath][Offset].Recorver  = _FALSE;
-			RF_Shadow[eRFPath][Offset].ErrorOrNot = _FALSE;
-			RF_Shadow[eRFPath][Offset].Driver_Write = _FALSE;
+			RF_Shadow[eRFPath][Offset].Compare = false;
+			RF_Shadow[eRFPath][Offset].Recorver  = false;
+			RF_Shadow[eRFPath][Offset].ErrorOrNot = false;
+			RF_Shadow[eRFPath][Offset].Driver_Write = false;
 		}
 	}
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
@@ -125,7 +125,7 @@ static void query_rx_phy_status(union re
 		if(padapter->pwrctrlpriv.rf_pwrstate == rf_on)
 			cck_highpwr = (u8)pHalData->bCckHighPower;
 		else
-			cck_highpwr = _FALSE;
+			cck_highpwr = false;
 
 		if(!cck_highpwr)
 		{
@@ -563,9 +563,9 @@ void rtl8192d_translate_rx_signal_stuff(
 {
 	struct rx_pkt_attrib	*pattrib = &precvframe->u.hdr.attrib;
 	_adapter				*padapter = precvframe->u.hdr.adapter;
-	u8	bPacketMatchBSSID =_FALSE;
-	u8	bPacketToSelf = _FALSE;
-	u8	bPacketBeacon = _FALSE;
+	u8	bPacketMatchBSSID =false;
+	u8	bPacketToSelf = false;
+	u8	bPacketBeacon = false;
 
 	if((pattrib->physt) && (pphy_info != NULL))
 	{
@@ -580,7 +580,7 @@ void rtl8192d_translate_rx_signal_stuff(
 		query_rx_phy_status(precvframe, pphy_info, bPacketMatchBSSID);
 
 		precvframe->u.hdr.psta = NULL;
-		if(bPacketMatchBSSID && check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == _TRUE)
+		if(bPacketMatchBSSID && check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == true)
 		{
 			u8 *sa;
 			struct sta_info *psta=NULL;
@@ -597,7 +597,7 @@ void rtl8192d_translate_rx_signal_stuff(
 		}
 		else if(bPacketToSelf || bPacketBeacon)
 		{
-			if(check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+			if(check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
 			{
 				u8 *sa;
 				struct sta_info *psta=NULL;
--- a/drivers/staging/rtl8192du/hal/rtl8192du_led.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_led.c
@@ -60,14 +60,14 @@ BlinkWorkItemCallback(
 static void
 ResetLedStatus(PLED_871x	pLed) {
 	pLed->CurrLedState = RTW_LED_OFF; // Current LED state.
-	pLed->bLedOn = _FALSE; // true if LED is ON, false if LED is OFF.
+	pLed->bLedOn = false; // true if LED is ON, false if LED is OFF.
 
-	pLed->bLedBlinkInProgress = _FALSE; // true if it is blinking, false o.w..
-	pLed->bLedNoLinkBlinkInProgress = _FALSE;
-	pLed->bLedLinkBlinkInProgress = _FALSE;
-	pLed->bLedStartToLinkBlinkInProgress = _FALSE;
-	pLed->bLedScanBlinkInProgress = _FALSE;
-	pLed->bLedWPSBlinkInProgress = _FALSE;
+	pLed->bLedBlinkInProgress = false; // true if it is blinking, false o.w..
+	pLed->bLedNoLinkBlinkInProgress = false;
+	pLed->bLedLinkBlinkInProgress = false;
+	pLed->bLedStartToLinkBlinkInProgress = false;
+	pLed->bLedScanBlinkInProgress = false;
+	pLed->bLedWPSBlinkInProgress = false;
 	pLed->BlinkTimes = 0; // Number of times to toggle led state for blinking.
 	pLed->BlinkingLedState = LED_UNKNOWN; // Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are.
 }
@@ -99,9 +99,9 @@ InitLed871x(
 	pLed->LedPin = LedPin;
 
 	pLed->CurrLedState = RTW_LED_OFF;
-	pLed->bLedOn = _FALSE;
+	pLed->bLedOn = false;
 
-	pLed->bLedBlinkInProgress = _FALSE;
+	pLed->bLedBlinkInProgress = false;
 	pLed->BlinkTimes = 0;
 	pLed->BlinkingLedState = LED_UNKNOWN;
 
@@ -154,7 +154,7 @@ SwLedOn(
 {
 	u8	LedCfg;
 
-	if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))
+	if( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
 	{
 		return;
 	}
@@ -184,7 +184,7 @@ SwLedOn(
 			break;
 	}
 
-	pLed->bLedOn = _TRUE;
+	pLed->bLedOn = true;
 
 }
 
@@ -206,7 +206,7 @@ SwLedOff(
 {
 	u8	LedCfg;
 
-	if((padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))
+	if((padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
 	{
              return;
 	}
@@ -238,7 +238,7 @@ SwLedOff(
 			break;
 	}
 
-	pLed->bLedOn = _FALSE;
+	pLed->bLedOn = false;
 
 }
 
@@ -258,7 +258,7 @@ SwLedBlink(
 {
 	_adapter			*padapter = pLed->padapter;
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-	u8				bStopBlinking = _FALSE;
+	u8				bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
 	if( pLed->BlinkingLedState == RTW_LED_ON )
@@ -280,36 +280,36 @@ SwLedBlink(
 	case LED_BLINK_NORMAL:
 		if(pLed->BlinkTimes == 0)
 		{
-			bStopBlinking = _TRUE;
+			bStopBlinking = true;
 		}
 		break;
 
 	case LED_BLINK_StartToBlink:
 		if( check_fwstate(pmlmepriv, _FW_LINKED) && check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
 		{
-			bStopBlinking = _TRUE;
+			bStopBlinking = true;
 		}
 		if( check_fwstate(pmlmepriv, _FW_LINKED) &&
 			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) )
 		{
-			bStopBlinking = _TRUE;
+			bStopBlinking = true;
 		}
 		else if(pLed->BlinkTimes == 0)
 		{
-			bStopBlinking = _TRUE;
+			bStopBlinking = true;
 		}
 		break;
 
 	case LED_BLINK_WPS:
 		if( pLed->BlinkTimes == 0 )
 		{
-			bStopBlinking = _TRUE;
+			bStopBlinking = true;
 		}
 		break;
 
 
 	default:
-		bStopBlinking = _TRUE;
+		bStopBlinking = true;
 		break;
 
 	}
@@ -320,17 +320,17 @@ SwLedBlink(
 		{
 			SwLedOff(padapter, pLed);
 		}
-		else if( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) && (pLed->bLedOn == _FALSE))
+		else if( (check_fwstate(pmlmepriv, _FW_LINKED)== true) && (pLed->bLedOn == false))
 		{
 			SwLedOn(padapter, pLed);
 		}
-		else if( (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) &&  pLed->bLedOn == _TRUE)
+		else if( (check_fwstate(pmlmepriv, _FW_LINKED)== true) &&  pLed->bLedOn == true)
 		{
 			SwLedOff(padapter, pLed);
 		}
 
 		pLed->BlinkTimes = 0;
-		pLed->bLedBlinkInProgress = _FALSE;
+		pLed->bLedBlinkInProgress = false;
 	}
 	else
 	{
@@ -381,7 +381,7 @@ SwLedBlink1(
 	struct led_priv		*ledpriv = &(padapter->ledpriv);
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
 	PLED_871x			pLed1 = &(ledpriv->SwLed1);
-	u8					bStopBlinking = _FALSE;
+	u8					bStopBlinking = false;
 
 	if(pHalData->CustomerID == RT_CID_819x_CAMEO)
 		pLed = &(ledpriv->SwLed1);
@@ -401,12 +401,12 @@ SwLedBlink1(
 
 	if(pHalData->CustomerID == RT_CID_DEFAULT)
 	{
-		if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+		if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
 		{
 			if(!pLed1->bSWLedCtrl)
 			{
 				SwLedOn(padapter, pLed1);
-				pLed1->bSWLedCtrl = _TRUE;
+				pLed1->bSWLedCtrl = true;
 			}
 			else if(!pLed1->bLedOn)
 				SwLedOn(padapter, pLed1);
@@ -417,7 +417,7 @@ SwLedBlink1(
 			if(!pLed1->bSWLedCtrl)
 			{
 				SwLedOff(padapter, pLed1);
-				pLed1->bSWLedCtrl = _TRUE;
+				pLed1->bSWLedCtrl = true;
 			}
 			else if(pLed1->bLedOn)
 				SwLedOff(padapter, pLed1);
@@ -447,7 +447,7 @@ SwLedBlink1(
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
-				bStopBlinking = _TRUE;
+				bStopBlinking = true;
 			}
 
 			if(bStopBlinking)
@@ -456,9 +456,9 @@ SwLedBlink1(
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
-					pLed->bLedLinkBlinkInProgress = _TRUE;
+					pLed->bLedLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_NORMAL;
 					if( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
@@ -468,9 +468,9 @@ SwLedBlink1(
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
-					pLed->bLedNoLinkBlinkInProgress = _TRUE;
+					pLed->bLedNoLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
 					if( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
@@ -479,7 +479,7 @@ SwLedBlink1(
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
-				pLed->bLedScanBlinkInProgress = _FALSE;
+				pLed->bLedScanBlinkInProgress = false;
 			}
 			else
 			{
@@ -502,7 +502,7 @@ SwLedBlink1(
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
-				bStopBlinking = _TRUE;
+				bStopBlinking = true;
 			}
 			if(bStopBlinking)
 			{
@@ -510,9 +510,9 @@ SwLedBlink1(
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
-					pLed->bLedLinkBlinkInProgress = _TRUE;
+					pLed->bLedLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_NORMAL;
 					if( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
@@ -521,9 +521,9 @@ SwLedBlink1(
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
-					pLed->bLedNoLinkBlinkInProgress = _TRUE;
+					pLed->bLedNoLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
 					if( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
@@ -533,7 +533,7 @@ SwLedBlink1(
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
 				pLed->BlinkTimes = 0;
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
 			else
 			{
@@ -565,11 +565,11 @@ SwLedBlink1(
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
-				bStopBlinking = _FALSE;
+				bStopBlinking = false;
 			}
 			else
 			{
-				bStopBlinking = _TRUE;
+				bStopBlinking = true;
 			}
 
 			if(bStopBlinking)
@@ -580,7 +580,7 @@ SwLedBlink1(
 				}
 				else
 				{
-					pLed->bLedLinkBlinkInProgress = _TRUE;
+					pLed->bLedLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_NORMAL;
 					if( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
@@ -589,7 +589,7 @@ SwLedBlink1(
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = false;
 			}
 			break;
 
@@ -609,7 +609,7 @@ SwLedBlink2(
 {
 	_adapter				*padapter = pLed->padapter;
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
-	u8					bStopBlinking = _FALSE;
+	u8					bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
 	if( pLed->BlinkingLedState == RTW_LED_ON)
@@ -629,7 +629,7 @@ SwLedBlink2(
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
-				bStopBlinking = _TRUE;
+				bStopBlinking = true;
 			}
 
 			if(bStopBlinking)
@@ -638,7 +638,7 @@ SwLedBlink2(
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
 					pLed->CurrLedState = RTW_LED_ON;
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -646,14 +646,14 @@ SwLedBlink2(
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
 
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
 					SwLedOff(padapter, pLed);
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
 				}
-				pLed->bLedScanBlinkInProgress = _FALSE;
+				pLed->bLedScanBlinkInProgress = false;
 			}
 			else
 			{
@@ -676,7 +676,7 @@ SwLedBlink2(
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
-				bStopBlinking = _TRUE;
+				bStopBlinking = true;
 			}
 			if(bStopBlinking)
 			{
@@ -684,7 +684,7 @@ SwLedBlink2(
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
 					pLed->CurrLedState = RTW_LED_ON;
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -692,14 +692,14 @@ SwLedBlink2(
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
 
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
 					SwLedOff(padapter, pLed);
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
 				}
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
 			else
 			{
@@ -734,7 +734,7 @@ SwLedBlink3(
 {
 	_adapter			*padapter = pLed->padapter;
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-	u8				bStopBlinking = _FALSE;
+	u8				bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
 	if( pLed->BlinkingLedState == RTW_LED_ON )
@@ -755,7 +755,7 @@ SwLedBlink3(
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
-				bStopBlinking = _TRUE;
+				bStopBlinking = true;
 			}
 
 			if(bStopBlinking)
@@ -764,7 +764,7 @@ SwLedBlink3(
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
 					pLed->CurrLedState = RTW_LED_ON;
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -773,7 +773,7 @@ SwLedBlink3(
 
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
@@ -782,7 +782,7 @@ SwLedBlink3(
 
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
-				pLed->bLedScanBlinkInProgress = _FALSE;
+				pLed->bLedScanBlinkInProgress = false;
 			}
 			else
 			{
@@ -805,7 +805,7 @@ SwLedBlink3(
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
-				bStopBlinking = _TRUE;
+				bStopBlinking = true;
 			}
 			if(bStopBlinking)
 			{
@@ -813,7 +813,7 @@ SwLedBlink3(
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
 					pLed->CurrLedState = RTW_LED_ON;
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -823,7 +823,7 @@ SwLedBlink3(
 
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
-				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
+				else if(check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
@@ -834,7 +834,7 @@ SwLedBlink3(
 
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
 			else
 			{
@@ -866,11 +866,11 @@ SwLedBlink3(
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
-				bStopBlinking = _FALSE;
+				bStopBlinking = false;
 			}
 			else
 			{
-				bStopBlinking = _TRUE;
+				bStopBlinking = true;
 			}
 
 			if(bStopBlinking)
@@ -886,7 +886,7 @@ SwLedBlink3(
 					SwLedOn(padapter, pLed);
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 				}
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = false;
 			}
 			break;
 
@@ -908,7 +908,7 @@ SwLedBlink4(
 	_adapter			*padapter = pLed->padapter;
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 	PLED_871x		pLed1 = &(ledpriv->SwLed1);
-	u8				bStopBlinking = _FALSE;
+	u8				bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
 	if( pLed->BlinkingLedState == RTW_LED_ON )
@@ -956,7 +956,7 @@ SwLedBlink4(
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
-				bStopBlinking = _FALSE;
+				bStopBlinking = false;
 			}
 
 			if(bStopBlinking)
@@ -967,7 +967,7 @@ SwLedBlink4(
 				}
 				else
 				{
-					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+					pLed->bLedNoLinkBlinkInProgress = false;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
 					if( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
@@ -975,7 +975,7 @@ SwLedBlink4(
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 				}
-				pLed->bLedScanBlinkInProgress = _FALSE;
+				pLed->bLedScanBlinkInProgress = false;
 			}
 			else
 			{
@@ -998,7 +998,7 @@ SwLedBlink4(
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
-				bStopBlinking = _TRUE;
+				bStopBlinking = true;
 			}
 			if(bStopBlinking)
 			{
@@ -1008,7 +1008,7 @@ SwLedBlink4(
 				}
 				else
 				{
-					pLed->bLedNoLinkBlinkInProgress = _TRUE;
+					pLed->bLedNoLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
 					if( pLed->bLedOn )
 						pLed->BlinkingLedState = RTW_LED_OFF;
@@ -1016,7 +1016,7 @@ SwLedBlink4(
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 				}
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
 			else
 			{
@@ -1067,7 +1067,7 @@ SwLedBlink4(
 				}
 				else
 				{
-					bStopBlinking = _TRUE;
+					bStopBlinking = true;
 				}
 			}
 
@@ -1107,7 +1107,7 @@ SwLedBlink5(
 	)
 {
 	_adapter			*padapter = pLed->padapter;
-	u8				bStopBlinking = _FALSE;
+	u8				bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
 	if( pLed->BlinkingLedState == RTW_LED_ON )
@@ -1127,7 +1127,7 @@ SwLedBlink5(
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
-				bStopBlinking = _TRUE;
+				bStopBlinking = true;
 			}
 
 			if(bStopBlinking)
@@ -1146,7 +1146,7 @@ SwLedBlink5(
 							_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 
-				pLed->bLedScanBlinkInProgress = _FALSE;
+				pLed->bLedScanBlinkInProgress = false;
 			}
 			else
 			{
@@ -1170,7 +1170,7 @@ SwLedBlink5(
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
-				bStopBlinking = _TRUE;
+				bStopBlinking = true;
 			}
 
 			if(bStopBlinking)
@@ -1190,7 +1190,7 @@ SwLedBlink5(
 						_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
 			else
 			{
@@ -1231,7 +1231,7 @@ BlinkTimerCallback(
 	PLED_871x	 pLed = (PLED_871x)data;
 	_adapter		*padapter = pLed->padapter;
 
-	 if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))
+	 if( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
        {
              return;
        }
@@ -1251,7 +1251,7 @@ void BlinkWorkItemCallback(struct work_s
 	struct led_priv	*ledpriv = &(pLed->padapter->ledpriv);
 	_adapter		*padapter = pLed->padapter;
 
-	 if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))
+	 if( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
        {
              return;
        }
@@ -1317,9 +1317,9 @@ SwLedControlMode0(
 	{
 	case LED_CTL_TX:
 	case LED_CTL_RX:
-		if( pLed->bLedBlinkInProgress == _FALSE )
+		if( pLed->bLedBlinkInProgress == false )
 		{
-			pLed->bLedBlinkInProgress = _TRUE;
+			pLed->bLedBlinkInProgress = true;
 
 			pLed->CurrLedState = LED_BLINK_NORMAL;
 			pLed->BlinkTimes = 2;
@@ -1333,9 +1333,9 @@ SwLedControlMode0(
 		break;
 
 	case LED_CTL_START_TO_LINK:
-		if( pLed->bLedBlinkInProgress == _FALSE )
+		if( pLed->bLedBlinkInProgress == false )
 		{
-			pLed->bLedBlinkInProgress = _TRUE;
+			pLed->bLedBlinkInProgress = true;
 
 			pLed->CurrLedState = LED_BLINK_StartToBlink;
 			pLed->BlinkTimes = 24;
@@ -1354,7 +1354,7 @@ SwLedControlMode0(
 
 	case LED_CTL_LINK:
 		pLed->CurrLedState = RTW_LED_ON;
-		if( pLed->bLedBlinkInProgress == _FALSE )
+		if( pLed->bLedBlinkInProgress == false )
 		{
 			SwLedOn(padapter, pLed);
 		}
@@ -1362,7 +1362,7 @@ SwLedControlMode0(
 
 	case LED_CTL_NO_LINK:
 		pLed->CurrLedState = RTW_LED_OFF;
-		if( pLed->bLedBlinkInProgress == _FALSE )
+		if( pLed->bLedBlinkInProgress == false )
 		{
 			SwLedOff(padapter, pLed);
 		}
@@ -1375,15 +1375,15 @@ SwLedControlMode0(
 		if(pLed->bLedBlinkInProgress)
 		{
 			_cancel_timer_ex(&(pLed->BlinkTimer));
-			pLed->bLedBlinkInProgress = _FALSE;
+			pLed->bLedBlinkInProgress = false;
 		}
 		SwLedOff(padapter, pLed);
 		break;
 
 	case LED_CTL_START_WPS:
-		if( pLed->bLedBlinkInProgress == _FALSE || pLed->CurrLedState == RTW_LED_ON)
+		if( pLed->bLedBlinkInProgress == false || pLed->CurrLedState == RTW_LED_ON)
 		{
-			pLed->bLedBlinkInProgress = _TRUE;
+			pLed->bLedBlinkInProgress = true;
 
 			pLed->CurrLedState = LED_BLINK_WPS;
 			pLed->BlinkTimes = 20;
@@ -1406,7 +1406,7 @@ SwLedControlMode0(
 		{
 			pLed->CurrLedState = RTW_LED_OFF;
 			_cancel_timer_ex(&(pLed->BlinkTimer));
-			pLed->bLedBlinkInProgress = _FALSE;
+			pLed->bLedBlinkInProgress = false;
 		}
 		break;
 
@@ -1443,24 +1443,24 @@ SwLedControlMode1(
 	{
 		case LED_CTL_START_TO_LINK:
 		case LED_CTL_NO_LINK:
-			if( pLed->bLedNoLinkBlinkInProgress == _FALSE )
+			if( pLed->bLedNoLinkBlinkInProgress == false )
 			{
 				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if( pLed->bLedLinkBlinkInProgress == _TRUE )
+				if( pLed->bLedLinkBlinkInProgress == true )
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedLinkBlinkInProgress = _FALSE;
+					pLed->bLedLinkBlinkInProgress = false;
 				}
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
 
-				pLed->bLedNoLinkBlinkInProgress = _TRUE;
+				pLed->bLedNoLinkBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_SLOWLY;
 				if( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
@@ -1471,23 +1471,23 @@ SwLedControlMode1(
 			break;
 
 		case LED_CTL_LINK:
-			if( pLed->bLedLinkBlinkInProgress == _FALSE )
+			if( pLed->bLedLinkBlinkInProgress == false )
 			{
 				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				if(pLed->bLedNoLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
-				pLed->bLedLinkBlinkInProgress = _TRUE;
+				pLed->bLedLinkBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_NORMAL;
 				if( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
@@ -1498,29 +1498,29 @@ SwLedControlMode1(
 			break;
 
 		case LED_CTL_SITE_SURVEY:
-			 if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+			 if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 				;
-			 else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			 else if(pLed->bLedScanBlinkInProgress ==false)
 			 {
 				if(IS_LED_WPS_BLINKING(pLed))
 					return;
 
-				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				if(pLed->bLedNoLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				if( pLed->bLedLinkBlinkInProgress == _TRUE )
+				if( pLed->bLedLinkBlinkInProgress == true )
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					 pLed->bLedLinkBlinkInProgress = _FALSE;
+					 pLed->bLedLinkBlinkInProgress = false;
 				}
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
-				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
 				if( pLed->bLedOn )
@@ -1533,23 +1533,23 @@ SwLedControlMode1(
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if(pLed->bLedBlinkInProgress ==_FALSE)
+			if(pLed->bLedBlinkInProgress ==false)
 			{
                             if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
                             {
 					return;
                             }
-                            if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+                            if(pLed->bLedNoLinkBlinkInProgress == true)
                             {
                                 _cancel_timer_ex(&(pLed->BlinkTimer));
-                                pLed->bLedNoLinkBlinkInProgress = _FALSE;
+                                pLed->bLedNoLinkBlinkInProgress = false;
                             }
-                            if( pLed->bLedLinkBlinkInProgress == _TRUE )
+                            if( pLed->bLedLinkBlinkInProgress == true )
                             {
                                 _cancel_timer_ex(&(pLed->BlinkTimer));
-                                pLed->bLedLinkBlinkInProgress = _FALSE;
+                                pLed->bLedLinkBlinkInProgress = false;
                             }
-                            pLed->bLedBlinkInProgress = _TRUE;
+                            pLed->bLedBlinkInProgress = true;
                             pLed->CurrLedState = LED_TXRX_BLINK;
                             pLed->BlinkTimes = 2;
                             if( pLed->bLedOn )
@@ -1562,29 +1562,29 @@ SwLedControlMode1(
 
 		case LED_CTL_START_WPS: //wait until xinpin finish
 		case LED_CTL_START_WPS_BOTTON:
-			 if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			 if(pLed->bLedWPSBlinkInProgress ==false)
 			 {
-				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				if(pLed->bLedNoLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				if( pLed->bLedLinkBlinkInProgress == _TRUE )
+				if( pLed->bLedLinkBlinkInProgress == true )
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					 pLed->bLedLinkBlinkInProgress = _FALSE;
+					 pLed->bLedLinkBlinkInProgress = false;
 				}
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
-				if(pLed->bLedScanBlinkInProgress ==_TRUE)
+				if(pLed->bLedScanBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedScanBlinkInProgress = _FALSE;
+					pLed->bLedScanBlinkInProgress = false;
 				}
-				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->bLedWPSBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_WPS;
 				if( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
@@ -1596,25 +1596,25 @@ SwLedControlMode1(
 
 
 		case LED_CTL_STOP_WPS:
-			if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+			if(pLed->bLedNoLinkBlinkInProgress == true)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				pLed->bLedNoLinkBlinkInProgress = false;
 			}
-			if( pLed->bLedLinkBlinkInProgress == _TRUE )
+			if( pLed->bLedLinkBlinkInProgress == true )
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				 pLed->bLedLinkBlinkInProgress = _FALSE;
+				 pLed->bLedLinkBlinkInProgress = false;
 			}
-			if(pLed->bLedBlinkInProgress ==_TRUE)
+			if(pLed->bLedBlinkInProgress ==true)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
-			if(pLed->bLedScanBlinkInProgress ==_TRUE)
+			if(pLed->bLedScanBlinkInProgress ==true)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = _FALSE;
+				pLed->bLedScanBlinkInProgress = false;
 			}
 			if(pLed->bLedWPSBlinkInProgress)
 			{
@@ -1622,7 +1622,7 @@ SwLedControlMode1(
 			}
 			else
 			{
-				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->bLedWPSBlinkInProgress = true;
 			}
 
 			pLed->CurrLedState = LED_BLINK_WPS_STOP;
@@ -1642,10 +1642,10 @@ SwLedControlMode1(
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = false;
 			}
 
-			pLed->bLedNoLinkBlinkInProgress = _TRUE;
+			pLed->bLedNoLinkBlinkInProgress = true;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
 			if( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
@@ -1661,27 +1661,27 @@ SwLedControlMode1(
 			if( pLed->bLedNoLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				pLed->bLedNoLinkBlinkInProgress = false;
 			}
 			if( pLed->bLedLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedLinkBlinkInProgress = _FALSE;
+				pLed->bLedLinkBlinkInProgress = false;
 			}
 			if( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
 			if( pLed->bLedWPSBlinkInProgress )
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = false;
 			}
 			if( pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = _FALSE;
+				pLed->bLedScanBlinkInProgress = false;
 			}
 
 			SwLedOff(padapter, pLed);
@@ -1716,17 +1716,17 @@ SwLedControlMode2(
 		case LED_CTL_SITE_SURVEY:
 			 if(pmlmepriv->LinkDetectInfo.bBusyTraffic)
 				;
-			 else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			 else if(pLed->bLedScanBlinkInProgress ==false)
 			 {
 				if(IS_LED_WPS_BLINKING(pLed))
 					return;
 
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
-				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
 				if( pLed->bLedOn )
@@ -1739,14 +1739,14 @@ SwLedControlMode2(
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if((pLed->bLedBlinkInProgress ==_FALSE) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+			if((pLed->bLedBlinkInProgress ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 			{
 				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
 
-				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->bLedBlinkInProgress = true;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
 				if( pLed->bLedOn )
@@ -1763,12 +1763,12 @@ SwLedControlMode2(
 			if( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
 			if( pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = _FALSE;
+				pLed->bLedScanBlinkInProgress = false;
 			}
 
 			_set_timer(&(pLed->BlinkTimer), 0);
@@ -1776,19 +1776,19 @@ SwLedControlMode2(
 
 		case LED_CTL_START_WPS: //wait until xinpin finish
 		case LED_CTL_START_WPS_BOTTON:
-			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			if(pLed->bLedWPSBlinkInProgress ==false)
 			{
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
-				if(pLed->bLedScanBlinkInProgress ==_TRUE)
+				if(pLed->bLedScanBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedScanBlinkInProgress = _FALSE;
+					pLed->bLedScanBlinkInProgress = false;
 				}
-				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->bLedWPSBlinkInProgress = true;
 				pLed->CurrLedState = RTW_LED_ON;
 				pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), 0);
@@ -1796,7 +1796,7 @@ SwLedControlMode2(
 			break;
 
 		case LED_CTL_STOP_WPS:
-			pLed->bLedWPSBlinkInProgress = _FALSE;
+			pLed->bLedWPSBlinkInProgress = false;
 			if(padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 			{
 				SwLedOff(padapter, pLed);
@@ -1811,7 +1811,7 @@ SwLedControlMode2(
 			break;
 
 		case LED_CTL_STOP_WPS_FAIL:
-			pLed->bLedWPSBlinkInProgress = _FALSE;
+			pLed->bLedWPSBlinkInProgress = false;
 			if(padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 			{
 				SwLedOff(padapter, pLed);
@@ -1841,17 +1841,17 @@ SwLedControlMode2(
 			if( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
 			if( pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = _FALSE;
+				pLed->bLedScanBlinkInProgress = false;
 			}
 			if( pLed->bLedWPSBlinkInProgress )
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = false;
 			}
 
 			_set_timer(&(pLed->BlinkTimer), 0);
@@ -1886,17 +1886,17 @@ SwLedControlMode2(
 		case LED_CTL_SITE_SURVEY:
 			if(pmlmepriv->LinkDetectInfo.bBusyTraffic)
 				;
-			else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			else if(pLed->bLedScanBlinkInProgress ==false)
 			{
 				if(IS_LED_WPS_BLINKING(pLed))
 					return;
 
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
-				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
 				if( pLed->bLedOn )
@@ -1909,14 +1909,14 @@ SwLedControlMode2(
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if((pLed->bLedBlinkInProgress ==_FALSE) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+			if((pLed->bLedBlinkInProgress ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 			{
 				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
 
-				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->bLedBlinkInProgress = true;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
 				if( pLed->bLedOn )
@@ -1936,12 +1936,12 @@ SwLedControlMode2(
 			if( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
 			if( pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = _FALSE;
+				pLed->bLedScanBlinkInProgress = false;
 			}
 
 			_set_timer(&(pLed->BlinkTimer), 0);
@@ -1949,19 +1949,19 @@ SwLedControlMode2(
 
 		case LED_CTL_START_WPS: //wait until xinpin finish
 		case LED_CTL_START_WPS_BOTTON:
-			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			if(pLed->bLedWPSBlinkInProgress ==false)
 			{
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
-				if(pLed->bLedScanBlinkInProgress ==_TRUE)
+				if(pLed->bLedScanBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedScanBlinkInProgress = _FALSE;
+					pLed->bLedScanBlinkInProgress = false;
 				}
-				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->bLedWPSBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_WPS;
 				if( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
@@ -1975,11 +1975,11 @@ SwLedControlMode2(
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = false;
 			}
 			else
 			{
-				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->bLedWPSBlinkInProgress = true;
 			}
 
 			pLed->CurrLedState = LED_BLINK_WPS_STOP;
@@ -2000,7 +2000,7 @@ SwLedControlMode2(
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = false;
 			}
 
 			pLed->CurrLedState = RTW_LED_OFF;
@@ -2024,17 +2024,17 @@ SwLedControlMode2(
 			if( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
 			if( pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = _FALSE;
+				pLed->bLedScanBlinkInProgress = false;
 			}
 			if( pLed->bLedWPSBlinkInProgress )
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = false;
 			}
 
 			_set_timer(&(pLed->BlinkTimer), 0);
@@ -2071,7 +2071,7 @@ SwLedControlMode4(
 		case LED_CTL_START_TO_LINK:
 			if(pLed1->bLedWPSBlinkInProgress)
 			{
-				pLed1->bLedWPSBlinkInProgress = _FALSE;
+				pLed1->bLedWPSBlinkInProgress = false;
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
 
 				pLed1->BlinkingLedState = RTW_LED_OFF;
@@ -2081,24 +2081,24 @@ SwLedControlMode4(
 					_set_timer(&(pLed->BlinkTimer), 0);
 			}
 
-			if( pLed->bLedStartToLinkBlinkInProgress == _FALSE )
+			if( pLed->bLedStartToLinkBlinkInProgress == false )
 			{
 				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
-				if(pLed->bLedNoLinkBlinkInProgress ==_TRUE)
+				if(pLed->bLedNoLinkBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+					pLed->bLedNoLinkBlinkInProgress = false;
 				}
 
-				pLed->bLedStartToLinkBlinkInProgress = _TRUE;
+				pLed->bLedStartToLinkBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_StartToBlink;
 				if( pLed->bLedOn )
 				{
@@ -2120,7 +2120,7 @@ SwLedControlMode4(
 			{
 				if(pLed1->bLedWPSBlinkInProgress)
 				{
-					pLed1->bLedWPSBlinkInProgress = _FALSE;
+					pLed1->bLedWPSBlinkInProgress = false;
 					_cancel_timer_ex(&(pLed1->BlinkTimer));
 
 					pLed1->BlinkingLedState = RTW_LED_OFF;
@@ -2131,19 +2131,19 @@ SwLedControlMode4(
 				}
 			}
 
-			if( pLed->bLedNoLinkBlinkInProgress == _FALSE )
+			if( pLed->bLedNoLinkBlinkInProgress == false )
 			{
 				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
 
-				pLed->bLedNoLinkBlinkInProgress = _TRUE;
+				pLed->bLedNoLinkBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_SLOWLY;
 				if( pLed->bLedOn )
 					pLed->BlinkingLedState = RTW_LED_OFF;
@@ -2154,24 +2154,24 @@ SwLedControlMode4(
 			break;
 
 		case LED_CTL_SITE_SURVEY:
-			if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+			if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 				;
-			else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			else if(pLed->bLedScanBlinkInProgress ==false)
 			{
 				if(IS_LED_WPS_BLINKING(pLed))
 					return;
 
-				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				if(pLed->bLedNoLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
-				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
 				if( pLed->bLedOn )
@@ -2184,18 +2184,18 @@ SwLedControlMode4(
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if(pLed->bLedBlinkInProgress ==_FALSE)
+			if(pLed->bLedBlinkInProgress ==false)
 			{
 				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				if(pLed->bLedNoLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->bLedBlinkInProgress = true;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
 				if( pLed->bLedOn )
@@ -2210,7 +2210,7 @@ SwLedControlMode4(
 		case LED_CTL_START_WPS_BOTTON:
 			if(pLed1->bLedWPSBlinkInProgress)
 			{
-				pLed1->bLedWPSBlinkInProgress = _FALSE;
+				pLed1->bLedWPSBlinkInProgress = false;
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
 
 				pLed1->BlinkingLedState = RTW_LED_OFF;
@@ -2220,24 +2220,24 @@ SwLedControlMode4(
 					_set_timer(&(pLed->BlinkTimer), 0);
 			}
 
-			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
+			if(pLed->bLedWPSBlinkInProgress ==false)
 			{
-				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				if(pLed->bLedNoLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = _FALSE;
+					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
-				if(pLed->bLedScanBlinkInProgress ==_TRUE)
+				if(pLed->bLedScanBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedScanBlinkInProgress = _FALSE;
+					pLed->bLedScanBlinkInProgress = false;
 				}
-				pLed->bLedWPSBlinkInProgress = _TRUE;
+				pLed->bLedWPSBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_WPS;
 				if( pLed->bLedOn )
 				{
@@ -2256,10 +2256,10 @@ SwLedControlMode4(
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = false;
 			}
 
-			pLed->bLedNoLinkBlinkInProgress = _TRUE;
+			pLed->bLedNoLinkBlinkInProgress = true;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
 			if( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
@@ -2273,10 +2273,10 @@ SwLedControlMode4(
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = false;
 			}
 
-			pLed->bLedNoLinkBlinkInProgress = _TRUE;
+			pLed->bLedNoLinkBlinkInProgress = true;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
 			if( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
@@ -2288,7 +2288,7 @@ SwLedControlMode4(
 			if(pLed1->bLedWPSBlinkInProgress)
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
 			else
-				pLed1->bLedWPSBlinkInProgress = _TRUE;
+				pLed1->bLedWPSBlinkInProgress = true;
 
 			pLed1->CurrLedState = LED_BLINK_WPS_STOP;
 			if( pLed1->bLedOn )
@@ -2303,10 +2303,10 @@ SwLedControlMode4(
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = false;
 			}
 
-			pLed->bLedNoLinkBlinkInProgress = _TRUE;
+			pLed->bLedNoLinkBlinkInProgress = true;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
 			if( pLed->bLedOn )
 				pLed->BlinkingLedState = RTW_LED_OFF;
@@ -2318,7 +2318,7 @@ SwLedControlMode4(
 			if(pLed1->bLedWPSBlinkInProgress)
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
 			else
-				pLed1->bLedWPSBlinkInProgress = _TRUE;
+				pLed1->bLedWPSBlinkInProgress = true;
 
 			pLed1->CurrLedState = LED_BLINK_WPS_STOP_OVERLAP;
 			pLed1->BlinkTimes = 10;
@@ -2337,38 +2337,38 @@ SwLedControlMode4(
 			if( pLed->bLedNoLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedNoLinkBlinkInProgress = _FALSE;
+				pLed->bLedNoLinkBlinkInProgress = false;
 			}
 			if( pLed->bLedLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedLinkBlinkInProgress = _FALSE;
+				pLed->bLedLinkBlinkInProgress = false;
 			}
 			if( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
 			if( pLed->bLedWPSBlinkInProgress )
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = false;
 			}
 			if( pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = _FALSE;
+				pLed->bLedScanBlinkInProgress = false;
 			}
 			if( pLed->bLedStartToLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedStartToLinkBlinkInProgress = _FALSE;
+				pLed->bLedStartToLinkBlinkInProgress = false;
 			}
 
 			if( pLed1->bLedWPSBlinkInProgress )
 			{
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
-				pLed1->bLedWPSBlinkInProgress = _FALSE;
+				pLed1->bLedWPSBlinkInProgress = false;
 			}
 
 			pLed1->BlinkingLedState = LED_UNKNOWN;
@@ -2418,16 +2418,16 @@ SwLedControlMode5(
 			break;
 
 		case LED_CTL_SITE_SURVEY:
-			if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+			if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 				;
-			else if(pLed->bLedScanBlinkInProgress ==_FALSE)
+			else if(pLed->bLedScanBlinkInProgress ==false)
 			{
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+				if(pLed->bLedBlinkInProgress ==true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = _FALSE;
+					pLed->bLedBlinkInProgress = false;
 				}
-				pLed->bLedScanBlinkInProgress = _TRUE;
+				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
 				if( pLed->bLedOn )
@@ -2440,13 +2440,13 @@ SwLedControlMode5(
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if(pLed->bLedBlinkInProgress ==_FALSE)
+			if(pLed->bLedBlinkInProgress ==false)
 			{
 				if(pLed->CurrLedState == LED_SCAN_BLINK)
 				{
 					return;
 				}
-				pLed->bLedBlinkInProgress = _TRUE;
+				pLed->bLedBlinkInProgress = true;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
 				if( pLed->bLedOn )
@@ -2464,7 +2464,7 @@ SwLedControlMode5(
 			if( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = false;
 			}
 
 			SwLedOff(padapter, pLed);
@@ -2496,12 +2496,12 @@ LedControl871x(
 {
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 
-       if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))
+       if( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
        {
              return;
        }
 
-	if( ledpriv->bRegUseLed == _FALSE)
+	if( ledpriv->bRegUseLed == false)
 		return;
 
 	//if (!priv->up)
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -263,7 +263,7 @@ static s32 update_txdesc(struct xmit_fra
 if (padapter->registrypriv.mp_mode == 0)
 {
 
-	if((_FALSE == bagg_pkt) && (urb_zero_packet_chk(padapter, sz)==0))
+	if((false == bagg_pkt) && (urb_zero_packet_chk(padapter, sz)==0))
 	{
 		ptxdesc = (struct tx_desc *)(pmem+PACKET_OFFSET_SZ);
 		pull = 1;
@@ -288,10 +288,10 @@ if (padapter->registrypriv.mp_mode == 0)
 
 		fill_txdesc_sectype(pattrib, ptxdesc);
 
-		if(pattrib->ampdu_en==_TRUE){
+		if(pattrib->ampdu_en==true){
 			ptxdesc->txdw1 |= cpu_to_le32(BIT(5));//AGG EN
 			//Insert Early Mode Content after tx desc position.
-			if((pHalData->bEarlyModeEnable) && (_TRUE == bagg_pkt)){
+			if((pHalData->bEarlyModeEnable) && (true == bagg_pkt)){
 				ptxdesc->txdw0 |= cpu_to_le32(((USB_HWDESC_HEADER_LEN-8) << OFFSET_SHT) & 0x00ff0000);//32 bytes for TX Desc
 				if(pxmitframe->EMPktNum > 0){
 					InsertEMContent(pxmitframe, pmem+TXDESC_SIZE);
@@ -411,7 +411,7 @@ if (padapter->registrypriv.mp_mode == 0)
 
 		//offset 20
 #ifdef CONFIG_AP_MODE
-		if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+		if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		{
 			ptxdesc->txdw5 |= cpu_to_le32(BIT(17));//retry limit enable
 #ifdef CONFIG_P2P
@@ -426,7 +426,7 @@ if (padapter->registrypriv.mp_mode == 0)
 #endif
 
 #ifdef CONFIG_INTEL_PROXIM
-		if((padapter->proximity.proxim_on==_TRUE)&&(pattrib->intel_proxim==_TRUE)){
+		if((padapter->proximity.proxim_on==true)&&(pattrib->intel_proxim==true)){
 			printk("\n %s pattrib->rate=%d\n",__FUNCTION__,pattrib->rate);
 			ptxdesc->txdw5 |= cpu_to_le32( pattrib->rate);
 		}
@@ -568,7 +568,7 @@ s32 rtw_dump_xframe(_adapter *padapter,
 			sz = pattrib->last_txcmdsz;
 		}
 
-		pull = update_txdesc(pxmitframe, mem_addr, sz, _FALSE);
+		pull = update_txdesc(pxmitframe, mem_addr, sz, false);
 
 		if(pull)
 		{
@@ -648,7 +648,7 @@ void UpdateEarlyModeInfo8192D(_adapter *
 
 	xmitframe_phead = get_list_head(&ptxservq->sta_pending);
 	xmitframe_plist = get_next(xmitframe_phead);
-	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist) == _FALSE)&&(pxmitframe->EMPktNum < 5))
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist) == false)&&(pxmitframe->EMPktNum < 5))
 	{
 		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 		xmitframe_plist = get_next(xmitframe_plist);
@@ -683,8 +683,8 @@ s32 rtl8192du_xmitframe_complete(_adapte
 	u32	bulkPtr=0;
 	u8	descCount=0;
 	u8	ac_index;
-	u8	bfirst = _TRUE;//first aggregation xmitframe
-	u8	bulkstart = _FALSE;
+	u8	bfirst = true;//first aggregation xmitframe
+	u8	bulkstart = false;
 
 	// dump frame variable
 	u32 ff_hwaddr;
@@ -698,7 +698,7 @@ s32 rtl8192du_xmitframe_complete(_adapte
 	// check xmitbuffer is ok
 	if (pxmitbuf == NULL) {
 		pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
-		if (pxmitbuf == NULL) return _FALSE;
+		if (pxmitbuf == NULL) return false;
 	}
 
 	if(pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY)
@@ -714,7 +714,7 @@ s32 rtl8192du_xmitframe_complete(_adapte
 			if (pxmitframe == NULL) {
 				// no more xmit frame, release xmit buffer
 				rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
-				return _FALSE;
+				return false;
 			}
 
 			pxmitframe->pxmitbuf = pxmitbuf;
@@ -735,7 +735,7 @@ s32 rtl8192du_xmitframe_complete(_adapte
 			// dequeue same priority packet from station tx queue
 			_enter_critical_bh(&pxmitpriv->lock, &irqL);
 
-			if (_rtw_queue_empty(&ptxservq->sta_pending) == _FALSE)
+			if (_rtw_queue_empty(&ptxservq->sta_pending) == false)
 			{
 				xmitframe_phead = get_list_head(&ptxservq->sta_pending);
 				xmitframe_plist = get_next(xmitframe_phead);
@@ -746,7 +746,7 @@ s32 rtl8192du_xmitframe_complete(_adapte
 				len = xmitframe_need_length(pxmitframe) + TXDESC_SIZE + ((USB_92D_DUMMY_OFFSET - 1) * PACKET_OFFSET_SZ);
 				if (pbuf + _RND8(len) > aggMaxLength)
 				{
-					bulkstart = _TRUE;
+					bulkstart = true;
 				}
 				else
 				{
@@ -755,13 +755,13 @@ s32 rtl8192du_xmitframe_complete(_adapte
 					phwxmit[ac_index].accnt--;
 
 					//Remove sta node when there is no pending packets.
-					if (_rtw_queue_empty(&ptxservq->sta_pending) == _TRUE)
+					if (_rtw_queue_empty(&ptxservq->sta_pending) == true)
 						rtw_list_delete(&ptxservq->tx_pending);
 				}
 			}
 			else
 			{
-				bulkstart = _TRUE;
+				bulkstart = true;
 			}
 
 			_exit_critical_bh(&pxmitpriv->lock, &irqL);
@@ -784,7 +784,7 @@ s32 rtl8192du_xmitframe_complete(_adapte
 		rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
 #else
 		res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
-		if (res == _FALSE) {
+		if (res == false) {
 			rtw_free_xmitframe(pxmitpriv, pxmitframe);
 			continue;
 		}
@@ -801,11 +801,11 @@ s32 rtl8192du_xmitframe_complete(_adapte
 
 			descCount = 0;
 			bulkPtr = bulkSize;
-			bfirst = _FALSE;
+			bfirst = false;
 		}
 		else
 		{
-			update_txdesc(pxmitframe, pxmitframe->buf_addr, pxmitframe->attrib.last_txcmdsz, _TRUE);
+			update_txdesc(pxmitframe, pxmitframe->buf_addr, pxmitframe->attrib.last_txcmdsz, true);
 
 			// don't need xmitframe any more
 			rtw_free_xmitframe(pxmitpriv, pxmitframe);
@@ -849,7 +849,7 @@ s32 rtl8192du_xmitframe_complete(_adapte
 		pfirstframe->pkt_offset--;
 	}
 #endif	// CONFIG_USE_USB_BUFFER_ALLOC_TX
-	update_txdesc(pfirstframe, pfirstframe->buf_addr, pfirstframe->attrib.last_txcmdsz, _TRUE);
+	update_txdesc(pfirstframe, pfirstframe->buf_addr, pfirstframe->attrib.last_txcmdsz, true);
 
 	//3 4. write xmit buffer to USB FIFO
 	ff_hwaddr = rtw_get_ff_hwaddr(pfirstframe);
@@ -866,7 +866,7 @@ s32 rtl8192du_xmitframe_complete(_adapte
 
 	rtw_free_xmitframe(pxmitpriv, pfirstframe);
 
-	return _TRUE;
+	return true;
 }
 
 #else
@@ -889,7 +889,7 @@ s32 rtl8192du_xmitframe_complete(_adapte
 		pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
 		if(!pxmitbuf)
 		{
-			return _FALSE;
+			return false;
 		}
 	}
 
@@ -935,14 +935,14 @@ s32 rtl8192du_xmitframe_complete(_adapte
 		else
 		{
 			rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
-			return _FALSE;
+			return false;
 		}
 
 		break;
 
 	}while(0/*xcnt < (NR_XMITFRAME >> 3)*/);
 
-	return _TRUE;
+	return true;
 
 }
 #endif
@@ -963,8 +963,8 @@ static s32 xmitframe_direct(_adapter *pa
 
 /*
  * Return
- *	_TRUE	dump packet directly
- *	_FALSE	enqueue packet
+ *	true	dump packet directly
+ *	false	enqueue packet
  */
 static s32 pre_xmitframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 {
@@ -979,18 +979,18 @@ static s32 pre_xmitframe(_adapter *padap
 
 	if (rtw_txframes_sta_ac_pending(padapter, pattrib) > 0
 #ifdef CONFIG_DUALMAC_CONCURRENT
-		|| (dc_check_xmit(padapter)== _FALSE)
+		|| (dc_check_xmit(padapter)== false)
 #endif
 		)
 		goto enqueue;
 
 
 
-	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
 		goto enqueue;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
 		goto enqueue;
 #endif //CONFIG_CONCURRENT_MODE
 
@@ -1009,7 +1009,7 @@ static s32 pre_xmitframe(_adapter *padap
 		rtw_free_xmitframe(pxmitpriv, pxmitframe);
 	}
 
-	return _TRUE;
+	return true;
 
 enqueue:
 	res = rtw_xmitframe_enqueue(padapter, pxmitframe);
@@ -1022,10 +1022,10 @@ enqueue:
 		// Trick, make the statistics correct
 		pxmitpriv->tx_pkts--;
 		pxmitpriv->tx_drop++;
-		return _TRUE;
+		return true;
 	}
 
-	return _FALSE;
+	return false;
 }
 
 s32 rtl8192du_mgnt_xmit(_adapter *padapter, struct xmit_frame *pmgntframe)
@@ -1035,8 +1035,8 @@ s32 rtl8192du_mgnt_xmit(_adapter *padapt
 
 /*
  * Return
- *	_TRUE	dump packet directly ok
- *	_FALSE	temporary can't transmit packets to hardware
+ *	true	dump packet directly ok
+ *	false	temporary can't transmit packets to hardware
  */
 s32 rtl8192du_hal_xmit(_adapter *padapter, struct xmit_frame *pxmitframe)
 {
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -177,9 +177,9 @@ _MappingOutEP(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	struct registry_priv *pregistrypriv = &pAdapter->registrypriv;
 
-	bool	 bWIFICfg = (pregistrypriv->wifi_spec) ?_TRUE:_FALSE;
+	bool	 bWIFICfg = (pregistrypriv->wifi_spec) ?true:false;
 
-	bool result = _TRUE;
+	bool result = true;
 
 	switch(NumOutPipe)
 	{
@@ -193,7 +193,7 @@ _MappingOutEP(
 			_OneOutEpMapping(pHalData);
 			break;
 		default:
-			result = _FALSE;
+			result = false;
 			break;
 	}
 
@@ -270,7 +270,7 @@ static bool HalUsbSetQueuePipeMapping819
 	)
 {
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(pAdapter);
-	bool			result		= _FALSE;
+	bool			result		= false;
 
 	_ConfigChipOutEP(pAdapter, NumOutPipe);
 
@@ -293,7 +293,7 @@ void rtl8192du_interface_configure(_adap
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
 	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
 
-	if (pdvobjpriv->ishighspeed == _TRUE)
+	if (pdvobjpriv->ishighspeed == true)
 	{
 		pHalData->UsbBulkOutSize = USB_HIGH_SPEED_BULK_SIZE;//512 bytes
 	}
@@ -355,7 +355,7 @@ static u8 _InitPowerOn(_adapter *padapte
 			return _FAIL;
 		}
 
-	}while(_TRUE);
+	}while(true);
 
 
 	//For hardware power on sequence.
@@ -394,7 +394,7 @@ static u8 _InitPowerOn(_adapter *padapte
 			return _FAIL;
 		}
 
-	}while(_TRUE);
+	}while(true);
 
 	// release RF digital isolation
 	value16 = rtw_read16(padapter, REG_SYS_ISO_CTRL);
@@ -1370,7 +1370,7 @@ _InitUsbAggregationSetting(
 	u32			value32;
 
 	if(Adapter->registrypriv.wifi_spec)
-		pHalData->UsbTxAggMode = _FALSE;
+		pHalData->UsbTxAggMode = false;
 
 	if(pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
 		pHalData->UsbTxAggDescNum = 2;
@@ -1678,9 +1678,9 @@ static VOID _RfPowerSave(
 	return;
 #endif
 
-	if(pwrctrlpriv->reg_rfoff == _TRUE){ // User disable RF via registry.
+	if(pwrctrlpriv->reg_rfoff == true){ // User disable RF via registry.
 		//RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RegRfOff.\n"));
-		//MgntActSet_RF_State(Adapter, rf_off, RF_CHANGE_BY_SW, _TRUE);
+		//MgntActSet_RF_State(Adapter, rf_off, RF_CHANGE_BY_SW, true);
 		// Those action will be discard in MgntActSet_RF_State because off the same state
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		if(pHalData->bSlaveOfDMSP)
@@ -1691,7 +1691,7 @@ static VOID _RfPowerSave(
 	}
 	else if(pwrctrlpriv->rfoff_reason > RF_CHANGE_BY_PS){ // H/W or S/W RF OFF before sleep.
 		//RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason));
-		//MgntActSet_RF_State(Adapter, rf_off, pMgntInfo->RfOffReason, _TRUE);
+		//MgntActSet_RF_State(Adapter, rf_off, pMgntInfo->RfOffReason, true);
 	}
 	else{
 		pwrctrlpriv->rf_pwrstate = rf_on;
@@ -1828,7 +1828,7 @@ u32 rtl8192du_hal_init(_adapter *padapte
 _func_enter_;
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
-	padapter->init_adpt_in_progress = _TRUE;
+	padapter->init_adpt_in_progress = true;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if(BuddyAdapter != NULL)
@@ -1942,16 +1942,16 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOW
 	rtl8192d_PHY_InitRxSetting(padapter);
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
 	DBG_8192C("%s(): Don't Download Firmware !!\n",__FUNCTION__);
-	padapter->bFWReady = _FALSE;
-	pHalData->fw_ractrl = _FALSE;
+	padapter->bFWReady = false;
+	pHalData->fw_ractrl = false;
 
 #else
 
-	status = FirmwareDownload92D(padapter, _FALSE);
+	status = FirmwareDownload92D(padapter, false);
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
 	if(status == _FAIL){
-		padapter->bFWReady = _FALSE;
-		pHalData->fw_ractrl = _FALSE;
+		padapter->bFWReady = false;
+		pHalData->fw_ractrl = false;
 		DBG_8192C("fw download fail!\n");
 
 		//return fail only when part number check fail,suggested by alex
@@ -1966,8 +1966,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOW
 		}
 	}
 	else	{
-		padapter->bFWReady = _TRUE;
-		pHalData->fw_ractrl = _TRUE;
+		padapter->bFWReady = true;
+		pHalData->fw_ractrl = true;
 		DBG_8192C("fw download ok!\n");
 	}
 
@@ -1975,7 +1975,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOW
 
 	pHalData->LastHMEBoxNum = 0;
 
-	if(pwrctrlpriv->reg_rfoff == _TRUE){
+	if(pwrctrlpriv->reg_rfoff == true){
 		pwrctrlpriv->rf_pwrstate = rf_off;
 	}
 
@@ -2022,7 +2022,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 	_InitOperationMode(padapter);//todo
 	_InitBeaconParameters(padapter);
 	_InitAMPDUAggregation(padapter);
-	_InitBeaconMaxError(padapter, _TRUE);
+	_InitBeaconMaxError(padapter, true);
 
 #if defined(CONFIG_CONCURRENT_MODE)
 
@@ -2135,12 +2135,12 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB)
 
 	if(padapter->bFWReady && pHalData->FirmwareVersion >= 0x13)
 	{
-		pHalData->bReadRFbyFW = _TRUE;
+		pHalData->bReadRFbyFW = true;
 		DBG_871X("Enable 92du query RF by FW.\n");
 	}
 	else
 	{
-		pHalData->bReadRFbyFW = _FALSE;
+		pHalData->bReadRFbyFW = false;
 	}
 
 	// 92CU use 3-wire to r/w RF
@@ -2170,7 +2170,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF)
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if(!pHalData->bSlaveOfDMSP)
 #endif
-		PHY_UpdateBBRFConfiguration8192D(padapter, _FALSE);
+		PHY_UpdateBBRFConfiguration8192D(padapter, false);
 
 #endif
 
@@ -2340,7 +2340,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 #endif //CONFIG_XMIT_ACK
 
 exit:
-	padapter->init_adpt_in_progress = _FALSE;
+	padapter->init_adpt_in_progress = false;
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END);
 
@@ -2362,7 +2362,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END
 _func_exit_;
 
 #ifdef CONFIG_WOWLAN
-	if(padapter->pwrctrlpriv.wowlan_mode == _TRUE)
+	if(padapter->pwrctrlpriv.wowlan_mode == true)
 		dump_wakup_reason(padapter);
 	{
 		u16 GPIO_val;
@@ -2457,7 +2457,7 @@ _DisableRF_AFE(
 			return _FAIL;
 		}
 
-	}while(_TRUE);
+	}while(true);
 
 #endif
 
@@ -2745,7 +2745,7 @@ CanGotoPowerOff92D(
 #endif
 
 	if(pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY)
-		return _TRUE;
+		return true;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if(BuddyAdapter != NULL)
@@ -2753,7 +2753,7 @@ CanGotoPowerOff92D(
 		if(BuddyAdapter->init_adpt_in_progress)
 		{
 			DBG_871X("do not power off during another adapter is initialization \n");
-			return _FALSE;
+			return false;
 		}
 	}
 #endif
@@ -2792,9 +2792,9 @@ CanGotoPowerOff92D(
 		u1bTmp=rtw_read8(Adapter, 0x17);
 		u1bTmp&=(~BIT7);
 		rtw_write8(Adapter, 0x17, u1bTmp);
-		return _FALSE;
+		return false;
 	}
-	return _TRUE;
+	return true;
 }
 
 static int
@@ -2817,7 +2817,7 @@ CardDisableHWSM( // HW Auto state machin
 
 	//==== RF Off Sequence ====
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == _FALSE)
+	if(!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
 #endif
 		_DisableRFAFEAndResetBB(Adapter);
 
@@ -2830,13 +2830,13 @@ CardDisableHWSM( // HW Auto state machin
 	rtw_write8(Adapter, REG_RF_CTRL,0);
 
 	//  ==== Reset digital sequence   ======
-	_ResetDigitalProcedure1(Adapter, _FALSE);
+	_ResetDigitalProcedure1(Adapter, false);
 
 	//  ==== Pull GPIO PIN to balance level and LED control ======
 	_DisableGPIO(Adapter);
 
 	//  ==== Disable analog sequence ===
-	_DisableAnalog(Adapter, _FALSE);
+	_DisableAnalog(Adapter, false);
 
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
 	value=rtw_read8(Adapter, REG_POWER_OFF_IN_PROCESS);
@@ -2868,7 +2868,7 @@ CardDisableWithoutHWSM( // without HW Au
 
 	//==== RF Off Sequence ====
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if(!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == _FALSE)
+	if(!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
 #endif
 		_DisableRFAFEAndResetBB(Adapter);
 
@@ -2889,9 +2889,9 @@ CardDisableWithoutHWSM( // without HW Au
 
 	//  ==== Reset digital sequence   ======
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	_ResetDigitalProcedure1(Adapter, _FALSE);
+	_ResetDigitalProcedure1(Adapter, false);
 #else
-	_ResetDigitalProcedure1(Adapter,_TRUE);
+	_ResetDigitalProcedure1(Adapter,true);
 #endif
 
 	//  ==== Pull GPIO PIN to balance level and LED control ======
@@ -2902,9 +2902,9 @@ CardDisableWithoutHWSM( // without HW Au
 
 	//  ==== Disable analog sequence ===
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	_DisableAnalog(Adapter,_FALSE);
+	_DisableAnalog(Adapter,false);
 #else
-	_DisableAnalog(Adapter,_TRUE);
+	_DisableAnalog(Adapter,true);
 #endif
 
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
@@ -2933,7 +2933,7 @@ _func_enter_;
 		return _FAIL;
 	}
 
-	padapter->bHaltInProgress = _TRUE;
+	padapter->bHaltInProgress = true;
 
 	OpMode = 0;
 	rtw_hal_set_hwreg(padapter, HW_VAR_MEDIA_STATUS, (u8 *)(&OpMode));
@@ -2941,8 +2941,8 @@ _func_enter_;
 	rtw_write16(padapter, REG_GPIO_MUXCFG, rtw_read16(padapter, REG_GPIO_MUXCFG)&(~BIT12));
 
 	if(/*Adapter->bInUsbIfTest ||*/ !pHalData->bSupportRemoteWakeUp){
-		if( padapter->bCardDisableWOHSM == _FALSE)
-			CardDisableHWSM(padapter, _FALSE);
+		if( padapter->bCardDisableWOHSM == false)
+			CardDisableHWSM(padapter, false);
 		else
 			CardDisableWithoutHWSM(padapter);
 	} else{
@@ -2962,7 +2962,7 @@ _func_enter_;
 
 	rtw_led_control(padapter, LED_CTL_POWER_OFF);
 
-	padapter->bHaltInProgress = _FALSE;
+	padapter->bHaltInProgress = false;
 
 _func_exit_;
 
@@ -2996,7 +2996,7 @@ _func_enter_;
 	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
 	for(i=0; i<NR_RECVBUFF; i++)
 	{
-		if(_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == _FALSE )
+		if(_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == false )
 		{
 			RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_port error \n"));
 			status = _FAIL;
@@ -3009,7 +3009,7 @@ _func_enter_;
 
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
 	_read_interrupt = pintfhdl->io_ops._read_interrupt;
-	if(_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == _FALSE )
+	if(_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == false )
 	{
 		RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_interrupt error \n"));
 		status = _FAIL;
@@ -3093,7 +3093,7 @@ _ReadIDs(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
 
-	if(_FALSE == AutoloadFail){
+	if(false == AutoloadFail){
 		// VID, PID
 		pHalData->EEPROMVID = le16_to_cpu( *(u16 *)&PROMContent[EEPROM_VID]);
 		pHalData->EEPROMPID = le16_to_cpu( *(u16 *)&PROMContent[EEPROM_PID]);
@@ -3117,17 +3117,17 @@ _ReadIDs(
 	switch(pHalData->EEPROMCustomerID)
 	{
 		case EEPROM_CID_WHQL:
-			//Adapter->bInHctTest = _TRUE;
+			//Adapter->bInHctTest = true;
 
-			//pMgntInfo->bSupportTurboMode = _FALSE;
-			//pMgntInfo->bAutoTurboBy8186 = _FALSE;
+			//pMgntInfo->bSupportTurboMode = false;
+			//pMgntInfo->bAutoTurboBy8186 = false;
 
-			//pMgntInfo->PowerSaveControl.bInactivePs = _FALSE;
-			//pMgntInfo->PowerSaveControl.bIPSModeBackup = _FALSE;
-			//pMgntInfo->PowerSaveControl.bLeisurePs = _FALSE;
+			//pMgntInfo->PowerSaveControl.bInactivePs = false;
+			//pMgntInfo->PowerSaveControl.bIPSModeBackup = false;
+			//pMgntInfo->PowerSaveControl.bLeisurePs = false;
 			//pMgntInfo->keepAliveLevel = 0;
 
-			//Adapter->bUnloadDriverwhenS3S4 = _FALSE;
+			//Adapter->bUnloadDriverwhenS3S4 = false;
 			break;
 		default:
 			pHalData->CustomerID = RT_CID_DEFAULT;
@@ -3153,7 +3153,7 @@ _ReadMACAddress(
 
 	// Dual MAC should assign diffrent MAC address ,or, it is wil cause hang in single phy mode  zhiyuan 04/07/2010
 	//Temply random assigh mac address for  efuse mac address not ready now
-	if(AutoloadFail == _FALSE  ){
+	if(AutoloadFail == false  ){
 		if(pHalData->interfaceIndex == 0){
 			//change to use memcpy, in order to avoid alignment issue. Baron 2011/6/20
 			_rtw_memcpy(&pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR_MAC0_92D], ETH_ALEN);
@@ -3212,12 +3212,12 @@ hal_ReadMacPhyModeFromPROM92DU(
 		if(Adapter->registrypriv.mac_phy_mode == 3)
 		{
 			pHalData->MacPhyMode92D = DUALMAC_SINGLEPHY;
-			Adapter->DualMacConcurrent = _TRUE;
+			Adapter->DualMacConcurrent = true;
 		}
 		else
 		{
 			pHalData->MacPhyMode92D = DUALMAC_DUALPHY;
-			Adapter->DualMacConcurrent = _FALSE;
+			Adapter->DualMacConcurrent = false;
 		}
 #else
 		pHalData->MacPhyMode92D = DUALMAC_DUALPHY;
@@ -3252,7 +3252,7 @@ hal_ReadMacPhyMode_92D(
 
 
 
-	if(AutoloadFail==_TRUE){
+	if(AutoloadFail==true){
 		Mac1EnableValue = rtw_read8(Adapter,0xFE64);
 		PHY_ReadMacPhyMode92D(Adapter, AutoloadFail);
 
@@ -3273,7 +3273,7 @@ hal_ReadMacPhyMode_92D(
 		RELEASE_GLOBAL_MUTEX(GlobalCounterForMutex);
 		PHY_ConfigMacPhyMode92D(Adapter);
 		ACQUIRE_GLOBAL_MUTEX(GlobalCounterForMutex);
-		GlobalFirstConfigurationForNormalChip = _FALSE;
+		GlobalFirstConfigurationForNormalChip = false;
 		RELEASE_GLOBAL_MUTEX(GlobalCounterForMutex);
 	}
 	else
@@ -3302,7 +3302,7 @@ _ReadBoardType(
 
 	if(AutoloadFail){
 		pHalData->rf_type = RF_2T2R;
-		pHalData->BluetoothCoexist = _FALSE;
+		pHalData->BluetoothCoexist = false;
 		return;
 	}
 
@@ -3328,7 +3328,7 @@ _ReadLEDSetting(
 	{
 		case RT_CID_DEFAULT:
 			pledpriv->LedStrategy = SW_LED_MODE1;
-			pledpriv->bRegUseLed = _TRUE;
+			pledpriv->bRegUseLed = true;
 			break;
 		default:
 			pledpriv->LedStrategy = SW_LED_MODE0;
@@ -3349,12 +3349,12 @@ _ReadWOWLAN(
 	)
 {
 	if(AutoloadFail)
-		Adapter->pwrctrlpriv.bSupportRemoteWakeup = _FALSE;
+		Adapter->pwrctrlpriv.bSupportRemoteWakeup = false;
 	else
 	{
 		// decide hw if support remote wakeup function
 		// if hw supported, 8051 (SIE) will generate WeakUP signal( D+/D- toggle) when autoresume
-		Adapter->pwrctrlpriv.bSupportRemoteWakeup = (PROMContent[EEPROM_Option_Setting] & BIT1)?_TRUE :_FALSE;
+		Adapter->pwrctrlpriv.bSupportRemoteWakeup = (PROMContent[EEPROM_Option_Setting] & BIT1)?true :false;
 		DBG_871X("efuse remote wakeup =%d \n", Adapter->pwrctrlpriv.bSupportRemoteWakeup);
 	}
 }
@@ -3392,18 +3392,18 @@ static void _ReadPROMContent(
 
 	eeValue = rtw_read8(Adapter, REG_9346CR);
 	// To check system boot selection.
-	pEEPROM->EepromOrEfuse		= (eeValue & BOOT_FROM_EEPROM) ? _TRUE : _FALSE;
-	pEEPROM->bautoload_fail_flag	= (eeValue & EEPROM_EN) ? _FALSE : _TRUE;
+	pEEPROM->EepromOrEfuse		= (eeValue & BOOT_FROM_EEPROM) ? true : false;
+	pEEPROM->bautoload_fail_flag	= (eeValue & EEPROM_EN) ? false : true;
 
 
 	DBG_8192C("Boot from %s, Autoload %s !\n", (pEEPROM->EepromOrEfuse ? "EEPROM" : "EFUSE"),
 				(pEEPROM->bautoload_fail_flag ? "Fail" : "OK") );
 
-	//pHalData->EEType = (pEEPROM->EepromOrEfuse == _TRUE) ? EEPROM_93C46 : EEPROM_BOOT_EFUSE;
+	//pHalData->EEType = (pEEPROM->EepromOrEfuse == true) ? EEPROM_93C46 : EEPROM_BOOT_EFUSE;
 
-	if (pEEPROM->bautoload_fail_flag == _FALSE)
+	if (pEEPROM->bautoload_fail_flag == false)
 	{
-		if ( pEEPROM->EepromOrEfuse == _TRUE)
+		if ( pEEPROM->EepromOrEfuse == true)
 		{
 			// Read all Content from EEPROM or EFUSE.
 			for(i = 0; i < HWSET_MAX_SIZE; i += 2)
@@ -3417,7 +3417,7 @@ static void _ReadPROMContent(
 		{
 			// Read EFUSE real map to shadow.
 			ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
-			EFUSE_ShadowMapUpdate(Adapter, EFUSE_WIFI, _FALSE);
+			EFUSE_ShadowMapUpdate(Adapter, EFUSE_WIFI, false);
 			RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
 			_rtw_memcpy((void*)PROMContent, (void*)pEEPROM->efuse_eeprom_data, HWSET_MAX_SIZE);
 		}
@@ -3425,12 +3425,12 @@ static void _ReadPROMContent(
 		//Double check 0x8192 autoload status again
 		if(RTL8192_EEPROM_ID != le16_to_cpu(*((u16 *)PROMContent)))
 		{
-			pEEPROM->bautoload_fail_flag = _TRUE;
+			pEEPROM->bautoload_fail_flag = true;
 			DBG_8192C("Autoload OK but EEPROM ID content is incorrect!!\n");
 		}
 
 	}
-	else if ( pEEPROM->EepromOrEfuse == _FALSE)//auto load fail
+	else if ( pEEPROM->EepromOrEfuse == false)//auto load fail
 	{
 		_rtw_memset(pEEPROM->efuse_eeprom_data, 0xff, HWSET_MAX_SIZE);
 		_rtw_memcpy((void*)PROMContent, (void*)pEEPROM->efuse_eeprom_data, HWSET_MAX_SIZE);
@@ -3450,9 +3450,9 @@ _InitOtherVariable(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
 	//if(Adapter->bInHctTest){
-	//	pMgntInfo->PowerSaveControl.bInactivePs = _FALSE;
-	//	pMgntInfo->PowerSaveControl.bIPSModeBackup = _FALSE;
-	//	pMgntInfo->PowerSaveControl.bLeisurePs = _FALSE;
+	//	pMgntInfo->PowerSaveControl.bInactivePs = false;
+	//	pMgntInfo->PowerSaveControl.bIPSModeBackup = false;
+	//	pMgntInfo->PowerSaveControl.bLeisurePs = false;
 	//	pMgntInfo->keepAliveLevel = 0;
 	//}
 
@@ -3460,10 +3460,10 @@ _InitOtherVariable(
 	// So if you want to use radio B. Please modify RF path enable bit for correct signal
 	// strength calculate.
 	if (pHalData->rf_type == RF_1T1R){
-		pHalData->bRFPathRxEnable[0] = _TRUE;
+		pHalData->bRFPathRxEnable[0] = true;
 	}
 	else{
-		pHalData->bRFPathRxEnable[0] = pHalData->bRFPathRxEnable[1] = _TRUE;
+		pHalData->bRFPathRxEnable[0] = pHalData->bRFPathRxEnable[1] = true;
 	}
 
 }
@@ -3595,7 +3595,7 @@ SelectRTSInitialRate(
 	}
 
 	if(psta->rtsen || psta->cts2self)
-		bUseProtection = _TRUE;
+		bUseProtection = true;
 
 	_rtw_memcpy(SupportRateSet, cur_network->SupportedRates, NDIS_802_11_LENGTH_RATES_EX);
 
@@ -3615,7 +3615,7 @@ SelectRTSInitialRate(
 	else //if(pMgntInfo->pHTInfo->CurrentOpMode)
 	{
 		//MacId 0: INFRA mode.
-		if((check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)&&(check_fwstate(pmlmepriv, WIFI_STATION_STATE)==_TRUE))
+		if((check_fwstate(pmlmepriv, _FW_LINKED)== true)&&(check_fwstate(pmlmepriv, WIFI_STATION_STATE)==true))
 		{
 			LowestRateIdx = rtw_read8(Adapter, REG_INIDATA_RATE_SEL)&0x3f;
 		}
@@ -3780,7 +3780,7 @@ static void hw_var_set_opmode(PADAPTER A
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 			// Reset TSF for STA+AP concurrent mode
 			if ( check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE)) ) {
-				if (reset_tsf(Adapter, IFACE_PORT1) == _FALSE)
+				if (reset_tsf(Adapter, IFACE_PORT1) == false)
 					DBG_871X("ERROR! %s()-%d: Reset port1 TSF fail\n",
 						__FUNCTION__, __LINE__);
 			}
@@ -3860,7 +3860,7 @@ static void hw_var_set_opmode(PADAPTER A
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 			// Reset TSF for STA+AP concurrent mode
 			if ( check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE)) ) {
-				if (reset_tsf(Adapter, IFACE_PORT0) == _FALSE)
+				if (reset_tsf(Adapter, IFACE_PORT0) == false)
 					DBG_871X("ERROR! %s()-%d: Reset port0 TSF fail\n",
 						__FUNCTION__, __LINE__);
 			}
@@ -3985,7 +3985,7 @@ static void hw_var_set_correct_tsf(PADAP
 		// Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue!
 		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
 			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE) ) {
-			if (reset_tsf(Adapter, IFACE_PORT0) == _FALSE)
+			if (reset_tsf(Adapter, IFACE_PORT0) == false)
 				DBG_871X("ERROR! %s()-%d: Reset port0 TSF fail\n",
 					__FUNCTION__, __LINE__);
 		}
@@ -4026,7 +4026,7 @@ static void hw_var_set_correct_tsf(PADAP
 		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
 		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
 			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE) ) {
-			if (reset_tsf(Adapter, IFACE_PORT1) == _FALSE)
+			if (reset_tsf(Adapter, IFACE_PORT1) == false)
 				DBG_871X("ERROR! %s()-%d: Reset port1 TSF fail\n",
 					__FUNCTION__, __LINE__);
 		}
@@ -4159,9 +4159,9 @@ static void hw_var_set_mlme_sitesurvey(P
 
 #ifdef CONFIG_FIND_BEST_CHANNEL
 
-	if( (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	if( (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 #ifdef CONFIG_CONCURRENT_MODE
-		|| (check_buddy_fwstate(Adapter, WIFI_AP_STATE) == _TRUE)
+		|| (check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true)
 #endif
 #ifdef CONFIG_TDLS
 		// TDLS will clear RCR_CBSSID_DATA bit for connection.
@@ -4192,7 +4192,7 @@ static void hw_var_set_mlme_sitesurvey(P
 
 	if(*((u8 *)val))//under sitesurvey
 	{
-		pHalData->bLoadIMRandIQKSettingFor2G = _FALSE;
+		pHalData->bLoadIMRandIQKSettingFor2G = false;
 
 		value_rcr &= ~(rcr_clear_bit);
 		rtw_write32(Adapter, REG_RCR, value_rcr);
@@ -4273,7 +4273,7 @@ static void hw_var_set_mlme_join(PADAPTE
 		else
 			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
 
-		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+		if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 		{
 			RetryLimit = (pHalData->CustomerID == RT_CID_CCX) ? 7 : 48;
 		}
@@ -4282,8 +4282,8 @@ static void hw_var_set_mlme_join(PADAPTE
 			RetryLimit = 0x7;
 		}
 
-		DBG_8192C("%s(): pHalData->bNeedIQK = _TRUE\n",__FUNCTION__);
-		pHalData->bNeedIQK = _TRUE; //for 92D IQK
+		DBG_8192C("%s(): pHalData->bNeedIQK = true\n",__FUNCTION__);
+		pHalData->bNeedIQK = true; //for 92D IQK
 	}
 	else if(type == 1) //joinbss_event call back when join res < 0
 	{
@@ -4336,7 +4336,7 @@ static void dc_hw_var_mlme_sitesurvey(PA
 	struct mlme_ext_priv *pbuddy_mlmeext;
 
 	if((BuddyAdapter !=NULL) &&
-		Adapter->DualMacConcurrent == _TRUE)
+		Adapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(BuddyAdapter->mlmepriv);
 		pbuddy_mlmeext = &BuddyAdapter->mlmeextpriv;
@@ -4373,7 +4373,7 @@ static void dc_hw_var_mlme_join(PADAPTER
 
 
 	if((BuddyAdapter !=NULL) &&
-		Adapter->DualMacConcurrent == _TRUE)
+		Adapter->DualMacConcurrent == true)
 	{
 		pbuddy_mlmepriv = &(BuddyAdapter->mlmepriv);
 		pbuddy_mlmeext = &BuddyAdapter->mlmeextpriv;
@@ -4507,16 +4507,16 @@ _func_enter_;
 #ifdef CONFIG_DUALMAC_CONCURRENT
 				PADAPTER	BuddyAdapter = Adapter->pbuddy_adapter;
 #endif
-				if(check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE) == _TRUE)
+				if(check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE) == true)
 				{
-					DBG_8192C("%s(): pHalData->bNeedIQK = _TRUE\n",__FUNCTION__);
-					pHalData->bNeedIQK = _TRUE; //for 92D IQK
+					DBG_8192C("%s(): pHalData->bNeedIQK = true\n",__FUNCTION__);
+					pHalData->bNeedIQK = true; //for 92D IQK
 				}
 #ifdef CONFIG_DUALMAC_CONCURRENT
 				if((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
 				{
-					if(check_fwstate(&BuddyAdapter->mlmepriv, WIFI_AP_STATE) == _TRUE)
-						GET_HAL_DATA(BuddyAdapter)->bNeedIQK = _TRUE; //for 92D IQK
+					if(check_fwstate(&BuddyAdapter->mlmepriv, WIFI_AP_STATE) == true)
+						GET_HAL_DATA(BuddyAdapter)->bNeedIQK = true; //for 92D IQK
 				}
 #endif
 			}
@@ -4542,7 +4542,7 @@ _func_enter_;
 		case HW_VAR_BASIC_RATE:
 			{
 				u16	BrateCfg = 0;
-				u8	RateIndex = 0, b2GBand = _FALSE;
+				u8	RateIndex = 0, b2GBand = false;
 				struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
 
 				// 2007.01.16, by Emily
@@ -4552,9 +4552,9 @@ _func_enter_;
 				halsetbratecfg( Adapter, val, &BrateCfg );
 
 				if(pHalData->CurrentBandType92D == BAND_ON_2_4G)
-					b2GBand = _TRUE;
+					b2GBand = true;
 				else
-					b2GBand = _FALSE;
+					b2GBand = false;
 
 				if(b2GBand)
 				{
@@ -4707,7 +4707,7 @@ _func_enter_;
 
 					rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
 
-					if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+					if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 					{
 						RetryLimit = (pHalData->CustomerID == RT_CID_CCX) ? 7 : 48;
 					}
@@ -4716,12 +4716,12 @@ _func_enter_;
 						RetryLimit = 0x7;
 					}
 
-					DBG_8192C("%s(): pHalData->bNeedIQK = _TRUE\n",__FUNCTION__);
-					pHalData->bNeedIQK = _TRUE; //for 92D IQK
+					DBG_8192C("%s(): pHalData->bNeedIQK = true\n",__FUNCTION__);
+					pHalData->bNeedIQK = true; //for 92D IQK
 #ifdef CONFIG_DUALMAC_CONCURRENT
 					if((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
 					{
-						GET_HAL_DATA(BuddyAdapter)->bNeedIQK = _TRUE; //for 92D IQK
+						GET_HAL_DATA(BuddyAdapter)->bNeedIQK = true; //for 92D IQK
 					}
 #endif
 				}
@@ -5101,7 +5101,7 @@ _func_enter_;
 				//keep sn
 				Adapter->xmitpriv.nqos_ssn = rtw_read16(Adapter,REG_NQOS_SEQ);
 
-				if(pwrpriv->bkeepfwalive != _TRUE)
+				if(pwrpriv->bkeepfwalive != true)
 				{
 					//RX DMA stop
 					rtw_write32(Adapter,REG_RXPKT_NUM,(rtw_read32(Adapter,REG_RXPKT_NUM)|RW_RELEASE_EN));
@@ -5134,12 +5134,12 @@ _func_enter_;
 						DBG_8192C("\n PATTERN_MATCH poidparam->subcode_value=%d\n",poidparam->subcode_value);
 						if(poidparam->subcode_value==1){
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(1)));
-							Adapter->pwrctrlpriv.wowlan_pattern=_TRUE;
+							Adapter->pwrctrlpriv.wowlan_pattern=true;
 							DBG_8192C("%s Adapter->pwrctrlpriv.wowlan_pattern=%x\n",__FUNCTION__,Adapter->pwrctrlpriv.wowlan_pattern);
 						}
 						else{
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&~BIT(1)));
-							Adapter->pwrctrlpriv.wowlan_pattern=_FALSE;
+							Adapter->pwrctrlpriv.wowlan_pattern=false;
 						}
 						break;
 					case WOWLAN_MAGIC_PACKET:
@@ -5147,23 +5147,23 @@ _func_enter_;
 						DBG_8192C("\n MAGIC_PACKET poidparam->subcode_value=%d\n",poidparam->subcode_value);
 						if(poidparam->subcode_value==1){
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(2)));
-							Adapter->pwrctrlpriv.wowlan_magic=_TRUE;
+							Adapter->pwrctrlpriv.wowlan_magic=true;
 							DBG_8192C("%s Adapter->pwrctrlpriv.wowlan_magic=%x\n",__FUNCTION__,Adapter->pwrctrlpriv.wowlan_magic);
 						}
 						else{
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&~BIT(2)));
-							Adapter->pwrctrlpriv.wowlan_magic=_FALSE;
+							Adapter->pwrctrlpriv.wowlan_magic=false;
 						}
 						break;
 					case WOWLAN_UNICAST:
 						//Turn on the Unicast wakeup feature
 						if(poidparam->subcode_value==1){
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(3)));
-							Adapter->pwrctrlpriv.wowlan_unicast=_TRUE;
+							Adapter->pwrctrlpriv.wowlan_unicast=true;
 						}
 						else{
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&~BIT(3)));
-							Adapter->pwrctrlpriv.wowlan_unicast=_FALSE;
+							Adapter->pwrctrlpriv.wowlan_unicast=false;
 							DBG_8192C("%s Adapter->pwrctrlpriv.wowlan_unicast=%x\n",__FUNCTION__,Adapter->pwrctrlpriv.wowlan_unicast);
 						}
 						break;
@@ -5188,9 +5188,9 @@ _func_enter_;
 
 						break;
 					case WOWLAN_ENABLE:
-						SetFwRelatedForWoWLAN8192DU(Adapter, _TRUE);
+						SetFwRelatedForWoWLAN8192DU(Adapter, true);
 						//Set Pattern
-						if(Adapter->pwrctrlpriv.wowlan_pattern==_TRUE)
+						if(Adapter->pwrctrlpriv.wowlan_pattern==true)
 							rtw_wowlan_reload_pattern(Adapter);
 						rtl8192d_set_wowlan_cmd(Adapter);
 						//rtw_write8(Adapter, 0x6, rtw_read8(Adapter, 0x6)|BIT(3));
@@ -5202,7 +5202,7 @@ _func_enter_;
 						break;
 
 					case WOWLAN_DISABLE:
-						Adapter->pwrctrlpriv.wowlan_mode=_FALSE;
+						Adapter->pwrctrlpriv.wowlan_mode=false;
 						rtl8192d_set_wowlan_cmd(Adapter);
 						rtw_msleep_os(10);
 						break;
@@ -5215,9 +5215,9 @@ _func_enter_;
 					case WOWLAN_DEBUG_RELOAD_FW:
 						//for debug
 						/*
-						SetFwRelatedForWoWLAN8192DU(Adapter, _TRUE);
+						SetFwRelatedForWoWLAN8192DU(Adapter, true);
 						//Set Pattern
-						if(Adapter->pwrctrlpriv.wowlan_pattern==_TRUE)
+						if(Adapter->pwrctrlpriv.wowlan_pattern==true)
 							rtw_wowlan_reload_pattern(Adapter);
 						rtl8192d_set_wowlan_cmd(Adapter);
 						rtw_write8(Adapter, 0x6, rtw_read8(Adapter, 0x6)|BIT(3));
@@ -5281,9 +5281,9 @@ _func_enter_;
 						break;
 				}
 				if (Adapter->pwrctrlpriv.wowlan_unicast||Adapter->pwrctrlpriv.wowlan_magic || Adapter->pwrctrlpriv.wowlan_pattern)
-					Adapter->pwrctrlpriv.wowlan_mode =_TRUE;
+					Adapter->pwrctrlpriv.wowlan_mode =true;
 				else
-					Adapter->pwrctrlpriv.wowlan_mode =_FALSE;
+					Adapter->pwrctrlpriv.wowlan_mode =false;
 			}
 			break;
 #endif //CONFIG_WOWLAN
@@ -5344,7 +5344,7 @@ _func_enter_;
 			break;
 		case HW_VAR_BCN_VALID:
 			//BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2
-			val[0] = (BIT0 & rtw_read8(Adapter, REG_TDECTRL+2))?_TRUE:_FALSE;
+			val[0] = (BIT0 & rtw_read8(Adapter, REG_TDECTRL+2))?true:false;
 			break;
 		case HW_VAR_DM_FLAG:
 			val[0] = pHalData->dmpriv.DMFlag;
@@ -5361,16 +5361,16 @@ _func_enter_;
 				{
 					// If it is in HW/SW Radio OFF or IPS state, we do not check Fw LPS Leave,
 					// because Fw is unload.
-					val[0] = _TRUE;
+					val[0] = true;
 				}
 				else
 				{
 					valRCR = rtw_read32(Adapter, REG_RCR);
 					valRCR &= 0x00070000;
 					if(valRCR)
-						val[0] = _FALSE;
+						val[0] = false;
 					else
-						val[0] = _TRUE;
+						val[0] = true;
 				}
 			}
 			break;
@@ -5408,7 +5408,7 @@ GetHalDefVar8192DUsb(
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	u8			bResult = _TRUE;
+	u8			bResult = true;
 
 	switch(eVariable) {
 	case HAL_DEF_UNDERCORATEDSMOOTHEDPWDB:
@@ -5427,7 +5427,7 @@ GetHalDefVar8192DUsb(
 		*(( u8*)pValue) = pHalData->dmpriv.DMFlag;
 		break;
 	default:
-		bResult = _FALSE;
+		bResult = false;
 		break;
 	}
 	return bResult;
@@ -5451,7 +5451,7 @@ SetHalDefVar8192DUsb(
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	u8			bResult = _TRUE;
+	u8			bResult = true;
 
 	switch(eVariable)
 	{
@@ -5497,7 +5497,7 @@ SetHalDefVar8192DUsb(
 			break;
 		default:
 			//RT_TRACE(COMP_INIT, DBG_TRACE, ("SetHalDefVar819xUsb(): Unkown variable: %d!\n", eVariable));
-			bResult = _FALSE;
+			bResult = false;
 			break;
 	}
 
@@ -5558,7 +5558,7 @@ void UpdateHalRAMask8192DUsb(PADAPTER pa
 	u8	init_rate=0;
 	u8	networkType, raid;
 	u32	mask;
-	u8	shortGIrate = _FALSE;
+	u8	shortGIrate = false;
 	int	supportRateNum = 0;
 	struct sta_info	*psta;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
@@ -5599,7 +5599,7 @@ void UpdateHalRAMask8192DUsb(PADAPTER pa
 
 			if (support_short_GI(padapter, &(pmlmeinfo->HT_caps)))
 			{
-				shortGIrate = _TRUE;
+				shortGIrate = true;
 			}
 
 			break;
@@ -5658,7 +5658,7 @@ void UpdateHalRAMask8192DUsb(PADAPTER pa
 
 	init_rate = get_highest_rate_idx(mask)&0x3f;
 
-	if(pHalData->fw_ractrl == _TRUE)
+	if(pHalData->fw_ractrl == true)
 	{
 		value[0] = mask;
 		value[1] = mac_id | (shortGIrate?0x20:0x00) | 0x80;
@@ -5669,7 +5669,7 @@ void UpdateHalRAMask8192DUsb(PADAPTER pa
 	}
 	else
 	{
-		if (shortGIrate==_TRUE)
+		if (shortGIrate==true)
 			init_rate |= BIT(6);
 
 		rtw_write8(padapter, (REG_INIDATA_RATE_SEL+mac_id), init_rate);
@@ -5716,7 +5716,7 @@ void SetBeaconRelatedRegisters8192DUsb(P
 	rtw_write8(padapter,  REG_RXTSF_OFFSET_CCK, 0x50);
 	rtw_write8(padapter, REG_RXTSF_OFFSET_OFDM, 0x50);
 
-	_BeaconFunctionEnable(padapter, _TRUE, _TRUE);
+	_BeaconFunctionEnable(padapter, true, true);
 
 	ResumeTxBeacon(padapter);
 
@@ -5739,7 +5739,7 @@ static void rtl8192du_init_default_value
 	pHalData->CurrentWirelessMode = WIRELESS_MODE_AUTO;
 
 	//init default value
-	pHalData->fw_ractrl = _FALSE;
+	pHalData->fw_ractrl = false;
 	if(!pwrctrlpriv->bkeepfwalive)
 		pHalData->LastHMEBoxNum = 0;
 
@@ -5748,7 +5748,7 @@ static void rtl8192du_init_default_value
 
 	//init dm default value
 	pdmpriv->TM_Trigger = 0;
-	//pdmpriv->binitialized = _FALSE;
+	//pdmpriv->binitialized = false;
 	pdmpriv->prv_traffic_idx = 3;
 
 	rtl8192d_PHY_ResetIQKResult(padapter);
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -132,7 +132,7 @@ static int usbctrl_vendorreq(struct intf
 			if (status < 0) {
 				if(status == (-ESHUTDOWN)	|| status == -ENODEV	)
 				{
-					padapter->bSurpriseRemoved = _TRUE;
+					padapter->bSurpriseRemoved = true;
 				} else {
 					#ifdef DBG_CONFIG_ERROR_DETECT
 					{
@@ -152,8 +152,8 @@ static int usbctrl_vendorreq(struct intf
 				}
 			}
 
-			if(rtw_inc_and_chk_continual_urb_error(pdvobjpriv) == _TRUE ){
-				padapter->bSurpriseRemoved = _TRUE;
+			if(rtw_inc_and_chk_continual_urb_error(pdvobjpriv) == true ){
+				padapter->bSurpriseRemoved = true;
 				break;
 			}
 
@@ -435,10 +435,10 @@ static void usb_read_interrupt_complete(
 			case -EPIPE:
 			case -ENODEV:
 			case -ESHUTDOWN:
-				//padapter->bSurpriseRemoved=_TRUE;
+				//padapter->bSurpriseRemoved=true;
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
 			case -ENOENT:
-				padapter->bDriverStopped=_TRUE;
+				padapter->bDriverStopped=true;
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
 				break;
 			case -EPROTO:
@@ -504,7 +504,7 @@ static s32 pre_recv_entry(union recv_fra
 
 	paddr1 = GetAddr1Ptr(precvframe->u.hdr.rx_data);
 
-	if(IS_MCAST(paddr1) == _FALSE)//unicast packets
+	if(IS_MCAST(paddr1) == false)//unicast packets
 	{
 		//primary_myid = myid(&primary_padapter->eeprompriv);
 		secondary_myid = myid(&secondary_padapter->eeprompriv);
@@ -520,9 +520,9 @@ static s32 pre_recv_entry(union recv_fra
 	}
 	else // Handle BC/MC Packets
 	{
-		u8 clone = _TRUE;
+		u8 clone = true;
 
-		if(_TRUE == clone)
+		if(true == clone)
 		{
 			//clone/copy to if2
 			u8 shift_sz = 0;
@@ -799,7 +799,7 @@ void rtl8192du_recv_tasklet(void *priv)
 
 	while (NULL != (precvbuf = rtw_dequeue_recvbuf(&precvpriv->recv_buf_pending_queue)))
 	{
-		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+		if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
 		{
 			DBG_8192C("recv_tasklet => bDriverStopped or bSurpriseRemoved \n");
 
@@ -860,10 +860,10 @@ static void usb_read_port_complete(struc
 			case -EPIPE:
 			case -ENODEV:
 			case -ESHUTDOWN:
-				//padapter->bSurpriseRemoved=_TRUE;
+				//padapter->bSurpriseRemoved=true;
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
 			case -ENOENT:
-				padapter->bDriverStopped=_TRUE;
+				padapter->bDriverStopped=true;
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
 				break;
 			case -EPROTO:
@@ -1134,7 +1134,7 @@ void rtl8192du_recv_tasklet(void *priv)
 
 	while (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue)))
 	{
-		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+		if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
 		{
 			DBG_8192C("recv_tasklet => bDriverStopped or bSurpriseRemoved \n");
 			dev_kfree_skb_any(pskb);
@@ -1170,7 +1170,7 @@ static void usb_read_port_complete(struc
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
 
 	//_enter_critical(&precvpriv->lock, &irqL);
-	//precvbuf->irp_pending=_FALSE;
+	//precvbuf->irp_pending=false;
 	//precvpriv->rx_pending_cnt --;
 	//_exit_critical(&precvpriv->lock, &irqL);
 
@@ -1187,7 +1187,7 @@ static void usb_read_port_complete(struc
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));
 
 	#ifdef CONFIG_PREALLOC_RECV_SKB
-		precvbuf->reuse = _TRUE;
+		precvbuf->reuse = true;
 	#else
 		if(precvbuf->pskb){
 			DBG_8192C("==> free skb(%p)\n",precvbuf->pskb);
@@ -1203,7 +1203,7 @@ static void usb_read_port_complete(struc
 		if ((purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE))
 		{
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n"));
-			precvbuf->reuse = _TRUE;
+			precvbuf->reuse = true;
 			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
 		}
 		else
@@ -1217,7 +1217,7 @@ static void usb_read_port_complete(struc
 				tasklet_schedule(&precvpriv->recv_tasklet);
 
 			precvbuf->pskb = NULL;
-			precvbuf->reuse = _FALSE;
+			precvbuf->reuse = false;
 			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
 		}
 	}
@@ -1232,15 +1232,15 @@ static void usb_read_port_complete(struc
 			case -EPIPE:
 			case -ENODEV:
 			case -ESHUTDOWN:
-				//padapter->bSurpriseRemoved=_TRUE;
+				//padapter->bSurpriseRemoved=true;
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
 			case -ENOENT:
-				padapter->bDriverStopped=_TRUE;
+				padapter->bDriverStopped=true;
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
 				break;
 			case -EPROTO:
 			case -EOVERFLOW:
-				precvbuf->reuse = _TRUE;
+				precvbuf->reuse = true;
 				rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
 				break;
 			case -EINPROGRESS:
@@ -1281,11 +1281,11 @@ _func_enter_;
 	}
 
 #ifdef CONFIG_PREALLOC_RECV_SKB
-	if((precvbuf->reuse == _FALSE) || (precvbuf->pskb == NULL))
+	if((precvbuf->reuse == false) || (precvbuf->pskb == NULL))
 	{
 		if (NULL != (precvbuf->pskb = skb_dequeue(&precvpriv->free_recv_skb_queue)))
 		{
-			precvbuf->reuse = _TRUE;
+			precvbuf->reuse = true;
 		}
 	}
 #endif
@@ -1296,7 +1296,7 @@ _func_enter_;
 		rtl8192du_init_recvbuf(adapter, precvbuf);
 
 		//re-assign for linux based on skb
-		if((precvbuf->reuse == _FALSE) || (precvbuf->pskb == NULL))
+		if((precvbuf->reuse == false) || (precvbuf->pskb == NULL))
 		{
 			//precvbuf->pskb = alloc_skb(MAX_RECVBUF_SZ, GFP_ATOMIC);//don't use this after v2.6.25
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
@@ -1328,12 +1328,12 @@ _func_enter_;
 			precvbuf->pend = skb_end_pointer(precvbuf->pskb);
 			precvbuf->pbuf = precvbuf->pskb->data;
 
-			precvbuf->reuse = _FALSE;
+			precvbuf->reuse = false;
 		}
 
 		//_enter_critical(&precvpriv->lock, &irqL);
 		//precvpriv->rx_pending_cnt++;
-		//precvbuf->irp_pending = _TRUE;
+		//precvbuf->irp_pending = true;
 		//_exit_critical(&precvpriv->lock, &irqL);
 
 		precvpriv->rx_pending_cnt++;
@@ -1371,20 +1371,20 @@ _func_exit_;
 
 void rtl8192du_xmit_tasklet(void *priv)
 {
-	int ret = _FALSE;
+	int ret = false;
 	_adapter *padapter = (_adapter*)priv;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
-	if(check_fwstate(&padapter->mlmepriv, _FW_UNDER_SURVEY) == _TRUE
+	if(check_fwstate(&padapter->mlmepriv, _FW_UNDER_SURVEY) == true
 #ifdef CONFIG_DUALMAC_CONCURRENT
-		|| (dc_check_xmit(padapter)== _FALSE)
+		|| (dc_check_xmit(padapter)== false)
 #endif
 		)
 		return;
 
 	while(1)
 	{
-		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
+		if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
 		{
 			DBG_8192C("xmit_tasklet => bDriverStopped or bSurpriseRemoved \n");
 			break;
@@ -1392,7 +1392,7 @@ void rtl8192du_xmit_tasklet(void *priv)
 
 		ret = rtl8192du_xmitframe_complete(padapter, pxmitpriv, NULL);
 
-		if(ret==_FALSE)
+		if(ret==false)
 			break;
 	}
 
--- a/drivers/staging/rtl8192du/include/basic_types.h
+++ b/drivers/staging/rtl8192du/include/basic_types.h
@@ -26,18 +26,6 @@
 #define SUCCESS	0
 #define FAIL	(-1)
 
-#ifndef TRUE
-	#define _TRUE	1
-#else
-	#define _TRUE	TRUE
-#endif
-
-#ifndef FALSE
-	#define _FALSE	0
-#else
-	#define _FALSE	FALSE
-#endif
-
 #include <linux/types.h>
 #define IN
 #define OUT
--- a/drivers/staging/rtl8192du/include/ieee80211.h
+++ b/drivers/staging/rtl8192du/include/ieee80211.h
@@ -193,19 +193,19 @@ enum NETWORK_TYPE
 #define SUPPORTED_24G_NETTYPE_MSK (WIRELESS_11B | WIRELESS_11G | WIRELESS_11_24N)
 #define SUPPORTED_5G_NETTYPE_MSK (WIRELESS_11A | WIRELESS_11_5N)
 
-#define IsSupported24G(NetType) ((NetType) & SUPPORTED_24G_NETTYPE_MSK ? _TRUE : _FALSE)
-#define IsSupported5G(NetType) ((NetType) & SUPPORTED_5G_NETTYPE_MSK ? _TRUE : _FALSE)
+#define IsSupported24G(NetType) ((NetType) & SUPPORTED_24G_NETTYPE_MSK ? true : false)
+#define IsSupported5G(NetType) ((NetType) & SUPPORTED_5G_NETTYPE_MSK ? true : false)
 
 #define IsEnableHWCCK(NetType) IsSupported24G(NetType)
-#define IsEnableHWOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11_24N|SUPPORTED_5G_NETTYPE_MSK) ? _TRUE : _FALSE)
+#define IsEnableHWOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11_24N|SUPPORTED_5G_NETTYPE_MSK) ? true : false)
 
 #define IsSupportedRxCCK(NetType) IsEnableHWCCK(NetType)
 #define IsSupportedRxOFDM(NetType) IsEnableHWOFDM(NetType)
 #define IsSupportedRxMCS(NetType) IsEnableHWOFDM(NetType)
 
-#define IsSupportedTxCCK(NetType) ((NetType) & (WIRELESS_11B) ? _TRUE : _FALSE)
-#define IsSupportedTxOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11A) ? _TRUE : _FALSE)
-#define IsSupportedTxMCS(NetType) ((NetType) & (WIRELESS_11_24N|WIRELESS_11_5N) ? _TRUE : _FALSE)
+#define IsSupportedTxCCK(NetType) ((NetType) & (WIRELESS_11B) ? true : false)
+#define IsSupportedTxOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11A) ? true : false)
+#define IsSupportedTxMCS(NetType) ((NetType) & (WIRELESS_11_24N|WIRELESS_11_5N) ? true : false)
 
 
 typedef struct ieee_param {
--- a/drivers/staging/rtl8192du/include/osdep_service.h
+++ b/drivers/staging/rtl8192du/include/osdep_service.h
@@ -29,12 +29,6 @@
 #define RTW_RX_HANDLED 2
 //#define RTW_STATUS_TIMEDOUT -110
 
-#undef _TRUE
-#define _TRUE		1
-
-#undef _FALSE
-#define _FALSE		0
-
 	#include <linux/version.h>
 	#include <linux/spinlock.h>
 	#include <linux/compiler.h>
@@ -243,7 +237,7 @@ __inline static void _set_timer(_timer *
 __inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
 {
 	del_timer_sync(ptimer);
-	*bcancelled=  _TRUE;//TRUE ==1; FALSE==0
+	*bcancelled=  true;
 }
 
 #define RTW_TIMER_HDL_ARGS void *FunctionContext
--- a/drivers/staging/rtl8192du/include/rtl8192d_hal.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_hal.h
@@ -474,25 +474,25 @@ typedef enum _USB_RX_AGG_MODE{
 #define GET_CVID_ROM_VERSION(version)		((version) & ROM_VERSION_MASK)
 #define GET_CVID_CUT_VERSION(version)		((version) & CUT_VERSION_MASK)
 
-#define IS_81XXC(version)					((GET_CVID_IC_TYPE(version) == 0)? _TRUE : _FALSE)
-#define IS_8723_SERIES(version)				((GET_CVID_IC_TYPE(version) == CHIP_8723)? _TRUE : _FALSE)
-#define IS_92D(version)						((GET_CVID_IC_TYPE(version) == CHIP_92D)? _TRUE : _FALSE)
-#define IS_1T1R(version)						((GET_CVID_RF_TYPE(version))? _FALSE : _TRUE)
-#define IS_1T2R(version)						((GET_CVID_RF_TYPE(version) == RF_TYPE_1T2R)? _TRUE : _FALSE)
-#define IS_2T2R(version)						((GET_CVID_RF_TYPE(version) == RF_TYPE_2T2R)? _TRUE : _FALSE)
-#define IS_CHIP_VENDOR_UMC(version)			((GET_CVID_MANUFACTUER(version))? _TRUE: _FALSE)
+#define IS_81XXC(version)					((GET_CVID_IC_TYPE(version) == 0)? true : false)
+#define IS_8723_SERIES(version)				((GET_CVID_IC_TYPE(version) == CHIP_8723)? true : false)
+#define IS_92D(version)						((GET_CVID_IC_TYPE(version) == CHIP_92D)? true : false)
+#define IS_1T1R(version)						((GET_CVID_RF_TYPE(version))? false : true)
+#define IS_1T2R(version)						((GET_CVID_RF_TYPE(version) == RF_TYPE_1T2R)? true : false)
+#define IS_2T2R(version)						((GET_CVID_RF_TYPE(version) == RF_TYPE_2T2R)? true : false)
+#define IS_CHIP_VENDOR_UMC(version)			((GET_CVID_MANUFACTUER(version))? true: false)
 
-#define IS_92C_SERIAL(version)					((IS_81XXC(version) && IS_2T2R(version)) ? _TRUE : _FALSE)
-#define IS_VENDOR_UMC_A_CUT(version)		((IS_CHIP_VENDOR_UMC(version)) ? ((GET_CVID_CUT_VERSION(version)) ? _FALSE : _TRUE) : _FALSE)
-#define IS_VENDOR_8723_A_CUT(version)		((IS_8723_SERIES(version)) ? ((GET_CVID_CUT_VERSION(version)) ? _FALSE : _TRUE) : _FALSE)
+#define IS_92C_SERIAL(version)					((IS_81XXC(version) && IS_2T2R(version)) ? true : false)
+#define IS_VENDOR_UMC_A_CUT(version)		((IS_CHIP_VENDOR_UMC(version)) ? ((GET_CVID_CUT_VERSION(version)) ? false : true) : false)
+#define IS_VENDOR_8723_A_CUT(version)		((IS_8723_SERIES(version)) ? ((GET_CVID_CUT_VERSION(version)) ? false : true) : false)
 // <tynli_Note> 88/92C UMC B-cut vendor is set to TSMC so we need to check CHIP_VENDOR_UMC bit is not 1.
-#define IS_81xxC_VENDOR_UMC_B_CUT(version)	((IS_CHIP_VENDOR_UMC(version)) ? ((GET_CVID_CUT_VERSION(version) == B_CUT_VERSION) ? _TRUE : _FALSE):_FALSE)
-#define IS_92D_SINGLEPHY(version)			((IS_92D(version)) ? (IS_2T2R(version) ? _TRUE: _FALSE) : _FALSE)
+#define IS_81xxC_VENDOR_UMC_B_CUT(version)	((IS_CHIP_VENDOR_UMC(version)) ? ((GET_CVID_CUT_VERSION(version) == B_CUT_VERSION) ? true : false):false)
+#define IS_92D_SINGLEPHY(version)			((IS_92D(version)) ? (IS_2T2R(version) ? true: false) : false)
 
-#define IS_92D_C_CUT(version)				((IS_92D(version)) ? ((GET_CVID_CUT_VERSION(version) == C_CUT_VERSION) ? _TRUE : _FALSE) : _FALSE)
-#define IS_92D_D_CUT(version)				((IS_92D(version)) ? ((GET_CVID_CUT_VERSION(version) == D_CUT_VERSION) ? _TRUE : _FALSE) : _FALSE)
-#define IS_92D_E_CUT(version)				((IS_92D(version)) ? ((GET_CVID_CUT_VERSION(version) == E_CUT_VERSION) ? _TRUE : _FALSE) : _FALSE)
-#define IS_NORMAL_CHIP92D(version)		((GET_CVID_CHIP_TYPE(version))? _TRUE: _FALSE)
+#define IS_92D_C_CUT(version)				((IS_92D(version)) ? ((GET_CVID_CUT_VERSION(version) == C_CUT_VERSION) ? true : false) : false)
+#define IS_92D_D_CUT(version)				((IS_92D(version)) ? ((GET_CVID_CUT_VERSION(version) == D_CUT_VERSION) ? true : false) : false)
+#define IS_92D_E_CUT(version)				((IS_92D(version)) ? ((GET_CVID_CUT_VERSION(version) == E_CUT_VERSION) ? true : false) : false)
+#define IS_NORMAL_CHIP92D(version)		((GET_CVID_CHIP_TYPE(version)) ? true : false)
 
 typedef enum _VERSION_8192D{
 	VERSION_TEST_CHIP_88C = 0x0000,
--- a/drivers/staging/rtl8192du/include/rtl8192d_spec.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_spec.h
@@ -653,8 +653,8 @@ Default: 00b.
 #define	TOTAL_CAM_ENTRY			32
 #define	HALF_CAM_ENTRY			16
 
-#define	CAM_CONFIG_USEDK			_TRUE
-#define	CAM_CONFIG_NO_USEDK		_FALSE
+#define	CAM_CONFIG_USEDK			true
+#define	CAM_CONFIG_NO_USEDK		false
 
 #define	CAM_WRITE					BIT16
 #define	CAM_READ					0x00000000
@@ -1640,15 +1640,15 @@ Current IOREG MAP
 
 //2 RXERR_RPT
 #define RXERR_TYPE_OFDM_PPDU			0
-#define RXERR_TYPE_OFDM_FALSE_ALARM	1
+#define RXERR_TYPE_OFDMfalse_ALARM	1
 #define RXERR_TYPE_OFDM_MPDU_OK		2
 #define RXERR_TYPE_OFDM_MPDU_FAIL	3
 #define RXERR_TYPE_CCK_PPDU			4
-#define RXERR_TYPE_CCK_FALSE_ALARM	5
+#define RXERR_TYPE_CCKfalse_ALARM	5
 #define RXERR_TYPE_CCK_MPDU_OK		6
 #define RXERR_TYPE_CCK_MPDU_FAIL		7
 #define RXERR_TYPE_HT_PPDU				8
-#define RXERR_TYPE_HT_FALSE_ALARM	9
+#define RXERR_TYPE_HTfalse_ALARM	9
 #define RXERR_TYPE_HT_MPDU_TOTAL		10
 #define RXERR_TYPE_HT_MPDU_OK			11
 #define RXERR_TYPE_HT_MPDU_FAIL		12
--- a/drivers/staging/rtl8192du/include/rtw_mlme.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme.h
@@ -352,7 +352,7 @@ struct wifidirect_info{
 struct tdls_ss_record{	//signal strength record; recording the tdls sta with lowerest ss
 	u8		macaddr[ETH_ALEN];
 	u8		RxPWDBAll;
-	u8		is_tdls_sta;	// _TRUE: direct link sta, _FALSE: else
+	u8		is_tdls_sta;	// true: direct link sta, false: else
 };
 
 struct tdls_info{
@@ -600,9 +600,9 @@ __inline static u8 *get_bssid(struct mlm
 __inline static sint check_fwstate(struct mlme_priv *pmlmepriv, sint state)
 {
 	if (pmlmepriv->fw_state & state)
-		return _TRUE;
+		return true;
 
-	return _FALSE;
+	return false;
 }
 
 __inline static sint get_fwstate(struct mlme_priv *pmlmepriv)
@@ -636,7 +636,7 @@ __inline static void clr_fwstate(struct
 	_irqL irqL;
 
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
-	if (check_fwstate(pmlmepriv, state) == _TRUE)
+	if (check_fwstate(pmlmepriv, state) == true)
 		pmlmepriv->fw_state ^= state;
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 }
@@ -713,7 +713,7 @@ void rtw_clear_scan_deny(_adapter *adapt
 void rtw_set_scan_deny_timer_hdl(_adapter *adapter);
 void rtw_set_scan_deny(_adapter *adapter, u32 ms);
 #else
-#define rtw_is_scan_deny(adapter) _FALSE
+#define rtw_is_scan_deny(adapter) false
 #define rtw_clear_scan_deny(adapter) do {} while (0)
 #define rtw_set_scan_deny_timer_hdl(adapter) do {} while (0)
 #define rtw_set_scan_deny(adapter, ms) do {} while (0)
--- a/drivers/staging/rtl8192du/include/rtw_mp.h
+++ b/drivers/staging/rtl8192du/include/rtw_mp.h
@@ -334,8 +334,8 @@ struct bb_reg_param {
 };
 //=======================================================================
 
-#define LOWER	_TRUE
-#define RAISE	_FALSE
+#define LOWER	true
+#define RAISE	false
 
 /* Hardware Registers */
 #define BB_REG_BASE_ADDR		0x800
--- a/drivers/staging/rtl8192du/include/rtw_pwrctrl.h
+++ b/drivers/staging/rtl8192du/include/rtw_pwrctrl.h
@@ -163,7 +163,7 @@ typedef enum _rt_rf_power_state
 #define	RT_RF_LPS_DISALBE_2R			BIT(30)	// When LPS is on, disable 2R if no packet is received or transmittd.
 #define	RT_RF_LPS_LEVEL_ASPM			BIT(31)	// LPS with ASPM
 
-#define	RT_IN_PS_LEVEL(ppsc, _PS_FLAG)		((ppsc->cur_ps_level & _PS_FLAG) ? _TRUE : _FALSE)
+#define	RT_IN_PS_LEVEL(ppsc, _PS_FLAG)		((ppsc->cur_ps_level & _PS_FLAG) ? true : false)
 #define	RT_CLEAR_PS_LEVEL(ppsc, _PS_FLAG)	(ppsc->cur_ps_level &= (~(_PS_FLAG)))
 #define	RT_SET_PS_LEVEL(ppsc, _PS_FLAG)		(ppsc->cur_ps_level |= _PS_FLAG)
 
@@ -331,8 +331,8 @@ void rtw_set_do_late_resume(struct pwrct
 void rtw_register_early_suspend(struct pwrctrl_priv *pwrpriv);
 void rtw_unregister_early_suspend(struct pwrctrl_priv *pwrpriv);
 #else
-#define rtw_is_earlysuspend_registered(pwrpriv) _FALSE
-#define rtw_is_do_late_resume(pwrpriv) _FALSE
+#define rtw_is_earlysuspend_registered(pwrpriv) false
+#define rtw_is_do_late_resume(pwrpriv) false
 #define rtw_set_do_late_resume(pwrpriv, enable) do {} while (0)
 #define rtw_register_early_suspend(pwrpriv) do {} while (0)
 #define rtw_unregister_early_suspend(pwrpriv) do {} while (0)
--- a/drivers/staging/rtl8192du/include/rtw_security.h
+++ b/drivers/staging/rtl8192du/include/rtw_security.h
@@ -144,7 +144,7 @@ struct security_priv
 	s32	sw_encrypt;//from registry_priv
 	s32	sw_decrypt;//from registry_priv
 
-	s32	hw_decrypted;//if the rx packets is hw_decrypted==_FALSE, it means the hw has not been ready.
+	s32	hw_decrypted;//if the rx packets is hw_decrypted==false, it means the hw has not been ready.
 
 
 	//keeps the auth_type & enc_status from upper layer ioctl(wpa_supplicant or wzc)
--- a/drivers/staging/rtl8192du/include/usb_ops.h
+++ b/drivers/staging/rtl8192du/include/usb_ops.h
@@ -62,16 +62,16 @@ void rtl8192du_xmit_tasklet(void *priv);
 
 /*
 * Increase and check if the continual_urb_error of this @param dvobjprive is larger than MAX_CONTINUAL_URB_ERR
-* @return _TRUE:
-* @return _FALSE:
+* @return true:
+* @return false:
 */
 static inline int rtw_inc_and_chk_continual_urb_error(struct dvobj_priv *dvobj)
 {
-	int ret = _FALSE;
+	int ret = false;
 	int value;
 	if( (value=ATOMIC_INC_RETURN(&dvobj->continual_urb_error)) > MAX_CONTINUAL_URB_ERR) {
 		DBG_871X("[dvobj:%p][ERROR] continual_urb_error:%d > %d\n", dvobj, value, MAX_CONTINUAL_URB_ERR);
-		ret = _TRUE;
+		ret = true;
 	} else {
 		//DBG_871X("[dvobj:%p] continual_urb_error:%d\n", dvobj, value);
 	}
--- a/drivers/staging/rtl8192du/include/wifi.h
+++ b/drivers/staging/rtl8192du/include/wifi.h
@@ -416,15 +416,15 @@ enum WIFI_REG_DOMAIN {
 ( \
 	( (addr[0] == 0xff) && (addr[1] == 0xff) && \
 		(addr[2] == 0xff) && (addr[3] == 0xff) && \
-		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? _TRUE : _FALSE \
+		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? true : false \
 )
 
 __inline static int IS_MCAST(unsigned char *da)
 {
 	if ((*da) & 0x01)
-		return _TRUE;
+		return true;
 	else
-		return _FALSE;
+		return false;
 }
 
 
@@ -505,9 +505,9 @@ __inline static unsigned char * get_hdr_
 __inline static int IsFrameTypeCtrl(unsigned char *pframe)
 {
 	if(WIFI_CTRL_TYPE == GetFrameType(pframe))
-		return _TRUE;
+		return true;
 	else
-		return _FALSE;
+		return false;
 }
 /*-----------------------------------------------------------------------------
 			Below is for the security related definition
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -365,7 +365,7 @@ static int rtw_cfg80211_inform_bss(_adap
 	notify_ielen = pnetwork->network.IELength-_FIXED_IE_LENGTH_;
 
 	//We've set wiphy's signal_type as CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm)
-	if ( check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE &&
+	if ( check_fwstate(pmlmepriv, _FW_LINKED)== true &&
 		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network)) {
 		notify_signal = 100*translate_percentage_to_dbm(padapter->recvpriv.signal_strength);//dbm
 	} else {
@@ -492,7 +492,7 @@ void rtw_cfg80211_indicate_connect(_adap
 		return;
 	}
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		return;
 
 #ifdef CONFIG_P2P
@@ -565,7 +565,7 @@ void rtw_cfg80211_indicate_disconnect(_a
 		return;
 	}
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		return;
 
 #ifdef CONFIG_P2P
@@ -855,7 +855,7 @@ static int rtw_cfg80211_ap_set_encryptio
 				_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 				_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 
-				psecuritypriv->busetkipkey = _TRUE;
+				psecuritypriv->busetkipkey = true;
 
 			}
 			else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
@@ -875,7 +875,7 @@ static int rtw_cfg80211_ap_set_encryptio
 
 			psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
 
-			psecuritypriv->binstallGrpkey = _TRUE;
+			psecuritypriv->binstallGrpkey = true;
 
 			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
 
@@ -884,7 +884,7 @@ static int rtw_cfg80211_ap_set_encryptio
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
 			if(pbcmc_sta)
 			{
-				pbcmc_sta->ieee8021x_blocked = _FALSE;
+				pbcmc_sta->ieee8021x_blocked = false;
 				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
 			}
 
@@ -923,7 +923,7 @@ static int rtw_cfg80211_ap_set_encryptio
 					_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 					_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
-					psecuritypriv->busetkipkey = _TRUE;
+					psecuritypriv->busetkipkey = true;
 
 				}
 				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
@@ -942,9 +942,9 @@ static int rtw_cfg80211_ap_set_encryptio
 
 				set_pairwise_key(padapter, psta);
 
-				psta->ieee8021x_blocked = _FALSE;
+				psta->ieee8021x_blocked = false;
 
-				psta->bpairwise_key_installed = _TRUE;
+				psta->bpairwise_key_installed = true;
 
 			}
 			else//group key???
@@ -970,7 +970,7 @@ static int rtw_cfg80211_ap_set_encryptio
 					_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 					_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 
-					psecuritypriv->busetkipkey = _TRUE;
+					psecuritypriv->busetkipkey = true;
 
 				}
 				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
@@ -986,7 +986,7 @@ static int rtw_cfg80211_ap_set_encryptio
 
 				psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
 
-				psecuritypriv->binstallGrpkey = _TRUE;
+				psecuritypriv->binstallGrpkey = true;
 
 				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
 
@@ -995,7 +995,7 @@ static int rtw_cfg80211_ap_set_encryptio
 				pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
 				if(pbcmc_sta)
 				{
-					pbcmc_sta->ieee8021x_blocked = _FALSE;
+					pbcmc_sta->ieee8021x_blocked = false;
 					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
 				}
 
@@ -1099,7 +1099,7 @@ _func_enter_;
 
 		//DBG_8192C("%s, : dot11AuthAlgrthm == dot11AuthAlgrthm_8021X \n", __func__);
 
-		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == _TRUE) //sta mode
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true) //sta mode
 		{
 			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
 			if (psta == NULL) {
@@ -1110,7 +1110,7 @@ _func_enter_;
 			{
 				//Jeff: don't disable ieee8021x_blocked while clearing key
 				if (strcmp(param->u.crypt.alg, "none") != 0)
-					psta->ieee8021x_blocked = _FALSE;
+					psta->ieee8021x_blocked = false;
 
 
 				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
@@ -1132,21 +1132,21 @@ _func_enter_;
 						_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 						_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
-						padapter->securitypriv.busetkipkey=_FALSE;
+						padapter->securitypriv.busetkipkey=false;
 						//_set_timer(&padapter->securitypriv.tkip_timer, 50);
 					}
 
 					//DEBUG_ERR((" param->u.crypt.key_len=%d\n",param->u.crypt.key_len));
 					DBG_871X(" ~~~~set sta key:unicastkey\n");
 
-					rtw_setstakey_cmd(padapter, (unsigned char *)psta, _TRUE);
+					rtw_setstakey_cmd(padapter, (unsigned char *)psta, true);
 				}
 				else//group key
 				{
 					_rtw_memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 					_rtw_memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[16]),8);
 					_rtw_memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[24]),8);
-                                        padapter->securitypriv.binstallGrpkey = _TRUE;
+                                        padapter->securitypriv.binstallGrpkey = true;
 					//DEBUG_ERR((" param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
 					DBG_871X(" ~~~~set sta key:groupkey\n");
 
@@ -1172,7 +1172,7 @@ _func_enter_;
 			{
 				//Jeff: don't disable ieee8021x_blocked while clearing key
 				if (strcmp(param->u.crypt.alg, "none") != 0)
-					pbcmc_sta->ieee8021x_blocked = _FALSE;
+					pbcmc_sta->ieee8021x_blocked = false;
 
 				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
 						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
@@ -1275,11 +1275,11 @@ static int cfg80211_rtw_add_key(struct w
 		_rtw_memcpy(param->u.crypt.key, params->key, params->key_len);
 	}
 
-	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 	{
 		ret =  rtw_cfg80211_set_encryption(ndev, param, param_len);
 	}
-	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 #ifdef CONFIG_AP_MODE
 		if(mac_addr)
@@ -1415,7 +1415,7 @@ static int cfg80211_rtw_get_station(stru
 	{
 		struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
 
-		if (_rtw_memcmp(mac, cur_network->network.MacAddress, ETH_ALEN) == _FALSE) {
+		if (_rtw_memcmp(mac, cur_network->network.MacAddress, ETH_ALEN) == false) {
 			DBG_871X("%s, mismatch bssid="MAC_FMT"\n", __func__, MAC_ARG(cur_network->network.MacAddress));
 			ret = -ENOENT;
 			goto exit;
@@ -1488,7 +1488,7 @@ static int cfg80211_rtw_change_iface(str
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 #endif
 	int ret = 0;
-	u8 change = _FALSE;
+	u8 change = false;
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if(padapter->adapter_type == SECONDARY_ADAPTER)
@@ -1520,7 +1520,7 @@ static int cfg80211_rtw_change_iface(str
 
 	if(old_type != type)
 	{
-		change = _TRUE;
+		change = true;
 		pmlmeext->action_public_rxseq = 0xffff;
 		pmlmeext->action_public_dialog_token = 0xff;
 	}
@@ -1571,7 +1571,7 @@ static int cfg80211_rtw_change_iface(str
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 	_enter_critical_bh(&queue->lock, &irqL);
 
-	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==_FALSE)
+	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==false)
 	{
 		rtw_wdev->iftype = old_type;
 		ret = -EPERM;
@@ -1650,7 +1650,7 @@ void rtw_cfg80211_surveydone_event_callb
 
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+		if (rtw_end_of_queue_search(phead,plist)== true)
 			break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -1658,7 +1658,7 @@ void rtw_cfg80211_surveydone_event_callb
 		//report network only if the current channel set contains the channel to which this network belongs
 		if(rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
 			#ifdef CONFIG_VALIDATE_SSID
-			&& _TRUE == rtw_validate_ssid(&(pnetwork->network.Ssid))
+			&& true == rtw_validate_ssid(&(pnetwork->network.Ssid))
 			#endif
 		)
 		{
@@ -1673,7 +1673,7 @@ void rtw_cfg80211_surveydone_event_callb
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 
 	//call this after other things have been done
-	rtw_cfg80211_indicate_scan_done(wdev_to_priv(padapter->rtw_wdev), _FALSE);
+	rtw_cfg80211_indicate_scan_done(wdev_to_priv(padapter->rtw_wdev), false);
 }
 
 static int rtw_cfg80211_set_probe_req_wpsp2pie(_adapter *padapter, char *buf, int len)
@@ -1787,7 +1787,7 @@ static int cfg80211_rtw_scan(struct wiph
 	, struct cfg80211_scan_request *request)
 {
 	int i;
-	u8 _status = _FALSE;
+	u8 _status = false;
 	int ret = 0;
 	_adapter *padapter = wiphy_to_adapter(wiphy);
 	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
@@ -1804,7 +1804,7 @@ static int cfg80211_rtw_scan(struct wiph
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 	struct cfg80211_ssid *ssids = request->ssids;
 	int social_channel = 0, j = 0;
-	bool need_indicate_scan_done = _FALSE;
+	bool need_indicate_scan_done = false;
 #ifdef CONFIG_CONCURRENT_MODE
 	PADAPTER pbuddy_adapter = NULL;
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
@@ -1823,7 +1823,7 @@ static int cfg80211_rtw_scan(struct wiph
 #endif //CONFIG_CONCURRENT_MODE
 
 #ifdef CONFIG_MP_INCLUDED
-	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
 	{
 		ret = -EPERM;
 		goto exit;
@@ -1834,18 +1834,18 @@ static int cfg80211_rtw_scan(struct wiph
 	pwdev_priv->scan_request = request;
 	_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
 
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 
 #ifdef CONFIG_DEBUG_CFG80211
 		DBG_871X("%s under WIFI_AP_STATE\n", __FUNCTION__);
 #endif
-		//need_indicate_scan_done = _TRUE;
+		//need_indicate_scan_done = true;
 		//goto check_need_indicate_scan_done;
 	}
 
 	if(_FAIL == rtw_pwr_wakeup(padapter)) {
-		need_indicate_scan_done = _TRUE;
+		need_indicate_scan_done = true;
 		goto check_need_indicate_scan_done;
 	}
 
@@ -1858,7 +1858,7 @@ static int cfg80211_rtw_scan(struct wiph
 		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
 			rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
-			wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = _TRUE;
+			wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = true;
 		}
 		else
 		{
@@ -1885,47 +1885,47 @@ static int cfg80211_rtw_scan(struct wiph
 		rtw_cfg80211_set_probe_req_wpsp2pie(padapter, (u8 *)request->ie, request->ie_len );
 	}
 
-	if (pmlmepriv->LinkDetectInfo.bBusyTraffic == _TRUE)
+	if (pmlmepriv->LinkDetectInfo.bBusyTraffic == true)
 	{
-		DBG_8192C("%s, bBusyTraffic == _TRUE\n", __func__);
-		need_indicate_scan_done = _TRUE;
+		DBG_8192C("%s, bBusyTraffic == true\n", __func__);
+		need_indicate_scan_done = true;
 		goto check_need_indicate_scan_done;
 	}
 	if (rtw_is_scan_deny(padapter)){
 		DBG_871X(FUNC_ADPT_FMT  ": scan deny\n", FUNC_ADPT_ARG(padapter));
-		need_indicate_scan_done = _TRUE;
+		need_indicate_scan_done = true;
 		goto check_need_indicate_scan_done;
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(pbuddy_mlmepriv && (pbuddy_mlmepriv->LinkDetectInfo.bBusyTraffic == _TRUE))
+	if(pbuddy_mlmepriv && (pbuddy_mlmepriv->LinkDetectInfo.bBusyTraffic == true))
 	{
-		DBG_8192C("%s, bBusyTraffic == _TRUE at buddy_intf\n", __func__);
-		need_indicate_scan_done = _TRUE;
+		DBG_8192C("%s, bBusyTraffic == true at buddy_intf\n", __func__);
+		need_indicate_scan_done = true;
 		goto check_need_indicate_scan_done;
 	}
 #endif //CONFIG_CONCURRENT_MODE
 
-	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
 	{
 		DBG_8192C("%s, fwstate=0x%x\n", __func__, pmlmepriv->fw_state);
-		need_indicate_scan_done = _TRUE;
+		need_indicate_scan_done = true;
 		goto check_need_indicate_scan_done;
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter,
-		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE)
+		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == true)
 	{
 		if(check_buddy_fwstate(padapter, _FW_UNDER_SURVEY))
 		{
 			DBG_8192C("scanning_via_buddy_intf\n");
-			pmlmepriv->scanning_via_buddy_intf = _TRUE;
+			pmlmepriv->scanning_via_buddy_intf = true;
 		}
 
 		DBG_8192C("buddy_intf's mlme state:0x%x\n", pbuddy_mlmepriv->fw_state);
 
-		need_indicate_scan_done = _TRUE;
+		need_indicate_scan_done = true;
 		goto check_need_indicate_scan_done;
 	}
 #endif
@@ -1935,7 +1935,7 @@ static int cfg80211_rtw_scan(struct wiph
 	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 	{
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
-		rtw_free_network_queue(padapter, _TRUE);
+		rtw_free_network_queue(padapter, true);
 
 		if(social_channel == 0)
 			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
@@ -1978,7 +1978,7 @@ static int cfg80211_rtw_scan(struct wiph
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 
 
-	if(_status == _FALSE)
+	if(_status == false)
 	{
 		ret = -1;
 	}
@@ -2354,7 +2354,7 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
 		//WPS open need to enable multicast
-		//|| check_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS) == _TRUE)
+		//|| check_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS) == true)
 		rtw_hal_set_hwreg(padapter, HW_VAR_OFF_RCR_AM, null_addr);
 
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
@@ -2380,9 +2380,9 @@ static int cfg80211_rtw_connect(struct w
 	NDIS_802_11_SSID ndis_ssid;
 	u8 *dst_ssid, *src_ssid;
 	u8 *dst_bssid, *src_bssid;
-	//u8 matched_by_bssid=_FALSE;
-	//u8 matched_by_ssid=_FALSE;
-	u8 matched=_FALSE;
+	//u8 matched_by_bssid=false;
+	//u8 matched_by_ssid=false;
+	u8 matched=false;
 	_adapter *padapter = wiphy_to_adapter(wiphy);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
@@ -2393,7 +2393,7 @@ static int cfg80211_rtw_connect(struct w
 		sme->privacy, sme->key, sme->key_len, sme->key_idx);
 
 
-	if(wdev_to_priv(padapter->rtw_wdev)->block == _TRUE)
+	if(wdev_to_priv(padapter->rtw_wdev)->block == true)
 	{
 		ret = -EBUSY;
 		DBG_871X("%s wdev_priv.block is set\n", __FUNCTION__);
@@ -2411,12 +2411,12 @@ static int cfg80211_rtw_connect(struct w
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(padapter, _FW_UNDER_LINKING) == _TRUE) {
+	if (check_buddy_fwstate(padapter, _FW_UNDER_LINKING) == true) {
 		DBG_8192C("%s, but buddy_intf is under linking\n", __FUNCTION__);
 		ret = -EINVAL;
 		goto exit;
 	}
-	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY) == _TRUE) {
+	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY) == true) {
 		rtw_scan_abort(padapter->pbuddy_adapter);
 	}
 #endif
@@ -2445,12 +2445,12 @@ static int cfg80211_rtw_connect(struct w
 		DBG_8192C("bssid="MAC_FMT"\n", MAC_ARG(sme->bssid));
 
 
-	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE) {
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {
 		ret = -EBUSY;
 		DBG_8192C("%s, fw_state=0x%x, goto exit\n", __FUNCTION__, pmlmepriv->fw_state);
 		goto exit;
 	}
-	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
 		rtw_scan_abort(padapter);
 	}
 
@@ -2462,7 +2462,7 @@ static int cfg80211_rtw_connect(struct w
 
 	while (1)
 	{
-		if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == _TRUE)
+		if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == true)
 		{
 			break;
 		}
@@ -2474,13 +2474,13 @@ static int cfg80211_rtw_connect(struct w
 		dst_bssid = pnetwork->network.MacAddress;
 
 		if(sme->bssid)  {
-			if(_rtw_memcmp(pnetwork->network.MacAddress, sme->bssid, ETH_ALEN) == _FALSE)
+			if(_rtw_memcmp(pnetwork->network.MacAddress, sme->bssid, ETH_ALEN) == false)
 				continue;
 		}
 
 		if(sme->ssid && sme->ssid_len) {
 			if(	pnetwork->network.Ssid.SsidLength != sme->ssid_len
-				|| _rtw_memcmp(pnetwork->network.Ssid.Ssid, sme->ssid, sme->ssid_len) == _FALSE
+				|| _rtw_memcmp(pnetwork->network.Ssid.Ssid, sme->ssid, sme->ssid_len) == false
 			)
 				continue;
 		}
@@ -2490,14 +2490,14 @@ static int cfg80211_rtw_connect(struct w
 		{
 			src_bssid = sme->bssid;
 
-			if ((_rtw_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == _TRUE)
+			if ((_rtw_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == true)
 			{
 				DBG_8192C("matched by bssid\n");
 
 				ndis_ssid.SsidLength = pnetwork->network.Ssid.SsidLength;
 				_rtw_memcpy(ndis_ssid.Ssid, pnetwork->network.Ssid.Ssid, pnetwork->network.Ssid.SsidLength);
 
-				matched=_TRUE;
+				matched=true;
 				break;
 			}
 
@@ -2506,28 +2506,28 @@ static int cfg80211_rtw_connect(struct w
 		{
 			src_ssid = ndis_ssid.Ssid;
 
-			if ((_rtw_memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength) == _TRUE) &&
+			if ((_rtw_memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength) == true) &&
 				(pnetwork->network.Ssid.SsidLength==ndis_ssid.SsidLength))
 			{
 				DBG_8192C("matched by ssid\n");
-				matched=_TRUE;
+				matched=true;
 				break;
 			}
 		}
 
 	}
 
-	if((matched == _FALSE) || (pnetwork== NULL))
+	if((matched == false) || (pnetwork== NULL))
 	{
 		ret = -ENOENT;
-		DBG_8192C("connect, matched == _FALSE, goto exit\n");
+		DBG_8192C("connect, matched == false, goto exit\n");
 		_exit_critical_bh(&queue->lock, &irqL);
 		_exit_critical_bh(&pmlmepriv->lock, &irqL);
 		goto exit;
 	}
 
 
-	if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == _FALSE)
+	if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == false)
 	{
 		ret = -EPERM;
 		_exit_critical_bh(&queue->lock, &irqL);
@@ -2559,7 +2559,7 @@ static int cfg80211_rtw_connect(struct w
 		goto exit;
 
 	if (sme->crypto.n_ciphers_pairwise) {
-		ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.ciphers_pairwise[0], _TRUE);
+		ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.ciphers_pairwise[0], true);
 		if (ret < 0)
 			goto exit;
 	}
@@ -2626,7 +2626,7 @@ static int cfg80211_rtw_connect(struct w
 			goto exit;
 	}
 
-	ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.cipher_group, _FALSE);
+	ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.cipher_group, false);
 	if (ret < 0)
 		return ret;
 
@@ -2641,7 +2641,7 @@ static int cfg80211_rtw_connect(struct w
 
 	//rtw_set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
 
-	if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == _FALSE) {
+	if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == false) {
 		ret = -1;
 		goto exit;
 	}
@@ -2669,13 +2669,13 @@ static int cfg80211_rtw_disconnect(struc
 	{
 		rtw_scan_abort(padapter);
 		LeaveAllPowerSaveMode(padapter);
-		rtw_disassoc_cmd(padapter, 500, _FALSE);
+		rtw_disassoc_cmd(padapter, 500, false);
 
 		DBG_871X("%s...call rtw_indicate_disconnect\n", __FUNCTION__);
 
-		padapter->mlmepriv.not_indic_disco = _TRUE;
+		padapter->mlmepriv.not_indic_disco = true;
 		rtw_indicate_disconnect(padapter);
-		padapter->mlmepriv.not_indic_disco = _FALSE;
+		padapter->mlmepriv.not_indic_disco = false;
 
 		rtw_free_assoc_resources(padapter, 1);
 	}
@@ -2738,31 +2738,31 @@ static int cfg80211_rtw_set_pmksa(struct
 				  struct net_device *netdev,
 				  struct cfg80211_pmksa *pmksa)
 {
-	u8	index,blInserted = _FALSE;
+	u8	index,blInserted = false;
 	_adapter	*padapter = wiphy_to_adapter(wiphy);
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 	u8	strZeroMacAddress[ ETH_ALEN ] = { 0x00 };
 
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
 
-	if ( _rtw_memcmp( pmksa->bssid, strZeroMacAddress, ETH_ALEN ) == _TRUE )
+	if ( _rtw_memcmp( pmksa->bssid, strZeroMacAddress, ETH_ALEN ) == true )
 	{
 		return -EINVAL;
 	}
 
-	blInserted = _FALSE;
+	blInserted = false;
 
 	//overwrite PMKID
 	for(index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
-		if( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==_TRUE )
+		if( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==true )
 		{ // BSSID is matched, the same AP => rewrite with new PMKID.
 			DBG_871X(FUNC_NDEV_FMT" BSSID exists in the PMKList.\n", FUNC_NDEV_ARG(netdev));
 
 			_rtw_memcpy( psecuritypriv->PMKIDList[index].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
-			psecuritypriv->PMKIDList[index].bUsed = _TRUE;
+			psecuritypriv->PMKIDList[index].bUsed = true;
 			psecuritypriv->PMKIDIndex = index+1;
-			blInserted = _TRUE;
+			blInserted = true;
 			break;
 		}
 	}
@@ -2776,7 +2776,7 @@ static int cfg80211_rtw_set_pmksa(struct
 		_rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, pmksa->bssid, ETH_ALEN);
 		_rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
 
-		psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = _TRUE;
+		psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = true;
 		psecuritypriv->PMKIDIndex++ ;
 		if(psecuritypriv->PMKIDIndex==16)
 		{
@@ -2791,7 +2791,7 @@ static int cfg80211_rtw_del_pmksa(struct
 				  struct net_device *netdev,
 				  struct cfg80211_pmksa *pmksa)
 {
-	u8	index, bMatched = _FALSE;
+	u8	index, bMatched = false;
 	_adapter	*padapter = wiphy_to_adapter(wiphy);
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 
@@ -2799,17 +2799,17 @@ static int cfg80211_rtw_del_pmksa(struct
 
 	for(index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
-		if( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==_TRUE )
+		if( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==true )
 		{ // BSSID is matched, the same AP => Remove this PMKID information and reset it.
 			_rtw_memset( psecuritypriv->PMKIDList[index].Bssid, 0x00, ETH_ALEN );
 			_rtw_memset( psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN );
-			psecuritypriv->PMKIDList[index].bUsed = _FALSE;
-			bMatched = _TRUE;
+			psecuritypriv->PMKIDList[index].bUsed = false;
+			bMatched = true;
 			break;
 		}
 	}
 
-	if(_FALSE == bMatched)
+	if(false == bMatched)
 	{
 		DBG_871X(FUNC_NDEV_FMT" do not have matched BSSID\n"
 			, FUNC_NDEV_ARG(netdev));
@@ -3045,7 +3045,7 @@ static int rtw_cfg80211_monitor_if_xmit_
 		u8 category, action;
 		int type = -1;
 
-		if (rtw_action_frame_parse(buf, len, &category, &action) == _FALSE) {
+		if (rtw_action_frame_parse(buf, len, &category, &action) == false) {
 			DBG_8192C(FUNC_NDEV_FMT" frame_control:0x%x\n", FUNC_NDEV_ARG(ndev),
 				le16_to_cpu(((struct rtw_ieee80211_hdr_3addr *)buf)->frame_ctl));
 			goto fail;
@@ -3054,7 +3054,7 @@ static int rtw_cfg80211_monitor_if_xmit_
 		DBG_8192C("RTW_Tx:da="MAC_FMT" via "FUNC_NDEV_FMT"\n",
 			MAC_ARG(GetAddr1Ptr(buf)), FUNC_NDEV_ARG(ndev));
 		#ifdef CONFIG_P2P
-		if((type = rtw_p2p_check_frames(padapter, buf, len, _TRUE)) >= 0)
+		if((type = rtw_p2p_check_frames(padapter, buf, len, true)) >= 0)
 			goto dump;
 		#endif
 		if (category == RTW_WLAN_CATEGORY_PUBLIC)
@@ -3072,7 +3072,7 @@ dump:
 		//update attribute
 		pattrib = &pmgntframe->attrib;
 		update_mgntframe_attrib(padapter, pattrib);
-		pattrib->retry_ctrl = _FALSE;
+		pattrib->retry_ctrl = false;
 
 		_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
 
@@ -3086,7 +3086,7 @@ dump:
 
 			pwfd_info = padapter->wdinfo.wfd_info;
 
-			if ( _TRUE == pwfd_info->wfd_enable )
+			if ( true == pwfd_info->wfd_enable )
 			{
 				rtw_append_wfd_ie( padapter, pframe, &len );
 			}
@@ -3327,7 +3327,7 @@ static int rtw_add_beacon(_adapter *adap
 	uint len, wps_ielen=0;
 	uint p2p_ielen=0;
 	u8 *p2p_ie;
-	u8 got_p2p_ie = _FALSE;
+	u8 got_p2p_ie = false;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 	//struct sta_priv *pstapriv = &padapter->stapriv;
 
@@ -3335,7 +3335,7 @@ static int rtw_add_beacon(_adapter *adap
 	DBG_8192C("%s beacon_head_len=%zu, beacon_tail_len=%zu\n", __FUNCTION__, head_len, tail_len);
 
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
 	if(head_len<24)
@@ -3367,7 +3367,7 @@ static int rtw_add_beacon(_adapter *adap
 	if(rtw_get_p2p_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &p2p_ielen))
 	{
 		DBG_8192C("got p2p_ie, len=%d\n", p2p_ielen);
-		got_p2p_ie = _TRUE;
+		got_p2p_ie = true;
 	}
 #endif
 
@@ -3379,7 +3379,7 @@ static int rtw_add_beacon(_adapter *adap
 	{
 #ifdef  CONFIG_P2P
 		//check p2p if enable
-		if(got_p2p_ie == _TRUE)
+		if(got_p2p_ie == true)
 		{
 			struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
 			struct wifidirect_info *pwdinfo= &(adapter->wdinfo);
@@ -3388,7 +3388,7 @@ static int rtw_add_beacon(_adapter *adap
 			{
 				DBG_8192C("Enable P2P function for the first time\n");
 				rtw_p2p_enable(adapter, P2P_ROLE_GO);
-				wdev_to_priv(adapter->rtw_wdev)->p2p_enabled = _TRUE;
+				wdev_to_priv(adapter->rtw_wdev)->p2p_enabled = true;
 			}
 			else
 			{
@@ -3443,7 +3443,7 @@ static int	cfg80211_rtw_set_beacon(struc
 
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
-	pmlmeext->bstart_bss = _TRUE;
+	pmlmeext->bstart_bss = true;
 
 	cfg80211_rtw_add_beacon(wiphy, ndev, info);
 
@@ -3537,7 +3537,7 @@ static int	cfg80211_rtw_del_station(stru
 
 	DBG_871X("+"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
-	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)
 	{
 		DBG_8192C("%s, fw_state != FW_LINKED|WIFI_AP_STATE\n", __func__);
 		return -EINVAL;
@@ -3572,7 +3572,7 @@ static int	cfg80211_rtw_del_station(stru
 	plist = get_next(phead);
 
 	//check asoc_queue
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 
@@ -3580,9 +3580,9 @@ static int	cfg80211_rtw_del_station(stru
 
 		if(_rtw_memcmp(mac, psta->hwaddr, ETH_ALEN))
 		{
-			if(psta->dot8021xalg == 1 && psta->bpairwise_key_installed == _FALSE)
+			if(psta->dot8021xalg == 1 && psta->bpairwise_key_installed == false)
 			{
-				DBG_8192C("%s, sta's dot8021xalg = 1 and key_installed = _FALSE\n", __func__);
+				DBG_8192C("%s, sta's dot8021xalg = 1 and key_installed = false\n", __func__);
 			}
 			else
 			{
@@ -3592,7 +3592,7 @@ static int	cfg80211_rtw_del_station(stru
 				pstapriv->asoc_list_cnt--;
 
 				//_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-				updated = ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_DEAUTH_LEAVING);
+				updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
 				//_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
 				psta = NULL;
@@ -3697,7 +3697,7 @@ void rtw_cfg80211_rx_action_p2p(_adapter
 
 	DBG_8192C("RTW_Rx:cur_ch=%d\n", channel);
 	#ifdef CONFIG_P2P
-	type = rtw_p2p_check_frames(padapter, pmgmt_frame, frame_len, _FALSE);
+	type = rtw_p2p_check_frames(padapter, pmgmt_frame, frame_len, false);
 	if (type >= 0)
 		goto indicate;
 	#endif
@@ -3729,7 +3729,7 @@ void rtw_cfg80211_rx_p2p_action_public(_
 
 	DBG_8192C("RTW_Rx:cur_ch=%d\n", channel);
 	#ifdef CONFIG_P2P
-	type = rtw_p2p_check_frames(padapter, pmgmt_frame, frame_len, _FALSE);
+	type = rtw_p2p_check_frames(padapter, pmgmt_frame, frame_len, false);
 	if (type >= 0) {
 		switch (type) {
 		case P2P_GO_NEGO_CONF:
@@ -4031,11 +4031,11 @@ static s32 cfg80211_rtw_remain_on_channe
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 	u8 remain_ch = (u8) ieee80211_frequency_to_channel(channel->center_freq);
-	u8 ready_on_channel = _FALSE;
+	u8 ready_on_channel = false;
 
 	DBG_871X(FUNC_ADPT_FMT" ch:%u duration:%d\n", FUNC_ADPT_ARG(padapter), remain_ch, duration);
 
-	if(pcfg80211_wdinfo->is_ro_ch == _TRUE)
+	if(pcfg80211_wdinfo->is_ro_ch == true)
 	{
 		DBG_8192C("%s, cancel ro ch timer\n", __func__);
 
@@ -4048,7 +4048,7 @@ static s32 cfg80211_rtw_remain_on_channe
 		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
 	}
 
-	pcfg80211_wdinfo->is_ro_ch = _TRUE;
+	pcfg80211_wdinfo->is_ro_ch = true;
 
 	if(_FAIL == rtw_pwr_wakeup(padapter)) {
 		err = -EFAULT;
@@ -4071,7 +4071,7 @@ static s32 cfg80211_rtw_remain_on_channe
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
-		wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = _TRUE;
+		wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = true;
 	}
 	else
 	{
@@ -4121,14 +4121,14 @@ static s32 cfg80211_rtw_remain_on_channe
 				}
 			}
 
-			ready_on_channel = _TRUE;
+			ready_on_channel = true;
 			//pmlmeext->cur_channel = remain_ch;
 			//set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 		}else
 #endif //CONFIG_CONCURRENT_MODE
 		if(remain_ch != pmlmeext->cur_channel )
 		{
-			ready_on_channel = _TRUE;
+			ready_on_channel = true;
 			//pmlmeext->cur_channel = remain_ch;
 			//set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 		}
@@ -4146,7 +4146,7 @@ static s32 cfg80211_rtw_remain_on_channe
 		ATOMIC_SET(&pwdev_priv->ro_ch_to, 0);
 #endif
 
-		if(ready_on_channel == _TRUE)
+		if(ready_on_channel == true)
 		{
 			if ( !check_fwstate(&padapter->mlmepriv, _FW_LINKED ) )
 				pmlmeext->cur_channel = remain_ch;
@@ -4172,7 +4172,7 @@ static s32 cfg80211_rtw_remain_on_channe
 
 exit:
 	if (err)
-		pcfg80211_wdinfo->is_ro_ch = _FALSE;
+		pcfg80211_wdinfo->is_ro_ch = false;
 
 	return err;
 }
@@ -4194,7 +4194,7 @@ static s32 cfg80211_rtw_cancel_remain_on
 
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
 
-	if (pcfg80211_wdinfo->is_ro_ch == _TRUE) {
+	if (pcfg80211_wdinfo->is_ro_ch == true) {
 		DBG_8192C("%s, cancel ro ch timer\n", __func__);
 		_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
 		#ifdef CONFIG_CONCURRENT_MODE
@@ -4207,7 +4207,7 @@ static s32 cfg80211_rtw_cancel_remain_on
 #ifdef CONFIG_DEBUG_CFG80211
 	 DBG_8192C("%s, role=%d, p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo));
 #endif
-	pcfg80211_wdinfo->is_ro_ch = _FALSE;
+	pcfg80211_wdinfo->is_ro_ch = false;
 
 	return err;
 }
@@ -4220,7 +4220,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 	struct pkt_attrib	*pattrib;
 	unsigned char	*pframe;
 	int ret = _FAIL;
-	bool ack = _TRUE;
+	bool ack = true;
 	struct rtw_ieee80211_hdr *pwlanhdr;
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
@@ -4242,10 +4242,10 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 		rtw_scan_abort(padapter->pbuddy_adapter);
 	#endif /* CONFIG_CONCURRENT_MODE */
 
-	if (padapter->cfg80211_wdinfo.is_ro_ch == _TRUE) {
+	if (padapter->cfg80211_wdinfo.is_ro_ch == true) {
 		//DBG_8192C("%s, cancel ro ch timer\n", __func__);
 		//_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
-		//padapter->cfg80211_wdinfo.is_ro_ch = _FALSE;
+		//padapter->cfg80211_wdinfo.is_ro_ch = false;
 		#ifdef CONFIG_CONCURRENT_MODE
 		DBG_8192C("%s, extend ro ch time\n", __func__);
 		_set_timer( &padapter->cfg80211_wdinfo.remain_on_ch_timer, pwdinfo->ext_listen_period);
@@ -4300,7 +4300,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
-	pattrib->retry_ctrl = _FALSE;
+	pattrib->retry_ctrl = false;
 
 	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
 
@@ -4321,7 +4321,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 
 		pwfd_info = padapter->wdinfo.wfd_info;
 
-		if ( _TRUE == pwfd_info->wfd_enable )
+		if ( true == pwfd_info->wfd_enable )
 		{
 			rtw_append_wfd_ie( padapter, pframe, &pattrib->pktlen );
 		}
@@ -4332,7 +4332,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 
 	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS)
 	{
-		ack = _FALSE;
+		ack = false;
 		ret = _FAIL;
 
 		#ifdef CONFIG_DEBUG_CFG80211
@@ -4391,7 +4391,7 @@ static int cfg80211_rtw_mgmt_tx(struct w
 	int tx_ret;
 	u32 dump_limit = RTW_MAX_MGMT_TX_CNT;
 	u32 dump_cnt = 0;
-	bool ack = _TRUE;
+	bool ack = true;
 	u8 tx_ch = (u8)ieee80211_frequency_to_channel(chan->center_freq);
 	u8 category, action;
 	int type = (-1);
@@ -4426,7 +4426,7 @@ static int cfg80211_rtw_mgmt_tx(struct w
 	cfg80211_action_tx_status(ndev, *cookie, buf, len, ack, GFP_KERNEL);
 #endif
 
-	if (rtw_action_frame_parse(buf, len, &category, &action) == _FALSE) {
+	if (rtw_action_frame_parse(buf, len, &category, &action) == false) {
 		DBG_8192C(FUNC_ADPT_FMT" frame_control:0x%x\n", FUNC_ADPT_ARG(padapter),
 			le16_to_cpu(((struct rtw_ieee80211_hdr_3addr *)buf)->frame_ctl));
 		goto exit;
@@ -4434,7 +4434,7 @@ static int cfg80211_rtw_mgmt_tx(struct w
 
 	DBG_8192C("RTW_Tx:tx_ch=%d, da="MAC_FMT"\n", tx_ch, MAC_ARG(GetAddr1Ptr(buf)));
 	#ifdef CONFIG_P2P
-	if((type = rtw_p2p_check_frames(padapter, buf, len, _TRUE)) >= 0)
+	if((type = rtw_p2p_check_frames(padapter, buf, len, true)) >= 0)
 		goto dump;
 	#endif
 	if (category == RTW_WLAN_CATEGORY_PUBLIC)
@@ -4537,7 +4537,7 @@ static int rtw_cfg80211_set_beacon_wpsp2
 			_rtw_memcpy(pmlmepriv->wps_beacon_ie, wps_ie, wps_ielen);
 			pmlmepriv->wps_beacon_ie_len = wps_ielen;
 
-			update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, _TRUE);
+			update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, true);
 
 		}
 
@@ -4600,7 +4600,7 @@ static int rtw_cfg80211_set_beacon_wpsp2
 		}
 		#endif //CONFIG_WFD
 
-		pmlmeext->bstart_bss = _TRUE;
+		pmlmeext->bstart_bss = true;
 
 	}
 
@@ -4674,7 +4674,7 @@ static int rtw_cfg80211_set_probe_resp_w
 		#ifdef CONFIG_P2P
 		if((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
 		{
-			u8 is_GO = _FALSE;
+			u8 is_GO = false;
 			u32 attr_contentlen = 0;
 			u16 cap_attr=0;
 
@@ -4690,14 +4690,14 @@ static int rtw_cfg80211_set_probe_resp_w
 				cap_attr = le16_to_cpu(cap_attr);
 				grp_cap = (u8)((cap_attr >> 8)&0xff);
 
-				is_GO = (grp_cap&BIT(0)) ? _TRUE:_FALSE;
+				is_GO = (grp_cap&BIT(0)) ? true:false;
 
 				if(is_GO)
 					DBG_8192C("Got P2P Capability Attr, grp_cap=0x%x, is_GO\n", grp_cap);
 			}
 
 
-			if(is_GO == _FALSE)
+			if(is_GO == false)
 			{
 				if(pmlmepriv->p2p_probe_resp_ie)
 				{
@@ -4908,7 +4908,7 @@ static void rtw_cfg80211_init_ht_capab(s
 #define MAX_BIT_RATE_40MHZ_MCS15	300	/* Mbps */
 #define MAX_BIT_RATE_40MHZ_MCS7		150	/* Mbps */
 
-	ht_cap->ht_supported = _TRUE;
+	ht_cap->ht_supported = true;
 
 	ht_cap->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
 					IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20 |
@@ -5117,16 +5117,16 @@ int rtw_wdev_alloc(_adapter *padapter, s
 	pwdev_priv->scan_request = NULL;
 	_rtw_spinlock_init(&pwdev_priv->scan_req_lock);
 
-	pwdev_priv->p2p_enabled = _FALSE;
-	pwdev_priv->provdisc_req_issued = _FALSE;
+	pwdev_priv->p2p_enabled = false;
+	pwdev_priv->provdisc_req_issued = false;
 	rtw_wdev_invit_info_init(&pwdev_priv->invit_info);
 
-	pwdev_priv->bandroid_scan = _FALSE;
+	pwdev_priv->bandroid_scan = false;
 
 	if(padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
-		pwdev_priv->power_mgmt = _TRUE;
+		pwdev_priv->power_mgmt = true;
 	else
-		pwdev_priv->power_mgmt = _FALSE;
+		pwdev_priv->power_mgmt = false;
 
 #ifdef CONFIG_CONCURRENT_MODE
 	ATOMIC_SET(&pwdev_priv->switch_ch_to, 1);
@@ -5175,7 +5175,7 @@ void rtw_wdev_unregister(struct wireless
 
 	pwdev_priv = wdev_to_priv(wdev);
 
-	rtw_cfg80211_indicate_scan_done(pwdev_priv, _TRUE);
+	rtw_cfg80211_indicate_scan_done(pwdev_priv, true);
 
 	if (pwdev_priv->pmon_ndev) {
 		DBG_8192C("%s, unregister monitor interface\n", __func__);
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -246,11 +246,11 @@ uint	rtw_is_cckrates_included(u8 *rate)
 		{
 			if  ( (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
 			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22))
-			return _TRUE;
+			return true;
 			i++;
 		}
 
-		return _FALSE;
+		return false;
 }
 
 uint	rtw_is_cckratesonly_included(u8 *rate)
@@ -261,11 +261,11 @@ uint	rtw_is_cckratesonly_included(u8 *ra
 	{
 			if  ( (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
 				(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22))
-			return _FALSE;
+			return false;
 			i++;
 	}
 
-	return _TRUE;
+	return true;
 }
 */
 
@@ -278,7 +278,7 @@ static char *translate_scan(_adapter *pa
 	u32 ht_ielen = 0;
 	char custom[MAX_CUSTOM_LEN];
 	char *p;
-	u16 max_rate=0, rate, ht_cap=_FALSE;
+	u16 max_rate=0, rate, ht_cap=false;
 	u32 i = 0;
 	char	*current_val;
 	long rssi;
@@ -301,7 +301,7 @@ static char *translate_scan(_adapter *pa
 	{
 		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
-			u32	blnGotP2PIE = _FALSE;
+			u32	blnGotP2PIE = false;
 
 			//	User is doing the P2P device discovery
 			//	The prefix of SSID should be "DIRECT-" and the IE should contains the P2P IE.
@@ -315,11 +315,11 @@ static char *translate_scan(_adapter *pa
 				//	Verifying the P2P IE
 				if (rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen))
 				{
-					blnGotP2PIE = _TRUE;
+					blnGotP2PIE = true;
 				}
 			}
 
-			if (blnGotP2PIE == _FALSE)
+			if (blnGotP2PIE == false)
 			{
 				return start;
 			}
@@ -330,7 +330,7 @@ static char *translate_scan(_adapter *pa
 #ifdef CONFIG_WFD
 	if (SCAN_RESULT_WFD_TYPE == pwdinfo->wfd_info->scan_result_type)
 	{
-		u32	blnGotWFD = _FALSE;
+		u32	blnGotWFD = false;
 		u8	wfd_ie[ 128 ] = { 0x00 };
 		uint	wfd_ielen = 0;
 
@@ -347,7 +347,7 @@ static char *translate_scan(_adapter *pa
 					if ((wfd_devinfo[ 1 ] & 0x03) == WFD_DEVINFO_SOURCE)
 					{
 						//	If this device is Miracast PSink device, the scan reuslt should just provide the Miracast source.
-						blnGotWFD = _TRUE;
+						blnGotWFD = true;
 					}
 				}
 				else if (pwdinfo->wfd_info->wfd_device_type == WFD_DEVINFO_SOURCE)
@@ -357,13 +357,13 @@ static char *translate_scan(_adapter *pa
 					{
 						//	If this device is Miracast source device, the scan reuslt should just provide the Miracast PSink.
 						//	Todo: How about the SSink?!
-						blnGotWFD = _TRUE;
+						blnGotWFD = true;
 					}
 				}
 			}
 		}
 
-		if (blnGotWFD == _FALSE)
+		if (blnGotWFD == false)
 		{
 			return start;
 		}
@@ -390,7 +390,7 @@ static char *translate_scan(_adapter *pa
 	if (p && ht_ielen>0)
 	{
 		struct rtw_ieee80211_ht_cap *pht_capie;
-		ht_cap = _TRUE;
+		ht_cap = true;
 		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
 		_rtw_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
 		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
@@ -399,16 +399,16 @@ static char *translate_scan(_adapter *pa
 
 	/* Add the protocol name */
 	iwe.cmd = SIOCGIWNAME;
-	if ((rtw_is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)
+	if ((rtw_is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == true)
 	{
-		if (ht_cap == _TRUE)
+		if (ht_cap == true)
 			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");
 		else
 		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
 	}
-	else if ((rtw_is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)
+	else if ((rtw_is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == true)
 	{
-		if (ht_cap == _TRUE)
+		if (ht_cap == true)
 			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");
 		else
 		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
@@ -417,14 +417,14 @@ static char *translate_scan(_adapter *pa
 	{
 		if (pnetwork->network.Configuration.DSConfig > 14)
 		{
-			if (ht_cap == _TRUE)
+			if (ht_cap == true)
 				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11an");
 			else
 				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11a");
 		}
 		else
 		{
-			if (ht_cap == _TRUE)
+			if (ht_cap == true)
 				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");
 			else
 				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");
@@ -482,7 +482,7 @@ static char *translate_scan(_adapter *pa
 		i++;
 	}
 
-	if (ht_cap == _TRUE)
+	if (ht_cap == true)
 	{
 		if (mcs_rate&0x8000)//MCS15
 		{
@@ -591,7 +591,7 @@ static char *translate_scan(_adapter *pa
 	#endif
 	;
 
-	if (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE &&
+	if (check_fwstate(pmlmepriv, _FW_LINKED)== true &&
 		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network)) {
 		ss = padapter->recvpriv.signal_strength;
 		sq = padapter->recvpriv.signal_qual;
@@ -776,7 +776,7 @@ _func_enter_;
 		struct sta_info * psta,*pbcmc_sta;
 		struct sta_priv * pstapriv = &padapter->stapriv;
 
-		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == _TRUE) //sta mode
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true) //sta mode
 		{
 			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
 			if (psta == NULL) {
@@ -786,7 +786,7 @@ _func_enter_;
 			{
 				//Jeff: don't disable ieee8021x_blocked while clearing key
 				if (strcmp(param->u.crypt.alg, "none") != 0)
-					psta->ieee8021x_blocked = _FALSE;
+					psta->ieee8021x_blocked = false;
 
 				if ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
 						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
@@ -804,7 +804,7 @@ _func_enter_;
 						_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 						_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
-						padapter->securitypriv.busetkipkey=_FALSE;
+						padapter->securitypriv.busetkipkey=false;
 						//_set_timer(&padapter->securitypriv.tkip_timer, 50);
 					}
 
@@ -812,14 +812,14 @@ _func_enter_;
 					//DEBUG_ERR(("\n ~~~~stastakey:unicastkey\n"));
 					DBG_871X("\n ~~~~stastakey:unicastkey\n");
 
-					rtw_setstakey_cmd(padapter, (unsigned char *)psta, _TRUE);
+					rtw_setstakey_cmd(padapter, (unsigned char *)psta, true);
 				}
 				else//group key
 				{
 					_rtw_memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 					_rtw_memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[16]),8);
 					_rtw_memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[24]),8);
-                                        padapter->securitypriv.binstallGrpkey = _TRUE;
+                                        padapter->securitypriv.binstallGrpkey = true;
 					//DEBUG_ERR(("\n param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
 					//DEBUG_ERR(("\n ~~~~stastakey:groupkey\n"));
 					DBG_871X("\n ~~~~stastakey:groupkey\n");
@@ -846,7 +846,7 @@ _func_enter_;
 			{
 				//Jeff: don't disable ieee8021x_blocked while clearing key
 				if (strcmp(param->u.crypt.alg, "none") != 0)
-					pbcmc_sta->ieee8021x_blocked = _FALSE;
+					pbcmc_sta->ieee8021x_blocked = false;
 
 				if ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
 						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
@@ -995,7 +995,7 @@ static int rtw_set_wpa_ie(_adapter *pada
 			{
 				eid = buf[cnt];
 
-				if ((eid==_VENDOR_SPECIFIC_IE_)&&(_rtw_memcmp(&buf[cnt+2], wps_oui, 4)==_TRUE))
+				if ((eid==_VENDOR_SPECIFIC_IE_)&&(_rtw_memcmp(&buf[cnt+2], wps_oui, 4)==true))
 				{
 					DBG_871X("SET WPS_IE\n");
 
@@ -1026,7 +1026,7 @@ static int rtw_set_wpa_ie(_adapter *pada
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
 		//WPS open need to enable multicast
-		//|| check_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS) == _TRUE)
+		//|| check_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS) == true)
 		rtw_hal_set_hwreg(padapter, HW_VAR_OFF_RCR_AM, null_addr);
 
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
@@ -1048,7 +1048,7 @@ static int rtw_wx_get_name(struct net_de
 	u16 cap;
 	u32 ht_ielen = 0;
 	char *p;
-	u8 ht_cap=_FALSE;
+	u8 ht_cap=false;
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
 	NDIS_802_11_RATES_EX* prates = NULL;
@@ -1057,27 +1057,27 @@ static int rtw_wx_get_name(struct net_de
 
 	_func_enter_;
 
-	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true)
 	{
 		//parsing HT_CAP_IE
 		p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
 		if (p && ht_ielen>0)
 		{
-			ht_cap = _TRUE;
+			ht_cap = true;
 		}
 
 		prates = &pcur_bss->SupportedRates;
 
-		if (rtw_is_cckratesonly_included((u8*)prates) == _TRUE)
+		if (rtw_is_cckratesonly_included((u8*)prates) == true)
 		{
-			if (ht_cap == _TRUE)
+			if (ht_cap == true)
 				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bn");
 			else
 				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11b");
 		}
-		else if ((rtw_is_cckrates_included((u8*)prates)) == _TRUE)
+		else if ((rtw_is_cckrates_included((u8*)prates)) == true)
 		{
-			if (ht_cap == _TRUE)
+			if (ht_cap == true)
 				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bgn");
 			else
 				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bg");
@@ -1086,14 +1086,14 @@ static int rtw_wx_get_name(struct net_de
 		{
 			if (pcur_bss->Configuration.DSConfig > 14)
 			{
-				if (ht_cap == _TRUE)
+				if (ht_cap == true)
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11an");
 				else
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11a");
 			}
 			else
 			{
-				if (ht_cap == _TRUE)
+				if (ht_cap == true)
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11gn");
 				else
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
@@ -1133,7 +1133,7 @@ static int rtw_wx_get_freq(struct net_de
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
 
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		//wrqu->freq.m = ieee80211_wlan_frequencies[pcur_bss->Configuration.DSConfig-1] * 100000;
 		wrqu->freq.m = rtw_ch2freq(pcur_bss->Configuration.DSConfig) * 100000;
@@ -1166,7 +1166,7 @@ static int rtw_wx_set_mode(struct net_de
 		goto exit;
 	}
 
-	if (padapter->hw_init_completed==_FALSE){
+	if (padapter->hw_init_completed==false){
 		ret = -EPERM;
 		goto exit;
 	}
@@ -1209,7 +1209,7 @@ static int rtw_wx_set_mode(struct net_de
 */
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 	_enter_critical_bh(&queue->lock, &irqL);
-	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==_FALSE){
+	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==false){
 
 		ret = -EPERM;
 		_exit_critical_bh(&queue->lock, &irqL);
@@ -1239,17 +1239,17 @@ static int rtw_wx_get_mode(struct net_de
 
 	_func_enter_;
 
-	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 	{
 		wrqu->mode = IW_MODE_INFRA;
 	}
-	else if  ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
-		       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
+	else if  ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+		       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
 
 	{
 		wrqu->mode = IW_MODE_ADHOC;
 	}
-	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		wrqu->mode = IW_MODE_MASTER;
 	}
@@ -1270,8 +1270,8 @@ static int rtw_wx_set_pmkid(struct net_d
 			     union iwreq_data *wrqu, char *extra)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	u8          j,blInserted = _FALSE;
-	int         intReturn = _FALSE;
+	u8          j,blInserted = false;
+	int         intReturn = false;
 	struct mlme_priv  *pmlmepriv = &padapter->mlmepriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
         struct iw_pmksa*  pPMK = (struct iw_pmksa*) extra;
@@ -1295,28 +1295,28 @@ static int rtw_wx_set_pmkid(struct net_d
         if (pPMK->cmd == IW_PMKSA_ADD)
         {
                 DBG_871X("[rtw_wx_set_pmkid] IW_PMKSA_ADD!\n");
-                if (_rtw_memcmp(strIssueBssid, strZeroMacAddress, ETH_ALEN) == _TRUE)
+                if (_rtw_memcmp(strIssueBssid, strZeroMacAddress, ETH_ALEN) == true)
                 {
                     return(intReturn);
                 }
                 else
                 {
-                    intReturn = _TRUE;
+                    intReturn = true;
                 }
-		blInserted = _FALSE;
+		blInserted = false;
 
 		//overwrite PMKID
 		for(j=0 ; j<NUM_PMKID_CACHE; j++)
 		{
-			if (_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE)
+			if (_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==true)
 			{ // BSSID is matched, the same AP => rewrite with new PMKID.
 
                                 DBG_871X("[rtw_wx_set_pmkid] BSSID exists in the PMKList.\n");
 
 				_rtw_memcpy(psecuritypriv->PMKIDList[j].PMKID, pPMK->pmkid, IW_PMKID_LEN);
-                                psecuritypriv->PMKIDList[ j ].bUsed = _TRUE;
+                                psecuritypriv->PMKIDList[ j ].bUsed = true;
 				psecuritypriv->PMKIDIndex = j+1;
-				blInserted = _TRUE;
+				blInserted = true;
 				break;
 			}
 	        }
@@ -1330,7 +1330,7 @@ static int rtw_wx_set_pmkid(struct net_d
 	            _rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);
 		    _rtw_memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);
 
-                    psecuritypriv->PMKIDList[ psecuritypriv->PMKIDIndex ].bUsed = _TRUE;
+                    psecuritypriv->PMKIDList[ psecuritypriv->PMKIDIndex ].bUsed = true;
 		    psecuritypriv->PMKIDIndex++ ;
 		    if (psecuritypriv->PMKIDIndex==16)
                     {
@@ -1341,13 +1341,13 @@ static int rtw_wx_set_pmkid(struct net_d
         else if (pPMK->cmd == IW_PMKSA_REMOVE)
         {
                 DBG_871X("[rtw_wx_set_pmkid] IW_PMKSA_REMOVE!\n");
-                intReturn = _TRUE;
+                intReturn = true;
 		for(j=0 ; j<NUM_PMKID_CACHE; j++)
 		{
-			if (_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE)
+			if (_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==true)
 			{ // BSSID is matched, the same AP => Remove this PMKID information and reset it.
                                 _rtw_memset(psecuritypriv->PMKIDList[ j ].Bssid, 0x00, ETH_ALEN);
-                                psecuritypriv->PMKIDList[ j ].bUsed = _FALSE;
+                                psecuritypriv->PMKIDList[ j ].bUsed = false;
 				break;
 			}
 	        }
@@ -1357,7 +1357,7 @@ static int rtw_wx_set_pmkid(struct net_d
             DBG_871X("[rtw_wx_set_pmkid] IW_PMKSA_FLUSH!\n");
             _rtw_memset(&psecuritypriv->PMKIDList[ 0 ], 0x00, sizeof(RT_PMKID_LIST) * NUM_PMKID_CACHE);
             psecuritypriv->PMKIDIndex = 0;
-            intReturn = _TRUE;
+            intReturn = true;
         }
     return(intReturn);
 }
@@ -1532,7 +1532,7 @@ static int rtw_wx_set_wap(struct net_dev
 */
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
 	{
 		printk("set bssid, but buddy_intf is under scanning or linking\n");
 
@@ -1543,7 +1543,7 @@ static int rtw_wx_set_wap(struct net_dev
 #endif
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if (dc_check_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)== _TRUE)
+	if (dc_check_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)== true)
 	{
 		printk("set bssid, but buddy_intf is under scanning or linking\n");
 		ret = -EINVAL;
@@ -1575,7 +1575,7 @@ static int rtw_wx_set_wap(struct net_dev
        pmlmepriv->pscanned = get_next(phead);
 
 	while (1) {
-		if ((rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) == _TRUE)
+		if ((rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) == true)
 			break;
 
 		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
@@ -1586,7 +1586,7 @@ static int rtw_wx_set_wap(struct net_dev
 
 		src_bssid = temp->sa_data;
 
-		if ((_rtw_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == _TRUE) {
+		if ((_rtw_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == true) {
 			if (!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode)) {
 				ret = -1;
 				_exit_critical_bh(&queue->lock, &irqL);
@@ -1602,7 +1602,7 @@ static int rtw_wx_set_wap(struct net_dev
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 	rtw_set_802_11_authentication_mode(padapter, authmode);
 	//set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
-	if (rtw_set_802_11_bssid(padapter, temp->sa_data) == _FALSE) {
+	if (rtw_set_802_11_bssid(padapter, temp->sa_data) == false) {
 		ret = -1;
 		goto exit;
 	}
@@ -1631,9 +1631,9 @@ static int rtw_wx_get_wap(struct net_dev
 
 	_func_enter_;
 
-	if  (((check_fwstate(pmlmepriv, _FW_LINKED)) == _TRUE) ||
-			((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == _TRUE) ||
-			((check_fwstate(pmlmepriv, WIFI_AP_STATE)) == _TRUE))
+	if  (((check_fwstate(pmlmepriv, _FW_LINKED)) == true) ||
+			((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) ||
+			((check_fwstate(pmlmepriv, WIFI_AP_STATE)) == true))
 	{
 
 		_rtw_memcpy(wrqu->ap_addr.sa_data, pcur_bss->MacAddress, ETH_ALEN);
@@ -1693,7 +1693,7 @@ static int rtw_wx_set_mlme(struct net_de
 static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *extra)
 {
-	u8 _status = _FALSE;
+	u8 _status = false;
 	int ret = 0;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
@@ -1720,7 +1720,7 @@ _func_enter_;
 */
 
 #ifdef CONFIG_MP_INCLUDED
-	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
 	{
 		ret = -1;
 		goto exit;
@@ -1744,7 +1744,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	if (padapter->hw_init_completed==_FALSE){
+	if (padapter->hw_init_completed==false){
 		ret = -1;
 		goto exit;
 	}
@@ -1752,13 +1752,13 @@ _func_enter_;
 	// When Busy Traffic, driver do not site survey. So driver return success.
 	// wpa_supplicant will not issue SIOCSIWSCAN cmd again after scan timeout.
 	// modify by thomas 2011-02-22.
-	if (pmlmepriv->LinkDetectInfo.bBusyTraffic == _TRUE)
+	if (pmlmepriv->LinkDetectInfo.bBusyTraffic == true)
 	{
 		indicate_wx_scan_complete_event(padapter);
 		goto exit;
 	}
 
-	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
 	{
 		indicate_wx_scan_complete_event(padapter);
 		goto exit;
@@ -1766,12 +1766,12 @@ _func_enter_;
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter,
-		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE)
+		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == true)
 	{
 		if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY))
 		{
 			printk("scanning_via_buddy_intf\n");
-			pmlmepriv->scanning_via_buddy_intf = _TRUE;
+			pmlmepriv->scanning_via_buddy_intf = true;
 		}
 
 		indicate_wx_scan_complete_event(padapter);
@@ -1781,7 +1781,7 @@ _func_enter_;
 #endif
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if (dc_check_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)== _TRUE)
+	if (dc_check_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)== true)
 	{
 		indicate_wx_scan_complete_event(padapter);
 		goto exit;
@@ -1811,7 +1811,7 @@ _func_enter_;
 		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
 		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_FULL);
-		rtw_free_network_queue(padapter, _TRUE);
+		rtw_free_network_queue(padapter, true);
 	}
 #endif //CONFIG_P2P
 
@@ -1848,7 +1848,7 @@ _func_enter_;
 #endif
 
 	if (	wrqu->data.length >= WEXT_CSCAN_HEADER_SIZE
-		&& _rtw_memcmp(extra, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == _TRUE
+		&& _rtw_memcmp(extra, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == true
 	)
 	{
 		int len = wrqu->data.length -WEXT_CSCAN_HEADER_SIZE;
@@ -1915,7 +1915,7 @@ _func_enter_;
 		_status = rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);
 	}
 
-	if (_status == _FALSE)
+	if (_status == false)
 		ret = -1;
 
 exit:
@@ -1996,9 +1996,9 @@ static int rtw_wx_get_scan(struct net_de
 
 /*
 #ifdef CONFIG_CONCURRENT_MODE
-	if (pmlmepriv->scanning_via_buddy_intf == _TRUE)
+	if (pmlmepriv->scanning_via_buddy_intf == true)
 	{
-		pmlmepriv->scanning_via_buddy_intf = _FALSE;//reset
+		pmlmepriv->scanning_via_buddy_intf = false;//reset
 
 		// change pointers to buddy interface
 		padapter = pbuddy_adapter;
@@ -2016,7 +2016,7 @@ static int rtw_wx_get_scan(struct net_de
 	;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	while(dc_check_fwstate(padapter, wait_status)== _TRUE)
+	while(dc_check_fwstate(padapter, wait_status)== true)
 	{
 		rtw_msleep_os(30);
 		cnt++;
@@ -2025,7 +2025,7 @@ static int rtw_wx_get_scan(struct net_de
 	}
 #endif // CONFIG_DUALMAC_CONCURRENT
 
-	while(check_fwstate(pmlmepriv, wait_status) == _TRUE)
+	while(check_fwstate(pmlmepriv, wait_status) == true)
 	{
 		rtw_msleep_os(30);
 		cnt++;
@@ -2040,7 +2040,7 @@ static int rtw_wx_get_scan(struct net_de
 
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+		if (rtw_end_of_queue_search(phead,plist)== true)
 			break;
 
 		if ((stop - ev) < SCAN_ITEM_SIZE) {
@@ -2053,7 +2053,7 @@ static int rtw_wx_get_scan(struct net_de
 		//report network only if the current channel set contains the channel to which this network belongs
 		if (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
 			#ifdef CONFIG_VALIDATE_SSID
-			&& _TRUE == rtw_validate_ssid(&(pnetwork->network.Ssid))
+			&& true == rtw_validate_ssid(&(pnetwork->network.Ssid))
 			#endif
 		)
 		{
@@ -2096,7 +2096,7 @@ static int rtw_wx_set_essid(struct net_d
 	_queue *queue = &pmlmepriv->scanned_queue;
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	_list *phead;
-	s8 status = _TRUE;
+	s8 status = true;
 	struct wlan_network *pnetwork = NULL;
 	NDIS_802_11_AUTHENTICATION_MODE authmode;
 	NDIS_802_11_SSID ndis_ssid;
@@ -2121,7 +2121,7 @@ static int rtw_wx_set_essid(struct net_d
 */
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
 	{
 		printk("set ssid, but buddy_intf is under scanning or linking\n");
 
@@ -2132,7 +2132,7 @@ static int rtw_wx_set_essid(struct net_d
 #endif
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	if (dc_check_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)== _TRUE)
+	if (dc_check_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)== true)
 	{
 		printk("set bssid, but buddy_intf is under scanning or linking\n");
 		ret = -EINVAL;
@@ -2201,7 +2201,7 @@ static int rtw_wx_set_essid(struct net_d
 
 		while (1)
 		{
-			if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == _TRUE)
+			if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == true)
 			{
 			        RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_warning_,
 					 ("rtw_wx_set_essid: scan_q is empty, set ssid to check if scanning again!\n"));
@@ -2219,19 +2219,19 @@ static int rtw_wx_set_essid(struct net_d
 				 ("rtw_wx_set_essid: dst_ssid=%s\n",
 				  pnetwork->network.Ssid.Ssid));
 
-			if ((_rtw_memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength) == _TRUE) &&
+			if ((_rtw_memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength) == true) &&
 				(pnetwork->network.Ssid.SsidLength==ndis_ssid.SsidLength))
 			{
 				RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
 					 ("rtw_wx_set_essid: find match, set infra mode\n"));
 
-				if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+				if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)
 				{
 					if (pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
 						continue;
 				}
 
-				if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == _FALSE)
+				if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == false)
 				{
 					ret = -1;
 					_exit_critical_bh(&queue->lock, &irqL);
@@ -2248,7 +2248,7 @@ static int rtw_wx_set_essid(struct net_d
 			 ("set ssid: set_802_11_auth. mode=%d\n", authmode));
 		rtw_set_802_11_authentication_mode(padapter, authmode);
 		//set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
-		if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == _FALSE) {
+		if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == false) {
 			ret = -1;
 			goto exit;
 		}
@@ -2280,8 +2280,8 @@ static int rtw_wx_get_essid(struct net_d
 
 	_func_enter_;
 
-	if ((check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) ||
-	      (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE))
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
+	      (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))
 	{
 		len = pcur_bss->Ssid.SsidLength;
 
@@ -2642,7 +2642,7 @@ static int rtw_wx_set_enc(struct net_dev
 
 	_rtw_memcpy(wep.KeyMaterial, keybuf, wep.KeyLength);
 
-	if (rtw_set_802_11_add_wep(padapter, &wep) == _FALSE) {
+	if (rtw_set_802_11_add_wep(padapter, &wep) == false) {
 		if (rf_on == pwrpriv->rf_pwrstate)
 			ret = -EOPNOTSUPP;
 		goto exit;
@@ -2667,9 +2667,9 @@ static int rtw_wx_get_enc(struct net_dev
 
 	_func_enter_;
 
-	if (check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_LINKED) != true)
 	{
-		 if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != _TRUE)
+		 if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != true)
 		 {
 		erq->length = 0;
 		erq->flags |= IW_ENCODE_DISABLED;
@@ -2808,11 +2808,11 @@ static int rtw_wx_set_auth(struct net_de
         {
 	    if (param->value)
             {  // wpa_supplicant is enabling the tkip countermeasure.
-               padapter->securitypriv.btkip_countermeasure = _TRUE;
+               padapter->securitypriv.btkip_countermeasure = true;
             }
             else
             {  // wpa_supplicant is disabling the tkip countermeasure.
-               padapter->securitypriv.btkip_countermeasure = _FALSE;
+               padapter->securitypriv.btkip_countermeasure = false;
             }
 		break;
         }
@@ -2855,7 +2855,7 @@ static int rtw_wx_set_auth(struct net_de
 		*/
 		if (check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {
 			LeaveAllPowerSaveMode(padapter);
-			rtw_disassoc_cmd(padapter, 500, _FALSE);
+			rtw_disassoc_cmd(padapter, 500, false);
 			DBG_871X("%s...call rtw_indicate_disconnect\n ",__func__);
 			rtw_indicate_disconnect(padapter);
 			rtw_free_assoc_resources(padapter, 1);
@@ -3539,7 +3539,7 @@ static int rtw_get_ap_info(struct net_de
 		goto exit;
 	}
 
-	while((check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) == _TRUE)
+	while((check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) == true)
 	{
 		rtw_msleep_os(30);
 		cnt++;
@@ -3571,7 +3571,7 @@ static int rtw_get_ap_info(struct net_de
 
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+		if (rtw_end_of_queue_search(phead,plist)== true)
 			break;
 
 
@@ -3586,7 +3586,7 @@ static int rtw_get_ap_info(struct net_de
 		}
 
 
-		if (_rtw_memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN) == _TRUE)//BSSID match, then check if supporting wpa/wpa2
+		if (_rtw_memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN) == true)//BSSID match, then check if supporting wpa/wpa2
 		{
 			DBG_871X("BSSID:" MAC_FMT "\n", MAC_ARG(bssid));
 
@@ -4228,7 +4228,7 @@ static int rtw_p2p_get_wps_configmethod(
 
 	while (1)
 	{
-		if (rtw_end_of_queue_search(phead, plist) == _TRUE) break;
+		if (rtw_end_of_queue_search(phead, plist) == true) break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
@@ -4305,7 +4305,7 @@ static int rtw_p2p_get_peer_wfd_preferre
 	DBG_871X("[%s] wfd_pc = %d\n", __func__, pwdinfo->wfd_info->wfd_pc);
 
 	wrqu->data.length = strlen(extra);
-	pwdinfo->wfd_info->wfd_pc = _FALSE;	//	Reset the WFD preferred connection to P2P
+	pwdinfo->wfd_info->wfd_pc = false;	//	Reset the WFD preferred connection to P2P
 	return ret;
 
 }
@@ -4324,7 +4324,7 @@ static int rtw_p2p_get_peer_wfd_session_
 	DBG_871X("[%s] wfd_sa = %d\n", __func__, pwdinfo->wfd_info->peer_session_avail);
 
 	wrqu->data.length = strlen(extra);
-	pwdinfo->wfd_info->peer_session_avail = _TRUE;	//	Reset the WFD session available
+	pwdinfo->wfd_info->peer_session_avail = true;	//	Reset the WFD session available
 	return ret;
 
 }
@@ -4365,7 +4365,7 @@ static int rtw_p2p_get_go_device_address
 
 	while (1)
 	{
-		if (rtw_end_of_queue_search(phead, plist) == _TRUE) break;
+		if (rtw_end_of_queue_search(phead, plist) == true) break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
@@ -4457,7 +4457,7 @@ static int rtw_p2p_get_device_type(struc
 
 	while (1)
 	{
-		if (rtw_end_of_queue_search(phead, plist) == _TRUE) break;
+		if (rtw_end_of_queue_search(phead, plist) == true) break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
@@ -4535,7 +4535,7 @@ static int rtw_p2p_get_device_name(struc
 
 	while (1)
 	{
-		if (rtw_end_of_queue_search(phead, plist) == _TRUE) break;
+		if (rtw_end_of_queue_search(phead, plist) == true) break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
@@ -4609,7 +4609,7 @@ static int rtw_p2p_get_invitation_proced
 
 	while (1)
 	{
-		if (rtw_end_of_queue_search(phead, plist) == _TRUE) break;
+		if (rtw_end_of_queue_search(phead, plist) == true) break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
@@ -4719,7 +4719,7 @@ static int rtw_p2p_connect(struct net_de
 
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+		if (rtw_end_of_queue_search(phead,plist)== true)
 			break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -4749,7 +4749,7 @@ static int rtw_p2p_connect(struct net_de
 
 		pwdinfo->nego_req_info.peer_channel_num[ 0 ] = uintPeerChannel;
 		_rtw_memcpy(pwdinfo->nego_req_info.peerDevAddr, pnetwork->network.MacAddress, ETH_ALEN);
-		pwdinfo->nego_req_info.benable = _TRUE;
+		pwdinfo->nego_req_info.benable = true;
 
 		_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
 		if (rtw_p2p_state(pwdinfo) != P2P_STATE_GONEGO_OK)
@@ -4851,7 +4851,7 @@ static int rtw_p2p_invite_req(struct net
 	else
 	{
 		//	Reset the content of struct tx_invite_req_info
-		pinvite_req_info->benable = _FALSE;
+		pinvite_req_info->benable = false;
 		_rtw_memset(pinvite_req_info->go_bssid, 0x00, ETH_ALEN);
 		_rtw_memset(pinvite_req_info->go_ssid, 0x00, WLAN_SSID_MAXLEN);
 		pinvite_req_info->ssidlen = 0x00;
@@ -4872,7 +4872,7 @@ static int rtw_p2p_invite_req(struct net
 
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+		if (rtw_end_of_queue_search(phead,plist)== true)
 			break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -4935,16 +4935,16 @@ static int rtw_p2p_invite_req(struct net
 				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
 				if (wfd_devinfo_field & WFD_DEVINFO_SESSION_AVAIL)
 				{
-					pwfd_info->peer_session_avail = _TRUE;
+					pwfd_info->peer_session_avail = true;
 				}
 				else
 				{
-					pwfd_info->peer_session_avail = _FALSE;
+					pwfd_info->peer_session_avail = false;
 				}
 			}
 		}
 
-		if (_FALSE == pwfd_info->peer_session_avail)
+		if (false == pwfd_info->peer_session_avail)
 		{
 			DBG_871X("[%s] WFD Session not avaiable!\n", __func__);
 			goto exit;
@@ -4970,7 +4970,7 @@ static int rtw_p2p_invite_req(struct net
 		//	Store the GO's ssid
 		pinvite_req_info->ssidlen = wrqu->data.length - 36;
 		_rtw_memcpy(pinvite_req_info->go_ssid, &extra[ 36 ], (u32) pinvite_req_info->ssidlen);
-		pinvite_req_info->benable = _TRUE;
+		pinvite_req_info->benable = true;
 		pinvite_req_info->peer_ch = uintPeerChannel;
 
 		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
@@ -5066,15 +5066,15 @@ static int rtw_p2p_set_persistent(struct
 	{
 		if (extra[ 0 ] == '0')	//	Disable the persistent group function.
 		{
-			pwdinfo->persistent_supported = _FALSE;
+			pwdinfo->persistent_supported = false;
 		}
 		else if (extra[ 0 ] == '1')	//	Enable the persistent group function.
 		{
-			pwdinfo->persistent_supported = _TRUE;
+			pwdinfo->persistent_supported = true;
 		}
 		else
 		{
-			pwdinfo->persistent_supported = _FALSE;
+			pwdinfo->persistent_supported = false;
 		}
 	}
 	printk("[%s] persistent_supported = %d\n", __func__, pwdinfo->persistent_supported);
@@ -5137,7 +5137,7 @@ static int rtw_p2p_set_pc(struct net_dev
 
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+		if (rtw_end_of_queue_search(phead,plist)== true)
 			break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -5202,11 +5202,11 @@ static int rtw_p2p_set_pc(struct net_dev
 				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
 				if (wfd_devinfo_field & WFD_DEVINFO_PC_TDLS)
 				{
-					pwfd_info->wfd_pc = _TRUE;
+					pwfd_info->wfd_pc = true;
 				}
 				else
 				{
-					pwfd_info->wfd_pc = _FALSE;
+					pwfd_info->wfd_pc = false;
 				}
 			}
 		}
@@ -5322,15 +5322,15 @@ static int rtw_p2p_set_sa(struct net_dev
 	{
 		if (extra[ 0 ] == '0')	//	Disable the session available.
 		{
-			pwdinfo->session_available = _FALSE;
+			pwdinfo->session_available = false;
 		}
 		else if (extra[ 0 ] == '1')	//	Enable the session available.
 		{
-			pwdinfo->session_available = _TRUE;
+			pwdinfo->session_available = true;
 		}
 		else
 		{
-			pwdinfo->session_available = _FALSE;
+			pwdinfo->session_available = false;
 		}
 	}
 	printk("[%s] session available = %d\n", __func__, pwdinfo->session_available);
@@ -5394,7 +5394,7 @@ static int rtw_p2p_prov_disc(struct net_
 		_rtw_memset(&pwdinfo->tx_prov_disc_info.ssid, 0x00, sizeof(NDIS_802_11_SSID));
 		pwdinfo->tx_prov_disc_info.peer_channel_num[ 0 ] = 0;
 		pwdinfo->tx_prov_disc_info.peer_channel_num[ 1 ] = 0;
-		pwdinfo->tx_prov_disc_info.benable = _FALSE;
+		pwdinfo->tx_prov_disc_info.benable = false;
 	}
 
 	for(jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
@@ -5431,7 +5431,7 @@ static int rtw_p2p_prov_disc(struct net_
 
 	while(1)
 	{
-		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
+		if (rtw_end_of_queue_search(phead,plist)== true)
 			break;
 
 		if (uintPeerChannel != 0)
@@ -5501,16 +5501,16 @@ static int rtw_p2p_prov_disc(struct net_
 				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
 				if (wfd_devinfo_field & WFD_DEVINFO_SESSION_AVAIL)
 				{
-					pwfd_info->peer_session_avail = _TRUE;
+					pwfd_info->peer_session_avail = true;
 				}
 				else
 				{
-					pwfd_info->peer_session_avail = _FALSE;
+					pwfd_info->peer_session_avail = false;
 				}
 			}
 		}
 
-		if (_FALSE == pwfd_info->peer_session_avail)
+		if (false == pwfd_info->peer_session_avail)
 		{
 			DBG_871X("[%s] WFD Session not avaiable!\n", __func__);
 			goto exit;
@@ -5531,7 +5531,7 @@ static int rtw_p2p_prov_disc(struct net_
 		_rtw_memcpy(pwdinfo->tx_prov_disc_info.peerIFAddr, pnetwork->network.MacAddress, ETH_ALEN);
 		_rtw_memcpy(pwdinfo->tx_prov_disc_info.peerDevAddr, peerMAC, ETH_ALEN);
 		pwdinfo->tx_prov_disc_info.peer_channel_num[0] = (u16) uintPeerChannel;
-		pwdinfo->tx_prov_disc_info.benable = _TRUE;
+		pwdinfo->tx_prov_disc_info.benable = true;
 		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ);
 
@@ -5904,7 +5904,7 @@ static int rtw_rereg_nd_name(struct net_
 		goto exit;
 	}
 
-	if (_rtw_memcmp(rereg_priv->old_ifname, "disable%d", 9) == _TRUE) {
+	if (_rtw_memcmp(rereg_priv->old_ifname, "disable%d", 9) == true) {
 		padapter->ledpriv.bRegUseLed= rereg_priv->old_bRegUseLed;
 		rtw_hal_sw_led_init(padapter);
 		rtw_ips_mode_req(&padapter->pwrctrlpriv, rereg_priv->old_ips_mode);
@@ -5913,16 +5913,16 @@ static int rtw_rereg_nd_name(struct net_
 	strncpy(rereg_priv->old_ifname, new_ifname, IFNAMSIZ);
 	rereg_priv->old_ifname[IFNAMSIZ-1] = 0;
 
-	if (_rtw_memcmp(new_ifname, "disable%d", 9) == _TRUE) {
+	if (_rtw_memcmp(new_ifname, "disable%d", 9) == true) {
 
 		DBG_871X("%s disable\n", __func__);
 		// free network queue for Android's timming issue
-		rtw_free_network_queue(padapter, _TRUE);
+		rtw_free_network_queue(padapter, true);
 
 		// close led
 		rtw_led_control(padapter, LED_CTL_POWER_OFF);
 		rereg_priv->old_bRegUseLed = padapter->ledpriv.bRegUseLed;
-		padapter->ledpriv.bRegUseLed= _FALSE;
+		padapter->ledpriv.bRegUseLed= false;
 		rtw_hal_sw_led_deinit(padapter);
 
 		// the interface is being "disabled", we can do deeper IPS
@@ -6331,7 +6331,7 @@ static int rtw_dbg_port(struct net_devic
 							phead = &(pstapriv->sta_hash[i]);
 							plist = get_next(phead);
 
-							while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+							while ((rtw_end_of_queue_search(phead, plist)) == false)
 							{
 								psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
@@ -7047,7 +7047,7 @@ static int rtw_set_encryption(struct net
 				_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 				_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 
-				psecuritypriv->busetkipkey = _TRUE;
+				psecuritypriv->busetkipkey = true;
 
 			}
 			else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
@@ -7067,7 +7067,7 @@ static int rtw_set_encryption(struct net
 
 			psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
 
-			psecuritypriv->binstallGrpkey = _TRUE;
+			psecuritypriv->binstallGrpkey = true;
 
 			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
 
@@ -7076,7 +7076,7 @@ static int rtw_set_encryption(struct net
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
 			if (pbcmc_sta)
 			{
-				pbcmc_sta->ieee8021x_blocked = _FALSE;
+				pbcmc_sta->ieee8021x_blocked = false;
 				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
 			}
 
@@ -7115,7 +7115,7 @@ static int rtw_set_encryption(struct net
 					_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 					_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
-					psecuritypriv->busetkipkey = _TRUE;
+					psecuritypriv->busetkipkey = true;
 
 				}
 				else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
@@ -7134,7 +7134,7 @@ static int rtw_set_encryption(struct net
 
 				set_pairwise_key(padapter, psta);
 
-				psta->ieee8021x_blocked = _FALSE;
+				psta->ieee8021x_blocked = false;
 
 			}
 			else//group key???
@@ -7160,7 +7160,7 @@ static int rtw_set_encryption(struct net
 					_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 					_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 
-					psecuritypriv->busetkipkey = _TRUE;
+					psecuritypriv->busetkipkey = true;
 
 				}
 				else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
@@ -7176,7 +7176,7 @@ static int rtw_set_encryption(struct net
 
 				psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
 
-				psecuritypriv->binstallGrpkey = _TRUE;
+				psecuritypriv->binstallGrpkey = true;
 
 				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
 
@@ -7185,7 +7185,7 @@ static int rtw_set_encryption(struct net
 				pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
 				if (pbcmc_sta)
 				{
-					pbcmc_sta->ieee8021x_blocked = _FALSE;
+					pbcmc_sta->ieee8021x_blocked = false;
 					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
 				}
 
@@ -7217,7 +7217,7 @@ static int rtw_set_beacon(struct net_dev
 
 	DBG_871X("%s, len=%d\n", __func__, len);
 
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
 	_rtw_memcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);
@@ -7266,7 +7266,7 @@ static int rtw_add_sta(struct net_device
 
 	DBG_871X("rtw_add_sta(aid=%d)=" MAC_FMT "\n", param->u.add_sta.aid, MAC_ARG(param->sta_addr));
 
-	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)
 	{
 		return -EINVAL;
 	}
@@ -7317,17 +7317,17 @@ static int rtw_add_sta(struct net_device
 		//chec 802.11n ht cap.
 		if (WLAN_STA_HT&flags)
 		{
-			psta->htpriv.ht_option = _TRUE;
+			psta->htpriv.ht_option = true;
 			psta->qos_option = 1;
 			_rtw_memcpy((void*)&psta->htpriv.ht_cap, (void*)&param->u.add_sta.ht_cap, sizeof(struct rtw_ieee80211_ht_cap));
 		}
 		else
 		{
-			psta->htpriv.ht_option = _FALSE;
+			psta->htpriv.ht_option = false;
 		}
 
-		if (pmlmepriv->htpriv.ht_option == _FALSE)
-			psta->htpriv.ht_option = _FALSE;
+		if (pmlmepriv->htpriv.ht_option == false)
+			psta->htpriv.ht_option = false;
 #endif
 
 
@@ -7355,7 +7355,7 @@ static int rtw_del_sta(struct net_device
 
 	DBG_871X("rtw_del_sta=" MAC_FMT "\n", MAC_ARG(param->sta_addr));
 
-	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)
 	{
 		return -EINVAL;
 	}
@@ -7375,11 +7375,11 @@ static int rtw_del_sta(struct net_device
 		//DBG_871X("free psta=%p, aid=%d\n", psta, psta->aid);
 
 		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-		if (rtw_is_list_empty(&psta->asoc_list)==_FALSE)
+		if (rtw_is_list_empty(&psta->asoc_list)==false)
 		{
 			rtw_list_delete(&psta->asoc_list);
 			pstapriv->asoc_list_cnt--;
-			updated = ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_DEAUTH_LEAVING);
+			updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
 
 		}
 		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
@@ -7413,7 +7413,7 @@ static int rtw_ioctl_get_sta_data(struct
 
 	DBG_871X("rtw_ioctl_get_sta_info, sta_addr: " MAC_FMT "\n", MAC_ARG(param_ex->sta_addr));
 
-	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)
 	{
 		return -EINVAL;
 	}
@@ -7482,7 +7482,7 @@ static int rtw_get_sta_wpaie(struct net_
 
 	DBG_871X("rtw_get_sta_wpaie, sta_addr: " MAC_FMT "\n", MAC_ARG(param->sta_addr));
 
-	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)
 	{
 		return -EINVAL;
 	}
@@ -7537,7 +7537,7 @@ static int rtw_set_wps_beacon(struct net
 
 	DBG_871X("%s, len=%d\n", __func__, len);
 
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
 	ie_len = len-12-2;// 12 = param header, 2:no packed
@@ -7560,9 +7560,9 @@ static int rtw_set_wps_beacon(struct net
 
 		_rtw_memcpy(pmlmepriv->wps_beacon_ie, param->u.bcn_ie.buf, ie_len);
 
-		update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, _TRUE);
+		update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, true);
 
-		pmlmeext->bstart_bss = _TRUE;
+		pmlmeext->bstart_bss = true;
 
 	}
 
@@ -7580,7 +7580,7 @@ static int rtw_set_wps_probe_resp(struct
 
 	DBG_871X("%s, len=%d\n", __func__, len);
 
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
 	ie_len = len-12-2;// 12 = param header, 2:no packed
@@ -7617,7 +7617,7 @@ static int rtw_set_wps_assoc_resp(struct
 
 	DBG_871X("%s, len=%d\n", __func__, len);
 
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
 	ie_len = len-12-2;// 12 = param header, 2:no packed
@@ -7659,7 +7659,7 @@ static int rtw_set_hidden_ssid(struct ne
 	sint ssid_len;
 	u8 ignore_broadcast_ssid;
 
-	if (check_fwstate(mlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(mlmepriv, WIFI_AP_STATE) != true)
 		return -EPERM;
 
 	if (param->u.bcn_ie.reserved[0] != 0xea)
@@ -7706,7 +7706,7 @@ static int rtw_ioctl_acl_remove_sta(stru
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
@@ -7728,7 +7728,7 @@ static int rtw_ioctl_acl_add_sta(struct
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
@@ -7750,7 +7750,7 @@ static int rtw_ioctl_set_macaddr_acl(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
 	rtw_set_macaddr_acl(padapter, param->u.mlme.command);
@@ -7771,7 +7771,7 @@ static int rtw_hostapd_ioctl(struct net_
 	* so, we just check hw_init_completed instead of call rfpwrstate_check()
 	*/
 
-	if (padapter->hw_init_completed==_FALSE){
+	if (padapter->hw_init_completed==false){
 		ret = -EPERM;
 		goto out;
 	}
@@ -7961,7 +7961,7 @@ static int rtw_wx_set_priv(struct net_de
 		u8 wps_oui[4]={0x0,0x50,0xf2,0x04};
 
 		if ((_VENDOR_SPECIFIC_IE_ == probereq_wpsie[0]) &&
-			(_rtw_memcmp(&probereq_wpsie[2], wps_oui, 4) ==_TRUE))
+			(_rtw_memcmp(&probereq_wpsie[2], wps_oui, 4) ==true))
 		{
 			cp_sz = probereq_wpsie_len>MAX_WPS_IE_LEN ? MAX_WPS_IE_LEN:probereq_wpsie_len;
 
@@ -7996,7 +7996,7 @@ static int rtw_wx_set_priv(struct net_de
 	}
 
 	if (	len >= WEXT_CSCAN_HEADER_SIZE
-		&& _rtw_memcmp(ext, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == _TRUE
+		&& _rtw_memcmp(ext, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == true
 	){
 		ret = rtw_wx_set_scan(dev, info, awrq, ext);
 		goto FREE_EXT;
@@ -8019,7 +8019,7 @@ static int rtw_wx_set_priv(struct net_de
 				struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 				struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
 
-				if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+				if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
 					sprintf(ext, "%s rssi %d", pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
 				} else {
 					sprintf(ext, "OK");
@@ -8174,7 +8174,7 @@ static int rtw_mp_efuse_get(struct net_d
 		DBG_871X("cnts = %d \n" ,cnts);
 		//_rtw_memset(extra, '\0', wrqu->data.length);
 
-		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, false);
 		if ((addr + cnts) > max_available_size) {
 			DBG_871X("(addr + cnts parameter error \n");
 			return -EFAULT;
@@ -8206,7 +8206,7 @@ static int rtw_mp_efuse_get(struct net_d
 		addr=0;
 		mapLen = EFUSE_MAX_SIZE;
 
-		if (rtw_efuse_access(padapter, _FALSE, addr, mapLen, rawdata) == _FAIL)
+		if (rtw_efuse_access(padapter, false, addr, mapLen, rawdata) == _FAIL)
 		{
 			DBG_871X("\t  rtw_efuse_map_read : Fail \n");
 			return -EFAULT;
@@ -8236,7 +8236,7 @@ static int rtw_mp_efuse_get(struct net_d
 		if (tmp[1]==NULL || tmp[2]==NULL) return	-EINVAL;
 		addr = 0x19;
 		cnts = 6;
-		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, false);
 		if ((addr + mapLen) > max_available_size) {
 			DBG_871X("(addr + cnts parameter error \n");
 			return -EFAULT;
@@ -8262,7 +8262,7 @@ static int rtw_mp_efuse_get(struct net_d
 		if (tmp[1]==NULL || tmp[2]==NULL) return	-EINVAL;
 		addr = 0x0c;
 		cnts = 4;
-		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, false);
 		if ((addr + mapLen) > max_available_size) {
 			DBG_871X("(addr + cnts parameter error \n");
 			return -EFAULT;
@@ -8349,7 +8349,7 @@ static int rtw_mp_efuse_set(struct net_d
 				setdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+ 1]);
 			}
 
-			EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+			EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, false);
 
 			if ((addr + cnts) > max_available_size) {
 						DBG_871X("parameter error \n");
@@ -8381,7 +8381,7 @@ static int rtw_mp_efuse_set(struct net_d
 					setrawdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+ 1]);
 			}
 
-			if (rtw_efuse_access(padapter, _TRUE, addr, cnts, setrawdata) == _FAIL){
+			if (rtw_efuse_access(padapter, true, addr, cnts, setrawdata) == _FAIL){
 					DBG_871X("\t  rtw_efuse_map_read : Fail \n");
 						return -EFAULT;
 			} else
@@ -8407,7 +8407,7 @@ static int rtw_mp_efuse_set(struct net_d
 					setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk+ 1]);
 				}
 
-				EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+				EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, false);
 
 				if ((addr + cnts) > max_available_size) {
 						DBG_871X("parameter error \n");
@@ -8437,7 +8437,7 @@ static int rtw_mp_efuse_set(struct net_d
 				setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk+ 1]);
 			}
 
-			EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+			EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, false);
 
 			if ((addr + cnts) > max_available_size) {
 				DBG_871X("parameter error \n");
@@ -9268,7 +9268,7 @@ static int rtw_mp_thermal(struct net_dev
 	 Hal_GetThermalMeter(padapter, &val);
 
 	 if (bwrite == 0) {
-		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, false);
 		if (2 > max_available_size) {
 			DBG_871X("no available efuse!\n");
 			return -EFAULT;
@@ -9658,7 +9658,7 @@ static int rtw_tdls_enable(struct net_de
 			phead = &(pstapriv->sta_hash[index]);
 			plist = get_next(phead);
 
-			while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+			while ((rtw_end_of_queue_search(phead, plist)) == false)
 			{
 				psta = LIST_CONTAINOR(plist, struct sta_info ,hash_list);
 
@@ -10274,7 +10274,7 @@ static int rtw_wowlan_ctrl(struct net_de
 	}
 	poidparam = (struct wowlan_ioctl_param *)pparmbuf;
 
-	if (padapter->pwrctrlpriv.bSupportRemoteWakeup==_FALSE){
+	if (padapter->pwrctrlpriv.bSupportRemoteWakeup==false){
 		ret = -EPERM;
 		DBG_871X("+rtw_wowlan_ctrl: Device didn't support the remote wakeup!!\n");
 		goto _rtw_wowlan_ctrl_exit_free;
@@ -10667,7 +10667,7 @@ static struct iw_statistics *rtw_get_wir
 	int tmp_qual = 0;
 	int tmp_noise = 0;
 
-	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) != _TRUE)
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) != true)
 	{
 		piwstats->qual.qual = 0;
 		piwstats->qual.level = 0;
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -124,7 +124,7 @@ int rtw_bt_iso = 2;/*  0:Low, 1:High, 2:
 int rtw_bt_sco = 3;/*  0:Idle, 1:None-SCO, 2:SCO, 3:From Counter, 4.Busy, 5.OtherBusy */
 int rtw_bt_ampdu = 1 ;/*  0:Disable BT control A-MPDU, 1:Enable BT control A-MPDU. */
 #endif
-static int rtw_AcceptAddbaReq = _TRUE;/*  0:Reject AP's Add BA req, 1:Accept AP's Add BA req. */
+static int rtw_AcceptAddbaReq = true;/*  0:Reject AP's Add BA req, 1:Accept AP's Add BA req. */
 
 static int  rtw_antdiv_cfg = 2; /*  0:OFF , 1:ON, 2:decide by Efuse config */
 
@@ -218,7 +218,7 @@ MODULE_PARM_DESC(rtw_max_roaming_times,"
 #endif /* CONFIG_LAYER2_ROAMING */
 
 #ifdef CONFIG_IOL
-bool rtw_force_iol = _FALSE;
+bool rtw_force_iol = false;
 module_param(rtw_force_iol, bool, 0644);
 MODULE_PARM_DESC(rtw_force_iol,"Force to enable IOL");
 #endif /* CONFIG_IOL */
@@ -802,7 +802,7 @@ static int rtw_net_set_mac_address(struc
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
 	struct sockaddr *addr = p;
 
-	if (padapter->bup == _FALSE)
+	if (padapter->bup == false)
 	{
 		/* addr->sa_data[4], addr->sa_data[5]); */
 		_rtw_memcpy(padapter->eeprompriv.mac_addr, addr->sa_data, ETH_ALEN);
@@ -1040,7 +1040,7 @@ u32 rtw_start_drv_threads(_adapter *pada
 #endif
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (padapter->isprimary == _TRUE)
+	if (padapter->isprimary == true)
 #endif /* CONFIG_CONCURRENT_MODE */
 	{
 		padapter->cmdThread = kthread_run(rtw_cmd_thread, padapter, "RTW_CMD_THREAD");
@@ -1066,7 +1066,7 @@ void rtw_stop_drv_threads (_adapter *pad
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_stop_drv_threads\n"));
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (padapter->isprimary == _TRUE)
+	if (padapter->isprimary == true)
 #endif /* CONFIG_CONCURRENT_MODE */
 	{
 		/* Below is to termindate rtw_cmd_thread & event_thread... */
@@ -1128,7 +1128,7 @@ u8 rtw_init_default_value(_adapter *pada
 
 	/* ht_priv */
 #ifdef CONFIG_80211N_HT
-	pmlmepriv->htpriv.ampdu_enable = _FALSE;/* set to disabled */
+	pmlmepriv->htpriv.ampdu_enable = false;/* set to disabled */
 #endif
 
 	/* security_priv */
@@ -1160,8 +1160,8 @@ u8 rtw_init_default_value(_adapter *pada
 	rtw_hal_def_value_init(padapter);
 
 	/* misc. */
-	padapter->bReadPortCancel = _FALSE;
-	padapter->bWritePortCancel = _FALSE;
+	padapter->bReadPortCancel = false;
+	padapter->bWritePortCancel = false;
 	padapter->bRxRSSIDisplay = 0;
 	padapter->bForceWriteInitGain = 1;
 	padapter->bNotifyChannelChange = 0;
@@ -1179,18 +1179,18 @@ u8 rtw_reset_drv_sw(_adapter *padapter)
 
 	/* hal_priv */
 	rtw_hal_def_value_init(padapter);
-	padapter->bReadPortCancel = _FALSE;
-	padapter->bWritePortCancel = _FALSE;
+	padapter->bReadPortCancel = false;
+	padapter->bWritePortCancel = false;
 	padapter->bRxRSSIDisplay = 0;
 	pmlmepriv->scan_interval = SCAN_INTERVAL;/*  30*2 sec = 60sec */
 
-	pwrctrlpriv->bips_processing = _FALSE;
+	pwrctrlpriv->bips_processing = false;
 	pwrctrlpriv->rf_pwrstate = rf_on;
 
 	padapter->xmitpriv.tx_pkts = 0;
 	padapter->recvpriv.rx_pkts = 0;
 
-	pmlmepriv->LinkDetectInfo.bBusyTraffic = _FALSE;
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
 
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY |_FW_UNDER_LINKING);
 
@@ -1475,19 +1475,19 @@ int _netdev_vir_if_open(struct net_devic
 	if (!primary_padapter)
 		goto _netdev_virtual_iface_open_error;
 
-	if (primary_padapter->bup == _FALSE || primary_padapter->hw_init_completed == _FALSE)
+	if (primary_padapter->bup == false || primary_padapter->hw_init_completed == false)
 	{
 		_netdev_open(primary_padapter->pnetdev);
 	}
 
-	if (padapter->bup == _FALSE && primary_padapter->bup == _TRUE &&
-		primary_padapter->hw_init_completed == _TRUE)
+	if (padapter->bup == false && primary_padapter->bup == true &&
+		primary_padapter->hw_init_completed == true)
 	{
 		int i;
 
-		padapter->bDriverStopped = _FALSE;
-		padapter->bSurpriseRemoved = _FALSE;
-		padapter->bCardDisableWOHSM = _FALSE;
+		padapter->bDriverStopped = false;
+		padapter->bSurpriseRemoved = false;
+		padapter->bCardDisableWOHSM = false;
 
 		_rtw_memcpy(padapter->HalData, primary_padapter->HalData, padapter->hal_data_sz);
 
@@ -1505,14 +1505,14 @@ int _netdev_vir_if_open(struct net_devic
 		rtw_cfg80211_init_wiphy(padapter);
 #endif
 
-		padapter->bup = _TRUE;
-		padapter->hw_init_completed = _TRUE;
+		padapter->bup = true;
+		padapter->hw_init_completed = true;
 
-		rtw_start_mbssid_cam(padapter);/* start mbssid_cam after bup = _TRUE & hw_init_completed = _TRUE */
+		rtw_start_mbssid_cam(padapter);/* start mbssid_cam after bup = true & hw_init_completed = true */
 
 	}
 
-	padapter->net_closed = _FALSE;
+	padapter->net_closed = false;
 
 	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
 
@@ -1527,7 +1527,7 @@ int _netdev_vir_if_open(struct net_devic
 
 _netdev_virtual_iface_open_error:
 
-	padapter->bup = _FALSE;
+	padapter->bup = false;
 
 	netif_carrier_off(pnetdev);
 	rtw_netif_stop_queue(pnetdev);
@@ -1551,7 +1551,7 @@ static int netdev_vir_if_close(struct ne
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
 
-	padapter->net_closed = _TRUE;
+	padapter->net_closed = true;
 
 	if (pnetdev)
 	{
@@ -1561,7 +1561,7 @@ static int netdev_vir_if_close(struct ne
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_scan_abort(padapter);
-	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = _FALSE;
+	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = false;
 #endif
 
 	return 0;
@@ -1592,8 +1592,8 @@ _adapter *rtw_drv_add_vir_if (_adapter *
 	u8 mac[ETH_ALEN];
 
 /*
-	if ((primary_padapter->bup == _FALSE) ||
-		(rtw_buddy_adapter_up(primary_padapter) == _FALSE))
+	if ((primary_padapter->bup == false) ||
+		(rtw_buddy_adapter_up(primary_padapter) == false))
 	{
 		goto error_rtw_drv_add_iface;
 	}
@@ -1621,13 +1621,13 @@ _adapter *rtw_drv_add_vir_if (_adapter *
 	_rtw_memcpy(padapter, primary_padapter, sizeof(_adapter));
 
 	/*  */
-	padapter->bup = _FALSE;
-	padapter->net_closed = _TRUE;
-	padapter->hw_init_completed = _FALSE;
+	padapter->bup = false;
+	padapter->net_closed = true;
+	padapter->hw_init_completed = false;
 
 
 	/* set adapter_type/iface type */
-	padapter->isprimary = _FALSE;
+	padapter->isprimary = false;
 	padapter->adapter_type = MAX_ADAPTER;
 	padapter->pbuddy_adapter = primary_padapter;
 	pr_debug("pbuddy_adapter: %p\n", primary_padapter);
@@ -1756,9 +1756,9 @@ void rtw_drv_stop_vir_if (_adapter *pada
 
 	rtw_cancel_all_timer(padapter);
 
-	if (padapter->bup == _TRUE)
+	if (padapter->bup == true)
 	{
-		padapter->bDriverStopped = _TRUE;
+		padapter->bDriverStopped = true;
 
 		#ifdef CONFIG_XMIT_ACK
 		if (padapter->xmitpriv.ack_tx)
@@ -1772,7 +1772,7 @@ void rtw_drv_stop_vir_if (_adapter *pada
 
 		rtw_stop_drv_threads(padapter);
 
-		padapter->bup = _FALSE;
+		padapter->bup = false;
 	}
 
 #ifdef CONFIG_IOCTL_CFG80211
@@ -1849,19 +1849,19 @@ static int _netdev_if2_open(struct net_d
 
 	DBG_871X("+871x_drv - if2_open, bup =%d\n", padapter->bup);
 
-	if (primary_padapter->bup == _FALSE || primary_padapter->hw_init_completed == _FALSE)
+	if (primary_padapter->bup == false || primary_padapter->hw_init_completed == false)
 	{
 		_netdev_open(primary_padapter->pnetdev);
 	}
 
-	if (padapter->bup == _FALSE && primary_padapter->bup == _TRUE &&
-		primary_padapter->hw_init_completed == _TRUE)
+	if (padapter->bup == false && primary_padapter->bup == true &&
+		primary_padapter->hw_init_completed == true)
 	{
 		int i;
 
-		padapter->bDriverStopped = _FALSE;
-		padapter->bSurpriseRemoved = _FALSE;
-		padapter->bCardDisableWOHSM = _FALSE;
+		padapter->bDriverStopped = false;
+		padapter->bSurpriseRemoved = false;
+		padapter->bCardDisableWOHSM = false;
 
 		_rtw_memcpy(padapter->HalData, primary_padapter->HalData, padapter->hal_data_sz);
 
@@ -1883,7 +1883,7 @@ static int _netdev_if2_open(struct net_d
 		}
 
 
-		padapter->hw_init_completed = _TRUE;
+		padapter->hw_init_completed = true;
 
 		padapter->dir_dev = NULL;
 		rtw_proc_init_one(pnetdev);
@@ -1893,11 +1893,11 @@ static int _netdev_if2_open(struct net_d
 		rtw_cfg80211_init_wiphy(padapter);
 #endif
 
-		padapter->bup = _TRUE;
+		padapter->bup = true;
 
 	}
 
-	padapter->net_closed = _FALSE;
+	padapter->net_closed = false;
 
 	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
 
@@ -1911,7 +1911,7 @@ static int _netdev_if2_open(struct net_d
 
 netdev_if2_open_error:
 
-	padapter->bup = _FALSE;
+	padapter->bup = false;
 
 	netif_carrier_off(pnetdev);
 	rtw_netif_stop_queue(pnetdev);
@@ -1935,7 +1935,7 @@ static int netdev_if2_close(struct net_d
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
 
-	padapter->net_closed = _TRUE;
+	padapter->net_closed = true;
 
 	if (pnetdev)
 	{
@@ -1945,7 +1945,7 @@ static int netdev_if2_close(struct net_d
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_scan_abort(padapter);
-	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = _FALSE;
+	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = false;
 #endif
 
 	return 0;
@@ -1996,12 +1996,12 @@ _adapter *rtw_drv_if2_init(_adapter *pri
 	_rtw_memcpy(padapter, primary_padapter, sizeof(_adapter));
 
 	/*  */
-	padapter->bup = _FALSE;
-	padapter->net_closed = _TRUE;
-	padapter->hw_init_completed = _FALSE;
+	padapter->bup = false;
+	padapter->net_closed = true;
+	padapter->hw_init_completed = false;
 
 	/* set adapter_type/iface type */
-	padapter->isprimary = _FALSE;
+	padapter->isprimary = false;
 	padapter->adapter_type = SECONDARY_ADAPTER;
 	padapter->pbuddy_adapter = primary_padapter;
 	pr_debug("pbuddy_adapter: %p\n", primary_padapter);
@@ -2157,8 +2157,8 @@ void rtw_drv_if2_stop(_adapter *if2)
 
 	rtw_cancel_all_timer(padapter);
 
-	if (padapter->bup == _TRUE) {
-		padapter->bDriverStopped = _TRUE;
+	if (padapter->bup == true) {
+		padapter->bDriverStopped = true;
 		#ifdef CONFIG_XMIT_ACK
 		if (padapter->xmitpriv.ack_tx)
 			rtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_DRV_STOP);
@@ -2171,7 +2171,7 @@ void rtw_drv_if2_stop(_adapter *if2)
 
 		rtw_stop_drv_threads(padapter);
 
-		padapter->bup = _FALSE;
+		padapter->bup = false;
 	}
 
 	#ifdef CONFIG_IOCTL_CFG80211
@@ -2237,16 +2237,16 @@ int _netdev_open(struct net_device *pnet
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+871x_drv - dev_open\n"));
 	DBG_871X("+871x_drv - drv_open, bup =%d\n", padapter->bup);
 
-	if (pwrctrlpriv->ps_flag == _TRUE){
-		padapter->net_closed = _FALSE;
+	if (pwrctrlpriv->ps_flag == true){
+		padapter->net_closed = false;
 		goto netdev_open_normal_process;
 	}
 
-	if (padapter->bup == _FALSE)
+	if (padapter->bup == false)
 	{
-		padapter->bDriverStopped = _FALSE;
-		padapter->bSurpriseRemoved = _FALSE;
-		padapter->bCardDisableWOHSM = _FALSE;
+		padapter->bDriverStopped = false;
+		padapter->bSurpriseRemoved = false;
+		padapter->bCardDisableWOHSM = false;
 
 		status = rtw_hal_init(padapter);
 		if (status == _FAIL)
@@ -2289,13 +2289,13 @@ int _netdev_open(struct net_device *pnet
 
 		rtw_led_control(padapter, LED_CTL_NO_LINK);
 
-		padapter->bup = _TRUE;
+		padapter->bup = true;
 	}
-	padapter->net_closed = _FALSE;
+	padapter->net_closed = false;
 
 	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
 
-	padapter->pwrctrlpriv.bips_processing = _FALSE;
+	padapter->pwrctrlpriv.bips_processing = false;
 	rtw_set_pwr_state_check_timer(&padapter->pwrctrlpriv);
 
 	if (!rtw_netif_queue_stopped(pnetdev))
@@ -2312,7 +2312,7 @@ netdev_open_normal_process:
 	#ifdef CONFIG_CONCURRENT_MODE
 	{
 		_adapter *sec_adapter = padapter->pbuddy_adapter;
-		if (sec_adapter && (sec_adapter->bup == _FALSE || sec_adapter->hw_init_completed == _FALSE))
+		if (sec_adapter && (sec_adapter->bup == false || sec_adapter->hw_init_completed == false))
 			_netdev_if2_open(sec_adapter->pnetdev);
 	}
 	#endif
@@ -2324,7 +2324,7 @@ netdev_open_normal_process:
 
 netdev_open_error:
 
-	padapter->bup = _FALSE;
+	padapter->bup = false;
 
 	netif_carrier_off(pnetdev);
 	rtw_netif_stop_queue(pnetdev);
@@ -2352,13 +2352,13 @@ int netdev_open(struct net_device *pnetd
 static int  ips_netdrv_open(_adapter *padapter)
 {
 	int status = _SUCCESS;
-	padapter->net_closed = _FALSE;
+	padapter->net_closed = false;
 	DBG_871X("===> %s.........\n", __FUNCTION__);
 
 
-	padapter->bDriverStopped = _FALSE;
-	padapter->bSurpriseRemoved = _FALSE;
-	padapter->bCardDisableWOHSM = _FALSE;
+	padapter->bDriverStopped = false;
+	padapter->bSurpriseRemoved = false;
+	padapter->bCardDisableWOHSM = false;
 
 	status = rtw_hal_init(padapter);
 	if (status == _FAIL)
@@ -2405,13 +2405,13 @@ void rtw_ips_pwr_down(_adapter *padapter
 	u32 start_time = rtw_get_current_time();
 	DBG_871X("===> rtw_ips_pwr_down...................\n");
 
-	padapter->bCardDisableWOHSM = _TRUE;
-	padapter->net_closed = _TRUE;
+	padapter->bCardDisableWOHSM = true;
+	padapter->net_closed = true;
 
 	rtw_led_control(padapter, LED_CTL_POWER_OFF);
 
 	rtw_ips_dev_unload(padapter);
-	padapter->bCardDisableWOHSM = _FALSE;
+	padapter->bCardDisableWOHSM = false;
 	DBG_871X("<=== rtw_ips_pwr_down..................... in %dms\n", rtw_get_passing_time_ms(start_time));
 }
 #endif
@@ -2427,7 +2427,7 @@ void rtw_ips_dev_unload(_adapter *padapt
 		padapter->intf_stop(padapter);
 
 	/* s5. */
-	if (padapter->bSurpriseRemoved == _FALSE)
+	if (padapter->bSurpriseRemoved == false)
 		rtw_hal_deinit(padapter);
 }
 
@@ -2450,12 +2450,12 @@ static int netdev_close(struct net_devic
 
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+871x_drv - drv_close\n"));
 
-	if (padapter->pwrctrlpriv.bInternalAutoSuspend == _TRUE)
+	if (padapter->pwrctrlpriv.bInternalAutoSuspend == true)
 	{
 		if (padapter->pwrctrlpriv.rf_pwrstate == rf_off)
-			padapter->pwrctrlpriv.ps_flag = _TRUE;
+			padapter->pwrctrlpriv.ps_flag = true;
 	}
-	padapter->net_closed = _TRUE;
+	padapter->net_closed = true;
 
 	if (padapter->pwrctrlpriv.rf_pwrstate == rf_on){
 		DBG_871X("(2)871x_drv - drv_close, bup =%d, hw_init_completed =%d\n", padapter->bup, padapter->hw_init_completed);
@@ -2470,13 +2470,13 @@ static int netdev_close(struct net_devic
 #ifndef CONFIG_ANDROID
 		/* s2. */
 		LeaveAllPowerSaveMode(padapter);
-		rtw_disassoc_cmd(padapter, 500, _FALSE);
+		rtw_disassoc_cmd(padapter, 500, false);
 		/* s2-2.  indicate disconnect to os */
 		rtw_indicate_disconnect(padapter);
 		/* s2-3. */
 		rtw_free_assoc_resources(padapter, 1);
 		/* s2-4. */
-		rtw_free_network_queue(padapter, _TRUE);
+		rtw_free_network_queue(padapter, true);
 #endif
 		/*  Close LED */
 		rtw_led_control(padapter, LED_CTL_POWER_OFF);
@@ -2488,15 +2488,15 @@ static int netdev_close(struct net_devic
 
 #ifdef CONFIG_P2P
 	#ifdef CONFIG_IOCTL_CFG80211
-	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled == _TRUE)
-		wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = _FALSE;
+	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled == true)
+		wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = false;
 	#endif
 	rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
 #endif /* CONFIG_P2P */
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_scan_abort(padapter);
-	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = _FALSE;
+	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = false;
 	padapter->rtw_wdev->iftype = NL80211_IFTYPE_MONITOR; /* set this at the end */
 #endif /* CONFIG_IOCTL_CFG80211 */
 
--- a/drivers/staging/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8192du/os_dep/osdep_service.c
@@ -384,9 +384,9 @@ int	_rtw_memcmp(void *dst, void *src, u3
 {
 //under Linux/GNU/GLibc, the return value of memcmp for two same mem. chunk is 0
 	if (!(memcmp(dst, src, sz)))
-		return _TRUE;
+		return true;
 	else
-		return _FALSE;
+		return false;
 }
 
 void _rtw_memset(void *pbuf, int c, u32 sz)
@@ -407,9 +407,9 @@ Otherwise, there will be racing conditio
 u32	rtw_is_list_empty(_list *phead)
 {
 	if (list_empty(phead))
-		return _TRUE;
+		return true;
 	else
-		return _FALSE;
+		return false;
 }
 
 void rtw_list_insert_head(_list *plist, _list *phead)
@@ -512,9 +512,9 @@ u32	  _rtw_queue_empty(_queue	*pqueue)
 u32 rtw_end_of_queue_search(_list *head, _list *plist)
 {
 	if (head == plist)
-		return _TRUE;
+		return true;
 	else
-		return _FALSE;
+		return false;
 }
 
 
@@ -874,14 +874,14 @@ static int storeToFile(char *path, u8* b
 /*
 * Test if the specifi @param path is a file and readable
 * @param path the path of the file to test
-* @return _TRUE or _FALSE
+* @return true or false
 */
 int rtw_is_file_readable(char *path)
 {
 	if(isFileReadable(path) == 0)
-		return _TRUE;
+		return true;
 	else
-		return _FALSE;
+		return false;
 }
 
 /*
@@ -1109,22 +1109,22 @@ keep_ori:
  * rtw_cbuf_full - test if cbuf is full
  * @cbuf: pointer of struct rtw_cbuf
  *
- * Returns: _TRUE if cbuf is full
+ * Returns: true if cbuf is full
  */
 inline bool rtw_cbuf_full(struct rtw_cbuf *cbuf)
 {
-	return (cbuf->write == cbuf->read-1)? _TRUE : _FALSE;
+	return (cbuf->write == cbuf->read-1)? true : false;
 }
 
 /**
  * rtw_cbuf_empty - test if cbuf is empty
  * @cbuf: pointer of struct rtw_cbuf
  *
- * Returns: _TRUE if cbuf is empty
+ * Returns: true if cbuf is empty
  */
 inline bool rtw_cbuf_empty(struct rtw_cbuf *cbuf)
 {
-	return (cbuf->write == cbuf->read)? _TRUE : _FALSE;
+	return (cbuf->write == cbuf->read)? true : false;
 }
 
 /**
@@ -1133,7 +1133,7 @@ inline bool rtw_cbuf_empty(struct rtw_cb
  * @buf: pointer to push in
  *
  * Lock free operation, be careful of the use scheme
- * Returns: _TRUE push success
+ * Returns: true push success
  */
 bool rtw_cbuf_push(struct rtw_cbuf *cbuf, void *buf)
 {
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -65,7 +65,7 @@ int rtw_os_recvbuf_resource_alloc(_adapt
 	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
 	struct usb_device	*pusbd = pdvobjpriv->pusbdev;
 
-	precvbuf->irp_pending = _FALSE;
+	precvbuf->irp_pending = false;
 	precvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);
 	if(precvbuf->purb == NULL){
 		res = _FAIL;
@@ -73,7 +73,7 @@ int rtw_os_recvbuf_resource_alloc(_adapt
 
 	precvbuf->pskb = NULL;
 
-	precvbuf->reuse = _FALSE;
+	precvbuf->reuse = false;
 
 	precvbuf->pallocated_buf  = precvbuf->pbuf = NULL;
 
@@ -143,7 +143,7 @@ void rtw_handle_tkip_mic_err(_adapter *p
 
 		if( cur_time - psecuritypriv->last_mic_err_time < 60*HZ )
 		{
-			psecuritypriv->btkip_countermeasure = _TRUE;
+			psecuritypriv->btkip_countermeasure = true;
 			psecuritypriv->last_mic_err_time = 0;
 			psecuritypriv->btkip_countermeasure_time = cur_time;
 		}
@@ -272,7 +272,7 @@ _func_enter_;
 
 	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n skb->head=%p skb->data=%p skb->tail=%p skb->end=%p skb->len=%d\n", skb->head, skb->data, skb->tail, skb->end, skb->len));
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
 		_pkt *pskb2=NULL;
 		struct sta_info *psta = NULL;
@@ -282,7 +282,7 @@ _func_enter_;
 
 		//DBG_871X("bmcast=%d\n", bmcast);
 
-		if(_rtw_memcmp(pattrib->dst, myid(&padapter->eeprompriv), ETH_ALEN)==_FALSE)
+		if(_rtw_memcmp(pattrib->dst, myid(&padapter->eeprompriv), ETH_ALEN)==false)
 		{
 			//DBG_871X("not ap psta=%p, addr=%pM\n", psta, pattrib->dst);
 
@@ -333,7 +333,7 @@ _func_enter_;
 	rcu_read_unlock();
 #endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 
-	if( br_port	&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == _TRUE) )
+	if( br_port	&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) )
 	{
 		int nat25_handle_frame(_adapter *priv, struct sk_buff *skb);
 		if (nat25_handle_frame(padapter, skb) == -1) {
@@ -404,14 +404,10 @@ void rtw_os_read_port(_adapter *padapter
 	dev_kfree_skb_any(precvbuf->pskb);
 
 	precvbuf->pskb = NULL;
-	precvbuf->reuse = _FALSE;
+	precvbuf->reuse = false;
 
-	if(precvbuf->irp_pending == _FALSE)
-	{
+	if(precvbuf->irp_pending == false)
 		rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-	}
-
-
 }
 
 void _rtw_reordering_ctrl_timeout_handler (void *FunctionContext)
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -115,7 +115,7 @@ typedef struct android_wifi_priv_cmd {
  * time (only) in dhd_open, subsequential wifi on will be handled by
  * wl_android_wifi_on
  */
-static int g_wifi_on = _TRUE;
+static int g_wifi_on = true;
 
 
 #ifdef PNO_SUPPORT
@@ -243,7 +243,7 @@ static int rtw_android_get_rssi(struct n
 	struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
 	int bytes_written = 0;
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == true) {
 		bytes_written += snprintf(&command[bytes_written], total_len, "%s rssi %d",
 			pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
 	}
@@ -304,7 +304,7 @@ static int rtw_android_set_block(struct
 	char *block_value = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_BLOCK]) + 1;
 
 	#ifdef CONFIG_IOCTL_CFG80211
-	wdev_to_priv(adapter->rtw_wdev)->block = (*block_value=='0')?_FALSE:_TRUE;
+	wdev_to_priv(adapter->rtw_wdev)->block = (*block_value=='0')?false:true;
 	#endif
 
 	return 0;
@@ -470,7 +470,7 @@ int rtw_android_priv_cmd(struct net_devi
 		_adapter*	padapter = ( _adapter * ) rtw_netdev_priv(net);
 
 		pwfd_info = &padapter->wfd_info;
-		pwfd_info->wfd_enable = _TRUE;
+		pwfd_info->wfd_enable = true;
 		break;
 	}
 	case ANDROID_WIFI_CMD_WFD_DISABLE:
@@ -483,7 +483,7 @@ int rtw_android_priv_cmd(struct net_devi
 		_adapter*	padapter = ( _adapter * ) rtw_netdev_priv(net);
 
 		pwfd_info = &padapter->wfd_info;
-		pwfd_info->wfd_enable = _FALSE;
+		pwfd_info->wfd_enable = false;
 		break;
 	}
 	case ANDROID_WIFI_CMD_WFD_SET_TCPPORT:
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -429,10 +429,10 @@ _func_enter_;
 	DBG_871X("nr_endpoint=%d, in_num=%d, out_num=%d\n\n", pdvobjpriv->nr_endpoint, pdvobjpriv->RtNumInPipes, pdvobjpriv->RtNumOutPipes);
 
 	if (pusbd->speed == USB_SPEED_HIGH) {
-		pdvobjpriv->ishighspeed = _TRUE;
+		pdvobjpriv->ishighspeed = true;
 		DBG_871X("USB_SPEED_HIGH\n");
 	} else {
-		pdvobjpriv->ishighspeed = _FALSE;
+		pdvobjpriv->ishighspeed = false;
 		DBG_871X("NON USB_SPEED_HIGH\n");
 	}
 
@@ -477,7 +477,7 @@ _func_enter_;
 	if (dvobj) {
 		//Modify condition for 92DU DMDP 2010.11.18, by Thomas
 		/*if ((dvobj->NumInterfaces == 1)
-			|| ((dvobj->InterfaceNumber == 1) && (dvobj->DualMacMode == _TRUE))) {
+			|| ((dvobj->InterfaceNumber == 1) && (dvobj->DualMacMode == true))) {
 			if (interface_to_usbdev(usb_intf)->state != USB_STATE_NOTATTACHED) {
 				//If we didn't unplug usb dongle and remove/insert modlue, driver fails on sitesurvey for the first time when device is up .
 				//Reset usb port for sitesurvey fail issue. 2009.8.13, by Thomas
@@ -520,11 +520,11 @@ static void usb_intf_stop(_adapter *pada
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+usb_intf_stop\n"));
 
 	//disabel_hw_interrupt
-	if(padapter->bSurpriseRemoved == _FALSE)
+	if(padapter->bSurpriseRemoved == false)
 	{
 		//device still exists, so driver can do i/o operation
 		//TODO:
-		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("SurpriseRemoved==_FALSE\n"));
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("SurpriseRemoved==false\n"));
 	}
 
 	//cancel in irp
@@ -545,11 +545,11 @@ static void rtw_dev_unload(_adapter *pad
 	u8 val8;
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_dev_unload\n"));
 
-	if(padapter->bup == _TRUE)
+	if(padapter->bup == true)
 	{
 		DBG_871X("===> rtw_dev_unload\n");
 
-		padapter->bDriverStopped = _TRUE;
+		padapter->bDriverStopped = true;
 		#ifdef CONFIG_XMIT_ACK
 		if (padapter->xmitpriv.ack_tx)
 			rtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_DRV_STOP);
@@ -567,29 +567,29 @@ static void rtw_dev_unload(_adapter *pad
 
 
 		//s5.
-		if(padapter->bSurpriseRemoved == _FALSE)
+		if(padapter->bSurpriseRemoved == false)
 		{
 			//DBG_871X("r871x_dev_unload()->rtl871x_hal_deinit()\n");
 #ifdef CONFIG_WOWLAN
-			if((padapter->pwrctrlpriv.bSupportRemoteWakeup==_TRUE)&&(padapter->pwrctrlpriv.wowlan_mode==_TRUE)){
-				DBG_871X("%s bSupportWakeOnWlan==_TRUE  do not run rtw_hal_deinit()\n",__FUNCTION__);
+			if((padapter->pwrctrlpriv.bSupportRemoteWakeup==true)&&(padapter->pwrctrlpriv.wowlan_mode==true)){
+				DBG_871X("%s bSupportWakeOnWlan==true  do not run rtw_hal_deinit()\n",__FUNCTION__);
 			}
 			else
 #endif //CONFIG_WOWLAN
 			{
 				rtw_hal_deinit(padapter);
 			}
-			padapter->bSurpriseRemoved = _TRUE;
+			padapter->bSurpriseRemoved = true;
 		}
 
-		padapter->bup = _FALSE;
+		padapter->bup = false;
 #ifdef CONFIG_WOWLAN
-		padapter->hw_init_completed=_FALSE;
+		padapter->hw_init_completed=false;
 #endif //CONFIG_WOWLAN
 	}
 	else
 	{
-		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("r871x_dev_unload():padapter->bup == _FALSE\n" ));
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("r871x_dev_unload():padapter->bup == false\n" ));
 	}
 
 	DBG_871X("<=== rtw_dev_unload\n");
@@ -645,8 +645,8 @@ int rtw_hw_suspend(_adapter *padapter )
 
 		DBG_871X("==> rtw_hw_suspend\n");
 		_enter_pwrlock(&pwrpriv->lock);
-		pwrpriv->bips_processing = _TRUE;
-		//padapter->net_closed = _TRUE;
+		pwrpriv->bips_processing = true;
+		//padapter->net_closed = true;
 		//s1.
 		if(pnetdev)
 		{
@@ -655,7 +655,7 @@ int rtw_hw_suspend(_adapter *padapter )
 		}
 
 		//s2.
-		rtw_disassoc_cmd(padapter, 500, _FALSE);
+		rtw_disassoc_cmd(padapter, 500, false);
 
 		//s2-2.  indicate disconnect to os
 		//rtw_indicate_disconnect(padapter);
@@ -681,12 +681,12 @@ int rtw_hw_suspend(_adapter *padapter )
 		rtw_free_assoc_resources(padapter, 1);
 
 		//s2-4.
-		rtw_free_network_queue(padapter,_TRUE);
+		rtw_free_network_queue(padapter,true);
 		#ifdef CONFIG_IPS
 		rtw_ips_dev_unload(padapter);
 		#endif
 		pwrpriv->rf_pwrstate = rf_off;
-		pwrpriv->bips_processing = _FALSE;
+		pwrpriv->bips_processing = false;
 
 		_exit_pwrlock(&pwrpriv->lock);
 	}
@@ -714,10 +714,10 @@ int rtw_hw_resume(_adapter *padapter)
 	{
 		DBG_871X("==> rtw_hw_resume\n");
 		_enter_pwrlock(&pwrpriv->lock);
-		pwrpriv->bips_processing = _TRUE;
+		pwrpriv->bips_processing = true;
 		rtw_reset_drv_sw(padapter);
 
-		if(pm_netdev_open(pnetdev,_FALSE) != 0)
+		if(pm_netdev_open(pnetdev,false) != 0)
 		{
 			_exit_pwrlock(&pwrpriv->lock);
 			goto error_exit;
@@ -731,11 +731,11 @@ int rtw_hw_resume(_adapter *padapter)
 		else
 			netif_wake_queue(pnetdev);
 
-		pwrpriv->bkeepfwalive = _FALSE;
-		pwrpriv->brfoffbyhw = _FALSE;
+		pwrpriv->bkeepfwalive = false;
+		pwrpriv->brfoffbyhw = false;
 
 		pwrpriv->rf_pwrstate = rf_on;
-		pwrpriv->bips_processing = _FALSE;
+		pwrpriv->bips_processing = false;
 
 		_exit_pwrlock(&pwrpriv->lock);
 	}
@@ -784,19 +784,19 @@ static int rtw_suspend(struct usb_interf
 		// The FW command register update must after MAC and FW init ready.
 		if((padapter->bFWReady) && ( padapter->pwrctrlpriv.bHWPwrPindetect ) && (padapter->registrypriv.usbss_enable ))
 		{
-			u8 bOpen = _TRUE;
+			u8 bOpen = true;
 			rtw_interface_ps_func(padapter,HAL_USB_SELECT_SUSPEND,&bOpen);
-			//rtl8192c_set_FwSelectSuspend_cmd(padapter,_TRUE ,500);//note fw to support hw power down ping detect
+			//rtl8192c_set_FwSelectSuspend_cmd(padapter,true ,500);//note fw to support hw power down ping detect
 		}
 	#endif
 	#endif
 	}
-	pwrpriv->bInSuspend = _TRUE;
+	pwrpriv->bInSuspend = true;
 	rtw_cancel_all_timer(padapter);
 	LeaveAllPowerSaveMode(padapter);
 
 	_enter_pwrlock(&pwrpriv->lock);
-	//padapter->net_closed = _TRUE;
+	//padapter->net_closed = true;
 	//s1.
 	if(pnetdev)
 	{
@@ -804,7 +804,7 @@ static int rtw_suspend(struct usb_interf
 		rtw_netif_stop_queue(pnetdev);
 	}
 #ifdef CONFIG_WOWLAN
-	if(padapter->pwrctrlpriv.bSupportRemoteWakeup==_TRUE&&padapter->pwrctrlpriv.wowlan_mode==_TRUE){
+	if(padapter->pwrctrlpriv.bSupportRemoteWakeup==true&&padapter->pwrctrlpriv.wowlan_mode==true){
 		u8 ps_mode=PS_MODE_MIN;
 		//set H2C command
 		poidparam.subcode=WOWLAN_ENABLE;
@@ -816,7 +816,7 @@ static int rtw_suspend(struct usb_interf
 #endif //CONFIG_WOWLAN
 	{
 		//s2.
-		rtw_disassoc_cmd(padapter, 0, _FALSE);
+		rtw_disassoc_cmd(padapter, 0, false);
 	}
 
 #ifdef CONFIG_LAYER2_ROAMING_RESUME
@@ -839,12 +839,12 @@ static int rtw_suspend(struct usb_interf
 	if(!pwrpriv->bInternalAutoSuspend )
 #endif
 	//s2-4.
-	rtw_free_network_queue(padapter, _TRUE);
+	rtw_free_network_queue(padapter, true);
 
 	rtw_dev_unload(padapter);
 #ifdef CONFIG_AUTOSUSPEND
 	pwrpriv->rf_pwrstate = rf_off;
-	pwrpriv->bips_processing = _FALSE;
+	pwrpriv->bips_processing = false;
 #endif
 	_exit_pwrlock(&pwrpriv->lock);
 
@@ -882,7 +882,7 @@ static int rtw_resume(struct usb_interfa
 			#endif /* CONFIG_WOWLAN */
 		) {
 			/* jeff: bypass resume here, do in late_resume */
-			rtw_set_do_late_resume(pwrpriv, _TRUE);
+			rtw_set_do_late_resume(pwrpriv, true);
 		} else {
 			ret = rtw_resume_process(padapter);
 		}
@@ -912,10 +912,10 @@ int rtw_resume_process(_adapter *padapte
 
 	_enter_pwrlock(&pwrpriv->lock);
 	rtw_reset_drv_sw(padapter);
-	pwrpriv->bkeepfwalive = _FALSE;
+	pwrpriv->bkeepfwalive = false;
 
 	DBG_871X("bkeepfwalive(%x)\n",pwrpriv->bkeepfwalive);
-	if(pm_netdev_open(pnetdev,_TRUE) != 0)
+	if(pm_netdev_open(pnetdev,true) != 0)
 		goto exit;
 
 	netif_device_attach(pnetdev);
@@ -929,15 +929,15 @@ int rtw_resume_process(_adapter *padapte
 			// The FW command register update must after MAC and FW init ready.
 		if((padapter->bFWReady) && ( padapter->pwrctrlpriv.bHWPwrPindetect ) && (padapter->registrypriv.usbss_enable ))
 		{
-			//rtl8192c_set_FwSelectSuspend_cmd(padapter,_FALSE ,500);//note fw to support hw power down ping detect
-			u8 bOpen = _FALSE;
+			//rtl8192c_set_FwSelectSuspend_cmd(padapter,false ,500);//note fw to support hw power down ping detect
+			u8 bOpen = false;
 			rtw_interface_ps_func(padapter,HAL_USB_SELECT_SUSPEND,&bOpen);
 		}
 		#endif
 		#endif
 
-		pwrpriv->bInternalAutoSuspend = _FALSE;
-		pwrpriv->brfoffbyhw = _FALSE;
+		pwrpriv->bInternalAutoSuspend = false;
+		pwrpriv->brfoffbyhw = false;
 		{
 			DBG_871X("enc_algorithm(%x),wepkeymask(%x)\n",
 				padapter->securitypriv.dot11PrivacyAlgrthm,pwrpriv->wepkeymask);
@@ -975,7 +975,7 @@ exit:
 	rtw_unlock_suspend();
 	#endif //CONFIG_RESUME_IN_WORKQUEUE
 
-	pwrpriv->bInSuspend = _FALSE;
+	pwrpriv->bInSuspend = false;
 	DBG_871X("<===  %s return %d.............. in %dms\n", __FUNCTION__
 		, ret, rtw_get_passing_time_ms(start_time));
 
@@ -990,8 +990,8 @@ void autosuspend_enter(_adapter* padapte
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
 
-	pwrpriv->bInternalAutoSuspend = _TRUE;
-	pwrpriv->bips_processing = _TRUE;
+	pwrpriv->bInternalAutoSuspend = true;
+	pwrpriv->bips_processing = true;
 
 	DBG_871X("==>autosuspend_enter...........\n");
 
@@ -1032,7 +1032,7 @@ int autoresume_enter(_adapter* padapter)
 
 	if(rf_off == pwrpriv->rf_pwrstate )
 	{
-		pwrpriv->ps_flag = _FALSE;
+		pwrpriv->ps_flag = false;
 		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,33))
 			if (usb_autopm_get_interface(dvobj->pusbintf) < 0)
 			{
@@ -1072,11 +1072,11 @@ _adapter *rtw_usb_if1_init(struct dvobj_
 	padapter->dvobj = dvobj;
 	dvobj->if1 = padapter;
 
-	padapter->bDriverStopped=_TRUE;
+	padapter->bDriverStopped=true;
 
 #if defined(CONFIG_CONCURRENT_MODE) || defined(CONFIG_DUALMAC_CONCURRENT)
 	//set adapter_type/iface type for primary padapter
-	padapter->isprimary = _TRUE;
+	padapter->isprimary = true;
 	padapter->adapter_type = PRIMARY_ADAPTER;
 	padapter->iface_id = IFACE_ID0;
 	#ifndef CONFIG_HWPORT_SWAP
@@ -1239,7 +1239,7 @@ static void rtw_usb_if1_deinit(_adapter
 	struct mlme_priv *pmlmepriv= &if1->mlmepriv;
 
 	if(check_fwstate(pmlmepriv, _FW_LINKED))
-		rtw_disassoc_cmd(if1, 0, _FALSE);
+		rtw_disassoc_cmd(if1, 0, false);
 
 
 #ifdef CONFIG_AP_MODE
@@ -1259,7 +1259,7 @@ static void rtw_usb_if1_deinit(_adapter
 
 	rtw_cancel_all_timer(if1);
 #ifdef CONFIG_WOWLAN
-	if1->pwrctrlpriv.wowlan_mode=_FALSE;
+	if1->pwrctrlpriv.wowlan_mode=false;
 #endif //CONFIG_WOWLAN
 	rtw_dev_unload(if1);
 
@@ -1361,15 +1361,15 @@ _func_exit_;
 	DBG_871X("+rtw_dev_remove\n");
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+dev_remove()\n"));
 
-	if(usb_drv->drv_registered == _TRUE)
+	if(usb_drv->drv_registered == true)
 	{
-		//DBG_871X("r871xu_dev_remove():padapter->bSurpriseRemoved == _TRUE\n");
-		padapter->bSurpriseRemoved = _TRUE;
+		//DBG_871X("r871xu_dev_remove():padapter->bSurpriseRemoved == true\n");
+		padapter->bSurpriseRemoved = true;
 	}
 	/*else
 	{
 		//DBG_871X("r871xu_dev_remove():module removed\n");
-		padapter->hw_init_completed = _FALSE;
+		padapter->hw_init_completed = false;
 	}*/
 
 #if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
@@ -1423,7 +1423,7 @@ static int __init rtw_drv_entry(void)
 
 	rtw_suspend_lock_init();
 
-	usb_drv->drv_registered = _TRUE;
+	usb_drv->drv_registered = true;
 	return usb_register(&usb_drv->usbdrv);
 }
 
@@ -1434,7 +1434,7 @@ static void __exit rtw_drv_halt(void)
 
 	rtw_suspend_lock_uninit();
 
-	usb_drv->drv_registered = _FALSE;
+	usb_drv->drv_registered = false;
 	usb_deregister(&usb_drv->usbdrv);
 
 	DBG_871X("-rtw_drv_halt\n");
--- a/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
@@ -289,11 +289,11 @@ void usb_read_port_cancel(struct intf_hd
 
 	DBG_871X("%s\n", __func__);
 
-	padapter->bReadPortCancel = _TRUE;
+	padapter->bReadPortCancel = true;
 
 	for (i=0; i < NR_RECVBUFF ; i++) {
 
-		precvbuf->reuse = _TRUE;
+		precvbuf->reuse = true;
 		if (precvbuf->purb)	 {
 			//DBG_8192C("usb_read_port_cancel : usb_kill_urb \n");
 			usb_kill_urb(precvbuf->purb);
@@ -419,14 +419,14 @@ _func_enter_;
 
 		} else if (purb->status == -ESHUTDOWN) {
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: ESHUTDOWN\n"));
-			padapter->bDriverStopped=_TRUE;
+			padapter->bDriverStopped=true;
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped=TRUE\n"));
 
 			goto check_completion;
 		}
 		else
 		{
-			padapter->bSurpriseRemoved=_TRUE;
+			padapter->bSurpriseRemoved=true;
 			DBG_8192C("bSurpriseRemoved=TRUE\n");
 			//rtl8192cu_trigger_gpio_0(padapter);
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bSurpriseRemoved=TRUE\n"));
@@ -462,7 +462,7 @@ u32 usb_write_port(struct intf_hdl *pint
 	_irqL irqL;
 	unsigned int pipe;
 	int status;
-	u32 ret = _FAIL, bwritezero = _FALSE;
+	u32 ret = _FAIL, bwritezero = false;
 	PURB	purb = NULL;
 	_adapter *padapter = (_adapter *)pintfhdl->padapter;
 	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);
@@ -524,7 +524,7 @@ _func_enter_;
 		if(cnt> 0 && cnt%512 == 0)
 		{
 			//DBG_8192C("ishighspeed, cnt=%d\n", cnt);
-			bwritezero = _TRUE;
+			bwritezero = true;
 		}
 	}
 	else
@@ -532,7 +532,7 @@ _func_enter_;
 		if(cnt > 0 && cnt%64 == 0)
 		{
 			//DBG_8192C("cnt=%d\n", cnt);
-			bwritezero = _TRUE;
+			bwritezero = true;
 		}
 	}
 #endif
@@ -542,7 +542,7 @@ _func_enter_;
 
 #ifdef CONFIG_REDUCE_USB_TX_INT
 	if ( (pxmitpriv->free_xmitbuf_cnt%NR_XMITBUFF == 0)
-		|| (pxmitbuf->ext_tag == _TRUE) )
+		|| (pxmitbuf->ext_tag == true) )
 	{
 		purb->transfer_flags  &=  (~URB_NO_INTERRUPT);
 	} else {
@@ -586,7 +586,7 @@ _func_enter_;
 
 		switch (status) {
 		case -ENODEV:
-			padapter->bDriverStopped=_TRUE;
+			padapter->bDriverStopped=true;
 			break;
 		default:
 			break;
@@ -599,7 +599,7 @@ _func_enter_;
 //   Commented by Albert 2009/10/13
 //   We add the URB_ZERO_PACKET flag to urb so that the host will send the zero packet automatically.
 /*
-	if(bwritezero == _TRUE)
+	if(bwritezero == true)
 	{
 		usb_bulkout_zero(pintfhdl, addr);
 	}
@@ -623,7 +623,7 @@ void usb_write_port_cancel(struct intf_h
 
 	DBG_871X("%s \n", __func__);
 
-	padapter->bWritePortCancel = _TRUE;
+	padapter->bWritePortCancel = true;
 
 	for (i=0; i<NR_XMITBUFF; i++) {
 		for (j=0; j<8; j++) {
--- a/drivers/staging/rtl8192du/os_dep/xmit_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/xmit_linux.c
@@ -77,12 +77,12 @@ _func_enter_;
 
 	if (pfile->pkt_len == 0) {
 _func_exit_;
-		return _TRUE;
+		return true;
 	}
 
 _func_exit_;
 
-	return _FALSE;
+	return false;
 }
 
 void rtw_set_tx_chksum_offload(_pkt *pkt, struct pkt_attrib *pattrib)
@@ -258,7 +258,7 @@ int rtw_mlcst2unicst(_adapter *padapter,
 	plist = get_next(phead);
 
 	//free sta asoc_queue
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 
@@ -285,13 +285,13 @@ int rtw_mlcst2unicst(_adapter *padapter,
 
 			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 			//dev_kfree_skb_any(skb);
-			return _FALSE;	// Caller shall tx this multicast frame via normal way.
+			return false;	// Caller shall tx this multicast frame via normal way.
 		}
 	}
 
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	dev_kfree_skb_any(skb);
-	return _TRUE;
+	return true;
 }
 
 int rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev)
@@ -309,7 +309,7 @@ _func_enter_;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("+xmit_enry\n"));
 
-	if (rtw_if_up(padapter) == _FALSE) {
+	if (rtw_if_up(padapter) == false) {
 		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit_entry: rtw_if_up fail\n"));
 		#ifdef DBG_TX_DROP_FRAME
 		DBG_871X("DBG_TX_DROP_FRAME %s if_up fail\n", __FUNCTION__);
@@ -328,7 +328,7 @@ _func_enter_;
 #endif
 
 	if ( !rtw_mc2u_disable
-		&& check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE
+		&& check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
 		&& ( IP_MCAST_MAC(pkt->data)
 			|| ICMPV6_MCAST_MAC(pkt->data) )
 		&& (padapter->registrypriv.wifi_spec == 0)
@@ -336,7 +336,7 @@ _func_enter_;
 	{
 		if ( pxmitpriv->free_xmitframe_cnt > (NR_XMITFRAME/4) ) {
 			res = rtw_mlcst2unicst(padapter, pkt);
-			if (res == _TRUE) {
+			if (res == true) {
 				goto exit;
 			}
 		} else {

From 4cb6c900654f127592da8342202693fece8e8fa7 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Wed, 19 Feb 2014 21:10:35 -0600
Subject: [PATCH 213/390] rtl8192du: Replace wrappers around spin_{lock,unlock}

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_ap.c           |  4 +---
 core/rtw_cmd.c          |  7 ++-----
 core/rtw_mlme.c         |  5 +----
 core/rtw_recv.c         | 22 +++++++++-------------
 core/rtw_sta_mgt.c      | 37 ++++---------------------------------
 core/rtw_tdls.c         |  7 ++-----
 core/rtw_xmit.c         | 18 ++----------------
 hal/rtl8192du_recv.c    |  2 +-
 include/osdep_service.h |  6 ------
 os_dep/ioctl_cfg80211.c |  2 +-
 os_dep/os_intfs.c       |  6 +-----
 os_dep/osdep_service.c  | 31 +------------------------------
 12 files changed, 25 insertions(+), 122 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_ap.c
+++ b/drivers/staging/rtl8192du/core/rtw_ap.c
@@ -29,7 +29,7 @@ void init_mlme_ap_info(struct rtw_adapte
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
 
-	_rtw_spinlock_init(&pmlmepriv->bcn_update_lock);
+	spin_lock_init(&pmlmepriv->bcn_update_lock);
 
 	/* for ACL */
 	_rtw_init_queue(&pacl_list->acl_node_q);
@@ -60,8 +60,6 @@ void free_mlme_ap_info(struct rtw_adapte
 	spin_lock_bh(&(pstapriv->sta_hash_lock));
 	rtw_free_stainfo(padapter, psta);
 	spin_unlock_bh(&(pstapriv->sta_hash_lock));
-
-	_rtw_spinlock_free(&pmlmepriv->bcn_update_lock);
 }
 
 static void update_BCNTIM(struct rtw_adapter *padapter)
--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -143,15 +143,12 @@ void _rtw_free_evt_priv(struct evt_priv
 
 void _rtw_free_cmd_priv(struct cmd_priv *pcmdpriv)
 {
-
 	if (pcmdpriv) {
-		_rtw_spinlock_free(&(pcmdpriv->cmd_queue.lock));
 		_rtw_free_sema(&(pcmdpriv->cmd_queue_sema));
 		_rtw_free_sema(&(pcmdpriv->terminate_cmdthread_sema));
 		kfree(pcmdpriv->cmd_allocated_buf);
 		kfree(pcmdpriv->rsp_allocated_buf);
 	}
-
 }
 
 /*
@@ -1632,10 +1629,10 @@ u8 rtw_tdls_cmd(struct rtw_adapter *pada
 		goto exit;
 	}
 
-	_rtw_spinlock(&(padapter->tdlsinfo.cmd_lock));
+	spin_lock(&(padapter->tdlsinfo.cmd_lock));
 	memcpy(TDLSoption->addr, addr, 6);
 	TDLSoption->option = option;
-	_rtw_spinunlock(&(padapter->tdlsinfo.cmd_lock));
+	spin_unlock(&(padapter->tdlsinfo.cmd_lock));
 	init_h2fwcmd_w_parm_no_rsp(pcmdobj, TDLSoption, GEN_CMD_CODE(_TDLS));
 	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
 
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -57,7 +57,7 @@ int _rtw_init_mlme_priv(struct rtw_adapt
 	pmlmepriv->cur_network.network.InfrastructureMode = NDIS802_11AUTOUNK;
 	pmlmepriv->scan_mode = SCAN_ACTIVE;	/*  1: active, 0: pasive. Maybe someday we should rename this varable to "active_mode" (Jeff) */
 
-	_rtw_spinlock_init(&(pmlmepriv->lock));
+	spin_lock_init(&(pmlmepriv->lock));
 	_rtw_init_queue(&(pmlmepriv->free_bss_pool));
 	_rtw_init_queue(&(pmlmepriv->scanned_queue));
 
@@ -97,9 +97,6 @@ exit:
 
 static void rtw_mfree_mlme_priv_lock(struct mlme_priv *pmlmepriv)
 {
-	_rtw_spinlock_free(&pmlmepriv->lock);
-	_rtw_spinlock_free(&(pmlmepriv->free_bss_pool.lock));
-	_rtw_spinlock_free(&(pmlmepriv->scanned_queue.lock));
 }
 
 static void rtw_free_mlme_ie_data(u8 **ppie, u32 *plen)
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -34,7 +34,7 @@ void _rtw_init_sta_recv_priv(struct sta_
 
 	memset((u8 *)psta_recvpriv, 0, sizeof(struct sta_recv_priv));
 
-	_rtw_spinlock_init(&psta_recvpriv->lock);
+	spin_lock_init(&psta_recvpriv->lock);
 
 	/* for (i=0; i<MAX_RX_NUMBLKS; i++) */
 	/*      _rtw_init_queue(&psta_recvpriv->blk_strms[i]); */
@@ -52,7 +52,7 @@ int _rtw_init_recv_priv(struct recv_priv
 
 	int res = _SUCCESS;
 
-	_rtw_spinlock_init(&precvpriv->lock);
+	spin_lock_init(&precvpriv->lock);
 
 	_rtw_init_queue(&precvpriv->free_recv_queue);
 	_rtw_init_queue(&precvpriv->recv_pending_queue);
@@ -110,10 +110,6 @@ exit:
 
 static void rtw_mfree_recv_priv_lock(struct recv_priv *precvpriv)
 {
-	_rtw_spinlock_free(&precvpriv->lock);
-	_rtw_spinlock_free(&precvpriv->free_recv_queue.lock);
-	_rtw_spinlock_free(&precvpriv->recv_pending_queue.lock);
-	_rtw_spinlock_free(&precvpriv->free_recv_buf_queue.lock);
 }
 
 void _rtw_free_recv_priv(struct recv_priv *precvpriv)
@@ -262,7 +258,7 @@ void rtw_free_recvframe_queue(struct __q
 	struct recv_frame_hdr *precvframe;
 	struct list_head *plist, *phead;
 
-	_rtw_spinlock(&pframequeue->lock);
+	spin_lock(&pframequeue->lock);
 
 	phead = get_list_head(pframequeue);
 	plist = phead->next;
@@ -275,7 +271,7 @@ void rtw_free_recvframe_queue(struct __q
 		rtw_free_recvframe(precvframe, pfree_recv_queue);
 	}
 
-	_rtw_spinunlock(&pframequeue->lock);
+	spin_unlock(&pframequeue->lock);
 
 }
 
@@ -2013,10 +2009,10 @@ struct recv_frame_hdr *recvframe_chk_def
 
 			/* Then enqueue the 0~(n-1) fragment into the defrag_q */
 
-			/* _rtw_spinlock(&pdefrag_q->lock); */
+			/* spin_lock(&pdefrag_q->lock); */
 			phead = get_list_head(pdefrag_q);
 			rtw_list_insert_tail(&pfhdr->list, phead);
-			/* _rtw_spinunlock(&pdefrag_q->lock); */
+			/* spin_unlock(&pdefrag_q->lock); */
 
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
 				 ("Enqueuq: ismfrag = %d, fragnum= %d\n",
@@ -2038,10 +2034,10 @@ struct recv_frame_hdr *recvframe_chk_def
 		/* the last fragment frame */
 		/* enqueue the last fragment */
 		if (pdefrag_q != NULL) {
-			/* _rtw_spinlock(&pdefrag_q->lock); */
+			/* spin_lock(&pdefrag_q->lock); */
 			phead = get_list_head(pdefrag_q);
 			rtw_list_insert_tail(&pfhdr->list, phead);
-			/* _rtw_spinunlock(&pdefrag_q->lock); */
+			/* spin_unlock(&pdefrag_q->lock); */
 
 			/* call recvframe_defrag to defrag */
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
@@ -2336,7 +2332,7 @@ static int recv_indicatepkts_in_order(st
 	if (bforced == true) {
 		if (rtw_is_list_empty(phead)) {
 			/*  spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql); */
-			/* _rtw_spinunlock_ex(&ppending_recvframe_queue->lock); */
+			/* spin_unlock(&ppending_recvframe_queue->lock); */
 			return true;
 		}
 
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -29,7 +29,7 @@ static void _rtw_init_stainfo(struct sta
 
 	memset((u8 *)psta, 0, sizeof(struct sta_info));
 
-	 _rtw_spinlock_init(&psta->lock);
+	 spin_lock_init(&psta->lock);
 	INIT_LIST_HEAD(&psta->list);
 	INIT_LIST_HEAD(&psta->hash_list);
 
@@ -84,7 +84,7 @@ u32	_rtw_init_sta_priv(struct	sta_priv *
 
 	_rtw_init_queue(&pstapriv->free_sta_queue);
 
-	_rtw_spinlock_init(&pstapriv->sta_hash_lock);
+	spin_lock_init(&pstapriv->sta_hash_lock);
 
 	pstapriv->asoc_sta_count = 0;
 	_rtw_init_queue(&pstapriv->sleep_q);
@@ -109,8 +109,8 @@ u32	_rtw_init_sta_priv(struct	sta_priv *
 
 	INIT_LIST_HEAD(&pstapriv->asoc_list);
 	INIT_LIST_HEAD(&pstapriv->auth_list);
-	_rtw_spinlock_init(&pstapriv->asoc_list_lock);
-	_rtw_spinlock_init(&pstapriv->auth_list_lock);
+	spin_lock_init(&pstapriv->asoc_list_lock);
+	spin_lock_init(&pstapriv->auth_list_lock);
 	pstapriv->asoc_list_cnt = 0;
 	pstapriv->auth_list_cnt = 0;
 
@@ -152,33 +152,16 @@ inline struct sta_info *rtw_get_stainfo_
 
 static void _rtw_free_sta_xmit_priv_lock(struct sta_xmit_priv *psta_xmitpriv)
 {
-
-	_rtw_spinlock_free(&psta_xmitpriv->lock);
-
-	_rtw_spinlock_free(&(psta_xmitpriv->be_q.sta_pending.lock));
-	_rtw_spinlock_free(&(psta_xmitpriv->bk_q.sta_pending.lock));
-	_rtw_spinlock_free(&(psta_xmitpriv->vi_q.sta_pending.lock));
-	_rtw_spinlock_free(&(psta_xmitpriv->vo_q.sta_pending.lock));
-
 }
 
 static void _rtw_free_sta_recv_priv_lock(struct sta_recv_priv *psta_recvpriv)
 {
-
-	_rtw_spinlock_free(&psta_recvpriv->lock);
-	_rtw_spinlock_free(&(psta_recvpriv->defrag_q.lock));
-
 }
 
 static void rtw_mfree_stainfo(struct sta_info *psta)
 {
-
-	if (&psta->lock != NULL)
-		_rtw_spinlock_free(&psta->lock);
-
 	_rtw_free_sta_xmit_priv_lock(&psta->sta_xmitpriv);
 	_rtw_free_sta_recv_priv_lock(&psta->sta_recvpriv);
-
 }
 
 /*  this function is used to free the memory of lock || sema for all stainfos */
@@ -210,18 +193,6 @@ static void rtw_mfree_sta_priv_lock(stru
 #endif
 
 	 rtw_mfree_all_stainfo(pstapriv); /* be done before free sta_hash_lock */
-
-	_rtw_spinlock_free(&pstapriv->free_sta_queue.lock);
-
-	_rtw_spinlock_free(&pstapriv->sta_hash_lock);
-	_rtw_spinlock_free(&pstapriv->wakeup_q.lock);
-	_rtw_spinlock_free(&pstapriv->sleep_q.lock);
-
-#ifdef CONFIG_92D_AP_MODE
-	_rtw_spinlock_free(&pstapriv->asoc_list_lock);
-	_rtw_spinlock_free(&pstapriv->auth_list_lock);
-	_rtw_spinlock_free(&pacl_list->acl_node_q.lock);
-#endif
 }
 
 u32	_rtw_free_sta_priv(struct	sta_priv *pstapriv)
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ b/drivers/staging/rtl8192du/core/rtw_tdls.c
@@ -54,17 +54,14 @@ int rtw_init_tdls_info(_adapter *padapte
 	ptdlsinfo->enable = 1;
 	rtw_reset_tdls_info(padapter);
 
-	_rtw_spinlock_init(&ptdlsinfo->cmd_lock);
-	_rtw_spinlock_init(&ptdlsinfo->hdl_lock);
+	spin_lock_init(&ptdlsinfo->cmd_lock);
+	spin_lock_init(&ptdlsinfo->hdl_lock);
 
 	return res;
 }
 
 void rtw_free_tdls_info(struct tdls_info *ptdlsinfo)
 {
-	_rtw_spinlock_free(&ptdlsinfo->cmd_lock);
-	_rtw_spinlock_free(&ptdlsinfo->hdl_lock);
-
 	memset(ptdlsinfo, 0, sizeof(struct tdls_info));
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -42,7 +42,7 @@ void	_rtw_init_sta_xmit_priv(struct sta_
 
 	memset((unsigned char *)psta_xmitpriv, 0, sizeof(struct sta_xmit_priv));
 
-	_rtw_spinlock_init(&psta_xmitpriv->lock);
+	spin_lock_init(&psta_xmitpriv->lock);
 
 	/* for (i = 0 ; i < MAX_NUMBLKS; i++) */
 	/*	_init_txservq(&(psta_xmitpriv->blk_q[i])); */
@@ -66,7 +66,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv
 	/*  We don't need to memset padapter->XXX to zero, because adapter is allocated by vzalloc(). */
 	/* memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv)); */
 
-	_rtw_spinlock_init(&pxmitpriv->lock);
+	spin_lock_init(&pxmitpriv->lock);
 	_rtw_init_sema(&pxmitpriv->xmit_sema, 0);
 	_rtw_init_sema(&pxmitpriv->terminate_xmitthread_sema, 0);
 
@@ -219,19 +219,8 @@ exit:
 
 static void  rtw_mfree_xmit_priv_lock(struct xmit_priv *pxmitpriv)
 {
-	_rtw_spinlock_free(&pxmitpriv->lock);
 	_rtw_free_sema(&pxmitpriv->xmit_sema);
 	_rtw_free_sema(&pxmitpriv->terminate_xmitthread_sema);
-
-	_rtw_spinlock_free(&pxmitpriv->be_pending.lock);
-	_rtw_spinlock_free(&pxmitpriv->bk_pending.lock);
-	_rtw_spinlock_free(&pxmitpriv->vi_pending.lock);
-	_rtw_spinlock_free(&pxmitpriv->vo_pending.lock);
-	_rtw_spinlock_free(&pxmitpriv->bm_pending.lock);
-
-	_rtw_spinlock_free(&pxmitpriv->free_xmit_queue.lock);
-	_rtw_spinlock_free(&pxmitpriv->free_xmitbuf_queue.lock);
-	_rtw_spinlock_free(&pxmitpriv->pending_xmitbuf_queue.lock);
 }
 
 void _rtw_free_xmit_priv(struct xmit_priv *pxmitpriv)
@@ -259,9 +248,6 @@ void _rtw_free_xmit_priv(struct xmit_pri
 	if (pxmitpriv->pallocated_xmitbuf)
 		vfree(pxmitpriv->pallocated_xmitbuf);
 
-	/*  free xmit extension buff */
-	_rtw_spinlock_free(&pxmitpriv->free_xmit_extbuf_queue.lock);
-
 	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;
 	for (i = 0; i < NR_XMIT_EXTBUFF; i++) {
 		rtw_os_xmit_resource_free(padapter, pxmitbuf, (MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ));
--- a/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
@@ -70,7 +70,7 @@ int	rtl8192du_init_recv_priv(struct rtw_
 	{
 		INIT_LIST_HEAD(&precvbuf->list);
 
-		_rtw_spinlock_init(&precvbuf->recvbuf_lock);
+		spin_lock_init(&precvbuf->recvbuf_lock);
 
 		precvbuf->alloc_sz = MAX_RECVBUF_SZ;
 
--- a/drivers/staging/rtl8192du/include/osdep_service.h
+++ b/drivers/staging/rtl8192du/include/osdep_service.h
@@ -201,12 +201,6 @@ void	_rtw_up_sema(struct  semaphore *sem
 u32	_rtw_down_sema(struct  semaphore *sema);
 void	_rtw_mutex_init(_mutex *pmutex);
 void	_rtw_mutex_free(_mutex *pmutex);
-void	_rtw_spinlock_init(spinlock_t *plock);
-void	_rtw_spinlock_free(spinlock_t *plock);
-void	_rtw_spinlock(spinlock_t	*plock);
-void	_rtw_spinunlock(spinlock_t	*plock);
-void	_rtw_spinlock_ex(spinlock_t	*plock);
-void	_rtw_spinunlock_ex(spinlock_t	*plock);
 
 void	_rtw_init_queue(struct __queue *pqueue);
 u32	_rtw_queue_empty(struct __queue *pqueue);
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -4581,7 +4581,7 @@ int rtw_wdev_alloc(_adapter *padapter, s
 	pwdev_priv->ifname_mon[0] = '\0';
 	pwdev_priv->padapter = padapter;
 	pwdev_priv->scan_request = NULL;
-	_rtw_spinlock_init(&pwdev_priv->scan_req_lock);
+	spin_lock_init(&pwdev_priv->scan_req_lock);
 
 	pwdev_priv->p2p_enabled = false;
 	pwdev_priv->provdisc_req_issued = false;
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -1217,7 +1217,7 @@ u8 rtw_init_drv_sw(struct rtw_adapter *p
 #endif /* CONFIG_INTEL_WIDI */
 
 #ifdef CONFIG_BR_EXT
-	_rtw_spinlock_init(&padapter->br_ext_lock);
+	spin_lock_init(&padapter->br_ext_lock);
 #endif	/*  CONFIG_BR_EXT */
 
 exit:
@@ -1287,10 +1287,6 @@ u8 rtw_free_drv_sw(struct rtw_adapter *p
 	}
 	#endif
 
-#ifdef CONFIG_BR_EXT
-	_rtw_spinlock_free(&padapter->br_ext_lock);
-#endif	/*  CONFIG_BR_EXT */
-
 #ifdef CONFIG_INTEL_WIDI
 	rtw_free_intel_widi(padapter);
 #endif /* CONFIG_INTEL_WIDI */
--- a/drivers/staging/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8192du/os_dep/osdep_service.c
@@ -131,41 +131,12 @@ void	_rtw_mutex_free(_mutex *pmutex)
 	mutex_destroy(pmutex);
 }
 
-void	_rtw_spinlock_init(spinlock_t *plock)
-{
-	spin_lock_init(plock);
-}
-
-void	_rtw_spinlock_free(spinlock_t *plock)
-{
-}
-
-inline void	_rtw_spinlock(spinlock_t *plock)
-{
-	spin_lock(plock);
-}
-
-inline void	_rtw_spinunlock(spinlock_t *plock)
-{
-	spin_unlock(plock);
-}
-
-inline void	_rtw_spinlock_ex(spinlock_t *plock)
-{
-	spin_lock(plock);
-}
-
-inline void	_rtw_spinunlock_ex(spinlock_t *plock)
-{
-	spin_unlock(plock);
-}
-
 void	_rtw_init_queue(struct __queue *pqueue)
 {
 
 	INIT_LIST_HEAD(&(pqueue->queue));
 
-	_rtw_spinlock_init(&(pqueue->lock));
+	spin_lock_init(&(pqueue->lock));
 }
 
 u32	  _rtw_queue_empty(struct __queue *pqueue)

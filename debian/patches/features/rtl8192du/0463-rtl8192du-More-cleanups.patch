From 64456fc402ec94b2cd03b87deec3d0eb276d88f2 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sun, 6 Apr 2014 11:13:14 -0500
Subject: [PATCH 463/470] rtl8192du: More cleanups

When the Makefile was revised to use the same options as a kernel build,
a number of warnings appeared.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 Makefile                |  10 +-
 core/rtw_ap.c           |  22 +-
 core/rtw_cmd.c          |  13 +-
 core/rtw_efuse.c        |  90 -----
 core/rtw_ieee80211.c    |   4 +-
 core/rtw_ioctl_set.c    |   3 -
 core/rtw_mlme.c         |  57 +---
 core/rtw_mlme_ext.c     | 212 ++----------
 core/rtw_p2p.c          | 100 ------
 core/rtw_pwrctrl.c      |  12 -
 core/rtw_recv.c         |  19 +-
 core/rtw_security.c     | 521 -----------------------------
 core/rtw_sta_mgt.c      |   4 -
 core/rtw_wlan_util.c    |  26 +-
 core/rtw_xmit.c         |   2 -
 hal/rtl8192d_cmd.c      |  41 +--
 hal/rtl8192d_dm.c       |  30 --
 hal/rtl8192d_hal_init.c |   1 -
 hal/rtl8192d_phycfg.c   | 682 +++++++-------------------------------
 hal/rtl8192d_rf6052.c   |   3 -
 hal/rtl8192d_rxdesc.c   |  13 -
 hal/rtl8192du_led.c     | 118 -------
 hal/usb_halinit.c       | 862 ------------------------------------------------
 hal/usb_ops_linux.c     | 119 -------
 include/autoconf.h      |   2 +-
 include/drv_types.h     |   2 +-
 include/rtl8192d_hal.h  |  99 ------
 include/rtw_recv.h      |  18 -
 include/rtw_sreset.h    |  18 +-
 os_dep/ioctl_cfg80211.c | 361 ++++----------------
 os_dep/ioctl_linux.c    | 480 +++++----------------------
 os_dep/os_intfs.c       |   4 -
 os_dep/recv_linux.c     |   9 +-
 os_dep/usb_intf.c       |  15 +-
 os_dep/usb_ops_linux.c  | 129 ++------
 os_dep/xmit_linux.c     |  33 +-
 36 files changed, 354 insertions(+), 3780 deletions(-)

--- a/drivers/staging/rtl8192du/Makefile
+++ b/drivers/staging/rtl8192du/Makefile
@@ -1,14 +1,6 @@
 EXTRA_CFLAGS += $(USER_EXTRA_CFLAGS)
-EXTRA_CFLAGS += -O1
 
-EXTRA_CFLAGS += -Wno-unused-variable
-EXTRA_CFLAGS += -Wno-unused-value
-EXTRA_CFLAGS += -Wno-unused-label
-EXTRA_CFLAGS += -Wno-unused-parameter
-EXTRA_CFLAGS += -Wno-unused-function
-EXTRA_CFLAGS += -Wno-unused
-
-EXTRA_CFLAGS += -Wno-uninitialized
+EXTRA_CFLAGS += -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
 
 EXTRA_CFLAGS += -I$(src)/include
 
--- a/drivers/staging/rtl8192du/core/rtw_ap.c
+++ b/drivers/staging/rtl8192du/core/rtw_ap.c
@@ -24,7 +24,6 @@
 
 void init_mlme_ap_info(struct rtw_adapter *padapter)
 {
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
@@ -179,8 +178,8 @@ void rtw_add_bcn_ie(struct rtw_adapter *
 	struct ndis_802_11_variable_ies *pIE;
 	u8 bmatch = false;
 	u8 *pie = pnetwork->IEs;
-	u8 *p, *dst_ie, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;
-	u32 i, offset, ielen, ie_offset, remainder_ielen = 0;
+	u8 *p = NULL, *dst_ie = NULL, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;
+	u32 i, offset, ielen = 0, ie_offset, remainder_ielen = 0;
 
 	for (i = sizeof(struct ndis_802_11_fixed_ies);
 	     i < pnetwork->IELength;) {
@@ -241,7 +240,7 @@ void rtw_add_bcn_ie(struct rtw_adapter *
 
 void rtw_remove_bcn_ie(struct rtw_adapter *padapter, struct wlan_bssid_ex *pnetwork, u8 index)
 {
-	u8 *p, *dst_ie, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;
+	u8 *p, *dst_ie = NULL, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;
 	uint offset, ielen, ie_offset, remainder_ielen = 0;
 	u8	*pie = pnetwork->IEs;
 
@@ -295,7 +294,7 @@ static u8 chk_sta_is_alive(struct sta_in
 void	expire_timeout_chk(struct rtw_adapter *padapter)
 {
 	struct list_head *phead, *plist;
-	u8 updated;
+	u8 updated = 0;
 	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	u8 chk_alive_num = 0;
@@ -717,7 +716,6 @@ static void update_hw_ht_param(struct rt
 {
 	unsigned char		max_AMPDU_len;
 	unsigned char		min_MPDU_spacing;
-	struct registry_priv	 *pregpriv = &padapter->registrypriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
@@ -764,7 +762,6 @@ static void start_bss_network(struct rtw
 	u32	acparm;
 	int	ie_len;
 	u8 cbw40_enable = 0;
-	u8 change_band = false;
 
 	bcn_interval = (u16)pnetwork->Configuration.BeaconPeriod;
 	cur_channel = pnetwork->Configuration.DSConfig;
@@ -1058,13 +1055,11 @@ int rtw_check_beacon_data(struct rtw_ada
 	u8 channel, network_type, supportrate[NDIS_802_11_LENGTH_RATES_EX];
 	int supportratenum = 0;
 	u8 OUI1[] = {0x00, 0x50, 0xf2, 0x01};
-	u8 wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};
 	u8 WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};
 	struct registry_priv *pregistrypriv = &padapter->registrypriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct wlan_bssid_ex *pbss_network = &pmlmepriv->cur_network.network;
-	struct sta_priv *pstapriv = &padapter->stapriv;
 	u8 *ie = pbss_network->IEs;
 
 	/* SSID
@@ -1410,7 +1405,7 @@ int rtw_acl_add_sta(struct rtw_adapter *
 int rtw_acl_remove_sta(struct rtw_adapter *padapter, u8 *addr)
 {
 	struct list_head *plist, *phead;
-	int i, ret = 0;
+	int ret = 0;
 	struct rtw_wlan_acl_node *paclnode;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
@@ -1481,11 +1476,6 @@ static void update_bcn_erpinfo_ie(struct
 	}
 }
 
-static void update_bcn_wmm_ie(struct rtw_adapter *padapter)
-{
-	DBG_8192D("%s\n", __func__);
-}
-
 static void update_bcn_wps_ie(struct rtw_adapter *padapter)
 {
 	u8 *pwps_ie = NULL, *pwps_ie_src, *premainder_ie;
@@ -1905,8 +1895,6 @@ u8 ap_free_sta(struct rtw_adapter *padap
 	       bool active, u16 reason)
 {
 	u8 beacon_updated = false;
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
 	if (!psta)
--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -1048,8 +1048,6 @@ u8 rtw_clearstakey_cmd(struct rtw_adapte
 	struct set_stakey_parm *psetstakey_para;
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 	struct set_stakey_rsp *psetstakey_rsp = NULL;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct sta_info *sta = (struct sta_info *)psta;
 	u8 res = 1;
 
@@ -1429,9 +1427,7 @@ u8 rtw_set_csa_cmd(struct rtw_adapter *p
 {
 	struct cmd_obj *pcmdobj;
 	struct setchannelswitch_param *setchannelswitch_param;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
-
 	u8 res = 1;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_csa_cmd\n"));
@@ -1463,14 +1459,7 @@ exit:
 
 u8 rtw_tdls_cmd(struct rtw_adapter *padapter, u8 *addr, u8 option)
 {
-	struct cmd_obj *pcmdobj;
-	struct TDLSoption_param	*TDLSoption;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
-
-	u8 res = 1;
-
-	return res;
+	return 1;
 }
 
 static void traffic_status_watchdog(struct rtw_adapter *padapter)
--- a/drivers/staging/rtl8192du/core/rtw_efuse.c
+++ b/drivers/staging/rtl8192du/core/rtw_efuse.c
@@ -587,96 +587,6 @@ static void Efuse_ReadAllMap(struct rtw_
 }
 
 /*-----------------------------------------------------------------------------
- * Function:	efuse_ShadowRead1Byte
- *			efuse_ShadowRead2Byte
- *			efuse_ShadowRead4Byte
- *
- * Overview:	Read from efuse init map by one/two/four bytes !!!!!
- *
- * Input:       NONE
- *
- * Output:      NONE
- *
- * Return:      NONE
- *
- * Revised History:
- * When			Who		Remark
- * 11/12/2008	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-static void efuse_ShadowRead1Byte(struct rtw_adapter *adapter, u16 Offset, u8 *value)
-{
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
-
-	*value = pEEPROM->efuse_eeprom_data[Offset];
-}	/*  EFUSE_ShadowRead1Byte */
-
-/* Read Two Bytes */
-static void efuse_ShadowRead2Byte(struct rtw_adapter *adapter, u16 Offset, u16 *value)
-{
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
-
-	*value = pEEPROM->efuse_eeprom_data[Offset];
-	*value |= pEEPROM->efuse_eeprom_data[Offset+1]<<8;
-}	/*  EFUSE_ShadowRead2Byte */
-
-/* Read Four Bytes */
-static void efuse_ShadowRead4Byte(struct rtw_adapter *adapter, u16 Offset, u32 *value)
-{
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
-
-	*value = pEEPROM->efuse_eeprom_data[Offset];
-	*value |= pEEPROM->efuse_eeprom_data[Offset+1]<<8;
-	*value |= pEEPROM->efuse_eeprom_data[Offset+2]<<16;
-	*value |= pEEPROM->efuse_eeprom_data[Offset+3]<<24;
-}	/*  efuse_ShadowRead4Byte */
-
-/*-----------------------------------------------------------------------------
- * Function:	efuse_ShadowWrite1Byte
- *			efuse_ShadowWrite2Byte
- *			efuse_ShadowWrite4Byte
- *
- * Overview:	Write efuse modify map by one/two/four byte.
- *
- * Input:       NONE
- *
- * Output:      NONE
- *
- * Return:      NONE
- *
- * Revised History:
- * When			Who		Remark
- * 11/12/2008	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-static void efuse_ShadowWrite1Byte(struct rtw_adapter *adapter, u16 Offset, u8 value)
-{
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
-
-	pEEPROM->efuse_eeprom_data[Offset] = value;
-}	/*  efuse_ShadowWrite1Byte */
-
-/* Write Two Bytes */
-static void efuse_ShadowWrite2Byte(struct rtw_adapter *adapter, u16 Offset, u16 value)
-{
-	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
-
-	pEEPROM->efuse_eeprom_data[Offset] = value&0x00FF;
-	pEEPROM->efuse_eeprom_data[Offset+1] = value>>8;
-}	/*  efuse_ShadowWrite1Byte */
-
-/* Write Four Bytes */
-static void efuse_ShadowWrite4Byte(struct rtw_adapter *adapter, u16 Offset, u32 value)
-{
-	struct eeprom_priv *EEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
-
-	EEPROM->efuse_eeprom_data[Offset] = (u8)(value&0x000000FF);
-	EEPROM->efuse_eeprom_data[Offset+1] = (u8)((value>>8)&0x0000FF);
-	EEPROM->efuse_eeprom_data[Offset+2] = (u8)((value>>16)&0x00FF);
-	EEPROM->efuse_eeprom_data[Offset+3] = (u8)((value>>24)&0xFF);
-}	/*  efuse_ShadowWrite1Byte */
-
-/*-----------------------------------------------------------------------------
  * Function:	EFUSE_ShadowMapUpdate
  *
  * Overview:	Transfer current EFUSE content to shadow init and modify map.
--- a/drivers/staging/rtl8192du/core/rtw_ieee80211.c
+++ b/drivers/staging/rtl8192du/core/rtw_ieee80211.c
@@ -1319,7 +1319,6 @@ static uint rtw_p2p_attr_remove(u8 *ie,
 	u8 *target_attr;
 	u32 target_attr_len;
 	uint ielen = ielen_ori;
-	int index = 0;
 
 	while (1) {
 		target_attr = rtw_get_p2p_attr(ie, ielen, attr_id, NULL, &target_attr_len);
@@ -1344,7 +1343,6 @@ void rtw_wlan_bssid_ex_remove_p2p_attr(s
 {
 	u8 *p2p_ie;
 	uint p2p_ielen, p2p_ielen_ori;
-	int cnt;
 
 	p2p_ie = rtw_get_p2p_ie(bss_ex->IEs+_FIXED_IE_LENGTH_,
 				bss_ex->IELength-_FIXED_IE_LENGTH_,
@@ -1473,7 +1471,7 @@ int rtw_action_frame_parse(const u8 *fra
 {
 	const u8 *frame_body = frame + sizeof(struct ieee80211_hdr_3addr);
 	u16 fc;
-	u8 c, a;
+	u8 c, a = 0;
 
 	fc = le16_to_cpu(((struct ieee80211_hdr_3addr *)frame)->frame_control);
 
--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -1053,9 +1053,6 @@ int rtw_set_scan_mode(struct rtw_adapter
 */
 int rtw_set_channel_plan(struct rtw_adapter *adapter, u8 channel_plan)
 {
-	struct registry_priv *pregistrypriv = &adapter->registrypriv;
-	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
-
 	/* handle by cmd_thread to sync with scan operation */
 	return rtw_set_chplan_cmd(adapter, channel_plan, 1);
 }
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -87,6 +87,7 @@ exit:
 	return res;
 }
 
+#ifdef CONFIG_92D_AP_MODE
 static void rtw_free_mlme_ie_data(u8 **ppie, u32 *plen)
 {
 	if (*ppie) {
@@ -95,6 +96,7 @@ static void rtw_free_mlme_ie_data(u8 **p
 		*ppie = NULL;
 	}
 }
+#endif
 
 void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)
 {
@@ -399,24 +401,6 @@ void rtw_free_mlme_priv(struct mlme_priv
 
 }
 
-static int rtw_enqueue_network(struct __queue *queue, struct wlan_network *pnetwork)
-{
-	int res;
-
-	res = _rtw_enqueue_network(queue, pnetwork);
-
-	return res;
-}
-
-static struct wlan_network *rtw_dequeue_network(struct __queue *queue)
-{
-	struct wlan_network *pnetwork;
-
-	pnetwork = _rtw_dequeue_network(queue);
-
-	return pnetwork;
-}
-
 static struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv)
 {
 	struct wlan_network *pnetwork;
@@ -426,17 +410,6 @@ static struct wlan_network *rtw_alloc_ne
 	return pnetwork;
 }
 
-static void rtw_free_network(struct mlme_priv *pmlmepriv,
-			     struct wlan_network *pnetwork, u8 is_freeall)
-{
-
-	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
-		 ("rtw_free_network==> ssid = %s\n\n",
-		  pnetwork->network.Ssid.Ssid));
-	_rtw_free_network(pmlmepriv, pnetwork, is_freeall);
-
-}
-
 static void rtw_free_network_nolock(struct mlme_priv *pmlmepriv,
 				    struct wlan_network *pnetwork)
 {
@@ -544,14 +517,8 @@ struct wlan_network *rtw_get_oldest_wlan
 static void update_network(struct wlan_bssid_ex *dst, struct wlan_bssid_ex *src,
 			   struct rtw_adapter *padapter, bool update_ie)
 {
-	u8 ss_ori = dst->PhyInfo.SignalStrength;
-	u8 sq_ori = dst->PhyInfo.SignalQuality;
 	long rssi_ori = dst->Rssi;
-
-	u8 ss_smp = src->PhyInfo.SignalStrength;
 	u8 sq_smp = src->PhyInfo.SignalQuality;
-	long rssi_smp = src->Rssi;
-
 	u8 ss_final;
 	u8 sq_final;
 	long rssi_final;
@@ -725,11 +692,6 @@ exit:
 static void rtw_add_network(struct rtw_adapter *adapter,
 			    struct wlan_bssid_ex *pnetwork)
 {
-	struct mlme_priv *pmlmepriv =
-	    &(((struct rtw_adapter *)adapter)->mlmepriv);
-
-	/* spin_lock_bh(&queue->lock); */
-
 #if defined(CONFIG_P2P)
 	rtw_wlan_bssid_ex_remove_p2p_attr(pnetwork, P2P_ATTR_GROUP_INFO);
 #endif
@@ -737,9 +699,6 @@ static void rtw_add_network(struct rtw_a
 	update_current_network(adapter, pnetwork);
 
 	rtw_update_scanned_network(adapter, pnetwork);
-
-	/* spin_unlock_bh(&queue->lock); */
-
 }
 
 /* select the desired network based on the capability of the (i)bss. */
@@ -870,7 +829,6 @@ void rtw_surveydone_event_callback(struc
 	spin_lock_bh(&pmlmepriv->lock);
 
 	if (pmlmepriv->wps_probe_req_ie) {
-		u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 		pmlmepriv->wps_probe_req_ie_len = 0;
 		kfree(pmlmepriv->wps_probe_req_ie);
 		pmlmepriv->wps_probe_req_ie = NULL;
@@ -1088,7 +1046,6 @@ void rtw_free_assoc_resources(struct rtw
 void rtw_indicate_connect(struct rtw_adapter *padapter)
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 		 ("+rtw_indicate_connect\n"));
@@ -1148,7 +1105,6 @@ inline void rtw_indicate_scan_done(struc
 
 void rtw_scan_abort(struct rtw_adapter *adapter)
 {
-	u32 cnt = 0;
 	u32 start;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);
@@ -1817,7 +1773,6 @@ void rtw_scan_timeout_handler(struct rtw
 static void rtw_auto_scan_handler(struct rtw_adapter *padapter)
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 
 	/* auto site survey per 60sec */
 	if (pmlmepriv->scan_interval > 0) {
@@ -2009,7 +1964,6 @@ int rtw_select_and_join_from_scanned_que
 	struct __queue *queue = &(pmlmepriv->scanned_queue);
 	struct wlan_network *pnetwork = NULL;
 	struct wlan_network *candidate = NULL;
-	u8 bSupportAntDiv = false;
 
 	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 	phead = get_list_head(queue);
@@ -2296,10 +2250,8 @@ static int rtw_append_pmkid(struct rtw_a
 int rtw_restruct_sec_ie(struct rtw_adapter *adapter, u8 *in_ie, u8 *out_ie,
 			uint in_len)
 {
-	u8 authmode, securitytype, match;
-	u8 sec_ie[255], uncst_oui[4], bkup_ie[255];
-	u8 wpa_oui[4] = { 0x0, 0x50, 0xf2, 0x01 };
-	uint ielength, cnt, remove_cnt;
+	u8 authmode;
+	uint ielength;
 	int iEntry;
 
 	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
@@ -2471,7 +2423,6 @@ unsigned int rtw_restructure_ht_ie(struc
 	u32 ielen;
 	unsigned char *p;
 	struct rtw_ieee80211_ht_cap ht_capie;
-	unsigned char WMM_IE[] = { 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00 };
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
 	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -45,27 +45,6 @@ static struct mlme_handler mlme_sta_tbl[
 	{WIFI_ACTION, "OnAction", &OnAction},
 };
 
-static struct mlme_handler mlme_ap_tbl[] = {
-	{WIFI_ASSOCREQ, "OnAssocReq", &OnAssocReq},
-	{WIFI_ASSOCRSP, "OnAssocRsp", &OnAssocRsp},
-	{WIFI_REASSOCREQ, "OnReAssocReq", &OnAssocReq},
-	{WIFI_REASSOCRSP, "OnReAssocRsp", &OnAssocRsp},
-	{WIFI_PROBEREQ, "OnProbeReq", &OnProbeReq},
-	{WIFI_PROBERSP, "OnProbeRsp", &OnProbeRsp},
-
-	/*----------------------------------------------------------
-					below 2 are reserved
-	-----------------------------------------------------------*/
-	{0, "DoReserved", &DoReserved},
-	{0, "DoReserved", &DoReserved},
-	{WIFI_BEACON, "OnBeacon", &OnBeacon},
-	{WIFI_ATIM, "OnATIM", &OnAtim},
-	{WIFI_DISASSOC, "OnDisassoc", &OnDisassoc},
-	{WIFI_AUTH, "OnAuth", &OnAuth},
-	{WIFI_DEAUTH, "OnDeAuth", &OnDeAuth},
-	{WIFI_ACTION, "OnAction", &OnAction},
-};
-
 static struct action_handler OnAction_tbl[] = {
 	{RTW_WLAN_CATEGORY_SPECTRUM_MGMT, "ACTION_SPECTRUM_MGMT",
 	 on_action_spct},
@@ -514,26 +493,6 @@ void free_mlme_ext_priv(struct mlme_ext_
 	}
 }
 
-static u8 cmp_pkt_chnl_diff(struct rtw_adapter *adapt, u8 *pframe,
-			    uint packet_len)
-{				/*  if the channel is same, return 0. else return channel differential */
-	uint len;
-	u8 channel;
-	u8 *p;
-	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_,
-		       _DSSET_IE_, &len, packet_len - _BEACON_IE_OFFSET_);
-	if (p) {
-		channel = *(p + 2);
-		if (adapt->mlmeextpriv.cur_channel >= channel) {
-			return adapt->mlmeextpriv.cur_channel - channel;
-		} else {
-			return channel - adapt->mlmeextpriv.cur_channel;
-		}
-	} else {
-		return 0;
-	}
-}
-
 static void _mgt_dispatcher(struct rtw_adapter *adapt,
 			    struct mlme_handler *ptable,
 			    struct recv_frame_hdr *precv_frame)
@@ -686,7 +645,6 @@ unsigned int OnProbeReq(struct rtw_adapt
 
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
 	u8 wifi_test_chk_rate = 1;
 
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) &&
@@ -772,13 +730,10 @@ _issue_probersp:
 unsigned int OnProbeRsp(struct rtw_adapter *adapt,
 			struct recv_frame_hdr *precv_frame)
 {
-	struct sta_info *psta;
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct sta_priv *pstapriv = &adapt->stapriv;
-	u8 *pframe = precv_frame->rx_data;
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &adapt->wdinfo;
+	u8 *pframe = precv_frame->rx_data;
 #endif
 
 #ifdef CONFIG_P2P
@@ -1875,7 +1830,7 @@ unsigned int OnDeAuth(struct rtw_adapter
 
 		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
 		if (psta) {
-			u8 updated;
+			u8 updated = 0;
 
 			spin_lock_bh(&pstapriv->asoc_list_lock);
 			if (list_empty(&psta->asoc_list) == false) {
@@ -1940,7 +1895,7 @@ unsigned int OnDisassoc(struct rtw_adapt
 
 		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
 		if (psta) {
-			u8 updated;
+			u8 updated = 0;
 
 			spin_lock_bh(&pstapriv->asoc_list_lock);
 			if (list_empty(&psta->asoc_list) == false) {
@@ -1972,71 +1927,6 @@ unsigned int OnAtim(struct rtw_adapter *
 	return 1;
 }
 
-static unsigned int on_action_spct_ch_switch(struct rtw_adapter *adapt,
-					     struct sta_info *psta, u8 *ies,
-					     uint ies_len)
-{
-	unsigned int ret = 0;
-	struct mlme_ext_priv *mlmeext = &adapt->mlmeextpriv;
-	struct mlme_ext_info *pmlmeinfo = &(mlmeext->mlmext_info);
-
-	if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {
-		ret = 1;
-		goto exit;
-	}
-
-	if ((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) {
-		int ch_switch_mode = -1, ch = -1, ch_switch_cnt = -1;
-		int ch_offset = -1;
-		u8 bwmode;
-		struct ieee80211_info_element *ie;
-
-		DBG_8192D(FUNC_NDEV_FMT " from %pM\n",
-			  FUNC_NDEV_ARG(adapt->pnetdev), psta->hwaddr);
-
-		for_each_ie(ie, ies, ies_len) {
-			if (ie->id == WLAN_EID_CHANNEL_SWITCH) {
-				ch_switch_mode = ie->data[0];
-				ch = ie->data[1];
-				ch_switch_cnt = ie->data[2];
-				DBG_8192D
-				    ("ch_switch_mode:%d, ch:%d, ch_switch_cnt:%d\n",
-				     ch_switch_mode, ch, ch_switch_cnt);
-			} else if (ie->id == WLAN_EID_SECONDARY_CHANNEL_OFFSET) {
-				ch_offset =
-				    secondary_ch_offset_to_hal_ch_offset(ie->
-									 data
-									 [0]);
-				DBG_8192D("ch_offset:%d\n", ch_offset);
-			}
-		}
-
-		if (ch == -1)
-			return 1;
-
-		if (ch_offset == -1)
-			bwmode = mlmeext->cur_bwmode;
-		else
-			bwmode =
-			    (ch_offset ==
-			     HAL_PRIME_CHNL_OFFSET_DONT_CARE) ?
-			    HT_CHANNEL_WIDTH_20 : HT_CHANNEL_WIDTH_40;
-
-		ch_offset =
-		    (ch_offset == -1) ? mlmeext->cur_ch_offset : ch_offset;
-
-		/* todo:
-		 * 1. the decision of channel switching
-		 * 2. things after channel switching
-		 */
-
-		ret = rtw_set_ch_cmd(adapt, ch, bwmode, ch_offset, true);
-	}
-
-exit:
-	return ret;
-}
-
 unsigned int on_action_spct(struct rtw_adapter *adapt,
 			    struct recv_frame_hdr *precv_frame)
 {
@@ -2165,31 +2055,6 @@ static int get_reg_classes_full_count(st
 	return cnt;
 }
 
-static void get_channel_cnt_24g_5gl_5gh(struct mlme_ext_priv *pmlmeext,
-					u8 *p24g_cnt, u8 *p5gl_cnt,
-					u8 *p5gh_cnt)
-{
-	int i = 0;
-
-	*p24g_cnt = 0;
-	*p5gl_cnt = 0;
-	*p5gh_cnt = 0;
-
-	for (i = 0; i < pmlmeext->max_chan_nums; i++) {
-		if (pmlmeext->channel_set[i].ChannelNum <= 14) {
-			(*p24g_cnt)++;
-		} else if ((pmlmeext->channel_set[i].ChannelNum > 14) &&
-			   (pmlmeext->channel_set[i].ChannelNum <= 48)) {
-			/*      Just include the channel 36, 40, 44, 48 channels for 5G low */
-			(*p5gl_cnt)++;
-		} else if ((pmlmeext->channel_set[i].ChannelNum >= 149) &&
-			   (pmlmeext->channel_set[i].ChannelNum <= 161)) {
-			/*      Just include the channel 149, 153, 157, 161 channels for 5G high */
-			(*p5gh_cnt)++;
-		}
-	}
-}
-
 void issue_p2p_GO_request(struct rtw_adapter *adapt, u8 *raddr)
 {
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
@@ -2197,8 +2062,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	__be32 p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_GO_NEGO_REQ;
 	u8 wpsie[255] = { 0x00 }, p2pie[255] = {0x00};
-	u8 wpsielen = 0, p2pielen = 0, i;
-	u8 channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
+	u8 wpsielen = 0, p2pielen = 0;
 	u16 len_channellist_attr = 0;
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
@@ -2207,7 +2071,6 @@ void issue_p2p_GO_request(struct rtw_ada
 	unsigned short *fctrl;
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
@@ -2619,12 +2482,11 @@ static void issue_p2p_GO_response(struct
 	u8 oui_subtype = P2P_GO_NEGO_RESP;
 	u8 wpsie[255] = { 0x00 }, p2pie[255] = {
 	0x00};
-	u8 p2pielen = 0, i;
+	u8 p2pielen = 0;
 	uint wpsielen = 0;
 	u16 wps_devicepassword_id = 0x0000;
 	uint wps_devicepassword_id_len = 0;
 	__be16 be_tmp;
-	u8 channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh;
 	u16 len_channellist_attr = 0;
 
 	struct xmit_frame *pmgntframe;
@@ -2634,7 +2496,6 @@ static void issue_p2p_GO_response(struct
 	unsigned short *fctrl;
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
@@ -3083,8 +2944,8 @@ static void issue_p2p_GO_confirm(struct
 	u8 action = P2P_PUB_ACTION_ACTION;
 	__be32 p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_GO_NEGO_CONF;
-	u8 wpsie[255] = {0x00}, p2pie[255] = {0x00};
-	u8 wpsielen = 0, p2pielen = 0;
+	u8 p2pie[255] = {0x00};
+	u8 p2pielen = 0;
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	unsigned char *pframe;
@@ -3092,7 +2953,6 @@ static void issue_p2p_GO_confirm(struct
 	unsigned short *fctrl;
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
@@ -3283,9 +3143,8 @@ void issue_p2p_invitation_request(struct
 	__be32 p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_INVIT_REQ;
 	u8 p2pie[255] = { 0x00 };
-	u8 p2pielen = 0, i;
+	u8 p2pielen = 0;
 	u8 dialogToken = 3;
-	u8 channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
 	u16 len_channellist_attr = 0;
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
@@ -3301,7 +3160,6 @@ void issue_p2p_invitation_request(struct
 	unsigned short *fctrl;
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
@@ -3622,8 +3480,7 @@ void issue_p2p_invitation_response(struc
 	__be32 p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_INVIT_RESP;
 	u8 p2pie[255] = { 0x00 };
-	u8 p2pielen = 0, i;
-	u8 channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
+	u8 p2pielen = 0;
 	u16 len_channellist_attr = 0;
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
@@ -3638,7 +3495,6 @@ void issue_p2p_invitation_response(struc
 	unsigned short *fctrl;
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
@@ -3910,7 +3766,6 @@ void issue_p2p_provision_request(struct
 	unsigned short *fctrl;
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
@@ -4031,7 +3886,6 @@ void issue_probersp_p2p(struct rtw_adapt
 	struct ieee80211_hdr *pwlanhdr;
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo =
@@ -4327,11 +4181,8 @@ static int _issue_probereq_p2p(struct rt
 	struct ieee80211_hdr *pwlanhdr;
 	unsigned short *fctrl;
 	unsigned char *mac;
-	unsigned char bssrate[NUMRATES];
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
-	int bssrate_len = 0;
 	u8 bc_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 	u8 wpsie[255] = {0x00}, p2pie[255] = {0x00};
@@ -4745,14 +4596,14 @@ static s32 rtw_action_public_decache(str
 
 static unsigned int on_action_public_p2p(struct recv_frame_hdr *precv_frame)
 {
-	struct rtw_adapter *adapt = precv_frame->adapter;
 	u8 *pframe = precv_frame->rx_data;
-	uint len = precv_frame->len;
 	u8 *frame_body;
 	u8 dialogToken = 0;
 #ifdef CONFIG_P2P
+	struct rtw_adapter *adapt = precv_frame->adapter;
+	uint len = precv_frame->len;
 	u8 *p2p_ie;
-	u32 p2p_ielen, wps_ielen;
+	u32 p2p_ielen;
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 	u8 result = P2P_STATUS_SUCCESS;
 	u8 empty_addr[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
@@ -5280,7 +5131,6 @@ static unsigned int on_action_public_ven
 {
 	unsigned int ret = 0;
 	u8 *pframe = precv_frame->rx_data;
-	uint frame_len = precv_frame->len;
 	u8 *frame_body = pframe + sizeof(struct ieee80211_hdr_3addr);
 
 	if (!memcmp(frame_body + 2, P2P_OUI, 4)) {
@@ -5321,7 +5171,6 @@ unsigned int on_action_public(struct rtw
 {
 	unsigned int ret = 0;
 	u8 *pframe = precv_frame->rx_data;
-	uint frame_len = precv_frame->len;
 	u8 *frame_body = pframe + sizeof(struct ieee80211_hdr_3addr);
 	u8 category, action;
 
@@ -5935,7 +5784,6 @@ void issue_probersp(struct rtw_adapter *
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	struct ieee80211_hdr *pwlanhdr;
-	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);
@@ -5946,6 +5794,9 @@ void issue_probersp(struct rtw_adapter *
 	unsigned char *pframe;
 	unsigned short *fctrl;
 	unsigned char *mac, *bssid;
+#if defined (CONFIG_92D_AP_MODE) || defined(CONFIG_P2P)
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+#endif
 #if defined (CONFIG_92D_AP_MODE)
 	u8 *pwps_ie;
 	uint wps_ielen;
@@ -6137,7 +5988,7 @@ void issue_probersp(struct rtw_adapter *
 				       &pattrib->pktlen);
 		}
 
-		/*  EXTERNDED SUPPORTED RATE */
+		/*  EXTENDED SUPPORTED RATE */
 		if (rate_len > 8) {
 			pframe =
 			    rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_,
@@ -6186,7 +6037,6 @@ static int _issue_probereq(struct rtw_ad
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
 	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	int bssrate_len = 0;
 	u8 bc_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 
@@ -6512,9 +6362,6 @@ void issue_asocrsp(struct rtw_adapter *a
 	struct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);
 	u8 *ie = pnetwork->IEs;
 	__le16 leval, lestatus;
-#ifdef CONFIG_P2P
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-#endif /* CONFIG_P2P */
 
 	DBG_8192D("%s\n", __func__);
 
@@ -6664,7 +6511,6 @@ void issue_assocreq(struct rtw_adapter *
 	unsigned char *pframe, *p;
 	struct ieee80211_hdr *pwlanhdr;
 	unsigned short *fctrl;
-	unsigned short val16;
 	__le16 le_tmp;
 	unsigned int i, j, ie_len, index = 0;
 	unsigned char rf_type, bssrate[NUMRATES], sta_bssrate[NUMRATES];
@@ -7513,16 +7359,13 @@ exit:
 void issue_action_spct_ch_switch(struct rtw_adapter *adapt, u8 *ra,
 				 u8 new_ch, u8 ch_offset)
 {
-	struct list_head *plist, *phead;
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	unsigned char *pframe;
 	struct ieee80211_hdr *pwlanhdr;
 	unsigned short *fctrl;
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
-	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	DBG_8192D(FUNC_NDEV_FMT " ra=%pM, ch:%u, offset:%u\n",
 		  FUNC_NDEV_ARG(adapt->pnetdev), ra, new_ch, ch_offset);
@@ -7582,10 +7425,10 @@ void issue_action_BA(struct rtw_adapter
 {
 	u8 category = RTW_WLAN_CATEGORY_BACK;
 	u16 start_seq;
-	u16 BA_para_set;
+	u16 BA_para_set = 0;
 	u16 reason_code;
 	u16 BA_timeout_value;
-	u16 BA_starting_seqctrl;
+	u16 BA_starting_seqctrl = 0;
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	u8 *pframe;
@@ -8004,8 +7847,6 @@ void site_survey(struct rtw_adapter *ada
 
 #endif /* CONFIG_CONCURRENT_MODE */
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-	static unsigned char prev_survey_channel;
-	static unsigned int p2p_scan_count;
 
 	if ((pwdinfo->rx_invitereq_info.scan_op_ch_only) ||
 	    (pwdinfo->p2p_info.scan_op_ch_only)) {
@@ -9513,8 +9354,6 @@ static void _linked_rx_signal_strehgth_d
 static u8 chk_ap_is_alive(struct rtw_adapter *adapt, struct sta_info *psta)
 {
 	u8 ret = false;
-	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	if ((sta_rx_data_pkts(psta) == sta_last_rx_data_pkts(psta)) &&
 	    sta_rx_beacon_pkts(psta) == sta_last_rx_beacon_pkts(psta) &&
@@ -10168,10 +10007,6 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 	u32 initialgain;
 	u32 i;
 
-#ifdef CONFIG_P2P
-	struct wifidirect_info *pwdinfo = &adapt->wdinfo;
-#endif
-
 	if (pmlmeext->sitesurvey_res.state == SCAN_DISABLE) {
 		/* for first time sitesurvey_cmd */
 		rtw_hal_set_hwreg(adapt, HW_VAR_CHECK_TXBUF, NULL);
@@ -10579,10 +10414,9 @@ void change_band_update_ie(struct rtw_ad
 {
 	u8 network_type, rate_len, total_rate_len, remainder_rate_len;
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+#ifdef CONFIG_92D_AP_MODE
 	u8 erpinfo = 0x4;
-
-	/* DBG_8192D("%s\n", __func__); */
+#endif
 
 	if (pmlmeext->cur_channel >= 36) {
 		network_type = WIRELESS_11A;
@@ -11582,7 +11416,6 @@ void concurrent_chk_joinbss_done(struct
 u8 set_ch_hdl(struct rtw_adapter *adapt, u8 *pbuf)
 {
 	struct set_ch_parm *set_ch_parm;
-	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
 
 	if (!pbuf)
@@ -11607,7 +11440,6 @@ u8 set_ch_hdl(struct rtw_adapter *adapt,
 u8 set_chplan_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
 {
 	struct setchannelplan_param *setchannelplan_param;
-	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
 
 	if (!pbuf)
@@ -11634,10 +11466,6 @@ u8 led_blink_hdl(struct rtw_adapter *ada
 u8 set_csa_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
 {
 	struct setchannelswitch_param *setchannelswitch_param;
-	struct setchannelplan_param *setchannelplan_param;
-	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
-	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
-	struct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;
 	u8 new_ch_no;
 	u8 gval8 = 0x00, sval8 = 0xff;
 
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -34,32 +34,6 @@ static int rtw_p2p_is_channel_list_ok(u8
 	return found;
 }
 
-static int is_any_client_associated(struct rtw_adapter *padapter)
-{
-	struct list_head *phead, *plist;
-	int	intFound = false;
-
-	struct sta_priv *pstapriv = &padapter->stapriv;
-
-	spin_lock_bh(&pstapriv->asoc_list_lock);
-	phead = &pstapriv->asoc_list;
-	plist = phead->next;
-
-	if (rtw_end_of_queue_search(phead, plist) == true)
-		intFound = false;
-	else
-		intFound = true;
-
-	if ((intFound == false && pstapriv->asoc_list_cnt) ||
-	    (intFound == true && !pstapriv->asoc_list_cnt))
-		DBG_8192D("%s intFound:%d, asoc_list_cnt:%u mismatch\n",
-			  __func__, intFound, pstapriv->asoc_list_cnt);
-
-	spin_unlock_bh(&pstapriv->asoc_list_lock);
-
-	return intFound;
-}
-
 static u32 go_add_group_info_attr(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
 	struct list_head *phead, *plist;
@@ -291,7 +265,6 @@ static void issue_p2p_provision_resp(str
 	unsigned short				*fctrl;
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
 	if (pmgntframe == NULL)
@@ -1040,18 +1013,6 @@ static u8 rtw_p2p_get_peer_ch_list(struc
 	return ch_no;
 }
 
-static u8 rtw_p2p_check_peer_oper_ch(struct mlme_ext_priv *pmlmeext, u8 ch)
-{
-	u8 i = 0;
-
-	for (i = 0; i < pmlmeext->max_chan_nums; i++) {
-		if (pmlmeext->channel_set[i].ChannelNum == ch)
-			return 1;
-	}
-
-	return 0;
-}
-
 static u8 rtw_p2p_ch_inclusion(struct mlme_ext_priv *pmlmeext, u8 *peer_ch_list, u8 peer_ch_num, u8 *ch_list_inclusioned)
 {
 	int	i = 0, j = 0, temp = 0;
@@ -1262,8 +1223,6 @@ u8 process_p2p_group_negotation_resp(str
 		u8 attr_content = 0x00;
 		u32	attr_contentlen = 0;
 		u8 operatingch_info[5] = { 0x00 };
-		uint	ch_cnt = 0;
-		u8 ch_content[50] = { 0x00 };
 		u8 groupid[38];
 		u16	cap_attr;
 		u8 peer_ch_list[50] = { 0x00 };
@@ -1529,7 +1488,6 @@ void p2p_concurrent_handler(struct rtw_a
 static void restore_p2p_state_handler(struct rtw_adapter *padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
-	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) ||
 	    rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
@@ -1631,7 +1589,6 @@ static void ro_ch_handler(struct rtw_ada
 {
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -1671,7 +1628,6 @@ static void ro_ch_handler(struct rtw_ada
 static void ro_ch_timer_process (void *FunctionContext)
 {
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
 
 #ifdef	CONFIG_CONCURRENT_MODE
 	atomic_set(&pwdev_priv->ro_ch_to, 1);
@@ -1680,55 +1636,6 @@ static void ro_ch_timer_process (void *F
 	p2p_protocol_wk_cmd(adapter, P2P_RO_CH_WK);
 }
 
-static void rtw_cfg80211_adjust_p2pie_channel(struct rtw_adapter *padapter, const u8 *frame_body, u32 len)
-{
-#ifdef CONFIG_CONCURRENT_MODE
-	u8 *ies, *p2p_ie;
-	u32 ies_len, p2p_ielen;
-	struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
-	struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
-	ies = (u8 *)(frame_body + _PUBLIC_ACTION_IE_OFFSET_);
-	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
-
-	p2p_ie = rtw_get_p2p_ie(ies, ies_len, NULL, &p2p_ielen);
-
-	while (p2p_ie) {
-		u32	attr_contentlen = 0;
-		u8 *pattr = NULL;
-
-		/* Check P2P_ATTR_CH_LIST */
-		pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, NULL, (uint *)&attr_contentlen);
-		if (pattr != NULL) {
-			int i;
-			u32 num_of_ch;
-			u8 *pattr_temp = pattr + 3;
-
-			attr_contentlen -= 3;
-
-			while (attr_contentlen > 0) {
-				num_of_ch = *(pattr_temp+1);
-
-				for (i = 0; i < num_of_ch; i++)
-					*(pattr_temp+2+i) = pbuddy_mlmeext->cur_channel;/* forcing to the same channel */
-
-				pattr_temp += (2+num_of_ch);
-				attr_contentlen -= (2+num_of_ch);
-			}
-		}
-
-		/* Check P2P_ATTR_OPERATING_CH */
-		attr_contentlen = 0;
-		pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, (uint *)&attr_contentlen);
-		if (pattr != NULL)
-			*(pattr+4) = pbuddy_mlmeext->cur_channel;/* forcing to the same channel */
-
-		/* Get the next P2P IE */
-		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len - (p2p_ie - ies + p2p_ielen), NULL, &p2p_ielen);
-	}
-#endif
-}
-
 int rtw_p2p_check_frames(struct rtw_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 {
 	int is_p2p_frame = (-1);
@@ -1938,8 +1845,6 @@ void rtw_init_cfg80211_wifidirect_info(s
 
 void p2p_protocol_wk_hdl(struct rtw_adapter *padapter, int intCmdType)
 {
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
 	switch (intCmdType) {
 	case P2P_FIND_PHASE_WK:
 		find_phase_handler(padapter);
@@ -2035,7 +1940,6 @@ static void pre_tx_scan_timer_process(vo
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
 	struct	wifidirect_info *pwdinfo = &adapter->wdinfo;
 	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
-	u8 _status = 0;
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
@@ -2259,13 +2163,9 @@ int rtw_p2p_enable(struct rtw_adapter *p
 {
 	int ret = 1;
 	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 
 	if (role == P2P_ROLE_DEVICE || role == P2P_ROLE_CLIENT ||
 	    role == P2P_ROLE_GO) {
-		u8 channel, ch_offset;
-		u16 bwmode;
-
 #ifdef CONFIG_CONCURRENT_MODE
 		struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 		struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -23,7 +23,6 @@
 void ips_enter(struct rtw_adapter *padapter)
 {
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
 	_enter_pwrlock(&pwrpriv->lock);
 
@@ -106,8 +105,6 @@ static bool rtw_pwr_unassociated_idle(st
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &(adapter->wdinfo);
-	struct cfg80211_wifidirect_info *pcfg80211_wdinfo =
-	    &adapter->cfg80211_wdinfo;
 #endif
 
 	bool ret = false;
@@ -131,8 +128,6 @@ static bool rtw_pwr_unassociated_idle(st
 		struct mlme_priv *b_pmlmepriv = &(buddy->mlmepriv);
 #ifdef CONFIG_P2P
 		struct wifidirect_info *b_pwdinfo = &(buddy->wdinfo);
-		struct cfg80211_wifidirect_info *b_pcfg80211_wdinfo =
-		    &buddy->cfg80211_wdinfo;
 #endif
 
 		if (check_fwstate(b_pmlmepriv, WIFI_ASOC_STATE | WIFI_SITE_MONITOR) ||
@@ -153,9 +148,6 @@ exit:
 
 void rtw_ps_processor(struct rtw_adapter *padapter)
 {
-#ifdef CONFIG_P2P
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-#endif /* CONFIG_P2P */
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
@@ -269,9 +261,6 @@ static u8 ps_rdy_check(struct rtw_adapte
 void rtw_set_ps_mode(struct rtw_adapter *padapter, u8 ps_mode, u8 smart_ps)
 {
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
-#ifdef CONFIG_P2P
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-#endif /* CONFIG_P2P */
 
 	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
 		 ("%s: PowerMode=%d Smart_PS=%d\n",
@@ -319,7 +308,6 @@ void rtw_lps_enter(struct rtw_adapter *p
 {
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct rtw_adapter *buddy = padapter->pbuddy_adapter;
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type != IFACE_PORT0)
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -26,8 +26,21 @@
 #include <usb_osintf.h>
 #include <linux/vmalloc.h>
 
+static u8 SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};
+
+static u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};
+
 void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS);
 
+static u8 rtw_rfc1042_header[] = {
+	0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00
+};
+
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static u8 rtw_bridge_tunnel_header[] = {
+	0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8
+};
+
 void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
 {
 	memset((u8 *)psta_recvpriv, 0, sizeof(struct sta_recv_priv));
@@ -2206,8 +2219,6 @@ static int recv_func_prehandle(struct rt
 			       struct recv_frame_hdr *rframe)
 {
 	int ret = 1;
-	struct rx_pkt_attrib *pattrib = &rframe->attrib;
-	struct recv_priv *precvpriv = &padapter->recvpriv;
 	struct __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
 
 	/* check the frame crtl field and decache */
@@ -2229,7 +2240,6 @@ static int recv_func_posthandle(struct r
 {
 	int ret = 1;
 	struct recv_frame_hdr *orig_prframe = prframe;
-	struct rx_pkt_attrib *pattrib = &prframe->attrib;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 	struct __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
 
@@ -2266,8 +2276,6 @@ static int recv_func_posthandle(struct r
 		rtw_free_recvframe(orig_prframe, pfree_recv_queue);	/* free this recv_frame */
 		goto _recv_data_drop;
 	}
-
-_exit_recv_func:
 	return ret;
 
 _recv_data_drop:
@@ -2280,7 +2288,6 @@ static int recv_func(struct rtw_adapter
 {
 	int ret;
 	struct rx_pkt_attrib *prxattrib = &rframe->attrib;
-	struct recv_priv *recvpriv = &padapter->recvpriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct mlme_priv *mlmepriv = &padapter->mlmepriv;
 
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -875,8 +875,6 @@ static void next_key(u8 *key, int round)
 static void byte_sub(u8 *in, u8 *out);
 static void shift_row(u8 *in, u8 *out);
 static void mix_column(u8 *in, u8 *out);
-static void add_round_key(u8 *shiftrow_in,
-			  u8 *mcol_in, u8 *block_in, int round, u8 *out);
 static void aes128k128d(u8 *key, u8 *data, u8 *ciphertext);
 
 /****************************************/
@@ -1705,325 +1703,6 @@ exit:
 	return res;
 }
 
-/* compress 512-bits */
-static int sha256_compress(struct sha256_state *md, unsigned char *buf)
-{
-	u32 S[8], W[64], t0, t1;
-	u32 t;
-	int i;
-
-	/* copy state into S */
-	for (i = 0; i < 8; i++)
-		S[i] = md->state[i];
-
-	/* copy the state into 512-bits into W[0..15] */
-	for (i = 0; i < 16; i++)
-		W[i] = WPA_GET_BE32(buf + (4 * i));
-
-	/* fill W[16..63] */
-	for (i = 16; i < 64; i++) {
-		W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) +
-		    W[i - 16];
-	}
-
-	/* Compress */
-#define RND(a, b, c, d, e, f, g, h, i)			\
-do {							\
-	t0 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];	\
-	t1 = Sigma0(a) + Maj(a, b, c);			\
-	d += t0;					\
-	h  = t0 + t1;					\
-} while (0)
-
-	for (i = 0; i < 64; ++i) {
-		RND(S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7], i);
-		t = S[7];
-		S[7] = S[6];
-		S[6] = S[5];
-		S[5] = S[4];
-		S[4] = S[3];
-		S[3] = S[2];
-		S[2] = S[1];
-		S[1] = S[0];
-		S[0] = t;
-	}
-
-	/* feedback */
-	for (i = 0; i < 8; i++)
-		md->state[i] = md->state[i] + S[i];
-	return 0;
-}
-
-/* Initialize the hash state */
-static void sha256_init(struct sha256_state *md)
-{
-	md->curlen = 0;
-	md->length = 0;
-	md->state[0] = 0x6A09E667UL;
-	md->state[1] = 0xBB67AE85UL;
-	md->state[2] = 0x3C6EF372UL;
-	md->state[3] = 0xA54FF53AUL;
-	md->state[4] = 0x510E527FUL;
-	md->state[5] = 0x9B05688CUL;
-	md->state[6] = 0x1F83D9ABUL;
-	md->state[7] = 0x5BE0CD19UL;
-}
-
-/**
-   Process a block of memory though the hash
-   @param md     The hash state
-   @param in     The data to hash
-   @param inlen  The length of the data (octets)
-   @return CRYPT_OK if successful
-*/
-static int sha256_process(struct sha256_state *md, unsigned char *in,
-			  unsigned long inlen)
-{
-	unsigned long n;
-#define block_size 64
-
-	if (md->curlen > sizeof(md->buf))
-		return -1;
-
-	while (inlen > 0) {
-		if (md->curlen == 0 && inlen >= block_size) {
-			if (sha256_compress(md, (unsigned char *)in) < 0)
-				return -1;
-			md->length += block_size * 8;
-			in += block_size;
-			inlen -= block_size;
-		} else {
-			n = MIN(inlen, (block_size - md->curlen));
-			memcpy(md->buf + md->curlen, in, n);
-			md->curlen += n;
-			in += n;
-			inlen -= n;
-			if (md->curlen == block_size) {
-				if (sha256_compress(md, md->buf) < 0)
-					return -1;
-				md->length += 8 * block_size;
-				md->curlen = 0;
-			}
-		}
-	}
-
-	return 0;
-}
-
-/**
-   Terminate the hash to get the digest
-   @param md  The hash state
-   @param out [out] The destination of the hash (32 bytes)
-   @return CRYPT_OK if successful
-*/
-static int sha256_done(struct sha256_state *md, unsigned char *out)
-{
-	int i;
-
-	if (md->curlen >= sizeof(md->buf))
-		return -1;
-
-	/* increase the length of the message */
-	md->length += md->curlen * 8;
-
-	/* append the '1' bit */
-	md->buf[md->curlen++] = (unsigned char)0x80;
-
-	/* if the length is currently above 56 bytes we append zeros
-	 * then compress.  Then we can fall back to padding zeros and length
-	 * encoding like normal.
-	 */
-	if (md->curlen > 56) {
-		while (md->curlen < 64)
-			md->buf[md->curlen++] = (unsigned char)0;
-		sha256_compress(md, md->buf);
-		md->curlen = 0;
-	}
-
-	/* pad upto 56 bytes of zeroes */
-	while (md->curlen < 56)
-		md->buf[md->curlen++] = (unsigned char)0;
-
-	/* store length */
-	WPA_PUT_BE64(md->buf + 56, md->length);
-	sha256_compress(md, md->buf);
-
-	/* copy output */
-	for (i = 0; i < 8; i++)
-		WPA_PUT_BE32(out + (4 * i), md->state[i]);
-
-	return 0;
-}
-
-/**
- * sha256_vector - SHA256 hash for data vector
- * @num_elem: Number of elements in the data vector
- * @addr: Pointers to the data areas
- * @len: Lengths of the data blocks
- * @mac: Buffer for the hash
- * Returns: 0 on success, -1 of failure
- */
-static int sha256_vector(size_t num_elem, u8 *addr[], size_t *len, u8 *mac)
-{
-	struct sha256_state ctx;
-	size_t i;
-
-	sha256_init(&ctx);
-	for (i = 0; i < num_elem; i++)
-		if (sha256_process(&ctx, addr[i], len[i]))
-			return -1;
-	if (sha256_done(&ctx, mac))
-		return -1;
-	return 0;
-}
-
-static u8 os_strlen(const char *s)
-{
-	const char *p = s;
-	while (*p)
-		p++;
-	return p - s;
-}
-
-static int os_memcmp(void *s1, void *s2, u8 n)
-{
-	unsigned char *p1 = s1, *p2 = s2;
-
-	if (n == 0)
-		return 0;
-
-	while (*p1 == *p2) {
-		p1++;
-		p2++;
-		n--;
-		if (n == 0)
-			return 0;
-	}
-
-	return *p1 - *p2;
-}
-
-/**
- * hmac_sha256_vector - HMAC-SHA256 over data vector (RFC 2104)
- * @key: Key for HMAC operations
- * @key_len: Length of the key in bytes
- * @num_elem: Number of elements in the data vector
- * @addr: Pointers to the data areas
- * @len: Lengths of the data blocks
- * @mac: Buffer for the hash (32 bytes)
- */
-static void hmac_sha256_vector(u8 *key, size_t key_len, size_t num_elem,
-			       u8 *addr[], size_t *len, u8 *mac)
-{
-	unsigned char k_pad[64];	/* padding - key XORd with ipad/opad */
-	unsigned char tk[32];
-	u8 *_addr[6];
-	size_t _len[6], i;
-
-	if (num_elem > 5) {
-		/*
-		 * Fixed limit on the number of fragments to avoid having to
-		 * allocate memory (which could fail).
-		 */
-		return;
-	}
-
-	/* if key is longer than 64 bytes reset it to key = SHA256(key) */
-	if (key_len > 64) {
-		sha256_vector(1, &key, &key_len, tk);
-		key = tk;
-		key_len = 32;
-	}
-
-	/* the HMAC_SHA256 transform looks like:
-	 *
-	 * SHA256(K XOR opad, SHA256(K XOR ipad, text))
-	 *
-	 * where K is an n byte key
-	 * ipad is the byte 0x36 repeated 64 times
-	 * opad is the byte 0x5c repeated 64 times
-	 * and text is the data being protected */
-
-	/* start out by storing key in ipad */
-	memset(k_pad, 0, sizeof(k_pad));
-	memcpy(k_pad, key, key_len);
-	/* XOR key with ipad values */
-	for (i = 0; i < 64; i++)
-		k_pad[i] ^= 0x36;
-
-	/* perform inner SHA256 */
-	_addr[0] = k_pad;
-	_len[0] = 64;
-	for (i = 0; i < num_elem; i++) {
-		_addr[i + 1] = addr[i];
-		_len[i + 1] = len[i];
-	}
-	sha256_vector(1 + num_elem, _addr, _len, mac);
-
-	memset(k_pad, 0, sizeof(k_pad));
-	memcpy(k_pad, key, key_len);
-	/* XOR key with opad values */
-	for (i = 0; i < 64; i++)
-		k_pad[i] ^= 0x5c;
-
-	/* perform outer SHA256 */
-	_addr[0] = k_pad;
-	_len[0] = 64;
-	_addr[1] = mac;
-	_len[1] = 32;
-	sha256_vector(2, _addr, _len, mac);
-}
-
-/**
- * sha256_prf - SHA256-based Pseudo-Random Function (IEEE 802.11r, 8.5.1.5.2)
- * @key: Key for PRF
- * @key_len: Length of the key in bytes
- * @label: A unique label for each purpose of the PRF
- * @data: Extra data to bind into the key
- * @data_len: Length of the data
- * @buf: Buffer for the generated pseudo-random key
- * @buf_len: Number of bytes of key to generate
- *
- * This function is used to derive new, cryptographically separate keys from a
- * given key.
- */
-static void sha256_prf(u8 *key, size_t key_len, char *label,
-		       u8 *data, size_t data_len, u8 *buf, size_t buf_len)
-{
-	u16 counter = 1;
-	size_t pos, plen;
-	u8 hash[SHA256_MAC_LEN];
-	u8 *addr[4];
-	size_t len[4];
-	u8 counter_le[2], length_le[2];
-
-	addr[0] = counter_le;
-	len[0] = 2;
-	addr[1] = (u8 *)label;
-	len[1] = os_strlen(label);
-	addr[2] = data;
-	len[2] = data_len;
-	addr[3] = length_le;
-	len[3] = sizeof(length_le);
-
-	WPA_PUT_LE16(length_le, buf_len * 8);
-	pos = 0;
-	while (pos < buf_len) {
-		plen = buf_len - pos;
-		WPA_PUT_LE16(counter_le, counter);
-		if (plen >= SHA256_MAC_LEN) {
-			hmac_sha256_vector(key, key_len, 4, addr, len,
-					   &buf[pos]);
-			pos += SHA256_MAC_LEN;
-		} else {
-			hmac_sha256_vector(key, key_len, 4, addr, len, hash);
-			memcpy(&buf[pos], hash, plen);
-			break;
-		}
-		counter++;
-	}
-}
-
 /* AES tables*/
 const u32 Te0[256] = {
 	0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,
@@ -2199,206 +1878,6 @@ const u8 rcons[] = {
 	    /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */
 };
 
-/**
- * Expand the cipher key into the encryption key schedule.
- *
- * @return	the number of rounds for the given cipher key size.
- */
-static void rijndaelKeySetupEnc(u32 rk[/*44 */], const u8 cipherKey[])
-{
-	int i;
-	u32 temp;
-
-	rk[0] = GETU32(cipherKey);
-	rk[1] = GETU32(cipherKey + 4);
-	rk[2] = GETU32(cipherKey + 8);
-	rk[3] = GETU32(cipherKey + 12);
-	for (i = 0; i < 10; i++) {
-		temp = rk[3];
-		rk[4] = rk[0] ^
-		    TE421(temp) ^ TE432(temp) ^ TE443(temp) ^ TE414(temp) ^
-		    RCON(i);
-		rk[5] = rk[1] ^ rk[4];
-		rk[6] = rk[2] ^ rk[5];
-		rk[7] = rk[3] ^ rk[6];
-		rk = rk + 4;
-	}
-}
-
-static void rijndaelEncrypt(u32 rk[/*44 */], u8 pt[16], u8 ct[16])
-{
-	u32 s0, s1, s2, s3, t0, t1, t2, t3;
-	int Nr = 10;
-	int r;
-
-	/*
-	 * map byte array block to cipher state
-	 * and add initial round key:
-	 */
-	s0 = GETU32(pt) ^ rk[0];
-	s1 = GETU32(pt + 4) ^ rk[1];
-	s2 = GETU32(pt + 8) ^ rk[2];
-	s3 = GETU32(pt + 12) ^ rk[3];
-
-#define ROUND(i, d, s)							\
-do {									\
-	d##0 = TE0(s##0) ^ TE1(s##1) ^ TE2(s##2) ^ TE3(s##3) ^ rk[4 * i]; \
-	d##1 = TE0(s##1) ^ TE1(s##2) ^ TE2(s##3) ^ TE3(s##0) ^ rk[4 * i + 1]; \
-	d##2 = TE0(s##2) ^ TE1(s##3) ^ TE2(s##0) ^ TE3(s##1) ^ rk[4 * i + 2]; \
-	d##3 = TE0(s##3) ^ TE1(s##0) ^ TE2(s##1) ^ TE3(s##2) ^ rk[4 * i + 3]; \
-} while (0)
-
-	/* Nr - 1 full rounds: */
-	r = Nr >> 1;
-	for (;;) {
-		ROUND(1, t, s);
-		rk = rk + 8;
-		if (--r == 0)
-			break;
-		ROUND(0, s, t);
-	}
-
-#undef ROUND
-
-	/*
-	 * apply last round and
-	 * map cipher state to byte array block:
-	 */
-	s0 = TE41(t0) ^ TE42(t1) ^ TE43(t2) ^ TE44(t3) ^ rk[0];
-	PUTU32(ct, s0);
-	s1 = TE41(t1) ^ TE42(t2) ^ TE43(t3) ^ TE44(t0) ^ rk[1];
-	PUTU32(ct + 4, s1);
-	s2 = TE41(t2) ^ TE42(t3) ^ TE43(t0) ^ TE44(t1) ^ rk[2];
-	PUTU32(ct + 8, s2);
-	s3 = TE41(t3) ^ TE42(t0) ^ TE43(t1) ^ TE44(t2) ^ rk[3];
-	PUTU32(ct + 12, s3);
-}
-
-static void *aes_encrypt_init(u8 *key, size_t len)
-{
-	u32 *rk;
-	if (len != 16)
-		return NULL;
-	rk = (u32 *)kmalloc(AES_PRIV_SIZE, GFP_KERNEL);
-	if (rk == NULL)
-		return NULL;
-	rijndaelKeySetupEnc(rk, key);
-	return rk;
-}
-
-static void aes_128_encrypt(void *ctx, u8 *plain, u8 *crypt)
-{
-	rijndaelEncrypt(ctx, plain, crypt);
-}
-
-static void gf_mulx(u8 *pad)
-{
-	int i, carry;
-
-	carry = pad[0] & 0x80;
-	for (i = 0; i < AES_BLOCK_SIZE - 1; i++)
-		pad[i] = (pad[i] << 1) | (pad[i + 1] >> 7);
-	pad[AES_BLOCK_SIZE - 1] <<= 1;
-	if (carry)
-		pad[AES_BLOCK_SIZE - 1] ^= 0x87;
-}
-
-static void aes_encrypt_deinit(void *ctx)
-{
-	memset(ctx, 0, AES_PRIV_SIZE);
-	kfree(ctx);
-}
-
-/**
- * omac1_aes_128_vector - One-Key CBC MAC (OMAC1) hash with AES-128
- * @key: 128-bit key for the hash operation
- * @num_elem: Number of elements in the data vector
- * @addr: Pointers to the data areas
- * @len: Lengths of the data blocks
- * @mac: Buffer for MAC (128 bits, i.e., 16 bytes)
- * Returns: 0 on success, -1 on failure
- *
- * This is a mode for using block cipher (AES in this case) for authentication.
- * OMAC1 was standardized with the name CMAC by NIST in a Special Publication
- * (SP) 800-38B.
- */
-static int omac1_aes_128_vector(u8 *key, size_t num_elem,
-				u8 *addr[], size_t *len, u8 *mac)
-{
-	void *ctx;
-	u8 cbc[AES_BLOCK_SIZE], pad[AES_BLOCK_SIZE];
-	u8 *pos, *end;
-	size_t i, e, left, total_len;
-
-	ctx = aes_encrypt_init(key, 16);
-	if (ctx == NULL)
-		return -1;
-	memset(cbc, 0, AES_BLOCK_SIZE);
-
-	total_len = 0;
-	for (e = 0; e < num_elem; e++)
-		total_len += len[e];
-	left = total_len;
-
-	e = 0;
-	pos = addr[0];
-	end = pos + len[0];
-
-	while (left >= AES_BLOCK_SIZE) {
-		for (i = 0; i < AES_BLOCK_SIZE; i++) {
-			cbc[i] ^= *pos++;
-			if (pos >= end) {
-				e++;
-				pos = addr[e];
-				end = pos + len[e];
-			}
-		}
-		if (left > AES_BLOCK_SIZE)
-			aes_128_encrypt(ctx, cbc, cbc);
-		left -= AES_BLOCK_SIZE;
-	}
-
-	memset(pad, 0, AES_BLOCK_SIZE);
-	aes_128_encrypt(ctx, pad, pad);
-	gf_mulx(pad);
-
-	if (left || total_len == 0) {
-		for (i = 0; i < left; i++) {
-			cbc[i] ^= *pos++;
-			if (pos >= end) {
-				e++;
-				pos = addr[e];
-				end = pos + len[e];
-			}
-		}
-		cbc[left] ^= 0x80;
-		gf_mulx(pad);
-	}
-
-	for (i = 0; i < AES_BLOCK_SIZE; i++)
-		pad[i] ^= cbc[i];
-	aes_128_encrypt(ctx, pad, mac);
-	aes_encrypt_deinit(ctx);
-	return 0;
-}
-
-/**
- * omac1_aes_128 - One-Key CBC MAC (OMAC1) hash with AES-128 (aka AES-CMAC)
- * @key: 128-bit key for the hash operation
- * @data: Data buffer for which a MAC is determined
- * @data_len: Length of data buffer in bytes
- * @mac: Buffer for MAC (128 bits, i.e., 16 bytes)
- * Returns: 0 on success, -1 on failure
- *
- * This is a mode for using block cipher (AES in this case) for authentication.
- * OMAC1 was standardized with the name CMAC by NIST in a Special Publication
- * (SP) 800-38B.
- */
-static int omac1_aes_128(u8 *key, u8 *data, size_t data_len, u8 *mac)
-{
-	return omac1_aes_128_vector(key, 1, &data, &data_len, mac);
-}
-
 void rtw_use_tkipkey_handler(void *FunctionContext)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)FunctionContext;
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -182,10 +182,6 @@ static void rtw_mfree_all_stainfo(struct
 
 static void rtw_mfree_sta_priv_lock(struct	sta_priv *pstapriv)
 {
-#ifdef CONFIG_92D_AP_MODE
-	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
-#endif
-
 	 rtw_mfree_all_stainfo(pstapriv); /* be done before free sta_hash_lock */
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -25,7 +25,6 @@ static unsigned char ATHEROS_OUI2[] = {0
 
 static unsigned char BROADCOM_OUI1[] = {0x00, 0x10, 0x18};
 static unsigned char BROADCOM_OUI2[] = {0x00, 0x0a, 0xf7};
-static unsigned char BROADCOM_OUI3[] = {0x00, 0x05, 0xb5};
 
 static unsigned char CISCO_OUI[] = {0x00, 0x40, 0x96};
 static unsigned char MARVELL_OUI[] = {0x00, 0x50, 0x43};
@@ -330,11 +329,6 @@ void Switch_DM_Func(struct rtw_adapter *
 	}
 }
 
-static void Set_NETYPE1_MSR(struct rtw_adapter *padapter, u8 type)
-{
-	rtw_hal_set_hwreg(padapter, HW_VAR_MEDIA_STATUS_SUCCESS, (u8 *)(&type));
-}
-
 static void Set_NETYPE0_MSR(struct rtw_adapter *padapter, u8 type)
 {
 	rtw_hal_set_hwreg(padapter, HW_VAR_MEDIA_STATUS, (u8 *)(&type));
@@ -382,8 +376,6 @@ inline void rtw_set_oper_choffset(struct
 
 void SelectChannel(struct rtw_adapter *padapter, unsigned char channel)
 {
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	/* saved channel info */
 	rtw_set_oper_ch(padapter, channel);
@@ -404,8 +396,6 @@ void SelectChannel(struct rtw_adapter *p
 
 void SetBWMode(struct rtw_adapter *padapter, unsigned short bwmode, unsigned char channel_offset)
 {
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	/* saved bw info */
 	rtw_set_oper_bw(padapter, bwmode);
@@ -429,7 +419,6 @@ void SetBWMode(struct rtw_adapter *padap
 void set_channel_bwmode(struct rtw_adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode)
 {
 	u8 center_ch;
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
 	if (padapter->bNotifyChannelChange)
 		DBG_8192D("[%s] ch = %d, offset = %d, bwmode = %d\n", __func__, channel, channel_offset, bwmode);
@@ -1187,19 +1176,6 @@ unsigned char get_highest_rate_idx(u32 m
 	return rate_idx;
 }
 
-static unsigned char get_highest_mcs_rate(struct HT_caps_element *pHT_caps)
-{
-	int i, mcs_rate;
-
-	mcs_rate = (pHT_caps->u.HT_cap_element.MCS_rate[0] | (pHT_caps->u.HT_cap_element.MCS_rate[1] << 8));
-
-	for (i = 15; i >= 0; i--) {
-		if (mcs_rate & (0x1 << i))
-			break;
-	}
-	return i;
-}
-
 void Update_RA_Entry(struct rtw_adapter *padapter, u32 mac_id)
 {
 	rtw_hal_update_ra_mask(padapter, mac_id);
@@ -1333,7 +1309,7 @@ void update_capinfo(struct rtw_adapter *
 {
 	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	bool		shortpreamble;
+	bool	shortpreamble = false;
 
 	/*  Check preamble mode, 2005.01.06, by rcnjko. */
 	/*  Mark to update preamble value forever, 2008.03.18 by lanhsin */
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -614,7 +614,6 @@ static s32 xmitframe_addmic(struct rtw_a
 	u8 *pframe, *payload, mic[8];
 	struct	mic_data micdata;
 	struct	sta_info *stainfo;
-	struct	qos_priv *pqospriv = &(padapter->mlmepriv.qospriv);
 	struct	pkt_attrib *pattrib = &pxmitframe->attrib;
 	struct	security_priv *psecuritypriv = &padapter->securitypriv;
 	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
@@ -1337,7 +1336,6 @@ struct xmit_frame *rtw_alloc_xmitframe(s
 	struct xmit_frame *pxframe = NULL;
 	struct list_head *plist, *phead;
 	struct __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
-	struct rtw_adapter *padapter = pxmitpriv->adapter;
 
 	spin_lock_bh(&pfree_xmit_queue->lock);
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -25,23 +25,6 @@
 #include <rtl8192d_hal.h>
 
 static bool
-CheckWriteH2C(
-	struct rtw_adapter *		adapter,
-	u8		BoxNum
-)
-{
-	u8	valHMETFR;
-	bool	Result = false;
-
-	valHMETFR = rtw_read8(adapter, REG_HMETFR);
-
-	if (((valHMETFR>>BoxNum)&BIT0) == 1)
-		Result = true;
-
-	return Result;
-}
-
-static bool
 CheckFwReadLastH2C(
 	struct rtw_adapter *		adapter,
 	u8		BoxNum
@@ -263,25 +246,6 @@ FillH2CCmd92D(
 	return;
 }
 
-static u8 rtl8192d_h2c_msg_hdl(struct rtw_adapter *padapter, unsigned char *pbuf)
-{
-	u8 ElementID, CmdLen;
-	u8 *pCmdBuffer;
-	struct cmd_msg_parm  *pcmdmsg;
-
-	if (!pbuf)
-		return H2C_PARAMETERS_ERROR;
-
-	pcmdmsg = (struct cmd_msg_parm*)pbuf;
-	ElementID = pcmdmsg->eid;
-	CmdLen = pcmdmsg->sz;
-	pCmdBuffer = pcmdmsg->buf;
-
-	FillH2CCmd92D(padapter, ElementID, CmdLen, pCmdBuffer);
-
-	return H2C_SUCCESS;
-}
-
 u8 rtl8192d_set_raid_cmd(struct rtw_adapter*padapter, u32 mask, u8 arg)
 {
 	u8	buf[5];
@@ -341,7 +305,6 @@ void rtl8192d_set_FwPwrMode_cmd(struct r
 	SET_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(u1H2CSetPwrMode, beacon_interval);
 
 	FillH2CCmd92D(padapter, H2C_SETPWRMODE, 3, u1H2CSetPwrMode);
-
 }
 
 static void ConstructBeacon(struct rtw_adapter *padapter, u8 *pframe, u32 *pLength)
@@ -624,7 +587,7 @@ static void SetFwRsvdPagePkt(struct rtw_
 	struct xmit_priv	*pxmitpriv = &(adapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(adapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	u32	BeaconLength, ProbeRspLength, PSPollLength, NullFunctionDataLength;
+	u32	BeaconLength = 0, ProbeRspLength = 0, PSPollLength, NullFunctionDataLength;
 	u8	*reservedpagepacket;
 	u8	PageNum=0, U1bTmp, TxDescLen=0, TxDescOffset=0;
 	u16	BufIndex=0;
@@ -654,8 +617,6 @@ static void SetFwRsvdPagePkt(struct rtw_
 		"SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: BCN\n",
 		&reservedpagepacket[BufIndex], (BeaconLength+BufIndex));
 
-/*  */
-
 	/*  When we count the first page size, we need to reserve description size for the RSVD */
 	/*  packet, it will be filled in front of the packet in TXPKTBUF. */
 	U1bTmp = (u8)PageNum_128(BeaconLength+TxDescLen);
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -496,7 +496,6 @@ static void odm_DIG(
 	static bool	bMediaConnect_0 = false;
 	static bool	bMediaConnect_1 = false;
 	bool		FirstConnect;
-	u8	TxRate = rtw_read8(adapter, REG_INIDATA_RATE_SEL);
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
 	struct hal_data_8192du *pbuddy_pHalData = GET_HAL_DATA(pbuddy_adapter);
@@ -813,33 +812,6 @@ static void odm_DIG(
 
 }
 
-static u8
-dm_initial_gain_MinPWDB(
-	struct rtw_adapter *	adapter
-	)
-{
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	s32	rssi_val_min = 0;
-	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
-
-	if ((dm_digtable->curmultistaconnectstate == DIG_MultiSTA_CONNECT) &&
-	   (dm_digtable->curstaconnectstate == DIG_STA_CONNECT)) {
-		if (pdmpriv->EntryMinUndecoratedSmoothedPWDB != 0)
-			rssi_val_min  =  (pdmpriv->EntryMinUndecoratedSmoothedPWDB > pdmpriv->UndecoratedSmoothedPWDB)?
-					pdmpriv->UndecoratedSmoothedPWDB:pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-		else
-			rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
-	}
-	else if (	dm_digtable->curstaconnectstate == DIG_STA_CONNECT ||
-			dm_digtable->curstaconnectstate == DIG_STA_BEFORE_CONNECT)
-		rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
-	else if (dm_digtable->curmultistaconnectstate == DIG_MultiSTA_CONNECT)
-		rssi_val_min = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-
-	return (u8)rssi_val_min;
-}
-
 static void dm_CCK_PacketDetectionThresh_DMSP(
 	struct rtw_adapter *	adapter)
 {
@@ -2386,8 +2358,6 @@ rtl8192d_HalDmWatchDog(
 		/* temporarily disable it advised for performance test by yn,2010-11-03. */
 		dm_DynamicBBPowerSaving(adapter);
 
-_record_initrate:
-
 		/*  Read REG_INIDATA_RATE_SEL value for TXDESC. */
 		if (check_fwstate(&adapter->mlmepriv, WIFI_STATION_STATE)) {
 			pdmpriv->INIDATA_RATE[0] = rtw_read8(adapter, REG_INIDATA_RATE_SEL) & 0x3f;
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -1802,7 +1802,6 @@ static s32 c2h_id_filter_ccx_8192d(u8 id
 static s32 c2h_handler_8192d(struct rtw_adapter *padapter, struct c2h_evt_hdr *c2h_evt)
 {
 	s32 ret = 1;
-	u8 i = 0;
 
 	if (c2h_evt == NULL) {
 		DBG_8192D("%s c2h_evt is NULL\n", __func__);
--- a/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
@@ -55,6 +55,120 @@
 #include <rtl8192d_hal.h>
 #include <Hal8192DPhyCfg.h>
 
+static u32 TargetChnl_5G[TARGET_CHNL_NUM_5G] = {
+	25141,	25116,	25091,	25066,	25041,
+	25016,	24991,	24966,	24941,	24917,
+	24892,	24867,	24843,	24818,	24794,
+	24770,	24765,	24721,	24697,	24672,
+	24648,	24624,	24600,	24576,	24552,
+	24528,	24504,	24480,	24457,	24433,
+	24409,	24385,	24362,	24338,	24315,
+	24291,	24268,	24245,	24221,	24198,
+	24175,	24151,	24128,	24105,	24082,
+	24059,	24036,	24013,	23990,	23967,
+	23945,	23922,	23899,	23876,	23854,
+	23831,	23809,	23786,	23764,	23741,
+	23719,	23697,	23674,	23652,	23630,
+	23608,	23586,	23564,	23541,	23519,
+	23498,	23476,	23454,	23432,	23410,
+	23388,	23367,	23345,	23323,	23302,
+	23280,	23259,	23237,	23216,	23194,
+	23173,	23152,	23130,	23109,	23088,
+	23067,	23046,	23025,	23003,	22982,
+	22962,	22941,	22920,	22899,	22878,
+	22857,	22837,	22816,	22795,	22775,
+	22754,	22733,	22713,	22692,	22672,
+	22652,	22631,	22611,	22591,	22570,
+	22550,	22530,	22510,	22490,	22469,
+	22449,	22429,	22409,	22390,	22370,
+	22350,	22336,	22310,	22290,	22271,
+	22251,	22231,	22212,	22192,	22173,
+	22153,	22134,	22114,	22095,	22075,
+	22056,	22037,	22017,	21998,	21979,
+	21960,	21941,	21921,	21902,	21883,
+	21864,	21845,	21826,	21807,	21789,
+	21770,	21751,	21732,	21713,	21695,
+	21676,	21657,	21639,	21620,	21602,
+	21583,	21565,	21546,	21528,	21509,
+	21491,	21473,	21454,	21436,	21418,
+	21400,	21381,	21363,	21345,	21327,
+	21309,	21291,	21273,	21255,	21237,
+	21219,	21201,	21183,	21166,	21148,
+	21130,	21112,	21095,	21077,	21059,
+	21042,	21024,	21007,	20989,	20972,
+	25679,	25653,	25627,	25601,	25575,
+	25549,	25523,	25497,	25471,	25446,
+	25420,	25394,	25369,	25343,	25318,
+	25292,	25267,	25242,	25216,	25191,
+	25166
+};
+
+static u32 TargetChnl_2G[TARGET_CHNL_NUM_2G] = {	/*  channel 1~14 */
+	26084, 26030, 25976, 25923, 25869, 25816, 25764,
+	25711, 25658, 25606, 25554, 25502, 25451, 25328
+};
+
+static u32 RF_REG_FOR_5G_SWCHNL_NORMAL[MAX_RF_IMR_INDEX_NORMAL] = {
+	0, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x0
+};
+
+static u8 RF_REG_for_C_CUT_5G[RF_REG_NUM_for_C_CUT_5G] = {
+	RF_SYN_G1, RF_SYN_G2, RF_SYN_G3, RF_SYN_G4, RF_SYN_G5, RF_SYN_G6
+};
+
+static u8 RF_REG_for_C_CUT_5G_internalPA[RF_REG_NUM_for_C_CUT_5G_internalPA] = {
+	0x0B, 0x48, 0x49, 0x4B,	0x03, 0x04, 0x0E
+};
+
+static u8 RF_REG_for_C_CUT_2G[RF_REG_NUM_for_C_CUT_2G] = {
+	RF_SYN_G1, RF_SYN_G2, RF_SYN_G3, RF_SYN_G7, RF_SYN_G8
+};
+
+static u8 RF_CHNL_5G[RF_CHNL_NUM_5G] = {
+	36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112,
+	116, 120, 124, 128, 132, 136, 140
+};
+
+static u8 RF_CHNL_5G_40M[RF_CHNL_NUM_5G_40M] = {
+	38, 42, 46, 50, 54, 58, 62, 102, 106, 110, 114, 118,
+	122, 126, 130, 134, 138
+};
+
+static u32 RF_REG_Param_for_C_CUT_5G[5][RF_REG_NUM_for_C_CUT_5G] = {
+	{0xE43BE, 0xFC638, 0x77C0A, 0xDE471, 0xd7110, 0x8EB04},
+	{0xE43BE, 0xFC078, 0xF7C1A, 0xE0C71, 0xD7550, 0xAEB04},
+	{0xE43BF, 0xFF038, 0xF7C0A, 0xDE471, 0xE5550, 0xAEB04},
+	{0xE43BF, 0xFF079, 0xF7C1A, 0xDE471, 0xE5550, 0xAEB04},
+	{0xE43BF, 0xFF038, 0xF7C1A, 0xDE471, 0xd7550, 0xAEB04}
+};
+
+static u32 RF_REG_Param_for_C_CUT_2G[3][RF_REG_NUM_for_C_CUT_2G] = {
+	{0x643BC, 0xFC038, 0x77C1A, 0x41289, 0x01840},
+	{0x643BC, 0xFC038, 0x07C1A, 0x41289, 0x01840},
+	{0x243BC, 0xFC438, 0x07C1A, 0x4128B, 0x0FC41}
+};
+
+static u32 RF_REG_SYN_G4_for_C_CUT_2G = 0xD1C31&0x7FF;
+
+static u32 RF_REG_Param_for_C_CUT_5G_internalPA[3][RF_REG_NUM_for_C_CUT_5G_internalPA] = {
+	{0x01a00, 0x40443, 0x00eb5, 0x89bec, 0x94a12, 0x94a12, 0x94a12},
+	{0x01800, 0xc0443, 0x00730, 0x896ee, 0x94a52, 0x94a52, 0x94a52},
+	{0x01800, 0xc0443, 0x00730, 0x896ee, 0x94a12, 0x94a12, 0x94a12}
+};
+
+/* mode][patha+b][reg] */
+static u32 RF_IMR_Param_Normal[3][MAX_RF_IMR_INDEX_NORMAL] = {
+	{0x70000, 0x00ff0, 0x4400f, 0x00ff0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x64888,
+	 0xe266c, 0x00090, 0x22fff},/*  channel 1-14. */
+	{0x70000, 0x22880, 0x4470f, 0x55880, 0x00070, 0x88000, 0x0, 0x88080,
+	 0x70000, 0x64a82, 0xe466c, 0x00090, 0x32c9a}, /* path 36-64 */
+	{0x70000, 0x44880, 0x4477f, 0x77880, 0x00070, 0x88000, 0x0, 0x880b0,
+	 0x0, 0x64b82, 0xe466c, 0x00090,0x32c9a} /* 100 -165 */
+};
+
+static u32 CurveIndex[TARGET_CHNL_NUM_2G_5G] = {0};
+
+
 /*---------------------Define local function prototype-----------------------*/
 static void phy_PathAFillIQKMatrix(struct rtw_adapter *adapter, bool bIQKOK,
 				   int result[][8], u8 final_candidate,
@@ -239,33 +353,6 @@ rtl8192d_PHY_SetBBReg(
 
 /*  */
 /*  2. RF register R/W API */
-/*  */
-/*-----------------------------------------------------------------------------
- * Function:	phy_FwRFSerialRead()
- *
- * Overview:	We support firmware to execute RF-R/W.
- *
- * Input:		NONE
- *
- * Output:		NONE
- *
- * Return:		NONE
- *
- * Revised History:
- *	When		Who		Remark
- *	01/21/2008	MHC		Create Version 0.
- *
- *---------------------------------------------------------------------------*/
-static	u32
-phy_FwRFSerialRead(
-	struct rtw_adapter *			adapter,
-	enum RF_RADIO_PATH_E	eRFPath,
-	u32				Offset	)
-{
-	u32		retValue = 0;
-	return	(retValue);
-}	/* phy_FwRFSerialRead */
-
 /**
 * Function:	phy_RFSerialRead
 *
@@ -566,25 +653,17 @@ rtl8192d_PHY_SetRFReg(
  * Note:		The format of MACPHY_REG.txt is different from PHY and RF.
  *			[Register][Mask][Value]
  *---------------------------------------------------------------------------*/
-static	int
-phy_ConfigMACWithHeaderFile(
-	struct rtw_adapter *		adapter
-)
+static	int phy_ConfigMACWithHeaderFile(struct rtw_adapter *adapter)
 {
-	u32					i = 0;
-	u32					ArrayLength = 0;
-	u32*				ptrArray;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
-
-	/* 2008.11.06 Modified by tynli. */
+	u32 i;
+	u32 ArrayLength;
+	u32 *ptrArray;
 
 	ArrayLength = Rtl8192D_MAC_ArrayLength;
 	ptrArray = (u32 *)Rtl8192D_MAC_Array;
 
-	for (i = 0 ;i < ArrayLength;i = i+2) { /*  Add by tynli for 2 column */
+	for (i = 0 ;i < ArrayLength;i = i+2) /*  Add by tynli for 2 column */
 		rtw_write8(adapter, ptrArray[i], (u8)ptrArray[i+1]);
-	}
-
 	return 1;
 }
 
@@ -913,7 +992,6 @@ phy_ConfigBBWithPgHeaderFile(
 	int i;
 	u32*	Rtl819XPHY_REGArray_Table_PG;
 	u16	PHY_REGArrayPGLen;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
 	PHY_REGArrayPGLen = Rtl8192D_PHY_REG_Array_PGLength;
 	Rtl819XPHY_REGArray_Table_PG = (u32 *)Rtl8192D_PHY_REG_Array_PG;
@@ -2319,7 +2397,7 @@ static  void
 		IMR_NUM = MAX_RF_IMR_INDEX_NORMAL;
 
 		for (i = 0; i<IMR_NUM; i++) {
-			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_REG_FOR_5G_SWCHNL_NORMAL[i], RFMask, RF_IMR_Param_Normal[0][group][i]);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_REG_FOR_5G_SWCHNL_NORMAL[i], RFMask, RF_IMR_Param_Normal[group][i]);
 		}
 		PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000, 0);
 		PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 2);
@@ -2332,7 +2410,7 @@ static  void
 
 			IMR_NUM = MAX_RF_IMR_INDEX_NORMAL;
 			for (i = 0; i<IMR_NUM; i++) {
-				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_REG_FOR_5G_SWCHNL_NORMAL[i], bRFRegOffsetMask, RF_IMR_Param_Normal[0][0][i]);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_REG_FOR_5G_SWCHNL_NORMAL[i], bRFRegOffsetMask, RF_IMR_Param_Normal[0][i]);
 			}
 			PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000, 0);
 			PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 3);
@@ -2607,42 +2685,12 @@ PHY_SwChnl8192D(	/*  Call after initiali
 	}
 }
 
-static	bool
-phy_SetSwChnlCmdArray(
-	struct sw_chnl_cmd *cmdtable,
-	u32			cmdtableidx,
-	u32			cmdtablesz,
-	enum swchnl_cmdid	cmdid,
-	u32			para1,
-	u32			para2,
-	u32			msdelay
-	)
-{
-	struct sw_chnl_cmd *cmd;
-
-	if (cmdtable == NULL)
-		return false;
-	if (cmdtableidx >= cmdtablesz)
-		return false;
-
-	cmd = cmdtable + cmdtableidx;
-	cmd->cmdid = cmdid;
-	cmd->Para1 = para1;
-	cmd->Para2 = para2;
-	cmd->msDelay = msdelay;
-
-	return true;
-}
-
-/*  */
 /*  Description: */
 /*	Switch channel synchronously. Called by SwChnlByDelayHandler. */
-/*  */
 /*  Implemented by Bruce, 2008-02-14. */
 /*  The following procedure is operted according to SwChanlCallback8190Pci(). */
 /*  However, this procedure is performed synchronously  which should be running under */
 /*  passive level. */
-/*  */
 void
 PHY_SwChnlPhy8192D(	/*  Only called during initialize */
 	struct rtw_adapter *	adapter,
@@ -3662,382 +3710,6 @@ phy_IQCalibrate(
 }
 
 static void
-phy_IQCalibrate_5G(
-	struct rtw_adapter *	adapter,
-	int		result[][8]
-	)
-{
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	u32			extPAon, REG0xe5c, RX0REG0xe40, REG0xe40, REG0xe94;
-	u32			REG0xeac, RX1REG0xe40, REG0xeb4, REG0xea4, REG0xec4;
-	u8			TX0IQKOK = false, TX1IQKOK = false ;
-	u32			TX_X0, TX_Y0, TX_X1, TX_Y1, RX_X0, RX_Y0, RX_X1, RX_Y1;
-	u32			ADDA_REG[IQK_ADDA_REG_NUM] = {
-						rFPGA0_XCD_SwitchControl,	rBlue_Tooth,
-						rRx_Wait_CCA,		rTx_CCK_RFON,
-						rTx_CCK_BBON,	rTx_OFDM_RFON,
-						rTx_OFDM_BBON,	rTx_To_Rx,
-						rTx_To_Tx,		rRx_CCK,
-						rRx_OFDM,		rRx_Wait_RIFS,
-						rRx_TO_Rx,		rStandby,
-						rSleep,				rPMPD_ANAEN };
-
-	u32			IQK_MAC_REG[IQK_MAC_REG_NUM] = {
-						REG_TXPAUSE,		REG_BCN_CTRL,
-						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
-
-	u32			IQK_BB_REG[IQK_BB_REG_NUM_test] = {	/* for normal */
-						rFPGA0_XAB_RFInterfaceSW,	rOFDM0_TRMuxPar,
-						rFPGA0_XCD_RFInterfaceSW,	rOFDM0_TRxPathEnable,
-						rFPGA0_RFMOD,			rFPGA0_AnalogParameter4
-					};
-
-	bool			is2T =  IS_92D_SINGLEPHY(pHalData->VersionID);
-
-	DBG_8192D("IQK for 5G:Start!!!interface %d\n", pHalData->interfaceIndex);
-
-	DBG_8192D("IQ Calibration for %s\n", (is2T ? "2T2R" : "1T1R"));
-
-	/* Save MAC default value */
-	phy_SaveMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
-
-	/* Save BB Parameter */
-	phy_SaveADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_test);
-
-	/* Save AFE Parameters */
-	phy_SaveADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
-
-	/* 1 Path-A TX IQK */
-	/* Path-A AFE all on */
-	phy_PathADDAOn(adapter, ADDA_REG, true, true);
-
-	/* MAC register setting */
-	phy_MACSettingCalibration(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
-
-	/* IQK must be done in PI mode */
-	pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter1, BIT(8));
-	if (!pdmpriv->bRfPiEnable)
-		phy_PIModeSwitch(adapter, true);
-
-	/* TXIQK RF setting */
-	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01940000);
-	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01940000);
-
-	/* BB setting */
-	PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
-	PHY_SetBBReg(adapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
-	PHY_SetBBReg(adapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
-	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT6|BIT5,  0x03);
-	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT22|BIT21,  0x03);
-	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xf00000,  0x0f);
-
-	/* AP or IQK */
-	PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x0f600000);
-	PHY_SetBBReg(adapter, rConfig_AntB, bMaskDWord, 0x0f600000);
-
-	/* IQK global setting */
-	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
-	PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, 0x10007c00);
-	PHY_SetBBReg(adapter, rRx_IQK, bMaskDWord, 0x01004800);
-
-	/* path-A IQK setting */
-	if (pHalData->interfaceIndex == 0)
-	{
-		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
-		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c1f);
-	}
-	else
-	{
-		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c22);
-		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c22);
-	}
-
-	if (is2T)
-		PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x821402e2);
-	else
-		PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x821402e6);
-	PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
-
-	/* path-B IQK setting */
-	if (is2T)
-	{
-		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
-		PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x30008c22);
-		PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-		PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
-	}
-
-	/* LO calibration setting */
-	PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
-
-	/* One shot, path A LOK & IQK */
-	PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-	PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
-
-	/* Delay 1 ms */
-	udelay(IQK_DELAY_TIME*1000);
-
-	/* Exit IQK mode */
-	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
-
-	/* Check_TX_IQK_A_result() */
-	REG0xe40 = PHY_QueryBBReg(adapter, rTx_IQK, bMaskDWord);
-	REG0xeac = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-	REG0xe94 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord);
-
-	if (((REG0xeac&BIT(28)) == 0) && (((REG0xe94&0x3FF0000)>>16)!= 0x142))
-	{
-		TX_X0 = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-		TX_Y0 = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-		RX0REG0xe40 =  0x80000000 | (REG0xe40 & 0xfc00fc00) | (TX_X0<<16) | TX_Y0;
-		result[0][0] = TX_X0;
-		result[0][1] = TX_Y0;
-		TX0IQKOK = true;
-		DBG_8192D("IQK for 5G: Path A TxOK interface %u\n", pHalData->interfaceIndex);
-	}
-	else
-	{
-		DBG_8192D("IQK for 5G: Path A Tx Fail interface %u\n", pHalData->interfaceIndex);
-	}
-
-	/* 1 path A RX IQK */
-	if (TX0IQKOK == true)
-	{
-
-		DBG_8192D("IQK for 5G: Path A Rx  START interface %u\n", pHalData->interfaceIndex);
-
-		/* TXIQK RF setting */
-		PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
-		PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
-
-		/* turn on external PA */
-		if (pHalData->interfaceIndex == 1)
-			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT(30), 0x01);
-
-		/* IQK global setting */
-		PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
-
-		/* path-A IQK setting */
-		if (pHalData->interfaceIndex == 0)
-		{
-			PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
-			PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
-		}
-		else
-		{
-			PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c22);
-			PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x14008c22);
-		}
-		PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
-		if (pHalData->interfaceIndex == 0)
-			PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, (pHalData->CurrentChannel<= 140)?0x68160c62:0x68160c66);
-		else
-			PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68160962);
-
-		/* path-B IQK setting */
-		if (is2T)
-		{
-			PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
-			PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x14008c22);
-			PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-			PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
-		}
-
-		/* load TX0 IMR setting */
-		PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, RX0REG0xe40);
-		/* Sleep(5) -> delay 1ms */
-		udelay(IQK_DELAY_TIME*1000);
-
-		/* LO calibration setting */
-		PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
-
-		/* One shot, path A LOK & IQK */
-		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
-		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
-
-		/* Delay 3 ms */
-		udelay(3*IQK_DELAY_TIME*1000);
-
-		/* Exit IQK mode */
-		PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
-
-		/* Check_RX_IQK_A_result() */
-		REG0xeac = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-		REG0xea4 = PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
-		if (pHalData->interfaceIndex == 0)
-		{
-			if (((REG0xeac&BIT(27)) == 0) && (((REG0xea4&0x3FF0000)>>16)!= 0x132))
-			{
-				RX_X0 =  (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
-				RX_Y0 =  (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
-				result[0][2] = RX_X0;
-				result[0][3] = RX_Y0;
-			}
-		}
-		else
-		{
-			if (((REG0xeac&BIT(30)) == 0) && (((REG0xea4&0x3FF0000)>>16)!= 0x132))
-			{
-				RX_X0 =  (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
-				RX_Y0 =  (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
-				result[0][2] = RX_X0;
-				result[0][3] = RX_Y0;
-			}
-		}
-	}
-
-	if (!is2T)
-		goto Exit_IQK;
-
-	/* 1 path B TX IQK */
-	/* Path-B AFE all on */
-
-	DBG_8192D("IQK for 5G: Path B Tx  START interface %u\n", pHalData->interfaceIndex);
-
-	phy_PathADDAOn(adapter, ADDA_REG, false, true);
-
-	/* TXIQK RF setting */
-	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01940000);
-	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01940000);
-
-	/* IQK global setting */
-	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
-	PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, 0x10007c00);
-
-	/* path-A IQK setting */
-	PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
-	PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c1f);
-	PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
-	PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
-
-	/* path-B IQK setting */
-	PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
-	PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x30008c22);
-	PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82140386);
-	PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
-
-	/* LO calibration setting */
-	PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
-
-	/* One shot, path A LOK & IQK */
-	PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
-	PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
-
-	/* Delay 1 ms */
-	udelay(IQK_DELAY_TIME*1000);
-
-	/* Exit IQK mode */
-	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
-
-	/*  Check_TX_IQK_B_result() */
-	REG0xe40 = PHY_QueryBBReg(adapter, rTx_IQK, bMaskDWord);
-	REG0xeac = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-	REG0xeb4 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord);
-	if (((REG0xeac&BIT(31)) == 0) && ((REG0xeb4&0x3FF0000)!= 0x142))
-	{
-		TX_X1 = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
-		TX_Y1 = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
-		RX1REG0xe40 = 0x80000000 | (REG0xe40 & 0xfc00fc00) | (TX_X1<<16) | TX_Y1;
-		result[0][4] = TX_X1;
-		result[0][5] = TX_Y1;
-		TX1IQKOK = true;
-	}
-
-	/* 1 path B RX IQK */
-	if (TX1IQKOK == true)
-	{
-
-		DBG_8192D("IQK for 5G: Path B Rx  START interface %u\n", pHalData->interfaceIndex);
-
-		if (pHalData->CurrentChannel<= 140)
-		{
-			REG0xe5c = 0x68160960;
-			extPAon = 0x1;
-		}
-		else
-		{
-			REG0xe5c = 0x68150c66;
-			extPAon = 0x0;
-		}
-
-		/* TXIQK RF setting */
-		PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
-		PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
-
-		/* turn on external PA */
-		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT(30), extPAon);
-
-		/* BB setting */
-		PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, bMaskDWord, 0xcc300080);
-
-		/* IQK global setting */
-		PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
-
-		/* path-A IQK setting */
-		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
-		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x34008c1f);
-		PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
-		PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
-
-		/* path-B IQK setting */
-		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
-		PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x14008c22);
-		PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
-		PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, REG0xe5c);
-
-		/* load TX0 IMR setting */
-		PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, RX1REG0xe40);
-
-		/* Sleep(5) -> delay 1ms */
-		udelay(IQK_DELAY_TIME*1000);
-
-		/* LO calibration setting */
-		PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
-
-		/* One shot, path A LOK & IQK */
-		PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
-		PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
-
-		/* Delay 1 ms */
-		udelay(3*IQK_DELAY_TIME*1000);
-
-		/* Check_RX_IQK_B_result() */
-		REG0xeac = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-		REG0xec4 = PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
-		if (((REG0xeac&BIT(30)) == 0) && (((REG0xec4&0x3FF0000)>>16)!= 0x132))
-		{
-			RX_X1 =  (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
-			RX_Y1 =  (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
-			result[0][6] = RX_X1;
-			result[0][7] = RX_Y1;
-		}
-	}
-
-Exit_IQK:
-	/* turn off external PA */
-	if (pHalData->interfaceIndex == 1 || is2T)
-		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT(30), 0);
-
-	/* Exit IQK mode */
-	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
-	phy_ReloadADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_test);
-
-	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
-	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
-	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032fff);
-	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032fff);
-
-	/* reload MAC default value */
-	phy_ReloadMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
-
-	if (!pdmpriv->bRfPiEnable)
-		phy_PIModeSwitch(adapter, false);
-	/* Reload ADDA power saving parameters */
-	phy_ReloadADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
-}
-
-static void
 phy_IQCalibrate_5G_Normal(
 	struct rtw_adapter *	adapter,
 	int		result[][8],
@@ -4313,7 +3985,7 @@ phy_LCCalibrate92DSW(
 	u8	RF_mode[2], tmpReg, index = 0;
 	u32	tmpu4Byte[2];
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
-	u8	u1bTmp = 0, path = is2T?2:1;
+	u8	path = is2T ? 2 : 1;
 	u32	i, u4tmp, offset;
 	u32	curveCountVal[CV_CURVE_CNT*2]={0};
 	u16	timeout = 800, timecount = 0;
@@ -4437,115 +4109,6 @@ static void phy_LCCalibrate(struct rtw_a
 #define		APK_CURVE_REG_NUM 4
 #define		PATH_NUM		2
 
-static void phy_APCalibrate(struct rtw_adapter *adapter, char delta, bool is2T)
-{
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
-	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	u32 regD[PATH_NUM];
-	u32 tmpReg, index, offset, path, i, pathbound = PATH_NUM, apkbound;
-
-	u32 BB_backup[APK_BB_REG_NUM];
-	u32 BB_REG[APK_BB_REG_NUM] = {
-		rFPGA1_TxBlock,		rOFDM0_TRxPathEnable,
-		rFPGA0_RFMOD,	rOFDM0_TRMuxPar,
-		rFPGA0_XCD_RFInterfaceSW,	rFPGA0_XAB_RFInterfaceSW,
-		rFPGA0_XA_RFInterfaceOE,	rFPGA0_XB_RFInterfaceOE
-	};
-	u32 BB_AP_MODE[APK_BB_REG_NUM] = {
-		0x00000020, 0x00a05430, 0x02040000,
-		0x000800e4, 0x00204000
-	};
-	u32 BB_normal_AP_MODE[APK_BB_REG_NUM] = {
-		0x00000020, 0x00a05430, 0x02040000,
-		0x000800e4, 0x22204000
-	};
-
-	u32 AFE_backup[IQK_ADDA_REG_NUM];
-	u32 AFE_REG[IQK_ADDA_REG_NUM] = {
-		rFPGA0_XCD_SwitchControl, rBlue_Tooth,
-		rRx_Wait_CCA, rTx_CCK_RFON,
-		rTx_CCK_BBON, rTx_OFDM_RFON,
-		rTx_OFDM_BBON, rTx_To_Rx,
-		rTx_To_Tx, rRx_CCK,
-		rRx_OFDM, rRx_Wait_RIFS,
-		rRx_TO_Rx, rStandby,
-		rSleep, rPMPD_ANAEN
-	};
-
-	u32 MAC_backup[IQK_MAC_REG_NUM];
-	u32 MAC_REG[IQK_MAC_REG_NUM] = {
-		REG_TXPAUSE,		REG_BCN_CTRL,
-		REG_BCN_CTRL_1,	REG_GPIO_MUXCFG
-	};
-
-	u32 APK_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
-		{0x0852c, 0x1852c, 0x5852c, 0x1852c, 0x5852c},
-		{0x2852e, 0x0852e, 0x3852e, 0x0852e, 0x0852e}
-	};
-
-	u32 APK_normal_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
-		{0x0852c, 0x0a52c, 0x3a52c, 0x5a52c, 0x5a52c},	/* path settings equal to path b settings */
-		{0x0852c, 0x0a52c, 0x5a52c, 0x5a52c, 0x5a52c}
-	};
-
-	u32 APK_RF_value_0[PATH_NUM][APK_BB_REG_NUM] = {
-		{0x52019, 0x52014, 0x52013, 0x5200f, 0x5208d},
-		{0x5201a, 0x52019, 0x52016, 0x52033, 0x52050}
-	};
-
-	u32 APK_normal_RF_value_0[PATH_NUM][APK_BB_REG_NUM] = {
-		{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a},	/* path settings equal to path b settings */
-		{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a}
-	};
-	u32 AFE_on_off[PATH_NUM] = {
-		0x04db25a4, 0x0b1b25a4i
-	};	/* path A on path B off / path A off path B on */
-
-	u32 APK_offset[PATH_NUM] = {
-		rConfig_AntA, rConfig_AntB
-	};
-
-	u32 APK_normal_offset[PATH_NUM] = {
-		rConfig_Pmpd_AntA, rConfig_Pmpd_AntB
-	};
-
-	u32 APK_value[PATH_NUM] = {
-		0x92fc0000, 0x12fc0000
-	};
-
-	u32 APK_normal_value[PATH_NUM] = {
-		0x92680000, 0x12680000
-	};
-
-	char APK_delta_mapping[APK_BB_REG_NUM][13] = {
-		{-4, -3, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
-		{-4, -3, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
-		{-6, -4, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
-		{-1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6},
-		{-11, -9, -7, -5, -3, -1, 0, 0, 0, 0, 0, 0, 0}
-	};
-
-	u32 APK_normal_setting_value_1[13] = {
-		0x01017018, 0xf7ed8f84, 0x1b1a1816, 0x2522201e, 0x322e2b28,
-		0x433f3a36, 0x5b544e49, 0x7b726a62, 0xa69a8f84, 0xdfcfc0b3,
-		0x12680000, 0x00880000, 0x00880000
-	};
-
-	u32 APK_normal_setting_value_2[16] = {
-		0x01c7021d, 0x01670183, 0x01000123, 0x00bf00e2, 0x008d00a3,
-		0x0068007b, 0x004d0059, 0x003a0042, 0x002b0031, 0x001f0025,
-		0x0017001b, 0x00110014, 0x000c000f, 0x0009000b, 0x00070008,
-		0x00050006
-	};
-
-	u32 APK_result[PATH_NUM][APK_BB_REG_NUM];	/* val_1_1a, val_1_2a, val_2a, val_3a, val_4a */
-
-	int BB_offset, delta_V, delta_offset;
-
-	if (!is2T)
-		pathbound = 1;
-}
-
 static void phy_SetRFPathSwitch(
 	struct rtw_adapter *	adapter,
 	bool		main,
@@ -4740,7 +4303,6 @@ rtl8192d_PHY_LCCalibrate(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 	bool		bStartContTx = false, bSingleTone = false, bCarrierSuppression = false;
-	u32			timeout = 2000, timecount = 0;
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
 	struct mlme_priv	*pmlmeprivBuddyadapter;
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
@@ -64,9 +64,6 @@ struct rf_shadow_compare_map {
 /*------------------------Define global variable-----------------------------*/
 
 /*------------------------Define local variable------------------------------*/
-/*  2008/11/20 MH For Debug only, RF */
-static	struct rf_shadow_compare_map RF_Shadow[RF6052_MAX_PATH][RF6052_MAX_REG];
-/*------------------------Define local variable------------------------------*/
 
 /*-----------------------------------------------------------------------------
  * Function:    PHY_RF6052SetBandwidth()
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
@@ -68,17 +68,6 @@ static s32 signal_scale_mapping(struct r
 	return ret_sig;
 }
 
-static s32  translate2dbm(u8 signal_strength_idx)
-{
-	s32	signal_power; /*  in dBm. */
-
-	/*  Translate to dBm (x=0.5y-95). */
-	signal_power = (s32)((signal_strength_idx + 1) >> 1);
-	signal_power -= 95;
-
-	return signal_power;
-}
-
 static void query_rx_phy_status(struct recv_frame_hdr *prframe, struct phy_stat *pphy_stat, bool bPacketMatchBSSID)
 {
 	struct phy_ofdm_rx_status_report_8192cd	*pOfdm_buf;
@@ -364,7 +353,6 @@ static void query_rx_phy_status(struct r
 
 static void process_rssi(struct rtw_adapter *padapter,struct recv_frame_hdr *prframe)
 {
-	u32	last_rssi, tmp_val;
 	struct rx_pkt_attrib *pattrib = &prframe->attrib;
 	struct signal_stat * signal_stat = &padapter->recvpriv.signal_strength_data;
 
@@ -433,7 +421,6 @@ static void process_PWDB(struct rtw_adap
 
 static void process_link_qual(struct rtw_adapter *padapter,struct recv_frame_hdr *prframe)
 {
-	u32	last_evm=0,  tmpVal;
 	struct rx_pkt_attrib *pattrib;
 	struct signal_stat * signal_stat;
 
--- a/drivers/staging/rtl8192du/hal/rtl8192du_led.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_led.c
@@ -1184,124 +1184,6 @@ static void BlinkWorkItemCallback(struct
 /*  Default LED behavior. */
 /*  */
 
-/*  */
-/*	Description: */
-/*		Implement each led action for SW_LED_MODE0. */
-/*		This is default strategy. */
-/*  */
-static void SwLedControlMode0(
-	struct rtw_adapter		*padapter,
-	enum LED_CTL_MODE		LedAction
-)
-{
-	struct led_priv	*ledpriv = &(padapter->ledpriv);
-	struct LED_871X *	pled = &(ledpriv->SwLed1);
-
-	/*  Decide led state */
-	switch (LedAction)
-	{
-	case LED_CTL_TX:
-	case LED_CTL_RX:
-		if (pled->blink_in_prog == false)
-		{
-			pled->blink_in_prog = true;
-
-			pled->currledstate = LED_BLINK_NORMAL;
-			pled->blinktimes = 2;
-
-			if (pled->led_on)
-				pled->blinkingledstate = RTW_LED_OFF;
-			else
-				pled->blinkingledstate = RTW_LED_ON;
-			_set_timer(&(pled->blinktimer), LED_BLINK_NORMAL_INTERVAL);
-		}
-		break;
-
-	case LED_CTL_START_TO_LINK:
-		if (pled->blink_in_prog == false)
-		{
-			pled->blink_in_prog = true;
-
-			pled->currledstate = LED_BLINK_StartToBlink;
-			pled->blinktimes = 24;
-
-			if (pled->led_on)
-				pled->blinkingledstate = RTW_LED_OFF;
-			else
-				pled->blinkingledstate = RTW_LED_ON;
-			_set_timer(&(pled->blinktimer), LED_BLINK_SLOWLY_INTERVAL);
-		}
-		else
-		{
-			pled->currledstate = LED_BLINK_StartToBlink;
-		}
-		break;
-
-	case LED_CTL_LINK:
-		pled->currledstate = RTW_LED_ON;
-		if (pled->blink_in_prog == false)
-		{
-			SwLedOn(padapter, pled);
-		}
-		break;
-
-	case LED_CTL_NO_LINK:
-		pled->currledstate = RTW_LED_OFF;
-		if (pled->blink_in_prog == false)
-		{
-			SwLedOff(padapter, pled);
-		}
-		break;
-
-	case LED_CTL_POWER_OFF:
-		pled->currledstate = RTW_LED_OFF;
-		pled->blinkingledstate = RTW_LED_OFF;
-
-		if (pled->blink_in_prog)
-		{
-			del_timer_sync(&(pled->blinktimer));
-			pled->blink_in_prog = false;
-		}
-		SwLedOff(padapter, pled);
-		break;
-
-	case LED_CTL_START_WPS:
-		if (pled->blink_in_prog == false || pled->currledstate == RTW_LED_ON)
-		{
-			pled->blink_in_prog = true;
-
-			pled->currledstate = LED_BLINK_WPS;
-			pled->blinktimes = 20;
-
-			if (pled->led_on)
-			{
-				pled->blinkingledstate = RTW_LED_OFF;
-				_set_timer(&(pled->blinktimer), LED_BLINK_LONG_INTERVAL);
-			}
-			else
-			{
-				pled->blinkingledstate = RTW_LED_ON;
-				_set_timer(&(pled->blinktimer), LED_BLINK_LONG_INTERVAL);
-			}
-		}
-		break;
-
-	case LED_CTL_STOP_WPS:
-		if (pled->blink_in_prog)
-		{
-			pled->currledstate = RTW_LED_OFF;
-			del_timer_sync(&(pled->blinktimer));
-			pled->blink_in_prog = false;
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pled->currledstate));
-}
-
  /* ALPHA, added by chiyoko, 20090106 */
 static void SwLedControlMode1(
 	struct rtw_adapter		*padapter,
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -328,84 +328,6 @@ static u8 _InitPowerOn(struct rtw_adapte
 	return ret;
 }
 
-static u16 CRC16(u8 data, u16 CRC)
-{
-	unsigned char shift_in, CRC_BIT15, DataBit, CRC_BIT11, CRC_BIT4 ;
-	int index;
-	unsigned short CRC_Result;
-
-	for (index = 0;index<8;index++)
-	{
-		CRC_BIT15 = ((CRC&BIT15) ? 1:0);
-		DataBit  = (data&(BIT0<<index) ? 1:0);
-		shift_in = CRC_BIT15^DataBit;
-		/* printf("CRC_BIT15 =%d, DataBit =%d, shift_in =%d\n", CRC_BIT15, DataBit, shift_in); */
-
-		CRC_Result = CRC<<1;
-		/* set BIT0 */
-		/*	printf("CRC =%x\n", CRC_Result); */
-		/* CRC bit 0 = shift_in, */
-		if (shift_in == 0)
-		{
-			CRC_Result&= (~BIT0);
-		}
-		else
-		{
-			CRC_Result|= BIT0;
-		}
-		/* printf("CRC =%x\n", CRC_Result); */
-
-		CRC_BIT11 = ((CRC&BIT11) ? 1:0)^shift_in;
-		if (CRC_BIT11 == 0)
-		{
-			CRC_Result&= (~BIT12);
-		}
-		else
-		{
-			CRC_Result|= BIT12;
-		}
-		/* printf("bit12 CRC =%x\n", CRC_Result); */
-
-		CRC_BIT4 = ((CRC&BIT4) ? 1:0)^shift_in;
-		if (CRC_BIT4 == 0)
-		{
-			CRC_Result&= (~BIT5);
-		}
-		else
-		{
-			CRC_Result|= BIT5;
-		}
-		/* printf("bit5 CRC =%x\n", CRC_Result); */
-
-		CRC = CRC_Result; /* repeat using the last result */
-	}
-
-	return CRC;
-}
-
-/*  */
-/*  */
-/* function name :calc_crc */
-/*  */
-/* input         : char* pattern , pattern size */
-/*  */
-/*  */
-static u16 calc_crc(u8 *pdata, int length)
-{
-/*     unsigned char data[2]={0xC6, 0xAA}; */
-	u16 CRC = 0xffff;
-	int i;
-
-	for (i = 0;i<length;i++)
-	{
-		CRC = CRC16(pdata[i], CRC);
-	}
-
-	CRC =~CRC;                  /* get 1' complement */
-	DBG_8192D("CRC =%x\n", CRC);
-	return CRC;
-}
-
 #ifdef CONFIG_WAKE_ON_WLAN
 static int rtw_wowlan_set_pattern(struct rtw_adapter *padapter , u8 *pbuf) {
 	struct pwrctrl_priv *pwrpriv =&padapter->pwrctrlpriv;
@@ -602,33 +524,6 @@ static u8 _LLTWrite(
 	return status;
 }
 
-static u8 _LLTRead(
-	struct rtw_adapter *	adapter,
-	u32		address
-	)
-{
-	int		count = 0;
-	u32		value = _LLT_INIT_ADDR(address) | _LLT_OP(_LLT_READ_ACCESS);
-
-	rtw_write32(adapter, REG_LLT_INIT, value);
-
-	/* polling and get value */
-	do{
-
-		value = rtw_read32(adapter, REG_LLT_INIT);
-		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)) {
-			return (u8)value;
-		}
-
-		if (count > POLLING_LLT_THRESHOLD) {
-			/* RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling read LLT done at address %d!\n", address)); */
-			break;
-		}
-	}while (count++);
-
-	return 0xFF;
-}
-
 static u8 InitLLTTable(
 	struct rtw_adapter *	adapter,
 	u32		boundary
@@ -684,36 +579,7 @@ static u8 InitLLTTable(
 	return status;
 }
 
-/*  */
-/*  */
 /*	MAC init functions */
-/*  */
-/*  */
-static void _SetMacID(struct rtw_adapter *adapter, u8 *MacID)
-{
-	u32 i;
-	for (i = 0 ; i< ETH_ALEN ; i++) {
-#ifdef  CONFIG_CONCURRENT_MODE
-		if (adapter->iface_type == IFACE_PORT1)
-			rtw_write32(adapter, REG_MACID1+i, MacID[i]);
-		else
-#endif
-		rtw_write32(adapter, REG_MACID+i, MacID[i]);
-	}
-}
-
-static void _SetBSSID( struct rtw_adapter *adapter, u8 *BSSID)
-{
-	u32 i;
-	for (i = 0 ; i< ETH_ALEN ; i++) {
-#ifdef  CONFIG_CONCURRENT_MODE
-		if (adapter->iface_type == IFACE_PORT1)
-			rtw_write32(adapter, REG_BSSID1+i, BSSID[i]);
-		else
-#endif
-		rtw_write32(adapter, REG_BSSID+i, BSSID[i]);
-	}
-}
 
 /*  Shall USB interface init this? */
 static void _InitInterrupt(struct rtw_adapter *adapter)
@@ -1891,115 +1757,6 @@ n. LEDCFG 0x4C[15:0] = 0x8080
 
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable GPIO and LED.\n")); */
 } /* end of _DisableGPIO() */
-static void
-_ResetFWDownloadRegister(
-	struct rtw_adapter *			adapter
-	)
-{
-	u32	value32;
-
-	value32 = rtw_read32(adapter, REG_MCUFWDL);
-	value32 &= ~(MCUFWDL_EN | MCUFWDL_RDY);
-	rtw_write32(adapter, REG_MCUFWDL, value32);
-}
-
-static int
-_DisableRF_AFE(
-	struct rtw_adapter *			adapter
-	)
-{
-	int		rtStatus = 1;
-	u32			pollingCount = 0;
-	u8			value8;
-
-	/* disable RF/ AFE AD/DA */
-	value8 = APSDOFF;
-	rtw_write8(adapter, REG_APSD_CTRL, value8);
-	return rtStatus;
-}
-
-static void
-_ResetBB(
-	struct rtw_adapter *			adapter
-	)
-{
-	u16	value16;
-	/* before BB reset should do clock gated */
-	rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
-	/* reset BB */
-	value16 = rtw_read16(adapter, REG_SYS_FUNC_EN);
-	value16 &= ~(FEN_BBRSTB | FEN_BB_GLB_RSTn);
-	rtw_write16(adapter, REG_SYS_FUNC_EN, value16);
-	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset BB.\n")); */
-}
-
-static void
-_ResetMCU(
-	struct rtw_adapter *			adapter
-	)
-{
-	u16	value16;
-
-	/*  reset MCU */
-	value16 = rtw_read16(adapter, REG_SYS_FUNC_EN);
-	value16 &= ~FEN_CPUEN;
-	rtw_write16(adapter, REG_SYS_FUNC_EN, value16);
-	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset MCU.\n")); */
-}
-
-static void
-_DisableMAC_AFE_PLL(
-	struct rtw_adapter *			adapter
-	)
-{
-	u32	value32;
-
-	/* disable MAC/ AFE PLL */
-	value32 = rtw_read32(adapter, REG_APS_FSMCO);
-	value32 |= APDM_MAC;
-	rtw_write32(adapter, REG_APS_FSMCO, value32);
-
-	value32 |= APFM_OFF;
-	rtw_write32(adapter, REG_APS_FSMCO, value32);
-	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable MAC, AFE PLL.\n")); */
-}
-
-static void
-_AutoPowerDownToHostOff(
-	struct rtw_adapter *		adapter
-	)
-{
-	u32			value32;
-	rtw_write8(adapter, REG_SPS0_CTRL, 0x22);
-
-	value32 = rtw_read32(adapter, REG_APS_FSMCO);
-
-	value32 |= APDM_HOST;/* card disable */
-	rtw_write32(adapter, REG_APS_FSMCO, value32);
-	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Auto Power Down to Host-off state.\n")); */
-
-	/*  set USB suspend */
-	value32 = rtw_read32(adapter, REG_APS_FSMCO);
-	value32 &= ~AFSM_PCIE;
-	rtw_write32(adapter, REG_APS_FSMCO, value32);
-}
-
-static void
-_SetUsbSuspend(
-	struct rtw_adapter *			adapter
-	)
-{
-	u32			value32;
-
-	value32 = rtw_read32(adapter, REG_APS_FSMCO);
-
-	/*  set USB suspend */
-	value32 |= AFSM_HSUS;
-	rtw_write32(adapter, REG_APS_FSMCO, value32);
-
-	/* RT_ASSERT(0 == (rtw_read32(adapter, REG_APS_FSMCO) & BIT(12)), ("")); */
-	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Set USB suspend.\n")); */
-}
 
 static void
 _DisableRFAFEAndResetBB8192D(
@@ -2060,9 +1817,6 @@ _ResetDigitalProcedure1(
 	bool				bWithoutHWSM
 	)
 {
-
-	struct hal_data_8192du  *pHalData = GET_HAL_DATA(adapter);
-
 	u8 retry_cnts = 0;
 	/*  2010/08/12 MH For USB SS, we can not stop 8051 when we are trying to */
 	/*  enter IPS/HW&SW radio off. For S3/S4/S5/Disable, we can stop 8051 because */
@@ -2169,77 +1923,12 @@ i.	APS_FSMCO 0x04[15:0] = 0x4802		set US
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable Analog Reg0x04:0x%04x.\n", value16)); */
 }
 
-static bool
-CanGotoPowerOff92D(
-	struct rtw_adapter *			adapter
-	)
-{
-	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
-	u8 u1bTmp;
-#ifdef CONFIG_DUALMAC_CONCURRENT
-	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
-#endif
-
-	if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY)
-		return true;
-
-#ifdef CONFIG_DUALMAC_CONCURRENT
-	if (Buddyadapter != NULL)
-	{
-		if (Buddyadapter->init_adpt_in_progress)
-		{
-			DBG_8192D("do not power off during another adapter is initialization\n");
-			return false;
-		}
-	}
-#endif
-
-	if (pHalData->interfaceIndex == 0)
-	{	/*  query another mac status; */
-		u1bTmp = rtw_read8(adapter, REG_MAC1);
-		u1bTmp&= MAC1_ON;
-	}
-	else
-	{
-		u1bTmp = rtw_read8(adapter, REG_MAC0);
-		u1bTmp&= MAC0_ON;
-	}
-
-	/* 0x17[7]:1b' power off in process */
-	u1bTmp = rtw_read8(adapter, 0x17);
-	u1bTmp|= BIT7;
-	rtw_write8(adapter, 0x17, u1bTmp);
-
-	udelay(500);
-	/*  query another mac status; */
-	if (pHalData->interfaceIndex == 0)
-	{	/*  query another mac status; */
-		u1bTmp = rtw_read8(adapter, REG_MAC1);
-		u1bTmp&= MAC1_ON;
-	}
-	else
-	{
-		u1bTmp = rtw_read8(adapter, REG_MAC0);
-		u1bTmp&= MAC0_ON;
-	}
-	/* if another mac is alive, do not do power off */
-	if (u1bTmp)
-	{
-		u1bTmp = rtw_read8(adapter, 0x17);
-		u1bTmp&= (~BIT7);
-		rtw_write8(adapter, 0x17, u1bTmp);
-		return false;
-	}
-	return true;
-}
-
 static int
 CardDisableHWSM(/*  HW Auto state machine */
 	struct rtw_adapter *		adapter,
 	bool			resetMCU
 	)
 {
-	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	int		rtStatus = 1;
 	u8		value;
 
@@ -2290,7 +1979,6 @@ CardDisableWithoutHWSM(/*  without HW Au
 	struct rtw_adapter *		adapter
 	)
 {
-	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	int		rtStatus = 1;
 	u8		value;
 
@@ -2472,19 +2160,6 @@ _ReadPROMVersion(
 	}
 }
 
-static u32 _GetChannelGroup(u32 channel)
-{
-
-	if (channel < 3) {	/*  Channel 1~3 */
-		return 0;
-	}
-	else if (channel < 9) { /*  Channel 4~9 */
-		return 1;
-	}
-
-	return 2;				/*  Channel 10~14 */
-}
-
 static void
 _ReadIDs(
 	struct rtw_adapter *	adapter,
@@ -2752,7 +2427,6 @@ static void _ReadPROMContent(
 	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 	u8			PROMContent[HWSET_MAX_SIZE]={0};
 	u8			eeValue;
-	u32			i;
 
 	eeValue = rtw_read8(adapter, REG_9346CR);
 	/*  To check system boot selection. */
@@ -2888,268 +2562,6 @@ ResumeTxBeacon(
 	rtw_write8(adapter, REG_TBTT_PROHIBIT+1, 0x64);
 }
 
-/*  */
-/*  2010.11.17. Added by tynli. */
-/*  */
-static u8 SelectRTSInitialRate(struct rtw_adapter *adapter)
-{
-	struct sta_info		*psta;
-	struct mlme_priv		*pmlmepriv = &adapter->mlmepriv;
-	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
-	struct sta_priv		*pstapriv = &adapter->stapriv;
-	u8	bUseProtection;
-	u16	BasicRateCfg = 0;
-	u8	SupportRateSet[NDIS_802_11_LENGTH_RATES_EX];
-	u8	RTSRateIndex = 0; /*  1M */
-	u8	LowestRateIdx = 0;
-
-	psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
-	if (psta == NULL)
-	{
-		return RTSRateIndex;
-	}
-
-	if (psta->rtsen || psta->cts2self)
-		bUseProtection = true;
-
-	memcpy(SupportRateSet, cur_network->SupportedRates, NDIS_802_11_LENGTH_RATES_EX);
-
-	halsetbratecfg(adapter, SupportRateSet, &BasicRateCfg);
-
-	if (bUseProtection &&
-		(!(pmlmeext->cur_wireless_mode == WIRELESS_11A|| pmlmeext->cur_wireless_mode == WIRELESS_11A_5N)))/*  5G not support cck rate */
-	{
-		/*  Use CCK rate */
-		BasicRateCfg &= 0xf; /* CCK rate */
-		while (BasicRateCfg > 0x1)
-		{
-			BasicRateCfg = (BasicRateCfg>> 1);
-			RTSRateIndex++;
-		}
-	}
-	else /* if (pMgntInfo->pHTInfo->CurrentOpMode) */
-	{
-		/* MacId 0: INFRA mode. */
-		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true)&&(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true))
-		{
-			LowestRateIdx = rtw_read8(adapter, REG_INIDATA_RATE_SEL)&0x3f;
-		}
-
-		/*  Adjust RTS Init rate when the data rate is MCS0~2, 8~10 which is lower than 24M. */
-		if (LowestRateIdx == 12 || LowestRateIdx == 20) /* MCS0, MCS8 */
-		{
-			RTSRateIndex = 4; /*  6M */
-		}
-		else if (LowestRateIdx == 13 || LowestRateIdx == 14 ||
-			LowestRateIdx == 21 || LowestRateIdx == 22) /* MCS1, MCS2, MCS9, MCS10 */
-		{
-			RTSRateIndex = 6; /*  12M */
-		}
-		else
-		{
-			if (BasicRateCfg != 0)
-			{
-				/*  Select RTS Init rate */
-				while (BasicRateCfg > 0x1)
-				{
-					BasicRateCfg = (BasicRateCfg>> 1);
-					RTSRateIndex++;
-				}
-			}
-			else
-			{
-				RTSRateIndex = 4; /*  6M */
-			}
-		}
-
-	}
-
-	/* Set RTS init rate to Hw. */
-	return RTSRateIndex;
-}
-
-/*  */
-/*  Description: Selcet the RTS init rate and set the rate to HW. */
-/*  2010.11.25. Created by tynli. */
-/*  */
-static void SetRTSRateWorkItemCallback(void *pContext)
-{
-	struct rtw_adapter *adapter =  (struct rtw_adapter *)pContext;
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
-	u8	NewRTSInitRate = 0;
-
-	NewRTSInitRate = SelectRTSInitialRate(adapter);
-	if (NewRTSInitRate != pHalData->RTSInitRate)
-	{
-		rtw_write8(adapter, REG_INIRTS_RATE_SEL, NewRTSInitRate);
-		pHalData->RTSInitRate = NewRTSInitRate;
-	}
-
-	DBG_8192D("HW_VAR_INIT_RTS_RATE: RateIndex(%d)\n", NewRTSInitRate);
-}
-
-static void hw_var_set_opmode(struct rtw_adapter *adapter, u8 variable, u8 *val)
-{
-	u8	val8;
-	u8	mode = *((u8 *)val);
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (adapter->iface_type == IFACE_PORT1)
-	{
-		/*  disable Port1 TSF update */
-		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(4));
-
-		/*  set net_type */
-		val8 = rtw_read8(adapter, MSR)&0x03;
-		val8 |= (mode<<2);
-		rtw_write8(adapter, MSR, val8);
-
-		/* reset TSF1 */
-		rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(1));
-
-		DBG_8192D("%s()-%d mode = %d\n", __func__, __LINE__, mode);
-
-		if ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
-		{
-			if (!check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
-			{
-				StopTxBeacon(adapter);
-			}
-
-			rtw_write8(adapter, REG_BCN_CTRL_1, 0x19);/* disable atim wnd */
-		}
-		else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
-		{
-			ResumeTxBeacon(adapter);
-			rtw_write8(adapter, REG_BCN_CTRL_1, 0x1a);
-		}
-		else if (mode == _HW_STATE_AP_)
-		{
-			ResumeTxBeacon(adapter);
-
-			rtw_write8(adapter, REG_BCN_CTRL_1, 0x12);
-
-			/* Set RCR */
-			rtw_write32(adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
-			/* enable to rx data frame */
-			rtw_write16(adapter, REG_RXFLTMAP2, 0xFFFF);
-			/* enable to rx ps-poll */
-			rtw_write16(adapter, REG_RXFLTMAP1, 0x0400);
-
-			/* Beacon Control related register for first time */
-			rtw_write8(adapter, REG_BCNDMATIM, 0x02); /*  2ms */
-			rtw_write8(adapter, REG_DRVERLYINT, 0x05);/*  5ms */
-			rtw_write8(adapter, REG_ATIMWND_1, 0x0a); /*  10ms for port1 */
-			rtw_write16(adapter, REG_BCNTCFG, 0x00);
-			rtw_write16(adapter, REG_TBTT_PROHIBIT, 0xff04);
-			rtw_write16(adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);/*  +32767 (~32ms) */
-
-		       /* enable BCN1 Function for if2 */
-			/* don't enable update TSF1 for if2 (due to TSF update when beacon/probe rsp are received) */
-			rtw_write8(adapter, REG_BCN_CTRL_1, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
-
-			DBG_8192D("%s()-%d: REG_BCN_CTRL_1 = %02x\n", __func__, __LINE__, rtw_read8(adapter, REG_BCN_CTRL_1));
-
-			if (check_buddy_fwstate(adapter, WIFI_FW_NULL_STATE))
-				rtw_write8(adapter, REG_BCN_CTRL,
-					rtw_read8(adapter, REG_BCN_CTRL) & ~EN_BCN_FUNCTION);
-
-			/* dis BCN0 ATIM  WND if if1 is station */
-			rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(0));
-#ifdef CONFIG_CONCURRENT_MODE
-			/*  Reset TSF for STA+AP concurrent mode */
-			if (check_buddy_fwstate(adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE))) {
-				if (reset_tsf(adapter, IFACE_PORT1) == false)
-					DBG_8192D("ERROR! %s()-%d: Reset port1 TSF fail\n",
-						__func__, __LINE__);
-			}
-#endif	/*  CONFIG_CONCURRENT_MODE */
-		}
-
-	}
-	else	/*  (adapter->iface_type == IFACE_PORT1) */
-#endif /* CONFIG_CONCURRENT_MODE */
-	{
-		/*  disable Port0 TSF update */
-		rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
-
-		/*  set net_type */
-		val8 = rtw_read8(adapter, MSR)&0x0c;
-		val8 |= mode;
-		rtw_write8(adapter, MSR, val8);
-
-		/* reset TSF0 */
-		rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(0));
-
-		DBG_8192D("%s()-%d mode = %d\n", __func__, __LINE__, mode);
-
-		if ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
-		{
-#ifdef CONFIG_CONCURRENT_MODE
-			if (!check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
-#endif /* CONFIG_CONCURRENT_MODE */
-			{
-				StopTxBeacon(adapter);
-			}
-
-			rtw_write8(adapter, REG_BCN_CTRL, 0x19);/* disable atim wnd */
-		}
-		else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
-		{
-			ResumeTxBeacon(adapter);
-			rtw_write8(adapter, REG_BCN_CTRL, 0x1a);
-		}
-		else if (mode == _HW_STATE_AP_)
-		{
-			ResumeTxBeacon(adapter);
-
-			rtw_write8(adapter, REG_BCN_CTRL, 0x12);
-
-			/* Set RCR */
-			rtw_write32(adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
-			/* enable to rx data frame */
-			rtw_write16(adapter, REG_RXFLTMAP2, 0xFFFF);
-			/* enable to rx ps-poll */
-			rtw_write16(adapter, REG_RXFLTMAP1, 0x0400);
-
-			/* Beacon Control related register for first time */
-
-			rtw_write8(adapter, REG_BCNDMATIM, 0x02); /*  2ms */
-			rtw_write8(adapter, REG_DRVERLYINT, 0x05);/*  5ms */
-
-			rtw_write8(adapter, REG_ATIMWND, 0x0a); /*  10ms for port0 */
-			rtw_write16(adapter, REG_BCNTCFG, 0x00);
-			rtw_write16(adapter, REG_TBTT_PROHIBIT, 0xff04);
-			rtw_write16(adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);/*  +32767 (~32ms) */
-
-		        /* enable BCN0 Function for if1 */
-			/* don't enable update TSF0 for if1 (due to TSF update when beacon/probe rsp are received) */
-			rtw_write8(adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
-
-#ifdef CONFIG_CONCURRENT_MODE
-			if (check_buddy_fwstate(adapter, WIFI_FW_NULL_STATE))
-				rtw_write8(adapter, REG_BCN_CTRL_1,
-					rtw_read8(adapter, REG_BCN_CTRL_1) & ~EN_BCN_FUNCTION);
-
-			/* dis BCN1 ATIM  WND if if2 is station */
-			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(0));
-#ifdef CONFIG_CONCURRENT_MODE
-			/*  Reset TSF for STA+AP concurrent mode */
-			if (check_buddy_fwstate(adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE))) {
-				if (reset_tsf(adapter, IFACE_PORT0) == false)
-					DBG_8192D("ERROR! %s()-%d: Reset port0 TSF fail\n",
-						__func__, __LINE__);
-			}
-#endif /*  CONFIG_CONCURRENT_MODE */
-#endif /*  CONFIG_CONCURRENT_MODE */
-		}
-
-	}
-}
-
 static void hw_var_set_macaddr(struct rtw_adapter *adapter, u8 variable, u8 *val)
 {
 	u8 idx = 0;
@@ -3168,28 +2580,6 @@ static void hw_var_set_macaddr(struct rt
 		rtw_write8(adapter, (reg_macid+idx), val[idx]);
 }
 
-static void hw_var_set_bssid(struct rtw_adapter *adapter, u8 variable, u8 *val)
-{
-	u8	idx = 0;
-	u32 reg_bssid;
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (adapter->iface_type == IFACE_PORT1)
-	{
-		reg_bssid = REG_BSSID1;
-	}
-	else
-#endif
-	{
-		reg_bssid = REG_BSSID;
-	}
-
-	for (idx = 0 ; idx < 6; idx++)
-	{
-		rtw_write8(adapter, (reg_bssid+idx), val[idx]);
-	}
-}
-
 static void hw_var_set_bcn_func(struct rtw_adapter *adapter, u8 variable,
 				u8 *val)
 {
@@ -3224,137 +2614,6 @@ static void hw_var_set_bcn_func(struct r
 	}
 }
 
-static void hw_var_set_correct_tsf(struct rtw_adapter *adapter, u8 variable,
-				   u8 *val)
-{
-#ifdef CONFIG_CONCURRENT_MODE
-	u64	tsf;
-	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
-	tsf = pmlmeext->TSFValue - do_div(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; /* us */
-
-	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
-	{
-		StopTxBeacon(adapter);
-	}
-
-	if (adapter->iface_type == IFACE_PORT1)
-	{
-		/* disable related TSF function */
-		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)&(~BIT(3)));
-
-		rtw_write32(adapter, REG_TSFTR1, tsf);
-		rtw_write32(adapter, REG_TSFTR1+4, tsf>>32);
-
-		/* enable related TSF function */
-		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(3));
-
-#ifdef CONFIG_CONCURRENT_MODE
-		/*  Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue! */
-		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(adapter, WIFI_AP_STATE)) {
-			if (reset_tsf(adapter, IFACE_PORT0) == false)
-				DBG_8192D("ERROR! %s()-%d: Reset port0 TSF fail\n",
-					__func__, __LINE__);
-		}
-#endif	/*  CONFIG_CONCURRENT_MODE */
-
-	}
-	else	/*  adapter->iface_type == IFACE_PORT1 */
-	{
-		/* disable related TSF function */
-		rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(3)));
-		/*  disable TSF update instead! May induce burst beacon TX */
-
-		rtw_write32(adapter, REG_TSFTR, tsf);
-		rtw_write32(adapter, REG_TSFTR+4, tsf>>32);
-
-		/* enable related TSF function */
-		rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(3));
-
-		/*  Update buddy port's TSF if it is SoftAP for beacon TX issue! */
-		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(adapter, WIFI_AP_STATE)
-		) {
-			/* disable related TSF function */
-			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)&(~BIT(3)));
-			/*  disable TSF update instead! */
-
-			rtw_write32(adapter, REG_TSFTR1, tsf);
-			rtw_write32(adapter, REG_TSFTR1+4, tsf>>32);
-
-			/* enable related TSF function */
-			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(3));
-		}
-#ifdef CONFIG_CONCURRENT_MODE
-		/*  Update buddy port's TSF if it is SoftAP for beacon TX issue! */
-		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(adapter, WIFI_AP_STATE)) {
-			if (reset_tsf(adapter, IFACE_PORT1) == false)
-				DBG_8192D("ERROR! %s()-%d: Reset port1 TSF fail\n",
-					__func__, __LINE__);
-		}
-#endif	/*  CONFIG_CONCURRENT_MODE */
-	}
-
-	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
-	{
-		ResumeTxBeacon(adapter);
-	}
-#endif	/*  CONFIG_CONCURRENT_MODE */
-}
-
-static void hw_var_set_mlme_disconnect(struct rtw_adapter *adapter,
-				       u8 variable, u8 *val)
-{
-#ifdef CONFIG_CONCURRENT_MODE
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
-	struct rtw_adapter *pbuddy_adapter = adapter->pbuddy_adapter;
-
-	if (check_buddy_mlmeinfo_state(adapter, _HW_STATE_NOLINK_))
-		rtw_write16(adapter, REG_RXFLTMAP2, 0x00);
-
-	if (adapter->iface_type == IFACE_PORT1)
-	{
-		int i;
-		u8 reg_bcn_ctrl_1;
-
-		/*  a.Driver set 0x422 bit 6 = 0 */
-		rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
-		pHalData->RegFwHwTxQCtrl &= (~BIT6);
-
-		/* disable update TSF1 */
-			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(4));
-
-		/* reset TSF1 */
-		rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(1));
-
-		/*  disable Port1's beacon function */
-		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)&(~BIT(3)));
-
-		/*  j, Driver set 0x422 bit 6 = 1 */
-		rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
-		pHalData->RegFwHwTxQCtrl |= BIT6;
-
-		/*  k. re_download beacon pkt */
-		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
-			set_tx_beacon_cmd(pbuddy_adapter);
-
-	}
-	else	/*  (adapter->iface_type == IFACE_PORT1) */
-	{
-		/* disable update TSF */
-			rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
-
-		/* reset TSF */
-		rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(0));
-
-		/*  Can't disable Port0's beacon function due to it is used by RA */
-	}
-#endif
-}
-
 static void hw_var_set_mlme_sitesurvey(struct rtw_adapter *adapter, u8 variable, u8 *val)
 {
 	u32	value_rcr, rcr_clear_bit, reg_bcn_ctl;
@@ -3442,83 +2701,6 @@ static void hw_var_set_mlme_sitesurvey(s
 	}
 }
 
-static void hw_var_set_mlme_join(struct rtw_adapter *adapter,
-				 u8 variable, u8 *val)
-{
-#ifdef CONFIG_CONCURRENT_MODE
-	u8	RetryLimit = 0x30;
-	u8	type = *((u8 *)val);
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
-	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
-
-	if (type == 0) /*  prepare to join */
-	{
-		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(adapter, _FW_LINKED))
-		{
-			StopTxBeacon(adapter);
-		}
-
-		/* enable to rx data frame.Accept all data frame */
-		rtw_write16(adapter, REG_RXFLTMAP2, 0xFFFF);
-
-		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
-			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_BCN);
-		else
-			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
-
-		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
-		{
-			RetryLimit = (pHalData->CustomerID == RT_CID_CCX) ? 7 : 48;
-		}
-		else /*  Ad-hoc Mode */
-		{
-			RetryLimit = 0x7;
-		}
-
-		DBG_8192D("%s(): pHalData->bNeedIQK = true\n", __func__);
-		pHalData->bNeedIQK = true; /* for 92D IQK */
-	}
-	else if (type == 1) /* joinbss_event call back when join res < 0 */
-	{
-		if (check_buddy_mlmeinfo_state(adapter, _HW_STATE_NOLINK_))
-			rtw_write16(adapter, REG_RXFLTMAP2, 0x00);
-
-		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(adapter, _FW_LINKED))
-		{
-			ResumeTxBeacon(adapter);
-		}
-	}
-	else if (type == 2) /* sta add event call back */
-	{
-
-		/* enable update TSF */
-		if (adapter->iface_type == IFACE_PORT1)
-			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)&(~BIT(4)));
-		else
-			rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
-
-		if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
-		{
-			/* fixed beacon issue for 8191su........... */
-			rtw_write8(adapter, 0x542 , 0x02);
-			RetryLimit = 0x7;
-		}
-
-		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(adapter, _FW_LINKED))
-		{
-			ResumeTxBeacon(adapter);
-		}
-
-	}
-
-	rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
-
-#endif
-}
-
 #ifdef CONFIG_DUALMAC_CONCURRENT
 static void dc_hw_var_mlme_sitesurvey(struct rtw_adapter *adapter,
 				      u8 sitesurvey_state)
@@ -3729,7 +2911,6 @@ static void SetHwReg8192DU(struct rtw_ad
 			{
 				u16	BrateCfg = 0;
 				u8	RateIndex = 0, b2GBand = false;
-				struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
 
 				/*  2007.01.16, by Emily */
 				/*  Select RRSR (in Legacy-OFDM and CCK) */
@@ -4521,49 +3702,6 @@ static u8 SetHalDefVar8192DUsb(
 	return bResult;
 }
 
-static u32  _update_92cu_basic_rate(struct rtw_adapter *padapter, unsigned int mask)
-{
-	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
-#ifdef CONFIG_BT_COEXIST
-	struct btcoexist_priv	*pbtpriv = &(pHalData->bt_coexist);
-#endif
-	unsigned int BrateCfg = 0;
-
-#ifdef CONFIG_BT_COEXIST
-	if (	(pbtpriv->BT_Coexist) &&	(pbtpriv->BT_CoexistType == BT_CSR_BC4)	)
-	{
-		BrateCfg = mask  & 0x151;
-	}
-	else
-#endif
-	{
-		if (pHalData->VersionID != VERSION_TEST_CHIP_88C)
-			BrateCfg = mask  & 0x15F;
-		else	/* for 88CU 46PING setting, Disable CCK 2M, 5.5M, Others must tuning */
-			BrateCfg = mask  & 0x159;
-	}
-
-	BrateCfg |= 0x01; /*  default enable 1M ACK rate */
-
-	return BrateCfg;
-}
-
-static void _update_response_rate(struct rtw_adapter *padapter, unsigned int mask)
-{
-	u8	RateIndex = 0;
-	/*  Set RRSR rate table. */
-	rtw_write8(padapter, REG_RRSR, mask&0xff);
-	rtw_write8(padapter, REG_RRSR+1, (mask>>8)&0xff);
-
-	/*  Set RTS initial rate */
-	while (mask > 0x1)
-	{
-		mask = (mask>> 1);
-		RateIndex++;
-	}
-	rtw_write8(padapter, REG_INIRTS_RATE_SEL, RateIndex);
-}
-
 static void UpdateHalRAMask8192DUsb(struct rtw_adapter *padapter, u32 mac_id)
 {
 	u32	value[2];
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -28,10 +28,8 @@ static int usbctrl_vendorreq(struct intf
 	struct rtw_adapter *padapter = pintfhdl->padapter ;
 	struct dvobj_priv  *pdvobjpriv = adapter_to_dvobj(padapter);
 	struct usb_device *udev = pdvobjpriv->pusbdev;
-
 	unsigned int pipe;
 	int status = 0;
-	u32 tmp_buflen=0;
 	u8 reqtype;
 	u8 *pIo_buf;
 	int vendorreq_times = 0;
@@ -132,7 +130,6 @@ exit:
 static void usb_read_reg_rf_byfw(struct intf_hdl *pintfhdl, u16 byteCount, u32 registerIndex, void *buffer)
 {
 	u16	wPage = 0x0000, offset;
-	u32	BufferLengthRead;
 	struct rtw_adapter *	adapter = pintfhdl->padapter;
 	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	u8	RFPath=0,nPHY=0;
@@ -319,121 +316,6 @@ static int usb_writeN(struct intf_hdl *p
 	return ret;
 }
 
-static s32 pre_recv_entry(struct recv_frame_hdr *precvframe, struct recv_stat *prxstat, struct phy_stat *pphy_info)
-{
-	s32 ret=1;
-#ifdef CONFIG_CONCURRENT_MODE
-	u8 *primary_myid, *secondary_myid, *paddr1;
-	struct recv_frame_hdr	*precvframe_if2 = NULL;
-	struct rtw_adapter *primary_padapter = precvframe->adapter;
-	struct rtw_adapter *secondary_padapter = primary_padapter->pbuddy_adapter;
-	struct recv_priv *precvpriv = &primary_padapter->recvpriv;
-	struct __queue *pfree_recv_queue = &precvpriv->free_recv_queue;
-	u8	*pbuf = precvframe->rx_data;
-
-	if (!secondary_padapter)
-		return ret;
-
-	paddr1 = GetAddr1Ptr(precvframe->rx_data);
-
-	if (IS_MCAST(paddr1) == false)/* unicast packets */
-	{
-		secondary_myid = myid(&secondary_padapter->eeprompriv);
-
-		if (!memcmp(paddr1, secondary_myid, ETH_ALEN))
-		{
-			/* change to secondary interface */
-			precvframe->adapter = secondary_padapter;
-		}
-
-	}
-	else /*  Handle BC/MC Packets */
-	{
-		u8 clone = true;
-
-		if (true == clone)
-		{
-			/* clone/copy to if2 */
-			u8 shift_sz = 0;
-			u32 alloc_sz, skb_len;
-			struct sk_buff *pkt_copy = NULL;
-			struct rx_pkt_attrib *pattrib = NULL;
-
-			precvframe_if2 = rtw_alloc_recvframe(pfree_recv_queue);
-			if (precvframe_if2)
-			{
-				precvframe_if2->adapter = secondary_padapter;
-
-				INIT_LIST_HEAD(&precvframe_if2->list);
-				precvframe_if2->precvbuf = NULL;	/* can't access the precvbuf for new arch. */
-				precvframe_if2->len=0;
-
-				memcpy(&precvframe_if2->attrib, &precvframe->attrib, sizeof(struct rx_pkt_attrib));
-
-				pattrib = &precvframe_if2->attrib;
-
-				/*	Modified by Albert 20101213 */
-				/*	For 8 bytes IP header alignment. */
-				if (pattrib->qos)	/*	Qos data, wireless lan header length is 26 */
-				{
-					shift_sz = 6;
-				}
-				else
-				{
-					shift_sz = 0;
-				}
-
-				skb_len = pattrib->pkt_len;
-
-				/*  for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet. */
-				/*  modify alloc_sz for recvive crc error packet by thomas 2011-06-02 */
-				if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)) {
-					if (skb_len <= 1650)
-						alloc_sz = 1664;
-					else
-						alloc_sz = skb_len + 14;
-				}
-				else {
-					alloc_sz = skb_len;
-					/*	6 is for IP header 8 bytes alignment in QoS packet case. */
-					/*	8 is for skb->data 4 bytes alignment. */
-					alloc_sz += 14;
-				}
-
-				pkt_copy = netdev_alloc_skb(secondary_padapter->pnetdev, alloc_sz);
-				if (pkt_copy) {
-					pkt_copy->dev = secondary_padapter->pnetdev;
-					precvframe_if2->pkt = pkt_copy;
-					precvframe_if2->rx_head = pkt_copy->data;
-					precvframe_if2->rx_end = pkt_copy->data + alloc_sz;
-					skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));/* force pkt_copy->data at 8-byte alignment address */
-					skb_reserve(pkt_copy, shift_sz);/* force ip_hdr at 8-byte alignment address according to shift_sz. */
-					memcpy(pkt_copy->data, pbuf, skb_len);
-					precvframe_if2->rx_data = precvframe_if2->rx_tail = pkt_copy->data;
-				}
-
-				recvframe_put(precvframe_if2, skb_len);
-				/* recvframe_pull(precvframe_if2, drvinfo_sz + RXDESC_SIZE); */
-
-				rtl8192d_translate_rx_signal_stuff(precvframe_if2, pphy_info);
-
-				ret = rtw_recv_entry(precvframe_if2);
-
-			}
-
-		}
-
-	}
-
-	rtl8192d_translate_rx_signal_stuff(precvframe, pphy_info);
-
-	ret = rtw_recv_entry(precvframe);
-
-#endif
-
-	return ret;
-}
-
 static int recvbuf2recvframe(struct rtw_adapter *padapter, struct sk_buff *pskb)
 {
 	u8	*pbuf;
@@ -613,7 +495,6 @@ void rtl8192du_recv_tasklet(void *priv)
 
 static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
 {
-	uint isevt, *pbuf;
 	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;
 	struct rtw_adapter			*padapter =(struct rtw_adapter *)precvbuf->adapter;
 	struct recv_priv	*precvpriv = &padapter->recvpriv;
--- a/drivers/staging/rtl8192du/include/autoconf.h
+++ b/drivers/staging/rtl8192du/include/autoconf.h
@@ -25,7 +25,7 @@
 
 #define CONFIG_92D_AP_MODE 1
 
-//#define CONFIG_P2P	1
+#define CONFIG_P2P	1
 
 #define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable,*/
 
--- a/drivers/staging/rtl8192du/include/drv_types.h
+++ b/drivers/staging/rtl8192du/include/drv_types.h
@@ -211,7 +211,7 @@ struct dvobj_priv {
 	atomic_t continual_urb_error;
 };
 
-static struct device *dvobj_to_dev(struct dvobj_priv *dvobj)
+static inline struct device *dvobj_to_dev(struct dvobj_priv *dvobj)
 {
 	/* todo: get interface type from dvobj and the return the dev accordingly */
 	return &dvobj->pusbintf->dev;
--- a/drivers/staging/rtl8192du/include/rtl8192d_hal.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_hal.h
@@ -54,105 +54,6 @@ extern bool GlobalFirstConfigurationForN
 
 
 
-static u32	   RF_REG_FOR_5G_SWCHNL_NORMAL[MAX_RF_IMR_INDEX_NORMAL]={0,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x0};
-
-static u8	RF_REG_for_C_CUT_5G[RF_REG_NUM_for_C_CUT_5G] =
-			{RF_SYN_G1, RF_SYN_G2,	RF_SYN_G3,	RF_SYN_G4,	RF_SYN_G5,	RF_SYN_G6};
-
-static u8	RF_REG_for_C_CUT_5G_internalPA[RF_REG_NUM_for_C_CUT_5G_internalPA] =
-			{0x0B,	0x48,	0x49,	0x4B,	0x03,	0x04,	0x0E};
-static u8	RF_REG_for_C_CUT_2G[RF_REG_NUM_for_C_CUT_2G] =
-			{RF_SYN_G1, RF_SYN_G2,	RF_SYN_G3,	RF_SYN_G7,	RF_SYN_G8};
-
-static u8	RF_CHNL_5G[RF_CHNL_NUM_5G] =
-	{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140};
-static u8	RF_CHNL_5G_40M[RF_CHNL_NUM_5G_40M] =
-	{38,42,46,50,54,58,62,102,106,110,114,118,122,126,130,134,138};
-
-static u32	RF_REG_Param_for_C_CUT_5G[5][RF_REG_NUM_for_C_CUT_5G] = {
-	{0xE43BE,	0xFC638,	0x77C0A,	0xDE471,	0xd7110,	0x8EB04},
-	{0xE43BE,	0xFC078,	0xF7C1A,	0xE0C71,	0xD7550,	0xAEB04},
-	{0xE43BF,	0xFF038,	0xF7C0A,	0xDE471,	0xE5550,	0xAEB04},
-	{0xE43BF,	0xFF079,	0xF7C1A,	0xDE471,	0xE5550,	0xAEB04},
-	{0xE43BF,	0xFF038,	0xF7C1A,	0xDE471,	0xd7550,	0xAEB04}};
-
-static u32	RF_REG_Param_for_C_CUT_2G[3][RF_REG_NUM_for_C_CUT_2G] = {
-	{0x643BC,	0xFC038,	0x77C1A,	0x41289,	0x01840},
-	{0x643BC,	0xFC038,	0x07C1A,	0x41289,	0x01840},
-	{0x243BC,	0xFC438,	0x07C1A,	0x4128B,	0x0FC41}};
-
-static u32 RF_REG_SYN_G4_for_C_CUT_2G = 0xD1C31&0x7FF;
-
-static u32	RF_REG_Param_for_C_CUT_5G_internalPA[3][RF_REG_NUM_for_C_CUT_5G_internalPA] = {
-	{0x01a00,	0x40443,	0x00eb5,	0x89bec,	0x94a12,	0x94a12,	0x94a12},
-	{0x01800,	0xc0443,	0x00730,	0x896ee,	0x94a52,	0x94a52,	0x94a52},
-	{0x01800,	0xc0443,	0x00730,	0x896ee,	0x94a12,	0x94a12,	0x94a12}};
-
-
-
-/* mode][patha+b][reg] */
-static u32 RF_IMR_Param_Normal[1][3][MAX_RF_IMR_INDEX_NORMAL]={{
-	{0x70000,0x00ff0,0x4400f,0x00ff0,0x0,0x0,0x0,0x0,0x0,0x64888,0xe266c,0x00090,0x22fff},/*  channel 1-14. */
-	{0x70000,0x22880,0x4470f,0x55880,0x00070, 0x88000, 0x0,0x88080,0x70000,0x64a82,0xe466c,0x00090,0x32c9a}, /* path 36-64 */
-	{0x70000,0x44880,0x4477f,0x77880,0x00070, 0x88000, 0x0,0x880b0,0x0,0x64b82,0xe466c,0x00090,0x32c9a} /* 100 -165 */
-}
-};
-
-static u32 CurveIndex[TARGET_CHNL_NUM_2G_5G]={0};
-
-static u32 TargetChnl_5G[TARGET_CHNL_NUM_5G] = {
-25141,	25116,	25091,	25066,	25041,
-25016,	24991,	24966,	24941,	24917,
-24892,	24867,	24843,	24818,	24794,
-24770,	24765,	24721,	24697,	24672,
-24648,	24624,	24600,	24576,	24552,
-24528,	24504,	24480,	24457,	24433,
-24409,	24385,	24362,	24338,	24315,
-24291,	24268,	24245,	24221,	24198,
-24175,	24151,	24128,	24105,	24082,
-24059,	24036,	24013,	23990,	23967,
-23945,	23922,	23899,	23876,	23854,
-23831,	23809,	23786,	23764,	23741,
-23719,	23697,	23674,	23652,	23630,
-23608,	23586,	23564,	23541,	23519,
-23498,	23476,	23454,	23432,	23410,
-23388,	23367,	23345,	23323,	23302,
-23280,	23259,	23237,	23216,	23194,
-23173,	23152,	23130,	23109,	23088,
-23067,	23046,	23025,	23003,	22982,
-22962,	22941,	22920,	22899,	22878,
-22857,	22837,	22816,	22795,	22775,
-22754,	22733,	22713,	22692,	22672,
-22652,	22631,	22611,	22591,	22570,
-22550,	22530,	22510,	22490,	22469,
-22449,	22429,	22409,	22390,	22370,
-22350,	22336,	22310,	22290,	22271,
-22251,	22231,	22212,	22192,	22173,
-22153,	22134,	22114,	22095,	22075,
-22056,	22037,	22017,	21998,	21979,
-21960,	21941,	21921,	21902,	21883,
-21864,	21845,	21826,	21807,	21789,
-21770,	21751,	21732,	21713,	21695,
-21676,	21657,	21639,	21620,	21602,
-21583,	21565,	21546,	21528,	21509,
-21491,	21473,	21454,	21436,	21418,
-21400,	21381,	21363,	21345,	21327,
-21309,	21291,	21273,	21255,	21237,
-21219,	21201,	21183,	21166,	21148,
-21130,	21112,	21095,	21077,	21059,
-21042,	21024,	21007,	20989,	20972,
-25679,	25653,	25627,	25601,	25575,
-25549,	25523,	25497,	25471,	25446,
-25420,	25394,	25369,	25343,	25318,
-25292,	25267,	25242,	25216,	25191,
-25166	};
-
-static u32 TargetChnl_2G[TARGET_CHNL_NUM_2G] = {	/*  channel 1~14 */
-26084, 26030, 25976, 25923, 25869, 25816, 25764,
-25711, 25658, 25606, 25554, 25502, 25451, 25328
-};
-
-
 #include "Hal8192DUHWImg.h"
 
 #define RTL819X_DEFAULT_RF_TYPE		RF_1T2R
--- a/drivers/staging/rtl8192du/include/rtw_recv.h
+++ b/drivers/staging/rtl8192du/include/rtw_recv.h
@@ -29,25 +29,7 @@
 #define MAX_RX_NUMBLKS			32
 #define RECVFRAME_HDR_ALIGN		128
 
-static u8 SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};
-
-static u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};
-static u8 SNAP_ETH_TYPE_TDLS[2] = {0x89, 0x0d};
-static u8 SNAP_HDR_APPLETALK_DDP[3] = {
-	0x08, 0x00, 0x07
-}; /*  Datagram Delivery Protocol */
-
-static u8 oui_8021h[] = {0x00, 0x00, 0xf8};
-static u8 oui_rfc1042[] = {0x00, 0x00, 0x00};
-
 #define MAX_SUBFRAME_COUNT		64
-static u8 rtw_rfc1042_header[] = {
-	0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00
-};
-/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
-static u8 rtw_bridge_tunnel_header[] = {
-	0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8
-};
 
 /* for Rx reordering buffer control */
 struct recv_reorder_ctrl {
--- a/drivers/staging/rtl8192du/include/rtw_sreset.h
+++ b/drivers/staging/rtl8192du/include/rtw_sreset.h
@@ -19,6 +19,7 @@
 #include <autoconf.h>
 #include <osdep_service.h>
 #include <drv_types.h>
+#include <rtl8192d_hal.h>
 
 struct sreset_priv {
 	_mutex	silentreset_mutex;
@@ -28,20 +29,13 @@ struct sreset_priv {
 	unsigned long last_tx_complete_time;
 };
 
-#include <rtl8192d_hal.h>
-
 #define	WIFI_STATUS_SUCCESS		0
-#define	USB_VEN_REQ_CMD_FAIL	BIT0
+#define	USB_VEN_REQ_CMD_FAIL		BIT0
 #define	USB_READ_PORT_FAIL		BIT1
 #define	USB_WRITE_PORT_FAIL		BIT2
-#define	WIFI_MAC_TXDMA_ERROR	BIT3
-#define   WIFI_TX_HANG				BIT4
-#define	WIFI_RX_HANG				BIT5
-#define		WIFI_IF_NOT_EXIST			BIT6
-
-static void sreset_init_value(struct rtw_adapter *padapter) {}
-static void sreset_reset_value(struct rtw_adapter *padapter) {}
-static u8 sreset_get_wifi_status(struct rtw_adapter *padapter) {return WIFI_STATUS_SUCCESS;}
-static void sreset_set_wifi_error_status(struct rtw_adapter *padapter, u32 status) {}
+#define	WIFI_MAC_TXDMA_ERROR		BIT3
+#define WIFI_TX_HANG			BIT4
+#define	WIFI_RX_HANG			BIT5
+#define WIFI_IF_NOT_EXIST		BIT6
 
 #endif
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -607,7 +607,7 @@ static int set_wep_key(struct rtw_adapte
 static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
 {
 	int ret = 0;
-	u32 wep_key_idx, wep_key_len,wep_total_len;
+	u32 wep_key_idx, wep_key_len;
 	struct sta_info *psta = NULL, *pbcmc_sta = NULL;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
@@ -888,7 +888,7 @@ exit:
 static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
 {
 	int ret = 0;
-	u32 wep_key_idx, wep_key_len,wep_total_len;
+	u32 wep_key_idx, wep_key_len;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
@@ -1394,14 +1394,6 @@ void rtw_cfg80211_surveydone_event_callb
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	struct __queue		*queue	= &(pmlmepriv->scanned_queue);
 	struct	wlan_network	*pnetwork = NULL;
-	u32 cnt=0;
-	u32 wait_for_surveydone;
-	int wait_status;
-#ifdef CONFIG_P2P
-	struct	wifidirect_info*	pwdinfo = &padapter->wdinfo;
-#endif /* CONFIG_P2P */
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
-	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 
 	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
@@ -1434,16 +1426,15 @@ static int rtw_cfg80211_set_probe_req_wp
 	int ret = 0;
 	uint wps_ielen = 0;
 	u8 *wps_ie;
-	u32	p2p_ielen = 0;
-	u8 *p2p_ie;
-	u32	wfd_ielen = 0;
-	u8 *wfd_ie;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+#ifdef CONFIG_P2P
+	u32 p2p_ielen = 0;
+	u8 *p2p_ie;
+#endif
 
 	if (len > 0) {
 		if ((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen))) {
 			if (pmlmepriv->wps_probe_req_ie) {
-				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 				pmlmepriv->wps_probe_req_ie_len = 0;
 				kfree(pmlmepriv->wps_probe_req_ie);
 				pmlmepriv->wps_probe_req_ie = NULL;
@@ -1463,7 +1454,6 @@ static int rtw_cfg80211_set_probe_req_wp
 		if ((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen))) {
 
 			if (pmlmepriv->p2p_probe_req_ie) {
-				u32 free_len = pmlmepriv->p2p_probe_req_ie_len;
 				pmlmepriv->p2p_probe_req_ie_len = 0;
 				kfree(pmlmepriv->p2p_probe_req_ie);
 				pmlmepriv->p2p_probe_req_ie = NULL;
@@ -1492,6 +1482,7 @@ static int cfg80211_rtw_scan(struct wiph
 	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+	int social_channel = 0;
 #endif /* CONFIG_P2P */
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 	struct cfg80211_ssid *ssids = request->ssids;
@@ -1502,11 +1493,6 @@ static int cfg80211_rtw_scan(struct wiph
 	int i;
 	u8 _status = false;
 	int ret = 0;
-	u8 *wps_ie=NULL;
-	uint wps_ielen=0;
-	u8 *p2p_ie=NULL;
-	uint p2p_ielen=0;
-	int social_channel = 0, j = 0;
 	bool need_indicate_scan_done = false;
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -1537,13 +1523,10 @@ static int cfg80211_rtw_scan(struct wiph
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
 
 		if (request->n_channels == 3 &&
-			request->channels[0]->hw_value == 1 &&
-			request->channels[1]->hw_value == 6 &&
-			request->channels[2]->hw_value == 11
-		)
-		{
+		    request->channels[0]->hw_value == 1 &&
+		    request->channels[1]->hw_value == 6 &&
+		    request->channels[2]->hw_value == 11)
 			social_channel = 1;
-		}
 	}
 	#endif /* CONFIG_P2P */
 
@@ -1640,9 +1623,6 @@ static int cfg80211_rtw_scan(struct wiph
 check_need_indicate_scan_done:
 	if (need_indicate_scan_done)
 		rtw_cfg80211_surveydone_event_callback(padapter);
-
-exit:
-
 	return ret;
 }
 
@@ -1675,9 +1655,7 @@ static int rtw_cfg80211_set_wpa_version(
 	}
 
 	if (wpa_version & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))
-	{
 		psecuritypriv->ndisauthtype = NDIS802_11AUTHMODEWPAPSK;
-	}
 
 	return 0;
 }
@@ -1769,11 +1747,10 @@ static int rtw_cfg80211_set_key_mgt(stru
 
 	if (key_mgt == WLAN_AKM_SUITE_8021X)
 		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
-	else if (key_mgt == WLAN_AKM_SUITE_PSK) {
+	else if (key_mgt == WLAN_AKM_SUITE_PSK)
 		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
-	} else {
+	else
 		DBG_8192D("Invalid key mgt: 0x%x\n", key_mgt);
-	}
 
 	return 0;
 }
@@ -1781,13 +1758,13 @@ static int rtw_cfg80211_set_key_mgt(stru
 static int rtw_cfg80211_set_wpa_ie(struct rtw_adapter *padapter, u8 *pie, size_t ielen)
 {
 	u8 *buf=NULL, *pos=NULL;
-	u32 left;
 	int group_cipher = 0, pairwise_cipher = 0;
 	int ret = 0;
 	int wpa_ielen=0;
 	int wpa2_ielen=0;
 	u8 *pwpa, *pwpa2;
 	u8 null_addr[]= {0,0,0,0,0,0};
+	int i;
 
 	if (pie == NULL || !ielen) {
 		/* Treat this as normal case, but need to clear WIFI_UNDER_WPS */
@@ -1809,12 +1786,11 @@ static int rtw_cfg80211_set_wpa_ie(struc
 	memcpy(buf, pie , ielen);
 
 	/* dump */
-	{
-		int i;
-		DBG_8192D("set wpa_ie(length:%zu):\n", ielen);
-		for (i=0;i<ielen;i=i+8)
-			DBG_8192D("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n",buf[i],buf[i+1],buf[i+2],buf[i+3],buf[i+4],buf[i+5],buf[i+6],buf[i+7]);
-	}
+	DBG_8192D("set wpa_ie(length:%zu):\n", ielen);
+	for (i = 0; i < ielen; i += 8)
+		DBG_8192D("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n",
+			  buf[i], buf[i+1], buf[i+2], buf[i+3], buf[i+4],
+			  buf[i+5], buf[i+6], buf[i+7]);
 
 	pos = buf;
 	if (ielen < RSN_HEADER_LEN) {
@@ -1919,7 +1895,6 @@ static int rtw_cfg80211_set_wpa_ie(struc
 
 		if ((p2p_ie=rtw_get_p2p_ie(buf, ielen, NULL, &p2p_ielen))) {
 			if (pmlmepriv->p2p_assoc_req_ie) {
-				u32 free_len = pmlmepriv->p2p_assoc_req_ie_len;
 				pmlmepriv->p2p_assoc_req_ie_len = 0;
 				kfree(pmlmepriv->p2p_assoc_req_ie);
 				pmlmepriv->p2p_assoc_req_ie = NULL;
@@ -2011,7 +1986,6 @@ static int cfg80211_rtw_connect(struct w
 	}
 
 	if (sme->ssid_len > IW_ESSID_MAX_SIZE) {
-
 		ret= -E2BIG;
 		goto exit;
 	}
@@ -2025,14 +1999,13 @@ static int cfg80211_rtw_connect(struct w
 	if (sme->bssid)
 		DBG_8192D("bssid=%pM\n", sme->bssid);
 
-	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {
 		ret = -EBUSY;
 		DBG_8192D("%s, fw_state=0x%x, goto exit\n", __func__, pmlmepriv->fw_state);
 		goto exit;
 	}
-	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))
 		rtw_scan_abort(padapter);
-	}
 
 	spin_lock_bh(&pmlmepriv->lock);
 	spin_lock_bh(&queue->lock);
@@ -2371,7 +2344,6 @@ static int cfg80211_rtw_flush_pmksa(stru
 #ifdef CONFIG_92D_AP_MODE
 void rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
 {
-	struct wireless_dev *pwdev = padapter->rtw_wdev;
 	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
 	struct net_device *ndev = padapter->pnetdev;
 	s32 freq;
@@ -2447,11 +2419,8 @@ static int rtw_cfg80211_monitor_if_open(
 
 static int rtw_cfg80211_monitor_if_close(struct net_device *ndev)
 {
-	int ret = 0;
-
 	DBG_8192D("%s\n", __func__);
-
-	return ret;
+	return 0;
 }
 
 static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
@@ -2536,7 +2505,9 @@ static int rtw_cfg80211_monitor_if_xmit_
 		u8 *buf = skb->data;
 		u32 len = skb->len;
 		u8 category, action;
+#ifdef CONFIG_P2P
 		int type = -1;
+#endif
 
 		if (rtw_action_frame_parse(buf, len, &category, &action) == false) {
 			DBG_8192D(FUNC_NDEV_FMT" frame_control:0x%x\n", FUNC_NDEV_ARG(ndev),
@@ -2555,12 +2526,12 @@ static int rtw_cfg80211_monitor_if_xmit_
 		else
 			DBG_8192D("RTW_Tx:category(%u), action(%u)\n", category, action);
 
+#ifdef CONFIG_P2P
 dump:
+#endif
 		/* starting alloc mgmt frame to dump it */
 		if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
-		{
 			goto fail;
-		}
 
 		/* update attribute */
 		pattrib = &pmgntframe->attrib;
@@ -2597,11 +2568,6 @@ fail:
 	return 0;
 }
 
-static void rtw_cfg80211_monitor_if_set_multicast_list(struct net_device *ndev)
-{
-	DBG_8192D("%s\n", __func__);
-}
-
 static int rtw_cfg80211_monitor_if_set_mac_address(struct net_device *ndev, void *addr)
 {
 	int ret = 0;
@@ -2761,10 +2727,11 @@ static int rtw_add_beacon(struct rtw_ada
 	int ret=0;
 	u8 *pbuf = NULL;
 	uint len, wps_ielen=0;
-	uint p2p_ielen=0;
-	u8 *p2p_ie;
-	u8 got_p2p_ie = false;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+#ifdef CONFIG_P2P
+	u32 p2p_ielen = 0;
+	u8 got_p2p_ie = false;
+#endif
 
 	DBG_8192D("%s beacon_head_len=%zu, beacon_tail_len=%zu\n", __func__, head_len, tail_len);
 
@@ -2789,8 +2756,7 @@ static int rtw_add_beacon(struct rtw_ada
 
 #ifdef CONFIG_P2P
 	/* check p2p ie if inclued */
-	if (rtw_get_p2p_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &p2p_ielen))
-	{
+	if (rtw_get_p2p_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &p2p_ielen)) {
 		DBG_8192D("got p2p_ie, len=%d\n", p2p_ielen);
 		got_p2p_ie = true;
 	}
@@ -2904,7 +2870,7 @@ static int	cfg80211_rtw_del_station(stru
 {
 	int ret=0;
 	struct list_head *phead, *plist;
-	u8 updated;
+	u8 updated = 0;
 	struct sta_info *psta = NULL;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(ndev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -3000,46 +2966,21 @@ static int	cfg80211_rtw_dump_station(str
 static int	cfg80211_rtw_change_bss(struct wiphy *wiphy, struct net_device *ndev,
 			      struct bss_parameters *params)
 {
-	u8 i;
-
-	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-	return 0;
-}
-
-static int rtw_set_channel(struct wiphy *wiphy, struct net_device *ndev,
-			   struct ieee80211_channel *chan,
-			   enum nl80211_channel_type channel_type)
-{
-	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-
-	return 0;
-}
-
-static int	cfg80211_rtw_auth(struct wiphy *wiphy, struct net_device *ndev,
-			struct cfg80211_auth_request *req)
-{
 	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-
 	return 0;
 }
 
-static int	cfg80211_rtw_assoc(struct wiphy *wiphy, struct net_device *ndev,
-			 struct cfg80211_assoc_request *req)
-{
-	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-
-	return 0;
-}
 #endif /* CONFIG_92D_AP_MODE */
 
 void rtw_cfg80211_rx_action_p2p(struct rtw_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
 {
-	int type;
 	s32 freq;
 	int channel;
-	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
 	u8 category, action;
 	u32 flags = 0;		/* FIX ME */
+#ifdef CONFIG_P2P
+	int type;
+#endif
 
 	channel = rtw_get_oper_ch(padapter);
 
@@ -3052,7 +2993,9 @@ void rtw_cfg80211_rx_action_p2p(struct r
 	rtw_action_frame_parse(pmgmt_frame, frame_len, &category, &action);
 	DBG_8192D("RTW_Rx:category(%u), action(%u)\n", category, action);
 
+#ifdef CONFIG_P2P
 indicate:
+#endif
 	if (channel <= RTW_CH_MAX_2G_CHANNEL)
 		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 	else
@@ -3063,12 +3006,13 @@ indicate:
 
 void rtw_cfg80211_rx_p2p_action_public(struct rtw_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
 {
-	int type;
 	s32 freq;
 	int channel;
-	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
 	u8 category, action;
 	u32 flags = 0; /*FIX ME */
+#ifdef CONFIG_P2P
+	int type;
+#endif
 
 	channel = rtw_get_oper_ch(padapter);
 
@@ -3087,7 +3031,9 @@ void rtw_cfg80211_rx_p2p_action_public(s
 	rtw_action_frame_parse(pmgmt_frame, frame_len, &category, &action);
 	DBG_8192D("RTW_Rx:category(%u), action(%u)\n", category, action);
 
+#ifdef CONFIG_P2P
 indicate:
+#endif
 	if (channel <= RTW_CH_MAX_2G_CHANNEL)
 		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 	else
@@ -3100,8 +3046,6 @@ void rtw_cfg80211_rx_action(struct rtw_a
 {
 	s32 freq;
 	int channel;
-	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
 	u8 category, action;
 	u32 flags = 0;		/* FIX ME */
 
@@ -3148,7 +3092,6 @@ void rtw_cfg80211_issue_p2p_provision_re
 	unsigned short		*fctrl;
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
 	u8 *frame_body = (unsigned char *)(buf + sizeof(struct ieee80211_hdr_3addr));
 	size_t frame_body_len = len - sizeof(struct ieee80211_hdr_3addr);
@@ -3321,7 +3264,6 @@ static s32 cfg80211_rtw_remain_on_channe
 {
 	s32 err = 0;
 	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
@@ -3455,9 +3397,7 @@ static s32 cfg80211_rtw_cancel_remain_on
 {
 	s32 err = 0;
 	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 
 	DBG_8192D(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
@@ -3479,210 +3419,27 @@ static s32 cfg80211_rtw_cancel_remain_on
 
 #endif /* CONFIG_P2P */
 
-static int _cfg80211_rtw_mgmt_tx(struct rtw_adapter *padapter, u8 tx_ch, const u8 *buf, size_t len)
-{
-	struct xmit_frame	*pmgntframe;
-	struct pkt_attrib	*pattrib;
-	unsigned char	*pframe;
-	int ret = 0;
-	bool ack = true;
-	struct ieee80211_hdr *pwlanhdr;
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
-	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-
-	if (0 == rtw_pwr_wakeup(padapter)) {
-		ret = -EFAULT;
-		goto exit;
-	}
-
-	rtw_set_scan_deny(padapter, 1000);
-
-	rtw_scan_abort(padapter);
-	#ifdef CONFIG_CONCURRENT_MODE
-	if (rtw_buddy_adapter_up(padapter))
-		rtw_scan_abort(padapter->pbuddy_adapter);
-	#endif /* CONFIG_CONCURRENT_MODE */
-
-	if (padapter->cfg80211_wdinfo.is_ro_ch == true) {
-		#ifdef CONFIG_CONCURRENT_MODE
-		DBG_8192D("%s, extend ro ch time\n", __func__);
-		_set_timer(&padapter->cfg80211_wdinfo.remain_on_ch_timer, pwdinfo->ext_listen_period);
-		#endif /* CONFIG_CONCURRENT_MODE */
-	}
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(padapter, _FW_LINKED)) {
-		u8 co_channel=0xff;
-		PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
-		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
-		co_channel = rtw_get_oper_ch(padapter);
-
-		if (tx_ch != pbuddy_mlmeext->cur_channel) {
-			if (atomic_read(&pwdev_priv->switch_ch_to)==1) {
-				DBG_8192D("%s, issue nulldata pwrbit=1\n", __func__);
-				issue_nulldata(padapter->pbuddy_adapter, NULL, 1, 3, 500);
-
-				atomic_set(&pwdev_priv->switch_ch_to, 0);
-
-			}
-
-			DBG_8192D("%s, set switch ch timer, period=%d\n", __func__, pwdinfo->ext_listen_period);
-			_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_period);
-		}
-
-		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
-			pmlmeext->cur_channel = tx_ch;
-
-		if (tx_ch != co_channel)
-			set_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-	} else
-#endif /* CONFIG_CONCURRENT_MODE */
-	if (tx_ch != rtw_get_oper_ch(padapter)) {
-		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
-			pmlmeext->cur_channel = tx_ch;
-		set_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-	}
-
-	/* starting alloc mgmt frame to dump it */
-	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
-	{
-		/* ret = -ENOMEM; */
-		ret = 0;
-		goto exit;
-	}
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(padapter, pattrib);
-	pattrib->retry_ctrl = false;
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-
-	memcpy(pframe, (void*)buf, len);
-	pattrib->pktlen = len;
-
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-	/* update seq number */
-	pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
-	pattrib->seqnum = pmlmeext->mgnt_seq;
-	pmlmeext->mgnt_seq++;
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != 1) {
-		ack = false;
-		ret = 0;
-	} else {
-		ret = 1;
-	}
-
-exit:
-
-	return ret;
-}
-
-static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
-	struct wireless_dev *wdev,
-	struct ieee80211_channel *chan,
-	bool offchan,
-	unsigned int wait,
-	const u8 *buf, size_t len,
-	bool no_cck,
-	bool dont_wait_for_ack,
-	u64 *cookie)
-{
-	struct rtw_adapter *padapter = (struct rtw_adapter *)wiphy_to_adapter(wiphy);
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
-	int ret = 0;
-	int tx_ret;
-	u32 dump_limit = RTW_MAX_MGMT_TX_CNT;
-	u32 dump_cnt = 0;
-	bool ack = true;
-	u8 tx_ch = (u8)ieee80211_frequency_to_channel(chan->center_freq);
-	u8 category, action;
-	int type = (-1);
-	u32 start = jiffies;
-
-	/* cookie generation */
-	*cookie = (unsigned long) buf;
-
-	/* indicate ack before issue frame to avoid racing with rsp frame */
-	cfg80211_mgmt_tx_status(padapter->rtw_wdev, *cookie, buf, len, ack, GFP_KERNEL);
-
-	if (rtw_action_frame_parse(buf, len, &category, &action) == false) {
-		DBG_8192D(FUNC_ADPT_FMT" frame_control:0x%x\n", FUNC_ADPT_ARG(padapter),
-			le16_to_cpu(((struct ieee80211_hdr_3addr *)buf)->frame_control));
-		goto exit;
-	}
-
-	DBG_8192D("RTW_Tx:tx_ch=%d, da=%pM\n", tx_ch, GetAddr1Ptr(buf));
-	#ifdef CONFIG_P2P
-	if ((type = rtw_p2p_check_frames(padapter, buf, len, true)) >= 0)
-		goto dump;
-	#endif
-	if (category == RTW_WLAN_CATEGORY_PUBLIC)
-		DBG_8192D("RTW_Tx:%s\n", action_public_str(action));
-	else
-		DBG_8192D("RTW_Tx:category(%u), action(%u)\n", category, action);
-
-dump:
-	do {
-		dump_cnt++;
-		tx_ret = _cfg80211_rtw_mgmt_tx(padapter, tx_ch, buf, len);
-	} while (dump_cnt < dump_limit && tx_ret != 1);
-
-	if (tx_ret != 1 || dump_cnt > 1) {
-		DBG_8192D(FUNC_ADPT_FMT" %s (%d/%d) in %d ms\n", FUNC_ADPT_ARG(padapter),
-			tx_ret==1?"OK":"FAIL", dump_cnt, dump_limit, rtw_systime_to_ms(jiffies - start));
-	}
-
-	switch (type) {
-	case P2P_GO_NEGO_CONF:
-		rtw_clear_scan_deny(padapter);
-		break;
-	case P2P_INVIT_RESP:
-		if (pwdev_priv->invit_info.flags & BIT(0)
-			&& pwdev_priv->invit_info.status == 0)
-		{
-			DBG_8192D(FUNC_ADPT_FMT" agree with invitation of persistent group\n",
-				FUNC_ADPT_ARG(padapter));
-			rtw_set_scan_deny(padapter, 5000);
-			rtw_pwr_wakeup_ex(padapter, 5000);
-			rtw_clear_scan_deny(padapter);
-		}
-		break;
-	}
-
-exit:
-	return ret;
-}
-
 static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
 {
 	int ret = 0;
 	uint wps_ielen = 0;
 	u8 *wps_ie;
-	u32	p2p_ielen = 0;
-	u8 wps_oui[8]={0x0,0x50,0xf2,0x04};
-	u8 *p2p_ie;
-	u32	wfd_ielen = 0;
-	u8 *wfd_ie;
+#ifdef CONFIG_92D_AP_MODE
+	u8 wps_oui[8] = {0x0, 0x50, 0xf2, 0x04};
+#endif
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(ndev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+#ifdef CONFIG_P2P
+	u32 p2p_ielen = 0;
+	u8 *p2p_ie;
+#endif
 
 	DBG_8192D(FUNC_NDEV_FMT" ielen=%d\n", FUNC_NDEV_ARG(ndev), len);
 
 	if (len > 0) {
 		if ((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen))) {
 			if (pmlmepriv->wps_beacon_ie) {
-				u32 free_len = pmlmepriv->wps_beacon_ie_len;
 				pmlmepriv->wps_beacon_ie_len = 0;
 				kfree(pmlmepriv->wps_beacon_ie);
 				pmlmepriv->wps_beacon_ie = NULL;
@@ -3706,7 +3463,6 @@ static int rtw_cfg80211_set_beacon_wpsp2
 		#ifdef CONFIG_P2P
 		if ((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen))) {
 			if (pmlmepriv->p2p_beacon_ie) {
-				u32 free_len = pmlmepriv->p2p_beacon_ie_len;
 				pmlmepriv->p2p_beacon_ie_len = 0;
 				kfree(pmlmepriv->p2p_beacon_ie);
 				pmlmepriv->p2p_beacon_ie = NULL;
@@ -3737,10 +3493,10 @@ static int rtw_cfg80211_set_probe_resp_w
 	int ret = 0;
 	uint wps_ielen = 0;
 	u8 *wps_ie;
-	u32	p2p_ielen = 0;
+#ifdef CONFIG_P2P
+	u32 p2p_ielen = 0;
 	u8 *p2p_ie;
-	u32	wfd_ielen = 0;
-	u8 *wfd_ie;
+#endif
 
 	if (len > 0) {
 		wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen);
@@ -3749,7 +3505,6 @@ static int rtw_cfg80211_set_probe_resp_w
 			u16	*puconfig_method = NULL;
 
 			if (pmlmepriv->wps_probe_resp_ie) {
-				u32 free_len = pmlmepriv->wps_probe_resp_ie_len;
 				pmlmepriv->wps_probe_resp_ie_len = 0;
 				kfree(pmlmepriv->wps_probe_resp_ie);
 				pmlmepriv->wps_probe_resp_ie = NULL;
@@ -3793,7 +3548,6 @@ static int rtw_cfg80211_set_probe_resp_w
 
 			if (is_GO == false) {
 				if (pmlmepriv->p2p_probe_resp_ie) {
-					u32 free_len = pmlmepriv->p2p_probe_resp_ie_len;
 					pmlmepriv->p2p_probe_resp_ie_len = 0;
 					kfree(pmlmepriv->p2p_probe_resp_ie);
 					pmlmepriv->p2p_probe_resp_ie = NULL;
@@ -3807,12 +3561,8 @@ static int rtw_cfg80211_set_probe_resp_w
 				}
 				memcpy(pmlmepriv->p2p_probe_resp_ie, p2p_ie, p2p_ielen);
 				pmlmepriv->p2p_probe_resp_ie_len = p2p_ielen;
-			}
-			else
-			{
-				if (pmlmepriv->p2p_go_probe_resp_ie)
-				{
-					u32 free_len = pmlmepriv->p2p_go_probe_resp_ie_len;
+			} else {
+				if (pmlmepriv->p2p_go_probe_resp_ie) {
 					pmlmepriv->p2p_go_probe_resp_ie_len = 0;
 					kfree(pmlmepriv->p2p_go_probe_resp_ie);
 					pmlmepriv->p2p_go_probe_resp_ie = NULL;
@@ -3846,7 +3596,6 @@ static int rtw_cfg80211_set_assoc_resp_w
 	{
 		if (pmlmepriv->wps_assoc_resp_ie)
 		{
-			u32 free_len = pmlmepriv->wps_assoc_resp_ie_len;
 			pmlmepriv->wps_assoc_resp_ie_len = 0;
 			kfree(pmlmepriv->wps_assoc_resp_ie);
 			pmlmepriv->wps_assoc_resp_ie = NULL;
@@ -3870,7 +3619,9 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struc
 {
 	int ret = 0;
 	uint wps_ielen = 0;
-	u32	p2p_ielen = 0;
+#ifdef CONFIG_P2P
+	u32 p2p_ielen = 0;
+#endif
 
 	if ((rtw_get_wps_ie(buf, len, NULL, &wps_ielen) && (wps_ielen>0))
 		#ifdef CONFIG_P2P
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -87,14 +87,6 @@ static int hwaddr_aton_i(const char *txt
 	return 0;
 }
 
-static void indicate_wx_custom_event(struct rtw_adapter *padapter, char *msg)
-{
-}
-
-static void request_wps_pbc_event(struct rtw_adapter *padapter)
-{
-}
-
 void indicate_wx_scan_complete_event(struct rtw_adapter *padapter)
 {
 }
@@ -120,11 +112,8 @@ static char *translate_scan(struct rtw_a
 	char *p;
 	u16 max_rate = 0, rate, ht_cap = false;
 	u32 i = 0;
-	char	*current_val;
-	long rssi;
 	u8 bw_40MHz = 0, short_GI = 0;
 	u16 mcs_rate = 0;
-	struct registry_priv *pregpriv = &padapter->registrypriv;
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
 #endif /* CONFIG_P2P */
@@ -577,7 +566,6 @@ exit:
 static int rtw_set_wpa_ie(struct rtw_adapter *padapter, char *pie, unsigned short ielen)
 {
 	u8 *buf = NULL;
-	u32 left;
 	int group_cipher = 0, pairwise_cipher = 0;
 	int ret = 0;
 	u8	null_addr[]= {0, 0, 0, 0, 0, 0};
@@ -733,7 +721,6 @@ static int rtw_wx_get_name(struct net_de
 			   union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	u16 cap;
 	u32 ht_ielen = 0;
 	char *p;
 	u8 ht_cap = false;
@@ -901,7 +888,6 @@ static int rtw_wx_set_pmkid(struct net_d
 			    union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv  *pmlmepriv = &padapter->mlmepriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct iw_pmksa*  pPMK = (struct iw_pmksa*) extra;
 	u8          j, blInserted = false;
@@ -1528,11 +1514,9 @@ static int rtw_wx_set_essid(struct net_d
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct __queue *queue = &pmlmepriv->scanned_queue;
-	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct list_head *phead;
 	struct wlan_network *pnetwork = NULL;
 	struct ndis_802_11_ssid ndis_ssid;
-	s8 status = true;
 	enum NDIS_802_11_AUTHENTICATION_MODE authmode;
 	u8 *dst_ssid, *src_ssid;
 	uint ret = 0, len;
@@ -2437,7 +2421,6 @@ static int rtw_wx_set_channel_plan(struc
 				   union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct registry_priv *pregistrypriv = &padapter->registrypriv;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	u8 channel_plan_req = (u8) (*((int *)wrqu));
 
@@ -2575,9 +2558,6 @@ static int rtw_mp_ioctl_hdl(struct net_d
 						union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
-	u32 BytesRead, BytesWritten, BytesNeeded;
-	struct oid_par_priv	oid_par;
-	struct mp_ioctl_handler	*phandler;
 	struct mp_ioctl_param	*poidparam;
 	uint status = 0;
 	u16 len;
@@ -2637,7 +2617,7 @@ static int rtw_get_ap_info(struct net_de
 			   struct iw_request_info *info,
 			   union iwreq_data *wrqu, char *extra)
 {
-	int bssid_match, ret = 0;
+	int ret = 0;
 	u32 cnt = 0, wpa_ielen;
 	struct list_head *plist, *phead;
 	unsigned char *pbuf;
@@ -2782,7 +2762,6 @@ static int rtw_wps_start(struct net_devi
 	else if (u32wps_start == 3) /*  WPS Stop because of wps fail */
 		rtw_led_control(padapter, LED_CTL_STOP_WPS_FAIL);
 
-exit:
 	return ret;
 }
 
@@ -2794,11 +2773,8 @@ static int rtw_wext_p2p_enable(struct ne
 
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	enum P2P_ROLE init_role = P2P_ROLE_DISABLE;
 
 	if (*extra == '0')
@@ -2874,8 +2850,6 @@ static int rtw_p2p_set_go_nego_ssid(stru
 				    union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
 
 	DBG_8192D("[%s] ssid = %s, len = %d\n", __func__, extra, (u32)strlen(extra));
@@ -3075,7 +3049,6 @@ static int rtw_p2p_get_status(struct net
 {
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	if (padapter->bShowGetP2PState) {
@@ -3110,7 +3083,6 @@ static int rtw_p2p_get_req_cm(struct net
 
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	sprintf(extra, "\n\nCM =%s\n", pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req);
@@ -3125,7 +3097,6 @@ static int rtw_p2p_get_role(struct net_d
 
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n",
@@ -3149,7 +3120,6 @@ static int rtw_p2p_get_peer_ifaddr(struc
 
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
@@ -3171,7 +3141,6 @@ static int rtw_p2p_get_peer_devaddr(stru
 
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
@@ -3191,7 +3160,6 @@ static int rtw_p2p_get_peer_devaddr_by_i
 						  union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
@@ -3212,7 +3180,6 @@ static int rtw_p2p_get_groupid(struct ne
 
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	sprintf(extra, "\n%pM %s",
@@ -3227,7 +3194,6 @@ static int rtw_p2p_get_op_ch(struct net_
 			     union iwreq_data *wrqu, char *extra)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	DBG_8192D("[%s] Op_ch = %02x\n", __func__, pwdinfo->operating_channel);
@@ -3650,7 +3616,6 @@ static int rtw_p2p_connect(struct net_de
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 	u8					peerMAC[ETH_ALEN] = { 0x00 };
 	int					jj, kk;
-	u8					peerMACStr[ETH_ALEN * 2] = { 0x00 };
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct list_head *plist, *phead;
 	struct __queue *queue	= &(pmlmepriv->scanned_queue);
@@ -3725,8 +3690,7 @@ static int rtw_p2p_connect(struct net_de
 		pwdinfo->nego_req_info.benable = true;
 
 		del_timer_sync(&pwdinfo->restore_p2p_state_timer);
-		if (rtw_p2p_state(pwdinfo) != P2P_STATE_GONEGO_OK)
-		{
+		if (rtw_p2p_state(pwdinfo) != P2P_STATE_GONEGO_OK) {
 			/*	Restore to the listen state if the current p2p state is not nego OK */
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
 		}
@@ -3735,10 +3699,11 @@ static int rtw_p2p_connect(struct net_de
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED))
-		{
+		if (check_buddy_fwstate(padapter, _FW_LINKED)) {
 			/*	Have to enter the power saving with the AP */
-			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
+			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel,
+					   pbuddy_mlmeext->cur_ch_offset,
+					   pbuddy_mlmeext->cur_bwmode);
 
 			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
 		}
@@ -3749,24 +3714,17 @@ static int rtw_p2p_connect(struct net_de
 
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_buddy_fwstate(padapter, _FW_LINKED))
-		{
 			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_GO_NEGO_TIMEOUT);
-		}
 		else
-		{
 			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_GO_NEGO_TIMEOUT);
-		}
 #else
 		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_GO_NEGO_TIMEOUT);
 #endif /*  CONFIG_CONCURRENT_MODE */
 
-	}
-	else
-	{
+	} else {
 		DBG_8192D("[%s] Not Found in Scanning Queue~\n", __func__);
 		ret = -1;
 	}
-exit:
 	return ret;
 }
 
@@ -3775,20 +3733,18 @@ static int rtw_p2p_invite_req(struct net
 			      union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
-	struct rtw_adapter					*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point				*pdata = &wrqu->data;
-	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
-	int						jj, kk;
-	u8						peerMACStr[ETH_ALEN * 2] = { 0x00 };
-	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
+	int jj, kk;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct list_head *plist, *phead;
 	struct __queue *queue = &(pmlmepriv->scanned_queue);
 	struct	wlan_network		*pnetwork = NULL;
-	uint						uintPeerChannel = 0;
-	u8						attr_content[50] = { 0x00 }, _status = 0;
-	u8						*p2pie;
-	uint						p2pielen = 0, attr_contentlen = 0;
-	struct tx_invite_req_info*	pinvite_req_info = &pwdinfo->invitereq_info;
+	uint uintPeerChannel = 0;
+	u8 attr_content[50] = { 0x00 };
+	u8 *p2pie;
+	uint p2pielen = 0, attr_contentlen = 0;
+	struct tx_invite_req_info *pinvite_req_info = &pwdinfo->invitereq_info;
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter					*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_priv			*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
@@ -3803,19 +3759,15 @@ static int rtw_p2p_invite_req(struct net
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
-	if (wrqu->data.length <=  37)
-	{
+	if (wrqu->data.length <=  37) {
 		DBG_8192D("[%s] Wrong format!\n", __func__);
 		return ret;
 	}
 
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-	{
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
 		DBG_8192D("[%s] WiFi Direct is disable!\n", __func__);
 		return ret;
-	}
-	else
-	{
+	} else {
 		/*	Reset the content of struct tx_invite_req_info */
 		pinvite_req_info->benable = false;
 		memset(pinvite_req_info->go_bssid, 0x00, ETH_ALEN);
@@ -3827,72 +3779,54 @@ static int rtw_p2p_invite_req(struct net
 	}
 
 	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
-	{
 		pinvite_req_info->peer_macaddr[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
-	}
 
 	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = phead->next;
 
-	while (1)
-	{
+	while (1) {
 		if (rtw_end_of_queue_search(phead, plist) == true)
 			break;
 
 		pnetwork = container_of(plist, struct wlan_network, list);
 
-		/*	Commented by Albert 2011/05/18 */
 		/*	Match the device address located in the P2P IE */
 		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
 
-		if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
-		{
+		if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen))) {
 			/*	The P2P Device ID attribute is included in the Beacon frame. */
 			/*	The P2P Device Info attribute is included in the probe response frame. */
 
-			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
-			{
+			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen)) {
 				/*	Handle the P2P Device ID attribute of Beacon first */
-				if (!memcmp(attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN))
-				{
+				if (!memcmp(attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN)) {
 					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
 					break;
 				}
-			}
-			else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
-			{
+			} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen)) {
 				/*	Handle the P2P Device Info attribute of probe response */
-				if (!memcmp(attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN))
-				{
+				if (!memcmp(attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN)) {
 					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
 					break;
 				}
 			}
-
 		}
-
 		plist = plist->next;
-
 	}
 
 	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
-	if (uintPeerChannel)
-	{
+	if (uintPeerChannel) {
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
-		{
 			del_timer_sync(&pwdinfo->ap_p2p_switch_timer);
-		}
 #endif /*  CONFIG_CONCURRENT_MODE */
 
 		/*	Store the GO's bssid */
 		for (jj = 0, kk = 18; jj < ETH_ALEN; jj++, kk += 3)
-		{
 			pinvite_req_info->go_bssid[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
-		}
 
 		/*	Store the GO's ssid */
 		pinvite_req_info->ssidlen = wrqu->data.length - 36;
@@ -3904,43 +3838,31 @@ static int rtw_p2p_invite_req(struct net
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_INVITE_REQ);
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
-		{
+		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) {
 			/*	Have to enter the power saving with the AP */
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 
 			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
-		}
-		else
-		{
+		} else {
 			set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 		}
 #else
 		set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 #endif
-
 		_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
-		{
 			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_INVITE_TIMEOUT);
-		}
 		else
-		{
 			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT);
-		}
 #else
 		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT);
 #endif /*  CONFIG_CONCURRENT_MODE */
 
-	}
-	else
-	{
+	} else {
 		DBG_8192D("[%s] NOT Found in the Scanning Queue!\n", __func__);
 	}
-exit:
-
 	return ret;
 }
 
@@ -3949,57 +3871,32 @@ static int rtw_p2p_set_persistent(struct
 				  union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
-	struct rtw_adapter					*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point				*pdata = &wrqu->data;
-	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
-	int						jj, kk;
-	u8						peerMACStr[ETH_ALEN * 2] = { 0x00 };
-	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
-	struct list_head *plist, *phead;
-	struct __queue *queue = &(pmlmepriv->scanned_queue);
-	struct	wlan_network		*pnetwork = NULL;
-	uint						uintPeerChannel = 0;
-	u8						attr_content[50] = { 0x00 }, _status = 0;
-	u8						*p2pie;
-	uint						p2pielen = 0, attr_contentlen = 0;
-	struct tx_invite_req_info*	pinvite_req_info = &pwdinfo->invitereq_info;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
 #ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter					*pbuddy_adapter = padapter->pbuddy_adapter;
-	struct mlme_priv			*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
-	struct mlme_ext_priv		*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+	struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
+	struct mlme_priv *pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
+	struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 #endif /*  CONFIG_CONCURRENT_MODE */
 
-	/*	Commented by Albert 20120328 */
 	/*	The input data is 0 or 1 */
 	/*	0: disable persistent group functionality */
 	/*	1: enable persistent group founctionality */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-	{
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
 		DBG_8192D("[%s] WiFi Direct is disable!\n", __func__);
 		return ret;
-	}
-	else
-	{
+	} else {
 		if (extra[0] == '0')	/*	Disable the persistent group function. */
-		{
 			pwdinfo->persistent_supported = false;
-		}
 		else if (extra[0] == '1')	/*	Enable the persistent group function. */
-		{
 			pwdinfo->persistent_supported = true;
-		}
 		else
-		{
 			pwdinfo->persistent_supported = false;
-		}
 	}
 	DBG_8192D("[%s] persistent_supported = %d\n", __func__, pwdinfo->persistent_supported);
-
-exit:
-
 	return ret;
 }
 
@@ -4008,19 +3905,18 @@ static int rtw_p2p_prov_disc(struct net_
 			     union iwreq_data *wrqu, char *extra)
 {
 	int ret = 0;
-	struct rtw_adapter				*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	u8					peerMAC[ETH_ALEN] = { 0x00 };
-	int					jj, kk;
-	u8					peerMACStr[ETH_ALEN * 2] = { 0x00 };
+	u8 peerMAC[ETH_ALEN] = { 0x00 };
+	int jj, kk;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct list_head *plist, *phead;
 	struct __queue *queue = &(pmlmepriv->scanned_queue);
 	struct	wlan_network	*pnetwork = NULL;
-	uint					uintPeerChannel = 0;
-	u8					attr_content[100] = { 0x00 }, _status = 0;
+	uint uintPeerChannel = 0;
+	u8 attr_content[100] = { 0x00 };
 	u8 *p2pie;
-	uint					p2pielen = 0, attr_contentlen = 0;
+	uint p2pielen = 0, attr_contentlen = 0;
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -4037,13 +3933,10 @@ static int rtw_p2p_prov_disc(struct net_
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-	{
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
 		DBG_8192D("[%s] WiFi Direct is disable!\n", __func__);
 		return ret;
-	}
-	else
-	{
+	} else {
 		/*	Reset the content of struct tx_provdisc_req_info excluded the wps_config_method_request. */
 		memset(pwdinfo->tx_prov_disc_info.peerDevAddr, 0x00, ETH_ALEN);
 		memset(pwdinfo->tx_prov_disc_info.peerIFAddr, 0x00, ETH_ALEN);
@@ -4054,30 +3947,19 @@ static int rtw_p2p_prov_disc(struct net_
 	}
 
 	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
-	{
 		peerMAC[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
-	}
 
-	if (!memcmp(&extra[18], "display", 7))
-	{
+	if (!memcmp(&extra[18], "display", 7)) {
 		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_DISPLYA;
-	}
-	else if (!memcmp(&extra[18], "keypad", 7))
-	{
+	} else if (!memcmp(&extra[18], "keypad", 7)) {
 		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_KEYPAD;
-	}
-	else if (!memcmp(&extra[18], "pbc", 3))
-	{
+	} else if (!memcmp(&extra[18], "pbc", 3)) {
 		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_PUSH_BUTTON;
-	}
-	else if (!memcmp(&extra[18], "label", 5))
-	{
+	} else if (!memcmp(&extra[18], "label", 5)) {
 		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_LABEL;
-	}
-	else
-	{
+	} else {
 		DBG_8192D("[%s] Unknown WPS config methodn", __func__);
-		return(ret);
+		return ret;
 	}
 
 	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
@@ -4085,8 +3967,7 @@ static int rtw_p2p_prov_disc(struct net_
 	phead = get_list_head(queue);
 	plist = phead->next;
 
-	while (1)
-	{
+	while (1) {
 		if (rtw_end_of_queue_search(phead, plist) == true)
 			break;
 
@@ -4099,27 +3980,20 @@ static int rtw_p2p_prov_disc(struct net_
 		/*	Match the device address located in the P2P IE */
 		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
 
-		if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
-		{
-			while (p2pie)
-			{
+		if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen))) {
+			while (p2pie) {
 				/*	The P2P Device ID attribute is included in the Beacon frame. */
 				/*	The P2P Device Info attribute is included in the probe response frame. */
 
-				if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
-				{
+				if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen)) {
 					/*	Handle the P2P Device ID attribute of Beacon first */
-					if (!memcmp(attr_content, peerMAC, ETH_ALEN))
-					{
+					if (!memcmp(attr_content, peerMAC, ETH_ALEN)) {
 						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
 						break;
 					}
-				}
-				else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
-				{
+				} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen)) {
 					/*	Handle the P2P Device Info attribute of probe response */
-					if (!memcmp(attr_content, peerMAC, ETH_ALEN))
-					{
+					if (!memcmp(attr_content, peerMAC, ETH_ALEN)) {
 						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
 						break;
 					}
@@ -4129,21 +4003,16 @@ static int rtw_p2p_prov_disc(struct net_
 				p2pie = rtw_get_p2p_ie(p2pie+p2pielen, pnetwork->network.IELength - 12 -(p2pie -&pnetwork->network.IEs[12] + p2pielen), NULL, &p2pielen);
 			}
 		}
-
 		plist = plist->next;
-
 	}
 
 	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	if (uintPeerChannel) {
-
 		DBG_8192D("[%s] peer channel: %d!\n", __func__, uintPeerChannel);
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_buddy_fwstate(padapter, _FW_LINKED))
-		{
 			del_timer_sync(&pwdinfo->ap_p2p_switch_timer);
-		}
 #endif /*  CONFIG_CONCURRENT_MODE */
 		memcpy(pwdinfo->tx_prov_disc_info.peerIFAddr, pnetwork->network.MacAddress, ETH_ALEN);
 		memcpy(pwdinfo->tx_prov_disc_info.peerDevAddr, peerMAC, ETH_ALEN);
@@ -4152,26 +4021,20 @@ static int rtw_p2p_prov_disc(struct net_
 		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ);
 
-		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
-		{
+		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)) {
 			memcpy(&pwdinfo->tx_prov_disc_info.ssid, &pnetwork->network.Ssid, sizeof(struct ndis_802_11_ssid));
-		}
-		else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
-		{
+		} else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
 			memcpy(pwdinfo->tx_prov_disc_info.ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN);
 			pwdinfo->tx_prov_disc_info.ssid.SsidLength = P2P_WILDCARD_SSID_LEN;
 		}
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED))
-		{
+		if (check_buddy_fwstate(padapter, _FW_LINKED)) {
 			/*	Have to enter the power saving with the AP */
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 
 			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
-		}
-		else
-		{
+		} else {
 			set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 		}
 #else
@@ -4182,24 +4045,16 @@ static int rtw_p2p_prov_disc(struct net_
 
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_buddy_fwstate(padapter, _FW_LINKED))
-		{
 			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_PROVISION_TIMEOUT);
-		}
 		else
-		{
 			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
-		}
 #else
 		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
 #endif /*  CONFIG_CONCURRENT_MODE */
 
-	}
-	else
-	{
+	} else {
 		DBG_8192D("[%s] NOT Found in the Scanning Queue!\n", __func__);
 	}
-exit:
-
 	return ret;
 }
 
@@ -4256,79 +4111,47 @@ static int rtw_p2p_set(struct net_device
 	int ret = 0;
 #ifdef CONFIG_P2P
 
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct iw_point *pdata = &wrqu->data;
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-
 	DBG_8192D("[%s] extra = %s\n", __func__, extra);
 
-	if (!memcmp(extra, "enable =", 7))
-	{
+	if (!memcmp(extra, "enable =", 7)) {
 		rtw_wext_p2p_enable(dev, info, wrqu, &extra[7]);
-	}
-	else if (!memcmp(extra, "setDN =", 6))
-	{
+	} else if (!memcmp(extra, "setDN=", 6)) {
 		wrqu->data.length -= 6;
 		rtw_p2p_setDN(dev, info, wrqu, &extra[6]);
-	}
-	else if (!memcmp(extra, "profilefound =", 13))
-	{
+	} else if (!memcmp(extra, "profilefound=", 13)) {
 		wrqu->data.length -= 13;
 		rtw_p2p_profilefound(dev, info, wrqu, &extra[13]);
-	}
-	else if (!memcmp(extra, "prov_disc =", 10))
-	{
+	} else if (!memcmp(extra, "prov_disc=", 10)) {
 		wrqu->data.length -= 10;
 		rtw_p2p_prov_disc(dev, info, wrqu, &extra[10]);
-	}
-	else if (!memcmp(extra, "nego =", 5))
-	{
+	} else if (!memcmp(extra, "nego=", 5)) {
 		wrqu->data.length -= 5;
 		rtw_p2p_connect(dev, info, wrqu, &extra[5]);
-	}
-	else if (!memcmp(extra, "intent =", 7))
-	{
-		/*	Commented by Albert 2011/03/23 */
+	} else if (!memcmp(extra, "intent=", 7)) {
 		/*	The wrqu->data.length will include the null character */
 		/*	So, we will decrease 7 + 1 */
 		wrqu->data.length -= 8;
 		rtw_p2p_set_intent(dev, info, wrqu, &extra[7]);
-	}
-	else if (!memcmp(extra, "ssid =", 5))
-	{
+	} else if (!memcmp(extra, "ssid=", 5)) {
 		wrqu->data.length -= 5;
 		rtw_p2p_set_go_nego_ssid(dev, info, wrqu, &extra[5]);
-	}
-	else if (!memcmp(extra, "got_wpsinfo =", 12))
-	{
+	} else if (!memcmp(extra, "got_wpsinfo=", 12)) {
 		wrqu->data.length -= 12;
 		rtw_p2p_got_wpsinfo(dev, info, wrqu, &extra[12]);
-	}
-	else if (!memcmp(extra, "listen_ch =", 10))
-	{
-		/*	Commented by Albert 2011/05/24 */
+	} else if (!memcmp(extra, "listen_ch=", 10)) {
 		/*	The wrqu->data.length will include the null character */
 		/*	So, we will decrease (10 + 1) */
 		wrqu->data.length -= 11;
 		rtw_p2p_set_listen_ch(dev, info, wrqu, &extra[10]);
-	}
-	else if (!memcmp(extra, "op_ch =", 6))
-	{
-		/*	Commented by Albert 2011/05/24 */
+	} else if (!memcmp(extra, "op_ch=", 6)) {
 		/*	The wrqu->data.length will include the null character */
 		/*	So, we will decrease (6 + 1) */
 		wrqu->data.length -= 7;
 		rtw_p2p_set_op_ch(dev, info, wrqu, &extra[6]);
-	}
-	else if (!memcmp(extra, "invite =", 7))
-	{
+	} else if (!memcmp(extra, "invite=", 7)) {
 		wrqu->data.length -= 8;
 		rtw_p2p_invite_req(dev, info, wrqu, &extra[7]);
-	}
-	else if (!memcmp(extra, "persistent =", 11))
-	{
+	} else if (!memcmp(extra, "persistent=", 11)) {
 		wrqu->data.length -= 11;
 		rtw_p2p_set_persistent(dev, info, wrqu, &extra[11]);
 	}
@@ -4346,10 +4169,6 @@ static int rtw_p2p_get(struct net_device
 #ifdef CONFIG_P2P
 
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct iw_point *pdata = &wrqu->data;
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 
 	if (padapter->bShowGetP2PState)
 		DBG_8192D("[%s] extra = %s\n", __func__, (char *)wrqu->data.pointer);
@@ -4941,7 +4760,6 @@ static int rtw_dbg_port(struct net_devic
 static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
 {
 	uint ret = 0;
-	u32 flags;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
 	switch (name) {
@@ -5695,7 +5513,7 @@ static int rtw_del_sta(struct net_device
 
 	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
 	if (psta) {
-		u8 updated;
+		u8 updated = 0;
 
 		/* DBG_8192D("free psta =%p, aid =%d\n", psta, psta->aid); */
 
@@ -5852,7 +5670,6 @@ static int rtw_set_wps_beacon(struct net
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	int ie_len;
 
 	DBG_8192D("%s, len =%d\n", __func__, len);
@@ -6142,7 +5959,6 @@ static int rtw_wx_set_priv(struct net_de
 	int ret = 0;
 	int len = 0;
 	char *ext;
-	int i;
 
 	if (dwrq->length == 0)
 		return -EFAULT;
@@ -6173,7 +5989,6 @@ static int rtw_wx_set_priv(struct net_de
 			DBG_8192D("probe_req_wps_ielen =%d\n", cp_sz);
 
 			if (pmlmepriv->wps_probe_req_ie) {
-				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 				pmlmepriv->wps_probe_req_ie_len = 0;
 				kfree(pmlmepriv->wps_probe_req_ie);
 				pmlmepriv->wps_probe_req_ie = NULL;
@@ -6215,8 +6030,6 @@ static int rtw_mp_efuse_get(struct net_d
 {
 	struct iw_point *wrqu = (struct iw_point *)wdata;
 	struct rtw_adapter * padapter = rtw_netdev_priv(dev);
-	struct mp_priv *pmp_priv;
-
 	int i, j = 0;
 	u8 data[EFUSE_MAP_SIZE];
 	u8 rawdata[EFUSE_MAX_SIZE];
@@ -6407,15 +6220,11 @@ static int rtw_mp_efuse_set(struct net_d
 			struct iw_request_info *info,
 			union iwreq_data *wdata, char *extra)
 {
-	struct iw_point *wrqu = (struct iw_point *)wdata;
 	struct rtw_adapter *padapter = rtw_netdev_priv(dev);
-
-	u8 buffer[40];
 	u32 i, jj, kk;
 	u8 setdata[EFUSE_MAP_SIZE];
 	u8 setrawdata[EFUSE_MAX_SIZE];
-	char *pch, *ptmp, *token, *edata, *tmp[3] = {NULL, NULL, NULL};
-
+	char *pch, *ptmp, *token, *tmp[3] = {NULL, NULL, NULL};
 	u16 addr = 0, max_available_size = 0;
 	u32  cnts = 0;
 
@@ -6551,144 +6360,7 @@ static int rtw_mp_efuse_set(struct net_d
 	  return 0;
 }
 
-static int rtw_wfd_tdls_enable(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-static int rtw_tdls_weaksec(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-static int rtw_tdls_enable(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-static int rtw_tdls_setup(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-static int rtw_tdls_teardown(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-static int rtw_tdls_discovery(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-static int rtw_tdls_ch_switch (struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-static int rtw_tdls_pson(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-static int rtw_tdls_psoff(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-static int rtw_tdls_setip(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-static int rtw_tdls_getip(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-static int rtw_tdls_getport(struct net_device *dev,
-			    struct iw_request_info *info,
-			    union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
 /* WFDTDLS, for sigma test */
-static int rtw_tdls_dis_result(struct net_device *dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-
-	return ret;
-}
-
-/* WFDTDLS, for sigma test */
-static int rtw_wfd_tdls_status(struct net_device *dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-static int rtw_tdls_ch_switch_off(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-	return ret;
-}
-
 static int rtw_tdls(struct net_device *dev,
 		    struct iw_request_info *info,
 		    union iwreq_data *wrqu, char *extra)
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -382,8 +382,6 @@ static const struct net_device_ops rtw_n
 
 int rtw_init_netdev_name(struct net_device *pnetdev, const char *ifname)
 {
-	struct rtw_adapter *padapter = rtw_netdev_priv(pnetdev);
-
 	if (dev_alloc_name(pnetdev, ifname) < 0)
 		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("dev_alloc_name, fail!\n"));
 
@@ -1176,8 +1174,6 @@ void rtw_ips_pwr_down(struct rtw_adapter
 
 void rtw_ips_dev_unload(struct rtw_adapter *padapter)
 {
-	struct net_device *pnetdev = (struct net_device*)padapter->pnetdev;
-	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 	DBG_8192D("====> %s...\n", __func__);
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_FIFO_CLEARN_UP, NULL);
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -41,10 +41,7 @@ void rtw_os_recv_resource_free(struct re
 /* alloc os related resource in struct recv_buf */
 int rtw_os_recvbuf_resource_alloc(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
 {
-	int res=1;
-
-	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
-	struct usb_device	*pusbd = pdvobjpriv->pusbdev;
+	int res = 1;
 
 	precvbuf->irp_pending = false;
 	precvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);
@@ -105,9 +102,9 @@ void rtw_handle_tkip_mic_err(struct rtw_
 	}
 
 	if (bgroup)
-		key_type |= NL80211_KEYTYPE_GROUP;
+		key_type = NL80211_KEYTYPE_GROUP;
 	else
-		key_type |= NL80211_KEYTYPE_PAIRWISE;
+		key_type = NL80211_KEYTYPE_PAIRWISE;
 
 	cfg80211_michael_mic_failure(padapter->pnetdev, (u8 *)&pmlmepriv->assoc_bssid[0], key_type, -1,
 		NULL, GFP_ATOMIC);
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -133,7 +133,6 @@ static u8 rtw_deinit_intf_priv(struct dv
 static struct dvobj_priv *usb_dvobj_init(struct usb_interface *usb_intf)
 {
 	int	i;
-	u8	val8;
 	int	status = 0;
 	struct dvobj_priv *pdvobjpriv = NULL;
 	struct usb_device				*pusbd;
@@ -295,12 +294,9 @@ static void usb_intf_stop(struct rtw_ada
 
 static void rtw_dev_unload(struct rtw_adapter *padapter)
 {
-	struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;
-	u8 val8;
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_dev_unload\n"));
 
-	if (padapter->bup == true)
-	{
+	if (padapter->bup) {
 		DBG_8192D("===> rtw_dev_unload\n");
 
 		padapter->bDriverStopped = true;
@@ -373,7 +369,6 @@ static int rtw_suspend(struct usb_interf
 	struct net_device *pnetdev = padapter->pnetdev;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
-	struct usb_device *usb_dev = interface_to_usbdev(pusb_intf);
 #ifdef CONFIG_WAKE_ON_WLAN
 	struct wowlan_ioctl_param poidparam;
 #endif /*  CONFIG_WAKE_ON_WLAN */
@@ -446,7 +441,7 @@ exit:
 	return ret;
 }
 
-int rtw_resume_process(struct rtw_adapter *padapter)
+static int rtw_resume_process(struct rtw_adapter *padapter)
 {
 	struct net_device *pnetdev;
 	struct pwrctrl_priv *pwrpriv = NULL;
@@ -494,7 +489,6 @@ static int rtw_resume(struct usb_interfa
 {
 	struct dvobj_priv *dvobj = usb_get_intfdata(pusb_intf);
 	struct rtw_adapter *padapter = dvobj->if1;
-	struct net_device *pnetdev = padapter->pnetdev;
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	 int ret = 0;
 
@@ -681,11 +675,9 @@ static void rtw_usb_if1_deinit(struct rt
  *        We accept the new device by returning 0.
 */
 
-static struct rtw_adapter  *rtw_sw_export = NULL;
-
 static int rtw_drv_init(struct usb_interface *pusb_intf, const struct usb_device_id *did)
 {
-	struct rtw_adapter *if1 = NULL, *if2 = NULL;
+	struct rtw_adapter *if1 = NULL;
 	struct dvobj_priv *dvobj = NULL;
 	uint status = 0;
 
@@ -713,7 +705,6 @@ static int rtw_drv_init(struct usb_inter
 
 	status = 1;
 
-free_if1:
 	if (status != 1 && if1)
 		rtw_usb_if1_deinit(if1);
 free_dvobj:
--- a/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
@@ -47,61 +47,6 @@ struct zero_bulkout_context{
 	void *padapter;
 };
 
-static void usb_bulkout_zero_complete(struct urb *purb, struct pt_regs *regs)
-{
-	struct zero_bulkout_context *pcontext = (struct zero_bulkout_context *)purb->context;
-
-	if (pcontext) {
-		kfree(pcontext->pbuf);
-
-		if (pcontext->purb && (pcontext->purb==purb))
-			usb_free_urb(pcontext->purb);
-
-		kfree(pcontext);
-	}
-}
-
-static u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
-{
-	int pipe, status, len;
-	u32 ret;
-	unsigned char *pbuf;
-	struct zero_bulkout_context *pcontext;
-	struct urb *	purb = NULL;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)pintfhdl->padapter;
-	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
-	struct usb_device *pusbd = pdvobj->pusbdev;
-
-	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||
-	    (padapter->pwrctrlpriv.pnp_bstop_trx))
-		return 0;
-
-	pcontext = (struct zero_bulkout_context *)kzalloc(sizeof(struct zero_bulkout_context), GFP_KERNEL);
-
-	pbuf = (unsigned char *)kzalloc(sizeof(int), GFP_KERNEL);
-	purb = usb_alloc_urb(0, GFP_ATOMIC);
-
-	len = 0;
-	pcontext->pbuf = pbuf;
-	pcontext->purb = purb;
-	pcontext->pirp = NULL;
-	pcontext->padapter = padapter;
-
-	/* translate DMA FIFO addr to pipehandle */
-
-	usb_fill_bulk_urb(purb, pusbd, pipe, pbuf, len,
-			  usb_bulkout_zero_complete, pcontext);
-
-	status = usb_submit_urb(purb, GFP_ATOMIC);
-
-	if (!status)
-		ret= 1;
-	else
-		ret= 0;
-
-	return ret;
-}
-
 void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 {
 }
@@ -132,33 +77,30 @@ void usb_read_port_cancel(struct intf_hd
 
 static void usb_write_port_complete(struct urb *purb, struct pt_regs *regs)
 {
-	long unsigned int irqL;
-	int i;
 	struct xmit_buf *pxmitbuf = (struct xmit_buf *)purb->context;
 	struct rtw_adapter	*padapter = pxmitbuf->padapter;
-       struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 
-	switch (pxmitbuf->flags)
-	{
-		case VO_QUEUE_INX:
-			pxmitpriv->voq_cnt--;
-			break;
-		case VI_QUEUE_INX:
-			pxmitpriv->viq_cnt--;
-			break;
-		case BE_QUEUE_INX:
-			pxmitpriv->beq_cnt--;
-			break;
-		case BK_QUEUE_INX:
-			pxmitpriv->bkq_cnt--;
-			break;
-		case HIGH_QUEUE_INX:
+	switch (pxmitbuf->flags) {
+	case VO_QUEUE_INX:
+		pxmitpriv->voq_cnt--;
+		break;
+	case VI_QUEUE_INX:
+		pxmitpriv->viq_cnt--;
+		break;
+	case BE_QUEUE_INX:
+		pxmitpriv->beq_cnt--;
+		break;
+	case BK_QUEUE_INX:
+		pxmitpriv->bkq_cnt--;
+		break;
+	case HIGH_QUEUE_INX:
 #ifdef CONFIG_92D_AP_MODE
-			rtw_chk_hi_queue_cmd(padapter);
+		rtw_chk_hi_queue_cmd(padapter);
 #endif
-			break;
-		default:
-			break;
+		break;
+	default:
+		break;
 	}
 
 	if (padapter->bSurpriseRemoved || padapter->bDriverStopped ||padapter->bWritePortCancel)
@@ -175,34 +117,29 @@ static void usb_write_port_complete(stru
 	} else {
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete : purb->status(%d) != 0\n", purb->status));
 		DBG_8192D("###=> urb_write_port_complete status(%d)\n",purb->status);
-		if ((purb->status==-EPIPE)||(purb->status==-EPROTO))
-		{
-			sreset_set_wifi_error_status(padapter, USB_WRITE_PORT_FAIL);
+		if ((purb->status == -EPIPE) || (purb->status == -EPROTO)) {
 		} else if (purb->status == -EINPROGRESS) {
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: EINPROGESS\n"));
+			RT_TRACE(_module_hci_ops_os_c_, _drv_err_,
+				 ("usb_write_port_complete: EINPROGESS\n"));
 			goto check_completion;
-
 		} else if (purb->status == -ENOENT) {
 			DBG_8192D("%s: -ENOENT\n", __func__);
 			goto check_completion;
-
 		} else if (purb->status == -ECONNRESET) {
 			DBG_8192D("%s: -ECONNRESET\n", __func__);
 			goto check_completion;
-
 		} else if (purb->status == -ESHUTDOWN) {
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: ESHUTDOWN\n"));
+			RT_TRACE(_module_hci_ops_os_c_, _drv_err_,
+				 ("usb_write_port_complete: ESHUTDOWN\n"));
 			padapter->bDriverStopped=true;
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped=TRUE\n"));
-
+			RT_TRACE(_module_hci_ops_os_c_, _drv_err_,
+				 ("usb_write_port_complete:bDriverStopped=TRUE\n"));
 			goto check_completion;
-		}
-		else
-		{
+		} else {
 			padapter->bSurpriseRemoved=true;
 			DBG_8192D("bSurpriseRemoved=TRUE\n");
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bSurpriseRemoved=TRUE\n"));
-
+			RT_TRACE(_module_hci_ops_os_c_, _drv_err_,
+				 ("usb_write_port_complete:bSurpriseRemoved=TRUE\n"));
 			goto check_completion;
 		}
 	}
@@ -213,10 +150,7 @@ check_completion:
 
 	rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
 
-	{
-		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
-	}
-
+	tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
 }
 
 u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
@@ -224,7 +158,7 @@ u32 usb_write_port(struct intf_hdl *pint
 	long unsigned int irqL;
 	unsigned int pipe;
 	int status;
-	u32 ret = 0, bwritezero = false;
+	u32 ret = 0;
 	struct urb *purb = NULL;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)pintfhdl->padapter;
 	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);
@@ -232,7 +166,6 @@ u32 usb_write_port(struct intf_hdl *pint
 	struct xmit_buf *pxmitbuf = (struct xmit_buf *)wmem;
 	struct xmit_frame *pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
 	struct usb_device *pusbd = pdvobj->pusbdev;
-	struct pkt_attrib *pattrib = &pxmitframe->attrib;
 
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port\n"));
 
--- a/drivers/staging/rtl8192du/os_dep/xmit_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/xmit_linux.c
@@ -77,19 +77,15 @@ void rtw_set_tx_chksum_offload(struct sk
 int rtw_os_xmit_resource_alloc(struct rtw_adapter *padapter, struct xmit_buf *pxmitbuf,u32 alloc_sz)
 {
 	int i;
-	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
-	struct usb_device	*pusbd = pdvobjpriv->pusbdev;
 
 	pxmitbuf->pallocated_buf = kzalloc(alloc_sz, GFP_KERNEL);
 	if (pxmitbuf->pallocated_buf == NULL)
-	{
 		return 0;
-	}
 
 	pxmitbuf->pbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitbuf->pallocated_buf), XMITBUF_ALIGN_SZ);
 	pxmitbuf->dma_transfer_addr = 0;
 
-	for (i=0; i < 8; i++) {
+	for (i = 0; i < 8; i++) {
 		pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
 		if (pxmitbuf->pxmit_urb[i] == NULL) {
 			DBG_8192D("pxmitbuf->pxmit_urb[i]==NULL");
@@ -103,15 +99,10 @@ int rtw_os_xmit_resource_alloc(struct rt
 void rtw_os_xmit_resource_free(struct rtw_adapter *padapter, struct xmit_buf *pxmitbuf,u32 free_sz)
 {
 	int i;
-	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
-	struct usb_device	*pusbd = pdvobjpriv->pusbdev;
 
-	for (i=0; i<8; i++)
-	{
+	for (i = 0; i < 8; i++) {
 		if (pxmitbuf->pxmit_urb[i])
-		{
 			usb_free_urb(pxmitbuf->pxmit_urb[i]);
-		}
 	}
 
 	kfree(pxmitbuf->pallocated_buf);
@@ -124,10 +115,8 @@ void rtw_os_pkt_complete(struct rtw_adap
 
 	queue = skb_get_queue_mapping(pkt);
 	if (__netif_subqueue_stopped(padapter->pnetdev, queue) &&
-		(pxmitpriv->hwxmits[queue].accnt < NR_XMITFRAME/2))
-	{
+	    (pxmitpriv->hwxmits[queue].accnt < NR_XMITFRAME/2))
 		netif_wake_subqueue(padapter->pnetdev, queue);
-	}
 
 	dev_kfree_skb_any(pkt);
 }
@@ -135,12 +124,7 @@ void rtw_os_pkt_complete(struct rtw_adap
 void rtw_os_xmit_complete(struct rtw_adapter *padapter, struct xmit_frame *pxframe)
 {
 	if (pxframe->pkt)
-	{
-
 		rtw_os_pkt_complete(padapter, pxframe->pkt);
-
-	}
-
 	pxframe->pkt = NULL;
 }
 
@@ -156,9 +140,7 @@ void rtw_os_xmit_schedule(struct rtw_ada
 	spin_lock_bh(&pxmitpriv->lock);
 
 	if (rtw_txframes_pending(padapter))
-	{
 		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
-	}
 
 	spin_unlock_bh(&pxmitpriv->lock);
 }
@@ -177,8 +159,7 @@ static int rtw_mlcst2unicst(struct rtw_a
 	plist = phead->next;
 
 	/* free sta asoc_queue */
-	while ((rtw_end_of_queue_search(phead, plist)) == false)
-	{
+	while (!rtw_end_of_queue_search(phead, plist)) {
 		psta = container_of(plist, struct sta_info, asoc_list);
 
 		plist = plist->next;
@@ -193,11 +174,13 @@ static int rtw_mlcst2unicst(struct rtw_a
 			memcpy(newskb->data, psta->hwaddr, 6);
 			res = rtw_xmit(padapter, &newskb);
 			if (res < 0) {
-				DBG_8192D("%s()-%d: rtw_xmit() return error!\n", __func__, __LINE__);
+				DBG_8192D("%s()-%d: rtw_xmit() return error!\n",
+					  __func__, __LINE__);
 				pxmitpriv->tx_drop++;
 				dev_kfree_skb_any(newskb);
-			} else
+			} else {
 				pxmitpriv->tx_pkts++;
+			}
 		} else {
 			DBG_8192D("%s-%d: skb_copy() failed!\n", __func__, __LINE__);
 			pxmitpriv->tx_drop++;

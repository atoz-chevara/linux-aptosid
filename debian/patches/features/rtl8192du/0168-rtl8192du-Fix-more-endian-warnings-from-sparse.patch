From e4a9b9a8b284c3f4bef22a9da00933a4d54a403f Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Mon, 24 Jun 2013 12:13:05 -0500
Subject: [PATCH 168/210] rtl8192du: Fix more endian warnings from sparse

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_br_ext.c       |   4 +-
 core/rtw_wlan_util.c    |   2 +-
 hal/rtl8192d_cmd.c      |   6 +-
 hal/rtl8192d_hal_init.c |   4 +-
 hal/rtl8192du_xmit.c    |   6 +-
 hal/usb_halinit.c       |   6 +-
 include/basic_types.h   | 254 ++++++++++++++++++++++--------------------------
 include/hal_intf.h      |   4 +-
 include/rtl8192d_hal.h  |   4 +-
 include/rtw_mp.h        |   2 +-
 os_dep/rtw_android.c    |   2 +-
 11 files changed, 137 insertions(+), 157 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_br_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_br_ext.c
@@ -1350,7 +1350,7 @@ struct dhcp_message {
 	u_int8_t hops;
 	u_int32_t xid;
 	u_int16_t secs;
-	u_int16_t flags;
+	__be16 flags;
 	u_int32_t ciaddr;
 	u_int32_t yiaddr;
 	u_int32_t siaddr;
@@ -1391,7 +1391,7 @@ void dhcp_flag_bcast(struct rtw_adapter
 							dhcph->flags |= htons(BROADCAST_FLAG);
 							/*  recalculate checksum */
 							sum = ~(udph->check) & 0xffff;
-							sum += dhcph->flags;
+							sum += be16_to_cpu(dhcph->flags);
 							while (sum >> 16)
 								sum = (sum & 0xffff) + (sum >> 16);
 							udph->check = ~sum;
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -1252,7 +1252,7 @@ int support_short_GI(struct rtw_adapter
 
 	bit_offset = (pmlmeext->cur_bwmode & HT_CHANNEL_WIDTH_40) ? 6 : 5;
 
-	if (pHT_caps->u.HT_cap_element.HT_caps_info & (0x1 << bit_offset))
+	if (le16_to_cpu(pHT_caps->u.HT_cap_element.HT_caps_info) & (0x1 << bit_offset))
 		return _SUCCESS;
 	else
 		return _FAIL;
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -300,12 +300,12 @@ u8 rtl8192d_set_raid_cmd(struct rtw_adap
 {
 	u8	buf[5];
 	u8	res=_SUCCESS;
-
+	__le32	le_mask;
 _func_enter_;
 
 	memset(buf, 0, 5);
-	mask = cpu_to_le32(mask);
-	memcpy(buf, &mask, 4);
+	le_mask = cpu_to_le32(mask);
+	memcpy(buf, &le_mask, 4);
 	buf[4]  = arg;
 
 	FillH2CCmd92D(padapter, H2C_RA_MASK, 5, buf);
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -114,7 +114,7 @@ static int _BlockWrite_92d(struct rtw_ad
 			remainSize=remain8%blocksize4;
 
 			for (i = 0 ; i < blockCount4 ; i++) {
-				ret = rtw_write32(Adapter, (FW_8192D_START_ADDRESS + offset+i*blocksize4), cpu_to_le32(*(pu4BytePtr+ offset/4+i)));
+				ret = rtw_write32(Adapter, (FW_8192D_START_ADDRESS + offset+i*blocksize4), le32_to_cpu(*(__le32 *)(pu4BytePtr+ offset/4+i)));
 
 				if (ret == _FAIL)
 					goto exit;
@@ -412,7 +412,7 @@ int FirmwareDownload92D(
 	}
 
 	pHalData->FirmwareVersion =  le16_to_cpu(pFwHdr->Version);
-	pHalData->FirmwareSubVersion = le16_to_cpu(pFwHdr->Subversion);
+	pHalData->FirmwareSubVersion = pFwHdr->Subversion;
 
 	DBG_8192D(" FirmwareVersion(%#x), Signature(%#x)\n", pHalData->FirmwareVersion, le16_to_cpu(pFwHdr->Signature));
 
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -116,7 +116,7 @@ void rtl8192du_cal_txdesc_chksum(struct
 		ptxdesc->txdw7 &= cpu_to_le32(0xffff0000);
 
 		for (index = 0 ; index < count ; index++) {
-			checksum = checksum ^ le16_to_cpu(*(usPtr + index));
+			checksum = checksum ^ le16_to_cpu(*(__le16 *)(usPtr + index));
 		}
 
 		ptxdesc->txdw7 |= cpu_to_le32(0x0000ffff&checksum);
@@ -149,7 +149,7 @@ static void fill_txdesc_sectype(struct p
 	}
 }
 
-static void fill_txdesc_vcs(struct pkt_attrib *pattrib, u32 *pdw)
+static void fill_txdesc_vcs(struct pkt_attrib *pattrib, __le32 *pdw)
 {
 
 	switch (pattrib->vcs_mode)
@@ -185,7 +185,7 @@ static void fill_txdesc_vcs(struct pkt_a
 	}
 }
 
-static void fill_txdesc_phy(struct pkt_attrib *pattrib, u32 *pdw)
+static void fill_txdesc_phy(struct pkt_attrib *pattrib, __le32 *pdw)
 {
 
 	if (pattrib->ht_en)
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -2973,8 +2973,8 @@ _ReadIDs(
 
 	if (false == AutoloadFail) {
 		/*  VID, PID */
-		pHalData->EEPROMVID = le16_to_cpu(*(u16 *)&PROMContent[EEPROM_VID]);
-		pHalData->EEPROMPID = le16_to_cpu(*(u16 *)&PROMContent[EEPROM_PID]);
+		pHalData->EEPROMVID = le16_to_cpu(*(__le16 *)&PROMContent[EEPROM_VID]);
+		pHalData->EEPROMPID = le16_to_cpu(*(__le16 *)&PROMContent[EEPROM_PID]);
 
 		/*  Customer ID, 0x00 and 0xff are reserved for Realtek. */
 		pHalData->EEPROMCustomerID = *(u8 *)&PROMContent[EEPROM_CUSTOMER_ID];
@@ -3262,7 +3262,7 @@ static void _ReadPROMContent(
 		}
 
 		/* Double check 0x8192 autoload status again */
-		if (RTL8192_EEPROM_ID != le16_to_cpu(*((u16 *)PROMContent)))
+		if (RTL8192_EEPROM_ID != le16_to_cpu(*((__le16 *)PROMContent)))
 		{
 			pEEPROM->bautoload_fail_flag = true;
 			DBG_8192D("Autoload OK but EEPROM ID content is incorrect!!\n");
--- a/drivers/staging/rtl8192du/include/basic_types.h
+++ b/drivers/staging/rtl8192du/include/basic_types.h
@@ -46,152 +46,132 @@
  *		3. After read integer from IO.
 */
 
-/*  */
-/*  Byte Swapping routine. */
-/*  */
-#define EF1Byte
-#define EF2Byte		le16_to_cpu
-#define EF4Byte	le32_to_cpu
-
-/*  */
-/*  Read LE format data from memory */
-/*  */
-#define ReadEF1Byte(_ptr)		EF1Byte(*((u8 *)(_ptr)))
-#define ReadEF2Byte(_ptr)		EF2Byte(*((u16 *)(_ptr)))
-#define ReadEF4Byte(_ptr)		EF4Byte(*((u32 *)(_ptr)))
-
-/*  */
-/*  Write LE data to memory */
-/*  */
-#define WriteEF1Byte(_ptr, _val)	(*((u8 *)(_ptr)))=EF1Byte(_val)
-#define WriteEF2Byte(_ptr, _val)	(*((u16 *)(_ptr)))=EF2Byte(_val)
-#define WriteEF4Byte(_ptr, _val)	(*((u32 *)(_ptr)))=EF4Byte(_val)
-
-/*  */
-/* 	Example: */
-/* 		BIT_LEN_MASK_32(0) => 0x00000000 */
-/* 		BIT_LEN_MASK_32(1) => 0x00000001 */
-/* 		BIT_LEN_MASK_32(2) => 0x00000003 */
-/* 		BIT_LEN_MASK_32(32) => 0xFFFFFFFF */
-/*  */
-#define BIT_LEN_MASK_32(__BitLen) \
-	(0xFFFFFFFF >> (32 - (__BitLen)))
-/*  */
-/* 	Example: */
-/* 		BIT_OFFSET_LEN_MASK_32(0, 2) => 0x00000003 */
-/* 		BIT_OFFSET_LEN_MASK_32(16, 2) => 0x00030000 */
-/*  */
-#define BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen) \
-	(BIT_LEN_MASK_32(__BitLen) << (__BitOffset))
-
-/*  */
-/* 	Description: */
-/* 		Return 4-byte value in host byte ordering from */
-/* 		4-byte pointer in litten-endian system. */
-/*  */
-#define LE_P4BYTE_TO_HOST_4BYTE(__pStart) \
-	(EF4Byte(*((__le32 *)(__pStart))))
-
-/*  */
-/* 	Description: */
-/* 		Translate subfield (continuous bits in little-endian) of 4-byte value in litten byte to */
-/* 		4-byte value in host byte ordering. */
-/*  */
-#define LE_BITS_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
-	(\
-		(LE_P4BYTE_TO_HOST_4BYTE(__pStart) >> (__BitOffset)) \
-		& \
-		BIT_LEN_MASK_32(__BitLen) \
-	)
-
-/*  */
-/* 	Description: */
-/* 		Mask subfield (continuous bits in little-endian) of 4-byte value in litten byte oredering */
-/* 		and return the result in 4-byte value in host byte ordering. */
-/*  */
-#define LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
-	(\
-		LE_P4BYTE_TO_HOST_4BYTE(__pStart) \
-		& \
-		(~BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen)) \
-	)
-
-/*  */
-/* 	Description: */
-/* 		Set subfield of little-endian 4-byte value to specified value. */
-/*  */
-#define SET_BITS_TO_LE_4BYTE(__pStart, __BitOffset, __BitLen, __Value) \
-	*((__le32 *)(__pStart)) = \
-		EF4Byte(\
-			LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
-			| \
-			((((u32)__Value) & BIT_LEN_MASK_32(__BitLen)) << (__BitOffset)) \
-		);
-
-
-#define BIT_LEN_MASK_16(__BitLen) \
-		(0xFFFF >> (16 - (__BitLen)))
-
-#define BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen) \
-	(BIT_LEN_MASK_16(__BitLen) << (__BitOffset))
-
-#define LE_P2BYTE_TO_HOST_2BYTE(__pStart) \
-	(EF2Byte(*((u16 *)(__pStart))))
-
-#define LE_BITS_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
-	(\
-		(LE_P2BYTE_TO_HOST_2BYTE(__pStart) >> (__BitOffset)) \
-		& \
-		BIT_LEN_MASK_16(__BitLen) \
-	)
-
-#define LE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
-	(\
-		LE_P2BYTE_TO_HOST_2BYTE(__pStart) \
-		& \
-		(~BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen)) \
-	)
-
-#define SET_BITS_TO_LE_2BYTE(__pStart, __BitOffset, __BitLen, __Value) \
-	*((u16 *)(__pStart)) = \
-		EF2Byte(\
-			LE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
-			| \
-			((((u16)__Value) & BIT_LEN_MASK_16(__BitLen)) << (__BitOffset)) \
-		);
-
-#define BIT_LEN_MASK_8(__BitLen) \
-		(0xFF >> (8 - (__BitLen)))
-
-#define BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen) \
-	(BIT_LEN_MASK_8(__BitLen) << (__BitOffset))
-
-#define LE_P1BYTE_TO_HOST_1BYTE(__pStart) \
-	(EF1Byte(*((u8 *)(__pStart))))
-
-#define LE_BITS_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
-	(\
-		(LE_P1BYTE_TO_HOST_1BYTE(__pStart) >> (__BitOffset)) \
-		& \
-		BIT_LEN_MASK_8(__BitLen) \
-	)
-
-#define LE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
-	(\
-		LE_P1BYTE_TO_HOST_1BYTE(__pStart) \
-		& \
-		(~BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen)) \
-	)
-
-#define SET_BITS_TO_LE_1BYTE(__pStart, __BitOffset, __BitLen, __Value) \
-	*((u8 *)(__pStart)) = \
-		EF1Byte(\
-			LE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
-			| \
-			((((u8)__Value) & BIT_LEN_MASK_8(__BitLen)) << (__BitOffset)) \
-		);
+/* Convert little data endian to host ordering */
+#define EF1BYTE(_val)		\
+	((u8)(_val))
+#define EF2BYTE(_val)		\
+	(le16_to_cpu(_val))
+#define EF4BYTE(_val)		\
+	(le32_to_cpu(_val))
+
+/* Read data from memory */
+#define READEF1BYTE(_ptr)	\
+	EF1BYTE(*((u8 *)(_ptr)))
+/* Read le16 data from memory and convert to host ordering */
+#define READEF2BYTE(_ptr)	\
+	EF2BYTE(*(_ptr))
+#define READEF4BYTE(_ptr)	\
+	EF4BYTE(*(_ptr))
+
+/* Write data to memory */
+#define WRITEEF1BYTE(_ptr, _val)	\
+	(*((u8 *)(_ptr))) = EF1BYTE(_val)
+/* Write le data to memory in host ordering */
+#define WRITEEF2BYTE(_ptr, _val)	\
+	(*((u16 *)(_ptr))) = EF2BYTE(_val)
+#define WRITEEF4BYTE(_ptr, _val)	\
+	(*((u32 *)(_ptr))) = EF2BYTE(_val)
+
+/* Create a bit mask
+ * Examples:
+ * BIT_LEN_MASK_32(0) => 0x00000000
+ * BIT_LEN_MASK_32(1) => 0x00000001
+ * BIT_LEN_MASK_32(2) => 0x00000003
+ * BIT_LEN_MASK_32(32) => 0xFFFFFFFF
+ */
+#define BIT_LEN_MASK_32(__bitlen)	 \
+	(0xFFFFFFFF >> (32 - (__bitlen)))
+#define BIT_LEN_MASK_16(__bitlen)	 \
+	(0xFFFF >> (16 - (__bitlen)))
+#define BIT_LEN_MASK_8(__bitlen) \
+	(0xFF >> (8 - (__bitlen)))
+
+/* Create an offset bit mask
+ * Examples:
+ * BIT_OFFSET_LEN_MASK_32(0, 2) => 0x00000003
+ * BIT_OFFSET_LEN_MASK_32(16, 2) => 0x00030000
+ */
+#define BIT_OFFSET_LEN_MASK_32(__bitoffset, __bitlen) \
+	(BIT_LEN_MASK_32(__bitlen) << (__bitoffset))
+#define BIT_OFFSET_LEN_MASK_16(__bitoffset, __bitlen) \
+	(BIT_LEN_MASK_16(__bitlen) << (__bitoffset))
+#define BIT_OFFSET_LEN_MASK_8(__bitoffset, __bitlen) \
+	(BIT_LEN_MASK_8(__bitlen) << (__bitoffset))
+
+/*Description:
+ * Return 4-byte value in host byte ordering from
+ * 4-byte pointer in little-endian system.
+ */
+#define LE_P4BYTE_TO_HOST_4BYTE(__pstart) \
+	(EF4BYTE(*((__le32 *)(__pstart))))
+#define LE_P2BYTE_TO_HOST_2BYTE(__pstart) \
+	(EF2BYTE(*((__le16 *)(__pstart))))
+#define LE_P1BYTE_TO_HOST_1BYTE(__pstart) \
+	(EF1BYTE(*((u8 *)(__pstart))))
+
+/*Description:
+Translate subfield (continuous bits in little-endian) of 4-byte
+value to host byte ordering.*/
+#define LE_BITS_TO_4BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		(LE_P4BYTE_TO_HOST_4BYTE(__pstart) >> (__bitoffset))  & \
+		BIT_LEN_MASK_32(__bitlen) \
+	)
+#define LE_BITS_TO_2BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		(LE_P2BYTE_TO_HOST_2BYTE(__pstart) >> (__bitoffset)) & \
+		BIT_LEN_MASK_16(__bitlen) \
+	)
+#define LE_BITS_TO_1BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		(LE_P1BYTE_TO_HOST_1BYTE(__pstart) >> (__bitoffset)) & \
+		BIT_LEN_MASK_8(__bitlen) \
+	)
+
+/* Description:
+ * Mask subfield (continuous bits in little-endian) of 4-byte value
+ * and return the result in 4-byte value in host byte ordering.
+ */
+#define LE_BITS_CLEARED_TO_4BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		LE_P4BYTE_TO_HOST_4BYTE(__pstart)  & \
+		(~BIT_OFFSET_LEN_MASK_32(__bitoffset, __bitlen)) \
+	)
+#define LE_BITS_CLEARED_TO_2BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		LE_P2BYTE_TO_HOST_2BYTE(__pstart) & \
+		(~BIT_OFFSET_LEN_MASK_16(__bitoffset, __bitlen)) \
+	)
+#define LE_BITS_CLEARED_TO_1BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		LE_P1BYTE_TO_HOST_1BYTE(__pstart) & \
+		(~BIT_OFFSET_LEN_MASK_8(__bitoffset, __bitlen)) \
+	)
+
+/* Description:
+ * Set subfield of little-endian 4-byte value to specified value.
+ */
+#define SET_BITS_TO_LE_4BYTE(__pstart, __bitoffset, __bitlen, __val) \
+	*((u32 *)(__pstart)) = \
+	( \
+		LE_BITS_CLEARED_TO_4BYTE(__pstart, __bitoffset, __bitlen) | \
+		((((u32)__val) & BIT_LEN_MASK_32(__bitlen)) << (__bitoffset)) \
+	);
+#define SET_BITS_TO_LE_2BYTE(__pstart, __bitoffset, __bitlen, __val) \
+	*((u16 *)(__pstart)) = \
+	( \
+		LE_BITS_CLEARED_TO_2BYTE(__pstart, __bitoffset, __bitlen) | \
+		((((u16)__val) & BIT_LEN_MASK_16(__bitlen)) << (__bitoffset)) \
+	);
+#define SET_BITS_TO_LE_1BYTE(__pstart, __bitoffset, __bitlen, __val) \
+	*((u8 *)(__pstart)) = EF1BYTE \
+	( \
+		LE_BITS_CLEARED_TO_1BYTE(__pstart, __bitoffset, __bitlen) | \
+		((((u8)__val) & BIT_LEN_MASK_8(__bitlen)) << (__bitoffset)) \
+	);
 
 /*  Get the N-bytes aligment offset from the current length */
-#define N_BYTE_ALIGMENT(__Value, __Aligment) ((__Aligment == 1) ? (__Value) : (((__Value + __Aligment - 1) / __Aligment) * __Aligment))
+#define	N_BYTE_ALIGMENT(__value, __aligment) ((__aligment == 1) ? \
+	(__value) : (((__value + __aligment - 1) / __aligment) * __aligment))
 
 #endif /* __BASIC_TYPES_H__ */
--- a/drivers/staging/rtl8192du/include/hal_intf.h
+++ b/drivers/staging/rtl8192du/include/hal_intf.h
@@ -194,8 +194,8 @@ struct hal_ops {
 
 	u32	(*read_bbreg)(struct rtw_adapter * Adapter, u32 RegAddr, u32 BitMask);
 	void	(*write_bbreg)(struct rtw_adapter * Adapter, u32 RegAddr, u32 BitMask, u32 Data);
-	u32	(*read_rfreg)(struct rtw_adapter * Adapter, u32 eRFPath, u32 RegAddr, u32 BitMask);
-	void	(*write_rfreg)(struct rtw_adapter * Adapter, u32 eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
+	u32	(*read_rfreg)(struct rtw_adapter * Adapter, enum RF_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask);
+	void	(*write_rfreg)(struct rtw_adapter * Adapter, enum RF_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
 
 #ifdef CONFIG_HOSTAPD_MLME
 	s32	(*hostap_mgnt_xmit_entry)(struct rtw_adapter * Adapter, struct sk_buff *pkt);
--- a/drivers/staging/rtl8192du/include/rtl8192d_hal.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_hal.h
@@ -283,10 +283,10 @@ struct RT_FIRMWARE_92D {
 struct rt_8192d_firmware_hdr { /* 8-byte alinment required */
 
 	/*  LONG WORD 0 ---- */
-	u16		Signature;	/*  92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
+	__le16		Signature;	/*  92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
 	u8		Category;	/*  AP/NIC and USB/PCI */
 	u8		Function;	/*  Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
-	u16		Version;		/*  FW Version */
+	__le16		Version;		/*  FW Version */
 	u8		Subversion;	/*  FW Subversion, default 0x00 */
 	u8		Rsvd1;
 
--- a/drivers/staging/rtl8192du/include/rtw_mp.h
+++ b/drivers/staging/rtl8192du/include/rtw_mp.h
@@ -398,7 +398,7 @@ extern void mp_stop_test(struct rtw_adap
 
 
 
-extern u32 _read_rfreg(struct rtw_adapter * padapter, u8 rfpath, u32 addr, u32 bitmask);
+extern u32 _read_rfreg(struct rtw_adapter * padapter, enum RF_RADIO_PATH_E rfpath, u32 addr, u32 bitmask);
 extern void _write_rfreg(struct rtw_adapter * padapter, u8 rfpath, u32 addr, u32 bitmask, u32 val);
 
 extern u32 read_macreg(struct rtw_adapter *padapter, u32 addr, u32 sz);
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -96,7 +96,7 @@ struct cmd_tlv {
 #endif /* PNO_SUPPORT */
 
 struct android_wifi_priv_cmd {
-	char *buf;
+	const char __user *buf;
 	int used_len;
 	int total_len;
 };

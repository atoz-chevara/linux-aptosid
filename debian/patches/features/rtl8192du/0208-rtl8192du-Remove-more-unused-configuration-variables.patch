From 147fd2aca4b88a028362ea7df75aa6fe8f82a2ac Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Wed, 19 Feb 2014 14:07:09 -0600
Subject: [PATCH 208/210] rtl8192du: Remove more unused configuration variables

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 hal/usb_ops_linux.c     |  19 -------
 include/autoconf.h      |   3 -
 include/drv_conf.h      |  10 ----
 include/drv_types.h     |  10 ----
 include/usb_ops_linux.h |  11 ----
 os_dep/usb_intf.c       |  13 +----
 os_dep/usb_ops_linux.c  | 147 ++----------------------------------------------
 7 files changed, 5 insertions(+), 208 deletions(-)

--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -68,21 +68,7 @@ static int usbctrl_vendorreq(struct intf
 	#endif
 
 	/*  Acquire IO memory for vendorreq */
-#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
 	pIo_buf = pdvobjpriv->usb_vendor_req_buf;
-#else
-	#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_DYNAMIC_ALLOCATE
-	tmp_buf = kmalloc((u32) len + ALIGNMENT_UNIT, GFP_KERNEL);
-	tmp_buflen =  (u32)len + ALIGNMENT_UNIT;
-	#else /*  use stack memory */
-	tmp_buflen = MAX_USB_IO_CTL_SIZE;
-	#endif
-
-	/*  Added by Albert 2010/02/09 */
-	/*  For mstar platform, mstar suggests the address for USB IO should be 16 bytes alignment. */
-	/*  Trying to fix it here. */
-	pIo_buf = (tmp_buf==NULL)?NULL:tmp_buf + ALIGNMENT_UNIT -((SIZE_PTR)(tmp_buf) & 0x0f);
-#endif
 
 	if (pIo_buf== NULL) {
 		DBG_8192D("[%s] pIo_buf == NULL\n", __func__);
@@ -884,11 +870,6 @@ void rtl8192du_set_intf_ops(struct _io_o
 	pops->_write32 = &usb_write32;
 	pops->_writeN = &usb_writeN;
 
-#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
-	pops->_write8_async= &usb_async_write8;
-	pops->_write16_async = &usb_async_write16;
-	pops->_write32_async = &usb_async_write32;
-#endif
 	pops->_write_mem = &usb_write_mem;
 	pops->_write_port = &usb_write_port;
 
--- a/drivers/staging/rtl8192du/include/autoconf.h
+++ b/drivers/staging/rtl8192du/include/autoconf.h
@@ -98,9 +98,6 @@
  * USB VENDOR REQ BUFFER ALLOCATION METHOD
  * if not set we'll use function local variable (stack memory)
  */
-#define CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
-
-#define CONFIG_USB_VENDOR_REQ_MUTEX
 
 /* HAL  Related Config */
 
--- a/drivers/staging/rtl8192du/include/drv_conf.h
+++ b/drivers/staging/rtl8192du/include/drv_conf.h
@@ -45,14 +45,4 @@
 	#endif
 #endif
 
-/* About USB VENDOR REQ */
-#if defined(CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC) && !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
-	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC automatically"
-	#define CONFIG_USB_VENDOR_REQ_MUTEX
-#endif
-#if defined(CONFIG_VENDOR_REQ_RETRY) &&  !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
-	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_VENDOR_REQ_RETRY automatically"
-	#define CONFIG_USB_VENDOR_REQ_MUTEX
-#endif
-
 #endif /*  __DRV_CONF_H__ */
--- a/drivers/staging/rtl8192du/include/drv_types.h
+++ b/drivers/staging/rtl8192du/include/drv_types.h
@@ -243,23 +243,13 @@ struct dvobj_priv {
 	u8	RtNumInPipes;
 	u8	RtNumOutPipes;
 	int	ep_num[5]; /* endpoint number */
-
 	int	RegUsbSS;
-
 	struct  semaphore usb_suspend_sema;
-
-#ifdef CONFIG_USB_VENDOR_REQ_MUTEX
 	_mutex  usb_vendor_req_mutex;
-#endif
-
-#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
 	u8 *usb_alloc_vendor_req_buf;
 	u8 *usb_vendor_req_buf;
-#endif
-
 	struct usb_interface *pusbintf;
 	struct usb_device *pusbdev;
-
 	ATOMIC_T continual_urb_error;
 };
 
--- a/drivers/staging/rtl8192du/include/usb_ops_linux.h
+++ b/drivers/staging/rtl8192du/include/usb_ops_linux.h
@@ -21,12 +21,7 @@
 #define RTW_USB_CONTROL_MSG_TIMEOUT_TEST	10/* ms */
 #define RTW_USB_CONTROL_MSG_TIMEOUT	500/* ms */
 
-#if defined(CONFIG_VENDOR_REQ_RETRY) && defined(CONFIG_USB_VENDOR_REQ_MUTEX)
-/* vendor req retry should be in the situation when each vendor req is atomically submitted from others */
-#define MAX_USBCTRL_VENDORREQ_TIMES	10
-#else
 #define MAX_USBCTRL_VENDORREQ_TIMES	1
-#endif
 
 #define RTW_USB_BULKOUT_TIMEOUT	5000/* ms */
 
@@ -39,12 +34,6 @@
 #define usb_read_interrupt_complete(purb, regs)	usb_read_interrupt_complete(purb)
 #endif
 
-#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
-int usb_async_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val);
-int usb_async_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val);
-int usb_async_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val);
-#endif /* CONFIG_USB_SUPPORT_ASYNC_VDN_REQ */
-
 unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr);
 
 void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -247,11 +247,8 @@ static u8 rtw_init_intf_priv(struct dvob
 {
 	u8 rst = _SUCCESS;
 
-	#ifdef CONFIG_USB_VENDOR_REQ_MUTEX
 	_rtw_mutex_init(&dvobj->usb_vendor_req_mutex);
-	#endif
 
-	#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
 	dvobj->usb_alloc_vendor_req_buf = kzalloc(MAX_USB_IO_CTL_SIZE, GFP_KERNEL);
 	if (dvobj->usb_alloc_vendor_req_buf == NULL) {
 		DBG_8192D("alloc usb_vendor_req_buf failed... /n");
@@ -261,8 +258,6 @@ static u8 rtw_init_intf_priv(struct dvob
 	dvobj->usb_vendor_req_buf  =
 		(u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(dvobj->usb_alloc_vendor_req_buf), ALIGNMENT_UNIT);
 exit:
-	#endif
-
 	return rst;
 }
 
@@ -270,14 +265,8 @@ static u8 rtw_deinit_intf_priv(struct dv
 {
 	u8 rst = _SUCCESS;
 
-	#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
-		kfree(dvobj->usb_alloc_vendor_req_buf);
-	#endif
-
-	#ifdef CONFIG_USB_VENDOR_REQ_MUTEX
+	kfree(dvobj->usb_alloc_vendor_req_buf);
 	_rtw_mutex_free(&dvobj->usb_vendor_req_mutex);
-	#endif
-
 	return rst;
 }
 
--- a/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
@@ -18,137 +18,6 @@
 #include <usb_ops_linux.h>
 #include <rtw_sreset.h>
 
-#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
-static void _usbctrl_vendorreq_async_callback(struct urb *urb, struct pt_regs *regs)
-{
-	if (urb) {
-		if (urb->context) {
-			kfree(urb->context);
-		}
-		usb_free_urb(urb);
-	}
-}
-
-static int _usbctrl_vendorreq_async_write(struct usb_device *udev, u8 request,
-	u16 value, u16 index, void *pdata, u16 len, u8 requesttype)
-{
-	int rc;
-	unsigned int pipe;
-	u8 reqtype;
-	struct usb_ctrlrequest *dr;
-	struct urb *urb;
-	struct rtl819x_async_write_data {
-		u8 data[VENDOR_CMD_MAX_DATA_LEN];
-		struct usb_ctrlrequest dr;
-	} *buf;
-
-	if (requesttype == VENDOR_READ) {
-		pipe = usb_rcvctrlpipe(udev, 0);/* read_in */
-		reqtype =  REALTEK_USB_VENQT_READ;
-	}
-	else {
-		pipe = usb_sndctrlpipe(udev, 0);/* write_out */
-		reqtype =  REALTEK_USB_VENQT_WRITE;
-	}
-
-	buf = (struct rtl819x_async_write_data *)kzalloc(sizeof(*buf), GFP_KERNEL);
-	if (!buf) {
-		rc = -ENOMEM;
-		goto exit;
-	}
-
-	urb = usb_alloc_urb(0, GFP_ATOMIC);
-	if (!urb) {
-		kfree(buf);
-		rc = -ENOMEM;
-		goto exit;
-	}
-
-	dr = &buf->dr;
-
-	dr->bRequestType = reqtype;
-	dr->bRequest = request;
-	dr->wValue = cpu_to_le16(value);
-	dr->wIndex = cpu_to_le16(index);
-	dr->wLength = cpu_to_le16(len);
-
-	memcpy(buf, pdata, len);
-
-	usb_fill_control_urb(urb, udev, pipe, (unsigned char *)dr, buf, len,
-		_usbctrl_vendorreq_async_callback, buf);
-
-	rc = usb_submit_urb(urb, GFP_ATOMIC);
-	if (rc < 0) {
-		kfree(buf);
-		usb_free_urb(urb);
-	}
-
-exit:
-	return rc;
-}
-
-int usb_write_async(struct usb_device *udev, u32 addr, u32 val, u16 len)
-{
-	u8 request;
-	u8 requesttype;
-	u16 wvalue;
-	u16 index;
-	__le32 data;
-
-	int ret;
-
-	requesttype = VENDOR_WRITE;/* write_out */
-	request = REALTEK_USB_VENQT_CMD_REQ;
-	index = REALTEK_USB_VENQT_CMD_IDX;/* n/a */
-
-	wvalue = (u16)(addr&0x0000ffff);
-	data = cpu_to_le32(val);
-
-	ret = _usbctrl_vendorreq_async_write(udev, request, wvalue, index, &data, len, requesttype);
-
-	return ret;
-}
-
-int usb_async_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
-{
-	u8 data;
-	int ret;
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-	struct usb_device *udev=pdvobjpriv->pusbdev;
-
-	data = val;
-	ret = usb_write_async(udev, addr, &data, 1);
-
-	return ret;
-}
-
-int usb_async_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val)
-{
-	u16 data;
-	int ret;
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-	struct usb_device *udev=pdvobjpriv->pusbdev;
-
-	data = val;
-	ret = usb_write_async(udev, addr, data, 2);
-
-	return ret;
-}
-
-int usb_async_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
-{
-	u32 data;
-	int ret;
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-	struct usb_device *udev=pdvobjpriv->pusbdev;
-
-	data = val;
-	ret = usb_write_async(udev, addr, data, 4);
-
-	return ret;
-}
-#endif /* CONFIG_USB_SUPPORT_ASYNC_VDN_REQ */
-
 unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr)
 {
 	unsigned int pipe=0;
@@ -203,10 +72,9 @@ static u32 usb_bulkout_zero(struct intf_
 	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
 	struct usb_device *pusbd = pdvobj->pusbdev;
 
-	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
-	{
+	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||
+	    (padapter->pwrctrlpriv.pnp_bstop_trx))
 		return _FAIL;
-	}
 
 	pcontext = (struct zero_bulkout_context *)kzalloc(sizeof(struct zero_bulkout_context), GFP_KERNEL);
 
@@ -221,22 +89,15 @@ static u32 usb_bulkout_zero(struct intf_
 
 	/* translate DMA FIFO addr to pipehandle */
 
-	usb_fill_bulk_urb(purb, pusbd, pipe,
-				pbuf,
-				len,
-				usb_bulkout_zero_complete,
-				pcontext);/* context is pcontext */
+	usb_fill_bulk_urb(purb, pusbd, pipe, pbuf, len,
+			  usb_bulkout_zero_complete, pcontext);
 
 	status = usb_submit_urb(purb, GFP_ATOMIC);
 
 	if (!status)
-	{
 		ret= _SUCCESS;
-	}
 	else
-	{
 		ret= _FAIL;
-	}
 
 	return ret;
 }

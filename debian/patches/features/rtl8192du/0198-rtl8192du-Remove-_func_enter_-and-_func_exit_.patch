From ee28bfdebf2dc1f20ec23278f52b4cd22e957f0b Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Mon, 17 Feb 2014 14:49:41 -0600
Subject: [PATCH 198/210] rtl8192du: Remove _func_enter_ and _func_exit_

If function tracing is ever needed, the kernel provides the necessary facility.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_cmd.c          | 240 +++++++-----------------------------------------
 core/rtw_debug.c        |   2 +-
 core/rtw_ieee80211.c    |  26 +++---
 core/rtw_io.c           |  56 +++++------
 core/rtw_ioctl_set.c    |  48 +++++-----
 core/rtw_mlme.c         | 196 ++++++++-------------------------------
 core/rtw_mlme_ext.c     |  16 ++--
 core/rtw_p2p.c          |  48 +++++-----
 core/rtw_pwrctrl.c      |  64 ++++++-------
 core/rtw_recv.c         |  82 ++++++++---------
 core/rtw_security.c     | 146 +++++++++++++++--------------
 core/rtw_sta_mgt.c      |  59 ++----------
 core/rtw_xmit.c         | 102 ++------------------
 hal/hal_intf.c          |   4 +-
 hal/rtl8192d_cmd.c      |  58 ++++++------
 hal/rtl8192d_dm.c       |  46 +++++-----
 hal/rtl8192d_hal_init.c |  24 ++---
 hal/rtl8192d_phycfg.c   | 108 +++++++++++-----------
 hal/rtl8192du_led.c     |  62 ++++++-------
 hal/rtl8192du_xmit.c    |   4 +-
 hal/usb_halinit.c       |  94 +++++++++----------
 hal/usb_ops_linux.c     | 144 +++++++++--------------------
 include/rtw_debug.h     |  20 ----
 os_dep/ioctl_cfg80211.c |  62 ++++++-------
 os_dep/ioctl_linux.c    |  78 ++++++++--------
 os_dep/mlme_linux.c     |  14 +--
 os_dep/os_intfs.c       |   8 +-
 os_dep/recv_linux.c     |   6 +-
 os_dep/rtw_android.c    |  24 ++---
 os_dep/usb_intf.c       |  28 +++---
 os_dep/usb_ops_linux.c  |  24 ++---
 os_dep/xmit_linux.c     |  18 ++--
 32 files changed, 704 insertions(+), 1207 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -35,12 +35,9 @@ int _rtw_init_cmd_priv(struct cmd_priv *
 {
 	int res = _SUCCESS;
 
-_func_enter_;
-
 	_rtw_init_sema(&(pcmdpriv->cmd_queue_sema), 0);
 	_rtw_init_sema(&(pcmdpriv->terminate_cmdthread_sema), 0);
 
-
 	_rtw_init_queue(&(pcmdpriv->cmd_queue));
 
 	pcmdpriv->cmd_seq = 1;
@@ -69,8 +66,6 @@ _func_enter_;
 	pcmdpriv->rsp_cnt = 0;
 
 exit:
-
-_func_exit_;
 	return res;
 }
 
@@ -81,8 +76,6 @@ int _rtw_init_evt_priv(struct evt_priv *
 {
 	int res = _SUCCESS;
 
-_func_enter_;
-
 #ifdef CONFIG_H2CLBK
 	_rtw_init_sema(&(pevtpriv->lbkevt_done), 0);
 	pevtpriv->lbkevt_limit = 0;
@@ -117,15 +110,11 @@ exit:
 	pevtpriv->c2h_wk_alive = false;
 	pevtpriv->c2h_queue = rtw_cbuf_alloc(C2H_QUEUE_MAX_LEN+1);
 #endif
-
-_func_exit_;
-
 	return res;
 }
 
 void _rtw_free_evt_priv(struct evt_priv *pevtpriv)
 {
-_func_enter_;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("+_rtw_free_evt_priv\n"));
 
@@ -150,12 +139,10 @@ _func_enter_;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("-_rtw_free_evt_priv\n"));
 
-_func_exit_;
 }
 
 void _rtw_free_cmd_priv(struct cmd_priv *pcmdpriv)
 {
-_func_enter_;
 
 	if (pcmdpriv) {
 		_rtw_spinlock_free(&(pcmdpriv->cmd_queue.lock));
@@ -164,7 +151,7 @@ _func_enter_;
 		kfree(pcmdpriv->cmd_allocated_buf);
 		kfree(pcmdpriv->rsp_allocated_buf);
 	}
-_func_exit_;
+
 }
 
 /*
@@ -181,8 +168,6 @@ int	_rtw_enqueue_cmd(struct __queue *que
 {
 	long unsigned int flags;
 
-_func_enter_;
-
 	if (obj == NULL)
 		goto exit;
 
@@ -193,9 +178,6 @@ _func_enter_;
 	spin_unlock_irqrestore(&queue->lock, flags);
 
 exit:
-
-_func_exit_;
-
 	return _SUCCESS;
 }
 
@@ -204,8 +186,6 @@ struct cmd_obj *_rtw_dequeue_cmd(struct
 	long unsigned int flags;
 	struct cmd_obj *obj;
 
-_func_enter_;
-
 	spin_lock_irqsave(&queue->lock, flags);
 	if (rtw_is_list_empty(&(queue->queue))) {
 		obj = NULL;
@@ -216,43 +196,41 @@ _func_enter_;
 
 	spin_unlock_irqrestore(&queue->lock, flags);
 
-_func_exit_;
-
 	return obj;
 }
 
 u32	rtw_init_cmd_priv(struct cmd_priv *pcmdpriv)
 {
 	u32	res;
-_func_enter_;
+
 	res = _rtw_init_cmd_priv(pcmdpriv);
-_func_exit_;
+
 	return res;
 }
 
 u32	rtw_init_evt_priv(struct evt_priv *pevtpriv)
 {
 	int	res;
-_func_enter_;
+
 	res = _rtw_init_evt_priv(pevtpriv);
-_func_exit_;
+
 	return res;
 }
 
 void rtw_free_evt_priv(struct evt_priv *pevtpriv)
 {
-_func_enter_;
+
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("rtw_free_evt_priv\n"));
 	_rtw_free_evt_priv(pevtpriv);
-_func_exit_;
+
 }
 
 void rtw_free_cmd_priv(struct cmd_priv *pcmdpriv)
 {
-_func_enter_;
+
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("rtw_free_cmd_priv\n"));
 	_rtw_free_cmd_priv(pcmdpriv);
-_func_exit_;
+
 }
 
 static int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
@@ -285,8 +263,6 @@ u32 rtw_enqueue_cmd(struct cmd_priv *pcm
 	int res = _FAIL;
 	struct rtw_adapter *padapter = pcmdpriv->padapter;
 
-_func_enter_;
-
 	if (cmd_obj == NULL) {
 		goto exit;
 	}
@@ -311,9 +287,6 @@ _func_enter_;
 		_rtw_up_sema(&pcmdpriv->cmd_queue_sema);
 
 exit:
-
-_func_exit_;
-
 	return res;
 }
 
@@ -321,24 +294,20 @@ struct cmd_obj *rtw_dequeue_cmd(struct c
 {
 	struct cmd_obj *cmd_obj;
 
-_func_enter_;
-
 	cmd_obj = _rtw_dequeue_cmd(&pcmdpriv->cmd_queue);
 
-_func_exit_;
 	return cmd_obj;
 }
 
 void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv)
 {
-_func_enter_;
+
 	pcmdpriv->cmd_done_cnt++;
-_func_exit_;
+
 }
 
 void rtw_free_cmd_obj(struct cmd_obj *pcmd)
 {
-_func_enter_;
 
 	if ((pcmd->cmdcode != _JOINBSS_CMD_) &&
 	    (pcmd->cmdcode != _CREATEBSS_CMD_)) {
@@ -356,7 +325,6 @@ _func_enter_;
 	/* free cmd_obj */
 	kfree(pcmd);
 
-_func_exit_;
 }
 
 int rtw_cmd_thread(void *context)
@@ -369,8 +337,6 @@ int rtw_cmd_thread(void *context)
 	struct rtw_adapter *padapter = (struct rtw_adapter *)context;
 	struct cmd_priv *pcmdpriv = &(padapter->cmdpriv);
 
-_func_enter_;
-
 	thread_enter("RTW_CMD_THREAD");
 
 	pcmdbuf = pcmdpriv->cmd_buf;
@@ -459,21 +425,17 @@ post_process:
 	}
 	pcmdpriv->cmdthd_running = false;
 
-
 	/*  free all cmd_obj resources */
 	do {
 		pcmd = rtw_dequeue_cmd(pcmdpriv);
 		if (pcmd == NULL)
 			break;
 
-
 		rtw_free_cmd_obj(pcmd);
 	} while (1);
 
 	_rtw_up_sema(&pcmdpriv->terminate_cmdthread_sema);
 
-_func_exit_;
-
 	thread_exit();
 }
 
@@ -483,8 +445,6 @@ u32 rtw_enqueue_evt(struct evt_priv *pev
 	int	res;
 	struct __queue *queue = &pevtpriv->evt_queue;
 
-_func_enter_;
-
 	res = _SUCCESS;
 
 	if (obj == NULL) {
@@ -499,9 +459,6 @@ _func_enter_;
 	spin_unlock_bh(&queue->lock);
 
 exit:
-
-_func_exit_;
-
 	return res;
 }
 
@@ -509,8 +466,6 @@ struct evt_obj *rtw_dequeue_evt(_queue *
 {
 	struct evt_obj *pevtobj;
 
-_func_enter_;
-
 	spin_lock_bh(&queue->lock);
 
 	if (rtw_is_list_empty(&(queue->queue))) {
@@ -522,25 +477,23 @@ _func_enter_;
 
 	spin_unlock_bh(&queue->lock);
 
-_func_exit_;
-
 	return pevtobj;
 }
 
 void rtw_free_evt_obj(struct evt_obj *pevtobj)
 {
-_func_enter_;
+
 	kfree(pevtobj->parmbuf);
 	kfree(pevtobj);
-_func_exit_;
+
 }
 
 void rtw_evt_notify_isr(struct evt_priv *pevtpriv)
 {
-_func_enter_;
+
 	pevtpriv->evt_done_cnt++;
 	_rtw_up_sema(&(pevtpriv->evt_notify));
-_func_exit_;
+
 }
 #endif
 
@@ -552,8 +505,6 @@ u8 rtw_setstandby_cmd(struct rtw_adapter
 
 	u8 ret = _SUCCESS;
 
-_func_enter_;
-
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		ret = _FAIL;
@@ -574,9 +525,6 @@ _func_enter_;
 	ret = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
 exit:
-
-_func_exit_;
-
 	return ret;
 }
 
@@ -594,8 +542,6 @@ u8 rtw_sitesurvey_cmd(struct rtw_adapter
 	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 
-_func_enter_;
-
 #ifdef CONFIG_LPS
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
 		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SCAN, 1);
@@ -670,8 +616,6 @@ _func_enter_;
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 	}
 
-_func_exit_;
-
 	return res;
 }
 
@@ -682,8 +626,6 @@ u8 rtw_setdatarate_cmd(struct rtw_adapte
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		res = _FAIL;
@@ -706,9 +648,6 @@ _func_enter_;
 #endif
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
-
-_func_exit_;
-
 	return res;
 }
 
@@ -719,8 +658,6 @@ u8 rtw_setbasicrate_cmd(struct rtw_adapt
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		res = _FAIL;
@@ -740,13 +677,9 @@ _func_enter_;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
-
-_func_exit_;
-
 	return res;
 }
 
-
 /*
 unsigned char rtw_setphy_cmd(unsigned char  *adapter)
 
@@ -761,8 +694,6 @@ u8 rtw_setphy_cmd(struct rtw_adapter *pa
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		res = _FAIL;
@@ -785,7 +716,7 @@ _func_enter_;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
-_func_exit_;
+
 	return res;
 }
 
@@ -795,7 +726,7 @@ u8 rtw_setbbreg_cmd(struct rtw_adapter *
 	struct writeBB_parm *pwritebbparm;
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
-_func_enter_;
+
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		res = _FAIL;
@@ -816,7 +747,7 @@ _func_enter_;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
-_func_exit_;
+
 	return res;
 }
 
@@ -827,7 +758,6 @@ u8 rtw_getbbreg_cmd(struct rtw_adapter *
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-_func_enter_;
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		res = _FAIL;
@@ -851,7 +781,7 @@ _func_enter_;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
-_func_exit_;
+
 	return res;
 }
 
@@ -861,7 +791,7 @@ u8 rtw_setrfreg_cmd(struct rtw_adapter *
 	struct writeRF_parm *pwriterfparm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
-_func_enter_;
+
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		res = _FAIL;
@@ -882,7 +812,7 @@ _func_enter_;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
-_func_exit_;
+
 	return res;
 }
 
@@ -893,8 +823,6 @@ u8 rtw_getrfreg_cmd(struct rtw_adapter *
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		res = _FAIL;
@@ -921,29 +849,25 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
 void rtw_getbbrfreg_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
 {
- _func_enter_;
+
 
 	kfree(pcmd->parmbuf);
 	kfree(pcmd);
 
-_func_exit_;
 }
 
 void rtw_readtssi_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
 {
- _func_enter_;
+
 
 	kfree(pcmd->parmbuf);
 	kfree(pcmd);
 
-_func_exit_;
 }
 
 u8 rtw_createbss_cmd(struct rtw_adapter *padapter)
@@ -954,8 +878,6 @@ u8 rtw_createbss_cmd(struct rtw_adapter
 	struct wlan_bssid_ex *pdev_network = &padapter->registrypriv.dev_network;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	rtw_led_control(padapter, LED_CTL_START_TO_LINK);
 
 	if (pmlmepriv->assoc_ssid.SsidLength == 0) {
@@ -981,7 +903,7 @@ _func_enter_;
 
 	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
 exit:
-_func_exit_;
+
 	return res;
 }
 
@@ -991,8 +913,6 @@ u8 rtw_createbss_cmd_ex(struct rtw_adapt
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (pcmd == NULL) {
 		res = _FAIL;
@@ -1010,8 +930,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1031,8 +949,6 @@ u8 rtw_joinbss_cmd(struct rtw_adapter *p
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-_func_enter_;
-
 	rtw_led_control(padapter, LED_CTL_START_TO_LINK);
 
 	if (pmlmepriv->assoc_ssid.SsidLength == 0) {
@@ -1050,7 +966,6 @@ _func_enter_;
 	/* for IEs is fix buf size */
 	t_len = sizeof(struct wlan_bssid_ex);
 
-
 	/* for hidden ap to set fw_state here */
 	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) != true) {
 		switch (ndis_network_mode) {
@@ -1098,7 +1013,6 @@ _func_enter_;
 
 	psecnetwork->IELength = rtw_restruct_sec_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength);
 
-
 	pqospriv->qos_option = 0;
 
 	if (pregistrypriv->wmm_enable) {
@@ -1148,8 +1062,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1160,8 +1072,6 @@ u8 rtw_disassoc_cmd(struct rtw_adapter *
 	struct cmd_priv *cmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_disassoc_cmd\n"));
 
 	/* prepare cmd parameter */
@@ -1191,8 +1101,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1204,8 +1112,6 @@ u8 rtw_setopmode_cmd(struct rtw_adapter
 	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		res = false;
@@ -1225,8 +1131,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1242,8 +1146,6 @@ u8 rtw_setstakey_cmd(struct rtw_adapter
 	struct sta_info *sta = (struct sta_info *)psta;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		res = _FAIL;
@@ -1300,8 +1202,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1316,8 +1216,6 @@ u8 rtw_clearstakey_cmd(struct rtw_adapte
 	struct sta_info *sta = (struct sta_info *)psta;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	if (!enqueue) {
 		clear_cam_entry(padapter, entry);
 	} else {
@@ -1355,7 +1253,7 @@ _func_enter_;
 		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 	}
 exit:
-_func_exit_;
+
 	return res;
 }
 
@@ -1365,7 +1263,6 @@ u8 rtw_setrttbl_cmd(struct rtw_adapter *
 	struct setratable_parm *psetrttblparm;
 	struct cmd_priv				*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
-_func_enter_;
 
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
@@ -1386,7 +1283,7 @@ _func_enter_;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
-_func_exit_;
+
 	return res;
 }
 
@@ -1396,7 +1293,6 @@ u8 rtw_getrttbl_cmd(struct rtw_adapter *
 	struct getratable_parm *pgetrttblparm;
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
-_func_enter_;
 
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
@@ -1422,7 +1318,7 @@ _func_enter_;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
-_func_exit_;
+
 	return res;
 }
 
@@ -1435,8 +1331,6 @@ u8 rtw_setassocsta_cmd(struct rtw_adapte
 
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		res = _FAIL;
@@ -1467,8 +1361,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
  }
 
@@ -1480,8 +1372,6 @@ u8 rtw_addbareq_cmd(struct rtw_adapter *
 
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
 		res = _FAIL;
@@ -1504,8 +1394,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1516,13 +1404,10 @@ u8 rtw_dynamic_chk_wk_cmd(struct rtw_ada
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	if ((padapter->bDriverStopped == true) ||
 	    (padapter->bSurpriseRemoved == true))
 		goto exit;
 
-
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->adapter_type != PRIMARY_ADAPTER && padapter->pbuddy_adapter)
 		pcmdpriv = &(padapter->pbuddy_adapter->cmdpriv);
@@ -1550,8 +1435,6 @@ _func_enter_;
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1563,8 +1446,6 @@ u8 rtw_set_ch_cmd(struct rtw_adapter *pa
 
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	DBG_8192D(FUNC_NDEV_FMT" ch:%u, bw:%u, ch_offset:%u\n",
 		  FUNC_NDEV_ARG(padapter->pnetdev), ch, bw, ch_offset);
 
@@ -1605,8 +1486,6 @@ exit:
 
 	DBG_8192D(FUNC_NDEV_FMT" res:%u\n", FUNC_NDEV_ARG(padapter->pnetdev), res);
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1618,8 +1497,6 @@ u8 rtw_set_chplan_cmd(struct rtw_adapter
 
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_chplan_cmd\n"));
 
 	/* check input parameter */
@@ -1661,8 +1538,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1674,8 +1549,6 @@ u8 rtw_led_blink_cmd(struct rtw_adapter
 
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_led_blink_cmd\n"));
 
 	pcmdobj = (struct cmd_obj *)kzalloc(sizeof(struct	cmd_obj), GFP_KERNEL);
@@ -1698,8 +1571,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1712,8 +1583,6 @@ u8 rtw_set_csa_cmd(struct rtw_adapter *p
 
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_csa_cmd\n"));
 
 	pcmdobj = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
@@ -1736,8 +1605,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1750,8 +1617,6 @@ u8 rtw_tdls_cmd(struct rtw_adapter *pada
 
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 #ifdef CONFIG_TDLS
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_tdls_cmd\n"));
@@ -1780,9 +1645,6 @@ _func_enter_;
 
 exit:
 
-
-_func_exit_;
-
 	return res;
 }
 
@@ -1908,8 +1770,6 @@ static void lps_ctrl_wk_hdl(struct rtw_a
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	u8 mstatus;
 
-_func_enter_;
-
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
 	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
 		return;
@@ -1941,7 +1801,6 @@ _func_enter_;
 		break;
 	}
 
-_func_exit_;
 }
 
 u8 rtw_lps_ctrl_wk_cmd(struct rtw_adapter *padapter, u8 lps_ctrl_type, u8 enqueue)
@@ -1951,8 +1810,6 @@ u8 rtw_lps_ctrl_wk_cmd(struct rtw_adapte
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type != IFACE_PORT0)
 		return res;
@@ -1985,8 +1842,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -2006,7 +1861,6 @@ u8 rtw_antenna_select_cmd(struct rtw_ada
 	u8 support_ant_div = false;
 	u8 res = _SUCCESS;
 
-_func_enter_;
 	rtw_hal_get_def_var(padapter, HAL_DEF_IS_SUPPORT_ANT_DIV, &(support_ant_div));
 	if (false == support_ant_div)
 		return res;
@@ -2035,7 +1889,7 @@ _func_enter_;
 		antenna_select_wk_hdl(padapter, antenna);
 	}
 exit:
-_func_exit_;
+
 	return res;
 }
 #endif
@@ -2054,8 +1908,6 @@ u8 p2p_protocol_wk_cmd(struct rtw_adapte
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-_func_enter_;
-
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return res;
 
@@ -2080,7 +1932,7 @@ _func_enter_;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
-_func_exit_;
+
 	return res;
 }
 #endif /* CONFIG_P2P */
@@ -2092,7 +1944,6 @@ u8 rtw_ps_cmd(struct rtw_adapter *padapt
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 
 	u8 res = _SUCCESS;
-_func_enter_;
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->adapter_type != PRIMARY_ADAPTER)
@@ -2120,8 +1971,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -2137,7 +1986,6 @@ static void rtw_chk_hi_queue_hdl(struct
 	if (!psta_bmc)
 		return;
 
-
 	if (psta_bmc->sleepq_len == 0) {
 		while ((rtw_read32(padapter, 0x414)&0x00ffff00) != 0) {
 			rtw_msleep_os(100);
@@ -2349,8 +2197,6 @@ void rtw_survey_cmd_callback(struct rtw_
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-_func_enter_;
-
 	if (pcmd->res == H2C_DROPPED) {
 		/* TODO: cancel timer and do timeout handler directly... */
 		/* need to make timeout handlerOS independent */
@@ -2363,23 +2209,19 @@ _func_enter_;
 	/*  free cmd */
 	rtw_free_cmd_obj(pcmd);
 
-_func_exit_;
 }
 
 void rtw_disassoc_cmd_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-_func_enter_;
-
 	if (pcmd->res != H2C_SUCCESS) {
 		spin_lock_bh(&pmlmepriv->lock);
 		set_fwstate(pmlmepriv, _FW_LINKED);
 		spin_unlock_bh(&pmlmepriv->lock);
 
 		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ***Error: disconnect_cmd_callback Fail ***\n."));
-
-		goto exit;
+		return;
 	}
 #ifdef CONFIG_BR_EXT
 	else /* clear bridge database */
@@ -2388,19 +2230,12 @@ _func_enter_;
 
 	/*  free cmd */
 	rtw_free_cmd_obj(pcmd);
-
-exit:
-
-_func_exit_;
 }
 
-
 void rtw_joinbss_cmd_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-_func_enter_;
-
 	if (pcmd->res == H2C_DROPPED) {
 		/* TODO: cancel timer and do timeout handler directly... */
 		/* need to make timeout handlerOS independent */
@@ -2412,7 +2247,6 @@ _func_enter_;
 
 	rtw_free_cmd_obj(pcmd);
 
-_func_exit_;
 }
 
 void rtw_createbss_cmd_callback(struct rtw_adapter *padapter, struct cmd_obj *pcmd)
@@ -2424,8 +2258,6 @@ void rtw_createbss_cmd_callback(struct r
 	struct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)pcmd->parmbuf;
 	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
 
-_func_enter_;
-
 	if ((pcmd->res != H2C_SUCCESS)) {
 		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ********Error: rtw_createbss_cmd_callback  Fail ************\n\n."));
 		_set_timer(&pmlmepriv->assoc_timer, 1);
@@ -2492,7 +2324,7 @@ createbss_cmd_fail:
 	spin_unlock_bh(&pmlmepriv->lock);
 
 	rtw_free_cmd_obj(pcmd);
-_func_exit_;
+
 }
 
 void rtw_setstakey_cmdrsp_callback(struct rtw_adapter *padapter, struct cmd_obj *pcmd)
@@ -2501,15 +2333,13 @@ void rtw_setstakey_cmdrsp_callback(struc
 	struct set_stakey_rsp *psetstakey_rsp = (struct set_stakey_rsp *)(pcmd->rsp);
 	struct sta_info *psta = rtw_get_stainfo(pstapriv, psetstakey_rsp->addr);
 
-_func_enter_;
-
 	if (psta == NULL) {
 		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nERROR: rtw_setstaKey_cmdrsp_callback => can't get sta_info\n\n"));
 		goto exit;
 	}
 exit:
 	rtw_free_cmd_obj(pcmd);
-_func_exit_;
+
 }
 
 void rtw_setassocsta_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
@@ -2520,8 +2350,6 @@ void rtw_setassocsta_cmdrsp_callback(str
 	struct set_assocsta_rsp *passocsta_rsp = (struct set_assocsta_rsp *)(pcmd->rsp);
 	struct sta_info *psta = rtw_get_stainfo(pstapriv, passocsta_parm->addr);
 
-_func_enter_;
-
 	if (psta == NULL) {
 		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nERROR: setassocsta_cmdrsp_callbac => can't get sta_info\n\n"));
 		goto exit;
@@ -2541,13 +2369,11 @@ _func_enter_;
 exit:
 	rtw_free_cmd_obj(pcmd);
 
-_func_exit_;
 }
 
 static void rtw_getrttbl_cmd_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
 {
-_func_enter_;
 
 	rtw_free_cmd_obj(pcmd);
-_func_exit_;
+
 }
--- a/drivers/staging/rtl8192du/core/rtw_debug.c
+++ b/drivers/staging/rtl8192du/core/rtw_debug.c
@@ -20,7 +20,7 @@
 
 u32 GlobalDebugLevel = _drv_err_;
 
-u64 GlobalDebugComponents = 
+u64 GlobalDebugComponents =
 	_module_rtl871x_xmit_c_ |
 	_module_xmit_osdep_c_ |
 	_module_rtl871x_recv_c_ |
--- a/drivers/staging/rtl8192du/core/rtw_ieee80211.c
+++ b/drivers/staging/rtl8192du/core/rtw_ieee80211.c
@@ -137,7 +137,7 @@ u8 *rtw_set_fixed_ie(unsigned char *pbuf
 /*  rtw_set_ie will update frame length */
 u8 *rtw_set_ie(u8 *pbuf, int index, uint len, u8 *source, uint *frlen)
 {
-_func_enter_;
+
 	*pbuf = (u8)index;
 
 	*(pbuf + 1) = (u8)len;
@@ -147,7 +147,7 @@ _func_enter_;
 
 	*frlen = *frlen + (len + 2);
 
-_func_exit_;
+
 	return pbuf + len + 2;
 }
 
@@ -211,9 +211,9 @@ u8 *rtw_get_ie(u8 *pbuf, int index, int
 {
 	int tmp, i;
 	u8 *p;
-_func_enter_;
+
 	if (limit < 1) {
-		_func_exit_;
+
 		return NULL;
 	}
 
@@ -232,7 +232,7 @@ _func_enter_;
 		if (i >= limit)
 			break;
 	}
-_func_exit_;
+
 	return NULL;
 }
 
@@ -324,7 +324,7 @@ exit:
 
 void rtw_set_supported_rate(u8 *SupportedRates, uint mode)
 {
-_func_enter_;
+
 
 	memset(SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
 
@@ -346,13 +346,13 @@ _func_enter_;
 		memcpy(SupportedRates + IEEE80211_CCK_RATE_LEN, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);
 		break;
 	}
-_func_exit_;
+
 }
 
 uint	rtw_get_rateset_len(u8	*rateset)
 {
 	uint i = 0;
-_func_enter_;
+
 	while (1) {
 		if ((rateset[i]) == 0)
 			break;
@@ -362,7 +362,7 @@ _func_enter_;
 
 		i++;
 	}
-_func_exit_;
+
 	return i;
 }
 
@@ -373,7 +373,7 @@ int rtw_generate_ie(struct registry_priv
 	struct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;
 	u8 *ie = pdev_network->IEs;
 
-_func_enter_;
+
 
 	/* timestamp will be inserted by hardware */
 	sz += 8;
@@ -430,7 +430,7 @@ _func_enter_;
 
 	if (rate_len > 8)
 		ie = rtw_set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (pdev_network->SupportedRates + 8), &sz);
-_func_exit_;
+
 	/* return _SUCCESS; */
 	return sz;
 }
@@ -652,7 +652,7 @@ int rtw_get_sec_ie(u8 *in_ie, uint in_le
 	u8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};
 	uint	cnt;
 
-_func_enter_;
+
 
 	/* Search required WPA or WPA2 IE and copy to sec_ie[] */
 
@@ -704,7 +704,7 @@ _func_enter_;
 			}
 		}
 	}
-_func_exit_;
+
 	return *rsn_len + *wpa_len;
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_io.c
+++ b/drivers/staging/rtl8192du/core/rtw_io.c
@@ -49,11 +49,11 @@ u8 _rtw_read8(struct rtw_adapter *adapte
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
-	_func_enter_;
+
 	_read8 = pintfhdl->io_ops._read8;
 
 	r_val = _read8(pintfhdl, addr);
-	_func_exit_;
+
 	return r_val;
 }
 
@@ -63,11 +63,11 @@ u16 _rtw_read16(struct rtw_adapter *adap
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	u16	(*_read16)(struct intf_hdl *pintfhdl, u32 addr);
-	_func_enter_;
+
 	_read16 = pintfhdl->io_ops._read16;
 
 	r_val = _read16(pintfhdl, addr);
-	_func_exit_;
+
 	return r_val;
 }
 
@@ -77,11 +77,11 @@ u32 _rtw_read32(struct rtw_adapter *adap
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	u32	(*_read32)(struct intf_hdl *pintfhdl, u32 addr);
-	_func_enter_;
+
 	_read32 = pintfhdl->io_ops._read32;
 
 	r_val = _read32(pintfhdl, addr);
-	_func_exit_;
+
 	return r_val;
 }
 
@@ -91,11 +91,11 @@ int _rtw_write8(struct rtw_adapter *adap
 	struct	intf_hdl *pintfhdl = &(pio_priv->intf);
 	int (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
 	int ret;
-	_func_enter_;
+
 	_write8 = pintfhdl->io_ops._write8;
 
 	ret = _write8(pintfhdl, addr, val);
-	_func_exit_;
+
 
 	return RTW_STATUS_CODE(ret);
 }
@@ -106,11 +106,11 @@ int _rtw_write16(struct rtw_adapter *ada
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	int (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
 	int ret;
-	_func_enter_;
+
 	_write16 = pintfhdl->io_ops._write16;
 
 	ret = _write16(pintfhdl, addr, val);
-	_func_exit_;
+
 
 	return RTW_STATUS_CODE(ret);
 }
@@ -120,11 +120,11 @@ int _rtw_write32(struct rtw_adapter *ada
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	int (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
 	int ret;
-	_func_enter_;
+
 	_write32 = pintfhdl->io_ops._write32;
 
 	ret = _write32(pintfhdl, addr, val);
-	_func_exit_;
+
 
 	return RTW_STATUS_CODE(ret);
 }
@@ -136,11 +136,11 @@ int _rtw_writeN(struct rtw_adapter *adap
 	int (*_writeN)(struct intf_hdl *pintfhdl, u32 addr,
 		       u32 length, u8 *pdata);
 	int ret;
-	_func_enter_;
+
 	_writeN = pintfhdl->io_ops._writeN;
 
 	ret = _writeN(pintfhdl, addr, length, pdata);
-	_func_exit_;
+
 
 	return RTW_STATUS_CODE(ret);
 }
@@ -150,11 +150,11 @@ int _rtw_write8_async(struct rtw_adapter
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	int (*_write8_async)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
 	int ret;
-	_func_enter_;
+
 	_write8_async = pintfhdl->io_ops._write8_async;
 
 	ret = _write8_async(pintfhdl, addr, val);
-	_func_exit_;
+
 
 	return RTW_STATUS_CODE(ret);
 }
@@ -164,11 +164,11 @@ int _rtw_write16_async(struct rtw_adapte
 	struct	intf_hdl *pintfhdl = &(pio_priv->intf);
 	int (*_write16_async)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
 	int ret;
-	_func_enter_;
+
 	_write16_async = pintfhdl->io_ops._write16_async;
 
 	ret = _write16_async(pintfhdl, addr, val);
-	_func_exit_;
+
 
 	return RTW_STATUS_CODE(ret);
 }
@@ -178,11 +178,11 @@ int _rtw_write32_async(struct rtw_adapte
 	struct	intf_hdl *pintfhdl = &(pio_priv->intf);
 	int (*_write32_async)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
 	int ret;
-	_func_enter_;
+
 	_write32_async = pintfhdl->io_ops._write32_async;
 
 	ret = _write32_async(pintfhdl, addr, val);
-	_func_exit_;
+
 
 	return RTW_STATUS_CODE(ret);
 }
@@ -194,7 +194,7 @@ void _rtw_read_mem(struct rtw_adapter *a
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 
-	_func_enter_;
+
 
 	if ((adapter->bDriverStopped == true) ||
 	    (adapter->bSurpriseRemoved == true)) {
@@ -208,7 +208,7 @@ void _rtw_read_mem(struct rtw_adapter *a
 
 	_read_mem(pintfhdl, addr, cnt, pmem);
 
-	_func_exit_;
+
 }
 
 void _rtw_write_mem(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
@@ -218,13 +218,13 @@ void _rtw_write_mem(struct rtw_adapter *
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl *pintfhdl = &(pio_priv->intf);
 
-	_func_enter_;
+
 
 	_write_mem = pintfhdl->io_ops._write_mem;
 
 	_write_mem(pintfhdl, addr, cnt, pmem);
 
-	_func_exit_;
+
 }
 
 void _rtw_read_port(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
@@ -234,7 +234,7 @@ void _rtw_read_port(struct rtw_adapter *
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl *pintfhdl = &(pio_priv->intf);
 
-	_func_enter_;
+
 
 	if ((adapter->bDriverStopped == true) ||
 	    (adapter->bSurpriseRemoved == true)) {
@@ -248,7 +248,7 @@ void _rtw_read_port(struct rtw_adapter *
 
 	_read_port(pintfhdl, addr, cnt, pmem);
 
-	_func_exit_;
+
 }
 
 void _rtw_read_port_cancel(struct rtw_adapter *adapter)
@@ -271,13 +271,13 @@ u32 _rtw_write_port(struct rtw_adapter *
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	u32 ret = _SUCCESS;
 
-	_func_enter_;
+
 
 	_write_port = pintfhdl->io_ops._write_port;
 
 	ret = _write_port(pintfhdl, addr, cnt, pmem);
 
-	 _func_exit_;
+
 
 	return ret;
 }
--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -37,7 +37,7 @@ u8 rtw_validate_ssid(struct ndis_802_11_
 	u8	 i;
 	u8	ret = true;
 
-_func_enter_;
+
 
 	if (ssid->SsidLength > 32) {
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid length >32\n"));
@@ -56,7 +56,7 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
+
 
 	return ret;
 }
@@ -69,7 +69,7 @@ u8 rtw_do_join(struct rtw_adapter *padap
 	struct __queue *queue = &(pmlmepriv->scanned_queue);
 	u8 ret = _SUCCESS;
 
-_func_enter_;
+
 
 	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 	phead = get_list_head(queue);
@@ -163,7 +163,7 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
+
 
 	return ret;
 }
@@ -175,7 +175,7 @@ u8 rtw_set_802_11_bssid(struct rtw_adapt
 
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-_func_enter_;
+
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
 		 ("+rtw_set_802_11_bssid: bssid =%pM\n", bssid));
@@ -249,7 +249,7 @@ exit:
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 		 ("rtw_set_802_11_bssid: status=%d\n", status));
 
-_func_exit_;
+
 
 	return status;
 }
@@ -262,7 +262,7 @@ u8 rtw_set_802_11_ssid(struct rtw_adapte
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct wlan_network *pnetwork = &pmlmepriv->cur_network;
 
-_func_enter_;
+
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
 		 ("+rtw_set_802_11_ssid: ssid =[%s] fw_state= 0x%08x\n",
@@ -371,7 +371,7 @@ exit:
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 		 ("-rtw_set_802_11_ssid: status=%d\n", status));
 
-_func_exit_;
+
 
 	return status;
 }
@@ -383,7 +383,7 @@ u8 rtw_set_802_11_infrastructure_mode(st
 	struct	wlan_network	*cur_network = &pmlmepriv->cur_network;
 	enum NDIS_802_11_NETWORK_INFRASTRUCTURE *pold_state = &(cur_network->network.InfrastructureMode);
 
-_func_enter_;
+
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
 		 ("+rtw_set_802_11_infrastructure_mode: old=%d new=%d fw_state= 0x%08x\n",
@@ -436,7 +436,7 @@ _func_enter_;
 		}
 	}
 
-_func_exit_;
+
 
 	return true;
 }
@@ -446,7 +446,7 @@ u8 rtw_set_802_11_disassociate(struct rt
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-_func_enter_;
+
 
 	spin_lock_bh(&pmlmepriv->lock);
 
@@ -460,7 +460,7 @@ _func_enter_;
 
 	spin_unlock_bh(&pmlmepriv->lock);
 
-_func_exit_;
+
 
 	return true;
 }
@@ -470,7 +470,7 @@ u8 rtw_set_802_11_bssid_list_scan(struct
 	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	u8	res = true;
 
-_func_enter_;
+
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("+rtw_set_802_11_bssid_list_scan(), fw_state=%x\n", get_fwstate(pmlmepriv)));
 
@@ -509,7 +509,7 @@ _func_enter_;
 	}
 exit:
 
-_func_exit_;
+
 
 	return res;
 }
@@ -520,7 +520,7 @@ u8 rtw_set_802_11_authentication_mode(st
 	int res;
 	u8 ret;
 
-_func_enter_;
+
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_802_11_auth.mode(): mode=%x\n", authmode));
 
@@ -540,7 +540,7 @@ _func_enter_;
 	else
 		ret = false;
 
-_func_exit_;
+
 
 	return ret;
 }
@@ -551,7 +551,7 @@ u8 rtw_set_802_11_add_wep(struct rtw_ada
 	struct security_priv *psecuritypriv = &(padapter->securitypriv);
 	u8		ret = _SUCCESS;
 
-_func_enter_;
+
 
 	keyid = wep->KeyIndex & 0x3fffffff;
 
@@ -598,7 +598,7 @@ _func_enter_;
 		ret = false;
 exit:
 
-_func_exit_;
+
 
 	return ret;
 }
@@ -607,7 +607,7 @@ u8 rtw_set_802_11_remove_wep(struct rtw_
 {
 	u8 ret = _SUCCESS;
 
-_func_enter_;
+
 
 	if (keyindex >= 0x80000000 || padapter == NULL) {
 		ret = false;
@@ -631,7 +631,7 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
+
 
 	return ret;
 }
@@ -645,7 +645,7 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 	u8	bgrouptkey = false;/* can be remove later */
 	u8	ret = _SUCCESS;
 
-_func_enter_;
+
 
 	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)) {
 		/*  It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination, */
@@ -981,7 +981,7 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
+
 
 	return ret;
 }
@@ -995,7 +995,7 @@ u8 rtw_set_802_11_remove_key(struct rtw_
 	u8	keyIndex = (u8)key->KeyIndex & 0x03;
 	u8	ret = _SUCCESS;
 
-_func_enter_;
+
 
 	if ((key->KeyIndex & 0xbffffffc) > 0) {
 		ret = _FAIL;
@@ -1022,7 +1022,7 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
+
 
 	return ret;
 }
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -47,8 +47,6 @@ int _rtw_init_mlme_priv(struct rtw_adapt
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	int res = _SUCCESS;
 
-	_func_enter_;
-
 	/*  We don't need to memset padapter->XXX to zero,
 	 * because adapter is allocated by vzalloc(). */
 
@@ -94,8 +92,6 @@ int _rtw_init_mlme_priv(struct rtw_adapt
 
 exit:
 
-	_func_exit_;
-
 	return res;
 }
 
@@ -157,7 +153,6 @@ void rtw_free_mlme_priv_ie_data(struct m
 
 void _rtw_free_mlme_priv(struct mlme_priv *pmlmepriv)
 {
-	_func_enter_;
 
 	rtw_free_mlme_priv_ie_data(pmlmepriv);
 
@@ -167,12 +162,11 @@ void _rtw_free_mlme_priv(struct mlme_pri
 		if (pmlmepriv->free_bss_buf)
 			vfree(pmlmepriv->free_bss_buf);
 	}
-	_func_exit_;
+
 }
 
 int _rtw_enqueue_network(struct __queue *queue, struct wlan_network *pnetwork)
 {
-	_func_enter_;
 
 	if (pnetwork == NULL)
 		goto exit;
@@ -185,8 +179,6 @@ int _rtw_enqueue_network(struct __queue
 
 exit:
 
-	_func_exit_;
-
 	return _SUCCESS;
 }
 
@@ -194,8 +186,6 @@ struct wlan_network *_rtw_dequeue_networ
 {
 	struct wlan_network *pnetwork;
 
-	_func_enter_;
-
 	spin_lock_bh(&queue->lock);
 
 	if (_rtw_queue_empty(queue) == true) {
@@ -210,8 +200,6 @@ struct wlan_network *_rtw_dequeue_networ
 
 	spin_unlock_bh(&queue->lock);
 
-	_func_exit_;
-
 	return pnetwork;
 }
 
@@ -221,8 +209,6 @@ struct wlan_network *_rtw_alloc_network(
 	struct __queue *free_queue = &pmlmepriv->free_bss_pool;
 	struct list_head *plist = NULL;
 
-	_func_enter_;
-
 	spin_lock_bh(&free_queue->lock);
 
 	if (_rtw_queue_empty(free_queue) == true) {
@@ -248,8 +234,6 @@ struct wlan_network *_rtw_alloc_network(
 exit:
 	spin_unlock_bh(&free_queue->lock);
 
-	_func_exit_;
-
 	return pnetwork;
 }
 
@@ -260,13 +244,11 @@ void _rtw_free_network(struct mlme_priv
 	u32 lifetime = SCANQUEUE_LIFETIME;
 	struct __queue *free_queue = &(pmlmepriv->free_bss_pool);
 
-	_func_enter_;
-
 	if (pnetwork == NULL)
-		goto exit;
+		return;
 
 	if (pnetwork->fixed == true)
-		goto exit;
+		return;
 
 	curr_time = rtw_get_current_time();
 
@@ -277,9 +259,8 @@ void _rtw_free_network(struct mlme_priv
 	if (!isfreeall) {
 		delta_time = (curr_time - pnetwork->last_scanned) / HZ;
 
-		if (delta_time < lifetime) {	/*  unit:sec */
-			goto exit;
-		}
+		if (delta_time < lifetime)	/*  unit:sec */
+			return;
 	}
 
 	spin_lock_bh(&free_queue->lock);
@@ -291,10 +272,6 @@ void _rtw_free_network(struct mlme_priv
 	pmlmepriv->num_of_scanned--;
 
 	spin_unlock_bh(&free_queue->lock);
-
-exit:
-
-	_func_exit_;
 }
 
 void _rtw_free_network_nolock(struct mlme_priv *pmlmepriv,
@@ -302,23 +279,17 @@ void _rtw_free_network_nolock(struct mlm
 {
 	struct __queue *free_queue = &(pmlmepriv->free_bss_pool);
 
-	_func_enter_;
-
 	if (pnetwork == NULL)
-		goto exit;
+		return;
 
 	if (pnetwork->fixed == true)
-		goto exit;
+		return;
 
 	rtw_list_delete(&(pnetwork->list));
 
 	rtw_list_insert_tail(&(pnetwork->list), get_list_head(free_queue));
 
 	pmlmepriv->num_of_scanned--;
-
-exit:
-
-	_func_exit_;
 }
 
 /*
@@ -332,8 +303,6 @@ struct wlan_network *_rtw_find_network(s
 	struct wlan_network *pnetwork = NULL;
 	u8 zero_addr[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
 
-	_func_enter_;
-
 	if (_rtw_memcmp(zero_addr, addr, ETH_ALEN)) {
 		pnetwork = NULL;
 		goto exit;
@@ -361,8 +330,6 @@ struct wlan_network *_rtw_find_network(s
 
 exit:
 
-	_func_exit_;
-
 	return pnetwork;
 }
 
@@ -373,8 +340,6 @@ void _rtw_free_network_queue(struct rtw_
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct __queue *scanned_queue = &pmlmepriv->scanned_queue;
 
-	_func_enter_;
-
 	spin_lock_bh(&scanned_queue->lock);
 
 	phead = get_list_head(scanned_queue);
@@ -390,13 +355,11 @@ void _rtw_free_network_queue(struct rtw_
 
 	spin_unlock_bh(&scanned_queue->lock);
 
-	_func_exit_;
 }
 
 int rtw_if_up(struct rtw_adapter *padapter)
 {
 	int res;
-	_func_enter_;
 
 	if (padapter->bDriverStopped || padapter->bSurpriseRemoved ||
 	    (check_fwstate(&padapter->mlmepriv, _FW_LINKED) == false)) {
@@ -409,7 +372,6 @@ int rtw_if_up(struct rtw_adapter *padapt
 		res = true;
 	}
 
-	_func_exit_;
 	return res;
 }
 
@@ -417,14 +379,13 @@ void rtw_generate_random_ibss(u8 *pibss)
 {
 	u32 curtime = rtw_get_current_time();
 
-	_func_enter_;
 	pibss[0] = 0x02;	/* in ad-hoc mode bit1 must set to 1 */
 	pibss[1] = 0x11;
 	pibss[2] = 0x87;
 	pibss[3] = (u8) (curtime & 0xff);	/* p[0]; */
 	pibss[4] = (u8) ((curtime >> 8) & 0xff);	/* p[1]; */
 	pibss[5] = (u8) ((curtime >> 16) & 0xff);	/* p[2]; */
-	_func_exit_;
+
 	return;
 }
 
@@ -436,11 +397,9 @@ u8 *rtw_get_capability_from_ie(u8 *ie)
 u16 rtw_get_capability(struct wlan_bssid_ex *bss)
 {
 	__le16 val;
-	_func_enter_;
 
 	memcpy((u8 *)&val, rtw_get_capability_from_ie(bss->IEs), 2);
 
-	_func_exit_;
 	return le16_to_cpu(val);
 }
 
@@ -457,72 +416,72 @@ u8 *rtw_get_beacon_interval_from_ie(u8 *
 int rtw_init_mlme_priv(struct rtw_adapter *padapter)
 {				/* struct mlme_priv *pmlmepriv) */
 	int res;
-	_func_enter_;
+
 	res = _rtw_init_mlme_priv(padapter);	/*  (pmlmepriv); */
-	_func_exit_;
+
 	return res;
 }
 
 void rtw_free_mlme_priv(struct mlme_priv *pmlmepriv)
 {
-	_func_enter_;
+
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("rtw_free_mlme_priv\n"));
 	_rtw_free_mlme_priv(pmlmepriv);
-	_func_exit_;
+
 }
 
 static int rtw_enqueue_network(struct __queue *queue, struct wlan_network *pnetwork)
 {
 	int res;
-	_func_enter_;
+
 	res = _rtw_enqueue_network(queue, pnetwork);
-	_func_exit_;
+
 	return res;
 }
 
 static struct wlan_network *rtw_dequeue_network(struct __queue *queue)
 {
 	struct wlan_network *pnetwork;
-	_func_enter_;
+
 	pnetwork = _rtw_dequeue_network(queue);
-	_func_exit_;
+
 	return pnetwork;
 }
 
 static struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv)
 {
 	struct wlan_network *pnetwork;
-	_func_enter_;
+
 	pnetwork = _rtw_alloc_network(pmlmepriv);
-	_func_exit_;
+
 	return pnetwork;
 }
 
 static void rtw_free_network(struct mlme_priv *pmlmepriv,
 			     struct wlan_network *pnetwork, u8 is_freeall)
 {
-	_func_enter_;
+
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 		 ("rtw_free_network==> ssid = %s\n\n",
 		  pnetwork->network.Ssid.Ssid));
 	_rtw_free_network(pmlmepriv, pnetwork, is_freeall);
-	_func_exit_;
+
 }
 
 static void rtw_free_network_nolock(struct mlme_priv *pmlmepriv,
 				    struct wlan_network *pnetwork)
 {
-	_func_enter_;
+
 	/* RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s\n\n" , pnetwork->network.Ssid.Ssid)); */
 	_rtw_free_network_nolock(pmlmepriv, pnetwork);
-	_func_exit_;
+
 }
 
 void rtw_free_network_queue(struct rtw_adapter *dev, u8 isfreeall)
 {
-	_func_enter_;
+
 	_rtw_free_network_queue(dev, isfreeall);
-	_func_exit_;
+
 }
 
 /*
@@ -569,16 +528,12 @@ int is_same_network(struct wlan_bssid_ex
 	u16 s_cap, d_cap;
 	__le16 le_scap, le_dcap;
 
-	_func_enter_;
-
 	memcpy((u8 *)&le_scap, rtw_get_capability_from_ie(src->IEs), 2);
 	memcpy((u8 *)&le_dcap, rtw_get_capability_from_ie(dst->IEs), 2);
 
 	s_cap = le16_to_cpu(le_scap);
 	d_cap = le16_to_cpu(le_dcap);
 
-	_func_exit_;
-
 	return ((src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
 		/*      (src->Configuration.DSConfig == dst->Configuration.DSConfig) && */
 		((_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == true) &&
@@ -596,7 +551,7 @@ struct wlan_network *rtw_get_oldest_wlan
 	struct list_head *plist, *phead;
 	struct wlan_network *pwlan = NULL;
 	struct wlan_network *oldest = NULL;
-	_func_enter_;
+
 	phead = get_list_head(scanned_queue);
 
 	plist = get_next(phead);
@@ -616,7 +571,7 @@ struct wlan_network *rtw_get_oldest_wlan
 
 		plist = get_next(plist);
 	}
-	_func_exit_;
+
 	return oldest;
 }
 
@@ -635,8 +590,6 @@ static void update_network(struct wlan_b
 	u8 sq_final;
 	long rssi_final;
 
-	_func_enter_;
-
 #ifdef CONFIG_ANTENNA_DIVERSITY
 	rtw_hal_antdiv_rssi_compared(padapter, dst, src);	/* this will update src.Rssi, need consider again */
 #endif
@@ -695,7 +648,7 @@ static void update_network(struct wlan_b
 		     dst->Rssi);
 	}
 #endif
-	_func_exit_;
+
 }
 
 static void update_current_network(struct rtw_adapter *adapter,
@@ -703,8 +656,6 @@ static void update_current_network(struc
 {
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 
-	_func_enter_;
-
 	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) &&
 	    (is_same_network(&(pmlmepriv->cur_network.network), pnetwork))) {
 		/* RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"Same Network\n"); */
@@ -723,14 +674,12 @@ static void update_current_network(struc
 		}
 	}
 
-	_func_exit_;
 }
 
 /*
 
 Caller must hold pmlmepriv->lock first.
 
-
 */
 void rtw_update_scanned_network(struct rtw_adapter *adapter,
 				struct wlan_bssid_ex *target)
@@ -742,8 +691,6 @@ void rtw_update_scanned_network(struct r
 	struct wlan_network *pnetwork = NULL;
 	struct wlan_network *oldest = NULL;
 
-	_func_enter_;
-
 	spin_lock_bh(&queue->lock);
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -841,7 +788,6 @@ void rtw_update_scanned_network(struct r
 exit:
 	spin_unlock_bh(&queue->lock);
 
-	_func_exit_;
 }
 
 static void rtw_add_network(struct rtw_adapter *adapter,
@@ -850,8 +796,6 @@ static void rtw_add_network(struct rtw_a
 	struct mlme_priv *pmlmepriv =
 	    &(((struct rtw_adapter *)adapter)->mlmepriv);
 
-	_func_enter_;
-
 	/* spin_lock_bh(&queue->lock); */
 
 #if defined(CONFIG_P2P) && defined(CONFIG_P2P_REMOVE_GROUP_INFO)
@@ -864,14 +808,13 @@ static void rtw_add_network(struct rtw_a
 
 	/* spin_unlock_bh(&queue->lock); */
 
-	_func_exit_;
 }
 
 /* select the desired network based on the capability of the (i)bss. */
 /*  check items: (1) security */
-/* 			   (2) network_type */
-/* 			   (3) WMM */
-/* 			   (4) HT */
+/*			   (2) network_type */
+/*			   (3) WMM */
+/*			   (4) HT */
 /*                      (5) others */
 static int rtw_is_desired_network(struct rtw_adapter *adapter,
 				  struct wlan_network *pnetwork)
@@ -922,10 +865,10 @@ static int rtw_is_desired_network(struct
 /* TODO: Perry : For Power Management */
 void rtw_atimdone_event_callback(struct rtw_adapter *adapter, u8 *pbuf)
 {
-	_func_enter_;
+
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 		 ("receive atimdone_evet\n"));
-	_func_exit_;
+
 	return;
 }
 
@@ -935,8 +878,6 @@ void rtw_survey_event_callback(struct rt
 	struct wlan_bssid_ex *pnetwork;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 
-	_func_enter_;
-
 	pnetwork = (struct wlan_bssid_ex *)pbuf;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
@@ -987,8 +928,6 @@ exit:
 
 	spin_unlock_bh(&pmlmepriv->lock);
 
-	_func_exit_;
-
 	return;
 }
 
@@ -1001,8 +940,6 @@ void rtw_surveydone_event_callback(struc
 
 #endif
 
-	_func_enter_;
-
 	spin_lock_bh(&pmlmepriv->lock);
 
 	if (pmlmepriv->wps_probe_req_ie) {
@@ -1172,7 +1109,6 @@ void rtw_surveydone_event_callback(struc
 	rtw_cfg80211_surveydone_event_callback(adapter);
 #endif /* CONFIG_IOCTL_CFG80211 */
 
-	_func_exit_;
 }
 
 void rtw_dummy_event_callback(struct rtw_adapter *adapter, u8 *pbuf)
@@ -1189,8 +1125,6 @@ static void free_scanqueue(struct mlme_p
 	struct __queue *scan_queue = &pmlmepriv->scanned_queue;
 	struct list_head *plist, *phead, *ptemp;
 
-	_func_enter_;
-
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+free_scanqueue\n"));
 	spin_lock_bh(&scan_queue->lock);
 	spin_lock_bh(&free_queue->lock);
@@ -1209,7 +1143,6 @@ static void free_scanqueue(struct mlme_p
 	spin_unlock_bh(&free_queue->lock);
 	spin_unlock_bh(&scan_queue->lock);
 
-	_func_exit_;
 }
 
 /*
@@ -1226,7 +1159,6 @@ void rtw_free_assoc_resources(struct rtw
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
 #endif /* CONFIG_TDLS */
-	_func_enter_;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
 		 ("+rtw_free_assoc_resources\n"));
@@ -1294,7 +1226,6 @@ void rtw_free_assoc_resources(struct rtw
 
 	pmlmepriv->key_mask = 0;
 
-	_func_exit_;
 }
 
 /*
@@ -1305,8 +1236,6 @@ void rtw_indicate_connect(struct rtw_ada
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
-	_func_enter_;
-
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 		 ("+rtw_indicate_connect\n"));
 
@@ -1346,7 +1275,6 @@ void rtw_indicate_connect(struct rtw_ada
 		 ("-rtw_indicate_connect: fw_state=0x%08x\n",
 		  get_fwstate(pmlmepriv)));
 
-	_func_exit_;
 }
 
 /*
@@ -1356,8 +1284,6 @@ void rtw_indicate_disconnect(struct rtw_
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-	_func_enter_;
-
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 		 ("+rtw_indicate_disconnect\n"));
 
@@ -1385,7 +1311,6 @@ void rtw_indicate_disconnect(struct rtw_
 
 #endif
 
-	_func_exit_;
 }
 
 inline void rtw_indicate_scan_done(struct rtw_adapter *padapter, bool aborted)
@@ -1620,8 +1545,6 @@ void rtw_joinbss_event_prehandle(struct
 	struct wlan_network *pcur_wlan = NULL, *ptarget_wlan = NULL;
 	unsigned int the_same_macaddr = false;
 
-	_func_enter_;
-
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
 		 ("joinbss event call back received with res=%d\n",
 		  pnetwork->join_res));
@@ -1645,7 +1568,7 @@ void rtw_joinbss_event_prehandle(struct
 	if (pnetwork->network.Length > sizeof(struct wlan_bssid_ex)) {
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 			 ("\n\n ***joinbss_evt_callback return a wrong bss ***\n\n"));
-		goto ignore_nolock;
+		return;
 	}
 
 	spin_lock_bh(&pmlmepriv->lock);
@@ -1826,16 +1749,12 @@ void rtw_joinbss_event_prehandle(struct
 ignore_joinbss_callback:
 
 	spin_unlock_bh(&pmlmepriv->lock);
-ignore_nolock:
-	_func_exit_;
 }
 
 void rtw_joinbss_event_callback(struct rtw_adapter *adapter, u8 *pbuf)
 {
 	struct wlan_network *pnetwork = (struct wlan_network *)pbuf;
 
-	_func_enter_;
-
 	mlmeext_joinbss_event_callback(adapter, pnetwork->join_res);
 
 	rtw_os_xmit_schedule(adapter);
@@ -1848,7 +1767,6 @@ void rtw_joinbss_event_callback(struct r
 	dc_resume_xmit(adapter);
 #endif
 
-	_func_exit_;
 }
 
 void rtw_stassoc_event_callback(struct rtw_adapter *adapter, u8 *pbuf)
@@ -1859,8 +1777,6 @@ void rtw_stassoc_event_callback(struct r
 	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
 	struct wlan_network *ptarget_wlan = NULL;
 
-	_func_enter_;
-
 	if (rtw_access_ctrl(adapter, pstassoc->macaddr) == false)
 		return;
 
@@ -1902,7 +1818,7 @@ void rtw_stassoc_event_callback(struct r
 
 			ap_sta_info_defer_update(adapter, psta);
 		}
-		goto exit;
+		return;
 	}
 #endif
 
@@ -1913,14 +1829,14 @@ void rtw_stassoc_event_callback(struct r
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 			 ("Error: rtw_stassoc_event_callback: sta has been in sta_hash_queue\n"));
 
-		goto exit;	/* between drv has received this event before and  fw have not yet to set key to CAM_ENTRY) */
+		return;	/* between drv has received this event before and  fw have not yet to set key to CAM_ENTRY) */
 	}
 
 	psta = rtw_alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);
 	if (psta == NULL) {
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 			 ("Can't alloc sta_info when rtw_stassoc_event_callback\n"));
-		goto exit;
+		return;
 	}
 
 	/* to do : init sta_info variable */
@@ -1954,9 +1870,6 @@ void rtw_stassoc_event_callback(struct r
 	spin_unlock_bh(&pmlmepriv->lock);
 
 	mlmeext_sta_add_event_callback(adapter, psta);
-
-exit:
-	_func_exit_;
 }
 
 void rtw_stadel_event_callback(struct rtw_adapter *adapter, u8 *pbuf)
@@ -1970,8 +1883,6 @@ void rtw_stadel_event_callback(struct rt
 	struct sta_priv *pstapriv = &adapter->stapriv;
 	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
 
-	_func_enter_;
-
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 #ifdef CONFIG_IOCTL_CFG80211
 #ifdef COMPAT_KERNEL_RELEASE
@@ -2078,7 +1989,6 @@ void rtw_stadel_event_callback(struct rt
 
 	spin_unlock_bh(&pmlmepriv->lock);
 
-	_func_exit_;
 }
 
 void rtw_cpwm_event_callback(struct rtw_adapter *padapter, u8 *pbuf)
@@ -2087,8 +1997,6 @@ void rtw_cpwm_event_callback(struct rtw_
 	struct reportpwrstate_parm *preportpwrstate;
 #endif
 
-	_func_enter_;
-
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 		 ("rtw_cpwm_event_callback !!!\n"));
 #ifdef CONFIG_LPS_LCLK
@@ -2097,7 +2005,6 @@ void rtw_cpwm_event_callback(struct rtw_
 	cpwm_int_hdl(padapter, preportpwrstate);
 #endif
 
-	_func_exit_;
 }
 
 /*
@@ -2111,7 +2018,6 @@ void _rtw_join_timeout_handler(struct rt
 	int do_join_r;
 #endif /* CONFIG_LAYER2_ROAMING */
 
-	_func_enter_;
 	DBG_8192D("%s, fw_state=%x\n", __func__, get_fwstate(pmlmepriv));
 
 	if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
@@ -2165,7 +2071,6 @@ void _rtw_join_timeout_handler(struct rt
 	drvext_assoc_fail_indicate(&adapter->drvextpriv);
 #endif
 
-	_func_exit_;
 }
 
 /*
@@ -2424,7 +2329,6 @@ The caller must hold the following spinl
 
 pmlmepriv->lock
 
-
 */
 
 int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv)
@@ -2437,8 +2341,6 @@ int rtw_select_and_join_from_scanned_que
 	struct wlan_network *candidate = NULL;
 	u8 bSupportAntDiv = false;
 
-	_func_enter_;
-
 	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 	phead = get_list_head(queue);
 	adapter = (struct rtw_adapter *)pmlmepriv->nic_hdl;
@@ -2502,8 +2404,6 @@ int rtw_select_and_join_from_scanned_que
 exit:
 	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
-	_func_exit_;
-
 	return ret;
 }
 
@@ -2515,8 +2415,6 @@ int rtw_set_auth(struct rtw_adapter *ada
 	struct cmd_priv *pcmdpriv = &(adapter->cmdpriv);
 	int res = _SUCCESS;
 
-	_func_enter_;
-
 	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (pcmd == NULL) {
 		res = _FAIL;	/* try again */
@@ -2550,8 +2448,6 @@ int rtw_set_auth(struct rtw_adapter *ada
 
 exit:
 
-	_func_exit_;
-
 	return res;
 }
 
@@ -2565,8 +2461,6 @@ int rtw_set_key(struct rtw_adapter *adap
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 	int res = _SUCCESS;
 
-	_func_enter_;
-
 	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (pcmd == NULL) {
 		res = _FAIL;	/* try again */
@@ -2656,7 +2550,7 @@ int rtw_set_key(struct rtw_adapter *adap
 	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
 
 exit:
-	_func_exit_;
+
 	return res;
 }
 
@@ -2696,8 +2590,8 @@ int rtw_restruct_wmm_ie(struct rtw_adapt
 /*  */
 /*  Search by BSSID, */
 /*  Return Value: */
-/* 		-1		:if there is no pre-auth key in the  table */
-/* 		>=0		:if there is pre-auth key, and   return the entry id */
+/*		-1		:if there is no pre-auth key in the  table */
+/*		>=0		:if there is pre-auth key, and   return the entry id */
 /*  */
 /*  */
 
@@ -2769,8 +2663,6 @@ int rtw_restruct_sec_ie(struct rtw_adapt
 	uint ndisauthmode = psecuritypriv->ndisauthtype;
 	uint ndissecuritytype = psecuritypriv->ndisencryptstatus;
 
-	_func_enter_;
-
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
 		 ("+rtw_restruct_sec_ie: ndisauthmode=%d ndissecuritytype=%d\n",
 		  ndisauthmode, ndissecuritytype));
@@ -2813,8 +2705,6 @@ int rtw_restruct_sec_ie(struct rtw_adapt
 		}
 	}
 
-	_func_exit_;
-
 	return ielength;
 }
 
@@ -2825,8 +2715,6 @@ void rtw_init_registrypriv_dev_network(s
 	struct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;
 	u8 *myhwaddr = myid(peepriv);
 
-	_func_enter_;
-
 	memcpy(pdev_network->MacAddress, myhwaddr, ETH_ALEN);
 
 	memcpy(&pdev_network->Ssid, &pregistrypriv->ssid,
@@ -2839,7 +2727,6 @@ void rtw_init_registrypriv_dev_network(s
 	pdev_network->Configuration.FHConfig.HopSet = 0;
 	pdev_network->Configuration.FHConfig.DwellTime = 0;
 
-	_func_exit_;
 }
 
 void rtw_update_registrypriv_dev_network(struct rtw_adapter *adapter)
@@ -2851,8 +2738,6 @@ void rtw_update_registrypriv_dev_network
 	struct wlan_network *cur_network = &adapter->mlmepriv.cur_network;
 	/* struct       xmit_priv       *pxmitpriv = &adapter->xmitpriv; */
 
-	_func_enter_;
-
 	pdev_network->Privacy = (psecuritypriv->dot11PrivacyAlgrthm > 0 ? 1 : 0);	/*  adhoc no 802.1x */
 
 	pdev_network->Rssi = 0;
@@ -2905,14 +2790,11 @@ void rtw_update_registrypriv_dev_network
 	pdev_network->Length =
 	    get_wlan_bssid_ex_sz((struct wlan_bssid_ex *)pdev_network);
 
-	_func_exit_;
 }
 
 void rtw_get_encrypt_decrypt_from_registrypriv(struct rtw_adapter *adapter)
 {
-	_func_enter_;
 
-	_func_exit_;
 }
 
 /* the fucntion is at passive_level */
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -1959,7 +1959,7 @@ unsigned int OnAssocRsp(struct rtw_adapt
 	pmlmeinfo->slotTime = (pmlmeinfo->capability & BIT(10)) ? 9 : 20;
 
 	/* AID */
-	res = 
+	res =
 	    (int)(le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN + 4))
 		  & 0x3fff);
 	pmlmeinfo->aid = res;
@@ -9510,7 +9510,7 @@ static void process_80211d(struct rtw_ad
 					   chplan_ap.Channel[j]) {
 					chplan_new[k].ChannelNum =
 					    chplan_sta[i].ChannelNum;
-/* 					chplan_new[k].ScanType = chplan_sta[i].ScanType; */
+/*					chplan_new[k].ScanType = chplan_sta[i].ScanType; */
 					chplan_new[k].ScanType = SCAN_PASSIVE;
 					i++;
 					k++;
@@ -9530,7 +9530,7 @@ static void process_80211d(struct rtw_ad
 			       (chplan_sta[i].ChannelNum <= 14)) {
 				chplan_new[k].ChannelNum =
 				    chplan_sta[i].ChannelNum;
-/* 				chplan_new[k].ScanType = chplan_sta[i].ScanType; */
+/*				chplan_new[k].ScanType = chplan_sta[i].ScanType; */
 				chplan_new[k].ScanType = SCAN_PASSIVE;
 				i++;
 				k++;
@@ -9581,7 +9581,7 @@ static void process_80211d(struct rtw_ad
 					   chplan_ap.Channel[j]) {
 					chplan_new[k].ChannelNum =
 					    chplan_sta[i].ChannelNum;
-/* 					chplan_new[k].ScanType = chplan_sta[i].ScanType; */
+/*					chplan_new[k].ScanType = chplan_sta[i].ScanType; */
 					chplan_new[k].ScanType = SCAN_PASSIVE;
 					i++;
 					k++;
@@ -9599,7 +9599,7 @@ static void process_80211d(struct rtw_ad
 			while ((i < MAX_CHANNEL_NUM) && (chplan_sta[i].ChannelNum != 0)) {
 				chplan_new[k].ChannelNum =
 				    chplan_sta[i].ChannelNum;
-/* 				chplan_new[k].ScanType = chplan_sta[i].ScanType; */
+/*				chplan_new[k].ScanType = chplan_sta[i].ScanType; */
 				chplan_new[k].ScanType = SCAN_PASSIVE;
 				i++;
 				k++;
@@ -10730,7 +10730,7 @@ u8 join_cmd_hdl(struct rtw_adapter *adap
 
 			/* spec case only for cisco's ap because cisco's ap issue assoc rsp using mcs rate @40MHz or @20MHz */
 /* if !defined(CONFIG_CONCURRENT_MODE) && !defined(CONFIG_DUALMAC_CONCURRENT) */
-/* 				if (pmlmeinfo->assoc_AP_vendor == ciscoAP) */
+/*				if (pmlmeinfo->assoc_AP_vendor == ciscoAP) */
 /* endif */
 			{
 				struct HT_info_element *pht_info =
@@ -11249,7 +11249,7 @@ u8 set_tx_beacon_cmd(struct rtw_adapter
 	u8 res = _SUCCESS;
 	int len_diff = 0;
 
-	_func_enter_;
+
 
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
@@ -11280,7 +11280,7 @@ u8 set_tx_beacon_cmd(struct rtw_adapter
 
 exit:
 
-	_func_exit_;
+
 
 	return res;
 }
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -217,7 +217,7 @@ static void issue_p2p_devdisc_resp(struc
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8 action = P2P_PUB_ACTION_ACTION;
-	__be32 	p2poui = cpu_to_be32(P2POUI);
+	__be32	p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_DEVDISC_RESP;
 	u8 p2pie[8] = { 0x00 };
 	u32 p2pielen = 0;
@@ -283,7 +283,7 @@ static void issue_p2p_provision_resp(str
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8 action = P2P_PUB_ACTION_ACTION;
 	u8 dialogToken = frame_body[7];	/*	The Dialog Token of provisioning discovery request frame. */
-	__be32 	p2poui = cpu_to_be32(P2POUI);
+	__be32	p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_PROVISION_DISC_RESP;
 	u8 wpsie[100] = { 0x00 };
 	u8 wpsielen = 0;
@@ -2877,7 +2877,7 @@ static void find_phase_handler(struct rt
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct ndis_802_11_ssid	ssid;
 
-_func_enter_;
+
 
 	memset((unsigned char *)&ssid, 0, sizeof(struct ndis_802_11_ssid));
 	memcpy(ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN);
@@ -2890,7 +2890,7 @@ _func_enter_;
 	spin_unlock_bh(&pmlmepriv->lock);
 
 
-_func_exit_;
+
 }
 
 void p2p_concurrent_handler(struct rtw_adapter *padapter);
@@ -2900,7 +2900,7 @@ static void restore_p2p_state_handler(st
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 
-_func_enter_;
+
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) ||
 	    rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
@@ -2931,49 +2931,49 @@ _func_enter_;
 		set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 #endif
 	}
-_func_exit_;
+
 }
 
 static void pre_tx_invitereq_handler(struct rtw_adapter *padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	u8 val8 = 1;
-_func_enter_;
+
 
 	set_channel_bwmode(padapter, pwdinfo->invitereq_info.peer_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 	issue_probereq_p2p(padapter, NULL);
 	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 
-_func_exit_;
+
 }
 
 static void pre_tx_provdisc_handler(struct rtw_adapter *padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	u8 val8 = 1;
-_func_enter_;
+
 
 	set_channel_bwmode(padapter, pwdinfo->tx_prov_disc_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 	issue_probereq_p2p(padapter, NULL);
 	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 
-_func_exit_;
+
 }
 
 static void pre_tx_negoreq_handler(struct rtw_adapter *padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	u8 val8 = 1;
-_func_enter_;
+
 
 	set_channel_bwmode(padapter, pwdinfo->nego_req_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 	issue_probereq_p2p(padapter, NULL);
 	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 
-_func_exit_;
+
 }
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -2985,7 +2985,7 @@ void p2p_concurrent_handler(struct rtw_a
 	/* struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv; */
 	/* struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv; */
 	u8 val8;
-_func_enter_;
+
 
 	if (check_buddy_fwstate(padapter, _FW_LINKED)) {
 		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
@@ -3067,7 +3067,7 @@ _func_enter_;
 		set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	}
 
-_func_exit_;
+
 }
 #endif
 
@@ -3078,7 +3078,7 @@ static void ro_ch_handler(struct rtw_ada
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-_func_enter_;
+
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter, _FW_LINKED)) {
@@ -3115,7 +3115,7 @@ _func_enter_;
 		&pcfg80211_wdinfo->remain_on_ch_channel,
 		pcfg80211_wdinfo->remain_on_ch_type, GFP_KERNEL);
 
-_func_exit_;
+
 }
 
 static void ro_ch_timer_process (void *FunctionContext)
@@ -3497,7 +3497,7 @@ void p2p_protocol_wk_hdl(struct rtw_adap
 {
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-_func_enter_;
+
 
 	switch (intCmdType) {
 	case P2P_FIND_PHASE_WK:
@@ -3550,7 +3550,7 @@ _func_enter_;
 #endif /* CONFIG_IOCTL_CFG80211 */
 	}
 
-_func_exit_;
+
 }
 
 #ifdef CONFIG_P2P_PS
@@ -3567,7 +3567,7 @@ void process_p2p_ps_ie(struct rtw_adapte
 	u8 find_p2p = false, find_p2p_ps = false;
 	u8 noa_offset, noa_num, noa_index;
 
-_func_enter_;
+
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
@@ -3645,7 +3645,7 @@ _func_enter_;
 			p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
 	}
 
-_func_exit_;
+
 }
 
 void p2p_ps_wk_hdl(struct rtw_adapter *padapter, u8 p2p_ps_state)
@@ -3653,7 +3653,7 @@ void p2p_ps_wk_hdl(struct rtw_adapter *p
 	struct pwrctrl_priv		*pwrpriv = &padapter->pwrctrlpriv;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-_func_enter_;
+
 
 	switch (p2p_ps_state) {
 	case P2P_PS_DISABLE:
@@ -3699,7 +3699,7 @@ _func_enter_;
 		break;
 	}
 
-_func_exit_;
+
 }
 
 u8 p2p_ps_wk_cmd(struct rtw_adapter *padapter, u8 p2p_ps_state, u8 enqueue)
@@ -3710,7 +3710,7 @@ u8 p2p_ps_wk_cmd(struct rtw_adapter *pad
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-_func_enter_;
+
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
 #ifdef CONFIG_CONCURRENT_MODE
@@ -3746,7 +3746,7 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
+
 
 	return res;
 }
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -300,7 +300,7 @@ void rtw_set_rpwm(struct rtw_adapter *pa
 	u8 rpwm;
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 
-	_func_enter_;
+
 
 	pslv = PS_STATE(pslv);
 
@@ -337,7 +337,7 @@ void rtw_set_rpwm(struct rtw_adapter *pa
 	if (!(rpwm & PS_ACK))
 		pwrpriv->cpwm = pslv;
 
-	_func_exit_;
+
 }
 
 static u8 ps_rdy_check(struct rtw_adapter *padapter)
@@ -388,7 +388,7 @@ void rtw_set_ps_mode(struct rtw_adapter
 	struct sta_info *ptdls_sta;
 #endif /* CONFIG_TDLS */
 
-	_func_enter_;
+
 
 	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
 		 ("%s: PowerMode=%d Smart_PS=%d\n",
@@ -527,7 +527,7 @@ void rtw_set_ps_mode(struct rtw_adapter
 		/*  */
 	}
 
-	_func_exit_;
+
 }
 
 /*  */
@@ -540,7 +540,7 @@ void rtw_lps_enter(struct rtw_adapter *p
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct rtw_adapter *buddy = padapter->pbuddy_adapter;
 
-	_func_enter_;
+
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type != IFACE_PORT0)
@@ -594,7 +594,7 @@ void rtw_lps_enter(struct rtw_adapter *p
 		}
 	}
 
-	_func_exit_;
+
 }
 
 /*  */
@@ -609,7 +609,7 @@ void rtw_lps_leave(struct rtw_adapter *p
 	u32 start_time;
 	bool bAwake = false;
 
-	_func_enter_;
+
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type != IFACE_PORT0)
@@ -641,7 +641,7 @@ void rtw_lps_leave(struct rtw_adapter *p
 			}
 		}
 	}
-	_func_exit_;
+
 }
 
 #endif
@@ -654,7 +654,7 @@ void LeaveAllPowerSaveMode(struct rtw_ad
 {
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 
-	_func_enter_;
+
 
 	/* DBG_8192D("%s.....\n",__func__); */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {	/* connect */
@@ -682,7 +682,7 @@ void LeaveAllPowerSaveMode(struct rtw_ad
 		}
 	}
 
-	_func_exit_;
+
 }
 
 #ifdef CONFIG_LPS_LCLK
@@ -698,7 +698,7 @@ void cpwm_int_hdl(struct rtw_adapter *pa
 {
 	struct pwrctrl_priv *pwrpriv;
 
-	_func_enter_;
+
 
 	pwrpriv = &padapter->pwrctrlpriv;
 	pwrpriv->cpwm = PS_STATE(preportpwrstate->state);
@@ -716,7 +716,7 @@ exit:
 	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
 		 ("cpwm_int_hdl: cpwm=0x%02x\n", pwrpriv->cpwm));
 
-	_func_exit_;
+
 }
 
 static inline void register_task_alive(struct pwrctrl_priv *pwrctrl, u32 tag)
@@ -748,7 +748,7 @@ s32 rtw_register_tx_alive(struct rtw_ada
 	s32 res;
 	struct pwrctrl_priv *pwrctrl;
 
-	_func_enter_;
+
 
 	res = _SUCCESS;
 	pwrctrl = &padapter->pwrctrlpriv;
@@ -771,7 +771,7 @@ s32 rtw_register_tx_alive(struct rtw_ada
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-	_func_exit_;
+
 
 	return res;
 }
@@ -794,7 +794,7 @@ s32 rtw_register_cmd_alive(struct rtw_ad
 	s32 res;
 	struct pwrctrl_priv *pwrctrl;
 
-	_func_enter_;
+
 
 	res = _SUCCESS;
 	pwrctrl = &padapter->pwrctrlpriv;
@@ -817,7 +817,7 @@ s32 rtw_register_cmd_alive(struct rtw_ad
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-	_func_exit_;
+
 
 	return res;
 }
@@ -835,7 +835,7 @@ s32 rtw_register_rx_alive(struct rtw_ada
 {
 	struct pwrctrl_priv *pwrctrl;
 
-	_func_enter_;
+
 
 	pwrctrl = &padapter->pwrctrlpriv;
 
@@ -848,7 +848,7 @@ s32 rtw_register_rx_alive(struct rtw_ada
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-	_func_exit_;
+
 
 	return _SUCCESS;
 }
@@ -866,7 +866,7 @@ s32 rtw_register_evt_alive(struct rtw_ad
 {
 	struct pwrctrl_priv *pwrctrl;
 
-	_func_enter_;
+
 
 	pwrctrl = &padapter->pwrctrlpriv;
 
@@ -879,7 +879,7 @@ s32 rtw_register_evt_alive(struct rtw_ad
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-	_func_exit_;
+
 
 	return _SUCCESS;
 }
@@ -895,7 +895,7 @@ void rtw_unregister_tx_alive(struct rtw_
 {
 	struct pwrctrl_priv *pwrctrl;
 
-	_func_enter_;
+
 
 	pwrctrl = &padapter->pwrctrlpriv;
 
@@ -915,7 +915,7 @@ void rtw_unregister_tx_alive(struct rtw_
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-	_func_exit_;
+
 }
 
 /*
@@ -929,7 +929,7 @@ void rtw_unregister_cmd_alive(struct rtw
 {
 	struct pwrctrl_priv *pwrctrl;
 
-	_func_enter_;
+
 
 	pwrctrl = &padapter->pwrctrlpriv;
 
@@ -949,7 +949,7 @@ void rtw_unregister_cmd_alive(struct rtw
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-	_func_exit_;
+
 }
 
 /*
@@ -959,7 +959,7 @@ void rtw_unregister_rx_alive(struct rtw_
 {
 	struct pwrctrl_priv *pwrctrl;
 
-	_func_enter_;
+
 
 	pwrctrl = &padapter->pwrctrlpriv;
 
@@ -973,14 +973,14 @@ void rtw_unregister_rx_alive(struct rtw_
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-	_func_exit_;
+
 }
 
 void rtw_unregister_evt_alive(struct rtw_adapter *padapter)
 {
 	struct pwrctrl_priv *pwrctrl;
 
-	_func_enter_;
+
 
 	pwrctrl = &padapter->pwrctrlpriv;
 
@@ -992,7 +992,7 @@ void rtw_unregister_evt_alive(struct rtw
 
 	_exit_pwrlock(&pwrctrl->lock);
 
-	_func_exit_;
+
 }
 #endif /* CONFIG_LPS_LCLK */
 
@@ -1004,7 +1004,7 @@ void rtw_init_pwrctrl_priv(struct rtw_ad
 {
 	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 
-	_func_enter_;
+
 
 	_init_pwrlock(&pwrctrlpriv->lock);
 	pwrctrlpriv->rf_pwrstate = rf_on;
@@ -1057,14 +1057,14 @@ void rtw_init_pwrctrl_priv(struct rtw_ad
 	rtw_register_early_suspend(pwrctrlpriv);
 #endif /* CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER */
 
-	_func_exit_;
+
 }
 
 void rtw_free_pwrctrl_priv(struct rtw_adapter *adapter)
 {
 	struct pwrctrl_priv *pwrctrlpriv = &adapter->pwrctrlpriv;
 
-	_func_enter_;
+
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
 	if (pwrctrlpriv->rtw_workqueue) {
 		flush_workqueue(pwrctrlpriv->rtw_workqueue);
@@ -1078,7 +1078,7 @@ void rtw_free_pwrctrl_priv(struct rtw_ad
 
 	_free_pwrlock(&pwrctrlpriv->lock);
 
-	_func_exit_;
+
 }
 
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -33,7 +33,7 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 
 void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
 {
-	_func_enter_;
+
 
 	memset((u8 *)psta_recvpriv, 0, sizeof(struct sta_recv_priv));
 
@@ -44,7 +44,7 @@ void _rtw_init_sta_recv_priv(struct sta_
 
 	_rtw_init_queue(&psta_recvpriv->defrag_q);
 
-	_func_exit_;
+
 }
 
 int _rtw_init_recv_priv(struct recv_priv *precvpriv,
@@ -56,7 +56,7 @@ int _rtw_init_recv_priv(struct recv_priv
 
 	int res = _SUCCESS;
 
-	_func_enter_;
+
 
 	_rtw_spinlock_init(&precvpriv->lock);
 
@@ -114,7 +114,7 @@ int _rtw_init_recv_priv(struct recv_priv
 
 exit:
 
-	_func_exit_;
+
 
 	return res;
 }
@@ -141,7 +141,7 @@ void _rtw_free_recv_priv(struct recv_pri
 {
 	struct rtw_adapter *padapter = precvpriv->adapter;
 
-	_func_enter_;
+
 
 	rtw_free_uc_swdec_pending_queue(padapter);
 
@@ -154,7 +154,7 @@ void _rtw_free_recv_priv(struct recv_pri
 
 	rtw_hal_free_recv_priv(padapter);
 
-	_func_exit_;
+
 }
 
 struct recv_frame_hdr *_rtw_alloc_recvframe(struct __queue *pfree_recv_queue)
@@ -163,7 +163,7 @@ struct recv_frame_hdr *_rtw_alloc_recvfr
 	struct list_head *plist, *phead;
 	struct rtw_adapter *padapter;
 	struct recv_priv *precvpriv;
-	_func_enter_;
+
 
 	if (_rtw_queue_empty(pfree_recv_queue) == true) {
 		hdr = NULL;
@@ -183,7 +183,7 @@ struct recv_frame_hdr *_rtw_alloc_recvfr
 		}
 	}
 
-	_func_exit_;
+
 
 	return hdr;
 }
@@ -216,7 +216,7 @@ int rtw_free_recvframe(struct recv_frame
 	struct rtw_adapter *padapter = precvframe->adapter;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 
-	_func_enter_;
+
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->adapter_type > PRIMARY_ADAPTER) {
@@ -249,7 +249,7 @@ int rtw_free_recvframe(struct recv_frame
 
 	spin_unlock_bh(&pfree_recv_queue->lock);
 
-	_func_exit_;
+
 
 	return _SUCCESS;
 }
@@ -259,7 +259,7 @@ int _rtw_enqueue_recvframe(struct recv_f
 	struct rtw_adapter *padapter = precvframe->adapter;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 
-	_func_enter_;
+
 
 	/* INIT_LIST_HEAD(&(precvframe->list)); */
 	rtw_list_delete(&(precvframe->list));
@@ -271,7 +271,7 @@ int _rtw_enqueue_recvframe(struct recv_f
 			precvpriv->free_recvframe_cnt++;
 	}
 
-	_func_exit_;
+
 
 	return _SUCCESS;
 }
@@ -301,7 +301,7 @@ void rtw_free_recvframe_queue(struct __q
 	struct recv_frame_hdr *precvframe;
 	struct list_head *plist, *phead;
 
-	_func_enter_;
+
 	_rtw_spinlock(&pframequeue->lock);
 
 	phead = get_list_head(pframequeue);
@@ -317,7 +317,7 @@ void rtw_free_recvframe_queue(struct __q
 
 	_rtw_spinunlock(&pframequeue->lock);
 
-	_func_exit_;
+
 }
 
 u32 rtw_free_uc_swdec_pending_queue(struct rtw_adapter *adapter)
@@ -404,7 +404,7 @@ static int recvframe_chkmic(struct rtw_a
 
 	struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
-	_func_enter_;
+
 
 	stainfo = rtw_get_stainfo(&adapter->stapriv, &prxattrib->ta[0]);
 
@@ -576,7 +576,7 @@ static int recvframe_chkmic(struct rtw_a
 		recvframe_pull_tail(precvframe, 8);
 	}
 exit:
-	_func_exit_;
+
 	return res;
 }
 
@@ -588,7 +588,7 @@ static struct recv_frame_hdr *decryptor(
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct recv_frame_hdr *return_packet = precv_frame;
 	u32 res = _SUCCESS;
-	_func_enter_;
+
 
 	RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
 		 ("prxstat->decrypted=%x prxattrib->encrypt = 0x%03x\n",
@@ -673,7 +673,7 @@ static struct recv_frame_hdr *decryptor(
 		return_packet = NULL;
 	}
 
-	_func_exit_;
+
 
 	return return_packet;
 }
@@ -693,7 +693,7 @@ static struct recv_frame_hdr *portctrl(s
 	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
 	__be16 be_tmp;
 
-	_func_enter_;
+
 
 	pstapriv = &adapter->stapriv;
 	ptr = get_recvframe_data(precv_frame);
@@ -764,7 +764,7 @@ static struct recv_frame_hdr *portctrl(s
 		prtnframe = precv_frame;
 	}
 
-	_func_exit_;
+
 
 	return prtnframe;
 }
@@ -777,7 +777,7 @@ static int recv_decache(struct recv_fram
 	u16 seq_ctrl = ((precv_frame->attrib.seq_num & 0xffff) << 4) |
 	    (precv_frame->attrib.frag_num & 0xf);
 
-	_func_enter_;
+
 
 	if (tid > 15) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
@@ -799,7 +799,7 @@ static int recv_decache(struct recv_fram
 
 	prxcache->tid_rxseq[tid] = seq_ctrl;
 
-	_func_exit_;
+
 
 	return _SUCCESS;
 }
@@ -1032,7 +1032,7 @@ static int sta2sta_data_frame(struct rtw
 	u8 *pframe_body = psnap_type + ETH_TYPE_LEN + PAYLOAD_TYPE_LEN;
 #endif /* CONFIG_TDLS */
 
-	_func_enter_;
+
 
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
 	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
@@ -1207,7 +1207,7 @@ static int sta2sta_data_frame(struct rtw
 	}
 
 exit:
-	_func_exit_;
+
 	return ret;
 }
 
@@ -1223,7 +1223,7 @@ static int ap2sta_data_frame(struct rtw_
 	u8 *myhwaddr = myid(&adapter->eeprompriv);
 	int bmcast = IS_MCAST(pattrib->dst);
 
-	_func_enter_;
+
 
 	if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) &&
 	    (check_fwstate(pmlmepriv, _FW_LINKED) == true ||
@@ -1362,7 +1362,7 @@ static int ap2sta_data_frame(struct rtw_
 
 exit:
 
-	_func_exit_;
+
 
 	return ret;
 }
@@ -1377,7 +1377,7 @@ static int sta2ap_data_frame(struct rtw_
 	unsigned char *mybssid = get_bssid(pmlmepriv);
 	int ret = _SUCCESS;
 
-	_func_enter_;
+
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
 		/* For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR */
@@ -1429,7 +1429,7 @@ static int sta2ap_data_frame(struct rtw_
 
 exit:
 
-	_func_exit_;
+
 
 	return ret;
 }
@@ -1629,7 +1629,7 @@ static int validate_recv_data_frame(stru
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
 #endif /* CONFIG_TDLS */
 
-	_func_enter_;
+
 
 	bretry = GetRetry(ptr);
 	pda = get_da(ptr);
@@ -1756,7 +1756,7 @@ static int validate_recv_data_frame(stru
 
 exit:
 
-	_func_exit_;
+
 
 	return ret;
 }
@@ -1784,7 +1784,7 @@ static int validate_recv_frame(struct rt
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
 #endif /* CONFIG_TDLS */
 
-	_func_enter_;
+
 
 #ifdef CONFIG_FIND_BEST_CHANNEL
 	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {
@@ -1862,7 +1862,7 @@ static int validate_recv_frame(struct rt
 
 exit:
 
-	_func_exit_;
+
 
 	return retval;
 }
@@ -1885,7 +1885,7 @@ static int wlanhdr_to_ethhdr(struct recv
 	u8 *ptr = get_recvframe_data(precvframe);	/*  point to frame_ctrl field */
 	struct rx_pkt_attrib *pattrib = &precvframe->attrib;
 
-	_func_enter_;
+
 
 	if (pattrib->encrypt)
 		recvframe_pull_tail(precvframe, pattrib->icv_len);
@@ -1948,7 +1948,7 @@ static int wlanhdr_to_ethhdr(struct recv
 		memcpy(ptr + 12, &be_tmp, 2);
 	}
 
-	_func_exit_;
+
 	return ret;
 }
 
@@ -1963,7 +1963,7 @@ static struct recv_frame_hdr *recvframe_
 	struct recv_frame_hdr *prframe, *pnextrframe;
 	struct __queue *pfree_recv_queue;
 
-	_func_enter_;
+
 
 	curfragnum = 0;
 	pfree_recv_queue = &adapter->recvpriv.free_recv_queue;
@@ -2031,7 +2031,7 @@ static struct recv_frame_hdr *recvframe_
 	RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
 		 ("Performance defrag!!!!!\n"));
 
-	_func_exit_;
+
 
 	return prframe;
 }
@@ -2050,7 +2050,7 @@ struct recv_frame_hdr *recvframe_chk_def
 	struct recv_frame_hdr *prtnframe = NULL;
 	struct __queue *pfree_recv_queue, *pdefrag_q;
 
-	_func_enter_;
+
 
 	pstapriv = &padapter->stapriv;
 
@@ -2150,7 +2150,7 @@ struct recv_frame_hdr *recvframe_chk_def
 		}
 	}
 
-	_func_exit_;
+
 
 	return prtnframe;
 }
@@ -2955,7 +2955,7 @@ s32 rtw_recv_entry(struct recv_frame_hdr
 	struct recv_priv *precvpriv;
 	s32 ret = _SUCCESS;
 
-	_func_enter_;
+
 
 	padapter = precvframe->adapter;
 
@@ -2970,13 +2970,13 @@ s32 rtw_recv_entry(struct recv_frame_hdr
 
 	precvpriv->rx_pkts++;
 
-	_func_exit_;
+
 
 	return ret;
 
 _recv_entry_drop:
 
-	_func_exit_;
+
 
 	return ret;
 }
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -39,7 +39,7 @@ static void arcfour_init(struct arc4cont
 	u8 *state;
 	u32 counter;
 
-	_func_enter_;
+
 	state = parc4ctx->state;
 	parc4ctx->x = 0;
 	parc4ctx->y = 0;
@@ -56,7 +56,7 @@ static void arcfour_init(struct arc4cont
 		if (++keyindex >= key_len)
 			keyindex = 0;
 	}
-	_func_exit_;
+
 }
 
 static u32 arcfour_byte(struct arc4context *parc4ctx)
@@ -66,7 +66,7 @@ static u32 arcfour_byte(struct arc4conte
 	u32 sx, sy;
 	u8 *state;
 
-	_func_enter_;
+
 	state = parc4ctx->state;
 	x = (parc4ctx->x + 1) & 0xff;
 	sx = state[x];
@@ -76,7 +76,7 @@ static u32 arcfour_byte(struct arc4conte
 	parc4ctx->y = y;
 	state[y] = (u8) sx;
 	state[x] = (u8) sy;
-	_func_exit_;
+
 	return state[(sx + sy) & 0xff];
 }
 
@@ -85,10 +85,10 @@ static void arcfour_encrypt(struct arc4c
 {
 	u32 i;
 
-	_func_enter_;
+
 	for (i = 0; i < len; i++)
 		dest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);
-	_func_exit_;
+
 }
 
 static int bcrc32initialized;
@@ -104,9 +104,9 @@ static u8 crc32_reverseBit(u8 data)
 
 static void crc32_init(void)
 {
-	_func_enter_;
+
 	if (bcrc32initialized == 1) {
-		goto exit;
+		return;
 	} else {
 		int i, j;
 		u32 c;
@@ -130,8 +130,6 @@ static void crc32_init(void)
 		}
 		bcrc32initialized = 1;
 	}
-exit:
-	_func_exit_;
 }
 
 static __le32 getcrc32(u8 *buf, int len)
@@ -139,7 +137,7 @@ static __le32 getcrc32(u8 *buf, int len)
 	u8 *p;
 	u32 crc;
 
-	_func_enter_;
+
 	if (bcrc32initialized == 0)
 		crc32_init();
 
@@ -147,7 +145,7 @@ static __le32 getcrc32(u8 *buf, int len)
 
 	for (p = buf; len > 0; ++p, --len)
 		crc = crc32_table[(crc ^ *p) & 0xff] ^ (crc >> 8);
-	_func_exit_;
+
 	return cpu_to_le32(~crc);	/* transmit complement, per CRC-32 spec */
 }
 
@@ -167,7 +165,7 @@ void rtw_wep_encrypt(struct rtw_adapter
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
-	_func_enter_;
+
 	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
 		return;
 
@@ -224,7 +222,7 @@ void rtw_wep_encrypt(struct rtw_adapter
 		}
 	}
 
-	_func_exit_;
+
 }
 
 void rtw_wep_decrypt(struct rtw_adapter *padapter, u8 *precvframe)
@@ -240,7 +238,7 @@ void rtw_wep_decrypt(struct rtw_adapter
 	    &(((struct recv_frame_hdr *)precvframe)->attrib);
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 
-	_func_enter_;
+
 
 	pframe =
 	    (unsigned char *)((struct recv_frame_hdr *)precvframe)->rx_data;
@@ -281,7 +279,7 @@ void rtw_wep_decrypt(struct rtw_adapter
 				  payload[length - 4]));
 		}
 	}
-	_func_exit_;
+
 	return;
 }
 
@@ -292,10 +290,10 @@ static u32 secmicgetuint32(u8 *p)
 {
 	s32 i;
 	u32 res = 0;
-	_func_enter_;
+
 	for (i = 0; i < 4; i++)
 		res |= ((u32) (*p++)) << (8 * i);
-	_func_exit_;
+
 	return res;
 }
 
@@ -303,39 +301,39 @@ static void secmicputuint32(u8 *p, u32 v
 /*  Convert from Us4Byte32 to Byte[] in a portable way */
 {
 	long i;
-	_func_enter_;
+
 	for (i = 0; i < 4; i++) {
 		*p++ = (u8) (val & 0xff);
 		val >>= 8;
 	}
-	_func_exit_;
+
 }
 
 static void secmicclear(struct mic_data *pmicdata)
 {
 /*  Reset the state to the empty message. */
-	_func_enter_;
+
 	pmicdata->L = pmicdata->K0;
 	pmicdata->R = pmicdata->K1;
 	pmicdata->nBytesInM = 0;
 	pmicdata->M = 0;
-	_func_exit_;
+
 }
 
 void rtw_secmicsetkey(struct mic_data *pmicdata, u8 *key)
 {
 	/*  Set the key */
-	_func_enter_;
+
 	pmicdata->K0 = secmicgetuint32(key);
 	pmicdata->K1 = secmicgetuint32(key + 4);
 	/*  and reset the message */
 	secmicclear(pmicdata);
-	_func_exit_;
+
 }
 
 void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b)
 {
-	_func_enter_;
+
 	/*  Append the byte to our word-sized buffer */
 	pmicdata->M |= ((unsigned long)b) << (8 * pmicdata->nBytesInM);
 	pmicdata->nBytesInM++;
@@ -356,23 +354,23 @@ void rtw_secmicappendbyte(struct mic_dat
 		pmicdata->M = 0;
 		pmicdata->nBytesInM = 0;
 	}
-	_func_exit_;
+
 }
 
 void rtw_secmicappend(struct mic_data *pmicdata, u8 *src, u32 nbytes)
 {
-	_func_enter_;
+
 	/*  This is simple */
 	while (nbytes > 0) {
 		rtw_secmicappendbyte(pmicdata, *src++);
 		nbytes--;
 	}
-	_func_exit_;
+
 }
 
 void rtw_secgetmic(struct mic_data *pmicdata, u8 *dst)
 {
-	_func_enter_;
+
 	/*  Append the minimum padding */
 	rtw_secmicappendbyte(pmicdata, 0x5a);
 	rtw_secmicappendbyte(pmicdata, 0);
@@ -387,7 +385,7 @@ void rtw_secgetmic(struct mic_data *pmic
 	secmicputuint32(dst + 4, pmicdata->R);
 	/*  Reset to the empty message. */
 	secmicclear(pmicdata);
-	_func_exit_;
+
 }
 
 void rtw_seccalctkipmic(u8 *key, u8 *header, u8 *data, u32 data_len,
@@ -395,7 +393,7 @@ void rtw_seccalctkipmic(u8 *key, u8 *hea
 {
 	struct mic_data micdata;
 	u8 priority[4] = { 0x0, 0x0, 0x0, 0x0 };
-	_func_enter_;
+
 	rtw_secmicsetkey(&micdata, key);
 	priority[0] = pri;
 
@@ -418,7 +416,7 @@ void rtw_seccalctkipmic(u8 *key, u8 *hea
 	rtw_secmicappend(&micdata, data, data_len);
 
 	rtw_secgetmic(&micdata, mic_code);
-	_func_exit_;
+
 }
 
 /* macros for extraction/creation of unsigned char/unsigned short values  */
@@ -535,7 +533,7 @@ static const unsigned short Sbox1[2][256
 static void phase1(u16 *p1k, const u8 *tk, const u8 *ta, u32 iv32)
 {
 	int i;
-	_func_enter_;
+
 	/* Initialize the 80 bits of P1K[] from IV32 and TA[0..5]     */
 	p1k[0] = Lo16(iv32);
 	p1k[1] = Hi16(iv32);
@@ -553,7 +551,7 @@ static void phase1(u16 *p1k, const u8 *t
 		p1k[4] += _S_(p1k[3] ^ TK16((i & 1) + 0));
 		p1k[4] += (unsigned short)i;	/* avoid "slide attacks" */
 	}
-	_func_exit_;
+
 }
 
 /*
@@ -583,7 +581,7 @@ static void phase2(u8 *rc4key, const u8
 {
 	int i;
 	u16 PPK[6];		/* temporary key for mixing    */
-	_func_enter_;
+
 	/* Note: all adds in the PPK[] equations below are mod 2**16         */
 	for (i = 0; i < 5; i++)
 		PPK[i] = p1k[i];	/* first, copy P1K to PPK      */
@@ -620,7 +618,7 @@ static void phase2(u8 *rc4key, const u8
 		rc4key[4 + 2 * i] = Lo8(PPK[i]);
 		rc4key[5 + 2 * i] = Hi8(PPK[i]);
 	}
-	_func_exit_;
+
 }
 
 /* The hlen isn't include the IV */
@@ -641,7 +639,7 @@ u32 rtw_tkip_encrypt(struct rtw_adapter
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	u32 res = _SUCCESS;
 
-	_func_enter_;
+
 	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
 		return _FAIL;
 
@@ -731,7 +729,7 @@ u32 rtw_tkip_encrypt(struct rtw_adapter
 			res = _FAIL;
 		}
 	}
-	_func_exit_;
+
 	return res;
 }
 
@@ -754,7 +752,7 @@ u32 rtw_tkip_decrypt(struct rtw_adapter
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	u32 res = _SUCCESS;
 
-	_func_enter_;
+
 	pframe =
 	    (unsigned char *)((struct recv_frame_hdr *)precvframe)->rx_data;
 
@@ -823,7 +821,7 @@ u32 rtw_tkip_decrypt(struct rtw_adapter
 			res = _FAIL;
 		}
 	}
-	_func_exit_;
+
 exit:
 	return res;
 }
@@ -906,19 +904,19 @@ static void aes128k128d(u8 *key, u8 *dat
 static void xor_128(u8 *a, u8 *b, u8 *out)
 {
 	int i;
-	_func_enter_;
+
 	for (i = 0; i < 16; i++)
 		out[i] = a[i] ^ b[i];
-	_func_exit_;
+
 }
 
 static void xor_32(u8 *a, u8 *b, u8 *out)
 {
 	int i;
-	_func_enter_;
+
 	for (i = 0; i < 4; i++)
 		out[i] = a[i] ^ b[i];
-	_func_exit_;
+
 }
 
 static u8 sbox(u8 a)
@@ -934,7 +932,7 @@ static void next_key(u8 *key, int round)
 		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
 		0x1b, 0x36, 0x36, 0x36
 	};
-	_func_enter_;
+
 	sbox_key[0] = sbox(key[13]);
 	sbox_key[1] = sbox(key[14]);
 	sbox_key[2] = sbox(key[15]);
@@ -948,21 +946,21 @@ static void next_key(u8 *key, int round)
 	xor_32(&key[4], &key[0], &key[4]);
 	xor_32(&key[8], &key[4], &key[8]);
 	xor_32(&key[12], &key[8], &key[12]);
-	_func_exit_;
+
 }
 
 static void byte_sub(u8 *in, u8 *out)
 {
 	int i;
-	_func_enter_;
+
 	for (i = 0; i < 16; i++)
 		out[i] = sbox(in[i]);
-	_func_exit_;
+
 }
 
 static void shift_row(u8 *in, u8 *out)
 {
-	_func_enter_;
+
 	out[0] = in[0];
 	out[1] = in[5];
 	out[2] = in[10];
@@ -979,7 +977,7 @@ static void shift_row(u8 *in, u8 *out)
 	out[13] = in[1];
 	out[14] = in[6];
 	out[15] = in[11];
-	_func_exit_;
+
 }
 
 static void mix_column(u8 *in, u8 *out)
@@ -993,7 +991,7 @@ static void mix_column(u8 *in, u8 *out)
 	u8 rotr[4];
 	u8 temp[4];
 	u8 tempb[4];
-	_func_enter_;
+
 	for (i = 0; i < 4; i++) {
 		if ((in[i] & 0x80) == 0x80)
 			add1b[i] = 0x1b;
@@ -1037,7 +1035,7 @@ static void mix_column(u8 *in, u8 *out)
 	xor_32(add1bf7, rotr, temp);
 	xor_32(swap_halfs, rotl, tempb);
 	xor_32(temp, tempb, out);
-	_func_exit_;
+
 }
 
 static void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)
@@ -1047,7 +1045,7 @@ static void aes128k128d(u8 *key, u8 *dat
 	u8 intermediatea[16];
 	u8 intermediateb[16];
 	u8 round_key[16];
-	_func_enter_;
+
 	for (i = 0; i < 16; i++)
 		round_key[i] = key[i];
 
@@ -1071,7 +1069,7 @@ static void aes128k128d(u8 *key, u8 *dat
 			next_key(round_key, round);
 		}
 	}
-	_func_exit_;
+
 }
 
 /************************************************/
@@ -1084,7 +1082,7 @@ static void construct_mic_iv(u8 *mic_iv,
 			     u8 *mpdu, uint payload_length, u8 *pn_vector)
 {
 	int i;
-	_func_enter_;
+
 	mic_iv[0] = 0x59;
 	if (qc_exists && a4_exists)
 		mic_iv[1] = mpdu[30] & 0x0f;	/* QoS_TC           */
@@ -1103,7 +1101,7 @@ static void construct_mic_iv(u8 *mic_iv,
 #endif
 	mic_iv[14] = (unsigned char)(payload_length / 256);
 	mic_iv[15] = (unsigned char)(payload_length % 256);
-	_func_exit_;
+
 }
 
 /************************************************/
@@ -1114,7 +1112,7 @@ static void construct_mic_iv(u8 *mic_iv,
 static void construct_mic_header1(u8 *mic_header1,
 				  int header_length, u8 *mpdu)
 {
-	_func_enter_;
+
 	mic_header1[0] = (u8) ((header_length - 2) / 256);
 	mic_header1[1] = (u8) ((header_length - 2) % 256);
 	mic_header1[2] = mpdu[0] & 0xcf;	/* Mute CF poll & CF ack bits */
@@ -1131,7 +1129,7 @@ static void construct_mic_header1(u8 *mi
 	mic_header1[13] = mpdu[13];
 	mic_header1[14] = mpdu[14];
 	mic_header1[15] = mpdu[15];
-	_func_exit_;
+
 }
 
 /************************************************/
@@ -1143,7 +1141,7 @@ static void construct_mic_header2(u8 *mi
 				  u8 *mpdu, int a4_exists, int qc_exists)
 {
 	int i;
-	_func_enter_;
+
 	for (i = 0; i < 16; i++)
 		mic_header2[i] = 0x00;
 
@@ -1175,7 +1173,7 @@ static void construct_mic_header2(u8 *mi
 		mic_header2[15] = mpdu[31] & 0x00;
 	}
 
-	_func_exit_;
+
 }
 
 /************************************************/
@@ -1189,7 +1187,7 @@ static void construct_ctr_preload(u8 *ct
 				  u8 *mpdu, u8 *pn_vector, int c)
 {
 	int i = 0;
-	_func_enter_;
+
 	for (i = 0; i < 16; i++)
 		ctr_preload[i] = 0x00;
 	i = 0;
@@ -1211,7 +1209,7 @@ static void construct_ctr_preload(u8 *ct
 #endif
 	ctr_preload[14] = (unsigned char)(c / 256);	/* Ctr */
 	ctr_preload[15] = (unsigned char)(c % 256);
-	_func_exit_;
+
 }
 
 /************************************/
@@ -1221,10 +1219,10 @@ static void construct_ctr_preload(u8 *ct
 static void bitwise_xor(u8 *ina, u8 *inb, u8 *out)
 {
 	int i;
-	_func_enter_;
+
 	for (i = 0; i < 16; i++)
 		out[i] = ina[i] ^ inb[i];
-	_func_exit_;
+
 }
 
 static int aes_cipher(u8 *key, uint hdrlen, u8 *pframe, uint plen)
@@ -1246,7 +1244,7 @@ static int aes_cipher(u8 *key, uint hdrl
 	uint frtype = GetFrameType(pframe);
 	uint frsubtype = GetFrameSubType(pframe);
 
-	_func_enter_;
+
 	frsubtype = frsubtype >> 4;
 
 	memset((void *)mic_iv, 0, 16);
@@ -1368,7 +1366,7 @@ static int aes_cipher(u8 *key, uint hdrl
 	bitwise_xor(aes_out, padded_buffer, chain_buffer);
 	for (j = 0; j < 8; j++)
 		pframe[payload_index++] = chain_buffer[j];
-	_func_exit_;
+
 	return _SUCCESS;
 }
 
@@ -1386,7 +1384,7 @@ u32 rtw_aes_encrypt(struct rtw_adapter *
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	u32 res = _SUCCESS;
 
-	_func_enter_;
+
 
 	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
 		return _FAIL;
@@ -1464,7 +1462,7 @@ u32 rtw_aes_encrypt(struct rtw_adapter *
 			res = _FAIL;
 		}
 	}
-_func_exit_;
+
 	return res;
 }
 
@@ -1487,7 +1485,7 @@ static int aes_decipher(u8 *key, uint hd
 	u8 mic[8];
 	uint frtype = GetFrameType(pframe);
 	uint frsubtype = GetFrameSubType(pframe);
-	_func_enter_;
+
 	frsubtype = frsubtype >> 4;
 
 	memset((void *)mic_iv, 0, 16);
@@ -1686,7 +1684,7 @@ static int aes_decipher(u8 *key, uint hd
 		DBG_8192D("error packet header\n");
 	}
 
-	_func_exit_;
+
 	return res;
 }
 
@@ -1702,7 +1700,7 @@ u32 rtw_aes_decrypt(struct rtw_adapter *
 	    &((struct recv_frame_hdr *)precvframe)->attrib;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	u32 res = _SUCCESS;
-	_func_enter_;
+
 	pframe =
 	    (unsigned char *)((struct recv_frame_hdr *)precvframe)->rx_data;
 	/* 4 start to encrypt each fragment */
@@ -1753,7 +1751,7 @@ u32 rtw_aes_decrypt(struct rtw_adapter *
 			res = _FAIL;
 		}
 	}
-	_func_exit_;
+
 exit:
 	return res;
 }
@@ -2586,7 +2584,7 @@ void rtw_use_tkipkey_handler(void *Funct
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)FunctionContext;
 
-	_func_enter_;
+
 
 	RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
 		 ("^^^rtw_use_tkipkey_handler ^^^\n"));
@@ -2597,5 +2595,5 @@ void rtw_use_tkipkey_handler(void *Funct
 		 ("^^^rtw_use_tkipkey_handler padapter->securitypriv.busetkipkey =%d^^^\n",
 		  padapter->securitypriv.busetkipkey));
 
-	_func_exit_;
+
 }
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -26,7 +26,6 @@
 
 static void _rtw_init_stainfo(struct sta_info *psta)
 {
-_func_enter_;
 
 	memset((u8 *)psta, 0, sizeof(struct sta_info));
 
@@ -54,7 +53,6 @@ _func_enter_;
 
 	psta->bpairwise_key_installed = false;
 
-
 #ifdef CONFIG_NATIVEAP_MLME
 	psta->nonerp_set = 0;
 	psta->no_short_slot_time_set = 0;
@@ -68,7 +66,6 @@ _func_enter_;
 	psta->keep_alive_trycnt = 0;
 #endif	/*  CONFIG_AP_MODE */
 
-_func_exit_;
 }
 
 u32	_rtw_init_sta_priv(struct	sta_priv *pstapriv)
@@ -76,8 +73,6 @@ u32	_rtw_init_sta_priv(struct	sta_priv *
 	struct sta_info *psta;
 	s32 i;
 
-_func_enter_;
-
 	pstapriv->pallocated_stainfo_buf = vzalloc(sizeof(struct sta_info) *
 						   NUM_STA + 4);
 
@@ -97,7 +92,6 @@ _func_enter_;
 
 	psta = (struct sta_info *)(pstapriv->pstainfo_buf);
 
-
 	for (i = 0; i < NUM_STA; i++) {
 		_rtw_init_stainfo(psta);
 
@@ -108,8 +102,6 @@ _func_enter_;
 		psta++;
 	}
 
-
-
 #ifdef CONFIG_AP_MODE
 
 	pstapriv->sta_dz_bitmap = 0;
@@ -133,8 +125,6 @@ _func_enter_;
 
 #endif
 
-_func_exit_;
-
 	return _SUCCESS;
 }
 
@@ -162,7 +152,6 @@ inline struct sta_info *rtw_get_stainfo_
 
 static void _rtw_free_sta_xmit_priv_lock(struct sta_xmit_priv *psta_xmitpriv)
 {
-_func_enter_;
 
 	_rtw_spinlock_free(&psta_xmitpriv->lock);
 
@@ -170,20 +159,19 @@ _func_enter_;
 	_rtw_spinlock_free(&(psta_xmitpriv->bk_q.sta_pending.lock));
 	_rtw_spinlock_free(&(psta_xmitpriv->vi_q.sta_pending.lock));
 	_rtw_spinlock_free(&(psta_xmitpriv->vo_q.sta_pending.lock));
-_func_exit_;
+
 }
 
 static void _rtw_free_sta_recv_priv_lock(struct sta_recv_priv *psta_recvpriv)
 {
-_func_enter_;
+
 	_rtw_spinlock_free(&psta_recvpriv->lock);
 	_rtw_spinlock_free(&(psta_recvpriv->defrag_q.lock));
-_func_exit_;
+
 }
 
 static void rtw_mfree_stainfo(struct sta_info *psta)
 {
-_func_enter_;
 
 	if (&psta->lock != NULL)
 		_rtw_spinlock_free(&psta->lock);
@@ -191,7 +179,6 @@ _func_enter_;
 	_rtw_free_sta_xmit_priv_lock(&psta->sta_xmitpriv);
 	_rtw_free_sta_recv_priv_lock(&psta->sta_recvpriv);
 
-_func_exit_;
 }
 
 /*  this function is used to free the memory of lock || sema for all stainfos */
@@ -200,8 +187,6 @@ static void rtw_mfree_all_stainfo(struct
 	struct list_head *plist, *phead;
 	struct sta_info *psta = NULL;
 
-_func_enter_;
-
 	spin_lock_bh(&pstapriv->sta_hash_lock);
 
 	phead = get_list_head(&pstapriv->free_sta_queue);
@@ -216,7 +201,6 @@ _func_enter_;
 
 	spin_unlock_bh(&pstapriv->sta_hash_lock);
 
-_func_exit_;
 }
 
 static void rtw_mfree_sta_priv_lock(struct	sta_priv *pstapriv)
@@ -247,7 +231,6 @@ u32	_rtw_free_sta_priv(struct	sta_priv *
 	struct recv_reorder_ctrl *reorder;
 	int	index;
 
-_func_enter_;
 	if (pstapriv) {
 		/*	delete all reordering_ctrl_timer		*/
 		spin_lock_bh(&pstapriv->sta_hash_lock);
@@ -275,7 +258,6 @@ _func_enter_;
 			vfree(pstapriv->pallocated_stainfo_buf);
 	}
 
-_func_exit_;
 	return _SUCCESS;
 }
 
@@ -289,8 +271,6 @@ struct	sta_info *rtw_alloc_stainfo(struc
 	int i = 0;
 	u16  wRxSeqInitialValue = 0xffff;
 
-_func_enter_;
-
 	pfree_sta_queue = &pstapriv->free_sta_queue;
 
 	spin_lock_bh(&(pfree_sta_queue->lock));
@@ -387,12 +367,9 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return psta;
 }
 
-
 /*  using pstapriv->sta_hash_lock to protect */
 u32	rtw_free_stainfo(struct rtw_adapter *padapter, struct sta_info *psta)
 {
@@ -403,15 +380,11 @@ u32	rtw_free_stainfo(struct rtw_adapter
 	struct	xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 	struct	sta_priv *pstapriv = &padapter->stapriv;
 
-
-_func_enter_;
-
 	if (psta == NULL)
 		goto exit;
 
 	pfree_sta_queue = &pstapriv->free_sta_queue;
 
-
 	pstaxmitpriv = &psta->sta_xmitpriv;
 
 	spin_lock_bh(&pxmitpriv->lock);
@@ -490,7 +463,6 @@ _func_enter_;
 		spin_unlock_bh(&ppending_recvframe_queue->lock);
 	}
 
-
 #ifdef CONFIG_AP_MODE
 
 	spin_lock_bh(&pstapriv->auth_list_lock);
@@ -535,8 +507,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return _SUCCESS;
 }
 
@@ -549,10 +519,8 @@ void rtw_free_all_stainfo(struct rtw_ada
 	struct	sta_priv *pstapriv = &padapter->stapriv;
 	struct sta_info *pbcmc_stainfo = rtw_get_bcmc_stainfo(padapter);
 
-_func_enter_;
-
 	if (pstapriv->asoc_sta_count == 1)
-		goto exit;
+		return;
 
 	spin_lock_bh(&pstapriv->sta_hash_lock);
 
@@ -572,10 +540,6 @@ _func_enter_;
 	}
 
 	spin_unlock_bh(&pstapriv->sta_hash_lock);
-
-exit:
-
-_func_exit_;
 }
 
 /* any station allocated can be searched by hash list */
@@ -587,8 +551,6 @@ struct sta_info *rtw_get_stainfo(struct
 	u8 *addr;
 	u8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 
-_func_enter_;
-
 	if (hwaddr == NULL)
 		return NULL;
 
@@ -604,7 +566,6 @@ _func_enter_;
 	phead = &(pstapriv->sta_hash[index]);
 	plist = get_next(phead);
 
-
 	while ((rtw_end_of_queue_search(phead, plist)) == false) {
 		psta = container_of(plist, struct sta_info, hash_list);
 
@@ -617,7 +578,7 @@ _func_enter_;
 	}
 
 	spin_unlock_bh(&pstapriv->sta_hash_lock);
-_func_exit_;
+
 	return psta;
 }
 
@@ -629,8 +590,6 @@ u32 rtw_init_bcmc_stainfo(struct rtw_ada
 
 	struct	sta_priv *pstapriv = &padapter->stapriv;
 
-_func_enter_;
-
 	psta = rtw_alloc_stainfo(pstapriv, bcast_addr);
 
 	if (psta == NULL) {
@@ -643,21 +602,19 @@ _func_enter_;
 	/*  default broadcast & multicast use macid 1 */
 	psta->mac_id = 1;
 
-
 exit:
-_func_exit_;
+
 	return res;
 }
 
-
 struct sta_info *rtw_get_bcmc_stainfo(struct rtw_adapter *padapter)
 {
 	struct sta_info		*psta;
 	struct sta_priv		*pstapriv = &padapter->stapriv;
 	u8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-_func_enter_;
+
 	 psta = rtw_get_stainfo(pstapriv, bc_addr);
-_func_exit_;
+
 	return psta;
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -30,16 +30,15 @@ static u8 RFC1042_OUI[P80211_OUI_LEN] =
 
 static void _init_txservq(struct tx_servq *ptxservq)
 {
-_func_enter_;
+
 	INIT_LIST_HEAD(&ptxservq->tx_pending);
 	_rtw_init_queue(&ptxservq->sta_pending);
 	ptxservq->qcnt = 0;
-_func_exit_;
+
 }
 
 void	_rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)
 {
-_func_enter_;
 
 	memset((unsigned char *)psta_xmitpriv, 0, sizeof(struct sta_xmit_priv));
 
@@ -55,7 +54,6 @@ _func_enter_;
 	INIT_LIST_HEAD(&psta_xmitpriv->legacy_dz);
 	INIT_LIST_HEAD(&psta_xmitpriv->apsd);
 
-_func_exit_;
 }
 
 s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct rtw_adapter *padapter)
@@ -65,8 +63,6 @@ s32	_rtw_init_xmit_priv(struct xmit_priv
 	struct xmit_frame *pxframe;
 	int	res = _SUCCESS;
 
-_func_enter_;
-
 	/*  We don't need to memset padapter->XXX to zero, because adapter is allocated by vzalloc(). */
 	/* memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv)); */
 
@@ -126,7 +122,6 @@ _func_enter_;
 
 	pxmitpriv->frag_len = MAX_FRAG_THRESHOLD;
 
-
 	/* init xmit_buf */
 	_rtw_init_queue(&pxmitpriv->free_xmitbuf_queue);
 	_rtw_init_queue(&pxmitpriv->pending_xmitbuf_queue);
@@ -222,8 +217,6 @@ _func_enter_;
 	rtw_hal_init_xmit_priv(padapter);
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -251,11 +244,10 @@ void _rtw_free_xmit_priv(struct xmit_pri
 	struct xmit_frame	*pxmitframe = (struct xmit_frame *)pxmitpriv->pxmit_frame_buf;
 	struct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
 
-_func_enter_;
 	rtw_hal_free_xmit_priv(padapter);
 	rtw_mfree_xmit_priv_lock(pxmitpriv);
 	if (pxmitpriv->pxmit_frame_buf == NULL)
-		goto out;
+		return;
 
 	for (i = 0; i < NR_XMITFRAME; i++) {
 		rtw_os_xmit_complete(padapter, pxmitframe);
@@ -288,10 +280,6 @@ _func_enter_;
 #ifdef CONFIG_XMIT_ACK
 	_rtw_mutex_free(&pxmitpriv->ack_tx_mutex);
 #endif
-
-out:
-
-_func_exit_;
 }
 
 static void update_attrib_vcs_info(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
@@ -302,7 +290,6 @@ static void update_attrib_vcs_info(struc
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-
 	if (pattrib->nr_frags != 1)
 		sz = padapter->xmitpriv.frag_len;
 	else /* no frag */
@@ -332,7 +319,6 @@ static void update_attrib_vcs_info(struc
 				break;
 			}
 
-
 			/* check ERP protection */
 			if (psta->rtsen || psta->cts2self) {
 				if (psta->rtsen)
@@ -428,7 +414,6 @@ static void set_qos(struct pkt_file *ppk
 	struct iphdr ip_hdr;
 	s32 userpriority = 0;
 
-
 	_rtw_open_pktfile(ppktfile->pkt, ppktfile);
 	_rtw_pktfile_read(ppktfile, (unsigned char *)&etherhdr, ETH_HLEN);
 
@@ -460,14 +445,11 @@ static s32 update_attrib(struct rtw_adap
 	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
 	int res = _SUCCESS;
 
-_func_enter_;
-
 	_rtw_open_pktfile(pkt, &pktfile);
 	_rtw_pktfile_read(&pktfile, (u8 *)&etherhdr, ETH_HLEN);
 
 	pattrib->ether_type = ntohs(etherhdr.h_proto);
 
-
 	memcpy(pattrib->dst, &etherhdr.h_dest, ETH_ALEN);
 	memcpy(pattrib->src, &etherhdr.h_source, ETH_ALEN);
 
@@ -659,8 +641,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -681,7 +661,6 @@ static s32 xmitframe_addmic(struct rtw_a
 		stainfo = pattrib->psta;
 	else
 		stainfo = rtw_get_stainfo(&padapter->stapriv, &pattrib->ra[0]);
-_func_enter_;
 
 	if (pattrib->encrypt == _TKIP_) {
 		/* encode mic code */
@@ -791,8 +770,6 @@ _func_enter_;
 		}
 	}
 
-_func_exit_;
-
 	return _SUCCESS;
 }
 
@@ -800,8 +777,6 @@ static s32 xmitframe_swencrypt(struct rt
 {
 	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
 
-_func_enter_;
-
 	if (pattrib->bswenc) {
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("### xmitframe_swencrypt\n"));
 		switch (pattrib->encrypt) {
@@ -823,8 +798,6 @@ _func_enter_;
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_, ("### xmitframe_hwencrypt\n"));
 	}
 
-_func_exit_;
-
 	return _SUCCESS;
 }
 
@@ -850,8 +823,6 @@ s32 rtw_make_wlanhdr (struct rtw_adapter
 
 	int bmcst = IS_MCAST(pattrib->ra);
 
-_func_enter_;
-
 	if (pattrib->psta) {
 		psta = pattrib->psta;
 	} else {
@@ -955,7 +926,6 @@ _func_enter_;
 
 			SetSeqNum(hdr, pattrib->seqnum);
 
-
 			/* check if enable ampdu */
 			if (pattrib->ht_en && psta->htpriv.ampdu_enable) {
 				if (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
@@ -1007,8 +977,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1113,8 +1081,6 @@ s32 rtw_make_tdls_wlanhdr(struct rtw_ada
 	int res = _SUCCESS;
 	u16 *fctrl = &pwlanhdr->frame_ctl;
 
-_func_enter_;
-
 	memset(hdr, 0, WLANHDR_OFFSET);
 
 	SetFrameSubType(fctrl, pattrib->subtype);
@@ -1194,11 +1160,8 @@ _func_enter_;
 		SetSeqNum(hdr, pattrib->seqnum);
 	}
 
-
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1216,8 +1179,6 @@ s32 rtw_xmit_tdls_coalesce(struct rtw_ad
 	s32 bmcst = IS_MCAST(pattrib->ra);
 	s32 res = _SUCCESS;
 
-_func_enter_;
-
 	if (pattrib->psta) {
 		psta = pattrib->psta;
 	} else {
@@ -1297,8 +1258,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 #endif /* CONFIG_TDLS */
@@ -1355,8 +1314,6 @@ s32 rtw_xmitframe_coalesce(struct rtw_ad
 	s32 bmcst = IS_MCAST(pattrib->ra);
 	s32 res = _SUCCESS;
 
-_func_enter_;
-
 	if (pattrib->psta)
 		psta = pattrib->psta;
 	else
@@ -1493,8 +1450,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -1510,8 +1465,6 @@ s32 rtw_put_snap(u8 *data, u16 h_proto)
 	struct ieee80211_snap_hdr *snap;
 	u8 *oui;
 
-_func_enter_;
-
 	snap = (struct ieee80211_snap_hdr *)data;
 	snap->dsap = 0xaa;
 	snap->ssap = 0xaa;
@@ -1528,8 +1481,6 @@ _func_enter_;
 
 	*(__be16 *)(data + SNAP_SIZE) = htons(h_proto);
 
-_func_exit_;
-
 	return SNAP_SIZE + sizeof(u16);
 }
 
@@ -1541,8 +1492,6 @@ void rtw_update_protection(struct rtw_ad
 	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	struct	registry_priv *pregistrypriv = &padapter->registrypriv;
 
-_func_enter_;
-
 	switch (pxmitpriv->vcs_setting) {
 	case DISABLE_VCS:
 		pxmitpriv->vcs = NONE_VCS;
@@ -1568,7 +1517,6 @@ _func_enter_;
 		break;
 	}
 
-_func_exit_;
 }
 
 void rtw_count_tx_stats(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe, int sz)
@@ -1607,8 +1555,6 @@ struct xmit_buf *rtw_alloc_xmitbuf_ext(s
 	struct list_head *plist, *phead;
 	struct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;
 
-_func_enter_;
-
 	spin_lock_irqsave(&pfree_queue->lock, flags);
 
 	if (_rtw_queue_empty(pfree_queue) == true) {
@@ -1635,8 +1581,6 @@ _func_enter_;
 	}
 	spin_unlock_irqrestore(&pfree_queue->lock, flags);
 
-_func_exit_;
-
 	return pxmitbuf;
 }
 
@@ -1645,8 +1589,6 @@ s32 rtw_free_xmitbuf_ext(struct xmit_pri
 	long unsigned int flags;
 	struct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;
 
-_func_enter_;
-
 	if (pxmitbuf == NULL)
 		return _FAIL;
 
@@ -1662,8 +1604,6 @@ _func_enter_;
 
 	spin_unlock_irqrestore(&pfree_queue->lock, flags);
 
-_func_exit_;
-
 	return _SUCCESS;
 }
 
@@ -1674,8 +1614,6 @@ struct xmit_buf *rtw_alloc_xmitbuf(struc
 	struct list_head *plist, *phead;
 	struct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
 
-_func_enter_;
-
 	/* DBG_8192D("+rtw_alloc_xmitbuf\n"); */
 
 	spin_lock_irqsave(&pfree_xmitbuf_queue->lock, flags);
@@ -1713,8 +1651,6 @@ _func_enter_;
 
 	spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, flags);
 
-_func_exit_;
-
 	return pxmitbuf;
 }
 
@@ -1723,8 +1659,6 @@ s32 rtw_free_xmitbuf(struct xmit_priv *p
 	long unsigned int flags;
 	struct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
 
-_func_enter_;
-
 	if (pxmitbuf == NULL)
 		return _FAIL;
 
@@ -1750,8 +1684,6 @@ _func_enter_;
 		spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, flags);
 	}
 
-_func_exit_;
-
 	return _SUCCESS;
 }
 
@@ -1780,8 +1712,6 @@ struct xmit_frame *rtw_alloc_xmitframe(s
 	struct __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
 	struct rtw_adapter *padapter = pxmitpriv->adapter;
 
-_func_enter_;
-
 	spin_lock_bh(&pfree_xmit_queue->lock);
 
 	if (_rtw_queue_empty(pfree_xmit_queue) == true) {
@@ -1829,7 +1759,7 @@ _func_enter_;
 #endif
 	}
 	spin_unlock_bh(&pfree_xmit_queue->lock);
-_func_exit_;
+
 	return pxframe;
 }
 
@@ -1839,8 +1769,6 @@ s32 rtw_free_xmitframe(struct xmit_priv
 	struct rtw_adapter *padapter = pxmitpriv->adapter;
 	struct sk_buff *pndis_pkt = NULL;
 
-_func_enter_;
-
 	if (pxmitframe == NULL) {
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("====== rtw_free_xmitframe():pxmitframe == NULL!!!!!!!!!!\n"));
 		goto exit;
@@ -1862,14 +1790,11 @@ _func_enter_;
 
 	spin_unlock_bh(&pfree_xmit_queue->lock);
 
-
 	if (pndis_pkt)
 		rtw_os_pkt_complete(padapter, pndis_pkt);
 
 exit:
 
-_func_exit_;
-
 	return _SUCCESS;
 }
 
@@ -1878,8 +1803,6 @@ void rtw_free_xmitframe_queue(struct xmi
 	struct list_head *plist, *phead;
 	struct	xmit_frame	*pxmitframe;
 
-_func_enter_;
-
 	spin_lock_bh(&(pframequeue->lock));
 
 	phead = get_list_head(pframequeue);
@@ -1892,7 +1815,6 @@ _func_enter_;
 	}
 	spin_unlock_bh(&(pframequeue->lock));
 
-_func_exit_;
 }
 
 s32 rtw_xmitframe_enqueue(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
@@ -1940,8 +1862,6 @@ struct xmit_frame *rtw_dequeue_xframe(st
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
 	int i, inx[4];
 
-_func_enter_;
-
 	inx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;
 
 	if (pregpriv->wifi_spec == 1) {
@@ -1998,8 +1918,6 @@ exit:
 
 	spin_unlock_bh(&pxmitpriv->lock);
 
-_func_exit_;
-
 	return pxmitframe;
 }
 
@@ -2007,8 +1925,6 @@ struct tx_servq *rtw_get_sta_pending(str
 {
 	struct tx_servq *ptxservq;
 
-_func_enter_;
-
 	switch (up) {
 	case 1:
 	case 2:
@@ -2036,7 +1952,7 @@ _func_enter_;
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : BE\n"));
 	break;
 	}
-_func_exit_;
+
 	return ptxservq;
 }
 
@@ -2054,8 +1970,6 @@ s32 rtw_xmit_classifier(struct rtw_adapt
 	struct hw_xmit	*phwxmits =  padapter->xmitpriv.hwxmits;
 	int res = _SUCCESS;
 
-_func_enter_;
-
 	if (pattrib->psta)
 		psta = pattrib->psta;
 	else
@@ -2079,8 +1993,6 @@ _func_enter_;
 
 exit:
 
-_func_exit_;
-
 	return res;
 }
 
@@ -2121,10 +2033,10 @@ void rtw_free_hwxmits(struct rtw_adapter
 void rtw_init_hwxmits(struct hw_xmit *phwxmit, int entry)
 {
 	int i;
-_func_enter_;
+
 	for (i = 0; i < entry; i++, phwxmit++)
 		phwxmit->accnt = 0;
-_func_exit_;
+
 }
 
 #ifdef CONFIG_BR_EXT
--- a/drivers/staging/rtl8192du/hal/hal_intf.c
+++ b/drivers/staging/rtl8192du/hal/hal_intf.c
@@ -130,7 +130,7 @@ uint rtw_hal_deinit(struct rtw_adapter *
 {
 	uint	status = _SUCCESS;
 
-_func_enter_;
+
 
 	status = padapter->HalFunc.hal_deinit(padapter);
 
@@ -138,7 +138,7 @@ _func_enter_;
 		padapter->hw_init_completed = false;
 	else
 		RT_TRACE(_module_hal_init_c_,_drv_err_,("\n rtw_hal_deinit: hal_init fail\n"));
-_func_exit_;
+
 
 	return status;
 }
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -63,13 +63,13 @@ CheckFwReadLastH2C(
 
 /*  */
 /*  Description: */
-/* 	Fill H2C command */
-/* 	BOX_0-4 Format: */
-/* 	bit [31-8]	|     7		|  [6-0] */
-/* 	     RSVD	|  CMD_EXT	|  CMD_ID */
+/*	Fill H2C command */
+/*	BOX_0-4 Format: */
+/*	bit [31-8]	|     7		|  [6-0] */
+/*	     RSVD	|  CMD_EXT	|  CMD_ID */
 /*  */
-/* 	BOX Extension 0-4 format: */
-/* 	bit 15-0: RSVD */
+/*	BOX Extension 0-4 format: */
+/*	bit 15-0: RSVD */
 /*  */
 
 /*****************************************
@@ -91,7 +91,7 @@ static void _FillH2CCmd92D(struct rtw_ad
 	u8	WaitWriteH2cLimmit = 100;
 	u8	idx=0;
 
-_func_enter_;
+
 
 	padapter = GET_PRIMARY_ADAPTER(padapter);
 	pHalData = GET_HAL_DATA(padapter);
@@ -243,7 +243,7 @@ _func_enter_;
 
 	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex));
 
-_func_exit_;
+
 }
 
 void
@@ -297,7 +297,7 @@ u8 rtl8192d_set_raid_cmd(struct rtw_adap
 	u8	buf[5];
 	u8	res=_SUCCESS;
 	__le32	le_mask;
-_func_enter_;
+
 
 	memset(buf, 0, 5);
 	le_mask = cpu_to_le32(mask);
@@ -306,7 +306,7 @@ _func_enter_;
 
 	FillH2CCmd92D(padapter, H2C_RA_MASK, 5, buf);
 
-_func_exit_;
+
 
 	return res;
 }
@@ -348,7 +348,7 @@ void rtl8192d_set_FwPwrMode_cmd(struct r
 	u8	u1H2CSetPwrMode[3]={0};
 	u8	beacon_interval = 1;
 
-_func_enter_;
+
 
 	DBG_8192D("%s(): Mode = %d, SmartPS = %d\n", __func__,Mode,pwrpriv->smart_ps);
 
@@ -358,7 +358,7 @@ _func_enter_;
 
 	FillH2CCmd92D(padapter, H2C_SETPWRMODE, 3, u1H2CSetPwrMode);
 
-_func_exit_;
+
 }
 
 static void ConstructBeacon(struct rtw_adapter *padapter, u8 *pframe, u32 *pLength)
@@ -578,8 +578,8 @@ static void ConstructProbeRsp(struct rtw
 
 /*  */
 /*  Description: In normal chip, we should send some packet to Hw which will be used by Fw */
-/* 			in FW LPS mode. The function is to fill the Tx descriptor of this packets, then */
-/* 			Fw can tell Hw to send these packet derectly. */
+/*			in FW LPS mode. The function is to fill the Tx descriptor of this packets, then */
+/*			Fw can tell Hw to send these packet derectly. */
 /*  Added by tynli. 2009.10.15. */
 /*  */
 static void
@@ -633,13 +633,13 @@ FillFakeTxDescriptor92D(
 
 /*  */
 /*  Description: Fill the reserved packets that FW will use to RSVD page. */
-/* 			Now we just send 4 types packet to rsvd page. */
-/* 			(1)Beacon, (2)Ps-poll, (3)Null data, (4)ProbeRsp. */
-/* 	Input: */
-/* 	    dl_finish - FALSE: At the first time we will send all the packets as a large packet to Hw, */
-/* 						so we need to set the packet length to total lengh. */
-/* 			      TRUE: At the second time, we should send the first packet (default:beacon) */
-/* 						to Hw again and set the lengh in descriptor to the real beacon lengh. */
+/*			Now we just send 4 types packet to rsvd page. */
+/*			(1)Beacon, (2)Ps-poll, (3)Null data, (4)ProbeRsp. */
+/*	Input: */
+/*	    dl_finish - FALSE: At the first time we will send all the packets as a large packet to Hw, */
+/*						so we need to set the packet length to total lengh. */
+/*			      TRUE: At the second time, we should send the first packet (default:beacon) */
+/*						to Hw again and set the lengh in descriptor to the real beacon lengh. */
 /*  2009.10.15 by tynli. */
 static void SetFwRsvdPagePkt(struct rtw_adapter * adapter, bool dl_finish)
 {
@@ -788,7 +788,7 @@ void rtl8192d_set_FwJoinBssReport_cmd(st
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	bool	bRecover = false;
 
-_func_enter_;
+
 
 	DBG_8192D("%s\n", __func__);
 
@@ -842,7 +842,7 @@ _func_enter_;
 
 	FillH2CCmd92D(padapter, H2C_JOINBSSRPT, 1, u1JoinBssRptParm);
 
-_func_exit_;
+
 }
 
 #ifdef CONFIG_P2P_PS
@@ -863,7 +863,7 @@ void rtl8192d_set_p2p_ps_offload_cmd(str
 	u16	ctwindow;
 	u32	start_time, tsf_low;
 
-_func_enter_;
+
 
 	switch (p2p_ps_state)
 	{
@@ -949,7 +949,7 @@ _func_enter_;
 
 	FillH2CCmd92D(padapter, H2C_P2P_PS_OFFLOAD, 1, (u8 *)p2p_ps_offload);
 
-_func_exit_;
+
 }
 #endif /*  CONFIG_P2P_PS */
 
@@ -964,7 +964,7 @@ static u8 rtl8192d_reset_tsf(struct rtw_
 	u8	buf[2];
 	u8	res=_SUCCESS;
 
-_func_enter_;
+
 	if (IFACE_PORT0==reset_port) {
 		buf[0] = 0x1; buf[1] = 0;
 
@@ -972,7 +972,7 @@ _func_enter_;
 		buf[0] = 0x0; buf[1] = 0x1;
 	}
 	FillH2CCmd92D(padapter, H2C_92D_RESET_TSF, 2, buf);
-_func_exit_;
+
 
 	return res;
 }
@@ -1010,7 +1010,7 @@ void rtl8192d_set_wowlan_cmd(struct rtw_
 	struct set_wowlan_parm pwowlan_parm;
 	struct pwrctrl_priv *pwrpriv=&padapter->pwrctrlpriv;
 
-_func_enter_;
+
 
 	pwowlan_parm.mode =0;
 	pwowlan_parm.gpio_index=0;
@@ -1093,7 +1093,7 @@ _func_enter_;
 		FillH2CCmd92D(padapter, H2C_WO_WLAN_CMD, 4, (u8 *)&pwowlan_parm);
 
 
-_func_exit_;
+
 
 	return ;
 }
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -680,9 +680,9 @@ static void odm_DIG(
 			}
 		}
 	} else {
-		/* 	There is no network interface connects to AP. */
+		/*	There is no network interface connects to AP. */
 		if (0 == dm_digtable->rx_gain_range_min_nolink) {
-			/* 	First time to enter odm_DIG function and set the default value to rx_gain_range_min_nolink */
+			/*	First time to enter odm_DIG function and set the default value to rx_gain_range_min_nolink */
 			dm_digtable->rx_gain_range_min_nolink = 0x30;
 		} else {
 			if ((falsealmcnt->Cnt_all > 1000) && (falsealmcnt->Cnt_all < 2000)) {
@@ -1528,34 +1528,34 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 	u8		OFDM_min_index = 6, OFDM_min_index_internalPA = 12, rf; /* OFDM BB Swing should be less than +3.0dB, which is required by Arthur */
 	u8		Indexforchannel = rtl8192d_GetRightChnlPlaceforIQK(pHalData->CurrentChannel);
 	u8 index_mapping[5][index_mapping_NUM] = {
-		{0, 1, 3, 6, 8, 9, 			/* 5G, path A/MAC 0, decrease power */
+		{0, 1, 3, 6, 8, 9,			/* 5G, path A/MAC 0, decrease power */
 		11, 13, 14, 16, 17, 18, 18},
-		{0, 2, 4, 5, 7, 10, 			/* 5G, path A/MAC 0, increase power */
+		{0, 2, 4, 5, 7, 10,			/* 5G, path A/MAC 0, increase power */
 		12, 14, 16, 18, 18, 18, 18},
-		{0, 2, 3, 6, 8, 9, 			/* 5G, path B/MAC 1, decrease power */
+		{0, 2, 3, 6, 8, 9,			/* 5G, path B/MAC 1, decrease power */
 		11, 13, 14, 16, 17, 18, 18},
-		{0, 2, 4, 5, 7, 10, 			/* 5G, path B/MAC 1, increase power */
+		{0, 2, 4, 5, 7, 10,			/* 5G, path B/MAC 1, increase power */
 		13, 16, 16, 18, 18, 18, 18},
-		{0, 1, 2, 3, 4, 5, 			/* 2.4G, for decreas power */
+		{0, 1, 2, 3, 4, 5,			/* 2.4G, for decreas power */
 		6, 7, 7, 8, 9, 10, 10},
 	};
 
 	u8 index_mapping_internalPA[8][index_mapping_NUM] = {
-		{0, 1, 2, 4, 6, 7, 			/* 5G, path A/MAC 0, ch36-64, decrease power */
+		{0, 1, 2, 4, 6, 7,			/* 5G, path A/MAC 0, ch36-64, decrease power */
 		9, 11, 12, 14, 15, 16, 16},
-		{0, 2, 4, 5, 7, 10, 			/* 5G, path A/MAC 0, ch36-64, increase power */
+		{0, 2, 4, 5, 7, 10,			/* 5G, path A/MAC 0, ch36-64, increase power */
 		12, 14, 16, 18, 18, 18, 18},
-		{0, 1, 2, 3, 5, 6, 			/* 5G, path A/MAC 0, ch100-165, decrease power */
+		{0, 1, 2, 3, 5, 6,			/* 5G, path A/MAC 0, ch100-165, decrease power */
 		8, 10, 11, 13, 14, 15, 15},
-		{0, 2, 4, 5, 7, 10, 			/* 5G, path A/MAC 0, ch100-165, increase power */
+		{0, 2, 4, 5, 7, 10,			/* 5G, path A/MAC 0, ch100-165, increase power */
 		12, 14, 16, 18, 18, 18, 18},
-		{0, 1, 2, 4, 6, 7, 			/* 5G, path B/MAC 1, ch36-64, decrease power */
+		{0, 1, 2, 4, 6, 7,			/* 5G, path B/MAC 1, ch36-64, decrease power */
 		9, 11, 12, 14, 15, 16, 16},
-		{0, 2, 4, 5, 7, 10, 			/* 5G, path B/MAC 1, ch36-64, increase power */
+		{0, 2, 4, 5, 7, 10,			/* 5G, path B/MAC 1, ch36-64, increase power */
 		13, 16, 16, 18, 18, 18, 18},
-		{0, 1, 2, 3, 5, 6, 			/* 5G, path B/MAC 1, ch100-165, decrease power */
+		{0, 1, 2, 3, 5, 6,			/* 5G, path B/MAC 1, ch100-165, decrease power */
 		8, 9, 10, 12, 13, 14, 14},
-		{0, 2, 4, 5, 7, 10, 			/* 5G, path B/MAC 1, ch100-165, increase power */
+		{0, 2, 4, 5, 7, 10,			/* 5G, path B/MAC 1, ch100-165, increase power */
 		13, 16, 16, 18, 18, 18, 18},
 	};
 
@@ -2007,15 +2007,15 @@ DM_InitializeTXPowerTracking(
 }
 
 /*  */
-/* 	Description: */
-/* 		- Dispatch TxPower Tracking direct call ONLY for 92s. */
-/* 		- We shall NOT schedule Workitem within PASSIVE LEVEL, which will cause system resource */
-/* 		   leakage under some platform. */
+/*	Description: */
+/*		- Dispatch TxPower Tracking direct call ONLY for 92s. */
+/*		- We shall NOT schedule Workitem within PASSIVE LEVEL, which will cause system resource */
+/*		   leakage under some platform. */
 /*  */
-/* 	Assumption: */
-/* 		PASSIVE_LEVEL when this routine is called. */
+/*	Assumption: */
+/*		PASSIVE_LEVEL when this routine is called. */
 /*  */
-/* 	Added by Roger, 2009.06.18. */
+/*	Added by Roger, 2009.06.18. */
 /*  */
 static void
 DM_TXPowerTracking92CDirectCall(
@@ -2155,7 +2155,7 @@ static void	dm_CheckPbcGPIO(struct rtw_a
 
 
 		if (padapter->pid[0] == 0)
-		{	/* 	0 is the default value and it means the application monitors the HW PBC doesn't privde its pid to driver. */
+		{	/*	0 is the default value and it means the application monitors the HW PBC doesn't privde its pid to driver. */
 			return;
 		}
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -279,7 +279,7 @@ static int _FWInit(struct rtw_adapter *a
 	return _FAIL;
 }
 
-/* 	Description: Download 8192D firmware code. */
+/*	Description: Download 8192D firmware code. */
 int FirmwareDownload92D(struct rtw_adapter *adapter, bool bUsedWoWLANFw)
 {
 	int rtStatus = _SUCCESS;
@@ -530,9 +530,9 @@ InitializeFirmwareVars92D(
 
 /*  */
 /*  Description: Prepare some information to Fw for WoWLAN. */
-/* 			(1) Download wowlan Fw. */
-/* 			(2) Download RSVD page packets. */
-/* 			(3) Enable AP offload if needed. */
+/*			(1) Download wowlan Fw. */
+/*			(2) Download RSVD page packets. */
+/*			(3) Enable AP offload if needed. */
 /*  */
 /*  2011.04.12 by tynli. */
 /*  */
@@ -640,7 +640,7 @@ rtl8192d_ReadChipVersion(
 
 /*  */
 /*  */
-/* 	Channel Plan */
+/*	Channel Plan */
 /*  */
 /*  */
 
@@ -664,7 +664,7 @@ rtl8192d_EfuseParseChnlPlan(
 
 /*  */
 /*  */
-/* 	EEPROM Power index mapping */
+/*	EEPROM Power index mapping */
 /*  */
 /*  */
 
@@ -984,10 +984,10 @@ rtl8192d_ReadTxPowerInfo(
 }
 
 /*  */
-/* 	Description: */
-/* 		Reset Dual Mac Mode Switch related settings */
+/*	Description: */
+/*		Reset Dual Mac Mode Switch related settings */
 /*  */
-/* 	Assumption: */
+/*	Assumption: */
 /*  */
 void rtl8192d_ResetDualMacSwitchVariables(
 		struct rtw_adapter *			adapter
@@ -1123,7 +1123,7 @@ PHY_SetPowerOnFor8192D(
 
 void rtl8192d_free_hal_data(struct rtw_adapter * padapter)
 {
-_func_enter_;
+
 
 	DBG_8192D("===== rtl8192du_free_hal_data =====\n");
 
@@ -1131,11 +1131,11 @@ _func_enter_;
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	GlobalFirstConfigurationForNormalChip = true;
 #endif
-_func_exit_;
+
 }
 
 /*  */
-/* 				Efuse related code */
+/*				Efuse related code */
 /*  */
 enum{
 		VOLTAGE_V25						= 0x03,
--- a/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
@@ -1737,11 +1737,11 @@ rtl8192d_PHY_GetHWRegOriginalValue(
 
 
 /*  */
-/* 	Description: */
-/* 		Map dBm into Tx power index according to */
-/* 		current HW model, for example, RF and PA, and */
-/* 		current wireless mode. */
-/* 	By Bruce, 2008-01-29. */
+/*	Description: */
+/*		Map dBm into Tx power index according to */
+/*		current HW model, for example, RF and PA, and */
+/*		current wireless mode. */
+/*	By Bruce, 2008-01-29. */
 /*  */
 static	u8
 phy_DbmToTxPwrIdx(
@@ -1758,7 +1758,7 @@ phy_DbmToTxPwrIdx(
 	/*  Tested by MP, we found that CCK Index 0 equals to 8dbm, OFDM legacy equals to */
 	/*  3dbm, and OFDM HT equals to 0dbm repectively. */
 	/*  Note: */
-	/* 	The mapping may be different by different NICs. Do not use this formula for what needs accurate result. */
+	/*	The mapping may be different by different NICs. Do not use this formula for what needs accurate result. */
 	/*  By Bruce, 2008-01-29. */
 	/*  */
 	switch (WirelessMode)
@@ -1794,11 +1794,11 @@ phy_DbmToTxPwrIdx(
 
 
 /*  */
-/* 	Description: */
-/* 		Map Tx power index into dBm according to */
-/* 		current HW model, for example, RF and PA, and */
-/* 		current wireless mode. */
-/* 	By Bruce, 2008-01-29. */
+/*	Description: */
+/*		Map Tx power index into dBm according to */
+/*		current HW model, for example, RF and PA, and */
+/*		current wireless mode. */
+/*	By Bruce, 2008-01-29. */
 /*  */
 static int
 phy_TxPwrIdxToDbm(
@@ -1813,7 +1813,7 @@ phy_TxPwrIdxToDbm(
 	/*  */
 	/*  Tested by MP, we found that CCK Index 0 equals to -7dbm, OFDM legacy equals to -8dbm. */
 	/*  Note: */
-	/* 	The mapping may be different by different NICs. Do not use this formula for what needs accurate result. */
+	/*	The mapping may be different by different NICs. Do not use this formula for what needs accurate result. */
 	/*  By Bruce, 2008-01-29. */
 	/*  */
 	switch (WirelessMode)
@@ -1978,12 +1978,12 @@ PHY_SetTxPowerLevel8192D(
 }
 
 /*  */
-/* 	Description: */
-/* 		Update transmit power level of all channel supported. */
+/*	Description: */
+/*		Update transmit power level of all channel supported. */
 /*  */
-/* 	TODO: */
-/* 		A mode. */
-/* 	By Bruce, 2008-02-04. */
+/*	TODO: */
+/*		A mode. */
+/*	By Bruce, 2008-02-04. */
 /*  */
 bool
 PHY_UpdateTxPowerDbm8192D(
@@ -3194,7 +3194,7 @@ phy_FinishSwChnlNow(	/*  We should not c
 
 /*  */
 /*  Description: */
-/* 	Switch channel synchronously. Called by SwChnlByDelayHandler. */
+/*	Switch channel synchronously. Called by SwChnlByDelayHandler. */
 /*  */
 /*  Implemented by Bruce, 2008-02-14. */
 /*  The following procedure is operted according to SwChanlCallback8190Pci(). */
@@ -3231,10 +3231,10 @@ PHY_SwChnlPhy8192D(	/*  Only called duri
 
 
 /*  */
-/* 	Description: */
-/* 		Configure H/W functionality to enable/disable Monitor mode. */
-/* 		Note, because we possibly need to configure BB and RF in this function, */
-/* 		so caller should in PASSIVE_LEVEL. 080118, by rcnjko. */
+/*	Description: */
+/*		Configure H/W functionality to enable/disable Monitor mode. */
+/*		Note, because we possibly need to configure BB and RF in this function, */
+/*		so caller should in PASSIVE_LEVEL. 080118, by rcnjko. */
 /*  */
 void
 PHY_SetMonitorMode8192D(
@@ -3275,7 +3275,7 @@ PHY_CheckIsLegalRfPath8192D(
 
 /*  */
 /*  */
-/* 	IQK */
+/*	IQK */
 /*  */
 /*  */
 #define MAX_TOLERANCE		5
@@ -4128,7 +4128,7 @@ phy_IQCalibrate(
 #endif
 
 	/*  Note: IQ calibration must be performed after loading */
-	/* 		PHY_REG.txt , and radio_a, radio_b.txt */
+	/*		PHY_REG.txt , and radio_a, radio_b.txt */
 	if (t == 0) {
 		/*  Save ADDA parameters, turn Path A ADDA on */
 		phy_SaveADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
@@ -4703,7 +4703,7 @@ phy_IQCalibrate_5G_Normal(
 					};
 
 	/*  Note: IQ calibration must be performed after loading */
-	/* 		PHY_REG.txt , and radio_a, radio_b.txt */
+	/*		PHY_REG.txt , and radio_a, radio_b.txt */
 	/* 3 PathDiv */
        /* Neil Chen--2011--05--19-- */
 	u8                 rfPathDiv;   /* for Path Diversity */
@@ -6149,15 +6149,15 @@ PHY_UpdateBBRFConfiguration8192D(
 }
 
 /*  */
-/* 	Description: */
-/* 		Read HW adapter information through EEPROM 93C46. */
-/* 		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type. */
-/* 		MacPhyMode:DMDP,SMSP. */
-/* 		BandType:2.4G,5G. */
+/*	Description: */
+/*		Read HW adapter information through EEPROM 93C46. */
+/*		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type. */
+/*		MacPhyMode:DMDP,SMSP. */
+/*		BandType:2.4G,5G. */
 /*  */
-/* 	Assumption: */
-/* 		1. Boot from EEPROM and CR9346 regiser has verified. */
-/* 		2. PASSIVE_LEVEL (USB interface) */
+/*	Assumption: */
+/*		1. Boot from EEPROM and CR9346 regiser has verified. */
+/*		2. PASSIVE_LEVEL (USB interface) */
 /*  */
 void PHY_ReadMacPhyMode92D(
 		struct rtw_adapter *			adapter,
@@ -6192,15 +6192,15 @@ void PHY_ReadMacPhyMode92D(
 }
 
 /*  */
-/* 	Description: */
-/* 		Read HW adapter information through EEPROM 93C46. */
-/* 		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type. */
-/* 		MacPhyMode:DMDP,SMSP. */
-/* 		BandType:2.4G,5G. */
+/*	Description: */
+/*		Read HW adapter information through EEPROM 93C46. */
+/*		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type. */
+/*		MacPhyMode:DMDP,SMSP. */
+/*		BandType:2.4G,5G. */
 /*  */
-/* 	Assumption: */
-/* 		1. Boot from EEPROM and CR9346 regiser has verified. */
-/* 		2. PASSIVE_LEVEL (USB interface) */
+/*	Assumption: */
+/*		1. Boot from EEPROM and CR9346 regiser has verified. */
+/*		2. PASSIVE_LEVEL (USB interface) */
 /*  */
 void PHY_ConfigMacPhyMode92D(
 		struct rtw_adapter *			adapter
@@ -6228,15 +6228,15 @@ void PHY_ConfigMacPhyMode92D(
 }
 
 /*  */
-/* 	Description: */
-/* 		Read HW adapter information through EEPROM 93C46. */
-/* 		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type. */
-/* 		MacPhyMode:DMDP,SMSP. */
-/* 		BandType:2.4G,5G. */
+/*	Description: */
+/*		Read HW adapter information through EEPROM 93C46. */
+/*		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type. */
+/*		MacPhyMode:DMDP,SMSP. */
+/*		BandType:2.4G,5G. */
 /*  */
-/* 	Assumption: */
-/* 		1. Boot from EEPROM and CR9346 regiser has verified. */
-/* 		2. PASSIVE_LEVEL (USB interface) */
+/*	Assumption: */
+/*		1. Boot from EEPROM and CR9346 regiser has verified. */
+/*		2. PASSIVE_LEVEL (USB interface) */
 /*  */
 void PHY_ConfigMacPhyModeInfo92D(struct rtw_adapter *adapter)
 {
@@ -6375,12 +6375,12 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 }
 
 /*  */
-/* 	Description: */
-/* 	set RX packet buffer and other setting acording to dual mac mode */
+/*	Description: */
+/*	set RX packet buffer and other setting acording to dual mac mode */
 /*  */
-/* 	Assumption: */
-/* 		1. Boot from EEPROM and CR9346 regiser has verified. */
-/* 		2. PASSIVE_LEVEL (USB interface) */
+/*	Assumption: */
+/*		1. Boot from EEPROM and CR9346 regiser has verified. */
+/*		2. PASSIVE_LEVEL (USB interface) */
 /*  */
 void PHY_ConfigMacCoexist_RFPage92D(
 		struct rtw_adapter *			adapter
--- a/drivers/staging/rtl8192du/hal/rtl8192du_led.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_led.c
@@ -19,7 +19,7 @@
 #include <rtl8192d_led.h>
 
 /*  */
-/* 	Constant. */
+/*	Constant. */
 /*  */
 
 /*  */
@@ -41,7 +41,7 @@
 
 
 /*  */
-/* 	Prototype of protected function. */
+/*	Prototype of protected function. */
 /*  */
 
 static void BlinkTimerCallback(unsigned long data);
@@ -71,8 +71,8 @@ ResetLedStatus(struct LED_871X *	pLed) {
 /*  */
 
 /*  */
-/* 	Description: */
-/* 		Initialize an struct LED_871X object. */
+/*	Description: */
+/*		Initialize an struct LED_871X object. */
 /*  */
 
 static void InitLed871x(struct rtw_adapter *padapter,
@@ -98,8 +98,8 @@ static void InitLed871x(struct rtw_adapt
 
 
 /*  */
-/* 	Description: */
-/* 		DeInitialize an struct LED_871X object. */
+/*	Description: */
+/*		DeInitialize an struct LED_871X object. */
 /*  */
 static void DeInitLed871x(struct LED_871X *pLed)
 {
@@ -115,8 +115,8 @@ static void DeInitLed871x(struct LED_871
 
 
 /*  */
-/* 	Description: */
-/* 		Turn on LED according to LedPin specified. */
+/*	Description: */
+/*		Turn on LED according to LedPin specified. */
 /*  */
 
 static void SwLedOn(struct rtw_adapter *padapter, struct LED_871X *pLed)
@@ -155,8 +155,8 @@ static void SwLedOn(struct rtw_adapter *
 
 
 /*  */
-/* 	Description: */
-/* 		Turn off LED according to LedPin specified. */
+/*	Description: */
+/*		Turn off LED according to LedPin specified. */
 /*  */
 static void SwLedOff(struct rtw_adapter *padapter, struct LED_871X *pLed)
 {
@@ -195,9 +195,9 @@ static void SwLedOff(struct rtw_adapter
 }
 
 /*  */
-/* 	Description: */
-/* 		Implementation of LED blinking behavior. */
-/* 		It toggle off LED and schedule corresponding timer if necessary. */
+/*	Description: */
+/*		Implementation of LED blinking behavior. */
+/*		It toggle off LED and schedule corresponding timer if necessary. */
 /*  */
 static void SwLedBlink(struct LED_871X *pLed)
 {
@@ -316,7 +316,7 @@ static void SwLedBlink(struct LED_871X *
 static void SwLedBlink1(struct LED_871X *pLed)
 {
 	struct rtw_adapter				*padapter = pLed->padapter;
-	struct hal_data_8192du 		*pHalData = GET_HAL_DATA(padapter);
+	struct hal_data_8192du		*pHalData = GET_HAL_DATA(padapter);
 	struct led_priv		*ledpriv = &(padapter->ledpriv);
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
 	struct LED_871X *			pLed1 = &(ledpriv->SwLed1);
@@ -1129,9 +1129,9 @@ static void SwLedBlink5(struct LED_871X
 }
 
 /*  */
-/* 	Description: */
-/* 		Callback function of LED BlinkTimer, */
-/* 		it just schedules to corresponding BlinkWorkItem. */
+/*	Description: */
+/*		Callback function of LED BlinkTimer, */
+/*		it just schedules to corresponding BlinkWorkItem. */
 /*  */
 static void
 BlinkTimerCallback(
@@ -1151,9 +1151,9 @@ BlinkTimerCallback(
 
 
 /*  */
-/* 	Description: */
-/* 		Callback function of LED BlinkWorkItem. */
-/* 		We dispatch acture LED blink action according to LedStrategy. */
+/*	Description: */
+/*		Callback function of LED BlinkWorkItem. */
+/*		We dispatch acture LED blink action according to LedStrategy. */
 /*  */
 static void BlinkWorkItemCallback(struct work_struct *work)
 {
@@ -1204,9 +1204,9 @@ static void BlinkWorkItemCallback(struct
 /*  */
 
 /*  */
-/* 	Description: */
-/* 		Implement each led action for SW_LED_MODE0. */
-/* 		This is default strategy. */
+/*	Description: */
+/*		Implement each led action for SW_LED_MODE0. */
+/*		This is default strategy. */
 /*  */
 static void SwLedControlMode0(
 	struct rtw_adapter		*padapter,
@@ -1328,7 +1328,7 @@ static void SwLedControlMode1(
 	enum LED_CTL_MODE		LedAction
 )
 {
-	struct hal_data_8192du 		*pHalData = GET_HAL_DATA(padapter);
+	struct hal_data_8192du		*pHalData = GET_HAL_DATA(padapter);
 	struct led_priv		*ledpriv = &(padapter->ledpriv);
 	struct LED_871X *			pLed = &(ledpriv->SwLed0);
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
@@ -2271,7 +2271,7 @@ static void SwLedControlMode5(
 	enum LED_CTL_MODE		LedAction
 )
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(padapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct LED_871X *		pLed = &(ledpriv->SwLed0);
@@ -2353,8 +2353,8 @@ static void SwLedControlMode5(
 
 
 /*  */
-/* 	Description: */
-/* 		Dispatch LED action according to pHalData->LedStrategy. */
+/*	Description: */
+/*		Dispatch LED action according to pHalData->LedStrategy. */
 /*  */
 static void LedControl871x(
 	struct rtw_adapter				*padapter,
@@ -2418,8 +2418,8 @@ static void LedControl871x(
 /*  */
 
 /*  */
-/* 	Description: */
-/* 		Initialize all struct LED_871X objects. */
+/*	Description: */
+/*		Initialize all struct LED_871X objects. */
 /*  */
 void rtl8192du_InitSwLeds(struct rtw_adapter	*padapter)
 {
@@ -2434,8 +2434,8 @@ void rtl8192du_InitSwLeds(struct rtw_ada
 
 
 /*  */
-/* 	Description: */
-/* 		DeInitialize all LED_819xUsb objects. */
+/*	Description: */
+/*		DeInitialize all LED_819xUsb objects. */
 /*  */
 void rtl8192du_DeInitSwLeds(struct rtw_adapter *padapter)
 {
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -222,7 +222,7 @@ static s32 update_txdesc(struct xmit_fra
 	int	pull=0;
 	uint	qsel;
 	struct rtw_adapter				*padapter = pxmitframe->padapter;
-	struct hal_data_8192du 		*pHalData = GET_HAL_DATA(padapter);
+	struct hal_data_8192du		*pHalData = GET_HAL_DATA(padapter);
 	struct dm_priv		*pdmpriv = &pHalData->dmpriv;
 #ifdef CONFIG_AP_MODE
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -602,7 +602,7 @@ static void UpdateEarlyModeInfo8192D(str
 #define IDEA_CONDITION 1	/*  check all packets before enqueue */
 s32 rtl8192du_xmitframe_complete(struct rtw_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(padapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
 	struct xmit_frame *pxmitframe = NULL;
 	struct xmit_frame *pfirstframe = NULL;
 
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -74,7 +74,7 @@ _TwoOutEpMapping(
 
 	if (bWIFICfg) { /*  Normal chip && wmm */
 
-		/* 	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA */
+		/*	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA */
 		/*   0,		1,	0,	1,	0,	0,	0,	0,		0	}; */
 		/* 0:H(end_number=0x02), 1:L (end_number=0x03) */
 
@@ -117,7 +117,7 @@ static void _ThreeOutEpMapping(
 {
 	if (bWIFICfg) {/* for WMM */
 
-		/* 	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA */
+		/*	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA */
 		/*   1,		2,	1,	0,	0,	0,	0,	0,		0	}; */
 		/* 0:H(end_number=0x02), 1:N(end_number=0x03), 2:L (end_number=0x05) */
 
@@ -135,7 +135,7 @@ static void _ThreeOutEpMapping(
 	else {/* typical setting */
 
 
-		/* 	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA */
+		/*	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA */
 		/*   2,		2,	1,	0,	0,	0,	0,	0,		0	}; */
 		/* 0:H(end_number=0x02), 1:N(end_number=0x03), 2:L (end_number=0x05) */
 
@@ -310,7 +310,7 @@ static u8 _InitPowerOn(struct rtw_adapte
 	u8	ret = _SUCCESS;
 	u16	value16=0;
 	u8	value8 = 0;
-/* 	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter); */
+/*	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter); */
 
 	/*  polling autoload done. */
 	u32	pollingCount = 0;
@@ -402,7 +402,7 @@ static u16 CRC16(u8 data,u16 CRC)
 
 		CRC_Result=CRC<<1;
 		/* set BIT0 */
-		/* 	printf("CRC =%x\n",CRC_Result); */
+		/*	printf("CRC =%x\n",CRC_Result); */
 		/* CRC bit 0 =shift_in, */
 		if (shift_in==0)
 		{
@@ -552,7 +552,7 @@ static int rtw_wowlan_set_pattern(struct
 			if (pbuf[4+(i/8)]&(0x01<<(i%8)))
 			{
 				packet[crc_idx++]=pbuf[20+i];
-		/* 		DBG_8192D("\n i=%d packet[i]=%x pbuf[20+i(%d)]=%x\n",i,packet[i],20+i,pbuf[20+i]); */
+		/*		DBG_8192D("\n i=%d packet[i]=%x pbuf[20+i(%d)]=%x\n",i,packet[i],20+i,pbuf[20+i]); */
 			}
 		}
 		crc_val=calc_crc(packet, crc_idx);
@@ -751,7 +751,7 @@ static u8 InitLLTTable(
 
 /*  */
 /*  */
-/* 	MAC init functions */
+/*	MAC init functions */
 /*  */
 /*  */
 static void
@@ -1104,7 +1104,7 @@ _InitNetworkType(
 	value32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AP);
 #endif
 	rtw_write32(adapter, REG_CR, value32);
-/* 	RASSERT(pIoBase->rtw_read8(REG_CR + 2) == 0x2); */
+/*	RASSERT(pIoBase->rtw_read8(REG_CR + 2) == 0x2); */
 }
 
 static void
@@ -1504,7 +1504,7 @@ _InitBeaconParameters(
 	struct rtw_adapter * adapter
 	)
 {
-/* 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter); */
+/*	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter); */
 
 	rtw_write16(adapter, REG_BCN_CTRL, 0x1010);
 
@@ -1523,7 +1523,7 @@ _InitRFType(
 	struct rtw_adapter * adapter
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 
 #if (DISABLE_BB_RF==1)
 	pHalData->rf_chip	= RF_PSEUDO_11N;
@@ -1545,7 +1545,7 @@ _InitRFType(
 #if RTL8192CU_ADHOC_WORKAROUND_SETTING
 static void _InitAdhocWorkaroundParams(struct rtw_adapter * adapter)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	pHalData->RegBcnCtrlVal = rtw_read8(adapter, REG_BCN_CTRL);
 	pHalData->RegTxPause = rtw_read8(adapter, REG_TXPAUSE);
 	pHalData->RegFwHwTxQCtrl = rtw_read8(adapter, REG_FWHW_TXQ_CTRL+2);
@@ -1576,7 +1576,7 @@ static void _BBTurnOnBlock(
 	struct rtw_adapter *		adapter
 	)
 {
-	struct hal_data_8192du 		*pHalData	= GET_HAL_DATA(adapter);
+	struct hal_data_8192du		*pHalData	= GET_HAL_DATA(adapter);
 #if (DISABLE_BB_RF)
 	return;
 #endif
@@ -1591,7 +1591,7 @@ static void _RfPowerSave(
 	struct rtw_adapter *		adapter
 	)
 {
-	struct hal_data_8192du 	*pHalData	= GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData	= GET_HAL_DATA(adapter);
 	struct pwrctrl_priv		*pwrctrlpriv = &adapter->pwrctrlpriv;
 	u8			eRFPath;
 
@@ -1618,7 +1618,7 @@ static void _RfPowerSave(
 		pwrctrlpriv->rf_pwrstate = rf_on;
 		pwrctrlpriv->rfoff_reason = 0;
 		/* if (adapter->bInSetPower || adapter->bResetInProgress) */
-		/* 	PlatformUsbEnableInPipes(adapter); */
+		/*	PlatformUsbEnableInPipes(adapter); */
 		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("Initializeadapter8192CUsb(): RF is on.\n")); */
 	}
 }
@@ -1744,7 +1744,7 @@ static u32 rtl8192du_hal_init(struct rtw
 #else
 	#define HAL_INIT_PROFILE_TAG(stage) do {} while (0)
 #endif /* DBG_HAL_INIT_PROFILING */
-_func_enter_;
+
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
 	padapter->init_adpt_in_progress = true;
@@ -2204,7 +2204,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 		/* 3 Set Loopback mode or Normal mode */
 		/* 3 */
 		/* 2006.12.13 by emily. Note!We should not merge these two CPU_GEN register writings */
-		/* 	because setting of System_Reset bit reset MAC to default transmission mode. */
+		/*	because setting of System_Reset bit reset MAC to default transmission mode. */
 		ulRegRead = rtw_read32(padapter, 0x100);	/* CPU_GEN  0x100 */
 
 		ulRegRead |= ulRegRead;
@@ -2254,7 +2254,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END
 	}
 	#endif
 
-_func_exit_;
+
 
 #ifdef CONFIG_WOWLAN
 	if (padapter->pwrctrlpriv.wowlan_mode == true)
@@ -2454,7 +2454,7 @@ c.	APSD_CTRL 0x600[7:0] = 0x40
 d.	SYS_FUNC_EN 0x02[7:0] = 0x16		reset BB state machine
 e.	SYS_FUNC_EN 0x02[7:0] = 0x14		reset BB state machine
 ***************************************/
-       struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+       struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	u8	eRFPath = 0,value8 = 0;
 
 	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000,  0xf);
@@ -2624,7 +2624,7 @@ CanGotoPowerOff92D(
 	struct rtw_adapter *			adapter
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	u8 u1bTmp;
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
@@ -2689,7 +2689,7 @@ CardDisableHWSM(/*  HW Auto state machin
 	bool			resetMCU
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	int		rtStatus = _SUCCESS;
 	u8		value;
 
@@ -2740,7 +2740,7 @@ CardDisableWithoutHWSM(/*  without HW Au
 	struct rtw_adapter *		adapter
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	int		rtStatus = _SUCCESS;
 	u8		value;
 
@@ -2807,10 +2807,10 @@ static u32 rtl8192du_hal_deinit(struct r
  {
 	u8	u1bTmp;
 	u8	OpMode;
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(padapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
 	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
 
-_func_enter_;
+
 
 	if (RT_IN_PS_LEVEL(pwrpriv, RT_RF_OFF_LEVL_HALT_NIC))
 	{
@@ -2849,7 +2849,7 @@ _func_enter_;
 
 	padapter->bHaltInProgress = false;
 
-_func_exit_;
+
 
 	return _SUCCESS;
  }
@@ -2866,7 +2866,7 @@ static unsigned int rtl8192du_inirp_init
 	u32 (*_read_interrupt)(struct intf_hdl *pintfhdl, u32 addr);
 #endif
 
-_func_enter_;
+
 
 	_read_port = pintfhdl->io_ops._read_port;
 
@@ -2904,7 +2904,7 @@ exit:
 
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("<=== usb_inirp_init\n"));
 
-_func_exit_;
+
 
 	return status;
 }
@@ -2923,7 +2923,7 @@ static unsigned int rtl8192du_inirp_dein
 
 /*  */
 /*  */
-/* 	EEPROM/EFUSE Content Parsing */
+/*	EEPROM/EFUSE Content Parsing */
 /*  */
 /*  */
 
@@ -2934,7 +2934,7 @@ _ReadPROMVersion(
 	bool		AutoloadFail
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 
 	if (AutoloadFail) {
 		pHalData->EEPROMVersion = EEPROM_Default_Version;
@@ -2964,7 +2964,7 @@ _ReadIDs(
 	bool		AutoloadFail
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 
 
 	if (false == AutoloadFail) {
@@ -2987,7 +2987,7 @@ _ReadIDs(
 
 	}
 
-	/* 	Decide CustomerID according to VID/DID or EEPROM */
+	/*	Decide CustomerID according to VID/DID or EEPROM */
 	switch (pHalData->EEPROMCustomerID) {
 	case EEPROM_CID_WHQL:
 		break;
@@ -3009,7 +3009,7 @@ _ReadMACAddress(
 	bool		AutoloadFail
 	)
 {
-	struct hal_data_8192du 		*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du		*pHalData = GET_HAL_DATA(adapter);
 	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 
 	/*  Dual MAC should assign diffrent MAC address ,or, it is wil cause hang in single phy mode  zhiyuan 04/07/2010 */
@@ -3053,7 +3053,7 @@ hal_ReadMacPhyModeFromPROM92DU(
 	u8*		PROMContent
 )
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	u8	MacPhyCrValue = 0;
 
 
@@ -3097,7 +3097,7 @@ hal_ReadMacPhyMode_92D(
 )
 {
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 #endif /* CONFIG_DUALMAC_CONCURRENT */
 	u8	Mac1EnableValue = 0;
 
@@ -3146,7 +3146,7 @@ _ReadBoardType(
 	bool		AutoloadFail
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	u8			boardType;
 
 	if (AutoloadFail) {
@@ -3168,7 +3168,7 @@ _ReadLEDSetting(
 	bool		AutoloadFail
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	struct led_priv		*pledpriv = &(adapter->ledpriv);
 
 	/*  Led mode */
@@ -3281,7 +3281,7 @@ _InitOtherVariable(
 	struct rtw_adapter *		adapter
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 
 
 	/*  2009/06/10 MH For 92S 1*1=1R/ 1*2&2*2 use 2R. We default set 1*1 use radio A */
@@ -3300,7 +3300,7 @@ _ReadRFType(
 	struct rtw_adapter *	adapter
 	)
 {
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 
 #if DISABLE_BB_RF
 	pHalData->rf_chip = RF_PSEUDO_11N;
@@ -4167,7 +4167,7 @@ static void SetHwReg8192DU(struct rtw_ad
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
-_func_enter_;
+
 
 	switch (variable)
 	{
@@ -5002,14 +5002,14 @@ _func_enter_;
 			break;
 	}
 
-_func_exit_;
+
 }
 
 static void GetHwReg8192DU(struct rtw_adapter * adapter, u8 variable, u8* val)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 
-_func_enter_;
+
 
 	switch (variable)
 	{
@@ -5064,12 +5064,12 @@ _func_enter_;
 			break;
 	}
 
-_func_exit_;
+
 }
 
 /*  */
-/* 	Description: */
-/* 		Query setting of specified variable. */
+/*	Description: */
+/*		Query setting of specified variable. */
 /*  */
 static u8 GetHalDefVar8192DUsb(struct rtw_adapter * adapter, enum HAL_DEF_VARIABLE eVariable, void  *pValue)
 {
@@ -5100,8 +5100,8 @@ static u8 GetHalDefVar8192DUsb(struct rt
 }
 
 /*  */
-/* 	Description: */
-/* 		Change default setting of specified variable. */
+/*	Description: */
+/*		Change default setting of specified variable. */
 /*  */
 static u8 SetHalDefVar8192DUsb(
 	struct rtw_adapter *				adapter,
@@ -5399,7 +5399,7 @@ void rtl8192du_set_hal_ops(struct rtw_ad
 {
 	struct hal_ops	*pHalFunc = &padapter->HalFunc;
 
-_func_enter_;
+
 
 	padapter->HalData = kzalloc(sizeof(struct hal_data_8192du), GFP_KERNEL);
 	if (padapter->HalData == NULL) {
@@ -5451,5 +5451,5 @@ _func_enter_;
 
 	rtl8192d_set_hal_ops(pHalFunc);
 
-_func_exit_;
+
 }
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -51,8 +51,6 @@ static int usbctrl_vendorreq(struct intf
 	}
 #endif
 
-
-
 	if ((padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx)) {
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usbctrl_vendorreq:(padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
 		status = -EPERM;
@@ -69,7 +67,6 @@ static int usbctrl_vendorreq(struct intf
 	_enter_critical_mutex(&pdvobjpriv->usb_vendor_req_mutex);
 	#endif
 
-
 	/*  Acquire IO memory for vendorreq */
 #ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
 	pIo_buf = pdvobjpriv->usb_vendor_req_buf;
@@ -130,7 +127,7 @@ static int usbctrl_vendorreq(struct intf
 				} else {
 					#ifdef DBG_CONFIG_ERROR_DETECT
 					{
-						struct hal_data_8192du 	*pHalData = GET_HAL_DATA(padapter);
+						struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
 						pHalData->srestpriv.Wifi_Error_Status = USB_VEN_REQ_CMD_FAIL;
 					}
 					#endif
@@ -177,7 +174,7 @@ static void usb_read_reg_rf_byfw(struct
 	u16	wPage = 0x0000, offset;
 	u32	BufferLengthRead;
 	struct rtw_adapter *	adapter = pintfhdl->padapter;
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(adapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	u8	RFPath=0,nPHY=0;
 
 	RFPath =(u8) ((registerIndex&0xff0000)>>16);
@@ -206,7 +203,7 @@ static void usb_read_reg_rf_byfw(struct
 static void usb_read_reg(struct intf_hdl *pintfhdl, u16 value, void *pdata, u16 len)
 {
 	struct rtw_adapter		*padapter = pintfhdl->padapter;
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(padapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
 	u8	request;
 	u8	requesttype;
 	u16	index;
@@ -229,7 +226,7 @@ static void usb_read_reg(struct intf_hdl
 static int usb_write_reg(struct intf_hdl *pintfhdl, u16 value, void *pdata, u16 len)
 {
 	struct rtw_adapter		*padapter = pintfhdl->padapter;
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(padapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
 	u8	request;
 	u8	requesttype;
 	u16	index;
@@ -255,15 +252,11 @@ static u8 usb_read8(struct intf_hdl *pin
 	u16 len;
 	__le32 data;
 
-	_func_enter_;
-
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 1;
 
 	usb_read_reg(pintfhdl, wvalue, &data, len);
 
-	_func_exit_;
-
 	return (u8)(le32_to_cpu(data)&0x0ff);
 }
 
@@ -273,15 +266,11 @@ static u16 usb_read16(struct intf_hdl *p
 	u16 len;
 	__le32 data;
 
-	_func_enter_;
-
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 2;
 
 	usb_read_reg(pintfhdl, wvalue, &data, len);
 
-	_func_exit_;
-
 	return (u16)(le32_to_cpu(data)&0xffff);
 }
 
@@ -291,8 +280,6 @@ static u32 usb_read32(struct intf_hdl *p
 	u16 len;
 	__le32 data;
 
-	_func_enter_;
-
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 4;
 
@@ -303,8 +290,6 @@ static u32 usb_read32(struct intf_hdl *p
 		usb_read_reg(pintfhdl, wvalue, &data, len);
 	}
 
-	_func_exit_;
-
 	return le32_to_cpu(data);
 }
 
@@ -315,8 +300,6 @@ static int usb_write8(struct intf_hdl *p
 	__le32 data;
 	int ret;
 
-	_func_enter_;
-
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 1;
 
@@ -324,8 +307,6 @@ static int usb_write8(struct intf_hdl *p
 
 	ret = usb_write_reg(pintfhdl, wvalue, &data, len);
 
-	_func_exit_;
-
 	return ret;
 }
 
@@ -336,8 +317,6 @@ static int usb_write16(struct intf_hdl *
 	__le32 data;
 	int ret;
 
-	_func_enter_;
-
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 2;
 
@@ -345,8 +324,6 @@ static int usb_write16(struct intf_hdl *
 
 	ret = usb_write_reg(pintfhdl, wvalue, &data, len);
 
-	_func_exit_;
-
 	return ret;
 }
 
@@ -357,16 +334,12 @@ static int usb_write32(struct intf_hdl *
 	__le32 data;
 	int ret;
 
-	_func_enter_;
-
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 4;
 	data = cpu_to_le32(val);
 
 	ret = usb_write_reg(pintfhdl, wvalue, &data, len);
 
-	_func_exit_;
-
 	return ret;
 }
 
@@ -377,16 +350,12 @@ static int usb_writeN(struct intf_hdl *p
 	u8	buf[VENDOR_CMD_MAX_DATA_LEN]={0};
 	int	ret;
 
-	_func_enter_;
-
 	wvalue = (u16)(addr&0x0000ffff);
 	len = length;
 	 memcpy(buf, pdata, len);
 
 	ret = usb_write_reg(pintfhdl, wvalue, buf, len);
 
-	_func_exit_;
-
 	return ret;
 }
 
@@ -444,8 +413,6 @@ static u32 usb_read_interrupt(struct int
 	struct recv_priv	*precvpriv = &adapter->recvpriv;
 	struct usb_device	*pusbd = pdvobj->pusbdev;
 
-_func_enter_;
-
 	/* translate DMA FIFO addr to pipehandle */
 	pipe = ffaddr2pipehdl(pdvobj, addr);
 
@@ -463,8 +430,6 @@ _func_enter_;
 		ret = _FAIL;
 	}
 
-_func_exit_;
-
 	return ret;
 }
 #endif
@@ -496,7 +461,6 @@ static s32 pre_recv_entry(struct recv_fr
 			precvframe->adapter = secondary_padapter;
 		}
 
-
 	}
 	else /*  Handle BC/MC Packets */
 	{
@@ -523,9 +487,9 @@ static s32 pre_recv_entry(struct recv_fr
 
 				pattrib = &precvframe_if2->attrib;
 
-				/* 	Modified by Albert 20101213 */
-				/* 	For 8 bytes IP header alignment. */
-				if (pattrib->qos)	/* 	Qos data, wireless lan header length is 26 */
+				/*	Modified by Albert 20101213 */
+				/*	For 8 bytes IP header alignment. */
+				if (pattrib->qos)	/*	Qos data, wireless lan header length is 26 */
 				{
 					shift_sz = 6;
 				}
@@ -546,8 +510,8 @@ static s32 pre_recv_entry(struct recv_fr
 				}
 				else {
 					alloc_sz = skb_len;
-					/* 	6 is for IP header 8 bytes alignment in QoS packet case. */
-					/* 	8 is for skb->data 4 bytes alignment. */
+					/*	6 is for IP header 8 bytes alignment in QoS packet case. */
+					/*	8 is for skb->data 4 bytes alignment. */
 					alloc_sz += 14;
 				}
 
@@ -603,11 +567,10 @@ static int recvbuf2recvframe(struct rtw_
 	struct sk_buff *pkt_copy = NULL;
 	struct recv_frame_hdr	*precvframe = NULL;
 	struct rx_pkt_attrib	*pattrib = NULL;
-	struct hal_data_8192du 		*pHalData = GET_HAL_DATA(padapter);
+	struct hal_data_8192du		*pHalData = GET_HAL_DATA(padapter);
 	struct recv_priv	*precvpriv = &padapter->recvpriv;
 	struct __queue *pfree_recv_queue = &precvpriv->free_recv_queue;
 
-
 	transfer_len = (s32)precvbuf->transfer_len;
 	pbuf = precvbuf->pbuf;
 
@@ -651,9 +614,9 @@ static int recvbuf2recvframe(struct rtw_
 			goto _exit_recvbuf2recvframe;
 		}
 
-		/* 	Modified by Albert 20101213 */
-		/* 	For 8 bytes IP header alignment. */
-		if (pattrib->qos)	/* 	Qos data, wireless lan header length is 26 */
+		/*	Modified by Albert 20101213 */
+		/*	For 8 bytes IP header alignment. */
+		if (pattrib->qos)	/*	Qos data, wireless lan header length is 26 */
 		{
 			shift_sz = 6;
 		}
@@ -674,8 +637,8 @@ static int recvbuf2recvframe(struct rtw_
 		}
 		else {
 			alloc_sz = skb_len;
-			/* 	6 is for IP header 8 bytes alignment in QoS packet case. */
-			/* 	8 is for skb->data 4 bytes alignment. */
+			/*	6 is for IP header 8 bytes alignment in QoS packet case. */
+			/*	8 is for skb->data 4 bytes alignment. */
 			alloc_sz += 14;
 		}
 
@@ -767,7 +730,6 @@ _exit_recvbuf2recvframe:
 	return _SUCCESS;
 }
 
-
 void rtl8192du_recv_tasklet(void *priv)
 {
 	struct recv_buf *precvbuf = NULL;
@@ -783,7 +745,6 @@ void rtl8192du_recv_tasklet(void *priv)
 			break;
 		}
 
-
 		recvbuf2recvframe(padapter, precvbuf);
 
 		rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
@@ -857,7 +818,6 @@ static void usb_read_port_complete(struc
 
 exit:
 
-_func_exit_;
 }
 
 static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
@@ -871,8 +831,6 @@ static u32 usb_read_port(struct intf_hdl
 	struct recv_priv	*precvpriv = &adapter->recvpriv;
 	struct usb_device	*pusbd = pdvobj->pusbdev;
 
-_func_enter_;
-
 	if (adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:(padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
@@ -918,8 +876,6 @@ _func_enter_;
 		ret = _FAIL;
 	}
 
-_func_exit_;
-
 	return ret;
 }
 #else	/*  CONFIG_USE_USB_BUFFER_ALLOC_RX */
@@ -935,7 +891,7 @@ static int recvbuf2recvframe(struct rtw_
 	struct sk_buff *pkt_copy = NULL;
 	struct recv_frame_hdr	*precvframe = NULL;
 	struct rx_pkt_attrib	*pattrib = NULL;
-	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(padapter);
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
 	struct recv_priv	*precvpriv = &padapter->recvpriv;
 	struct __queue *pfree_recv_queue = &precvpriv->free_recv_queue;
 
@@ -982,9 +938,9 @@ static int recvbuf2recvframe(struct rtw_
 			goto _exit_recvbuf2recvframe;
 		}
 
-		/* 	Modified by Albert 20101213 */
-		/* 	For 8 bytes IP header alignment. */
-		if (pattrib->qos)	/* 	Qos data, wireless lan header length is 26 */
+		/*	Modified by Albert 20101213 */
+		/*	For 8 bytes IP header alignment. */
+		if (pattrib->qos)	/*	Qos data, wireless lan header length is 26 */
 		{
 			shift_sz = 6;
 		}
@@ -1005,8 +961,8 @@ static int recvbuf2recvframe(struct rtw_
 		}
 		else {
 			alloc_sz = skb_len;
-			/* 	6 is for IP header 8 bytes alignment in QoS packet case. */
-			/* 	8 is for skb->data 4 bytes alignment. */
+			/*	6 is for IP header 8 bytes alignment in QoS packet case. */
+			/*	8 is for skb->data 4 bytes alignment. */
 			alloc_sz += 14;
 		}
 
@@ -1098,7 +1054,6 @@ _exit_recvbuf2recvframe:
 	return _SUCCESS;
 }
 
-
 void rtl8192du_recv_tasklet(void *priv)
 {
 	struct sk_buff *pskb;
@@ -1130,7 +1085,6 @@ void rtl8192du_recv_tasklet(void *priv)
 	}
 }
 
-
 static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
 {
 	uint isevt, *pbuf;
@@ -1155,7 +1109,7 @@ static void usb_read_port_complete(struc
 		}
 	#endif
 
-		goto exit;
+		return;
 	}
 
 	if (purb->status==0)/* SUCCESS */
@@ -1165,9 +1119,7 @@ static void usb_read_port_complete(struc
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n"));
 			precvbuf->reuse = true;
 			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-		}
-		else
-		{
+		} else {
 			precvbuf->transfer_len = purb->actual_length;
 
 			skb_put(precvbuf->pskb, purb->actual_length);
@@ -1180,40 +1132,35 @@ static void usb_read_port_complete(struc
 			precvbuf->reuse = false;
 			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
 		}
-	}
-	else
-	{
+	} else {
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete : purb->status(%d) != 0\n", purb->status));
 
 		DBG_8192D("###=> usb_read_port_complete => urb status(%d)\n", purb->status);
 
 		switch (purb->status) {
-			case -EINVAL:
-			case -EPIPE:
-			case -ENODEV:
-			case -ESHUTDOWN:
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
-			case -ENOENT:
-				padapter->bDriverStopped=true;
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
-				break;
-			case -EPROTO:
-			case -EOVERFLOW:
-				precvbuf->reuse = true;
-				rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-				break;
-			case -EINPROGRESS:
-				DBG_8192D("ERROR: URB IS IN PROGRESS!/n");
-				break;
-			default:
-				break;
+		case -EINVAL:
+		case -EPIPE:
+		case -ENODEV:
+		case -ESHUTDOWN:
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
+		case -ENOENT:
+			padapter->bDriverStopped=true;
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
+			break;
+		case -EPROTO:
+		case -EOVERFLOW:
+			precvbuf->reuse = true;
+			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+			break;
+		case -EINPROGRESS:
+			DBG_8192D("ERROR: URB IS IN PROGRESS!/n");
+			break;
+		default:
+			break;
 		}
 
 	}
 
-exit:
-
-_func_exit_;
 }
 
 static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
@@ -1229,7 +1176,6 @@ static u32 usb_read_port(struct intf_hdl
 	struct recv_priv	*precvpriv = &adapter->recvpriv;
 	struct usb_device	*pusbd = pdvobj->pusbdev;
 
-_func_enter_;
 	if (adapter->bDriverStopped || adapter->bSurpriseRemoved ||
 	    adapter->pwrctrlpriv.pnp_bstop_trx) {
 		RT_TRACE(_module_hci_ops_os_c_, _drv_err_,
@@ -1305,8 +1251,6 @@ _func_enter_;
 		}
 	}
 
-_func_exit_;
-
 	return ret;
 }
 #endif	/*  CONFIG_USE_USB_BUFFER_ALLOC_RX */
@@ -1339,7 +1283,6 @@ void rtl8192du_xmit_tasklet(void *priv)
 
 void rtl8192du_set_intf_ops(struct _io_ops	*pops)
 {
-	_func_enter_;
 
 	memset((u8 *)pops, 0, sizeof(struct _io_ops));
 
@@ -1369,5 +1312,4 @@ void rtl8192du_set_intf_ops(struct _io_o
 	pops->_read_interrupt = &usb_read_interrupt;
 #endif
 
-	_func_exit_;
 }
--- a/drivers/staging/rtl8192du/include/rtw_debug.h
+++ b/drivers/staging/rtl8192du/include/rtw_debug.h
@@ -146,8 +146,6 @@
 #endif
 
 #define RT_TRACE(_Comp, _Level, Fmt) do{}while (0)
-#define _func_enter_ do{}while (0)
-#define _func_exit_ do{}while (0)
 #define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen) do{}while (0)
 
 #undef	_dbgdump
@@ -172,24 +170,6 @@
 #endif
 
 #if defined (_dbgdump)
-	#undef  _func_enter_
-	#define _func_enter_						\
-	do {								\
-		if (GlobalDebugLevel >= _drv_debug_) {			\
-			_dbgdump("\n %s : %s enters at %d\n",		\
-				 RTL871X_MODULE_NAME, __func__, __LINE__);\
-		}						\
-	} while (0)
-
-	#undef  _func_exit_
-	#define _func_exit_						\
-	do {								\
-		if (GlobalDebugLevel >= _drv_debug_) {			\
-			_dbgdump("\n %s : %s exits at %d\n",		\
-				 RTL871X_MODULE_NAME, __func__, __LINE__); \
-		}							\
-	} while (0)
-
 	#undef RT_PRINT_DATA
 	#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData,	\
 			      _HexDataLen)				\
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -989,7 +989,7 @@ static int rtw_cfg80211_set_encryption(s
 	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
 #endif /* CONFIG_P2P */
 
-_func_enter_;
+
 
 	DBG_8192C("%s\n", __func__);
 
@@ -1149,7 +1149,7 @@ exit:
 
 	DBG_8192C("%s, ret=%d\n", __func__, ret);
 
-	_func_exit_;
+
 
 	return ret;
 }
@@ -3754,45 +3754,45 @@ void rtw_cfg80211_issue_p2p_provision_re
 
 
 	/* build_prov_disc_request_p2p_ie */
-	/* 	P2P OUI */
+	/*	P2P OUI */
 	p2pielen = 0;
 	p2p_ie[p2pielen++] = 0x50;
 	p2p_ie[p2pielen++] = 0x6F;
 	p2p_ie[p2pielen++] = 0x9A;
-	p2p_ie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
+	p2p_ie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
 
-	/* 	Commented by Albert 20110301 */
-	/* 	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes */
-	/* 	1. P2P Capability */
-	/* 	2. Device Info */
-	/* 	3. Group ID (When joining an operating P2P Group) */
+	/*	Commented by Albert 20110301 */
+	/*	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes */
+	/*	1. P2P Capability */
+	/*	2. Device Info */
+	/*	3. Group ID (When joining an operating P2P Group) */
 
-	/* 	P2P Capability ATTR */
-	/* 	Type: */
+	/*	P2P Capability ATTR */
+	/*	Type: */
 	p2p_ie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
-	/* 	Length: */
+	/*	Length: */
 	RTW_PUT_LE16(p2p_ie + p2pielen, 0x0002);
 	p2pielen += 2;
 
-	/* 	Value: */
-	/* 	Device Capability Bitmap, 1 byte */
-	/* 	Group Capability Bitmap, 1 byte */
+	/*	Value: */
+	/*	Device Capability Bitmap, 1 byte */
+	/*	Group Capability Bitmap, 1 byte */
 	memcpy(p2p_ie + p2pielen, &capability, 2);
 	p2pielen += 2;
 
 
-	/* 	Device Info ATTR */
-	/* 	Type: */
+	/*	Device Info ATTR */
+	/*	Type: */
 	p2p_ie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
 
-	/* 	Length: */
-	/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
-	/* 	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
+	/*	Length: */
+	/*	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
+	/*	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
 	RTW_PUT_LE16(p2p_ie + p2pielen, devinfo_contentlen);
 	p2pielen += 2;
 
-	/* 	Value: */
+	/*	Value: */
 	memcpy(p2p_ie + p2pielen, devinfo_content, devinfo_contentlen);
 	p2pielen += devinfo_contentlen;
 
@@ -3801,32 +3801,32 @@ void rtw_cfg80211_issue_p2p_provision_re
 	pattrib->pktlen += p2p_ielen;
 
 	wpsielen = 0;
-	/* 	WPS OUI */
+	/*	WPS OUI */
 	*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 	wpsielen += 4;
 
-	/* 	WPS version */
-	/* 	Type: */
+	/*	WPS version */
+	/*	Type: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 	wpsielen += 2;
 
-	/* 	Length: */
+	/*	Length: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 	wpsielen += 2;
 
-	/* 	Value: */
-	wpsie[wpsielen++] = WPS_VERSION_1;	/* 	Version 1.0 */
+	/*	Value: */
+	wpsie[wpsielen++] = WPS_VERSION_1;	/*	Version 1.0 */
 
-	/* 	Config Method */
-	/* 	Type: */
+	/*	Config Method */
+	/*	Type: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
 	wpsielen += 2;
 
-	/* 	Length: */
+	/*	Length: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 	wpsielen += 2;
 
-	/* 	Value: */
+	/*	Value: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->tx_prov_disc_info.wps_config_method_request);
 	wpsielen += 2;
 
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -587,7 +587,7 @@ static int wpa_set_encryption(struct net
 	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
 #endif /* CONFIG_P2P */
 
-_func_enter_;
+
 
 	param->u.crypt.err = 0;
 	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
@@ -744,7 +744,7 @@ exit:
 
 	kfree(pwep);
 
-	_func_exit_;
+
 
 	return ret;
 }
@@ -918,7 +918,7 @@ static int rtw_wx_get_name(struct net_de
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("cmd_code =%x\n", info->cmd));
 
-	_func_enter_;
+
 
 	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {
 		/* parsing HT_CAP_IE */
@@ -955,7 +955,7 @@ static int rtw_wx_get_name(struct net_de
 		snprintf(wrqu->name, IFNAMSIZ, "unassociated");
 	}
 
-	_func_exit_;
+
 
 	return 0;
 }
@@ -964,11 +964,11 @@ static int rtw_wx_set_freq(struct net_de
 			   struct iw_request_info *info,
 			   union iwreq_data *wrqu, char *extra)
 {
-	_func_enter_;
+
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+rtw_wx_set_freq\n"));
 
-	_func_exit_;
+
 
 	return 0;
 }
@@ -1002,7 +1002,7 @@ static int rtw_wx_set_mode(struct net_de
 	int ret = 0;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct __queue *queue = &pmlmepriv->scanned_queue;
-	_func_enter_;
+
 
 	if (_FAIL == rtw_pwr_wakeup(padapter)) {
 		ret = -EPERM;
@@ -1055,7 +1055,7 @@ static int rtw_wx_set_mode(struct net_de
 
 exit:
 
-	_func_exit_;
+
 
 	return ret;
 }
@@ -1068,7 +1068,7 @@ static int rtw_wx_get_mode(struct net_de
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, (" rtw_wx_get_mode\n"));
 
-	_func_enter_;
+
 
 	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 		wrqu->mode = IW_MODE_INFRA;
@@ -1080,7 +1080,7 @@ static int rtw_wx_get_mode(struct net_de
 	else
 		wrqu->mode = IW_MODE_AUTO;
 
-	_func_exit_;
+
 
 	return 0;
 }
@@ -1175,7 +1175,7 @@ static int rtw_wx_get_range(struct net_d
 	u16 val;
 	int i;
 
-	_func_enter_;
+
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_range. cmd_code =%x\n", info->cmd));
 
@@ -1266,7 +1266,7 @@ static int rtw_wx_get_range(struct net_d
 					IW_SCAN_CAPA_CHANNEL|IW_SCAN_CAPA_MODE|IW_SCAN_CAPA_RATE;
 #endif
 
-	_func_exit_;
+
 
 	return 0;
 }
@@ -1291,7 +1291,7 @@ static int rtw_wx_set_wap(struct net_dev
 	struct	wlan_network	*pnetwork = NULL;
 	enum NDIS_802_11_AUTHENTICATION_MODE	authmode;
 
-	_func_enter_;
+
 /*
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type > PRIMARY_IFACE)
@@ -1378,7 +1378,7 @@ static int rtw_wx_set_wap(struct net_dev
 
 exit:
 
-	_func_exit_;
+
 
 	return ret;
 }
@@ -1398,7 +1398,7 @@ static int rtw_wx_get_wap(struct net_dev
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_wap\n"));
 
-	_func_enter_;
+
 
 	if  (((check_fwstate(pmlmepriv, _FW_LINKED)) == true) ||
 			((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) ||
@@ -1412,7 +1412,7 @@ static int rtw_wx_get_wap(struct net_dev
 		memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
 	}
 
-	_func_exit_;
+
 
 	return 0;
 }
@@ -1463,7 +1463,7 @@ static int rtw_wx_set_scan(struct net_de
 #endif /* CONFIG_P2P */
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_set_scan\n"));
 
-_func_enter_;
+
 
 	#ifdef DBG_IOCTL
 	DBG_8192D("DBG_IOCTL %s:%d\n", __func__, __LINE__);
@@ -1640,7 +1640,7 @@ exit:
 	DBG_8192D("DBG_IOCTL %s:%d return %d\n", __func__, __LINE__, ret);
 	#endif
 
-_func_exit_;
+
 
 	return ret;
 }
@@ -1667,7 +1667,7 @@ static int rtw_wx_get_scan(struct net_de
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan\n"));
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, (" Start of Query SIOCGIWSCAN .\n"));
 
-	_func_enter_;
+
 
 	#ifdef DBG_IOCTL
 	DBG_8192D("DBG_IOCTL %s:%d\n", __func__, __LINE__);
@@ -1761,7 +1761,7 @@ static int rtw_wx_get_scan(struct net_de
 
 exit:
 
-	_func_exit_;
+
 
 	#ifdef DBG_IOCTL
 	DBG_8192D("DBG_IOCTL %s:%d return %d\n", __func__, __LINE__, ret);
@@ -1792,7 +1792,7 @@ static int rtw_wx_set_essid(struct net_d
 
 	uint ret = 0, len;
 
-	_func_enter_;
+
 
 	#ifdef DBG_IOCTL
 	DBG_8192D("DBG_IOCTL %s:%d\n", __func__, __LINE__);
@@ -1945,7 +1945,7 @@ exit:
 	DBG_8192D("DBG_IOCTL %s:%d return %d\n", __func__, __LINE__, ret);
 	#endif
 
-	_func_exit_;
+
 
 	return ret;
 }
@@ -1961,7 +1961,7 @@ static int rtw_wx_get_essid(struct net_d
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_essid\n"));
 
-	_func_enter_;
+
 
 	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
 	      (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))
@@ -1982,7 +1982,7 @@ static int rtw_wx_get_essid(struct net_d
 
 exit:
 
-	_func_exit_;
+
 
 	return ret;
 }
@@ -1999,7 +1999,7 @@ static int rtw_wx_set_rate(struct net_de
 	u32	ratevalue = 0;
 	 u8 mpdatarate[NUMRATES]={11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};
 
-_func_enter_;
+
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, (" rtw_wx_set_rate\n"));
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("target_rate = %d, fixed = %d\n", target_rate, fixed));
@@ -2071,7 +2071,7 @@ set_rate:
 		ret = -1;
 	}
 
-_func_exit_;
+
 
 	return ret;
 }
@@ -2099,7 +2099,7 @@ static int rtw_wx_set_rts(struct net_dev
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-	_func_enter_;
+
 
 	if (wrqu->rts.disabled)
 		padapter->registrypriv.rts_thresh = 2347;
@@ -2113,7 +2113,7 @@ static int rtw_wx_set_rts(struct net_dev
 
 	DBG_8192D("%s, rts_thresh =%d\n", __func__, padapter->registrypriv.rts_thresh);
 
-	_func_exit_;
+
 
 	return 0;
 }
@@ -2124,14 +2124,14 @@ static int rtw_wx_get_rts(struct net_dev
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-	_func_enter_;
+
 
 	DBG_8192D("%s, rts_thresh =%d\n", __func__, padapter->registrypriv.rts_thresh);
 
 	wrqu->rts.value = padapter->registrypriv.rts_thresh;
 	wrqu->rts.fixed = 0;	/* no auto select */
 
-	_func_exit_;
+
 
 	return 0;
 }
@@ -2142,7 +2142,7 @@ static int rtw_wx_set_frag(struct net_de
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-	_func_enter_;
+
 
 	if (wrqu->frag.disabled)
 		padapter->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;
@@ -2156,7 +2156,7 @@ static int rtw_wx_set_frag(struct net_de
 
 	DBG_8192D("%s, frag_len =%d\n", __func__, padapter->xmitpriv.frag_len);
 
-	_func_exit_;
+
 
 	return 0;
 }
@@ -2167,14 +2167,14 @@ static int rtw_wx_get_frag(struct net_de
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-	_func_enter_;
+
 
 	DBG_8192D("%s, frag_len =%d\n", __func__, padapter->xmitpriv.frag_len);
 
 	wrqu->frag.value = padapter->xmitpriv.frag_len;
 	wrqu->frag.fixed = 0;	/* no auto select */
 
-	_func_exit_;
+
 
 	return 0;
 }
@@ -2208,7 +2208,7 @@ static int rtw_wx_set_enc(struct net_dev
 
 	key = erq->flags & IW_ENCODE_INDEX;
 
-	_func_enter_;
+
 
 	if (erq->flags & IW_ENCODE_DISABLED)
 	{
@@ -2321,7 +2321,7 @@ static int rtw_wx_set_enc(struct net_dev
 
 exit:
 
-	_func_exit_;
+
 
 	return ret;
 }
@@ -2335,7 +2335,7 @@ static int rtw_wx_get_enc(struct net_dev
 	struct iw_point *erq = &(wrqu->encoding);
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 
-	_func_enter_;
+
 
 	if (check_fwstate(pmlmepriv, _FW_LINKED) != true)
 	{
@@ -2413,7 +2413,7 @@ static int rtw_wx_get_enc(struct net_dev
 
 	}
 
-	_func_exit_;
+
 
 	return ret;
 }
@@ -3357,7 +3357,7 @@ static int rtw_p2p_set_intent(struct net
 
 static int rtw_p2p_set_listen_ch(struct net_device *dev,
 				 struct iw_request_info *info,
-       				 union iwreq_data *wrqu, char *extra)
+				 union iwreq_data *wrqu, char *extra)
 {
 
 	int ret = 0;
--- a/drivers/staging/rtl8192du/os_dep/mlme_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/mlme_linux.c
@@ -21,7 +21,7 @@
 #include <osdep_service.h>
 #include <drv_types.h>
 #include <mlme_osdep.h>
-                               
+
 void rtw_join_timeout_handler (void *FunctionContext)
 {
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
@@ -71,7 +71,7 @@ void rtw_init_mlme_timer(struct rtw_adap
 void rtw_os_indicate_connect(struct rtw_adapter *adapter)
 {
 
-_func_enter_;
+
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_cfg80211_indicate_connect(adapter);
@@ -83,7 +83,7 @@ _func_enter_;
 	if (adapter->pid[2] !=0)
 		rtw_signal_process(adapter->pid[2], SIGALRM);
 
-_func_exit_;
+
 }
 
 void rtw_os_indicate_scan_done(struct rtw_adapter *padapter, bool aborted)
@@ -149,7 +149,7 @@ void rtw_reset_securitypriv(struct rtw_a
 void rtw_os_indicate_disconnect(struct rtw_adapter *adapter)
 {
 
-_func_enter_;
+
 
 	netif_carrier_off(adapter->pnetdev); /*  Do it first for tx broadcast pkt after disconnection issue! */
 
@@ -161,7 +161,7 @@ _func_enter_;
 
 	 rtw_reset_securitypriv(adapter);
 
-_func_exit_;
+
 }
 
 void rtw_report_sec_ie(struct rtw_adapter *adapter,u8 authmode,u8 *sec_ie)
@@ -170,7 +170,7 @@ void rtw_report_sec_ie(struct rtw_adapte
 	u8	*buff,*p,i;
 	union iwreq_data wrqu;
 
-_func_enter_;
+
 
 	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+rtw_report_sec_ie, authmode=%d\n", authmode));
 
@@ -208,7 +208,7 @@ _func_enter_;
 
 	}
 
-_func_exit_;
+
 }
 
 static void _survey_timer_hdl (void *FunctionContext)
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -662,7 +662,7 @@ static uint loadparam(struct rtw_adapter
 	uint status = _SUCCESS;
 	struct registry_priv  *registry_par = &padapter->registrypriv;
 
-_func_enter_;
+
 
 	registry_par->chip_version = (u8)rtw_chip_version;
 	registry_par->rfintfs = (u8)rtw_rfintfs;
@@ -771,7 +771,7 @@ _func_enter_;
 	registry_par->ext_iface_num = (u8)rtw_ext_iface_num;
 #endif /* CONFIG_MULTI_VIR_IFACES */
 
-_func_exit_;
+
 
 	return status;
 }
@@ -1204,7 +1204,7 @@ u8 rtw_init_drv_sw(struct rtw_adapter *p
 
 	u8	ret8 = _SUCCESS;
 
-_func_enter_;
+
 
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_init_drv_sw\n"));
 
@@ -1317,7 +1317,7 @@ exit:
 
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-rtw_init_drv_sw\n"));
 
-	_func_exit_;
+
 
 	return ret8;
 }
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -222,7 +222,7 @@ int rtw_recv_indicatepkt(struct rtw_adap
 	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
 #endif
 
-_func_enter_;
+
 
 	precvpriv = &(padapter->recvpriv);
 	pfree_recv_queue = &(precvpriv->free_recv_queue);
@@ -320,7 +320,7 @@ _recv_indicatepkt_end:
 
 	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n rtw_recv_indicatepkt :after netif_rx!!!!\n"));
 
-_func_exit_;
+
 
         return _SUCCESS;
 
@@ -329,7 +329,7 @@ _recv_indicatepkt_drop:
 	 /* enqueue back to free_recv_queue */
 	 rtw_free_recvframe(precv_frame, pfree_recv_queue);
 
-_func_exit_;
+
 	 return _FAIL;
 }
 
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -308,7 +308,7 @@ static int get_int_from_command(char* pc
 	{
 		if (pcmd[i] == '=')
 		{
-			/* 	Skip the '=' and space characters. */
+			/*	Skip the '=' and space characters. */
 			i += 2;
 			break;
 		}
@@ -451,9 +451,9 @@ int rtw_android_priv_cmd(struct net_devi
 #ifdef CONFIG_WFD
 	case ANDROID_WIFI_CMD_WFD_ENABLE:
 	{
-		/* 	Commented by Albert 2012/07/24 */
-		/* 	We can enable the WFD function by using the following command: */
-		/* 	wpa_cli driver wfd-enable */
+		/*	Commented by Albert 2012/07/24 */
+		/*	We can enable the WFD function by using the following command: */
+		/*	wpa_cli driver wfd-enable */
 
 		struct wifi_display_info		*pwfd_info;
 		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
@@ -464,9 +464,9 @@ int rtw_android_priv_cmd(struct net_devi
 	}
 	case ANDROID_WIFI_CMD_WFD_DISABLE:
 	{
-		/* 	Commented by Albert 2012/07/24 */
-		/* 	We can disable the WFD function by using the following command: */
-		/* 	wpa_cli driver wfd-disable */
+		/*	Commented by Albert 2012/07/24 */
+		/*	We can disable the WFD function by using the following command: */
+		/*	wpa_cli driver wfd-disable */
 
 		struct wifi_display_info		*pwfd_info;
 		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
@@ -477,9 +477,9 @@ int rtw_android_priv_cmd(struct net_devi
 	}
 	case ANDROID_WIFI_CMD_WFD_SET_TCPPORT:
 	{
-		/* 	Commented by Albert 2012/07/24 */
-		/* 	We can set the tcp port number by using the following command: */
-		/* 	wpa_cli driver wfd-set-tcpport = 554 */
+		/*	Commented by Albert 2012/07/24 */
+		/*	We can set the tcp port number by using the following command: */
+		/*	wpa_cli driver wfd-set-tcpport = 554 */
 
 		struct wifi_display_info		*pwfd_info;
 		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
@@ -492,8 +492,8 @@ int rtw_android_priv_cmd(struct net_devi
 		break;
 	case ANDROID_WIFI_CMD_WFD_SET_DEVTYPE:
 	{
-		/* 	Commented by Albert 2012/08/28 */
-		/* 	Specify the WFD device type (WFD source/primary sink) */
+		/*	Commented by Albert 2012/08/28 */
+		/*	Specify the WFD device type (WFD source/primary sink) */
 
 		struct wifi_display_info		*pwfd_info;
 		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -297,7 +297,7 @@ static struct dvobj_priv *usb_dvobj_init
 	struct usb_host_endpoint		*phost_endp;
 	struct usb_endpoint_descriptor	*pendp_desc;
 
-_func_enter_;
+
 
 	pdvobjpriv = (struct dvobj_priv*)kzalloc(sizeof(*pdvobjpriv), GFP_KERNEL);
 	if (!pdvobjpriv)
@@ -387,7 +387,7 @@ free_dvobj:
 		pdvobjpriv = NULL;
 	}
 exit:
-_func_exit_;
+
 	return pdvobjpriv;
 }
 
@@ -395,7 +395,7 @@ static void usb_dvobj_deinit(struct usb_
 {
 	struct dvobj_priv *dvobj = usb_get_intfdata(usb_intf);
 
-_func_enter_;
+
 
 	usb_set_intfdata(usb_intf, NULL);
 	if (dvobj) {
@@ -410,7 +410,7 @@ _func_enter_;
 
 	usb_put_dev(interface_to_usbdev(usb_intf));
 
-_func_exit_;
+
 }
 
 static void decide_chip_type_by_usb_device_id(struct rtw_adapter *padapter, const struct usb_device_id *pdid)
@@ -541,7 +541,7 @@ int rtw_hw_suspend(struct rtw_adapter *p
 	struct usb_interface *pusb_intf = adapter_to_dvobj(padapter)->pusbintf;
 	struct net_device *pnetdev = padapter->pnetdev;
 
-	_func_enter_;
+
 
 	if ((!padapter->bup) || (padapter->bDriverStopped)||(padapter->bSurpriseRemoved))
 	{
@@ -602,7 +602,7 @@ int rtw_hw_suspend(struct rtw_adapter *p
 	else
 		goto error_exit;
 
-	_func_exit_;
+
 	return 0;
 
 error_exit:
@@ -616,7 +616,7 @@ int rtw_hw_resume(struct rtw_adapter *pa
 	struct usb_interface *pusb_intf = adapter_to_dvobj(padapter)->pusbintf;
 	struct net_device *pnetdev = padapter->pnetdev;
 
-	_func_enter_;
+
 
 	if (padapter)/* system resume */
 	{
@@ -652,7 +652,7 @@ int rtw_hw_resume(struct rtw_adapter *pa
 		goto error_exit;
 	}
 
-	_func_exit_;
+
 
 	return 0;
 error_exit:
@@ -674,7 +674,7 @@ static int rtw_suspend(struct usb_interf
 #endif /*  CONFIG_WOWLAN */
 	int ret = 0;
 	u32 start_time = rtw_get_current_time();
-	_func_enter_;
+
 
 	DBG_8192D("==> %s (%s:%d)\n",__func__, current->comm, current->pid);
 
@@ -761,7 +761,7 @@ exit:
 	DBG_8192D("<===  %s return %d.............. in %dms\n", __func__
 		, ret, rtw_get_passing_time_ms(start_time));
 
-	_func_exit_;
+
 	return ret;
 }
 
@@ -801,7 +801,7 @@ int rtw_resume_process(struct rtw_adapte
 	struct pwrctrl_priv *pwrpriv = NULL;
 	int ret = -1;
 	u32 start_time = rtw_get_current_time();
-	_func_enter_;
+
 
 	DBG_8192D("==> %s (%s:%d)\n",__func__, current->comm, current->pid);
 
@@ -881,7 +881,7 @@ exit:
 	DBG_8192D("<===  %s return %d.............. in %dms\n", __func__
 		, ret, rtw_get_passing_time_ms(start_time));
 
-	_func_exit_;
+
 
 	return ret;
 }
@@ -1259,7 +1259,7 @@ static void rtw_dev_remove(struct usb_in
 	struct dvobj_priv *dvobj = usb_get_intfdata(pusb_intf);
 	struct rtw_adapter *padapter = dvobj->if1;
 
-_func_exit_;
+
 
 	DBG_8192D("+rtw_dev_remove\n");
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+dev_remove()\n"));
@@ -1298,7 +1298,7 @@ _func_exit_;
 
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-dev_remove()\n"));
 	DBG_8192D("-r871xu_dev_remove, done\n");
-_func_exit_;
+
 	return;
 }
 
--- a/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
@@ -117,10 +117,10 @@ int usb_async_write8(struct intf_hdl *pi
 	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
 	struct usb_device *udev=pdvobjpriv->pusbdev;
 
-	_func_enter_;
+
 	data = val;
 	ret = usb_write_async(udev, addr, &data, 1);
-	_func_exit_;
+
 
 	return ret;
 }
@@ -132,10 +132,10 @@ int usb_async_write16(struct intf_hdl *p
 	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
 	struct usb_device *udev=pdvobjpriv->pusbdev;
 
-	_func_enter_;
+
 	data = val;
 	ret = usb_write_async(udev, addr, data, 2);
-	_func_exit_;
+
 
 	return ret;
 }
@@ -147,10 +147,10 @@ int usb_async_write32(struct intf_hdl *p
 	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
 	struct usb_device *udev=pdvobjpriv->pusbdev;
 
-	_func_enter_;
+
 	data = val;
 	ret = usb_write_async(udev, addr, data, 4);
-	_func_exit_;
+
 
 	return ret;
 }
@@ -295,7 +295,7 @@ static void usb_write_port_complete(stru
 	struct rtw_adapter	*padapter = pxmitbuf->padapter;
        struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 
-_func_enter_;
+
 
 	switch (pxmitbuf->flags)
 	{
@@ -369,7 +369,7 @@ _func_enter_;
 
 	#ifdef DBG_CONFIG_ERROR_DETECT
 	{
-		struct hal_data_8192du 	*pHalData = GET_HAL_DATA(padapter);
+		struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
 		pHalData->srestpriv.last_tx_complete_time = rtw_get_current_time();
 	}
 	#endif
@@ -384,7 +384,7 @@ check_completion:
 		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
 	}
 
-_func_exit_;
+
 }
 
 u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
@@ -402,7 +402,7 @@ u32 usb_write_port(struct intf_hdl *pint
 	struct usb_device *pusbd = pdvobj->pusbdev;
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
 
-_func_enter_;
+
 
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port\n"));
 
@@ -476,7 +476,7 @@ _func_enter_;
 	if (!status) {
 		#ifdef DBG_CONFIG_ERROR_DETECT
 		{
-			struct hal_data_8192du 	*pHalData = GET_HAL_DATA(padapter);
+			struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
 			pHalData->srestpriv.last_tx_time = rtw_get_current_time();
 		}
 		#endif
@@ -500,7 +500,7 @@ _func_enter_;
 exit:
 	if (ret != _SUCCESS)
 		rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
-_func_exit_;
+
 	return ret;
 }
 
--- a/drivers/staging/rtl8192du/os_dep/xmit_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/xmit_linux.c
@@ -34,7 +34,7 @@ uint rtw_remainder_len(struct pkt_file *
 
 void _rtw_open_pktfile (struct sk_buff *pktptr, struct pkt_file *pfile)
 {
-_func_enter_;
+
 
 	pfile->pkt = pktptr;
 	pfile->cur_addr = pfile->buf_start = pktptr->data;
@@ -42,14 +42,14 @@ _func_enter_;
 
 	pfile->cur_buffer = pfile->buf_start ;
 
-_func_exit_;
+
 }
 
 uint _rtw_pktfile_read (struct pkt_file *pfile, u8 *rmem, uint rlen)
 {
 	uint	len = 0;
 
-_func_enter_;
+
 
        len =  rtw_remainder_len(pfile);
 	len = (rlen > len)? len: rlen;
@@ -60,21 +60,21 @@ _func_enter_;
        pfile->cur_addr += len;
        pfile->pkt_len -= len;
 
-_func_exit_;
+
 
 	return len;
 }
 
 int rtw_endofpktfile(struct pkt_file *pfile)
 {
-_func_enter_;
+
 
 	if (pfile->pkt_len == 0) {
-_func_exit_;
+
 		return true;
 	}
 
-_func_exit_;
+
 
 	return false;
 }
@@ -282,7 +282,7 @@ int rtw_xmit_entry(struct sk_buff *pkt,
 	u16 queue;
 #endif
 
-_func_enter_;
+
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("+xmit_enry\n"));
 
@@ -337,7 +337,7 @@ drop_packet:
 
 exit:
 
-_func_exit_;
+
 
 	return 0;
 }

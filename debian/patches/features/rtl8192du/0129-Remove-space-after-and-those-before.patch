From b1a1b13f35a0948844f94309876587202f1f20f4 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sun, 5 May 2013 23:05:40 -0500
Subject: [PATCH 129/390] Remove space after [ and those before ]

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_mlme.c         |   8 +-
 core/rtw_mlme_ext.c     | 422 +++++++++++++++++++--------------------
 core/rtw_p2p.c          | 512 ++++++++++++++++++++++++------------------------
 core/rtw_security.c     |  12 +-
 core/rtw_sta_mgt.c      |   2 +-
 core/rtw_tdls.c         |  28 +--
 core/rtw_wlan_util.c    |   4 +-
 include/if_ether.h      |   2 +-
 include/rtw_mlme.h      |  32 +--
 os_dep/ioctl_cfg80211.c |  18 +-
 os_dep/ioctl_linux.c    | 170 ++++++++--------
 os_dep/mlme_linux.c     |  10 +-
 os_dep/recv_linux.c     |   4 +-
 os_dep/rtw_android.c    |   2 +-
 14 files changed, 613 insertions(+), 613 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -2589,12 +2589,12 @@ int rtw_restruct_wmm_ie(struct rtw_adapt
 			/* Append WMM IE to the last index of out_ie */
                         for (j = i; j < i + 9; j++)
                         {
-                            out_ie[ ielength] = in_ie[ j ];
+                            out_ie[ielength] = in_ie[j];
                             ielength++;
                         }
-                        out_ie[ initial_out_len + 1 ] = 0x07;
-                        out_ie[ initial_out_len + 6 ] = 0x00;
-                        out_ie[ initial_out_len + 8 ] = 0x00;
+                        out_ie[initial_out_len + 1] = 0x07;
+                        out_ie[initial_out_len + 6] = 0x00;
+                        out_ie[initial_out_len + 8] = 0x00;
 
 			break;
 		}
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -1359,7 +1359,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 	u8 *p2pie;
 	u32 p2pielen = 0;
 #ifdef CONFIG_WFD
-	u8	wfd_ie[ 128 ] = { 0x00 };
+	u8	wfd_ie[128] = { 0x00 };
 	u32	wfd_ielen = 0;
 #endif /*  CONFIG_WFD */
 #endif /* CONFIG_P2P */
@@ -1776,7 +1776,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 #ifdef CONFIG_WFD
 		if (rtw_get_wfd_ie(pframe + WLAN_HDR_A3_LEN + ie_offset , pkt_len - WLAN_HDR_A3_LEN - ie_offset , wfd_ie, &wfd_ielen))
 		{
-			u8	attr_content[ 10 ] = { 0x00 };
+			u8	attr_content[10] = { 0x00 };
 			u32	attr_contentlen = 0;
 
 			DBG_8192D("[%s] WFD IE Found!!\n", __func__);
@@ -2419,16 +2419,16 @@ static void get_channel_cnt_24g_5gl_5gh(
 
 	for (i = 0; i < pmlmeext->max_chan_nums; i++)
 	{
-		if (pmlmeext->channel_set[ i ].ChannelNum <= 14)
+		if (pmlmeext->channel_set[i].ChannelNum <= 14)
 		{
 			(*p24g_cnt)++;
 		}
-		else if ((pmlmeext->channel_set[ i ].ChannelNum > 14) && (pmlmeext->channel_set[ i ].ChannelNum <= 48))
+		else if ((pmlmeext->channel_set[i].ChannelNum > 14) && (pmlmeext->channel_set[i].ChannelNum <= 48))
 		{
 			/* 	Just include the channel 36, 40, 44, 48 channels for 5G low */
 			(*p5gl_cnt)++;
 		}
-		else if ((pmlmeext->channel_set[ i ].ChannelNum >= 149) && (pmlmeext->channel_set[ i ].ChannelNum <= 161))
+		else if ((pmlmeext->channel_set[i].ChannelNum >= 149) && (pmlmeext->channel_set[i].ChannelNum <= 161))
 		{
 			/* 	Just include the channel 149, 153, 157, 161 channels for 5G high */
 			(*p5gh_cnt)++;
@@ -2442,7 +2442,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u32			p2poui = cpu_to_be32(P2POUI);
 	u8			oui_subtype = P2P_GO_NEGO_REQ;
-	u8			wpsie[ 255 ] = { 0x00 }, p2pie[ 255 ] = { 0x00 };
+	u8			wpsie[255] = { 0x00 }, p2pie[255] = { 0x00 };
 	u8			wpsielen = 0, p2pielen = 0, i;
 	u8			channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
 	u16			len_channellist_attr = 0;
@@ -2550,10 +2550,10 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/* 	P2P OUI */
 	p2pielen = 0;
-	p2pie[ p2pielen++ ] = 0x50;
-	p2pie[ p2pielen++ ] = 0x6F;
-	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+	p2pie[p2pielen++] = 0x50;
+	p2pie[p2pielen++] = 0x6F;
+	p2pie[p2pielen++] = 0x9A;
+	p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 	/* 	Commented by Albert 20110306 */
 	/* 	According to the P2P Specification, the group negoitation request frame should contain 9 P2P attributes */
@@ -2570,7 +2570,7 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/* 	P2P Capability */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
+	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
@@ -2578,22 +2578,22 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/* 	Value: */
 	/* 	Device Capability Bitmap, 1 byte */
-	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
+	p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
 
 	/* 	Group Capability Bitmap, 1 byte */
 	if (pwdinfo->persistent_supported)
 	{
-		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
+		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
 	}
 	else
 	{
-		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN;
+		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
 	}
 
 
 	/* 	Group Owner Intent */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_GO_INTENT;
+	p2pie[p2pielen++] = P2P_ATTR_GO_INTENT;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
@@ -2601,24 +2601,24 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/* 	Value: */
 	/* 	Todo the tie breaker bit. */
-	p2pie[ p2pielen++ ] = ((pwdinfo->intent << 1) | BIT(0));
+	p2pie[p2pielen++] = ((pwdinfo->intent << 1) | BIT(0));
 
 	/* 	Configuration Timeout */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
+	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	/* 	Value: */
-	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P GO */
-	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P Client */
+	p2pie[p2pielen++] = 200;	/* 	2 seconds needed to be the P2P GO */
+	p2pie[p2pielen++] = 200;	/* 	2 seconds needed to be the P2P Client */
 
 
 	/* 	Listen Channel */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_LISTEN_CH;
+	p2pie[p2pielen++] = P2P_ATTR_LISTEN_CH;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
@@ -2626,23 +2626,23 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/* 	Value: */
 	/* 	Country String */
-	p2pie[ p2pielen++ ] = 'X';
-	p2pie[ p2pielen++ ] = 'X';
+	p2pie[p2pielen++] = 'X';
+	p2pie[p2pielen++] = 'X';
 
 	/* 	The third byte should be set to 0x04. */
 	/* 	Described in the "Operating Channel Attribute" section. */
-	p2pie[ p2pielen++ ] = 0x04;
+	p2pie[p2pielen++] = 0x04;
 
 	/* 	Operating Class */
-	p2pie[ p2pielen++ ] = 0x51;	/* 	Copy from SD7 */
+	p2pie[p2pielen++] = 0x51;	/* 	Copy from SD7 */
 
 	/* 	Channel Number */
-	p2pie[ p2pielen++ ] = pwdinfo->listen_channel;	/* 	listening channel number */
+	p2pie[p2pielen++] = pwdinfo->listen_channel;	/* 	listening channel number */
 
 
 	/* 	Extended Listen Timing ATTR */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_EX_LISTEN_TIMING;
+	p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0004);
@@ -2660,7 +2660,7 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/* 	Intended P2P Interface Address */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_INTENTED_IF_ADDR;
+	p2pie[p2pielen++] = P2P_ATTR_INTENTED_IF_ADDR;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
@@ -2673,7 +2673,7 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/* 	Channel List */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
+	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
 
 	/*  Length: */
 	/*  Country String(3) */
@@ -2701,12 +2701,12 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/* 	Value: */
 	/* 	Country String */
-	p2pie[ p2pielen++ ] = 'X';
-	p2pie[ p2pielen++ ] = 'X';
+	p2pie[p2pielen++] = 'X';
+	p2pie[p2pielen++] = 'X';
 
 	/* 	The third byte should be set to 0x04. */
 	/* 	Described in the "Operating Channel Attribute" section. */
-	p2pie[ p2pielen++ ] = 0x04;
+	p2pie[p2pielen++] = 0x04;
 
 	/* 	Channel Entry List */
 
@@ -2721,24 +2721,24 @@ void issue_p2p_GO_request(struct rtw_ada
 		{
 			if (pbuddy_mlmeext->cur_channel >= 149)
 			{
-				p2pie[ p2pielen++ ] = 0x7c;
+				p2pie[p2pielen++] = 0x7c;
 			}
 			else
 			{
-				p2pie[ p2pielen++ ] = 0x73;
+				p2pie[p2pielen++] = 0x73;
 			}
 		}
 		else
 		{
-			p2pie[ p2pielen++ ] = 0x51;
+			p2pie[p2pielen++] = 0x51;
 		}
 
 		/* 	Number of Channels */
 		/* 	Just support 1 channel and this channel is AP's channel */
-		p2pie[ p2pielen++ ] = 1;
+		p2pie[p2pielen++] = 1;
 
 		/* 	Channel List */
-		p2pie[ p2pielen++ ] = pbuddy_mlmeext->cur_channel;
+		p2pie[p2pielen++] = pbuddy_mlmeext->cur_channel;
 	}
 	else
 	{
@@ -2776,7 +2776,7 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/* 	Device Info */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
+	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
@@ -2810,7 +2810,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pielen += 2;
 
 	/* 	Number of Secondary Device Types */
-	p2pie[ p2pielen++ ] = 0x00;	/* 	No Secondary Device Type List */
+	p2pie[p2pielen++] = 0x00;	/* 	No Secondary Device Type List */
 
 	/* 	Device Name */
 	/* 	Type: */
@@ -2828,7 +2828,7 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/* 	Operating Channel */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
+	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
@@ -2836,32 +2836,32 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/* 	Value: */
 	/* 	Country String */
-	p2pie[ p2pielen++ ] = 'X';
-	p2pie[ p2pielen++ ] = 'X';
+	p2pie[p2pielen++] = 'X';
+	p2pie[p2pielen++] = 'X';
 
 	/* 	The third byte should be set to 0x04. */
 	/* 	Described in the "Operating Channel Attribute" section. */
-	p2pie[ p2pielen++ ] = 0x04;
+	p2pie[p2pielen++] = 0x04;
 
 	/* 	Operating Class */
 	if (pwdinfo->operating_channel <= 14)
 	{
 		/* 	Operating Class */
-		p2pie[ p2pielen++ ] = 0x51;
+		p2pie[p2pielen++] = 0x51;
 	}
 	else if ((pwdinfo->operating_channel >= 36) && (pwdinfo->operating_channel <= 48))
 	{
 		/* 	Operating Class */
-		p2pie[ p2pielen++ ] = 0x73;
+		p2pie[p2pielen++] = 0x73;
 	}
 	else
 	{
 		/* 	Operating Class */
-		p2pie[ p2pielen++ ] = 0x7c;
+		p2pie[p2pielen++] = 0x7c;
 	}
 
 	/* 	Channel Number */
-	p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	/* 	operating channel number */
+	p2pie[p2pielen++] = pwdinfo->operating_channel;	/* 	operating channel number */
 
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen);
 
@@ -2885,7 +2885,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u32			p2poui = cpu_to_be32(P2POUI);
 	u8			oui_subtype = P2P_GO_NEGO_RESP;
-	u8			wpsie[ 255 ] = { 0x00 }, p2pie[ 255 ] = { 0x00 };
+	u8			wpsie[255] = { 0x00 }, p2pie[255] = { 0x00 };
 	u8			p2pielen = 0, i;
 	uint			wpsielen = 0;
 	u16			wps_devicepassword_id = 0x0000;
@@ -3021,10 +3021,10 @@ void issue_p2p_GO_response(struct rtw_ad
 
 	/* 	P2P OUI */
 	p2pielen = 0;
-	p2pie[ p2pielen++ ] = 0x50;
-	p2pie[ p2pielen++ ] = 0x6F;
-	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+	p2pie[p2pielen++] = 0x50;
+	p2pie[p2pielen++] = 0x6F;
+	p2pie[p2pielen++] = 0x9A;
+	p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 	/* 	Commented by Albert 20100908 */
 	/* 	According to the P2P Specification, the group negoitation response frame should contain 9 P2P attributes */
@@ -3043,18 +3043,18 @@ void issue_p2p_GO_response(struct rtw_ad
 
 	/* 	P2P Status */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_STATUS;
+	p2pie[p2pielen++] = P2P_ATTR_STATUS;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	/* 	Value: */
-	p2pie[ p2pielen++ ] = result;
+	p2pie[p2pielen++] = result;
 
 	/* 	P2P Capability */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
+	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
@@ -3068,27 +3068,27 @@ void issue_p2p_GO_response(struct rtw_ad
 		/* 	Commented by Albert 2011/03/08 */
 		/* 	According to the P2P specification */
 		/* 	if the sending device will be client, the P2P Capability should be reserved of group negotation response frame */
-		p2pie[ p2pielen++ ] = 0;
+		p2pie[p2pielen++] = 0;
 	}
 	else
 	{
 		/* 	Be group owner or meet the error case */
-		p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
+		p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
 	}
 
 	/* 	Group Capability Bitmap, 1 byte */
 	if (pwdinfo->persistent_supported)
 	{
-		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
+		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
 	}
 	else
 	{
-		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN;
+		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
 	}
 
 	/* 	Group Owner Intent */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_GO_INTENT;
+	p2pie[p2pielen++] = P2P_ATTR_GO_INTENT;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
@@ -3098,30 +3098,30 @@ void issue_p2p_GO_response(struct rtw_ad
 	if (pwdinfo->peer_intent & 0x01)
 	{
 		/* 	Peer's tie breaker bit is 1, our tie breaker bit should be 0 */
-		p2pie[ p2pielen++ ] = (pwdinfo->intent << 1);
+		p2pie[p2pielen++] = (pwdinfo->intent << 1);
 	}
 	else
 	{
 		/* 	Peer's tie breaker bit is 0, our tie breaker bit should be 1 */
-		p2pie[ p2pielen++ ] = ((pwdinfo->intent << 1) | BIT(0));
+		p2pie[p2pielen++] = ((pwdinfo->intent << 1) | BIT(0));
 	}
 
 
 	/* 	Configuration Timeout */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
+	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	/* 	Value: */
-	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P GO */
-	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P Client */
+	p2pie[p2pielen++] = 200;	/* 	2 seconds needed to be the P2P GO */
+	p2pie[p2pielen++] = 200;	/* 	2 seconds needed to be the P2P Client */
 
 	/* 	Operating Channel */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
+	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
@@ -3129,36 +3129,36 @@ void issue_p2p_GO_response(struct rtw_ad
 
 	/* 	Value: */
 	/* 	Country String */
-	p2pie[ p2pielen++ ] = 'X';
-	p2pie[ p2pielen++ ] = 'X';
+	p2pie[p2pielen++] = 'X';
+	p2pie[p2pielen++] = 'X';
 
 	/* 	The third byte should be set to 0x04. */
 	/* 	Described in the "Operating Channel Attribute" section. */
-	p2pie[ p2pielen++ ] = 0x04;
+	p2pie[p2pielen++] = 0x04;
 
 	/* 	Operating Class */
 	if (pwdinfo->operating_channel <= 14)
 	{
 		/* 	Operating Class */
-		p2pie[ p2pielen++ ] = 0x51;
+		p2pie[p2pielen++] = 0x51;
 	}
 	else if ((pwdinfo->operating_channel >= 36) && (pwdinfo->operating_channel <= 48))
 	{
 		/* 	Operating Class */
-		p2pie[ p2pielen++ ] = 0x73;
+		p2pie[p2pielen++] = 0x73;
 	}
 	else
 	{
 		/* 	Operating Class */
-		p2pie[ p2pielen++ ] = 0x7c;
+		p2pie[p2pielen++] = 0x7c;
 	}
 
 	/* 	Channel Number */
-	p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	/* 	operating channel number */
+	p2pie[p2pielen++] = pwdinfo->operating_channel;	/* 	operating channel number */
 
 	/* 	Intended P2P Interface Address */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_INTENTED_IF_ADDR;
+	p2pie[p2pielen++] = P2P_ATTR_INTENTED_IF_ADDR;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
@@ -3170,7 +3170,7 @@ void issue_p2p_GO_response(struct rtw_ad
 
 	/* 	Channel List */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
+	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
 
 	/*  Country String(3) */
 	/*  + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?) */
@@ -3197,12 +3197,12 @@ void issue_p2p_GO_response(struct rtw_ad
 
 	/* 	Value: */
 	/* 	Country String */
-	p2pie[ p2pielen++ ] = 'X';
-	p2pie[ p2pielen++ ] = 'X';
+	p2pie[p2pielen++] = 'X';
+	p2pie[p2pielen++] = 'X';
 
 	/* 	The third byte should be set to 0x04. */
 	/* 	Described in the "Operating Channel Attribute" section. */
-	p2pie[ p2pielen++ ] = 0x04;
+	p2pie[p2pielen++] = 0x04;
 
 	/* 	Channel Entry List */
 
@@ -3217,24 +3217,24 @@ void issue_p2p_GO_response(struct rtw_ad
 		{
 			if (pbuddy_mlmeext->cur_channel >= 149)
 			{
-				p2pie[ p2pielen++ ] = 0x7c;
+				p2pie[p2pielen++] = 0x7c;
 			}
 			else
 			{
-				p2pie[ p2pielen++ ] = 0x73;
+				p2pie[p2pielen++] = 0x73;
 			}
 		}
 		else
 		{
-			p2pie[ p2pielen++ ] = 0x51;
+			p2pie[p2pielen++] = 0x51;
 		}
 
 		/* 	Number of Channels */
 		/* 	Just support 1 channel and this channel is AP's channel */
-		p2pie[ p2pielen++ ] = 1;
+		p2pie[p2pielen++] = 1;
 
 		/* 	Channel List */
-		p2pie[ p2pielen++ ] = pbuddy_mlmeext->cur_channel;
+		p2pie[p2pielen++] = pbuddy_mlmeext->cur_channel;
 	}
 	else
 	{
@@ -3272,7 +3272,7 @@ void issue_p2p_GO_response(struct rtw_ad
 
 	/* 	Device Info */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
+	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
@@ -3306,7 +3306,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	p2pielen += 2;
 
 	/* 	Number of Secondary Device Types */
-	p2pie[ p2pielen++ ] = 0x00;	/* 	No Secondary Device Type List */
+	p2pie[p2pielen++] = 0x00;	/* 	No Secondary Device Type List */
 
 	/* 	Device Name */
 	/* 	Type: */
@@ -3325,7 +3325,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	{
 		/* 	Group ID Attribute */
 		/* 	Type: */
-		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
+		p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
 
 		/* 	Length: */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN + pwdinfo->nego_ssidlen);
@@ -3363,7 +3363,7 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u32			p2poui = cpu_to_be32(P2POUI);
 	u8			oui_subtype = P2P_GO_NEGO_CONF;
-	u8			wpsie[ 255 ] = { 0x00 }, p2pie[ 255 ] = { 0x00 };
+	u8			wpsie[255] = { 0x00 }, p2pie[255] = { 0x00 };
 	u8			wpsielen = 0, p2pielen = 0;
 
 	struct xmit_frame			*pmgntframe;
@@ -3420,10 +3420,10 @@ void issue_p2p_GO_confirm(struct rtw_ada
 
 	/* 	P2P OUI */
 	p2pielen = 0;
-	p2pie[ p2pielen++ ] = 0x50;
-	p2pie[ p2pielen++ ] = 0x6F;
-	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+	p2pie[p2pielen++] = 0x50;
+	p2pie[p2pielen++] = 0x6F;
+	p2pie[p2pielen++] = 0x9A;
+	p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 	/* 	Commented by Albert 20110306 */
 	/* 	According to the P2P Specification, the group negoitation request frame should contain 5 P2P attributes */
@@ -3435,18 +3435,18 @@ void issue_p2p_GO_confirm(struct rtw_ada
 
 	/* 	P2P Status */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_STATUS;
+	p2pie[p2pielen++] = P2P_ATTR_STATUS;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	/* 	Value: */
-	p2pie[ p2pielen++ ] = result;
+	p2pie[p2pielen++] = result;
 
 	/* 	P2P Capability */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
+	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
@@ -3454,22 +3454,22 @@ void issue_p2p_GO_confirm(struct rtw_ada
 
 	/* 	Value: */
 	/* 	Device Capability Bitmap, 1 byte */
-	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
+	p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
 
 	/* 	Group Capability Bitmap, 1 byte */
 	if (pwdinfo->persistent_supported)
 	{
-		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
+		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
 	}
 	else
 	{
-		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN;
+		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
 	}
 
 
 	/* 	Operating Channel */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
+	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
@@ -3477,12 +3477,12 @@ void issue_p2p_GO_confirm(struct rtw_ada
 
 	/* 	Value: */
 	/* 	Country String */
-	p2pie[ p2pielen++ ] = 'X';
-	p2pie[ p2pielen++ ] = 'X';
+	p2pie[p2pielen++] = 'X';
+	p2pie[p2pielen++] = 'X';
 
 	/* 	The third byte should be set to 0x04. */
 	/* 	Described in the "Operating Channel Attribute" section. */
-	p2pie[ p2pielen++ ] = 0x04;
+	p2pie[p2pielen++] = 0x04;
 
 
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
@@ -3490,47 +3490,47 @@ void issue_p2p_GO_confirm(struct rtw_ada
 		if (pwdinfo->peer_operating_ch <= 14)
 		{
 			/* 	Operating Class */
-			p2pie[ p2pielen++ ] = 0x51;
+			p2pie[p2pielen++] = 0x51;
 		}
 		else if ((pwdinfo->peer_operating_ch >= 36) && (pwdinfo->peer_operating_ch <= 48))
 		{
 			/* 	Operating Class */
-			p2pie[ p2pielen++ ] = 0x73;
+			p2pie[p2pielen++] = 0x73;
 		}
 		else
 		{
 			/* 	Operating Class */
-			p2pie[ p2pielen++ ] = 0x7c;
+			p2pie[p2pielen++] = 0x7c;
 		}
 
-		p2pie[ p2pielen++ ] = pwdinfo->peer_operating_ch;
+		p2pie[p2pielen++] = pwdinfo->peer_operating_ch;
 	}
 	else
 	{
 		if (pwdinfo->operating_channel <= 14)
 		{
 			/* 	Operating Class */
-			p2pie[ p2pielen++ ] = 0x51;
+			p2pie[p2pielen++] = 0x51;
 		}
 		else if ((pwdinfo->operating_channel >= 36) && (pwdinfo->operating_channel <= 48))
 		{
 			/* 	Operating Class */
-			p2pie[ p2pielen++ ] = 0x73;
+			p2pie[p2pielen++] = 0x73;
 		}
 		else
 		{
 			/* 	Operating Class */
-			p2pie[ p2pielen++ ] = 0x7c;
+			p2pie[p2pielen++] = 0x7c;
 		}
 
 		/* 	Channel Number */
-		p2pie[ p2pielen++ ] = pwdinfo->operating_channel;		/* 	Use the listen channel as the operating channel */
+		p2pie[p2pielen++] = pwdinfo->operating_channel;		/* 	Use the listen channel as the operating channel */
 	}
 
 
 	/* 	Channel List */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
+	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(pwdinfo->channel_list_attr_len);
@@ -3544,7 +3544,7 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	{
 		/* 	Group ID Attribute */
 		/* 	Type: */
-		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
+		p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
 
 		/* 	Length: */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN + pwdinfo->nego_ssidlen);
@@ -3581,7 +3581,7 @@ void issue_p2p_invitation_request(struct
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u32			p2poui = cpu_to_be32(P2POUI);
 	u8			oui_subtype = P2P_INVIT_REQ;
-	u8			p2pie[ 255 ] = { 0x00 };
+	u8			p2pie[255] = { 0x00 };
 	u8			p2pielen = 0, i;
 	u8			dialogToken = 3;
 	u8			channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
@@ -3645,10 +3645,10 @@ void issue_p2p_invitation_request(struct
 
 	/* 	P2P OUI */
 	p2pielen = 0;
-	p2pie[ p2pielen++ ] = 0x50;
-	p2pie[ p2pielen++ ] = 0x6F;
-	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+	p2pie[p2pielen++] = 0x50;
+	p2pie[p2pielen++] = 0x6F;
+	p2pie[p2pielen++] = 0x9A;
+	p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 	/* 	Commented by Albert 20101011 */
 	/* 	According to the P2P Specification, the P2P Invitation request frame should contain 7 P2P attributes */
@@ -3662,31 +3662,31 @@ void issue_p2p_invitation_request(struct
 
 	/* 	Configuration Timeout */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
+	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	/* 	Value: */
-	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P GO */
-	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P Client */
+	p2pie[p2pielen++] = 200;	/* 	2 seconds needed to be the P2P GO */
+	p2pie[p2pielen++] = 200;	/* 	2 seconds needed to be the P2P Client */
 
 	/* 	Invitation Flags */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_INVITATION_FLAGS;
+	p2pie[p2pielen++] = P2P_ATTR_INVITATION_FLAGS;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	/* 	Value: */
-	p2pie[ p2pielen++ ] = P2P_INVITATION_FLAGS_PERSISTENT;
+	p2pie[p2pielen++] = P2P_INVITATION_FLAGS_PERSISTENT;
 
 
 	/* 	Operating Channel */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
+	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
@@ -3694,29 +3694,29 @@ void issue_p2p_invitation_request(struct
 
 	/* 	Value: */
 	/* 	Country String */
-	p2pie[ p2pielen++ ] = 'X';
-	p2pie[ p2pielen++ ] = 'X';
+	p2pie[p2pielen++] = 'X';
+	p2pie[p2pielen++] = 'X';
 
 	/* 	The third byte should be set to 0x04. */
 	/* 	Described in the "Operating Channel Attribute" section. */
-	p2pie[ p2pielen++ ] = 0x04;
+	p2pie[p2pielen++] = 0x04;
 
 	/* 	Operating Class */
 	if (pwdinfo->invitereq_info.operating_ch <= 14)
-		p2pie[ p2pielen++ ] = 0x51;
+		p2pie[p2pielen++] = 0x51;
 	else if ((pwdinfo->invitereq_info.operating_ch >= 36) && (pwdinfo->invitereq_info.operating_ch <= 48))
-		p2pie[ p2pielen++ ] = 0x73;
+		p2pie[p2pielen++] = 0x73;
 	else
-		p2pie[ p2pielen++ ] = 0x7c;
+		p2pie[p2pielen++] = 0x7c;
 
 	/* 	Channel Number */
-	p2pie[ p2pielen++ ] = pwdinfo->invitereq_info.operating_ch;	/* 	operating channel number */
+	p2pie[p2pielen++] = pwdinfo->invitereq_info.operating_ch;	/* 	operating channel number */
 
 	if (_rtw_memcmp(myid(&padapter->eeprompriv), pwdinfo->invitereq_info.go_bssid, ETH_ALEN))
 	{
 		/* 	P2P Group BSSID */
 		/* 	Type: */
-		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_BSSID;
+		p2pie[p2pielen++] = P2P_ATTR_GROUP_BSSID;
 
 		/* 	Length: */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
@@ -3730,7 +3730,7 @@ void issue_p2p_invitation_request(struct
 
 	/* 	Channel List */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
+	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
 
 
 	/* 	Length: */
@@ -3759,12 +3759,12 @@ void issue_p2p_invitation_request(struct
 
 	/* 	Value: */
 	/* 	Country String */
-	p2pie[ p2pielen++ ] = 'X';
-	p2pie[ p2pielen++ ] = 'X';
+	p2pie[p2pielen++] = 'X';
+	p2pie[p2pielen++] = 'X';
 
 	/* 	The third byte should be set to 0x04. */
 	/* 	Described in the "Operating Channel Attribute" section. */
-	p2pie[ p2pielen++ ] = 0x04;
+	p2pie[p2pielen++] = 0x04;
 
 	/* 	Channel Entry List */
 #ifdef CONFIG_CONCURRENT_MODE
@@ -3778,24 +3778,24 @@ void issue_p2p_invitation_request(struct
 		{
 			if (pbuddy_mlmeext->cur_channel >= 149)
 			{
-				p2pie[ p2pielen++ ] = 0x7c;
+				p2pie[p2pielen++] = 0x7c;
 			}
 			else
 			{
-				p2pie[ p2pielen++ ] = 0x73;
+				p2pie[p2pielen++] = 0x73;
 			}
 		}
 		else
 		{
-			p2pie[ p2pielen++ ] = 0x51;
+			p2pie[p2pielen++] = 0x51;
 		}
 
 		/* 	Number of Channels */
 		/* 	Just support 1 channel and this channel is AP's channel */
-		p2pie[ p2pielen++ ] = 1;
+		p2pie[p2pielen++] = 1;
 
 		/* 	Channel List */
-		p2pie[ p2pielen++ ] = pbuddy_mlmeext->cur_channel;
+		p2pie[p2pielen++] = pbuddy_mlmeext->cur_channel;
 	}
 	else
 	{
@@ -3834,7 +3834,7 @@ void issue_p2p_invitation_request(struct
 
 	/* 	P2P Group ID */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
+	p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(6 + pwdinfo->invitereq_info.ssidlen);
@@ -3852,7 +3852,7 @@ void issue_p2p_invitation_request(struct
 
 	/* 	Device Info */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
+	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
@@ -3884,7 +3884,7 @@ void issue_p2p_invitation_request(struct
 	p2pielen += 2;
 
 	/* 	Number of Secondary Device Types */
-	p2pie[ p2pielen++ ] = 0x00;	/* 	No Secondary Device Type List */
+	p2pie[p2pielen++] = 0x00;	/* 	No Secondary Device Type List */
 
 	/* 	Device Name */
 	/* 	Type: */
@@ -3920,7 +3920,7 @@ void issue_p2p_invitation_response(struc
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u32			p2poui = cpu_to_be32(P2POUI);
 	u8			oui_subtype = P2P_INVIT_RESP;
-	u8			p2pie[ 255 ] = { 0x00 };
+	u8			p2pie[255] = { 0x00 };
 	u8			p2pielen = 0, i;
 	u8			channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
 	u16			len_channellist_attr = 0;
@@ -3983,10 +3983,10 @@ void issue_p2p_invitation_response(struc
 
 	/* 	P2P OUI */
 	p2pielen = 0;
-	p2pie[ p2pielen++ ] = 0x50;
-	p2pie[ p2pielen++ ] = 0x6F;
-	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+	p2pie[p2pielen++] = 0x50;
+	p2pie[p2pielen++] = 0x6F;
+	p2pie[p2pielen++] = 0x9A;
+	p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 	/* 	Commented by Albert 20101005 */
 	/* 	According to the P2P Specification, the P2P Invitation response frame should contain 5 P2P attributes */
@@ -3998,7 +3998,7 @@ void issue_p2p_invitation_response(struc
 
 	/* 	P2P Status */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_STATUS;
+	p2pie[p2pielen++] = P2P_ATTR_STATUS;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
@@ -4011,19 +4011,19 @@ void issue_p2p_invitation_response(struc
 	/* 	So, the WiFi driver will send the P2P_STATUS_FAIL_INFO_UNAVAILABLE to NB. */
 	/* 	If the UI found the corresponding profile, the WiFi driver sends the P2P Invitation Req */
 	/* 	to NB to rebuild the persistent group. */
-	p2pie[ p2pielen++ ] = status_code;
+	p2pie[p2pielen++] = status_code;
 
 	/* 	Configuration Timeout */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
+	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
 
 	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	/* 	Value: */
-	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P GO */
-	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P Client */
+	p2pie[p2pielen++] = 200;	/* 	2 seconds needed to be the P2P GO */
+	p2pie[p2pielen++] = 200;	/* 	2 seconds needed to be the P2P Client */
 
 	if (status_code == P2P_STATUS_SUCCESS)
 	{
@@ -4036,7 +4036,7 @@ void issue_p2p_invitation_response(struc
 
 			/* 	Operating Channel */
 			/* 	Type: */
-			p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
+			p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
 
 			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
@@ -4044,23 +4044,23 @@ void issue_p2p_invitation_response(struc
 
 			/* 	Value: */
 			/* 	Country String */
-			p2pie[ p2pielen++ ] = 'X';
-			p2pie[ p2pielen++ ] = 'X';
+			p2pie[p2pielen++] = 'X';
+			p2pie[p2pielen++] = 'X';
 
 			/* 	The third byte should be set to 0x04. */
 			/* 	Described in the "Operating Channel Attribute" section. */
-			p2pie[ p2pielen++ ] = 0x04;
+			p2pie[p2pielen++] = 0x04;
 
 			/* 	Operating Class */
-			p2pie[ p2pielen++ ] = 0x51;	/* 	Copy from SD7 */
+			p2pie[p2pielen++] = 0x51;	/* 	Copy from SD7 */
 
 			/* 	Channel Number */
-			p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	/* 	operating channel number */
+			p2pie[p2pielen++] = pwdinfo->operating_channel;	/* 	operating channel number */
 
 
 			/* 	P2P Group BSSID */
 			/* 	Type: */
-			p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_BSSID;
+			p2pie[p2pielen++] = P2P_ATTR_GROUP_BSSID;
 
 			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
@@ -4075,7 +4075,7 @@ void issue_p2p_invitation_response(struc
 
 		/* 	Channel List */
 		/* 	Type: */
-		p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
+		p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
 
 		/* 	Length: */
 		/*  Country String(3) */
@@ -4103,12 +4103,12 @@ void issue_p2p_invitation_response(struc
 
 		/* 	Value: */
 		/* 	Country String */
-		p2pie[ p2pielen++ ] = 'X';
-		p2pie[ p2pielen++ ] = 'X';
+		p2pie[p2pielen++] = 'X';
+		p2pie[p2pielen++] = 'X';
 
 		/* 	The third byte should be set to 0x04. */
 		/* 	Described in the "Operating Channel Attribute" section. */
-		p2pie[ p2pielen++ ] = 0x04;
+		p2pie[p2pielen++] = 0x04;
 
 		/* 	Channel Entry List */
 #ifdef CONFIG_CONCURRENT_MODE
@@ -4122,24 +4122,24 @@ void issue_p2p_invitation_response(struc
 			{
 				if (pbuddy_mlmeext->cur_channel >= 149)
 				{
-					p2pie[ p2pielen++ ] = 0x7c;
+					p2pie[p2pielen++] = 0x7c;
 				}
 				else
 				{
-					p2pie[ p2pielen++ ] = 0x73;
+					p2pie[p2pielen++] = 0x73;
 				}
 			}
 			else
 			{
-				p2pie[ p2pielen++ ] = 0x51;
+				p2pie[p2pielen++] = 0x51;
 			}
 
 			/* 	Number of Channels */
 			/* 	Just support 1 channel and this channel is AP's channel */
-			p2pie[ p2pielen++ ] = 1;
+			p2pie[p2pielen++] = 1;
 
 			/* 	Channel List */
-			p2pie[ p2pielen++ ] = pbuddy_mlmeext->cur_channel;
+			p2pie[p2pielen++] = pbuddy_mlmeext->cur_channel;
 		}
 		else
 		{
@@ -4198,7 +4198,7 @@ void issue_p2p_provision_request(struct
 	u8			dialogToken = 1;
 	u32			p2poui = cpu_to_be32(P2POUI);
 	u8			oui_subtype = P2P_PROVISION_DISC_REQ;
-	u8			wpsie[ 100 ] = { 0x00 };
+	u8			wpsie[100] = { 0x00 };
 	u8			wpsielen = 0;
 	u32			p2pielen = 0;
 #ifdef CONFIG_WFD
@@ -4572,7 +4572,7 @@ void issue_probersp_p2p(struct rtw_adapt
 		wpsielen += 2;
 
 		/* 	Value: */
-		wpsie[ wpsielen++ ] = 0x31;		/* 	character 1 */
+		wpsie[wpsielen++] = 0x31;		/* 	character 1 */
 
 		/* 	Serial Number */
 		/* 	Type: */
@@ -4688,7 +4688,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 	int	bssrate_len = 0;
 	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	u8					wpsie[255] = { 0x00 }, p2pie[ 255 ] = { 0x00 };
+	u8					wpsie[255] = { 0x00 }, p2pie[255] = { 0x00 };
 	u16					wpsielen = 0, p2pielen = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
@@ -4875,10 +4875,10 @@ int _issue_probereq_p2p(struct rtw_adapt
 
 		/* 	P2P OUI */
 		p2pielen = 0;
-		p2pie[ p2pielen++ ] = 0x50;
-		p2pie[ p2pielen++ ] = 0x6F;
-		p2pie[ p2pielen++ ] = 0x9A;
-		p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+		p2pie[p2pielen++] = 0x50;
+		p2pie[p2pielen++] = 0x6F;
+		p2pie[p2pielen++] = 0x9A;
+		p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 		/* 	Commented by Albert 20110221 */
 		/* 	According to the P2P Specification, the probe request frame should contain 5 P2P attributes */
@@ -4890,7 +4890,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 
 		/* 	P2P Capability */
 		/* 	Type: */
-		p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
+		p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 		/* 	Length: */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
@@ -4898,17 +4898,17 @@ int _issue_probereq_p2p(struct rtw_adapt
 
 		/* 	Value: */
 		/* 	Device Capability Bitmap, 1 byte */
-		p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
+		p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
 
 		/* 	Group Capability Bitmap, 1 byte */
 		if (pwdinfo->persistent_supported)
-			p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
+			p2pie[p2pielen++] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
 		else
-			p2pie[ p2pielen++ ] = DMP_P2P_GRPCAP_SUPPORT;
+			p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
 
 		/* 	Listen Channel */
 		/* 	Type: */
-		p2pie[ p2pielen++ ] = P2P_ATTR_LISTEN_CH;
+		p2pie[p2pielen++] = P2P_ATTR_LISTEN_CH;
 
 		/* 	Length: */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
@@ -4916,23 +4916,23 @@ int _issue_probereq_p2p(struct rtw_adapt
 
 		/* 	Value: */
 		/* 	Country String */
-		p2pie[ p2pielen++ ] = 'X';
-		p2pie[ p2pielen++ ] = 'X';
+		p2pie[p2pielen++] = 'X';
+		p2pie[p2pielen++] = 'X';
 
 		/* 	The third byte should be set to 0x04. */
 		/* 	Described in the "Operating Channel Attribute" section. */
-		p2pie[ p2pielen++ ] = 0x04;
+		p2pie[p2pielen++] = 0x04;
 
 		/* 	Operating Class */
-		p2pie[ p2pielen++ ] = 0x51;	/* 	Copy from SD7 */
+		p2pie[p2pielen++] = 0x51;	/* 	Copy from SD7 */
 
 		/* 	Channel Number */
-		p2pie[ p2pielen++ ] = pwdinfo->listen_channel;	/* 	listen channel */
+		p2pie[p2pielen++] = pwdinfo->listen_channel;	/* 	listen channel */
 
 
 		/* 	Extended Listen Timing */
 		/* 	Type: */
-		p2pie[ p2pielen++ ] = P2P_ATTR_EX_LISTEN_TIMING;
+		p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
 
 		/* 	Length: */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0004);
@@ -4951,7 +4951,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 		{
 			/* 	Operating Channel (if this WiFi is working as the group owner now) */
 			/* 	Type: */
-			p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
+			p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
 
 			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
@@ -4959,18 +4959,18 @@ int _issue_probereq_p2p(struct rtw_adapt
 
 			/* 	Value: */
 			/* 	Country String */
-			p2pie[ p2pielen++ ] = 'X';
-			p2pie[ p2pielen++ ] = 'X';
+			p2pie[p2pielen++] = 'X';
+			p2pie[p2pielen++] = 'X';
 
 			/* 	The third byte should be set to 0x04. */
 			/* 	Described in the "Operating Channel Attribute" section. */
-			p2pie[ p2pielen++ ] = 0x04;
+			p2pie[p2pielen++] = 0x04;
 
 			/* 	Operating Class */
-			p2pie[ p2pielen++ ] = 0x51;	/* 	Copy from SD7 */
+			p2pie[p2pielen++] = 0x51;	/* 	Copy from SD7 */
 
 			/* 	Channel Number */
-			p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	/* 	operating channel number */
+			p2pie[p2pielen++] = pwdinfo->operating_channel;	/* 	operating channel number */
 
 		}
 
@@ -5140,7 +5140,7 @@ unsigned int on_action_public_p2p(union
 
 		len -= sizeof(struct rtw_ieee80211_hdr_3addr);
 
-		switch (frame_body[ 6 ])/* OUI Subtype */
+		switch (frame_body[6])/* OUI Subtype */
 		{
 			case P2P_GO_NEGO_REQ:
 			{
@@ -5214,7 +5214,7 @@ unsigned int on_action_public_p2p(union
 					{
 						if (rtw_p2p_role(pwdinfo) == P2P_ROLE_CLIENT)
 						{
-							pwdinfo->p2p_info.operation_ch[ 0 ] = pwdinfo->peer_operating_ch;
+							pwdinfo->p2p_info.operation_ch[0] = pwdinfo->peer_operating_ch;
 							pwdinfo->p2p_info.scan_op_ch_only = 1;
 							_set_timer(&pwdinfo->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH);
 						}
@@ -5243,7 +5243,7 @@ unsigned int on_action_public_p2p(union
 				{
 					if (rtw_p2p_role(pwdinfo) == P2P_ROLE_CLIENT)
 					{
-						pwdinfo->p2p_info.operation_ch[ 0 ] = pwdinfo->peer_operating_ch;
+						pwdinfo->p2p_info.operation_ch[0] = pwdinfo->peer_operating_ch;
 						pwdinfo->p2p_info.scan_op_ch_only = 1;
 						_set_timer(&pwdinfo->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH);
 					}
@@ -5301,7 +5301,7 @@ unsigned int on_action_public_p2p(union
 								else
 								{
 									/* 	The p2p device sending this p2p invitation request wants to be the persistent GO. */
-									if (is_matched_in_profilelist(pwdinfo->p2p_peer_interface_addr, &pwdinfo->profileinfo[ 0 ]))
+									if (is_matched_in_profilelist(pwdinfo->p2p_peer_interface_addr, &pwdinfo->profileinfo[0]))
 									{
 										u8 operatingch_info[5] = { 0x00 };
 										if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen))
@@ -5396,7 +5396,7 @@ unsigned int on_action_public_p2p(union
 
 					DBG_8192D("[%s] status_code = %d\n", __func__, status_code);
 
-					pwdinfo->inviteresp_info.token = frame_body[ 7 ];
+					pwdinfo->inviteresp_info.token = frame_body[7];
 					issue_p2p_invitation_response(padapter, GetAddr2Ptr(pframe), pwdinfo->inviteresp_info.token, status_code);
 				}
 #ifdef CONFIG_INTEL_WIDI
@@ -6932,7 +6932,7 @@ void issue_assocreq(struct rtw_adapter *
 	u8	cbw40_enable = 0;
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	u8					p2pie[ 255 ] = { 0x00 };
+	u8					p2pie[255] = { 0x00 };
 	u16					p2pielen = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
@@ -6942,7 +6942,7 @@ void issue_assocreq(struct rtw_adapter *
 #ifdef CONFIG_DFS
 	u16	cap;
 	u8 pow_cap_ele[2] = { 0x00 };
-	u8 sup_ch[ 30 * 2 ] = {0x00 }, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
+	u8 sup_ch[30 * 2] = {0x00 }, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
 #endif /* CONFIG_DFS */
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
@@ -7232,10 +7232,10 @@ void issue_assocreq(struct rtw_adapter *
 			/* 	P2P OUI */
 
 			p2pielen = 0;
-			p2pie[ p2pielen++ ] = 0x50;
-			p2pie[ p2pielen++ ] = 0x6F;
-			p2pie[ p2pielen++ ] = 0x9A;
-			p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+			p2pie[p2pielen++] = 0x50;
+			p2pie[p2pielen++] = 0x6F;
+			p2pie[p2pielen++] = 0x9A;
+			p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 			/* 	Commented by Albert 20101109 */
 			/* 	According to the P2P Specification, the association request frame should contain 3 P2P attributes */
@@ -7247,7 +7247,7 @@ void issue_assocreq(struct rtw_adapter *
 
 			/* 	P2P Capability */
 			/* 	Type: */
-			p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
+			p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
@@ -7255,17 +7255,17 @@ void issue_assocreq(struct rtw_adapter *
 
 			/* 	Value: */
 			/* 	Device Capability Bitmap, 1 byte */
-			p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
+			p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
 
 			/* 	Group Capability Bitmap, 1 byte */
 			if (pwdinfo->persistent_supported)
-				p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
+				p2pie[p2pielen++] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
 			else
-				p2pie[ p2pielen++ ] = DMP_P2P_GRPCAP_SUPPORT;
+				p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
 
 			/* 	Extended Listen Timing */
 			/* 	Type: */
-			p2pie[ p2pielen++ ] = P2P_ATTR_EX_LISTEN_TIMING;
+			p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
 
 			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0004);
@@ -7282,7 +7282,7 @@ void issue_assocreq(struct rtw_adapter *
 
 			/* 	Device Info */
 			/* 	Type: */
-			p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
+			p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
 
 			/* 	Length: */
 			/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
@@ -7323,7 +7323,7 @@ void issue_assocreq(struct rtw_adapter *
 			p2pielen += 2;
 
 			/* 	Number of Secondary Device Types */
-			p2pie[ p2pielen++ ] = 0x00;	/* 	No Secondary Device Type List */
+			p2pie[p2pielen++] = 0x00;	/* 	No Secondary Device Type List */
 
 			/* 	Device Name */
 			/* 	Type: */
@@ -7340,7 +7340,7 @@ void issue_assocreq(struct rtw_adapter *
 
 			/* 	P2P Interface */
 			/* 	Type: */
-			p2pie[ p2pielen++ ] = P2P_ATTR_INTERFACE;
+			p2pie[p2pielen++] = P2P_ATTR_INTERFACE;
 
 			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x000D);
@@ -7350,7 +7350,7 @@ void issue_assocreq(struct rtw_adapter *
 			memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);	/* 	P2P Device Address */
 			p2pielen += ETH_ALEN;
 
-			p2pie[ p2pielen++ ] = 1;	/* 	P2P Interface Address Count */
+			p2pie[p2pielen++] = 1;	/* 	P2P Interface Address Count */
 
 			memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);	/* 	P2P Interface Address List */
 			p2pielen += ETH_ALEN;
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -31,7 +31,7 @@ int rtw_p2p_is_channel_list_ok(u8 desire
 
 	for (i = 0; i < ch_cnt; i++)
 	{
-		if (ch_list[ i ] == desired_ch)
+		if (ch_list[i] == desired_ch)
 		{
 			found = 1;
 			break;
@@ -283,10 +283,10 @@ static void issue_p2p_devdisc_resp(struc
 	/* Build P2P IE */
 	/* 	P2P OUI */
 	p2pielen = 0;
-	p2pie[ p2pielen++ ] = 0x50;
-	p2pie[ p2pielen++ ] = 0x6F;
-	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+	p2pie[p2pielen++] = 0x50;
+	p2pie[p2pielen++] = 0x6F;
+	p2pie[p2pielen++] = 0x9A;
+	p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 	/*  P2P_ATTR_STATUS */
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status);
@@ -306,7 +306,7 @@ static void issue_p2p_provision_resp(str
 	u8			dialogToken = frame_body[7];	/* 	The Dialog Token of provisioning discovery request frame. */
 	u32			p2poui = cpu_to_be32(P2POUI);
 	u8			oui_subtype = P2P_PROVISION_DISC_RESP;
-	u8			wpsie[ 100 ] = { 0x00 };
+	u8			wpsie[100] = { 0x00 };
 	u8			wpsielen = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
@@ -402,7 +402,7 @@ static void issue_p2p_presence_resp(stru
 	unsigned char category = RTW_WLAN_CATEGORY_P2P;/* P2P action frame */
 	u32	p2poui = cpu_to_be32(P2POUI);
 	u8	oui_subtype = P2P_PRESENCE_RESPONSE;
-	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
+	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
 	u8 noa_attr_content[32] = { 0x00 };
 	u32 p2pielen = 0;
 
@@ -446,10 +446,10 @@ static void issue_p2p_presence_resp(stru
 	/* Add P2P IE header */
 	/* 	P2P OUI */
 	p2pielen = 0;
-	p2pie[ p2pielen++ ] = 0x50;
-	p2pie[ p2pielen++ ] = 0x6F;
-	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+	p2pie[p2pielen++] = 0x50;
+	p2pie[p2pielen++] = 0x6F;
+	p2pie[p2pielen++] = 0x9A;
+	p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 	/* Add Status attribute in P2P IE */
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status);
@@ -474,17 +474,17 @@ static void issue_p2p_presence_resp(stru
 
 u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
+	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
 	u16 capability=0;
 	u32 len=0, p2pielen = 0;
 
 
 	/* 	P2P OUI */
 	p2pielen = 0;
-	p2pie[ p2pielen++ ] = 0x50;
-	p2pie[ p2pielen++ ] = 0x6F;
-	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+	p2pie[p2pielen++] = 0x50;
+	p2pie[p2pielen++] = 0x6F;
+	p2pie[p2pielen++] = 0x9A;
+	p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 
 	/* 	According to the P2P Specification, the beacon frame should contain 3 P2P attributes */
@@ -531,7 +531,7 @@ u32 build_beacon_p2p_ie(struct wifidirec
 #ifdef CONFIG_WFD
 u32 build_beacon_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 len=0, wfdielen = 0;
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -539,10 +539,10 @@ u32 build_beacon_wfd_ie(struct wifidirec
 
 	/* 	WFD OUI */
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110812 */
 	/* 	According to the WFD Specification, the beacon frame should contain 4 WFD attributes */
@@ -553,7 +553,7 @@ u32 build_beacon_wfd_ie(struct wifidirec
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -599,7 +599,7 @@ u32 build_beacon_wfd_ie(struct wifidirec
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -610,7 +610,7 @@ u32 build_beacon_wfd_ie(struct wifidirec
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -621,7 +621,7 @@ u32 build_beacon_wfd_ie(struct wifidirec
 
 	/* 	Coupled Sink Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -631,14 +631,14 @@ u32 build_beacon_wfd_ie(struct wifidirec
 	/* 	Value: */
 	/* 	Coupled Sink Status bitmap */
 	/* 	Not coupled/available for Coupling */
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
 	/*   MAC Addr. */
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
@@ -647,7 +647,7 @@ u32 build_beacon_wfd_ie(struct wifidirec
 
 u32 build_probe_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 len=0, wfdielen = 0;
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -655,10 +655,10 @@ u32 build_probe_req_wfd_ie(struct wifidi
 
 	/* 	WFD OUI */
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110812 */
 	/* 	According to the WFD Specification, the probe request frame should contain 4 WFD attributes */
@@ -669,7 +669,7 @@ u32 build_probe_req_wfd_ie(struct wifidi
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -711,7 +711,7 @@ u32 build_probe_req_wfd_ie(struct wifidi
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -722,7 +722,7 @@ u32 build_probe_req_wfd_ie(struct wifidi
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -733,7 +733,7 @@ u32 build_probe_req_wfd_ie(struct wifidi
 
 	/* 	Coupled Sink Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -743,14 +743,14 @@ u32 build_probe_req_wfd_ie(struct wifidi
 	/* 	Value: */
 	/* 	Coupled Sink Status bitmap */
 	/* 	Not coupled/available for Coupling */
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
 	/*   MAC Addr. */
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
@@ -759,7 +759,7 @@ u32 build_probe_req_wfd_ie(struct wifidi
 
 u32 build_probe_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 tunneled)
 {
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 len=0, wfdielen = 0;
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -767,10 +767,10 @@ u32 build_probe_resp_wfd_ie(struct wifid
 
 	/* 	WFD OUI */
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110812 */
 	/* 	According to the WFD Specification, the probe response frame should contain 4 WFD attributes */
@@ -782,7 +782,7 @@ u32 build_probe_resp_wfd_ie(struct wifid
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -867,7 +867,7 @@ u32 build_probe_resp_wfd_ie(struct wifid
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -878,7 +878,7 @@ u32 build_probe_resp_wfd_ie(struct wifid
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -889,7 +889,7 @@ u32 build_probe_resp_wfd_ie(struct wifid
 
 	/* 	Coupled Sink Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -899,20 +899,20 @@ u32 build_probe_resp_wfd_ie(struct wifid
 	/* 	Value: */
 	/* 	Coupled Sink Status bitmap */
 	/* 	Not coupled/available for Coupling */
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
 	/*   MAC Addr. */
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
 
 	if (P2P_ROLE_GO == pwdinfo->role)
 	{
 		/* 	WFD Session Information ATTR */
 		/* 	Type: */
-		wfdie[ wfdielen++ ] = WFD_ATTR_SESSION_INFO;
+		wfdie[wfdielen++] = WFD_ATTR_SESSION_INFO;
 
 		/* 	Length: */
 		/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -928,7 +928,7 @@ u32 build_probe_resp_wfd_ie(struct wifid
 	{
 		/* 	Alternative MAC Address ATTR */
 		/* 	Type: */
-		wfdie[ wfdielen++ ] = WFD_ATTR_ALTER_MAC;
+		wfdie[wfdielen++] = WFD_ATTR_ALTER_MAC;
 
 		/* 	Length: */
 		/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -937,7 +937,7 @@ u32 build_probe_resp_wfd_ie(struct wifid
 
 		/* 	Value: */
 		/* 	Alternative MAC Address */
-		memcpy(wfdie + wfdielen, &padapter->pbuddy_adapter->eeprompriv.mac_addr[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &padapter->pbuddy_adapter->eeprompriv.mac_addr[0], ETH_ALEN);
 		/* 	This mac address is used to make the WFD session when TDLS is enable. */
 
 		wfdielen += ETH_ALEN;
@@ -952,7 +952,7 @@ u32 build_probe_resp_wfd_ie(struct wifid
 
 u32 build_assoc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 len=0, wfdielen = 0;
 	struct rtw_adapter					*padapter = NULL;
 	struct mlme_priv			*pmlmepriv = NULL;
@@ -969,10 +969,10 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 	pwfd_info = padapter->wdinfo.wfd_info;
 
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110812 */
 	/* 	According to the WFD Specification, the probe request frame should contain 4 WFD attributes */
@@ -983,7 +983,7 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1010,7 +1010,7 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1021,7 +1021,7 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -1032,7 +1032,7 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 
 	/* 	Coupled Sink Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1042,14 +1042,14 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 	/* 	Value: */
 	/* 	Coupled Sink Status bitmap */
 	/* 	Not coupled/available for Coupling */
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
 	/*   MAC Addr. */
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
@@ -1058,7 +1058,7 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 
 u32 build_assoc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 len=0, wfdielen = 0;
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -1066,10 +1066,10 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 
 	/* 	WFD OUI */
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110812 */
 	/* 	According to the WFD Specification, the probe request frame should contain 4 WFD attributes */
@@ -1080,7 +1080,7 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1107,7 +1107,7 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1118,7 +1118,7 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -1129,7 +1129,7 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 
 	/* 	Coupled Sink Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1139,14 +1139,14 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 	/* 	Value: */
 	/* 	Coupled Sink Status bitmap */
 	/* 	Not coupled/available for Coupling */
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
 	/*   MAC Addr. */
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
@@ -1155,7 +1155,7 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 
 u32 build_nego_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 len=0, wfdielen = 0;
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -1163,10 +1163,10 @@ u32 build_nego_req_wfd_ie(struct wifidir
 
 	/* 	WFD OUI */
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110825 */
 	/* 	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes */
@@ -1177,7 +1177,7 @@ u32 build_nego_req_wfd_ie(struct wifidir
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1204,7 +1204,7 @@ u32 build_nego_req_wfd_ie(struct wifidir
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1215,7 +1215,7 @@ u32 build_nego_req_wfd_ie(struct wifidir
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -1226,7 +1226,7 @@ u32 build_nego_req_wfd_ie(struct wifidir
 
 	/* 	Coupled Sink Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1236,14 +1236,14 @@ u32 build_nego_req_wfd_ie(struct wifidir
 	/* 	Value: */
 	/* 	Coupled Sink Status bitmap */
 	/* 	Not coupled/available for Coupling */
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
 	/*   MAC Addr. */
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
@@ -1252,7 +1252,7 @@ u32 build_nego_req_wfd_ie(struct wifidir
 
 u32 build_nego_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 len=0, wfdielen = 0;
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -1260,10 +1260,10 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 
 	/* 	WFD OUI */
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110825 */
 	/* 	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes */
@@ -1274,7 +1274,7 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1301,7 +1301,7 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1312,7 +1312,7 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -1323,7 +1323,7 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 
 	/* 	Coupled Sink Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1333,14 +1333,14 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 	/* 	Value: */
 	/* 	Coupled Sink Status bitmap */
 	/* 	Not coupled/available for Coupling */
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
 	/*   MAC Addr. */
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
 
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
@@ -1350,7 +1350,7 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 
 u32 build_nego_confirm_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 len=0, wfdielen = 0;
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -1358,10 +1358,10 @@ u32 build_nego_confirm_wfd_ie(struct wif
 
 	/* 	WFD OUI */
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110825 */
 	/* 	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes */
@@ -1372,7 +1372,7 @@ u32 build_nego_confirm_wfd_ie(struct wif
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1399,7 +1399,7 @@ u32 build_nego_confirm_wfd_ie(struct wif
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1410,7 +1410,7 @@ u32 build_nego_confirm_wfd_ie(struct wif
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -1421,7 +1421,7 @@ u32 build_nego_confirm_wfd_ie(struct wif
 
 	/* 	Coupled Sink Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1431,14 +1431,14 @@ u32 build_nego_confirm_wfd_ie(struct wif
 	/* 	Value: */
 	/* 	Coupled Sink Status bitmap */
 	/* 	Not coupled/available for Coupling */
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
 	/*   MAC Addr. */
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
 
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
@@ -1448,7 +1448,7 @@ u32 build_nego_confirm_wfd_ie(struct wif
 
 u32 build_invitation_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 len=0, wfdielen = 0;
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -1456,10 +1456,10 @@ u32 build_invitation_req_wfd_ie(struct w
 
 	/* 	WFD OUI */
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110825 */
 	/* 	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes */
@@ -1470,7 +1470,7 @@ u32 build_invitation_req_wfd_ie(struct w
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1497,7 +1497,7 @@ u32 build_invitation_req_wfd_ie(struct w
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1508,7 +1508,7 @@ u32 build_invitation_req_wfd_ie(struct w
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -1519,7 +1519,7 @@ u32 build_invitation_req_wfd_ie(struct w
 
 	/* 	Coupled Sink Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1529,20 +1529,20 @@ u32 build_invitation_req_wfd_ie(struct w
 	/* 	Value: */
 	/* 	Coupled Sink Status bitmap */
 	/* 	Not coupled/available for Coupling */
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
 	/*   MAC Addr. */
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
 
 	if (P2P_ROLE_GO == pwdinfo->role)
 	{
 		/* 	WFD Session Information ATTR */
 		/* 	Type: */
-		wfdie[ wfdielen++ ] = WFD_ATTR_SESSION_INFO;
+		wfdie[wfdielen++] = WFD_ATTR_SESSION_INFO;
 
 		/* 	Length: */
 		/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1560,7 +1560,7 @@ u32 build_invitation_req_wfd_ie(struct w
 
 u32 build_invitation_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 len=0, wfdielen = 0;
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -1568,10 +1568,10 @@ u32 build_invitation_resp_wfd_ie(struct
 
 	/* 	WFD OUI */
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110825 */
 	/* 	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes */
@@ -1582,7 +1582,7 @@ u32 build_invitation_resp_wfd_ie(struct
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1609,7 +1609,7 @@ u32 build_invitation_resp_wfd_ie(struct
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1620,7 +1620,7 @@ u32 build_invitation_resp_wfd_ie(struct
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -1631,7 +1631,7 @@ u32 build_invitation_resp_wfd_ie(struct
 
 	/* 	Coupled Sink Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1641,20 +1641,20 @@ u32 build_invitation_resp_wfd_ie(struct
 	/* 	Value: */
 	/* 	Coupled Sink Status bitmap */
 	/* 	Not coupled/available for Coupling */
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
 	/*   MAC Addr. */
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
 
 	if (P2P_ROLE_GO == pwdinfo->role)
 	{
 		/* 	WFD Session Information ATTR */
 		/* 	Type: */
-		wfdie[ wfdielen++ ] = WFD_ATTR_SESSION_INFO;
+		wfdie[wfdielen++] = WFD_ATTR_SESSION_INFO;
 
 		/* 	Length: */
 		/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1672,7 +1672,7 @@ u32 build_invitation_resp_wfd_ie(struct
 
 u32 build_provdisc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 len=0, wfdielen = 0;
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -1680,10 +1680,10 @@ u32 build_provdisc_req_wfd_ie(struct wif
 
 	/* 	WFD OUI */
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110825 */
 	/* 	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes */
@@ -1694,7 +1694,7 @@ u32 build_provdisc_req_wfd_ie(struct wif
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1721,7 +1721,7 @@ u32 build_provdisc_req_wfd_ie(struct wif
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1732,7 +1732,7 @@ u32 build_provdisc_req_wfd_ie(struct wif
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -1743,7 +1743,7 @@ u32 build_provdisc_req_wfd_ie(struct wif
 
 	/* 	Coupled Sink Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1753,14 +1753,14 @@ u32 build_provdisc_req_wfd_ie(struct wif
 	/* 	Value: */
 	/* 	Coupled Sink Status bitmap */
 	/* 	Not coupled/available for Coupling */
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
 	/*   MAC Addr. */
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
 
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
@@ -1770,7 +1770,7 @@ u32 build_provdisc_req_wfd_ie(struct wif
 
 u32 build_provdisc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 len=0, wfdielen = 0;
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -1778,10 +1778,10 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 
 	/* 	WFD OUI */
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110825 */
 	/* 	According to the WFD Specification, the provision discovery response frame should contain 3 WFD attributes */
@@ -1792,7 +1792,7 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1819,7 +1819,7 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1830,7 +1830,7 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -1841,7 +1841,7 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 
 	/* 	Coupled Sink Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1851,14 +1851,14 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 	/* 	Value: */
 	/* 	Coupled Sink Status bitmap */
 	/* 	Not coupled/available for Coupling */
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
 	/*   MAC Addr. */
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
-	wfdie[ wfdielen++ ] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
+	wfdie[wfdielen++] = 0;
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
@@ -1869,7 +1869,7 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 
 u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
+	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
 	u32 len=0, p2pielen = 0;
 #ifdef CONFIG_INTEL_WIDI
 	u8 zero_array_check[L2SDTA_SERVICE_VE_LEN] = { 0x00 };
@@ -1877,10 +1877,10 @@ u32 build_probe_resp_p2p_ie(struct wifid
 
 	/* 	P2P OUI */
 	p2pielen = 0;
-	p2pie[ p2pielen++ ] = 0x50;
-	p2pie[ p2pielen++ ] = 0x6F;
-	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+	p2pie[p2pielen++] = 0x50;
+	p2pie[p2pielen++] = 0x6F;
+	p2pie[p2pielen++] = 0x9A;
+	p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 	/* 	Commented by Albert 20100907 */
 	/* 	According to the P2P Specification, the probe response frame should contain 5 P2P attributes */
@@ -1892,7 +1892,7 @@ u32 build_probe_resp_p2p_ie(struct wifid
 
 	/* 	P2P Capability ATTR */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
+	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 	/* 	Length: */
 	RTW_PUT_LE16(p2pie + p2pielen, 0x0002);
@@ -1900,15 +1900,15 @@ u32 build_probe_resp_p2p_ie(struct wifid
 
 	/* 	Value: */
 	/* 	Device Capability Bitmap, 1 byte */
-	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
+	p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
 
 	/* 	Group Capability Bitmap, 1 byte */
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
-		p2pie[ p2pielen ] = (P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS);
+		p2pie[p2pielen] = (P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS);
 
 		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
-			p2pie[ p2pielen ] |= P2P_GRPCAP_GROUP_FORMATION;
+			p2pie[p2pielen] |= P2P_GRPCAP_GROUP_FORMATION;
 
 		p2pielen++;
 	}
@@ -1916,15 +1916,15 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	{
 		/* 	Group Capability Bitmap, 1 byte */
 		if (pwdinfo->persistent_supported)
-			p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
+			p2pie[p2pielen++] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
 		else
-			p2pie[ p2pielen++ ] = DMP_P2P_GRPCAP_SUPPORT;
+			p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
 
 	}
 
 	/* 	Extended Listen Timing ATTR */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_EX_LISTEN_TIMING;
+	p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
 
 	/* 	Length: */
 	RTW_PUT_LE16(p2pie + p2pielen, 0x0004);
@@ -1951,7 +1951,7 @@ u32 build_probe_resp_p2p_ie(struct wifid
 
 	/* 	Device Info ATTR */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
+	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
@@ -1993,7 +1993,7 @@ u32 build_probe_resp_p2p_ie(struct wifid
 #ifdef CONFIG_INTEL_WIDI
 	if (_rtw_memcmp(pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == false)
 	{
-		p2pie[ p2pielen++ ] = 0x01;
+		p2pie[p2pielen++] = 0x01;
 
 		RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_CID_DISPLAYS);
 		p2pielen += 2;
@@ -2006,7 +2006,7 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	}
 	else
 #endif /* CONFIG_INTEL_WIDI */
-	p2pie[ p2pielen++ ] = 0x00;	/* 	No Secondary Device Type List */
+	p2pie[p2pielen++] = 0x00;	/* 	No Secondary Device Type List */
 
 	/* 	Device Name */
 	/* 	Type: */
@@ -2039,15 +2039,15 @@ u32 build_probe_resp_p2p_ie(struct wifid
 
 u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8* pssid, u8 ussidlen, u8* pdev_raddr)
 {
-	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
+	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
 	u32 len=0, p2pielen = 0;
 
 	/* 	P2P OUI */
 	p2pielen = 0;
-	p2pie[ p2pielen++ ] = 0x50;
-	p2pie[ p2pielen++ ] = 0x6F;
-	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+	p2pie[p2pielen++] = 0x50;
+	p2pie[p2pielen++] = 0x6F;
+	p2pie[p2pielen++] = 0x9A;
+	p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 	/* 	Commented by Albert 20110301 */
 	/* 	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes */
@@ -2057,7 +2057,7 @@ u32 build_prov_disc_request_p2p_ie(struc
 
 	/* 	P2P Capability ATTR */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
+	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 	/* 	Length: */
 	RTW_PUT_LE16(p2pie + p2pielen, 0x0002);
@@ -2065,18 +2065,18 @@ u32 build_prov_disc_request_p2p_ie(struc
 
 	/* 	Value: */
 	/* 	Device Capability Bitmap, 1 byte */
-	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
+	p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
 
 	/* 	Group Capability Bitmap, 1 byte */
 	if (pwdinfo->persistent_supported)
-		p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
+		p2pie[p2pielen++] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
 	else
-		p2pie[ p2pielen++ ] = DMP_P2P_GRPCAP_SUPPORT;
+		p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
 
 
 	/* 	Device Info ATTR */
 	/* 	Type: */
-	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
+	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
@@ -2116,7 +2116,7 @@ u32 build_prov_disc_request_p2p_ie(struc
 	p2pielen += 2;
 
 	/* 	Number of Secondary Device Types */
-	p2pie[ p2pielen++ ] = 0x00;	/* 	No Secondary Device Type List */
+	p2pie[p2pielen++] = 0x00;	/* 	No Secondary Device Type List */
 
 	/* 	Device Name */
 	/* 	Type: */
@@ -2138,7 +2138,7 @@ u32 build_prov_disc_request_p2p_ie(struc
 
 		/* 	P2P Group ID ATTR */
 		/* 	Type: */
-		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
+		p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
 
 		/* 	Length: */
 		RTW_PUT_LE16(p2pie + p2pielen, ETH_ALEN + ussidlen);
@@ -2162,15 +2162,15 @@ u32 build_prov_disc_request_p2p_ie(struc
 
 u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 status_code)
 {
-	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
+	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
 	u32 len=0, p2pielen = 0;
 
 	/* 	P2P OUI */
 	p2pielen = 0;
-	p2pie[ p2pielen++ ] = 0x50;
-	p2pie[ p2pielen++ ] = 0x6F;
-	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
+	p2pie[p2pielen++] = 0x50;
+	p2pie[p2pielen++] = 0x6F;
+	p2pie[p2pielen++] = 0x9A;
+	p2pie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
 	/*  According to the P2P Specification, the Association response frame should contain 2 P2P attributes */
 	/* 	1. Status */
@@ -2421,7 +2421,7 @@ u32 process_p2p_devdisc_req(struct wifid
 
 	if ((p2p_ie=rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)))
 	{
-		u8 groupid[ 38 ] = { 0x00 };
+		u8 groupid[38] = { 0x00 };
 		u8 dev_addr[ETH_ALEN] = { 0x00 };
 		u32	attr_contentlen = 0;
 
@@ -2573,7 +2573,7 @@ u8 rtw_p2p_check_peer_oper_ch(struct mlm
 
 	for (i = 0; i < pmlmeext->max_chan_nums; i++)
 	{
-		if (pmlmeext->channel_set[ i ].ChannelNum == ch)
+		if (pmlmeext->channel_set[i].ChannelNum == ch)
 		{
 			return _SUCCESS;
 		}
@@ -2591,9 +2591,9 @@ u8 rtw_p2p_ch_inclusion(struct mlme_ext_
 	{
 		for (j = temp; j < pmlmeext->max_chan_nums; j++)
 		{
-			if (*(peer_ch_list + i) == pmlmeext->channel_set[ j ].ChannelNum)
+			if (*(peer_ch_list + i) == pmlmeext->channel_set[j].ChannelNum)
 			{
-				ch_list_inclusioned[ ch_no++ ] = *(peer_ch_list + i);
+				ch_list_inclusioned[ch_no++] = *(peer_ch_list + i);
 				temp = j;
 				break;
 			}
@@ -2615,7 +2615,7 @@ u8 process_p2p_group_negotation_req(stru
 	u16		wps_devicepassword_id = 0x0000;
 	uint	wps_devicepassword_id_len = 0;
 #ifdef CONFIG_WFD
-	u8	wfd_ie[ 128 ] = { 0x00 };
+	u8	wfd_ie[128] = { 0x00 };
 	u32	wfd_ielen = 0;
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
@@ -2823,7 +2823,7 @@ u8 process_p2p_group_negotation_req(stru
 	/* 	Try to get the TCP port information when receiving the negotiation request. */
 	if (rtw_get_wfd_ie(pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wfd_ie, &wfd_ielen))
 	{
-		u8	attr_content[ 10 ] = { 0x00 };
+		u8	attr_content[10] = { 0x00 };
 		u32	attr_contentlen = 0;
 
 		DBG_8192D("[%s] WFD IE Found!!\n", __func__);
@@ -2848,7 +2848,7 @@ u8 process_p2p_group_negotation_resp(str
 	u32 ies_len;
 	u8 * p2p_ie;
 #ifdef CONFIG_WFD
-	u8	wfd_ie[ 128 ] = { 0x00 };
+	u8	wfd_ie[128] = { 0x00 };
 	u32	wfd_ielen = 0;
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
@@ -2884,7 +2884,7 @@ u8 process_p2p_group_negotation_resp(str
 		u8	operatingch_info[5] = { 0x00 };
 		uint	ch_cnt = 0;
 		u8	ch_content[50] = { 0x00 };
-		u8	groupid[ 38 ];
+		u8	groupid[38];
 		u16	cap_attr;
 		u8	peer_ch_list[50] = { 0x00 };
 		u8	peer_ch_num = 0;
@@ -3082,7 +3082,7 @@ u8 process_p2p_group_negotation_resp(str
 	/* 	Try to get the TCP port information when receiving the negotiation response. */
 	if (rtw_get_wfd_ie(pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wfd_ie, &wfd_ielen))
 	{
-		u8	attr_content[ 10 ] = { 0x00 };
+		u8	attr_content[10] = { 0x00 };
 		u32	attr_contentlen = 0;
 
 		DBG_8192D("[%s] WFD IE Found!!\n", __func__);
@@ -3112,7 +3112,7 @@ u8 process_p2p_group_negotation_confirm(
 	while (p2p_ie)	/* 	Found the P2P IE. */
 	{
 		u8	attr_content = 0x00, operatingch_info[5] = { 0x00 };
-		u8	groupid[ 38 ] = { 0x00 };
+		u8	groupid[38] = { 0x00 };
 		u32	attr_contentlen = 0;
 
 		pwdinfo->negotiation_dialog_token = 1;
@@ -4497,7 +4497,7 @@ void init_wifidirect_info(struct rtw_ada
 	pwdinfo->inviteresp_info.token = 0;
 
 	pwdinfo->profileindex = 0;
-	memset(&pwdinfo->profileinfo[ 0 ], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
+	memset(&pwdinfo->profileinfo[0], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
 
 	rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
 
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -150,7 +150,7 @@ _func_enter_;
 
 	for (p = buf; len > 0; ++p, --len)
 	{
-		crc = crc32_table[ (crc ^ *p) & 0xff] ^ (crc >> 8);
+		crc = crc32_table[(crc ^ *p) & 0xff] ^ (crc >> 8);
 	}
 _func_exit_;
 	return ~crc;    /* transmit complement, per CRC-32 spec */
@@ -531,10 +531,10 @@ static const unsigned short Sbox1[2][256
 *
 * Inputs:
 *     tk[]      = temporal key                         [128 bits]
-*     ta[]      = transmitter's MAC address            [ 48 bits]
-*     iv32      = upper 32 bits of IV                  [ 32 bits]
+*     ta[]      = transmitter's MAC address            [48 bits]
+*     iv32      = upper 32 bits of IV                  [32 bits]
 * Output:
-*     p1k[]     = Phase 1 key                          [ 80 bits]
+*     p1k[]     = Phase 1 key                          [80 bits]
 *
 * Note:
 *     This function only needs to be called every 2**16 packets,
@@ -574,8 +574,8 @@ _func_exit_;
 *
 * Inputs:
 *     tk[]      = Temporal key                         [128 bits]
-*     p1k[]     = Phase 1 output key                   [ 80 bits]
-*     iv16      = low 16 bits of IV counter            [ 16 bits]
+*     p1k[]     = Phase 1 output key                   [80 bits]
+*     iv16      = low 16 bits of IV counter            [16 bits]
 * Output:
 *     rc4key[]  = the key used to encrypt the packet   [128 bits]
 *
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -350,7 +350,7 @@ _func_enter_;
 /*  So, we initialize the tid_rxseq variable as the 0xffff. */
 
 		for (i = 0; i < 16; i++)
-                     memcpy(&psta->sta_recvpriv.rxcache.tid_rxseq[ i ], &wRxSeqInitialValue, 2);
+                     memcpy(&psta->sta_recvpriv.rxcache.tid_rxseq[i], &wRxSeqInitialValue, 2);
 
 		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_info_,("alloc number_%d stainfo  with hwaddr = %x %x %x %x %x %x \n",
 		pstapriv->asoc_sta_count , hwaddr[0], hwaddr[1], hwaddr[2],hwaddr[3],hwaddr[4],hwaddr[5]));
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ b/drivers/staging/rtl8192du/core/rtw_tdls.c
@@ -382,7 +382,7 @@ u8 *rtw_tdls_set_ht_cap(_adapter *padapt
 
 u8 *rtw_tdls_set_sup_ch(struct mlme_ext_priv *pmlmeext, u8 *pframe, struct pkt_attrib *pattrib)
 {
-	u8 sup_ch[ 30 * 2 ] = { 0x00 }, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
+	u8 sup_ch[30 * 2] = { 0x00 }, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
 	do{
 		if (pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14)
 		{
@@ -404,7 +404,7 @@ u8 *rtw_tdls_set_sup_ch(struct mlme_ext_
 #ifdef CONFIG_WFD
 void rtw_tdls_process_wfd_ie(struct tdls_info *ptdlsinfo, u8 *ptr, u8 length)
 {
-	u8	wfd_ie[ 128 ] = { 0x00 };
+	u8	wfd_ie[128] = { 0x00 };
 	u32	wfd_ielen = 0;
 	u32	wfd_offset = 0;
 	/* 	Try to get the TCP port information when receiving the negotiation response. */
@@ -414,7 +414,7 @@ void rtw_tdls_process_wfd_ie(struct tdls
 	wfd_offset = rtw_get_wfd_ie(ptr + wfd_offset, length - wfd_offset, wfd_ie, &wfd_ielen);
 	while (wfd_offset)
 	{
-		u8	attr_content[ 10 ] = { 0x00 };
+		u8	attr_content[10] = { 0x00 };
 		u32	attr_contentlen = 0;
 		int	i;
 
@@ -1893,15 +1893,15 @@ void wfd_ie_tdls(_adapter * padapter, u8
 {
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info	*pwfd_info = padapter->tdlsinfo.wfd_info;
-	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
+	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
 	u32 wfdielen = 0;
 
 	/* 	WFD OUI */
 	wfdielen = 0;
-	wfdie[ wfdielen++ ] = 0x50;
-	wfdie[ wfdielen++ ] = 0x6F;
-	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
+	wfdie[wfdielen++] = 0x50;
+	wfdie[wfdielen++] = 0x6F;
+	wfdie[wfdielen++] = 0x9A;
+	wfdie[wfdielen++] = 0x0A;	/* 	WFA WFD v1.0 */
 
 	/* 	Commented by Albert 20110825 */
 	/* 	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes */
@@ -1911,7 +1911,7 @@ void wfd_ie_tdls(_adapter * padapter, u8
 
 	/* 	WFD Device Information ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
+	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1939,7 +1939,7 @@ void wfd_ie_tdls(_adapter * padapter, u8
 
 	/* 	Associated BSSID ATTR */
 	/* 	Type: */
-	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
+	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1950,7 +1950,7 @@ void wfd_ie_tdls(_adapter * padapter, u8
 	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 	}
 	else
 	{
@@ -1958,7 +1958,7 @@ void wfd_ie_tdls(_adapter * padapter, u8
 	}
 
 	/* 	Local IP Address ATTR */
-	wfdie[ wfdielen++ ] = WFD_ATTR_LOCAL_IP_ADDR;
+	wfdie[wfdielen++] = WFD_ATTR_LOCAL_IP_ADDR;
 
 	/* 	Length: */
 	/* 	Note: In the WFD specification, the size of length field is 2. */
@@ -1967,7 +1967,7 @@ void wfd_ie_tdls(_adapter * padapter, u8
 
 	/* 	Version: */
 	/* 	0x01: Version1;IPv4 */
-	wfdie[ wfdielen++ ] = 0x01;
+	wfdie[wfdielen++] = 0x01;
 
 	/* 	IPv4 Address */
 	memcpy(wfdie + wfdielen, pwfd_info->ip_address, 4);
@@ -1996,7 +1996,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	u8 link_id_addr[18] = {0};
 	u8 iedata=0;
-	u8 sup_ch[ 30 * 2 ] = {0x00 }, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
+	u8 sup_ch[30 * 2] = {0x00 }, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
 	u8 timeout_itvl[5];	/* set timeout interval to maximum value */
 	u32 time;
 
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -799,14 +799,14 @@ int WFD_info_handler(struct rtw_adapter
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wifidirect_info	*pwdinfo;
-	u8	wfd_ie[ 128 ] = { 0x00 };
+	u8	wfd_ie[128] = { 0x00 };
 	u32	wfd_ielen = 0;
 
 
 	pwdinfo = &padapter->wdinfo;
 	if (rtw_get_wfd_ie((u8*) pIE, pIE->Length, wfd_ie, &wfd_ielen))
 	{
-		u8	attr_content[ 10 ] = { 0x00 };
+		u8	attr_content[10] = { 0x00 };
 		u32	attr_contentlen = 0;
 
 		printk("[%s] Found WFD IE\n", __func__);
--- a/drivers/staging/rtl8192du/include/if_ether.h
+++ b/drivers/staging/rtl8192du/include/if_ether.h
@@ -42,7 +42,7 @@
 #define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
 #define ETH_P_X25	0x0805		/* CCITT X.25			*/
 #define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
-#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[NOT AN OFFICIALLY REGISTERED ID] */
 #define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
 #define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
 #define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
--- a/drivers/staging/rtl8192du/include/rtw_mlme.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme.h
@@ -168,17 +168,17 @@ struct rt_link_detect {
 
 struct profile_info {
 	u8	ssidlen;
-	u8	ssid[ WLAN_SSID_MAXLEN ];
-	u8	peermac[ ETH_ALEN ];
+	u8	ssid[WLAN_SSID_MAXLEN];
+	u8	peermac[ETH_ALEN];
 };
 
 struct tx_invite_req_info{
 	u8					token;
 	u8					benable;
-	u8					go_ssid[ WLAN_SSID_MAXLEN ];
+	u8					go_ssid[WLAN_SSID_MAXLEN];
 	u8					ssidlen;
-	u8					go_bssid[ ETH_ALEN ];
-	u8					peer_macaddr[ ETH_ALEN ];
+	u8					go_bssid[ETH_ALEN];
+	u8					peer_macaddr[ETH_ALEN];
 	u8					operating_ch;	//	This information will be set by using the p2p_set op_ch=x
 	u8					peer_ch;		//	The listen channel for peer P2P device
 
@@ -217,26 +217,26 @@ struct tx_provdisc_req_info{
 	u16					wps_config_method_request;	//	Used when sending the provisioning request frame
 	u16					peer_channel_num[2];		//	The channel number which the receiver stands.
 	struct ndis_802_11_ssid	ssid;
-	u8					peerDevAddr[ ETH_ALEN ];		//	Peer device address
-	u8					peerIFAddr[ ETH_ALEN ];		//	Peer interface address
+	u8					peerDevAddr[ETH_ALEN];		//	Peer device address
+	u8					peerIFAddr[ETH_ALEN];		//	Peer interface address
 	u8					benable;					//	This provision discovery request frame is trigger to send or not
 };
 
 struct rx_provdisc_req_info{	//When peer device issue prov_disc_req first, we should store the following informations
-	u8					peerDevAddr[ ETH_ALEN ];		//	Peer device address
+	u8					peerDevAddr[ETH_ALEN];		//	Peer device address
 	u8					strconfig_method_desc_of_prov_disc_req[4];	//	description for the config method located in the provisioning discovery request frame.
 																	//	The UI must know this information to know which config method the remote p2p device is requiring.
 };
 
 struct tx_nego_req_info{
 	u16					peer_channel_num[2];		//	The channel number which the receiver stands.
-	u8					peerDevAddr[ ETH_ALEN ];		//	Peer device address
+	u8					peerDevAddr[ETH_ALEN];		//	Peer device address
 	u8					benable;					//	This negoitation request frame is trigger to send or not
 };
 
 struct group_id_info{
-	u8					go_device_addr[ ETH_ALEN ];	//	The GO's device address of this P2P group
-	u8					ssid[ WLAN_SSID_MAXLEN ];	//	The SSID of this P2P group
+	u8					go_device_addr[ETH_ALEN];	//	The GO's device address of this P2P group
+	u8					ssid[WLAN_SSID_MAXLEN];	//	The SSID of this P2P group
 };
 
 struct scan_limit_info{
@@ -271,7 +271,7 @@ struct wifidirect_info{
 	struct tx_provdisc_req_info	tx_prov_disc_info;
 	struct rx_provdisc_req_info rx_prov_disc_info;
 	struct tx_invite_req_info	invitereq_info;
-	struct profile_info			profileinfo[ P2P_MAX_PERSISTENT_GROUP_NUM ];	//	Store the profile information of persistent group
+	struct profile_info			profileinfo[P2P_MAX_PERSISTENT_GROUP_NUM];	//	Store the profile information of persistent group
 	struct tx_invite_resp_info	inviteresp_info;
 	struct tx_nego_req_info	nego_req_info;
 	struct group_id_info		groupid_info;	//	Store the group id information when doing the group negotiation handshake.
@@ -292,17 +292,17 @@ struct wifidirect_info{
 	u8						support_rate[8];
 	u8						p2p_wildcard_ssid[P2P_WILDCARD_SSID_LEN];
 	u8						intent;		//	should only include the intent value.
-	u8						p2p_peer_interface_addr[ ETH_ALEN ];
-	u8						p2p_peer_device_addr[ ETH_ALEN ];
+	u8						p2p_peer_interface_addr[ETH_ALEN];
+	u8						p2p_peer_device_addr[ETH_ALEN];
 	u8						peer_intent;	//	Included the intent value and tie breaker value.
-	u8						device_name[ WPS_MAX_DEVICE_NAME_LEN ];	//	Device name for displaying on searching device screen
+	u8						device_name[WPS_MAX_DEVICE_NAME_LEN];	//	Device name for displaying on searching device screen
 	u8						device_name_len;
 	u8						profileindex;	//	Used to point to the index of profileinfo array
 	u8						peer_operating_ch;
 	u8						find_phase_state_exchange_cnt;
 	u16						device_password_id_for_nego;	//	The device password ID for group negotation
 	u8						negotiation_dialog_token;
-	u8						nego_ssid[ WLAN_SSID_MAXLEN ];	//	SSID information for group negotitation
+	u8						nego_ssid[WLAN_SSID_MAXLEN];	//	SSID information for group negotitation
 	u8						nego_ssidlen;
 	u8						p2p_group_ssid[WLAN_SSID_MAXLEN];
 	u8						p2p_group_ssid_len;
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -2709,7 +2709,7 @@ static int cfg80211_rtw_set_pmksa(struct
 	u8	index,blInserted = false;
 	_adapter	*padapter = wiphy_to_adapter(wiphy);
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
-	u8	strZeroMacAddress[ ETH_ALEN ] = { 0x00 };
+	u8	strZeroMacAddress[ETH_ALEN] = { 0x00 };
 
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
 
@@ -2795,7 +2795,7 @@ static int cfg80211_rtw_flush_pmksa(stru
 
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
 
-	memset(&psecuritypriv->PMKIDList[ 0 ], 0x00, sizeof(RT_PMKID_LIST) * NUM_PMKID_CACHE);
+	memset(&psecuritypriv->PMKIDList[0], 0x00, sizeof(RT_PMKID_LIST) * NUM_PMKID_CACHE);
 	psecuritypriv->PMKIDIndex = 0;
 
 	return 0;
@@ -3743,7 +3743,7 @@ void rtw_cfg80211_issue_p2p_provision_re
 {
 	u16	wps_devicepassword_id = 0x0000;
 	uint	wps_devicepassword_id_len = 0;
-	u8			wpsie[ 255 ] = { 0x00 }, p2p_ie[ 255 ] = { 0x00 };
+	u8			wpsie[255] = { 0x00 }, p2p_ie[255] = { 0x00 };
 	uint			p2p_ielen = 0;
 	uint			wpsielen = 0;
 	u32	devinfo_contentlen = 0;
@@ -3863,10 +3863,10 @@ void rtw_cfg80211_issue_p2p_provision_re
 	//build_prov_disc_request_p2p_ie
 	//	P2P OUI
 	p2pielen = 0;
-	p2p_ie[ p2pielen++ ] = 0x50;
-	p2p_ie[ p2pielen++ ] = 0x6F;
-	p2p_ie[ p2pielen++ ] = 0x9A;
-	p2p_ie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+	p2p_ie[p2pielen++] = 0x50;
+	p2p_ie[p2pielen++] = 0x6F;
+	p2p_ie[p2pielen++] = 0x9A;
+	p2p_ie[p2pielen++] = 0x09;	//	WFA P2P v1.0
 
 	//	Commented by Albert 20110301
 	//	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes
@@ -3876,7 +3876,7 @@ void rtw_cfg80211_issue_p2p_provision_re
 
 	//	P2P Capability ATTR
 	//	Type:
-	p2p_ie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
+	p2p_ie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 	//	Length:
 	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
@@ -3892,7 +3892,7 @@ void rtw_cfg80211_issue_p2p_provision_re
 
 	//	Device Info ATTR
 	//	Type:
-	p2p_ie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
+	p2p_ie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
 
 	//	Length:
 	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -327,12 +327,12 @@ static char *translate_scan(struct rtw_a
 	if (SCAN_RESULT_WFD_TYPE == pwdinfo->wfd_info->scan_result_type)
 	{
 		u32	blnGotWFD = false;
-		u8	wfd_ie[ 128 ] = { 0x00 };
+		u8	wfd_ie[128] = { 0x00 };
 		uint	wfd_ielen = 0;
 
 		if (rtw_get_wfd_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen))
 		{
-			u8	wfd_devinfo[ 6 ] = { 0x00 };
+			u8	wfd_devinfo[6] = { 0x00 };
 			uint	wfd_devlen = 6;
 
 			if (rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, wfd_devinfo, &wfd_devlen))
@@ -340,7 +340,7 @@ static char *translate_scan(struct rtw_a
 				if (pwdinfo->wfd_info->wfd_device_type == WFD_DEVINFO_PSINK)
 				{
 					//	the first two bits will indicate the WFD device type
-					if ((wfd_devinfo[ 1 ] & 0x03) == WFD_DEVINFO_SOURCE)
+					if ((wfd_devinfo[1] & 0x03) == WFD_DEVINFO_SOURCE)
 					{
 						//	If this device is Miracast PSink device, the scan reuslt should just provide the Miracast source.
 						blnGotWFD = true;
@@ -349,7 +349,7 @@ static char *translate_scan(struct rtw_a
 				else if (pwdinfo->wfd_info->wfd_device_type == WFD_DEVINFO_SOURCE)
 				{
 					//	the first two bits will indicate the WFD device type
-					if ((wfd_devinfo[ 1 ] & 0x03) == WFD_DEVINFO_PSINK)
+					if ((wfd_devinfo[1] & 0x03) == WFD_DEVINFO_PSINK)
 					{
 						//	If this device is Miracast source device, the scan reuslt should just provide the Miracast PSink.
 						//	Todo: How about the SSink?!
@@ -1265,8 +1265,8 @@ static int rtw_wx_set_pmkid(struct net_d
 	struct mlme_priv  *pmlmepriv = &padapter->mlmepriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
         struct iw_pmksa*  pPMK = (struct iw_pmksa*) extra;
-        u8     strZeroMacAddress[ ETH_ALEN ] = { 0x00 };
-        u8     strIssueBssid[ ETH_ALEN ] = { 0x00 };
+        u8     strZeroMacAddress[ETH_ALEN] = { 0x00 };
+        u8     strIssueBssid[ETH_ALEN] = { 0x00 };
 
 /*
         struct iw_pmksa
@@ -1304,7 +1304,7 @@ static int rtw_wx_set_pmkid(struct net_d
                                 DBG_8192D("[rtw_wx_set_pmkid] BSSID exists in the PMKList.\n");
 
 				memcpy(psecuritypriv->PMKIDList[j].PMKID, pPMK->pmkid, IW_PMKID_LEN);
-                                psecuritypriv->PMKIDList[ j ].bUsed = true;
+                                psecuritypriv->PMKIDList[j].bUsed = true;
 				psecuritypriv->PMKIDIndex = j+1;
 				blInserted = true;
 				break;
@@ -1320,7 +1320,7 @@ static int rtw_wx_set_pmkid(struct net_d
 	            memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);
 		    memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);
 
-                    psecuritypriv->PMKIDList[ psecuritypriv->PMKIDIndex ].bUsed = true;
+                    psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = true;
 		    psecuritypriv->PMKIDIndex++ ;
 		    if (psecuritypriv->PMKIDIndex==16)
                     {
@@ -1336,8 +1336,8 @@ static int rtw_wx_set_pmkid(struct net_d
 		{
 			if (_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==true)
 			{ // BSSID is matched, the same AP => Remove this PMKID information and reset it.
-                                memset(psecuritypriv->PMKIDList[ j ].Bssid, 0x00, ETH_ALEN);
-                                psecuritypriv->PMKIDList[ j ].bUsed = false;
+                                memset(psecuritypriv->PMKIDList[j].Bssid, 0x00, ETH_ALEN);
+                                psecuritypriv->PMKIDList[j].bUsed = false;
 				break;
 			}
 	        }
@@ -1345,7 +1345,7 @@ static int rtw_wx_set_pmkid(struct net_d
         else if (pPMK->cmd == IW_PMKSA_FLUSH)
         {
             DBG_8192D("[rtw_wx_set_pmkid] IW_PMKSA_FLUSH!\n");
-            memset(&psecuritypriv->PMKIDList[ 0 ], 0x00, sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+            memset(&psecuritypriv->PMKIDList[0], 0x00, sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
             psecuritypriv->PMKIDIndex = 0;
             intReturn = true;
         }
@@ -3769,12 +3769,12 @@ static int rtw_p2p_set_intent(struct net
 	{
 		case 1:
 		{
-			intent = extra[ 0 ] - '0';
+			intent = extra[0] - '0';
 			break;
 		}
 		case 2:
 		{
-			intent = str_2char2num(extra[ 0 ], extra[ 1 ]);
+			intent = str_2char2num(extra[0], extra[1]);
 			break;
 		}
 	}
@@ -3807,12 +3807,12 @@ static int rtw_p2p_set_listen_ch(struct
 	{
 		case 1:
 		{
-			listen_ch = extra[ 0 ] - '0';
+			listen_ch = extra[0] - '0';
 			break;
 		}
 		case 2:
 		{
-			listen_ch = str_2char2num(extra[ 0 ], extra[ 1 ]);
+			listen_ch = str_2char2num(extra[0], extra[1]);
 			break;
 		}
 	}
@@ -3848,12 +3848,12 @@ static int rtw_p2p_set_op_ch(struct net_
 	{
 		case 1:
 		{
-			op_ch = extra[ 0 ] - '0';
+			op_ch = extra[0] - '0';
 			break;
 		}
 		case 2:
 		{
-			op_ch = str_2char2num(extra[ 0 ], extra[ 1 ]);
+			op_ch = str_2char2num(extra[0], extra[1]);
 			break;
 		}
 	}
@@ -3898,10 +3898,10 @@ static int rtw_p2p_profilefound(struct n
 	//	The upper application should pass the SSID to driver by using this rtw_p2p_profilefound function.
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
-		if (extra[ 0 ] == '0')
+		if (extra[0] == '0')
 		{
 			//	Remove all the profile information of wifidirect_info structure.
-			memset(&pwdinfo->profileinfo[ 0 ], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
+			memset(&pwdinfo->profileinfo[0], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
 			pwdinfo->profileindex = 0;
 		}
 		else
@@ -3918,11 +3918,11 @@ static int rtw_p2p_profilefound(struct n
 				//	Ex:  1XX:XX:XX:XX:XX:XXYYSSID
 				for (jj = 0, kk = 1; jj < ETH_ALEN; jj++, kk += 3)
 				{
-					pwdinfo->profileinfo[ pwdinfo->profileindex ].peermac[ jj ] = key_2char2num(extra[ kk ], extra[ kk+ 1 ]);
+					pwdinfo->profileinfo[pwdinfo->profileindex].peermac[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
 				}
 
-				//pwdinfo->profileinfo[ pwdinfo->profileindex ].ssidlen = (extra[18] - '0') * 10 + (extra[ 19 ] - '0');
-				//memcpy(pwdinfo->profileinfo[ pwdinfo->profileindex ].ssid, &extra[ 20 ], pwdinfo->profileinfo[ pwdinfo->profileindex ].ssidlen);
+				//pwdinfo->profileinfo[pwdinfo->profileindex].ssidlen = (extra[18] - '0') * 10 + (extra[19] - '0');
+				//memcpy(pwdinfo->profileinfo[pwdinfo->profileindex].ssid, &extra[20], pwdinfo->profileinfo[pwdinfo->profileindex].ssidlen);
 				pwdinfo->profileindex++;
 			}
 		}
@@ -3964,8 +3964,8 @@ static int rtw_p2p_get_status(struct net
 	if (padapter->bShowGetP2PState)
 	{
 		DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-				pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
-				pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
+				pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
+				pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
 	}
 
 	//	Commented by Albert 2010/10/12
@@ -4010,8 +4010,8 @@ static int rtw_p2p_get_role(struct net_d
 
 
 	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-			pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
-			pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
+			pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
+			pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
 
 	sprintf(extra, "\n\nRole=%.2d\n", rtw_p2p_role(pwdinfo));
 	wrqu->data.length = strlen(extra);
@@ -4031,12 +4031,12 @@ static int rtw_p2p_get_peer_ifaddr(struc
 
 
 	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-			pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
-			pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
+			pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
+			pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
 
 	sprintf(extra, "\nMAC %.2X:%.2X:%.2X:%.2X:%.2X:%.2X",
-			pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
-			pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
+			pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
+			pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
 	wrqu->data.length = strlen(extra);
 	return ret;
 }
@@ -4053,13 +4053,13 @@ static int rtw_p2p_get_peer_devaddr(stru
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-			pwdinfo->rx_prov_disc_info.peerDevAddr[ 0 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 1 ],
-			pwdinfo->rx_prov_disc_info.peerDevAddr[ 2 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 3 ],
-			pwdinfo->rx_prov_disc_info.peerDevAddr[ 4 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 5 ]);
+			pwdinfo->rx_prov_disc_info.peerDevAddr[0], pwdinfo->rx_prov_disc_info.peerDevAddr[1],
+			pwdinfo->rx_prov_disc_info.peerDevAddr[2], pwdinfo->rx_prov_disc_info.peerDevAddr[3],
+			pwdinfo->rx_prov_disc_info.peerDevAddr[4], pwdinfo->rx_prov_disc_info.peerDevAddr[5]);
 	sprintf(extra, "\n%.2X%.2X%.2X%.2X%.2X%.2X",
-			pwdinfo->rx_prov_disc_info.peerDevAddr[ 0 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 1 ],
-			pwdinfo->rx_prov_disc_info.peerDevAddr[ 2 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 3 ],
-			pwdinfo->rx_prov_disc_info.peerDevAddr[ 4 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 5 ]);
+			pwdinfo->rx_prov_disc_info.peerDevAddr[0], pwdinfo->rx_prov_disc_info.peerDevAddr[1],
+			pwdinfo->rx_prov_disc_info.peerDevAddr[2], pwdinfo->rx_prov_disc_info.peerDevAddr[3],
+			pwdinfo->rx_prov_disc_info.peerDevAddr[4], pwdinfo->rx_prov_disc_info.peerDevAddr[5]);
 	wrqu->data.length = strlen(extra);
 	return ret;
 }
@@ -4076,13 +4076,13 @@ static int rtw_p2p_get_peer_devaddr_by_i
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-			pwdinfo->p2p_peer_device_addr[ 0 ], pwdinfo->p2p_peer_device_addr[ 1 ],
-			pwdinfo->p2p_peer_device_addr[ 2 ], pwdinfo->p2p_peer_device_addr[ 3 ],
-			pwdinfo->p2p_peer_device_addr[ 4 ], pwdinfo->p2p_peer_device_addr[ 5 ]);
+			pwdinfo->p2p_peer_device_addr[0], pwdinfo->p2p_peer_device_addr[1],
+			pwdinfo->p2p_peer_device_addr[2], pwdinfo->p2p_peer_device_addr[3],
+			pwdinfo->p2p_peer_device_addr[4], pwdinfo->p2p_peer_device_addr[5]);
 	sprintf(extra, "\nMAC %.2X:%.2X:%.2X:%.2X:%.2X:%.2X",
-			pwdinfo->p2p_peer_device_addr[ 0 ], pwdinfo->p2p_peer_device_addr[ 1 ],
-			pwdinfo->p2p_peer_device_addr[ 2 ], pwdinfo->p2p_peer_device_addr[ 3 ],
-			pwdinfo->p2p_peer_device_addr[ 4 ], pwdinfo->p2p_peer_device_addr[ 5 ]);
+			pwdinfo->p2p_peer_device_addr[0], pwdinfo->p2p_peer_device_addr[1],
+			pwdinfo->p2p_peer_device_addr[2], pwdinfo->p2p_peer_device_addr[3],
+			pwdinfo->p2p_peer_device_addr[4], pwdinfo->p2p_peer_device_addr[5]);
 	wrqu->data.length = strlen(extra);
 	return ret;
 }
@@ -4099,9 +4099,9 @@ static int rtw_p2p_get_groupid(struct ne
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	sprintf(extra, "\n%.2X:%.2X:%.2X:%.2X:%.2X:%.2X %s",
-			pwdinfo->groupid_info.go_device_addr[ 0 ], pwdinfo->groupid_info.go_device_addr[ 1 ],
-			pwdinfo->groupid_info.go_device_addr[ 2 ], pwdinfo->groupid_info.go_device_addr[ 3 ],
-			pwdinfo->groupid_info.go_device_addr[ 4 ], pwdinfo->groupid_info.go_device_addr[ 5 ],
+			pwdinfo->groupid_info.go_device_addr[0], pwdinfo->groupid_info.go_device_addr[1],
+			pwdinfo->groupid_info.go_device_addr[2], pwdinfo->groupid_info.go_device_addr[3],
+			pwdinfo->groupid_info.go_device_addr[4], pwdinfo->groupid_info.go_device_addr[5],
 			pwdinfo->groupid_info.ssid);
 	wrqu->data.length = strlen(extra);
 	return ret;
@@ -4600,9 +4600,9 @@ static int rtw_p2p_connect(struct net_de
 	int ret = 0;
 	struct rtw_adapter				*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	u8					peerMAC[ ETH_ALEN ] = { 0x00 };
+	u8					peerMAC[ETH_ALEN] = { 0x00 };
 	int					jj,kk;
-	u8					peerMACStr[ ETH_ALEN * 2 ] = { 0x00 };
+	u8					peerMACStr[ETH_ALEN * 2] = { 0x00 };
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct list_head *plist, *phead;
 	struct __queue *queue	= &(pmlmepriv->scanned_queue);
@@ -4636,7 +4636,7 @@ static int rtw_p2p_connect(struct net_de
 
 	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
 	{
-		peerMAC[ jj ] = key_2char2num(extra[kk], extra[kk+ 1]);
+		peerMAC[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
 	}
 
 	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
@@ -4674,7 +4674,7 @@ static int rtw_p2p_connect(struct net_de
 		memset(&pwdinfo->nego_req_info, 0x00, sizeof(struct tx_nego_req_info));
 		memset(&pwdinfo->groupid_info, 0x00, sizeof(struct group_id_info));
 
-		pwdinfo->nego_req_info.peer_channel_num[ 0 ] = uintPeerChannel;
+		pwdinfo->nego_req_info.peer_channel_num[0] = uintPeerChannel;
 		memcpy(pwdinfo->nego_req_info.peerDevAddr, pnetwork->network.MacAddress, ETH_ALEN);
 		pwdinfo->nego_req_info.benable = true;
 
@@ -4734,7 +4734,7 @@ static int rtw_p2p_invite_req(struct net
 	struct iw_point				*pdata = &wrqu->data;
 	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
 	int						jj,kk;
-	u8						peerMACStr[ ETH_ALEN * 2 ] = { 0x00 };
+	u8						peerMACStr[ETH_ALEN * 2] = { 0x00 };
 	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
 	struct list_head *plist, *phead;
 	struct __queue *queue = &(pmlmepriv->scanned_queue);
@@ -4788,7 +4788,7 @@ static int rtw_p2p_invite_req(struct net
 
 	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
 	{
-		pinvite_req_info->peer_macaddr[ jj ] = key_2char2num(extra[kk], extra[kk+ 1]);
+		pinvite_req_info->peer_macaddr[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
 	}
 
 	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
@@ -4842,12 +4842,12 @@ static int rtw_p2p_invite_req(struct net
 #ifdef CONFIG_WFD
 	if (uintPeerChannel)
 	{
-		u8	wfd_ie[ 128 ] = { 0x00 };
+		u8	wfd_ie[128] = { 0x00 };
 		uint	wfd_ielen = 0;
 
 		if (rtw_get_wfd_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen))
 		{
-			u8	wfd_devinfo[ 6 ] = { 0x00 };
+			u8	wfd_devinfo[6] = { 0x00 };
 			uint	wfd_devlen = 6;
 
 			DBG_8192D("[%s] Found WFD IE!\n", __func__);
@@ -4890,12 +4890,12 @@ static int rtw_p2p_invite_req(struct net
 		//	Store the GO's bssid
 		for (jj = 0, kk = 18; jj < ETH_ALEN; jj++, kk += 3)
 		{
-			pinvite_req_info->go_bssid[ jj ] = key_2char2num(extra[kk], extra[kk+ 1]);
+			pinvite_req_info->go_bssid[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
 		}
 
 		//	Store the GO's ssid
 		pinvite_req_info->ssidlen = wrqu->data.length - 36;
-		memcpy(pinvite_req_info->go_ssid, &extra[ 36 ], (u32) pinvite_req_info->ssidlen);
+		memcpy(pinvite_req_info->go_ssid, &extra[36], (u32) pinvite_req_info->ssidlen);
 		pinvite_req_info->benable = true;
 		pinvite_req_info->peer_ch = uintPeerChannel;
 
@@ -4954,7 +4954,7 @@ static int rtw_p2p_set_persistent(struct
 	struct iw_point				*pdata = &wrqu->data;
 	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
 	int						jj,kk;
-	u8						peerMACStr[ ETH_ALEN * 2 ] = { 0x00 };
+	u8						peerMACStr[ETH_ALEN * 2] = { 0x00 };
 	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
 	struct list_head *plist, *phead;
 	struct __queue *queue = &(pmlmepriv->scanned_queue);
@@ -4988,11 +4988,11 @@ static int rtw_p2p_set_persistent(struct
 	}
 	else
 	{
-		if (extra[ 0 ] == '0')	//	Disable the persistent group function.
+		if (extra[0] == '0')	//	Disable the persistent group function.
 		{
 			pwdinfo->persistent_supported = false;
 		}
-		else if (extra[ 0 ] == '1')	//	Enable the persistent group function.
+		else if (extra[0] == '1')	//	Enable the persistent group function.
 		{
 			pwdinfo->persistent_supported = true;
 		}
@@ -5018,9 +5018,9 @@ static int rtw_p2p_set_pc(struct net_dev
 	struct rtw_adapter				*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point			*pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	u8					peerMAC[ ETH_ALEN ] = { 0x00 };
+	u8					peerMAC[ETH_ALEN] = { 0x00 };
 	int					jj,kk;
-	u8					peerMACStr[ ETH_ALEN * 2 ] = { 0x00 };
+	u8					peerMACStr[ETH_ALEN * 2] = { 0x00 };
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct list_head *plist, *phead;
 	struct __queue *queue = &(pmlmepriv->scanned_queue);
@@ -5049,7 +5049,7 @@ static int rtw_p2p_set_pc(struct net_dev
 
 	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
 	{
-		peerMAC[ jj ] = key_2char2num(extra[kk], extra[kk+ 1]);
+		peerMAC[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
 	}
 
 	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
@@ -5105,12 +5105,12 @@ static int rtw_p2p_set_pc(struct net_dev
 
 	if (uintPeerChannel)
 	{
-		u8	wfd_ie[ 128 ] = { 0x00 };
+		u8	wfd_ie[128] = { 0x00 };
 		uint	wfd_ielen = 0;
 
 		if (rtw_get_wfd_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen))
 		{
-			u8	wfd_devinfo[ 6 ] = { 0x00 };
+			u8	wfd_devinfo[6] = { 0x00 };
 			uint	wfd_devlen = 6;
 
 			DBG_8192D("[%s] Found WFD IE!\n", __func__);
@@ -5161,7 +5161,7 @@ static int rtw_p2p_set_wfd_device_type(s
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
-	if (extra[ 0 ] == '0')	//	Set to Miracast source device.
+	if (extra[0] == '0')	//	Set to Miracast source device.
 	{
 		pwfd_info->wfd_device_type = WFD_DEVINFO_SOURCE;
 	}
@@ -5196,15 +5196,15 @@ static int rtw_p2p_set_scan_result_type(
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
-	if (extra[ 0 ] == '0')
+	if (extra[0] == '0')
 	{
 		pwfd_info->scan_result_type = SCAN_RESULT_P2P_ONLY;
 	}
-	else if (extra[ 0 ] == '1')
+	else if (extra[0] == '1')
 	{
 		pwfd_info->scan_result_type = SCAN_RESULT_ALL;
 	}
-	else if (extra[ 0 ] == '2')
+	else if (extra[0] == '2')
 	{
 		pwfd_info->scan_result_type = SCAN_RESULT_WFD_TYPE;
 	}
@@ -5232,9 +5232,9 @@ static int rtw_p2p_set_sa(struct net_dev
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
-	if (extra[ 0 ] == '0')	//	Disable the session available.
+	if (extra[0] == '0')	//	Disable the session available.
 		pwdinfo->session_available = false;
-	else if (extra[ 0 ] == '1')	//	Enable the session available.
+	else if (extra[0] == '1')	//	Enable the session available.
 		pwdinfo->session_available = true;
 	else
 		pwdinfo->session_available = false;
@@ -5253,9 +5253,9 @@ static int rtw_p2p_prov_disc(struct net_
 	int ret = 0;
 	struct rtw_adapter				*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	u8					peerMAC[ ETH_ALEN ] = { 0x00 };
+	u8					peerMAC[ETH_ALEN] = { 0x00 };
 	int					jj,kk;
-	u8					peerMACStr[ ETH_ALEN * 2 ] = { 0x00 };
+	u8					peerMACStr[ETH_ALEN * 2] = { 0x00 };
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct list_head *plist, *phead;
 	struct __queue *queue = &(pmlmepriv->scanned_queue);
@@ -5295,29 +5295,29 @@ static int rtw_p2p_prov_disc(struct net_
 		memset(pwdinfo->tx_prov_disc_info.peerDevAddr, 0x00, ETH_ALEN);
 		memset(pwdinfo->tx_prov_disc_info.peerIFAddr, 0x00, ETH_ALEN);
 		memset(&pwdinfo->tx_prov_disc_info.ssid, 0x00, sizeof(struct ndis_802_11_ssid));
-		pwdinfo->tx_prov_disc_info.peer_channel_num[ 0 ] = 0;
-		pwdinfo->tx_prov_disc_info.peer_channel_num[ 1 ] = 0;
+		pwdinfo->tx_prov_disc_info.peer_channel_num[0] = 0;
+		pwdinfo->tx_prov_disc_info.peer_channel_num[1] = 0;
 		pwdinfo->tx_prov_disc_info.benable = false;
 	}
 
 	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
 	{
-		peerMAC[ jj ] = key_2char2num(extra[kk], extra[kk+ 1]);
+		peerMAC[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
 	}
 
-	if (_rtw_memcmp(&extra[ 18 ], "display", 7))
+	if (_rtw_memcmp(&extra[18], "display", 7))
 	{
 		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_DISPLYA;
 	}
-	else if (_rtw_memcmp(&extra[ 18 ], "keypad", 7))
+	else if (_rtw_memcmp(&extra[18], "keypad", 7))
 	{
 		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_KEYPAD;
 	}
-	else if (_rtw_memcmp(&extra[ 18 ], "pbc", 3))
+	else if (_rtw_memcmp(&extra[18], "pbc", 3))
 	{
 		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_PUSH_BUTTON;
 	}
-	else if (_rtw_memcmp(&extra[ 18 ], "label", 5))
+	else if (_rtw_memcmp(&extra[18], "label", 5))
 	{
 		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_LABEL;
 	}
@@ -5385,12 +5385,12 @@ static int rtw_p2p_prov_disc(struct net_
 
 #ifdef CONFIG_WFD
 	{
-		u8	wfd_ie[ 128 ] = { 0x00 };
+		u8	wfd_ie[128] = { 0x00 };
 		uint	wfd_ielen = 0;
 
 		if (rtw_get_wfd_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen))
 		{
-			u8	wfd_devinfo[ 6 ] = { 0x00 };
+			u8	wfd_devinfo[6] = { 0x00 };
 			uint	wfd_devlen = 6;
 
 			DBG_8192D("[%s] Found WFD IE!\n", __func__);
@@ -8121,7 +8121,7 @@ static int rtw_mp_efuse_get(struct net_d
 	else if (strcmp(tmp[0],"ableraw") == 0) {
 		efuse_GetCurrentSize(padapter,&raw_cursize);
 		raw_maxsize = efuse_GetMaxSize(padapter);
-		sprintf(extra, "%s : [ available raw size] = %d",extra,raw_maxsize-raw_cursize);
+		sprintf(extra, "%s : [available raw size] = %d",extra,raw_maxsize-raw_cursize);
 		wrqu->length = strlen(extra);
 
 		return 0;
@@ -9414,7 +9414,7 @@ static int rtw_wfd_tdls_enable(struct ne
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	if (extra[ 0 ] == '0')
+	if (extra[0] == '0')
 	{
 		padapter->wdinfo.wfd_tdls_enable = 0;
 	}
@@ -9442,7 +9442,7 @@ static int rtw_tdls_weaksec(struct net_d
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	if (extra[ 0 ] == '0')
+	if (extra[0] == '0')
 	{
 		padapter->wdinfo.wfd_tdls_weaksec = 0;
 	}
@@ -9477,7 +9477,7 @@ static int rtw_tdls_enable(struct net_de
 
 	memset(tdls_sta, 0x00, sizeof(tdls_sta));
 
-	if (extra[ 0 ] == '0')
+	if (extra[0] == '0')
 	{
 		ptdlsinfo->enable = 0;
 
@@ -9514,7 +9514,7 @@ static int rtw_tdls_enable(struct net_de
 		}
 		rtw_tdls_cmd(padapter, myid(&(padapter->eeprompriv)), TDLS_RS_RCR);
 		rtw_reset_tdls_info(padapter);
-	} else if (extra[ 0 ] == '1') {
+	} else if (extra[0] == '1') {
 		ptdlsinfo->enable = 1;
 	}
 #endif //CONFIG_TDLS
--- a/drivers/staging/rtl8192du/os_dep/mlme_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/mlme_linux.c
@@ -103,7 +103,7 @@ void rtw_os_indicate_scan_done(struct rt
 	indicate_wx_scan_complete_event(padapter);
 }
 
-static struct RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
+static struct RT_PMKID_LIST   backupPMKIDList[NUM_PMKID_CACHE];
 void rtw_reset_securitypriv(struct rtw_adapter *adapter)
 {
 	u8	backupPMKIDIndex = 0;
@@ -118,9 +118,9 @@ void rtw_reset_securitypriv(struct rtw_a
 		// Backup the btkip_countermeasure information.
 		// When the countermeasure is trigger, the driver have to disconnect with AP for 60 seconds.
 
-		memset(&backupPMKIDList[ 0 ], 0x00, sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+		memset(&backupPMKIDList[0], 0x00, sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
 
-		memcpy(&backupPMKIDList[ 0 ], &adapter->securitypriv.PMKIDList[ 0 ], sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+		memcpy(&backupPMKIDList[0], &adapter->securitypriv.PMKIDList[0], sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
 		backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
 		backupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;
 		backupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;
@@ -130,7 +130,7 @@ void rtw_reset_securitypriv(struct rtw_a
 
 		// Added by Albert 2009/02/18
 		// Restore the PMK information to securitypriv structure for the following connection.
-		memcpy(&adapter->securitypriv.PMKIDList[ 0 ], &backupPMKIDList[ 0 ], sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+		memcpy(&adapter->securitypriv.PMKIDList[0], &backupPMKIDList[0], sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
 		adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
 		adapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
 		adapter->securitypriv.btkip_countermeasure_time = backupTKIPcountermeasure_time;
@@ -160,7 +160,7 @@ void rtw_reset_securitypriv(struct rtw_a
 
 void rtw_os_indicate_disconnect(struct rtw_adapter *adapter)
 {
-   //struct RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
+   //struct RT_PMKID_LIST   backupPMKIDList[NUM_PMKID_CACHE];
 
 _func_enter_;
 
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -160,7 +160,7 @@ void rtw_handle_tkip_mic_err(struct rtw_
 		key_type |= NL80211_KEYTYPE_PAIRWISE;
 	}
 
-	cfg80211_michael_mic_failure(padapter->pnetdev, (u8 *)&pmlmepriv->assoc_bssid[ 0 ], key_type, -1,
+	cfg80211_michael_mic_failure(padapter->pnetdev, (u8 *)&pmlmepriv->assoc_bssid[0], key_type, -1,
 		NULL, GFP_ATOMIC);
 #endif
 
@@ -175,7 +175,7 @@ void rtw_handle_tkip_mic_err(struct rtw_
 	}
 
 	ev.src_addr.sa_family = ARPHRD_ETHER;
-	memcpy(ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
+	memcpy(ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
 
 	memset(&wrqu, 0x00, sizeof(wrqu));
 	wrqu.data.length = sizeof(ev);
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -314,7 +314,7 @@ static int get_int_from_command(char* pc
 
 	for (i = 0; i < strlen(pcmd); i++)
 	{
-		if (pcmd[ i ] == '=')
+		if (pcmd[i] == '=')
 		{
 			//	Skip the '=' and space characters.
 			i += 2;

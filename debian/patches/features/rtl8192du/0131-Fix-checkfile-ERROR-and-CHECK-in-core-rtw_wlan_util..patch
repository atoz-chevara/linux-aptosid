From e9b6aa1ab8d63fb0709e8e398499c985ea1b5bd5 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Mon, 6 May 2013 21:45:55 -0500
Subject: [PATCH 131/390] Fix checkfile ERROR and CHECK in core/rtw_wlan_util.c

This patch also fixes sparse warnings other than endian issues

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_wlan_util.c | 1144 +++++++++++++++++++-------------------------------
 include/wifi.h       |    1 +
 2 files changed, 434 insertions(+), 711 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -25,18 +25,18 @@
 #include <wifi.h>
 
 
-unsigned char ARTHEROS_OUI1[] = {0x00, 0x03, 0x7f};
-unsigned char ARTHEROS_OUI2[] = {0x00, 0x13, 0x74};
+static unsigned char ARTHEROS_OUI1[] = {0x00, 0x03, 0x7f};
+static unsigned char ARTHEROS_OUI2[] = {0x00, 0x13, 0x74};
 
-unsigned char BROADCOM_OUI1[] = {0x00, 0x10, 0x18};
-unsigned char BROADCOM_OUI2[] = {0x00, 0x0a, 0xf7};
-unsigned char BROADCOM_OUI3[] = {0x00, 0x05, 0xb5};
-
-unsigned char CISCO_OUI[] = {0x00, 0x40, 0x96};
-unsigned char MARVELL_OUI[] = {0x00, 0x50, 0x43};
-unsigned char RALINK_OUI[] = {0x00, 0x0c, 0x43};
-unsigned char REALTEK_OUI[] = {0x00, 0xe0, 0x4c};
-unsigned char AIRGOCAP_OUI[] = {0x00, 0x0a, 0xf5};
+static unsigned char BROADCOM_OUI1[] = {0x00, 0x10, 0x18};
+static unsigned char BROADCOM_OUI2[] = {0x00, 0x0a, 0xf7};
+static unsigned char BROADCOM_OUI3[] = {0x00, 0x05, 0xb5};
+
+static unsigned char CISCO_OUI[] = {0x00, 0x40, 0x96};
+static unsigned char MARVELL_OUI[] = {0x00, 0x50, 0x43};
+static unsigned char RALINK_OUI[] = {0x00, 0x0c, 0x43};
+static unsigned char REALTEK_OUI[] = {0x00, 0xe0, 0x4c};
+static unsigned char AIRGOCAP_OUI[] = {0x00, 0x0a, 0xf5};
 
 unsigned char REALTEK_96B_IE[] = {0x00, 0xe0, 0x4c, 0x02, 0x01, 0x20};
 
@@ -77,11 +77,10 @@ int cckrates_included(unsigned char *rat
 {
 	int	i;
 
-	for (i = 0; i < ratelen; i++)
-	{
-		if  ( (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
-			   (((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22))
-		return true;
+	for (i = 0; i < ratelen; i++) {
+		if ((((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
+		    (((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22))
+			return true;
 	}
 
 	return false;
@@ -91,11 +90,10 @@ int cckratesonly_included(unsigned char
 {
 	int	i;
 
-	for (i = 0; i < ratelen; i++)
-	{
-		if  ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
-			   (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22))
-		return false;
+	for (i = 0; i < ratelen; i++) {
+		if ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+		    (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22))
+			return false;
 	}
 
 	return true;
@@ -105,33 +103,31 @@ unsigned char networktype_to_raid(unsign
 {
 	unsigned char raid;
 
-	switch (network_type)
-	{
-		case WIRELESS_11B:
-			raid = 6;
-			break;
-		case WIRELESS_11A:
-		case WIRELESS_11G:
-			raid = 5;
-			break;
-		case WIRELESS_11BG:
-			raid = 4;
-			break;
-		case WIRELESS_11_24N:
-		case WIRELESS_11_5N:
-			raid = 3;
-			break;
-		case WIRELESS_11A_5N:
-		case WIRELESS_11G_24N:
-			raid = 1;
-			break;
-		case WIRELESS_11BG_24N:
-			raid = 0;
-			break;
-		default:
-			raid = 4;
-			break;
-
+	switch (network_type) {
+	case WIRELESS_11B:
+		raid = 6;
+		break;
+	case WIRELESS_11A:
+	case WIRELESS_11G:
+		raid = 5;
+		break;
+	case WIRELESS_11BG:
+		raid = 4;
+		break;
+	case WIRELESS_11_24N:
+	case WIRELESS_11_5N:
+		raid = 3;
+		break;
+	case WIRELESS_11A_5N:
+	case WIRELESS_11G_24N:
+		raid = 1;
+		break;
+	case WIRELESS_11BG_24N:
+		raid = 0;
+		break;
+	default:
+		raid = 4;
+		break;
 	}
 
 	return raid;
@@ -144,96 +140,67 @@ int judge_network_type(struct rtw_adapte
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 
-	if (pmlmeext->cur_channel > 14)
-	{
+	if (pmlmeext->cur_channel > 14) {
 		if (pmlmeinfo->HT_enable)
-		{
 			network_type = WIRELESS_11_5N;
-		}
 
 		network_type |= WIRELESS_11A;
-	}
-	else
-	{
+	} else {
 		if (pmlmeinfo->HT_enable)
-		{
 			network_type = WIRELESS_11_24N;
-		}
 
 		if ((cckratesonly_included(rate, ratelen)) == true)
-		{
 			network_type |= WIRELESS_11B;
-		}
 		else if ((cckrates_included(rate, ratelen)) == true)
-		{
 			network_type |= WIRELESS_11BG;
-		}
 		else
-		{
 			network_type |= WIRELESS_11G;
-		}
 	}
-
 	return	network_type;
 }
 
-unsigned char ratetbl_val_2wifirate(unsigned char rate);
-unsigned char ratetbl_val_2wifirate(unsigned char rate)
+static unsigned char ratetbl_val_2wifirate(unsigned char rate)
 {
 	unsigned char val = 0;
 
-	switch (rate & 0x7f)
-	{
-		case 0:
-			val = IEEE80211_CCK_RATE_1MB;
-			break;
-
-		case 1:
-			val = IEEE80211_CCK_RATE_2MB;
-			break;
-
-		case 2:
-			val = IEEE80211_CCK_RATE_5MB;
-			break;
-
-		case 3:
-			val = IEEE80211_CCK_RATE_11MB;
-			break;
-
-		case 4:
-			val = IEEE80211_OFDM_RATE_6MB;
-			break;
-
-		case 5:
-			val = IEEE80211_OFDM_RATE_9MB;
-			break;
-
-		case 6:
-			val = IEEE80211_OFDM_RATE_12MB;
-			break;
-
-		case 7:
-			val = IEEE80211_OFDM_RATE_18MB;
-			break;
-
-		case 8:
-			val = IEEE80211_OFDM_RATE_24MB;
-			break;
-
-		case 9:
-			val = IEEE80211_OFDM_RATE_36MB;
-			break;
-
-		case 10:
-			val = IEEE80211_OFDM_RATE_48MB;
-			break;
-
-		case 11:
-			val = IEEE80211_OFDM_RATE_54MB;
-			break;
-
+	switch (rate & 0x7f) {
+	case 0:
+		val = IEEE80211_CCK_RATE_1MB;
+		break;
+	case 1:
+		val = IEEE80211_CCK_RATE_2MB;
+		break;
+	case 2:
+		val = IEEE80211_CCK_RATE_5MB;
+		break;
+	case 3:
+		val = IEEE80211_CCK_RATE_11MB;
+		break;
+	case 4:
+		val = IEEE80211_OFDM_RATE_6MB;
+		break;
+	case 5:
+		val = IEEE80211_OFDM_RATE_9MB;
+		break;
+	case 6:
+		val = IEEE80211_OFDM_RATE_12MB;
+		break;
+	case 7:
+		val = IEEE80211_OFDM_RATE_18MB;
+		break;
+	case 8:
+		val = IEEE80211_OFDM_RATE_24MB;
+		break;
+	case 9:
+		val = IEEE80211_OFDM_RATE_36MB;
+		break;
+	case 10:
+		val = IEEE80211_OFDM_RATE_48MB;
+		break;
+	case 11:
+		val = IEEE80211_OFDM_RATE_54MB;
+		break;
 	}
-
 	return val;
 }
 
@@ -244,16 +211,12 @@ int is_basicrate(struct rtw_adapter *pad
 	unsigned char val;
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
-	for (i = 0; i < NUMRATES; i++)
-	{
+	for (i = 0; i < NUMRATES; i++) {
 		val = pmlmeext->basicrate[i];
 
-		if ((val != 0xff) && (val != 0xfe))
-		{
+		if ((val != 0xff) && (val != 0xfe)) {
 			if (rate == ratetbl_val_2wifirate(val))
-			{
 				return true;
-			}
 		}
 	}
 
@@ -268,29 +231,21 @@ unsigned int ratetbl2rateset(struct rtw_
 	unsigned int	len = 0;
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
-	for (i = 0; i < NUMRATES; i++)
-	{
+	for (i = 0; i < NUMRATES; i++) {
 		rate = pmlmeext->datarate[i];
 
-		switch (rate)
-		{
-			case 0xff:
-				return len;
-
-			case 0xfe:
-				continue;
-
-			default:
-				rate = ratetbl_val_2wifirate(rate);
-
-				if (is_basicrate(padapter, rate) == true)
-				{
-					rate |= IEEE80211_BASIC_RATE_MASK;
-				}
-
-				rateset[len] = rate;
-				len++;
-				break;
+		switch (rate) {
+		case 0xff:
+			return len;
+		case 0xfe:
+			continue;
+		default:
+			rate = ratetbl_val_2wifirate(rate);
+			if (is_basicrate(padapter, rate) == true)
+				rate |= IEEE80211_BASIC_RATE_MASK;
+			rateset[len] = rate;
+			len++;
+			break;
 		}
 	}
 	return len;
@@ -307,7 +262,7 @@ void get_rate_set(struct rtw_adapter *pa
 }
 
 void UpdateBrateTbl(
-	struct rtw_adapter *		Adapter,
+	struct rtw_adapter *Adapter,
 	u8			*mBratesOS
 )
 {
@@ -315,20 +270,18 @@ void UpdateBrateTbl(
 	u8	rate;
 
 	/*  1M, 2M, 5.5M, 11M, 6M, 12M, 24M are mandatory. */
-	for (i=0;i<NDIS_802_11_LENGTH_RATES_EX;i++)
-	{
+	for (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {
 		rate = mBratesOS[i] & 0x7f;
-		switch (rate)
-		{
-			case IEEE80211_CCK_RATE_1MB:
-			case IEEE80211_CCK_RATE_2MB:
-			case IEEE80211_CCK_RATE_5MB:
-			case IEEE80211_CCK_RATE_11MB:
-			case IEEE80211_OFDM_RATE_6MB:
-			case IEEE80211_OFDM_RATE_12MB:
-			case IEEE80211_OFDM_RATE_24MB:
-				mBratesOS[i] |= IEEE80211_BASIC_RATE_MASK;
-				break;
+		switch (rate) {
+		case IEEE80211_CCK_RATE_1MB:
+		case IEEE80211_CCK_RATE_2MB:
+		case IEEE80211_CCK_RATE_5MB:
+		case IEEE80211_CCK_RATE_11MB:
+		case IEEE80211_OFDM_RATE_6MB:
+		case IEEE80211_OFDM_RATE_12MB:
+		case IEEE80211_OFDM_RATE_24MB:
+			mBratesOS[i] |= IEEE80211_BASIC_RATE_MASK;
+			break;
 		}
 	}
 }
@@ -338,17 +291,15 @@ void UpdateBrateTblForSoftAP(u8 *bssrate
 	u8	i;
 	u8	rate;
 
-	for (i=0;i<bssratelen;i++)
-	{
+	for (i = 0; i < bssratelen; i++) {
 		rate = bssrateset[i] & 0x7f;
-		switch (rate)
-		{
-			case IEEE80211_CCK_RATE_1MB:
-			case IEEE80211_CCK_RATE_2MB:
-			case IEEE80211_CCK_RATE_5MB:
-			case IEEE80211_CCK_RATE_11MB:
-				bssrateset[i] |= IEEE80211_BASIC_RATE_MASK;
-				break;
+		switch (rate) {
+		case IEEE80211_CCK_RATE_1MB:
+		case IEEE80211_CCK_RATE_2MB:
+		case IEEE80211_CCK_RATE_5MB:
+		case IEEE80211_CCK_RATE_11MB:
+			bssrateset[i] |= IEEE80211_BASIC_RATE_MASK;
+			break;
 		}
 	}
 }
@@ -383,16 +334,13 @@ void Switch_DM_Func(struct rtw_adapter *
 	struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 #endif
 
-	if (enable == true)
-	{
+	if (enable == true) {
 #ifdef CONFIG_CONCURRENT_MODE
 		if (pbuddy_adapter)
 		rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_DM_FUNC_SET, (u8 *)(&mode));
 #endif
 		rtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_SET, (u8 *)(&mode));
-	}
-	else
-	{
+	} else {
 #ifdef CONFIG_CONCURRENT_MODE
 		if (pbuddy_adapter)
 		rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_DM_FUNC_CLR, (u8 *)(&mode));
@@ -415,14 +363,10 @@ void Set_MSR(struct rtw_adapter *padapte
 {
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type == IFACE_PORT1)
-	{
 		Set_NETYPE1_MSR(padapter, type);
-	}
 	else
 #endif
-	{
 		Set_NETYPE0_MSR(padapter, type);
-	}
 }
 
 inline u8 rtw_get_oper_ch(struct rtw_adapter *adapter)
@@ -507,25 +451,18 @@ void set_channel_bwmode(struct rtw_adapt
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
 	if (padapter->bNotifyChannelChange)
-	{
 		DBG_8192D("[%s] ch = %d, offset = %d, bwmode = %d\n", __func__, channel, channel_offset, bwmode);
-	}
 
-	if ((bwmode == HT_CHANNEL_WIDTH_20)||(channel_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE))
-	{
+	if ((bwmode == HT_CHANNEL_WIDTH_20) ||
+	    (channel_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)) {
 		/* SelectChannel(padapter, channel); */
 		center_ch = channel;
-	}
-	else
-	{
+	} else {
 		/* switch to the proper channel */
-		if (channel_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
-		{
+		if (channel_offset == HAL_PRIME_CHNL_OFFSET_LOWER) {
 			/* SelectChannel(padapter, channel + 2); */
 			center_ch = channel + 2;
-		}
-		else
-		{
+		} else {
 			/* SelectChannel(padapter, channel - 2); */
 			center_ch = channel - 2;
 		}
@@ -563,22 +500,16 @@ void set_channel_bwmode(struct rtw_adapt
 int get_bsstype(unsigned short capability)
 {
 	if (capability & BIT(0))
-	{
 		return WIFI_FW_AP_STATE;
-	}
 	else if (capability & BIT(1))
-	{
 		return WIFI_FW_ADHOC_STATE;
-	}
 	else
-	{
 		return 0;
-	}
 }
 
-__inline u8 *get_my_bssid(struct wlan_bssid_ex *pnetwork)
+inline u8 *get_my_bssid(struct wlan_bssid_ex *pnetwork)
 {
-	return (pnetwork->MacAddress);
+	return pnetwork->MacAddress;
 }
 
 u16 get_beacon_interval(struct wlan_bssid_ex *bss)
@@ -601,13 +532,9 @@ int is_client_associated_to_ap(struct rt
 	pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE))
-	{
 		return true;
-	}
 	else
-	{
 		return _FAIL;
-	}
 }
 
 int is_client_associated_to_ibss(struct rtw_adapter *padapter)
@@ -616,13 +543,9 @@ int is_client_associated_to_ibss(struct
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))
-	{
 		return true;
-	}
 	else
-	{
 		return _FAIL;
-	}
 }
 
 int is_IBSS_empty(struct rtw_adapter *padapter)
@@ -631,44 +554,31 @@ int is_IBSS_empty(struct rtw_adapter *pa
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	for (i = IBSS_START_MAC_ID; i < NUM_STA; i++)
-	{
+	for (i = IBSS_START_MAC_ID; i < NUM_STA; i++) {
 		if (pmlmeinfo->FW_sta_info[i].status == 1)
-		{
 			return _FAIL;
-		}
 	}
-
 	return true;
 }
 
 unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval)
 {
 	if ((bcn_interval << 2) < WAIT_FOR_BCN_TO_MIN)
-	{
 		return WAIT_FOR_BCN_TO_MIN;
-	}
 	else if ((bcn_interval << 2) > WAIT_FOR_BCN_TO_MAX)
-	{
 		return WAIT_FOR_BCN_TO_MAX;
-	}
 	else
-	{
-		return ((bcn_interval << 2));
-	}
+		return bcn_interval << 2;
 }
 
-void CAM_empty_entry(
-	struct rtw_adapter *	Adapter,
-	u8			ucIndex
-)
+void CAM_empty_entry(struct rtw_adapter *Adapter, u8 ucIndex)
 {
 	rtw_hal_set_hwreg(Adapter, HW_VAR_CAM_EMPTY_ENTRY, (u8 *)(&ucIndex));
 }
 
 void invalidate_cam_all(struct rtw_adapter *padapter)
 {
-	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);
+	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, NULL);
 }
 
 void write_cam(struct rtw_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key)
@@ -680,44 +590,31 @@ void write_cam(struct rtw_adapter *padap
 
 	addr = entry << 3;
 
-	for (j = 5; j >= 0; j--)
-	{
-		switch (j)
-		{
-			case 0:
-				val = (ctrl | (mac[0] << 16) | (mac[1] << 24));
-				break;
-
-			case 1:
-				val = (mac[2] | (mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));
-				break;
-
-			default:
-				i = (j - 2) << 2;
-				val = (key[i] | (key[i+1] << 8) | (key[i+2] << 16) | (key[i+3] << 24));
-				break;
-
+	for (j = 5; j >= 0; j--) {
+		switch (j) {
+		case 0:
+			val = (ctrl | (mac[0] << 16) | (mac[1] << 24));
+			break;
+		case 1:
+			val = (mac[2] | (mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));
+			break;
+		default:
+			i = (j - 2) << 2;
+			val = (key[i] | (key[i+1] << 8) | (key[i+2] << 16) | (key[i+3] << 24));
+			break;
 		}
 
 		cam_val[0] = val;
 		cam_val[1] = addr + (unsigned int)j;
 
 		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_WRITE, (u8 *)cam_val);
-
-		/* rtw_write32(padapter, WCAMI, val); */
-
-		/* cmd = CAM_POLLINIG | CAM_WRITE | (addr + j); */
-		/* rtw_write32(padapter, RWCAM, cmd); */
-
-		/* DBG_8192D("%s=> cam write: %x, %x\n",__func__, cmd, val); */
-
 	}
 }
 
 void clear_cam_entry(struct rtw_adapter *padapter, u8 entry)
 {
 	unsigned char null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-	unsigned char null_key[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00};
+	unsigned char null_key[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
 
 	write_cam(padapter, entry, 0, null_sta, null_key);
 }
@@ -728,10 +625,8 @@ int allocate_fw_sta_entry(struct rtw_ada
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	for (mac_id = IBSS_START_MAC_ID; mac_id < NUM_STA; mac_id++)
-	{
-		if (pmlmeinfo->FW_sta_info[mac_id].status == 0)
-		{
+	for (mac_id = IBSS_START_MAC_ID; mac_id < NUM_STA; mac_id++) {
+		if (pmlmeinfo->FW_sta_info[mac_id].status == 0) {
 			pmlmeinfo->FW_sta_info[mac_id].status = 1;
 			pmlmeinfo->FW_sta_info[mac_id].retry = 0;
 			break;
@@ -751,34 +646,28 @@ void flush_all_cam_entry(struct rtw_adap
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
 	/* if (check_buddy_mlmeinfo_state(padapter, _HW_STATE_NOLINK_)) */
-	if (check_buddy_fwstate(padapter, _FW_LINKED) == false)
-	{
-		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);
-	}
-	else
-	{
-		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
-		{
+	if (check_buddy_fwstate(padapter, _FW_LINKED) == false) {
+		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, NULL);
+	} else {
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
 			struct sta_priv	*pstapriv = &padapter->stapriv;
 			struct sta_info	*psta;
 			u8 cam_id;/* cam_entry */
 
 			psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
 			if (psta) {
-				if (psta->state & WIFI_AP_STATE)
-				{}   /* clear cam when ap free per sta_info */
-				else {
-					if (psta->mac_id==2)
+				if (psta->state & WIFI_AP_STATE) {
+					/* clear cam when ap free per sta_info */
+				} else {
+					if (psta->mac_id == 2)
 						cam_id = 5;
 					else
 						cam_id = 4;
 				}
 				/* clear_cam_entry(padapter, cam_id); */
-				rtw_clearstakey_cmd(padapter, (u8*)psta, cam_id, false);
+				rtw_clearstakey_cmd(padapter, (u8 *)psta, cam_id, false);
 			}
-		}
-		else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
-		{
+		} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
 			/* clear cam when ap free per sta_info */
 		}
 	}
@@ -792,7 +681,7 @@ void flush_all_cam_entry(struct rtw_adap
 }
 
 #if defined(CONFIG_P2P) && defined(CONFIG_WFD)
-int WFD_info_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *	pIE)
+int WFD_info_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
 {
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
@@ -802,28 +691,22 @@ int WFD_info_handler(struct rtw_adapter
 	u8	wfd_ie[128] = { 0x00 };
 	u32	wfd_ielen = 0;
 
-
 	pwdinfo = &padapter->wdinfo;
-	if (rtw_get_wfd_ie((u8*) pIE, pIE->Length, wfd_ie, &wfd_ielen))
-	{
+	if (rtw_get_wfd_ie((u8 *)pIE, pIE->Length, wfd_ie, &wfd_ielen)) {
 		u8	attr_content[10] = { 0x00 };
 		u32	attr_contentlen = 0;
 
-		printk("[%s] Found WFD IE\n", __func__);
+		pr_info("[%s] Found WFD IE\n", __func__);
 		rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
-		if (attr_contentlen)
-		{
+		if (attr_contentlen) {
 			pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16(attr_content + 2);
 			DBG_8192D("[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
-			return(true);
+			return true;
 		}
+	} else {
+		pr_info("[%s] NO WFD IE\n", __func__);
 	}
-	else
-	{
-		printk("[%s] NO WFD IE\n", __func__);
-
-	}
-	return(_FAIL);
+	return _FAIL;
 }
 #endif
 
@@ -834,8 +717,7 @@ int WMM_param_handler(struct rtw_adapter
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	if (pmlmepriv->qospriv.qos_option==0)
-	{
+	if (pmlmepriv->qospriv.qos_option == 0) {
 		pmlmeinfo->WMM_enable = 0;
 		return _FAIL;
 	}
@@ -854,8 +736,7 @@ void WMMOnAssocRsp(struct rtw_adapter *p
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	if (pmlmeinfo->WMM_enable == 0)
-	{
+	if (pmlmeinfo->WMM_enable == 0) {
 		padapter->mlmepriv.acm_mask = 0;
 		return;
 	}
@@ -867,8 +748,7 @@ void WMMOnAssocRsp(struct rtw_adapter *p
 	else
 		aSifsTime = 16;
 
-	for (i = 0; i < 4; i++)
-	{
+	for (i = 0; i < 4; i++) {
 		ACI = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5) & 0x03;
 		ACM = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4) & 0x01;
 
@@ -881,27 +761,22 @@ void WMMOnAssocRsp(struct rtw_adapter *p
 
 		acParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);
 
-		switch (ACI)
-		{
-			case 0x0:
-				rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BE, (u8 *)(&acParm));
-				acm_mask |= (ACM? BIT(1):0);
-				break;
-
-			case 0x1:
-				rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BK, (u8 *)(&acParm));
-				/* acm_mask |= (ACM? BIT(0):0); */
-				break;
-
-			case 0x2:
-				rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VI, (u8 *)(&acParm));
-				acm_mask |= (ACM? BIT(2):0);
-				break;
-
-			case 0x3:
-				rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VO, (u8 *)(&acParm));
-				acm_mask |= (ACM? BIT(3):0);
-				break;
+		switch (ACI) {
+		case 0x0:
+			rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BE, (u8 *)(&acParm));
+			acm_mask |= (ACM ? BIT(1) : 0);
+			break;
+		case 0x1:
+			rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BK, (u8 *)(&acParm));
+			break;
+		case 0x2:
+			rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VI, (u8 *)(&acParm));
+			acm_mask |= (ACM ? BIT(2) : 0);
+			break;
+		case 0x3:
+			rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VO, (u8 *)(&acParm));
+			acm_mask |= (ACM ? BIT(3) : 0);
+			break;
 		}
 
 		DBG_8192D("WMM(%x): %x, %x\n", ACI, ACM, acParm);
@@ -915,7 +790,7 @@ void WMMOnAssocRsp(struct rtw_adapter *p
 	return;
 }
 
-static void bwmode_update_check(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies * pIE)
+static void bwmode_update_check(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
 {
 	unsigned char	 new_bwmode;
 	unsigned char  new_ch_offset;
@@ -925,12 +800,13 @@ static void bwmode_update_check(struct r
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct registry_priv *pregistrypriv = &padapter->registrypriv;
 	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
-	u8 cbw40_enable=0;
+	u8 cbw40_enable = 0;
 
 	if (!pIE)
 		return;
 
-	if (phtpriv->ht_option == false)	return;
+	if (phtpriv->ht_option == false)
+		return;
 
 	if (pIE->Length > sizeof(struct HT_info_element))
 		return;
@@ -945,34 +821,28 @@ static void bwmode_update_check(struct r
 			cbw40_enable = 1;
 	}
 
-	if ((pHT_info->infos[0] & BIT(2)) && cbw40_enable)
-	{
+	if ((pHT_info->infos[0] & BIT(2)) && cbw40_enable) {
 		new_bwmode = HT_CHANNEL_WIDTH_40;
 
-		switch (pHT_info->infos[0] & 0x3)
-		{
-			case 1:
-				new_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
-				break;
-
-			case 3:
-				new_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
-				break;
-
-			default:
-				new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
-				break;
+		switch (pHT_info->infos[0] & 0x3) {
+		case 1:
+			new_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+			break;
+		case 3:
+			new_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+			break;
+		default:
+			new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+			break;
 		}
-	}
-	else
-	{
+	} else {
 		new_bwmode = HT_CHANNEL_WIDTH_20;
 		new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 	}
 
 
-	if ((new_bwmode!= pmlmeext->cur_bwmode) || (new_ch_offset!=pmlmeext->cur_ch_offset))
-	{
+	if ((new_bwmode != pmlmeext->cur_bwmode) ||
+	    (new_ch_offset != pmlmeext->cur_ch_offset)) {
 		pmlmeinfo->bwmode_updated = true;
 
 		pmlmeext->cur_bwmode = new_bwmode;
@@ -980,43 +850,34 @@ static void bwmode_update_check(struct r
 
 		/* update HT info also */
 		HT_info_handler(padapter, pIE);
-	}
-	else
-	{
+	} else {
 		pmlmeinfo->bwmode_updated = false;
 	}
 
 
-	if (true == pmlmeinfo->bwmode_updated)
-	{
+	if (true == pmlmeinfo->bwmode_updated) {
 		struct sta_info *psta;
 		struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
 		struct sta_priv	*pstapriv = &padapter->stapriv;
 
 		/* update ap's stainfo */
 		psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
-		if (psta)
-		{
+		if (psta) {
 			struct ht_priv	*phtpriv_sta = &psta->htpriv;
 
-			if (phtpriv_sta->ht_option)
-			{
+			if (phtpriv_sta->ht_option) {
 				/*  bwmode */
 				phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
 				phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
-			}
-			else
-			{
+			} else {
 				phtpriv_sta->bwmode = HT_CHANNEL_WIDTH_20;
 				phtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 			}
-
 		}
-
 	}
 }
 
-void HT_caps_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies * pIE)
+void HT_caps_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
 {
 	unsigned int	i;
 	u8	rf_type;
@@ -1027,95 +888,81 @@ void HT_caps_handler(struct rtw_adapter
 	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
 	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
 
-	if (pIE==NULL) return;
+	if (pIE == NULL)
+		return;
 
-	if (phtpriv->ht_option == false)	return;
+	if (phtpriv->ht_option == false)
+		return;
 
 	pmlmeinfo->HT_caps_enable = 1;
 
-	for (i = 0; i < (pIE->Length); i++)
-	{
-		if (i != 2)
-		{
-			/* 	Commented by Albert 2010/07/12 */
-			/* 	Got the endian issue here. */
+	for (i = 0; i < (pIE->Length); i++) {
+		if (i != 2) {
+			/*	Commented by Albert 2010/07/12 */
+			/*	Got the endian issue here. */
 			pmlmeinfo->HT_caps.u.HT_cap[i] &= (pIE->data[i]);
-		}
-		else
-		{
+		} else {
 			/* modify from  fw by Thomas 2010/11/17 */
 			if ((pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3) > (pIE->data[i] & 0x3))
-			{
 				max_AMPDU_len = (pIE->data[i] & 0x3);
-			}
 			else
-			{
 				max_AMPDU_len = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3);
-			}
 
 			if ((pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) > (pIE->data[i] & 0x1c))
-			{
 				min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c);
-			}
 			else
-			{
 				min_MPDU_spacing = (pIE->data[i] & 0x1c);
-			}
 
 			pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para = max_AMPDU_len | min_MPDU_spacing;
 		}
 	}
 
-	/* 	Commented by Albert 2010/07/12 */
-	/* 	Have to handle the endian issue after copying. */
-	/* 	HT_ext_caps didn't be used yet. */
+	/*	Commented by Albert 2010/07/12 */
+	/*	Have to handle the endian issue after copying. */
+	/*	HT_ext_caps didn't be used yet. */
 	pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info);
 	pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps = le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps);
 
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
 	/* update the MCS rates */
-	for (i = 0; i < 16; i++)
-	{
-		if ((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
-		{
+	for (i = 0; i < 16; i++) {
+		if ((rf_type == RF_1T1R) || (rf_type == RF_1T2R)) {
 			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
-		}
-		else
-		{
+		} else {
 			#ifdef CONFIG_DISABLE_MCS13TO15
-			if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40 && (pregistrypriv->wifi_spec!=1))
+			if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40 && (pregistrypriv->wifi_spec != 1))
 				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R_MCS13TO15_OFF[i];
 			else
-			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
+				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
 			#else
 			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
 			#endif /* CONFIG_DISABLE_MCS13TO15 */
 		}
-	        #ifdef RTL8192C_RECONFIG_TO_1T1R
+#ifdef RTL8192C_RECONFIG_TO_1T1R
 		{
 			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
 		}
-		#endif
+#endif
 
 		if (pregistrypriv->special_rf_path)
 			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
-
 	}
-
 	return;
 }
 
-void HT_info_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies * pIE)
+void HT_info_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
 {
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
 
-	if (pIE==NULL) return;
+	if (pIE == NULL)
+		return;
 
-	if (phtpriv->ht_option == false)	return;
+	if (phtpriv->ht_option == false)
+		return;
 
 
 	if (pIE->Length > sizeof(struct HT_info_element))
@@ -1131,20 +978,15 @@ void HTOnAssocRsp(struct rtw_adapter *pa
 {
 	unsigned char		max_AMPDU_len;
 	unsigned char		min_MPDU_spacing;
-	/* struct registry_priv	 *pregpriv = &padapter->registrypriv; */
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	DBG_8192D("%s\n", __func__);
 
-	if ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable))
-	{
+	if ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable)) {
 		pmlmeinfo->HT_enable = 1;
-	}
-	else
-	{
+	} else {
 		pmlmeinfo->HT_enable = 0;
-		/* set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode); */
 		return;
 	}
 
@@ -1162,12 +1004,12 @@ void HTOnAssocRsp(struct rtw_adapter *pa
 	rtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_FACTOR, (u8 *)(&max_AMPDU_len));
 }
 
-void ERP_IE_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies * pIE)
+void ERP_IE_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
 {
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	if (pIE->Length>1)
+	if (pIE->Length > 1)
 		return;
 
 	pmlmeinfo->ERP_enable = 1;
@@ -1180,47 +1022,35 @@ void VCS_update(struct rtw_adapter *pada
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	switch (pregpriv->vrtl_carrier_sense)/* 0:off 1:on 2:auto */
-	{
-		case 0: /* off */
-			psta->rtsen = 0;
+	switch (pregpriv->vrtl_carrier_sense) { /* 0:off 1:on 2:auto */
+	case 0: /* off */
+		psta->rtsen = 0;
+		psta->cts2self = 0;
+		break;
+	case 1: /* on */
+		if (pregpriv->vcs_type == 1) { /* 1:RTS/CTS 2:CTS to self */
+			psta->rtsen = 1;
 			psta->cts2self = 0;
-			break;
-
-		case 1: /* on */
-			if (pregpriv->vcs_type == 1) /* 1:RTS/CTS 2:CTS to self */
-			{
+		} else {
+			psta->rtsen = 0;
+			psta->cts2self = 1;
+		}
+		break;
+	case 2: /* auto */
+	default:
+		if ((pmlmeinfo->ERP_enable) && (pmlmeinfo->ERP_IE & BIT(1))) {
+			if (pregpriv->vcs_type == 1) {
 				psta->rtsen = 1;
 				psta->cts2self = 0;
-			}
-			else
-			{
+			} else {
 				psta->rtsen = 0;
 				psta->cts2self = 1;
 			}
-			break;
-
-		case 2: /* auto */
-		default:
-			if ((pmlmeinfo->ERP_enable) && (pmlmeinfo->ERP_IE & BIT(1)))
-			{
-				if (pregpriv->vcs_type == 1)
-				{
-					psta->rtsen = 1;
-					psta->cts2self = 0;
-				}
-				else
-				{
-					psta->rtsen = 0;
-					psta->cts2self = 1;
-				}
-			}
-			else
-			{
-				psta->rtsen = 0;
-				psta->cts2self = 0;
-			}
-			break;
+		} else {
+			psta->rtsen = 0;
+			psta->cts2self = 0;
+		}
+		break;
 	}
 }
 
@@ -1230,9 +1060,7 @@ int check_ap_tdls_prohibited(u8 *pframe,
 	u8 tdls_prohibited_bit = 0x40; /* bit(38); TDLS_prohibited */
 
 	if (pkt_len < 5)
-	{
 		return false;
-	}
 
 	pframe += 4;
 	if ((*pframe) & tdls_prohibited_bit)
@@ -1246,7 +1074,7 @@ void update_beacon_info(struct rtw_adapt
 {
 	unsigned int i;
 	unsigned int len;
-	struct ndis_802_11_variable_ies *	pIE;
+	struct ndis_802_11_variable_ies *pIE;
 
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
@@ -1285,26 +1113,22 @@ void process_csa_ie(struct rtw_adapter *
 {
 	unsigned int i;
 	unsigned int len;
-	struct ndis_802_11_variable_ies *	pIE;
+	struct ndis_802_11_variable_ies *pIE;
 	u8 new_ch_no = 0;
 
 	len = pkt_len - (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN);
 
-	for (i = 0; i < len;)
-	{
+	for (i = 0; i < len;) {
 		pIE = (struct ndis_802_11_variable_ies *)(pframe + (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN) + i);
 
-		switch (pIE->ElementID)
-		{
-			case _CH_SWTICH_ANNOUNCE_:
-				memcpy(&new_ch_no, pIE->data+1, 1);
-				rtw_set_csa_cmd(padapter, new_ch_no);
-				break;
-
-			default:
-				break;
+		switch (pIE->ElementID) {
+		case _CH_SWTICH_ANNOUNCE_:
+			memcpy(&new_ch_no, pIE->data+1, 1);
+			rtw_set_csa_cmd(padapter, new_ch_no);
+			break;
+		default:
+			break;
 		}
-
 		i += (pIE->Length + 2);
 	}
 }
@@ -1313,43 +1137,32 @@ void process_csa_ie(struct rtw_adapter *
 unsigned int is_ap_in_tkip(struct rtw_adapter *padapter)
 {
 	u32 i;
-	struct ndis_802_11_variable_ies *	pIE;
+	struct ndis_802_11_variable_ies *pIE;
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wlan_bssid_ex		*cur_network = &(pmlmeinfo->network);
 
-	if (rtw_get_capability((struct wlan_bssid_ex *)cur_network) & WLAN_CAPABILITY_PRIVACY)
-	{
-		for (i = sizeof(struct ndis_802_11_fixed_ies); i < pmlmeinfo->network.IELength;)
-		{
+	if (rtw_get_capability((struct wlan_bssid_ex *)cur_network) & WLAN_CAPABILITY_PRIVACY) {
+		for (i = sizeof(struct ndis_802_11_fixed_ies); i < pmlmeinfo->network.IELength;) {
 			pIE = (struct ndis_802_11_variable_ies *)(pmlmeinfo->network.IEs + i);
 
-			switch (pIE->ElementID)
-			{
-				case _VENDOR_SPECIFIC_IE_:
-					if ((_rtw_memcmp(pIE->data, RTW_WPA_OUI, 4)) && (_rtw_memcmp((pIE->data + 12), WPA_TKIP_CIPHER, 4)))
-					{
-						return true;
-					}
-					break;
-
-				case _RSN_IE_2_:
-					if (_rtw_memcmp((pIE->data + 8), RSN_TKIP_CIPHER, 4))
-					{
-						return true;
-					}
-
-				default:
-					break;
+			switch (pIE->ElementID) {
+			case _VENDOR_SPECIFIC_IE_:
+				if ((_rtw_memcmp(pIE->data, RTW_WPA_OUI, 4)) && (_rtw_memcmp((pIE->data + 12), WPA_TKIP_CIPHER, 4)))
+					return true;
+				break;
+			case _RSN_IE_2_:
+				if (_rtw_memcmp((pIE->data + 8), RSN_TKIP_CIPHER, 4))
+					return true;
+			default:
+				break;
 			}
 
 			i += (pIE->Length + 2);
 		}
 
 		return false;
-	}
-	else
-	{
+	} else {
 		return false;
 	}
 }
@@ -1360,55 +1173,43 @@ int wifirate2_ratetbl_inx(unsigned char
 	int	inx = 0;
 	rate = rate & 0x7f;
 
-	switch (rate)
-	{
-		case 54*2:
-			inx = 11;
-			break;
-
-		case 48*2:
-			inx = 10;
-			break;
-
-		case 36*2:
-			inx = 9;
-			break;
-
-		case 24*2:
-			inx = 8;
-			break;
-
-		case 18*2:
-			inx = 7;
-			break;
-
-		case 12*2:
-			inx = 6;
-			break;
-
-		case 9*2:
-			inx = 5;
-			break;
-
-		case 6*2:
-			inx = 4;
-			break;
-
-		case 11*2:
-			inx = 3;
-			break;
-		case 11:
-			inx = 2;
-			break;
-
-		case 2*2:
-			inx = 1;
-			break;
-
-		case 1*2:
-			inx = 0;
-			break;
-
+	switch (rate) {
+	case 54*2:
+		inx = 11;
+		break;
+	case 48*2:
+		inx = 10;
+		break;
+	case 36*2:
+		inx = 9;
+		break;
+	case 24*2:
+		inx = 8;
+		break;
+	case 18*2:
+		inx = 7;
+		break;
+	case 12*2:
+		inx = 6;
+		break;
+	case 9*2:
+		inx = 5;
+		break;
+	case 6*2:
+		inx = 4;
+		break;
+	case 11*2:
+		inx = 3;
+		break;
+	case 11:
+		inx = 2;
+		break;
+	case 2*2:
+		inx = 1;
+		break;
+	case 1*2:
+		inx = 0;
+		break;
 	}
 	return inx;
 }
@@ -1418,14 +1219,11 @@ unsigned int update_basic_rate(unsigned
 	unsigned int i, num_of_rate;
 	unsigned int mask = 0;
 
-	num_of_rate = (ptn_sz > NUMRATES)? NUMRATES: ptn_sz;
+	num_of_rate = (ptn_sz > NUMRATES) ? NUMRATES : ptn_sz;
 
-	for (i = 0; i < num_of_rate; i++)
-	{
+	for (i = 0; i < num_of_rate; i++) {
 		if ((*(ptn + i)) & 0x80)
-		{
 			mask |= 0x1 << wifirate2_ratetbl_inx(*(ptn + i));
-		}
 	}
 	return mask;
 }
@@ -1435,7 +1233,7 @@ unsigned int update_supported_rate(unsig
 	unsigned int i, num_of_rate;
 	unsigned int mask = 0;
 
-	num_of_rate = (ptn_sz > NUMRATES)? NUMRATES: ptn_sz;
+	num_of_rate = (ptn_sz > NUMRATES) ? NUMRATES : ptn_sz;
 
 	for (i = 0; i < num_of_rate; i++)
 		mask |= 0x1 << wifirate2_ratetbl_inx(*(ptn + i));
@@ -1464,27 +1262,21 @@ int support_short_GI(struct rtw_adapter
 	if ((pmlmeinfo->assoc_AP_vendor == ralinkAP))
 		return _FAIL;
 
-	bit_offset = (pmlmeext->cur_bwmode & HT_CHANNEL_WIDTH_40)? 6: 5;
+	bit_offset = (pmlmeext->cur_bwmode & HT_CHANNEL_WIDTH_40) ? 6 : 5;
 
 	if (pHT_caps->u.HT_cap_element.HT_caps_info & (0x1 << bit_offset))
-	{
 		return _SUCCESS;
-	}
 	else
-	{
 		return _FAIL;
-	}
 }
 
 unsigned char get_highest_rate_idx(u32 mask)
 {
 	int i;
-	unsigned char rate_idx=0;
+	unsigned char rate_idx = 0;
 
-	for (i=27; i>=0; i--)
-	{
-		if (mask & BIT(i))
-		{
+	for (i = 27; i >= 0; i--) {
+		if (mask & BIT(i)) {
 			rate_idx = i;
 			break;
 		}
@@ -1493,21 +1285,16 @@ unsigned char get_highest_rate_idx(u32 m
 	return rate_idx;
 }
 
-unsigned char get_highest_mcs_rate(struct HT_caps_element *pHT_caps);
-unsigned char get_highest_mcs_rate(struct HT_caps_element *pHT_caps)
+static unsigned char get_highest_mcs_rate(struct HT_caps_element *pHT_caps)
 {
 	int i, mcs_rate;
 
 	mcs_rate = (pHT_caps->u.HT_cap_element.MCS_rate[0] | (pHT_caps->u.HT_cap_element.MCS_rate[1] << 8));
 
-	for (i = 15; i >= 0; i--)
-	{
+	for (i = 15; i >= 0; i--) {
 		if (mcs_rate & (0x1 << i))
-		{
 			break;
-		}
 	}
-
 	return i;
 }
 
@@ -1534,11 +1321,11 @@ void update_tx_basic_rate(struct rtw_ada
 	unsigned char supported_rates[NDIS_802_11_LENGTH_RATES_EX];
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 #ifdef CONFIG_P2P
-	struct wifidirect_info*	pwdinfo = &padapter->wdinfo;
+	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 
-	/* 	Added by Albert 2011/03/22 */
-	/* 	In the P2P mode, the driver should not support the b mode. */
-	/* 	So, the Tx packet shouldn't use the CCK rate */
+	/*	Added by Albert 2011/03/22 */
+	/*	In the P2P mode, the driver should not support the b mode. */
+	/*	So, the Tx packet shouldn't use the CCK rate */
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 #endif /* CONFIG_P2P */
@@ -1553,13 +1340,12 @@ void update_tx_basic_rate(struct rtw_ada
 	if (pmlmeext->cur_channel > 14)
 		wirelessmode &= ~(WIRELESS_11B);
 
-	if ((wirelessmode & WIRELESS_11B) && (wirelessmode == WIRELESS_11B)) {
+	if ((wirelessmode & WIRELESS_11B) && (wirelessmode == WIRELESS_11B))
 		memcpy(supported_rates, rtw_basic_rate_cck, 4);
-	} else if (wirelessmode & WIRELESS_11B) {
+	else if (wirelessmode & WIRELESS_11B)
 		memcpy(supported_rates, rtw_basic_rate_mix, 7);
-	} else {
+	else
 		memcpy(supported_rates, rtw_basic_rate_ofdm, 3);
-	}
 
 	if (wirelessmode & WIRELESS_11B)
 		update_mgnt_tx_rate(padapter, IEEE80211_CCK_RATE_1MB);
@@ -1572,59 +1358,43 @@ void update_tx_basic_rate(struct rtw_ada
 unsigned char check_assoc_AP(u8 *pframe, uint len)
 {
 	unsigned int	i;
-	struct ndis_802_11_variable_ies *	pIE;
+	struct ndis_802_11_variable_ies *pIE;
 
-	for (i = sizeof(struct ndis_802_11_fixed_ies); i < len;)
-	{
+	for (i = sizeof(struct ndis_802_11_fixed_ies); i < len;) {
 		pIE = (struct ndis_802_11_variable_ies *)(pframe + i);
 
-		switch (pIE->ElementID)
-		{
-			case _VENDOR_SPECIFIC_IE_:
-				if ((_rtw_memcmp(pIE->data, ARTHEROS_OUI1, 3)) || (_rtw_memcmp(pIE->data, ARTHEROS_OUI2, 3)))
-				{
-					DBG_8192D("link to Artheros AP\n");
-					return atherosAP;
-				}
-				else if ((_rtw_memcmp(pIE->data, BROADCOM_OUI1, 3))
-							|| (_rtw_memcmp(pIE->data, BROADCOM_OUI2, 3))
-							|| (_rtw_memcmp(pIE->data, BROADCOM_OUI2, 3)))
-				{
-					DBG_8192D("link to Broadcom AP\n");
-					return broadcomAP;
-				}
-				else if (_rtw_memcmp(pIE->data, MARVELL_OUI, 3))
-				{
-					DBG_8192D("link to Marvell AP\n");
-					return marvellAP;
-				}
-				else if (_rtw_memcmp(pIE->data, RALINK_OUI, 3))
-				{
-					DBG_8192D("link to Ralink AP\n");
-					return ralinkAP;
-				}
-				else if (_rtw_memcmp(pIE->data, CISCO_OUI, 3))
-				{
-					DBG_8192D("link to Cisco AP\n");
-					return ciscoAP;
-				}
-				else if (_rtw_memcmp(pIE->data, REALTEK_OUI, 3))
-				{
-					DBG_8192D("link to Realtek 96B\n");
-					return realtekAP;
-				}
-				else if (_rtw_memcmp(pIE->data, AIRGOCAP_OUI,3))
-				{
-					DBG_8192D("link to Airgo Cap\n");
-					return airgocapAP;
-				}
-				else
-				{
-					break;
-				}
-
-			default:
+		switch (pIE->ElementID) {
+		case _VENDOR_SPECIFIC_IE_:
+			if ((_rtw_memcmp(pIE->data, ARTHEROS_OUI1, 3)) ||
+			    (_rtw_memcmp(pIE->data, ARTHEROS_OUI2, 3))) {
+				DBG_8192D("link to Artheros AP\n");
+				return atherosAP;
+			} else if ((_rtw_memcmp(pIE->data, BROADCOM_OUI1, 3)) ||
+				   (_rtw_memcmp(pIE->data, BROADCOM_OUI2, 3)) ||
+				   (_rtw_memcmp(pIE->data, BROADCOM_OUI2, 3))) {
+				DBG_8192D("link to Broadcom AP\n");
+				return broadcomAP;
+			} else if (_rtw_memcmp(pIE->data, MARVELL_OUI, 3)) {
+				DBG_8192D("link to Marvell AP\n");
+				return marvellAP;
+			} else if (_rtw_memcmp(pIE->data, RALINK_OUI, 3)) {
+				DBG_8192D("link to Ralink AP\n");
+				return ralinkAP;
+			} else if (_rtw_memcmp(pIE->data, CISCO_OUI, 3)) {
+				DBG_8192D("link to Cisco AP\n");
+				return ciscoAP;
+			} else if (_rtw_memcmp(pIE->data, REALTEK_OUI, 3)) {
+				DBG_8192D("link to Realtek 96B\n");
+				return realtekAP;
+			} else if (_rtw_memcmp(pIE->data, AIRGOCAP_OUI, 3)) {
+				DBG_8192D("link to Airgo Cap\n");
+				return airgocapAP;
+			} else {
 				break;
+			}
+
+		default:
+			break;
 		}
 
 		i += (pIE->Length + 2);
@@ -1639,91 +1409,69 @@ void update_IOT_info(struct rtw_adapter
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	switch (pmlmeinfo->assoc_AP_vendor)
-	{
-		case marvellAP:
-			pmlmeinfo->turboMode_cts2self = 1;
-			pmlmeinfo->turboMode_rtsen = 0;
-			break;
-
-		case ralinkAP:
-			pmlmeinfo->turboMode_cts2self = 0;
-			pmlmeinfo->turboMode_rtsen = 1;
-			/* disable high power */
-			Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), false);
-			break;
-		case realtekAP:
-			/* rtw_write16(padapter, 0x4cc, 0xffff); */
-			/* rtw_write16(padapter, 0x546, 0x01c0); */
-			/* disable high power */
-			Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), false);
-			break;
-		default:
-			pmlmeinfo->turboMode_cts2self = 0;
-			pmlmeinfo->turboMode_rtsen = 1;
-			break;
+	switch (pmlmeinfo->assoc_AP_vendor) {
+	case marvellAP:
+		pmlmeinfo->turboMode_cts2self = 1;
+		pmlmeinfo->turboMode_rtsen = 0;
+		break;
+	case ralinkAP:
+		pmlmeinfo->turboMode_cts2self = 0;
+		pmlmeinfo->turboMode_rtsen = 1;
+		/* disable high power */
+		Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), false);
+		break;
+	case realtekAP:
+		/* rtw_write16(padapter, 0x4cc, 0xffff); */
+		/* rtw_write16(padapter, 0x546, 0x01c0); */
+		/* disable high power */
+		Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), false);
+		break;
+	default:
+		pmlmeinfo->turboMode_cts2self = 0;
+		pmlmeinfo->turboMode_rtsen = 1;
+		break;
 	}
 }
 
-void update_capinfo(struct rtw_adapter * Adapter, u16 updateCap)
+void update_capinfo(struct rtw_adapter *Adapter, u16 updateCap)
 {
 	struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	bool		ShortPreamble;
+	bool		shortpreamble;
 
 	/*  Check preamble mode, 2005.01.06, by rcnjko. */
 	/*  Mark to update preamble value forever, 2008.03.18 by lanhsin */
 	/* if (pMgntInfo->RegPreambleMode == PREAMBLE_AUTO) */
-	{
-		if (updateCap & cShortPreamble) { /*  Short Preamble */
-			if (pmlmeinfo->preamble_mode != PREAMBLE_SHORT) /*  PREAMBLE_LONG or PREAMBLE_AUTO */
-			{
-				ShortPreamble = true;
-				pmlmeinfo->preamble_mode = PREAMBLE_SHORT;
-				rtw_hal_set_hwreg(Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&ShortPreamble);
-			}
-		}
-		else
-		{ /*  Long Preamble */
-			if (pmlmeinfo->preamble_mode != PREAMBLE_LONG)  /*  PREAMBLE_SHORT or PREAMBLE_AUTO */
-			{
-				ShortPreamble = false;
-				pmlmeinfo->preamble_mode = PREAMBLE_LONG;
-				rtw_hal_set_hwreg(Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&ShortPreamble);
-			}
+	if (updateCap & shortpreamble) { /*  Short Preamble */
+		if (pmlmeinfo->preamble_mode != PREAMBLE_SHORT) { /*  PREAMBLE_LONG or PREAMBLE_AUTO */
+			shortpreamble = true;
+			pmlmeinfo->preamble_mode = PREAMBLE_SHORT;
+			rtw_hal_set_hwreg(Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&shortpreamble);
+		}
+	} else { /*  Long Preamble */
+		if (pmlmeinfo->preamble_mode != PREAMBLE_LONG) {  /*  PREAMBLE_SHORT or PREAMBLE_AUTO */
+			shortpreamble = false;
+			pmlmeinfo->preamble_mode = PREAMBLE_LONG;
+			rtw_hal_set_hwreg(Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&shortpreamble);
 		}
 	}
 
 	if (updateCap & cIBSS) {
 		/* Filen: See 802.11-2007 p.91 */
 		pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
-	}
-	else
-	{
+	} else {
 		/* Filen: See 802.11-2007 p.90 */
-		if (pmlmeext->cur_wireless_mode & (WIRELESS_11G | WIRELESS_11_24N))
-		{
-			if ((updateCap & cShortSlotTime) /* && (!(pMgntInfo->pHTInfo->RT2RT_HT_Mode & RT_HT_CAP_USE_LONG_PREAMBLE)) */)
-			{ /*  Short Slot Time */
+		if (pmlmeext->cur_wireless_mode & (WIRELESS_11G | WIRELESS_11_24N)) {
+			if ((updateCap & cShortSlotTime)) { /*  Short Slot Time */
 				if (pmlmeinfo->slotTime != SHORT_SLOT_TIME)
-				{
 					pmlmeinfo->slotTime = SHORT_SLOT_TIME;
-				}
-			}
-			else
-			{ /*  Long Slot Time */
+			} else { /*  Long Slot Time */
 				if (pmlmeinfo->slotTime != NON_SHORT_SLOT_TIME)
-				{
 					pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
-				}
 			}
-		}
-		else if (pmlmeext->cur_wireless_mode & (WIRELESS_11A | WIRELESS_11_5N))
-		{
+		} else if (pmlmeext->cur_wireless_mode & (WIRELESS_11A | WIRELESS_11_5N)) {
 			pmlmeinfo->slotTime = SHORT_SLOT_TIME;
-		}
-		else
-		{
+		} else {
 			/* B Mode */
 			pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
 		}
@@ -1734,7 +1482,7 @@ void update_capinfo(struct rtw_adapter *
 
 void update_wireless_mode(struct rtw_adapter *padapter)
 {
-	u8	init_rate=0;
+	u8	init_rate = 0;
 	int	ratelen, network_type = 0;
 	u32	SIFS_Timer, mask;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
@@ -1748,38 +1496,23 @@ void update_wireless_mode(struct rtw_ada
 	ratelen = rtw_get_rateset_len(cur_network->SupportedRates);
 
 	if ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable))
-	{
 		pmlmeinfo->HT_enable = 1;
-	}
 
-	if (pmlmeext->cur_channel > 14)
-	{
+	if (pmlmeext->cur_channel > 14) {
 		if (pmlmeinfo->HT_enable)
-		{
 			network_type = WIRELESS_11_5N;
-		}
 
 		network_type |= WIRELESS_11A;
-	}
-	else
-	{
+	} else {
 		if (pmlmeinfo->HT_enable)
-		{
 			network_type = WIRELESS_11_24N;
-		}
 
 		if ((cckratesonly_included(rate, ratelen)) == true)
-		{
 			network_type |= WIRELESS_11B;
-		}
 		else if ((cckrates_included(rate, ratelen)) == true)
-		{
 			network_type |= WIRELESS_11BG;
-		}
 		else
-		{
 			network_type |= WIRELESS_11G;
-		}
 	}
 
 	pmlmeext->cur_wireless_mode = network_type & padapter->registrypriv.wireless_mode;
@@ -1791,14 +1524,13 @@ void update_wireless_mode(struct rtw_ada
 	rtw_hal_set_hwreg(padapter, HW_VAR_INIT_DATA_RATE,  (u8 *)&init_rate);
 
 	SIFS_Timer = 0x0a0a0808; /* 0x0808 -> for CCK, 0x0a0a -> for OFDM */
-                             /* change this value if having IOT issues. */
+				/* change this value if having IOT issues. */
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_RESP_SIFS,  (u8 *)&SIFS_Timer);
 
-	if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
+	if (pmlmeext->cur_wireless_mode & WIRELESS_11B) {
 		update_mgnt_tx_rate(padapter, IEEE80211_CCK_RATE_1MB);
-	else
-	{
+	} else {
 		update_mgnt_tx_rate(padapter, IEEE80211_OFDM_RATE_6MB);
 #ifdef CONFIG_CONCURRENT_MODE
 		if (pbuddy_adapter && (pmlmeext->cur_wireless_mode & WIRELESS_11A))
@@ -1807,8 +1539,7 @@ void update_wireless_mode(struct rtw_ada
 	}
 }
 
-void fire_write_MAC_cmd(struct rtw_adapter *padapter, unsigned int addr, unsigned int value);
-void fire_write_MAC_cmd(struct rtw_adapter *padapter, unsigned int addr, unsigned int value)
+static void fire_write_MAC_cmd(struct rtw_adapter *padapter, unsigned int addr, unsigned int value)
 {
 }
 
@@ -1817,18 +1548,15 @@ void update_bmc_sta_support_rate(struct
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
-	{
+	if (pmlmeext->cur_wireless_mode & WIRELESS_11B) {
 		/*  Only B, B/G, and B/G/N AP could use CCK rate */
 		memcpy((pmlmeinfo->FW_sta_info[mac_id].SupportedRates), rtw_basic_rate_cck, 4);
-	}
-	else
-	{
+	} else {
 		memcpy((pmlmeinfo->FW_sta_info[mac_id].SupportedRates), rtw_basic_rate_ofdm, 3);
 	}
 }
 
-int update_sta_support_rate(struct rtw_adapter *padapter, u8* pvar_ie, uint var_ie_len, int cam_idx)
+int update_sta_support_rate(struct rtw_adapter *padapter, u8 *pvar_ie, uint var_ie_len, int cam_idx)
 {
 	unsigned int	ie_len;
 	struct ndis_802_11_variable_ies *pIE;
@@ -1838,9 +1566,7 @@ int update_sta_support_rate(struct rtw_a
 
 	pIE = (struct ndis_802_11_variable_ies *)rtw_get_ie(pvar_ie, _SUPPORTEDRATES_IE_, &ie_len, var_ie_len);
 	if (pIE == NULL)
-	{
 		return _FAIL;
-	}
 
 	memcpy(pmlmeinfo->FW_sta_info[cam_idx].SupportedRates, pIE->data, ie_len);
 	supportRateNum = ie_len;
@@ -1858,14 +1584,13 @@ void process_addba_req(struct rtw_adapte
 	u16 tid, start_seq, param;
 	struct recv_reorder_ctrl *preorder_ctrl;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	struct ADDBA_request	*preq = (struct ADDBA_request*)paddba_req;
+	struct ADDBA_request	*preq = (struct ADDBA_request *)paddba_req;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	psta = rtw_get_stainfo(pstapriv, addr);
 
-	if (psta)
-	{
+	if (psta) {
 		start_seq = le16_to_cpu(preq->BA_starting_seqctrl) >> 4;
 
 		param = le16_to_cpu(preq->BA_para_set);
@@ -1877,34 +1602,31 @@ void process_addba_req(struct rtw_adapte
 		preorder_ctrl->indicate_seq = start_seq;
 		#ifdef DBG_RX_SEQ
 		DBG_8192D("DBG_RX_SEQ %s:%d IndicateSeq: %d, start_seq: %d\n", __func__, __LINE__,
-			preorder_ctrl->indicate_seq, start_seq);
+			  preorder_ctrl->indicate_seq, start_seq);
 		#endif
 		#else
 		preorder_ctrl->indicate_seq = 0xffff;
 		#endif
 
-		preorder_ctrl->enable =(pmlmeinfo->bAcceptAddbaReq == true)? true :false;
+		preorder_ctrl->enable = (pmlmeinfo->bAcceptAddbaReq == true) ? true : false;
 	}
 }
 
 void update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len)
 {
-	u8* pIE;
+	u8 *pIE;
 	u32 *pbuf;
 
 	pIE = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
-	pbuf = (u32*)pIE;
-
+	pbuf = (u32 *)pIE;
 	pmlmeext->TSFValue = le32_to_cpu(*(pbuf+1));
-
 	pmlmeext->TSFValue = pmlmeext->TSFValue << 32;
-
 	pmlmeext->TSFValue |= le32_to_cpu(*pbuf);
 }
 
 void correct_TSF(struct rtw_adapter *padapter, struct mlme_ext_priv *pmlmeext)
 {
-	rtw_hal_set_hwreg(padapter, HW_VAR_CORRECT_TSF, 0);
+	rtw_hal_set_hwreg(padapter, HW_VAR_CORRECT_TSF, NULL);
 }
 
 void beacon_timing_control(struct rtw_adapter *padapter)
@@ -1912,7 +1634,7 @@ void beacon_timing_control(struct rtw_ad
 	rtw_hal_bcn_related_reg_setting(padapter);
 }
 
-static struct rtw_adapter *pbuddy_padapter = NULL;
+static struct rtw_adapter *pbuddy_padapter;
 
 int rtw_handle_dualmac(struct rtw_adapter *adapter, bool init)
 {
@@ -1928,20 +1650,20 @@ int rtw_handle_dualmac(struct rtw_adapte
 
 		/* For SMSP on 92DU-VC, driver do not probe another Interface. */
 		if ((dvobj->DualMacMode != true) && (dvobj->InterfaceNumber != 0)) {
-			DBG_8192D("%s(): Do not init another USB Interface because SMSP\n",__func__);
+			DBG_8192D("%s(): Do not init another USB Interface because SMSP\n", __func__);
 			status = _FAIL;
 			goto exit;
 		}
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		if (pbuddy_padapter == NULL) {
 			pbuddy_padapter = adapter;
-			DBG_8192D("%s(): pbuddy_padapter == NULL, Set pbuddy_padapter\n",__func__);
+			DBG_8192D("%s(): pbuddy_padapter == NULL, Set pbuddy_padapter\n", __func__);
 		} else {
 			adapter->pbuddy_adapter = pbuddy_padapter;
 			pbuddy_padapter->pbuddy_adapter = adapter;
 			/*  clear global value */
 			pbuddy_padapter = NULL;
-			DBG_8192D("%s(): pbuddy_padapter exist, Exchange Information\n",__func__);
+			DBG_8192D("%s(): pbuddy_padapter exist, Exchange Information\n", __func__);
 		}
 
 		if (dvobj->InterfaceNumber == 0) {
@@ -1949,13 +1671,13 @@ int rtw_handle_dualmac(struct rtw_adapte
 			adapter->isprimary = true;
 			adapter->adapter_type = PRIMARY_ADAPTER;
 			adapter->iface_type = IFACE_PORT0;
-			DBG_8192D("%s(): PRIMARY_ADAPTER\n",__func__);
+			DBG_8192D("%s(): PRIMARY_ADAPTER\n", __func__);
 		} else {
 			/* set adapter_type/iface type */
 			adapter->isprimary = false;
 			adapter->adapter_type = SECONDARY_ADAPTER;
 			adapter->iface_type = IFACE_PORT1;
-			DBG_8192D("%s(): SECONDARY_ADAPTER\n",__func__);
+			DBG_8192D("%s(): SECONDARY_ADAPTER\n", __func__);
 		}
 #endif
 	} else {
--- a/drivers/staging/rtl8192du/include/wifi.h
+++ b/drivers/staging/rtl8192du/include/wifi.h
@@ -1139,5 +1139,6 @@ enum P2P_PS_MODE
 
 #define IP_MCAST_MAC(mac)	((mac[0]==0x01)&&(mac[1]==0x00)&&(mac[2]==0x5e))
 #define ICMPV6_MCAST_MAC(mac)	((mac[0]==0x33)&&(mac[1]==0x33)&&(mac[2]!=0xff))
+extern unsigned char REALTEK_96B_IE[6];
 
 #endif // _WIFI_H_

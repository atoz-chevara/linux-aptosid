From d5a7dd6a20f0b64f82f5fcdb05855309ee7a3efc Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Tue, 14 May 2013 15:21:17 -0500
Subject: [PATCH 157/390] Remove C90-style (//) comments from hal/*.c

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 hal/hal_intf.c          |    8 +-
 hal/rtl8192d_cmd.c      |  286 +++----
 hal/rtl8192d_dm.c       |  773 ++++++++-----------
 hal/rtl8192d_hal_init.c |  560 ++++++--------
 hal/rtl8192d_phycfg.c   | 1917 ++++++++++++++++++-----------------------------
 hal/rtl8192d_rf6052.c   |  238 +++---
 hal/rtl8192d_rxdesc.c   |  201 +++--
 hal/rtl8192d_xmit.c     |    2 +-
 hal/rtl8192du_led.c     |  241 +++---
 hal/rtl8192du_recv.c    |   22 +-
 hal/rtl8192du_xmit.c    |  266 +++----
 hal/usb_halinit.c       | 1708 ++++++++++++++++++-----------------------
 hal/usb_ops_linux.c     |  178 +++--
 13 files changed, 2637 insertions(+), 3763 deletions(-)

--- a/drivers/staging/rtl8192du/hal/hal_intf.c
+++ b/drivers/staging/rtl8192du/hal/hal_intf.c
@@ -63,7 +63,7 @@ void rtw_hal_dm_init(struct rtw_adapter
 
 void rtw_hal_dm_deinit(struct rtw_adapter *padapter)
 {
-	// cancel dm  timer
+	/*  cancel dm  timer */
 	if (padapter->HalFunc.dm_deinit)
 		padapter->HalFunc.dm_deinit(padapter);
 }
@@ -98,7 +98,7 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 #endif
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	// before init mac0, driver must init mac1 first to avoid usb rx error.
+	/*  before init mac0, driver must init mac1 first to avoid usb rx error. */
 	if ((padapter->pbuddy_adapter != NULL) && (padapter->DualMacConcurrent == true)
 		&& (padapter->adapter_type == PRIMARY_ADAPTER))
 	{
@@ -398,7 +398,7 @@ s32	rtw_hal_hostap_mgnt_xmit_entry(struc
 		return padapter->HalFunc.hostap_mgnt_xmit_entry(padapter, pkt);
 	return _FAIL;
 }
-#endif //CONFIG_HOSTAPD_MLME
+#endif /* CONFIG_HOSTAPD_MLME */
 
 #ifdef DBG_CONFIG_ERROR_DETECT
 void rtw_hal_sreset_init(struct rtw_adapter *padapter)
@@ -442,7 +442,7 @@ u8 rtw_hal_sreset_get_wifi_status(struct
 		status = padapter->HalFunc.sreset_get_wifi_status(padapter);
 	return status;
 }
-#endif //DBG_CONFIG_ERROR_DETECT
+#endif /* DBG_CONFIG_ERROR_DETECT */
 
 void rtw_hal_notch_filter(struct rtw_adapter *adapter, bool enable)
 {
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -57,9 +57,8 @@ CheckFwReadLastH2C(
 	bool	 Result = false;
 
 	valHMETFR = rtw_read8(Adapter, REG_HMETFR);
-	//RT_TRACE(COMP_INIT,DBG_LOUD,("REG[%x] = %x\n",	REG_HMETFR, valHMETFR));
 
-	// Do not seperate to 91C and 88C, we use the same setting. Suggested by SD4 Filen. 2009.12.03.
+	/*  Do not seperate to 91C and 88C, we use the same setting. Suggested by SD4 Filen. 2009.12.03. */
 	if (((valHMETFR>>BoxNum)&BIT0) == 0)
 		Result = true;
 
@@ -67,16 +66,16 @@ CheckFwReadLastH2C(
 }
 
 
-//
-// Description:
-//	Fill H2C command
-//	BOX_0-4 Format:
-//	bit [31-8]	|     7		|  [6-0]
-//	     RSVD	|  CMD_EXT	|  CMD_ID
-//
-//	BOX Extension 0-4 format:
-//	bit 15-0: RSVD
-//
+/*  */
+/*  Description: */
+/* 	Fill H2C command */
+/* 	BOX_0-4 Format: */
+/* 	bit [31-8]	|     7		|  [6-0] */
+/* 	     RSVD	|  CMD_EXT	|  CMD_ID */
+/*  */
+/* 	BOX Extension 0-4 format: */
+/* 	bit 15-0: RSVD */
+/*  */
 
 /*****************************************
 * H2C Msg format :
@@ -91,7 +90,7 @@ static void _FillH2CCmd92D(struct rtw_ad
 	u16	BOXReg=0, BOXExtReg=0;
 	u8	BoxContent[4], BoxExtContent[2];
 	u8	BufIndex=0;
-	u8	U1btmp; //Read 0x1bf
+	u8	U1btmp; /* Read 0x1bf */
 	u8	bWriteSucess = false;
 	u8	IsFwRead = false;
 	u8	WaitH2cLimmit = 100;
@@ -105,7 +104,6 @@ _func_enter_;
 
 	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex));
 
-	//DBG_8192D("FillH2CCmd : ElementID=%d\n",ElementID);
 
 	while (!bWriteSucess)
 	{
@@ -116,7 +114,7 @@ _func_enter_;
 			break;
 		}
 
-		// 2. Find the last BOX number which has been writen.
+		/*  2. Find the last BOX number which has been writen. */
 		BoxNum = pHalData->LastHMEBoxNum;
 		switch (BoxNum)
 		{
@@ -140,37 +138,35 @@ _func_enter_;
 				break;
 		}
 
-		// 3. Check if the box content is empty.
+		/*  3. Check if the box content is empty. */
 		IsFwRead = CheckFwReadLastH2C(padapter, BoxNum);
 		while (!IsFwRead)
 		{
-			//wait until Fw read
+			/* wait until Fw read */
 			WaitH2cLimmit--;
 			if (WaitH2cLimmit == 0)
 			{
 				DBG_8192D("FillH2CCmd92C(): Wating too long for FW read clear HMEBox(%d)!!!\n", BoxNum);
 				break;
 			}
-			rtw_udelay_os(10); //us
+			rtw_udelay_os(10); /* us */
 			IsFwRead = CheckFwReadLastH2C(padapter, BoxNum);
 			U1btmp = rtw_read8(padapter, 0x1BF);
-			//DBG_8192D("FillH2CCmd92C(): Wating for FW read clear HMEBox(%d)!!! 0x1BF = %2x\n", BoxNum, U1btmp);
 		}
 
-		// If Fw has not read the last H2C cmd, break and give up this H2C.
+		/*  If Fw has not read the last H2C cmd, break and give up this H2C. */
 		if (!IsFwRead)
 		{
 			DBG_8192D("FillH2CCmd92C():  Write H2C register BOX[%d] fail!!!!! Fw do not read.\n", BoxNum);
 			break;
 		}
 
-		// 4. Fill the H2C cmd into box
+		/*  4. Fill the H2C cmd into box */
 		memset(BoxContent, 0, sizeof(BoxContent));
 		memset(BoxExtContent, 0, sizeof(BoxExtContent));
 
-		BoxContent[0] = ElementID; // Fill element ID
+		BoxContent[0] = ElementID; /*  Fill element ID */
 
-		//DBG_8192D("FillH2CCmd92C():Write ElementID BOXReg(%4x) = %2x\n", BOXReg, ElementID);
 
 		switch (CmdLen)
 		{
@@ -178,8 +174,7 @@ _func_enter_;
 			{
 				BoxContent[0] &= ~(BIT7);
 				memcpy((u8 *)(BoxContent)+1, pCmdBuffer+BufIndex, 1);
-				//PlatformEFIOWrite4Byte(Adapter, BOXReg, *((pu4Byte)BoxContent));
-				//For Endian Free.
+				/* For Endian Free. */
 				for (idx= 0; idx < 4; idx++)
 				{
 					rtw_write8(padapter, BOXReg+idx, BoxContent[idx]);
@@ -190,7 +185,6 @@ _func_enter_;
 			{
 				BoxContent[0] &= ~(BIT7);
 				memcpy((u8 *)(BoxContent)+1, pCmdBuffer+BufIndex, 2);
-				//PlatformEFIOWrite4Byte(Adapter, BOXReg, *((pu4Byte)BoxContent));
 				for (idx=0; idx < 4; idx++)
 				{
 					rtw_write8(padapter, BOXReg+idx, BoxContent[idx]);
@@ -201,7 +195,6 @@ _func_enter_;
 			{
 				BoxContent[0] &= ~(BIT7);
 				memcpy((u8 *)(BoxContent)+1, pCmdBuffer+BufIndex, 3);
-				//PlatformEFIOWrite4Byte(Adapter, BOXReg, *((pu4Byte)BoxContent));
 				for (idx = 0; idx < 4 ; idx++)
 				{
 					rtw_write8(padapter, BOXReg+idx, BoxContent[idx]);
@@ -213,8 +206,6 @@ _func_enter_;
 				BoxContent[0] |= (BIT7);
 				memcpy((u8 *)(BoxExtContent), pCmdBuffer+BufIndex, 2);
 				memcpy((u8 *)(BoxContent)+1, pCmdBuffer+BufIndex+2, 2);
-				//PlatformEFIOWrite2Byte(Adapter, BOXExtReg, *((pu2Byte)BoxExtContent));
-				//PlatformEFIOWrite4Byte(Adapter, BOXReg, *((pu4Byte)BoxContent));
 				for (idx = 0 ; idx < 2 ; idx ++)
 				{
 					rtw_write8(padapter, BOXExtReg+idx, BoxExtContent[idx]);
@@ -230,8 +221,6 @@ _func_enter_;
 				BoxContent[0] |= (BIT7);
 				memcpy((u8 *)(BoxExtContent), pCmdBuffer+BufIndex, 2);
 				memcpy((u8 *)(BoxContent)+1, pCmdBuffer+BufIndex+2, 3);
-				//PlatformEFIOWrite2Byte(Adapter, BOXExtReg, *((pu2Byte)BoxExtContent));
-				//PlatformEFIOWrite4Byte(Adapter, BOXReg, *((pu4Byte)BoxContent));
 				for (idx = 0 ; idx < 2 ; idx ++)
 				{
 					rtw_write8(padapter, BOXExtReg+idx, BoxExtContent[idx]);
@@ -246,19 +235,16 @@ _func_enter_;
 				break;
 		}
 
-		//DBG_8192D("FillH2CCmd(): BoxExtContent=0x%04x\n", *(u16*)BoxExtContent);
-		//DBG_8192D("FillH2CCmd(): BoxContent=0x%08x\n", *(u32*)BoxContent);
 
-		// 5. Normal chip does not need to check if the H2C cmd has be written successfully.
-		// 92D test chip does not need to check,
+		/*  5. Normal chip does not need to check if the H2C cmd has be written successfully. */
+		/*  92D test chip does not need to check, */
 		bWriteSucess = true;
 
-		// Record the next BoxNum
+		/*  Record the next BoxNum */
 		pHalData->LastHMEBoxNum = BoxNum+1;
-		if (pHalData->LastHMEBoxNum == 4) // loop to 0
+		if (pHalData->LastHMEBoxNum == 4) /*  loop to 0 */
 			pHalData->LastHMEBoxNum = 0;
 
-		//DBG_8192D("FillH2CCmd92C():pHalData->LastHMEBoxNum  = %d\n", pHalData->LastHMEBoxNum);
 
 	}
 
@@ -277,7 +263,7 @@ FillH2CCmd92D(
 {
 	u32	tmpCmdBuf[2];
 
-	//Adapter = ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, TRUE);
+	/* Adapter = ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, TRUE); */
 
 	if (Adapter->bFWReady == false)
 	{
@@ -332,10 +318,10 @@ _func_exit_;
 	return res;
 }
 
-//bitmap[0:27] = tx_rate_bitmap
-//bitmap[28:31]= Rate Adaptive id
-//arg[0:4] = macid
-//arg[5] = Short GI
+/* bitmap[0:27] = tx_rate_bitmap */
+/* bitmap[28:31]= Rate Adaptive id */
+/* arg[0:4] = macid */
+/* arg[5] = Short GI */
 void rtl8192d_Add_RateATid(struct rtw_adapter * pAdapter, u32 bitmap, u8 arg)
 {
 
@@ -392,9 +378,6 @@ void ConstructBeacon(struct rtw_adapter
 	struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
 	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 
-
-	//DBG_8192D("%s\n", __func__);
-
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 
 	fctrl = &(pwlanhdr->frame_ctl);
@@ -411,17 +394,17 @@ void ConstructBeacon(struct rtw_adapter
 	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
 	pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
 
-	//timestamp will be inserted by hardware
+	/* timestamp will be inserted by hardware */
 	pframe += 8;
 	pktlen += 8;
 
-	// beacon interval: 2 bytes
+	/*  beacon interval: 2 bytes */
 	memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
 
 	pframe += 2;
 	pktlen += 2;
 
-	// capability info: 2 bytes
+	/*  capability info: 2 bytes */
 	memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
 
 	pframe += 2;
@@ -437,39 +420,38 @@ void ConstructBeacon(struct rtw_adapter
 		goto _ConstructBeacon;
 	}
 
-	//below for ad-hoc mode
+	/* below for ad-hoc mode */
 
-	// SSID
+	/*  SSID */
 	pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pktlen);
 
-	// supported rates...
+	/*  supported rates... */
 	rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
 	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8)? 8: rate_len), cur_network->SupportedRates, &pktlen);
 
-	// DS parameter set
+	/*  DS parameter set */
 	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pktlen);
 
 	if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
 	{
 		u32 ATIMWindow;
-		// IBSS Parameter Set...
-		//ATIMWindow = cur->Configuration.ATIMWindow;
+		/*  IBSS Parameter Set... */
 		ATIMWindow = 0;
 		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pktlen);
 	}
 
 
-	//todo: ERP IE
+	/* todo: ERP IE */
 
 
-	// EXTERNDED SUPPORTED RATE
+	/*  EXTERNDED SUPPORTED RATE */
 	if (rate_len > 8)
 	{
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pktlen);
 	}
 
 
-	//todo:HT for adhoc
+	/* todo:HT for adhoc */
 
 _ConstructBeacon:
 
@@ -481,7 +463,6 @@ _ConstructBeacon:
 
 	*pLength = pktlen;
 
-	//DBG_8192D("%s bcn_sz=%u\n", __func__, pktlen);
 }
 
 void ConstructPSPoll(struct rtw_adapter *padapter, u8 *pframe, u32 *pLength)
@@ -491,23 +472,22 @@ void ConstructPSPoll(struct rtw_adapter
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	//DBG_8192D("%s\n", __func__);
 
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 
-	// Frame control.
+	/*  Frame control. */
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
 	SetPwrMgt(fctrl);
 	SetFrameSubType(pframe, WIFI_PSPOLL);
 
-	// AID.
+	/*  AID. */
 	SetDuration(pframe, (pmlmeinfo->aid| 0xc000));
 
-	// BSSID.
+	/*  BSSID. */
 	memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
 
-	// TA.
+	/*  TA. */
 	memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
 
 	*pLength = 16;
@@ -523,7 +503,6 @@ void ConstructNullFunctionData(struct rt
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	//DBG_8192D("%s:%d\n", __func__, bForcePowerSave);
 
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 
@@ -577,8 +556,6 @@ void ConstructProbeRsp(struct rtw_adapte
 	struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
 
 
-	//DBG_8192D("%s\n", __func__);
-
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 
 	mac = myid(&(padapter->eeprompriv));
@@ -606,12 +583,12 @@ void ConstructProbeRsp(struct rtw_adapte
 	*pLength = pktlen;
 }
 
-//
-// Description: In normal chip, we should send some packet to Hw which will be used by Fw
-//			in FW LPS mode. The function is to fill the Tx descriptor of this packets, then
-//			Fw can tell Hw to send these packet derectly.
-// Added by tynli. 2009.10.15.
-//
+/*  */
+/*  Description: In normal chip, we should send some packet to Hw which will be used by Fw */
+/* 			in FW LPS mode. The function is to fill the Tx descriptor of this packets, then */
+/* 			Fw can tell Hw to send these packet derectly. */
+/*  Added by tynli. 2009.10.15. */
+/*  */
 static void
 FillFakeTxDescriptor92D(
 	struct rtw_adapter *		Adapter,
@@ -623,54 +600,54 @@ FillFakeTxDescriptor92D(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	struct tx_desc	*ptxdesc = (struct tx_desc *)pDesc;
 
-	// Clear all status
+	/*  Clear all status */
 	memset(pDesc, 0, 32);
 
-	//offset 0
-	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG); //own, bFirstSeg, bLastSeg;
+	/* offset 0 */
+	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG); /* own, bFirstSeg, bLastSeg; */
 
-	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000); //32 bytes for TX Desc
+	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000); /* 32 bytes for TX Desc */
 
-	ptxdesc->txdw0 |= cpu_to_le32(BufferLen&0x0000ffff); // Buffer size + command header
+	ptxdesc->txdw0 |= cpu_to_le32(BufferLen&0x0000ffff); /*  Buffer size + command header */
 
-	//offset 4
-	ptxdesc->txdw1 |= cpu_to_le32((QSLT_MGNT<<QSEL_SHT)&0x00001f00); // Fixed queue of Mgnt queue
+	/* offset 4 */
+	ptxdesc->txdw1 |= cpu_to_le32((QSLT_MGNT<<QSEL_SHT)&0x00001f00); /*  Fixed queue of Mgnt queue */
 
-	//Set NAVUSEHDR to prevent Ps-poll AId filed to be changed to error vlaue by Hw.
+	/* Set NAVUSEHDR to prevent Ps-poll AId filed to be changed to error vlaue by Hw. */
 	if (IsPsPoll)
 	{
 		ptxdesc->txdw1 |= cpu_to_le32(NAVUSEHDR);
 	}
 	else
 	{
-		ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); // Hw set sequence number
-		ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); //set bit3 to 1. Suugested by TimChen. 2009.12.29.
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); /*  Hw set sequence number */
+		ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); /* set bit3 to 1. Suugested by TimChen. 2009.12.29. */
 	}
 
-	//offset 16
-	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+	/* offset 16 */
+	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));/* driver uses rate */
 
 	if (pHalData->CurrentBandType92D == BAND_ON_5G)
-		ptxdesc->txdw5 |= cpu_to_le32(BIT(2));// use OFDM 6Mbps
+		ptxdesc->txdw5 |= cpu_to_le32(BIT(2));/*  use OFDM 6Mbps */
 
-	// USB interface drop packet if the checksum of descriptor isn't correct.
-	// Using this checksum can let hardware recovery from packet bulk out error (e.g. Cancel URC, Bulk out error.).
+	/*  USB interface drop packet if the checksum of descriptor isn't correct. */
+	/*  Using this checksum can let hardware recovery from packet bulk out error (e.g. Cancel URC, Bulk out error.). */
 	rtl8192du_cal_txdesc_chksum(ptxdesc);
 
 	RT_PRINT_DATA(_module_rtl8712_cmd_c_, _drv_info_, "FillFakeTxDescriptor92D(): H2C Tx Desc Content ----->\n", pDesc, TXDESC_SIZE);
 }
 
 
-//
-// Description: Fill the reserved packets that FW will use to RSVD page.
-//			Now we just send 4 types packet to rsvd page.
-//			(1)Beacon, (2)Ps-poll, (3)Null data, (4)ProbeRsp.
-//	Input:
-//	    dl_finish - FALSE: At the first time we will send all the packets as a large packet to Hw,
-//						so we need to set the packet length to total lengh.
-//			      TRUE: At the second time, we should send the first packet (default:beacon)
-//						to Hw again and set the lengh in descriptor to the real beacon lengh.
-// 2009.10.15 by tynli.
+/*  */
+/*  Description: Fill the reserved packets that FW will use to RSVD page. */
+/* 			Now we just send 4 types packet to rsvd page. */
+/* 			(1)Beacon, (2)Ps-poll, (3)Null data, (4)ProbeRsp. */
+/* 	Input: */
+/* 	    dl_finish - FALSE: At the first time we will send all the packets as a large packet to Hw, */
+/* 						so we need to set the packet length to total lengh. */
+/* 			      TRUE: At the second time, we should send the first packet (default:beacon) */
+/* 						to Hw again and set the lengh in descriptor to the real beacon lengh. */
+/*  2009.10.15 by tynli. */
 void SetFwRsvdPagePkt(struct rtw_adapter * Adapter, bool dl_finish)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
@@ -697,32 +674,32 @@ void SetFwRsvdPagePkt(struct rtw_adapter
 
 	memset(reservedpagepacket, 0, 1000);
 
-	TxDescLen = 32;//TX_DESC_SIZE;
+	TxDescLen = 32;/* TX_DESC_SIZE; */
 
 	BufIndex = TXDESC_OFFSET;
-	TxDescOffset = TxDescLen+8; //Shift index for 8 bytes because the dummy bytes in the first descipstor.
+	TxDescOffset = TxDescLen+8; /* Shift index for 8 bytes because the dummy bytes in the first descipstor. */
 
-	//(1) beacon
+	/* 1) beacon */
 	ConstructBeacon(Adapter,&reservedpagepacket[BufIndex],&BeaconLength);
 
 	RT_PRINT_DATA(_module_rtl8712_cmd_c_, _drv_info_,
 		"SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: BCN\n",
 		&reservedpagepacket[BufIndex], (BeaconLength+BufIndex));
 
-//--------------------------------------------------------------------
+/*  */
 
-	// When we count the first page size, we need to reserve description size for the RSVD
-	// packet, it will be filled in front of the packet in TXPKTBUF.
+	/*  When we count the first page size, we need to reserve description size for the RSVD */
+	/*  packet, it will be filled in front of the packet in TXPKTBUF. */
 	U1bTmp = (u8)PageNum_128(BeaconLength+TxDescLen);
 	PageNum += U1bTmp;
-	// To reserved 2 pages for beacon buffer. 2010.06.24.
+	/*  To reserved 2 pages for beacon buffer. 2010.06.24. */
 	if (PageNum == 1)
 		PageNum+=1;
 	pHalData->FwRsvdPageStartOffset = PageNum;
 
 	BufIndex = (PageNum*128) + TxDescOffset;
 
-	//(2) ps-poll
+	/* 2) ps-poll */
 	ConstructPSPoll(Adapter, &reservedpagepacket[BufIndex],&PSPollLength);
 
 	FillFakeTxDescriptor92D(Adapter, &reservedpagepacket[BufIndex-TxDescLen], PSPollLength, true);
@@ -733,14 +710,14 @@ void SetFwRsvdPagePkt(struct rtw_adapter
 
 	SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(u1RsvdPageLoc, PageNum);
 
-//------------------------------------------------------------------
+/*  */
 
 	U1bTmp = (u8)PageNum_128(PSPollLength+TxDescLen);
 	PageNum += U1bTmp;
 
 	BufIndex = (PageNum*128) + TxDescOffset;
 
-	//(3) null data
+	/* 3) null data */
 	ConstructNullFunctionData(
 		Adapter,
 		&reservedpagepacket[BufIndex],
@@ -755,14 +732,14 @@ void SetFwRsvdPagePkt(struct rtw_adapter
 	RT_PRINT_DATA(_module_rtl8712_cmd_c_, _drv_info_,
 		"SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: NULL DATA\n",
 		&reservedpagepacket[BufIndex-TxDescLen], (NullFunctionDataLength+TxDescLen));
-//------------------------------------------------------------------
+/*  */
 
 	U1bTmp = (u8)PageNum_128(NullFunctionDataLength+TxDescLen);
 	PageNum += U1bTmp;
 
 	BufIndex = (PageNum*128) + TxDescOffset;
 
-	//(4) probe response
+	/* 4) probe response */
 	ConstructProbeRsp(
 		Adapter,
 		&reservedpagepacket[BufIndex],
@@ -778,7 +755,7 @@ void SetFwRsvdPagePkt(struct rtw_adapter
 		"SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: PROBE RSP\n",
 		&reservedpagepacket[BufIndex-TxDescLen], (ProbeRspLength-TxDescLen));
 
-//------------------------------------------------------------------
+/*  */
 
 	U1bTmp = (u8)PageNum_128(ProbeRspLength+TxDescLen);
 
@@ -791,7 +768,7 @@ void SetFwRsvdPagePkt(struct rtw_adapter
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(Adapter, pattrib);
 	pattrib->qsel = 0x10;
@@ -824,50 +801,46 @@ _func_enter_;
 
 	if (mstatus == 1)
 	{
-		// We should set AID, correct TSF, HW seq enable before set JoinBssReport to Fw in 88/92C.
-		// Suggested by filen. Added by tynli.
+		/*  We should set AID, correct TSF, HW seq enable before set JoinBssReport to Fw in 88/92C. */
+		/*  Suggested by filen. Added by tynli. */
 		rtw_write16(padapter, REG_BCN_PSR_RPT, (0xC000|pmlmeinfo->aid));
-		// Do not set TSF again here or vWiFi beacon DMA INT will not work.
-		//rtw_hal_set_hwreg(Adapter, HW_VAR_CORRECT_TSF, (pu1Byte)(&bTypeIbss));
-		// Hw sequende enable by dedault. 2010.06.23. by tynli.
+		/*  Do not set TSF again here or vWiFi beacon DMA INT will not work. */
+		/* rtw_hal_set_hwreg(Adapter, HW_VAR_CORRECT_TSF, (pu1Byte)(&bTypeIbss)); */
+		/*  Hw sequende enable by dedault. 2010.06.23. by tynli. */
 
-		//set REG_CR bit 8
+		/* set REG_CR bit 8 */
 		pHalData->RegCR_1 |= BIT0;
 		rtw_write8(padapter,  REG_CR+1, pHalData->RegCR_1);
 
-		// Disable Hw protection for a time which revserd for Hw sending beacon.
-		// Fix download reserved page packet fail that access collision with the protection time.
-		// 2010.05.11. Added by tynli.
-		//SetBcnCtrlReg(Adapter, 0, BIT3);
-		//SetBcnCtrlReg(Adapter, BIT4, 0);
+		/*  Disable Hw protection for a time which revserd for Hw sending beacon. */
+		/*  Fix download reserved page packet fail that access collision with the protection time. */
+		/*  2010.05.11. Added by tynli. */
 		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(3)));
 		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4));
 
-		// Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame.
+		/*  Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame. */
 		if (pHalData->RegFwHwTxQCtrl&BIT6)
 			bRecover = true;
 		rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl&(~BIT6)));
 		pHalData->RegFwHwTxQCtrl &= (~BIT6);
 		SetFwRsvdPagePkt(padapter, 0);
 
-		// 2010.05.11. Added by tynli.
-		//SetBcnCtrlReg(Adapter, BIT3, 0);
-		//SetBcnCtrlReg(Adapter, 0, BIT4);
+		/*  2010.05.11. Added by tynli. */
 		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(3));
 		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(4)));
 
-		// To make sure that if there exists an adapter which would like to send beacon.
-		// If exists, the origianl value of 0x422[6] will be 1, we should check this to
-		// prevent from setting 0x422[6] to 0 after download reserved page, or it will cause
-		// the beacon cannot be sent by HW.
-		// 2010.06.23. Added by tynli.
+		/*  To make sure that if there exists an adapter which would like to send beacon. */
+		/*  If exists, the origianl value of 0x422[6] will be 1, we should check this to */
+		/*  prevent from setting 0x422[6] to 0 after download reserved page, or it will cause */
+		/*  the beacon cannot be sent by HW. */
+		/*  2010.06.23. Added by tynli. */
 		if (bRecover)
 		{
 			rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl|BIT6));
 			pHalData->RegFwHwTxQCtrl |= BIT6;
 		}
 
-		// Clear CR[8] or beacon packet will not be send to TxBuf anymore.
+		/*  Clear CR[8] or beacon packet will not be send to TxBuf anymore. */
 		pHalData->RegCR_1 &= (~BIT0);
 		rtw_write8(padapter,  REG_CR+1, pHalData->RegCR_1);
 	}
@@ -907,31 +880,30 @@ _func_enter_;
 			break;
 		case P2P_PS_ENABLE:
 			DBG_8192D("P2P_PS_ENABLE\n");
-			// update CTWindow value.
+			/*  update CTWindow value. */
 			if (pwdinfo->ctwindow > 0)
 			{
 				p2p_ps_offload->CTWindow_En = 1;
 				ctwindow = pwdinfo->ctwindow;
 				rtl8192d_set_p2p_ctw_period_cmd(padapter, ctwindow);
-				//rtw_write16(padapter, REG_ATIMWND, ctwindow);
 			}
 
-			// hw only support 2 set of NoA
+			/*  hw only support 2 set of NoA */
 			for (i=0 ; i<pwdinfo->noa_num ; i++)
 			{
-				// To control the register setting for which NOA
+				/*  To control the register setting for which NOA */
 				rtw_write8(padapter, 0x5CF, (i << 4));
 				if (i == 0)
 					p2p_ps_offload->NoA0_En = 1;
 				else
 					p2p_ps_offload->NoA1_En = 1;
 
-				// config P2P NoA Descriptor Register
+				/*  config P2P NoA Descriptor Register */
 				rtw_write32(padapter, 0x5E0, pwdinfo->noa_duration[i]);
 
 				rtw_write32(padapter, 0x5E4, pwdinfo->noa_interval[i]);
 
-				//Get Current TSF value
+				/* Get Current TSF value */
 				tsf_low = rtw_read32(padapter, REG_TSFTR);
 
 				start_time = pwdinfo->noa_start_time[i];
@@ -944,7 +916,6 @@ _func_enter_;
 							pwdinfo->noa_count[i]--;
 					}
 				}
-				//DBG_8192D("%s(): start_time = %x\n",__func__,start_time);
 				rtw_write32(padapter, 0x5E8, start_time);
 
 				rtw_write8(padapter, 0x5EC, pwdinfo->noa_count[i]);
@@ -952,7 +923,7 @@ _func_enter_;
 
 			if ((pwdinfo->opp_ps == 1) || (pwdinfo->noa_num > 0))
 			{
-				// rst p2p circuit
+				/*  rst p2p circuit */
 				rtw_write8(padapter, REG_DUAL_TSF_RST, BIT(4));
 
 				p2p_ps_offload->Offload_En = 1;
@@ -987,7 +958,7 @@ _func_enter_;
 
 _func_exit_;
 }
-#endif // CONFIG_P2P_PS
+#endif /*  CONFIG_P2P_PS */
 
 
 
@@ -1033,7 +1004,7 @@ int reset_tsf(struct rtw_adapter * Adapt
 }
 
 
-#endif	// CONFIG_TSF_RESET_OFFLOAD
+#endif	/*  CONFIG_TSF_RESET_OFFLOAD */
 
 #ifdef CONFIG_WOWLAN
 
@@ -1057,64 +1028,55 @@ _func_enter_;
 
 
 	if (pwrpriv->wowlan_mode ==true) {
-		//pause RX DMA
+		/* pause RX DMA */
 		test = rtw_read8(padapter, REG_RXPKT_NUM+2);
 		test |= BIT(2);
 		rtw_write8(padapter, REG_RXPKT_NUM+2, test);
-		//286 BIT(1) , not 1(means idle) do rx urb
+		/* 286 BIT(1) , not 1(means idle) do rx urb */
 		test = rtw_read8(padapter, REG_RXPKT_NUM+2) & BIT(1);
-		//printk("line(%d) 0x286=%d\n", __LINE__, rtw_read8(padapter, REG_RXPKT_NUM+2));
-		//check DMA idle?
+		/* check DMA idle? */
 		while (test != BIT(1))
 		{
 			tasklet_schedule(&precvpriv->recv_tasklet);
 			test = rtw_read8(padapter, REG_RXPKT_NUM+2) & BIT(1);
 			rtw_msleep_os(10);
-			//printk("line(%d) 0x286=%d\n", __LINE__, test);
 		}
-		//mask usb se0 reset by Alex and DD
+		/* mask usb se0 reset by Alex and DD */
 		test = rtw_read8(padapter, 0xf8);
 		test &= ~(BIT(3)|BIT(4));
 		rtw_write8(padapter, 0xf8, test);
 
 		pwowlan_parm.mode |=FW_WOWLAN_FUN_EN;
-		//printk("\n %s 1.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		if (pwrpriv->wowlan_pattern ==true) {
 			pwowlan_parm.mode |= FW_WOWLAN_PATTERN_MATCH;
-		//printk("\n %s 2.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		}
 		if (pwrpriv->wowlan_magic ==true) {
-			//pwowlan_parm.mode |=FW_WOWLAN_MAGIC_PKT;
-		//printk("\n %s 3.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		}
 		if (pwrpriv->wowlan_unicast ==true) {
 			pwowlan_parm.mode |=FW_WOWLAN_UNICAST;
-		//printk("\n %s 4.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		}
 
 		rtl8192d_set_FwJoinBssReport_cmd(padapter, 1);
 
-		//WOWLAN_GPIO_ACTIVE means GPIO high active
-		//pwowlan_parm.mode |=FW_WOWLAN_GPIO_ACTIVE;
+		/* WOWLAN_GPIO_ACTIVE means GPIO high active */
 		pwowlan_parm.mode |=FW_WOWLAN_REKEY_WAKEUP;
 		pwowlan_parm.mode |=FW_WOWLAN_DEAUTH_WAKEUP;
 
-		//GPIO 0
+		/* GPIO 0 */
 		pwowlan_parm.gpio_index=0;
 
-		//duration unit is 64us
+		/* duration unit is 64us */
 		pwowlan_parm.gpio_duration=0xff;
 
 		pwowlan_parm.second_mode|=FW_WOWLAN_GPIO_WAKEUP_EN;
 		pwowlan_parm.second_mode|=FW_FW_PARSE_MAGIC_PKT;
-		//printk("\n %s 5.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		{	u8 *ptr=(u8 *)&pwowlan_parm;
 			printk("\n %s H2C_WO_WLAN=%x %02x:%02x:%02x:%02x:%02x\n",__func__,H2C_WO_WLAN_CMD,ptr[0],ptr[1],ptr[2],ptr[3],ptr[4]);
 		}
 		FillH2CCmd92D(padapter, H2C_WO_WLAN_CMD, 4, (u8 *)&pwowlan_parm);
 
 
-		//keep alive period = 3 * 10 BCN interval
+		/* keep alive period = 3 * 10 BCN interval */
 		pwowlan_parm.mode =3;
 		pwowlan_parm.gpio_index=3;
 		FillH2CCmd92D(padapter, KEEP_ALIVE_CONTROL_CMD, 2, (u8 *)&pwowlan_parm);
@@ -1126,7 +1088,7 @@ _func_enter_;
 		FillH2CCmd92D(padapter, DISCONNECT_DECISION_CTRL_CMD, 3, (u8 *)&pwowlan_parm);
 		printk("%s after DISCONNECT_DECISION_CTRL_CMD register 0x81=%x\n",__func__,rtw_read8(padapter, 0x85));
 
-		//enable GPIO wakeup
+		/* enable GPIO wakeup */
 		pwowlan_parm.mode =1;
 		pwowlan_parm.gpio_index=0;
 		pwowlan_parm.gpio_duration=0;
@@ -1143,4 +1105,4 @@ _func_exit_;
 	return ;
 }
 
-#endif  //CONFIG_WOWLAN
+#endif  /* CONFIG_WOWLAN */
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -17,17 +17,17 @@
  *
  *
  ******************************************************************************/
-//============================================================
-// Description:
-//
-// This file is for 92CE/92CU dynamic mechanism only
-//
-//
-//============================================================
-
-//============================================================
-// include files
-//============================================================
+/*  */
+/*  Description: */
+/*  */
+/*  This file is for 92CE/92CU dynamic mechanism only */
+/*  */
+/*  */
+/*  */
+
+/*  */
+/*  include files */
+/*  */
 #include <drv_conf.h>
 #include <osdep_service.h>
 #include <drv_types.h>
@@ -35,19 +35,17 @@
 #include <hal_intf.h>
 
 #include <rtl8192d_hal.h>
-//avoid to warn in FreeBSD
+/* avoid to warn in FreeBSD */
 u32 EDCAParam[maxAP][3] =
-{          // UL			DL
-	{0x5ea322, 0x00a630, 0x00a44f}, //atheros AP
-	{0x5ea32b, 0x5ea42b, 0x5e4322}, //broadcom AP
-	{0x3ea430, 0x00a630, 0x3ea44f}, //cisco AP
-	{0x5ea44f, 0x00a44f, 0x5ea42b}, //marvell AP
-	{0x5ea422, 0x00a44f, 0x00a44f}, //ralink AP
-	//{0x5ea44f, 0x5ea44f, 0x5ea44f}, //realtek AP
-	{0xa44f, 0x5ea44f, 0x5e431c}, //realtek AP
-	{0x5ea42b, 0xa630, 0x5e431c}, //airgocap AP
-	{0x5ea42b, 0x5ea42b, 0x5ea42b}, //unknown AP
-//	{0x5e4322, 0x00a44f, 0x5ea44f}, //unknown AP
+{          /*  UL			DL */
+	{0x5ea322, 0x00a630, 0x00a44f}, /* atheros AP */
+	{0x5ea32b, 0x5ea42b, 0x5e4322}, /* broadcom AP */
+	{0x3ea430, 0x00a630, 0x3ea44f}, /* cisco AP */
+	{0x5ea44f, 0x00a44f, 0x5ea42b}, /* marvell AP */
+	{0x5ea422, 0x00a44f, 0x00a44f}, /* ralink AP */
+	{0xa44f, 0x5ea44f, 0x5e431c}, /* realtek AP */
+	{0x5ea42b, 0xa630, 0x5e431c}, /* airgocap AP */
+	{0x5ea42b, 0x5ea42b, 0x5ea42b}, /* unknown AP */
 };
 
 extern atomic_t GlobalMutexForGlobalAdapterList;
@@ -128,7 +126,7 @@ dm_DualMacGetParameterFromBuddyAdapter(
 	if (pHalData->bSlaveOfDMSP)
 		return false;
 
-//sherry sync with 92C_92D, 20110701
+/* sherry sync with 92C_92D, 20110701 */
 	if ((check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) && (!check_fwstate(pmlmepriv, _FW_LINKED))
 		&& (!check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE)))
 		return true;
@@ -171,7 +169,7 @@ odm_FalseAlarmCounterStatistics_ForSlave
 								falsealmcnt->Cnt_Fast_Fsync + falsealmcnt->Cnt_SB_Search_fail;
 
 
-	//hold cck counter
+	/* hold cck counter */
 	falsealmcnt->Cnt_Cck_fail = FlaseAlmCntBuddyAdapter->Cnt_Cck_fail;
 
 	falsealmcnt->Cnt_all = (	falsealmcnt->Cnt_Fast_Fsync +
@@ -182,14 +180,6 @@ odm_FalseAlarmCounterStatistics_ForSlave
 						falsealmcnt->Cnt_Mcs_fail +
 						falsealmcnt->Cnt_Cck_fail);
 
-/*
-	RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Fast_Fsync = %d, Cnt_SB_Search_fail = %d\n",
-				falsealmcnt->Cnt_Fast_Fsync , falsealmcnt->Cnt_SB_Search_fail));
-	RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Parity_Fail = %d, Cnt_Rate_Illegal = %d, Cnt_Crc8_fail = %d, Cnt_Mcs_fail = %d\n",
-				falsealmcnt->Cnt_Parity_Fail, falsealmcnt->Cnt_Rate_Illegal, falsealmcnt->Cnt_Crc8_fail, falsealmcnt->Cnt_Mcs_fail));
-	RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Ofdm_fail = %d, Cnt_Cck_fail = %d, Cnt_all = %d\n",
-				falsealmcnt->Cnt_Ofdm_fail, falsealmcnt->Cnt_Cck_fail, falsealmcnt->Cnt_all));
-*/
 #endif
 }
 
@@ -208,10 +198,10 @@ odm_FalseAlarmCounterStatistics(
 	struct rtw_adapter * pbuddy_adapter = Adapter->pbuddy_adapter;
 	struct hal_data_8192du *pbuddy_pHalData = GET_HAL_DATA(pbuddy_adapter);
 	struct mlme_priv *pbuddy_pmlmepriv = &(pbuddy_adapter->mlmepriv);
-#endif //CONFIG_CONCURRENT_MODE
-	//hold ofdm counter
-	PHY_SetBBReg(Adapter, rOFDM0_LSTF, BIT31, 1); //hold page C counter
-	PHY_SetBBReg(Adapter, rOFDM1_LSTF, BIT31, 1); //hold page D counter
+#endif /* CONFIG_CONCURRENT_MODE */
+	/* hold ofdm counter */
+	PHY_SetBBReg(Adapter, rOFDM0_LSTF, BIT31, 1); /* hold page C counter */
+	PHY_SetBBReg(Adapter, rOFDM1_LSTF, BIT31, 1); /* hold page D counter */
 
 	ret_value = PHY_QueryBBReg(Adapter, rOFDM0_FrameSync, bMaskDWord);
 	falsealmcnt->Cnt_Fast_Fsync = (ret_value&0xffff);
@@ -230,16 +220,13 @@ odm_FalseAlarmCounterStatistics(
 
 	if (pHalData->CurrentBandType92D != BAND_ON_5G)
 	{
-		//hold cck counter
-		//AcquireCCKAndRWPageAControl(Adapter);
-		//PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, BIT14, 1);
+		/* hold cck counter */
 
 		ret_value = PHY_QueryBBReg(Adapter, rCCK0_FACounterLower, bMaskByte0);
 		falsealmcnt->Cnt_Cck_fail = ret_value;
 
 		ret_value = PHY_QueryBBReg(Adapter, rCCK0_FACounterUpper, bMaskByte3);
 		falsealmcnt->Cnt_Cck_fail +=  (ret_value& 0xff)<<8;
-		//ReleaseCCKAndRWPageAControl(Adapter);
 	}
 	else
 	{
@@ -258,34 +245,34 @@ odm_FalseAlarmCounterStatistics(
 #ifdef CONFIG_CONCURRENT_MODE
 	if (pbuddy_adapter)
 		pbuddy_adapter->recvpriv.falsealmcnt_all = falsealmcnt->Cnt_all;
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
-	//reset false alarm counter registers
+	/* reset false alarm counter registers */
 	PHY_SetBBReg(Adapter, rOFDM1_LSTF, 0x08000000, 1);
 	PHY_SetBBReg(Adapter, rOFDM1_LSTF, 0x08000000, 0);
-	//update ofdm counter
-	PHY_SetBBReg(Adapter, rOFDM0_LSTF, BIT31, 0); //update page C counter
-	PHY_SetBBReg(Adapter, rOFDM1_LSTF, BIT31, 0); //update page D counter
+	/* update ofdm counter */
+	PHY_SetBBReg(Adapter, rOFDM0_LSTF, BIT31, 0); /* update page C counter */
+	PHY_SetBBReg(Adapter, rOFDM1_LSTF, BIT31, 0); /* update page D counter */
 	if (pHalData->CurrentBandType92D != BAND_ON_5G) {
-		//reset cck counter
+		/* reset cck counter */
 		PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, 0x0000c000, 0);
-		//enable cck counter
+		/* enable cck counter */
 		PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, 0x0000c000, 2);
 	}
 
-	//BB Reset
+	/* BB Reset */
 	if (IS_HARDWARE_TYPE_8192D(Adapter))
 	{
 		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
 			if ((pHalData->CurrentBandType92D == BAND_ON_2_4G) && pHalData->bMasterOfDMSP && (check_fwstate(pmlmepriv, _FW_LINKED) == false))
 			{
-				//before BB reset should do clock gated
+				/* before BB reset should do clock gated */
 				rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 				BBReset = rtw_read8(Adapter, 0x02);
 				rtw_write8(Adapter, 0x02, BBReset&(~BIT0));
 				rtw_write8(Adapter, 0x02, BBReset|BIT0);
-				//undo clock gated
+				/* undo clock gated */
 				rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
 			}
 		}
@@ -294,27 +281,27 @@ odm_FalseAlarmCounterStatistics(
 			if ((pHalData->CurrentBandType92D == BAND_ON_2_4G) &&(check_fwstate(pmlmepriv, _FW_LINKED) == false)
 #ifdef CONFIG_CONCURRENT_MODE
 				 && (check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == false)
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 			)
 			{
-				//before BB reset should do clock gated
+				/* before BB reset should do clock gated */
 				rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 				BBReset = rtw_read8(Adapter, 0x02);
 				rtw_write8(Adapter, 0x02, BBReset&(~BIT0));
 				rtw_write8(Adapter, 0x02, BBReset|BIT0);
-				//undo clock gated
+				/* undo clock gated */
 				rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
 			}
 		}
 	}
 	else if (check_fwstate(pmlmepriv, _FW_LINKED) == false)
 	{
-		//before BB reset should do clock gated
+		/* before BB reset should do clock gated */
 		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 		BBReset = rtw_read8(Adapter, 0x02);
 		rtw_write8(Adapter, 0x02, BBReset&(~BIT0));
 		rtw_write8(Adapter, 0x02, BBReset|BIT0);
-		//undo clock gated
+		/* undo clock gated */
 		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
 	}
 }
@@ -340,14 +327,12 @@ odm_FindMinimumRSSI_Dmsp(
 			Buddydmpriv = &GET_HAL_DATA(BuddyAdapter)->dmpriv;
 			if (pHalData->bSlaveOfDMSP)
 			{
-				//DBG_8192D("bSlavecase of dmsp\n");
 				Buddydmpriv->RssiValMinForAnotherMacOfDMSP = pdmpriv->MinUndecoratedPWDBForDM;
 			}
 			else
 			{
 				if (bGetValueFromBuddyAdapter)
 				{
-					//DBG_8192D("get new RSSI\n");
 					rest_rssi = true;
 					rssi_val_min_back_for_mac0 = pdmpriv->MinUndecoratedPWDBForDM;
 					pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->RssiValMinForAnotherMacOfDMSP;
@@ -374,37 +359,32 @@ struct rtw_adapter *	pAdapter
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct mlme_priv	*pmlmepriv = &pAdapter->mlmepriv;
 
-	//1 1.Determine the minimum RSSI
+	/* 1 1.Determine the minimum RSSI */
 	if ((check_fwstate(pmlmepriv, _FW_LINKED) == false) &&
 		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
 	{
 		pdmpriv->MinUndecoratedPWDBForDM = 0;
-		//RT_TRACE(COMP_BB_POWERSAVING, DBG_LOUD, ("Not connected to any\n"));
 	}
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)	// Default port
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)	/*  Default port */
 	{
 		if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) ||
 			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
 			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
 		{
 			pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-			//RT_TRACE(COMP_BB_POWERSAVING, DBG_LOUD, ("AP Client PWDB = 0x%x\n", pHalData->MinUndecoratedPWDBForDM));
 		}
 		else
 		{
 			pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->UndecoratedSmoothedPWDB;
-			//RT_TRACE(COMP_BB_POWERSAVING, DBG_LOUD, ("STA Default Port PWDB = 0x%x\n", pHalData->MinUndecoratedPWDBForDM));
 		}
 	}
-	else // associated entry pwdb
+	else /*  associated entry pwdb */
 	{
 		pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-		//RT_TRACE(COMP_BB_POWERSAVING, DBG_LOUD, ("AP Ext Port or disconnet PWDB = 0x%x\n", pHalData->MinUndecoratedPWDBForDM));
 	}
 
 	odm_FindMinimumRSSI_Dmsp(pAdapter);
 
-	//RT_TRACE(COMP_DIG, DBG_LOUD, ("MinUndecoratedPWDBForDM =%d\n",pHalData->MinUndecoratedPWDBForDM));
 }
 
 static u8
@@ -437,11 +417,8 @@ DM_Write_DIG_DMSP(
 	bool		bGetValueFromOtherMac = dm_DualMacGetParameterFromBuddyAdapter(pAdapter);
 	struct dm_priv	*Buddydmpriv;
 
-	//DBG_8192D(("curigvalue = 0x%x, preigvalue = 0x%x\n", dm_digtable->curigvalue, dm_digtable->preigvalue);
-
 	if (BuddyAdapter == NULL)
 	{
-		//DBG_8192D("DM_Write_DIG_DMSP(): not find buddyAdapter\n");
 		if (pHalData->bMasterOfDMSP)
 		{
 			PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
@@ -455,10 +432,8 @@ DM_Write_DIG_DMSP(
 		return;
 	}
 
-	//DBG_8192D("bGetValueFromOtherMac %d\n",bGetValueFromOtherMac);
 	if (bGetValueFromOtherMac)
 	{
-		//DBG_8192D("DM_Write_DIG_DMSP(): mac 0 set mac 1 value\n");
 		if (pdmpriv->bWriteDigForAnotherMacOfDMSP)
 		{
 			pdmpriv->bWriteDigForAnotherMacOfDMSP = false;
@@ -471,23 +446,18 @@ DM_Write_DIG_DMSP(
 
 	if (dm_digtable->preigvalue != dm_digtable->curigvalue)
 	{
-		// Set initial gain.
-		// 20100211 Joseph: Set only BIT0~BIT6 for DIG. BIT7 is the function switch of Antenna diversity.
-		// Just not to modified it for SD3 testing.
-		//PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, bMaskByte0, dm_digtable->curigvalue);
-		//PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, bMaskByte0, dm_digtable->curigvalue);
+		/*  Set initial gain. */
+		/*  20100211 Joseph: Set only BIT0~BIT6 for DIG. BIT7 is the function switch of Antenna diversity. */
+		/*  Just not to modified it for SD3 testing. */
 		 if (pHalData->bSlaveOfDMSP)
 		 {
-			//DBG_8192D("DM_Write_DIG_DMSP(): slave case\n");
 			Buddydmpriv->bWriteDigForAnotherMacOfDMSP = true;
 			Buddydmpriv->CurDigValueForAnotherMacOfDMSP =  dm_digtable->curigvalue;
 		 }
 		else
 		{
-			//DBG_8192D("DM_Write_DIG_DMSP(): master case\n");
 			if (!bGetValueFromOtherMac)
 			{
-				//DBG_8192D("DM_Write_DIG_DMSP(): mac 0 set mac 0 value\n");
 				PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
 				PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
 			}
@@ -511,9 +481,9 @@ DM_Write_DIG(
 
 	if ((dm_digtable->preigvalue != dm_digtable->curigvalue) || (pAdapter->bForceWriteInitGain))
 	{
-		// Set initial gain.
-		// 20100211 Joseph: Set only BIT0~BIT6 for DIG. BIT7 is the function switch of Antenna diversity.
-		// Just not to modified it for SD3 testing.
+		/*  Set initial gain. */
+		/*  20100211 Joseph: Set only BIT0~BIT6 for DIG. BIT7 is the function switch of Antenna diversity. */
+		/*  Just not to modified it for SD3 testing. */
 		PHY_SetBBReg(pAdapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
 		PHY_SetBBReg(pAdapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
 		if (dm_digtable->curigvalue != 0x17)
@@ -542,9 +512,8 @@ static void odm_DIG(
 	struct hal_data_8192du *pbuddy_pHalData = GET_HAL_DATA(pbuddy_adapter);
 	struct mlme_priv	*pbuddy_pmlmepriv = &(pbuddy_adapter->mlmepriv);
 	struct dm_priv	*pbuddy_pdmpriv = &pbuddy_pHalData->dmpriv;
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
-	//RT_TRACE(COMP_DIG, DBG_LOUD, ("odm_DIG() ==>\n"));
 
 	if (IS_HARDWARE_TYPE_8192D(pAdapter))
 	{
@@ -554,15 +523,12 @@ static void odm_DIG(
 			{
 				DIG_Dynamic_MIN = DIG_Dynamic_MIN_0;
 				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_0 == false);
-				//DBG_8192D("bMediaConnect_0=%d,  pMgntInfo->bMediaConnect=%d\n", bMediaConnect_0, check_fwstate(pmlmepriv, _FW_LINKED));
 			}
 			else
 			{
 				DIG_Dynamic_MIN = DIG_Dynamic_MIN_1;
 				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_1 == false);
-				//DBG_8192D("bMediaConnect_1=%d,  pMgntInfo->bMediaConnect=%d\n", bMediaConnect_1, check_fwstate(pmlmepriv, _FW_LINKED));
 			}
-			//DBG_8192D("pHalData->CurrentBandType92D = %s\n",(pHalData->CurrentBandType92D==BAND_ON_2_4G)?"2.4G":"5G");
 		}
 		else
 		{
@@ -574,8 +540,7 @@ static void odm_DIG(
 				) && (bMediaConnect_0 == false);
 #else
 				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_0 == false);
-#endif //CONFIG_CONCURRENT_MODE
-				//DBG_8192D("bMediaConnect_5G=%d,  pMgntInfo->bMediaConnect=%d\n", bMediaConnect_0, check_fwstate(pmlmepriv, _FW_LINKED));
+#endif /* CONFIG_CONCURRENT_MODE */
 			}
 			else
 			{
@@ -585,8 +550,7 @@ static void odm_DIG(
 				) && (bMediaConnect_1 == false);
 #else
 				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_1 == false);
-#endif //CONFIG_CONCURRENT_MODE
-				//DBG_8192D("bMediaConnect_2.4G=%d,  pMgntInfo->bMediaConnect=%d\n", bMediaConnect_1, check_fwstate(pmlmepriv, _FW_LINKED));
+#endif /* CONFIG_CONCURRENT_MODE */
 			}
 		}
 	}
@@ -598,55 +562,44 @@ static void odm_DIG(
 		) && (bMediaConnect_0 == false);
 #else
 		FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_0 == false);
-#endif //CONFIG_CONCURRENT_MODE
-		//DBG_8192D("bMediaConnect=%d,  pMgntInfo->bMediaConnect=%d\n", bMediaConnect_0, check_fwstate(pmlmepriv, _FW_LINKED));
+#endif /* CONFIG_CONCURRENT_MODE */
 	}
 
-	//DBG_8192D("Cnt_Parity_Fail = %d, Cnt_Rate_Illegal = %d, Cnt_Crc8_fail = %d, Cnt_Mcs_fail = %d\n",
-	//			falsealmcnt->Cnt_Parity_Fail, falsealmcnt->Cnt_Rate_Illegal, falsealmcnt->Cnt_Crc8_fail, falsealmcnt->Cnt_Mcs_fail);
-	//DBG_8192D("Cnt_Fast_Fsync = %d, Cnt_SB_Search_fail = %d\n",
-	//			falsealmcnt->Cnt_Fast_Fsync, falsealmcnt->Cnt_SB_Search_fail);
-	//DBG_8192D("Cnt_Ofdm_fail = %d, Cnt_Cck_fail = %d, Cnt_all = %d\n",
-	//			falsealmcnt->Cnt_Ofdm_fail, falsealmcnt->Cnt_Cck_fail, falsealmcnt->Cnt_all);
-	//DBG_8192D("RSSI_A=%d, RSSI_B=%d, RSSI_Ave=%d, RSSI_CCK=%d\n",
-	//	pAdapter->RxStats.RxRSSIPercentage[0], pAdapter->RxStats.RxRSSIPercentage[1], pdmpriv->UndecoratedSmoothedPWDB,pdmpriv->UndecoratedSmoothedCCK);
-	//DBG_8192D("RX Rate =  0x%x, TX Rate = 0x%x\n", pHalData->RxRate, TxRate);
-
 #ifndef CONFIG_CONCURRENT_MODE
 	if (pdmpriv->bDMInitialGainEnable == false)
 		return;
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG) || !(pbuddy_pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
 #else
 	if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 		return;
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (pAdapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS || pbuddy_adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)
 #else
 	if (pAdapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 		return;
 
-	//1 Boundary Decision
+	/* 1 Boundary Decision */
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
 #else
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 	{
-		//2 Get minimum RSSI value among associated devices
+		/* 2 Get minimum RSSI value among associated devices */
 		dm_digtable->rssi_val_min = odm_initial_gain_MinPWDB(pAdapter);
 
-		//2 Modify DIG upper bound
+		/* 2 Modify DIG upper bound */
 		if ((dm_digtable->rssi_val_min + 20) > DM_DIG_MAX)
 			dm_digtable->rx_gain_range_max = DM_DIG_MAX;
 		else
 			dm_digtable->rx_gain_range_max = dm_digtable->rssi_val_min + 20;
-		//2 Modify DIG lower bound
+		/* 2 Modify DIG lower bound */
 		if ((falsealmcnt->Cnt_all > 500)&&(DIG_Dynamic_MIN < 0x25))
 			DIG_Dynamic_MIN++;
 		if ((falsealmcnt->Cnt_all < 500)&&(DIG_Dynamic_MIN > DM_DIG_MIN))
@@ -658,11 +611,9 @@ static void odm_DIG(
 		DIG_Dynamic_MIN = DM_DIG_MIN;
 	}
 
-	//1 Modify DIG lower bound, deal with abnorally large false alarm
+	/* 1 Modify DIG lower bound, deal with abnorally large false alarm */
 	if (falsealmcnt->Cnt_all > 10000)
 	{
-		//DBG_8192D("dm_DIG(): Abnornally false alarm case.\n");
-
 		dm_digtable->largefahit++;
 		if (dm_digtable->forbiddenigi < dm_digtable->curigvalue)
 		{
@@ -676,23 +627,23 @@ static void odm_DIG(
 				dm_digtable->rx_gain_range_min = dm_digtable->rx_gain_range_max;
 			else
 				dm_digtable->rx_gain_range_min = (dm_digtable->forbiddenigi + 1);
-			dm_digtable->recover_cnt = 3600; //3600=2hr
+			dm_digtable->recover_cnt = 3600; /* 3600=2hr */
 		}
 
 	}
 	else
 	{
-		//Recovery mechanism for IGI lower bound
+		/* Recovery mechanism for IGI lower bound */
 		if (dm_digtable->recover_cnt != 0)
 			dm_digtable->recover_cnt --;
 		else
 		{
 			if (dm_digtable->largefahit == 0)
 			{
-				if ((dm_digtable->forbiddenigi -1) < DIG_Dynamic_MIN) //DM_DIG_MIN)
+				if ((dm_digtable->forbiddenigi -1) < DIG_Dynamic_MIN) /* DM_DIG_MIN) */
 				{
-					dm_digtable->forbiddenigi = DIG_Dynamic_MIN; //DM_DIG_MIN;
-					dm_digtable->rx_gain_range_min = DIG_Dynamic_MIN; //DM_DIG_MIN;
+					dm_digtable->forbiddenigi = DIG_Dynamic_MIN; /* DM_DIG_MIN; */
+					dm_digtable->rx_gain_range_min = DIG_Dynamic_MIN; /* DM_DIG_MIN; */
 				}
 				else
 				{
@@ -708,12 +659,12 @@ static void odm_DIG(
 
 	}
 
-	//1 Adjust initial gain by false alarm
+	/* 1 Adjust initial gain by false alarm */
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
 #else
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 	{
 		if (FirstConnect) {
 			dm_digtable->curigvalue = dm_digtable->rssi_val_min;
@@ -735,9 +686,9 @@ static void odm_DIG(
 			}
 		}
 	} else {
-		//	There is no network interface connects to AP.
+		/* 	There is no network interface connects to AP. */
 		if (0 == dm_digtable->rx_gain_range_min_nolink) {
-			//	First time to enter odm_DIG function and set the default value to rx_gain_range_min_nolink
+			/* 	First time to enter odm_DIG function and set the default value to rx_gain_range_min_nolink */
 			dm_digtable->rx_gain_range_min_nolink = 0x30;
 		} else {
 			if ((falsealmcnt->Cnt_all > 1000) && (falsealmcnt->Cnt_all < 2000)) {
@@ -754,7 +705,7 @@ static void odm_DIG(
 
 		dm_digtable->curigvalue = dm_digtable->rx_gain_range_min_nolink;
 	}
-	//1 Check initial gain by upper/lower bound
+	/* 1 Check initial gain by upper/lower bound */
 	if (dm_digtable->curigvalue > dm_digtable->rx_gain_range_max)
 		dm_digtable->curigvalue = dm_digtable->rx_gain_range_max;
 
@@ -770,7 +721,7 @@ static void odm_DIG(
 
 	if (IS_HARDWARE_TYPE_8192D(pAdapter))
 	{
-		//sherry  delete DualMacSmartConncurrent 20110517
+		/* sherry  delete DualMacSmartConncurrent 20110517 */
 		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
 			DM_Write_DIG_DMSP(pAdapter);
@@ -794,7 +745,7 @@ static void odm_DIG(
 				bMediaConnect_0 = (check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED));
 #else
 				bMediaConnect_0 = check_fwstate(pmlmepriv, _FW_LINKED);
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 				DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
 			}
 			else
@@ -803,7 +754,7 @@ static void odm_DIG(
 				bMediaConnect_1 = (check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED));
 #else
 				bMediaConnect_1 = check_fwstate(pmlmepriv, _FW_LINKED);
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 				DIG_Dynamic_MIN_1 = DIG_Dynamic_MIN;
 			}
 		}
@@ -815,29 +766,29 @@ static void odm_DIG(
 		bMediaConnect_0 = (check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED));
 #else
 		bMediaConnect_0 = check_fwstate(pmlmepriv, _FW_LINKED);
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 		DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
 	}
 
 	if ((pregistrypriv->lowrate_two_xmit) && IS_HARDWARE_TYPE_8192D(pAdapter) &&
 		(pHalData->MacPhyMode92D != DUALMAC_DUALPHY) && (!pregistrypriv->special_rf_path))
 	{
-		//for Use 2 path Tx to transmit MCS0~7 and legacy mode
+		/* for Use 2 path Tx to transmit MCS0~7 and legacy mode */
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
 #else
 		if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 		{
-			if (dm_digtable->rssi_val_min  <= 30)   //low rate 2T2R settings
+			if (dm_digtable->rssi_val_min  <= 30)   /* low rate 2T2R settings */
 			{
-				//Reg90C=0x83321333 (OFDM 2T)
-				//RegA07=0xc1            (CCK 2T2R)
-				//RegA11=0x9b            (no switch polarity of two antenna)
-				//RegA20=0x10            (extend CS ratio as X1.125)
-				//RegA2E=0xdf             (MRC on)
-				//RegA2F=0x10            (CDD 90ns for path-B)
-				//RegA75=0x01            (antenna selection enable)
+				/* Reg90C=0x83321333 (OFDM 2T) */
+				/* RegA07=0xc1            (CCK 2T2R) */
+				/* RegA11=0x9b            (no switch polarity of two antenna) */
+				/* RegA20=0x10            (extend CS ratio as X1.125) */
+				/* RegA2E=0xdf             (MRC on) */
+				/* RegA2F=0x10            (CDD 90ns for path-B) */
+				/* RegA75=0x01            (antenna selection enable) */
 
 				rtw_write32(pAdapter, 0x90C, 0x83321333);
 				rtw_write8(pAdapter, 0xA07, 0xc1);
@@ -848,15 +799,15 @@ static void odm_DIG(
 				rtw_write8(pAdapter, 0xA75, 0x01);
 
 			}
-			else if (dm_digtable->rssi_val_min  >= 35)  //low rate 1T1R Settings
+			else if (dm_digtable->rssi_val_min  >= 35)  /* low rate 1T1R Settings */
 			{
-				//Reg90C=0x81121313
-				//RegA07=0x80
-				//RegA11=0xbb
-				//RegA20=0x00
-				//RegA2E=0xd3
-				//RegA2F=0x00
-				//RegA75=0x00
+				/* Reg90C=0x81121313 */
+				/* RegA07=0x80 */
+				/* RegA11=0xbb */
+				/* RegA20=0x00 */
+				/* RegA2E=0xd3 */
+				/* RegA2F=0x00 */
+				/* RegA75=0x00 */
 
 				rtw_write32(pAdapter, 0x90C, 0x81121313);
 				rtw_write8(pAdapter, 0xA07, 0x80);
@@ -872,7 +823,6 @@ static void odm_DIG(
 	}
 
 
-	//RT_TRACE(COMP_DIG, DBG_LOUD, ("odm_DIG() <==\n"));
 }
 
 static u8
@@ -914,10 +864,6 @@ static void dm_CCK_PacketDetectionThresh
 	bool		bGetValueFromBuddyAdapter = dm_DualMacGetParameterFromBuddyAdapter(pAdapter);
 	struct dm_priv	*Buddydmpriv;
 
-
-	//if (pAdapter->DualMacSmartConcurrent == false)
-	//	return;
-
 	if (dm_digtable->curstaconnectstate == DIG_STA_CONNECT)
 	{
 		dm_digtable->rssi_val_min = dm_initial_gain_MinPWDB(pAdapter);
@@ -946,26 +892,12 @@ static void dm_CCK_PacketDetectionThresh
 			DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): mac 0 set for mac1\n");
 			if (pdmpriv->curcckpdstateForAnotherMacOfDMSP == CCK_PD_STAGE_LOWRSSI)
 			{
-				//AcquireCCKAndRWPageAControl(pAdapter);
-				//RT_TRACE(COMP_INIT,DBG_LOUD,("Acquiere mutex in dm_cck_packetdetection\n"));
 				PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0x83);
-				//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_cck_packetdetection\n"));
-				//ReleaseCCKAndRWPageAControl(pAdapter);
-				//PHY_SetBBReg(pAdapter, rCCK0_System, bMaskByte1, 0x40);
-				//if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
-					//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , maskbyte2, 0xd7);
 			}
 			else
 			{
-				//AcquireCCKAndRWPageAControl(pAdapter);
-				//RT_TRACE(COMP_INIT,DBG_LOUD,("Acquiere mutex in dm_cck_packetdetection\n"));
 				PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0xcd);
-				//ReleaseCCKAndRWPageAControl(pAdapter);
-				//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_cck_packetdetection\n"));
 
-				//PHY_SetBBReg(pAdapter,rCCK0_System, bMaskByte1, 0x47);
-				//if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
-					//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , maskbyte2, 0xd3);
 			}
 			pdmpriv->bChangeCCKPDStateForAnotherMacOfDMSP = false;
 		}
@@ -984,26 +916,12 @@ static void dm_CCK_PacketDetectionThresh
 			{
 				if (dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
 				{
-					//AcquireCCKAndRWPageAControl(pAdapter);
-					//RT_TRACE(COMP_INIT,DBG_LOUD,("Acquiere mutex in dm_cck_packetdetection\n"));
 					PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0x83);
-					//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_cck_packetdetection\n"));
-					//ReleaseCCKAndRWPageAControl(pAdapter);
-					//PHY_SetBBReg(pAdapter, rCCK0_System, bMaskByte1, 0x40);
-					//if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
-						//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , maskbyte2, 0xd7);
 				}
 				else
 				{
-					//AcquireCCKAndRWPageAControl(pAdapter);
-					//RT_TRACE(COMP_INIT,DBG_LOUD,("Acquiere mutex in dm_cck_packetdetection\n"));
 					PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0xcd);
-					///ReleaseCCKAndRWPageAControl(pAdapter);
-					//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_cck_packetdetection\n"));
 
-					//PHY_SetBBReg(pAdapter,rCCK0_System, bMaskByte1, 0x47);
-					//if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
-						//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , maskbyte2, 0xd3);
 				}
 				dm_digtable->precckpdstate = dm_digtable->curcckpdstate;
 			}
@@ -1024,34 +942,17 @@ static void dm_CCK_PacketDetectionThresh
 				DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): mac 0 set for mac0\n");
 				if (dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
 				{
-					//AcquireCCKAndRWPageAControl(pAdapter);
-					//RT_TRACE(COMP_INIT,DBG_LOUD,("Acquiere mutex in dm_cck_packetdetection\n"));
 					PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0x83);
-					//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_cck_packetdetection\n"));
-					//ReleaseCCKAndRWPageAControl(pAdapter);
-					//PHY_SetBBReg(pAdapter, rCCK0_System, bMaskByte1, 0x40);
-					//if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
-						//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , maskbyte2, 0xd7);
 				}
 				else
 				{
-					//AcquireCCKAndRWPageAControl(pAdapter);
-					//RT_TRACE(COMP_INIT,DBG_LOUD,("Acquiere mutex in dm_cck_packetdetection\n"));
 					PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0xcd);
-					//ReleaseCCKAndRWPageAControl(pAdapter);
-					//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_cck_packetdetection\n"));
 
-					//PHY_SetBBReg(pAdapter,rCCK0_System, bMaskByte1, 0x47);
-					//if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
-						//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , maskbyte2, 0xd3);
 				}
 			}
 		}
 		dm_digtable->precckpdstate = dm_digtable->curcckpdstate;
 	}
-	//DBG_8192D("CCKPDStage=%x\n",dm_digtable->curcckpdstate);
-	//DBG_8192D("is92C=%x\n",IS_92C_SERIAL(pHalData->VersionID));
-	//DBG_8192D("is92d single phy =%x\n",IS_92D_SINGLEPHY(pHalData->VersionID));
 #endif
 }
 
@@ -1112,7 +1013,7 @@ static void dm_1R_CCA(struct rtw_adapter
 					dm_pstable->curccastate = CCA_1R;
 			}
 		}
-		else	//disconnect
+		else	/* disconnect */
 		{
 			dm_pstable->curccastate=CCA_MAX;
 		}
@@ -1123,28 +1024,27 @@ static void dm_1R_CCA(struct rtw_adapter
 			{
 				if (pHalData->rf_type == RF_2T2R)
 				{
-					if (pregistrypriv->special_rf_path == 1) // path A only
+					if (pregistrypriv->special_rf_path == 1) /*  path A only */
 						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
-					else if (pregistrypriv->special_rf_path == 2) //path B only
+					else if (pregistrypriv->special_rf_path == 2) /* path B only */
 						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
 					else
 						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x13);
-					//PHY_SetBBReg(pAdapter, 0xe70, bMaskByte3, 0x20);
+					/* PHY_SetBBReg(pAdapter, 0xe70, bMaskByte3, 0x20); */
 				}
 				else
 				{
-					if (pregistrypriv->special_rf_path == 1) // path A only
+					if (pregistrypriv->special_rf_path == 1) /*  path A only */
 						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
-					else if (pregistrypriv->special_rf_path == 2) //path B only
+					else if (pregistrypriv->special_rf_path == 2) /* path B only */
 						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
 					else
 						PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x23);
-					//PHY_SetBBReg(pAdapter, 0xe70, 0x7fc00000, 0x10c); // Set RegE70[30:22] = 9b'100001100
 				}
 			} else if (dm_pstable->curccastate == CCA_2R || dm_pstable->curccastate == CCA_MAX) {
-				if (pregistrypriv->special_rf_path == 1) // path A only
+				if (pregistrypriv->special_rf_path == 1) /*  path A only */
 					PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
-				else if (pregistrypriv->special_rf_path == 2) //path B only
+				else if (pregistrypriv->special_rf_path == 2) /* path B only */
 					PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
 				else
 					PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x33);
@@ -1179,7 +1079,7 @@ static void odm_DynamicTxPower_92D(struc
 	u8		HighPowerLvlBackForMac0 = TxHighPwrLevel_Level1;
 #endif
 
-	// If dynamic high power is disabled.
+	/*  If dynamic high power is disabled. */
 	if ((pdmpriv->bDynamicTxPowerEnable != true) ||
 		(!(pdmpriv->DMFlag & DYNAMIC_FUNC_HP)))
 	{
@@ -1187,57 +1087,50 @@ static void odm_DynamicTxPower_92D(struc
 		return;
 	}
 
-	// STA not connected and AP not connected
+	/*  STA not connected and AP not connected */
 	if ((check_fwstate(pmlmepriv, _FW_LINKED) != true) &&
 		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
 	{
-		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("Not connected to any\n"));
 		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
 
-		//the LastDTPlvl should reset when disconnect,
-		//otherwise the tx power level wouldn't change when disconnect and connect again.
-		// Maddest 20091220.
+		/* the LastDTPlvl should reset when disconnect, */
+		/* otherwise the tx power level wouldn't change when disconnect and connect again. */
+		/*  Maddest 20091220. */
 		pdmpriv->LastDTPLvl=TxHighPwrLevel_Normal;
 		return;
 	}
 
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)	// Default port
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)	/*  Default port */
 	{
-		//todo: AP Mode
+		/* todo: AP Mode */
 		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
 		       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
 		{
 			UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("AP Client PWDB = 0x%x\n", UndecoratedSmoothedPWDB));
 		}
 		else
 		{
 			UndecoratedSmoothedPWDB = pdmpriv->UndecoratedSmoothedPWDB;
-			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("STA Default Port PWDB = 0x%x\n", UndecoratedSmoothedPWDB));
 		}
 	}
-	else // associated entry pwdb
+	else /*  associated entry pwdb */
 	{
 		UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x\n", UndecoratedSmoothedPWDB));
 	}
 
 	if (pHalData->CurrentBandType92D == BAND_ON_5G) {
 		if (UndecoratedSmoothedPWDB >= 0x33)
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
-			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level2 (TxPwr=0x0)\n"));
 		}
 		else if ((UndecoratedSmoothedPWDB <0x33) &&
 			(UndecoratedSmoothedPWDB >= 0x2b))
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
-			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
 		}
 		else if (UndecoratedSmoothedPWDB < 0x2b)
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Normal\n"));
 		}
 	}
 	else
@@ -1245,18 +1138,15 @@ static void odm_DynamicTxPower_92D(struc
 		if (UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
-			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
 		}
 		else if ((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
 			(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1))
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
-			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
 		}
 		else if (UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
-			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Normal\n"));
 		}
 	}
 
@@ -1278,7 +1168,6 @@ static void odm_DynamicTxPower_92D(struc
 
 	if ((pdmpriv->DynamicTxHighPowerLvl != pdmpriv->LastDTPLvl))
 	{
-		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192D() Channel = %d\n" , pHalData->CurrentChannel));
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		if (Adapter->DualMacConcurrent == true)
 		{
@@ -1338,7 +1227,7 @@ static void PWDB_Monitor(
 	int	i;
 	int	tmpEntryMaxPWDB=0, tmpEntryMinPWDB=0xff;
 	u8	sta_cnt=0;
-	u32	PWDB_rssi[NUM_STA]={0};//[0~15]:MACID, [16~31]:PWDB_rssi
+	u32	PWDB_rssi[NUM_STA]={0};/* 0~15]:MACID, [16~31]:PWDB_rssi */
 
 
 	if (check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
@@ -1383,7 +1272,7 @@ static void PWDB_Monitor(
 
 		if (pHalData->fw_ractrl == true)
 		{
-			// Report every sta's RSSI to FW
+			/*  Report every sta's RSSI to FW */
 			for (i=0; i< sta_cnt; i++)
 			{
 				FillH2CCmd92D(Adapter, H2C_RSSI_REPORT, 3, (u8 *)(&PWDB_rssi[i]));
@@ -1392,7 +1281,7 @@ static void PWDB_Monitor(
 	}
 
 
-	if (tmpEntryMaxPWDB != 0)	// If associated entry is found
+	if (tmpEntryMaxPWDB != 0)	/*  If associated entry is found */
 	{
 		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;
 	}
@@ -1401,7 +1290,7 @@ static void PWDB_Monitor(
 		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = 0;
 	}
 
-	if (tmpEntryMinPWDB != 0xff) // If associated entry is found
+	if (tmpEntryMinPWDB != 0xff) /*  If associated entry is found */
 	{
 		pdmpriv->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;
 	}
@@ -1413,22 +1302,20 @@ static void PWDB_Monitor(
 	if (check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == true
 		&& check_fwstate(&Adapter->mlmepriv, _FW_LINKED) == true)
 	{
-		// Indicate Rx signal strength to FW.
+		/*  Indicate Rx signal strength to FW. */
 		if (pHalData->fw_ractrl == true)
 		{
 			u32	temp = 0;
-			//DBG_8192D("RxSS: %lx =%ld\n", pdmpriv->UndecoratedSmoothedPWDB, pdmpriv->UndecoratedSmoothedPWDB);
 
 			temp = pdmpriv->UndecoratedSmoothedPWDB;
 			temp = temp << 16;
-			//temp = temp | 0x800000;
 
-			// fw v12 cmdid 5:use max macid ,for nic ,default macid is 0 ,max macid is 1
+			/*  fw v12 cmdid 5:use max macid ,for nic ,default macid is 0 ,max macid is 1 */
 
-			// Commented by Kurt 20120705
-			// We could set max mac_id to FW without checking how many STAs we allocated
-			// It's recommanded by SD3
-			// Original: temp = temp | ((Adapter->stapriv.asoc_sta_count+1) << 8);
+			/*  Commented by Kurt 20120705 */
+			/*  We could set max mac_id to FW without checking how many STAs we allocated */
+			/*  It's recommanded by SD3 */
+			/*  Original: temp = temp | ((Adapter->stapriv.asoc_sta_count+1) << 8); */
 			temp = temp | ((32) << 8);
 
 			FillH2CCmd92D(Adapter, H2C_RSSI_REPORT, 3, (u8 *)(&temp));
@@ -1436,7 +1323,6 @@ static void PWDB_Monitor(
 		else
 		{
 			rtw_write8(Adapter, 0x4fe, (u8)pdmpriv->UndecoratedSmoothedPWDB);
-			//DBG_8192D("0x4fe write %x %d\n", pdmpriv->UndecoratedSmoothedPWDB, pdmpriv->UndecoratedSmoothedPWDB);
 		}
 	}
 }
@@ -1450,7 +1336,7 @@ DM_InitEdcaTurbo(
 
 	pHalData->bCurrentTurboEDCA = false;
 	Adapter->recvpriv.bIsAnyNonBEPkts = false;
-}	// DM_InitEdcaTurbo
+}	/*  DM_InitEdcaTurbo */
 
 static void dm_CheckEdcaTurbo(struct rtw_adapter *Adapter)
 {
@@ -1489,32 +1375,32 @@ static void dm_CheckEdcaTurbo(struct rtw
 		goto dm_CheckEdcaTurbo_EXIT;
 	}
 
-	// Check if the status needs to be changed.
+	/*  Check if the status needs to be changed. */
 	if ((bbtchange) || (!precvpriv->bIsAnyNonBEPkts))
 	{
 		cur_tx_bytes = pxmitpriv->tx_bytes - pxmitpriv->last_tx_bytes;
 		cur_rx_bytes = precvpriv->rx_bytes - precvpriv->last_rx_bytes;
 
-		//traffic, TX or RX
+		/* traffic, TX or RX */
 		if ((pmlmeinfo->assoc_AP_vendor == ralinkAP)||(pmlmeinfo->assoc_AP_vendor == atherosAP))
 		{
 			if (cur_tx_bytes > (cur_rx_bytes << 2))
-			{ // Uplink TP is present.
+			{ /*  Uplink TP is present. */
 				trafficIndex = UP_LINK;
 			}
 			else
-			{ // Balance TP is present.
+			{ /*  Balance TP is present. */
 				trafficIndex = DOWN_LINK;
 			}
 		}
 		else
 		{
 			if (cur_rx_bytes > (cur_tx_bytes << 2))
-			{ // Downlink TP is present.
+			{ /*  Downlink TP is present. */
 				trafficIndex = DOWN_LINK;
 			}
 			else
-			{ // Balance TP is present.
+			{ /*  Balance TP is present. */
 				trafficIndex = UP_LINK;
 			}
 		}
@@ -1557,10 +1443,10 @@ static void dm_CheckEdcaTurbo(struct rtw
 	}
 	else
 	{
-		//
-		// Turn Off EDCA turbo here.
-		// Restore original EDCA according to the declaration of AP.
-		//
+		/*  */
+		/*  Turn Off EDCA turbo here. */
+		/*  Restore original EDCA according to the declaration of AP. */
+		/*  */
 		 if (pHalData->bCurrentTurboEDCA)
 		{
 			rtw_write32(Adapter, REG_EDCA_BE_PARAM, pHalData->AcParam_BE);
@@ -1569,11 +1455,11 @@ static void dm_CheckEdcaTurbo(struct rtw
 	}
 
 dm_CheckEdcaTurbo_EXIT:
-	// Set variables for next time.
+	/*  Set variables for next time. */
 	precvpriv->bIsAnyNonBEPkts = false;
 	pxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;
 	precvpriv->last_rx_bytes = precvpriv->rx_bytes;
-}	// dm_CheckEdcaTurbo
+}	/*  dm_CheckEdcaTurbo */
 
 static void dm_InitDynamicBBPowerSaving(
 	struct rtw_adapter *	Adapter
@@ -1596,7 +1482,7 @@ struct rtw_adapter *	pAdapter
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 
-	//1 Power Saving for 92C
+	/* 1 Power Saving for 92C */
 	if (IS_92D_SINGLEPHY(pHalData->VersionID))
 	{
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -1611,9 +1497,9 @@ dm_RXGainTrackingCallback_ThermalMeter_9
 	struct rtw_adapter *	Adapter)
 {
 	u8			index_mapping[Rx_index_mapping_NUM] = {
-						0x0f,	0x0f,	0x0f,	0x0f,	0x0b,
-						0x0a,	0x09,	0x08,	0x07,	0x06,
-						0x05,	0x04,	0x04,	0x03,	0x02
+						0x0f, 0x0f, 0x0f, 0x0f, 0x0b,
+						0x0a, 0x09, 0x08, 0x07, 0x06,
+						0x05, 0x04, 0x04, 0x03, 0x02
 					};
 
 	u8			eRFPath;
@@ -1623,69 +1509,63 @@ dm_RXGainTrackingCallback_ThermalMeter_9
 
 	u4tmp = (index_mapping[(pHalData->EEPROMThermalMeter - pdmpriv->ThermalValue_RxGain)]) << 12;
 
-	//DBG_8192D("===>dm_RXGainTrackingCallback_ThermalMeter_92D interface %d  Rx Gain %x\n", pHalData->interfaceIndex, u4tmp);
-
 	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++) {
 		PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_RXRF_A3, bRFRegOffsetMask, (pdmpriv->RegRF3C[eRFPath]&(~(0xF000)))|u4tmp);
 	}
 };
 
-//091212 chiyokolin
+/* 091212 chiyokolin */
 static	void
 dm_TXPowerTrackingCallback_ThermalMeter_92D(
             struct rtw_adapter *	Adapter)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	u8			ThermalValue = 0, delta, delta_LCK, delta_IQK, delta_RxGain, index, offset;
-	u8			ThermalValue_AVG_count = 0;
-	u32			ThermalValue_AVG = 0;
-	s32			ele_A = 0, ele_D, TempCCk, X, value32;
-	s32			Y, ele_C;
-	s8			OFDM_index[2], CCK_index=0, OFDM_index_old[2], CCK_index_old=0;
-	s32			i = 0;
+	u8		ThermalValue = 0, delta, delta_LCK, delta_IQK, delta_RxGain, index, offset;
+	u8		ThermalValue_AVG_count = 0;
+	u32		ThermalValue_AVG = 0;
+	s32		ele_A = 0, ele_D, TempCCk, X, value32;
+	s32		Y, ele_C;
+	s8		OFDM_index[2], CCK_index=0, OFDM_index_old[2], CCK_index_old=0;
+	s32		i = 0;
 	bool		is2T = IS_92D_SINGLEPHY(pHalData->VersionID);
 	bool		bInteralPA = false;
 
-	u8			OFDM_min_index = 6, OFDM_min_index_internalPA = 12, rf; //OFDM BB Swing should be less than +3.0dB, which is required by Arthur
-	u8			Indexforchannel = rtl8192d_GetRightChnlPlaceforIQK(pHalData->CurrentChannel);
-	u8			index_mapping[5][index_mapping_NUM] = {
-					{0,	1,	3,	6,	8,	9,				//5G, path A/MAC 0, decrease power
-					11,	13,	14,	16,	17,	18, 18},
-					{0,	2,	4,	5,	7,	10,				//5G, path A/MAC 0, increase power
-					12,	14,	16,	18,	18,	18,	18},
-					{0,	2,	3,	6,	8,	9,				//5G, path B/MAC 1, decrease power
-					11,	13,	14,	16,	17,	18,	18},
-					{0,	2,	4,	5,	7,	10,				//5G, path B/MAC 1, increase power
-					13,	16,	16,	18,	18,	18,	18},
-					{0,	1,	2,	3,	4,	5,				//2.4G, for decreas power
-					6,	7,	7,	8,	9,	10,	10},
-					};
-
-	u8			index_mapping_internalPA[8][index_mapping_NUM] = {
-					{0,	1,	2,	4,	6,	7,				//5G, path A/MAC 0, ch36-64, decrease power
-					9,	11,	12,	14,	15,	16,	16},
-					{0,	2,	4,	5,	7,	10,				//5G, path A/MAC 0, ch36-64, increase power
-					12,	14,	16,	18,	18,	18,	18},
-					{0,	1,	2,	3,	5,	6,				//5G, path A/MAC 0, ch100-165, decrease power
-					8,	10,	11,	13,	14,	15,	15},
-					{0,	2,	4,	5,	7,	10,				//5G, path A/MAC 0, ch100-165, increase power
-					12,	14,	16,	18,	18,	18,	18},
-					{0,	1,	2,	4,	6,	7,				//5G, path B/MAC 1, ch36-64, decrease power
-					9,	11,	12,	14,	15,	16,	16},
-					{0,	2,	4,	5,	7,	10,				//5G, path B/MAC 1, ch36-64, increase power
-					13,	16,	16,	18,	18,	18,	18},
-					{0,	1,	2,	3,	5,	6,				//5G, path B/MAC 1, ch100-165, decrease power
-					8,	9,	10,	12,	13,	14,	14},
-					{0,	2,	4,	5,	7,	10,				//5G, path B/MAC 1, ch100-165, increase power
-					13,	16,	16,	18,	18,	18,	18},
-				};
-
-//#if MP_DRIVER != 1
-//	return;
-//#endif
+	u8		OFDM_min_index = 6, OFDM_min_index_internalPA = 12, rf; /* OFDM BB Swing should be less than +3.0dB, which is required by Arthur */
+	u8		Indexforchannel = rtl8192d_GetRightChnlPlaceforIQK(pHalData->CurrentChannel);
+	u8 index_mapping[5][index_mapping_NUM] = {
+		{0, 1, 3, 6, 8, 9, 			/* 5G, path A/MAC 0, decrease power */
+		11, 13, 14, 16, 17, 18, 18},
+		{0, 2, 4, 5, 7, 10, 			/* 5G, path A/MAC 0, increase power */
+		12, 14, 16, 18, 18, 18, 18},
+		{0, 2, 3, 6, 8, 9, 			/* 5G, path B/MAC 1, decrease power */
+		11, 13, 14, 16, 17, 18, 18},
+		{0, 2, 4, 5, 7, 10, 			/* 5G, path B/MAC 1, increase power */
+		13, 16, 16, 18, 18, 18, 18},
+		{0, 1, 2, 3, 4, 5, 			/* 2.4G, for decreas power */
+		6, 7, 7, 8, 9, 10, 10},
+	};
+
+	u8 index_mapping_internalPA[8][index_mapping_NUM] = {
+		{0, 1, 2, 4, 6, 7, 			/* 5G, path A/MAC 0, ch36-64, decrease power */
+		9, 11, 12, 14, 15, 16, 16},
+		{0, 2, 4, 5, 7, 10, 			/* 5G, path A/MAC 0, ch36-64, increase power */
+		12, 14, 16, 18, 18, 18, 18},
+		{0, 1, 2, 3, 5, 6, 			/* 5G, path A/MAC 0, ch100-165, decrease power */
+		8, 10, 11, 13, 14, 15, 15},
+		{0, 2, 4, 5, 7, 10, 			/* 5G, path A/MAC 0, ch100-165, increase power */
+		12, 14, 16, 18, 18, 18, 18},
+		{0, 1, 2, 4, 6, 7, 			/* 5G, path B/MAC 1, ch36-64, decrease power */
+		9, 11, 12, 14, 15, 16, 16},
+		{0, 2, 4, 5, 7, 10, 			/* 5G, path B/MAC 1, ch36-64, increase power */
+		13, 16, 16, 18, 18, 18, 18},
+		{0, 1, 2, 3, 5, 6, 			/* 5G, path B/MAC 1, ch100-165, decrease power */
+		8, 9, 10, 12, 13, 14, 14},
+		{0, 2, 4, 5, 7, 10, 			/* 5G, path B/MAC 1, ch100-165, increase power */
+		13, 16, 16, 18, 18, 18, 18},
+	};
 
-	pdmpriv->TXPowerTrackingCallbackCnt++;	//cosa add for debug
+	pdmpriv->TXPowerTrackingCallbackCnt++;	/* cosa add for debug */
 	pdmpriv->bTXPowerTrackingInit = true;
 
 	if (pHalData->CurrentChannel == 14 && !pdmpriv->bCCKinCH14)
@@ -1693,16 +1573,11 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 	else if (pHalData->CurrentChannel != 14 && pdmpriv->bCCKinCH14)
 		pdmpriv->bCCKinCH14 = false;
 
-	//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("===>dm_TXPowerTrackingCallback_ThermalMeter_92D interface %d txpowercontrol %d\n", pHalData->interfaceIndex, pdmpriv->TxPowerTrackControl));
-
-	ThermalValue = (u8)PHY_QueryRFReg(Adapter, RF_PATH_A, RF_T_METER, 0xf800);	//0x42: RF Reg[15:11] 92D
 
-	//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Readback Thermal Meter = 0x%lx pre thermal meter 0x%lx EEPROMthermalmeter 0x%lx\n", ThermalValue, pHalData->ThermalValue, pHalData->EEPROMThermalMeter));
+	ThermalValue = (u8)PHY_QueryRFReg(Adapter, RF_PATH_A, RF_T_METER, 0xf800);	/* 0x42: RF Reg[15:11] 92D */
 
-	rtl8192d_PHY_APCalibrate(Adapter, (ThermalValue - pHalData->EEPROMThermalMeter));//notes:EEPROMThermalMeter is a fixed value from efuse/eeprom
 
-//	if (!pHalData->TxPowerTrackControl)
-//		return;
+	rtl8192d_PHY_APCalibrate(Adapter, (ThermalValue - pHalData->EEPROMThermalMeter));/* notes:EEPROMThermalMeter is a fixed value from efuse/eeprom */
 
 	if (is2T)
 		rf = 2;
@@ -1711,32 +1586,27 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 
 	if (ThermalValue)
 	{
-//		if (!pHalData->ThermalValue)
 		{
-			//Query OFDM path A default setting
+			/* Query OFDM path A default setting */
 			ele_D = PHY_QueryBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord)&bMaskOFDM_D;
-			for (i=0; i<OFDM_TABLE_SIZE_92D; i++)	//find the index
+			for (i=0; i<OFDM_TABLE_SIZE_92D; i++)	/* find the index */
 			{
 				if (ele_D == (OFDMSwingTable[i]&bMaskOFDM_D))
 				{
 					OFDM_index_old[0] = (u8)i;
-					//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Initial pathA ele_D reg0x%x = 0x%lx, OFDM_index=0x%x\n",
-					//	rOFDM0_XATxIQImbalance, ele_D, OFDM_index_old[0]));
 					break;
 				}
 			}
 
-			//Query OFDM path B default setting
+			/* Query OFDM path B default setting */
 			if (is2T)
 			{
 				ele_D = PHY_QueryBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord)&bMaskOFDM_D;
-				for (i=0; i<OFDM_TABLE_SIZE_92D; i++)	//find the index
+				for (i=0; i<OFDM_TABLE_SIZE_92D; i++)	/* find the index */
 				{
 					if (ele_D == (OFDMSwingTable[i]&bMaskOFDM_D))
 					{
 						OFDM_index_old[1] = (u8)i;
-						//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Initial pathB ele_D reg0x%x = 0x%lx, OFDM_index=0x%x\n",
-						//	rOFDM0_XBTxIQImbalance, ele_D, OFDM_index_old[1]));
 						break;
 					}
 				}
@@ -1744,7 +1614,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 
 			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 			{
-				//Query CCK default setting From 0xa24
+				/* Query CCK default setting From 0xa24 */
 				TempCCk = pdmpriv->RegA24;
 
 				for (i=0 ; i<CCK_TABLE_SIZE ; i++)
@@ -1754,8 +1624,6 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 						if (_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch14[i][2], 4)==true)
 						{
 							CCK_index_old =(u8)i;
-							//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Initial reg0x%x = 0x%lx, CCK_index=0x%x, ch 14 %d\n",
-							//	rCCK0_TxFilter2, TempCCk, CCK_index_old, pdmpriv->bCCKinCH14));
 							break;
 						}
 					}
@@ -1764,8 +1632,6 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 						if (_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch1_Ch13[i][2], 4)==true)
 						{
 							CCK_index_old =(u8)i;
-							//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Initial reg0x%x = 0x%lx, CCK_index=0x%x, ch14 %d\n",
-							//	rCCK0_TxFilter2, TempCCk, CCK_index_old, pdmpriv->bCCKinCH14));
 							break;
 						}
 					}
@@ -1794,7 +1660,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 				DBG_8192D("reload ofdm index for band switch\n");
 			}
 
-			//calculate average thermal meter
+			/* calculate average thermal meter */
 			{
 				pdmpriv->ThermalValue_AVG[pdmpriv->ThermalValue_AVG_index] = ThermalValue;
 				pdmpriv->ThermalValue_AVG_index++;
@@ -1833,9 +1699,6 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 		delta_IQK = (ThermalValue > pdmpriv->ThermalValue_IQK)?(ThermalValue - pdmpriv->ThermalValue_IQK):(pdmpriv->ThermalValue_IQK - ThermalValue);
 		delta_RxGain = (ThermalValue > pdmpriv->ThermalValue_RxGain)?(ThermalValue - pdmpriv->ThermalValue_RxGain):(pdmpriv->ThermalValue_RxGain - ThermalValue);
 
-		//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("interface %d Readback Thermal Meter = 0x%lx pre thermal meter 0x%lx EEPROMthermalmeter 0x%lx delta 0x%lx delta_LCK 0x%lx delta_IQK 0x%lx delta_RxGain 0x%lx\n",  pHalData->interfaceIndex, ThermalValue, pdmpriv->ThermalValue, pHalData->EEPROMThermalMeter, delta, delta_LCK, delta_IQK, delta_RxGain));
-		//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("interface %d pre thermal meter LCK 0x%lx pre thermal meter IQK 0x%lx delta_LCK_bound 0x%lx delta_IQK_bound 0x%lx\n",  pHalData->interfaceIndex, pdmpriv->ThermalValue_LCK, pdmpriv->ThermalValue_IQK, pdmpriv->Delta_LCK, pdmpriv->Delta_IQK));
-
 		if ((delta_LCK > pdmpriv->Delta_LCK) && (pdmpriv->Delta_LCK != 0))
 		{
 			pdmpriv->ThermalValue_LCK = ThermalValue;
@@ -1846,7 +1709,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 		{
 			delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);
 
-			//calculate new OFDM / CCK offset
+			/* calculate new OFDM / CCK offset */
 			{
 				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 				{
@@ -1875,7 +1738,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 					for (i = 0; i < rf; i++)
 					{
 						if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY &&
-							pHalData->interfaceIndex == 1)		//MAC 1 5G
+							pHalData->interfaceIndex == 1)		/* MAC 1 5G */
 							bInteralPA = pHalData->InternalPA5G[1];
 						else
 							bInteralPA = pHalData->InternalPA5G[i];
@@ -1898,7 +1761,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 								offset = 0;
 						}
 
-						if (ThermalValue > pHalData->EEPROMThermalMeter)	//set larger Tx power
+						if (ThermalValue > pHalData->EEPROMThermalMeter)	/* set larger Tx power */
 							offset++;
 
 						if (bInteralPA)
@@ -1916,7 +1779,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 								index = index_mapping[offset][delta];
 						}
 
-						if (ThermalValue > pHalData->EEPROMThermalMeter)	//set larger Tx power
+						if (ThermalValue > pHalData->EEPROMThermalMeter)	/* set larger Tx power */
 						{
 							if (bInteralPA && ThermalValue > 0x12)
 							{
@@ -1982,15 +1845,13 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 				}*/
 			}
 
-			//Config by SwingTable
+			/* Config by SwingTable */
 			if (pdmpriv->TxPowerTrackControl && !pHalData->bNOPG)
 			{
 				pdmpriv->bDoneTxpower = true;
 
-				//Adujst OFDM Ant_A according to IQK result
+				/* Adujst OFDM Ant_A according to IQK result */
 				ele_D = (OFDMSwingTable[(u8)OFDM_index[0]] & 0xFFC00000)>>22;
-				//X = pdmpriv->RegE94;
-				//Y = pdmpriv->RegE9C;
 				X = pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][0];
 				Y = pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][1];
 
@@ -2000,12 +1861,12 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 						X = X | 0xFFFFFC00;
 					ele_A = ((X * ele_D)>>8)&0x000003FF;
 
-					//new element C = element D x Y
+					/* new element C = element D x Y */
 					if ((Y & 0x00000200) != 0)
 						Y = Y | 0xFFFFFC00;
 					ele_C = ((Y * ele_D)>>8)&0x000003FF;
 
-					//wirte new elements A, C, D to regC80 and regC94, element B is always 0
+					/* wirte new elements A, C, D to regC80 and regC94, element B is always 0 */
 					value32 = (ele_D<<22)|((ele_C&0x3F)<<16)|ele_A;
 					PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, value32);
 
@@ -2023,11 +1884,9 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 					PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT24, 0x00);
 				}
 
-				//DBG_8192D("TxPwrTracking for interface %d path A: X = 0x%x, Y = 0x%x ele_A = 0x%x ele_C = 0x%x ele_D = 0x%x 0xe94 = 0x%x 0xe9c = 0x%x\n", Adapter->interfaceIndex, X, Y, ele_A, ele_C, ele_D, X, Y);
-
 				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 				{
-					//Adjust CCK according to IQK result
+					/* Adjust CCK according to IQK result */
 					if (!pdmpriv->bCCKinCH14) {
 						rtw_write8(Adapter, 0xa22, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][0]);
 						rtw_write8(Adapter, 0xa23, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][1]);
@@ -2054,24 +1913,22 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 				{
 					ele_D = (OFDMSwingTable[(u8)OFDM_index[1]] & 0xFFC00000)>>22;
 
-					//new element A = element D x X
-					//X = pdmpriv->RegEB4;
-					//Y = pdmpriv->RegEBC;
+					/* new element A = element D x X */
 					X = pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][4];
 					Y = pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][5];
 
 					if (X != 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G)
 					{
-						if ((X & 0x00000200) != 0)	//consider minus
+						if ((X & 0x00000200) != 0)	/* consider minus */
 							X = X | 0xFFFFFC00;
 						ele_A = ((X * ele_D)>>8)&0x000003FF;
 
-						//new element C = element D x Y
+						/* new element C = element D x Y */
 						if ((Y & 0x00000200) != 0)
 							Y = Y | 0xFFFFFC00;
 						ele_C = ((Y * ele_D)>>8)&0x00003FF;
 
-						//wirte new elements A, C, D to regC88 and regC9C, element B is always 0
+						/* wirte new elements A, C, D to regC88 and regC9C, element B is always 0 */
 						value32=(ele_D<<22)|((ele_C&0x3F)<<16) |ele_A;
 						PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, value32);
 
@@ -2089,10 +1946,8 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 						PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT28, 0x00);
 					}
 
-					//DBG_8192D("TxPwrTracking path B: X = 0x%x, Y = 0x%x ele_A = 0x%x ele_C = 0x%x ele_D = 0x%x 0xeb4 = 0x%x 0xebc = 0x%x\n", X, Y, ele_A, ele_C, ele_D, X, Y);
 				}
 
-				//DBG_8192D("TxPwrTracking 0xc80 = 0x%x, 0xc94 = 0x%x RF 0x24 = 0x%x\n", PHY_QueryBBReg(Adapter, 0xc80, bMaskDWord), PHY_QueryBBReg(Adapter, 0xc94, bMaskDWord), PHY_QueryRFReg(Adapter, RF_PATH_A, 0x24, bRFRegOffsetMask));
 			}
 		}
 
@@ -2115,7 +1970,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 			dm_RXGainTrackingCallback_ThermalMeter_92D(Adapter);
 		}
 
-		//update thermal meter value
+		/* update thermal meter value */
 		if (pdmpriv->TxPowerTrackControl)
 		{
 			pdmpriv->ThermalValue = ThermalValue;
@@ -2123,7 +1978,6 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 
 	}
 
-	//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("<===dm_TXPowerTrackingCallback_ThermalMeter_92D\n"));
 
 	pdmpriv->TXPowercount = 0;
 }
@@ -2136,12 +1990,11 @@ dm_InitializeTXPowerTracking_ThermalMete
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
-	//if (IS_HARDWARE_TYPE_8192C(pHalData))
 	{
 		pdmpriv->bTXPowerTracking = true;
 		pdmpriv->TXPowercount = 0;
 		pdmpriv->bTXPowerTrackingInit = false;
-#if	(MP_DRIVER != 1)		//for mp driver, turn off txpwrtracking as default
+#if	(MP_DRIVER != 1)		/* for mp driver, turn off txpwrtracking as default */
 		pdmpriv->TxPowerTrackControl = true;
 #endif
 	}
@@ -2153,25 +2006,23 @@ static void
 DM_InitializeTXPowerTracking(
 	struct rtw_adapter *		Adapter)
 {
-	//struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
-	//if (IS_HARDWARE_TYPE_8192C(pHalData))
 	{
 		dm_InitializeTXPowerTracking_ThermalMeter(Adapter);
 	}
 }
 
-//
-//	Description:
-//		- Dispatch TxPower Tracking direct call ONLY for 92s.
-//		- We shall NOT schedule Workitem within PASSIVE LEVEL, which will cause system resource
-//		   leakage under some platform.
-//
-//	Assumption:
-//		PASSIVE_LEVEL when this routine is called.
-//
-//	Added by Roger, 2009.06.18.
-//
+/*  */
+/* 	Description: */
+/* 		- Dispatch TxPower Tracking direct call ONLY for 92s. */
+/* 		- We shall NOT schedule Workitem within PASSIVE LEVEL, which will cause system resource */
+/* 		   leakage under some platform. */
+/*  */
+/* 	Assumption: */
+/* 		PASSIVE_LEVEL when this routine is called. */
+/*  */
+/* 	Added by Roger, 2009.06.18. */
+/*  */
 static void
 DM_TXPowerTracking92CDirectCall(
             struct rtw_adapter *		Adapter)
@@ -2185,7 +2036,6 @@ dm_CheckTXPowerTracking_ThermalMeter(
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	//u1Byte TxPowerCheckCnt = 5;	//10 sec
 
 	if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_SS))
 	{
@@ -2197,19 +2047,16 @@ dm_CheckTXPowerTracking_ThermalMeter(
 		return;
 	}
 
-	if (!pdmpriv->TM_Trigger)		//at least delay 1 sec
+	if (!pdmpriv->TM_Trigger)		/* at least delay 1 sec */
 	{
-		//pHalData->TxPowerCheckCnt++;	//cosa add for debug
 
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_T_METER, BIT17 | BIT16, 0x03);
-		//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Trigger 92C Thermal Meter!!\n"));
 		pdmpriv->TM_Trigger = 1;
 		return;
 	}
 	else
 	{
-		//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("Schedule TxPowerTracking direct call!!\n"));
-		DM_TXPowerTracking92CDirectCall(Adapter); //Using direct call is instead, added by Roger, 2009.06.18.
+		DM_TXPowerTracking92CDirectCall(Adapter); /* Using direct call is instead, added by Roger, 2009.06.18. */
 		pdmpriv->TM_Trigger = 0;
 	}
 }
@@ -2219,7 +2066,6 @@ void
 rtl8192d_dm_CheckTXPowerTracking(
 	struct rtw_adapter *		Adapter)
 {
-	//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("dm_CheckTXPowerTracking!!\n"));
 
 #if DISABLE_BB_RF
 	return;
@@ -2281,14 +2127,14 @@ static void	dm_CheckPbcGPIO(struct rtw_a
 		i++;
 	tmp1byte = rtw_read8(padapter, GPIO_IO_SEL);
 	tmp1byte |= (HAL_8192C_HW_GPIO_WPS_BIT);
-	rtw_write8(padapter, GPIO_IO_SEL, tmp1byte);	//enable GPIO[2] as output mode
+	rtw_write8(padapter, GPIO_IO_SEL, tmp1byte);	/* enable GPIO[2] as output mode */
 
 	tmp1byte &= ~(HAL_8192C_HW_GPIO_WPS_BIT);
-	rtw_write8(padapter,  GPIO_IN, tmp1byte);		//reset the floating voltage level
+	rtw_write8(padapter,  GPIO_IN, tmp1byte);		/* reset the floating voltage level */
 
 	tmp1byte = rtw_read8(padapter, GPIO_IO_SEL);
 	tmp1byte &= ~(HAL_8192C_HW_GPIO_WPS_BIT);
-	rtw_write8(padapter, GPIO_IO_SEL, tmp1byte);	//enable GPIO[2] as input mode
+	rtw_write8(padapter, GPIO_IO_SEL, tmp1byte);	/* enable GPIO[2] as input mode */
 
 	tmp1byte =rtw_read8(padapter, GPIO_IN);
 
@@ -2309,13 +2155,13 @@ static void	dm_CheckPbcGPIO(struct rtw_a
 
 	if (true == bPbcPressed)
 	{
-		// Here we only set bPbcPressed to true
-		// After trigger PBC, the variable will be set to false
+		/*  Here we only set bPbcPressed to true */
+		/*  After trigger PBC, the variable will be set to false */
 		DBG_8192D("CheckPbcGPIO - PBC is pressed, try_cnt=%d\n", i-1);
 
 
 		if (padapter->pid[0] == 0)
-		{	//	0 is the default value and it means the application monitors the HW PBC doesn't privde its pid to driver.
+		{	/* 	0 is the default value and it means the application monitors the HW PBC doesn't privde its pid to driver. */
 			return;
 		}
 
@@ -2373,9 +2219,9 @@ dm_CheckStatistics(
 {
 }
 
-//
-// Initialize GPIO setting registers
-//
+/*  */
+/*  Initialize GPIO setting registers */
+/*  */
 static void
 dm_InitGPIOSetting(
 	struct rtw_adapter *	Adapter
@@ -2388,21 +2234,15 @@ dm_InitGPIOSetting(
 	rtw_write8(Adapter, REG_GPIO_MUXCFG, tmp1byte);
 }
 
-//============================================================
-// functions
-//============================================================
+/*  */
+/*  functions */
+/*  */
 void rtl8192d_init_dm_priv(struct rtw_adapter * Adapter)
 {
-	//struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	//struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-
-	//memset(pdmpriv, 0, sizeof(struct dm_priv));
 }
 
 void rtl8192d_deinit_dm_priv(struct rtw_adapter * Adapter)
 {
-	//struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	//struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 }
 
 void
@@ -2417,24 +2257,23 @@ rtl8192d_InitHalDm(
 	pdmpriv->DM_Type = DM_Type_ByDriver;
 	pdmpriv->DMFlag = DYNAMIC_FUNC_DISABLE;
 	pdmpriv->UndecoratedSmoothedPWDB = 0;
-	//pdmpriv->UndecoratedSmoothedCCK = (-1);
 
-	//.1 DIG INIT
+	/* 1 DIG INIT */
 	pdmpriv->bDMInitialGainEnable = true;
 	pdmpriv->DMFlag |= DYNAMIC_FUNC_DIG;
 	dm_DIGInit(Adapter);
 
-	//.2 DynamicTxPower INIT
+	/* 2 DynamicTxPower INIT */
 	pdmpriv->DMFlag |= DYNAMIC_FUNC_HP;
 	dm_InitDynamicTxPower(Adapter);
 
-	//.3
-	DM_InitEdcaTurbo(Adapter);//moved to  linked_status_chk()
+	/* 3 */
+	DM_InitEdcaTurbo(Adapter);/* moved to  linked_status_chk() */
 
-	//.4 RateAdaptive INIT
+	/* 4 RateAdaptive INIT */
 	dm_InitRateAdaptiveMask(Adapter);
 
-	//.5 Tx Power Tracking Init.
+	/* 5 Tx Power Tracking Init. */
 	pdmpriv->DMFlag |= DYNAMIC_FUNC_SS;
 	DM_InitializeTXPowerTracking(Adapter);
 
@@ -2444,7 +2283,7 @@ rtl8192d_InitHalDm(
 
 	pdmpriv->DMFlag_tmp = pdmpriv->DMFlag;
 
-	// Save REG_INIDATA_RATE_SEL value for TXDESC.
+	/*  Save REG_INIDATA_RATE_SEL value for TXDESC. */
 	for (i = 0 ; i<32 ; i++)
 	{
 		pdmpriv->INIDATA_RATE[i] = rtw_read8(Adapter, REG_INIDATA_RATE_SEL+i) & 0x3f;
@@ -2467,7 +2306,7 @@ static void FindMinimumRSSI(struct rtw_a
 	pbuddy_HalData = GET_HAL_DATA(pbuddy_adapter);
 	pbuddy_dmpriv = &pbuddy_HalData->dmpriv;
 
-	//get min. [PWDB] when both interfaces are connected
+	/* get min. [PWDB] when both interfaces are connected */
 	if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
 		&& Adapter->stapriv.asoc_sta_count > 2
 		&& check_buddy_fwstate(Adapter, _FW_LINKED)) ||
@@ -2479,49 +2318,49 @@ static void FindMinimumRSSI(struct rtw_a
 		&& check_buddy_fwstate(Adapter,WIFI_STATION_STATE)
 		&& check_buddy_fwstate(Adapter,_FW_LINKED)))
 	{
-		//select smaller PWDB
+		/* select smaller PWDB */
 		if (pdmpriv->UndecoratedSmoothedPWDB > pbuddy_dmpriv->UndecoratedSmoothedPWDB)
 			pdmpriv->UndecoratedSmoothedPWDB = pbuddy_dmpriv->UndecoratedSmoothedPWDB;
-	}//secondary interface is connected
+	}/* secondary interface is connected */
 	else if ((check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true
 		&& pbuddy_adapter->stapriv.asoc_sta_count > 2) ||
 		(check_buddy_fwstate(Adapter,WIFI_STATION_STATE)
 		&& check_buddy_fwstate(Adapter,_FW_LINKED)))
 	{
-		//select buddy PWDB
+		/* select buddy PWDB */
 		pdmpriv->UndecoratedSmoothedPWDB = pbuddy_dmpriv->UndecoratedSmoothedPWDB;
 	}
-	//primary is connected
+	/* primary is connected */
 	else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
 		&& Adapter->stapriv.asoc_sta_count > 2) ||
 		(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
 		&& check_fwstate(pmlmepriv, _FW_LINKED)))
 	{
-		//set buddy PWDB to 0
+		/* set buddy PWDB to 0 */
 		pbuddy_dmpriv->UndecoratedSmoothedPWDB = 0;
 	}
-	//both interfaces are not connected
+	/* both interfaces are not connected */
 	else
 	{
 		pdmpriv->UndecoratedSmoothedPWDB = 0;
 		pbuddy_dmpriv->UndecoratedSmoothedPWDB = 0;
 	}
 
-	//primary interface is ap mode
+	/* primary interface is ap mode */
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true && Adapter->stapriv.asoc_sta_count > 2)
 	{
 		pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
-	}//secondary interface is ap mode
+	}/* secondary interface is ap mode */
 	else if (check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true && pbuddy_adapter->stapriv.asoc_sta_count > 2)
 	{
 		pdmpriv->EntryMinUndecoratedSmoothedPWDB = pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB;
 	}
-	else //both interfaces are not ap mode
+	else /* both interfaces are not ap mode */
 	{
 		pdmpriv->EntryMinUndecoratedSmoothedPWDB = pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
 	}
 }
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 void
 rtl8192d_HalDmWatchDog(
@@ -2535,7 +2374,7 @@ rtl8192d_HalDmWatchDog(
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter * pbuddy_adapter = Adapter->pbuddy_adapter;
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if ((pHalData->bInModeSwitchProcess))
@@ -2571,43 +2410,42 @@ rtl8192d_HalDmWatchDog(
 #endif
 
 #ifdef CONFIG_P2P_PS
-	// Fw is under p2p powersaving mode, driver should stop dynamic mechanism.
-	// modifed by thomas. 2011.06.11.
+	/*  Fw is under p2p powersaving mode, driver should stop dynamic mechanism. */
+	/*  modifed by thomas. 2011.06.11. */
 	if (Adapter->wdinfo.p2p_ps_mode)
 		bFwPSAwake = false;
-#endif // CONFIG_P2P_PS
+#endif /*  CONFIG_P2P_PS */
 
-	// Stop dynamic mechanism when:
-	// 1. RF is OFF. (No need to do DM.)
-	// 2. Fw is under power saving mode for FwLPS. (Prevent from SW/FW I/O racing.)
-	// 3. IPS workitem is scheduled. (Prevent from IPS sequence to be swapped with DM.
-	//     Sometimes DM execution time is longer than 100ms such that the assertion
-	//     in MgntActSet_RF_State() called by InactivePsWorkItem will be triggered by
-	//     wating to long for RFChangeInProgress.)
-	// 4. RFChangeInProgress is TRUE. (Prevent from broken by IPS/HW/SW Rf off.)
-	// Noted by tynli. 2010.06.01.
-	//if (rfState == eRfOn)
+	/*  Stop dynamic mechanism when: */
+	/*  1. RF is OFF. (No need to do DM.) */
+	/*  2. Fw is under power saving mode for FwLPS. (Prevent from SW/FW I/O racing.) */
+	/*  3. IPS workitem is scheduled. (Prevent from IPS sequence to be swapped with DM. */
+	/*      Sometimes DM execution time is longer than 100ms such that the assertion */
+	/*      in MgntActSet_RF_State() called by InactivePsWorkItem will be triggered by */
+	/*      wating to long for RFChangeInProgress.) */
+	/*  4. RFChangeInProgress is TRUE. (Prevent from broken by IPS/HW/SW Rf off.) */
+	/*  Noted by tynli. 2010.06.01. */
 	if ((hw_init_completed == true)
 		&& ((!bFwCurrentInPSMode) && bFwPSAwake))
 	{
-		//
-		// Calculate Tx/Rx statistics.
-		//
+		/*  */
+		/*  Calculate Tx/Rx statistics. */
+		/*  */
 		dm_CheckStatistics(Adapter);
 
-		//
-		// For PWDB monitor and record some value for later use.
-		//
+		/*  */
+		/*  For PWDB monitor and record some value for later use. */
+		/*  */
 		PWDB_Monitor(Adapter);
 #ifdef CONFIG_CONCURRENT_MODE
 		if (Adapter->adapter_type > PRIMARY_ADAPTER)
 			goto _record_initrate;
 		FindMinimumRSSI(Adapter);
-#endif //CONFIG_CONCURRENT_MODE
-		//
-		// Dynamic Initial Gain mechanism.
-		//
-//sherry delete flag 20110517
+#endif /* CONFIG_CONCURRENT_MODE */
+		/*  */
+		/*  Dynamic Initial Gain mechanism. */
+		/*  */
+/* sherry delete flag 20110517 */
 		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForGlobalAdapterList);
 		if (pHalData->bSlaveOfDMSP)
 		{
@@ -2620,7 +2458,7 @@ rtl8192d_HalDmWatchDog(
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForGlobalAdapterList);
 #ifndef CONFIG_CONCURRENT_MODE
 		odm_FindMinimumRSSI_92D(Adapter);
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 		odm_DIG(Adapter);
 		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
 		{
@@ -2633,44 +2471,43 @@ rtl8192d_HalDmWatchDog(
 				dm_CCK_PacketDetectionThresh(Adapter);
 		}
 
-		//
-		// Dynamic Tx Power mechanism.
-		//
+		/*  */
+		/*  Dynamic Tx Power mechanism. */
+		/*  */
 		odm_DynamicTxPower_92D(Adapter);
 
-		//
-		// Tx Power Tracking.
-		//
-		//TX power tracking will make 92de DMDP MAC0's throughput bad.
+		/*  */
+		/*  Tx Power Tracking. */
+		/*  */
+		/* TX power tracking will make 92de DMDP MAC0's throughput bad. */
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		if (!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
 #endif
 			rtl8192d_dm_CheckTXPowerTracking(Adapter);
 
-		//
-		// Rate Adaptive by Rx Signal Strength mechanism.
-		//
+		/*  */
+		/*  Rate Adaptive by Rx Signal Strength mechanism. */
+		/*  */
 		dm_RefreshRateAdaptiveMask(Adapter);
 
-		// EDCA turbo
-		//update the EDCA paramter according to the Tx/RX mode
+		/*  EDCA turbo */
+		/* update the EDCA paramter according to the Tx/RX mode */
 		dm_CheckEdcaTurbo(Adapter);
 
-		//
-		// Dynamically switch RTS/CTS protection.
-		//
-		//dm_CheckProtection(Adapter);
-
-		//
-		//Dynamic BB Power Saving Mechanism
-		//vivi, 20101014, to pass DTM item: softap_excludeunencrypted_ext.htm
-		//temporarily disable it advised for performance test by yn,2010-11-03.
-		//if (!Adapter->bInHctTest)
-			dm_DynamicBBPowerSaving(Adapter);
+		/*  */
+		/*  Dynamically switch RTS/CTS protection. */
+		/*  */
+		/* dm_CheckProtection(Adapter); */
+
+		/*  */
+		/* Dynamic BB Power Saving Mechanism */
+		/* vivi, 20101014, to pass DTM item: softap_excludeunencrypted_ext.htm */
+		/* temporarily disable it advised for performance test by yn,2010-11-03. */
+		dm_DynamicBBPowerSaving(Adapter);
 
 _record_initrate:
 
-		// Read REG_INIDATA_RATE_SEL value for TXDESC.
+		/*  Read REG_INIDATA_RATE_SEL value for TXDESC. */
 		if (check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == true)
 		{
 			pdmpriv->INIDATA_RATE[0] = rtw_read8(Adapter, REG_INIDATA_RATE_SEL) & 0x3f;
@@ -2684,7 +2521,7 @@ _record_initrate:
 					pdmpriv->INIDATA_RATE[i] = rtw_read8(Adapter, (REG_INIDATA_RATE_SEL+i)) & 0x3f;
 				}
 			}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 		}
 		else
@@ -2699,16 +2536,10 @@ _record_initrate:
 
 skip_dm:
 
-	// Check GPIO to determine current RF on/off and Pbc status.
-	// Not enable for 92CU now!!!
-	// Check Hardware Radio ON/OFF or not
-	//if (Adapter->MgntInfo.PowerSaveControl.bGpioRfSw)
-	//{
-		//RTPRINT(FPWR, PWRHW, ("dm_CheckRfCtrlGPIO\n"));
-	//	dm_CheckRfCtrlGPIO(Adapter);
-	//}
+	/*  Check GPIO to determine current RF on/off and Pbc status. */
+	/*  Not enable for 92CU now!!! */
+	/*  Check Hardware Radio ON/OFF or not */
 
-	dm_CheckPbcGPIO(Adapter);				// Add by hpfan 2008-03-11
+	dm_CheckPbcGPIO(Adapter);				/*  Add by hpfan 2008-03-11 */
 
-	//RTPRINT(FDM, DM_Monitor, ("HalDmWatchDog() <==\n"));
 }
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -58,19 +58,19 @@ static void _FWDownloadEnable(struct rtw
 				DBG_8192D("DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE %s:%d REG_MCUFWDL:0x%02x\n", __func__, __LINE__, val);
 		}
 		#endif
-		// 8051 enable
+		/*  8051 enable */
 		tmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
 		rtw_write8(Adapter, REG_SYS_FUNC_EN+1, tmp|0x04);
 
-		// MCU firmware download enable.
+		/*  MCU firmware download enable. */
 		tmp = rtw_read8(Adapter, REG_MCUFWDL);
 		rtw_write8(Adapter, REG_MCUFWDL, tmp|0x01);
 
-		// 8051 reset
+		/*  8051 reset */
 		tmp = rtw_read8(Adapter, REG_MCUFWDL+2);
 		rtw_write8(Adapter, REG_MCUFWDL+2, tmp&0xf7);
 	} else {
-		// MCU firmware download enable.
+		/*  MCU firmware download enable. */
 		tmp = rtw_read8(Adapter, REG_MCUFWDL);
 		rtw_write8(Adapter, REG_MCUFWDL, tmp&0xfe);
 	}
@@ -162,8 +162,8 @@ _WriteFW(
 	)
 {
 	int ret = _SUCCESS;
-	// Since we need dynamic decide method of dwonload fw, so we call this function to get chip version.
-	// We can remove _ReadChipVersion from ReadAdapterInfo8192C later.
+	/*  Since we need dynamic decide method of dwonload fw, so we call this function to get chip version. */
+	/*  We can remove _ReadChipVersion from ReadAdapterInfo8192C later. */
 	u32	pageNums,remainSize ;
 	u32	page,offset;
 	u8*	bufferPtr = (u8*)buffer;
@@ -198,7 +198,7 @@ int _FWFreeToGo_92D(
 {
 	u32			counter = 0;
 	u32			value32;
-	// polling CheckSum report
+	/*  polling CheckSum report */
 	do{
 		value32 = rtw_read32(Adapter, REG_MCUFWDL);
 	}while ((counter ++ < POLLING_READY_TIMEOUT_COUNT) && (!(value32 & FWDL_ChkSum_rpt )));
@@ -220,50 +220,42 @@ rtl8192d_FirmwareSelfReset(
 	struct rtw_adapter *		Adapter
 )
 {
-	//struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	u8	u1bTmp;
 	u8	Delay = 100;
 
-	//if ((pHalData->FirmwareVersion > 0x21) ||
-	//	(pHalData->FirmwareVersion == 0x21 &&
-	//	pHalData->FirmwareSubVersion >= 0x01))
-	{
-		rtw_write8(Adapter, REG_FSIMR, 0x00);
-		// 2010/08/25 MH Accordign to RD alfred's suggestion, we need to disable other
-		// HRCV INT to influence 8051 reset.
-		rtw_write8(Adapter, REG_FWIMR, 0x20);
-		// 2011/02/15 MH According to Alex's suggestion, close mask to prevent incorrect FW write operation.
-		rtw_write8(Adapter, REG_FTIMR, 0x00);
+	rtw_write8(Adapter, REG_FSIMR, 0x00);
+	/*  2010/08/25 MH Accordign to RD alfred's suggestion, we need to disable other */
+	/*  HRCV INT to influence 8051 reset. */
+	rtw_write8(Adapter, REG_FWIMR, 0x20);
+	/*  2011/02/15 MH According to Alex's suggestion, close mask to prevent incorrect FW write operation. */
+	rtw_write8(Adapter, REG_FTIMR, 0x00);
 
-		//0x1cf=0x20. Inform 8051 to reset. 2009.12.25. tynli_test
-		rtw_write8(Adapter, REG_HMETFR+3, 0x20);
+	/* 0x1cf=0x20. Inform 8051 to reset. 2009.12.25. tynli_test */
+	rtw_write8(Adapter, REG_HMETFR+3, 0x20);
 
+	u1bTmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
+	while (u1bTmp&BIT2)
+	{
+		Delay--;
+		if (Delay == 0)
+			break;
+		rtw_udelay_os(50);
 		u1bTmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
-		while (u1bTmp&BIT2)
-		{
-			Delay--;
-			//RT_TRACE(COMP_INIT, DBG_LOUD, ("PowerOffAdapter8192CE(): polling 0x03[2] Delay = %d\n", Delay));
-			if (Delay == 0)
-				break;
-			rtw_udelay_os(50);
-			u1bTmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
-		}
+	}
 
-		if ((u1bTmp&BIT2) && (Delay == 0))
-		{
-			//DbgPrint("FirmwareDownload92C(): Fail!!!!!! 0x03 = %x\n", u1bTmp);
-			rtw_write8(Adapter, REG_FWIMR, 0x00);
-			//debug reset fail
-			printk("FirmwareDownload92C(): Fail!!!!!! 0x1c = %x, 0x130=>%08x, 0x134=>%08x, 0x138=>%08x, 0x1c4=>%08x\n, 0x1cc=>%08x, , 0x80=>%08x , 0x1c0=>%08x\n", rtw_read32(Adapter, 0x1c)
-			, rtw_read32(Adapter, 0x130), rtw_read32(Adapter, 0x134), rtw_read32(Adapter, 0x138), rtw_read32(Adapter, 0x1c4),
-			rtw_read32(Adapter, 0x1cc), rtw_read32(Adapter, 0x80), rtw_read32(Adapter, 0x1c0));
-		}
+	if ((u1bTmp&BIT2) && (Delay == 0))
+	{
+		rtw_write8(Adapter, REG_FWIMR, 0x00);
+		/* debug reset fail */
+		printk("FirmwareDownload92C(): Fail!!!!!! 0x1c = %x, 0x130=>%08x, 0x134=>%08x, 0x138=>%08x, 0x1c4=>%08x\n, 0x1cc=>%08x, , 0x80=>%08x , 0x1c0=>%08x\n", rtw_read32(Adapter, 0x1c)
+		, rtw_read32(Adapter, 0x130), rtw_read32(Adapter, 0x134), rtw_read32(Adapter, 0x138), rtw_read32(Adapter, 0x1c4),
+		rtw_read32(Adapter, 0x1cc), rtw_read32(Adapter, 0x80), rtw_read32(Adapter, 0x1c0));
 	}
 }
 
-//
-// description :polling fw ready
-//
+/*  */
+/*  description :polling fw ready */
+/*  */
 int _FWInit(struct rtw_adapter *Adapter)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
@@ -272,7 +264,7 @@ int _FWInit(struct rtw_adapter *Adapter)
 
 	DBG_8192D("FW already have download ;\n");
 
-	// polling for FW ready
+	/*  polling for FW ready */
 	counter = 0;
 	do
 	{
@@ -307,12 +299,12 @@ int _FWInit(struct rtw_adapter *Adapter)
 #ifdef CONFIG_FILE_FWIMG
 extern char *rtw_fw_file_path;
 u8	FwBuffer8192D[FW_8192D_SIZE];
-#endif //CONFIG_FILE_FWIMG
-//
-//	Description:
-//		Download 8192C firmware code.
-//
-//
+#endif /* CONFIG_FILE_FWIMG */
+/*  */
+/* 	Description: */
+/* 		Download 8192C firmware code. */
+/*  */
+/*  */
 int FirmwareDownload92D(
 	struct rtw_adapter *			Adapter,
 	bool			bUsedWoWLANFw
@@ -329,7 +321,7 @@ int FirmwareDownload92D(
 #ifdef CONFIG_WOWLAN
 	u8*			FwImageWoWLAN;
 	u32			FwImageWoWLANLen;
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 	struct RT_FIRMWARE_92D	*pFirmware = NULL;
 	struct rt_8192d_firmware_hdr *pFwHdr = NULL;
 	u8		*pFirmwareBuf;
@@ -354,17 +346,17 @@ int FirmwareDownload92D(
 #ifdef CONFIG_WOWLAN
 	FwImageWoWLAN= Rtl8192D_FwWWImageArray;
 	FwImageWoWLANLen =DUWWImgArrayLength ;
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 	DBG_8192D(" ===> FirmwareDownload92D() fw:Rtl8192D_FwImageArray\n");
 
 	#ifdef CONFIG_FILE_FWIMG
 	if (rtw_is_file_readable(rtw_fw_file_path) == true)
 	{
 		DBG_8192D("%s accquire FW from file:%s\n", __func__, rtw_fw_file_path);
-		pFirmware->eFWSource = FW_SOURCE_IMG_FILE; // We should decided by Reg.
+		pFirmware->eFWSource = FW_SOURCE_IMG_FILE; /*  We should decided by Reg. */
 	}
 	else
-	#endif //CONFIG_FILE_FWIMG
+	#endif /* CONFIG_FILE_FWIMG */
 	{
 		DBG_8192D("%s accquire FW from embedded image\n", __func__);
 		pFirmware->eFWSource = FW_SOURCE_HEADER_FILE;
@@ -379,7 +371,7 @@ int FirmwareDownload92D(
 
 			pFirmware->ulFwLength = rtStatus>=0?rtStatus:0;
 			pFirmware->szFwBuffer = FwBuffer8192D;
-			#endif //CONFIG_FILE_FWIMG
+			#endif /* CONFIG_FILE_FWIMG */
 
 			if (pFirmware->ulFwLength <= 0)
 			{
@@ -396,11 +388,11 @@ int FirmwareDownload92D(
 				pFirmware->szWoWLANFwBuffer=FwImageWoWLAN;
 				pFirmware->ulWoWLANFwLength = FwImageWoWLANLen;
 			}
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 			break;
 	}
 
-	#ifdef DBG_FW_STORE_FILE_PATH //used to store firmware to file...
+	#ifdef DBG_FW_STORE_FILE_PATH /* used to store firmware to file... */
 	if (pFirmware->ulFwLength > 0)
 	{
 		rtw_store_to_file(DBG_FW_STORE_FILE_PATH, pFirmware->szFwBuffer, pFirmware->ulFwLength);
@@ -414,12 +406,12 @@ int FirmwareDownload92D(
 		pFwHdr = (struct rt_8192d_firmware_hdr *)pFirmware->szWoWLANFwBuffer;
 	}
 	else
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 	{
 	pFirmwareBuf = pFirmware->szFwBuffer;
 	FirmwareLen = pFirmware->ulFwLength;
 
-	// To Check Fw header. Added by tynli. 2009.12.04.
+	/*  To Check Fw header. Added by tynli. 2009.12.04. */
 	pFwHdr = (struct rt_8192d_firmware_hdr *)pFirmware->szFwBuffer;
 	}
 
@@ -430,13 +422,12 @@ int FirmwareDownload92D(
 
 	if (IS_FW_HEADER_EXIST(pFwHdr))
 	{
-		//DBG_8192D("Shift 32 bytes for FW header!!\n");
 		pFirmwareBuf = pFirmwareBuf + 32;
 		FirmwareLen = FirmwareLen -32;
 	}
 
 #ifdef CONFIG_WOWLAN
-	//write 0x5 BIT(3), don't suspend to reset MAC
+	/* write 0x5 BIT(3), don't suspend to reset MAC */
 	if (bUsedWoWLANFw)
 	{
 		u8 test;
@@ -445,7 +436,7 @@ int FirmwareDownload92D(
 		rtw_write8(Adapter, REG_APS_FSMCO+1, test);
 	}
 
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 	if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY ||
 		pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
@@ -497,9 +488,9 @@ int FirmwareDownload92D(
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 	}
 
-	// Suggested by Filen. If 8051 is running in RAM code, driver should inform Fw to reset by itself,
-	// or it will cause download Fw fail. 2010.02.01. by tynli.
-	if (rtw_read8(Adapter, REG_MCUFWDL)&BIT7) //8051 RAM code
+	/*  Suggested by Filen. If 8051 is running in RAM code, driver should inform Fw to reset by itself, */
+	/*  or it will cause download Fw fail. 2010.02.01. by tynli. */
+	if (rtw_read8(Adapter, REG_MCUFWDL)&BIT7) /* 8051 RAM code */
 	{
 		DBG_8192D("Firmware self reset\n");
 		rtl8192d_FirmwareSelfReset(Adapter);
@@ -509,7 +500,7 @@ int FirmwareDownload92D(
 	_FWDownloadEnable(Adapter, true);
 	fwdl_start_time = rtw_get_current_time();
 	while (1) {
-		//reset the FWDL chksum
+		/* reset the FWDL chksum */
 		rtw_write8(Adapter, REG_MCUFWDL, rtw_read8(Adapter, REG_MCUFWDL)|FWDL_ChkSum_rpt);
 
 		rtStatus = _WriteFW(Adapter, pFirmwareBuf, FirmwareLen);
@@ -532,7 +523,7 @@ int FirmwareDownload92D(
 
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 	rtStatus=_FWFreeToGo_92D(Adapter);
-	// download fw over,clear 0x1f[5]
+	/*  download fw over,clear 0x1f[5] */
 	value=rtw_read8(Adapter, 0x1f);
 	value&=(~BIT5);
 	rtw_write8(Adapter, 0x1f,value);
@@ -551,7 +542,6 @@ Exit:
 		rtw_vmfree((u8*)pFirmware, sizeof(struct RT_FIRMWARE_92D));
 	}
 
-	//RT_TRACE(COMP_INIT, DBG_LOUD, (" <=== FirmwareDownload91C()\n"));
 	return rtStatus;
 }
 
@@ -565,25 +555,25 @@ InitializeFirmwareVars92D(
 	struct pwrctrl_priv *pwrpriv;
 	pwrpriv = &Adapter->pwrctrlpriv;
 
-	// Init Fw LPS related.
+	/*  Init Fw LPS related. */
 	Adapter->pwrctrlpriv.bFwCurrentInPSMode = false;
 
 	pwrpriv->bkeepfwalive = true;
-	//Init H2C counter. by tynli. 2009.12.09.
+	/* Init H2C counter. by tynli. 2009.12.09. */
 	pHalData->LastHMEBoxNum = 0;
 }
 
 
-//===========================================
+/*  */
 
-//
-// Description: Prepare some information to Fw for WoWLAN.
-//			(1) Download wowlan Fw.
-//			(2) Download RSVD page packets.
-//			(3) Enable AP offload if needed.
-//
-// 2011.04.12 by tynli.
-//
+/*  */
+/*  Description: Prepare some information to Fw for WoWLAN. */
+/* 			(1) Download wowlan Fw. */
+/* 			(2) Download RSVD page packets. */
+/* 			(3) Enable AP offload if needed. */
+/*  */
+/*  2011.04.12 by tynli. */
+/*  */
 void
 SetFwRelatedForWoWLAN8192DU(
 	struct rtw_adapter *			padapter,
@@ -596,9 +586,9 @@ SetFwRelatedForWoWLAN8192DU(
 
 	if (bHostIsGoingtoSleep)
 	{
-		//
-		// 1. Before WoWLAN we need to re-download WoWLAN Fw.
-		//
+		/*  */
+		/*  1. Before WoWLAN we need to re-download WoWLAN Fw. */
+		/*  */
 		status = FirmwareDownload92D(padapter, bHostIsGoingtoSleep);
 		if (status != _SUCCESS)
 		{
@@ -610,30 +600,30 @@ SetFwRelatedForWoWLAN8192DU(
 			DBG_8192D("ConfigFwRelatedForWoWLAN8192DU(): Re-Download Firmware Success !!\n");
 		}
 
-		//
-		// 2. Re-Init the variables about Fw related setting.
-		//
+		/*  */
+		/*  2. Re-Init the variables about Fw related setting. */
+		/*  */
 		InitializeFirmwareVars92D(padapter);
 
 
 	}
 }
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 
-//"chnl" begins from 0. It's not a real channel.
-//"channel_info[chnl]" is a real channel.
+/* chnl" begins from 0. It's not a real channel. */
+/* channel_info[chnl]" is a real channel. */
 static u8 Hal_GetChnlGroupfromArray(u8 chnl)
 {
 	u8	group=0;
 	u8	channel_info[59] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
 
-	if (channel_info[chnl] <= 3)			// Chanel 1-3
+	if (channel_info[chnl] <= 3)			/*  Chanel 1-3 */
 		group = 0;
-	else if (channel_info[chnl] <= 9)		// Channel 4-9
+	else if (channel_info[chnl] <= 9)		/*  Channel 4-9 */
 		group = 1;
-	else	if (channel_info[chnl] <=14)				// Channel 10-14
+	else	if (channel_info[chnl] <=14)				/*  Channel 10-14 */
 		group = 2;
-	// For TX_POWER_FOR_5G_BAND
+	/*  For TX_POWER_FOR_5G_BAND */
 	else if (channel_info[chnl] <= 44)
 		group = 3;
 	else if (channel_info[chnl] <= 54)
@@ -670,10 +660,10 @@ rtl8192d_ReadChipVersion(
 
 	ChipVersion = (enum VERSION_8192D)(VERSION_NORMAL_CHIP_92D_SINGLEPHY | CHIP_92D);
 
-	//Decide TestChip or NormalChip here.
-	//92D's RF_type will be decided when the reg0x2c is filled.
+	/* Decide TestChip or NormalChip here. */
+	/* 92D's RF_type will be decided when the reg0x2c is filled. */
 	if (!(value32 & 0x000f0000))
-	{ //Test or Normal Chip:  hardward id 0xf0[19:16] =0 test chip
+	{ /* Test or Normal Chip:  hardward id 0xf0[19:16] =0 test chip */
 		ChipVersion = VERSION_TEST_CHIP_92D_SINGLEPHY;
 		DBG_8192D("TEST CHIP!!!\n");
 	}
@@ -686,11 +676,11 @@ rtl8192d_ReadChipVersion(
 	pHalData->VersionID = ChipVersion;
 }
 
-//-------------------------------------------------------------------------
-//
-//	Channel Plan
-//
-//-------------------------------------------------------------------------
+/*  */
+/*  */
+/* 	Channel Plan */
+/*  */
+/*  */
 
 void
 rtl8192d_EfuseParseChnlPlan(
@@ -710,11 +700,11 @@ rtl8192d_EfuseParseChnlPlan(
 	DBG_8192D("mlmepriv.ChannelPlan = 0x%02x\n" , Adapter->mlmepriv.ChannelPlan);
 }
 
-//-------------------------------------------------------------------------
-//
-//	EEPROM Power index mapping
-//
-//-------------------------------------------------------------------------
+/*  */
+/*  */
+/* 	EEPROM Power index mapping */
+/*  */
+/*  */
 
 static void
 hal_ReadPowerValueFromPROM92D(
@@ -759,8 +749,8 @@ hal_ReadPowerValueFromPROM92D(
 		return;
 	}
 
-	//Maybe autoload OK,buf the tx power index vlaue is not filled.
-	//If we find it,we set it default value.
+	/* Maybe autoload OK,buf the tx power index vlaue is not filled. */
+	/* If we find it,we set it default value. */
 	for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++) {
 		for (group = 0 ; group < CHANNEL_GROUP_MAX_2G; group++) {
 			eeAddr = EEPROM_CCK_TX_PWR_INX_2G + (rfPath * 3) + group;
@@ -780,7 +770,7 @@ hal_ReadPowerValueFromPROM92D(
 		}
 	}
 
-	//These just for 92D efuse offset.
+	/* These just for 92D efuse offset. */
 	for (group = 0 ; group < CHANNEL_GROUP_MAX ; group++) {
 		for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++) {
 			offset1 = group / 3;
@@ -789,8 +779,6 @@ hal_ReadPowerValueFromPROM92D(
 			if (PROMContent[EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G+ offset2 + offset1*21] != 0xFF)
 				pwrInfo->HT40_2SIndexDiff[rfPath][group] =
 					(PROMContent[EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G+ offset2 + offset1*21] >> (rfPath * 4)) & 0xF;
-					//RT_TRACE(COMP_INIT,DBG_LOUD,
-					//	("ht40_2sdiff:group:%d,%x:0x%x.\n",group,EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G+ offset2 + offset1*21,PROMContent[EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G+ offset2 + offset1*21]));
 			else
 				pwrInfo->HT40_2SIndexDiff[rfPath][group]	= EEPROM_Default_HT40_2SDiff;
 
@@ -798,7 +786,7 @@ hal_ReadPowerValueFromPROM92D(
 			{
 				pwrInfo->HT20IndexDiff[rfPath][group] =
 					(PROMContent[EEPROM_HT20_TX_PWR_INX_DIFF_2G+ offset2 + offset1*21] >> (rfPath * 4)) & 0xF;
-				if (pwrInfo->HT20IndexDiff[rfPath][group] & BIT3)	//4bit sign number to 8 bit sign number
+				if (pwrInfo->HT20IndexDiff[rfPath][group] & BIT3)	/* 4bit sign number to 8 bit sign number */
 					pwrInfo->HT20IndexDiff[rfPath][group] |= 0xF0;
 			}
 			else
@@ -828,16 +816,16 @@ hal_ReadPowerValueFromPROM92D(
 	}
 
 	if (PROMContent[EEPROM_TSSI_A_5G] != 0xFF) {
-		//5GL
-		pwrInfo->TSSI_A_5G[0] = PROMContent[EEPROM_TSSI_A_5G] & 0x3F;	//[0:5]
+		/* 5GL */
+		pwrInfo->TSSI_A_5G[0] = PROMContent[EEPROM_TSSI_A_5G] & 0x3F;	/* 0:5] */
 		pwrInfo->TSSI_B_5G[0] = PROMContent[EEPROM_TSSI_B_5G] & 0x3F;
 
-		//5GM
+		/* 5GM */
 		pwrInfo->TSSI_A_5G[1] = PROMContent[EEPROM_TSSI_AB_5G] & 0x3F;
 		pwrInfo->TSSI_B_5G[1] = (PROMContent[EEPROM_TSSI_AB_5G] & 0xC0) >> 6 |
 							(PROMContent[EEPROM_TSSI_AB_5G+1] & 0x0F) << 2;
 
-		//5GH
+		/* 5GH */
 		pwrInfo->TSSI_A_5G[2] = (PROMContent[EEPROM_TSSI_AB_5G+1] & 0xF0) >> 4 |
 							(PROMContent[EEPROM_TSSI_AB_5G+2] & 0x03) << 4;
 		pwrInfo->TSSI_B_5G[2] = (PROMContent[EEPROM_TSSI_AB_5G+2] & 0xFC) >> 2 ;
@@ -869,7 +857,7 @@ rtl8192d_ReadTxPowerInfo(
 
 	if (!AutoLoadFail)
 	{
-		pHalData->EEPROMRegulatory = (PROMContent[EEPROM_RF_OPT1]&0x7);	//bit0~2
+		pHalData->EEPROMRegulatory = (PROMContent[EEPROM_RF_OPT1]&0x7);	/* bit0~2 */
 		pHalData->EEPROMThermalMeter = PROMContent[EEPROM_THERMAL_METER]&0x1f;
 		pHalData->CrystalCap = PROMContent[EEPROM_XTAL_K];
 		tempval[0] = PROMContent[EEPROM_IQK_DELTA]&0x03;
@@ -898,7 +886,7 @@ rtl8192d_ReadTxPowerInfo(
 	{
 		switch (pHalData->PAMode)
 		{
-			//external pa
+			/* external pa */
 			case 0:
 				pHalData->EEPROMC9 = EEPROM_Default_externalPA_C9;
 				pHalData->EEPROMCC = EEPROM_Default_externalPA_CC;
@@ -906,7 +894,7 @@ rtl8192d_ReadTxPowerInfo(
 				pHalData->InternalPA5G[1] = false;
 				break;
 
-			// internal pa - SP3T
+			/*  internal pa - SP3T */
 			case 1:
 				pHalData->EEPROMC9 = EEPROM_Default_internalPA_SP3T_C9;
 				pHalData->EEPROMCC = EEPROM_Default_internalPA_SP3T_CC;
@@ -914,7 +902,7 @@ rtl8192d_ReadTxPowerInfo(
 				pHalData->InternalPA5G[1] = true;
 				break;
 
-			//intermal pa = SPDT
+			/* intermal pa = SPDT */
 			case 2:
 				pHalData->EEPROMC9 = EEPROM_Default_internalPA_SPDT_C9;
 				pHalData->EEPROMCC = EEPROM_Default_internalPA_SPDT_CC;
@@ -928,15 +916,15 @@ rtl8192d_ReadTxPowerInfo(
 	}
 	DBG_8192D("PHY_SetPAMode mode %d, c9 = 0x%x cc = 0x%x interface index %d\n", pHalData->PAMode, pHalData->EEPROMC9, pHalData->EEPROMCC, pHalData->interfaceIndex);
 
-	//Use default value to fill parameters if efuse is not filled on some place.
+	/* Use default value to fill parameters if efuse is not filled on some place. */
 
-	// ThermalMeter from EEPROM
+	/*  ThermalMeter from EEPROM */
 	if (pHalData->EEPROMThermalMeter < 0x06 || pHalData->EEPROMThermalMeter > 0x1c)
 		pHalData->EEPROMThermalMeter = 0x12;
 
 	pdmpriv->ThermalMeter[0] = pHalData->EEPROMThermalMeter;
 
-	//check XTAL_K
+	/* check XTAL_K */
 	if (pHalData->CrystalCap == 0xFF)
 		pHalData->CrystalCap = 0;
 
@@ -966,7 +954,7 @@ rtl8192d_ReadTxPowerInfo(
 		}
 	}
 
-	//this is suggested by Mimic, every 4 steps to redo IQK, every 7 steps to redo LCK
+	/* this is suggested by Mimic, every 4 steps to redo IQK, every 7 steps to redo LCK */
 	pdmpriv->Delta_IQK = 4;
 	pdmpriv->Delta_LCK = 7;
 	if (pHalData->EEPROMC9 == 0xFF)
@@ -1033,44 +1021,16 @@ rtl8192d_ReadTxPowerInfo(
 #endif
 }
 
-//
-//	Description:
-//		Reset Dual Mac Mode Switch related settings
-//
-//	Assumption:
-//
+/*  */
+/* 	Description: */
+/* 		Reset Dual Mac Mode Switch related settings */
+/*  */
+/* 	Assumption: */
+/*  */
 void rtl8192d_ResetDualMacSwitchVariables(
 		struct rtw_adapter *			Adapter
 )
 {
-#ifdef CONFIG_DUALMAC_CONCURRENT
-/*	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	struct rtw_adapter *		BuddyAdapter = Adapter->BuddyAdapter;
-
-	Adapter->bNeedReConfigMac = false;
-	Adapter->bNeedReConfigPhyRf = false;
-	Adapter->bNeedTurnOffAdapterInModeSwitchProcess = false;
-	Adapter->bNeedRecoveryAfterModeSwitch = false;
-	Adapter->bInModeSwitchProcess = false;
-	Adapter->bDoTurnOffPhyRf  = false;
-
-	if (BuddyAdapter != NULL)
-	{
-		Adapter->PreChangeAction = BuddyAdapter->PreChangeAction;
-	}
-	else
-	{
-		Adapter->PreChangeAction = MAXACTION;
-	}
-
-	//set dual mac role to set
-	Adapter->DualMacRoleToSet.BandType = pHalData->CurrentBandType92D;
-	Adapter->DualMacRoleToSet.BandSet = pHalData->BandSet92D;
-	Adapter->DualMacRoleToSet.RFType = pHalData->RF_Type;
-	Adapter->DualMacRoleToSet.macPhyMode = pHalData->MacPhyMode92D ;
-	Adapter->DualMacRoleToSet.bMasterOfDMSP = Adapter->bMasterOfDMSP;
-	Adapter->DualMacRoleToSet.bSlaveOfDMSP = Adapter->bSlaveOfDMSP;*/
-#endif //CONFIG_DUALMAC_CONCURRENT
 }
 
 u8 GetEEPROMSize8192D(struct rtw_adapter * Adapter)
@@ -1079,7 +1039,7 @@ u8 GetEEPROMSize8192D(struct rtw_adapter
 	u32	curRCR;
 
 	curRCR = rtw_read16(Adapter, REG_9346CR);
-	size = (curRCR & BOOT_FROM_EEPROM) ? 6 : 4; // 6: EEPROM used is 93C46, 4: boot from E-Fuse.
+	size = (curRCR & BOOT_FROM_EEPROM) ? 6 : 4; /*  6: EEPROM used is 93C46, 4: boot from E-Fuse. */
 
 	MSG_8192D("EEPROM type is %s\n", size==4 ? "E-FUSE" : "93C46");
 
@@ -1144,7 +1104,7 @@ PHY_SetPowerOnFor8192D(
 	u8	value8;
 	u16	i;
 
-	// notice fw know band status  0x81[1]/0x53[1] = 0: 5G, 1: 2G
+	/*  notice fw know band status  0x81[1]/0x53[1] = 0: 5G, 1: 2G */
 	if (pHalData->CurrentBandType92D==BAND_ON_2_4G)
 	{
 		value8 = rtw_read8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
@@ -1212,9 +1172,9 @@ _func_enter_;
 _func_exit_;
 }
 
-//===========================================================
-//				Efuse related code
-//===========================================================
+/*  */
+/* 				Efuse related code */
+/*  */
 enum{
 		VOLTAGE_V25						= 0x03,
 		LDOE25_SHIFT						= 28 ,
@@ -1231,20 +1191,20 @@ rtl8192d_EfusePowerSwitch(
 
 	if (PwrState == true)
 	{
-		// 1.2V Power: From VDDON with Power Cut(0x0000h[15]), defualt valid
+		/*  1.2V Power: From VDDON with Power Cut(0x0000h[15]), defualt valid */
 		tmpV16 = rtw_read16(pAdapter, REG_SYS_ISO_CTRL);
 		if (!(tmpV16 & PWC_EV12V)) {
 			tmpV16 |= PWC_EV12V ;
 			 rtw_write16(pAdapter, REG_SYS_ISO_CTRL, tmpV16);
 		}
-		// Reset: 0x0000h[28], default valid
+		/*  Reset: 0x0000h[28], default valid */
 		tmpV16 = rtw_read16(pAdapter, REG_SYS_FUNC_EN);
 		if (!(tmpV16 & FEN_ELDR)) {
 			tmpV16 |= FEN_ELDR ;
 			rtw_write16(pAdapter,REG_SYS_FUNC_EN,tmpV16);
 		}
 
-		// Clock: Gated(0x0008h[5]) 8M(0x0008h[1]) clock from ANA, default valid
+		/*  Clock: Gated(0x0008h[5]) 8M(0x0008h[1]) clock from ANA, default valid */
 		tmpV16 = rtw_read16(pAdapter, REG_SYS_CLKR);
 		if ((!(tmpV16 & LOADER_CLK_EN)) || (!(tmpV16 & ANA8M))) {
 			tmpV16 |= (LOADER_CLK_EN | ANA8M);
@@ -1252,7 +1212,7 @@ rtl8192d_EfusePowerSwitch(
 		}
 
 		if (bWrite == true) {
-			// Enable LDO 2.5V before read/write action
+			/*  Enable LDO 2.5V before read/write action */
 			tempval = rtw_read8(pAdapter, EFUSE_TEST+3);
 			tempval &= 0x0F;
 			tempval |= (VOLTAGE_V25 << 4);
@@ -1262,7 +1222,7 @@ rtl8192d_EfusePowerSwitch(
 	else
 	{
 		if (bWrite == true) {
-			// Disable LDO 2.5V after read/write action
+			/*  Disable LDO 2.5V after read/write action */
 			tempval = rtw_read8(pAdapter, EFUSE_TEST+3);
 			rtw_write8(pAdapter, EFUSE_TEST+3, (tempval & 0x7F));
 		}
@@ -1289,57 +1249,49 @@ ReadEFuse_RTL8192D(
 	u8	efuse_usage = 0;
 	u8	u1temp = 0;
 
-	//
-	// Do NOT excess total size of EFuse table. Added by Roger, 2008.11.10.
-	//
+	/*  */
+	/*  Do NOT excess total size of EFuse table. Added by Roger, 2008.11.10. */
+	/*  */
 	if ((_offset + _size_byte)>EFUSE_MAP_LEN)
-	{// total E-Fuse table is 128bytes
+	{/*  total E-Fuse table is 128bytes */
 		DBG_8192D("ReadEFuse(): Invalid offset(%#x) with read bytes(%#x)!!\n",_offset, _size_byte);
 		return;
 	}
 
-	// 0. Refresh efuse init map as all oxFF.
+	/*  0. Refresh efuse init map as all oxFF. */
 	for (i = 0; i < EFUSE_MAX_SECTION; i++)
 		for (j = 0; j < EFUSE_MAX_WORD_UNIT; j++)
 			eFuseWord[i][j] = 0xFFFF;
 
 
-	//
-	// 1. Read the first byte to check if efuse is empty!!!
-	//
-	//
+	/*  */
+	/*  1. Read the first byte to check if efuse is empty!!! */
+	/*  */
+	/*  */
 	ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
 	if (*rtemp8 != 0xFF)
 	{
 		efuse_utilized++;
-		//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Addr=%d\n", eFuse_Addr));
 		eFuse_Addr++;
 	}
 	else
 	{
-		//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("EFUSE is empty efuse_Addr-%d efuse_data=%x\n", eFuse_Addr, *rtemp8));
 		return;
 	}
 
-	//
-	// 2. Read real efuse content. Filter PG header and every section data.
-	//
+	/*  */
+	/*  2. Read real efuse content. Filter PG header and every section data. */
+	/*  */
 	while ((*rtemp8 != 0xFF) && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN))
 	{
-		// Check PG header for section num.
-		if ((*rtemp8 & 0x1F) == 0x0F)		//extended header
+		/*  Check PG header for section num. */
+		if ((*rtemp8 & 0x1F) == 0x0F)		/* extended header */
 		{
 
-			//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("extended header u1temp=%x *rtemp&0xE0 0x%x\n", u1temp, *rtemp8 & 0xE0));
-
 			u1temp =((*rtemp8 & 0xE0) >> 5);
 
-			//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("extended header u1temp=%x\n", u1temp));
-
 			ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
 
-			//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("extended header efuse_Addr-%d efuse_data=%x\n", eFuse_Addr, *rtemp8));
-
 			if ((*rtemp8 & 0x0F) == 0x0F)
 			{
 				eFuse_Addr++;
@@ -1366,18 +1318,15 @@ ReadEFuse_RTL8192D(
 
 		if (offset < EFUSE_MAX_SECTION)
 		{
-			// Get word enable value from PG header
-			//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Offset-%d Worden=%x\n", offset, wren));
+			/*  Get word enable value from PG header */
 
 			for (i=0; i<EFUSE_MAX_WORD_UNIT; i++)
 			{
-				// Check word enable condition in the section
+				/*  Check word enable condition in the section */
 				if (!(wren & 0x01))
 				{
-					//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Addr=%d\n", eFuse_Addr));
 					ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
 					eFuse_Addr++;
-					//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Data=0x%x\n", *rtemp8));
 					efuse_utilized++;
 					eFuseWord[offset][i] = (*rtemp8 & 0xff);
 
@@ -1385,10 +1334,8 @@ ReadEFuse_RTL8192D(
 					if (eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
 						break;
 
-					//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Addr=%d\n", eFuse_Addr));
 					ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
 					eFuse_Addr++;
-					//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Data=0x%x\n", *rtemp8));
 
 					efuse_utilized++;
 					eFuseWord[offset][i] |= (((u16)*rtemp8 << 8) & 0xff00);
@@ -1402,9 +1349,8 @@ ReadEFuse_RTL8192D(
 			}
 		}
 
-		// Read next PG header
+		/*  Read next PG header */
 		ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
-		//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Addr=%d rtemp 0x%x\n", eFuse_Addr, *rtemp8));
 
 		if (*rtemp8 != 0xFF && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN))
 		{
@@ -1413,9 +1359,9 @@ ReadEFuse_RTL8192D(
 		}
 	}
 
-	//
-	// 3. Collect 16 sections and 4 word unit into Efuse map.
-	//
+	/*  */
+	/*  3. Collect 16 sections and 4 word unit into Efuse map. */
+	/*  */
 	for (i=0; i<EFUSE_MAX_SECTION; i++)
 	{
 		for (j=0; j<EFUSE_MAX_WORD_UNIT; j++)
@@ -1425,22 +1371,19 @@ ReadEFuse_RTL8192D(
 		}
 	}
 
-	//
-	// 4. Copy from Efuse map to output pointer memory!!!
-	//
+	/*  */
+	/*  4. Copy from Efuse map to output pointer memory!!! */
+	/*  */
 	for (i=0; i<_size_byte; i++)
 	{
 		pbuf[i] = efuseTbl[_offset+i];
 	}
 
-	//
-	// 5. Calculate Efuse utilization.
-	//
-	//priv->EfuseUsedBytes = efuse_utilized;
+	/*  */
+	/*  5. Calculate Efuse utilization. */
+	/*  */
 	efuse_usage = (u8)((efuse_utilized*100)/EFUSE_REAL_CONTENT_LEN);
-	//priv->EfuseUsedPercentage = efuse_usage;
 	rtw_hal_set_hwreg(Adapter, HW_VAR_EFUSE_BYTES, (u8*)&efuse_utilized);
-	//rtw_hal_set_hwreg(dev, HW_VAR_EFUSE_USAGE, (u8*)&efuse_usage);
 }
 
 static void
@@ -1459,12 +1402,10 @@ hal_EfuseUpdateNormalChipVersion_92D(
 	ChipValue= (CutValue[1]<<8)|CutValue[0];
 	switch (ChipValue) {
 		case 0xAA55:
-			//ChipVer |= CHIP_92D_C_CUT;
 			ChipVer = (enum VERSION_8192D)(ChipVer | C_CUT_VERSION);
 			MSG_8192D("C-CUT!!!\n");
 			break;
 		case 0x9966:
-			//ChipVer |= CHIP_92D_D_CUT;
 			ChipVer = (enum VERSION_8192D)(ChipVer | D_CUT_VERSION);
 			MSG_8192D("D-CUT!!!\n");
 			break;
@@ -1473,7 +1414,6 @@ hal_EfuseUpdateNormalChipVersion_92D(
 			MSG_8192D("E-CUT!!!\n");
 			break;
 		default:
-			//ChipVer |= CHIP_92D_D_CUT;
 			ChipVer = (enum VERSION_8192D)(ChipVer | D_CUT_VERSION);
 			MSG_8192D("Unkown CUT!\n");
 			break;
@@ -1490,26 +1430,22 @@ hal_EfuseMacMode_ISVS_92D(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	u8	PartNo;
 	bool bResult = false;
-	// 92D VS not support dual mac mode
+	/*  92D VS not support dual mac mode */
 	if (IS_NORMAL_CHIP92D(pHalData->VersionID))
 	{
 		ReadEFuseByte(Adapter,EEPROM_DEF_PART_NO,&PartNo, false);
-		//RT_TRACE(COMP_INIT, DBG_LOUD, ("92D efuse byte 1021 content :%d\n",PartNo));
 
 		if ((((PartNo & 0xc0) ==  PARTNO_92D_NIC)&&((PartNo & 0x0c) == PARTNO_SINGLE_BAND_VS))||
 			(((PartNo & 0xF0) == PARTNO_92D_NIC_REMARK) &&((PartNo & 0x0F) == PARTNO_SINGLE_BAND_VS_REMARK)))
 		{
-			//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("92D VS !\n"));
 			bResult = true;
 		}
 		else if (PartNo == 0x00)
 		{
 			ReadEFuseByte(Adapter,EEPROM_DEF_PART_NO+1,&PartNo, false);
-			//RT_TRACE(COMP_INIT, DBG_LOUD, ("92D efuse byte 1022 content :%d\n",PartNo));
 			if ((((PartNo & 0xc0) ==  PARTNO_92D_NIC)&&((PartNo & 0x0c) == PARTNO_SINGLE_BAND_VS))||
 				(((PartNo & 0xF0) == PARTNO_92D_NIC_REMARK) &&((PartNo & 0x0F) == PARTNO_SINGLE_BAND_VS_REMARK)))
 			{
-				//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("92D VS !\n"));
 				bResult = true;
 			}
 		}
@@ -1617,7 +1553,7 @@ rtl8192d_EfuseGetCurrentSize(
 	{
 		if (efuse_data!=0xFF)
 		{
-			if ((efuse_data&0x1F) == 0x0F)		//extended header
+			if ((efuse_data&0x1F) == 0x0F)		/* extended header */
 			{
 				hoffset = efuse_data;
 				efuse_addr++;
@@ -1639,7 +1575,7 @@ rtl8192d_EfuseGetCurrentSize(
 				hworden =  efuse_data & 0x0F;
 			}
 			word_cnts = Efuse_CalculateWordCnts(hworden);
-			//read next header
+			/* read next header */
 			efuse_addr = efuse_addr + (word_cnts*2)+1;
 		}
 		else
@@ -1676,16 +1612,14 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 	memset((void *)data, 0xff, sizeof(u8)*PGPKT_DATA_SIZE);
 	memset((void *)tmpdata, 0xff, sizeof(u8)*PGPKT_DATA_SIZE);
 
-	//RT_PRINT_DATA(COMP_EFUSE, DBG_LOUD, ("efuse_PgPacketRead-1\n"), data, 8);
-
-	//
-	// <Roger_TODO> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP.
-	// Skip dummy parts to prevent unexpected data read from Efuse.
-	// By pass right now. 2009.02.19.
-	//
+	/*  */
+	/*  <Roger_TODO> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP. */
+	/*  Skip dummy parts to prevent unexpected data read from Efuse. */
+	/*  By pass right now. 2009.02.19. */
+	/*  */
 	while (bContinual && (efuse_addr  < EFUSE_REAL_CONTENT_LEN))
 	{
-		//-------  Header Read -------------
+		/*   Header Read ------------- */
 		if (ReadState & PG_STATE_HEADER)
 		{
 			if (efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest)&&(efuse_data!=0xFF))
@@ -1726,12 +1660,12 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 					}
 					if (bDataEmpty==false) {
 						ReadState = PG_STATE_DATA;
-					} else {//read next header
+					} else {/* read next header */
 						efuse_addr = efuse_addr + (word_cnts*2)+1;
 						ReadState = PG_STATE_HEADER;
 					}
 				}
-				else {//read next header
+				else {/* read next header */
 					efuse_addr = efuse_addr + (word_cnts*2)+1;
 					ReadState = PG_STATE_HEADER;
 				}
@@ -1741,7 +1675,7 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 				bContinual = false ;
 			}
 		}
-		//-------  Data section Read -------------
+		/*   Data section Read ------------- */
 		else if (ReadState & PG_STATE_DATA)
 		{
 			efuse_WordEnableDataRead(hworden,tmpdata,data);
@@ -1750,9 +1684,6 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 		}
 
 	}
-	//efuse_reg_ctrl(pAdapter,false);//power off
-
-	//RT_PRINT_DATA(COMP_EFUSE, DBG_LOUD, ("efuse_PgPacketRead-2\n"), data, 8);
 
 	if (	(data[0]==0xff) &&(data[1]==0xff) && (data[2]==0xff)  && (data[3]==0xff) &&
 		(data[4]==0xff) &&(data[5]==0xff) && (data[6]==0xff)  && (data[7]==0xff))
@@ -1795,40 +1726,34 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 	bool		bExtendedHeader = false;
 	u8	efuseType=EFUSE_WIFI;
 
-	//
-	// <Roger_Notes> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP.
-	// So we have to prevent unexpected data string connection, which will cause
-	// incorrect data auto-load from HW. The total size is equal or smaller than 498bytes
-	// (i.e., offset 0~497, and dummy 1bytes) expected after CP test.
-	// 2009.02.19.
-	//
+	/*  */
+	/*  <Roger_Notes> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP. */
+	/*  So we have to prevent unexpected data string connection, which will cause */
+	/*  incorrect data auto-load from HW. The total size is equal or smaller than 498bytes */
+	/*  (i.e., offset 0~497, and dummy 1bytes) expected after CP test. */
+	/*  2009.02.19. */
+	/*  */
 	if (Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest) >= (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))
 	{
-		//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite error\n"));
 		return false;
 	}
 
-	// Init the 8 bytes content as 0xff
+	/*  Init the 8 bytes content as 0xff */
 	target_pkt.offset = offset;
 	target_pkt.word_en= word_en;
 
-	//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite target offset 0x%x word_en 0x%x\n", target_pkt.offset, target_pkt.word_en));
-
-
 	memset((void *)target_pkt.data, 0xFF, sizeof(u8)*8);
 
 	efuse_WordEnableDataRead(word_en, data, target_pkt.data);
 	target_word_cnts = Efuse_CalculateWordCnts(target_pkt.word_en);
 
-	//efuse_reg_ctrl(pAdapter,true);//power on
-	//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE Power ON\n"));
 
-	//
-	// <Roger_Notes> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP.
-	// So we have to prevent unexpected data string connection, which will cause
-	// incorrect data auto-load from HW. Dummy 1bytes is additional.
-	// 2009.02.19.
-	//
+	/*  */
+	/*  <Roger_Notes> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP. */
+	/*  So we have to prevent unexpected data string connection, which will cause */
+	/*  incorrect data auto-load from HW. Dummy 1bytes is additional. */
+	/*  2009.02.19. */
+	/*  */
 	while (bContinual && (efuse_addr  < (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES)))
 	{
 
@@ -1836,17 +1761,16 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 		{
 			bDataEmpty=true;
 			badworden = 0x0F;
-			//************  so *******************
-			//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE PG_STATE_HEADER\n"));
+			/*   so ******************* */
 			if (	efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) &&
 				(efuse_data!=0xFF))
 			{
-				if ((efuse_data&0x1F) == 0x0F)		//extended header
+				if ((efuse_data&0x1F) == 0x0F)		/* extended header */
 				{
 					tmp_header = efuse_data;
 					efuse_addr++;
 					efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest);
-					if ((efuse_data & 0x0F) == 0x0F)	//wren fail
+					if ((efuse_data & 0x0F) == 0x0F)	/* wren fail */
 					{
 						efuse_addr++;
 						continue;
@@ -1865,43 +1789,35 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 				}
 				tmp_word_cnts =  Efuse_CalculateWordCnts(tmp_pkt.word_en);
 
-				//RTPRINT(FEEPROM, EFUSE_PG, ("section offset 0x%x worden 0x%x\n", tmp_pkt.offset, tmp_pkt.word_en));
-
-				//************  so-1 *******************
+				/*   so-1 ******************* */
 				if (tmp_pkt.offset  != target_pkt.offset)
 				{
-					efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet
+					efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; /* Next pg_packet */
 #if (EFUSE_ERROE_HANDLE == 1)
 					WriteState = PG_STATE_HEADER;
 #endif
 				}
-				else		//write the same offset
+				else		/* write the same offset */
 				{
-					//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite section offset the same\n"));
-
-					//************  so-2 *******************
+					/*   so-2 ******************* */
 					for (tmpindex=0 ; tmpindex<(tmp_word_cnts*2) ; tmpindex++)
 					{
 						if (efuse_OneByteRead(pAdapter, (efuse_addr+1+tmpindex) ,&efuse_data, bPseudoTest)&&(efuse_data != 0xFF)) {
 							bDataEmpty = false;
 						}
 					}
-					//************  so-2-1 *******************
+					/*   so-2-1 ******************* */
 					if (bDataEmpty == false)
 					{
-						//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite section offset the same and data is NOT empty\n"));
-
-						efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet
+						efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; /* Next pg_packet */
 #if (EFUSE_ERROE_HANDLE == 1)
 						WriteState=PG_STATE_HEADER;
 #endif
 					}
 					else
-					{//************  so-2-2 *******************
+					{/*   so-2-2 ******************* */
 
-						//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite section data empty\n"));
-
-						match_word_en = 0x0F;			//same bit as original wren
+						match_word_en = 0x0F;			/* same bit as original wren */
 						if (  !((target_pkt.word_en&BIT0)|(tmp_pkt.word_en&BIT0) ))
 						{
 							 match_word_en &= (~BIT0);
@@ -1919,22 +1835,22 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 							 match_word_en &= (~BIT3);
 						}
 
-						//************  so-2-2-A *******************
+						/*   so-2-2-A ******************* */
 						if ((match_word_en&0x0F)!=0x0F)
 						{
 							badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1, tmp_pkt.word_en ,target_pkt.data, bPseudoTest);
 
-							//************  so-2-2-A-1 *******************
-							//############################
+							/*   so-2-2-A-1 ******************* */
+							/*  */
 							if (0x0F != (badworden&0x0F))
 							{
 								u8	reorg_offset = offset;
 								u8	reorg_worden=badworden;
 								Efuse_PgPacketWrite(pAdapter, reorg_offset, reorg_worden, target_pkt.data, bPseudoTest);
 							}
-							//############################
+							/*  */
 
-							tmp_word_en = 0x0F;		//not the same bit as original wren
+							tmp_word_en = 0x0F;		/* not the same bit as original wren */
 							if ( (target_pkt.word_en&BIT0)^(match_word_en&BIT0) )
 							{
 								tmp_word_en &= (~BIT0);
@@ -1952,15 +1868,14 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 								tmp_word_en &=(~BIT3);
 							}
 
-							//************  so-2-2-A-2 *******************
+							/*   so-2-2-A-2 ******************* */
 							if ((tmp_word_en&0x0F)!=0x0F) {
-								//reorganize other pg packet
-//								efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr
+								/* reorganize other pg packet */
 								efuse_addr = Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest);
-								//===========================
+								/*  */
 								target_pkt.offset = offset;
 								target_pkt.word_en= tmp_word_en;
-								//===========================
+								/*  */
 							} else {
 								bContinual = false;
 							}
@@ -1973,22 +1888,21 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 							}
 #endif
 						}
-						else {//************  so-2-2-B *******************
-							//reorganize other pg packet
-							efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr
-							//===========================
+						else {/*   so-2-2-B ******************* */
+							/* reorganize other pg packet */
+							efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;/* next pg packet addr */
+							/*  */
 							target_pkt.offset = offset;
 							target_pkt.word_en= target_pkt.word_en;
-							//===========================
+							/*  */
 #if (EFUSE_ERROE_HANDLE == 1)
 							WriteState=PG_STATE_HEADER;
 #endif
 						}
 					}
 				}
-				//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE PG_STATE_HEADER-1\n"));
 			}
-			else		//************  s1: header == oxff  *******************
+			else		/*   s1: header == oxff  ******************* */
 			{
 				bExtendedHeader = false;
 
@@ -1996,15 +1910,11 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 				{
 					pg_header = ((target_pkt.offset &0x07) << 5) | 0x0F;
 
-					//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite extended pg_header[2:0] |0x0F 0x%x\n", pg_header));
-
 					efuse_OneByteWrite(pAdapter,efuse_addr, pg_header, bPseudoTest);
 					efuse_OneByteRead(pAdapter,efuse_addr, &tmp_header, bPseudoTest);
 
 					while (tmp_header == 0xFF)
 					{
-						//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite extended pg_header[2:0] wirte fail\n"));
-
 						repeat_times++;
 
 						if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
@@ -2026,8 +1936,6 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 						pg_header_temp = pg_header;
 						pg_header = ((target_pkt.offset & 0x78) << 1) | target_pkt.word_en;
 
-						//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite extended pg_header[6:3] | worden 0x%x word_en 0x%x\n", pg_header));
-
 						efuse_OneByteWrite(pAdapter,efuse_addr, pg_header, bPseudoTest);
 						efuse_OneByteRead(pAdapter,efuse_addr, &tmp_header, bPseudoTest);
 
@@ -2047,7 +1955,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 						if (!bContinual)
 							break;
 
-						if ((tmp_header & 0x0F) == 0x0F)	//wren PG fail
+						if ((tmp_header & 0x0F) == 0x0F)	/* wren PG fail */
 						{
 							repeat_times++;
 
@@ -2062,7 +1970,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 								continue;
 							}
 						}
-						else if (pg_header != tmp_header)	//offset PG fail
+						else if (pg_header != tmp_header)	/* offset PG fail */
 						{
 							bExtendedHeader = true;
 							tmp_pkt.offset = ((pg_header_temp & 0xE0) >> 5) | ((tmp_header & 0xF0) >> 1);
@@ -2070,7 +1978,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 							tmp_word_cnts =  Efuse_CalculateWordCnts(tmp_pkt.word_en);
 						}
 					}
-					else if ((tmp_header & 0x1F) == 0x0F)		//wrong extended header
+					else if ((tmp_header & 0x1F) == 0x0F)		/* wrong extended header */
 					{
 						efuse_addr+=2;
 						continue;
@@ -2084,12 +1992,12 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 				}
 
 				if (tmp_header == pg_header)
-				{ //************  s1-1*******************
+				{ /*   s1-1******************* */
 					WriteState = PG_STATE_DATA;
 				}
 #if (EFUSE_ERROE_HANDLE == 1)
-				else if (tmp_header == 0xFF) {//************  s1-3: if Write or read func doesn't work *******************
-					//efuse_addr doesn't change
+				else if (tmp_header == 0xFF) {/*   s1-3: if Write or read func doesn't work ******************* */
+					/* efuse_addr doesn't change */
 					WriteState = PG_STATE_HEADER;
 					repeat_times++;
 					if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
@@ -2099,7 +2007,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 				}
 #endif
 				else
-				{//************  s1-2 : fixed the header procedure *******************
+				{/*   s1-2 : fixed the header procedure ******************* */
 					if (!bExtendedHeader)
 					{
 						tmp_pkt.offset = (tmp_header>>4) & 0x0F;
@@ -2107,15 +2015,13 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 						tmp_word_cnts =  Efuse_CalculateWordCnts(tmp_pkt.word_en);
 					}
 
-					//************  s1-2-A :cover the exist data *******************
-					//memset(originaldata,0xff,sizeof(UINT8)*8);
+					/*   s1-2-A :cover the exist data ******************* */
 					memset((void *)originaldata, 0xff, sizeof(u8)*8);
 
 					if (Efuse_PgPacketRead(pAdapter, tmp_pkt.offset,originaldata, bPseudoTest))
-					{	//check if data exist
-						//efuse_reg_ctrl(pAdapter,true);//power on
+					{	/* check if data exist */
 						badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,tmp_pkt.word_en,originaldata, bPseudoTest);
-						//############################
+						/*  */
 						if (0x0F != (badworden&0x0F))
 						{
 							u8	reorg_offset = tmp_pkt.offset;
@@ -2123,15 +2029,15 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 							Efuse_PgPacketWrite(pAdapter,reorg_offset,reorg_worden,originaldata, bPseudoTest);
 							efuse_addr = Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest);
 						}
-						//############################
+						/*  */
 						else {
-							efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet
+							efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; /* Next pg_packet */
 						}
 					}
-					 //************  s1-2-B: wrong address*******************
+					 /*   s1-2-B: wrong address******************* */
 					else
 					{
-						efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet
+						efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; /* Next pg_packet */
 					}
 
 #if (EFUSE_ERROE_HANDLE == 1)
@@ -2142,32 +2048,29 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 						bResult = false;
 					}
 #endif
-
-					//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE PG_STATE_HEADER-2\n"));
 				}
 
 			}
 
 		}
-		//write data state
+		/* write data state */
 		else if (WriteState==PG_STATE_DATA)
-		{	//************  s1-1  *******************
-			//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE PG_STATE_DATA\n"));
+		{	/*   s1-1  ******************* */
 			badworden = 0x0f;
 			badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,target_pkt.word_en,target_pkt.data , bPseudoTest);
 			if ((badworden&0x0F)==0x0F)
-			{ //************  s1-1-A *******************
+			{ /*   s1-1-A ******************* */
 				bContinual = false;
 			}
 			else
-			{//reorganize other pg packet //************  s1-1-B *******************
-				efuse_addr = efuse_addr + (2*target_word_cnts) +1;//next pg packet addr
+			{/* reorganize other pg packet ************  s1-1-B ******************* */
+				efuse_addr = efuse_addr + (2*target_word_cnts) +1;/* next pg packet addr */
 
-				//===========================
+				/*  */
 				target_pkt.offset = offset;
 				target_pkt.word_en= badworden;
 				target_word_cnts =  Efuse_CalculateWordCnts(target_pkt.word_en);
-				//===========================
+				/*  */
 #if (EFUSE_ERROE_HANDLE == 1)
 				WriteState=PG_STATE_HEADER;
 				repeat_times++;
@@ -2176,17 +2079,9 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 					bResult = false;
 				}
 #endif
-				//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE PG_STATE_HEADER-3\n"));
 			}
 		}
 	}
-
-	if (efuse_addr  >= (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))
-	{
-		//RT_TRACE(COMP_EFUSE, DBG_LOUD, ("efuse_PgPacketWrite(): efuse_addr(%#x) Out of size!!\n", efuse_addr));
-	}
-	//efuse_reg_ctrl(pAdapter,false);//power off
-
 	return true;
 }
 
@@ -2202,12 +2097,7 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 	u8	badworden = 0x0F;
 	u8	tmpdata[8];
 
-	//memset(tmpdata,0xff,PGPKT_DATA_SIZE);
 	memset((void *)tmpdata, 0xff, PGPKT_DATA_SIZE);
-	//RT_TRACE(COMP_EFUSE, DBG_LOUD, ("word_en = %x efuse_addr=%x\n", word_en, efuse_addr));
-
-	//RT_PRINT_DATA(COMP_EFUSE, DBG_LOUD, ("U-EFUSE\n"), data, 8);
-
 	if (!(word_en&BIT0))
 	{
 		tmpaddr = start_addr;
@@ -2322,7 +2212,7 @@ void rtl8192d_set_hal_ops(struct hal_ops
 	pHalFunc->read_rfreg = &rtl8192d_PHY_QueryRFReg;
 	pHalFunc->write_rfreg = &rtl8192d_PHY_SetRFReg;
 
-	//Efuse related function
+	/* Efuse related function */
 	pHalFunc->EfusePowerSwitch = &rtl8192d_EfusePowerSwitch;
 	pHalFunc->ReadEFuse = &rtl8192d_ReadEFuse;
 	pHalFunc->EFUSEGetEfuseDefinition = &rtl8192d_EFUSE_GetEfuseDefinition;
--- a/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
@@ -71,7 +71,7 @@ extern atomic_t GlobalCounterForMutex;
 
 
 /*--------------------Define export function prototype-----------------------*/
-// Please refer to header file
+/*  Please refer to header file */
 /*--------------------Define export function prototype-----------------------*/
 
 /*---------------------Define local function prototype-----------------------*/
@@ -160,9 +160,9 @@ u8 rtl8192d_GetRightChnlPlaceforIQK(u8 c
 }
 
 
-//
-// 1. BB register R/W API
-//
+/*  */
+/*  1. BB register R/W API */
+/*  */
 /**
 * Function:	phy_CalculateBitShift
 *
@@ -190,9 +190,9 @@ phy_CalculateBitShift(
 	return (i);
 }
 
-//
-//To avoid miswrite Reg0x800 for 92D
-//
+/*  */
+/* To avoid miswrite Reg0x800 for 92D */
+/*  */
 void
 rtl8192d_PHY_SetBBReg1Byte(
 	struct rtw_adapter *	Adapter,
@@ -207,7 +207,7 @@ rtl8192d_PHY_SetBBReg1Byte(
 #if (DISABLE_BB_RF == 1)
 	return;
 #endif
-	// BitMask only support bit0~bit7 or bit8~bit15,bit16~bit23,bit24~bit31,should in 1 byte scale;
+	/*  BitMask only support bit0~bit7 or bit8~bit15,bit16~bit23,bit24~bit31,should in 1 byte scale; */
 	BitShift = phy_CalculateBitShift(BitMask);
 	offset = BitShift /8;
 
@@ -217,7 +217,6 @@ rtl8192d_PHY_SetBBReg1Byte(
 	value =(u8)(Data>>(8*offset));
 
 	rtw_write8(Adapter, RegAddr+offset, value);
-	//RT_TRACE(COMP_INIT,DBG_TRACE,("Write Reg0x800 originalvalue %x  to set 1byte value %x Data %x offset %x\n",OriginalValue,value,Data,offset));
 }
 
 /**
@@ -227,11 +226,11 @@ rtl8192d_PHY_SetBBReg1Byte(
 *
 * Input:
 *			struct rtw_adapter *		Adapter,
-*			u4Byte			RegAddr,		//The target address to be readback
-*			u4Byte			BitMask		//The target bit position in the target address
-*										//to be readback
+*			u4Byte			RegAddr,	The target address to be readback
+*			u4Byte			BitMask		The target bit position in the target address
+*								to be readback
 * Output:	None
-* Return:		u4Byte			Data			//The readback register value
+* Return:		u4Byte			Data		The readback register value
 * Note:		This function is equal to "GetRegSetting" in PHY programming guide
 */
 u32
@@ -260,11 +259,11 @@ rtl8192d_PHY_QueryBBReg(
 *
 * Input:
 *			struct rtw_adapter *		Adapter,
-*			u4Byte			RegAddr,		//The target address to be modified
-*			u4Byte			BitMask		//The target bit position in the target address
-*										//to be modified
-*			u4Byte			Data			//The new register value in the target bit position
-*										//of the target address
+*			u4Byte			RegAddr,	The target address to be modified
+*			u4Byte			BitMask		The target bit position in the target address
+*								to be modified
+*			u4Byte			Data		The new register value in the target bit position
+*								of the target address
 *
 * Output:	None
 * Return:		None
@@ -286,7 +285,7 @@ rtl8192d_PHY_SetBBReg(
 #endif
 
 	if (BitMask!= bMaskDWord)
-	{//if not "double word" write
+	{/* if not "double word" write */
 		OriginalValue = rtw_read32(Adapter, RegAddr);
 		BitShift = phy_CalculateBitShift(BitMask);
 		Data = ((OriginalValue & (~BitMask)) | ((Data << BitShift) & BitMask));
@@ -295,9 +294,9 @@ rtl8192d_PHY_SetBBReg(
 	rtw_write32(Adapter, RegAddr, Data);
 }
 
-//
-// 2. RF register R/W API
-//
+/*  */
+/*  2. RF register R/W API */
+/*  */
 /*-----------------------------------------------------------------------------
  * Function:	phy_FwRFSerialRead()
  *
@@ -321,7 +320,6 @@ phy_FwRFSerialRead(
 	u32				Offset	)
 {
 	u32		retValue = 0;
-	//RT_ASSERT(FALSE,("deprecate!\n"));
 	return	(retValue);
 }	/* phy_FwRFSerialRead */
 
@@ -358,8 +356,8 @@ phy_FwRFSerialWrite(
 *
 * Input:
 *			struct rtw_adapter *		Adapter,
-*			enum RF_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
-*			u4Byte			Offset,		//The target address to be read
+*			enum RF_RADIO_PATH_E	eRFPath,	Radio path of A/B/C/D
+*			u4Byte			Offset,		The target address to be read
 *
 * Output:	None
 * Return:		u4Byte			reback value
@@ -386,9 +384,9 @@ phy_RFSerialRead(
 	u8	i;
 	u32	MaskforPhySet=0;
 
-	//
-	// Make sure RF register offset is correct
-	//
+	/*  */
+	/*  Make sure RF register offset is correct */
+	/*  */
 	if (Offset & MAC1_ACCESS_PHY0)
 		MaskforPhySet = MAC1_ACCESS_PHY0;
 	else if (Offset & MAC0_ACCESS_PHY1)
@@ -396,35 +394,27 @@ phy_RFSerialRead(
 
 	Offset &=0x7F;
 
-	//
-	// Switch page for 8256 RF IC
-	//
+	/*  */
+	/*  Switch page for 8256 RF IC */
+	/*  */
 	NewOffset = Offset;
 
-	// 2009/06/17 MH We can not execute IO for power save or other accident mode.
-	//if (RT_CANNOT_IO(Adapter))
-	//{
-	//	RTPRINT(FPHY, PHY_RFR, ("phy_RFSerialRead return all one\n"));
-	//	return	0xFFFFFFFF;
-	//}
-
-	// For 92S LSSI Read RFLSSIRead
-	// For RF A/B write 0x824/82c(does not work in the future)
-	// We must use 0x824 for RF A and B to execute read trigger
+	/*  For 92S LSSI Read RFLSSIRead */
+	/*  For RF A/B write 0x824/82c(does not work in the future) */
+	/*  We must use 0x824 for RF A and B to execute read trigger */
 	tmplong = PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord);
 	if (eRFPath == RF_PATH_A)
 		tmplong2 = tmplong;
 	else
 		tmplong2 = PHY_QueryBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, bMaskDWord);
 
-	tmplong2 = (tmplong2 & (~bLSSIReadAddress)) | (NewOffset<<23) | bLSSIReadEdge;	//T65 RF
+	tmplong2 = (tmplong2 & (~bLSSIReadAddress)) | (NewOffset<<23) | bLSSIReadEdge;	/* T65 RF */
 
 	PHY_SetBBReg(Adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord, tmplong&(~bLSSIReadEdge));
 	rtw_udelay_os(10);
 
 	PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, bMaskDWord, tmplong2);
-	//rtw_udelay_os(1000);
-	for (i=0;i<2;i++)
+	for (i = 0; i < 2; i++)
 		rtw_udelay_os(MAX_STALL_TIME);
 	PHY_SetBBReg(Adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord, tmplong|bLSSIReadEdge);
 	rtw_udelay_os(10);
@@ -434,17 +424,13 @@ phy_RFSerialRead(
 	else if (eRFPath == RF_PATH_B)
 		RfPiEnable = (u8)PHY_QueryBBReg(Adapter, rFPGA0_XB_HSSIParameter1|MaskforPhySet, BIT8);
 
-	if (RfPiEnable)
-	{	// Read from BBreg8b8, 12 bits for 8190, 20bits for T65 RF
+	if (RfPiEnable) {
+		/*  Read from BBreg8b8, 12 bits for 8190, 20bits for T65 RF */
 		retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBackPi|MaskforPhySet, bLSSIReadBackData);
-		//RTPRINT(FINIT, INIT_RF, ("Readback from RF-PI : 0x%x\n", retValue));
-	}
-	else
-	{	//Read from BBreg8a0, 12 bits for 8190, 20 bits for T65 RF
+	} else {
+		/* Read from BBreg8a0, 12 bits for 8190, 20 bits for T65 RF */
 		retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBack|MaskforPhySet, bLSSIReadBackData);
-		//RTPRINT(FINIT, INIT_RF,("Readback from RF-SI : 0x%x\n", retValue));
 	}
-	//RTPRINT(FPHY, PHY_RFR, ("RFR-%d Addr[0x%lx]=0x%lx\n", eRFPath, pPhyReg->rfLSSIReadBack, retValue));
 
 	return retValue;
 }
@@ -458,10 +444,10 @@ phy_RFSerialRead(
 *
 * Input:
 *			struct rtw_adapter *		Adapter,
-*			enum RF_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
-*			u4Byte			Offset,		//The target address to be read
-*			u4Byte			Data			//The new register Data in the target bit position
-*										//of the target to be read
+*			enum RF_RADIO_PATH_E	eRFPath,	Radio path of A/B/C/D
+*			u4Byte			Offset,		The target address to be read
+*			u4Byte			Data		The new register Data in the target bit position
+*								of the target to be read
 *
 * Output:	None
 * Return:		None
@@ -508,12 +494,7 @@ phy_RFSerialWrite(
 	u32	NewOffset,MaskforPhySet=0;
 
 
-	// 2009/06/17 MH We can not execute IO for power save or other accident mode.
-	//if (RT_CANNOT_IO(Adapter))
-	//{
-	//	RTPRINT(FPHY, PHY_RFW, ("phy_RFSerialWrite stop\n"));
-	//	return;
-	//}
+	/*  2009/06/17 MH We can not execute IO for power save or other accident mode. */
 
 	if (Offset & MAC1_ACCESS_PHY0)
 		MaskforPhySet = MAC1_ACCESS_PHY0;
@@ -522,30 +503,27 @@ phy_RFSerialWrite(
 
 	Offset &=0x7F;
 
-	//
-	//92D RF offset >0x3f
+	/*  */
+	/* 92D RF offset >0x3f */
 
-	//
-	// Shadow Update
-	//
-	//PHY_RFShadowWrite(Adapter, eRFPath, Offset, Data);
-
-	//
-	// Switch page for 8256 RF IC
-	//
+	/*  */
+	/*  Shadow Update */
+	/*  */
+
+	/*  */
+	/*  Switch page for 8256 RF IC */
+	/*  */
 	NewOffset = Offset;
 
-	//
-	// Put write addr in [5:0]  and write data in [31:16]
-	//
-	//DataAndAddr = (Data<<16) | (NewOffset&0x3f);
-	DataAndAddr = ((NewOffset<<20) | (Data&0x000fffff)) & 0x0fffffff;	// T65 RF
-
-	//
-	// Write Operation
-	//
+	/*  */
+	/*  Put write addr in [5:0]  and write data in [31:16] */
+	/*  */
+	DataAndAddr = ((NewOffset<<20) | (Data&0x000fffff)) & 0x0fffffff;	/*  T65 RF */
+
+	/*  */
+	/*  Write Operation */
+	/*  */
 	PHY_SetBBReg(Adapter, pPhyReg->rf3wireOffset|MaskforPhySet, bMaskDWord, DataAndAddr);
-	//RTPRINT(FPHY, PHY_RFW, ("RFW-%d Addr[0x%lx]=0x%lx\n", eRFPath, pPhyReg->rf3wireOffset, DataAndAddr));
 }
 
 
@@ -556,10 +534,10 @@ phy_RFSerialWrite(
 *
 * Input:
 *			struct rtw_adapter *		Adapter,
-*			enum RF_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
-*			u4Byte			RegAddr,		//The target address to be read
-*			u4Byte			BitMask		//The target bit position in the target address
-*										//to be read
+*			enum RF_RADIO_PATH_E	eRFPath,	Radio path of A/B/C/D
+*			u4Byte			RegAddr,	The target address to be read
+*			u4Byte			BitMask		The target bit position in the target address
+*								to be read
 *
 * Output:	None
 * Return:		u4Byte			Readback value
@@ -575,7 +553,6 @@ rtl8192d_PHY_QueryRFReg(
 {
 	u32 Original_Value, Readback_Value, BitShift;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	//u8	RFWaitCounter = 0;
 
 #if (DISABLE_BB_RF == 1)
 	return 0;
@@ -585,7 +562,7 @@ rtl8192d_PHY_QueryRFReg(
 		return 0;
 
 	if (pHalData->bReadRFbyFW)
-		Original_Value = rtw_read32(Adapter,(0x66<<24|eRFPath<<16)|RegAddr); //0x66 Just a identifier.by wl
+		Original_Value = rtw_read32(Adapter,(0x66<<24|eRFPath<<16)|RegAddr); /* 0x66 Just a identifier.by wl */
 	else
 		Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
 
@@ -602,12 +579,12 @@ rtl8192d_PHY_QueryRFReg(
 *
 * Input:
 *			struct rtw_adapter *		Adapter,
-*			enum RF_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
-*			u4Byte			RegAddr,		//The target address to be modified
-*			u4Byte			BitMask		//The target bit position in the target address
-*										//to be modified
-*			u4Byte			Data			//The new register Data in the target bit position
-*										//of the target address
+*			enum RF_RADIO_PATH_E	eRFPath,	Radio path of A/B/C/D
+*			u4Byte			RegAddr,	The target address to be modified
+*			u4Byte			BitMask		The target bit position in the target address
+*								to be modified
+*			u4Byte			Data		The new register Data in the target bit position
+*								of the target address
 *
 * Output:	None
 * Return:		None
@@ -636,7 +613,7 @@ rtl8192d_PHY_SetRFReg(
 	if (BitMask == 0)
 		return;
 
-	// RF data is 12 bits only
+	/*  RF data is 12 bits only */
 	if (BitMask != bRFRegOffsetMask)
 	{
 		Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
@@ -647,9 +624,9 @@ rtl8192d_PHY_SetRFReg(
 	phy_RFSerialWrite(Adapter, eRFPath, RegAddr, Data);
 }
 
-//
-// 3. Initial MAC/BB/RF config by reading MAC/BB/RF txt.
-//
+/*  */
+/*  3. Initial MAC/BB/RF config by reading MAC/BB/RF txt. */
+/*  */
 
 /*-----------------------------------------------------------------------------
  * Function:    phy_ConfigMACWithParaFile()
@@ -680,7 +657,7 @@ phy_ConfigMACWithParaFile(
 
 	return rtStatus;
 }
-#endif //CONFIG_EMBEDDED_FWIMG
+#endif /* CONFIG_EMBEDDED_FWIMG */
 /*-----------------------------------------------------------------------------
  * Function:    phy_ConfigMACWithHeaderFile()
  *
@@ -707,14 +684,12 @@ phy_ConfigMACWithHeaderFile(
 	u32*				ptrArray;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
-	//2008.11.06 Modified by tynli.
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Read Rtl819XMACPHY_Array\n"));
+	/* 2008.11.06 Modified by tynli. */
 
 	ArrayLength = Rtl8192D_MAC_ArrayLength;
 	ptrArray = (u32 *)Rtl8192D_MAC_Array;
-	//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> phy_ConfigMACWithHeaderFile() Img:Rtl819XMAC_Array\n"));
 
-	for (i = 0 ;i < ArrayLength;i=i+2) { // Add by tynli for 2 column
+	for (i = 0 ;i < ArrayLength;i=i+2) { /*  Add by tynli for 2 column */
 		rtw_write8(Adapter, ptrArray[i], (u8)ptrArray[i+1]);
 	}
 
@@ -754,28 +729,25 @@ PHY_MACConfig8192D(
 
 	pszMACRegFile = sz92DMACRegFile;
 
-	//
-	// Config MAC
-	//
+	/*  */
+	/*  Config MAC */
+	/*  */
 #ifdef CONFIG_EMBEDDED_FWIMG
 	rtStatus = phy_ConfigMACWithHeaderFile(Adapter);
 #else
 
-	// Not make sure EEPROM, add later
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Read MACREG.txt\n"));
+	/*  Not make sure EEPROM, add later */
 	rtStatus = phy_ConfigMACWithParaFile(Adapter, pszMACRegFile);
 #endif
 
 	if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY)
 	{
-		//improve 2-stream TX EVM by Jenyu
-		//rtw_write8(Adapter, 0x14,0x71);
-		// 2010.07.13 AMPDU aggregation number 9
-		//rtw_write16(Adapter, REG_MAX_AGGR_NUM, MAX_AGGR_NUM);
-		rtw_write8(Adapter, REG_MAX_AGGR_NUM, 0x0B); //By tynli. 2010.11.18.
+		/* improve 2-stream TX EVM by Jenyu */
+		/*  2010.07.13 AMPDU aggregation number 9 */
+		rtw_write8(Adapter, REG_MAX_AGGR_NUM, 0x0B); /* By tynli. 2010.11.18. */
 	}
 	else
-		rtw_write8(Adapter, REG_MAX_AGGR_NUM, 0x07); //92D need to test to decide the num.
+		rtw_write8(Adapter, REG_MAX_AGGR_NUM, 0x07); /* 92D need to test to decide the num. */
 
 	return rtStatus;
 }
@@ -800,103 +772,101 @@ phy_InitBBRFRegisterDefinition(
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
-	// RF Interface Sowrtware Control
-	pHalData->PHYRegDef[RF_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW; // 16 LSBs if read 32-bit from 0x870
-	pHalData->PHYRegDef[RF_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW; // 16 MSBs if read 32-bit from 0x870 (16-bit for 0x872)
-	pHalData->PHYRegDef[RF_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;// 16 LSBs if read 32-bit from 0x874
-	pHalData->PHYRegDef[RF_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;// 16 MSBs if read 32-bit from 0x874 (16-bit for 0x876)
-
-	// RF Interface Readback Value
-	pHalData->PHYRegDef[RF_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB; // 16 LSBs if read 32-bit from 0x8E0
-	pHalData->PHYRegDef[RF_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;// 16 MSBs if read 32-bit from 0x8E0 (16-bit for 0x8E2)
-	pHalData->PHYRegDef[RF_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;// 16 LSBs if read 32-bit from 0x8E4
-	pHalData->PHYRegDef[RF_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;// 16 MSBs if read 32-bit from 0x8E4 (16-bit for 0x8E6)
-
-	// RF Interface Output (and Enable)
-	pHalData->PHYRegDef[RF_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE; // 16 LSBs if read 32-bit from 0x860
-	pHalData->PHYRegDef[RF_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE; // 16 LSBs if read 32-bit from 0x864
-
-	// RF Interface (Output and)  Enable
-	pHalData->PHYRegDef[RF_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE; // 16 MSBs if read 32-bit from 0x860 (16-bit for 0x862)
-	pHalData->PHYRegDef[RF_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE; // 16 MSBs if read 32-bit from 0x864 (16-bit for 0x866)
+	/*  RF Interface Sowrtware Control */
+	pHalData->PHYRegDef[RF_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW; /*  16 LSBs if read 32-bit from 0x870 */
+	pHalData->PHYRegDef[RF_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW; /*  16 MSBs if read 32-bit from 0x870 (16-bit for 0x872) */
+	pHalData->PHYRegDef[RF_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;/*  16 LSBs if read 32-bit from 0x874 */
+	pHalData->PHYRegDef[RF_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;/*  16 MSBs if read 32-bit from 0x874 (16-bit for 0x876) */
+
+	/*  RF Interface Readback Value */
+	pHalData->PHYRegDef[RF_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB; /*  16 LSBs if read 32-bit from 0x8E0 */
+	pHalData->PHYRegDef[RF_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;/*  16 MSBs if read 32-bit from 0x8E0 (16-bit for 0x8E2) */
+	pHalData->PHYRegDef[RF_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;/*  16 LSBs if read 32-bit from 0x8E4 */
+	pHalData->PHYRegDef[RF_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;/*  16 MSBs if read 32-bit from 0x8E4 (16-bit for 0x8E6) */
+
+	/*  RF Interface Output (and Enable) */
+	pHalData->PHYRegDef[RF_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE; /*  16 LSBs if read 32-bit from 0x860 */
+	pHalData->PHYRegDef[RF_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE; /*  16 LSBs if read 32-bit from 0x864 */
+
+	/*  RF Interface (Output and)  Enable */
+	pHalData->PHYRegDef[RF_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE; /*  16 MSBs if read 32-bit from 0x860 (16-bit for 0x862) */
+	pHalData->PHYRegDef[RF_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE; /*  16 MSBs if read 32-bit from 0x864 (16-bit for 0x866) */
 
-	//Addr of LSSI. Wirte RF register by driver
-	pHalData->PHYRegDef[RF_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter; //LSSI Parameter
+	/* Addr of LSSI. Wirte RF register by driver */
+	pHalData->PHYRegDef[RF_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter; /* LSSI Parameter */
 	pHalData->PHYRegDef[RF_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;
 
-	// RF parameter
-	pHalData->PHYRegDef[RF_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;  //BB Band Select
+	/*  RF parameter */
+	pHalData->PHYRegDef[RF_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;  /* BB Band Select */
 	pHalData->PHYRegDef[RF_PATH_B].rfLSSI_Select = rFPGA0_XAB_RFParameter;
 	pHalData->PHYRegDef[RF_PATH_C].rfLSSI_Select = rFPGA0_XCD_RFParameter;
 	pHalData->PHYRegDef[RF_PATH_D].rfLSSI_Select = rFPGA0_XCD_RFParameter;
 
-	// Tx AGC Gain Stage (same for all path. Should we remove this?)
-	pHalData->PHYRegDef[RF_PATH_A].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
-	pHalData->PHYRegDef[RF_PATH_B].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
-	pHalData->PHYRegDef[RF_PATH_C].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
-	pHalData->PHYRegDef[RF_PATH_D].rfTxGainStage = rFPGA0_TxGainStage; //Tx gain stage
-
-	// Tranceiver A~D HSSI Parameter-1
-	pHalData->PHYRegDef[RF_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;  //wire control parameter1
-	pHalData->PHYRegDef[RF_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;  //wire control parameter1
-
-	// Tranceiver A~D HSSI Parameter-2
-	pHalData->PHYRegDef[RF_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;  //wire control parameter2
-	pHalData->PHYRegDef[RF_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;  //wire control parameter2
+	/*  Tx AGC Gain Stage (same for all path. Should we remove this?) */
+	pHalData->PHYRegDef[RF_PATH_A].rfTxGainStage = rFPGA0_TxGainStage; /* Tx gain stage */
+	pHalData->PHYRegDef[RF_PATH_B].rfTxGainStage = rFPGA0_TxGainStage; /* Tx gain stage */
+	pHalData->PHYRegDef[RF_PATH_C].rfTxGainStage = rFPGA0_TxGainStage; /* Tx gain stage */
+	pHalData->PHYRegDef[RF_PATH_D].rfTxGainStage = rFPGA0_TxGainStage; /* Tx gain stage */
+
+	/*  Tranceiver A~D HSSI Parameter-1 */
+	pHalData->PHYRegDef[RF_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;  /* wire control parameter1 */
+	pHalData->PHYRegDef[RF_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;  /* wire control parameter1 */
+
+	/*  Tranceiver A~D HSSI Parameter-2 */
+	pHalData->PHYRegDef[RF_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;  /* wire control parameter2 */
+	pHalData->PHYRegDef[RF_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;  /* wire control parameter2 */
 
-	// RF switch Control
-	pHalData->PHYRegDef[RF_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl; //TR/Ant switch control
+	/*  RF switch Control */
+	pHalData->PHYRegDef[RF_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl; /* TR/Ant switch control */
 	pHalData->PHYRegDef[RF_PATH_B].rfSwitchControl = rFPGA0_XAB_SwitchControl;
 	pHalData->PHYRegDef[RF_PATH_C].rfSwitchControl = rFPGA0_XCD_SwitchControl;
 	pHalData->PHYRegDef[RF_PATH_D].rfSwitchControl = rFPGA0_XCD_SwitchControl;
 
-	// AGC control 1
+	/*  AGC control 1 */
 	pHalData->PHYRegDef[RF_PATH_A].rfAGCControl1 = rOFDM0_XAAGCCore1;
 	pHalData->PHYRegDef[RF_PATH_B].rfAGCControl1 = rOFDM0_XBAGCCore1;
 	pHalData->PHYRegDef[RF_PATH_C].rfAGCControl1 = rOFDM0_XCAGCCore1;
 	pHalData->PHYRegDef[RF_PATH_D].rfAGCControl1 = rOFDM0_XDAGCCore1;
 
-	// AGC control 2
+	/*  AGC control 2 */
 	pHalData->PHYRegDef[RF_PATH_A].rfAGCControl2 = rOFDM0_XAAGCCore2;
 	pHalData->PHYRegDef[RF_PATH_B].rfAGCControl2 = rOFDM0_XBAGCCore2;
 	pHalData->PHYRegDef[RF_PATH_C].rfAGCControl2 = rOFDM0_XCAGCCore2;
 	pHalData->PHYRegDef[RF_PATH_D].rfAGCControl2 = rOFDM0_XDAGCCore2;
 
-	// RX AFE control 1
+	/*  RX AFE control 1 */
 	pHalData->PHYRegDef[RF_PATH_A].rfRxIQImbalance = rOFDM0_XARxIQImbalance;
 	pHalData->PHYRegDef[RF_PATH_B].rfRxIQImbalance = rOFDM0_XBRxIQImbalance;
 	pHalData->PHYRegDef[RF_PATH_C].rfRxIQImbalance = rOFDM0_XCRxIQImbalance;
 	pHalData->PHYRegDef[RF_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;
 
-	// RX AFE control 1
+	/*  RX AFE control 1 */
 	pHalData->PHYRegDef[RF_PATH_A].rfRxAFE = rOFDM0_XARxAFE;
 	pHalData->PHYRegDef[RF_PATH_B].rfRxAFE = rOFDM0_XBRxAFE;
 	pHalData->PHYRegDef[RF_PATH_C].rfRxAFE = rOFDM0_XCRxAFE;
 	pHalData->PHYRegDef[RF_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;
 
-	// Tx AFE control 1
+	/*  Tx AFE control 1 */
 	pHalData->PHYRegDef[RF_PATH_A].rfTxIQImbalance = rOFDM0_XATxIQImbalance;
 	pHalData->PHYRegDef[RF_PATH_B].rfTxIQImbalance = rOFDM0_XBTxIQImbalance;
 	pHalData->PHYRegDef[RF_PATH_C].rfTxIQImbalance = rOFDM0_XCTxIQImbalance;
 	pHalData->PHYRegDef[RF_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;
 
-	// Tx AFE control 2
+	/*  Tx AFE control 2 */
 	pHalData->PHYRegDef[RF_PATH_A].rfTxAFE = rOFDM0_XATxAFE;
 	pHalData->PHYRegDef[RF_PATH_B].rfTxAFE = rOFDM0_XBTxAFE;
 	pHalData->PHYRegDef[RF_PATH_C].rfTxAFE = rOFDM0_XCTxAFE;
 	pHalData->PHYRegDef[RF_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;
 
-	// Tranceiver LSSI Readback SI mode
+	/*  Tranceiver LSSI Readback SI mode */
 	pHalData->PHYRegDef[RF_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;
 	pHalData->PHYRegDef[RF_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;
 	pHalData->PHYRegDef[RF_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;
 	pHalData->PHYRegDef[RF_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;
 
-	// Tranceiver LSSI Readback PI mode
+	/*  Tranceiver LSSI Readback PI mode */
 	pHalData->PHYRegDef[RF_PATH_A].rfLSSIReadBackPi = TransceiverA_HSPI_Readback;
 	pHalData->PHYRegDef[RF_PATH_B].rfLSSIReadBackPi = TransceiverB_HSPI_Readback;
-	//pHalData->PHYRegDef[RF_PATH_C].rfLSSIReadBackPi = rFPGA0_XC_LSSIReadBack;
-	//pHalData->PHYRegDef[RF_PATH_D].rfLSSIReadBackPi = rFPGA0_XD_LSSIReadBack;
 	pHalData->bPhyValueInitReady = true;
 }
 
@@ -930,37 +900,25 @@ phy_ConfigBBWithHeaderFile(
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
 
-	//Normal chip,Mac0 use AGC_TAB.txt for 2G and 5G band.
-	if (pHalData->interfaceIndex == 0)
-	{
+	/* Normal chip,Mac0 use AGC_TAB.txt for 2G and 5G band. */
+	if (pHalData->interfaceIndex == 0) {
 		AGCTAB_ArrayLen = Rtl8192D_AGCTAB_ArrayLength;
 		Rtl819XAGCTAB_Array_Table = (u32 *)Rtl8192D_AGCTAB_Array;
-		//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> phy_ConfigBBWithHeaderFile() phy:MAC0, Rtl819XAGCTAB_Array\n"));
-	}
-	else
-	{
-		if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
-		{
+	} else {
+		if (pHalData->CurrentBandType92D == BAND_ON_2_4G) {
 			AGCTAB_ArrayLen = Rtl8192D_AGCTAB_2GArrayLength;
 			Rtl819XAGCTAB_Array_Table = (u32 *)Rtl8192D_AGCTAB_2GArray;
-			//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> phy_ConfigBBWithHeaderFile() phy:MAC1, Rtl819XAGCTAB_2GArray\n"));
-		}
-		else
-		{
+		} else {
 			AGCTAB_5GArrayLen = Rtl8192D_AGCTAB_5GArrayLength;
 			Rtl819XAGCTAB_5GArray_Table = (u32 *)Rtl8192D_AGCTAB_5GArray;
-			//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> phy_ConfigBBWithHeaderFile() phy:MAC1, Rtl819XAGCTAB_5GArray\n"));
 		}
 	}
 
 	PHY_REGArrayLen = Rtl8192D_PHY_REG_2TArrayLength;
 	Rtl819XPHY_REGArray_Table = (u32 *)Rtl8192D_PHY_REG_2TArray;
-	//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> phy_ConfigBBWithHeaderFile() phy:Rtl819XPHY_REG_Array_PG\n"));
 
-	if (ConfigType == BaseBand_Config_PHY_REG)
-	{
-		for (i=0;i<PHY_REGArrayLen;i=i+2)
-		{
+	if (ConfigType == BaseBand_Config_PHY_REG) {
+		for (i = 0; i < PHY_REGArrayLen; i = i+2) {
 			if (Rtl819XPHY_REGArray_Table[i] == 0xfe || Rtl819XPHY_REGArray_Table[i] == 0xffe) {
 				#ifdef CONFIG_LONG_DELAY_ISSUE
 				rtw_msleep_os(50);
@@ -982,55 +940,37 @@ phy_ConfigBBWithHeaderFile(
 				pdmpriv->RegA24 = Rtl819XPHY_REGArray_Table[i+1];
 			PHY_SetBBReg(Adapter, Rtl819XPHY_REGArray_Table[i], bMaskDWord, Rtl819XPHY_REGArray_Table[i+1]);
 
-			// Add 1us delay between BB/RF register setting.
+			/*  Add 1us delay between BB/RF register setting. */
 			rtw_udelay_os(1);
-
-			//RT_TRACE(COMP_INIT, DBG_TRACE, ("The Rtl819XPHY_REGArray_Table[0] is %lx Rtl819XPHY_REGArray[1] is %lx\n",Rtl819XPHY_REGArray_Table[i], Rtl819XPHY_REGArray_Table[i+1]));
 		}
-	}
-	else if (ConfigType == BaseBand_Config_AGC_TAB)
-	{
-		//especial for 5G, vivi, 20100528
-		if (pHalData->interfaceIndex == 0)
-		{
-			for (i=0;i<AGCTAB_ArrayLen;i=i+2)
-			{
+	} else if (ConfigType == BaseBand_Config_AGC_TAB) {
+		/* especial for 5G, vivi, 20100528 */
+		if (pHalData->interfaceIndex == 0) {
+			for (i = 0; i < AGCTAB_ArrayLen; i = i+2) {
 				PHY_SetBBReg(Adapter, Rtl819XAGCTAB_Array_Table[i], bMaskDWord, Rtl819XAGCTAB_Array_Table[i+1]);
 
-				// Add 1us delay between BB/RF register setting.
+				/*  Add 1us delay between BB/RF register setting. */
 				rtw_udelay_os(1);
 
-				//RT_TRACE(COMP_INIT, DBG_TRACE, ("The Rtl819XAGCTAB_Array_Table[0] is %lx Rtl819XPHY_REGArray[1] is %lx\n",Rtl819XAGCTAB_Array_Table[i], Rtl819XAGCTAB_Array_Table[i+1]));
 			}
-			//RT_TRACE(COMP_INIT, DBG_LOUD, ("Normal Chip, MAC0, load Rtl819XAGCTAB_Array\n"));
-		}
-		else
-		{
+		} else {
 			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 			{
 				for (i=0;i<AGCTAB_ArrayLen;i=i+2)
 				{
 					PHY_SetBBReg(Adapter, Rtl819XAGCTAB_Array_Table[i], bMaskDWord, Rtl819XAGCTAB_Array_Table[i+1]);
 
-					// Add 1us delay between BB/RF register setting.
+					/*  Add 1us delay between BB/RF register setting. */
 					rtw_udelay_os(1);
-
-					//RT_TRACE(COMP_INIT, DBG_TRACE, ("The Rtl819XAGCTAB_Array_Table[0] is %lx Rtl819XPHY_REGArray[1] is %lx\n",Rtl819XAGCTAB_Array_Table[i], Rtl819XAGCTAB_Array_Table[i+1]));
 				}
-				//RT_TRACE(COMP_INIT, DBG_LOUD, ("Load Rtl819XAGCTAB_2GArray\n"));
-			}
-			else
-			{
+			} else {
 				for (i=0;i<AGCTAB_5GArrayLen;i=i+2)
 				{
 					PHY_SetBBReg(Adapter, Rtl819XAGCTAB_5GArray_Table[i], bMaskDWord, Rtl819XAGCTAB_5GArray_Table[i+1]);
 
-					// Add 1us delay between BB/RF register setting.
+					/*  Add 1us delay between BB/RF register setting. */
 					rtw_udelay_os(1);
-
-					//RT_TRACE(COMP_INIT, DBG_TRACE, ("The Rtl819XAGCTAB_5GArray_Table[0] is %lx Rtl819XPHY_REGArray[1] is %lx\n",Rtl819XAGCTAB_5GArray_Table[i], Rtl819XAGCTAB_5GArray_Table[i+1]));
 				}
-				//RT_TRACE(COMP_INIT, DBG_LOUD, ("Load Rtl819XAGCTAB_5GArray\n"));
 			}
 		}
 	}
@@ -1067,7 +1007,7 @@ phy_ConfigBBWithParaFile(
 
 	return rtStatus;
 }
-#endif //CONFIG_EMBEDDED_FWIMG
+#endif /* CONFIG_EMBEDDED_FWIMG */
 #if MP_DRIVER != 1
 static void
 storePwrIndexDiffRateOffset(
@@ -1080,100 +1020,37 @@ storePwrIndexDiffRateOffset(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
 	if (RegAddr == rTxAGC_A_Rate18_06)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][0] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][0] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][0]));
-	}
 	if (RegAddr == rTxAGC_A_Rate54_24)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][1] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][1] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][1]));
-	}
 	if (RegAddr == rTxAGC_A_CCK1_Mcs32)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][6] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][6] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][6]));
-	}
 	if (RegAddr == rTxAGC_B_CCK11_A_CCK2_11 && BitMask == 0xffffff00)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][7] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][7] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][7]));
-	}
 	if (RegAddr == rTxAGC_A_Mcs03_Mcs00)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][2] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][2] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][2]));
-	}
 	if (RegAddr == rTxAGC_A_Mcs07_Mcs04)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][3] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][3] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][3]));
-	}
 	if (RegAddr == rTxAGC_A_Mcs11_Mcs08)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][4] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][4] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][4]));
-	}
 	if (RegAddr == rTxAGC_A_Mcs15_Mcs12)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][5] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][5] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][5]));
-	}
 	if (RegAddr == rTxAGC_B_Rate18_06)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][8] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][8] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][8]));
-	}
 	if (RegAddr == rTxAGC_B_Rate54_24)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][9] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][9] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][9]));
-	}
 	if (RegAddr == rTxAGC_B_CCK1_55_Mcs32)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][14] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][14] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][14]));
-	}
 	if (RegAddr == rTxAGC_B_CCK11_A_CCK2_11 && BitMask == 0x000000ff)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][15] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][15] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][15]));
-	}
 	if (RegAddr == rTxAGC_B_Mcs03_Mcs00)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][10] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][10] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][10]));
-	}
 	if (RegAddr == rTxAGC_B_Mcs07_Mcs04)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][11] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][11] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][11]));
-	}
 	if (RegAddr == rTxAGC_B_Mcs11_Mcs08)
-	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][12] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][12] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][12]));
-	}
-	if (RegAddr == rTxAGC_B_Mcs15_Mcs12)
-	{
+	if (RegAddr == rTxAGC_B_Mcs15_Mcs12) {
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][13] = Data;
-		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][13] = 0x%lx\n", pHalData->pwrGroupCnt,
-		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][13]));
 		pHalData->pwrGroupCnt++;
 	}
 }
@@ -1207,39 +1084,13 @@ phy_ConfigBBWithPgHeaderFile(
 	PHY_REGArrayPGLen = Rtl8192D_PHY_REG_Array_PGLength;
 	Rtl819XPHY_REGArray_Table_PG = (u32 *)Rtl8192D_PHY_REG_Array_PG;
 
-	if (ConfigType == BaseBand_Config_PHY_REG)
-	{
-		for (i=0;i<PHY_REGArrayPGLen;i=i+3)
-		{
-			//if (Rtl819XPHY_REGArray_Table_PG[i] == 0xfe) {
-			//	#ifdef CONFIG_LONG_DELAY_ISSUE
-			//	rtw_msleep_os(50);
-			//	#else
-			//	rtw_mdelay_os(50);
-			//	#endif
-			//}
-			//else if (Rtl819XPHY_REGArray_Table_PG[i] == 0xfd)
-			//	rtw_mdelay_os(5);
-			//else if (Rtl819XPHY_REGArray_Table_PG[i] == 0xfc)
-			//	rtw_mdelay_os(1);
-			//else if (Rtl819XPHY_REGArray_Table_PG[i] == 0xfb)
-			//	rtw_udelay_os(50);
-			//else if (Rtl819XPHY_REGArray_Table_PG[i] == 0xfa)
-			//	rtw_udelay_os(5);
-			//else if (Rtl819XPHY_REGArray_Table_PG[i] == 0xf9)
-			//	rtw_udelay_os(1);
+	if (ConfigType == BaseBand_Config_PHY_REG) {
+		for (i = 0; i < PHY_REGArrayPGLen; i = i+3) {
 			storePwrIndexDiffRateOffset(Adapter, Rtl819XPHY_REGArray_Table_PG[i],
 				Rtl819XPHY_REGArray_Table_PG[i+1],
 				Rtl819XPHY_REGArray_Table_PG[i+2]);
-			//PHY_SetBBReg(Adapter, Rtl819XPHY_REGArray_Table_PG[i], Rtl819XPHY_REGArray_Table_PG[i+1], Rtl819XPHY_REGArray_Table_PG[i+2]);
-			//RT_TRACE(COMP_SEND, DBG_TRACE, ("The Rtl819XPHY_REGArray_Table_PG[0] is %lx Rtl819XPHY_REGArray_Table_PG[1] is %lx\n",Rtl819XPHY_REGArray_Table_PG[i], Rtl819XPHY_REGArray_Table_PG[i+1]));
 		}
 	}
-	else
-	{
-
-		//RT_TRACE(COMP_SEND, DBG_LOUD, ("phy_ConfigBBWithPgHeaderFile(): ConfigType != BaseBand_Config_PHY_REG\n"));
-	}
 
 	return _SUCCESS;
 }	/* phy_ConfigBBWithPgHeaderFile */
@@ -1274,7 +1125,7 @@ phy_ConfigBBWithPgParaFile(
 
 	return rtStatus;
 }	/* phy_ConfigBBWithPgParaFile */
-#endif //CONFIG_EMBEDDED_FWIMG
+#endif /* CONFIG_EMBEDDED_FWIMG */
 #if MP_DRIVER == 1
 #ifndef CONFIG_EMBEDDED_FWIMG
 /*-----------------------------------------------------------------------------
@@ -1355,17 +1206,11 @@ phy_ConfigBBWithMpHeaderFile(
 				rtw_udelay_os(1);
 			PHY_SetBBReg(Adapter, Rtl8192CPHY_REGArray_Table_MP[i], bMaskDWord, Rtl8192CPHY_REGArray_Table_MP[i+1]);
 
-			// Add 1us delay between BB/RF register setting.
+			/*  Add 1us delay between BB/RF register setting. */
 
 			rtw_udelay_os(1);
-
-			//RT_TRACE(COMP_INIT, DBG_TRACE, ("The Rtl8192CPHY_REGArray_Table_MP[%d] is %lx Rtl8192CPHY_REGArray_Table_MP[%d] is %lx\n", i, i+1, Rtl8192CPHY_REGArray_Table_MP[i], Rtl8192CPHY_REGArray_Table_MP[i+1]));
 		}
 	}
-	else
-	{
-		//RT_TRACE(COMP_SEND, DBG_LOUD, ("phy_ConfigBBWithMpHeaderFile(): ConfigType != BaseBand_Config_PHY_REG\n"));
-	}
 	return _SUCCESS;
 }	/* phy_ConfigBBWithPgHeaderFile */
 
@@ -1390,12 +1235,10 @@ phy_BB8192D_Config_ParaFile(
 	s8		sz92D5GAGCTableFile[] = RTL8192D_AGC_TAB_5G;
 	char		*pszBBRegFile, *pszAGCTableFile, *pszBBRegPgFile, *pszBBRegMpFile;
 
-	//RT_TRACE(COMP_INIT, DBG_TRACE, ("==>phy_BB8192S_Config_ParaFile\n"));
-
 	pszBBRegFile = sz92DBBRegFile;
 	pszBBRegPgFile = sz92DBBRegPgFile;
 
-	//Normal chip,Mac0 use AGC_TAB.txt for 2G and 5G band.
+	/* Normal chip,Mac0 use AGC_TAB.txt for 2G and 5G band. */
 	if (pHalData->interfaceIndex == 0)
 		pszAGCTableFile = sz92DAGCTableFile;
 	else
@@ -1407,50 +1250,41 @@ phy_BB8192D_Config_ParaFile(
 	}
 	pszBBRegMpFile = sz92DBBRegMpFile;
 
-	//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> phy_BB8192C_Config_ParaFile() phy_reg:%s\n",pszBBRegFile));
-	//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> phy_BB8192C_Config_ParaFile() phy_reg_pg:%s\n",pszBBRegPgFile));
-	//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> phy_BB8192C_Config_ParaFile() agc_table:%s\n",pszAGCTableFile));
-
-	//
-	// 1. Read PHY_REG.TXT BB INIT!!
-	// We will seperate as 88C / 92C according to chip version
-	//
+	/*  1. Read PHY_REG.TXT BB INIT!! */
+	/*  We will seperate as 88C / 92C according to chip version */
+	/*  */
 #ifdef CONFIG_EMBEDDED_FWIMG
 	rtStatus = phy_ConfigBBWithHeaderFile(Adapter, BaseBand_Config_PHY_REG);
 #else
-	// No matter what kind of CHIP we always read PHY_REG.txt. We must copy different
-	// type of parameter files to phy_reg.txt at first.
+	/*  No matter what kind of CHIP we always read PHY_REG.txt. We must copy different */
+	/*  type of parameter files to phy_reg.txt at first. */
 	rtStatus = phy_ConfigBBWithParaFile(Adapter,pszBBRegFile);
 #endif
 
-	if (rtStatus != _SUCCESS) {
-		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():Write BB Reg Fail!!"));
+	if (rtStatus != _SUCCESS)
 		goto phy_BB8190_Config_ParaFile_Fail;
-	}
 
 #if MP_DRIVER == 1
-	//
-	// 1.1 Read PHY_REG_MP.TXT BB INIT!!
-	// We will seperate as 88C / 92C according to chip version
-	//
+	/*  */
+	/*  1.1 Read PHY_REG_MP.TXT BB INIT!! */
+	/*  We will seperate as 88C / 92C according to chip version */
+	/*  */
 #ifdef CONFIG_EMBEDDED_FWIMG
 	rtStatus = phy_ConfigBBWithMpHeaderFile(Adapter, BaseBand_Config_PHY_REG);
 #else
-	// No matter what kind of CHIP we always read PHY_REG.txt. We must copy different
-	// type of parameter files to phy_reg.txt at first.
+	/*  No matter what kind of CHIP we always read PHY_REG.txt. We must copy different */
+	/*  type of parameter files to phy_reg.txt at first. */
 	rtStatus = phy_ConfigBBWithMpParaFile(Adapter,pszBBRegMpFile);
 #endif
 
-	if (rtStatus != _SUCCESS) {
-		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():Write BB Reg MP Fail!!"));
+	if (rtStatus != _SUCCESS)
 		goto phy_BB8190_Config_ParaFile_Fail;
-	}
 #endif
 
 #if MP_DRIVER != 1
-	//
-	// 2. If EEPROM or EFUSE autoload OK, We must config by PHY_REG_PG.txt
-	//
+	/*  */
+	/*  2. If EEPROM or EFUSE autoload OK, We must config by PHY_REG_PG.txt */
+	/*  */
 	if (pEEPROM->bautoload_fail_flag == false)
 	{
 		pHalData->pwrGroupCnt = 0;
@@ -1462,15 +1296,13 @@ phy_BB8192D_Config_ParaFile(
 #endif
 	}
 
-	if (rtStatus != _SUCCESS) {
-		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():BB_PG Reg Fail!!"));
+	if (rtStatus != _SUCCESS)
 		goto phy_BB8190_Config_ParaFile_Fail;
-	}
 #endif
 
-	//
-	// 3. BB AGC table Initialization
-	//
+	/*  */
+	/*  3. BB AGC table Initialization */
+	/*  */
 #ifdef CONFIG_EMBEDDED_FWIMG
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (pHalData->bSlaveOfDMSP)
@@ -1483,17 +1315,14 @@ phy_BB8192D_Config_ParaFile(
 		rtStatus = phy_ConfigBBWithHeaderFile(Adapter, BaseBand_Config_AGC_TAB);
 	}
 #else
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("phy_BB8192S_Config_ParaFile AGC_TAB.txt\n"));
 	rtStatus = phy_ConfigBBWithParaFile(Adapter, pszAGCTableFile);
 #endif
 
-	if (rtStatus != _SUCCESS) {
-		//RT_TRACE(COMP_FPGA, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():AGC Table Fail\n"));
+	if (rtStatus != _SUCCESS)
 		goto phy_BB8190_Config_ParaFile_Fail;
-	}
 
-	// Check if the CCK HighPower is turned ON.
-	// This is used to calculate PWDB.
+	/*  Check if the CCK HighPower is turned ON. */
+	/*  This is used to calculate PWDB. */
 	pHalData->bCckHighPower = (bool)(PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter2, 0x200));
 
 phy_BB8190_Config_ParaFile_Fail:
@@ -1507,7 +1336,7 @@ PHY_BBConfig8192D(
 	)
 {
 	int	rtStatus = _SUCCESS;
-	//u8		PathMap = 0, index = 0, rf_num = 0;
+	/* u8		PathMap = 0, index = 0, rf_num = 0; */
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	u32	RegVal;
 	u8	value;
@@ -1520,35 +1349,35 @@ PHY_BBConfig8192D(
 
 	phy_InitBBRFRegisterDefinition(Adapter);
 
-	// Enable BB and RF
+	/*  Enable BB and RF */
 	RegVal = rtw_read16(Adapter, REG_SYS_FUNC_EN);
 	rtw_write16(Adapter, REG_SYS_FUNC_EN, RegVal|BIT13|BIT0|BIT1);
 
-	// 20090923 Joseph: Advised by Steven and Jenyu. Power sequence before init RF.
+	/*  20090923 Joseph: Advised by Steven and Jenyu. Power sequence before init RF. */
 	rtw_write8(Adapter, REG_AFE_PLL_CTRL, 0x83);
 	rtw_write8(Adapter, REG_AFE_PLL_CTRL+1, 0xdb);
-	value=rtw_read8(Adapter, REG_RF_CTRL);     //  0x1f bit7 bit6 represent for mac0/mac1 driver ready
+	value=rtw_read8(Adapter, REG_RF_CTRL);     /*   0x1f bit7 bit6 represent for mac0/mac1 driver ready */
 	rtw_write8(Adapter, REG_RF_CTRL, value|RF_EN|RF_RSTB|RF_SDMRSTB);
 
 	rtw_write8(Adapter, REG_SYS_FUNC_EN, FEN_USBA | FEN_USBD | FEN_BB_GLB_RSTn | FEN_BBRSTB);
-	//undo clock gated
+	/* undo clock gated */
 	rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
-	//To Fix MAC loopback mode fail. Suggested by SD4 Johnny. 2010.03.23.
+	/* To Fix MAC loopback mode fail. Suggested by SD4 Johnny. 2010.03.23. */
 	rtw_write8(Adapter, REG_LDOHCI12_CTRL, 0x0f);
 	rtw_write8(Adapter, 0x15, 0xe9);
 
 	rtw_write8(Adapter, REG_AFE_XTAL_CTRL+1, 0x80);
 
-	//
-	// Config BB and AGC
-	//
+	/*  */
+	/*  Config BB and AGC */
+	/*  */
 	rtStatus = phy_BB8192D_Config_ParaFile(Adapter);
 
-	//Crystal Calibration
+	/* Crystal Calibration */
 	PHY_SetBBReg(Adapter, 0x24, 0xF0, pHalData->CrystalCap & 0x0F);
 	PHY_SetBBReg(Adapter, 0x28, 0xF0000000, ((pHalData->CrystalCap & 0xF0) >> 4));
 
-	//to save power for special 1T1R
+	/* to save power for special 1T1R */
 	if (pregistrypriv->special_rf_path == 1)
 	{
 		PHY_SetBBReg(Adapter, rFPGA0_XCD_SwitchControl, BIT24|BIT25|BIT27|BIT30, 0);
@@ -1597,7 +1426,6 @@ PHY_RFConfig8192D(
 	struct rtw_adapter *	Adapter
 	)
 {
-	//struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	int		rtStatus = _SUCCESS;
 
 	if (Adapter->bSurpriseRemoved) {
@@ -1605,9 +1433,9 @@ PHY_RFConfig8192D(
 		return rtStatus;
 	}
 
-	//
-	// RF config
-	//
+	/*  */
+	/*  RF config */
+	/*  */
 	rtStatus = PHY_RF6052_Config8192D(Adapter);
 	return rtStatus;
 }
@@ -1641,7 +1469,7 @@ rtl8192d_PHY_ConfigRFWithParaFile(
 	return rtStatus;
 }
 
-//****************************************
+/*  */
 /*-----------------------------------------------------------------------------
  * Function:    PHY_ConfigRFWithHeaderFile()
  *
@@ -1693,18 +1521,12 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 		Rtl819XRadioB_Array_Table = (u32 *)Rtl8192D_RadioB_2T_intPAArray;
 	}
 
-	//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> PHY_ConfigRFWithHeaderFile() Radio_A:Rtl819XRadioA_1TArray\n"));
-	//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> PHY_ConfigRFWithHeaderFile() Radio_B:Rtl819XRadioB_1TArray\n"));
-
-	//RT_TRACE(COMP_INIT, DBG_TRACE, ("PHY_ConfigRFWithHeaderFile: Radio No %x\n", eRFPath));
 	rtStatus = _SUCCESS;
 
-	//vivi added this for read parameter from header, 20100908
-	//1this only happens when DMDP, mac0 start on 2.4G, mac1 start on 5G,
-	//1mac 0 has to set phy0&phy1 pathA or mac1 has to set phy0&phy1 pathA
-	if ((Content == radiob_txt)&&(eRFPath == RF_PATH_A))
-	{
-		//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> PHY_ConfigRFWithHeaderFile(), althougth Path A, we load radiob.txt\n"));
+	/* vivi added this for read parameter from header, 20100908 */
+	/* 1this only happens when DMDP, mac0 start on 2.4G, mac1 start on 5G, */
+	/* 1mac 0 has to set phy0&phy1 pathA or mac1 has to set phy0&phy1 pathA */
+	if ((Content == radiob_txt)&&(eRFPath == RF_PATH_A)) {
 		RadioA_ArrayLen = RadioB_ArrayLen;
 		Rtl819XRadioA_Array_Table = Rtl819XRadioB_Array_Table;
 	}
@@ -1723,13 +1545,11 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 				}
 				else if (Rtl819XRadioA_Array_Table[i] == 0xfd)
 				{
-					//rtw_mdelay_os(5);
 					for (j=0;j<100;j++)
 						rtw_udelay_os(MAX_STALL_TIME);
 				}
 				else if (Rtl819XRadioA_Array_Table[i] == 0xfc)
 				{
-					//rtw_mdelay_os(1);
 					for (j=0;j<20;j++)
 						rtw_udelay_os(MAX_STALL_TIME);
 				}
@@ -1748,7 +1568,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 				else
 				{
 					PHY_SetRFReg(Adapter, eRFPath, Rtl819XRadioA_Array_Table[i]|MaskforPhySet, bRFRegOffsetMask, Rtl819XRadioA_Array_Table[i+1]);
-					// Add 1us delay between BB/RF register setting.
+					/*  Add 1us delay between BB/RF register setting. */
 					rtw_udelay_os(1);
 				}
 			}
@@ -1757,7 +1577,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 			for (i = 0;i<RadioB_ArrayLen; i=i+2)
 			{
 				if (Rtl819XRadioB_Array_Table[i] == 0xfe)
-				{ // Deay specific ms. Only RF configuration require delay.
+				{ /*  Deay specific ms. Only RF configuration require delay. */
 					#ifdef CONFIG_LONG_DELAY_ISSUE
 					rtw_msleep_os(50);
 					#else
@@ -1766,13 +1586,13 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 				}
 				else if (Rtl819XRadioB_Array_Table[i] == 0xfd)
 				{
-					//rtw_mdelay_os(5);
+					/* rtw_mdelay_os(5); */
 					for (j=0;j<100;j++)
 						rtw_udelay_os(MAX_STALL_TIME);
 				}
 				else if (Rtl819XRadioB_Array_Table[i] == 0xfc)
 				{
-					//rtw_mdelay_os(1);
+					/* rtw_mdelay_os(1); */
 					for (j=0;j<20;j++)
 						rtw_udelay_os(MAX_STALL_TIME);
 				}
@@ -1791,7 +1611,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 				else
 				{
 					PHY_SetRFReg(Adapter, eRFPath, Rtl819XRadioB_Array_Table[i]|MaskforPhySet, bRFRegOffsetMask, Rtl819XRadioB_Array_Table[i+1]);
-					// Add 1us delay between BB/RF register setting.
+					/*  Add 1us delay between BB/RF register setting. */
 					rtw_udelay_os(1);
 				}
 			}
@@ -1814,7 +1634,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
  *
  * Input:	struct rtw_adapter *			Adapter
  *			enum HW90_BLOCK		CheckBlock
- *			enum RF_RADIO_PATH_E	eRFPath		// it is used only when CheckBlock is HW90_BLOCK_RF
+ *			enum RF_RADIO_PATH_E	eRFPath		it is used only when CheckBlock is HW90_BLOCK_RF
  *
  * Output:      NONE
  *
@@ -1836,7 +1656,7 @@ rtl8192d_PHY_CheckBBAndRFOK(
 	u32				WriteAddr[4];
 	u32				WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};
 
-	// Initialize register address offset to be checked
+	/*  Initialize register address offset to be checked */
 	WriteAddr[HW90_BLOCK_MAC] = 0x100;
 	WriteAddr[HW90_BLOCK_PHY0] = 0x900;
 	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
@@ -1845,14 +1665,12 @@ rtl8192d_PHY_CheckBBAndRFOK(
 	for (i=0 ; i < CheckTimes ; i++)
 	{
 
-		//
-		// Write Data to register and readback
-		//
+		/*  */
+		/*  Write Data to register and readback */
+		/*  */
 		switch (CheckBlock)
 		{
 		case HW90_BLOCK_MAC:
-			//RT_ASSERT(FALSE, ("PHY_CheckBBRFOK(): Never Write 0x100 here!"));
-			//RT_TRACE(COMP_INIT, DBG_LOUD, ("PHY_CheckBBRFOK(): Never Write 0x100 here!\n"));
 			break;
 
 		case HW90_BLOCK_PHY0:
@@ -1862,18 +1680,18 @@ rtl8192d_PHY_CheckBBAndRFOK(
 			break;
 
 		case HW90_BLOCK_RF:
-			// When initialization, we want the delay function(delay_ms(), delay_us()
-			// ==> actually we call PlatformStallExecution()) to do NdisStallExecution()
-			// [busy wait] instead of NdisMSleep(). So we acquire RT_INITIAL_SPINLOCK
-			// to run at Dispatch level to achive it.
-			//cosa PlatformAcquireSpinLock(Adapter, RT_INITIAL_SPINLOCK);
+			/*  When initialization, we want the delay function(delay_ms(), delay_us() */
+			/*  ==> actually we call PlatformStallExecution()) to do NdisStallExecution() */
+			/*  [busy wait] instead of NdisMSleep(). So we acquire RT_INITIAL_SPINLOCK */
+			/*  to run at Dispatch level to achive it. */
+			/* cosa PlatformAcquireSpinLock(Adapter, RT_INITIAL_SPINLOCK); */
 			WriteData[i] &= 0xfff;
 			PHY_SetRFReg(Adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bRFRegOffsetMask, WriteData[i]);
-			// TODO: we should not delay for such a long time. Ask SD3
+			/*  TODO: we should not delay for such a long time. Ask SD3 */
 			rtw_mdelay_os(10);
 			ulRegRead = PHY_QueryRFReg(Adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bRFRegOffsetMask);
 			rtw_mdelay_os(10);
-			//cosa PlatformReleaseSpinLock(Adapter, RT_INITIAL_SPINLOCK);
+			/* cosa PlatformReleaseSpinLock(Adapter, RT_INITIAL_SPINLOCK); */
 			break;
 
 		default:
@@ -1882,12 +1700,11 @@ rtl8192d_PHY_CheckBBAndRFOK(
 		}
 
 
-		//
-		// Check whether readback data is correct
-		//
+		/*  */
+		/*  Check whether readback data is correct */
+		/*  */
 		if (ulRegRead != WriteData[i])
 		{
-			//RT_TRACE(COMP_FPGA, DBG_LOUD, ("ulRegRead: %lx, WriteData: %lx\n", ulRegRead, WriteData[i]));
 			rtStatus = _FAIL;
 			break;
 		}
@@ -1904,31 +1721,25 @@ rtl8192d_PHY_GetHWRegOriginalValue(
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
-	// read rx initial gain
+	/*  read rx initial gain */
 	pHalData->DefaultInitialGain[0] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XAAGCCore1, bMaskByte0);
 	pHalData->DefaultInitialGain[1] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XBAGCCore1, bMaskByte0);
 	pHalData->DefaultInitialGain[2] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XCAGCCore1, bMaskByte0);
 	pHalData->DefaultInitialGain[3] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XDAGCCore1, bMaskByte0);
-	//RT_TRACE(COMP_INIT, DBG_LOUD,
-	//("Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x)\n",
-	//pHalData->DefaultInitialGain[0], pHalData->DefaultInitialGain[1],
-	//pHalData->DefaultInitialGain[2], pHalData->DefaultInitialGain[3]));
 
-	// read framesync
+	/*  read framesync */
 	pHalData->framesync = (u8)PHY_QueryBBReg(Adapter, rOFDM0_RxDetector3, bMaskByte0);
 	pHalData->framesyncC34 = PHY_QueryBBReg(Adapter, rOFDM0_RxDetector2, bMaskDWord);
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Default framesync (0x%x) = 0x%x\n",
-	//	rOFDM0_RxDetector3, pHalData->framesync));
 }
 
 
-//
-//	Description:
-//		Map dBm into Tx power index according to
-//		current HW model, for example, RF and PA, and
-//		current wireless mode.
-//	By Bruce, 2008-01-29.
-//
+/*  */
+/* 	Description: */
+/* 		Map dBm into Tx power index according to */
+/* 		current HW model, for example, RF and PA, and */
+/* 		current wireless mode. */
+/* 	By Bruce, 2008-01-29. */
+/*  */
 static	u8
 phy_DbmToTxPwrIdx(
 	struct rtw_adapter *		Adapter,
@@ -1940,13 +1751,13 @@ phy_DbmToTxPwrIdx(
 	int				Offset = 0;
 
 
-	//
-	// Tested by MP, we found that CCK Index 0 equals to 8dbm, OFDM legacy equals to
-	// 3dbm, and OFDM HT equals to 0dbm repectively.
-	// Note:
-	//	The mapping may be different by different NICs. Do not use this formula for what needs accurate result.
-	// By Bruce, 2008-01-29.
-	//
+	/*  */
+	/*  Tested by MP, we found that CCK Index 0 equals to 8dbm, OFDM legacy equals to */
+	/*  3dbm, and OFDM HT equals to 0dbm repectively. */
+	/*  Note: */
+	/* 	The mapping may be different by different NICs. Do not use this formula for what needs accurate result. */
+	/*  By Bruce, 2008-01-29. */
+	/*  */
 	switch (WirelessMode)
 	{
 	case WIRELESS_MODE_B:
@@ -1971,7 +1782,7 @@ phy_DbmToTxPwrIdx(
 		TxPwrIdx = 0;
 	}
 
-	// Tx Power Index is too large.
+	/*  Tx Power Index is too large. */
 	if (TxPwrIdx > MAX_TXPWR_IDX_NMODE_92S)
 		TxPwrIdx = MAX_TXPWR_IDX_NMODE_92S;
 
@@ -1979,13 +1790,13 @@ phy_DbmToTxPwrIdx(
 }
 
 
-//
-//	Description:
-//		Map Tx power index into dBm according to
-//		current HW model, for example, RF and PA, and
-//		current wireless mode.
-//	By Bruce, 2008-01-29.
-//
+/*  */
+/* 	Description: */
+/* 		Map Tx power index into dBm according to */
+/* 		current HW model, for example, RF and PA, and */
+/* 		current wireless mode. */
+/* 	By Bruce, 2008-01-29. */
+/*  */
 static int
 phy_TxPwrIdxToDbm(
 	struct rtw_adapter *		Adapter,
@@ -1996,12 +1807,12 @@ phy_TxPwrIdxToDbm(
 	int				Offset = 0;
 	int				PwrOutDbm = 0;
 
-	//
-	// Tested by MP, we found that CCK Index 0 equals to -7dbm, OFDM legacy equals to -8dbm.
-	// Note:
-	//	The mapping may be different by different NICs. Do not use this formula for what needs accurate result.
-	// By Bruce, 2008-01-29.
-	//
+	/*  */
+	/*  Tested by MP, we found that CCK Index 0 equals to -7dbm, OFDM legacy equals to -8dbm. */
+	/*  Note: */
+	/* 	The mapping may be different by different NICs. Do not use this formula for what needs accurate result. */
+	/*  By Bruce, 2008-01-29. */
+	/*  */
 	switch (WirelessMode)
 	{
 	case WIRELESS_MODE_B:
@@ -2017,7 +1828,7 @@ phy_TxPwrIdxToDbm(
 		break;
 	}
 
-	PwrOutDbm = TxPwrIdx / 2 + Offset; // Discard the decimal part.
+	PwrOutDbm = TxPwrIdx / 2 + Offset; /*  Discard the decimal part. */
 
 	return PwrOutDbm;
 }
@@ -2046,26 +1857,26 @@ PHY_GetTxPowerLevel8192D(
 	u8			TxPwrLevel = 0;
 	int			TxPwrDbm;
 
-	//
-	// Because the Tx power indexes are different, we report the maximum of them to
-	// meet the CCX TPC request. By Bruce, 2008-01-31.
-	//
+	/*  */
+	/*  Because the Tx power indexes are different, we report the maximum of them to */
+	/*  meet the CCX TPC request. By Bruce, 2008-01-31. */
+	/*  */
 
-	// CCK
+	/*  CCK */
 	TxPwrLevel = pHalData->CurrentCckTxPwrIdx;
 	TxPwrDbm = phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_B, TxPwrLevel);
 
-	// Legacy OFDM
+	/*  Legacy OFDM */
 	TxPwrLevel = pHalData->CurrentOfdm24GTxPwrIdx + pHalData->LegacyHTTxPowerDiff;
 
-	// Compare with Legacy OFDM Tx power.
+	/*  Compare with Legacy OFDM Tx power. */
 	if (phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_G, TxPwrLevel) > TxPwrDbm)
 		TxPwrDbm = phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_G, TxPwrLevel);
 
-	// HT OFDM
+	/*  HT OFDM */
 	TxPwrLevel = pHalData->CurrentOfdm24GTxPwrIdx;
 
-	// Compare with HT OFDM Tx power.
+	/*  Compare with HT OFDM Tx power. */
 	if (phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_N_24G, TxPwrLevel) > TxPwrDbm)
 		TxPwrDbm = phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_N_24G, TxPwrLevel);
 
@@ -2083,29 +1894,28 @@ static void getTxPowerIndex(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	u8	index = (channel -1);
 
-	// 1. CCK
+	/*  1. CCK */
 	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 	{
-		cckPowerLevel[RF_PATH_A] = pHalData->TxPwrLevelCck[RF_PATH_A][index];	//RF-A
-		cckPowerLevel[RF_PATH_B] = pHalData->TxPwrLevelCck[RF_PATH_B][index];	//RF-B
+		cckPowerLevel[RF_PATH_A] = pHalData->TxPwrLevelCck[RF_PATH_A][index];	/* RF-A */
+		cckPowerLevel[RF_PATH_B] = pHalData->TxPwrLevelCck[RF_PATH_B][index];	/* RF-B */
 	}
 	else
 		cckPowerLevel[RF_PATH_A] = cckPowerLevel[RF_PATH_B] = 0;
 
-	// 2. OFDM for 1S or 2S
+	/*  2. OFDM for 1S or 2S */
 	if (GET_RF_TYPE(Adapter) == RF_1T2R || GET_RF_TYPE(Adapter) == RF_1T1R)
 	{
-		// Read HT 40 OFDM TX power
+		/*  Read HT 40 OFDM TX power */
 		ofdmPowerLevel[RF_PATH_A] = pHalData->TxPwrLevelHT40_1S[RF_PATH_A][index];
 		ofdmPowerLevel[RF_PATH_B] = pHalData->TxPwrLevelHT40_1S[RF_PATH_B][index];
 	}
 	else if (GET_RF_TYPE(Adapter) == RF_2T2R)
 	{
-		// Read HT 40 OFDM TX power
+		/*  Read HT 40 OFDM TX power */
 		ofdmPowerLevel[RF_PATH_A] = pHalData->TxPwrLevelHT40_2S[RF_PATH_A][index];
 		ofdmPowerLevel[RF_PATH_B] = pHalData->TxPwrLevelHT40_2S[RF_PATH_B][index];
 	}
-	//RTPRINT(FPHY, PHY_TXPWR, ("Channel-%d, set tx power index !!\n", channel));
 }
 
 static void ccxPowerIndexCheck(
@@ -2140,7 +1950,7 @@ PHY_SetTxPowerLevel8192D(
 	)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	u8	cckPowerLevel[2], ofdmPowerLevel[2];	// [0]:RF-A, [1]:RF-B
+	u8	cckPowerLevel[2], ofdmPowerLevel[2];	/*  [0]:RF-A, [1]:RF-B */
 
 #if (MP_DRIVER == 1)
 	return;
@@ -2164,14 +1974,14 @@ PHY_SetTxPowerLevel8192D(
 	rtl8192d_PHY_RF6052SetOFDMTxPower(Adapter, &ofdmPowerLevel[0], channel);
 }
 
-//
-//	Description:
-//		Update transmit power level of all channel supported.
-//
-//	TODO:
-//		A mode.
-//	By Bruce, 2008-02-04.
-//
+/*  */
+/* 	Description: */
+/* 		Update transmit power level of all channel supported. */
+/*  */
+/* 	TODO: */
+/* 		A mode. */
+/* 	By Bruce, 2008-02-04. */
+/*  */
 bool
 PHY_UpdateTxPowerDbm8192D(
 	struct rtw_adapter *	Adapter,
@@ -2182,7 +1992,7 @@ PHY_UpdateTxPowerDbm8192D(
 	u8	idx;
 	u8	rf_path;
 
-	// TODO: A mode Tx power.
+	/*  TODO: A mode Tx power. */
 	u8	CckTxPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_B, powerInDbm);
 	u8	OfdmTxPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_N_24G, powerInDbm);
 
@@ -2191,7 +2001,6 @@ PHY_UpdateTxPowerDbm8192D(
 	else
 		OfdmTxPwrIdx = 0;
 
-	//RT_TRACE(COMP_TXAGC, DBG_LOUD, ("PHY_UpdateTxPowerDbm8192S(): %ld dBm , CckTxPwrIdx = %d, OfdmTxPwrIdx = %d\n", powerInDbm, CckTxPwrIdx, OfdmTxPwrIdx));
 
 	for (idx = 0; idx < CHANNEL_MAX_NUMBER; idx++)
 	{
@@ -2204,7 +2013,6 @@ PHY_UpdateTxPowerDbm8192D(
 		}
 	}
 
-	//Adapter->HalFunc.SetTxPowerLevelHandler(Adapter, pHalData->CurrentChannel);//gtest:todo
 
 	return true;
 }
@@ -2261,20 +2069,16 @@ _PHY_SetBWMode92D(
 	u8	regRRSR_RSC;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	// FOr 92D dual mac config.
+	/*  FOr 92D dual mac config. */
 	struct rtw_adapter *BuddyAdapter = Adapter->pbuddy_adapter;
 	struct hal_data_8192du *pHalDataBuddyAdapter;
 #endif
 
-	//DBG_8192D("==>[%d]: _PHY_SetBWMode92D()  Switch to %s bandwidth\n", pHalData->interfaceIndex, pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz");
 
 	if (pHalData->rf_chip == RF_PSEUDO_11N)
-	{
-		//pHalData->SetBWModeInProgress= false;
 		return;
-	}
 
-	// There is no 40MHz mode in RF_8225.
+	/*  There is no 40MHz mode in RF_8225. */
 	if (pHalData->rf_chip==RF_8225)
 		return;
 
@@ -2282,26 +2086,25 @@ _PHY_SetBWMode92D(
 		return;
 
 
-	//3//
-	//3//<1>Set MAC register
-	//3//
-	//Adapter->HalFunc.SetBWModeHandler();
+	/* 3 */
+	/* 3<1>Set MAC register */
+	/* 3 */
+	/* Adapter->HalFunc.SetBWModeHandler(); */
 
 	regBwOpMode = rtw_read8(Adapter, REG_BWOPMODE);
 	regRRSR_RSC = rtw_read8(Adapter, REG_RRSR+2);
-	//regBwOpMode = rtw_hal_get_hwreg(Adapter,HW_VAR_BWMODE,(pu1Byte)&regBwOpMode);
 
 	switch (pHalData->CurrentChannelBW)
 	{
 		case HT_CHANNEL_WIDTH_20:
 			regBwOpMode |= BW_OPMODE_20MHZ;
-			   // 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+			   /*  2007/02/07 Mark by Emily becasue we have not verify whether this register works */
 			rtw_write8(Adapter, REG_BWOPMODE, regBwOpMode);
 			break;
 
 		case HT_CHANNEL_WIDTH_40:
 			regBwOpMode &= ~BW_OPMODE_20MHZ;
-				// 2007/02/07 Mark by Emily becasue we have not verify whether this register works
+				/*  2007/02/07 Mark by Emily becasue we have not verify whether this register works */
 			rtw_write8(Adapter, REG_BWOPMODE, regBwOpMode);
 
 			regRRSR_RSC = (regRRSR_RSC&0x90) |(pHalData->nCur40MhzPrimeSC<<5);
@@ -2314,9 +2117,9 @@ _PHY_SetBWMode92D(
 			break;
 	}
 
-	//3//
-	//3//<2>Set PHY related register
-	//3//
+	/* 3 */
+	/* 3<2>Set PHY related register */
+	/* 3 */
 	switch (pHalData->CurrentChannelBW)
 	{
 		/* 20 MHz channel*/
@@ -2325,7 +2128,7 @@ _PHY_SetBWMode92D(
 
 			PHY_SetBBReg(Adapter, rFPGA1_RFMOD, bRFMOD, 0x0);
 
-			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter2, BIT10|BIT11, 3);// SET BIT10 BIT11  for receive cck
+			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter2, BIT10|BIT11, 3);/*  SET BIT10 BIT11  for receive cck */
 
 			break;
 
@@ -2335,16 +2138,14 @@ _PHY_SetBWMode92D(
 
 			PHY_SetBBReg(Adapter, rFPGA1_RFMOD, bRFMOD, 0x1);
 
-			// Set Control channel to upper or lower. These settings are required only for 40MHz
+			/*  Set Control channel to upper or lower. These settings are required only for 40MHz */
 			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 			{
-				//AcquireCCKAndRWPageAControl(Adapter);
 				PHY_SetBBReg(Adapter, rCCK0_System, bCCKSideBand, (pHalData->nCur40MhzPrimeSC>>1));
-				//ReleaseCCKAndRWPageAControl(Adapter);
 			}
 			PHY_SetBBReg(Adapter, rOFDM1_LSTF, 0xC00, pHalData->nCur40MhzPrimeSC);
 
-			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter2, BIT10|BIT11, 0);// SET BIT10 BIT11  for receive cck
+			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter2, BIT10|BIT11, 0);/*  SET BIT10 BIT11  for receive cck */
 
 			PHY_SetBBReg(Adapter, 0x818, (BIT26|BIT27), (pHalData->nCur40MhzPrimeSC==HAL_PRIME_CHNL_OFFSET_LOWER)?2:1);
 
@@ -2357,25 +2158,22 @@ _PHY_SetBWMode92D(
 
 	}
 
-	//3<3>Set RF related register
+	/* 3<3>Set RF related register */
 	switch (pHalData->rf_chip)
 	{
 		case RF_8225:
-			//PHY_SetRF8225Bandwidth(Adapter, pHalData->CurrentChannelBW);
 			break;
 
 		case RF_8256:
-			// Please implement this function in Hal8190PciPhy8256.c
-			//PHY_SetRF8256Bandwidth(Adapter, pHalData->CurrentChannelBW);
+			/*  Please implement this function in Hal8190PciPhy8256.c */
 			break;
 
 		case RF_8258:
-			// Please implement this function in Hal8190PciPhy8258.c
-			// PHY_SetRF8258Bandwidth();
+			/*  Please implement this function in Hal8190PciPhy8258.c */
 			break;
 
 		case RF_PSEUDO_11N:
-			// Do Nothing
+			/*  Do Nothing */
 			break;
 
 		case RF_6052:
@@ -2383,11 +2181,9 @@ _PHY_SetBWMode92D(
 			break;
 
 		default:
-			//RT_ASSERT(FALSE, ("Unknown RFChipID: %d\n", pHalData->RFChipID));
 			break;
 	}
 
-	//pHalData->SetBWModeInProgress= FALSE;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (Adapter->DualMacConcurrent == true && BuddyAdapter != NULL)
@@ -2401,7 +2197,6 @@ _PHY_SetBWMode92D(
 	}
 #endif
 
-	//RT_TRACE(COMP_SCAN, DBG_LOUD, ("<==PHY_SetBWModeCallback8192C()\n"));
 }
 
  /*-----------------------------------------------------------------------------
@@ -2410,7 +2205,7 @@ _PHY_SetBWMode92D(
  * Overview:  This function is export to "HalCommon" moudule
  *
  * Input:		struct rtw_adapter *			Adapter
- *			HT_CHANNEL_WIDTH	Bandwidth	//20M or 40M
+ *			HT_CHANNEL_WIDTH	Bandwidth	20M or 40M
  *
  * Output:      NONE
  *
@@ -2421,8 +2216,8 @@ _PHY_SetBWMode92D(
 void
 PHY_SetBWMode8192D(
 	struct rtw_adapter *					Adapter,
-	enum HT_CHANNEL_WIDTH	Bandwidth,	// 20M or 40M
-	unsigned char	Offset		// Upper, Lower, or Don't care
+	enum HT_CHANNEL_WIDTH	Bandwidth,	/*  20M or 40M */
+	unsigned char	Offset		/*  Upper, Lower, or Don't care */
 )
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
@@ -2431,19 +2226,15 @@ PHY_SetBWMode8192D(
 	struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
 #endif
 
-	//if (pHalData->SetBWModeInProgress)
-	//	return;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (pHalData->bInModeSwitchProcess)
 	{
 		DBG_8192D("PHY_SwChnl8192D(): During mode switch\n");
-		//pHalData->SetBWModeInProgress=false;
 		return;
 	}
 #endif
 
-	//pHalData->SetBWModeInProgress= true;
 
 	pHalData->CurrentChannelBW = Bandwidth;
 
@@ -2452,10 +2243,8 @@ PHY_SetBWMode8192D(
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if ((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
 	{
-		//if ((BuddyAdapter->MgntInfo.bJoinInProgress) ||(BuddyAdapter->MgntInfo.bScanInProgress))
 		{
 			DBG_8192D("PHY_SetBWMode92D():slave return when slave\n");
-			//pHalData->SetBWModeInProgress=false;
 			return;
 		}
 	}
@@ -2463,16 +2252,12 @@ PHY_SetBWMode8192D(
 
 	if ((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))
 	{
-#ifdef USE_WORKITEM
-		//PlatformScheduleWorkItem(&(pHalData->SetBWModeWorkItem));
-#else
+#ifndef USE_WORKITEM
 	_PHY_SetBWMode92D(Adapter);
 #endif
 	}
 	else
 	{
-		//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SetBWMode8192C() SetBWModeInProgress FALSE driver sleep or unload\n"));
-		//pHalData->SetBWModeInProgress= FALSE;
 		pHalData->CurrentChannelBW = tmpBW;
 	}
 }
@@ -2506,7 +2291,7 @@ void PHY_SwitchWirelessBand(struct rtw_a
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	u8	i, value8;//, RegValue
+	u8	i, value8;/*  RegValue */
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (pHalData->bInModeSwitchProcess || pHalData->bSlaveOfDMSP)
@@ -2515,7 +2300,6 @@ void PHY_SwitchWirelessBand(struct rtw_a
 		return;
 	}
 #endif
-	//DBG_8192D("PHY_SwitchWirelessBand():Before Switch Band\n");
 
 	pHalData->BandSet92D = pHalData->CurrentBandType92D = (enum BAND_TYPE)Band;
 	if (IS_92D_SINGLEPHY(pHalData->VersionID))
@@ -2546,13 +2330,13 @@ void PHY_SwitchWirelessBand(struct rtw_a
 	}
 #endif
 
-	//stop RX/Tx
+	/* stop RX/Tx */
 	PHY_StopTRXBeforeChangeBand8192D(Adapter);
 
-	//reconfig BB/RF according to wireless mode
+	/* reconfig BB/RF according to wireless mode */
 	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 	{
-		//BB & RF Config
+		/* BB & RF Config */
 		if (pHalData->interfaceIndex == 1)
 		{
 #ifdef CONFIG_EMBEDDED_FWIMG
@@ -2562,7 +2346,7 @@ void PHY_SwitchWirelessBand(struct rtw_a
 #endif
 		}
 	}
-	else	//5G band
+	else	/* 5G band */
 	{
 		if (pHalData->interfaceIndex == 1)
 		{
@@ -2584,8 +2368,8 @@ void PHY_SwitchWirelessBand(struct rtw_a
 	}
 	else
 	{
-		//avoid using cck rate in 5G band
-		// Set RRSR rate table.
+		/* avoid using cck rate in 5G band */
+		/*  Set RRSR rate table. */
 		update_tx_basic_rate(Adapter, WIRELESS_11A_5N);
 
 		PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x2);
@@ -2608,7 +2392,7 @@ void PHY_SwitchWirelessBand(struct rtw_a
 
 	pdmpriv->bReloadtxpowerindex = true;
 
-	// notice fw know band status  0x81[1]/0x53[1] = 0: 5G, 1: 2G
+	/*  notice fw know band status  0x81[1]/0x53[1] = 0: 5G, 1: 2G */
 	if (pHalData->CurrentBandType92D==BAND_ON_2_4G)
 	{
 		value8 = rtw_read8(Adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
@@ -2626,7 +2410,6 @@ void PHY_SwitchWirelessBand(struct rtw_a
 	for (i=0;i<20;i++)
 			rtw_udelay_os(MAX_STALL_TIME);
 
-	//DBG_8192D("PHY_SwitchWirelessBand():Switch Band OK.\n");
 }
 
 
@@ -2641,7 +2424,6 @@ PHY_EnableRFENV(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	struct bb_register_def *pPhyReg = &pHalData->PHYRegDef[eRFPath];
 
-	//RT_TRACE(COMP_RF, DBG_LOUD, ("====>PHY_EnableRFENV\n"));
 
 	/*----Store original RFENV control type----*/
 	switch (eRFPath)
@@ -2665,13 +2447,11 @@ PHY_EnableRFENV(
 	rtw_udelay_os(1);
 
 	/* Set bit number of Address and Data for RF register */
-	PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireAddressLength, 0x0);	// Set 1 to 4 bits for 8255
+	PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireAddressLength, 0x0);	/*  Set 1 to 4 bits for 8255 */
 	rtw_udelay_os(1);
 
-	PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireDataLength, 0x0); // Set 0 to 12	bits for 8255
+	PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireDataLength, 0x0); /*  Set 0 to 12	bits for 8255 */
 	rtw_udelay_os(1);
-
-	//RT_TRACE(COMP_RF, DBG_LOUD, ("<====PHY_EnableRFENV\n"));
 }
 
 static void
@@ -2685,8 +2465,7 @@ PHY_RestoreRFENV(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	struct bb_register_def *pPhyReg = &pHalData->PHYRegDef[eRFPath];
 
-	//RT_TRACE(COMP_RF, DBG_LOUD, ("=====>PHY_RestoreRFENV\n"));
-	//If another MAC is ON,need do this?
+	/* If another MAC is ON,need do this? */
 	/*----Restore RFENV control type----*/;
 	switch (eRFPath)
 	{
@@ -2699,7 +2478,6 @@ PHY_RestoreRFENV(
 			PHY_SetBBReg(Adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16, *pu4RegValue);
 			break;
 	}
-	//RT_TRACE(COMP_RF, DBG_LOUD, ("<=====PHY_RestoreRFENV\n"));
 }
 
 
@@ -2731,17 +2509,16 @@ PHY_RestoreRFENV(
 	u8			index = 0,	i = 0, eRFPath = RF_PATH_A;
 	bool		bNeedPowerDownRadio = false, bInteralPA = false;
 	u32			u4RegValue, mask = 0x1C000, value = 0, u4tmp, u4tmp2,MaskforPhySet=0;
-	//Query regB30 bit27
+	/* Query regB30 bit27 */
 	u32			Regb30 = PHY_QueryBBReg(Adapter, 0xb30, BIT27);
 
-	//RT_TRACE(COMP_CMD, DBG_LOUD, ("====>phy_SwitchRfSetting interface %d\n", pHalData->interfaceIndex));
 
-	//only for 92D C-cut SMSP
+	/* only for 92D C-cut SMSP */
 
 	if (adapter_to_dvobj(Adapter)->ishighspeed == false)
 		return;
 
-	//config path A for 5G
+	/* config path A for 5G */
 	if (pHalData->CurrentBandType92D==BAND_ON_5G)
 	{
 		u4tmp = CurveIndex[GetRightChnlPlace(channel)-1];
@@ -2769,19 +2546,19 @@ PHY_RestoreRFENV(
 		{
 			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 			MaskforPhySet = MAC1_ACCESS_PHY0;
-			//asume no this case
+			/* asume no this case */
 			if (bNeedPowerDownRadio)
 				PHY_EnableRFENV(Adapter, path, MaskforPhySet, &u4RegValue);
 		}
 
-		//DMDP, if band = 5G,Mac0 need to set PHY1 when regB30[27]=1
+		/* DMDP, if band = 5G,Mac0 need to set PHY1 when regB30[27]=1 */
 		if (Regb30 && pHalData->interfaceIndex == 0)
 		{
 			DBG_8192D("===============phy_SwitchRfSetting8192D interface %d,B30&BIT27=1!!!!\n", pHalData->interfaceIndex);
 
 			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
 			MaskforPhySet= MAC0_ACCESS_PHY1;
-			//asume no this case
+			/* asume no this case */
 			if (bNeedPowerDownRadio)
 				PHY_EnableRFENV(Adapter, path, MaskforPhySet, &u4RegValue);
 		}
@@ -2836,7 +2613,7 @@ PHY_RestoreRFENV(
 		for (eRFPath = RF_PATH_A; eRFPath < pHalData->NumTotalRFPath; eRFPath++)
 		{
 			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY &&
-				pHalData->interfaceIndex == 1)		//MAC 1 5G
+				pHalData->interfaceIndex == 1)		/* MAC 1 5G */
 				bInteralPA = pHalData->InternalPA5G[1];
 			else
 				bInteralPA = pHalData->InternalPA5G[eRFPath];
@@ -2850,8 +2627,6 @@ PHY_RestoreRFENV(
 						PHY_SetRFReg(Adapter, eRFPath, RF_REG_for_C_CUT_5G_internalPA[i], bRFRegOffsetMask, 0x7bdef);
 					else
 						PHY_SetRFReg(Adapter, eRFPath, RF_REG_for_C_CUT_5G_internalPA[i], bRFRegOffsetMask, RF_REG_Param_for_C_CUT_5G_internalPA[index][i]);
-					//RT_TRACE(COMP_RF, DBG_LOUD, ("phy_SwitchRfSetting offset 0x%x value 0x%x path %d index %d\n",
-					//	RF_REG_for_C_CUT_5G_internalPA[i], RF_REG_Param_for_C_CUT_5G_internalPA[index][i], eRFPath,	index));
 				}
 			}
 			else
@@ -2860,9 +2635,7 @@ PHY_RestoreRFENV(
 	}
 	else if (pHalData->CurrentBandType92D==BAND_ON_2_4G)
 	{
-		//DBG_8192D("====>phy_SwitchRfSetting interface %d 2.4G\n", pHalData->interfaceIndex);
 		u4tmp = CurveIndex[channel-1];
-		//RTPRINT(FINIT, INIT_IQK, ("cosa ver 3 set RF-B, 2G, 0x28 = 0x%x !!\n", u4tmp));
 
 		if (channel == 1 || channel == 2 || channel ==4 || channel == 9 || channel == 10 ||
 			channel == 11 || channel ==12)
@@ -2883,14 +2656,13 @@ PHY_RestoreRFENV(
 					PHY_EnableRFENV(Adapter, path,MaskforPhySet,&u4RegValue);
 			}
 
-			//DMDP, if band = 2G,MAC1 need to set PHY0 when regB30[27]=1
+			/* DMDP, if band = 2G,MAC1 need to set PHY0 when regB30[27]=1 */
 			if (Regb30 && pHalData->interfaceIndex == 1)
 			{
-				//RT_TRACE(COMP_MLME, DBG_LOUD, ("===============phy_SwitchRfSetting interface %ld,B30&BIT27=1!!!!\n", Adapter->interfaceIndex));
 
 				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 				MaskforPhySet= MAC1_ACCESS_PHY0;
-				//asume no this case
+				/* asume no this case */
 				if (bNeedPowerDownRadio)
 					PHY_EnableRFENV(Adapter, path,MaskforPhySet,&u4RegValue);
 			}
@@ -2908,7 +2680,7 @@ PHY_RestoreRFENV(
 		}
 
 #if SWLCK == 1
-		//for SWLCK
+		/* for SWLCK */
 
 		PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)path, RF_SYN_G4|MaskforPhySet, bRFRegOffsetMask, RF_REG_SYN_G4_for_C_CUT_2G | (u4tmp << 11));
 #endif
@@ -2920,17 +2692,12 @@ PHY_RestoreRFENV(
 			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
 		}
 
-		if (Regb30 && pHalData->interfaceIndex == 1)
-		{
+		if (Regb30 && pHalData->interfaceIndex == 1) {
 			if (bNeedPowerDownRadio)
-			{
 				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
-			}
 			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
 		}
 	}
-
-	//RT_TRACE(COMP_CMD, DBG_LOUD, ("<====phy_SwitchRfSetting interface %d\n", pHalData->interfaceIndex));
 }
 
 
@@ -2963,24 +2730,19 @@ static  void
 	bool		bNeedPowerDownRadio = false;
 	u32		MaskforPhySet = 0;
 
-	//RT_TRACE(COMP_CMD, DBG_LOUD, ("====>phy_ReloadLCKSetting interface %d path %d\n", Adapter->interfaceIndex, eRFPath));
+	/* only for 92D C-cut SMSP */
 
-	//only for 92D C-cut SMSP
-
-	//RTPRINT(FINIT, INIT_IQK, ("cosa pHalData->CurrentBandType92D = %d\n", pHalData->CurrentBandType92D));
-	//RTPRINT(FINIT, INIT_IQK, ("cosa channel = %d\n", channel));
 	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 	{
-		//Path-A for 5G
+		/* Path-A for 5G */
 		{
 			u4tmp = CurveIndex[GetRightChnlPlace(channel)-1];
-			//RTPRINT(FINIT, INIT_IQK, ("cosa ver 1 set RF-A, 5G,	0x28 = 0x%x !!\n", u4tmp));
 
 			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
 			{
 				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 				MaskforPhySet = MAC1_ACCESS_PHY0;
-				//asume no this case
+				/* asume no this case */
 				if (bNeedPowerDownRadio)
 					PHY_EnableRFENV(Adapter, eRFPath, MaskforPhySet,&u4RegValue);
 			}
@@ -2998,7 +2760,6 @@ static  void
 		{
 			u32 u4tmp=0;
 			u4tmp = CurveIndex[channel-1];
-			//RTPRINT(FINIT, INIT_IQK, ("cosa ver 3 set RF-B, 2G, 0x28 = 0x%x !!\n", u4tmp));
 
 			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
 			{
@@ -3008,7 +2769,6 @@ static  void
 					PHY_EnableRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
 			}
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_SYN_G4|MaskforPhySet, 0x3f800, u4tmp);
-			//RTPRINT(FINIT, INIT_IQK, ("cosa ver 3 set RF-B, 2G, 0x28 = 0x%lx !!\n", PHY_QueryRFReg(Adapter, (enum RF_RADIO_PATH_E) eRFPath, RF_SYN_G4|MaskforPhyAccess, 0x3f800)));
 
 			if (bNeedPowerDownRadio) {
 				PHY_RestoreRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
@@ -3019,7 +2779,6 @@ static  void
 
 
 
-	//RT_TRACE(COMP_CMD, DBG_LOUD, ("<====phy_ReloadLCKSetting\n"));
 }
 
 
@@ -3055,20 +2814,20 @@ static  void
 	if (adapter_to_dvobj(Adapter)->ishighspeed == false)
 		return;
 
-	//only for 92D C-cut SMSP
+	/* only for 92D C-cut SMSP */
 
 	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 	{
 		PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, BIT25|BIT24, 0);
 		PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,	0xf);
 
-		// fc area 0xd2c
+		/*  fc area 0xd2c */
 		if (channel>=149)
 			PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT13|BIT14,2);
 		else
 			PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT13|BIT14,1);
 
-		group = channel<=64?1:2; //leave 0 for channel1-14.
+		group = channel<=64?1:2; /* leave 0 for channel1-14. */
 		IMR_NUM = MAX_RF_IMR_INDEX_NORMAL;
 
 		for (i=0; i<IMR_NUM; i++) {
@@ -3077,12 +2836,9 @@ static  void
 		PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,0);
 		PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 2);
 	}
-	else { //G band.
-		//RT_TRACE(COMP_SCAN,DBG_LOUD,("Load RF IMR parameters for G band. IMR already setting %d\n",pMgntInfo->bLoadIMRandIQKSettingFor2G));
+	else { /* G band. */
 
 		if (!pHalData->bLoadIMRandIQKSettingFor2G) {
-			//RT_TRACE(COMP_SCAN,DBG_LOUD,("Load RF IMR parameters for G band. %d\n",eRFPath));
-			//AcquireCCKAndRWPageAControl(Adapter);
 			PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, BIT25|BIT24, 0);
 			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,	0xf);
 
@@ -3092,11 +2848,9 @@ static  void
 			}
 			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,0);
 			PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 3);
-			//ReleaseCCKAndRWPageAControl(Adapter);
 		}
 	}
 
-	//RT_TRACE(COMP_CMD, DBG_LOUD, ("<====phy_ReloadIMRSetting\n"));
 }
 
 
@@ -3124,14 +2878,14 @@ static  void
 	)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
-	u8		Indexforchannel;//index,
+	u8		Indexforchannel;/* index, */
 
-	//only for 92D C-cut SMSP
+	/* only for 92D C-cut SMSP */
 
 	if (adapter_to_dvobj(Adapter)->ishighspeed == false)
 		return;
 
-	//---------Do IQK for normal chip and test chip 5G band----------------
+	/* Do IQK for normal chip and test chip 5G band---------------- */
 	Indexforchannel = rtl8192d_GetRightChnlPlaceforIQK(channel);
 
 #if MP_DRIVER == 1
@@ -3140,16 +2894,15 @@ static  void
 #endif
 
 	if (pHalData->bNeedIQK && !pHalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone)
-	{ //Re Do IQK.
+	{ /* Re Do IQK. */
 		DBG_8192D("Do IQK Matrix reg for channel:%d....\n", channel);
 		rtl8192d_PHY_IQCalibrate(Adapter);
 	}
-	else //Just load the value.
+	else /* Just load the value. */
 	{
-		// 2G band just load once.
+		/*  2G band just load once. */
 		if (((!pHalData->bLoadIMRandIQKSettingFor2G) && Indexforchannel==0) ||Indexforchannel>0)
 		{
-			//DBG_8192D("Just Read IQK Matrix reg for channel:%d....\n", channel);
 
 			if ((pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][0] != 0)/*&&(RegEA4 != 0)*/)
 			{
@@ -3175,8 +2928,6 @@ static  void
 		}
 	}
 	pHalData->bNeedIQK = false;
-
-	//RT_TRACE(COMP_CMD, DBG_LOUD, ("<====phy_ReloadIQKSetting\n"));
 }
 
 
@@ -3188,7 +2939,7 @@ static void _PHY_SwChnl8192D(struct rtw_
 	enum BAND_TYPE	bandtype, target_bandtype;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 #if defined(CONFIG_CONCURRENT_MODE) || defined(CONFIG_DUALMAC_CONCURRENT)
-	// FOr 92D dual mac config. and sw concurrent mode
+	/*  FOr 92D dual mac config. and sw concurrent mode */
 	struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
 #endif
 
@@ -3198,8 +2949,8 @@ static void _PHY_SwChnl8192D(struct rtw_
 	}
 
 	if (pHalData->BandSet92D == BAND_ON_BOTH) {
-		// Need change band?
-		// BB {Reg878[0],[16]} bit0= 1 is 5G, bit0=0 is 2G.
+		/*  Need change band? */
+		/*  BB {Reg878[0],[16]} bit0= 1 is 5G, bit0=0 is 2G. */
 		ret_value = PHY_QueryBBReg(Adapter, rFPGA0_XAB_RFParameter, bMaskDWord);
 
 		if (ret_value & BIT0)
@@ -3207,7 +2958,7 @@ static void _PHY_SwChnl8192D(struct rtw_
 		else
 			bandtype = BAND_ON_2_4G;
 
-		// Use current channel to judge Band Type and switch Band if need.
+		/*  Use current channel to judge Band Type and switch Band if need. */
 		if (channel > 14)
 		{
 			target_bandtype = BAND_ON_5G;
@@ -3222,10 +2973,10 @@ static void _PHY_SwChnl8192D(struct rtw_
 	}
 
 	do{
-		//s1. pre common command - CmdID_SetTxPowerLevel
+		/* s1. pre common command - CmdID_SetTxPowerLevel */
 		PHY_SetTxPowerLevel8192D(Adapter, channel);
 
-		//s2. RF dependent command - CmdID_RF_WriteReg, param1=RF_CHNLBW, param2=channel
+		/* s2. RF dependent command - CmdID_RF_WriteReg, param1=RF_CHNLBW, param2=channel */
 		param1 = RF_CHNLBW;
 		param2 = channel;
 		for (eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
@@ -3253,12 +3004,12 @@ static void _PHY_SwChnl8192D(struct rtw_
 
 		phy_SwitchRfSetting(Adapter, channel);
 
-		//do IQK when all parameters are ready
+		/* do IQK when all parameters are ready */
 		phy_ReloadIQKSetting(Adapter, channel);
 		break;
 	}while (true);
 
-	//s3. post common command - CmdID_End, None
+	/* s3. post common command - CmdID_End, None */
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (BuddyAdapter) {
@@ -3282,12 +3033,11 @@ static void _PHY_SwChnl8192D(struct rtw_
 
 
 void
-PHY_SwChnl8192D(	// Call after initialization
+PHY_SwChnl8192D(	/*  Call after initialization */
 	struct rtw_adapter *Adapter,
 	u8		channel
 	)
 {
-	//struct rtw_adapter * Adapter =  ADJUST_TO_ADAPTIVE_ADAPTER(pAdapter, true);
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	u8	tmpchannel = pHalData->CurrentChannel;
 	bool  bResult = true;
@@ -3300,24 +3050,18 @@ PHY_SwChnl8192D(	// Call after initializ
 
 	if (pHalData->rf_chip == RF_PSEUDO_11N)
 	{
-		//pHalData->SwChnlInProgress=FALSE;
-		return;									//return immediately if it is peudo-phy
+		return;									/* return immediately if it is peudo-phy */
 	}
 
 	if (Adapter->mlmeextpriv.sitesurvey_res.state == SCAN_COMPLETE)
 		pHalData->bLoadIMRandIQKSettingFor2G = false;
 
-	//if (pHalData->SwChnlInProgress)
-	//	return;
 
-	//if (pHalData->SetBWModeInProgress)
-	//	return;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (pHalData->bInModeSwitchProcess)
 	{
 		DBG_8192D("PHY_SwChnl8192D(): During mode switch\n");
-		//pHalData->SwChnlInProgress=false;
 		return;
 	}
 
@@ -3348,88 +3092,51 @@ PHY_SwChnl8192D(	// Call after initializ
 		timecount += 50;
 	}
 
-	//--------------------------------------------
+	/*  */
 	switch (pHalData->CurrentWirelessMode)
 	{
 		case WIRELESS_MODE_A:
 		case WIRELESS_MODE_N_5G:
-			//Get first channel error when change between 5G and 2.4G band.
-			//FIX ME!!!
-			//if (channel <=14)
-			//	return;
-			//RT_ASSERT((channel>14), ("WIRELESS_MODE_A but channel<=14"));
+			/* Get first channel error when change between 5G and 2.4G band. */
+			/* FIX ME!!! */
 			break;
-
 		case WIRELESS_MODE_B:
-			//if (channel>14)
-			//	return;
-			//RT_ASSERT((channel<=14), ("WIRELESS_MODE_B but channel>14"));
 			break;
-
 		case WIRELESS_MODE_G:
 		case WIRELESS_MODE_N_24G:
-			//Get first channel error when change between 5G and 2.4G band.
-			//FIX ME!!!
-			//if (channel > 14)
-			//	return;
-			//RT_ASSERT((channel<=14), ("WIRELESS_MODE_G but channel>14"));
+			/* Get first channel error when change between 5G and 2.4G band. */
 			break;
 
 		default:
-			//RT_ASSERT(FALSE, ("Invalid WirelessMode(%#x)!!\n", pHalData->CurrentWirelessMode));
 			break;
 	}
-	//--------------------------------------------
+	/*  */
 
-	//pHalData->SwChnlInProgress = TRUE;
-	if (channel == 0) {//FIXME!!!A band?
+	if (channel == 0) {/* FIXME!!!A band? */
 		channel = 1;
 	}
 
 	pHalData->CurrentChannel=channel;
 
-	//pHalData->SwChnlStage=0;
-	//pHalData->SwChnlStep=0;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if ((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
 	{
 		DBG_8192D("PHY_SwChnl8192D():slave return when slave\n");
-		//pHalData->SwChnlInProgress=false;
 		return;
 	}
 #endif
 
 	if ((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))
 	{
-#ifdef USE_WORKITEM
-		//bResult = PlatformScheduleWorkItem(&(pHalData->SwChnlWorkItem));
-#else
+#ifndef USE_WORKITEM
 		_PHY_SwChnl8192D(Adapter, channel);
 #endif
-		if (bResult)
-		{
-			//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress TRUE schdule workitem done\n"));
-		}
-		else
-		{
-			//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress FALSE schdule workitem error\n"));
-			//if (IS_HARDWARE_TYPE_8192SU(Adapter))
-			//{
-			//	pHalData->SwChnlInProgress = FALSE;
+		if (!bResult)
 				pHalData->CurrentChannel = tmpchannel;
-			//}
-		}
 
-	}
-	else
-	{
-		//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress FALSE driver sleep or unload\n"));
-		//if (IS_HARDWARE_TYPE_8192SU(Adapter))
-		//{
-		//	pHalData->SwChnlInProgress = FALSE;
+	} else {
 			pHalData->CurrentChannel = tmpchannel;
-		//}
 	}
 }
 
@@ -3474,7 +3181,7 @@ phy_SetSwChnlCmdArray(
 }
 
 static	void
-phy_FinishSwChnlNow(	// We should not call this function directly
+phy_FinishSwChnlNow(	/*  We should not call this function directly */
 		struct rtw_adapter *	Adapter,
 		u8		channel
 		)
@@ -3482,61 +3189,50 @@ phy_FinishSwChnlNow(	// We should not ca
 }
 
 
-//
-// Description:
-//	Switch channel synchronously. Called by SwChnlByDelayHandler.
-//
-// Implemented by Bruce, 2008-02-14.
-// The following procedure is operted according to SwChanlCallback8190Pci().
-// However, this procedure is performed synchronously  which should be running under
-// passive level.
-//
+/*  */
+/*  Description: */
+/* 	Switch channel synchronously. Called by SwChnlByDelayHandler. */
+/*  */
+/*  Implemented by Bruce, 2008-02-14. */
+/*  The following procedure is operted according to SwChanlCallback8190Pci(). */
+/*  However, this procedure is performed synchronously  which should be running under */
+/*  passive level. */
+/*  */
 void
-PHY_SwChnlPhy8192D(	// Only called during initialize
+PHY_SwChnlPhy8192D(	/*  Only called during initialize */
 	struct rtw_adapter *	Adapter,
 	u8		channel
 	)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
-	//RT_TRACE(COMP_SCAN | COMP_RM, DBG_LOUD, ("==>PHY_SwChnlPhy8192S(), switch from channel %d to channel %d.\n", pHalData->CurrentChannel, channel));
 
-	// Cannot IO.
-	//if (RT_CANNOT_IO(Adapter))
-	//	return;
+	/*  Cannot IO. */
 
-	// Channel Switching is in progress.
-	//if (pHalData->SwChnlInProgress)
-	//	return;
+	/*  Channel Switching is in progress. */
 
-	//return immediately if it is peudo-phy
+	/* return immediately if it is peudo-phy */
 	if (pHalData->rf_chip == RF_PSEUDO_11N)
 	{
-		//pHalData->SwChnlInProgress=FALSE;
 		return;
 	}
 
-	//pHalData->SwChnlInProgress = TRUE;
 	if (channel == 0)
 		channel = 1;
 
 	pHalData->CurrentChannel=channel;
 
-	//pHalData->SwChnlStage = 0;
-	//pHalData->SwChnlStep = 0;
-
 	phy_FinishSwChnlNow(Adapter,channel);
 
-	//pHalData->SwChnlInProgress = FALSE;
 }
 
 
-//
-//	Description:
-//		Configure H/W functionality to enable/disable Monitor mode.
-//		Note, because we possibly need to configure BB and RF in this function,
-//		so caller should in PASSIVE_LEVEL. 080118, by rcnjko.
-//
+/*  */
+/* 	Description: */
+/* 		Configure H/W functionality to enable/disable Monitor mode. */
+/* 		Note, because we possibly need to configure BB and RF in this function, */
+/* 		so caller should in PASSIVE_LEVEL. 080118, by rcnjko. */
+/*  */
 void
 PHY_SetMonitorMode8192D(
 	struct rtw_adapter *			pAdapter,
@@ -3568,23 +3264,22 @@ PHY_CheckIsLegalRfPath8192D(
 	struct rtw_adapter *	pAdapter,
 	u32	eRFPath)
 {
-//	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 	bool				rtValue = true;
 
-	// NOt check RF Path now.!
+	/*  NOt check RF Path now.! */
 	return	rtValue;
 }	/* PHY_CheckIsLegalRfPath8192D */
 
-//-------------------------------------------------------------------------
-//
-//	IQK
-//
-//-------------------------------------------------------------------------
+/*  */
+/*  */
+/* 	IQK */
+/*  */
+/*  */
 #define MAX_TOLERANCE		5
 #define MAX_TOLERANCE_92D	3
-#define IQK_DELAY_TIME		1	//ms
+#define IQK_DELAY_TIME		1	/* ms */
 
-static u8			//bit0 = 1 => Tx OK, bit1 = 1 => Rx OK
+static u8			/* bit0 = 1 => Tx OK, bit1 = 1 => Rx OK */
 phy_PathA_IQK(
 	struct rtw_adapter *	pAdapter,
 	bool		configPathB
@@ -3594,10 +3289,7 @@ phy_PathA_IQK(
 	u8	result = 0x00;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 
-	//RTPRINT(FINIT, INIT_IQK, ("Path A IQK!\n"));
-
-	//path-A IQK setting
-	//RTPRINT(FINIT, INIT_IQK, ("Path-A IQK setting!\n"));
+	/* path-A IQK setting */
 	if (pHalData->interfaceIndex == 0)
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
@@ -3614,7 +3306,7 @@ phy_PathA_IQK(
 	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, configPathB ? 0x28160202 :
 		IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID)?0x28160202:0x28160502);
 
-	//path-B IQK setting
+	/* path-B IQK setting */
 	if (configPathB)
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x10008c22);
@@ -3626,40 +3318,33 @@ phy_PathA_IQK(
 			PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x28160202);
 	}
 
-	//LO calibration setting
-	//RTPRINT(FINIT, INIT_IQK, ("LO calibration setting!\n"));
+	/* LO calibration setting */
 	if (IS_HARDWARE_TYPE_8192D(pAdapter))
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 	else
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x001028d1);
 
-	//One shot, path A LOK & IQK
-	//RTPRINT(FINIT, INIT_IQK, ("One shot, path A LOK & IQK!\n"));
+	/* One shot, path A LOK & IQK */
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
-	// delay x ms
-	//RTPRINT(FINIT, INIT_IQK, ("Delay %d ms for One shot, path A LOK & IQK.\n", IQK_DELAY_TIME));
+	/*  delay x ms */
 	rtw_udelay_os(IQK_DELAY_TIME*1000);
 
-	// Check failed
+	/*  Check failed */
 	regEAC = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-	//RTPRINT(FINIT, INIT_IQK, ("0xeac = 0x%x\n", regEAC));
 	regE94 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord);
-	//RTPRINT(FINIT, INIT_IQK, ("0xe94 = 0x%x\n", regE94));
 	regE9C= PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord);
-	//RTPRINT(FINIT, INIT_IQK, ("0xe9c = 0x%x\n", regE9C));
 	regEA4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
-	//RTPRINT(FINIT, INIT_IQK, ("0xea4 = 0x%x\n", regEA4));
 
 	if (!(regEAC & BIT28) &&
 		(((regE94 & 0x03FF0000)>>16) != 0x142) &&
 		(((regE9C & 0x03FF0000)>>16) != 0x42))
 		result |= 0x01;
-	else							//if Tx not OK, ignore Rx
+	else							/* if Tx not OK, ignore Rx */
 		return result;
 
-	if (!(regEAC & BIT27) &&		//if Tx is OK, check whether Rx is OK
+	if (!(regEAC & BIT27) &&		/* if Tx is OK, check whether Rx is OK */
 		(((regEA4 & 0x03FF0000)>>16) != 0x132) &&
 		(((regEAC & 0x03FF0000)>>16) != 0x36))
 		result |= 0x02;
@@ -3670,7 +3355,7 @@ phy_PathA_IQK(
 
 }
 
-static u8			//bit0 = 1 => Tx OK, bit1 = 1 => Rx OK
+static u8			/* bit0 = 1 => Tx OK, bit1 = 1 => Rx OK */
 phy_PathA_IQK_5G_Normal(
 	struct rtw_adapter *	pAdapter,
 	bool		configPathB
@@ -3690,23 +3375,21 @@ phy_PathA_IQK_5G_Normal(
 
 	u32	TxOKBit = BIT28, RxOKBit = BIT27;
 
-	if (pHalData->interfaceIndex == 1)	//PHY1
+	if (pHalData->interfaceIndex == 1)	/* PHY1 */
 	{
 		TxOKBit = BIT31;
 		RxOKBit = BIT30;
 	}
 
-	//RTPRINT(FINIT, INIT_IQK, ("Path A IQK!\n"));
 
-	//path-A IQK setting
-	//RTPRINT(FINIT, INIT_IQK, ("Path-A IQK setting!\n"));
+	/* path-A IQK setting */
 
 	PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
 	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
 	PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82140307);
 	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68160960);
 
-	//path-B IQK setting
+	/* path-B IQK setting */
 	if (configPathB)
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
@@ -3715,23 +3398,21 @@ phy_PathA_IQK_5G_Normal(
 		PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
 	}
 
-	//LO calibration setting
-	//RTPRINT(FINIT, INIT_IQK, ("LO calibration setting!\n"));
+	/* LO calibration setting */
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 
-	//path-A PA on
+	/* path-A PA on */
 	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x07000f60);
 	PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, 0x66e60e30);
 
 	for (i = 0 ; i < retryCount ; i++)
 	{
 
-		//One shot, path A LOK & IQK
-		//RTPRINT(FINIT, INIT_IQK, ("One shot, path A LOK & IQK!\n"));
+		/* One shot, path A LOK & IQK */
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
-		// delay x ms
+		/*  delay x ms */
 		rtw_mdelay_os(IQK_DELAY_TIME*10);
 
 		while (timecount < timeout && PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, BIT26) == 0x00)
@@ -3745,34 +3426,26 @@ phy_PathA_IQK_5G_Normal(
 		{
 			rtw_udelay_os(IQK_DELAY_TIME*1000*2);
 			timecount++;
-			//RTPRINT(FINIT, INIT_IQK, ("Delay %d ms for polling 0xea4[25:16]\n", timecount*2));
 		}
 
-		//RTPRINT(FINIT, INIT_IQK, ("0xea0 = 0x%lx\n", PHY_QueryBBReg(pAdapter, 0xea0, bMaskDWord)));
-		//RTPRINT(FINIT, INIT_IQK, ("0xea8 = 0x%lx\n", PHY_QueryBBReg(pAdapter, 0xea8, bMaskDWord)));
 
-		// Check failed
+		/*  Check failed */
 		regEAC = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-		//RTPRINT(FINIT, INIT_IQK, ("0xeac = 0x%lx\n", regEAC));
 		regE94 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord);
-		//RTPRINT(FINIT, INIT_IQK, ("0xe94 = 0x%lx\n", regE94));
 		regE9C= PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord);
-		//RTPRINT(FINIT, INIT_IQK, ("0xe9c = 0x%lx\n", regE9C));
 		regEA4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
-		//RTPRINT(FINIT, INIT_IQK, ("0xea4 = 0x%lx\n", regEA4));
 
 		if (!(regEAC & TxOKBit) &&
 			(((regE94 & 0x03FF0000)>>16) != 0x142) )
 		{
 			result |= 0x01;
 		}
-		else			//if Tx not OK, ignore Rx
+		else			/* if Tx not OK, ignore Rx */
 		{
-			//RTPRINT(FINIT, INIT_IQK, ("Path A Tx IQK fail!!\n"));
 			continue;
 		}
 
-		if (!(regEAC & RxOKBit) &&			//if Tx is OK, check whether Rx is OK
+		if (!(regEAC & RxOKBit) &&			/* if Tx is OK, check whether Rx is OK */
 			(((regEA4 & 0x03FF0000)>>16) != 0x132))
 		{
 			result |= 0x02;
@@ -3780,20 +3453,19 @@ phy_PathA_IQK_5G_Normal(
 		}
 		else
 		{
-			//RTPRINT(FINIT, INIT_IQK, ("Path A Rx IQK fail!!\n"));
 		}
 	}
 
-	//path A PA off
+	/* path A PA off */
 	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, pdmpriv->IQK_BB_backup[0]);
 	PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pdmpriv->IQK_BB_backup[1]);
 
-	if (!(result & 0x01))	//Tx IQK fail
+	if (!(result & 0x01))	/* Tx IQK fail */
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x19008c00);
 	}
 
-	if (!(result & 0x02))	//Rx IQK fail
+	if (!(result & 0x02))	/* Rx IQK fail */
 	{
 		PHY_SetBBReg(pAdapter, rOFDM0_XARxIQImbalance , bMaskDWord, 0x40000100);
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A , bMaskDWord, 0x19008c00);
@@ -3804,35 +3476,27 @@ phy_PathA_IQK_5G_Normal(
 	return result;
 }
 
-static u8				//bit0 = 1 => Tx OK, bit1 = 1 => Rx OK
+static u8				/* bit0 = 1 => Tx OK, bit1 = 1 => Rx OK */
 phy_PathB_IQK(
 	struct rtw_adapter *	pAdapter
 	)
 {
 	u32 regEAC, regEB4, regEBC, regEC4, regECC;
 	u8	result = 0x00;
-	//RTPRINT(FINIT, INIT_IQK, ("Path B IQK!\n"));
 
-	//One shot, path B LOK & IQK
-	//RTPRINT(FINIT, INIT_IQK, ("One shot, path A LOK & IQK!\n"));
+	/* One shot, path B LOK & IQK */
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
 
-	// delay x ms
-	//RTPRINT(FINIT, INIT_IQK, ("Delay %d ms for One shot, path B LOK & IQK.\n", IQK_DELAY_TIME));
-	rtw_udelay_os(IQK_DELAY_TIME*1000);//PlatformStallExecution(IQK_DELAY_TIME*1000);
+	/*  delay x ms */
+	rtw_udelay_os(IQK_DELAY_TIME*1000);/* PlatformStallExecution(IQK_DELAY_TIME*1000); */
 
-	// Check failed
+	/*  Check failed */
 	regEAC = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-	//RTPRINT(FINIT, INIT_IQK, ("0xeac = 0x%x\n", regEAC));
 	regEB4 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord);
-	//RTPRINT(FINIT, INIT_IQK, ("0xeb4 = 0x%x\n", regEB4));
 	regEBC= PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord);
-	//RTPRINT(FINIT, INIT_IQK, ("0xebc = 0x%x\n", regEBC));
 	regEC4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
-	//RTPRINT(FINIT, INIT_IQK, ("0xec4 = 0x%x\n", regEC4));
 	regECC= PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord);
-	//RTPRINT(FINIT, INIT_IQK, ("0xecc = 0x%x\n", regECC));
 
 	if (!(regEAC & BIT31) &&
 		(((regEB4 & 0x03FF0000)>>16) != 0x142) &&
@@ -3852,7 +3516,7 @@ phy_PathB_IQK(
 	return result;
 }
 
-static u8				//bit0 = 1 => Tx OK, bit1 = 1 => Rx OK
+static u8				/* bit0 = 1 => Tx OK, bit1 = 1 => Rx OK */
 phy_PathB_IQK_5G_Normal(
 	struct rtw_adapter *	pAdapter
 	)
@@ -3869,38 +3533,35 @@ phy_PathB_IQK_5G_Normal(
 #endif
 	u8	timeout = 20, timecount = 0;
 
-	//RTPRINT(FINIT, INIT_IQK, ("Path B IQK!\n"));
 
-	//path-A IQK setting
-	//RTPRINT(FINIT, INIT_IQK, ("Path-A IQK setting!\n"));
+	/* path-A IQK setting */
 	PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
 	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
 
 	PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
 	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
 
-	//path-B IQK setting
+	/* path-B IQK setting */
 	PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
 	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
 	PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82140307);
 	PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x68160960);
 
-	//LO calibration setting
-	//RTPRINT(FINIT, INIT_IQK, ("LO calibration setting!\n"));
+	/* LO calibration setting */
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 
-	//path-B PA on
+	/* path-B PA on */
 	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x0f600700);
 	PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, bMaskDWord, 0x061f0d30);
 
 	for (i = 0 ; i < retryCount ; i++)
 	{
-		//One shot, path B LOK & IQK
+		/* One shot, path B LOK & IQK */
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xfa000000);
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
 
-		// delay x ms
+		/*  delay x ms */
 		rtw_mdelay_os(IQK_DELAY_TIME*10);
 
 		while (timecount < timeout && PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, BIT29) == 0x00) {
@@ -3912,23 +3573,15 @@ phy_PathB_IQK_5G_Normal(
 		while (timecount < timeout && PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, 0x3FF0000) == 0x00) {
 			rtw_udelay_os(IQK_DELAY_TIME*1000*2);
 			timecount++;
-			//RTPRINT(FINIT, INIT_IQK, ("Delay %d ms for polling 0xec4[25:16]\n", timecount*2));
 		}
 
-		//RTPRINT(FINIT, INIT_IQK, ("0xec0 = 0x%lx\n", PHY_QueryBBReg(pAdapter, 0xec0, bMaskDWord)));
-		//RTPRINT(FINIT, INIT_IQK, ("0xec8 = 0x%lx\n", PHY_QueryBBReg(pAdapter, 0xec8, bMaskDWord)));
 
-		// Check failed
+		/*  Check failed */
 		regEAC = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
-		//RTPRINT(FINIT, INIT_IQK, ("0xeac = 0x%lx\n", regEAC));
 		regEB4 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord);
-		//RTPRINT(FINIT, INIT_IQK, ("0xeb4 = 0x%lx\n", regEB4));
 		regEBC= PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord);
-		//RTPRINT(FINIT, INIT_IQK, ("0xebc = 0x%lx\n", regEBC));
 		regEC4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
-		//RTPRINT(FINIT, INIT_IQK, ("0xec4 = 0x%lx\n", regEC4));
 		regECC= PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord);
-		//RTPRINT(FINIT, INIT_IQK, ("0xecc = 0x%lx\n", regECC));
 
 		if (!(regEAC & BIT31) &&
 			(((regEB4 & 0x03FF0000)>>16) != 0x142))
@@ -3944,20 +3597,19 @@ phy_PathB_IQK_5G_Normal(
 		}
 		else
 		{
-			//RTPRINT(FINIT, INIT_IQK, ("Path B Rx IQK fail!!\n"));
 		}
 	}
 
-	//path B PA off
+	/* path B PA off */
 	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, pdmpriv->IQK_BB_backup[0]);
 	PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, bMaskDWord, pdmpriv->IQK_BB_backup[2]);
 
-	if (!(result & 0x01))	//Tx IQK fail
+	if (!(result & 0x01))	/* Tx IQK fail */
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x19008c00);
 	}
 
-	if (!(result & 0x02))	//Rx IQK fail
+	if (!(result & 0x02))	/* Rx IQK fail */
 	{
 		PHY_SetBBReg(pAdapter, rOFDM0_XBRxIQImbalance , bMaskDWord, 0x40000100);
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B , bMaskDWord, 0x19008c00);
@@ -3980,20 +3632,18 @@ phy_PathAFillIQKMatrix(
 	int	Y, TX0_C;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 
-	//DBG_8192D("Path A IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed");
 
 	if (final_candidate == 0xFF)
 		return;
 
 	else if (bIQKOK)
 	{
-		Oldval_0 = (PHY_QueryBBReg(pAdapter, rOFDM0_XATxIQImbalance, bMaskDWord) >> 22) & 0x3FF;//OFDM0_D
+		Oldval_0 = (PHY_QueryBBReg(pAdapter, rOFDM0_XATxIQImbalance, bMaskDWord) >> 22) & 0x3FF;/* OFDM0_D */
 
 		X = result[final_candidate][0];
 		if ((X & 0x00000200) != 0)
 			X = X | 0xFFFFFC00;
 		TX0_A = (X * Oldval_0) >> 8;
-		//RTPRINT(FINIT, INIT_IQK, ("X = 0x%lx, TX0_A = 0x%lx, Oldval_0 0x%lx\n", X, TX0_A, Oldval_0));
 		PHY_SetBBReg(pAdapter, rOFDM0_XATxIQImbalance, 0x3FF, TX0_A);
 		if (IS_HARDWARE_TYPE_8192D(pAdapter))
 			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT24, ((X* Oldval_0>>7) & 0x1));
@@ -4004,12 +3654,11 @@ phy_PathAFillIQKMatrix(
 		if ((Y & 0x00000200) != 0)
 			Y = Y | 0xFFFFFC00;
 
-		//path B IQK result + 3
+		/* path B IQK result + 3 */
 		if (pHalData->interfaceIndex == 1 && pHalData->CurrentBandType92D == BAND_ON_5G)
 			Y += 3;
 
 		TX0_C = (Y * Oldval_0) >> 8;
-		//RTPRINT(FINIT, INIT_IQK, ("Y = 0x%lx, TX0_C = 0x%lx\n", Y, TX0_C));
 		PHY_SetBBReg(pAdapter, rOFDM0_XCTxAFE, 0xF0000000, ((TX0_C&0x3C0)>>6));
 		PHY_SetBBReg(pAdapter, rOFDM0_XATxIQImbalance, 0x003F0000, (TX0_C&0x3F));
 		if (IS_HARDWARE_TYPE_8192D(pAdapter)/*&&is2T*/)
@@ -4019,7 +3668,6 @@ phy_PathAFillIQKMatrix(
 
 	        if (bTxOnly)
 		{
-			//DBG_8192D("_PHY_PathAFillIQKMatrix only Tx OK\n");
 			return;
 		}
 
@@ -4046,10 +3694,6 @@ phy_PathAFillIQKMatrix_5G_Normal(
 	u32	X, reg;
 	int	Y;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
-	//bool		is2T =  IS_92D_SINGLEPHY(pHalData->VersionID) ||
-	//				pHalData->MacPhyMode92D == DUALMAC_DUALPHY;
-
-	//DBG_8192D("Path A IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed");
 
 	if (bIQKOK && final_candidate != 0xFF)
 	{
@@ -4057,30 +3701,23 @@ phy_PathAFillIQKMatrix_5G_Normal(
 		if ((X & 0x00000200) != 0)
 			X = X | 0xFFFFFC00;
 
-		//RTPRINT(FINIT, INIT_IQK, ("X = 0x%lx\n", X));
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, 0x3FF0000, X);
 		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT24, 0);
 
-		//RTPRINT(FINIT, INIT_IQK, ("0xe30 = 0x%lx\n", PHY_QueryBBReg(pAdapter, 0xe30, bMaskDWord)));
-
 		Y = result[final_candidate][1];
 		if ((Y & 0x00000200) != 0)
 			Y = Y | 0xFFFFFC00;
 
-		//path A/B IQK result + 3, suggest by Jenyu
+		/* path A/B IQK result + 3, suggest by Jenyu */
 		if (pHalData->CurrentBandType92D == BAND_ON_5G)
 			Y += 3;
 
-		//RTPRINT(FINIT, INIT_IQK, ("Y = 0x%lx\n", Y));
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, 0x003FF, Y);
-		//if (is2T)
-			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT26, 0);
+		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT26, 0);
 
-		//RTPRINT(FINIT, INIT_IQK, ("0xe30 = 0x%lx\n", PHY_QueryBBReg(pAdapter, 0xe30, bMaskDWord)));
 
 		if (bTxOnly)
 		{
-			//DBG_8192D("_PHY_PathAFillIQKMatrix only Tx OK\n");
 			return;
 		}
 
@@ -4108,15 +3745,13 @@ phy_PathBFillIQKMatrix(
 	bool	bIQKOK,
 	int		result[][8],
 	u8		final_candidate,
-	bool	bTxOnly			//do Tx only
+	bool	bTxOnly			/* do Tx only */
 	)
 {
 	u32	Oldval_1, X, TX1_A, reg;
 	int	Y, TX1_C;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 
-	//DBG_8192D("Path B IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed");
-
         if (final_candidate == 0xFF)
 		return;
 
@@ -4128,7 +3763,6 @@ phy_PathBFillIQKMatrix(
 		if ((X & 0x00000200) != 0)
 			X = X | 0xFFFFFC00;
 		TX1_A = (X * Oldval_1) >> 8;
-		//RTPRINT(FINIT, INIT_IQK, ("X = 0x%lx, TX1_A = 0x%lx\n", X, TX1_A));
 		PHY_SetBBReg(pAdapter, rOFDM0_XBTxIQImbalance, 0x3FF, TX1_A);
 		if (IS_HARDWARE_TYPE_8192D(pAdapter))
 			PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT28, ((X* Oldval_1>>7) & 0x1));
@@ -4139,9 +3773,8 @@ phy_PathBFillIQKMatrix(
 		if ((Y & 0x00000200) != 0)
 			Y = Y | 0xFFFFFC00;
 		if (pHalData->CurrentBandType92D == BAND_ON_5G)
-			Y += 3;		//temp modify for preformance
+			Y += 3;		/* temp modify for preformance */
 		TX1_C = (Y * Oldval_1) >> 8;
-		//RTPRINT(FINIT, INIT_IQK, ("Y = 0x%lx, TX1_C = 0x%lx\n", Y, TX1_C));
 		PHY_SetBBReg(pAdapter, rOFDM0_XDTxAFE, 0xF0000000, ((TX1_C&0x3C0)>>6));
 		PHY_SetBBReg(pAdapter, rOFDM0_XBTxIQImbalance, 0x003F0000, (TX1_C&0x3F));
 		if (IS_HARDWARE_TYPE_8192D(pAdapter))
@@ -4169,22 +3802,19 @@ phy_PathBFillIQKMatrix_5G_Normal(
 	bool	bIQKOK,
 	int		result[][8],
 	u8		final_candidate,
-	bool	bTxOnly			//do Tx only
+	bool	bTxOnly			/* do Tx only */
 	)
 {
 	u32	X, reg;
 	int	Y;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 
-	//DBG_8192D("Path B IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed");
-
 	if (bIQKOK && final_candidate != 0xFF)
 	{
 		X = result[final_candidate][4];
 		if ((X & 0x00000200) != 0)
 			X = X | 0xFFFFFC00;
 
-		//RTPRINT(FINIT, INIT_IQK, ("X = 0x%lx\n", X));
 		PHY_SetBBReg(pAdapter, 0xe50, 0x3FF0000, X);
 		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT28, 0);
 
@@ -4192,9 +3822,8 @@ phy_PathBFillIQKMatrix_5G_Normal(
 		if ((Y & 0x00000200) != 0)
 			Y = Y | 0xFFFFFC00;
 		if (pHalData->CurrentBandType92D == BAND_ON_5G)
-			Y += 3;		//temp modify for preformance, suggest by Jenyu
+			Y += 3;		/* temp modify for preformance, suggest by Jenyu */
 
-		//RTPRINT(FINIT, INIT_IQK, ("Y = 0x%lx\n", Y));
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, 0x003FF, Y);
 		PHY_SetBBReg(pAdapter, rOFDM0_ECCAThreshold, BIT30, 0);
 
@@ -4229,10 +3858,6 @@ phy_SaveADDARegisters(
 {
 	u32	i;
 
-	//if (ODM_CheckPowerStatus(pAdapter) == false)
-	//	return;
-
-	//RTPRINT(FINIT, INIT_IQK, ("Save ADDA parameters.\n"));
 	for (i = 0 ; i < RegisterNum ; i++) {
 		ADDABackup[i] = PHY_QueryBBReg(pAdapter, ADDAReg[i], bMaskDWord);
 	}
@@ -4247,7 +3872,6 @@ phy_SaveMACRegisters(
 {
 	u32	i;
 
-	//RTPRINT(FINIT, INIT_IQK, ("Save MAC parameters.\n"));
 	for (i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++) {
 		MACBackup[i] = rtw_read8(pAdapter, MACReg[i]);
 	}
@@ -4264,9 +3888,8 @@ phy_ReloadADDARegisters(
 {
 	u32	i;
 
-	//RTPRINT(FINIT, INIT_IQK, ("Reload ADDA power saving parameters !\n"));
 	for (i = 0 ; i < RegiesterNum ; i++) {
-		//path-A/B BB to initial gain
+		/* path-A/B BB to initial gain */
 		if (ADDAReg[i] == rOFDM0_XAAGCCore1 || ADDAReg[i] == rOFDM0_XBAGCCore1)
 			PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, 0x50);
 		PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, ADDABackup[i]);
@@ -4282,7 +3905,6 @@ phy_ReloadMACRegisters(
 {
 	u32	i;
 
-	//RTPRINT(FINIT, INIT_IQK, ("Reload MAC parameters !\n"));
 	for (i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++) {
 		rtw_write8(pAdapter, MACReg[i], (u8)MACBackup[i]);
 	}
@@ -4301,12 +3923,11 @@ phy_PathADDAOn(
 	u32	pathOn;
 	u32	i;
 
-	//RTPRINT(FINIT, INIT_IQK, ("ADDA ON.\n"));
 
 	pathOn = isPathAOn ? 0x04db25a4 : 0x0b1b25a4;
-	// Modified by Neil Chen
-	// for Path diversity and original IQK
-	if (isPathAOn)     // Neil Chen
+	/*  Modified by Neil Chen */
+	/*  for Path diversity and original IQK */
+	if (isPathAOn)     /*  Neil Chen */
 		pathOn = pHalData->interfaceIndex == 0? 0x04db25a4 : 0x0b1b25a4;
 
 	for (i = 0 ; i < IQK_ADDA_REG_NUM ; i++) {
@@ -4323,7 +3944,6 @@ phy_MACSettingCalibration(
 {
 	u32	i = 0;
 
-	//RTPRINT(FINIT, INIT_IQK, ("MAC settings for Calibration.\n"));
 
 	rtw_write8(pAdapter, MACReg[i], 0x3F);
 
@@ -4338,7 +3958,6 @@ phy_PathAStandBy(
 	struct rtw_adapter *	pAdapter
 	)
 {
-	//RTPRINT(FINIT, INIT_IQK, ("Path-A standby mode!\n"));
 
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x0);
 	PHY_SetBBReg(pAdapter, 0x840, bMaskDWord, 0x00010000);
@@ -4353,7 +3972,6 @@ phy_PIModeSwitch(
 {
 	u32	mode;
 
-	//RTPRINT(FINIT, INIT_IQK, ("BB Switch to %s mode!\n", (PIMode ? "PI" : "SI")));
 
 	mode = PIMode ? 0x01000100 : 0x01000000;
 	PHY_SetBBReg(pAdapter, 0x820, bMaskDWord, mode);
@@ -4370,7 +3988,7 @@ phy_SimularityCompare_92D(
 {
 	u32	i, j, diff, SimularityBitMap, bound = 0, u4temp = 0;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
-	u8	final_candidate[2] = {0xFF, 0xFF};	//for path A and path B
+	u8	final_candidate[2] = {0xFF, 0xFF};	/* for path A and path B */
 	bool		bResult = true;
 	bool		is2T = IS_92D_SINGLEPHY(pHalData->VersionID);
 
@@ -4381,7 +3999,7 @@ phy_SimularityCompare_92D(
 
 	SimularityBitMap = 0;
 
-	//check Tx
+	/* check Tx */
 	for (i = 0; i < bound; i++)
 	{
 		diff = (result[c1][i] > result[c2][i]) ? (result[c1][i] - result[c2][i]) : (result[c2][i] - result[c1][i]);
@@ -4417,29 +4035,29 @@ phy_SimularityCompare_92D(
 		{
 			u4temp += (result[c1][i]+	result[c2][i]);
 		}
-		if (u4temp == 0)	//IQK fail for c1 & c2
+		if (u4temp == 0)	/* IQK fail for c1 & c2 */
 			bResult = false;
 
 		return bResult;
 	}
 
-	if (!(SimularityBitMap & 0x0F))			//path A OK
+	if (!(SimularityBitMap & 0x0F))			/* path A OK */
 	{
 		for (i = 0; i < 4; i++)
 			result[3][i] = result[c1][i];
 	}
-	else if (!(SimularityBitMap & 0x03))		//path A, Tx OK
+	else if (!(SimularityBitMap & 0x03))		/* path A, Tx OK */
 	{
 		for (i = 0; i < 2; i++)
 			result[3][i] = result[c1][i];
 	}
 
-	if (!(SimularityBitMap & 0xF0) && is2T)		//path B OK
+	if (!(SimularityBitMap & 0xF0) && is2T)		/* path B OK */
 	{
 		for (i = 4; i < 8; i++)
 			result[3][i] = result[c1][i];
 	}
-	else if (!(SimularityBitMap & 0x30))		//path B, Tx OK
+	else if (!(SimularityBitMap & 0x30))		/* path B, Tx OK */
 	{
 		for (i = 4; i < 6; i++)
 			result[3][i] = result[c1][i];
@@ -4487,7 +4105,7 @@ phy_IQCalibrate(
 						REG_TXPAUSE,		REG_BCN_CTRL,
 						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
 
-	//since 92C & 92D have the different define in IQK_BB_REG
+	/* since 92C & 92D have the different define in IQK_BB_REG */
 	u32	IQK_BB_REG_92C[IQK_BB_REG_NUM_92C] = {
 							rOFDM0_TRxPathEnable,		rOFDM0_TRMuxPar,
 							rFPGA0_XCD_RFInterfaceSW,	rConfig_AntA,	rConfig_AntB,
@@ -4495,7 +4113,7 @@ phy_IQCalibrate(
 							rFPGA0_XB_RFInterfaceOE,	rFPGA0_RFMOD
 							};
 
-	u32	IQK_BB_REG_92D[IQK_BB_REG_NUM_92D] = {	//for normal
+	u32	IQK_BB_REG_92D[IQK_BB_REG_NUM_92D] = {	/* for normal */
 							rFPGA0_XAB_RFInterfaceSW,	rFPGA0_XA_RFInterfaceOE,
 							rFPGA0_XB_RFInterfaceOE,	rOFDM0_TRMuxPar,
 							rFPGA0_XCD_RFInterfaceSW,	rOFDM0_TRxPathEnable,
@@ -4509,18 +4127,16 @@ phy_IQCalibrate(
 	const u32	retryCount = 2;
 #endif
 
-	// Note: IQ calibration must be performed after loading
-	//		PHY_REG.txt , and radio_a, radio_b.txt
+	/*  Note: IQ calibration must be performed after loading */
+	/* 		PHY_REG.txt , and radio_a, radio_b.txt */
 
 	u32 bbvalue;
 
 	if (t==0)
 	{
 		bbvalue = PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bMaskDWord);
-		//RTPRINT(FINIT, INIT_IQK, ("PHY_IQCalibrate()==>0x%08lx\n",bbvalue));
-		//RTPRINT(FINIT, INIT_IQK, ("IQ Calibration for %s\n", (is2T ? "2T2R" : "1T1R")));
 
-		// Save ADDA parameters, turn Path A ADDA on
+		/*  Save ADDA parameters, turn Path A ADDA on */
 		phy_SaveADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 		phy_SaveMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 		if (IS_HARDWARE_TYPE_8192D(pAdapter))
@@ -4540,7 +4156,7 @@ phy_IQCalibrate(
 	}
 
 	if (!pdmpriv->bRfPiEnable) {
-		// Switch BB to PI mode to do IQ Calibration.
+		/*  Switch BB to PI mode to do IQ Calibration. */
 		phy_PIModeSwitch(pAdapter, true);
 	}
 
@@ -4564,7 +4180,7 @@ phy_IQCalibrate(
 		PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00010000);
 	}
 
-	//MAC settings
+	/* MAC settings */
 	phy_MACSettingCalibration(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 	if (IS_HARDWARE_TYPE_8192D(pAdapter))
@@ -4578,7 +4194,7 @@ phy_IQCalibrate(
 	}
 	else
 	{
-		//Page B init
+		/* Page B init */
 		PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x00080000);
 
 		if (is2T)
@@ -4587,8 +4203,7 @@ phy_IQCalibrate(
 		}
 	}
 
-	// IQ calibration setting
-	//RTPRINT(FINIT, INIT_IQK, ("IQK setting!\n"));
+	/*  IQ calibration setting */
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
 	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x01007c00);
 	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
@@ -4596,16 +4211,14 @@ phy_IQCalibrate(
 	for (i = 0 ; i < retryCount ; i++) {
 		PathAOK = phy_PathA_IQK(pAdapter, is2T);
 		if (PathAOK == 0x03) {
-			//RTPRINT(FINIT, INIT_IQK, ("Path A IQK Success!!\n"));
 			result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 			result[t][2] = (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
 			result[t][3] = (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
 			break;
 		}
-		else if (i == (retryCount-1) && PathAOK == 0x01)	//Tx IQK OK
+		else if (i == (retryCount-1) && PathAOK == 0x01)	/* Tx IQK OK */
 		{
-			//RTPRINT(FINIT, INIT_IQK, ("Path A IQK Only  Tx Success!!\n"));
 
 			result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
@@ -4619,22 +4232,20 @@ phy_IQCalibrate(
 	if (is2T) {
 		phy_PathAStandBy(pAdapter);
 
-		// Turn Path B ADDA on
+		/*  Turn Path B ADDA on */
 		phy_PathADDAOn(pAdapter, ADDA_REG, false, is2T);
 
 		for (i = 0 ; i < retryCount ; i++) {
 			PathBOK = phy_PathB_IQK(pAdapter);
 			if (PathBOK == 0x03) {
-				//RTPRINT(FINIT, INIT_IQK, ("Path B IQK Success!!\n"));
 				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 				result[t][6] = (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
 				result[t][7] = (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
 				break;
 			}
-			else if (i == (retryCount - 1) && PathBOK == 0x01)	//Tx IQK OK
+			else if (i == (retryCount - 1) && PathBOK == 0x01)	/* Tx IQK OK */
 			{
-				//RTPRINT(FINIT, INIT_IQK, ("Path B Only Tx IQK Success!!\n"));
 				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 			}
@@ -4645,24 +4256,24 @@ phy_IQCalibrate(
 		}
 	}
 
-	//Back to BB mode, load original value
-	//RTPRINT(FINIT, INIT_IQK, ("IQK:Back to BB mode, load original value!\n"));
+	/* Back to BB mode, load original value */
+	/* RTPRINT(FINIT, INIT_IQK, ("IQK:Back to BB mode, load original value!\n")); */
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0);
 
 	if (t!=0)
 	{
 		if (!pdmpriv->bRfPiEnable) {
-			// Switch back BB to SI mode after finish IQ Calibration.
+			/*  Switch back BB to SI mode after finish IQ Calibration. */
 			phy_PIModeSwitch(pAdapter, false);
 		}
 
-		// Reload ADDA power saving parameters
+		/*  Reload ADDA power saving parameters */
 		phy_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 
-		// Reload MAC parameters
+		/*  Reload MAC parameters */
 		phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
-		// Reload BB parameters
+		/*  Reload BB parameters */
 		if (IS_HARDWARE_TYPE_8192D(pAdapter))
 		{
 			if (is2T)
@@ -4675,19 +4286,18 @@ phy_IQCalibrate(
 
 		if (!IS_HARDWARE_TYPE_8192D(pAdapter))
 		{
-			// Restore RX initial gain
+			/*  Restore RX initial gain */
 			PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032ed3);
 			if (is2T) {
 				PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032ed3);
 			}
 		}
 
-		//load 0xe30 IQC default value
+		/* load 0xe30 IQC default value */
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);
 
 	}
-	//RTPRINT(FINIT, INIT_IQK, ("_PHY_IQCalibrate() <==\n"));
 }
 
 
@@ -4717,7 +4327,7 @@ phy_IQCalibrate_5G(
 						REG_TXPAUSE,		REG_BCN_CTRL,
 						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
 
-	u32			IQK_BB_REG[IQK_BB_REG_NUM_test] = {	//for normal
+	u32			IQK_BB_REG[IQK_BB_REG_NUM_test] = {	/* for normal */
 						rFPGA0_XAB_RFInterfaceSW,	rOFDM0_TRMuxPar,
 						rFPGA0_XCD_RFInterfaceSW,	rOFDM0_TRxPathEnable,
 						rFPGA0_RFMOD,			rFPGA0_AnalogParameter4
@@ -4729,32 +4339,32 @@ phy_IQCalibrate_5G(
 
 	DBG_8192D("IQ Calibration for %s\n", (is2T ? "2T2R" : "1T1R"));
 
-	//Save MAC default value
+	/* Save MAC default value */
 	phy_SaveMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
-	//Save BB Parameter
+	/* Save BB Parameter */
 	phy_SaveADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_test);
 
-	//Save AFE Parameters
+	/* Save AFE Parameters */
 	phy_SaveADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 
-	//1 Path-A TX IQK
-	//Path-A AFE all on
+	/* 1 Path-A TX IQK */
+	/* Path-A AFE all on */
 	phy_PathADDAOn(pAdapter, ADDA_REG, true, true);
 
-	//MAC register setting
+	/* MAC register setting */
 	phy_MACSettingCalibration(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
-	//IQK must be done in PI mode
+	/* IQK must be done in PI mode */
 	pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
 	if (!pdmpriv->bRfPiEnable)
 		phy_PIModeSwitch(pAdapter, true);
 
-	//TXIQK RF setting
+	/* TXIQK RF setting */
 	PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01940000);
 	PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01940000);
 
-	//BB setting
+	/* BB setting */
 	PHY_SetBBReg(pAdapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
 	PHY_SetBBReg(pAdapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
 	PHY_SetBBReg(pAdapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
@@ -4762,16 +4372,16 @@ phy_IQCalibrate_5G(
 	PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFInterfaceSW, BIT22|BIT21,  0x03);
 	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xf00000,  0x0f);
 
-	//AP or IQK
+	/* AP or IQK */
 	PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x0f600000);
 	PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x0f600000);
 
-	//IQK global setting
+	/* IQK global setting */
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
 	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x10007c00);
 	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
 
-	//path-A IQK setting
+	/* path-A IQK setting */
 	if (pHalData->interfaceIndex == 0)
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
@@ -4789,7 +4399,7 @@ phy_IQCalibrate_5G(
 		PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x821402e6);
 	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
 
-	//path-B IQK setting
+	/* path-B IQK setting */
 	if (is2T)
 	{
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
@@ -4798,22 +4408,21 @@ phy_IQCalibrate_5G(
 		PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
 	}
 
-	//LO calibration setting
+	/* LO calibration setting */
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 
-	//RTPRINT(FINIT, INIT_IQK, ("0x522 %x\n", rtw_read8(pAdapter, 0x522)));
 
-	//One shot, path A LOK & IQK
+	/* One shot, path A LOK & IQK */
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
-	//Delay 1 ms
+	/* Delay 1 ms */
 	rtw_udelay_os(IQK_DELAY_TIME*1000);
 
-	//Exit IQK mode
+	/* Exit IQK mode */
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 
-	//Check_TX_IQK_A_result()
+	/* Check_TX_IQK_A_result() */
 	REG0xe40 = PHY_QueryBBReg(pAdapter, rTx_IQK, bMaskDWord);
 	REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
 	REG0xe94 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord);
@@ -4834,24 +4443,24 @@ phy_IQCalibrate_5G(
 		DBG_8192D("IQK for 5G: Path A Tx Fail interface %u\n", pHalData->interfaceIndex);
 	}
 
-	//1 path A RX IQK
+	/* 1 path A RX IQK */
 	if (TX0IQKOK == true)
 	{
 
 		DBG_8192D("IQK for 5G: Path A Rx  START interface %u\n", pHalData->interfaceIndex);
 
-		//TXIQK RF setting
+		/* TXIQK RF setting */
 		PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
 		PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
 
-		//turn on external PA
+		/* turn on external PA */
 		if (pHalData->interfaceIndex == 1)
 			PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT(30), 0x01);
 
-		//IQK global setting
+		/* IQK global setting */
 		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
 
-		//path-A IQK setting
+		/* path-A IQK setting */
 		if (pHalData->interfaceIndex == 0)
 		{
 			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
@@ -4868,7 +4477,7 @@ phy_IQCalibrate_5G(
 		else
 			PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68160962);
 
-		//path-B IQK setting
+		/* path-B IQK setting */
 		if (is2T)
 		{
 			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
@@ -4877,25 +4486,25 @@ phy_IQCalibrate_5G(
 			PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
 		}
 
-		//load TX0 IMR setting
+		/* load TX0 IMR setting */
 		PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, RX0REG0xe40);
-		//Sleep(5) -> delay 1ms
+		/* Sleep(5) -> delay 1ms */
 		rtw_udelay_os(IQK_DELAY_TIME*1000);
 
-		//LO calibration setting
+		/* LO calibration setting */
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
 
-		//One shot, path A LOK & IQK
+		/* One shot, path A LOK & IQK */
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
 
-		//Delay 3 ms
+		/* Delay 3 ms */
 		rtw_udelay_os(3*IQK_DELAY_TIME*1000);
 
-		//Exit IQK mode
+		/* Exit IQK mode */
 		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 
-		//Check_RX_IQK_A_result()
+		/* Check_RX_IQK_A_result() */
 		REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
 		REG0xea4 = PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
 		if (pHalData->interfaceIndex == 0)
@@ -4923,47 +4532,47 @@ phy_IQCalibrate_5G(
 	if (!is2T)
 		goto Exit_IQK;
 
-	//1 path B TX IQK
-	//Path-B AFE all on
+	/* 1 path B TX IQK */
+	/* Path-B AFE all on */
 
 	DBG_8192D("IQK for 5G: Path B Tx  START interface %u\n", pHalData->interfaceIndex);
 
 	phy_PathADDAOn(pAdapter, ADDA_REG, false, true);
 
-	//TXIQK RF setting
+	/* TXIQK RF setting */
 	PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01940000);
 	PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01940000);
 
-	//IQK global setting
+	/* IQK global setting */
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
 	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x10007c00);
 
-	//path-A IQK setting
+	/* path-A IQK setting */
 	PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
 	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c1f);
 	PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
 	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
 
-	//path-B IQK setting
+	/* path-B IQK setting */
 	PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
 	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x30008c22);
 	PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82140386);
 	PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
 
-	//LO calibration setting
+	/* LO calibration setting */
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
 
-	//One shot, path A LOK & IQK
+	/* One shot, path A LOK & IQK */
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
 
-	//Delay 1 ms
+	/* Delay 1 ms */
 	rtw_udelay_os(IQK_DELAY_TIME*1000);
 
-	//Exit IQK mode
+	/* Exit IQK mode */
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 
-	// Check_TX_IQK_B_result()
+	/*  Check_TX_IQK_B_result() */
 	REG0xe40 = PHY_QueryBBReg(pAdapter, rTx_IQK, bMaskDWord);
 	REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
 	REG0xeb4 = PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord);
@@ -4977,7 +4586,7 @@ phy_IQCalibrate_5G(
 		TX1IQKOK = true;
 	}
 
-	//1 path B RX IQK
+	/* 1 path B RX IQK */
 	if (TX1IQKOK == true)
 	{
 
@@ -4994,48 +4603,48 @@ phy_IQCalibrate_5G(
 			extPAon = 0x0;
 		}
 
-		//TXIQK RF setting
+		/* TXIQK RF setting */
 		PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
 		PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
 
-		//turn on external PA
+		/* turn on external PA */
 		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT(30), extPAon);
 
-		//BB setting
+		/* BB setting */
 		PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, bMaskDWord, 0xcc300080);
 
-		//IQK global setting
+		/* IQK global setting */
 		PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
 
-		//path-A IQK setting
+		/* path-A IQK setting */
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x34008c1f);
 		PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
 		PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
 
-		//path-B IQK setting
+		/* path-B IQK setting */
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x14008c22);
 		PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
 		PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, REG0xe5c);
 
-		//load TX0 IMR setting
+		/* load TX0 IMR setting */
 		PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, RX1REG0xe40);
 
-		//Sleep(5) -> delay 1ms
+		/* Sleep(5) -> delay 1ms */
 		rtw_udelay_os(IQK_DELAY_TIME*1000);
 
-		//LO calibration setting
+		/* LO calibration setting */
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
 
-		//One shot, path A LOK & IQK
+		/* One shot, path A LOK & IQK */
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
 		PHY_SetBBReg(pAdapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
 
-		//Delay 1 ms
+		/* Delay 1 ms */
 		rtw_udelay_os(3*IQK_DELAY_TIME*1000);
 
-		//Check_RX_IQK_B_result()
+		/* Check_RX_IQK_B_result() */
 		REG0xeac = PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord);
 		REG0xec4 = PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
 		if (((REG0xeac&BIT(30)) == 0) && (((REG0xec4&0x3FF0000)>>16)!=0x132))
@@ -5048,11 +4657,11 @@ phy_IQCalibrate_5G(
 	}
 
 Exit_IQK:
-	//turn off external PA
+	/* turn off external PA */
 	if (pHalData->interfaceIndex == 1 || is2T)
 		PHY_SetBBReg(pAdapter, rFPGA0_XAB_RFParameter, BIT(30), 0);
 
-	//Exit IQK mode
+	/* Exit IQK mode */
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 	phy_ReloadADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_test);
 
@@ -5062,12 +4671,12 @@ Exit_IQK:
 	PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032fff);
 
 
-	//reload MAC default value
+	/* reload MAC default value */
 	phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 	if (!pdmpriv->bRfPiEnable)
 		phy_PIModeSwitch(pAdapter, false);
-	//Reload ADDA power saving parameters
+	/* Reload ADDA power saving parameters */
 	phy_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 }
 
@@ -5094,7 +4703,7 @@ phy_IQCalibrate_5G_Normal(
 						REG_TXPAUSE,		REG_BCN_CTRL,
 						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
 
-	u32			IQK_BB_REG[IQK_BB_REG_NUM] = {	//for normal
+	u32			IQK_BB_REG[IQK_BB_REG_NUM] = {	/* for normal */
 						rFPGA0_XAB_RFInterfaceSW,	rFPGA0_XA_RFInterfaceOE,
 						rFPGA0_XB_RFInterfaceOE,	rOFDM0_TRMuxPar,
 						rFPGA0_XCD_RFInterfaceSW,	rOFDM0_TRxPathEnable,
@@ -5102,30 +4711,23 @@ phy_IQCalibrate_5G_Normal(
 						rOFDM0_XAAGCCore1,		rOFDM0_XBAGCCore1
 					};
 
-	// Note: IQ calibration must be performed after loading
-	//		PHY_REG.txt , and radio_a, radio_b.txt
-	//3 PathDiv
-       //Neil Chen--2011--05--19--
-	u8                 rfPathDiv;   //for Path Diversity
-	//-------------------------------
+	/*  Note: IQ calibration must be performed after loading */
+	/* 		PHY_REG.txt , and radio_a, radio_b.txt */
+	/* 3 PathDiv */
+       /* Neil Chen--2011--05--19-- */
+	u8                 rfPathDiv;   /* for Path Diversity */
+	/*  */
 
 	u32	bbvalue;
 	bool		is2T =  IS_92D_SINGLEPHY(pHalData->VersionID);
 
-	//RTPRINT(FINIT, INIT_IQK, ("IQK for 5G NORMAL:Start!!! interface %d\n", pAdapter->interfaceIndex));
-
-	//rtw_udelay_os(IQK_DELAY_TIME*1000*100);	//delay after set IMR
-
-	//rtw_udelay_os(IQK_DELAY_TIME*1000*20);
 	rtw_mdelay_os(IQK_DELAY_TIME*20);
 
 	if (t==0)
 	{
 		bbvalue = PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bMaskDWord);
-		//RTPRINT(FINIT, INIT_IQK, ("PHY_IQCalibrate()==>0x%08lx\n",bbvalue));
-		//RTPRINT(FINIT, INIT_IQK, ("IQ Calibration for %s\n", (is2T ? "2T2R" : "1T1R")));
 
-		// Save ADDA parameters, turn Path A ADDA on
+		/*  Save ADDA parameters, turn Path A ADDA on */
 		phy_SaveADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 		phy_SaveMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 		if (is2T)
@@ -5134,26 +4736,24 @@ phy_IQCalibrate_5G_Normal(
 			phy_SaveADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D-1);
 	}
 
-	//===================================
-	//3 Path Diversity
-	//Path-A AFE all on
-	//Neil Chen--2011--05--19
+	/*  */
+	/* 3 Path Diversity */
+	/* Path-A AFE all on */
+	/* Neil Chen--2011--05--19 */
 	rfPathDiv =(u8) (PHY_QueryBBReg(pAdapter, 0xB30, bMaskDWord)>>27);
 
-	if ((rfPathDiv&0x01)==1)   // Div on
+	if ((rfPathDiv&0x01)==1)   /*  Div on */
 	{
 		phy_PathADDAOn(pAdapter, ADDA_REG, false, is2T);
-		//DbgPrint("=STEP= change ADDA Path to B Path\n");
 	}
 	else
 		phy_PathADDAOn(pAdapter, ADDA_REG, true, is2T);
-	//3 end
-       //=============================================//
+	/* 3 end */
+       /*  */
 
-	//Path-A AFE all on
-	//phy_PathADDAOn(pAdapter, ADDA_REG, true, is2T);
+	/* Path-A AFE all on */
 
-	//MAC settings
+	/* MAC settings */
 	phy_MACSettingCalibration(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 	if (t==0)
@@ -5162,7 +4762,7 @@ phy_IQCalibrate_5G_Normal(
 	}
 
 	if (!pdmpriv->bRfPiEnable) {
-		// Switch BB to PI mode to do IQ Calibration.
+		/*  Switch BB to PI mode to do IQ Calibration. */
 		phy_PIModeSwitch(pAdapter, true);
 	}
 
@@ -5172,16 +4772,16 @@ phy_IQCalibrate_5G_Normal(
 	PHY_SetBBReg(pAdapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
 	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xf00000, 0x0f);
 
-	//Page A AP setting for IQK
+	/* Page A AP setting for IQK */
 	PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x00000000);
 	PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x20000000);
 
-	//Page B AP setting for IQK
+	/* Page B AP setting for IQK */
 	if (is2T) {
 		PHY_SetBBReg(pAdapter, rPdp_AntB, bMaskDWord, 0x00000000);
 		PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x20000000);
 	}
-	// IQ calibration setting
+	/*  IQ calibration setting */
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
 	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x10007c00);
 	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
@@ -5195,7 +4795,7 @@ phy_IQCalibrate_5G_Normal(
 			result[t][2] = (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
 			result[t][3] = (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
 		}
-		else if (PathAOK == 0x01)	//Tx IQK OK
+		else if (PathAOK == 0x01)	/* Tx IQK OK */
 		{
 			DBG_8192D("Path A IQK Only  Tx Success!!\n");
 
@@ -5213,9 +4813,8 @@ phy_IQCalibrate_5G_Normal(
 	}
 
 	if (is2T) {
-		//_PHY_PathAStandBy(pAdapter);
 
-		// Turn Path B ADDA on
+		/*  Turn Path B ADDA on */
 		phy_PathADDAOn(pAdapter, ADDA_REG, false, is2T);
 
 		{
@@ -5227,7 +4826,7 @@ phy_IQCalibrate_5G_Normal(
 				result[t][6] = (PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
 				result[t][7] = (PHY_QueryBBReg(pAdapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
 			}
-			else if (PathBOK == 0x01)	//Tx IQK OK
+			else if (PathBOK == 0x01)	/* Tx IQK OK */
 			{
 				DBG_8192D("Path B Only Tx IQK Success!!\n");
 				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
@@ -5239,8 +4838,7 @@ phy_IQCalibrate_5G_Normal(
 		}
 	}
 
-	//Back to BB mode, load original value
-	//RTPRINT(FINIT, INIT_IQK, ("IQK:Back to BB mode, load original value!\n"));
+	/* Back to BB mode, load original value */
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0);
 
 	if (t!=0)
@@ -5250,22 +4848,22 @@ phy_IQCalibrate_5G_Normal(
 		else
 			phy_ReloadADDARegisters(pAdapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D-1);
 
-		//path A IQ path to DP block
+		/* path A IQ path to DP block */
 		PHY_SetBBReg(pAdapter, rPdp_AntA, bMaskDWord, 0x010170b8);
 
-		//path B IQ path to DP block
+		/* path B IQ path to DP block */
 		if (is2T)
 			PHY_SetBBReg(pAdapter, rPdp_AntB, bMaskDWord, 0x010170b8);
 
-		// Reload MAC parameters
+		/*  Reload MAC parameters */
 		phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 		if (!pdmpriv->bRfPiEnable) {
-			// Switch back BB to SI mode after finish IQ Calibration.
+			/*  Switch back BB to SI mode after finish IQ Calibration. */
 			phy_PIModeSwitch(pAdapter, false);
 		}
 
-		// Reload ADDA power saving parameters
+		/*  Reload ADDA power saving parameters */
 		phy_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 	}
 }
@@ -5284,28 +4882,28 @@ phy_LCCalibrate92D(
 	u16	timeout = 800, timecount = 0;
 #endif
 
-	//Check continuous TX and Packet TX
+	/* Check continuous TX and Packet TX */
 	tmpReg = rtw_read8(pAdapter, 0xd03);
 
-	if ((tmpReg&0x70) != 0)			//Deal with contisuous TX case
-		rtw_write8(pAdapter, 0xd03, tmpReg&0x8F);	//disable all continuous TX
-	else							// Deal with Packet TX case
-		rtw_write8(pAdapter, REG_TXPAUSE, 0xFF);			// block all queues
+	if ((tmpReg&0x70) != 0)			/* Deal with contisuous TX case */
+		rtw_write8(pAdapter, 0xd03, tmpReg&0x8F);	/* disable all continuous TX */
+	else							/*  Deal with Packet TX case */
+		rtw_write8(pAdapter, REG_TXPAUSE, 0xFF);			/*  block all queues */
 
 	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xF00000, 0x0F);
 
 	for (index = 0; index <path; index ++)
 	{
-		//1. Read original RF mode
+		/* 1. Read original RF mode */
 		RF_mode[index] = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_AC, bRFRegOffsetMask);
 
-		//2. Set RF mode = standby mode
+		/* 2. Set RF mode = standby mode */
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_AC, 0x70000, 0x01);
 
 		tmpu4Byte[index] = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask);
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, 0x700, 0x07);
 
-		//4. Set LC calibration begin
+		/* 4. Set LC calibration begin */
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_CHNLBW, 0x08000, 0x01);
 
 	}
@@ -5317,7 +4915,6 @@ phy_LCCalibrate92D(
 			timecount <= timeout)
 		{
 
-			//RTPRINT(FINIT, INIT_IQK,("PHY_LCK delay for %d ms=2\n", timecount));
 			#ifdef CONFIG_LONG_DELAY_ISSUE
 			rtw_msleep_os(50);
 			#else
@@ -5334,7 +4931,7 @@ phy_LCCalibrate92D(
 	#endif
 #endif
 
-	//Restore original situation
+	/* Restore original situation */
 	for (index = 0; index <path; index ++)
 	{
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask, tmpu4Byte[index]);
@@ -5343,17 +4940,17 @@ phy_LCCalibrate92D(
 
 	if ((tmpReg&0x70) != 0)
 	{
-		//Path-A
+		/* Path-A */
 		rtw_write8(pAdapter, 0xd03, tmpReg);
 	}
-	else // Deal with Packet TX case
+	else /*  Deal with Packet TX case */
 	{
 		rtw_write8(pAdapter, REG_TXPAUSE, 0x00);
 	}
 
 	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xF00000, 0x00);
 }
-#endif  //SWLCK != 1, amy, temp remove
+#endif  /* SWLCK != 1, amy, temp remove */
 
 static u32
 get_abs(
@@ -5402,7 +4999,7 @@ phy_CalcCurvIndex(
 		{
 			if (i != start)
 				pre_channel = channel;
-			channel = GetChnlFromPlace(i);	//actual channel number
+			channel = GetChnlFromPlace(i);	/* actual channel number */
 
 			if (i == start)
 				pre_channel = channel;
@@ -5425,7 +5022,7 @@ phy_CalcCurvIndex(
 			{
 				bBase = true;
 				base_index = 0;
-				search_bound = (CV_CURVE_CNT*2);	//search every 128
+				search_bound = (CV_CURVE_CNT*2);	/* search every 128 */
 				break;
 			}
 			else if (channel < Base_chnl[j] || j == end_base-1)
@@ -5433,7 +5030,7 @@ phy_CalcCurvIndex(
 				base_index = CurveIndex[GetRightChnlPlace(pre_channel)-1];
 
 				if (base_index > 5)
-					base_index -= 5;	//search -5~5, not every 128
+					base_index -= 5;	/* search -5~5, not every 128 */
 				else
 					base_index = 0;
 				search_bound = base_index+10;
@@ -5466,33 +5063,31 @@ phy_LCCalibrate92DSW(
 	u8	RF_mode[2], tmpReg, index = 0;
 #if (TESTFLAG == 0)
 	u32	tmpu4Byte[2];
-#endif //(TESTFLAG == 0)
+#endif /* TESTFLAG == 0) */
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 	u8	u1bTmp=0,path = is2T?2:1;
 	u32	i, u4tmp, offset;
 	u32	curveCountVal[CV_CURVE_CNT*2]={0};
 	u16	timeout = 800, timecount = 0;
 
-	//Check continuous TX and Packet TX
+	/* Check continuous TX and Packet TX */
 	tmpReg = rtw_read8(pAdapter, 0xd03);
 
-	if ((tmpReg&0x70) != 0)			//Deal with contisuous TX case
-		rtw_write8(pAdapter, 0xd03, tmpReg&0x8F);	//disable all continuous TX
-	else							// Deal with Packet TX case
-		rtw_write8(pAdapter, REG_TXPAUSE, 0xFF);			// block all queues
+	if ((tmpReg&0x70) != 0)			/* Deal with contisuous TX case */
+		rtw_write8(pAdapter, 0xd03, tmpReg&0x8F);	/* disable all continuous TX */
+	else							/*  Deal with Packet TX case */
+		rtw_write8(pAdapter, REG_TXPAUSE, 0xFF);			/*  block all queues */
 
 	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xF00000, 0x0F);
 
 	for (index = 0; index <path; index ++)
 	{
-		//RTPRINT(FINIT, INIT_IQK,("PHY_LCK enter for loop for index %d\n", index));
 
-		//1. Read original RF mode
+		/* 1. Read original RF mode */
 		offset = index == 0?rOFDM0_XAAGCCore1:rOFDM0_XBAGCCore1;
 		RF_mode[index] = rtw_read8(pAdapter, offset);
-		//RTPRINT(FINIT, INIT_IQK,("PHY_LCK offset 0x%x tmpreg = 0x%x\n", offset, RF_mode[index]));
 
-		//2. Set RF mode = standby mode
+		/* 2. Set RF mode = standby mode */
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_AC, bRFRegOffsetMask, 0x010000);
 #if (TESTFLAG == 0)
 		tmpu4Byte[index] = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask);
@@ -5501,13 +5096,12 @@ phy_LCCalibrate92DSW(
 
 		if (pAdapter->hw_init_completed)
 		{
-			// switch CV-curve control by LC-calibration
+			/*  switch CV-curve control by LC-calibration */
 			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G7, BIT17, 0x0);
 
-			//4. Set LC calibration begin
+			/* 4. Set LC calibration begin */
 			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_CHNLBW, 0x08000, 0x01);
 
-			//RTPRINT(FINIT, INIT_IQK,("PHY_LCK finish HWLCK\n"));
 		}
 	}
 
@@ -5526,17 +5120,16 @@ phy_LCCalibrate92DSW(
 			timecount += 50;
 			u4tmp = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G6, bRFRegOffsetMask);
 		}
-		//RTPRINT(FINIT, INIT_IQK,("PHY_LCK finish delay for %d ms=2\n", timecount));
 	}
-	//Disable TX only need during phy lck, To reduce LCK affect on chariot,
-	// move enable tx here after PHY LCK finish, it will not affect sw lck result.
-	// zhiyuan 2011/06/03
+	/* Disable TX only need during phy lck, To reduce LCK affect on chariot, */
+	/*  move enable tx here after PHY LCK finish, it will not affect sw lck result. */
+	/*  zhiyuan 2011/06/03 */
 	if ((tmpReg&0x70) != 0)
 	{
-		//Path-A
+		/* Path-A */
 		rtw_write8(pAdapter, 0xd03, tmpReg);
 	}
-	else // Deal with Packet TX case
+	else /*  Deal with Packet TX case */
 	{
 		rtw_write8(pAdapter, REG_TXPAUSE, 0x00);
 	}
@@ -5548,21 +5141,12 @@ phy_LCCalibrate92DSW(
 
 		{
 
-			//if (index == 0 && pHalData->interfaceIndex == 0)
-			//{
-			//	RTPRINT(FINIT, INIT_IQK,("cosa, path-A / 5G LCK\n"));
-			//}
-			//else
-			//{
-			//	RTPRINT(FINIT, INIT_IQK,("cosa, path-B / 2.4G LCK\n"));
-			//}
 			memset(&curveCountVal[0], 0, CV_CURVE_CNT*2);
 
-			//Set LC calibration off
+			/* Set LC calibration off */
 			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_CHNLBW, 0x08000, 0x0);
-			//RTPRINT(FINIT, INIT_IQK,("cosa, set RF 0x18[15] = 0\n"));
 
-			//save Curve-counting number
+			/* save Curve-counting number */
 			for (i=0; i<CV_CURVE_CNT; i++)
 			{
 				u32	readVal=0, readVal2=0;
@@ -5572,8 +5156,8 @@ phy_LCCalibrate92DSW(
 				readVal = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, 0x4F, bRFRegOffsetMask);
 
 				curveCountVal[2*i+1] = (readVal & 0xfffe0) >> 5;
-				// reg 0x4f [4:0]
-				// reg 0x50 [19:10]
+				/*  reg 0x4f [4:0] */
+				/*  reg 0x50 [19:10] */
 				readVal2 = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, 0x50, 0xffc00);
 				curveCountVal[2*i] = (((readVal & 0x1F) << 10) | readVal2);
 
@@ -5584,20 +5168,19 @@ phy_LCCalibrate92DSW(
 			else
 				phy_CalcCurvIndex(pAdapter, TargetChnl_2G, curveCountVal, false, CurveIndex);
 
-			// switch CV-curve control mode
+			/*  switch CV-curve control mode */
 			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G7, BIT17, 0x1);
 		}
 
 	}
 
-	//Restore original situation
+	/* Restore original situation */
 	for (index = 0; index <path; index ++)
 	{
 #if (TESTFLAG == 0)
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask, tmpu4Byte[index]);
 #endif
 		offset = index == 0?rOFDM0_XAAGCCore1:rOFDM0_XBAGCCore1;
-		//RTPRINT(FINIT, INIT_IQK,("offset 0x%x tmpreg = 0x%x index %d\n", offset, RF_mode[index], index));
 		rtw_write8(pAdapter, offset, 0x50);
 		rtw_write8(pAdapter, offset, RF_mode[index]);
 	}
@@ -5613,7 +5196,6 @@ phy_LCCalibrate(
 	)
 {
 #if SWLCK == 1
-	//DBG_8192D("cosa PHY_LCK ver=2\n");
 	phy_LCCalibrate92DSW(pAdapter, is2T);
 #else
 	phy_LCCalibrate92D(pAdapter, is2T);
@@ -5621,7 +5203,7 @@ phy_LCCalibrate(
 }
 
 
-//Analog Pre-distortion calibration
+/* Analog Pre-distortion calibration */
 #define		APK_BB_REG_NUM	8
 #define		APK_CURVE_REG_NUM 4
 #define		PATH_NUM		2
@@ -5673,7 +5255,7 @@ phy_APCalibrate(
 					};
 
 	u32			APK_normal_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
-					{0x0852c, 0x0a52c, 0x3a52c, 0x5a52c, 0x5a52c},	//path settings equal to path b settings
+					{0x0852c, 0x0a52c, 0x3a52c, 0x5a52c, 0x5a52c},	/* path settings equal to path b settings */
 					{0x0852c, 0x0a52c, 0x5a52c, 0x5a52c, 0x5a52c}
 					};
 
@@ -5683,11 +5265,11 @@ phy_APCalibrate(
 					};
 
 	u32			APK_normal_RF_value_0[PATH_NUM][APK_BB_REG_NUM] = {
-					{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a},	//path settings equal to path b settings
+					{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a},	/* path settings equal to path b settings */
 					{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a}
 					};
 	u32			AFE_on_off[PATH_NUM] = {
-					0x04db25a4, 0x0b1b25a4};	//path A on path B off / path A off path B on
+					0x04db25a4, 0x0b1b25a4};	/* path A on path B off / path A off path B on */
 
 	u32			APK_offset[PATH_NUM] = {
 					rConfig_AntA, rConfig_AntB};
@@ -5722,8 +5304,7 @@ phy_APCalibrate(
 					0x00050006
 					};
 
-	u32			APK_result[PATH_NUM][APK_BB_REG_NUM];	//val_1_1a, val_1_2a, val_2a, val_3a, val_4a
-	//u32			AP_curve[PATH_NUM][APK_CURVE_REG_NUM];
+	u32			APK_result[PATH_NUM][APK_BB_REG_NUM];	/* val_1_1a, val_1_2a, val_2a, val_3a, val_4a */
 
 	int			BB_offset, delta_V, delta_offset;
 
@@ -5734,23 +5315,20 @@ phy_APCalibrate(
 	pMptCtx->APK_bound[1] = 52;
 #endif
 
-	//RTPRINT(FINIT, INIT_IQK, ("==>PHY_APCalibrate() delta %d\n", delta));
-	//RTPRINT(FINIT, INIT_IQK, ("AP Calibration for %s\n", (is2T ? "2T2R" : "1T1R")));
-
 	if (!is2T)
 		pathbound = 1;
 
-	//2 FOR NORMAL CHIP SETTINGS
+	/* 2 FOR NORMAL CHIP SETTINGS */
 
-// Temporarily do not allow normal driver to do the following settings because these offset
-// and value will cause RF internal PA to be unpredictably disabled by HW, such that RF Tx signal
-// will disappear after disable/enable card many times on 88CU. RF SD and DD have not find the
-// root cause, so we remove these actions temporarily. Added by tynli and SD3 Allen. 2010.05.31.
+/*  Temporarily do not allow normal driver to do the following settings because these offset */
+/*  and value will cause RF internal PA to be unpredictably disabled by HW, such that RF Tx signal */
+/*  will disappear after disable/enable card many times on 88CU. RF SD and DD have not find the */
+/*  root cause, so we remove these actions temporarily. Added by tynli and SD3 Allen. 2010.05.31. */
 #if MP_DRIVER != 1
 	return;
 #endif
 
-	//settings adjust for normal chip
+	/* settings adjust for normal chip */
 	for (index = 0; index < PATH_NUM; index ++)
 	{
 		APK_offset[index] = APK_normal_offset[index];
@@ -5770,18 +5348,18 @@ phy_APCalibrate(
 
 	apkbound = 6;
 
-	//save BB default value
+	/* save BB default value */
 	for (index = 0; index < APK_BB_REG_NUM ; index++)
 	{
-		if (index == 0)		//skip
+		if (index == 0)		/* skip */
 			continue;
 		BB_backup[index] = PHY_QueryBBReg(pAdapter, BB_REG[index], bMaskDWord);
 	}
 
-	//save MAC default value
+	/* save MAC default value */
 	phy_SaveMACRegisters(pAdapter, MAC_REG, MAC_backup);
 
-	//save AFE default value
+	/* save AFE default value */
 	phy_SaveADDARegisters(pAdapter, AFE_REG, AFE_backup, IQK_ADDA_REG_NUM);
 
 	for (path = 0; path < pathbound; path++)
@@ -5790,14 +5368,13 @@ phy_APCalibrate(
 
 		if (path == RF_PATH_A)
 		{
-			//path A APK
-			//load APK setting
-			//path-A
+			/* path A APK */
+			/* load APK setting */
+			/* path-A */
 			offset = rPdp_AntA;
 			for (index = 0; index < 11; index ++)
 			{
 				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord)));
 
 				offset += 0x04;
 			}
@@ -5808,20 +5385,18 @@ phy_APCalibrate(
 			for (; index < 13; index ++)
 			{
 				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord)));
 
 				offset += 0x04;
 			}
 
-			//page-B1
+			/* page-B1 */
 			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x40000000);
 
-			//path A
+			/* path A */
 			offset = rPdp_AntA;
 			for (index = 0; index < 16; index++)
 			{
 				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord)));
 
 				offset += 0x04;
 			}
@@ -5829,14 +5404,13 @@ phy_APCalibrate(
 		}
 		else if (path == RF_PATH_B)
 		{
-			//path B APK
-			//load APK setting
-			//path-B
+			/* path B APK */
+			/* load APK setting */
+			/* path-B */
 			offset = rPdp_AntB;
 			for (index = 0; index < 10; index ++)
 			{
 				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord)));
 
 				offset += 0x04;
 			}
@@ -5846,44 +5420,41 @@ phy_APCalibrate(
 
 			offset = rConfig_AntA;
 			index = 11;
-			for (; index < 13; index ++) //offset 0xb68, 0xb6c
+			for (; index < 13; index ++) /* offset 0xb68, 0xb6c */
 			{
 				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord)));
 
 				offset += 0x04;
 			}
 
-			//page-B1
+			/* page-B1 */
 			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x40000000);
 
-			//path B
+			/* path B */
 			offset = 0xb60;
 			for (index = 0; index < 16; index++)
 			{
 				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord)));
 
 				offset += 0x04;
 			}
 			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
 		}
 
-		//save RF default value
+		/* save RF default value */
 		regD[path] = PHY_QueryRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask);
 
-		//Path A AFE all on, path B AFE All off or vise versa
+		/* Path A AFE all on, path B AFE All off or vise versa */
 		for (index = 0; index < IQK_ADDA_REG_NUM ; index++)
 			PHY_SetBBReg(pAdapter, AFE_REG[index], bMaskDWord, AFE_on_off[path]);
-		//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0xe70 %x\n", PHY_QueryBBReg(pAdapter, rRx_Wait_CCA, bMaskDWord)));
 
-		//BB to AP mode
+		/* BB to AP mode */
 		if (path == 0)
 		{
 			for (index = 0; index < APK_BB_REG_NUM ; index++)
 			{
 
-				if (index == 0)		//skip
+				if (index == 0)		/* skip */
 					continue;
 				else if (index < 5)
 				PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_AP_MODE[index]);
@@ -5896,23 +5467,22 @@ phy_APCalibrate(
 			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);
 			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);
 		}
-		else		//path B
+		else		/* path B */
 		{
 			PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x01008c00);
 			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x01008c00);
 
 		}
 
-		//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x800 %x\n", PHY_QueryBBReg(pAdapter, 0x800, bMaskDWord)));
 
-		//MAC settings
+		/* MAC settings */
 		phy_MACSettingCalibration(pAdapter, MAC_REG, MAC_backup);
 
-		if (path == RF_PATH_A)	//Path B to standby mode
+		if (path == RF_PATH_A)	/* Path B to standby mode */
 		{
 			PHY_SetRFReg(pAdapter, RF_PATH_B, RF_AC, bRFRegOffsetMask, 0x10000);
 		}
-		else			//Path A to standby mode
+		else			/* Path A to standby mode */
 		{
 			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x10000);
 			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);
@@ -5925,16 +5495,16 @@ phy_APCalibrate(
 		else if (delta_offset > 12)
 			delta_offset = 12;
 
-		//AP calibration
+		/* AP calibration */
 		for (index = 0; index < APK_BB_REG_NUM; index++) {
-			if (index != 1)	//only DO PA11+PAD01001, AP RF setting
+			if (index != 1)	/* only DO PA11+PAD01001, AP RF setting */
 				continue;
 
 			tmpReg = APK_RF_init_value[path][index];
 			if (!pdmpriv->bAPKThermalMeterIgnore) {
 				BB_offset = (tmpReg & 0xF0000) >> 16;
 
-				if (!(tmpReg & BIT15)) //sign bit 0
+				if (!(tmpReg & BIT15)) /* sign bit 0 */
 					BB_offset = -BB_offset;
 
 				delta_V = APK_delta_mapping[index][delta_offset];
@@ -5955,7 +5525,7 @@ phy_APCalibrate(
 			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_AC, bRFRegOffsetMask, APK_RF_value_0[path][index]);
 			PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask, tmpReg);
 
-			// PA11+PAD01111, one shot
+			/*  PA11+PAD01111, one shot */
 			i = 0;
 			do {
 				PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80000000);
@@ -5970,7 +5540,6 @@ phy_APCalibrate(
 				tmpReg = PHY_QueryBBReg(pAdapter, rAPK, 0x03E00000);
 				else
 					tmpReg = PHY_QueryBBReg(pAdapter, rAPK, 0xF8000000);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0xbd8[25:21] %x\n", tmpReg));
 
 
 				i++;
@@ -5981,22 +5550,22 @@ phy_APCalibrate(
 		}
 	}
 
-	//reload MAC default value
+	/* reload MAC default value */
 	phy_ReloadMACRegisters(pAdapter, MAC_REG, MAC_backup);
 
-	//reload BB default value
+	/* reload BB default value */
 	for (index = 0; index < APK_BB_REG_NUM ; index++)
 	{
 
-		if (index == 0)		//skip
+		if (index == 0)		/* skip */
 			continue;
 		PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_backup[index]);
 	}
 
-	//reload AFE default value
+	/* reload AFE default value */
 	phy_ReloadADDARegisters(pAdapter, AFE_REG, AFE_backup, IQK_ADDA_REG_NUM);
 
-	//reload RF path default value
+	/* reload RF path default value */
 	for (path = 0; path < pathbound; path++)
 	{
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask, regD[path]);
@@ -6006,13 +5575,11 @@ phy_APCalibrate(
 			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20101);
 		}
 
-		//note no index == 0
+		/* note no index == 0 */
 		if (APK_result[path][1] > 6)
 			APK_result[path][1] = 6;
-		//RTPRINT(FINIT, INIT_IQK, ("apk path %d result %d 0x%x \t", path, 1, APK_result[path][1]));
 	}
 
-	//RTPRINT(FINIT, INIT_IQK, ("\n"));
 
 	for (path = 0; path < pathbound; path++)
 	{
@@ -6025,14 +5592,10 @@ phy_APCalibrate(
 		PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask,
 			((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x02 << 5) | 0x05));
 
-		//if (!IS_HARDWARE_TYPE_8723A(pAdapter))
-		//	PHY_SetRFReg(pAdapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G9_G11, bRFRegOffsetMask,
-		//	((0x08 << 15) | (0x08 << 10) | (0x08 << 5) | 0x08));
 	}
 
 	pdmpriv->bAPKdone = true;
 
-	//RTPRINT(FINIT, INIT_IQK, ("<==PHY_APCalibrate()\n"));
 }
 
 static void phy_SetRFPathSwitch(
@@ -6053,7 +5616,6 @@ static void phy_SetRFPathSwitch(
 	else
 		PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x1);
 
-	//RT_TRACE(COMP_OID_SET, DBG_LOUD, ("_PHY_SetRFPathSwitch 0x4C %lx, 0x878 %lx, 0x860 %lx\n", PHY_QueryBBReg(pAdapter, 0x4C, BIT23), PHY_QueryBBReg(pAdapter, 0x878, BIT13), PHY_QueryBBReg(pAdapter, 0x860, 0x300)));
 }
 
 void
@@ -6063,15 +5625,13 @@ rtl8192d_PHY_IQCalibrate(
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(pAdapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	int			result[4][8];	//last is final result
+	int			result[4][8];	/* last is final result */
 	u8			i, final_candidate, Indexforchannel;
 	bool		bPathAOK, bPathBOK;
 	int			RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC, RegTmp = 0;
 	bool		is12simular, is13simular, is23simular;
 	bool		bStartContTx = false, bSingleTone = false, bCarrierSuppression = false;
 
-	//if (ODM_CheckPowerStatus(pAdapter) == false)
-	//	return;
 
 #if (MP_DRIVER == 1)
 	bStartContTx = pAdapter->mppriv.MptCtx.bStartContTx;
@@ -6079,7 +5639,7 @@ rtl8192d_PHY_IQCalibrate(
 	bCarrierSuppression = pAdapter->mppriv.MptCtx.bCarrierSuppression;
 #endif
 
-	//ignore IQK when continuous Tx
+	/* ignore IQK when continuous Tx */
 	if (bStartContTx || bSingleTone || bCarrierSuppression)
 		return;
 
@@ -6092,7 +5652,6 @@ rtl8192d_PHY_IQCalibrate(
 		return;
 #endif
 
-	//RTPRINT(FINIT, INIT_IQK, ("IQK:Start!!!interface %d channel %d\n", pHalData->interfaceIndex, pHalData->CurrentChannel));
 
 	for (i = 0; i < 8; i++)
 	{
@@ -6108,9 +5667,6 @@ rtl8192d_PHY_IQCalibrate(
 	is23simular = false;
 	is13simular = false;
 
-	//RTPRINT(FINIT, INIT_IQK, ("IQK !!!interface %d currentband %d ishardwareD %d\n", pAdapter->interfaceIndex, pHalData->CurrentBandType92D, IS_HARDWARE_TYPE_8192D(pAdapter)));
-	//AcquireCCKAndRWPageAControl(pAdapter);
-	//RT_TRACE(COMP_INIT,DBG_LOUD,("Acquire Mutex in IQCalibrate\n"));
 	for (i=0; i<3; i++)
 	{
 		if (pHalData->CurrentBandType92D == BAND_ON_5G)
@@ -6159,8 +5715,6 @@ rtl8192d_PHY_IQCalibrate(
 			}
 		}
 	}
-	//RT_TRACE(COMP_INIT,DBG_LOUD,("Release Mutex in IQCalibrate\n"));
-	//ReleaseCCKAndRWPageAControl(pAdapter);
 
         for (i=0; i<4; i++)
 	{
@@ -6172,7 +5726,6 @@ rtl8192d_PHY_IQCalibrate(
 		RegEBC = result[i][5];
 		RegEC4 = result[i][6];
 		RegECC = result[i][7];
-		//RTPRINT(FINIT, INIT_IQK, ("IQK: RegE94=%lx RegE9C=%lx RegEA4=%lx RegEAC=%lx RegEB4=%lx RegEBC=%lx RegEC4=%lx RegECC=%lx\n ", RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC));
 	}
 
 	if (final_candidate != 0xff)
@@ -6191,8 +5744,8 @@ rtl8192d_PHY_IQCalibrate(
 	}
 	else
 	{
-		pdmpriv->RegE94 = pdmpriv->RegEB4 = 0x100;	//X default value
-		pdmpriv->RegE9C = pdmpriv->RegEBC = 0x0;		//Y default value
+		pdmpriv->RegE94 = pdmpriv->RegEB4 = 0x100;	/* X default value */
+		pdmpriv->RegE9C = pdmpriv->RegEBC = 0x0;		/* Y default value */
 	}
 
 	if ((RegE94 != 0)/*&&(RegEA4 != 0)*/)
@@ -6226,7 +5779,6 @@ rtl8192d_PHY_IQCalibrate(
 
 		pHalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone = true;
 
-		//RT_TRACE(COMP_SCAN|COMP_MLME,DBG_LOUD,("\nIQK OK Indexforchannel %d.\n", Indexforchannel));
 #ifdef CONFIG_CONCURRENT_MODE
 		if (rtw_buddy_adapter_up(pAdapter)) {
 			struct rtw_adapter * pbuddy_adapter = pAdapter->pbuddy_adapter;
@@ -6269,7 +5821,7 @@ rtl8192d_PHY_LCCalibrate(
 	return;
 #endif
 
-	//ignore IQK when continuous Tx
+	/* ignore IQK when continuous Tx */
 	if (bStartContTx || bSingleTone || bCarrierSuppression)
 		return;
 
@@ -6292,20 +5844,18 @@ rtl8192d_PHY_LCCalibrate(
 
 	pHalData->bLCKInProgress = true;
 
-	//DBG_8192D("LCK:Start!!!interface %d currentband %x delay %d ms\n", pHalData->interfaceIndex, pHalData->CurrentBandType92D, timecount);
 
 	if (IS_92D_SINGLEPHY(pHalData->VersionID))
 	{
 		phy_LCCalibrate(pAdapter, true);
 	}
 	else {
-		// For 88C 1T1R
+		/*  For 88C 1T1R */
 		phy_LCCalibrate(pAdapter, false);
 	}
 
 	pHalData->bLCKInProgress = false;
 
-	//RTPRINT(FINIT, INIT_IQK, ("LCK:Finish!!!interface %d\n", pHalData->interfaceIndex));
 }
 
 void
@@ -6321,7 +5871,6 @@ rtl8192d_PHY_APCalibrate(
 	return;
 #endif
 
-	//if (IS_HARDWARE_TYPE_8192D(pAdapter))
 		return;
 
 	if (pdmpriv->bAPKdone)
@@ -6331,7 +5880,7 @@ rtl8192d_PHY_APCalibrate(
 		phy_APCalibrate(pAdapter, delta, true);
 	}
 	else {
-		// For 88C 1T1R
+		/*  For 88C 1T1R */
 		phy_APCalibrate(pAdapter, delta, false);
 	}
 }
@@ -6348,11 +5897,11 @@ PHY_UpdateBBRFConfiguration8192D(
 	bool			bInternalPA;
 	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
 
-	//Update BB
-	//r_select_5G for path_A/B.0 for 2.4G,1 for 5G
+	/* Update BB */
+	/* r_select_5G for path_A/B.0 for 2.4G,1 for 5G */
 	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
-	{// 2.4G band
-		//r_select_5G for path_A/B,0x878
+	{/*  2.4G band */
+		/* r_select_5G for path_A/B,0x878 */
 
 		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT0, 0x0);
 		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT15, 0x0);
@@ -6362,15 +5911,15 @@ PHY_UpdateBBRFConfiguration8192D(
 			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT31, 0x0);
 		}
 
-		//rssi_table_select:index 0 for 2.4G.1~3 for 5G,0xc78
+		/* rssi_table_select:index 0 for 2.4G.1~3 for 5G,0xc78 */
 		PHY_SetBBReg(Adapter, rOFDM0_AGCRSSITable, BIT6|BIT7, 0x0);
 
-		//fc_area//0xd2c
+		/* fc_area 0xd2c */
 		PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT14|BIT13, 0x0);
-		// 5G LAN ON
+		/*  5G LAN ON */
 		PHY_SetBBReg(Adapter, 0xB30, 0x00F00000, 0xa);
 
-		//TX BB gain shift*1,Just for testchip,0xc80,0xc88
+		/* TX BB gain shift*1,Just for testchip,0xc80,0xc88 */
 		PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
 		PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x40000100);
 
@@ -6415,11 +5964,10 @@ PHY_UpdateBBRFConfiguration8192D(
 		pdmpriv->CCK_index = 0x0c;
 
 	}
-	else	//5G band
+	else	/* 5G band */
 	{
-		//DBG_8192D("==>PHY_UpdateBBRFConfiguration8192D() interface %d BAND_ON_5G settings\n", pHalData->interfaceIndex);
 
-		//r_select_5G for path_A/B
+		/* r_select_5G for path_A/B */
 		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT0, 0x1);
 		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT15, 0x1);
 		if (pHalData->MacPhyMode92D != DUALMAC_DUALPHY)
@@ -6428,15 +5976,15 @@ PHY_UpdateBBRFConfiguration8192D(
 			PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT31, 0x1);
 		}
 
-		//rssi_table_select:index 0 for 2.4G.1~3 for 5G
+		/* rssi_table_select:index 0 for 2.4G.1~3 for 5G */
 		PHY_SetBBReg(Adapter, rOFDM0_AGCRSSITable, BIT6|BIT7, 0x1);
 
-		//fc_area
+		/* fc_area */
 		PHY_SetBBReg(Adapter, rOFDM1_CFOTracking, BIT14|BIT13, 0x1);
-		// 5G LAN ON
+		/*  5G LAN ON */
 		PHY_SetBBReg(Adapter, 0xB30, 0x00F00000, 0x0);
 
-		//TX BB gain shift,Just for testchip,0xc80,0xc88
+		/* TX BB gain shift,Just for testchip,0xc80,0xc88 */
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
 		{
 			if (pHalData->interfaceIndex == 0)
@@ -6480,7 +6028,6 @@ PHY_UpdateBBRFConfiguration8192D(
 			}
 		}
 
-		//DBG_8192D("==>PHY_UpdateBBRFConfiguration8192D() interface %d BAND_ON_5G settings OFDM index 0x%x\n", pHalData->interfaceIndex, pdmpriv->OFDM_index[RF_PATH_A]);
 		PHY_SetBBReg(Adapter, 0xB30, BIT27, 0x0);
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
 		{
@@ -6520,7 +6067,7 @@ PHY_UpdateBBRFConfiguration8192D(
 
 	}
 
-	//update IQK related settings
+	/* update IQK related settings */
 	{
 		PHY_SetBBReg(Adapter, rOFDM0_XARxIQImbalance, bMaskDWord, 0x40000100);
 		PHY_SetBBReg(Adapter, rOFDM0_XBRxIQImbalance, bMaskDWord, 0x40000100);
@@ -6531,46 +6078,46 @@ PHY_UpdateBBRFConfiguration8192D(
 		PHY_SetBBReg(Adapter, rOFDM0_AGCRSSITable, 0x0000F000, 0x00);
 	}
 
-	//Update RF
+	/* Update RF */
 	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 	{
 		if (pHalData->CurrentBandType92D == BAND_ON_2_4G) {
-			//MOD_AG for RF paht_A 0x18 BIT8,BIT16
+			/* MOD_AG for RF paht_A 0x18 BIT8,BIT16 */
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT8|BIT16|BIT18|0xFF, 1);
 
-			//RF0x0b[16:14] =3b'111
+			/* RF0x0b[16:14] =3b'111 */
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_TXPA_AG, 0x1c000, 0x07);
 		}
-		else { //5G band
-			//MOD_AG for RF paht_A 0x18 BIT8,BIT16
-			PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x97524); //set channel 36
+		else { /* 5G band */
+			/* MOD_AG for RF paht_A 0x18 BIT8,BIT16 */
+			PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x97524); /* set channel 36 */
 
 		}
 
 		if ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G) ||
 		    (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)) {
-			//Set right channel on RF reg0x18 for another mac.
-			if (pHalData->interfaceIndex == 0) //set MAC1 default channel if MAC1 not up.
+			/* Set right channel on RF reg0x18 for another mac. */
+			if (pHalData->interfaceIndex == 0) /* set MAC1 default channel if MAC1 not up. */
 			{
 				if (!(rtw_read8(Adapter, REG_MAC1)&MAC1_ON)) {
 					rtl8192d_PHY_EnableAnotherPHY(Adapter, true);
-					PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW|MAC0_ACCESS_PHY1, bRFRegOffsetMask, 0x97524); //set channel 36
+					PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW|MAC0_ACCESS_PHY1, bRFRegOffsetMask, 0x97524); /* set channel 36 */
 					rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
 				}
-			} else if (pHalData->interfaceIndex == 1) { //set MAC0 default channel
+			} else if (pHalData->interfaceIndex == 1) { /* set MAC0 default channel */
 				if (!(rtw_read8(Adapter, REG_MAC0)&MAC0_ON)) {
 					rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
-					PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW|MAC1_ACCESS_PHY0, bRFRegOffsetMask, 0x87401); // set channel 1
+					PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW|MAC1_ACCESS_PHY0, bRFRegOffsetMask, 0x87401); /*  set channel 1 */
 					rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
 				}
 			}
 		}
 	}
 
-	//Update for all band.
+	/* Update for all band. */
 	if (pHalData->rf_type == RF_1T1R)
-	{ //DMDP
-		//Use antenna 0,0xc04,0xd04
+	{ /* DMDP */
+		/* Use antenna 0,0xc04,0xd04 */
 #if MP_DRIVER == 1
 		if (!bisBandSwitch)
 #endif
@@ -6579,17 +6126,15 @@ PHY_UpdateBBRFConfiguration8192D(
 		PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, 0x1);
 		}
 
-		//enable ad/da clock1 for dual-phy reg0x888
+		/* enable ad/da clock1 for dual-phy reg0x888 */
 		if (pHalData->interfaceIndex == 0)
 			PHY_SetBBReg(Adapter, rFPGA0_AdDaClockEn, BIT12|BIT13, 0x3);
 		else
 		{
 			bool bMAC0NotUp =false;
 
-			//3 Path Div
-			// Neil Chen---2011--05--31---Begin
-			//PHY_SetBBReg(Adapter, rFPGA0_AdDaClockEn, BIT12|BIT13, 0x3);
-			//--------------------------------------end
+			/* 3 Path Div */
+			/*  Neil Chen---2011--05--31---Begin */
 
 			bMAC0NotUp = rtl8192d_PHY_EnableAnotherPHY(Adapter, false);
 			if (bMAC0NotUp)
@@ -6599,34 +6144,34 @@ PHY_UpdateBBRFConfiguration8192D(
 			}
 		}
 
-		//supported mcs
+		/* supported mcs */
 		PHY_SetBBReg(Adapter, rOFDM1_LSTF, BIT19|BIT20, 0x0);
 	}
-	else // 2T2R //Single PHY
+	else /*  2T2R Single PHY */
 	{
 		if (pregistrypriv->special_rf_path == 2)
 		{
 			PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x22);
 			PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, 0x2);
-			PHY_SetBBReg(Adapter, rFPGA1_TxInfo, bMaskDWord, 0x82221322);	//OFDM Tx
+			PHY_SetBBReg(Adapter, rFPGA1_TxInfo, bMaskDWord, 0x82221322);	/* OFDM Tx */
 		}
 		else if (pregistrypriv->special_rf_path == 1)
 		{
 			PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x11);
 			PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, 0x1);
-			PHY_SetBBReg(Adapter, rFPGA1_TxInfo, bMaskDWord, 0x81121311);	//OFDM Tx
+			PHY_SetBBReg(Adapter, rFPGA1_TxInfo, bMaskDWord, 0x81121311);	/* OFDM Tx */
 		}
 		else
 		{
-			//Use antenna 0 & 1,0xc04,0xd04
+			/* Use antenna 0 & 1,0xc04,0xd04 */
 			PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x33);
 			PHY_SetBBReg(Adapter, rOFDM1_TRxPathEnable, bDWord, 0x3);
 		}
 
-		//disable ad/da clock1,0x888
+		/* disable ad/da clock1,0x888 */
 		PHY_SetBBReg(Adapter, rFPGA0_AdDaClockEn, BIT12|BIT13, 0);
 
-		//supported mcs
+		/* supported mcs */
 		PHY_SetBBReg(Adapter, rOFDM1_LSTF, BIT19|BIT20, 0x1);
 	}
 
@@ -6644,23 +6189,20 @@ PHY_UpdateBBRFConfiguration8192D(
 		pdmpriv->RegRF3C[eRFPath] = PHY_QueryRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_RXRF_A3, bRFRegOffsetMask);
 	}
 
-	//for (i = 0; i < 2; i++)
-	//	DBG_8192D("PHY_UpdateBBRFConfiguration8192D RF 0x18 = 0x%x interface index %d\n",pHalData->RfRegChnlVal[i],	pHalData->interfaceIndex);
 
-	//RT_TRACE(COMP_INIT,DBG_LOUD,("<==PHY_UpdateBBRFConfiguration8192D()\n"));
 }
 
-//
-//	Description:
-//		Read HW adapter information through EEPROM 93C46.
-//		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type.
-//		MacPhyMode:DMDP,SMSP.
-//		BandType:2.4G,5G.
-//
-//	Assumption:
-//		1. Boot from EEPROM and CR9346 regiser has verified.
-//		2. PASSIVE_LEVEL (USB interface)
-//
+/*  */
+/* 	Description: */
+/* 		Read HW adapter information through EEPROM 93C46. */
+/* 		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type. */
+/* 		MacPhyMode:DMDP,SMSP. */
+/* 		BandType:2.4G,5G. */
+/*  */
+/* 	Assumption: */
+/* 		1. Boot from EEPROM and CR9346 regiser has verified. */
+/* 		2. PASSIVE_LEVEL (USB interface) */
+/*  */
 void PHY_ReadMacPhyMode92D(
 		struct rtw_adapter *			Adapter,
 		bool		AutoloadFail
@@ -6693,17 +6235,17 @@ void PHY_ReadMacPhyMode92D(
 	}
 }
 
-//
-//	Description:
-//		Read HW adapter information through EEPROM 93C46.
-//		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type.
-//		MacPhyMode:DMDP,SMSP.
-//		BandType:2.4G,5G.
-//
-//	Assumption:
-//		1. Boot from EEPROM and CR9346 regiser has verified.
-//		2. PASSIVE_LEVEL (USB interface)
-//
+/*  */
+/* 	Description: */
+/* 		Read HW adapter information through EEPROM 93C46. */
+/* 		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type. */
+/* 		MacPhyMode:DMDP,SMSP. */
+/* 		BandType:2.4G,5G. */
+/*  */
+/* 	Assumption: */
+/* 		1. Boot from EEPROM and CR9346 regiser has verified. */
+/* 		2. PASSIVE_LEVEL (USB interface) */
+/*  */
 void PHY_ConfigMacPhyMode92D(
 		struct rtw_adapter *			Adapter
 )
@@ -6717,32 +6259,29 @@ void PHY_ConfigMacPhyMode92D(
 		case DUALMAC_DUALPHY:
 			MSG_8192D("MacPhyMode: DUALMAC_DUALPHY\n");
 			rtw_write8(Adapter, offset, temp | BIT(0)|BIT(1));
-			//rtw_write8(Adapter, offset, 0xF3);
 			break;
 		case SINGLEMAC_SINGLEPHY:
 			MSG_8192D("MacPhyMode: SINGLEMAC_SINGLEPHY\n");
 			rtw_write8(Adapter, offset, temp | BIT(2));
-			//rtw_write8(Adapter, offset, 0xF4);
 			break;
 		case DUALMAC_SINGLEPHY:
 			MSG_8192D("MacPhyMode: DUALMAC_SINGLEPHY\n");
 			rtw_write8(Adapter, offset, temp | BIT(0));
-			//rtw_write8(Adapter, offset, 0xF1);
 			break;
 	}
 }
 
-//
-//	Description:
-//		Read HW adapter information through EEPROM 93C46.
-//		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type.
-//		MacPhyMode:DMDP,SMSP.
-//		BandType:2.4G,5G.
-//
-//	Assumption:
-//		1. Boot from EEPROM and CR9346 regiser has verified.
-//		2. PASSIVE_LEVEL (USB interface)
-//
+/*  */
+/* 	Description: */
+/* 		Read HW adapter information through EEPROM 93C46. */
+/* 		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type. */
+/* 		MacPhyMode:DMDP,SMSP. */
+/* 		BandType:2.4G,5G. */
+/*  */
+/* 	Assumption: */
+/* 		1. Boot from EEPROM and CR9346 regiser has verified. */
+/* 		2. PASSIVE_LEVEL (USB interface) */
+/*  */
 void PHY_ConfigMacPhyModeInfo92D(struct rtw_adapter *Adapter)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
@@ -6758,7 +6297,7 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 			pHalData->BandSet92D = BAND_ON_BOTH;
 			pHalData->CurrentBandType92D = BAND_ON_2_4G;
 #ifdef CONFIG_DUALMAC_CONCURRENT
-//get bMasetOfDMSP and bSlaveOfDMSP sync with buddy adapter
+/* get bMasetOfDMSP and bSlaveOfDMSP sync with buddy adapter */
 			ACQUIRE_GLOBAL_MUTEX(GlobalCounterForMutex);
 			if (BuddyAdapter != NULL)
 			{
@@ -6798,11 +6337,11 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 			pHalData->VersionID = (enum VERSION_8192D)(pHalData->VersionID & RF_TYPE_1T1R);
 			if (pHalData->interfaceIndex == 1) {
 				pHalData->BandSet92D = BAND_ON_5G;
-				pHalData->CurrentBandType92D = BAND_ON_5G;//Now we let MAC1 run on 5G band.
+				pHalData->CurrentBandType92D = BAND_ON_5G;/* Now we let MAC1 run on 5G band. */
 			}
 			else {
 				pHalData->BandSet92D = BAND_ON_2_4G;
-				pHalData->CurrentBandType92D = BAND_ON_2_4G;//
+				pHalData->CurrentBandType92D = BAND_ON_2_4G;/*  */
 			}
 			pHalData->bMasterOfDMSP = false;
 			pHalData->bSlaveOfDMSP = false;
@@ -6879,14 +6418,14 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 	DBG_8192D("%s(): wireless_mode = %x\n",__func__,Adapter->registrypriv.wireless_mode);
 }
 
-//
-//	Description:
-//	set RX packet buffer and other setting acording to dual mac mode
-//
-//	Assumption:
-//		1. Boot from EEPROM and CR9346 regiser has verified.
-//		2. PASSIVE_LEVEL (USB interface)
-//
+/*  */
+/* 	Description: */
+/* 	set RX packet buffer and other setting acording to dual mac mode */
+/*  */
+/* 	Assumption: */
+/* 		1. Boot from EEPROM and CR9346 regiser has verified. */
+/* 		2. PASSIVE_LEVEL (USB interface) */
+/*  */
 void PHY_ConfigMacCoexist_RFPage92D(
 		struct rtw_adapter *			Adapter
 )
@@ -6970,7 +6509,7 @@ void rtl8192d_PHY_SetRFPathSwitch(struct
 	if (IS_92D_SINGLEPHY(pHalData->VersionID)) {
 		phy_SetRFPathSwitch(pAdapter, main, true);
 	} else {
-		// For 88C 1T1R
+		/*  For 88C 1T1R */
 		phy_SetRFPathSwitch(pAdapter, main, false);
 	}
 #endif
@@ -6982,22 +6521,17 @@ HalChangeCCKStatus8192D(
 	bool		bCCKDisable
 )
 {
-	//struct rtw_adapter *	BuddyAdapter = Adapter->BuddyAdapter;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	u8	i;
 
-	//DBG_8192D("MAC %d: =====> ChangeCCKStatus8192D\n",pHalData->interfaceIndex);
 
 	if (pHalData->BandSet92D != BAND_ON_BOTH)
 	{
-		//DBG_8192D("ChangeCCKStatus8192D():  Skip\n");
 		return;
 	}
 
 	if (bCCKDisable)
 	{
-		//if (ACTING_AS_AP(Adapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, FALSE)) || (Adapter->MgntInfo.mIbss))
-		//	StopTxBeacon(Adapter);
 		rtw_write16(Adapter, REG_RL,0x0101);
 		for (i=0;i<30;i++)
 		{
@@ -7009,7 +6543,6 @@ HalChangeCCKStatus8192D(
 			}
 			else
 			{
-				//DBG_8192D("no packet in tx packet buffer\n");
 				break;
 			}
 		}
@@ -7041,20 +6574,8 @@ HalChangeCCKStatus8192D(
 	else
 	{
 		u8	RetryLimit = 0x30;
-		//if (ACTING_AS_AP(Adapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(Adapter, FALSE)) || Adapter->MgntInfo.mIbss)
-		//	ResumeTxBeacon(Adapter);
 
 		rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
-
-		/*if ((BuddyAdapter != NULL) && (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY))
-		{
-			if (ACTING_AS_AP(BuddyAdapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(BuddyAdapter, FALSE)) || BuddyAdapter->MgntInfo.mIbss)
-				ResumeTxBeacon(BuddyAdapter);
-
-			PlatformEFIOWrite2Byte(BuddyAdapter, REG_RL,
-					pHalData->ShortRetryLimit << RETRY_LIMIT_SHORT_SHIFT | \
-					pHalData->LongRetryLimit << RETRY_LIMIT_LONG_SHIFT);
-		}*/
 	}
 }
 
@@ -7078,7 +6599,7 @@ PHY_InitPABias92D(struct rtw_adapter * A
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F425);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F425);
 
-		//Back to RX Mode
+		/* Back to RX Mode */
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x30000);
 		DBG_8192D("2G PA BIAS path A\n");
 	}
@@ -7092,35 +6613,35 @@ PHY_InitPABias92D(struct rtw_adapter * A
 		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F425);
 		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F425);
 
-		//Back to RX Mode
+		/* Back to RX Mode */
 		PHY_SetRFReg(Adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x30000);
 		DBG_8192D("2G PA BIAS path B\n");
 	}
 
 	if (!(tmpU1b & BIT2) && (is92 || pHalData->interfaceIndex == 0))
 	{
-		//5GL_channel
+		/* 5GL_channel */
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x17524);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F496);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F496);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F496);
 
-		//5GM_channel
+		/* 5GM_channel */
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x37564);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F496);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F496);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F496);
 
-		//5GH_channel
+		/* 5GH_channel */
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x57595);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F496);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F496);
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F496);
 
-		//Back to RX Mode
+		/* Back to RX Mode */
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x30000);
 
 		DBG_8192D("5G PA BIAS path A\n");
@@ -7129,28 +6650,28 @@ PHY_InitPABias92D(struct rtw_adapter * A
 	if (!(tmpU1b & BIT3) && (is92 || pHalData->interfaceIndex == 1))
 	{
 		eRFPath = (pHalData->interfaceIndex == 1)?RF_PATH_A:RF_PATH_B;
-		//5GL_channel
+		/* 5GL_channel */
 		PHY_SetRFReg(Adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x17524);
 		PHY_SetRFReg(Adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
 		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F496);
 		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F496);
 		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F496);
 
-		//5GM_channel
+		/* 5GM_channel */
 		PHY_SetRFReg(Adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x37564);
 		PHY_SetRFReg(Adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
 		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F496);
 		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F496);
 		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F496);
 
-		//5GH_channel
+		/* 5GH_channel */
 		PHY_SetRFReg(Adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x57595);
 		PHY_SetRFReg(Adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
 		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F496);
 		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F496);
 		PHY_SetRFReg(Adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F496);
 
-		//Back to RX Mode
+		/* Back to RX Mode */
 		PHY_SetRFReg(Adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x30000);
 		DBG_8192D("5G PA BIAS path B\n");
 	}
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
@@ -49,17 +49,17 @@
 #include <rtl8192d_hal.h>
 
 /*---------------------------Define Local Constant---------------------------*/
-// Define local structure for debug!!!!!
+/*  Define local structure for debug!!!!! */
 struct rf_shadow_compare_map {
-	// Shadow register value
+	/*  Shadow register value */
 	u32		Value;
-	// Compare or not flag
+	/*  Compare or not flag */
 	u8		Compare;
-	// Record If it had ever modified unpredicted
+	/*  Record If it had ever modified unpredicted */
 	u8		ErrorOrNot;
-	// Recorver Flag
+	/*  Recorver Flag */
 	u8		Recorver;
-	//
+	/*  */
 	u8		Driver_Write;
 };
 /*---------------------------Define Local Constant---------------------------*/
@@ -70,7 +70,7 @@ struct rf_shadow_compare_map {
 
 
 /*------------------------Define local variable------------------------------*/
-// 2008/11/20 MH For Debug only, RF
+/*  2008/11/20 MH For Debug only, RF */
 static	struct rf_shadow_compare_map RF_Shadow[RF6052_MAX_PATH][RF6052_MAX_REG];
 /*------------------------Define local variable------------------------------*/
 
@@ -80,7 +80,7 @@ static	struct rf_shadow_compare_map RF_S
  *
  * Overview:	For RL6052, we must change some RF settign for 1T or 2T.
  *
- * Input:		u2Byte DataRate		// 0x80-8f, 0x90-9f
+ * Input:		u2Byte DataRate		  0x80-8f, 0x90-9f
  *
  * Output:      NONE
  *
@@ -95,7 +95,7 @@ static	struct rf_shadow_compare_map RF_S
 void rtl8192d_RF_ChangeTxPath(	struct rtw_adapter *	Adapter,
 										u16		DataRate)
 {
-// We do not support gain table change inACUT now !!!! Delete later !!!
+/*  We do not support gain table change inACUT now !!!! Delete later !!! */
 }	/* RF_ChangeTxPath */
 
 
@@ -105,7 +105,7 @@ void rtl8192d_RF_ChangeTxPath(	struct rt
  * Overview:    This function is called by SetBWModeCallback8190Pci() only
  *
  * Input:       struct rtw_adapter *				Adapter
- *			WIRELESS_BANDWIDTH_E	Bandwidth	//20M or 40M
+ *			WIRELESS_BANDWIDTH_E	Bandwidth	20M or 40M
  *
  * Output:      NONE
  *
@@ -116,7 +116,7 @@ void rtl8192d_RF_ChangeTxPath(	struct rt
 void
 rtl8192d_PHY_RF6052SetBandwidth(
 	struct rtw_adapter *				Adapter,
-	enum HT_CHANNEL_WIDTH		Bandwidth)	//20M or 40M
+	enum HT_CHANNEL_WIDTH		Bandwidth)	/* 20M or 40M */
 {
 	u8			eRFPath;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
@@ -136,17 +136,13 @@ rtl8192d_PHY_RF6052SetBandwidth(
 			for (eRFPath=0;eRFPath<pHalData->NumTotalRFPath;eRFPath++)
 			{
 				pHalData->RfRegChnlVal[eRFPath] = ((pHalData->RfRegChnlVal[eRFPath] & 0xfffff3ff));
-				//PHY_SetRFReg(Adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, pHalData->RfRegChnlVal[eRFPath]);
 				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT10|BIT11, 0x00);
-				//RT_TRACE(COMP_RF, DBG_LOUD, ("PHY_RF6052SetBandwidth 40M RF 0x18 = 0x%x interface index %d\n",pHalData->RfRegChnlVal[eRFPath],  Adapter->interfaceIndex));
 			}
 			break;
 
 		default:
-			//RT_TRACE(COMP_DBG, DBG_LOUD, ("PHY_SetRF8225Bandwidth(): unknown Bandwidth: %#X\n",Bandwidth));
 			break;
 	}
-	//RT_TRACE(COMP_MLME,DBG_LOUD,("<==== PHY_RF6052SetBandwidth()Bandwidth:%d\n",Bandwidth));
 }
 
 
@@ -187,7 +183,7 @@ rtl8192d_PHY_RF6052SetCckTxPower(
 		TxAGC[RF_PATH_A] = 0x3f3f3f3f;
 		TxAGC[RF_PATH_B] = 0x3f3f3f3f;
 
-		TurboScanOff =  true;//disable Turbo scan
+		TurboScanOff =  true;/* disable Turbo scan */
 
 		if (TurboScanOff)
 		{
@@ -201,10 +197,10 @@ rtl8192d_PHY_RF6052SetCckTxPower(
 	}
 	else
 	{
-//vivi merge from 92c, pass win7 DTM item: performance_ext
-// 20100427 Joseph: Driver dynamic Tx power shall not affect Tx power. It shall be determined by power training mechanism.
-// Currently, we cannot fully disable driver dynamic tx power mechanism because it is referenced by BT coexist mechanism.
-// In the future, two mechanism shall be separated from each other and maintained independantly. Thanks for Lanhsin's reminder.
+/* vivi merge from 92c, pass win7 DTM item: performance_ext */
+/*  20100427 Joseph: Driver dynamic Tx power shall not affect Tx power. It shall be determined by power training mechanism. */
+/*  Currently, we cannot fully disable driver dynamic tx power mechanism because it is referenced by BT coexist mechanism. */
+/*  In the future, two mechanism shall be separated from each other and maintained independantly. Thanks for Lanhsin's reminder. */
 		{
 			for (idx1=RF_PATH_A; idx1<=RF_PATH_B; idx1++)
 			{
@@ -237,28 +233,23 @@ rtl8192d_PHY_RF6052SetCckTxPower(
 		}
 	}
 
-	// rf-A cck tx power
+	/*  rf-A cck tx power */
 	tmpval = TxAGC[RF_PATH_A]&0xff;
 	PHY_SetBBReg(Adapter, rTxAGC_A_CCK1_Mcs32, bMaskByte1, tmpval);
-	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 1M (rf-A) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_A_CCK1_Mcs32));
 	tmpval = TxAGC[RF_PATH_A]>>8;
 	PHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, 0xffffff00, tmpval);
-	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 2~11M (rf-A) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_B_CCK11_A_CCK2_11));
 
-	// rf-B cck tx power
+	/*  rf-B cck tx power */
 	tmpval = TxAGC[RF_PATH_B]>>24;
 	PHY_SetBBReg(Adapter, rTxAGC_B_CCK11_A_CCK2_11, bMaskByte0, tmpval);
-	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 11M (rf-B) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_B_CCK11_A_CCK2_11));
 	tmpval = TxAGC[RF_PATH_B]&0x00ffffff;
 	PHY_SetBBReg(Adapter, rTxAGC_B_CCK1_55_Mcs32, 0xffffff00, tmpval);
-	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 1~5.5M (rf-B) = 0x%x (reg 0x%x)\n",
-	//	tmpval, rTxAGC_B_CCK1_55_Mcs32));
 }	/* PHY_RF6052SetCckTxPower */
 
-//
-// powerbase0 for OFDM rates
-// powerbase1 for HT MCS rates
-//
+/*  */
+/*  powerbase0 for OFDM rates */
+/*  powerbase1 for HT MCS rates */
+/*  */
 static void getPowerBase(
 	struct rtw_adapter *	Adapter,
 	u8		*pPowerLevel,
@@ -281,12 +272,11 @@ static void getPowerBase(
 
 		powerBase0 = (powerBase0<<24) | (powerBase0<<16) |(powerBase0<<8) |powerBase0;
 		*(OfdmBase+i) = powerBase0;
-		//RTPRINT(FPHY, PHY_TXPWR, (" [OFDM power base index rf(%c) = 0x%x]\n", ((i==0)?'A':'B'), *(OfdmBase+i)));
 	}
 
 	for (i=0; i<2; i++)
 	{
-		//Check HT20 to HT40 diff
+		/* Check HT20 to HT40 diff */
 		if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
 		{
 			HT20_pwrdiff = pHalData->TxPwrHt20Diff[i][Channel-1];
@@ -295,7 +285,6 @@ static void getPowerBase(
 		powerBase1 = powerlevel[i];
 		powerBase1 = (powerBase1<<24) | (powerBase1<<16) |(powerBase1<<8) |powerBase1;
 		*(MCSBase+i) = powerBase1;
-		//RTPRINT(FPHY, PHY_TXPWR, (" [MCS power base index rf(%c) = 0x%x]\n", ((i==0)?'A':'B'), *(MCSBase+i)));
 	}
 }
 
@@ -307,11 +296,11 @@ static u8 getChnlGroupByPG(u8 chnlindex)
 	u8	group=0;
 	u8	channel_info[59] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
 
-	if (channel_info[chnlindex] <= 3)			// Cjanel 1-3
+	if (channel_info[chnlindex] <= 3)			/*  Cjanel 1-3 */
 		group = 0;
-	else if (channel_info[chnlindex] <= 9)		// Channel 4-9
+	else if (channel_info[chnlindex] <= 9)		/*  Channel 4-9 */
 		group = 1;
-	else if (channel_info[chnlindex] <=14)				// Channel 10-14
+	else if (channel_info[chnlindex] <=14)				/*  Channel 10-14 */
 		group = 2;
 	else if (channel_info[chnlindex] <= 64)
 		group = 6;
@@ -339,24 +328,21 @@ static void getTxPowerWriteValByRegulato
 	s8	pwr_diff=0;
 	u32	writeVal, customer_limit, rf;
 
-	//
-	// Index 0 & 1= legacy OFDM, 2-5=HT_MCS rate
-	//
+	/*  */
+	/*  Index 0 & 1= legacy OFDM, 2-5=HT_MCS rate */
+	/*  */
 	for (rf=0; rf<2; rf++)
 	{
 		switch (pHalData->EEPROMRegulatory)
 		{
-			case 0:	// Realtek better performance
-					// increase power diff defined by Realtek for large power
+			case 0:	/*  Realtek better performance */
+					/*  increase power diff defined by Realtek for large power */
 				chnlGroup = 0;
-				//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%lx\n",
-				//	chnlGroup, index, pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]));
 				writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] +
 					((index<2)?powerBase0[rf]:powerBase1[rf]);
-				//RTPRINT(FPHY, PHY_TXPWR, ("RTK better performance, writeVal(%c) = 0x%lx\n", ((rf==0)?'A':'B'), writeVal));
 				break;
-			case 1:	// Realtek regulatory
-					// increase power diff defined by Realtek for regulatory
+			case 1:	/*  Realtek regulatory */
+					/*  increase power diff defined by Realtek for regulatory */
 					if (pHalData->pwrGroupCnt == 1)
 						chnlGroup = 0;
 					if (pHalData->pwrGroupCnt >= MAX_PG_GROUP)
@@ -365,51 +351,33 @@ static void getTxPowerWriteValByRegulato
 
 						if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
 							chnlGroup++;
-						else	   // 40M BW
+						else	   /*  40M BW */
 							chnlGroup += 4;
 					}
-					//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%lx\n",
-					//chnlGroup, index, pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]));
 					writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] +
 							((index<2)?powerBase0[rf]:powerBase1[rf]);
-					//RTPRINT(FPHY, PHY_TXPWR, ("Realtek regulatory, 20MHz, writeVal(%c) = 0x%lx\n", ((rf==0)?'A':'B'), writeVal));
 
 				break;
-			case 2:	// Better regulatory
-					// don't increase any power diff
+			case 2:	/*  Better regulatory */
+					/*  don't increase any power diff */
 				writeVal = ((index<2)?powerBase0[rf]:powerBase1[rf]);
-				//RTPRINT(FPHY, PHY_TXPWR, ("Better regulatory, writeVal(%c) = 0x%lx\n", ((rf==0)?'A':'B'), writeVal));
 				break;
-			case 3:	// Customer defined power diff.
-					// increase power diff defined by customer.
+			case 3:	/*  Customer defined power diff. */
+					/*  increase power diff defined by customer. */
 				chnlGroup = 0;
-				//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%lx\n",
-				//	chnlGroup, index, pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]));
 
-				//if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_40)
-				//{
-					//RTPRINT(FPHY, PHY_TXPWR, ("customer's limit, 40MHz rf(%c) = 0x%x\n",
-					//	((rf==0)?'A':'B'), pHalData->PwrGroupHT40[rf][Channel-1]));
-				//}
-				//else
-				//{
-					//RTPRINT(FPHY, PHY_TXPWR, ("customer's limit, 20MHz rf(%c) = 0x%x\n",
-					//	((rf==0)?'A':'B'), pHalData->PwrGroupHT20[rf][Channel-1]));
-				//}
 
 				if (index < 2)
 					pwr_diff = pHalData->TxPwrLegacyHtDiff[rf][Channel-1];
 				else if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
 					pwr_diff = pHalData->TxPwrHt20Diff[rf][Channel-1];
 
-				//RTPRINT(FPHY, PHY_TXPWR, ("power diff rf(%c) = 0x%x\n", ((rf==0)?'A':'B'), pwr_diff));
 
 				if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_40)
 					customer_pwr_limit = pHalData->PwrGroupHT40[rf][Channel-1];
 				else
 					customer_pwr_limit = pHalData->PwrGroupHT20[rf][Channel-1];
 
-				//RTPRINT(FPHY, PHY_TXPWR, ("customer pwr limit  rf(%c) = 0x%x\n", ((rf==0)?'A':'B'), customer_pwr_limit));
 
 				if (pwr_diff >= customer_pwr_limit)
 					pwr_diff = 0;
@@ -426,37 +394,29 @@ static void getTxPowerWriteValByRegulato
 
 				customer_limit = (pwr_diff_limit[3]<<24) | (pwr_diff_limit[2]<<16) |
 								(pwr_diff_limit[1]<<8) | (pwr_diff_limit[0]);
-				//RTPRINT(FPHY, PHY_TXPWR, ("Customer's limit rf(%c) = 0x%lx\n", ((rf==0)?'A':'B'), customer_limit));
 
 				writeVal = customer_limit + ((index<2)?powerBase0[rf]:powerBase1[rf]);
-				//RTPRINT(FPHY, PHY_TXPWR, ("Customer, writeVal rf(%c)= 0x%lx\n", ((rf==0)?'A':'B'), writeVal));
 				break;
 			default:
 				chnlGroup = 0;
 				writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] +
 						((index<2)?powerBase0[rf]:powerBase1[rf]);
-				//RTPRINT(FPHY, PHY_TXPWR, ("RTK better performance, writeVal rf(%c) = 0x%lx\n", ((rf==0)?'A':'B'), writeVal));
 				break;
 		}
 
-		// 20100628 Joseph: High power mode for BT-Coexist mechanism.
-		// This mechanism is only applied when Driver-Highpower-Mechanism is OFF.
+		/*  20100628 Joseph: High power mode for BT-Coexist mechanism. */
+		/*  This mechanism is only applied when Driver-Highpower-Mechanism is OFF. */
 		if (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_BT1)
 		{
-			//RTPRINT(FBT, BT_TRACE, ("Tx Power (-6)\n"));
 			writeVal = writeVal - 0x06060606;
 		}
 		else if (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_BT2)
 		{
-			//RTPRINT(FBT, BT_TRACE, ("Tx Power (-0)\n"));
 			writeVal = writeVal ;
 		}
 
-		//if (pMgntInfo->bDisableTXPowerByRate)
-		//{
-			// add for  OID_RT_11N_TX_POWER_BY_RATE ,disable tx powre change by rate
-		//	writeVal = 0x2c2c2c2c;
-		//}
+			/*  add for  OID_RT_11N_TX_POWER_BY_RATE ,disable tx powre change by rate */
+		/*  */
 		*(pOutWriteVal+rf) = writeVal;
 	}
 }
@@ -494,9 +454,8 @@ static void writeOFDMPowerReg(
 		else
 			RegOffset = RegOffset_B[index];
 		PHY_SetBBReg(Adapter, RegOffset, bMaskDWord, writeVal);
-		//RTPRINT(FPHY, PHY_TXPWR, ("Set 0x%x = %08x\n", RegOffset, writeVal));
 
-		// 201005115 Joseph: Set Tx Power diff for Tx power training mechanism.
+		/*  201005115 Joseph: Set Tx Power diff for Tx power training mechanism. */
 		if (((pHalData->rf_type == RF_2T2R) &&
 				(RegOffset == rTxAGC_A_Mcs15_Mcs12 || RegOffset == rTxAGC_B_Mcs15_Mcs12))||
 		     ((pHalData->rf_type != RF_2T2R) &&
@@ -549,8 +508,6 @@ rtl8192d_PHY_RF6052SetOFDMTxPower(
 	u32	writeVal[2], powerBase0[2], powerBase1[2];
 	u8	index = 0;
 
-	//DBG_871X("PHY_RF6052SetOFDMTxPower, channel(%d)\n", Channel);
-
 	getPowerBase(Adapter, pPowerLevel, Channel, &powerBase0[0], &powerBase1[0]);
 
 	for (index=0; index<6; index++)
@@ -571,15 +528,15 @@ rtl8192d_PHY_EnableAnotherPHY(
 	u8			u1bTmp;
 	u8			MAC_REG = bMac0==true?REG_MAC1:REG_MAC0;
 	u8			MAC_ON_BIT = bMac0==true?MAC1_ON:MAC0_ON;
-	bool		bResult = true;	//true: need to enable BB/RF power
+	bool		bResult = true;	/* true: need to enable BB/RF power */
 	u32			MaskForPHYSet = 0;
 
-	//MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write.
+	/* MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write. */
 	u1bTmp = rtw_read8(Adapter, MAC_REG);
 
 	if (!(u1bTmp&MAC_ON_BIT))
 	{
-		// Enable BB and RF power
+		/*  Enable BB and RF power */
 		if (bMac0)
 			MaskForPHYSet = MAC0_ACCESS_PHY1;
 		else
@@ -587,7 +544,7 @@ rtl8192d_PHY_EnableAnotherPHY(
 		rtw_write16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet, rtw_read16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet)&0xFFFC);
 		rtw_write16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet, rtw_read16(Adapter, REG_SYS_FUNC_EN|MaskForPHYSet)|BIT13|BIT0|BIT1);
 	} else {
-		// We think if MAC1 is ON,then radio_a.txt and radio_b.txt has been load.
+		/*  We think if MAC1 is ON,then radio_a.txt and radio_b.txt has been load. */
 		bResult = false;
 	}
 	return bResult;
@@ -604,11 +561,11 @@ rtl8192d_PHY_PowerDownAnotherPHY(
 	u8	MAC_ON_BIT = bMac0==true?MAC1_ON:MAC0_ON;
 	u32	MaskforPhySet = 0;
 
-	// check MAC0 enable or not again now, if enabled, not power down radio A.
+	/*  check MAC0 enable or not again now, if enabled, not power down radio A. */
 	u1bTmp = rtw_read8(Adapter, MAC_REG);
 
 	if (!(u1bTmp&MAC_ON_BIT)) {
-		// power down RF radio A according to YuNan's advice.
+		/*  power down RF radio A according to YuNan's advice. */
 		if (bMac0)
 			MaskforPhySet = MAC0_ACCESS_PHY1;
 		else
@@ -616,7 +573,6 @@ rtl8192d_PHY_PowerDownAnotherPHY(
 		  rtw_write32(Adapter, rFPGA0_XA_LSSIParameter|MaskforPhySet, 0x00000000);
 	}
 
-	//RT_TRACE(COMP_RF, DBG_LOUD, ("<====PHY_PowerDownAnotherPHY\n"));
 }
 
 static int
@@ -637,8 +593,8 @@ phy_RF6052_Config_ParaFile(
 	static s8		sz92DRadioBintPAFile[] = RTL8192D_PHY_RADIO_B_intPA;
 	bool		bMac1NeedInitRadioAFirst = false,bMac0NeedInitRadioBFirst = false;
 	bool		bNeedPowerDownRadioA = false,bNeedPowerDownRadioB = false;
-	bool		bTrueBPath = false;//vivi added this for read parameter from header, 20100908
-	u32	MaskforPhySet = 0; //For 92d PHY cross access, 88c must set value 0.
+	bool		bTrueBPath = false;/* vivi added this for read parameter from header, 20100908 */
+	u32	MaskforPhySet = 0; /* For 92d PHY cross access, 88c must set value 0. */
 
 
 	pszRadioAFile = sz92DRadioAFile;
@@ -649,12 +605,12 @@ phy_RF6052_Config_ParaFile(
 	if (pHalData->InternalPA5G[1])
 		pszRadioBFile = sz92DRadioBintPAFile;
 
-	//DMDP,MAC0 on G band,MAC1 on A band.
+	/* DMDP,MAC0 on G band,MAC1 on A band. */
 	if (pHalData->MacPhyMode92D==DUALMAC_DUALPHY)
 	{
 		if (pHalData->CurrentBandType92D == BAND_ON_2_4G && pHalData->interfaceIndex == 0)
 		{
-			//MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write.
+			/* MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write. */
 			if (rtl8192d_PHY_EnableAnotherPHY(Adapter, true))
 			{
 				pHalData->NumTotalRFPath = 2;
@@ -662,13 +618,13 @@ phy_RF6052_Config_ParaFile(
 			}
 			else
 			{
-				// We think if MAC1 is ON,then radio_a.txt and radio_b.txt has been load.
+				/*  We think if MAC1 is ON,then radio_a.txt and radio_b.txt has been load. */
 				return rtStatus;
 			}
 		}
 		else if (pHalData->CurrentBandType92D == BAND_ON_5G && pHalData->interfaceIndex == 1)
 		{
-			//MAC1 Need PHY0 load radio_a.txt . Driver use DBI to write.
+			/* MAC1 Need PHY0 load radio_a.txt . Driver use DBI to write. */
 			if (rtl8192d_PHY_EnableAnotherPHY(Adapter, false))
 			{
 				pHalData->NumTotalRFPath = 2;
@@ -676,27 +632,25 @@ phy_RF6052_Config_ParaFile(
 			}
 			else
 			{
-				// We think if MAC0 is ON,then radio_a.txt and radio_b.txt has been load.
+				/*  We think if MAC0 is ON,then radio_a.txt and radio_b.txt has been load. */
 				return rtStatus;
 			}
 		}
 		else if (pHalData->interfaceIndex == 1)
 		{
-			// MAC0 enabled, only init radia B.
+			/*  MAC0 enabled, only init radia B. */
 			pszRadioAFile = pszRadioBFile;
-			bTrueBPath = true;  //vivi added this for read parameter from header, 20100909
+			bTrueBPath = true;  /* vivi added this for read parameter from header, 20100909 */
 		}
 	}
 
-	//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> phy_RF6052_Config_ParaFile() Radio_A:%s\n",pszRadioAFile));
-	//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> phy_RF6052_Config_ParaFile() Radio_B:%s\n",pszRadioBFile));
 
-	//3//-----------------------------------------------------------------
-	//3// <2> Initialize RF
-	//3//-----------------------------------------------------------------
+	/* 3----------------------------------------------------------------- */
+	/* 3 <2> Initialize RF */
+	/* 3----------------------------------------------------------------- */
 	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 	{
-		if (bMac1NeedInitRadioAFirst) //Mac1 use PHY0 write
+		if (bMac1NeedInitRadioAFirst) /* Mac1 use PHY0 write */
 		{
 			if (eRFPath == RF_PATH_A)
 			{
@@ -713,7 +667,7 @@ phy_RF6052_Config_ParaFile(
 				pHalData->NumTotalRFPath = 1;
 			}
 		}
-		else  if (bMac0NeedInitRadioBFirst) //Mac0 use PHY1 write
+		else  if (bMac0NeedInitRadioBFirst) /* Mac0 use PHY1 write */
 		{
 			if (eRFPath == RF_PATH_A)
 			{
@@ -749,25 +703,25 @@ phy_RF6052_Config_ParaFile(
 
 		/*----Set RF_ENV enable----*/
 		PHY_SetBBReg(Adapter, pPhyReg->rfintfe|MaskforPhySet, bRFSI_RFENV<<16, 0x1);
-		rtw_udelay_os(1);//PlatformStallExecution(1);
+		rtw_udelay_os(1);/* PlatformStallExecution(1); */
 
 		/*----Set RF_ENV output high----*/
 		PHY_SetBBReg(Adapter, pPhyReg->rfintfo|MaskforPhySet, bRFSI_RFENV, 0x1);
-		rtw_udelay_os(1);//PlatformStallExecution(1);
+		rtw_udelay_os(1);/* PlatformStallExecution(1); */
 
 		/* Set bit number of Address and Data for RF register */
-		PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireAddressLength, 0x0);	// Set 1 to 4 bits for 8255
-		rtw_udelay_os(1);//PlatformStallExecution(1);
+		PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireAddressLength, 0x0);	/*  Set 1 to 4 bits for 8255 */
+		rtw_udelay_os(1);/* PlatformStallExecution(1); */
 
-		PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireDataLength, 0x0);	// Set 0 to 12  bits for 8255
-		rtw_udelay_os(1);//PlatformStallExecution(1);
+		PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireDataLength, 0x0);	/*  Set 0 to 12  bits for 8255 */
+		rtw_udelay_os(1);/* PlatformStallExecution(1); */
 
 		/*----Initialize RF fom connfiguration file----*/
 		switch (eRFPath)
 		{
 			case RF_PATH_A:
 #ifdef CONFIG_EMBEDDED_FWIMG
-				//vivi added this for read parameter from header, 20100908
+				/* vivi added this for read parameter from header, 20100908 */
 				if (bTrueBPath == true)
 					rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(Adapter,radiob_txt|MaskforPhySet, (enum RF_RADIO_PATH_E)eRFPath);
 				else
@@ -803,7 +757,6 @@ phy_RF6052_Config_ParaFile(
 		}
 
 		if (rtStatus != _SUCCESS) {
-			//RT_TRACE(COMP_FPGA, DBG_LOUD, ("phy_RF6052_Config_ParaFile():Radio[%d] Fail!!", eRFPath));
 			goto phy_RF6052_Config_ParaFile_Fail;
 		}
 
@@ -811,12 +764,12 @@ phy_RF6052_Config_ParaFile(
 
 	if (bNeedPowerDownRadioA)
 	{
-		// check MAC0 enable or not again now, if enabled, not power down radio A.
+		/*  check MAC0 enable or not again now, if enabled, not power down radio A. */
 		rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
 	}
 	else  if (bNeedPowerDownRadioB)
 	{
-		// check MAC1 enable or not again now, if enabled, not power down radio B.
+		/*  check MAC1 enable or not again now, if enabled, not power down radio B. */
 		rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
 	}
 
@@ -828,7 +781,6 @@ phy_RF6052_Config_ParaFile(
 		pdmpriv->RegRF3C[eRFPath] = PHY_QueryRFReg(Adapter, eRFPath, RF_RXRF_A3, bRFRegOffsetMask);
 	}
 
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("<---phy_RF6052_Config_ParaFile()\n"));
 	return rtStatus;
 
 phy_RF6052_Config_ParaFile_Fail:
@@ -842,10 +794,10 @@ PHY_RF6052_Config8192D(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	int rtStatus = _SUCCESS;
 
-	//
-	// Initialize general global value
-	//
-	// TODO: Extend RF_PATH_C and RF_PATH_D in the future
+	/*  */
+	/*  Initialize general global value */
+	/*  */
+	/*  TODO: Extend RF_PATH_C and RF_PATH_D in the future */
 	if (pHalData->rf_type == RF_1T1R)
 		pHalData->NumTotalRFPath = 1;
 	else
@@ -859,18 +811,18 @@ PHY_RF6052_Config8192D(
 	}
 #endif
 
-	//
-	// Config BB and RF
-	//
+	/*  */
+	/*  Config BB and RF */
+	/*  */
 	rtStatus = phy_RF6052_Config_ParaFile(Adapter);
 
 	return rtStatus;
 }
 
 
-//
-// ==> RF shadow Operation API Code Section!!!
-//
+/*  */
+/*  ==> RF shadow Operation API Code Section!!! */
+/*  */
 /*-----------------------------------------------------------------------------
  * Function:	PHY_RFShadowRead
  *				PHY_RFShadowWrite
@@ -925,18 +877,15 @@ PHY_RFShadowCompare(
 	u32				Offset)
 {
 	u32	reg;
-	// Check if we need to check the register
+	/*  Check if we need to check the register */
 	if (RF_Shadow[eRFPath][Offset].Compare == true)
 	{
 		reg = PHY_QueryRFReg(Adapter, eRFPath, Offset, bRFRegOffsetMask);
-		// Compare shadow and real rf register for 20bits!!
+		/*  Compare shadow and real rf register for 20bits!! */
 		if (RF_Shadow[eRFPath][Offset].Value != reg)
 		{
-			// Locate error position.
+			/*  Locate error position. */
 			RF_Shadow[eRFPath][Offset].ErrorOrNot = true;
-			//RT_TRACE(COMP_INIT, DBG_LOUD,
-			//("PHY_RFShadowCompare RF-%d Addr%02lx Err = %05lx\n",
-			//eRFPath, Offset, reg));
 		}
 		return RF_Shadow[eRFPath][Offset].ErrorOrNot ;
 	}
@@ -949,17 +898,14 @@ PHY_RFShadowRecorver(
 	enum RF_RADIO_PATH_E	eRFPath,
 	u32				Offset)
 {
-	// Check if the address is error
+	/*  Check if the address is error */
 	if (RF_Shadow[eRFPath][Offset].ErrorOrNot == true)
 	{
-		// Check if we need to recorver the register.
+		/*  Check if we need to recorver the register. */
 		if (RF_Shadow[eRFPath][Offset].Recorver == true)
 		{
 			PHY_SetRFReg(Adapter, eRFPath, Offset, bRFRegOffsetMask,
 							RF_Shadow[eRFPath][Offset].Value);
-			//RT_TRACE(COMP_INIT, DBG_LOUD,
-			//("PHY_RFShadowRecorver RF-%d Addr%02lx=%05lx",
-			//eRFPath, Offset, RF_Shadow[eRFPath][Offset].Value));
 		}
 	}
 }	/* PHY_RFShadowRecorver */
@@ -999,7 +945,7 @@ PHY_RFShadowCompareFlagSet(
 	u32				Offset,
 	u8				Type)
 {
-	// Set True or False!!!
+	/*  Set True or False!!! */
 	RF_Shadow[eRFPath][Offset].Compare = Type;
 }	/* PHY_RFShadowCompareFlagSet */
 
@@ -1010,7 +956,7 @@ PHY_RFShadowRecorverFlagSet(
 	u32				Offset,
 	u8				Type)
 {
-	// Set True or False!!!
+	/*  Set True or False!!! */
 	RF_Shadow[eRFPath][Offset].Recorver= Type;
 }	/* PHY_RFShadowRecorverFlagSet */
 
@@ -1023,7 +969,7 @@ void PHY_RFShadowCompareFlagSetAll(struc
 	{
 		for (Offset = 0; Offset <= RF6052_MAX_REG; Offset++)
 		{
-			// 2008/11/20 MH For S3S4 test, we only check reg 26/27 now!!!!
+			/*  2008/11/20 MH For S3S4 test, we only check reg 26/27 now!!!! */
 			if (Offset != 0x26 && Offset != 0x27)
 				PHY_RFShadowCompareFlagSet(Adapter, (enum RF_RADIO_PATH_E)eRFPath, Offset, false);
 			else
@@ -1041,7 +987,7 @@ void PHY_RFShadowRecorverFlagSetAll(stru
 	{
 		for (Offset = 0; Offset <= RF6052_MAX_REG; Offset++)
 		{
-			// 2008/11/20 MH For S3S4 test, we only check reg 26/27 now!!!!
+			/*  2008/11/20 MH For S3S4 test, we only check reg 26/27 now!!!! */
 			if (Offset != 0x26 && Offset != 0x27)
 				PHY_RFShadowRecorverFlagSet(Adapter, (enum RF_RADIO_PATH_E)eRFPath, Offset, false);
 			else
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
@@ -25,13 +25,13 @@
 
 static u8 evm_db2percentage(s8 value)
 {
-	//
-	// -33dB~0dB to 0%~99%
-	//
+	/*  */
+	/*  -33dB~0dB to 0%~99% */
+	/*  */
 	s8 ret_val;
 
 	ret_val = value;
-	//ret_val /= 2;
+	/* ret_val /= 2; */
 
 	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("EVMdbToPercentage92S Value=%d / %x\n", ret_val, ret_val));
 
@@ -75,10 +75,10 @@ static s32 signal_scale_mapping(struct r
 
 static s32  translate2dbm(u8 signal_strength_idx)
 {
-	s32	signal_power; // in dBm.
+	s32	signal_power; /*  in dBm. */
 
 
-	// Translate to dBm (x=0.5y-95).
+	/*  Translate to dBm (x=0.5y-95). */
 	signal_power = (s32)((signal_strength_idx + 1) >> 1);
 	signal_power -= 95;
 
@@ -105,22 +105,21 @@ static void query_rx_phy_status(union re
 
 	bcck_rate=(pattrib->mcs_rate<=3? 1:0);
 
-	// Record it for next packet processing
+	/*  Record it for next packet processing */
 	pattrib->rx_mimo_signal_qual[0]= -1;
 	pattrib->rx_mimo_signal_qual[1]= -1;
 
-	if (bcck_rate) //CCK
+	if (bcck_rate) /* CCK */
 	{
 		u8 report;
 
-		// CCK Driver info Structure is not the same as OFDM packet.
+		/*  CCK Driver info Structure is not the same as OFDM packet. */
 		pCck_buf = (struct phy_cck_rx_status_report_8192cd *)pphy_stat;
-		//Adapter->RxStats.NumQryPhyStatusCCK++;
 
-		//
-		// (1)Hardware does not provide RSSI for CCK
-		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
-		//
+		/*  */
+		/*  (1)Hardware does not provide RSSI for CCK */
+		/*  (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive) */
+		/*  */
 
 		if (padapter->pwrctrlpriv.rf_pwrstate == rf_on)
 			cck_highpwr = (u8)pHalData->bCckHighPower;
@@ -133,9 +132,9 @@ static void query_rx_phy_status(union re
 			report = report>>6;
 			switch (report)
 			{
-				// 03312009 modified by cosa
-				// Modify the RF RNA gain value to -40, -20, -2, 14 by Jenyu's suggestion
-				// Note: different RF with the different RNA gain.
+				/*  03312009 modified by cosa */
+				/*  Modify the RF RNA gain value to -40, -20, -2, 14 by Jenyu's suggestion */
+				/*  Note: different RF with the different RNA gain. */
 				case 0x3:
 					rx_pwr_all = (-46) - (pCck_buf->cck_agc_rpt & 0x3e);
 					break;
@@ -172,14 +171,13 @@ static void query_rx_phy_status(union re
 		}
 
 		pwdb_all= query_rx_pwr_percentage(rx_pwr_all);
-		//if (pHalData->CustomerID == RT_CID_819x_Lenovo)
 		{
-			// CCK gain is smaller than OFDM/MCS gain,
-			// so we add gain diff by experiences, the val is 6
+			/*  CCK gain is smaller than OFDM/MCS gain, */
+			/*  so we add gain diff by experiences, the val is 6 */
 			pwdb_all+=6;
 			if (pwdb_all > 100)
 				pwdb_all = 100;
-			// modify the offset to make the same gain index with OFDM.
+			/*  modify the offset to make the same gain index with OFDM. */
 			if (pwdb_all > 34 && pwdb_all <= 42)
 				pwdb_all -= 2;
 			else if (pwdb_all > 26 && pwdb_all <= 34)
@@ -194,18 +192,18 @@ static void query_rx_phy_status(union re
 		pattrib->RecvSignalPower = rx_pwr_all;
 		padapter->recvpriv.rxpwdb = rx_pwr_all;
 
-		//
-		// (3) Get Signal Quality (EVM)
-		//
+		/*  */
+		/*  (3) Get Signal Quality (EVM) */
+		/*  */
 		if (bPacketMatchBSSID)
 		{
 			u8	sq;
 
 			if (pHalData->CustomerID == RT_CID_819x_Lenovo)
 			{
-				// mapping to 5 bars for vista signal strength
-				// signal quality in driver will be displayed to signal strength
-				// in vista.
+				/*  mapping to 5 bars for vista signal strength */
+				/*  signal quality in driver will be displayed to signal strength */
+				/*  in vista. */
 				if (pwdb_all >= 50)
 					sq = 100;
 				else if (pwdb_all >= 35 && pwdb_all < 50)
@@ -242,20 +240,18 @@ static void query_rx_phy_status(union re
 			pattrib->rx_mimo_signal_qual[1]=(-1);
 		}
 	}
-	else //OFDM/HT
+	else /* OFDM/HT */
 	{
 		pOfdm_buf = (struct phy_ofdm_rx_status_report_8192cd *)pphy_stat;
 
-		//
-		// (1)Get RSSI for HT rate
-		//
+		/*  */
+		/*  (1)Get RSSI for HT rate */
+		/*  */
 		for (i=0; i<pHalData->NumTotalRFPath; i++)
 		{
-			// 2008/01/30 MH we will judge RF RX path now.
+			/*  2008/01/30 MH we will judge RF RX path now. */
 			if (pHalData->bRFPathRxEnable[i])
 				rf_rx_num++;
-			//else
-				//continue;
 
 			rx_pwr[i] = ((pOfdm_buf->trsw_gain_X[+i]&0x3F)*2) - 110;
 			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
@@ -271,7 +267,7 @@ static void query_rx_phy_status(union re
 
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("RF-%d RXPWR=%x RSSI=%d\n", i, rx_pwr[i], rssi));
 
-			//Get Rx snr value in DB
+			/* Get Rx snr value in DB */
 			tmp_rxsnr = pOfdm_buf->rxsnr_X[i];
 			rx_snrX = (s8)(tmp_rxsnr);
 			rx_snrX >>= 1;
@@ -280,18 +276,17 @@ static void query_rx_phy_status(union re
 			/* Record Signal Strength for next packet */
 			if (bPacketMatchBSSID)
 			{
-				//pRfd->Status.RxMIMOSignalStrength[i] =(u8) rssi;
 
-				//The following is for lenovo signal strength in vista
+				/* The following is for lenovo signal strength in vista */
 				if (pHalData->CustomerID == RT_CID_819x_Lenovo)
 				{
 					u8	SQ;
 
 					if (i == 0)
 					{
-						// mapping to 5 bars for vista signal strength
-						// signal quality in driver will be displayed to signal strength
-						// in vista.
+						/*  mapping to 5 bars for vista signal strength */
+						/*  signal quality in driver will be displayed to signal strength */
+						/*  in vista. */
 						if (rssi >= 50)
 							SQ = 100;
 						else if (rssi >= 35 && rssi < 50)
@@ -302,50 +297,50 @@ static void query_rx_phy_status(union re
 							SQ = 40;
 						else
 							SQ = 20;
-						//DbgPrint("ofdm/mcs RSSI=%d\n", RSSI);
+						/* DbgPrint("ofdm/mcs RSSI=%d\n", RSSI); */
 						pattrib->signal_qual = SQ;
-						//DbgPrint("ofdm/mcs SQ = %d\n", pRfd->Status.SignalQuality);
+						/* DbgPrint("ofdm/mcs SQ = %d\n", pRfd->Status.SignalQuality); */
 					}
 				}
 			}
 		}
 
 
-		//
-		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
-		//
+		/*  */
+		/*  (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive) */
+		/*  */
 		rx_pwr_all = (((pOfdm_buf->pwdb_all) >> 1)& 0x7f) -106;
 		pwdb_all = query_rx_pwr_percentage(rx_pwr_all);
 
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("PWDB_ALL=%d\n",	pwdb_all));
 
-		pattrib->RxPWDBAll = pwdb_all;	//for DIG/rate adaptive
+		pattrib->RxPWDBAll = pwdb_all;	/* for DIG/rate adaptive */
 		pattrib->RecvSignalPower = rx_pwr_all;
 		padapter->recvpriv.rxpwdb = rx_pwr_all;
 
-		//
-		// (3)EVM of HT rate
-		//
+		/*  */
+		/*  (3)EVM of HT rate */
+		/*  */
 		if (pHalData->CustomerID != RT_CID_819x_Lenovo)
 		{
 			if (pattrib->rxht &&  pattrib->mcs_rate >=20 && pattrib->mcs_rate<=27)
-				max_spatial_stream = 2; //both spatial stream make sense
+				max_spatial_stream = 2; /* both spatial stream make sense */
 			else
-				max_spatial_stream = 1; //only spatial stream 1 makes sense
+				max_spatial_stream = 1; /* only spatial stream 1 makes sense */
 
 			for (i=0; i<max_spatial_stream; i++)
 			{
-				// Do not use shift operation like "rx_evmX >>= 1" because the compilor of free build environment
-				// fill most significant bit to "zero" when doing shifting operation which may change a negative
-				// value to positive one, then the dbm value (which is supposed to be negative)  is not correct anymore.
-				evm = evm_db2percentage((pOfdm_buf->rxevm_X[i] /*/ 2*/));//dbm
+				/*  Do not use shift operation like "rx_evmX >>= 1" because the compilor of free build environment */
+				/*  fill most significant bit to "zero" when doing shifting operation which may change a negative */
+				/*  value to positive one, then the dbm value (which is supposed to be negative)  is not correct anymore. */
+				evm = evm_db2percentage((pOfdm_buf->rxevm_X[i] /*/ 2*/));/* dbm */
 
 				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("RXRATE=%x RXEVM=%x EVM=%s%d\n",
 					pattrib->mcs_rate, pOfdm_buf->rxevm_X[i], "%",evm));
 
 				if (bPacketMatchBSSID)
 				{
-					if (i==0) // Fill value in RFD, Get the first spatial stream only
+					if (i==0) /*  Fill value in RFD, Get the first spatial stream only */
 					{
 						pattrib->signal_qual = (u8)(evm & 0xff);
 					}
@@ -355,15 +350,15 @@ static void query_rx_phy_status(union re
 
 		}
 
-		//
-		// 4. Record rx statistics for debug
-		//
+		/*  */
+		/*  4. Record rx statistics for debug */
+		/*  */
 
 	}
 
 
-	//UI BSS List signal strength(in percentage), make it good looking, from 0~100.
-	//It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp().
+	/* UI BSS List signal strength(in percentage), make it good looking, from 0~100. */
+	/* It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp(). */
 	if (bcck_rate)
 	{
 		pattrib->signal_strength=(u8)signal_scale_mapping(padapter, pwdb_all);
@@ -384,9 +379,8 @@ static void process_rssi(struct rtw_adap
 	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	struct signal_stat * signal_stat = &padapter->recvpriv.signal_strength_data;
-#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
-	//if (pRfd->Status.bPacketToSelf || pRfd->Status.bPacketBeacon)
 	{
 	#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 		if (signal_stat->update_req) {
@@ -398,9 +392,8 @@ static void process_rssi(struct rtw_adap
 		signal_stat->total_num++;
 		signal_stat->total_val  += pattrib->signal_strength;
 		signal_stat->avg_val = signal_stat->total_val / signal_stat->total_num;
-	#else //CONFIG_NEW_SIGNAL_STAT_PROCESS
+	#else /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
-		//Adapter->RxStats.RssiCalculateCnt++;	//For antenna Test
 		if (padapter->recvpriv.signal_strength_data.total_num++ >= PHY_RSSI_SLID_WIN_MAX)
 		{
 			padapter->recvpriv.signal_strength_data.total_num = PHY_RSSI_SLID_WIN_MAX;
@@ -419,9 +412,9 @@ static void process_rssi(struct rtw_adap
 		padapter->recvpriv.rssi=(s8)translate2dbm((u8)tmp_val);
 
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("UI RSSI = %d, ui_rssi.TotalVal = %d, ui_rssi.TotalNum = %d\n", tmp_val, padapter->recvpriv.signal_strength_data.total_val,padapter->recvpriv.signal_strength_data.total_num));
-	#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+	#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 	}
-}// Process_UI_RSSI_8192S
+}/*  Process_UI_RSSI_8192S */
 
 
 static void process_PWDB(struct rtw_adapter *padapter, union recv_frame *prframe)
@@ -441,9 +434,8 @@ static void process_PWDB(struct rtw_adap
 		UndecoratedSmoothedPWDB = pdmpriv->UndecoratedSmoothedPWDB;
 	}
 
-	//if (pRfd->Status.bPacketToSelf || pRfd->Status.bPacketBeacon)
 	{
-		if (UndecoratedSmoothedPWDB == 0) // initialize
+		if (UndecoratedSmoothedPWDB == 0) /*  initialize */
 		{
 			UndecoratedSmoothedPWDB = pattrib->RxPWDBAll;
 		}
@@ -472,8 +464,6 @@ static void process_PWDB(struct rtw_adap
 		{
 			pdmpriv->UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
 		}
-
-		//UpdateRxSignalStatistics8192C(Adapter, pRfd);
 	}
 }
 
@@ -484,7 +474,7 @@ static void process_link_qual(struct rtw
 	struct rx_pkt_attrib *pattrib;
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	struct signal_stat * signal_stat;
-#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 	if (prframe == NULL || padapter==NULL) {
 		return;
@@ -493,7 +483,7 @@ static void process_link_qual(struct rtw
 	pattrib = &prframe->u.hdr.attrib;
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	signal_stat = &padapter->recvpriv.signal_qual_data;
-#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	if (signal_stat->update_req) {
@@ -506,12 +496,12 @@ static void process_link_qual(struct rtw
 	signal_stat->total_val  += pattrib->signal_qual;
 	signal_stat->avg_val = signal_stat->total_val / signal_stat->total_num;
 
-#else //CONFIG_NEW_SIGNAL_STAT_PROCESS
+#else /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 	if (pattrib->signal_qual != 0)
 	{
-			//
-			// 1. Record the general EVM to the sliding window.
-			//
+			/*  */
+			/*  1. Record the general EVM to the sliding window. */
+			/*  */
 			if (padapter->recvpriv.signal_qual_data.total_num++ >= PHY_LINKQUALITY_SLID_WIN_MAX)
 			{
 				padapter->recvpriv.signal_qual_data.total_num = PHY_LINKQUALITY_SLID_WIN_MAX;
@@ -526,7 +516,7 @@ static void process_link_qual(struct rtw
 
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("Total SQ=%d  pattrib->signal_qual= %d\n", padapter->recvpriv.signal_qual_data.total_val, pattrib->signal_qual));
 
-			// <1> Showed on UI for user, in percentage.
+			/*  <1> Showed on UI for user, in percentage. */
 			tmpVal = padapter->recvpriv.signal_qual_data.total_val/padapter->recvpriv.signal_qual_data.total_num;
 			padapter->recvpriv.signal_qual=(u8)tmpVal;
 	}
@@ -534,25 +524,25 @@ static void process_link_qual(struct rtw
 	{
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" pattrib->signal_qual =%d\n", pattrib->signal_qual));
 	}
-#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
-}// Process_UiLinkQuality8192S
+#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
+}/*  Process_UiLinkQuality8192S */
 
 
 static void process_phy_info(struct rtw_adapter *padapter, union recv_frame *prframe)
 {
 	union recv_frame *precvframe = (union recv_frame *)prframe;
 
-	//
-	// Check RSSI
-	//
+	/*  */
+	/*  Check RSSI */
+	/*  */
 	process_rssi(padapter, precvframe);
-	//
-	// Check PWDB.
-	//
+	/*  */
+	/*  Check PWDB. */
+	/*  */
 	process_PWDB(padapter, precvframe);
-	//
-	// Check EVM
-	//
+	/*  */
+	/*  Check EVM */
+	/*  */
 	process_link_qual(padapter,  precvframe);
 }
 
@@ -618,48 +608,47 @@ void rtl8192d_query_rx_desc_status(union
 {
 	struct rx_pkt_attrib	*pattrib = &precvframe->u.hdr.attrib;
 
-	//Offset 0
+	/* Offset 0 */
 	pattrib->physt = (u8)((le32_to_cpu(pdesc->rxdw0) >> 26) & 0x1);
 	pattrib->pkt_len =  (u16)(le32_to_cpu(pdesc->rxdw0)&0x00003fff);
-	pattrib->drvinfo_sz = (u8)((le32_to_cpu(pdesc->rxdw0) >> 16) & 0xf) * 8;//uint 2^3 = 8 bytes
+	pattrib->drvinfo_sz = (u8)((le32_to_cpu(pdesc->rxdw0) >> 16) & 0xf) * 8;/* uint 2^3 = 8 bytes */
 
 	pattrib->shift_sz = (u8)((le32_to_cpu(pdesc->rxdw0) >> 24) & 0x3);
 
 	pattrib->crc_err = (u8)((le32_to_cpu(pdesc->rxdw0) >> 14) & 0x1);
 	pattrib->icv_err = (u8)((le32_to_cpu(pdesc->rxdw0) >> 15) & 0x1);
-	pattrib->qos = (u8)((le32_to_cpu(pdesc->rxdw0) >> 23) & 0x1);// Qos data, wireless lan header length is 26
+	pattrib->qos = (u8)((le32_to_cpu(pdesc->rxdw0) >> 23) & 0x1);/*  Qos data, wireless lan header length is 26 */
 	pattrib->bdecrypted = (le32_to_cpu(pdesc->rxdw0) & BIT(27))? 0:1;
 
-	//Offset 4
-	pattrib->mfrag = (u8)((le32_to_cpu(pdesc->rxdw1) >> 27) & 0x1);//more fragment bit
+	/* Offset 4 */
+	pattrib->mfrag = (u8)((le32_to_cpu(pdesc->rxdw1) >> 27) & 0x1);/* more fragment bit */
 
-	//Offset 8
-	pattrib->frag_num = (u8)((le32_to_cpu(pdesc->rxdw2) >> 12) & 0xf);//fragmentation number
+	/* Offset 8 */
+	pattrib->frag_num = (u8)((le32_to_cpu(pdesc->rxdw2) >> 12) & 0xf);/* fragmentation number */
 
-	//Offset 12
+	/* Offset 12 */
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
 	if (le32_to_cpu(pdesc->rxdw3) & BIT(13)) {
-		pattrib->tcpchk_valid = 1; // valid
+		pattrib->tcpchk_valid = 1; /*  valid */
 		if (le32_to_cpu(pdesc->rxdw3) & BIT(11)) {
-			pattrib->tcp_chkrpt = 1; // correct
-			//DBG_8192C("tcp csum ok\n");
+			pattrib->tcp_chkrpt = 1; /*  correct */
 		}
 		else
-			pattrib->tcp_chkrpt = 0; // incorrect
+			pattrib->tcp_chkrpt = 0; /*  incorrect */
 
 		if (le32_to_cpu(pdesc->rxdw3) & BIT(12))
-			pattrib->ip_chkrpt = 1; // correct
+			pattrib->ip_chkrpt = 1; /*  correct */
 		else
-			pattrib->ip_chkrpt = 0; // incorrect
+			pattrib->ip_chkrpt = 0; /*  incorrect */
 	}
 	else {
-		pattrib->tcpchk_valid = 0; // invalid
+		pattrib->tcpchk_valid = 0; /*  invalid */
 	}
 #endif
 
 	pattrib->mcs_rate=(u8)((le32_to_cpu(pdesc->rxdw3))&0x3f);
 	pattrib->rxht=(u8)((le32_to_cpu(pdesc->rxdw3) >>6)&0x1);
 
-	//Offset 16
-	//Offset 20
+	/* Offset 16 */
+	/* Offset 20 */
 }
--- a/drivers/staging/rtl8192du/hal/rtl8192d_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_xmit.c
@@ -59,4 +59,4 @@ void handle_txrpt_ccx_8192d(struct rtw_a
 			rtw_ack_tx_done(&adapter->xmitpriv, RTW_SCTX_DONE_CCX_PKT_FAIL);
 	}
 }
-#endif //CONFIG_XMIT_ACK
+#endif /* CONFIG_XMIT_ACK */
--- a/drivers/staging/rtl8192du/hal/rtl8192du_led.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_led.c
@@ -21,31 +21,31 @@
 #include "drv_types.h"
 #include "rtl8192d_hal.h"
 
-//================================================================================
-//	Constant.
-//================================================================================
-
-//
-// Default LED behavior.
-//
+/*  */
+/* 	Constant. */
+/*  */
+
+/*  */
+/*  Default LED behavior. */
+/*  */
 #define LED_BLINK_NORMAL_INTERVAL	100
 #define LED_BLINK_SLOWLY_INTERVAL	200
 #define LED_BLINK_LONG_INTERVAL	400
 
 #define LED_BLINK_NO_LINK_INTERVAL_ALPHA		1000
-#define LED_BLINK_LINK_INTERVAL_ALPHA			500		//500
-#define LED_BLINK_SCAN_INTERVAL_ALPHA		180	//150
+#define LED_BLINK_LINK_INTERVAL_ALPHA			500		/* 500 */
+#define LED_BLINK_SCAN_INTERVAL_ALPHA		180	/* 150 */
 #define LED_BLINK_FASTER_INTERVAL_ALPHA		50
 #define LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA	5000
 
-//================================================================================
-// LED object.
-//================================================================================
+/*  */
+/*  LED object. */
+/*  */
 
 
-//================================================================================
-//	Prototype of protected function.
-//================================================================================
+/*  */
+/* 	Prototype of protected function. */
+/*  */
 
 static void
 BlinkTimerCallback(
@@ -59,27 +59,27 @@ BlinkWorkItemCallback(
 
 static void
 ResetLedStatus(struct LED_871X *	pLed) {
-	pLed->CurrLedState = RTW_LED_OFF; // Current LED state.
-	pLed->bLedOn = false; // true if LED is ON, false if LED is OFF.
+	pLed->CurrLedState = RTW_LED_OFF; /*  Current LED state. */
+	pLed->bLedOn = false; /*  true if LED is ON, false if LED is OFF. */
 
-	pLed->bLedBlinkInProgress = false; // true if it is blinking, false o.w..
+	pLed->bLedBlinkInProgress = false; /*  true if it is blinking, false o.w.. */
 	pLed->bLedNoLinkBlinkInProgress = false;
 	pLed->bLedLinkBlinkInProgress = false;
 	pLed->bLedStartToLinkBlinkInProgress = false;
 	pLed->bLedScanBlinkInProgress = false;
 	pLed->bLedWPSBlinkInProgress = false;
-	pLed->BlinkTimes = 0; // Number of times to toggle led state for blinking.
-	pLed->BlinkingLedState = LED_UNKNOWN; // Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are.
+	pLed->BlinkTimes = 0; /*  Number of times to toggle led state for blinking. */
+	pLed->BlinkingLedState = LED_UNKNOWN; /*  Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are. */
 }
 
-//================================================================================
-// LED_819xUsb routines.
-//================================================================================
-
-//
-//	Description:
-//		Initialize an struct LED_871X object.
-//
+/*  */
+/*  LED_819xUsb routines. */
+/*  */
+
+/*  */
+/* 	Description: */
+/* 		Initialize an struct LED_871X object. */
+/*  */
 
 void InitLed871x(struct rtw_adapter *padapter,
 	struct LED_871X *		pLed,
@@ -103,27 +103,27 @@ void InitLed871x(struct rtw_adapter *pad
 }
 
 
-//
-//	Description:
-//		DeInitialize an struct LED_871X object.
-//
+/*  */
+/* 	Description: */
+/* 		DeInitialize an struct LED_871X object. */
+/*  */
 void DeInitLed871x(struct LED_871X *pLed)
 {
-	//call _cancel_workitem_sync(&(pLed->BlinkWorkItem))
-    //before _cancel_timer_ex(&(pLed->BlinkTimer)) to
-    //avoid led timer restarting when driver is removed
+	/* call _cancel_workitem_sync(&(pLed->BlinkWorkItem)) */
+    /* before _cancel_timer_ex(&(pLed->BlinkTimer)) to */
+    /* avoid led timer restarting when driver is removed */
 
 	_cancel_workitem_sync(&(pLed->BlinkWorkItem));
 	_cancel_timer_ex(&(pLed->BlinkTimer));
-	// We should reset bLedBlinkInProgress if we cancel the LedControlTimer, 2005.03.10, by rcnjko.
+	/*  We should reset bLedBlinkInProgress if we cancel the LedControlTimer, 2005.03.10, by rcnjko. */
 	ResetLedStatus(pLed);
 }
 
 
-//
-//	Description:
-//		Turn on LED according to LedPin specified.
-//
+/*  */
+/* 	Description: */
+/* 		Turn on LED according to LedPin specified. */
+/*  */
 
 void SwLedOn(struct rtw_adapter *padapter, struct LED_871X *pLed)
 {
@@ -134,7 +134,6 @@ void SwLedOn(struct rtw_adapter *padapte
 		return;
 	}
 
-	//LedCfg = PlatformEFIORead1Byte(Adapter, LEDCFG);
 
 	switch (pLed->LedPin)
 	{
@@ -143,15 +142,13 @@ void SwLedOn(struct rtw_adapter *padapte
 
 		case LED_PIN_LED0:
 			LedCfg = rtw_read8(padapter, REG_LEDCFG2);
-			rtw_write8(padapter, REG_LEDCFG2, LedCfg&0xf0); // SW control led0 on.
-			//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOn LED0\n"));
+			rtw_write8(padapter, REG_LEDCFG2, LedCfg&0xf0); /*  SW control led0 on. */
 
 			break;
 
 		case LED_PIN_LED1:
 			LedCfg = rtw_read8(padapter, (REG_LEDCFG2 + 1));
-			rtw_write8(padapter, (REG_LEDCFG2 + 1), LedCfg&0x0f); // SW control led1 on.
-			//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOn LED1\n"));
+			rtw_write8(padapter, (REG_LEDCFG2 + 1), LedCfg&0x0f); /*  SW control led1 on. */
 
 			break;
 
@@ -163,10 +160,10 @@ void SwLedOn(struct rtw_adapter *padapte
 }
 
 
-//
-//	Description:
-//		Turn off LED according to LedPin specified.
-//
+/*  */
+/* 	Description: */
+/* 		Turn off LED according to LedPin specified. */
+/*  */
 void SwLedOff(struct rtw_adapter *padapter, struct LED_871X *pLed)
 {
 	u8	LedCfg;
@@ -176,7 +173,6 @@ void SwLedOff(struct rtw_adapter *padapt
              return;
 	}
 
-	//LedCfg = PlatformEFIORead1Byte(Adapter, LEDCFG);
 
 	switch (pLed->LedPin)
 	{
@@ -185,17 +181,15 @@ void SwLedOff(struct rtw_adapter *padapt
 
 		case LED_PIN_LED0:
 			LedCfg = rtw_read8(padapter, REG_LEDCFG2);
-			LedCfg &= 0xf0; // Set to software control.
+			LedCfg &= 0xf0; /*  Set to software control. */
 			rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3));
-			//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOff LED0\n"));
 
 			break;
 
 		case LED_PIN_LED1:
 			LedCfg = rtw_read8(padapter, (REG_LEDCFG2+1));
-			LedCfg &= 0x0f; // Set to software control.
+			LedCfg &= 0x0f; /*  Set to software control. */
 			rtw_write8(padapter, (REG_LEDCFG2+1), (LedCfg|BIT3));
-			//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOff LED1\n"));
 
 			break;
 
@@ -206,18 +200,18 @@ void SwLedOff(struct rtw_adapter *padapt
 	pLed->bLedOn = false;
 }
 
-//
-//	Description:
-//		Implementation of LED blinking behavior.
-//		It toggle off LED and schedule corresponding timer if necessary.
-//
+/*  */
+/* 	Description: */
+/* 		Implementation of LED blinking behavior. */
+/* 		It toggle off LED and schedule corresponding timer if necessary. */
+/*  */
 void SwLedBlink(struct LED_871X *pLed)
 {
 	struct rtw_adapter			*padapter = pLed->padapter;
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	u8				bStopBlinking = false;
 
-	// Change LED according to BlinkingLedState specified.
+	/*  Change LED according to BlinkingLedState specified. */
 	if (pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
@@ -229,7 +223,7 @@ void SwLedBlink(struct LED_871X *pLed)
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
 	}
 
-	// Determine if we shall change LED state again.
+	/*  Determine if we shall change LED state again. */
 	pLed->BlinkTimes--;
 	switch (pLed->CurrLedState)
 	{
@@ -291,13 +285,13 @@ void SwLedBlink(struct LED_871X *pLed)
 	}
 	else
 	{
-		// Assign LED state to toggle.
+		/*  Assign LED state to toggle. */
 		if (pLed->BlinkingLedState == RTW_LED_ON)
 			pLed->BlinkingLedState = RTW_LED_OFF;
 		else
 			pLed->BlinkingLedState = RTW_LED_ON;
 
-		// Schedule a timer to toggle LED state.
+		/*  Schedule a timer to toggle LED state. */
 		switch (pLed->CurrLedState)
 		{
 		case LED_BLINK_NORMAL:
@@ -337,7 +331,7 @@ void SwLedBlink1(struct LED_871X *pLed)
 	if (pHalData->CustomerID == RT_CID_819x_CAMEO)
 		pLed = &(ledpriv->SwLed1);
 
-	// Change LED according to BlinkingLedState specified.
+	/*  Change LED according to BlinkingLedState specified. */
 	if (pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
@@ -511,7 +505,7 @@ void SwLedBlink1(struct LED_871X *pLed)
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			break;
 
-		case LED_BLINK_WPS_STOP:	//WPS success
+		case LED_BLINK_WPS_STOP:	/* WPS success */
 			if (pLed->BlinkingLedState == RTW_LED_ON)
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
@@ -555,7 +549,7 @@ void SwLedBlink2(struct LED_871X *pLed)
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
 	u8					bStopBlinking = false;
 
-	// Change LED according to BlinkingLedState specified.
+	/*  Change LED according to BlinkingLedState specified. */
 	if (pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
@@ -673,7 +667,7 @@ void SwLedBlink3(struct LED_871X *pLed)
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	u8				bStopBlinking = false;
 
-	// Change LED according to BlinkingLedState specified.
+	/*  Change LED according to BlinkingLedState specified. */
 	if (pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
@@ -798,7 +792,7 @@ void SwLedBlink3(struct LED_871X *pLed)
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			break;
 
-		case LED_BLINK_WPS_STOP:	//WPS success
+		case LED_BLINK_WPS_STOP:	/* WPS success */
 			if (pLed->BlinkingLedState == RTW_LED_ON)
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
@@ -840,7 +834,7 @@ void SwLedBlink4(struct LED_871X *pLed)
 	struct LED_871X *		pLed1 = &(ledpriv->SwLed1);
 	u8				bStopBlinking = false;
 
-	// Change LED according to BlinkingLedState specified.
+	/*  Change LED according to BlinkingLedState specified. */
 	if (pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
@@ -978,7 +972,7 @@ void SwLedBlink4(struct LED_871X *pLed)
 			}
 			break;
 
-		case LED_BLINK_WPS_STOP:	//WPS authentication fail
+		case LED_BLINK_WPS_STOP:	/* WPS authentication fail */
 			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
@@ -987,7 +981,7 @@ void SwLedBlink4(struct LED_871X *pLed)
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
 			break;
 
-		case LED_BLINK_WPS_STOP_OVERLAP:	//WPS session overlap
+		case LED_BLINK_WPS_STOP_OVERLAP:	/* WPS session overlap */
 			pLed->BlinkTimes--;
 			if (pLed->BlinkTimes == 0)
 			{
@@ -1032,7 +1026,7 @@ void SwLedBlink5(struct LED_871X *pLed)
 	struct rtw_adapter			*padapter = pLed->padapter;
 	u8				bStopBlinking = false;
 
-	// Change LED according to BlinkingLedState specified.
+	/*  Change LED according to BlinkingLedState specified. */
 	if (pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
@@ -1140,11 +1134,11 @@ void SwLedBlink5(struct LED_871X *pLed)
 
 }
 
-//
-//	Description:
-//		Callback function of LED BlinkTimer,
-//		it just schedules to corresponding BlinkWorkItem.
-//
+/*  */
+/* 	Description: */
+/* 		Callback function of LED BlinkTimer, */
+/* 		it just schedules to corresponding BlinkWorkItem. */
+/*  */
 void
 BlinkTimerCallback(
 	unsigned long data
@@ -1162,11 +1156,11 @@ BlinkTimerCallback(
 }
 
 
-//
-//	Description:
-//		Callback function of LED BlinkWorkItem.
-//		We dispatch acture LED blink action according to LedStrategy.
-//
+/*  */
+/* 	Description: */
+/* 		Callback function of LED BlinkWorkItem. */
+/* 		We dispatch acture LED blink action according to LedStrategy. */
+/*  */
 void BlinkWorkItemCallback(struct work_struct *work)
 {
 	struct LED_871X *	 pLed = container_of(work, struct LED_871X, BlinkWorkItem);
@@ -1211,15 +1205,15 @@ void BlinkWorkItemCallback(struct work_s
 }
 
 
-//================================================================================
-// Default LED behavior.
-//================================================================================
-
-//
-//	Description:
-//		Implement each led action for SW_LED_MODE0.
-//		This is default strategy.
-//
+/*  */
+/*  Default LED behavior. */
+/*  */
+
+/*  */
+/* 	Description: */
+/* 		Implement each led action for SW_LED_MODE0. */
+/* 		This is default strategy. */
+/*  */
 void
 SwLedControlMode0(
 	struct rtw_adapter		*padapter,
@@ -1229,7 +1223,7 @@ SwLedControlMode0(
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 	struct LED_871X *	pLed = &(ledpriv->SwLed1);
 
-	// Decide led state
+	/*  Decide led state */
 	switch (LedAction)
 	{
 	case LED_CTL_TX:
@@ -1335,7 +1329,7 @@ SwLedControlMode0(
 	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
 }
 
- //ALPHA, added by chiyoko, 20090106
+ /* ALPHA, added by chiyoko, 20090106 */
 void
 SwLedControlMode1(
 	struct rtw_adapter		*padapter,
@@ -1471,7 +1465,7 @@ SwLedControlMode1(
 			}
 			break;
 
-		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS: /* wait until xinpin finish */
 		case LED_CTL_START_WPS_BOTTON:
 			 if (pLed->bLedWPSBlinkInProgress ==false)
 			 {
@@ -1606,7 +1600,7 @@ SwLedControlMode1(
 	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
 }
 
- //Arcadyan/Sitecom , added by chiyoko, 20090216
+ /* Arcadyan/Sitecom , added by chiyoko, 20090216 */
 void
 SwLedControlMode2(
 	struct rtw_adapter				*padapter,
@@ -1680,7 +1674,7 @@ SwLedControlMode2(
 			_set_timer(&(pLed->BlinkTimer), 0);
 			break;
 
-		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS: /* wait until xinpin finish */
 		case LED_CTL_START_WPS_BOTTON:
 			if (pLed->bLedWPSBlinkInProgress ==false)
 			{
@@ -1771,7 +1765,7 @@ SwLedControlMode2(
 	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 }
 
-  //COREGA, added by chiyoko, 20090316
+  /* COREGA, added by chiyoko, 20090316 */
  void
  SwLedControlMode3(
 	struct rtw_adapter				*padapter,
@@ -1848,7 +1842,7 @@ SwLedControlMode2(
 			_set_timer(&(pLed->BlinkTimer), 0);
 			break;
 
-		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS: /* wait until xinpin finish */
 		case LED_CTL_START_WPS_BOTTON:
 			if (pLed->bLedWPSBlinkInProgress ==false)
 			{
@@ -1950,7 +1944,7 @@ SwLedControlMode2(
 }
 
 
- //Edimax-Belkin, added by chiyoko, 20090413
+ /* Edimax-Belkin, added by chiyoko, 20090413 */
 void
 SwLedControlMode4(
 	struct rtw_adapter				*padapter,
@@ -2011,7 +2005,7 @@ SwLedControlMode4(
 
 		case LED_CTL_LINK:
 		case LED_CTL_NO_LINK:
-			//LED1 settings
+			/* LED1 settings */
 			if (LedAction == LED_CTL_LINK)
 			{
 				if (pLed1->bLedWPSBlinkInProgress)
@@ -2102,7 +2096,7 @@ SwLedControlMode4(
 			}
 			break;
 
-		case LED_CTL_START_WPS: //wait until xinpin finish
+		case LED_CTL_START_WPS: /* wait until xinpin finish */
 		case LED_CTL_START_WPS_BOTTON:
 			if (pLed1->bLedWPSBlinkInProgress)
 			{
@@ -2148,7 +2142,7 @@ SwLedControlMode4(
 			}
 			break;
 
-		case LED_CTL_STOP_WPS:	//WPS connect success
+		case LED_CTL_STOP_WPS:	/* WPS connect success */
 			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
@@ -2165,7 +2159,7 @@ SwLedControlMode4(
 
 			break;
 
-		case LED_CTL_STOP_WPS_FAIL:		//WPS authentication fail
+		case LED_CTL_STOP_WPS_FAIL:		/* WPS authentication fail */
 			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
@@ -2180,7 +2174,7 @@ SwLedControlMode4(
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 
-			//LED1 settings
+			/* LED1 settings */
 			if (pLed1->bLedWPSBlinkInProgress)
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
 			else
@@ -2195,7 +2189,7 @@ SwLedControlMode4(
 
 			break;
 
-		case LED_CTL_STOP_WPS_FAIL_OVERLAP:	//WPS session overlap
+		case LED_CTL_STOP_WPS_FAIL_OVERLAP:	/* WPS session overlap */
 			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
@@ -2210,7 +2204,7 @@ SwLedControlMode4(
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 
-			//LED1 settings
+			/* LED1 settings */
 			if (pLed1->bLedWPSBlinkInProgress)
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
 			else
@@ -2282,7 +2276,7 @@ SwLedControlMode4(
 
 
 
- //Sercomm-Belkin, added by chiyoko, 20090415
+ /* Sercomm-Belkin, added by chiyoko, 20090415 */
 void
 SwLedControlMode5(
 	struct rtw_adapter				*padapter,
@@ -2301,7 +2295,7 @@ SwLedControlMode5(
 	{
 		case LED_CTL_POWER_ON:
 		case LED_CTL_NO_LINK:
-		case LED_CTL_LINK:	//solid blue
+		case LED_CTL_LINK:	/* solid blue */
 			pLed->CurrLedState = RTW_LED_ON;
 			pLed->BlinkingLedState = RTW_LED_ON;
 
@@ -2370,10 +2364,10 @@ SwLedControlMode5(
 }
 
 
-//
-//	Description:
-//		Dispatch LED action according to pHalData->LedStrategy.
-//
+/*  */
+/* 	Description: */
+/* 		Dispatch LED action according to pHalData->LedStrategy. */
+/*  */
 void
 LedControl871x(
 	struct rtw_adapter				*padapter,
@@ -2390,12 +2384,6 @@ LedControl871x(
 	if (ledpriv->bRegUseLed == false)
 		return;
 
-	//if (!priv->up)
-	//	return;
-
-	//if (priv->bInHctTest)
-	//	return;
-
 	if (	padapter->pwrctrlpriv.rf_pwrstate != rf_on &&
 		(LedAction == LED_CTL_TX || LedAction == LED_CTL_RX ||
 		 LedAction == LED_CTL_SITE_SURVEY ||
@@ -2409,7 +2397,6 @@ LedControl871x(
 	switch (ledpriv->LedStrategy)
 	{
 		case SW_LED_MODE0:
-			//SwLedControlMode0(padapter, LedAction);
 			break;
 
 		case SW_LED_MODE1:
@@ -2439,14 +2426,14 @@ LedControl871x(
 	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("LedStrategy:%d, LedAction %d\n", ledpriv->LedStrategy,LedAction));
 }
 
-//================================================================================
-// Interface to manipulate LED objects.
-//================================================================================
-
-//
-//	Description:
-//		Initialize all struct LED_871X objects.
-//
+/*  */
+/*  Interface to manipulate LED objects. */
+/*  */
+
+/*  */
+/* 	Description: */
+/* 		Initialize all struct LED_871X objects. */
+/*  */
 void rtl8192du_InitSwLeds(struct rtw_adapter	*padapter)
 {
 	struct led_priv *pledpriv = &(padapter->ledpriv);
@@ -2459,10 +2446,10 @@ void rtl8192du_InitSwLeds(struct rtw_ada
 }
 
 
-//
-//	Description:
-//		DeInitialize all LED_819xUsb objects.
-//
+/*  */
+/* 	Description: */
+/* 		DeInitialize all LED_819xUsb objects. */
+/*  */
 void rtl8192du_DeInitSwLeds(struct rtw_adapter *padapter)
 {
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
--- a/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
@@ -54,9 +54,9 @@ int	rtl8192du_init_recv_priv(struct rtw_
 	struct recv_buf *precvbuf;
 
 #ifdef CONFIG_RECV_THREAD_MODE
-	_rtw_init_sema(&precvpriv->recv_sema, 0);//will be removed
-	_rtw_init_sema(&precvpriv->terminate_recvthread_sema, 0);//will be removed
-#endif //CONFIG_RECV_THREAD_MODE
+	_rtw_init_sema(&precvpriv->recv_sema, 0);/* will be removed */
+	_rtw_init_sema(&precvpriv->terminate_recvthread_sema, 0);/* will be removed */
+#endif /* CONFIG_RECV_THREAD_MODE */
 
 	tasklet_init(&precvpriv->recv_tasklet,
 	     (void(*)(unsigned long))rtl8192du_recv_tasklet,
@@ -64,7 +64,7 @@ int	rtl8192du_init_recv_priv(struct rtw_
 
 #ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
 	_rtw_init_queue(&precvpriv->recv_buf_pending_queue);
-#endif	// CONFIG_USE_USB_BUFFER_ALLOC_RX
+#endif	/*  CONFIG_USE_USB_BUFFER_ALLOC_RX */
 
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
 
@@ -76,9 +76,9 @@ int	rtl8192du_init_recv_priv(struct rtw_
 	if (precvpriv->int_in_buf == NULL) {
 		DBG_8192D("alloc_mem for interrupt in endpoint fail !!!!\n");
 	}
-#endif //CONFIG_USB_INTERRUPT_IN_PIPE
+#endif /* CONFIG_USB_INTERRUPT_IN_PIPE */
 
-	//init recv_buf
+	/* init recv_buf */
 	_rtw_init_queue(&precvpriv->free_recv_buf_queue);
 
 	precvpriv->pallocated_recv_buf = rtw_zmalloc(NR_RECVBUFF *sizeof(struct recv_buf) + 4);
@@ -106,10 +106,6 @@ int	rtl8192du_init_recv_priv(struct rtw_
 
 		precvbuf->ref_cnt = 0;
 		precvbuf->adapter =padapter;
-
-
-		//rtw_list_insert_tail(&precvbuf->list, &(precvpriv->free_recv_buf_queue.queue));
-
 		precvbuf++;
 
 	}
@@ -120,7 +116,7 @@ int	rtl8192du_init_recv_priv(struct rtw_
 #ifdef CONFIG_RX_INDICATE_QUEUE
 	memset(&precvpriv->rx_indicate_queue, 0, sizeof(struct ifqueue));
 	mtx_init(&precvpriv->rx_indicate_queue.ifq_mtx, "rx_indicate_queue", NULL, MTX_DEF);
-#endif	// CONFIG_RX_INDICATE_QUEUE
+#endif	/*  CONFIG_RX_INDICATE_QUEUE */
 
 #ifdef CONFIG_PREALLOC_RECV_SKB
 	{
@@ -133,11 +129,11 @@ int	rtl8192du_init_recv_priv(struct rtw_
 
 		for (i=0; i<NR_PREALLOC_RECV_SKB; i++)
 		{
-	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
 			pskb = dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
 	#else
 			pskb = netdev_alloc_skb(padapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
-	#endif //(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
+	#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) */
 
 			if (pskb)
 			{
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -67,7 +67,7 @@ u32 rtw_get_ff_hwaddr(struct xmit_frame
 		case 0x10:
 			addr = BCN_QUEUE_INX;
 			break;
-		case 0x11://BC/MC in PS (HIQ)
+		case 0x11:/* BC/MC in PS (HIQ) */
 			addr = HIGH_QUEUE_INX;
 			break;
 		case 0x12:
@@ -110,11 +110,11 @@ int urb_zero_packet_chk(struct rtw_adapt
 void rtl8192du_cal_txdesc_chksum(struct tx_desc	*ptxdesc)
 {
 		u16	*usPtr = (u16*)ptxdesc;
-		u32 count = 16;		// (32 bytes / 2 bytes per XOR) => 16 times
+		u32 count = 16;		/*  (32 bytes / 2 bytes per XOR) => 16 times */
 		u32 index;
 		u16 checksum = 0;
 
-		//Clear first
+		/* Clear first */
 		ptxdesc->txdw7 &= cpu_to_le32(0xffff0000);
 
 		for (index = 0 ; index < count ; index++) {
@@ -130,14 +130,13 @@ void fill_txdesc_sectype(struct pkt_attr
 	{
 		switch (pattrib->encrypt)
 		{
-			//SEC_TYPE
+			/* SEC_TYPE */
 			case _WEP40_:
 			case _WEP104_:
 					ptxdesc->txdw1 |= cpu_to_le32((0x01<<22)&0x00c00000);
 					break;
 			case _TKIP_:
 			case _TKIP_WTMIC_:
-					//ptxdesc->txdw1 |= cpu_to_le32((0x02<<22)&0x00c00000);
 					ptxdesc->txdw1 |= cpu_to_le32((0x01<<22)&0x00c00000);
 					break;
 			case _AES_:
@@ -154,7 +153,6 @@ void fill_txdesc_sectype(struct pkt_attr
 
 static void fill_txdesc_vcs(struct pkt_attrib *pattrib, u32 *pdw)
 {
-	//DBG_8192D("cvs_mode=%d\n", pattrib->vcs_mode);
 
 	switch (pattrib->vcs_mode)
 	{
@@ -172,7 +170,7 @@ static void fill_txdesc_vcs(struct pkt_a
 	if (pattrib->vcs_mode) {
 		*pdw |= cpu_to_le32(BIT(13));
 
-		// Set RTS BW
+		/*  Set RTS BW */
 		if (pattrib->ht_en)
 		{
 			*pdw |= (pattrib->bwmode&HT_CHANNEL_WIDTH_40)?	cpu_to_le32(BIT(27)):0;
@@ -191,7 +189,6 @@ static void fill_txdesc_vcs(struct pkt_a
 
 static void fill_txdesc_phy(struct pkt_attrib *pattrib, u32 *pdw)
 {
-	//DBG_8192D("bwmode=%d, ch_off=%d\n", pattrib->bwmode, pattrib->ch_offset);
 
 	if (pattrib->ht_en)
 	{
@@ -224,7 +221,6 @@ void InsertEMContent(struct xmit_frame *
 	SET_EARLYMODE_LEN2_2(VirtualAddress, pxmitframe->EMPktLen[2]>>4);
 	SET_EARLYMODE_LEN3(VirtualAddress, pxmitframe->EMPktLen[3]);
 	SET_EARLYMODE_LEN4(VirtualAddress, pxmitframe->EMPktLen[4]);
-	//RT_PRINT_DATA(COMP_SEND, DBG_LOUD, "EM Header:", VirtualAddress, 8)
 }
 
 static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bagg_pkt)
@@ -236,7 +232,7 @@ static s32 update_txdesc(struct xmit_fra
 	struct dm_priv		*pdmpriv = &pHalData->dmpriv;
 #ifdef CONFIG_AP_MODE
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-#endif //CONFIG_AP_MODE
+#endif /* CONFIG_AP_MODE */
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct pkt_attrib		*pattrib = &pxmitframe->attrib;
@@ -245,7 +241,7 @@ static s32 update_txdesc(struct xmit_fra
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
 	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
@@ -259,15 +255,14 @@ if (padapter->registrypriv.mp_mode == 0)
 		pxmitframe->pkt_offset --;
 	}
 }
-#endif	// CONFIG_USE_USB_BUFFER_ALLOC_TX
+#endif	/*  CONFIG_USE_USB_BUFFER_ALLOC_TX */
 
 	memset(ptxdesc, 0, sizeof(struct tx_desc));
 
 	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
 	{
-		//DBG_8192D("pxmitframe->frame_tag == DATA_FRAMETAG\n");
 
-		//offset 4
+		/* offset 4 */
 		ptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id&0x1f);
 
 		qsel = (uint)(pattrib->qsel & 0x0000001f);
@@ -278,10 +273,10 @@ if (padapter->registrypriv.mp_mode == 0)
 		fill_txdesc_sectype(pattrib, ptxdesc);
 
 		if (pattrib->ampdu_en==true) {
-			ptxdesc->txdw1 |= cpu_to_le32(BIT(5));//AGG EN
-			//Insert Early Mode Content after tx desc position.
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(5));/* AGG EN */
+			/* Insert Early Mode Content after tx desc position. */
 			if ((pHalData->bEarlyModeEnable) && (true == bagg_pkt)) {
-				ptxdesc->txdw0 |= cpu_to_le32(((USB_HWDESC_HEADER_LEN-8) << OFFSET_SHT) & 0x00ff0000);//32 bytes for TX Desc
+				ptxdesc->txdw0 |= cpu_to_le32(((USB_HWDESC_HEADER_LEN-8) << OFFSET_SHT) & 0x00ff0000);/* 32 bytes for TX Desc */
 				if (pxmitframe->EMPktNum > 0) {
 					InsertEMContent(pxmitframe, pmem+TXDESC_SIZE);
 				}
@@ -289,47 +284,46 @@ if (padapter->registrypriv.mp_mode == 0)
 		}
 		else
 		{
-			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));//AGG BK
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));/* AGG BK */
 		}
 
-		//offset 8
+		/* offset 8 */
 
 
-		//offset 12
+		/* offset 12 */
 		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
 
 
-		//offset 16 , offset 20
+		/* offset 16 , offset 20 */
 		if (pattrib->qos_en)
-			ptxdesc->txdw4 |= cpu_to_le32(BIT(6));//QoS
+			ptxdesc->txdw4 |= cpu_to_le32(BIT(6));/* QoS */
 
 		if ((pattrib->ether_type != 0x888e) && (pattrib->ether_type != 0x0806) && (pattrib->dhcp_pkt != 1))
 		{
-		//Non EAP & ARP & DHCP type data packet
+		/* Non EAP & ARP & DHCP type data packet */
 
 			fill_txdesc_vcs(pattrib, &ptxdesc->txdw4);
 			fill_txdesc_phy(pattrib, &ptxdesc->txdw4);
 
-			ptxdesc->txdw4 |= cpu_to_le32(0x00000008);//RTS Rate=24M
-			ptxdesc->txdw5 |= cpu_to_le32(0x0001ff00);//
-			//ptxdesc->txdw5 |= cpu_to_le32(0x0000000b);//DataRate - 54M
+			ptxdesc->txdw4 |= cpu_to_le32(0x00000008);/* RTS Rate=24M */
+			ptxdesc->txdw5 |= cpu_to_le32(0x0001ff00);/*  */
 
-			//use REG_INIDATA_RATE_SEL value
+			/* use REG_INIDATA_RATE_SEL value */
 			ptxdesc->txdw5 |= cpu_to_le32(pdmpriv->INIDATA_RATE[pattrib->mac_id]);
 
 		}
 		else
 		{
-			// EAP data packet and ARP packet.
-			// Use the 1M data rate to send the EAP/ARP packet.
-			// This will maybe make the handshake smooth.
+			/*  EAP data packet and ARP packet. */
+			/*  Use the 1M data rate to send the EAP/ARP packet. */
+			/*  This will maybe make the handshake smooth. */
 
-			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));//AGG BK
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));/* AGG BK */
 
-			ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+			ptxdesc->txdw4 |= cpu_to_le32(BIT(8));/* driver uses rate */
 
 			if (pmlmeinfo->preamble_mode == PREAMBLE_SHORT)
-				ptxdesc->txdw4 |= cpu_to_le32(BIT(24));// DATA_SHORT
+				ptxdesc->txdw4 |= cpu_to_le32(BIT(24));/*  DATA_SHORT */
 
 			ptxdesc->txdw5 |= cpu_to_le32(ratetohwrate(pmlmeext->tx_rate));
 		}
@@ -337,20 +331,19 @@ if (padapter->registrypriv.mp_mode == 0)
 #ifdef CONFIG_P2P
 		if (pregistrypriv->wifi_spec==1 && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
-			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));//AGG BK
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));/* AGG BK */
 
-			ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+			ptxdesc->txdw4 |= cpu_to_le32(BIT(8));/* driver uses rate */
 
-			ptxdesc->txdw5 = cpu_to_le32(0x0001ff00);//
+			ptxdesc->txdw5 = cpu_to_le32(0x0001ff00);/*  */
 
-			ptxdesc->txdw5 |= cpu_to_le32(BIT(2));// use OFDM 6Mbps
+			ptxdesc->txdw5 |= cpu_to_le32(BIT(2));/*  use OFDM 6Mbps */
 		}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
-		//offset 24
+		/* offset 24 */
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
 		if (pattrib->hw_tcp_csum == 1) {
-			// ptxdesc->txdw6 = 0; // clear TCP_CHECKSUM and IP_CHECKSUM. It's zero already!!
 			u8 ip_hdr_offset = 32 + pattrib->hdrlen + pattrib->iv_len + 8;
 			ptxdesc->txdw7 = (1 << 31) | (ip_hdr_offset << 16);
 			DBG_8192D("ptxdesc->txdw7 = %08x\n", ptxdesc->txdw7);
@@ -359,9 +352,8 @@ if (padapter->registrypriv.mp_mode == 0)
 	}
 	else if ((pxmitframe->frame_tag&0x0f)== MGNT_FRAMETAG)
 	{
-		//DBG_8192D("pxmitframe->frame_tag == MGNT_FRAMETAG\n");
 
-		//offset 4
+		/* offset 4 */
 		ptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id&0x1f);
 
 		qsel = (uint)(pattrib->qsel&0x0000001f);
@@ -369,35 +361,34 @@ if (padapter->registrypriv.mp_mode == 0)
 
 		ptxdesc->txdw1 |= cpu_to_le32((pattrib->raid<< 16) & 0x000f0000);
 
-		//fill_txdesc_sectype(pattrib, ptxdesc);
 
-		//offset 8
+		/* offset 8 */
 #ifdef CONFIG_XMIT_ACK
-		//CCX-TXRPT ack for xmit mgmt frames.
+		/* CCX-TXRPT ack for xmit mgmt frames. */
 		if (pxmitframe->ack_report) {
 			ptxdesc->txdw2 |= cpu_to_le32(BIT(19));
 			#ifdef DBG_CCX
 			DBG_8192D("%s set ccx\n", __func__);
 			#endif
 		}
-#endif //CONFIG_XMIT_ACK
+#endif /* CONFIG_XMIT_ACK */
 
-		//offset 12
+		/* offset 12 */
 		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
 
-		//offset 16
-		ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+		/* offset 16 */
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(8));/* driver uses rate */
 
-		//offset 20
+		/* offset 20 */
 #ifdef CONFIG_AP_MODE
 		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
-			ptxdesc->txdw5 |= cpu_to_le32(BIT(17));//retry limit enable
+			ptxdesc->txdw5 |= cpu_to_le32(BIT(17));/* retry limit enable */
 #ifdef CONFIG_P2P
 			if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-				ptxdesc->txdw5 |= cpu_to_le32(0x00080000);//retry limit = 2
+				ptxdesc->txdw5 |= cpu_to_le32(0x00080000);/* retry limit = 2 */
 			} else
-#endif //CONFIG_P2P
-				ptxdesc->txdw5 |= cpu_to_le32(0x00180000);//retry limit = 6
+#endif /* CONFIG_P2P */
+				ptxdesc->txdw5 |= cpu_to_le32(0x00180000);/* retry limit = 6 */
 		}
 #endif
 
@@ -407,41 +398,41 @@ if (padapter->registrypriv.mp_mode == 0)
 	} else {
 		DBG_8192D("pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);
 
-		//offset 4
-		ptxdesc->txdw1 |= cpu_to_le32((4)&0x1f);//CAM_ID(MAC_ID)
+		/* offset 4 */
+		ptxdesc->txdw1 |= cpu_to_le32((4)&0x1f);/* CAM_ID(MAC_ID) */
 
-		ptxdesc->txdw1 |= cpu_to_le32((6<< 16) & 0x000f0000);//raid
+		ptxdesc->txdw1 |= cpu_to_le32((6<< 16) & 0x000f0000);/* raid */
 
-		//offset 8
+		/* offset 8 */
 
-		//offset 12
+		/* offset 12 */
 		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
 
-		//offset 16
-		ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+		/* offset 16 */
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(8));/* driver uses rate */
 
-		//offset 20
+		/* offset 20 */
 		ptxdesc->txdw5 |= cpu_to_le32(ratetohwrate(pmlmeext->tx_rate));
 	}
 
-	// 2009.11.05. tynli_test. Suggested by SD4 Filen for FW LPS.
-	// (1) The sequence number of each non-Qos frame / broadcast / multicast /
-	// mgnt frame should be controled by Hw because Fw will also send null data
-	// which we cannot control when Fw LPS enable.
-	// --> default enable non-Qos data sequense number. 2010.06.23. by tynli.
-	// (2) Enable HW SEQ control for beacon packet, because we use Hw beacon.
-	// (3) Use HW Qos SEQ to control the seq num of Ext port non-Qos packets.
-	// 2010.06.23. Added by tynli.
+	/*  2009.11.05. tynli_test. Suggested by SD4 Filen for FW LPS. */
+	/*  (1) The sequence number of each non-Qos frame / broadcast / multicast / */
+	/*  mgnt frame should be controled by Hw because Fw will also send null data */
+	/*  which we cannot control when Fw LPS enable. */
+	/*  --> default enable non-Qos data sequense number. 2010.06.23. by tynli. */
+	/*  (2) Enable HW SEQ control for beacon packet, because we use Hw beacon. */
+	/*  (3) Use HW Qos SEQ to control the seq num of Ext port non-Qos packets. */
+	/*  2010.06.23. Added by tynli. */
 	if (!pattrib->qos_en)
 	{
-		ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); // Hw set sequence number
-		ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); //set bit3 to 1. Suugested by TimChen. 2009.12.29.
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); /*  Hw set sequence number */
+		ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); /* set bit3 to 1. Suugested by TimChen. 2009.12.29. */
 	}
 
-	//offset 0
+	/* offset 0 */
 	ptxdesc->txdw0 |= cpu_to_le32(sz&0x0000ffff);
 	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
-	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);//32 bytes for TX Desc
+	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);/* 32 bytes for TX Desc */
 
 	if (bmcst)
 	{
@@ -450,8 +441,8 @@ if (padapter->registrypriv.mp_mode == 0)
 
 	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("offset0-txdesc=0x%x\n", ptxdesc->txdw0));
 
-	//offset 4
-	// pkt_offset, unit:8 bytes padding
+	/* offset 4 */
+	/*  pkt_offset, unit:8 bytes padding */
 	if (pxmitframe->pkt_offset > 0)
 		ptxdesc->txdw1 |= cpu_to_le32((pxmitframe->pkt_offset << 26) & 0x7c000000);
 
@@ -480,7 +471,7 @@ s32 rtw_dump_xframe(struct rtw_adapter *
 	struct sta_priv		*pstapriv = &padapter->stapriv;
 	struct sta_info *ptdls_sta=NULL, *psta_backup=NULL;
 	u8 ra_backup[6];
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	if ((pxmitframe->frame_tag == DATA_FRAMETAG) &&
 	    (pxmitframe->attrib.ether_type != 0x0806) &&
@@ -499,7 +490,7 @@ s32 rtw_dump_xframe(struct rtw_adapter *
 			pattrib->psta = psta_backup;
 			memcpy(pattrib->ra, ra_backup, ETH_ALEN);
 		}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 		rtw_issue_addbareq_cmd(padapter, pxmitframe);
 	}
 
@@ -519,7 +510,7 @@ s32 rtw_dump_xframe(struct rtw_adapter *
 			sz = pxmitpriv->frag_len;
 			sz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 : pattrib->icv_len);
 		}
-		else //no frag
+		else /* no frag */
 		{
 			sz = pattrib->last_txcmdsz;
 		}
@@ -528,9 +519,8 @@ s32 rtw_dump_xframe(struct rtw_adapter *
 
 		if (pull)
 		{
-			mem_addr += PACKET_OFFSET_SZ; //pull txdesc head
+			mem_addr += PACKET_OFFSET_SZ; /* pull txdesc head */
 
-			//pxmitbuf ->pbuf = mem_addr;
 			pxmitframe->buf_addr = mem_addr;
 
 			w_sz = sz + TXDESC_SIZE;
@@ -548,7 +538,6 @@ s32 rtw_dump_xframe(struct rtw_adapter *
 
 
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_write_port, w_sz=%d\n", w_sz));
-		//DBG_8192D("rtw_write_port, w_sz=%d, sz=%d, txdesc_sz=%d, tid=%d\n", w_sz, sz, w_sz-sz, pattrib->priority);
 
 		mem_addr += w_sz;
 
@@ -572,7 +561,7 @@ static u32 xmitframe_need_length(struct
 
 	u32	len = 0;
 
-	// no consider fragement
+	/*  no consider fragement */
 	len = pattrib->hdrlen + pattrib->iv_len +
 		SNAP_SIZE + sizeof(u16) +
 		pattrib->pktlen +
@@ -591,13 +580,13 @@ void UpdateEarlyModeInfo8192D(struct rtw
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	struct list_head *xmitframe_plist = NULL, *xmitframe_phead = NULL;
 
-	//Some macaddr can't do early mode.
+	/* Some macaddr can't do early mode. */
 	if (MacAddr_isBcst(pattrib->dst) ||IS_MCAST(pattrib->dst) || !!pattrib->qos_en)
 		return;
 
 	pxmitframe->EMPktNum = 0;
 
-	// dequeue same priority packet from station tx queue
+	/*  dequeue same priority packet from station tx queue */
 	spin_lock_bh(&pxmitpriv->lock);
 
 	xmitframe_phead = get_list_head(&ptxservq->sta_pending);
@@ -614,31 +603,31 @@ void UpdateEarlyModeInfo8192D(struct rtw
 	spin_unlock_bh(&pxmitpriv->lock);
 }
 
-#define IDEA_CONDITION 1	// check all packets before enqueue
+#define IDEA_CONDITION 1	/*  check all packets before enqueue */
 s32 rtl8192du_xmitframe_complete(struct rtw_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
 {
 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(padapter);
 	struct xmit_frame *pxmitframe = NULL;
 	struct xmit_frame *pfirstframe = NULL;
 
-	// aggregate variable
+	/*  aggregate variable */
 	struct hw_xmit	*phwxmit = pxmitpriv->hwxmits;
 	struct tx_servq	*ptxservq = NULL;
 
 	struct list_head *xmitframe_plist = NULL, *xmitframe_phead = NULL;
 
-	u32	pbuf=0; // next pkt address
-	u32	pbuf_tail; // last pkt tail
-	u32	len=0; //packet length, except TXDESC_SIZE and PKT_OFFSET
+	u32	pbuf=0; /*  next pkt address */
+	u32	pbuf_tail; /*  last pkt tail */
+	u32	len=0; /* packet length, except TXDESC_SIZE and PKT_OFFSET */
 	u32	aggMaxLength = MAX_XMITBUF_SZ;
 	u32	bulkSize = pHalData->UsbBulkOutSize;
 	u32	bulkPtr=0;
 	u8	descCount=0;
 	u8	ac_index;
-	u8	bfirst = true;//first aggregation xmitframe
+	u8	bfirst = true;/* first aggregation xmitframe */
 	u8	bulkstart = false;
 
-	// dump frame variable
+	/*  dump frame variable */
 	u32 ff_hwaddr;
 
 #ifndef IDEA_CONDITION
@@ -647,7 +636,7 @@ s32 rtl8192du_xmitframe_complete(struct
 
 	RT_TRACE(_module_rtl8192c_xmit_c_, _drv_info_, ("+xmitframe_complete\n"));
 
-	// check xmitbuffer is ok
+	/*  check xmitbuffer is ok */
 	if (pxmitbuf == NULL) {
 		pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
 		if (pxmitbuf == NULL) return false;
@@ -659,12 +648,12 @@ s32 rtl8192du_xmitframe_complete(struct
 		aggMaxLength = 0x3D00;
 
 	do {
-		//3 1. pick up first frame
+		/* 3 1. pick up first frame */
 		if (bfirst)
 		{
 			pxmitframe = rtw_dequeue_xframe(pxmitpriv, pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);
 			if (pxmitframe == NULL) {
-				// no more xmit frame, release xmit buffer
+				/*  no more xmit frame, release xmit buffer */
 				rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
 				return false;
 			}
@@ -673,18 +662,17 @@ s32 rtl8192du_xmitframe_complete(struct
 			pxmitframe->buf_addr = pxmitbuf->pbuf;
 			pxmitbuf->priv_data = pxmitframe;
 
-			//pxmitframe->agg_num = 1; // alloc xmitframe should assign to 1.
-			pxmitframe->pkt_offset = USB_92D_DUMMY_OFFSET; // first frame of aggregation, reserve 2 offset for 512 alignment and early mode
+			pxmitframe->pkt_offset = USB_92D_DUMMY_OFFSET; /*  first frame of aggregation, reserve 2 offset for 512 alignment and early mode */
 
 			pfirstframe = pxmitframe;
 			spin_lock_bh(&pxmitpriv->lock);
 			ptxservq = rtw_get_sta_pending(padapter, pfirstframe->attrib.psta, pfirstframe->attrib.priority, (u8 *)(&ac_index));
 			spin_unlock_bh(&pxmitpriv->lock);
 		}
-		//3 2. aggregate same priority and same DA(AP or STA) frames
+		/* 3 2. aggregate same priority and same DA(AP or STA) frames */
 		else
 		{
-			// dequeue same priority packet from station tx queue
+			/*  dequeue same priority packet from station tx queue */
 			spin_lock_bh(&pxmitpriv->lock);
 
 			if (_rtw_queue_empty(&ptxservq->sta_pending) == false)
@@ -706,7 +694,7 @@ s32 rtl8192du_xmitframe_complete(struct
 					ptxservq->qcnt--;
 					phwxmit[ac_index].accnt--;
 
-					//Remove sta node when there is no pending packets.
+					/* Remove sta node when there is no pending packets. */
 					if (_rtw_queue_empty(&ptxservq->sta_pending) == true)
 						rtw_list_delete(&ptxservq->tx_pending);
 				}
@@ -725,8 +713,8 @@ s32 rtl8192du_xmitframe_complete(struct
 
 			pxmitframe->buf_addr = pxmitbuf->pbuf + pbuf;
 
-			pxmitframe->agg_num = 0; // not first frame of aggregation
-			pxmitframe->pkt_offset = USB_92D_DUMMY_OFFSET - 1; // not first frame of aggregation, reserve 1 offset for early mode
+			pxmitframe->agg_num = 0; /*  not first frame of aggregation */
+			pxmitframe->pkt_offset = USB_92D_DUMMY_OFFSET - 1; /*  not first frame of aggregation, reserve 1 offset for early mode */
 		}
 
 		if (pHalData->bEarlyModeEnable)
@@ -742,7 +730,7 @@ s32 rtl8192du_xmitframe_complete(struct
 		}
 #endif
 
-		// always return ndis_packet after rtw_xmitframe_coalesce
+		/*  always return ndis_packet after rtw_xmitframe_coalesce */
 		rtw_os_xmit_complete(padapter, pxmitframe);
 
 		if (bfirst)
@@ -759,10 +747,10 @@ s32 rtl8192du_xmitframe_complete(struct
 		{
 			update_txdesc(pxmitframe, pxmitframe->buf_addr, pxmitframe->attrib.last_txcmdsz, true);
 
-			// don't need xmitframe any more
+			/*  don't need xmitframe any more */
 			rtw_free_xmitframe(pxmitpriv, pxmitframe);
 
-			// handle pointer and stop condition
+			/*  handle pointer and stop condition */
 			pbuf_tail = pbuf + len;
 			pbuf = _RND8(pbuf_tail);
 
@@ -771,7 +759,7 @@ s32 rtl8192du_xmitframe_complete(struct
 				break;
 		}
 
-		// check pkt amount in one bluk
+		/*  check pkt amount in one bluk */
 		if (pbuf < bulkPtr)
 		{
 			descCount++;
@@ -781,7 +769,7 @@ s32 rtl8192du_xmitframe_complete(struct
 		else
 		{
 			descCount = 0;
-			bulkPtr = ((pbuf / bulkSize) + 1) * bulkSize; // round to next bulkSize
+			bulkPtr = ((pbuf / bulkSize) + 1) * bulkSize; /*  round to next bulkSize */
 		}
 	} while (1);
 
@@ -793,25 +781,23 @@ s32 rtl8192du_xmitframe_complete(struct
 	}
 
 #ifndef CONFIG_USE_USB_BUFFER_ALLOC_TX
-	//3 3. update first frame txdesc
+	/* 3 3. update first frame txdesc */
 	if ((pbuf_tail % bulkSize) == 0) {
-		// remove 1 pkt_offset
+		/*  remove 1 pkt_offset */
 		pbuf_tail -= PACKET_OFFSET_SZ;
 		pfirstframe->buf_addr += PACKET_OFFSET_SZ;
 		pfirstframe->pkt_offset--;
 	}
-#endif	// CONFIG_USE_USB_BUFFER_ALLOC_TX
+#endif	/*  CONFIG_USE_USB_BUFFER_ALLOC_TX */
 	update_txdesc(pfirstframe, pfirstframe->buf_addr, pfirstframe->attrib.last_txcmdsz, true);
 
-	//3 4. write xmit buffer to USB FIFO
+	/* 3 4. write xmit buffer to USB FIFO */
 	ff_hwaddr = rtw_get_ff_hwaddr(pfirstframe);
 
-	// xmit address == ((xmit_frame*)pxmitbuf->priv_data)->buf_addr
 	rtw_write_port(padapter, ff_hwaddr, pbuf_tail, (u8*)pxmitbuf);
 
-	//3 5. update statisitc
+	/* 3 5. update statisitc */
 	pbuf_tail -= (pfirstframe->agg_num * TXDESC_SIZE);
-	//if (pfirstframe->pkt_offset == 1) pbuf_tail -= PACKET_OFFSET_SZ;
 	pbuf_tail -= (pfirstframe->pkt_offset * PACKET_OFFSET_SZ);
 
 	rtw_count_tx_stats(padapter, pfirstframe, pbuf_tail);
@@ -859,12 +845,12 @@ s32 rtl8192du_xmitframe_complete(struct
 
 			if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
 			{
-				if (pxmitframe->attrib.priority<=15)//TID0~15
+				if (pxmitframe->attrib.priority<=15)/* TID0~15 */
 				{
 					res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
 				}
 
-				rtw_os_xmit_complete(padapter, pxmitframe);//always return ndis_packet after rtw_xmitframe_coalesce
+				rtw_os_xmit_complete(padapter, pxmitframe);/* always return ndis_packet after rtw_xmitframe_coalesce */
 			}
 
 
@@ -942,7 +928,7 @@ static s32 pre_xmitframe(struct rtw_adap
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
 		goto enqueue;
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 	pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
 	if (pxmitbuf == NULL)
@@ -969,7 +955,7 @@ enqueue:
 		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("pre_xmitframe: enqueue xmitframe fail\n"));
 		rtw_free_xmitframe(pxmitpriv, pxmitframe);
 
-		// Trick, make the statistics correct
+		/*  Trick, make the statistics correct */
 		pxmitpriv->tx_pkts--;
 		pxmitpriv->tx_drop++;
 		return true;
@@ -1017,11 +1003,7 @@ s32 rtl8192du_hostap_mgnt_xmit_entry(str
 	struct hal_data_8192du  *pHalData = GET_HAL_DATA(padapter);
 	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
 
-
-	//DBG_8192D("%s\n", __func__);
-
 	skb = pkt;
-
 	len = skb->len;
 	tx_hdr = (struct rtw_ieee80211_hdr *)(skb->data);
 	fc = le16_to_cpu(tx_hdr->frame_ctl);
@@ -1030,7 +1012,7 @@ s32 rtl8192du_hostap_mgnt_xmit_entry(str
 	if ((fc & RTW_IEEE80211_FCTL_FTYPE) != RTW_IEEE80211_FTYPE_MGMT)
 		goto _exit;
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
 	pxmit_skb = dev_alloc_skb(len + TXDESC_SIZE);
 #else
 	pxmit_skb = netdev_alloc_skb(pnetdev, len + TXDESC_SIZE);
@@ -1045,13 +1027,13 @@ s32 rtl8192du_hostap_mgnt_xmit_entry(str
 		goto _exit;
 	}
 
-	// ----- fill tx desc -----
+	/*  ----- fill tx desc ----- */
 	ptxdesc = (struct tx_desc *)pxmitbuf;
 	memset(ptxdesc, 0, sizeof(*ptxdesc));
 
-	//offset 0
+	/* offset 0 */
 	ptxdesc->txdw0 |= cpu_to_le32(len&0x0000ffff);
-	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);//default = 32 bytes for TX Desc
+	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);/* default = 32 bytes for TX Desc */
 	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
 
 	if (bmcst)
@@ -1059,44 +1041,42 @@ s32 rtl8192du_hostap_mgnt_xmit_entry(str
 		ptxdesc->txdw0 |= cpu_to_le32(BIT(24));
 	}
 
-	//offset 4
-	ptxdesc->txdw1 |= cpu_to_le32(0x00);//MAC_ID
+	/* offset 4 */
+	ptxdesc->txdw1 |= cpu_to_le32(0x00);/* MAC_ID */
 
 	ptxdesc->txdw1 |= cpu_to_le32((0x12<<QSEL_SHT)&0x00001f00);
 
-	ptxdesc->txdw1 |= cpu_to_le32((0x06<< 16) & 0x000f0000);//b mode
+	ptxdesc->txdw1 |= cpu_to_le32((0x06<< 16) & 0x000f0000);/* b mode */
 
-	//offset 8
+	/* offset 8 */
 
-	//offset 12
+	/* offset 12 */
 	ptxdesc->txdw3 |= cpu_to_le32((le16_to_cpu(tx_hdr->seq_ctl)<<16)&0xffff0000);
 
-	//offset 16
-	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+	/* offset 16 */
+	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));/* driver uses rate */
 
-	//offset 20
+	/* offset 20 */
 
 
-	//HW append seq
-	ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); // Hw set sequence number
-	ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); //set bit3 to 1. Suugested by TimChen. 2009.12.29.
+	/* HW append seq */
+	ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); /*  Hw set sequence number */
+	ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); /* set bit3 to 1. Suugested by TimChen. 2009.12.29. */
 
 
 	rtl8192cu_cal_txdesc_chksum(ptxdesc);
-	// ----- end of fill tx desc -----
+	/*  ----- end of fill tx desc ----- */
 
-	//
+	/*  */
 	skb_put(pxmit_skb, len + TXDESC_SIZE);
 	pxmitbuf = pxmitbuf + TXDESC_SIZE;
 	memcpy(pxmitbuf, skb->data, len);
 
-	//DBG_8192D("mgnt_xmit, len=%x\n", pxmit_skb->len);
 
 
-	// ----- prepare urb for submit -----
+	/*  ----- prepare urb for submit ----- */
 
-	//translate DMA FIFO addr to pipehandle
-	//pipe = ffaddr2pipehdl(pdvobj, MGT_QUEUE_INX);
+	/* translate DMA FIFO addr to pipehandle */
 	pipe = usb_sndbulkpipe(pdvobj->pusbdev, pHalData->Queue2EPNum[(u8)MGT_QUEUE_INX]&0x0f);
 	usb_fill_bulk_urb(urb, pdvobj->pusbdev, pipe,
 		pxmit_skb->data, pxmit_skb->len, rtl8192cu_hostap_mgnt_xmit_cb, pxmit_skb);
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -42,8 +42,8 @@
 	#define		HAL_RF_ENABLE		1
 #endif
 
-//add mutex to solve the problem that reading efuse and power on/fw download do
-//on the same time
+/* add mutex to solve the problem that reading efuse and power on/fw download do */
+/* on the same time */
 extern atomic_t GlobalMutexForMac0_2G_Mac1_5G;
 extern atomic_t GlobalMutexForPowerAndEfuse;
 extern atomic_t GlobalMutexForPowerOnAndPowerOff;
@@ -53,12 +53,12 @@ extern bool GlobalFirstConfigurationForN
 #endif
 
 
-//endpoint number 1,2,3,4,5
-// bult in : 1
-// bult out: 2 (High)
-// bult out: 3 (Normal) for 3 out_ep, (Low) for 2 out_ep
-// interrupt in: 4
-// bult out: 5 (Low) for 3 out_ep
+/* endpoint number 1,2,3,4,5 */
+/*  bult in : 1 */
+/*  bult out: 2 (High) */
+/*  bult out: 3 (Normal) for 3 out_ep, (Low) for 2 out_ep */
+/*  interrupt in: 4 */
+/*  bult out: 5 (Low) for 3 out_ep */
 
 
 static void
@@ -66,17 +66,17 @@ _OneOutEpMapping(
 	struct hal_data_8192du *pHalData
 	)
 {
-	//only endpoint number 0x02
+	/* only endpoint number 0x02 */
 
-	pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];//VO
-	pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[0];//VI
-	pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[0];//BE
-	pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[0];//BK
-
-	pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];//TS
-	pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];//MGT
-	pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];//BMC
-	pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];//BCN
+	pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];/* VO */
+	pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[0];/* VI */
+	pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[0];/* BE */
+	pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[0];/* BK */
+
+	pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];/* TS */
+	pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];/* MGT */
+	pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];/* BMC */
+	pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];/* BCN */
 }
 
 
@@ -87,39 +87,39 @@ _TwoOutEpMapping(
 	)
 {
 
-	if (bWIFICfg) { // Normal chip && wmm
+	if (bWIFICfg) { /*  Normal chip && wmm */
 
-		//	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA
-		//{  0,		1,	0,	1,	0,	0,	0,	0,		0	};
-		//0:H(end_number=0x02), 1:L (end_number=0x03)
+		/* 	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA */
+		/*   0,		1,	0,	1,	0,	0,	0,	0,		0	}; */
+		/* 0:H(end_number=0x02), 1:L (end_number=0x03) */
 
-		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[1];//VO
-		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[0];//VI
-		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[1];//BE
-		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[0];//BK
+		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[1];/* VO */
+		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[0];/* VI */
+		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[1];/* BE */
+		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[0];/* BK */
 
-		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];//TS
-		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];//MGT
-		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];//BMC
-		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];//BCN
+		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];/* TS */
+		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];/* MGT */
+		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];/* BMC */
+		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];/* BCN */
 
 	}
-	else {//typical setting
+	else {/* typical setting */
 
 
-		//BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA
-		//{  1,		1,	0,	0,	0,	0,	0,	0,		0	};
-		//0:H(end_number=0x02), 1:L (end_number=0x03)
+		/* BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA */
+		/*   1,		1,	0,	0,	0,	0,	0,	0,		0	}; */
+		/* 0:H(end_number=0x02), 1:L (end_number=0x03) */
 
-		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];//VO
-		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[0];//VI
-		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[1];//BE
-		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[1];//BK
+		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];/* VO */
+		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[0];/* VI */
+		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[1];/* BE */
+		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[1];/* BK */
 
-		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];//TS
-		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];//MGT
-		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];//BMC
-		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];//BCN
+		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];/* TS */
+		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];/* MGT */
+		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];/* BMC */
+		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];/* BCN */
 
 	}
 }
@@ -130,39 +130,39 @@ static void _ThreeOutEpMapping(
 	bool			bWIFICfg
 	)
 {
-	if (bWIFICfg) {//for WMM
+	if (bWIFICfg) {/* for WMM */
 
-		//	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA
-		//{  1,		2,	1,	0,	0,	0,	0,	0,		0	};
-		//0:H(end_number=0x02), 1:N(end_number=0x03), 2:L (end_number=0x05)
+		/* 	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA */
+		/*   1,		2,	1,	0,	0,	0,	0,	0,		0	}; */
+		/* 0:H(end_number=0x02), 1:N(end_number=0x03), 2:L (end_number=0x05) */
 
-		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];//VO
-		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[1];//VI
-		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[2];//BE
-		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[1];//BK
+		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];/* VO */
+		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[1];/* VI */
+		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[2];/* BE */
+		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[1];/* BK */
 
-		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];//TS
-		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];//MGT
-		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];//BMC
-		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];//BCN
+		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];/* TS */
+		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];/* MGT */
+		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];/* BMC */
+		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];/* BCN */
 
 	}
-	else {//typical setting
+	else {/* typical setting */
 
 
-		//	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA
-		//{  2,		2,	1,	0,	0,	0,	0,	0,		0	};
-		//0:H(end_number=0x02), 1:N(end_number=0x03), 2:L (end_number=0x05)
+		/* 	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA */
+		/*   2,		2,	1,	0,	0,	0,	0,	0,		0	}; */
+		/* 0:H(end_number=0x02), 1:N(end_number=0x03), 2:L (end_number=0x05) */
 
-		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];//VO
-		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[1];//VI
-		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[2];//BE
-		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[2];//BK
+		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];/* VO */
+		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[1];/* VI */
+		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[2];/* BE */
+		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[2];/* BK */
 
-		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];//TS
-		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];//MGT
-		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];//BMC
-		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];//BCN
+		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];/* TS */
+		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];/* MGT */
+		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];/* BMC */
+		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];/* BCN */
 	}
 }
 
@@ -210,7 +210,7 @@ _ConfigChipOutEP(
 	pHalData->OutEpQueueSel = 0;
 	pHalData->OutEpNumber = 0;
 
-	// Normal and High queue
+	/*  Normal and High queue */
 	if (pHalData->interfaceIndex==0)
 		value8=rtw_read8(pAdapter, REG_USB_High_NORMAL_Queue_Select_MAC0);
 	else
@@ -226,7 +226,7 @@ _ConfigChipOutEP(
 		pHalData->OutEpNumber++;
 	}
 
-	// Low queue
+	/*  Low queue */
 	if (pHalData->interfaceIndex==0)
 		value8=rtw_read8(pAdapter, (REG_USB_High_NORMAL_Queue_Select_MAC0+1));
 	else
@@ -237,7 +237,7 @@ _ConfigChipOutEP(
 		pHalData->OutEpNumber++;
 	}
 
-	//add for 0xfe44 0xfe45 0xfe47 0xfe48 not validly
+	/* add for 0xfe44 0xfe45 0xfe47 0xfe48 not validly */
 	switch (NumOutPipe) {
 		case 3:
 			pHalData->OutEpQueueSel=TX_SELE_HQ| TX_SELE_LQ|TX_SELE_NQ;
@@ -255,8 +255,8 @@ _ConfigChipOutEP(
 			break;
 	}
 
-	// TODO: Error recovery for this case
-	//RT_ASSERT((NumOutPipe == pHalData->OutEpNumber), ("Out EP number isn't match! %d(Descriptor) != %d (SIE reg)\n", (u4Byte)NumOutPipe, (u4Byte)pHalData->OutEpNumber));
+	/*  TODO: Error recovery for this case */
+	/* RT_ASSERT((NumOutPipe == pHalData->OutEpNumber), ("Out EP number isn't match! %d(Descriptor) != %d (SIE reg)\n", (u4Byte)NumOutPipe, (u4Byte)pHalData->OutEpNumber)); */
 }
 
 static bool HalUsbSetQueuePipeMapping8192DUsb(
@@ -270,7 +270,7 @@ static bool HalUsbSetQueuePipeMapping819
 
 	_ConfigChipOutEP(pAdapter, NumOutPipe);
 
-	// Normal chip with one IN and one OUT doesn't have interrupt IN EP.
+	/*  Normal chip with one IN and one OUT doesn't have interrupt IN EP. */
 	if (1 == pHalData->OutEpNumber) {
 		if (1 != NumInPipe) {
 			return result;
@@ -289,11 +289,11 @@ void rtl8192du_interface_configure(struc
 
 	if (pdvobjpriv->ishighspeed == true)
 	{
-		pHalData->UsbBulkOutSize = USB_HIGH_SPEED_BULK_SIZE;//512 bytes
+		pHalData->UsbBulkOutSize = USB_HIGH_SPEED_BULK_SIZE;/* 512 bytes */
 	}
 	else
 	{
-		pHalData->UsbBulkOutSize = USB_FULL_SPEED_BULK_SIZE;//64 bytes
+		pHalData->UsbBulkOutSize = USB_FULL_SPEED_BULK_SIZE;/* 64 bytes */
 	}
 
 	pHalData->interfaceIndex = pdvobjpriv->InterfaceNumber;
@@ -302,19 +302,18 @@ void rtl8192du_interface_configure(struc
 	pHalData->RtBulkOutPipe[1] = pdvobjpriv->ep_num[2];
 	pHalData->RtIntInPipe = pdvobjpriv->ep_num[3];
 	pHalData->RtBulkOutPipe[2] = pdvobjpriv->ep_num[4];
-	//DBG_8192D("Bulk In = %x, Bulk Out = %x %x %x\n",pHalData->RtBulkInPipe, pHalData->RtBulkOutPipe[0],pHalData->RtBulkOutPipe[1],pHalData->RtBulkOutPipe[2]);
+	/* DBG_8192D("Bulk In = %x, Bulk Out = %x %x %x\n",pHalData->RtBulkInPipe, pHalData->RtBulkOutPipe[0],pHalData->RtBulkOutPipe[1],pHalData->RtBulkOutPipe[2]); */
 #ifdef CONFIG_USB_TX_AGGREGATION
 	pHalData->UsbTxAggMode		= 1;
-	pHalData->UsbTxAggDescNum	= 0x4;	// only 4 bits
+	pHalData->UsbTxAggDescNum	= 0x4;	/*  only 4 bits */
 #endif
 
 #ifdef CONFIG_USB_RX_AGGREGATION
-	//pHalData->UsbRxAggMode = USB_RX_AGG_DMA_USB;// USB_RX_AGG_DMA;
-	pHalData->UsbRxAggMode = USB_RX_AGG_DMA;// USB_RX_AGG_DMA;
-	pHalData->UsbRxAggBlockCount	= 8; //unit : 512b
+	pHalData->UsbRxAggMode = USB_RX_AGG_DMA;/*  USB_RX_AGG_DMA; */
+	pHalData->UsbRxAggBlockCount	= 8; /* unit : 512b */
 	pHalData->UsbRxAggBlockTimeout = 0x6;
-	pHalData->UsbRxAggPageCount	= 48; //uint :128 b //0x0A;	// 10 = MAX_RX_DMA_BUFFER_SIZE/2/pHalData->UsbBulkOutSize
-	pHalData->UsbRxAggPageTimeout = 0x6; //6, absolute time = 34ms/(2^6)
+	pHalData->UsbRxAggPageCount	= 48; /* uint :128 b 0x0A;	10 = MAX_RX_DMA_BUFFER_SIZE/2/pHalData->UsbBulkOutSize */
+	pHalData->UsbRxAggPageTimeout = 0x6; /* 6, absolute time = 34ms/(2^6) */
 #endif
 
 	HalUsbSetQueuePipeMapping8192DUsb(padapter,
@@ -326,9 +325,9 @@ static u8 _InitPowerOn(struct rtw_adapte
 	u8	ret = _SUCCESS;
 	u16	value16=0;
 	u8	value8 = 0;
-//	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
+/* 	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter); */
 
-	// polling autoload done.
+	/*  polling autoload done. */
 	u32	pollingCount = 0;
 
 	if (padapter->bSurpriseRemoved) {
@@ -339,37 +338,37 @@ static u8 _InitPowerOn(struct rtw_adapte
 	do
 	{
 		if (rtw_read8(padapter, REG_APS_FSMCO) & PFM_ALDN) {
-			//RT_TRACE(COMP_INIT,DBG_LOUD,("Autoload Done!\n"));
+			/* RT_TRACE(COMP_INIT,DBG_LOUD,("Autoload Done!\n")); */
 			break;
 		}
 
 		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT) {
-			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling REG_APS_FSMCO[PFM_ALDN] done!\n"));
+			/* RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling REG_APS_FSMCO[PFM_ALDN] done!\n")); */
 			return _FAIL;
 		}
 
 	}while (true);
 
 
-	//For hardware power on sequence.
-	//0.	RSV_CTRL 0x1C[7:0] = 0x00			// unlock ISO/CLK/Power control register
+	/* For hardware power on sequence. */
+	/* 0.	RSV_CTRL 0x1C[7:0] = 0x00			unlock ISO/CLK/Power control register */
 	rtw_write8(padapter, REG_RSV_CTRL, 0x0);
-	// Power on when re-enter from IPS/Radio off/card disable
-	rtw_write8(padapter, REG_SPS0_CTRL, 0x2b);//enable SPS into PWM mode
-	rtw_usleep_os(100);//PlatformSleepUs(150);//this is not necessary when initially power on
+	/*  Power on when re-enter from IPS/Radio off/card disable */
+	rtw_write8(padapter, REG_SPS0_CTRL, 0x2b);/* enable SPS into PWM mode */
+	rtw_usleep_os(100);/* PlatformSleepUs(150);this is not necessary when initially power on */
 
 	value8 = rtw_read8(padapter, REG_LDOV12D_CTRL);
 	if (0== (value8 & LDV12_EN)) {
 		value8 |= LDV12_EN;
 		rtw_write8(padapter, REG_LDOV12D_CTRL, value8);
-		//RT_TRACE(COMP_INIT, DBG_LOUD, (" power-on :REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8));
-		rtw_usleep_os(100);//PlatformSleepUs(100);//this is not necessary when initially power on
+		/* RT_TRACE(COMP_INIT, DBG_LOUD, (" power-on :REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8)); */
+		rtw_usleep_os(100);/* PlatformSleepUs(100);this is not necessary when initially power on */
 		value8 = rtw_read8(padapter, REG_SYS_ISO_CTRL);
 		value8 &= ~ISO_MD2PP;
 		rtw_write8(padapter, REG_SYS_ISO_CTRL, value8);
 	}
 
-	// auto enable WLAN
+	/*  auto enable WLAN */
 	pollingCount = 0;
 	value16 = rtw_read16(padapter, REG_APS_FSMCO);
 	value16 |= APFM_ONMAC;
@@ -378,23 +377,23 @@ static u8 _InitPowerOn(struct rtw_adapte
 	do
 	{
 		if (0 == (rtw_read16(padapter, REG_APS_FSMCO) & APFM_ONMAC)) {
-			//RT_TRACE(COMP_INIT,DBG_LOUD,("MAC auto ON okay!\n"));
+			/* RT_TRACE(COMP_INIT,DBG_LOUD,("MAC auto ON okay!\n")); */
 			break;
 		}
 
 		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT) {
-			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling REG_APS_FSMCO[APFM_ONMAC] done!\n"));
+			/* RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling REG_APS_FSMCO[APFM_ONMAC] done!\n")); */
 			return _FAIL;
 		}
 
 	}while (true);
 
-	// release RF digital isolation
+	/*  release RF digital isolation */
 	value16 = rtw_read16(padapter, REG_SYS_ISO_CTRL);
 	value16 &= ~ISO_DIOR;
 	rtw_write16(padapter, REG_SYS_ISO_CTRL, value16);
 
-	// Enable MAC DMA/WMAC/SCHEDULE/SEC block
+	/*  Enable MAC DMA/WMAC/SCHEDULE/SEC block */
 	value16 = rtw_read16(padapter, REG_CR);
 	value16 |= (HCI_TXDMA_EN | HCI_RXDMA_EN | TXDMA_EN | RXDMA_EN
 				| PROTOCOL_EN | SCHEDULE_EN | MACTXEN | MACRXEN | ENSEC);
@@ -414,12 +413,12 @@ u16 CRC16(u8 data,u16 CRC)
 		CRC_BIT15=((CRC&BIT15) ? 1:0);
 		DataBit  =(data&(BIT0<<index) ? 1:0);
 		shift_in=CRC_BIT15^DataBit;
-		//printf("CRC_BIT15=%d, DataBit=%d, shift_in=%d\n",CRC_BIT15,DataBit,shift_in);
+		/* printf("CRC_BIT15=%d, DataBit=%d, shift_in=%d\n",CRC_BIT15,DataBit,shift_in); */
 
 		CRC_Result=CRC<<1;
-		//set BIT0
-		//	printf("CRC =%x\n",CRC_Result);
-		//CRC bit 0 =shift_in,
+		/* set BIT0 */
+		/* 	printf("CRC =%x\n",CRC_Result); */
+		/* CRC bit 0 =shift_in, */
 		if (shift_in==0)
 		{
 			CRC_Result&=(~BIT0);
@@ -428,7 +427,7 @@ u16 CRC16(u8 data,u16 CRC)
 		{
 			CRC_Result|=BIT0;
 		}
-		//printf("CRC =%x\n",CRC_Result);
+		/* printf("CRC =%x\n",CRC_Result); */
 
 		CRC_BIT11 = ((CRC&BIT11) ? 1:0)^shift_in;
 		if (CRC_BIT11==0)
@@ -439,7 +438,7 @@ u16 CRC16(u8 data,u16 CRC)
 		{
 			CRC_Result|=BIT12;
 		}
-		//printf("bit12 CRC =%x\n",CRC_Result);
+		/* printf("bit12 CRC =%x\n",CRC_Result); */
 
 		CRC_BIT4 = ((CRC&BIT4) ? 1:0)^shift_in;
 		if (CRC_BIT4==0)
@@ -450,24 +449,24 @@ u16 CRC16(u8 data,u16 CRC)
 		{
 			CRC_Result|=BIT5;
 		}
-		//printf("bit5 CRC =%x\n",CRC_Result);
+		/* printf("bit5 CRC =%x\n",CRC_Result); */
 
-		CRC=CRC_Result; //repeat using the last result
+		CRC=CRC_Result; /* repeat using the last result */
 	}
 
 	return CRC;
 }
 
-/////////////////////////////////////////////////
-//
-//function name :calc_crc
-//
-//input         : char* pattern , pattern size
-//
-//////////////////////////////////////////////////
+/*  */
+/*  */
+/* function name :calc_crc */
+/*  */
+/* input         : char* pattern , pattern size */
+/*  */
+/*  */
 u16 calc_crc(u8 * pdata,int length)
 {
-//    unsigned char data[2]={0xC6,0xAA};
+/*     unsigned char data[2]={0xC6,0xAA}; */
 	u16 CRC=0xffff;
 	int i;
 
@@ -476,7 +475,7 @@ u16 calc_crc(u8 * pdata,int length)
 		CRC=CRC16(pdata[i],CRC);
 	}
 
-	CRC=~CRC;                  //get 1' complement
+	CRC=~CRC;                  /* get 1' complement */
 	DBG_8192D("CRC =%x\n",CRC);
 	return CRC;
 }
@@ -502,8 +501,8 @@ static int rtw_wowlan_set_pattern(struct
 	packet_len=pattern_len*8;
 	pdata=(u32 *)pbuf;
 
-	// Write to the Wakeup CAM
-	//offset 0
+	/*  Write to the Wakeup CAM */
+	/* offset 0 */
 	if (pattern_len>=4) {
 		content=pdata[1];
 	}
@@ -511,11 +510,11 @@ static int rtw_wowlan_set_pattern(struct
 		content=0;
 	}
 	DBG_8192D("\nrtw_wowlan_set_pattern offset[0]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
-	//rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content));
+	/* rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content)); */
 	pwrpriv->wowlan_pattern_context[idx][0]= __cpu_to_le32(content);
-	//cmd=BIT(31)|BIT(16)|(idx+0);
-	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
-	//offset 4
+	/* cmd=BIT(31)|BIT(16)|(idx+0); */
+	/* rtw_write32(padapter, REG_WKFMCAM_CMD, cmd); */
+	/* offset 4 */
 	if (pattern_len>=8) {
 		content=pdata[2];
 	}
@@ -523,12 +522,12 @@ static int rtw_wowlan_set_pattern(struct
 		content=0;
 	}
 	DBG_8192D("rtw_wowlan_set_pattern offset[4]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
-	//rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content));
+	/* rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content)); */
 	pwrpriv->wowlan_pattern_context[idx][1]= __cpu_to_le32(content);
 
-	//cmd=BIT(31)|BIT(16)|(idx+1);
-	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
-	//offset 8
+	/* cmd=BIT(31)|BIT(16)|(idx+1); */
+	/* rtw_write32(padapter, REG_WKFMCAM_CMD, cmd); */
+	/* offset 8 */
 	if (pattern_len>=12) {
 		content=pdata[3];
 	}
@@ -536,11 +535,11 @@ static int rtw_wowlan_set_pattern(struct
 		content=0;
 	}
 	DBG_8192D("rtw_wowlan_set_pattern offset[8]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
-	//rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content));
+	/* rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content)); */
 	pwrpriv->wowlan_pattern_context[idx][2]= __cpu_to_le32(content);
-	//cmd=BIT(31)|BIT(16)|(idx+2);
-	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
-	//offset 12
+	/* cmd=BIT(31)|BIT(16)|(idx+2); */
+	/* rtw_write32(padapter, REG_WKFMCAM_CMD, cmd); */
+	/* offset 12 */
 	if (pattern_len>=16) {
 		content=pdata[4];
 	}
@@ -548,13 +547,13 @@ static int rtw_wowlan_set_pattern(struct
 		content=0;
 	}
 	DBG_8192D("rtw_wowlan_set_pattern offset[12]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
-	//rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content));
+	/* rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content)); */
 	pwrpriv->wowlan_pattern_context[idx][3]= __cpu_to_le32(content);
-	//cmd=BIT(31)|BIT(16)|(idx+3);
-	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+	/* cmd=BIT(31)|BIT(16)|(idx+3); */
+	/* rtw_write32(padapter, REG_WKFMCAM_CMD, cmd); */
 
 	if (crc) {
-		// Have the CRC value
+		/*  Have the CRC value */
 		crc_val=*(u16 *)(&pbuf[2]);
 		DBG_8192D("rtw_wowlan_set_pattern crc_val  0x%x\n", crc_val);
 		crc_val=__cpu_to_le16(crc_val);
@@ -562,13 +561,13 @@ static int rtw_wowlan_set_pattern(struct
 	}
 	else {
 		DBG_8192D("+rtw_wowlan_set_pattern   crc=0[%x]  Should calculate the CRC\n", crc);
-		// calculate the CRC the write to the Wakeup CAM
+		/*  calculate the CRC the write to the Wakeup CAM */
 		crc_idx=0;
 		for (i=0;i<packet_len;i++) {
 			if (pbuf[4+(i/8)]&(0x01<<(i%8)))
 			{
 				packet[crc_idx++]=pbuf[20+i];
-		//		DBG_8192D("\n i=%d packet[i]=%x pbuf[20+i(%d)]=%x\n",i,packet[i],20+i,pbuf[20+i]);
+		/* 		DBG_8192D("\n i=%d packet[i]=%x pbuf[20+i(%d)]=%x\n",i,packet[i],20+i,pbuf[20+i]); */
 			}
 		}
 		crc_val=calc_crc(packet, crc_idx);
@@ -576,13 +575,13 @@ static int rtw_wowlan_set_pattern(struct
 
 	}
 
-	//offset 16
+	/* offset 16 */
 	content=(valid<<31)| (bc<<26)|(mc<<25)|(uc<<24) |crc_val;
 	printk("rtw_wowlan_set_pattern offset[16]  content  0x%x\n", content);
 	rtw_write32(padapter, REG_WKFMCAM_RWD,content);
 	pwrpriv->wowlan_pattern_context[idx][4]= content;
-	//cmd=BIT(31)|BIT(16)|(idx+4);
-	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+	/* cmd=BIT(31)|BIT(16)|(idx+4); */
+	/* rtw_write32(padapter, REG_WKFMCAM_CMD, cmd); */
 	pwrpriv->wowlan_pattern_idx|=BIT(idx);
 
 _rtw_wowlan_set_pattern_exit:
@@ -598,27 +597,27 @@ void rtw_wowlan_reload_pattern(struct rt
 
 	for (idx=0;idx<8;idx ++) {
 		if (pwrpriv->wowlan_pattern_idx & BIT(idx)) {
-			//offset 0
+			/* offset 0 */
 			rtw_write32(padapter, REG_WKFMCAM_RWD, pwrpriv->wowlan_pattern_context[idx][0]);
 			cmd=BIT(31)|BIT(16)|(idx+0);
 			rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 
-			//offset 4
+			/* offset 4 */
 			rtw_write32(padapter, REG_WKFMCAM_RWD, pwrpriv->wowlan_pattern_context[idx][1]);
 			cmd=BIT(31)|BIT(16)|(idx+1);
 			rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 
-			//offset 8
+			/* offset 8 */
 			rtw_write32(padapter, REG_WKFMCAM_RWD, pwrpriv->wowlan_pattern_context[idx][2]);
 			cmd=BIT(31)|BIT(16)|(idx+2);
 			rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 
-			//offset 12
+			/* offset 12 */
 			rtw_write32(padapter, REG_WKFMCAM_RWD, pwrpriv->wowlan_pattern_context[idx][3]);
 			cmd=BIT(31)|BIT(16)|(idx+3);
 			rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 
-			//offset 16
+			/* offset 16 */
 			rtw_write32(padapter, REG_WKFMCAM_RWD, pwrpriv->wowlan_pattern_context[idx][4]);
 			cmd=BIT(31)|BIT(16)|(idx+4);
 			rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
@@ -644,14 +643,14 @@ void rtw_wowlan_reload_pattern(struct rt
 
 	}
 }
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 
 
-//-------------------------------------------------------------------------
-//
-// LLT R/W/Init function
-//
-//-------------------------------------------------------------------------
+/*  */
+/*  */
+/*  LLT R/W/Init function */
+/*  */
+/*  */
 static u8 _LLTWrite(
 	struct rtw_adapter *	Adapter,
 	u32		address,
@@ -664,7 +663,7 @@ static u8 _LLTWrite(
 
 	rtw_write32(Adapter, REG_LLT_INIT, value);
 
-	//polling
+	/* polling */
 	do{
 
 		value = rtw_read32(Adapter, REG_LLT_INIT);
@@ -673,7 +672,7 @@ static u8 _LLTWrite(
 		}
 
 		if (count > POLLING_LLT_THRESHOLD) {
-			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling write LLT done at address %d!\n", address));
+			/* RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling write LLT done at address %d!\n", address)); */
 			status = _FAIL;
 			break;
 		}
@@ -692,7 +691,7 @@ static u8 _LLTRead(
 
 	rtw_write32(Adapter, REG_LLT_INIT, value);
 
-	//polling and get value
+	/* polling and get value */
 	do{
 
 		value = rtw_read32(Adapter, REG_LLT_INIT);
@@ -701,7 +700,7 @@ static u8 _LLTRead(
 		}
 
 		if (count > POLLING_LLT_THRESHOLD) {
-			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling read LLT done at address %d!\n", address));
+			/* RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling read LLT done at address %d!\n", address)); */
 			break;
 		}
 	}while (count++);
@@ -722,15 +721,15 @@ static u8 InitLLTTable(
 
 
 	if (pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY) {
-		//for 92du two mac: The page size is different from 92c and 92s
+		/* for 92du two mac: The page size is different from 92c and 92s */
 		txpktbuf_bndy =TX_PAGE_BOUNDARY_DUAL_MAC;
 		Last_Entry_Of_TxPktBuf=LAST_ENTRY_OF_TX_PKT_BUFFER_DUAL_MAC;
 	}
 	else {
 		txpktbuf_bndy = boundary;
 		Last_Entry_Of_TxPktBuf=LAST_ENTRY_OF_TX_PKT_BUFFER;
-		//txpktbuf_bndy =253;
-		//Last_Entry_Of_TxPktBuf=255;
+		/* txpktbuf_bndy =253; */
+		/* Last_Entry_Of_TxPktBuf=255; */
 	}
 
 	for (i = 0 ; i < (txpktbuf_bndy - 1) ; i++) {
@@ -740,15 +739,15 @@ static u8 InitLLTTable(
 		}
 	}
 
-	// end of list
+	/*  end of list */
 	status = _LLTWrite(Adapter, (txpktbuf_bndy - 1), 0xFF);
 	if (_SUCCESS != status) {
 		return status;
 	}
 
-	// Make the other pages as ring buffer
-	// This ring buffer is used as beacon buffer if we config this MAC as two MAC transfer.
-	// Otherwise used as local loopback buffer.
+	/*  Make the other pages as ring buffer */
+	/*  This ring buffer is used as beacon buffer if we config this MAC as two MAC transfer. */
+	/*  Otherwise used as local loopback buffer. */
 	for (i = txpktbuf_bndy ; i < Last_Entry_Of_TxPktBuf ; i++) {
 		status = _LLTWrite(Adapter, i, (i + 1));
 		if (_SUCCESS != status) {
@@ -756,7 +755,7 @@ static u8 InitLLTTable(
 		}
 	}
 
-	// Let last entry point to the start entry of ring buffer
+	/*  Let last entry point to the start entry of ring buffer */
 	status = _LLTWrite(Adapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);
 	if (_SUCCESS != status) {
 		return status;
@@ -765,11 +764,11 @@ static u8 InitLLTTable(
 	return status;
 }
 
-//---------------------------------------------------------------
-//
-//	MAC init functions
-//
-//---------------------------------------------------------------
+/*  */
+/*  */
+/* 	MAC init functions */
+/*  */
+/*  */
 static void
 _SetMacID(
 	struct rtw_adapter * Adapter, u8* MacID
@@ -802,7 +801,7 @@ _SetBSSID(
 	}
 }
 
-// Shall USB interface init this?
+/*  Shall USB interface init this? */
 static void
 _InitInterrupt(
 	struct rtw_adapter * Adapter
@@ -810,11 +809,11 @@ _InitInterrupt(
 {
 	u32	value32;
 
-	// HISR - turn all on
+	/*  HISR - turn all on */
 	value32 = 0xFFFFFFFF;
 	rtw_write32(Adapter, REG_HISR, value32);
 
-	// HIMR - turn all on
+	/*  HIMR - turn all on */
 	rtw_write32(Adapter, REG_HIMR, value32);
 }
 
@@ -846,12 +845,12 @@ _InitQueueReservedPage(
 		else
 		{
 			numPubQ =TEST_PAGE_NUM_PUBQ;
-			//RT_ASSERT((numPubQ < TX_TOTAL_PAGE_NUMBER), ("Public queue page number is great than total tx page number.\n"));
+			/* RT_ASSERT((numPubQ < TX_TOTAL_PAGE_NUMBER), ("Public queue page number is great than total tx page number.\n")); */
 			txQPageNum = TX_TOTAL_PAGE_NUMBER - numPubQ;
 		}
 
 		if ((pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY)&&(outEPNum==3))
-		{// temply for DMDP/DMSP Page allocate
+		{/*  temply for DMDP/DMSP Page allocate */
 			numHQ=NORMAL_PAGE_NUM_HPQ_92D_DUAL_MAC;
 			numLQ=NORMAL_PAGE_NUM_LPQ_92D_DUAL_MAC;
 			numNQ=NORMAL_PAGE_NUM_NORMALQ_92D_DUAL_MAC;
@@ -867,13 +866,13 @@ _InitQueueReservedPage(
 			if (pHalData->OutEpQueueSel & TX_SELE_LQ) {
 				numLQ = txQPageUnit;
 			}
-			// HIGH priority queue always present in the configuration of 2 or 3 out-ep
-			// so ,remainder pages have assigned to High queue
+			/*  HIGH priority queue always present in the configuration of 2 or 3 out-ep */
+			/*  so ,remainder pages have assigned to High queue */
 			if ((outEPNum>1) && (txQRemainPage)) {
 				numHQ += txQRemainPage;
 			}
 
-			// NOTE: This step shall be proceed before writting REG_RQPN.
+			/*  NOTE: This step shall be proceed before writting REG_RQPN. */
 			if (pHalData->OutEpQueueSel & TX_SELE_NQ)
 				numNQ = txQPageUnit;
 
@@ -881,10 +880,10 @@ _InitQueueReservedPage(
 			rtw_write8(Adapter, REG_RQPN_NPQ, value8);
 		}
 	}
-	else { //for WMM
-		//RT_ASSERT((outEPNum>=2), ("for WMM ,number of out-ep must more than or equal to 2!\n"));
-		// 92du wifi config only for SMSP
-		//RT_ASSERT((pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY), ("for WMM ,only SMSP come here!\n"));
+	else { /* for WMM */
+		/* RT_ASSERT((outEPNum>=2), ("for WMM ,number of out-ep must more than or equal to 2!\n")); */
+		/*  92du wifi config only for SMSP */
+		/* RT_ASSERT((pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY), ("for WMM ,only SMSP come here!\n")); */
 
 		numPubQ = (outEPNum==2)?WMM_NORMAL_PAGE_NUM_PUBQ:WMM_NORMAL_PAGE_NUM_PUBQ_92D;
 
@@ -903,7 +902,7 @@ _InitQueueReservedPage(
 		}
 	}
 
-	// TX DMA
+	/*  TX DMA */
 	value32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;
 	rtw_write32(Adapter, REG_RQPN, value32);
 }
@@ -916,13 +915,13 @@ _InitTxBufferBoundary(
 	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
 	struct hal_data_8192du *pHalData	= GET_HAL_DATA(Adapter);
 
-	//u16	txdmactrl;
+	/* u16	txdmactrl; */
 	u8	txpktbuf_bndy;
 
 	if (!pregistrypriv->wifi_spec) {
 		txpktbuf_bndy = TX_PAGE_BOUNDARY;
 	}
-	else {//for WMM
+	else {/* for WMM */
 		txpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY;
 	}
 
@@ -977,7 +976,7 @@ _InitNormalChipOneOutEpPriority(
 			value = QUEUE_NORMAL;
 			break;
 		default:
-			//RT_ASSERT(FALSE,("Shall not reach here!\n"));
+			/* RT_ASSERT(FALSE,("Shall not reach here!\n")); */
 			break;
 	}
 
@@ -1019,7 +1018,7 @@ _InitNormalChipTwoOutEpPriority(
 			valueLow = QUEUE_NORMAL;
 			break;
 		default:
-			//RT_ASSERT(FALSE,("Shall not reach here!\n"));
+			/* RT_ASSERT(FALSE,("Shall not reach here!\n")); */
 			break;
 	}
 
@@ -1031,7 +1030,7 @@ _InitNormalChipTwoOutEpPriority(
 		mgtQ	= valueHi;
 		hiQ		= valueHi;
 	}
-	else {//for WMM ,CONFIG_OUT_EP_WIFI_MODE
+	else {/* for WMM ,CONFIG_OUT_EP_WIFI_MODE */
 		beQ		= valueLow;
 		bkQ		= valueHi;
 		viQ		= valueHi;
@@ -1051,7 +1050,7 @@ _InitNormalChipThreeOutEpPriority(
 	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
 
-	if (!pregistrypriv->wifi_spec) {// typical setting
+	if (!pregistrypriv->wifi_spec) {/*  typical setting */
 		beQ		= QUEUE_LOW;
 		bkQ		= QUEUE_LOW;
 		viQ		= QUEUE_NORMAL;
@@ -1059,7 +1058,7 @@ _InitNormalChipThreeOutEpPriority(
 		mgtQ	= QUEUE_HIGH;
 		hiQ		= QUEUE_HIGH;
 	}
-	else {// for WMM
+	else {/*  for WMM */
 		beQ		= QUEUE_LOW;
 		bkQ		= QUEUE_NORMAL;
 		viQ		= QUEUE_NORMAL;
@@ -1089,11 +1088,11 @@ _InitQueuePriority(
 			_InitNormalChipThreeOutEpPriority(Adapter);
 			break;
 		default:
-			//RT_ASSERT(FALSE,("Shall not reach here!\n"));
+			/* RT_ASSERT(FALSE,("Shall not reach here!\n")); */
 			break;
 	}
 }
-#if ENABLE_USB_DROP_INCORRECT_OUT //amy,temp remove
+#if ENABLE_USB_DROP_INCORRECT_OUT /* amy,temp remove */
 static void
 _InitHardwareDropIncorrectBulkOut(
 	struct rtw_adapter * Adapter
@@ -1103,7 +1102,7 @@ _InitHardwareDropIncorrectBulkOut(
 	value32 |= DROP_DATA_EN;
 	rtw_write32(Adapter, REG_TXDMA_OFFSET_CHK, value32);
 }
-#endif //ENABLE_USB_DROP_INCORRECT_OUT, amy,temp remove
+#endif /* ENABLE_USB_DROP_INCORRECT_OUT, amy,temp remove */
 static void
 _InitNetworkType(
 	struct rtw_adapter * Adapter
@@ -1113,14 +1112,14 @@ _InitNetworkType(
 
 	value32 = rtw_read32(Adapter, REG_CR);
 
-	// TODO: use the other function to set network type
+	/*  TODO: use the other function to set network type */
 #if RTL8191C_FPGA_NETWORKTYPE_ADHOC
 	value32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AD_HOC);
 #else
 	value32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AP);
 #endif
 	rtw_write32(Adapter, REG_CR, value32);
-//	RASSERT(pIoBase->rtw_read8(REG_CR + 2) == 0x2);
+/* 	RASSERT(pIoBase->rtw_read8(REG_CR + 2) == 0x2); */
 }
 
 static void
@@ -1128,7 +1127,7 @@ _InitTransferPageSize(
 	struct rtw_adapter * Adapter
 	)
 {
-	// Tx page size is always 128.
+	/*  Tx page size is always 128. */
 
 	u8	value8;
 	value8 = _PSRX(PBP_128) | _PSTX(PBP_128);
@@ -1149,14 +1148,14 @@ _InitWMACSetting(
 	struct rtw_adapter * Adapter
 	)
 {
-	//u4Byte			value32;
-	//u16			value16;
+	/* u4Byte			value32; */
+	/* u16			value16; */
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
-	//pHalData->ReceiveConfig = AAP | APM | AM | AB | APP_ICV | ADF | AMF | APP_FCS | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;
-	//pHalData->ReceiveConfig = AAP | APM | AM | AB | CBSSID |CBSSID_BCN | APP_ICV | AMF | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;
+	/* pHalData->ReceiveConfig = AAP | APM | AM | AB | APP_ICV | ADF | AMF | APP_FCS | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS; */
+	/* pHalData->ReceiveConfig = AAP | APM | AM | AB | CBSSID |CBSSID_BCN | APP_ICV | AMF | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS; */
 
-	// don't turn on AAP, it will allow all packets to driver
+	/*  don't turn on AAP, it will allow all packets to driver */
 	pHalData->ReceiveConfig = APM | AM | AB | CBSSID |CBSSID_BCN | APP_ICV | AMF | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;
 
 
@@ -1166,20 +1165,20 @@ _InitWMACSetting(
 
 	rtw_write32(Adapter, REG_RCR, pHalData->ReceiveConfig);
 
-	// Accept all multicast address
+	/*  Accept all multicast address */
 	rtw_write32(Adapter, REG_MAR, 0xFFFFFFFF);
 	rtw_write32(Adapter, REG_MAR+4, 0xFFFFFFFF);
 
-	// Accept all data frames
-	//value16 = 0xFFFF;
-	//rtw_write16(Adapter, REG_RXFLTMAP2, value16);
-
-	// Accept all management frames
-	//value16 = 0xFFFF;
-	//rtw_write16(Adapter, REG_RXFLTMAP0, value16);
+	/*  Accept all data frames */
+	/* value16 = 0xFFFF; */
+	/* rtw_write16(Adapter, REG_RXFLTMAP2, value16); */
+
+	/*  Accept all management frames */
+	/* value16 = 0xFFFF; */
+	/* rtw_write16(Adapter, REG_RXFLTMAP0, value16); */
 
-	//Reject all control frame - default value is 0
-	//rtw_write16(Adapter,REG_RXFLTMAP1,0x0);
+	/* Reject all control frame - default value is 0 */
+	/* rtw_write16(Adapter,REG_RXFLTMAP1,0x0); */
 }
 
 static void
@@ -1191,7 +1190,7 @@ _InitAdaptiveCtrl(
 	u32	value32;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
-	// Response Rate Set
+	/*  Response Rate Set */
 	value32 = rtw_read32(Adapter, REG_RRSR);
 	value32 &= ~RATE_BITMAP_ALL;
 	if (pHalData->CurrentBandType92D == BAND_ON_5G)
@@ -1204,14 +1203,14 @@ _InitAdaptiveCtrl(
 	}
 	rtw_write32(Adapter, REG_RRSR, value32);
 
-	// CF-END Threshold
-	//m_spIoBase->rtw_write8(REG_CFEND_TH, 0x1);
+	/*  CF-END Threshold */
+	/* m_spIoBase->rtw_write8(REG_CFEND_TH, 0x1); */
 
-	// SIFS (used in NAV)
+	/*  SIFS (used in NAV) */
 	value16 = _SPEC_SIFS_CCK(0x10) | _SPEC_SIFS_OFDM(0x10);
 	rtw_write16(Adapter, REG_SPEC_SIFS, value16);
 
-	// Retry Limit
+	/*  Retry Limit */
 	value16 = _LRL(0x30) | _SRL(0x30);
 	rtw_write16(Adapter, REG_RL, value16);
 }
@@ -1221,7 +1220,7 @@ _InitRateFallback(
 	struct rtw_adapter * Adapter
 	)
 {
-	// Set Data Auto Rate Fallback Retry Count register.
+	/*  Set Data Auto Rate Fallback Retry Count register. */
 	rtw_write32(Adapter, REG_DARFRC, 0x00000000);
 	rtw_write32(Adapter, REG_DARFRC+4, 0x10080404);
 	rtw_write32(Adapter, REG_RARFRC, 0x04030201);
@@ -1234,30 +1233,30 @@ _InitEDCA(
 	struct rtw_adapter * Adapter
 	)
 {
-	//PHAL_DATA_8192CUSB	pHalData = GetHalData8192CUsb(Adapter);
+	/* PHAL_DATA_8192CUSB	pHalData = GetHalData8192CUsb(Adapter); */
 	u16				value16;
 
-	//disable EDCCA count down, to reduce collison and retry
+	/* disable EDCCA count down, to reduce collison and retry */
 	value16 = rtw_read16(Adapter, REG_RD_CTRL);
 	value16 |= DIS_EDCA_CNT_DWN;
 	rtw_write16(Adapter, REG_RD_CTRL, value16);
 
 
-	// Update SIFS timing.  ??????????
-	//pHalData->SifsTime = 0x0e0e0a0a;
-	//rtw_hal_set_hwreg(Adapter, HW_VAR_RESP_SIFS,  (pu1Byte)&pHalData->SifsTime);
-	// SIFS for CCK Data ACK
+	/*  Update SIFS timing.  ?????????? */
+	/* pHalData->SifsTime = 0x0e0e0a0a; */
+	/* rtw_hal_set_hwreg(Adapter, HW_VAR_RESP_SIFS,  (pu1Byte)&pHalData->SifsTime); */
+	/*  SIFS for CCK Data ACK */
 	rtw_write8(Adapter, REG_SIFS_CTX, 0xa);
-	// SIFS for CCK consecutive tx like CTS data!
+	/*  SIFS for CCK consecutive tx like CTS data! */
 	rtw_write8(Adapter, REG_SIFS_CTX+1, 0xa);
 
-	// SIFS for OFDM Data ACK
+	/*  SIFS for OFDM Data ACK */
 	rtw_write8(Adapter, REG_SIFS_TRX, 0xe);
-	// SIFS for OFDM consecutive tx like CTS data!
+	/*  SIFS for OFDM consecutive tx like CTS data! */
 	rtw_write8(Adapter, REG_SIFS_TRX+1, 0xe);
 
-	// Set CCK/OFDM SIFS
-	rtw_write16(Adapter, REG_SIFS_CTX, 0x0a0a); // CCK SIFS shall always be 10us.
+	/*  Set CCK/OFDM SIFS */
+	rtw_write16(Adapter, REG_SIFS_CTX, 0x0a0a); /*  CCK SIFS shall always be 10us. */
 	rtw_write16(Adapter, REG_SIFS_TRX, 0x1010);
 
 	rtw_write16(Adapter, REG_PROT_MODE_CTRL, 0x0204);
@@ -1265,16 +1264,16 @@ _InitEDCA(
 	rtw_write32(Adapter, REG_BAR_MODE_CTRL, 0x014004);
 
 
-	// TXOP
+	/*  TXOP */
 	rtw_write32(Adapter, REG_EDCA_BE_PARAM, 0x005EA42B);
 	rtw_write32(Adapter, REG_EDCA_BK_PARAM, 0x0000A44F);
 	rtw_write32(Adapter, REG_EDCA_VI_PARAM, 0x005EA324);
 	rtw_write32(Adapter, REG_EDCA_VO_PARAM, 0x002FA226);
 
-	// PIFS
+	/*  PIFS */
 	rtw_write8(Adapter, REG_PIFS, 0x1C);
 
-	//AGGR BREAK TIME Register
+	/* AGGR BREAK TIME Register */
 	rtw_write8(Adapter, REG_AGGR_BREAK_TIME, 0x16);
 
 	rtw_write16(Adapter, REG_NAV_PROT_LEN, 0x0040);
@@ -1292,7 +1291,7 @@ _InitAMPDUAggregation(
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
-	//rtw_write32(Adapter, REG_AGGLEN_LMT, 0x99997631);
+	/* rtw_write32(Adapter, REG_AGGLEN_LMT, 0x99997631); */
 
 	if (pHalData->MacPhyMode92D ==SINGLEMAC_SINGLEPHY)
 		rtw_write32(Adapter, REG_AGGLEN_LMT, 0x88728841);
@@ -1313,7 +1312,7 @@ _InitBeaconMaxError(
 #ifdef RTL8192CU_ADHOC_WORKAROUND_SETTING
 	rtw_write8(Adapter, REG_BCN_MAX_ERR,  0xFF);
 #else
-	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));
+	/* rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10)); */
 #endif
 }
 
@@ -1338,7 +1337,7 @@ _InitRetryFunction(
 	value8 |= EN_AMPDU_RTY_NEW;
 	rtw_write8(Adapter, REG_FWHW_TXQ_CTRL, value8);
 
-	// Set ACK timeout
+	/*  Set ACK timeout */
 	rtw_write8(Adapter, REG_ACKTO, 0x40);
 }
 
@@ -1369,7 +1368,7 @@ _InitUsbAggregationSetting(
 }
 #endif
 
-	// Rx aggregation setting
+	/*  Rx aggregation setting */
 #ifdef CONFIG_USB_RX_AGGREGATION
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
@@ -1423,7 +1422,7 @@ _InitUsbAggregationSetting(
 			break;
 		case USB_RX_AGG_DISABLE:
 		default:
-			// TODO:
+			/*  TODO: */
 			break;
 	}
 	switch (PBP_128)
@@ -1444,7 +1443,7 @@ _InitUsbAggregationSetting(
 			pHalData->HwRxPageSize = 1024;
 			break;
 		default:
-			//RT_ASSERT(FALSE, ("RX_PAGE_SIZE_REG_VALUE definition is incorrect!\n"));
+			/* RT_ASSERT(FALSE, ("RX_PAGE_SIZE_REG_VALUE definition is incorrect!\n")); */
 			break;
 	}
 }
@@ -1461,10 +1460,10 @@ _InitOperationMode(
 	u8 regBwOpMode = 0, MinSpaceCfg = 0;
 	u32 regRATR = 0, regRRSR = 0;
 
-	//1 This part need to modified according to the rate set we filtered!!
-	//
-	// Set RRSR, RATR, and REG_BWOPMODE registers
-	//
+	/* 1 This part need to modified according to the rate set we filtered!! */
+	/*  */
+	/*  Set RRSR, RATR, and REG_BWOPMODE registers */
+	/*  */
 	switch (pHalData->CurrentWirelessMode) {
 	case WIRELESS_MODE_B:
 		regBwOpMode = BW_OPMODE_20MHZ;
@@ -1472,7 +1471,7 @@ _InitOperationMode(
 		regRRSR = RATE_ALL_CCK;
 		break;
 	case WIRELESS_MODE_A:
-		//RT_ASSERT(FALSE,("Error wireless a mode\n"));
+		/* RT_ASSERT(FALSE,("Error wireless a mode\n")); */
 		regBwOpMode = BW_OPMODE_5G |BW_OPMODE_20MHZ;
 		regRATR = RATE_ALL_OFDM_AG;
 		regRRSR = RATE_ALL_OFDM_AG;
@@ -1489,8 +1488,8 @@ _InitOperationMode(
 		regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
 		break;
 	case WIRELESS_MODE_N_24G:
-		// It support CCK rate by default.
-		// CCK rate will be filtered out only when associated AP does not support it.
+		/*  It support CCK rate by default. */
+		/*  CCK rate will be filtered out only when associated AP does not support it. */
 		regBwOpMode = BW_OPMODE_20MHZ;
 			regRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;
 			regRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;
@@ -1502,10 +1501,10 @@ _InitOperationMode(
 		break;
 	}
 
-	// Ziv ????????
+	/*  Ziv ???????? */
 	rtw_write8(Adapter, REG_BWOPMODE, regBwOpMode);
 
-	// For Min Spacing configuration.
+	/*  For Min Spacing configuration. */
 	switch (pHalData->rf_type) {
 	case RF_1T2R:
 	case RF_1T1R:
@@ -1533,22 +1532,17 @@ _InitBeaconParameters(
 	struct rtw_adapter * Adapter
 	)
 {
-//	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
+/* 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter); */
 
 	rtw_write16(Adapter, REG_BCN_CTRL, 0x1010);
 
-	 //default value  for register 0x558 and 0x559 is  0x05 0x03 (92DU before bitfile0821) zhiyuan 2009/08/26
-	rtw_write16(Adapter, REG_TBTT_PROHIBIT,0x3c02);// ms
-	rtw_write8(Adapter, REG_DRVERLYINT, 0x05);//ms
+	 /* default value  for register 0x558 and 0x559 is  0x05 0x03 (92DU before bitfile0821) zhiyuan 2009/08/26 */
+	rtw_write16(Adapter, REG_TBTT_PROHIBIT,0x3c02);/*  ms */
+	rtw_write8(Adapter, REG_DRVERLYINT, 0x05);/* ms */
 	rtw_write8(Adapter, REG_BCNDMATIM, 0x03);
 
-	// TODO: Remove these magic number
-	//rtw_write16(Adapter, REG_TBTT_PROHIBIT,0x6404);// ms
-	//rtw_write8(Adapter, REG_DRVERLYINT, DRIVER_EARLY_INT_TIME);//ms
-	//rtw_write8(Adapter, REG_BCNDMATIM, BCN_DMA_ATIME_INT_TIME);
-
-	// Suggested by designer timchen. Change beacon AIFS to the largest number
-	// beacause test chip does not contension before sending beacon. by tynli. 2009.11.03
+	/*  Suggested by designer timchen. Change beacon AIFS to the largest number */
+	/*  beacause test chip does not contension before sending beacon. by tynli. 2009.11.03 */
 	rtw_write16(Adapter, REG_BCNTCFG, 0x660F);
 }
 
@@ -1561,7 +1555,7 @@ _InitRFType(
 
 #if (DISABLE_BB_RF==1)
 	pHalData->rf_chip	= RF_PSEUDO_11N;
-	pHalData->rf_type	= RF_1T1R;// RF_2T2R;
+	pHalData->rf_type	= RF_1T1R;/*  RF_2T2R; */
 #else
 
 	pHalData->rf_chip	= RF_6052;
@@ -1570,7 +1564,7 @@ _InitRFType(
 	{
 		pHalData->rf_type = RF_1T1R;
 	}
-	else {// SMSP OR DMSP
+	else {/*  SMSP OR DMSP */
 		pHalData->rf_type = RF_2T2R;
 	}
 #endif
@@ -1595,17 +1589,17 @@ _BeaconFunctionEnable(
 	bool			Linked
 	)
 {
-	// 20100901 zhiyuan: Change original setting of BCN_CTRL(0x550) from
-	// 0x1a to 0x1b. Set BIT0 of this register disable ATIM  function.
-	//  enable ATIM function may invoke HW Tx stop operation. This may cause ping failed
-	// sometimes in long run test. So just disable it now.
-	// When ATIM function is disabled, High Queue should not use anymore.
+	/*  20100901 zhiyuan: Change original setting of BCN_CTRL(0x550) from */
+	/*  0x1a to 0x1b. Set BIT0 of this register disable ATIM  function. */
+	/*   enable ATIM function may invoke HW Tx stop operation. This may cause ping failed */
+	/*  sometimes in long run test. So just disable it now. */
+	/*  When ATIM function is disabled, High Queue should not use anymore. */
 	rtw_write8(Adapter, REG_BCN_CTRL, 0x1b);
 	rtw_write8(Adapter, REG_RD_CTRL+1, 0x6F);
 }
 
 
-// Set CCK and OFDM Block "ON"
+/*  Set CCK and OFDM Block "ON" */
 static void _BBTurnOnBlock(
 	struct rtw_adapter *		Adapter
 	)
@@ -1633,10 +1627,10 @@ static void _RfPowerSave(
 	return;
 #endif
 
-	if (pwrctrlpriv->reg_rfoff == true) { // User disable RF via registry.
-		//RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RegRfOff.\n"));
-		//MgntActSet_RF_State(Adapter, rf_off, RF_CHANGE_BY_SW, true);
-		// Those action will be discard in MgntActSet_RF_State because off the same state
+	if (pwrctrlpriv->reg_rfoff == true) { /*  User disable RF via registry. */
+		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RegRfOff.\n")); */
+		/* MgntActSet_RF_State(Adapter, rf_off, RF_CHANGE_BY_SW, true); */
+		/*  Those action will be discard in MgntActSet_RF_State because off the same state */
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		if (pHalData->bSlaveOfDMSP)
 			return;
@@ -1644,16 +1638,16 @@ static void _RfPowerSave(
 		for (eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
 	}
-	else if (pwrctrlpriv->rfoff_reason > RF_CHANGE_BY_PS) { // H/W or S/W RF OFF before sleep.
-		//RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason));
-		//MgntActSet_RF_State(Adapter, rf_off, pMgntInfo->RfOffReason, true);
+	else if (pwrctrlpriv->rfoff_reason > RF_CHANGE_BY_PS) { /*  H/W or S/W RF OFF before sleep. */
+		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason)); */
+		/* MgntActSet_RF_State(Adapter, rf_off, pMgntInfo->RfOffReason, true); */
 	}
 	else {
 		pwrctrlpriv->rf_pwrstate = rf_on;
 		pwrctrlpriv->rfoff_reason = 0;
-		//if (Adapter->bInSetPower || Adapter->bResetInProgress)
-		//	PlatformUsbEnableInPipes(Adapter);
-		//RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): RF is on.\n"));
+		/* if (Adapter->bInSetPower || Adapter->bResetInProgress) */
+		/* 	PlatformUsbEnableInPipes(Adapter); */
+		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): RF is on.\n")); */
 	}
 }
 
@@ -1665,11 +1659,11 @@ static void _InitHWLed(struct rtw_adapte
 	if (pledpriv->LedStrategy != HW_LED)
 			return;
 
-// HW led control
-// to do ....
-//must consider the cases of antenna diversity/ commbo card/solo card/mini card
+/*  HW led control */
+/*  to do .... */
+/* must consider the cases of antenna diversity/ commbo card/solo card/mini card */
 }
-#endif //CONFIG_LED
+#endif /* CONFIG_LED */
 
 #ifdef CONFIG_WOWLAN
 static void dump_wakup_reason(struct rtw_adapter *padapter)
@@ -1702,7 +1696,7 @@ static void dump_wakup_reason(struct rtw
 			break;
 	}
 }
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 
 u32 rtl8192du_hal_init(struct rtw_adapter *padapter)
 {
@@ -1711,7 +1705,7 @@ u32 rtl8192du_hal_init(struct rtw_adapte
 	u32	boundary, i = 0,  status = _SUCCESS;
 #if SWLCK == 0
 	u32	j;
-#endif //SWLCK == 0
+#endif /* SWLCK == 0 */
 	struct hal_data_8192du  *pHalData = GET_HAL_DATA(padapter);
 	struct pwrctrl_priv		*pwrctrlpriv = &padapter->pwrctrlpriv;
 	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
@@ -1769,7 +1763,7 @@ u32 rtl8192du_hal_init(struct rtw_adapte
 	};
 
 	int hal_init_profiling_i;
-	u32 hal_init_stages_timestamp[HAL_INIT_STAGES_NUM]; //used to record the time of each stage's starting point
+	u32 hal_init_stages_timestamp[HAL_INIT_STAGES_NUM]; /* used to record the time of each stage's starting point */
 
 	for (hal_init_profiling_i=0;hal_init_profiling_i<HAL_INIT_STAGES_NUM;hal_init_profiling_i++)
 		hal_init_stages_timestamp[hal_init_profiling_i]=0;
@@ -1777,7 +1771,7 @@ u32 rtl8192du_hal_init(struct rtw_adapte
 	#define HAL_INIT_PROFILE_TAG(stage) hal_init_stages_timestamp[(stage)]=rtw_get_current_time();
 #else
 	#define HAL_INIT_PROFILE_TAG(stage) do {} while (0)
-#endif //DBG_HAL_INIT_PROFILING
+#endif /* DBG_HAL_INIT_PROFILING */
 _func_enter_;
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);
@@ -1803,12 +1797,12 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEG
 		}
 	}
 #endif
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("--->InitializeAdapter8192CUsb()\n"));
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("--->InitializeAdapter8192CUsb()\n")); */
 
 	if (padapter->bSurpriseRemoved)
 		return _FAIL;
 
-	//Let the first starting mac load RF parameters and do LCK in this case,by wl
+	/* Let the first starting mac load RF parameters and do LCK in this case,by wl */
 	if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
 		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
@@ -1827,17 +1821,17 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEG
 		u8 reg_val=0;
 		rtl8192d_FirmwareSelfReset(padapter);
 		rtw_write8(padapter, REG_MCUFWDL, 0x00);
-		//before BB reset should do clock gated
+		/* before BB reset should do clock gated */
 		rtw_write32(padapter, rFPGA0_XCD_RFParameter, rtw_read32(padapter, rFPGA0_XCD_RFParameter)|(BIT31));
-		//reset BB
+		/* reset BB */
 		reg_val = rtw_read8(padapter, REG_SYS_FUNC_EN);
 		reg_val &= ~(BIT(0) | BIT(1));
 		rtw_write8(padapter, REG_SYS_FUNC_EN, reg_val);
-		//reset RF
+		/* reset RF */
 		rtw_write8(padapter, REG_RF_CTRL, 0);
-		//reset TRX path
+		/* reset TRX path */
 		rtw_write16(padapter, REG_CR, 0);
-		//reset MAC, Digital Core
+		/* reset MAC, Digital Core */
 		reg_val = rtw_read8(padapter, REG_SYS_FUNC_EN+1);
 		reg_val &= ~(BIT(4) | BIT(7));
 		rtw_write8(padapter, REG_SYS_FUNC_EN+1, reg_val);
@@ -1845,12 +1839,12 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEG
 		reg_val |= BIT(4) | BIT(7);
 		rtw_write8(padapter, REG_SYS_FUNC_EN+1, reg_val);
 	}
-#endif //CONFIG_WOWLAN
-	//mac status:
-	//0x81[4]:0 mac0 off, 1:mac0 on
-	//0x82[4]:0 mac1 off, 1: mac1 on.
+#endif /* CONFIG_WOWLAN */
+	/* mac status: */
+	/* 0x81[4]:0 mac0 off, 1:mac0 on */
+	/* 0x82[4]:0 mac1 off, 1: mac1 on. */
 
-	//For s3/s4 may reset mac,Reg0xf8 may be set to 0, so reset macphy control reg here.
+	/* For s3/s4 may reset mac,Reg0xf8 may be set to 0, so reset macphy control reg here. */
 	PHY_ConfigMacPhyMode92D(padapter);
 
 	PHY_SetPowerOnFor8192D(padapter);
@@ -1871,7 +1865,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INI
 	if (!pregistrypriv->wifi_spec) {
 		boundary = TX_PAGE_BOUNDARY;
 	}
-	else {// for WMM
+	else {/*  for WMM */
 		boundary = WMM_NORMAL_TX_PAGE_BOUNDARY;
 	}
 
@@ -1907,7 +1901,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOW
 		pHalData->fw_ractrl = false;
 		DBG_8192D("fw download fail!\n");
 
-		//return fail only when part number check fail,suggested by alex
+		/* return fail only when part number check fail,suggested by alex */
 		if (0xE0 == rtw_read8(padapter, 0x1c5))
 		{
 			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
@@ -1932,12 +1926,11 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOW
 		pwrctrlpriv->rf_pwrstate = rf_off;
 	}
 
-	// Set RF type for BB/RF configuration
-	_InitRFType(padapter);//->_ReadRFType()
+	/*  Set RF type for BB/RF configuration */
+	_InitRFType(padapter);/* _ReadRFType() */
 
-	// Save target channel
-	// <Roger_Notes> Current Channel will be updated again later.
-	//pHalData->CurrentChannel = 6;//default set to 6
+	/*  Save target channel */
+	/*  <Roger_Notes> Current Channel will be updated again later. */
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MAC);
 #if (HAL_MAC_ENABLE == 1)
@@ -1960,19 +1953,19 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 	_InitTransferPageSize(padapter);
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);
-	// Get Rx PHY status in order to report RSSI and others.
+	/*  Get Rx PHY status in order to report RSSI and others. */
 	_InitDriverInfoSize(padapter, DRVINFO_SZ);
 
 	_InitInterrupt(padapter);
-	hal_init_macaddr(padapter);//set mac_address
-	_InitNetworkType(padapter);//set msr
+	hal_init_macaddr(padapter);/* set mac_address */
+	_InitNetworkType(padapter);/* set msr */
 	_InitWMACSetting(padapter);
 	_InitAdaptiveCtrl(padapter);
 	_InitEDCA(padapter);
 	_InitRateFallback(padapter);
 	_InitRetryFunction(padapter);
 	_InitUsbAggregationSetting(padapter);
-	_InitOperationMode(padapter);//todo
+	_InitOperationMode(padapter);/* todo */
 	_InitBeaconParameters(padapter);
 	_InitAMPDUAggregation(padapter);
 	_InitBeaconMaxError(padapter, true);
@@ -1980,13 +1973,13 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 #if defined(CONFIG_CONCURRENT_MODE)
 
 #ifdef CONFIG_CHECK_AC_LIFETIME
-	// Enable lifetime check for the four ACs
+	/*  Enable lifetime check for the four ACs */
 	rtw_write8(padapter, REG_LIFETIME_EN, 0x0F);
-#endif	// CONFIG_CHECK_AC_LIFETIME
+#endif	/*  CONFIG_CHECK_AC_LIFETIME */
 
-	rtw_write16(padapter, REG_PKT_VO_VI_LIFE_TIME, 0x0400);	// unit: 256us. 256ms
-	rtw_write16(padapter, REG_PKT_BE_BK_LIFE_TIME, 0x0400);	// unit: 256us. 256ms
-#endif	// CONFIG_CONCURRENT_MODE
+	rtw_write16(padapter, REG_PKT_VO_VI_LIFE_TIME, 0x0400);	/*  unit: 256us. 256ms */
+	rtw_write16(padapter, REG_PKT_BE_BK_LIFE_TIME, 0x0400);	/*  unit: 256us. 256ms */
+#endif	/*  CONFIG_CONCURRENT_MODE */
 
 	#ifdef CONFIG_LED
 	_InitHWLed(padapter);
@@ -1999,7 +1992,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 		_InitRDGSetting(padapter);
 	}
 
-	// Set Data Auto Rate Fallback Reg.
+	/*  Set Data Auto Rate Fallback Reg. */
 	for (i = 0 ; i < 4 ; i++) {
 		rtw_write32(padapter, REG_ARFR0+i*4, 0x1f8ffff0);
 	}
@@ -2010,7 +2003,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 	}
 	else {
 		if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY) {
-			if (pHalData->OutEpNumber == 2)  // suggested by chunchu
+			if (pHalData->OutEpNumber == 2)  /*  suggested by chunchu */
 				rtw_write32(padapter, REG_FAST_EDCA_CTRL, 0x03066666);
 		       else
 				rtw_write16(padapter, REG_FAST_EDCA_CTRL, 0x8888);
@@ -2026,11 +2019,10 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 	rtw_write8(padapter, 0x55e,0x30);
 	rtw_write8(padapter, 0x55f,0x30);
 	rtw_write8(padapter, 0x606,0x30);
-	//PlatformEFIOWrite1Byte(Adapter, 0x5e4,0x38);	  // masked for new bitfile
 
-	//for bitfile 0912/0923 zhiyuan 2009/09/23
-	// temp for high queue and mgnt Queue corrupt in time;
-	//it may cause hang when sw beacon use high_Q,other frame use mgnt_Q; or ,sw beacon use mgnt_Q ,other frame use high_Q;
+	/* for bitfile 0912/0923 zhiyuan 2009/09/23 */
+	/*  temp for high queue and mgnt Queue corrupt in time; */
+	/* it may cause hang when sw beacon use high_Q,other frame use mgnt_Q; or ,sw beacon use mgnt_Q ,other frame use high_Q; */
 	rtw_write8(padapter, 0x523, 0x10);
 	val16 = rtw_read16(padapter, 0x524);
 	val16|=BIT12;
@@ -2038,7 +2030,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 
 	rtw_write8(padapter,REG_TXPAUSE, 0);
 
-	// suggested by zhouzhou   usb suspend  idle time count for bitfile0927  2009/10/09 zhiyuan
+	/*  suggested by zhouzhou   usb suspend  idle time count for bitfile0927  2009/10/09 zhiyuan */
 	val8=rtw_read8(padapter, 0xfe56);
 	val8 |=(BIT0|BIT1);
 	rtw_write8(padapter, 0xfe56, val8);
@@ -2062,9 +2054,9 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 		rtw_write8(padapter,0x4d0,0);
 	}
 
-	//
-	//d. Initialize BB related configurations.
-	//
+	/*  */
+	/* d. Initialize BB related configurations. */
+	/*  */
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB);
 #if (HAL_BB_ENABLE == 1)
 	status = PHY_BBConfig8192D(padapter);
@@ -2096,15 +2088,15 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BB)
 		pHalData->bReadRFbyFW = false;
 	}
 
-	// 92CU use 3-wire to r/w RF
-	//
-	// e. Initialize RF related configurations.
-	//
-	// 2007/11/02 MH Before initalizing RF. We can not use FW to do RF-R/W.
-	//pHalData->Rf_Mode = RF_OP_By_SW_3wire;
+	/*  92CU use 3-wire to r/w RF */
+	/*  */
+	/*  e. Initialize RF related configurations. */
+	/*  */
+	/*  2007/11/02 MH Before initalizing RF. We can not use FW to do RF-R/W. */
+	/* pHalData->Rf_Mode = RF_OP_By_SW_3wire; */
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF);
 #if (HAL_RF_ENABLE == 1)
-	// set before initialize RF,
+	/*  set before initialize RF, */
 	PHY_SetBBReg(padapter, rFPGA0_AnalogParameter4, 0x00f00000,  0xf);
 
 	status = PHY_RFConfig8192D(padapter);
@@ -2117,7 +2109,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF)
 		goto exit;
 	}
 
-	// set default value after initialize RF,
+	/*  set default value after initialize RF, */
 	PHY_SetBBReg(padapter, rFPGA0_AnalogParameter4, 0x00f00000,  0);
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -2137,7 +2129,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_TUR
 #endif
 		_BBTurnOnBlock(padapter);
 
-	//NicIFSetMacAddress(padapter, padapter->PermanentAddress);
+	/* NicIFSetMacAddress(padapter, padapter->PermanentAddress); */
 
 	if (pHalData->CurrentBandType92D == BAND_ON_5G)
 	{
@@ -2154,34 +2146,34 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INI
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);
 	_RfPowerSave(padapter);
 
-	// HW SEQ CTRL
-	//set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM.
+	/*  HW SEQ CTRL */
+	/* set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM. */
 	rtw_write8(padapter,REG_HWSEQ_CTRL, 0xFF);
 
-	//schmitt trigger ,improve tx evm for 92du,suggested by ynlin  12/03/2010
+	/* schmitt trigger ,improve tx evm for 92du,suggested by ynlin  12/03/2010 */
 	tmpU1b = rtw_read8(padapter, REG_AFE_XTAL_CTRL);
 	tmpU1b |=BIT1;
 	rtw_write8(padapter, REG_AFE_XTAL_CTRL, tmpU1b);
 
-	//disable bar
+	/* disable bar */
 	rtw_write32(padapter, REG_BAR_MODE_CTRL, 0xffff);
 
-	//Nav limit , suggest by scott
+	/* Nav limit , suggest by scott */
 	rtw_write8(padapter, 0x652, 0x0);
-	rtw_write8(padapter, 0xc87, 0x50);//suggest by Jackson for CCA
+	rtw_write8(padapter, 0xc87, 0x50);/* suggest by Jackson for CCA */
 
 #if (MP_DRIVER == 1)
 	padapter->mppriv.channel = pHalData->CurrentChannel;
 	MPT_InitializeAdapter(padapter, padapter->mppriv.channel);
-	//MPT_InitializeAdapter(padapter, Channel);
-#else // temply marked this for RF
+	/* MPT_InitializeAdapter(padapter, Channel); */
+#else /*  temply marked this for RF */
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (!pHalData->bSlaveOfDMSP)
 #endif
 	{
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_IQK);
-		// do IQK for 2.4G for better scan result, if current bandtype is 2.4G.
+		/*  do IQK for 2.4G for better scan result, if current bandtype is 2.4G. */
 		if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 			rtl8192d_PHY_IQCalibrate(padapter);
 
@@ -2194,8 +2186,8 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_LCK
 		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
 			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
-		//5G and 2.4G must wait sometime to let RF LO ready
-		//by sherry 2010.06.28
+		/* 5G and 2.4G must wait sometime to let RF LO ready */
+		/* by sherry 2010.06.28 */
 #if SWLCK == 0
 		{
 			u32 tmpRega, tmpRegb;
@@ -2214,7 +2206,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_LCK
 					tmpRegb = PHY_QueryRFReg(padapter, (enum RF_RADIO_PATH_E)RF_PATH_B, 0x2a, bMaskDWord);
 					if (((tmpRega&BIT11)==BIT11)&&((tmpRegb&BIT11)==BIT11))
 						break;
-					// temply add for DMSP
+					/*  temply add for DMSP */
 					if (pHalData->MacPhyMode92D==DUALMAC_SINGLEPHY&&(pHalData->interfaceIndex!=0))
 						break;
 				}
@@ -2232,45 +2224,23 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INI
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC31);
 
-	rtw_write16(padapter, REG_BCN_CTRL, 0x1818);	// For 2 PORT TSF SYNC
+	rtw_write16(padapter, REG_BCN_CTRL, 0x1818);	/*  For 2 PORT TSF SYNC */
 
 	{
-		//pHalData->LoopbackMode=LOOPBACK_MODE;
-		//if (padapter->ResetProgress == RESET_TYPE_NORESET)
-		//{
-		       u32					ulRegRead;
-			//3//
-			//3//Set Loopback mode or Normal mode
-			//3//
-			//2006.12.13 by emily. Note!We should not merge these two CPU_GEN register writings
-			//	because setting of System_Reset bit reset MAC to default transmission mode.
-			ulRegRead = rtw_read32(padapter, 0x100);	//CPU_GEN  0x100
-
-			//if (pHalData->LoopbackMode == RTL8192SU_NO_LOOPBACK)
-			{
-				ulRegRead |= ulRegRead ;
-			}
-			//else if (pHalData->LoopbackMode == RTL8192SU_MAC_LOOPBACK)
-			//{
-				//RT_TRACE(COMP_INIT, DBG_LOUD, ("==>start loop back mode %x\n",ulRegRead));
-			//	ulRegRead |= 0x0b000000; //0x0b000000 CPU_CCK_LOOPBACK;
-			//}
-			//else if (pHalData->LoopbackMode == RTL8192SU_DMA_LOOPBACK)
-			//{
-				//RT_TRACE(COMP_INIT, DBG_LOUD, ("==>start dule mac loop back mode %x\n",ulRegRead));
-			//	ulRegRead |= 0x07000000; //0x07000000 CPU_CCK_LOOPBACK;
-			//}
-			//else
-			//{
-				//RT_ASSERT(FALSE, ("Serious error: wrong loopback mode setting\n"));
-			//}
-
-			rtw_write32(padapter, 0x100, ulRegRead);
-	              //RT_TRACE(COMP_INIT,DBG_LOUD,("==>loop back mode CPU GEN value:%x\n",ulRegRead));
-
-			// 2006.11.29. After reset cpu, we sholud wait for a second, otherwise, it may fail to write registers. Emily
-			rtw_udelay_os(500);
-		//}
+	       u32					ulRegRead;
+		/* 3  */
+		/* 3 Set Loopback mode or Normal mode */
+		/* 3 */
+		/* 2006.12.13 by emily. Note!We should not merge these two CPU_GEN register writings */
+		/* 	because setting of System_Reset bit reset MAC to default transmission mode. */
+		ulRegRead = rtw_read32(padapter, 0x100);	/* CPU_GEN  0x100 */
+
+		ulRegRead |= ulRegRead;
+
+		rtw_write32(padapter, 0x100, ulRegRead);
+
+		/*  2006.11.29. After reset cpu, we sholud wait for a second, otherwise, it may fail to write registers. Emily */
+		rtw_udelay_os(500);
 	}
 
 	RT_CLEAR_PS_LEVEL(pwrctrlpriv, RT_RF_OFF_LEVL_HALT_NIC);
@@ -2278,19 +2248,19 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 
 	if ((pregistrypriv->lowrate_two_xmit) && (pHalData->MacPhyMode92D != DUALMAC_DUALPHY))
 	{
-		//for Use 2 path Tx to transmit MCS0~7 and legacy mode
-		//Reg90C[30]=1'b0 (OFDM TX by Reg, default PHY parameter)
-		//Reg80C[31]=1'b0 (CCK TX by Reg, default PHYparameter)
-		//RegC8C=0xa0e40000 (OFDM RX weighting)
+		/* for Use 2 path Tx to transmit MCS0~7 and legacy mode */
+		/* Reg90C[30]=1'b0 (OFDM TX by Reg, default PHY parameter) */
+		/* Reg80C[31]=1'b0 (CCK TX by Reg, default PHYparameter) */
+		/* RegC8C=0xa0e40000 (OFDM RX weighting) */
 		rtw_write32(padapter, 0x90C, rtw_read32(padapter, 0x90C)&(~BIT(30)));
 		rtw_write32(padapter, 0x80C, rtw_read32(padapter, 0x80C)&(~BIT(31)));
 		rtw_write32(padapter, 0xC8C, 0xa0e40000);
 	}
 
 #ifdef CONFIG_XMIT_ACK
-	//ack for xmit mgmt frames.
+	/* ack for xmit mgmt frames. */
 	rtw_write32(padapter, REG_FWHW_TXQ_CTRL, rtw_read32(padapter, REG_FWHW_TXQ_CTRL)|BIT(12));
-#endif //CONFIG_XMIT_ACK
+#endif /* CONFIG_XMIT_ACK */
 
 exit:
 	padapter->init_adpt_in_progress = false;
@@ -2321,13 +2291,13 @@ _func_exit_;
 		u16 GPIO_val;
 		GPIO_val = rtw_read16(padapter, REG_GPIO_PIN_CTRL+1);
 		GPIO_val |= BIT(0)|BIT(8);
-		//set GPIO 0 to high for Toshiba
+		/* set GPIO 0 to high for Toshiba */
 		rtw_write16(padapter, REG_GPIO_PIN_CTRL+1, GPIO_val);
 	}
-	//prevent 8051 to be reset by PERST# wake on wlan by Alex & Baron
-	//rtw_write8(padapter, REG_RSV_CTRL, 0x20);
-	//rtw_write8(padapter, REG_RSV_CTRL, 0x60);
-#endif // CONFIG_WOWLAN
+	/* prevent 8051 to be reset by PERST# wake on wlan by Alex & Baron */
+	/* rtw_write8(padapter, REG_RSV_CTRL, 0x20); */
+	/* rtw_write8(padapter, REG_RSV_CTRL, 0x60); */
+#endif /*  CONFIG_WOWLAN */
 	return status;
 }
 
@@ -2338,9 +2308,9 @@ _DisableGPIO(
 	)
 {
 /***************************************
-j. GPIO_PIN_CTRL 0x44[31:0]=0x000		//
+j. GPIO_PIN_CTRL 0x44[31:0]=0x000
 k. Value = GPIO_PIN_CTRL[7:0]
-l.  GPIO_PIN_CTRL 0x44[31:0] = 0x00FF0000 | (value <<8); //write external PIN level
+l.  GPIO_PIN_CTRL 0x44[31:0] = 0x00FF0000 | (value <<8);  write external PIN level
 m. GPIO_MUXCFG 0x42 [15:0] = 0x0780
 n. LEDCFG 0x4C[15:0] = 0x8080
 ***************************************/
@@ -2348,14 +2318,14 @@ n. LEDCFG 0x4C[15:0] = 0x8080
 	u16	value16;
 	u32	value32;
 
-	//1. Disable GPIO[7:0]
+	/* 1. Disable GPIO[7:0] */
 	rtw_write16(Adapter, REG_GPIO_PIN_CTRL+2, 0x0000);
 	value32 = rtw_read32(Adapter, REG_GPIO_PIN_CTRL) & 0xFFFF00FF;
 	value8 = (u8) (value32&0x000000FF);
 	value32 |= ((value8<<8) | 0x00FF0000);
 	rtw_write32(Adapter, REG_GPIO_PIN_CTRL, value32);
 
-	//2. Disable GPIO[10:8]
+	/* 2. Disable GPIO[10:8] */
 	rtw_write8(Adapter, REG_MAC_PINMUX_CFG, 0x00);
 	value16 = rtw_read16(Adapter, REG_GPIO_IO_SEL) & 0xFF0F;
 	value8 = (u8) (value16&0x000F);
@@ -2363,11 +2333,11 @@ n. LEDCFG 0x4C[15:0] = 0x8080
 	rtw_write16(Adapter, REG_GPIO_IO_SEL, value16);
 
 
-	//3. Disable LED0 & 1
+	/* 3. Disable LED0 & 1 */
 	rtw_write16(Adapter, REG_LEDCFG0, 0x8888);
 
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable GPIO and LED.\n"));
-} //end of _DisableGPIO()
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable GPIO and LED.\n")); */
+} /* end of _DisableGPIO() */
 static void
 _ResetFWDownloadRegister(
 	struct rtw_adapter *			Adapter
@@ -2390,7 +2360,7 @@ _DisableRF_AFE(
 	u32			pollingCount = 0;
 	u8			value8;
 
-	//disable RF/ AFE AD/DA
+	/* disable RF/ AFE AD/DA */
 	value8 = APSDOFF;
 	rtw_write8(Adapter, REG_APSD_CTRL, value8);
 
@@ -2400,12 +2370,12 @@ _DisableRF_AFE(
 	do
 	{
 		if (rtw_read8(Adapter, REG_APSD_CTRL) & APSDOFF_STATUS) {
-			//RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE, AD, DA Done!\n"));
+			/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE, AD, DA Done!\n")); */
 			break;
 		}
 
 		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT) {
-			//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling APSDOFF_STATUS done!\n"));
+			/* RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling APSDOFF_STATUS done!\n")); */
 			return _FAIL;
 		}
 
@@ -2413,7 +2383,7 @@ _DisableRF_AFE(
 
 #endif
 
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE,AD, DA.\n"));
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE,AD, DA.\n")); */
 	return rtStatus;
 }
 
@@ -2423,13 +2393,13 @@ _ResetBB(
 	)
 {
 	u16	value16;
-	//before BB reset should do clock gated
+	/* before BB reset should do clock gated */
 	rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
-	//reset BB
+	/* reset BB */
 	value16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);
 	value16 &= ~(FEN_BBRSTB | FEN_BB_GLB_RSTn);
 	rtw_write16(Adapter, REG_SYS_FUNC_EN, value16);
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset BB.\n"));
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset BB.\n")); */
 }
 
 static void
@@ -2439,11 +2409,11 @@ _ResetMCU(
 {
 	u16	value16;
 
-	// reset MCU
+	/*  reset MCU */
 	value16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);
 	value16 &= ~FEN_CPUEN;
 	rtw_write16(Adapter, REG_SYS_FUNC_EN, value16);
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset MCU.\n"));
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset MCU.\n")); */
 }
 
 static void
@@ -2453,14 +2423,14 @@ _DisableMAC_AFE_PLL(
 {
 	u32	value32;
 
-	//disable MAC/ AFE PLL
+	/* disable MAC/ AFE PLL */
 	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
 	value32 |= APDM_MAC;
 	rtw_write32(Adapter, REG_APS_FSMCO, value32);
 
 	value32 |= APFM_OFF;
 	rtw_write32(Adapter, REG_APS_FSMCO, value32);
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable MAC, AFE PLL.\n"));
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable MAC, AFE PLL.\n")); */
 }
 
 static void
@@ -2473,11 +2443,11 @@ _AutoPowerDownToHostOff(
 
 	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
 
-	value32 |= APDM_HOST;//card disable
+	value32 |= APDM_HOST;/* card disable */
 	rtw_write32(Adapter, REG_APS_FSMCO, value32);
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Auto Power Down to Host-off state.\n"));
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Auto Power Down to Host-off state.\n")); */
 
-	// set USB suspend
+	/*  set USB suspend */
 	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
 	value32 &= ~AFSM_PCIE;
 	rtw_write32(Adapter, REG_APS_FSMCO, value32);
@@ -2492,12 +2462,12 @@ _SetUsbSuspend(
 
 	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
 
-	// set USB suspend
+	/*  set USB suspend */
 	value32 |= AFSM_HSUS;
 	rtw_write32(Adapter, REG_APS_FSMCO, value32);
 
-	//RT_ASSERT(0 == (rtw_read32(Adapter, REG_APS_FSMCO) & BIT(12)),(""));
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Set USB suspend.\n"));
+	/* RT_ASSERT(0 == (rtw_read32(Adapter, REG_APS_FSMCO) & BIT(12)),("")); */
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Set USB suspend.\n")); */
 }
 
 static void
@@ -2506,11 +2476,11 @@ _DisableRFAFEAndResetBB8192D(
 	)
 {
 /**************************************
-a.	TXPAUSE 0x522[7:0] = 0xFF             //Pause MAC TX queue
-b.	RF path 0 offset 0x00 = 0x00            // disable RF
+a.	TXPAUSE 0x522[7:0] = 0xFF             Pause MAC TX queue
+b.	RF path 0 offset 0x00 = 0x00            disable RF
 c.	APSD_CTRL 0x600[7:0] = 0x40
-d.	SYS_FUNC_EN 0x02[7:0] = 0x16		//reset BB state machine
-e.	SYS_FUNC_EN 0x02[7:0] = 0x14		//reset BB state machine
+d.	SYS_FUNC_EN 0x02[7:0] = 0x16		reset BB state machine
+e.	SYS_FUNC_EN 0x02[7:0] = 0x14		reset BB state machine
 ***************************************/
        struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
 	u8	eRFPath = 0,value8 = 0;
@@ -2519,31 +2489,31 @@ e.	SYS_FUNC_EN 0x02[7:0] = 0x14		//reset
 	PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, 0x0,bRFRegOffsetMask, 0x0);
 
 	value8 |= APSDOFF;
-	rtw_write8(Adapter, REG_APSD_CTRL, value8);//0x40
+	rtw_write8(Adapter, REG_APSD_CTRL, value8);/* 0x40 */
 
 
-	//testchip  should not do BB reset if another mac is alive;
+	/* testchip  should not do BB reset if another mac is alive; */
 	value8 = 0 ;
 	value8 |=(FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
-	rtw_write8(Adapter, REG_SYS_FUNC_EN,value8);//0x16
+	rtw_write8(Adapter, REG_SYS_FUNC_EN,value8);/* 0x16 */
 
 	if (pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
 	{
 		if (pHalData->interfaceIndex!=0) {
-			//before BB reset should do clock gated
+			/* before BB reset should do clock gated */
 			rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 			value8 &=(~FEN_BB_GLB_RSTn);
-			rtw_write8(Adapter, REG_SYS_FUNC_EN, value8); //0x14
+			rtw_write8(Adapter, REG_SYS_FUNC_EN, value8); /* 0x14 */
 		}
 	}
 	else {
-		//before BB reset should do clock gated
+		/* before BB reset should do clock gated */
 		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 		value8 &=(~FEN_BB_GLB_RSTn);
-		rtw_write8(Adapter, REG_SYS_FUNC_EN, value8); //0x14
+		rtw_write8(Adapter, REG_SYS_FUNC_EN, value8); /* 0x14 */
 	}
 
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> RF off and reset BB.\n"));
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> RF off and reset BB.\n")); */
 }
 
 static void
@@ -2564,29 +2534,29 @@ _ResetDigitalProcedure1(
 	struct hal_data_8192du  *pHalData = GET_HAL_DATA(Adapter);
 
 	u8 retry_cnts = 0;
-	// 2010/08/12 MH For USB SS, we can not stop 8051 when we are trying to
-	// enter IPS/HW&SW radio off. For S3/S4/S5/Disable, we can stop 8051 because
-	// we will init FW when power on again.
-	if (rtw_read8(Adapter, REG_MCUFWDL) & BIT1) { //IF fw in RAM code, do reset
+	/*  2010/08/12 MH For USB SS, we can not stop 8051 when we are trying to */
+	/*  enter IPS/HW&SW radio off. For S3/S4/S5/Disable, we can stop 8051 because */
+	/*  we will init FW when power on again. */
+	if (rtw_read8(Adapter, REG_MCUFWDL) & BIT1) { /* IF fw in RAM code, do reset */
 
 		if (Adapter->bFWReady) {
 			rtw_write8(Adapter, REG_FSIMR, 0x00);
-			// 2010/08/25 MH Accordign to RD alfred's suggestion, we need to disable other
-			// HRCV INT to influence 8051 reset.
+			/*  2010/08/25 MH Accordign to RD alfred's suggestion, we need to disable other */
+			/*  HRCV INT to influence 8051 reset. */
 			rtw_write8(Adapter, REG_FWIMR, 0x20);
-			// 2011/02/15 MH According to Alex's suggestion, close mask to prevent incorrect FW write operation.
+			/*  2011/02/15 MH According to Alex's suggestion, close mask to prevent incorrect FW write operation. */
 			rtw_write8(Adapter, REG_FTIMR, 0x00);
 
 			rtw_write8(Adapter, REG_MCUFWDL, 0);
-			rtw_write8(Adapter, REG_HMETFR+3, 0x20);//8051 reset by self
+			rtw_write8(Adapter, REG_HMETFR+3, 0x20);/* 8051 reset by self */
 
 			while ((retry_cnts++ <100) && (FEN_CPUEN &rtw_read16(Adapter, REG_SYS_FUNC_EN)))
-				rtw_udelay_os(50);//us
+				rtw_udelay_os(50);/* us */
 
 			if (retry_cnts>= 100) {
 				rtw_write8(Adapter, REG_FWIMR, 0x00);
-				// 2010/08/31 MH According to Filen's info, if 8051 reset fail, reset MAC directly.
-				rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x50);	//Reset MAC and Enable 8051
+				/*  2010/08/31 MH According to Filen's info, if 8051 reset fail, reset MAC directly. */
+				rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x50);	/* Reset MAC and Enable 8051 */
 				rtw_mdelay_os(10);
 			} else {
 				DBG_8192D("=====> 8051 reset success (%d) .\n",retry_cnts);
@@ -2604,24 +2574,24 @@ _ResetDigitalProcedure1(
 	}
 	#endif
 
-	rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x54);	//Reset MAC and Enable 8051
+	rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x54);	/* Reset MAC and Enable 8051 */
 	rtw_write8(Adapter, REG_MCUFWDL, 0);
 
 	if (bWithoutHWSM) {
 	/*****************************
 		Without HW auto state machine
-	g.	SYS_CLKR 0x08[15:0] = 0x30A3			//disable MAC clock
-	h.	AFE_PLL_CTRL 0x28[7:0] = 0x80			//disable AFE PLL
-	i.	AFE_XTAL_CTRL 0x24[15:0] = 0x880F		//gated AFE DIG_CLOCK
-	j.	SYS_ISO_CTRL 0x00[7:0] = 0xF9			// isolated digital to PON
+	g.	SYS_CLKR 0x08[15:0] = 0x30A3			disable MAC clock
+	h.	AFE_PLL_CTRL 0x28[7:0] = 0x80			disable AFE PLL
+	i.	AFE_XTAL_CTRL 0x24[15:0] = 0x880F		gated AFE DIG_CLOCK
+	j.	SYS_ISO_CTRL 0x00[7:0] = 0xF9			isolated digital to PON
 	******************************/
-		//rtw_write16(Adapter, REG_SYS_CLKR, 0x30A3);
-		rtw_write16(Adapter, REG_SYS_CLKR, 0x70A3);//modify to 0x70A3 by Scott.
+		/* rtw_write16(Adapter, REG_SYS_CLKR, 0x30A3); */
+		rtw_write16(Adapter, REG_SYS_CLKR, 0x70A3);/* modify to 0x70A3 by Scott. */
 		rtw_write8(Adapter, REG_AFE_PLL_CTRL, 0x80);
 		rtw_write16(Adapter, REG_AFE_XTAL_CTRL, 0x880F);
 		rtw_write8(Adapter, REG_SYS_ISO_CTRL, 0xF9);
 	}
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Reset Digital.\n"));
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Reset Digital.\n")); */
 }
 
 static void
@@ -2630,16 +2600,12 @@ _ResetDigitalProcedure2(
 )
 {
 /*****************************
-k.	SYS_FUNC_EN 0x03[7:0] = 0x44			// disable ELDR runction
-l.	SYS_CLKR 0x08[15:0] = 0x3083			// disable ELDR clock
-m.	SYS_ISO_CTRL 0x01[7:0] = 0x83			// isolated ELDR to PON
+k.	SYS_FUNC_EN 0x03[7:0] = 0x44			disable ELDR runction
+l.	SYS_CLKR 0x08[15:0] = 0x3083			disable ELDR clock
+m.	SYS_ISO_CTRL 0x01[7:0] = 0x83			isolated ELDR to PON
 ******************************/
-	//rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x44);//marked by Scott.
-	//rtw_write16(Adapter, REG_SYS_CLKR, 0x3083);
-	//rtw_write8(Adapter, REG_SYS_ISO_CTRL+1, 0x83);
-
-	rtw_write16(Adapter, REG_SYS_CLKR, 0x70a3); //modify to 0x70a3 by Scott.
-	rtw_write8(Adapter, REG_SYS_ISO_CTRL+1, 0x82); //modify to 0x82 by Scott.
+	rtw_write16(Adapter, REG_SYS_CLKR, 0x70a3); /* modify to 0x70a3 by Scott. */
+	rtw_write8(Adapter, REG_SYS_ISO_CTRL+1, 0x82); /* modify to 0x82 by Scott. */
 }
 
 static void
@@ -2653,32 +2619,32 @@ _DisableAnalog(
 
 	if (bWithoutHWSM) {
 	/*****************************
-	n.	LDOA15_CTRL 0x20[7:0] = 0x04		// disable A15 power
-	o.	LDOV12D_CTRL 0x21[7:0] = 0x54		// disable digital core power
+	n.	LDOA15_CTRL 0x20[7:0] = 0x04		disable A15 power
+	o.	LDOV12D_CTRL 0x21[7:0] = 0x54		disable digital core power
 	r.	When driver call disable, the ASIC will turn off remaining clock automatically
 	******************************/
 
 		rtw_write8(Adapter, REG_LDOA15_CTRL, 0x04);
-		//PlatformIOWrite1Byte(Adapter, REG_LDOV12D_CTRL, 0x54);
+		/* PlatformIOWrite1Byte(Adapter, REG_LDOV12D_CTRL, 0x54); */
 
 		value8 = rtw_read8(Adapter, REG_LDOV12D_CTRL);
 		value8 &= (~LDV12_EN);
 		rtw_write8(Adapter, REG_LDOV12D_CTRL, value8);
-		//RT_TRACE(COMP_INIT, DBG_LOUD, (" REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8));
+		/* RT_TRACE(COMP_INIT, DBG_LOUD, (" REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8)); */
 	}
 
 /*****************************
-h.	SPS0_CTRL 0x11[7:0] = 0x23			//enter PFM mode
-i.	APS_FSMCO 0x04[15:0] = 0x4802		// set USB suspend
+h.	SPS0_CTRL 0x11[7:0] = 0x23		enter PFM mode
+i.	APS_FSMCO 0x04[15:0] = 0x4802		set USB suspend
 ******************************/
 	rtw_write8(Adapter, REG_SPS0_CTRL, 0x23);
 
 	value16 |= (APDM_HOST | AFSM_HSUS |PFM_ALDN);
-	rtw_write16(Adapter, REG_APS_FSMCO,value16);//0x4802
+	rtw_write16(Adapter, REG_APS_FSMCO,value16);/* 0x4802 */
 
 	rtw_write8(Adapter, REG_RSV_CTRL, 0x0e);
 
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable Analog Reg0x04:0x%04x.\n",value16));
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable Analog Reg0x04:0x%04x.\n",value16)); */
 }
 
 static bool
@@ -2707,7 +2673,7 @@ CanGotoPowerOff92D(
 #endif
 
 	if (pHalData->interfaceIndex==0)
-	{	// query another mac status;
+	{	/*  query another mac status; */
 		u1bTmp = rtw_read8(Adapter, REG_MAC1);
 		u1bTmp&=MAC1_ON;
 	}
@@ -2717,15 +2683,15 @@ CanGotoPowerOff92D(
 		u1bTmp&=MAC0_ON;
 	}
 
-	//0x17[7]:1b' power off in process
+	/* 0x17[7]:1b' power off in process */
 	u1bTmp=rtw_read8(Adapter, 0x17);
 	u1bTmp|=BIT7;
 	rtw_write8(Adapter, 0x17, u1bTmp);
 
 	rtw_udelay_os(500);
-	// query another mac status;
+	/*  query another mac status; */
 	if (pHalData->interfaceIndex==0)
-	{	// query another mac status;
+	{	/*  query another mac status; */
 		u1bTmp = rtw_read8(Adapter, REG_MAC1);
 		u1bTmp&=MAC1_ON;
 	}
@@ -2734,7 +2700,7 @@ CanGotoPowerOff92D(
 		u1bTmp = rtw_read8(Adapter, REG_MAC0);
 		u1bTmp&=MAC0_ON;
 	}
-	//if another mac is alive,do not do power off
+	/* if another mac is alive,do not do power off */
 	if (u1bTmp)
 	{
 		u1bTmp=rtw_read8(Adapter, 0x17);
@@ -2746,7 +2712,7 @@ CanGotoPowerOff92D(
 }
 
 static int
-CardDisableHWSM(// HW Auto state machine
+CardDisableHWSM(/*  HW Auto state machine */
 	struct rtw_adapter *		Adapter,
 	bool			resetMCU
 	)
@@ -2763,7 +2729,7 @@ CardDisableHWSM(// HW Auto state machine
 	rtw_udelay_os(500);
 	rtw_write8(Adapter,	REG_CR, 0x0);
 
-	//==== RF Off Sequence ====
+	/*  RF Off Sequence ==== */
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
 #endif
@@ -2772,18 +2738,18 @@ CardDisableHWSM(// HW Auto state machine
 	if (!PHY_CheckPowerOffFor8192D(Adapter))
 		return rtStatus;
 
-	//0x20:value 05-->04
+	/* 0x20:value 05-->04 */
 	rtw_write8(Adapter, REG_LDOA15_CTRL,0x04);
-	//RF Control
+	/* RF Control */
 	rtw_write8(Adapter, REG_RF_CTRL,0);
 
-	//  ==== Reset digital sequence   ======
+	/*   ==== Reset digital sequence   ====== */
 	_ResetDigitalProcedure1(Adapter, false);
 
-	//  ==== Pull GPIO PIN to balance level and LED control ======
+	/*   ==== Pull GPIO PIN to balance level and LED control ====== */
 	_DisableGPIO(Adapter);
 
-	//  ==== Disable analog sequence ===
+	/*   ==== Disable analog sequence === */
 	_DisableAnalog(Adapter, false);
 
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
@@ -2798,7 +2764,7 @@ CardDisableHWSM(// HW Auto state machine
 }
 
 static int
-CardDisableWithoutHWSM(// without HW Auto state machine
+CardDisableWithoutHWSM(/*  without HW Auto state machine */
 	struct rtw_adapter *		Adapter
 	)
 {
@@ -2814,13 +2780,13 @@ CardDisableWithoutHWSM(// without HW Aut
 	rtw_udelay_os(500);
 	rtw_write8(Adapter,	REG_CR, 0x0);
 
-	//==== RF Off Sequence ====
+	/*  RF Off Sequence ==== */
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	if (!pHalData->bSlaveOfDMSP || Adapter->DualMacConcurrent == false)
 #endif
 		_DisableRFAFEAndResetBB(Adapter);
 
-	// stop tx/rx
+	/*  stop tx/rx */
 	rtw_write8(Adapter, REG_TXPAUSE, 0xFF);
 	rtw_udelay_os(500);
 	rtw_write8(Adapter,	REG_CR, 0x0);
@@ -2830,25 +2796,25 @@ CardDisableWithoutHWSM(// without HW Aut
 		return rtStatus;
 	}
 
-	//0x20:value 05-->04
+	/* 0x20:value 05-->04 */
 	rtw_write8(Adapter, REG_LDOA15_CTRL,0x04);
-	//RF Control
+	/* RF Control */
 	rtw_write8(Adapter, REG_RF_CTRL,0);
 
-	//  ==== Reset digital sequence   ======
+	/*   ==== Reset digital sequence   ====== */
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	_ResetDigitalProcedure1(Adapter, false);
 #else
 	_ResetDigitalProcedure1(Adapter,true);
 #endif
 
-	//  ==== Pull GPIO PIN to balance level and LED control ======
+	/*   ==== Pull GPIO PIN to balance level and LED control ====== */
 	_DisableGPIO(Adapter);
 
-	//  ==== Reset digital sequence   ======
+	/*   ==== Reset digital sequence   ====== */
 	_ResetDigitalProcedure2(Adapter);
 
-	//  ==== Disable analog sequence ===
+	/*   ==== Disable analog sequence === */
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	_DisableAnalog(Adapter,false);
 #else
@@ -2861,7 +2827,7 @@ CardDisableWithoutHWSM(// without HW Aut
 	rtw_write8(Adapter, REG_POWER_OFF_IN_PROCESS, value);
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
 
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("<====== Card Disable Without HWSM .\n"));
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("<====== Card Disable Without HWSM .\n")); */
 	return rtStatus;
 }
 
@@ -2894,12 +2860,12 @@ _func_enter_;
 			CardDisableWithoutHWSM(padapter);
 	} else {
 
-		// Wake on WLAN
+		/*  Wake on WLAN */
 	}
 
 	if (pHalData->bInSetPower)
 	{
-		//0xFE10[4] clear before suspend	 suggested by zhouzhou
+		/* 0xFE10[4] clear before suspend	 suggested by zhouzhou */
 		u1bTmp=rtw_read8(padapter,0xfe10);
 		u1bTmp&=(~BIT4);
 		rtw_write8(padapter,0xfe10,u1bTmp);
@@ -2938,7 +2904,7 @@ _func_enter_;
 
 	precvpriv->ff_hwaddr = RECV_BULK_IN_ADDR;
 
-	//issue Rx irp to receive data
+	/* issue Rx irp to receive data */
 	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
 	for (i=0; i<NR_RECVBUFF; i++)
 	{
@@ -2983,11 +2949,11 @@ unsigned int rtl8192du_inirp_deinit(stru
 	return _SUCCESS;
 }
 
-//-------------------------------------------------------------------
-//
-//	EEPROM/EFUSE Content Parsing
-//
-//-------------------------------------------------------------------
+/*  */
+/*  */
+/* 	EEPROM/EFUSE Content Parsing */
+/*  */
+/*  */
 
 static void
 _ReadPROMVersion(
@@ -3008,16 +2974,15 @@ _ReadPROMVersion(
 
 u32 _GetChannelGroup(u32 channel)
 {
-	//RT_ASSERT((channel < 14), ("Channel %d no is supported!\n"));
 
-	if (channel < 3) {	// Channel 1~3
+	if (channel < 3) {	/*  Channel 1~3 */
 		return 0;
 	}
-	else if (channel < 9) { // Channel 4~9
+	else if (channel < 9) { /*  Channel 4~9 */
 		return 1;
 	}
 
-	return 2;				// Channel 10~14
+	return 2;				/*  Channel 10~14 */
 }
 
 static void
@@ -3031,11 +2996,11 @@ _ReadIDs(
 
 
 	if (false == AutoloadFail) {
-		// VID, PID
+		/*  VID, PID */
 		pHalData->EEPROMVID = le16_to_cpu(*(u16 *)&PROMContent[EEPROM_VID]);
 		pHalData->EEPROMPID = le16_to_cpu(*(u16 *)&PROMContent[EEPROM_PID]);
 
-		// Customer ID, 0x00 and 0xff are reserved for Realtek.
+		/*  Customer ID, 0x00 and 0xff are reserved for Realtek. */
 		pHalData->EEPROMCustomerID = *(u8 *)&PROMContent[EEPROM_CUSTOMER_ID];
 		pHalData->EEPROMSubCustomerID = *(u8 *)&PROMContent[EEPROM_SUBCUSTOMER_ID];
 
@@ -3044,32 +3009,19 @@ _ReadIDs(
 		pHalData->EEPROMVID	 = EEPROM_Default_VID;
 		pHalData->EEPROMPID	 = EEPROM_Default_PID;
 
-		// Customer ID, 0x00 and 0xff are reserved for Realtek.
+		/*  Customer ID, 0x00 and 0xff are reserved for Realtek. */
 		pHalData->EEPROMCustomerID	= EEPROM_Default_CustomerID;
 		pHalData->EEPROMSubCustomerID = EEPROM_Default_SubCustomerID;
 
 	}
 
-	//	Decide CustomerID according to VID/DID or EEPROM
-	switch (pHalData->EEPROMCustomerID)
-	{
-		case EEPROM_CID_WHQL:
-			//Adapter->bInHctTest = true;
-
-			//pMgntInfo->bSupportTurboMode = false;
-			//pMgntInfo->bAutoTurboBy8186 = false;
-
-			//pMgntInfo->PowerSaveControl.bInactivePs = false;
-			//pMgntInfo->PowerSaveControl.bIPSModeBackup = false;
-			//pMgntInfo->PowerSaveControl.bLeisurePs = false;
-			//pMgntInfo->keepAliveLevel = 0;
-
-			//Adapter->bUnloadDriverwhenS3S4 = false;
-			break;
-		default:
-			pHalData->CustomerID = RT_CID_DEFAULT;
-			break;
-
+	/* 	Decide CustomerID according to VID/DID or EEPROM */
+	switch (pHalData->EEPROMCustomerID) {
+	case EEPROM_CID_WHQL:
+		break;
+	default:
+		pHalData->CustomerID = RT_CID_DEFAULT;
+		break;
 	}
 
 	DBG_8192D("EEPROMVID = 0x%04x\n", pHalData->EEPROMVID);
@@ -3088,46 +3040,37 @@ _ReadMACAddress(
 	struct hal_data_8192du 		*pHalData = GET_HAL_DATA(Adapter);
 	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
 
-	// Dual MAC should assign diffrent MAC address ,or, it is wil cause hang in single phy mode  zhiyuan 04/07/2010
-	//Temply random assigh mac address for  efuse mac address not ready now
+	/*  Dual MAC should assign diffrent MAC address ,or, it is wil cause hang in single phy mode  zhiyuan 04/07/2010 */
+	/* Temply random assigh mac address for  efuse mac address not ready now */
 	if (AutoloadFail == false ) {
 		if (pHalData->interfaceIndex == 0) {
-			//change to use memcpy, in order to avoid alignment issue. Baron 2011/6/20
+			/* change to use memcpy, in order to avoid alignment issue. Baron 2011/6/20 */
 			memcpy(&pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR_MAC0_92D], ETH_ALEN);
 		}
 		else {
-			//change to use memcpy, in order to avoid alignment issue. Baron 2011/6/20
+			/* change to use memcpy, in order to avoid alignment issue. Baron 2011/6/20 */
 			memcpy(&pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR_MAC1_92D], ETH_ALEN);
 		}
 
 		if (is_broadcast_mac_addr(pEEPROM->mac_addr) || is_multicast_mac_addr(pEEPROM->mac_addr))
 		{
-			//Random assigh MAC address
+			/* Random assigh MAC address */
 			u8 sMacAddr[MAC_ADDR_LEN] = {0x00, 0xE0, 0x4C, 0x81, 0x92, 0x00};
-			//u32	curtime = rtw_get_current_time();
-			if (pHalData->interfaceIndex == 1) {
+			if (pHalData->interfaceIndex == 1)
 				sMacAddr[5] = 0x01;
-				//sMacAddr[5] = (u8)(curtime & 0xff);
-				//sMacAddr[5] = (u8)GetRandomNumber(1, 254);
-			}
 			memcpy(pEEPROM->mac_addr, sMacAddr, ETH_ALEN);
 		}
 	}
 	else
 	{
-		//Random assigh MAC address
+		/* Random assigh MAC address */
 		u8 sMacAddr[MAC_ADDR_LEN] = {0x00, 0xE0, 0x4C, 0x81, 0x92, 0x00};
-		//u32	curtime = rtw_get_current_time();
 		if (pHalData->interfaceIndex == 1) {
 			sMacAddr[5] = 0x01;
-			//sMacAddr[5] = (u8)(curtime & 0xff);
-			//sMacAddr[5] = (u8)GetRandomNumber(1, 254);
 		}
 		memcpy(pEEPROM->mac_addr, sMacAddr, ETH_ALEN);
 	}
 
-	//NicIFSetMacAddress(Adapter, Adapter->PermanentAddress);
-	//RT_PRINT_ADDR(COMP_INIT|COMP_EFUSE, DBG_LOUD, "MAC Addr: %s", Adapter->PermanentAddress);
 	DBG_8192D("MAC Address from EFUSE = %pM\n", pEEPROM->mac_addr);
 }
 
@@ -3183,7 +3126,7 @@ hal_ReadMacPhyMode_92D(
 {
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
-#endif //CONFIG_DUALMAC_CONCURRENT
+#endif /* CONFIG_DUALMAC_CONCURRENT */
 	u8	Mac1EnableValue = 0;
 
 
@@ -3199,10 +3142,9 @@ hal_ReadMacPhyMode_92D(
 	}
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-//SMSP-->DMDP/DMSP wait for another adapter compeletes mode switc
-	//CheckInModeSwitchProcess(Adapter);
+/* SMSP-->DMDP/DMSP wait for another adapter compeletes mode switc */
 
-//get Dual Mac Mode from 0x2C for test chip and 0xF8 for normal chip
+/* get Dual Mac Mode from 0x2C for test chip and 0xF8 for normal chip */
 	ACQUIRE_GLOBAL_MUTEX(GlobalCounterForMutex);
 	if (GlobalFirstConfigurationForNormalChip)
 	{
@@ -3257,7 +3199,7 @@ _ReadLEDSetting(
 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
 	struct led_priv		*pledpriv = &(Adapter->ledpriv);
 
-	// Led mode
+	/*  Led mode */
 	switch (pHalData->CustomerID)
 	{
 		case RT_CID_DEFAULT:
@@ -3286,13 +3228,13 @@ _ReadWOWLAN(
 		Adapter->pwrctrlpriv.bSupportRemoteWakeup = false;
 	else
 	{
-		// decide hw if support remote wakeup function
-		// if hw supported, 8051 (SIE) will generate WeakUP signal(D+/D- toggle) when autoresume
+		/*  decide hw if support remote wakeup function */
+		/*  if hw supported, 8051 (SIE) will generate WeakUP signal(D+/D- toggle) when autoresume */
 		Adapter->pwrctrlpriv.bSupportRemoteWakeup = (PROMContent[EEPROM_Option_Setting] & BIT1)?true :false;
 		DBG_8192D("efuse remote wakeup =%d\n", Adapter->pwrctrlpriv.bSupportRemoteWakeup);
 	}
 }
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 
 static void _InitAdapterVariablesByPROM(
 	struct rtw_adapter *	Adapter,
@@ -3310,7 +3252,7 @@ static void _InitAdapterVariablesByPROM(
 	_ReadLEDSetting(Adapter, PROMContent, AutoloadFail);
 #ifdef CONFIG_WOWLAN
 	_ReadWOWLAN(Adapter, PROMContent, AutoloadFail);
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 }
 
 static void _ReadPROMContent(
@@ -3323,7 +3265,7 @@ static void _ReadPROMContent(
 	u32			i;
 
 	eeValue = rtw_read8(Adapter, REG_9346CR);
-	// To check system boot selection.
+	/*  To check system boot selection. */
 	pEEPROM->EepromOrEfuse		= (eeValue & BOOT_FROM_EEPROM) ? true : false;
 	pEEPROM->bautoload_fail_flag	= (eeValue & EEPROM_EN) ? false : true;
 
@@ -3331,30 +3273,19 @@ static void _ReadPROMContent(
 	DBG_8192D("Boot from %s, Autoload %s !\n", (pEEPROM->EepromOrEfuse ? "EEPROM" : "EFUSE"),
 				(pEEPROM->bautoload_fail_flag ? "Fail" : "OK"));
 
-	//pHalData->EEType = (pEEPROM->EepromOrEfuse == true) ? EEPROM_93C46 : EEPROM_BOOT_EFUSE;
 
-	if (pEEPROM->bautoload_fail_flag == false)
-	{
-		if (pEEPROM->EepromOrEfuse == true)
-		{
-			// Read all Content from EEPROM or EFUSE.
-			for (i = 0; i < HWSET_MAX_SIZE; i += 2)
-			{
-				//todo:
-				//value16 = EF2Byte(ReadEEprom(Adapter, (u16) (i>>1)));
-				//*((u16*)(&PROMContent[i])) = value16;
-			}
-		}
-		else
-		{
-			// Read EFUSE real map to shadow.
+	if (pEEPROM->bautoload_fail_flag == false) {
+		if (pEEPROM->EepromOrEfuse == true) {
+			/*  Read all Content from EEPROM or EFUSE. */
+		} else {
+			/*  Read EFUSE real map to shadow. */
 			ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
 			EFUSE_ShadowMapUpdate(Adapter, EFUSE_WIFI, false);
 			RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
 			memcpy((void*)PROMContent, (void*)pEEPROM->efuse_eeprom_data, HWSET_MAX_SIZE);
 		}
 
-		//Double check 0x8192 autoload status again
+		/* Double check 0x8192 autoload status again */
 		if (RTL8192_EEPROM_ID != le16_to_cpu(*((u16 *)PROMContent)))
 		{
 			pEEPROM->bautoload_fail_flag = true;
@@ -3362,7 +3293,7 @@ static void _ReadPROMContent(
 		}
 
 	}
-	else if (pEEPROM->EepromOrEfuse == false)//auto load fail
+	else if (pEEPROM->EepromOrEfuse == false)/* auto load fail */
 	{
 		memset(pEEPROM->efuse_eeprom_data, 0xff, HWSET_MAX_SIZE);
 		memcpy((void*)PROMContent, (void*)pEEPROM->efuse_eeprom_data, HWSET_MAX_SIZE);
@@ -3380,16 +3311,10 @@ _InitOtherVariable(
 {
 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
 
-	//if (Adapter->bInHctTest) {
-	//	pMgntInfo->PowerSaveControl.bInactivePs = false;
-	//	pMgntInfo->PowerSaveControl.bIPSModeBackup = false;
-	//	pMgntInfo->PowerSaveControl.bLeisurePs = false;
-	//	pMgntInfo->keepAliveLevel = 0;
-	//}
-
-	// 2009/06/10 MH For 92S 1*1=1R/ 1*2&2*2 use 2R. We default set 1*1 use radio A
-	// So if you want to use radio B. Please modify RF path enable bit for correct signal
-	// strength calculate.
+
+	/*  2009/06/10 MH For 92S 1*1=1R/ 1*2&2*2 use 2R. We default set 1*1 use radio A */
+	/*  So if you want to use radio B. Please modify RF path enable bit for correct signal */
+	/*  strength calculate. */
 	if (pHalData->rf_type == RF_1T1R) {
 		pHalData->bRFPathRxEnable[0] = true;
 	}
@@ -3418,13 +3343,12 @@ static int _ReadAdapterInfo8192DU(struct
 
 	DBG_8192D("====> %s\n", __func__);
 
-	//rtl8192d_ReadChipVersion(Adapter);
 	_ReadRFType(Adapter);
 	_ReadPROMContent(Adapter);
 
 	_InitOtherVariable(Adapter);
 
-	//For 92DU Phy and Mac mode set ,will initialize by EFUSE/EPPROM     zhiyuan 2010/03/25
+	/* For 92DU Phy and Mac mode set ,will initialize by EFUSE/EPPROM     zhiyuan 2010/03/25 */
 	DBG_8192D("<==== %s in %d ms\n", __func__, rtw_get_passing_time_ms(start));
 
 	return _SUCCESS;
@@ -3432,8 +3356,7 @@ static int _ReadAdapterInfo8192DU(struct
 
 static void ReadAdapterInfo8192DU(struct rtw_adapter * Adapter)
 {
-	// Read EEPROM size before call any EEPROM function
-	//Adapter->EepromAddressSize=Adapter->HalFunc.GetEEPROMSizeHandler(Adapter);
+	/*  Read EEPROM size before call any EEPROM function */
 	Adapter->EepromAddressSize = GetEEPROMSize8192D(Adapter);
 
 	_ReadAdapterInfo8192DU(Adapter);
@@ -3461,7 +3384,6 @@ StopTxBeacon(
 {
 	struct hal_data_8192du *	pHalData = GET_HAL_DATA(Adapter);
 
-	//PlatformScheduleWorkItem(&pHalData->StopTxBeaconWorkItem);
 
 	DBG_8192D("StopTxBeacon\n");
 
@@ -3469,7 +3391,6 @@ StopTxBeacon(
 	pHalData->RegFwHwTxQCtrl &= (~BIT6);
 	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xff);
 	rtw_write8(Adapter, REG_TBTT_PROHIBIT+1, 0x64);
-	//CheckFwRsvdPageContent(Adapter);  // 2010.06.23. Added by tynli.
 }
 
 static void
@@ -3479,7 +3400,6 @@ ResumeTxBeacon(
 {
 	struct hal_data_8192du *	pHalData = GET_HAL_DATA(Adapter);
 
-	//PlatformScheduleWorkItem(&pHalData->ResumeTxBeaconWorkItem);
 
 	DBG_8192D("ResumeTxBeacon\n");
 
@@ -3489,9 +3409,9 @@ ResumeTxBeacon(
 	rtw_write8(Adapter, REG_TBTT_PROHIBIT+1, 0x64);
 }
 
-//
-// 2010.11.17. Added by tynli.
-//
+/*  */
+/*  2010.11.17. Added by tynli. */
+/*  */
 u8 SelectRTSInitialRate(struct rtw_adapter *Adapter)
 {
 	struct sta_info		*psta;
@@ -3503,11 +3423,8 @@ u8 SelectRTSInitialRate(struct rtw_adapt
 	u8	bUseProtection;
 	u16	BasicRateCfg=0;
 	u8	SupportRateSet[NDIS_802_11_LENGTH_RATES_EX];
-	u8	RTSRateIndex=0; // 1M
+	u8	RTSRateIndex=0; /*  1M */
 	u8	LowestRateIdx=0;
-	//u8	TempRateIdx=0;
-	//u8	i;
-
 
 	psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
 	if (psta == NULL)
@@ -3523,63 +3440,39 @@ u8 SelectRTSInitialRate(struct rtw_adapt
 	halsetbratecfg(Adapter, SupportRateSet, &BasicRateCfg);
 
 	if (bUseProtection &&
-		(!(pmlmeext->cur_wireless_mode == WIRELESS_11A|| pmlmeext->cur_wireless_mode == WIRELESS_11A_5N)))// 5G not support cck rate
+		(!(pmlmeext->cur_wireless_mode == WIRELESS_11A|| pmlmeext->cur_wireless_mode == WIRELESS_11A_5N)))/*  5G not support cck rate */
 	{
-		// Use CCK rate
-		BasicRateCfg &= 0xf; //CCK rate
+		/*  Use CCK rate */
+		BasicRateCfg &= 0xf; /* CCK rate */
 		while (BasicRateCfg > 0x1)
 		{
 			BasicRateCfg = (BasicRateCfg>> 1);
 			RTSRateIndex++;
 		}
 	}
-	else //if (pMgntInfo->pHTInfo->CurrentOpMode)
+	else /* if (pMgntInfo->pHTInfo->CurrentOpMode) */
 	{
-		//MacId 0: INFRA mode.
+		/* MacId 0: INFRA mode. */
 		if ((check_fwstate(pmlmepriv, _FW_LINKED)== true)&&(check_fwstate(pmlmepriv, WIFI_STATION_STATE)==true))
 		{
 			LowestRateIdx = rtw_read8(Adapter, REG_INIDATA_RATE_SEL)&0x3f;
 		}
 
-		//Todo: for AP mode and IBSS mode.
-		/*for (i = 0; i < ASSOCIATE_ENTRY_NUM; i++)
+		/*  Adjust RTS Init rate when the data rate is MCS0~2, 8~10 which is lower than 24M. */
+		if (LowestRateIdx == 12 || LowestRateIdx == 20) /* MCS0, MCS8 */
 		{
-			if (AsocEntry[i].bUsed && AsocEntry[i].bAssociated)
-			{
-				//Get the lowest data rate.
-				if (AsocEntry[i].AID != 0)
-				{
-					TempRateIdx = rtw_read8(Adapter, REG_INIDATA_RATE_SEL+4*(AsocEntry[i].AID+1));
-					TempRateIdx &= 0x3f; // bit 0-5: rate index
-
-					if (TempRateIdx < LowestRateIdx)
-						LowestRateIdx = TempRateIdx;
-				}
-			}
-		}*/
-
-		// Adjust RTS Init rate when the data rate is MCS0~2, 8~10 which is lower than 24M.
-		if (LowestRateIdx == 12 || LowestRateIdx == 20) //MCS0, MCS8
-		{
-			RTSRateIndex = 4; // 6M
+			RTSRateIndex = 4; /*  6M */
 		}
 		else if (LowestRateIdx == 13 || LowestRateIdx == 14 ||
-			LowestRateIdx == 21 || LowestRateIdx == 22) //MCS1, MCS2, MCS9, MCS10
+			LowestRateIdx == 21 || LowestRateIdx == 22) /* MCS1, MCS2, MCS9, MCS10 */
 		{
-			RTSRateIndex = 6; // 12M
+			RTSRateIndex = 6; /*  12M */
 		}
 		else
 		{
-			//if ((pmlmeext->cur_wireless_mode == WIRELESS_11BG_24N) &&
-				//(!pMgntInfo->pHTInfo->bCurSuppCCK) &&
-			//	(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40))
-			//{
-			//	BasicRateCfg &= 0xfff0; //disable CCK
-			//}
-
 			if (BasicRateCfg != 0)
 			{
-				// Select RTS Init rate
+				/*  Select RTS Init rate */
 				while (BasicRateCfg > 0x1)
 				{
 					BasicRateCfg = (BasicRateCfg>> 1);
@@ -3588,20 +3481,20 @@ u8 SelectRTSInitialRate(struct rtw_adapt
 			}
 			else
 			{
-				RTSRateIndex = 4; // 6M
+				RTSRateIndex = 4; /*  6M */
 			}
 		}
 
 	}
 
-	//Set RTS init rate to Hw.
+	/* Set RTS init rate to Hw. */
 	return RTSRateIndex;
 }
 
-//
-// Description: Selcet the RTS init rate and set the rate to HW.
-// 2010.11.25. Created by tynli.
-//
+/*  */
+/*  Description: Selcet the RTS init rate and set the rate to HW. */
+/*  2010.11.25. Created by tynli. */
+/*  */
 void SetRTSRateWorkItemCallback(void *pContext)
 {
 	struct rtw_adapter *Adapter =  (struct rtw_adapter *)pContext;
@@ -3627,15 +3520,15 @@ static void hw_var_set_opmode(struct rtw
 #ifdef CONFIG_CONCURRENT_MODE
 	if (Adapter->iface_type == IFACE_PORT1)
 	{
-		// disable Port1 TSF update
+		/*  disable Port1 TSF update */
 		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
 
-		// set net_type
+		/*  set net_type */
 		val8 = rtw_read8(Adapter, MSR)&0x03;
 		val8 |= (mode<<2);
 		rtw_write8(Adapter, MSR, val8);
 
-		//reset TSF1
+		/* reset TSF1 */
 		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1));
 
 		DBG_8192D("%s()-%d mode = %d\n", __func__, __LINE__, mode);
@@ -3647,8 +3540,7 @@ static void hw_var_set_opmode(struct rtw
 				StopTxBeacon(Adapter);
 			}
 
-			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x19);//disable atim wnd
-			//rtw_write8(Adapter,REG_BCN_CTRL_1, 0x18);
+			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x19);/* disable atim wnd */
 		}
 		else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
 		{
@@ -3661,26 +3553,24 @@ static void hw_var_set_opmode(struct rtw
 
 			rtw_write8(Adapter, REG_BCN_CTRL_1, 0x12);
 
-			//Set RCR
-			//rtw_write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0
-			rtw_write32(Adapter, REG_RCR, 0x7000228e);//CBSSID_DATA must set to 0
-			//enable to rx data frame
+			/* Set RCR */
+			rtw_write32(Adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
+			/* enable to rx data frame */
 			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
-			//enable to rx ps-poll
+			/* enable to rx ps-poll */
 			rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
 
-			//Beacon Control related register for first time
-			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms
-			rtw_write8(Adapter, REG_DRVERLYINT, 0x05);// 5ms
-			//rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
-			rtw_write8(Adapter, REG_ATIMWND_1, 0x0a); // 10ms for port1
+			/* Beacon Control related register for first time */
+			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); /*  2ms */
+			rtw_write8(Adapter, REG_DRVERLYINT, 0x05);/*  5ms */
+			rtw_write8(Adapter, REG_ATIMWND_1, 0x0a); /*  10ms for port1 */
 			rtw_write16(Adapter, REG_BCNTCFG, 0x00);
 			rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);
-			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);// +32767 (~32ms)
+			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);/*  +32767 (~32ms) */
 
 
-		       //enable BCN1 Function for if2
-			//don't enable update TSF1 for if2 (due to TSF update when beacon/probe rsp are received)
+		       /* enable BCN1 Function for if2 */
+			/* don't enable update TSF1 for if2 (due to TSF update when beacon/probe rsp are received) */
 			rtw_write8(Adapter, REG_BCN_CTRL_1, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
 
 			DBG_8192D("%s()-%d: REG_BCN_CTRL_1 = %02x\n", __func__, __LINE__, rtw_read8(Adapter, REG_BCN_CTRL_1));
@@ -3689,31 +3579,31 @@ static void hw_var_set_opmode(struct rtw
 				rtw_write8(Adapter, REG_BCN_CTRL,
 					rtw_read8(Adapter, REG_BCN_CTRL) & ~EN_BCN_FUNCTION);
 
-			//dis BCN0 ATIM  WND if if1 is station
+			/* dis BCN0 ATIM  WND if if1 is station */
 			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(0));
 #ifdef CONFIG_TSF_RESET_OFFLOAD
-			// Reset TSF for STA+AP concurrent mode
+			/*  Reset TSF for STA+AP concurrent mode */
 			if (check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE))) {
 				if (reset_tsf(Adapter, IFACE_PORT1) == false)
 					DBG_8192D("ERROR! %s()-%d: Reset port1 TSF fail\n",
 						__func__, __LINE__);
 			}
-#endif	// CONFIG_TSF_RESET_OFFLOAD
+#endif	/*  CONFIG_TSF_RESET_OFFLOAD */
 		}
 
 	}
-	else	// (Adapter->iface_type == IFACE_PORT1)
-#endif //CONFIG_CONCURRENT_MODE
+	else	/*  (Adapter->iface_type == IFACE_PORT1) */
+#endif /* CONFIG_CONCURRENT_MODE */
 	{
-		// disable Port0 TSF update
+		/*  disable Port0 TSF update */
 		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
 
-		// set net_type
+		/*  set net_type */
 		val8 = rtw_read8(Adapter, MSR)&0x0c;
 		val8 |= mode;
 		rtw_write8(Adapter, MSR, val8);
 
-		//reset TSF0
+		/* reset TSF0 */
 		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));
 
 		DBG_8192D("%s()-%d mode = %d\n", __func__, __LINE__, mode);
@@ -3722,13 +3612,12 @@ static void hw_var_set_opmode(struct rtw
 		{
 #ifdef CONFIG_CONCURRENT_MODE
 			if (!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 			{
 				StopTxBeacon(Adapter);
 			}
 
-			rtw_write8(Adapter,REG_BCN_CTRL, 0x19);//disable atim wnd
-			//rtw_write8(Adapter,REG_BCN_CTRL, 0x18);
+			rtw_write8(Adapter,REG_BCN_CTRL, 0x19);/* disable atim wnd */
 		}
 		else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
 		{
@@ -3741,27 +3630,25 @@ static void hw_var_set_opmode(struct rtw
 
 			rtw_write8(Adapter, REG_BCN_CTRL, 0x12);
 
-			//Set RCR
-			//write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0
-			rtw_write32(Adapter, REG_RCR, 0x7000228e);//CBSSID_DATA must set to 0
-			//enable to rx data frame
+			/* Set RCR */
+			rtw_write32(Adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
+			/* enable to rx data frame */
 			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
-			//enable to rx ps-poll
+			/* enable to rx ps-poll */
 			rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
 
-			//Beacon Control related register for first time
+			/* Beacon Control related register for first time */
 
-			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms
-			rtw_write8(Adapter, REG_DRVERLYINT, 0x05);// 5ms
+			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); /*  2ms */
+			rtw_write8(Adapter, REG_DRVERLYINT, 0x05);/*  5ms */
 
-			//write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
-			rtw_write8(Adapter, REG_ATIMWND, 0x0a); // 10ms for port0
+			rtw_write8(Adapter, REG_ATIMWND, 0x0a); /*  10ms for port0 */
 			rtw_write16(Adapter, REG_BCNTCFG, 0x00);
 			rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);
-			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);// +32767 (~32ms)
+			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);/*  +32767 (~32ms) */
 
-		        //enable BCN0 Function for if1
-			//don't enable update TSF0 for if1 (due to TSF update when beacon/probe rsp are received)
+		        /* enable BCN0 Function for if1 */
+			/* don't enable update TSF0 for if1 (due to TSF update when beacon/probe rsp are received) */
 			rtw_write8(Adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -3769,17 +3656,17 @@ static void hw_var_set_opmode(struct rtw
 				rtw_write8(Adapter, REG_BCN_CTRL_1,
 					rtw_read8(Adapter, REG_BCN_CTRL_1) & ~EN_BCN_FUNCTION);
 
-			//dis BCN1 ATIM  WND if if2 is station
+			/* dis BCN1 ATIM  WND if if2 is station */
 			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(0));
 #ifdef CONFIG_TSF_RESET_OFFLOAD
-			// Reset TSF for STA+AP concurrent mode
+			/*  Reset TSF for STA+AP concurrent mode */
 			if (check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE))) {
 				if (reset_tsf(Adapter, IFACE_PORT0) == false)
 					DBG_8192D("ERROR! %s()-%d: Reset port0 TSF fail\n",
 						__func__, __LINE__);
 			}
-#endif // CONFIG_TSF_RESET_OFFLOAD
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_TSF_RESET_OFFLOAD */
+#endif /*  CONFIG_CONCURRENT_MODE */
 		}
 
 	}
@@ -3857,7 +3744,6 @@ static void hw_var_set_bcn_func(struct r
 		}
 		else
 		{
-			//rtw_write8(Adapter, bcn_ctrl_reg, rtw_read8(Adapter, bcn_ctrl_reg)&(~(EN_BCN_FUNCTION | EN_TXBCN_RPT)));
 			rtw_write8(Adapter, bcn_ctrl_reg, (rtw_read8(Adapter, bcn_ctrl_reg)&(~(EN_TXBCN_RPT))) | DIS_TSF_UDT0_NORMAL_CHIP);
 		}
 	}
@@ -3871,88 +3757,79 @@ static void hw_var_set_correct_tsf(struc
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 
-	//tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
-	tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
+	tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; /* us */
 
 	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 	{
-		//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
-		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
 		StopTxBeacon(Adapter);
 	}
 
 	if (Adapter->iface_type == IFACE_PORT1)
 	{
-		//disable related TSF function
+		/* disable related TSF function */
 		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
 
 		rtw_write32(Adapter, REG_TSFTR1, tsf);
 		rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
 
-		//enable related TSF function
+		/* enable related TSF function */
 		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));
 
 
 #ifdef CONFIG_TSF_RESET_OFFLOAD
-		// Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue!
+		/*  Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue! */
 		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
 			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)) {
 			if (reset_tsf(Adapter, IFACE_PORT0) == false)
 				DBG_8192D("ERROR! %s()-%d: Reset port0 TSF fail\n",
 					__func__, __LINE__);
 		}
-#endif	// CONFIG_TSF_RESET_OFFLOAD
+#endif	/*  CONFIG_TSF_RESET_OFFLOAD */
 
 	}
-	else	// Adapter->iface_type == IFACE_PORT1
+	else	/*  Adapter->iface_type == IFACE_PORT1 */
 	{
-		//disable related TSF function
+		/* disable related TSF function */
 		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
-		// disable TSF update instead! May induce burst beacon TX
-		//rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+		/*  disable TSF update instead! May induce burst beacon TX */
 
 		rtw_write32(Adapter, REG_TSFTR, tsf);
 		rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
 
-		//enable related TSF function
+		/* enable related TSF function */
 		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
-		//rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
 
-		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
+		/*  Update buddy port's TSF if it is SoftAP for beacon TX issue! */
 		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
 			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)
 		) {
-			//disable related TSF function
+			/* disable related TSF function */
 			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
-			// disable TSF update instead!
-			//rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
+			/*  disable TSF update instead! */
 
 			rtw_write32(Adapter, REG_TSFTR1, tsf);
 			rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
 
-			//enable related TSF function
+			/* enable related TSF function */
 			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));
-			//rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
 		}
 #ifdef CONFIG_TSF_RESET_OFFLOAD
-		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
+		/*  Update buddy port's TSF if it is SoftAP for beacon TX issue! */
 		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
 			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)) {
 			if (reset_tsf(Adapter, IFACE_PORT1) == false)
 				DBG_8192D("ERROR! %s()-%d: Reset port1 TSF fail\n",
 					__func__, __LINE__);
 		}
-#endif	// CONFIG_TSF_RESET_OFFLOAD
+#endif	/*  CONFIG_TSF_RESET_OFFLOAD */
 	}
 
 
 	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 	{
-		//pHalData->RegTxPause  &= (~STOP_BCNQ);
-		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)&(~BIT(6))));
 		ResumeTxBeacon(Adapter);
 	}
-#endif	// CONFIG_CONCURRENT_MODE
+#endif	/*  CONFIG_CONCURRENT_MODE */
 }
 
 
@@ -3972,7 +3849,7 @@ static void hw_var_set_mlme_disconnect(s
 		int i;
 		u8 reg_bcn_ctrl_1;
 
-		// a.Driver set 0x422 bit 6 =0
+		/*  a.Driver set 0x422 bit 6 =0 */
 		rtw_write8(Adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
 		pHalData->RegFwHwTxQCtrl &= (~BIT6);
 
@@ -3984,11 +3861,11 @@ static void hw_var_set_mlme_disconnect(s
 		reg_bcn_ctrl_1 = rtw_read8(Adapter, REG_BCN_CTRL_1);
 		DBG_8192D("%s()-%d: reg_bcn_ctrl_1=%02x\n", __func__, __LINE__, reg_bcn_ctrl_1);
 
-		// b. driver set h2c cmd
+		/*  b. driver set h2c cmd */
 		rtl8192c_dis_beacon_fun_cmd(Adapter);
 
 		/*
-			// FW Job for port 0
+			  FW Job for port 0
 
 		   c. 8051 set nettype to ap
 		   d. 8051 check dma_int
@@ -4000,13 +3877,12 @@ static void hw_var_set_mlme_disconnect(s
 
 		*/
 
-		// The worst case is 100 + 15 ms
+		/*  The worst case is 100 + 15 ms */
 		rtw_msleep_os(120);
 
 		for (i=0; i< 10; i++) {
 			reg_bcn_ctrl_1 = rtw_read8(Adapter, REG_BCN_CTRL_1);
 			if ((reg_bcn_ctrl_1 & BIT(3)) == 0) {
-				//DBG_8192D("%s()-%d: BEACON_DISABLE_OFFLOAD finished! reg=%02x\n", __func__, __LINE__, reg);
 				break;
 			}
 			DBG_8192D("%s()-%d: BEACON_DISABLE_OFFLOAD not finished! REG_BCN_CTRL_1=%02x\n", __func__, __LINE__, reg_bcn_ctrl_1);
@@ -4018,38 +3894,38 @@ static void hw_var_set_mlme_disconnect(s
 		DBG_8192D("%s()-%d: reg_bcn_disable_cnt=%02x\n", __func__, __LINE__, rtw_read8(Adapter, REG_FW_BCN_DIS_CNT));
 		DBG_8192D("%s()-%d: reg_bcn_ctrl_1=%02x\n", __func__, __LINE__, reg_bcn_ctrl_1);
 
-#else   // CONFIG_BEACON_DISABLE_OFFLOAD
+#else   /*  CONFIG_BEACON_DISABLE_OFFLOAD */
 
-		//disable update TSF1
+		/* disable update TSF1 */
 			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
 
-		//reset TSF1
+		/* reset TSF1 */
 		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1));
 
-		// disable Port1's beacon function
+		/*  disable Port1's beacon function */
 		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
 
-#endif  // CONFIG_BEACON_DISABLE_OFFLOAD
+#endif  /*  CONFIG_BEACON_DISABLE_OFFLOAD */
 
-		// j, Driver set 0x422 bit 6 =1
+		/*  j, Driver set 0x422 bit 6 =1 */
 		rtw_write8(Adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
 		pHalData->RegFwHwTxQCtrl |= BIT6;
 
-		// k. re_download beacon pkt
+		/*  k. re_download beacon pkt */
 		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
 			set_tx_beacon_cmd(pbuddy_adapter);
 
 
 	}
-	else	// (Adapter->iface_type == IFACE_PORT1)
+	else	/*  (Adapter->iface_type == IFACE_PORT1) */
 	{
-		//disable update TSF
+		/* disable update TSF */
 			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
 
-		//reset TSF
+		/* reset TSF */
 		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));
 
-		// Can't disable Port0's beacon function due to it is used by RA
+		/*  Can't disable Port0's beacon function due to it is used by RA */
 	}
 #endif
 }
@@ -4076,9 +3952,9 @@ static void hw_var_set_mlme_sitesurvey(s
 		|| (check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true)
 #endif
 #ifdef CONFIG_TDLS
-		// TDLS will clear RCR_CBSSID_DATA bit for connection.
+		/*  TDLS will clear RCR_CBSSID_DATA bit for connection. */
 		|| (Adapter->tdlsinfo.setup_state & TDLS_LINKED_STATE)
-#endif // CONFIG_TDLS
+#endif /*  CONFIG_TDLS */
 		)
 	{
 		rcr_clear_bit = RCR_CBSSID_BCN;
@@ -4088,21 +3964,21 @@ static void hw_var_set_mlme_sitesurvey(s
 		rcr_clear_bit = (RCR_CBSSID_BCN | RCR_CBSSID_DATA);
 	}
 
-	// Recieve all data frames
+	/*  Recieve all data frames */
 	value_rxfltmap2 = 0xFFFF;
 
 #else /* CONFIG_FIND_BEST_CHANNEL */
 
 	rcr_clear_bit = RCR_CBSSID_BCN;
 
-	//config RCR to receive different BSSID & not to receive data frame
+	/* config RCR to receive different BSSID & not to receive data frame */
 	value_rxfltmap2 = 0;
 
 #endif /* CONFIG_FIND_BEST_CHANNEL */
 
 	value_rcr = rtw_read32(Adapter, REG_RCR);
 
-	if (*((u8 *)val))//under sitesurvey
+	if (*((u8 *)val))/* under sitesurvey */
 	{
 		pHalData->bLoadIMRandIQKSettingFor2G = false;
 
@@ -4112,11 +3988,11 @@ static void hw_var_set_mlme_sitesurvey(s
 		rtw_write16(Adapter, REG_RXFLTMAP2, value_rxfltmap2);
 
 		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE |WIFI_ADHOC_MASTER_STATE)) {
-			//disable update TSF
+			/* disable update TSF */
 			rtw_write8(Adapter, reg_bcn_ctl, rtw_read8(Adapter, reg_bcn_ctl)|BIT(4));
 		}
 
-		// Save orignal RRSR setting.
+		/*  Save orignal RRSR setting. */
 		pHalData->RegRRSR = rtw_read16(Adapter, REG_RRSR);
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -4127,7 +4003,7 @@ static void hw_var_set_mlme_sitesurvey(s
 		}
 #endif
 	}
-	else//sitesurvey done
+	else/* sitesurvey done */
 	{
 		if (check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pmlmepriv, WIFI_AP_STATE)
 #ifdef CONFIG_CONCURRENT_MODE
@@ -4135,19 +4011,19 @@ static void hw_var_set_mlme_sitesurvey(s
 #endif
 			)
 		{
-			//enable to rx data frame
+			/* enable to rx data frame */
 			rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
 		}
 
 		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE |WIFI_ADHOC_MASTER_STATE)) {
-			//enable update TSF
+			/* enable update TSF */
 			rtw_write8(Adapter, reg_bcn_ctl, rtw_read8(Adapter, reg_bcn_ctl)&(~BIT(4)));
 		}
 
 		value_rcr |= rcr_clear_bit;
 		rtw_write32(Adapter, REG_RCR, value_rcr);
 
-		// Restore orignal RRSR setting.
+		/*  Restore orignal RRSR setting. */
 		rtw_write16(Adapter, REG_RRSR, pHalData->RegRRSR);
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -4168,7 +4044,7 @@ static void hw_var_set_mlme_join(struct
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
 
-	if (type == 0) // prepare to join
+	if (type == 0) /*  prepare to join */
 	{
 		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 			check_buddy_fwstate(Adapter, _FW_LINKED))
@@ -4176,8 +4052,7 @@ static void hw_var_set_mlme_join(struct
 			StopTxBeacon(Adapter);
 		}
 
-		//enable to rx data frame.Accept all data frame
-		//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
+		/* enable to rx data frame.Accept all data frame */
 		rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
 
 		if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
@@ -4189,15 +4064,15 @@ static void hw_var_set_mlme_join(struct
 		{
 			RetryLimit = (pHalData->CustomerID == RT_CID_CCX) ? 7 : 48;
 		}
-		else // Ad-hoc Mode
+		else /*  Ad-hoc Mode */
 		{
 			RetryLimit = 0x7;
 		}
 
 		DBG_8192D("%s(): pHalData->bNeedIQK = true\n",__func__);
-		pHalData->bNeedIQK = true; //for 92D IQK
+		pHalData->bNeedIQK = true; /* for 92D IQK */
 	}
-	else if (type == 1) //joinbss_event call back when join res < 0
+	else if (type == 1) /* joinbss_event call back when join res < 0 */
 	{
 		if (check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))
 			rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
@@ -4208,10 +4083,10 @@ static void hw_var_set_mlme_join(struct
 			ResumeTxBeacon(Adapter);
 		}
 	}
-	else if (type == 2) //sta add event call back
+	else if (type == 2) /* sta add event call back */
 	{
 
-		//enable update TSF
+		/* enable update TSF */
 		if (Adapter->iface_type == IFACE_PORT1)
 			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
 		else
@@ -4220,7 +4095,7 @@ static void hw_var_set_mlme_join(struct
 
 		if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
 		{
-			//fixed beacon issue for 8191su...........
+			/* fixed beacon issue for 8191su........... */
 			rtw_write8(Adapter,0x542 ,0x02);
 			RetryLimit = 0x7;
 		}
@@ -4253,7 +4128,7 @@ static void dc_hw_var_mlme_sitesurvey(st
 		pbuddy_mlmepriv = &(BuddyAdapter->mlmepriv);
 		pbuddy_mlmeext = &BuddyAdapter->mlmeextpriv;
 
-		if (sitesurvey_state)//under sitesurvey
+		if (sitesurvey_state)/* under sitesurvey */
 		{
 			if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 				check_buddy_fwstate(Adapter, _FW_LINKED))
@@ -4263,7 +4138,7 @@ static void dc_hw_var_mlme_sitesurvey(st
 
 			rtw_write16(Adapter, REG_RRSR, 0x150);
 		}
-		else//sitesurvey done
+		else/* sitesurvey done */
 		{
 			if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 				check_buddy_fwstate(Adapter, _FW_LINKED))
@@ -4294,7 +4169,7 @@ static void dc_hw_var_mlme_join(struct r
 			pmlmeext->cur_bwmode != pbuddy_mlmeext->cur_bwmode ||
 			pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset)
 		{
-			if (join_state == 0)// prepare to join
+			if (join_state == 0)/*  prepare to join */
 			{
 				if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 					check_buddy_fwstate(Adapter, _FW_LINKED))
@@ -4302,7 +4177,7 @@ static void dc_hw_var_mlme_join(struct r
 					StopTxBeacon(BuddyAdapter);
 				}
 			}
-			else//join success or fail
+			else/* join success or fail */
 			{
 				if (check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 					check_buddy_fwstate(Adapter, _FW_LINKED))
@@ -4345,7 +4220,7 @@ _func_enter_;
 		case HW_VAR_SET_OPMODE:
 #if defined(CONFIG_CONCURRENT_MODE)
 			hw_var_set_opmode(Adapter, variable, val);
-#else //CONFIG_CONCURRENT_MODE
+#else /* CONFIG_CONCURRENT_MODE */
 			{
 				u8	val8;
 				u8	mode = *((u8 *)val);
@@ -4367,29 +4242,27 @@ _func_enter_;
 					rtw_write8(Adapter, REG_BCN_CTRL, 0x12);
 
 
-					//Set RCR
-					//rtw_write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0
-					rtw_write32(Adapter, REG_RCR, 0x7000228e);//CBSSID_DATA must set to 0
-					//enable to rx data frame
+					/* Set RCR */
+					rtw_write32(Adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
+					/* enable to rx data frame */
 					rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
-					//enable to rx ps-poll
+					/* enable to rx ps-poll */
 					rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
 
-					//Beacon Control related register for first time
-					rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms
-					rtw_write8(Adapter, REG_DRVERLYINT, 0x05);// 5ms
-					//rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
-					rtw_write8(Adapter, REG_ATIMWND, 0x0a); // 10ms
+					/* Beacon Control related register for first time */
+					rtw_write8(Adapter, REG_BCNDMATIM, 0x02); /*  2ms */
+					rtw_write8(Adapter, REG_DRVERLYINT, 0x05);/*  5ms */
+					rtw_write8(Adapter, REG_ATIMWND, 0x0a); /*  10ms */
 					rtw_write16(Adapter, REG_BCNTCFG, 0x00);
 					rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0x6404);
 
-					//reset TSF
+					/* reset TSF */
 					rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));
 
-					//enable TSF Function for if1
+					/* enable TSF Function for if1 */
 					rtw_write8(Adapter, REG_BCN_CTRL, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
 
-					//enable update TSF for if1
+					/* enable update TSF for if1 */
 					rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
 				}
 
@@ -4397,7 +4270,7 @@ _func_enter_;
 				val8 |= mode;
 				rtw_write8(Adapter, MSR, val8);
 			}
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 			break;
 		case HW_VAR_MAC_ADDR:
 			hw_var_set_macaddr(Adapter, variable, val);
@@ -4405,7 +4278,7 @@ _func_enter_;
 		case HW_VAR_BSSID:
 #if defined(CONFIG_CONCURRENT_MODE)
 			hw_var_set_bssid(Adapter, variable, val);
-#else //CONFIG_CONCURRENT_MODE
+#else /* CONFIG_CONCURRENT_MODE */
 			{
 				u8	idx = 0;
 				for (idx = 0 ; idx < 6; idx++)
@@ -4413,7 +4286,7 @@ _func_enter_;
 					rtw_write8(Adapter, (REG_BSSID+idx), val[idx]);
 				}
 			}
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 			{
 #ifdef CONFIG_DUALMAC_CONCURRENT
 				struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
@@ -4421,13 +4294,13 @@ _func_enter_;
 				if (check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE) == true)
 				{
 					DBG_8192D("%s(): pHalData->bNeedIQK = true\n",__func__);
-					pHalData->bNeedIQK = true; //for 92D IQK
+					pHalData->bNeedIQK = true; /* for 92D IQK */
 				}
 #ifdef CONFIG_DUALMAC_CONCURRENT
 				if ((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
 				{
 					if (check_fwstate(&BuddyAdapter->mlmepriv, WIFI_AP_STATE) == true)
-						GET_HAL_DATA(BuddyAdapter)->bNeedIQK = true; //for 92D IQK
+						GET_HAL_DATA(BuddyAdapter)->bNeedIQK = true; /* for 92D IQK */
 				}
 #endif
 			}
@@ -4456,10 +4329,10 @@ _func_enter_;
 				u8	RateIndex = 0, b2GBand = false;
 				struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
 
-				// 2007.01.16, by Emily
-				// Select RRSR (in Legacy-OFDM and CCK)
-				// For 8190, we select only 24M, 12M, 6M, 11M, 5.5M, 2M, and 1M from the Basic rate.
-				// We do not use other rates.
+				/*  2007.01.16, by Emily */
+				/*  Select RRSR (in Legacy-OFDM and CCK) */
+				/*  For 8190, we select only 24M, 12M, 6M, 11M, 5.5M, 2M, and 1M from the Basic rate. */
+				/*  We do not use other rates. */
 				halsetbratecfg(Adapter, val, &BrateCfg);
 
 				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
@@ -4469,39 +4342,31 @@ _func_enter_;
 
 				if (b2GBand)
 				{
-					//CCK 2M ACK should be disabled for some BCM and Atheros AP IOT
-					//because CCK 2M has poor TXEVM
-					//CCK 5.5M & 11M ACK should be enabled for better performance
+					/* CCK 2M ACK should be disabled for some BCM and Atheros AP IOT */
+					/* because CCK 2M has poor TXEVM */
+					/* CCK 5.5M & 11M ACK should be enabled for better performance */
 					pHalData->BasicRateSet = BrateCfg = (BrateCfg |0xd)& 0x15d;
-					BrateCfg |= 0x1; // default enable 1M ACK rate
+					BrateCfg |= 0x1; /*  default enable 1M ACK rate */
 				}
-				else // 5G
+				else /*  5G */
 				{
 					pHalData->BasicRateSet &= 0xFF0;
-					BrateCfg |= 0x10; // default enable 6M ACK rate
+					BrateCfg |= 0x10; /*  default enable 6M ACK rate */
 				}
 
 				DBG_8192D("HW_VAR_BASIC_RATE: BrateCfg(%#x)\n", BrateCfg);
 
-				// Set RRSR rate table.
+				/*  Set RRSR rate table. */
 				rtw_write8(Adapter, REG_RRSR, BrateCfg&0xff);
 				rtw_write8(Adapter, REG_RRSR+1, (BrateCfg>>8)&0xff);
 				rtw_write8(Adapter, REG_RRSR+2, rtw_read8(Adapter, REG_RRSR+2)&0xf0);
 
-				//if (pHalData->FirmwareVersion > 0xe)
-				//{
-				//	SetRTSRateWorkItemCallback(Adapter);
-				//}
-				//else
-				//{
-					// Set RTS initial rate
-					while (BrateCfg > 0x1)
-					{
-						BrateCfg = (BrateCfg>> 1);
-						RateIndex++;
-					}
-					rtw_write8(Adapter, REG_INIRTS_RATE_SEL, RateIndex);
-				//}
+				/*  Set RTS initial rate */
+				while (BrateCfg > 0x1) {
+					BrateCfg = (BrateCfg>> 1);
+					RateIndex++;
+				}
+				rtw_write8(Adapter, REG_INIRTS_RATE_SEL, RateIndex);
 			}
 			break;
 		case HW_VAR_TXPAUSE:
@@ -4513,40 +4378,35 @@ _func_enter_;
 		case HW_VAR_CORRECT_TSF:
 #ifdef CONFIG_CONCURRENT_MODE
 			hw_var_set_correct_tsf(Adapter, variable, val);
-#else //CONFIG_CONCURRENT_MODE
+#else /* CONFIG_CONCURRENT_MODE */
 			{
 				u64	tsf;
 				struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
 				struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-				//tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
-				tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
+				tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; /* us */
 
 				if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 				{
-					//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
-					//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
 					StopTxBeacon(Adapter);
 				}
 
-				//disable related TSF function
+				/* disable related TSF function */
 				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
 
 				rtw_write32(Adapter, REG_TSFTR, tsf);
 				rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
 
-				//enable related TSF function
+				/* enable related TSF function */
 				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
 
 
 				if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 				{
-					//pHalData->RegTxPause  &= (~STOP_BCNQ);
-					//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)&(~BIT(6))));
 					ResumeTxBeacon(Adapter);
 				}
 			}
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 			break;
 		case HW_VAR_CHECK_BSSID:
 			if (*((u8 *)val))
@@ -4567,30 +4427,29 @@ _func_enter_;
 		case HW_VAR_MLME_DISCONNECT:
 #ifdef CONFIG_CONCURRENT_MODE
 			hw_var_set_mlme_disconnect(Adapter, variable, val);
-#else //CONFIG_CONCURRENT_MODE
+#else /* CONFIG_CONCURRENT_MODE */
 			{
-				//Set RCR to not to receive data frame when NO LINK state
-				//rtw_write32(Adapter, REG_RCR, rtw_read32(padapter, REG_RCR) & ~RCR_ADF);
+				/* Set RCR to not to receive data frame when NO LINK state */
 				rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
 
-				//reset TSF
+				/* reset TSF */
 				rtw_write8(Adapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));
 
-				//disable update TSF
+				/* disable update TSF */
 				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
 			}
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 			break;
 		case HW_VAR_MLME_SITESURVEY:
 			hw_var_set_mlme_sitesurvey(Adapter, variable,  val);
 #ifdef CONFIG_DUALMAC_CONCURRENT
 			dc_hw_var_mlme_sitesurvey(Adapter, *((u8 *)val));
-#endif //CONFIG_DUALMAC_CONCURRENT
+#endif /* CONFIG_DUALMAC_CONCURRENT */
 			break;
 		case HW_VAR_MLME_JOIN:
 #ifdef CONFIG_CONCURRENT_MODE
 			hw_var_set_mlme_join(Adapter, variable,  val);
-#else //CONFIG_CONCURRENT_MODE
+#else /* CONFIG_CONCURRENT_MODE */
 			{
 				u8	RetryLimit = 0x30;
 				u8	type = *((u8 *)val);
@@ -4599,10 +4458,9 @@ _func_enter_;
 				struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
 #endif
 
-				if (type == 0) // prepare to join
+				if (type == 0) /*  prepare to join */
 				{
-					//enable to rx data frame.Accept all data frame
-					//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
+					/* enable to rx data frame.Accept all data frame */
 					rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
 
 					rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
@@ -4611,38 +4469,34 @@ _func_enter_;
 					{
 						RetryLimit = (pHalData->CustomerID == RT_CID_CCX) ? 7 : 48;
 					}
-					else // Ad-hoc Mode
+					else /*  Ad-hoc Mode */
 					{
 						RetryLimit = 0x7;
 					}
 
 					DBG_8192D("%s(): pHalData->bNeedIQK = true\n",__func__);
-					pHalData->bNeedIQK = true; //for 92D IQK
+					pHalData->bNeedIQK = true; /* for 92D IQK */
 #ifdef CONFIG_DUALMAC_CONCURRENT
 					if ((BuddyAdapter !=NULL) && (pHalData->bSlaveOfDMSP))
 					{
-						GET_HAL_DATA(BuddyAdapter)->bNeedIQK = true; //for 92D IQK
+						GET_HAL_DATA(BuddyAdapter)->bNeedIQK = true; /* for 92D IQK */
 					}
 #endif
 				}
-				else if (type == 1) //joinbss_event call back when join res < 0
+				else if (type == 1) /* joinbss_event call back when join res < 0 */
 				{
-					//config RCR to receive different BSSID & not to receive data frame during linking
-					//u32 v = rtw_read32(Adapter, REG_RCR);
-					//v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);//| RCR_ADF
-					//rtw_write32(Adapter, REG_RCR, v);
+					/* config RCR to receive different BSSID & not to receive data frame during linking */
 
 					rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
 				}
-				else if (type == 2) //sta add event call back
+				else if (type == 2) /* sta add event call back */
 				{
-					//enable update TSF
+					/* enable update TSF */
 					rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
 
 					if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
 					{
-						//fixed beacon issue for 8191su...........
-						//rtw_write8(Adapter,0x542 ,0x02);
+						/* fixed beacon issue for 8191su........... */
 						RetryLimit = 0x7;
 					}
 				}
@@ -4650,9 +4504,9 @@ _func_enter_;
 				rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
 #ifdef CONFIG_DUALMAC_CONCURRENT
 				dc_hw_var_mlme_join(Adapter, *((u8 *)val));
-#endif //CONFIG_DUALMAC_CONCURRENT
+#endif /* CONFIG_DUALMAC_CONCURRENT */
 			}
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 			break;
 
 		case HW_VAR_ON_RCR_AM:
@@ -4685,7 +4539,7 @@ _func_enter_;
 
 					u1bAIFS = aSifsTime + (2 * pmlmeinfo->slotTime);
 
-					// <Roger_EXP> Temporary removed, 2008.06.20.
+					/*  <Roger_EXP> Temporary removed, 2008.06.20. */
 					rtw_write8(Adapter, REG_EDCA_VO_PARAM, u1bAIFS);
 					rtw_write8(Adapter, REG_EDCA_VI_PARAM, u1bAIFS);
 					rtw_write8(Adapter, REG_EDCA_BE_PARAM, u1bAIFS);
@@ -4697,9 +4551,9 @@ _func_enter_;
 			{
 				u8	regTmp;
 				u8	bShortPreamble = *((bool *)val);
-				// Joseph marked out for Netgear 3500 TKIP channel 7 issue.(Temporarily)
+				/*  Joseph marked out for Netgear 3500 TKIP channel 7 issue.(Temporarily) */
 				regTmp = (pHalData->nCur40MhzPrimeSC)<<5;
-				//regTmp = 0;
+				/* regTmp = 0; */
 				if (bShortPreamble)
 					regTmp |= 0x80;
 
@@ -4708,21 +4562,21 @@ _func_enter_;
 			break;
 		case HW_VAR_SEC_CFG:
 #ifdef CONFIG_CONCURRENT_MODE
-			rtw_write8(Adapter, REG_SECCFG, 0x0c |BIT(5));//only enable tx enc and rx dec engine.
-#else //CONFIG_CONCURRENT_MODE
+			rtw_write8(Adapter, REG_SECCFG, 0x0c |BIT(5));/* only enable tx enc and rx dec engine. */
+#else /* CONFIG_CONCURRENT_MODE */
 			rtw_write8(Adapter, REG_SECCFG, *((u8 *)val));
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 			break;
 		case HW_VAR_DM_FLAG:
 			pdmpriv->DMFlag = *((u8 *)val);
 			break;
 		case HW_VAR_DM_FUNC_OP:
 			if (val[0])
-			{// save dm flag
+			{/*  save dm flag */
 				pdmpriv->DMFlag_tmp = pdmpriv->DMFlag;
 			}
 			else
-			{// restore dm flag
+			{/*  restore dm flag */
 				pdmpriv->DMFlag = pdmpriv->DMFlag_tmp;
 			}
 			break;
@@ -4745,24 +4599,21 @@ _func_enter_;
 
 				for (i=0;i<CAM_CONTENT_COUNT;i++)
 				{
-					// filled id in CAM config 2 byte
+					/*  filled id in CAM config 2 byte */
 					if (i == 0)
 					{
 						ulContent |=(ucIndex & 0x03) | ((u16)(ulEncAlgo)<<2);
-						//ulContent |= CAM_VALID;
 					}
 					else
 					{
 						ulContent = 0;
 					}
-					// polling bit, and No Write enable, and address
+					/*  polling bit, and No Write enable, and address */
 					ulCommand= CAM_CONTENT_COUNT*ucIndex+i;
 					ulCommand= ulCommand | CAM_POLLINIG|CAM_WRITE;
-					// write content 0 is equall to mark invalid
-					rtw_write32(Adapter, WCAMI, ulContent);  //delay_ms(40);
-					//RT_TRACE(COMP_SEC, DBG_LOUD, ("CAM_empty_entry(): WRITE A4: %lx\n",ulContent));
-					rtw_write32(Adapter, RWCAM, ulCommand);  //delay_ms(40);
-					//RT_TRACE(COMP_SEC, DBG_LOUD, ("CAM_empty_entry(): WRITE A0: %lx\n",ulCommand));
+					/*  write content 0 is equall to mark invalid */
+					rtw_write32(Adapter, WCAMI, ulContent);  /* delay_ms(40); */
+					rtw_write32(Adapter, RWCAM, ulCommand);  /* delay_ms(40); */
 				}
 			}
 			break;
@@ -4849,7 +4700,6 @@ _func_enter_;
 						MinSpacingToSet = SecMinSpace;
 					}
 
-					//RT_TRACE(COMP_MLME, DBG_LOUD, ("Set HW_VAR_AMPDU_MIN_SPACE: %#x\n", Adapter->MgntInfo.MinSpaceCfg));
 					rtw_write8(Adapter, REG_AMPDU_MIN_SPACE, (rtw_read8(Adapter, REG_AMPDU_MIN_SPACE) & 0xf8) | MinSpacingToSet);
 				}
 			}
@@ -4891,7 +4741,6 @@ _func_enter_;
 					}
 
 					rtw_write32(Adapter, REG_AGGLEN_LMT, RegToSet);
-					//RT_TRACE(COMP_MLME, DBG_LOUD, ("Set HW_VAR_AMPDU_FACTOR: %#x\n", FactorToSet));
 				}
 			}
 			break;
@@ -4912,16 +4761,6 @@ _func_enter_;
 				u8	RpwmVal = (*(u8 *)val);
 				RpwmVal = RpwmVal & 0xf;
 
-				/*if (pHalData->PreRpwmVal & BIT7) //bit7: 1
-				{
-					PlatformEFIOWrite1Byte(Adapter, REG_USB_HRPWM, (*(pu1Byte)val));
-					pHalData->PreRpwmVal = (*(pu1Byte)val);
-				}
-				else //bit7: 0
-				{
-					PlatformEFIOWrite1Byte(Adapter, REG_USB_HRPWM, ((*(pu1Byte)val)|BIT7));
-					pHalData->PreRpwmVal = ((*(pu1Byte)val)|BIT7);
-				}*/
 				FillH2CCmd92D(Adapter, H2C_PWRM, 1, (u8 *)(&RpwmVal));
 			}
 			break;
@@ -4938,7 +4777,7 @@ _func_enter_;
 				rtl8192d_set_p2p_ps_offload_cmd(Adapter, p2p_ps_state);
 			}
 			break;
-#endif // CONFIG_P2P_PS
+#endif /*  CONFIG_P2P_PS */
 #ifdef CONFIG_TDLS
 		case HW_VAR_TDLS_WRCR:
 			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)&(~ BIT(6)));
@@ -4948,13 +4787,13 @@ _func_enter_;
 				rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)&(~ BIT(6))&(~ BIT(7)));
 				rtw_write16(Adapter, REG_RXFLTMAP2,0xffff);
 
-				//disable update TSF
+				/* disable update TSF */
 				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
 			}
 			break;
 		case HW_VAR_TDLS_DONE_CH_SEN:
 			{
-				//enable update TSF
+				/* enable update TSF */
 				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~ BIT(4)));
 				rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|(BIT(7)));
 			}
@@ -4962,13 +4801,13 @@ _func_enter_;
 		case HW_VAR_TDLS_RS_RCR:
 			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|(BIT(6)));
 			break;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 		case HW_VAR_INITIAL_GAIN:
 			{
 				struct DIG_T *dig_table = &pdmpriv->DM_DigTable;
 				u32		rx_gain = ((u32 *)(val))[0];
 
-				if (rx_gain == 0xff) {//restore rx gain
+				if (rx_gain == 0xff) {/* restore rx gain */
 					dig_table->curigvalue = dig_table->backupigvalue;
 					PHY_SetBBReg(Adapter, rOFDM0_XAAGCCore1, 0x7f,dig_table->curigvalue);
 					PHY_SetBBReg(Adapter, rOFDM0_XBAGCCore1, 0x7f,dig_table->curigvalue);
@@ -4984,7 +4823,7 @@ _func_enter_;
 		case HW_VAR_TRIGGER_GPIO_0:
 			rtl8192du_trigger_gpio_0(Adapter);
 			break;
-		case HW_VAR_EFUSE_BYTES: // To set EFUE total used bytes, added by Roger, 2008.12.22.
+		case HW_VAR_EFUSE_BYTES: /*  To set EFUE total used bytes, added by Roger, 2008.12.22. */
 			pHalData->EfuseUsedBytes = *((u16 *)val);
 			break;
 		case HW_VAR_FIFO_CLEARN_UP:
@@ -4995,15 +4834,15 @@ _func_enter_;
 				struct pwrctrl_priv *pwrpriv = &Adapter->pwrctrlpriv;
 				u8 trycnt = 100;
 
-				//pause tx
+				/* pause tx */
 				rtw_write8(Adapter,REG_TXPAUSE,0xff);
 
-				//keep sn
+				/* keep sn */
 				Adapter->xmitpriv.nqos_ssn = rtw_read16(Adapter,REG_NQOS_SEQ);
 
 				if (pwrpriv->bkeepfwalive != true)
 				{
-					//RX DMA stop
+					/* RX DMA stop */
 					rtw_write32(Adapter,REG_RXPKT_NUM,(rtw_read32(Adapter,REG_RXPKT_NUM)|RW_RELEASE_EN));
 					do{
 						if (!(rtw_read32(Adapter,REG_RXPKT_NUM)&RXDMA_IDLE))
@@ -5012,7 +4851,7 @@ _func_enter_;
 					if (trycnt ==0)
 						DBG_8192D("Stop RX DMA failed......\n");
 
-					//RQPN Load 0
+					/* RQPN Load 0 */
 					rtw_write16(Adapter,REG_RQPN_NPQ,0x0);
 					rtw_write32(Adapter,REG_RQPN,0x80000000);
 					rtw_mdelay_os(10);
@@ -5030,75 +4869,54 @@ _func_enter_;
 				poidparam = (struct wowlan_ioctl_param *)val;
 				switch (poidparam->subcode) {
 					case WOWLAN_PATTERN_MATCH:
-						//Turn on the Pattern Match feature
+						/* Turn on the Pattern Match feature */
 						DBG_8192D("\n PATTERN_MATCH poidparam->subcode_value=%d\n",poidparam->subcode_value);
 						if (poidparam->subcode_value==1) {
-							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(1)));
 							Adapter->pwrctrlpriv.wowlan_pattern=true;
 							DBG_8192D("%s Adapter->pwrctrlpriv.wowlan_pattern=%x\n",__func__,Adapter->pwrctrlpriv.wowlan_pattern);
 						}
 						else {
-							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&~BIT(1)));
 							Adapter->pwrctrlpriv.wowlan_pattern=false;
 						}
 						break;
 					case WOWLAN_MAGIC_PACKET:
-						//Turn on the Magic Packet feature
+						/* Turn on the Magic Packet feature */
 						DBG_8192D("\n MAGIC_PACKET poidparam->subcode_value=%d\n",poidparam->subcode_value);
 						if (poidparam->subcode_value==1) {
-							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(2)));
 							Adapter->pwrctrlpriv.wowlan_magic=true;
 							DBG_8192D("%s Adapter->pwrctrlpriv.wowlan_magic=%x\n",__func__,Adapter->pwrctrlpriv.wowlan_magic);
 						}
 						else {
-							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&~BIT(2)));
 							Adapter->pwrctrlpriv.wowlan_magic=false;
 						}
 						break;
 					case WOWLAN_UNICAST:
-						//Turn on the Unicast wakeup feature
+						/* Turn on the Unicast wakeup feature */
 						if (poidparam->subcode_value==1) {
-							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(3)));
 							Adapter->pwrctrlpriv.wowlan_unicast=true;
 						}
 						else {
-							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&~BIT(3)));
 							Adapter->pwrctrlpriv.wowlan_unicast=false;
 							DBG_8192D("%s Adapter->pwrctrlpriv.wowlan_unicast=%x\n",__func__,Adapter->pwrctrlpriv.wowlan_unicast);
 						}
 						break;
 					case WOWLAN_SET_PATTERN:
-						//Setting the Pattern for wowlan
+						/* Setting the Pattern for wowlan */
 						res=rtw_wowlan_set_pattern(Adapter,poidparam->pattern);
 						if (res)
 							DBG_8192D("rtw_wowlan_set_pattern retern value=0x%x",res);
 						break;
 					case WOWLAN_DUMP_REG:
-						//dump the WKFMCAM and WOW_CTRL register
-						/*DBG_8192D("\n\n\n\n rtw_wowlan_ctrl: WOW_CTRL=0x%x\n",rtw_read8(Adapter, REG_WOW_CTRL));
-						DBG_8192D("print WKFMCAM index =%d ",poidparam->data[0]);
-						{	int cmd=0,offset=0;
-							for (offset=0;offset<5;offset++) {
-								cmd=BIT(31)|(poidparam->data[0]+offset);
-								rtw_write32(Adapter, REG_WKFMCAM_CMD, cmd);
-								DBG_8192D("offset[%d]=0x%.8x  ",offset,rtw_read32(Adapter, REG_WKFMCAM_RWD));
-								DBG_8192D("offset[%d]=MSB 0x%x:0x%x:0x%x:0x%x  ",offset,rtw_read8(Adapter, REG_WKFMCAM_RWD+3),rtw_read8(Adapter, REG_WKFMCAM_RWD+2),rtw_read8(Adapter, REG_WKFMCAM_RWD+1),rtw_read8(Adapter, REG_WKFMCAM_RWD));
-						}
-						}*/
+						/* dump the WKFMCAM and WOW_CTRL register */
 
 						break;
 					case WOWLAN_ENABLE:
 						SetFwRelatedForWoWLAN8192DU(Adapter, true);
-						//Set Pattern
+						/* Set Pattern */
 						if (Adapter->pwrctrlpriv.wowlan_pattern==true)
 							rtw_wowlan_reload_pattern(Adapter);
 						rtl8192d_set_wowlan_cmd(Adapter);
-						//rtw_write8(Adapter, 0x6, rtw_read8(Adapter, 0x6)|BIT(3));
 						rtw_msleep_os(10);
-						//DBG_8192D("\n REG_WOW_CTRL=0x%x\n",rtw_read8(Adapter, REG_WOW_CTRL));
-//						if (rtw_read8(Adapter, REG_WOW_CTRL)==0)
-//							rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(1)|BIT(2)|BIT(3)));
-						//DBG_8192D("\n REG_WOW_CTRL=0x%x\n",rtw_read8(Adapter, REG_WOW_CTRL));
 						break;
 
 					case WOWLAN_DISABLE:
@@ -5113,16 +4931,6 @@ _func_enter_;
 						break;
 
 					case WOWLAN_DEBUG_RELOAD_FW:
-						//for debug
-						/*
-						SetFwRelatedForWoWLAN8192DU(Adapter, true);
-						//Set Pattern
-						if (Adapter->pwrctrlpriv.wowlan_pattern==true)
-							rtw_wowlan_reload_pattern(Adapter);
-						rtl8192d_set_wowlan_cmd(Adapter);
-						rtw_write8(Adapter, 0x6, rtw_read8(Adapter, 0x6)|BIT(3));
-						rtw_msleep_os(10);
-						*/
 						break;
 					case WOWLAN_DEBUG_1:
 						{
@@ -5131,7 +4939,7 @@ _func_enter_;
 							{
 								GPIO_val = rtw_read16(Adapter, REG_GPIO_PIN_CTRL+1);
 								GPIO_val |= BIT(0)|BIT(8);
-								//set GPIO 0 to high for Toshiba
+								/* set GPIO 0 to high for Toshiba */
 								rtw_write16(Adapter, REG_GPIO_PIN_CTRL+1, GPIO_val);
 							}
 							else
@@ -5139,7 +4947,7 @@ _func_enter_;
 								GPIO_val = rtw_read16(Adapter, REG_GPIO_PIN_CTRL+1);
 								GPIO_val |= BIT(8);
 								GPIO_val &= ~BIT(0);
-								//set GPIO 0 to low for Toshiba
+								/* set GPIO 0 to low for Toshiba */
 								rtw_write16(Adapter, REG_GPIO_PIN_CTRL+1, GPIO_val);
 							}
 						}
@@ -5152,29 +4960,29 @@ _func_enter_;
 							if (poidparam->subcode_value==1)
 							{
 
-								//prevent 8051 to be reset by PERST# wake on wlan by Alex & Baron
+								/* prevent 8051 to be reset by PERST# wake on wlan by Alex & Baron */
 								reg = rtw_read8(Adapter, REG_RSV_CTRL);
 								rtw_write8(Adapter, REG_RSV_CTRL, reg| BIT(5));
 								rtw_write8(Adapter, REG_RSV_CTRL, reg| BIT(6)|BIT(5));
-								//for Toshiba only, they should call rtw_suspend before suspend
+								/* for Toshiba only, they should call rtw_suspend before suspend */
 								rtw_suspend_toshiba(Adapter);
 							}
 							else
 							{
-								//unmask usb se0 reset by Alex and DD
+								/* unmask usb se0 reset by Alex and DD */
 								reg = rtw_read8(Adapter, 0xf8);
 								reg |= BIT(3)|BIT(4);
 								rtw_write8(Adapter, 0xf8, reg);
 
-								//for Toshiba only, they should call rtw_resume before resume
+								/* for Toshiba only, they should call rtw_resume before resume */
 								rtw_resume_toshiba(Adapter);
-								//suggest by Scott
+								/* suggest by Scott */
 								reg = rtw_read8(Adapter, REG_RSV_CTRL);
 								reg &= ~(BIT(5)|BIT(6));
 								rtw_write8(Adapter, REG_RSV_CTRL, reg);
 
 							}
-#endif //CONFIG_WOWLAN_MANUAL
+#endif /* CONFIG_WOWLAN_MANUAL */
 						}
 						break;
 					default:
@@ -5186,21 +4994,19 @@ _func_enter_;
 					Adapter->pwrctrlpriv.wowlan_mode =false;
 			}
 			break;
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 		case HW_VAR_CHECK_TXBUF:
 #if defined(CONFIG_CONCURRENT_MODE) || defined(CONFIG_DUALMAC_CONCURRENT)
 			{
 				int i;
 				u8	RetryLimit = 0x01;
 
-				//rtw_write16(Adapter, REG_RL,0x0101);
 				rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
 
 				for (i=0;i<1000;i++)
 				{
 					if (rtw_read32(Adapter, 0x200) != rtw_read32(Adapter, 0x204))
 					{
-						//DBG_8192D("packet in tx packet buffer - 0x204=%x, 0x200=%x (%d)\n", rtw_read32(Adapter, 0x204), rtw_read32(Adapter, 0x200), i);
 						rtw_msleep_os(10);
 					}
 					else
@@ -5217,7 +5023,7 @@ _func_enter_;
 #endif
 			break;
 		case HW_VAR_BCN_VALID:
-			//BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2, write 1 to clear, Clear by sw
+			/* BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2, write 1 to clear, Clear by sw */
 			rtw_write8(Adapter, REG_TDECTRL+2, rtw_read8(Adapter, REG_TDECTRL+2) | BIT0);
 			break;
 		default:
@@ -5242,7 +5048,7 @@ _func_enter_;
 			val[0] = rtw_read8(Adapter, REG_TXPAUSE);
 			break;
 		case HW_VAR_BCN_VALID:
-			//BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2
+			/* BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2 */
 			val[0] = (BIT0 & rtw_read8(Adapter, REG_TDECTRL+2))?true:false;
 			break;
 		case HW_VAR_DM_FLAG:
@@ -5253,13 +5059,13 @@ _func_enter_;
 			break;
 		case HW_VAR_FWLPS_RF_ON:
 			{
-				//When we halt NIC, we should check if FW LPS is leave.
+				/* When we halt NIC, we should check if FW LPS is leave. */
 				u32	valRCR;
 
 				if (Adapter->pwrctrlpriv.rf_pwrstate == rf_off)
 				{
-					// If it is in HW/SW Radio OFF or IPS state, we do not check Fw LPS Leave,
-					// because Fw is unload.
+					/*  If it is in HW/SW Radio OFF or IPS state, we do not check Fw LPS Leave, */
+					/*  because Fw is unload. */
 					val[0] = true;
 				}
 				else
@@ -5273,7 +5079,7 @@ _func_enter_;
 				}
 			}
 			break;
-		case HW_VAR_EFUSE_BYTES: // To get EFUE total used bytes, added by Roger, 2008.12.22.
+		case HW_VAR_EFUSE_BYTES: /*  To get EFUE total used bytes, added by Roger, 2008.12.22. */
 			*((u16 *)(val)) = pHalData->EfuseUsedBytes;
 			break;
 		case HW_VAR_VID:
@@ -5289,10 +5095,10 @@ _func_enter_;
 _func_exit_;
 }
 
-//
-//	Description:
-//		Query setting of specified variable.
-//
+/*  */
+/* 	Description: */
+/* 		Query setting of specified variable. */
+/*  */
 u8 GetHalDefVar8192DUsb(struct rtw_adapter * Adapter, enum HAL_DEF_VARIABLE eVariable, void  *pValue)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
@@ -5321,10 +5127,10 @@ u8 GetHalDefVar8192DUsb(struct rtw_adapt
 	return bResult;
 }
 
-//
-//	Description:
-//		Change default setting of specified variable.
-//
+/*  */
+/* 	Description: */
+/* 		Change default setting of specified variable. */
+/*  */
 u8
 SetHalDefVar8192DUsb(
 	struct rtw_adapter *				Adapter,
@@ -5341,28 +5147,28 @@ SetHalDefVar8192DUsb(
 				u8 dm_func = *((u8*)pValue);
 				struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
-				if (dm_func == 0) { //disable all dynamic func
+				if (dm_func == 0) { /* disable all dynamic func */
 					pdmpriv->DMFlag = DYNAMIC_FUNC_DISABLE;
 					DBG_8192D("==> Disable all dynamic function...\n");
 				}
-				else if (dm_func == 1) {//disable DIG
+				else if (dm_func == 1) {/* disable DIG */
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_DIG);
 					DBG_8192D("==> Disable DIG...\n");
 				}
-				else if (dm_func == 2) {//disable High power
+				else if (dm_func == 2) {/* disable High power */
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_HP);
 				}
-				else if (dm_func == 3) {//disable tx power tracking
+				else if (dm_func == 3) {/* disable tx power tracking */
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_SS);
 					DBG_8192D("==> Disable tx power tracking...\n");
 				}
-				else if (dm_func == 4) {//disable BT coexistence
+				else if (dm_func == 4) {/* disable BT coexistence */
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_BT);
 				}
-				else if (dm_func == 5) {//disable antenna diversity
+				else if (dm_func == 5) {/* disable antenna diversity */
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_ANT_DIV);
 				}
-				else if (dm_func == 6) {//turn on all dynamic func
+				else if (dm_func == 6) {/* turn on all dynamic func */
 					if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
 					{
 						struct dm_priv	*pdmpriv = &pHalData->dmpriv;
@@ -5377,7 +5183,6 @@ SetHalDefVar8192DUsb(
 			}
 			break;
 		default:
-			//RT_TRACE(COMP_INIT, DBG_TRACE, ("SetHalDefVar819xUsb(): Unkown variable: %d!\n", eVariable));
 			bResult = false;
 			break;
 	}
@@ -5397,18 +5202,17 @@ u32  _update_92cu_basic_rate(struct rtw_
 	if (	(pbtpriv->BT_Coexist) &&	(pbtpriv->BT_CoexistType == BT_CSR_BC4)	)
 	{
 		BrateCfg = mask  & 0x151;
-		//DBG_8192D("BT temp disable cck 2/5.5/11M, (0x%x = 0x%x)\n", REG_RRSR, BrateCfg & 0x151);
 	}
 	else
 #endif
 	{
 		if (pHalData->VersionID != VERSION_TEST_CHIP_88C)
 			BrateCfg = mask  & 0x15F;
-		else	//for 88CU 46PING setting, Disable CCK 2M, 5.5M, Others must tuning
+		else	/* for 88CU 46PING setting, Disable CCK 2M, 5.5M, Others must tuning */
 			BrateCfg = mask  & 0x159;
 	}
 
-	BrateCfg |= 0x01; // default enable 1M ACK rate
+	BrateCfg |= 0x01; /*  default enable 1M ACK rate */
 
 	return BrateCfg;
 }
@@ -5416,12 +5220,12 @@ u32  _update_92cu_basic_rate(struct rtw_
 void _update_response_rate(struct rtw_adapter *padapter,unsigned int mask)
 {
 	u8	RateIndex = 0;
-	// Set RRSR rate table.
+	/*  Set RRSR rate table. */
 	rtw_write8(padapter, REG_RRSR, mask&0xff);
 	rtw_write8(padapter,REG_RRSR+1, (mask>>8)&0xff);
 
 
-	// Set RTS initial rate
+	/*  Set RTS initial rate */
 	while (mask > 0x1)
 	{
 		mask = (mask>> 1);
@@ -5461,13 +5265,12 @@ void UpdateHalRAMask8192DUsb(struct rtw_
 
 	switch (mac_id)
 	{
-		case 0:// for infra mode
+		case 0:/*  for infra mode */
 #ifdef CONFIG_CONCURRENT_MODE
-		case 2:// first station uses macid=0, second station uses macid=2
-#endif //CONFIG_CONCURRENT_MODE
+		case 2:/*  first station uses macid=0, second station uses macid=2 */
+#endif /* CONFIG_CONCURRENT_MODE */
 			supportRateNum = rtw_get_rateset_len(cur_network->SupportedRates);
 			networkType = judge_network_type(padapter, cur_network->SupportedRates, supportRateNum);
-			//pmlmeext->cur_wireless_mode = networkType;
 			raid = networktype_to_raid(networkType);
 
 			mask = update_supported_rate(cur_network->SupportedRates, supportRateNum);
@@ -5482,7 +5285,7 @@ void UpdateHalRAMask8192DUsb(struct rtw_
 
 			break;
 
-		case 1://for broadcast/multicast
+		case 1:/* for broadcast/multicast */
 			supportRateNum = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[mac_id].SupportedRates);
 			if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
 				networkType = WIRELESS_11B;
@@ -5495,7 +5298,7 @@ void UpdateHalRAMask8192DUsb(struct rtw_
 
 			break;
 
-		default: //for each sta in IBSS
+		default: /* for each sta in IBSS */
 #ifdef CONFIG_TDLS
 			if (psta->tdls_sta_state & TDLS_LINKED_STATE)
 			{
@@ -5505,17 +5308,16 @@ void UpdateHalRAMask8192DUsb(struct rtw_
 				break;
 			}
 			else
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 			{
 				supportRateNum = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[mac_id].SupportedRates);
 				networkType = judge_network_type(padapter, pmlmeinfo->FW_sta_info[mac_id].SupportedRates, supportRateNum);
-				//pmlmeext->cur_wireless_mode = networkType;
 				raid = networktype_to_raid(networkType);
 
 				mask = update_supported_rate(cur_network->SupportedRates, supportRateNum);
 				mask |= ((raid<<28)&0xf0000000);
 
-				//todo: support HT in IBSS
+				/* todo: support HT in IBSS */
 
 				break;
 			}
@@ -5554,18 +5356,17 @@ void UpdateHalRAMask8192DUsb(struct rtw_
 	}
 
 
-	//set ra_id
+	/* set ra_id */
 	psta->raid = raid;
 	psta->init_rate = init_rate;
 
-	//set correct initial date rate for each mac_id
+	/* set correct initial date rate for each mac_id */
 	pdmpriv->INIDATA_RATE[mac_id] = init_rate;
 }
 
 void SetBeaconRelatedRegisters8192DUsb(struct rtw_adapter * padapter)
 {
 	u32	value32;
-//	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
@@ -5578,10 +5379,9 @@ void SetBeaconRelatedRegisters8192DUsb(s
 
 	rtw_write8(padapter, REG_SLOT, 0x09);
 
-	//
-	// Reset TSF Timer to zero, added by Roger. 2008.06.24
-	//
-	//pHalData->TransmitConfig &= (~TSFRST);
+	/*  */
+	/*  Reset TSF Timer to zero, added by Roger. 2008.06.24 */
+	/*  */
 	value32 = rtw_read32(padapter, REG_TCR);
 	value32 &= ~TSFRST;
 	rtw_write32(padapter, REG_TCR, value32);
@@ -5589,7 +5389,7 @@ void SetBeaconRelatedRegisters8192DUsb(s
 	value32 |= TSFRST;
 	rtw_write32(padapter, REG_TCR, value32);
 
-	// NOTE: Fix test chip's bug (about contention windows's randomness)
+	/*  NOTE: Fix test chip's bug (about contention windows's randomness) */
 	rtw_write8(padapter,  REG_RXTSF_OFFSET_CCK, 0x50);
 	rtw_write8(padapter, REG_RXTSF_OFFSET_OFDM, 0x50);
 
@@ -5597,12 +5397,6 @@ void SetBeaconRelatedRegisters8192DUsb(s
 
 	ResumeTxBeacon(padapter);
 
-	//rtw_write8(padapter, 0x422, rtw_read8(padapter, 0x422)|BIT(6));
-
-	//rtw_write8(padapter, 0x541, 0xff);
-
-	//rtw_write8(padapter, 0x542, rtw_read8(padapter, 0x541)|BIT(0));
-
 	rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(1));
 }
 
@@ -5614,7 +5408,7 @@ static void rtl8192du_init_default_value
 
 	pHalData->CurrentWirelessMode = WIRELESS_MODE_AUTO;
 
-	//init default value
+	/* init default value */
 	pHalData->fw_ractrl = false;
 	if (!pwrctrlpriv->bkeepfwalive)
 		pHalData->LastHMEBoxNum = 0;
@@ -5622,9 +5416,8 @@ static void rtl8192du_init_default_value
 	pHalData->bEarlyModeEnable = 0;
 	pHalData->pwrGroupCnt = 0;
 
-	//init dm default value
+	/* init dm default value */
 	pdmpriv->TM_Trigger = 0;
-	//pdmpriv->binitialized = false;
 	pdmpriv->prv_traffic_idx = 3;
 
 	rtl8192d_PHY_ResetIQKResult(padapter);
@@ -5641,14 +5434,11 @@ _func_enter_;
 	if (padapter->HalData == NULL) {
 		DBG_8192D("cant not alloc memory for HAL DATA\n");
 	}
-	//memset(padapter->HalData, 0, sizeof(struct hal_data_8192du));
 	padapter->hal_data_sz = sizeof(struct hal_data_8192du);
 
 	pHalFunc->hal_init = &rtl8192du_hal_init;
 	pHalFunc->hal_deinit = &rtl8192du_hal_deinit;
 
-	//pHalFunc->free_hal_data = &rtl8192d_free_hal_data;
-
 	pHalFunc->inirp_init = &rtl8192du_inirp_init;
 	pHalFunc->inirp_deinit = &rtl8192du_inirp_deinit;
 
@@ -5660,19 +5450,15 @@ _func_enter_;
 #ifdef CONFIG_SW_LED
 	pHalFunc->InitSwLeds = &rtl8192du_InitSwLeds;
 	pHalFunc->DeInitSwLeds = &rtl8192du_DeInitSwLeds;
-#else // case of hw led or no led
+#else /*  case of hw led or no led */
 	pHalFunc->InitSwLeds = NULL;
 	pHalFunc->DeInitSwLeds = NULL;
-#endif //CONFIG_SW_LED
-	//pHalFunc->dm_init = &rtl8192d_init_dm_priv;
-	//pHalFunc->dm_deinit = &rtl8192d_deinit_dm_priv;
+#endif /* CONFIG_SW_LED */
 
 	pHalFunc->init_default_value = &rtl8192du_init_default_value;
 	pHalFunc->intf_chip_configure = &rtl8192du_interface_configure;
 	pHalFunc->read_adapter_info = &ReadAdapterInfo8192DU;
 
-	//pHalFunc->set_bwmode_handler = &PHY_SetBWMode8192D;
-	//pHalFunc->set_channel_handler = &PHY_SwChnl8192D;
 
 	pHalFunc->hal_dm_watchdog = &rtl8192d_HalDmWatchDog;
 
@@ -5687,10 +5473,6 @@ _func_enter_;
 	pHalFunc->hal_xmit = &rtl8192du_hal_xmit;
 	pHalFunc->mgnt_xmit = &rtl8192du_mgnt_xmit;
 
-	//pHalFunc->read_bbreg = &rtl8192d_PHY_QueryBBReg;
-	//pHalFunc->write_bbreg = &rtl8192d_PHY_SetBBReg;
-	//pHalFunc->read_rfreg = &rtl8192d_PHY_QueryRFReg;
-	//pHalFunc->write_rfreg = &rtl8192d_PHY_SetRFReg;
 
 #ifdef CONFIG_HOSTAPD_MLME
 	pHalFunc->hostap_mgnt_xmit_entry = &rtl8192du_hostap_mgnt_xmit_entry;
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -43,7 +43,7 @@ static int usbctrl_vendorreq(struct intf
 
 	#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_DYNAMIC_ALLOCATE
 	u8 *tmp_buf;
-	#else // use stack memory
+	#else /*  use stack memory */
 	u8 tmp_buf[MAX_USB_IO_CTL_SIZE];
 	#endif
 
@@ -57,7 +57,6 @@ static int usbctrl_vendorreq(struct intf
 #endif
 
 
-	//DBG_8192D("%s %s:%d\n",__func__, current->comm, current->pid);
 
 	if ((padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx)) {
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usbctrl_vendorreq:(padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
@@ -76,20 +75,20 @@ static int usbctrl_vendorreq(struct intf
 	#endif
 
 
-	// Acquire IO memory for vendorreq
+	/*  Acquire IO memory for vendorreq */
 #ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
 	pIo_buf = pdvobjpriv->usb_vendor_req_buf;
 #else
 	#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_DYNAMIC_ALLOCATE
 	tmp_buf = rtw_malloc((u32) len + ALIGNMENT_UNIT);
 	tmp_buflen =  (u32)len + ALIGNMENT_UNIT;
-	#else // use stack memory
+	#else /*  use stack memory */
 	tmp_buflen = MAX_USB_IO_CTL_SIZE;
 	#endif
 
-	// Added by Albert 2010/02/09
-	// For mstar platform, mstar suggests the address for USB IO should be 16 bytes alignment.
-	// Trying to fix it here.
+	/*  Added by Albert 2010/02/09 */
+	/*  For mstar platform, mstar suggests the address for USB IO should be 16 bytes alignment. */
+	/*  Trying to fix it here. */
 	pIo_buf = (tmp_buf==NULL)?NULL:tmp_buf + ALIGNMENT_UNIT -((SIZE_PTR)(tmp_buf) & 0x0f);
 #endif
 
@@ -105,27 +104,27 @@ static int usbctrl_vendorreq(struct intf
 
 		if (requesttype == 0x01)
 		{
-			pipe = usb_rcvctrlpipe(udev, 0);//read_in
+			pipe = usb_rcvctrlpipe(udev, 0);/* read_in */
 			reqtype =  REALTEK_USB_VENQT_READ;
 		}
 		else
 		{
-			pipe = usb_sndctrlpipe(udev, 0);//write_out
+			pipe = usb_sndctrlpipe(udev, 0);/* write_out */
 			reqtype =  REALTEK_USB_VENQT_WRITE;
 			memcpy(pIo_buf, pdata, len);
 		}
 
 		status = rtw_usb_control_msg(udev, pipe, request, reqtype, value, index, pIo_buf, len, RTW_USB_CONTROL_MSG_TIMEOUT);
 
-		if (status == len)   // Success this control transfer.
+		if (status == len)   /*  Success this control transfer. */
 		{
 			rtw_reset_continual_urb_error(pdvobjpriv);
 			if (requesttype == 0x01)
-			{   // For Control read transfer, we have to copy the read data from pIo_buf to pdata.
+			{   /*  For Control read transfer, we have to copy the read data from pIo_buf to pdata. */
 				memcpy(pdata, pIo_buf,  len);
 			}
 		}
-		else { // error cases
+		else { /*  error cases */
 			DBG_8192D("reg 0x%x, usb %s %u fail, status:%d value=0x%x, vendorreq_times:%d\n"
 				, value,(requesttype == 0x01)?"read":"write" , len, status, *(u32*)pdata, vendorreq_times);
 
@@ -142,11 +141,11 @@ static int usbctrl_vendorreq(struct intf
 					#endif
 				}
 			}
-			else // status != len && status >= 0
+			else /*  status != len && status >= 0 */
 			{
 				if (status > 0) {
 					if (requesttype == 0x01)
-					{   // For Control read transfer, we have to copy the read data from pIo_buf to pdata.
+					{   /*  For Control read transfer, we have to copy the read data from pIo_buf to pdata. */
 						memcpy(pdata, pIo_buf,  len);
 					}
 				}
@@ -159,13 +158,13 @@ static int usbctrl_vendorreq(struct intf
 
 		}
 
-		// firmware download is checksumed, don't retry
+		/*  firmware download is checksumed, don't retry */
 		if ((value >= FW_8192D_START_ADDRESS && value <= FW_8192D_END_ADDRESS) || status == len)
 			break;
 
 	}
 
-	// release IO memory used by vendorreq
+	/*  release IO memory used by vendorreq */
 	#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_DYNAMIC_ALLOCATE
 	kfree(tmp_buf);
 	#endif
@@ -190,8 +189,8 @@ static void usb_read_reg_rf_byfw(struct
 
 	if (pHalData->interfaceIndex!=0)
 	{
-		nPHY = 1; //MAC1
-		if (registerIndex&MAC1_ACCESS_PHY0)// MAC1 need to access PHY0
+		nPHY = 1; /* MAC1 */
+		if (registerIndex&MAC1_ACCESS_PHY0)/*  MAC1 need to access PHY0 */
 			nPHY = 0;
 	}
 	else
@@ -203,9 +202,9 @@ static void usb_read_reg_rf_byfw(struct
 	wPage = ((nPHY<<7)|(RFPath<<5)|8)<<8;
 	offset = (u16)registerIndex;
 
-	//
-	// IN a vendor request to read back MAC register.
-	//
+	/*  */
+	/*  IN a vendor request to read back MAC register. */
+	/*  */
 	usbctrl_vendorreq(pintfhdl, 0x05, offset, wPage, buffer, byteCount, 0x01);
 }
 
@@ -218,8 +217,8 @@ static void usb_read_reg(struct intf_hdl
 	u16	index;
 
 	request = 0x05;
-	requesttype = 0x01;//read_in
-	index = 0;//n/a
+	requesttype = 0x01;/* read_in */
+	index = 0;/* n/a */
 
 	if (pHalData->interfaceIndex!=0)
 	{
@@ -241,14 +240,14 @@ static int usb_write_reg(struct intf_hdl
 	u16	index;
 
 	request = 0x05;
-	requesttype = 0x00;//write_out
-	index = 0;//n/a
+	requesttype = 0x00;/* write_out */
+	index = 0;/* n/a */
 
 	if (pHalData->interfaceIndex!=0)
 	{
 		if (value<0x1000)
 			value|=0x4000;
-		else if ((value&MAC1_ACCESS_PHY0) && !(value&0x8000))// MAC1 need to access PHY0
+		else if ((value&MAC1_ACCESS_PHY0) && !(value&0x8000))/*  MAC1 need to access PHY0 */
 			value &= 0xFFF;
 	}
 
@@ -405,7 +404,7 @@ static void usb_read_interrupt_complete(
 	struct rtw_adapter		*padapter = (struct rtw_adapter	 *)purb->context;
 
 	padapter->recvpriv.int_cnt ++;
-	if (purb->status==0)//SUCCESS
+	if (purb->status==0)/* SUCCESS */
 	{
 		if (purb->actual_length > sizeof(INTERRUPT_MSG_FORMAT_EX))
 		{
@@ -427,7 +426,6 @@ static void usb_read_interrupt_complete(
 			case -EPIPE:
 			case -ENODEV:
 			case -ESHUTDOWN:
-				//padapter->bSurpriseRemoved=true;
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
 			case -ENOENT:
 				padapter->bDriverStopped=true;
@@ -455,7 +453,7 @@ static u32 usb_read_interrupt(struct int
 
 _func_enter_;
 
-	//translate DMA FIFO addr to pipehandle
+	/* translate DMA FIFO addr to pipehandle */
 	pipe = ffaddr2pipehdl(pdvobj, addr);
 
 	usb_fill_int_urb(precvpriv->int_in_urb, pusbd, pipe,
@@ -495,27 +493,25 @@ static s32 pre_recv_entry(union recv_fra
 
 	paddr1 = GetAddr1Ptr(precvframe->u.hdr.rx_data);
 
-	if (IS_MCAST(paddr1) == false)//unicast packets
+	if (IS_MCAST(paddr1) == false)/* unicast packets */
 	{
-		//primary_myid = myid(&primary_padapter->eeprompriv);
 		secondary_myid = myid(&secondary_padapter->eeprompriv);
 
 		if (_rtw_memcmp(paddr1, secondary_myid, ETH_ALEN))
 		{
-			//change to secondary interface
+			/* change to secondary interface */
 			precvframe->u.hdr.adapter = secondary_padapter;
 		}
 
-		//ret = recv_entry(precvframe);
 
 	}
-	else // Handle BC/MC Packets
+	else /*  Handle BC/MC Packets */
 	{
 		u8 clone = true;
 
 		if (true == clone)
 		{
-			//clone/copy to if2
+			/* clone/copy to if2 */
 			u8 shift_sz = 0;
 			u32 alloc_sz, skb_len;
 			struct sk_buff *pkt_copy = NULL;
@@ -527,16 +523,16 @@ static s32 pre_recv_entry(union recv_fra
 				precvframe_if2->u.hdr.adapter = secondary_padapter;
 
 				INIT_LIST_HEAD(&precvframe_if2->u.hdr.list);
-				precvframe_if2->u.hdr.precvbuf = NULL;	//can't access the precvbuf for new arch.
+				precvframe_if2->u.hdr.precvbuf = NULL;	/* can't access the precvbuf for new arch. */
 				precvframe_if2->u.hdr.len=0;
 
 				memcpy(&precvframe_if2->u.hdr.attrib, &precvframe->u.hdr.attrib, sizeof(struct rx_pkt_attrib));
 
 				pattrib = &precvframe_if2->u.hdr.attrib;
 
-				//	Modified by Albert 20101213
-				//	For 8 bytes IP header alignment.
-				if (pattrib->qos)	//	Qos data, wireless lan header length is 26
+				/* 	Modified by Albert 20101213 */
+				/* 	For 8 bytes IP header alignment. */
+				if (pattrib->qos)	/* 	Qos data, wireless lan header length is 26 */
 				{
 					shift_sz = 6;
 				}
@@ -547,10 +543,9 @@ static s32 pre_recv_entry(union recv_fra
 
 				skb_len = pattrib->pkt_len;
 
-				// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
-				// modify alloc_sz for recvive crc error packet by thomas 2011-06-02
+				/*  for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet. */
+				/*  modify alloc_sz for recvive crc error packet by thomas 2011-06-02 */
 				if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)) {
-					//alloc_sz = 1664;	//1664 is 128 alignment.
 					if (skb_len <= 1650)
 						alloc_sz = 1664;
 					else
@@ -558,12 +553,12 @@ static s32 pre_recv_entry(union recv_fra
 				}
 				else {
 					alloc_sz = skb_len;
-					//	6 is for IP header 8 bytes alignment in QoS packet case.
-					//	8 is for skb->data 4 bytes alignment.
+					/* 	6 is for IP header 8 bytes alignment in QoS packet case. */
+					/* 	8 is for skb->data 4 bytes alignment. */
 					alloc_sz += 14;
 				}
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
 				pkt_copy = dev_alloc_skb(alloc_sz);
 #else
 				pkt_copy = netdev_alloc_skb(secondary_padapter->pnetdev, alloc_sz);
@@ -574,14 +569,14 @@ static s32 pre_recv_entry(union recv_fra
 					precvframe_if2->u.hdr.pkt = pkt_copy;
 					precvframe_if2->u.hdr.rx_head = pkt_copy->data;
 					precvframe_if2->u.hdr.rx_end = pkt_copy->data + alloc_sz;
-					skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));//force pkt_copy->data at 8-byte alignment address
-					skb_reserve(pkt_copy, shift_sz);//force ip_hdr at 8-byte alignment address according to shift_sz.
+					skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));/* force pkt_copy->data at 8-byte alignment address */
+					skb_reserve(pkt_copy, shift_sz);/* force ip_hdr at 8-byte alignment address according to shift_sz. */
 					memcpy(pkt_copy->data, pbuf, skb_len);
 					precvframe_if2->u.hdr.rx_data = precvframe_if2->u.hdr.rx_tail = pkt_copy->data;
 				}
 
 				recvframe_put(precvframe_if2, skb_len);
-				//recvframe_pull(precvframe_if2, drvinfo_sz + RXDESC_SIZE);
+				/* recvframe_pull(precvframe_if2, drvinfo_sz + RXDESC_SIZE); */
 
 				rtl8192d_translate_rx_signal_stuff(precvframe_if2, pphy_info);
 
@@ -642,7 +637,7 @@ static int recvbuf2recvframe(struct rtw_
 		}
 
 		INIT_LIST_HEAD(&precvframe->u.hdr.list);
-		precvframe->u.hdr.precvbuf = NULL;	//can't access the precvbuf for new arch.
+		precvframe->u.hdr.precvbuf = NULL;	/* can't access the precvbuf for new arch. */
 		precvframe->u.hdr.len=0;
 
 		rtl8192d_query_rx_desc_status(precvframe, prxstat);
@@ -663,9 +658,9 @@ static int recvbuf2recvframe(struct rtw_
 			goto _exit_recvbuf2recvframe;
 		}
 
-		//	Modified by Albert 20101213
-		//	For 8 bytes IP header alignment.
-		if (pattrib->qos)	//	Qos data, wireless lan header length is 26
+		/* 	Modified by Albert 20101213 */
+		/* 	For 8 bytes IP header alignment. */
+		if (pattrib->qos)	/* 	Qos data, wireless lan header length is 26 */
 		{
 			shift_sz = 6;
 		}
@@ -676,10 +671,9 @@ static int recvbuf2recvframe(struct rtw_
 
 		skb_len = pattrib->pkt_len;
 
-		// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
-		// modify alloc_sz for recvive crc error packet by thomas 2011-06-02
+		/*  for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet. */
+		/*  modify alloc_sz for recvive crc error packet by thomas 2011-06-02 */
 		if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)) {
-			//alloc_sz = 1664;	//1664 is 128 alignment.
 			if (skb_len <= 1650)
 				alloc_sz = 1664;
 			else
@@ -687,12 +681,12 @@ static int recvbuf2recvframe(struct rtw_
 		}
 		else {
 			alloc_sz = skb_len;
-			//	6 is for IP header 8 bytes alignment in QoS packet case.
-			//	8 is for skb->data 4 bytes alignment.
+			/* 	6 is for IP header 8 bytes alignment in QoS packet case. */
+			/* 	8 is for skb->data 4 bytes alignment. */
 			alloc_sz += 14;
 		}
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
 		pkt_copy = dev_alloc_skb(alloc_sz);
 #else
 		pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
@@ -702,17 +696,17 @@ static int recvbuf2recvframe(struct rtw_
 			precvframe->u.hdr.pkt = pkt_copy;
 			precvframe->u.hdr.rx_head = pkt_copy->data;
 			precvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;
-			skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));//force pkt_copy->data at 8-byte alignment address
-			skb_reserve(pkt_copy, shift_sz);//force ip_hdr at 8-byte alignment address according to shift_sz.
+			skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));/* force pkt_copy->data at 8-byte alignment address */
+			skb_reserve(pkt_copy, shift_sz);/* force ip_hdr at 8-byte alignment address according to shift_sz. */
 			memcpy(pkt_copy->data, (pbuf + pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE), skb_len);
 			precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
 		}
 		else
 		{
 			DBG_8192D("recvbuf2recvframe:can not allocate memory for skb copy\n");
-			//precvframe->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC);
-			//precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pbuf;
-			//precvframe->u.hdr.rx_end = pbuf + (pkt_offset>1612?pkt_offset:1612);
+			/* precvframe->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC); */
+			/* precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pbuf; */
+			/* precvframe->u.hdr.rx_end = pbuf + (pkt_offset>1612?pkt_offset:1612); */
 
 			precvframe->u.hdr.pkt = NULL;
 			rtw_free_recvframe(precvframe, pfree_recv_queue);
@@ -721,7 +715,7 @@ static int recvbuf2recvframe(struct rtw_
 		}
 
 		recvframe_put(precvframe, skb_len);
-		//recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);
+		/* recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE); */
 
 #ifdef CONFIG_USB_RX_AGGREGATION
 		switch (pHalData->UsbRxAggMode)
@@ -761,7 +755,7 @@ static int recvbuf2recvframe(struct rtw_
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
 		}
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 		pkt_cnt--;
 
@@ -820,7 +814,7 @@ static void usb_read_port_complete(struc
 		goto exit;
 	}
 
-	if (purb->status==0)//SUCCESS
+	if (purb->status==0)/* SUCCESS */
 	{
 		if ((purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE))
 		{
@@ -832,7 +826,7 @@ static void usb_read_port_complete(struc
 		{
 			precvbuf->transfer_len = purb->actual_length;
 
-			//rtw_enqueue_rx_transfer_buffer(precvpriv, rx_transfer_buf);
+			/* rtw_enqueue_rx_transfer_buffer(precvpriv, rx_transfer_buf); */
 			rtw_enqueue_recvbuf(precvbuf, &precvpriv->recv_buf_pending_queue);
 
 			tasklet_schedule(&precvpriv->recv_tasklet);
@@ -849,7 +843,7 @@ static void usb_read_port_complete(struc
 			case -EPIPE:
 			case -ENODEV:
 			case -ESHUTDOWN:
-				//padapter->bSurpriseRemoved=true;
+				/* padapter->bSurpriseRemoved=true; */
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
 			case -ENOENT:
 				padapter->bDriverStopped=true;
@@ -902,14 +896,14 @@ _func_enter_;
 
 			purb = precvbuf->purb;
 
-			//translate DMA FIFO addr to pipehandle
+			/* translate DMA FIFO addr to pipehandle */
 			pipe = ffaddr2pipehdl(pdvobj, addr);
 
 			usb_fill_bulk_urb(purb, pusbd, pipe,
 						precvbuf->pbuf,
 						MAX_RECVBUF_SZ,
 						usb_read_port_complete,
-						precvbuf);//context is precvbuf
+						precvbuf);/* context is precvbuf */
 
 			purb->transfer_dma = precvbuf->dma_transfer_addr;
 			purb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
@@ -935,7 +929,7 @@ _func_exit_;
 
 	return ret;
 }
-#else	// CONFIG_USE_USB_BUFFER_ALLOC_RX
+#else	/*  CONFIG_USE_USB_BUFFER_ALLOC_RX */
 static int recvbuf2recvframe(struct rtw_adapter *padapter, struct sk_buff *pskb)
 {
 	u8	*pbuf;
@@ -974,7 +968,7 @@ static int recvbuf2recvframe(struct rtw_
 		}
 
 		INIT_LIST_HEAD(&precvframe->u.hdr.list);
-		precvframe->u.hdr.precvbuf = NULL;	//can't access the precvbuf for new arch.
+		precvframe->u.hdr.precvbuf = NULL;	/* can't access the precvbuf for new arch. */
 		precvframe->u.hdr.len=0;
 
 		rtl8192d_query_rx_desc_status(precvframe, prxstat);
@@ -995,9 +989,9 @@ static int recvbuf2recvframe(struct rtw_
 			goto _exit_recvbuf2recvframe;
 		}
 
-		//	Modified by Albert 20101213
-		//	For 8 bytes IP header alignment.
-		if (pattrib->qos)	//	Qos data, wireless lan header length is 26
+		/* 	Modified by Albert 20101213 */
+		/* 	For 8 bytes IP header alignment. */
+		if (pattrib->qos)	/* 	Qos data, wireless lan header length is 26 */
 		{
 			shift_sz = 6;
 		}
@@ -1008,10 +1002,9 @@ static int recvbuf2recvframe(struct rtw_
 
 		skb_len = pattrib->pkt_len;
 
-		// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
-		// modify alloc_sz for recvive crc error packet by thomas 2011-06-02
+		/*  for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet. */
+		/*  modify alloc_sz for recvive crc error packet by thomas 2011-06-02 */
 		if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)) {
-			//alloc_sz = 1664;	//1664 is 128 alignment.
 			if (skb_len <= 1650)
 				alloc_sz = 1664;
 			else
@@ -1019,12 +1012,12 @@ static int recvbuf2recvframe(struct rtw_
 		}
 		else {
 			alloc_sz = skb_len;
-			//	6 is for IP header 8 bytes alignment in QoS packet case.
-			//	8 is for skb->data 4 bytes alignment.
+			/* 	6 is for IP header 8 bytes alignment in QoS packet case. */
+			/* 	8 is for skb->data 4 bytes alignment. */
 			alloc_sz += 14;
 		}
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
 		pkt_copy = dev_alloc_skb(alloc_sz);
 #else
 		pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
@@ -1034,8 +1027,8 @@ static int recvbuf2recvframe(struct rtw_
 			precvframe->u.hdr.pkt = pkt_copy;
 			precvframe->u.hdr.rx_head = pkt_copy->data;
 			precvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;
-			skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));//force pkt_copy->data at 8-byte alignment address
-			skb_reserve(pkt_copy, shift_sz);//force ip_hdr at 8-byte alignment address according to shift_sz.
+			skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));/* force pkt_copy->data at 8-byte alignment address */
+			skb_reserve(pkt_copy, shift_sz);/* force ip_hdr at 8-byte alignment address according to shift_sz. */
 			memcpy(pkt_copy->data, (pbuf + pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE), skb_len);
 			precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
 		}
@@ -1056,7 +1049,6 @@ static int recvbuf2recvframe(struct rtw_
 		}
 
 		recvframe_put(precvframe, skb_len);
-		//recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);
 
 #ifdef CONFIG_USB_RX_AGGREGATION
 		switch (pHalData->UsbRxAggMode)
@@ -1095,7 +1087,7 @@ static int recvbuf2recvframe(struct rtw_
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
 		}
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 		pkt_cnt--;
 
 		transfer_len -= pkt_offset;
@@ -1173,7 +1165,7 @@ static void usb_read_port_complete(struc
 		goto exit;
 	}
 
-	if (purb->status==0)//SUCCESS
+	if (purb->status==0)/* SUCCESS */
 	{
 		if ((purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE))
 		{
@@ -1207,7 +1199,6 @@ static void usb_read_port_complete(struc
 			case -EPIPE:
 			case -ENODEV:
 			case -ESHUTDOWN:
-				//padapter->bSurpriseRemoved=true;
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
 			case -ENOENT:
 				padapter->bDriverStopped=true;
@@ -1268,11 +1259,10 @@ _func_enter_;
 	{
 		rtl8192du_init_recvbuf(adapter, precvbuf);
 
-		//re-assign for linux based on skb
+		/* re-assign for linux based on skb */
 		if ((precvbuf->reuse == false) || (precvbuf->pskb == NULL))
 		{
-			//precvbuf->pskb = alloc_skb(MAX_RECVBUF_SZ, GFP_ATOMIC);//don't use this after v2.6.25
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
 			precvbuf->pskb = dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
 #else
 			precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
@@ -1293,7 +1283,7 @@ _func_enter_;
 			precvbuf->pend = skb_end_pointer(precvbuf->pskb);
 			precvbuf->pbuf = precvbuf->pskb->data;
 		}
-		else//reuse skb
+		else/* reuse skb */
 		{
 			precvbuf->phead = precvbuf->pskb->head;
 			precvbuf->pdata = precvbuf->pskb->data;
@@ -1308,14 +1298,14 @@ _func_enter_;
 
 		purb = precvbuf->purb;
 
-		//translate DMA FIFO addr to pipehandle
+		/* translate DMA FIFO addr to pipehandle */
 		pipe = ffaddr2pipehdl(pdvobj, addr);
 
 		usb_fill_bulk_urb(purb, pusbd, pipe,
 						precvbuf->pbuf,
 						MAX_RECVBUF_SZ,
 						usb_read_port_complete,
-						precvbuf);//context is precvbuf
+						precvbuf);/* context is precvbuf */
 
 		err = usb_submit_urb(purb, GFP_ATOMIC);
 		if ((err) && (err != (-EPERM)))
@@ -1335,7 +1325,7 @@ _func_exit_;
 
 	return ret;
 }
-#endif	// CONFIG_USE_USB_BUFFER_ALLOC_RX
+#endif	/*  CONFIG_USE_USB_BUFFER_ALLOC_RX */
 
 void rtl8192du_xmit_tasklet(void *priv)
 {

From fb497ae0af2bc40feea499c086a7032b60410283 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Thu, 18 Apr 2013 08:32:47 -0500
Subject: [PATCH 034/390] More cleanups

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_debug.c     |  18 +-
 include/hal_intf.h   |   2 +
 include/rtw_debug.h  |  18 +-
 os_dep/ioctl_linux.c | 887 +++++++++++++++++++++++++--------------------------
 os_dep/mlme_linux.c  |   8 +-
 os_dep/os_intfs.c    | 871 +++++++++++++++++++++++---------------------------
 os_dep/rtw_android.c |  16 +-
 7 files changed, 856 insertions(+), 964 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_debug.c
+++ b/drivers/staging/rtl8192du/core/rtw_debug.c
@@ -95,7 +95,7 @@ int proc_get_log_level(char *page, char
 	return len;
 }
 
-int proc_set_log_level(struct file *file, const char *buffer,
+int proc_set_log_level(struct file *file, const char __user *buffer,
 		unsigned long count, void *data)
 {
 	struct net_device *dev = (struct net_device *)data;
@@ -129,7 +129,7 @@ int proc_get_write_reg(char *page, char
 	return 0;
 }
 
-int proc_set_write_reg(struct file *file, const char *buffer,
+int proc_set_write_reg(struct file *file, const char __user *buffer,
 		unsigned long count, void *data)
 {
 	struct net_device *dev = (struct net_device *)data;
@@ -213,7 +213,7 @@ int proc_get_read_reg(char *page, char *
 
 }
 
-int proc_set_read_reg(struct file *file, const char *buffer,
+int proc_set_read_reg(struct file *file, const char __user *buffer,
 		unsigned long count, void *data)
 {
 	char tmp[16];
@@ -702,7 +702,7 @@ int proc_get_rx_signal(char *page, char
 	return len;
 }
 
-int proc_set_rx_signal(struct file *file, const char *buffer,
+int proc_set_rx_signal(struct file *file, const char __user *buffer,
 		unsigned long count, void *data)
 {
 	struct net_device *dev = (struct net_device *)data;
@@ -759,7 +759,7 @@ int proc_get_ht_enable(char *page, char
 	return len;
 }
 
-int proc_set_ht_enable(struct file *file, const char *buffer,
+int proc_set_ht_enable(struct file *file, const char __user *buffer,
 		unsigned long count, void *data)
 {
 	struct net_device *dev = (struct net_device *)data;
@@ -807,7 +807,7 @@ int proc_get_cbw40_enable(char *page, ch
 	return len;
 }
 
-int proc_set_cbw40_enable(struct file *file, const char *buffer,
+int proc_set_cbw40_enable(struct file *file, const char __user *buffer,
 		unsigned long count, void *data)
 {
 	struct net_device *dev = (struct net_device *)data;
@@ -854,7 +854,7 @@ int proc_get_ampdu_enable(char *page, ch
 	return len;
 }
 
-int proc_set_ampdu_enable(struct file *file, const char *buffer,
+int proc_set_ampdu_enable(struct file *file, const char __user *buffer,
 		unsigned long count, void *data)
 {
 	struct net_device *dev = (struct net_device *)data;
@@ -922,7 +922,7 @@ int proc_get_rx_stbc(char *page, char **
 	return len;
 }
 
-int proc_set_rx_stbc(struct file *file, const char *buffer,
+int proc_set_rx_stbc(struct file *file, const char __user *buffer,
 		unsigned long count, void *data)
 {
 	struct net_device *dev = (struct net_device *)data;
@@ -995,7 +995,7 @@ int proc_get_rssi_disp(char *page, char
 	return 0;
 }
 
-int proc_set_rssi_disp(struct file *file, const char *buffer,
+int proc_set_rssi_disp(struct file *file, const char __user *buffer,
 		unsigned long count, void *data)
 {
 	struct net_device *dev = (struct net_device *)data;
--- a/drivers/staging/rtl8192du/include/hal_intf.h
+++ b/drivers/staging/rtl8192du/include/hal_intf.h
@@ -24,6 +24,8 @@
 #include <osdep_service.h>
 #include <drv_types.h>
 
+extern int rtw_ht_enable;
+
 enum RTL871X_HCI_TYPE {
 
 	RTW_SDIO,
--- a/drivers/staging/rtl8192du/include/rtw_debug.h
+++ b/drivers/staging/rtl8192du/include/rtw_debug.h
@@ -278,21 +278,21 @@ extern u32 GlobalDebugLevel;
 			  off_t offset, int count,
 			  int *eof, void *data);
 
-	int proc_set_log_level(struct file *file, const char *buffer,
+	int proc_set_log_level(struct file *file, const char __user *buffer,
 			unsigned long count, void *data);
 
 	int proc_get_write_reg(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
 
-	int proc_set_write_reg(struct file *file, const char *buffer,
+	int proc_set_write_reg(struct file *file, const char __user *buffer,
 		unsigned long count, void *data);
 
 	int proc_get_read_reg(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
 
-	int proc_set_read_reg(struct file *file, const char *buffer,
+	int proc_set_read_reg(struct file *file, const char __user *buffer,
 		unsigned long count, void *data);
 
 
@@ -396,28 +396,28 @@ extern u32 GlobalDebugLevel;
 			  off_t offset, int count,
 			  int *eof, void *data);
 
-	int proc_set_rx_signal(struct file *file, const char *buffer,
+	int proc_set_rx_signal(struct file *file, const char __user *buffer,
 		unsigned long count, void *data);
 
 	int proc_get_ht_enable(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
 
-	int proc_set_ht_enable(struct file *file, const char *buffer,
+	int proc_set_ht_enable(struct file *file, const char __user *buffer,
 		unsigned long count, void *data);
 
 	int proc_get_cbw40_enable(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
 
-	int proc_set_cbw40_enable(struct file *file, const char *buffer,
+	int proc_set_cbw40_enable(struct file *file, const char __user *buffer,
 		unsigned long count, void *data);
 
 	int proc_get_ampdu_enable(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
 
-	int proc_set_ampdu_enable(struct file *file, const char *buffer,
+	int proc_set_ampdu_enable(struct file *file, const char __user *buffer,
 		unsigned long count, void *data);
 
 	int proc_get_two_path_rssi(char *page, char **start,
@@ -428,7 +428,7 @@ extern u32 GlobalDebugLevel;
 			  off_t offset, int count,
 			  int *eof, void *data);
 
-	int proc_set_rx_stbc(struct file *file, const char *buffer,
+	int proc_set_rx_stbc(struct file *file, const char __user *buffer,
 		unsigned long count, void *data);
 
 
@@ -444,7 +444,7 @@ extern u32 GlobalDebugLevel;
 			  off_t offset, int count,
 			  int *eof, void *data);
 
-	int proc_set_rssi_disp(struct file *file, const char *buffer,
+	int proc_set_rssi_disp(struct file *file, const char __user *buffer,
 		unsigned long count, void *data);
 
 
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -136,12 +136,12 @@ static void indicate_wx_custom_event(_ad
 	union iwreq_data wrqu;
 
 	if ((u32)strlen(msg) > IW_CUSTOM_MAX) {
-		DBG_871X("%s strlen(msg):%u > IW_CUSTOM_MAX:%u\n", __FUNCTION__ ,(u32)strlen(msg), IW_CUSTOM_MAX);
+		DBG_871X("%s strlen(msg):%u > IW_CUSTOM_MAX:%u\n", __func__ ,(u32)strlen(msg), IW_CUSTOM_MAX);
 		return;
 	}
 
 	buff = rtw_zmalloc(IW_CUSTOM_MAX+1);
-	if(!buff)
+	if (!buff)
 		return;
 
 	_rtw_memcpy(buff, msg, strlen(msg));
@@ -149,7 +149,7 @@ static void indicate_wx_custom_event(_ad
 	_rtw_memset(&wrqu,0,sizeof(wrqu));
 	wrqu.data.length = strlen(msg);
 
-	DBG_871X("%s %s\n", __FUNCTION__, buff);
+	DBG_871X("%s %s\n", __func__, buff);
 	wireless_send_event(padapter->pnetdev, IWEVCUSTOM, &wrqu, buff);
 
 	rtw_mfree(buff, IW_CUSTOM_MAX+1);
@@ -164,7 +164,7 @@ static void request_wps_pbc_event(_adapt
 	union iwreq_data wrqu;
 
 	buff = rtw_malloc(IW_CUSTOM_MAX);
-	if(!buff)
+	if (!buff)
 		return;
 
 	_rtw_memset(buff, 0, IW_CUSTOM_MAX);
@@ -179,11 +179,11 @@ static void request_wps_pbc_event(_adapt
 
 	wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
 
-	DBG_871X("%s\n", __FUNCTION__);
+	DBG_871X("%s\n", __func__);
 
 	wireless_send_event(padapter->pnetdev, IWEVCUSTOM, &wrqu, buff);
 
-	if(buff)
+	if (buff)
 	{
 		rtw_mfree(buff, IW_CUSTOM_MAX);
 	}
@@ -299,7 +299,7 @@ static char *translate_scan(_adapter *pa
 		      (SCAN_RESULT_WFD_TYPE == pwdinfo->wfd_info->scan_result_type))
 #endif // CONFIG_WFD
 	{
-		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
 			u32	blnGotP2PIE = _FALSE;
 
@@ -387,7 +387,7 @@ static char *translate_scan(_adapter *pa
 	//parsing HT_CAP_IE
 		p = rtw_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-12);
 
-	if(p && ht_ielen>0)
+	if (p && ht_ielen>0)
 	{
 		struct rtw_ieee80211_ht_cap *pht_capie;
 		ht_cap = _TRUE;
@@ -401,30 +401,30 @@ static char *translate_scan(_adapter *pa
 	iwe.cmd = SIOCGIWNAME;
 	if ((rtw_is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)
 	{
-		if(ht_cap == _TRUE)
+		if (ht_cap == _TRUE)
 			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");
 		else
 		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
 	}
 	else if ((rtw_is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)
 	{
-		if(ht_cap == _TRUE)
+		if (ht_cap == _TRUE)
 			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");
 		else
 		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
 	}
 	else
 	{
-		if(pnetwork->network.Configuration.DSConfig > 14)
+		if (pnetwork->network.Configuration.DSConfig > 14)
 		{
-			if(ht_cap == _TRUE)
+			if (ht_cap == _TRUE)
 				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11an");
 			else
 				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11a");
 		}
 		else
 		{
-			if(ht_cap == _TRUE)
+			if (ht_cap == _TRUE)
 				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");
 			else
 				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");
@@ -440,7 +440,7 @@ static char *translate_scan(_adapter *pa
 
 	cap = le16_to_cpu(cap);
 
-	if(cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)){
+	if (cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)){
 		if (cap & WLAN_CAPABILITY_BSS)
 			iwe.u.mode = IW_MODE_MASTER;
 		else
@@ -449,7 +449,7 @@ static char *translate_scan(_adapter *pa
 		start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_UINT_LEN);
 	}
 
-	if(pnetwork->network.Configuration.DSConfig<1 /*|| pnetwork->network.Configuration.DSConfig>14*/)
+	if (pnetwork->network.Configuration.DSConfig<1 /*|| pnetwork->network.Configuration.DSConfig>14*/)
 		pnetwork->network.Configuration.DSConfig = 1;
 
 	 /* Add frequency/channel */
@@ -482,14 +482,14 @@ static char *translate_scan(_adapter *pa
 		i++;
 	}
 
-	if(ht_cap == _TRUE)
+	if (ht_cap == _TRUE)
 	{
-		if(mcs_rate&0x8000)//MCS15
+		if (mcs_rate&0x8000)//MCS15
 		{
 			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
 
 		}
-		else if(mcs_rate&0x0080)//MCS7
+		else if (mcs_rate&0x0080)//MCS7
 		{
 			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
 		}
@@ -567,7 +567,7 @@ static char *translate_scan(_adapter *pa
 
 		while(cnt < total_ielen)
 		{
-			if(rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2))
+			if (rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2))
 			{
 				wpsie_ptr = &ie_ptr[cnt];
 				iwe.cmd =IWEVGENIE;
@@ -633,14 +633,14 @@ static int wpa_set_auth_algs(struct net_
 
 		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeShared;
 		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;
-	} else if(value & AUTH_ALG_OPEN_SYSTEM) {
+	} else if (value & AUTH_ALG_OPEN_SYSTEM) {
 		DBG_871X("wpa_set_auth_algs, AUTH_ALG_OPEN_SYSTEM\n");
-		if(padapter->securitypriv.ndisauthtype < Ndis802_11AuthModeWPAPSK) {
+		if (padapter->securitypriv.ndisauthtype < Ndis802_11AuthModeWPAPSK) {
 			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
 			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
 		}
 	}
-	else if(value & AUTH_ALG_LEAP)
+	else if (value & AUTH_ALG_LEAP)
 	{
 		DBG_871X("wpa_set_auth_algs, AUTH_ALG_LEAP\n");
 	}
@@ -716,7 +716,7 @@ _func_enter_;
 			wep_key_len = wep_key_len <= 5 ? 5 : 13;
 			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
 			pwep =(NDIS_802_11_WEP	 *) rtw_malloc(wep_total_len);
-			if(pwep == NULL){
+			if (pwep == NULL){
 				RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,(" wpa_set_encryption: pwep allocate fail !!!\n"));
 				goto exit;
 			}
@@ -726,7 +726,7 @@ _func_enter_;
 			pwep->KeyLength = wep_key_len;
 			pwep->Length = wep_total_len;
 
-			if(wep_key_len==13)
+			if (wep_key_len==13)
 			{
 				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
 				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
@@ -742,11 +742,11 @@ _func_enter_;
 
 		_rtw_memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
 
-		if(param->u.crypt.set_tx)
+		if (param->u.crypt.set_tx)
 		{
 			DBG_871X("wep, set_tx=1\n");
 
-			if(rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
+			if (rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
 			{
 				ret = -EOPNOTSUPP ;
 			}
@@ -771,7 +771,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	if(padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) // 802_1x
+	if (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) // 802_1x
 	{
 		struct sta_info * psta,*pbcmc_sta;
 		struct sta_priv * pstapriv = &padapter->stapriv;
@@ -788,17 +788,17 @@ _func_enter_;
 				if (strcmp(param->u.crypt.alg, "none") != 0)
 					psta->ieee8021x_blocked = _FALSE;
 
-				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+				if ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
 						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
 				{
 					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
 				}
 
-				if(param->u.crypt.set_tx ==1)//pairwise key
+				if (param->u.crypt.set_tx ==1)//pairwise key
 				{
 					_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
-					if(strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
+					if (strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
 					{
 						//DEBUG_ERR(("\nset key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
 						_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
@@ -828,7 +828,7 @@ _func_enter_;
 
 					rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1);
 #ifdef CONFIG_P2P
-					if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
+					if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
 					{
 						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_DONE);
 					}
@@ -838,7 +838,7 @@ _func_enter_;
 			}
 
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
-			if(pbcmc_sta==NULL)
+			if (pbcmc_sta==NULL)
 			{
 				//DEBUG_ERR(("Set OID_802_11_ADD_KEY: bcmc stainfo is null \n"));
 			}
@@ -848,14 +848,14 @@ _func_enter_;
 				if (strcmp(param->u.crypt.alg, "none") != 0)
 					pbcmc_sta->ieee8021x_blocked = _FALSE;
 
-				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
+				if ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
 						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
 				{
 					pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
 				}
 			}
 		}
-		else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
+		else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
 		{
 		}
 	}
@@ -882,15 +882,15 @@ static int rtw_set_wpa_ie(_adapter *pada
 	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
 #endif //CONFIG_P2P
 
-	if((ielen > MAX_WPA_IE_LEN) || (pie == NULL)){
+	if ((ielen > MAX_WPA_IE_LEN) || (pie == NULL)){
 		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
-		if(pie == NULL)
+		if (pie == NULL)
 			return ret;
 		else
 			return -EINVAL;
 	}
 
-	if(ielen)
+	if (ielen)
 	{
 		buf = rtw_zmalloc(ielen);
 		if (buf == NULL){
@@ -909,20 +909,20 @@ static int rtw_set_wpa_ie(_adapter *pada
 		}
 
 		pos = buf;
-		if(ielen < RSN_HEADER_LEN){
+		if (ielen < RSN_HEADER_LEN){
 			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie len too short %d\n", ielen));
 			ret  = -1;
 			goto exit;
 		}
 
-		if(rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		if (rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
 			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
 			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPAPSK;
 			_rtw_memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);
 		}
 
-		if(rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		if (rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
 			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
 			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPA2PSK;
@@ -995,7 +995,7 @@ static int rtw_set_wpa_ie(_adapter *pada
 			{
 				eid = buf[cnt];
 
-				if((eid==_VENDOR_SPECIFIC_IE_)&&(_rtw_memcmp(&buf[cnt+2], wps_oui, 4)==_TRUE))
+				if ((eid==_VENDOR_SPECIFIC_IE_)&&(_rtw_memcmp(&buf[cnt+2], wps_oui, 4)==_TRUE))
 				{
 					DBG_871X("SET WPS_IE\n");
 
@@ -1006,7 +1006,7 @@ static int rtw_set_wpa_ie(_adapter *pada
 					set_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS);
 
 #ifdef CONFIG_P2P
-					if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_OK))
+					if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_OK))
 					{
 						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_ING);
 					}
@@ -1022,7 +1022,7 @@ static int rtw_set_wpa_ie(_adapter *pada
 	}
 
 	//TKIP and AES disallow multicast packets until installing group key
-	if(padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_
+	if (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
 		//WPS open need to enable multicast
@@ -1061,7 +1061,7 @@ static int rtw_wx_get_name(struct net_de
 	{
 		//parsing HT_CAP_IE
 		p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
-		if(p && ht_ielen>0)
+		if (p && ht_ielen>0)
 		{
 			ht_cap = _TRUE;
 		}
@@ -1070,30 +1070,30 @@ static int rtw_wx_get_name(struct net_de
 
 		if (rtw_is_cckratesonly_included((u8*)prates) == _TRUE)
 		{
-			if(ht_cap == _TRUE)
+			if (ht_cap == _TRUE)
 				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bn");
 			else
 				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11b");
 		}
 		else if ((rtw_is_cckrates_included((u8*)prates)) == _TRUE)
 		{
-			if(ht_cap == _TRUE)
+			if (ht_cap == _TRUE)
 				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bgn");
 			else
 				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bg");
 		}
 		else
 		{
-			if(pcur_bss->Configuration.DSConfig > 14)
+			if (pcur_bss->Configuration.DSConfig > 14)
 			{
-				if(ht_cap == _TRUE)
+				if (ht_cap == _TRUE)
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11an");
 				else
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11a");
 			}
 			else
 			{
-				if(ht_cap == _TRUE)
+				if (ht_cap == _TRUE)
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11gn");
 				else
 					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
@@ -1133,7 +1133,7 @@ static int rtw_wx_get_freq(struct net_de
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
 	{
 		//wrqu->freq.m = ieee80211_wlan_frequencies[pcur_bss->Configuration.DSConfig-1] * 100000;
 		wrqu->freq.m = rtw_ch2freq(pcur_bss->Configuration.DSConfig) * 100000;
@@ -1161,7 +1161,7 @@ static int rtw_wx_set_mode(struct net_de
 	_queue *queue = &pmlmepriv->scanned_queue;
 	_func_enter_;
 
-	if(_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (_FAIL == rtw_pwr_wakeup(padapter)) {
 		ret= -EPERM;
 		goto exit;
 	}
@@ -1198,7 +1198,7 @@ static int rtw_wx_set_mode(struct net_de
 	}
 
 /*
-	if(Ndis802_11APMode == networkType)
+	if (Ndis802_11APMode == networkType)
 	{
 		rtw_setopmode_cmd(padapter, networkType);
 	}
@@ -1249,7 +1249,7 @@ static int rtw_wx_get_mode(struct net_de
 	{
 		wrqu->mode = IW_MODE_ADHOC;
 	}
-	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
+	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
 	{
 		wrqu->mode = IW_MODE_MASTER;
 	}
@@ -1308,7 +1308,7 @@ static int rtw_wx_set_pmkid(struct net_d
 		//overwrite PMKID
 		for(j=0 ; j<NUM_PMKID_CACHE; j++)
 		{
-			if(_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE)
+			if (_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE)
 			{ // BSSID is matched, the same AP => rewrite with new PMKID.
 
                                 DBG_871X("[rtw_wx_set_pmkid] BSSID exists in the PMKList.\n");
@@ -1321,7 +1321,7 @@ static int rtw_wx_set_pmkid(struct net_d
 			}
 	        }
 
-	        if(!blInserted)
+	        if (!blInserted)
                 {
 		    // Find a new entry
                     DBG_871X("[rtw_wx_set_pmkid] Use the new entry index = %d for this PMKID.\n",
@@ -1332,7 +1332,7 @@ static int rtw_wx_set_pmkid(struct net_d
 
                     psecuritypriv->PMKIDList[ psecuritypriv->PMKIDIndex ].bUsed = _TRUE;
 		    psecuritypriv->PMKIDIndex++ ;
-		    if(psecuritypriv->PMKIDIndex==16)
+		    if (psecuritypriv->PMKIDIndex==16)
                     {
 		        psecuritypriv->PMKIDIndex =0;
                     }
@@ -1344,7 +1344,7 @@ static int rtw_wx_set_pmkid(struct net_d
                 intReturn = _TRUE;
 		for(j=0 ; j<NUM_PMKID_CACHE; j++)
 		{
-			if(_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE)
+			if (_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE)
 			{ // BSSID is matched, the same AP => Remove this PMKID information and reset it.
                                 _rtw_memset(psecuritypriv->PMKIDList[ j ].Bssid, 0x00, ETH_ALEN);
                                 psecuritypriv->PMKIDList[ j ].bUsed = _FALSE;
@@ -1451,7 +1451,7 @@ static int rtw_wx_get_range(struct net_d
 	for (i = 0, val = 0; i < MAX_CHANNEL_NUM; i++) {
 
 		// Include only legal frequencies for some countries
-		if(pmlmeext->channel_set[i].ChannelNum != 0)
+		if (pmlmeext->channel_set[i].ChannelNum != 0)
 		{
 			range->freq[val].i = pmlmeext->channel_set[i].ChannelNum;
 			range->freq[val].m = rtw_ch2freq(pmlmeext->channel_set[i].ChannelNum) * 100000;
@@ -1523,7 +1523,7 @@ static int rtw_wx_set_wap(struct net_dev
 	_func_enter_;
 /*
 #ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->iface_type > PRIMARY_IFACE)
+	if (padapter->iface_type > PRIMARY_IFACE)
 	{
 		ret = -EINVAL;
 		goto exit;
@@ -1551,13 +1551,13 @@ static int rtw_wx_set_wap(struct net_dev
 	}
 #endif
 
-	if(_FAIL == rtw_pwr_wakeup(padapter))
+	if (_FAIL == rtw_pwr_wakeup(padapter))
 	{
 		ret= -1;
 		goto exit;
 	}
 
-	if(!padapter->bup){
+	if (!padapter->bup){
 		ret = -1;
 		goto exit;
 	}
@@ -1587,7 +1587,7 @@ static int rtw_wx_set_wap(struct net_dev
 		src_bssid = temp->sa_data;
 
 		if ((_rtw_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == _TRUE) {
-			if(!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode)) {
+			if (!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode)) {
 				ret = -1;
 				_exit_critical_bh(&queue->lock, &irqL);
 				_exit_critical_bh(&pmlmepriv->lock, &irqL);
@@ -1659,25 +1659,25 @@ static int rtw_wx_set_mlme(struct net_de
 	struct iw_mlme *mlme = (struct iw_mlme *) extra;
 
 
-	if(mlme==NULL)
+	if (mlme==NULL)
 		return -1;
 
-	printk("%s\n", __FUNCTION__);
+	printk("%s\n", __func__);
 
 	reason = cpu_to_le16(mlme->reason_code);
 
 
-	printk("%s, cmd=%d, reason=%d\n", __FUNCTION__, mlme->cmd, reason);
+	printk("%s, cmd=%d, reason=%d\n", __func__, mlme->cmd, reason);
 
 	switch (mlme->cmd)
 	{
 		case IW_MLME_DEAUTH:
-				if(!rtw_set_802_11_disassociate(padapter))
+				if (!rtw_set_802_11_disassociate(padapter))
 				ret = -1;
 				break;
 
 		case IW_MLME_DISASSOC:
-				if(!rtw_set_802_11_disassociate(padapter))
+				if (!rtw_set_802_11_disassociate(padapter))
 						ret = -1;
 
 				break;
@@ -1707,11 +1707,11 @@ static int rtw_wx_set_scan(struct net_de
 _func_enter_;
 
 	#ifdef DBG_IOCTL
-	DBG_871X("DBG_IOCTL %s:%d\n",__FUNCTION__, __LINE__);
+	DBG_871X("DBG_IOCTL %s:%d\n",__func__, __LINE__);
 	#endif
 /*
 #ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->iface_type > PRIMARY_IFACE)
+	if (padapter->iface_type > PRIMARY_IFACE)
 	{
 		ret = -1;
 		goto exit;
@@ -1727,19 +1727,19 @@ _func_enter_;
 	}
 #endif
 
-	if(_FAIL == rtw_pwr_wakeup(padapter))
+	if (_FAIL == rtw_pwr_wakeup(padapter))
 	{
 		ret= -1;
 		goto exit;
 	}
 
-	if(padapter->bDriverStopped){
+	if (padapter->bDriverStopped){
            DBG_871X("bDriverStopped=%d\n", padapter->bDriverStopped);
 		ret= -1;
 		goto exit;
 	}
 
-	if(!padapter->bup){
+	if (!padapter->bup){
 		ret = -1;
 		goto exit;
 	}
@@ -1768,7 +1768,7 @@ _func_enter_;
 	if (check_buddy_fwstate(padapter,
 		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE)
 	{
-		if(check_buddy_fwstate(padapter, _FW_UNDER_SURVEY))
+		if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY))
 		{
 			printk("scanning_via_buddy_intf\n");
 			pmlmepriv->scanning_via_buddy_intf = _TRUE;
@@ -1794,10 +1794,10 @@ _func_enter_;
 //	So, the wpa_supplicant won't find out the WPS SoftAP.
 
 /*
-	if(pmlmepriv->scan_interval>10)
+	if (pmlmepriv->scan_interval>10)
 		pmlmepriv->scan_interval = 0;
 
-	if(pmlmepriv->scan_interval > 0)
+	if (pmlmepriv->scan_interval > 0)
 	{
 		DBG_871X("scan done\n");
 		ret = 0;
@@ -1806,7 +1806,7 @@ _func_enter_;
 
 */
 #ifdef CONFIG_P2P
-	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
@@ -1847,7 +1847,7 @@ _func_enter_;
 	else
 #endif
 
-	if(	wrqu->data.length >= WEXT_CSCAN_HEADER_SIZE
+	if (	wrqu->data.length >= WEXT_CSCAN_HEADER_SIZE
 		&& _rtw_memcmp(extra, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == _TRUE
 	)
 	{
@@ -1857,7 +1857,7 @@ _func_enter_;
 		char sec_len;
 		int ssid_index = 0;
 
-		//DBG_871X("%s COMBO_SCAN header is recognized\n", __FUNCTION__);
+		//DBG_871X("%s COMBO_SCAN header is recognized\n", __func__);
 
 		while(len >= 1) {
 			section = *(pos++); len-=1;
@@ -1865,17 +1865,17 @@ _func_enter_;
 			switch(section) {
 				case WEXT_CSCAN_SSID_SECTION:
 					//DBG_871X("WEXT_CSCAN_SSID_SECTION\n");
-					if(len < 1) {
+					if (len < 1) {
 						len = 0;
 						break;
 					}
 
 					sec_len = *(pos++); len-=1;
 
-					if(sec_len>0 && sec_len<=len) {
+					if (sec_len>0 && sec_len<=len) {
 						ssid[ssid_index].SsidLength = sec_len;
 						_rtw_memcpy(ssid[ssid_index].Ssid, pos, ssid[ssid_index].SsidLength);
-						//DBG_871X("%s COMBO_SCAN with specific ssid:%s, %d\n", __FUNCTION__
+						//DBG_871X("%s COMBO_SCAN with specific ssid:%s, %d\n", __func__
 						//	, ssid[ssid_index].Ssid, ssid[ssid_index].SsidLength);
 						ssid_index++;
 					}
@@ -1915,12 +1915,12 @@ _func_enter_;
 		_status = rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);
 	}
 
-	if(_status == _FALSE)
+	if (_status == _FALSE)
 		ret = -1;
 
 exit:
 	#ifdef DBG_IOCTL
-	DBG_871X("DBG_IOCTL %s:%d return %d\n",__FUNCTION__, __LINE__, ret);
+	DBG_871X("DBG_IOCTL %s:%d return %d\n",__func__, __LINE__, ret);
 	#endif
 
 _func_exit_;
@@ -1956,26 +1956,26 @@ static int rtw_wx_get_scan(struct net_de
 	_func_enter_;
 
 	#ifdef DBG_IOCTL
-	DBG_871X("DBG_IOCTL %s:%d\n",__FUNCTION__, __LINE__);
+	DBG_871X("DBG_IOCTL %s:%d\n",__func__, __LINE__);
 	#endif
 
 /*
 #ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->iface_type > PRIMARY_IFACE)
+	if (padapter->iface_type > PRIMARY_IFACE)
 	{
 		ret = -EINVAL;
 		goto exit;
 	}
 #endif
 */
-	if(padapter->pwrctrlpriv.brfoffbyhw && padapter->bDriverStopped)
+	if (padapter->pwrctrlpriv.brfoffbyhw && padapter->bDriverStopped)
 	{
 		ret = -EINVAL;
 		goto exit;
 	}
 
 #ifdef CONFIG_P2P
-	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		//	P2P is enabled
 		if (padapter->chip_type == RTL8192D)
@@ -1996,7 +1996,7 @@ static int rtw_wx_get_scan(struct net_de
 
 /*
 #ifdef CONFIG_CONCURRENT_MODE
-	if(pmlmepriv->scanning_via_buddy_intf == _TRUE)
+	if (pmlmepriv->scanning_via_buddy_intf == _TRUE)
 	{
 		pmlmepriv->scanning_via_buddy_intf = _FALSE;//reset
 
@@ -2020,7 +2020,7 @@ static int rtw_wx_get_scan(struct net_de
 	{
 		rtw_msleep_os(30);
 		cnt++;
-		if(cnt > wait_for_surveydone)
+		if (cnt > wait_for_surveydone)
 			break;
 	}
 #endif // CONFIG_DUALMAC_CONCURRENT
@@ -2029,7 +2029,7 @@ static int rtw_wx_get_scan(struct net_de
 	{
 		rtw_msleep_os(30);
 		cnt++;
-		if(cnt > wait_for_surveydone)
+		if (cnt > wait_for_surveydone)
 			break;
 	}
 
@@ -2043,7 +2043,7 @@ static int rtw_wx_get_scan(struct net_de
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
 			break;
 
-		if((stop - ev) < SCAN_ITEM_SIZE) {
+		if ((stop - ev) < SCAN_ITEM_SIZE) {
 			ret = -E2BIG;
 			break;
 		}
@@ -2051,7 +2051,7 @@ static int rtw_wx_get_scan(struct net_de
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
 		//report network only if the current channel set contains the channel to which this network belongs
-		if(rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
+		if (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
 			#ifdef CONFIG_VALIDATE_SSID
 			&& _TRUE == rtw_validate_ssid(&(pnetwork->network.Ssid))
 			#endif
@@ -2074,7 +2074,7 @@ exit:
 	_func_exit_;
 
 	#ifdef DBG_IOCTL
-	DBG_871X("DBG_IOCTL %s:%d return %d\n",__FUNCTION__, __LINE__, ret);
+	DBG_871X("DBG_IOCTL %s:%d return %d\n",__func__, __LINE__, ret);
 	#endif
 
 	return ret ;
@@ -2107,12 +2107,12 @@ static int rtw_wx_set_essid(struct net_d
 	_func_enter_;
 
 	#ifdef DBG_IOCTL
-	DBG_871X("DBG_IOCTL %s:%d\n",__FUNCTION__, __LINE__);
+	DBG_871X("DBG_IOCTL %s:%d\n",__func__, __LINE__);
 	#endif
 
 /*
 #ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->iface_type > PRIMARY_IFACE)
+	if (padapter->iface_type > PRIMARY_IFACE)
 	{
 		ret = -EINVAL;
 		goto exit;
@@ -2142,13 +2142,13 @@ static int rtw_wx_set_essid(struct net_d
 
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
 		 ("+rtw_wx_set_essid: fw_state=0x%08x\n", get_fwstate(pmlmepriv)));
-	if(_FAIL == rtw_pwr_wakeup(padapter))
+	if (_FAIL == rtw_pwr_wakeup(padapter))
 	{
 		ret = -1;
 		goto exit;
 	}
 
-	if(!padapter->bup){
+	if (!padapter->bup){
 		ret = -1;
 		goto exit;
 	}
@@ -2162,20 +2162,20 @@ static int rtw_wx_set_essid(struct net_d
 		goto exit;
 	}
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 		ret = -1;
 		goto exit;
 	}
 
 	authmode = padapter->securitypriv.ndisauthtype;
-	DBG_871X("=>%s\n",__FUNCTION__);
+	DBG_871X("=>%s\n",__func__);
 	if (wrqu->essid.flags && wrqu->essid.length)
 	{
 		// Commented by Albert 20100519
 		// We got the codes in "set_info" function of iwconfig source code.
 		//	=========================================
 		//	wrq.u.essid.length = strlen(essid) + 1;
-		//	if(we_kernel_version > 20)
+		//	if (we_kernel_version > 20)
 		//		wrq.u.essid.length--;
 		//	=========================================
 		//	That means, if the WIRELESS_EXT less than or equal to 20, the correct ssid len should subtract 1.
@@ -2185,7 +2185,7 @@ static int rtw_wx_set_essid(struct net_d
 		len = (wrqu->essid.length < IW_ESSID_MAX_SIZE) ? wrqu->essid.length : IW_ESSID_MAX_SIZE;
 #endif
 
-		if(wrqu->essid.length != 33)
+		if (wrqu->essid.length != 33)
 			DBG_871X("ssid=%s, len=%d\n", extra, wrqu->essid.length);
 
 		_rtw_memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));
@@ -2225,9 +2225,9 @@ static int rtw_wx_set_essid(struct net_d
 				RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
 					 ("rtw_wx_set_essid: find match, set infra mode\n"));
 
-				if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
+				if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
 				{
-					if(pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
+					if (pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
 						continue;
 				}
 
@@ -2256,10 +2256,10 @@ static int rtw_wx_set_essid(struct net_d
 
 exit:
 
-	DBG_871X("<=%s, ret %d\n",__FUNCTION__, ret);
+	DBG_871X("<=%s, ret %d\n",__func__, ret);
 
 	#ifdef DBG_IOCTL
-	DBG_871X("DBG_IOCTL %s:%d return %d\n",__FUNCTION__, __LINE__, ret);
+	DBG_871X("DBG_IOCTL %s:%d return %d\n",__func__, __LINE__, ret);
 	#endif
 
 	_func_exit_;
@@ -2322,7 +2322,7 @@ _func_enter_;
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,(" rtw_wx_set_rate \n"));
 	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("target_rate = %d, fixed = %d\n",target_rate,fixed));
 
-	if(target_rate == -1){
+	if (target_rate == -1){
 		ratevalue = 11;
 		goto set_rate;
 	}
@@ -2374,10 +2374,10 @@ set_rate:
 
 	for(i=0; i<NumRates; i++)
 	{
-		if(ratevalue==mpdatarate[i])
+		if (ratevalue==mpdatarate[i])
 		{
 			datarates[i] = mpdatarate[i];
-			if(fixed == 0)
+			if (fixed == 0)
 				break;
 		}
 		else{
@@ -2387,7 +2387,7 @@ set_rate:
 		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("datarate_inx=%d\n",datarates[i]));
 	}
 
-	if(rtw_setdatarate_cmd(padapter, datarates) !=_SUCCESS){
+	if (rtw_setdatarate_cmd(padapter, datarates) !=_SUCCESS){
 		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("rtw_wx_set_rate Fail!!!\n"));
 		ret = -1;
 	}
@@ -2405,7 +2405,7 @@ static int rtw_wx_get_rate(struct net_de
 
 	max_rate = rtw_get_cur_max_rate((_adapter *)rtw_netdev_priv(dev));
 
-	if(max_rate == 0)
+	if (max_rate == 0)
 		return -EPERM;
 
 	wrqu->bitrate.fixed = 0;	/* no auto select */
@@ -2566,7 +2566,7 @@ static int rtw_wx_set_enc(struct net_dev
 	}
 
 	//set authentication mode
-	if(erq->flags & IW_ENCODE_OPEN)
+	if (erq->flags & IW_ENCODE_OPEN)
 	{
 		DBG_871X("rtw_wx_set_enc():IW_ENCODE_OPEN\n");
 		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;//Ndis802_11EncryptionDisabled;
@@ -2578,7 +2578,7 @@ static int rtw_wx_set_enc(struct net_dev
 		authmode = Ndis802_11AuthModeOpen;
 		padapter->securitypriv.ndisauthtype=authmode;
 	}
-	else if(erq->flags & IW_ENCODE_RESTRICTED)
+	else if (erq->flags & IW_ENCODE_RESTRICTED)
 	{
 		DBG_871X("rtw_wx_set_enc():IW_ENCODE_RESTRICTED\n");
 		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
@@ -2613,7 +2613,7 @@ static int rtw_wx_set_enc(struct net_dev
 	{
 		wep.KeyLength = 0 ;
 
-		if(keyindex_provided == 1)// set key_id only, no given KeyMaterial(erq->length==0).
+		if (keyindex_provided == 1)// set key_id only, no given KeyMaterial(erq->length==0).
 		{
 			padapter->securitypriv.dot11PrivacyKeyIndex = key;
 
@@ -2643,7 +2643,7 @@ static int rtw_wx_set_enc(struct net_dev
 	_rtw_memcpy(wep.KeyMaterial, keybuf, wep.KeyLength);
 
 	if (rtw_set_802_11_add_wep(padapter, &wep) == _FALSE) {
-		if(rf_on == pwrpriv->rf_pwrstate)
+		if (rf_on == pwrpriv->rf_pwrstate)
 			ret = -EOPNOTSUPP;
 		goto exit;
 	}
@@ -2667,9 +2667,9 @@ static int rtw_wx_get_enc(struct net_dev
 
 	_func_enter_;
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE)
+	if (check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE)
 	{
-		 if(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != _TRUE)
+		 if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != _TRUE)
 		 {
 		erq->length = 0;
 		erq->flags |= IW_ENCODE_DISABLED;
@@ -2691,7 +2691,7 @@ static int rtw_wx_get_enc(struct net_dev
 
 	erq->flags = key + 1;
 
-	//if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)
+	//if (padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)
 	//{
 	//      erq->flags |= IW_ENCODE_OPEN;
 	//}
@@ -2710,17 +2710,17 @@ static int rtw_wx_get_enc(struct net_dev
 
 		erq->length = padapter->securitypriv.dot11DefKeylen[key];
 
-		if(erq->length)
+		if (erq->length)
 		{
 			_rtw_memcpy(keybuf, padapter->securitypriv.dot11DefKey[key].skey, padapter->securitypriv.dot11DefKeylen[key]);
 
 		erq->flags |= IW_ENCODE_ENABLED;
 
-			if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)
+			if (padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)
 			{
 				erq->flags |= IW_ENCODE_OPEN;
 			}
-			else if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeShared)
+			else if (padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeShared)
 			{
 		erq->flags |= IW_ENCODE_RESTRICTED;
 			}
@@ -2830,13 +2830,13 @@ static int rtw_wx_set_auth(struct net_de
 			 * be set.
 			 */
 
-			if(padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption1Enabled)
+			if (padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption1Enabled)
 			{
 				break;//it means init value, or using wep, ndisencryptstatus = Ndis802_11Encryption1Enabled,
 						// then it needn't reset it;
 			}
 
-			if(param->value){
+			if (param->value){
 				padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
 				padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
 				padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
@@ -2853,10 +2853,10 @@ static int rtw_wx_set_auth(struct net_de
 		/*
 		 *  It's the starting point of a link layer connection using wpa_supplicant
 		*/
-		if(check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {
+		if (check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {
 			LeaveAllPowerSaveMode(padapter);
 			rtw_disassoc_cmd(padapter, 500, _FALSE);
-			DBG_871X("%s...call rtw_indicate_disconnect\n ",__FUNCTION__);
+			DBG_871X("%s...call rtw_indicate_disconnect\n ",__func__);
 			rtw_indicate_disconnect(padapter);
 			rtw_free_assoc_resources(padapter, 1);
 		}
@@ -2869,7 +2869,7 @@ static int rtw_wx_set_auth(struct net_de
 
 	case IW_AUTH_WPA_ENABLED:
 
-		//if(param->value)
+		//if (param->value)
 		//	padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X; //802.1x
 		//else
 		//	padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;//open system
@@ -2939,7 +2939,7 @@ static int rtw_wx_set_enc_ext(struct net
 	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
 
 
-	if(pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)//?
+	if (pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)//?
 	{
 		param->u.crypt.set_tx = 0;
 	}
@@ -2956,7 +2956,7 @@ static int rtw_wx_set_enc_ext(struct net
 		_rtw_memcpy(param->u.crypt.seq, pext->rx_seq, 8);
 	}
 
-	if(pext->key_len)
+	if (pext->key_len)
 	{
 		param->u.crypt.key_len = pext->key_len;
 		//_rtw_memcpy(param + 1, pext + 1, pext->key_len);
@@ -2973,7 +2973,7 @@ static int rtw_wx_set_enc_ext(struct net
 	ret =  wpa_set_encryption(dev, param, param_len);
 
 
-	if(param)
+	if (param)
 	{
 		rtw_mfree((u8*)param, param_len);
 	}
@@ -2992,7 +2992,7 @@ static int rtw_wx_get_nick(struct net_de
 	 //struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	 //struct security_priv *psecuritypriv = &padapter->securitypriv;
 
-	if(extra)
+	if (extra)
 	{
 		wrqu->data.length = 14;
 		wrqu->data.flags = 1;
@@ -3159,7 +3159,7 @@ static int rtw_wx_set_channel_plan(struc
 	extern int rtw_channel_plan;
 	u8 channel_plan_req = (u8) (*((int *)wrqu));
 
-	if(_SUCCESS == rtw_set_chplan_cmd(padapter, channel_plan_req, 1)) {
+	if (_SUCCESS == rtw_set_chplan_cmd(padapter, channel_plan_req, 1)) {
 		DBG_871X("%s set channel_plan = 0x%02X\n", __func__, pmlmepriv->ChannelPlan);
 	} else
 		return -EPERM;
@@ -3206,7 +3206,7 @@ static  int rtw_drvext_hdl(struct net_de
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct iw_point *p = &wrqu->data;
 
-	if((!p->length) || (!p->pointer)){
+	if ((!p->length) || (!p->pointer)){
 		ret = -EINVAL;
 		goto _rtw_drvext_hdl_exit;
 	}
@@ -3220,7 +3220,7 @@ static  int rtw_drvext_hdl(struct net_de
 		goto _rtw_drvext_hdl_exit;
 	}
 
-	if(bset)//set info
+	if (bset)//set info
 	{
 		if (copy_from_user(pparmbuf, p->pointer,len)) {
 			rtw_mfree(pparmbuf, len);
@@ -3271,7 +3271,7 @@ static  int rtw_drvext_hdl(struct net_de
 
 	res = phandler->handler(&padapter->drvextpriv, bset, poidparam->data);
 
-	if(res==0)
+	if (res==0)
 	{
 		ret = 0;
 
@@ -3303,7 +3303,7 @@ static void rtw_dbg_mode_hdl(_adapter *p
 	u8 offset;
 	u32 value;
 
-	DBG_871X("%s\n", __FUNCTION__);
+	DBG_871X("%s\n", __func__);
 
 	switch(id)
 	{
@@ -3371,7 +3371,7 @@ static void rtw_dbg_mode_hdl(_adapter *p
 			break;
                 case GEN_MP_IOCTL_SUBCODE(TRIGGER_GPIO):
 			DBG_871X("==> trigger gpio 0\n");
-			rtw_hal_set_hwreg(padapter, HW_VAR_TRIGGER_GPIO_0, 0);
+			rtw_hal_set_hwreg(padapter, HW_VAR_TRIGGER_GPIO_0, NULL);
 			break;
 #ifdef CONFIG_BT_COEXIST
 		case GEN_MP_IOCTL_SUBCODE(SET_DM_BT):
@@ -3533,7 +3533,7 @@ static int rtw_get_ap_info(struct net_de
 
 	DBG_871X("+rtw_get_aplist_info\n");
 
-	if((padapter->bDriverStopped) || (pdata==NULL))
+	if ((padapter->bDriverStopped) || (pdata==NULL))
 	{
 		ret= -EINVAL;
 		goto exit;
@@ -3543,16 +3543,16 @@ static int rtw_get_ap_info(struct net_de
 	{
 		rtw_msleep_os(30);
 		cnt++;
-		if(cnt > 100)
+		if (cnt > 100)
 			break;
 	}
 
 
 	//pdata->length = 0;//?
 	pdata->flags = 0;
-	if(pdata->length>=32)
+	if (pdata->length>=32)
 	{
-		if(copy_from_user(data, pdata->pointer, 32))
+		if (copy_from_user(data, pdata->pointer, 32))
 		{
 			ret= -EINVAL;
 			goto exit;
@@ -3577,8 +3577,8 @@ static int rtw_get_ap_info(struct net_de
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		//if(hwaddr_aton_i(pdata->pointer, bssid))
-		if(hwaddr_aton_i(data, bssid))
+		//if (hwaddr_aton_i(pdata->pointer, bssid))
+		if (hwaddr_aton_i(data, bssid))
 		{
 			DBG_871X("Invalid BSSID '%s'.\n", (u8*)data);
 			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
@@ -3586,19 +3586,19 @@ static int rtw_get_ap_info(struct net_de
 		}
 
 
-		if(_rtw_memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN) == _TRUE)//BSSID match, then check if supporting wpa/wpa2
+		if (_rtw_memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN) == _TRUE)//BSSID match, then check if supporting wpa/wpa2
 		{
 			DBG_871X("BSSID:" MAC_FMT "\n", MAC_ARG(bssid));
 
 			pbuf = rtw_get_wpa_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
-			if(pbuf && (wpa_ielen>0))
+			if (pbuf && (wpa_ielen>0))
 			{
 				pdata->flags = 1;
 				break;
 			}
 
 			pbuf = rtw_get_wpa2_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
-			if(pbuf && (wpa_ielen>0))
+			if (pbuf && (wpa_ielen>0))
 			{
 				pdata->flags = 2;
 				break;
@@ -3612,10 +3612,8 @@ static int rtw_get_ap_info(struct net_de
 
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 
-	if(pdata->length>=34)
-	{
-		if(copy_to_user((u8*)pdata->pointer+32, (u8*)&pdata->flags, 1))
-		{
+	if (pdata->length>=34) {
+		if (copy_to_user((u8 __user *)pdata->pointer+32, (u8*)&pdata->flags, 1)) {
 			ret= -EINVAL;
 			goto exit;
 		}
@@ -3637,18 +3635,18 @@ static int rtw_set_pid(struct net_device
 	int *pdata = (int *)wrqu;
 	int selector;
 
-	if((padapter->bDriverStopped) || (pdata==NULL))
+	if ((padapter->bDriverStopped) || (pdata==NULL))
 	{
 		ret= -EINVAL;
 		goto exit;
 	}
 
 	selector = *pdata;
-	if(selector < 3 && selector >=0) {
+	if (selector < 3 && selector >=0) {
 		padapter->pid[selector] = *(pdata+1);
-		DBG_871X("%s set pid[%d]=%d\n", __FUNCTION__, selector ,padapter->pid[selector]);
+		DBG_871X("%s set pid[%d]=%d\n", __func__, selector ,padapter->pid[selector]);
 	} else {
-		DBG_871X("%s selector %d error\n", __FUNCTION__, selector);
+		DBG_871X("%s selector %d error\n", __func__, selector);
 	}
 exit:
 	return ret;
@@ -3666,7 +3664,7 @@ static int rtw_wps_start(struct net_devi
 
         uintRet = copy_from_user((void*) &u32wps_start, pdata->pointer, 4);
 
-	if((padapter->bDriverStopped) || (pdata==NULL)) {
+	if ((padapter->bDriverStopped) || (pdata==NULL)) {
 		ret= -EINVAL;
 		goto exit;
 	}
@@ -3674,7 +3672,7 @@ static int rtw_wps_start(struct net_devi
 	if (u32wps_start == 0)
 		u32wps_start = *extra;
 
-	DBG_871X("[%s] wps_start = %d\n", __FUNCTION__, u32wps_start);
+	DBG_871X("[%s] wps_start = %d\n", __func__, u32wps_start);
 
 	if (u32wps_start == 1) // WPS Start
 	{
@@ -3714,28 +3712,28 @@ static int rtw_wext_p2p_enable(struct ne
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	enum P2P_ROLE init_role = P2P_ROLE_DISABLE;
 
-	if(*extra == '0')
+	if (*extra == '0')
 		init_role = P2P_ROLE_DISABLE;
-	else if(*extra == '1')
+	else if (*extra == '1')
 		init_role = P2P_ROLE_DEVICE;
-	else if(*extra == '2')
+	else if (*extra == '2')
 		init_role = P2P_ROLE_CLIENT;
-	else if(*extra == '3')
+	else if (*extra == '3')
 		init_role = P2P_ROLE_GO;
 
-	if(_FAIL == rtw_p2p_enable(padapter, init_role))
+	if (_FAIL == rtw_p2p_enable(padapter, init_role))
 	{
 		ret = -EFAULT;
 		goto exit;
 	}
 
 	//set channel/bandwidth
-	if(init_role != P2P_ROLE_DISABLE)
+	if (init_role != P2P_ROLE_DISABLE)
 	{
 		u8 channel, ch_offset;
 		u16 bwmode;
 
-		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN))
+		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN))
 		{
 			//	Stay at the listen state and wait for discovery.
 			channel = pwdinfo->listen_channel;
@@ -3744,7 +3742,7 @@ static int rtw_wext_p2p_enable(struct ne
 			bwmode = HT_CHANNEL_WIDTH_20;
 		}
 #ifdef CONFIG_CONCURRENT_MODE
-		else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
+		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 		{
 			_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 			//struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
@@ -3795,7 +3793,7 @@ static int rtw_p2p_set_go_nego_ssid(stru
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 
-	DBG_871X("[%s] ssid = %s, len = %d\n", __FUNCTION__, extra, (u32)strlen(extra));
+	DBG_871X("[%s] ssid = %s, len = %d\n", __func__, extra, (u32)strlen(extra));
 	_rtw_memcpy(pwdinfo->nego_ssid, extra, strlen(extra));
 	pwdinfo->nego_ssidlen = strlen(extra);
 
@@ -3836,7 +3834,7 @@ static int rtw_p2p_set_intent(struct net
 		ret = -1;
 	}
 
-	DBG_871X("[%s] intent = %d\n", __FUNCTION__, intent);
+	DBG_871X("[%s] intent = %d\n", __func__, intent);
 
 	return ret;
 
@@ -3876,7 +3874,7 @@ static int rtw_p2p_set_listen_ch(struct
 		ret = -1;
 	}
 
-	DBG_871X("[%s] listen_ch = %d\n", __FUNCTION__, pwdinfo->listen_channel);
+	DBG_871X("[%s] listen_ch = %d\n", __func__, pwdinfo->listen_channel);
 
 	return ret;
 
@@ -3917,7 +3915,7 @@ static int rtw_p2p_set_op_ch(struct net_
 		ret = -1;
 	}
 
-	DBG_871X("[%s] op_ch = %d\n", __FUNCTION__, pwdinfo->operating_channel);
+	DBG_871X("[%s] op_ch = %d\n", __func__, pwdinfo->operating_channel);
 
 	return ret;
 
@@ -3943,11 +3941,11 @@ static int rtw_p2p_profilefound(struct n
 	//	YY => SSID Length
 	//	SSID => SSID for persistence group
 
-	DBG_871X("[%s] In value = %s, len = %d \n", __FUNCTION__, extra, wrqu->data.length -1);
+	DBG_871X("[%s] In value = %s, len = %d \n", __func__, extra, wrqu->data.length -1);
 
 
 	//	The upper application should pass the SSID to driver by using this rtw_p2p_profilefound function.
-	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		if (extra[ 0 ] == '0')
 		{
@@ -3993,7 +3991,7 @@ static int rtw_p2p_setDN(struct net_devi
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 
 
-	DBG_871X("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1 );
+	DBG_871X("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
 
 	_rtw_memset(pwdinfo->device_name, 0x00, WPS_MAX_DEVICE_NAME_LEN);
 	_rtw_memcpy(pwdinfo->device_name, extra, wrqu->data.length - 1);
@@ -4016,7 +4014,7 @@ static int rtw_p2p_get_status(struct net
 
 	if (padapter->bShowGetP2PState)
 	{
-		DBG_871X("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
+		DBG_871X("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
 				pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
 				pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
 	}
@@ -4064,7 +4062,7 @@ static int rtw_p2p_get_role(struct net_d
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 
-	DBG_871X("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
+	DBG_871X("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
 			pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
 			pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
 
@@ -4086,7 +4084,7 @@ static int rtw_p2p_get_peer_ifaddr(struc
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 
-	DBG_871X("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
+	DBG_871X("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
 			pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
 			pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
 
@@ -4109,7 +4107,7 @@ static int rtw_p2p_get_peer_devaddr(stru
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-	DBG_871X("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
+	DBG_871X("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
 			pwdinfo->rx_prov_disc_info.peerDevAddr[ 0 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 1 ],
 			pwdinfo->rx_prov_disc_info.peerDevAddr[ 2 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 3 ],
 			pwdinfo->rx_prov_disc_info.peerDevAddr[ 4 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 5 ]);
@@ -4133,7 +4131,7 @@ static int rtw_p2p_get_peer_devaddr_by_i
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-	DBG_871X("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
+	DBG_871X("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
 			pwdinfo->p2p_peer_device_addr[ 0 ], pwdinfo->p2p_peer_device_addr[ 1 ],
 			pwdinfo->p2p_peer_device_addr[ 2 ], pwdinfo->p2p_peer_device_addr[ 3 ],
 			pwdinfo->p2p_peer_device_addr[ 4 ], pwdinfo->p2p_peer_device_addr[ 5 ]);
@@ -4179,7 +4177,7 @@ static int rtw_p2p_get_op_ch(struct net_
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 
-	DBG_871X("[%s] Op_ch = %02x\n", __FUNCTION__, pwdinfo->operating_channel);
+	DBG_871X("[%s] Op_ch = %02x\n", __func__, pwdinfo->operating_channel);
 
 	sprintf(extra, "\n\nOp_ch=%.2d\n", pwdinfo->operating_channel);
 	wrqu->data.length = strlen(extra);
@@ -4219,7 +4217,7 @@ static int rtw_p2p_get_wps_configmethod(
 	//	After knowing its WPS config method, the application can decide the config method for provisioning discovery.
 	//	Format: iwpriv wlanx p2p_get_wpsCM 00:E0:4C:00:00:05
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, subcmd);
+	DBG_871X("[%s] data = %s\n", __func__, subcmd);
 
 	macstr2num(peerMAC, subcmd);
 
@@ -4283,10 +4281,10 @@ static int rtw_p2p_get_peer_wfd_port(str
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
-	DBG_871X("[%s] p2p_state = %d\n", __FUNCTION__, rtw_p2p_state(pwdinfo));
+	DBG_871X("[%s] p2p_state = %d\n", __func__, rtw_p2p_state(pwdinfo));
 
 	sprintf(extra, "\n\nPort=%d\n", pwdinfo->wfd_info->peer_rtsp_ctrlport);
-	DBG_871X("[%s] remote port = %d\n", __FUNCTION__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
+	DBG_871X("[%s] remote port = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
 
 	wrqu->data.length = strlen(extra);
 	return ret;
@@ -4304,7 +4302,7 @@ static int rtw_p2p_get_peer_wfd_preferre
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	sprintf(extra, "\n\nwfd_pc=%d\n", pwdinfo->wfd_info->wfd_pc);
-	DBG_871X("[%s] wfd_pc = %d\n", __FUNCTION__, pwdinfo->wfd_info->wfd_pc);
+	DBG_871X("[%s] wfd_pc = %d\n", __func__, pwdinfo->wfd_info->wfd_pc);
 
 	wrqu->data.length = strlen(extra);
 	pwdinfo->wfd_info->wfd_pc = _FALSE;	//	Reset the WFD preferred connection to P2P
@@ -4323,7 +4321,7 @@ static int rtw_p2p_get_peer_wfd_session_
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 	sprintf(extra, "\n\nwfd_sa=%d\n", pwdinfo->wfd_info->peer_session_avail);
-	DBG_871X("[%s] wfd_sa = %d\n", __FUNCTION__, pwdinfo->wfd_info->peer_session_avail);
+	DBG_871X("[%s] wfd_sa = %d\n", __func__, pwdinfo->wfd_info->peer_session_avail);
 
 	wrqu->data.length = strlen(extra);
 	pwdinfo->wfd_info->peer_session_avail = _TRUE;	//	Reset the WFD session available
@@ -4356,7 +4354,7 @@ static int rtw_p2p_get_go_device_address
 	//	The input data is the GO's interface address which the application wants to know its device address.
 	//	Format: iwpriv wlanx p2p_get2 go_devadd=00:E0:4C:00:00:05
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, subcmd);
+	DBG_871X("[%s] data = %s\n", __func__, subcmd);
 
 	macstr2num(peerMAC, subcmd);
 
@@ -4448,7 +4446,7 @@ static int rtw_p2p_get_device_type(struc
 	//	Such user interface could know the device type.
 	//	Format: iwpriv wlanx p2p_get2 dev_type=00:E0:4C:00:00:05
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, subcmd);
+	DBG_871X("[%s] data = %s\n", __func__, subcmd);
 
 	macstr2num(peerMAC, subcmd);
 
@@ -4526,7 +4524,7 @@ static int rtw_p2p_get_device_name(struc
 	//	Such user interface could show peer device's device name instead of ssid.
 	//	Format: iwpriv wlanx p2p_get2 devN=00:E0:4C:00:00:05
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, subcmd);
+	DBG_871X("[%s] data = %s\n", __func__, subcmd);
 
 	macstr2num(peerMAC, subcmd);
 
@@ -4600,7 +4598,7 @@ static int rtw_p2p_get_invitation_proced
 	//	The application wants to know P2P initation procedure is support or not.
 	//	Format: iwpriv wlanx p2p_get2 InvProc=00:E0:4C:00:00:05
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, subcmd);
+	DBG_871X("[%s] data = %s\n", __func__, subcmd);
 
 	macstr2num(peerMAC, subcmd);
 
@@ -4696,11 +4694,11 @@ static int rtw_p2p_connect(struct net_de
 	//	Format: 00:E0:4C:00:00:05
 	//	Format: 00:E0:4C:00:00:05
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, extra);
+	DBG_871X("[%s] data = %s\n", __func__, extra);
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
-		DBG_871X("[%s] WiFi Direct is disable!\n", __FUNCTION__);
+		DBG_871X("[%s] WiFi Direct is disable!\n", __func__);
 		return ret;
 	}
 
@@ -4773,7 +4771,7 @@ static int rtw_p2p_connect(struct net_de
 		}
 #endif // CONFIG_CONCURRENT_MODE
 
-		DBG_871X("[%s] Start PreTx Procedure!\n", __FUNCTION__);
+		DBG_871X("[%s] Start PreTx Procedure!\n", __func__);
 		_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -4792,7 +4790,7 @@ static int rtw_p2p_connect(struct net_de
 	}
 	else
 	{
-		DBG_871X("[%s] Not Found in Scanning Queue~\n", __FUNCTION__);
+		DBG_871X("[%s] Not Found in Scanning Queue~\n", __func__);
 		ret = -1;
 	}
 exit:
@@ -4837,17 +4835,17 @@ static int rtw_p2p_invite_req(struct net
 	//	Command line sample: iwpriv wlan0 p2p_set invite="00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy"
 	//	Format: 00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, extra);
+	DBG_871X("[%s] data = %s\n", __func__, extra);
 
 	if (wrqu->data.length <=  37)
 	{
-		DBG_871X("[%s] Wrong format!\n", __FUNCTION__);
+		DBG_871X("[%s] Wrong format!\n", __func__);
 		return ret;
 	}
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
-		DBG_871X("[%s] WiFi Direct is disable!\n", __FUNCTION__);
+		DBG_871X("[%s] WiFi Direct is disable!\n", __func__);
 		return ret;
 	}
 	else
@@ -4926,7 +4924,7 @@ static int rtw_p2p_invite_req(struct net
 			u8	wfd_devinfo[ 6 ] = { 0x00 };
 			uint	wfd_devlen = 6;
 
-			DBG_871X("[%s] Found WFD IE!\n", __FUNCTION__);
+			DBG_871X("[%s] Found WFD IE!\n", __func__);
 			if (rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, wfd_devinfo, &wfd_devlen))
 			{
 				u16	wfd_devinfo_field = 0;
@@ -4948,7 +4946,7 @@ static int rtw_p2p_invite_req(struct net
 
 		if (_FALSE == pwfd_info->peer_session_avail)
 		{
-			DBG_871X("[%s] WFD Session not avaiable!\n", __FUNCTION__);
+			DBG_871X("[%s] WFD Session not avaiable!\n", __func__);
 			goto exit;
 		}
 	}
@@ -5013,7 +5011,7 @@ static int rtw_p2p_invite_req(struct net
 	}
 	else
 	{
-		DBG_871X("[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__);
+		DBG_871X("[%s] NOT Found in the Scanning Queue!\n", __func__);
 	}
 exit:
 
@@ -5057,11 +5055,11 @@ static int rtw_p2p_set_persistent(struct
 	//	0: disable persistent group functionality
 	//	1: enable persistent group founctionality
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, extra);
+	DBG_871X("[%s] data = %s\n", __func__, extra);
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
-		DBG_871X("[%s] WiFi Direct is disable!\n", __FUNCTION__);
+		DBG_871X("[%s] WiFi Direct is disable!\n", __func__);
 		return ret;
 	}
 	else
@@ -5079,7 +5077,7 @@ static int rtw_p2p_set_persistent(struct
 			pwdinfo->persistent_supported = _FALSE;
 		}
 	}
-	printk("[%s] persistent_supported = %d\n", __FUNCTION__, pwdinfo->persistent_supported);
+	printk("[%s] persistent_supported = %d\n", __func__, pwdinfo->persistent_supported);
 
 exit:
 
@@ -5119,11 +5117,11 @@ static int rtw_p2p_set_pc(struct net_dev
 	//	1. Input information is the MAC address which wants to know the Preferred Connection bit (PC bit)
 	//	Format: 00:E0:4C:00:00:05
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, extra);
+	DBG_871X("[%s] data = %s\n", __func__, extra);
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
-		DBG_871X("[%s] WiFi Direct is disable!\n", __FUNCTION__);
+		DBG_871X("[%s] WiFi Direct is disable!\n", __func__);
 		return ret;
 	}
 
@@ -5152,11 +5150,11 @@ static int rtw_p2p_set_pc(struct net_dev
 		{
 			//	The P2P Device ID attribute is included in the Beacon frame.
 			//	The P2P Device Info attribute is included in the probe response frame.
-			printk("[%s] Got P2P IE\n", __FUNCTION__);
+			printk("[%s] Got P2P IE\n", __func__);
 			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
 			{
 				//	Handle the P2P Device ID attribute of Beacon first
-				printk("[%s] P2P_ATTR_DEVICE_ID \n", __FUNCTION__);
+				printk("[%s] P2P_ATTR_DEVICE_ID \n", __func__);
 				if (_rtw_memcmp(attr_content, peerMAC, ETH_ALEN))
 				{
 					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
@@ -5166,7 +5164,7 @@ static int rtw_p2p_set_pc(struct net_dev
 			else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
 			{
 				//	Handle the P2P Device Info attribute of probe response
-				printk("[%s] P2P_ATTR_DEVICE_INFO \n", __FUNCTION__);
+				printk("[%s] P2P_ATTR_DEVICE_INFO \n", __func__);
 				if (_rtw_memcmp(attr_content, peerMAC, ETH_ALEN))
 				{
 					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
@@ -5181,7 +5179,7 @@ static int rtw_p2p_set_pc(struct net_dev
 	}
 
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-	printk("[%s] channel = %d\n", __FUNCTION__, uintPeerChannel);
+	printk("[%s] channel = %d\n", __func__, uintPeerChannel);
 
 	if (uintPeerChannel)
 	{
@@ -5193,7 +5191,7 @@ static int rtw_p2p_set_pc(struct net_dev
 			u8	wfd_devinfo[ 6 ] = { 0x00 };
 			uint	wfd_devlen = 6;
 
-			DBG_871X("[%s] Found WFD IE!\n", __FUNCTION__);
+			DBG_871X("[%s] Found WFD IE!\n", __func__);
 			if (rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, wfd_devinfo, &wfd_devlen))
 			{
 				u16	wfd_devinfo_field = 0;
@@ -5215,7 +5213,7 @@ static int rtw_p2p_set_pc(struct net_dev
 	}
 	else
 	{
-		DBG_871X("[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__);
+		DBG_871X("[%s] NOT Found in the Scanning Queue!\n", __func__);
 	}
 
 exit:
@@ -5240,7 +5238,7 @@ static int rtw_p2p_set_wfd_device_type(s
 	//	0: specify to Miracast source device
 	//	1 or others: specify to Miracast sink device (display device)
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, extra);
+	DBG_871X("[%s] data = %s\n", __func__, extra);
 
 	if (extra[ 0 ] == '0')	//	Set to Miracast source device.
 	{
@@ -5276,7 +5274,7 @@ static int rtw_p2p_set_scan_result_type(
 	//	It will show up all the Miracast source device if this device is sink.
 	//	It will show up all the Miracast sink device if this device is source.
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, extra);
+	DBG_871X("[%s] data = %s\n", __func__, extra);
 
 	if (extra[ 0 ] == '0')
 	{
@@ -5313,11 +5311,11 @@ static int rtw_p2p_set_sa(struct net_dev
 	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
 	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, extra);
+	DBG_871X("[%s] data = %s\n", __func__, extra);
 
-	if(0)
+	if (0)
 	{
-		DBG_871X("[%s] WiFi Direct is disable!\n", __FUNCTION__);
+		DBG_871X("[%s] WiFi Direct is disable!\n", __func__);
 		return ret;
 	}
 	else
@@ -5335,7 +5333,7 @@ static int rtw_p2p_set_sa(struct net_dev
 			pwdinfo->session_available = _FALSE;
 		}
 	}
-	printk("[%s] session available = %d\n", __FUNCTION__, pwdinfo->session_available);
+	printk("[%s] session available = %d\n", __func__, pwdinfo->session_available);
 
 exit:
 
@@ -5381,11 +5379,11 @@ static int rtw_p2p_prov_disc(struct net_
 	//	Format: 00:E0:4C:00:00:05_pbc
 	//	Format: 00:E0:4C:00:00:05_label
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, extra);
+	DBG_871X("[%s] data = %s\n", __func__, extra);
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
-		DBG_871X("[%s] WiFi Direct is disable!\n", __FUNCTION__);
+		DBG_871X("[%s] WiFi Direct is disable!\n", __func__);
 		return ret;
 	}
 	else
@@ -5422,7 +5420,7 @@ static int rtw_p2p_prov_disc(struct net_
 	}
 	else
 	{
-		DBG_871X("[%s] Unknown WPS config methodn", __FUNCTION__);
+		DBG_871X("[%s] Unknown WPS config methodn", __func__);
 		return(ret);
 	}
 
@@ -5436,7 +5434,7 @@ static int rtw_p2p_prov_disc(struct net_
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
 			break;
 
-		if(uintPeerChannel != 0)
+		if (uintPeerChannel != 0)
 			break;
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
@@ -5492,7 +5490,7 @@ static int rtw_p2p_prov_disc(struct net_
 			u8	wfd_devinfo[ 6 ] = { 0x00 };
 			uint	wfd_devlen = 6;
 
-			DBG_871X("[%s] Found WFD IE!\n", __FUNCTION__);
+			DBG_871X("[%s] Found WFD IE!\n", __func__);
 			if (rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, wfd_devinfo, &wfd_devlen))
 			{
 				u16	wfd_devinfo_field = 0;
@@ -5514,7 +5512,7 @@ static int rtw_p2p_prov_disc(struct net_
 
 		if (_FALSE == pwfd_info->peer_session_avail)
 		{
-			DBG_871X("[%s] WFD Session not avaiable!\n", __FUNCTION__);
+			DBG_871X("[%s] WFD Session not avaiable!\n", __func__);
 			goto exit;
 		}
 	}
@@ -5523,7 +5521,7 @@ static int rtw_p2p_prov_disc(struct net_
 	if (uintPeerChannel)
 	{
 
-		DBG_871X("[%s] peer channel: %d!\n", __FUNCTION__, uintPeerChannel);
+		DBG_871X("[%s] peer channel: %d!\n", __func__, uintPeerChannel);
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_buddy_fwstate(padapter, _FW_LINKED))
 		{
@@ -5537,11 +5535,11 @@ static int rtw_p2p_prov_disc(struct net_
 		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ);
 
-		if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
+		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
 		{
 			_rtw_memcpy(&pwdinfo->tx_prov_disc_info.ssid, &pnetwork->network.Ssid, sizeof(NDIS_802_11_SSID));
 		}
-		else if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
+		else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 		{
 			_rtw_memcpy(pwdinfo->tx_prov_disc_info.ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN);
 			pwdinfo->tx_prov_disc_info.ssid.SsidLength= P2P_WILDCARD_SSID_LEN;
@@ -5582,7 +5580,7 @@ static int rtw_p2p_prov_disc(struct net_
 	}
 	else
 	{
-		DBG_871X("[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__);
+		DBG_871X("[%s] NOT Found in the Scanning Queue!\n", __func__);
 	}
 exit:
 
@@ -5604,7 +5602,7 @@ static int rtw_p2p_got_wpsinfo(struct ne
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 
-	DBG_871X("[%s] data = %s\n", __FUNCTION__, extra);
+	DBG_871X("[%s] data = %s\n", __func__, extra);
 	//	Added by Albert 20110328
 	//	if the input data is P2P_NO_WPSINFO -> reset the wpsinfo
 	//	if the input data is P2P_GOT_WPSINFO_PEER_DISPLAY_PIN -> the utility just input the PIN code got from the peer P2P device.
@@ -5652,7 +5650,7 @@ static int rtw_p2p_set(struct net_device
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 
-	DBG_871X("[%s] extra = %s\n", __FUNCTION__, extra);
+	DBG_871X("[%s] extra = %s\n", __func__, extra);
 
 	if (_rtw_memcmp(extra, "enable=", 7))
 	{
@@ -5770,55 +5768,33 @@ static int rtw_p2p_get(struct net_device
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 
 	if (padapter->bShowGetP2PState)
-	{
-		DBG_871X("[%s] extra = %s\n", __FUNCTION__, (char*) wrqu->data.pointer);
-	}
+		DBG_871X("[%s] extra = %s\n", __func__, (char *)wrqu->data.pointer);
 
-	if (_rtw_memcmp(wrqu->data.pointer, "status", 6))
-	{
+	if (_rtw_memcmp(wrqu->data.pointer, "status", 6)) {
 		rtw_p2p_get_status(dev, info, wrqu, extra);
-	}
-	else if (_rtw_memcmp(wrqu->data.pointer, "role", 4))
-	{
+	} else if (_rtw_memcmp(wrqu->data.pointer, "role", 4)) {
 		rtw_p2p_get_role(dev, info, wrqu, extra);
-	}
-	else if (_rtw_memcmp(wrqu->data.pointer, "peer_ifa", 8))
-	{
+	} else if (_rtw_memcmp(wrqu->data.pointer, "peer_ifa", 8)) {
 		rtw_p2p_get_peer_ifaddr(dev, info, wrqu, extra);
-	}
-	else if (_rtw_memcmp(wrqu->data.pointer, "req_cm", 6))
-	{
+	} else if (_rtw_memcmp(wrqu->data.pointer, "req_cm", 6)) {
 		rtw_p2p_get_req_cm(dev, info, wrqu, extra);
-	}
-	else if (_rtw_memcmp(wrqu->data.pointer, "peer_deva", 9))
-	{
+	} else if (_rtw_memcmp(wrqu->data.pointer, "peer_deva", 9)) {
 		//	Get the P2P device address when receiving the provision discovery request frame.
 		rtw_p2p_get_peer_devaddr(dev, info, wrqu, extra);
-	}
-	else if (_rtw_memcmp(wrqu->data.pointer, "group_id", 8))
-	{
+	} else if (_rtw_memcmp(wrqu->data.pointer, "group_id", 8)) {
 		rtw_p2p_get_groupid(dev, info, wrqu, extra);
-	}
-	else if (_rtw_memcmp(wrqu->data.pointer, "peer_deva_inv", 9))
-	{
+	} else if (_rtw_memcmp(wrqu->data.pointer, "peer_deva_inv", 9)) {
 		//	Get the P2P device address when receiving the P2P Invitation request frame.
 		rtw_p2p_get_peer_devaddr_by_invitation(dev, info, wrqu, extra);
-	}
-	else if (_rtw_memcmp(wrqu->data.pointer, "op_ch", 5))
-	{
+	} else if (_rtw_memcmp(wrqu->data.pointer, "op_ch", 5)) {
 		rtw_p2p_get_op_ch(dev, info, wrqu, extra);
 	}
 #ifdef CONFIG_WFD
-	else if (_rtw_memcmp(wrqu->data.pointer, "peer_port", 9))
-	{
+	else if (_rtw_memcmp(wrqu->data.pointer, "peer_port", 9)) {
 		rtw_p2p_get_peer_wfd_port(dev, info, wrqu, extra);
-	}
-	else if (_rtw_memcmp(wrqu->data.pointer, "wfd_sa", 6))
-	{
+	} else if (_rtw_memcmp(wrqu->data.pointer, "wfd_sa", 6)) {
 		rtw_p2p_get_peer_wfd_session_available(dev, info, wrqu, extra);
-	}
-	else if (_rtw_memcmp(wrqu->data.pointer, "wfd_pc", 6))
-	{
+	} else if (_rtw_memcmp(wrqu->data.pointer, "wfd_pc", 6)) {
 		rtw_p2p_get_peer_wfd_preferred_connection(dev, info, wrqu, extra);
 	}
 #endif // CONFIG_WFD
@@ -5853,7 +5829,7 @@ static int rtw_p2p_get2(struct net_devic
 		goto bad;
 	}
 
-	DBG_871X("[%s] buffer = %s\n", __FUNCTION__, buffer);
+	DBG_871X("[%s] buffer = %s\n", __func__, buffer);
 
 	if (_rtw_memcmp(buffer, "wpsCM=", 6))
 	{
@@ -5898,7 +5874,7 @@ static int rtw_rereg_nd_name(struct net_
 	struct rereg_nd_name_data *rereg_priv = &padapter->rereg_nd_name_priv;
 	char new_ifname[IFNAMSIZ];
 
-	if(rereg_priv->old_ifname[0] == 0) {
+	if (rereg_priv->old_ifname[0] == 0) {
 		char *reg_ifname;
 #ifdef CONFIG_CONCURRENT_MODE
 		if (padapter->isprimary)
@@ -5911,24 +5887,24 @@ static int rtw_rereg_nd_name(struct net_
 		rereg_priv->old_ifname[IFNAMSIZ-1] = 0;
 	}
 
-	//DBG_871X("%s wrqu->data.length:%d\n", __FUNCTION__, wrqu->data.length);
-	if(wrqu->data.length > IFNAMSIZ)
+	//DBG_871X("%s wrqu->data.length:%d\n", __func__, wrqu->data.length);
+	if (wrqu->data.length > IFNAMSIZ)
 		return -EFAULT;
 
 	if (copy_from_user(new_ifname, wrqu->data.pointer, IFNAMSIZ)) {
 		return -EFAULT;
 	}
 
-	if(0 == strcmp(rereg_priv->old_ifname, new_ifname)) {
+	if (0 == strcmp(rereg_priv->old_ifname, new_ifname)) {
 		return ret;
 	}
 
-	DBG_871X("%s new_ifname:%s\n", __FUNCTION__, new_ifname);
-	if(0 != (ret = rtw_change_ifname(padapter, new_ifname))) {
+	DBG_871X("%s new_ifname:%s\n", __func__, new_ifname);
+	if (0 != (ret = rtw_change_ifname(padapter, new_ifname))) {
 		goto exit;
 	}
 
-	if(_rtw_memcmp(rereg_priv->old_ifname, "disable%d", 9) == _TRUE) {
+	if (_rtw_memcmp(rereg_priv->old_ifname, "disable%d", 9) == _TRUE) {
 		padapter->ledpriv.bRegUseLed= rereg_priv->old_bRegUseLed;
 		rtw_hal_sw_led_init(padapter);
 		rtw_ips_mode_req(&padapter->pwrctrlpriv, rereg_priv->old_ips_mode);
@@ -5937,9 +5913,9 @@ static int rtw_rereg_nd_name(struct net_
 	strncpy(rereg_priv->old_ifname, new_ifname, IFNAMSIZ);
 	rereg_priv->old_ifname[IFNAMSIZ-1] = 0;
 
-	if(_rtw_memcmp(new_ifname, "disable%d", 9) == _TRUE) {
+	if (_rtw_memcmp(new_ifname, "disable%d", 9) == _TRUE) {
 
-		DBG_871X("%s disable\n", __FUNCTION__);
+		DBG_871X("%s disable\n", __func__);
 		// free network queue for Android's timming issue
 		rtw_free_network_queue(padapter, _TRUE);
 
@@ -5964,15 +5940,15 @@ void mac_reg_dump(_adapter *padapter)
 	DBG_871X("\n======= MAC REG =======\n");
 	for(i=0x0;i<0x300;i+=4)
 	{
-		if(j%4==1)	DBG_871X("0x%02x",i);
+		if (j%4==1)	DBG_871X("0x%02x",i);
 		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	DBG_871X("\n");
+		if ((j++)%4 == 0)	DBG_871X("\n");
 	}
 	for(i=0x400;i<0x800;i+=4)
 	{
-		if(j%4==1)	DBG_871X("0x%02x",i);
+		if (j%4==1)	DBG_871X("0x%02x",i);
 		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	DBG_871X("\n");
+		if ((j++)%4 == 0)	DBG_871X("\n");
 	}
 }
 void bb_reg_dump(_adapter *padapter)
@@ -5981,10 +5957,10 @@ void bb_reg_dump(_adapter *padapter)
 	DBG_871X("\n======= BB REG =======\n");
 	for(i=0x800;i<0x1000;i+=4)
 	{
-		if(j%4==1) DBG_871X("0x%02x",i);
+		if (j%4==1) DBG_871X("0x%02x",i);
 
 		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	DBG_871X("\n");
+		if ((j++)%4 == 0)	DBG_871X("\n");
 	}
 }
 void rf_reg_dump(_adapter *padapter)
@@ -5995,7 +5971,7 @@ void rf_reg_dump(_adapter *padapter)
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
 	DBG_871X("\n======= RF REG =======\n");
-	if((RF_1T2R == rf_type) ||(RF_1T1R ==rf_type))
+	if ((RF_1T2R == rf_type) ||(RF_1T1R ==rf_type))
 		path_nums = 1;
 	else
 		path_nums = 2;
@@ -6007,9 +5983,9 @@ void rf_reg_dump(_adapter *padapter)
 		{
 			//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
 			value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
-			if(j%4==1)	DBG_871X("0x%02x ",i);
+			if (j%4==1)	DBG_871X("0x%02x ",i);
 			DBG_871X(" 0x%08x ",value);
-			if((j++)%4==0)	DBG_871X("\n");
+			if ((j++)%4==0)	DBG_871X("\n");
 		}
 	}
 }
@@ -6117,7 +6093,7 @@ static int rtw_dbg_port(struct net_devic
 					{
 						struct xmit_frame	*xmit_frame;
 
-						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
+						if ((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
 							ret = -ENOMEM;
 							break;
 						}
@@ -6125,7 +6101,7 @@ static int rtw_dbg_port(struct net_devic
 						rtw_IOL_append_LLT_cmd(xmit_frame, page_boundary);
 
 
-						if(_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 500))
+						if (_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 500))
 							ret = -EPERM;
 					}
 				}
@@ -6140,7 +6116,7 @@ static int rtw_dbg_port(struct net_devic
 					{
 						struct xmit_frame	*xmit_frame;
 
-						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
+						if ((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
 							ret = -ENOMEM;
 							break;
 						}
@@ -6151,7 +6127,7 @@ static int rtw_dbg_port(struct net_devic
 							rtw_IOL_append_WB_cmd(xmit_frame, reg, 0x08);
 							rtw_IOL_append_DELAY_MS_cmd(xmit_frame, blink_delay_ms);
 						}
-						if(_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, (blink_delay_ms*blink_num*2)+200))
+						if (_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, (blink_delay_ms*blink_num*2)+200))
 							ret = -EPERM;
 					}
 				}
@@ -6168,7 +6144,7 @@ static int rtw_dbg_port(struct net_devic
 					{
 						struct xmit_frame	*xmit_frame;
 
-						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
+						if ((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
 							ret = -ENOMEM;
 							break;
 						}
@@ -6176,11 +6152,11 @@ static int rtw_dbg_port(struct net_devic
 						for(i=0;i<write_num;i++){
 							rtw_IOL_append_WB_cmd(xmit_frame, reg, i+start_value);
 						}
-						if(_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000))
+						if (_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000))
 							ret = -EPERM;
 					}
 
-					if(start_value+write_num-1 == (final=rtw_read8(padapter, reg))) {
+					if (start_value+write_num-1 == (final=rtw_read8(padapter, reg))) {
 						DBG_871X("continuous IOL_CMD_WB_REG to 0x%x %u times Success, start:%u, final:%u\n", reg, write_num, start_value, final);
 					} else {
 						DBG_871X("continuous IOL_CMD_WB_REG to 0x%x %u times Fail, start:%u, final:%u\n", reg, write_num, start_value, final);
@@ -6200,7 +6176,7 @@ static int rtw_dbg_port(struct net_devic
 					{
 						struct xmit_frame	*xmit_frame;
 
-						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
+						if ((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
 							ret = -ENOMEM;
 							break;
 						}
@@ -6208,11 +6184,11 @@ static int rtw_dbg_port(struct net_devic
 						for(i=0;i<write_num;i++){
 							rtw_IOL_append_WW_cmd(xmit_frame, reg, i+start_value);
 						}
-						if(_SUCCESS !=rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000))
+						if (_SUCCESS !=rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000))
 							ret = -EPERM;
 					}
 
-					if(start_value+write_num-1 == (final=rtw_read16(padapter, reg))) {
+					if (start_value+write_num-1 == (final=rtw_read16(padapter, reg))) {
 						DBG_871X("continuous IOL_CMD_WW_REG to 0x%x %u times Success, start:%u, final:%u\n", reg, write_num, start_value, final);
 					} else {
 						DBG_871X("continuous IOL_CMD_WW_REG to 0x%x %u times Fail, start:%u, final:%u\n", reg, write_num, start_value, final);
@@ -6232,7 +6208,7 @@ static int rtw_dbg_port(struct net_devic
 					{
 						struct xmit_frame	*xmit_frame;
 
-						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
+						if ((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
 							ret = -ENOMEM;
 							break;
 						}
@@ -6240,12 +6216,12 @@ static int rtw_dbg_port(struct net_devic
 						for(i=0;i<write_num;i++){
 							rtw_IOL_append_WD_cmd(xmit_frame, reg, i+start_value);
 						}
-						if(_SUCCESS !=rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000))
+						if (_SUCCESS !=rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000))
 							ret = -EPERM;
 
 					}
 
-					if(start_value+write_num-1 == (final=rtw_read32(padapter, reg))) {
+					if (start_value+write_num-1 == (final=rtw_read32(padapter, reg))) {
 						DBG_871X("continuous IOL_CMD_WD_REG to 0x%x %u times Success, start:%u, final:%u\n", reg, write_num, start_value, final);
 					} else {
 						DBG_871X("continuous IOL_CMD_WD_REG to 0x%x %u times Fail, start:%u, final:%u\n", reg, write_num, start_value, final);
@@ -6285,7 +6261,7 @@ static int rtw_dbg_port(struct net_devic
 					break;
 				case 0x05:
 					psta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
-					if(psta)
+					if (psta)
 					{
 						int i;
 						struct recv_reorder_ctrl *preorder_ctrl;
@@ -6303,7 +6279,7 @@ static int rtw_dbg_port(struct net_devic
 						for(i=0;i<16;i++)
 						{
 							preorder_ctrl = &psta->recvreorder_ctrl[i];
-							if(preorder_ctrl->enable)
+							if (preorder_ctrl->enable)
 							{
 								DBG_871X("tid=%d, indicate_seq=%d\n", i, preorder_ctrl->indicate_seq);
 							}
@@ -6361,7 +6337,7 @@ static int rtw_dbg_port(struct net_devic
 
 								plist = get_next(plist);
 
-								if(extra_arg == psta->aid)
+								if (extra_arg == psta->aid)
 								{
 									DBG_871X("sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
 									DBG_871X("rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
@@ -6385,7 +6361,7 @@ static int rtw_dbg_port(struct net_devic
 									for(j=0;j<16;j++)
 									{
 										preorder_ctrl = &psta->recvreorder_ctrl[j];
-										if(preorder_ctrl->enable)
+										if (preorder_ctrl->enable)
 										{
 											DBG_871X("tid=%d, indicate_seq=%d\n", j, preorder_ctrl->indicate_seq);
 										}
@@ -6411,7 +6387,7 @@ static int rtw_dbg_port(struct net_devic
 		#ifdef DBG_CONFIG_ERROR_DETECT
 				case 0x0f:
 						{
-							if(extra_arg == 0){
+							if (extra_arg == 0){
 								DBG_871X("###### silent reset test.......#####\n");
 								rtw_hal_sreset_reset(padapter);
 							}
@@ -6441,7 +6417,7 @@ static int rtw_dbg_port(struct net_devic
 					struct registry_priv	*pregpriv = &padapter->registrypriv;
 					// 0: disable, bit(0):enable 2.4g, bit(1):enable 5g, 0x3: enable both 2.4g and 5g
 					//default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ
-					if(pregpriv && (extra_arg == 0 || extra_arg == 1|| extra_arg == 2 || extra_arg == 3))
+					if (pregpriv && (extra_arg == 0 || extra_arg == 1|| extra_arg == 2 || extra_arg == 3))
 					{
 						pregpriv->rx_stbc= extra_arg;
 						DBG_871X("set rx_stbc=%d\n",pregpriv->rx_stbc);
@@ -6455,7 +6431,7 @@ static int rtw_dbg_port(struct net_devic
 				{
 					struct registry_priv	*pregpriv = &padapter->registrypriv;
 					// 0: disable, 0x1:enable (but wifi_spec should be 0), 0x2: force enable (don't care wifi_spec)
-					if(pregpriv && extra_arg >= 0 && extra_arg < 3)
+					if (pregpriv && extra_arg >= 0 && extra_arg < 3)
 					{
 						pregpriv->ampdu_enable= extra_arg;
 						DBG_871X("set ampdu_enable=%d\n",pregpriv->ampdu_enable);
@@ -6495,13 +6471,13 @@ static int rtw_dbg_port(struct net_devic
 #if 1
 				case 0xdd://registers dump , 0 for mac reg,1 for bb reg, 2 for rf reg
 					{
-						if(extra_arg==0){
+						if (extra_arg==0){
 							mac_reg_dump(padapter);
 						}
-						else if(extra_arg==1){
+						else if (extra_arg==1){
 							bb_reg_dump(padapter);
 						}
-						else if(extra_arg==2){
+						else if (extra_arg==2){
 							rf_reg_dump(padapter);
 						}
 
@@ -6512,7 +6488,7 @@ static int rtw_dbg_port(struct net_devic
 					{
 						u8 dm_flag;
 
-						if(0xf==extra_arg){
+						if (0xf==extra_arg){
 							rtw_hal_get_def_var(padapter, HAL_DEF_DBG_DM_FUNC,&dm_flag);
 							DBG_871X(" === DMFlag(0x%02x) === \n",dm_flag);
 							DBG_871X("extra_arg = 0  - disable all dynamic func \n");
@@ -6692,14 +6668,14 @@ static int wpa_mlme(struct net_device *d
 	{
 		case IEEE_MLME_STA_DEAUTH:
 
-			if(!rtw_set_802_11_disassociate(padapter))
+			if (!rtw_set_802_11_disassociate(padapter))
 				ret = -1;
 
 			break;
 
 		case IEEE_MLME_STA_DISASSOC:
 
-			if(!rtw_set_802_11_disassociate(padapter))
+			if (!rtw_set_802_11_disassociate(padapter))
 				ret = -1;
 
 			break;
@@ -6793,7 +6769,7 @@ static u8 set_pairwise_key(_adapter *pad
 	}
 
 	psetstakey_para = (struct set_stakey_parm*)rtw_zmalloc(sizeof(struct set_stakey_parm));
-	if(psetstakey_para==NULL){
+	if (psetstakey_para==NULL){
 		rtw_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
 		res=_FAIL;
 		goto exit;
@@ -6825,15 +6801,15 @@ static int set_group_key(_adapter *padap
 	struct cmd_priv	*pcmdpriv=&(padapter->cmdpriv);
 	int res=_SUCCESS;
 
-	DBG_871X("%s\n", __FUNCTION__);
+	DBG_871X("%s\n", __func__);
 
 	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if(pcmd==NULL){
+	if (pcmd==NULL){
 		res= _FAIL;
 		goto exit;
 	}
 	psetkeyparm=(struct setkey_parm*)rtw_zmalloc(sizeof(struct setkey_parm));
-	if(psetkeyparm==NULL){
+	if (psetkeyparm==NULL){
 		rtw_mfree((unsigned char *)pcmd, sizeof(struct cmd_obj));
 		res= _FAIL;
 		goto exit;
@@ -6915,7 +6891,7 @@ static int rtw_set_encryption(struct net
 	struct security_priv* psecuritypriv=&(padapter->securitypriv);
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
-	DBG_871X("%s\n", __FUNCTION__);
+	DBG_871X("%s\n", __func__);
 
 	param->u.crypt.err = 0;
 	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
@@ -6941,7 +6917,7 @@ static int rtw_set_encryption(struct net
 	else
 	{
 		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
-		if(!psta)
+		if (!psta)
 		{
 			//ret = -EINVAL;
 			DBG_871X("rtw_set_encryption(), sta has already been removed or never been added\n");
@@ -6968,7 +6944,7 @@ static int rtw_set_encryption(struct net
 
 		DBG_871X("r871x_set_encryption, wep_key_idx=%d, len=%d\n", wep_key_idx, wep_key_len);
 
-		if((wep_key_idx >= WEP_KEYS) || (wep_key_len<=0))
+		if ((wep_key_idx >= WEP_KEYS) || (wep_key_len<=0))
 		{
 			ret = -EINVAL;
 			goto exit;
@@ -6980,7 +6956,7 @@ static int rtw_set_encryption(struct net
 			wep_key_len = wep_key_len <= 5 ? 5 : 13;
 			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
 			pwep =(NDIS_802_11_WEP *)rtw_malloc(wep_total_len);
-			if(pwep == NULL){
+			if (pwep == NULL){
 				DBG_871X(" r871x_set_encryption: pwep allocate fail !!!\n");
 				goto exit;
 			}
@@ -6996,7 +6972,7 @@ static int rtw_set_encryption(struct net
 
 		_rtw_memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
 
-		if(param->u.crypt.set_tx)
+		if (param->u.crypt.set_tx)
 		{
 			DBG_871X("wep, set_tx=1\n");
 
@@ -7004,7 +6980,7 @@ static int rtw_set_encryption(struct net
 			psecuritypriv->dot11PrivacyAlgrthm=_WEP40_;
 			psecuritypriv->dot118021XGrpPrivacy=_WEP40_;
 
-			if(pwep->KeyLength==13)
+			if (pwep->KeyLength==13)
 			{
 				psecuritypriv->dot11PrivacyAlgrthm=_WEP104_;
 				psecuritypriv->dot118021XGrpPrivacy=_WEP104_;
@@ -7041,26 +7017,26 @@ static int rtw_set_encryption(struct net
 	}
 
 
-	if(!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) // //group key
+	if (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) // //group key
 	{
-		if(param->u.crypt.set_tx ==1)
+		if (param->u.crypt.set_tx ==1)
 		{
-			if(strcmp(param->u.crypt.alg, "WEP") == 0)
+			if (strcmp(param->u.crypt.alg, "WEP") == 0)
 			{
-				DBG_871X("%s, set group_key, WEP\n", __FUNCTION__);
+				DBG_871X("%s, set group_key, WEP\n", __func__);
 
 				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
 				psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
-				if(param->u.crypt.key_len==13)
+				if (param->u.crypt.key_len==13)
 				{
 						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
 				}
 
 			}
-			else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+			else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
 			{
-				DBG_871X("%s, set group_key, TKIP\n", __FUNCTION__);
+				DBG_871X("%s, set group_key, TKIP\n", __func__);
 
 				psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
 
@@ -7074,9 +7050,9 @@ static int rtw_set_encryption(struct net
 				psecuritypriv->busetkipkey = _TRUE;
 
 			}
-			else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+			else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
 			{
-				DBG_871X("%s, set group_key, CCMP\n", __FUNCTION__);
+				DBG_871X("%s, set group_key, CCMP\n", __func__);
 
 				psecuritypriv->dot118021XGrpPrivacy = _AES_;
 
@@ -7084,7 +7060,7 @@ static int rtw_set_encryption(struct net
 			}
 			else
 			{
-				DBG_871X("%s, set group_key, none\n", __FUNCTION__);
+				DBG_871X("%s, set group_key, none\n", __func__);
 
 				psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
 			}
@@ -7098,7 +7074,7 @@ static int rtw_set_encryption(struct net
 			set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
 
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
-			if(pbcmc_sta)
+			if (pbcmc_sta)
 			{
 				pbcmc_sta->ieee8021x_blocked = _FALSE;
 				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
@@ -7110,27 +7086,27 @@ static int rtw_set_encryption(struct net
 
 	}
 
-	if(psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) // psk/802_1x
+	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) // psk/802_1x
 	{
-		if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE))
 		{
-			if(param->u.crypt.set_tx ==1)
+			if (param->u.crypt.set_tx ==1)
 			{
 				_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
-				if(strcmp(param->u.crypt.alg, "WEP") == 0)
+				if (strcmp(param->u.crypt.alg, "WEP") == 0)
 				{
-					DBG_871X("%s, set pairwise key, WEP\n", __FUNCTION__);
+					DBG_871X("%s, set pairwise key, WEP\n", __func__);
 
 					psta->dot118021XPrivacy = _WEP40_;
-					if(param->u.crypt.key_len==13)
+					if (param->u.crypt.key_len==13)
 					{
 						psta->dot118021XPrivacy = _WEP104_;
 					}
 				}
-				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+				else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
 				{
-					DBG_871X("%s, set pairwise key, TKIP\n", __FUNCTION__);
+					DBG_871X("%s, set pairwise key, TKIP\n", __func__);
 
 					psta->dot118021XPrivacy = _TKIP_;
 
@@ -7142,16 +7118,16 @@ static int rtw_set_encryption(struct net
 					psecuritypriv->busetkipkey = _TRUE;
 
 				}
-				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+				else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
 				{
 
-					DBG_871X("%s, set pairwise key, CCMP\n", __FUNCTION__);
+					DBG_871X("%s, set pairwise key, CCMP\n", __func__);
 
 					psta->dot118021XPrivacy = _AES_;
 				}
 				else
 				{
-					DBG_871X("%s, set pairwise key, none\n", __FUNCTION__);
+					DBG_871X("%s, set pairwise key, none\n", __func__);
 
 					psta->dot118021XPrivacy = _NO_PRIVACY_;
 				}
@@ -7163,17 +7139,17 @@ static int rtw_set_encryption(struct net
 			}
 			else//group key???
 			{
-				if(strcmp(param->u.crypt.alg, "WEP") == 0)
+				if (strcmp(param->u.crypt.alg, "WEP") == 0)
 				{
 					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
 					psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
-					if(param->u.crypt.key_len==13)
+					if (param->u.crypt.key_len==13)
 					{
 						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
 					}
 				}
-				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
+				else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
 				{
 					psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
 
@@ -7187,7 +7163,7 @@ static int rtw_set_encryption(struct net
 					psecuritypriv->busetkipkey = _TRUE;
 
 				}
-				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
+				else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
 				{
 					psecuritypriv->dot118021XGrpPrivacy = _AES_;
 
@@ -7207,7 +7183,7 @@ static int rtw_set_encryption(struct net
 				set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
 
 				pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
-				if(pbcmc_sta)
+				if (pbcmc_sta)
 				{
 					pbcmc_sta->ieee8021x_blocked = _FALSE;
 					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
@@ -7221,7 +7197,7 @@ static int rtw_set_encryption(struct net
 
 exit:
 
-	if(pwep)
+	if (pwep)
 	{
 		rtw_mfree((u8 *)pwep,wep_total_len);
 	}
@@ -7239,18 +7215,18 @@ static int rtw_set_beacon(struct net_dev
 	unsigned char *pbuf = param->u.bcn_ie.buf;
 
 
-	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+	DBG_871X("%s, len=%d\n", __func__, len);
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
 		return -EINVAL;
 
 	_rtw_memcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);
 
-	if((pstapriv->max_num_sta>NUM_STA) || (pstapriv->max_num_sta<=0))
+	if ((pstapriv->max_num_sta>NUM_STA) || (pstapriv->max_num_sta<=0))
 		pstapriv->max_num_sta = NUM_STA;
 
 
-	if(rtw_check_beacon_data(padapter, pbuf,  (len-12-2)) == _SUCCESS)// 12 = param header, 2:no packed
+	if (rtw_check_beacon_data(padapter, pbuf,  (len-12-2)) == _SUCCESS)// 12 = param header, 2:no packed
 		ret = 0;
 	else
 		ret = -EINVAL;
@@ -7269,7 +7245,7 @@ static int rtw_hostapd_sta_flush(struct
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	//struct sta_priv *pstapriv = &padapter->stapriv;
 
-	DBG_871X("%s\n", __FUNCTION__);
+	DBG_871X("%s\n", __func__);
 
 	flush_all_cam_entry(padapter);	//clear CAM
 
@@ -7290,7 +7266,7 @@ static int rtw_add_sta(struct net_device
 
 	DBG_871X("rtw_add_sta(aid=%d)=" MAC_FMT "\n", param->u.add_sta.aid, MAC_ARG(param->sta_addr));
 
-	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
 	{
 		return -EINVAL;
 	}
@@ -7304,7 +7280,7 @@ static int rtw_add_sta(struct net_device
 
 /*
 	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
-	if(psta)
+	if (psta)
 	{
 		DBG_871X("rtw_add_sta(), free has been added psta=%p\n", psta);
 		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
@@ -7316,7 +7292,7 @@ static int rtw_add_sta(struct net_device
 */
 	//psta = rtw_alloc_stainfo(pstapriv, param->sta_addr);
 	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
-	if(psta)
+	if (psta)
 	{
 		int flags = param->u.add_sta.flags;
 
@@ -7328,18 +7304,18 @@ static int rtw_add_sta(struct net_device
 
 
 		//check wmm cap.
-		if(WLAN_STA_WME&flags)
+		if (WLAN_STA_WME&flags)
 			psta->qos_option = 1;
 		else
 			psta->qos_option = 0;
 
-		if(pmlmepriv->qospriv.qos_option == 0)
+		if (pmlmepriv->qospriv.qos_option == 0)
 			psta->qos_option = 0;
 
 
 #ifdef CONFIG_80211N_HT
 		//chec 802.11n ht cap.
-		if(WLAN_STA_HT&flags)
+		if (WLAN_STA_HT&flags)
 		{
 			psta->htpriv.ht_option = _TRUE;
 			psta->qos_option = 1;
@@ -7350,7 +7326,7 @@ static int rtw_add_sta(struct net_device
 			psta->htpriv.ht_option = _FALSE;
 		}
 
-		if(pmlmepriv->htpriv.ht_option == _FALSE)
+		if (pmlmepriv->htpriv.ht_option == _FALSE)
 			psta->htpriv.ht_option = _FALSE;
 #endif
 
@@ -7379,7 +7355,7 @@ static int rtw_del_sta(struct net_device
 
 	DBG_871X("rtw_del_sta=" MAC_FMT "\n", MAC_ARG(param->sta_addr));
 
-	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
 	{
 		return -EINVAL;
 	}
@@ -7392,14 +7368,14 @@ static int rtw_del_sta(struct net_device
 	}
 
 	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
-	if(psta)
+	if (psta)
 	{
 		u8 updated;
 
 		//DBG_871X("free psta=%p, aid=%d\n", psta, psta->aid);
 
 		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-		if(rtw_is_list_empty(&psta->asoc_list)==_FALSE)
+		if (rtw_is_list_empty(&psta->asoc_list)==_FALSE)
 		{
 			rtw_list_delete(&psta->asoc_list);
 			pstapriv->asoc_list_cnt--;
@@ -7437,7 +7413,7 @@ static int rtw_ioctl_get_sta_data(struct
 
 	DBG_871X("rtw_ioctl_get_sta_info, sta_addr: " MAC_FMT "\n", MAC_ARG(param_ex->sta_addr));
 
-	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
 	{
 		return -EINVAL;
 	}
@@ -7450,7 +7426,7 @@ static int rtw_ioctl_get_sta_data(struct
 	}
 
 	psta = rtw_get_stainfo(pstapriv, param_ex->sta_addr);
-	if(psta)
+	if (psta)
 	{
 		psta_data->aid = (u16)psta->aid;
 		psta_data->capability = psta->capability;
@@ -7506,7 +7482,7 @@ static int rtw_get_sta_wpaie(struct net_
 
 	DBG_871X("rtw_get_sta_wpaie, sta_addr: " MAC_FMT "\n", MAC_ARG(param->sta_addr));
 
-	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
 	{
 		return -EINVAL;
 	}
@@ -7519,9 +7495,9 @@ static int rtw_get_sta_wpaie(struct net_
 	}
 
 	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
-	if(psta)
+	if (psta)
 	{
-		if((psta->wpa_ie[0] == WLAN_EID_RSN) || (psta->wpa_ie[0] == WLAN_EID_GENERIC))
+		if ((psta->wpa_ie[0] == WLAN_EID_RSN) || (psta->wpa_ie[0] == WLAN_EID_GENERIC))
 		{
 			int wpa_ie_len;
 			int copy_len;
@@ -7559,26 +7535,26 @@ static int rtw_set_wps_beacon(struct net
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	int ie_len;
 
-	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+	DBG_871X("%s, len=%d\n", __func__, len);
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
 		return -EINVAL;
 
 	ie_len = len-12-2;// 12 = param header, 2:no packed
 
 
-	if(pmlmepriv->wps_beacon_ie)
+	if (pmlmepriv->wps_beacon_ie)
 	{
 		rtw_mfree(pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len);
 		pmlmepriv->wps_beacon_ie = NULL;
 	}
 
-	if(ie_len>0)
+	if (ie_len>0)
 	{
 		pmlmepriv->wps_beacon_ie = rtw_malloc(ie_len);
 		pmlmepriv->wps_beacon_ie_len = ie_len;
 		if (pmlmepriv->wps_beacon_ie == NULL) {
-			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 			return -EINVAL;
 		}
 
@@ -7602,26 +7578,26 @@ static int rtw_set_wps_probe_resp(struct
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	int ie_len;
 
-	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+	DBG_871X("%s, len=%d\n", __func__, len);
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
 		return -EINVAL;
 
 	ie_len = len-12-2;// 12 = param header, 2:no packed
 
 
-	if(pmlmepriv->wps_probe_resp_ie)
+	if (pmlmepriv->wps_probe_resp_ie)
 	{
 		rtw_mfree(pmlmepriv->wps_probe_resp_ie, pmlmepriv->wps_probe_resp_ie_len);
 		pmlmepriv->wps_probe_resp_ie = NULL;
 	}
 
-	if(ie_len>0)
+	if (ie_len>0)
 	{
 		pmlmepriv->wps_probe_resp_ie = rtw_malloc(ie_len);
 		pmlmepriv->wps_probe_resp_ie_len = ie_len;
 		if (pmlmepriv->wps_probe_resp_ie == NULL) {
-			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 			return -EINVAL;
 		}
 		_rtw_memcpy(pmlmepriv->wps_probe_resp_ie, param->u.bcn_ie.buf, ie_len);
@@ -7639,26 +7615,26 @@ static int rtw_set_wps_assoc_resp(struct
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	int ie_len;
 
-	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+	DBG_871X("%s, len=%d\n", __func__, len);
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
 		return -EINVAL;
 
 	ie_len = len-12-2;// 12 = param header, 2:no packed
 
 
-	if(pmlmepriv->wps_assoc_resp_ie)
+	if (pmlmepriv->wps_assoc_resp_ie)
 	{
 		rtw_mfree(pmlmepriv->wps_assoc_resp_ie, pmlmepriv->wps_assoc_resp_ie_len);
 		pmlmepriv->wps_assoc_resp_ie = NULL;
 	}
 
-	if(ie_len>0)
+	if (ie_len>0)
 	{
 		pmlmepriv->wps_assoc_resp_ie = rtw_malloc(ie_len);
 		pmlmepriv->wps_assoc_resp_ie_len = ie_len;
 		if (pmlmepriv->wps_assoc_resp_ie == NULL) {
-			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 			return -EINVAL;
 		}
 
@@ -7683,7 +7659,7 @@ static int rtw_set_hidden_ssid(struct ne
 	sint ssid_len;
 	u8 ignore_broadcast_ssid;
 
-	if(check_fwstate(mlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(mlmepriv, WIFI_AP_STATE) != _TRUE)
 		return -EPERM;
 
 	if (param->u.bcn_ie.reserved[0] != 0xea)
@@ -7701,7 +7677,7 @@ static int rtw_set_hidden_ssid(struct ne
 		_rtw_memcpy(ssid, ssid_ie+2, ssid_len);
 		ssid[ssid_len>NDIS_802_11_LENGTH_SSID?NDIS_802_11_LENGTH_SSID:ssid_len] = 0x0;
 
-		if(0)
+		if (0)
 		DBG_871X(FUNC_ADPT_FMT" ssid:(%s,%d), from ie:(%s,%d), (%s,%d)\n", FUNC_ADPT_ARG(adapter),
 			ssid, ssid_len,
 			pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength,
@@ -7712,7 +7688,7 @@ static int rtw_set_hidden_ssid(struct ne
 		_rtw_memcpy(pbss_network_ext->Ssid.Ssid, (void *)ssid, ssid_len);
 		pbss_network_ext->Ssid.SsidLength = ssid_len;
 
-		if(0)
+		if (0)
 		DBG_871X(FUNC_ADPT_FMT" after ssid:(%s,%d), (%s,%d)\n", FUNC_ADPT_ARG(adapter),
 			pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength,
 			pbss_network_ext->Ssid.Ssid, pbss_network_ext->Ssid.SsidLength);
@@ -7730,7 +7706,7 @@ static int rtw_ioctl_acl_remove_sta(stru
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
 		return -EINVAL;
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
@@ -7752,7 +7728,7 @@ static int rtw_ioctl_acl_add_sta(struct
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
 		return -EINVAL;
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
@@ -7774,7 +7750,7 @@ static int rtw_ioctl_set_macaddr_acl(str
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
 		return -EINVAL;
 
 	rtw_set_macaddr_acl(padapter, param->u.mlme.command);
@@ -7788,7 +7764,7 @@ static int rtw_hostapd_ioctl(struct net_
 	int ret=0;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 
-	//DBG_871X("%s\n", __FUNCTION__);
+	//DBG_871X("%s\n", __func__);
 
 	/*
 	* this function is expect to call in master mode, which allows no power saving
@@ -7802,7 +7778,7 @@ static int rtw_hostapd_ioctl(struct net_
 
 
 	//if (p->length < sizeof(struct ieee_param) || !p->pointer){
-	if(!p->pointer){
+	if (!p->pointer){
 		ret = -EINVAL;
 		goto out;
 	}
@@ -7821,7 +7797,7 @@ static int rtw_hostapd_ioctl(struct net_
 		goto out;
 	}
 
-	//DBG_871X("%s, cmd=%d\n", __FUNCTION__, param->cmd);
+	//DBG_871X("%s, cmd=%d\n", __func__, param->cmd);
 
 	switch (param->cmd)
 	{
@@ -7949,7 +7925,7 @@ static int rtw_wx_set_priv(struct net_de
 	struct iw_point *dwrq = (struct iw_point*)awrq;
 
 	//RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+rtw_wx_set_priv\n"));
-	if(dwrq->length == 0)
+	if (dwrq->length == 0)
 		return -EFAULT;
 	len = dwrq->length;
 	if (!(ext = rtw_vmalloc(len)))
@@ -7976,7 +7952,7 @@ static int rtw_wx_set_priv(struct net_de
 	#endif
 
 	//added for wps2.0 @20110524
-	if(dwrq->flags == 0x8766 && len > 8)
+	if (dwrq->flags == 0x8766 && len > 8)
 	{
 		u32 cp_sz;
 		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -7984,7 +7960,7 @@ static int rtw_wx_set_priv(struct net_de
 		int probereq_wpsie_len = len;
 		u8 wps_oui[4]={0x0,0x50,0xf2,0x04};
 
-		if((_VENDOR_SPECIFIC_IE_ == probereq_wpsie[0]) &&
+		if ((_VENDOR_SPECIFIC_IE_ == probereq_wpsie[0]) &&
 			(_rtw_memcmp(&probereq_wpsie[2], wps_oui, 4) ==_TRUE))
 		{
 			cp_sz = probereq_wpsie_len>MAX_WPS_IE_LEN ? MAX_WPS_IE_LEN:probereq_wpsie_len;
@@ -7994,7 +7970,7 @@ static int rtw_wx_set_priv(struct net_de
 
 			printk("probe_req_wps_ielen=%d\n", cp_sz);
 
-			if(pmlmepriv->wps_probe_req_ie)
+			if (pmlmepriv->wps_probe_req_ie)
 			{
 				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 				pmlmepriv->wps_probe_req_ie_len = 0;
@@ -8004,7 +7980,7 @@ static int rtw_wx_set_priv(struct net_de
 
 			pmlmepriv->wps_probe_req_ie = rtw_malloc(cp_sz);
 			if (pmlmepriv->wps_probe_req_ie == NULL) {
-				printk("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+				printk("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 				ret =  -EINVAL;
 				goto FREE_EXT;
 
@@ -8019,7 +7995,7 @@ static int rtw_wx_set_priv(struct net_de
 
 	}
 
-	if(	len >= WEXT_CSCAN_HEADER_SIZE
+	if (	len >= WEXT_CSCAN_HEADER_SIZE
 		&& _rtw_memcmp(ext, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == _TRUE
 	){
 		ret = rtw_wx_set_scan(dev, info, awrq, ext);
@@ -8043,7 +8019,7 @@ static int rtw_wx_set_priv(struct net_de
 				struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 				struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
 
-				if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
+				if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
 					sprintf(ext, "%s rssi %d", pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
 				} else {
 					sprintf(ext, "OK");
@@ -8082,7 +8058,7 @@ static int rtw_wx_set_priv(struct net_de
 			break;
 		default :
 			#ifdef  CONFIG_DEBUG_RTW_WX_SET_PRIV
-			DBG_871X("%s: %s unknowned req=%s\n", __FUNCTION__,
+			DBG_871X("%s: %s unknowned req=%s\n", __func__,
 				dev->name, ext_dbg);
 			#endif
 
@@ -8094,7 +8070,7 @@ static int rtw_wx_set_priv(struct net_de
 		ret = -EFAULT;
 
 	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
-	DBG_871X("%s: %s req=%s rep=%s dwrq->length=%d, strlen(ext)+1=%d\n", __FUNCTION__,
+	DBG_871X("%s: %s req=%s rep=%s dwrq->length=%d, strlen(ext)+1=%d\n", __func__,
 		dev->name, ext_dbg ,ext, dwrq->length, (u16)(strlen(ext)+1));
 	#endif
 #endif //end of CONFIG_ANDROID
@@ -8126,8 +8102,8 @@ static int rtw_mp_efuse_get(struct net_d
 	u8 data[EFUSE_MAP_SIZE];
 	u8 rawdata[EFUSE_MAX_SIZE];
 	u16 mapLen=0;
-	char *pch, *ptmp, *token, *tmp[3]={0x00,0x00,0x00};
-	u16 addr = 0, cnts = 0, max_available_size = 0,raw_cursize = 0 ,raw_maxsize = 0;
+	char *pch, *ptmp, *token, *tmp[3] = {NULL, NULL, NULL};
+	u16 addr = 0, cnts = 0, max_available_size = 0, raw_cursize = 0, raw_maxsize = 0;
 
 	_rtw_memset(data, '\0', sizeof(data));
 	_rtw_memset(rawdata, '\0', sizeof(rawdata));
@@ -8142,7 +8118,7 @@ static int rtw_mp_efuse_get(struct net_d
 	//mac 16 "00e04c871200" rmap,00,2
 	while ((token = strsep (&pch,","))!=NULL)
 	{
-			if(i>2) break;
+			if (i>2) break;
 			tmp[i] = token;
 			i++;
 	}
@@ -8193,7 +8169,7 @@ static int rtw_mp_efuse_get(struct net_d
 		DBG_871X("addr = %x \n" ,addr);
 
 		cnts=simple_strtoul(tmp[2], &ptmp,10);
-		if(cnts==0) return -EINVAL;
+		if (cnts==0) return -EINVAL;
 
 		DBG_871X("cnts = %d \n" ,cnts);
 		//_rtw_memset(extra, '\0', wrqu->data.length);
@@ -8336,7 +8312,7 @@ static int rtw_mp_efuse_set(struct net_d
 	u32 i,jj,kk;
 	u8 setdata[EFUSE_MAP_SIZE];
 	u8 setrawdata[EFUSE_MAX_SIZE];
-	char *pch, *ptmp, *token, *edata,*tmp[3]={0x00,0x00,0x00};
+	char *pch, *ptmp, *token, *edata, *tmp[3] = {NULL, NULL, NULL};
 
 	u16 addr = 0, max_available_size = 0;
 	u32  cnts = 0;
@@ -8347,7 +8323,7 @@ static int rtw_mp_efuse_set(struct net_d
 	i=0;
 	while ((token = strsep (&pch,","))!=NULL)
 	{
-		if(i>2) break;
+		if (i>2) break;
 		tmp[i] = token;
 		i++;
 	}
@@ -8617,7 +8593,7 @@ static int rtw_mp_read_reg(struct net_de
 			sprintf(data, "%04d\n", rtw_read16(padapter, addr));
 			for(i=0 ; i <= strlen(data) ; i++)
 				{
-					  if(i%2==0)
+					  if (i%2==0)
 					  {
 						   tmp[j]=' ';
 						   j++;
@@ -8653,7 +8629,7 @@ static int rtw_mp_read_reg(struct net_de
 				//add read data format blank
 				for(i=0 ; i <= strlen(data) ; i++)
 				{
-					  if(i%2==0)
+					  if (i%2==0)
 					  {
 						   tmp[j]=' ';
 						   j++;
@@ -8763,7 +8739,7 @@ static int rtw_mp_read_rf(struct net_dev
 				//add read data format blank
 				for(i=0 ; i <= strlen(data) ; i++)
 				{
-					  if(i%2==0)
+					  if (i%2==0)
 					  {
 						   tmp[j]=' ';
 						   j++;
@@ -8844,7 +8820,7 @@ static int rtw_mp_rate(struct net_device
 	rate = rtw_atoi(input);
 	sprintf(extra, "Set data rate to %d" , rate);
 
-	if(rate <= 0x7f)
+	if (rate <= 0x7f)
 		rate = wifirate2_ratetbl_inx((u8)rate);
 	else
 		rate =(rate-0x80+MPT_RATE_MCS0);
@@ -9120,7 +9096,7 @@ static int rtw_mp_ctx(struct net_device
 		case MP_CARRIER_SUPPRISSION_TX:
 			//DBG_871X("%s: CarrSprTx %d\n", __func__, bStartTest);
 			if (bStartTest != 0){
-				if(pmp_priv->rateidx <= MPT_RATE_11M)
+				if (pmp_priv->rateidx <= MPT_RATE_11M)
 				{
 					sprintf(extra, "Start continuous DA=ffffffffffff len=1500 \n infinite=yes.");
 				}else
@@ -9178,12 +9154,12 @@ static int rtw_mp_arx(struct net_device
 	bStopRx = (strncmp(input, "stop", 5)==0)?1:0; // strncmp TRUE is 0
 	SetPacketRx(padapter, bStartRx);
 
-	if(bStartRx)
+	if (bStartRx)
 	{
 		sprintf(extra, "start");
 		wrqu->length = strlen(extra) + 1;
 	}
-	else if(bStopRx)
+	else if (bStopRx)
 	{
 		sprintf(extra, "Received packet OK:%d CRC error:%d",padapter->mppriv.rx_pktcount,
 														padapter->mppriv.rx_crcerrpktcount);
@@ -9291,9 +9267,9 @@ static int rtw_mp_thermal(struct net_dev
 
 	 Hal_GetThermalMeter(padapter, &val);
 
-	 if(bwrite == 0) {
+	 if (bwrite == 0) {
 		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
-		if(2 > max_available_size) {
+		if (2 > max_available_size) {
 			DBG_871X("no available efuse!\n");
 			return -EFAULT;
 		}
@@ -9349,22 +9325,22 @@ static int rtw_mp_dump(struct net_device
 			DBG_871X("\n======= MAC REG =======\n");
 			for (i=0x0;i<0x300;i+=4)
 			{
-				if(j%4==1)	DBG_871X("0x%02x",i);
+				if (j%4==1)	DBG_871X("0x%02x",i);
 				DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-				if((j++)%4 == 0)	DBG_871X("\n");
+				if ((j++)%4 == 0)	DBG_871X("\n");
 			}
 			for(i=0x400;i<0x800;i+=4)
 			{
-				if(j%4==1)	DBG_871X("0x%02x",i);
+				if (j%4==1)	DBG_871X("0x%02x",i);
 				DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-				if((j++)%4 == 0)	DBG_871X("\n");
+				if ((j++)%4 == 0)	DBG_871X("\n");
 			}
 
 			i,j=1;
 			rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
 			DBG_871X("\n======= RF REG =======\n");
-			if((RF_1T2R == rf_type) ||(RF_1T1R ==rf_type))
+			if ((RF_1T2R == rf_type) ||(RF_1T1R ==rf_type))
 				path_nums = 1;
 			else
 				path_nums = 2;
@@ -9603,7 +9579,7 @@ static int rtw_wfd_tdls_enable(struct ne
 
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 
-	printk("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1 );
+	printk("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
 
 	if (extra[ 0 ] == '0')
 	{
@@ -9631,7 +9607,7 @@ static int rtw_tdls_weaksec(struct net_d
 	u8 i, j;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 
-	DBG_871X("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1 );
+	DBG_871X("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
 
 	if (extra[ 0 ] == '0')
 	{
@@ -9665,7 +9641,7 @@ static int rtw_tdls_enable(struct net_de
 	u8 tdls_sta[NUM_STA][ETH_ALEN];
 	u8 empty_hwaddr[ETH_ALEN] = { 0x00 };
 
-	printk("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1 );
+	printk("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
 
 	_rtw_memset(tdls_sta, 0x00, sizeof(tdls_sta));
 
@@ -9673,7 +9649,7 @@ static int rtw_tdls_enable(struct net_de
 	{
 		ptdlsinfo->enable = 0;
 
-		if(pstapriv->asoc_sta_count==1)
+		if (pstapriv->asoc_sta_count==1)
 			return ret;
 
 		_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
@@ -9688,7 +9664,7 @@ static int rtw_tdls_enable(struct net_de
 
 				plist = get_next(plist);
 
-				if(psta->tdls_sta_state != TDLS_STATE_NONE)
+				if (psta->tdls_sta_state != TDLS_STATE_NONE)
 				{
 					_rtw_memcpy(tdls_sta[index], psta->hwaddr, ETH_ALEN);
 				}
@@ -9698,7 +9674,7 @@ static int rtw_tdls_enable(struct net_de
 
 		for(index=0; index< NUM_STA; index++)
 		{
-			if(!_rtw_memcmp(tdls_sta[index], empty_hwaddr, ETH_ALEN))
+			if (!_rtw_memcmp(tdls_sta[index], empty_hwaddr, ETH_ALEN))
 			{
 				printk("issue tear down to "MAC_FMT"\n", MAC_ARG(tdls_sta[index]));
 				issue_tdls_teardown(padapter, tdls_sta[index]);
@@ -9732,7 +9708,7 @@ static int rtw_tdls_setup(struct net_dev
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 #endif // CONFIG_WFD
 
-	printk("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1 );
+	printk("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
 
 	for(i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
@@ -9745,7 +9721,7 @@ static int rtw_tdls_setup(struct net_dev
 		if (0 == pwdinfo->wfd_tdls_weaksec)
 		{
 			//	Can't send the tdls setup request out!!
-			DBG_871X("[%s] Current link is not AES, SKIP sending the tdls setup request!!\n", __FUNCTION__);
+			DBG_871X("[%s] Current link is not AES, SKIP sending the tdls setup request!!\n", __func__);
 		}
 		else
 		{
@@ -9775,7 +9751,7 @@ static int rtw_tdls_teardown(struct net_
 	struct sta_info *ptdls_sta = NULL;
 	u8 mac_addr[ETH_ALEN];
 
-	printk("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1 );
+	printk("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
 
 	for(i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
@@ -9783,7 +9759,7 @@ static int rtw_tdls_teardown(struct net_
 
 	ptdls_sta = rtw_get_stainfo(&(padapter->stapriv), mac_addr);
 
-	if(ptdls_sta != NULL)
+	if (ptdls_sta != NULL)
 	{
 		ptdls_sta->stat_code = _RSON_TDLS_TEAR_UN_RSN_;
 		issue_tdls_teardown(padapter, mac_addr);
@@ -9806,7 +9782,7 @@ static int rtw_tdls_discovery(struct net
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	printk("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1 );
+	printk("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
 
 	issue_tdls_dis_req(padapter, NULL);
 
@@ -9828,14 +9804,14 @@ static int rtw_tdls_ch_switch(struct net
 	u8 i, j, mac_addr[ETH_ALEN];
 	struct sta_info *ptdls_sta = NULL;
 
-	printk("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1 );
+	printk("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
 
 	for(i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
 	}
 
 	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
-	if(ptdls_sta == NULL)
+	if (ptdls_sta == NULL)
 		return ret;
 	ptdlsinfo->ch_sensing=1;
 
@@ -9860,7 +9836,7 @@ static int rtw_tdls_pson(struct net_devi
 	u8 i, j, mac_addr[ETH_ALEN];
 	struct sta_info *ptdls_sta = NULL;
 
-	printk("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1 );
+	printk("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
 
 	for(i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
@@ -9889,7 +9865,7 @@ static int rtw_tdls_psoff(struct net_dev
 	u8 i, j, mac_addr[ETH_ALEN];
 	struct sta_info *ptdls_sta = NULL;
 
-	printk("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1 );
+	printk("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
 
 	for(i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
@@ -9918,20 +9894,20 @@ static int rtw_tdls_setip(struct net_dev
 	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
 	u8 i=0, j=0, k=0, tag=0, ip[3] = { 0xff }, *ptr = extra;
 
-	printk("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1 );
+	printk("[%s] %s %d\n", __func__, extra, wrqu->data.length - 1 );
 
 
 	while(i < 4)
 	{
 		for(j=0; j < 4; j++)
 		{
-			if(*(extra + j + tag) == '.' || *(extra + j + tag) == '\0')
+			if (*(extra + j + tag) == '.' || *(extra + j + tag) == '\0')
 			{
-				if(j == 1)
+				if (j == 1)
 					pwfd_info->ip_address[i]=convert_ip_addr('0', '0', *(extra+(j-1)+tag));
-				if(j == 2)
+				if (j == 2)
 					pwfd_info->ip_address[i]=convert_ip_addr('0', *(extra+(j-2)+tag), *(extra+(j-1)+tag));
-				if(j == 3)
+				if (j == 3)
 					pwfd_info->ip_address[i]=convert_ip_addr(*(extra+(j-3)+tag), *(extra+(j-2)+tag), *(extra+(j-1)+tag));
 
 				tag += j + 1;
@@ -9941,7 +9917,7 @@ static int rtw_tdls_setip(struct net_dev
 		i++;
 	}
 
-	printk("[%s] Set IP = %u.%u.%u.%u \n", __FUNCTION__,
+	printk("[%s] Set IP = %u.%u.%u.%u \n", __func__,
 		ptdlsinfo->wfd_info->ip_address[0], ptdlsinfo->wfd_info->ip_address[1],
 		ptdlsinfo->wfd_info->ip_address[2], ptdlsinfo->wfd_info->ip_address[3]
 	);
@@ -9965,14 +9941,14 @@ static int rtw_tdls_getip(struct net_dev
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
 
-	printk("[%s]\n", __FUNCTION__);
+	printk("[%s]\n", __func__);
 
 	sprintf(extra, "\n\n%u.%u.%u.%u\n",
 		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1],
 		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]
 		);
 
-	printk("[%s] IP=%u.%u.%u.%u\n", __FUNCTION__,
+	printk("[%s] IP=%u.%u.%u.%u\n", __func__,
 		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1],
 		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]
 		);
@@ -9999,10 +9975,10 @@ static int rtw_tdls_getport(struct net_d
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
 
-	printk("[%s]\n", __FUNCTION__);
+	printk("[%s]\n", __func__);
 
 	sprintf(extra, "\n\n%d\n", pwfd_info->peer_rtsp_ctrlport);
-	printk("[%s] remote port = %d\n", __FUNCTION__, pwfd_info->peer_rtsp_ctrlport);
+	printk("[%s] remote port = %d\n", __func__, pwfd_info->peer_rtsp_ctrlport);
 
 	wrqu->data.length = strlen(extra);
 
@@ -10028,9 +10004,9 @@ static int rtw_tdls_dis_result(struct ne
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
 
-	printk("[%s]\n", __FUNCTION__);
+	printk("[%s]\n", __func__);
 
-	if(ptdlsinfo->dev_discovered == 1)
+	if (ptdlsinfo->dev_discovered == 1)
 	{
 		sprintf(extra, "\n\nDis=1\n");
 		ptdlsinfo->dev_discovered = 0;
@@ -10060,9 +10036,9 @@ static int rtw_wfd_tdls_status(struct ne
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
 
-	printk("[%s]\n", __FUNCTION__);
+	printk("[%s]\n", __func__);
 
-	if(ptdlsinfo->setup_state == TDLS_LINKED_STATE)
+	if (ptdlsinfo->setup_state == TDLS_LINKED_STATE)
 	{
 		sprintf(extra, "\n\nStatus=1\n");
 	}
@@ -10092,7 +10068,7 @@ static int rtw_tdls_ch_switch_off(struct
 	u8 i, j, mac_addr[ETH_ALEN];
 	struct sta_info *ptdls_sta = NULL;
 
-	printk("[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1 );
+	printk("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
 
 	for(i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
@@ -10102,7 +10078,7 @@ static int rtw_tdls_ch_switch_off(struct
 
 	ptdls_sta->tdls_sta_state |= TDLS_SW_OFF_STATE;
 /*
-	if((ptdls_sta->tdls_sta_state & TDLS_AT_OFF_CH_STATE) && (ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE)){
+	if ((ptdls_sta->tdls_sta_state & TDLS_AT_OFF_CH_STATE) && (ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE)){
 		pmlmeinfo->tdls_candidate_ch= pmlmeext->cur_channel;
 		issue_tdls_ch_switch_req(padapter, mac_addr);
 		DBG_871X("issue tdls ch switch req back to base channel\n");
@@ -10123,7 +10099,7 @@ static int rtw_tdls(struct net_device *d
 #ifdef CONFIG_TDLS
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 
-	printk("[%s] extra = %s\n", __FUNCTION__, extra);
+	printk("[%s] extra = %s\n", __func__, extra);
 	//	WFD Sigma will use the tdls enable command to let the driver know we want to test the tdls now!
 	if (_rtw_memcmp(extra, "wfdenable=", 10))
 	{
@@ -10144,7 +10120,7 @@ static int rtw_tdls(struct net_device *d
 		return ret;
 	}
 
-	if(padapter->tdlsinfo.enable == 0)
+	if (padapter->tdlsinfo.enable == 0)
 	{
 		printk("tdls haven't enabled\n");
 		return 0;
@@ -10211,7 +10187,7 @@ static int rtw_tdls_get(struct net_devic
 
 #ifdef CONFIG_WFD
 
-	DBG_871X("[%s] extra = %s\n", __FUNCTION__, (char*) wrqu->data.pointer);
+	DBG_871X("[%s] extra = %s\n", __func__, (char*) wrqu->data.pointer);
 
 	if (_rtw_memcmp(wrqu->data.pointer, "ip", 2))
 	{
@@ -10245,7 +10221,7 @@ static int rtw_pm_set(struct net_device
 	unsigned	mode = 0;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 
-	DBG_871X("[%s] extra = %s\n", __FUNCTION__, extra);
+	DBG_871X("[%s] extra = %s\n", __func__, extra);
 
 	if (_rtw_memcmp(extra, "lps=", 4)) {
 		sscanf(extra+4, "%u", &mode);
@@ -10298,7 +10274,7 @@ static int rtw_wowlan_ctrl(struct net_de
 	}
 	poidparam = (struct wowlan_ioctl_param *)pparmbuf;
 
-	if(padapter->pwrctrlpriv.bSupportRemoteWakeup==_FALSE){
+	if (padapter->pwrctrlpriv.bSupportRemoteWakeup==_FALSE){
 		ret = -EPERM;
 		DBG_871X("+rtw_wowlan_ctrl: Device didn't support the remote wakeup!!\n");
 		goto _rtw_wowlan_ctrl_exit_free;
@@ -10345,8 +10321,7 @@ static int rtw_widi_set_probe_request(st
 	_adapter	*padapter = (_adapter *)rtw_netdev_priv(dev);
 
 	pbuf = rtw_malloc(sizeof(l2_msg_t));
-	if(pbuf)
-	{
+	if (pbuf) {
 		_rtw_memcpy(pbuf, wrqu->data.pointer, wrqu->data.length);
 		intel_widi_wk_cmd(padapter, INTEL_WIDI_ISSUE_PROB_WK, pbuf);
 	}
--- a/drivers/staging/rtl8192du/os_dep/mlme_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/mlme_linux.c
@@ -40,7 +40,7 @@ void _rtw_scan_timeout_handler (void *Fu
 }
 
 
-void _dynamic_check_timer_handlder (void *FunctionContext)
+static void _dynamic_check_timer_handlder (void *FunctionContext)
 {
 	_adapter *adapter = (_adapter *)FunctionContext;
 
@@ -227,20 +227,20 @@ _func_exit_;
 
 }
 
-void _survey_timer_hdl (void *FunctionContext)
+static void _survey_timer_hdl (void *FunctionContext)
 {
 	_adapter *padapter = (_adapter *)FunctionContext;
 
 	survey_timer_hdl(padapter);
 }
 
-void _link_timer_hdl (void *FunctionContext)
+static void _link_timer_hdl (void *FunctionContext)
 {
 	_adapter *padapter = (_adapter *)FunctionContext;
 	link_timer_hdl(padapter);
 }
 
-void _addba_timer_hdl(void *FunctionContext)
+static void _addba_timer_hdl(void *FunctionContext)
 {
 	struct sta_info *psta = (struct sta_info *)FunctionContext;
 	addba_timer_hdl(psta);
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -33,7 +33,7 @@
 
 #ifdef CONFIG_BR_EXT
 #include <rtw_br_ext.h>
-#endif //CONFIG_BR_EXT
+#endif /* CONFIG_BR_EXT */
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Realtek Wireless Lan Driver");
@@ -41,30 +41,30 @@ MODULE_AUTHOR("Realtek Semiconductor Cor
 MODULE_VERSION(DRIVERVERSION);
 
 /* module param defaults */
-int rtw_chip_version = 0x00;
-int rtw_rfintfs = HWPI;
-int rtw_lbkmode = 0;//RTL8712_AIR_TRX;
-
-
-int rtw_network_mode = Ndis802_11IBSS;//Ndis802_11Infrastructure;//infra, ad-hoc, auto
-//NDIS_802_11_SSID	ssid;
-int rtw_channel = 1;//ad-hoc support requirement
-int rtw_wireless_mode = WIRELESS_11BG_24N;
-int rtw_vrtl_carrier_sense = AUTO_VCS;
-int rtw_vcs_type = RTS_CTS;//*
-int rtw_rts_thresh = 2347;//*
-int rtw_frag_thresh = 2346;//*
-int rtw_preamble = PREAMBLE_LONG;//long, short, auto
-int rtw_scan_mode = 1;//active, passive
-int rtw_adhoc_tx_pwr = 1;
-int rtw_soft_ap = 0;
-//int smart_ps = 1;
+static int rtw_chip_version = 0x00;
+static int rtw_rfintfs = HWPI;
+static int rtw_lbkmode = 0;/* RTL8712_AIR_TRX; */
+
+
+static int rtw_network_mode = Ndis802_11IBSS;
+/* NDIS_802_11_SSID	ssid; */
+static int rtw_channel = 1;/* ad-hoc support requirement */
+static int rtw_wireless_mode = WIRELESS_11BG_24N;
+static int rtw_vrtl_carrier_sense = AUTO_VCS;
+static int rtw_vcs_type = RTS_CTS;/*  */
+static int rtw_rts_thresh = 2347;/*  */
+static int rtw_frag_thresh = 2346;/*  */
+static int rtw_preamble = PREAMBLE_LONG;/* long, short, auto */
+static int rtw_scan_mode = 1;/* active, passive */
+static int rtw_adhoc_tx_pwr = 1;
+static int rtw_soft_ap = 0;
+/* int smart_ps = 1; */
 #ifdef CONFIG_POWER_SAVING
-int rtw_power_mgnt = 1;
+static int rtw_power_mgnt = 1;
 #ifdef CONFIG_IPS_LEVEL_2
-int rtw_ips_mode = IPS_LEVEL_2;
+static int rtw_ips_mode = IPS_LEVEL_2;
 #else
-int rtw_ips_mode = IPS_NORMAL;
+static int rtw_ips_mode = IPS_NORMAL;
 #endif
 #else
 int rtw_power_mgnt = PS_MODE_ACTIVE;
@@ -73,100 +73,99 @@ int rtw_ips_mode = IPS_NONE;
 module_param(rtw_ips_mode, int, 0644);
 MODULE_PARM_DESC(rtw_ips_mode,"The default IPS mode");
 
-int rtw_radio_enable = 1;
-int rtw_long_retry_lmt = 7;
-int rtw_short_retry_lmt = 7;
-int rtw_busy_thresh = 40;
-//int qos_enable = 0; //*
-int rtw_ack_policy = NORMAL_ACK;
+static int rtw_radio_enable = 1;
+static int rtw_long_retry_lmt = 7;
+static int rtw_short_retry_lmt = 7;
+static int rtw_busy_thresh = 40;
+static int rtw_ack_policy = NORMAL_ACK;
 #ifdef CONFIG_MP_INCLUDED
 int rtw_mp_mode = 1;
 #else
-int rtw_mp_mode = 0;
+static int rtw_mp_mode = 0;
 #endif
-int rtw_software_encrypt = 0;
-int rtw_software_decrypt = 0;
+static int rtw_software_encrypt = 0;
+static int rtw_software_decrypt = 0;
 
-int rtw_acm_method = 0;// 0:By SW 1:By HW.
+static int rtw_acm_method = 0;/*  0:By SW 1:By HW. */
 
-int rtw_wmm_enable = 1;// default is set to enable the wmm.
-int rtw_uapsd_enable = 0;
-int rtw_uapsd_max_sp = NO_LIMIT;
-int rtw_uapsd_acbk_en = 0;
-int rtw_uapsd_acbe_en = 0;
-int rtw_uapsd_acvi_en = 0;
-int rtw_uapsd_acvo_en = 0;
+static int rtw_wmm_enable = 1;/*  default is set to enable the wmm. */
+static int rtw_uapsd_enable = 0;
+static int rtw_uapsd_max_sp = NO_LIMIT;
+static int rtw_uapsd_acbk_en = 0;
+static int rtw_uapsd_acbe_en = 0;
+static int rtw_uapsd_acvi_en = 0;
+static int rtw_uapsd_acvo_en = 0;
 
 #ifdef CONFIG_80211N_HT
 int rtw_ht_enable = 1;
-int rtw_cbw40_enable = 3; // 0 :diable, bit(0): enable 2.4g, bit(1): enable 5g
-int rtw_ampdu_enable = 1;//for enable tx_ampdu
-int rtw_rx_stbc = 1;// 0: disable, bit(0):enable 2.4g, bit(1):enable 5g, default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ
-int rtw_ampdu_amsdu = 0;// 0: disabled, 1:enabled, 2:auto
+int rtw_cbw40_enable = 3; /*  0 :diable, bit(0): enable 2.4g, bit(1): enable 5g */
+int rtw_ampdu_enable = 1;/* for enable tx_ampdu */
+static int rtw_rx_stbc = 1;/*  0: disable, bit(0):enable 2.4g, bit(1):enable 5g, default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ */
+static int rtw_ampdu_amsdu = 0;/*  0: disabled, 1:enabled, 2:auto */
 #endif
 
-int rtw_lowrate_two_xmit = 1;//Use 2 path Tx to transmit MCS0~7 and legacy mode
+static int rtw_lowrate_two_xmit = 1;/* Use 2 path Tx to transmit MCS0~7 and legacy mode */
 
-//int rf_config = RF_1T2R;  // 1T2R
-int rtw_rf_config = RF_819X_MAX_TYPE;  //auto
-int rtw_low_power = 0;
+/* int rf_config = RF_1T2R;   1T2R */
+static int rtw_rf_config = RF_819X_MAX_TYPE;  /* auto */
+static int rtw_low_power = 0;
 #ifdef CONFIG_WIFI_TEST
-int rtw_wifi_spec = 1;//for wifi test
+int rtw_wifi_spec = 1;/* for wifi test */
 #else
-int rtw_wifi_spec = 0;
+static int rtw_wifi_spec = 0;
 #endif
 
-int rtw_special_rf_path = 0; //0: 2T2R ,1: only turn on path A 1T1R, 2: only turn on path B 1T1R
+static int rtw_special_rf_path = 0; /* 0: 2T2R , 1: only turn on path A 1T1R, 2: only turn on path B 1T1R */
 
-int rtw_channel_plan = RT_CHANNEL_DOMAIN_MAX;
+static int rtw_channel_plan = RT_CHANNEL_DOMAIN_MAX;
 
 #ifdef CONFIG_BT_COEXIST
-int rtw_bt_iso = 2;// 0:Low, 1:High, 2:From Efuse
-int rtw_bt_sco = 3;// 0:Idle, 1:None-SCO, 2:SCO, 3:From Counter, 4.Busy, 5.OtherBusy
-int rtw_bt_ampdu =1 ;// 0:Disable BT control A-MPDU, 1:Enable BT control A-MPDU.
+int rtw_bt_iso = 2;/*  0:Low, 1:High, 2:From Efuse */
+int rtw_bt_sco = 3;/*  0:Idle, 1:None-SCO, 2:SCO, 3:From Counter, 4.Busy, 5.OtherBusy */
+int rtw_bt_ampdu = 1 ;/*  0:Disable BT control A-MPDU, 1:Enable BT control A-MPDU. */
 #endif
-int rtw_AcceptAddbaReq = _TRUE;// 0:Reject AP's Add BA req, 1:Accept AP's Add BA req.
+static int rtw_AcceptAddbaReq = _TRUE;/*  0:Reject AP's Add BA req, 1:Accept AP's Add BA req. */
 
-int  rtw_antdiv_cfg = 2; // 0:OFF , 1:ON, 2:decide by Efuse config
+static int  rtw_antdiv_cfg = 2; /*  0:OFF , 1:ON, 2:decide by Efuse config */
 
 #ifdef CONFIG_USB_AUTOSUSPEND
-int rtw_enusbss = 1;//0:disable,1:enable
+int rtw_enusbss = 1;/* 0:disable, 1:enable */
 #else
-int rtw_enusbss = 0;//0:disable,1:enable
+static int rtw_enusbss = 0;/* 0:disable, 1:enable */
 #endif
 
-int rtw_hwpdn_mode=2;//0:disable,1:enable,2: by EFUSE config
+static int rtw_hwpdn_mode = 2;/* 0:disable, 1:enable, 2: by EFUSE config */
 
 #ifdef CONFIG_HW_PWRP_DETECTION
 int rtw_hwpwrp_detect = 1;
 #else
-int rtw_hwpwrp_detect = 0; //HW power  ping detect 0:disable , 1:enable
+static int rtw_hwpwrp_detect = 0; /* HW power  ping detect 0:disable , 1:enable */
 #endif
 
-int rtw_hw_wps_pbc = 1;
+static int rtw_hw_wps_pbc = 1;
 
 int rtw_mc2u_disable = 0;
 
-int rtw_mac_phy_mode = 0; //0:by efuse, 1:smsp, 2:dmdp, 3:dmsp.
+int rtw_mac_phy_mode = 0; /* 0:by efuse, 1:smsp, 2:dmdp, 3:dmsp. */
 
 #ifdef CONFIG_80211D
-int rtw_80211d = 0;
+static int rtw_80211d = 0;
 #endif
 
-char* ifname = "wlan%d";
+static char* ifname = "wlan%d";
 module_param(ifname, charp, 0644);
 MODULE_PARM_DESC(ifname, "The default name to allocate for first interface");
 
-char* if2name = "wlan%d";
+static char* if2name = "wlan%d";
 module_param(if2name, charp, 0644);
 MODULE_PARM_DESC(if2name, "The default name to allocate for second interface");
 
-char* rtw_initmac = 0;  // temp mac address if users want to use instead of the mac address in Efuse
+char* rtw_initmac = NULL;  /*  temp mac address if users want to use instead of the mac address in Efuse */
 
 #ifdef CONFIG_MULTI_VIR_IFACES
-int rtw_ext_iface_num  = 1;//primary/secondary iface is excluded
+int rtw_ext_iface_num  = 1;/* primary/secondary iface is excluded */
 module_param(rtw_ext_iface_num, int, 0644);
-#endif //CONFIG_MULTI_VIR_IFACES
+#endif /* CONFIG_MULTI_VIR_IFACES */
 
 module_param(rtw_initmac, charp, 0644);
 module_param(rtw_channel_plan, int, 0644);
@@ -207,28 +206,28 @@ module_param(rtw_hwpwrp_detect, int, 064
 module_param(rtw_hw_wps_pbc, int, 0644);
 
 #ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
-char *rtw_adaptor_info_caching_file_path= "/data/misc/wifi/rtw_cache";
+char *rtw_adaptor_info_caching_file_path = "/data/misc/wifi/rtw_cache";
 module_param(rtw_adaptor_info_caching_file_path, charp, 0644);
 MODULE_PARM_DESC(rtw_adaptor_info_caching_file_path, "The path of adapter info cache file");
-#endif //CONFIG_ADAPTOR_INFO_CACHING_FILE
+#endif /* CONFIG_ADAPTOR_INFO_CACHING_FILE */
 
 #ifdef CONFIG_LAYER2_ROAMING
-uint rtw_max_roaming_times=2;
+static uint rtw_max_roaming_times = 2;
 module_param(rtw_max_roaming_times, uint, 0644);
 MODULE_PARM_DESC(rtw_max_roaming_times,"The max roaming times to try");
-#endif //CONFIG_LAYER2_ROAMING
+#endif /* CONFIG_LAYER2_ROAMING */
 
 #ifdef CONFIG_IOL
-bool rtw_force_iol=_FALSE;
+bool rtw_force_iol = _FALSE;
 module_param(rtw_force_iol, bool, 0644);
 MODULE_PARM_DESC(rtw_force_iol,"Force to enable IOL");
-#endif //CONFIG_IOL
+#endif /* CONFIG_IOL */
 
 #ifdef CONFIG_FILE_FWIMG
-char *rtw_fw_file_path= "";
+char *rtw_fw_file_path = "";
 module_param(rtw_fw_file_path, charp, 0644);
 MODULE_PARM_DESC(rtw_fw_file_path, "The path of fw image");
-#endif //CONFIG_FILE_FWIMG
+#endif /* CONFIG_FILE_FWIMG */
 
 module_param(rtw_mc2u_disable, int, 0644);
 
@@ -238,7 +237,7 @@ module_param(rtw_mac_phy_mode, int, 0644
 module_param(rtw_80211d, int, 0644);
 #endif
 
-uint rtw_notch_filter = RTW_NOTCH_FILTER;
+static uint rtw_notch_filter = RTW_NOTCH_FILTER;
 module_param(rtw_notch_filter, uint, 0644);
 MODULE_PARM_DESC(rtw_notch_filter, "0:Disable, 1:Enable, 2:Enable only for P2P");
 
@@ -259,37 +258,26 @@ static int	rtw_proc_cnt = 0;
 void rtw_proc_init_one(struct net_device *dev)
 {
 	struct proc_dir_entry *dir_dev = NULL;
-	struct proc_dir_entry *entry=NULL;
+	struct proc_dir_entry *entry = NULL;
 	_adapter	*padapter = rtw_netdev_priv(dev);
 	u8 rf_type;
 
-	if(rtw_proc == NULL)
-	{
-		if(padapter->chip_type == RTL8188C_8192C)
-		{
+	if (rtw_proc == NULL) {
+		if (padapter->chip_type == RTL8188C_8192C)
 			_rtw_memcpy(rtw_proc_name, RTL8192C_PROC_NAME, sizeof(RTL8192C_PROC_NAME));
-		}
-		else if(padapter->chip_type == RTL8192D)
-		{
+		else if (padapter->chip_type == RTL8192D)
 			_rtw_memcpy(rtw_proc_name, RTL8192D_PROC_NAME, sizeof(RTL8192D_PROC_NAME));
-		}
-		else if(padapter->chip_type == RTL8723A)
-		{
+		else if (padapter->chip_type == RTL8723A)
 			_rtw_memcpy(rtw_proc_name, RTW_PROC_NAME, sizeof(RTW_PROC_NAME));
-		}
-		else if(padapter->chip_type == RTL8188E)
-		{
+		else if (padapter->chip_type == RTL8188E)
 			_rtw_memcpy(rtw_proc_name, RTW_PROC_NAME, sizeof(RTW_PROC_NAME));
-		}
 		else
-		{
 			_rtw_memcpy(rtw_proc_name, RTW_PROC_NAME, sizeof(RTW_PROC_NAME));
-		}
 
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
-		rtw_proc=create_proc_entry(rtw_proc_name, S_IFDIR, proc_net);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
+		rtw_proc = create_proc_entry(rtw_proc_name, S_IFDIR, proc_net);
 #else
-		rtw_proc=create_proc_entry(rtw_proc_name, S_IFDIR, init_net.proc_net);
+		rtw_proc = create_proc_entry(rtw_proc_name, S_IFDIR, init_net.proc_net);
 #endif
 		if (rtw_proc == NULL) {
 			DBG_871X(KERN_ERR "Unable to create rtw_proc directory\n");
@@ -313,20 +301,17 @@ void rtw_proc_init_one(struct net_device
 
 
 
-	if(padapter->dir_dev == NULL)
-	{
+	if (padapter->dir_dev == NULL) {
 		padapter->dir_dev = create_proc_entry(dev->name,
 					  S_IFDIR | S_IRUGO | S_IXUGO,
 					  rtw_proc);
 
 		dir_dev = padapter->dir_dev;
 
-		if(dir_dev==NULL)
-		{
-			if(rtw_proc_cnt == 0)
-			{
-				if(rtw_proc){
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+		if (dir_dev == NULL) {
+			if (rtw_proc_cnt == 0) {
+				if (rtw_proc) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
 					remove_proc_entry(rtw_proc_name, proc_net);
 #else
 					remove_proc_entry(rtw_proc_name, init_net.proc_net);
@@ -338,9 +323,7 @@ void rtw_proc_init_one(struct net_device
 			DBG_871X("Unable to create dir_dev directory\n");
 			return;
 		}
-	}
-	else
-	{
+	} else {
 		return;
 	}
 
@@ -486,7 +469,7 @@ void rtw_proc_init_one(struct net_device
 	}
 
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-	if((RF_1T2R == rf_type) ||(RF_1T1R ==rf_type ))	{
+	if ((RF_1T2R == rf_type) ||(RF_1T1R == rf_type ))	{
 		entry = create_proc_read_entry("rf_reg_dump3", S_IFREG | S_IRUGO,
 					   dir_dev, proc_get_rf_reg_dump3, dev);
 		if (!entry) {
@@ -595,7 +578,6 @@ void rtw_proc_init_one(struct net_device
 		return;
 	}
 	entry->write_proc = proc_set_rssi_disp;
-
 }
 
 void rtw_proc_remove_one(struct net_device *dev)
@@ -630,7 +612,7 @@ void rtw_proc_remove_one(struct net_devi
 		remove_proc_entry("rf_reg_dump1", dir_dev);
 		remove_proc_entry("rf_reg_dump2", dir_dev);
 		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-		if((RF_1T2R == rf_type) ||(RF_1T1R ==rf_type ))	{
+		if ((RF_1T2R == rf_type) ||(RF_1T1R == rf_type ))	{
 			remove_proc_entry("rf_reg_dump3", dir_dev);
 			remove_proc_entry("rf_reg_dump4", dir_dev);
 		}
@@ -674,13 +656,13 @@ void rtw_proc_remove_one(struct net_devi
 
 	rtw_proc_cnt--;
 
-	if(rtw_proc_cnt == 0)
+	if (rtw_proc_cnt == 0)
 	{
-		if(rtw_proc){
+		if (rtw_proc){
 			remove_proc_entry("ver_info", rtw_proc);
 
 			remove_proc_entry("log_level", rtw_proc);
-#if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
 			remove_proc_entry(rtw_proc_name, proc_net);
 #else
 			remove_proc_entry(rtw_proc_name, init_net.proc_net);
@@ -703,7 +685,7 @@ _func_enter_;
 	registry_par->chip_version = (u8)rtw_chip_version;
 	registry_par->rfintfs = (u8)rtw_rfintfs;
 	registry_par->lbkmode = (u8)rtw_lbkmode;
-	//registry_par->hci = (u8)hci;
+	/* registry_par->hci = (u8)hci; */
 	registry_par->network_mode  = (u8)rtw_network_mode;
 
 	_rtw_memcpy(registry_par->ssid.Ssid, "ANY", 3);
@@ -713,20 +695,20 @@ _func_enter_;
 	registry_par->wireless_mode = (u8)rtw_wireless_mode;
 	registry_par->vrtl_carrier_sense = (u8)rtw_vrtl_carrier_sense ;
 	registry_par->vcs_type = (u8)rtw_vcs_type;
-	registry_par->rts_thresh=(u16)rtw_rts_thresh;
-	registry_par->frag_thresh=(u16)rtw_frag_thresh;
+	registry_par->rts_thresh = (u16)rtw_rts_thresh;
+	registry_par->frag_thresh = (u16)rtw_frag_thresh;
 	registry_par->preamble = (u8)rtw_preamble;
 	registry_par->scan_mode = (u8)rtw_scan_mode;
 	registry_par->adhoc_tx_pwr = (u8)rtw_adhoc_tx_pwr;
-	registry_par->soft_ap=  (u8)rtw_soft_ap;
-	//registry_par->smart_ps =  (u8)rtw_smart_ps;
+	registry_par->soft_ap =  (u8)rtw_soft_ap;
+	/* registry_par->smart_ps =  (u8)rtw_smart_ps; */
 	registry_par->power_mgnt = (u8)rtw_power_mgnt;
 	registry_par->ips_mode = (u8)rtw_ips_mode;
 	registry_par->radio_enable = (u8)rtw_radio_enable;
 	registry_par->long_retry_lmt = (u8)rtw_long_retry_lmt;
 	registry_par->short_retry_lmt = (u8)rtw_short_retry_lmt;
 	registry_par->busy_thresh = (u16)rtw_busy_thresh;
-	//registry_par->qos_enable = (u8)rtw_qos_enable;
+	/* registry_par->qos_enable = (u8)rtw_qos_enable; */
 	registry_par->ack_policy = (u8)rtw_ack_policy;
 	registry_par->mp_mode = (u8)rtw_mp_mode;
 	registry_par->software_encrypt = (u8)rtw_software_encrypt;
@@ -734,7 +716,7 @@ _func_enter_;
 
 	registry_par->acm_method = (u8)rtw_acm_method;
 
-	 //UAPSD
+	 /* UAPSD */
 	registry_par->wmm_enable = (u8)rtw_wmm_enable;
 	registry_par->uapsd_enable = (u8)rtw_uapsd_enable;
 	registry_par->uapsd_max_sp = (u8)rtw_uapsd_max_sp;
@@ -770,25 +752,25 @@ _func_enter_;
 	registry_par->antdiv_cfg = (u8)rtw_antdiv_cfg;
 
 #ifdef CONFIG_AUTOSUSPEND
-	registry_par->usbss_enable = (u8)rtw_enusbss;//0:disable,1:enable
+	registry_par->usbss_enable = (u8)rtw_enusbss;/* 0:disable, 1:enable */
 #endif
 #ifdef SUPPORT_HW_RFOFF_DETECTED
-	registry_par->hwpdn_mode = (u8)rtw_hwpdn_mode;//0:disable,1:enable,2:by EFUSE config
-	registry_par->hwpwrp_detect = (u8)rtw_hwpwrp_detect;//0:disable,1:enable
+	registry_par->hwpdn_mode = (u8)rtw_hwpdn_mode;/* 0:disable, 1:enable, 2:by EFUSE config */
+	registry_par->hwpwrp_detect = (u8)rtw_hwpwrp_detect;/* 0:disable, 1:enable */
 #endif
 
 	registry_par->hw_wps_pbc = (u8)rtw_hw_wps_pbc;
 
 #ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
 	snprintf(registry_par->adaptor_info_caching_file_path, PATH_LENGTH_MAX, "%s", rtw_adaptor_info_caching_file_path);
-	registry_par->adaptor_info_caching_file_path[PATH_LENGTH_MAX-1]=0;
+	registry_par->adaptor_info_caching_file_path[PATH_LENGTH_MAX-1]= 0;
 #endif
 
 #ifdef CONFIG_LAYER2_ROAMING
 	registry_par->max_roaming_times = (u8)rtw_max_roaming_times;
 #ifdef CONFIG_INTEL_WIDI
 	registry_par->max_roaming_times = (u8)rtw_max_roaming_times + 2;
-#endif // CONFIG_INTEL_WIDI
+#endif /*  CONFIG_INTEL_WIDI */
 #endif
 
 #ifdef CONFIG_IOL
@@ -808,7 +790,7 @@ _func_enter_;
 
 #ifdef CONFIG_MULTI_VIR_IFACES
 	registry_par->ext_iface_num = (u8)rtw_ext_iface_num;
-#endif //CONFIG_MULTI_VIR_IFACES
+#endif /* CONFIG_MULTI_VIR_IFACES */
 
 _func_exit_;
 
@@ -820,13 +802,10 @@ static int rtw_net_set_mac_address(struc
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
 	struct sockaddr *addr = p;
 
-	if(padapter->bup == _FALSE)
+	if (padapter->bup == _FALSE)
 	{
-		//DBG_871X("r8711_net_set_mac_address(), MAC=%x:%x:%x:%x:%x:%x\n", addr->sa_data[0], addr->sa_data[1], addr->sa_data[2], addr->sa_data[3],
-		//addr->sa_data[4], addr->sa_data[5]);
+		/* addr->sa_data[4], addr->sa_data[5]); */
 		_rtw_memcpy(padapter->eeprompriv.mac_addr, addr->sa_data, ETH_ALEN);
-		//_rtw_memcpy(pnetdev->dev_addr, addr->sa_data, ETH_ALEN);
-		//padapter->bset_hwaddr = _TRUE;
 	}
 
 	return 0;
@@ -838,8 +817,8 @@ static struct net_device_stats *rtw_net_
 	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
 	struct recv_priv *precvpriv = &(padapter->recvpriv);
 
-	padapter->stats.tx_packets = pxmitpriv->tx_pkts;//pxmitpriv->tx_pkts++;
-	padapter->stats.rx_packets = precvpriv->rx_pkts;//precvpriv->rx_pkts++;
+	padapter->stats.tx_packets = pxmitpriv->tx_pkts;/* pxmitpriv->tx_pkts++; */
+	padapter->stats.rx_packets = precvpriv->rx_pkts;/* precvpriv->rx_pkts++; */
 	padapter->stats.tx_dropped = pxmitpriv->tx_drop;
 	padapter->stats.rx_dropped = precvpriv->rx_drop;
 	padapter->stats.tx_bytes = pxmitpriv->tx_bytes;
@@ -848,7 +827,7 @@ static struct net_device_stats *rtw_net_
 	return &padapter->stats;
 }
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 35))
 /*
  * AC to queue mapping
  *
@@ -860,7 +839,7 @@ static struct net_device_stats *rtw_net_
 static const u16 rtw_1d_to_queue[8] = { 2, 3, 3, 2, 1, 1, 0, 0 };
 
 /* Given a data frame determine the 802.1p/1d tag to use. */
-unsigned int rtw_classify8021d(struct sk_buff *skb)
+static unsigned int rtw_classify8021d(struct sk_buff *skb)
 {
 	unsigned int dscp;
 
@@ -890,7 +869,7 @@ static u16 rtw_select_queue(struct net_d
 
 	skb->priority = rtw_classify8021d(skb);
 
-	if(pmlmepriv->acm_mask != 0)
+	if (pmlmepriv->acm_mask != 0)
 	{
 		skb->priority = qos_acm(pmlmepriv->acm_mask, skb->priority);
 	}
@@ -928,12 +907,12 @@ u16 rtw_recv_select_queue(struct sk_buff
 
 #endif
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
 static const struct net_device_ops rtw_netdev_ops = {
 	.ndo_open = netdev_open,
 	.ndo_stop = netdev_close,
 	.ndo_start_xmit = rtw_xmit_entry,
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 35))
 	.ndo_select_queue	= rtw_select_queue,
 #endif
 	.ndo_set_mac_address = rtw_net_set_mac_address,
@@ -951,19 +930,19 @@ int rtw_init_netdev_name(struct net_devi
 	_adapter			*TargetAdapter = NULL;
 	struct net		*devnet = NULL;
 
-	if(padapter->bDongle == 1)
+	if (padapter->bDongle == 1)
 	{
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
 		TargetNetdev = dev_get_by_name("wlan0");
 #else
-	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
 		devnet = pnetdev->nd_net;
 	#else
 		devnet = dev_net(pnetdev);
 	#endif
 		TargetNetdev = dev_get_by_name(devnet, "wlan0");
 #endif
-		if(TargetNetdev) {
+		if (TargetNetdev) {
 			DBG_871X("Force onboard module driver disappear !!!\n");
 			TargetAdapter = rtw_netdev_priv(TargetNetdev);
 			TargetAdapter->DriverState = DRIVER_DISAPPEAR;
@@ -975,7 +954,7 @@ int rtw_init_netdev_name(struct net_devi
 			dev_put(TargetNetdev);
 			unregister_netdev(TargetNetdev);
 
-			if(TargetAdapter->chip_type == padapter->chip_type)
+			if (TargetAdapter->chip_type == padapter->chip_type)
 				rtw_proc_remove_one(TargetNetdev);
 
 			padapter->DriverState = DRIVER_REPLACE_DONGLE;
@@ -983,14 +962,12 @@ int rtw_init_netdev_name(struct net_devi
 	}
 #endif
 
-	if(dev_alloc_name(pnetdev, ifname) < 0)
+	if (dev_alloc_name(pnetdev, ifname) < 0)
 	{
-		RT_TRACE(_module_os_intfs_c_,_drv_err_,("dev_alloc_name, fail! \n"));
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("dev_alloc_name, fail! \n"));
 	}
 
 	netif_carrier_off(pnetdev);
-	//rtw_netif_stop_queue(pnetdev);
-
 	return 0;
 }
 
@@ -999,9 +976,9 @@ struct net_device *rtw_init_netdev(_adap
 	_adapter *padapter;
 	struct net_device *pnetdev;
 
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+init_net_dev\n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+init_net_dev\n"));
 
-	if(old_padapter != NULL)
+	if (old_padapter != NULL)
 		pnetdev = rtw_alloc_etherdev_with_old_priv(sizeof(_adapter), (void *)old_padapter);
 	else
 		pnetdev = rtw_alloc_etherdev(sizeof(_adapter));
@@ -1012,13 +989,11 @@ struct net_device *rtw_init_netdev(_adap
 	padapter = rtw_netdev_priv(pnetdev);
 	padapter->pnetdev = pnetdev;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
 	SET_MODULE_OWNER(pnetdev);
 #endif
 
-	//pnetdev->init = NULL;
-
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
 	DBG_871X("register rtw_netdev_ops to netdev_ops\n");
 	pnetdev->netdev_ops = &rtw_netdev_ops;
 #else
@@ -1034,18 +1009,12 @@ struct net_device *rtw_init_netdev(_adap
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
 	pnetdev->features |= NETIF_F_IP_CSUM;
 #endif
-	//pnetdev->tx_timeout = NULL;
 	pnetdev->watchdog_timeo = HZ*3; /* 3 second timeout */
 #ifdef CONFIG_WIRELESS_EXT
 	pnetdev->wireless_handlers = (struct iw_handler_def *)&rtw_handlers_def;
 #endif
 
-#ifdef WIRELESS_SPY
-	//priv->wireless_data.spy_data = &priv->spy_data;
-	//pnetdev->wireless_data = &priv->wireless_data;
-#endif
-
-	//step 2.
+	/* step 2. */
 	loadparam(padapter, pnetdev);
 
 	return pnetdev;
@@ -1057,34 +1026,34 @@ u32 rtw_start_drv_threads(_adapter *pada
 
 	u32 _status = _SUCCESS;
 
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_start_drv_threads\n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_start_drv_threads\n"));
 #ifdef CONFIG_XMIT_THREAD_MODE
 	padapter->xmitThread = kthread_run(rtw_xmit_thread, padapter, "RTW_XMIT_THREAD");
-	if(IS_ERR(padapter->xmitThread))
+	if (IS_ERR(padapter->xmitThread))
 		_status = _FAIL;
 #endif
 
 #ifdef CONFIG_RECV_THREAD_MODE
 	padapter->recvThread = kthread_run(rtw_recv_thread, padapter, "RTW_RECV_THREAD");
-	if(IS_ERR(padapter->recvThread))
+	if (IS_ERR(padapter->recvThread))
 		_status = _FAIL;
 #endif
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->isprimary == _TRUE)
-#endif //CONFIG_CONCURRENT_MODE
+	if (padapter->isprimary == _TRUE)
+#endif /* CONFIG_CONCURRENT_MODE */
 	{
 		padapter->cmdThread = kthread_run(rtw_cmd_thread, padapter, "RTW_CMD_THREAD");
-		if(IS_ERR(padapter->cmdThread))
+		if (IS_ERR(padapter->cmdThread))
 			_status = _FAIL;
 		else
-			_rtw_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema); //wait for cmd_thread to run
+			_rtw_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema); /* wait for cmd_thread to run */
 	}
 
 
 #ifdef CONFIG_EVENT_THREAD_MODE
 	padapter->evtThread = kthread_run(event_thread, padapter, "RTW_EVENT_THREAD");
-	if(IS_ERR(padapter->evtThread))
+	if (IS_ERR(padapter->evtThread))
 		_status = _FAIL;
 #endif
 
@@ -1094,39 +1063,38 @@ u32 rtw_start_drv_threads(_adapter *pada
 
 void rtw_stop_drv_threads (_adapter *padapter)
 {
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_stop_drv_threads\n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_stop_drv_threads\n"));
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->isprimary == _TRUE)
-#endif //CONFIG_CONCURRENT_MODE
+	if (padapter->isprimary == _TRUE)
+#endif /* CONFIG_CONCURRENT_MODE */
 	{
-		//Below is to termindate rtw_cmd_thread & event_thread...
+		/* Below is to termindate rtw_cmd_thread & event_thread... */
 		_rtw_up_sema(&padapter->cmdpriv.cmd_queue_sema);
-		//_rtw_up_sema(&padapter->cmdpriv.cmd_done_sema);
-		if(padapter->cmdThread){
+		if (padapter->cmdThread){
 			_rtw_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema);
 		}
 	}
 
 #ifdef CONFIG_EVENT_THREAD_MODE
         _rtw_up_sema(&padapter->evtpriv.evt_notify);
-	if(padapter->evtThread){
+	if (padapter->evtThread){
 		_rtw_down_sema(&padapter->evtpriv.terminate_evtthread_sema);
 	}
 #endif
 
 #ifdef CONFIG_XMIT_THREAD_MODE
-	// Below is to termindate tx_thread...
+	/*  Below is to termindate tx_thread... */
 	_rtw_up_sema(&padapter->xmitpriv.xmit_sema);
 	_rtw_down_sema(&padapter->xmitpriv.terminate_xmitthread_sema);
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("\n drv_halt: rtw_xmit_thread can be terminated ! \n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("\n drv_halt: rtw_xmit_thread can be terminated ! \n"));
 #endif
 
 #ifdef CONFIG_RECV_THREAD_MODE
-	// Below is to termindate rx_thread...
+	/*  Below is to termindate rx_thread... */
 	_rtw_up_sema(&padapter->recvpriv.recv_sema);
 	_rtw_down_sema(&padapter->recvpriv.terminate_recvthread_sema);
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("\n drv_halt:recv_thread can be terminated! \n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("\n drv_halt:recv_thread can be terminated! \n"));
 #endif
 
 
@@ -1138,40 +1106,37 @@ u8 rtw_init_default_value(_adapter *pada
 	u8 ret  = _SUCCESS;
 	struct registry_priv* pregistrypriv = &padapter->registrypriv;
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
-	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 
-	//xmit_priv
+	/* xmit_priv */
 	pxmitpriv->vcs_setting = pregistrypriv->vrtl_carrier_sense;
 	pxmitpriv->vcs = pregistrypriv->vcs_type;
 	pxmitpriv->vcs_type = pregistrypriv->vcs_type;
-	//pxmitpriv->rts_thresh = pregistrypriv->rts_thresh;
 	pxmitpriv->frag_len = pregistrypriv->frag_thresh;
 
 
 
-	//recv_priv
+	/* recv_priv */
 
 
-	//mlme_priv
-	pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
+	/* mlme_priv */
+	pmlmepriv->scan_interval = SCAN_INTERVAL;/*  30*2 sec = 60sec */
 	pmlmepriv->scan_mode = SCAN_ACTIVE;
 
-	//qos_priv
-	//pmlmepriv->qospriv.qos_option = pregistrypriv->wmm_enable;
+	/* qos_priv */
 
-	//ht_priv
+	/* ht_priv */
 #ifdef CONFIG_80211N_HT
-	pmlmepriv->htpriv.ampdu_enable = _FALSE;//set to disabled
+	pmlmepriv->htpriv.ampdu_enable = _FALSE;/* set to disabled */
 #endif
 
-	//security_priv
-	//rtw_get_encrypt_decrypt_from_registrypriv(padapter);
+	/* security_priv */
 	psecuritypriv->binstallGrpkey = _FAIL;
-	psecuritypriv->sw_encrypt=pregistrypriv->software_encrypt;
-	psecuritypriv->sw_decrypt=pregistrypriv->software_decrypt;
+	psecuritypriv->sw_encrypt = pregistrypriv->software_encrypt;
+	psecuritypriv->sw_decrypt = pregistrypriv->software_decrypt;
 
-	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; //open system
+	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
 	psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
 
 	psecuritypriv->dot11PrivacyKeyIndex = 0;
@@ -1183,18 +1148,18 @@ u8 rtw_init_default_value(_adapter *pada
 	psecuritypriv->ndisencryptstatus = Ndis802_11WEPDisabled;
 
 
-	//pwrctrl_priv
+	/* pwrctrl_priv */
 
 
-	//registry_priv
+	/* registry_priv */
 	rtw_init_registrypriv_dev_network(padapter);
 	rtw_update_registrypriv_dev_network(padapter);
 
 
-	//hal_priv
+	/* hal_priv */
 	rtw_hal_def_value_init(padapter);
 
-	//misc.
+	/* misc. */
 	padapter->bReadPortCancel = _FALSE;
 	padapter->bWritePortCancel = _FALSE;
 	padapter->bRxRSSIDisplay = 0;
@@ -1208,16 +1173,16 @@ u8 rtw_init_default_value(_adapter *pada
 
 u8 rtw_reset_drv_sw(_adapter *padapter)
 {
-	u8	ret8=_SUCCESS;
-	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
+	u8	ret8 = _SUCCESS;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 
-	//hal_priv
+	/* hal_priv */
 	rtw_hal_def_value_init(padapter);
 	padapter->bReadPortCancel = _FALSE;
 	padapter->bWritePortCancel = _FALSE;
 	padapter->bRxRSSIDisplay = 0;
-	pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
+	pmlmepriv->scan_interval = SCAN_INTERVAL;/*  30*2 sec = 60sec */
 
 	pwrctrlpriv->bips_processing = _FALSE;
 	pwrctrlpriv->rf_pwrstate = rf_on;
@@ -1230,8 +1195,8 @@ u8 rtw_reset_drv_sw(_adapter *padapter)
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY |_FW_UNDER_LINKING);
 
 #ifdef CONFIG_AUTOSUSPEND
-	#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,34))
-		adapter_to_dvobj(padapter)->pusbdev->autosuspend_disabled = 1;//autosuspend disabled by the user
+	#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 22) && LINUX_VERSION_CODE<= KERNEL_VERSION(2, 6, 34))
+		adapter_to_dvobj(padapter)->pusbdev->autosuspend_disabled = 1;/* autosuspend disabled by the user */
 	#endif
 #endif
 
@@ -1240,8 +1205,8 @@ u8 rtw_reset_drv_sw(_adapter *padapter)
 #endif
 	pwrctrlpriv->pwr_state_check_cnts = 0;
 
-	//mlmeextpriv
-	padapter->mlmeextpriv.sitesurvey_res.state= SCAN_DISABLE;
+	/* mlmeextpriv */
+	padapter->mlmeextpriv.sitesurvey_res.state = SCAN_DISABLE;
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	rtw_set_signal_stat_timer(&padapter->recvpriv);
@@ -1254,33 +1219,33 @@ u8 rtw_reset_drv_sw(_adapter *padapter)
 u8 rtw_init_drv_sw(_adapter *padapter)
 {
 
-	u8	ret8=_SUCCESS;
+	u8	ret8 = _SUCCESS;
 
 _func_enter_;
 
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_init_drv_sw\n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_init_drv_sw\n"));
 
 	if ((rtw_init_cmd_priv(&padapter->cmdpriv)) == _FAIL)
 	{
-		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init cmd_priv\n"));
-		ret8=_FAIL;
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init cmd_priv\n"));
+		ret8 = _FAIL;
 		goto exit;
 	}
 
-	padapter->cmdpriv.padapter=padapter;
+	padapter->cmdpriv.padapter = padapter;
 
 	if ((rtw_init_evt_priv(&padapter->evtpriv)) == _FAIL)
 	{
-		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init evt_priv\n"));
-		ret8=_FAIL;
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init evt_priv\n"));
+		ret8 = _FAIL;
 		goto exit;
 	}
 
 
 	if (rtw_init_mlme_priv(padapter) == _FAIL)
 	{
-		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init mlme_priv\n"));
-		ret8=_FAIL;
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init mlme_priv\n"));
+		ret8 = _FAIL;
 		goto exit;
 	}
 
@@ -1292,50 +1257,47 @@ _func_enter_;
 	rtw_init_cfg80211_wifidirect_info(padapter);
 	#endif
 #ifdef CONFIG_WFD
-	if(rtw_init_wifi_display_info(padapter) == _FAIL)
-		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init init_wifi_display_info\n"));
+	if (rtw_init_wifi_display_info(padapter) == _FAIL)
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init init_wifi_display_info\n"));
 #endif
 #endif /* CONFIG_P2P */
 
-	if(init_mlme_ext_priv(padapter) == _FAIL)
+	if (init_mlme_ext_priv(padapter) == _FAIL)
 	{
-		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't init mlme_ext_priv\n"));
-		ret8=_FAIL;
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init mlme_ext_priv\n"));
+		ret8 = _FAIL;
 		goto exit;
 	}
 
 #ifdef CONFIG_TDLS
-	if(rtw_init_tdls_info(padapter) == _FAIL)
+	if (rtw_init_tdls_info(padapter) == _FAIL)
 	{
 		DBG_871X("Can't rtw_init_tdls_info\n");
-		ret8=_FAIL;
+		ret8 = _FAIL;
 		goto exit;
 	}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
-	if(_rtw_init_xmit_priv(&padapter->xmitpriv, padapter) == _FAIL)
+	if (_rtw_init_xmit_priv(&padapter->xmitpriv, padapter) == _FAIL)
 	{
 		DBG_871X("Can't _rtw_init_xmit_priv\n");
-		ret8=_FAIL;
+		ret8 = _FAIL;
 		goto exit;
 	}
 
-	if(_rtw_init_recv_priv(&padapter->recvpriv, padapter) == _FAIL)
+	if (_rtw_init_recv_priv(&padapter->recvpriv, padapter) == _FAIL)
 	{
 		DBG_871X("Can't _rtw_init_recv_priv\n");
-		ret8=_FAIL;
+		ret8 = _FAIL;
 		goto exit;
 	}
 
-	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
-	//_rtw_memset((unsigned char *)&padapter->securitypriv, 0, sizeof (struct security_priv));
+	/*  We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc(). */
 
-	//_init_timer(&(padapter->securitypriv.tkip_timer), padapter->pifp, rtw_use_tkipkey_handler, padapter);
-
-	if(_rtw_init_sta_priv(&padapter->stapriv) == _FAIL)
+	if (_rtw_init_sta_priv(&padapter->stapriv) == _FAIL)
 	{
 		DBG_871X("Can't _rtw_init_sta_priv\n");
-		ret8=_FAIL;
+		ret8 = _FAIL;
 		goto exit;
 	}
 
@@ -1345,8 +1307,6 @@ _func_enter_;
 
 	rtw_init_pwrctrl_priv(padapter);
 
-	//_rtw_memset((u8 *)&padapter->qospriv, 0, sizeof (struct qos_priv));//move to mlme_priv
-
 #ifdef CONFIG_MP_INCLUDED
 	if (init_mp_priv(padapter) == _FAIL) {
 		DBG_871X("%s: initialize MP private data Fail!\n", __func__);
@@ -1363,21 +1323,21 @@ _func_enter_;
 #endif
 
 #ifdef CONFIG_INTEL_WIDI
-	if(rtw_init_intel_widi(padapter) == _FAIL)
+	if (rtw_init_intel_widi(padapter) == _FAIL)
 	{
 		DBG_871X("Can't rtw_init_intel_widi\n");
-		ret8=_FAIL;
+		ret8 = _FAIL;
 		goto exit;
 	}
-#endif //CONFIG_INTEL_WIDI
+#endif /* CONFIG_INTEL_WIDI */
 
 #ifdef CONFIG_BR_EXT
 	_rtw_spinlock_init(&padapter->br_ext_lock);
-#endif	// CONFIG_BR_EXT
+#endif	/*  CONFIG_BR_EXT */
 
 exit:
 
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-rtw_init_drv_sw\n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-rtw_init_drv_sw\n"));
 
 	_func_exit_;
 
@@ -1387,66 +1347,63 @@ exit:
 
 void rtw_cancel_all_timer(_adapter *padapter)
 {
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+rtw_cancel_all_timer\n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_cancel_all_timer\n"));
 
 	_cancel_timer_ex(&padapter->mlmepriv.assoc_timer);
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel association timer complete! \n"));
-
-	//_cancel_timer_ex(&padapter->securitypriv.tkip_timer);
-	//RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel tkip_timer! \n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel association timer complete! \n"));
 
 	_cancel_timer_ex(&padapter->mlmepriv.scan_to_timer);
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel scan_to_timer! \n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel scan_to_timer! \n"));
 
 	_cancel_timer_ex(&padapter->mlmepriv.dynamic_chk_timer);
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel dynamic_chk_timer! \n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel dynamic_chk_timer! \n"));
 
-	// cancel sw led timer
+	/*  cancel sw led timer */
 	rtw_hal_sw_led_deinit(padapter);
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel DeInitSwLeds! \n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel DeInitSwLeds! \n"));
 
 	_cancel_timer_ex(&padapter->pwrctrlpriv.pwr_state_check_timer);
 
 #ifdef CONFIG_IOCTL_CFG80211
 #ifdef CONFIG_P2P
 	_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
-#endif //CONFIG_P2P
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_P2P */
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 #ifdef CONFIG_SET_SCAN_DENY_TIMER
 	_cancel_timer_ex(&padapter->mlmepriv.set_scan_deny_timer);
 	rtw_clear_scan_deny(padapter);
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel set_scan_deny_timer! \n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel set_scan_deny_timer! \n"));
 #endif
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	_cancel_timer_ex(&padapter->recvpriv.signal_stat_timer);
 #endif
 
-	// cancel dm  timer
+	/*  cancel dm  timer */
 	rtw_hal_dm_deinit(padapter);
 
 }
 
 u8 rtw_free_drv_sw(_adapter *padapter)
 {
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("==>rtw_free_drv_sw"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("==>rtw_free_drv_sw"));
 
 
-	//we can call rtw_p2p_enable here, but:
-	// 1. rtw_p2p_enable may have IO operation
-	// 2. rtw_p2p_enable is bundled with wext interface
+	/* we can call rtw_p2p_enable here, but: */
+	/*  1. rtw_p2p_enable may have IO operation */
+	/*  2. rtw_p2p_enable is bundled with wext interface */
 	#ifdef CONFIG_P2P
 	{
 		struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
+		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
 			_cancel_timer_ex( &pwdinfo->find_phase_timer );
 			_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
 			_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
 #ifdef CONFIG_CONCURRENT_MODE
 			_cancel_timer_ex( &pwdinfo->ap_p2p_switch_timer );
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
 		}
 	}
@@ -1455,57 +1412,49 @@ u8 rtw_free_drv_sw(_adapter *padapter)
 
 #ifdef CONFIG_BR_EXT
 	_rtw_spinlock_free(&padapter->br_ext_lock);
-#endif	// CONFIG_BR_EXT
+#endif	/*  CONFIG_BR_EXT */
 
 #ifdef CONFIG_INTEL_WIDI
 	rtw_free_intel_widi(padapter);
-#endif //CONFIG_INTEL_WIDI
+#endif /* CONFIG_INTEL_WIDI */
 
 	free_mlme_ext_priv(&padapter->mlmeextpriv);
 
-#ifdef CONFIG_TDLS
-	//rtw_free_tdls_info(&padapter->tdlsinfo);
-#endif //CONFIG_TDLS
-
 	rtw_free_cmd_priv(&padapter->cmdpriv);
 
 	rtw_free_evt_priv(&padapter->evtpriv);
 
 	rtw_free_mlme_priv(&padapter->mlmepriv);
 
-	//free_io_queue(padapter);
-
 	_rtw_free_xmit_priv(&padapter->xmitpriv);
 
-	_rtw_free_sta_priv(&padapter->stapriv); //will free bcmc_stainfo here
+	_rtw_free_sta_priv(&padapter->stapriv); /* will free bcmc_stainfo here */
 
 	_rtw_free_recv_priv(&padapter->recvpriv);
 
 	rtw_free_pwrctrl_priv(padapter);
 
-	//rtw_mfree((void *)padapter, sizeof (padapter));
-
 #ifdef CONFIG_DRVEXT_MODULE
 	free_drvext(&padapter->drvextpriv);
 #endif
 
 	rtw_hal_free_data(padapter);
 
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("<==rtw_free_drv_sw\n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("<== rtw_free_drv_sw\n"));
 
-	//free the old_pnetdev
-	if(padapter->rereg_nd_name_priv.old_pnetdev) {
+	/* free the old_pnetdev */
+	if (padapter->rereg_nd_name_priv.old_pnetdev) {
 		free_netdev(padapter->rereg_nd_name_priv.old_pnetdev);
 		padapter->rereg_nd_name_priv.old_pnetdev = NULL;
 	}
 
-	// clear pbuddy_adapter to avoid access wrong pointer.
-	if(padapter->pbuddy_adapter != NULL)
+	/*  clear pbuddy_adapter to avoid access wrong pointer. */
+	if (padapter->pbuddy_adapter != NULL)
 	{
 		padapter->pbuddy_adapter->pbuddy_adapter = NULL;
 	}
 
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-rtw_free_drv_sw\n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-rtw_free_drv_sw\n"));
 
 	return _SUCCESS;
 
@@ -1523,15 +1472,15 @@ int _netdev_vir_if_open(struct net_devic
 
 	DBG_871X(FUNC_NDEV_FMT" enter\n", FUNC_NDEV_ARG(pnetdev));
 
-	if(!primary_padapter)
+	if (!primary_padapter)
 		goto _netdev_virtual_iface_open_error;
 
-	if(primary_padapter->bup == _FALSE || primary_padapter->hw_init_completed == _FALSE)
+	if (primary_padapter->bup == _FALSE || primary_padapter->hw_init_completed == _FALSE)
 	{
 		_netdev_open(primary_padapter->pnetdev);
 	}
 
-	if(padapter->bup == _FALSE && primary_padapter->bup == _TRUE &&
+	if (padapter->bup == _FALSE && primary_padapter->bup == _TRUE &&
 		primary_padapter->hw_init_completed == _TRUE)
 	{
 		int i;
@@ -1544,7 +1493,7 @@ int _netdev_vir_if_open(struct net_devic
 
 		padapter->bFWReady = primary_padapter->bFWReady;
 
-		if(rtw_start_drv_threads(padapter) == _FAIL)
+		if (rtw_start_drv_threads(padapter) == _FAIL)
 		{
 			goto _netdev_virtual_iface_open_error;
 		}
@@ -1559,7 +1508,7 @@ int _netdev_vir_if_open(struct net_devic
 		padapter->bup = _TRUE;
 		padapter->hw_init_completed = _TRUE;
 
-		rtw_start_mbssid_cam(padapter);//start mbssid_cam after bup = _TRUE & hw_init_completed = _TRUE
+		rtw_start_mbssid_cam(padapter);/* start mbssid_cam after bup = _TRUE & hw_init_completed = _TRUE */
 
 	}
 
@@ -1567,7 +1516,7 @@ int _netdev_vir_if_open(struct net_devic
 
 	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
 
-	if(!rtw_netif_queue_stopped(pnetdev))
+	if (!rtw_netif_queue_stopped(pnetdev))
 		rtw_netif_start_queue(pnetdev);
 	else
 		rtw_netif_wake_queue(pnetdev);
@@ -1604,7 +1553,7 @@ static int netdev_vir_if_close(struct ne
 
 	padapter->net_closed = _TRUE;
 
-	if(pnetdev)
+	if (pnetdev)
 	{
 		if (!rtw_netif_queue_stopped(pnetdev))
 			rtw_netif_stop_queue(pnetdev);
@@ -1618,7 +1567,7 @@ static int netdev_vir_if_close(struct ne
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
 static const struct net_device_ops rtw_netdev_vir_if_ops = {
 	 .ndo_open = netdev_vir_if_open,
         .ndo_stop = netdev_vir_if_close,
@@ -1626,13 +1575,13 @@ static const struct net_device_ops rtw_n
         .ndo_set_mac_address = rtw_net_set_mac_address,
         .ndo_get_stats = rtw_net_get_stats,
         .ndo_do_ioctl = rtw_ioctl,
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 35))
 	.ndo_select_queue	= rtw_select_queue,
 #endif
 };
 #endif
 
-_adapter *rtw_drv_add_vir_if(_adapter *primary_padapter, char *name,
+_adapter *rtw_drv_add_vir_if (_adapter *primary_padapter, char *name,
 	void (*set_intf_ops)(struct _io_ops *pops))
 {
 
@@ -1643,7 +1592,7 @@ _adapter *rtw_drv_add_vir_if(_adapter *p
 	u8 mac[ETH_ALEN];
 
 /*
-	if((primary_padapter->bup == _FALSE) ||
+	if ((primary_padapter->bup == _FALSE) ||
 		(rtw_buddy_adapter_up(primary_padapter) == _FALSE))
 	{
 		goto error_rtw_drv_add_iface;
@@ -1655,7 +1604,7 @@ _adapter *rtw_drv_add_vir_if(_adapter *p
 	if (!pnetdev)
 		goto error_rtw_drv_add_iface;
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
 	DBG_871X("register rtw_netdev_virtual_iface_ops to netdev_ops\n");
 	pnetdev->netdev_ops = &rtw_netdev_vir_if_ops;
 #else
@@ -1671,28 +1620,20 @@ _adapter *rtw_drv_add_vir_if(_adapter *p
 	padapter = rtw_netdev_priv(pnetdev);
 	_rtw_memcpy(padapter, primary_padapter, sizeof(_adapter));
 
-	//
+	/*  */
 	padapter->bup = _FALSE;
 	padapter->net_closed = _TRUE;
 	padapter->hw_init_completed = _FALSE;
 
 
-	//set adapter_type/iface type
+	/* set adapter_type/iface type */
 	padapter->isprimary = _FALSE;
 	padapter->adapter_type = MAX_ADAPTER;
 	padapter->pbuddy_adapter = primary_padapter;
 	pr_debug("pbuddy_adapter: %p\n", primary_padapter);
-#if 0
-#ifndef CONFIG_HWPORT_SWAP	//Port0 -> Pri , Port1 -> Sec
-	padapter->iface_type = IFACE_PORT1;
-#else
-	padapter->iface_type = IFACE_PORT0;
-#endif  //CONFIG_HWPORT_SWAP
-#else
-	//extended virtual interfaces always are set to port0
+	/* extended virtual interfaces always are set to port0 */
 	padapter->iface_type = IFACE_PORT0;
-#endif
-	//
+	/*  */
 	padapter->pnetdev = pnetdev;
 
 	/****** setup dvobj ******/
@@ -1703,14 +1644,14 @@ _adapter *rtw_drv_add_vir_if(_adapter *p
 	SET_NETDEV_DEV(pnetdev, dvobj_to_dev(pdvobjpriv));
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_wdev_alloc(padapter, dvobj_to_dev(pdvobjpriv));
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
-	//set interface_type/chip_type/HardwareType
+	/* set interface_type/chip_type/HardwareType */
 	padapter->interface_type = primary_padapter->interface_type;
 	padapter->chip_type = primary_padapter->chip_type;
 	padapter->HardwareType = primary_padapter->HardwareType;
 
-	//set hal data & hal ops
+	/* set hal data & hal ops */
 	rtl8192du_set_hal_ops(padapter);
 
 	padapter->HalFunc.inirp_init = NULL;
@@ -1718,35 +1659,35 @@ _adapter *rtw_drv_add_vir_if(_adapter *p
 	padapter->intf_start = NULL;
 	padapter->intf_stop = NULL;
 
-	//step init_io_priv
+	/* step init_io_priv */
 	if ((rtw_init_io_priv(padapter, set_intf_ops)) == _FAIL) {
-		RT_TRACE(_module_hci_intfs_c_,_drv_err_,(" \n Can't init io_reqs\n"));
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, (" \n Can't init io_reqs\n"));
 	}
 
-	//step read_chip_version
+	/* step read_chip_version */
 	rtw_hal_read_chip_version(padapter);
 
-	//step usb endpoint mapping
+	/* step usb endpoint mapping */
 	rtw_hal_chip_configure(padapter);
 
 
-	//init drv data
-	if(rtw_init_drv_sw(padapter)!= _SUCCESS)
+	/* init drv data */
+	if (rtw_init_drv_sw(padapter)!= _SUCCESS)
 		goto error_rtw_drv_add_iface;
 
 
-	// alloc dev name after got efuse data.
-	if(name == NULL)
+	/*  alloc dev name after got efuse data. */
+	if (name == NULL)
 		name = padapter->registrypriv.if2name;
 
 	rtw_init_netdev_name(pnetdev, name);
-	//get mac address from primary_padapter
+	/* get mac address from primary_padapter */
 	_rtw_memcpy(mac, primary_padapter->eeprompriv.mac_addr, ETH_ALEN);
 
-	if (((mac[0]==0xff) &&(mac[1]==0xff) && (mac[2]==0xff) &&
-	     (mac[3]==0xff) && (mac[4]==0xff) &&(mac[5]==0xff)) ||
-	    ((mac[0]==0x0) && (mac[1]==0x0) && (mac[2]==0x0) &&
-	     (mac[3]==0x0) && (mac[4]==0x0) &&(mac[5]==0x0)))
+	if (((mac[0]== 0xff) &&(mac[1]== 0xff) && (mac[2]== 0xff) &&
+	     (mac[3]== 0xff) && (mac[4]== 0xff) &&(mac[5]== 0xff)) ||
+	    ((mac[0]== 0x0) && (mac[1]== 0x0) && (mac[2]== 0x0) &&
+	     (mac[3]== 0x0) && (mac[4]== 0x0) &&(mac[5]== 0x0)))
 	{
 		mac[0] = 0x00;
 		mac[1] = 0xe0;
@@ -1757,10 +1698,10 @@ _adapter *rtw_drv_add_vir_if(_adapter *p
 	}
 	else
 	{
-		//If the BIT1 is 0, the address is universally administered.
-		//If it is 1, the address is locally administered
-#if 1 //needs enable MBSSID CAM
-		mac[0] |= BIT(1); // locally administered
+		/* If the BIT1 is 0, the address is universally administered. */
+		/* If it is 1, the address is locally administered */
+#if 1 /* needs enable MBSSID CAM */
+		mac[0] |= BIT(1); /*  locally administered */
 		mac[0] |= (padapter->iface_id-1)<<4;
 #endif
 	}
@@ -1774,7 +1715,7 @@ _adapter *rtw_drv_add_vir_if(_adapter *p
 
 	/* Tell the network stack we exist */
 	if (register_netdev(pnetdev) != 0)
-	//if (register_netdevice(pnetdev) != 0)
+	/* if (register_netdevice(pnetdev) != 0) */
 	{
 		goto error_rtw_drv_add_iface;
 	}
@@ -1788,7 +1729,7 @@ _adapter *rtw_drv_add_vir_if(_adapter *p
 
 error_rtw_drv_add_iface:
 
-	if(padapter)
+	if (padapter)
 		rtw_free_drv_sw(padapter);
 
 	if (pnetdev)
@@ -1798,24 +1739,24 @@ error_rtw_drv_add_iface:
 
 }
 
-void rtw_drv_stop_vir_if(_adapter *padapter)
+void rtw_drv_stop_vir_if (_adapter *padapter)
 {
-	struct net_device *pnetdev=NULL;
+	struct net_device *pnetdev = NULL;
 
 	if (padapter == NULL)
 		return;
 
 	pnetdev = padapter->pnetdev;
 
-	if(pnetdev)
+	if (pnetdev)
 	{
-		unregister_netdev(pnetdev); //will call netdev_close()
+		unregister_netdev(pnetdev); /* will call netdev_close() */
 		rtw_proc_remove_one(pnetdev);
 	}
 
 	rtw_cancel_all_timer(padapter);
 
-	if(padapter->bup == _TRUE)
+	if (padapter->bup == _TRUE)
 	{
 		padapter->bDriverStopped = _TRUE;
 
@@ -1824,7 +1765,7 @@ void rtw_drv_stop_vir_if(_adapter *padap
 			rtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_DRV_STOP);
 		#endif
 
-		if(padapter->intf_stop)
+		if (padapter->intf_stop)
 		{
 			padapter->intf_stop(padapter);
 		}
@@ -1836,13 +1777,13 @@ void rtw_drv_stop_vir_if(_adapter *padap
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_wdev_unregister(padapter->rtw_wdev);
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 }
 
-void rtw_drv_free_vir_if(_adapter *padapter)
+void rtw_drv_free_vir_if (_adapter *padapter)
 {
-	struct net_device *pnetdev=NULL;
+	struct net_device *pnetdev = NULL;
 
 	if (padapter == NULL)
 		return;
@@ -1854,7 +1795,7 @@ void rtw_drv_free_vir_if(_adapter *padap
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_wdev_free(padapter->rtw_wdev);
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 	rtw_free_drv_sw(padapter);
 
@@ -1864,29 +1805,29 @@ void rtw_drv_free_vir_if(_adapter *padap
 void rtw_drv_stop_vir_ifaces(struct dvobj_priv *dvobj)
 {
 	int i;
-	//struct dvobj_priv *dvobj = primary_padapter->dvobj;
+	/* struct dvobj_priv *dvobj = primary_padapter->dvobj; */
 
-	for(i=2;i<dvobj->iface_nums;i++)
+	for(i = 2;i<dvobj->iface_nums;i++)
 	{
-		rtw_drv_stop_vir_if(dvobj->padapters[i]);
+		rtw_drv_stop_vir_if (dvobj->padapters[i]);
 	}
 }
 
 void rtw_drv_free_vir_ifaces(struct dvobj_priv *dvobj)
 {
 	int i;
-	//struct dvobj_priv *dvobj = primary_padapter->dvobj;
+	/* struct dvobj_priv *dvobj = primary_padapter->dvobj; */
 
-	for(i=2;i<dvobj->iface_nums;i++)
+	for(i = 2;i<dvobj->iface_nums;i++)
 	{
-		rtw_drv_free_vir_if(dvobj->padapters[i]);
+		rtw_drv_free_vir_if (dvobj->padapters[i]);
 	}
 }
 
-void rtw_drv_del_vir_if(_adapter *padapter)
+void rtw_drv_del_vir_if (_adapter *padapter)
 {
-	rtw_drv_stop_vir_if(padapter);
-	rtw_drv_free_vir_if(padapter);
+	rtw_drv_stop_vir_if (padapter);
+	rtw_drv_free_vir_if (padapter);
 }
 
 void rtw_drv_del_vir_ifaces(_adapter *primary_padapter)
@@ -1894,26 +1835,26 @@ void rtw_drv_del_vir_ifaces(_adapter *pr
 	int i;
 	struct dvobj_priv *dvobj = primary_padapter->dvobj;
 
-	for(i=2;i<dvobj->iface_nums;i++)
+	for(i = 2;i<dvobj->iface_nums;i++)
 	{
-		rtw_drv_del_vir_if(dvobj->padapters[i]);
+		rtw_drv_del_vir_if (dvobj->padapters[i]);
 	}
 }
-#endif //CONFIG_MULTI_VIR_IFACES
+#endif /* CONFIG_MULTI_VIR_IFACES */
 
-int _netdev_if2_open(struct net_device *pnetdev)
+static int _netdev_if2_open(struct net_device *pnetdev)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
 	_adapter *primary_padapter = padapter->pbuddy_adapter;
 
-	DBG_871X("+871x_drv - if2_open, bup=%d\n", padapter->bup);
+	DBG_871X("+871x_drv - if2_open, bup =%d\n", padapter->bup);
 
-	if(primary_padapter->bup == _FALSE || primary_padapter->hw_init_completed == _FALSE)
+	if (primary_padapter->bup == _FALSE || primary_padapter->hw_init_completed == _FALSE)
 	{
 		_netdev_open(primary_padapter->pnetdev);
 	}
 
-	if(padapter->bup == _FALSE && primary_padapter->bup == _TRUE &&
+	if (padapter->bup == _FALSE && primary_padapter->bup == _TRUE &&
 		primary_padapter->hw_init_completed == _TRUE)
 	{
 		int i;
@@ -1928,17 +1869,15 @@ int _netdev_if2_open(struct net_device *
 
 		rtw_hal_set_hwreg(padapter, HW_VAR_DM_INIT_PWDB, NULL);
 
-		//if (init_mlme_ext_priv(padapter) == _FAIL)
-		//	goto netdev_if2_open_error;
 
 
-		if(rtw_start_drv_threads(padapter) == _FAIL)
+		if (rtw_start_drv_threads(padapter) == _FAIL)
 		{
 			goto netdev_if2_open_error;
 		}
 
 
-		if(padapter->intf_start)
+		if (padapter->intf_start)
 		{
 			padapter->intf_start(padapter);
 		}
@@ -1962,12 +1901,12 @@ int _netdev_if2_open(struct net_device *
 
 	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
 
-	if(!rtw_netif_queue_stopped(pnetdev))
+	if (!rtw_netif_queue_stopped(pnetdev))
 		rtw_netif_start_queue(pnetdev);
 	else
 		rtw_netif_wake_queue(pnetdev);
 
-	DBG_871X("-871x_drv - if2_open, bup=%d\n", padapter->bup);
+	DBG_871X("-871x_drv - if2_open, bup =%d\n", padapter->bup);
 	return 0;
 
 netdev_if2_open_error:
@@ -1981,7 +1920,7 @@ netdev_if2_open_error:
 
 }
 
-int netdev_if2_open(struct net_device *pnetdev)
+static int netdev_if2_open(struct net_device *pnetdev)
 {
 	int ret;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
@@ -1998,7 +1937,7 @@ static int netdev_if2_close(struct net_d
 
 	padapter->net_closed = _TRUE;
 
-	if(pnetdev)
+	if (pnetdev)
 	{
 		if (!rtw_netif_queue_stopped(pnetdev))
 			rtw_netif_stop_queue(pnetdev);
@@ -2012,7 +1951,7 @@ static int netdev_if2_close(struct net_d
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
 static const struct net_device_ops rtw_netdev_if2_ops = {
 	.ndo_open = netdev_if2_open,
         .ndo_stop = netdev_if2_close,
@@ -2020,7 +1959,7 @@ static const struct net_device_ops rtw_n
         .ndo_set_mac_address = rtw_net_set_mac_address,
         .ndo_get_stats = rtw_net_get_stats,
         .ndo_do_ioctl = rtw_ioctl,
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 35))
 	.ndo_select_queue	= rtw_select_queue,
 #endif
 };
@@ -2040,7 +1979,7 @@ _adapter *rtw_drv_if2_init(_adapter *pri
 	if (!pnetdev)
 		goto error_rtw_drv_if2_init;
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
 	DBG_871X("register rtw_netdev_if2_ops to netdev_ops\n");
 	pnetdev->netdev_ops = &rtw_netdev_if2_ops;
 #else
@@ -2056,23 +1995,23 @@ _adapter *rtw_drv_if2_init(_adapter *pri
 	padapter = rtw_netdev_priv(pnetdev);
 	_rtw_memcpy(padapter, primary_padapter, sizeof(_adapter));
 
-	//
+	/*  */
 	padapter->bup = _FALSE;
 	padapter->net_closed = _TRUE;
 	padapter->hw_init_completed = _FALSE;
 
-	//set adapter_type/iface type
+	/* set adapter_type/iface type */
 	padapter->isprimary = _FALSE;
 	padapter->adapter_type = SECONDARY_ADAPTER;
 	padapter->pbuddy_adapter = primary_padapter;
 	pr_debug("pbuddy_adapter: %p\n", primary_padapter);
         padapter->iface_id = IFACE_ID1;
-#ifndef CONFIG_HWPORT_SWAP			//Port0 -> Pri , Port1 -> Sec
+#ifndef CONFIG_HWPORT_SWAP			/* Port0 -> Pri , Port1 -> Sec */
 	padapter->iface_type = IFACE_PORT1;
 #else
 	padapter->iface_type = IFACE_PORT0;
-#endif  //CONFIG_HWPORT_SWAP
-	//
+#endif  /* CONFIG_HWPORT_SWAP */
+	/*  */
 	padapter->pnetdev = pnetdev;
 
 	/****** setup dvobj ******/
@@ -2083,53 +2022,53 @@ _adapter *rtw_drv_if2_init(_adapter *pri
 	SET_NETDEV_DEV(pnetdev, dvobj_to_dev(pdvobjpriv));
 	#ifdef CONFIG_IOCTL_CFG80211
 	rtw_wdev_alloc(padapter, dvobj_to_dev(pdvobjpriv));
-	#endif //CONFIG_IOCTL_CFG80211
+	#endif /* CONFIG_IOCTL_CFG80211 */
 
-	//set interface_type/chip_type/HardwareType
+	/* set interface_type/chip_type/HardwareType */
 	padapter->interface_type = primary_padapter->interface_type;
 	padapter->chip_type = primary_padapter->chip_type;
 	padapter->HardwareType = primary_padapter->HardwareType;
 
-	//set hal data & hal ops
+	/* set hal data & hal ops */
 	rtl8192du_set_hal_ops(padapter);
 
 	padapter->HalFunc.inirp_init = NULL;
 	padapter->HalFunc.inirp_deinit = NULL;
 
-	//
+	/*  */
 	padapter->intf_start = primary_padapter->intf_start;
 	padapter->intf_stop = primary_padapter->intf_stop;
 
-	//step init_io_priv
+	/* step init_io_priv */
 	if ((rtw_init_io_priv(padapter, set_intf_ops)) == _FAIL) {
-		RT_TRACE(_module_hci_intfs_c_,_drv_err_,(" \n Can't init io_reqs\n"));
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, (" \n Can't init io_reqs\n"));
 	}
 
-	//step read_chip_version
+	/* step read_chip_version */
 	rtw_hal_read_chip_version(padapter);
 
-	//step usb endpoint mapping
+	/* step usb endpoint mapping */
 	rtw_hal_chip_configure(padapter);
 
 
-	//init drv data
-	if(rtw_init_drv_sw(padapter)!= _SUCCESS)
+	/* init drv data */
+	if (rtw_init_drv_sw(padapter)!= _SUCCESS)
 		goto error_rtw_drv_if2_init;
 
 
-	// alloc dev name after got efuse data.
-	if(name == NULL)
+	/*  alloc dev name after got efuse data. */
+	if (name == NULL)
 		name = padapter->registrypriv.if2name;
 
 	rtw_init_netdev_name(pnetdev, name);
 
-	//get mac address from primary_padapter
+	/* get mac address from primary_padapter */
 	_rtw_memcpy(mac, primary_padapter->eeprompriv.mac_addr, ETH_ALEN);
 
-	if (((mac[0]==0xff) &&(mac[1]==0xff) && (mac[2]==0xff) &&
-	     (mac[3]==0xff) && (mac[4]==0xff) &&(mac[5]==0xff)) ||
-	    ((mac[0]==0x0) && (mac[1]==0x0) && (mac[2]==0x0) &&
-	     (mac[3]==0x0) && (mac[4]==0x0) &&(mac[5]==0x0)))
+	if (((mac[0]== 0xff) &&(mac[1]== 0xff) && (mac[2]== 0xff) &&
+	     (mac[3]== 0xff) && (mac[4]== 0xff) &&(mac[5]== 0xff)) ||
+	    ((mac[0]== 0x0) && (mac[1]== 0x0) && (mac[2]== 0x0) &&
+	     (mac[3]== 0x0) && (mac[4]== 0x0) &&(mac[5]== 0x0)))
 	{
 		mac[0] = 0x00;
 		mac[1] = 0xe0;
@@ -2140,9 +2079,9 @@ _adapter *rtw_drv_if2_init(_adapter *pri
 	}
 	else
 	{
-		//If the BIT1 is 0, the address is universally administered.
-		//If it is 1, the address is locally administered
-		mac[0] |= BIT(1); // locally administered
+		/* If the BIT1 is 0, the address is universally administered. */
+		/* If it is 1, the address is locally administered */
+		mac[0] |= BIT(1); /*  locally administered */
 
 	}
 
@@ -2170,7 +2109,7 @@ _adapter *rtw_drv_if2_init(_adapter *pri
 
 error_rtw_drv_if2_init:
 
-	if(padapter)
+	if (padapter)
 		rtw_free_drv_sw(padapter);
 
 	if (pnetdev)
@@ -2212,7 +2151,7 @@ void rtw_drv_if2_stop(_adapter *if2)
 	pnetdev = padapter->pnetdev;
 
 	if (pnetdev) {
-		unregister_netdev(pnetdev); //will call netdev_close()
+		unregister_netdev(pnetdev); /* will call netdev_close() */
 		rtw_proc_remove_one(pnetdev);
 	}
 
@@ -2225,7 +2164,7 @@ void rtw_drv_if2_stop(_adapter *if2)
 			rtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_DRV_STOP);
 		#endif
 
-		if(padapter->intf_stop)
+		if (padapter->intf_stop)
 		{
 			padapter->intf_stop(padapter);
 		}
@@ -2240,7 +2179,7 @@ void rtw_drv_if2_stop(_adapter *if2)
 	#endif
 
 }
-#endif //end of CONFIG_CONCURRENT_MODE
+#endif /* end of CONFIG_CONCURRENT_MODE */
 
 #ifdef CONFIG_BR_EXT
 void netdev_br_init(struct net_device *netdev)
@@ -2249,31 +2188,29 @@ void netdev_br_init(struct net_device *n
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
 	rcu_read_lock();
-#endif	// (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#endif	/*  (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35)) */
 
-	//if(check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == _TRUE)
 	{
-		//struct net_bridge	*br = netdev->br_port->br;//->dev->dev_addr;
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 		if (netdev->br_port)
-#else   // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+#else   /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 		if (rcu_dereference(adapter->pnetdev->rx_handler_data))
-#endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+#endif  /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 		{
 			struct net_device *br_netdev;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
 			br_netdev = dev_get_by_name(CONFIG_BR_EXT_BRNAME);
-#else	// (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#else	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)) */
 			struct net *devnet = NULL;
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
 			devnet = netdev->nd_net;
-#else	// (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#else	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)) */
 			devnet = dev_net(netdev);
-#endif	// (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#endif	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)) */
 
 			br_netdev = dev_get_by_name(devnet, CONFIG_BR_EXT_BRNAME);
-#endif	// (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#endif	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)) */
 
 			if (br_netdev) {
 				memcpy(adapter->br_mac, br_netdev->dev_addr, ETH_ALEN);
@@ -2287,9 +2224,9 @@ void netdev_br_init(struct net_device *n
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
 	rcu_read_unlock();
-#endif	// (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#endif	/*  (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35)) */
 }
-#endif //CONFIG_BR_EXT
+#endif /* CONFIG_BR_EXT */
 
 int _netdev_open(struct net_device *pnetdev)
 {
@@ -2297,41 +2234,41 @@ int _netdev_open(struct net_device *pnet
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
 	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+871x_drv - dev_open\n"));
-	DBG_871X("+871x_drv - drv_open, bup=%d\n", padapter->bup);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+871x_drv - dev_open\n"));
+	DBG_871X("+871x_drv - drv_open, bup =%d\n", padapter->bup);
 
-	if(pwrctrlpriv->ps_flag == _TRUE){
+	if (pwrctrlpriv->ps_flag == _TRUE){
 		padapter->net_closed = _FALSE;
 		goto netdev_open_normal_process;
 	}
 
-	if(padapter->bup == _FALSE)
+	if (padapter->bup == _FALSE)
 	{
 		padapter->bDriverStopped = _FALSE;
 		padapter->bSurpriseRemoved = _FALSE;
 		padapter->bCardDisableWOHSM = _FALSE;
 
 		status = rtw_hal_init(padapter);
-		if (status ==_FAIL)
+		if (status == _FAIL)
 		{
-			RT_TRACE(_module_os_intfs_c_,_drv_err_,("rtl871x_hal_init(): Can't init h/w!\n"));
+			RT_TRACE(_module_os_intfs_c_, _drv_err_, ("rtl871x_hal_init(): Can't init h/w!\n"));
 			goto netdev_open_error;
 		}
 
 		DBG_871X("MAC Address = "MAC_FMT"\n", MAC_ARG(pnetdev->dev_addr));
 
 
-		status=rtw_start_drv_threads(padapter);
-		if(status ==_FAIL)
+		status = rtw_start_drv_threads(padapter);
+		if (status == _FAIL)
 		{
-			RT_TRACE(_module_os_intfs_c_,_drv_err_,("Initialize driver software resource Failed!\n"));
+			RT_TRACE(_module_os_intfs_c_, _drv_err_, ("Initialize driver software resource Failed!\n"));
 			goto netdev_open_error;
 		}
 
 
 		if (init_hw_mlme_ext(padapter) == _FAIL)
 		{
-			RT_TRACE(_module_os_intfs_c_,_drv_err_,("can't init mlme_ext_priv\n"));
+			RT_TRACE(_module_os_intfs_c_, _drv_err_, ("can't init mlme_ext_priv\n"));
 			goto netdev_open_error;
 		}
 
@@ -2340,7 +2277,7 @@ int _netdev_open(struct net_device *pnet
 		init_drvext(padapter);
 #endif
 
-		if(padapter->intf_start)
+		if (padapter->intf_start)
 		{
 			padapter->intf_start(padapter);
 		}
@@ -2361,28 +2298,27 @@ int _netdev_open(struct net_device *pnet
 	padapter->pwrctrlpriv.bips_processing = _FALSE;
 	rtw_set_pwr_state_check_timer(&padapter->pwrctrlpriv);
 
-	//netif_carrier_on(pnetdev);//call this func when rtw_joinbss_event_callback return success
-	if(!rtw_netif_queue_stopped(pnetdev))
+	if (!rtw_netif_queue_stopped(pnetdev))
 		rtw_netif_start_queue(pnetdev);
 	else
 		rtw_netif_wake_queue(pnetdev);
 
 #ifdef CONFIG_BR_EXT
 	netdev_br_init(pnetdev);
-#endif	// CONFIG_BR_EXT
+#endif	/*  CONFIG_BR_EXT */
 
 netdev_open_normal_process:
 
 	#ifdef CONFIG_CONCURRENT_MODE
 	{
 		_adapter *sec_adapter = padapter->pbuddy_adapter;
-		if(sec_adapter && (sec_adapter->bup == _FALSE || sec_adapter->hw_init_completed == _FALSE))
+		if (sec_adapter && (sec_adapter->bup == _FALSE || sec_adapter->hw_init_completed == _FALSE))
 			_netdev_if2_open(sec_adapter->pnetdev);
 	}
 	#endif
 
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-871x_drv - dev_open\n"));
-	DBG_871X("-871x_drv - drv_open, bup=%d\n", padapter->bup);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-871x_drv - dev_open\n"));
+	DBG_871X("-871x_drv - drv_open, bup =%d\n", padapter->bup);
 
 	return 0;
 
@@ -2393,8 +2329,8 @@ netdev_open_error:
 	netif_carrier_off(pnetdev);
 	rtw_netif_stop_queue(pnetdev);
 
-	RT_TRACE(_module_os_intfs_c_,_drv_err_,("-871x_drv - dev_open, fail!\n"));
-	DBG_871X("-871x_drv - drv_open fail, bup=%d\n", padapter->bup);
+	RT_TRACE(_module_os_intfs_c_, _drv_err_, ("-871x_drv - dev_open, fail!\n"));
+	DBG_871X("-871x_drv - drv_open fail, bup =%d\n", padapter->bup);
 
 	return (-1);
 
@@ -2413,38 +2349,36 @@ int netdev_open(struct net_device *pnetd
 }
 
 #ifdef CONFIG_IPS
-int  ips_netdrv_open(_adapter *padapter)
+static int  ips_netdrv_open(_adapter *padapter)
 {
 	int status = _SUCCESS;
 	padapter->net_closed = _FALSE;
-	DBG_871X("===> %s.........\n",__FUNCTION__);
+	DBG_871X("===> %s.........\n", __FUNCTION__);
 
 
 	padapter->bDriverStopped = _FALSE;
 	padapter->bSurpriseRemoved = _FALSE;
 	padapter->bCardDisableWOHSM = _FALSE;
-	//padapter->bup = _TRUE;
 
 	status = rtw_hal_init(padapter);
-	if (status ==_FAIL)
+	if (status == _FAIL)
 	{
-		RT_TRACE(_module_os_intfs_c_,_drv_err_,("ips_netdrv_open(): Can't init h/w!\n"));
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("ips_netdrv_open(): Can't init h/w!\n"));
 		goto netdev_open_error;
 	}
 
-	if(padapter->intf_start)
+	if (padapter->intf_start)
 	{
 		padapter->intf_start(padapter);
 	}
 
 	rtw_set_pwr_state_check_timer(&padapter->pwrctrlpriv);
-	_set_timer(&padapter->mlmepriv.dynamic_chk_timer,5000);
+	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 5000);
 
 	 return _SUCCESS;
 
 netdev_open_error:
-	//padapter->bup = _FALSE;
-	DBG_871X("-ips_netdrv_open - drv_open failure, bup=%d\n", padapter->bup);
+	DBG_871X("-ips_netdrv_open - drv_open failure, bup =%d\n", padapter->bup);
 
 	return _FAIL;
 }
@@ -2483,29 +2417,24 @@ void rtw_ips_pwr_down(_adapter *padapter
 #endif
 void rtw_ips_dev_unload(_adapter *padapter)
 {
-	struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;
+	struct net_device *pnetdev = (struct net_device*)padapter->pnetdev;
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
-	DBG_871X("====> %s...\n",__FUNCTION__);
+	DBG_871X("====> %s...\n", __FUNCTION__);
 
-	rtw_hal_set_hwreg(padapter, HW_VAR_FIFO_CLEARN_UP, 0);
+	rtw_hal_set_hwreg(padapter, HW_VAR_FIFO_CLEARN_UP, NULL);
 
-	if(padapter->intf_stop)
-	{
+	if (padapter->intf_stop)
 		padapter->intf_stop(padapter);
-	}
 
-	//s5.
-	if(padapter->bSurpriseRemoved == _FALSE)
-	{
+	/* s5. */
+	if (padapter->bSurpriseRemoved == _FALSE)
 		rtw_hal_deinit(padapter);
-	}
-
 }
 
-int pm_netdev_open(struct net_device *pnetdev,u8 bnormal)
+int pm_netdev_open(struct net_device *pnetdev, u8 bnormal)
 {
 	int status;
-	if(bnormal)
+	if (bnormal)
 		status = netdev_open(pnetdev);
 #ifdef CONFIG_IPS
 	else
@@ -2519,74 +2448,60 @@ static int netdev_close(struct net_devic
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(pnetdev);
 
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("+871x_drv - drv_close\n"));
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+871x_drv - drv_close\n"));
 
-	if(padapter->pwrctrlpriv.bInternalAutoSuspend == _TRUE)
+	if (padapter->pwrctrlpriv.bInternalAutoSuspend == _TRUE)
 	{
-		//rtw_pwr_wakeup(padapter);
-		if(padapter->pwrctrlpriv.rf_pwrstate == rf_off)
+		if (padapter->pwrctrlpriv.rf_pwrstate == rf_off)
 			padapter->pwrctrlpriv.ps_flag = _TRUE;
 	}
 	padapter->net_closed = _TRUE;
 
-/*	if(!padapter->hw_init_completed)
-	{
-		DBG_871X("(1)871x_drv - drv_close, bup=%d, hw_init_completed=%d\n", padapter->bup, padapter->hw_init_completed);
-
-		padapter->bDriverStopped = _TRUE;
-
-		rtw_dev_unload(padapter);
-	}
-	else*/
-	if(padapter->pwrctrlpriv.rf_pwrstate == rf_on){
-		DBG_871X("(2)871x_drv - drv_close, bup=%d, hw_init_completed=%d\n", padapter->bup, padapter->hw_init_completed);
+	if (padapter->pwrctrlpriv.rf_pwrstate == rf_on){
+		DBG_871X("(2)871x_drv - drv_close, bup =%d, hw_init_completed =%d\n", padapter->bup, padapter->hw_init_completed);
 
-		//s1.
-		if(pnetdev)
+		/* s1. */
+		if (pnetdev)
 		{
 			if (!rtw_netif_queue_stopped(pnetdev))
 				rtw_netif_stop_queue(pnetdev);
 		}
 
 #ifndef CONFIG_ANDROID
-		//s2.
+		/* s2. */
 		LeaveAllPowerSaveMode(padapter);
 		rtw_disassoc_cmd(padapter, 500, _FALSE);
-		//s2-2.  indicate disconnect to os
+		/* s2-2.  indicate disconnect to os */
 		rtw_indicate_disconnect(padapter);
-		//s2-3.
+		/* s2-3. */
 		rtw_free_assoc_resources(padapter, 1);
-		//s2-4.
-		rtw_free_network_queue(padapter,_TRUE);
+		/* s2-4. */
+		rtw_free_network_queue(padapter, _TRUE);
 #endif
-		// Close LED
+		/*  Close LED */
 		rtw_led_control(padapter, LED_CTL_POWER_OFF);
 	}
 
 #ifdef CONFIG_BR_EXT
-	//if (OPMODE & (WIFI_STATION_STATE | WIFI_ADHOC_STATE))
-	{
-		//void nat25_db_cleanup(_adapter *priv);
-		nat25_db_cleanup(padapter);
-	}
-#endif	// CONFIG_BR_EXT
+	nat25_db_cleanup(padapter);
+#endif	/*  CONFIG_BR_EXT */
 
 #ifdef CONFIG_P2P
 	#ifdef CONFIG_IOCTL_CFG80211
-	if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled == _TRUE)
+	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled == _TRUE)
 		wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = _FALSE;
 	#endif
 	rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_scan_abort(padapter);
 	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = _FALSE;
-	padapter->rtw_wdev->iftype = NL80211_IFTYPE_MONITOR; //set this at the end
-#endif //CONFIG_IOCTL_CFG80211
+	padapter->rtw_wdev->iftype = NL80211_IFTYPE_MONITOR; /* set this at the end */
+#endif /* CONFIG_IOCTL_CFG80211 */
 
-	RT_TRACE(_module_os_intfs_c_,_drv_info_,("-871x_drv - drv_close\n"));
-	DBG_871X("-871x_drv - drv_close, bup=%d\n", padapter->bup);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-871x_drv - drv_close\n"));
+	DBG_871X("-871x_drv - drv_close, bup =%d\n", padapter->bup);
 
 	return 0;
 }
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -36,7 +36,7 @@
 #endif
 #endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
 
-const char *android_wifi_cmd_str[ANDROID_WIFI_CMD_MAX] = {
+static const char *android_wifi_cmd_str[ANDROID_WIFI_CMD_MAX] = {
 	"START",
 	"STOP",
 	"SCAN-ACTIVE",
@@ -236,7 +236,7 @@ int rtw_android_cmdstr_to_num(char *cmds
 	return cmd_num;
 }
 
-int rtw_android_get_rssi(struct net_device *net, char *command, int total_len)
+static int rtw_android_get_rssi(struct net_device *net, char *command, int total_len)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
@@ -251,7 +251,7 @@ int rtw_android_get_rssi(struct net_devi
 	return bytes_written;
 }
 
-int rtw_android_get_link_speed(struct net_device *net, char *command, int total_len)
+static int rtw_android_get_link_speed(struct net_device *net, char *command, int total_len)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
@@ -265,7 +265,7 @@ int rtw_android_get_link_speed(struct ne
 	return bytes_written;
 }
 
-int rtw_android_get_macaddr(struct net_device *net, char *command, int total_len)
+static int rtw_android_get_macaddr(struct net_device *net, char *command, int total_len)
 {
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
 	int bytes_written = 0;
@@ -274,7 +274,7 @@ int rtw_android_get_macaddr(struct net_d
 	return bytes_written;
 }
 
-int rtw_android_set_country(struct net_device *net, char *command, int total_len)
+static int rtw_android_set_country(struct net_device *net, char *command, int total_len)
 {
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
 	char *country_code = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_COUNTRY]) + 1;
@@ -285,7 +285,7 @@ int rtw_android_set_country(struct net_d
 	return (ret==_SUCCESS)?0:-1;
 }
 
-int rtw_android_get_p2p_dev_addr(struct net_device *net, char *command, int total_len)
+static int rtw_android_get_p2p_dev_addr(struct net_device *net, char *command, int total_len)
 {
 	int ret;
 	int bytes_written = 0;
@@ -297,7 +297,7 @@ int rtw_android_get_p2p_dev_addr(struct
 	return bytes_written;
 }
 
-int rtw_android_set_block(struct net_device *net, char *command, int total_len)
+static int rtw_android_set_block(struct net_device *net, char *command, int total_len)
 {
 	int ret;
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
@@ -310,7 +310,7 @@ int rtw_android_set_block(struct net_dev
 	return 0;
 }
 
-int get_int_from_command( char* pcmd )
+static int get_int_from_command( char* pcmd )
 {
 	int i = 0;
 

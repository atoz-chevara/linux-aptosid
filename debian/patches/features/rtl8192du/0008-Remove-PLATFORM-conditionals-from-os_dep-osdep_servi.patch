From a00cc5dd2c5450311491df0272f737cad61bcdca Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Wed, 17 Apr 2013 11:08:22 -0500
Subject: [PATCH 008/210] Remove PLATFORM conditionals from
 os_dep/osdep_service.c

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 os_dep/osdep_service.c | 839 +------------------------------------------------
 1 file changed, 5 insertions(+), 834 deletions(-)

--- a/drivers/staging/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8192du/os_dep/osdep_service.c
@@ -25,31 +25,17 @@
 #include <osdep_service.h>
 #include <drv_types.h>
 #include <recv_osdep.h>
-#ifdef PLATFORM_LINUX
 #include <linux/vmalloc.h>
-#endif
-#ifdef PLATFORM_FREEBSD
-#include <sys/malloc.h>
-#include <sys/time.h>
-#endif /* PLATFORM_FREEBSD */
-#ifdef RTK_DMP_PLATFORM
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12))
-#include <linux/pageremap.h>
-#endif
-#endif
 
 #define RT_TAG	'1178'
 
 #ifdef DBG_MEMORY_LEAK
-#ifdef PLATFORM_LINUX
 #include <asm/atomic.h>
 atomic_t _malloc_cnt = ATOMIC_INIT(0);
 atomic_t _malloc_size = ATOMIC_INIT(0);
-#endif
 #endif /* DBG_MEMORY_LEAK */
 
 
-#if defined(PLATFORM_LINUX)
 /*
 * Translate the OS dependent @param error_code to OS independent RTW_STATUS_CODE
 * @return: one of RTW_STATUS_CODE
@@ -65,11 +51,6 @@ inline int RTW_STATUS_CODE(int error_cod
 			return _FAIL;
 	}
 }
-#else
-inline int RTW_STATUS_CODE(int error_code){
-	return error_code;
-}
-#endif
 
 u32 rtw_atoi(u8* s)
 {
@@ -96,24 +77,13 @@ u32 rtw_atoi(u8* s)
 inline u8* _rtw_vmalloc(u32 sz)
 {
 	u8	*pbuf;
-#ifdef PLATFORM_LINUX
 	pbuf = vmalloc(sz);
-#endif
-#ifdef PLATFORM_FREEBSD
-	pbuf = malloc(sz,M_DEVBUF,M_NOWAIT);
-#endif
-
-#ifdef PLATFORM_WINDOWS
-	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);
-#endif
 
 #ifdef DBG_MEMORY_LEAK
-#ifdef PLATFORM_LINUX
 	if ( pbuf != NULL) {
 		atomic_inc(&_malloc_cnt);
 		atomic_add(sz, &_malloc_size);
 	}
-#endif
 #endif /* DBG_MEMORY_LEAK */
 
 	return pbuf;
@@ -122,40 +92,19 @@ inline u8* _rtw_vmalloc(u32 sz)
 inline u8* _rtw_zvmalloc(u32 sz)
 {
 	u8	*pbuf;
-#ifdef PLATFORM_LINUX
 	pbuf = _rtw_vmalloc(sz);
 	if (pbuf != NULL)
 		memset(pbuf, 0, sz);
-#endif
-#ifdef PLATFORM_FREEBSD
-	pbuf = malloc(sz,M_DEVBUF,M_ZERO|M_NOWAIT);
-#endif
-#ifdef PLATFORM_WINDOWS
-	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);
-	if (pbuf != NULL)
-		NdisFillMemory(pbuf, sz, 0);
-#endif
-
 	return pbuf;
 }
 
 inline void _rtw_vmfree(u8 *pbuf, u32 sz)
 {
-#ifdef	PLATFORM_LINUX
 	vfree(pbuf);
-#endif
-#ifdef PLATFORM_FREEBSD
-	free(pbuf,M_DEVBUF);
-#endif
-#ifdef PLATFORM_WINDOWS
-	NdisFreeMemory(pbuf,sz, 0);
-#endif
 
 #ifdef DBG_MEMORY_LEAK
-#ifdef PLATFORM_LINUX
 	atomic_dec(&_malloc_cnt);
 	atomic_sub(sz, &_malloc_size);
-#endif
 #endif /* DBG_MEMORY_LEAK */
 }
 
@@ -164,92 +113,37 @@ u8* _rtw_malloc(u32 sz)
 
 	u8	*pbuf=NULL;
 
-#ifdef PLATFORM_LINUX
-#ifdef RTK_DMP_PLATFORM
-	if(sz > 0x4000)
-		pbuf = (u8 *)dvr_malloc(sz);
-	else
-#endif
-		pbuf = kmalloc(sz,in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	pbuf = malloc(sz,M_DEVBUF,M_NOWAIT);
-#endif
-#ifdef PLATFORM_WINDOWS
-
-	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);
-
-#endif
+	pbuf = kmalloc(sz,in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
 
 #ifdef DBG_MEMORY_LEAK
-#ifdef PLATFORM_LINUX
 	if ( pbuf != NULL) {
 		atomic_inc(&_malloc_cnt);
 		atomic_add(sz, &_malloc_size);
 	}
-#endif
 #endif /* DBG_MEMORY_LEAK */
 
 	return pbuf;
-
 }
 
-
 u8* _rtw_zmalloc(u32 sz)
 {
-#ifdef PLATFORM_FREEBSD
-	return malloc(sz,M_DEVBUF,M_ZERO|M_NOWAIT);
-#else // PLATFORM_FREEBSD
 	u8	*pbuf = _rtw_malloc(sz);
 
 	if (pbuf != NULL) {
-
-#ifdef PLATFORM_LINUX
 		memset(pbuf, 0, sz);
-#endif
-
-#ifdef PLATFORM_WINDOWS
-		NdisFillMemory(pbuf, sz, 0);
-#endif
-
 	}
-
 	return pbuf;
-#endif // PLATFORM_FREEBSD
 }
 
 void	_rtw_mfree(u8 *pbuf, u32 sz)
 {
-
-#ifdef	PLATFORM_LINUX
-#ifdef RTK_DMP_PLATFORM
-	if(sz > 0x4000)
-		dvr_free(pbuf);
-	else
-#endif
 		kfree(pbuf);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	free(pbuf,M_DEVBUF);
-#endif
-#ifdef PLATFORM_WINDOWS
-
-	NdisFreeMemory(pbuf,sz, 0);
-
-#endif
-
 #ifdef DBG_MEMORY_LEAK
-#ifdef PLATFORM_LINUX
 	atomic_dec(&_malloc_cnt);
 	atomic_sub(sz, &_malloc_size);
-#endif
 #endif /* DBG_MEMORY_LEAK */
-
 }
 
-
 #ifdef DBG_MEM_ALLOC
 
 struct rtw_dbg_mem_stat {
@@ -483,147 +377,28 @@ inline void dbg_rtw_mfree(u8 *pbuf, u32
 
 void _rtw_memcpy(void* dst, void* src, u32 sz)
 {
-
-#if defined (PLATFORM_LINUX)|| defined (PLATFORM_FREEBSD)
-
 	memcpy(dst, src, sz);
-
-#endif
-
-#ifdef PLATFORM_WINDOWS
-
-	NdisMoveMemory(dst, src, sz);
-
-#endif
-
 }
 
 int	_rtw_memcmp(void *dst, void *src, u32 sz)
 {
-
-#if defined (PLATFORM_LINUX)|| defined (PLATFORM_FREEBSD)
 //under Linux/GNU/GLibc, the return value of memcmp for two same mem. chunk is 0
-
 	if (!(memcmp(dst, src, sz)))
 		return _TRUE;
 	else
 		return _FALSE;
-#endif
-
-
-#ifdef PLATFORM_WINDOWS
-//under Windows, the return value of NdisEqualMemory for two same mem. chunk is 1
-
-	if (NdisEqualMemory (dst, src, sz))
-		return _TRUE;
-	else
-		return _FALSE;
-
-#endif
-
-
-
 }
 
 void _rtw_memset(void *pbuf, int c, u32 sz)
 {
-
-#if defined (PLATFORM_LINUX)|| defined (PLATFORM_FREEBSD)
-
         memset(pbuf, c, sz);
-
-#endif
-
-#ifdef PLATFORM_WINDOWS
-#if 0
-	NdisZeroMemory(pbuf, sz);
-	if (c != 0) memset(pbuf, c, sz);
-#else
-	NdisFillMemory(pbuf, sz, c);
-#endif
-#endif
-
-}
-
-#ifdef PLATFORM_FREEBSD
-
-static inline void __list_add(_list *pnew, _list *pprev, _list *pnext)
- {
-         pnext->prev = pnew;
-         pnew->next = pnext;
-         pnew->prev = pprev;
-         pprev->next = pnew;
-}
-
-//review again
-struct sk_buff * dev_alloc_skb(unsigned int size)
-{
-	struct sk_buff *skb=NULL;
-	u8 *data=NULL;
-
-	//skb = (struct sk_buff *)_rtw_zmalloc(sizeof(struct sk_buff)); // for skb->len, etc.
-	skb = (struct sk_buff *)_rtw_malloc(sizeof(struct sk_buff));
-	if(!skb)
-		goto out;
-	data = _rtw_malloc(size);
-	if(!data)
-		goto nodata;
-
-	skb->head = (unsigned char*)data;
-	skb->data = (unsigned char*)data;
-	skb->tail = (unsigned char*)data;
-	skb->end = (unsigned char*)data + size;
-	skb->len = 0;
-	//printf("%s()-%d: skb=%p, skb->head = %p\n", __FUNCTION__, __LINE__, skb, skb->head);
-
-out:
-	return skb;
-nodata:
-	_rtw_mfree((u8 *)skb, sizeof(struct sk_buff));
-	skb = NULL;
-goto out;
-
-}
-
-void dev_kfree_skb_any(struct sk_buff *skb)
-{
-	//printf("%s()-%d: skb->head = %p\n", __FUNCTION__, __LINE__, skb->head);
-	if(skb->head)
-		_rtw_mfree(skb->head, 0);
-	//printf("%s()-%d: skb = %p\n", __FUNCTION__, __LINE__, skb);
-	if(skb)
-		_rtw_mfree((u8 *)skb, 0);
-}
-struct sk_buff *skb_clone(const struct sk_buff *skb)
-{
-	return NULL;
 }
 
-#endif
-
-
 void _rtw_init_listhead(_list *list)
 {
-
-#ifdef PLATFORM_LINUX
-
         INIT_LIST_HEAD(list);
-
-#endif
-
-#ifdef PLATFORM_FREEBSD
-         list->next = list;
-         list->prev = list;
-#endif
-#ifdef PLATFORM_WINDOWS
-
-        NdisInitializeListHead(list);
-
-#endif
-
 }
 
-
 /*
 For the following list_xxx operations,
 caller must guarantee the atomic context.
@@ -631,354 +406,94 @@ Otherwise, there will be racing conditio
 */
 u32	rtw_is_list_empty(_list *phead)
 {
-
-#ifdef PLATFORM_LINUX
-
 	if (list_empty(phead))
 		return _TRUE;
 	else
 		return _FALSE;
-
-#endif
-#ifdef PLATFORM_FREEBSD
-
-	if (phead->next == phead)
-		return _TRUE;
-	else
-		return _FALSE;
-
-#endif
-
-
-#ifdef PLATFORM_WINDOWS
-
-	if (IsListEmpty(phead))
-		return _TRUE;
-	else
-		return _FALSE;
-
-#endif
-
-
 }
 
 void rtw_list_insert_head(_list *plist, _list *phead)
 {
-
-#ifdef PLATFORM_LINUX
 	list_add(plist, phead);
-#endif
-
-#ifdef PLATFORM_FREEBSD
-	__list_add(plist, phead, phead->next);
-#endif
-
-#ifdef PLATFORM_WINDOWS
-	InsertHeadList(phead, plist);
-#endif
 }
 
 void rtw_list_insert_tail(_list *plist, _list *phead)
 {
-
-#ifdef PLATFORM_LINUX
-
 	list_add_tail(plist, phead);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-
-	__list_add(plist, phead->prev, phead);
-
-#endif
-#ifdef PLATFORM_WINDOWS
-
-  InsertTailList(phead, plist);
-
-#endif
-
 }
 
-
 /*
-
 Caller must check if the list is empty before calling rtw_list_delete
-
 */
 
-
 void _rtw_init_sema(_sema	*sema, int init_val)
 {
-
-#ifdef PLATFORM_LINUX
-
 	sema_init(sema, init_val);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	sema_init(sema, init_val, "rtw_drv");
-#endif
-#ifdef PLATFORM_OS_XP
-
-	KeInitializeSemaphore(sema, init_val,  SEMA_UPBND); // count=0;
-
-#endif
-
-#ifdef PLATFORM_OS_CE
-	if(*sema == NULL)
-		*sema = CreateSemaphore(NULL, init_val, SEMA_UPBND, NULL);
-#endif
-
 }
 
 void _rtw_free_sema(_sema	*sema)
 {
-#ifdef PLATFORM_FREEBSD
-	sema_destroy(sema);
-#endif
-#ifdef PLATFORM_OS_CE
-	CloseHandle(*sema);
-#endif
-
 }
 
 void _rtw_up_sema(_sema	*sema)
 {
-
-#ifdef PLATFORM_LINUX
-
 	up(sema);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	sema_post(sema);
-#endif
-#ifdef PLATFORM_OS_XP
-
-	KeReleaseSemaphore(sema, IO_NETWORK_INCREMENT, 1,  FALSE );
-
-#endif
-
-#ifdef PLATFORM_OS_CE
-	ReleaseSemaphore(*sema,  1,  NULL );
-#endif
 }
 
 u32 _rtw_down_sema(_sema *sema)
 {
-
-#ifdef PLATFORM_LINUX
-
 	if (down_interruptible(sema))
 		return _FAIL;
 	else
 		return _SUCCESS;
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	sema_wait(sema);
-	return  _SUCCESS;
-#endif
-#ifdef PLATFORM_OS_XP
-
-	if(STATUS_SUCCESS == KeWaitForSingleObject(sema, Executive, KernelMode, TRUE, NULL))
-		return  _SUCCESS;
-	else
-		return _FAIL;
-#endif
-
-#ifdef PLATFORM_OS_CE
-	if(WAIT_OBJECT_0 == WaitForSingleObject(*sema, INFINITE ))
-		return _SUCCESS;
-	else
-		return _FAIL;
-#endif
 }
 
-
-
 void	_rtw_mutex_init(_mutex *pmutex)
 {
-#ifdef PLATFORM_LINUX
-
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 	mutex_init(pmutex);
 #else
 	init_MUTEX(pmutex);
 #endif
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	mtx_init(pmutex, "", NULL, MTX_DEF|MTX_RECURSE);
-#endif
-#ifdef PLATFORM_OS_XP
-
-	KeInitializeMutex(pmutex, 0);
-
-#endif
-
-#ifdef PLATFORM_OS_CE
-	*pmutex =  CreateMutex( NULL, _FALSE, NULL);
-#endif
 }
 
 void	_rtw_mutex_free(_mutex *pmutex);
 void	_rtw_mutex_free(_mutex *pmutex)
 {
-#ifdef PLATFORM_LINUX
-
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 	mutex_destroy(pmutex);
-#else
-#endif
-
-#ifdef PLATFORM_FREEBSD
-	sema_destroy(pmutex);
-#endif
-
-#endif
-
-#ifdef PLATFORM_OS_XP
-
-#endif
-
-#ifdef PLATFORM_OS_CE
-
 #endif
 }
 
 void	_rtw_spinlock_init(_lock *plock)
 {
-
-#ifdef PLATFORM_LINUX
-
 	spin_lock_init(plock);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-		mtx_init(plock, "", NULL, MTX_DEF|MTX_RECURSE);
-#endif
-#ifdef PLATFORM_WINDOWS
-
-	NdisAllocateSpinLock(plock);
-
-#endif
-
 }
 
 void	_rtw_spinlock_free(_lock *plock)
 {
-#ifdef PLATFORM_FREEBSD
-	 mtx_destroy(plock);
-#endif
-
-#ifdef PLATFORM_WINDOWS
-
-	NdisFreeSpinLock(plock);
-
-#endif
-
 }
-#ifdef PLATFORM_FREEBSD
-extern PADAPTER prtw_lock;
-
-void rtw_mtx_lock(_lock *plock){
-	if(prtw_lock){
-		mtx_lock(&prtw_lock->glock);
-	}
-	else{
-		printf("%s prtw_lock==NULL",__FUNCTION__);
-	}
-}
-void rtw_mtx_unlock(_lock *plock){
-	if(prtw_lock){
-		mtx_unlock(&prtw_lock->glock);
-	}
-	else{
-		printf("%s prtw_lock==NULL",__FUNCTION__);
-	}
-
-}
-#endif //PLATFORM_FREEBSD
-
 
 void	_rtw_spinlock(_lock	*plock)
 {
-
-#ifdef PLATFORM_LINUX
-
 	spin_lock(plock);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	mtx_lock(plock);
-#endif
-#ifdef PLATFORM_WINDOWS
-
-	NdisAcquireSpinLock(plock);
-
-#endif
-
 }
 
 void	_rtw_spinunlock(_lock *plock)
 {
-
-#ifdef PLATFORM_LINUX
-
 	spin_unlock(plock);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	mtx_unlock(plock);
-#endif
-#ifdef PLATFORM_WINDOWS
-
-	NdisReleaseSpinLock(plock);
-
-#endif
 }
 
-
 void	_rtw_spinlock_ex(_lock	*plock)
 {
-
-#ifdef PLATFORM_LINUX
-
 	spin_lock(plock);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	mtx_lock(plock);
-#endif
-#ifdef PLATFORM_WINDOWS
-
-	NdisDprAcquireSpinLock(plock);
-
-#endif
-
 }
 
 void	_rtw_spinunlock_ex(_lock *plock)
 {
-
-#ifdef PLATFORM_LINUX
-
 	spin_unlock(plock);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	mtx_unlock(plock);
-#endif
-#ifdef PLATFORM_WINDOWS
-
-	NdisDprReleaseSpinLock(plock);
-
-#endif
 }
 
-
-
 void	_rtw_init_queue(_queue	*pqueue)
 {
 
@@ -1005,83 +520,32 @@ u32 rtw_end_of_queue_search(_list *head,
 
 u32	rtw_get_current_time(void)
 {
-
-#ifdef PLATFORM_LINUX
 	return jiffies;
-#endif
-#ifdef PLATFORM_FREEBSD
-	struct timeval tvp;
-	getmicrotime(&tvp);
-	return tvp.tv_sec;
-#endif
-#ifdef PLATFORM_WINDOWS
-	LARGE_INTEGER	SystemTime;
-	NdisGetCurrentSystemTime(&SystemTime);
-	return (u32)(SystemTime.LowPart);// count of 100-nanosecond intervals
-#endif
 }
 
 inline u32 rtw_systime_to_ms(u32 systime)
 {
-#ifdef PLATFORM_LINUX
 	return systime * 1000 / HZ;
-#endif
-#ifdef PLATFORM_FREEBSD
-	return systime * 1000;
-#endif
-#ifdef PLATFORM_WINDOWS
-	return systime / 10000 ;
-#endif
 }
 
 inline u32 rtw_ms_to_systime(u32 ms)
 {
-#ifdef PLATFORM_LINUX
 	return ms * HZ / 1000;
-#endif
-#ifdef PLATFORM_FREEBSD
-	return ms /1000;
-#endif
-#ifdef PLATFORM_WINDOWS
-	return ms / 10000 ;
-#endif
 }
 
 // the input parameter start use the same unit as returned by rtw_get_current_time
 inline s32 rtw_get_passing_time_ms(u32 start)
 {
-#ifdef PLATFORM_LINUX
 	return rtw_systime_to_ms(jiffies-start);
-#endif
-#ifdef PLATFORM_FREEBSD
-	return rtw_systime_to_ms(rtw_get_current_time());
-#endif
-#ifdef PLATFORM_WINDOWS
-	LARGE_INTEGER	SystemTime;
-	NdisGetCurrentSystemTime(&SystemTime);
-	return rtw_systime_to_ms((u32)(SystemTime.LowPart) - start) ;
-#endif
 }
 
 inline s32 rtw_get_time_interval_ms(u32 start, u32 end)
 {
-#ifdef PLATFORM_LINUX
-	return rtw_systime_to_ms(end-start);
-#endif
-#ifdef PLATFORM_FREEBSD
-	return rtw_systime_to_ms(rtw_get_current_time());
-#endif
-#ifdef PLATFORM_WINDOWS
 	return rtw_systime_to_ms(end-start);
-#endif
 }
 
-
 void rtw_sleep_schedulable(int ms)
 {
-
-#ifdef PLATFORM_LINUX
-
     u32 delta;
 
     delta = (ms * HZ)/1000;//(ms)
@@ -1093,176 +557,49 @@ void rtw_sleep_schedulable(int ms)
         return ;
     }
     return;
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	DELAY(ms*1000);
-	return ;
-#endif
-
-#ifdef PLATFORM_WINDOWS
-
-	NdisMSleep(ms*1000); //(us)*1000=(ms)
-
-#endif
-
 }
 
-
 void rtw_msleep_os(int ms)
 {
-
-#ifdef PLATFORM_LINUX
-
 	msleep((unsigned int)ms);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-       //Delay for delay microseconds
-	DELAY(ms*1000);
-	return ;
-#endif
-#ifdef PLATFORM_WINDOWS
-
-	NdisMSleep(ms*1000); //(us)*1000=(ms)
-
-#endif
-
-
 }
+
 void rtw_usleep_os(int us)
 {
-
-#ifdef PLATFORM_LINUX
-
       // msleep((unsigned int)us);
       if ( 1 < (us/1000) )
                 msleep(1);
       else
 		msleep( (us/1000) + 1);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	//Delay for delay microseconds
-	DELAY(us);
-
-	return ;
-#endif
-#ifdef PLATFORM_WINDOWS
-
-	NdisMSleep(us); //(us)
-
-#endif
-
-
 }
 
-
 #ifdef DBG_DELAY_OS
 void _rtw_mdelay_os(int ms, const char *func, const int line)
 {
-	#if 0
-	if(ms>10)
-		DBG_871X("%s:%d %s(%d)\n", func, line, __FUNCTION__, ms);
-		rtw_msleep_os(ms);
-	return;
-	#endif
-
-
 	DBG_871X("%s:%d %s(%d)\n", func, line, __FUNCTION__, ms);
-
-#if defined(PLATFORM_LINUX)
-
 	mdelay((unsigned long)ms);
-
-#elif defined(PLATFORM_WINDOWS)
-
-	NdisStallExecution(ms*1000); //(us)*1000=(ms)
-
-#endif
-
-
 }
+
 void _rtw_udelay_os(int us, const char *func, const int line)
 {
-
-	#if 0
-	if(us > 1000) {
-	DBG_871X("%s:%d %s(%d)\n", func, line, __FUNCTION__, us);
-		rtw_usleep_os(us);
-		return;
-	}
-	#endif
-
-
 	DBG_871X("%s:%d %s(%d)\n", func, line, __FUNCTION__, us);
-
-
-#if defined(PLATFORM_LINUX)
-
       udelay((unsigned long)us);
-
-#elif defined(PLATFORM_WINDOWS)
-
-	NdisStallExecution(us); //(us)
-
-#endif
-
 }
 #else
 void rtw_mdelay_os(int ms)
 {
-
-#ifdef PLATFORM_LINUX
-
 	mdelay((unsigned long)ms);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	DELAY(ms*1000);
-	return ;
-#endif
-#ifdef PLATFORM_WINDOWS
-
-	NdisStallExecution(ms*1000); //(us)*1000=(ms)
-
-#endif
-
-
 }
+
 void rtw_udelay_os(int us)
 {
-
-#ifdef PLATFORM_LINUX
-
       udelay((unsigned long)us);
-
-#endif
-#ifdef PLATFORM_FREEBSD
-	//Delay for delay microseconds
-	DELAY(us);
-	return ;
-#endif
-#ifdef PLATFORM_WINDOWS
-
-	NdisStallExecution(us); //(us)
-
-#endif
-
 }
 #endif
 
 void rtw_yield_os()
 {
-#ifdef PLATFORM_LINUX
 	yield();
-#endif
-#ifdef PLATFORM_FREEBSD
-	yield();
-#endif
-#ifdef PLATFORM_WINDOWS
-	SwitchToThread();
-#endif
 }
 
 #define RTW_SUSPEND_LOCK_NAME "rtw_wifi"
@@ -1314,119 +651,54 @@ inline void rtw_unlock_suspend()
 
 inline void ATOMIC_SET(ATOMIC_T *v, int i)
 {
-	#ifdef PLATFORM_LINUX
 	atomic_set(v,i);
-	#elif defined(PLATFORM_WINDOWS)
-	*v=i;// other choice????
-	#elif defined(PLATFORM_FREEBSD)
-	atomic_set_int(v,i);
-	#endif
 }
 
 inline int ATOMIC_READ(ATOMIC_T *v)
 {
-	#ifdef PLATFORM_LINUX
 	return atomic_read(v);
-	#elif defined(PLATFORM_WINDOWS)
-	return *v; // other choice????
-	#elif defined(PLATFORM_FREEBSD)
-	return atomic_load_acq_32(v);
-	#endif
 }
 
 inline void ATOMIC_ADD(ATOMIC_T *v, int i)
 {
-	#ifdef PLATFORM_LINUX
 	atomic_add(i,v);
-	#elif defined(PLATFORM_WINDOWS)
-	InterlockedAdd(v,i);
-	#elif defined(PLATFORM_FREEBSD)
-	atomic_add_int(v,i);
-	#endif
 }
+
 inline void ATOMIC_SUB(ATOMIC_T *v, int i)
 {
-	#ifdef PLATFORM_LINUX
 	atomic_sub(i,v);
-	#elif defined(PLATFORM_WINDOWS)
-	InterlockedAdd(v,-i);
-	#elif defined(PLATFORM_FREEBSD)
-	atomic_subtract_int(v,i);
-	#endif
 }
 
 inline void ATOMIC_INC(ATOMIC_T *v)
 {
-	#ifdef PLATFORM_LINUX
 	atomic_inc(v);
-	#elif defined(PLATFORM_WINDOWS)
-	InterlockedIncrement(v);
-	#elif defined(PLATFORM_FREEBSD)
-	atomic_add_int(v,1);
-	#endif
 }
 
 inline void ATOMIC_DEC(ATOMIC_T *v)
 {
-	#ifdef PLATFORM_LINUX
 	atomic_dec(v);
-	#elif defined(PLATFORM_WINDOWS)
-	InterlockedDecrement(v);
-	#elif defined(PLATFORM_FREEBSD)
-	atomic_subtract_int(v,1);
-	#endif
 }
 
 inline int ATOMIC_ADD_RETURN(ATOMIC_T *v, int i)
 {
-	#ifdef PLATFORM_LINUX
 	return atomic_add_return(i,v);
-	#elif defined(PLATFORM_WINDOWS)
-	return InterlockedAdd(v,i);
-	#elif defined(PLATFORM_FREEBSD)
-	atomic_add_int(v,i);
-	return atomic_load_acq_32(v);
-	#endif
 }
 
 inline int ATOMIC_SUB_RETURN(ATOMIC_T *v, int i)
 {
-	#ifdef PLATFORM_LINUX
 	return atomic_sub_return(i,v);
-	#elif defined(PLATFORM_WINDOWS)
-	return InterlockedAdd(v,-i);
-	#elif defined(PLATFORM_FREEBSD)
-	atomic_subtract_int(v,i);
-	return atomic_load_acq_32(v);
-	#endif
 }
 
 inline int ATOMIC_INC_RETURN(ATOMIC_T *v)
 {
-	#ifdef PLATFORM_LINUX
 	return atomic_inc_return(v);
-	#elif defined(PLATFORM_WINDOWS)
-	return InterlockedIncrement(v);
-	#elif defined(PLATFORM_FREEBSD)
-	atomic_add_int(v,1);
-	return atomic_load_acq_32(v);
-	#endif
 }
 
 inline int ATOMIC_DEC_RETURN(ATOMIC_T *v)
 {
-	#ifdef PLATFORM_LINUX
 	return atomic_dec_return(v);
-	#elif defined(PLATFORM_WINDOWS)
-	return InterlockedDecrement(v);
-	#elif defined(PLATFORM_FREEBSD)
-	atomic_subtract_int(v,1);
-	return atomic_load_acq_32(v);
-	#endif
 }
 
-
-#ifdef PLATFORM_LINUX
 /*
 * Open a file with the specific @param path, @param flag, @param mode
 * @param fpp the pointer of struct file pointer to get struct file pointer while file opening is success
@@ -1598,7 +870,6 @@ static int storeToFile(char *path, u8* b
 	}
 	return ret;
 }
-#endif //PLATFORM_LINUX
 
 /*
 * Test if the specifi @param path is a file and readable
@@ -1607,15 +878,10 @@ static int storeToFile(char *path, u8* b
 */
 int rtw_is_file_readable(char *path)
 {
-#ifdef PLATFORM_LINUX
 	if(isFileReadable(path) == 0)
 		return _TRUE;
 	else
 		return _FALSE;
-#else
-	//Todo...
-	return _FALSE;
-#endif
 }
 
 /*
@@ -1627,13 +893,8 @@ int rtw_is_file_readable(char *path)
 */
 int rtw_retrive_from_file(char *path, u8* buf, u32 sz)
 {
-#ifdef PLATFORM_LINUX
 	int ret =retriveFromFile(path, buf, sz);
 	return ret>=0?ret:0;
-#else
-	//Todo...
-	return 0;
-#endif
 }
 
 /*
@@ -1645,17 +906,10 @@ int rtw_retrive_from_file(char *path, u8
 */
 int rtw_store_to_file(char *path, u8* buf, u32 sz)
 {
-#ifdef PLATFORM_LINUX
 	int ret =storeToFile(path, buf, sz);
 	return ret>=0?ret:0;
-#else
-	//Todo...
-	return 0;
-#endif
 }
 
-#if 1 //#ifdef MEM_ALLOC_REFINE_ADAPTOR
-#ifdef PLATFORM_LINUX
 struct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv)
 {
 	struct net_device *pnetdev;
@@ -1789,99 +1043,16 @@ error:
 	return -1;
 
 }
-#endif
-#endif //MEM_ALLOC_REFINE_ADAPTOR
 
-#ifdef PLATFORM_FREEBSD
-/*
- * Copy a buffer from userspace and write into kernel address
- * space.
- *
- * This emulation just calls the FreeBSD copyin function (to
- * copy data from user space buffer into a kernel space buffer)
- * and is designed to be used with the above io_write_wrapper.
- *
- * This function should return the number of bytes not copied.
- * I.e. success results in a zero value.
- * Negative error values are not returned.
- */
-unsigned long
-copy_from_user(void *to, const void *from, unsigned long n)
-{
-        if ( copyin(from, to, n) != 0 ) {
-                /* Any errors will be treated as a failure
-                   to copy any of the requested bytes */
-                return n;
-        }
-
-        return 0;
-}
-
-unsigned long
-copy_to_user(void *to, const void *from, unsigned long n)
-{
-	if ( copyout(from, to, n) != 0 ) {
-		/* Any errors will be treated as a failure
-		   to copy any of the requested bytes */
-		return n;
-	}
-
-	return 0;
-}
-
-
-/*
- * The usb_register and usb_deregister functions are used to register
- * usb drivers with the usb subsystem. In this compatibility layer
- * emulation a list of drivers (struct usb_driver) is maintained
- * and is used for probing/attaching etc.
- *
- * usb_register and usb_deregister simply call these functions.
- */
-int
-usb_register(struct usb_driver *driver)
-{
-        rtw_usb_linux_register(driver);
-        return 0;
-}
-
-
-int
-usb_deregister(struct usb_driver *driver)
-{
-        rtw_usb_linux_deregister(driver);
-        return 0;
-}
-
-void module_init_exit_wrapper(void *arg)
-{
-        int (*func)(void) = arg;
-        func();
-        return;
-}
-
-#endif //PLATFORM_FREEBSD
 u64 rtw_modular64(u64 x, u64 y)
 {
-#ifdef PLATFORM_LINUX
 	return do_div(x, y);
-#elif defined(PLATFORM_WINDOWS)
-	return (x % y);
-#elif defined(PLATFORM_FREEBSD)
-	return (x %y);
-#endif
 }
 
 u64 rtw_division64(u64 x, u64 y)
 {
-#ifdef PLATFORM_LINUX
 	do_div(x, y);
 	return x;
-#elif defined(PLATFORM_WINDOWS)
-	return (x / y);
-#elif defined(PLATFORM_FREEBSD)
-	return (x / y);
-#endif
 }
 
 void rtw_buf_free(u8 **buf, u32 *buf_len)

From ee8c07c41ffaccf74a449de008cb8d7c88ad293c Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sat, 4 May 2013 20:10:59 -0500
Subject: [PATCH 125/390] Cheanup "( ", " )" and blank lines after "{"

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_debug.c         |    2 -
 core/rtw_efuse.c         |    9 -
 core/rtw_io.c            |   10 +-
 core/rtw_ioctl_set.c     |   66 +--
 core/rtw_mlme.c          |  158 +++----
 core/rtw_mlme_ext.c      | 1115 +++++++++++++++++++++-------------------------
 core/rtw_p2p.c           |  967 +++++++++++++++++++---------------------
 core/rtw_pwrctrl.c       |   38 +-
 core/rtw_recv.c          |  131 ++----
 core/rtw_security.c      |  127 +++---
 core/rtw_sreset.c        |    2 +-
 core/rtw_sta_mgt.c       |   34 +-
 core/rtw_tdls.c          |  213 ++++-----
 core/rtw_wlan_util.c     |   89 ++--
 core/rtw_xmit.c          |   66 +--
 hal/hal_intf.c           |    4 -
 hal/rtl8192d_cmd.c       |   45 +-
 hal/rtl8192d_dm.c        |   75 ++--
 hal/rtl8192d_hal_init.c  |   72 ++-
 hal/rtl8192d_mp.c        |   56 +--
 hal/rtl8192d_phycfg.c    |   82 +---
 hal/rtl8192d_rf6052.c    |   17 +-
 hal/rtl8192d_rxdesc.c    |   22 +-
 hal/rtl8192du_led.c      |  312 +++++++------
 hal/rtl8192du_recv.c     |    2 -
 hal/rtl8192du_xmit.c     |   16 +-
 hal/usb_halinit.c        |  154 +++----
 hal/usb_ops_linux.c      |   60 +--
 include/Hal8192DPhyCfg.h |    2 +-
 include/basic_types.h    |   36 +-
 include/drv_conf.h       |    2 +-
 include/hal_com.h        |    2 +-
 include/if_ether.h       |    6 +-
 include/mlme_osdep.h     |    6 +-
 include/osdep_service.h  |    6 +-
 include/rtl8192d_cmd.h   |    2 +-
 include/rtl8192d_hal.h   |    4 +-
 include/rtl8192d_rf.h    |    2 +-
 include/rtl8192d_spec.h  |    8 +-
 include/rtw_cmd.h        |    2 +-
 include/rtw_debug.h      |    2 +-
 include/rtw_efuse.h      |    4 +-
 include/rtw_io.h         |    4 +-
 include/rtw_mlme_ext.h   |    4 +-
 include/rtw_mp.h         |    4 +-
 include/rtw_p2p.h        |    8 +-
 include/rtw_pwrctrl.h    |    4 +-
 include/rtw_recv.h       |    6 +-
 include/rtw_security.h   |   18 +-
 include/swab.h           |    8 +-
 include/swabb.h          |   16 +-
 include/usb_ops.h        |    2 +-
 include/wifi.h           |   16 +-
 os_dep/ioctl_cfg80211.c  |  167 +++----
 os_dep/ioctl_linux.c     |  109 +----
 os_dep/mlme_linux.c      |   18 +-
 os_dep/os_intfs.c        |   28 +-
 os_dep/osdep_service.c   |   15 +-
 os_dep/recv_linux.c      |   27 +-
 os_dep/rtw_android.c     |   26 +-
 os_dep/usb_intf.c        |   45 +-
 os_dep/usb_ops_linux.c   |   13 +-
 os_dep/xmit_linux.c      |   11 +-
 63 files changed, 1939 insertions(+), 2638 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_debug.c
+++ b/drivers/staging/rtl8192du/core/rtw_debug.c
@@ -424,7 +424,6 @@ int proc_get_mac_reg_dump1(char *page, c
 
 	*eof = 1;
 	return len;
-
 }
 
 int proc_get_mac_reg_dump2(char *page, char **start,
@@ -448,7 +447,6 @@ int proc_get_mac_reg_dump2(char *page, c
 
 	*eof = 1;
 	return len;
-
 }
 
 int proc_get_mac_reg_dump3(char *page, char **start,
--- a/drivers/staging/rtl8192du/core/rtw_efuse.c
+++ b/drivers/staging/rtl8192du/core/rtw_efuse.c
@@ -260,7 +260,6 @@ u8 EFUSE_Read1Byte(struct rtw_adapter *A
 	} else {
 		return 0xFF;
 	}
-
 } /* EFUSE_Read1Byte */
 
 /*-----------------------------------------------------------------------------
@@ -677,7 +676,6 @@ static void efuse_ShadowRead1Byte(struct
 	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(pAdapter);
 
 	*value = pEEPROM->efuse_eeprom_data[Offset];
-
 }	/*  EFUSE_ShadowRead1Byte */
 
 /* Read Two Bytes */
@@ -687,7 +685,6 @@ static void efuse_ShadowRead2Byte(struct
 
 	*value = pEEPROM->efuse_eeprom_data[Offset];
 	*value |= pEEPROM->efuse_eeprom_data[Offset+1]<<8;
-
 }	/*  EFUSE_ShadowRead2Byte */
 
 /* Read Four Bytes */
@@ -699,7 +696,6 @@ static void efuse_ShadowRead4Byte(struct
 	*value |= pEEPROM->efuse_eeprom_data[Offset+1]<<8;
 	*value |= pEEPROM->efuse_eeprom_data[Offset+2]<<16;
 	*value |= pEEPROM->efuse_eeprom_data[Offset+3]<<24;
-
 }	/*  efuse_ShadowRead4Byte */
 
 
@@ -726,7 +722,6 @@ static void efuse_ShadowWrite1Byte(struc
 	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(pAdapter);
 
 	pEEPROM->efuse_eeprom_data[Offset] = value;
-
 }	/*  efuse_ShadowWrite1Byte */
 
 /* Write Two Bytes */
@@ -736,7 +731,6 @@ static void efuse_ShadowWrite2Byte(struc
 
 	pEEPROM->efuse_eeprom_data[Offset] = value&0x00FF;
 	pEEPROM->efuse_eeprom_data[Offset+1] = value>>8;
-
 }	/*  efuse_ShadowWrite1Byte */
 
 /* Write Four Bytes */
@@ -748,7 +742,6 @@ static void efuse_ShadowWrite4Byte(struc
 	EEPROM->efuse_eeprom_data[Offset+1] = (u8)((value>>8)&0x0000FF);
 	EEPROM->efuse_eeprom_data[Offset+2] = (u8)((value>>16)&0x00FF);
 	EEPROM->efuse_eeprom_data[Offset+3] = (u8)((value>>24)&0xFF);
-
 }	/*  efuse_ShadowWrite1Byte */
 
 /*-----------------------------------------------------------------------------
@@ -814,7 +807,6 @@ void EFUSE_ShadowRead(struct rtw_adapter
 		efuse_ShadowRead2Byte(pAdapter, Offset, (u16 *)value);
 	else if (Type == 4)
 		efuse_ShadowRead4Byte(pAdapter, Offset, (u32 *)value);
-
 }	/*  EFUSE_ShadowRead */
 
 /*-----------------------------------------------------------------------------
@@ -845,7 +837,6 @@ void EFUSE_ShadowWrite(struct rtw_adapte
 		efuse_ShadowWrite2Byte(pAdapter, Offset, (u16)value);
 	else if (Type == 4)
 		efuse_ShadowWrite4Byte(pAdapter, Offset, (u32)value);
-
 }	/*  EFUSE_ShadowWrite */
 
 void Efuse_InitSomeVar(struct rtw_adapter *pAdapter)
--- a/drivers/staging/rtl8192du/core/rtw_io.c
+++ b/drivers/staging/rtl8192du/core/rtw_io.c
@@ -90,7 +90,6 @@ u32 _rtw_read32(struct rtw_adapter *adap
 	r_val = _read32(pintfhdl, addr);
 	_func_exit_;
 	return r_val;
-
 }
 
 int _rtw_write8(struct rtw_adapter *adapter, u32 addr, u8 val)
@@ -208,7 +207,7 @@ void _rtw_read_mem(struct rtw_adapter *a
 
 	_func_enter_;
 
-	if ( (adapter->bDriverStopped ==true) || (adapter->bSurpriseRemoved == true))
+	if ((adapter->bDriverStopped ==true) || (adapter->bSurpriseRemoved == true))
 	{
 	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_mem:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));
 	     return;
@@ -219,7 +218,6 @@ void _rtw_read_mem(struct rtw_adapter *a
 	_read_mem(pintfhdl, addr, cnt, pmem);
 
 	_func_exit_;
-
 }
 
 void _rtw_write_mem(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
@@ -236,7 +234,6 @@ void _rtw_write_mem(struct rtw_adapter *
 	_write_mem(pintfhdl, addr, cnt, pmem);
 
 	_func_exit_;
-
 }
 
 void _rtw_read_port(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
@@ -248,7 +245,7 @@ void _rtw_read_port(struct rtw_adapter *
 
 	_func_enter_;
 
-	if ( (adapter->bDriverStopped ==true) || (adapter->bSurpriseRemoved == true))
+	if ((adapter->bDriverStopped ==true) || (adapter->bSurpriseRemoved == true))
 	{
 	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_port:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));
 	     return;
@@ -259,7 +256,6 @@ void _rtw_read_port(struct rtw_adapter *
 	_read_port(pintfhdl, addr, cnt, pmem);
 
 	_func_exit_;
-
 }
 
 void _rtw_read_port_cancel(struct rtw_adapter *adapter)
@@ -272,7 +268,6 @@ void _rtw_read_port_cancel(struct rtw_ad
 
 	if (_read_port_cancel)
 		_read_port_cancel(pintfhdl);
-
 }
 
 u32 _rtw_write_port(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
@@ -321,7 +316,6 @@ void _rtw_write_port_cancel(struct rtw_a
 
 	if (_write_port_cancel)
 		_write_port_cancel(pintfhdl);
-
 }
 
 int rtw_init_io_priv(struct rtw_adapter *padapter, void (*set_intf_ops)(struct _io_ops *pops))
--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -31,10 +31,10 @@
 extern void indicate_wx_scan_complete_event(struct rtw_adapter *padapter);
 
 #define IS_MAC_ADDRESS_BROADCAST(addr) \
-( \
-	( (addr[0] == 0xff) && (addr[1] == 0xff) && \
+(\
+	((addr[0] == 0xff) && (addr[1] == 0xff) && \
 		(addr[2] == 0xff) && (addr[3] == 0xff) && \
-		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? true : false \
+		(addr[4] == 0xff) && (addr[5] == 0xff))  ? true : false \
 )
 
 u8 rtw_validate_ssid(struct ndis_802_11_ssid *ssid)
@@ -53,7 +53,7 @@ _func_enter_;
 	for (i = 0; i < ssid->SsidLength; i++)
 	{
 		//wifi, printable ascii code must be supported
-		if (!( (ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e) )){
+		if (!((ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e))){
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid has nonprintabl ascii\n"));
 			ret= false;
 			break;
@@ -106,7 +106,7 @@ _func_enter_;
 		{
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_do_join(): site survey if scanned_queue is empty\n."));
 			// submit site_survey_cmd
-			if (_SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)) ) {
+			if (_SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0))) {
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_do_join(): site survey return error\n."));
 			}
 		}
@@ -187,7 +187,7 @@ _func_enter_;
 				)
 				{
 					//DBG_8192D("rtw_do_join() when   no desired bss in scanning queue\n");
-					if ( _SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)) ){
+					if (_SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0))){
 						RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("do_join(): site survey return error\n."));
 					}
 				}
@@ -269,7 +269,7 @@ handle_tkip_countermeasure:
 	if (padapter->securitypriv.btkip_countermeasure == true) {
 		cur_time = rtw_get_current_time();
 
-		if ( (cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ )
+		if ((cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ)
 		{
 			padapter->securitypriv.btkip_countermeasure = false;
 			padapter->securitypriv.btkip_countermeasure_time = 0;
@@ -398,7 +398,7 @@ handle_tkip_countermeasure:
 	if (padapter->securitypriv.btkip_countermeasure == true) {
 		cur_time = rtw_get_current_time();
 
-		if ( (cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ )
+		if ((cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ)
 		{
 			padapter->securitypriv.btkip_countermeasure = false;
 			padapter->securitypriv.btkip_countermeasure_time = 0;
@@ -437,7 +437,6 @@ exit:
 _func_exit_;
 
 	return status;
-
 }
 
 /*
@@ -460,7 +459,6 @@ _func_enter_;
 
 	if (*pold_state != networktype)
 	{
-
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,(" change mode!"));
 		//DBG_8192D("change mode, old_mode=%d, new_mode=%d, fw_state=0x%x\n", *pold_state, networktype, get_fwstate(pmlmepriv));
 
@@ -477,7 +475,7 @@ _func_enter_;
 			rtw_disassoc_cmd(padapter, 0, true);
 
 		if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) ||
-			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)== true) )
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)== true))
 			rtw_free_assoc_resources(padapter, 0);
 
 		if ((*pold_state == NDIS802_11INFRA) ||(*pold_state == NDIS802_11IBSS))
@@ -519,7 +517,7 @@ _func_enter_;
 		//SecClearAllKeys(adapter);
 
 		//RT_TRACE(COMP_OID_SET, DBG_LOUD, ("set_infrastructure: fw_state:%x after changing mode\n",
-		//									get_fwstate(pmlmepriv) ));
+		//									get_fwstate(pmlmepriv)));
 
 	}
 
@@ -634,7 +632,6 @@ _func_exit_;
 }
 
 u8 rtw_set_802_11_add_wep(struct rtw_adapter* padapter, struct ndis_802_11_wep *wep){
-
 	u8		bdefaultkey;
 	u8		btransmitkey;
 	int		keyid,res;
@@ -694,17 +691,14 @@ exit:
 _func_exit_;
 
 	return ret;
-
 }
 
 u8 rtw_set_802_11_remove_wep(struct rtw_adapter* padapter, u32 keyindex){
-
 	u8 ret=_SUCCESS;
 
 _func_enter_;
 
 	if (keyindex >= 0x80000000 || padapter == NULL){
-
 		ret=false;
 		goto exit;
 
@@ -713,8 +707,7 @@ _func_enter_;
 	{
 		int res;
 		struct security_priv* psecuritypriv=&(padapter->securitypriv);
-		if ( keyindex < 4 ){
-
+		if (keyindex < 4){
 			memset(&psecuritypriv->dot11DefKey[keyindex], 0, 16);
 
 			res=rtw_set_key(padapter,psecuritypriv,keyindex, 0);
@@ -737,11 +730,9 @@ exit:
 _func_exit_;
 
 	return ret;
-
 }
 
 u8 rtw_set_802_11_add_key(struct rtw_adapter* padapter, struct ndis_802_11_key *key){
-
 	uint	encryptionalgo;
 	u8 * pbssid;
 	struct sta_info *stainfo;
@@ -752,7 +743,6 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 _func_enter_;
 
 	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)){
-
 		// It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination,
 		// it must fail the request and return NDIS_STATUS_INVALID_DATA.
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_add_key: ((key->KeyIndex & 0x80000000) == 0)[=%d] ",(int)(key->KeyIndex & 0x80000000) == 0));
@@ -772,7 +762,7 @@ _func_enter_;
 		stainfo=rtw_get_stainfo(&padapter->stapriv, pbssid);
 
 		if ((stainfo!=NULL)&&(padapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)){
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY:( stainfo!=NULL)&&(Adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)\n"));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY:(stainfo!=NULL)&&(Adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)\n"));
 			encryptionalgo=stainfo->dot118021XPrivacy;
 		}
 		else{
@@ -780,7 +770,7 @@ _func_enter_;
 			encryptionalgo=padapter->securitypriv.dot11PrivacyAlgrthm;
 		}
 
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (encryptionalgo ==%d)!\n",encryptionalgo ));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (encryptionalgo ==%d)!\n",encryptionalgo));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (Adapter->securitypriv.dot11PrivacyAlgrthm ==%d)!\n",padapter->securitypriv.dot11PrivacyAlgrthm));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (Adapter->securitypriv.dot11AuthAlgrthm ==%d)!\n",padapter->securitypriv.dot11AuthAlgrthm));
 
@@ -799,7 +789,6 @@ _func_enter_;
 
 		// check BSSID
 		if (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == true){
-
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("MacAddr_isBcst(key->BSSID)\n"));
 			ret= false;
 			goto exit;
@@ -852,7 +841,7 @@ _func_enter_;
 		// when add wep key through add key and didn't assigned encryption type before
 		if ((padapter->securitypriv.ndisauthtype<=3)&&(padapter->securitypriv.dot118021XGrpPrivacy==0))
 		{
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("keylen=%d( Adapter->securitypriv.dot11PrivacyAlgrthm=%x  )padapter->securitypriv.dot118021XGrpPrivacy(%x)\n", key->KeyLength,padapter->securitypriv.dot11PrivacyAlgrthm,padapter->securitypriv.dot118021XGrpPrivacy));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("keylen=%d(Adapter->securitypriv.dot11PrivacyAlgrthm=%x )padapter->securitypriv.dot118021XGrpPrivacy(%x)\n", key->KeyLength,padapter->securitypriv.dot11PrivacyAlgrthm,padapter->securitypriv.dot118021XGrpPrivacy));
 
 			switch (key->KeyLength)
 			{
@@ -878,7 +867,7 @@ _func_enter_;
 		else
 		{
 			encryptionalgo=padapter->securitypriv.dot118021XGrpPrivacy;
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("( Adapter->securitypriv.dot11PrivacyAlgrthm=%x  )encryptionalgo(%x)=padapter->securitypriv.dot118021XGrpPrivacy(%x)keylen=%d\n", padapter->securitypriv.dot11PrivacyAlgrthm,encryptionalgo,padapter->securitypriv.dot118021XGrpPrivacy,key->KeyLength));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("(Adapter->securitypriv.dot11PrivacyAlgrthm=%x )encryptionalgo(%x)=padapter->securitypriv.dot118021XGrpPrivacy(%x)keylen=%d\n", padapter->securitypriv.dot11PrivacyAlgrthm,encryptionalgo,padapter->securitypriv.dot118021XGrpPrivacy,key->KeyLength));
 
 		}
 
@@ -890,13 +879,11 @@ _func_enter_;
 
 		// Check key length for TKIP
 		if ((encryptionalgo== _TKIP_) && (key->KeyLength != 32)) {
-
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" TKIP GTK KeyLength:%u != 32\n", key->KeyLength));
 			ret= _FAIL;
 			goto exit;
 
-		} else if (encryptionalgo== _AES_ && (key->KeyLength != 16 && key->KeyLength != 32) ) {
-
+		} else if (encryptionalgo== _AES_ && (key->KeyLength != 16 && key->KeyLength != 32)) {
 			// Check key length for AES
 			// For NDTEST, we allow keylen=32 in this case. 2005.01.27, by rcnjko.
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("<=== SetInfo, OID_802_11_ADD_KEY: AES GTK KeyLength:%u != 16 or 32\n", key->KeyLength));
@@ -905,9 +892,9 @@ _func_enter_;
 		}
 
 		// Change the key length for EAPPkt9x.vxd. Added by Annie, 2005-11-03.
-		if ((encryptionalgo==  _AES_) && (key->KeyLength == 32) ) {
+		if ((encryptionalgo==  _AES_) && (key->KeyLength == 32)) {
 			key->KeyLength = 16;
-			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("AES key length changed: %u\n", key->KeyLength) );
+			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("AES key length changed: %u\n", key->KeyLength));
 		}
 
 		if (key->KeyIndex & 0x8000000) {//error ??? 0x8000_0000
@@ -921,8 +908,8 @@ _func_enter_;
 
 		bgroup = true;
 
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n") );
-		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("[Group Key set]\n") );
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("[Group Key set]\n"));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n")) ;
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key index: 0x%8x(0x%8x)\n", key->KeyIndex,(key->KeyIndex&0x3)));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key Length: %d\n", key->KeyLength)) ;
@@ -1046,11 +1033,11 @@ _func_enter_;
 		u8 res;
 
 		pbssid=get_bssid(&padapter->mlmepriv);
-		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid );
+		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid);
 
 		if (stainfo!=NULL)
 		{
-			memset( &stainfo->dot118021x_UncstKey, 0, 16);// clear keybuffer
+			memset(&stainfo->dot118021x_UncstKey, 0, 16);// clear keybuffer
 
 			memcpy(&stainfo->dot118021x_UncstKey, key->KeyMaterial, 16);
 
@@ -1076,7 +1063,6 @@ _func_enter_;
 			}
 			else if (encryptionalgo == _AES_)
 			{
-
 			}
 
 
@@ -1106,7 +1092,6 @@ _func_exit_;
 }
 
 u8 rtw_set_802_11_remove_key(struct rtw_adapter*	padapter, struct ndis_802_11_remove_key *key){
-
 	uint				encryptionalgo;
 	u8 * pbssid;
 	struct sta_info *stainfo;
@@ -1130,11 +1115,9 @@ _func_enter_;
 		memset(&padapter->securitypriv.dot118021XGrpKey[keyIndex], 0, 16);
 
 		//! \todo Send a H2C Command to Firmware for removing this Key in CAM Entry.
-
 	} else {
-
 		pbssid=get_bssid(&padapter->mlmepriv);
-		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid );
+		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid);
 		if (stainfo !=NULL){
 			encryptionalgo=stainfo->dot118021XPrivacy;
 
@@ -1155,7 +1138,6 @@ exit:
 _func_exit_;
 
 	return true;
-
 }
 
 /*
@@ -1224,7 +1206,7 @@ u16 rtw_get_cur_max_rate(struct rtw_adap
 	else
 #endif //CONFIG_80211N_HT
 	{
-		while ( (pcur_bss->SupportedRates[i]!=0) && (pcur_bss->SupportedRates[i]!=0xFF))
+		while ((pcur_bss->SupportedRates[i]!=0) && (pcur_bss->SupportedRates[i]!=0xFF))
 		{
 			rate = pcur_bss->SupportedRates[i]&0x7F;
 			if (rate>max_rate)
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -143,7 +143,6 @@ void rtw_free_mlme_priv_ie_data(struct m
 	rtw_free_mlme_ie_data(&pmlmepriv->wfd_go_probe_resp_ie, &pmlmepriv->wfd_go_probe_resp_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->wfd_assoc_req_ie, &pmlmepriv->wfd_assoc_req_ie_len);
 #endif
-
 }
 
 void _rtw_free_mlme_priv (struct mlme_priv *pmlmepriv)
@@ -164,7 +163,6 @@ _func_exit_;
 
 int	_rtw_enqueue_network(struct __queue *queue, struct wlan_network *pnetwork)
 {
-
 _func_enter_;
 
 	if (pnetwork == NULL)
@@ -185,7 +183,6 @@ _func_exit_;
 
 struct	wlan_network *_rtw_dequeue_network(struct __queue *queue)
 {
-
 	struct wlan_network *pnetwork;
 
 _func_enter_;
@@ -210,7 +207,7 @@ _func_exit_;
 	return pnetwork;
 }
 
-struct	wlan_network *_rtw_alloc_network(struct	mlme_priv *pmlmepriv )//(struct __queue *free_queue)
+struct	wlan_network *_rtw_alloc_network(struct	mlme_priv *pmlmepriv)//(struct __queue *free_queue)
 {
 	struct	wlan_network	*pnetwork;
 	struct __queue *free_queue = &pmlmepriv->free_bss_pool;
@@ -263,8 +260,8 @@ _func_enter_;
 
 	curr_time = rtw_get_current_time();
 
-	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==true ) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true ) )
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true))
 		lifetime = 1;
 
 	if (!isfreeall)
@@ -290,12 +287,10 @@ _func_enter_;
 exit:
 
 _func_exit_;
-
 }
 
 void _rtw_free_network_nolock(struct	mlme_priv *pmlmepriv, struct wlan_network *pnetwork)
 {
-
 	struct __queue *free_queue = &(pmlmepriv->free_bss_pool);
 
 _func_enter_;
@@ -315,7 +310,6 @@ _func_enter_;
 exit:
 
 _func_exit_;
-
 }
 
 
@@ -326,7 +320,6 @@ _func_exit_;
 */
 struct wlan_network *_rtw_find_network(struct __queue *scanned_queue, u8 *addr)
 {
-
 	struct list_head *phead, *plist;
 	struct	wlan_network *pnetwork = NULL;
 	u8 zero_addr[ETH_ALEN] = {0,0,0,0,0,0};
@@ -363,7 +356,6 @@ exit:
 _func_exit_;
 
 	return pnetwork;
-
 }
 
 
@@ -384,7 +376,6 @@ _func_enter_;
 
 	while (rtw_end_of_queue_search(phead, plist) == false)
 	{
-
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
 		plist = get_next(plist);
@@ -396,18 +387,16 @@ _func_enter_;
 	spin_unlock_bh(&scanned_queue->lock);
 
 _func_exit_;
-
 }
 
 
 
 
 int rtw_if_up(struct rtw_adapter *padapter)	{
-
 	int res;
 _func_enter_;
 
-	if ( padapter->bDriverStopped || padapter->bSurpriseRemoved ||
+	if (padapter->bDriverStopped || padapter->bSurpriseRemoved ||
 		(check_fwstate(&padapter->mlmepriv, _FW_LINKED)== false)){
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_if_up:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
 		res=false;
@@ -499,7 +488,7 @@ _func_exit_;
 	return pnetwork;
 }
 
-struct	wlan_network *rtw_alloc_network(struct	mlme_priv *pmlmepriv )//(struct __queue	*free_queue)
+struct	wlan_network *rtw_alloc_network(struct	mlme_priv *pmlmepriv)//(struct __queue	*free_queue)
 {
 	struct	wlan_network	*pnetwork;
 _func_enter_;
@@ -516,8 +505,8 @@ _func_enter_;
 _func_exit_;
 }
 
-void rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork );
-void rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork )
+void rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork);
+void rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork)
 {
 _func_enter_;
 	//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s\n\n" , pnetwork->network.Ssid.Ssid));
@@ -550,13 +539,13 @@ int rtw_is_same_ibss(struct rtw_adapter
 	int ret=true;
 	struct security_priv *psecuritypriv = &adapter->securitypriv;
 
-	if ( (psecuritypriv->dot11PrivacyAlgrthm != _NO_PRIVACY_ ) &&
-		    ( pnetwork->network.Privacy == 0 ) )
+	if ((psecuritypriv->dot11PrivacyAlgrthm != _NO_PRIVACY_) &&
+		    (pnetwork->network.Privacy == 0))
 	{
 		ret=false;
 	}
-	else if ((psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_ ) &&
-		 ( pnetwork->network.Privacy == 1 ) )
+	else if ((psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_) &&
+		 (pnetwork->network.Privacy == 1))
 	{
 		ret=false;
 	}
@@ -566,7 +555,6 @@ int rtw_is_same_ibss(struct rtw_adapter
 	}
 
 	return ret;
-
 }
 
 inline int is_same_ess(struct wlan_bssid_ex *a, struct wlan_bssid_ex *b);
@@ -595,13 +583,12 @@ _func_exit_;
 
 	return ((src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
 		//	(src->Configuration.DSConfig == dst->Configuration.DSConfig) &&
-			( (_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == true) &&
-			( (_rtw_memcmp(src->Ssid.Ssid, dst->Ssid.Ssid, src->Ssid.SsidLength)) == true) &&
+			((_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == true) &&
+			((_rtw_memcmp(src->Ssid.Ssid, dst->Ssid.Ssid, src->Ssid.SsidLength)) == true) &&
 			((s_cap & WLAN_CAPABILITY_IBSS) ==
 			(d_cap & WLAN_CAPABILITY_IBSS)) &&
 			((s_cap & WLAN_CAPABILITY_BSS) ==
 			(d_cap & WLAN_CAPABILITY_BSS)));
-
 }
 
 struct	wlan_network	* rtw_get_oldest_wlan_network(struct __queue *scanned_queue)
@@ -616,7 +603,6 @@ _func_enter_;
 
 	while (1)
 	{
-
 		if (rtw_end_of_queue_search(phead,plist)== true)
 			break;
 
@@ -632,7 +618,6 @@ _func_enter_;
 	}
 _func_exit_;
 	return oldest;
-
 }
 
 static void update_network(struct wlan_bssid_ex *dst, struct wlan_bssid_ex *src,
@@ -715,7 +700,7 @@ static void update_current_network(struc
 
 _func_enter_;
 
-	if ( (check_fwstate(pmlmepriv, _FW_LINKED)== true) && (is_same_network(&(pmlmepriv->cur_network.network), pnetwork)))
+	if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) && (is_same_network(&(pmlmepriv->cur_network.network), pnetwork)))
 	{
 		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"Same Network\n");
 
@@ -728,7 +713,6 @@ _func_enter_;
 	}
 
 _func_exit_;
-
 }
 
 
@@ -779,7 +763,6 @@ _func_enter_;
 	/* If we didn't find a match, then get a new network slot to initialize
 	 * with this beacon's information */
 	if (rtw_end_of_queue_search(phead,plist)== true) {
-
 		if (_rtw_queue_empty(&(pmlmepriv->free_bss_pool)) == true) {
 			/* If there are no more slots, expire the oldest */
 			//list_del_init(&oldest->list);
@@ -819,7 +802,7 @@ _func_enter_;
 			//target->PhyInfo.Optimum_antenna = pHalData->CurAntenna;
 			rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(target->PhyInfo.Optimum_antenna));
 #endif
-			memcpy(&(pnetwork->network), target, bssid_ex_sz );
+			memcpy(&(pnetwork->network), target, bssid_ex_sz);
 
 			pnetwork->last_scanned = rtw_get_current_time();
 
@@ -933,7 +916,6 @@ int rtw_is_desired_network(struct rtw_ad
 /* TODO: Perry : For Power Management */
 void rtw_atimdone_event_callback(struct rtw_adapter	*adapter , u8 *pbuf)
 {
-
 _func_enter_;
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("receive atimdone_evet\n"));
 _func_exit_;
@@ -984,7 +966,7 @@ _func_enter_;
 	// lock pmlmepriv->lock when you accessing network_q
 	if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == false)
 	{
-	        if ( pnetwork->Ssid.Ssid[0] == 0 )
+	        if (pnetwork->Ssid.Ssid[0] == 0)
 		{
 			pnetwork->Ssid.SsidLength = 0;
 		}
@@ -1034,7 +1016,6 @@ _func_enter_;
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 	}
 	else {
-
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("nic status =%x, survey done event comes too late!\n", get_fwstate(pmlmepriv)));
 	}
 
@@ -1044,7 +1025,7 @@ _func_enter_;
 
 	if (pmlmepriv->to_join == true)
 	{
-		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true) )
+		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true))
 		{
 			if (check_fwstate(pmlmepriv, _FW_LINKED)==false)
 			{
@@ -1052,7 +1033,7 @@ _func_enter_;
 
 				if (rtw_select_and_join_from_scanned_queue(pmlmepriv)==_SUCCESS)
 				{
-					_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT );
+					_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
 				}
 				else
 				{
@@ -1100,7 +1081,7 @@ _func_enter_;
 				DBG_8192D("try_to_join, but select scanning queue fail, to_roaming:%d\n", rtw_to_roaming(adapter));
 				#ifdef CONFIG_LAYER2_ROAMING
 				if (rtw_to_roaming(adapter) != 0) {
-					if ( --pmlmepriv->to_roaming == 0
+					if (--pmlmepriv->to_roaming == 0
 						|| _SUCCESS != rtw_sitesurvey_cmd(adapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)
 					) {
 						rtw_set_roaming(adapter, 0);
@@ -1164,17 +1145,14 @@ _func_enter_;
 #endif //CONFIG_IOCTL_CFG80211
 
 _func_exit_;
-
 }
 
 void rtw_dummy_event_callback(struct rtw_adapter *adapter , u8 *pbuf)
 {
-
 }
 
 void rtw_fwdbg_event_callback(struct rtw_adapter *adapter , u8 *pbuf)
 {
-
 }
 
 static void free_scanqueue(struct	mlme_priv *pmlmepriv)
@@ -1226,7 +1204,7 @@ _func_enter_;
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("tgt_network->network.MacAddress=%pM ssid=%s\n",
 		tgt_network->network.MacAddress, tgt_network->network.Ssid.Ssid));
 
-	if (check_fwstate( pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE))
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE))
 	{
 		struct sta_info* psta;
 
@@ -1251,7 +1229,7 @@ _func_enter_;
 
 	}
 
-	if (check_fwstate( pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE))
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE))
 	{
 		struct sta_info* psta;
 
@@ -1291,7 +1269,6 @@ _func_enter_;
 	pmlmepriv->key_mask = 0;
 
 _func_exit_;
-
 }
 
 /*
@@ -1310,7 +1287,6 @@ _func_enter_;
 
 	if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
 	{
-
 #ifdef CONFIG_SW_ANTENNA_DIVERSITY
 	rtw_hal_set_hwreg(padapter, HW_VAR_ANTENNA_DIVERSITY_LINK, 0);
 #endif
@@ -1347,14 +1323,13 @@ _func_enter_;
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("-rtw_indicate_connect: fw_state=0x%08x\n", get_fwstate(pmlmepriv)));
 
 _func_exit_;
-
 }
 
 
 /*
 *rtw_indicate_disconnect: the caller has to lock pmlmepriv->lock
 */
-void rtw_indicate_disconnect(struct rtw_adapter *padapter )
+void rtw_indicate_disconnect(struct rtw_adapter *padapter)
 {
 	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
@@ -1412,7 +1387,6 @@ void rtw_scan_abort(struct rtw_adapter *
 	pmlmeext->scan_abort = true;
 	while (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)
 		&& rtw_get_passing_time_ms(start) <= 200) {
-
 		if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
 			break;
 
@@ -1480,7 +1454,7 @@ static struct sta_info *rtw_joinbss_upda
 		//	Commented by Albert 2012/07/21
 		//	When doing the WPS, the wps_ie_len won't equal to 0
 		//	And the Wi-Fi driver shouldn't allow the data packet to be tramsmitted.
-		if ( padapter->securitypriv.wps_ie_len != 0 )
+		if (padapter->securitypriv.wps_ie_len != 0)
 		{
 			psta->ieee8021x_blocked=true;
 			padapter->securitypriv.wps_ie_len = 0;
@@ -1530,7 +1504,6 @@ static struct sta_info *rtw_joinbss_upda
 	}
 
 	return psta;
-
 }
 
 //pnetwork : returns from rtw_joinbss_event_callback
@@ -1599,7 +1572,6 @@ static void rtw_joinbss_update_network(s
 	rtw_update_ht_cap(padapter, cur_network->network.IEs, cur_network->network.IELength, (u8) cur_network->network.Configuration.DSConfig);
 #endif
 
-
 }
 
 //Notes: the fucntion could be > passive_level (the same context as Rx tasklet)
@@ -1655,10 +1627,10 @@ _func_enter_;
 	{
 		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 		retry = 0;
-		if (check_fwstate(pmlmepriv,_FW_UNDER_LINKING) )
+		if (check_fwstate(pmlmepriv,_FW_UNDER_LINKING))
 		{
 			//s1. find ptarget_wlan
-			if (check_fwstate(pmlmepriv, _FW_LINKED) )
+			if (check_fwstate(pmlmepriv, _FW_LINKED))
 			{
 				if (the_same_macaddr == true)
 				{
@@ -1760,7 +1732,6 @@ _func_enter_;
 	}
 	else //if join_res < 0 (join fails), then try again
 	{
-
 		#ifdef REJOIN
 		res = _FAIL;
 		if (retry < 2) {
@@ -1878,7 +1849,7 @@ _func_enter_;
 #endif
 
 	psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);
-	if ( psta != NULL)
+	if (psta != NULL)
 	{
 		//the sta have been in sta_info_queue => do nothing
 
@@ -1905,8 +1876,8 @@ _func_enter_;
 
 	spin_lock_bh(&pmlmepriv->lock);
 
-	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==true ) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true ) )
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true))
 	{
 		if (adapter->stapriv.asoc_sta_count== 2)
 		{
@@ -1959,7 +1930,7 @@ _func_enter_;
 
 	spin_lock_bh(&pmlmepriv->lock);
 
-	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
 	{
 		#ifdef CONFIG_LAYER2_ROAMING
 		if (rtw_to_roaming(adapter) > 0)
@@ -1994,7 +1965,7 @@ _func_enter_;
 #endif // CONFIG_INTEL_WIDI
 	}
 
-	if ( check_fwstate(pmlmepriv,WIFI_ADHOC_MASTER_STATE) ||
+	if (check_fwstate(pmlmepriv,WIFI_ADHOC_MASTER_STATE) ||
 	      check_fwstate(pmlmepriv,WIFI_ADHOC_STATE))
 	{
 		psta = rtw_get_stainfo(&adapter->stapriv, pstadel->macaddr);
@@ -2037,7 +2008,6 @@ _func_enter_;
 
 			if (rtw_createbss_cmd(adapter)!=_SUCCESS)
 			{
-
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("***Error=>stadel_event_callback: rtw_createbss_cmd status FAIL***\n "));
 
 			}
@@ -2050,7 +2020,6 @@ _func_enter_;
 	spin_unlock_bh(&pmlmepriv->lock);
 
 _func_exit_;
-
 }
 
 
@@ -2070,7 +2039,6 @@ _func_enter_;
 #endif
 
 _func_exit_;
-
 }
 
 /*
@@ -2099,7 +2067,7 @@ _func_enter_;
 			pmlmepriv->to_roaming--;
 			if (rtw_to_roaming(adapter) != 0) { /* try another */
 				DBG_8192D("%s try another roaming\n", __func__);
-				if ( _SUCCESS!=(do_join_r=rtw_do_join(adapter)) ) {
+				if (_SUCCESS!=(do_join_r=rtw_do_join(adapter))) {
 					DBG_8192D("%s roaming do_join return %d\n", __func__ ,do_join_r);
 					continue;
 				}
@@ -2134,7 +2102,6 @@ _func_enter_;
 #endif
 
 _func_exit_;
-
 }
 
 /*
@@ -2154,7 +2121,6 @@ void rtw_scan_timeout_handler (struct rt
 	spin_unlock_bh(&pmlmepriv->lock);
 
 	rtw_indicate_scan_done(adapter, true);
-
 }
 
 static void rtw_auto_scan_handler(struct rtw_adapter *padapter)
@@ -2203,7 +2169,6 @@ static void rtw_auto_scan_handler(struct
 		}
 
 	}
-
 }
 
 void rtw_dynamic_check_timer_handlder(struct rtw_adapter *adapter)
@@ -2271,11 +2236,11 @@ void rtw_dynamic_check_timer_handlder(st
 #endif	// (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-	if ( adapter->pnetdev->br_port)
+	if (adapter->pnetdev->br_port)
 #else	// (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-	if ( rcu_dereference(adapter->pnetdev->rx_handler_data)
+	if (rcu_dereference(adapter->pnetdev->rx_handler_data)
 #endif	// (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-		&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) )
+		&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true))
 	{
 		// expire NAT2.5 entry
 		void nat25_db_expire(struct rtw_adapter *priv);
@@ -2296,7 +2261,6 @@ void rtw_dynamic_check_timer_handlder(st
 #endif	// (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
 
 #endif	// CONFIG_BR_EXT
-
 }
 
 
@@ -2342,7 +2306,6 @@ void rtw_set_scan_deny(struct rtw_adapte
 	ATOMIC_SET(&b_mlmepriv->set_scan_deny, 1);
 	_set_timer(&b_mlmepriv->set_scan_deny_timer, ms);
 #endif
-
 }
 #endif
 
@@ -2390,7 +2353,7 @@ static int rtw_check_join_candidate(stru
 	}
 #endif
 
-	if (*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi )
+	if (*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi)
 	{
 		*candidate = competitor;
 		updated = true;
@@ -2428,7 +2391,7 @@ pmlmepriv->lock
 
 */
 
-int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
+int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv)
 {
 	int ret;
 	struct list_head *phead;
@@ -2444,10 +2407,9 @@ _func_enter_;
 	phead = get_list_head(queue);
 	adapter = (struct rtw_adapter *)pmlmepriv->nic_hdl;
 
-	pmlmepriv->pscanned = get_next( phead );
+	pmlmepriv->pscanned = get_next(phead);
 
 	while (!rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) {
-
 		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
 		if (pnetwork==NULL){
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s return _FAIL:(pnetwork==NULL)\n", __func__));
@@ -2547,7 +2509,6 @@ exit:
 _func_exit_;
 
 	return res;
-
 }
 
 
@@ -2589,7 +2550,7 @@ _func_enter_;
 	psetkeyparm->set_tx = set_tx;
 	pmlmepriv->key_mask |= BIT(psetkeyparm->keyid);
 #ifdef CONFIG_AUTOSUSPEND
-	if ( true  == adapter->pwrctrlpriv.bInternalAutoSuspend)
+	if (true  == adapter->pwrctrlpriv.bInternalAutoSuspend)
 	{
 		adapter->pwrctrlpriv.wepkeymask = pmlmepriv->key_mask;
 		DBG_8192D("....AutoSuspend pwrctrlpriv.wepkeymask(%x)\n",adapter->pwrctrlpriv.wepkeymask);
@@ -2599,7 +2560,6 @@ _func_enter_;
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key: psetkeyparm->algorithm=%d psetkeyparm->keyid=(u8)keyid=%d\n",psetkeyparm->algorithm, keyid));
 
 	switch (psetkeyparm->algorithm){
-
 		case _WEP40_:
 			keylen=5;
 			memcpy(&(psetkeyparm->key[0]), &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);
@@ -2641,7 +2601,6 @@ _func_enter_;
 exit:
 _func_exit_;
 	return res;
-
 }
 
 
@@ -2658,7 +2617,6 @@ int rtw_restruct_wmm_ie(struct rtw_adapt
 
 		if (in_ie[i] == 0xDD && in_ie[i+2] == 0x00 && in_ie[i+3] == 0x50  && in_ie[i+4] == 0xF2 && in_ie[i+5] == 0x02 && i+5 < in_len) //WMM element ID and OUI
 		{
-
 			//Append WMM IE to the last index of out_ie
 			/*
 			for (j=i; j< i+(in_ie[i+1]+2); j++)
@@ -2669,7 +2627,7 @@ int rtw_restruct_wmm_ie(struct rtw_adapt
 			out_ie[initial_out_len+8] = 0x00; //force the QoS Info Field to be zero
 	                */
 
-                        for ( j = i; j < i + 9; j++ )
+                        for (j = i; j < i + 9; j++)
                         {
                             out_ie[ ielength] = in_ie[ j ];
                             ielength++;
@@ -2685,7 +2643,6 @@ int rtw_restruct_wmm_ie(struct rtw_adapt
 	}
 
 	return ielength;
-
 }
 
 
@@ -2707,8 +2664,8 @@ static int SecIsInPMKIDList(struct rtw_a
 
 	do
 	{
-		if ( ( psecuritypriv->PMKIDList[i].bUsed ) &&
-                    (  _rtw_memcmp( psecuritypriv->PMKIDList[i].Bssid, bssid, ETH_ALEN ) == true ) )
+		if ((psecuritypriv->PMKIDList[i].bUsed) &&
+                    ( _rtw_memcmp(psecuritypriv->PMKIDList[i].Bssid, bssid, ETH_ALEN) == true))
 		{
 			break;
 		}
@@ -2720,7 +2677,7 @@ static int SecIsInPMKIDList(struct rtw_a
 
 	}while (i<NUM_PMKID_CACHE);
 
-	if ( i == NUM_PMKID_CACHE )
+	if (i == NUM_PMKID_CACHE)
 	{
 		i = -1;// Could not find.
 	}
@@ -2730,7 +2687,6 @@ static int SecIsInPMKIDList(struct rtw_a
 	}
 
 	return (i);
-
 }
 
 //
@@ -2758,7 +2714,6 @@ static int rtw_append_pmkid(struct rtw_a
 
 	}
 	return (ie_len);
-
 }
 int rtw_restruct_sec_ie(struct rtw_adapter *adapter,u8 *in_ie, u8 *out_ie, uint in_len)
 {
@@ -2845,7 +2800,6 @@ _func_enter_;
 
 
 _func_exit_;
-
 }
 
 void rtw_update_registrypriv_dev_network(struct rtw_adapter* adapter)
@@ -2911,7 +2865,6 @@ _func_enter_;
 	//pdev_network->IELength = cpu_to_le32(sz);
 
 _func_exit_;
-
 }
 
 void rtw_get_encrypt_decrypt_from_registrypriv(struct rtw_adapter* adapter)
@@ -2920,7 +2873,6 @@ _func_enter_;
 
 
 _func_exit_;
-
 }
 
 //the fucntion is at passive_level
@@ -3001,16 +2953,16 @@ unsigned int rtw_restructure_ht_ie(struc
 		ht_capie.cap_info =  IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_TX_STBC |
 							IEEE80211_HT_CAP_DSSSCCK40;
 		//if insert module set only support 20MHZ, don't add the 40MHZ and SGI_40
-		if ( channel > 14 )
+		if (channel > 14)
 		{
-			if ( pregpriv->cbw40_enable & BIT(1) )
+			if (pregpriv->cbw40_enable & BIT(1))
 				cbw40_enable = 1;
 		}
 		else
-			if ( pregpriv->cbw40_enable & BIT(0) )
+			if (pregpriv->cbw40_enable & BIT(0))
 				cbw40_enable = 1;
 
-		if ( cbw40_enable != 0 )
+		if (cbw40_enable != 0)
 			ht_capie.cap_info |= IEEE80211_HT_CAP_SUP_WIDTH | IEEE80211_HT_CAP_SGI_40;
 
 
@@ -3027,7 +2979,7 @@ unsigned int rtw_restructure_ht_ie(struc
 
 		ht_capie.ampdu_params_info = (IEEE80211_HT_CAP_AMPDU_FACTOR&0x03);
 
-		if (padapter->securitypriv.dot11PrivacyAlgrthm == _AES_ )
+		if (padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
 			ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&(0x07<<2));
 		else
 			ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);
@@ -3053,7 +3005,6 @@ unsigned int rtw_restructure_ht_ie(struc
 	}
 
 	return (phtpriv->ht_option);
-
 }
 
 //the fucntion is > passive_level (in critical_section)
@@ -3123,13 +3074,13 @@ void rtw_update_ht_cap(struct rtw_adapte
 		//todo:
 	}
 
-	if ( channel > 14 )
+	if (channel > 14)
 	{
-		if ( pregistrypriv->cbw40_enable & BIT(1) )
+		if (pregistrypriv->cbw40_enable & BIT(1))
 			cbw40_enable = 1;
 	}
 	else
-		if ( pregistrypriv->cbw40_enable & BIT(0) )
+		if (pregistrypriv->cbw40_enable & BIT(0))
 			cbw40_enable = 1;
 
 
@@ -3153,7 +3104,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 			else
 			{
 				#ifdef CONFIG_DISABLE_MCS13TO15
-				if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40 && pregistrypriv->wifi_spec != 1 )
+				if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40 && pregistrypriv->wifi_spec != 1)
 				{
 					pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R_MCS13TO15_OFF[i];
 				}
@@ -3248,7 +3199,6 @@ void rtw_issue_addbareq_cmd(struct rtw_a
 			rtw_addbareq_cmd(padapter,(u8) priority, pattrib->ra);
 		}
 	}
-
 }
 
 #endif
@@ -3295,7 +3245,7 @@ void _rtw_roaming(struct rtw_adapter *pa
 		pmlmepriv->assoc_by_bssid = false;
 
 		while (1) {
-			if ( _SUCCESS==(do_join_r=rtw_do_join(padapter)) ) {
+			if (_SUCCESS==(do_join_r=rtw_do_join(padapter))) {
 				break;
 			} else {
 				DBG_8192D("roaming do_join return %d\n", do_join_r);
@@ -3311,7 +3261,6 @@ void _rtw_roaming(struct rtw_adapter *pa
 			}
 		}
 	}
-
 }
 #endif
 
@@ -3328,7 +3277,7 @@ int rtw_buddy_adapter_up(struct rtw_adap
 	{
 		res = false;
 	}
-	else if ( (padapter->pbuddy_adapter->bDriverStopped) || (padapter->pbuddy_adapter->bSurpriseRemoved) ||
+	else if ((padapter->pbuddy_adapter->bDriverStopped) || (padapter->pbuddy_adapter->bSurpriseRemoved) ||
 		(padapter->pbuddy_adapter->bup == false) || (padapter->pbuddy_adapter->hw_init_completed == false))
 	{
 		res = false;
@@ -3339,7 +3288,6 @@ int rtw_buddy_adapter_up(struct rtw_adap
 	}
 
 	return res;
-
 }
 
 int check_buddy_fwstate(struct rtw_adapter *padapter, int state)
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -362,7 +362,6 @@ static int has_channel(struct rt_channel
 static void init_channel_list(struct rtw_adapter *padapter, struct rt_channel_info *channel_set,
 							  u8 chanset_size,
 							  struct p2p_channels *channel_list) {
-
 	struct p2p_oper_class_map op_class[] = {
 		{ IEEE80211G,  81,   1,  13,  1, BW20 },
 		{ IEEE80211G,  82,  14,  14,  1, BW20 },
@@ -408,7 +407,6 @@ static void init_channel_list(struct rtw
 		}
 	}
 	channel_list->reg_classes = cla;
-
 }
 
 static u8 init_channel_set(struct rtw_adapter* padapter, u8 ChannelPlan, struct rt_channel_info *channel_set)
@@ -480,8 +478,8 @@ static u8 init_channel_set(struct rtw_ad
 		{
 #ifdef CONFIG_DFS
 			channel_set[chanset_size].ChannelNum = RTW_ChannelPlan5G[Index5G].Channel[index];
-			if ( channel_set[chanset_size].ChannelNum <= 48
-				|| channel_set[chanset_size].ChannelNum >= 149 )
+			if (channel_set[chanset_size].ChannelNum <= 48
+				|| channel_set[chanset_size].ChannelNum >= 149)
 			{
 				if (RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)//passive scan for all 5G channels
 					channel_set[chanset_size].ScanType = SCAN_PASSIVE;
@@ -494,8 +492,8 @@ static u8 init_channel_set(struct rtw_ad
 			}
 			chanset_size++;
 #else /* CONFIG_DFS */
-			if ( RTW_ChannelPlan5G[Index5G].Channel[index] <= 48
-				|| RTW_ChannelPlan5G[Index5G].Channel[index] >= 149 ) {
+			if (RTW_ChannelPlan5G[Index5G].Channel[index] <= 48
+				|| RTW_ChannelPlan5G[Index5G].Channel[index] >= 149) {
 				channel_set[chanset_size].ChannelNum = RTW_ChannelPlan5G[Index5G].Channel[index];
 				if (RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)//passive scan for all 5G channels
 					channel_set[chanset_size].ScanType = SCAN_PASSIVE;
@@ -547,7 +545,6 @@ int	init_mlme_ext_priv(struct rtw_adapte
 #endif
 
 	return res;
-
 }
 
 void free_mlme_ext_priv (struct mlme_ext_priv *pmlmeext)
@@ -605,7 +602,6 @@ static void _mgt_dispatcher(struct rtw_a
 
 		ptable->func(padapter, precv_frame);
         }
-
 }
 
 void mgt_dispatcher(struct rtw_adapter *padapter, union recv_frame *precv_frame)
@@ -643,8 +639,8 @@ void mgt_dispatcher(struct rtw_adapter *
 #ifdef CONFIG_TDLS
 	if ((index << 4)==WIFI_ACTION){
 		//category==RTW_WLAN_CATEGORY_PUBLIC, action==TDLS_DISCOVERY_RESPONSE
-		if (*(pframe + IEEE80211_MGMT_HDR_LEN ) == RTW_WLAN_CATEGORY_PUBLIC
-			&& *(pframe + IEEE80211_MGMT_HDR_LEN + 1) == TDLS_DISCOVERY_RESPONSE )
+		if (*(pframe + IEEE80211_MGMT_HDR_LEN) == RTW_WLAN_CATEGORY_PUBLIC
+			&& *(pframe + IEEE80211_MGMT_HDR_LEN + 1) == TDLS_DISCOVERY_RESPONSE)
 		{
 			DBG_8192D("recv tdls discovery response frame\n");
 			On_TDLS_Dis_Rsp(padapter, precv_frame);
@@ -729,7 +725,6 @@ void mgt_dispatcher(struct rtw_adapter *
 	_mgt_dispatcher(padapter, ptable, precv_frame);
 
 #endif
-
 }
 
 #ifdef CONFIG_P2P
@@ -751,14 +746,14 @@ u32 p2p_listen_state_process(struct rtw_
 	}
 #else
 	//	do nothing if the device name is empty
-	if ( !padapter->wdinfo.device_name_len )
+	if (!padapter->wdinfo.device_name_len)
 	{
 		response	= false;
 	}
 #endif
 
 	if (response == true)
-		issue_probersp_p2p( padapter, da);
+		issue_probersp_p2p(padapter, da);
 
 	return _SUCCESS;
 }
@@ -793,7 +788,7 @@ unsigned int OnProbeReq(struct rtw_adapt
 		!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) &&
 		!rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH) &&
 		!rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN)
-	   )
+	  )
 	{
 		//	Commented by Albert 2011/03/17
 		//	mcs_rate = 0 -> CCK 1M rate
@@ -805,19 +800,19 @@ unsigned int OnProbeReq(struct rtw_adapt
 		//	Commented by Kurt 2012/10/16
 		//	IOT issue: Google Nexus7 use 1M rate to send p2p_probe_req after GO nego completed and Nexus7 is client
 #ifdef CONFIG_WIFI_TEST
-		if ( pattrib->mcs_rate <= 3 )
+		if (pattrib->mcs_rate <= 3)
 		{
 			wifi_test_chk_rate = 0;
 		}
 #endif //CONFIG_WIFI_TEST
 
-		if ( wifi_test_chk_rate == 1 )
+		if (wifi_test_chk_rate == 1)
 		{
 			if ((is_valid_p2p_probereq = process_probe_req_p2p_ie(pwdinfo, pframe, len)) == true)
 			{
 				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE))
 				{
-					p2p_listen_state_process( padapter,  get_sa(pframe));
+					p2p_listen_state_process(padapter,  get_sa(pframe));
 
 					return _SUCCESS;
 				}
@@ -868,7 +863,7 @@ _continue:
 			goto _issue_probersp;
 		}
 
-		if ( (ielen != 0 && false ==_rtw_memcmp((void *)(p+2), (void *)cur->Ssid.Ssid, cur->Ssid.SsidLength))
+		if ((ielen != 0 && false ==_rtw_memcmp((void *)(p+2), (void *)cur->Ssid.Ssid, cur->Ssid.SsidLength))
 			|| (ielen == 0 && pmlmeinfo->hidden_ssid_mode)
 		)
 		{
@@ -887,7 +882,6 @@ _issue_probersp:
 	}
 
 	return _SUCCESS;
-
 }
 
 unsigned int OnProbeRsp(struct rtw_adapter *padapter, union recv_frame *precv_frame)
@@ -905,25 +899,25 @@ unsigned int OnProbeRsp(struct rtw_adapt
 #ifdef CONFIG_P2P
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
 	{
-		if ( true == pwdinfo->tx_prov_disc_info.benable )
+		if (true == pwdinfo->tx_prov_disc_info.benable)
 		{
-			if ( _rtw_memcmp( pwdinfo->tx_prov_disc_info.peerIFAddr, GetAddr2Ptr(pframe), ETH_ALEN ) )
+			if (_rtw_memcmp(pwdinfo->tx_prov_disc_info.peerIFAddr, GetAddr2Ptr(pframe), ETH_ALEN))
 			{
 				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
 				{
 					pwdinfo->tx_prov_disc_info.benable = false;
-					issue_p2p_provision_request( padapter,
+					issue_p2p_provision_request(padapter,
 												pwdinfo->tx_prov_disc_info.ssid.Ssid,
 												pwdinfo->tx_prov_disc_info.ssid.SsidLength,
-												pwdinfo->tx_prov_disc_info.peerDevAddr );
+												pwdinfo->tx_prov_disc_info.peerDevAddr);
 				}
-				else if ( rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) )
+				else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 				{
 					pwdinfo->tx_prov_disc_info.benable = false;
-					issue_p2p_provision_request( padapter,
+					issue_p2p_provision_request(padapter,
 												NULL,
 												0,
-												pwdinfo->tx_prov_disc_info.peerDevAddr );
+												pwdinfo->tx_prov_disc_info.peerDevAddr);
 				}
 			}
 		}
@@ -931,25 +925,25 @@ unsigned int OnProbeRsp(struct rtw_adapt
 	}
 	else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
 	{
-		if ( true == pwdinfo->nego_req_info.benable )
+		if (true == pwdinfo->nego_req_info.benable)
 		{
-			DBG_8192D( "[%s] P2P State is GONEGO ING!\n", __func__ );
-			if ( _rtw_memcmp( pwdinfo->nego_req_info.peerDevAddr, GetAddr2Ptr(pframe), ETH_ALEN ) )
+			DBG_8192D("[%s] P2P State is GONEGO ING!\n", __func__);
+			if (_rtw_memcmp(pwdinfo->nego_req_info.peerDevAddr, GetAddr2Ptr(pframe), ETH_ALEN))
 			{
 				pwdinfo->nego_req_info.benable = false;
-				issue_p2p_GO_request( padapter, pwdinfo->nego_req_info.peerDevAddr);
+				issue_p2p_GO_request(padapter, pwdinfo->nego_req_info.peerDevAddr);
 			}
 		}
 	}
-	else if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ ) )
+	else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ))
 	{
-		if ( true == pwdinfo->invitereq_info.benable )
+		if (true == pwdinfo->invitereq_info.benable)
 		{
-			DBG_8192D( "[%s] P2P_STATE_TX_INVITE_REQ!\n", __func__ );
-			if ( _rtw_memcmp( pwdinfo->invitereq_info.peer_macaddr, GetAddr2Ptr(pframe), ETH_ALEN ) )
+			DBG_8192D("[%s] P2P_STATE_TX_INVITE_REQ!\n", __func__);
+			if (_rtw_memcmp(pwdinfo->invitereq_info.peer_macaddr, GetAddr2Ptr(pframe), ETH_ALEN))
 			{
 				pwdinfo->invitereq_info.benable = false;
-				issue_p2p_invitation_request( padapter, pwdinfo->invitereq_info.peer_macaddr );
+				issue_p2p_invitation_request(padapter, pwdinfo->invitereq_info.peer_macaddr);
 			}
 		}
 	}
@@ -969,7 +963,6 @@ unsigned int OnProbeRsp(struct rtw_adapt
 	}
 
 	return _SUCCESS;
-
 }
 
 unsigned int OnBeacon(struct rtw_adapter *padapter, union recv_frame *precv_frame)
@@ -1081,7 +1074,6 @@ unsigned int OnBeacon(struct rtw_adapter
 _END_ONBEACON_:
 
 	return _SUCCESS;
-
 }
 
 unsigned int OnAuth(struct rtw_adapter *padapter, union recv_frame *precv_frame)
@@ -1134,7 +1126,7 @@ unsigned int OnAuth(struct rtw_adapter *
 		auth_mode = 0;
 
 	if ((algorithm > 0 && auth_mode == 0) ||	// rx a shared-key auth but shared not enabled
-		(algorithm == 0 && auth_mode == 1) )	// rx a open-system auth but shared-key is enabled
+		(algorithm == 0 && auth_mode == 1))	// rx a open-system auth but shared-key is enabled
 	{
 		DBG_8192D("auth rejected due to bad alg [alg=%d, auth_mib=%d] %02X%02X%02X%02X%02X%02X\n",
 			algorithm, auth_mode, sa[0], sa[1], sa[2], sa[3], sa[4], sa[5]);
@@ -1297,7 +1289,6 @@ auth_fail:
 
 #endif
 	return _FAIL;
-
 }
 
 unsigned int OnAuthClient(struct rtw_adapter *padapter, union recv_frame *precv_frame)
@@ -1397,7 +1388,6 @@ authclnt_fail:
 	//pmlmeinfo->state &= ~(WIFI_FW_AUTH_STATE);
 
 	return _FAIL;
-
 }
 
 unsigned int OnAssocReq(struct rtw_adapter *padapter, union recv_frame *precv_frame)
@@ -1555,7 +1545,6 @@ unsigned int OnAssocReq(struct rtw_adapt
 		p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _EXT_SUPPORTEDRATES_IE_ , &ie_len,
 				pkt_len - WLAN_HDR_A3_LEN - ie_offset);
 		if (p !=  NULL) {
-
 			if (supportRateNum<=sizeof(supportRate))
 			{
 				memcpy(supportRate+supportRateNum, p+2, ie_len);
@@ -1581,7 +1570,6 @@ unsigned int OnAssocReq(struct rtw_adapt
 	pstat->wpa2_pairwise_cipher = 0;
 	memset(pstat->wpa_ie, 0, sizeof(pstat->wpa_ie));
 	if ((psecuritypriv->wpa_psk & BIT(1)) && elems.rsn_ie) {
-
 		int group_cipher=0, pairwise_cipher=0;
 
 		wpa_ie = elems.rsn_ie;
@@ -1607,7 +1595,6 @@ unsigned int OnAssocReq(struct rtw_adapt
 		}
 
 	} else if ((psecuritypriv->wpa_psk & BIT(0)) && elems.wpa_ie) {
-
 		int group_cipher=0, pairwise_cipher=0;
 
 		wpa_ie = elems.wpa_ie;
@@ -1734,7 +1721,6 @@ unsigned int OnAssocReq(struct rtw_adapt
 			p = rtw_get_ie(p, _VENDOR_SPECIFIC_IE_, &ie_len, pkt_len - WLAN_HDR_A3_LEN - ie_offset);
 			if (p != NULL) {
 				if (_rtw_memcmp(p+2, WMM_IE, 6)) {
-
 					pstat->flags |= WLAN_STA_WME;
 
 					pstat->qos_option = 1;
@@ -1840,7 +1826,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 	pstat->is_p2p_device = false;
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
-		if ( (p2pie=rtw_get_p2p_ie(pframe + WLAN_HDR_A3_LEN + ie_offset , pkt_len - WLAN_HDR_A3_LEN - ie_offset , NULL, &p2pielen)))
+		if ((p2pie=rtw_get_p2p_ie(pframe + WLAN_HDR_A3_LEN + ie_offset , pkt_len - WLAN_HDR_A3_LEN - ie_offset , NULL, &p2pielen)))
 		{
 			pstat->is_p2p_device = true;
 			if ((p2p_status_code=(u8)process_assoc_req_p2p_ie(pwdinfo, pframe, pkt_len, pstat))>0)
@@ -1851,17 +1837,17 @@ unsigned int OnAssocReq(struct rtw_adapt
 			}
 		}
 #ifdef CONFIG_WFD
-		if (rtw_get_wfd_ie(pframe + WLAN_HDR_A3_LEN + ie_offset , pkt_len - WLAN_HDR_A3_LEN - ie_offset , wfd_ie, &wfd_ielen ))
+		if (rtw_get_wfd_ie(pframe + WLAN_HDR_A3_LEN + ie_offset , pkt_len - WLAN_HDR_A3_LEN - ie_offset , wfd_ie, &wfd_ielen))
 		{
 			u8	attr_content[ 10 ] = { 0x00 };
 			u32	attr_contentlen = 0;
 
-			DBG_8192D( "[%s] WFD IE Found!!\n", __func__ );
-			rtw_get_wfd_attr_content( wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
-			if ( attr_contentlen )
+			DBG_8192D("[%s] WFD IE Found!!\n", __func__);
+			rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
+			if (attr_contentlen)
 			{
-				pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16( attr_content + 2 );
-				DBG_8192D( "[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport );
+				pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16(attr_content + 2);
+				DBG_8192D("[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
 			}
 		}
 #endif
@@ -1887,7 +1873,6 @@ unsigned int OnAssocReq(struct rtw_adapt
 
 		//if (pstat->aid > NUM_STA) {
 		if (pstat->aid > pstapriv->max_num_sta) {
-
 			pstat->aid = 0;
 
 			DBG_8192D("  no room for more AIDs\n");
@@ -2005,7 +1990,6 @@ OnAssocReqFail:
 #endif /* CONFIG_AP_MODE */
 
 	return _FAIL;
-
 }
 
 unsigned int OnAssocRsp(struct rtw_adapter *padapter, union recv_frame *precv_frame)
@@ -2068,10 +2052,10 @@ unsigned int OnAssocRsp(struct rtw_adapt
 					WMM_param_handler(padapter, pIE);
 				}
 #if defined(CONFIG_P2P) && defined(CONFIG_WFD)
-				else if ( _rtw_memcmp(pIE->data, WFD_OUI, 4))		//WFD
+				else if (_rtw_memcmp(pIE->data, WFD_OUI, 4))		//WFD
 				{
-					DBG_8192D( "[%s] Found WFD IE\n", __func__ );
-					WFD_info_handler( padapter, pIE );
+					DBG_8192D("[%s] Found WFD IE\n", __func__);
+					WFD_info_handler(padapter, pIE);
 				}
 #endif
 				break;
@@ -2128,10 +2112,10 @@ unsigned int OnDeAuth(struct rtw_adapter
 		return _SUCCESS;
 
 #ifdef CONFIG_P2P
-	if ( pwdinfo->rx_invitereq_info.scan_op_ch_only )
+	if (pwdinfo->rx_invitereq_info.scan_op_ch_only)
 	{
-		_cancel_timer_ex( &pwdinfo->reset_ch_sitesurvey );
-		_set_timer( &pwdinfo->reset_ch_sitesurvey, 10 );
+		_cancel_timer_ex(&pwdinfo->reset_ch_sitesurvey);
+		_set_timer(&pwdinfo->reset_ch_sitesurvey, 10);
 	}
 #endif //CONFIG_P2P
 
@@ -2177,7 +2161,6 @@ unsigned int OnDeAuth(struct rtw_adapter
 	}
 	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
 	return _SUCCESS;
-
 }
 
 unsigned int OnDisassoc(struct rtw_adapter *padapter, union recv_frame *precv_frame)
@@ -2196,10 +2179,10 @@ unsigned int OnDisassoc(struct rtw_adapt
 		return _SUCCESS;
 
 #ifdef CONFIG_P2P
-	if ( pwdinfo->rx_invitereq_info.scan_op_ch_only )
+	if (pwdinfo->rx_invitereq_info.scan_op_ch_only)
 	{
-		_cancel_timer_ex( &pwdinfo->reset_ch_sitesurvey );
-		_set_timer( &pwdinfo->reset_ch_sitesurvey, 10 );
+		_cancel_timer_ex(&pwdinfo->reset_ch_sitesurvey);
+		_set_timer(&pwdinfo->reset_ch_sitesurvey, 10);
 	}
 #endif //CONFIG_P2P
 
@@ -2244,7 +2227,6 @@ unsigned int OnDisassoc(struct rtw_adapt
 	}
 	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
 	return _SUCCESS;
-
 }
 
 unsigned int OnAtim(struct rtw_adapter *padapter, union recv_frame *precv_frame)
@@ -2265,7 +2247,6 @@ unsigned int on_action_spct_ch_switch (s
 	}
 
 	if ((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) {
-
 		int ch_switch_mode = -1, ch = -1, ch_switch_cnt = -1;
 		int ch_offset = -1;
 		u8 bwmode;
@@ -2406,7 +2387,7 @@ unsigned int OnAction_back(struct rtw_ad
 #ifdef CONFIG_TDLS
 		if ((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
 			(psta->htpriv.ht_option==true) &&
-			(psta->htpriv.ampdu_enable==true) )
+			(psta->htpriv.ampdu_enable==true))
 		{
 			//do nothing; just don't want to return _SUCCESS;
 		}
@@ -2505,7 +2486,7 @@ static int get_reg_classes_full_count(st
 	return cnt;
 }
 
-static void get_channel_cnt_24g_5gl_5gh(  struct mlme_ext_priv *pmlmeext, u8* p24g_cnt, u8* p5gl_cnt, u8* p5gh_cnt )
+static void get_channel_cnt_24g_5gl_5gh( struct mlme_ext_priv *pmlmeext, u8* p24g_cnt, u8* p5gl_cnt, u8* p5gh_cnt)
 {
 	int	i = 0;
 
@@ -2513,18 +2494,18 @@ static void get_channel_cnt_24g_5gl_5gh(
 	*p5gl_cnt = 0;
 	*p5gh_cnt = 0;
 
-	for ( i = 0; i < pmlmeext->max_chan_nums; i++ )
+	for (i = 0; i < pmlmeext->max_chan_nums; i++)
 	{
-		if ( pmlmeext->channel_set[ i ].ChannelNum <= 14 )
+		if (pmlmeext->channel_set[ i ].ChannelNum <= 14)
 		{
 			(*p24g_cnt)++;
 		}
-		else if ( ( pmlmeext->channel_set[ i ].ChannelNum > 14 ) && ( pmlmeext->channel_set[ i ].ChannelNum <= 48 ) )
+		else if ((pmlmeext->channel_set[ i ].ChannelNum > 14) && (pmlmeext->channel_set[ i ].ChannelNum <= 48))
 		{
 			//	Just include the channel 36, 40, 44, 48 channels for 5G low
 			(*p5gl_cnt)++;
 		}
-		else if ( ( pmlmeext->channel_set[ i ].ChannelNum >= 149 ) && ( pmlmeext->channel_set[ i ].ChannelNum <= 161 ) )
+		else if ((pmlmeext->channel_set[ i ].ChannelNum >= 149) && (pmlmeext->channel_set[ i ].ChannelNum <= 161))
 		{
 			//	Just include the channel 149, 153, 157, 161 channels for 5G high
 			(*p5gh_cnt)++;
@@ -2534,7 +2515,6 @@ static void get_channel_cnt_24g_5gl_5gh(
 
 void issue_p2p_GO_request(struct rtw_adapter *padapter, u8* raddr)
 {
-
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u32			p2poui = cpu_to_be32(P2POUI);
@@ -2555,7 +2535,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo);
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
@@ -2563,7 +2543,7 @@ void issue_p2p_GO_request(struct rtw_ada
 		return;
 	}
 
-	DBG_8192D( "[%s] In\n", __func__ );
+	DBG_8192D("[%s] In\n", __func__);
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
@@ -2599,16 +2579,16 @@ void issue_p2p_GO_request(struct rtw_ada
 	//	WPS Section
 	wpsielen = 0;
 	//	WPS OUI
-	*(u32*) ( wpsie ) = cpu_to_be32( WPSOUI );
+	*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 	wpsielen += 4;
 
 	//	WPS version
 	//	Type:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_VER1 );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 	wpsielen += 2;
 
 	//	Length:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 	wpsielen += 2;
 
 	//	Value:
@@ -2616,31 +2596,31 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	//	Device Password ID
 	//	Type:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_DEVICE_PWID );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
 	wpsielen += 2;
 
 	//	Length:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0002 );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 	wpsielen += 2;
 
 	//	Value:
 
-	if ( pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN )
+	if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN)
 	{
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_DPID_USER_SPEC );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_DPID_USER_SPEC);
 	}
-	else if ( pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_SELF_DISPLAY_PIN )
+	else if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_SELF_DISPLAY_PIN)
 	{
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_DPID_REGISTRAR_SPEC );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);
 	}
-	else if ( pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PBC )
+	else if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PBC)
 	{
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_DPID_PBC );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_DPID_PBC);
 	}
 
 	wpsielen += 2;
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen );
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
 
 
 	//	P2P IE Section.
@@ -2670,7 +2650,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	//	Value:
@@ -2678,7 +2658,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 
 	//	Group Capability Bitmap, 1 byte
-	if ( pwdinfo->persistent_supported )
+	if (pwdinfo->persistent_supported)
 	{
 		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
 	}
@@ -2693,19 +2673,19 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[ p2pielen++ ] = P2P_ATTR_GO_INTENT;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0001 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	//	Value:
 	//	Todo the tie breaker bit.
-	p2pie[ p2pielen++ ] = ( ( pwdinfo->intent << 1 ) | BIT(0) );
+	p2pie[ p2pielen++ ] = ((pwdinfo->intent << 1) | BIT(0));
 
 	//	Configuration Timeout
 	//	Type:
 	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	//	Value:
@@ -2718,7 +2698,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[ p2pielen++ ] = P2P_ATTR_LISTEN_CH;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0005 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
 	//	Value:
@@ -2742,16 +2722,16 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[ p2pielen++ ] = P2P_ATTR_EX_LISTEN_TIMING;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0004 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0004);
 	p2pielen += 2;
 
 	//	Value:
 	//	Availability Period
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0xFFFF );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 	p2pielen += 2;
 
 	//	Availability Interval
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0xFFFF );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 	p2pielen += 2;
 
 
@@ -2760,11 +2740,11 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[ p2pielen++ ] = P2P_ATTR_INTENTED_IF_ADDR;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( ETH_ALEN );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
 	p2pielen += 2;
 
 	//	Value:
-	memcpy( p2pie + p2pielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+	memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
 
@@ -2774,24 +2754,24 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	// Length:
 	// Country String(3)
-	// + ( Operating Class (1) + Number of Channels(1) ) * Operation Classes (?)
+	// + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?)
 	// + number of channels in all classes
 	len_channellist_attr = 3
 	   + (1 + 1) * (u16)(pmlmeext->channel_list.reg_classes)
 	   + get_reg_classes_full_count(pmlmeext->channel_list);
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+	if (check_buddy_fwstate(padapter, _FW_LINKED))
 	{
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 5 + 1 );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(5 + 1);
 	}
 	else
 	{
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( len_channellist_attr );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 	}
 #else
 
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( len_channellist_attr );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 
 #endif
 	p2pielen += 2;
@@ -2808,15 +2788,15 @@ void issue_p2p_GO_request(struct rtw_ada
 	//	Channel Entry List
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+	if (check_buddy_fwstate(padapter, _FW_LINKED))
 	{
 		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
 		//	Operating Class
-		if ( pbuddy_mlmeext->cur_channel > 14 )
+		if (pbuddy_mlmeext->cur_channel > 14)
 		{
-			if ( pbuddy_mlmeext->cur_channel >= 149 )
+			if (pbuddy_mlmeext->cur_channel >= 149)
 			{
 				p2pie[ p2pielen++ ] = 0x7c;
 			}
@@ -2878,32 +2858,32 @@ void issue_p2p_GO_request(struct rtw_ada
 	//	Length:
 	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
 	//	Value:
 	//	P2P Device Address
-	memcpy( p2pie + p2pielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+	memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
 	//	Config Method
 	//	This field should be big endian. Noted by P2P specification.
 
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( pwdinfo->supported_wps_cm );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
 
 	p2pielen += 2;
 
 	//	Primary Device Type
 	//	Category ID
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
 	//	OUI
-	*(u32*) ( p2pie + p2pielen ) = cpu_to_be32( WPSOUI );
+	*(u32*) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 	p2pielen += 4;
 
 	//	Sub Category ID
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_SCID_MEDIA_SERVER );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
 	//	Number of Secondary Device Types
@@ -2911,15 +2891,15 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	//	Device Name
 	//	Type:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( pwdinfo->device_name_len );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 	p2pielen += 2;
 
 	//	Value:
-	memcpy( p2pie + p2pielen, pwdinfo->device_name , pwdinfo->device_name_len );
+	memcpy(p2pie + p2pielen, pwdinfo->device_name , pwdinfo->device_name_len);
 	p2pielen += pwdinfo->device_name_len;
 
 
@@ -2928,7 +2908,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0005 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
 	//	Value:
@@ -2941,12 +2921,12 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[ p2pielen++ ] = 0x04;
 
 	//	Operating Class
-	if ( pwdinfo->operating_channel <= 14 )
+	if (pwdinfo->operating_channel <= 14)
 	{
 		//	Operating Class
 		p2pie[ p2pielen++ ] = 0x51;
 	}
-	else if ( ( pwdinfo->operating_channel >= 36 ) && ( pwdinfo->operating_channel <= 48 ) )
+	else if ((pwdinfo->operating_channel >= 36) && (pwdinfo->operating_channel <= 48))
 	{
 		//	Operating Class
 		p2pie[ p2pielen++ ] = 0x73;
@@ -2960,7 +2940,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	//	Channel Number
 	p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	//	operating channel number
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen);
 
 #ifdef CONFIG_WFD
 	wfdielen = build_nego_req_wfd_ie(pwdinfo, pframe);
@@ -2973,13 +2953,11 @@ void issue_p2p_GO_request(struct rtw_ada
 	dump_mgntframe(padapter, pmgntframe);
 
 	return;
-
 }
 
 
 void issue_p2p_GO_response(struct rtw_adapter *padapter, u8* raddr, u8* frame_body,uint len, u8 result)
 {
-
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u32			p2poui = cpu_to_be32(P2POUI);
@@ -3000,7 +2978,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo);
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
@@ -3011,7 +2989,7 @@ void issue_p2p_GO_response(struct rtw_ad
 		return;
 	}
 
-	DBG_8192D( "[%s] In, result = %d\n", __func__,  result );
+	DBG_8192D("[%s] In, result = %d\n", __func__,  result);
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
@@ -3045,26 +3023,26 @@ void issue_p2p_GO_response(struct rtw_ad
 	//	Commented by Albert 20110328
 	//	Try to get the device password ID from the WPS IE of group negotiation request frame
 	//	WiFi Direct test plan 5.1.15
-	rtw_get_wps_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wpsie, &wpsielen);
-	rtw_get_wps_attr_content( wpsie, wpsielen, WPS_ATTR_DEVICE_PWID, (u8*) &wps_devicepassword_id, &wps_devicepassword_id_len);
-	wps_devicepassword_id = be16_to_cpu( wps_devicepassword_id );
+	rtw_get_wps_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wpsie, &wpsielen);
+	rtw_get_wps_attr_content(wpsie, wpsielen, WPS_ATTR_DEVICE_PWID, (u8*) &wps_devicepassword_id, &wps_devicepassword_id_len);
+	wps_devicepassword_id = be16_to_cpu(wps_devicepassword_id);
 
-	memset( wpsie, 0x00, 255 );
+	memset(wpsie, 0x00, 255);
 	wpsielen = 0;
 
 	//	WPS Section
 	wpsielen = 0;
 	//	WPS OUI
-	*(u32*) ( wpsie ) = cpu_to_be32( WPSOUI );
+	*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 	wpsielen += 4;
 
 	//	WPS version
 	//	Type:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_VER1 );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 	wpsielen += 2;
 
 	//	Length:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 	wpsielen += 2;
 
 	//	Value:
@@ -3072,48 +3050,48 @@ void issue_p2p_GO_response(struct rtw_ad
 
 	//	Device Password ID
 	//	Type:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_DEVICE_PWID );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
 	wpsielen += 2;
 
 	//	Length:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0002 );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 	wpsielen += 2;
 
 	//	Value:
-	if ( wps_devicepassword_id == WPS_DPID_USER_SPEC )
+	if (wps_devicepassword_id == WPS_DPID_USER_SPEC)
 	{
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_DPID_REGISTRAR_SPEC );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);
 	}
-	else if ( wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC )
+	else if (wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC)
 	{
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_DPID_USER_SPEC );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_DPID_USER_SPEC);
 	}
 	else
 	{
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_DPID_PBC );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_DPID_PBC);
 	}
 	wpsielen += 2;
 
 	//	Commented by Kurt 20120113
 	//	If some device wants to do p2p handshake without sending prov_disc_req
 	//	We have to get peer_req_cm from here.
-	if (_rtw_memcmp( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3) )
+	if (_rtw_memcmp(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3))
 	{
-		if ( wps_devicepassword_id == WPS_DPID_USER_SPEC )
+		if (wps_devicepassword_id == WPS_DPID_USER_SPEC)
 		{
-			memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis", 3 );
+			memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis", 3);
 		}
-		else if ( wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC )
+		else if (wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC)
 		{
-			memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3 );
+			memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3);
 		}
 		else
 		{
-			memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3 );
+			memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3);
 		}
 	}
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen );
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
 
 
 	//	P2P IE Section.
@@ -3135,7 +3113,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	//	6. Intended P2P Interface Address
 	//	7. Channel List
 	//	8. Device Info
-	//	9. Group ID	( Only GO )
+	//	9. Group ID	(Only GO)
 
 
 	//	ToDo:
@@ -3145,7 +3123,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	p2pie[ p2pielen++ ] = P2P_ATTR_STATUS;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0001 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	//	Value:
@@ -3156,13 +3134,13 @@ void issue_p2p_GO_response(struct rtw_ad
 	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	//	Value:
 	//	Device Capability Bitmap, 1 byte
 
-	if ( rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) )
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
 	{
 		//	Commented by Albert 2011/03/08
 		//	According to the P2P specification
@@ -3176,7 +3154,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	}
 
 	//	Group Capability Bitmap, 1 byte
-	if ( pwdinfo->persistent_supported )
+	if (pwdinfo->persistent_supported)
 	{
 		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
 	}
@@ -3190,19 +3168,19 @@ void issue_p2p_GO_response(struct rtw_ad
 	p2pie[ p2pielen++ ] = P2P_ATTR_GO_INTENT;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0001 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	//	Value:
-	if ( pwdinfo->peer_intent & 0x01 )
+	if (pwdinfo->peer_intent & 0x01)
 	{
 		//	Peer's tie breaker bit is 1, our tie breaker bit should be 0
-		p2pie[ p2pielen++ ] = ( pwdinfo->intent << 1 );
+		p2pie[ p2pielen++ ] = (pwdinfo->intent << 1);
 	}
 	else
 	{
 		//	Peer's tie breaker bit is 0, our tie breaker bit should be 1
-		p2pie[ p2pielen++ ] = ( ( pwdinfo->intent << 1 ) | BIT(0) );
+		p2pie[ p2pielen++ ] = ((pwdinfo->intent << 1) | BIT(0));
 	}
 
 
@@ -3211,7 +3189,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	//	Value:
@@ -3223,7 +3201,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0005 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
 	//	Value:
@@ -3236,12 +3214,12 @@ void issue_p2p_GO_response(struct rtw_ad
 	p2pie[ p2pielen++ ] = 0x04;
 
 	//	Operating Class
-	if ( pwdinfo->operating_channel <= 14 )
+	if (pwdinfo->operating_channel <= 14)
 	{
 		//	Operating Class
 		p2pie[ p2pielen++ ] = 0x51;
 	}
-	else if ( ( pwdinfo->operating_channel >= 36 ) && ( pwdinfo->operating_channel <= 48 ) )
+	else if ((pwdinfo->operating_channel >= 36) && (pwdinfo->operating_channel <= 48))
 	{
 		//	Operating Class
 		p2pie[ p2pielen++ ] = 0x73;
@@ -3260,11 +3238,11 @@ void issue_p2p_GO_response(struct rtw_ad
 	p2pie[ p2pielen++ ] = P2P_ATTR_INTENTED_IF_ADDR;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( ETH_ALEN );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
 	p2pielen += 2;
 
 	//	Value:
-	memcpy( p2pie + p2pielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+	memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
 	//	Channel List
@@ -3272,24 +3250,24 @@ void issue_p2p_GO_response(struct rtw_ad
 	p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
 
 	// Country String(3)
-	// + ( Operating Class (1) + Number of Channels(1) ) * Operation Classes (?)
+	// + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?)
 	// + number of channels in all classes
 	len_channellist_attr = 3
 	   + (1 + 1) * (u16)pmlmeext->channel_list.reg_classes
 	   + get_reg_classes_full_count(pmlmeext->channel_list);
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+	if (check_buddy_fwstate(padapter, _FW_LINKED))
 	{
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 5 + 1 );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(5 + 1);
 	}
 	else
 	{
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( len_channellist_attr );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 	}
 #else
 
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( len_channellist_attr );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 
  #endif
 	p2pielen += 2;
@@ -3306,15 +3284,15 @@ void issue_p2p_GO_response(struct rtw_ad
 	//	Channel Entry List
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+	if (check_buddy_fwstate(padapter, _FW_LINKED))
 	{
 		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
 		//	Operating Class
-		if ( pbuddy_mlmeext->cur_channel > 14 )
+		if (pbuddy_mlmeext->cur_channel > 14)
 		{
-			if ( pbuddy_mlmeext->cur_channel >= 149 )
+			if (pbuddy_mlmeext->cur_channel >= 149)
 			{
 				p2pie[ p2pielen++ ] = 0x7c;
 			}
@@ -3376,32 +3354,32 @@ void issue_p2p_GO_response(struct rtw_ad
 	//	Length:
 	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
 	//	Value:
 	//	P2P Device Address
-	memcpy( p2pie + p2pielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+	memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
 	//	Config Method
 	//	This field should be big endian. Noted by P2P specification.
 
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( pwdinfo->supported_wps_cm );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
 
 	p2pielen += 2;
 
 	//	Primary Device Type
 	//	Category ID
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
 	//	OUI
-	*(u32*) ( p2pie + p2pielen ) = cpu_to_be32( WPSOUI );
+	*(u32*) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 	p2pielen += 4;
 
 	//	Sub Category ID
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_SCID_MEDIA_SERVER );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
 	//	Number of Secondary Device Types
@@ -3409,39 +3387,39 @@ void issue_p2p_GO_response(struct rtw_ad
 
 	//	Device Name
 	//	Type:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( pwdinfo->device_name_len );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 	p2pielen += 2;
 
 	//	Value:
-	memcpy( p2pie + p2pielen, pwdinfo->device_name , pwdinfo->device_name_len );
+	memcpy(p2pie + p2pielen, pwdinfo->device_name , pwdinfo->device_name_len);
 	p2pielen += pwdinfo->device_name_len;
 
-	if ( rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) )
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
 		//	Group ID Attribute
 		//	Type:
 		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
 
 		//	Length:
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( ETH_ALEN + pwdinfo->nego_ssidlen );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN + pwdinfo->nego_ssidlen);
 		p2pielen += 2;
 
 		//	Value:
 		//	p2P Device Address
-		memcpy( p2pie + p2pielen , pwdinfo->device_addr, ETH_ALEN );
+		memcpy(p2pie + p2pielen , pwdinfo->device_addr, ETH_ALEN);
 		p2pielen += ETH_ALEN;
 
 		//	SSID
-		memcpy( p2pie + p2pielen, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen );
+		memcpy(p2pie + p2pielen, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen);
 		p2pielen += pwdinfo->nego_ssidlen;
 
 	}
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen);
 
 #ifdef CONFIG_WFD
 	wfdielen = build_nego_resp_wfd_ie(pwdinfo, pframe);
@@ -3454,12 +3432,10 @@ void issue_p2p_GO_response(struct rtw_ad
 	dump_mgntframe(padapter, pmgntframe);
 
 	return;
-
 }
 
 void issue_p2p_GO_confirm(struct rtw_adapter *padapter, u8* raddr, u8 result)
 {
-
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u32			p2poui = cpu_to_be32(P2POUI);
@@ -3475,7 +3451,7 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo);
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
 #endif //CONFIG_WFD
@@ -3485,7 +3461,7 @@ void issue_p2p_GO_confirm(struct rtw_ada
 		return;
 	}
 
-	DBG_8192D( "[%s] In\n", __func__ );
+	DBG_8192D("[%s] In\n", __func__);
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
@@ -3532,14 +3508,14 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	//	2. P2P Capability
 	//	3. Operating Channel
 	//	4. Channel List
-	//	5. Group ID	( if this WiFi is GO )
+	//	5. Group ID	(if this WiFi is GO)
 
 	//	P2P Status
 	//	Type:
 	p2pie[ p2pielen++ ] = P2P_ATTR_STATUS;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0001 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	//	Value:
@@ -3550,7 +3526,7 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	//	Value:
@@ -3558,7 +3534,7 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 
 	//	Group Capability Bitmap, 1 byte
-	if ( pwdinfo->persistent_supported )
+	if (pwdinfo->persistent_supported)
 	{
 		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
 	}
@@ -3573,7 +3549,7 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0005 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
 	//	Value:
@@ -3586,14 +3562,14 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	p2pie[ p2pielen++ ] = 0x04;
 
 
-	if ( rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) )
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
 	{
-		if ( pwdinfo->peer_operating_ch <= 14 )
+		if (pwdinfo->peer_operating_ch <= 14)
 		{
 			//	Operating Class
 			p2pie[ p2pielen++ ] = 0x51;
 		}
-		else if ( ( pwdinfo->peer_operating_ch >= 36 ) && ( pwdinfo->peer_operating_ch <= 48 ) )
+		else if ((pwdinfo->peer_operating_ch >= 36) && (pwdinfo->peer_operating_ch <= 48))
 		{
 			//	Operating Class
 			p2pie[ p2pielen++ ] = 0x73;
@@ -3608,12 +3584,12 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	}
 	else
 	{
-		if ( pwdinfo->operating_channel <= 14 )
+		if (pwdinfo->operating_channel <= 14)
 		{
 			//	Operating Class
 			p2pie[ p2pielen++ ] = 0x51;
 		}
-		else if ( ( pwdinfo->operating_channel >= 36 ) && ( pwdinfo->operating_channel <= 48 ) )
+		else if ((pwdinfo->operating_channel >= 36) && (pwdinfo->operating_channel <= 48))
 		{
 			//	Operating Class
 			p2pie[ p2pielen++ ] = 0x73;
@@ -3634,34 +3610,34 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( pwdinfo->channel_list_attr_len );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(pwdinfo->channel_list_attr_len);
 	p2pielen += 2;
 
 	//	Value:
-	memcpy( p2pie + p2pielen, pwdinfo->channel_list_attr, pwdinfo->channel_list_attr_len );
+	memcpy(p2pie + p2pielen, pwdinfo->channel_list_attr, pwdinfo->channel_list_attr_len);
 	p2pielen += pwdinfo->channel_list_attr_len;
 
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) )
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
 		//	Group ID Attribute
 		//	Type:
 		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
 
 		//	Length:
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( ETH_ALEN + pwdinfo->nego_ssidlen );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN + pwdinfo->nego_ssidlen);
 		p2pielen += 2;
 
 		//	Value:
 		//	p2P Device Address
-		memcpy( p2pie + p2pielen , pwdinfo->device_addr, ETH_ALEN );
+		memcpy(p2pie + p2pielen , pwdinfo->device_addr, ETH_ALEN);
 		p2pielen += ETH_ALEN;
 
 		//	SSID
-		memcpy( p2pie + p2pielen, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen );
+		memcpy(p2pie + p2pielen, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen);
 		p2pielen += pwdinfo->nego_ssidlen;
 	}
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen);
 
 #ifdef CONFIG_WFD
 	wfdielen = build_nego_confirm_wfd_ie(pwdinfo, pframe);
@@ -3674,12 +3650,10 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	dump_mgntframe(padapter, pmgntframe);
 
 	return;
-
 }
 
-void issue_p2p_invitation_request(struct rtw_adapter *padapter, u8* raddr )
+void issue_p2p_invitation_request(struct rtw_adapter *padapter, u8* raddr)
 {
-
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u32			p2poui = cpu_to_be32(P2POUI);
@@ -3707,7 +3681,7 @@ void issue_p2p_invitation_request(struct
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo);
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
@@ -3757,8 +3731,8 @@ void issue_p2p_invitation_request(struct
 	//	According to the P2P Specification, the P2P Invitation request frame should contain 7 P2P attributes
 	//	1. Configuration Timeout
 	//	2. Invitation Flags
-	//	3. Operating Channel	( Only GO )
-	//	4. P2P Group BSSID	( Should be included if I am the GO )
+	//	3. Operating Channel	(Only GO)
+	//	4. P2P Group BSSID	(Should be included if I am the GO)
 	//	5. Channel List
 	//	6. P2P Group ID
 	//	7. P2P Device Info
@@ -3768,7 +3742,7 @@ void issue_p2p_invitation_request(struct
 	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	//	Value:
@@ -3780,7 +3754,7 @@ void issue_p2p_invitation_request(struct
 	p2pie[ p2pielen++ ] = P2P_ATTR_INVITATION_FLAGS;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0001 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	//	Value:
@@ -3792,7 +3766,7 @@ void issue_p2p_invitation_request(struct
 	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0005 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
 	//	Value:
@@ -3805,9 +3779,9 @@ void issue_p2p_invitation_request(struct
 	p2pie[ p2pielen++ ] = 0x04;
 
 	//	Operating Class
-	if ( pwdinfo->invitereq_info.operating_ch <= 14 )
+	if (pwdinfo->invitereq_info.operating_ch <= 14)
 		p2pie[ p2pielen++ ] = 0x51;
-	else if ( ( pwdinfo->invitereq_info.operating_ch >= 36 ) && ( pwdinfo->invitereq_info.operating_ch <= 48 ) )
+	else if ((pwdinfo->invitereq_info.operating_ch >= 36) && (pwdinfo->invitereq_info.operating_ch <= 48))
 		p2pie[ p2pielen++ ] = 0x73;
 	else
 		p2pie[ p2pielen++ ] = 0x7c;
@@ -3815,19 +3789,19 @@ void issue_p2p_invitation_request(struct
 	//	Channel Number
 	p2pie[ p2pielen++ ] = pwdinfo->invitereq_info.operating_ch;	//	operating channel number
 
-	if ( _rtw_memcmp( myid( &padapter->eeprompriv ), pwdinfo->invitereq_info.go_bssid, ETH_ALEN ) )
+	if (_rtw_memcmp(myid(&padapter->eeprompriv), pwdinfo->invitereq_info.go_bssid, ETH_ALEN))
 	{
 		//	P2P Group BSSID
 		//	Type:
 		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_BSSID;
 
 		//	Length:
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( ETH_ALEN );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
 		p2pielen += 2;
 
 		//	Value:
 		//	P2P Device Address for GO
-		memcpy( p2pie + p2pielen, pwdinfo->invitereq_info.go_bssid, ETH_ALEN );
+		memcpy(p2pie + p2pielen, pwdinfo->invitereq_info.go_bssid, ETH_ALEN);
 		p2pielen += ETH_ALEN;
 	}
 
@@ -3838,24 +3812,24 @@ void issue_p2p_invitation_request(struct
 
 	//	Length:
 	// Country String(3)
-	// + ( Operating Class (1) + Number of Channels(1) ) * Operation Classes (?)
+	// + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?)
 	// + number of channels in all classes
 	len_channellist_attr = 3
 	   + (1 + 1) * (u16)pmlmeext->channel_list.reg_classes
 	   + get_reg_classes_full_count(pmlmeext->channel_list);
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+	if (check_buddy_fwstate(padapter, _FW_LINKED))
 	{
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 5 + 1 );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(5 + 1);
 	}
 	else
 	{
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( len_channellist_attr );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 	}
 #else
 
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( len_channellist_attr );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 
  #endif
 	p2pielen += 2;
@@ -3871,15 +3845,15 @@ void issue_p2p_invitation_request(struct
 
 	//	Channel Entry List
 #ifdef CONFIG_CONCURRENT_MODE
-	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+	if (check_buddy_fwstate(padapter, _FW_LINKED))
 	{
 		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
 		//	Operating Class
-		if ( pbuddy_mlmeext->cur_channel > 14 )
+		if (pbuddy_mlmeext->cur_channel > 14)
 		{
-			if ( pbuddy_mlmeext->cur_channel >= 149 )
+			if (pbuddy_mlmeext->cur_channel >= 149)
 			{
 				p2pie[ p2pielen++ ] = 0x7c;
 			}
@@ -3940,16 +3914,16 @@ void issue_p2p_invitation_request(struct
 	p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 6 + pwdinfo->invitereq_info.ssidlen );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(6 + pwdinfo->invitereq_info.ssidlen);
 	p2pielen += 2;
 
 	//	Value:
 	//	P2P Device Address for GO
-	memcpy( p2pie + p2pielen, pwdinfo->invitereq_info.go_bssid, ETH_ALEN );
+	memcpy(p2pie + p2pielen, pwdinfo->invitereq_info.go_bssid, ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
 	//	SSID
-	memcpy( p2pie + p2pielen, pwdinfo->invitereq_info.go_ssid, pwdinfo->invitereq_info.ssidlen );
+	memcpy(p2pie + p2pielen, pwdinfo->invitereq_info.go_ssid, pwdinfo->invitereq_info.ssidlen);
 	p2pielen += pwdinfo->invitereq_info.ssidlen;
 
 
@@ -3960,30 +3934,30 @@ void issue_p2p_invitation_request(struct
 	//	Length:
 	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
 	//	Value:
 	//	P2P Device Address
-	memcpy( p2pie + p2pielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+	memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
 	//	Config Method
 	//	This field should be big endian. Noted by P2P specification.
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_CONFIG_METHOD_DISPLAY );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY);
 	p2pielen += 2;
 
 	//	Primary Device Type
 	//	Category ID
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
 	//	OUI
-	*(u32*) ( p2pie + p2pielen ) = cpu_to_be32( WPSOUI );
+	*(u32*) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 	p2pielen += 4;
 
 	//	Sub Category ID
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_SCID_MEDIA_SERVER );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
 	//	Number of Secondary Device Types
@@ -3991,18 +3965,18 @@ void issue_p2p_invitation_request(struct
 
 	//	Device Name
 	//	Type:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( pwdinfo->device_name_len );
+	*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 	p2pielen += 2;
 
 	//	Value:
-	memcpy( p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len );
+	memcpy(p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len);
 	p2pielen += pwdinfo->device_name_len;
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen);
 
 #ifdef CONFIG_WFD
 	wfdielen = build_invitation_req_wfd_ie(pwdinfo, pframe);
@@ -4015,12 +3989,10 @@ void issue_p2p_invitation_request(struct
 	dump_mgntframe(padapter, pmgntframe);
 
 	return;
-
 }
 
 void issue_p2p_invitation_response(struct rtw_adapter *padapter, u8* raddr, u8 dialogToken, u8 status_code)
 {
-
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u32			p2poui = cpu_to_be32(P2POUI);
@@ -4047,7 +4019,7 @@ void issue_p2p_invitation_response(struc
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo);
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
@@ -4097,8 +4069,8 @@ void issue_p2p_invitation_response(struc
 	//	According to the P2P Specification, the P2P Invitation response frame should contain 5 P2P attributes
 	//	1. Status
 	//	2. Configuration Timeout
-	//	3. Operating Channel	( Only GO )
-	//	4. P2P Group BSSID	( Only GO )
+	//	3. Operating Channel	(Only GO)
+	//	4. P2P Group BSSID	(Only GO)
 	//	5. Channel List
 
 	//	P2P Status
@@ -4106,7 +4078,7 @@ void issue_p2p_invitation_response(struc
 	p2pie[ p2pielen++ ] = P2P_ATTR_STATUS;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0001 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	//	Value:
@@ -4123,16 +4095,16 @@ void issue_p2p_invitation_response(struc
 	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
 
 	//	Length:
-	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	//	Value:
 	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P GO
 	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P Client
 
-	if ( status_code == P2P_STATUS_SUCCESS )
+	if (status_code == P2P_STATUS_SUCCESS)
 	{
-		if ( rtw_p2p_chk_role( pwdinfo, P2P_ROLE_GO ) )
+		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 		{
 			//	The P2P Invitation request frame asks this Wi-Fi device to be the P2P GO
 			//	In this case, the P2P Invitation response frame should carry the two more P2P attributes.
@@ -4144,7 +4116,7 @@ void issue_p2p_invitation_response(struc
 			p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
 
 			//	Length:
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0005 );
+			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 			p2pielen += 2;
 
 			//	Value:
@@ -4168,12 +4140,12 @@ void issue_p2p_invitation_response(struc
 			p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_BSSID;
 
 			//	Length:
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( ETH_ALEN );
+			*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
 			p2pielen += 2;
 
 			//	Value:
 			//	P2P Device Address for GO
-			memcpy( p2pie + p2pielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+			memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 			p2pielen += ETH_ALEN;
 
 		}
@@ -4184,24 +4156,24 @@ void issue_p2p_invitation_response(struc
 
 		//	Length:
 		// Country String(3)
-		// + ( Operating Class (1) + Number of Channels(1) ) * Operation Classes (?)
+		// + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?)
 		// + number of channels in all classes
 		len_channellist_attr = 3
 			+ (1 + 1) * (u16)pmlmeext->channel_list.reg_classes
 			+ get_reg_classes_full_count(pmlmeext->channel_list);
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+		if (check_buddy_fwstate(padapter, _FW_LINKED))
 		{
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 5 + 1 );
+			*(u16*) (p2pie + p2pielen) = cpu_to_le16(5 + 1);
 		}
 		else
 		{
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( len_channellist_attr );
+			*(u16*) (p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 		}
 #else
 
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( len_channellist_attr );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 
 #endif
 		p2pielen += 2;
@@ -4217,15 +4189,15 @@ void issue_p2p_invitation_response(struc
 
 		//	Channel Entry List
 #ifdef CONFIG_CONCURRENT_MODE
-		if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+		if (check_buddy_fwstate(padapter, _FW_LINKED))
 		{
 			struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 			struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
 			//	Operating Class
-			if ( pbuddy_mlmeext->cur_channel > 14 )
+			if (pbuddy_mlmeext->cur_channel > 14)
 			{
-				if ( pbuddy_mlmeext->cur_channel >= 149 )
+				if (pbuddy_mlmeext->cur_channel >= 149)
 				{
 					p2pie[ p2pielen++ ] = 0x7c;
 				}
@@ -4281,7 +4253,7 @@ void issue_p2p_invitation_response(struc
 #endif // CONFIG_CONCURRENT_MODE
 	}
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen);
 
 #ifdef CONFIG_WFD
 	wfdielen = build_invitation_resp_wfd_ie(pwdinfo, pframe);
@@ -4294,10 +4266,9 @@ void issue_p2p_invitation_response(struc
 	dump_mgntframe(padapter, pmgntframe);
 
 	return;
-
 }
 
-void issue_p2p_provision_request(struct rtw_adapter *padapter, u8* pssid, u8 ussidlen, u8* pdev_raddr )
+void issue_p2p_provision_request(struct rtw_adapter *padapter, u8* pssid, u8 ussidlen, u8* pdev_raddr)
 {
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8			action = P2P_PUB_ACTION_ACTION;
@@ -4327,7 +4298,7 @@ void issue_p2p_provision_request(struct
 		return;
 	}
 
-	DBG_8192D( "[%s] In\n", __func__ );
+	DBG_8192D("[%s] In\n", __func__);
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
@@ -4357,23 +4328,23 @@ void issue_p2p_provision_request(struct
 	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
-	p2pielen = build_prov_disc_request_p2p_ie( pwdinfo, pframe, pssid, ussidlen, pdev_raddr );
+	p2pielen = build_prov_disc_request_p2p_ie(pwdinfo, pframe, pssid, ussidlen, pdev_raddr);
 
 	pframe += p2pielen;
 	pattrib->pktlen += p2pielen;
 
 	wpsielen = 0;
 	//	WPS OUI
-	*(u32*) ( wpsie ) = cpu_to_be32( WPSOUI );
+	*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 	wpsielen += 4;
 
 	//	WPS version
 	//	Type:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_VER1 );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 	wpsielen += 2;
 
 	//	Length:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 	wpsielen += 2;
 
 	//	Value:
@@ -4381,18 +4352,18 @@ void issue_p2p_provision_request(struct
 
 	//	Config Method
 	//	Type:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_CONF_METHOD );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
 	wpsielen += 2;
 
 	//	Length:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0002 );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 	wpsielen += 2;
 
 	//	Value:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( pwdinfo->tx_prov_disc_info.wps_config_method_request );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->tx_prov_disc_info.wps_config_method_request);
 	wpsielen += 2;
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen );
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
 
 
 #ifdef CONFIG_WFD
@@ -4406,30 +4377,29 @@ void issue_p2p_provision_request(struct
 	dump_mgntframe(padapter, pmgntframe);
 
 	return;
-
 }
 
 
-u8 is_matched_in_profilelist( u8* peermacaddr, struct profile_info* profileinfo )
+u8 is_matched_in_profilelist(u8* peermacaddr, struct profile_info* profileinfo)
 {
 	u8 i, match_result = 0;
 
-	DBG_8192D( "[%s] peermac = %.2X %.2X %.2X %.2X %.2X %.2X\n", __func__,
+	DBG_8192D("[%s] peermac = %.2X %.2X %.2X %.2X %.2X %.2X\n", __func__,
 		    peermacaddr[0], peermacaddr[1],peermacaddr[2],peermacaddr[3],peermacaddr[4],peermacaddr[5]);
 
-	for ( i = 0; i < P2P_MAX_PERSISTENT_GROUP_NUM; i++, profileinfo++ )
+	for (i = 0; i < P2P_MAX_PERSISTENT_GROUP_NUM; i++, profileinfo++)
 	{
-	       DBG_8192D( "[%s] profileinfo_mac = %.2X %.2X %.2X %.2X %.2X %.2X\n", __func__,
+	       DBG_8192D("[%s] profileinfo_mac = %.2X %.2X %.2X %.2X %.2X %.2X\n", __func__,
 			    profileinfo->peermac[0], profileinfo->peermac[1],profileinfo->peermac[2],profileinfo->peermac[3],profileinfo->peermac[4],profileinfo->peermac[5]);
-		if ( _rtw_memcmp( peermacaddr, profileinfo->peermac, ETH_ALEN ) )
+		if (_rtw_memcmp(peermacaddr, profileinfo->peermac, ETH_ALEN))
 		{
 			match_result = 1;
-			DBG_8192D( "[%s] Match!\n", __func__ );
+			DBG_8192D("[%s] Match!\n", __func__);
 			break;
 		}
 	}
 
-	return (match_result );
+	return (match_result);
 }
 
 void issue_probersp_p2p(struct rtw_adapter *padapter, unsigned char *da)
@@ -4519,12 +4489,12 @@ void issue_probersp_p2p(struct rtw_adapt
 	pframe = rtw_set_ie(pframe, _SSID_IE_, 7, pwdinfo->p2p_wildcard_ssid, &pattrib->pktlen);
 
 	// supported rates...
-	//	Use the OFDM rate in the P2P probe response frame. ( 6(B), 9(B), 12, 18, 24, 36, 48, 54 )
+	//	Use the OFDM rate in the P2P probe response frame. (6(B), 9(B), 12, 18, 24, 36, 48, 54)
 	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pwdinfo->support_rate, &pattrib->pktlen);
 
 	// DS parameter set
 #ifdef CONFIG_IOCTL_CFG80211
-	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && listen_channel !=0 )
+	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && listen_channel !=0)
 	{
 		pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&listen_channel, &pattrib->pktlen);
 	}
@@ -4538,7 +4508,7 @@ void issue_probersp_p2p(struct rtw_adapt
 #ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
 	{
-		if ( pmlmepriv->wps_probe_resp_ie != NULL && pmlmepriv->p2p_probe_resp_ie != NULL )
+		if (pmlmepriv->wps_probe_resp_ie != NULL && pmlmepriv->p2p_probe_resp_ie != NULL)
 		{
 			//WPS IE
 			memcpy(pframe, pmlmepriv->wps_probe_resp_ie, pmlmepriv->wps_probe_resp_ie_len);
@@ -4554,23 +4524,22 @@ void issue_probersp_p2p(struct rtw_adapt
 	else
 #endif //CONFIG_IOCTL_CFG80211
 	{
-
 		//	Todo: WPS IE
 		//	Noted by Albert 20100907
 		//	According to the WPS specification, all the WPS attribute is presented by Big Endian.
 
 		wpsielen = 0;
 		//	WPS OUI
-		*(u32*) ( wpsie ) = cpu_to_be32( WPSOUI );
+		*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 		wpsielen += 4;
 
 		//	WPS version
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_VER1 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
 		//	Value:
@@ -4579,41 +4548,41 @@ void issue_probersp_p2p(struct rtw_adapt
 #ifdef CONFIG_INTEL_WIDI
 		//	Commented by Kurt
 		//	Appended WiDi info. only if we did issued_probereq_widi(), and then we saved ven. ext. in pmlmepriv->sa_ext.
-		if (  _rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == false )
+		if ( _rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == false)
 		{
 			//Sec dev type
-			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_SEC_DEV_TYPE_LIST );
+			*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_SEC_DEV_TYPE_LIST);
 			wpsielen += 2;
 
 			//	Length:
-			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0008 );
+			*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0008);
 			wpsielen += 2;
 
 			//	Value:
 			//	Category ID
-			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_PDT_CID_DISPLAYS );
+			*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_PDT_CID_DISPLAYS);
 			wpsielen += 2;
 
 			//	OUI
-			*(u32*) ( wpsie + wpsielen ) = cpu_to_be32( INTEL_DEV_TYPE_OUI );
+			*(u32*) (wpsie + wpsielen) = cpu_to_be32(INTEL_DEV_TYPE_OUI);
 			wpsielen += 4;
 
-			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_PDT_SCID_WIDI_CONSUMER_SINK );
+			*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_PDT_SCID_WIDI_CONSUMER_SINK);
 			wpsielen += 2;
 
 			//	Vendor Extension
-			memcpy( wpsie + wpsielen, pmlmepriv->sa_ext, L2SDTA_SERVICE_VE_LEN );
+			memcpy(wpsie + wpsielen, pmlmepriv->sa_ext, L2SDTA_SERVICE_VE_LEN);
 			wpsielen += L2SDTA_SERVICE_VE_LEN;
 		}
 #endif //CONFIG_INTEL_WIDI
 
 		//	WiFi Simple Config State
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_SIMPLE_CONF_STATE );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_SIMPLE_CONF_STATE);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
 		//	Value:
@@ -4621,11 +4590,11 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		//	Response Type
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_RESP_TYPE );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_RESP_TYPE);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
 		//	Value:
@@ -4633,50 +4602,50 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		//	UUID-E
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_UUID_E );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_UUID_E);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0010 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0010);
 		wpsielen += 2;
 
 		//	Value:
-		memcpy( wpsie + wpsielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+		memcpy(wpsie + wpsielen, myid(&padapter->eeprompriv), ETH_ALEN);
 		wpsielen += 0x10;
 
 		//	Manufacturer
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_MANUFACTURER );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_MANUFACTURER);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0007 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0007);
 		wpsielen += 2;
 
 		//	Value:
-		memcpy( wpsie + wpsielen, "Realtek", 7 );
+		memcpy(wpsie + wpsielen, "Realtek", 7);
 		wpsielen += 7;
 
 		//	Model Name
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_MODEL_NAME );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_MODEL_NAME);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0006 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0006);
 		wpsielen += 2;
 
 		//	Value:
-		memcpy( wpsie + wpsielen, "8192CU", 6 );
+		memcpy(wpsie + wpsielen, "8192CU", 6);
 		wpsielen += 6;
 
 		//	Model Number
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_MODEL_NUMBER );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_MODEL_NUMBER);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
 		//	Value:
@@ -4684,67 +4653,67 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		//	Serial Number
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_SERIAL_NUMBER );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_SERIAL_NUMBER);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( ETH_ALEN );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(ETH_ALEN);
 		wpsielen += 2;
 
 		//	Value:
-		memcpy( wpsie + wpsielen, "123456" , ETH_ALEN );
+		memcpy(wpsie + wpsielen, "123456" , ETH_ALEN);
 		wpsielen += ETH_ALEN;
 
 		//	Primary Device Type
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_PRIMARY_DEV_TYPE );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0008 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0008);
 		wpsielen += 2;
 
 		//	Value:
 		//	Category ID
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_PDT_CID_RTK_WIDI );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_PDT_CID_RTK_WIDI);
 		wpsielen += 2;
 
 		//	OUI
-		*(u32*) ( wpsie + wpsielen ) = cpu_to_be32( WPSOUI );
+		*(u32*) (wpsie + wpsielen) = cpu_to_be32(WPSOUI);
 		wpsielen += 4;
 
 		//	Sub Category ID
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_PDT_SCID_RTK_DMP );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_PDT_SCID_RTK_DMP);
 		wpsielen += 2;
 
 		//	Device Name
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( pwdinfo->device_name_len );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->device_name_len);
 		wpsielen += 2;
 
 		//	Value:
-		memcpy( wpsie + wpsielen, pwdinfo->device_name, pwdinfo->device_name_len );
+		memcpy(wpsie + wpsielen, pwdinfo->device_name, pwdinfo->device_name_len);
 		wpsielen += pwdinfo->device_name_len;
 
 		//	Config Method
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_CONF_METHOD );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0002 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 		wpsielen += 2;
 
 		//	Value:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( pwdinfo->supported_wps_cm );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
 		wpsielen += 2;
 
 
-		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen );
+		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
 
 
 		p2pielen = build_probe_resp_p2p_ie(pwdinfo, pframe);
@@ -4754,7 +4723,7 @@ void issue_probersp_p2p(struct rtw_adapt
 
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
-	if ( true == pwdinfo->wfd_info->wfd_enable )
+	if (true == pwdinfo->wfd_info->wfd_enable)
 #endif //CONFIG_IOCTL_CFG80211
 	{
 		wfdielen = build_probe_resp_wfd_ie(pwdinfo, pframe, 0);
@@ -4778,7 +4747,6 @@ void issue_probersp_p2p(struct rtw_adapt
 	dump_mgntframe(padapter, pmgntframe);
 
 	return;
-
 }
 
 int _issue_probereq_p2p(struct rtw_adapter *padapter, u8 *da, int wait_ack)
@@ -4830,7 +4798,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 		memcpy(pwlanhdr->addr1, da, ETH_ALEN);
 		memcpy(pwlanhdr->addr3, da, ETH_ALEN);
 	} else {
-		if ( ( pwdinfo->p2p_info.scan_op_ch_only ) || ( pwdinfo->rx_invitereq_info.scan_op_ch_only ) )
+		if ((pwdinfo->p2p_info.scan_op_ch_only) || (pwdinfo->rx_invitereq_info.scan_op_ch_only))
 		{
 			//	This two flags will be set when this is only the P2P client mode.
 			memcpy(pwlanhdr->addr1, pwdinfo->p2p_peer_interface_addr, ETH_ALEN);
@@ -4860,13 +4828,13 @@ int _issue_probereq_p2p(struct rtw_adapt
 	{
 		pframe = rtw_set_ie(pframe, _SSID_IE_, P2P_WILDCARD_SSID_LEN, pwdinfo->p2p_wildcard_ssid, &(pattrib->pktlen));
 	}
-	//	Use the OFDM rate in the P2P probe request frame. ( 6(B), 9(B), 12(B), 24(B), 36, 48, 54 )
+	//	Use the OFDM rate in the P2P probe request frame. (6(B), 9(B), 12(B), 24(B), 36, 48, 54)
 	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pwdinfo->support_rate, &pattrib->pktlen);
 
 #ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
 	{
-		if ( pmlmepriv->wps_probe_req_ie != NULL && pmlmepriv->p2p_probe_req_ie != NULL )
+		if (pmlmepriv->wps_probe_req_ie != NULL && pmlmepriv->p2p_probe_req_ie != NULL)
 		{
 			//WPS IE
 			memcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);
@@ -4882,106 +4850,105 @@ int _issue_probereq_p2p(struct rtw_adapt
 	else
 #endif //CONFIG_IOCTL_CFG80211
 	{
-
 		//	WPS IE
 		//	Noted by Albert 20110221
 		//	According to the WPS specification, all the WPS attribute is presented by Big Endian.
 
 		wpsielen = 0;
 		//	WPS OUI
-		*(u32*) ( wpsie ) = cpu_to_be32( WPSOUI );
+		*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 		wpsielen += 4;
 
 		//	WPS version
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_VER1 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
 		//	Value:
 		wpsie[wpsielen++] = WPS_VERSION_1;	//	Version 1.0
 
-		if ( pmlmepriv->wps_probe_req_ie == NULL )
+		if (pmlmepriv->wps_probe_req_ie == NULL)
 		{
 			//	UUID-E
 			//	Type:
-			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_UUID_E );
+			*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_UUID_E);
 			wpsielen += 2;
 
 			//	Length:
-			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0010 );
+			*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0010);
 			wpsielen += 2;
 
 			//	Value:
-			memcpy( wpsie + wpsielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+			memcpy(wpsie + wpsielen, myid(&padapter->eeprompriv), ETH_ALEN);
 			wpsielen += 0x10;
 
 			//	Config Method
 			//	Type:
-			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_CONF_METHOD );
+			*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
 			wpsielen += 2;
 
 			//	Length:
-			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0002 );
+			*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 			wpsielen += 2;
 
 			//	Value:
-			*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( pwdinfo->supported_wps_cm );
+			*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
 			wpsielen += 2;
 		}
 
 		//	Device Name
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( pwdinfo->device_name_len );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->device_name_len);
 		wpsielen += 2;
 
 		//	Value:
-		memcpy( wpsie + wpsielen, pwdinfo->device_name, pwdinfo->device_name_len );
+		memcpy(wpsie + wpsielen, pwdinfo->device_name, pwdinfo->device_name_len);
 		wpsielen += pwdinfo->device_name_len;
 
 		//	Primary Device Type
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_PRIMARY_DEV_TYPE );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0008 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0008);
 		wpsielen += 2;
 
 		//	Value:
 		//	Category ID
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 		wpsielen += 2;
 
 		//	OUI
-		*(u32*) ( wpsie + wpsielen ) = cpu_to_be32( WPSOUI );
+		*(u32*) (wpsie + wpsielen) = cpu_to_be32(WPSOUI);
 		wpsielen += 4;
 
 		//	Sub Category ID
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_PDT_SCID_MEDIA_SERVER );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 		wpsielen += 2;
 
 		//	Device Password ID
 		//	Type:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_DEVICE_PWID );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
 		wpsielen += 2;
 
 		//	Length:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0002 );
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 		wpsielen += 2;
 
 		//	Value:
-		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_DPID_REGISTRAR_SPEC );	//	Registrar-specified
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);	//	Registrar-specified
 		wpsielen += 2;
 
-		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen );
+		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
 
 		//	P2P OUI
 		p2pielen = 0;
@@ -5003,7 +4970,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 		p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
 		//	Length:
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 		p2pielen += 2;
 
 		//	Value:
@@ -5011,7 +4978,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 		p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 
 		//	Group Capability Bitmap, 1 byte
-		if ( pwdinfo->persistent_supported )
+		if (pwdinfo->persistent_supported)
 			p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
 		else
 			p2pie[ p2pielen++ ] = DMP_P2P_GRPCAP_SUPPORT;
@@ -5021,7 +4988,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 		p2pie[ p2pielen++ ] = P2P_ATTR_LISTEN_CH;
 
 		//	Length:
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0005 );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 		p2pielen += 2;
 
 		//	Value:
@@ -5045,26 +5012,26 @@ int _issue_probereq_p2p(struct rtw_adapt
 		p2pie[ p2pielen++ ] = P2P_ATTR_EX_LISTEN_TIMING;
 
 		//	Length:
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0004 );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0004);
 		p2pielen += 2;
 
 		//	Value:
 		//	Availability Period
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0xFFFF );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 		p2pielen += 2;
 
 		//	Availability Interval
-		*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0xFFFF );
+		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 		p2pielen += 2;
 
-		if ( rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) )
+		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 		{
 			//	Operating Channel (if this WiFi is working as the group owner now)
 			//	Type:
 			p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
 
 			//	Length:
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0005 );
+			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 			p2pielen += 2;
 
 			//	Value:
@@ -5084,9 +5051,9 @@ int _issue_probereq_p2p(struct rtw_adapt
 
 		}
 
-		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
+		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen);
 
-		if ( pmlmepriv->wps_probe_req_ie != NULL )
+		if (pmlmepriv->wps_probe_req_ie != NULL)
 		{
 			//WPS IE
 			memcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);
@@ -5097,7 +5064,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
-	if ( true == pwdinfo->wfd_info->wfd_enable )
+	if (true == pwdinfo->wfd_info->wfd_enable)
 #endif
 	{
 		wfdielen = build_probe_req_wfd_ie(pwdinfo, pframe);
@@ -5183,7 +5150,7 @@ s32 rtw_action_public_decache(union recv
 	struct rtw_adapter *adapter = recv_frame->u.hdr.adapter;
 	struct mlme_ext_priv *mlmeext = &(adapter->mlmeextpriv);
 	u8 *frame = recv_frame->u.hdr.rx_data;
-	u16 seq_ctrl = ( (recv_frame->u.hdr.attrib.seq_num&0xffff) << 4) |
+	u16 seq_ctrl = ((recv_frame->u.hdr.attrib.seq_num&0xffff) << 4) |
 		(recv_frame->u.hdr.attrib.frag_num & 0xf);
 
 	if (GetRetry(frame)) {
@@ -5222,7 +5189,7 @@ unsigned int on_action_public_p2p(union
 #ifdef CONFIG_P2P
 	u8 *p2p_ie;
 	u32	p2p_ielen, wps_ielen;
-	struct	wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+	struct	wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 	u8	result = P2P_STATUS_SUCCESS;
 	u8	empty_addr[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 #endif //CONFIG_P2P
@@ -5235,7 +5202,7 @@ unsigned int on_action_public_p2p(union
 		return _FAIL;
 
 #ifdef CONFIG_P2P
-	_cancel_timer_ex( &pwdinfo->reset_ch_sitesurvey );
+	_cancel_timer_ex(&pwdinfo->reset_ch_sitesurvey);
 #ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
 	{
@@ -5250,12 +5217,12 @@ unsigned int on_action_public_p2p(union
 
 		len -= sizeof(struct rtw_ieee80211_hdr_3addr);
 
-		switch ( frame_body[ 6 ] )//OUI Subtype
+		switch (frame_body[ 6 ])//OUI Subtype
 		{
 			case P2P_GO_NEGO_REQ:
 			{
-				DBG_8192D( "[%s] Got GO Nego Req Frame\n", __func__);
-				memset( &pwdinfo->groupid_info, 0x00, sizeof( struct group_id_info ) );
+				DBG_8192D("[%s] Got GO Nego Req Frame\n", __func__);
+				memset(&pwdinfo->groupid_info, 0x00, sizeof(struct group_id_info));
 
 				if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ))
 				{
@@ -5266,15 +5233,15 @@ unsigned int on_action_public_p2p(union
 				{
 					//	Commented by Albert 20110526
 					//	In this case, this means the previous nego fail doesn't be reset yet.
-					_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
+					_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
 					//	Restore the previous p2p state
 					rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
-					DBG_8192D( "[%s] Restore the previous p2p state to %d\n", __func__, rtw_p2p_state(pwdinfo) );
+					DBG_8192D("[%s] Restore the previous p2p state to %d\n", __func__, rtw_p2p_state(pwdinfo));
 				}
 #ifdef CONFIG_CONCURRENT_MODE
-				if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+				if (check_buddy_fwstate(padapter, _FW_LINKED))
 				{
-					_cancel_timer_ex( &pwdinfo->ap_p2p_switch_timer );
+					_cancel_timer_ex(&pwdinfo->ap_p2p_switch_timer);
 				}
 #endif // CONFIG_CONCURRENT_MODE
 
@@ -5285,13 +5252,13 @@ unsigned int on_action_public_p2p(union
 
 				//	Commented by Kurt 20120113
 				//	Get peer_dev_addr here if peer doesn't issue prov_disc frame.
-				if ( _rtw_memcmp(pwdinfo->rx_prov_disc_info.peerDevAddr, empty_addr, ETH_ALEN) );
+				if (_rtw_memcmp(pwdinfo->rx_prov_disc_info.peerDevAddr, empty_addr, ETH_ALEN));
 					memcpy(pwdinfo->rx_prov_disc_info.peerDevAddr, GetAddr2Ptr(pframe), ETH_ALEN);
 
-				result = process_p2p_group_negotation_req( pwdinfo, frame_body, len );
-				issue_p2p_GO_response( padapter, GetAddr2Ptr(pframe), frame_body, len, result );
+				result = process_p2p_group_negotation_req(pwdinfo, frame_body, len);
+				issue_p2p_GO_response(padapter, GetAddr2Ptr(pframe), frame_body, len, result);
 #ifdef CONFIG_INTEL_WIDI
-				if ( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
+				if ((padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION))
 				{
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
@@ -5302,31 +5269,31 @@ unsigned int on_action_public_p2p(union
 				//	No matter negotiating or negotiation failure, the driver should set up the restore P2P state timer.
 #ifdef CONFIG_CONCURRENT_MODE
 				//	Commented by Albert 20120107
-				_set_timer( &pwdinfo->restore_p2p_state_timer, 3000 );
+				_set_timer(&pwdinfo->restore_p2p_state_timer, 3000);
 #else // CONFIG_CONCURRENT_MODE
-				_set_timer( &pwdinfo->restore_p2p_state_timer, 5000 );
+				_set_timer(&pwdinfo->restore_p2p_state_timer, 5000);
 #endif // CONFIG_CONCURRENT_MODE
 				break;
 			}
 			case P2P_GO_NEGO_RESP:
 			{
-				DBG_8192D( "[%s] Got GO Nego Resp Frame\n", __func__);
+				DBG_8192D("[%s] Got GO Nego Resp Frame\n", __func__);
 
 				if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
 				{
 					//	Commented by Albert 20110425
 					//	The restore timer is enabled when issuing the nego request frame of rtw_p2p_connect function.
-					_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
+					_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
 					pwdinfo->nego_req_info.benable = false;
-					result = process_p2p_group_negotation_resp( pwdinfo, frame_body, len);
-					issue_p2p_GO_confirm( pwdinfo->padapter, GetAddr2Ptr(pframe), result);
-					if ( P2P_STATUS_SUCCESS == result )
+					result = process_p2p_group_negotation_resp(pwdinfo, frame_body, len);
+					issue_p2p_GO_confirm(pwdinfo->padapter, GetAddr2Ptr(pframe), result);
+					if (P2P_STATUS_SUCCESS == result)
 					{
-						if ( rtw_p2p_role(pwdinfo) == P2P_ROLE_CLIENT )
+						if (rtw_p2p_role(pwdinfo) == P2P_ROLE_CLIENT)
 						{
 							pwdinfo->p2p_info.operation_ch[ 0 ] = pwdinfo->peer_operating_ch;
 							pwdinfo->p2p_info.scan_op_ch_only = 1;
-							_set_timer( &pwdinfo->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH );
+							_set_timer(&pwdinfo->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH);
 						}
 					}
 
@@ -5335,27 +5302,27 @@ unsigned int on_action_public_p2p(union
 
 					if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
 					{
-						_set_timer( &pwdinfo->restore_p2p_state_timer, 5000 );
+						_set_timer(&pwdinfo->restore_p2p_state_timer, 5000);
 					}
 				}
 				else
 				{
-					DBG_8192D( "[%s] Skipped GO Nego Resp Frame (p2p_state != P2P_STATE_GONEGO_ING)\n", __func__);
+					DBG_8192D("[%s] Skipped GO Nego Resp Frame (p2p_state != P2P_STATE_GONEGO_ING)\n", __func__);
 				}
 
 				break;
 			}
 			case P2P_GO_NEGO_CONF:
 			{
-				DBG_8192D( "[%s] Got GO Nego Confirm Frame\n", __func__);
-				result = process_p2p_group_negotation_confirm( pwdinfo, frame_body, len);
-				if ( P2P_STATUS_SUCCESS == result )
+				DBG_8192D("[%s] Got GO Nego Confirm Frame\n", __func__);
+				result = process_p2p_group_negotation_confirm(pwdinfo, frame_body, len);
+				if (P2P_STATUS_SUCCESS == result)
 				{
-					if ( rtw_p2p_role(pwdinfo) == P2P_ROLE_CLIENT )
+					if (rtw_p2p_role(pwdinfo) == P2P_ROLE_CLIENT)
 					{
 						pwdinfo->p2p_info.operation_ch[ 0 ] = pwdinfo->peer_operating_ch;
 						pwdinfo->p2p_info.scan_op_ch_only = 1;
-						_set_timer( &pwdinfo->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH );
+						_set_timer(&pwdinfo->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH);
 					}
 				}
 				break;
@@ -5365,8 +5332,8 @@ unsigned int on_action_public_p2p(union
 				//	Added by Albert 2010/10/05
 				//	Received the P2P Invite Request frame.
 
-				DBG_8192D( "[%s] Got invite request frame!\n", __func__ );
-				if ( (p2p_ie=rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)) )
+				DBG_8192D("[%s] Got invite request frame!\n", __func__);
+				if ((p2p_ie=rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)))
 				{
 					//	Parse the necessary information from the P2P Invitation Request frame.
 					//	For example: The MAC address of sending this P2P Invitation Request frame.
@@ -5375,65 +5342,64 @@ unsigned int on_action_public_p2p(union
 					struct group_id_info group_id;
 					u8	invitation_flag = 0;
 
-					rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_INVITATION_FLAGS, &invitation_flag, &attr_contentlen);
-					if ( attr_contentlen )
+					rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INVITATION_FLAGS, &invitation_flag, &attr_contentlen);
+					if (attr_contentlen)
 					{
-
-						rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_GROUP_BSSID, pwdinfo->p2p_peer_interface_addr, &attr_contentlen);
+						rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_BSSID, pwdinfo->p2p_peer_interface_addr, &attr_contentlen);
 						//	Commented by Albert 20120510
 						//	Copy to the pwdinfo->p2p_peer_interface_addr.
-						//	So that the WFD UI ( or Sigma ) can get the peer interface address by using the following command.
+						//	So that the WFD UI (or Sigma) can get the peer interface address by using the following command.
 						//	#> iwpriv wlan0 p2p_get peer_ifa
 						//	After having the peer interface address, the sigma can find the correct conf file for wpa_supplicant.
 
-						if ( attr_contentlen )
+						if (attr_contentlen)
 						{
-							DBG_8192D( "[%s] GO's BSSID = %.2X %.2X %.2X %.2X %.2X %.2X\n", __func__,
+							DBG_8192D("[%s] GO's BSSID = %.2X %.2X %.2X %.2X %.2X %.2X\n", __func__,
 									pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1],
 									pwdinfo->p2p_peer_interface_addr[2], pwdinfo->p2p_peer_interface_addr[3],
-									pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5] );
+									pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
 						}
 
-						if ( invitation_flag & P2P_INVITATION_FLAGS_PERSISTENT )
+						if (invitation_flag & P2P_INVITATION_FLAGS_PERSISTENT)
 						{
 							//	Re-invoke the persistent group.
 
-							memset( &group_id, 0x00, sizeof( struct group_id_info ) );
-							rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, ( u8* ) &group_id, &attr_contentlen);
-							if ( attr_contentlen )
+							memset(&group_id, 0x00, sizeof(struct group_id_info));
+							rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, (u8*) &group_id, &attr_contentlen);
+							if (attr_contentlen)
 							{
-								if ( _rtw_memcmp( group_id.go_device_addr, myid( &padapter->eeprompriv ), ETH_ALEN ) )
+								if (_rtw_memcmp(group_id.go_device_addr, myid(&padapter->eeprompriv), ETH_ALEN))
 								{
 									//	The p2p device sending this p2p invitation request wants this Wi-Fi device to be the persistent GO.
-									rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_GO );
-									rtw_p2p_set_role( pwdinfo, P2P_ROLE_GO );
+									rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_GO);
+									rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
 									status_code = P2P_STATUS_SUCCESS;
 								}
 								else
 								{
 									//	The p2p device sending this p2p invitation request wants to be the persistent GO.
-									if ( is_matched_in_profilelist( pwdinfo->p2p_peer_interface_addr, &pwdinfo->profileinfo[ 0 ] ) )
+									if (is_matched_in_profilelist(pwdinfo->p2p_peer_interface_addr, &pwdinfo->profileinfo[ 0 ]))
 									{
 										u8 operatingch_info[5] = { 0x00 };
-										if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen) )
+										if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen))
 										{
-											if ( rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, (u32)operatingch_info[4] ) )
+											if (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, (u32)operatingch_info[4]))
 											{
 												//	The operating channel is acceptable for this device.
 												pwdinfo->rx_invitereq_info.operation_ch[0]= operatingch_info[4];
 												pwdinfo->rx_invitereq_info.scan_op_ch_only = 1;
-												_set_timer( &pwdinfo->reset_ch_sitesurvey, P2P_RESET_SCAN_CH );
-												rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_MATCH );
-												rtw_p2p_set_role( pwdinfo, P2P_ROLE_CLIENT );
+												_set_timer(&pwdinfo->reset_ch_sitesurvey, P2P_RESET_SCAN_CH);
+												rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_MATCH);
+												rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 												status_code = P2P_STATUS_SUCCESS;
 												}
 											else
 											{
 												//	The operating channel isn't supported by this device.
-												rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_DISMATCH );
-												rtw_p2p_set_role( pwdinfo, P2P_ROLE_DEVICE );
+												rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_DISMATCH);
+												rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
 												status_code = P2P_STATUS_FAIL_NO_COMMON_CH;
-												_set_timer( &pwdinfo->restore_p2p_state_timer, 3000 );
+												_set_timer(&pwdinfo->restore_p2p_state_timer, 3000);
 											}
 										}
 										else
@@ -5441,17 +5407,17 @@ unsigned int on_action_public_p2p(union
 											//	Commented by Albert 20121130
 											//	Intel will use the different P2P IE to store the operating channel information
 											//	Workaround for Intel WiDi 3.5
-											rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_MATCH );
-											rtw_p2p_set_role( pwdinfo, P2P_ROLE_CLIENT );
+											rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_MATCH);
+											rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 											status_code = P2P_STATUS_SUCCESS;
 										}
 									}
 									else
 									{
-										rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_DISMATCH );
+										rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_DISMATCH);
 										#ifdef CONFIG_INTEL_WIDI
-										memcpy( pwdinfo->p2p_peer_device_addr, group_id.go_device_addr , ETH_ALEN );
-										rtw_p2p_set_role( pwdinfo, P2P_ROLE_CLIENT );
+										memcpy(pwdinfo->p2p_peer_device_addr, group_id.go_device_addr , ETH_ALEN);
+										rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 										#endif //CONFIG_INTEL_WIDI
 
 										status_code = P2P_STATUS_FAIL_UNKNOWN_P2PGROUP;
@@ -5460,7 +5426,7 @@ unsigned int on_action_public_p2p(union
 							}
 							else
 							{
-								DBG_8192D( "[%s] P2P Group ID Attribute NOT FOUND!\n", __func__ );
+								DBG_8192D("[%s] P2P Group ID Attribute NOT FOUND!\n", __func__);
 								status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
 							}
 						}
@@ -5468,14 +5434,14 @@ unsigned int on_action_public_p2p(union
 						{
 							//	Received the invitation to join a P2P group.
 
-							memset( &group_id, 0x00, sizeof( struct group_id_info ) );
-							rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, ( u8* ) &group_id, &attr_contentlen);
-							if ( attr_contentlen )
+							memset(&group_id, 0x00, sizeof(struct group_id_info));
+							rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, (u8*) &group_id, &attr_contentlen);
+							if (attr_contentlen)
 							{
-								if ( _rtw_memcmp( group_id.go_device_addr, myid( &padapter->eeprompriv ), ETH_ALEN ) )
+								if (_rtw_memcmp(group_id.go_device_addr, myid(&padapter->eeprompriv), ETH_ALEN))
 								{
 									//	In this case, the GO can't be myself.
-									rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_DISMATCH );
+									rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_DISMATCH);
 									status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
 								}
 								else
@@ -5486,32 +5452,32 @@ unsigned int on_action_public_p2p(union
 									//	The peer device address should be the destination address for the provisioning discovery request.
 									//	Then, this Wi-Fi device should use the iwpriv command to get the peer interface address.
 									//	The peer interface address should be the address for WPS mac address
-									memcpy( pwdinfo->p2p_peer_device_addr, group_id.go_device_addr , ETH_ALEN );
-									rtw_p2p_set_role( pwdinfo, P2P_ROLE_CLIENT );
-									rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_JOIN );
+									memcpy(pwdinfo->p2p_peer_device_addr, group_id.go_device_addr , ETH_ALEN);
+									rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
+									rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_JOIN);
 									status_code = P2P_STATUS_SUCCESS;
 								}
 							}
 							else
 							{
-								DBG_8192D( "[%s] P2P Group ID Attribute NOT FOUND!\n", __func__ );
+								DBG_8192D("[%s] P2P Group ID Attribute NOT FOUND!\n", __func__);
 								status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
 							}
 						}
 					}
 					else
 					{
-						DBG_8192D( "[%s] P2P Invitation Flags Attribute NOT FOUND!\n", __func__ );
+						DBG_8192D("[%s] P2P Invitation Flags Attribute NOT FOUND!\n", __func__);
 						status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
 					}
 
-					DBG_8192D( "[%s] status_code = %d\n", __func__, status_code );
+					DBG_8192D("[%s] status_code = %d\n", __func__, status_code);
 
 					pwdinfo->inviteresp_info.token = frame_body[ 7 ];
-					issue_p2p_invitation_response( padapter, GetAddr2Ptr(pframe), pwdinfo->inviteresp_info.token, status_code );
+					issue_p2p_invitation_response(padapter, GetAddr2Ptr(pframe), pwdinfo->inviteresp_info.token, status_code);
 				}
 #ifdef CONFIG_INTEL_WIDI
-				if ( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
+				if ((padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION))
 				{
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
@@ -5524,50 +5490,50 @@ unsigned int on_action_public_p2p(union
 				u8	attr_content = 0x00;
 				u32	attr_contentlen = 0;
 
-				DBG_8192D( "[%s] Got invite response frame!\n", __func__ );
-				_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
-				if ( (p2p_ie=rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)) )
+				DBG_8192D("[%s] Got invite response frame!\n", __func__);
+				_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
+				if ((p2p_ie=rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)))
 				{
 					rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, &attr_content, &attr_contentlen);
 
-					if ( attr_contentlen == 1 )
+					if (attr_contentlen == 1)
 					{
-						DBG_8192D( "[%s] Status = %d\n", __func__, attr_content );
+						DBG_8192D("[%s] Status = %d\n", __func__, attr_content);
 						pwdinfo->invitereq_info.benable = false;
 
-						if ( attr_content == P2P_STATUS_SUCCESS )
+						if (attr_content == P2P_STATUS_SUCCESS)
 						{
-							if ( _rtw_memcmp( pwdinfo->invitereq_info.go_bssid, myid( &padapter->eeprompriv ), ETH_ALEN ))
+							if (_rtw_memcmp(pwdinfo->invitereq_info.go_bssid, myid(&padapter->eeprompriv), ETH_ALEN))
 							{
-								rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO );
+								rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
 							}
 							else
 							{
 								rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 							}
-							rtw_p2p_set_state( pwdinfo, P2P_STATE_RX_INVITE_RESP_OK );
+							rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_INVITE_RESP_OK);
 						}
 						else
 						{
 							rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
-							rtw_p2p_set_state( pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL );
+							rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL);
 						}
 					}
 					else
 					{
 						rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
-						rtw_p2p_set_state( pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL );
+						rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL);
 					}
 				}
 				else
 				{
 					rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
-					rtw_p2p_set_state( pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL );
+					rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL);
 				}
 
-				if ( rtw_p2p_chk_state( pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL ) )
+				if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL))
 				{
-					_set_timer( &pwdinfo->restore_p2p_state_timer, 5000 );
+					_set_timer(&pwdinfo->restore_p2p_state_timer, 5000);
 				}
 				break;
 			}
@@ -5584,7 +5550,7 @@ unsigned int on_action_public_p2p(union
 				break;
 
 			case P2P_PROVISION_DISC_REQ:
-				DBG_8192D( "[%s] Got Provisioning Discovery Request Frame\n", __func__ );
+				DBG_8192D("[%s] Got Provisioning Discovery Request Frame\n", __func__);
 				process_p2p_provdisc_req(pwdinfo, pframe, len);
 				memcpy(pwdinfo->rx_prov_disc_info.peerDevAddr, GetAddr2Ptr(pframe), ETH_ALEN);
 
@@ -5594,9 +5560,9 @@ unsigned int on_action_public_p2p(union
 					rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
 
 				rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ);
-				_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT );
+				_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
 #ifdef CONFIG_INTEL_WIDI
-				if ( (padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION) )
+				if ((padapter->mlmepriv.widi_state == INTEL_WIDI_STATE_LISTEN) && (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_WFD_CONNECTION))
 				{
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
@@ -5607,13 +5573,13 @@ unsigned int on_action_public_p2p(union
 			case P2P_PROVISION_DISC_RESP:
 				//	Commented by Albert 20110707
 				//	Should we check the pwdinfo->tx_prov_disc_info.bsent flag here??
-				DBG_8192D( "[%s] Got Provisioning Discovery Response Frame\n", __func__ );
+				DBG_8192D("[%s] Got Provisioning Discovery Response Frame\n", __func__);
 				//	Commented by Albert 20110426
 				//	The restore timer is enabled when issuing the provisioing request frame in rtw_p2p_prov_disc function.
-				_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
+				_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
 				rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_RSP);
 				process_p2p_provdisc_resp(pwdinfo, pframe);
-				_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT );
+				_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
 				break;
 
 		}
@@ -5711,7 +5677,7 @@ unsigned int OnAction_p2p(struct rtw_ada
 	u8 category, OUI_Subtype, dialogToken=0;
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	uint len = precv_frame->u.hdr.len;
-	struct	wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+	struct	wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 
 
 	DBG_8192D("%s\n", __func__);
@@ -5726,7 +5692,7 @@ unsigned int OnAction_p2p(struct rtw_ada
 	if (category != RTW_WLAN_CATEGORY_P2P)
 		return _SUCCESS;
 
-	if ( cpu_to_be32( *( ( u32* ) ( frame_body + 1 ) ) ) != P2POUI )
+	if (cpu_to_be32(*((u32*) (frame_body + 1))) != P2POUI)
 		return _SUCCESS;
 
 #ifdef CONFIG_IOCTL_CFG80211
@@ -5770,7 +5736,6 @@ unsigned int OnAction_p2p(struct rtw_ada
 #endif //CONFIG_P2P
 
 	return _SUCCESS;
-
 }
 
 unsigned int OnAction(struct rtw_adapter *padapter, union recv_frame *precv_frame)
@@ -5795,12 +5760,10 @@ unsigned int OnAction(struct rtw_adapter
 	}
 
 	return _SUCCESS;
-
 }
 
 unsigned int DoReserved(struct rtw_adapter *padapter, union recv_frame *precv_frame)
 {
-
 	//DBG_8192D("rcvd mgt frame(%x, %x)\n", (GetFrameSubType(pframe) >> 4), *(unsigned int *)GetAddr1Ptr(pframe));
 	return _SUCCESS;
 }
@@ -5832,7 +5795,6 @@ struct xmit_frame *alloc_mgtxmitframe(st
 	pxmitbuf->priv_data = pmgntframe;
 
 	return pmgntframe;
-
 }
 
 
@@ -5882,7 +5844,6 @@ void update_mgntframe_attrib(struct rtw_
 	pattrib->seqnum = pmlmeext->mgnt_seq;
 
 	pattrib->retry_ctrl = true;
-
 }
 
 void dump_mgntframe(struct rtw_adapter *padapter, struct xmit_frame *pmgntframe)
@@ -6044,7 +6005,7 @@ void issue_beacon(struct rtw_adapter *pa
 	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
 	pattrib->pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
 
-	if ( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 		//DBG_8192D("ie len=%d\n", cur_network->IELength);
 #ifdef CONFIG_P2P
@@ -6100,38 +6061,38 @@ void issue_beacon(struct rtw_adapter *pa
 				//now pframe is end of wsc ie, insert Primary Device Type & Device Name
 				//	Primary Device Type
 				//	Type:
-				*(u16*) ( pframe + insert_len) = cpu_to_be16( WPS_ATTR_PRIMARY_DEV_TYPE );
+				*(u16*) (pframe + insert_len) = cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
 				insert_len += 2;
 
 				//	Length:
-				*(u16*) ( pframe + insert_len ) = cpu_to_be16( 0x0008 );
+				*(u16*) (pframe + insert_len) = cpu_to_be16(0x0008);
 				insert_len += 2;
 
 				//	Value:
 				//	Category ID
-				*(u16*) ( pframe + insert_len ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA );
+				*(u16*) (pframe + insert_len) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 				insert_len += 2;
 
 				//	OUI
-				*(u32*) ( pframe + insert_len ) = cpu_to_be32( WPSOUI );
+				*(u32*) (pframe + insert_len) = cpu_to_be32(WPSOUI);
 				insert_len += 4;
 
 				//	Sub Category ID
-				*(u16*) ( pframe + insert_len ) = cpu_to_be16( WPS_PDT_SCID_MEDIA_SERVER );
+				*(u16*) (pframe + insert_len) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 				insert_len += 2;
 
 
 				//	Device Name
 				//	Type:
-				*(u16*) ( pframe + insert_len ) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+				*(u16*) (pframe + insert_len) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 				insert_len += 2;
 
 				//	Length:
-				*(u16*) ( pframe + insert_len ) = cpu_to_be16( pwdinfo->device_name_len );
+				*(u16*) (pframe + insert_len) = cpu_to_be16(pwdinfo->device_name_len);
 				insert_len += 2;
 
 				//	Value:
-				memcpy( pframe + insert_len, pwdinfo->device_name, pwdinfo->device_name_len );
+				memcpy(pframe + insert_len, pwdinfo->device_name, pwdinfo->device_name_len);
 				insert_len += pwdinfo->device_name_len;
 
 
@@ -6201,7 +6162,7 @@ void issue_beacon(struct rtw_adapter *pa
 			if (true == pwdinfo->wfd_info->wfd_enable)
 #endif //CONFIG_IOCTL_CFG80211
 			{
-			len = build_beacon_wfd_ie( pwdinfo, pframe );
+			len = build_beacon_wfd_ie(pwdinfo, pframe);
 			}
 #ifdef CONFIG_IOCTL_CFG80211
 			else
@@ -6254,7 +6215,7 @@ void issue_beacon(struct rtw_adapter *pa
 	// DS parameter set
 	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pattrib->pktlen);
 
-	//if ( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	//if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
 	{
 		u8 erpinfo=0;
 		u32 ATIMWindow;
@@ -6296,7 +6257,6 @@ _issue_bcn:
 	//DBG_8192D("issue bcn_sz=%d\n", pattrib->last_txcmdsz);
 
 	dump_mgntframe(padapter, pmgntframe);
-
 }
 
 void issue_probersp(struct rtw_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probereq)
@@ -6364,7 +6324,7 @@ void issue_probersp(struct rtw_adapter *
 		return;
 
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
-	if ( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 		pwps_ie = rtw_get_wps_ie(cur_network->IEs+_FIXED_IE_LENGTH_, cur_network->IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen);
 
@@ -6443,7 +6403,6 @@ void issue_probersp(struct rtw_adapter *
 	else
 #endif
 	{
-
 		//timestamp will be inserted by hardware
 		pframe += 8;
 		pattrib->pktlen += 8;
@@ -6474,7 +6433,7 @@ void issue_probersp(struct rtw_adapter *
 		// DS parameter set
 		pframe =rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pattrib->pktlen);
 
-		if ( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+		if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
 		{
 			u8 erpinfo=0;
 			u32 ATIMWindow;
@@ -6552,7 +6511,6 @@ void issue_probersp(struct rtw_adapter *
 	dump_mgntframe(padapter, pmgntframe);
 
 	return;
-
 }
 
 int _issue_probereq(struct rtw_adapter *padapter, struct ndis_802_11_ssid *pssid, u8 *da, int wait_ack)
@@ -7144,7 +7102,7 @@ void issue_assocreq(struct rtw_adapter *
 		// Check if the AP's supported rates are also supported by STA.
 		for (j=0; j < sta_bssrate_len; j++) {
 			 // Avoid the proprietary data rate (22Mbps) of Handlink WSG-4000 AP
-			if ( (pmlmeinfo->network.SupportedRates[i]|IEEE80211_BASIC_RATE_MASK)
+			if ((pmlmeinfo->network.SupportedRates[i]|IEEE80211_BASIC_RATE_MASK)
 					== (sta_bssrate[j]|IEEE80211_BASIC_RATE_MASK)) {
 				//DBG_8192D("match i = %d, j=%d\n", i, j);
 				break;
@@ -7202,7 +7160,7 @@ void issue_assocreq(struct rtw_adapter *
 
 		//supported channels
 		do{
-			if ( pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14 )
+			if (pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14)
 			{
 				sup_ch[0] = 1;	//First channel number
 				sup_ch[1] = pmlmeext->channel_set[sup_ch_idx].ChannelNum;	//Number of channel
@@ -7214,7 +7172,7 @@ void issue_assocreq(struct rtw_adapter *
 			}
 			sup_ch_idx++;
 		}
-		while ( pmlmeext->channel_set[sup_ch_idx].ChannelNum != 0 );
+		while (pmlmeext->channel_set[sup_ch_idx].ChannelNum != 0);
 		pframe = rtw_set_ie(pframe, _SUPPORTED_CH_IE_, idx_5g, sup_ch, &(pattrib->pktlen));
 	}
 #endif //CONFIG_DFS
@@ -7236,13 +7194,13 @@ void issue_assocreq(struct rtw_adapter *
 			memcpy(&(pmlmeinfo->HT_caps), (p + 2), sizeof(struct HT_caps_element));
 
 			//to disable 40M Hz support while gd_bw_40MHz_en = 0
-			if ( pmlmeext->cur_channel > 14)
+			if (pmlmeext->cur_channel > 14)
 			{
-				if (pregpriv->cbw40_enable & BIT(1) )
+				if (pregpriv->cbw40_enable & BIT(1))
 					cbw40_enable=1;
 			}
 			else
-				if (pregpriv->cbw40_enable & BIT(0) )
+				if (pregpriv->cbw40_enable & BIT(0))
 					cbw40_enable=1;
 
 			if (cbw40_enable == 0)
@@ -7391,7 +7349,7 @@ void issue_assocreq(struct rtw_adapter *
 			p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
 			//	Length:
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 			p2pielen += 2;
 
 			//	Value:
@@ -7399,7 +7357,7 @@ void issue_assocreq(struct rtw_adapter *
 			p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 
 			//	Group Capability Bitmap, 1 byte
-			if ( pwdinfo->persistent_supported )
+			if (pwdinfo->persistent_supported)
 				p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
 			else
 				p2pie[ p2pielen++ ] = DMP_P2P_GRPCAP_SUPPORT;
@@ -7409,16 +7367,16 @@ void issue_assocreq(struct rtw_adapter *
 			p2pie[ p2pielen++ ] = P2P_ATTR_EX_LISTEN_TIMING;
 
 			//	Length:
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0004 );
+			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0004);
 			p2pielen += 2;
 
 			//	Value:
 			//	Availability Period
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0xFFFF );
+			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 			p2pielen += 2;
 
 			//	Availability Interval
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0xFFFF );
+			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 			p2pielen += 2;
 
 			//	Device Info
@@ -7428,39 +7386,39 @@ void issue_assocreq(struct rtw_adapter *
 			//	Length:
 			//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
 			//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
+			*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
 			p2pielen += 2;
 
 			//	Value:
 			//	P2P Device Address
-			memcpy( p2pie + p2pielen, myid( &padapter->eeprompriv ), ETH_ALEN );
+			memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 			p2pielen += ETH_ALEN;
 
 			//	Config Method
 			//	This field should be big endian. Noted by P2P specification.
-			if ( ( pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN ) ||
-				( pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_SELF_DISPLAY_PIN ) )
+			if ((pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN) ||
+				(pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_SELF_DISPLAY_PIN))
 			{
-				*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_CONFIG_METHOD_DISPLAY );
+				*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY);
 			}
 			else
 			{
-				*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_CONFIG_METHOD_PBC );
+				*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_PBC);
 			}
 
 			p2pielen += 2;
 
 			//	Primary Device Type
 			//	Category ID
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA );
+			*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 			p2pielen += 2;
 
 			//	OUI
-			*(u32*) ( p2pie + p2pielen ) = cpu_to_be32( WPSOUI );
+			*(u32*) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 			p2pielen += 4;
 
 			//	Sub Category ID
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_SCID_MEDIA_SERVER );
+			*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 			p2pielen += 2;
 
 			//	Number of Secondary Device Types
@@ -7468,15 +7426,15 @@ void issue_assocreq(struct rtw_adapter *
 
 			//	Device Name
 			//	Type:
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+			*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 			p2pielen += 2;
 
 			//	Length:
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( pwdinfo->device_name_len );
+			*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 			p2pielen += 2;
 
 			//	Value:
-			memcpy( p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len );
+			memcpy(p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len);
 			p2pielen += pwdinfo->device_name_len;
 
 			//	P2P Interface
@@ -7484,19 +7442,19 @@ void issue_assocreq(struct rtw_adapter *
 			p2pie[ p2pielen++ ] = P2P_ATTR_INTERFACE;
 
 			//	Length:
-			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x000D );
+			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x000D);
 			p2pielen += 2;
 
 			//	Value:
-			memcpy( p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN );	//	P2P Device Address
+			memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);	//	P2P Device Address
 			p2pielen += ETH_ALEN;
 
 			p2pie[ p2pielen++ ] = 1;	//	P2P Interface Address Count
 
-			memcpy( p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN );	//	P2P Interface Address List
+			memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);	//	P2P Interface Address List
 			p2pielen += ETH_ALEN;
 
-			pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
+			pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen);
 
 #ifdef CONFIG_WFD
 			//wfdielen = build_assoc_req_wfd_ie(pwdinfo, pframe);
@@ -7510,7 +7468,7 @@ void issue_assocreq(struct rtw_adapter *
 
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
-	if ( true == pwdinfo->wfd_info->wfd_enable )
+	if (true == pwdinfo->wfd_info->wfd_enable)
 #endif //CONFIG_IOCTL_CFG80211
 	{
 		wfdielen = build_assoc_req_wfd_ie(pwdinfo, pframe);
@@ -7823,10 +7781,10 @@ static int _issue_deauth(struct rtw_adap
 #endif //CONFIG_P2P
 
 #ifdef CONFIG_P2P
-	if ( !( rtw_p2p_chk_state( pwdinfo, P2P_STATE_NONE ) ) && ( pwdinfo->rx_invitereq_info.scan_op_ch_only ) )
+	if (!(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) && (pwdinfo->rx_invitereq_info.scan_op_ch_only))
 	{
-		_cancel_timer_ex( &pwdinfo->reset_ch_sitesurvey );
-		_set_timer( &pwdinfo->reset_ch_sitesurvey, 10 );
+		_cancel_timer_ex(&pwdinfo->reset_ch_sitesurvey);
+		_set_timer(&pwdinfo->reset_ch_sitesurvey, 10);
 	}
 #endif //CONFIG_P2P
 
@@ -7987,7 +7945,6 @@ void issue_action_spct_ch_switch (struct
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(padapter, pmgntframe);
-
 }
 
 void issue_action_BA(struct rtw_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short status)
@@ -8274,7 +8231,6 @@ static void issue_action_BSSCoexistPacke
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(padapter, pmgntframe);
-
 }
 
 unsigned int send_delba(struct rtw_adapter *padapter, u8 initiator, u8 *addr)
@@ -8321,7 +8277,7 @@ unsigned int send_delba(struct rtw_adapt
 			if (psta->htpriv.agg_enable_bitmap & BIT(tid))
 			{
 				DBG_8192D("tx agg disable tid(%d)\n",tid);
-				issue_action_BA(padapter, addr, RTW_WLAN_ACTION_DELBA, (((tid <<1) |initiator)&0x1F) );
+				issue_action_BA(padapter, addr, RTW_WLAN_ACTION_DELBA, (((tid <<1) |initiator)&0x1F));
 				psta->htpriv.agg_enable_bitmap &= ~BIT(tid);
 				psta->htpriv.candidate_tid_bitmap &= ~BIT(tid);
 
@@ -8330,7 +8286,6 @@ unsigned int send_delba(struct rtw_adapt
 	}
 
 	return _SUCCESS;
-
 }
 
 unsigned int send_beacon(struct rtw_adapter *padapter)
@@ -8377,7 +8332,6 @@ bool IsLegal5GChannel(
 	struct rtw_adapter * Adapter,
 	u8 channel)
 {
-
 	int i=0;
 	u8 Channel_5G[45] = {36,38,40,42,44,46,48,50,52,54,56,58,
 		60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,
@@ -8415,9 +8369,9 @@ void site_survey(struct rtw_adapter *pad
 	static unsigned int p2p_scan_count = 0;
 
 
-	if ( ( pwdinfo->rx_invitereq_info.scan_op_ch_only ) || ( pwdinfo->p2p_info.scan_op_ch_only ) )
+	if ((pwdinfo->rx_invitereq_info.scan_op_ch_only) || (pwdinfo->p2p_info.scan_op_ch_only))
 	{
-		if ( pwdinfo->rx_invitereq_info.scan_op_ch_only )
+		if (pwdinfo->rx_invitereq_info.scan_op_ch_only)
 		{
 			survey_channel = pwdinfo->rx_invitereq_info.operation_ch[pmlmeext->sitesurvey_res.channel_idx];
 		}
@@ -8470,7 +8424,7 @@ void site_survey(struct rtw_adapter *pad
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 		if ((padapter->pbuddy_adapter->mlmeextpriv.mlmext_info.state&0x03) == WIFI_FW_AP_STATE)
 		{
-			if ( pmlmeinfo->scan_cnt == RTW_SCAN_NUM_OF_CH )
+			if (pmlmeinfo->scan_cnt == RTW_SCAN_NUM_OF_CH)
 			{
 				pmlmeinfo->scan_cnt = 0;
 				survey_channel = pbuddy_mlmeext->cur_channel;
@@ -8479,7 +8433,7 @@ void site_survey(struct rtw_adapter *pad
 			}
 			else
 			{
-				if ( pmlmeinfo->scan_cnt == 0 )
+				if (pmlmeinfo->scan_cnt == 0)
 					stay_buddy_ch = 2;
 				pmlmeinfo->scan_cnt++;
 			}
@@ -8496,7 +8450,7 @@ void site_survey(struct rtw_adapter *pad
 		}
 
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-		if ( stay_buddy_ch == 1 )
+		if (stay_buddy_ch == 1)
 		{
 			val8 = 0; //survey done
 			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
@@ -8507,7 +8461,7 @@ void site_survey(struct rtw_adapter *pad
 				update_beacon(padapter->pbuddy_adapter, 0, NULL, true);
 			}
 		}
-		else if ( stay_buddy_ch == 2 )
+		else if (stay_buddy_ch == 2)
 		{
 			val8 = 1; //under site survey
 			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
@@ -8550,8 +8504,8 @@ void site_survey(struct rtw_adapter *pad
 		}
 
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-		if ( stay_buddy_ch == 1 )
-			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time * RTW_STAY_AP_CH_MILLISECOND );
+		if (stay_buddy_ch == 1)
+			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time * RTW_STAY_AP_CH_MILLISECOND);
 		else
 #endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time);
@@ -8559,7 +8513,6 @@ void site_survey(struct rtw_adapter *pad
 	}
 	else
 	{
-
 		//	channel number is 0 or this channel is not valid.
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -8592,14 +8545,14 @@ void site_survey(struct rtw_adapter *pad
 #ifdef CONFIG_P2P
 		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH))
 		{
-			if ( ( pwdinfo->rx_invitereq_info.scan_op_ch_only ) || ( pwdinfo->p2p_info.scan_op_ch_only ) )
+			if ((pwdinfo->rx_invitereq_info.scan_op_ch_only) || (pwdinfo->p2p_info.scan_op_ch_only))
 			{
 				//	Set the find_phase_state_exchange_cnt to P2P_FINDPHASE_EX_CNT.
 				//	This will let the following flow to run the scanning end.
 				rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_MAX);
 			}
 			#ifdef CONFIG_DBG_P2P
-			DBG_8192D( "[%s] find phase exchange cnt = %d\n", __func__, pwdinfo->find_phase_state_exchange_cnt );
+			DBG_8192D("[%s] find phase exchange cnt = %d\n", __func__, pwdinfo->find_phase_state_exchange_cnt);
 			#endif
 		}
 
@@ -8616,12 +8569,11 @@ void site_survey(struct rtw_adapter *pad
 			Restore_DM_Func_Flag(padapter);
 			//Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true);
 
-			_set_timer( &pwdinfo->find_phase_timer, ( u32 ) ( ( u32 ) ( pwdinfo->listen_dwell ) * 100 ) );
+			_set_timer(&pwdinfo->find_phase_timer, (u32) ((u32) (pwdinfo->listen_dwell) * 100));
 		}
 		else
 #endif //CONFIG_P2P
 		{
-
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 			pmlmeinfo->scan_cnt = 0;
 #endif //CONFIG_DMP_STA_NODE_SCAN_UNDER_AP_MODE
@@ -8645,9 +8597,9 @@ void site_survey(struct rtw_adapter *pad
 			{
 			#ifdef CONFIG_CONCURRENT_MODE
 				#ifndef CONFIG_IOCTL_CFG80211
-				if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+				if (check_buddy_fwstate(padapter, _FW_LINKED))
 				{
-					_set_timer( &pwdinfo->ap_p2p_switch_timer, 500 );
+					_set_timer(&pwdinfo->ap_p2p_switch_timer, 500);
 				}
 				#endif //CONFIG_IOCTL_CFG80211
 				rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
@@ -8668,7 +8620,7 @@ void site_survey(struct rtw_adapter *pad
 				dc_set_channel_bwmode_survey_done(padapter);
 #else
 #ifndef CONFIG_IOCTL_CFG80211
-				if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN) )
+				if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN))
 				{
 					set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 				}
@@ -8733,7 +8685,6 @@ void site_survey(struct rtw_adapter *pad
 		if (check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&
 			check_buddy_fwstate(padapter, _FW_LINKED))
 		{
-
 			DBG_8192D("survey done, current CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
 
 			DBG_8192D("restart pbuddy_adapter's beacon\n");
@@ -8745,7 +8696,6 @@ void site_survey(struct rtw_adapter *pad
 	}
 
 	return;
-
 }
 
 //collect bss info from Beacon and Probe response frames.
@@ -9004,7 +8954,6 @@ void start_create_ibss(struct rtw_adapte
 		DBG_8192D("start_create_ibss, invalid cap:%x\n", caps);
 		return;
 	}
-
 }
 
 void start_clnt_join(struct rtw_adapter* padapter)
@@ -9086,7 +9035,6 @@ void start_clnt_join(struct rtw_adapter*
 		//DBG_8192D("marc: invalid cap:%x\n", caps);
 		return;
 	}
-
 }
 
 void start_clnt_auth(struct rtw_adapter* padapter)
@@ -9116,7 +9064,6 @@ void start_clnt_auth(struct rtw_adapter*
 	issue_auth(padapter, NULL, 0);
 
 	set_link_timer(pmlmeext, REAUTH_TO);
-
 }
 
 
@@ -9499,7 +9446,6 @@ void report_survey_event(struct rtw_adap
 	pmlmeext->sitesurvey_res.bss_cnt++;
 
 	return;
-
 }
 
 void report_surveydone_event(struct rtw_adapter *padapter)
@@ -9545,7 +9491,6 @@ void report_surveydone_event(struct rtw_
 	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
 
 	return;
-
 }
 
 void report_join_res(struct rtw_adapter *padapter, int res)
@@ -9597,7 +9542,6 @@ void report_join_res(struct rtw_adapter
 	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
 
 	return;
-
 }
 
 void report_del_sta_event(struct rtw_adapter *padapter, unsigned char* MacAddr, unsigned short reason)
@@ -9761,7 +9705,6 @@ void update_sta_info(struct rtw_adapter
 
 
 	psta->state = _FW_LINKED;
-
 }
 
 void mlmeext_joinbss_event_callback(struct rtw_adapter *padapter, int join_res)
@@ -9857,7 +9800,6 @@ exit_mlmeext_joinbss_event_callback:
 #endif
 
 	DBG_8192D("=>%s\n", __func__);
-
 }
 
 void mlmeext_sta_add_event_callback(struct rtw_adapter *padapter, struct sta_info *psta)
@@ -9907,7 +9849,6 @@ void mlmeext_sta_add_event_callback(stru
 
 	//update adhoc sta_info
 	update_sta_info(padapter, psta);
-
 }
 
 void mlmeext_sta_del_event_callback(struct rtw_adapter *padapter)
@@ -9955,7 +9896,6 @@ void mlmeext_sta_del_event_callback(stru
 		_cancel_timer_ex(&pmlmeext->link_timer);
 
 	}
-
 }
 
 /****************************************************************************
@@ -9994,10 +9934,10 @@ void _linked_rx_signal_strehgth_display(
 	DBG_8192D("Rx RSSI:%d\n",padapter->recvpriv.rssi);
 	DBG_8192D("Rx Signal_strength:%d\n",padapter->recvpriv.signal_strength);
 	DBG_8192D("Rx Signal_qual:%d\n",padapter->recvpriv.signal_qual);
-	if ( check_fwstate( &padapter->mlmepriv,  _FW_LINKED ))
+	if (check_fwstate(&padapter->mlmepriv,  _FW_LINKED))
 	{
-		DBG_8192D("bw mode: %d, channel: %d\n", padapter->mlmeextpriv.cur_bwmode, padapter->mlmeextpriv.cur_channel );
-		DBG_8192D("received bytes = %d\n", (u32) (padapter->recvpriv.rx_bytes - padapter->recvpriv.last_rx_bytes ) );
+		DBG_8192D("bw mode: %d, channel: %d\n", padapter->mlmeextpriv.cur_bwmode, padapter->mlmeextpriv.cur_channel);
+		DBG_8192D("received bytes = %d\n", (u32) (padapter->recvpriv.rx_bytes - padapter->recvpriv.last_rx_bytes));
 	}
 	DBG_8192D("============ linked status check ===================\n");
 	DBG_8192D(" DIG PATH-A(0x%02x), PATH-B(0x%02x)\n",rtw_read8(padapter,0xc50),rtw_read8(padapter,0xc58));
@@ -10006,7 +9946,6 @@ void _linked_rx_signal_strehgth_display(
 
 	DBG_8192D(" CCK -Alarm A5B(0x%02x),A5C(0x%02x)\n",rtw_read8(padapter,0xA5B),rtw_read8(padapter,0xA5C));
 	DBG_8192D(" FalseAlmCnt_all(%d)\n",padapter->recvpriv.falsealmcnt_all);
-
 }
 
 u8 chk_ap_is_alive(struct rtw_adapter *padapter, struct sta_info *psta)
@@ -10185,7 +10124,6 @@ void linked_status_chk(struct rtw_adapte
 
 				if (pmlmeinfo->FW_sta_info[i].rx_pkt == sta_rx_pkts(psta))
 				{
-
 					if (pmlmeinfo->FW_sta_info[i].retry<3)
 					{
 						pmlmeinfo->FW_sta_info[i].retry++;
@@ -10210,7 +10148,6 @@ void linked_status_chk(struct rtw_adapte
 		//set_link_timer(pmlmeext, DISCONNECT_TO);
 
 	}
-
 }
 
 void survey_timer_hdl(struct rtw_adapter *padapter)
@@ -10229,7 +10166,7 @@ void survey_timer_hdl(struct rtw_adapter
 		if (pmlmeext->sitesurvey_res.state ==  SCAN_PROCESS)
 		{
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-			if ( padapter->mlmeextpriv.mlmext_info.scan_cnt != RTW_SCAN_NUM_OF_CH )
+			if (padapter->mlmeextpriv.mlmext_info.scan_cnt != RTW_SCAN_NUM_OF_CH)
 #endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 				pmlmeext->sitesurvey_res.channel_idx++;
 		}
@@ -10373,7 +10310,6 @@ u8 setopmode_hdl(struct rtw_adapter *pad
 	//Set_NETYPE0_MSR(padapter, type);
 
 	return H2C_SUCCESS;
-
 }
 
 u8 createbss_hdl(struct rtw_adapter *padapter, u8 *pbuf)
@@ -10439,7 +10375,6 @@ u8 createbss_hdl(struct rtw_adapter *pad
 	}
 
 	return H2C_SUCCESS;
-
 }
 
 u8 join_cmd_hdl(struct rtw_adapter *padapter, u8 *pbuf)
@@ -10516,7 +10451,7 @@ u8 join_cmd_hdl(struct rtw_adapter *pada
 		switch (pIE->ElementID)
 		{
 			case _VENDOR_SPECIFIC_IE_://Get WMM IE.
-				if ( _rtw_memcmp(pIE->data, WMM_OUI, 4) )
+				if (_rtw_memcmp(pIE->data, WMM_OUI, 4))
 				{
 					pmlmeinfo->WMM_enable = 1;
 				}
@@ -10536,13 +10471,13 @@ u8 join_cmd_hdl(struct rtw_adapter *pada
 				{
 					struct HT_info_element *pht_info = (struct HT_info_element *)(pIE->data);
 
-					if ( pnetwork->Configuration.DSConfig > 14 )
+					if (pnetwork->Configuration.DSConfig > 14)
 					{
-						if ( pregpriv->cbw40_enable & BIT(1) )
+						if (pregpriv->cbw40_enable & BIT(1))
 							cbw40_enable = 1;
 					}
 					else
-						if ( pregpriv->cbw40_enable & BIT(0) )
+						if (pregpriv->cbw40_enable & BIT(0))
 							cbw40_enable = 1;
 
 					if ((cbw40_enable) &&	 (pht_info->infos[0] & BIT(2)))
@@ -10593,7 +10528,6 @@ u8 join_cmd_hdl(struct rtw_adapter *pada
 	start_clnt_join(padapter);
 
 	return H2C_SUCCESS;
-
 }
 
 u8 disconnect_hdl(struct rtw_adapter *padapter, unsigned char *pbuf)
@@ -10824,7 +10758,7 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 			initialgain = 0x17;
 #else	//	go through the WEXT interface //CONFIG_IOCTL_CFG80211
 #ifdef CONFIG_P2P
-		if ( rtw_p2p_chk_state( pwdinfo, P2P_STATE_NONE ) )
+		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 			initialgain = 0x17;
 		else
 			initialgain = 0x28;
@@ -10847,7 +10781,6 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 	site_survey(padapter);
 
 	return H2C_SUCCESS;
-
 }
 
 u8 setauth_hdl(struct rtw_adapter *padapter, unsigned char *pbuf)
@@ -10947,7 +10880,6 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 
 	if ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
-
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &padapter->stapriv;
 
@@ -11008,7 +10940,7 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 	}
 
 	psta = rtw_get_stainfo(pstapriv, pparm->addr);//Get TDLS Peer STA
-	if ( psta->tdls_sta_state&TDLS_LINKED_STATE ){
+	if (psta->tdls_sta_state&TDLS_LINKED_STATE){
 		write_cam(padapter, psta->mac_id, ctrl, pparm->addr, pparm->key);
 	}
 	else
@@ -11045,7 +10977,7 @@ u8 add_ba_hdl(struct rtw_adapter *padapt
 #ifdef CONFIG_TDLS
 	else if ((psta->tdls_sta_state & TDLS_LINKED_STATE)&&
 		(psta->htpriv.ht_option==true) &&
-		(psta->htpriv.ampdu_enable==true) )
+		(psta->htpriv.ampdu_enable==true))
 	{
 		issue_action_BA(padapter, pparm->addr, RTW_WLAN_ACTION_ADDBA_REQ, (u16)pparm->tid);
 		//_set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO);
@@ -11123,7 +11055,7 @@ u8 mlme_evt_hdl(struct rtw_adapter *pada
 
 	#ifdef CHECK_EVENT_SEQ
 	// checking event sequence...
-	if (evt_seq != (ATOMIC_READ(&pevt_priv->event_seq) & 0x7f) )
+	if (evt_seq != (ATOMIC_READ(&pevt_priv->event_seq) & 0x7f))
 	{
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("Evetn Seq Error! %d vs %d\n", (evt_seq & 0x7f), (ATOMIC_READ(&pevt_priv->event_seq) & 0x7f)));
 
@@ -11144,7 +11076,6 @@ u8 mlme_evt_hdl(struct rtw_adapter *pada
 	if ((wlanevents[evt_code].parmsize != 0) &&
 			(wlanevents[evt_code].parmsize != evt_sz))
 	{
-
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nEvent(%d) Parm Size mismatch (%d vs %d)!\n",
 			evt_code, wlanevents[evt_code].parmsize, evt_sz));
 		goto _abort_event_;
@@ -11168,7 +11099,6 @@ _abort_event_:
 
 
 	return H2C_SUCCESS;
-
 }
 
 u8 h2c_msg_hdl(struct rtw_adapter *padapter, unsigned char *pbuf)
@@ -11243,7 +11173,6 @@ u8 tx_beacon_hdl(struct rtw_adapter *pad
 #endif
 
 	return H2C_SUCCESS;
-
 }
 
 void change_band_update_ie(struct rtw_adapter *padapter, struct wlan_bssid_ex *pnetwork)
@@ -11304,7 +11233,7 @@ void dc_SelectChannel(struct rtw_adapter
 {
 	struct rtw_adapter * ptarget_adapter;
 
-	if ( (padapter->pbuddy_adapter != NULL) &&
+	if ((padapter->pbuddy_adapter != NULL) &&
 		(padapter->DualMacConcurrent == true) &&
 		(padapter->adapter_type == SECONDARY_ADAPTER))
 	{
@@ -11327,7 +11256,7 @@ void dc_SetBWMode(struct rtw_adapter *pa
 {
 	struct rtw_adapter * ptarget_adapter;
 
-	if ( (padapter->pbuddy_adapter != NULL) &&
+	if ((padapter->pbuddy_adapter != NULL) &&
 		(padapter->DualMacConcurrent == true) &&
 		(padapter->adapter_type == SECONDARY_ADAPTER))
 	{
@@ -11409,7 +11338,7 @@ u8 dc_handle_join_request(struct rtw_ada
 				{
 					// HT_CHANNEL_WIDTH_40 or HT_CHANNEL_WIDTH_20 but channel offset is different
 					if ((pmlmeext->cur_bwmode == pbuddy_mlmeext->cur_bwmode) &&
-						(pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset) )
+						(pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset))
 					{
 						report_join_res(padapter, -4);
 						ret = _FAIL;
@@ -11475,7 +11404,7 @@ void dc_handle_join_done(struct rtw_adap
 				if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 				{
 					p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(struct ndis_802_11_fixed_ies)), _HT_ADD_INFO_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-					if ( p && ie_len)
+					if (p && ie_len)
 					{
 						pht_info = (struct HT_info_element *)(p+2);
 						pht_info->infos[0] &= ~(BIT(0)|BIT(1)); //no secondary channel is present
@@ -11486,7 +11415,7 @@ void dc_handle_join_done(struct rtw_adap
 						pbuddy_mlmeext->cur_ch_offset = pmlmeext->cur_ch_offset;
 
 						//to update cur_ch_offset value in beacon
-						if ( pht_info )
+						if (pht_info)
 						{
 							switch (pmlmeext->cur_ch_offset)
 							{
@@ -11536,7 +11465,7 @@ void dc_handle_join_done(struct rtw_adap
 					*(p + 2) = pmlmeext->cur_channel;
 
 				p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(struct ndis_802_11_fixed_ies)), _HT_ADD_INFO_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-				if ( p && ie_len)
+				if (p && ie_len)
 				{
 					pht_info = (struct HT_info_element *)(p+2);
 					pht_info->primary_channel = pmlmeext->cur_channel;
@@ -11641,24 +11570,18 @@ void dc_set_channel_bwmode_survey_done(s
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 		pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
 
-		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
-		{
+		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) {
 			if (check_fwstate(pmlmepriv, _FW_LINKED) &&
-				(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40))
-			{
+			    (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)) {
 				cur_channel = pmlmeext->cur_channel;
 				cur_bwmode = pmlmeext->cur_bwmode;
 				cur_ch_offset = pmlmeext->cur_ch_offset;
-			}
-			else
-			{
+			} else {
 				cur_channel = pbuddy_mlmeext->cur_channel;
 				cur_bwmode = pbuddy_mlmeext->cur_bwmode;
 				cur_ch_offset = pbuddy_mlmeext->cur_ch_offset;
 			}
-		}
-		else
-		{
+		} else {
 			cur_channel = pmlmeext->cur_channel;
 			cur_bwmode = pmlmeext->cur_bwmode;
 			cur_ch_offset = pmlmeext->cur_ch_offset;
@@ -11666,25 +11589,20 @@ void dc_set_channel_bwmode_survey_done(s
 
 		set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
 
-		if (is_client_associated_to_ap(pbuddy_adapter) == true)
-		{
+		if (is_client_associated_to_ap(pbuddy_adapter) == true) {
 			//issue null data
 			issue_nulldata(pbuddy_adapter, NULL, 0, 0, 0);
 		}
 
 		if (((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
-			check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
-		{
-
+		     check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) {
 			DBG_8192D("survey done, current CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
 
 			DBG_8192D("restart pbuddy_adapter's beacon\n");
 
 			update_beacon(pbuddy_adapter, 0, NULL, true);
 		}
-	}
-	else
-	{
+	} else {
 		set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 	}
 }
@@ -11712,7 +11630,7 @@ void dc_set_ap_channel_bandwidth(struct
 	change_band = false;
 
 	p = rtw_get_ie((pnetwork->IEs + sizeof(struct ndis_802_11_fixed_ies)), _HT_ADD_INFO_IE_, &ie_len, (pnetwork->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-	if ( p && ie_len)
+	if (p && ie_len)
 	{
 		pht_info = (struct HT_info_element *)(p+2);
 	}
@@ -11876,7 +11794,6 @@ int check_buddy_mlmeinfo_state(struct rt
 		return true;
 
 	return false;
-
 }
 
 int concurrent_chk_start_clnt_join(struct rtw_adapter *padapter)
@@ -11961,7 +11878,6 @@ int concurrent_chk_start_clnt_join(struc
 	}
 
 	return _SUCCESS;
-
 }
 
 void concurrent_chk_joinbss_done(struct rtw_adapter *padapter, int join_res)
@@ -12010,7 +11926,7 @@ void concurrent_chk_joinbss_done(struct
 			if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 			{
 				p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(struct ndis_802_11_fixed_ies)), _HT_ADD_INFO_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-				if ( p && ie_len)
+				if (p && ie_len)
 				{
 					pht_info = (struct HT_info_element *)(p+2);
 					pht_info->infos[0] &= ~(BIT(0)|BIT(1)); //no secondary channel is present
@@ -12021,7 +11937,7 @@ void concurrent_chk_joinbss_done(struct
 					pbuddy_mlmeext->cur_ch_offset = pmlmeext->cur_ch_offset;
 
 					//to update cur_ch_offset value in beacon
-					if ( pht_info )
+					if (pht_info)
 					{
 						switch (pmlmeext->cur_ch_offset)
 						{
@@ -12122,7 +12038,7 @@ void concurrent_chk_joinbss_done(struct
 				*(p + 2) = pmlmeext->cur_channel;
 
 			p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(struct ndis_802_11_fixed_ies)), _HT_ADD_INFO_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(struct ndis_802_11_fixed_ies)));
-			if ( p && ie_len)
+			if (p && ie_len)
 			{
 				pht_info = (struct HT_info_element *)(p+2);
 				pht_info->primary_channel = pmlmeext->cur_channel;
@@ -12164,7 +12080,6 @@ void concurrent_chk_joinbss_done(struct
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 		}
 	}
-
 }
 #endif //CONFIG_CONCURRENT_MODE
 
@@ -12254,7 +12169,7 @@ u8 set_csa_hdl(struct rtw_adapter *padap
 	rtw_free_network_queue(padapter, true);
 	rtw_indicate_disconnect(padapter);
 
-	if ( ((new_ch_no >= 52) && (new_ch_no <= 64)) ||((new_ch_no >= 100) && (new_ch_no <= 140)) ) {
+	if (((new_ch_no >= 52) && (new_ch_no <= 64)) ||((new_ch_no >= 100) && (new_ch_no <= 140))) {
 		DBG_8192D("Switched to DFS band (ch %02x) again!!\n", new_ch_no);
 	}
 
@@ -12262,7 +12177,6 @@ u8 set_csa_hdl(struct rtw_adapter *padap
 #else
 	return	H2C_REJECTED;
 #endif //CONFIG_DFS
-
 }
 
 // TDLS_WRCR		: write RCR DATA BIT
@@ -12293,12 +12207,12 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 
 	TDLSoption = (struct TDLSoption_param *)pbuf;
 
-	ptdls_sta = rtw_get_stainfo( &(padapter->stapriv), TDLSoption->addr );
+	ptdls_sta = rtw_get_stainfo(&(padapter->stapriv), TDLSoption->addr);
 	option = TDLSoption->option;
 
-	if ( ptdls_sta == NULL )
+	if (ptdls_sta == NULL)
 	{
-		if ( option != TDLS_RS_RCR )
+		if (option != TDLS_RS_RCR)
 			return H2C_REJECTED;
 	}
 
@@ -12437,5 +12351,4 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 #else
 	return H2C_REJECTED;
 #endif //CONFIG_TDLS
-
 }
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -25,22 +25,22 @@
 
 #ifdef CONFIG_P2P
 
-int rtw_p2p_is_channel_list_ok( u8 desired_ch, u8* ch_list, u8 ch_cnt )
+int rtw_p2p_is_channel_list_ok(u8 desired_ch, u8* ch_list, u8 ch_cnt)
 {
 	int found = 0, i = 0;
 
-	for ( i = 0; i < ch_cnt; i++ )
+	for (i = 0; i < ch_cnt; i++)
 	{
-		if ( ch_list[ i ] == desired_ch )
+		if (ch_list[ i ] == desired_ch)
 		{
 			found = 1;
 			break;
 		}
 	}
-	return( found );
+	return(found);
 }
 
-int	is_any_client_associated(struct rtw_adapter *padapter )
+int	is_any_client_associated(struct rtw_adapter *padapter)
 {
 	struct list_head *phead, *plist;
 	int	intFound = false;
@@ -51,7 +51,7 @@ int	is_any_client_associated(struct rtw_
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
-	if ( rtw_end_of_queue_search(phead, plist) == true )
+	if (rtw_end_of_queue_search(phead, plist) == true)
 	{
 		intFound = false;
 	}
@@ -68,8 +68,7 @@ int	is_any_client_associated(struct rtw_
 
 	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
-	return( intFound );
-
+	return(intFound);
 }
 
 static u32 go_add_group_info_attr(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -133,11 +132,11 @@ static u32 go_add_group_info_attr(struct
 
 			if (psta->dev_name_len>0)
 			{
-				//*(u16*)(pcur) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+				//*(u16*)(pcur) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 				RTW_PUT_BE16(pcur, WPS_ATTR_DEVICE_NAME);
 				pcur += 2;
 
-				//*(u16*)(pcur) = cpu_to_be16( psta->dev_name_len );
+				//*(u16*)(pcur) = cpu_to_be16(psta->dev_name_len);
 				RTW_PUT_BE16(pcur, psta->dev_name_len);
 				pcur += 2;
 
@@ -169,7 +168,6 @@ static u32 go_add_group_info_attr(struct
 	kfree(pdata_attr);
 
 	return len;
-
 }
 
 static void issue_group_disc_req(struct wifidirect_info *pwdinfo, u8 *da)
@@ -228,7 +226,6 @@ static void issue_group_disc_req(struct
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(padapter, pmgntframe);
-
 }
 
 static void issue_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *da, u8 status, u8 dialogToken)
@@ -302,7 +299,6 @@ static void issue_p2p_devdisc_resp(struc
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(padapter, pmgntframe);
-
 }
 
 static void issue_p2p_provision_resp(struct wifidirect_info *pwdinfo, u8* raddr, u8* frame_body, u16 config_method)
@@ -365,27 +361,27 @@ static void issue_p2p_provision_resp(str
 
 	wpsielen = 0;
 	//	WPS OUI
-	//*(u32*) ( wpsie ) = cpu_to_be32( WPSOUI );
+	//*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 	RTW_PUT_BE32(wpsie, WPSOUI);
 	wpsielen += 4;
 
 	//	Config Method
 	//	Type:
-	//*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_CONF_METHOD );
+	//*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
 	RTW_PUT_BE16(wpsie + wpsielen, WPS_ATTR_CONF_METHOD);
 	wpsielen += 2;
 
 	//	Length:
-	//*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0002 );
+	//*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 	RTW_PUT_BE16(wpsie + wpsielen, 0x0002);
 	wpsielen += 2;
 
 	//	Value:
-	//*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( config_method );
+	//*(u16*) (wpsie + wpsielen) = cpu_to_be16(config_method);
 	RTW_PUT_BE16(wpsie + wpsielen, config_method);
 	wpsielen += 2;
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen );
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
 
 #ifdef CONFIG_WFD
 	wfdielen = build_provdisc_resp_wfd_ie(pwdinfo, pframe);
@@ -398,7 +394,6 @@ static void issue_p2p_provision_resp(str
 	dump_mgntframe(padapter, pmgntframe);
 
 	return;
-
 }
 
 static void issue_p2p_presence_resp(struct wifidirect_info *pwdinfo, u8 *da, u8 status, u8 dialogToken)
@@ -482,7 +477,6 @@ static void issue_p2p_presence_resp(stru
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(padapter, pmgntframe);
-
 }
 
 u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -503,7 +497,7 @@ u32 build_beacon_p2p_ie(struct wifidirec
 	//	According to the P2P Specification, the beacon frame should contain 3 P2P attributes
 	//	1. P2P Capability
 	//	2. P2P Device ID
-	//	3. Notice of Absence ( NOA )
+	//	3. Notice of Absence (NOA)
 
 	//	P2P Capability ATTR
 	//	Type:
@@ -539,7 +533,6 @@ u32 build_beacon_p2p_ie(struct wifidirec
 
 
 	return len;
-
 }
 
 #ifdef CONFIG_WFD
@@ -577,24 +570,24 @@ u32 build_beacon_wfd_ie(struct wifidirec
 	//	Value1:
 	//	WFD device information
 
-	if ( P2P_ROLE_GO == pwdinfo->role )
+	if (P2P_ROLE_GO == pwdinfo->role)
 	{
-		if ( is_any_client_associated( pwdinfo->padapter ) )
+		if (is_any_client_associated(pwdinfo->padapter))
 		{
 			//	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery)
-			RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD );
+			RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD);
 		}
 		else
 		{
 			//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
-			RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD );
+			RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 		}
 
 	}
 	else
 	{
-		//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD ( WFD Service Discovery )
-		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD );
+		//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	}
 
 	wfdielen += 2;
@@ -602,7 +595,7 @@ u32 build_beacon_wfd_ie(struct wifidirec
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -622,13 +615,13 @@ u32 build_beacon_wfd_ie(struct wifidirec
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	wfdielen += ETH_ALEN;
@@ -657,7 +650,6 @@ u32 build_beacon_wfd_ie(struct wifidirec
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
 }
 
 u32 build_probe_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -694,20 +686,20 @@ u32 build_probe_req_wfd_ie(struct wifidi
 	//	Value1:
 	//	WFD device information
 
-	if ( 1 == pwdinfo->wfd_tdls_enable )
+	if (1 == pwdinfo->wfd_tdls_enable)
 	{
-		//	WFD primary sink + available for WFD session + WiFi TDLS mode + WSC ( WFD Service Discovery )
+		//	WFD primary sink + available for WFD session + WiFi TDLS mode + WSC (WFD Service Discovery)
 		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type |
 						WFD_DEVINFO_SESSION_AVAIL |
 						WFD_DEVINFO_WSD |
-						WFD_DEVINFO_PC_TDLS );
+						WFD_DEVINFO_PC_TDLS);
 	}
 	else
 	{
-		//	WFD primary sink + available for WFD session + WiFi Direct mode + WSC ( WFD Service Discovery )
+		//	WFD primary sink + available for WFD session + WiFi Direct mode + WSC (WFD Service Discovery)
 		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type |
 						WFD_DEVINFO_SESSION_AVAIL |
-						WFD_DEVINFO_WSD );
+						WFD_DEVINFO_WSD);
 	}
 
 	wfdielen += 2;
@@ -715,7 +707,7 @@ u32 build_probe_req_wfd_ie(struct wifidi
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -735,13 +727,13 @@ u32 build_probe_req_wfd_ie(struct wifidi
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	wfdielen += ETH_ALEN;
@@ -770,7 +762,6 @@ u32 build_probe_req_wfd_ie(struct wifidi
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
 }
 
 u32 build_probe_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 tunneled)
@@ -809,55 +800,54 @@ u32 build_probe_resp_wfd_ie(struct wifid
 	//	WFD device information
 	//	WFD primary sink + available for WFD session + WiFi Direct mode
 
-	if (  true == pwdinfo->session_available )
+	if ( true == pwdinfo->session_available)
 	{
-		if ( P2P_ROLE_GO == pwdinfo->role )
+		if (P2P_ROLE_GO == pwdinfo->role)
 		{
-			if ( is_any_client_associated( pwdinfo->padapter ) )
+			if (is_any_client_associated(pwdinfo->padapter))
 			{
-				if ( pwdinfo->wfd_tdls_enable )
+				if (pwdinfo->wfd_tdls_enable)
 				{
-					//	WFD primary sink + TDLS mode + WSD ( WFD Service Discovery )
+					//	WFD primary sink + TDLS mode + WSD (WFD Service Discovery)
 					RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_WSD | WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_HDCP_SUPPORT);
 				}
 				else
 				{
-					//	WFD primary sink + WiFi Direct mode + WSD ( WFD Service Discovery )
+					//	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery)
 					RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_WSD | WFD_DEVINFO_HDCP_SUPPORT);
 				}
 			}
 			else
 			{
-				if ( pwdinfo->wfd_tdls_enable )
+				if (pwdinfo->wfd_tdls_enable)
 				{
-					//	WFD primary sink + available for WFD session + TDLS mode + WSD ( WFD Service Discovery )
+					//	WFD primary sink + available for WFD session + TDLS mode + WSD (WFD Service Discovery)
 					RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_HDCP_SUPPORT);
 				}
 				else
 				{
-					//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD ( WFD Service Discovery )
+					//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
 					RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_HDCP_SUPPORT);
 				}
 			}
 		}
 		else
 		{
-			if ( pwdinfo->wfd_tdls_enable )
+			if (pwdinfo->wfd_tdls_enable)
 			{
-				//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD ( WFD Service Discovery )
+				//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
 				RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_HDCP_SUPPORT);
 			}
 			else
 			{
-
-				//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD ( WFD Service Discovery )
+				//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
 				RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_HDCP_SUPPORT);
 			}
 		}
 	}
 	else
 	{
-		if ( pwdinfo->wfd_tdls_enable )
+		if (pwdinfo->wfd_tdls_enable)
 		{
 			RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_WSD |WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_HDCP_SUPPORT);
 		}
@@ -873,7 +863,7 @@ u32 build_probe_resp_wfd_ie(struct wifid
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -893,13 +883,13 @@ u32 build_probe_resp_wfd_ie(struct wifid
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	wfdielen += ETH_ALEN;
@@ -925,7 +915,7 @@ u32 build_probe_resp_wfd_ie(struct wifid
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 
-	if ( P2P_ROLE_GO == pwdinfo->role )
+	if (P2P_ROLE_GO == pwdinfo->role)
 	{
 		//	WFD Session Information ATTR
 		//	Type:
@@ -941,7 +931,7 @@ u32 build_probe_resp_wfd_ie(struct wifid
 	}
 #ifdef CONFIG_CONCURRENT_MODE
 #ifdef CONFIG_TDLS
-	if ( ( tunneled == 0 ) && ( padapter->pbuddy_adapter->wdinfo.wfd_tdls_enable == 1 ) )
+	if ((tunneled == 0) && (padapter->pbuddy_adapter->wdinfo.wfd_tdls_enable == 1))
 	{
 		//	Alternative MAC Address ATTR
 		//	Type:
@@ -949,12 +939,12 @@ u32 build_probe_resp_wfd_ie(struct wifid
 
 		//	Length:
 		//	Note: In the WFD specification, the size of length field is 2.
-		RTW_PUT_BE16(wfdie + wfdielen,  ETH_ALEN );
+		RTW_PUT_BE16(wfdie + wfdielen,  ETH_ALEN);
 		wfdielen += 2;
 
 		//	Value:
 		//	Alternative MAC Address
-		memcpy( wfdie + wfdielen, &padapter->pbuddy_adapter->eeprompriv.mac_addr[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &padapter->pbuddy_adapter->eeprompriv.mac_addr[ 0 ], ETH_ALEN);
 		//	This mac address is used to make the WFD session when TDLS is enable.
 
 		wfdielen += ETH_ALEN;
@@ -965,7 +955,6 @@ u32 build_probe_resp_wfd_ie(struct wifid
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
 }
 
 u32 build_assoc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1010,14 +999,14 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 
 	//	Value1:
 	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD ( WFD Service Discovery )
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD );
+	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -1037,13 +1026,13 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	wfdielen += ETH_ALEN;
@@ -1072,7 +1061,6 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
 }
 
 u32 build_assoc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1108,14 +1096,14 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 
 	//	Value1:
 	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD ( WFD Service Discovery )
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD );
+	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -1135,13 +1123,13 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	wfdielen += ETH_ALEN;
@@ -1170,7 +1158,6 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
 }
 
 u32 build_nego_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1191,8 +1178,8 @@ u32 build_nego_req_wfd_ie(struct wifidir
 	//	Commented by Albert 20110825
 	//	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes
 	//	1. WFD Device Information
-	//	2. Associated BSSID ( Optional )
-	//	3. Local IP Adress ( Optional )
+	//	2. Associated BSSID (Optional)
+	//	3. Local IP Adress (Optional)
 
 
 	//	WFD Device Information ATTR
@@ -1206,14 +1193,14 @@ u32 build_nego_req_wfd_ie(struct wifidir
 
 	//	Value1:
 	//	WFD device information
-	//	WFD primary sink + WiFi Direct mode + WSD ( WFD Service Discovery ) + WFD Session Available
+	//	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) + WFD Session Available
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD | WFD_DEVINFO_SESSION_AVAIL);
 	wfdielen += 2;
 
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -1233,13 +1220,13 @@ u32 build_nego_req_wfd_ie(struct wifidir
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	wfdielen += ETH_ALEN;
@@ -1268,7 +1255,6 @@ u32 build_nego_req_wfd_ie(struct wifidir
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
 }
 
 u32 build_nego_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1289,8 +1275,8 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 	//	Commented by Albert 20110825
 	//	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes
 	//	1. WFD Device Information
-	//	2. Associated BSSID ( Optional )
-	//	3. Local IP Adress ( Optional )
+	//	2. Associated BSSID (Optional)
+	//	3. Local IP Adress (Optional)
 
 
 	//	WFD Device Information ATTR
@@ -1304,14 +1290,14 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 
 	//	Value1:
 	//	WFD device information
-	//	WFD primary sink + WiFi Direct mode + WSD ( WFD Service Discovery ) + WFD Session Available
+	//	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) + WFD Session Available
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD | WFD_DEVINFO_SESSION_AVAIL);
 	wfdielen += 2;
 
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -1331,13 +1317,13 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	wfdielen += ETH_ALEN;
@@ -1367,7 +1353,6 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
 }
 
 u32 build_nego_confirm_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1388,8 +1373,8 @@ u32 build_nego_confirm_wfd_ie(struct wif
 	//	Commented by Albert 20110825
 	//	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes
 	//	1. WFD Device Information
-	//	2. Associated BSSID ( Optional )
-	//	3. Local IP Adress ( Optional )
+	//	2. Associated BSSID (Optional)
+	//	3. Local IP Adress (Optional)
 
 
 	//	WFD Device Information ATTR
@@ -1403,14 +1388,14 @@ u32 build_nego_confirm_wfd_ie(struct wif
 
 	//	Value1:
 	//	WFD device information
-	//	WFD primary sink + WiFi Direct mode + WSD ( WFD Service Discovery ) + WFD Session Available
+	//	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) + WFD Session Available
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD | WFD_DEVINFO_SESSION_AVAIL);
 	wfdielen += 2;
 
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -1430,13 +1415,13 @@ u32 build_nego_confirm_wfd_ie(struct wif
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	wfdielen += ETH_ALEN;
@@ -1466,7 +1451,6 @@ u32 build_nego_confirm_wfd_ie(struct wif
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
 }
 
 u32 build_invitation_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1487,8 +1471,8 @@ u32 build_invitation_req_wfd_ie(struct w
 	//	Commented by Albert 20110825
 	//	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes
 	//	1. WFD Device Information
-	//	2. Associated BSSID ( Optional )
-	//	3. Local IP Adress ( Optional )
+	//	2. Associated BSSID (Optional)
+	//	3. Local IP Adress (Optional)
 
 
 	//	WFD Device Information ATTR
@@ -1502,14 +1486,14 @@ u32 build_invitation_req_wfd_ie(struct w
 
 	//	Value1:
 	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD ( WFD Service Discovery )
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD );
+	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -1529,13 +1513,13 @@ u32 build_invitation_req_wfd_ie(struct w
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	wfdielen += ETH_ALEN;
@@ -1561,7 +1545,7 @@ u32 build_invitation_req_wfd_ie(struct w
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 
-	if ( P2P_ROLE_GO == pwdinfo->role )
+	if (P2P_ROLE_GO == pwdinfo->role)
 	{
 		//	WFD Session Information ATTR
 		//	Type:
@@ -1579,7 +1563,6 @@ u32 build_invitation_req_wfd_ie(struct w
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
 }
 
 u32 build_invitation_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1600,8 +1583,8 @@ u32 build_invitation_resp_wfd_ie(struct
 	//	Commented by Albert 20110825
 	//	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes
 	//	1. WFD Device Information
-	//	2. Associated BSSID ( Optional )
-	//	3. Local IP Adress ( Optional )
+	//	2. Associated BSSID (Optional)
+	//	3. Local IP Adress (Optional)
 
 
 	//	WFD Device Information ATTR
@@ -1615,14 +1598,14 @@ u32 build_invitation_resp_wfd_ie(struct
 
 	//	Value1:
 	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD ( WFD Service Discovery )
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD );
+	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -1642,13 +1625,13 @@ u32 build_invitation_resp_wfd_ie(struct
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	wfdielen += ETH_ALEN;
@@ -1674,7 +1657,7 @@ u32 build_invitation_resp_wfd_ie(struct
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 
-	if ( P2P_ROLE_GO == pwdinfo->role )
+	if (P2P_ROLE_GO == pwdinfo->role)
 	{
 		//	WFD Session Information ATTR
 		//	Type:
@@ -1692,7 +1675,6 @@ u32 build_invitation_resp_wfd_ie(struct
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
 }
 
 u32 build_provdisc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1713,8 +1695,8 @@ u32 build_provdisc_req_wfd_ie(struct wif
 	//	Commented by Albert 20110825
 	//	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes
 	//	1. WFD Device Information
-	//	2. Associated BSSID ( Optional )
-	//	3. Local IP Adress ( Optional )
+	//	2. Associated BSSID (Optional)
+	//	3. Local IP Adress (Optional)
 
 
 	//	WFD Device Information ATTR
@@ -1728,14 +1710,14 @@ u32 build_provdisc_req_wfd_ie(struct wif
 
 	//	Value1:
 	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD ( WFD Service Discovery )
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD );
+	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -1755,13 +1737,13 @@ u32 build_provdisc_req_wfd_ie(struct wif
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	wfdielen += ETH_ALEN;
@@ -1791,7 +1773,6 @@ u32 build_provdisc_req_wfd_ie(struct wif
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
 }
 
 u32 build_provdisc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1812,8 +1793,8 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 	//	Commented by Albert 20110825
 	//	According to the WFD Specification, the provision discovery response frame should contain 3 WFD attributes
 	//	1. WFD Device Information
-	//	2. Associated BSSID ( Optional )
-	//	3. Local IP Adress ( Optional )
+	//	2. Associated BSSID (Optional)
+	//	3. Local IP Adress (Optional)
 
 
 	//	WFD Device Information ATTR
@@ -1827,14 +1808,14 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 
 	//	Value1:
 	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD ( WFD Service Discovery )
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD );
+	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -1854,13 +1835,13 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate(pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	wfdielen += ETH_ALEN;
@@ -1889,7 +1870,6 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
 }
 
 #endif //CONFIG_WFD
@@ -1913,16 +1893,16 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	//	According to the P2P Specification, the probe response frame should contain 5 P2P attributes
 	//	1. P2P Capability
 	//	2. Extended Listen Timing
-	//	3. Notice of Absence ( NOA )	( Only GO needs this )
+	//	3. Notice of Absence (NOA)	(Only GO needs this)
 	//	4. Device Info
-	//	5. Group Info	( Only GO need this )
+	//	5. Group Info	(Only GO need this)
 
 	//	P2P Capability ATTR
 	//	Type:
 	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
 	//	Length:
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	RTW_PUT_LE16(p2pie + p2pielen, 0x0002);
 	p2pielen += 2;
 
@@ -1940,10 +1920,10 @@ u32 build_probe_resp_p2p_ie(struct wifid
 
 		p2pielen++;
 	}
-	else if ( rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) )
+	else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE))
 	{
 		//	Group Capability Bitmap, 1 byte
-		if ( pwdinfo->persistent_supported )
+		if (pwdinfo->persistent_supported)
 			p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
 		else
 			p2pie[ p2pielen++ ] = DMP_P2P_GRPCAP_SUPPORT;
@@ -1955,18 +1935,18 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	p2pie[ p2pielen++ ] = P2P_ATTR_EX_LISTEN_TIMING;
 
 	//	Length:
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0004 );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0004);
 	RTW_PUT_LE16(p2pie + p2pielen, 0x0004);
 	p2pielen += 2;
 
 	//	Value:
 	//	Availability Period
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0xFFFF );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 	RTW_PUT_LE16(p2pie + p2pielen, 0xFFFF);
 	p2pielen += 2;
 
 	//	Availability Interval
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0xFFFF );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 	RTW_PUT_LE16(p2pie + p2pielen, 0xFFFF);
 	p2pielen += 2;
 
@@ -1987,9 +1967,9 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	//	Length:
 	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
 #ifdef CONFIG_INTEL_WIDI
-	if ( _rtw_memcmp( pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN ) == false )
+	if (_rtw_memcmp(pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == false)
 	{
 		RTW_PUT_LE16(p2pie + p2pielen, 21 + 8 + pwdinfo->device_name_len);
 	}
@@ -2000,34 +1980,34 @@ u32 build_probe_resp_p2p_ie(struct wifid
 
 	//	Value:
 	//	P2P Device Address
-	memcpy( p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN );
+	memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
 	//	Config Method
 	//	This field should be big endian. Noted by P2P specification.
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( pwdinfo->supported_wps_cm );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
 	RTW_PUT_BE16(p2pie + p2pielen, pwdinfo->supported_wps_cm);
 	p2pielen += 2;
 
 	//	Primary Device Type
 	//	Category ID
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 	RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
 	//	OUI
-	//*(u32*) ( p2pie + p2pielen ) = cpu_to_be32( WPSOUI );
+	//*(u32*) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 	RTW_PUT_BE32(p2pie + p2pielen, WPSOUI);
 	p2pielen += 4;
 
 	//	Sub Category ID
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_SCID_MEDIA_SERVER );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 	RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
 	//	Number of Secondary Device Types
 #ifdef CONFIG_INTEL_WIDI
-	if ( _rtw_memcmp( pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN ) == false )
+	if (_rtw_memcmp(pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == false)
 	{
 		p2pie[ p2pielen++ ] = 0x01;
 
@@ -2046,17 +2026,17 @@ u32 build_probe_resp_p2p_ie(struct wifid
 
 	//	Device Name
 	//	Type:
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 	RTW_PUT_BE16(p2pie + p2pielen, WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
 	//	Length:
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( pwdinfo->device_name_len );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 	RTW_PUT_BE16(p2pie + p2pielen, pwdinfo->device_name_len);
 	p2pielen += 2;
 
 	//	Value:
-	memcpy( p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len );
+	memcpy(p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len);
 	p2pielen += pwdinfo->device_name_len;
 
 	// Group Info ATTR
@@ -2073,10 +2053,9 @@ u32 build_probe_resp_p2p_ie(struct wifid
 
 
 	return len;
-
 }
 
-u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8* pssid, u8 ussidlen, u8* pdev_raddr )
+u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8* pssid, u8 ussidlen, u8* pdev_raddr)
 {
 	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
 	u32 len=0, p2pielen = 0;
@@ -2092,14 +2071,14 @@ u32 build_prov_disc_request_p2p_ie(struc
 	//	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes
 	//	1. P2P Capability
 	//	2. Device Info
-	//	3. Group ID ( When joining an operating P2P Group )
+	//	3. Group ID (When joining an operating P2P Group)
 
 	//	P2P Capability ATTR
 	//	Type:
 	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
 	//	Length:
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	RTW_PUT_LE16(p2pie + p2pielen, 0x0002);
 	p2pielen += 2;
 
@@ -2108,7 +2087,7 @@ u32 build_prov_disc_request_p2p_ie(struc
 	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 
 	//	Group Capability Bitmap, 1 byte
-	if ( pwdinfo->persistent_supported )
+	if (pwdinfo->persistent_supported)
 		p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
 	else
 		p2pie[ p2pielen++ ] = DMP_P2P_GRPCAP_SUPPORT;
@@ -2121,25 +2100,25 @@ u32 build_prov_disc_request_p2p_ie(struc
 	//	Length:
 	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
 	RTW_PUT_LE16(p2pie + p2pielen, 21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
 	//	Value:
 	//	P2P Device Address
-	memcpy( p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN );
+	memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
 	//	Config Method
 	//	This field should be big endian. Noted by P2P specification.
-	if ( pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PBC )
+	if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PBC)
 	{
-		//*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_CONFIG_METHOD_PBC );
+		//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_PBC);
 		RTW_PUT_BE16(p2pie + p2pielen, WPS_CONFIG_METHOD_PBC);
 	}
 	else
 	{
-		//*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_CONFIG_METHOD_DISPLAY );
+		//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY);
 		RTW_PUT_BE16(p2pie + p2pielen, WPS_CONFIG_METHOD_DISPLAY);
 	}
 
@@ -2147,17 +2126,17 @@ u32 build_prov_disc_request_p2p_ie(struc
 
 	//	Primary Device Type
 	//	Category ID
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 	RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
 	//	OUI
-	//*(u32*) ( p2pie + p2pielen ) = cpu_to_be32( WPSOUI );
+	//*(u32*) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 	RTW_PUT_BE32(p2pie + p2pielen, WPSOUI);
 	p2pielen += 4;
 
 	//	Sub Category ID
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_PDT_SCID_MEDIA_SERVER );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 	RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
@@ -2166,20 +2145,20 @@ u32 build_prov_disc_request_p2p_ie(struc
 
 	//	Device Name
 	//	Type:
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 	RTW_PUT_BE16(p2pie + p2pielen, WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
 	//	Length:
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_be16( pwdinfo->device_name_len );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 	RTW_PUT_BE16(p2pie + p2pielen, pwdinfo->device_name_len);
 	p2pielen += 2;
 
 	//	Value:
-	memcpy( p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len );
+	memcpy(p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len);
 	p2pielen += pwdinfo->device_name_len;
 
-	if ( rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) )
+	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
 	{
 		//	Added by Albert 2011/05/19
 		//	In this case, the pdev_raddr is the device address of the group owner.
@@ -2189,15 +2168,15 @@ u32 build_prov_disc_request_p2p_ie(struc
 		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
 
 		//	Length:
-		//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( ETH_ALEN + ussidlen );
+		//*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN + ussidlen);
 		RTW_PUT_LE16(p2pie + p2pielen, ETH_ALEN + ussidlen);
 		p2pielen += 2;
 
 		//	Value:
-		memcpy( p2pie + p2pielen, pdev_raddr, ETH_ALEN );
+		memcpy(p2pie + p2pielen, pdev_raddr, ETH_ALEN);
 		p2pielen += ETH_ALEN;
 
-		memcpy( p2pie + p2pielen, pssid, ussidlen );
+		memcpy(p2pie + p2pielen, pssid, ussidlen);
 		p2pielen += ussidlen;
 
 	}
@@ -2206,7 +2185,6 @@ u32 build_prov_disc_request_p2p_ie(struc
 
 
 	return len;
-
 }
 
 
@@ -2240,7 +2218,6 @@ u32 build_assoc_resp_p2p_ie(struct wifid
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &len);
 
 	return len;
-
 }
 
 u32 build_deauth_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -2261,22 +2238,22 @@ u32 process_probe_req_p2p_ie(struct wifi
 	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, _SUPPORTEDRATES_IE_, (int *)&rate_cnt,
 			len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
 
-	if ( rate_cnt <= 4 )
+	if (rate_cnt <= 4)
 	{
 		int i, g_rate =0;
 
-		for ( i = 0; i < rate_cnt; i++ )
+		for (i = 0; i < rate_cnt; i++)
 		{
-			if ( ( ( *( p + 2 + i ) & 0xff ) != 0x02 ) &&
-				( ( *( p + 2 + i ) & 0xff ) != 0x04 ) &&
-				( ( *( p + 2 + i ) & 0xff ) != 0x0B ) &&
-				( ( *( p + 2 + i ) & 0xff ) != 0x16 ) )
+			if (((*(p + 2 + i) & 0xff) != 0x02) &&
+				((*(p + 2 + i) & 0xff) != 0x04) &&
+				((*(p + 2 + i) & 0xff) != 0x0B) &&
+				((*(p + 2 + i) & 0xff) != 0x16))
 			{
 				g_rate = 1;
 			}
 		}
 
-		if ( g_rate == 0 )
+		if (g_rate == 0)
 		{
 			//	There is no OFDM rate included in SupportedRates IE of this probe request frame
 			//	The driver should response this probe request.
@@ -2294,7 +2271,7 @@ u32 process_probe_req_p2p_ie(struct wifi
 	//	1. This probe request frame must contain the P2P IE. (Done)
 	//	2. This probe request frame must contain the wildcard SSID. (Done)
 	//	3. Wildcard BSSID. (Todo)
-	//	4. Destination Address. ( Done in mgt_dispatcher function )
+	//	4. Destination Address. (Done in mgt_dispatcher function)
 	//	5. Requested Device Type in WSC IE. (Todo)
 	//	6. Device ID attribute in P2P IE. (Todo)
 
@@ -2304,9 +2281,9 @@ u32 process_probe_req_p2p_ie(struct wifi
 	ssid_len &= 0xff;	//	Just last 1 byte is valid for ssid len of the probe request
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
-		if ((p2pie=rtw_get_p2p_ie( pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_ , len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_ , NULL, &p2pielen)))
+		if ((p2pie=rtw_get_p2p_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_ , len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_ , NULL, &p2pielen)))
 		{
-			if ( (p != NULL) && _rtw_memcmp( ( void * ) ( p+2 ), ( void * ) pwdinfo->p2p_wildcard_ssid , 7 ))
+			if ((p != NULL) && _rtw_memcmp((void *) (p+2), (void *) pwdinfo->p2p_wildcard_ssid , 7))
 			{
 				//todo:
 				//Check Requested Device Type attributes in WSC IE.
@@ -2314,7 +2291,7 @@ u32 process_probe_req_p2p_ie(struct wifi
 
 				ret = true;
 			}
-			else if ( (p != NULL) && ( ssid_len == 0 ) )
+			else if ((p != NULL) && (ssid_len == 0))
 			{
 				ret = true;
 			}
@@ -2328,7 +2305,6 @@ u32 process_probe_req_p2p_ie(struct wifi
 
 
 	return ret;
-
 }
 
 u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len, struct sta_info *psta)
@@ -2361,22 +2337,22 @@ u32 process_assoc_req_p2p_ie(struct wifi
 
 	p2p_ie = rtw_get_p2p_ie(ies , ies_len , NULL, &p2p_ielen);
 
-	if ( !p2p_ie )
+	if (!p2p_ie)
 	{
-		DBG_8192D( "[%s] P2P IE not Found!!\n", __func__ );
+		DBG_8192D("[%s] P2P IE not Found!!\n", __func__);
 		status_code =  P2P_STATUS_FAIL_INVALID_PARAM;
 	}
 	else
 	{
-		DBG_8192D( "[%s] P2P IE Found!!\n", __func__ );
+		DBG_8192D("[%s] P2P IE Found!!\n", __func__);
 	}
 
-	while ( p2p_ie )
+	while (p2p_ie)
 	{
 		//Check P2P Capability ATTR
-		if ( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*) &attr_contentlen) )
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*) &attr_contentlen))
 		{
-			DBG_8192D( "[%s] Got P2P Capability Attr!!\n", __func__ );
+			DBG_8192D("[%s] Got P2P Capability Attr!!\n", __func__);
 			cap_attr = le16_to_cpu(cap_attr);
 			psta->dev_cap = cap_attr&0xff;
 		}
@@ -2387,7 +2363,7 @@ u32 process_assoc_req_p2p_ie(struct wifi
 		//Check P2P Device Info ATTR
 		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, NULL, (uint*)&attr_contentlen))
 		{
-			DBG_8192D( "[%s] Got P2P DEVICE INFO Attr!!\n", __func__ );
+			DBG_8192D("[%s] Got P2P DEVICE INFO Attr!!\n", __func__);
 			pattr_content = pbuf = rtw_zmalloc(attr_contentlen);
 			if (pattr_content)
 			{
@@ -2454,7 +2430,6 @@ u32 process_assoc_req_p2p_ie(struct wifi
 	}
 
 	return status_code;
-
 }
 
 u32 process_p2p_devdisc_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
@@ -2472,7 +2447,7 @@ u32 process_p2p_devdisc_req(struct wifid
 	dialogToken = frame_body[7];
 	status = P2P_STATUS_FAIL_UNKNOWN_P2PGROUP;
 
-	if ( (p2p_ie=rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)) )
+	if ((p2p_ie=rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)))
 	{
 		u8 groupid[ 38 ] = { 0x00 };
 		u8 dev_addr[ETH_ALEN] = { 0x00 };
@@ -2502,7 +2477,6 @@ u32 process_p2p_devdisc_req(struct wifid
 						if (psta->is_p2p_device && (psta->dev_cap&P2P_DEVCAP_CLIENT_DISCOVERABILITY) &&
 							_rtw_memcmp(psta->dev_addr, dev_addr, ETH_ALEN))
 						{
-
 							issue_group_disc_req(pwdinfo, psta->hwaddr);
 
 							status = P2P_STATUS_SUCCESS;
@@ -2539,7 +2513,6 @@ u32 process_p2p_devdisc_req(struct wifid
 
 
 	return (status==P2P_STATUS_SUCCESS) ? true:false;
-
 }
 
 u32 process_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
@@ -2547,7 +2520,7 @@ u32 process_p2p_devdisc_resp(struct wifi
 	return true;
 }
 
-u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,  u8 *pframe, uint len )
+u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,  u8 *pframe, uint len)
 {
 	u8 *frame_body;
 	u8 *wpsie;
@@ -2557,45 +2530,43 @@ u8 process_p2p_provdisc_req(struct wifid
 
 	frame_body = (pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
 
-	if ( (wpsie=rtw_get_wps_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &wps_ielen)) )
+	if ((wpsie=rtw_get_wps_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &wps_ielen)))
 	{
-		if ( rtw_get_wps_attr_content( wpsie, wps_ielen, WPS_ATTR_CONF_METHOD , ( u8* ) &uconfig_method, &attr_contentlen) )
+		if (rtw_get_wps_attr_content(wpsie, wps_ielen, WPS_ATTR_CONF_METHOD , (u8*) &uconfig_method, &attr_contentlen))
 		{
-			uconfig_method = be16_to_cpu( uconfig_method );
-			switch ( uconfig_method )
+			uconfig_method = be16_to_cpu(uconfig_method);
+			switch (uconfig_method)
 			{
 				case WPS_CM_DISPLYA:
 				{
-					memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis", 3 );
+					memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis", 3);
 					break;
 				}
 				case WPS_CM_LABEL:
 				{
-					memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "lab", 3 );
+					memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "lab", 3);
 					break;
 				}
 				case WPS_CM_PUSH_BUTTON:
 				{
-					memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3 );
+					memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3);
 					break;
 				}
 				case WPS_CM_KEYPAD:
 				{
-					memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3 );
+					memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3);
 					break;
 				}
 			}
-			issue_p2p_provision_resp( pwdinfo, GetAddr2Ptr(pframe), frame_body, uconfig_method);
+			issue_p2p_provision_resp(pwdinfo, GetAddr2Ptr(pframe), frame_body, uconfig_method);
 		}
 	}
-	DBG_8192D( "[%s] config method = %s\n", __func__, pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req );
+	DBG_8192D("[%s] config method = %s\n", __func__, pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req);
 	return true;
-
 }
 
 u8 process_p2p_provdisc_resp(struct wifidirect_info *pwdinfo,  u8 *pframe)
 {
-
 	return true;
 }
 
@@ -2607,14 +2578,14 @@ u8 rtw_p2p_get_peer_ch_list(struct wifid
 	ch_content += 3;
 	ch_cnt -= 3;
 
-	while ( ch_cnt > 0)
+	while (ch_cnt > 0)
 	{
 		ch_content += 1;
 		ch_cnt -= 1;
 		temp = *ch_content;
-		for ( i = 0 ; i < temp ; i++, j++ )
+		for (i = 0 ; i < temp ; i++, j++)
 		{
-			peer_ch_list[j] = *( ch_content + 1 + i );
+			peer_ch_list[j] = *(ch_content + 1 + i);
 		}
 		ch_content += (temp + 1);
 		ch_cnt -= (temp + 1);
@@ -2628,9 +2599,9 @@ u8 rtw_p2p_check_peer_oper_ch(struct mlm
 {
 	u8 i = 0;
 
-	for ( i = 0; i < pmlmeext->max_chan_nums; i++ )
+	for (i = 0; i < pmlmeext->max_chan_nums; i++)
 	{
-		if ( pmlmeext->channel_set[ i ].ChannelNum == ch )
+		if (pmlmeext->channel_set[ i ].ChannelNum == ch)
 		{
 			return _SUCCESS;
 		}
@@ -2644,13 +2615,13 @@ u8 rtw_p2p_ch_inclusion(struct mlme_ext_
 	int	i = 0, j = 0, temp = 0;
 	u8 ch_no = 0;
 
-	for ( i = 0; i < peer_ch_num; i++ )
+	for (i = 0; i < peer_ch_num; i++)
 	{
-		for ( j = temp; j < pmlmeext->max_chan_nums; j++ )
+		for (j = temp; j < pmlmeext->max_chan_nums; j++)
 		{
-			if ( *( peer_ch_list + i ) == pmlmeext->channel_set[ j ].ChannelNum )
+			if (*(peer_ch_list + i) == pmlmeext->channel_set[ j ].ChannelNum)
 			{
-				ch_list_inclusioned[ ch_no++ ] = *( peer_ch_list + i );
+				ch_list_inclusioned[ ch_no++ ] = *(peer_ch_list + i);
 				temp = j;
 				break;
 			}
@@ -2660,7 +2631,7 @@ u8 rtw_p2p_ch_inclusion(struct mlme_ext_
 	return ch_no;
 }
 
-u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe, uint len )
+u8 process_p2p_group_negotation_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
 {
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	u8	result = P2P_STATUS_SUCCESS;
@@ -2685,58 +2656,58 @@ u8 process_p2p_group_negotation_req( str
 	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 #endif
 
-	if ( (wpsie=rtw_get_wps_ie( pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &wps_ielen)) )
+	if ((wpsie=rtw_get_wps_ie(pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &wps_ielen)))
 	{
 		//	Commented by Kurt 20120113
 		//	If some device wants to do p2p handshake without sending prov_disc_req
 		//	We have to get peer_req_cm from here.
-		if (_rtw_memcmp( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3) )
+		if (_rtw_memcmp(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3))
 		{
-			rtw_get_wps_attr_content( wpsie, wps_ielen, WPS_ATTR_DEVICE_PWID, (u8*) &wps_devicepassword_id, &wps_devicepassword_id_len);
-			wps_devicepassword_id = be16_to_cpu( wps_devicepassword_id );
+			rtw_get_wps_attr_content(wpsie, wps_ielen, WPS_ATTR_DEVICE_PWID, (u8*) &wps_devicepassword_id, &wps_devicepassword_id_len);
+			wps_devicepassword_id = be16_to_cpu(wps_devicepassword_id);
 
-			if ( wps_devicepassword_id == WPS_DPID_USER_SPEC )
+			if (wps_devicepassword_id == WPS_DPID_USER_SPEC)
 			{
-				memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis", 3 );
+				memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis", 3);
 			}
-			else if ( wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC )
+			else if (wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC)
 			{
-				memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3 );
+				memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3);
 			}
 			else
 			{
-				memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3 );
+				memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3);
 			}
 		}
 	}
 	else
 	{
-		DBG_8192D( "[%s] WPS IE not Found!!\n", __func__ );
+		DBG_8192D("[%s] WPS IE not Found!!\n", __func__);
 		result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
-		return( result );
+		return(result);
 	}
 
-	if ( pwdinfo->ui_got_wps_info == P2P_NO_WPSINFO )
+	if (pwdinfo->ui_got_wps_info == P2P_NO_WPSINFO)
 	{
 		result = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_INFOR_NOREADY);
-		return( result );
+		return(result);
 	}
 
 	ies = pframe + _PUBLIC_ACTION_IE_OFFSET_;
 	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
 
-	p2p_ie = rtw_get_p2p_ie( ies, ies_len, NULL, &p2p_ielen );
+	p2p_ie = rtw_get_p2p_ie(ies, ies_len, NULL, &p2p_ielen);
 
-	if ( !p2p_ie )
+	if (!p2p_ie)
 	{
-		DBG_8192D( "[%s] P2P IE not Found!!\n", __func__ );
+		DBG_8192D("[%s] P2P IE not Found!!\n", __func__);
 		result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
 	}
 
-	while ( p2p_ie )
+	while (p2p_ie)
 	{
 		u8	attr_content = 0x00;
 		u32	attr_contentlen = 0;
@@ -2751,32 +2722,32 @@ u8 process_p2p_group_negotation_req( str
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);
 
 		//Check P2P Capability ATTR
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*)&attr_contentlen) )
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*)&attr_contentlen))
 		{
 			cap_attr = le16_to_cpu(cap_attr);
 
 #if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
-			if (!(cap_attr & P2P_GRPCAP_INTRABSS) )
+			if (!(cap_attr & P2P_GRPCAP_INTRABSS))
 				ptdlsinfo->ap_prohibited = true;
 #endif //defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 		}
 
-		if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT , &attr_content, &attr_contentlen) )
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT , &attr_content, &attr_contentlen))
 		{
-			DBG_8192D( "[%s] GO Intent = %d, tie = %d\n", __func__, attr_content >> 1, attr_content & 0x01 );
+			DBG_8192D("[%s] GO Intent = %d, tie = %d\n", __func__, attr_content >> 1, attr_content & 0x01);
 			pwdinfo->peer_intent = attr_content;	//	include both intent and tie breaker values.
 
-			if ( pwdinfo->intent == ( pwdinfo->peer_intent >> 1 ) )
+			if (pwdinfo->intent == (pwdinfo->peer_intent >> 1))
 			{
 				//	Try to match the tie breaker value
-				if ( pwdinfo->intent == P2P_MAX_INTENT )
+				if (pwdinfo->intent == P2P_MAX_INTENT)
 				{
 					rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
 					result = P2P_STATUS_FAIL_BOTH_GOINTENT_15;
 				}
 				else
 				{
-					if ( attr_content & 0x01 )
+					if (attr_content & 0x01)
 					{
 						rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 					}
@@ -2786,7 +2757,7 @@ u8 process_p2p_group_negotation_req( str
 					}
 				}
 			}
-			else if ( pwdinfo->intent > ( pwdinfo->peer_intent >> 1 ) )
+			else if (pwdinfo->intent > (pwdinfo->peer_intent >> 1))
 			{
 				rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
 			}
@@ -2798,29 +2769,29 @@ u8 process_p2p_group_negotation_req( str
 			if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 			{
 				//	Store the group id information.
-				memcpy( pwdinfo->groupid_info.go_device_addr, pwdinfo->device_addr, ETH_ALEN );
-				memcpy( pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen );
+				memcpy(pwdinfo->groupid_info.go_device_addr, pwdinfo->device_addr, ETH_ALEN);
+				memcpy(pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen);
 			}
 		}
 
 
 		attr_contentlen = 0;
-		if ( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_INTENTED_IF_ADDR, pwdinfo->p2p_peer_interface_addr, &attr_contentlen ) )
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INTENTED_IF_ADDR, pwdinfo->p2p_peer_interface_addr, &attr_contentlen))
 		{
-			if ( attr_contentlen != ETH_ALEN )
+			if (attr_contentlen != ETH_ALEN)
 			{
-				memset( pwdinfo->p2p_peer_interface_addr, 0x00, ETH_ALEN );
+				memset(pwdinfo->p2p_peer_interface_addr, 0x00, ETH_ALEN);
 			}
 		}
 
-		if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, ch_content, &ch_cnt) )
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, ch_content, &ch_cnt))
 		{
 			peer_ch_num = rtw_p2p_get_peer_ch_list(pwdinfo, ch_content, ch_cnt, peer_ch_list);
 			ch_num_inclusioned = rtw_p2p_ch_inclusion(&padapter->mlmeextpriv, peer_ch_list, peer_ch_num, ch_list_inclusioned);
 
-			if ( ch_num_inclusioned == 0)
+			if (ch_num_inclusioned == 0)
 			{
-				DBG_8192D( "[%s] No common channel in channel list!\n", __func__ );
+				DBG_8192D("[%s] No common channel in channel list!\n", __func__);
 				result = P2P_STATUS_FAIL_NO_COMMON_CH;
 				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
 				break;
@@ -2828,13 +2799,13 @@ u8 process_p2p_group_negotation_req( str
 
 			if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 			{
-				if ( !rtw_p2p_is_channel_list_ok( pwdinfo->operating_channel,
-												ch_list_inclusioned, ch_num_inclusioned) )
+				if (!rtw_p2p_is_channel_list_ok(pwdinfo->operating_channel,
+												ch_list_inclusioned, ch_num_inclusioned))
 				{
 #ifdef CONFIG_CONCURRENT_MODE
-					if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+					if (check_buddy_fwstate(padapter, _FW_LINKED))
 					{
-						DBG_8192D( "[%s] desired channel NOT Found!\n", __func__ );
+						DBG_8192D("[%s] desired channel NOT Found!\n", __func__);
 						result = P2P_STATUS_FAIL_NO_COMMON_CH;
 						rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
 						break;
@@ -2845,25 +2816,25 @@ u8 process_p2p_group_negotation_req( str
 						u8 operatingch_info[5] = { 0x00 }, peer_operating_ch = 0;
 						attr_contentlen = 0;
 
-						if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen) )
+						if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen))
 						{
 							peer_operating_ch = operatingch_info[4];
 						}
 
-						if ( rtw_p2p_is_channel_list_ok( peer_operating_ch,
-														ch_list_inclusioned, ch_num_inclusioned) )
+						if (rtw_p2p_is_channel_list_ok(peer_operating_ch,
+														ch_list_inclusioned, ch_num_inclusioned))
 						{
 							/**
 							 *	Change our operating channel as peer's for compatibility.
 							 */
 							pwdinfo->operating_channel = peer_operating_ch;
-							DBG_8192D( "[%s] Change op ch to %02x as peer's\n", __func__, pwdinfo->operating_channel);
+							DBG_8192D("[%s] Change op ch to %02x as peer's\n", __func__, pwdinfo->operating_channel);
 						}
 						else
 						{
 							// Take first channel of ch_list_inclusioned as operating channel
 							pwdinfo->operating_channel = ch_list_inclusioned[0];
-							DBG_8192D( "[%s] Change op ch to %02x\n", __func__, pwdinfo->operating_channel);
+							DBG_8192D("[%s] Change op ch to %02x\n", __func__, pwdinfo->operating_channel);
 						}
 					}
 
@@ -2878,25 +2849,25 @@ u8 process_p2p_group_negotation_req( str
 #ifdef CONFIG_WFD
 	//	Added by Albert 20110823
 	//	Try to get the TCP port information when receiving the negotiation request.
-	if ( rtw_get_wfd_ie( pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wfd_ie, &wfd_ielen ) )
+	if (rtw_get_wfd_ie(pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wfd_ie, &wfd_ielen))
 	{
 		u8	attr_content[ 10 ] = { 0x00 };
 		u32	attr_contentlen = 0;
 
-		DBG_8192D( "[%s] WFD IE Found!!\n", __func__ );
-		rtw_get_wfd_attr_content( wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
-		if ( attr_contentlen )
+		DBG_8192D("[%s] WFD IE Found!!\n", __func__);
+		rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
+		if (attr_contentlen)
 		{
-			pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16( attr_content + 2 );
-			DBG_8192D( "[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport );
+			pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16(attr_content + 2);
+			DBG_8192D("[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
 		}
 	}
 #endif // CONFIG_WFD
 
-	return( result );
+	return(result);
 }
 
-u8 process_p2p_group_negotation_resp( struct wifidirect_info *pwdinfo, u8 *pframe, uint len )
+u8 process_p2p_group_negotation_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
 {
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	u8	result = P2P_STATUS_SUCCESS;
@@ -2917,19 +2888,18 @@ u8 process_p2p_group_negotation_resp( st
 
 	//	Be able to know which one is the P2P GO and which one is P2P client.
 
-	if ( rtw_get_wps_ie( ies, ies_len, NULL, &wps_ielen) )
+	if (rtw_get_wps_ie(ies, ies_len, NULL, &wps_ielen))
 	{
-
 	}
 	else
 	{
-		DBG_8192D( "[%s] WPS IE not Found!!\n", __func__ );
+		DBG_8192D("[%s] WPS IE not Found!!\n", __func__);
 		result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
 	}
 
-	p2p_ie = rtw_get_p2p_ie( ies, ies_len, NULL, &p2p_ielen );
-	if ( !p2p_ie )
+	p2p_ie = rtw_get_p2p_ie(ies, ies_len, NULL, &p2p_ielen);
+	if (!p2p_ie)
 	{
 		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
@@ -2937,7 +2907,6 @@ u8 process_p2p_group_negotation_resp( st
 	}
 	else
 	{
-
 		u8	attr_content = 0x00;
 		u32	attr_contentlen = 0;
 		u8	operatingch_info[5] = { 0x00 };
@@ -2950,30 +2919,29 @@ u8 process_p2p_group_negotation_resp( st
 		u8	ch_list_inclusioned[50] = { 0x00 };
 		u8	ch_num_inclusioned = 0;
 
-		while ( p2p_ie )	//	Found the P2P IE.
+		while (p2p_ie)	//	Found the P2P IE.
 		{
-
 			//Check P2P Capability ATTR
-			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*)&attr_contentlen) )
+			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*)&attr_contentlen))
 			{
 				cap_attr = le16_to_cpu(cap_attr);
 #if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
-			if (!(cap_attr & P2P_GRPCAP_INTRABSS) )
+			if (!(cap_attr & P2P_GRPCAP_INTRABSS))
 				ptdlsinfo->ap_prohibited = true;
 #endif //defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 			}
 
 			rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, &attr_content, &attr_contentlen);
-			if ( attr_contentlen == 1 )
+			if (attr_contentlen == 1)
 			{
-				DBG_8192D( "[%s] Status = %d\n", __func__, attr_content );
-				if ( attr_content == P2P_STATUS_SUCCESS )
+				DBG_8192D("[%s] Status = %d\n", __func__, attr_content);
+				if (attr_content == P2P_STATUS_SUCCESS)
 				{
 					//	Do nothing.
 				}
 				else
 				{
-					if ( P2P_STATUS_FAIL_INFO_UNAVAILABLE == attr_content ) {
+					if (P2P_STATUS_FAIL_INFO_UNAVAILABLE == attr_content) {
 						rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_INFOR_NOREADY);
 					} else {
 						rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
@@ -2986,26 +2954,26 @@ u8 process_p2p_group_negotation_resp( st
 
 			//	Try to get the peer's interface address
 			attr_contentlen = 0;
-			if ( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_INTENTED_IF_ADDR, pwdinfo->p2p_peer_interface_addr, &attr_contentlen ) )
+			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INTENTED_IF_ADDR, pwdinfo->p2p_peer_interface_addr, &attr_contentlen))
 			{
-				if ( attr_contentlen != ETH_ALEN )
+				if (attr_contentlen != ETH_ALEN)
 				{
-					memset( pwdinfo->p2p_peer_interface_addr, 0x00, ETH_ALEN );
+					memset(pwdinfo->p2p_peer_interface_addr, 0x00, ETH_ALEN);
 				}
 			}
 
 			//	Try to get the peer's intent and tie breaker value.
 			attr_content = 0x00;
 			attr_contentlen = 0;
-			if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT , &attr_content, &attr_contentlen) )
+			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT , &attr_content, &attr_contentlen))
 			{
-				DBG_8192D( "[%s] GO Intent = %d, tie = %d\n", __func__, attr_content >> 1, attr_content & 0x01 );
+				DBG_8192D("[%s] GO Intent = %d, tie = %d\n", __func__, attr_content >> 1, attr_content & 0x01);
 				pwdinfo->peer_intent = attr_content;	//	include both intent and tie breaker values.
 
-				if ( pwdinfo->intent == ( pwdinfo->peer_intent >> 1 ) )
+				if (pwdinfo->intent == (pwdinfo->peer_intent >> 1))
 				{
 					//	Try to match the tie breaker value
-					if ( pwdinfo->intent == P2P_MAX_INTENT )
+					if (pwdinfo->intent == P2P_MAX_INTENT)
 					{
 						rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
 						result = P2P_STATUS_FAIL_BOTH_GOINTENT_15;
@@ -3015,7 +2983,7 @@ u8 process_p2p_group_negotation_resp( st
 					{
 						rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
 						rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
-						if ( attr_content & 0x01 )
+						if (attr_content & 0x01)
 						{
 							rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 						}
@@ -3025,7 +2993,7 @@ u8 process_p2p_group_negotation_resp( st
 						}
 					}
 				}
-				else if ( pwdinfo->intent > ( pwdinfo->peer_intent >> 1 ) )
+				else if (pwdinfo->intent > (pwdinfo->peer_intent >> 1))
 				{
 					rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
 					rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
@@ -3041,8 +3009,8 @@ u8 process_p2p_group_negotation_resp( st
 				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 				{
 					//	Store the group id information.
-					memcpy( pwdinfo->groupid_info.go_device_addr, pwdinfo->device_addr, ETH_ALEN );
-					memcpy( pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen );
+					memcpy(pwdinfo->groupid_info.go_device_addr, pwdinfo->device_addr, ETH_ALEN);
+					memcpy(pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen);
 
 				}
 			}
@@ -3050,23 +3018,23 @@ u8 process_p2p_group_negotation_resp( st
 			//	Try to get the operation channel information
 
 			attr_contentlen = 0;
-			if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen))
+			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen))
 			{
-				DBG_8192D( "[%s] Peer's operating channel = %d\n", __func__, operatingch_info[4] );
+				DBG_8192D("[%s] Peer's operating channel = %d\n", __func__, operatingch_info[4]);
 				pwdinfo->peer_operating_ch = operatingch_info[4];
 			}
 
 			//	Try to get the channel list information
-			if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, pwdinfo->channel_list_attr, &pwdinfo->channel_list_attr_len ) )
+			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, pwdinfo->channel_list_attr, &pwdinfo->channel_list_attr_len))
 			{
-				DBG_8192D( "[%s] channel list attribute found, len = %d\n", __func__,  pwdinfo->channel_list_attr_len );
+				DBG_8192D("[%s] channel list attribute found, len = %d\n", __func__,  pwdinfo->channel_list_attr_len);
 
 				peer_ch_num = rtw_p2p_get_peer_ch_list(pwdinfo, pwdinfo->channel_list_attr, pwdinfo->channel_list_attr_len, peer_ch_list);
 				ch_num_inclusioned = rtw_p2p_ch_inclusion(&padapter->mlmeextpriv, peer_ch_list, peer_ch_num, ch_list_inclusioned);
 
-				if ( ch_num_inclusioned == 0)
+				if (ch_num_inclusioned == 0)
 				{
-					DBG_8192D( "[%s] No common channel in channel list!\n", __func__ );
+					DBG_8192D("[%s] No common channel in channel list!\n", __func__);
 					result = P2P_STATUS_FAIL_NO_COMMON_CH;
 					rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
 					break;
@@ -3074,13 +3042,13 @@ u8 process_p2p_group_negotation_resp( st
 
 				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 				{
-					if ( !rtw_p2p_is_channel_list_ok( pwdinfo->operating_channel,
-													ch_list_inclusioned, ch_num_inclusioned) )
+					if (!rtw_p2p_is_channel_list_ok(pwdinfo->operating_channel,
+													ch_list_inclusioned, ch_num_inclusioned))
 					{
 #ifdef CONFIG_CONCURRENT_MODE
-						if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+						if (check_buddy_fwstate(padapter, _FW_LINKED))
 						{
-							DBG_8192D( "[%s] desired channel NOT Found!\n", __func__ );
+							DBG_8192D("[%s] desired channel NOT Found!\n", __func__);
 							result = P2P_STATUS_FAIL_NO_COMMON_CH;
 							rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
 							break;
@@ -3091,25 +3059,25 @@ u8 process_p2p_group_negotation_resp( st
 							u8 operatingch_info[5] = { 0x00 }, peer_operating_ch = 0;
 							attr_contentlen = 0;
 
-							if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen) )
+							if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen))
 							{
 								peer_operating_ch = operatingch_info[4];
 							}
 
-							if ( rtw_p2p_is_channel_list_ok( peer_operating_ch,
-															ch_list_inclusioned, ch_num_inclusioned) )
+							if (rtw_p2p_is_channel_list_ok(peer_operating_ch,
+															ch_list_inclusioned, ch_num_inclusioned))
 							{
 								/**
 								 *	Change our operating channel as peer's for compatibility.
 								 */
 								pwdinfo->operating_channel = peer_operating_ch;
-								DBG_8192D( "[%s] Change op ch to %02x as peer's\n", __func__, pwdinfo->operating_channel);
+								DBG_8192D("[%s] Change op ch to %02x as peer's\n", __func__, pwdinfo->operating_channel);
 							}
 							else
 							{
 								// Take first channel of ch_list_inclusioned as operating channel
 								pwdinfo->operating_channel = ch_list_inclusioned[0];
-								DBG_8192D( "[%s] Change op ch to %02x\n", __func__, pwdinfo->operating_channel);
+								DBG_8192D("[%s] Change op ch to %02x\n", __func__, pwdinfo->operating_channel);
 							}
 						}
 
@@ -3119,16 +3087,16 @@ u8 process_p2p_group_negotation_resp( st
 			}
 			else
 			{
-				DBG_8192D( "[%s] channel list attribute not found!\n", __func__);
+				DBG_8192D("[%s] channel list attribute not found!\n", __func__);
 			}
 
 			//	Try to get the group id information if peer is GO
 			attr_contentlen = 0;
-			memset( groupid, 0x00, 38 );
-			if ( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen) )
+			memset(groupid, 0x00, 38);
+			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen))
 			{
-				memcpy( pwdinfo->groupid_info.go_device_addr, &groupid[0], ETH_ALEN );
-				memcpy( pwdinfo->groupid_info.ssid, &groupid[6], attr_contentlen - ETH_ALEN );
+				memcpy(pwdinfo->groupid_info.go_device_addr, &groupid[0], ETH_ALEN);
+				memcpy(pwdinfo->groupid_info.ssid, &groupid[6], attr_contentlen - ETH_ALEN);
 			}
 
 			//Get the next P2P IE
@@ -3140,26 +3108,25 @@ u8 process_p2p_group_negotation_resp( st
 #ifdef CONFIG_WFD
 	//	Added by Albert 20111122
 	//	Try to get the TCP port information when receiving the negotiation response.
-	if ( rtw_get_wfd_ie( pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wfd_ie, &wfd_ielen ) )
+	if (rtw_get_wfd_ie(pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wfd_ie, &wfd_ielen))
 	{
 		u8	attr_content[ 10 ] = { 0x00 };
 		u32	attr_contentlen = 0;
 
-		DBG_8192D( "[%s] WFD IE Found!!\n", __func__ );
-		rtw_get_wfd_attr_content( wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
-		if ( attr_contentlen )
+		DBG_8192D("[%s] WFD IE Found!!\n", __func__);
+		rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
+		if (attr_contentlen)
 		{
-			pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16( attr_content + 2 );
-			DBG_8192D( "[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport );
+			pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16(attr_content + 2);
+			DBG_8192D("[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
 		}
 	}
 #endif // CONFIG_WFD
 
-	return( result );
-
+	return(result);
 }
 
-u8 process_p2p_group_negotation_confirm( struct wifidirect_info *pwdinfo, u8 *pframe, uint len )
+u8 process_p2p_group_negotation_confirm(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
 {
 	u8 * ies;
 	u32 ies_len;
@@ -3169,8 +3136,8 @@ u8 process_p2p_group_negotation_confirm(
 	ies = pframe + _PUBLIC_ACTION_IE_OFFSET_;
 	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
 
-	p2p_ie = rtw_get_p2p_ie( ies, ies_len, NULL, &p2p_ielen );
-	while ( p2p_ie )	//	Found the P2P IE.
+	p2p_ie = rtw_get_p2p_ie(ies, ies_len, NULL, &p2p_ielen);
+	while (p2p_ie)	//	Found the P2P IE.
 	{
 		u8	attr_content = 0x00, operatingch_info[5] = { 0x00 };
 		u8	groupid[ 38 ] = { 0x00 };
@@ -3178,33 +3145,33 @@ u8 process_p2p_group_negotation_confirm(
 
 		pwdinfo->negotiation_dialog_token = 1;
 		rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, &attr_content, &attr_contentlen);
-		if ( attr_contentlen == 1 )
+		if (attr_contentlen == 1)
 		{
-			DBG_8192D( "[%s] Status = %d\n", __func__, attr_content );
+			DBG_8192D("[%s] Status = %d\n", __func__, attr_content);
 			result = attr_content;
 
-			if ( attr_content == P2P_STATUS_SUCCESS )
+			if (attr_content == P2P_STATUS_SUCCESS)
 			{
 				u8	bcancelled = 0;
 
-				_cancel_timer( &pwdinfo->restore_p2p_state_timer, &bcancelled );
+				_cancel_timer(&pwdinfo->restore_p2p_state_timer, &bcancelled);
 
 				//	Commented by Albert 20100911
 				//	Todo: Need to handle the case which both Intents are the same.
 				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
 				rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
-				if ( ( pwdinfo->intent ) > ( pwdinfo->peer_intent >> 1 ) )
+				if ((pwdinfo->intent) > (pwdinfo->peer_intent >> 1))
 				{
 					rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
 				}
-				else if ( ( pwdinfo->intent ) < ( pwdinfo->peer_intent >> 1 ) )
+				else if ((pwdinfo->intent) < (pwdinfo->peer_intent >> 1))
 				{
 					rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 				}
 				else
 				{
 					//	Have to compare the Tie Breaker
-					if ( pwdinfo->peer_intent & 0x01 )
+					if (pwdinfo->peer_intent & 0x01)
 					{
 						rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 					}
@@ -3215,10 +3182,10 @@ u8 process_p2p_group_negotation_confirm(
 				}
 
 #ifdef CONFIG_CONCURRENT_MODE
-				if ( check_buddy_fwstate(pwdinfo->padapter , _FW_LINKED ) )
+				if (check_buddy_fwstate(pwdinfo->padapter , _FW_LINKED))
 				{
 					//	Switch back to the AP channel soon.
-					_set_timer( &pwdinfo->ap_p2p_switch_timer, 100 );
+					_set_timer(&pwdinfo->ap_p2p_switch_timer, 100);
 				}
 #endif
 			}
@@ -3232,18 +3199,18 @@ u8 process_p2p_group_negotation_confirm(
 
 		//	Try to get the group id information
 		attr_contentlen = 0;
-		memset( groupid, 0x00, 38 );
-		if ( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen) )
+		memset(groupid, 0x00, 38);
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen))
 		{
-			DBG_8192D( "[%s] Ssid = %s, ssidlen = %d\n", __func__, &groupid[ETH_ALEN], (u32)strlen(&groupid[ETH_ALEN]) );
-			memcpy( pwdinfo->groupid_info.go_device_addr, &groupid[0], ETH_ALEN );
-			memcpy( pwdinfo->groupid_info.ssid, &groupid[6], attr_contentlen - ETH_ALEN );
+			DBG_8192D("[%s] Ssid = %s, ssidlen = %d\n", __func__, &groupid[ETH_ALEN], (u32)strlen(&groupid[ETH_ALEN]));
+			memcpy(pwdinfo->groupid_info.go_device_addr, &groupid[0], ETH_ALEN);
+			memcpy(pwdinfo->groupid_info.ssid, &groupid[6], attr_contentlen - ETH_ALEN);
 		}
 
 		attr_contentlen = 0;
-		if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen) )
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen))
 		{
-			DBG_8192D( "[%s] Peer's operating channel = %d\n", __func__, operatingch_info[4] );
+			DBG_8192D("[%s] Peer's operating channel = %d\n", __func__, operatingch_info[4]);
 			pwdinfo->peer_operating_ch = operatingch_info[4];
 		}
 
@@ -3252,7 +3219,7 @@ u8 process_p2p_group_negotation_confirm(
 
 	}
 
-	return( result );
+	return(result);
 }
 
 u8 process_p2p_presence_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
@@ -3272,7 +3239,7 @@ u8 process_p2p_presence_req(struct wifid
 	return true;
 }
 
-void find_phase_handler(struct rtw_adapter*	padapter )
+void find_phase_handler(struct rtw_adapter*	padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -3282,7 +3249,7 @@ void find_phase_handler(struct rtw_adapt
 _func_enter_;
 
 	memset((unsigned char*)&ssid, 0, sizeof(struct ndis_802_11_ssid));
-	memcpy(ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN );
+	memcpy(ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN);
 	ssid.SsidLength = P2P_WILDCARD_SSID_LEN;
 
 	rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
@@ -3295,9 +3262,9 @@ _func_enter_;
 _func_exit_;
 }
 
-void p2p_concurrent_handler(struct rtw_adapter *padapter );
+void p2p_concurrent_handler(struct rtw_adapter *padapter);
 
-void restore_p2p_state_handler(struct rtw_adapter*	padapter )
+void restore_p2p_state_handler(struct rtw_adapter*	padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
@@ -3310,7 +3277,7 @@ _func_enter_;
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+	if (check_buddy_fwstate(padapter, _FW_LINKED))
 	{
 		struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
@@ -3330,17 +3297,17 @@ _func_enter_;
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE))
 	{
 #ifdef CONFIG_CONCURRENT_MODE
-		p2p_concurrent_handler( padapter );
+		p2p_concurrent_handler(padapter);
 #else
 		//	In the P2P client mode, the driver should not switch back to its listen channel
 		//	because this P2P client should stay at the operating channel of P2P GO.
-		set_channel_bwmode( padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
+		set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 #endif
 	}
 _func_exit_;
 }
 
-void pre_tx_invitereq_handler(struct rtw_adapter*	padapter )
+void pre_tx_invitereq_handler(struct rtw_adapter*	padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	u8	val8 = 1;
@@ -3349,12 +3316,12 @@ _func_enter_;
 	set_channel_bwmode(padapter, pwdinfo->invitereq_info.peer_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 	issue_probereq_p2p(padapter, NULL);
-	_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
+	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 
 _func_exit_;
 }
 
-void pre_tx_provdisc_handler(struct rtw_adapter*	padapter )
+void pre_tx_provdisc_handler(struct rtw_adapter*	padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	u8	val8 = 1;
@@ -3363,12 +3330,12 @@ _func_enter_;
 	set_channel_bwmode(padapter, pwdinfo->tx_prov_disc_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 	issue_probereq_p2p(padapter, NULL);
-	_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
+	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 
 _func_exit_;
 }
 
-void pre_tx_negoreq_handler(struct rtw_adapter*	padapter )
+void pre_tx_negoreq_handler(struct rtw_adapter*	padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	u8	val8 = 1;
@@ -3377,13 +3344,13 @@ _func_enter_;
 	set_channel_bwmode(padapter, pwdinfo->nego_req_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 	issue_probereq_p2p(padapter, NULL);
-	_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
+	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 
 _func_exit_;
 }
 
 #ifdef CONFIG_CONCURRENT_MODE
-void p2p_concurrent_handler(struct rtw_adapter*	padapter )
+void p2p_concurrent_handler(struct rtw_adapter*	padapter)
 {
 	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
 	//_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
@@ -3393,7 +3360,7 @@ void p2p_concurrent_handler(struct rtw_a
 	u8					val8;
 _func_enter_;
 
-	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+	if (check_buddy_fwstate(padapter, _FW_LINKED))
 	{
 		struct rtw_adapter * pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -3412,11 +3379,11 @@ _func_enter_;
 		{
 			//	Now, the driver stays on the AP's channel.
 			//	If the pwdinfo->ext_listen_period = 0, that means the P2P listen state is not available on listen channel.
-			if ( pwdinfo->ext_listen_period > 0 )
+			if (pwdinfo->ext_listen_period > 0)
 			{
-				DBG_8192D( "[%s] P2P_STATE_IDLE, ext_listen_period = %d\n", __func__, pwdinfo->ext_listen_period );
+				DBG_8192D("[%s] P2P_STATE_IDLE, ext_listen_period = %d\n", __func__, pwdinfo->ext_listen_period);
 
-				if ( pbuddy_mlmeext->cur_channel != pwdinfo->listen_channel )
+				if (pbuddy_mlmeext->cur_channel != pwdinfo->listen_channel)
 				{
 					//	Will switch to listen channel so that need to send the NULL data with PW bit to AP.
 					issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
@@ -3428,22 +3395,22 @@ _func_enter_;
 				rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 
 				//	Todo: To check the value of pwdinfo->ext_listen_period is equal to 0 or not.
-				_set_timer( &pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_period );
+				_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_period);
 			}
 		}
-		else if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN) ||
+		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN) ||
 				rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL) ||
-				( rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == false ) ||
-				rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ) )
+				(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == false) ||
+				rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ))
 		{
 			//	Now, the driver is in the listen state of P2P mode.
-			DBG_8192D( "[%s] P2P_STATE_IDLE, ext_listen_interval = %d\n", __func__, pwdinfo->ext_listen_interval );
+			DBG_8192D("[%s] P2P_STATE_IDLE, ext_listen_interval = %d\n", __func__, pwdinfo->ext_listen_interval);
 
 			//	Commented by Albert 2012/11/01
 			//	If the AP's channel is the same as the listen channel, we should still be in the listen state
 			//	Other P2P device is still able to find this device out even this device is in the AP's channel.
 			//	So, configure this device to be able to receive the probe request frame and set it to listen state.
-			if ( pbuddy_mlmeext->cur_channel != pwdinfo->listen_channel )
+			if (pbuddy_mlmeext->cur_channel != pwdinfo->listen_channel)
 			{
 				set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 				val8 = 0;
@@ -3453,7 +3420,7 @@ _func_enter_;
 			}
 
 			//	Todo: To check the value of pwdinfo->ext_listen_interval is equal to 0 or not.
-			_set_timer( &pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_interval );
+			_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_interval);
 		}
 		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_OK))
 		{
@@ -3469,7 +3436,7 @@ _func_enter_;
 			set_channel_bwmode(padapter, pwdinfo->tx_prov_disc_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 			issue_probereq_p2p(padapter, NULL);
-			_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
+			_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 		}
 		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == true)
 		{
@@ -3477,23 +3444,23 @@ _func_enter_;
 			set_channel_bwmode(padapter, pwdinfo->nego_req_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 			issue_probereq_p2p(padapter, NULL);
-			_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
+			_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 		}
-		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ ) && pwdinfo->invitereq_info.benable == true)
+		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ) && pwdinfo->invitereq_info.benable == true)
 		{
 			/*
 			val8 = 1;
 			set_channel_bwmode(padapter, , HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 			issue_probereq_p2p(padapter, NULL);
-			_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
+			_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 			*/
 		}
 #endif //CONFIG_IOCTL_CFG80211
 	}
 	else
 	{
-		set_channel_bwmode( padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
+		set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	}
 
 _func_exit_;
@@ -3510,9 +3477,8 @@ static void ro_ch_handler(struct rtw_ada
 _func_enter_;
 
 	{
-
 #ifdef CONFIG_CONCURRENT_MODE
-		if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+		if (check_buddy_fwstate(padapter, _FW_LINKED))
 		{
 			struct rtw_adapter * pbuddy_adapter = padapter->pbuddy_adapter;
 			struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -3525,9 +3491,9 @@ _func_enter_;
 
 		}else
 #endif //CONFIG_CONCURRENT_MODE
-		if ( pcfg80211_wdinfo->restore_channel != pmlmeext->cur_channel )
+		if (pcfg80211_wdinfo->restore_channel != pmlmeext->cur_channel)
 		{
-			if ( !check_fwstate(&padapter->mlmepriv, _FW_LINKED ) )
+			if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
 				pmlmeext->cur_channel = pcfg80211_wdinfo->restore_channel;
 
 			set_channel_bwmode(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
@@ -3562,7 +3528,7 @@ static void ro_ch_timer_process (void *F
 	ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
 #endif
 
-	p2p_protocol_wk_cmd( adapter, P2P_RO_CH_WK);
+	p2p_protocol_wk_cmd(adapter, P2P_RO_CH_WK);
 }
 
 static void rtw_cfg80211_adjust_p2pie_channel(struct rtw_adapter *padapter, const u8 *frame_body, u32 len)
@@ -3576,9 +3542,9 @@ static void rtw_cfg80211_adjust_p2pie_ch
 	ies = (u8*)(frame_body + _PUBLIC_ACTION_IE_OFFSET_);
 	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
 
-	p2p_ie = rtw_get_p2p_ie( ies, ies_len, NULL, &p2p_ielen );
+	p2p_ie = rtw_get_p2p_ie(ies, ies_len, NULL, &p2p_ielen);
 
-	while ( p2p_ie )
+	while (p2p_ie)
 	{
 		u32	attr_contentlen = 0;
 		u8 *pattr = NULL;
@@ -3640,35 +3606,35 @@ void rtw_append_wfd_ie(struct rtw_adapte
 		{
 			OUI_Subtype = frame_body[6];
 			dialogToken = frame_body[7];
-			switch ( OUI_Subtype )//OUI Subtype
+			switch (OUI_Subtype)//OUI Subtype
 			{
 				case P2P_GO_NEGO_REQ:
 				{
-					wfdielen = build_nego_req_wfd_ie( &padapter->wdinfo, buf + ( *len ) );
+					wfdielen = build_nego_req_wfd_ie(&padapter->wdinfo, buf + (*len));
 					(*len) += wfdielen;
 					break;
 				}
 				case P2P_GO_NEGO_RESP:
 				{
-					wfdielen = build_nego_resp_wfd_ie( &padapter->wdinfo, buf + ( *len ) );
+					wfdielen = build_nego_resp_wfd_ie(&padapter->wdinfo, buf + (*len));
 					(*len) += wfdielen;
 					break;
 				}
 				case P2P_GO_NEGO_CONF:
 				{
-					wfdielen = build_nego_confirm_wfd_ie( &padapter->wdinfo, buf + ( *len ) );
+					wfdielen = build_nego_confirm_wfd_ie(&padapter->wdinfo, buf + (*len));
 					(*len) += wfdielen;
 					break;
 				}
 				case P2P_INVIT_REQ:
 				{
-					wfdielen = build_invitation_req_wfd_ie( &padapter->wdinfo, buf + ( *len ) );
+					wfdielen = build_invitation_req_wfd_ie(&padapter->wdinfo, buf + (*len));
 					(*len) += wfdielen;
 					break;
 				}
 				case P2P_INVIT_RESP:
 				{
-					wfdielen = build_invitation_resp_wfd_ie( &padapter->wdinfo, buf + ( *len ) );
+					wfdielen = build_invitation_resp_wfd_ie(&padapter->wdinfo, buf + (*len));
 					(*len) += wfdielen;
 					break;
 				}
@@ -3679,13 +3645,13 @@ void rtw_append_wfd_ie(struct rtw_adapte
 					break;
 				case P2P_PROVISION_DISC_REQ:
 				{
-					wfdielen = build_provdisc_req_wfd_ie( &padapter->wdinfo, buf + ( *len ) );
+					wfdielen = build_provdisc_req_wfd_ie(&padapter->wdinfo, buf + (*len));
 					(*len) += wfdielen;
 					break;
 				}
 				case P2P_PROVISION_DISC_RESP:
 				{
-					wfdielen = build_provdisc_resp_wfd_ie( &padapter->wdinfo, buf + ( *len ) );
+					wfdielen = build_provdisc_resp_wfd_ie(&padapter->wdinfo, buf + (*len));
 					(*len) += wfdielen;
 					break;
 				}
@@ -3704,7 +3670,7 @@ void rtw_append_wfd_ie(struct rtw_adapte
 
 #ifdef CONFIG_DEBUG_CFG80211
 		DBG_8192D("ACTION_CATEGORY_P2P: OUI=0x%x, OUI_Subtype=%d, dialogToken=%d\n",
-					cpu_to_be32( *( ( u32* ) ( frame_body + 1 ) ) ), OUI_Subtype, dialogToken);
+					cpu_to_be32(*((u32*) (frame_body + 1))), OUI_Subtype, dialogToken);
 #endif
 
 		switch (OUI_Subtype)
@@ -3761,7 +3727,7 @@ int rtw_p2p_check_frames(struct rtw_adap
 			is_p2p_frame = OUI_Subtype;
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192D("ACTION_CATEGORY_PUBLIC: ACT_PUBLIC_VENDOR, OUI=0x%x, OUI_Subtype=%d, dialogToken=%d\n",
-				cpu_to_be32( *( ( u32* ) ( frame_body + 2 ) ) ), OUI_Subtype, dialogToken);
+				cpu_to_be32(*((u32*) (frame_body + 2))), OUI_Subtype, dialogToken);
 			#endif
 
 			p2p_ie = rtw_get_p2p_ie(
@@ -3769,7 +3735,7 @@ int rtw_p2p_check_frames(struct rtw_adap
 				len-sizeof(struct rtw_ieee80211_hdr_3addr)-_PUBLIC_ACTION_IE_OFFSET_,
 				NULL, &p2p_ielen);
 
-			switch ( OUI_Subtype )//OUI Subtype
+			switch (OUI_Subtype)//OUI Subtype
 			{
 				u8 *cont;
 				uint cont_len;
@@ -3896,25 +3862,17 @@ int rtw_p2p_check_frames(struct rtw_adap
 
 					DBG_8192D("RTW_%s:P2P_PROVISION_DISC_REQ, dialogToken=%d\n", (tx==true)?"Tx":"Rx", dialogToken);
 
-					//if (tx)
 					{
-						pwdev_priv->provdisc_req_issued = false;
-
-						if ( (p2p_ie=rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)))
-						{
-
-							if (rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, NULL, &contentlen))
-							{
-								pwdev_priv->provdisc_req_issued = false;//case: p2p_client join p2p GO
-							}
-							else
-							{
-								#ifdef CONFIG_DEBUG_CFG80211
-								DBG_8192D("provdisc_req_issued is true\n");
-								#endif //CONFIG_DEBUG_CFG80211
-								pwdev_priv->provdisc_req_issued = true;//case: p2p_devices connection before Nego req.
-							}
+					pwdev_priv->provdisc_req_issued = false;
 
+					if ((p2p_ie=rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen))) {
+						if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, NULL, &contentlen)) {
+							pwdev_priv->provdisc_req_issued = false;//case: p2p_client join p2p GO
+						} else {
+							#ifdef CONFIG_DEBUG_CFG80211
+							DBG_8192D("provdisc_req_issued is true\n");
+							#endif //CONFIG_DEBUG_CFG80211
+							pwdev_priv->provdisc_req_issued = true;//case: p2p_devices connection before Nego req.
 						}
 					}
 				}
@@ -3928,16 +3886,13 @@ int rtw_p2p_check_frames(struct rtw_adap
 			}
 
 		}
-
-	}
-	else if (category == RTW_WLAN_CATEGORY_P2P)
-	{
+	} else if (category == RTW_WLAN_CATEGORY_P2P) {
 		OUI_Subtype = frame_body[5];
 		dialogToken = frame_body[6];
 
 		#ifdef CONFIG_DEBUG_CFG80211
 		DBG_8192D("ACTION_CATEGORY_P2P: OUI=0x%x, OUI_Subtype=%d, dialogToken=%d\n",
-			cpu_to_be32( *( ( u32* ) ( frame_body + 1 ) ) ), OUI_Subtype, dialogToken);
+			cpu_to_be32(*((u32*) (frame_body + 1))), OUI_Subtype, dialogToken);
 		#endif
 
 		is_p2p_frame = OUI_Subtype;
@@ -3975,9 +3930,9 @@ void rtw_init_cfg80211_wifidirect_info(s
 {
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 
-	memset(pcfg80211_wdinfo, 0x00, sizeof(struct cfg80211_wifidirect_info) );
+	memset(pcfg80211_wdinfo, 0x00, sizeof(struct cfg80211_wifidirect_info));
 
-	_init_timer( &pcfg80211_wdinfo->remain_on_ch_timer, padapter->pnetdev, ro_ch_timer_process, padapter );
+	_init_timer(&pcfg80211_wdinfo->remain_on_ch_timer, padapter->pnetdev, ro_ch_timer_process, padapter);
 }
 #endif //CONFIG_IOCTL_CFG80211
 
@@ -3991,59 +3946,59 @@ _func_enter_;
 	{
 		case P2P_FIND_PHASE_WK:
 		{
-			find_phase_handler( padapter );
+			find_phase_handler(padapter);
 			break;
 		}
 		case P2P_RESTORE_STATE_WK:
 		{
-			restore_p2p_state_handler( padapter );
+			restore_p2p_state_handler(padapter);
 			break;
 		}
 		case P2P_PRE_TX_PROVDISC_PROCESS_WK:
 		{
 #ifdef CONFIG_CONCURRENT_MODE
-			if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+			if (check_buddy_fwstate(padapter, _FW_LINKED))
 			{
-				p2p_concurrent_handler( padapter );
+				p2p_concurrent_handler(padapter);
 			}
 			else
 			{
-				pre_tx_provdisc_handler( padapter );
+				pre_tx_provdisc_handler(padapter);
 			}
 #else
-			pre_tx_provdisc_handler( padapter );
+			pre_tx_provdisc_handler(padapter);
 #endif
 			break;
 		}
 		case P2P_PRE_TX_INVITEREQ_PROCESS_WK:
 		{
 #ifdef CONFIG_CONCURRENT_MODE
-			if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+			if (check_buddy_fwstate(padapter, _FW_LINKED))
 			{
-				p2p_concurrent_handler( padapter );
+				p2p_concurrent_handler(padapter);
 			}
 			else
 			{
-				pre_tx_invitereq_handler( padapter );
+				pre_tx_invitereq_handler(padapter);
 			}
 #else
-			pre_tx_invitereq_handler( padapter );
+			pre_tx_invitereq_handler(padapter);
 #endif
 			break;
 		}
 		case P2P_PRE_TX_NEGOREQ_PROCESS_WK:
 		{
 #ifdef CONFIG_CONCURRENT_MODE
-			if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+			if (check_buddy_fwstate(padapter, _FW_LINKED))
 			{
-				p2p_concurrent_handler( padapter );
+				p2p_concurrent_handler(padapter);
 			}
 			else
 			{
-				pre_tx_negoreq_handler( padapter );
+				pre_tx_negoreq_handler(padapter);
 			}
 #else
-			pre_tx_negoreq_handler( padapter );
+			pre_tx_negoreq_handler(padapter);
 #endif
 			break;
 		}
@@ -4051,7 +4006,7 @@ _func_enter_;
 #ifdef CONFIG_CONCURRENT_MODE
 		case P2P_AP_P2P_CH_SWITCH_PROCESS_WK:
 		{
-			p2p_concurrent_handler( padapter );
+			p2p_concurrent_handler(padapter);
 			break;
 		}
 #endif
@@ -4059,7 +4014,7 @@ _func_enter_;
 #ifdef CONFIG_IOCTL_CFG80211
 		case P2P_RO_CH_WK:
 		{
-			ro_ch_handler( padapter );
+			ro_ch_handler(padapter);
 			break;
 		}
 #endif //CONFIG_IOCTL_CFG80211
@@ -4079,7 +4034,7 @@ void process_p2p_ps_ie(struct rtw_adapte
 	u8	noa_attr[MAX_P2P_IE_LEN] = { 0x00 };// NoA length should be n*(13) + 2
 	u32	attr_contentlen = 0;
 
-	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 	u8	find_p2p = false, find_p2p_ps = false;
 	u8	noa_offset, noa_num, noa_index;
 
@@ -4100,19 +4055,19 @@ _func_enter_;
 	ies = IEs + _BEACON_IE_OFFSET_;
 	ies_len = IELength - _BEACON_IE_OFFSET_;
 
-	p2p_ie = rtw_get_p2p_ie( ies, ies_len, NULL, &p2p_ielen);
+	p2p_ie = rtw_get_p2p_ie(ies, ies_len, NULL, &p2p_ielen);
 
 	while (p2p_ie)
 	{
 		find_p2p = true;
 		// Get Notice of Absence IE.
-		if (rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_NOA, noa_attr, &attr_contentlen))
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_NOA, noa_attr, &attr_contentlen))
 		{
 			find_p2p_ps = true;
 			noa_index = noa_attr[0];
 
-			if ( (pwdinfo->p2p_ps_mode == P2P_PS_NONE) ||
-				(noa_index != pwdinfo->noa_index) )// if index change, driver should reconfigure related setting.
+			if ((pwdinfo->p2p_ps_mode == P2P_PS_NONE) ||
+				(noa_index != pwdinfo->noa_index))// if index change, driver should reconfigure related setting.
 			{
 				pwdinfo->noa_index = noa_index;
 				pwdinfo->opp_ps = noa_attr[1] >> 7;
@@ -4143,7 +4098,7 @@ _func_enter_;
 				}
 				pwdinfo->noa_num = noa_num;
 
-				if ( pwdinfo->opp_ps == 1 )
+				if (pwdinfo->opp_ps == 1)
 				{
 					pwdinfo->p2p_ps_mode = P2P_PS_CTWINDOW;
 					// driver should wait LPS for entering CTWindow
@@ -4152,12 +4107,12 @@ _func_enter_;
 						p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 1);
 					}
 				}
-				else if ( pwdinfo->noa_num > 0 )
+				else if (pwdinfo->noa_num > 0)
 				{
 					pwdinfo->p2p_ps_mode = P2P_PS_NOA;
 					p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 1);
 				}
-				else if ( pwdinfo->p2p_ps_mode > P2P_PS_NONE)
+				else if (pwdinfo->p2p_ps_mode > P2P_PS_NONE)
 				{
 					p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
 				}
@@ -4173,7 +4128,7 @@ _func_enter_;
 
 	if (find_p2p == true)
 	{
-		if ( (pwdinfo->p2p_ps_mode > P2P_PS_NONE) && (find_p2p_ps == false) )
+		if ((pwdinfo->p2p_ps_mode > P2P_PS_NONE) && (find_p2p_ps == false))
 		{
 			p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
 		}
@@ -4214,7 +4169,7 @@ _func_enter_;
 			if (pwdinfo->p2p_ps_mode > P2P_PS_NONE) {
 				pwdinfo->p2p_ps_state = p2p_ps_state;
 
-				if ( pwdinfo->ctwindow > 0 )
+				if (pwdinfo->ctwindow > 0)
 				{
 					if (pwrpriv->smart_ps != 0)
 					{
@@ -4251,7 +4206,7 @@ u8 p2p_ps_wk_cmd(struct rtw_adapter*pada
 
 _func_enter_;
 
-	if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
 #ifdef CONFIG_CONCURRENT_MODE
 		|| (padapter->iface_type != IFACE_PORT0)
 #endif
@@ -4293,7 +4248,6 @@ exit:
 _func_exit_;
 
 	return res;
-
 }
 #endif // CONFIG_P2P_PS
 
@@ -4305,7 +4259,7 @@ static void reset_ch_sitesurvey_timer_pr
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 
-	DBG_8192D( "[%s] In\n", __func__ );
+	DBG_8192D("[%s] In\n", __func__);
 	//	Reset the operation channel information
 	pwdinfo->rx_invitereq_info.operation_ch[0] = 0;
 	pwdinfo->rx_invitereq_info.scan_op_ch_only = 0;
@@ -4319,7 +4273,7 @@ static void reset_ch_sitesurvey_timer_pr
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 
-	DBG_8192D( "[%s] In\n", __func__ );
+	DBG_8192D("[%s] In\n", __func__);
 	//	Reset the operation channel information
 	pwdinfo->p2p_info.operation_ch[0] = 0;
 	pwdinfo->p2p_info.scan_op_ch_only = 0;
@@ -4333,7 +4287,7 @@ static void restore_p2p_state_timer_proc
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 
-	p2p_protocol_wk_cmd( adapter, P2P_RESTORE_STATE_WK );
+	p2p_protocol_wk_cmd(adapter, P2P_RESTORE_STATE_WK);
 }
 
 static void pre_tx_scan_timer_process (void *FunctionContext)
@@ -4353,32 +4307,32 @@ static void pre_tx_scan_timer_process (v
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
 	{
-		if ( true == pwdinfo->tx_prov_disc_info.benable )	//	the provision discovery request frame is trigger to send or not
+		if (true == pwdinfo->tx_prov_disc_info.benable)	//	the provision discovery request frame is trigger to send or not
 		{
-			p2p_protocol_wk_cmd( adapter, P2P_PRE_TX_PROVDISC_PROCESS_WK );
+			p2p_protocol_wk_cmd(adapter, P2P_PRE_TX_PROVDISC_PROCESS_WK);
 			//issue_probereq_p2p(adapter, NULL);
-			//_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
+			//_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 		}
 	}
 	else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
 	{
-		if ( true == pwdinfo->nego_req_info.benable )
+		if (true == pwdinfo->nego_req_info.benable)
 		{
-			p2p_protocol_wk_cmd( adapter, P2P_PRE_TX_NEGOREQ_PROCESS_WK );
+			p2p_protocol_wk_cmd(adapter, P2P_PRE_TX_NEGOREQ_PROCESS_WK);
 			//issue_probereq_p2p(adapter, NULL);
-			//_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
+			//_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
 		}
 	}
-	else if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ ) )
+	else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ))
 	{
-		if ( true == pwdinfo->invitereq_info.benable )
+		if (true == pwdinfo->invitereq_info.benable)
 		{
-			p2p_protocol_wk_cmd( adapter, P2P_PRE_TX_INVITEREQ_PROCESS_WK );
+			p2p_protocol_wk_cmd(adapter, P2P_PRE_TX_INVITEREQ_PROCESS_WK);
 		}
 	}
 	else
 	{
-		DBG_8192D( "[%s] p2p_state is %d, ignore!!\n", __func__, rtw_p2p_state(pwdinfo) );
+		DBG_8192D("[%s] p2p_state is %d, ignore!!\n", __func__, rtw_p2p_state(pwdinfo));
 	}
 
 	spin_unlock_bh(&pmlmepriv->lock);
@@ -4394,7 +4348,7 @@ static void find_phase_timer_process (vo
 
 	adapter->wdinfo.find_phase_state_exchange_cnt++;
 
-	p2p_protocol_wk_cmd( adapter, P2P_FIND_PHASE_WK );
+	p2p_protocol_wk_cmd(adapter, P2P_FIND_PHASE_WK);
 }
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -4413,11 +4367,11 @@ void ap_p2p_switch_timer_process (void *
 	ATOMIC_SET(&pwdev_priv->switch_ch_to, 1);
 #endif
 
-	p2p_protocol_wk_cmd( adapter, P2P_AP_P2P_CH_SWITCH_PROCESS_WK );
+	p2p_protocol_wk_cmd(adapter, P2P_AP_P2P_CH_SWITCH_PROCESS_WK);
 }
 #endif
 
-void reset_global_wifidirect_info(struct rtw_adapter* padapter )
+void reset_global_wifidirect_info(struct rtw_adapter* padapter)
 {
 	struct wifidirect_info	*pwdinfo;
 
@@ -4446,10 +4400,9 @@ int rtw_init_wifi_display_info(struct rt
 	pwfd_info->wfd_pc = false;
 
 	// Used in TDLS
-	memset( pwfd_info->ip_address, 0x00, 4 );
-	memset( pwfd_info->peer_ip_address, 0x00, 4 );
+	memset(pwfd_info->ip_address, 0x00, 4);
+	memset(pwfd_info->peer_ip_address, 0x00, 4);
 	return res;
-
 }
 #endif //CONFIG_WFD
 
@@ -4457,13 +4410,13 @@ void rtw_init_wifidirect_timers(struct r
 {
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 
-	_init_timer( &pwdinfo->find_phase_timer, padapter->pnetdev, find_phase_timer_process, padapter );
-	_init_timer( &pwdinfo->restore_p2p_state_timer, padapter->pnetdev, restore_p2p_state_timer_process, padapter );
-	_init_timer( &pwdinfo->pre_tx_scan_timer, padapter->pnetdev, pre_tx_scan_timer_process, padapter );
-	_init_timer( &pwdinfo->reset_ch_sitesurvey, padapter->pnetdev, reset_ch_sitesurvey_timer_process, padapter );
-	_init_timer( &pwdinfo->reset_ch_sitesurvey2, padapter->pnetdev, reset_ch_sitesurvey_timer_process2, padapter );
+	_init_timer(&pwdinfo->find_phase_timer, padapter->pnetdev, find_phase_timer_process, padapter);
+	_init_timer(&pwdinfo->restore_p2p_state_timer, padapter->pnetdev, restore_p2p_state_timer_process, padapter);
+	_init_timer(&pwdinfo->pre_tx_scan_timer, padapter->pnetdev, pre_tx_scan_timer_process, padapter);
+	_init_timer(&pwdinfo->reset_ch_sitesurvey, padapter->pnetdev, reset_ch_sitesurvey_timer_process, padapter);
+	_init_timer(&pwdinfo->reset_ch_sitesurvey2, padapter->pnetdev, reset_ch_sitesurvey_timer_process2, padapter);
 #ifdef CONFIG_CONCURRENT_MODE
-	_init_timer( &pwdinfo->ap_p2p_switch_timer, padapter->pnetdev, ap_p2p_switch_timer_process, padapter );
+	_init_timer(&pwdinfo->ap_p2p_switch_timer, padapter->pnetdev, ap_p2p_switch_timer_process, padapter);
 #endif
 }
 
@@ -4512,9 +4465,9 @@ void init_wifidirect_info(struct rtw_ada
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 	}
 
-	if ( ( check_buddy_fwstate(padapter, _FW_LINKED ) == true ) &&
-	      ( ( pbuddy_mlmeext->cur_channel == 1) || ( pbuddy_mlmeext->cur_channel == 6 ) || ( pbuddy_mlmeext->cur_channel == 11 ) )
-	   )
+	if ((check_buddy_fwstate(padapter, _FW_LINKED) == true) &&
+	      ((pbuddy_mlmeext->cur_channel == 1) || (pbuddy_mlmeext->cur_channel == 6) || (pbuddy_mlmeext->cur_channel == 11))
+	  )
 	{
 		//	Use the AP's channel as the listen channel
 		//	This will avoid the channel switch between AP's channel and listen channel.
@@ -4531,7 +4484,7 @@ void init_wifidirect_info(struct rtw_ada
 	{
 		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
 		#ifdef CONFIG_CONCURRENT_MODE
-		if ( check_buddy_fwstate(padapter, _FW_LINKED ) == true )
+		if (check_buddy_fwstate(padapter, _FW_LINKED) == true)
 		{
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_IDLE);
 		}
@@ -4558,7 +4511,7 @@ void init_wifidirect_info(struct rtw_ada
 		rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
 	}
 
-//	Use the OFDM rate in the P2P probe response frame. ( 6(B), 9(B), 12, 18, 24, 36, 48, 54 )
+//	Use the OFDM rate in the P2P probe response frame. (6(B), 9(B), 12, 18, 24, 36, 48, 54)
 	pwdinfo->support_rate[0] = 0x8c;	//	6(B)
 	pwdinfo->support_rate[1] = 0x92;	//	9(B)
 	pwdinfo->support_rate[2] = 0x18;	//	12
@@ -4568,34 +4521,34 @@ void init_wifidirect_info(struct rtw_ada
 	pwdinfo->support_rate[6] = 0x60;	//	48
 	pwdinfo->support_rate[7] = 0x6c;	//	54
 
-	memcpy( ( void* ) pwdinfo->p2p_wildcard_ssid, "DIRECT-", 7 );
+	memcpy((void*) pwdinfo->p2p_wildcard_ssid, "DIRECT-", 7);
 
-	memset( pwdinfo->device_name, 0x00, WPS_MAX_DEVICE_NAME_LEN );
+	memset(pwdinfo->device_name, 0x00, WPS_MAX_DEVICE_NAME_LEN);
 	pwdinfo->device_name_len = 0;
 
-	memset( &pwdinfo->invitereq_info, 0x00, sizeof( struct tx_invite_req_info ) );
+	memset(&pwdinfo->invitereq_info, 0x00, sizeof(struct tx_invite_req_info));
 	pwdinfo->invitereq_info.token = 3;	//	Token used for P2P invitation request frame.
 
-	memset( &pwdinfo->inviteresp_info, 0x00, sizeof( struct tx_invite_resp_info ) );
+	memset(&pwdinfo->inviteresp_info, 0x00, sizeof(struct tx_invite_resp_info));
 	pwdinfo->inviteresp_info.token = 0;
 
 	pwdinfo->profileindex = 0;
-	memset( &pwdinfo->profileinfo[ 0 ], 0x00, sizeof( struct profile_info ) * P2P_MAX_PERSISTENT_GROUP_NUM );
+	memset(&pwdinfo->profileinfo[ 0 ], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
 
 	rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
 
-	pwdinfo->listen_dwell = ( u8 ) (( rtw_get_current_time() % 3 ) + 1);
-	//DBG_8192D( "[%s] listen_dwell time is %d00ms\n", __func__, pwdinfo->listen_dwell );
+	pwdinfo->listen_dwell = (u8) ((rtw_get_current_time() % 3) + 1);
+	//DBG_8192D("[%s] listen_dwell time is %d00ms\n", __func__, pwdinfo->listen_dwell);
 
-	memset( &pwdinfo->tx_prov_disc_info, 0x00, sizeof( struct tx_provdisc_req_info ) );
+	memset(&pwdinfo->tx_prov_disc_info, 0x00, sizeof(struct tx_provdisc_req_info));
 	pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_NONE;
 
-	memset( &pwdinfo->nego_req_info, 0x00, sizeof( struct tx_nego_req_info ) );
+	memset(&pwdinfo->nego_req_info, 0x00, sizeof(struct tx_nego_req_info));
 
 	pwdinfo->device_password_id_for_nego = WPS_DPID_PBC;
 	pwdinfo->negotiation_dialog_token = 1;
 
-	memset( pwdinfo->nego_ssid, 0x00, WLAN_SSID_MAXLEN );
+	memset(pwdinfo->nego_ssid, 0x00, WLAN_SSID_MAXLEN);
 	pwdinfo->nego_ssidlen = 0;
 
 	pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
@@ -4606,11 +4559,11 @@ void init_wifidirect_info(struct rtw_ada
 	pwdinfo->supported_wps_cm = WPS_CONFIG_METHOD_DISPLAY | WPS_CONFIG_METHOD_PBC | WPS_CONFIG_METHOD_KEYPAD;
 #endif //CONFIG_WFD
 	pwdinfo->channel_list_attr_len = 0;
-	memset( pwdinfo->channel_list_attr, 0x00, 100 );
+	memset(pwdinfo->channel_list_attr, 0x00, 100);
 
-	memset( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, 0x00, 4 );
-	memset( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, '0', 3 );
-	memset( &pwdinfo->groupid_info, 0x00, sizeof( struct group_id_info ) );
+	memset(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, 0x00, 4);
+	memset(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, '0', 3);
+	memset(&pwdinfo->groupid_info, 0x00, sizeof(struct group_id_info));
 #ifdef CONFIG_CONCURRENT_MODE
 #ifdef CONFIG_IOCTL_CFG80211
 	pwdinfo->ext_listen_interval = 1000; //The interval to be available with legacy AP during p2p0-find/scan
@@ -4623,8 +4576,8 @@ void init_wifidirect_info(struct rtw_ada
 #endif //!CONFIG_IOCTL_CFG80211
 #endif
 	pwdinfo->wfd_tdls_enable = 0;
-	memset( pwdinfo->p2p_peer_interface_addr, 0x00, ETH_ALEN );
-	memset( pwdinfo->p2p_peer_device_addr, 0x00, ETH_ALEN );
+	memset(pwdinfo->p2p_peer_interface_addr, 0x00, ETH_ALEN);
+	memset(pwdinfo->p2p_peer_device_addr, 0x00, ETH_ALEN);
 
 	pwdinfo->rx_invitereq_info.operation_ch[0] = 0;
 	pwdinfo->rx_invitereq_info.operation_ch[1] = 0;	//	Used to indicate the scan end in site survey function
@@ -4757,15 +4710,15 @@ int rtw_p2p_enable(struct rtw_adapter *p
 		//Disable P2P function
 		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
-			_cancel_timer_ex( &pwdinfo->find_phase_timer );
-			_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
-			_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
-			_cancel_timer_ex( &pwdinfo->reset_ch_sitesurvey);
-			_cancel_timer_ex( &pwdinfo->reset_ch_sitesurvey2);
-			reset_ch_sitesurvey_timer_process( padapter );
-			reset_ch_sitesurvey_timer_process2( padapter );
+			_cancel_timer_ex(&pwdinfo->find_phase_timer);
+			_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
+			_cancel_timer_ex(&pwdinfo->pre_tx_scan_timer);
+			_cancel_timer_ex(&pwdinfo->reset_ch_sitesurvey);
+			_cancel_timer_ex(&pwdinfo->reset_ch_sitesurvey2);
+			reset_ch_sitesurvey_timer_process(padapter);
+			reset_ch_sitesurvey_timer_process2(padapter);
 			#ifdef CONFIG_CONCURRENT_MODE
-			_cancel_timer_ex( &pwdinfo->ap_p2p_switch_timer);
+			_cancel_timer_ex(&pwdinfo->ap_p2p_switch_timer);
 			#endif
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
 			rtw_p2p_set_role(pwdinfo, P2P_ROLE_DISABLE);
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -41,7 +41,7 @@ void ips_enter(struct rtw_adapter * pada
 	pwrpriv->ips_enter_cnts++;
 	DBG_8192D("==>ips_enter cnts:%d\n",pwrpriv->ips_enter_cnts);
 
-	if (rf_off == pwrpriv->change_rfpwrstate )
+	if (rf_off == pwrpriv->change_rfpwrstate)
 	{
 		if (pwrpriv->ips_mode == IPS_LEVEL_2)
 			pwrpriv->bkeepfwalive = true;
@@ -51,7 +51,6 @@ void ips_enter(struct rtw_adapter * pada
 	}
 	pwrpriv->bips_processing = false;
 	_exit_pwrlock(&pwrpriv->lock);
-
 }
 
 int ips_leave(struct rtw_adapter * padapter)
@@ -107,7 +106,7 @@ extern int autoresume_enter(struct rtw_a
 #endif
 
 #ifdef SUPPORT_HW_RFOFF_DETECTED
-int rtw_hw_suspend(struct rtw_adapter *padapter );
+int rtw_hw_suspend(struct rtw_adapter *padapter);
 int rtw_hw_resume(struct rtw_adapter *padapter);
 #endif
 
@@ -174,7 +173,7 @@ exit:
 void rtw_ps_processor(struct rtw_adapter*padapter)
 {
 #ifdef CONFIG_P2P
-	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 #endif //CONFIG_P2P
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -228,12 +227,12 @@ void rtw_ps_processor(struct rtw_adapter
 					pwrpriv->change_rfpwrstate = rf_off;
 					pwrpriv->brfoffbyhw = true;
 					padapter->bCardDisableWOHSM = true;
-					rtw_hw_suspend(padapter );
+					rtw_hw_suspend(padapter);
 				}
 				else
 				{
 					pwrpriv->change_rfpwrstate = rf_on;
-					rtw_hw_resume(padapter );
+					rtw_hw_resume(padapter);
 				}
 				DBG_8192D("current rf_pwrstate(%s)\n",(pwrpriv->rf_pwrstate == rf_off)?"rf_off":"rf_on");
 			}
@@ -362,13 +361,13 @@ u8 PS_RDY_CHECK(struct rtw_adapter * pad
 	if (	(check_fwstate(pmlmepriv, _FW_LINKED) == false) ||
 		(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) ||
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) )
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
 		return false;
 
-	if (true == pwrpriv->bInSuspend )
+	if (true == pwrpriv->bInSuspend)
 		return false;
 
-	if ( (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) && (padapter->securitypriv.binstallGrpkey == false) )
+	if ((padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) && (padapter->securitypriv.binstallGrpkey == false))
 	{
 		DBG_8192D("Group handshake still in progress !!!\n");
 		return false;
@@ -385,7 +384,7 @@ void rtw_set_ps_mode(struct rtw_adapter
 {
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 #ifdef CONFIG_P2P
-	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 #endif //CONFIG_P2P
 #ifdef CONFIG_TDLS
 	struct sta_priv *pstapriv = &padapter->stapriv;
@@ -433,7 +432,7 @@ _func_enter_;
 				{
 					ptdls_sta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
-					if ( ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE )
+					if (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE)
 						issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 0);
 					plist = get_next(plist);
 				}
@@ -487,7 +486,7 @@ _func_enter_;
 				{
 					ptdls_sta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
-					if ( ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE )
+					if (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE)
 						issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 1);
 					plist = get_next(plist);
 				}
@@ -573,7 +572,7 @@ _func_enter_;
 	    (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) ||
 	    (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) ||
 	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
-	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) )
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
 		return;
 
 	if (true == pwrpriv->bInSuspend)
@@ -1088,7 +1087,6 @@ _func_enter_;
 
 
 _func_exit_;
-
 }
 
 
@@ -1191,7 +1189,6 @@ void rtw_register_early_suspend(struct p
 	pwrpriv->early_suspend.resume = rtw_late_resume;
 	register_early_suspend(&pwrpriv->early_suspend);
 
-
 }
 
 void rtw_unregister_early_suspend(struct pwrctrl_priv *pwrpriv)
@@ -1323,7 +1320,7 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 	}
 
 	//System suspend is not allowed to wakeup
-	if ((pwrpriv->bInternalAutoSuspend == false) && (true == pwrpriv->bInSuspend )){
+	if ((pwrpriv->bInternalAutoSuspend == false) && (true == pwrpriv->bInSuspend)){
 		ret = _FAIL;
 		goto exit;
 	}
@@ -1341,7 +1338,7 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 		goto exit;
 	}
 
-	if (rf_off == pwrpriv->rf_pwrstate )
+	if (rf_off == pwrpriv->rf_pwrstate)
 	{
 #ifdef CONFIG_AUTOSUSPEND
 		 if (pwrpriv->brfoffbyhw==true)
@@ -1393,7 +1390,6 @@ exit:
 	if (pwrpriv->ips_deny_time < rtw_get_current_time() + rtw_ms_to_systime(ips_deffer_ms))
 		pwrpriv->ips_deny_time = rtw_get_current_time() + rtw_ms_to_systime(ips_deffer_ms);
 	return ret;
-
 }
 
 int rtw_pm_set_lps(struct rtw_adapter *padapter, u8 mode)
@@ -1401,7 +1397,7 @@ int rtw_pm_set_lps(struct rtw_adapter *p
 	int	ret = 0;
 	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 
-	if ( mode < PS_MODE_NUM )
+	if (mode < PS_MODE_NUM)
 	{
 		if (pwrctrlpriv->power_mgnt !=mode)
 		{
@@ -1429,7 +1425,7 @@ int rtw_pm_set_ips(struct rtw_adapter *p
 {
 	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 
-	if ( mode == IPS_NORMAL || mode == IPS_LEVEL_2 ) {
+	if (mode == IPS_NORMAL || mode == IPS_LEVEL_2) {
 		rtw_ips_mode_req(pwrctrlpriv, mode);
 		DBG_8192D("%s %s\n", __func__, mode == IPS_NORMAL?"IPS_NORMAL":"IPS_LEVEL_2");
 		return 0;
@@ -1437,7 +1433,7 @@ int rtw_pm_set_ips(struct rtw_adapter *p
 	else if (mode ==IPS_NONE){
 		rtw_ips_mode_req(pwrctrlpriv, mode);
 		DBG_8192D("%s %s\n", __func__, "IPS_NONE");
-		if ((padapter->bSurpriseRemoved ==0)&&(_FAIL == rtw_pwr_wakeup(padapter)) )
+		if ((padapter->bSurpriseRemoved ==0)&&(_FAIL == rtw_pwr_wakeup(padapter)))
 			return -EFAULT;
 	}
 	else {
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -38,7 +38,6 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
 {
 
-
 _func_enter_;
 
 	memset((u8 *)psta_recvpriv, 0, sizeof (struct sta_recv_priv));
@@ -51,7 +50,6 @@ _func_enter_;
 	_rtw_init_queue(&psta_recvpriv->defrag_q);
 
 _func_exit_;
-
 }
 
 int _rtw_init_recv_priv(struct recv_priv *precvpriv, struct rtw_adapter *padapter)
@@ -129,7 +127,6 @@ exit:
 _func_exit_;
 
 	return res;
-
 }
 
 void rtw_mfree_recv_priv_lock(struct recv_priv *precvpriv);
@@ -170,12 +167,10 @@ _func_enter_;
 	rtw_hal_free_recv_priv(padapter);
 
 _func_exit_;
-
 }
 
 union recv_frame *_rtw_alloc_recvframe (struct __queue *pfree_recv_queue)
 {
-
 	union recv_frame  *precvframe;
 	struct list_head *plist, *phead;
 	struct rtw_adapter *padapter;
@@ -206,7 +201,6 @@ _func_enter_;
 _func_exit_;
 
 	return precvframe;
-
 }
 
 union recv_frame *rtw_alloc_recvframe (struct __queue *pfree_recv_queue)
@@ -271,7 +265,6 @@ _func_enter_;
 _func_exit_;
 
 	return _SUCCESS;
-
 }
 
 
@@ -279,7 +272,6 @@ _func_exit_;
 
 int _rtw_enqueue_recvframe(union recv_frame *precvframe, struct __queue *queue)
 {
-
 	struct rtw_adapter *padapter=precvframe->u.hdr.adapter;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 
@@ -343,7 +335,6 @@ _func_enter_;
 	_rtw_spinunlock(&pframequeue->lock);
 
 _func_exit_;
-
 }
 
 u32 rtw_free_uc_swdec_pending_queue(struct rtw_adapter *adapter)
@@ -388,7 +379,6 @@ int rtw_enqueue_recvbuf(struct recv_buf
 
 
 	return _SUCCESS;
-
 }
 
 struct recv_buf *rtw_dequeue_recvbuf(struct __queue *queue)
@@ -419,12 +409,10 @@ struct recv_buf *rtw_dequeue_recvbuf(str
 
 
 	return precvbuf;
-
 }
 
 int recvframe_chkmic(struct rtw_adapter *adapter,  union recv_frame *precvframe);
 int recvframe_chkmic(struct rtw_adapter *adapter,  union recv_frame *precvframe){
-
 	int	i,res=_SUCCESS;
 	u32	datalen;
 	u8	miccode[8];
@@ -455,7 +443,7 @@ _func_enter_;
 			{
 				//mickey=&psecuritypriv->dot118021XGrprxmickey.skey[0];
 				//iv = precvframe->u.hdr.rx_data+prxattrib->hdrlen;
-				//rxdata_key_idx =( ((iv[3])>>6)&0x3) ;
+				//rxdata_key_idx =(((iv[3])>>6)&0x3) ;
 				mickey=&psecuritypriv->dot118021XGrprxmickey[prxattrib->key_index].skey[0];
 
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n recvframe_chkmic: bcmc key\n"));
@@ -498,7 +486,6 @@ _func_enter_;
 
 
 			if (bmic_err==true){
-
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n *(pframemic-8)-*(pframemic-1)=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
 					*(pframemic-8),*(pframemic-7),*(pframemic-6),*(pframemic-5),*(pframemic-4),*(pframemic-3),*(pframemic-2),*(pframemic-1)));
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n *(pframemic-16)-*(pframemic-9)=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
@@ -524,7 +511,7 @@ _func_enter_;
 
 				// double check key_index for some timing issue ,
 				// cannot compare with psecuritypriv->dot118021XGrpKeyid also cause timing issue
-				if ((IS_MCAST(prxattrib->ra)==true)  && (prxattrib->key_index != pmlmeinfo->key_index ))
+				if ((IS_MCAST(prxattrib->ra)==true)  && (prxattrib->key_index != pmlmeinfo->key_index))
 					brpt_micerror = false;
 
 				if (brpt_micerror == true)
@@ -560,14 +547,12 @@ exit:
 _func_exit_;
 
 	return res;
-
 }
 
 //decrypt and set the ivlen,icvlen of the recv_frame
 union recv_frame * decryptor(struct rtw_adapter *padapter,union recv_frame *precv_frame);
 union recv_frame * decryptor(struct rtw_adapter *padapter,union recv_frame *precv_frame)
 {
-
 	struct rx_pkt_attrib *prxattrib = &precv_frame->u.hdr.attrib;
 	struct security_priv *psecuritypriv=&padapter->securitypriv;
 	union recv_frame *return_packet=precv_frame;
@@ -579,7 +564,7 @@ _func_enter_;
 	if (prxattrib->encrypt>0)
 	{
 		u8 *iv = precv_frame->u.hdr.rx_data+prxattrib->hdrlen;
-		prxattrib->key_index = ( ((iv[3])>>6)&0x3) ;
+		prxattrib->key_index = (((iv[3])>>6)&0x3) ;
 
 		if (prxattrib->key_index > WEP_KEYS)
 		{
@@ -601,7 +586,6 @@ _func_enter_;
 
 	if ((prxattrib->encrypt>0) && ((prxattrib->bdecrypted==0) ||(psecuritypriv->sw_decrypt==true)))
 	{
-
 #ifdef CONFIG_CONCURRENT_MODE
 		if (!IS_MCAST(prxattrib->ra))//bc/mc packets use sw decryption for concurrent mode
 #endif
@@ -621,7 +605,7 @@ _func_enter_;
 			res = rtw_tkip_decrypt(padapter, (u8 *)precv_frame);
 			break;
 		case _AES_:
-			res = rtw_aes_decrypt(padapter, (u8 * )precv_frame);
+			res = rtw_aes_decrypt(padapter, (u8 *)precv_frame);
 			break;
 		default:
 				break;
@@ -629,7 +613,7 @@ _func_enter_;
 	}
 	else if (prxattrib->bdecrypted==1
 		&& prxattrib->encrypt >0
-		&& (psecuritypriv->busetkipkey==1 || prxattrib->encrypt !=_TKIP_ )
+		&& (psecuritypriv->busetkipkey==1 || prxattrib->encrypt !=_TKIP_)
 		)
 	{
 		psecuritypriv->hw_decrypted=true;
@@ -653,7 +637,6 @@ _func_enter_;
 _func_exit_;
 
 	return return_packet;
-
 }
 //###set the security information in the recv_frame
 union recv_frame * portctrl(struct rtw_adapter *adapter,union recv_frame * precv_frame);
@@ -694,7 +677,7 @@ _func_enter_;
 			//get ether_type
 			ptr=ptr+pfhdr->attrib.hdrlen+pfhdr->attrib.iv_len+LLC_HEADER_SIZE;
 			memcpy(&ether_type,ptr, 2);
-			ether_type= ntohs((unsigned short )ether_type);
+			ether_type= ntohs((unsigned short)ether_type);
 
 		        if (ether_type == eapol_type) {
 				prtnframe=precv_frame;
@@ -718,7 +701,6 @@ _func_enter_;
 			prtnframe=precv_frame;
 			//check is the EAPOL frame or not (Rekey)
 			if (ether_type == eapol_type){
-
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("########portctrl:ether_type == 0x888e\n"));
 				//check Rekey
 
@@ -737,7 +719,6 @@ _func_enter_;
 _func_exit_;
 
 		return prtnframe;
-
 }
 
 int recv_decache(union recv_frame *precv_frame, u8 bretry, struct stainfo_rxcache *prxcache);
@@ -745,7 +726,7 @@ int recv_decache(union recv_frame *precv
 {
 	int tid = precv_frame->u.hdr.attrib.priority;
 
-	u16 seq_ctrl = ( (precv_frame->u.hdr.attrib.seq_num&0xffff) << 4) |
+	u16 seq_ctrl = ((precv_frame->u.hdr.attrib.seq_num&0xffff) << 4) |
 		(precv_frame->u.hdr.attrib.frag_num & 0xf);
 
 _func_enter_;
@@ -772,7 +753,6 @@ _func_enter_;
 _func_exit_;
 
 	return _SUCCESS;
-
 }
 
 void process_pwrbit_data(struct rtw_adapter *padapter, union recv_frame *precv_frame);
@@ -834,7 +814,7 @@ void process_wmmps_data(struct rtw_adapt
 	if (!psta) return;
 
 #ifdef CONFIG_TDLS
-	if ( !(psta->tdls_sta_state & TDLS_LINKED_STATE ) )
+	if (!(psta->tdls_sta_state & TDLS_LINKED_STATE))
 	{
 #endif //CONFIG_TDLS
 
@@ -891,7 +871,6 @@ void process_wmmps_data(struct rtw_adapt
 
 
 #endif
-
 }
 
 #ifdef CONFIG_TDLS
@@ -957,16 +936,16 @@ int OnTDLS(struct rtw_adapter *adapter,
 			break;
 #ifdef CONFIG_WFD
 		case 0x50:	//First byte of WFA OUI
-			if ( _rtw_memcmp(WFA_OUI, (paction), 3) )
+			if (_rtw_memcmp(WFA_OUI, (paction), 3))
 			{
-				if ( *(paction + 3) == 0x04)	//Probe request frame
+				if (*(paction + 3) == 0x04)	//Probe request frame
 				{
 					//WFDTDLS: for sigma test, do not setup direct link automatically
 					ptdlsinfo->dev_discovered = 1;
 					DBG_8192D("recv tunneled probe request frame\n");
 					issue_tunneled_probe_rsp(adapter, precv_frame);
 				}
-				if ( *(paction + 3) == 0x05)	//Probe response frame
+				if (*(paction + 3) == 0x05)	//Probe response frame
 				{
 					//WFDTDLS: for sigma test, do not setup direct link automatically
 					ptdlsinfo->dev_discovered = 1;
@@ -983,7 +962,6 @@ int OnTDLS(struct rtw_adapter *adapter,
 
 exit:
 	return ret;
-
 }
 #endif //CONFIG_TDLS
 
@@ -1001,7 +979,7 @@ void count_rx_stats(struct rtw_adapter *
 
 	padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod++;
 
-	if ( (!MacAddr_isBcst(pattrib->dst)) && (!IS_MCAST(pattrib->dst))){
+	if ((!MacAddr_isBcst(pattrib->dst)) && (!IS_MCAST(pattrib->dst))){
 		padapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod++;
 	}
 
@@ -1017,7 +995,6 @@ void count_rx_stats(struct rtw_adapter *
 		pstats->rx_data_pkts++;
 		pstats->rx_bytes += sz;
 	}
-
 }
 
 int sta2sta_data_frame(
@@ -1053,7 +1030,6 @@ _func_enter_;
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))
 	{
-
 		// filter packets that SA is myself or multicast or broadcast
 		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" SA==myself\n"));
@@ -1061,14 +1037,14 @@ _func_enter_;
 			goto exit;
 		}
 
-		if ( (!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))	&& (!bmcast) ){
+		if ((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))	&& (!bmcast)){
 			ret= _FAIL;
 			goto exit;
 		}
 
-		if ( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		if (_rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 		   _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
-		   (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) ) {
+		   (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN))) {
 			ret= _FAIL;
 			goto exit;
 		}
@@ -1090,7 +1066,7 @@ _func_enter_;
 			else if (ptdls_sta->tdls_sta_state&TDLS_LINKED_STATE)
 			{
 				//drop QoS-SubType Data, including QoS NULL, excluding QoS-Data
-				if ( (GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE )== WIFI_QOS_DATA_TYPE)
+				if ((GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE)== WIFI_QOS_DATA_TYPE)
 				{
 					if (GetFrameSubType(ptr)&(BIT(4)|BIT(5)|BIT(6)))
 					{
@@ -1111,9 +1087,9 @@ _func_enter_;
 					goto exit;
 				}
 				// check BSSID
-				if ( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+				if (_rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 				     _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
-				     (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) )
+				     (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)))
 				{
 					ret= _FAIL;
 					goto exit;
@@ -1161,7 +1137,7 @@ _func_enter_;
 #endif //CONFIG_TDLS
 		{
 			// For Station mode, sa and bssid should always be BSSID, and DA is my mac-address
-			if (!_rtw_memcmp(pattrib->bssid, pattrib->src, ETH_ALEN) )
+			if (!_rtw_memcmp(pattrib->bssid, pattrib->src, ETH_ALEN))
 			{
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("bssid != TA under STATION_MODE; drop pkt\n"));
 				ret= _FAIL;
@@ -1234,17 +1210,16 @@ _func_enter_;
 exit:
 _func_exit_;
 	return ret;
-
 }
 
 int ap2sta_data_frame(
 	struct rtw_adapter *adapter,
 	union recv_frame *precv_frame,
-	struct sta_info**psta );
+	struct sta_info**psta);
 int ap2sta_data_frame(
 	struct rtw_adapter *adapter,
 	union recv_frame *precv_frame,
-	struct sta_info**psta )
+	struct sta_info**psta)
 {
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
@@ -1262,7 +1237,6 @@ _func_enter_;
 			|| check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true	)
 		)
 	{
-
 		// filter packets that SA is myself or multicast or broadcast
 		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" SA==myself\n"));
@@ -1291,9 +1265,9 @@ _func_enter_;
 
 
 		// check BSSID
-		if ( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		if (_rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 		     _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
-		     (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) )
+		     (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)))
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,
 				(" ap2sta_data_frame:  compare BSSID fail ; BSSID=%pM\n", pattrib->bssid));
@@ -1301,7 +1275,7 @@ _func_enter_;
 			#ifdef DBG_RX_DROP_FRAME
 			DBG_8192D("DBG_RX_DROP_FRAME %s BSSID=%pM, mybssid=%pM\n",
 				__func__, pattrib->bssid, mybssid);
-			DBG_8192D( "this adapter = %d, buddy adapter = %d\n", adapter->adapter_type, adapter->pbuddy_adapter->adapter_type );
+			DBG_8192D("this adapter = %d, buddy adapter = %d\n", adapter->adapter_type, adapter->pbuddy_adapter->adapter_type);
 			#endif
 
 			if (!bmcast) {
@@ -1339,7 +1313,7 @@ _func_enter_;
 
 	}
 	else if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) &&
-		     (check_fwstate(pmlmepriv, _FW_LINKED) == true) )
+		     (check_fwstate(pmlmepriv, _FW_LINKED) == true))
 	{
 		memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
 		memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
@@ -1393,17 +1367,16 @@ exit:
 _func_exit_;
 
 	return ret;
-
 }
 
 int sta2ap_data_frame(
 	struct rtw_adapter *adapter,
 	union recv_frame *precv_frame,
-	struct sta_info**psta );
+	struct sta_info**psta);
 int sta2ap_data_frame(
 	struct rtw_adapter *adapter,
 	union recv_frame *precv_frame,
-	struct sta_info**psta )
+	struct sta_info**psta)
 {
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
@@ -1465,7 +1438,6 @@ exit:
 _func_exit_;
 
 	return ret;
-
 }
 
 int validate_recv_ctrl_frame(struct rtw_adapter *padapter, union recv_frame *precv_frame);
@@ -1623,7 +1595,6 @@ int validate_recv_ctrl_frame(struct rtw_
 #endif
 
 	return _FAIL;
-
 }
 
 union recv_frame* recvframe_chk_defrag(struct rtw_adapter * padapter, union recv_frame *precv_frame);
@@ -1662,7 +1633,6 @@ int validate_recv_mgnt_frame(struct rtw_
 	mgt_dispatcher(padapter, precv_frame);
 
 	return _SUCCESS;
-
 }
 
 int validate_recv_data_frame(struct rtw_adapter *adapter, union recv_frame *precv_frame)
@@ -1787,7 +1757,6 @@ _func_enter_;
 	}
 
 	if (pattrib->privacy){
-
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("validate_recv_data_frame:pattrib->privacy=%x\n", pattrib->privacy));
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n ^^^^^^^^^^^IS_MCAST(pattrib->ra(0x%02x))=%d^^^^^^^^^^^^^^^6\n", pattrib->ra[0],IS_MCAST(pattrib->ra)));
 
@@ -1918,7 +1887,7 @@ _func_exit_;
 
 //remove the wlanhdr and add the eth_hdr
 
-int wlanhdr_to_ethhdr ( union recv_frame *precvframe)
+int wlanhdr_to_ethhdr (union recv_frame *precvframe)
 {
 	int	rmv_len;
 	u16	eth_type, len;
@@ -1945,7 +1914,7 @@ _func_enter_;
 	//eth_type = (psnap_type[0] << 8) | psnap_type[1];
 	if ((_rtw_memcmp(psnap, rtw_rfc1042_header, SNAP_SIZE) &&
 		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == false) &&
-		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2)==false) )||
+		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2)==false))||
 		//eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
 		 _rtw_memcmp(psnap, rtw_bridge_tunnel_header, SNAP_SIZE)){
 		/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
@@ -1962,7 +1931,7 @@ _func_enter_;
 	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n===pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n\n", pattrib->hdrlen,  pattrib->iv_len));
 
 	memcpy(&eth_type, ptr+rmv_len, 2);
-	eth_type= ntohs((unsigned short )eth_type); //pattrib->ether_type
+	eth_type= ntohs((unsigned short)eth_type); //pattrib->ether_type
 	pattrib->eth_type = eth_type;
 
 	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true))
@@ -1991,7 +1960,6 @@ _func_enter_;
 
 _func_exit_;
 	return ret;
-
 }
 
 //perform defrag
@@ -2207,7 +2175,6 @@ _func_enter_;
 _func_exit_;
 
 	return prtnframe;
-
 }
 
 #define ENDIAN_FREE 1
@@ -2238,7 +2205,6 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 	pdata = prframe->u.hdr.rx_data;
 
 	while (a_len > ETH_HLEN) {
-
 		/* Offset 12 denote 2 mac address */
 #ifdef ENDIAN_FREE
 		//nSubframe_Length = ntohs(*((u16*)(pdata + 12)));
@@ -2250,7 +2216,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 		//ntohs(nSubframe_Length);
 #endif // ENDIAN_FREE
 
-		if ( a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length) ) {
+		if (a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
 			DBG_8192D("nRemain_Length is %d and nSubframe_Length is : %d\n",a_len,nSubframe_Length);
 			goto exit;
 		}
@@ -2320,7 +2286,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 		if (sub_skb->len >= 8 &&
 			((_rtw_memcmp(sub_skb->data, rtw_rfc1042_header, SNAP_SIZE) &&
 			  eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
-			 _rtw_memcmp(sub_skb->data, rtw_bridge_tunnel_header, SNAP_SIZE) )) {
+			 _rtw_memcmp(sub_skb->data, rtw_bridge_tunnel_header, SNAP_SIZE))) {
 			/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
 			skb_pull(sub_skb, SNAP_SIZE);
 			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src, ETH_ALEN);
@@ -2352,7 +2318,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 #endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 
 
-			if ( br_port && (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) )
+			if (br_port && (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true))
 			{
 				int nat25_handle_frame(struct rtw_adapter *priv, struct sk_buff *skb);
 				if (nat25_handle_frame(padapter, sub_skb) == -1) {
@@ -2374,7 +2340,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 			sub_skb->dev = padapter->pnetdev;
 
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
-			if ( (pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1) ) {
+			if ((pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1)) {
 				sub_skb->ip_summed = CHECKSUM_UNNECESSARY;
 			} else {
 				sub_skb->ip_summed = CHECKSUM_NONE;
@@ -2416,7 +2382,7 @@ int check_indicate_seq(struct recv_reord
 	//DbgPrint("enter->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
 
 	// Drop out the packet which SeqNum is smaller than WinStart
-	if ( SN_LESS(seq_num, preorder_ctrl->indicate_seq) )
+	if (SN_LESS(seq_num, preorder_ctrl->indicate_seq))
 	{
 		//RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum));
 		//DbgPrint("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
@@ -2435,7 +2401,7 @@ int check_indicate_seq(struct recv_reord
 	// 1. Incoming SeqNum is equal to WinStart =>Window shift 1
 	// 2. Incoming SeqNum is larger than the WinEnd => Window shift N
 	//
-	if ( SN_EQUAL(seq_num, preorder_ctrl->indicate_seq) )
+	if (SN_EQUAL(seq_num, preorder_ctrl->indicate_seq))
 	{
 		preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1) & 0xFFF;
 		#ifdef DBG_RX_SEQ
@@ -2486,7 +2452,7 @@ int enqueue_reorder_recvframe(struct rec
 		{
 			plist = get_next(plist);
 		}
-		else if ( SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))
+		else if (SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))
 		{
 			//Duplicate entry is found!! Do not insert current entry.
 			//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
@@ -2518,7 +2484,6 @@ int enqueue_reorder_recvframe(struct rec
 
 	//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
 	return true;
-
 }
 
 int recv_indicatepkts_in_order(struct rtw_adapter *padapter, struct recv_reorder_ctrl *preorder_ctrl, int bforced);
@@ -2557,7 +2522,6 @@ int recv_indicatepkts_in_order(struct rt
 	// Check if there is any packet need indicate.
 	while (!rtw_is_list_empty(phead))
 	{
-
 		prframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pattrib = &prframe->u.hdr.attrib;
 
@@ -2635,7 +2599,6 @@ int recv_indicatepkts_in_order(struct rt
 
 	//return true;
 	return bPktInBuf;
-
 }
 
 int recv_indicatepkt_reorder(struct rtw_adapter *padapter, union recv_frame *prframe);
@@ -2657,7 +2620,7 @@ int recv_indicatepkt_reorder(struct rtw_
 			if ((padapter->bDriverStopped == false) &&
 			    (padapter->bSurpriseRemoved == false))
 			{
-				RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@  recv_indicatepkt_reorder -recv_func recv_indicatepkt\n" ));
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@  recv_indicatepkt_reorder -recv_func recv_indicatepkt\n"));
 
 				rtw_recv_indicatepkt(padapter, prframe);
 				return _SUCCESS;
@@ -2728,7 +2691,6 @@ int recv_indicatepkt_reorder(struct rtw_
 	}
 	else
 	{
-
 	}
 
 	spin_lock_bh(&ppending_recvframe_queue->lock);
@@ -2840,7 +2802,7 @@ int process_recv_indicatepkts(struct rtw
 	struct ht_priv	*phtpriv = &pmlmepriv->htpriv;
 
 #ifdef CONFIG_TDLS
-	if ( (phtpriv->ht_option==true) ||
+	if ((phtpriv->ht_option==true) ||
 		((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
 		 (psta->htpriv.ht_option==true) &&
 		 (psta->htpriv.ampdu_enable==true))) //B/G/N Mode
@@ -2877,17 +2839,17 @@ int process_recv_indicatepkts(struct rtw
 			return retval;
 		}
 
-		if ((padapter->bDriverStopped ==false)&&( padapter->bSurpriseRemoved==false))
+		if ((padapter->bDriverStopped ==false)&&(padapter->bSurpriseRemoved==false))
 		{
 			//indicate this recv_frame
-			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("@@@@ process_recv_indicatepkts- recv_func recv_indicatepkt\n" ));
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("@@@@ process_recv_indicatepkts- recv_func recv_indicatepkt\n"));
 			rtw_recv_indicatepkt(padapter, prframe);
 
 
 		}
 		else
 		{
-			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("@@@@ process_recv_indicatepkts- recv_func free_indicatepkt\n" ));
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("@@@@ process_recv_indicatepkts- recv_func free_indicatepkt\n"));
 
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
 			retval = _FAIL;
@@ -2897,7 +2859,6 @@ int process_recv_indicatepkts(struct rtw
 	}
 
 	return retval;
-
 }
 
 int recv_func_prehandle(struct rtw_adapter *padapter, union recv_frame *rframe)
@@ -3042,7 +3003,7 @@ int recv_func_posthandle(struct rtw_adap
 
 		if ((padapter->bDriverStopped == false) && (padapter->bSurpriseRemoved == false))
 		{
-			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@ recv_func: recv_func rtw_recv_indicatepkt\n" ));
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@ recv_func: recv_func rtw_recv_indicatepkt\n"));
 			//indicate this recv_frame
 			ret = rtw_recv_indicatepkt(padapter, prframe);
 			if (ret != _SUCCESS)
@@ -3055,7 +3016,7 @@ int recv_func_posthandle(struct rtw_adap
 		}
 		else
 		{
-			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@  recv_func: rtw_free_recvframe\n" ));
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@  recv_func: rtw_free_recvframe\n"));
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_debug_, ("recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
 			#ifdef DBG_RX_DROP_FRAME
 			DBG_8192D("DBG_RX_DROP_FRAME %s ecv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", __func__,
@@ -3068,7 +3029,6 @@ int recv_func_posthandle(struct rtw_adap
 	}
 	else if (pattrib->amsdu==1)
 	{
-
 		ret = amsdu_to_msdu(padapter, prframe);
 		if (ret != _SUCCESS)
 		{
@@ -3120,7 +3080,6 @@ int recv_func(struct rtw_adapter *padapt
 	ret = recv_func_prehandle(padapter, rframe);
 
 	if (ret == _SUCCESS) {
-
 		/* check if need to enqueue into uc_swdec_pending_queue*/
 		if (check_fwstate(mlmepriv, WIFI_STATION_STATE) &&
 			!IS_MCAST(prxattrib->ra) && prxattrib->encrypt>0 &&
@@ -3198,7 +3157,6 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 		adapter->recvpriv.signal_strength= adapter->recvpriv.signal_strength_dbg;
 		adapter->recvpriv.rssi=(s8)translate_percentage_to_dbm((u8)adapter->recvpriv.signal_strength_dbg);
 	} else {
-
 		if (recvpriv->signal_strength_data.update_req == 0) {// update_req is clear, means we got rx
 			avg_signal_strength = recvpriv->signal_strength_data.avg_val;
 			num_signal_strength = recvpriv->signal_strength_data.total_num;
@@ -3249,6 +3207,5 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 		}
 	}
 	rtw_set_signal_stat_timer(recvpriv);
-
 }
 #endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -102,9 +102,9 @@ static int bcrc32initialized = 0;
 static u32 crc32_table[256];
 
 
-static u8 crc32_reverseBit( u8 data)
+static u8 crc32_reverseBit(u8 data)
 {
-	return( (u8)((data<<7)&0x80) | ((data<<5)&0x40) | ((data<<3)&0x20) | ((data<<1)&0x10) | ((data>>1)&0x08) | ((data>>3)&0x04) | ((data>>5)&0x02) | ((data>>7)&0x01) );
+	return((u8)((data<<7)&0x80) | ((data<<5)&0x40) | ((data<<3)&0x20) | ((data<<1)&0x10) | ((data>>1)&0x08) | ((data>>3)&0x04) | ((data>>5)&0x02) | ((data>>7)&0x01));
 }
 
 static void crc32_init(void)
@@ -230,7 +230,6 @@ _func_enter_;
 	}
 
 _func_exit_;
-
 }
 
 void rtw_wep_decrypt(struct rtw_adapter  *padapter, u8 *precvframe)
@@ -281,18 +280,17 @@ _func_enter_;
 _func_exit_;
 
 	return;
-
 }
 
 //3		=====TKIP related=====
 
-static u32 secmicgetuint32( u8 * p )
+static u32 secmicgetuint32(u8 * p)
 // Convert from Byte[] to Us4Byte32 in a portable way
 {
 	s32 i;
 	u32 res = 0;
 _func_enter_;
-	for ( i=0; i<4; i++ )
+	for (i=0; i<4; i++)
 	{
 		res |= ((u32)(*p++)) << (8*i);
 	}
@@ -300,12 +298,12 @@ _func_exit_;
 	return res;
 }
 
-static void secmicputuint32( u8 * p, u32 val )
+static void secmicputuint32(u8 * p, u32 val)
 // Convert from Us4Byte32 to Byte[] in a portable way
 {
 	long i;
 _func_enter_;
-	for ( i=0; i<4; i++ )
+	for (i=0; i<4; i++)
 	{
 		*p++ = (u8) (val & 0xff);
 		val >>= 8;
@@ -324,34 +322,34 @@ _func_enter_;
 _func_exit_;
 }
 
-void rtw_secmicsetkey(struct mic_data *pmicdata, u8 * key )
+void rtw_secmicsetkey(struct mic_data *pmicdata, u8 * key)
 {
 	// Set the key
 _func_enter_;
-	pmicdata->K0 = secmicgetuint32( key );
-	pmicdata->K1 = secmicgetuint32( key + 4 );
+	pmicdata->K0 = secmicgetuint32(key);
+	pmicdata->K1 = secmicgetuint32(key + 4);
 	// and reset the message
 	secmicclear(pmicdata);
 _func_exit_;
 }
 
-void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b )
+void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b)
 {
 _func_enter_;
 	// Append the byte to our word-sized buffer
 	pmicdata->M |= ((unsigned long)b) << (8*pmicdata->nBytesInM);
 	pmicdata->nBytesInM++;
 	// Process the word if it is full.
-	if ( pmicdata->nBytesInM >= 4 )
+	if (pmicdata->nBytesInM >= 4)
 	{
 		pmicdata->L ^= pmicdata->M;
-		pmicdata->R ^= ROL32( pmicdata->L, 17 );
+		pmicdata->R ^= ROL32(pmicdata->L, 17);
 		pmicdata->L += pmicdata->R;
 		pmicdata->R ^= ((pmicdata->L & 0xff00ff00) >> 8) | ((pmicdata->L & 0x00ff00ff) << 8);
 		pmicdata->L += pmicdata->R;
-		pmicdata->R ^= ROL32( pmicdata->L, 3 );
+		pmicdata->R ^= ROL32(pmicdata->L, 3);
 		pmicdata->L += pmicdata->R;
-		pmicdata->R ^= ROR32( pmicdata->L, 2 );
+		pmicdata->R ^= ROR32(pmicdata->L, 2);
 		pmicdata->L += pmicdata->R;
 		// Clear the buffer
 		pmicdata->M = 0;
@@ -360,35 +358,35 @@ _func_enter_;
 _func_exit_;
 }
 
-void rtw_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nbytes )
+void rtw_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nbytes)
 {
 _func_enter_;
 	// This is simple
-	while ( nbytes > 0 )
+	while (nbytes > 0)
 	{
-		rtw_secmicappendbyte(pmicdata, *src++ );
+		rtw_secmicappendbyte(pmicdata, *src++);
 		nbytes--;
 	}
 _func_exit_;
 }
 
-void rtw_secgetmic(struct mic_data *pmicdata, u8 * dst )
+void rtw_secgetmic(struct mic_data *pmicdata, u8 * dst)
 {
 _func_enter_;
 	// Append the minimum padding
-	rtw_secmicappendbyte(pmicdata, 0x5a );
-	rtw_secmicappendbyte(pmicdata, 0 );
-	rtw_secmicappendbyte(pmicdata, 0 );
-	rtw_secmicappendbyte(pmicdata, 0 );
-	rtw_secmicappendbyte(pmicdata, 0 );
+	rtw_secmicappendbyte(pmicdata, 0x5a);
+	rtw_secmicappendbyte(pmicdata, 0);
+	rtw_secmicappendbyte(pmicdata, 0);
+	rtw_secmicappendbyte(pmicdata, 0);
+	rtw_secmicappendbyte(pmicdata, 0);
 	// and then zeroes until the length is a multiple of 4
-	while ( pmicdata->nBytesInM != 0 )
+	while (pmicdata->nBytesInM != 0)
 	{
-		rtw_secmicappendbyte(pmicdata, 0 );
+		rtw_secmicappendbyte(pmicdata, 0);
 	}
 	// The appendByte function has already computed the result.
-	secmicputuint32( dst, pmicdata->L );
-	secmicputuint32( dst+4, pmicdata->R );
+	secmicputuint32(dst, pmicdata->L);
+	secmicputuint32(dst+4, pmicdata->R);
 	// Reset to the empty message.
 	secmicclear(pmicdata);
 _func_exit_;
@@ -397,7 +395,6 @@ _func_exit_;
 
 void rtw_seccalctkipmic(u8 * key,u8 *header,u8 *data,u32 data_len,u8 *mic_code, u8 pri)
 {
-
 	struct mic_data	micdata;
 	u8 priority[4]={0x0,0x0,0x0,0x0};
 _func_enter_;
@@ -434,9 +431,9 @@ _func_exit_;
 
 /* macros for extraction/creation of unsigned char/unsigned short values  */
 #define RotR1(v16)   ((((v16) >> 1) & 0x7FFF) ^ (((v16) & 1) << 15))
-#define   Lo8(v16)   ((u8)( (v16)       & 0x00FF))
+#define   Lo8(v16)   ((u8)((v16)       & 0x00FF))
 #define   Hi8(v16)   ((u8)(((v16) >> 8) & 0x00FF))
-#define  Lo16(v32)   ((u16)( (v32)       & 0xFFFF))
+#define  Lo16(v32)   ((u16)((v32)       & 0xFFFF))
 #define  Hi16(v32)   ((u16)(((v32) >>16) & 0xFFFF))
 #define  Mk16(hi,lo) ((lo) ^ (((u16)(hi)) << 8))
 
@@ -673,14 +670,13 @@ _func_enter_;
 
 	//4 start to encrypt each fragment
 	if (pattrib->encrypt==_TKIP_){
-
 		if (pattrib->psta)
 		{
 			stainfo = pattrib->psta;
 		}
 		else
 		{
-			stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0] );
+			stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0]);
 		}
 
 		if (stainfo!=NULL){
@@ -743,7 +739,6 @@ _func_enter_;
 	}
 _func_exit_;
 	return res;
-
 }
 
 
@@ -773,10 +768,8 @@ _func_enter_;
 
 	//4 start to decrypt recvframe
 	if (prxattrib->encrypt==_TKIP_){
-
-		stainfo=rtw_get_stainfo(&padapter->stapriv ,&prxattrib->ta[0] );
+		stainfo=rtw_get_stainfo(&padapter->stapriv ,&prxattrib->ta[0]);
 		if (stainfo!=NULL){
-
 			if (IS_MCAST(prxattrib->ra))
 			{
 				if (psecuritypriv->binstallGrpkey==false)
@@ -834,7 +827,6 @@ _func_enter_;
 _func_exit_;
 exit:
 	return res;
-
 }
 
 
@@ -918,7 +910,7 @@ static void next_key(u8 *key, int round)
 static void byte_sub(u8 *in, u8 *out);
 static void shift_row(u8 *in, u8 *out);
 static void mix_column(u8 *in, u8 *out);
-static void add_round_key( u8 *shiftrow_in,
+static void add_round_key(u8 *shiftrow_in,
                     u8 *mcol_in,
                     u8 *block_in,
                     int round,
@@ -1136,7 +1128,7 @@ static void construct_mic_iv(
                         u8 *mpdu,
                         uint payload_length,
                         u8 *pn_vector
-                        )
+                       )
 {
     int i;
 _func_enter_;
@@ -1168,7 +1160,7 @@ static void construct_mic_header1(
                         u8 *mic_header1,
                         int header_length,
                         u8 *mpdu
-                        )
+                       )
 {
 _func_enter_;
     mic_header1[0] = (u8)((header_length - 2) / 256);
@@ -1201,7 +1193,7 @@ static void construct_mic_header2(
                 u8 *mpdu,
                 int a4_exists,
                 int qc_exists
-                )
+               )
 {
     int i;
 _func_enter_;
@@ -1255,7 +1247,7 @@ static void construct_ctr_preload(
                         u8 *mpdu,
                         u8 *pn_vector,
                         int c
-                        )
+                       )
 {
     int i = 0;
 _func_enter_;
@@ -1333,7 +1325,7 @@ _func_enter_;
 	memset((void *)aes_out, 0, 16);
 	memset((void *)padded_buffer, 0, 16);
 
-	if ((hdrlen == WLAN_HDR_A3_LEN )||(hdrlen ==  WLAN_HDR_A3_QOS_LEN))
+	if ((hdrlen == WLAN_HDR_A3_LEN)||(hdrlen ==  WLAN_HDR_A3_QOS_LEN))
 		a4_exists = 0;
 	else
 		a4_exists = 1;
@@ -1345,7 +1337,6 @@ _func_enter_;
 		{
 			qc_exists = 1;
 					if (hdrlen !=  WLAN_HDR_A3_QOS_LEN){
-
 					hdrlen += 2;
 			}
 		}
@@ -1356,7 +1347,6 @@ _func_enter_;
 		(frsubtype == 0x0b))
 		{
 			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN){
-
 					hdrlen += 2;
 			}
 			qc_exists = 1;
@@ -1378,19 +1368,19 @@ _func_enter_;
                         pframe,	 //message,
                         plen,
                         pn_vector
-                        );
+                       );
 
     construct_mic_header1(
                             mic_header1,
                             hdrlen,
                             pframe	//message
-                            );
+                           );
     construct_mic_header2(
                             mic_header2,
                             pframe,	//message,
                             a4_exists,
                             qc_exists
-                            );
+                           );
 
 
 	payload_remainder = plen % 16;
@@ -1525,14 +1515,13 @@ _func_enter_;
 
 	//4 start to encrypt each fragment
 	if ((pattrib->encrypt==_AES_)){
-
 		if (pattrib->psta)
 		{
 			stainfo = pattrib->psta;
 		}
 		else
 		{
-			stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0] );
+			stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0]);
 		}
 
 		if (stainfo!=NULL){
@@ -1550,8 +1539,8 @@ _func_enter_;
 #ifdef CONFIG_TDLS	//swencryption
 			{
 				struct	sta_info		*ptdls_sta;
-				ptdls_sta=rtw_get_stainfo(&padapter->stapriv ,&pattrib->dst[0] );
-				if ((ptdls_sta != NULL) && (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) )
+				ptdls_sta=rtw_get_stainfo(&padapter->stapriv ,&pattrib->dst[0]);
+				if ((ptdls_sta != NULL) && (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 				{
 					DBG_8192D("[%s] for tdls link\n", __func__);
 					prwskey=&ptdls_sta->tpk.tk[0];
@@ -1562,7 +1551,6 @@ _func_enter_;
 			prwskeylen=16;
 
 			for (curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
-
 				if ((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
 
@@ -1630,7 +1618,7 @@ _func_enter_;
 
 	//start to decrypt the payload
 
-	num_blocks = (plen-8) / 16; //(plen including llc, payload_length and mic )
+	num_blocks = (plen-8) / 16; //(plen including llc, payload_length and mic)
 
 	payload_remainder = (plen-8) % 16;
 
@@ -1641,7 +1629,7 @@ _func_enter_;
 	pn_vector[4]  = pframe[hdrlen+6];
 	pn_vector[5]  = pframe[hdrlen+7];
 
-	if ((hdrlen == WLAN_HDR_A3_LEN )||(hdrlen ==  WLAN_HDR_A3_QOS_LEN))
+	if ((hdrlen == WLAN_HDR_A3_LEN)||(hdrlen ==  WLAN_HDR_A3_QOS_LEN))
 		a4_exists = 0;
 	else
 		a4_exists = 1;
@@ -1653,7 +1641,6 @@ _func_enter_;
 		{
 			qc_exists = 1;
 					if (hdrlen !=  WLAN_HDR_A3_QOS_LEN){
-
 					hdrlen += 2;
 			}
 		}
@@ -1664,7 +1651,6 @@ _func_enter_;
 		(frsubtype == 0x0b))
 		{
 			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN){
-
 					hdrlen += 2;
 			}
 			qc_exists = 1;
@@ -1686,7 +1672,7 @@ _func_enter_;
                                 pframe,
                                 pn_vector,
                                 i+1
-                            );
+                           );
 
         aes128k128d(key, ctr_preload, aes_out);
         bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
@@ -1703,7 +1689,7 @@ _func_enter_;
                                 pframe,
                                 pn_vector,
                                 num_blocks+1
-                            );
+                           );
 
         for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
         for (j = 0; j < payload_remainder; j++)
@@ -1736,19 +1722,19 @@ _func_enter_;
                         message,
                         plen-8,
                         pn_vector
-                        );
+                       );
 
     construct_mic_header1(
                             mic_header1,
                             hdrlen,
                             message
-                            );
+                           );
     construct_mic_header2(
                             mic_header2,
                             message,
                             a4_exists,
                             qc_exists
-                            );
+                           );
 
 
 	payload_remainder = (plen-8) % 16;
@@ -1891,8 +1877,7 @@ _func_enter_;
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
 	//4 start to encrypt each fragment
 	if ((prxattrib->encrypt==_AES_)){
-
-		stainfo=rtw_get_stainfo(&padapter->stapriv ,&prxattrib->ta[0] );
+		stainfo=rtw_get_stainfo(&padapter->stapriv ,&prxattrib->ta[0]);
 		if (stainfo!=NULL){
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_decrypt: stainfo!=NULL!!!\n"));
 
@@ -2430,7 +2415,7 @@ static void rijndaelKeySetupEnc(u32 rk[/
 	int i;
 	u32 temp;
 
-	rk[0] = GETU32(cipherKey     );
+	rk[0] = GETU32(cipherKey    );
 	rk[1] = GETU32(cipherKey +  4);
 	rk[2] = GETU32(cipherKey +  8);
 	rk[3] = GETU32(cipherKey + 12);
@@ -2458,7 +2443,7 @@ static void rijndaelEncrypt(u32 rk[/*44*
 	 * map byte array block to cipher state
 	 * and add initial round key:
 	 */
-	s0 = GETU32(pt     ) ^ rk[0];
+	s0 = GETU32(pt    ) ^ rk[0];
 	s1 = GETU32(pt +  4) ^ rk[1];
 	s2 = GETU32(pt +  8) ^ rk[2];
 	s3 = GETU32(pt + 12) ^ rk[3];
@@ -2687,7 +2672,6 @@ void wpa_tdls_generate_tpk(struct rtw_ad
 
 	sha256_prf(key_input, SHA256_MAC_LEN, "TDLS PMK", data, sizeof(data), (u8 *) &psta->tpk, sizeof(psta->tpk));
 
-
 }
 
 /**
@@ -2745,7 +2729,6 @@ int wpa_tdls_ftie_mic(u8 *kck, u8 trans_
 	ret = omac1_aes_128(kck, buf, pos - buf, mic);
 	kfree(buf);
 	return ret;
-
 }
 
 int tdls_verify_mic(u8 *kck, u8 trans_seq,
@@ -2805,9 +2788,8 @@ int tdls_verify_mic(u8 *kck, u8 trans_se
 	}
 
 	//Invalid MIC
-	DBG_8192D( "[%s] Invalid MIC\n", __func__);
+	DBG_8192D("[%s] Invalid MIC\n", __func__);
 	return 0;
-
 }
 #endif //CONFIG_TDLS
 
@@ -2825,5 +2807,4 @@ _func_enter_;
 	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler padapter->securitypriv.busetkipkey=%d^^^\n",padapter->securitypriv.busetkipkey));
 
 _func_exit_;
-
 }
--- a/drivers/staging/rtl8192du/core/rtw_sreset.c
+++ b/drivers/staging/rtl8192du/core/rtw_sreset.c
@@ -66,7 +66,7 @@ u8 sreset_get_wifi_status(_adapter *pada
 	if (WIFI_STATUS_SUCCESS !=psrtpriv->Wifi_Error_Status)
 	{
 		DBG_8192C("==>%s error_status(0x%x)\n",__func__,psrtpriv->Wifi_Error_Status);
-		status = (psrtpriv->Wifi_Error_Status &( ~(USB_READ_PORT_FAIL|USB_WRITE_PORT_FAIL)));
+		status = (psrtpriv->Wifi_Error_Status &(~(USB_READ_PORT_FAIL|USB_WRITE_PORT_FAIL)));
 	}
 	DBG_8192C("==> %s wifi_status(0x%x)\n",__func__,status);
 
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -29,7 +29,6 @@
 
 void _rtw_init_stainfo(struct sta_info *psta)
 {
-
 _func_enter_;
 
 	memset((u8 *)psta, 0, sizeof (struct sta_info));
@@ -73,7 +72,6 @@ _func_enter_;
 #endif	// CONFIG_AP_MODE
 
 _func_exit_;
-
 }
 
 u32	_rtw_init_sta_priv(struct	sta_priv *pstapriv)
@@ -89,7 +87,7 @@ _func_enter_;
 		return _FAIL;
 
 	pstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -
-		((SIZE_PTR)(pstapriv->pallocated_stainfo_buf ) & 3);
+		((SIZE_PTR)(pstapriv->pallocated_stainfo_buf) & 3);
 
 	_rtw_init_queue(&pstapriv->free_sta_queue);
 
@@ -142,7 +140,6 @@ _func_enter_;
 _func_exit_;
 
 	return _SUCCESS;
-
 }
 
 inline int rtw_stainfo_offset(struct sta_priv *stapriv, struct sta_info *sta)
@@ -186,7 +183,6 @@ _func_enter_;
 	_rtw_spinlock_free(&(psta_recvpriv->defrag_q.lock));
 
 _func_exit_;
-
 }
 
 void rtw_mfree_stainfo(struct sta_info *psta)
@@ -204,7 +200,7 @@ _func_exit_;
 
 
 // this function is used to free the memory of lock || sema for all stainfos
-void rtw_mfree_all_stainfo(struct sta_priv *pstapriv )
+void rtw_mfree_all_stainfo(struct sta_priv *pstapriv)
 {
 	struct list_head *plist, *phead;
 	struct sta_info *psta = NULL;
@@ -227,7 +223,6 @@ _func_enter_;
 	spin_unlock_bh(&pstapriv->sta_hash_lock);
 
 _func_exit_;
-
 }
 
 void rtw_mfree_sta_priv_lock(struct	sta_priv *pstapriv)
@@ -249,7 +244,6 @@ void rtw_mfree_sta_priv_lock(struct	sta_
 	_rtw_spinlock_free(&pstapriv->auth_list_lock);
 	_rtw_spinlock_free(&pacl_list->acl_node_q.lock);
 #endif
-
 }
 
 u32	_rtw_free_sta_priv(struct	sta_priv *pstapriv)
@@ -261,7 +255,6 @@ u32	_rtw_free_sta_priv(struct	sta_priv *
 
 _func_enter_;
 	if (pstapriv){
-
 		/*	delete all reordering_ctrl_timer		*/
 		spin_lock_bh(&pstapriv->sta_hash_lock);
 		for (index = 0; index < NUM_STA; index++)
@@ -358,8 +351,8 @@ _func_enter_;
 // In this case, this packet will be dropped by recv_decache function if we use the 0x00 as the default value for tid_rxseq variable.
 // So, we initialize the tid_rxseq variable as the 0xffff.
 
-		for ( i = 0; i < 16; i++ )
-                     memcpy( &psta->sta_recvpriv.rxcache.tid_rxseq[ i ], &wRxSeqInitialValue, 2 );
+		for (i = 0; i < 16; i++)
+                     memcpy(&psta->sta_recvpriv.rxcache.tid_rxseq[ i ], &wRxSeqInitialValue, 2);
 
 		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_info_,("alloc number_%d stainfo  with hwaddr = %x %x %x %x %x %x \n",
 		pstapriv->asoc_sta_count , hwaddr[0], hwaddr[1], hwaddr[2],hwaddr[3],hwaddr[4],hwaddr[5]));
@@ -414,7 +407,6 @@ _func_exit_;
 
 	return psta;
 
-
 }
 
 
@@ -444,19 +436,19 @@ _func_enter_;
 	rtw_free_xmitframe_queue(pxmitpriv, &psta->sleep_q);
 	psta->sleepq_len = 0;
 
-	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);
+	rtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);
 
 	rtw_list_delete(&(pstaxmitpriv->vo_q.tx_pending));
 
-	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);
+	rtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);
 
 	rtw_list_delete(&(pstaxmitpriv->vi_q.tx_pending));
 
-	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);
+	rtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);
 
 	rtw_list_delete(&(pstaxmitpriv->bk_q.tx_pending));
 
-	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->be_q.sta_pending);
+	rtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->be_q.sta_pending);
 
 	rtw_list_delete(&(pstaxmitpriv->be_q.tx_pending));
 
@@ -568,7 +560,6 @@ exit:
 _func_exit_;
 
 	return _SUCCESS;
-
 }
 
 // free all stainfo which in sta_hash[all]
@@ -578,7 +569,7 @@ void rtw_free_all_stainfo(struct rtw_ada
 	s32	index;
 	struct sta_info *psta = NULL;
 	struct	sta_priv *pstapriv = &padapter->stapriv;
-	struct sta_info* pbcmc_stainfo =rtw_get_bcmc_stainfo( padapter);
+	struct sta_info* pbcmc_stainfo =rtw_get_bcmc_stainfo(padapter);
 
 _func_enter_;
 
@@ -609,13 +600,11 @@ _func_enter_;
 exit:
 
 _func_exit_;
-
 }
 
 /* any station allocated can be searched by hash list */
 struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
 {
-
 	struct list_head *plist, *phead;
 	struct sta_info *psta = NULL;
 	u32	index;
@@ -642,7 +631,6 @@ _func_enter_;
 
 	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
-
 		psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
 		if ((_rtw_memcmp(psta->hwaddr, addr, ETH_ALEN))== true)
@@ -656,12 +644,10 @@ _func_enter_;
 	spin_unlock_bh(&pstapriv->sta_hash_lock);
 _func_exit_;
 	return psta;
-
 }
 
 u32 rtw_init_bcmc_stainfo(struct rtw_adapter* padapter)
 {
-
 	struct sta_info		*psta;
 	struct tx_servq	*ptxservq;
 	u32 res=_SUCCESS;
@@ -687,7 +673,6 @@ _func_enter_;
 exit:
 _func_exit_;
 	return _SUCCESS;
-
 }
 
 
@@ -700,7 +685,6 @@ _func_enter_;
 	 psta = rtw_get_stainfo(pstapriv, bc_addr);
 _func_exit_;
 	return psta;
-
 }
 
 u8 rtw_access_ctrl(struct rtw_adapter *padapter, u8 *mac_addr)
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ b/drivers/staging/rtl8192du/core/rtw_tdls.c
@@ -63,7 +63,6 @@ int rtw_init_tdls_info(_adapter* padapte
 	_rtw_spinlock_init(&ptdlsinfo->hdl_lock);
 
 	return res;
-
 }
 
 void rtw_free_tdls_info(struct tdls_info *ptdlsinfo)
@@ -71,8 +70,7 @@ void rtw_free_tdls_info(struct tdls_info
 	_rtw_spinlock_free(&ptdlsinfo->cmd_lock);
 	_rtw_spinlock_free(&ptdlsinfo->hdl_lock);
 
-	memset(ptdlsinfo, 0, sizeof(struct tdls_info) );
-
+	memset(ptdlsinfo, 0, sizeof(struct tdls_info));
 }
 
 void issue_nulldata_to_TDLS_peer_STA(_adapter *padapter, struct sta_info *ptdls_sta, unsigned int power_mode)
@@ -130,7 +128,6 @@ void issue_nulldata_to_TDLS_peer_STA(_ad
 
 s32 update_tdls_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
 {
-
 	struct sta_info *psta = NULL;
 	struct sta_priv		*pstapriv = &padapter->stapriv;
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
@@ -154,7 +151,7 @@ s32 update_tdls_attrib(_adapter *padapte
 
 	pattrib->ack_policy = 0;
 	// get ether_hdr_len
-	pattrib->pkt_hdrlen = ETH_HLEN;//(pattrib->ether_type == 0x8100) ? (14 + 4 ): 14; //vlan tag
+	pattrib->pkt_hdrlen = ETH_HLEN;//(pattrib->ether_type == 0x8100) ? (14 + 4): 14; //vlan tag
 
 	if (pqospriv->qos_option &&  psta->qos_option) {
 		pattrib->priority = 1;	//tdls management frame should be AC_BK
@@ -254,10 +251,10 @@ void free_tdls_sta(_adapter *padapter, s
 	if (ptdlsinfo->sta_cnt != 0)
 		ptdlsinfo->sta_cnt--;
 	spin_unlock_bh(&(pstapriv->sta_hash_lock));
-	if ( ptdlsinfo->sta_cnt < (NUM_STA - 2) )	// -2: AP + BC/MC sta
+	if (ptdlsinfo->sta_cnt < (NUM_STA - 2))	// -2: AP + BC/MC sta
 	{
 		ptdlsinfo->sta_maximum = false;
-		memset( &ptdlsinfo->ss_record, 0x00, sizeof(struct tdls_ss_record) );
+		memset(&ptdlsinfo->ss_record, 0x00, sizeof(struct tdls_ss_record));
 	}
 	//ready to clear cam
 	if (ptdls_sta->mac_id!=0){
@@ -273,7 +270,6 @@ void free_tdls_sta(_adapter *padapter, s
 		DBG_871X("Remain tdls sta:%02x\n", ptdlsinfo->sta_cnt);
 
 	rtw_free_stainfo(padapter,  ptdls_sta);
-
 }
 
 // cam entry will be the same as mac_id
@@ -282,7 +278,7 @@ void rtw_tdls_set_mac_id(struct tdls_inf
 	if (ptdls_sta->mac_id==0)
 	{
 		ptdls_sta->mac_id = ptdlsinfo->macid_index;
-		if ( (++ptdlsinfo->macid_index) > (NUM_STA -2) )
+		if ((++ptdlsinfo->macid_index) > (NUM_STA -2))
 			ptdlsinfo->macid_index= TDLS_INI_MACID_ENTRY;
 	}
 }
@@ -301,7 +297,7 @@ void rtw_tdls_process_ht_cap(_adapter *a
 {
 	/* save HT capabilities in the sta object */
 	memset(&ptdls_sta->htpriv.ht_cap, 0, sizeof(struct rtw_ieee80211_ht_cap));
-	if (data && Length >= sizeof(struct rtw_ieee80211_ht_cap) )
+	if (data && Length >= sizeof(struct rtw_ieee80211_ht_cap))
 	{
 		ptdls_sta->flags |= WLAN_STA_HT;
 
@@ -392,7 +388,7 @@ u8 *rtw_tdls_set_sup_ch(struct mlme_ext_
 {
 	u8 sup_ch[ 30 * 2 ] = { 0x00 }, sup_ch_idx = 0, idx_5g = 2;	//For supported channel
 	do{
-		if ( pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14 )
+		if (pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14)
 		{
 			sup_ch[0] = 1;	//First channel number
 			sup_ch[1] = pmlmeext->channel_set[sup_ch_idx].ChannelNum;	//Number of channel
@@ -405,7 +401,7 @@ u8 *rtw_tdls_set_sup_ch(struct mlme_ext_
 
 		sup_ch_idx++;
 	}
-	while ( pmlmeext->channel_set[sup_ch_idx].ChannelNum != 0 );
+	while (pmlmeext->channel_set[sup_ch_idx].ChannelNum != 0);
 	return(rtw_set_ie(pframe, _SUPPORTED_CH_IE_, idx_5g, sup_ch, &(pattrib->pktlen)));
 }
 
@@ -419,33 +415,33 @@ void rtw_tdls_process_wfd_ie(struct tdls
 	//
 
 	wfd_offset = 0;
-	wfd_offset = rtw_get_wfd_ie( ptr + wfd_offset, length - wfd_offset, wfd_ie, &wfd_ielen );
-	while ( wfd_offset )
+	wfd_offset = rtw_get_wfd_ie(ptr + wfd_offset, length - wfd_offset, wfd_ie, &wfd_ielen);
+	while (wfd_offset)
 	{
 		u8	attr_content[ 10 ] = { 0x00 };
 		u32	attr_contentlen = 0;
 		int	i;
 
-		DBG_871X( "[%s] WFD IE Found!!\n", __func__ );
-		rtw_get_wfd_attr_content( wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
-		if ( attr_contentlen )
+		DBG_871X("[%s] WFD IE Found!!\n", __func__);
+		rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
+		if (attr_contentlen)
 		{
-			ptdlsinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16( attr_content + 2 );
-			DBG_871X( "[%s] Peer PORT NUM = %d\n", __func__, ptdlsinfo->wfd_info->peer_rtsp_ctrlport );
+			ptdlsinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16(attr_content + 2);
+			DBG_871X("[%s] Peer PORT NUM = %d\n", __func__, ptdlsinfo->wfd_info->peer_rtsp_ctrlport);
 		}
 
-		memset( attr_content, 0x00, 10);
+		memset(attr_content, 0x00, 10);
 		attr_contentlen = 0;
-		rtw_get_wfd_attr_content( wfd_ie, wfd_ielen, WFD_ATTR_LOCAL_IP_ADDR, attr_content, &attr_contentlen);
-		if ( attr_contentlen )
+		rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_LOCAL_IP_ADDR, attr_content, &attr_contentlen);
+		if (attr_contentlen)
 		{
-			memcpy(ptdlsinfo->wfd_info->peer_ip_address, ( attr_content + 1 ), 4);
-			DBG_871X( "[%s] Peer IP = %02u.%02u.%02u.%02u\n", __func__,
+			memcpy(ptdlsinfo->wfd_info->peer_ip_address, (attr_content + 1), 4);
+			DBG_871X("[%s] Peer IP = %02u.%02u.%02u.%02u\n", __func__,
 				ptdlsinfo->wfd_info->peer_ip_address[0], ptdlsinfo->wfd_info->peer_ip_address[1],
 				ptdlsinfo->wfd_info->peer_ip_address[2], ptdlsinfo->wfd_info->peer_ip_address[3]
 				);
 		}
-		wfd_offset = rtw_get_wfd_ie( ptr + wfd_offset, length - wfd_offset, wfd_ie, &wfd_ielen );
+		wfd_offset = rtw_get_wfd_ie(ptr + wfd_offset, length - wfd_offset, wfd_ie, &wfd_ielen);
 	}
 }
 
@@ -582,7 +578,7 @@ void issue_tdls_setup_req(_adapter *pada
 			if (!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 				ptdlsinfo->sta_cnt++;
 			spin_unlock_bh(&(pstapriv->sta_hash_lock));
-			if ( ptdlsinfo->sta_cnt == (NUM_STA - 2) )	// -2: AP + BC/MC sta
+			if (ptdlsinfo->sta_cnt == (NUM_STA - 2))	// -2: AP + BC/MC sta
 			{
 				ptdlsinfo->sta_maximum  = true;
 			}
@@ -601,11 +597,11 @@ void issue_tdls_setup_req(_adapter *pada
 		ptdls_sta->dialog = dialogtoken;
 		dialogtoken = (dialogtoken+1)%256;
 		ptdls_sta->TDLS_PeerKey_Lifetime = timeout_interval;
-		_set_timer( &ptdls_sta->handshake_timer, TDLS_HANDSHAKE_TIME );
+		_set_timer(&ptdls_sta->handshake_timer, TDLS_HANDSHAKE_TIME);
 	}
 
 	pattrib->qsel=pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_SETUP_REQUEST) !=_SUCCESS ){
+	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_SETUP_REQUEST) !=_SUCCESS){
 		rtw_free_xmitbuf(pxmitpriv,pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
 		goto exit;
@@ -665,14 +661,14 @@ void issue_tdls_teardown(_adapter *padap
 		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
 	}
 
-	if ( ptdls_sta->timer_flag == 1 )
+	if (ptdls_sta->timer_flag == 1)
 	{
 		spin_lock_bh(&(padapter->tdlsinfo.hdl_lock));
 		ptdls_sta->timer_flag = 2;
 		spin_unlock_bh(&(padapter->tdlsinfo.hdl_lock));
 	}
 	else
-		rtw_tdls_cmd(padapter, mac_addr, TDLS_FREE_STA );
+		rtw_tdls_cmd(padapter, mac_addr, TDLS_FREE_STA);
 
 
 exit:
@@ -764,7 +760,6 @@ void issue_tdls_setup_rsp(_adapter *pada
 exit:
 
 	return;
-
 }
 
 void issue_tdls_setup_cfm(_adapter *padapter, union recv_frame *precv_frame)
@@ -808,7 +803,6 @@ void issue_tdls_setup_cfm(_adapter *pada
 exit:
 
 	return;
-
 }
 
 //TDLS Discovery Response frame is a management action frame
@@ -943,7 +937,7 @@ void issue_tdls_ch_switch_req(_adapter *
 	update_tdls_attrib(padapter, pattrib);
 
 	pattrib->qsel=pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_REQUEST) !=_SUCCESS ){
+	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_REQUEST) !=_SUCCESS){
 		rtw_free_xmitbuf(pxmitpriv,pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
 		goto exit;
@@ -984,7 +978,7 @@ void issue_tdls_ch_switch_rsp(_adapter *
 	update_tdls_attrib(padapter, pattrib);
 
 	pattrib->qsel=pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_RESPONSE) !=_SUCCESS ){
+	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_RESPONSE) !=_SUCCESS){
 		rtw_free_xmitbuf(pxmitpriv,pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
 		goto exit;
@@ -1019,16 +1013,16 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, u
 		ptdls_sta->tdls_sta_state |= TDLS_ALIVE_STATE;
 
 		//Record the tdls sta with lowest signal strength
-		if ( (ptdlsinfo->sta_maximum == true) && (ptdls_sta->alive_count >= 1) )
+		if ((ptdlsinfo->sta_maximum == true) && (ptdls_sta->alive_count >= 1))
 		{
-			if ( _rtw_memcmp(ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN) )
+			if (_rtw_memcmp(ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN))
 			{
 				memcpy(ptdlsinfo->ss_record.macaddr, psa, ETH_ALEN);
 				ptdlsinfo->ss_record.RxPWDBAll = pattrib->RxPWDBAll;
 			}
 			else
 			{
-				if ( ptdlsinfo->ss_record.RxPWDBAll < pattrib->RxPWDBAll )
+				if (ptdlsinfo->ss_record.RxPWDBAll < pattrib->RxPWDBAll)
 				{
 					memcpy(ptdlsinfo->ss_record.macaddr, psa, ETH_ALEN);
 					ptdlsinfo->ss_record.RxPWDBAll = pattrib->RxPWDBAll;
@@ -1039,16 +1033,16 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, u
 	}
 	else
 	{
-		if ( ptdlsinfo->sta_maximum == true)
+		if (ptdlsinfo->sta_maximum == true)
 		{
-			if ( _rtw_memcmp( ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN ) )
+			if (_rtw_memcmp(ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN))
 			{
 				//All traffics are busy, do not set up another direct link.
 				return _FAIL;
 			}
 			else
 			{
-				if ( pattrib->RxPWDBAll > ptdlsinfo->ss_record.RxPWDBAll )
+				if (pattrib->RxPWDBAll > ptdlsinfo->ss_record.RxPWDBAll)
 				{
 					issue_tdls_teardown(adapter, ptdlsinfo->ss_record.macaddr);
 				}
@@ -1061,7 +1055,7 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, u
 
 		rtw_hal_get_def_var(adapter, HAL_DEF_UNDERCORATEDSMOOTHEDPWDB, &UndecoratedSmoothedPWDB);
 
-		if ( pattrib->RxPWDBAll + TDLS_SIGNAL_THRESH >= UndecoratedSmoothedPWDB);
+		if (pattrib->RxPWDBAll + TDLS_SIGNAL_THRESH >= UndecoratedSmoothedPWDB);
 		{
 			DBG_871X("pattrib->RxPWDBAll=%d, pdmpriv->UndecoratedSmoothedPWDB=%d\n", pattrib->RxPWDBAll, UndecoratedSmoothedPWDB);
 			issue_tdls_setup_req(adapter, psa);
@@ -1150,7 +1144,6 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 
 		//parsing information element
 		for (j=FIXED_IE; j<parsing_length;){
-
 			pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
 			switch (pIE->ElementID)
@@ -1178,7 +1171,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 						ppairwise_cipher=prsnie+10;
 						memcpy(&pairwise_count, (u16*)(ppairwise_cipher-2), 1);
 						for (k=0;k<pairwise_count;k++){
-							if (_rtw_memcmp( ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==true)
+							if (_rtw_memcmp(ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==true)
 								ccmp_have=1;
 						}
 						if (ccmp_have==0){
@@ -1227,7 +1220,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 
 		//check status code
 		//if responder STA has/hasn't security on AP, but request hasn't/has RSNIE, it should reject
-		if (ptdls_sta->stat_code == 0 )
+		if (ptdls_sta->stat_code == 0)
 		{
 			if (rsnie_have && (prx_pkt_attrib->encrypt==0)){
 				//security disabled
@@ -1240,7 +1233,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 #ifdef CONFIG_WFD
 			//WFD test plan version 0.18.2 test item 5.1.5
 			//SoUT does not use TDLS if AP uses weak security
-			if ( adapter->wdinfo.wfd_tdls_enable )
+			if (adapter->wdinfo.wfd_tdls_enable)
 			{
 				if (rsnie_have && (prx_pkt_attrib->encrypt != _AES_))
 				{
@@ -1259,7 +1252,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 		if (!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 			ptdlsinfo->sta_cnt++;
 		spin_unlock_bh(&(pstapriv->sta_hash_lock));
-		if ( ptdlsinfo->sta_cnt == (NUM_STA - 2) )	// -2: AP + BC/MC sta
+		if (ptdlsinfo->sta_cnt == (NUM_STA - 2))	// -2: AP + BC/MC sta
 		{
 			ptdlsinfo->sta_maximum = true;
 		}
@@ -1278,7 +1271,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 
 	if (ptdls_sta->stat_code==0)
 	{
-		_set_timer( &ptdls_sta->handshake_timer, TDLS_HANDSHAKE_TIME);
+		_set_timer(&ptdls_sta->handshake_timer, TDLS_HANDSHAKE_TIME);
 	}
 	else		//status code!=0 ; setup unsuccess
 	{
@@ -1311,7 +1304,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 	psa = get_sa(ptr);
 	ptdls_sta = rtw_get_stainfo(pstapriv, psa);
 
-	if ( NULL == ptdls_sta )
+	if (NULL == ptdls_sta)
 	{
 		return _FAIL;
 	}
@@ -1330,7 +1323,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 
 	if (stat_code!=0)
 	{
-		DBG_871X( "[%s] status_code = %d, free_tdls_sta\n", __func__, stat_code );
+		DBG_871X("[%s] status_code = %d, free_tdls_sta\n", __func__, stat_code);
 		free_tdls_sta(adapter, ptdls_sta);
 		return _FAIL;
 	}
@@ -1365,7 +1358,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 				ppairwise_cipher=prsnie+10;
 				memcpy(&pairwise_count, (u16*)(ppairwise_cipher-2), 2);
 				for (k=0;k<pairwise_count;k++){
-					if (_rtw_memcmp( ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==true)
+					if (_rtw_memcmp(ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==true)
 						verify_ccmp=1;
 				}
 			case _EXT_CAP_IE_:
@@ -1440,12 +1433,12 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 	{
 		ptdlsinfo->setup_state = TDLS_LINKED_STATE;
 
-		if ( ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE )
+		if (ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE)
 		{
 			ptdls_sta->tdls_sta_state |= TDLS_LINKED_STATE;
-			_cancel_timer_ex( &ptdls_sta->handshake_timer);
+			_cancel_timer_ex(&ptdls_sta->handshake_timer);
 #ifdef CONFIG_TDLS_AUTOCHECKALIVE
-			_set_timer( &ptdls_sta->alive_timer1, TDLS_ALIVE_TIMER_PH1);
+			_set_timer(&ptdls_sta->alive_timer1, TDLS_ALIVE_TIMER_PH1);
 #endif //CONFIG_TDLS_AUTOSETUP
 		}
 
@@ -1461,7 +1454,6 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 	}
 
 	return _FAIL;
-
 }
 
 int On_TDLS_Setup_Cfm(_adapter *adapter, union recv_frame *precv_frame)
@@ -1494,7 +1486,7 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 	memcpy(&stat_code, ptr+2, 2);
 
 	if (stat_code!=0){
-		DBG_871X( "[%s] stat_code = %d\n, free_tdls_sta", __func__, stat_code );
+		DBG_871X("[%s] stat_code = %d\n, free_tdls_sta", __func__, stat_code);
 		free_tdls_sta(adapter, ptdls_sta);
 		return _FAIL;
 	}
@@ -1502,7 +1494,6 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 	if (prx_pkt_attrib->encrypt){
 		//parsing information element
 		for (j=FIXED_IE; j<parsing_length;){
-
 			pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
 			switch (pIE->ElementID)
@@ -1540,12 +1531,12 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 	}
 
 	ptdlsinfo->setup_state = TDLS_LINKED_STATE;
-	if ( ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE )
+	if (ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE)
 	{
 		ptdls_sta->tdls_sta_state|=TDLS_LINKED_STATE;
-		_cancel_timer_ex( &ptdls_sta->handshake_timer);
+		_cancel_timer_ex(&ptdls_sta->handshake_timer);
 #ifdef CONFIG_TDLS_AUTOCHECKALIVE
-		_set_timer( &ptdls_sta->alive_timer1, TDLS_ALIVE_TIMER_PH1);
+		_set_timer(&ptdls_sta->alive_timer1, TDLS_ALIVE_TIMER_PH1);
 #endif //CONFIG_TDLS_AUTOCHECKALIVE
 	}
 
@@ -1555,7 +1546,6 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 	rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_WRCR);
 
 	return _FAIL;
-
 }
 
 int On_TDLS_Dis_Req(_adapter *adapter, union recv_frame *precv_frame)
@@ -1583,7 +1573,6 @@ int On_TDLS_Dis_Req(_adapter *adapter, u
 
 	//parsing information element
 	for (j=FIXED_IE; j<parsing_length;){
-
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
 		switch (pIE->ElementID)
@@ -1595,7 +1584,7 @@ int On_TDLS_Dis_Req(_adapter *adapter, u
 					goto exit;
 				}
 				dst = pIE->data + 12;
-				if ( (MacAddr_isBcst(dst) == false) && (_rtw_memcmp(myid(&(adapter->eeprompriv)), dst, 6) == false) )
+				if ((MacAddr_isBcst(dst) == false) && (_rtw_memcmp(myid(&(adapter->eeprompriv)), dst, 6) == false))
 				{
 					goto exit;
 				}
@@ -1610,12 +1599,11 @@ int On_TDLS_Dis_Req(_adapter *adapter, u
 
 	//check frame contents
 
-	issue_tdls_dis_rsp(adapter, precv_frame, *(pdialog) );
+	issue_tdls_dis_rsp(adapter, precv_frame, *(pdialog));
 
 exit:
 
 	return _FAIL;
-
 }
 
 int On_TDLS_Teardown(_adapter *adapter, union recv_frame *precv_frame)
@@ -1639,14 +1627,12 @@ int On_TDLS_Teardown(_adapter *adapter,
 	}
 
 	return _FAIL;
-
 }
 
 u8 TDLS_check_ch_state(uint state){
 	if (	(state & TDLS_CH_SWITCH_ON_STATE) &&
 		(state & TDLS_AT_OFF_CH_STATE) &&
-		(state & TDLS_PEER_AT_OFF_STATE) ){
-
+		(state & TDLS_PEER_AT_OFF_STATE)){
 		if (state & TDLS_PEER_SLEEP_STATE)
 			return 2;	//U-APSD + ch. switch
 		else
@@ -1671,7 +1657,7 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 
 	//receive peer traffic response frame, sleeping STA wakes up
 	//ptdls_sta->tdls_sta_state &= ~(TDLS_PEER_SLEEP_STATE);
-	process_wmmps_data( adapter, precv_frame);
+	process_wmmps_data(adapter, precv_frame);
 
 	// if noticed peer STA wakes up by receiving peer traffic response
 	// and we want to do channel swtiching, then we will transmit channel switch request first
@@ -1780,7 +1766,6 @@ int On_TDLS_Ch_Switch_Req(_adapter *adap
 
 	//parsing information element
 	for (j=FIXED_IE; j<parsing_length;){
-
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
 		switch (pIE->ElementID)
@@ -1841,7 +1826,7 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 
 	//if channel switch is running and receiving Unsolicited TDLS Channel Switch Response,
 	//it will go back to base channel and terminate this channel switch procedure
-	if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE ){
+	if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE){
 		if (pmlmeext->cur_channel==ptdls_sta->off_ch){
 			DBG_871X("back to base channel %x\n", pmlmeext->cur_channel);
 			ptdls_sta->option=7;
@@ -1875,7 +1860,6 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 
 	//parsing information element
 	for (j=FIXED_IE; j<parsing_length;){
-
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
 		switch (pIE->ElementID)
@@ -1910,7 +1894,7 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 }
 
 #ifdef CONFIG_WFD
-void wfd_ie_tdls(_adapter * padapter, u8 *pframe, u32 *pktlen )
+void wfd_ie_tdls(_adapter * padapter, u8 *pframe, u32 *pktlen)
 {
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info	*pwfd_info = padapter->tdlsinfo.wfd_info;
@@ -1927,8 +1911,8 @@ void wfd_ie_tdls(_adapter * padapter, u8
 	//	Commented by Albert 20110825
 	//	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes
 	//	1. WFD Device Information
-	//	2. Associated BSSID ( Optional )
-	//	3. Local IP Adress ( Optional )
+	//	2. Associated BSSID (Optional)
+	//	3. Local IP Adress (Optional)
 
 	//	WFD Device Information ATTR
 	//	Type:
@@ -1941,7 +1925,7 @@ void wfd_ie_tdls(_adapter * padapter, u8
 
 	//	Value1:
 	//	WFD device information
-	//	WFD primary sink + available for WFD session + Preferred TDLS + WSD ( WFD Service Discovery )
+	//	WFD primary sink + available for WFD session + Preferred TDLS + WSD (WFD Service Discovery)
 	RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL
 								| WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_WSD);
 	wfdielen += 2;
@@ -1949,7 +1933,7 @@ void wfd_ie_tdls(_adapter * padapter, u8
 	//	Value2:
 	//	Session Management Control Port
 	//	Default TCP port for RTSP messages is 554
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport );
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
 	//	Value3:
@@ -1969,13 +1953,13 @@ void wfd_ie_tdls(_adapter * padapter, u8
 
 	//	Value:
 	//	Associated BSSID
-	if ( check_fwstate( pmlmepriv, _FW_LINKED) == true )
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		memcpy( wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 	}
 	else
 	{
-		memset( wfdie + wfdielen, 0x00, ETH_ALEN );
+		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
 	//	Local IP Address ATTR
@@ -1991,11 +1975,10 @@ void wfd_ie_tdls(_adapter * padapter, u8
 	wfdie[ wfdielen++ ] = 0x01;
 
 	//	IPv4 Address
-	memcpy( wfdie + wfdielen, pwfd_info->ip_address, 4 );
+	memcpy(wfdie + wfdielen, pwfd_info->ip_address, 4);
 	wfdielen += 4;
 
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, pktlen);
-
 }
 #endif //CONFIG_WFD
 
@@ -2005,7 +1988,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	struct mlme_ext_info	*pmlmeinfo = &pmlmeext->mlmext_info;
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
-	struct sta_info *ptdls_sta=rtw_get_stainfo( (&padapter->stapriv) , pattrib->dst);
+	struct sta_info *ptdls_sta=rtw_get_stainfo((&padapter->stapriv) , pattrib->dst);
 
 	u8 payload_type = 0x02;
 	u8 category = RTW_WLAN_CATEGORY_TDLS;
@@ -2069,7 +2052,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	pframe = rtw_tdls_set_sup_ch(pmlmeext, pframe, pattrib);
 
 	//	SRC IE
-	pframe = rtw_set_ie( pframe, _SRC_IE_, 16, TDLS_SRC, &(pattrib->pktlen));
+	pframe = rtw_set_ie(pframe, _SRC_IE_, 16, TDLS_SRC, &(pattrib->pktlen));
 
 	//RSNIE
 	if (pattrib->encrypt)
@@ -2113,9 +2096,8 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
 
 #ifdef CONFIG_WFD
-	wfd_ie_tdls( padapter, pframe, &(pattrib->pktlen) );
+	wfd_ie_tdls(padapter, pframe, &(pattrib->pktlen));
 #endif //CONFIG_WFD
-
 }
 
 void rtw_build_tdls_setup_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
@@ -2143,9 +2125,9 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	u8  *pftie, *ptimeout_ie, *plinkid_ie, *prsnie, *pftie_mic;
 	u32 time;
 
-	ptdls_sta = rtw_get_stainfo( &(padapter->stapriv) , pattrib->dst);
+	ptdls_sta = rtw_get_stainfo(&(padapter->stapriv) , pattrib->dst);
 
-	if (ptdls_sta == NULL )
+	if (ptdls_sta == NULL)
 	{
 		DBG_871X("[%s] %d\n", __func__, __LINE__);
 		return;
@@ -2177,7 +2159,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	//capability
 	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
 
-	if (pattrib->encrypt )
+	if (pattrib->encrypt)
 		*pframe =*pframe | BIT(4);
 	pframe += 2;
 	pattrib->pktlen += 2;
@@ -2262,18 +2244,16 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 		wpa_tdls_ftie_mic(ptdls_sta->tpk.kck, 2, plinkid_ie, prsnie, ptimeout_ie, pftie, pftie_mic);
 
 #ifdef CONFIG_WFD
-	wfd_ie_tdls( padapter, pframe, &(pattrib->pktlen) );
+	wfd_ie_tdls(padapter, pframe, &(pattrib->pktlen));
 #endif //CONFIG_WFD
-
 }
 
 void rtw_build_tdls_setup_cfm_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
 {
-
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	struct sta_info *ptdls_sta=rtw_get_stainfo( (&padapter->stapriv) , pattrib->dst);
+	struct sta_info *ptdls_sta=rtw_get_stainfo((&padapter->stapriv) , pattrib->dst);
 
 	u8 payload_type = 0x02;
 	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
@@ -2336,19 +2316,17 @@ void rtw_build_tdls_setup_cfm_ies(_adapt
 	//fill FTIE mic
 	if (pattrib->encrypt)
 		wpa_tdls_ftie_mic(ptdls_sta->tpk.kck, 3, plinkid_ie, prsnie, ptimeout_ie, pftie, pftie_mic);
-
 }
 
 void rtw_build_tdls_teardown_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
 {
-
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	u8 payload_type = 0x02;
 	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
 	unsigned char action = TDLS_TEARDOWN;
 	u8	link_id_addr[18] = {0};
 
-	struct sta_info *ptdls_sta = rtw_get_stainfo( &(padapter->stapriv) , pattrib->dst);
+	struct sta_info *ptdls_sta = rtw_get_stainfo(&(padapter->stapriv) , pattrib->dst);
 	struct sta_priv		*pstapriv = &padapter->stapriv;
 
 	//payload type
@@ -2369,12 +2347,10 @@ void rtw_build_tdls_teardown_ies(_adapte
 		memcpy((link_id_addr+12), pattrib->src, 6);
 	}
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-
 }
 
 void rtw_build_tdls_dis_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
 {
-
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	u8 payload_type = 0x02;
 	u8 category = RTW_WLAN_CATEGORY_TDLS;
@@ -2395,7 +2371,6 @@ void rtw_build_tdls_dis_req_ies(_adapter
 	memcpy((link_id_addr+6), pattrib->src, 6);
 	memcpy((link_id_addr+12), pattrib->dst, 6);
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-
 }
 
 void rtw_build_tdls_dis_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, u8 dialog)
@@ -2487,12 +2462,10 @@ void rtw_build_tdls_dis_rsp_ies(_adapter
 	memcpy((link_id_addr+6), pattrib->dst, 6);
 	memcpy((link_id_addr+12), pattrib->src, 6);
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_, 18, link_id_addr, &(pattrib->pktlen));
-
 }
 
 void rtw_build_tdls_peer_traffic_indication_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
 {
-
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	u8 payload_type = 0x02;
 	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
@@ -2527,12 +2500,10 @@ void rtw_build_tdls_peer_traffic_indicat
 	if (ptdls_sta->uapsd_vo&BIT(1))
 		AC_queue=BIT(3);
 	pframe = rtw_set_ie(pframe, _PTI_BUFFER_STATUS_, 1, &AC_queue, &(pattrib->pktlen));
-
 }
 
 void rtw_build_tdls_ch_switch_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
 {
-
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	u8 payload_type = 0x02;
@@ -2566,12 +2537,10 @@ void rtw_build_tdls_ch_switch_req_ies(_a
 	ptdls_sta->off_ch=ptdlsinfo->candidate_ch;
 	ptdls_sta->ch_switch_time=switch_time;
 	ptdls_sta->ch_switch_timeout=switch_timeout;
-
 }
 
 void rtw_build_tdls_ch_switch_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
 {
-
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	u8 payload_type = 0x02;
 	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
@@ -2600,13 +2569,11 @@ void rtw_build_tdls_ch_switch_rsp_ies(_a
 	memcpy(ch_switch_timing, &ptdls_sta->ch_switch_time, 2);
 	memcpy(ch_switch_timing+2, &ptdls_sta->ch_switch_timeout, 2);
 	pframe = rtw_set_ie(pframe, _CH_SWITCH_TIMING_,  4, ch_switch_timing, &(pattrib->pktlen));
-
 }
 
 #ifdef CONFIG_WFD
 void rtw_build_tunneled_probe_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
 {
-
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 	struct wifidirect_info *pbuddy_wdinfo = &padapter->pbuddy_adapter->wdinfo;
@@ -2635,12 +2602,10 @@ void rtw_build_tunneled_probe_req_ies(_a
 		pframe += wfdielen;
 		pattrib->pktlen += wfdielen;
 	}
-
 }
 
 void rtw_build_tunneled_probe_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
 {
-
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 	struct wifidirect_info *pbuddy_wdinfo = &padapter->pbuddy_adapter->wdinfo;
@@ -2669,7 +2634,6 @@ void rtw_build_tunneled_probe_rsp_ies(_a
 		pframe += wfdielen;
 		pattrib->pktlen += wfdielen;
 	}
-
 }
 #endif //CONFIG_WFD
 
@@ -2700,16 +2664,15 @@ void init_TPK_timer(_adapter *padapter,
 // TDLS_BASE_CH: when go back to the channel linked with AP, send null data to peer STA as an indication
 void _ch_switch_timer_hdl(void *FunctionContext)
 {
-
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
 	_adapter *padapter = ptdls_sta->padapter;
 
-	if ( ptdls_sta->option == TDLS_DONE_CH_SEN ){
+	if (ptdls_sta->option == TDLS_DONE_CH_SEN){
 		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_DONE_CH_SEN);
-	}else if ( ptdls_sta->option == TDLS_OFF_CH ){
+	}else if (ptdls_sta->option == TDLS_OFF_CH){
 		issue_nulldata_to_TDLS_peer_STA(ptdls_sta->padapter, ptdls_sta, 0);
 		_set_timer(&ptdls_sta->base_ch_timer, 500);
-	}else if ( ptdls_sta->option == TDLS_BASE_CH){
+	}else if (ptdls_sta->option == TDLS_BASE_CH){
 		issue_nulldata_to_TDLS_peer_STA(ptdls_sta->padapter, ptdls_sta, 0);
 	}
 }
@@ -2735,7 +2698,7 @@ void init_base_ch_timer(_adapter *padapt
 void _off_ch_timer_hdl(void *FunctionContext)
 {
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
-	rtw_tdls_cmd(ptdls_sta->padapter, ptdls_sta->hwaddr, TDLS_P_BASE_CH );
+	rtw_tdls_cmd(ptdls_sta->padapter, ptdls_sta->hwaddr, TDLS_P_BASE_CH);
 }
 
 void init_off_ch_timer(_adapter *padapter, struct sta_info *psta)
@@ -2750,7 +2713,7 @@ void _tdls_handshake_timer_hdl(void *Fun
 
 	if (ptdls_sta != NULL)
 	{
-		if ( !(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) )
+		if (!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 		{
 			DBG_871X("tdls handshake time out\n");
 			free_tdls_sta(ptdls_sta->padapter, ptdls_sta);
@@ -2778,11 +2741,11 @@ void _tdls_alive_timer_phase1_hdl(void *
 	ptdls_sta->tdls_sta_state &= (~TDLS_ALIVE_STATE);
 
 	DBG_871X("issue_tdls_dis_req to check alive\n");
-	issue_tdls_dis_req( padapter, ptdls_sta->hwaddr);
+	issue_tdls_dis_req(padapter, ptdls_sta->hwaddr);
 	rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_CKALV_PH1);
 	sta_update_last_rx_pkts(ptdls_sta);
 
-	if (	ptdls_sta->timer_flag == 2 )
+	if (	ptdls_sta->timer_flag == 2)
 		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_FREE_STA);
 	else
 	{
@@ -2790,7 +2753,6 @@ void _tdls_alive_timer_phase1_hdl(void *
 		ptdls_sta->timer_flag = 0;
 		spin_unlock_bh(&ptdlsinfo->hdl_lock);
 	}
-
 }
 
 void _tdls_alive_timer_phase2_hdl(void *FunctionContext)
@@ -2803,8 +2765,8 @@ void _tdls_alive_timer_phase2_hdl(void *
 	ptdls_sta->timer_flag = 1;
 	spin_unlock_bh(&ptdlsinfo->hdl_lock);
 
-	if ( (ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE) &&
-		(sta_last_rx_pkts(ptdls_sta) + 3 <= sta_rx_pkts(ptdls_sta)) )
+	if ((ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE) &&
+		(sta_last_rx_pkts(ptdls_sta) + 3 <= sta_rx_pkts(ptdls_sta)))
 	{
 		DBG_871X("TDLS STA ALIVE, ptdls_sta->sta_stats.last_rx_pkts:%llu, ptdls_sta->sta_stats.rx_pkts:%llu\n",
 			sta_last_rx_pkts(ptdls_sta), sta_rx_pkts(ptdls_sta));
@@ -2814,14 +2776,14 @@ void _tdls_alive_timer_phase2_hdl(void *
 	}
 	else
 	{
-		if ( !(ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE) )
+		if (!(ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE))
 			DBG_871X("TDLS STA TOO FAR\n");
-		if ( !(sta_last_rx_pkts(ptdls_sta) + 3 <= sta_rx_pkts(ptdls_sta)))
+		if (!(sta_last_rx_pkts(ptdls_sta) + 3 <= sta_rx_pkts(ptdls_sta)))
 			DBG_871X("TDLS LINK WITH LOW TRAFFIC, ptdls_sta->sta_stats.last_rx_pkts:%llu, ptdls_sta->sta_stats.rx_pkts:%llu\n",
 				sta_last_rx_pkts(ptdls_sta), sta_rx_pkts(ptdls_sta));
 
 		ptdls_sta->alive_count++;
-		if ( ptdls_sta->alive_count == TDLS_ALIVE_COUNT )
+		if (ptdls_sta->alive_count == TDLS_ALIVE_COUNT)
 		{
 			ptdls_sta->stat_code = _RSON_TDLS_TEAR_TOOFAR_;
 			issue_tdls_teardown(padapter, ptdls_sta->hwaddr);
@@ -2832,7 +2794,7 @@ void _tdls_alive_timer_phase2_hdl(void *
 		}
 	}
 
-	if (	ptdls_sta->timer_flag == 2 )
+	if (	ptdls_sta->timer_flag == 2)
 		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_FREE_STA);
 	else
 	{
@@ -2840,7 +2802,6 @@ void _tdls_alive_timer_phase2_hdl(void *
 		ptdls_sta->timer_flag = 0;
 		spin_unlock_bh(&ptdlsinfo->hdl_lock);
 }
-
 }
 
 void init_tdls_alive_timer(_adapter *padapter, struct sta_info *psta)
@@ -2895,7 +2856,7 @@ u32 update_mask_tdls(_adapter *padapter,
 		}
 	}
 
-	if ( pcur_network->Configuration.DSConfig > 14 ) {
+	if (pcur_network->Configuration.DSConfig > 14) {
 		// 5G band
 		if (tx_ra_bitmap & 0xffff000)
 			sta_band |= WIRELESS_11_5N | WIRELESS_11A;
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -79,13 +79,12 @@ int cckrates_included(unsigned char *rat
 
 	for (i = 0; i < ratelen; i++)
 	{
-		if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
-			   (((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )
+		if  ( (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
+			   (((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22))
 		return true;
 	}
 
 	return false;
-
 }
 
 int cckratesonly_included(unsigned char *rate, int ratelen)
@@ -94,8 +93,8 @@ int cckratesonly_included(unsigned char
 
 	for (i = 0; i < ratelen; i++)
 	{
-		if  ( (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
-			   (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
+		if  ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+			   (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22))
 		return false;
 	}
 
@@ -136,7 +135,6 @@ unsigned char networktype_to_raid(unsign
 	}
 
 	return raid;
-
 }
 
 int judge_network_type(struct rtw_adapter *padapter, unsigned char *rate, int ratelen)
@@ -237,7 +235,6 @@ unsigned char ratetbl_val_2wifirate(unsi
 	}
 
 	return val;
-
 }
 
 int is_basicrate(struct rtw_adapter *padapter, unsigned char rate);
@@ -334,7 +331,6 @@ void UpdateBrateTbl(
 				break;
 		}
 	}
-
 }
 
 void UpdateBrateTblForSoftAP(u8 *bssrateset, u32 bssratelen)
@@ -355,7 +351,6 @@ void UpdateBrateTblForSoftAP(u8 *bssrate
 				break;
 		}
 	}
-
 }
 
 void Save_DM_Func_Flag(struct rtw_adapter *padapter)
@@ -369,7 +364,6 @@ void Save_DM_Func_Flag(struct rtw_adapte
 #endif
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));
-
 }
 
 void Restore_DM_Func_Flag(struct rtw_adapter *padapter)
@@ -512,9 +506,9 @@ void set_channel_bwmode(struct rtw_adapt
 	u8 center_ch;
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
-	if ( padapter->bNotifyChannelChange )
+	if (padapter->bNotifyChannelChange)
 	{
-		DBG_8192D( "[%s] ch = %d, offset = %d, bwmode = %d\n", __func__, channel, channel_offset, bwmode );
+		DBG_8192D("[%s] ch = %d, offset = %d, bwmode = %d\n", __func__, channel, channel_offset, bwmode);
 	}
 
 	if ((bwmode == HT_CHANNEL_WIDTH_20)||(channel_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE))
@@ -564,7 +558,6 @@ void set_channel_bwmode(struct rtw_adapt
 
 	//set BandWidth
 	SetBWMode(padapter, bwmode, channel_offset);
-
 }
 
 int get_bsstype(unsigned short capability)
@@ -594,7 +587,6 @@ u16 get_beacon_interval(struct wlan_bssi
 	memcpy((unsigned char *)&val, rtw_get_beacon_interval_from_ie(bss->IEs), 2);
 
 	return le16_to_cpu(val);
-
 }
 
 int is_client_associated_to_ap(struct rtw_adapter *padapter)
@@ -648,7 +640,6 @@ int is_IBSS_empty(struct rtw_adapter *pa
 	}
 
 	return true;
-
 }
 
 unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval)
@@ -694,11 +685,11 @@ void write_cam(struct rtw_adapter *padap
 		switch (j)
 		{
 			case 0:
-				val = (ctrl | (mac[0] << 16) | (mac[1] << 24) );
+				val = (ctrl | (mac[0] << 16) | (mac[1] << 24));
 				break;
 
 			case 1:
-				val = (mac[2] | ( mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));
+				val = (mac[2] | (mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));
 				break;
 
 			default:
@@ -721,7 +712,6 @@ void write_cam(struct rtw_adapter *padap
 		//DBG_8192D("%s=> cam write: %x, %x\n",__func__, cmd, val);
 
 	}
-
 }
 
 void clear_cam_entry(struct rtw_adapter *padapter, u8 entry)
@@ -799,7 +789,6 @@ void flush_all_cam_entry(struct rtw_adap
 #endif //CONFIG_CONCURRENT_MODE
 
 	memset((u8 *)(pmlmeinfo->FW_sta_info), 0, sizeof(pmlmeinfo->FW_sta_info));
-
 }
 
 #if defined(CONFIG_P2P) && defined(CONFIG_WFD)
@@ -815,26 +804,26 @@ int WFD_info_handler(struct rtw_adapter
 
 
 	pwdinfo = &padapter->wdinfo;
-	if ( rtw_get_wfd_ie( ( u8* ) pIE, pIE->Length, wfd_ie, &wfd_ielen ) )
+	if (rtw_get_wfd_ie((u8*) pIE, pIE->Length, wfd_ie, &wfd_ielen))
 	{
 		u8	attr_content[ 10 ] = { 0x00 };
 		u32	attr_contentlen = 0;
 
-		printk( "[%s] Found WFD IE\n", __func__ );
-		rtw_get_wfd_attr_content( wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
-		if ( attr_contentlen )
+		printk("[%s] Found WFD IE\n", __func__);
+		rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
+		if (attr_contentlen)
 		{
-			pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16( attr_content + 2 );
-			DBG_8192D( "[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport );
-			return( true );
+			pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16(attr_content + 2);
+			DBG_8192D("[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
+			return(true);
 		}
 	}
 	else
 	{
-		printk( "[%s] NO WFD IE\n", __func__ );
+		printk("[%s] NO WFD IE\n", __func__);
 
 	}
-	return( _FAIL );
+	return(_FAIL);
 }
 #endif
 
@@ -874,7 +863,6 @@ int WMM_param_handler(struct rtw_adapter
 		pmlmeinfo->WMM_enable = 0;
 		return _FAIL;
 	}*/
-
 }
 
 void WMMOnAssocRsp(struct rtw_adapter *padapter)
@@ -894,7 +882,7 @@ void WMMOnAssocRsp(struct rtw_adapter *p
 
 	acm_mask = 0;
 
-	if ( pmlmeext->cur_wireless_mode == WIRELESS_11B)
+	if (pmlmeext->cur_wireless_mode == WIRELESS_11B)
 		aSifsTime = 10;
 	else
 		aSifsTime = 16;
@@ -977,7 +965,7 @@ static void bwmode_update_check(struct r
 			cbw40_enable = 1;
 	}
 
-	if ((pHT_info->infos[0] & BIT(2)) && cbw40_enable )
+	if ((pHT_info->infos[0] & BIT(2)) && cbw40_enable)
 	{
 		new_bwmode = HT_CHANNEL_WIDTH_40;
 
@@ -1051,7 +1039,6 @@ static void bwmode_update_check(struct r
 		//pmlmeinfo->bwmode_updated = false;//bwmode_updated done, reset it!
 
 	}
-
 }
 
 void HT_caps_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies * pIE)
@@ -1107,8 +1094,8 @@ void HT_caps_handler(struct rtw_adapter
 	//	Commented by Albert 2010/07/12
 	//	Have to handle the endian issue after copying.
 	//	HT_ext_caps didn't be used yet.
-	pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = le16_to_cpu( pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info );
-	pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps = le16_to_cpu( pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps );
+	pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info);
+	pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps = le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps);
 
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
@@ -1198,7 +1185,6 @@ void HTOnAssocRsp(struct rtw_adapter *pa
 	rtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_MIN_SPACE, (u8 *)(&min_MPDU_spacing));
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_FACTOR, (u8 *)(&max_AMPDU_len));
-
 }
 
 void ERP_IE_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies * pIE)
@@ -1274,7 +1260,7 @@ int check_ap_tdls_prohibited(u8 *pframe,
 	}
 
 	pframe += 4;
-	if ( (*pframe) & tdls_prohibited_bit )
+	if ((*pframe) & tdls_prohibited_bit)
 		return true;
 
 	return false;
@@ -1307,7 +1293,7 @@ void update_beacon_info(struct rtw_adapt
 			break;
 #ifdef CONFIG_TDLS
 		case _EXT_CAP_IE_:
-			if ( check_ap_tdls_prohibited(pIE->data, pIE->Length) == true )
+			if (check_ap_tdls_prohibited(pIE->data, pIE->Length) == true)
 				ptdlsinfo->ap_prohibited = true;
 			break;
 #endif //CONFIG_TDLS
@@ -1391,7 +1377,6 @@ unsigned int is_ap_in_tkip(struct rtw_ad
 	{
 		return false;
 	}
-
 }
 
 int wifirate2_ratetbl_inx(unsigned char rate);
@@ -1703,7 +1688,6 @@ void update_IOT_info(struct rtw_adapter
 			pmlmeinfo->turboMode_rtsen = 1;
 			break;
 	}
-
 }
 
 void update_capinfo(struct rtw_adapter * Adapter, u16 updateCap)
@@ -1714,16 +1698,14 @@ void update_capinfo(struct rtw_adapter *
 
 	// Check preamble mode, 2005.01.06, by rcnjko.
 	// Mark to update preamble value forever, 2008.03.18 by lanhsin
-	//if ( pMgntInfo->RegPreambleMode == PREAMBLE_AUTO )
+	//if (pMgntInfo->RegPreambleMode == PREAMBLE_AUTO)
 	{
-
-		if (updateCap & cShortPreamble)
-		{ // Short Preamble
+		if (updateCap & cShortPreamble) { // Short Preamble
 			if (pmlmeinfo->preamble_mode != PREAMBLE_SHORT) // PREAMBLE_LONG or PREAMBLE_AUTO
 			{
 				ShortPreamble = true;
 				pmlmeinfo->preamble_mode = PREAMBLE_SHORT;
-				rtw_hal_set_hwreg( Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&ShortPreamble );
+				rtw_hal_set_hwreg(Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&ShortPreamble);
 			}
 		}
 		else
@@ -1732,21 +1714,21 @@ void update_capinfo(struct rtw_adapter *
 			{
 				ShortPreamble = false;
 				pmlmeinfo->preamble_mode = PREAMBLE_LONG;
-				rtw_hal_set_hwreg( Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&ShortPreamble );
+				rtw_hal_set_hwreg(Adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&ShortPreamble);
 			}
 		}
 	}
 
-	if ( updateCap & cIBSS ) {
+	if (updateCap & cIBSS) {
 		//Filen: See 802.11-2007 p.91
 		pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
 	}
 	else
 	{
 		//Filen: See 802.11-2007 p.90
-		if ( pmlmeext->cur_wireless_mode & (WIRELESS_11G | WIRELESS_11_24N))
+		if (pmlmeext->cur_wireless_mode & (WIRELESS_11G | WIRELESS_11_24N))
 		{
-			if ( (updateCap & cShortSlotTime) /* && (!(pMgntInfo->pHTInfo->RT2RT_HT_Mode & RT_HT_CAP_USE_LONG_PREAMBLE)) */)
+			if ((updateCap & cShortSlotTime) /* && (!(pMgntInfo->pHTInfo->RT2RT_HT_Mode & RT_HT_CAP_USE_LONG_PREAMBLE)) */)
 			{ // Short Slot Time
 				if (pmlmeinfo->slotTime != SHORT_SLOT_TIME)
 				{
@@ -1761,7 +1743,7 @@ void update_capinfo(struct rtw_adapter *
 				}
 			}
 		}
-		else if ( pmlmeext->cur_wireless_mode & (WIRELESS_11A | WIRELESS_11_5N))
+		else if (pmlmeext->cur_wireless_mode & (WIRELESS_11A | WIRELESS_11_5N))
 		{
 			pmlmeinfo->slotTime = SHORT_SLOT_TIME;
 		}
@@ -1772,8 +1754,7 @@ void update_capinfo(struct rtw_adapter *
 		}
 	}
 
-	rtw_hal_set_hwreg( Adapter, HW_VAR_SLOT_TIME, &pmlmeinfo->slotTime );
-
+	rtw_hal_set_hwreg(Adapter, HW_VAR_SLOT_TIME, &pmlmeinfo->slotTime);
 }
 
 void update_wireless_mode(struct rtw_adapter *padapter)
@@ -1832,7 +1813,7 @@ void update_wireless_mode(struct rtw_ada
 	//Modified by Thomas 2012-12-3
 	mask = update_supported_rate(cur_network->SupportedRates, ratelen);
 	init_rate = get_highest_rate_idx(mask)&0x3f;
-	rtw_hal_set_hwreg( padapter, HW_VAR_INIT_DATA_RATE,  (u8 *)&init_rate);
+	rtw_hal_set_hwreg(padapter, HW_VAR_INIT_DATA_RATE,  (u8 *)&init_rate);
 
 /*
 	if ((pmlmeext->cur_wireless_mode==WIRELESS_11G) ||
@@ -1845,7 +1826,7 @@ void update_wireless_mode(struct rtw_ada
 	SIFS_Timer = 0x0a0a0808; //0x0808 -> for CCK, 0x0a0a -> for OFDM
                              //change this value if having IOT issues.
 
-	rtw_hal_set_hwreg( padapter, HW_VAR_RESP_SIFS,  (u8 *)&SIFS_Timer);
+	rtw_hal_set_hwreg(padapter, HW_VAR_RESP_SIFS,  (u8 *)&SIFS_Timer);
 
 	if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
 		update_mgnt_tx_rate(padapter, IEEE80211_CCK_RATE_1MB);
@@ -1902,7 +1883,6 @@ int update_sta_support_rate(struct rtw_a
 		memcpy((pmlmeinfo->FW_sta_info[cam_idx].SupportedRates + supportRateNum), pIE->data, ie_len);
 
 	return _SUCCESS;
-
 }
 
 void process_addba_req(struct rtw_adapter *padapter, u8 *paddba_req, u8 *addr)
@@ -1938,7 +1918,6 @@ void process_addba_req(struct rtw_adapte
 
 		preorder_ctrl->enable =(pmlmeinfo->bAcceptAddbaReq == true)? true :false;
 	}
-
 }
 
 void update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len)
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -46,7 +46,6 @@ _func_exit_;
 
 void	_rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)
 {
-
 _func_enter_;
 
 	memset((unsigned char *)psta_xmitpriv, 0, sizeof (struct sta_xmit_priv));
@@ -64,7 +63,6 @@ _func_enter_;
 	INIT_LIST_HEAD(&psta_xmitpriv->apsd);
 
 _func_exit_;
-
 }
 
 s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct rtw_adapter *padapter)
@@ -363,7 +361,6 @@ void _rtw_free_xmit_priv (struct xmit_pr
 out:
 
 _func_exit_;
-
 }
 
 static void update_attrib_vcs_info(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
@@ -426,7 +423,7 @@ static void update_attrib_vcs_info(struc
 
 			//IOT action
 			if ((pmlmeinfo->assoc_AP_vendor == atherosAP) && (pattrib->ampdu_en==true) &&
-				(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_ ))
+				(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_))
 			{
 				pattrib->vcs_mode = CTS_TO_SELF;
 				break;
@@ -449,7 +446,7 @@ static void update_attrib_vcs_info(struc
 			{
 				u8 HTOpMode = pmlmeinfo->HT_protection;
 				if ((pmlmeext->cur_bwmode && (HTOpMode == 2 || HTOpMode == 3)) ||
-					(!pmlmeext->cur_bwmode && HTOpMode == 3) )
+					(!pmlmeext->cur_bwmode && HTOpMode == 3))
 				{
 					pattrib->vcs_mode = RTS_CTS;
 					break;
@@ -508,7 +505,6 @@ static void update_attrib_phy_info(struc
 
 
 	pattrib->retry_ctrl = false;
-
 }
 
 u8	qos_acm(u8 acm_mask, u8 priority)
@@ -641,14 +637,14 @@ static s32 update_attrib(struct rtw_adap
 		}
 	}
 
-	if ( (pattrib->ether_type == 0x888e) || (pattrib->dhcp_pkt == 1) )
+	if ((pattrib->ether_type == 0x888e) || (pattrib->dhcp_pkt == 1))
 	{
 		rtw_set_scan_deny(padapter, 3000);
 	}
 
 #ifdef CONFIG_LPS
 	// If EAPOL , ARP , OR DHCP packet, driver must be in active mode.
-	if ( (pattrib->ether_type == 0x0806) || (pattrib->ether_type == 0x888e) || (pattrib->dhcp_pkt == 1) )
+	if ((pattrib->ether_type == 0x0806) || (pattrib->ether_type == 0x888e) || (pattrib->dhcp_pkt == 1))
 	{
 		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SPECIAL_PACKET, 1);
 	}
@@ -694,7 +690,7 @@ static s32 update_attrib(struct rtw_adap
 
 	pattrib->ack_policy = 0;
 	// get ether_hdr_len
-	pattrib->pkt_hdrlen = ETH_HLEN;//(pattrib->ether_type == 0x8100) ? (14 + 4 ): 14; //vlan tag
+	pattrib->pkt_hdrlen = ETH_HLEN;//(pattrib->ether_type == 0x8100) ? (14 + 4): 14; //vlan tag
 
 	pattrib->hdrlen = WLAN_HDR_A3_LEN;
 	pattrib->subtype = WIFI_DATA_TYPE;
@@ -921,12 +917,12 @@ _func_enter_;
 				payload=payload+pattrib->hdrlen+pattrib->iv_len;
 				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("curfragnum=%d pattrib->hdrlen=%d pattrib->iv_len=%d",curfragnum,pattrib->hdrlen,pattrib->iv_len));
 				if ((curfragnum+1)==pattrib->nr_frags){
-					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-( (pattrib->bswenc) ? pattrib->icv_len : 0);
+					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);
 					rtw_secmicappend(&micdata, payload,length);
 					payload=payload+length;
 				}
 				else{
-					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-( (pattrib->bswenc) ? pattrib->icv_len : 0);
+					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);
 					rtw_secmicappend(&micdata, payload, length);
 					payload=payload+length+pattrib->icv_len;
 					RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("curfragnum=%d length=%d pattrib->icv_len=%d",curfragnum,length,pattrib->icv_len));
@@ -961,7 +957,6 @@ _func_exit_;
 }
 
 static s32 xmitframe_swencrypt(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe){
-
 	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
 	//struct	security_priv	*psecuritypriv=&padapter->securitypriv;
 
@@ -981,7 +976,7 @@ _func_enter_;
 			rtw_tkip_encrypt(padapter, (u8 *)pxmitframe);
 			break;
 		case _AES_:
-			rtw_aes_encrypt(padapter, (u8 * )pxmitframe);
+			rtw_aes_encrypt(padapter, (u8 *)pxmitframe);
 			break;
 		default:
 				break;
@@ -1069,7 +1064,7 @@ _func_enter_;
 				qos_option = true;
 
 		}
-		else if ((check_fwstate(pmlmepriv,  WIFI_AP_STATE) == true) ) {
+		else if ((check_fwstate(pmlmepriv,  WIFI_AP_STATE) == true)) {
 			//to_ds = 0, fr_ds = 1;
 			SetFrDs(fctrl);
 			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
@@ -1197,7 +1192,6 @@ _func_enter_;
 	}
 	else
 	{
-
 	}
 
 exit:
@@ -1340,7 +1334,7 @@ _func_enter_;
 			tdls_seq=1;
 			break;
 		case TDLS_DISCOVERY_REQUEST:	//unicast: directly to peer sta, Bcast: via AP
-			if (_rtw_memcmp(pattrib->dst, baddr, ETH_ALEN) )
+			if (_rtw_memcmp(pattrib->dst, baddr, ETH_ALEN))
 			{
 				SetToDs(fctrl);
 				memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
@@ -1486,7 +1480,7 @@ _func_enter_;
 
 	rtw_build_tdls_ies(padapter, pxmitframe, pframe, action);
 
-	if ((pattrib->icv_len >0 )&& (pattrib->bswenc)) {
+	if ((pattrib->icv_len >0)&& (pattrib->bswenc)) {
 		pframe += pattrib->pktlen;
 		memcpy(pframe, pattrib->icv, pattrib->icv_len);
 		pframe += pattrib->icv_len;
@@ -1673,7 +1667,7 @@ _func_enter_;
 
 		pframe += mem_sz;
 
-		if ((pattrib->icv_len >0 )&& (pattrib->bswenc)) {
+		if ((pattrib->icv_len >0)&& (pattrib->bswenc)) {
 			memcpy(pframe, pattrib->icv, pattrib->icv_len);
 			pframe += pattrib->icv_len;
 		}
@@ -1758,7 +1752,6 @@ _func_exit_;
 
 void rtw_update_protection(struct rtw_adapter *padapter, u8 *ie, uint ie_len)
 {
-
 	uint	protection;
 	u8	*perp;
 	int	 erp_len;
@@ -1802,7 +1795,6 @@ _func_enter_;
 	}
 
 _func_exit_;
-
 }
 
 void rtw_count_tx_stats(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe, int sz)
@@ -1834,7 +1826,6 @@ void rtw_count_tx_stats(struct rtw_adapt
 			pstats->tx_bytes += sz;
 		}
 	}
-
 }
 
 struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv)
@@ -1851,7 +1842,6 @@ _func_enter_;
 	if (_rtw_queue_empty(pfree_queue) == true) {
 		pxmitbuf = NULL;
 	} else {
-
 		phead = get_list_head(pfree_queue);
 
 		plist = get_next(phead);
@@ -1930,7 +1920,6 @@ _func_enter_;
 	if (_rtw_queue_empty(pfree_xmitbuf_queue) == true) {
 		pxmitbuf = NULL;
 	} else {
-
 		phead = get_list_head(pfree_xmitbuf_queue);
 
 		plist = get_next(phead);
@@ -2151,7 +2140,6 @@ _func_enter_;
 
 	while (rtw_end_of_queue_search(phead, plist) == false)
 	{
-
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 
 		plist = get_next(plist);
@@ -2260,7 +2248,6 @@ _func_enter_;
 
 		while ((rtw_end_of_queue_search(sta_phead, sta_plist)) == false)
 		{
-
 			ptxservq= LIST_CONTAINOR(sta_plist, struct tx_servq, tx_pending);
 
 			pframe_queue = &ptxservq->sta_pending;
@@ -2411,7 +2398,6 @@ void rtw_alloc_hwxmits(struct rtw_adapte
 	}
 	else if (pxmitpriv->hwxmit_entry == 4)
 	{
-
 		//pxmitpriv->vo_txqueue.head = 0;
 		//hwxmits[0] .phwtxqueue = &pxmitpriv->vo_txqueue;
 		hwxmits[0] .sta_queue = &pxmitpriv->vo_pending;
@@ -2431,10 +2417,8 @@ void rtw_alloc_hwxmits(struct rtw_adapte
 	else
 	{
 
-
 	}
 
-
 }
 
 void rtw_free_hwxmits(struct rtw_adapter *padapter)
@@ -2689,7 +2673,7 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 	rcu_read_unlock();
 #endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 
-	if ( br_port	&& check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true)
+	if (br_port	&& check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true)
 	{
 		res = rtw_br_client_tx(padapter, ppkt);
 		if (res == -1)
@@ -2747,17 +2731,14 @@ int xmitframe_enqueue_for_tdls_sleeping_
 	if (ptdls_sta==NULL){
 		return ret;
 	}else if (ptdls_sta->tdls_sta_state&TDLS_LINKED_STATE){
-
-		if (pattrib->triggered==1)
-		{
+		if (pattrib->triggered==1) {
 			ret = true;
 			return ret;
-			}
+		}
 
 		spin_lock_bh(&ptdls_sta->sleep_q.lock);
 
-		if (ptdls_sta->state&WIFI_SLEEP_STATE)
-		{
+		if (ptdls_sta->state&WIFI_SLEEP_STATE) {
 			rtw_list_delete(&pxmitframe->list);
 
 			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&ptdls_sta->sleep_q));
@@ -2800,7 +2781,6 @@ int xmitframe_enqueue_for_tdls_sleeping_
 	}
 
 	return ret;
-
 }
 #endif //CONFIG_TDLS
 
@@ -2817,7 +2797,7 @@ int xmitframe_enqueue_for_sleeping_sta(s
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 
-	if ( ptdlsinfo->setup_state == TDLS_LINKED_STATE )
+	if (ptdlsinfo->setup_state == TDLS_LINKED_STATE)
 	{
 		ret = xmitframe_enqueue_for_tdls_sleeping_sta(padapter, pxmitframe);
 		return ret;
@@ -2965,7 +2945,6 @@ static void dequeue_xmitframes_to_sleepi
 		ptxservq->qcnt--;
 		phwxmits[ac_index].accnt--;
 	}
-
 }
 
 void stop_sta_xmit(struct rtw_adapter *padapter, struct sta_info *psta)
@@ -2986,7 +2965,7 @@ void stop_sta_xmit(struct rtw_adapter *p
 	psta->state |= WIFI_SLEEP_STATE;
 
 #ifdef CONFIG_TDLS
-	if ( !(psta->tdls_sta_state & TDLS_LINKED_STATE) )
+	if (!(psta->tdls_sta_state & TDLS_LINKED_STATE))
 #endif //CONFIG_TDLS
 	pstapriv->sta_dz_bitmap |= BIT(psta->aid);
 
@@ -3008,9 +2987,9 @@ void stop_sta_xmit(struct rtw_adapter *p
 	rtw_list_delete(&(pstaxmitpriv->bk_q.tx_pending));
 
 #ifdef CONFIG_TDLS
-	if ( !(psta->tdls_sta_state & TDLS_LINKED_STATE) )
+	if (!(psta->tdls_sta_state & TDLS_LINKED_STATE))
 	{
-		if ( psta_bmc != NULL )
+		if (psta_bmc != NULL)
 		{
 #endif //CONFIG_TDLS
 
@@ -3103,7 +3082,7 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 	if (psta->sleepq_len==0)
 	{
 #ifdef CONFIG_TDLS
-		if ( psta->tdls_sta_state & TDLS_LINKED_STATE )
+		if (psta->tdls_sta_state & TDLS_LINKED_STATE)
 		{
 			if (psta->state&WIFI_SLEEP_STATE)
 				psta->state ^= WIFI_SLEEP_STATE;
@@ -3191,7 +3170,6 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 		//update_BCNTIM(padapter);
 		update_beacon(padapter, _TIM_IE_, NULL, false);
 	}
-
 }
 
 void xmit_delivery_enabled_frames(struct rtw_adapter *padapter, struct sta_info *psta)
@@ -3262,7 +3240,7 @@ void xmit_delivery_enabled_frames(struct
 		if ((psta->sleepq_ac_len==0) && (!psta->has_legacy_ac) && (wmmps_ac))
 		{
 #ifdef CONFIG_TDLS
-			if (psta->tdls_sta_state & TDLS_LINKED_STATE )
+			if (psta->tdls_sta_state & TDLS_LINKED_STATE)
 			{
 				spin_unlock_bh(&psta->sleep_q.lock);
 				return;
--- a/drivers/staging/rtl8192du/hal/hal_intf.c
+++ b/drivers/staging/rtl8192du/hal/hal_intf.c
@@ -173,7 +173,6 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 	RT_TRACE(_module_hal_init_c_,_drv_err_,("-rtl871x_hal_init:status=0x%x\n",status));
 
 	return status;
-
 }
 
 uint rtw_hal_deinit(struct rtw_adapter *padapter)
@@ -229,7 +228,6 @@ void rtw_hal_enable_interrupt(struct rtw
 		padapter->HalFunc.enable_interrupt(padapter);
 	else
 		DBG_8192D("%s: HalFunc.enable_interrupt is NULL!\n", __func__);
-
 }
 void rtw_hal_disable_interrupt(struct rtw_adapter *padapter)
 {
@@ -237,7 +235,6 @@ void rtw_hal_disable_interrupt(struct rt
 		padapter->HalFunc.disable_interrupt(padapter);
 	else
 		DBG_8192D("%s: HalFunc.disable_interrupt is NULL!\n", __func__);
-
 }
 
 u32	rtw_hal_inirp_init(struct rtw_adapter *padapter)
@@ -257,7 +254,6 @@ u32	rtw_hal_inirp_deinit(struct rtw_adap
 		return padapter->HalFunc.inirp_deinit(padapter);
 
 	return _FAIL;
-
 }
 
 u8 rtw_hal_intf_ps_func(struct rtw_adapter *padapter, enum HAL_INTF_PS_FUNC efunc_id, u8* val)
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -46,7 +46,6 @@ CheckWriteH2C(
 		Result = true;
 
 	return Result;
-
 }
 
 static bool
@@ -324,7 +323,7 @@ u8 rtl8192d_set_raid_cmd(struct rtw_adap
 _func_enter_;
 
 	memset(buf, 0, 5);
-	mask = cpu_to_le32( mask );
+	mask = cpu_to_le32(mask);
 	memcpy(buf, &mask, 4);
 	buf[4]  = arg;
 
@@ -333,7 +332,6 @@ _func_enter_;
 _func_exit_;
 
 	return res;
-
 }
 
 //bitmap[0:27] = tx_rate_bitmap
@@ -364,7 +362,6 @@ void rtl8192d_Add_RateATid(struct rtw_ad
 
 		rtw_write8(pAdapter, (REG_INIDATA_RATE_SEL+macid), (u8)init_rate);
 	}
-
 }
 
 
@@ -434,7 +431,7 @@ void ConstructBeacon(struct rtw_adapter
 	pktlen += 2;
 
 
-	if ( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 		DBG_8192D("ie len=%u\n", cur_network->IELength);
 		pktlen += cur_network->IELength - sizeof(struct ndis_802_11_fixed_ies);
@@ -455,7 +452,7 @@ void ConstructBeacon(struct rtw_adapter
 	// DS parameter set
 	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pktlen);
 
-	if ( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
 	{
 		u32 ATIMWindow;
 		// IBSS Parameter Set...
@@ -488,7 +485,6 @@ _ConstructBeacon:
 	*pLength = pktlen;
 
 	//DBG_8192D("%s bcn_sz=%u\n", __func__, pktlen);
-
 }
 
 void ConstructPSPoll(struct rtw_adapter *padapter, u8 *pframe, u32 *pLength);
@@ -637,7 +633,7 @@ FillFakeTxDescriptor92D(
 	memset(pDesc, 0, 32);
 
 	//offset 0
-	ptxdesc->txdw0 |= cpu_to_le32( OWN | FSG | LSG); //own, bFirstSeg, bLastSeg;
+	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG); //own, bFirstSeg, bLastSeg;
 
 	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000); //32 bytes for TX Desc
 
@@ -741,7 +737,7 @@ void SetFwRsvdPagePkt(struct rtw_adapter
 		"SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: PS-POLL\n",
 		&reservedpagepacket[BufIndex-TxDescLen], (PSPollLength+TxDescLen));
 
-	SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(u1RsvdPageLoc, PageNum );
+	SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(u1RsvdPageLoc, PageNum);
 
 //------------------------------------------------------------------
 
@@ -895,14 +891,13 @@ void rtl8192d_set_p2p_ctw_period_cmd(str
 	u8	CTWPeriod = ctwindow;
 
 	FillH2CCmd92D(padapter, H2C_P2P_PS_CTW_CMD, 1, (u8 *)(&CTWPeriod));
-
 }
 
 void rtl8192d_set_p2p_ps_offload_cmd(struct rtw_adapter* padapter, u8 p2p_ps_state)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
-	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 	struct P2P_PS_Offload_t	*p2p_ps_offload = &pHalData->p2p_ps_offload;
 	u8	i;
 	u16	ctwindow;
@@ -919,7 +914,7 @@ _func_enter_;
 		case P2P_PS_ENABLE:
 			DBG_8192D("P2P_PS_ENABLE\n");
 			// update CTWindow value.
-			if ( pwdinfo->ctwindow > 0 )
+			if (pwdinfo->ctwindow > 0)
 			{
 				p2p_ps_offload->CTWindow_En = 1;
 				ctwindow = pwdinfo->ctwindow;
@@ -928,7 +923,7 @@ _func_enter_;
 			}
 
 			// hw only support 2 set of NoA
-			for ( i=0 ; i<pwdinfo->noa_num ; i++)
+			for (i=0 ; i<pwdinfo->noa_num ; i++)
 			{
 				// To control the register setting for which NOA
 				rtw_write8(padapter, 0x5CF, (i << 4));
@@ -948,7 +943,7 @@ _func_enter_;
 				start_time = pwdinfo->noa_start_time[i];
 				if (pwdinfo->noa_count[i] != 1)
 				{
-					while ( start_time <= (tsf_low+(50*1024) ) )
+					while (start_time <= (tsf_low+(50*1024)))
 					{
 						start_time += pwdinfo->noa_interval[i];
 						if (pwdinfo->noa_count[i] != 255)
@@ -961,7 +956,7 @@ _func_enter_;
 				rtw_write8(padapter, 0x5EC, pwdinfo->noa_count[i]);
 			}
 
-			if ( (pwdinfo->opp_ps == 1) || (pwdinfo->noa_num > 0) )
+			if ((pwdinfo->opp_ps == 1) || (pwdinfo->noa_num > 0))
 			{
 				// rst p2p circuit
 				rtw_write8(padapter, REG_DUAL_TSF_RST, BIT(4));
@@ -997,7 +992,6 @@ _func_enter_;
 	FillH2CCmd92D(padapter, H2C_P2P_PS_OFFLOAD, 1, (u8 *)p2p_ps_offload);
 
 _func_exit_;
-
 }
 #endif // CONFIG_P2P_PS
 
@@ -1007,7 +1001,7 @@ _func_exit_;
 /*
 	ask FW to Reset sync register at Beacon early interrupt
 */
-u8 rtl8192d_reset_tsf(struct rtw_adapter *padapter, u8 reset_port )
+u8 rtl8192d_reset_tsf(struct rtw_adapter *padapter, u8 reset_port)
 {
 	u8	buf[2];
 	u8	res=_SUCCESS;
@@ -1025,7 +1019,7 @@ _func_exit_;
 	return res;
 }
 
-int reset_tsf(struct rtw_adapter * Adapter, u8 reset_port )
+int reset_tsf(struct rtw_adapter * Adapter, u8 reset_port)
 {
 	u8 reset_cnt_before = 0, reset_cnt_after = 0, loop_cnt = 0;
 	u32 reg_reset_tsf_cnt = (IFACE_PORT0==reset_port) ?
@@ -1035,7 +1029,7 @@ int reset_tsf(struct rtw_adapter * Adapt
 	reset_cnt_after = reset_cnt_before = rtw_read8(Adapter,reg_reset_tsf_cnt);
 	rtl8192d_reset_tsf(Adapter, reset_port);
 
-	while ((reset_cnt_after == reset_cnt_before ) && (loop_cnt < 10)) {
+	while ((reset_cnt_after == reset_cnt_before) && (loop_cnt < 10)) {
 		rtw_msleep_os(100);
 		loop_cnt++;
 		reset_cnt_after = rtw_read8(Adapter, reg_reset_tsf_cnt);
@@ -1090,18 +1084,18 @@ _func_enter_;
 		rtw_write8(padapter, 0xf8, test);
 
 		pwowlan_parm.mode |=FW_WOWLAN_FUN_EN;
-		//printk("\n %s 1.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode );
+		//printk("\n %s 1.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		if (pwrpriv->wowlan_pattern ==true){
 			pwowlan_parm.mode |= FW_WOWLAN_PATTERN_MATCH;
-		//printk("\n %s 2.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode );
+		//printk("\n %s 2.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		}
 		if (pwrpriv->wowlan_magic ==true){
 			//pwowlan_parm.mode |=FW_WOWLAN_MAGIC_PKT;
-		//printk("\n %s 3.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode );
+		//printk("\n %s 3.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		}
 		if (pwrpriv->wowlan_unicast ==true){
 			pwowlan_parm.mode |=FW_WOWLAN_UNICAST;
-		//printk("\n %s 4.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode );
+		//printk("\n %s 4.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		}
 
 		rtl8192d_set_FwJoinBssReport_cmd(padapter, 1);
@@ -1119,9 +1113,9 @@ _func_enter_;
 
 		pwowlan_parm.second_mode|=FW_WOWLAN_GPIO_WAKEUP_EN;
 		pwowlan_parm.second_mode|=FW_FW_PARSE_MAGIC_PKT;
-		//printk("\n %s 5.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode );
+		//printk("\n %s 5.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		{	u8 *ptr=(u8 *)&pwowlan_parm;
-			printk("\n %s H2C_WO_WLAN=%x %02x:%02x:%02x:%02x:%02x\n",__func__,H2C_WO_WLAN_CMD,ptr[0],ptr[1],ptr[2],ptr[3],ptr[4] );
+			printk("\n %s H2C_WO_WLAN=%x %02x:%02x:%02x:%02x:%02x\n",__func__,H2C_WO_WLAN_CMD,ptr[0],ptr[1],ptr[2],ptr[3],ptr[4]);
 		}
 		FillH2CCmd92D(padapter, H2C_WO_WLAN_CMD, 4, (u8 *)&pwowlan_parm);
 
@@ -1153,7 +1147,6 @@ _func_enter_;
 _func_exit_;
 
 	return ;
-
 }
 
 #endif  //CONFIG_WOWLAN
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -131,7 +131,7 @@ dm_DualMacGetParameterFromBuddyAdapter(
 
 //sherry sync with 92C_92D, 20110701
 	if ((check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) && (!check_fwstate(pmlmepriv, _FW_LINKED))
-		&& (!check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) ))
+		&& (!check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE)))
 		return true;
 	else
 		return false;
@@ -185,11 +185,11 @@ odm_FalseAlarmCounterStatistics_ForSlave
 
 /*
 	RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Fast_Fsync = %d, Cnt_SB_Search_fail = %d\n",
-				falsealmcnt->Cnt_Fast_Fsync , falsealmcnt->Cnt_SB_Search_fail) );
+				falsealmcnt->Cnt_Fast_Fsync , falsealmcnt->Cnt_SB_Search_fail));
 	RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Parity_Fail = %d, Cnt_Rate_Illegal = %d, Cnt_Crc8_fail = %d, Cnt_Mcs_fail = %d\n",
-				falsealmcnt->Cnt_Parity_Fail, falsealmcnt->Cnt_Rate_Illegal, falsealmcnt->Cnt_Crc8_fail, falsealmcnt->Cnt_Mcs_fail) );
+				falsealmcnt->Cnt_Parity_Fail, falsealmcnt->Cnt_Rate_Illegal, falsealmcnt->Cnt_Crc8_fail, falsealmcnt->Cnt_Mcs_fail));
 	RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Ofdm_fail = %d, Cnt_Cck_fail = %d, Cnt_all = %d\n",
-				falsealmcnt->Cnt_Ofdm_fail, falsealmcnt->Cnt_Cck_fail, falsealmcnt->Cnt_all) );
+				falsealmcnt->Cnt_Ofdm_fail, falsealmcnt->Cnt_Cck_fail, falsealmcnt->Cnt_all));
 */
 #endif
 }
@@ -510,7 +510,7 @@ DM_Write_DIG(
 	if (dm_digtable->dig_enable_flag == false)
 		return;
 
-	if ( (dm_digtable->preigvalue != dm_digtable->curigvalue) || ( pAdapter->bForceWriteInitGain ) )
+	if ((dm_digtable->preigvalue != dm_digtable->curigvalue) || (pAdapter->bForceWriteInitGain))
 	{
 		// Set initial gain.
 		// 20100211 Joseph: Set only BIT0~BIT6 for DIG. BIT7 is the function switch of Antenna diversity.
@@ -643,7 +643,7 @@ static void odm_DIG(
 		dm_digtable->rssi_val_min = odm_initial_gain_MinPWDB(pAdapter);
 
 		//2 Modify DIG upper bound
-		if ((dm_digtable->rssi_val_min + 20) > DM_DIG_MAX )
+		if ((dm_digtable->rssi_val_min + 20) > DM_DIG_MAX)
 			dm_digtable->rx_gain_range_max = DM_DIG_MAX;
 		else
 			dm_digtable->rx_gain_range_max = dm_digtable->rssi_val_min + 20;
@@ -688,7 +688,7 @@ static void odm_DIG(
 			dm_digtable->recover_cnt --;
 		else
 		{
-			if (dm_digtable->largefahit == 0 )
+			if (dm_digtable->largefahit == 0)
 			{
 				if ((dm_digtable->forbiddenigi -1) < DIG_Dynamic_MIN) //DM_DIG_MIN)
 				{
@@ -701,7 +701,7 @@ static void odm_DIG(
 					dm_digtable->rx_gain_range_min = (dm_digtable->forbiddenigi + 1);
 				}
 			}
-			else if (dm_digtable->largefahit == 3 )
+			else if (dm_digtable->largefahit == 3)
 			{
 				dm_digtable->largefahit = 0;
 			}
@@ -737,19 +737,19 @@ static void odm_DIG(
 		}
 	} else {
 		//	There is no network interface connects to AP.
-		if ( 0 == dm_digtable->rx_gain_range_min_nolink ) {
+		if (0 == dm_digtable->rx_gain_range_min_nolink) {
 			//	First time to enter odm_DIG function and set the default value to rx_gain_range_min_nolink
 			dm_digtable->rx_gain_range_min_nolink = 0x30;
 		} else {
-			if ( ( falsealmcnt->Cnt_all > 1000 ) && ( falsealmcnt->Cnt_all < 2000 ) ) {
-				dm_digtable->rx_gain_range_min_nolink = ( ( dm_digtable->rx_gain_range_min_nolink + 1 ) > 0x3e ) ?
-							0x3e : ( dm_digtable->rx_gain_range_min_nolink + 1 ) ;
-			} else if ( falsealmcnt->Cnt_all >= 2000 ) {
-				dm_digtable->rx_gain_range_min_nolink = ( ( dm_digtable->rx_gain_range_min_nolink + 2 ) > 0x3e ) ?
-							0x3e : ( dm_digtable->rx_gain_range_min_nolink + 2 ) ;
-			} else if ( falsealmcnt->Cnt_all < 500 ) {
-				dm_digtable->rx_gain_range_min_nolink = ( ( dm_digtable->rx_gain_range_min_nolink - 1 ) < 0x1e ) ?
-							0x1e : ( dm_digtable->rx_gain_range_min_nolink - 1 ) ;
+			if ((falsealmcnt->Cnt_all > 1000) && (falsealmcnt->Cnt_all < 2000)) {
+				dm_digtable->rx_gain_range_min_nolink = ((dm_digtable->rx_gain_range_min_nolink + 1) > 0x3e) ?
+							0x3e : (dm_digtable->rx_gain_range_min_nolink + 1) ;
+			} else if (falsealmcnt->Cnt_all >= 2000) {
+				dm_digtable->rx_gain_range_min_nolink = ((dm_digtable->rx_gain_range_min_nolink + 2) > 0x3e) ?
+							0x3e : (dm_digtable->rx_gain_range_min_nolink + 2) ;
+			} else if (falsealmcnt->Cnt_all < 500) {
+				dm_digtable->rx_gain_range_min_nolink = ((dm_digtable->rx_gain_range_min_nolink - 1) < 0x1e) ?
+							0x1e : (dm_digtable->rx_gain_range_min_nolink - 1) ;
 			}
 		}
 
@@ -762,11 +762,11 @@ static void odm_DIG(
 	if (dm_digtable->curigvalue < dm_digtable->rx_gain_range_min)
 		dm_digtable->curigvalue = dm_digtable->rx_gain_range_min;
 
-	if ( pAdapter->bRxRSSIDisplay )
+	if (pAdapter->bRxRSSIDisplay)
 	{
 		DBG_8192D("Modify DIG algorithm for DMP DIG: RxGainMin = %X, RxGainMax = %X\n",
 			dm_digtable->rx_gain_range_min,
-			dm_digtable->rx_gain_range_max );
+			dm_digtable->rx_gain_range_max);
 	}
 
 	if (IS_HARDWARE_TYPE_8192D(pAdapter))
@@ -874,7 +874,6 @@ static void odm_DIG(
 
 
 	//RT_TRACE(COMP_DIG, DBG_LOUD, ("odm_DIG() <==\n"));
-
 }
 
 static u8
@@ -889,7 +888,7 @@ dm_initial_gain_MinPWDB(
 
 
 	if ((dm_digtable->curmultistaconnectstate == DIG_MultiSTA_CONNECT) &&
-	   (dm_digtable->curstaconnectstate == DIG_STA_CONNECT) ) {
+	   (dm_digtable->curstaconnectstate == DIG_STA_CONNECT)) {
 		if (pdmpriv->EntryMinUndecoratedSmoothedPWDB != 0)
 			rssi_val_min  =  (pdmpriv->EntryMinUndecoratedSmoothedPWDB > pdmpriv->UndecoratedSmoothedPWDB)?
 					pdmpriv->UndecoratedSmoothedPWDB:pdmpriv->EntryMinUndecoratedSmoothedPWDB;
@@ -1086,7 +1085,6 @@ static void dm_CCK_PacketDetectionThresh
 			PHY_SetBBReg(pAdapter, rCCK0_CCA, maskbyte2, 0xcd);
 		dm_digtable->precckpdstate = dm_digtable->curcckpdstate;
 	}
-
 }
 
 static void dm_1R_CCA(struct rtw_adapter *pAdapter)
@@ -1183,8 +1181,8 @@ static void odm_DynamicTxPower_92D(struc
 #endif
 
 	// If dynamic high power is disabled.
-	if ( (pdmpriv->bDynamicTxPowerEnable != true) ||
-		(!(pdmpriv->DMFlag & DYNAMIC_FUNC_HP)) )
+	if ((pdmpriv->bDynamicTxPowerEnable != true) ||
+		(!(pdmpriv->DMFlag & DYNAMIC_FUNC_HP)))
 	{
 		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
 		return;
@@ -1232,7 +1230,7 @@ static void odm_DynamicTxPower_92D(struc
 			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level2 (TxPwr=0x0)\n"));
 		}
 		else if ((UndecoratedSmoothedPWDB <0x33) &&
-			(UndecoratedSmoothedPWDB >= 0x2b) )
+			(UndecoratedSmoothedPWDB >= 0x2b))
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
 			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("5G:TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
@@ -1251,7 +1249,7 @@ static void odm_DynamicTxPower_92D(struc
 			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x0)\n"));
 		}
 		else if ((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
-			(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1) )
+			(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1))
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
 			//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("TxHighPwrLevel_Level1 (TxPwr=0x10)\n"));
@@ -1279,7 +1277,7 @@ static void odm_DynamicTxPower_92D(struc
 	}
 #endif
 
-	if ( (pdmpriv->DynamicTxHighPowerLvl != pdmpriv->LastDTPLvl) )
+	if ((pdmpriv->DynamicTxHighPowerLvl != pdmpriv->LastDTPLvl))
 	{
 		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("PHY_SetTxPowerLevel8192D() Channel = %d\n" , pHalData->CurrentChannel));
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -1329,7 +1327,6 @@ static void odm_DynamicTxPower_92D(struc
 		}
 	}
 	pdmpriv->LastDTPLvl = pdmpriv->DynamicTxHighPowerLvl;
-
 }
 
 
@@ -1494,7 +1491,7 @@ static void dm_CheckEdcaTurbo(struct rtw
 	}
 
 	// Check if the status needs to be changed.
-	if ((bbtchange) || (!precvpriv->bIsAnyNonBEPkts) )
+	if ((bbtchange) || (!precvpriv->bIsAnyNonBEPkts))
 	{
 		cur_tx_bytes = pxmitpriv->tx_bytes - pxmitpriv->last_tx_bytes;
 		cur_rx_bytes = precvpriv->rx_bytes - precvpriv->last_rx_bytes;
@@ -1538,8 +1535,8 @@ static void dm_CheckEdcaTurbo(struct rtw
 					else
 						edca_param = EDCA_BE[trafficIndex];
 				}
-				else if ( (pmlmeinfo->assoc_AP_vendor == atherosAP) &&
-					(pmlmeext->cur_wireless_mode&WIRELESS_11_5N) )
+				else if ((pmlmeinfo->assoc_AP_vendor == atherosAP) &&
+					(pmlmeext->cur_wireless_mode&WIRELESS_11_5N))
 				{
 					if (trafficIndex == DOWN_LINK)
 						edca_param = 0xa42b;
@@ -1577,7 +1574,6 @@ dm_CheckEdcaTurbo_EXIT:
 	precvpriv->bIsAnyNonBEPkts = false;
 	pxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;
 	precvpriv->last_rx_bytes = precvpriv->rx_bytes;
-
 }	// dm_CheckEdcaTurbo
 
 static void dm_InitDynamicBBPowerSaving(
@@ -1633,7 +1629,6 @@ dm_RXGainTrackingCallback_ThermalMeter_9
 	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++){
 		PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_RXRF_A3, bRFRegOffsetMask, (pdmpriv->RegRF3C[eRFPath]&(~(0xF000)))|u4tmp);
 	}
-
 };
 
 //091212 chiyokolin
@@ -2132,7 +2127,6 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 	//RT_TRACE(COMP_POWER_TRACKING, DBG_LOUD,("<===dm_TXPowerTrackingCallback_ThermalMeter_92D\n"));
 
 	pdmpriv->TXPowercount = 0;
-
 }
 
 
@@ -2219,7 +2213,6 @@ dm_CheckTXPowerTracking_ThermalMeter(
 		DM_TXPowerTracking92CDirectCall(Adapter); //Using direct call is instead, added by Roger, 2009.06.18.
 		pdmpriv->TM_Trigger = 0;
 	}
-
 }
 
 
@@ -2257,7 +2250,6 @@ dm_CheckRfCtrlGPIO(
 	struct rtw_adapter *	Adapter
 	)
 {
-
 }	/* dm_CheckRfCtrlGPIO */
 
 /*-----------------------------------------------------------------------------
@@ -2316,14 +2308,14 @@ static void	dm_CheckPbcGPIO(struct rtw_a
 	}
 	}while (i<=3 && bPbcPressed == true);
 
-	if ( true == bPbcPressed)
+	if (true == bPbcPressed)
 	{
 		// Here we only set bPbcPressed to true
 		// After trigger PBC, the variable will be set to false
 		DBG_8192D("CheckPbcGPIO - PBC is pressed, try_cnt=%d\n", i-1);
 
 
-		if ( padapter->pid[0] == 0 )
+		if (padapter->pid[0] == 0)
 		{	//	0 is the default value and it means the application monitors the HW PBC doesn't privde its pid to driver.
 			return;
 		}
@@ -2395,7 +2387,6 @@ dm_InitGPIOSetting(
 	tmp1byte = rtw_read8(Adapter, REG_GPIO_MUXCFG);
 	tmp1byte &= (GPIOSEL_GPIO | ~GPIOSEL_ENBT);
 	rtw_write8(Adapter, REG_GPIO_MUXCFG, tmp1byte);
-
 }
 
 //============================================================
@@ -2407,14 +2398,12 @@ void rtl8192d_init_dm_priv(struct rtw_ad
 	//struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
 	//memset(pdmpriv, 0, sizeof(struct dm_priv));
-
 }
 
 void rtl8192d_deinit_dm_priv(struct rtw_adapter * Adapter)
 {
 	//struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	//struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-
 }
 
 void
@@ -2599,7 +2588,7 @@ rtl8192d_HalDmWatchDog(
 	// 4. RFChangeInProgress is TRUE. (Prevent from broken by IPS/HW/SW Rf off.)
 	// Noted by tynli. 2010.06.01.
 	//if (rfState == eRfOn)
-	if ( (hw_init_completed == true)
+	if ((hw_init_completed == true)
 		&& ((!bFwCurrentInPSMode) && bFwPSAwake))
 	{
 		//
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -73,7 +73,7 @@ _FWDownloadEnable(
 		#ifdef DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE
 		{
 			u8 val;
-			if ( (val=rtw_read8(Adapter, REG_MCUFWDL)))
+			if ((val=rtw_read8(Adapter, REG_MCUFWDL)))
 				DBG_8192D("DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE %s:%d REG_MCUFWDL:0x%02x\n", __func__, __LINE__, val);
 		}
 		#endif
@@ -182,7 +182,7 @@ _PageWrite(
 	u8 value8;
 	u8 u8Page = (u8) (page & 0x07) ;
 
-	value8 = (rtw_read8(Adapter, REG_MCUFWDL+2)& 0xF8 ) | u8Page ;
+	value8 = (rtw_read8(Adapter, REG_MCUFWDL+2)& 0xF8) | u8Page ;
 	rtw_write8(Adapter, REG_MCUFWDL+2,value8);
 	return _BlockWrite_92d(Adapter,buffer,size);
 }
@@ -236,7 +236,7 @@ int _FWFreeToGo_92D(
 	// polling CheckSum report
 	do{
 		value32 = rtw_read32(Adapter, REG_MCUFWDL);
-	}while ((counter ++ < POLLING_READY_TIMEOUT_COUNT) && (!(value32 & FWDL_ChkSum_rpt  )));
+	}while ((counter ++ < POLLING_READY_TIMEOUT_COUNT) && (!(value32 & FWDL_ChkSum_rpt )));
 
 	if (counter >= POLLING_READY_TIMEOUT_COUNT){
 		DBG_8192D("chksum report faill ! REG_MCUFWDL:0x%08x .\n",value32);
@@ -248,7 +248,6 @@ int _FWFreeToGo_92D(
 	value32 |= MCUFWDL_RDY;
 	rtw_write32(Adapter, REG_MCUFWDL, value32);
 	return _SUCCESS;
-
 }
 
 void
@@ -335,15 +334,14 @@ int _FWInit(
 	}while (counter++ < POLLING_READY_TIMEOUT_COUNT);
 
 	if (pHalData->interfaceIndex==0){
-		DBG_8192D("Polling FW ready fail!! MAC0 FW init not ready:0x%x .\n",rtw_read8(Adapter, FW_MAC0_ready) );
+		DBG_8192D("Polling FW ready fail!! MAC0 FW init not ready:0x%x .\n",rtw_read8(Adapter, FW_MAC0_ready));
 	}
 	else{
-		DBG_8192D("Polling FW ready fail!! MAC1 FW init not ready:0x%x .\n",rtw_read8(Adapter, FW_MAC1_ready) );
+		DBG_8192D("Polling FW ready fail!! MAC1 FW init not ready:0x%x .\n",rtw_read8(Adapter, FW_MAC1_ready));
 	}
 
 	DBG_8192D("Polling FW ready fail!! REG_MCUFWDL:0x%x .\n",rtw_read32(Adapter, REG_MCUFWDL));
 	return _FAIL;
-
 }
 
 #ifdef CONFIG_FILE_FWIMG
@@ -433,7 +431,7 @@ int FirmwareDownload92D(
 #if 0
 			if (ImgArrayLength > FW_8192C_SIZE){
 				rtStatus = _FAIL;
-				//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Firmware size exceed 0x%X. Check it.\n", FW_8192C_SIZE) );
+				//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Firmware size exceed 0x%X. Check it.\n", FW_8192C_SIZE));
 				goto Exit;
 			}
 #endif
@@ -602,7 +600,6 @@ Exit:
 
 	//RT_TRACE(COMP_INIT, DBG_LOUD, (" <=== FirmwareDownload91C()\n"));
 	return rtStatus;
-
 }
 
 #ifdef CONFIG_WOWLAN
@@ -729,12 +726,11 @@ rtl8192d_ReadChipVersion(
 	}
 	else
 	{
-		ChipVersion = (enum VERSION_8192D)( ChipVersion | NORMAL_CHIP);
+		ChipVersion = (enum VERSION_8192D)(ChipVersion | NORMAL_CHIP);
 		DBG_8192D("Normal CHIP!!!\n");
 	}
 
 	pHalData->VersionID = ChipVersion;
-
 }
 
 //-------------------------------------------------------------------------
@@ -1094,7 +1090,6 @@ rtl8192d_ReadTxPowerInfo(
 	}
 
 #endif
-
 }
 
 //
@@ -1135,7 +1130,6 @@ void rtl8192d_ResetDualMacSwitchVariable
 	Adapter->DualMacRoleToSet.bMasterOfDMSP = Adapter->bMasterOfDMSP;
 	Adapter->DualMacRoleToSet.bSlaveOfDMSP = Adapter->bSlaveOfDMSP;*/
 #endif //CONFIG_DUALMAC_CONCURRENT
-
 }
 
 u8 GetEEPROMSize8192D(struct rtw_adapter * Adapter)
@@ -1311,7 +1305,7 @@ rtl8192d_EfusePowerSwitch(
 
 		// Clock: Gated(0x0008h[5]) 8M(0x0008h[1]) clock from ANA, default valid
 		tmpV16 = rtw_read16(pAdapter, REG_SYS_CLKR);
-		if ( (!(tmpV16 & LOADER_CLK_EN)) || (!(tmpV16 & ANA8M)) ){
+		if ((!(tmpV16 & LOADER_CLK_EN)) || (!(tmpV16 & ANA8M))){
 			tmpV16 |= (LOADER_CLK_EN | ANA8M);
 			rtw_write16(pAdapter, REG_SYS_CLKR, tmpV16);
 		}
@@ -1392,12 +1386,12 @@ ReadEFuse_RTL8192D(
 	while ((*rtemp8 != 0xFF) && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN))
 	{
 		// Check PG header for section num.
-		if ((*rtemp8 & 0x1F ) == 0x0F)		//extended header
+		if ((*rtemp8 & 0x1F) == 0x0F)		//extended header
 		{
 
 			//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("extended header u1temp=%x *rtemp&0xE0 0x%x\n", u1temp, *rtemp8 & 0xE0));
 
-			u1temp =( (*rtemp8 & 0xE0) >> 5);
+			u1temp =((*rtemp8 & 0xE0) >> 5);
 
 			//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("extended header u1temp=%x\n", u1temp));
 
@@ -1525,21 +1519,21 @@ hal_EfuseUpdateNormalChipVersion_92D(
 	switch (ChipValue){
 		case 0xAA55:
 			//ChipVer |= CHIP_92D_C_CUT;
-			ChipVer = (enum VERSION_8192D)( ChipVer | C_CUT_VERSION);
+			ChipVer = (enum VERSION_8192D)(ChipVer | C_CUT_VERSION);
 			MSG_8192D("C-CUT!!!\n");
 			break;
 		case 0x9966:
 			//ChipVer |= CHIP_92D_D_CUT;
-			ChipVer = (enum VERSION_8192D)( ChipVer | D_CUT_VERSION);
+			ChipVer = (enum VERSION_8192D)(ChipVer | D_CUT_VERSION);
 			MSG_8192D("D-CUT!!!\n");
 			break;
 		case 0xCC33:
-			ChipVer = (enum VERSION_8192D)( ChipVer | E_CUT_VERSION);
+			ChipVer = (enum VERSION_8192D)(ChipVer | E_CUT_VERSION);
 			MSG_8192D("E-CUT!!!\n");
 			break;
 		default:
 			//ChipVer |= CHIP_92D_D_CUT;
-			ChipVer = (enum VERSION_8192D)( ChipVer | D_CUT_VERSION);
+			ChipVer = (enum VERSION_8192D)(ChipVer | D_CUT_VERSION);
 			MSG_8192D("Unkown CUT!\n");
 			break;
 	}
@@ -1678,7 +1672,7 @@ rtl8192d_EfuseGetCurrentSize(
 
 	while (	bContinual &&
 			efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) &&
-			(efuse_addr  < EFUSE_REAL_CONTENT_LEN) )
+			(efuse_addr  < EFUSE_REAL_CONTENT_LEN))
 	{
 		if (efuse_data!=0xFF)
 		{
@@ -1714,7 +1708,6 @@ rtl8192d_EfuseGetCurrentSize(
 	}
 
 	return efuse_addr;
-
 }
 
 static int
@@ -1749,7 +1742,7 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 	// Skip dummy parts to prevent unexpected data read from Efuse.
 	// By pass right now. 2009.02.19.
 	//
-	while (bContinual && (efuse_addr  < EFUSE_REAL_CONTENT_LEN) )
+	while (bContinual && (efuse_addr  < EFUSE_REAL_CONTENT_LEN))
 	{
 		//-------  Header Read -------------
 		if (ReadState & PG_STATE_HEADER)
@@ -1783,7 +1776,7 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 
 				if (hoffset==offset){
 					for (tmpidx = 0;tmpidx< word_cnts*2 ;tmpidx++){
-						if (efuse_OneByteRead(pAdapter, efuse_addr+1+tmpidx ,&efuse_data, bPseudoTest) ){
+						if (efuse_OneByteRead(pAdapter, efuse_addr+1+tmpidx ,&efuse_data, bPseudoTest)){
 							tmpdata[tmpidx] = efuse_data;
 							if (efuse_data!=0xff){
 								bDataEmpty = false;
@@ -1825,7 +1818,6 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 		return false;
 	else
 		return true;
-
 }
 
 static int
@@ -1869,7 +1861,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 	// (i.e., offset 0~497, and dummy 1bytes) expected after CP test.
 	// 2009.02.19.
 	//
-	if ( Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest) >= (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))
+	if (Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest) >= (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))
 	{
 		//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite error\n"));
 		return false;
@@ -1896,7 +1888,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 	// incorrect data auto-load from HW. Dummy 1bytes is additional.
 	// 2009.02.19.
 	//
-	while ( bContinual && (efuse_addr  < (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES)) )
+	while (bContinual && (efuse_addr  < (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES)))
 	{
 
 		if (WriteState==PG_STATE_HEADER)
@@ -1969,19 +1961,19 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 						//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite section data empty\n"));
 
 						match_word_en = 0x0F;			//same bit as original wren
-						if (   !( (target_pkt.word_en&BIT0)|(tmp_pkt.word_en&BIT0)  ))
+						if (  !((target_pkt.word_en&BIT0)|(tmp_pkt.word_en&BIT0) ))
 						{
 							 match_word_en &= (~BIT0);
 						}
-						if (   !( (target_pkt.word_en&BIT1)|(tmp_pkt.word_en&BIT1)  ))
+						if (  !((target_pkt.word_en&BIT1)|(tmp_pkt.word_en&BIT1) ))
 						{
 							 match_word_en &= (~BIT1);
 						}
-						if (   !( (target_pkt.word_en&BIT2)|(tmp_pkt.word_en&BIT2)  ))
+						if (  !((target_pkt.word_en&BIT2)|(tmp_pkt.word_en&BIT2) ))
 						{
 							 match_word_en &= (~BIT2);
 						}
-						if (   !( (target_pkt.word_en&BIT3)|(tmp_pkt.word_en&BIT3)  ))
+						if (  !((target_pkt.word_en&BIT3)|(tmp_pkt.word_en&BIT3) ))
 						{
 							 match_word_en &= (~BIT3);
 						}
@@ -2002,19 +1994,19 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 							//############################
 
 							tmp_word_en = 0x0F;		//not the same bit as original wren
-							if (  (target_pkt.word_en&BIT0)^(match_word_en&BIT0)  )
+							if ( (target_pkt.word_en&BIT0)^(match_word_en&BIT0) )
 							{
 								tmp_word_en &= (~BIT0);
 							}
-							if (   (target_pkt.word_en&BIT1)^(match_word_en&BIT1) )
+							if (  (target_pkt.word_en&BIT1)^(match_word_en&BIT1))
 							{
 								tmp_word_en &=  (~BIT1);
 							}
-							if (   (target_pkt.word_en&BIT2)^(match_word_en&BIT2) )
+							if (  (target_pkt.word_en&BIT2)^(match_word_en&BIT2))
 							{
 								tmp_word_en &= (~BIT2);
 							}
-							if (   (target_pkt.word_en&BIT3)^(match_word_en&BIT3) )
+							if (  (target_pkt.word_en&BIT3)^(match_word_en&BIT3))
 							{
 								tmp_word_en &=(~BIT3);
 							}
@@ -2091,7 +2083,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 					{
 						efuse_addr++;
 						pg_header_temp = pg_header;
-						pg_header = ((target_pkt.offset & 0x78) << 1 ) | target_pkt.word_en;
+						pg_header = ((target_pkt.offset & 0x78) << 1) | target_pkt.word_en;
 
 						//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_PgPacketWrite extended pg_header[6:3] | worden 0x%x word_en 0x%x\n", pg_header));
 
@@ -2178,7 +2170,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 					//memset(originaldata,0xff,sizeof(UINT8)*8);
 					memset((void *)originaldata, 0xff, sizeof(u8)*8);
 
-					if (Efuse_PgPacketRead( pAdapter, tmp_pkt.offset,originaldata, bPseudoTest))
+					if (Efuse_PgPacketRead(pAdapter, tmp_pkt.offset,originaldata, bPseudoTest))
 					{	//check if data exist
 						//efuse_reg_ctrl(pAdapter,true);//power on
 						badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,tmp_pkt.word_en,originaldata, bPseudoTest);
@@ -2296,7 +2288,7 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 		efuse_OneByteRead(pAdapter,tmpaddr    , &tmpdata[2], bPseudoTest);
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[3], bPseudoTest);
 		if ((data[2]!=tmpdata[2])||(data[3]!=tmpdata[3])){
-			badworden &=( ~BIT1);
+			badworden &=(~BIT1);
 		}
 	}
 	if (!(word_en&BIT2))
@@ -2308,7 +2300,7 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[4], bPseudoTest);
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[5], bPseudoTest);
 		if ((data[4]!=tmpdata[4])||(data[5]!=tmpdata[5])){
-			badworden &=( ~BIT2);
+			badworden &=(~BIT2);
 		}
 	}
 	if (!(word_en&BIT3))
@@ -2320,7 +2312,7 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[6], bPseudoTest);
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[7], bPseudoTest);
 		if ((data[6]!=tmpdata[6])||(data[7]!=tmpdata[7])){
-			badworden &=( ~BIT3);
+			badworden &=(~BIT3);
 		}
 	}
 	return badworden;
--- a/drivers/staging/rtl8192du/hal/rtl8192d_mp.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_mp.c
@@ -31,7 +31,7 @@
 #define dm_CheckTXPowerTracking(a)	rtl8192d_dm_CheckTXPowerTracking(a)
 #define PHY_SetRFPathSwitch(a,b)	rtl8192d_PHY_SetRFPathSwitch(a,b)
 
-void Hal_MptSet8256CCKTxPower( PADAPTER pAdapter,u8 *pTxPower)
+void Hal_MptSet8256CCKTxPower(PADAPTER pAdapter,u8 *pTxPower)
 {
 	u8				TxAGC[2]={0, 0};
 	u32			 tmpval=0;
@@ -50,7 +50,6 @@ void Hal_MptSet8256CCKTxPower( PADAPTER
 
 	tmpval = (TxAGC[RF_PATH_B]<<16)|(TxAGC[RF_PATH_B]<<8)|(TxAGC[RF_PATH_B]);
 	PHY_SetBBReg(pAdapter, rTxAGC_B_CCK1_55_Mcs32, 0xffffff00, tmpval);
-
 }
 
 
@@ -85,7 +84,6 @@ void Hal_MptSet8256OFDMTxPower(PADAPTER
 	PHY_SetBBReg(pAdapter, rTxAGC_B_Mcs15_Mcs12, bMaskDWord, TxAGC);
 
 
-
 }
 
 
@@ -312,8 +310,8 @@ void Hal_SetCarrierSuppressionTx(PADAPTE
     if (bStart)
     { // Start Carrier Suppression.
         //if (pMgntInfo->dot11CurrentWirelessMode == WIRELESS_MODE_B)
-        if ( pMptCtx->MptRateIndex >= MPT_RATE_1M &&
-            pMptCtx->MptRateIndex <= MPT_RATE_11M )
+        if (pMptCtx->MptRateIndex >= MPT_RATE_1M &&
+            pMptCtx->MptRateIndex <= MPT_RATE_11M)
         { // Start CCK Carrier Suppression
             // 1. if CCK block on?
             if (!PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bCCKEn))
@@ -334,8 +332,8 @@ void Hal_SetCarrierSuppressionTx(PADAPTE
     else
     { // Stop Carrier Suppression.
         //if (pMgntInfo->dot11CurrentWirelessMode == WIRELESS_MODE_B)
-        if ( pMptCtx->MptRateIndex >= MPT_RATE_1M &&
-            pMptCtx->MptRateIndex <= MPT_RATE_11M )
+        if (pMptCtx->MptRateIndex >= MPT_RATE_1M &&
+            pMptCtx->MptRateIndex <= MPT_RATE_11M)
         { // Stop Carrier Suppression
             PHY_SetBBReg(pAdapter, rCCK0_System, bCCKBBMode, 0x0);    //normal mode
             PHY_SetBBReg(pAdapter, rCCK0_System, bCCKScramble, 0x1);  //turn on scramble setting
@@ -345,11 +343,10 @@ void Hal_SetCarrierSuppressionTx(PADAPTE
             PHY_SetBBReg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
         }
     }
-
 }
 
 
-void Hal_SetSingleToneTx ( PADAPTER pAdapter , u8 bStart )
+void Hal_SetSingleToneTx (PADAPTER pAdapter , u8 bStart)
 {
    // PMGNT_INFO          pMgntInfo = &(pAdapter->MgntInfo);
     HAL_DATA_TYPE       *pHalData   = GET_HAL_DATA(pAdapter);
@@ -418,7 +415,6 @@ void Hal_SetSingleToneTx ( PADAPTER pAda
 		PHY_SetBBReg(pAdapter, rOFDM1_LSTF, BIT30|BIT29|BIT28, OFDM_ALL_OFF);
 
     }
-
 }
 
 
@@ -449,7 +445,7 @@ s32 Hal_SetThermalMeter(PADAPTER pAdapte
 }
 
 
-void Hal_TriggerRFThermalMeter( PADAPTER pAdapter )
+void Hal_TriggerRFThermalMeter(PADAPTER pAdapter)
 {
    // PADAPTER			  pAdapter = (PADAPTER)Context;
 	PHY_SetRFReg(pAdapter, RF_PATH_A, RF_T_METER, BIT17 | BIT16, 0x03);
@@ -539,7 +535,7 @@ void Hal_SetSingleCarrierTx (PADAPTER pA
     u8              CurrChannel = pAdapter->mppriv.channel;
      PMPT_CONTEXT        pMptCtx = &(pAdapter->mppriv.MptCtx);
 
-    if ( bStart )
+    if (bStart)
     {// Start Single Carrier.
         // 1. if OFDM block on?
         if (!PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bOFDMEn))
@@ -617,7 +613,6 @@ static  void Hal_mpt_StartCckContTx(PADA
 
     pMptCtx->bCckContTx = true;
     pMptCtx->bOfdmContTx = false;
-
 }   /* mpt_StartCckContTx */
 
 
@@ -637,11 +632,10 @@ static  void Hal_mpt_StopCckCoNtTx(PADAP
     //BB Reset
     PHY_SetBBReg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
     PHY_SetBBReg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
-
 }   /* mpt_StopCckCoNtTx */
 
 
-static  void Hal_mpt_StartOfdmContTx( PADAPTER pAdapter )
+static  void Hal_mpt_StartOfdmContTx(PADAPTER pAdapter)
 {
 
     HAL_DATA_TYPE   *pHalData   = GET_HAL_DATA(pAdapter);
@@ -671,11 +665,10 @@ static  void Hal_mpt_StartOfdmContTx( PA
     pMptCtx->bCckContTx = false;
     pMptCtx->bOfdmContTx = true;
     //pMptCtx->bCtxTriggerPktSent = false;
-
 }   /* mpt_StartOfdmContTx */
 
 
-static  void Hal_mpt_StopOfdmContTx( PADAPTER pAdapter)
+static  void Hal_mpt_StopOfdmContTx(PADAPTER pAdapter)
 {
     HAL_DATA_TYPE   *pHalData   = GET_HAL_DATA(pAdapter);
     PMPT_CONTEXT        pMptCtx = &(pAdapter->mppriv.MptCtx);
@@ -693,7 +686,6 @@ static  void Hal_mpt_StopOfdmContTx( PAD
     //BB Reset
     PHY_SetBBReg(pAdapter, rPMAC_Reset, bBBResetB, 0x0);
     PHY_SetBBReg(pAdapter, rPMAC_Reset, bBBResetB, 0x1);
-
 }   /* mpt_StopOfdmContTx */
 
 
@@ -704,11 +696,11 @@ void Hal_SetContinuousTx (PADAPTER pAdap
 
     if (bStart)
     { // Start Continuous Tx.
-        if ( pAdapter->mppriv.rateidx >= MPT_RATE_1M &&
-            pAdapter->mppriv.rateidx <= MPT_RATE_11M )
+        if (pAdapter->mppriv.rateidx >= MPT_RATE_1M &&
+            pAdapter->mppriv.rateidx <= MPT_RATE_11M)
             Hal_mpt_StartCckContTx(pAdapter, true);
         else if (pAdapter->mppriv.rateidx >= MPT_RATE_6M &&
-                pAdapter->mppriv.rateidx <= MPT_RATE_MCS15 )
+                pAdapter->mppriv.rateidx <= MPT_RATE_MCS15)
             Hal_mpt_StartOfdmContTx(pAdapter);
         else
         {
@@ -740,7 +732,6 @@ void Hal_SetContinuousTx (PADAPTER pAdap
 
         }
     }
-
 }
 
 
@@ -766,7 +757,7 @@ u4Byte RT8192DU_Reg_Offset_Conver(PADAPT
 	//{
 		if (offset < 0x1000)
 			offset|=0x4000;
-		else if ( (offset&MAC1_ACCESS_PHY0) && !(offset&0x8000))// MAC1 need to access PHY0
+		else if ((offset&MAC1_ACCESS_PHY0) && !(offset&0x8000))// MAC1 need to access PHY0
 			offset &= 0xFFF;
 	//}
 
@@ -909,7 +900,6 @@ phy_RestoreRFENV(
 			break;
 	}
 	//RT_TRACE(COMP_RF, DBG_LOUD, ("<=====phy_RestoreRFENV\n"));
-
 }
 
 void
@@ -954,7 +944,6 @@ phy_EnableRFENV(
 	rtw_msleep_os(1);
 
 	//RT_TRACE(COMP_RF, DBG_LOUD, ("<====phy_EnableRFENV\n"));
-
 }
 
 
@@ -1036,7 +1025,7 @@ void
 			index = 2;
 		else if (channel == 151 || channel == 153 || channel == 163 || channel == 165)
 			index = 3;
-		else if (channel == 157 || channel == 159 )
+		else if (channel == 157 || channel == 159)
 			index = 4;
 
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
@@ -1235,7 +1224,6 @@ void
 	}
 
 	//RT_TRACE(COMP_CMD, DBG_LOUD, ("<====phy_SwitchRfSetting8192D interface %u\n", Adapter->interfaceIndex));
-
 }
 
 void Hal_mpt_SwitchRfSetting(PADAPTER pAdapter)
@@ -1308,8 +1296,8 @@ void MPT_CCKTxPowerAdjust(PADAPTER Adapt
 		// get the current swing index
 		for (i=0 ; i<CCK_TABLE_SIZE ; i++)
 		{
-			if ( ((CurrCCKSwingVal&0xff) == (u4Byte)CCKSwingTable_Ch1_Ch13[i][0]) &&
-				( ((CurrCCKSwingVal&0xff00)>>8) == (u4Byte)CCKSwingTable_Ch1_Ch13[i][1]) )
+			if (((CurrCCKSwingVal&0xff) == (u4Byte)CCKSwingTable_Ch1_Ch13[i][0]) &&
+				(((CurrCCKSwingVal&0xff00)>>8) == (u4Byte)CCKSwingTable_Ch1_Ch13[i][1]))
 			{
 				CCKSwingIndex = i;
 				//RT_TRACE(COMP_INIT, DBG_LOUD,("Ch1~13, Current reg0x%x = 0x%lx, CCKSwingIndex=0x%x\n", (rCCK0_TxFilter1+2), CurrCCKSwingVal, CCKSwingIndex));
@@ -1326,7 +1314,7 @@ void MPT_CCKTxPowerAdjust(PADAPTER Adapt
 		TempVal2 = 0;
 		TempVal2 =	CCKSwingTable_Ch1_Ch13[CCKSwingIndex][2] +
 					(CCKSwingTable_Ch1_Ch13[CCKSwingIndex][3]<<8) +
-					(CCKSwingTable_Ch1_Ch13[CCKSwingIndex][4]<<16 )+
+					(CCKSwingTable_Ch1_Ch13[CCKSwingIndex][4]<<16)+
 					(CCKSwingTable_Ch1_Ch13[CCKSwingIndex][5]<<24);
 
 		//Write 0xa28  0xa29
@@ -1340,8 +1328,8 @@ void MPT_CCKTxPowerAdjust(PADAPTER Adapt
 	{
 		for (i=0 ; i<CCK_TABLE_SIZE ; i++)
 		{
-			if ( ((CurrCCKSwingVal&0xff) == (u4Byte)CCKSwingTable_Ch14[i][0]) &&
-				( ((CurrCCKSwingVal&0xff00)>>8) == (u4Byte)CCKSwingTable_Ch14[i][1]) )
+			if (((CurrCCKSwingVal&0xff) == (u4Byte)CCKSwingTable_Ch14[i][0]) &&
+				(((CurrCCKSwingVal&0xff00)>>8) == (u4Byte)CCKSwingTable_Ch14[i][1]))
 			{
 				CCKSwingIndex = i;
 				//RT_TRACE(COMP_INIT, DBG_LOUD,("Ch14, Current reg0x%x = 0x%lx, CCKSwingIndex=0x%x\n", (rCCK0_TxFilter1+2), CurrCCKSwingVal, CCKSwingIndex));
@@ -1357,7 +1345,7 @@ void MPT_CCKTxPowerAdjust(PADAPTER Adapt
 		TempVal2= 0;
 		TempVal2 =	CCKSwingTable_Ch14[CCKSwingIndex][2] +
 					(CCKSwingTable_Ch14[CCKSwingIndex][3]<<8) +
-					(CCKSwingTable_Ch14[CCKSwingIndex][4]<<16 )+
+					(CCKSwingTable_Ch14[CCKSwingIndex][4]<<16)+
 					(CCKSwingTable_Ch14[CCKSwingIndex][5]<<24);
 
 		//Write 0xa28  0xa29
@@ -1372,7 +1360,6 @@ void MPT_CCKTxPowerAdjust(PADAPTER Adapt
 	//RTPRINT(FMP, MP_SWICH_CH, ("0xA24=0x%x\n", TempVal2));
 	PHY_SetBBReg(Adapter, rCCK0_DebugPort,bMaskLWord, TempVal3);
 	//RTPRINT(FMP, MP_SWICH_CH, ("0xA28=0x%x\n", TempVal3));
-
 }
 
 
@@ -1628,7 +1615,6 @@ void Hal_ProSetCrystalCap (PADAPTER pAda
 
 	PHY_SetBBReg(pAdapter, 0x24, 0xF0, CrystalCapVal & 0x0F);
 	PHY_SetBBReg(pAdapter, 0x28, 0xF0000000, (CrystalCapVal & 0xF0) >> 4);
-
 }
 
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
@@ -184,7 +184,7 @@ phy_CalculateBitShift(
 
 	for (i=0; i<=31; i++)
 	{
-		if ( ((BitMask>>i) &  0x1 ) == 1)
+		if (((BitMask>>i) &  0x1) == 1)
 			break;
 	}
 
@@ -219,7 +219,6 @@ rtl8192d_PHY_SetBBReg1Byte(
 
 	rtw_write8(Adapter, RegAddr+offset, value);
 	//RT_TRACE(COMP_INIT,DBG_TRACE,("Write Reg0x800 originalvalue %x  to set 1byte value %x Data %x offset %x\n",OriginalValue,value,Data,offset));
-
 }
 
 /**
@@ -295,7 +294,6 @@ rtl8192d_PHY_SetBBReg(
 	}
 
 	rtw_write32(Adapter, RegAddr, Data);
-
 }
 
 //
@@ -326,7 +324,6 @@ phy_FwRFSerialRead(
 	u32		retValue = 0;
 	//RT_ASSERT(FALSE,("deprecate!\n"));
 	return	(retValue);
-
 }	/* phy_FwRFSerialRead */
 
 
@@ -451,7 +448,6 @@ phy_RFSerialRead(
 	//RTPRINT(FPHY, PHY_RFR, ("RFR-%d Addr[0x%lx]=0x%lx\n", eRFPath, pPhyReg->rfLSSIReadBack, retValue));
 
 	return retValue;
-
 }
 
 
@@ -551,7 +547,6 @@ phy_RFSerialWrite(
 	//
 	PHY_SetBBReg(Adapter, pPhyReg->rf3wireOffset|MaskforPhySet, bMaskDWord, DataAndAddr);
 	//RTPRINT(FPHY, PHY_RFW, ("RFW-%d Addr[0x%lx]=0x%lx\n", eRFPath, pPhyReg->rf3wireOffset, DataAndAddr));
-
 }
 
 
@@ -591,7 +586,7 @@ rtl8192d_PHY_QueryRFReg(
 		return 0;
 
 	if (pHalData->bReadRFbyFW)
-		Original_Value = rtw_read32(Adapter,(0x66<<24|eRFPath<<16)|RegAddr ); //0x66 Just a identifier.by wl
+		Original_Value = rtw_read32(Adapter,(0x66<<24|eRFPath<<16)|RegAddr); //0x66 Just a identifier.by wl
 	else
 		Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
 
@@ -725,7 +720,6 @@ phy_ConfigMACWithHeaderFile(
 	}
 
 	return _SUCCESS;
-
 }
 
 /*-----------------------------------------------------------------------------
@@ -785,7 +779,6 @@ PHY_MACConfig8192D(
 		rtw_write8(Adapter, REG_MAX_AGGR_NUM, 0x07); //92D need to test to decide the num.
 
 	return rtStatus;
-
 }
 
 
@@ -1044,7 +1037,6 @@ phy_ConfigBBWithHeaderFile(
 	}
 
 	return _SUCCESS;
-
 }
 
 /*-----------------------------------------------------------------------------
@@ -1251,7 +1243,6 @@ phy_ConfigBBWithPgHeaderFile(
 	}
 
 	return _SUCCESS;
-
 }	/* phy_ConfigBBWithPgHeaderFile */
 #endif
 
@@ -1283,7 +1274,6 @@ phy_ConfigBBWithPgParaFile(
 
 
 	return rtStatus;
-
 }	/* phy_ConfigBBWithPgParaFile */
 #endif //CONFIG_EMBEDDED_FWIMG
 #if MP_DRIVER == 1
@@ -1314,7 +1304,6 @@ phy_ConfigBBWithMpParaFile(
 	int	rtStatus = _SUCCESS;
 
 	return rtStatus;
-
 }
 #else
 /*-----------------------------------------------------------------------------
@@ -1379,7 +1368,6 @@ phy_ConfigBBWithMpHeaderFile(
 		//RT_TRACE(COMP_SEND, DBG_LOUD, ("phy_ConfigBBWithMpHeaderFile(): ConfigType != BaseBand_Config_PHY_REG\n"));
 	}
 	return _SUCCESS;
-
 }	/* phy_ConfigBBWithPgHeaderFile */
 
 #endif
@@ -1652,7 +1640,6 @@ rtl8192d_PHY_ConfigRFWithParaFile(
 
 
 	return rtStatus;
-
 }
 
 //****************************************
@@ -1817,7 +1804,6 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 	}
 
 	return _SUCCESS;
-
 }
 
 
@@ -2240,7 +2226,6 @@ rtl8192d_PHY_SetBeaconHwReg(
 	u16			BeaconInterval
 	)
 {
-
 }
 
 
@@ -2417,7 +2402,7 @@ _PHY_SetBWMode92D(
 	}
 #endif
 
-	//RT_TRACE(COMP_SCAN, DBG_LOUD, ("<==PHY_SetBWModeCallback8192C()\n" ));
+	//RT_TRACE(COMP_SCAN, DBG_LOUD, ("<==PHY_SetBWModeCallback8192C()\n"));
 }
 
  /*-----------------------------------------------------------------------------
@@ -2491,7 +2476,6 @@ PHY_SetBWMode8192D(
 		//pHalData->SetBWModeInProgress= FALSE;
 		pHalData->CurrentChannelBW = tmpBW;
 	}
-
 }
 
 
@@ -2699,7 +2683,6 @@ PHY_EnableRFENV(
 	rtw_udelay_os(1);
 
 	//RT_TRACE(COMP_RF, DBG_LOUD, ("<====PHY_EnableRFENV\n"));
-
 }
 
 static void
@@ -2728,7 +2711,6 @@ PHY_RestoreRFENV(
 			break;
 	}
 	//RT_TRACE(COMP_RF, DBG_LOUD, ("<=====PHY_RestoreRFENV\n"));
-
 }
 
 
@@ -2791,7 +2773,7 @@ PHY_RestoreRFENV(
 			index = 2;
 		else if (channel == 151 || channel == 153 || channel == 163 || channel == 165)
 			index = 3;
-		else if (channel == 157 || channel == 159 )
+		else if (channel == 157 || channel == 159)
 			index = 4;
 
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
@@ -2986,7 +2968,6 @@ PHY_RestoreRFENV(
 	}
 
 	//RT_TRACE(COMP_CMD, DBG_LOUD, ("<====phy_SwitchRfSetting interface %d\n", pHalData->interfaceIndex));
-
 }
 
 
@@ -3076,7 +3057,6 @@ static  void
 
 
 	//RT_TRACE(COMP_CMD, DBG_LOUD, ("<====phy_ReloadLCKSetting\n"));
-
 }
 
 
@@ -3154,7 +3134,6 @@ static  void
 	}
 
 	//RT_TRACE(COMP_CMD, DBG_LOUD, ("<====phy_ReloadIMRSetting\n"));
-
 }
 
 
@@ -3235,7 +3214,6 @@ static  void
 	pHalData->bNeedIQK = false;
 
 	//RT_TRACE(COMP_CMD, DBG_LOUD, ("<====phy_ReloadIQKSetting\n"));
-
 }
 
 
@@ -3251,9 +3229,9 @@ static void _PHY_SwChnl8192D(struct rtw_
 	struct rtw_adapter *	BuddyAdapter = Adapter->pbuddy_adapter;
 #endif
 
-	if ( Adapter->bNotifyChannelChange )
+	if (Adapter->bNotifyChannelChange)
 	{
-		DBG_8192D( "[%s] ch = %d\n", __func__, channel );
+		DBG_8192D("[%s] ch = %d\n", __func__, channel);
 	}
 
 	if (pHalData->BandSet92D == BAND_ON_BOTH){
@@ -3448,7 +3426,7 @@ PHY_SwChnl8192D(	// Call after initializ
 	//--------------------------------------------
 
 	//pHalData->SwChnlInProgress = TRUE;
-	if ( channel == 0){//FIXME!!!A band?
+	if (channel == 0){//FIXME!!!A band?
 		channel = 1;
 	}
 
@@ -3583,7 +3561,7 @@ PHY_SwChnlPhy8192D(	// Only called durin
 	}
 
 	//pHalData->SwChnlInProgress = TRUE;
-	if ( channel == 0)
+	if (channel == 0)
 		channel = 1;
 
 	pHalData->CurrentChannel=channel;
@@ -3639,7 +3617,6 @@ PHY_CheckIsLegalRfPath8192D(
 
 	// NOt check RF Path now.!
 	return	rtValue;
-
 }	/* PHY_CheckIsLegalRfPath8192D */
 
 //-------------------------------------------------------------------------
@@ -3721,7 +3698,7 @@ phy_PathA_IQK(
 
 	if (!(regEAC & BIT28) &&
 		(((regE94 & 0x03FF0000)>>16) != 0x142) &&
-		(((regE9C & 0x03FF0000)>>16) != 0x42) )
+		(((regE9C & 0x03FF0000)>>16) != 0x42))
 		result |= 0x01;
 	else							//if Tx not OK, ignore Rx
 		return result;
@@ -3735,7 +3712,6 @@ phy_PathA_IQK(
 
 	return result;
 
-
 }
 
 static u8			//bit0 = 1 => Tx OK, bit1 = 1 => Rx OK
@@ -3777,8 +3753,8 @@ phy_PathA_IQK_5G_Normal(
 	//path-B IQK setting
 	if (configPathB)
 	{
-		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f );
-		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x18008c2f );
+		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
+		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
 		PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
 		PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
 	}
@@ -3830,7 +3806,7 @@ phy_PathA_IQK_5G_Normal(
 		//RTPRINT(FINIT, INIT_IQK, ("0xea4 = 0x%lx\n", regEA4));
 
 		if (!(regEAC & TxOKBit) &&
-			(((regE94 & 0x03FF0000)>>16) != 0x142)  )
+			(((regE94 & 0x03FF0000)>>16) != 0x142) )
 		{
 			result |= 0x01;
 		}
@@ -3918,7 +3894,6 @@ phy_PathB_IQK(
 
 
 	return result;
-
 }
 
 static u8				//bit0 = 1 => Tx OK, bit1 = 1 => Rx OK
@@ -3949,8 +3924,8 @@ phy_PathB_IQK_5G_Normal(
 	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
 
 	//path-B IQK setting
-	PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f );
-	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x18008c2f );
+	PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
+	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
 	PHY_SetBBReg(pAdapter, rTx_IQK_PI_B, bMaskDWord, 0x82140307);
 	PHY_SetBBReg(pAdapter, rRx_IQK_PI_B, bMaskDWord, 0x68160960);
 
@@ -4302,7 +4277,7 @@ phy_SaveADDARegisters(
 	//	return;
 
 	//RTPRINT(FINIT, INIT_IQK, ("Save ADDA parameters.\n"));
-	for ( i = 0 ; i < RegisterNum ; i++){
+	for (i = 0 ; i < RegisterNum ; i++){
 		ADDABackup[i] = PHY_QueryBBReg(pAdapter, ADDAReg[i], bMaskDWord);
 	}
 }
@@ -4317,11 +4292,10 @@ phy_SaveMACRegisters(
 	u32	i;
 
 	//RTPRINT(FINIT, INIT_IQK, ("Save MAC parameters.\n"));
-	for ( i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
+	for (i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
 		MACBackup[i] = rtw_read8(pAdapter, MACReg[i]);
 	}
 	MACBackup[i] = rtw_read32(pAdapter, MACReg[i]);
-
 }
 
 static void
@@ -4379,7 +4353,7 @@ phy_PathADDAOn(
 	if (isPathAOn)     // Neil Chen
 		pathOn = pHalData->interfaceIndex == 0? 0x04db25a4 : 0x0b1b25a4;
 
-	for ( i = 0 ; i < IQK_ADDA_REG_NUM ; i++){
+	for (i = 0 ; i < IQK_ADDA_REG_NUM ; i++){
 		PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, pathOn);
 	}
 }
@@ -4401,7 +4375,6 @@ phy_MACSettingCalibration(
 		rtw_write8(pAdapter, MACReg[i], (u8)(MACBackup[i]&(~BIT3)));
 	}
 	rtw_write8(pAdapter, MACReg[i], (u8)(MACBackup[i]&(~BIT5)));
-
 }
 
 static void
@@ -4453,7 +4426,7 @@ phy_SimularityCompare_92D(
 	SimularityBitMap = 0;
 
 	//check Tx
-	for ( i = 0; i < bound; i++ )
+	for (i = 0; i < bound; i++)
 	{
 		diff = (result[c1][i] > result[c2][i]) ? (result[c1][i] - result[c2][i]) : (result[c2][i] - result[c1][i]);
 		if (diff > MAX_TOLERANCE_92D)
@@ -4472,19 +4445,19 @@ phy_SimularityCompare_92D(
 		}
 	}
 
-	if ( SimularityBitMap == 0)
+	if (SimularityBitMap == 0)
 	{
-		for ( i = 0; i < (bound/4); i++ )
+		for (i = 0; i < (bound/4); i++)
 		{
 			if (final_candidate[i] != 0xFF)
 			{
-				for ( j = i*4; j < (i+1)*4-2; j++)
+				for (j = i*4; j < (i+1)*4-2; j++)
 					result[3][j] = result[final_candidate[i]][j];
 				bResult = false;
 			}
 		}
 
-		for ( i = 0; i < bound; i++ )
+		for (i = 0; i < bound; i++)
 		{
 			u4temp += (result[c1][i]+	result[c2][i]);
 		}
@@ -4517,7 +4490,6 @@ phy_SimularityCompare_92D(
 	}
 
 	return false;
-
 }
 
 /*
@@ -4760,7 +4732,6 @@ phy_IQCalibrate(
 
 	}
 	//RTPRINT(FINIT, INIT_IQK, ("_PHY_IQCalibrate() <==\n"));
-
 }
 
 
@@ -5084,7 +5055,7 @@ phy_IQCalibrate_5G(
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
 		PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x34008c1f);
 		PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
-		PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000 );
+		PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
 
 		//path-B IQK setting
 		PHY_SetBBReg(pAdapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
@@ -5142,7 +5113,6 @@ Exit_IQK:
 		phy_PIModeSwitch(pAdapter, false);
 	//Reload ADDA power saving parameters
 	phy_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
-
 }
 
 static void
@@ -5350,7 +5320,6 @@ phy_IQCalibrate_5G_Normal(
 
 	}
 	//RTPRINT(FINIT, INIT_IQK, ("_PHY_IQCalibrate_5G_Normal() <==\n"));
-
 }
 
 #if SWLCK != 1
@@ -5435,7 +5404,6 @@ phy_LCCalibrate92D(
 	}
 
 	PHY_SetBBReg(pAdapter, rFPGA0_AnalogParameter4, 0xF00000, 0x00);
-
 }
 #endif  //SWLCK != 1, amy, temp remove
 
@@ -5701,7 +5669,6 @@ phy_LCCalibrate92DSW(
 	}
 
 	phy_ReloadLCKSetting(pAdapter, pHalData->CurrentChannel);
-
 }
 
 
@@ -6166,7 +6133,6 @@ static void phy_SetRFPathSwitch(
 		PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x1);
 
 	//RT_TRACE(COMP_OID_SET, DBG_LOUD, ("_PHY_SetRFPathSwitch 0x4C %lx, 0x878 %lx, 0x860 %lx\n", PHY_QueryBBReg(pAdapter, 0x4C, BIT23), PHY_QueryBBReg(pAdapter, 0x878, BIT13), PHY_QueryBBReg(pAdapter, 0x860, 0x300)));
-
 }
 
 void
@@ -6355,7 +6321,6 @@ rtl8192d_PHY_IQCalibrate(
 		}
 #endif
 	}
-
 }
 
 
@@ -6773,7 +6738,6 @@ PHY_UpdateBBRFConfiguration8192D(
 	//	DBG_8192D("PHY_UpdateBBRFConfiguration8192D RF 0x18 = 0x%x interface index %d\n",pHalData->RfRegChnlVal[i],	pHalData->interfaceIndex);
 
 	//RT_TRACE(COMP_INIT,DBG_LOUD,("<==PHY_UpdateBBRFConfiguration8192D()\n"));
-
 }
 
 //
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
@@ -20,7 +20,7 @@
 /******************************************************************************
  *
  *
- * Module:	HalRf6052.c	( Source C File)
+ * Module:	HalRf6052.c	(Source C File)
  *
  * Note:	Provide RF 6052 series relative API.
  *
@@ -97,7 +97,6 @@ void rtl8192d_RF_ChangeTxPath(	struct rt
 										u16		DataRate)
 {
 // We do not support gain table change inACUT now !!!! Delete later !!!
-
 }	/* RF_ChangeTxPath */
 
 
@@ -145,7 +144,7 @@ rtl8192d_PHY_RF6052SetBandwidth(
 			break;
 
 		default:
-			//RT_TRACE(COMP_DBG, DBG_LOUD, ("PHY_SetRF8225Bandwidth(): unknown Bandwidth: %#X\n",Bandwidth ));
+			//RT_TRACE(COMP_DBG, DBG_LOUD, ("PHY_SetRF8225Bandwidth(): unknown Bandwidth: %#X\n",Bandwidth));
 			break;
 	}
 	//RT_TRACE(COMP_MLME,DBG_LOUD,("<==== PHY_RF6052SetBandwidth()Bandwidth:%d\n",Bandwidth));
@@ -255,7 +254,6 @@ rtl8192d_PHY_RF6052SetCckTxPower(
 	PHY_SetBBReg(Adapter, rTxAGC_B_CCK1_55_Mcs32, 0xffffff00, tmpval);
 	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 1~5.5M (rf-B) = 0x%x (reg 0x%x)\n",
 	//	tmpval, rTxAGC_B_CCK1_55_Mcs32));
-
 }	/* PHY_RF6052SetCckTxPower */
 
 //
@@ -868,7 +866,6 @@ PHY_RF6052_Config8192D(
 	rtStatus = phy_RF6052_Config_ParaFile(Adapter);
 
 	return rtStatus;
-
 }
 
 
@@ -908,7 +905,6 @@ PHY_RFShadowRead(
 	u32				Offset)
 {
 	return	RF_Shadow[eRFPath][Offset].Value;
-
 }	/* PHY_RFShadowRead */
 
 
@@ -921,7 +917,6 @@ PHY_RFShadowWrite(
 {
 	RF_Shadow[eRFPath][Offset].Value = (Data & bRFRegOffsetMask);
 	RF_Shadow[eRFPath][Offset].Driver_Write = true;
-
 }	/* PHY_RFShadowWrite */
 
 bool
@@ -977,7 +972,6 @@ PHY_RFShadowRecorver(
 			//eRFPath, Offset, RF_Shadow[eRFPath][Offset].Value));
 		}
 	}
-
 }	/* PHY_RFShadowRecorver */
 void
 PHY_RFShadowCompareAll(
@@ -996,7 +990,6 @@ PHY_RFShadowCompareAll(
 			PHY_RFShadowCompare(Adapter, (enum RF_RADIO_PATH_E)eRFPath, Offset);
 		}
 	}
-
 }	/* PHY_RFShadowCompareAll */
 void
 PHY_RFShadowRecorverAll(
@@ -1015,7 +1008,6 @@ PHY_RFShadowRecorverAll(
 			PHY_RFShadowRecorver(Adapter, (enum RF_RADIO_PATH_E)eRFPath, Offset);
 		}
 	}
-
 }	/* PHY_RFShadowRecorverAll */
 void
 PHY_RFShadowCompareFlagSet(
@@ -1032,7 +1024,6 @@ PHY_RFShadowCompareFlagSet(
 {
 	// Set True or False!!!
 	RF_Shadow[eRFPath][Offset].Compare = Type;
-
 }	/* PHY_RFShadowCompareFlagSet */
 void
 PHY_RFShadowRecorverFlagSet(
@@ -1049,7 +1040,6 @@ PHY_RFShadowRecorverFlagSet(
 {
 	// Set True or False!!!
 	RF_Shadow[eRFPath][Offset].Recorver= Type;
-
 }	/* PHY_RFShadowRecorverFlagSet */
 void
 PHY_RFShadowCompareFlagSetAll(
@@ -1072,7 +1062,6 @@ PHY_RFShadowCompareFlagSetAll(
 				PHY_RFShadowCompareFlagSet(Adapter, (enum RF_RADIO_PATH_E)eRFPath, Offset, true);
 		}
 	}
-
 }	/* PHY_RFShadowCompareFlagSetAll */
 void
 PHY_RFShadowRecorverFlagSetAll(
@@ -1095,7 +1084,6 @@ PHY_RFShadowRecorverFlagSetAll(
 				PHY_RFShadowRecorverFlagSet(Adapter, (enum RF_RADIO_PATH_E)eRFPath, Offset, true);
 		}
 	}
-
 }	/* PHY_RFShadowCompareFlagSetAll */
 void
 PHY_RFShadowRefresh(
@@ -1118,7 +1106,6 @@ PHY_RFShadowRefresh(
 			RF_Shadow[eRFPath][Offset].Driver_Write = false;
 		}
 	}
-
 }	/* PHY_RFShadowRead */
 
 /* End of HalRf6052.c */
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
@@ -50,7 +50,7 @@ static u8 evm_db2percentage(s8 value)
 }
 
 
-static s32 signal_scale_mapping(struct rtw_adapter *padapter, s32 cur_sig )
+static s32 signal_scale_mapping(struct rtw_adapter *padapter, s32 cur_sig)
 {
 	s32 ret_sig;
 
@@ -314,7 +314,7 @@ static void query_rx_phy_status(union re
 		//
 		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
 		//
-		rx_pwr_all = (((pOfdm_buf->pwdb_all) >> 1 )& 0x7f) -106;
+		rx_pwr_all = (((pOfdm_buf->pwdb_all) >> 1)& 0x7f) -106;
 		pwdb_all = query_rx_pwr_percentage(rx_pwr_all);
 
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("PWDB_ALL=%d\n",	pwdb_all));
@@ -338,7 +338,7 @@ static void query_rx_phy_status(union re
 				// Do not use shift operation like "rx_evmX >>= 1" because the compilor of free build environment
 				// fill most significant bit to "zero" when doing shifting operation which may change a negative
 				// value to positive one, then the dbm value (which is supposed to be negative)  is not correct anymore.
-				evm = evm_db2percentage( (pOfdm_buf->rxevm_X[i] /*/ 2*/));//dbm
+				evm = evm_db2percentage((pOfdm_buf->rxevm_X[i] /*/ 2*/));//dbm
 
 				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("RXRATE=%x RXEVM=%x EVM=%s%d\n",
 					pattrib->mcs_rate, pOfdm_buf->rxevm_X[i], "%",evm));
@@ -375,7 +375,6 @@ static void query_rx_phy_status(union re
 			pattrib->signal_strength= (u8)(signal_scale_mapping(padapter, total_rssi/=rf_rx_num));
 		}
 	}
-
 }
 
 
@@ -422,7 +421,6 @@ static void process_rssi(struct rtw_adap
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("UI RSSI = %d, ui_rssi.TotalVal = %d, ui_rssi.TotalNum = %d\n", tmp_val, padapter->recvpriv.signal_strength_data.total_val,padapter->recvpriv.signal_strength_data.total_num));
 	#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
 	}
-
 }// Process_UI_RSSI_8192S
 
 
@@ -453,7 +451,7 @@ static void process_PWDB(struct rtw_adap
 		if (pattrib->RxPWDBAll > (u32)UndecoratedSmoothedPWDB)
 		{
 			UndecoratedSmoothedPWDB =
-					( ((UndecoratedSmoothedPWDB)*(Rx_Smooth_Factor-1)) +
+					(((UndecoratedSmoothedPWDB)*(Rx_Smooth_Factor-1)) +
 					(pattrib->RxPWDBAll)) /(Rx_Smooth_Factor);
 
 			UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB + 1;
@@ -461,7 +459,7 @@ static void process_PWDB(struct rtw_adap
 		else
 		{
 			UndecoratedSmoothedPWDB =
-					( ((UndecoratedSmoothedPWDB)*(Rx_Smooth_Factor-1)) +
+					(((UndecoratedSmoothedPWDB)*(Rx_Smooth_Factor-1)) +
 					(pattrib->RxPWDBAll)) /(Rx_Smooth_Factor);
 		}
 
@@ -537,7 +535,6 @@ static void process_link_qual(struct rtw
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" pattrib->signal_qual =%d\n", pattrib->signal_qual));
 	}
 #endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
-
 }// Process_UiLinkQuality8192S
 
 
@@ -630,7 +627,7 @@ void rtl8192d_query_rx_desc_status(union
 
 	pattrib->crc_err = (u8)((le32_to_cpu(pdesc->rxdw0) >> 14) & 0x1);
 	pattrib->icv_err = (u8)((le32_to_cpu(pdesc->rxdw0) >> 15) & 0x1);
-	pattrib->qos = (u8)(( le32_to_cpu( pdesc->rxdw0 ) >> 23) & 0x1);// Qos data, wireless lan header length is 26
+	pattrib->qos = (u8)((le32_to_cpu(pdesc->rxdw0) >> 23) & 0x1);// Qos data, wireless lan header length is 26
 	pattrib->bdecrypted = (le32_to_cpu(pdesc->rxdw0) & BIT(27))? 0:1;
 
 	//Offset 4
@@ -641,16 +638,16 @@ void rtl8192d_query_rx_desc_status(union
 
 	//Offset 12
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
-	if ( le32_to_cpu(pdesc->rxdw3) & BIT(13)){
+	if (le32_to_cpu(pdesc->rxdw3) & BIT(13)){
 		pattrib->tcpchk_valid = 1; // valid
-		if ( le32_to_cpu(pdesc->rxdw3) & BIT(11) ) {
+		if (le32_to_cpu(pdesc->rxdw3) & BIT(11)) {
 			pattrib->tcp_chkrpt = 1; // correct
 			//DBG_8192C("tcp csum ok\n");
 		}
 		else
 			pattrib->tcp_chkrpt = 0; // incorrect
 
-		if ( le32_to_cpu(pdesc->rxdw3) & BIT(12) )
+		if (le32_to_cpu(pdesc->rxdw3) & BIT(12))
 			pattrib->ip_chkrpt = 1; // correct
 		else
 			pattrib->ip_chkrpt = 0; // incorrect
@@ -665,5 +662,4 @@ void rtl8192d_query_rx_desc_status(union
 
 	//Offset 16
 	//Offset 20
-
 }
--- a/drivers/staging/rtl8192du/hal/rtl8192du_led.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_led.c
@@ -146,7 +146,7 @@ SwLedOn(
 {
 	u8	LedCfg;
 
-	if ( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
+	if ((padapter->bSurpriseRemoved == true) || (padapter->bDriverStopped == true))
 	{
 		return;
 	}
@@ -177,7 +177,6 @@ SwLedOn(
 	}
 
 	pLed->bLedOn = true;
-
 }
 
 
@@ -198,7 +197,7 @@ SwLedOff(
 {
 	u8	LedCfg;
 
-	if ((padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
+	if ((padapter->bSurpriseRemoved == true) || (padapter->bDriverStopped == true))
 	{
              return;
 	}
@@ -231,7 +230,6 @@ SwLedOff(
 	}
 
 	pLed->bLedOn = false;
-
 }
 
 //
@@ -253,7 +251,7 @@ SwLedBlink(
 	u8				bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
-	if ( pLed->BlinkingLedState == RTW_LED_ON )
+	if (pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
@@ -261,7 +259,7 @@ SwLedBlink(
 	else
 	{
 		SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,( "Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
 	}
 
 	// Determine if we shall change LED state again.
@@ -277,12 +275,12 @@ SwLedBlink(
 		break;
 
 	case LED_BLINK_StartToBlink:
-		if ( check_fwstate(pmlmepriv, _FW_LINKED) && check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
+		if (check_fwstate(pmlmepriv, _FW_LINKED) && check_fwstate(pmlmepriv, WIFI_STATION_STATE))
 		{
 			bStopBlinking = true;
 		}
-		if ( check_fwstate(pmlmepriv, _FW_LINKED) &&
-			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) )
+		if (check_fwstate(pmlmepriv, _FW_LINKED) &&
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)))
 		{
 			bStopBlinking = true;
 		}
@@ -293,7 +291,7 @@ SwLedBlink(
 		break;
 
 	case LED_BLINK_WPS:
-		if ( pLed->BlinkTimes == 0 )
+		if (pLed->BlinkTimes == 0)
 		{
 			bStopBlinking = true;
 		}
@@ -308,15 +306,15 @@ SwLedBlink(
 
 	if (bStopBlinking)
 	{
-		if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+		if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 		{
 			SwLedOff(padapter, pLed);
 		}
-		else if ( (check_fwstate(pmlmepriv, _FW_LINKED)== true) && (pLed->bLedOn == false))
+		else if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) && (pLed->bLedOn == false))
 		{
 			SwLedOn(padapter, pLed);
 		}
-		else if ( (check_fwstate(pmlmepriv, _FW_LINKED)== true) &&  pLed->bLedOn == true)
+		else if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) &&  pLed->bLedOn == true)
 		{
 			SwLedOff(padapter, pLed);
 		}
@@ -327,13 +325,13 @@ SwLedBlink(
 	else
 	{
 		// Assign LED state to toggle.
-		if ( pLed->BlinkingLedState == RTW_LED_ON )
+		if (pLed->BlinkingLedState == RTW_LED_ON)
 			pLed->BlinkingLedState = RTW_LED_OFF;
 		else
 			pLed->BlinkingLedState = RTW_LED_ON;
 
 		// Schedule a timer to toggle LED state.
-		switch ( pLed->CurrLedState )
+		switch (pLed->CurrLedState)
 		{
 		case LED_BLINK_NORMAL:
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
@@ -346,7 +344,7 @@ SwLedBlink(
 
 		case LED_BLINK_WPS:
 			{
-				if ( pLed->BlinkingLedState == RTW_LED_ON )
+				if (pLed->BlinkingLedState == RTW_LED_ON)
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
 				else
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
@@ -379,10 +377,10 @@ SwLedBlink1(
 		pLed = &(ledpriv->SwLed1);
 
 	// Change LED according to BlinkingLedState specified.
-	if ( pLed->BlinkingLedState == RTW_LED_ON )
+	if (pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,( "Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
 	}
 	else
 	{
@@ -420,7 +418,7 @@ SwLedBlink1(
 	switch (pLed->CurrLedState)
 	{
 		case LED_BLINK_SLOWLY:
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -428,7 +426,7 @@ SwLedBlink1(
 			break;
 
 		case LED_BLINK_NORMAL:
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -437,14 +435,14 @@ SwLedBlink1(
 
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
-			if ( pLed->BlinkTimes == 0 )
+			if (pLed->BlinkTimes == 0)
 			{
 				bStopBlinking = true;
 			}
 
 			if (bStopBlinking)
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -452,7 +450,7 @@ SwLedBlink1(
 				{
 					pLed->bLedLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_NORMAL;
-					if ( pLed->bLedOn )
+					if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -464,7 +462,7 @@ SwLedBlink1(
 				{
 					pLed->bLedNoLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if ( pLed->bLedOn )
+					if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -475,13 +473,13 @@ SwLedBlink1(
 			}
 			else
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if ( pLed->bLedOn )
+					 if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -492,13 +490,13 @@ SwLedBlink1(
 
 		case LED_TXRX_BLINK:
 			pLed->BlinkTimes--;
-			if ( pLed->BlinkTimes == 0 )
+			if (pLed->BlinkTimes == 0)
 			{
 				bStopBlinking = true;
 			}
 			if (bStopBlinking)
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -506,7 +504,7 @@ SwLedBlink1(
 				{
 					pLed->bLedLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_NORMAL;
-					if ( pLed->bLedOn )
+					if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -517,7 +515,7 @@ SwLedBlink1(
 				{
 					pLed->bLedNoLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if ( pLed->bLedOn )
+					if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -529,13 +527,13 @@ SwLedBlink1(
 			}
 			else
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if ( pLed->bLedOn )
+					 if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -545,7 +543,7 @@ SwLedBlink1(
 			break;
 
 		case LED_BLINK_WPS:
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -566,7 +564,7 @@ SwLedBlink1(
 
 			if (bStopBlinking)
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -574,7 +572,7 @@ SwLedBlink1(
 				{
 					pLed->bLedLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_NORMAL;
-					if ( pLed->bLedOn )
+					if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -588,7 +586,6 @@ SwLedBlink1(
 		default:
 			break;
 	}
-
 }
 void
 SwLedBlink2(
@@ -604,7 +601,7 @@ SwLedBlink2(
 	u8					bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
-	if ( pLed->BlinkingLedState == RTW_LED_ON)
+	if (pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
@@ -619,14 +616,14 @@ SwLedBlink2(
 	{
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
-			if ( pLed->BlinkTimes == 0 )
+			if (pLed->BlinkTimes == 0)
 			{
 				bStopBlinking = true;
 			}
 
 			if (bStopBlinking)
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -649,13 +646,13 @@ SwLedBlink2(
 			}
 			else
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if ( pLed->bLedOn )
+					 if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -666,13 +663,13 @@ SwLedBlink2(
 
 		case LED_TXRX_BLINK:
 			pLed->BlinkTimes--;
-			if ( pLed->BlinkTimes == 0 )
+			if (pLed->BlinkTimes == 0)
 			{
 				bStopBlinking = true;
 			}
 			if (bStopBlinking)
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -695,13 +692,13 @@ SwLedBlink2(
 			}
 			else
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if ( pLed->bLedOn )
+					 if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -713,7 +710,6 @@ SwLedBlink2(
 		default:
 			break;
 	}
-
 }
 void
 SwLedBlink3(
@@ -729,7 +725,7 @@ SwLedBlink3(
 	u8				bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
-	if ( pLed->BlinkingLedState == RTW_LED_ON )
+	if (pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
@@ -745,14 +741,14 @@ SwLedBlink3(
 	{
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
-			if ( pLed->BlinkTimes == 0 )
+			if (pLed->BlinkTimes == 0)
 			{
 				bStopBlinking = true;
 			}
 
 			if (bStopBlinking)
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -760,7 +756,7 @@ SwLedBlink3(
 				{
 					pLed->CurrLedState = RTW_LED_ON;
 					pLed->BlinkingLedState = RTW_LED_ON;
-					if ( !pLed->bLedOn )
+					if (!pLed->bLedOn)
 						SwLedOn(padapter, pLed);
 
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
@@ -769,7 +765,7 @@ SwLedBlink3(
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
-					if ( pLed->bLedOn )
+					if (pLed->bLedOn)
 						SwLedOff(padapter, pLed);
 
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
@@ -778,13 +774,13 @@ SwLedBlink3(
 			}
 			else
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					if ( pLed->bLedOn )
+					if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -795,13 +791,13 @@ SwLedBlink3(
 
 		case LED_TXRX_BLINK:
 			pLed->BlinkTimes--;
-			if ( pLed->BlinkTimes == 0 )
+			if (pLed->BlinkTimes == 0)
 			{
 				bStopBlinking = true;
 			}
 			if (bStopBlinking)
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -810,7 +806,7 @@ SwLedBlink3(
 					pLed->CurrLedState = RTW_LED_ON;
 					pLed->BlinkingLedState = RTW_LED_ON;
 
-					if ( !pLed->bLedOn )
+					if (!pLed->bLedOn)
 						SwLedOn(padapter, pLed);
 
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
@@ -820,7 +816,7 @@ SwLedBlink3(
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
 
-					if ( pLed->bLedOn )
+					if (pLed->bLedOn)
 						SwLedOff(padapter, pLed);
 
 
@@ -830,13 +826,13 @@ SwLedBlink3(
 			}
 			else
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					if ( pLed->bLedOn )
+					if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -846,7 +842,7 @@ SwLedBlink3(
 			break;
 
 		case LED_BLINK_WPS:
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -867,7 +863,7 @@ SwLedBlink3(
 
 			if (bStopBlinking)
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -886,7 +882,6 @@ SwLedBlink3(
 		default:
 			break;
 	}
-
 }
 void
 SwLedBlink4(
@@ -903,7 +898,7 @@ SwLedBlink4(
 	u8				bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
-	if ( pLed->BlinkingLedState == RTW_LED_ON )
+	if (pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
@@ -924,7 +919,7 @@ SwLedBlink4(
 	switch (pLed->CurrLedState)
 	{
 		case LED_BLINK_SLOWLY:
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -932,7 +927,7 @@ SwLedBlink4(
 			break;
 
 		case LED_BLINK_StartToBlink:
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
@@ -946,14 +941,14 @@ SwLedBlink4(
 
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
-			if ( pLed->BlinkTimes == 0 )
+			if (pLed->BlinkTimes == 0)
 			{
 				bStopBlinking = false;
 			}
 
 			if (bStopBlinking)
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -961,7 +956,7 @@ SwLedBlink4(
 				{
 					pLed->bLedNoLinkBlinkInProgress = false;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if ( pLed->bLedOn )
+					if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -971,13 +966,13 @@ SwLedBlink4(
 			}
 			else
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if ( pLed->bLedOn )
+					 if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -988,13 +983,13 @@ SwLedBlink4(
 
 		case LED_TXRX_BLINK:
 			pLed->BlinkTimes--;
-			if ( pLed->BlinkTimes == 0 )
+			if (pLed->BlinkTimes == 0)
 			{
 				bStopBlinking = true;
 			}
 			if (bStopBlinking)
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
@@ -1002,7 +997,7 @@ SwLedBlink4(
 				{
 					pLed->bLedNoLinkBlinkInProgress = true;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if ( pLed->bLedOn )
+					if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -1012,13 +1007,13 @@ SwLedBlink4(
 			}
 			else
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if ( pLed->bLedOn )
+					 if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -1028,7 +1023,7 @@ SwLedBlink4(
 			break;
 
 		case LED_BLINK_WPS:
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
@@ -1041,7 +1036,7 @@ SwLedBlink4(
 			break;
 
 		case LED_BLINK_WPS_STOP:	//WPS authentication fail
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -1071,7 +1066,7 @@ SwLedBlink4(
 			}
 			else
 			{
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1087,7 +1082,6 @@ SwLedBlink4(
 
 	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink4 CurrLedState %d\n", pLed->CurrLedState));
 
-
 }
 void
 SwLedBlink5(
@@ -1102,7 +1096,7 @@ SwLedBlink5(
 	u8				bStopBlinking = false;
 
 	// Change LED according to BlinkingLedState specified.
-	if ( pLed->BlinkingLedState == RTW_LED_ON )
+	if (pLed->BlinkingLedState == RTW_LED_ON)
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
@@ -1117,14 +1111,14 @@ SwLedBlink5(
 	{
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
-			if ( pLed->BlinkTimes == 0 )
+			if (pLed->BlinkTimes == 0)
 			{
 				bStopBlinking = true;
 			}
 
 			if (bStopBlinking)
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
@@ -1142,13 +1136,13 @@ SwLedBlink5(
 			}
 			else
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					if ( pLed->bLedOn )
+					if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -1160,14 +1154,14 @@ SwLedBlink5(
 
 		case LED_TXRX_BLINK:
 			pLed->BlinkTimes--;
-			if ( pLed->BlinkTimes == 0 )
+			if (pLed->BlinkTimes == 0)
 			{
 				bStopBlinking = true;
 			}
 
 			if (bStopBlinking)
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
 					pLed->BlinkingLedState = RTW_LED_OFF;
@@ -1186,13 +1180,13 @@ SwLedBlink5(
 			}
 			else
 			{
-				if ( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
 				else
 				{
-					 if ( pLed->bLedOn )
+					 if (pLed->bLedOn)
 						pLed->BlinkingLedState = RTW_LED_OFF;
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
@@ -1207,7 +1201,6 @@ SwLedBlink5(
 
 	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink5 CurrLedState %d\n", pLed->CurrLedState));
 
-
 }
 
 //
@@ -1223,7 +1216,7 @@ BlinkTimerCallback(
 	struct LED_871X *	 pLed = (struct LED_871X *)data;
 	struct rtw_adapter		*padapter = pLed->padapter;
 
-	 if ( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
+	 if ((padapter->bSurpriseRemoved == true) || (padapter->bDriverStopped == true))
        {
              return;
        }
@@ -1243,7 +1236,7 @@ void BlinkWorkItemCallback(struct work_s
 	struct led_priv	*ledpriv = &(pLed->padapter->ledpriv);
 	struct rtw_adapter		*padapter = pLed->padapter;
 
-	 if ( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
+	 if ((padapter->bSurpriseRemoved == true) || (padapter->bDriverStopped == true))
        {
              return;
        }
@@ -1309,14 +1302,14 @@ SwLedControlMode0(
 	{
 	case LED_CTL_TX:
 	case LED_CTL_RX:
-		if ( pLed->bLedBlinkInProgress == false )
+		if (pLed->bLedBlinkInProgress == false)
 		{
 			pLed->bLedBlinkInProgress = true;
 
 			pLed->CurrLedState = LED_BLINK_NORMAL;
 			pLed->BlinkTimes = 2;
 
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -1325,14 +1318,14 @@ SwLedControlMode0(
 		break;
 
 	case LED_CTL_START_TO_LINK:
-		if ( pLed->bLedBlinkInProgress == false )
+		if (pLed->bLedBlinkInProgress == false)
 		{
 			pLed->bLedBlinkInProgress = true;
 
 			pLed->CurrLedState = LED_BLINK_StartToBlink;
 			pLed->BlinkTimes = 24;
 
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -1346,7 +1339,7 @@ SwLedControlMode0(
 
 	case LED_CTL_LINK:
 		pLed->CurrLedState = RTW_LED_ON;
-		if ( pLed->bLedBlinkInProgress == false )
+		if (pLed->bLedBlinkInProgress == false)
 		{
 			SwLedOn(padapter, pLed);
 		}
@@ -1354,7 +1347,7 @@ SwLedControlMode0(
 
 	case LED_CTL_NO_LINK:
 		pLed->CurrLedState = RTW_LED_OFF;
-		if ( pLed->bLedBlinkInProgress == false )
+		if (pLed->bLedBlinkInProgress == false)
 		{
 			SwLedOff(padapter, pLed);
 		}
@@ -1373,14 +1366,14 @@ SwLedControlMode0(
 		break;
 
 	case LED_CTL_START_WPS:
-		if ( pLed->bLedBlinkInProgress == false || pLed->CurrLedState == RTW_LED_ON)
+		if (pLed->bLedBlinkInProgress == false || pLed->CurrLedState == RTW_LED_ON)
 		{
 			pLed->bLedBlinkInProgress = true;
 
 			pLed->CurrLedState = LED_BLINK_WPS;
 			pLed->BlinkTimes = 20;
 
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 			{
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
@@ -1408,7 +1401,6 @@ SwLedControlMode0(
 	}
 
 	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
-
 }
 
  //ALPHA, added by chiyoko, 20090106
@@ -1435,13 +1427,13 @@ SwLedControlMode1(
 	{
 		case LED_CTL_START_TO_LINK:
 		case LED_CTL_NO_LINK:
-			if ( pLed->bLedNoLinkBlinkInProgress == false )
+			if (pLed->bLedNoLinkBlinkInProgress == false)
 			{
 				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if ( pLed->bLedLinkBlinkInProgress == true )
+				if (pLed->bLedLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedLinkBlinkInProgress = false;
@@ -1454,7 +1446,7 @@ SwLedControlMode1(
 
 				pLed->bLedNoLinkBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_SLOWLY;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1463,7 +1455,7 @@ SwLedControlMode1(
 			break;
 
 		case LED_CTL_LINK:
-			if ( pLed->bLedLinkBlinkInProgress == false )
+			if (pLed->bLedLinkBlinkInProgress == false)
 			{
 				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
@@ -1481,7 +1473,7 @@ SwLedControlMode1(
 				}
 				pLed->bLedLinkBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_NORMAL;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1502,7 +1494,7 @@ SwLedControlMode1(
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				if ( pLed->bLedLinkBlinkInProgress == true )
+				if (pLed->bLedLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					 pLed->bLedLinkBlinkInProgress = false;
@@ -1515,7 +1507,7 @@ SwLedControlMode1(
 				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1536,7 +1528,7 @@ SwLedControlMode1(
                                 _cancel_timer_ex(&(pLed->BlinkTimer));
                                 pLed->bLedNoLinkBlinkInProgress = false;
                             }
-                            if ( pLed->bLedLinkBlinkInProgress == true )
+                            if (pLed->bLedLinkBlinkInProgress == true)
                             {
                                 _cancel_timer_ex(&(pLed->BlinkTimer));
                                 pLed->bLedLinkBlinkInProgress = false;
@@ -1544,7 +1536,7 @@ SwLedControlMode1(
                             pLed->bLedBlinkInProgress = true;
                             pLed->CurrLedState = LED_TXRX_BLINK;
                             pLed->BlinkTimes = 2;
-                            if ( pLed->bLedOn )
+                            if (pLed->bLedOn)
                                 pLed->BlinkingLedState = RTW_LED_OFF;
                             else
                                 pLed->BlinkingLedState = RTW_LED_ON;
@@ -1561,7 +1553,7 @@ SwLedControlMode1(
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedNoLinkBlinkInProgress = false;
 				}
-				if ( pLed->bLedLinkBlinkInProgress == true )
+				if (pLed->bLedLinkBlinkInProgress == true)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					 pLed->bLedLinkBlinkInProgress = false;
@@ -1578,7 +1570,7 @@ SwLedControlMode1(
 				}
 				pLed->bLedWPSBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_WPS;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1593,7 +1585,7 @@ SwLedControlMode1(
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedNoLinkBlinkInProgress = false;
 			}
-			if ( pLed->bLedLinkBlinkInProgress == true )
+			if (pLed->bLedLinkBlinkInProgress == true)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				 pLed->bLedLinkBlinkInProgress = false;
@@ -1639,7 +1631,7 @@ SwLedControlMode1(
 
 			pLed->bLedNoLinkBlinkInProgress = true;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -1650,27 +1642,27 @@ SwLedControlMode1(
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
 
-			if ( pLed->bLedNoLinkBlinkInProgress)
+			if (pLed->bLedNoLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedNoLinkBlinkInProgress = false;
 			}
-			if ( pLed->bLedLinkBlinkInProgress)
+			if (pLed->bLedLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedLinkBlinkInProgress = false;
 			}
-			if ( pLed->bLedBlinkInProgress)
+			if (pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if ( pLed->bLedWPSBlinkInProgress )
+			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
 			}
-			if ( pLed->bLedScanBlinkInProgress)
+			if (pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
@@ -1721,7 +1713,7 @@ SwLedControlMode2(
 				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1741,7 +1733,7 @@ SwLedControlMode2(
 				pLed->bLedBlinkInProgress = true;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1752,12 +1744,12 @@ SwLedControlMode2(
 		case LED_CTL_LINK:
 			pLed->CurrLedState = RTW_LED_ON;
 			pLed->BlinkingLedState = RTW_LED_ON;
-			if ( pLed->bLedBlinkInProgress)
+			if (pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if ( pLed->bLedScanBlinkInProgress)
+			if (pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
@@ -1830,17 +1822,17 @@ SwLedControlMode2(
 		case LED_CTL_POWER_OFF:
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
-			if ( pLed->bLedBlinkInProgress)
+			if (pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if ( pLed->bLedScanBlinkInProgress)
+			if (pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
 			}
-			if ( pLed->bLedWPSBlinkInProgress )
+			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
@@ -1891,7 +1883,7 @@ SwLedControlMode2(
 				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1911,7 +1903,7 @@ SwLedControlMode2(
 				pLed->bLedBlinkInProgress = true;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -1925,12 +1917,12 @@ SwLedControlMode2(
 
 			pLed->CurrLedState = RTW_LED_ON;
 			pLed->BlinkingLedState = RTW_LED_ON;
-			if ( pLed->bLedBlinkInProgress)
+			if (pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if ( pLed->bLedScanBlinkInProgress)
+			if (pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
@@ -1955,7 +1947,7 @@ SwLedControlMode2(
 				}
 				pLed->bLedWPSBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_WPS;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -2013,17 +2005,17 @@ SwLedControlMode2(
 		case LED_CTL_POWER_OFF:
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
-			if ( pLed->bLedBlinkInProgress)
+			if (pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if ( pLed->bLedScanBlinkInProgress)
+			if (pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
 			}
-			if ( pLed->bLedWPSBlinkInProgress )
+			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
@@ -2073,7 +2065,7 @@ SwLedControlMode4(
 					_set_timer(&(pLed->BlinkTimer), 0);
 			}
 
-			if ( pLed->bLedStartToLinkBlinkInProgress == false )
+			if (pLed->bLedStartToLinkBlinkInProgress == false)
 			{
 				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
@@ -2092,7 +2084,7 @@ SwLedControlMode4(
 
 				pLed->bLedStartToLinkBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_StartToBlink;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 				{
 					pLed->BlinkingLedState = RTW_LED_OFF;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
@@ -2123,7 +2115,7 @@ SwLedControlMode4(
 				}
 			}
 
-			if ( pLed->bLedNoLinkBlinkInProgress == false )
+			if (pLed->bLedNoLinkBlinkInProgress == false)
 			{
 				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
@@ -2137,7 +2129,7 @@ SwLedControlMode4(
 
 				pLed->bLedNoLinkBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_SLOWLY;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -2166,7 +2158,7 @@ SwLedControlMode4(
 				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -2190,7 +2182,7 @@ SwLedControlMode4(
 				pLed->bLedBlinkInProgress = true;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -2231,7 +2223,7 @@ SwLedControlMode4(
 				}
 				pLed->bLedWPSBlinkInProgress = true;
 				pLed->CurrLedState = LED_BLINK_WPS;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 				{
 					pLed->BlinkingLedState = RTW_LED_OFF;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
@@ -2253,7 +2245,7 @@ SwLedControlMode4(
 
 			pLed->bLedNoLinkBlinkInProgress = true;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -2270,7 +2262,7 @@ SwLedControlMode4(
 
 			pLed->bLedNoLinkBlinkInProgress = true;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -2283,7 +2275,7 @@ SwLedControlMode4(
 				pLed1->bLedWPSBlinkInProgress = true;
 
 			pLed1->CurrLedState = LED_BLINK_WPS_STOP;
-			if ( pLed1->bLedOn )
+			if (pLed1->bLedOn)
 				pLed1->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed1->BlinkingLedState = RTW_LED_ON;
@@ -2300,7 +2292,7 @@ SwLedControlMode4(
 
 			pLed->bLedNoLinkBlinkInProgress = true;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if ( pLed->bLedOn )
+			if (pLed->bLedOn)
 				pLed->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
@@ -2314,7 +2306,7 @@ SwLedControlMode4(
 
 			pLed1->CurrLedState = LED_BLINK_WPS_STOP_OVERLAP;
 			pLed1->BlinkTimes = 10;
-			if ( pLed1->bLedOn )
+			if (pLed1->bLedOn)
 				pLed1->BlinkingLedState = RTW_LED_OFF;
 			else
 				pLed1->BlinkingLedState = RTW_LED_ON;
@@ -2326,38 +2318,38 @@ SwLedControlMode4(
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
 
-			if ( pLed->bLedNoLinkBlinkInProgress)
+			if (pLed->bLedNoLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedNoLinkBlinkInProgress = false;
 			}
-			if ( pLed->bLedLinkBlinkInProgress)
+			if (pLed->bLedLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedLinkBlinkInProgress = false;
 			}
-			if ( pLed->bLedBlinkInProgress)
+			if (pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
 			}
-			if ( pLed->bLedWPSBlinkInProgress )
+			if (pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedWPSBlinkInProgress = false;
 			}
-			if ( pLed->bLedScanBlinkInProgress)
+			if (pLed->bLedScanBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = false;
 			}
-			if ( pLed->bLedStartToLinkBlinkInProgress)
+			if (pLed->bLedStartToLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedStartToLinkBlinkInProgress = false;
 			}
 
-			if ( pLed1->bLedWPSBlinkInProgress )
+			if (pLed1->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
 				pLed1->bLedWPSBlinkInProgress = false;
@@ -2422,7 +2414,7 @@ SwLedControlMode5(
 				pLed->bLedScanBlinkInProgress = true;
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -2441,7 +2433,7 @@ SwLedControlMode5(
 				pLed->bLedBlinkInProgress = true;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
-				if ( pLed->bLedOn )
+				if (pLed->bLedOn)
 					pLed->BlinkingLedState = RTW_LED_OFF;
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
@@ -2453,7 +2445,7 @@ SwLedControlMode5(
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
 
-			if ( pLed->bLedBlinkInProgress)
+			if (pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = false;
@@ -2488,12 +2480,12 @@ LedControl871x(
 {
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 
-       if ( (padapter->bSurpriseRemoved == true) || ( padapter->bDriverStopped == true))
+       if ((padapter->bSurpriseRemoved == true) || (padapter->bDriverStopped == true))
        {
              return;
        }
 
-	if ( ledpriv->bRegUseLed == false)
+	if (ledpriv->bRegUseLed == false)
 		return;
 
 	//if (!priv->up)
@@ -2507,7 +2499,7 @@ LedControl871x(
 		 LedAction == LED_CTL_SITE_SURVEY ||
 		 LedAction == LED_CTL_LINK ||
 		 LedAction == LED_CTL_NO_LINK ||
-		 LedAction == LED_CTL_POWER_ON) )
+		 LedAction == LED_CTL_POWER_ON))
 	{
 		return;
 	}
@@ -2580,6 +2572,6 @@ rtl8192du_DeInitSwLeds(
 {
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 
-	DeInitLed871x( &(ledpriv->SwLed0) );
-	DeInitLed871x( &(ledpriv->SwLed1) );
+	DeInitLed871x(&(ledpriv->SwLed0));
+	DeInitLed871x(&(ledpriv->SwLed1));
 }
--- a/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
@@ -45,7 +45,6 @@ void rtl8192du_init_recvbuf(struct rtw_a
 		precvbuf->pdata = precvbuf->phead = precvbuf->ptail = precvbuf->pbuf;
 		precvbuf->pend = precvbuf->pdata + MAX_RECVBUF_SZ;
 	}
-
 }
 
 int	rtl8192du_init_recv_priv(struct rtw_adapter *padapter)
@@ -160,7 +159,6 @@ int	rtl8192du_init_recv_priv(struct rtw_
 exit:
 
 	return res;
-
 }
 
 void rtl8192du_free_recv_priv (struct rtw_adapter *padapter)
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -82,7 +82,6 @@ u32 rtw_get_ff_hwaddr(struct xmit_frame
 	}
 
 	return addr;
-
 }
 
 int urb_zero_packet_chk(struct rtw_adapter *padapter, int sz);
@@ -91,9 +90,9 @@ int urb_zero_packet_chk(struct rtw_adapt
 	int blnSetTxDescOffset;
 	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);
 
-	if ( pdvobj->ishighspeed )
+	if (pdvobj->ishighspeed)
 	{
-		if ( ( (sz + TXDESC_SIZE) % 512 ) == 0 ) {
+		if (((sz + TXDESC_SIZE) % 512) == 0) {
 			blnSetTxDescOffset = 1;
 		} else {
 			blnSetTxDescOffset = 0;
@@ -101,7 +100,7 @@ int urb_zero_packet_chk(struct rtw_adapt
 	}
 	else
 	{
-		if ( ( (sz + TXDESC_SIZE) % 64 ) == 0 )		{
+		if (((sz + TXDESC_SIZE) % 64) == 0)		{
 			blnSetTxDescOffset = 1;
 		} else {
 			blnSetTxDescOffset = 0;
@@ -109,7 +108,6 @@ int urb_zero_packet_chk(struct rtw_adapt
 	}
 
 	return blnSetTxDescOffset;
-
 }
 
 void rtl8192du_cal_txdesc_chksum(struct tx_desc	*ptxdesc)
@@ -127,7 +125,6 @@ void rtl8192du_cal_txdesc_chksum(struct
 		}
 
 		ptxdesc->txdw7 |= cpu_to_le32(0x0000ffff&checksum);
-
 }
 
 void fill_txdesc_sectype(struct pkt_attrib *pattrib, struct tx_desc *ptxdesc);
@@ -157,7 +154,6 @@ void fill_txdesc_sectype(struct pkt_attr
 		}
 
 	}
-
 }
 
 static void fill_txdesc_vcs(struct pkt_attrib *pattrib, u32 *pdw)
@@ -370,7 +366,7 @@ if (padapter->registrypriv.mp_mode == 0)
 
 		//offset 24
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
-		if ( pattrib->hw_tcp_csum == 1 ) {
+		if (pattrib->hw_tcp_csum == 1) {
 			// ptxdesc->txdw6 = 0; // clear TCP_CHECKSUM and IP_CHECKSUM. It's zero already!!
 			u8 ip_hdr_offset = 32 + pattrib->hdrlen + pattrib->iv_len + 8;
 			ptxdesc->txdw7 = (1 << 31) | (ip_hdr_offset << 16);
@@ -490,7 +486,6 @@ if (padapter->registrypriv.mp_mode == 0)
 	rtl8192du_cal_txdesc_chksum(ptxdesc);
 
 	return pull;
-
 }
 
 s32 rtw_dump_xframe(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
@@ -641,7 +636,6 @@ void UpdateEarlyModeInfo8192D(struct rtw
 		pxmitframe->EMPktNum++;
 	}
 	spin_unlock_bh(&pxmitpriv->lock);
-
 }
 
 #define IDEA_CONDITION 1	// check all packets before enqueue
@@ -925,7 +919,6 @@ s32 rtl8192du_xmitframe_complete(struct
 	}while (0/*xcnt < (NR_XMITFRAME >> 3)*/);
 
 	return true;
-
 }
 #endif
 
@@ -1145,6 +1138,5 @@ _exit:
 
 	dev_kfree_skb_any(skb);
 	return 0;
-
 }
 #endif
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -122,7 +122,6 @@ _TwoOutEpMapping(
 		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];//BCN
 
 	}
-
 }
 
 
@@ -165,7 +164,6 @@ static void _ThreeOutEpMapping(
 		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];//BMC
 		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];//BCN
 	}
-
 }
 
 static bool
@@ -198,7 +196,6 @@ _MappingOutEP(
 	}
 
 	return result;
-
 }
 
 static void
@@ -260,7 +257,6 @@ _ConfigChipOutEP(
 
 	// TODO: Error recovery for this case
 	//RT_ASSERT((NumOutPipe == pHalData->OutEpNumber), ("Out EP number isn't match! %d(Descriptor) != %d (SIE reg)\n", (u4Byte)NumOutPipe, (u4Byte)pHalData->OutEpNumber));
-
 }
 
 static bool HalUsbSetQueuePipeMapping8192DUsb(
@@ -284,7 +280,6 @@ static bool HalUsbSetQueuePipeMapping819
 	result = _MappingOutEP(pAdapter, NumOutPipe);
 
 	return result;
-
 }
 
 void rtl8192du_interface_configure(struct rtw_adapter *padapter);
@@ -325,7 +320,6 @@ void rtl8192du_interface_configure(struc
 
 	HalUsbSetQueuePipeMapping8192DUsb(padapter,
 				pdvobjpriv->RtNumInPipes, pdvobjpriv->RtNumOutPipes);
-
 }
 
 static u8 _InitPowerOn(struct rtw_adapter *padapter)
@@ -366,7 +360,7 @@ static u8 _InitPowerOn(struct rtw_adapte
 	rtw_usleep_os(100);//PlatformSleepUs(150);//this is not necessary when initially power on
 
 	value8 = rtw_read8(padapter, REG_LDOV12D_CTRL);
-	if (0== (value8 & LDV12_EN) ){
+	if (0== (value8 & LDV12_EN)){
 		value8 |= LDV12_EN;
 		rtw_write8(padapter, REG_LDOV12D_CTRL, value8);
 		//RT_TRACE(COMP_INIT, DBG_LOUD, (" power-on :REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8));
@@ -408,7 +402,6 @@ static u8 _InitPowerOn(struct rtw_adapte
 	rtw_write16(padapter, REG_CR, value16);
 
 	return ret;
-
 }
 
 u16 CRC16(u8 data,u16 CRC)
@@ -464,7 +457,6 @@ u16 CRC16(u8 data,u16 CRC)
 	}
 
 	return CRC;
-
 }
 
 /////////////////////////////////////////////////
@@ -689,7 +681,6 @@ static u8 _LLTWrite(
 	}while (count++);
 
 	return status;
-
 }
 
 static u8 _LLTRead(
@@ -717,7 +708,6 @@ static u8 _LLTRead(
 	}while (count++);
 
 	return 0xFF;
-
 }
 
 static u8 InitLLTTable(
@@ -774,7 +764,6 @@ static u8 InitLLTTable(
 	}
 
 	return status;
-
 }
 
 //---------------------------------------------------------------
@@ -1001,7 +990,6 @@ _InitNormalChipOneOutEpPriority(
 								value,
 								value
 								);
-
 }
 
 static void
@@ -1036,7 +1024,7 @@ _InitNormalChipTwoOutEpPriority(
 			break;
 	}
 
-	if (!pregistrypriv->wifi_spec ){
+	if (!pregistrypriv->wifi_spec){
 		beQ		= valueLow;
 		bkQ		= valueLow;
 		viQ		= valueHi;
@@ -1054,7 +1042,6 @@ _InitNormalChipTwoOutEpPriority(
 	}
 
 	_InitNormalChipRegPriority(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
-
 }
 
 static void
@@ -1065,7 +1052,7 @@ _InitNormalChipThreeOutEpPriority(
 	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
 
-	if (!pregistrypriv->wifi_spec ){// typical setting
+	if (!pregistrypriv->wifi_spec){// typical setting
 		beQ		= QUEUE_LOW;
 		bkQ		= QUEUE_LOW;
 		viQ		= QUEUE_NORMAL;
@@ -1228,7 +1215,6 @@ _InitAdaptiveCtrl(
 	// Retry Limit
 	value16 = _LRL(0x30) | _SRL(0x30);
 	rtw_write16(Adapter, REG_RL, value16);
-
 }
 
 static void
@@ -1260,7 +1246,7 @@ _InitEDCA(
 
 	// Update SIFS timing.  ??????????
 	//pHalData->SifsTime = 0x0e0e0a0a;
-	//rtw_hal_set_hwreg( Adapter, HW_VAR_RESP_SIFS,  (pu1Byte)&pHalData->SifsTime);
+	//rtw_hal_set_hwreg(Adapter, HW_VAR_RESP_SIFS,  (pu1Byte)&pHalData->SifsTime);
 	// SIFS for CCK Data ACK
 	rtw_write8(Adapter, REG_SIFS_CTX, 0xa);
 	// SIFS for CCK consecutive tx like CTS data!
@@ -1297,7 +1283,6 @@ _InitEDCA(
 	rtw_write8(Adapter, REG_BCNDMATIM, 0x02);
 
 	rtw_write8(Adapter, REG_ATIMWND, 0x02);
-
 }
 
 
@@ -1327,7 +1312,7 @@ _InitBeaconMaxError(
 	)
 {
 #ifdef RTL8192CU_ADHOC_WORKAROUND_SETTING
-	rtw_write8(Adapter, REG_BCN_MAX_ERR,  0xFF );
+	rtw_write8(Adapter, REG_BCN_MAX_ERR,  0xFF);
 #else
 	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));
 #endif
@@ -1468,10 +1453,8 @@ _InitUsbAggregationSetting(
 			//RT_ASSERT(FALSE, ("RX_PAGE_SIZE_REG_VALUE definition is incorrect!\n"));
 			break;
 	}
-
 }
 #endif
-
 }
 
 
@@ -1561,7 +1544,6 @@ _InitOperationMode(
 	}
 
 	rtw_write8(Adapter, REG_AMPDU_MIN_SPACE, MinSpaceCfg);
-
 }
 
 
@@ -1707,13 +1689,12 @@ static void _InitHWLed(struct rtw_adapte
 {
 	struct led_priv *pledpriv = &(Adapter->ledpriv);
 
-	if ( pledpriv->LedStrategy != HW_LED)
+	if (pledpriv->LedStrategy != HW_LED)
 			return;
 
 // HW led control
 // to do ....
 //must consider the cases of antenna diversity/ commbo card/solo card/mini card
-
 }
 #endif //CONFIG_LED
 
@@ -2297,7 +2278,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 			{
 				ulRegRead |= ulRegRead ;
 			}
-			//else if (pHalData->LoopbackMode == RTL8192SU_MAC_LOOPBACK )
+			//else if (pHalData->LoopbackMode == RTL8192SU_MAC_LOOPBACK)
 			//{
 				//RT_TRACE(COMP_INIT, DBG_LOUD, ("==>start loop back mode %x\n",ulRegRead));
 			//	ulRegRead |= 0x0b000000; //0x0b000000 CPU_CCK_LOOPBACK;
@@ -2414,7 +2395,6 @@ n. LEDCFG 0x4C[15:0] = 0x8080
 	rtw_write16(Adapter, REG_LEDCFG0, 0x8888);
 
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable GPIO and LED.\n"));
-
 } //end of _DisableGPIO()
 static void
 _ResetFWDownloadRegister(
@@ -2463,7 +2443,6 @@ _DisableRF_AFE(
 
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE,AD, DA.\n"));
 	return rtStatus;
-
 }
 
 static void
@@ -2530,7 +2509,6 @@ _AutoPowerDownToHostOff(
 	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
 	value32 &= ~AFSM_PCIE;
 	rtw_write32(Adapter, REG_APS_FSMCO, value32);
-
 }
 
 static void
@@ -2548,7 +2526,6 @@ _SetUsbSuspend(
 
 	//RT_ASSERT(0 == (rtw_read32(Adapter, REG_APS_FSMCO) & BIT(12)),(""));
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Set USB suspend.\n"));
-
 }
 
 static void
@@ -2575,22 +2552,22 @@ e.	SYS_FUNC_EN 0x02[7:0] = 0x14		//reset
 
 	//testchip  should not do BB reset if another mac is alive;
 	value8 = 0 ;
-	value8 |=( FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
-	rtw_write8(Adapter, REG_SYS_FUNC_EN,value8 );//0x16
+	value8 |=(FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
+	rtw_write8(Adapter, REG_SYS_FUNC_EN,value8);//0x16
 
 	if (pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
 	{
 		if (pHalData->interfaceIndex!=0){
 			//before BB reset should do clock gated
 			rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
-			value8 &=( ~FEN_BB_GLB_RSTn );
+			value8 &=(~FEN_BB_GLB_RSTn);
 			rtw_write8(Adapter, REG_SYS_FUNC_EN, value8); //0x14
 		}
 	}
 	else{
 		//before BB reset should do clock gated
 		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
-		value8 &=( ~FEN_BB_GLB_RSTn );
+		value8 &=(~FEN_BB_GLB_RSTn);
 		rtw_write8(Adapter, REG_SYS_FUNC_EN, value8); //0x14
 	}
 
@@ -2631,7 +2608,7 @@ _ResetDigitalProcedure1(
 			rtw_write8(Adapter, REG_MCUFWDL, 0);
 			rtw_write8(Adapter, REG_HMETFR+3, 0x20);//8051 reset by self
 
-			while ( (retry_cnts++ <100) && (FEN_CPUEN &rtw_read16(Adapter, REG_SYS_FUNC_EN)))
+			while ((retry_cnts++ <100) && (FEN_CPUEN &rtw_read16(Adapter, REG_SYS_FUNC_EN)))
 				rtw_udelay_os(50);//us
 
 			if (retry_cnts>= 100) {
@@ -2650,7 +2627,7 @@ _ResetDigitalProcedure1(
 	#ifdef DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE
 	{
 		u8 val;
-		if ( (val=rtw_read8(Adapter, REG_MCUFWDL)))
+		if ((val=rtw_read8(Adapter, REG_MCUFWDL)))
 			DBG_8192D("DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE %s:%d REG_MCUFWDL:0x%02x\n", __func__, __LINE__, val);
 	}
 	#endif
@@ -2673,7 +2650,6 @@ _ResetDigitalProcedure1(
 		rtw_write8(Adapter, REG_SYS_ISO_CTRL, 0xF9);
 	}
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Reset Digital.\n"));
-
 }
 
 static void
@@ -2726,7 +2702,7 @@ i.	APS_FSMCO 0x04[15:0] = 0x4802		// set
 	rtw_write8(Adapter, REG_SPS0_CTRL, 0x23);
 
 	value16 |= (APDM_HOST | AFSM_HSUS |PFM_ALDN);
-	rtw_write16(Adapter, REG_APS_FSMCO,value16 );//0x4802
+	rtw_write16(Adapter, REG_APS_FSMCO,value16);//0x4802
 
 	rtw_write8(Adapter, REG_RSV_CTRL, 0x0e);
 
@@ -2798,7 +2774,7 @@ CanGotoPowerOff92D(
 }
 
 static int
-CardDisableHWSM( // HW Auto state machine
+CardDisableHWSM(// HW Auto state machine
 	struct rtw_adapter *		Adapter,
 	bool			resetMCU
 	)
@@ -2850,7 +2826,7 @@ CardDisableHWSM( // HW Auto state machin
 }
 
 static int
-CardDisableWithoutHWSM( // without HW Auto state machine
+CardDisableWithoutHWSM(// without HW Auto state machine
 	struct rtw_adapter *		Adapter
 	)
 {
@@ -2941,7 +2917,7 @@ _func_enter_;
 	rtw_write16(padapter, REG_GPIO_MUXCFG, rtw_read16(padapter, REG_GPIO_MUXCFG)&(~BIT12));
 
 	if (/*Adapter->bInUsbIfTest ||*/ !pHalData->bSupportRemoteWakeUp){
-		if ( padapter->bCardDisableWOHSM == false)
+		if (padapter->bCardDisableWOHSM == false)
 			CardDisableHWSM(padapter, false);
 		else
 			CardDisableWithoutHWSM(padapter);
@@ -2996,7 +2972,7 @@ _func_enter_;
 	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
 	for (i=0; i<NR_RECVBUFF; i++)
 	{
-		if (_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == false )
+		if (_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == false)
 		{
 			RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_port error\n"));
 			status = _FAIL;
@@ -3009,7 +2985,7 @@ _func_enter_;
 
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
 	_read_interrupt = pintfhdl->io_ops._read_interrupt;
-	if (_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == false )
+	if (_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == false)
 	{
 		RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_interrupt error\n"));
 		status = _FAIL;
@@ -3023,7 +2999,6 @@ exit:
 _func_exit_;
 
 	return status;
-
 }
 
 unsigned int rtl8192du_inirp_deinit(struct rtw_adapter * padapter);
@@ -3095,8 +3070,8 @@ _ReadIDs(
 
 	if (false == AutoloadFail){
 		// VID, PID
-		pHalData->EEPROMVID = le16_to_cpu( *(u16 *)&PROMContent[EEPROM_VID]);
-		pHalData->EEPROMPID = le16_to_cpu( *(u16 *)&PROMContent[EEPROM_PID]);
+		pHalData->EEPROMVID = le16_to_cpu(*(u16 *)&PROMContent[EEPROM_VID]);
+		pHalData->EEPROMPID = le16_to_cpu(*(u16 *)&PROMContent[EEPROM_PID]);
 
 		// Customer ID, 0x00 and 0xff are reserved for Realtek.
 		pHalData->EEPROMCustomerID = *(u8 *)&PROMContent[EEPROM_CUSTOMER_ID];
@@ -3153,7 +3128,7 @@ _ReadMACAddress(
 
 	// Dual MAC should assign diffrent MAC address ,or, it is wil cause hang in single phy mode  zhiyuan 04/07/2010
 	//Temply random assigh mac address for  efuse mac address not ready now
-	if (AutoloadFail == false  ){
+	if (AutoloadFail == false ){
 		if (pHalData->interfaceIndex == 0){
 			//change to use memcpy, in order to avoid alignment issue. Baron 2011/6/20
 			memcpy(&pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR_MAC0_92D], ETH_ALEN);
@@ -3235,7 +3210,6 @@ hal_ReadMacPhyModeFromPROM92DU(
 	}
 
 	DBG_8192D("_ReadMacPhyModeFromPROM92DU(): MacPhyCrValue %d\n", MacPhyCrValue);
-
 }
 
 static void
@@ -3287,7 +3261,6 @@ hal_ReadMacPhyMode_92D(
 
 	PHY_ConfigMacPhyModeInfo92D(Adapter);
 	rtl8192d_ResetDualMacSwitchVariables(Adapter);
-
 }
 
 static void
@@ -3309,7 +3282,6 @@ _ReadBoardType(
 	boardType = PROMContent[EEPROM_NORMAL_BoardType];
 	boardType &= BOARD_TYPE_NORMAL_MASK;
 	boardType >>= 5;
-
 }
 
 
@@ -3353,7 +3325,7 @@ _ReadWOWLAN(
 	else
 	{
 		// decide hw if support remote wakeup function
-		// if hw supported, 8051 (SIE) will generate WeakUP signal( D+/D- toggle) when autoresume
+		// if hw supported, 8051 (SIE) will generate WeakUP signal(D+/D- toggle) when autoresume
 		Adapter->pwrctrlpriv.bSupportRemoteWakeup = (PROMContent[EEPROM_Option_Setting] & BIT1)?true :false;
 		DBG_8192D("efuse remote wakeup =%d\n", Adapter->pwrctrlpriv.bSupportRemoteWakeup);
 	}
@@ -3395,13 +3367,13 @@ static void _ReadPROMContent(
 
 
 	DBG_8192D("Boot from %s, Autoload %s !\n", (pEEPROM->EepromOrEfuse ? "EEPROM" : "EFUSE"),
-				(pEEPROM->bautoload_fail_flag ? "Fail" : "OK") );
+				(pEEPROM->bautoload_fail_flag ? "Fail" : "OK"));
 
 	//pHalData->EEType = (pEEPROM->EepromOrEfuse == true) ? EEPROM_93C46 : EEPROM_BOOT_EFUSE;
 
 	if (pEEPROM->bautoload_fail_flag == false)
 	{
-		if ( pEEPROM->EepromOrEfuse == true)
+		if (pEEPROM->EepromOrEfuse == true)
 		{
 			// Read all Content from EEPROM or EFUSE.
 			for (i = 0; i < HWSET_MAX_SIZE; i += 2)
@@ -3428,7 +3400,7 @@ static void _ReadPROMContent(
 		}
 
 	}
-	else if ( pEEPROM->EepromOrEfuse == false)//auto load fail
+	else if (pEEPROM->EepromOrEfuse == false)//auto load fail
 	{
 		memset(pEEPROM->efuse_eeprom_data, 0xff, HWSET_MAX_SIZE);
 		memcpy((void*)PROMContent, (void*)pEEPROM->efuse_eeprom_data, HWSET_MAX_SIZE);
@@ -3436,7 +3408,6 @@ static void _ReadPROMContent(
 
 
 	_InitAdapterVariablesByPROM(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
-
 }
 
 
@@ -3463,7 +3434,6 @@ _InitOtherVariable(
 	else{
 		pHalData->bRFPathRxEnable[0] = pHalData->bRFPathRxEnable[1] = true;
 	}
-
 }
 
 static void
@@ -3515,12 +3485,11 @@ static void rtl8192du_trigger_gpio_0(str
 	DBG_8192D("==> trigger_gpio_0...\n");
 	rtw_write16_async(padapter,REG_GPIO_PIN_CTRL,0);
 	rtw_write8_async(padapter,REG_GPIO_PIN_CTRL+2,0xFF);
-	gpioctrl = (BIT(GPIO_DEBUG_PORT_NUM)<<24 )|(BIT(GPIO_DEBUG_PORT_NUM)<<16);
+	gpioctrl = (BIT(GPIO_DEBUG_PORT_NUM)<<24)|(BIT(GPIO_DEBUG_PORT_NUM)<<16);
 	rtw_write32_async(padapter,REG_GPIO_PIN_CTRL,gpioctrl);
 	gpioctrl |= (BIT(GPIO_DEBUG_PORT_NUM)<<8);
 	rtw_write32_async(padapter,REG_GPIO_PIN_CTRL,gpioctrl);
 	DBG_8192D("<=== trigger_gpio_0...\n");
-
 }
 
 static void
@@ -3539,7 +3508,6 @@ StopTxBeacon(
 	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xff);
 	rtw_write8(Adapter, REG_TBTT_PROHIBIT+1, 0x64);
 	//CheckFwRsvdPageContent(Adapter);  // 2010.06.23. Added by tynli.
-
 }
 
 static void
@@ -3597,9 +3565,9 @@ SelectRTSInitialRate(
 
 	memcpy(SupportRateSet, cur_network->SupportedRates, NDIS_802_11_LENGTH_RATES_EX);
 
-	halsetbratecfg( Adapter, SupportRateSet, &BasicRateCfg );
+	halsetbratecfg(Adapter, SupportRateSet, &BasicRateCfg);
 
-	if ( bUseProtection &&
+	if (bUseProtection &&
 		(!(pmlmeext->cur_wireless_mode == WIRELESS_11A|| pmlmeext->cur_wireless_mode == WIRELESS_11A_5N)))// 5G not support cck rate
 	{
 		// Use CCK rate
@@ -3777,7 +3745,7 @@ static void hw_var_set_opmode(struct rtw
 			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(0));
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 			// Reset TSF for STA+AP concurrent mode
-			if ( check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE)) ) {
+			if (check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE))) {
 				if (reset_tsf(Adapter, IFACE_PORT1) == false)
 					DBG_8192D("ERROR! %s()-%d: Reset port1 TSF fail\n",
 						__func__, __LINE__);
@@ -3857,7 +3825,7 @@ static void hw_var_set_opmode(struct rtw
 			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(0));
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 			// Reset TSF for STA+AP concurrent mode
-			if ( check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE)) ) {
+			if (check_buddy_fwstate(Adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE))) {
 				if (reset_tsf(Adapter, IFACE_PORT0) == false)
 					DBG_8192D("ERROR! %s()-%d: Reset port0 TSF fail\n",
 						__func__, __LINE__);
@@ -3889,7 +3857,6 @@ static void hw_var_set_macaddr(struct rt
 	{
 		rtw_write8(Adapter, (reg_macid+idx), val[idx]);
 	}
-
 }
 
 static void hw_var_set_bssid(struct rtw_adapter * Adapter, u8 variable, u8* val)
@@ -3912,7 +3879,6 @@ static void hw_var_set_bssid(struct rtw_
 	{
 		rtw_write8(Adapter, (reg_bssid+idx), val[idx]);
 	}
-
 }
 
 static void hw_var_set_bcn_func(struct rtw_adapter * Adapter, u8 variable, u8* val)
@@ -3981,8 +3947,8 @@ static void hw_var_set_correct_tsf(struc
 
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 		// Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue!
-		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE) ) {
+		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
+			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)) {
 			if (reset_tsf(Adapter, IFACE_PORT0) == false)
 				DBG_8192D("ERROR! %s()-%d: Reset port0 TSF fail\n",
 					__func__, __LINE__);
@@ -4005,7 +3971,7 @@ static void hw_var_set_correct_tsf(struc
 		//rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
 
 		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
-		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
+		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
 			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)
 		) {
 			//disable related TSF function
@@ -4022,8 +3988,8 @@ static void hw_var_set_correct_tsf(struc
 		}
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
-		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE) ) {
+		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
+			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)) {
 			if (reset_tsf(Adapter, IFACE_PORT1) == false)
 				DBG_8192D("ERROR! %s()-%d: Reset port1 TSF fail\n",
 					__func__, __LINE__);
@@ -4091,7 +4057,7 @@ static void hw_var_set_mlme_disconnect(s
 
 		for (i=0; i< 10; i++) {
 			reg_bcn_ctrl_1 = rtw_read8(Adapter, REG_BCN_CTRL_1);
-			if ( (reg_bcn_ctrl_1 & BIT(3)) == 0 ) {
+			if ((reg_bcn_ctrl_1 & BIT(3)) == 0) {
 				//DBG_8192D("%s()-%d: BEACON_DISABLE_OFFLOAD finished! reg=%02x\n", __func__, __LINE__, reg);
 				break;
 			}
@@ -4157,13 +4123,13 @@ static void hw_var_set_mlme_sitesurvey(s
 
 #ifdef CONFIG_FIND_BEST_CHANNEL
 
-	if ( (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 #ifdef CONFIG_CONCURRENT_MODE
 		|| (check_buddy_fwstate(Adapter, WIFI_AP_STATE) == true)
 #endif
 #ifdef CONFIG_TDLS
 		// TDLS will clear RCR_CBSSID_DATA bit for connection.
-		|| ( Adapter->tdlsinfo.setup_state & TDLS_LINKED_STATE )
+		|| (Adapter->tdlsinfo.setup_state & TDLS_LINKED_STATE)
 #endif // CONFIG_TDLS
 		)
 	{
@@ -4547,7 +4513,7 @@ _func_enter_;
 				// Select RRSR (in Legacy-OFDM and CCK)
 				// For 8190, we select only 24M, 12M, 6M, 11M, 5.5M, 2M, and 1M from the Basic rate.
 				// We do not use other rates.
-				halsetbratecfg( Adapter, val, &BrateCfg );
+				halsetbratecfg(Adapter, val, &BrateCfg);
 
 				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 					b2GBand = true;
@@ -4559,7 +4525,7 @@ _func_enter_;
 					//CCK 2M ACK should be disabled for some BCM and Atheros AP IOT
 					//because CCK 2M has poor TXEVM
 					//CCK 5.5M & 11M ACK should be enabled for better performance
-					pHalData->BasicRateSet = BrateCfg = (BrateCfg |0xd )& 0x15d;
+					pHalData->BasicRateSet = BrateCfg = (BrateCfg |0xd)& 0x15d;
 					BrateCfg |= 0x1; // default enable 1M ACK rate
 				}
 				else // 5G
@@ -4727,7 +4693,7 @@ _func_enter_;
 				{
 					//config RCR to receive different BSSID & not to receive data frame during linking
 					//u32 v = rtw_read32(Adapter, REG_RCR);
-					//v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN );//| RCR_ADF
+					//v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);//| RCR_ADF
 					//rtw_write32(Adapter, REG_RCR, v);
 
 					rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
@@ -4844,7 +4810,7 @@ _func_enter_;
 				for (i=0;i<CAM_CONTENT_COUNT;i++)
 				{
 					// filled id in CAM config 2 byte
-					if ( i == 0)
+					if (i == 0)
 					{
 						ulContent |=(ucIndex & 0x03) | ((u16)(ulEncAlgo)<<2);
 						//ulContent |= CAM_VALID;
@@ -4893,7 +4859,7 @@ _func_enter_;
 		case HW_VAR_ACM_CTRL:
 			{
 				u8	acm_ctrl = *((u8 *)val);
-				u8	AcmCtrl = rtw_read8( Adapter, REG_ACMHWCTRL);
+				u8	AcmCtrl = rtw_read8(Adapter, REG_ACMHWCTRL);
 
 				if (acm_ctrl > 1)
 					AcmCtrl = AcmCtrl | 0x1;
@@ -4913,8 +4879,8 @@ _func_enter_;
 				else
 					AcmCtrl &= (~AcmHw_BeqEn);
 
-				DBG_8192D("[HW_VAR_ACM_CTRL] Write 0x%X\n", AcmCtrl );
-				rtw_write8(Adapter, REG_ACMHWCTRL, AcmCtrl );
+				DBG_8192D("[HW_VAR_ACM_CTRL] Write 0x%X\n", AcmCtrl);
+				rtw_write8(Adapter, REG_ACMHWCTRL, AcmCtrl);
 			}
 			break;
 		case HW_VAR_AMPDU_MIN_SPACE:
@@ -4997,7 +4963,7 @@ _func_enter_;
 			#ifdef CONFIG_USB_RX_AGGREGATION
 			{
 				u8	threshold = *((u8 *)val);
-				if ( threshold == 0)
+				if (threshold == 0)
 				{
 					threshold = pHalData->UsbRxAggPageCount;
 				}
@@ -5039,11 +5005,11 @@ _func_enter_;
 #endif // CONFIG_P2P_PS
 #ifdef CONFIG_TDLS
 		case HW_VAR_TDLS_WRCR:
-			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)&(~ BIT(6) ));
+			rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)&(~ BIT(6)));
 			break;
 		case HW_VAR_TDLS_INIT_CH_SEN:
 			{
-				rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)&(~ BIT(6) )&(~ BIT(7) ));
+				rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)&(~ BIT(6))&(~ BIT(7)));
 				rtw_write16(Adapter, REG_RXFLTMAP2,0xffff);
 
 				//disable update TSF
@@ -5054,7 +5020,7 @@ _func_enter_;
 			{
 				//enable update TSF
 				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~ BIT(4)));
-				rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|(BIT(7) ));
+				rtw_write32(Adapter, REG_RCR, rtw_read32(Adapter, REG_RCR)|(BIT(7)));
 			}
 			break;
 		case HW_VAR_TDLS_RS_RCR:
@@ -5068,12 +5034,12 @@ _func_enter_;
 
 				if (rx_gain == 0xff){//restore rx gain
 					dig_table->curigvalue = dig_table->backupigvalue;
-					PHY_SetBBReg(Adapter, rOFDM0_XAAGCCore1, 0x7f,dig_table->curigvalue );
+					PHY_SetBBReg(Adapter, rOFDM0_XAAGCCore1, 0x7f,dig_table->curigvalue);
 					PHY_SetBBReg(Adapter, rOFDM0_XBAGCCore1, 0x7f,dig_table->curigvalue);
 				}
 				else{
 					dig_table->backupigvalue = dig_table->curigvalue;
-					PHY_SetBBReg(Adapter, rOFDM0_XAAGCCore1, 0x7f,rx_gain );
+					PHY_SetBBReg(Adapter, rOFDM0_XAAGCCore1, 0x7f,rx_gain);
 					PHY_SetBBReg(Adapter, rOFDM0_XBAGCCore1, 0x7f,rx_gain);
 					dig_table->curigvalue = (u8)rx_gain;
 				}
@@ -5402,16 +5368,16 @@ u8 GetHalDefVar8192DUsb(struct rtw_adapt
 		*((int *)pValue) = pHalData->dmpriv.UndecoratedSmoothedPWDB;
 		break;
 	case HAL_DEF_DRVINFO_SZ:
-		*(( u32*)pValue) = DRVINFO_SZ;
+		*((u32*)pValue) = DRVINFO_SZ;
 		break;
 	case HAL_DEF_MAX_RECVBUF_SZ:
-		*(( u32*)pValue) = MAX_RECVBUF_SZ;
+		*((u32*)pValue) = MAX_RECVBUF_SZ;
 		break;
 	case HAL_DEF_RX_PACKET_OFFSET:
-		*(( u32*)pValue) = RXDESC_SIZE + DRVINFO_SZ;
+		*((u32*)pValue) = RXDESC_SIZE + DRVINFO_SZ;
 		break;
 	case HAL_DEF_DBG_DM_FUNC:
-		*(( u8*)pValue) = pHalData->dmpriv.DMFlag;
+		*((u8*)pValue) = pHalData->dmpriv.DMFlag;
 		break;
 	default:
 		bResult = false;
@@ -5443,7 +5409,7 @@ SetHalDefVar8192DUsb(
 	switch (eVariable) {
 		case HAL_DEF_DBG_DM_FUNC:
 			{
-				u8 dm_func = *(( u8*)pValue);
+				u8 dm_func = *((u8*)pValue);
 				struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
 				if (dm_func == 0){ //disable all dynamic func
@@ -5629,12 +5595,12 @@ void UpdateHalRAMask8192DUsb(struct rtw_
 	}
 
 #ifdef CONFIG_BT_COEXIST
-	if ( (pbtpriv->BT_Coexist) &&
+	if ((pbtpriv->BT_Coexist) &&
 		(pbtpriv->BT_CoexistType == BT_CSR_BC4) &&
 		(pbtpriv->BT_CUR_State) &&
 		(pbtpriv->BT_Ant_isolation) &&
 		((pbtpriv->BT_Service==BT_SCO)||
-		(pbtpriv->BT_Service==BT_Busy)) )
+		(pbtpriv->BT_Service==BT_Busy)))
 		mask &= 0xffffcfc0;
 	else
 #endif
@@ -5711,7 +5677,6 @@ void SetBeaconRelatedRegisters8192DUsb(s
 	//rtw_write8(padapter, 0x542, rtw_read8(padapter, 0x541)|BIT(0));
 
 	rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(1));
-
 }
 
 static void rtl8192du_init_default_value(struct rtw_adapter * padapter)
@@ -5736,7 +5701,6 @@ static void rtl8192du_init_default_value
 	pdmpriv->prv_traffic_idx = 3;
 
 	rtl8192d_PHY_ResetIQKResult(padapter);
-
 }
 
 
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -66,7 +66,7 @@ static int usbctrl_vendorreq(struct intf
 	}
 
 	if (len>MAX_VENDOR_REQ_CMD_SIZE){
-		DBG_8192D( "[%s] Buffer len error ,vendor request failed\n", __func__ );
+		DBG_8192D("[%s] Buffer len error ,vendor request failed\n", __func__);
 		status = -EINVAL;
 		goto exit;
 	}
@@ -81,7 +81,7 @@ static int usbctrl_vendorreq(struct intf
 	pIo_buf = pdvobjpriv->usb_vendor_req_buf;
 #else
 	#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_DYNAMIC_ALLOCATE
-	tmp_buf = rtw_malloc( (u32) len + ALIGNMENT_UNIT);
+	tmp_buf = rtw_malloc((u32) len + ALIGNMENT_UNIT);
 	tmp_buflen =  (u32)len + ALIGNMENT_UNIT;
 	#else // use stack memory
 	tmp_buflen = MAX_USB_IO_CTL_SIZE;
@@ -90,11 +90,11 @@ static int usbctrl_vendorreq(struct intf
 	// Added by Albert 2010/02/09
 	// For mstar platform, mstar suggests the address for USB IO should be 16 bytes alignment.
 	// Trying to fix it here.
-	pIo_buf = (tmp_buf==NULL)?NULL:tmp_buf + ALIGNMENT_UNIT -((SIZE_PTR)(tmp_buf) & 0x0f );
+	pIo_buf = (tmp_buf==NULL)?NULL:tmp_buf + ALIGNMENT_UNIT -((SIZE_PTR)(tmp_buf) & 0x0f);
 #endif
 
-	if ( pIo_buf== NULL) {
-		DBG_8192D( "[%s] pIo_buf == NULL\n", __func__ );
+	if (pIo_buf== NULL) {
+		DBG_8192D("[%s] pIo_buf == NULL\n", __func__);
 		status = -ENOMEM;
 		goto release_mutex;
 	}
@@ -112,17 +112,17 @@ static int usbctrl_vendorreq(struct intf
 		{
 			pipe = usb_sndctrlpipe(udev, 0);//write_out
 			reqtype =  REALTEK_USB_VENQT_WRITE;
-			memcpy( pIo_buf, pdata, len);
+			memcpy(pIo_buf, pdata, len);
 		}
 
 		status = rtw_usb_control_msg(udev, pipe, request, reqtype, value, index, pIo_buf, len, RTW_USB_CONTROL_MSG_TIMEOUT);
 
-		if ( status == len)   // Success this control transfer.
+		if (status == len)   // Success this control transfer.
 		{
 			rtw_reset_continual_urb_error(pdvobjpriv);
-			if ( requesttype == 0x01 )
+			if (requesttype == 0x01)
 			{   // For Control read transfer, we have to copy the read data from pIo_buf to pdata.
-				memcpy( pdata, pIo_buf,  len );
+				memcpy(pdata, pIo_buf,  len);
 			}
 		}
 		else { // error cases
@@ -145,14 +145,14 @@ static int usbctrl_vendorreq(struct intf
 			else // status != len && status >= 0
 			{
 				if (status > 0) {
-					if ( requesttype == 0x01 )
+					if (requesttype == 0x01)
 					{   // For Control read transfer, we have to copy the read data from pIo_buf to pdata.
-						memcpy( pdata, pIo_buf,  len );
+						memcpy(pdata, pIo_buf,  len);
 					}
 				}
 			}
 
-			if (rtw_inc_and_chk_continual_urb_error(pdvobjpriv) == true ){
+			if (rtw_inc_and_chk_continual_urb_error(pdvobjpriv) == true){
 				padapter->bSurpriseRemoved = true;
 				break;
 			}
@@ -160,7 +160,7 @@ static int usbctrl_vendorreq(struct intf
 		}
 
 		// firmware download is checksumed, don't retry
-		if ( (value >= FW_8192D_START_ADDRESS && value <= FW_8192D_END_ADDRESS) || status == len )
+		if ((value >= FW_8192D_START_ADDRESS && value <= FW_8192D_END_ADDRESS) || status == len)
 			break;
 
 	}
@@ -176,7 +176,6 @@ release_mutex:
 	#endif
 exit:
 	return status;
-
 }
 
 static void usb_read_reg_rf_byfw(struct intf_hdl *pintfhdl, u16 byteCount, u32 registerIndex, void *buffer)
@@ -208,7 +207,6 @@ static void usb_read_reg_rf_byfw(struct
 	// IN a vendor request to read back MAC register.
 	//
 	usbctrl_vendorreq(pintfhdl, 0x05, offset, wPage, buffer, byteCount, 0x01);
-
 }
 
 static void usb_read_reg(struct intf_hdl *pintfhdl, u16 value, void *pdata, u16 len)
@@ -273,7 +271,6 @@ static u8 usb_read8(struct intf_hdl *pin
 	_func_exit_;
 
 	return (u8)(le32_to_cpu(data)&0x0ff);
-
 }
 
 static u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr)
@@ -292,7 +289,6 @@ static u16 usb_read16(struct intf_hdl *p
 	_func_exit_;
 
 	return (u16)(le32_to_cpu(data)&0xffff);
-
 }
 
 static u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr)
@@ -316,7 +312,6 @@ static u32 usb_read32(struct intf_hdl *p
 	_func_exit_;
 
 	return le32_to_cpu(data);
-
 }
 
 static int usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
@@ -361,7 +356,6 @@ static int usb_write16(struct intf_hdl *
 	_func_exit_;
 
 	return ret;
-
 }
 
 static int usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
@@ -382,7 +376,6 @@ static int usb_write32(struct intf_hdl *
 	_func_exit_;
 
 	return ret;
-
 }
 
 static int usb_writeN(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata)
@@ -396,14 +389,13 @@ static int usb_writeN(struct intf_hdl *p
 
 	wvalue = (u16)(addr&0x0000ffff);
 	len = length;
-	 memcpy(buf, pdata, len );
+	 memcpy(buf, pdata, len);
 
 	ret = usb_write_reg(pintfhdl, wvalue, buf, len);
 
 	_func_exit_;
 
 	return ret;
-
 }
 
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
@@ -450,7 +442,6 @@ static void usb_read_interrupt_complete(
 				break;
 		}
 	}
-
 }
 
 static u32 usb_read_interrupt(struct intf_hdl *pintfhdl, u32 addr)
@@ -583,8 +574,8 @@ static s32 pre_recv_entry(union recv_fra
 					precvframe_if2->u.hdr.pkt = pkt_copy;
 					precvframe_if2->u.hdr.rx_head = pkt_copy->data;
 					precvframe_if2->u.hdr.rx_end = pkt_copy->data + alloc_sz;
-					skb_reserve( pkt_copy, 8 - ((SIZE_PTR)( pkt_copy->data ) & 7 ));//force pkt_copy->data at 8-byte alignment address
-					skb_reserve( pkt_copy, shift_sz );//force ip_hdr at 8-byte alignment address according to shift_sz.
+					skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));//force pkt_copy->data at 8-byte alignment address
+					skb_reserve(pkt_copy, shift_sz);//force ip_hdr at 8-byte alignment address according to shift_sz.
 					memcpy(pkt_copy->data, pbuf, skb_len);
 					precvframe_if2->u.hdr.rx_data = precvframe_if2->u.hdr.rx_tail = pkt_copy->data;
 				}
@@ -609,7 +600,6 @@ static s32 pre_recv_entry(union recv_fra
 #endif
 
 	return ret;
-
 }
 
 #ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
@@ -712,8 +702,8 @@ static int recvbuf2recvframe(struct rtw_
 			precvframe->u.hdr.pkt = pkt_copy;
 			precvframe->u.hdr.rx_head = pkt_copy->data;
 			precvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;
-			skb_reserve( pkt_copy, 8 - ((SIZE_PTR)( pkt_copy->data ) & 7 ));//force pkt_copy->data at 8-byte alignment address
-			skb_reserve( pkt_copy, shift_sz );//force ip_hdr at 8-byte alignment address according to shift_sz.
+			skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));//force pkt_copy->data at 8-byte alignment address
+			skb_reserve(pkt_copy, shift_sz);//force ip_hdr at 8-byte alignment address according to shift_sz.
 			memcpy(pkt_copy->data, (pbuf + pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE), skb_len);
 			precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
 		}
@@ -811,7 +801,6 @@ void rtl8192du_recv_tasklet(void *priv)
 
 		rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
 	}
-
 }
 
 static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
@@ -882,7 +871,6 @@ static void usb_read_port_complete(struc
 exit:
 
 _func_exit_;
-
 }
 
 static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
@@ -900,7 +888,7 @@ _func_enter_;
 
 	if (adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
 	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:(padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
 		return _FAIL;
 	}
 
@@ -1046,8 +1034,8 @@ static int recvbuf2recvframe(struct rtw_
 			precvframe->u.hdr.pkt = pkt_copy;
 			precvframe->u.hdr.rx_head = pkt_copy->data;
 			precvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;
-			skb_reserve( pkt_copy, 8 - ((SIZE_PTR)( pkt_copy->data ) & 7 ));//force pkt_copy->data at 8-byte alignment address
-			skb_reserve( pkt_copy, shift_sz );//force ip_hdr at 8-byte alignment address according to shift_sz.
+			skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));//force pkt_copy->data at 8-byte alignment address
+			skb_reserve(pkt_copy, shift_sz);//force ip_hdr at 8-byte alignment address according to shift_sz.
 			memcpy(pkt_copy->data, (pbuf + pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE), skb_len);
 			precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
 		}
@@ -1155,7 +1143,6 @@ void rtl8192du_recv_tasklet(void *priv)
 #endif
 
 	}
-
 }
 
 
@@ -1243,7 +1230,6 @@ static void usb_read_port_complete(struc
 exit:
 
 _func_exit_;
-
 }
 
 static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
@@ -1263,7 +1249,7 @@ _func_enter_;
 
 	if (adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
 	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:(padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
 		return _FAIL;
 	}
 
@@ -1377,7 +1363,6 @@ void rtl8192du_xmit_tasklet(void *priv)
 		if (ret==false)
 			break;
 	}
-
 }
 
 void rtl8192du_set_intf_ops(struct _io_ops	*pops)
@@ -1413,5 +1398,4 @@ void rtl8192du_set_intf_ops(struct _io_o
 #endif
 
 	_func_exit_;
-
 }
--- a/drivers/staging/rtl8192du/include/Hal8192DPhyCfg.h
+++ b/drivers/staging/rtl8192du/include/Hal8192DPhyCfg.h
@@ -306,7 +306,7 @@ int	rtl8192d_PHY_ConfigRFWithHeaderFile(
 /* BB/RF readback check for making sure init OK */
 int	rtl8192d_PHY_CheckBBAndRFOK(	struct rtw_adapter *			Adapter,
 				enum HW90_BLOCK		CheckBlock,
-				enum RF_RADIO_PATH_E	eRFPath	  );
+				enum RF_RADIO_PATH_E	eRFPath	 );
 /* Read initi reg value for tx power setting. */
 void	rtl8192d_PHY_GetHWRegOriginalValue(	struct rtw_adapter *		Adapter	);
 
--- a/drivers/staging/rtl8192du/include/basic_types.h
+++ b/drivers/staging/rtl8192du/include/basic_types.h
@@ -98,8 +98,8 @@
 //		4-byte value in host byte ordering.
 //
 #define LE_BITS_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
-	( \
-		( LE_P4BYTE_TO_HOST_4BYTE(__pStart) >> (__BitOffset) ) \
+	(\
+		(LE_P4BYTE_TO_HOST_4BYTE(__pStart) >> (__BitOffset)) \
 		& \
 		BIT_LEN_MASK_32(__BitLen) \
 	)
@@ -110,10 +110,10 @@
 //		and return the result in 4-byte value in host byte ordering.
 //
 #define LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
-	( \
+	(\
 		LE_P4BYTE_TO_HOST_4BYTE(__pStart) \
 		& \
-		( ~BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen) ) \
+		(~BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen)) \
 	)
 
 //
@@ -122,10 +122,10 @@
 //
 #define SET_BITS_TO_LE_4BYTE(__pStart, __BitOffset, __BitLen, __Value) \
 	*((u32 *)(__pStart)) = \
-		EF4Byte( \
+		EF4Byte(\
 			LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
 			| \
-			( (((u32)__Value) & BIT_LEN_MASK_32(__BitLen)) << (__BitOffset) ) \
+			((((u32)__Value) & BIT_LEN_MASK_32(__BitLen)) << (__BitOffset)) \
 		);
 
 
@@ -139,25 +139,25 @@
 	(EF2Byte(*((u16 *)(__pStart))))
 
 #define LE_BITS_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
-	( \
-		( LE_P2BYTE_TO_HOST_2BYTE(__pStart) >> (__BitOffset) ) \
+	(\
+		(LE_P2BYTE_TO_HOST_2BYTE(__pStart) >> (__BitOffset)) \
 		& \
 		BIT_LEN_MASK_16(__BitLen) \
 	)
 
 #define LE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
-	( \
+	(\
 		LE_P2BYTE_TO_HOST_2BYTE(__pStart) \
 		& \
-		( ~BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen) ) \
+		(~BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen)) \
 	)
 
 #define SET_BITS_TO_LE_2BYTE(__pStart, __BitOffset, __BitLen, __Value) \
 	*((u16 *)(__pStart)) = \
-		EF2Byte( \
+		EF2Byte(\
 			LE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
 			| \
-			( (((u16)__Value) & BIT_LEN_MASK_16(__BitLen)) << (__BitOffset) ) \
+			((((u16)__Value) & BIT_LEN_MASK_16(__BitLen)) << (__BitOffset)) \
 		);
 
 #define BIT_LEN_MASK_8(__BitLen) \
@@ -170,25 +170,25 @@
 	(EF1Byte(*((u8 *)(__pStart))))
 
 #define LE_BITS_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
-	( \
-		( LE_P1BYTE_TO_HOST_1BYTE(__pStart) >> (__BitOffset) ) \
+	(\
+		(LE_P1BYTE_TO_HOST_1BYTE(__pStart) >> (__BitOffset)) \
 		& \
 		BIT_LEN_MASK_8(__BitLen) \
 	)
 
 #define LE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
-	( \
+	(\
 		LE_P1BYTE_TO_HOST_1BYTE(__pStart) \
 		& \
-		( ~BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen) ) \
+		(~BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen)) \
 	)
 
 #define SET_BITS_TO_LE_1BYTE(__pStart, __BitOffset, __BitLen, __Value) \
 	*((u8 *)(__pStart)) = \
-		EF1Byte( \
+		EF1Byte(\
 			LE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
 			| \
-			( (((u8)__Value) & BIT_LEN_MASK_8(__BitLen)) << (__BitOffset) ) \
+			((((u8)__Value) & BIT_LEN_MASK_8(__BitLen)) << (__BitOffset)) \
 		);
 
 // Get the N-bytes aligment offset from the current length
--- a/drivers/staging/rtl8192du/include/drv_conf.h
+++ b/drivers/staging/rtl8192du/include/drv_conf.h
@@ -43,7 +43,7 @@
 #endif
 
 #ifdef CONFIG_RESUME_IN_WORKQUEUE //this can be removed, because there is no case for this...
-	#if !defined( CONFIG_WAKELOCK) && !defined(CONFIG_ANDROID_POWER)
+	#if !defined(CONFIG_WAKELOCK) && !defined(CONFIG_ANDROID_POWER)
 	#error "enable CONFIG_RESUME_IN_WORKQUEUE without CONFIG_WAKELOCK or CONFIG_ANDROID_POWER will suffer from the danger of wifi's unfunctionality..."
 	#error "If you still want to enable CONFIG_RESUME_IN_WORKQUEUE in this case, mask this preprossor checking and GOOD LUCK..."
 	#endif
--- a/drivers/staging/rtl8192du/include/hal_com.h
+++ b/drivers/staging/rtl8192du/include/hal_com.h
@@ -130,7 +130,7 @@ hal_com_get_channel_plan(
 	bool		AutoLoadFail
 	);
 
-void	halsetbratecfg( struct rtw_adapter * Adapter, u8 *mBratesOS, u16 *pBrateCfg);
+void	halsetbratecfg(struct rtw_adapter * Adapter, u8 *mBratesOS, u16 *pBrateCfg);
 
 u8	ratetohwrate(u8 rate);
 
--- a/drivers/staging/rtl8192du/include/if_ether.h
+++ b/drivers/staging/rtl8192du/include/if_ether.h
@@ -104,9 +104,9 @@ struct _vlan {
 
 
 
-#define get_vlan_id(pvlan) ((ntohs((unsigned short )pvlan->h_vlan_TCI)) & 0xfff)
-#define get_vlan_priority(pvlan) ((ntohs((unsigned short )pvlan->h_vlan_TCI))>>13)
-#define get_vlan_encap_proto(pvlan) (ntohs((unsigned short )pvlan->h_vlan_encapsulated_proto))
+#define get_vlan_id(pvlan) ((ntohs((unsigned short)pvlan->h_vlan_TCI)) & 0xfff)
+#define get_vlan_priority(pvlan) ((ntohs((unsigned short)pvlan->h_vlan_TCI))>>13)
+#define get_vlan_encap_proto(pvlan) (ntohs((unsigned short)pvlan->h_vlan_encapsulated_proto))
 
 
 #endif	/* _LINUX_IF_ETHER_H */
--- a/drivers/staging/rtl8192du/include/mlme_osdep.h
+++ b/drivers/staging/rtl8192du/include/mlme_osdep.h
@@ -25,11 +25,11 @@
 #include <drv_types.h>
 
 extern void rtw_init_mlme_timer(struct rtw_adapter *padapter);
-extern void rtw_os_indicate_disconnect(struct rtw_adapter *adapter );
-extern void rtw_os_indicate_connect(struct rtw_adapter *adapter );
+extern void rtw_os_indicate_disconnect(struct rtw_adapter *adapter);
+extern void rtw_os_indicate_connect(struct rtw_adapter *adapter);
 void rtw_os_indicate_scan_done(struct rtw_adapter *padapter, bool aborted);
 extern void rtw_report_sec_ie(struct rtw_adapter *adapter,u8 authmode,u8 *sec_ie);
 
-void rtw_reset_securitypriv(struct rtw_adapter *adapter );
+void rtw_reset_securitypriv(struct rtw_adapter *adapter);
 
 #endif	//_MLME_OSDEP_H_
--- a/drivers/staging/rtl8192du/include/osdep_service.h
+++ b/drivers/staging/rtl8192du/include/osdep_service.h
@@ -237,7 +237,7 @@ static inline int rtw_netif_queue_stoppe
 	return (netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 0)) &&
 		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 1)) &&
 		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 2)) &&
-		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 3)) );
+		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 3)));
 #else
 	return netif_queue_stopped(pnetdev);
 #endif
@@ -273,7 +273,7 @@ static inline void rtw_netif_stop_queue(
 #include <rtw_byteorder.h>
 
 #ifndef BIT
-	#define BIT(x)	( 1 << (x))
+	#define BIT(x)	(1 << (x))
 #endif
 
 extern int RTW_STATUS_CODE(int error_code);
@@ -497,7 +497,7 @@ struct rtw_netdev_priv_indicator {
 struct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv);
 extern struct net_device * rtw_alloc_etherdev(int sizeof_priv);
 
-#define rtw_netdev_priv(netdev) ( ((struct rtw_netdev_priv_indicator *)netdev_priv(netdev))->priv )
+#define rtw_netdev_priv(netdev) (((struct rtw_netdev_priv_indicator *)netdev_priv(netdev))->priv)
 
 extern void rtw_free_netdev(struct net_device * netdev);
 
--- a/drivers/staging/rtl8192du/include/rtl8192d_cmd.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_cmd.h
@@ -108,7 +108,7 @@ void	rtl8192d_set_p2p_ps_offload_cmd(str
 #endif //CONFIG_P2P
 
 #ifdef CONFIG_TSF_RESET_OFFLOAD
-int reset_tsf(struct rtw_adapter * Adapter, u8 reset_port );
+int reset_tsf(struct rtw_adapter * Adapter, u8 reset_port);
 #endif	// CONFIG_TSF_RESET_OFFLOAD
 
 #ifdef CONFIG_WOWLAN
--- a/drivers/staging/rtl8192du/include/rtl8192d_hal.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_hal.h
@@ -243,7 +243,7 @@ static u32 TargetChnl_2G[TARGET_CHNL_NUM
 					(le16_to_cpu(_pFwHdr->Signature)&0xFFFF) == 0x92D0 ||\
 					(le16_to_cpu(_pFwHdr->Signature)&0xFFFF) == 0x92D1 ||\
 					(le16_to_cpu(_pFwHdr->Signature)&0xFFFF) == 0x92D2 ||\
-					(le16_to_cpu(_pFwHdr->Signature)&0xFFFF) == 0x92D3 )
+					(le16_to_cpu(_pFwHdr->Signature)&0xFFFF) == 0x92D3)
 
 #define FW_8192D_SIZE				0x8020 // Max FW len = 32k + 32(FW header length).
 #define FW_8192D_START_ADDRESS	0x1000
@@ -737,7 +737,7 @@ extern void Hal_SetBandwidth(struct rtw_
 
 extern void Hal_SetTxPower(struct rtw_adapter * pAdapter);
 extern void Hal_SetCarrierSuppressionTx(struct rtw_adapter * pAdapter, u8 bStart);
-extern void Hal_SetSingleToneTx ( struct rtw_adapter * pAdapter , u8 bStart );
+extern void Hal_SetSingleToneTx (struct rtw_adapter * pAdapter , u8 bStart);
 extern void Hal_SetSingleCarrierTx (struct rtw_adapter * pAdapter, u8 bStart);
 extern void Hal_SetContinuousTx (struct rtw_adapter * pAdapter, u8 bStart);
 extern void Hal_SetBandwidth(struct rtw_adapter * pAdapter);
--- a/drivers/staging/rtl8192du/include/rtl8192d_rf.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_rf.h
@@ -20,7 +20,7 @@
 /******************************************************************************
  *
  *
- * Module:	rtl8192d_rf.h	( Header File)
+ * Module:	rtl8192d_rf.h	(Header File)
  *
  * Note:	Collect every HAL RF type exter API or constant.
  *
--- a/drivers/staging/rtl8192du/include/rtl8192d_spec.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_spec.h
@@ -493,7 +493,7 @@
 
 
 //
-// 9. Security Control Registers	(Offset: )
+// 9. Security Control Registers	(Offset:)
 //
 #define	RWCAM						REG_CAMCMD		//IN 8190 Data Sheet is called CAMcmd
 #define	WCAMI						REG_CAMWRITE	// Software write CAM input content
@@ -1363,9 +1363,9 @@ Current IOREG MAP
 #define _TXDMA_HIQ_MAP(x)			(((x)&0x3) << 14)
 #define _TXDMA_MGQ_MAP(x)			(((x)&0x3) << 12)
 #define _TXDMA_BKQ_MAP(x)			(((x)&0x3) << 10)
-#define _TXDMA_BEQ_MAP(x)			(((x)&0x3) << 8 )
-#define _TXDMA_VIQ_MAP(x)			(((x)&0x3) << 6 )
-#define _TXDMA_VOQ_MAP(x)			(((x)&0x3) << 4 )
+#define _TXDMA_BEQ_MAP(x)			(((x)&0x3) << 8)
+#define _TXDMA_VIQ_MAP(x)			(((x)&0x3) << 6)
+#define _TXDMA_VOQ_MAP(x)			(((x)&0x3) << 4)
 
 #define QUEUE_LOW					1
 #define QUEUE_NORMAL				2
--- a/drivers/staging/rtl8192du/include/rtw_cmd.h
+++ b/drivers/staging/rtl8192du/include/rtw_cmd.h
@@ -142,7 +142,7 @@ extern void rtw_free_evt_priv (struct ev
 extern void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv);
 extern void rtw_evt_notify_isr(struct evt_priv *pevtpriv);
 #ifdef CONFIG_P2P
-u8 p2p_protocol_wk_cmd(struct rtw_adapter*padapter, int intCmdType );
+u8 p2p_protocol_wk_cmd(struct rtw_adapter*padapter, int intCmdType);
 #endif //CONFIG_P2P
 
 enum rtw_drvextra_cmd_id
--- a/drivers/staging/rtl8192du/include/rtw_debug.h
+++ b/drivers/staging/rtl8192du/include/rtw_debug.h
@@ -212,7 +212,7 @@
 				u8	*ptr = (u8 *)_HexData;				\
 				_dbgdump("Rtl871x: ");						\
 				_dbgdump(_TitleString);						\
-				for ( __i=0; __i<(int)_HexDataLen; __i++ )				\
+				for (__i=0; __i<(int)_HexDataLen; __i++)				\
 				{								\
 					_dbgdump("%02X%s", ptr[__i], (((__i + 1) % 4) == 0)?"  ":" ");	\
 					if (((__i + 1) % 16) == 0)	_dbgdump("\n");			\
--- a/drivers/staging/rtl8192du/include/rtw_efuse.h
+++ b/drivers/staging/rtl8192du/include/rtw_efuse.h
@@ -53,9 +53,9 @@ enum _EFUSE_DEF_TYPE {
 #define		EFUSE_MAX_HW_SIZE		512
 #define		EFUSE_MAX_SECTION_BASE	16
 
-#define EXT_HEADER(header) ((header & 0x1F ) == 0x0F)
+#define EXT_HEADER(header) ((header & 0x1F) == 0x0F)
 #define ALL_WORDS_DISABLED(wde)	((wde & 0x0F) == 0x0F)
-#define GET_HDR_OFFSET_2_0(header) ( (header & 0xE0) >> 5)
+#define GET_HDR_OFFSET_2_0(header) ((header & 0xE0) >> 5)
 
 #define		EFUSE_REPEAT_THRESHOLD_			3
 
--- a/drivers/staging/rtl8192du/include/rtw_io.h
+++ b/drivers/staging/rtl8192du/include/rtw_io.h
@@ -105,8 +105,8 @@
 
 */
 
-#define IO_WR_BURST(x)		(_IO_WRITE_ | _IO_SYNC_ | _IO_BURST_ | ( (x) & _IOSZ_MASK_))
-#define IO_RD_BURST(x)		(_IO_SYNC_ | _IO_BURST_ | ( (x) & _IOSZ_MASK_))
+#define IO_WR_BURST(x)		(_IO_WRITE_ | _IO_SYNC_ | _IO_BURST_ | ((x) & _IOSZ_MASK_))
+#define IO_RD_BURST(x)		(_IO_SYNC_ | _IO_BURST_ | ((x) & _IOSZ_MASK_))
 
 
 
--- a/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
@@ -27,7 +27,7 @@
 
 
 //	Commented by Albert 20101105
-//	Increase the SURVEY_TO value from 100 to 150  ( 100ms to 150ms )
+//	Increase the SURVEY_TO value from 100 to 150  (100ms to 150ms)
 //	The Realtek 8188CE SoftAP will spend around 100ms to send the probe response after receiving the probe request.
 //	So, this driver tried to extend the dwell time for each scanning channel.
 //	This will increase the chance to receive the probe response from SoftAP.
@@ -611,7 +611,7 @@ void issue_p2p_GO_request(struct rtw_ada
 void issue_probereq_p2p(struct rtw_adapter *padapter, u8 *da);
 int issue_probereq_p2p_ex(struct rtw_adapter *adapter, u8 *da, int try_cnt, int wait_ms);
 void issue_p2p_invitation_response(struct rtw_adapter *padapter, u8* raddr, u8 dialogToken, u8 success);
-void issue_p2p_invitation_request(struct rtw_adapter *padapter, u8* raddr );
+void issue_p2p_invitation_request(struct rtw_adapter *padapter, u8* raddr);
 #endif //CONFIG_P2P
 void issue_beacon(struct rtw_adapter *padapter);
 void issue_probersp(struct rtw_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probereq);
--- a/drivers/staging/rtl8192du/include/rtw_mp.h
+++ b/drivers/staging/rtl8192du/include/rtw_mp.h
@@ -207,7 +207,7 @@ struct mpt_context {
 
 /* end of E-Fuse */
 
-//#define RTPRIV_IOCTL_MP					( SIOCIWFIRSTPRIV + 0x17)
+//#define RTPRIV_IOCTL_MP					(SIOCIWFIRSTPRIV + 0x17)
 enum {
 	WRITE_REG = 1,
 	READ_REG,
@@ -468,7 +468,7 @@ extern void Hal_SetBandwidth(struct rtw_
 
 extern void Hal_SetTxPower(struct rtw_adapter * pAdapter);
 extern void Hal_SetCarrierSuppressionTx(struct rtw_adapter * pAdapter, u8 bStart);
-extern void Hal_SetSingleToneTx ( struct rtw_adapter * pAdapter, u8 bStart );
+extern void Hal_SetSingleToneTx (struct rtw_adapter * pAdapter, u8 bStart);
 extern void Hal_SetSingleCarrierTx (struct rtw_adapter * pAdapter, u8 bStart);
 extern void Hal_SetContinuousTx (struct rtw_adapter * pAdapter, u8 bStart);
 extern void Hal_SetBandwidth(struct rtw_adapter * pAdapter);
--- a/drivers/staging/rtl8192du/include/rtw_p2p.h
+++ b/drivers/staging/rtl8192du/include/rtw_p2p.h
@@ -24,7 +24,7 @@
 
 u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
 u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8* pssid, u8 ussidlen, u8* pdev_raddr );
+u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8* pssid, u8 ussidlen, u8* pdev_raddr);
 u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 status_code);
 u32 build_deauth_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
 #ifdef CONFIG_WFD
@@ -48,9 +48,9 @@ u32 process_p2p_devdisc_req(struct wifid
 u32 process_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
 u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,  u8 *pframe, uint len);
 u8 process_p2p_provdisc_resp(struct wifidirect_info *pwdinfo,  u8 *pframe);
-u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe, uint len );
-u8 process_p2p_group_negotation_resp( struct wifidirect_info *pwdinfo, u8 *pframe, uint len );
-u8 process_p2p_group_negotation_confirm( struct wifidirect_info *pwdinfo, u8 *pframe, uint len );
+u8 process_p2p_group_negotation_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u8 process_p2p_group_negotation_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u8 process_p2p_group_negotation_confirm(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
 u8 process_p2p_presence_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
 
 void p2p_protocol_wk_hdl(struct rtw_adapter *padapter, int intCmdType);
--- a/drivers/staging/rtl8192du/include/rtw_pwrctrl.h
+++ b/drivers/staging/rtl8192du/include/rtw_pwrctrl.h
@@ -306,7 +306,7 @@ void rtw_ps_processor(struct rtw_adapter
 int autoresume_enter(struct rtw_adapter* padapter);
 #endif
 #ifdef SUPPORT_HW_RFOFF_DETECTED
-rt_rf_power_state RfOnOffDetect(IN	struct rtw_adapter * pAdapter );
+rt_rf_power_state RfOnOffDetect(IN	struct rtw_adapter * pAdapter);
 #endif
 
 
@@ -319,7 +319,7 @@ void rtw_lps_leave(struct rtw_adapter *
 void rtw_resume_in_workqueue(struct pwrctrl_priv *pwrpriv);
 #endif //CONFIG_RESUME_IN_WORKQUEUE
 
-#if defined(CONFIG_HAS_EARLYSUSPEND ) || defined(CONFIG_ANDROID_POWER)
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
 bool rtw_is_earlysuspend_registered(struct pwrctrl_priv *pwrpriv);
 bool rtw_is_do_late_resume(struct pwrctrl_priv *pwrpriv);
 void rtw_set_do_late_resume(struct pwrctrl_priv *pwrpriv, bool enable);
--- a/drivers/staging/rtl8192du/include/rtw_recv.h
+++ b/drivers/staging/rtl8192du/include/rtw_recv.h
@@ -326,7 +326,7 @@ struct recv_buf {
 
 	end   ----->
 
-	len = (unsigned int )(tail - data);
+	len = (unsigned int)(tail - data);
 
 */
 struct recv_frame_hdr
@@ -435,7 +435,7 @@ static inline u8 *recvframe_push(union r
 
 
 	precvframe->u.hdr.rx_data -= sz ;
-	if ( precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head )
+	if (precvframe->u.hdr.rx_data < precvframe->u.hdr.rx_head)
 	{
 		precvframe->u.hdr.rx_data += sz ;
 		return NULL;
@@ -584,7 +584,7 @@ static inline int get_recvframe_len(unio
 	return precvframe->u.hdr.len;
 }
 
-static inline u8 query_rx_pwr_percentage(s8 antpower )
+static inline u8 query_rx_pwr_percentage(s8 antpower)
 {
 	if ((antpower <= -100) || (antpower >= 20))
 	{
--- a/drivers/staging/rtl8192du/include/rtw_security.h
+++ b/drivers/staging/rtl8192du/include/rtw_security.h
@@ -107,7 +107,7 @@ struct security_priv
 	u32	dot11DefKeylen[4];
 
 	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key
-	u32	dot118021XGrpKeyid;		// key id used for Grp Key ( tx key index)
+	u32	dot118021XGrpKeyid;		// key id used for Grp Key (tx key index)
 	union Keytype	dot118021XGrpKey[4];	// 802.1x Group Key, for inx0 and inx1
 	union Keytype	dot118021XGrptxmickey[4];
 	union Keytype	dot118021XGrprxmickey[4];
@@ -200,7 +200,7 @@ do{\
 }while (0)
 
 
-#define SET_ICE_IV_LEN( iv_len, icv_len, encrypt)\
+#define SET_ICE_IV_LEN(iv_len, icv_len, encrypt)\
 do{\
 	switch (encrypt)\
 	{\
@@ -236,8 +236,8 @@ do{\
 }while (0)
 
 
-#define ROL32( A, n )	( ((A) << (n)) | ( ((A)>>(32-(n)))  & ( (1UL << (n)) - 1 ) ) )
-#define ROR32( A, n )	ROL32( (A), 32-(n) )
+#define ROL32(A, n)	(((A) << (n)) | (((A)>>(32-(n)))  & ((1UL << (n)) - 1)))
+#define ROR32(A, n)	ROL32((A), 32-(n))
 
 struct mic_data
 {
@@ -356,7 +356,7 @@ static const unsigned long K[64] = {
 
 /* Various logical functions */
 #define RORc(x, y) \
-( ((((unsigned long) (x) & 0xFFFFFFFFUL) >> (unsigned long) ((y) & 31)) | \
+(((((unsigned long) (x) & 0xFFFFFFFFUL) >> (unsigned long) ((y) & 31)) | \
    ((unsigned long) (x) << (unsigned long) (32 - ((y) & 31)))) & 0xFFFFFFFFUL)
 #define Ch(x,y,z)       (z ^ (x & (y ^ z)))
 #define Maj(x,y,z)      (((x | y) & z) | (x & y))
@@ -370,10 +370,10 @@ static const unsigned long K[64] = {
 #define MIN(x, y) (((x) < (y)) ? (x) : (y))
 #endif
 
-void rtw_secmicsetkey(struct mic_data *pmicdata, u8 * key );
-void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b );
-void rtw_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nBytes );
-void rtw_secgetmic(struct mic_data *pmicdata, u8 * dst );
+void rtw_secmicsetkey(struct mic_data *pmicdata, u8 * key);
+void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b);
+void rtw_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nBytes);
+void rtw_secgetmic(struct mic_data *pmicdata, u8 * dst);
 
 void rtw_seccalctkipmic(
 	u8 * key,
--- a/drivers/staging/rtl8192du/include/swab.h
+++ b/drivers/staging/rtl8192du/include/swab.h
@@ -43,7 +43,7 @@ static inline __u16  ___swab16(__u16 x)
 	return
 	((__u16)(
 		(((__u16)(__x) & (__u16)0x00ffU) << 8) |
-		(((__u16)(__x) & (__u16)0xff00U) >> 8) ));
+		(((__u16)(__x) & (__u16)0xff00U) >> 8)));
 
 }
 
@@ -54,7 +54,7 @@ static inline __u32  ___swab32(__u32 x)
 		(((__u32)(__x) & (__u32)0x000000ffUL) << 24) |
 		(((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) |
 		(((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) |
-		(((__u32)(__x) & (__u32)0xff000000UL) >> 24) ));
+		(((__u32)(__x) & (__u32)0xff000000UL) >> 24)));
 }
 
 static inline __u64  ___swab64(__u64 x)
@@ -62,7 +62,7 @@ static inline __u64  ___swab64(__u64 x)
 	__u64 __x = (x);
 
 	return
-	((__u64)( \
+	((__u64)(\
 		(__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
 		(__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
 		(__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
@@ -70,7 +70,7 @@ static inline __u64  ___swab64(__u64 x)
 	        (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
 		(__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
 		(__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
-		(__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); \
+		(__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56))); \
 }
 
 #ifndef __arch__swab16
--- a/drivers/staging/rtl8192du/include/swabb.h
+++ b/drivers/staging/rtl8192du/include/swabb.h
@@ -47,26 +47,26 @@
 #define ___swahw32(x) \
 ({ \
 	__u32 __x = (x); \
-	((__u32)( \
+	((__u32)(\
 		(((__u32)(__x) & (__u32)0x0000ffffUL) << 16) | \
-		(((__u32)(__x) & (__u32)0xffff0000UL) >> 16) )); \
+		(((__u32)(__x) & (__u32)0xffff0000UL) >> 16))); \
 })
 #define ___swahb32(x) \
 ({ \
 	__u32 __x = (x); \
-	((__u32)( \
+	((__u32)(\
 		(((__u32)(__x) & (__u32)0x00ff00ffUL) << 8) | \
-		(((__u32)(__x) & (__u32)0xff00ff00UL) >> 8) )); \
+		(((__u32)(__x) & (__u32)0xff00ff00UL) >> 8))); \
 })
 
 #define ___constant_swahw32(x) \
-	((__u32)( \
+	((__u32)(\
 		(((__u32)(x) & (__u32)0x0000ffffUL) << 16) | \
-		(((__u32)(x) & (__u32)0xffff0000UL) >> 16) ))
+		(((__u32)(x) & (__u32)0xffff0000UL) >> 16)))
 #define ___constant_swahb32(x) \
-	((__u32)( \
+	((__u32)(\
 		(((__u32)(x) & (__u32)0x00ff00ffUL) << 8) | \
-		(((__u32)(x) & (__u32)0xff00ff00UL) >> 8) ))
+		(((__u32)(x) & (__u32)0xff00ff00UL) >> 8)))
 
 /*
  * provide defaults when no architecture-specific optimization is detected
--- a/drivers/staging/rtl8192du/include/usb_ops.h
+++ b/drivers/staging/rtl8192du/include/usb_ops.h
@@ -69,7 +69,7 @@ static inline int rtw_inc_and_chk_contin
 {
 	int ret = false;
 	int value;
-	if ( (value=ATOMIC_INC_RETURN(&dvobj->continual_urb_error)) > MAX_CONTINUAL_URB_ERR) {
+	if ((value=ATOMIC_INC_RETURN(&dvobj->continual_urb_error)) > MAX_CONTINUAL_URB_ERR) {
 		DBG_8192D("[dvobj:%p][ERROR] continual_urb_error:%d > %d\n", dvobj, value, MAX_CONTINUAL_URB_ERR);
 		ret = true;
 	} else {
--- a/drivers/staging/rtl8192du/include/wifi.h
+++ b/drivers/staging/rtl8192du/include/wifi.h
@@ -383,12 +383,12 @@ enum WIFI_REG_DOMAIN {
 
 #define SetEOSP(pbuf, eosp)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16( (eosp & 1) << 4); \
+		*(unsigned short *)(pbuf) |= cpu_to_le16((eosp & 1) << 4); \
 	} while (0)
 
 #define SetAckpolicy(pbuf, ack)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16( (ack & 3) << 5); \
+		*(unsigned short *)(pbuf) |= cpu_to_le16((ack & 3) << 5); \
 	} while (0)
 
 #define GetAckpolicy(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 5) & 0x3)
@@ -397,7 +397,7 @@ enum WIFI_REG_DOMAIN {
 
 #define SetAMsdu(pbuf, amsdu)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16( (amsdu & 1) << 7); \
+		*(unsigned short *)(pbuf) |= cpu_to_le16((amsdu & 1) << 7); \
 	} while (0)
 
 #define GetAid(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 2)) & 0x3fff)
@@ -413,10 +413,10 @@ enum WIFI_REG_DOMAIN {
 #define GetAddr4Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 24))
 
 #define MacAddr_isBcst(addr) \
-( \
-	( (addr[0] == 0xff) && (addr[1] == 0xff) && \
+(\
+	((addr[0] == 0xff) && (addr[1] == 0xff) && \
 		(addr[2] == 0xff) && (addr[3] == 0xff) && \
-		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? true : false \
+		(addr[4] == 0xff) && (addr[5] == 0xff))  ? true : false \
 )
 
 __inline static int IS_MCAST(unsigned char *da)
@@ -986,7 +986,7 @@ struct ADDBA_request
 #define	P2P_GRPCAP_PERSISTENT_RECONN		BIT(5)
 #define	P2P_GRPCAP_GROUP_FORMATION			BIT(6)
 
-//	P2P Public Action Frame ( Management Frame )
+//	P2P Public Action Frame (Management Frame)
 #define	P2P_PUB_ACTION_ACTION				0x09
 
 //	P2P Public Action Frame Type
@@ -1026,7 +1026,7 @@ struct ADDBA_request
 #define	P2P_TX_PRESCAN_TIMEOUT				100		//	100ms
 #define	P2P_INVITE_TIMEOUT					5000	//	5 seconds timeout for sending the invitation request
 #define	P2P_CONCURRENT_INVITE_TIMEOUT		3000	//	3 seconds timeout for sending the invitation request under concurrent mode
-#define	P2P_RESET_SCAN_CH						15000	//	15 seconds timeout to reset the scan channel ( based on channel plan )
+#define	P2P_RESET_SCAN_CH						15000	//	15 seconds timeout to reset the scan channel (based on channel plan)
 #define	P2P_MAX_INTENT						15
 
 #define	P2P_MAX_NOA_NUM						2
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -365,7 +365,7 @@ static int rtw_cfg80211_inform_bss(_adap
 	notify_ielen = pnetwork->network.IELength-_FIXED_IE_LENGTH_;
 
 	//We've set wiphy's signal_type as CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm)
-	if ( check_fwstate(pmlmepriv, _FW_LINKED)== true &&
+	if (check_fwstate(pmlmepriv, _FW_LINKED)== true &&
 		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network)) {
 		notify_signal = 100*translate_percentage_to_dbm(padapter->recvpriv.signal_strength);//dbm
 	} else {
@@ -449,9 +449,9 @@ static int rtw_cfg80211_inform_bss(_adap
 
 /*
 	{
-		if ( bss->information_elements == bss->proberesp_ies)
+		if (bss->information_elements == bss->proberesp_ies)
 		{
-			if ( bss->len_information_elements !=  bss->len_proberesp_ies)
+			if (bss->len_information_elements !=  bss->len_proberesp_ies)
 			{
 				DBG_8192C("error!, len_information_elements !=  bss->len_proberesp_ies\n");
 			}
@@ -469,7 +469,6 @@ static int rtw_cfg80211_inform_bss(_adap
 
 exit:
 	return ret;
-
 }
 
 void rtw_cfg80211_indicate_connect(_adapter *padapter)
@@ -571,9 +570,9 @@ void rtw_cfg80211_indicate_disconnect(_a
 #ifdef CONFIG_P2P
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
-		_cancel_timer_ex( &pwdinfo->find_phase_timer );
-		_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
-		_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
+		_cancel_timer_ex(&pwdinfo->find_phase_timer);
+		_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
+		_cancel_timer_ex(&pwdinfo->pre_tx_scan_timer);
 
 		rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
 		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
@@ -607,7 +606,7 @@ static u8 set_pairwise_key(_adapter *pad
 	u8	res=_SUCCESS;
 
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if ( ph2c == NULL){
+	if (ph2c == NULL){
 		res= _FAIL;
 		goto exit;
 	}
@@ -634,7 +633,6 @@ static u8 set_pairwise_key(_adapter *pad
 exit:
 
 	return res;
-
 }
 
 static int set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid)
@@ -700,7 +698,6 @@ exit:
 
 	return res;
 
-
 }
 
 static int set_wep_key(_adapter *padapter, u8 *key, u8 keylen, int keyid)
@@ -720,7 +717,6 @@ static int set_wep_key(_adapter *padapte
 	}
 
 	return set_group_key(padapter, key, alg, keyid);
-
 }
 
 static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
@@ -1008,7 +1004,6 @@ static int rtw_cfg80211_ap_set_encryptio
 exit:
 
 	return ret;
-
 }
 #endif
 
@@ -1103,7 +1098,7 @@ _func_enter_;
 		{
 			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
 			if (psta == NULL) {
-				//DEBUG_ERR( ("Set wpa_set_encryption: Obtain Sta_info fail\n"));
+				//DEBUG_ERR(("Set wpa_set_encryption: Obtain Sta_info fail\n"));
 				DBG_8192C("%s, : Obtain Sta_info fail\n", __func__);
 			}
 			else
@@ -1166,7 +1161,7 @@ _func_enter_;
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
 			if (pbcmc_sta==NULL)
 			{
-				//DEBUG_ERR( ("Set OID_802_11_ADD_KEY: bcmc stainfo is null\n"));
+				//DEBUG_ERR(("Set OID_802_11_ADD_KEY: bcmc stainfo is null\n"));
 			}
 			else
 			{
@@ -1295,7 +1290,6 @@ static int cfg80211_rtw_add_key(struct w
 		kfree(param);
 
 	return ret;
-
 }
 
 static int cfg80211_rtw_get_key(struct wiphy *wiphy, struct net_device *ndev,
@@ -1371,7 +1365,6 @@ static int cfg80211_rtw_set_default_key(
 	}
 
 	return 0;
-
 }
 
 static int cfg80211_rtw_get_station(struct wiphy *wiphy,
@@ -1531,9 +1524,9 @@ static int cfg80211_rtw_change_iface(str
 		#ifdef CONFIG_P2P
 		if (change && rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 		{
-			_cancel_timer_ex( &pwdinfo->find_phase_timer );
-			_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
-			_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
+			_cancel_timer_ex(&pwdinfo->find_phase_timer);
+			_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
+			_cancel_timer_ex(&pwdinfo->pre_tx_scan_timer);
 
 			//it means remove GO and change mode from AP(GO) to station(P2P DEVICE)
 			rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
@@ -1700,7 +1693,7 @@ static int rtw_cfg80211_set_probe_req_wp
 			}
 
 			pmlmepriv->wps_probe_req_ie = rtw_malloc(wps_ielen);
-			if ( pmlmepriv->wps_probe_req_ie == NULL) {
+			if (pmlmepriv->wps_probe_req_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 				return -EINVAL;
 
@@ -1728,7 +1721,7 @@ static int rtw_cfg80211_set_probe_req_wp
 			}
 
 			pmlmepriv->p2p_probe_req_ie = rtw_malloc(p2p_ielen);
-			if ( pmlmepriv->p2p_probe_req_ie == NULL) {
+			if (pmlmepriv->p2p_probe_req_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 				return -EINVAL;
 
@@ -1757,7 +1750,7 @@ static int rtw_cfg80211_set_probe_req_wp
 			}
 
 			pmlmepriv->wfd_probe_req_ie = rtw_malloc(wfd_ielen);
-			if ( pmlmepriv->wfd_probe_req_ie == NULL) {
+			if (pmlmepriv->wfd_probe_req_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 				return -EINVAL;
 
@@ -1769,7 +1762,6 @@ static int rtw_cfg80211_set_probe_req_wp
 	}
 
 	return ret;
-
 }
 
 static int cfg80211_rtw_scan(struct wiphy *wiphy
@@ -1873,7 +1865,7 @@ static int cfg80211_rtw_scan(struct wiph
 
 	if (request->ie && request->ie_len>0)
 	{
-		rtw_cfg80211_set_probe_req_wpsp2pie(padapter, (u8 *)request->ie, request->ie_len );
+		rtw_cfg80211_set_probe_req_wpsp2pie(padapter, (u8 *)request->ie, request->ie_len);
 	}
 
 	if (pmlmepriv->LinkDetectInfo.bBusyTraffic == true)
@@ -1981,7 +1973,6 @@ check_need_indicate_scan_done:
 exit:
 
 	return ret;
-
 }
 
 static int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy, u32 changed)
@@ -2026,7 +2017,6 @@ static int rtw_cfg80211_set_wpa_version(
 */
 
 	return 0;
-
 }
 
 static int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv,
@@ -2063,7 +2053,6 @@ static int rtw_cfg80211_set_auth_type(st
 	}
 
 	return 0;
-
 }
 
 static int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv, u32 cipher, bool ucast)
@@ -2300,7 +2289,7 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 			}
 
 			pmlmepriv->p2p_assoc_req_ie = rtw_malloc(p2p_ielen);
-			if ( pmlmepriv->p2p_assoc_req_ie == NULL) {
+			if (pmlmepriv->p2p_assoc_req_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 				goto exit;
 			}
@@ -2331,7 +2320,7 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 			}
 
 			pmlmepriv->wfd_assoc_req_ie = rtw_malloc(wfd_ielen);
-			if ( pmlmepriv->wfd_assoc_req_ie == NULL) {
+			if (pmlmepriv->wfd_assoc_req_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 				goto exit;
 			}
@@ -2732,7 +2721,7 @@ static int cfg80211_rtw_set_pmksa(struct
 
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
 
-	if ( _rtw_memcmp( pmksa->bssid, strZeroMacAddress, ETH_ALEN ) == true )
+	if (_rtw_memcmp(pmksa->bssid, strZeroMacAddress, ETH_ALEN) == true)
 	{
 		return -EINVAL;
 	}
@@ -2742,11 +2731,11 @@ static int cfg80211_rtw_set_pmksa(struct
 	//overwrite PMKID
 	for (index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
-		if ( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==true )
+		if (_rtw_memcmp(psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==true)
 		{ // BSSID is matched, the same AP => rewrite with new PMKID.
 			DBG_871X(FUNC_NDEV_FMT" BSSID exists in the PMKList.\n", FUNC_NDEV_ARG(netdev));
 
-			memcpy( psecuritypriv->PMKIDList[index].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
+			memcpy(psecuritypriv->PMKIDList[index].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
 			psecuritypriv->PMKIDList[index].bUsed = true;
 			psecuritypriv->PMKIDIndex = index+1;
 			blInserted = true;
@@ -2758,7 +2747,7 @@ static int cfg80211_rtw_set_pmksa(struct
 	{
 		// Find a new entry
 		DBG_871X(FUNC_NDEV_FMT" Use the new entry index = %d for this PMKID.\n",
-			FUNC_NDEV_ARG(netdev), psecuritypriv->PMKIDIndex );
+			FUNC_NDEV_ARG(netdev), psecuritypriv->PMKIDIndex);
 
 		memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, pmksa->bssid, ETH_ALEN);
 		memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
@@ -2786,10 +2775,10 @@ static int cfg80211_rtw_del_pmksa(struct
 
 	for (index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
-		if ( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==true )
+		if (_rtw_memcmp(psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==true)
 		{ // BSSID is matched, the same AP => Remove this PMKID information and reset it.
-			memset( psecuritypriv->PMKIDList[index].Bssid, 0x00, ETH_ALEN );
-			memset( psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN );
+			memset(psecuritypriv->PMKIDList[index].Bssid, 0x00, ETH_ALEN);
+			memset(psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN);
 			psecuritypriv->PMKIDList[index].bUsed = false;
 			bMatched = true;
 			break;
@@ -2814,7 +2803,7 @@ static int cfg80211_rtw_flush_pmksa(stru
 
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
 
-	memset( &psecuritypriv->PMKIDList[ 0 ], 0x00, sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+	memset(&psecuritypriv->PMKIDList[ 0 ], 0x00, sizeof(RT_PMKID_LIST) * NUM_PMKID_CACHE);
 	psecuritypriv->PMKIDIndex = 0;
 
 	return 0;
@@ -2868,7 +2857,6 @@ void rtw_cfg80211_indicate_sta_assoc(_ad
 	}
 	#endif //COMPAT_KERNEL_RELEASE
 #endif /* defined(RTW_USE_CFG80211_STA_EVENT) */
-
 }
 
 void rtw_cfg80211_indicate_sta_disassoc(_adapter *padapter, unsigned char *da, unsigned short reason)
@@ -3073,9 +3061,9 @@ dump:
 
 			pwfd_info = padapter->wdinfo.wfd_info;
 
-			if ( true == pwfd_info->wfd_enable )
+			if (true == pwfd_info->wfd_enable)
 			{
-				rtw_append_wfd_ie( padapter, pframe, &len );
+				rtw_append_wfd_ie(padapter, pframe, &len);
 			}
 		}
 		#endif // CONFIG_WFD
@@ -3104,7 +3092,6 @@ fail:
 	dev_kfree_skb(skb);
 
 	return 0;
-
 }
 
 static void rtw_cfg80211_monitor_if_set_multicast_list(struct net_device *ndev)
@@ -3141,7 +3128,7 @@ static int rtw_cfg80211_add_monitor_if (
 	struct rtw_netdev_priv_indicator *pnpi;
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 
-	if (!name ) {
+	if (!name) {
 		DBG_871X(FUNC_ADPT_FMT" without specific name\n", FUNC_ADPT_ARG(padapter));
 		ret = -EINVAL;
 		goto out;
@@ -3379,9 +3366,9 @@ static int rtw_add_beacon(_adapter *adap
 			}
 			else
 			{
-				_cancel_timer_ex( &pwdinfo->find_phase_timer );
-				_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
-				_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
+				_cancel_timer_ex(&pwdinfo->find_phase_timer);
+				_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
+				_cancel_timer_ex(&pwdinfo->pre_tx_scan_timer);
 
 				DBG_8192C("enter GO Mode, p2p_ielen=%d\n", p2p_ielen);
 
@@ -3597,7 +3584,6 @@ static int	cfg80211_rtw_del_station(stru
 	DBG_871X("-"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	return ret;
-
 }
 
 static int	cfg80211_rtw_change_station(struct wiphy *wiphy, struct net_device *ndev,
@@ -3638,7 +3624,6 @@ static int	cfg80211_rtw_change_bss(struc
 	}
 */
 	return 0;
-
 }
 
 static int	cfg80211_rtw_set_channel(struct wiphy *wiphy
@@ -3769,7 +3754,6 @@ void rtw_cfg80211_rx_action(_adapter *ad
 #else
 	cfg80211_rx_action(adapter->pnetdev, freq, frame, frame_len, GFP_ATOMIC);
 #endif
-
 }
 
 #ifdef CONFIG_P2P
@@ -3809,7 +3793,7 @@ void rtw_cfg80211_issue_p2p_provision_re
 	size_t frame_body_len = len - sizeof(struct rtw_ieee80211_hdr_3addr);
 
 
-	DBG_871X( "[%s] In\n", __func__ );
+	DBG_871X("[%s] In\n", __func__);
 
 	//prepare for building provision_request frame
 	memcpy(pwdinfo->tx_prov_disc_info.peerIFAddr, GetAddr1Ptr(buf), ETH_ALEN);
@@ -3817,9 +3801,9 @@ void rtw_cfg80211_issue_p2p_provision_re
 
 	pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_PUSH_BUTTON;
 
-	rtw_get_wps_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, wpsie, &wpsielen);
-	rtw_get_wps_attr_content( wpsie, wpsielen, WPS_ATTR_DEVICE_PWID, (u8*) &wps_devicepassword_id, &wps_devicepassword_id_len);
-	wps_devicepassword_id = be16_to_cpu( wps_devicepassword_id );
+	rtw_get_wps_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, wpsie, &wpsielen);
+	rtw_get_wps_attr_content(wpsie, wpsielen, WPS_ATTR_DEVICE_PWID, (u8*) &wps_devicepassword_id, &wps_devicepassword_id_len);
+	wps_devicepassword_id = be16_to_cpu(wps_devicepassword_id);
 
 	switch (wps_devicepassword_id)
 	{
@@ -3844,11 +3828,11 @@ void rtw_cfg80211_issue_p2p_provision_re
 	}
 
 
-	if ( rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, p2p_ie, &p2p_ielen ) )
+	if (rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, p2p_ie, &p2p_ielen))
 	{
 
-		rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, devinfo_content, &devinfo_contentlen);
-		rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&capability, &capability_len);
+		rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, devinfo_content, &devinfo_contentlen);
+		rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&capability, &capability_len);
 
 	}
 
@@ -3906,14 +3890,14 @@ void rtw_cfg80211_issue_p2p_provision_re
 	//	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes
 	//	1. P2P Capability
 	//	2. Device Info
-	//	3. Group ID ( When joining an operating P2P Group )
+	//	3. Group ID (When joining an operating P2P Group)
 
 	//	P2P Capability ATTR
 	//	Type:
 	p2p_ie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
 	//	Length:
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x0002 );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	RTW_PUT_LE16(p2p_ie + p2pielen, 0x0002);
 	p2pielen += 2;
 
@@ -3931,7 +3915,7 @@ void rtw_cfg80211_issue_p2p_provision_re
 	//	Length:
 	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
-	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
+	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
 	RTW_PUT_LE16(p2p_ie + p2pielen, devinfo_contentlen);
 	p2pielen += 2;
 
@@ -3941,22 +3925,22 @@ void rtw_cfg80211_issue_p2p_provision_re
 
 
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2p_ie, &p2p_ielen);
-	//p2pielen = build_prov_disc_request_p2p_ie( pwdinfo, pframe, NULL, 0, pwdinfo->tx_prov_disc_info.peerDevAddr);
+	//p2pielen = build_prov_disc_request_p2p_ie(pwdinfo, pframe, NULL, 0, pwdinfo->tx_prov_disc_info.peerDevAddr);
 	//pframe += p2pielen;
 	pattrib->pktlen += p2p_ielen;
 
 	wpsielen = 0;
 	//	WPS OUI
-	*(u32*) ( wpsie ) = cpu_to_be32( WPSOUI );
+	*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 	wpsielen += 4;
 
 	//	WPS version
 	//	Type:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_VER1 );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 	wpsielen += 2;
 
 	//	Length:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0001 );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 	wpsielen += 2;
 
 	//	Value:
@@ -3964,18 +3948,18 @@ void rtw_cfg80211_issue_p2p_provision_re
 
 	//	Config Method
 	//	Type:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_ATTR_CONF_METHOD );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
 	wpsielen += 2;
 
 	//	Length:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0002 );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 	wpsielen += 2;
 
 	//	Value:
-	*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( pwdinfo->tx_prov_disc_info.wps_config_method_request );
+	*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->tx_prov_disc_info.wps_config_method_request);
 	wpsielen += 2;
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen );
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
 
 
 #ifdef CONFIG_WFD
@@ -3995,7 +3979,6 @@ void rtw_cfg80211_issue_p2p_provision_re
 	//	DBG_8192C("waiting for p2p peer key-in PIN CODE\n");
 	//	rtw_msleep_os(15000); // 15 sec for key in PIN CODE, workaround for GS2 before issuing Nego Req.
 	//}
-
 }
 
 static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
@@ -4087,7 +4070,7 @@ static s32 cfg80211_rtw_remain_on_channe
 
 	if (rtw_ch_set_search_ch(pmlmeext->channel_set, remain_ch) >= 0) {
 #ifdef	CONFIG_CONCURRENT_MODE
-		if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
+		if (check_buddy_fwstate(padapter, _FW_LINKED))
 		{
 			PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
 			struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -4112,7 +4095,7 @@ static s32 cfg80211_rtw_remain_on_channe
 			//set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 		}else
 #endif //CONFIG_CONCURRENT_MODE
-		if (remain_ch != pmlmeext->cur_channel )
+		if (remain_ch != pmlmeext->cur_channel)
 		{
 			ready_on_channel = true;
 			//pmlmeext->cur_channel = remain_ch;
@@ -4134,7 +4117,7 @@ static s32 cfg80211_rtw_remain_on_channe
 
 		if (ready_on_channel == true)
 		{
-			if ( !check_fwstate(&padapter->mlmepriv, _FW_LINKED ) )
+			if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
 				pmlmeext->cur_channel = remain_ch;
 
 #ifdef	CONFIG_CONCURRENT_MODE
@@ -4146,7 +4129,7 @@ static s32 cfg80211_rtw_remain_on_channe
 		}
 
 		DBG_8192C("%s, set ro ch timer, duration=%d\n", __func__, duration);
-		_set_timer( &pcfg80211_wdinfo->remain_on_ch_timer, duration);
+		_set_timer(&pcfg80211_wdinfo->remain_on_ch_timer, duration);
 
 #ifdef	CONFIG_CONCURRENT_MODE
 	}
@@ -4234,12 +4217,12 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 		//padapter->cfg80211_wdinfo.is_ro_ch = false;
 		#ifdef CONFIG_CONCURRENT_MODE
 		DBG_8192C("%s, extend ro ch time\n", __func__);
-		_set_timer( &padapter->cfg80211_wdinfo.remain_on_ch_timer, pwdinfo->ext_listen_period);
+		_set_timer(&padapter->cfg80211_wdinfo.remain_on_ch_timer, pwdinfo->ext_listen_period);
 		#endif //CONFIG_CONCURRENT_MODE
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(padapter, _FW_LINKED )) {
+	if (check_buddy_fwstate(padapter, _FW_LINKED)) {
 		u8 co_channel=0xff;
 		PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -4261,7 +4244,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 			_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_period);
 		}
 
-		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED ))
+		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
 			pmlmeext->cur_channel = tx_ch;
 
 		if (tx_ch != co_channel)
@@ -4270,7 +4253,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 #endif //CONFIG_CONCURRENT_MODE
 	//if (tx_ch != pmlmeext->cur_channel) {
 	if (tx_ch != rtw_get_oper_ch(padapter)) {
-		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED ))
+		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
 			pmlmeext->cur_channel = tx_ch;
 		set_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	}
@@ -4307,9 +4290,9 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 
 		pwfd_info = padapter->wdinfo.wfd_info;
 
-		if ( true == pwfd_info->wfd_enable )
+		if (true == pwfd_info->wfd_enable)
 		{
-			rtw_append_wfd_ie( padapter, pframe, &pattrib->pktlen );
+			rtw_append_wfd_ie(padapter, pframe, &pattrib->pktlen);
 		}
 	}
 #endif // CONFIG_WFD
@@ -4340,7 +4323,6 @@ exit:
 	#endif
 
 	return ret;
-
 }
 
 static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
@@ -4514,7 +4496,7 @@ static int rtw_cfg80211_set_beacon_wpsp2
 			}
 
 			pmlmepriv->wps_beacon_ie = rtw_malloc(wps_ielen);
-			if ( pmlmepriv->wps_beacon_ie == NULL) {
+			if (pmlmepriv->wps_beacon_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 				return -EINVAL;
 
@@ -4546,7 +4528,7 @@ static int rtw_cfg80211_set_beacon_wpsp2
 			}
 
 			pmlmepriv->p2p_beacon_ie = rtw_malloc(p2p_ielen);
-			if ( pmlmepriv->p2p_beacon_ie == NULL) {
+			if (pmlmepriv->p2p_beacon_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 				return -EINVAL;
 
@@ -4577,7 +4559,7 @@ static int rtw_cfg80211_set_beacon_wpsp2
 			}
 
 			pmlmepriv->wfd_beacon_ie = rtw_malloc(wfd_ielen);
-			if ( pmlmepriv->wfd_beacon_ie == NULL) {
+			if (pmlmepriv->wfd_beacon_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 				return -EINVAL;
 
@@ -4591,7 +4573,6 @@ static int rtw_cfg80211_set_beacon_wpsp2
 	}
 
 	return ret;
-
 }
 
 static int rtw_cfg80211_set_probe_resp_wpsp2pie(struct net_device *net, char *buf, int len)
@@ -4630,21 +4611,21 @@ static int rtw_cfg80211_set_probe_resp_w
 			}
 
 			pmlmepriv->wps_probe_resp_ie = rtw_malloc(wps_ielen);
-			if ( pmlmepriv->wps_probe_resp_ie == NULL) {
+			if (pmlmepriv->wps_probe_resp_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 				return -EINVAL;
 
 			}
 
 			//add PUSH_BUTTON config_method by driver self in wpsie of probe_resp at GO Mode
-			if ( (puconfig_method = (u16*)rtw_get_wps_attr_content( wps_ie, wps_ielen, WPS_ATTR_CONF_METHOD , NULL, &attr_contentlen)) != NULL )
+			if ((puconfig_method = (u16*)rtw_get_wps_attr_content(wps_ie, wps_ielen, WPS_ATTR_CONF_METHOD , NULL, &attr_contentlen)) != NULL)
 			{
 				#ifdef CONFIG_DEBUG_CFG80211
 				//printk("config_method in wpsie of probe_resp = 0x%x\n", be16_to_cpu(*puconfig_method));
 				#endif
 
 				uconfig_method = WPS_CM_PUSH_BUTTON;
-				uconfig_method = cpu_to_be16( uconfig_method );
+				uconfig_method = cpu_to_be16(uconfig_method);
 
 				*puconfig_method |= uconfig_method;
 			}
@@ -4669,10 +4650,10 @@ static int rtw_cfg80211_set_probe_resp_w
 			#endif
 
 			//Check P2P Capability ATTR
-			if ( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*) &attr_contentlen) )
+			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*) &attr_contentlen))
 			{
 				u8 grp_cap=0;
-				//DBG_8192C( "[%s] Got P2P Capability Attr!!\n", __func__ );
+				//DBG_8192C("[%s] Got P2P Capability Attr!!\n", __func__);
 				cap_attr = le16_to_cpu(cap_attr);
 				grp_cap = (u8)((cap_attr >> 8)&0xff);
 
@@ -4694,7 +4675,7 @@ static int rtw_cfg80211_set_probe_resp_w
 				}
 
 				pmlmepriv->p2p_probe_resp_ie = rtw_malloc(p2p_ielen);
-				if ( pmlmepriv->p2p_probe_resp_ie == NULL) {
+				if (pmlmepriv->p2p_probe_resp_ie == NULL) {
 					DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 					return -EINVAL;
 
@@ -4713,7 +4694,7 @@ static int rtw_cfg80211_set_probe_resp_w
 				}
 
 				pmlmepriv->p2p_go_probe_resp_ie = rtw_malloc(p2p_ielen);
-				if ( pmlmepriv->p2p_go_probe_resp_ie == NULL) {
+				if (pmlmepriv->p2p_go_probe_resp_ie == NULL) {
 					DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 					return -EINVAL;
 
@@ -4744,7 +4725,7 @@ static int rtw_cfg80211_set_probe_resp_w
 			}
 
 			pmlmepriv->wfd_probe_resp_ie = rtw_malloc(wfd_ielen);
-			if ( pmlmepriv->wfd_probe_resp_ie == NULL) {
+			if (pmlmepriv->wfd_probe_resp_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 				return -EINVAL;
 
@@ -4756,7 +4737,6 @@ static int rtw_cfg80211_set_probe_resp_w
 	}
 
 	return ret;
-
 }
 
 static int rtw_cfg80211_set_assoc_resp_wpsp2pie(struct net_device *net, char *buf, int len)
@@ -4778,7 +4758,7 @@ static int rtw_cfg80211_set_assoc_resp_w
 		}
 
 		pmlmepriv->wps_assoc_resp_ie = rtw_malloc(len);
-		if ( pmlmepriv->wps_assoc_resp_ie == NULL) {
+		if (pmlmepriv->wps_assoc_resp_ie == NULL) {
 			DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);
 			return -EINVAL;
 
@@ -4788,7 +4768,6 @@ static int rtw_cfg80211_set_assoc_resp_w
 	}
 
 	return ret;
-
 }
 
 int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len,
@@ -4826,7 +4805,6 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struc
 	}
 
 	return ret;
-
 }
 
 static struct cfg80211_ops rtw_cfg80211_ops = {
@@ -4941,7 +4919,6 @@ static void rtw_cfg80211_init_ht_capab(s
 	{
 		DBG_8192C("%s, error rf_type=%d\n", __func__, rf_type);
 	}
-
 }
 
 void rtw_cfg80211_init_wiphy(_adapter *padapter)
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -240,7 +240,7 @@ uint	rtw_is_cckrates_included(u8 *rate)
 
 		while (rate[i]!=0)
 		{
-			if  ( (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
+			if  ((((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
 			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22))
 			return true;
 			i++;
@@ -255,7 +255,7 @@ uint	rtw_is_cckratesonly_included(u8 *ra
 
 	while (rate[i]!=0)
 	{
-			if  ( (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+			if  ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
 				(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22))
 			return false;
 			i++;
@@ -647,7 +647,6 @@ static int wpa_set_auth_algs(struct net_
 	}
 
 	return ret;
-
 }
 
 static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
@@ -1219,7 +1218,6 @@ exit:
 	_func_exit_;
 
 	return ret;
-
 }
 
 static int rtw_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
@@ -1254,7 +1252,6 @@ static int rtw_wx_get_mode(struct net_de
 	_func_exit_;
 
 	return 0;
-
 }
 
 
@@ -1489,7 +1486,6 @@ static int rtw_wx_get_range(struct net_d
 	_func_exit_;
 
 	return 0;
-
 }
 
 //set bssid flow
@@ -1638,7 +1634,6 @@ static int rtw_wx_get_wap(struct net_dev
 	_func_exit_;
 
 	return 0;
-
 }
 
 static int rtw_wx_set_mlme(struct net_device *dev,
@@ -1679,7 +1674,6 @@ static int rtw_wx_set_mlme(struct net_de
 	}
 
 	return ret;
-
 }
 
 static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
@@ -2068,7 +2062,6 @@ exit:
 	#endif
 
 	return ret ;
-
 }
 
 //set ssid flow
@@ -2289,7 +2282,6 @@ exit:
 	_func_exit_;
 
 	return ret;
-
 }
 
 static int rtw_wx_set_rate(struct net_device *dev,
@@ -2421,7 +2413,6 @@ static int rtw_wx_set_rts(struct net_dev
 	_func_exit_;
 
 	return 0;
-
 }
 
 static int rtw_wx_get_rts(struct net_device *dev,
@@ -2466,7 +2457,6 @@ static int rtw_wx_set_frag(struct net_de
 	_func_exit_;
 
 	return 0;
-
 }
 
 static int rtw_wx_get_frag(struct net_device *dev,
@@ -2500,7 +2490,6 @@ static int rtw_wx_get_retry(struct net_d
 	wrqu->retry.disabled = 1;
 
 	return 0;
-
 }
 
 static int rtw_wx_set_enc(struct net_device *dev,
@@ -2637,7 +2626,6 @@ exit:
 	_func_exit_;
 
 	return ret;
-
 }
 
 static int rtw_wx_get_enc(struct net_device *dev,
@@ -2736,7 +2724,6 @@ static int rtw_wx_get_enc(struct net_dev
 	_func_exit_;
 
 	return ret;
-
 }
 
 static int rtw_wx_get_power(struct net_device *dev,
@@ -2750,7 +2737,6 @@ static int rtw_wx_get_power(struct net_d
 	wrqu->power.disabled = 1;
 
 	return 0;
-
 }
 
 static int rtw_wx_set_gen_ie(struct net_device *dev,
@@ -2876,7 +2862,6 @@ static int rtw_wx_set_auth(struct net_de
 	}
 
 	return ret;
-
 }
 
 static int rtw_wx_set_enc_ext(struct net_device *dev,
@@ -2961,7 +2946,6 @@ static int rtw_wx_set_enc_ext(struct net
 
 
 	return ret;
-
 }
 
 
@@ -3127,7 +3111,6 @@ static int dummy(struct net_device *dev,
 	//DBG_8192D("cmd_code=%x, fwstate=0x%x\n", a->cmd, get_fwstate(pmlmepriv));
 
 	return -1;
-
 }
 
 static int rtw_wx_set_channel_plan(struct net_device *dev,
@@ -3273,7 +3256,6 @@ _rtw_drvext_hdl_exit:
 #endif
 
 	return 0;
-
 }
 
 static void rtw_dbg_mode_hdl(struct rtw_adapter *padapter, u32 id, u8 *pdata, u32 len)
@@ -3373,7 +3355,6 @@ static void rtw_dbg_mode_hdl(struct rtw_
 		default:
 			break;
 	}
-
 }
 
 static int rtw_mp_ioctl_hdl(struct net_device *dev, struct iw_request_info *info,
@@ -3599,7 +3580,6 @@ static int rtw_get_ap_info(struct net_de
 exit:
 
 	return ret;
-
 }
 
 static int rtw_set_pid(struct net_device *dev,
@@ -3671,7 +3651,6 @@ static int rtw_wps_start(struct net_devi
 exit:
 
 	return ret;
-
 }
 
 #ifdef CONFIG_P2P
@@ -3756,7 +3735,6 @@ static int rtw_wext_p2p_enable(struct ne
 
 exit:
 	return ret;
-
 }
 
 static int rtw_p2p_set_go_nego_ssid(struct net_device *dev,
@@ -3775,7 +3753,6 @@ static int rtw_p2p_set_go_nego_ssid(stru
 	pwdinfo->nego_ssidlen = strlen(extra);
 
 	return ret;
-
 }
 
 
@@ -3814,7 +3791,6 @@ static int rtw_p2p_set_intent(struct net
 	DBG_8192D("[%s] intent = %d\n", __func__, intent);
 
 	return ret;
-
 }
 
 static int rtw_p2p_set_listen_ch(struct net_device *dev,
@@ -3854,7 +3830,6 @@ static int rtw_p2p_set_listen_ch(struct
 	DBG_8192D("[%s] listen_ch = %d\n", __func__, pwdinfo->listen_channel);
 
 	return ret;
-
 }
 
 static int rtw_p2p_set_op_ch(struct net_device *dev,
@@ -3895,7 +3870,6 @@ static int rtw_p2p_set_op_ch(struct net_
 	DBG_8192D("[%s] op_ch = %d\n", __func__, pwdinfo->operating_channel);
 
 	return ret;
-
 }
 
 
@@ -3955,7 +3929,6 @@ static int rtw_p2p_profilefound(struct n
 	}
 
 	return ret;
-
 }
 
 static int rtw_p2p_setDN(struct net_device *dev,
@@ -3968,13 +3941,12 @@ static int rtw_p2p_setDN(struct net_devi
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 
 
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
+	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	memset(pwdinfo->device_name, 0x00, WPS_MAX_DEVICE_NAME_LEN);
 	memcpy(pwdinfo->device_name, extra, wrqu->data.length - 1);
 	pwdinfo->device_name_len = wrqu->data.length - 1;
 	return ret;
-
 }
 
 
@@ -4003,7 +3975,6 @@ static int rtw_p2p_get_status(struct net
 	wrqu->data.length = strlen(extra);
 
 	return ret;
-
 }
 
 //	Commented by Albert 20110520
@@ -4024,7 +3995,6 @@ static int rtw_p2p_get_req_cm(struct net
 	sprintf(extra, "\n\nCM=%s\n", pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req);
 	wrqu->data.length = strlen(extra);
 	return ret;
-
 }
 
 
@@ -4046,7 +4016,6 @@ static int rtw_p2p_get_role(struct net_d
 	sprintf(extra, "\n\nRole=%.2d\n", rtw_p2p_role(pwdinfo));
 	wrqu->data.length = strlen(extra);
 	return ret;
-
 }
 
 
@@ -4070,7 +4039,6 @@ static int rtw_p2p_get_peer_ifaddr(struc
 			pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
 	wrqu->data.length = strlen(extra);
 	return ret;
-
 }
 
 static int rtw_p2p_get_peer_devaddr(struct net_device *dev,
@@ -4094,7 +4062,6 @@ static int rtw_p2p_get_peer_devaddr(stru
 			pwdinfo->rx_prov_disc_info.peerDevAddr[ 4 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 5 ]);
 	wrqu->data.length = strlen(extra);
 	return ret;
-
 }
 
 static int rtw_p2p_get_peer_devaddr_by_invitation(struct net_device *dev,
@@ -4118,7 +4085,6 @@ static int rtw_p2p_get_peer_devaddr_by_i
 			pwdinfo->p2p_peer_device_addr[ 4 ], pwdinfo->p2p_peer_device_addr[ 5 ]);
 	wrqu->data.length = strlen(extra);
 	return ret;
-
 }
 
 static int rtw_p2p_get_groupid(struct net_device *dev,
@@ -4139,7 +4105,6 @@ static int rtw_p2p_get_groupid(struct ne
 			pwdinfo->groupid_info.ssid);
 	wrqu->data.length = strlen(extra);
 	return ret;
-
 }
 
 static int rtw_p2p_get_op_ch(struct net_device *dev,
@@ -4159,7 +4124,6 @@ static int rtw_p2p_get_op_ch(struct net_
 	sprintf(extra, "\n\nOp_ch=%.2d\n", pwdinfo->operating_channel);
 	wrqu->data.length = strlen(extra);
 	return ret;
-
 }
 
 inline static void macstr2num(u8 *dst, u8 *src)
@@ -4243,7 +4207,6 @@ static int rtw_p2p_get_wps_configmethod(
 	memcpy(extra, attr_content_str, wrqu->data.length);
 
 	return ret;
-
 }
 
 #ifdef CONFIG_WFD
@@ -4264,7 +4227,6 @@ static int rtw_p2p_get_peer_wfd_port(str
 
 	wrqu->data.length = strlen(extra);
 	return ret;
-
 }
 
 static int rtw_p2p_get_peer_wfd_preferred_connection(struct net_device *dev,
@@ -4283,7 +4245,6 @@ static int rtw_p2p_get_peer_wfd_preferre
 	wrqu->data.length = strlen(extra);
 	pwdinfo->wfd_info->wfd_pc = false;	//	Reset the WFD preferred connection to P2P
 	return ret;
-
 }
 
 static int rtw_p2p_get_peer_wfd_session_available(struct net_device *dev,
@@ -4302,7 +4263,6 @@ static int rtw_p2p_get_peer_wfd_session_
 	wrqu->data.length = strlen(extra);
 	pwdinfo->wfd_info->peer_session_avail = true;	//	Reset the WFD session available
 	return ret;
-
 }
 
 #endif // CONFIG_WFD
@@ -4395,7 +4355,6 @@ static int rtw_p2p_get_go_device_address
 	memcpy(extra, go_devadd_str, wrqu->data.length);
 
 	return ret;
-
 }
 
 static int rtw_p2p_get_device_type(struct net_device *dev,
@@ -4472,7 +4431,6 @@ static int rtw_p2p_get_device_type(struc
 	memcpy(extra, dev_type_str, wrqu->data.length);
 
 	return ret;
-
 }
 
 static int rtw_p2p_get_device_name(struct net_device *dev,
@@ -4545,7 +4503,6 @@ static int rtw_p2p_get_device_name(struc
 	memcpy(extra, dev_name_str, wrqu->data.length);
 
 	return ret;
-
 }
 
 static int rtw_p2p_get_invitation_procedure(struct net_device *dev,
@@ -4633,7 +4590,6 @@ static int rtw_p2p_get_invitation_proced
 	memcpy(extra, inv_proc_str, wrqu->data.length);
 
 	return ret;
-
 }
 
 static int rtw_p2p_connect(struct net_device *dev,
@@ -4986,7 +4942,6 @@ static int rtw_p2p_invite_req(struct net
 exit:
 
 	return ret;
-
 }
 
 static int rtw_p2p_set_persistent(struct net_device *dev,
@@ -5051,7 +5006,6 @@ static int rtw_p2p_set_persistent(struct
 exit:
 
 	return ret;
-
 }
 
 #ifdef CONFIG_WFD
@@ -5187,7 +5141,6 @@ static int rtw_p2p_set_pc(struct net_dev
 exit:
 
 	return ret;
-
 }
 
 static int rtw_p2p_set_wfd_device_type(struct net_device *dev,
@@ -5220,7 +5173,6 @@ static int rtw_p2p_set_wfd_device_type(s
 exit:
 
 	return ret;
-
 }
 
 static int rtw_p2p_set_scan_result_type(struct net_device *dev,
@@ -5264,7 +5216,6 @@ static int rtw_p2p_set_scan_result_type(
 exit:
 
 	return ret;
-
 }
 
 //	To set the WFD session available to enable or disable
@@ -5306,7 +5257,6 @@ static int rtw_p2p_set_sa(struct net_dev
 exit:
 
 	return ret;
-
 }
 #endif //CONFIG_WFD
 
@@ -5552,7 +5502,6 @@ static int rtw_p2p_prov_disc(struct net_
 exit:
 
 	return ret;
-
 }
 
 //	Added by Albert 20110328
@@ -5598,7 +5547,6 @@ static int rtw_p2p_got_wpsinfo(struct ne
 	}
 
 	return ret;
-
 }
 
 #endif //CONFIG_P2P
@@ -5716,7 +5664,6 @@ static int rtw_p2p_set(struct net_device
 #endif //CONFIG_P2P
 
 	return ret;
-
 }
 
 static int rtw_p2p_get(struct net_device *dev,
@@ -5769,7 +5716,6 @@ static int rtw_p2p_get(struct net_device
 #endif //CONFIG_P2P
 
 	return ret;
-
 }
 
 static int rtw_p2p_get2(struct net_device *dev,
@@ -5825,7 +5771,6 @@ bad:
 #endif //CONFIG_P2P
 
 	return ret;
-
 }
 
 extern int rtw_change_ifname(struct rtw_adapter *padapter, const char *ifname);
@@ -5895,7 +5840,6 @@ static int rtw_rereg_nd_name(struct net_
 	}
 exit:
 	return ret;
-
 }
 
 void mac_reg_dump(struct rtw_adapter *padapter)
@@ -6523,7 +6467,6 @@ static int rtw_dbg_port(struct net_devic
 
 
 	return ret;
-
 }
 
 static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
@@ -6619,7 +6562,6 @@ static int wpa_set_param(struct net_devi
 	}
 
 	return ret;
-
 }
 
 static int wpa_mlme(struct net_device *dev, u32 command, u32 reason)
@@ -6649,7 +6591,6 @@ static int wpa_mlme(struct net_device *d
 	}
 
 	return ret;
-
 }
 
 static int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)
@@ -6714,7 +6655,6 @@ out:
 	//up(&ieee->wx_sem);
 
 	return ret;
-
 }
 
 #ifdef CONFIG_AP_MODE
@@ -6753,7 +6693,6 @@ static u8 set_pairwise_key(struct rtw_ad
 exit:
 
 	return res;
-
 }
 
 static int set_group_key(struct rtw_adapter *padapter, u8 *key, u8 alg, int keyid)
@@ -6819,7 +6758,6 @@ exit:
 
 	return res;
 
-
 }
 
 static int set_wep_key(struct rtw_adapter *padapter, u8 *key, u8 keylen, int keyid)
@@ -6839,7 +6777,6 @@ static int set_wep_key(struct rtw_adapte
 	}
 
 	return set_group_key(padapter, key, alg, keyid);
-
 }
 
 
@@ -7163,7 +7100,6 @@ exit:
 	kfree(pwep);
 
 	return ret;
-
 }
 
 static int rtw_set_beacon(struct net_device *dev, struct ieee_param *param, int len)
@@ -7193,7 +7129,6 @@ static int rtw_set_beacon(struct net_dev
 
 
 	return ret;
-
 }
 
 static int rtw_hostapd_sta_flush(struct net_device *dev)
@@ -7208,7 +7143,6 @@ static int rtw_hostapd_sta_flush(struct
 	ret = rtw_sta_flush(padapter);
 
 	return ret;
-
 }
 
 static int rtw_add_sta(struct net_device *dev, struct ieee_param *param)
@@ -7296,7 +7230,6 @@ static int rtw_add_sta(struct net_device
 	}
 
 	return ret;
-
 }
 
 static int rtw_del_sta(struct net_device *dev, struct ieee_param *param)
@@ -7347,7 +7280,6 @@ static int rtw_del_sta(struct net_device
 
 
 	return ret;
-
 }
 
 static int rtw_ioctl_get_sta_data(struct net_device *dev, struct ieee_param *param, int len)
@@ -7418,7 +7350,6 @@ static int rtw_ioctl_get_sta_data(struct
 	}
 
 	return ret;
-
 }
 
 static int rtw_get_sta_wpaie(struct net_device *dev, struct ieee_param *param)
@@ -7471,7 +7402,6 @@ static int rtw_get_sta_wpaie(struct net_
 	}
 
 	return ret;
-
 }
 
 static int rtw_set_wps_beacon(struct net_device *dev, struct ieee_param *param, int len)
@@ -7514,7 +7444,6 @@ static int rtw_set_wps_beacon(struct net
 
 
 	return ret;
-
 }
 
 static int rtw_set_wps_probe_resp(struct net_device *dev, struct ieee_param *param, int len)
@@ -7548,7 +7477,6 @@ static int rtw_set_wps_probe_resp(struct
 
 
 	return ret;
-
 }
 
 static int rtw_set_wps_assoc_resp(struct net_device *dev, struct ieee_param *param, int len)
@@ -7582,7 +7510,6 @@ static int rtw_set_wps_assoc_resp(struct
 
 
 	return ret;
-
 }
 
 static int rtw_set_hidden_ssid(struct net_device *dev, struct ieee_param *param, int len)
@@ -7658,7 +7585,6 @@ static int rtw_ioctl_acl_remove_sta(stru
 	ret = rtw_acl_remove_sta(padapter, param->sta_addr);
 
 	return ret;
-
 }
 
 static int rtw_ioctl_acl_add_sta(struct net_device *dev, struct ieee_param *param, int len)
@@ -7680,7 +7606,6 @@ static int rtw_ioctl_acl_add_sta(struct
 	ret = rtw_acl_add_sta(padapter, param->sta_addr);
 
 	return ret;
-
 }
 
 static int rtw_ioctl_set_macaddr_acl(struct net_device *dev, struct ieee_param *param, int len)
@@ -7840,7 +7765,6 @@ static int rtw_hostapd_ioctl(struct net_
 out:
 
 	return ret;
-
 }
 #endif
 
@@ -8026,7 +7950,6 @@ FREE_EXT:
 	//		dev->name, ret);
 
 	return ret;
-
 }
 
 static int rtw_mp_efuse_get(struct net_device *dev,
@@ -9322,7 +9245,6 @@ static int rtw_mp_phypara(struct net_dev
 	wrqu->length = strlen(extra) + 1;
 
 return 0;
-
 }
 
 
@@ -9518,7 +9440,7 @@ static int rtw_wfd_tdls_enable(struct ne
 
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
+	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	if (extra[ 0 ] == '0')
 	{
@@ -9546,7 +9468,7 @@ static int rtw_tdls_weaksec(struct net_d
 	u8 i, j;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
+	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	if (extra[ 0 ] == '0')
 	{
@@ -9579,7 +9501,7 @@ static int rtw_tdls_enable(struct net_de
 	u8 tdls_sta[NUM_STA][ETH_ALEN];
 	u8 empty_hwaddr[ETH_ALEN] = { 0x00 };
 
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
+	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	memset(tdls_sta, 0x00, sizeof(tdls_sta));
 
@@ -9644,7 +9566,7 @@ static int rtw_tdls_setup(struct net_dev
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 #endif // CONFIG_WFD
 
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
+	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
@@ -9687,7 +9609,7 @@ static int rtw_tdls_teardown(struct net_
 	struct sta_info *ptdls_sta = NULL;
 	u8 mac_addr[ETH_ALEN];
 
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
+	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
@@ -9718,7 +9640,7 @@ static int rtw_tdls_discovery(struct net
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
+	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	issue_tdls_dis_req(padapter, NULL);
 
@@ -9740,7 +9662,7 @@ static int rtw_tdls_ch_switch (struct ne
 	u8 i, j, mac_addr[ETH_ALEN];
 	struct sta_info *ptdls_sta = NULL;
 
-	DBG_8192S("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
+	DBG_8192S("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
@@ -9772,7 +9694,7 @@ static int rtw_tdls_pson(struct net_devi
 	u8 i, j, mac_addr[ETH_ALEN];
 	struct sta_info *ptdls_sta = NULL;
 
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
+	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
@@ -9801,7 +9723,7 @@ static int rtw_tdls_psoff(struct net_dev
 	u8 i, j, mac_addr[ETH_ALEN];
 	struct sta_info *ptdls_sta = NULL;
 
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
+	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
@@ -9830,7 +9752,7 @@ static int rtw_tdls_setip(struct net_dev
 	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
 	u8 i=0, j=0, k=0, tag=0, ip[3] = { 0xff }, *ptr = extra;
 
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length - 1 );
+	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length - 1);
 
 
 	while (i < 4)
@@ -9922,7 +9844,6 @@ static int rtw_tdls_getport(struct net_d
 #endif //CONFIG_TDLS
 
 	return ret;
-
 }
 
 //WFDTDLS, for sigma test
@@ -9954,7 +9875,6 @@ static int rtw_tdls_dis_result(struct ne
 #endif //CONFIG_TDLS
 
 	return ret;
-
 }
 
 //WFDTDLS, for sigma test
@@ -9989,7 +9909,6 @@ static int rtw_wfd_tdls_status(struct ne
 #endif //CONFIG_TDLS
 
 	return ret;
-
 }
 
 static int rtw_tdls_ch_switch_off(struct net_device *dev,
@@ -10004,7 +9923,7 @@ static int rtw_tdls_ch_switch_off(struct
 	u8 i, j, mac_addr[ETH_ALEN];
 	struct sta_info *ptdls_sta = NULL;
 
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1 );
+	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
--- a/drivers/staging/rtl8192du/os_dep/mlme_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/mlme_linux.c
@@ -104,7 +104,7 @@ void rtw_os_indicate_scan_done(struct rt
 }
 
 static struct RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
-void rtw_reset_securitypriv(struct rtw_adapter *adapter )
+void rtw_reset_securitypriv(struct rtw_adapter *adapter)
 {
 	u8	backupPMKIDIndex = 0;
 	u8	backupTKIPCountermeasure = 0x00;
@@ -118,9 +118,9 @@ void rtw_reset_securitypriv(struct rtw_a
 		// Backup the btkip_countermeasure information.
 		// When the countermeasure is trigger, the driver have to disconnect with AP for 60 seconds.
 
-		memset( &backupPMKIDList[ 0 ], 0x00, sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE );
+		memset(&backupPMKIDList[ 0 ], 0x00, sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
 
-		memcpy( &backupPMKIDList[ 0 ], &adapter->securitypriv.PMKIDList[ 0 ], sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE );
+		memcpy(&backupPMKIDList[ 0 ], &adapter->securitypriv.PMKIDList[ 0 ], sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
 		backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
 		backupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;
 		backupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;
@@ -130,7 +130,7 @@ void rtw_reset_securitypriv(struct rtw_a
 
 		// Added by Albert 2009/02/18
 		// Restore the PMK information to securitypriv structure for the following connection.
-		memcpy( &adapter->securitypriv.PMKIDList[ 0 ], &backupPMKIDList[ 0 ], sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE );
+		memcpy(&adapter->securitypriv.PMKIDList[ 0 ], &backupPMKIDList[ 0 ], sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
 		adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
 		adapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
 		adapter->securitypriv.btkip_countermeasure_time = backupTKIPcountermeasure_time;
@@ -158,7 +158,7 @@ void rtw_reset_securitypriv(struct rtw_a
 	}
 }
 
-void rtw_os_indicate_disconnect(struct rtw_adapter *adapter )
+void rtw_os_indicate_disconnect(struct rtw_adapter *adapter)
 {
    //struct RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
 
@@ -172,10 +172,9 @@ _func_enter_;
 
 	rtw_indicate_wx_disassoc_event(adapter);
 
-	 rtw_reset_securitypriv( adapter );
+	 rtw_reset_securitypriv(adapter);
 
 _func_exit_;
-
 }
 
 void rtw_report_sec_ie(struct rtw_adapter *adapter,u8 authmode,u8 *sec_ie)
@@ -223,7 +222,6 @@ _func_enter_;
 	}
 
 _func_exit_;
-
 }
 
 static void _survey_timer_hdl (void *FunctionContext)
@@ -301,7 +299,6 @@ void rtw_indicate_sta_assoc_event(struct
 	DBG_8192D("+rtw_indicate_sta_assoc_event\n");
 
 	wireless_send_event(padapter->pnetdev, IWEVREGISTERED, &wrqu, NULL);
-
 }
 
 void rtw_indicate_sta_disassoc_event(struct rtw_adapter *padapter, struct sta_info *psta)
@@ -326,7 +323,6 @@ void rtw_indicate_sta_disassoc_event(str
 	DBG_8192D("+rtw_indicate_sta_disassoc_event\n");
 
 	wireless_send_event(padapter->pnetdev, IWEVEXPIRED, &wrqu, NULL);
-
 }
 
 
@@ -480,7 +476,6 @@ int hostapd_mode_init(struct rtw_adapter
 	}
 
 	return 0;
-
 }
 
 void hostapd_mode_unload(struct rtw_adapter *padapter)
@@ -490,7 +485,6 @@ void hostapd_mode_unload(struct rtw_adap
 
 	unregister_netdev(pnetdev);
 	rtw_free_netdev(pnetdev);
-
 }
 
 #endif
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -467,7 +467,7 @@ void rtw_proc_init_one(struct net_device
 	}
 
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-	if ((RF_1T2R == rf_type) ||(RF_1T1R == rf_type ))	{
+	if ((RF_1T2R == rf_type) ||(RF_1T1R == rf_type))	{
 		entry = create_proc_read_entry("rf_reg_dump3", S_IFREG | S_IRUGO,
 					   dir_dev, proc_get_rf_reg_dump3, dev);
 		if (!entry) {
@@ -601,7 +601,7 @@ void rtw_proc_remove_one(struct net_devi
 		remove_proc_entry("rf_reg_dump1", dir_dev);
 		remove_proc_entry("rf_reg_dump2", dir_dev);
 		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-		if ((RF_1T2R == rf_type) ||(RF_1T1R == rf_type ))	{
+		if ((RF_1T2R == rf_type) ||(RF_1T1R == rf_type))	{
 			remove_proc_entry("rf_reg_dump3", dir_dev);
 			remove_proc_entry("rf_reg_dump4", dir_dev);
 		}
@@ -886,7 +886,6 @@ u16 rtw_recv_select_queue(struct sk_buff
 	}
 
 	return rtw_1d_to_queue[priority];
-
 }
 
 #endif
@@ -1002,7 +1001,6 @@ struct net_device *rtw_init_netdev(struc
 	loadparam(padapter, pnetdev);
 
 	return pnetdev;
-
 }
 
 u32 rtw_start_drv_threads(struct rtw_adapter *padapter)
@@ -1042,7 +1040,6 @@ u32 rtw_start_drv_threads(struct rtw_ada
 #endif
 
 	return _status;
-
 }
 
 void rtw_stop_drv_threads (struct rtw_adapter *padapter)
@@ -1081,7 +1078,6 @@ void rtw_stop_drv_threads (struct rtw_ad
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("\n drv_halt:recv_thread can be terminated!\n"));
 #endif
 
-
 }
 
 u8 rtw_init_default_value(struct rtw_adapter *padapter);
@@ -1326,7 +1322,6 @@ exit:
 	_func_exit_;
 
 	return ret8;
-
 }
 
 void rtw_cancel_all_timer(struct rtw_adapter *padapter)
@@ -1366,7 +1361,6 @@ void rtw_cancel_all_timer(struct rtw_ada
 
 	/*  cancel dm  timer */
 	rtw_hal_dm_deinit(padapter);
-
 }
 
 u8 rtw_free_drv_sw(struct rtw_adapter *padapter)
@@ -1382,11 +1376,11 @@ u8 rtw_free_drv_sw(struct rtw_adapter *p
 		struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
-			_cancel_timer_ex( &pwdinfo->find_phase_timer );
-			_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
-			_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
+			_cancel_timer_ex(&pwdinfo->find_phase_timer);
+			_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
+			_cancel_timer_ex(&pwdinfo->pre_tx_scan_timer);
 #ifdef CONFIG_CONCURRENT_MODE
-			_cancel_timer_ex( &pwdinfo->ap_p2p_switch_timer );
+			_cancel_timer_ex(&pwdinfo->ap_p2p_switch_timer);
 #endif /*  CONFIG_CONCURRENT_MODE */
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
 		}
@@ -1441,7 +1435,6 @@ u8 rtw_free_drv_sw(struct rtw_adapter *p
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-rtw_free_drv_sw\n"));
 
 	return _SUCCESS;
-
 }
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -1517,7 +1510,6 @@ _netdev_virtual_iface_open_error:
 	rtw_netif_stop_queue(pnetdev);
 
 	return (-1);
-
 }
 
 int netdev_vir_if_open(struct net_device *pnetdev)
@@ -1720,7 +1712,6 @@ error_rtw_drv_add_iface:
 		rtw_free_netdev(pnetdev);
 
 	return NULL;
-
 }
 
 void rtw_drv_stop_vir_if (struct rtw_adapter *padapter)
@@ -1762,7 +1753,6 @@ void rtw_drv_stop_vir_if (struct rtw_ada
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_wdev_unregister(padapter->rtw_wdev);
 #endif /* CONFIG_IOCTL_CFG80211 */
-
 }
 
 void rtw_drv_free_vir_if (struct rtw_adapter *padapter)
@@ -1901,7 +1891,6 @@ netdev_if2_open_error:
 	rtw_netif_stop_queue(pnetdev);
 
 	return (-1);
-
 }
 
 static int netdev_if2_open(struct net_device *pnetdev)
@@ -2100,7 +2089,6 @@ error_rtw_drv_if2_init:
 		rtw_free_netdev(pnetdev);
 
 	return NULL;
-
 }
 
 void rtw_drv_if2_free(struct rtw_adapter *if2)
@@ -2121,7 +2109,6 @@ void rtw_drv_if2_free(struct rtw_adapter
 	rtw_free_drv_sw(padapter);
 
 	rtw_free_netdev(pnetdev);
-
 }
 
 void rtw_drv_if2_stop(struct rtw_adapter *if2)
@@ -2161,7 +2148,6 @@ void rtw_drv_if2_stop(struct rtw_adapter
 	#ifdef CONFIG_IOCTL_CFG80211
 	rtw_wdev_unregister(padapter->rtw_wdev);
 	#endif
-
 }
 #endif /* end of CONFIG_CONCURRENT_MODE */
 
@@ -2317,7 +2303,6 @@ netdev_open_error:
 	DBG_8192D("-871x_drv - drv_open fail, bup =%d\n", padapter->bup);
 
 	return (-1);
-
 }
 
 int netdev_open(struct net_device *pnetdev)
@@ -2381,7 +2366,6 @@ int rtw_ips_pwr_up(struct rtw_adapter *p
 
 	DBG_8192D("<===  rtw_ips_pwr_up.............. in %dms\n", rtw_get_passing_time_ms(start_time));
 	return result;
-
 }
 
 void rtw_ips_pwr_down(struct rtw_adapter *padapter)
--- a/drivers/staging/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8192du/os_dep/osdep_service.c
@@ -64,7 +64,6 @@ u32 rtw_atoi(u8* s)
 	   num = num * -1;
 
 	 return(num);
-
 }
 
 inline u8* _rtw_vmalloc(u32 sz)
@@ -218,7 +217,6 @@ void	_rtw_init_queue(struct __queue *pqu
 	INIT_LIST_HEAD(&(pqueue->queue));
 
 	_rtw_spinlock_init(&(pqueue->lock));
-
 }
 
 u32	  _rtw_queue_empty(struct __queue *pqueue)
@@ -285,10 +283,10 @@ void rtw_msleep_os(int ms)
 void rtw_usleep_os(int us)
 {
       // msleep((unsigned int)us);
-      if ( 1 < (us/1000) )
+      if (1 < (us/1000))
                 msleep(1);
       else
-		msleep( (us/1000) + 1);
+		msleep((us/1000) + 1);
 }
 
 #ifdef DBG_DELAY_OS
@@ -469,7 +467,6 @@ static int readFile(struct file *fp,char
 	}
 
 	return  sum;
-
 }
 
 static int writeFile(struct file *fp,char *buf,int len)
@@ -490,7 +487,6 @@ static int writeFile(struct file *fp,cha
 	}
 
 	return sum;
-
 }
 
 /*
@@ -535,7 +531,7 @@ static int retriveFromFile(char *path, u
 	struct file *fp;
 
 	if (path && buf) {
-		if ( 0 == (ret=openFile(&fp,path, O_RDONLY, 0)) ){
+		if (0 == (ret=openFile(&fp,path, O_RDONLY, 0))){
 			DBG_8192D("%s openFile path:%s fp=%p\n",__func__, path ,fp);
 
 			oldfs = get_fs(); set_fs(get_ds());
@@ -569,7 +565,7 @@ static int storeToFile(char *path, u8* b
 	struct file *fp;
 
 	if (path && buf) {
-		if ( 0 == (ret=openFile(&fp, path, O_CREAT|O_WRONLY, 0666)) ) {
+		if (0 == (ret=openFile(&fp, path, O_CREAT|O_WRONLY, 0666))) {
 			DBG_8192D("%s openFile path:%s fp=%p\n",__func__, path ,fp);
 
 			oldfs = get_fs(); set_fs(get_ds());
@@ -747,7 +743,7 @@ int rtw_change_ifname(struct rtw_adapter
 #endif
 		ret = register_netdevice(pnetdev);
 
-	if ( ret != 0) {
+	if (ret != 0) {
 		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("register_netdev() failed\n"));
 		goto error;
 	}
@@ -759,7 +755,6 @@ int rtw_change_ifname(struct rtw_adapter
 error:
 
 	return -1;
-
 }
 
 u64 rtw_modular64(u64 x, u64 y)
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -47,13 +47,11 @@ int rtw_os_recv_resource_alloc(struct rt
 	precvframe->u.hdr.pkt_newalloc = precvframe->u.hdr.pkt = NULL;
 
 	return res;
-
 }
 
 //free os related resource in union recv_frame
 void rtw_os_recv_resource_free(struct recv_priv *precvpriv)
 {
-
 }
 
 
@@ -119,7 +117,6 @@ int rtw_os_recvbuf_resource_free(struct
 
 
 	return ret;
-
 }
 
 void rtw_handle_tkip_mic_err(struct rtw_adapter *padapter,u8 bgroup)
@@ -133,7 +130,7 @@ void rtw_handle_tkip_mic_err(struct rtw_
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 	u32 cur_time = 0;
 
-	if ( psecuritypriv->last_mic_err_time == 0 )
+	if (psecuritypriv->last_mic_err_time == 0)
 	{
 		psecuritypriv->last_mic_err_time = rtw_get_current_time();
 	}
@@ -141,7 +138,7 @@ void rtw_handle_tkip_mic_err(struct rtw_
 	{
 		cur_time = rtw_get_current_time();
 
-		if ( cur_time - psecuritypriv->last_mic_err_time < 60*HZ )
+		if (cur_time - psecuritypriv->last_mic_err_time < 60*HZ)
 		{
 			psecuritypriv->btkip_countermeasure = true;
 			psecuritypriv->last_mic_err_time = 0;
@@ -154,7 +151,7 @@ void rtw_handle_tkip_mic_err(struct rtw_
 	}
 
 #ifdef CONFIG_IOCTL_CFG80211
-	if ( bgroup )
+	if (bgroup)
 	{
 		key_type |= NL80211_KEYTYPE_GROUP;
 	}
@@ -167,8 +164,8 @@ void rtw_handle_tkip_mic_err(struct rtw_
 		NULL, GFP_ATOMIC);
 #endif
 
-	memset( &ev, 0x00, sizeof( ev ) );
-	if ( bgroup )
+	memset(&ev, 0x00, sizeof(ev));
+	if (bgroup)
 	{
 	    ev.flags |= IW_MICFAILURE_GROUP;
 	}
@@ -178,12 +175,12 @@ void rtw_handle_tkip_mic_err(struct rtw_
 	}
 
 	ev.src_addr.sa_family = ARPHRD_ETHER;
-	memcpy( ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+	memcpy(ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
 
-	memset( &wrqu, 0x00, sizeof( wrqu ) );
-	wrqu.data.length = sizeof( ev );
+	memset(&wrqu, 0x00, sizeof(wrqu));
+	wrqu.data.length = sizeof(ev);
 
-	wireless_send_event( padapter->pnetdev, IWEVMICHAELMICFAILURE, &wrqu, (char*) &ev );
+	wireless_send_event(padapter->pnetdev, IWEVMICHAELMICFAILURE, &wrqu, (char*) &ev);
 }
 
 void rtw_hostapd_mlme_rx(struct rtw_adapter *padapter, union recv_frame *precv_frame)
@@ -333,7 +330,7 @@ _func_enter_;
 	rcu_read_unlock();
 #endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 
-	if ( br_port	&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) )
+	if (br_port	&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true))
 	{
 		int nat25_handle_frame(struct rtw_adapter *priv, struct sk_buff *skb);
 		if (nat25_handle_frame(padapter, skb) == -1) {
@@ -352,7 +349,7 @@ _func_enter_;
 
 
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
-	if ( (pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1) ) {
+	if ((pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1)) {
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
 		//DBG_871X("CHECKSUM_UNNECESSARY\n");
 	} else {
@@ -391,7 +388,6 @@ _recv_indicatepkt_drop:
 	 return _FAIL;
 
 _func_exit_;
-
 }
 
 void rtw_os_read_port(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
@@ -421,5 +417,4 @@ void rtw_init_recv_timer(struct recv_reo
 	struct rtw_adapter *padapter = preorder_ctrl->padapter;
 
 	_init_timer(&(preorder_ctrl->reordering_ctrl_timer), padapter->pnetdev, _rtw_reordering_ctrl_timeout_handler, preorder_ctrl);
-
 }
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -228,7 +228,7 @@ int rtw_android_cmdstr_to_num(char *cmds
 {
 	int cmd_num;
 	for (cmd_num=0 ; cmd_num<ANDROID_WIFI_CMD_MAX; cmd_num++)
-		if (0 == strnicmp(cmdstr , android_wifi_cmd_str[cmd_num], strlen(android_wifi_cmd_str[cmd_num])) )
+		if (0 == strnicmp(cmdstr , android_wifi_cmd_str[cmd_num], strlen(android_wifi_cmd_str[cmd_num])))
 			break;
 
 	return cmd_num;
@@ -308,20 +308,20 @@ static int rtw_android_set_block(struct
 	return 0;
 }
 
-static int get_int_from_command( char* pcmd )
+static int get_int_from_command(char* pcmd)
 {
 	int i = 0;
 
-	for ( i = 0; i < strlen( pcmd ); i++ )
+	for (i = 0; i < strlen(pcmd); i++)
 	{
-		if ( pcmd[ i ] == '=' )
+		if (pcmd[ i ] == '=')
 		{
 			//	Skip the '=' and space characters.
 			i += 2;
 			break;
 		}
 	}
-	return ( rtw_atoi( pcmd + i ) );
+	return (rtw_atoi(pcmd + i));
 }
 
 int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
@@ -419,7 +419,7 @@ int rtw_android_priv_cmd(struct net_devi
 	case ANDROID_WIFI_CMD_SETBAND:
 	{
 		uint band = *(command + strlen("SETBAND") + 1) - '0';
-		struct rtw_adapter*	padapter = (struct rtw_adapter * ) rtw_netdev_priv(net);
+		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
 
 		if (padapter->chip_type == RTL8192D)
 			padapter->setband = band;
@@ -465,7 +465,7 @@ int rtw_android_priv_cmd(struct net_devi
 		//	wpa_cli driver wfd-enable
 
 		struct wifi_display_info		*pwfd_info;
-		struct rtw_adapter*	padapter = (struct rtw_adapter * ) rtw_netdev_priv(net);
+		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
 
 		pwfd_info = &padapter->wfd_info;
 		pwfd_info->wfd_enable = true;
@@ -478,7 +478,7 @@ int rtw_android_priv_cmd(struct net_devi
 		//	wpa_cli driver wfd-disable
 
 		struct wifi_display_info		*pwfd_info;
-		struct rtw_adapter*	padapter = (struct rtw_adapter * ) rtw_netdev_priv(net);
+		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
 
 		pwfd_info = &padapter->wfd_info;
 		pwfd_info->wfd_enable = false;
@@ -491,10 +491,10 @@ int rtw_android_priv_cmd(struct net_devi
 		//	wpa_cli driver wfd-set-tcpport = 554
 
 		struct wifi_display_info		*pwfd_info;
-		struct rtw_adapter*	padapter = (struct rtw_adapter * ) rtw_netdev_priv(net);
+		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
 
 		pwfd_info = &padapter->wfd_info;
-		pwfd_info->rtsp_ctrlport = ( u16 ) get_int_from_command( priv_cmd.buf );
+		pwfd_info->rtsp_ctrlport = (u16) get_int_from_command(priv_cmd.buf);
 		break;
 	}
 	case ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT:
@@ -502,13 +502,13 @@ int rtw_android_priv_cmd(struct net_devi
 	case ANDROID_WIFI_CMD_WFD_SET_DEVTYPE:
 	{
 		//	Commented by Albert 2012/08/28
-		//	Specify the WFD device type ( WFD source/primary sink )
+		//	Specify the WFD device type (WFD source/primary sink)
 
 		struct wifi_display_info		*pwfd_info;
-		struct rtw_adapter*	padapter = (struct rtw_adapter * ) rtw_netdev_priv(net);
+		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
 
 		pwfd_info = &padapter->wfd_info;
-		pwfd_info->wfd_device_type = ( u8 ) get_int_from_command( priv_cmd.buf );
+		pwfd_info->wfd_device_type = (u8) get_int_from_command(priv_cmd.buf);
 
 		pwfd_info->wfd_device_type &= WFD_DEVINFO_DUAL;
 		break;
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -139,7 +139,7 @@ static void rtw_dev_remove(struct usb_in
 	{USB_DEVICE(0x0DF6, 0x0070)}, /* Sitecom - Edimax */ \
 	{USB_DEVICE(0x0789, 0x016D)}, /* LOGITEC - Edimax */ \
 	/****** 8192CE-VAU  ********/ \
-	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8186)},/* Intel-Xavi( Azwave) */
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8186)},/* Intel-Xavi(Azwave) */
 
 #define RTL8192D_USB_IDS \
 	/*=== Realtek demoboard ===*/ \
@@ -271,12 +271,11 @@ static u8 rtw_init_intf_priv(struct dvob
 		goto exit;
 	}
 	dvobj->usb_vendor_req_buf  =
-		(u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(dvobj->usb_alloc_vendor_req_buf ), ALIGNMENT_UNIT);
+		(u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(dvobj->usb_alloc_vendor_req_buf), ALIGNMENT_UNIT);
 exit:
 	#endif
 
 	return rst;
-
 }
 
 static u8 rtw_deinit_intf_priv(struct dvobj_priv *dvobj)
@@ -534,7 +533,6 @@ static void usb_intf_stop(struct rtw_ada
 	//todo:cancel other irps
 
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-usb_intf_stop\n"));
-
 }
 
 static void rtw_dev_unload(struct rtw_adapter *padapter)
@@ -560,7 +558,7 @@ static void rtw_dev_unload(struct rtw_ad
 		}
 
 		//s4.
-		if (!padapter->pwrctrlpriv.bInternalAutoSuspend )
+		if (!padapter->pwrctrlpriv.bInternalAutoSuspend)
 		rtw_stop_drv_threads(padapter);
 
 
@@ -587,13 +585,12 @@ static void rtw_dev_unload(struct rtw_ad
 	}
 	else
 	{
-		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("r871x_dev_unload():padapter->bup == false\n" ));
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("r871x_dev_unload():padapter->bup == false\n"));
 	}
 
 	DBG_8192D("<=== rtw_dev_unload\n");
 
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-rtw_dev_unload\n"));
-
 }
 
 static void process_spec_devid(const struct usb_device_id *pdid)
@@ -622,7 +619,7 @@ static void process_spec_devid(const str
 }
 
 #ifdef SUPPORT_HW_RFOFF_DETECTED
-int rtw_hw_suspend(struct rtw_adapter *padapter )
+int rtw_hw_suspend(struct rtw_adapter *padapter)
 {
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct usb_interface *pusb_intf = adapter_to_dvobj(padapter)->pusbintf;
@@ -697,7 +694,6 @@ int rtw_hw_suspend(struct rtw_adapter *p
 error_exit:
 	DBG_8192D("%s, failed\n",__func__);
 	return (-1);
-
 }
 
 int rtw_hw_resume(struct rtw_adapter *padapter)
@@ -775,12 +771,12 @@ static int rtw_suspend(struct usb_interf
 		goto exit;
 	}
 
-	if (pwrpriv->bInternalAutoSuspend )
+	if (pwrpriv->bInternalAutoSuspend)
 	{
 	#ifdef CONFIG_AUTOSUSPEND
 	#ifdef SUPPORT_HW_RFOFF_DETECTED
 		// The FW command register update must after MAC and FW init ready.
-		if ((padapter->bFWReady) && ( padapter->pwrctrlpriv.bHWPwrPindetect ) && (padapter->registrypriv.usbss_enable ))
+		if ((padapter->bFWReady) && (padapter->pwrctrlpriv.bHWPwrPindetect) && (padapter->registrypriv.usbss_enable))
 		{
 			u8 bOpen = true;
 			rtw_interface_ps_func(padapter,HAL_USB_SELECT_SUSPEND,&bOpen);
@@ -818,7 +814,7 @@ static int rtw_suspend(struct usb_interf
 	}
 
 #ifdef CONFIG_LAYER2_ROAMING_RESUME
-	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) && check_fwstate(pmlmepriv, _FW_LINKED) )
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) && check_fwstate(pmlmepriv, _FW_LINKED))
 	{
 		//DBG_8192D("%s:%d assoc_ssid:%s\n", __func__, __LINE__, pmlmepriv->assoc_ssid.Ssid);
 		DBG_8192D("%s:%d %s(%pM), length:%d assoc_ssid.length:%d\n",__func__, __LINE__,
@@ -834,7 +830,7 @@ static int rtw_suspend(struct usb_interf
 	//s2-3.
 	rtw_free_assoc_resources(padapter, 1);
 #ifdef CONFIG_AUTOSUSPEND
-	if (!pwrpriv->bInternalAutoSuspend )
+	if (!pwrpriv->bInternalAutoSuspend)
 #endif
 	//s2-4.
 	rtw_free_network_queue(padapter, true);
@@ -868,7 +864,7 @@ static int rtw_resume(struct usb_interfa
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	 int ret = 0;
 
-	if (pwrpriv->bInternalAutoSuspend ){
+	if (pwrpriv->bInternalAutoSuspend){
 		ret = rtw_resume_process(padapter);
 	} else {
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
@@ -888,7 +884,6 @@ static int rtw_resume(struct usb_interfa
 	}
 
 	return ret;
-
 }
 
 int rtw_resume_process(struct rtw_adapter *padapter)
@@ -920,12 +915,12 @@ int rtw_resume_process(struct rtw_adapte
 	netif_carrier_on(pnetdev);
 
 #ifdef CONFIG_AUTOSUSPEND
-	if (pwrpriv->bInternalAutoSuspend )
+	if (pwrpriv->bInternalAutoSuspend)
 	{
 		#ifdef CONFIG_AUTOSUSPEND
 		#ifdef SUPPORT_HW_RFOFF_DETECTED
 			// The FW command register update must after MAC and FW init ready.
-		if ((padapter->bFWReady) && ( padapter->pwrctrlpriv.bHWPwrPindetect ) && (padapter->registrypriv.usbss_enable ))
+		if ((padapter->bFWReady) && (padapter->pwrctrlpriv.bHWPwrPindetect) && (padapter->registrypriv.usbss_enable))
 		{
 			//rtl8192c_set_FwSelectSuspend_cmd(padapter,false ,500);//note fw to support hw power down ping detect
 			u8 bOpen = false;
@@ -958,7 +953,7 @@ int rtw_resume_process(struct rtw_adapte
 #endif
 	_exit_pwrlock(&pwrpriv->lock);
 
-	if ( padapter->pid[1]!=0) {
+	if (padapter->pid[1]!=0) {
 		DBG_8192D("pid[1]:%d\n",padapter->pid[1]);
 		rtw_signal_process(padapter->pid[1], SIGUSR2);
 	}
@@ -993,7 +988,7 @@ void autosuspend_enter(struct rtw_adapte
 
 	DBG_8192D("==>autosuspend_enter...........\n");
 
-	if (rf_off == pwrpriv->change_rfpwrstate )
+	if (rf_off == pwrpriv->change_rfpwrstate)
 	{
 		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 		usb_enable_autosuspend(dvobj->pusbdev);
@@ -1014,8 +1009,8 @@ void autosuspend_enter(struct rtw_adapte
 	#else
 	DBG_8192D("...pm_usage_cnt(%d).....\n", dvobj->pusbintf->pm_usage_cnt);
 	#endif
-
 }
+
 int autoresume_enter(struct rtw_adapter* padapter)
 {
 	int result = _SUCCESS;
@@ -1028,13 +1023,13 @@ int autoresume_enter(struct rtw_adapter*
 
 	DBG_8192D("====> autoresume_enter\n");
 
-	if (rf_off == pwrpriv->rf_pwrstate )
+	if (rf_off == pwrpriv->rf_pwrstate)
 	{
 		pwrpriv->ps_flag = false;
 		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,33))
 			if (usb_autopm_get_interface(dvobj->pusbintf) < 0)
 			{
-				DBG_8192D( "can't get autopm: %d\n", result);
+				DBG_8192D("can't get autopm: %d\n", result);
 				result = _FAIL;
 				goto error_exit;
 			}
@@ -1152,9 +1147,9 @@ struct rtw_adapter *rtw_usb_if1_init(str
 #endif
 
 #ifdef CONFIG_AUTOSUSPEND
-	if ( padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE )
+	if (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
 	{
-		if (padapter->registrypriv.usbss_enable ){	/* autosuspend (2s delay) */
+		if (padapter->registrypriv.usbss_enable){	/* autosuspend (2s delay) */
 			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,38))
 			dvobj->pusbdev->dev.power.autosuspend_delay = 0 * HZ;//15 * HZ; idle-delay time
 			#else
@@ -1168,7 +1163,7 @@ struct rtw_adapter *rtw_usb_if1_init(str
 			dvobj->pusbdev->autosuspend_disabled = 0;//autosuspend disabled by the user
 			#endif
 
-			usb_autopm_get_interface(dvobj->pusbintf );//init pm_usage_cnt ,let it start from 1
+			usb_autopm_get_interface(dvobj->pusbintf);//init pm_usage_cnt ,let it start from 1
 
 			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,32))
 			DBG_8192D("%s...pm_usage_cnt(%d).....\n",__func__, atomic_read(&(dvobj->pusbintf ->pm_usage_cnt)));
--- a/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
@@ -257,17 +257,14 @@ static u32 usb_bulkout_zero(struct intf_
 
 
 	return _SUCCESS;
-
 }
 
 void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 {
-
 }
 
 void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 {
-
 }
 
 
@@ -445,7 +442,6 @@ check_completion:
 	}
 
 _func_exit_;
-
 }
 
 u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
@@ -470,9 +466,9 @@ _func_enter_;
 	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx)) {
 		#ifdef DBG_TX
 		DBG_8192D(" DBG_TX %s:%d bDriverStopped%d, bSurpriseRemoved:%d, pnp_bstop_trx:%d\n",__func__, __LINE__
-			,padapter->bDriverStopped, padapter->bSurpriseRemoved, padapter->pwrctrlpriv.pnp_bstop_trx );
+			,padapter->bDriverStopped, padapter->bSurpriseRemoved, padapter->pwrctrlpriv.pnp_bstop_trx);
 		#endif
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port:(padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
 		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_TX_DENY);
 		goto exit;
 	}
@@ -532,8 +528,8 @@ _func_enter_;
 	pipe = ffaddr2pipehdl(pdvobj, addr);
 
 #ifdef CONFIG_REDUCE_USB_TX_INT
-	if ( (pxmitpriv->free_xmitbuf_cnt%NR_XMITBUFF == 0)
-		|| (pxmitbuf->ext_tag == true) )
+	if ((pxmitpriv->free_xmitbuf_cnt%NR_XMITBUFF == 0)
+		|| (pxmitbuf->ext_tag == true))
 	{
 		purb->transfer_flags  &=  (~URB_NO_INTERRUPT);
 	} else {
@@ -603,7 +599,6 @@ exit:
 		rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
 _func_exit_;
 	return ret;
-
 }
 
 void usb_write_port_cancel(struct intf_hdl *pintfhdl)
--- a/drivers/staging/rtl8192du/os_dep/xmit_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/xmit_linux.c
@@ -121,7 +121,6 @@ void rtw_set_tx_chksum_offload(struct sk
 		}
 	}
 #endif
-
 }
 
 int rtw_os_xmit_resource_alloc(struct rtw_adapter *padapter, struct xmit_buf *pxmitbuf,u32 alloc_sz)
@@ -324,21 +323,21 @@ _func_enter_;
 	}
 #endif
 
-	if ( !rtw_mc2u_disable
+	if (!rtw_mc2u_disable
 		&& check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
-		&& ( IP_MCAST_MAC(pkt->data)
-			|| ICMPV6_MCAST_MAC(pkt->data) )
+		&& (IP_MCAST_MAC(pkt->data)
+			|| ICMPV6_MCAST_MAC(pkt->data))
 		&& (padapter->registrypriv.wifi_spec == 0)
 		)
 	{
-		if ( pxmitpriv->free_xmitframe_cnt > (NR_XMITFRAME/4) ) {
+		if (pxmitpriv->free_xmitframe_cnt > (NR_XMITFRAME/4)) {
 			res = rtw_mlcst2unicst(padapter, pkt);
 			if (res == true) {
 				goto exit;
 			}
 		} else {
 			//DBG_8192D("Stop M2U(%d, %d)! ", pxmitpriv->free_xmitframe_cnt, pxmitpriv->free_xmitbuf_cnt);
-			//DBG_8192D("!m2u );
+			//DBG_8192D("!m2u);
 		}
 	}
 

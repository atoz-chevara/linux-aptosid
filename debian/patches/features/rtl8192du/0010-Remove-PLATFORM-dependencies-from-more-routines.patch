From 0e86389b1cd82a4a145b62accb4cfb3341379ea8 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Wed, 17 Apr 2013 12:02:06 -0500
Subject: [PATCH 010/390] Remove PLATFORM dependencies from more routines

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 Makefile                | 230 -----------
 include/osdep_service.h | 988 +-----------------------------------------------
 os_dep/mlme_linux.c     |  65 ----
 os_dep/usb_intf.c       |  82 ----
 4 files changed, 2 insertions(+), 1363 deletions(-)

--- a/drivers/staging/rtl8192du/Makefile
+++ b/drivers/staging/rtl8192du/Makefile
@@ -145,7 +145,6 @@ ifeq ($(CONFIG_INTEL_WIDI), y)
 EXTRA_CFLAGS += -DCONFIG_INTEL_WIDI
 endif
 
-ifeq ($(CONFIG_PLATFORM_I386_PC), y)
 EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
 SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
 ARCH ?= $(SUBARCH)
@@ -154,235 +153,6 @@ KVER  := $(shell uname -r)
 KSRC := /lib/modules/$(KVER)/build
 MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/
 INSTALL_PREFIX :=
-endif
-
-ifeq ($(CONFIG_PLATFORM_TI_AM3517), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_SHUTTLE
-CROSS_COMPILE := arm-eabi-
-KSRC := $(shell pwd)/../../../Android/kernel
-ARCH := arm
-endif
-
-ifeq ($(CONFIG_PLATFORM_MSTAR_TITANIA12), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MSTAR_TITANIA12
-ARCH:=mips
-CROSS_COMPILE:= /usr/src/Mstar_kernel/mips-4.3/bin/mips-linux-gnu-
-KVER:= 2.6.28.9
-KSRC:= /usr/src/Mstar_kernel/2.6.28.9/
-endif
-
-ifeq ($(CONFIG_PLATFORM_MSTAR_A3), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MSTAR_TITANIA12
-ARCH:=arm
-CROSS_COMPILE:= arm-none-linux-gnueabi-
-KVER:= 2.6.35.11
-KSRC:= /home/gary/PERFORCE/THEALE/RedLion/2.6.35.11/
-MODULE_NAME = wlan
-endif
-
-ifeq ($(CONFIG_PLATFORM_ANDROID_X86), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
-SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
-ARCH := $(SUBARCH)
-CROSS_COMPILE := /media/DATA-2/android-x86/ics-x86_20120130/prebuilt/linux-x86/toolchain/i686-unknown-linux-gnu-4.2.1/bin/i686-unknown-linux-gnu-
-KSRC := /media/DATA-2/android-x86/ics-x86_20120130/out/target/product/generic_x86/obj/kernel
-MODULE_NAME :=wlan
-endif
-
-ifeq ($(CONFIG_PLATFORM_ARM_PXA2XX), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
-ARCH := arm
-CROSS_COMPILE := arm-none-linux-gnueabi-
-KVER  := 2.6.34.1
-KSRC ?= /usr/src/linux-2.6.34.1
-endif
-
-ifeq ($(CONFIG_PLATFORM_ARM_S3C2K4), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
-ARCH := arm
-CROSS_COMPILE := arm-linux-
-KVER  := 2.6.24.7_$(ARCH)
-KSRC := /usr/src/kernels/linux-$(KVER)
-endif
-
-ifeq ($(CONFIG_PLATFORM_ARM_S3C6K4), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
-ARCH := arm
-CROSS_COMPILE := arm-none-linux-gnueabi-
-KVER  := 2.6.34.1
-KSRC ?= /usr/src/linux-2.6.34.1
-endif
-
-ifeq ($(CONFIG_PLATFORM_RTD2880B), y)
-EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN -DCONFIG_PLATFORM_RTD2880B
-ARCH:=
-CROSS_COMPILE:=
-KVER:=
-KSRC:=
-endif
-
-ifeq ($(CONFIG_PLATFORM_MIPS_RMI), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
-ARCH:=mips
-CROSS_COMPILE:=mipsisa32r2-uclibc-
-KVER:=
-KSRC:= /root/work/kernel_realtek
-endif
-
-ifeq ($(CONFIG_PLATFORM_MIPS_PLM), y)
-EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN
-ARCH:=mips
-CROSS_COMPILE:=mipsisa32r2-uclibc-
-KVER:=
-KSRC:= /root/work/kernel_realtek
-endif
-
-ifeq ($(CONFIG_PLATFORM_MSTAR389), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MSTAR389
-ARCH:=mips
-CROSS_COMPILE:= mips-linux-gnu-
-KVER:= 2.6.28.10
-KSRC:= /home/mstar/mstar_linux/2.6.28.9/
-endif
-
-ifeq ($(CONFIG_PLATFORM_MIPS_AR9132), y)
-EXTRA_CFLAGS += -DCONFIG_BIG_ENDIAN
-ARCH := mips
-CROSS_COMPILE := mips-openwrt-linux-
-KSRC := /home/alex/test_openwrt/tmp/linux-2.6.30.9
-endif
-
-ifeq ($(CONFIG_PLATFORM_DMP_PHILIPS), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DRTK_DMP_PLATFORM
-ARCH := mips
-#CROSS_COMPILE:=/usr/local/msdk-4.3.6-mips-EL-2.6.12.6-0.9.30.3/bin/mipsel-linux-
-CROSS_COMPILE:=/usr/local/toolchain_mipsel/bin/mipsel-linux-
-KSRC ?=/usr/local/Jupiter/linux-2.6.12
-endif
-
-ifeq ($(CONFIG_PLATFORM_RTK_DMP), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DRTK_DMP_PLATFORM
-ARCH:=mips
-CROSS_COMPILE:=mipsel-linux-
-KVER:=
-KSRC ?= /usr/src/DMP_Kernel/jupiter/linux-2.6.12
-endif
-
-ifeq ($(CONFIG_PLATFORM_MT53XX), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MT53XX
-ARCH:= arm
-CROSS_COMPILE:= arm11_mtk_le-
-KVER:= 2.6.27
-KSRC?= /proj/mtk00802/BD_Compare/BDP/Dev/BDP_V301/BDP_Linux/linux-2.6.27
-endif
-
-ifeq ($(CONFIG_PLATFORM_ARM_MX51_241H), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_WISTRON_PLATFORM
-ARCH := arm
-CROSS_COMPILE := /opt/freescale/usr/local/gcc-4.1.2-glibc-2.5-nptl-3/arm-none-linux-gnueabi/bin/arm-none-linux-gnueabi-
-KVER  := 2.6.31
-KSRC ?= /lib/modules/2.6.31-770-g0e46b52/source
-endif
-
-ifeq ($(CONFIG_PLATFORM_FS_MX61), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN 
-ARCH := arm
-CROSS_COMPILE := /home/share/CusEnv/FreeScale/arm-eabi-4.4.3/bin/arm-eabi-
-KSRC ?= /home/share/CusEnv/FreeScale/FS_kernel_env
-endif
-
-
-
-ifeq ($(CONFIG_PLATFORM_ACTIONS_ATJ227X), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ACTIONS_ATJ227X
-ARCH := mips
-CROSS_COMPILE := /home/cnsd4/project/actions/tools-2.6.27/bin/mipsel-linux-gnu-
-KVER  := 2.6.27
-KSRC := /home/cnsd4/project/actions/linux-2.6.27.28
-endif
-
-ifeq ($(CONFIG_PLATFORM_TI_DM365), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_TI_DM365
-ARCH := arm
-CROSS_COMPILE := /home/cnsd4/Appro/mv_pro_5.0/montavista/pro/devkit/arm/v5t_le/bin/arm_v5t_le-
-KVER  := 2.6.18
-KSRC := /home/cnsd4/Appro/mv_pro_5.0/montavista/pro/devkit/lsp/ti-davinci/linux-dm365
-endif
-
-ifeq ($(CONFIG_PLATFORM_TEGRA3_CARDHU), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
-ARCH := arm
-CROSS_COMPILE := /home/android_sdk/nvidia/tegra-16r3-partner-android-4.1_20120723/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
-KSRC := /home/android_sdk/nvidia/tegra-16r3-partner-android-4.1_20120723/out/target/product/cardhu/obj/KERNEL
-MODULE_NAME := wlan
-endif
-
-ifeq ($(CONFIG_PLATFORM_TEGRA4_DALMORE), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
-ARCH := arm
-CROSS_COMPILE := /home/android_sdk/nvidia/tegra-17r9-partner-android-4.2-dalmore_20130131/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
-KSRC := /home/android_sdk/nvidia/tegra-17r9-partner-android-4.2-dalmore_20130131/out/target/product/dalmore/obj/KERNEL
-MODULE_NAME := wlan
-endif
-
-ifeq ($(CONFIG_PLATFORM_ARM_TCC8900), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
-ARCH := arm
-CROSS_COMPILE := /home/android_sdk/Telechips/SDK_2304_20110613/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
-KSRC := /home/android_sdk/Telechips/SDK_2304_20110613/kernel
-MODULE_NAME := wlan
-endif
-
-ifeq ($(CONFIG_PLATFORM_ARM_TCC8920), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
-ARCH := arm
-CROSS_COMPILE := /home/android_sdk/Telechips/v12.06_r1-tcc-android-4.0.4/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
-KSRC := /home/android_sdk/Telechips/v12.06_r1-tcc-android-4.0.4/kernel
-MODULE_NAME := wlan
-endif
-
-ifeq ($(CONFIG_PLATFORM_ARM_RK2818), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID -DCONFIG_PLATFORM_ROCKCHIPS -DCONFIG_MINIMAL_MEMORY_USAGE
-ARCH := arm
-CROSS_COMPILE := /usr/src/release_fae_version/toolchain/arm-eabi-4.4.0/bin/arm-eabi-
-KSRC := /usr/src/release_fae_version/kernel25_A7_281x
-MODULE_NAME := wlan
-endif
-
-ifeq ($(CONFIG_PLATFORM_ARM_TI_PANDA), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN #-DCONFIG_MINIMAL_MEMORY_USAGE
-ARCH := arm
-#CROSS_COMPILE := /media/DATA-1/aosp/ics-aosp_20111227/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
-#KSRC := /media/DATA-1/aosp/android-omap-panda-3.0_20120104
-CROSS_COMPILE := /media/DATA-1/android-4.0/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
-KSRC := /media/DATA-1/android-4.0/panda_kernel/omap
-MODULE_NAME := wlan
-endif
-
-ifeq ($(CONFIG_PLATFORM_MIPS_JZ4760), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_MINIMAL_MEMORY_USAGE
-ARCH ?= mips
-CROSS_COMPILE ?= /mnt/sdb5/Ingenic/Umido/mips-4.3/bin/mips-linux-gnu-
-KSRC ?= /mnt/sdb5/Ingenic/Umido/kernel
-endif
-
-#Add setting for MN10300
-ifeq ($(CONFIG_PLATFORM_MN10300), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_MN10300
-ARCH := mn10300
-CROSS_COMPILE := mn10300-linux-
-KVER := 2.6.32.2
-KSRC := /home/winuser/work/Plat_sLD2T_V3010/usr/src/linux-2.6.32.2
-INSTALL_PREFIX :=
-endif
-
-ifeq ($(CONFIG_PLATFORM_ARM_SUNxI), y)
-EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ARM_SUNxI
-ARCH := arm
-CROSS_COMPILE := arm-none-linux-gnueabi-
-KVER  := 3.0.8
-#KSRC:= ../lichee/linux-3.0/
-endif
 
 ifneq ($(USER_MODULE_NAME),)
 MODULE_NAME := $(USER_MODULE_NAME)
--- a/drivers/staging/rtl8192du/include/osdep_service.h
+++ b/drivers/staging/rtl8192du/include/osdep_service.h
@@ -35,721 +35,6 @@
 #undef _FALSE
 #define _FALSE		0
 
-
-#ifdef PLATFORM_FREEBSD
-#include <sys/cdefs.h>
-#include <sys/types.h>
-#include <sys/systm.h>
-#include <sys/param.h>
-#include <sys/sockio.h>
-#include <sys/sysctl.h>
-#include <sys/lock.h>
-#include <sys/mutex.h>
-#include <sys/mbuf.h>
-#include <sys/kernel.h>
-#include <sys/socket.h>
-#include <sys/systm.h>
-#include <sys/malloc.h>
-#include <sys/module.h>
-#include <sys/bus.h>
-#include <sys/endian.h>
-#include <sys/kdb.h>
-#include <sys/kthread.h>
-#include <machine/atomic.h>
-
-#include <machine/bus.h>
-#include <machine/resource.h>
-#include <sys/rman.h>
-
-#include <net/bpf.h>
-#include <net/if.h>
-#include <net/if_arp.h>
-#include <net/ethernet.h>
-#include <net/if_dl.h>
-#include <net/if_media.h>
-#include <net/if_types.h>
-#include <net/route.h>
-
-
-#include <netinet/in.h>
-#include <netinet/in_systm.h>
-#include <netinet/in_var.h>
-#include <netinet/if_ether.h>
-
-#include <net80211/ieee80211_var.h>
-#include <net80211/ieee80211_regdomain.h>
-#include <net80211/ieee80211_radiotap.h>
-#include <net80211/ieee80211_ratectl.h>
-
-#include <dev/usb/usb.h>
-#include <dev/usb/usbdi.h>
-#include "usbdevs.h"
-
-#define	USB_DEBUG_VAR rum_debug
-#include <dev/usb/usb_debug.h>
-
-#if 1 //Baron porting from linux, it's all temp solution, needs to check again
-#include <sys/sema.h>
-#include <sys/pcpu.h> /* XXX for PCPU_GET */
-//	typedef struct	semaphore _sema;
-	typedef struct	sema _sema;
-//	typedef	spinlock_t	_lock;
-	typedef	struct mtx	_lock;
-	typedef struct mtx		_mutex;
-	typedef struct timer_list _timer;
-	struct list_head {
-	struct list_head *next, *prev;
-	};
-	struct	__queue	{
-		struct	list_head	queue;
-		_lock	lock;
-	};
-
-	//typedef	struct sk_buff	_pkt;
-	typedef	struct mbuf	_pkt;
-	typedef struct mbuf	_buffer;
-
-	typedef struct	__queue	_queue;
-	typedef struct	list_head	_list;
-	typedef	int	_OS_STATUS;
-	//typedef u32	_irqL;
-	typedef unsigned long _irqL;
-	typedef	struct	ifnet * _nic_hdl;
-
-	typedef pid_t		_thread_hdl_;
-//	typedef struct thread		_thread_hdl_;
-	typedef void		thread_return;
-	typedef void*	thread_context;
-
-	//#define thread_exit() complete_and_exit(NULL, 0)
-
-	typedef void timer_hdl_return;
-	typedef void* timer_hdl_context;
-	typedef struct work_struct _workitem;
-
-#define   KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
-/* emulate a modern version */
-#define LINUX_VERSION_CODE KERNEL_VERSION(2, 6, 35)
-
-#define WIRELESS_EXT -1
-#define HZ hz
-#define spin_lock_irqsave mtx_lock_irqsave
-#define spin_lock_bh mtx_lock_irqsave
-#define mtx_lock_irqsave(lock, x) mtx_lock(lock)//{local_irq_save((x)); mtx_lock_spin((lock));}
-//#define IFT_RTW	0xf9 //ifnet allocate type for RTW
-#define free_netdev if_free
-#define LIST_CONTAINOR(ptr, type, member) \
-        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
-#define container_of(p,t,n) (t*)((p)-&(((t*)0)->n))
-/*
- * Linux timers are emulated using FreeBSD callout functions
- * (and taskqueue functionality).
- *
- * Currently no timer stats functionality.
- *
- * See (linux_compat) processes.c
- *
- */
-struct timer_list {
-
-        /* FreeBSD callout related fields */
-        struct callout callout;
-
-	//timeout function
-        void (*function)(void*);
-	//argument
-	 void *arg;
-
-};
-struct workqueue_struct;
-struct work_struct;
-typedef void (*work_func_t)(struct work_struct *work);
-/* Values for the state of an item of work (work_struct) */
-typedef enum work_state {
-        WORK_STATE_UNSET = 0,
-        WORK_STATE_CALLOUT_PENDING = 1,
-        WORK_STATE_TASK_PENDING = 2,
-        WORK_STATE_WORK_CANCELLED = 3
-} work_state_t;
-
-struct work_struct {
-        struct task task; /* FreeBSD task */
-        work_state_t state; /* the pending or otherwise state of work. */
-        work_func_t func;
-};
-#define spin_unlock_irqrestore mtx_unlock_irqrestore
-#define spin_unlock_bh mtx_unlock_irqrestore
-#define mtx_unlock_irqrestore(lock,x)    mtx_unlock(lock);
-extern void	_rtw_spinlock_init(_lock *plock);
-
-//modify private structure to match freebsd
-#define BITS_PER_LONG 32
-union ktime {
-	s64	tv64;
-#if BITS_PER_LONG != 64 && !defined(CONFIG_KTIME_SCALAR)
-	struct {
-#ifdef __BIG_ENDIAN
-	s32	sec, nsec;
-#else
-	s32	nsec, sec;
-#endif
-	} tv;
-#endif
-};
-#define kmemcheck_bitfield_begin(name)
-#define kmemcheck_bitfield_end(name)
-#define CHECKSUM_NONE 0
-typedef unsigned char *sk_buff_data_t;
-typedef union ktime ktime_t;		/* Kill this */
-
-void rtw_mtx_lock(_lock *plock);
-
-void rtw_mtx_unlock(_lock *plock);
-
-/**
- *	struct sk_buff - socket buffer
- *	@next: Next buffer in list
- *	@prev: Previous buffer in list
- *	@sk: Socket we are owned by
- *	@tstamp: Time we arrived
- *	@dev: Device we arrived on/are leaving by
- *	@transport_header: Transport layer header
- *	@network_header: Network layer header
- *	@mac_header: Link layer header
- *	@_skb_refdst: destination entry (with norefcount bit)
- *	@sp: the security path, used for xfrm
- *	@cb: Control buffer. Free for use by every layer. Put private vars here
- *	@len: Length of actual data
- *	@data_len: Data length
- *	@mac_len: Length of link layer header
- *	@hdr_len: writable header length of cloned skb
- *	@csum: Checksum (must include start/offset pair)
- *	@csum_start: Offset from skb->head where checksumming should start
- *	@csum_offset: Offset from csum_start where checksum should be stored
- *	@local_df: allow local fragmentation
- *	@cloned: Head may be cloned (check refcnt to be sure)
- *	@nohdr: Payload reference only, must not modify header
- *	@pkt_type: Packet class
- *	@fclone: skbuff clone status
- *	@ip_summed: Driver fed us an IP checksum
- *	@priority: Packet queueing priority
- *	@users: User count - see {datagram,tcp}.c
- *	@protocol: Packet protocol from driver
- *	@truesize: Buffer size
- *	@head: Head of buffer
- *	@data: Data head pointer
- *	@tail: Tail pointer
- *	@end: End pointer
- *	@destructor: Destruct function
- *	@mark: Generic packet mark
- *	@nfct: Associated connection, if any
- *	@ipvs_property: skbuff is owned by ipvs
- *	@peeked: this packet has been seen already, so stats have been
- *		done for it, don't do them again
- *	@nf_trace: netfilter packet trace flag
- *	@nfctinfo: Relationship of this skb to the connection
- *	@nfct_reasm: netfilter conntrack re-assembly pointer
- *	@nf_bridge: Saved data about a bridged frame - see br_netfilter.c
- *	@skb_iif: ifindex of device we arrived on
- *	@rxhash: the packet hash computed on receive
- *	@queue_mapping: Queue mapping for multiqueue devices
- *	@tc_index: Traffic control index
- *	@tc_verd: traffic control verdict
- *	@ndisc_nodetype: router type (from link layer)
- *	@dma_cookie: a cookie to one of several possible DMA operations
- *		done by skb DMA functions
- *	@secmark: security marking
- *	@vlan_tci: vlan tag control information
- */
-
-struct sk_buff {
-	/* These two members must be first. */
-	struct sk_buff		*next;
-	struct sk_buff		*prev;
-
-	ktime_t			tstamp;
-
-	struct sock		*sk;
-	//struct net_device	*dev;
-	struct ifnet *dev;
-
-	/*
-	 * This is the control buffer. It is free to use for every
-	 * layer. Please put your private variables there. If you
-	 * want to keep them across layers you have to do a skb_clone()
-	 * first. This is owned by whoever has the skb queued ATM.
-	 */
-	char			cb[48] __aligned(8);
-
-	unsigned long		_skb_refdst;
-#ifdef CONFIG_XFRM
-	struct	sec_path	*sp;
-#endif
-	unsigned int		len,
-				data_len;
-	u16			mac_len,
-				hdr_len;
-	union {
-		u32		csum;
-		struct {
-			u16	csum_start;
-			u16	csum_offset;
-		}smbol2;
-	}smbol1;
-	u32			priority;
-	kmemcheck_bitfield_begin(flags1);
-	u8			local_df:1,
-				cloned:1,
-				ip_summed:2,
-				nohdr:1,
-				nfctinfo:3;
-	u8			pkt_type:3,
-				fclone:2,
-				ipvs_property:1,
-				peeked:1,
-				nf_trace:1;
-	kmemcheck_bitfield_end(flags1);
-	u16			protocol;
-
-	void			(*destructor)(struct sk_buff *skb);
-#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
-	struct nf_conntrack	*nfct;
-	struct sk_buff		*nfct_reasm;
-#endif
-#ifdef CONFIG_BRIDGE_NETFILTER
-	struct nf_bridge_info	*nf_bridge;
-#endif
-
-	int			skb_iif;
-#ifdef CONFIG_NET_SCHED
-	u16			tc_index;	/* traffic control index */
-#ifdef CONFIG_NET_CLS_ACT
-	u16			tc_verd;	/* traffic control verdict */
-#endif
-#endif
-
-	u32			rxhash;
-
-	kmemcheck_bitfield_begin(flags2);
-	u16			queue_mapping:16;
-#ifdef CONFIG_IPV6_NDISC_NODETYPE
-	u8			ndisc_nodetype:2,
-				deliver_no_wcard:1;
-#else
-	u8			deliver_no_wcard:1;
-#endif
-	kmemcheck_bitfield_end(flags2);
-
-	/* 0/14 bit hole */
-
-#ifdef CONFIG_NET_DMA
-	dma_cookie_t		dma_cookie;
-#endif
-#ifdef CONFIG_NETWORK_SECMARK
-	u32			secmark;
-#endif
-	union {
-		u32		mark;
-		u32		dropcount;
-	}symbol3;
-
-	u16			vlan_tci;
-
-	sk_buff_data_t		transport_header;
-	sk_buff_data_t		network_header;
-	sk_buff_data_t		mac_header;
-	/* These elements must be at the end, see alloc_skb() for details.  */
-	sk_buff_data_t		tail;
-	sk_buff_data_t		end;
-	unsigned char		*head,
-				*data;
-	unsigned int		truesize;
-	atomic_t		users;
-};
-struct sk_buff_head {
-	/* These two members must be first. */
-	struct sk_buff	*next;
-	struct sk_buff	*prev;
-
-	u32		qlen;
-	_lock	lock;
-};
-#define skb_tail_pointer(skb)	skb->tail
-static inline unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
-{
-	unsigned char *tmp = skb_tail_pointer(skb);
-	//SKB_LINEAR_ASSERT(skb);
-	skb->tail += len;
-	skb->len  += len;
-	return tmp;
-}
-
-static inline unsigned char *__skb_pull(struct sk_buff *skb, unsigned int len)
-{
-	skb->len -= len;
-	if(skb->len < skb->data_len)
-		printf("%s(),%d,error!\n",__FUNCTION__,__LINE__);
-	return skb->data += len;
-}
-static inline unsigned char *skb_pull(struct sk_buff *skb, unsigned int len)
-{
-	#ifdef PLATFORM_FREEBSD
-	return __skb_pull(skb, len);
-	#else
-	return unlikely(len > skb->len) ? NULL : __skb_pull(skb, len);
-	#endif //PLATFORM_FREEBSD
-}
-static inline u32 skb_queue_len(const struct sk_buff_head *list_)
-{
-	return list_->qlen;
-}
-static inline void __skb_insert(struct sk_buff *newsk,
-				struct sk_buff *prev, struct sk_buff *next,
-				struct sk_buff_head *list)
-{
-	newsk->next = next;
-	newsk->prev = prev;
-	next->prev  = prev->next = newsk;
-	list->qlen++;
-}
-static inline void __skb_queue_before(struct sk_buff_head *list,
-				      struct sk_buff *next,
-				      struct sk_buff *newsk)
-{
-	__skb_insert(newsk, next->prev, next, list);
-}
-static inline void skb_queue_tail(struct sk_buff_head *list,
-				   struct sk_buff *newsk)
-{
-	mtx_lock(&list->lock);
-	__skb_queue_before(list, (struct sk_buff *)list, newsk);
-	mtx_unlock(&list->lock);
-}
-static inline struct sk_buff *skb_peek(struct sk_buff_head *list_)
-{
-	struct sk_buff *list = ((struct sk_buff *)list_)->next;
-	if (list == (struct sk_buff *)list_)
-		list = NULL;
-	return list;
-}
-static inline void __skb_unlink(struct sk_buff *skb, struct sk_buff_head *list)
-{
-	struct sk_buff *next, *prev;
-
-	list->qlen--;
-	next	   = skb->next;
-	prev	   = skb->prev;
-	skb->next  = skb->prev = NULL;
-	next->prev = prev;
-	prev->next = next;
-}
-
-static inline struct sk_buff *skb_dequeue(struct sk_buff_head *list)
-{
-	mtx_lock(&list->lock);
-
-	struct sk_buff *skb = skb_peek(list);
-	if (skb)
-		__skb_unlink(skb, list);
-
-	mtx_unlock(&list->lock);
-
-	return skb;
-}
-static inline void skb_reserve(struct sk_buff *skb, int len)
-{
-	skb->data += len;
-	skb->tail += len;
-}
-static inline void __skb_queue_head_init(struct sk_buff_head *list)
-{
-	list->prev = list->next = (struct sk_buff *)list;
-	list->qlen = 0;
-}
-/*
- * This function creates a split out lock class for each invocation;
- * this is needed for now since a whole lot of users of the skb-queue
- * infrastructure in drivers have different locking usage (in hardirq)
- * than the networking core (in softirq only). In the long run either the
- * network layer or drivers should need annotation to consolidate the
- * main types of usage into 3 classes.
- */
-static inline void skb_queue_head_init(struct sk_buff_head *list)
-{
-	_rtw_spinlock_init(&list->lock);
-	__skb_queue_head_init(list);
-}
-unsigned long copy_from_user(void *to, const void *from, unsigned long n);
-unsigned long copy_to_user(void *to, const void *from, unsigned long n);
-struct sk_buff * dev_alloc_skb(unsigned int size);
-struct sk_buff *skb_clone(const struct sk_buff *skb);
-void dev_kfree_skb_any(struct sk_buff *skb);
-#endif //Baron porting from linux, it's all temp solution, needs to check again
-
-
-#if 1 // kenny add Linux compatibility code for Linux USB driver
-#include <dev/usb/usb_compat_linux.h>
-
-#define __init		// __attribute ((constructor))
-#define __exit		// __attribute ((destructor))
-
-/*
- * Definitions for module_init and module_exit macros.
- *
- * These macros will use the SYSINIT framework to call a specified
- * function (with no arguments) on module loading or unloading.
- *
- */
-
-void module_init_exit_wrapper(void *arg);
-
-#define module_init(initfn)                             \
-        SYSINIT(mod_init_ ## initfn,                    \
-                SI_SUB_KLD, SI_ORDER_FIRST,             \
-                module_init_exit_wrapper, initfn)
-
-#define module_exit(exitfn)                             \
-        SYSUNINIT(mod_exit_ ## exitfn,                  \
-                  SI_SUB_KLD, SI_ORDER_ANY,             \
-                  module_init_exit_wrapper, exitfn)
-
-/*
- * The usb_register and usb_deregister functions are used to register
- * usb drivers with the usb subsystem.
- */
-int usb_register(struct usb_driver *driver);
-int usb_deregister(struct usb_driver *driver);
-
-/*
- * usb_get_dev and usb_put_dev - increment/decrement the reference count
- * of the usb device structure.
- *
- * Original body of usb_get_dev:
- *
- *       if (dev)
- *               get_device(&dev->dev);
- *       return dev;
- *
- * Reference counts are not currently used in this compatibility
- * layer. So these functions will do nothing.
- */
-static inline struct usb_device *
-usb_get_dev(struct usb_device *dev)
-{
-        return dev;
-}
-
-static inline void
-usb_put_dev(struct usb_device *dev)
-{
-        return;
-}
-
-
-// rtw_usb_compat_linux
-int rtw_usb_submit_urb(struct urb *urb, uint16_t mem_flags);
-int rtw_usb_unlink_urb(struct urb *urb);
-int rtw_usb_clear_halt(struct usb_device *dev, struct usb_host_endpoint *uhe);
-int rtw_usb_control_msg(struct usb_device *dev, struct usb_host_endpoint *uhe,
-    uint8_t request, uint8_t requesttype,
-    uint16_t value, uint16_t index, void *data,
-    uint16_t size, usb_timeout_t timeout);
-int rtw_usb_set_interface(struct usb_device *dev, uint8_t iface_no, uint8_t alt_index);
-int rtw_usb_setup_endpoint(struct usb_device *dev,
-    struct usb_host_endpoint *uhe, usb_size_t bufsize);
-struct urb *rtw_usb_alloc_urb(uint16_t iso_packets, uint16_t mem_flags);
-struct usb_host_endpoint *rtw_usb_find_host_endpoint(struct usb_device *dev, uint8_t type, uint8_t ep);
-struct usb_host_interface *rtw_usb_altnum_to_altsetting(const struct usb_interface *intf, uint8_t alt_index);
-struct usb_interface *rtw_usb_ifnum_to_if(struct usb_device *dev, uint8_t iface_no);
-void *rtw_usb_buffer_alloc(struct usb_device *dev, usb_size_t size, uint16_t mem_flags, uint8_t *dma_addr);
-void *rtw_usbd_get_intfdata(struct usb_interface *intf);
-void rtw_usb_linux_register(void *arg);
-void rtw_usb_linux_deregister(void *arg);
-void rtw_usb_linux_free_device(struct usb_device *dev);
-void rtw_usb_buffer_free(struct usb_device *dev, usb_size_t size,
-    void *addr, uint8_t dma_addr);
-void rtw_usb_free_urb(struct urb *urb);
-void rtw_usb_init_urb(struct urb *urb);
-void rtw_usb_kill_urb(struct urb *urb);
-void rtw_usb_set_intfdata(struct usb_interface *intf, void *data);
-void rtw_usb_fill_bulk_urb(struct urb *urb, struct usb_device *udev,
-    struct usb_host_endpoint *uhe, void *buf,
-    int length, usb_complete_t callback, void *arg);
-int rtw_usb_bulk_msg(struct usb_device *udev, struct usb_host_endpoint *uhe,
-    void *data, int len, uint16_t *pactlen, usb_timeout_t timeout);
-void *usb_get_intfdata(struct usb_interface *intf);
-int usb_linux_init_endpoints(struct usb_device *udev);
-
-
-
-typedef struct urb *  PURB;
-
-typedef unsigned gfp_t;
-#define __GFP_WAIT      ((gfp_t)0x10u)  /* Can wait and reschedule? */
-#define __GFP_HIGH      ((gfp_t)0x20u)  /* Should access emergency pools? */
-#define __GFP_IO        ((gfp_t)0x40u)  /* Can start physical IO? */
-#define __GFP_FS        ((gfp_t)0x80u)  /* Can call down to low-level FS? */
-#define __GFP_COLD      ((gfp_t)0x100u) /* Cache-cold page required */
-#define __GFP_NOWARN    ((gfp_t)0x200u) /* Suppress page allocation failure warning */
-#define __GFP_REPEAT    ((gfp_t)0x400u) /* Retry the allocation.  Might fail */
-#define __GFP_NOFAIL    ((gfp_t)0x800u) /* Retry for ever.  Cannot fail */
-#define __GFP_NORETRY   ((gfp_t)0x1000u)/* Do not retry.  Might fail */
-#define __GFP_NO_GROW   ((gfp_t)0x2000u)/* Slab internal usage */
-#define __GFP_COMP      ((gfp_t)0x4000u)/* Add compound page metadata */
-#define __GFP_ZERO      ((gfp_t)0x8000u)/* Return zeroed page on success */
-#define __GFP_NOMEMALLOC ((gfp_t)0x10000u) /* Don't use emergency reserves */
-#define __GFP_HARDWALL   ((gfp_t)0x20000u) /* Enforce hardwall cpuset memory allocs */
-
-/* This equals 0, but use constants in case they ever change */
-#define GFP_NOWAIT      (GFP_ATOMIC & ~__GFP_HIGH)
-/* GFP_ATOMIC means both !wait (__GFP_WAIT not set) and use emergency pool */
-#define GFP_ATOMIC      (__GFP_HIGH)
-#define GFP_NOIO        (__GFP_WAIT)
-#define GFP_NOFS        (__GFP_WAIT | __GFP_IO)
-#define GFP_KERNEL      (__GFP_WAIT | __GFP_IO | __GFP_FS)
-#define GFP_USER        (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL)
-#define GFP_HIGHUSER    (__GFP_WAIT | __GFP_IO | __GFP_FS | __GFP_HARDWALL | \
-                         __GFP_HIGHMEM)
-
-
-#endif // kenny add Linux compatibility code for Linux USB
-
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
-	#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
-#endif
-
-__inline static _list *get_next(_list	*list)
-{
-	return list->next;
-}
-
-__inline static _list	*get_list_head(_queue	*queue)
-{
-	return (&(queue->queue));
-}
-
-
-#define LIST_CONTAINOR(ptr, type, member) \
-        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
-
-
-__inline static void _enter_critical(_lock *plock, _irqL *pirqL)
-{
-	spin_lock_irqsave(plock, *pirqL);
-}
-
-__inline static void _exit_critical(_lock *plock, _irqL *pirqL)
-{
-	spin_unlock_irqrestore(plock, *pirqL);
-}
-
-__inline static void _enter_critical_ex(_lock *plock, _irqL *pirqL)
-{
-	spin_lock_irqsave(plock, *pirqL);
-}
-
-__inline static void _exit_critical_ex(_lock *plock, _irqL *pirqL)
-{
-	spin_unlock_irqrestore(plock, *pirqL);
-}
-
-__inline static void _enter_critical_bh(_lock *plock, _irqL *pirqL)
-{
-	spin_lock_bh(plock, *pirqL);
-}
-
-__inline static void _exit_critical_bh(_lock *plock, _irqL *pirqL)
-{
-	spin_unlock_bh(plock, *pirqL);
-}
-
-__inline static void _enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
-{
-
-		mtx_lock(pmutex);
-
-}
-
-
-__inline static void _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
-{
-
-		mtx_unlock(pmutex);
-
-}
-static inline void __list_del(struct list_head * prev, struct list_head * next)
-{
-	next->prev = prev;
-	prev->next = next;
-}
-static inline void INIT_LIST_HEAD(struct list_head *list)
-{
-	list->next = list;
-	list->prev = list;
-}
-__inline static void rtw_list_delete(_list *plist)
-{
-	__list_del(plist->prev, plist->next);
-	INIT_LIST_HEAD(plist);
-}
-
-__inline static void _init_timer(_timer *ptimer,_nic_hdl padapter,void *pfunc,void* cntx)
-{
-	ptimer->function = pfunc;
-	ptimer->arg = cntx;
-	callout_init(&ptimer->callout, CALLOUT_MPSAFE);
-}
-
-__inline static void _set_timer(_timer *ptimer,u32 delay_time)
-{
-	//	mod_timer(ptimer , (jiffies+(delay_time*HZ/1000)));
-	if(ptimer->function && ptimer->arg){
-		rtw_mtx_lock(NULL);
-		callout_reset(&ptimer->callout, delay_time,ptimer->function, ptimer->arg);
-		rtw_mtx_unlock(NULL);
-	}
-}
-
-__inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
-{
-	//	del_timer_sync(ptimer);
-	//	*bcancelled=  _TRUE;//TRUE ==1; FALSE==0
-	rtw_mtx_lock(NULL);
-	callout_drain(&ptimer->callout);
-	rtw_mtx_unlock(NULL);
-}
-
-__inline static void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
-{
-	printf("%s Not implement yet! \n",__FUNCTION__);
-}
-
-__inline static void _set_workitem(_workitem *pwork)
-{
-	printf("%s Not implement yet! \n",__FUNCTION__);
-//	schedule_work(pwork);
-}
-
-//
-// Global Mutex: can only be used at PASSIVE level.
-//
-
-#define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
-{                                                               \
-}
-
-#define RELEASE_GLOBAL_MUTEX(_MutexCounter)                              \
-{                                                               \
-}
-
-#define ATOMIC_INIT(i)  { (i) }
-
-#endif //PLATFORM_FREEBSD
-
-
-#ifdef PLATFORM_LINUX
 	#include <linux/version.h>
 	#include <linux/spinlock.h>
 	#include <linux/compiler.h>
@@ -970,11 +255,7 @@ __inline static void _cancel_timer(_time
 	*bcancelled=  _TRUE;//TRUE ==1; FALSE==0
 }
 
-#ifdef PLATFORM_LINUX
 #define RTW_TIMER_HDL_ARGS void *FunctionContext
-#elif defined(PLATFORM_OS_CE) || defined(PLATFORM_WINDOWS)
-#define RTW_TIMER_HDL_ARGS IN PVOID SystemSpecific1, IN PVOID FunctionContext, IN PVOID SystemSpecific2, IN PVOID SystemSpecific3
-#endif
 
 #define RTW_TIMER_HDL_NAME(name) rtw_##name##_timer_hdl
 #define RTW_DECLARE_TIMER_HDL(name) void RTW_TIMER_HDL_NAME(name)(RTW_TIMER_HDL_ARGS)
@@ -1060,176 +341,6 @@ static inline void rtw_netif_stop_queue(
 #endif
 }
 
-#endif	// PLATFORM_LINUX
-
-
-#ifdef PLATFORM_OS_XP
-
-	#include <ndis.h>
-	#include <ntddk.h>
-	#include <ntddndis.h>
-	#include <ntdef.h>
-
-#ifdef CONFIG_USB_HCI
-	#include <usb.h>
-	#include <usbioctl.h>
-	#include <usbdlib.h>
-#endif
-
-	typedef KSEMAPHORE	_sema;
-	typedef	LIST_ENTRY	_list;
-	typedef NDIS_STATUS _OS_STATUS;
-
-
-	typedef NDIS_SPIN_LOCK	_lock;
-
-	typedef KMUTEX			_mutex;
-
-	typedef KIRQL	_irqL;
-
-	// USB_PIPE for WINCE , but handle can be use just integer under windows
-	typedef NDIS_HANDLE  _nic_hdl;
-
-
-	typedef NDIS_MINIPORT_TIMER    _timer;
-
-	struct	__queue	{
-		LIST_ENTRY	queue;
-		_lock	lock;
-	};
-
-	typedef	NDIS_PACKET	_pkt;
-	typedef NDIS_BUFFER	_buffer;
-	typedef struct	__queue	_queue;
-
-	typedef PKTHREAD _thread_hdl_;
-	typedef void	thread_return;
-	typedef void* thread_context;
-
-	typedef NDIS_WORK_ITEM _workitem;
-
-	#define thread_exit() PsTerminateSystemThread(STATUS_SUCCESS);
-
-	#define HZ			10000000
-	#define SEMA_UPBND	(0x7FFFFFFF)   //8192
-
-__inline static _list *get_next(_list	*list)
-{
-	return list->Flink;
-}
-
-__inline static _list	*get_list_head(_queue	*queue)
-{
-	return (&(queue->queue));
-}
-
-
-#define LIST_CONTAINOR(ptr, type, member) CONTAINING_RECORD(ptr, type, member)
-
-
-__inline static _enter_critical(_lock *plock, _irqL *pirqL)
-{
-	NdisAcquireSpinLock(plock);
-}
-
-__inline static _exit_critical(_lock *plock, _irqL *pirqL)
-{
-	NdisReleaseSpinLock(plock);
-}
-
-
-__inline static _enter_critical_ex(_lock *plock, _irqL *pirqL)
-{
-	NdisDprAcquireSpinLock(plock);
-}
-
-__inline static _exit_critical_ex(_lock *plock, _irqL *pirqL)
-{
-	NdisDprReleaseSpinLock(plock);
-}
-
-__inline static void _enter_critical_bh(_lock *plock, _irqL *pirqL)
-{
-	NdisDprAcquireSpinLock(plock);
-}
-
-__inline static void _exit_critical_bh(_lock *plock, _irqL *pirqL)
-{
-	NdisDprReleaseSpinLock(plock);
-}
-
-__inline static _enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
-{
-	KeWaitForSingleObject(pmutex, Executive, KernelMode, FALSE, NULL);
-}
-
-
-__inline static _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
-{
-	KeReleaseMutex(pmutex, FALSE);
-}
-
-
-__inline static void rtw_list_delete(_list *plist)
-{
-	RemoveEntryList(plist);
-	InitializeListHead(plist);
-}
-
-__inline static void _init_timer(_timer *ptimer,_nic_hdl nic_hdl,void *pfunc,PVOID cntx)
-{
-	NdisMInitializeTimer(ptimer, nic_hdl, pfunc, cntx);
-}
-
-__inline static void _set_timer(_timer *ptimer,u32 delay_time)
-{
-	NdisMSetTimer(ptimer,delay_time);
-}
-
-__inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
-{
-	NdisMCancelTimer(ptimer,bcancelled);
-}
-
-__inline static void _init_workitem(_workitem *pwork, void *pfunc, PVOID cntx)
-{
-
-	NdisInitializeWorkItem(pwork, pfunc, cntx);
-}
-
-__inline static void _set_workitem(_workitem *pwork)
-{
-	NdisScheduleWorkItem(pwork);
-}
-
-
-#define ATOMIC_INIT(i)  { (i) }
-
-//
-// Global Mutex: can only be used at PASSIVE level.
-//
-
-#define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
-{                                                               \
-    while (NdisInterlockedIncrement((PULONG)&(_MutexCounter)) != 1)\
-    {                                                           \
-        NdisInterlockedDecrement((PULONG)&(_MutexCounter));        \
-        NdisMSleep(10000);                          \
-    }                                                           \
-}
-
-#define RELEASE_GLOBAL_MUTEX(_MutexCounter)                              \
-{                                                               \
-    NdisInterlockedDecrement((PULONG)&(_MutexCounter));              \
-}
-
-#endif // PLATFORM_OS_XP
-
-
-#ifdef PLATFORM_OS_CE
-#include <osdep_ce_service.h>
-#endif
-
 #include <rtw_byteorder.h>
 
 #ifndef BIT
@@ -1309,9 +420,7 @@ extern void	_rtw_init_listhead(_list *li
 extern u32	rtw_is_list_empty(_list *phead);
 extern void	rtw_list_insert_head(_list *plist, _list *phead);
 extern void	rtw_list_insert_tail(_list *plist, _list *phead);
-#ifndef PLATFORM_FREEBSD
 extern void	rtw_list_delete(_list *plist);
-#endif //PLATFORM_FREEBSD
 
 extern void	_rtw_init_sema(_sema *sema, int init_val);
 extern void	_rtw_free_sema(_sema	*sema);
@@ -1319,9 +428,7 @@ extern void	_rtw_up_sema(_sema	*sema);
 extern u32	_rtw_down_sema(_sema *sema);
 extern void	_rtw_mutex_init(_mutex *pmutex);
 extern void	_rtw_mutex_free(_mutex *pmutex);
-#ifndef PLATFORM_FREEBSD
 extern void	_rtw_spinlock_init(_lock *plock);
-#endif //PLATFORM_FREEBSD
 extern void	_rtw_spinlock_free(_lock *plock);
 extern void	_rtw_spinlock(_lock	*plock);
 extern void	_rtw_spinunlock(_lock	*plock);
@@ -1360,66 +467,26 @@ extern void rtw_yield_os(void);
 
 __inline static unsigned char _cancel_timer_ex(_timer *ptimer)
 {
-#ifdef PLATFORM_LINUX
 	return del_timer_sync(ptimer);
-#endif
-#ifdef PLATFORM_FREEBSD
-	_cancel_timer(ptimer,0);
-	return 0;
-#endif
-#ifdef PLATFORM_WINDOWS
-	u8 bcancelled;
-
-	_cancel_timer(ptimer, &bcancelled);
-
-	return bcancelled;
-#endif
 }
-#ifdef PLATFORM_FREEBSD
-static __inline void thread_enter(void *context);
-#endif //PLATFORM_FREEBSD
+
 static __inline void thread_enter(char *name)
 {
-#ifdef PLATFORM_LINUX
 	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0))
 	daemonize("%s", name);
 	#endif
 	allow_signal(SIGTERM);
-#endif
-#ifdef PLATFORM_FREEBSD
-	printf("%s", "RTKTHREAD_enter");
-#endif
 }
-#ifdef PLATFORM_FREEBSD
-#define thread_exit() do{printf("%s", "RTKTHREAD_exit");}while(0)
-#endif //PLATFORM_FREEBSD
+
 __inline static void flush_signals_thread(void)
 {
-#ifdef PLATFORM_LINUX
 	if (signal_pending (current))
-	{
 		flush_signals(current);
-	}
-#endif
 }
 
 __inline static _OS_STATUS res_to_status(sint res)
 {
-
-
-#if defined (PLATFORM_LINUX) || defined (PLATFORM_MPIXEL) || defined (PLATFORM_FREEBSD)
 	return res;
-#endif
-
-#ifdef PLATFORM_WINDOWS
-
-	if (res == _SUCCESS)
-		return NDIS_STATUS_SUCCESS;
-	else
-		return NDIS_STATUS_FAILURE;
-
-#endif
-
 }
 
 #define _RND(sz, r) ((((sz)+((r)-1))/(r))*(r))
@@ -1498,20 +565,10 @@ __inline static u32 bitshift(u32 bitmask
 #endif
 
 //#ifdef __GNUC__
-#ifdef PLATFORM_LINUX
 #define STRUCT_PACKED __attribute__ ((packed))
-#else
-#define STRUCT_PACKED
-#endif
-
 
 // limitation of path length
-#ifdef PLATFORM_LINUX
 	#define PATH_LENGTH_MAX PATH_MAX
-#elif defined(PLATFORM_WINDOWS)
-	#define PATH_LENGTH_MAX MAX_PATH
-#endif
-
 
 // Suspend lock prevent system from going suspend
 #ifdef CONFIG_WAKELOCK
@@ -1527,13 +584,7 @@ extern void rtw_unlock_suspend(void);
 
 
 //Atomic integer operations
-#ifdef PLATFORM_LINUX
 	#define ATOMIC_T atomic_t
-#elif defined(PLATFORM_WINDOWS)
-	#define ATOMIC_T LONG
-#elif defined(PLATFORM_FREEBSD)
-	typedef uint32_t ATOMIC_T ;
-#endif
 
 extern void ATOMIC_SET(ATOMIC_T *v, int i);
 extern int ATOMIC_READ(ATOMIC_T *v);
@@ -1552,7 +603,6 @@ extern int rtw_retrive_from_file(char *p
 extern int rtw_store_to_file(char *path, u8* buf, u32 sz);
 
 
-#if 1 //#ifdef MEM_ALLOC_REFINE_ADAPTOR
 struct rtw_netdev_priv_indicator {
 	void *priv;
 	u32 sizeof_priv;
@@ -1560,32 +610,10 @@ struct rtw_netdev_priv_indicator {
 struct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv);
 extern struct net_device * rtw_alloc_etherdev(int sizeof_priv);
 
-#ifndef PLATFORM_FREEBSD
 #define rtw_netdev_priv(netdev) ( ((struct rtw_netdev_priv_indicator *)netdev_priv(netdev))->priv )
-#else //PLATFORM_FREEBSD
-#define rtw_netdev_priv(netdev) (((struct ifnet *)netdev)->if_softc)
-#endif //PLATFORM_FREEBSD
 
-#ifndef PLATFORM_FREEBSD
 extern void rtw_free_netdev(struct net_device * netdev);
-#else //PLATFORM_FREEBSD
-#define rtw_free_netdev(netdev) if_free((netdev))
-#endif //PLATFORM_FREEBSD
-
-#else //MEM_ALLOC_REFINE_ADAPTOR
-
-#define rtw_alloc_etherdev(sizeof_priv) alloc_etherdev((sizeof_priv))
-
-#ifndef PLATFORM_FREEBSD
-#define rtw_netdev_priv(netdev) netdev_priv((netdev))
-#define rtw_free_netdev(netdev) free_netdev((netdev))
-#else //PLATFORM_FREEBSD
-#define rtw_netdev_priv(netdev) (((struct ifnet *)netdev)->if_softc)
-#define rtw_free_netdev(netdev) if_free((netdev))
-#endif //PLATFORM_FREEBSD
-#endif
 
-#ifdef PLATFORM_LINUX
 #define NDEV_FMT "%s"
 #define NDEV_ARG(ndev) ndev->name
 #define ADPT_FMT "%s"
@@ -1594,24 +622,12 @@ extern void rtw_free_netdev(struct net_d
 #define FUNC_NDEV_ARG(ndev) __func__, ndev->name
 #define FUNC_ADPT_FMT "%s(%s)"
 #define FUNC_ADPT_ARG(adapter) __func__, adapter->pnetdev->name
-#else
-#define NDEV_FMT "%s"
-#define NDEV_ARG(ndev) ""
-#define ADPT_FMT "%s"
-#define ADPT_ARG(adapter) ""
-#define FUNC_NDEV_FMT "%s"
-#define FUNC_NDEV_ARG(ndev) __func__
-#define FUNC_ADPT_FMT "%s"
-#define FUNC_ADPT_ARG(adapter) __func__
-#endif
 
-#ifdef PLATFORM_LINUX
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
 #define rtw_signal_process(pid, sig) kill_pid(find_vpid((pid)),(sig), 1)
 #else //(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
 #define rtw_signal_process(pid, sig) kill_proc((pid), (sig), 1)
 #endif //(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
-#endif //PLATFORM_LINUX
 
 extern u64 rtw_modular64(u64 x, u64 y);
 extern u64 rtw_division64(u64 x, u64 y);
--- a/drivers/staging/rtl8192du/os_dep/mlme_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/mlme_linux.c
@@ -26,57 +26,6 @@
 #include <drv_types.h>
 #include <mlme_osdep.h>
 
-
-#ifdef RTK_DMP_PLATFORM
-void Linkup_workitem_callback(struct work_struct *work)
-{
-	struct mlme_priv *pmlmepriv = container_of(work, struct mlme_priv, Linkup_workitem);
-	_adapter *padapter = container_of(pmlmepriv, _adapter, mlmepriv);
-
-_func_enter_;
-
-	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+ Linkup_workitem_callback\n"));
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12))
-	kobject_uevent(&padapter->pnetdev->dev.kobj, KOBJ_LINKUP);
-#else
-	kobject_hotplug(&padapter->pnetdev->class_dev.kobj, KOBJ_LINKUP);
-#endif
-
-_func_exit_;
-}
-
-void Linkdown_workitem_callback(struct work_struct *work)
-{
-	struct mlme_priv *pmlmepriv = container_of(work, struct mlme_priv, Linkdown_workitem);
-	_adapter *padapter = container_of(pmlmepriv, _adapter, mlmepriv);
-
-_func_enter_;
-
-	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+ Linkdown_workitem_callback\n"));
-
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12))
-	kobject_uevent(&padapter->pnetdev->dev.kobj, KOBJ_LINKDOWN);
-#else
-	kobject_hotplug(&padapter->pnetdev->class_dev.kobj, KOBJ_LINKDOWN);
-#endif
-
-_func_exit_;
-}
-#endif
-
-
-/*
-void sitesurvey_ctrl_handler(void *FunctionContext)
-{
-	_adapter *adapter = (_adapter *)FunctionContext;
-
-	_sitesurvey_ctrl_handler(adapter);
-
-	_set_timer(&adapter->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer, 3000);
-}
-*/
-
 void rtw_join_timeout_handler (void *FunctionContext)
 {
 	_adapter *adapter = (_adapter *)FunctionContext;
@@ -122,12 +71,6 @@ void rtw_init_mlme_timer(_adapter *padap
 	#ifdef CONFIG_SET_SCAN_DENY_TIMER
 	_init_timer(&(pmlmepriv->set_scan_deny_timer), padapter->pnetdev, _rtw_set_scan_deny_timer_hdl, padapter);
 	#endif
-
-#ifdef RTK_DMP_PLATFORM
-	_init_workitem(&(pmlmepriv->Linkup_workitem), Linkup_workitem_callback, padapter);
-	_init_workitem(&(pmlmepriv->Linkdown_workitem), Linkdown_workitem_callback, padapter);
-#endif
-
 }
 
 extern void rtw_indicate_wx_assoc_event(_adapter *padapter);
@@ -148,12 +91,7 @@ _func_enter_;
 	if(adapter->pid[2] !=0)
 		rtw_signal_process(adapter->pid[2], SIGALRM);
 
-#ifdef RTK_DMP_PLATFORM
-	_set_workitem(&adapter->mlmepriv.Linkup_workitem);
-#endif
-
 _func_exit_;
-
 }
 
 extern void indicate_wx_scan_complete_event(_adapter *padapter);
@@ -234,9 +172,6 @@ _func_enter_;
 
 	rtw_indicate_wx_disassoc_event(adapter);
 
-#ifdef RTK_DMP_PLATFORM
-	_set_workitem(&adapter->mlmepriv.Linkdown_workitem);
-#endif
 	 rtw_reset_securitypriv( adapter );
 
 _func_exit_;
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -37,15 +37,6 @@
 #include <usb_ops.h>
 #include <usb_osintf.h>
 #include <usb_hal.h>
-#ifdef CONFIG_PLATFORM_RTK_DMP
-#include <asm/io.h>
-#endif
-
-#if defined (PLATFORM_LINUX) && defined (PLATFORM_WINDOWS)
-
-#error "Shall be Linux or Windows, but not both!\n"
-
-#endif
 
 #ifdef CONFIG_80211N_HT
 extern int rtw_ht_enable;
@@ -214,10 +205,6 @@ static struct specific_device_id specifi
 	{.idVendor=0x0b05, .idProduct=0x1791, .flags=SPEC_DEV_ID_DISABLE_HT},
 	{.idVendor=0x13D3, .idProduct=0x3311, .flags=SPEC_DEV_ID_DISABLE_HT},
 	{.idVendor=0x13D3, .idProduct=0x3359, .flags=SPEC_DEV_ID_DISABLE_HT},//Russian customer -Azwave (8188CE-VAU  g mode)
-#ifdef RTK_DMP_PLATFORM
-	{.idVendor=USB_VENDER_ID_REALTEK, .idProduct=0x8111, .flags=SPEC_DEV_ID_ASSIGN_IFNAME}, // Realtek 5G dongle for WiFi Display
-	{.idVendor=0x2019, .idProduct=0xAB2D, .flags=SPEC_DEV_ID_ASSIGN_IFNAME}, // PCI-Abocom 5G dongle for WiFi Display
-#endif /* RTK_DMP_PLATFORM */
 	{}
 };
 
@@ -686,17 +673,6 @@ static void process_spec_devid(const str
 		}
 #endif
 
-#ifdef RTK_DMP_PLATFORM
-		// Change the ifname to wlan10 when PC side WFD dongle plugin on DMP platform.
-		// It is used to distinguish between normal and PC-side wifi dongle/module.
-		if((pdid->idVendor==vid) && (pdid->idProduct==pid) && (flags&SPEC_DEV_ID_ASSIGN_IFNAME))
-		{
-			extern char* ifname;
-			strncpy(ifname, "wlan10", 6);
-			//DBG_871X("%s()-%d: ifname=%s, vid=%04X, pid=%04X\n", __FUNCTION__, __LINE__, ifname, vid, pid);
-		}
-#endif /* RTK_DMP_PLATFORM */
-
 	}
 }
 
@@ -1136,17 +1112,6 @@ error_exit:
 }
 #endif
 
-#ifdef CONFIG_PLATFORM_RTD2880B
-extern void rtd2885_wlan_netlink_sendMsg(char *action_string, char *name);
-#endif
-
-#ifdef CONFIG_PLATFORM_ARM_SUNxI
-#include <mach/sys_config.h>
-extern int sw_usb_disable_hcd(__u32 usbc_no);
-extern int sw_usb_enable_hcd(__u32 usbc_no);
-static int usb_wifi_host = 2;
-#endif
-
 _adapter *rtw_usb_if1_init(struct dvobj_priv *dvobj,
 	struct usb_interface *pusb_intf, const struct usb_device_id *pdid)
 {
@@ -1286,21 +1251,12 @@ _adapter *rtw_usb_if1_init(struct dvobj_
 	hostapd_mode_init(padapter);
 #endif
 
-#ifdef CONFIG_PLATFORM_RTD2880B
-	DBG_871X("wlan link up\n");
-	rtd2885_wlan_netlink_sendMsg("linkup", "8712");
-#endif
-
 	/* step 6. Tell the network stack we exist */
 	if (register_netdev(pnetdev) != 0) {
 		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("register_netdev() failed\n"));
 		goto free_hal_data;
 	}
 
-#ifdef RTK_DMP_PLATFORM
-	rtw_proc_init_one(pnetdev);
-#endif
-
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-drv_init - Adapter->bDriverStopped=%d, Adapter->bSurpriseRemoved=%d\n",padapter->bDriverStopped, padapter->bSurpriseRemoved));
 	DBG_871X("bDriverStopped:%d, bSurpriseRemoved:%d, bup:%d, hw_init_completed:%d\n"
 		,padapter->bDriverStopped
@@ -1380,12 +1336,6 @@ static void rtw_usb_if1_deinit(_adapter
 
 	if(pnetdev)
 		rtw_free_netdev(pnetdev);
-
-#ifdef CONFIG_PLATFORM_RTD2880B
-	DBG_871X("wlan link down\n");
-	rtd2885_wlan_netlink_sendMsg("linkdown", "8712");
-#endif
-
 }
 
 /*
@@ -1532,37 +1482,11 @@ extern int console_suspend_enabled;
 
 static int __init rtw_drv_entry(void)
 {
-#ifdef CONFIG_PLATFORM_RTK_DMP
-	u32 tmp;
-	tmp=readl((volatile unsigned int*)0xb801a608);
-	tmp &= 0xffffff00;
-	tmp |= 0x55;
-	writel(tmp,(volatile unsigned int*)0xb801a608);//write dummy register for 1055
-#endif
-#ifdef CONFIG_PLATFORM_ARM_SUNxI
-#ifndef CONFIG_RTL8723A
-	int ret = 0;
-	/* ----------get usb_wifi_usbc_num------------- */
-	ret = script_parser_fetch("usb_wifi_para", "usb_wifi_usbc_num", (int *)&usb_wifi_host, 64);
-	if(ret != 0){
-		printk("ERR: script_parser_fetch usb_wifi_usbc_num failed\n");
-		ret = -ENOMEM;
-		return ret;
-	}
-	printk("sw_usb_enable_hcd: usbc_num = %d\n", usb_wifi_host);
-	sw_usb_enable_hcd(usb_wifi_host);
-#endif //CONFIG_RTL8723A
-#endif //CONFIG_PLATFORM_ARM_SUNxI
-
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_drv_entry\n"));
 
 	DBG_871X(DRV_NAME " driver version=%s\n", DRIVERVERSION);
 	DBG_871X("build time: %s %s\n", __DATE__, __TIME__);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
-	//console_suspend_enabled=0;
-#endif
-
 	rtw_suspend_lock_init();
 
 	usb_drv->drv_registered = _TRUE;
@@ -1579,12 +1503,6 @@ static void __exit rtw_drv_halt(void)
 	usb_drv->drv_registered = _FALSE;
 	usb_deregister(&usb_drv->usbdrv);
 
-#ifdef CONFIG_PLATFORM_ARM_SUNxI
-#ifndef CONFIG_RTL8723A
-	printk("sw_usb_disable_hcd: usbc_num = %d\n", usb_wifi_host);
-	sw_usb_disable_hcd(usb_wifi_host);
-#endif //ifndef CONFIG_RTL8723A
-#endif	//CONFIG_PLATFORM_ARM_SUNxI
 	DBG_871X("-rtw_drv_halt\n");
 }
 

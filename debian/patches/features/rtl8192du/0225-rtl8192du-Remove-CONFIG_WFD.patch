From 0b6dcf6f36c4abffefd830fae0323c6f2abb6dba Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Thu, 20 Feb 2014 12:25:36 -0600
Subject: [PATCH 225/390] rtl8192du: Remove CONFIG_WFD

This parameter is never defined.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_ieee80211.c    |   84 ---
 core/rtw_mlme.c         |   13 -
 core/rtw_mlme_ext.c     |  241 +-------
 core/rtw_p2p.c          | 1417 +----------------------------------------------
 core/rtw_recv.c         |   22 -
 core/rtw_tdls.c         |  297 ----------
 core/rtw_wlan_util.c    |   31 --
 core/rtw_xmit.c         |    9 -
 include/autoconf.h      |    4 -
 include/drv_types.h     |    4 -
 include/ieee80211.h     |    5 -
 include/rtw_mlme.h      |  123 ++--
 include/rtw_mlme_ext.h  |    3 -
 include/rtw_p2p.h       |   15 -
 include/rtw_tdls.h      |    4 -
 os_dep/ioctl_cfg80211.c |  148 -----
 os_dep/ioctl_linux.c    |  680 +----------------------
 os_dep/os_intfs.c       |    4 -
 os_dep/rtw_android.c    |   57 --
 19 files changed, 59 insertions(+), 3102 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_ieee80211.c
+++ b/drivers/staging/rtl8192du/core/rtw_ieee80211.c
@@ -1370,89 +1370,6 @@ void rtw_wlan_bssid_ex_remove_p2p_attr(s
 
 #endif /* CONFIG_P2P */
 
-#ifdef CONFIG_WFD
-int rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen)
-{
-	int match;
-	uint cnt = 0;
-	u8 eid, wfd_oui[4] = {0x50, 0x6F, 0x9A, 0x0A};
-
-	match = false;
-
-	if (in_len < 0)
-		return match;
-	while (cnt < in_len) {
-		eid = in_ie[cnt];
-
-		if ((eid == _VENDOR_SPECIFIC_IE_) &&
-		    (_rtw_memcmp(&in_ie[cnt+2], wfd_oui, 4) == true)) {
-			if (wfd_ie != NULL) {
-				memcpy(wfd_ie, &in_ie[cnt], in_ie[cnt + 1] + 2);
-
-			} else {
-				if (wfd_ielen != NULL)
-					*wfd_ielen = 0;
-			}
-
-			if (wfd_ielen != NULL)
-				*wfd_ielen = in_ie[cnt + 1] + 2;
-
-			cnt += in_ie[cnt + 1] + 2;
-
-			match = true;
-			break;
-		} else {
-			cnt += in_ie[cnt + 1] + 2; /* goto next */
-		}
-	}
-
-	if (match == true)
-		match = cnt;
-
-	return match;
-}
-
-/*	attr_content: The output buffer, contains the "body field" of WFD attribute. */
-/*	attr_contentlen: The data length of the "body field" of WFD attribute. */
-int rtw_get_wfd_attr_content(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id, u8 *attr_content, uint *attr_contentlen)
-{
-	int match;
-	uint cnt = 0;
-	u8 attr_id, wfd_oui[4] = {0x50, 0x6F, 0x9A, 0x0A};
-
-	match = false;
-
-	if ((wfd_ie[0] != _VENDOR_SPECIFIC_IE_) ||
-	    (_rtw_memcmp(wfd_ie + 2, wfd_oui, 4) != true))
-		return match;
-
-	/*	1 (WFD IE) + 1 (Length) + 3 (OUI) + 1 (OUI Type) */
-	cnt = 6;
-	while (cnt < wfd_ielen) {
-		u16 attrlen = RTW_GET_BE16(wfd_ie + cnt + 1);
-
-		attr_id = wfd_ie[cnt];
-		if (attr_id == target_attr_id) {
-			/*	3 -> 1 byte for attribute ID field, 2 bytes for length field */
-			if (attr_content)
-				memcpy(attr_content, &wfd_ie[cnt + 3], attrlen);
-
-			if (attr_contentlen)
-				*attr_contentlen = attrlen;
-
-			cnt += attrlen + 3;
-
-			match = true;
-			break;
-		} else {
-			cnt += attrlen + 3; /* goto next */
-		}
-	}
-	return match;
-}
-#endif /*  CONFIG_WFD */
-
-/* Baron adds to avoid FreeBSD warning */
 int ieee80211_is_empty_essid(const char *essid, int essid_len)
 {
 	/* Single white space is for Linksys APs */
@@ -1465,7 +1382,6 @@ int ieee80211_is_empty_essid(const char
 		if (essid[essid_len] != '\0')
 			return 0;
 	}
-
 	return 1;
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -133,19 +133,6 @@ void rtw_free_mlme_priv_ie_data(struct m
 	rtw_free_mlme_ie_data(&pmlmepriv->p2p_assoc_req_ie,
 			      &pmlmepriv->p2p_assoc_req_ie_len);
 #endif
-
-#if defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211)
-	rtw_free_mlme_ie_data(&pmlmepriv->wfd_beacon_ie,
-			      &pmlmepriv->wfd_beacon_ie_len);
-	rtw_free_mlme_ie_data(&pmlmepriv->wfd_probe_req_ie,
-			      &pmlmepriv->wfd_probe_req_ie_len);
-	rtw_free_mlme_ie_data(&pmlmepriv->wfd_probe_resp_ie,
-			      &pmlmepriv->wfd_probe_resp_ie_len);
-	rtw_free_mlme_ie_data(&pmlmepriv->wfd_go_probe_resp_ie,
-			      &pmlmepriv->wfd_go_probe_resp_ie_len);
-	rtw_free_mlme_ie_data(&pmlmepriv->wfd_assoc_req_ie,
-			      &pmlmepriv->wfd_assoc_req_ie_len);
-#endif
 }
 
 void _rtw_free_mlme_priv(struct mlme_priv *pmlmepriv)
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -1367,10 +1367,6 @@ unsigned int OnAssocReq(struct rtw_adapt
 	u8 p2p_status_code = P2P_STATUS_SUCCESS;
 	u8 *p2pie;
 	u32 p2pielen = 0;
-#ifdef CONFIG_WFD
-	u8 wfd_ie[128] = { 0x00 };
-	u32 wfd_ielen = 0;
-#endif /*  CONFIG_WFD */
 #endif /* CONFIG_P2P */
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -1761,28 +1757,6 @@ unsigned int OnAssocReq(struct rtw_adapt
 				goto OnAssocReqFail;
 			}
 		}
-#ifdef CONFIG_WFD
-		if (rtw_get_wfd_ie
-		    (pframe + WLAN_HDR_A3_LEN + ie_offset,
-		     pkt_len - WLAN_HDR_A3_LEN - ie_offset, wfd_ie,
-		     &wfd_ielen)) {
-			u8 attr_content[10] = { 0x00 };
-			u32 attr_contentlen = 0;
-
-			DBG_8192D("[%s] WFD IE Found!!\n", __func__);
-			rtw_get_wfd_attr_content(wfd_ie, wfd_ielen,
-						 WFD_ATTR_DEVICE_INFO,
-						 attr_content,
-						 &attr_contentlen);
-			if (attr_contentlen) {
-				pwdinfo->wfd_info->peer_rtsp_ctrlport =
-				    RTW_GET_BE16(attr_content + 2);
-				DBG_8192D("[%s] Peer PORT NUM = %d\n", __func__,
-					  pwdinfo->wfd_info->
-					  peer_rtsp_ctrlport);
-			}
-		}
-#endif
 	}
 	pstat->p2p_status_code = p2p_status_code;
 #endif /* CONFIG_P2P */
@@ -1970,14 +1944,7 @@ unsigned int OnAssocRsp(struct rtw_adapt
 			if (_rtw_memcmp(pIE->data, WMM_PARA_OUI, 6)) {	/* WMM */
 				WMM_param_handler(adapt, pIE);
 			}
-#if defined(CONFIG_P2P) && defined(CONFIG_WFD)
-			else if (_rtw_memcmp(pIE->data, WFD_OUI, 4)) {	/* WFD */
-				DBG_8192D("[%s] Found WFD IE\n", __func__);
-				WFD_info_handler(adapt, pIE);
-			}
-#endif
 			break;
-
 		case _HT_CAPABILITY_IE_:	/* HT caps */
 			HT_caps_handler(adapt, pIE);
 			break;
@@ -2437,15 +2404,10 @@ void issue_p2p_GO_request(struct rtw_ada
 	u8 action = P2P_PUB_ACTION_ACTION;
 	__be32 p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_GO_NEGO_REQ;
-	u8 wpsie[255] = { 0x00 }, p2pie[255] = {
-	0x00};
+	u8 wpsie[255] = { 0x00 }, p2pie[255] = {0x00};
 	u8 wpsielen = 0, p2pielen = 0, i;
 	u8 channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
 	u16 len_channellist_attr = 0;
-#ifdef CONFIG_WFD
-	u32 wfdielen = 0;
-#endif /* CONFIG_WFD */
-
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	unsigned char *pframe;
@@ -2851,12 +2813,6 @@ void issue_p2p_GO_request(struct rtw_ada
 	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
 		       (unsigned char *)p2pie, &pattrib->pktlen);
 
-#ifdef CONFIG_WFD
-	wfdielen = build_nego_req_wfd_ie(pwdinfo, pframe);
-	pframe += wfdielen;
-	pattrib->pktlen += wfdielen;
-#endif /* CONFIG_WFD */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 	dump_mgntframe(adapt, pmgntframe);
 	return;
@@ -2889,10 +2845,6 @@ static void issue_p2p_GO_response(struct
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 
-#ifdef CONFIG_WFD
-	u32 wfdielen = 0;
-#endif /* CONFIG_WFD */
-
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
 	if (pmgntframe == NULL)
 		return;
@@ -3326,12 +3278,6 @@ static void issue_p2p_GO_response(struct
 	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
 		       (unsigned char *)p2pie, &pattrib->pktlen);
 
-#ifdef CONFIG_WFD
-	wfdielen = build_nego_resp_wfd_ie(pwdinfo, pframe);
-	pframe += wfdielen;
-	pattrib->pktlen += wfdielen;
-#endif /* CONFIG_WFD */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(adapt, pmgntframe);
@@ -3345,10 +3291,8 @@ static void issue_p2p_GO_confirm(struct
 	u8 action = P2P_PUB_ACTION_ACTION;
 	__be32 p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_GO_NEGO_CONF;
-	u8 wpsie[255] = { 0x00 }, p2pie[255] = {
-	0x00};
+	u8 wpsie[255] = {0x00}, p2pie[255] = {0x00};
 	u8 wpsielen = 0, p2pielen = 0;
-
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	unsigned char *pframe;
@@ -3358,9 +3302,6 @@ static void issue_p2p_GO_confirm(struct
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-#ifdef CONFIG_WFD
-	u32 wfdielen = 0;
-#endif /* CONFIG_WFD */
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
 	if (pmgntframe == NULL)
@@ -3536,12 +3477,6 @@ static void issue_p2p_GO_confirm(struct
 	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
 		       (unsigned char *)p2pie, &pattrib->pktlen);
 
-#ifdef CONFIG_WFD
-	wfdielen = build_nego_confirm_wfd_ie(pwdinfo, pframe);
-	pframe += wfdielen;
-	pattrib->pktlen += wfdielen;
-#endif /* CONFIG_WFD */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(adapt, pmgntframe);
@@ -3560,9 +3495,6 @@ void issue_p2p_invitation_request(struct
 	u8 dialogToken = 3;
 	u8 channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
 	u16 len_channellist_attr = 0;
-#ifdef CONFIG_WFD
-	u32 wfdielen = 0;
-#endif /* CONFIG_WFD */
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
 	struct wifidirect_info *pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
@@ -3883,12 +3815,6 @@ void issue_p2p_invitation_request(struct
 	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
 		       (unsigned char *)p2pie, &pattrib->pktlen);
 
-#ifdef CONFIG_WFD
-	wfdielen = build_invitation_req_wfd_ie(pwdinfo, pframe);
-	pframe += wfdielen;
-	pattrib->pktlen += wfdielen;
-#endif /* CONFIG_WFD */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(adapt, pmgntframe);
@@ -3913,10 +3839,6 @@ void issue_p2p_invitation_response(struc
 	struct mlme_priv *pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
 	struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 #endif
-#ifdef CONFIG_WFD
-	u32 wfdielen = 0;
-#endif /* CONFIG_WFD */
-
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	unsigned char *pframe;
@@ -4171,12 +4093,6 @@ void issue_p2p_invitation_response(struc
 	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
 		       (unsigned char *)p2pie, &pattrib->pktlen);
 
-#ifdef CONFIG_WFD
-	wfdielen = build_invitation_resp_wfd_ie(pwdinfo, pframe);
-	pframe += wfdielen;
-	pattrib->pktlen += wfdielen;
-#endif /* CONFIG_WFD */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(adapt, pmgntframe);
@@ -4195,10 +4111,6 @@ void issue_p2p_provision_request(struct
 	u8 wpsie[100] = { 0x00 };
 	u8 wpsielen = 0;
 	u32 p2pielen = 0;
-#ifdef CONFIG_WFD
-	u32 wfdielen = 0;
-#endif /* CONFIG_WFD */
-
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	unsigned char *pframe;
@@ -4289,12 +4201,6 @@ void issue_p2p_provision_request(struct
 	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen,
 		       (unsigned char *)wpsie, &pattrib->pktlen);
 
-#ifdef CONFIG_WFD
-	wfdielen = build_provdisc_req_wfd_ie(pwdinfo, pframe);
-	pframe += wfdielen;
-	pattrib->pktlen += wfdielen;
-#endif /* CONFIG_WFD */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(adapt, pmgntframe);
@@ -4344,9 +4250,6 @@ void issue_probersp_p2p(struct rtw_adapt
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 	u8 wpsie[255] = { 0x00 };
 	u32 wpsielen = 0, p2pielen = 0;
-#ifdef CONFIG_WFD
-	u32 wfdielen = 0;
-#endif /* CONFIG_WFD */
 #ifdef CONFIG_IOCTL_CFG80211
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo =
 	    &adapt->cfg80211_wdinfo;
@@ -4667,28 +4570,6 @@ void issue_probersp_p2p(struct rtw_adapt
 		pframe += p2pielen;
 		pattrib->pktlen += p2pielen;
 	}
-
-#ifdef CONFIG_WFD
-#ifdef CONFIG_IOCTL_CFG80211
-	if (true == pwdinfo->wfd_info->wfd_enable)
-#endif /* CONFIG_IOCTL_CFG80211 */
-	{
-		wfdielen = build_probe_resp_wfd_ie(pwdinfo, pframe, 0);
-		pframe += wfdielen;
-		pattrib->pktlen += wfdielen;
-	}
-#ifdef CONFIG_IOCTL_CFG80211
-	else if (pmlmepriv->wfd_probe_resp_ie != NULL &&
-		 pmlmepriv->wfd_probe_resp_ie_len > 0) {
-		/* WFD IE */
-		memcpy(pframe, pmlmepriv->wfd_probe_resp_ie,
-		       pmlmepriv->wfd_probe_resp_ie_len);
-		pattrib->pktlen += pmlmepriv->wfd_probe_resp_ie_len;
-		pframe += pmlmepriv->wfd_probe_resp_ie_len;
-	}
-#endif /* CONFIG_IOCTL_CFG80211 */
-#endif /* CONFIG_WFD */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(adapt, pmgntframe);
@@ -4712,13 +4593,8 @@ static int _issue_probereq_p2p(struct rt
 	int bssrate_len = 0;
 	u8 bc_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-	u8 wpsie[255] = { 0x00 }, p2pie[255] = {
-	0x00};
+	u8 wpsie[255] = {0x00}, p2pie[255] = {0x00};
 	u16 wpsielen = 0, p2pielen = 0;
-#ifdef CONFIG_WFD
-	u32 wfdielen = 0;
-#endif /* CONFIG_WFD */
-
 	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
@@ -5023,27 +4899,6 @@ static int _issue_probereq_p2p(struct rt
 		}
 	}
 
-#ifdef CONFIG_WFD
-#ifdef CONFIG_IOCTL_CFG80211
-	if (true == pwdinfo->wfd_info->wfd_enable)
-#endif
-	{
-		wfdielen = build_probe_req_wfd_ie(pwdinfo, pframe);
-		pframe += wfdielen;
-		pattrib->pktlen += wfdielen;
-	}
-#ifdef CONFIG_IOCTL_CFG80211
-	else if (pmlmepriv->wfd_probe_req_ie != NULL &&
-		 pmlmepriv->wfd_probe_req_ie_len > 0) {
-		/* WFD IE */
-		memcpy(pframe, pmlmepriv->wfd_probe_req_ie,
-		       pmlmepriv->wfd_probe_req_ie_len);
-		pattrib->pktlen += pmlmepriv->wfd_probe_req_ie_len;
-		pframe += pmlmepriv->wfd_probe_req_ie_len;
-	}
-#endif /* CONFIG_IOCTL_CFG80211 */
-#endif /* CONFIG_WFD */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
@@ -6311,27 +6166,6 @@ void issue_beacon(struct rtw_adapter *ad
 
 			pframe += len;
 			pattrib->pktlen += len;
-#ifdef CONFIG_WFD
-#ifdef CONFIG_IOCTL_CFG80211
-			if (true == pwdinfo->wfd_info->wfd_enable)
-#endif /* CONFIG_IOCTL_CFG80211 */
-			{
-				len = build_beacon_wfd_ie(pwdinfo, pframe);
-			}
-#ifdef CONFIG_IOCTL_CFG80211
-			else {
-				len = 0;
-				if (pmlmepriv->wfd_beacon_ie &&
-				    pmlmepriv->wfd_beacon_ie_len > 0) {
-					len = pmlmepriv->wfd_beacon_ie_len;
-					memcpy(pframe, pmlmepriv->wfd_beacon_ie,
-					       len);
-				}
-			}
-#endif /* CONFIG_IOCTL_CFG80211 */
-			pframe += len;
-			pattrib->pktlen += len;
-#endif /* CONFIG_WFD */
 		}
 #endif /* CONFIG_P2P */
 		goto _issue_bcn;
@@ -6448,9 +6282,6 @@ void issue_probersp(struct rtw_adapter *
 	unsigned int rate_len;
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-#ifdef CONFIG_WFD
-	u32 wfdielen = 0;
-#endif /* CONFIG_WFD */
 #endif /* CONFIG_P2P */
 
 	/* DBG_8192D("%s\n", __func__); */
@@ -6668,28 +6499,6 @@ void issue_probersp(struct rtw_adapter *
 
 		pframe += len;
 		pattrib->pktlen += len;
-
-#ifdef CONFIG_WFD
-#ifdef CONFIG_IOCTL_CFG80211
-		if (true == pwdinfo->wfd_info->wfd_enable)
-#endif /* CONFIG_IOCTL_CFG80211 */
-		{
-			len = build_probe_resp_wfd_ie(pwdinfo, pframe, 0);
-		}
-#ifdef CONFIG_IOCTL_CFG80211
-		else {
-			len = 0;
-			if (pmlmepriv->wfd_probe_resp_ie &&
-			    pmlmepriv->wfd_probe_resp_ie_len > 0) {
-				len = pmlmepriv->wfd_probe_resp_ie_len;
-				memcpy(pframe, pmlmepriv->wfd_probe_resp_ie,
-				       len);
-			}
-		}
-#endif /* CONFIG_IOCTL_CFG80211 */
-		pframe += len;
-		pattrib->pktlen += len;
-#endif /* CONFIG_WFD */
 	}
 #endif /* CONFIG_P2P */
 
@@ -7047,9 +6856,6 @@ void issue_asocrsp(struct rtw_adapter *a
 	__le16 leval, lestatus;
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-#ifdef CONFIG_WFD
-	u32 wfdielen = 0;
-#endif /* CONFIG_WFD */
 #endif /* CONFIG_P2P */
 
 	DBG_8192D("%s\n", __func__);
@@ -7197,17 +7003,6 @@ void issue_asocrsp(struct rtw_adapter *a
 		pattrib->pktlen += len;
 	}
 #endif /* CONFIG_IOCTL_CFG80211 */
-#ifdef CONFIG_WFD
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)
-#ifdef CONFIG_IOCTL_CFG80211
-	    && (true == pwdinfo->wfd_info->wfd_enable)
-#endif /* CONFIG_IOCTL_CFG80211 */
-	   ) {
-		wfdielen = build_assoc_resp_wfd_ie(pwdinfo, pframe);
-		pframe += wfdielen;
-		pattrib->pktlen += wfdielen;
-	}
-#endif /* CONFIG_WFD */
 #endif /* CONFIG_P2P */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
@@ -7241,9 +7036,6 @@ void issue_assocreq(struct rtw_adapter *
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 	u8 p2pie[255] = { 0x00 };
 	u16 p2pielen = 0;
-#ifdef CONFIG_WFD
-	u32 wfdielen = 0;
-#endif /* CONFIG_WFD */
 #endif /* CONFIG_P2P */
 
 #ifdef CONFIG_DFS
@@ -7691,38 +7483,11 @@ void issue_assocreq(struct rtw_adapter *
 			    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
 				       (unsigned char *)p2pie,
 				       &pattrib->pktlen);
-
-#ifdef CONFIG_WFD
-			/* wfdielen = build_assoc_req_wfd_ie(pwdinfo, pframe); */
-			/*pframe += wfdielen; */
-			/*pattrib->pktlen += wfdielen; */
-#endif /* CONFIG_WFD */
 		}
 	}
 
 #endif /* CONFIG_P2P */
 
-#ifdef CONFIG_WFD
-#ifdef CONFIG_IOCTL_CFG80211
-	if (true == pwdinfo->wfd_info->wfd_enable)
-#endif /* CONFIG_IOCTL_CFG80211 */
-	{
-		wfdielen = build_assoc_req_wfd_ie(pwdinfo, pframe);
-		pframe += wfdielen;
-		pattrib->pktlen += wfdielen;
-	}
-#ifdef CONFIG_IOCTL_CFG80211
-	else if (pmlmepriv->wfd_assoc_req_ie != NULL &&
-		 pmlmepriv->wfd_assoc_req_ie_len > 0) {
-		/* WFD IE */
-		memcpy(pframe, pmlmepriv->wfd_assoc_req_ie,
-		       pmlmepriv->wfd_assoc_req_ie_len);
-		pattrib->pktlen += pmlmepriv->wfd_assoc_req_ie_len;
-		pframe += pmlmepriv->wfd_assoc_req_ie_len;
-	}
-#endif /* CONFIG_IOCTL_CFG80211 */
-#endif /* CONFIG_WFD */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 	dump_mgntframe(adapt, pmgntframe);
 
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -284,10 +284,6 @@ static void issue_p2p_provision_resp(str
 	u8 oui_subtype = P2P_PROVISION_DISC_RESP;
 	u8 wpsie[100] = { 0x00 };
 	u8 wpsielen = 0;
-#ifdef CONFIG_WFD
-	u32					wfdielen = 0;
-#endif /* CONFIG_WFD */
-
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
 	unsigned char					*pframe;
@@ -350,12 +346,6 @@ static void issue_p2p_provision_resp(str
 
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *)wpsie, &pattrib->pktlen);
 
-#ifdef CONFIG_WFD
-	wfdielen = build_provdisc_resp_wfd_ie(pwdinfo, pframe);
-	pframe += wfdielen;
-	pattrib->pktlen += wfdielen;
-#endif /* CONFIG_WFD */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(padapter, pmgntframe);
@@ -492,1233 +482,6 @@ u32 build_beacon_p2p_ie(struct wifidirec
 	return len;
 }
 
-#ifdef CONFIG_WFD
-u32 build_beacon_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
-	u32 len = 0, wfdielen = 0;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct wifi_display_info *pwfd_info = padapter->wdinfo.wfd_info;
-
-	/*	WFD OUI */
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110812 */
-	/*	According to the WFD Specification, the beacon frame should contain 4 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID */
-	/*	3. Coupled Sink Information */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-
-	if (P2P_ROLE_GO == pwdinfo->role) {
-		if (is_any_client_associated(pwdinfo->padapter)) {
-			/*	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) */
-			RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD);
-		} else {
-			/*	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
-			RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
-		}
-
-	} else {
-		/*	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
-		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
-	}
-
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	wfdielen += ETH_ALEN;
-
-	/*	Coupled Sink Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Coupled Sink Status bitmap */
-	/*	Not coupled/available for Coupling */
-	wfdie[wfdielen++] = 0;
-	/*   MAC Addr. */
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
-
-	return len;
-}
-
-u32 build_probe_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
-	u32 len = 0, wfdielen = 0;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct wifi_display_info *pwfd_info = padapter->wdinfo.wfd_info;
-
-	/*	WFD OUI */
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110812 */
-	/*	According to the WFD Specification, the probe request frame should contain 4 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID */
-	/*	3. Coupled Sink Information */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-
-	if (1 == pwdinfo->wfd_tdls_enable) {
-		/*	WFD primary sink + available for WFD session + WiFi TDLS mode + WSC (WFD Service Discovery) */
-		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type |
-						WFD_DEVINFO_SESSION_AVAIL |
-						WFD_DEVINFO_WSD |
-						WFD_DEVINFO_PC_TDLS);
-	} else {
-		/*	WFD primary sink + available for WFD session + WiFi Direct mode + WSC (WFD Service Discovery) */
-		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type |
-						WFD_DEVINFO_SESSION_AVAIL |
-						WFD_DEVINFO_WSD);
-	}
-
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	wfdielen += ETH_ALEN;
-
-	/*	Coupled Sink Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Coupled Sink Status bitmap */
-	/*	Not coupled/available for Coupling */
-	wfdie[wfdielen++] = 0;
-	/*   MAC Addr. */
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
-
-	return len;
-}
-
-u32 build_probe_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 tunneled)
-{
-	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
-	u32 len = 0, wfdielen = 0;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct wifi_display_info *pwfd_info = padapter->wdinfo.wfd_info;
-
-	/*	WFD OUI */
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110812 */
-	/*	According to the WFD Specification, the probe response frame should contain 4 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID */
-	/*	3. Coupled Sink Information */
-	/*	4. WFD Session Information */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-	/*	WFD primary sink + available for WFD session + WiFi Direct mode */
-
-	if (true == pwdinfo->session_available) {
-		if (P2P_ROLE_GO == pwdinfo->role) {
-			if (is_any_client_associated(pwdinfo->padapter)) {
-				if (pwdinfo->wfd_tdls_enable) {
-					/*	WFD primary sink + TDLS mode + WSD (WFD Service Discovery) */
-					RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_WSD | WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_HDCP_SUPPORT);
-				} else {
-					/*	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) */
-					RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_WSD | WFD_DEVINFO_HDCP_SUPPORT);
-				}
-			} else {
-				if (pwdinfo->wfd_tdls_enable) {
-					/*	WFD primary sink + available for WFD session + TDLS mode + WSD (WFD Service Discovery) */
-					RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_HDCP_SUPPORT);
-				} else {
-					/*	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
-					RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_HDCP_SUPPORT);
-				}
-			}
-		} else {
-			if (pwdinfo->wfd_tdls_enable) {
-				/*	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
-				RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_HDCP_SUPPORT);
-			} else {
-				/*	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
-				RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_HDCP_SUPPORT);
-			}
-		}
-	} else {
-		if (pwdinfo->wfd_tdls_enable)
-			RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK |
-				     WFD_DEVINFO_WSD | WFD_DEVINFO_PC_TDLS |
-				     WFD_DEVINFO_HDCP_SUPPORT);
-		else
-			RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK |
-				     WFD_DEVINFO_WSD | WFD_DEVINFO_HDCP_SUPPORT);
-	}
-
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	wfdielen += ETH_ALEN;
-
-	/*	Coupled Sink Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Coupled Sink Status bitmap */
-	/*	Not coupled/available for Coupling */
-	wfdie[wfdielen++] = 0;
-	/*   MAC Addr. */
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-
-	if (P2P_ROLE_GO == pwdinfo->role) {
-		/*	WFD Session Information ATTR */
-		/*	Type: */
-		wfdie[wfdielen++] = WFD_ATTR_SESSION_INFO;
-
-		/*	Length: */
-		/*	Note: In the WFD specification, the size of length field is 2. */
-		RTW_PUT_BE16(wfdie + wfdielen, 0x0000);
-		wfdielen += 2;
-
-		/*	Todo: to add the list of WFD device info descriptor in WFD group. */
-	}
-#ifdef CONFIG_CONCURRENT_MODE
-#ifdef CONFIG_TDLS
-	if ((tunneled == 0) && (padapter->pbuddy_adapter->wdinfo.wfd_tdls_enable == 1)) {
-		/*	Alternative MAC Address ATTR */
-		/*	Type: */
-		wfdie[wfdielen++] = WFD_ATTR_ALTER_MAC;
-
-		/*	Length: */
-		/*	Note: In the WFD specification, the size of length field is 2. */
-		RTW_PUT_BE16(wfdie + wfdielen,  ETH_ALEN);
-		wfdielen += 2;
-
-		/*	Value: */
-		/*	Alternative MAC Address */
-		memcpy(wfdie + wfdielen, &padapter->pbuddy_adapter->eeprompriv.mac_addr[0], ETH_ALEN);
-		/*	This mac address is used to make the WFD session when TDLS is enable. */
-
-		wfdielen += ETH_ALEN;
-	}
-#endif /*  CONFIG_TDLS */
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
-
-	return len;
-}
-
-u32 build_assoc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
-	u32 len = 0, wfdielen = 0;
-	struct rtw_adapter					*padapter = NULL;
-	struct mlme_priv			*pmlmepriv = NULL;
-	struct wifi_display_info		*pwfd_info = NULL;
-
-	/*	WFD OUI */
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
-		return 0;
-
-	padapter = pwdinfo->padapter;
-	pmlmepriv = &padapter->mlmepriv;
-	pwfd_info = padapter->wdinfo.wfd_info;
-
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110812 */
-	/*	According to the WFD Specification, the probe request frame should contain 4 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID */
-	/*	3. Coupled Sink Information */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-	/*	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	wfdielen += ETH_ALEN;
-
-	/*	Coupled Sink Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Coupled Sink Status bitmap */
-	/*	Not coupled/available for Coupling */
-	wfdie[wfdielen++] = 0;
-	/*   MAC Addr. */
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
-
-	return len;
-}
-
-u32 build_assoc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 wfdie[MAX_WFD_IE_LEN] = {0x00};
-	u32 len = 0, wfdielen = 0;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct wifi_display_info *pwfd_info = padapter->wdinfo.wfd_info;
-
-	/*	WFD OUI */
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110812 */
-	/*	According to the WFD Specification, the probe request frame should contain 4 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID */
-	/*	3. Coupled Sink Information */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-	/*	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	wfdielen += ETH_ALEN;
-
-	/*	Coupled Sink Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Coupled Sink Status bitmap */
-	/*	Not coupled/available for Coupling */
-	wfdie[wfdielen++] = 0;
-	/*   MAC Addr. */
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
-
-	return len;
-}
-
-u32 build_nego_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
-	u32 len = 0, wfdielen = 0;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct wifi_display_info *pwfd_info = padapter->wdinfo.wfd_info;
-
-	/*	WFD OUI */
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110825 */
-	/*	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID (Optional) */
-	/*	3. Local IP Adress (Optional) */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-	/*	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) + WFD Session Available */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD | WFD_DEVINFO_SESSION_AVAIL);
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	wfdielen += ETH_ALEN;
-
-	/*	Coupled Sink Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Coupled Sink Status bitmap */
-	/*	Not coupled/available for Coupling */
-	wfdie[wfdielen++] = 0;
-	/*   MAC Addr. */
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
-
-	return len;
-}
-
-u32 build_nego_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
-	u32 len = 0, wfdielen = 0;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct wifi_display_info *pwfd_info = padapter->wdinfo.wfd_info;
-
-	/*	WFD OUI */
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110825 */
-	/*	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID (Optional) */
-	/*	3. Local IP Adress (Optional) */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-	/*	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) + WFD Session Available */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD | WFD_DEVINFO_SESSION_AVAIL);
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	wfdielen += ETH_ALEN;
-
-	/*	Coupled Sink Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Coupled Sink Status bitmap */
-	/*	Not coupled/available for Coupling */
-	wfdie[wfdielen++] = 0;
-	/*   MAC Addr. */
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
-
-	return len;
-}
-
-u32 build_nego_confirm_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 wfdie[MAX_WFD_IE_LEN] = {0x00};
-	u32 len = 0, wfdielen = 0;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct wifi_display_info *pwfd_info = padapter->wdinfo.wfd_info;
-
-	/*	WFD OUI */
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110825 */
-	/*	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID (Optional) */
-	/*	3. Local IP Adress (Optional) */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-	/*	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) + WFD Session Available */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD | WFD_DEVINFO_SESSION_AVAIL);
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	wfdielen += ETH_ALEN;
-
-	/*	Coupled Sink Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Coupled Sink Status bitmap */
-	/*	Not coupled/available for Coupling */
-	wfdie[wfdielen++] = 0;
-	/*   MAC Addr. */
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
-	return len;
-}
-
-u32 build_invitation_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
-	u32 len = 0, wfdielen = 0;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct wifi_display_info *pwfd_info = padapter->wdinfo.wfd_info;
-
-	/*	WFD OUI */
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110825 */
-	/*	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID (Optional) */
-	/*	3. Local IP Adress (Optional) */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-	/*	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	wfdielen += ETH_ALEN;
-
-	/*	Coupled Sink Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Coupled Sink Status bitmap */
-	/*	Not coupled/available for Coupling */
-	wfdie[wfdielen++] = 0;
-	/*   MAC Addr. */
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-
-	if (P2P_ROLE_GO == pwdinfo->role) {
-		/*	WFD Session Information ATTR */
-		/*	Type: */
-		wfdie[wfdielen++] = WFD_ATTR_SESSION_INFO;
-
-		/*	Length: */
-		/*	Note: In the WFD specification, the size of length field is 2. */
-		RTW_PUT_BE16(wfdie + wfdielen, 0x0000);
-		wfdielen += 2;
-
-		/*	Todo: to add the list of WFD device info descriptor in WFD group. */
-	}
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
-	return len;
-}
-
-u32 build_invitation_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 wfdie[MAX_WFD_IE_LEN] = {0x00};
-	u32 len = 0, wfdielen = 0;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct wifi_display_info *pwfd_info = padapter->wdinfo.wfd_info;
-
-	/*	WFD OUI */
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110825 */
-	/*	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID (Optional) */
-	/*	3. Local IP Adress (Optional) */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-	/*	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	wfdielen += ETH_ALEN;
-
-	/*	Coupled Sink Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Coupled Sink Status bitmap */
-	/*	Not coupled/available for Coupling */
-	wfdie[wfdielen++] = 0;
-	/*   MAC Addr. */
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-
-	if (P2P_ROLE_GO == pwdinfo->role) {
-		/*	WFD Session Information ATTR */
-		/*	Type: */
-		wfdie[wfdielen++] = WFD_ATTR_SESSION_INFO;
-
-		/*	Length: */
-		/*	Note: In the WFD specification, the size of length field is 2. */
-		RTW_PUT_BE16(wfdie + wfdielen, 0x0000);
-		wfdielen += 2;
-		/*	Todo: to add the list of WFD device info descriptor in WFD group. */
-	}
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
-	return len;
-}
-
-u32 build_provdisc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
-	u32 len = 0, wfdielen = 0;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct wifi_display_info *pwfd_info = padapter->wdinfo.wfd_info;
-
-	/*	WFD OUI */
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110825 */
-	/*	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID (Optional) */
-	/*	3. Local IP Adress (Optional) */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-	/*	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	wfdielen += ETH_ALEN;
-
-	/*	Coupled Sink Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Coupled Sink Status bitmap */
-	/*	Not coupled/available for Coupling */
-	wfdie[wfdielen++] = 0;
-	/*   MAC Addr. */
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
-	return len;
-}
-
-u32 build_provdisc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
-	u32 len = 0, wfdielen = 0;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct wifi_display_info *pwfd_info = padapter->wdinfo.wfd_info;
-
-	/*	WFD OUI */
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110825 */
-	/*	According to the WFD Specification, the provision discovery response frame should contain 3 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID (Optional) */
-	/*	3. Local IP Adress (Optional) */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-	/*	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	wfdielen += ETH_ALEN;
-
-	/*	Coupled Sink Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_COUPLED_SINK_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Coupled Sink Status bitmap */
-	/*	Not coupled/available for Coupling */
-	wfdie[wfdielen++] = 0;
-	/*   MAC Addr. */
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	wfdie[wfdielen++] = 0;
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *)wfdie, &len);
-	return len;
-}
-
-#endif /* CONFIG_WFD */
-
 u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
 	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
@@ -2352,13 +1115,6 @@ u8 process_p2p_group_negotation_req(stru
 	u16		wps_devicepassword_id = 0x0000;
 	uint	wps_devicepassword_id_len = 0;
 	__be16 be_tmp;
-#ifdef CONFIG_WFD
-	u8 wfd_ie[128] = { 0x00 };
-	u32	wfd_ielen = 0;
-#ifdef CONFIG_TDLS
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-#endif /*  CONFIG_TDLS */
-#endif /*  CONFIG_WFD */
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter				*pbuddy_adapter = pwdinfo->padapter->pbuddy_adapter;
 	struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
@@ -2421,15 +1177,9 @@ u8 process_p2p_group_negotation_req(stru
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);
 
 		/* Check P2P Capability ATTR */
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&le_tmp, (uint *)&attr_contentlen)) {
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&le_tmp, (uint *)&attr_contentlen))
 			cap_attr = le16_to_cpu(le_tmp);
 
-#if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
-			if (!(cap_attr & P2P_GRPCAP_INTRABSS))
-				ptdlsinfo->ap_prohibited = true;
-#endif /* defined(CONFIG_WFD) && defined(CONFIG_TDLS) */
-		}
-
 		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT, &attr_content, &attr_contentlen)) {
 			DBG_8192D("[%s] GO Intent = %d, tie = %d\n", __func__, attr_content >> 1, attr_content & 0x01);
 			pwdinfo->peer_intent = attr_content;	/*	include both intent and tie breaker values. */
@@ -2511,23 +1261,6 @@ u8 process_p2p_group_negotation_req(stru
 		/* Get the next P2P IE */
 		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len - (p2p_ie - ies + p2p_ielen), NULL, &p2p_ielen);
 	}
-
-#ifdef CONFIG_WFD
-	/*	Added by Albert 20110823 */
-	/*	Try to get the TCP port information when receiving the negotiation request. */
-	if (rtw_get_wfd_ie(pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wfd_ie, &wfd_ielen)) {
-		u8 attr_content[10] = {0x00};
-		u32	attr_contentlen = 0;
-
-		DBG_8192D("[%s] WFD IE Found!!\n", __func__);
-		rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
-		if (attr_contentlen) {
-			pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16(attr_content + 2);
-			DBG_8192D("[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
-		}
-	}
-#endif /*  CONFIG_WFD */
-
 	return result;
 }
 
@@ -2539,13 +1272,6 @@ u8 process_p2p_group_negotation_resp(str
 	u8 *ies;
 	u32 ies_len;
 	u8 *p2p_ie;
-#ifdef CONFIG_WFD
-	u8 wfd_ie[128] = { 0x00 };
-	u32	wfd_ielen = 0;
-#ifdef CONFIG_TDLS
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-#endif /*  CONFIG_TDLS */
-#endif /*  CONFIG_WFD */
 
 	ies = pframe + _PUBLIC_ACTION_IE_OFFSET_;
 	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
@@ -2581,13 +1307,8 @@ u8 process_p2p_group_negotation_resp(str
 
 		while (p2p_ie) {
 			/* Check P2P Capability ATTR */
-			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&le_tmp, (uint *)&attr_contentlen)) {
+			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&le_tmp, (uint *)&attr_contentlen))
 				cap_attr = le16_to_cpu(le_tmp);
-#if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
-			if (!(cap_attr & P2P_GRPCAP_INTRABSS))
-				ptdlsinfo->ap_prohibited = true;
-#endif /* defined(CONFIG_WFD) && defined(CONFIG_TDLS) */
-			}
 
 			rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, &attr_content, &attr_contentlen);
 			if (attr_contentlen == 1) {
@@ -2721,23 +1442,6 @@ u8 process_p2p_group_negotation_resp(str
 			p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len - (p2p_ie - ies + p2p_ielen), NULL, &p2p_ielen);
 		}
 	}
-
-#ifdef CONFIG_WFD
-	/*	Added by Albert 20111122 */
-	/*	Try to get the TCP port information when receiving the negotiation response. */
-	if (rtw_get_wfd_ie(pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wfd_ie, &wfd_ielen)) {
-		u8 attr_content[10] = { 0x00 };
-		u32	attr_contentlen = 0;
-
-		DBG_8192D("[%s] WFD IE Found!!\n", __func__);
-		rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
-		if (attr_contentlen) {
-			pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16(attr_content + 2);
-			DBG_8192D("[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
-		}
-	}
-#endif /*  CONFIG_WFD */
-
 	return result;
 }
 
@@ -3127,91 +1831,6 @@ static void rtw_cfg80211_adjust_p2pie_ch
 #endif
 }
 
-#ifdef CONFIG_WFD
-void rtw_append_wfd_ie(struct rtw_adapter *padapter, u8 *buf, u32 *len)
-{
-	unsigned char	*frame_body;
-	u8 category, action, OUI_Subtype, dialogToken = 0;
-	u32	wfdielen = 0;
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
-
-	frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));
-	category = frame_body[0];
-
-	if (category == RTW_WLAN_CATEGORY_PUBLIC) {
-		action = frame_body[1];
-		if (action == ACT_PUBLIC_VENDOR &&
-		    _rtw_memcmp(frame_body+2, P2P_OUI, 4) == true) {
-			OUI_Subtype = frame_body[6];
-			dialogToken = frame_body[7];
-			switch (OUI_Subtype) {
-			case P2P_GO_NEGO_REQ:
-				wfdielen = build_nego_req_wfd_ie(&padapter->wdinfo, buf + (*len));
-				(*len) += wfdielen;
-				break;
-			case P2P_GO_NEGO_RESP:
-				wfdielen = build_nego_resp_wfd_ie(&padapter->wdinfo, buf + (*len));
-				(*len) += wfdielen;
-				break;
-			case P2P_GO_NEGO_CONF:
-				wfdielen = build_nego_confirm_wfd_ie(&padapter->wdinfo, buf + (*len));
-				(*len) += wfdielen;
-				break;
-			case P2P_INVIT_REQ:
-				wfdielen = build_invitation_req_wfd_ie(&padapter->wdinfo, buf + (*len));
-				(*len) += wfdielen;
-				break;
-			case P2P_INVIT_RESP:
-				wfdielen = build_invitation_resp_wfd_ie(&padapter->wdinfo, buf + (*len));
-				(*len) += wfdielen;
-				break;
-			case P2P_DEVDISC_REQ:
-				break;
-			case P2P_DEVDISC_RESP:
-				break;
-			case P2P_PROVISION_DISC_REQ:
-				wfdielen = build_provdisc_req_wfd_ie(&padapter->wdinfo, buf + (*len));
-				(*len) += wfdielen;
-				break;
-			case P2P_PROVISION_DISC_RESP:
-				wfdielen = build_provdisc_resp_wfd_ie(&padapter->wdinfo, buf + (*len));
-				(*len) += wfdielen;
-				break;
-			default:
-				break;
-			}
-		}
-	} else if (category == RTW_WLAN_CATEGORY_P2P) {
-		OUI_Subtype = frame_body[5];
-		dialogToken = frame_body[6];
-
-#ifdef CONFIG_DEBUG_CFG80211
-		DBG_8192D("ACTION_CATEGORY_P2P: OUI = 0x%x, OUI_Subtype =%d, dialogToken =%d\n",
-			  cpu_to_be32(*((u32 *)(frame_body + 1))), OUI_Subtype, dialogToken);
-#endif
-
-		switch (OUI_Subtype) {
-		case P2P_NOTICE_OF_ABSENCE:
-			break;
-		case P2P_PRESENCE_REQUEST:
-			break;
-		case P2P_PRESENCE_RESPONSE:
-			break;
-		case P2P_GO_DISC_REQUEST:
-			break;
-		default:
-			break;
-		}
-	} else {
-		DBG_8192D("%s, action frame category =%d\n",
-			  __func__, category);
-		/* is_p2p_frame = (-1); */
-	}
-
-	return;
-}
-#endif
-
 int rtw_p2p_check_frames(struct rtw_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 {
 	int is_p2p_frame = (-1);
@@ -3808,30 +2427,6 @@ void reset_global_wifidirect_info(struct
 	pwdinfo->wfd_tdls_weaksec = 0;
 }
 
-#ifdef CONFIG_WFD
-int rtw_init_wifi_display_info(struct rtw_adapter *padapter)
-{
-	int	res = _SUCCESS;
-	struct wifi_display_info *pwfd_info = &padapter->wfd_info;
-
-	/*  Used in P2P and TDLS */
-	pwfd_info->rtsp_ctrlport = 554;
-	pwfd_info->peer_rtsp_ctrlport = 0;	/*	Reset to 0 */
-	pwfd_info->wfd_enable = false;
-	pwfd_info->wfd_device_type = WFD_DEVINFO_PSINK;
-	pwfd_info->scan_result_type = SCAN_RESULT_P2P_ONLY;
-
-	/*  Used in P2P */
-	pwfd_info->peer_session_avail = true;
-	pwfd_info->wfd_pc = false;
-
-	/*  Used in TDLS */
-	memset(pwfd_info->ip_address, 0x00, 4);
-	memset(pwfd_info->peer_ip_address, 0x00, 4);
-	return res;
-}
-#endif /* CONFIG_WFD */
-
 void rtw_init_wifidirect_timers(struct rtw_adapter *padapter)
 {
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
@@ -3861,9 +2456,6 @@ void rtw_init_wifidirect_addrs(struct rt
 void init_wifidirect_info(struct rtw_adapter *padapter, enum P2P_ROLE role)
 {
 	struct wifidirect_info	*pwdinfo;
-#ifdef CONFIG_WFD
-	struct wifi_display_info	*pwfd_info = &padapter->wfd_info;
-#endif
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_ext_priv	*pbuddy_mlmeext;
@@ -3960,12 +2552,7 @@ void init_wifidirect_info(struct rtw_ada
 	pwdinfo->nego_ssidlen = 0;
 
 	pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
-#ifdef CONFIG_WFD
-	pwdinfo->supported_wps_cm = WPS_CONFIG_METHOD_DISPLAY  | WPS_CONFIG_METHOD_PBC;
-	pwdinfo->wfd_info = pwfd_info;
-#else
 	pwdinfo->supported_wps_cm = WPS_CONFIG_METHOD_DISPLAY | WPS_CONFIG_METHOD_PBC | WPS_CONFIG_METHOD_KEYPAD;
-#endif /* CONFIG_WFD */
 	pwdinfo->channel_list_attr_len = 0;
 	memset(pwdinfo->channel_list_attr, 0x00, 100);
 
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -846,9 +846,6 @@ int OnTDLS(struct rtw_adapter *adapter,
 	int ret = _SUCCESS;
 	u8 *paction = get_recvframe_data(precv_frame);
 	u8 category_field = 1;
-#ifdef CONFIG_WFD
-	u8 WFA_OUI[3] = { 0x50, 0x6f, 0x9a };
-#endif /* CONFIG_WFD */
 	struct tdls_info *ptdlsinfo = &(adapter->tdlsinfo);
 
 	/* point to action field */
@@ -895,25 +892,6 @@ int OnTDLS(struct rtw_adapter *adapter,
 		DBG_8192D("recv tdls channel switch response frame\n");
 		ret = On_TDLS_Ch_Switch_Rsp(adapter, precv_frame);
 		break;
-#ifdef CONFIG_WFD
-	case 0x50:		/* First byte of WFA OUI */
-		if (_rtw_memcmp(WFA_OUI, (paction), 3)) {
-			if (*(paction + 3) == 0x04) {	/* Probe request frame */
-				/* WFDTDLS: for sigma test, do not setup direct link automatically */
-				ptdlsinfo->dev_discovered = 1;
-				DBG_8192D
-				    ("recv tunneled probe request frame\n");
-				issue_tunneled_probe_rsp(adapter, precv_frame);
-			}
-			if (*(paction + 3) == 0x05) {	/* Probe response frame */
-				/* WFDTDLS: for sigma test, do not setup direct link automatically */
-				ptdlsinfo->dev_discovered = 1;
-				DBG_8192D
-				    ("recv tunneled probe response frame\n");
-			}
-		}
-		break;
-#endif /* CONFIG_WFD */
 	default:
 		DBG_8192D("receive TDLS frame but not supported\n");
 		ret = _FAIL;
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ b/drivers/staging/rtl8192du/core/rtw_tdls.c
@@ -40,10 +40,6 @@ void rtw_reset_tdls_info(_adapter *padap
 	ptdlsinfo->candidate_ch = 1;	/* when inplement channel switching, default candidate channel is 1 */
 	ptdlsinfo->watchdog_count = 0;
 	ptdlsinfo->dev_discovered = 0;
-
-#ifdef CONFIG_WFD
-	ptdlsinfo->wfd_info = &padapter->wfd_info;
-#endif /* CONFIG_WFD */
 }
 
 int rtw_init_tdls_info(_adapter *padapter)
@@ -362,128 +358,6 @@ u8 *rtw_tdls_set_sup_ch(struct mlme_ext_
 	return rtw_set_ie(pframe, _SUPPORTED_CH_IE_, idx_5g, sup_ch, &(pattrib->pktlen));
 }
 
-#ifdef CONFIG_WFD
-void rtw_tdls_process_wfd_ie(struct tdls_info *ptdlsinfo, u8 *ptr, u8 length)
-{
-	u8	wfd_ie[128] = { 0x00 };
-	u32	wfd_ielen = 0;
-	u32	wfd_offset = 0;
-	/*	Try to get the TCP port information when receiving the negotiation response. */
-
-	wfd_offset = 0;
-	wfd_offset = rtw_get_wfd_ie(ptr + wfd_offset, length - wfd_offset, wfd_ie, &wfd_ielen);
-	while (wfd_offset) {
-		u8	attr_content[10] = { 0x00 };
-		u32	attr_contentlen = 0;
-		int	i;
-
-		DBG_871X("[%s] WFD IE Found!!\n", __func__);
-		rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
-		if (attr_contentlen) {
-			ptdlsinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16(attr_content + 2);
-			DBG_871X("[%s] Peer PORT NUM = %d\n", __func__, ptdlsinfo->wfd_info->peer_rtsp_ctrlport);
-		}
-
-		memset(attr_content, 0x00, 10);
-		attr_contentlen = 0;
-		rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_LOCAL_IP_ADDR, attr_content, &attr_contentlen);
-		if (attr_contentlen) {
-			memcpy(ptdlsinfo->wfd_info->peer_ip_address, (attr_content + 1), 4);
-			DBG_871X("[%s] Peer IP = %02u.%02u.%02u.%02u\n", __func__,
-				 ptdlsinfo->wfd_info->peer_ip_address[0],
-				 ptdlsinfo->wfd_info->peer_ip_address[1],
-				 ptdlsinfo->wfd_info->peer_ip_address[2],
-				 ptdlsinfo->wfd_info->peer_ip_address[3]);
-		}
-		wfd_offset = rtw_get_wfd_ie(ptr + wfd_offset, length - wfd_offset, wfd_ie, &wfd_ielen);
-	}
-}
-
-void issue_tunneled_probe_req(_adapter *padapter)
-{
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	u8 baddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-
-	DBG_871X("[%s]\n", __func__);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-
-	pmgntframe->frame_tag = DATA_FRAMETAG;
-	pattrib->ether_type = 0x890d;
-	pattrib->pctrl = 0;
-
-	memcpy(pattrib->dst, baddr, ETH_ALEN);
-
-	memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
-
-	memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
-	memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
-
-	update_tdls_attrib(padapter, pattrib);
-	pattrib->qsel = pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TUNNELED_PROBE_REQ) != _SUCCESS) {
-		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
-		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit;
-	}
-	rtw_dump_xframe(padapter, pmgntframe);
-
-exit:
-
-	return;
-}
-
-void issue_tunneled_probe_rsp(_adapter *padapter, struct recv_frame_hdr *precv_frame)
-{
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct rx_pkt_attrib	*rx_pkt_pattrib = &precv_frame->attrib;
-
-	DBG_871X("[%s]\n", __func__);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-
-	pmgntframe->frame_tag = DATA_FRAMETAG;
-	pattrib->ether_type = 0x890d;
-	pattrib->pctrl = 0;
-
-	memcpy(pattrib->dst, rx_pkt_pattrib->src, ETH_ALEN);
-
-	memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
-
-	memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
-	memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
-
-	update_tdls_attrib(padapter, pattrib);
-	pattrib->qsel = pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TUNNELED_PROBE_RSP) != _SUCCESS) {
-		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
-		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit;
-	}
-	rtw_dump_xframe(padapter, pmgntframe);
-
-exit:
-
-	return;
-}
-#endif /* CONFIG_WFD */
-
 void issue_tdls_setup_req(_adapter *padapter, u8 *mac_addr)
 {
 	struct tdls_info	*ptdlsinfo = &padapter->tdlsinfo;
@@ -1137,14 +1011,6 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 				ptdls_sta->stat_code = 38;
 			}
 
-#ifdef CONFIG_WFD
-			/* WFD test plan version 0.18.2 test item 5.1.5 */
-			/* SoUT does not use TDLS if AP uses weak security */
-			if (adapter->wdinfo.wfd_tdls_enable) {
-				if (rsnie_have && (prx_pkt_attrib->encrypt != _AES_))
-					ptdls_sta->stat_code = 5;
-			}
-#endif /* CONFIG_WFD */
 		}
 
 		ptdls_sta->tdls_sta_state |= TDLS_INITIATOR_STATE;
@@ -1158,11 +1024,6 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 		if (ptdlsinfo->sta_cnt == (NUM_STA - 2))	/*  -2: AP + BC/MC sta */
 			ptdlsinfo->sta_maximum = true;
-
-#ifdef CONFIG_WFD
-		rtw_tdls_process_wfd_ie(ptdlsinfo, ptr + FIXED_IE, parsing_length - FIXED_IE);
-#endif /*  CONFIG_WFD */
-
 	} else {
 		goto exit;
 	}
@@ -1281,10 +1142,6 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 	ptdls_sta->bssratelen = supportRateNum;
 	memcpy(ptdls_sta->bssrateset, supportRate, supportRateNum);
 
-#ifdef CONFIG_WFD
-	rtw_tdls_process_wfd_ie(ptdlsinfo, ptr + FIXED_IE, parsing_length - FIXED_IE);
-#endif /*  CONFIG_WFD */
-
 	if (stat_code != 0) {
 		ptdls_sta->stat_code = stat_code;
 	} else {
@@ -1739,92 +1596,6 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 	return _FAIL;
 }
 
-#ifdef CONFIG_WFD
-void wfd_ie_tdls(_adapter *padapter, u8 *pframe, u32 *pktlen)
-{
-	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-	struct wifi_display_info	*pwfd_info = padapter->tdlsinfo.wfd_info;
-	u8 wfdie[MAX_WFD_IE_LEN] = { 0x00 };
-	u32 wfdielen = 0;
-
-	/*	WFD OUI */
-	wfdielen = 0;
-	wfdie[wfdielen++] = 0x50;
-	wfdie[wfdielen++] = 0x6F;
-	wfdie[wfdielen++] = 0x9A;
-	wfdie[wfdielen++] = 0x0A;	/*	WFA WFD v1.0 */
-
-	/*	Commented by Albert 20110825 */
-	/*	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes */
-	/*	1. WFD Device Information */
-	/*	2. Associated BSSID (Optional) */
-	/*	3. Local IP Adress (Optional) */
-
-	/*	WFD Device Information ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value1: */
-	/*	WFD device information */
-	/*	WFD primary sink + available for WFD session + Preferred TDLS + WSD (WFD Service Discovery) */
-	RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL
-								| WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_WSD);
-	wfdielen += 2;
-
-	/*	Value2: */
-	/*	Session Management Control Port */
-	/*	Default TCP port for RTSP messages is 554 */
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
-	wfdielen += 2;
-
-	/*	Value3: */
-	/*	WFD Device Maximum Throughput */
-	/*	300Mbps is the maximum throughput */
-	RTW_PUT_BE16(wfdie + wfdielen, 300);
-	wfdielen += 2;
-
-	/*	Associated BSSID ATTR */
-	/*	Type: */
-	wfdie[wfdielen++] = WFD_ATTR_ASSOC_BSSID;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
-	wfdielen += 2;
-
-	/*	Value: */
-	/*	Associated BSSID */
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
-	else
-		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
-
-	/*	Local IP Address ATTR */
-	wfdie[wfdielen++] = WFD_ATTR_LOCAL_IP_ADDR;
-
-	/*	Length: */
-	/*	Note: In the WFD specification, the size of length field is 2. */
-	RTW_PUT_BE16(wfdie + wfdielen, 0x0005);
-	wfdielen += 2;
-
-	/*	Version: */
-	/*	0x01: Version1;IPv4 */
-	wfdie[wfdielen++] = 0x01;
-
-	/*	IPv4 Address */
-	memcpy(wfdie + wfdielen, pwfd_info->ip_address, 4);
-	wfdielen += 4;
-
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wfdielen,
-			    (unsigned char *)wfdie, pktlen);
-}
-#endif /* CONFIG_WFD */
-
 void rtw_build_tdls_setup_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
 {
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
@@ -1933,10 +1704,6 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	memcpy((link_id_addr+6), pattrib->src, 6);
 	memcpy((link_id_addr+12), pattrib->dst, 6);
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-
-#ifdef CONFIG_WFD
-	wfd_ie_tdls(padapter, pframe, &(pattrib->pktlen));
-#endif /* CONFIG_WFD */
 }
 
 void rtw_build_tdls_setup_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
@@ -2076,10 +1843,6 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	/* fill FTIE mic */
 	if (pattrib->encrypt)
 		wpa_tdls_ftie_mic(ptdls_sta->tpk.kck, 2, plinkid_ie, prsnie, ptimeout_ie, pftie, pftie_mic);
-
-#ifdef CONFIG_WFD
-	wfd_ie_tdls(padapter, pframe, &(pattrib->pktlen));
-#endif /* CONFIG_WFD */
 }
 
 void rtw_build_tdls_setup_cfm_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
@@ -2402,66 +2165,6 @@ void rtw_build_tdls_ch_switch_rsp_ies(_a
 	pframe = rtw_set_ie(pframe, _CH_SWITCH_TIMING_,  4, ch_switch_timing, &(pattrib->pktlen));
 }
 
-#ifdef CONFIG_WFD
-void rtw_build_tunneled_probe_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
-{
-	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-	struct wifidirect_info *pbuddy_wdinfo = &padapter->pbuddy_adapter->wdinfo;
-	u8 payload_type = 0x02;
-	u8 category = RTW_WLAN_CATEGORY_P2P;
-	u8 WFA_OUI[3] = { 0x50, 0x6f, 0x9a};
-	u8 probe_req = 4;
-	u8 wfdielen = 0;
-
-	/* payload type */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	/* category, OUI, frame_body_type */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 3, WFA_OUI, &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(probe_req), &(pattrib->pktlen));
-
-	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-		wfdielen = build_probe_req_wfd_ie(pwdinfo, pframe);
-		pframe += wfdielen;
-		pattrib->pktlen += wfdielen;
-	} else if (!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE)) {
-		wfdielen = build_probe_req_wfd_ie(pbuddy_wdinfo, pframe);
-		pframe += wfdielen;
-		pattrib->pktlen += wfdielen;
-	}
-}
-
-void rtw_build_tunneled_probe_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
-{
-	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-	struct wifidirect_info *pbuddy_wdinfo = &padapter->pbuddy_adapter->wdinfo;
-	u8 payload_type = 0x02;
-	u8 category = RTW_WLAN_CATEGORY_P2P;
-	u8 WFA_OUI[3] = { 0x50, 0x6f, 0x9a};
-	u8 probe_rsp = 5;
-	u8 wfdielen = 0;
-
-	/* payload type */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	/* category, OUI, frame_body_type */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 3, WFA_OUI, &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(probe_rsp), &(pattrib->pktlen));
-
-	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-		wfdielen = build_probe_resp_wfd_ie(pwdinfo, pframe, 1);
-		pframe += wfdielen;
-		pattrib->pktlen += wfdielen;
-	} else if (!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE)) {
-		wfdielen = build_probe_resp_wfd_ie(pbuddy_wdinfo, pframe, 1);
-		pframe += wfdielen;
-		pattrib->pktlen += wfdielen;
-	}
-}
-#endif /* CONFIG_WFD */
-
 void _TPK_timer_hdl(void *FunctionContext)
 {
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -660,39 +660,8 @@ void flush_all_cam_entry(struct rtw_adap
 	memset((u8 *)(pmlmeinfo->FW_sta_info), 0, sizeof(pmlmeinfo->FW_sta_info));
 }
 
-#if defined(CONFIG_P2P) && defined(CONFIG_WFD)
-int WFD_info_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
-{
-	struct registry_priv	*pregpriv = &padapter->registrypriv;
-	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct wifidirect_info	*pwdinfo;
-	u8	wfd_ie[128] = { 0x00 };
-	u32	wfd_ielen = 0;
-
-	pwdinfo = &padapter->wdinfo;
-	if (rtw_get_wfd_ie((u8 *)pIE, pIE->Length, wfd_ie, &wfd_ielen)) {
-		u8	attr_content[10] = { 0x00 };
-		u32	attr_contentlen = 0;
-
-		pr_info("[%s] Found WFD IE\n", __func__);
-		rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
-		if (attr_contentlen) {
-			pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16(attr_content + 2);
-			DBG_8192D("[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
-			return true;
-		}
-	} else {
-		pr_info("[%s] NO WFD IE\n", __func__);
-	}
-	return _FAIL;
-}
-#endif
-
 int WMM_param_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
 {
-	/* struct registry_priv	*pregpriv = &padapter->registrypriv; */
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -1026,19 +1026,10 @@ int rtw_build_tdls_ies(struct rtw_adapte
 	case TDLS_CHANNEL_SWITCH_RESPONSE:
 		rtw_build_tdls_ch_switch_rsp_ies(padapter, pxmitframe, pframe);
 		break;
-#ifdef CONFIG_WFD
-	case TUNNELED_PROBE_REQ:
-		rtw_build_tunneled_probe_req_ies(padapter, pxmitframe, pframe);
-		break;
-	case TUNNELED_PROBE_RSP:
-		rtw_build_tunneled_probe_rsp_ies(padapter, pxmitframe, pframe);
-		break;
-#endif /* CONFIG_WFD */
 	default:
 		res = _FAIL;
 		break;
 	}
-
 	return res;
 }
 
--- a/drivers/staging/rtl8192du/include/autoconf.h
+++ b/drivers/staging/rtl8192du/include/autoconf.h
@@ -48,10 +48,6 @@
 /* 	Added by Albert 20110314 */
 #define CONFIG_P2P	1
 #ifdef CONFIG_P2P
-	/* Added by Albert 20110812 */
-	/* The CONFIG_WFD is for supporting the Wi-Fi display */
-	/* define CONFIG_WFD	1 */
-
 	#ifndef CONFIG_WIFI_TEST
 		#define CONFIG_P2P_REMOVE_GROUP_INFO
 	#endif
--- a/drivers/staging/rtl8192du/include/drv_types.h
+++ b/drivers/staging/rtl8192du/include/drv_types.h
@@ -315,10 +315,6 @@ struct rtw_adapter {
 	struct tdls_info	tdlsinfo;
 #endif /* CONFIG_TDLS */
 
-#ifdef CONFIG_WFD
-	struct wifi_display_info wfd_info;
-#endif /* CONFIG_WFD */
-
 	void *HalData;
 	u32 hal_data_sz;
 	struct hal_ops	HalFunc;
--- a/drivers/staging/rtl8192du/include/ieee80211.h
+++ b/drivers/staging/rtl8192du/include/ieee80211.h
@@ -1237,11 +1237,6 @@ u32 rtw_set_p2p_attr_content(u8 *pbuf, u
 void rtw_wlan_bssid_ex_remove_p2p_attr(struct wlan_bssid_ex *bss_ex, u8 attr_id);
 #endif
 
-#ifdef CONFIG_WFD
-int rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen);
-int rtw_get_wfd_attr_content(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id ,u8 *attr_content, uint *attr_contentlen);
-#endif /*  CONFIG_WFD */
-
 uint	rtw_get_rateset_len(u8	*rateset);
 
 struct registry_priv;
--- a/drivers/staging/rtl8192du/include/rtw_mlme.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme.h
@@ -169,31 +169,6 @@ struct tx_invite_resp_info{
 	u8					token;	/* 	Used to record the dialog token of p2p invitation request frame. */
 };
 
-#ifdef CONFIG_WFD
-
-struct wifi_display_info{
-	u16							wfd_enable;			/* 	Eanble/Disable the WFD function. */
-	u16							rtsp_ctrlport;		/* 	TCP port number at which the this WFD device listens for RTSP messages */
-	u16							peer_rtsp_ctrlport;	/* 	TCP port number at which the peer WFD device listens for RTSP messages */
-													/* 	This filed should be filled when receiving the gropu negotiation request */
-
-	u8							peer_session_avail;	/* 	WFD session is available or not for the peer wfd device. */
-													/* 	This variable will be set when sending the provisioning discovery request to peer WFD device. */
-													/* 	And this variable will be reset when it is read by using the iwpriv p2p_get wfd_sa command. */
-
-	u8							ip_address[4];
-	u8							peer_ip_address[4];
-	u8							wfd_pc;				/* 	WFD preferred connection */
-													/* 	0 -> Prefer to use the P2P for WFD connection on peer side. */
-													/* 	1 -> Prefer to use the TDLS for WFD connection on peer side. */
-
-	u8							wfd_device_type;	/* 	WFD Device Type */
-													/* 	0 -> WFD Source Device */
-													/* 	1 -> WFD Primary Sink Device */
-	enum	SCAN_RESULT_TYPE	scan_result_type;	/* 	Used when P2P is enable. This parameter will impact the scan result. */
-};
-#endif /* CONFIG_WFD */
-
 struct tx_provdisc_req_info{
 	u16					wps_config_method_request;	/* 	Used when sending the provisioning request frame */
 	u16					peer_channel_num[2];		/* 	The channel number which the receiver stands. */
@@ -258,47 +233,44 @@ struct wifidirect_info{
 	struct group_id_info		groupid_info;	/* 	Store the group id information when doing the group negotiation handshake. */
 	struct scan_limit_info		rx_invitereq_info;	/* 	Used for get the limit scan channel from the Invitation procedure */
 	struct scan_limit_info		p2p_info;		/* 	Used for get the limit scan channel from the P2P negotiation handshake */
-#ifdef CONFIG_WFD
-	struct wifi_display_info		*wfd_info;
-#endif
 	enum P2P_ROLE			role;
 	enum P2P_STATE			pre_p2p_state;
 	enum P2P_STATE			p2p_state;
-	u8						device_addr[ETH_ALEN];	/* 	The device address should be the mac address of this device. */
-	u8						interface_addr[ETH_ALEN];
-	u8						social_chan[4];
-	u8						listen_channel;
-	u8						operating_channel;
-	u8						listen_dwell;		/* 	This value should be between 1 and 3 */
-	u8						support_rate[8];
-	u8						p2p_wildcard_ssid[P2P_WILDCARD_SSID_LEN];
-	u8						intent;		/* 	should only include the intent value. */
-	u8						p2p_peer_interface_addr[ETH_ALEN];
-	u8						p2p_peer_device_addr[ETH_ALEN];
-	u8						peer_intent;	/* 	Included the intent value and tie breaker value. */
-	u8						device_name[WPS_MAX_DEVICE_NAME_LEN];	/* 	Device name for displaying on searching device screen */
-	u8						device_name_len;
-	u8						profileindex;	/* 	Used to point to the index of profileinfo array */
-	u8						peer_operating_ch;
-	u8						find_phase_state_exchange_cnt;
-	u16						device_password_id_for_nego;	/* 	The device password ID for group negotation */
-	u8						negotiation_dialog_token;
-	u8						nego_ssid[WLAN_SSID_MAXLEN];	/* 	SSID information for group negotitation */
-	u8						nego_ssidlen;
-	u8						p2p_group_ssid[WLAN_SSID_MAXLEN];
-	u8						p2p_group_ssid_len;
-	u8						persistent_supported;		/* 	Flag to know the persistent function should be supported or not. */
-														/* 	In the Sigma test, the Sigma will provide this enable from the sta_set_p2p CAPI. */
+	u8				device_addr[ETH_ALEN];	/* 	The device address should be the mac address of this device. */
+	u8				interface_addr[ETH_ALEN];
+	u8				social_chan[4];
+	u8				listen_channel;
+	u8				operating_channel;
+	u8				listen_dwell;		/* 	This value should be between 1 and 3 */
+	u8				support_rate[8];
+	u8				p2p_wildcard_ssid[P2P_WILDCARD_SSID_LEN];
+	u8				intent;		/* 	should only include the intent value. */
+	u8				p2p_peer_interface_addr[ETH_ALEN];
+	u8				p2p_peer_device_addr[ETH_ALEN];
+	u8				peer_intent;	/* 	Included the intent value and tie breaker value. */
+	u8				device_name[WPS_MAX_DEVICE_NAME_LEN];	/* 	Device name for displaying on searching device screen */
+	u8				device_name_len;
+	u8				profileindex;	/* 	Used to point to the index of profileinfo array */
+	u8				peer_operating_ch;
+	u8				find_phase_state_exchange_cnt;
+	u16				device_password_id_for_nego;	/* 	The device password ID for group negotation */
+	u8				negotiation_dialog_token;
+	u8				nego_ssid[WLAN_SSID_MAXLEN];	/* 	SSID information for group negotitation */
+	u8				nego_ssidlen;
+	u8				p2p_group_ssid[WLAN_SSID_MAXLEN];
+	u8				p2p_group_ssid_len;
+	u8				persistent_supported;		/* 	Flag to know the persistent function should be supported or not. */
+									/* 	In the Sigma test, the Sigma will provide this enable from the sta_set_p2p CAPI. */
+									/* 	0: disable */
+									/* 	1: enable */
+	u8				session_available;		/* 	Flag to set the WFD session available to enable or disable "by Sigma" */
+									/* 	In the Sigma test, the Sigma will disable the session available by using the sta_preset CAPI. */
+									/* 	0: disable */
+									/* 	1: enable */
+	u8				wfd_tdls_enable;			/* 	Flag to enable or disable the TDLS by WFD Sigma */
 														/* 	0: disable */
 														/* 	1: enable */
-	u8						session_available;			/* 	Flag to set the WFD session available to enable or disable "by Sigma" */
-														/* 	In the Sigma test, the Sigma will disable the session available by using the sta_preset CAPI. */
-														/* 	0: disable */
-														/* 	1: enable */
-	u8						wfd_tdls_enable;			/* 	Flag to enable or disable the TDLS by WFD Sigma */
-														/* 	0: disable */
-														/* 	1: enable */
-	u8						wfd_tdls_weaksec;			/* 	Flag to enable or disable the weak security function for TDLS by WFD Sigma */
+	u8				wfd_tdls_weaksec;			/* 	Flag to enable or disable the weak security function for TDLS by WFD Sigma */
 														/* 	0: disable */
 														/* 	In this case, the driver can't issue the tdsl setup request frame. */
 														/* 	1: enable */
@@ -306,13 +278,13 @@ struct wifidirect_info{
 														/* 	even the current security is weak security. */
 
 	enum	P2P_WPSINFO		ui_got_wps_info;			/* 	This field will store the WPS value (PIN value or PBC) that UI had got from the user. */
-	u16						supported_wps_cm;			/* 	This field describes the WPS config method which this driver supported. */
+	u16				supported_wps_cm;			/* 	This field describes the WPS config method which this driver supported. */
 														/* 	The value should be the combination of config method defined in page104 of WPS v2.0 spec. */
-	uint						channel_list_attr_len;		/* 	This field will contain the length of body of P2P Channel List attribute of group negotitation response frame. */
-	u8						channel_list_attr[100];		/* 	This field will contain the body of P2P Channel List attribute of group negotitation response frame. */
-														/* 	We will use the channel_cnt and channel_list fields when constructing the group negotitation confirm frame. */
+	uint				channel_list_attr_len;		/* 	This field will contain the length of body of P2P Channel List attribute of group negotitation response frame. */
+	u8				channel_list_attr[100];		/* 	This field will contain the body of P2P Channel List attribute of group negotitation response frame. */
+									/* 	We will use the channel_cnt and channel_list fields when constructing the group negotitation confirm frame. */
 #ifdef CONFIG_CONCURRENT_MODE
-	u16						ext_listen_interval;	/* 	The interval to be available with legacy AP (ms) */
+	u16				ext_listen_interval;	/* 	The interval to be available with legacy AP (ms) */
 	u16						ext_listen_period;	/* 	The time period to be available for P2P listen state (ms) */
 #endif
 #ifdef CONFIG_P2P_PS
@@ -352,9 +324,6 @@ struct tdls_info{
 	u8					watchdog_count;
 	u8					dev_discovered;		/* WFD_TDLS: for sigma test */
 	u8					enable;
-#ifdef CONFIG_WFD
-	struct wifi_display_info		*wfd_info;
-#endif
 };
 
 struct mlme_priv {
@@ -477,22 +446,6 @@ struct mlme_priv {
 
 #endif /* if defined (CONFIG_92D_AP_MODE) && defined (CONFIG_NATIVEAP_MLME) */
 
-#if defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211)
-
-	u8 *wfd_beacon_ie;
-	u8 *wfd_probe_req_ie;
-	u8 *wfd_probe_resp_ie;
-	u8 *wfd_go_probe_resp_ie; /* for GO */
-	u8 *wfd_assoc_req_ie;
-
-	u32 wfd_beacon_ie_len;
-	u32 wfd_probe_req_ie_len;
-	u32 wfd_probe_resp_ie_len;
-	u32 wfd_go_probe_resp_ie_len; /* for GO */
-	u32 wfd_assoc_req_ie_len;
-
-#endif
-
 #ifdef CONFIG_INTEL_WIDI
 	int	widi_state;
 	int	listen_state;
--- a/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
@@ -527,9 +527,6 @@ int is_IBSS_empty(struct rtw_adapter *pa
 unsigned char check_assoc_AP(u8 *pframe, uint len);
 
 int WMM_param_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE);
-#ifdef CONFIG_WFD
-int WFD_info_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE);
-#endif
 void WMMOnAssocRsp(struct rtw_adapter *padapter);
 
 void HT_caps_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE);
--- a/drivers/staging/rtl8192du/include/rtw_p2p.h
+++ b/drivers/staging/rtl8192du/include/rtw_p2p.h
@@ -23,21 +23,6 @@ u32 build_probe_resp_p2p_ie(struct wifid
 u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8* pssid, u8 ussidlen, u8* pdev_raddr);
 u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 status_code);
 u32 build_deauth_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-#ifdef CONFIG_WFD
-u32 build_probe_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 build_probe_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 tunneled);
-u32 build_beacon_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 build_nego_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 build_nego_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 build_nego_confirm_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 build_invitation_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 build_invitation_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 build_assoc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 build_assoc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 build_provdisc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-u32 build_provdisc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-#endif /* CONFIG_WFD */
-
 u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
 u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len, struct sta_info *psta);
 u32 process_p2p_devdisc_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
--- a/drivers/staging/rtl8192du/include/rtw_tdls.h
+++ b/drivers/staging/rtl8192du/include/rtw_tdls.h
@@ -98,10 +98,6 @@ void init_off_ch_timer(_adapter *padapte
 void init_tdls_alive_timer(_adapter *padapter, struct sta_info *psta);
 void init_handshake_timer(_adapter *padapter, struct sta_info *psta);
 void free_tdls_sta(_adapter *padapter, struct sta_info *ptdls_sta);
-#ifdef CONFIG_WFD
-void issue_tunneled_probe_req(_adapter *padapter);
-void issue_tunneled_probe_rsp(_adapter *padapter, struct recv_frame_hdr *precv_frame);
-#endif /* CONFIG_WFD */
 void issue_tdls_dis_req(_adapter *padapter, u8 *mac_addr);
 void issue_tdls_setup_req(_adapter *padapter, u8 *mac_addr);
 void issue_tdls_setup_rsp(_adapter *padapter, struct recv_frame_hdr *precv_frame);
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -1550,34 +1550,7 @@ static int rtw_cfg80211_set_probe_req_wp
 			pmlmepriv->p2p_probe_req_ie_len = p2p_ielen;
 		}
 		#endif /* CONFIG_P2P */
-
-		#ifdef CONFIG_WFD
-		if (rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
-		{
-			#ifdef CONFIG_DEBUG_CFG80211
-			DBG_8192D("probe_req_wfd_ielen=%d\n", wfd_ielen);
-			#endif
-
-			if (pmlmepriv->wfd_probe_req_ie)
-			{
-				u32 free_len = pmlmepriv->wfd_probe_req_ie_len;
-				pmlmepriv->wfd_probe_req_ie_len = 0;
-				kfree(pmlmepriv->wfd_probe_req_ie);
-				pmlmepriv->wfd_probe_req_ie = NULL;
-			}
-
-			pmlmepriv->wfd_probe_req_ie = kmalloc(wfd_ielen, GFP_KERNEL);
-			if (pmlmepriv->wfd_probe_req_ie == NULL) {
-				DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
-				return -EINVAL;
-
-			}
-			rtw_get_wfd_ie(buf, len, pmlmepriv->wfd_probe_req_ie, &pmlmepriv->wfd_probe_req_ie_len);
-		}
-		#endif /* CONFIG_WFD */
-
 	}
-
 	return ret;
 }
 
@@ -2088,36 +2061,6 @@ static int rtw_cfg80211_set_wpa_ie(struc
 	}
 	#endif /* CONFIG_P2P */
 
-	#ifdef CONFIG_WFD
-	{/* check wfd_ie for assoc req; */
-		uint wfd_ielen=0;
-		u8 *wfd_ie;
-		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
-		if (rtw_get_wfd_ie(buf, ielen, NULL, &wfd_ielen))
-		{
-			#ifdef CONFIG_DEBUG_CFG80211
-			DBG_8192D("%s wfd_assoc_req_ielen=%d\n", __func__, wfd_ielen);
-			#endif
-
-			if (pmlmepriv->wfd_assoc_req_ie)
-			{
-				u32 free_len = pmlmepriv->wfd_assoc_req_ie_len;
-				pmlmepriv->wfd_assoc_req_ie_len = 0;
-				kfree(pmlmepriv->wfd_assoc_req_ie);
-				pmlmepriv->wfd_assoc_req_ie = NULL;
-			}
-
-			pmlmepriv->wfd_assoc_req_ie = kmalloc(wfd_ielen, GFP_KERNEL);
-			if (pmlmepriv->wfd_assoc_req_ie == NULL) {
-				DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
-				goto exit;
-			}
-			rtw_get_wfd_ie(buf, ielen, pmlmepriv->wfd_assoc_req_ie, &pmlmepriv->wfd_assoc_req_ie_len);
-		}
-	}
-	#endif /* CONFIG_WFD */
-
 	/* TKIP and AES disallow multicast packets until installing group key */
 	if (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_
@@ -2813,19 +2756,6 @@ dump:
 		pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
 
 		memcpy(pframe, (void*)buf, len);
-		#ifdef CONFIG_WFD
-		if (type >= 0)
-		{
-			struct wifi_display_info		*pwfd_info;
-
-			pwfd_info = padapter->wdinfo.wfd_info;
-
-			if (true == pwfd_info->wfd_enable)
-			{
-				rtw_append_wfd_ie(padapter, pframe, &len);
-			}
-		}
-		#endif /*  CONFIG_WFD */
 		pattrib->pktlen = len;
 
 		pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
@@ -3386,17 +3316,12 @@ void rtw_cfg80211_issue_p2p_provision_re
 	u8	devinfo_content[64] = { 0x00 };
 	u16	capability = 0;
 	uint capability_len = 0;
-
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u8			dialogToken = 1;
 	u32			p2poui = cpu_to_be32(P2POUI);
 	u8			oui_subtype = P2P_PROVISION_DISC_REQ;
 	u32			p2pielen = 0;
-#ifdef CONFIG_WFD
-	u32					wfdielen = 0;
-#endif /* CONFIG_WFD */
-
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
 	unsigned char					*pframe;
@@ -3568,12 +3493,6 @@ void rtw_cfg80211_issue_p2p_provision_re
 
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
 
-#ifdef CONFIG_WFD
-	wfdielen = build_provdisc_req_wfd_ie(pwdinfo, pframe);
-	pframe += wfdielen;
-	pattrib->pktlen += wfdielen;
-#endif /* CONFIG_WFD */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS)
@@ -3849,19 +3768,6 @@ static int _cfg80211_rtw_mgmt_tx(struct
 	pattrib->seqnum = pmlmeext->mgnt_seq;
 	pmlmeext->mgnt_seq++;
 
-#ifdef CONFIG_WFD
-	{
-		struct wifi_display_info	*pwfd_info;
-
-		pwfd_info = padapter->wdinfo.wfd_info;
-
-		if (true == pwfd_info->wfd_enable)
-		{
-			rtw_append_wfd_ie(padapter, pframe, &pattrib->pktlen);
-		}
-	}
-#endif /*  CONFIG_WFD */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS)
@@ -4060,35 +3966,8 @@ static int rtw_cfg80211_set_beacon_wpsp2
 		}
 		#endif /* CONFIG_P2P */
 
-		#ifdef CONFIG_WFD
-		if (rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
-		{
-			#ifdef CONFIG_DEBUG_CFG80211
-			DBG_8192D("bcn_wfd_ielen=%d\n", wfd_ielen);
-			#endif
-
-			if (pmlmepriv->wfd_beacon_ie)
-			{
-				u32 free_len = pmlmepriv->wfd_beacon_ie_len;
-				pmlmepriv->wfd_beacon_ie_len = 0;
-				kfree(pmlmepriv->wfd_beacon_ie);
-				pmlmepriv->wfd_beacon_ie = NULL;
-			}
-
-			pmlmepriv->wfd_beacon_ie = kmalloc(wfd_ielen, GFP_KERNEL);
-			if (pmlmepriv->wfd_beacon_ie == NULL) {
-				DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
-				return -EINVAL;
-
-			}
-			rtw_get_wfd_ie(buf, len, pmlmepriv->wfd_beacon_ie, &pmlmepriv->wfd_beacon_ie_len);
-		}
-		#endif /* CONFIG_WFD */
-
 		pmlmeext->bstart_bss = true;
-
 	}
-
 	return ret;
 }
 
@@ -4213,34 +4092,7 @@ static int rtw_cfg80211_set_probe_resp_w
 
 		}
 		#endif /* CONFIG_P2P */
-
-		#ifdef CONFIG_WFD
-		if (rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
-		{
-			#ifdef CONFIG_DEBUG_CFG80211
-			DBG_8192D("probe_resp_wfd_ielen=%d\n", wfd_ielen);
-			#endif
-
-			if (pmlmepriv->wfd_probe_resp_ie)
-			{
-				u32 free_len = pmlmepriv->wfd_probe_resp_ie_len;
-				pmlmepriv->wfd_probe_resp_ie_len = 0;
-				kfree(pmlmepriv->wfd_probe_resp_ie);
-				pmlmepriv->wfd_probe_resp_ie = NULL;
-			}
-
-			pmlmepriv->wfd_probe_resp_ie = kmalloc(wfd_ielen, GFP_KERNEL);
-			if (pmlmepriv->wfd_probe_resp_ie == NULL) {
-				DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
-				return -EINVAL;
-
-			}
-			rtw_get_wfd_ie(buf, len, pmlmepriv->wfd_probe_resp_ie, &pmlmepriv->wfd_probe_resp_ie_len);
-		}
-		#endif /* CONFIG_WFD */
-
 	}
-
 	return ret;
 }
 
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -235,85 +235,31 @@ static char *translate_scan(struct rtw_a
 #endif /* CONFIG_P2P */
 
 #ifdef CONFIG_P2P
-#ifdef CONFIG_WFD
-	if (SCAN_RESULT_ALL == pwdinfo->wfd_info->scan_result_type)
-	{
-
-	}
-	else if ((SCAN_RESULT_P2P_ONLY == pwdinfo->wfd_info->scan_result_type) ||
-		      (SCAN_RESULT_WFD_TYPE == pwdinfo->wfd_info->scan_result_type))
-#endif /*  CONFIG_WFD */
+	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
-		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		{
-			u32	blnGotP2PIE = false;
-
-			/*	User is doing the P2P device discovery */
-			/*	The prefix of SSID should be "DIRECT-" and the IE should contains the P2P IE. */
-			/*	If not, the driver should ignore this AP and go to the next AP. */
-
-			/*	Verifying the SSID */
-			if (!memcmp(pnetwork->network.Ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN))
-			{
-				u32	p2pielen = 0;
-
-				/*	Verifying the P2P IE */
-				if (rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen))
-				{
-					blnGotP2PIE = true;
-				}
-			}
+		u32	blnGotP2PIE = false;
 
-			if (blnGotP2PIE == false)
-			{
-				return start;
-			}
-
-		}
-	}
-
-#ifdef CONFIG_WFD
-	if (SCAN_RESULT_WFD_TYPE == pwdinfo->wfd_info->scan_result_type)
-	{
-		u32	blnGotWFD = false;
-		u8	wfd_ie[128] = { 0x00 };
-		uint	wfd_ielen = 0;
+		/*	User is doing the P2P device discovery */
+		/*	The prefix of SSID should be "DIRECT-" and the IE should contains the P2P IE. */
+		/*	If not, the driver should ignore this AP and go to the next AP. */
 
-		if (rtw_get_wfd_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen))
+		/*	Verifying the SSID */
+		if (!memcmp(pnetwork->network.Ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN))
 		{
-			u8	wfd_devinfo[6] = { 0x00 };
-			uint	wfd_devlen = 6;
+			u32	p2pielen = 0;
 
-			if (rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, wfd_devinfo, &wfd_devlen))
+			/*	Verifying the P2P IE */
+			if (rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen))
 			{
-				if (pwdinfo->wfd_info->wfd_device_type == WFD_DEVINFO_PSINK)
-				{
-					/*	the first two bits will indicate the WFD device type */
-					if ((wfd_devinfo[1] & 0x03) == WFD_DEVINFO_SOURCE)
-					{
-						/*	If this device is Miracast PSink device, the scan reuslt should just provide the Miracast source. */
-						blnGotWFD = true;
-					}
-				}
-				else if (pwdinfo->wfd_info->wfd_device_type == WFD_DEVINFO_SOURCE)
-				{
-					/*	the first two bits will indicate the WFD device type */
-					if ((wfd_devinfo[1] & 0x03) == WFD_DEVINFO_PSINK)
-					{
-						/*	If this device is Miracast source device, the scan reuslt should just provide the Miracast PSink. */
-						/*	Todo: How about the SSink?! */
-						blnGotWFD = true;
-					}
-				}
+				blnGotP2PIE = true;
 			}
 		}
 
-		if (blnGotWFD == false)
+		if (blnGotP2PIE == false)
 		{
 			return start;
 		}
 	}
-#endif /*  CONFIG_WFD */
 
 #endif /* CONFIG_P2P */
 	/*  AP MAC address  */
@@ -3673,67 +3619,9 @@ static int rtw_p2p_get_wps_configmethod(
 	return ret;
 }
 
-#ifdef CONFIG_WFD
-static int rtw_p2p_get_peer_wfd_port(struct net_device *dev,
-				     struct iw_request_info *info,
-				     union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point *pdata = &wrqu->data;
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	DBG_8192D("[%s] p2p_state = %d\n", __func__, rtw_p2p_state(pwdinfo));
-
-	sprintf(extra, "\n\nPort =%d\n", pwdinfo->wfd_info->peer_rtsp_ctrlport);
-	DBG_8192D("[%s] remote port = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
-
-	wrqu->data.length = strlen(extra);
-	return ret;
-}
-
-static int rtw_p2p_get_peer_wfd_preferred_connection(struct net_device *dev,
-						     struct iw_request_info *info,
-						     union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point *pdata = &wrqu->data;
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	sprintf(extra, "\n\nwfd_pc =%d\n", pwdinfo->wfd_info->wfd_pc);
-	DBG_8192D("[%s] wfd_pc = %d\n", __func__, pwdinfo->wfd_info->wfd_pc);
-
-	wrqu->data.length = strlen(extra);
-	pwdinfo->wfd_info->wfd_pc = false;	/*	Reset the WFD preferred connection to P2P */
-	return ret;
-}
-
-static int rtw_p2p_get_peer_wfd_session_available(struct net_device *dev,
-						  struct iw_request_info *info,
-						  union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point *pdata = &wrqu->data;
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	sprintf(extra, "\n\nwfd_sa =%d\n", pwdinfo->wfd_info->peer_session_avail);
-	DBG_8192D("[%s] wfd_sa = %d\n", __func__, pwdinfo->wfd_info->peer_session_avail);
-
-	wrqu->data.length = strlen(extra);
-	pwdinfo->wfd_info->peer_session_avail = true;	/*	Reset the WFD session available */
-	return ret;
-}
-
-#endif /*  CONFIG_WFD */
-
 static int rtw_p2p_get_go_device_address(struct net_device *dev,
-										 struct iw_request_info *info,
-										 union iwreq_data *wrqu, char *extra, char *subcmd)
+					 struct iw_request_info *info,
+					 union iwreq_data *wrqu, char *extra, char *subcmd)
 {
 
 	int ret = 0;
@@ -4208,11 +4096,6 @@ static int rtw_p2p_invite_req(struct net
 	struct mlme_ext_priv		*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 #endif /*  CONFIG_CONCURRENT_MODE */
 
-#ifdef CONFIG_WFD
-	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
-#endif /*  CONFIG_WFD */
-
-	/*	Commented by Albert 20120321 */
 	/*	The input data contains two informations. */
 	/*	1. First information is the P2P device address which you want to send to. */
 	/*	2. Second information is the group id which combines with GO's mac address, space and GO's ssid. */
@@ -4297,45 +4180,6 @@ static int rtw_p2p_invite_req(struct net
 
 	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
-#ifdef CONFIG_WFD
-	if (uintPeerChannel)
-	{
-		u8	wfd_ie[128] = { 0x00 };
-		uint	wfd_ielen = 0;
-
-		if (rtw_get_wfd_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen))
-		{
-			u8	wfd_devinfo[6] = { 0x00 };
-			uint	wfd_devlen = 6;
-
-			DBG_8192D("[%s] Found WFD IE!\n", __func__);
-			if (rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, wfd_devinfo, &wfd_devlen))
-			{
-				u16	wfd_devinfo_field = 0;
-
-				/*	Commented by Albert 20120319 */
-				/*	The first two bytes are the WFD device information field of WFD device information subelement. */
-				/*	In big endian format. */
-				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
-				if (wfd_devinfo_field & WFD_DEVINFO_SESSION_AVAIL)
-				{
-					pwfd_info->peer_session_avail = true;
-				}
-				else
-				{
-					pwfd_info->peer_session_avail = false;
-				}
-			}
-		}
-
-		if (false == pwfd_info->peer_session_avail)
-		{
-			DBG_8192D("[%s] WFD Session not avaiable!\n", __func__);
-			goto exit;
-		}
-	}
-#endif /*  CONFIG_WFD */
-
 	if (uintPeerChannel)
 	{
 #ifdef CONFIG_CONCURRENT_MODE
@@ -4426,10 +4270,6 @@ static int rtw_p2p_set_persistent(struct
 	struct mlme_ext_priv		*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 #endif /*  CONFIG_CONCURRENT_MODE */
 
-#ifdef CONFIG_WFD
-	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
-#endif /*  CONFIG_WFD */
-
 	/*	Commented by Albert 20120328 */
 	/*	The input data is 0 or 1 */
 	/*	0: disable persistent group functionality */
@@ -4464,243 +4304,6 @@ exit:
 	return ret;
 }
 
-#ifdef CONFIG_WFD
-static int rtw_p2p_set_pc(struct net_device *dev,
-			  struct iw_request_info *info,
-			  union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-	struct rtw_adapter				*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point			*pdata = &wrqu->data;
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	u8					peerMAC[ETH_ALEN] = { 0x00 };
-	int					jj, kk;
-	u8					peerMACStr[ETH_ALEN * 2] = { 0x00 };
-	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-	struct list_head *plist, *phead;
-	struct __queue *queue = &(pmlmepriv->scanned_queue);
-	struct	wlan_network	*pnetwork = NULL;
-	u8					attr_content[50] = { 0x00 }, _status = 0;
-	u8 *p2pie;
-	uint					p2pielen = 0, attr_contentlen = 0;
-	uint					uintPeerChannel = 0;
-#ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
-	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif /*  CONFIG_CONCURRENT_MODE */
-	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
-
-	/*	Commented by Albert 20120512 */
-	/*	1. Input information is the MAC address which wants to know the Preferred Connection bit (PC bit) */
-	/*	Format: 00:E0:4C:00:00:05 */
-
-	DBG_8192D("[%s] data = %s\n", __func__, extra);
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-	{
-		DBG_8192D("[%s] WiFi Direct is disable!\n", __func__);
-		return ret;
-	}
-
-	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
-	{
-		peerMAC[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
-	}
-
-	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	phead = get_list_head(queue);
-	plist = phead->next;
-
-	while (1)
-	{
-		if (rtw_end_of_queue_search(phead, plist) == true)
-			break;
-
-		pnetwork = container_of(plist, struct wlan_network, list);
-
-		/*	Commented by Albert 2011/05/18 */
-		/*	Match the device address located in the P2P IE */
-		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
-
-		if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
-		{
-			/*	The P2P Device ID attribute is included in the Beacon frame. */
-			/*	The P2P Device Info attribute is included in the probe response frame. */
-			DBG_8192D("[%s] Got P2P IE\n", __func__);
-			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
-			{
-				/*	Handle the P2P Device ID attribute of Beacon first */
-				DBG_8192D("[%s] P2P_ATTR_DEVICE_ID\n", __func__);
-				if (!memcmp(attr_content, peerMAC, ETH_ALEN))
-				{
-					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
-					break;
-				}
-			}
-			else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
-			{
-				/*	Handle the P2P Device Info attribute of probe response */
-				DBG_8192D("[%s] P2P_ATTR_DEVICE_INFO\n", __func__);
-				if (!memcmp(attr_content, peerMAC, ETH_ALEN))
-				{
-					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
-					break;
-				}
-			}
-
-		}
-
-		plist = plist->next;
-
-	}
-
-	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-	DBG_8192D("[%s] channel = %d\n", __func__, uintPeerChannel);
-
-	if (uintPeerChannel)
-	{
-		u8	wfd_ie[128] = { 0x00 };
-		uint	wfd_ielen = 0;
-
-		if (rtw_get_wfd_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen))
-		{
-			u8	wfd_devinfo[6] = { 0x00 };
-			uint	wfd_devlen = 6;
-
-			DBG_8192D("[%s] Found WFD IE!\n", __func__);
-			if (rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, wfd_devinfo, &wfd_devlen))
-			{
-				u16	wfd_devinfo_field = 0;
-
-				/*	Commented by Albert 20120319 */
-				/*	The first two bytes are the WFD device information field of WFD device information subelement. */
-				/*	In big endian format. */
-				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
-				if (wfd_devinfo_field & WFD_DEVINFO_PC_TDLS)
-				{
-					pwfd_info->wfd_pc = true;
-				}
-				else
-				{
-					pwfd_info->wfd_pc = false;
-				}
-			}
-		}
-	}
-	else
-	{
-		DBG_8192D("[%s] NOT Found in the Scanning Queue!\n", __func__);
-	}
-
-exit:
-
-	return ret;
-}
-
-static int rtw_p2p_set_wfd_device_type(struct net_device *dev,
-				       struct iw_request_info *info,
-				       union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-	struct rtw_adapter					*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point				*pdata = &wrqu->data;
-	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
-	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
-
-	/*	Commented by Albert 20120328 */
-	/*	The input data is 0 or 1 */
-	/*	0: specify to Miracast source device */
-	/*	1 or others: specify to Miracast sink device (display device) */
-
-	DBG_8192D("[%s] data = %s\n", __func__, extra);
-
-	if (extra[0] == '0')	/*	Set to Miracast source device. */
-	{
-		pwfd_info->wfd_device_type = WFD_DEVINFO_SOURCE;
-	}
-	else					/*	Set to Miracast sink device. */
-	{
-		pwfd_info->wfd_device_type = WFD_DEVINFO_PSINK;
-	}
-
-exit:
-
-	return ret;
-}
-
-static int rtw_p2p_set_scan_result_type(struct net_device *dev,
-					struct iw_request_info *info,
-					union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-	struct rtw_adapter					*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point				*pdata = &wrqu->data;
-	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
-	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
-
-	/*	Commented by Albert 20120328 */
-	/*	The input data is 0 , 1 , 2 */
-	/*	0: when the P2P is enabled, the scan result will return all the found P2P device. */
-	/*	1: when the P2P is enabled, the scan result will return all the found P2P device and AP. */
-	/*	2: when the P2P is enabled, the scan result will show up the found Miracast devices base on... */
-	/*	It will show up all the Miracast source device if this device is sink. */
-	/*	It will show up all the Miracast sink device if this device is source. */
-
-	DBG_8192D("[%s] data = %s\n", __func__, extra);
-
-	if (extra[0] == '0')
-	{
-		pwfd_info->scan_result_type = SCAN_RESULT_P2P_ONLY;
-	}
-	else if (extra[0] == '1')
-	{
-		pwfd_info->scan_result_type = SCAN_RESULT_ALL;
-	}
-	else if (extra[0] == '2')
-	{
-		pwfd_info->scan_result_type = SCAN_RESULT_WFD_TYPE;
-	}
-	else
-	{
-		pwfd_info->scan_result_type = SCAN_RESULT_P2P_ONLY;
-	}
-
-exit:
-
-	return ret;
-}
-
-/*	To set the WFD session available to enable or disable */
-static int rtw_p2p_set_sa(struct net_device *dev,
-			  struct iw_request_info *info,
-			  union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-	struct rtw_adapter					*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct iw_point				*pdata = &wrqu->data;
-	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
-	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
-
-	DBG_8192D("[%s] data = %s\n", __func__, extra);
-
-	if (extra[0] == '0')	/*	Disable the session available. */
-		pwdinfo->session_available = false;
-	else if (extra[0] == '1')	/*	Enable the session available. */
-		pwdinfo->session_available = true;
-	else
-		pwdinfo->session_available = false;
-	DBG_8192D("[%s] session available = %d\n", __func__, pwdinfo->session_available);
-
-exit:
-
-	return ret;
-}
-#endif /* CONFIG_WFD */
-
 static int rtw_p2p_prov_disc(struct net_device *dev,
 			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
@@ -4724,10 +4327,6 @@ static int rtw_p2p_prov_disc(struct net_
 	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 #endif /*  CONFIG_CONCURRENT_MODE */
 
-#ifdef CONFIG_WFD
-	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
-#endif /*  CONFIG_WFD */
-
 	/*	Commented by Albert 20110301 */
 	/*	The input data contains two informations. */
 	/*	1. First information is the MAC address which wants to issue the provisioning discovery request frame. */
@@ -4838,46 +4437,7 @@ static int rtw_p2p_prov_disc(struct net_
 
 	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
-#ifdef CONFIG_WFD
-	{
-		u8	wfd_ie[128] = { 0x00 };
-		uint	wfd_ielen = 0;
-
-		if (rtw_get_wfd_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen))
-		{
-			u8	wfd_devinfo[6] = { 0x00 };
-			uint	wfd_devlen = 6;
-
-			DBG_8192D("[%s] Found WFD IE!\n", __func__);
-			if (rtw_get_wfd_attr_content(wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, wfd_devinfo, &wfd_devlen))
-			{
-				u16	wfd_devinfo_field = 0;
-
-				/*	Commented by Albert 20120319 */
-				/*	The first two bytes are the WFD device information field of WFD device information subelement. */
-				/*	In big endian format. */
-				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
-				if (wfd_devinfo_field & WFD_DEVINFO_SESSION_AVAIL)
-				{
-					pwfd_info->peer_session_avail = true;
-				}
-				else
-				{
-					pwfd_info->peer_session_avail = false;
-				}
-			}
-		}
-
-		if (false == pwfd_info->peer_session_avail)
-		{
-			DBG_8192D("[%s] WFD Session not avaiable!\n", __func__);
-			goto exit;
-		}
-	}
-#endif /*  CONFIG_WFD */
-
-	if (uintPeerChannel)
-	{
+	if (uintPeerChannel) {
 
 		DBG_8192D("[%s] peer channel: %d!\n", __func__, uintPeerChannel);
 #ifdef CONFIG_CONCURRENT_MODE
@@ -5073,32 +4633,6 @@ static int rtw_p2p_set(struct net_device
 		wrqu->data.length -= 11;
 		rtw_p2p_set_persistent(dev, info, wrqu, &extra[11]);
 	}
-#ifdef CONFIG_WFD
-	else if (!memcmp(extra, "sa =", 3))
-	{
-		/*	sa: WFD Session Available information */
-		wrqu->data.length -= 3;
-		rtw_p2p_set_sa(dev, info, wrqu, &extra[3]);
-	}
-	else if (!memcmp(extra, "pc =", 3))
-	{
-		/*	pc: WFD Preferred Connection */
-		wrqu->data.length -= 3;
-		rtw_p2p_set_pc(dev, info, wrqu, &extra[3]);
-	}
-	else if (!memcmp(extra, "wfd_type =", 9))
-	{
-		/*	Specify this device is Mircast source or sink */
-		wrqu->data.length -= 9;
-		rtw_p2p_set_wfd_device_type(dev, info, wrqu, &extra[9]);
-	}
-	else if (!memcmp(extra, "scan_type =", 10))
-	{
-		wrqu->data.length -= 10;
-		rtw_p2p_set_scan_result_type(dev, info, wrqu, &extra[10]);
-	}
-#endif /* CONFIG_WFD */
-
 #endif /* CONFIG_P2P */
 
 	return ret;
@@ -5140,16 +4674,6 @@ static int rtw_p2p_get(struct net_device
 	} else if (!memcmp((void const *)wrqu->data.pointer, "op_ch", 5)) {
 		rtw_p2p_get_op_ch(dev, info, wrqu, extra);
 	}
-#ifdef CONFIG_WFD
-	else if (!memcmp(wrqu->data.pointer, "peer_port", 9)) {
-		rtw_p2p_get_peer_wfd_port(dev, info, wrqu, extra);
-	} else if (!memcmp(wrqu->data.pointer, "wfd_sa", 6)) {
-		rtw_p2p_get_peer_wfd_session_available(dev, info, wrqu, extra);
-	} else if (!memcmp(wrqu->data.pointer, "wfd_pc", 6)) {
-		rtw_p2p_get_peer_wfd_preferred_connection(dev, info, wrqu, extra);
-	}
-#endif /*  CONFIG_WFD */
-
 #endif /* CONFIG_P2P */
 
 	return ret;
@@ -7448,21 +6972,6 @@ static int rtw_wfd_tdls_enable(struct ne
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-#ifdef CONFIG_WFD
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
-
-	if (extra[0] == '0')
-		padapter->wdinfo.wfd_tdls_enable = 0;
-	else
-		padapter->wdinfo.wfd_tdls_enable = 1;
-
-#endif /* CONFIG_WFD */
-#endif /* CONFIG_TDLS */
-
 	return ret;
 }
 
@@ -7560,32 +7069,13 @@ static int rtw_tdls_setup(struct net_dev
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	u8 mac_addr[ETH_ALEN];
 
-#ifdef CONFIG_WFD
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-#endif /*  CONFIG_WFD */
-
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
 	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3)
 		mac_addr[i]= key_2char2num(*(extra+j), *(extra+j+1));
 
-#ifdef CONFIG_WFD
-	if (_AES_ != padapter->securitypriv.dot11PrivacyAlgrthm) {
-		/*	Weak Security situation with AP. */
-		if (0 == pwdinfo->wfd_tdls_weaksec) {
-			/*	Can't send the tdls setup request out!! */
-			DBG_8192D("[%s] Current link is not AES, SKIP sending the tdls setup request!!\n", __func__);
-		} else {
-			issue_tdls_setup_req(padapter, mac_addr);
-		}
-	}
-	else
-#endif /*  CONFIG_WFD */
-	{
-		issue_tdls_setup_req(padapter, mac_addr);
-	}
+	issue_tdls_setup_req(padapter, mac_addr);
 #endif
-
 	return ret;
 }
 
@@ -7732,41 +7222,6 @@ static int rtw_tdls_setip(struct net_dev
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-#ifdef CONFIG_WFD
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
-	u8 i = 0, j = 0, k = 0, tag = 0, ip[3] = { 0xff }, *ptr = extra;
-
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length - 1);
-
-	while (i < 4) {
-		for (j = 0; j < 4; j++) {
-			if (*(extra + j + tag) == '.' || *(extra + j + tag) == '\0') {
-				if (j == 1)
-					pwfd_info->ip_address[i]= convert_ip_addr('0', '0', *(extra+(j-1)+tag));
-				if (j == 2)
-					pwfd_info->ip_address[i]= convert_ip_addr('0', *(extra+(j-2)+tag), *(extra+(j-1)+tag));
-				if (j == 3)
-					pwfd_info->ip_address[i]= convert_ip_addr(*(extra+(j-3)+tag), *(extra+(j-2)+tag), *(extra+(j-1)+tag));
-
-				tag += j + 1;
-				break;
-			}
-		}
-		i++;
-	}
-
-	DBG_8192D("[%s] Set IP = %u.%u.%u.%u\n", __func__,
-		ptdlsinfo->wfd_info->ip_address[0], ptdlsinfo->wfd_info->ip_address[1],
-		ptdlsinfo->wfd_info->ip_address[2], ptdlsinfo->wfd_info->ip_address[3]
-	);
-
-#endif /* CONFIG_WFD */
-#endif /* CONFIG_TDLS */
-
 	return ret;
 }
 
@@ -7776,28 +7231,6 @@ static int rtw_tdls_getip(struct net_dev
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-#ifdef CONFIG_WFD
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
-
-	DBG_8192D("[%s]\n", __func__);
-
-	sprintf(extra, "\n\n%u.%u.%u.%u\n",
-		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1],
-		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]);
-
-	DBG_8192D("[%s] IP =%u.%u.%u.%u\n", __func__,
-		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1],
-		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]);
-
-	wrqu->data.length = strlen(extra);
-
-#endif /* CONFIG_WFD */
-#endif /* CONFIG_TDLS */
-
 	return ret;
 }
 
@@ -7807,23 +7240,6 @@ static int rtw_tdls_getport(struct net_d
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-#ifdef CONFIG_WFD
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
-
-	DBG_8192D("[%s]\n", __func__);
-
-	sprintf(extra, "\n\n%d\n", pwfd_info->peer_rtsp_ctrlport);
-	DBG_8192D("[%s] remote port = %d\n", __func__, pwfd_info->peer_rtsp_ctrlport);
-
-	wrqu->data.length = strlen(extra);
-
-#endif /* CONFIG_WFD */
-#endif /* CONFIG_TDLS */
-
 	return ret;
 }
 
@@ -7835,25 +7251,6 @@ static int rtw_tdls_dis_result(struct ne
 
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-#ifdef CONFIG_WFD
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
-
-	DBG_8192D("[%s]\n", __func__);
-
-	if (ptdlsinfo->dev_discovered == 1) {
-		sprintf(extra, "\n\nDis = 1\n");
-		ptdlsinfo->dev_discovered = 0;
-	}
-
-	wrqu->data.length = strlen(extra);
-
-#endif /* CONFIG_WFD */
-#endif /* CONFIG_TDLS */
-
 	return ret;
 }
 
@@ -7864,25 +7261,6 @@ static int rtw_wfd_tdls_status(struct ne
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-#ifdef CONFIG_WFD
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
-
-	DBG_8192D("[%s]\n", __func__);
-
-	if (ptdlsinfo->setup_state == TDLS_LINKED_STATE)
-		sprintf(extra, "\n\nStatus = 1\n");
-	else
-		sprintf(extra, "\n\nStatus = 0\n");
-
-	wrqu->data.length = strlen(extra);
-
-#endif /* CONFIG_WFD */
-#endif /* CONFIG_TDLS */
-
 	return ret;
 }
 
@@ -7965,15 +7343,6 @@ static int rtw_tdls(struct net_device *d
 		wrqu->data.length -= 6;
 		rtw_tdls_psoff(dev, info, wrqu, &extra[6]);
 	}
-#ifdef CONFIG_WFD
-	else if (!memcmp(extra, "setip =", 6)) {
-		wrqu->data.length -= 6;
-		rtw_tdls_setip(dev, info, wrqu, &extra[6]);
-	} else if (!memcmp(extra, "tprobe =", 6)) {
-		issue_tunneled_probe_req((struct rtw_adapter *)rtw_netdev_priv(dev));
-	}
-#endif /* CONFIG_WFD */
-
 #endif /* CONFIG_TDLS */
 
 	return ret;
@@ -7983,23 +7352,6 @@ static int rtw_tdls_get(struct net_devic
 			struct iw_request_info *info,
 			union iwreq_data *wrqu, char *extra)
 {
-#ifdef CONFIG_WFD
-
-	DBG_8192D("[%s] extra = %s\n", __func__, (char *)wrqu->data.pointer);
-
-	if (!memcmp(wrqu->data.pointer, "ip", 2))
-		rtw_tdls_getip(dev, info, wrqu, extra);
-	if (!memcmp(wrqu->data.pointer, "port", 4))
-		rtw_tdls_getport(dev, info, wrqu, extra);
-
-	/* WFDTDLS, for sigma test */
-	if (!memcmp(wrqu->data.pointer, "dis", 3))
-		rtw_tdls_dis_result(dev, info, wrqu, extra);
-	if (!memcmp(wrqu->data.pointer, "status", 6))
-		rtw_wfd_tdls_status(dev, info, wrqu, extra);
-
-#endif /* CONFIG_WFD */
-
 	return 0;
 }
 
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -1117,10 +1117,6 @@ u8 rtw_init_drv_sw(struct rtw_adapter *p
 	#ifdef CONFIG_IOCTL_CFG80211
 	rtw_init_cfg80211_wifidirect_info(padapter);
 	#endif
-#ifdef CONFIG_WFD
-	if (rtw_init_wifi_display_info(padapter) == _FAIL)
-		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init init_wifi_display_info\n"));
-#endif
 #endif /* CONFIG_P2P */
 
 	if (init_mlme_ext_priv(padapter) == _FAIL)
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -443,63 +443,6 @@ int rtw_android_priv_cmd(struct net_devi
 	}
 #endif /* CONFIG_IOCTL_CFG80211 */
 
-#ifdef CONFIG_WFD
-	case ANDROID_WIFI_CMD_WFD_ENABLE:
-	{
-		/*	Commented by Albert 2012/07/24 */
-		/*	We can enable the WFD function by using the following command: */
-		/*	wpa_cli driver wfd-enable */
-
-		struct wifi_display_info		*pwfd_info;
-		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
-
-		pwfd_info = &padapter->wfd_info;
-		pwfd_info->wfd_enable = true;
-		break;
-	}
-	case ANDROID_WIFI_CMD_WFD_DISABLE:
-	{
-		/*	Commented by Albert 2012/07/24 */
-		/*	We can disable the WFD function by using the following command: */
-		/*	wpa_cli driver wfd-disable */
-
-		struct wifi_display_info		*pwfd_info;
-		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
-
-		pwfd_info = &padapter->wfd_info;
-		pwfd_info->wfd_enable = false;
-		break;
-	}
-	case ANDROID_WIFI_CMD_WFD_SET_TCPPORT:
-	{
-		/*	Commented by Albert 2012/07/24 */
-		/*	We can set the tcp port number by using the following command: */
-		/*	wpa_cli driver wfd-set-tcpport = 554 */
-
-		struct wifi_display_info		*pwfd_info;
-		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
-
-		pwfd_info = &padapter->wfd_info;
-		pwfd_info->rtsp_ctrlport = (u16) get_int_from_command(priv_cmd.buf);
-		break;
-	}
-	case ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT:
-		break;
-	case ANDROID_WIFI_CMD_WFD_SET_DEVTYPE:
-	{
-		/*	Commented by Albert 2012/08/28 */
-		/*	Specify the WFD device type (WFD source/primary sink) */
-
-		struct wifi_display_info		*pwfd_info;
-		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
-
-		pwfd_info = &padapter->wfd_info;
-		pwfd_info->wfd_device_type = (u8) get_int_from_command(priv_cmd.buf);
-
-		pwfd_info->wfd_device_type &= WFD_DEVINFO_DUAL;
-		break;
-	}
-#endif
 	default:
 		DBG_8192D("Unknown PRIVATE command %s - ignored\n", command);
 		snprintf(command, 3, "OK");

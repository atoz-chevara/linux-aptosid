From 8bce1c2e80c9652ae4e570fbbc8a125115f8a247 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Thu, 10 Apr 2014 22:04:13 -0500
Subject: [PATCH 469/470] rtl8192du: Remove all the P2P code

This code can be duplicated with hostapd and wpa_supplicant.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 Makefile                |    1 -
 core/rtw_ap.c           |    9 -
 core/rtw_cmd.c          |   45 -
 core/rtw_ieee80211.c    |  220 ---
 core/rtw_mlme.c         |   14 +-
 core/rtw_mlme_ext.c     | 4017 ++---------------------------------------------
 core/rtw_p2p.c          | 2224 --------------------------
 core/rtw_pwrctrl.c      |   26 +-
 core/rtw_wlan_util.c    |    8 -
 hal/rtl8192du_xmit.c    |   23 +-
 include/autoconf.h      |    2 -
 include/drv_types.h     |    4 -
 include/ieee80211.h     |   10 -
 include/rtl8192d_cmd.h  |    3 -
 include/rtl8192d_hal.h  |    3 -
 include/rtw_cmd.h       |    9 +-
 include/rtw_mlme_ext.h  |    9 -
 include/sta_info.h      |   16 -
 os_dep/ioctl_cfg80211.c |  690 +-------
 os_dep/ioctl_linux.c    | 1626 +------------------
 os_dep/os_intfs.c       |   44 +-
 os_dep/usb_intf.c       |    3 -
 22 files changed, 186 insertions(+), 8820 deletions(-)
 delete mode 100644 core/rtw_p2p.c

--- a/drivers/staging/rtl8192du/Makefile
+++ b/drivers/staging/rtl8192du/Makefile
@@ -51,7 +51,6 @@ rtk_core :=			\
 		core/rtw_ioctl_set.o \
 		core/rtw_mlme.o \
 		core/rtw_mlme_ext.o \
-		core/rtw_p2p.o \
 		core/rtw_pwrctrl.o \
 		core/rtw_recv.o \
 		core/rtw_rf.o \
--- a/drivers/staging/rtl8192du/core/rtw_ap.c
+++ b/drivers/staging/rtl8192du/core/rtw_ap.c
@@ -754,9 +754,6 @@ static void start_bss_network(struct rtw
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wlan_bssid_ex *pnetwork_mlmeext = &(pmlmeinfo->network);
 	struct HT_info_element *pht_info = NULL;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-#endif /* CONFIG_92D_P2P */
 	u8 *p;
 	u8 val8, cur_channel, cur_bwmode, cur_ch_offset;
 	u16 bcn_interval;
@@ -1023,12 +1020,6 @@ static void start_bss_network(struct rtw
 	/* let pnetwork_mlmeext == pnetwork_mlme. */
 	memcpy(pnetwork_mlmeext, pnetwork, pnetwork->Length);
 
-#ifdef CONFIG_92D_P2P
-	memcpy(pwdinfo->p2p_group_ssid, pnetwork->Ssid.Ssid,
-	       pnetwork->Ssid.SsidLength);
-	pwdinfo->p2p_group_ssid_len = pnetwork->Ssid.SsidLength;
-#endif /* CONFIG_92D_P2P */
-
 	if (pmlmeext->bstart_bss) {
 		update_beacon(padapter, _TIM_IE_, NULL, false);
 
--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -1645,45 +1645,6 @@ static void power_saving_wk_hdl(struct r
 	 rtw_ps_processor(padapter);
 }
 
-#ifdef CONFIG_92D_P2P
-u8 p2p_protocol_wk_cmd(struct rtw_adapter *padapter, int intcmdtype)
-{
-	struct cmd_obj *ph2c;
-	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8 res = 1;
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		return res;
-
-	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
-	if (ph2c == NULL) {
-		res = 0;
-		goto exit;
-	}
-
-	pdrvextra_cmd_parm = kzalloc(sizeof(*pdrvextra_cmd_parm), GFP_ATOMIC);
-	if (pdrvextra_cmd_parm == NULL) {
-		kfree(ph2c);
-		res = 0;
-		goto exit;
-	}
-
-	pdrvextra_cmd_parm->ec_id = P2P_PROTO_WK_CID;
-	pdrvextra_cmd_parm->type_size = intcmdtype;/* As the command type. */
-	pdrvextra_cmd_parm->pbuf = NULL;	/* Must be NULL here */
-
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm,
-				   GEN_CMD_CODE(_SET_DRV_EXTRA));
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-exit:
-
-	return res;
-}
-#endif /* CONFIG_92D_P2P */
-
 u8 rtw_ps_cmd(struct rtw_adapter *padapter)
 {
 	struct cmd_obj *ppscmd;
@@ -1862,12 +1823,6 @@ u8 rtw_drvextra_cmd_hdl(struct rtw_adapt
 	case LPS_CTRL_WK_CID:
 		lps_ctrl_wk_hdl(padapter, (u8)pdrvextra_cmd->type_size);
 		break;
-#ifdef CONFIG_92D_P2P
-	case P2P_PROTO_WK_CID:
-		/*	I used the type_size as the type command */
-		p2p_protocol_wk_hdl(padapter, pdrvextra_cmd->type_size);
-		break;
-#endif
 #ifdef CONFIG_92D_AP_MODE
 	case CHECK_HIQ_WK_CID:
 		rtw_chk_hi_queue_hdl(padapter);
--- a/drivers/staging/rtl8192du/core/rtw_ieee80211.c
+++ b/drivers/staging/rtl8192du/core/rtw_ieee80211.c
@@ -1113,9 +1113,6 @@ void dump_ies(u8 *buf, u32 buf_len)
 		len = *(pos+1);
 
 		DBG_8192D("%s ID:%u, LEN:%u\n", __func__, id, len);
-		#ifdef CONFIG_92D_P2P
-		dump_p2p_ie(pos, len);
-		#endif
 		dump_wps_ie(pos, len);
 
 		pos += (2+len);
@@ -1146,223 +1143,6 @@ void dump_wps_ie(u8 *ie, u32 ie_len)
 	}
 }
 
-#ifdef CONFIG_92D_P2P
-void dump_p2p_ie(u8 *ie, u32 ie_len)
-{
-	u8 *pos = (u8 *)ie;
-	u8 id;
-	u16 len;
-
-	u8 *p2p_ie;
-	uint p2p_ielen;
-
-	p2p_ie = rtw_get_p2p_ie(ie, ie_len, NULL, &p2p_ielen);
-	if (p2p_ie != ie || p2p_ielen == 0)
-		return;
-
-	pos += 6;
-	while (pos-ie < ie_len) {
-		id = *pos;
-		len = RTW_GET_LE16(pos+1);
-
-		DBG_8192D("%s ID:%u, LEN:%u\n", __func__, id, len);
-
-		pos += (3 + len);
-	}
-}
-
-/**
- * rtw_get_p2p_ie - Search P2P IE from a series of IEs
- * @in_ie: Address of IEs to search
- * @in_len: Length limit from in_ie
- * @p2p_ie: If not NULL and P2P IE is found, P2P IE will be copied to the buf starting from p2p_ie
- * @p2p_ielen: If not NULL and P2P IE is found, will set to the length of the entire P2P IE
- *
- * Returns: The address of the P2P IE found, or NULL
- */
-u8 *rtw_get_p2p_ie(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen)
-{
-	uint cnt = 0;
-	u8 *p2p_ie_ptr;
-	u8 eid, p2p_oui[4] = {0x50, 0x6F, 0x9A, 0x09};
-
-	if (p2p_ielen != NULL)
-		*p2p_ielen = 0;
-
-	while (cnt < in_len) {
-		eid = in_ie[cnt];
-		if ((in_len < 0) || (cnt > MAX_IE_SZ)) {
-			dump_stack();
-			return NULL;
-		}
-		if ((eid == _VENDOR_SPECIFIC_IE_) &&
-		    (!memcmp(&in_ie[cnt+2], p2p_oui, 4))) {
-			p2p_ie_ptr = in_ie + cnt;
-
-			if (p2p_ie != NULL)
-				memcpy(p2p_ie, &in_ie[cnt], in_ie[cnt + 1] + 2);
-
-			if (p2p_ielen != NULL)
-				*p2p_ielen = in_ie[cnt + 1] + 2;
-
-			return p2p_ie_ptr;
-
-			break;
-		} else {
-			cnt += in_ie[cnt + 1] + 2; /* goto next */
-		}
-	}
-	return NULL;
-}
-
-/**
- * rtw_get_p2p_attr - Search a specific P2P attribute from a given P2P IE
- * @p2p_ie: Address of P2P IE to search
- * @p2p_ielen: Length limit from p2p_ie
- * @target_attr_id: The attribute ID of P2P attribute to search
- * @buf_attr: If not NULL and the P2P attribute is found, P2P attribute will be copied to the buf starting from buf_attr
- * @len_attr: If not NULL and the P2P attribute is found, will set to the length of the entire P2P attribute
- *
- * Returns: the address of the specific WPS attribute found, or NULL
- */
-u8 *rtw_get_p2p_attr(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id, u8 *buf_attr, u32 *len_attr)
-{
-	u8 *attr_ptr = NULL;
-	u8 *target_attr_ptr = NULL;
-	u8 p2p_oui[4] = {0x50, 0x6F, 0x9A, 0x09};
-
-	if (len_attr)
-		*len_attr = 0;
-
-	if (!p2p_ie || (p2p_ie[0] != _VENDOR_SPECIFIC_IE_) ||
-	    (memcmp(p2p_ie + 2, p2p_oui, 4)))
-		return attr_ptr;
-
-	/*  6 = 1(Element ID) + 1(Length) + 3 (OUI) + 1(OUI Type) */
-	attr_ptr = p2p_ie + 6; /* goto first attr */
-
-	while (attr_ptr - p2p_ie < p2p_ielen) {
-		/*  3 = 1(Attribute ID) + 2(Length) */
-		u8 attr_id = *attr_ptr;
-		u16 attr_data_len = RTW_GET_LE16(attr_ptr + 1);
-		u16 attr_len = attr_data_len + 3;
-
-		if (attr_id == target_attr_id) {
-			target_attr_ptr = attr_ptr;
-
-			if (buf_attr)
-				memcpy(buf_attr, attr_ptr, attr_len);
-
-			if (len_attr)
-				*len_attr = attr_len;
-
-			break;
-		} else {
-			attr_ptr += attr_len; /* goto next */
-		}
-	}
-
-	return target_attr_ptr;
-}
-
-/**
- * rtw_get_p2p_attr_content - Search a specific P2P attribute content from a given P2P IE
- * @p2p_ie: Address of P2P IE to search
- * @p2p_ielen: Length limit from p2p_ie
- * @target_attr_id: The attribute ID of P2P attribute to search
- * @buf_content: If not NULL and the P2P attribute is found, P2P attribute content will be copied to the buf starting from buf_content
- * @len_content: If not NULL and the P2P attribute is found, will set to the length of the P2P attribute content
- *
- * Returns: the address of the specific P2P attribute content found, or NULL
- */
-u8 *rtw_get_p2p_attr_content(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id, u8 *buf_content, uint *len_content)
-{
-	u8 *attr_ptr;
-	u32 attr_len;
-
-	if (len_content)
-		*len_content = 0;
-
-	attr_ptr = rtw_get_p2p_attr(p2p_ie, p2p_ielen, target_attr_id, NULL, &attr_len);
-
-	if (attr_ptr && attr_len) {
-		if (buf_content)
-			memcpy(buf_content, attr_ptr+3, attr_len-3);
-
-		if (len_content)
-			*len_content = attr_len-3;
-
-		return attr_ptr+3;
-	}
-
-	return NULL;
-}
-
-u32 rtw_set_p2p_attr_content(u8 *pbuf, u8 attr_id, u16 attr_len, u8 *pdata_attr)
-{
-	u32 a_len;
-
-	*pbuf = attr_id;
-
-	RTW_PUT_LE16(pbuf + 1, attr_len);
-
-	if (pdata_attr)
-		memcpy(pbuf + 3, pdata_attr, attr_len);
-
-	a_len = attr_len + 3;
-
-	return a_len;
-}
-
-static uint rtw_p2p_attr_remove(u8 *ie, uint ielen_ori, u8 attr_id)
-{
-	u8 *target_attr;
-	u32 target_attr_len;
-	uint ielen = ielen_ori;
-
-	while (1) {
-		target_attr = rtw_get_p2p_attr(ie, ielen, attr_id, NULL, &target_attr_len);
-		if (target_attr && target_attr_len) {
-			u8 *next_attr = target_attr+target_attr_len;
-			uint remain_len = ielen-(next_attr-ie);
-
-			memset(target_attr, 0, target_attr_len);
-			memcpy(target_attr, next_attr, remain_len);
-			memset(target_attr+remain_len, 0, target_attr_len);
-			*(ie+1) -= target_attr_len;
-			ielen -= target_attr_len;
-		} else {
-			break;
-		}
-	}
-
-	return ielen;
-}
-
-void rtw_wlan_bssid_ex_remove_p2p_attr(struct wlan_bssid_ex *bss_ex, u8 attr_id)
-{
-	u8 *p2p_ie;
-	uint p2p_ielen, p2p_ielen_ori;
-
-	p2p_ie = rtw_get_p2p_ie(bss_ex->IEs+_FIXED_IE_LENGTH_,
-				bss_ex->IELength-_FIXED_IE_LENGTH_,
-				NULL, &p2p_ielen_ori);
-	if (p2p_ie) {
-		p2p_ielen = rtw_p2p_attr_remove(p2p_ie, p2p_ielen_ori, attr_id);
-		if (p2p_ielen != p2p_ielen_ori) {
-			u8 *next_ie_ori = p2p_ie+p2p_ielen_ori;
-			u8 *next_ie = p2p_ie+p2p_ielen;
-			uint remain_len = bss_ex->IELength-(next_ie_ori-bss_ex->IEs);
-
-			memcpy(next_ie, next_ie_ori, remain_len);
-			memset(next_ie+remain_len, 0, p2p_ielen_ori-p2p_ielen);
-			bss_ex->IELength -= p2p_ielen_ori-p2p_ielen;
-		}
-	}
-}
-
-#endif /* CONFIG_92D_P2P */
-
 int ieee80211_is_empty_essid(const char *essid, int essid_len)
 {
 	/* Single white space is for Linksys APs */
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -692,10 +692,6 @@ exit:
 static void rtw_add_network(struct rtw_adapter *adapter,
 			    struct wlan_bssid_ex *pnetwork)
 {
-#if defined(CONFIG_92D_P2P)
-	rtw_wlan_bssid_ex_remove_p2p_attr(pnetwork, P2P_ATTR_GROUP_INFO);
-#endif
-
 	update_current_network(adapter, pnetwork);
 
 	rtw_update_scanned_network(adapter, pnetwork);
@@ -1835,14 +1831,8 @@ void rtw_dynamic_check_timer_handlder(st
 	rtw_dynamic_chk_wk_cmd(adapter);
 
 	if (pregistrypriv->wifi_spec == 1) {
-#ifdef CONFIG_92D_P2P
-		struct wifidirect_info *pwdinfo = &adapter->wdinfo;
-		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-#endif
-		{
-			/* auto site survey */
-			rtw_auto_scan_handler(adapter);
-		}
+		/* auto site survey */
+		rtw_auto_scan_handler(adapter);
 	}
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -601,29 +601,6 @@ void mgt_dispatcher(struct rtw_adapter *
 #endif
 }
 
-#ifdef CONFIG_92D_P2P
-static u32 p2p_listen_state_process(struct rtw_adapter *adapt, unsigned char *da)
-{
-	bool response = true;
-
-	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled == false ||
-	    adapt->mlmepriv.wps_probe_resp_ie == NULL ||
-	    adapt->mlmepriv.p2p_probe_resp_ie == NULL) {
-		DBG_8192D
-		    ("DON'T issue_probersp_p2p: p2p_enabled:%d, wps_probe_resp_ie:%p, p2p_probe_resp_ie:%p\n",
-		     wdev_to_priv(adapt->rtw_wdev)->p2p_enabled,
-		     adapt->mlmepriv.wps_probe_resp_ie,
-		     adapt->mlmepriv.p2p_probe_resp_ie);
-		response = false;
-	}
-
-	if (response == true)
-		issue_probersp_p2p(adapt, da);
-
-	return 1;
-}
-#endif /* CONFIG_92D_P2P */
-
 /****************************************************************************
 
 Following are the callback functions for each subtype of the management frames
@@ -643,43 +620,6 @@ unsigned int OnProbeReq(struct rtw_adapt
 	uint len = precv_frame->len;
 	u8 is_valid_p2p_probereq = false;
 
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-	u8 wifi_test_chk_rate = 1;
-
-	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) &&
-	    !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE) &&
-	    !rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) &&
-	    !rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH) &&
-	    !rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN)) {
-		/*      mcs_rate = 0 -> CCK 1M rate */
-		/*      mcs_rate = 1 -> CCK 2M rate */
-		/*      mcs_rate = 2 -> CCK 5.5M rate */
-		/*      mcs_rate = 3 -> CCK 11M rate */
-		/*      In the P2P mode, the driver should not support the CCK rate */
-
-		/*      IOT issue: Google Nexus7 use 1M rate to send p2p_probe_req after GO nego completed and Nexus7 is client */
-		if (wifi_test_chk_rate == 1) {
-			is_valid_p2p_probereq = process_probe_req_p2p_ie(pwdinfo, pframe, len);
-			if (is_valid_p2p_probereq == true) {
-				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE)) {
-					p2p_listen_state_process(adapt,
-								 get_sa
-								 (pframe));
-
-					return 1;
-				}
-
-				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-					goto _continue;
-				}
-			}
-		}
-	}
-
-_continue:
-#endif /* CONFIG_92D_P2P */
-
 	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
 		return 1;
 	}
@@ -731,71 +671,6 @@ unsigned int OnProbeRsp(struct rtw_adapt
 			struct recv_frame_hdr *precv_frame)
 {
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &adapt->wdinfo;
-	u8 *pframe = precv_frame->rx_data;
-#endif
-
-#ifdef CONFIG_92D_P2P
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ)) {
-		if (pwdinfo->tx_prov_disc_info.benable) {
-			if (!memcmp
-			    (pwdinfo->tx_prov_disc_info.peerIFAddr,
-			     GetAddr2Ptr(pframe), ETH_ALEN)) {
-				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)) {
-					pwdinfo->tx_prov_disc_info.benable =
-					    false;
-					issue_p2p_provision_request(adapt,
-								    pwdinfo->
-								    tx_prov_disc_info.
-								    ssid.Ssid,
-								    pwdinfo->
-								    tx_prov_disc_info.
-								    ssid.
-								    SsidLength,
-								    pwdinfo->
-								    tx_prov_disc_info.
-								    peerDevAddr);
-				} else
-				    if (rtw_p2p_chk_role (pwdinfo, P2P_ROLE_DEVICE) ||
-					rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-					pwdinfo->tx_prov_disc_info.benable = false;
-					issue_p2p_provision_request(adapt,
-								    NULL, 0,
-								    pwdinfo->
-								    tx_prov_disc_info.
-								    peerDevAddr);
-				}
-			}
-		}
-		return 1;
-	} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING)) {
-		if (true == pwdinfo->nego_req_info.benable) {
-			DBG_8192D("[%s] P2P State is GONEGO ING!\n", __func__);
-			if (!memcmp
-			    (pwdinfo->nego_req_info.peerDevAddr,
-			     GetAddr2Ptr(pframe), ETH_ALEN)) {
-				pwdinfo->nego_req_info.benable = false;
-				issue_p2p_GO_request(adapt,
-						     pwdinfo->nego_req_info.
-						     peerDevAddr);
-			}
-		}
-	} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ)) {
-		if (true == pwdinfo->invitereq_info.benable) {
-			DBG_8192D("[%s] P2P_STATE_TX_INVITE_REQ!\n", __func__);
-			if (!memcmp
-			    (pwdinfo->invitereq_info.peer_macaddr,
-			     GetAddr2Ptr(pframe), ETH_ALEN)) {
-				pwdinfo->invitereq_info.benable = false;
-				issue_p2p_invitation_request(adapt,
-							     pwdinfo->
-							     invitereq_info.
-							     peer_macaddr);
-			}
-		}
-	}
-#endif
 
 	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {
 		report_survey_event(adapt, precv_frame);
@@ -1205,12 +1080,6 @@ unsigned int OnAssocReq(struct rtw_adapt
 	struct sta_priv *pstapriv = &adapt->stapriv;
 	u8 *pframe = precv_frame->rx_data;
 	uint pkt_len = precv_frame->len;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-	u8 p2p_status_code = P2P_STATUS_SUCCESS;
-	u8 *p2pie;
-	u32 p2pielen = 0;
-#endif /* CONFIG_92D_P2P */
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) &&
@@ -1587,23 +1456,6 @@ unsigned int OnAssocReq(struct rtw_adapt
 	if (status != _STATS_SUCCESSFUL_)
 		goto OnAssocReqFail;
 
-#ifdef CONFIG_92D_P2P
-	pstat->is_p2p_device = false;
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-		p2pie = rtw_get_p2p_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, pkt_len - WLAN_HDR_A3_LEN - ie_offset, NULL, &p2pielen);
-		if (p2pie) {
-			pstat->is_p2p_device = true;
-			p2p_status_code = (u8)process_assoc_req_p2p_ie(pwdinfo, pframe, pkt_len, pstat);
-			if (p2p_status_code > 0) {
-				pstat->p2p_status_code = p2p_status_code;
-				status = _STATS_CAP_FAIL_;
-				goto OnAssocReqFail;
-			}
-		}
-	}
-	pstat->p2p_status_code = p2p_status_code;
-#endif /* CONFIG_92D_P2P */
-
 	/* TODO: identify_proprietary_vendor_ie(); */
 	/*  Realtek proprietary IE */
 	/*  identify if this is Broadcom sta */
@@ -1799,9 +1651,6 @@ unsigned int OnDeAuth(struct rtw_adapter
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	u8 *pframe = precv_frame->rx_data;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-#endif /* CONFIG_92D_P2P */
 
 	/* check A3 */
 	if (!
@@ -1810,13 +1659,6 @@ unsigned int OnDeAuth(struct rtw_adapter
 	      ETH_ALEN)))
 		return 1;
 
-#ifdef CONFIG_92D_P2P
-	if (pwdinfo->rx_invitereq_info.scan_op_ch_only) {
-		del_timer_sync(&pwdinfo->reset_ch_sitesurvey);
-		_set_timer(&pwdinfo->reset_ch_sitesurvey, 10);
-	}
-#endif /* CONFIG_92D_P2P */
-
 	reason = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));
 
 	DBG_8192D("%s Reason code(%d)\n", __func__, reason);
@@ -1864,9 +1706,6 @@ unsigned int OnDisassoc(struct rtw_adapt
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	u8 *pframe = precv_frame->rx_data;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-#endif /* CONFIG_92D_P2P */
 
 	/* check A3 */
 	if (!
@@ -1875,13 +1714,6 @@ unsigned int OnDisassoc(struct rtw_adapt
 	      ETH_ALEN)))
 		return 1;
 
-#ifdef CONFIG_92D_P2P
-	if (pwdinfo->rx_invitereq_info.scan_op_ch_only) {
-		del_timer_sync(&pwdinfo->reset_ch_sitesurvey);
-		_set_timer(&pwdinfo->reset_ch_sitesurvey, 10);
-	}
-#endif /* CONFIG_92D_P2P */
-
 	reason = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));
 
 	DBG_8192D("%s Reason code(%d)\n", __func__, reason);
@@ -2024,2538 +1856,23 @@ unsigned int OnAction_back(struct rtw_ad
 				reason_code = RTW_GET_LE16(&frame_body[4]);
 			} else if ((frame_body[3] & BIT(3)) == BIT(3)) {
 				tid = (frame_body[3] >> 4) & 0x0F;
-
-				preorder_ctrl = &psta->recvreorder_ctrl[tid];
-				preorder_ctrl->enable = false;
-				preorder_ctrl->indicate_seq = 0xffff;
-			}
-
-			DBG_8192D("%s(): DELBA: %x(%x)\n", __func__,
-				  pmlmeinfo->agg_enable_bitmap, reason_code);
-			/* todo: how to notify the host while receiving DELETE BA */
-			break;
-		default:
-			break;
-		}
-	}
-	return 1;
-}
-
-#ifdef CONFIG_92D_P2P
-
-static int get_reg_classes_full_count(struct p2p_channels channel_list)
-{
-	int cnt = 0;
-	int i;
-
-	for (i = 0; i < channel_list.reg_classes; i++) {
-		cnt += channel_list.reg_class[i].channels;
-	}
-
-	return cnt;
-}
-
-void issue_p2p_GO_request(struct rtw_adapter *adapt, u8 *raddr)
-{
-	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
-	u8 action = P2P_PUB_ACTION_ACTION;
-	__be32 p2poui = cpu_to_be32(P2POUI);
-	u8 oui_subtype = P2P_GO_NEGO_REQ;
-	u8 wpsie[255] = { 0x00 }, p2pie[255] = {0x00};
-	u8 wpsielen = 0, p2pielen = 0;
-	u16 len_channellist_attr = 0;
-	struct xmit_frame *pmgntframe;
-	struct pkt_attrib *pattrib;
-	unsigned char *pframe;
-	struct ieee80211_hdr *pwlanhdr;
-	unsigned short *fctrl;
-	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
-	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	DBG_8192D("[%s] In\n", __func__);
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(adapt, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-
-	memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
-	memcpy(pwlanhdr->addr3, myid(&(adapt->eeprompriv)), ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
-
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 4, (unsigned char *)&(p2poui),
-			     &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pwdinfo->negotiation_dialog_token = 1;	/*      Initialize the dialog value */
-	pframe =
-	    rtw_set_fixed_ie(pframe, 1, &pwdinfo->negotiation_dialog_token,
-			     &(pattrib->pktlen));
-
-	/*      WPS Section */
-	wpsielen = 0;
-	/*      WPS OUI */
-	*(__be32 *)(wpsie) = cpu_to_be32(WPSOUI);
-	wpsielen += 4;
-
-	/*      WPS version */
-	/*      Type: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
-	wpsielen += 2;
-
-	/*      Length: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
-	wpsielen += 2;
-
-	/*      Value: */
-	wpsie[wpsielen++] = WPS_VERSION_1;	/*      Version 1.0 */
-
-	/*      Device Password ID */
-	/*      Type: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
-	wpsielen += 2;
-
-	/*      Length: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
-	wpsielen += 2;
-
-	/*      Value: */
-
-	if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN) {
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_USER_SPEC);
-	} else if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_SELF_DISPLAY_PIN) {
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);
-	} else if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PBC) {
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_PBC);
-	}
-
-	wpsielen += 2;
-
-	pframe =
-	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen,
-		       (unsigned char *)wpsie, &pattrib->pktlen);
-
-	/*      P2P IE Section. */
-
-	/*      P2P OUI */
-	p2pielen = 0;
-	p2pie[p2pielen++] = 0x50;
-	p2pie[p2pielen++] = 0x6F;
-	p2pie[p2pielen++] = 0x9A;
-	p2pie[p2pielen++] = 0x09;	/*      WFA P2P v1.0 */
-
-	/*      Commented by Albert 20110306 */
-	/*      According to the P2P Specification, the group negoitation request frame should contain 9 P2P attributes */
-	/*      1. P2P Capability */
-	/*      2. Group Owner Intent */
-	/*      3. Configuration Timeout */
-	/*      4. Listen Channel */
-	/*      5. Extended Listen Timing */
-	/*      6. Intended P2P Interface Address */
-	/*      7. Channel List */
-	/*      8. P2P Device Info */
-	/*      9. Operating Channel */
-
-	/*      P2P Capability */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Device Capability Bitmap, 1 byte */
-	p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
-
-	/*      Group Capability Bitmap, 1 byte */
-	if (pwdinfo->persistent_supported) {
-		p2pie[p2pielen++] =
-		    P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
-	} else {
-		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
-	}
-
-	/*      Group Owner Intent */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_GO_INTENT;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Todo the tie breaker bit. */
-	p2pie[p2pielen++] = ((pwdinfo->intent << 1) | BIT(0));
-
-	/*      Configuration Timeout */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
-	p2pielen += 2;
-
-	/*      Value: */
-	p2pie[p2pielen++] = 200;	/*      2 seconds needed to be the P2P GO */
-	p2pie[p2pielen++] = 200;	/*      2 seconds needed to be the P2P Client */
-
-	/*      Listen Channel */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_LISTEN_CH;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Country String */
-	p2pie[p2pielen++] = 'X';
-	p2pie[p2pielen++] = 'X';
-
-	/*      The third byte should be set to 0x04. */
-	/*      Described in the "Operating Channel Attribute" section. */
-	p2pie[p2pielen++] = 0x04;
-
-	/*      Operating Class */
-	p2pie[p2pielen++] = 0x51;	/*      Copy from SD7 */
-
-	/*      Channel Number */
-	p2pie[p2pielen++] = pwdinfo->listen_channel;	/*      listening channel number */
-
-	/*      Extended Listen Timing ATTR */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0004);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Availability Period */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
-	p2pielen += 2;
-
-	/*      Availability Interval */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
-	p2pielen += 2;
-
-	/*      Intended P2P Interface Address */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_INTENTED_IF_ADDR;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
-	p2pielen += 2;
-
-	/*      Value: */
-	memcpy(p2pie + p2pielen, myid(&adapt->eeprompriv), ETH_ALEN);
-	p2pielen += ETH_ALEN;
-
-	/*      Channel List */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
-
-	/*  Length: */
-	/*  Country String(3) */
-	/*  + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?) */
-	/*  + number of channels in all classes */
-	len_channellist_attr = 3
-	    + (1 + 1) * (u16) (pmlmeext->channel_list.reg_classes)
-	    + get_reg_classes_full_count(pmlmeext->channel_list);
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(5 + 1);
-	} else {
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
-	}
-#else
-
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
-
-#endif
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Country String */
-	p2pie[p2pielen++] = 'X';
-	p2pie[p2pielen++] = 'X';
-
-	/*      The third byte should be set to 0x04. */
-	/*      Described in the "Operating Channel Attribute" section. */
-	p2pie[p2pielen++] = 0x04;
-
-	/*      Channel Entry List */
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-		struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
-		struct mlme_ext_priv *pbuddy_mlmeext =
-		    &pbuddy_adapter->mlmeextpriv;
-
-		/*      Operating Class */
-		if (pbuddy_mlmeext->cur_channel > 14) {
-			if (pbuddy_mlmeext->cur_channel >= 149) {
-				p2pie[p2pielen++] = 0x7c;
-			} else {
-				p2pie[p2pielen++] = 0x73;
-			}
-		} else {
-			p2pie[p2pielen++] = 0x51;
-		}
-
-		/*      Number of Channels */
-		/*      Just support 1 channel and this channel is AP's channel */
-		p2pie[p2pielen++] = 1;
-
-		/*      Channel List */
-		p2pie[p2pielen++] = pbuddy_mlmeext->cur_channel;
-	} else {
-		int i, j;
-		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-			/*      Operating Class */
-			p2pie[p2pielen++] =
-			    pmlmeext->channel_list.reg_class[j].reg_class;
-
-			/*      Number of Channels */
-			p2pie[p2pielen++] =
-			    pmlmeext->channel_list.reg_class[j].channels;
-
-			/*      Channel List */
-			for (i = 0;
-			     i < pmlmeext->channel_list.reg_class[j].channels;
-			     i++) {
-				p2pie[p2pielen++] =
-				    pmlmeext->channel_list.reg_class[j].
-				    channel[i];
-			}
-		}
-	}
-#else /*  CONFIG_CONCURRENT_MODE */
-	{
-		int i, j;
-		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-			/*      Operating Class */
-			p2pie[p2pielen++] =
-			    pmlmeext->channel_list.reg_class[j].reg_class;
-
-			/*      Number of Channels */
-			p2pie[p2pielen++] =
-			    pmlmeext->channel_list.reg_class[j].channels;
-
-			/*      Channel List */
-			for (i = 0;
-			     i < pmlmeext->channel_list.reg_class[j].channels;
-			     i++) {
-				p2pie[p2pielen++] =
-				    pmlmeext->channel_list.reg_class[j].
-				    channel[i];
-			}
-		}
-	}
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-	/*      Device Info */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
-
-	/*      Length: */
-	/*      21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
-	/*      + NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
-	*(__le16 *)(p2pie + p2pielen) =
-	    cpu_to_le16(21 + pwdinfo->device_name_len);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      P2P Device Address */
-	memcpy(p2pie + p2pielen, myid(&adapt->eeprompriv), ETH_ALEN);
-	p2pielen += ETH_ALEN;
-
-	/*      Config Method */
-	/*      This field should be big endian. Noted by P2P specification. */
-
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
-
-	p2pielen += 2;
-
-	/*      Primary Device Type */
-	/*      Category ID */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
-	p2pielen += 2;
-
-	/*      OUI */
-	*(__be32 *)(p2pie + p2pielen) = cpu_to_be32(WPSOUI);
-	p2pielen += 4;
-
-	/*      Sub Category ID */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
-	p2pielen += 2;
-
-	/*      Number of Secondary Device Types */
-	p2pie[p2pielen++] = 0x00;	/*      No Secondary Device Type List */
-
-	/*      Device Name */
-	/*      Type: */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
-	p2pielen += 2;
-
-	/*      Length: */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
-	p2pielen += 2;
-
-	/*      Value: */
-	memcpy(p2pie + p2pielen, pwdinfo->device_name,
-	       pwdinfo->device_name_len);
-	p2pielen += pwdinfo->device_name_len;
-
-	/*      Operating Channel */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Country String */
-	p2pie[p2pielen++] = 'X';
-	p2pie[p2pielen++] = 'X';
-
-	/*      The third byte should be set to 0x04. */
-	/*      Described in the "Operating Channel Attribute" section. */
-	p2pie[p2pielen++] = 0x04;
-
-	/*      Operating Class */
-	if (pwdinfo->operating_channel <= 14) {
-		/*      Operating Class */
-		p2pie[p2pielen++] = 0x51;
-	} else if ((pwdinfo->operating_channel >= 36) &&
-		   (pwdinfo->operating_channel <= 48)) {
-		/*      Operating Class */
-		p2pie[p2pielen++] = 0x73;
-	} else {
-		/*      Operating Class */
-		p2pie[p2pielen++] = 0x7c;
-	}
-
-	/*      Channel Number */
-	p2pie[p2pielen++] = pwdinfo->operating_channel;	/*      operating channel number */
-
-	pframe =
-	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
-		       (unsigned char *)p2pie, &pattrib->pktlen);
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-	dump_mgntframe(adapt, pmgntframe);
-	return;
-}
-
-static void issue_p2p_GO_response(struct rtw_adapter *adapt, u8 *raddr,
-			   u8 *frame_body, uint len, u8 result)
-{
-	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
-	u8 action = P2P_PUB_ACTION_ACTION;
-	__be32 p2poui = cpu_to_be32(P2POUI);
-	u8 oui_subtype = P2P_GO_NEGO_RESP;
-	u8 wpsie[255] = { 0x00 }, p2pie[255] = {
-	0x00};
-	u8 p2pielen = 0;
-	uint wpsielen = 0;
-	u16 wps_devicepassword_id = 0x0000;
-	uint wps_devicepassword_id_len = 0;
-	__be16 be_tmp;
-	u16 len_channellist_attr = 0;
-
-	struct xmit_frame *pmgntframe;
-	struct pkt_attrib *pattrib;
-	unsigned char *pframe;
-	struct ieee80211_hdr *pwlanhdr;
-	unsigned short *fctrl;
-	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
-	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	DBG_8192D("[%s] In, result = %d\n", __func__, result);
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(adapt, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-
-	memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
-	memcpy(pwlanhdr->addr3, myid(&(adapt->eeprompriv)), ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
-
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 4, (unsigned char *)&(p2poui),
-			     &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pwdinfo->negotiation_dialog_token = frame_body[7];	/*      The Dialog Token of provisioning discovery request frame. */
-	pframe =
-	    rtw_set_fixed_ie(pframe, 1, &(pwdinfo->negotiation_dialog_token),
-			     &(pattrib->pktlen));
-
-	/*      Commented by Albert 20110328 */
-	/*      Try to get the device password ID from the WPS IE of group negotiation request frame */
-	/*      WiFi Direct test plan 5.1.15 */
-	rtw_get_wps_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_,
-		       len - _PUBLIC_ACTION_IE_OFFSET_, wpsie, &wpsielen);
-	rtw_get_wps_attr_content(wpsie, wpsielen, WPS_ATTR_DEVICE_PWID,
-				 (u8 *)&be_tmp, &wps_devicepassword_id_len);
-	wps_devicepassword_id = be16_to_cpu(be_tmp);
-
-	memset(wpsie, 0x00, 255);
-	wpsielen = 0;
-
-	/*      WPS Section */
-	wpsielen = 0;
-	/*      WPS OUI */
-	*(__be32 *)(wpsie) = cpu_to_be32(WPSOUI);
-	wpsielen += 4;
-
-	/*      WPS version */
-	/*      Type: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
-	wpsielen += 2;
-
-	/*      Length: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
-	wpsielen += 2;
-
-	/*      Value: */
-	wpsie[wpsielen++] = WPS_VERSION_1;	/*      Version 1.0 */
-
-	/*      Device Password ID */
-	/*      Type: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
-	wpsielen += 2;
-
-	/*      Length: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
-	wpsielen += 2;
-
-	/*      Value: */
-	if (wps_devicepassword_id == WPS_DPID_USER_SPEC) {
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);
-	} else if (wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC) {
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_USER_SPEC);
-	} else {
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_PBC);
-	}
-	wpsielen += 2;
-
-	/*      Commented by Kurt 20120113 */
-	/*      If some device wants to do p2p handshake without sending prov_disc_req */
-	/*      We have to get peer_req_cm from here. */
-	if (!memcmp
-	    (pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req,
-	     "000", 3)) {
-		if (wps_devicepassword_id == WPS_DPID_USER_SPEC) {
-			memcpy(pwdinfo->rx_prov_disc_info.
-			       strconfig_method_desc_of_prov_disc_req, "dis",
-			       3);
-		} else if (wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC) {
-			memcpy(pwdinfo->rx_prov_disc_info.
-			       strconfig_method_desc_of_prov_disc_req, "pad",
-			       3);
-		} else {
-			memcpy(pwdinfo->rx_prov_disc_info.
-			       strconfig_method_desc_of_prov_disc_req, "pbc",
-			       3);
-		}
-	}
-
-	pframe =
-	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen,
-		       (unsigned char *)wpsie, &pattrib->pktlen);
-
-	/*      P2P IE Section. */
-
-	/*      P2P OUI */
-	p2pielen = 0;
-	p2pie[p2pielen++] = 0x50;
-	p2pie[p2pielen++] = 0x6F;
-	p2pie[p2pielen++] = 0x9A;
-	p2pie[p2pielen++] = 0x09;	/*      WFA P2P v1.0 */
-
-	/*      Commented by Albert 20100908 */
-	/*      According to the P2P Specification, the group negoitation response frame should contain 9 P2P attributes */
-	/*      1. Status */
-	/*      2. P2P Capability */
-	/*      3. Group Owner Intent */
-	/*      4. Configuration Timeout */
-	/*      5. Operating Channel */
-	/*      6. Intended P2P Interface Address */
-	/*      7. Channel List */
-	/*      8. Device Info */
-	/*      9. Group ID     (Only GO) */
-
-	/*      ToDo: */
-
-	/*      P2P Status */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_STATUS;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
-	p2pielen += 2;
-
-	/*      Value: */
-	p2pie[p2pielen++] = result;
-
-	/*      P2P Capability */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Device Capability Bitmap, 1 byte */
-
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)) {
-		/*      Commented by Albert 2011/03/08 */
-		/*      According to the P2P specification */
-		/*      if the sending device will be client, the P2P Capability should be reserved of group negotation response frame */
-		p2pie[p2pielen++] = 0;
-	} else {
-		/*      Be group owner or meet the error case */
-		p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
-	}
-
-	/*      Group Capability Bitmap, 1 byte */
-	if (pwdinfo->persistent_supported) {
-		p2pie[p2pielen++] =
-		    P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
-	} else {
-		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
-	}
-
-	/*      Group Owner Intent */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_GO_INTENT;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
-	p2pielen += 2;
-
-	/*      Value: */
-	if (pwdinfo->peer_intent & 0x01) {
-		/*      Peer's tie breaker bit is 1, our tie breaker bit should be 0 */
-		p2pie[p2pielen++] = (pwdinfo->intent << 1);
-	} else {
-		/*      Peer's tie breaker bit is 0, our tie breaker bit should be 1 */
-		p2pie[p2pielen++] = ((pwdinfo->intent << 1) | BIT(0));
-	}
-
-	/*      Configuration Timeout */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
-	p2pielen += 2;
-
-	/*      Value: */
-	p2pie[p2pielen++] = 200;	/*      2 seconds needed to be the P2P GO */
-	p2pie[p2pielen++] = 200;	/*      2 seconds needed to be the P2P Client */
-
-	/*      Operating Channel */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Country String */
-	p2pie[p2pielen++] = 'X';
-	p2pie[p2pielen++] = 'X';
-
-	/*      The third byte should be set to 0x04. */
-	/*      Described in the "Operating Channel Attribute" section. */
-	p2pie[p2pielen++] = 0x04;
-
-	/*      Operating Class */
-	if (pwdinfo->operating_channel <= 14) {
-		/*      Operating Class */
-		p2pie[p2pielen++] = 0x51;
-	} else if ((pwdinfo->operating_channel >= 36) &&
-		   (pwdinfo->operating_channel <= 48)) {
-		/*      Operating Class */
-		p2pie[p2pielen++] = 0x73;
-	} else {
-		/*      Operating Class */
-		p2pie[p2pielen++] = 0x7c;
-	}
-
-	/*      Channel Number */
-	p2pie[p2pielen++] = pwdinfo->operating_channel;	/*      operating channel number */
-
-	/*      Intended P2P Interface Address */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_INTENTED_IF_ADDR;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
-	p2pielen += 2;
-
-	/*      Value: */
-	memcpy(p2pie + p2pielen, myid(&adapt->eeprompriv), ETH_ALEN);
-	p2pielen += ETH_ALEN;
-
-	/*      Channel List */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
-
-	/*  Country String(3) */
-	/*  + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?) */
-	/*  + number of channels in all classes */
-	len_channellist_attr = 3
-	    + (1 + 1) * (u16) pmlmeext->channel_list.reg_classes
-	    + get_reg_classes_full_count(pmlmeext->channel_list);
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(5 + 1);
-	} else {
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
-	}
-#else
-
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
-
-#endif
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Country String */
-	p2pie[p2pielen++] = 'X';
-	p2pie[p2pielen++] = 'X';
-
-	/*      The third byte should be set to 0x04. */
-	/*      Described in the "Operating Channel Attribute" section. */
-	p2pie[p2pielen++] = 0x04;
-
-	/*      Channel Entry List */
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-		struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
-		struct mlme_ext_priv *pbuddy_mlmeext =
-		    &pbuddy_adapter->mlmeextpriv;
-
-		/*      Operating Class */
-		if (pbuddy_mlmeext->cur_channel > 14) {
-			if (pbuddy_mlmeext->cur_channel >= 149) {
-				p2pie[p2pielen++] = 0x7c;
-			} else {
-				p2pie[p2pielen++] = 0x73;
-			}
-		} else {
-			p2pie[p2pielen++] = 0x51;
-		}
-
-		/*      Number of Channels */
-		/*      Just support 1 channel and this channel is AP's channel */
-		p2pie[p2pielen++] = 1;
-
-		/*      Channel List */
-		p2pie[p2pielen++] = pbuddy_mlmeext->cur_channel;
-	} else {
-		int i, j;
-		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-			/*      Operating Class */
-			p2pie[p2pielen++] =
-			    pmlmeext->channel_list.reg_class[j].reg_class;
-
-			/*      Number of Channels */
-			p2pie[p2pielen++] =
-			    pmlmeext->channel_list.reg_class[j].channels;
-
-			/*      Channel List */
-			for (i = 0;
-			     i < pmlmeext->channel_list.reg_class[j].channels;
-			     i++) {
-				p2pie[p2pielen++] =
-				    pmlmeext->channel_list.reg_class[j].
-				    channel[i];
-			}
-		}
-	}
-#else /*  CONFIG_CONCURRENT_MODE */
-	{
-		int i, j;
-		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-			/*      Operating Class */
-			p2pie[p2pielen++] =
-			    pmlmeext->channel_list.reg_class[j].reg_class;
-
-			/*      Number of Channels */
-			p2pie[p2pielen++] =
-			    pmlmeext->channel_list.reg_class[j].channels;
-
-			/*      Channel List */
-			for (i = 0;
-			     i < pmlmeext->channel_list.reg_class[j].channels;
-			     i++) {
-				p2pie[p2pielen++] =
-				    pmlmeext->channel_list.reg_class[j].
-				    channel[i];
-			}
-		}
-	}
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-	/*      Device Info */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
-
-	/*      Length: */
-	/*      21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
-	/*      + NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
-	*(__le16 *)(p2pie + p2pielen) =
-	    cpu_to_le16(21 + pwdinfo->device_name_len);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      P2P Device Address */
-	memcpy(p2pie + p2pielen, myid(&adapt->eeprompriv), ETH_ALEN);
-	p2pielen += ETH_ALEN;
-
-	/*      Config Method */
-	/*      This field should be big endian. Noted by P2P specification. */
-
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
-
-	p2pielen += 2;
-
-	/*      Primary Device Type */
-	/*      Category ID */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
-	p2pielen += 2;
-
-	/*      OUI */
-	*(__be32 *)(p2pie + p2pielen) = cpu_to_be32(WPSOUI);
-	p2pielen += 4;
-
-	/*      Sub Category ID */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
-	p2pielen += 2;
-
-	/*      Number of Secondary Device Types */
-	p2pie[p2pielen++] = 0x00;	/*      No Secondary Device Type List */
-
-	/*      Device Name */
-	/*      Type: */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
-	p2pielen += 2;
-
-	/*      Length: */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
-	p2pielen += 2;
-
-	/*      Value: */
-	memcpy(p2pie + p2pielen, pwdinfo->device_name,
-	       pwdinfo->device_name_len);
-	p2pielen += pwdinfo->device_name_len;
-
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-		/*      Group ID Attribute */
-		/*      Type: */
-		p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
-
-		/*      Length: */
-		*(__le16 *)(p2pie + p2pielen) =
-		    cpu_to_le16(ETH_ALEN + pwdinfo->nego_ssidlen);
-		p2pielen += 2;
-
-		/*      Value: */
-		/*      p2P Device Address */
-		memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);
-		p2pielen += ETH_ALEN;
-
-		/*      SSID */
-		memcpy(p2pie + p2pielen, pwdinfo->nego_ssid,
-		       pwdinfo->nego_ssidlen);
-		p2pielen += pwdinfo->nego_ssidlen;
-	}
-
-	pframe =
-	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
-		       (unsigned char *)p2pie, &pattrib->pktlen);
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	dump_mgntframe(adapt, pmgntframe);
-
-	return;
-}
-
-static void issue_p2p_GO_confirm(struct rtw_adapter *adapt, u8 *raddr, u8 result)
-{
-	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
-	u8 action = P2P_PUB_ACTION_ACTION;
-	__be32 p2poui = cpu_to_be32(P2POUI);
-	u8 oui_subtype = P2P_GO_NEGO_CONF;
-	u8 p2pie[255] = {0x00};
-	u8 p2pielen = 0;
-	struct xmit_frame *pmgntframe;
-	struct pkt_attrib *pattrib;
-	unsigned char *pframe;
-	struct ieee80211_hdr *pwlanhdr;
-	unsigned short *fctrl;
-	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
-	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	DBG_8192D("[%s] In\n", __func__);
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(adapt, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-
-	memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
-	memcpy(pwlanhdr->addr3, myid(&(adapt->eeprompriv)), ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
-
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 4, (unsigned char *)&(p2poui),
-			     &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 1, &(pwdinfo->negotiation_dialog_token),
-			     &(pattrib->pktlen));
-
-	/*      P2P IE Section. */
-
-	/*      P2P OUI */
-	p2pielen = 0;
-	p2pie[p2pielen++] = 0x50;
-	p2pie[p2pielen++] = 0x6F;
-	p2pie[p2pielen++] = 0x9A;
-	p2pie[p2pielen++] = 0x09;	/*      WFA P2P v1.0 */
-
-	/*      Commented by Albert 20110306 */
-	/*      According to the P2P Specification, the group negoitation request frame should contain 5 P2P attributes */
-	/*      1. Status */
-	/*      2. P2P Capability */
-	/*      3. Operating Channel */
-	/*      4. Channel List */
-	/*      5. Group ID     (if this WiFi is GO) */
-
-	/*      P2P Status */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_STATUS;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
-	p2pielen += 2;
-
-	/*      Value: */
-	p2pie[p2pielen++] = result;
-
-	/*      P2P Capability */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Device Capability Bitmap, 1 byte */
-	p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
-
-	/*      Group Capability Bitmap, 1 byte */
-	if (pwdinfo->persistent_supported) {
-		p2pie[p2pielen++] =
-		    P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
-	} else {
-		p2pie[p2pielen++] = P2P_GRPCAP_CROSS_CONN;
-	}
-
-	/*      Operating Channel */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Country String */
-	p2pie[p2pielen++] = 'X';
-	p2pie[p2pielen++] = 'X';
-
-	/*      The third byte should be set to 0x04. */
-	/*      Described in the "Operating Channel Attribute" section. */
-	p2pie[p2pielen++] = 0x04;
-
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)) {
-		if (pwdinfo->peer_operating_ch <= 14) {
-			/*      Operating Class */
-			p2pie[p2pielen++] = 0x51;
-		} else if ((pwdinfo->peer_operating_ch >= 36) &&
-			   (pwdinfo->peer_operating_ch <= 48)) {
-			/*      Operating Class */
-			p2pie[p2pielen++] = 0x73;
-		} else {
-			/*      Operating Class */
-			p2pie[p2pielen++] = 0x7c;
-		}
-
-		p2pie[p2pielen++] = pwdinfo->peer_operating_ch;
-	} else {
-		if (pwdinfo->operating_channel <= 14) {
-			/*      Operating Class */
-			p2pie[p2pielen++] = 0x51;
-		} else if ((pwdinfo->operating_channel >= 36) &&
-			   (pwdinfo->operating_channel <= 48)) {
-			/*      Operating Class */
-			p2pie[p2pielen++] = 0x73;
-		} else {
-			/*      Operating Class */
-			p2pie[p2pielen++] = 0x7c;
-		}
-
-		/*      Channel Number */
-		p2pie[p2pielen++] = pwdinfo->operating_channel;	/*      Use the listen channel as the operating channel */
-	}
-
-	/*      Channel List */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) =
-	    cpu_to_le16(pwdinfo->channel_list_attr_len);
-	p2pielen += 2;
-
-	/*      Value: */
-	memcpy(p2pie + p2pielen, pwdinfo->channel_list_attr,
-	       pwdinfo->channel_list_attr_len);
-	p2pielen += pwdinfo->channel_list_attr_len;
-
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-		/*      Group ID Attribute */
-		/*      Type: */
-		p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
-
-		/*      Length: */
-		*(__le16 *)(p2pie + p2pielen) =
-		    cpu_to_le16(ETH_ALEN + pwdinfo->nego_ssidlen);
-		p2pielen += 2;
-
-		/*      Value: */
-		/*      p2P Device Address */
-		memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);
-		p2pielen += ETH_ALEN;
-
-		/*      SSID */
-		memcpy(p2pie + p2pielen, pwdinfo->nego_ssid,
-		       pwdinfo->nego_ssidlen);
-		p2pielen += pwdinfo->nego_ssidlen;
-	}
-
-	pframe =
-	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
-		       (unsigned char *)p2pie, &pattrib->pktlen);
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	dump_mgntframe(adapt, pmgntframe);
-
-	return;
-}
-
-void issue_p2p_invitation_request(struct rtw_adapter *adapt, u8 *raddr)
-{
-	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
-	u8 action = P2P_PUB_ACTION_ACTION;
-	__be32 p2poui = cpu_to_be32(P2POUI);
-	u8 oui_subtype = P2P_INVIT_REQ;
-	u8 p2pie[255] = { 0x00 };
-	u8 p2pielen = 0;
-	u8 dialogToken = 3;
-	u16 len_channellist_attr = 0;
-#ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
-	struct wifidirect_info *pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
-	struct mlme_priv *pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
-	struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif
-
-	struct xmit_frame *pmgntframe;
-	struct pkt_attrib *pattrib;
-	unsigned char *pframe;
-	struct ieee80211_hdr *pwlanhdr;
-	unsigned short *fctrl;
-	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
-	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(adapt, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-
-	memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
-	memcpy(pwlanhdr->addr3, raddr, ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
-
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 4, (unsigned char *)&(p2poui),
-			     &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
-
-	/*      P2P IE Section. */
-
-	/*      P2P OUI */
-	p2pielen = 0;
-	p2pie[p2pielen++] = 0x50;
-	p2pie[p2pielen++] = 0x6F;
-	p2pie[p2pielen++] = 0x9A;
-	p2pie[p2pielen++] = 0x09;	/*      WFA P2P v1.0 */
-
-	/*      Commented by Albert 20101011 */
-	/*      According to the P2P Specification, the P2P Invitation request frame should contain 7 P2P attributes */
-	/*      1. Configuration Timeout */
-	/*      2. Invitation Flags */
-	/*      3. Operating Channel    (Only GO) */
-	/*      4. P2P Group BSSID      (Should be included if I am the GO) */
-	/*      5. Channel List */
-	/*      6. P2P Group ID */
-	/*      7. P2P Device Info */
-
-	/*      Configuration Timeout */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
-	p2pielen += 2;
-
-	/*      Value: */
-	p2pie[p2pielen++] = 200;	/*      2 seconds needed to be the P2P GO */
-	p2pie[p2pielen++] = 200;	/*      2 seconds needed to be the P2P Client */
-
-	/*      Invitation Flags */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_INVITATION_FLAGS;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
-	p2pielen += 2;
-
-	/*      Value: */
-	p2pie[p2pielen++] = P2P_INVITATION_FLAGS_PERSISTENT;
-
-	/*      Operating Channel */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Country String */
-	p2pie[p2pielen++] = 'X';
-	p2pie[p2pielen++] = 'X';
-
-	/*      The third byte should be set to 0x04. */
-	/*      Described in the "Operating Channel Attribute" section. */
-	p2pie[p2pielen++] = 0x04;
-
-	/*      Operating Class */
-	if (pwdinfo->invitereq_info.operating_ch <= 14)
-		p2pie[p2pielen++] = 0x51;
-	else if ((pwdinfo->invitereq_info.operating_ch >= 36) &&
-		 (pwdinfo->invitereq_info.operating_ch <= 48))
-		p2pie[p2pielen++] = 0x73;
-	else
-		p2pie[p2pielen++] = 0x7c;
-
-	/*      Channel Number */
-	p2pie[p2pielen++] = pwdinfo->invitereq_info.operating_ch;	/*      operating channel number */
-
-	if (!memcmp
-	    (myid(&adapt->eeprompriv), pwdinfo->invitereq_info.go_bssid,
-	     ETH_ALEN)) {
-		/*      P2P Group BSSID */
-		/*      Type: */
-		p2pie[p2pielen++] = P2P_ATTR_GROUP_BSSID;
-
-		/*      Length: */
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
-		p2pielen += 2;
-
-		/*      Value: */
-		/*      P2P Device Address for GO */
-		memcpy(p2pie + p2pielen, pwdinfo->invitereq_info.go_bssid,
-		       ETH_ALEN);
-		p2pielen += ETH_ALEN;
-	}
-
-	/*      Channel List */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
-
-	/*      Length: */
-	/*  Country String(3) */
-	/*  + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?) */
-	/*  + number of channels in all classes */
-	len_channellist_attr = 3
-	    + (1 + 1) * (u16) pmlmeext->channel_list.reg_classes
-	    + get_reg_classes_full_count(pmlmeext->channel_list);
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(5 + 1);
-	} else {
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
-	}
-#else
-
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
-
-#endif
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      Country String */
-	p2pie[p2pielen++] = 'X';
-	p2pie[p2pielen++] = 'X';
-
-	/*      The third byte should be set to 0x04. */
-	/*      Described in the "Operating Channel Attribute" section. */
-	p2pie[p2pielen++] = 0x04;
-
-	/*      Channel Entry List */
-#ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-		struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
-		struct mlme_ext_priv *pbuddy_mlmeext =
-		    &pbuddy_adapter->mlmeextpriv;
-
-		/*      Operating Class */
-		if (pbuddy_mlmeext->cur_channel > 14) {
-			if (pbuddy_mlmeext->cur_channel >= 149) {
-				p2pie[p2pielen++] = 0x7c;
-			} else {
-				p2pie[p2pielen++] = 0x73;
-			}
-		} else {
-			p2pie[p2pielen++] = 0x51;
-		}
-
-		/*      Number of Channels */
-		/*      Just support 1 channel and this channel is AP's channel */
-		p2pie[p2pielen++] = 1;
-
-		/*      Channel List */
-		p2pie[p2pielen++] = pbuddy_mlmeext->cur_channel;
-	} else {
-		int i, j;
-		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-			/*      Operating Class */
-			p2pie[p2pielen++] =
-			    pmlmeext->channel_list.reg_class[j].reg_class;
-
-			/*      Number of Channels */
-			p2pie[p2pielen++] =
-			    pmlmeext->channel_list.reg_class[j].channels;
-
-			/*      Channel List */
-			for (i = 0;
-			     i < pmlmeext->channel_list.reg_class[j].channels;
-			     i++) {
-				p2pie[p2pielen++] =
-				    pmlmeext->channel_list.reg_class[j].
-				    channel[i];
-			}
-		}
-	}
-#else /*  CONFIG_CONCURRENT_MODE */
-	{
-		int i, j;
-		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-			/*      Operating Class */
-			p2pie[p2pielen++] =
-			    pmlmeext->channel_list.reg_class[j].reg_class;
-
-			/*      Number of Channels */
-			p2pie[p2pielen++] =
-			    pmlmeext->channel_list.reg_class[j].channels;
-
-			/*      Channel List */
-			for (i = 0;
-			     i < pmlmeext->channel_list.reg_class[j].channels;
-			     i++) {
-				p2pie[p2pielen++] =
-				    pmlmeext->channel_list.reg_class[j].
-				    channel[i];
-			}
-		}
-	}
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-	/*      P2P Group ID */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) =
-	    cpu_to_le16(6 + pwdinfo->invitereq_info.ssidlen);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      P2P Device Address for GO */
-	memcpy(p2pie + p2pielen, pwdinfo->invitereq_info.go_bssid, ETH_ALEN);
-	p2pielen += ETH_ALEN;
-
-	/*      SSID */
-	memcpy(p2pie + p2pielen, pwdinfo->invitereq_info.go_ssid,
-	       pwdinfo->invitereq_info.ssidlen);
-	p2pielen += pwdinfo->invitereq_info.ssidlen;
-
-	/*      Device Info */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
-
-	/*      Length: */
-	/*      21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
-	/*      + NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
-	*(__le16 *)(p2pie + p2pielen) =
-	    cpu_to_le16(21 + pwdinfo->device_name_len);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      P2P Device Address */
-	memcpy(p2pie + p2pielen, myid(&adapt->eeprompriv), ETH_ALEN);
-	p2pielen += ETH_ALEN;
-
-	/*      Config Method */
-	/*      This field should be big endian. Noted by P2P specification. */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY);
-	p2pielen += 2;
-
-	/*      Primary Device Type */
-	/*      Category ID */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
-	p2pielen += 2;
-
-	/*      OUI */
-	*(__be32 *)(p2pie + p2pielen) = cpu_to_be32(WPSOUI);
-	p2pielen += 4;
-
-	/*      Sub Category ID */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
-	p2pielen += 2;
-
-	/*      Number of Secondary Device Types */
-	p2pie[p2pielen++] = 0x00;	/*      No Secondary Device Type List */
-
-	/*      Device Name */
-	/*      Type: */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
-	p2pielen += 2;
-
-	/*      Length: */
-	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
-	p2pielen += 2;
-
-	/*      Value: */
-	memcpy(p2pie + p2pielen, pwdinfo->device_name,
-	       pwdinfo->device_name_len);
-	p2pielen += pwdinfo->device_name_len;
-
-	pframe =
-	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
-		       (unsigned char *)p2pie, &pattrib->pktlen);
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	dump_mgntframe(adapt, pmgntframe);
-
-	return;
-}
-
-void issue_p2p_invitation_response(struct rtw_adapter *adapt, u8 *raddr,
-				   u8 dialogToken, u8 status_code)
-{
-	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
-	u8 action = P2P_PUB_ACTION_ACTION;
-	__be32 p2poui = cpu_to_be32(P2POUI);
-	u8 oui_subtype = P2P_INVIT_RESP;
-	u8 p2pie[255] = { 0x00 };
-	u8 p2pielen = 0;
-	u16 len_channellist_attr = 0;
-#ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
-	struct wifidirect_info *pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
-	struct mlme_priv *pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
-	struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif
-	struct xmit_frame *pmgntframe;
-	struct pkt_attrib *pattrib;
-	unsigned char *pframe;
-	struct ieee80211_hdr *pwlanhdr;
-	unsigned short *fctrl;
-	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
-	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(adapt, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-
-	memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
-	memcpy(pwlanhdr->addr3, raddr, ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
-
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 4, (unsigned char *)&(p2poui),
-			     &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
-
-	/*      P2P IE Section. */
-
-	/*      P2P OUI */
-	p2pielen = 0;
-	p2pie[p2pielen++] = 0x50;
-	p2pie[p2pielen++] = 0x6F;
-	p2pie[p2pielen++] = 0x9A;
-	p2pie[p2pielen++] = 0x09;	/*      WFA P2P v1.0 */
-
-	/*      Commented by Albert 20101005 */
-	/*      According to the P2P Specification, the P2P Invitation response frame should contain 5 P2P attributes */
-	/*      1. Status */
-	/*      2. Configuration Timeout */
-	/*      3. Operating Channel    (Only GO) */
-	/*      4. P2P Group BSSID      (Only GO) */
-	/*      5. Channel List */
-
-	/*      P2P Status */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_STATUS;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
-	p2pielen += 2;
-
-	/*      Value: */
-	/*      When status code is P2P_STATUS_FAIL_INFO_UNAVAILABLE. */
-	/*      Sent the event receiving the P2P Invitation Req frame to DMP UI. */
-	/*      DMP had to compare the MAC address to find out the profile. */
-	/*      So, the WiFi driver will send the P2P_STATUS_FAIL_INFO_UNAVAILABLE to NB. */
-	/*      If the UI found the corresponding profile, the WiFi driver sends the P2P Invitation Req */
-	/*      to NB to rebuild the persistent group. */
-	p2pie[p2pielen++] = status_code;
-
-	/*      Configuration Timeout */
-	/*      Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
-
-	/*      Length: */
-	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
-	p2pielen += 2;
-
-	/*      Value: */
-	p2pie[p2pielen++] = 200;	/*      2 seconds needed to be the P2P GO */
-	p2pie[p2pielen++] = 200;	/*      2 seconds needed to be the P2P Client */
-
-	if (status_code == P2P_STATUS_SUCCESS) {
-		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-			/*      The P2P Invitation request frame asks this Wi-Fi device to be the P2P GO */
-			/*      In this case, the P2P Invitation response frame should carry the two more P2P attributes. */
-			/*      First one is operating channel attribute. */
-			/*      Second one is P2P Group BSSID attribute. */
-
-			/*      Operating Channel */
-			/*      Type: */
-			p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
-
-			/*      Length: */
-			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
-			p2pielen += 2;
-
-			/*      Value: */
-			/*      Country String */
-			p2pie[p2pielen++] = 'X';
-			p2pie[p2pielen++] = 'X';
-
-			/*      The third byte should be set to 0x04. */
-			/*      Described in the "Operating Channel Attribute" section. */
-			p2pie[p2pielen++] = 0x04;
-
-			/*      Operating Class */
-			p2pie[p2pielen++] = 0x51;	/*      Copy from SD7 */
-
-			/*      Channel Number */
-			p2pie[p2pielen++] = pwdinfo->operating_channel;	/*      operating channel number */
-
-			/*      P2P Group BSSID */
-			/*      Type: */
-			p2pie[p2pielen++] = P2P_ATTR_GROUP_BSSID;
-
-			/*      Length: */
-			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
-			p2pielen += 2;
-
-			/*      Value: */
-			/*      P2P Device Address for GO */
-			memcpy(p2pie + p2pielen, myid(&adapt->eeprompriv),
-			       ETH_ALEN);
-			p2pielen += ETH_ALEN;
-		}
-
-		/*      Channel List */
-		/*      Type: */
-		p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
-
-		/*      Length: */
-		/*  Country String(3) */
-		/*  + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?) */
-		/*  + number of channels in all classes */
-		len_channellist_attr = 3
-		    + (1 + 1) * (u16) pmlmeext->channel_list.reg_classes
-		    + get_reg_classes_full_count(pmlmeext->channel_list);
-
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(5 + 1);
-		} else {
-			*(__le16 *)(p2pie + p2pielen) =
-			    cpu_to_le16(len_channellist_attr);
-		}
-#else
-
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
-
-#endif
-		p2pielen += 2;
-
-		/*      Value: */
-		/*      Country String */
-		p2pie[p2pielen++] = 'X';
-		p2pie[p2pielen++] = 'X';
-
-		/*      The third byte should be set to 0x04. */
-		/*      Described in the "Operating Channel Attribute" section. */
-		p2pie[p2pielen++] = 0x04;
-
-		/*      Channel Entry List */
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-			struct rtw_adapter *pbuddy_adapter =
-			    adapt->pbuddy_adapter;
-			struct mlme_ext_priv *pbuddy_mlmeext =
-			    &pbuddy_adapter->mlmeextpriv;
-
-			/*      Operating Class */
-			if (pbuddy_mlmeext->cur_channel > 14) {
-				if (pbuddy_mlmeext->cur_channel >= 149) {
-					p2pie[p2pielen++] = 0x7c;
-				} else {
-					p2pie[p2pielen++] = 0x73;
-				}
-			} else {
-				p2pie[p2pielen++] = 0x51;
-			}
-
-			/*      Number of Channels */
-			/*      Just support 1 channel and this channel is AP's channel */
-			p2pie[p2pielen++] = 1;
-
-			/*      Channel List */
-			p2pie[p2pielen++] = pbuddy_mlmeext->cur_channel;
-		} else {
-			int i, j;
-			for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-				/*      Operating Class */
-				p2pie[p2pielen++] =
-				    pmlmeext->channel_list.reg_class[j].
-				    reg_class;
-
-				/*      Number of Channels */
-				p2pie[p2pielen++] =
-				    pmlmeext->channel_list.reg_class[j].
-				    channels;
-
-				/*      Channel List */
-				for (i = 0;
-				     i <
-				     pmlmeext->channel_list.reg_class[j].
-				     channels; i++) {
-					p2pie[p2pielen++] =
-					    pmlmeext->channel_list.reg_class[j].
-					    channel[i];
-				}
-			}
-		}
-#else /*  CONFIG_CONCURRENT_MODE */
-		{
-			int i, j;
-			for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-				/*      Operating Class */
-				p2pie[p2pielen++] =
-				    pmlmeext->channel_list.reg_class[j].
-				    reg_class;
-
-				/*      Number of Channels */
-				p2pie[p2pielen++] =
-				    pmlmeext->channel_list.reg_class[j].
-				    channels;
-
-				/*      Channel List */
-				for (i = 0;
-				     i <
-				     pmlmeext->channel_list.reg_class[j].
-				     channels; i++) {
-					p2pie[p2pielen++] =
-					    pmlmeext->channel_list.reg_class[j].
-					    channel[i];
-				}
-			}
-		}
-#endif /*  CONFIG_CONCURRENT_MODE */
-	}
-
-	pframe =
-	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
-		       (unsigned char *)p2pie, &pattrib->pktlen);
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	dump_mgntframe(adapt, pmgntframe);
-
-	return;
-}
-
-void issue_p2p_provision_request(struct rtw_adapter *adapt, u8 *pssid,
-				 u8 ussidlen, u8 *pdev_raddr)
-{
-	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
-	u8 action = P2P_PUB_ACTION_ACTION;
-	u8 dialogToken = 1;
-	__be32 p2poui = cpu_to_be32(P2POUI);
-	u8 oui_subtype = P2P_PROVISION_DISC_REQ;
-	u8 wpsie[100] = { 0x00 };
-	u8 wpsielen = 0;
-	u32 p2pielen = 0;
-	struct xmit_frame *pmgntframe;
-	struct pkt_attrib *pattrib;
-	unsigned char *pframe;
-	struct ieee80211_hdr *pwlanhdr;
-	unsigned short *fctrl;
-	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
-	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	DBG_8192D("[%s] In\n", __func__);
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(adapt, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-
-	memcpy(pwlanhdr->addr1, pdev_raddr, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
-	memcpy(pwlanhdr->addr3, pdev_raddr, ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
-
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 4, (unsigned char *)&(p2poui),
-			     &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe =
-	    rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
-
-	p2pielen =
-	    build_prov_disc_request_p2p_ie(pwdinfo, pframe, pssid, ussidlen,
-					   pdev_raddr);
-
-	pframe += p2pielen;
-	pattrib->pktlen += p2pielen;
-
-	wpsielen = 0;
-	/*      WPS OUI */
-	*(__be32 *)(wpsie) = cpu_to_be32(WPSOUI);
-	wpsielen += 4;
-
-	/*      WPS version */
-	/*      Type: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
-	wpsielen += 2;
-
-	/*      Length: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
-	wpsielen += 2;
-
-	/*      Value: */
-	wpsie[wpsielen++] = WPS_VERSION_1;	/*      Version 1.0 */
-
-	/*      Config Method */
-	/*      Type: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
-	wpsielen += 2;
-
-	/*      Length: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
-	wpsielen += 2;
-
-	/*      Value: */
-	*(__be16 *)(wpsie + wpsielen) =
-	    cpu_to_be16(pwdinfo->tx_prov_disc_info.wps_config_method_request);
-	wpsielen += 2;
-
-	pframe =
-	    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen,
-		       (unsigned char *)wpsie, &pattrib->pktlen);
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	dump_mgntframe(adapt, pmgntframe);
-
-	return;
-}
-
-static u8 is_matched_in_profilelist(u8 *peermacaddr,
-			     struct profile_info *profileinfo)
-{
-	u8 i, match_result = 0;
-
-	DBG_8192D("[%s] peermac = %.2X %.2X %.2X %.2X %.2X %.2X\n", __func__,
-		  peermacaddr[0], peermacaddr[1], peermacaddr[2],
-		  peermacaddr[3], peermacaddr[4], peermacaddr[5]);
-
-	for (i = 0; i < P2P_MAX_PERSISTENT_GROUP_NUM; i++, profileinfo++) {
-		DBG_8192D
-		    ("[%s] profileinfo_mac = %.2X %.2X %.2X %.2X %.2X %.2X\n",
-		     __func__, profileinfo->peermac[0], profileinfo->peermac[1],
-		     profileinfo->peermac[2], profileinfo->peermac[3],
-		     profileinfo->peermac[4], profileinfo->peermac[5]);
-		if (!memcmp(peermacaddr, profileinfo->peermac, ETH_ALEN)) {
-			match_result = 1;
-			DBG_8192D("[%s] Match!\n", __func__);
-			break;
-		}
-	}
-	return match_result;
-}
-
-void issue_probersp_p2p(struct rtw_adapter *adapt, unsigned char *da)
-{
-	struct xmit_frame *pmgntframe;
-	struct pkt_attrib *pattrib;
-	struct ieee80211_hdr *pwlanhdr;
-	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
-	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-	struct cfg80211_wifidirect_info *pcfg80211_wdinfo =
-	    &adapt->cfg80211_wdinfo;
-	struct ieee80211_channel *ieee_ch =
-	    &pcfg80211_wdinfo->remain_on_ch_channel;
-	unsigned char *pframe;
-	unsigned short *fctrl;
-	unsigned char *mac;
-	u16 beacon_interval = 100;
-	u16 capInfo = 0;
-	u8 wpsie[255] = { 0x00 };
-	u32 wpsielen = 0, p2pielen = 0;
-	u8 listen_channel =
-	    (u8) ieee80211_frequency_to_channel(ieee_ch->center_freq);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(adapt, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	mac = myid(&(adapt->eeprompriv));
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
-
-	/*      Use the device address for BSSID field. */
-	memcpy(pwlanhdr->addr3, mac, ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(fctrl, WIFI_PROBERSP);
-
-	pattrib->hdrlen = sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = pattrib->hdrlen;
-	pframe += pattrib->hdrlen;
-
-	/* timestamp will be inserted by hardware */
-	pframe += 8;
-	pattrib->pktlen += 8;
-
-	/*  beacon interval: 2 bytes */
-	memcpy(pframe, (unsigned char *)&beacon_interval, 2);
-	pframe += 2;
-	pattrib->pktlen += 2;
-
-	/*      capability info: 2 bytes */
-	/*      ESS and IBSS bits must be 0 (defined in the 3.1.2.1.1 of WiFi Direct Spec) */
-	capInfo |= cap_ShortPremble;
-	capInfo |= cap_ShortSlot;
-
-	memcpy(pframe, (unsigned char *)&capInfo, 2);
-	pframe += 2;
-	pattrib->pktlen += 2;
-
-	/*  SSID */
-	pframe =
-	    rtw_set_ie(pframe, _SSID_IE_, 7, pwdinfo->p2p_wildcard_ssid,
-		       &pattrib->pktlen);
-
-	/*  supported rates... */
-	/*      Use the OFDM rate in the P2P probe response frame. (6(B), 9(B), 12, 18, 24, 36, 48, 54) */
-	pframe =
-	    rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pwdinfo->support_rate,
-		       &pattrib->pktlen);
-
-	/*  DS parameter set */
-	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled &&
-	    listen_channel != 0) {
-		pframe =
-		    rtw_set_ie(pframe, _DSSET_IE_, 1,
-			       (unsigned char *)&listen_channel,
-			       &pattrib->pktlen);
-	} else {
-		pframe =
-		    rtw_set_ie(pframe, _DSSET_IE_, 1,
-			       (unsigned char *)&pwdinfo->listen_channel,
-			       &pattrib->pktlen);
-	}
-
-	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
-		if (pmlmepriv->wps_probe_resp_ie != NULL &&
-		    pmlmepriv->p2p_probe_resp_ie != NULL) {
-			/* WPS IE */
-			memcpy(pframe, pmlmepriv->wps_probe_resp_ie,
-			       pmlmepriv->wps_probe_resp_ie_len);
-			pattrib->pktlen += pmlmepriv->wps_probe_resp_ie_len;
-			pframe += pmlmepriv->wps_probe_resp_ie_len;
-
-			/* P2P IE */
-			memcpy(pframe, pmlmepriv->p2p_probe_resp_ie,
-			       pmlmepriv->p2p_probe_resp_ie_len);
-			pattrib->pktlen += pmlmepriv->p2p_probe_resp_ie_len;
-			pframe += pmlmepriv->p2p_probe_resp_ie_len;
-		}
-	} else {
-		/*      Todo: WPS IE */
-		/*      Noted by Albert 20100907 */
-		/*      According to the WPS specification, all the WPS attribute is presented by Big Endian. */
-
-		wpsielen = 0;
-		/*      WPS OUI */
-		*(__be32 *)(wpsie) = cpu_to_be32(WPSOUI);
-		wpsielen += 4;
-
-		/*      WPS version */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
-		wpsielen += 2;
-
-		/*      Value: */
-		wpsie[wpsielen++] = WPS_VERSION_1;	/*      Version 1.0 */
-
-		/*      WiFi Simple Config State */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(WPS_ATTR_SIMPLE_CONF_STATE);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
-		wpsielen += 2;
-
-		/*      Value: */
-		wpsie[wpsielen++] = WPS_WSC_STATE_NOT_CONFIG;	/*      Not Configured. */
-
-		/*      Response Type */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_RESP_TYPE);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
-		wpsielen += 2;
-
-		/*      Value: */
-		wpsie[wpsielen++] = WPS_RESPONSE_TYPE_8021X;
-
-		/*      UUID-E */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_UUID_E);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0010);
-		wpsielen += 2;
-
-		/*      Value: */
-		memcpy(wpsie + wpsielen, myid(&adapt->eeprompriv), ETH_ALEN);
-		wpsielen += 0x10;
-
-		/*      Manufacturer */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(WPS_ATTR_MANUFACTURER);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0007);
-		wpsielen += 2;
-
-		/*      Value: */
-		memcpy(wpsie + wpsielen, "Realtek", 7);
-		wpsielen += 7;
-
-		/*      Model Name */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_MODEL_NAME);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0006);
-		wpsielen += 2;
-
-		/*      Value: */
-		memcpy(wpsie + wpsielen, "8192CU", 6);
-		wpsielen += 6;
-
-		/*      Model Number */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(WPS_ATTR_MODEL_NUMBER);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
-		wpsielen += 2;
-
-		/*      Value: */
-		wpsie[wpsielen++] = 0x31;	/*      character 1 */
-
-		/*      Serial Number */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(WPS_ATTR_SERIAL_NUMBER);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(ETH_ALEN);
-		wpsielen += 2;
-
-		/*      Value: */
-		memcpy(wpsie + wpsielen, "123456", ETH_ALEN);
-		wpsielen += ETH_ALEN;
-
-		/*      Primary Device Type */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0008);
-		wpsielen += 2;
-
-		/*      Value: */
-		/*      Category ID */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_PDT_CID_RTK_WIDI);
-		wpsielen += 2;
-
-		/*      OUI */
-		*(__be32 *)(wpsie + wpsielen) = cpu_to_be32(WPSOUI);
-		wpsielen += 4;
-
-		/*      Sub Category ID */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_PDT_SCID_RTK_DMP);
-		wpsielen += 2;
-
-		/*      Device Name */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(pwdinfo->device_name_len);
-		wpsielen += 2;
-
-		/*      Value: */
-		memcpy(wpsie + wpsielen, pwdinfo->device_name,
-		       pwdinfo->device_name_len);
-		wpsielen += pwdinfo->device_name_len;
-
-		/*      Config Method */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
-		wpsielen += 2;
-
-		/*      Value: */
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(pwdinfo->supported_wps_cm);
-		wpsielen += 2;
-
-		pframe =
-		    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen,
-			       (unsigned char *)wpsie, &pattrib->pktlen);
-
-		p2pielen = build_probe_resp_p2p_ie(pwdinfo, pframe);
-		pframe += p2pielen;
-		pattrib->pktlen += p2pielen;
-	}
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	dump_mgntframe(adapt, pmgntframe);
-
-	return;
-}
-
-static int _issue_probereq_p2p(struct rtw_adapter *adapt, u8 *da, int wait_ack)
-{
-	int ret = 0;
-	struct xmit_frame *pmgntframe;
-	struct pkt_attrib *pattrib;
-	unsigned char *pframe;
-	struct ieee80211_hdr *pwlanhdr;
-	unsigned short *fctrl;
-	unsigned char *mac;
-	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
-	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-	u8 wpsie[255] = {0x00}, p2pie[255] = {0x00};
-	u16 wpsielen = 0, p2pielen = 0;
-	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		goto exit;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(adapt, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	mac = myid(&(adapt->eeprompriv));
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-
-	if (da) {
-		memcpy(pwlanhdr->addr1, da, ETH_ALEN);
-		memcpy(pwlanhdr->addr3, da, ETH_ALEN);
-	} else {
-		if ((pwdinfo->p2p_info.scan_op_ch_only) ||
-		    (pwdinfo->rx_invitereq_info.scan_op_ch_only)) {
-			/*      This two flags will be set when this is only the P2P client mode. */
-			memcpy(pwlanhdr->addr1,
-			       pwdinfo->p2p_peer_interface_addr, ETH_ALEN);
-			memcpy(pwlanhdr->addr3,
-			       pwdinfo->p2p_peer_interface_addr, ETH_ALEN);
-		} else {
-			/*      broadcast probe request frame */
-			eth_broadcast_addr(pwlanhdr->addr1);
-			eth_broadcast_addr(pwlanhdr->addr3);
-		}
-	}
-	memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_PROBEREQ);
-
-	pframe += sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ)) {
-		pframe =
-		    rtw_set_ie(pframe, _SSID_IE_,
-			       pwdinfo->tx_prov_disc_info.ssid.SsidLength,
-			       pwdinfo->tx_prov_disc_info.ssid.Ssid,
-			       &(pattrib->pktlen));
-	} else {
-		pframe =
-		    rtw_set_ie(pframe, _SSID_IE_, P2P_WILDCARD_SSID_LEN,
-			       pwdinfo->p2p_wildcard_ssid, &(pattrib->pktlen));
-	}
-	/*      Use the OFDM rate in the P2P probe request frame. (6(B), 9(B), 12(B), 24(B), 36, 48, 54) */
-	pframe =
-	    rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pwdinfo->support_rate,
-		       &pattrib->pktlen);
-
-	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
-		if (pmlmepriv->wps_probe_req_ie != NULL &&
-		    pmlmepriv->p2p_probe_req_ie != NULL) {
-			/* WPS IE */
-			memcpy(pframe, pmlmepriv->wps_probe_req_ie,
-			       pmlmepriv->wps_probe_req_ie_len);
-			pattrib->pktlen += pmlmepriv->wps_probe_req_ie_len;
-			pframe += pmlmepriv->wps_probe_req_ie_len;
-
-			/* P2P IE */
-			memcpy(pframe, pmlmepriv->p2p_probe_req_ie,
-			       pmlmepriv->p2p_probe_req_ie_len);
-			pattrib->pktlen += pmlmepriv->p2p_probe_req_ie_len;
-			pframe += pmlmepriv->p2p_probe_req_ie_len;
-		}
-	} else {
-		/*      WPS IE */
-		/*      Noted by Albert 20110221 */
-		/*      According to the WPS specification, all the WPS attribute is presented by Big Endian. */
-
-		wpsielen = 0;
-		/*      WPS OUI */
-		*(__be32 *)(wpsie) = cpu_to_be32(WPSOUI);
-		wpsielen += 4;
-
-		/*      WPS version */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
-		wpsielen += 2;
-
-		/*      Value: */
-		wpsie[wpsielen++] = WPS_VERSION_1;	/*      Version 1.0 */
-
-		if (pmlmepriv->wps_probe_req_ie == NULL) {
-			/*      UUID-E */
-			/*      Type: */
-			*(__be16 *)(wpsie + wpsielen) =
-			    cpu_to_be16(WPS_ATTR_UUID_E);
-			wpsielen += 2;
-
-			/*      Length: */
-			*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0010);
-			wpsielen += 2;
-
-			/*      Value: */
-			memcpy(wpsie + wpsielen, myid(&adapt->eeprompriv),
-			       ETH_ALEN);
-			wpsielen += 0x10;
-
-			/*      Config Method */
-			/*      Type: */
-			*(__be16 *)(wpsie + wpsielen) =
-			    cpu_to_be16(WPS_ATTR_CONF_METHOD);
-			wpsielen += 2;
-
-			/*      Length: */
-			*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
-			wpsielen += 2;
-
-			/*      Value: */
-			*(__be16 *)(wpsie + wpsielen) =
-			    cpu_to_be16(pwdinfo->supported_wps_cm);
-			wpsielen += 2;
-		}
-
-		/*      Device Name */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(pwdinfo->device_name_len);
-		wpsielen += 2;
-
-		/*      Value: */
-		memcpy(wpsie + wpsielen, pwdinfo->device_name,
-		       pwdinfo->device_name_len);
-		wpsielen += pwdinfo->device_name_len;
-
-		/*      Primary Device Type */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0008);
-		wpsielen += 2;
-
-		/*      Value: */
-		/*      Category ID */
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
-		wpsielen += 2;
-
-		/*      OUI */
-		*(__be32 *)(wpsie + wpsielen) = cpu_to_be32(WPSOUI);
-		wpsielen += 4;
-
-		/*      Sub Category ID */
-		*(__be16 *)(wpsie + wpsielen) =
-		    cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
-		wpsielen += 2;
-
-		/*      Device Password ID */
-		/*      Type: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
-		wpsielen += 2;
-
-		/*      Length: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
-		wpsielen += 2;
-
-		/*      Value: */
-		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);	/*      Registrar-specified */
-		wpsielen += 2;
-
-		pframe =
-		    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen,
-			       (unsigned char *)wpsie, &pattrib->pktlen);
-
-		/*      P2P OUI */
-		p2pielen = 0;
-		p2pie[p2pielen++] = 0x50;
-		p2pie[p2pielen++] = 0x6F;
-		p2pie[p2pielen++] = 0x9A;
-		p2pie[p2pielen++] = 0x09;	/*      WFA P2P v1.0 */
-
-		/*      Commented by Albert 20110221 */
-		/*      According to the P2P Specification, the probe request frame should contain 5 P2P attributes */
-		/*      1. P2P Capability */
-		/*      2. P2P Device ID if this probe request wants to find the specific P2P device */
-		/*      3. Listen Channel */
-		/*      4. Extended Listen Timing */
-		/*      5. Operating Channel if this WiFi is working as the group owner now */
-
-		/*      P2P Capability */
-		/*      Type: */
-		p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
-
-		/*      Length: */
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
-		p2pielen += 2;
-
-		/*      Value: */
-		/*      Device Capability Bitmap, 1 byte */
-		p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
-
-		/*      Group Capability Bitmap, 1 byte */
-		if (pwdinfo->persistent_supported)
-			p2pie[p2pielen++] =
-			    P2P_GRPCAP_PERSISTENT_GROUP |
-			    DMP_P2P_GRPCAP_SUPPORT;
-		else
-			p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
-
-		/*      Listen Channel */
-		/*      Type: */
-		p2pie[p2pielen++] = P2P_ATTR_LISTEN_CH;
-
-		/*      Length: */
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
-		p2pielen += 2;
-
-		/*      Value: */
-		/*      Country String */
-		p2pie[p2pielen++] = 'X';
-		p2pie[p2pielen++] = 'X';
-
-		/*      The third byte should be set to 0x04. */
-		/*      Described in the "Operating Channel Attribute" section. */
-		p2pie[p2pielen++] = 0x04;
-
-		/*      Operating Class */
-		p2pie[p2pielen++] = 0x51;	/*      Copy from SD7 */
-
-		/*      Channel Number */
-		p2pie[p2pielen++] = pwdinfo->listen_channel;	/*      listen channel */
-
-		/*      Extended Listen Timing */
-		/*      Type: */
-		p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
-
-		/*      Length: */
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0004);
-		p2pielen += 2;
-
-		/*      Value: */
-		/*      Availability Period */
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
-		p2pielen += 2;
-
-		/*      Availability Interval */
-		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
-		p2pielen += 2;
-
-		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-			/*      Operating Channel (if this WiFi is working as the group owner now) */
-			/*      Type: */
-			p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
-
-			/*      Length: */
-			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
-			p2pielen += 2;
-
-			/*      Value: */
-			/*      Country String */
-			p2pie[p2pielen++] = 'X';
-			p2pie[p2pielen++] = 'X';
-
-			/*      The third byte should be set to 0x04. */
-			/*      Described in the "Operating Channel Attribute" section. */
-			p2pie[p2pielen++] = 0x04;
-
-			/*      Operating Class */
-			p2pie[p2pielen++] = 0x51;
-
-			/*      Channel Number */
-			p2pie[p2pielen++] = pwdinfo->operating_channel;
-		}
-
-		pframe =
-		    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
-			       (unsigned char *)p2pie, &pattrib->pktlen);
-
-		if (pmlmepriv->wps_probe_req_ie != NULL) {
-			/* WPS IE */
-			memcpy(pframe, pmlmepriv->wps_probe_req_ie,
-			       pmlmepriv->wps_probe_req_ie_len);
-			pattrib->pktlen += pmlmepriv->wps_probe_req_ie_len;
-			pframe += pmlmepriv->wps_probe_req_ie_len;
-		}
-	}
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
-		 ("issuing probe_req, tx_len=%d\n", pattrib->last_txcmdsz));
-
-	if (wait_ack) {
-		ret = dump_mgntframe_and_wait_ack(adapt, pmgntframe);
-	} else {
-		dump_mgntframe(adapt, pmgntframe);
-		ret = 1;
-	}
-
-exit:
-	return ret;
-}
-
-inline void issue_probereq_p2p(struct rtw_adapter *adapter, u8 *da)
-{
-	_issue_probereq_p2p(adapter, da, false);
-}
-
-int issue_probereq_p2p_ex(struct rtw_adapter *adapter, u8 *da, int try_cnt,
-			  int wait_ms)
-{
-	int ret;
-	int i = 0;
-	u32 start = jiffies;
-
-	do {
-		ret =
-		    _issue_probereq_p2p(adapter, da,
-					wait_ms > 0 ? true : false);
-
-		i++;
-
-		if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
-			break;
-
-		if (i < try_cnt && wait_ms > 0 && ret == 0)
-			msleep(wait_ms);
-
-	} while ((i < try_cnt) && ((ret == 0) || (wait_ms == 0)));
-
-	if (ret != 0) {
-		ret = 1;
-		goto exit;
-	}
-
-	if (try_cnt && wait_ms) {
-		if (da)
-			DBG_8192D(FUNC_ADPT_FMT
-				  " to %pM, ch:%u%s, %d/%d in %u ms\n",
-				  FUNC_ADPT_ARG(adapter), da,
-				  rtw_get_oper_ch(adapter),
-				  ret == 1 ? ", acked" : "", i, try_cnt,
-				  rtw_systime_to_ms(jiffies - start));
-		else
-			DBG_8192D(FUNC_ADPT_FMT ", ch:%u%s, %d/%d in %u ms\n",
-				  FUNC_ADPT_ARG(adapter),
-				  rtw_get_oper_ch(adapter),
-				  ret == 1 ? ", acked" : "", i, try_cnt,
-				  rtw_systime_to_ms(jiffies - start));
+
+				preorder_ctrl = &psta->recvreorder_ctrl[tid];
+				preorder_ctrl->enable = false;
+				preorder_ctrl->indicate_seq = 0xffff;
+			}
+
+			DBG_8192D("%s(): DELBA: %x(%x)\n", __func__,
+				  pmlmeinfo->agg_enable_bitmap, reason_code);
+			/* todo: how to notify the host while receiving DELETE BA */
+			break;
+		default:
+			break;
+		}
 	}
-exit:
-	return ret;
+	return 1;
 }
 
-#endif /* CONFIG_92D_P2P */
-
 static s32 rtw_action_public_decache(struct recv_frame_hdr *recv_frame, s32 token)
 {
 	struct rtw_adapter *adapter = recv_frame->adapter;
@@ -4598,15 +1915,6 @@ static unsigned int on_action_public_p2p
 	u8 *pframe = precv_frame->rx_data;
 	u8 *frame_body;
 	u8 dialogToken = 0;
-#ifdef CONFIG_92D_P2P
-	struct rtw_adapter *adapt = precv_frame->adapter;
-	uint len = precv_frame->len;
-	u8 *p2p_ie;
-	u32 p2p_ielen;
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-	u8 result = P2P_STATUS_SUCCESS;
-	u8 empty_addr[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-#endif /* CONFIG_92D_P2P */
 
 	frame_body =
 	    (unsigned char *)(pframe + sizeof(struct ieee80211_hdr_3addr));
@@ -4615,514 +1923,6 @@ static unsigned int on_action_public_p2p
 
 	if (rtw_action_public_decache(precv_frame, dialogToken) == 0)
 		return 0;
-
-#ifdef CONFIG_92D_P2P
-	del_timer_sync(&pwdinfo->reset_ch_sitesurvey);
-	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
-		rtw_cfg80211_rx_p2p_action_public(adapt, pframe, len);
-	} else {
-		/*      Do nothing if the driver doesn't enable the P2P function. */
-		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) ||
-		    rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
-			return 1;
-
-		len -= sizeof(struct ieee80211_hdr_3addr);
-
-		switch (frame_body[6]) {	/* OUI Subtype */
-		case P2P_GO_NEGO_REQ:
-			DBG_8192D("[%s] Got GO Nego Req Frame\n",
-				  __func__);
-			memset(&pwdinfo->groupid_info, 0x00,
-			       sizeof(struct group_id_info));
-
-			if (rtw_p2p_chk_state
-			    (pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ)) {
-				rtw_p2p_set_state(pwdinfo,
-						  rtw_p2p_pre_state
-						  (pwdinfo));
-			}
-
-			if (rtw_p2p_chk_state
-			    (pwdinfo, P2P_STATE_GONEGO_FAIL)) {
-				/*      Commented by Albert 20110526 */
-				/*      In this case, this means the previous nego fail doesn't be reset yet. */
-				del_timer_sync(&pwdinfo->
-						 restore_p2p_state_timer);
-				/*      Restore the previous p2p state */
-				rtw_p2p_set_state(pwdinfo,
-						  rtw_p2p_pre_state
-						  (pwdinfo));
-				DBG_8192D
-				    ("[%s] Restore the previous p2p state to %d\n",
-				     __func__, rtw_p2p_state(pwdinfo));
-			}
-#ifdef CONFIG_CONCURRENT_MODE
-			if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-				del_timer_sync(&pwdinfo->
-						 ap_p2p_switch_timer);
-			}
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-			/*      Commented by Kurt 20110902 */
-			/* Add if statement to avoid receiving duplicate prov disc req. such that pre_p2p_state would be covered. */
-			if (!rtw_p2p_chk_state
-			    (pwdinfo, P2P_STATE_GONEGO_ING))
-				rtw_p2p_set_pre_state(pwdinfo,
-						      rtw_p2p_state
-						      (pwdinfo));
-
-			/*      Commented by Kurt 20120113 */
-			/*      Get peer_dev_addr here if peer doesn't issue prov_disc frame. */
-/* XXXXXXXX */
-			if (!memcmp(pwdinfo->rx_prov_disc_info.peerDevAddr, empty_addr, ETH_ALEN))
-				memcpy(pwdinfo->rx_prov_disc_info.peerDevAddr,
-			GetAddr2Ptr(pframe), ETH_ALEN);
-
-			result =
-			    process_p2p_group_negotation_req(pwdinfo,
-							     frame_body,
-							     len);
-			issue_p2p_GO_response(adapt,
-					      GetAddr2Ptr(pframe),
-					      frame_body, len, result);
-			/*      No matter negotiating or negotiation failure, the driver should set up the restore P2P state timer. */
-#ifdef CONFIG_CONCURRENT_MODE
-			/*      Commented by Albert 20120107 */
-			_set_timer(&pwdinfo->restore_p2p_state_timer,
-				   3000);
-#else /*  CONFIG_CONCURRENT_MODE */
-			_set_timer(&pwdinfo->restore_p2p_state_timer,
-				   5000);
-#endif /*  CONFIG_CONCURRENT_MODE */
-			break;
-		case P2P_GO_NEGO_RESP:
-			DBG_8192D("[%s] Got GO Nego Resp Frame\n",
-				  __func__);
-
-			if (rtw_p2p_chk_state
-			    (pwdinfo, P2P_STATE_GONEGO_ING)) {
-				/*      Commented by Albert 20110425 */
-				/*      The restore timer is enabled when issuing the nego request frame of rtw_p2p_connect function. */
-				del_timer_sync(&pwdinfo->
-						 restore_p2p_state_timer);
-				pwdinfo->nego_req_info.benable = false;
-				result =
-				    process_p2p_group_negotation_resp
-				    (pwdinfo, frame_body, len);
-				issue_p2p_GO_confirm(pwdinfo->padapter,
-						     GetAddr2Ptr
-						     (pframe), result);
-				if (P2P_STATUS_SUCCESS == result) {
-					if (rtw_p2p_role(pwdinfo) ==
-					    P2P_ROLE_CLIENT) {
-						pwdinfo->p2p_info.
-						    operation_ch[0] =
-						    pwdinfo->
-						    peer_operating_ch;
-						pwdinfo->p2p_info.
-						    scan_op_ch_only = 1;
-						_set_timer(&pwdinfo->
-							   reset_ch_sitesurvey2,
-							   P2P_RESET_SCAN_CH);
-					}
-				}
-
-				/*      Reset the dialog token for group negotiation frames. */
-				pwdinfo->negotiation_dialog_token = 1;
-
-				if (rtw_p2p_chk_state
-				    (pwdinfo, P2P_STATE_GONEGO_FAIL)) {
-					_set_timer(&pwdinfo->
-						   restore_p2p_state_timer,
-						   5000);
-				}
-			} else {
-				DBG_8192D
-				    ("[%s] Skipped GO Nego Resp Frame (p2p_state != P2P_STATE_GONEGO_ING)\n",
-				     __func__);
-			}
-
-			break;
-		case P2P_GO_NEGO_CONF:
-			DBG_8192D("[%s] Got GO Nego Confirm Frame\n",
-				  __func__);
-			result =
-			    process_p2p_group_negotation_confirm
-			    (pwdinfo, frame_body, len);
-			if (P2P_STATUS_SUCCESS == result) {
-				if (rtw_p2p_role(pwdinfo) ==
-				    P2P_ROLE_CLIENT) {
-					pwdinfo->p2p_info.
-					    operation_ch[0] =
-					    pwdinfo->peer_operating_ch;
-					pwdinfo->p2p_info.
-					    scan_op_ch_only = 1;
-					_set_timer(&pwdinfo->
-						   reset_ch_sitesurvey2,
-						   P2P_RESET_SCAN_CH);
-				}
-			}
-			break;
-		case P2P_INVIT_REQ:
-			/*      Added by Albert 2010/10/05 */
-			/*      Received the P2P Invite Request frame. */
-
-			DBG_8192D("[%s] Got invite request frame!\n",
-				  __func__);
-			p2p_ie = rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_,
-						len - _PUBLIC_ACTION_IE_OFFSET_,
-						NULL, &p2p_ielen);
-			if (p2p_ie) {
-				/*      Parse the necessary information from the P2P Invitation Request frame. */
-				/*      For example: The MAC address of sending this P2P Invitation Request frame. */
-				u32 attr_contentlen = 0;
-				u8 status_code =
-				    P2P_STATUS_FAIL_INFO_UNAVAILABLE;
-				struct group_id_info group_id;
-				u8 invitation_flag = 0;
-
-				rtw_get_p2p_attr_content(p2p_ie,
-							 p2p_ielen,
-							 P2P_ATTR_INVITATION_FLAGS,
-							 &invitation_flag,
-							 &attr_contentlen);
-				if (attr_contentlen) {
-					rtw_get_p2p_attr_content(p2p_ie,
-								 p2p_ielen,
-								 P2P_ATTR_GROUP_BSSID,
-								 pwdinfo->
-								 p2p_peer_interface_addr,
-								 &attr_contentlen);
-					/*      Commented by Albert 20120510 */
-					/*      Copy to the pwdinfo->p2p_peer_interface_addr. */
-					/*      So that the WFD UI (or Sigma) can get the peer interface address by using the following command. */
-					/*      #> iwpriv wlan0 p2p_get peer_ifa */
-					/*      After having the peer interface address, the sigma can find the correct conf file for wpa_supplicant. */
-
-					if (attr_contentlen) {
-						DBG_8192D
-						    ("[%s] GO's BSSID = %.2X %.2X %.2X %.2X %.2X %.2X\n",
-						     __func__,
-						     pwdinfo->
-						     p2p_peer_interface_addr
-						     [0],
-						     pwdinfo->
-						     p2p_peer_interface_addr
-						     [1],
-						     pwdinfo->
-						     p2p_peer_interface_addr
-						     [2],
-						     pwdinfo->
-						     p2p_peer_interface_addr
-						     [3],
-						     pwdinfo->
-						     p2p_peer_interface_addr
-						     [4],
-						     pwdinfo->
-						     p2p_peer_interface_addr
-						     [5]);
-					}
-					if (invitation_flag &
-					    P2P_INVITATION_FLAGS_PERSISTENT) {
-						/*      Re-invoke the persistent group. */
-
-						memset(&group_id, 0x00,
-						       sizeof(struct
-							      group_id_info));
-						rtw_get_p2p_attr_content
-						    (p2p_ie, p2p_ielen,
-						     P2P_ATTR_GROUP_ID,
-						     (u8 *)&group_id,
-						     &attr_contentlen);
-						if (attr_contentlen) {
-							if (!memcmp(group_id.go_device_addr, myid
-							     (&adapt->eeprompriv), ETH_ALEN)) {
-								/* The p2p device sending this p2p invitation
-								 * request wants this Wi-Fi device to be the
-								 * persistent GO. */
-								rtw_p2p_set_state
-								    (pwdinfo,
-								     P2P_STATE_RECV_INVITE_REQ_GO);
-								rtw_p2p_set_role
-								    (pwdinfo,
-								     P2P_ROLE_GO);
-								status_code
-								    =
-								    P2P_STATUS_SUCCESS;
-							} else {
-								/*      The p2p device sending this p2p invitation request wants to be the persistent GO. */
-								if (is_matched_in_profilelist(pwdinfo->p2p_peer_interface_addr, &pwdinfo->profileinfo[0])) {
-									u8 operatingch_info[5] = { 0x00 };
-									if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen)) {
-										if (rtw_ch_set_search_ch(adapt->mlmeextpriv.channel_set, (u32) operatingch_info[4])) {
-											/*      The operating channel is acceptable for this device. */
-											pwdinfo->
-											    rx_invitereq_info.
-											    operation_ch
-											    [0]
-											    =
-											    operatingch_info
-											    [4];
-											pwdinfo->
-											    rx_invitereq_info.
-											    scan_op_ch_only
-											    =
-											    1;
-											_set_timer
-											    (&pwdinfo->
-											     reset_ch_sitesurvey,
-											     P2P_RESET_SCAN_CH);
-											rtw_p2p_set_state
-											    (pwdinfo,
-											     P2P_STATE_RECV_INVITE_REQ_MATCH);
-											rtw_p2p_set_role
-											    (pwdinfo,
-											     P2P_ROLE_CLIENT);
-											status_code
-											    =
-											    P2P_STATUS_SUCCESS;
-										} else {
-											/*      The operating channel isn't supported by this device. */
-											rtw_p2p_set_state
-											    (pwdinfo,
-											     P2P_STATE_RECV_INVITE_REQ_DISMATCH);
-											rtw_p2p_set_role
-											    (pwdinfo,
-											     P2P_ROLE_DEVICE);
-											status_code
-											    =
-											    P2P_STATUS_FAIL_NO_COMMON_CH;
-											_set_timer
-											    (&pwdinfo->
-											     restore_p2p_state_timer,
-											     3000);
-										}
-									} else {
-										/*      Commented by Albert 20121130 */
-										/*      Intel will use the different P2P IE to store the operating channel information */
-										/*      Workaround for Intel WiDi 3.5 */
-										rtw_p2p_set_state
-										    (pwdinfo,
-										     P2P_STATE_RECV_INVITE_REQ_MATCH);
-										rtw_p2p_set_role
-										    (pwdinfo,
-										     P2P_ROLE_CLIENT);
-										status_code
-										    =
-										    P2P_STATUS_SUCCESS;
-									}
-								} else {
-									rtw_p2p_set_state
-									    (pwdinfo,
-									     P2P_STATE_RECV_INVITE_REQ_DISMATCH);
-									status_code
-									    =
-									    P2P_STATUS_FAIL_UNKNOWN_P2PGROUP;
-								}
-							}
-						} else {
-							DBG_8192D
-							    ("[%s] P2P Group ID Attribute NOT FOUND!\n",
-							     __func__);
-							status_code =
-							    P2P_STATUS_FAIL_INFO_UNAVAILABLE;
-						}
-					} else {
-						/*      Received the invitation to join a P2P group. */
-
-						memset(&group_id, 0x00,
-						       sizeof(struct
-							      group_id_info));
-						rtw_get_p2p_attr_content
-						    (p2p_ie, p2p_ielen,
-						     P2P_ATTR_GROUP_ID,
-						     (u8 *)&group_id,
-						     &attr_contentlen);
-						if (attr_contentlen) {
-							if (!memcmp(group_id.go_device_addr,
-							    myid (&adapt->eeprompriv), ETH_ALEN)) {
-								/*      In this case, the GO can't be myself. */
-								rtw_p2p_set_state
-								    (pwdinfo,
-								     P2P_STATE_RECV_INVITE_REQ_DISMATCH);
-								status_code
-								    =
-								    P2P_STATUS_FAIL_INFO_UNAVAILABLE;
-							} else {
-								/*      The p2p device sending this p2p invitation request wants to join an existing P2P group */
-								/*      Commented by Albert 2012/06/28 */
-								/*      In this case, this Wi-Fi device should use the iwpriv command to get the peer device address. */
-								/*      The peer device address should be the destination address for the provisioning discovery request. */
-								/*      Then, this Wi-Fi device should use the iwpriv command to get the peer interface address. */
-								/*      The peer interface address should be the address for WPS mac address */
-								memcpy
-								    (pwdinfo->
-								     p2p_peer_device_addr,
-								     group_id.
-								     go_device_addr,
-								     ETH_ALEN);
-								rtw_p2p_set_role
-								    (pwdinfo,
-								     P2P_ROLE_CLIENT);
-								rtw_p2p_set_state
-								    (pwdinfo,
-								     P2P_STATE_RECV_INVITE_REQ_JOIN);
-								status_code
-								    =
-								    P2P_STATUS_SUCCESS;
-							}
-						} else {
-							DBG_8192D
-							    ("[%s] P2P Group ID Attribute NOT FOUND!\n",
-							     __func__);
-							status_code =
-							    P2P_STATUS_FAIL_INFO_UNAVAILABLE;
-						}
-					}
-				} else {
-					DBG_8192D
-					    ("[%s] P2P Invitation Flags Attribute NOT FOUND!\n",
-					     __func__);
-					status_code =
-					    P2P_STATUS_FAIL_INFO_UNAVAILABLE;
-				}
-
-				DBG_8192D("[%s] status_code = %d\n",
-					  __func__, status_code);
-
-				pwdinfo->inviteresp_info.token =
-				    frame_body[7];
-				issue_p2p_invitation_response(adapt,
-							      GetAddr2Ptr
-							      (pframe),
-							      pwdinfo->
-							      inviteresp_info.
-							      token,
-							      status_code);
-			}
-			break;
-		case P2P_INVIT_RESP:
-			{
-				u8 attr_content = 0x00;
-				u32 attr_contentlen = 0;
-
-				DBG_8192D("[%s] Got invite response frame!\n",
-					  __func__);
-				del_timer_sync(&pwdinfo->restore_p2p_state_timer);
-				p2p_ie = rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_,
-							len - _PUBLIC_ACTION_IE_OFFSET_,
-							NULL, &p2p_ielen);
-				if (p2p_ie) {
-					rtw_get_p2p_attr_content(p2p_ie,
-								 p2p_ielen,
-								 P2P_ATTR_STATUS,
-								 &attr_content,
-								 &attr_contentlen);
-
-					if (attr_contentlen == 1) {
-						DBG_8192D("[%s] Status = %d\n",
-							  __func__,
-							  attr_content);
-						pwdinfo->invitereq_info.
-						    benable = false;
-
-						if (attr_content ==
-						    P2P_STATUS_SUCCESS) {
-							if (!memcmp
-							    (pwdinfo->
-							     invitereq_info.
-							     go_bssid,
-							     myid(&adapt->
-								  eeprompriv),
-							     ETH_ALEN)) {
-								rtw_p2p_set_role
-								    (pwdinfo,
-								     P2P_ROLE_GO);
-							} else {
-								rtw_p2p_set_role
-								    (pwdinfo,
-								     P2P_ROLE_CLIENT);
-							}
-							rtw_p2p_set_state
-							    (pwdinfo,
-							     P2P_STATE_RX_INVITE_RESP_OK);
-						} else {
-							rtw_p2p_set_role
-							    (pwdinfo,
-							     P2P_ROLE_DEVICE);
-							rtw_p2p_set_state
-							    (pwdinfo,
-							     P2P_STATE_RX_INVITE_RESP_FAIL);
-						}
-					} else {
-						rtw_p2p_set_role(pwdinfo,
-								 P2P_ROLE_DEVICE);
-						rtw_p2p_set_state(pwdinfo,
-								  P2P_STATE_RX_INVITE_RESP_FAIL);
-					}
-				} else {
-					rtw_p2p_set_role(pwdinfo,
-							 P2P_ROLE_DEVICE);
-					rtw_p2p_set_state(pwdinfo,
-							  P2P_STATE_RX_INVITE_RESP_FAIL);
-				}
-
-				if (rtw_p2p_chk_state
-				    (pwdinfo, P2P_STATE_RX_INVITE_RESP_FAIL)) {
-					_set_timer(&pwdinfo->
-						   restore_p2p_state_timer,
-						   5000);
-				}
-				break;
-			}
-		case P2P_DEVDISC_REQ:
-
-			process_p2p_devdisc_req(pwdinfo, pframe, len);
-
-			break;
-
-		case P2P_DEVDISC_RESP:
-			break;
-		case P2P_PROVISION_DISC_REQ:
-			DBG_8192D
-			    ("[%s] Got Provisioning Discovery Request Frame\n",
-			     __func__);
-			process_p2p_provdisc_req(pwdinfo, pframe, len);
-			memcpy(pwdinfo->rx_prov_disc_info.peerDevAddr,
-			       GetAddr2Ptr(pframe), ETH_ALEN);
-
-			/* Add the following statement to avoid receiving
-			 * duplicate prov disc req. such that pre_p2p_state
-			 * would be covered. */
-			if (!rtw_p2p_chk_state
-			    (pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ))
-				rtw_p2p_set_pre_state(pwdinfo,
-						      rtw_p2p_state(pwdinfo));
-
-			rtw_p2p_set_state(pwdinfo,
-					  P2P_STATE_RX_PROVISION_DIS_REQ);
-			_set_timer(&pwdinfo->restore_p2p_state_timer,
-				   P2P_PROVISION_TIMEOUT);
-			break;
-		case P2P_PROVISION_DISC_RESP:
-			/*      Should we check the pwdinfo->tx_prov_disc_info.bsent flag here?? */
-			DBG_8192D
-			    ("[%s] Got Provisioning Discovery Response Frame\n",
-			     __func__);
-			/*      Commented by Albert 20110426 */
-			/* The restore timer is enabled when issuing the
-			 * provisioing request frame in rtw_p2p_prov_disc
-			 * function. */
-			del_timer_sync(&pwdinfo->restore_p2p_state_timer);
-			rtw_p2p_set_state(pwdinfo,
-					  P2P_STATE_RX_PROVISION_DIS_RSP);
-			_set_timer(&pwdinfo->restore_p2p_state_timer,
-				   P2P_PROVISION_TIMEOUT);
-			break;
-		}
-	}
-#endif /* CONFIG_92D_P2P */
-
 	return 1;
 }
 
@@ -5211,51 +2011,6 @@ unsigned int OnAction_wmm(struct rtw_ada
 unsigned int OnAction_p2p(struct rtw_adapter *adapt,
 			  struct recv_frame_hdr *precv_frame)
 {
-#ifdef CONFIG_92D_P2P
-	u8 *frame_body;
-	u8 category, OUI_Subtype;
-	u8 *pframe = precv_frame->rx_data;
-	uint len = precv_frame->len;
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-
-	DBG_8192D("%s\n", __func__);
-
-	/* check RA matches or not */
-	if (memcmp(myid(&(adapt->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))	/* for if1, sta/ap mode */
-		return 1;
-
-	frame_body =
-	    (unsigned char *)(pframe + sizeof(struct ieee80211_hdr_3addr));
-
-	category = frame_body[0];
-	if (category != RTW_WLAN_CATEGORY_P2P)
-		return 1;
-
-	if (be32_to_cpu(*((__be32 *)(frame_body + 1))) != P2POUI)
-		return 1;
-
-	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
-		rtw_cfg80211_rx_action_p2p(adapt, pframe, len);
-		return 1;
-	} else {
-		len -= sizeof(struct ieee80211_hdr_3addr);
-		OUI_Subtype = frame_body[5];
-		switch (OUI_Subtype) {
-		case P2P_NOTICE_OF_ABSENCE:
-			break;
-		case P2P_PRESENCE_REQUEST:
-			process_p2p_presence_req(pwdinfo, pframe, len);
-			break;
-		case P2P_PRESENCE_RESPONSE:
-			break;
-		case P2P_GO_DISC_REQUEST:
-			break;
-		default:
-			break;
-		}
-	}
-#endif /* CONFIG_92D_P2P */
-
 	return 1;
 }
 
@@ -5286,7 +2041,6 @@ unsigned int OnAction(struct rtw_adapter
 unsigned int DoReserved(struct rtw_adapter *adapt,
 			struct recv_frame_hdr *precv_frame)
 {
-	/* DBG_8192D("rcvd mgt frame(%x, %x)\n", (GetFrameSubType(pframe) >> 4), *(unsigned int *)GetAddr1Ptr(pframe)); */
 	return 1;
 }
 
@@ -5475,9 +2229,6 @@ void issue_beacon(struct rtw_adapter *ad
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-#endif /* CONFIG_92D_P2P */
 	unsigned char *pframe;
 	unsigned short *fctrl;
 	unsigned int rate_len;
@@ -5516,173 +2267,40 @@ void issue_beacon(struct rtw_adapter *ad
 	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
 
 	if ((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) {
-		/* DBG_8192D("ie len=%d\n", cur_network->IELength); */
-#ifdef CONFIG_92D_P2P
-		/*  for P2P : Primary Device Type & Device Name */
-		u32 wpsielen = 0, insert_len = 0;
-		u8 *wpsie = NULL;
-		wpsie =
-		    rtw_get_wps_ie(cur_network->IEs + _FIXED_IE_LENGTH_,
-				   cur_network->IELength - _FIXED_IE_LENGTH_,
-				   NULL, &wpsielen);
-
-		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && wpsie && wpsielen > 0) {
-			uint wps_offset, remainder_ielen;
-			u8 *premainder_ie, *pframe_wscie;
-
-			wps_offset = (uint) (wpsie - cur_network->IEs);
-
-			premainder_ie = wpsie + wpsielen;
-
-			remainder_ielen =
-			    cur_network->IELength - wps_offset - wpsielen;
-
-			if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
-				if (pmlmepriv->wps_beacon_ie && pmlmepriv->wps_beacon_ie_len > 0) {
-					memcpy(pframe, cur_network->IEs,
-					       wps_offset);
-					pframe += wps_offset;
-					pattrib->pktlen += wps_offset;
-
-					memcpy(pframe, pmlmepriv->wps_beacon_ie,
-					       pmlmepriv->wps_beacon_ie_len);
-					pframe += pmlmepriv->wps_beacon_ie_len;
-					pattrib->pktlen +=
-					    pmlmepriv->wps_beacon_ie_len;
-
-					/* copy remainder_ie to pframe */
-					memcpy(pframe, premainder_ie,
-					       remainder_ielen);
-					pframe += remainder_ielen;
-					pattrib->pktlen += remainder_ielen;
-				} else {
-					memcpy(pframe, cur_network->IEs,
-					       cur_network->IELength);
-					pframe += cur_network->IELength;
-					pattrib->pktlen +=
-					    cur_network->IELength;
-				}
-			} else {
-				pframe_wscie = pframe + wps_offset;
-				memcpy(pframe, cur_network->IEs,
-				       wps_offset + wpsielen);
-				pframe += (wps_offset + wpsielen);
-				pattrib->pktlen += (wps_offset + wpsielen);
-
-				/* now pframe is end of wsc ie, insert Primary Device Type & Device Name */
-				/*      Primary Device Type */
-				/*      Type: */
-				*(__be16 *)(pframe + insert_len) =
-				    cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
-				insert_len += 2;
-
-				/*      Length: */
-				*(__be16 *)(pframe + insert_len) =
-				    cpu_to_be16(0x0008);
-				insert_len += 2;
-
-				/*      Value: */
-				/*      Category ID */
-				*(__be16 *)(pframe + insert_len) =
-				    cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
-				insert_len += 2;
-
-				/*      OUI */
-				*(__be32 *)(pframe + insert_len) =
-				    cpu_to_be32(WPSOUI);
-				insert_len += 4;
-
-				/*      Sub Category ID */
-				*(__be16 *)(pframe + insert_len) =
-				    cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
-				insert_len += 2;
-
-				/*      Device Name */
-				/*      Type: */
-				*(__be16 *)(pframe + insert_len) =
-				    cpu_to_be16(WPS_ATTR_DEVICE_NAME);
-				insert_len += 2;
-
-				/*      Length: */
-				*(__be16 *)(pframe + insert_len) =
-				    cpu_to_be16(pwdinfo->device_name_len);
-				insert_len += 2;
-
-				/*      Value: */
-				memcpy(pframe + insert_len,
-				       pwdinfo->device_name,
-				       pwdinfo->device_name_len);
-				insert_len += pwdinfo->device_name_len;
-
-				/* update wsc ie length */
-				*(pframe_wscie + 1) =
-				    (wpsielen - 2) + insert_len;
-
-				/*pframe move to end */
-				pframe += insert_len;
-				pattrib->pktlen += insert_len;
-
-				/* copy remainder_ie to pframe */
-				memcpy(pframe, premainder_ie, remainder_ielen);
-				pframe += remainder_ielen;
-				pattrib->pktlen += remainder_ielen;
-			}
-		} else
-#endif /* CONFIG_92D_P2P */
-		{
-			int len_diff;
-			memcpy(pframe, cur_network->IEs, cur_network->IELength);
-			len_diff =
-			    update_hidden_ssid(pframe + _BEACON_IE_OFFSET_,
-					       cur_network->IELength -
-					       _BEACON_IE_OFFSET_,
-					       pmlmeinfo->hidden_ssid_mode);
-			pframe += (cur_network->IELength + len_diff);
-			pattrib->pktlen += (cur_network->IELength + len_diff);
+		int len_diff;
+		u8 *wps_ie;
+		uint wps_ielen;
+		u8 sr = 0;
+		memcpy(pframe, cur_network->IEs, cur_network->IELength);
+		len_diff =
+		    update_hidden_ssid(pframe + _BEACON_IE_OFFSET_,
+				       cur_network->IELength -
+				       _BEACON_IE_OFFSET_,
+				       pmlmeinfo->hidden_ssid_mode);
+		pframe += (cur_network->IELength + len_diff);
+		pattrib->pktlen += (cur_network->IELength + len_diff);
+
+		wps_ie =
+		    rtw_get_wps_ie(pmgntframe->buf_addr +
+				   TXDESC_OFFSET +
+				   sizeof(struct
+					  ieee80211_hdr_3addr) +
+				   _BEACON_IE_OFFSET_,
+				   pattrib->pktlen -
+				   sizeof(struct
+					  ieee80211_hdr_3addr) -
+				   _BEACON_IE_OFFSET_, NULL,
+				   &wps_ielen);
+		if (wps_ie && wps_ielen > 0) {
+			rtw_get_wps_attr_content(wps_ie, wps_ielen,
+						 WPS_ATTR_SELECTED_REGISTRAR,
+						 (u8 *)(&sr), NULL);
 		}
+		if (sr != 0)
+			set_fwstate(pmlmepriv, WIFI_UNDER_WPS);
+		else
+			_clr_fwstate_(pmlmepriv, WIFI_UNDER_WPS);
 
-		{
-			u8 *wps_ie;
-			uint wps_ielen;
-			u8 sr = 0;
-			wps_ie =
-			    rtw_get_wps_ie(pmgntframe->buf_addr +
-					   TXDESC_OFFSET +
-					   sizeof(struct
-						  ieee80211_hdr_3addr) +
-					   _BEACON_IE_OFFSET_,
-					   pattrib->pktlen -
-					   sizeof(struct
-						  ieee80211_hdr_3addr) -
-					   _BEACON_IE_OFFSET_, NULL,
-					   &wps_ielen);
-			if (wps_ie && wps_ielen > 0) {
-				rtw_get_wps_attr_content(wps_ie, wps_ielen,
-							 WPS_ATTR_SELECTED_REGISTRAR,
-							 (u8 *)(&sr), NULL);
-			}
-			if (sr != 0)
-				set_fwstate(pmlmepriv, WIFI_UNDER_WPS);
-			else
-				_clr_fwstate_(pmlmepriv, WIFI_UNDER_WPS);
-		}
-
-#ifdef CONFIG_92D_P2P
-		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-			u32 len;
-			if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
-				len = pmlmepriv->p2p_beacon_ie_len;
-				if (pmlmepriv->p2p_beacon_ie && len > 0)
-					memcpy(pframe, pmlmepriv->p2p_beacon_ie,
-					       len);
-			} else {
-				len = build_beacon_p2p_ie(pwdinfo, pframe);
-			}
-
-			pframe += len;
-			pattrib->pktlen += len;
-		}
-#endif /* CONFIG_92D_P2P */
 		goto _issue_bcn;
 	}
 
@@ -5786,13 +2404,10 @@ void issue_probersp(struct rtw_adapter *
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-#endif /* CONFIG_92D_P2P */
 	unsigned char *pframe;
 	unsigned short *fctrl;
 	unsigned char *mac, *bssid;
-#if defined (CONFIG_92D_AP_MODE) || defined(CONFIG_92D_P2P)
+#if defined (CONFIG_92D_AP_MODE)
 	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
 #endif
 #if defined (CONFIG_92D_AP_MODE)
@@ -5996,24 +2611,6 @@ void issue_probersp(struct rtw_adapter *
 		}
 	}
 
-#ifdef CONFIG_92D_P2P
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && is_valid_p2p_probereq) {
-		u32 len;
-		if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
-			/* if pwdinfo->role == P2P_ROLE_DEVICE will call issue_probersp_p2p() */
-			len = pmlmepriv->p2p_go_probe_resp_ie_len;
-			if (pmlmepriv->p2p_go_probe_resp_ie && len > 0)
-				memcpy(pframe, pmlmepriv->p2p_go_probe_resp_ie,
-				       len);
-		} else {
-			len = build_probe_resp_p2p_ie(pwdinfo, pframe);
-		}
-
-		pframe += len;
-		pattrib->pktlen += len;
-	}
-#endif /* CONFIG_92D_P2P */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(adapt, pmgntframe);
@@ -6519,12 +3116,6 @@ void issue_assocreq(struct rtw_adapter *
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	int bssrate_len = 0, sta_bssrate_len = 0;
 	u8 cbw40_enable = 0;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-	u8 p2pie[255] = { 0x00 };
-	u16 p2pielen = 0;
-#endif /* CONFIG_92D_P2P */
-
 	u16 cap;
 	u8 pow_cap_ele[2] = {0x00};
 	u8 sup_ch[30 * 2] = {0x00}, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
@@ -6796,163 +3387,6 @@ void issue_assocreq(struct rtw_adapter *
 		    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 6, REALTEK_96B_IE,
 			       &(pattrib->pktlen));
 	}
-#ifdef CONFIG_92D_P2P
-
-	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
-		if (pmlmepriv->p2p_assoc_req_ie &&
-		    pmlmepriv->p2p_assoc_req_ie_len > 0) {
-			memcpy(pframe, pmlmepriv->p2p_assoc_req_ie,
-			       pmlmepriv->p2p_assoc_req_ie_len);
-			pframe += pmlmepriv->p2p_assoc_req_ie_len;
-			pattrib->pktlen += pmlmepriv->p2p_assoc_req_ie_len;
-		}
-	} else {
-		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) &&
-		    !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE)) {
-			/*      Should add the P2P IE in the association request frame. */
-			/*      P2P OUI */
-
-			p2pielen = 0;
-			p2pie[p2pielen++] = 0x50;
-			p2pie[p2pielen++] = 0x6F;
-			p2pie[p2pielen++] = 0x9A;
-			p2pie[p2pielen++] = 0x09;	/*      WFA P2P v1.0 */
-
-			/*      Commented by Albert 20101109 */
-			/*      According to the P2P Specification, the association request frame should contain 3 P2P attributes */
-			/*      1. P2P Capability */
-			/*      2. Extended Listen Timing */
-			/*      3. Device Info */
-			/*      Commented by Albert 20110516 */
-			/*      4. P2P Interface */
-
-			/*      P2P Capability */
-			/*      Type: */
-			p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
-
-			/*      Length: */
-			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
-			p2pielen += 2;
-
-			/*      Value: */
-			/*      Device Capability Bitmap, 1 byte */
-			p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
-
-			/*      Group Capability Bitmap, 1 byte */
-			if (pwdinfo->persistent_supported)
-				p2pie[p2pielen++] =
-				    P2P_GRPCAP_PERSISTENT_GROUP |
-				    DMP_P2P_GRPCAP_SUPPORT;
-			else
-				p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
-
-			/*      Extended Listen Timing */
-			/*      Type: */
-			p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
-
-			/*      Length: */
-			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0004);
-			p2pielen += 2;
-
-			/*      Value: */
-			/*      Availability Period */
-			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
-			p2pielen += 2;
-
-			/*      Availability Interval */
-			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
-			p2pielen += 2;
-
-			/*      Device Info */
-			/*      Type: */
-			p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
-
-			/*      Length: */
-			/*      21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
-			/*      + NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
-			*(__le16 *)(p2pie + p2pielen) =
-			    cpu_to_le16(21 + pwdinfo->device_name_len);
-			p2pielen += 2;
-
-			/*      Value: */
-			/*      P2P Device Address */
-			memcpy(p2pie + p2pielen, myid(&adapt->eeprompriv),
-			       ETH_ALEN);
-			p2pielen += ETH_ALEN;
-
-			/*      Config Method */
-			/*      This field should be big endian. Noted by P2P specification. */
-			if ((pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN) ||
-			    (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_SELF_DISPLAY_PIN)) {
-				*(__be16 *)(p2pie + p2pielen) =
-				    cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY);
-			} else {
-				*(__be16 *)(p2pie + p2pielen) =
-				    cpu_to_be16(WPS_CONFIG_METHOD_PBC);
-			}
-
-			p2pielen += 2;
-
-			/*      Primary Device Type */
-			/*      Category ID */
-			*(__be16 *)(p2pie + p2pielen) =
-			    cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
-			p2pielen += 2;
-
-			/*      OUI */
-			*(__be32 *)(p2pie + p2pielen) = cpu_to_be32(WPSOUI);
-			p2pielen += 4;
-
-			/*      Sub Category ID */
-			*(__be16 *)(p2pie + p2pielen) =
-			    cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
-			p2pielen += 2;
-
-			/*      Number of Secondary Device Types */
-			p2pie[p2pielen++] = 0x00;	/*      No Secondary Device Type List */
-
-			/*      Device Name */
-			/*      Type: */
-			*(__be16 *)(p2pie + p2pielen) =
-			    cpu_to_be16(WPS_ATTR_DEVICE_NAME);
-			p2pielen += 2;
-
-			/*      Length: */
-			*(__be16 *)(p2pie + p2pielen) =
-			    cpu_to_be16(pwdinfo->device_name_len);
-			p2pielen += 2;
-
-			/*      Value: */
-			memcpy(p2pie + p2pielen, pwdinfo->device_name,
-			       pwdinfo->device_name_len);
-			p2pielen += pwdinfo->device_name_len;
-
-			/*      P2P Interface */
-			/*      Type: */
-			p2pie[p2pielen++] = P2P_ATTR_INTERFACE;
-
-			/*      Length: */
-			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x000D);
-			p2pielen += 2;
-
-			/*      Value: */
-			memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);	/*      P2P Device Address */
-			p2pielen += ETH_ALEN;
-
-			p2pie[p2pielen++] = 1;	/*      P2P Interface Address Count */
-
-			memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);	/*      P2P Interface Address List */
-			p2pielen += ETH_ALEN;
-
-			pframe =
-			    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen,
-				       (unsigned char *)p2pie,
-				       &pattrib->pktlen);
-		}
-	}
-
-#endif /* CONFIG_92D_P2P */
-
 	pattrib->last_txcmdsz = pattrib->pktlen;
 	dump_mgntframe(adapt, pmgntframe);
 
@@ -7242,17 +3676,6 @@ static int _issue_deauth(struct rtw_adap
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	int ret = 0;
 	__le16 le_tmp;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-#endif /* CONFIG_92D_P2P */
-
-#ifdef CONFIG_92D_P2P
-	if (!(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) &&
-	    (pwdinfo->rx_invitereq_info.scan_op_ch_only)) {
-		del_timer_sync(&pwdinfo->reset_ch_sitesurvey);
-		_set_timer(&pwdinfo->reset_ch_sitesurvey, 10);
-	}
-#endif /* CONFIG_92D_P2P */
 
 	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
 	if (pmgntframe == NULL)
@@ -7834,79 +4257,22 @@ void site_survey(struct rtw_adapter *ada
 #ifdef CONFIG_92D_AP_MODE
 	u8 stay_buddy_ch = 0;
 #endif
+	struct rtw_ieee80211_channel *ch;
 
-#ifdef CONFIG_92D_P2P
-
-#ifdef CONFIG_CONCURRENT_MODE
-	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
-	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
-	struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
-#endif /* CONFIG_CONCURRENT_MODE */
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-
-	if ((pwdinfo->rx_invitereq_info.scan_op_ch_only) ||
-	    (pwdinfo->p2p_info.scan_op_ch_only)) {
-		if (pwdinfo->rx_invitereq_info.scan_op_ch_only) {
-			survey_channel =
-			    pwdinfo->rx_invitereq_info.operation_ch[pmlmeext->
-								    sitesurvey_res.
-								    channel_idx];
-		} else {
-			survey_channel =
-			    pwdinfo->p2p_info.operation_ch[pmlmeext->
-							   sitesurvey_res.
-							   channel_idx];
-		}
-		ScanType = SCAN_ACTIVE;
-	} else if (rtw_p2p_findphase_ex_is_social(pwdinfo)) {
-		/*      Commented by Albert 2011/06/03 */
-		/*      The driver is in the find phase, it should go through the social channel. */
-		int ch_set_idx;
-		survey_channel =
-		    pwdinfo->social_chan[pmlmeext->sitesurvey_res.channel_idx];
-		ch_set_idx =
-		    rtw_ch_set_search_ch(pmlmeext->channel_set, survey_channel);
-		if (ch_set_idx >= 0)
-			ScanType = pmlmeext->channel_set[ch_set_idx].ScanType;
-		else
-			ScanType = SCAN_ACTIVE;
-	} else
-#endif /* CONFIG_92D_P2P */
-	{
-		struct rtw_ieee80211_channel *ch;
-		if (pmlmeext->sitesurvey_res.channel_idx <
-		    pmlmeext->sitesurvey_res.ch_num) {
-			ch = &pmlmeext->sitesurvey_res.ch[pmlmeext->
-							  sitesurvey_res.
-							  channel_idx];
-			survey_channel = ch->hw_value;
-			ScanType =
-			    (ch->
-			     flags & RTW_IEEE80211_CHAN_PASSIVE_SCAN) ?
-			    SCAN_PASSIVE : SCAN_ACTIVE;
-		}
+	if (pmlmeext->sitesurvey_res.channel_idx <
+	    pmlmeext->sitesurvey_res.ch_num) {
+		ch = &pmlmeext->sitesurvey_res.ch[pmlmeext->
+						  sitesurvey_res.
+						  channel_idx];
+		survey_channel = ch->hw_value;
+		ScanType =
+		    (ch->
+		     flags & RTW_IEEE80211_CHAN_PASSIVE_SCAN) ?
+		    SCAN_PASSIVE : SCAN_ACTIVE;
 	}
 
 	if (survey_channel != 0) {
 		/* PAUSE 4-AC Queue when site_survey */
-#ifdef CONFIG_CONCURRENT_MODE
-#ifdef CONFIG_92D_AP_MODE
-		if ((adapt->pbuddy_adapter->mlmeextpriv.mlmext_info.
-		     state & 0x03) == WIFI_FW_AP_STATE) {
-			if (pmlmeinfo->scan_cnt == RTW_SCAN_NUM_OF_CH) {
-				pmlmeinfo->scan_cnt = 0;
-				survey_channel = pbuddy_mlmeext->cur_channel;
-				ScanType = SCAN_ACTIVE;
-				stay_buddy_ch = 1;
-			} else {
-				if (pmlmeinfo->scan_cnt == 0)
-					stay_buddy_ch = 2;
-				pmlmeinfo->scan_cnt++;
-			}
-		}
-#endif
-#endif /* CONFIG_CONCURRENT_MODE */
 		if (pmlmeext->sitesurvey_res.channel_idx == 0) {
 			set_channel_bwmode(adapt, survey_channel,
 					   HAL_PRIME_CHNL_OFFSET_DONT_CARE,
@@ -7934,46 +4300,34 @@ void site_survey(struct rtw_adapter *ada
 #endif
 
 		if (ScanType == SCAN_ACTIVE) {	/* obey the channel plan setting... */
-#ifdef CONFIG_92D_P2P
-			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) ||
-			    rtw_p2p_chk_state(pwdinfo,
-					      P2P_STATE_FIND_PHASE_SEARCH)
-			   ) {
-				issue_probereq_p2p(adapt, NULL);
-				issue_probereq_p2p(adapt, NULL);
-				issue_probereq_p2p(adapt, NULL);
-			} else
-#endif /* CONFIG_92D_P2P */
-			{
-				int i;
-				for (i = 0; i < RTW_SSID_SCAN_AMOUNT; i++) {
-					if (pmlmeext->sitesurvey_res.ssid[i].
-					    SsidLength) {
-						/* todo: to issue two probe req??? */
-						issue_probereq(adapt,
-							       &(pmlmeext->
-								 sitesurvey_res.
-								 ssid[i]),
-							       NULL);
-						/* msleep(SURVEY_TO>>1); */
-						issue_probereq(adapt,
-							       &(pmlmeext->
-								 sitesurvey_res.
-								 ssid[i]),
-							       NULL);
-					} else {
-						break;
-					}
-				}
-
-				if (pmlmeext->sitesurvey_res.scan_mode ==
-				    SCAN_ACTIVE) {
+			int i;
+			for (i = 0; i < RTW_SSID_SCAN_AMOUNT; i++) {
+				if (pmlmeext->sitesurvey_res.ssid[i].
+				    SsidLength) {
 					/* todo: to issue two probe req??? */
-					issue_probereq(adapt, NULL, NULL);
+					issue_probereq(adapt,
+						       &(pmlmeext->
+							 sitesurvey_res.
+							 ssid[i]),
+						       NULL);
 					/* msleep(SURVEY_TO>>1); */
-					issue_probereq(adapt, NULL, NULL);
+					issue_probereq(adapt,
+						       &(pmlmeext->
+							 sitesurvey_res.
+							 ssid[i]),
+						       NULL);
+				} else {
+					break;
 				}
 			}
+
+			if (pmlmeext->sitesurvey_res.scan_mode ==
+			    SCAN_ACTIVE) {
+				/* todo: to issue two probe req??? */
+				issue_probereq(adapt, NULL, NULL);
+				/* msleep(SURVEY_TO>>1); */
+				issue_probereq(adapt, NULL, NULL);
+			}
 		}
 		set_survey_timer(pmlmeext, pmlmeext->chan_scan_time);
 	} else {
@@ -8001,136 +4355,78 @@ void site_survey(struct rtw_adapter *ada
 		}
 #endif
 
-#ifdef CONFIG_92D_P2P
-		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) ||
-		    rtw_p2p_chk_state(pwdinfo,
-					 P2P_STATE_FIND_PHASE_SEARCH)) {
-			if ((pwdinfo->rx_invitereq_info.scan_op_ch_only) ||
-			    (pwdinfo->p2p_info.scan_op_ch_only)) {
-				/*      Set the find_phase_state_exchange_cnt to P2P_FINDPHASE_EX_CNT. */
-				/*      This will let the following flow to run the scanning end. */
-				rtw_p2p_findphase_ex_set(pwdinfo,
-							 P2P_FINDPHASE_EX_MAX);
-			}
-		}
-
-		if (rtw_p2p_findphase_ex_is_needed(pwdinfo)) {
-			/*      Set the P2P State to the listen state of find phase and set the current channel to the listen channel */
-			set_channel_bwmode(adapt, pwdinfo->listen_channel,
-					   HAL_PRIME_CHNL_OFFSET_DONT_CARE,
-					   HT_CHANNEL_WIDTH_20);
-			rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_LISTEN);
-			pmlmeext->sitesurvey_res.state = SCAN_DISABLE;
-
-			initialgain = 0xff;	/* restore RX GAIN */
-			rtw_hal_set_hwreg(adapt, HW_VAR_INITIAL_GAIN,
-					  (u8 *)(&initialgain));
-			/* turn on dynamic functions */
-			Restore_DM_Func_Flag(adapt);
-			/* Switch_DM_Func(adapt, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true); */
-
-			_set_timer(&pwdinfo->find_phase_timer,
-				   (u32) ((u32) (pwdinfo->listen_dwell) * 100));
-		} else
-#endif /* CONFIG_92D_P2P */
-		{
-#ifdef CONFIG_92D_P2P
-			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) || rtw_p2p_chk_state(pwdinfo,
-			    P2P_STATE_FIND_PHASE_SEARCH))
-				rtw_p2p_set_state(pwdinfo,
-						  rtw_p2p_pre_state(pwdinfo));
-			rtw_p2p_findphase_ex_set(pwdinfo,
-						 P2P_FINDPHASE_EX_NONE);
-#endif /* CONFIG_92D_P2P */
-
-			pmlmeext->sitesurvey_res.state = SCAN_COMPLETE;
-
-			/* switch back to the original channel */
-			/* SelectChannel(adapt, pmlmeext->cur_channel, pmlmeext->cur_ch_offset); */
-
-			{
+		pmlmeext->sitesurvey_res.state = SCAN_COMPLETE;
 #ifdef CONFIG_DUALMAC_CONCURRENT
-				dc_set_channel_bwmode_survey_done(adapt);
+		dc_set_channel_bwmode_survey_done(adapt);
 #else
 #ifdef CONFIG_CONCURRENT_MODE
-					set_channel_bwmode(adapt,
-							   cur_channel,
-							   cur_ch_offset,
-							   cur_bwmode);
+		set_channel_bwmode(adapt, cur_channel,
+				   cur_ch_offset, cur_bwmode);
 #else
-					set_channel_bwmode(adapt,
-							   pmlmeext->
-							   cur_channel,
-							   pmlmeext->
-							   cur_ch_offset,
-							   pmlmeext->
-							   cur_bwmode);
+		set_channel_bwmode(adapt, pmlmeext-> cur_channel,
+				   pmlmeext-> cur_ch_offset, pmlmeext-> cur_bwmode);
 #endif
 #endif /* CONFIG_DUALMAC_CONCURRENT */
-			}
 
-			/* flush 4-AC Queue after site_survey */
-			/* val8 = 0; */
-			/* rtw_hal_set_hwreg(adapt, HW_VAR_TXPAUSE, (u8 *)(&val8)); */
+		/* flush 4-AC Queue after site_survey */
+		/* val8 = 0; */
+		/* rtw_hal_set_hwreg(adapt, HW_VAR_TXPAUSE, (u8 *)(&val8)); */
 
-			val8 = 0;	/* survey done */
-			rtw_hal_set_hwreg(adapt, HW_VAR_MLME_SITESURVEY,
-					  (u8 *)(&val8));
+		val8 = 0;	/* survey done */
+		rtw_hal_set_hwreg(adapt, HW_VAR_MLME_SITESURVEY,
+				  (u8 *)(&val8));
 
-			/* config MSR */
-			Set_MSR(adapt, (pmlmeinfo->state & 0x3));
+		/* config MSR */
+		Set_MSR(adapt, (pmlmeinfo->state & 0x3));
 
-			initialgain = 0xff;	/* restore RX GAIN */
-			rtw_hal_set_hwreg(adapt, HW_VAR_INITIAL_GAIN,
-					  (u8 *)(&initialgain));
-			/* turn on dynamic functions */
-			Restore_DM_Func_Flag(adapt);
-			/* Switch_DM_Func(adapt, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true); */
+		initialgain = 0xff;	/* restore RX GAIN */
+		rtw_hal_set_hwreg(adapt, HW_VAR_INITIAL_GAIN,
+				  (u8 *)(&initialgain));
+		/* turn on dynamic functions */
+		Restore_DM_Func_Flag(adapt);
+		/* Switch_DM_Func(adapt, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true); */
 
-			if (is_client_associated_to_ap(adapt) == true) {
-				issue_nulldata(adapt, NULL, 0, 3, 500);
+		if (is_client_associated_to_ap(adapt) == true) {
+			issue_nulldata(adapt, NULL, 0, 3, 500);
 
 #ifdef CONFIG_CONCURRENT_MODE
-				if (is_client_associated_to_ap
-				    (adapt->pbuddy_adapter) == true) {
-					DBG_8192D
-					    ("adapter is surveydone(buddy_adapter is linked), issue nulldata(pwrbit=0)\n");
+			if (is_client_associated_to_ap
+			    (adapt->pbuddy_adapter) == true) {
+				DBG_8192D
+				    ("adapter is surveydone(buddy_adapter is linked), issue nulldata(pwrbit=0)\n");
 
-					issue_nulldata(adapt->pbuddy_adapter,
-						       NULL, 0, 3, 500);
-				}
-#endif
+				issue_nulldata(adapt->pbuddy_adapter,
+					       NULL, 0, 3, 500);
 			}
+#endif
+		}
 #ifdef CONFIG_CONCURRENT_MODE
-			else if (is_client_associated_to_ap
-				 (adapt->pbuddy_adapter) == true) {
-				issue_nulldata(adapt->pbuddy_adapter, NULL,
-					       0, 3, 500);
-			}
+		else if (is_client_associated_to_ap
+			 (adapt->pbuddy_adapter) == true) {
+			issue_nulldata(adapt->pbuddy_adapter, NULL,
+				       0, 3, 500);
+		}
 #endif
 
-			report_surveydone_event(adapt);
+		report_surveydone_event(adapt);
 
-			pmlmeext->chan_scan_time = SURVEY_TO;
-			pmlmeext->sitesurvey_res.state = SCAN_DISABLE;
+		pmlmeext->chan_scan_time = SURVEY_TO;
+		pmlmeext->sitesurvey_res.state = SCAN_DISABLE;
 
-			issue_action_BSSCoexistPacket(adapt);
-			issue_action_BSSCoexistPacket(adapt);
-			issue_action_BSSCoexistPacket(adapt);
-		}
+		issue_action_BSSCoexistPacket(adapt);
+		issue_action_BSSCoexistPacket(adapt);
+		issue_action_BSSCoexistPacket(adapt);
+	}
 
 #ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_mlmeinfo_state(adapt, WIFI_FW_AP_STATE) &&
-		    check_buddy_fwstate(adapt, _FW_LINKED)) {
-			DBG_8192D
-			    ("survey done, current CH=%d, BW=%d, offset=%d\n",
-			     cur_channel, cur_bwmode, cur_ch_offset);
-			DBG_8192D("restart pbuddy_adapter's beacon\n");
-			update_beacon(adapt->pbuddy_adapter, 0, NULL, true);
-		}
-#endif
+	if (check_buddy_mlmeinfo_state(adapt, WIFI_FW_AP_STATE) &&
+	    check_buddy_fwstate(adapt, _FW_LINKED)) {
+		DBG_8192D("survey done, current CH=%d, BW=%d, offset=%d\n",
+			  cur_channel, cur_bwmode, cur_ch_offset);
+		DBG_8192D("restart pbuddy_adapter's beacon\n");
+		update_beacon(adapt->pbuddy_adapter, 0, NULL, true);
 	}
-
+#endif
 	return;
 }
 
@@ -9387,11 +5683,6 @@ void linked_status_chk(struct rtw_adapte
 		psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
 		if (psta != NULL) {
 			bool is_p2p_enable = false;
-#ifdef CONFIG_92D_P2P
-			is_p2p_enable =
-			    !rtw_p2p_chk_state(&adapt->wdinfo,
-					       P2P_STATE_NONE);
-#endif
 
 			if (chk_ap_is_alive(adapt, psta) == false)
 				rx_chk = 0;
@@ -9524,9 +5815,6 @@ void survey_timer_hdl(struct rtw_adapter
 	struct sitesurvey_parm *psurveyPara;
 	struct cmd_priv *pcmdpriv = &adapt->cmdpriv;
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
-#endif
 
 	/* issue rtw_sitesurvey_cmd */
 	if (pmlmeext->sitesurvey_res.state > SCAN_START) {
@@ -9534,41 +5822,27 @@ void survey_timer_hdl(struct rtw_adapter
 			pmlmeext->sitesurvey_res.channel_idx++;
 
 		if (pmlmeext->scan_abort == true) {
-#ifdef CONFIG_92D_P2P
-			if (!rtw_p2p_chk_state
-			    (&adapt->wdinfo, P2P_STATE_NONE)) {
-				rtw_p2p_findphase_ex_set(pwdinfo,
-							 P2P_FINDPHASE_EX_MAX);
-				pmlmeext->sitesurvey_res.channel_idx = 3;
-				DBG_8192D("%s idx:%d, cnt:%u\n", __func__,
-					  pmlmeext->sitesurvey_res.channel_idx,
-					  pwdinfo->
-					  find_phase_state_exchange_cnt);
-			} else
-#endif
-			{
-				pmlmeext->sitesurvey_res.channel_idx =
+			pmlmeext->sitesurvey_res.channel_idx =
 				    pmlmeext->sitesurvey_res.ch_num;
-				DBG_8192D("%s idx:%d\n", __func__,
-					  pmlmeext->sitesurvey_res.channel_idx);
-			}
+			DBG_8192D("%s idx:%d\n", __func__,
+				  pmlmeext->sitesurvey_res.channel_idx);
 
 			pmlmeext->scan_abort = false;	/* reset */
-		}
 
-		ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
-		if (ph2c == NULL)
-			goto exit_survey_timer_hdl;
-
-		psurveyPara = (struct sitesurvey_parm *)kzalloc(sizeof(struct sitesurvey_parm), GFP_ATOMIC);
-		if (psurveyPara == NULL) {
-			kfree(ph2c);
-			goto exit_survey_timer_hdl;
-		}
+			ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+			if (ph2c == NULL)
+				goto exit_survey_timer_hdl;
+
+			psurveyPara = (struct sitesurvey_parm *)kzalloc(sizeof(struct sitesurvey_parm), GFP_ATOMIC);
+			if (psurveyPara == NULL) {
+				kfree(ph2c);
+				goto exit_survey_timer_hdl;
+			}
 
-		init_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara,
-					   GEN_CMD_CODE(_SITESURVEY));
-		rtw_enqueue_cmd(pcmdpriv, ph2c);
+			init_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara,
+						   GEN_CMD_CODE(_SITESURVEY));
+			rtw_enqueue_cmd(pcmdpriv, ph2c);
+		}
 	}
 
 exit_survey_timer_hdl:
@@ -11126,16 +7400,9 @@ int concurrent_chk_start_clnt_join(struc
 			rtw_hal_set_hwreg(adapt, HW_VAR_CHECK_TXBUF, 0);
 		}
 	} else if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == true && check_fwstate(pbuddy_mlmepriv, WIFI_STATION_STATE) == true) {	/* for Client Mode/p2p client */
-#if defined(CONFIG_92D_P2P)
-		struct wifidirect_info *pbuddy_wdinfo =
-		    &(pbuddy_adapter->wdinfo);
-		if (!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
-			return 1;	/* wlan0-sta mode has higher priority than p2p0-p2p client */
-#endif /* CONFIG_92D_P2P */
 
 		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel) {
-			DBG_8192D
-			    ("start_clnt_join(ch=%d), but channel mismatch with buddy(ch=%d) interface\n",
+			DBG_8192D("start_clnt_join(ch=%d), but channel mismatch with buddy(ch=%d) interface\n",
 			     pmlmeext->cur_channel,
 			     pbuddy_mlmeext->cur_channel);
 
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ /dev/null
@@ -1,2224 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *
- ******************************************************************************/
-#define _RTW_P2P_C_
-
-#include <drv_types.h>
-#include <rtw_p2p.h>
-#include <wifi.h>
-
-#ifdef CONFIG_92D_P2P
-
-static int rtw_p2p_is_channel_list_ok(u8 desired_ch, u8 *ch_list, u8 ch_cnt)
-{
-	int found = 0, i = 0;
-
-	for (i = 0; i < ch_cnt; i++) {
-		if (ch_list[i] == desired_ch) {
-			found = 1;
-			break;
-		}
-	}
-	return found;
-}
-
-static u32 go_add_group_info_attr(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	struct list_head *phead, *plist;
-	u32 len = 0;
-	u16 attr_len = 0;
-	u8 tmplen, *pdata_attr, *pstart, *pcur;
-	struct sta_info *psta = NULL;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct sta_priv *pstapriv = &padapter->stapriv;
-
-	DBG_8192D("%s\n", __func__);
-
-	pdata_attr = kzalloc(MAX_P2P_IE_LEN, GFP_KERNEL);
-
-	pstart = pdata_attr;
-	pcur = pdata_attr;
-
-	spin_lock_bh(&pstapriv->asoc_list_lock);
-	phead = &pstapriv->asoc_list;
-	plist = phead->next;
-
-	/* look up sta asoc_queue */
-	while ((rtw_end_of_queue_search(phead, plist)) == false) {
-		psta = container_of(plist, struct sta_info, asoc_list);
-
-		plist = plist->next;
-
-		if (psta->is_p2p_device) {
-			tmplen = 0;
-
-			pcur++;
-
-			/* P2P device address */
-			memcpy(pcur, psta->dev_addr, ETH_ALEN);
-			pcur += ETH_ALEN;
-
-			/* P2P interface address */
-			memcpy(pcur, psta->hwaddr, ETH_ALEN);
-			pcur += ETH_ALEN;
-
-			*pcur = psta->dev_cap;
-			pcur++;
-
-			RTW_PUT_BE16(pcur, psta->config_methods);
-			pcur += 2;
-
-			memcpy(pcur, psta->primary_dev_type, 8);
-			pcur += 8;
-
-			*pcur = psta->num_of_secdev_type;
-			pcur++;
-
-			memcpy(pcur, psta->secdev_types_list, psta->num_of_secdev_type*8);
-			pcur += psta->num_of_secdev_type*8;
-
-			if (psta->dev_name_len > 0) {
-				RTW_PUT_BE16(pcur, WPS_ATTR_DEVICE_NAME);
-				pcur += 2;
-
-				RTW_PUT_BE16(pcur, psta->dev_name_len);
-				pcur += 2;
-
-				memcpy(pcur, psta->dev_name, psta->dev_name_len);
-				pcur += psta->dev_name_len;
-			}
-
-			tmplen = (u8)(pcur-pstart);
-
-			*pstart = (tmplen-1);
-
-			attr_len += tmplen;
-
-			/* pstart += tmplen; */
-			pstart = pcur;
-		}
-	}
-	spin_unlock_bh(&pstapriv->asoc_list_lock);
-
-	if (attr_len > 0)
-		len = rtw_set_p2p_attr_content(pbuf, P2P_ATTR_GROUP_INFO, attr_len, pdata_attr);
-
-	kfree(pdata_attr);
-
-	return len;
-}
-
-static void issue_group_disc_req(struct wifidirect_info *pwdinfo, u8 *da)
-{
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	unsigned char					*pframe;
-	struct ieee80211_hdr	*pwlanhdr;
-	unsigned short				*fctrl;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	unsigned char category = RTW_WLAN_CATEGORY_P2P;/* P2P action frame */
-	__be32	p2poui = cpu_to_be32(P2POUI);
-	u8 oui_subtype = P2P_GO_DISC_REQUEST;
-	u8 dialogToken = 0;
-
-	DBG_8192D("[%s]\n", __func__);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(padapter, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-
-	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, pwdinfo->interface_addr, ETH_ALEN);
-	memcpy(pwlanhdr->addr3, pwdinfo->interface_addr, ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
-
-	/* Build P2P action frame header */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *)&(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
-
-	/* there is no IE in this P2P action frame */
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	dump_mgntframe(padapter, pmgntframe);
-}
-
-static void issue_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *da, u8 status, u8 dialogToken)
-{
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	unsigned char					*pframe;
-	struct ieee80211_hdr	*pwlanhdr;
-	unsigned short				*fctrl;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
-	u8 action = P2P_PUB_ACTION_ACTION;
-	__be32	p2poui = cpu_to_be32(P2POUI);
-	u8 oui_subtype = P2P_DEVDISC_RESP;
-	u8 p2pie[8] = { 0x00 };
-	u32 p2pielen = 0;
-
-	DBG_8192D("[%s]\n", __func__);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(padapter, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-
-	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, pwdinfo->device_addr, ETH_ALEN);
-	memcpy(pwlanhdr->addr3, pwdinfo->device_addr, ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
-
-	/* Build P2P public action frame header */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *)&(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
-
-	/* Build P2P IE */
-	/*	P2P OUI */
-	p2pielen = 0;
-	p2pie[p2pielen++] = 0x50;
-	p2pie[p2pielen++] = 0x6F;
-	p2pie[p2pielen++] = 0x9A;
-	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
-
-	/*  P2P_ATTR_STATUS */
-	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status);
-
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, p2pie, &pattrib->pktlen);
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	dump_mgntframe(padapter, pmgntframe);
-}
-
-static void issue_p2p_provision_resp(struct wifidirect_info *pwdinfo, u8 *raddr, u8 *frame_body, u16 config_method)
-{
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
-	u8 action = P2P_PUB_ACTION_ACTION;
-	u8 dialogToken = frame_body[7];	/*	The Dialog Token of provisioning discovery request frame. */
-	__be32	p2poui = cpu_to_be32(P2POUI);
-	u8 oui_subtype = P2P_PROVISION_DISC_RESP;
-	u8 wpsie[100] = { 0x00 };
-	u8 wpsielen = 0;
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	unsigned char					*pframe;
-	struct ieee80211_hdr	*pwlanhdr;
-	unsigned short				*fctrl;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(padapter, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-
-	memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
-	memcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
-
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *)&(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
-
-	wpsielen = 0;
-	/*	WPS OUI */
-	RTW_PUT_BE32(wpsie, WPSOUI);
-	wpsielen += 4;
-
-	/*	Config Method */
-	/*	Type: */
-	RTW_PUT_BE16(wpsie + wpsielen, WPS_ATTR_CONF_METHOD);
-	wpsielen += 2;
-
-	/*	Length: */
-	RTW_PUT_BE16(wpsie + wpsielen, 0x0002);
-	wpsielen += 2;
-
-	/*	Value: */
-	RTW_PUT_BE16(wpsie + wpsielen, config_method);
-	wpsielen += 2;
-
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *)wpsie, &pattrib->pktlen);
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	dump_mgntframe(padapter, pmgntframe);
-
-	return;
-}
-
-static void issue_p2p_presence_resp(struct wifidirect_info *pwdinfo, u8 *da, u8 status, u8 dialogToken)
-{
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	unsigned char					*pframe;
-	struct ieee80211_hdr	*pwlanhdr;
-	unsigned short				*fctrl;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	unsigned char category = RTW_WLAN_CATEGORY_P2P;/* P2P action frame */
-	__be32	p2poui = cpu_to_be32(P2POUI);
-	u8 oui_subtype = P2P_PRESENCE_RESPONSE;
-	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
-	u8 noa_attr_content[32] = { 0x00 };
-	u32 p2pielen = 0;
-
-	DBG_8192D("[%s]\n", __func__);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(padapter, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-
-	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, pwdinfo->interface_addr, ETH_ALEN);
-	memcpy(pwlanhdr->addr3, pwdinfo->interface_addr, ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
-
-	/* Build P2P action frame header */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *)&(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
-
-	/* Add P2P IE header */
-	/*	P2P OUI */
-	p2pielen = 0;
-	p2pie[p2pielen++] = 0x50;
-	p2pie[p2pielen++] = 0x6F;
-	p2pie[p2pielen++] = 0x9A;
-	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
-
-	/* Add Status attribute in P2P IE */
-	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status);
-
-	/* Add NoA attribute in P2P IE */
-	noa_attr_content[0] = 0x1;/* index */
-	noa_attr_content[1] = 0x0;/* CTWindow and OppPS Parameters */
-
-	/* todo: Notice of Absence Descriptor(s) */
-
-	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_NOA, 2, noa_attr_content);
-
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, p2pie, &(pattrib->pktlen));
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	dump_mgntframe(padapter, pmgntframe);
-}
-
-u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
-	u16 capability = 0;
-	u32 len = 0, p2pielen = 0;
-	__le16 le_tmp;
-
-	/*	P2P OUI */
-	p2pielen = 0;
-	p2pie[p2pielen++] = 0x50;
-	p2pie[p2pielen++] = 0x6F;
-	p2pie[p2pielen++] = 0x9A;
-	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
-
-	/*	According to the P2P Specification, the beacon frame should contain 3 P2P attributes */
-	/*	1. P2P Capability */
-	/*	2. P2P Device ID */
-	/*	3. Notice of Absence (NOA) */
-
-	/*	P2P Capability ATTR */
-	/*	Type: */
-	/*	Length: */
-	/*	Value: */
-	/*	Device Capability Bitmap, 1 byte */
-	/*	Be able to participate in additional P2P Groups and */
-	/*	support the P2P Invitation Procedure */
-	/*	Group Capability Bitmap, 1 byte */
-	capability = P2P_DEVCAP_INVITATION_PROC|P2P_DEVCAP_CLIENT_DISCOVERABILITY;
-	capability |=  ((P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS) << 8);
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
-		capability |= (P2P_GRPCAP_GROUP_FORMATION<<8);
-
-	le_tmp = cpu_to_le16(capability);
-
-	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_CAPABILITY, 2, (u8 *)&le_tmp);
-
-	/*  P2P Device ID ATTR */
-	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_DEVICE_ID, ETH_ALEN, pwdinfo->device_addr);
-
-	/*  Notice of Absence ATTR */
-	/*	Type: */
-	/*	Length: */
-	/*	Value: */
-
-	/* go_add_noa_attr(pwdinfo); */
-
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *)p2pie, &len);
-
-	return len;
-}
-
-u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
-	u32 len = 0, p2pielen = 0;
-
-	/*	P2P OUI */
-	p2pielen = 0;
-	p2pie[p2pielen++] = 0x50;
-	p2pie[p2pielen++] = 0x6F;
-	p2pie[p2pielen++] = 0x9A;
-	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
-
-	/*	Commented by Albert 20100907 */
-	/*	According to the P2P Specification, the probe response frame should contain 5 P2P attributes */
-	/*	1. P2P Capability */
-	/*	2. Extended Listen Timing */
-	/*	3. Notice of Absence (NOA)	(Only GO needs this) */
-	/*	4. Device Info */
-	/*	5. Group Info	(Only GO need this) */
-
-	/*	P2P Capability ATTR */
-	/*	Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
-
-	/*	Length: */
-	RTW_PUT_LE16(p2pie + p2pielen, 0x0002);
-	p2pielen += 2;
-
-	/*	Value: */
-	/*	Device Capability Bitmap, 1 byte */
-	p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
-
-	/*	Group Capability Bitmap, 1 byte */
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-		p2pie[p2pielen] = (P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS);
-
-		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
-			p2pie[p2pielen] |= P2P_GRPCAP_GROUP_FORMATION;
-		p2pielen++;
-	} else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE)) {
-		/*	Group Capability Bitmap, 1 byte */
-		if (pwdinfo->persistent_supported)
-			p2pie[p2pielen++] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
-		else
-			p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
-	}
-
-	/*	Extended Listen Timing ATTR */
-	/*	Type: */
-	p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
-
-	/*	Length: */
-	RTW_PUT_LE16(p2pie + p2pielen, 0x0004);
-	p2pielen += 2;
-
-	/*	Value: */
-	/*	Availability Period */
-	RTW_PUT_LE16(p2pie + p2pielen, 0xFFFF);
-	p2pielen += 2;
-
-	/*	Availability Interval */
-	RTW_PUT_LE16(p2pie + p2pielen, 0xFFFF);
-	p2pielen += 2;
-
-	/*  Notice of Absence ATTR */
-	/*	Type: */
-	/*	Length: */
-	/*	Value: */
-
-	/*	Device Info ATTR */
-	/*	Type: */
-	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
-	/*	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
-	RTW_PUT_LE16(p2pie + p2pielen, 21 + pwdinfo->device_name_len);
-	p2pielen += 2;
-
-	/*	Value: */
-	/*	P2P Device Address */
-	memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);
-	p2pielen += ETH_ALEN;
-
-	/*	Config Method */
-	/*	This field should be big endian. Noted by P2P specification. */
-	RTW_PUT_BE16(p2pie + p2pielen, pwdinfo->supported_wps_cm);
-	p2pielen += 2;
-
-	/*	Primary Device Type */
-	/*	Category ID */
-	RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_CID_MULIT_MEDIA);
-	p2pielen += 2;
-
-	/*	OUI */
-	RTW_PUT_BE32(p2pie + p2pielen, WPSOUI);
-	p2pielen += 4;
-
-	/*	Sub Category ID */
-	RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_SCID_MEDIA_SERVER);
-	p2pielen += 2;
-
-	p2pie[p2pielen++] = 0x00;	/*	No Secondary Device Type List */
-
-	/*	Device Name */
-	/*	Type: */
-	RTW_PUT_BE16(p2pie + p2pielen, WPS_ATTR_DEVICE_NAME);
-	p2pielen += 2;
-
-	/*	Length: */
-	RTW_PUT_BE16(p2pie + p2pielen, pwdinfo->device_name_len);
-	p2pielen += 2;
-
-	/*	Value: */
-	memcpy(p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len);
-	p2pielen += pwdinfo->device_name_len;
-
-	/*  Group Info ATTR */
-	/*	Type: */
-	/*	Length: */
-	/*	Value: */
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
-		p2pielen += go_add_group_info_attr(pwdinfo, p2pie + p2pielen);
-
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *)p2pie, &len);
-
-	return len;
-}
-
-u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 *pssid, u8 ussidlen, u8 *pdev_raddr)
-{
-	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
-	u32 len = 0, p2pielen = 0;
-
-	/*	P2P OUI */
-	p2pielen = 0;
-	p2pie[p2pielen++] = 0x50;
-	p2pie[p2pielen++] = 0x6F;
-	p2pie[p2pielen++] = 0x9A;
-	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
-
-	/*	Commented by Albert 20110301 */
-	/*	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes */
-	/*	1. P2P Capability */
-	/*	2. Device Info */
-	/*	3. Group ID (When joining an operating P2P Group) */
-
-	/*	P2P Capability ATTR */
-	/*	Type: */
-	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
-
-	/*	Length: */
-	RTW_PUT_LE16(p2pie + p2pielen, 0x0002);
-	p2pielen += 2;
-
-	/*	Value: */
-	/*	Device Capability Bitmap, 1 byte */
-	p2pie[p2pielen++] = DMP_P2P_DEVCAP_SUPPORT;
-
-	/*	Group Capability Bitmap, 1 byte */
-	if (pwdinfo->persistent_supported)
-		p2pie[p2pielen++] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
-	else
-		p2pie[p2pielen++] = DMP_P2P_GRPCAP_SUPPORT;
-
-	/*	Device Info ATTR */
-	/*	Type: */
-	p2pie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
-	/*	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
-	RTW_PUT_LE16(p2pie + p2pielen, 21 + pwdinfo->device_name_len);
-	p2pielen += 2;
-
-	/*	Value: */
-	/*	P2P Device Address */
-	memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);
-	p2pielen += ETH_ALEN;
-
-	/*	Config Method */
-	/*	This field should be big endian. Noted by P2P specification. */
-	if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PBC)
-		RTW_PUT_BE16(p2pie + p2pielen, WPS_CONFIG_METHOD_PBC);
-	else
-		RTW_PUT_BE16(p2pie + p2pielen, WPS_CONFIG_METHOD_DISPLAY);
-
-	p2pielen += 2;
-
-	/*	Primary Device Type */
-	/*	Category ID */
-	RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_CID_MULIT_MEDIA);
-	p2pielen += 2;
-
-	/*	OUI */
-	RTW_PUT_BE32(p2pie + p2pielen, WPSOUI);
-	p2pielen += 4;
-
-	/*	Sub Category ID */
-	RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_SCID_MEDIA_SERVER);
-	p2pielen += 2;
-
-	/*	Number of Secondary Device Types */
-	p2pie[p2pielen++] = 0x00;	/*	No Secondary Device Type List */
-
-	/*	Device Name */
-	/*	Type: */
-	RTW_PUT_BE16(p2pie + p2pielen, WPS_ATTR_DEVICE_NAME);
-	p2pielen += 2;
-
-	/*	Length: */
-	RTW_PUT_BE16(p2pie + p2pielen, pwdinfo->device_name_len);
-	p2pielen += 2;
-
-	/*	Value: */
-	memcpy(p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len);
-	p2pielen += pwdinfo->device_name_len;
-
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)) {
-		/*	Added by Albert 2011/05/19 */
-		/*	In this case, the pdev_raddr is the device address of the group owner. */
-
-		/*	P2P Group ID ATTR */
-		/*	Type: */
-		p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
-
-		/*	Length: */
-		RTW_PUT_LE16(p2pie + p2pielen, ETH_ALEN + ussidlen);
-		p2pielen += 2;
-
-		/*	Value: */
-		memcpy(p2pie + p2pielen, pdev_raddr, ETH_ALEN);
-		p2pielen += ETH_ALEN;
-
-		memcpy(p2pie + p2pielen, pssid, ussidlen);
-		p2pielen += ussidlen;
-	}
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *)p2pie, &len);
-	return len;
-}
-
-u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 status_code)
-{
-	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
-	u32 len = 0, p2pielen = 0;
-
-	/*	P2P OUI */
-	p2pielen = 0;
-	p2pie[p2pielen++] = 0x50;
-	p2pie[p2pielen++] = 0x6F;
-	p2pie[p2pielen++] = 0x9A;
-	p2pie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
-
-	/*  According to the P2P Specification, the Association response frame should contain 2 P2P attributes */
-	/*	1. Status */
-	/*	2. Extended Listen Timing (optional) */
-
-	/*	Status ATTR */
-	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status_code);
-
-	/*  Extended Listen Timing ATTR */
-	/*	Type: */
-	/*	Length: */
-	/*	Value: */
-
-	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *)p2pie, &len);
-	return len;
-}
-
-u32 build_deauth_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
-{
-	u32 len = 0;
-
-	return len;
-}
-
-u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
-{
-	u8 *p;
-	u32 ret = false;
-	u8 *p2pie;
-	u32	p2pielen = 0;
-	int ssid_len = 0, rate_cnt = 0;
-
-	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, _SUPPORTEDRATES_IE_, (int *)&rate_cnt,
-			len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
-
-	if (rate_cnt <= 4) {
-		int i, g_rate = 0;
-
-		for (i = 0; i < rate_cnt; i++) {
-			if (((*(p + 2 + i) & 0xff) != 0x02) &&
-			    ((*(p + 2 + i) & 0xff) != 0x04) &&
-			    ((*(p + 2 + i) & 0xff) != 0x0B) &&
-			    ((*(p + 2 + i) & 0xff) != 0x16))
-				g_rate = 1;
-		}
-
-		if (g_rate == 0) {
-			/*	There is no OFDM rate included in SupportedRates IE of this probe request frame */
-			/*	The driver should response this probe request. */
-			return ret;
-		}
-	} else {
-		/*	rate_cnt > 4 means the SupportRates IE contains the OFDM rate because the count of CCK rates are 4. */
-		/*	We should proceed the following check for this probe request. */
-	}
-
-	/*	Added comments by Albert 20100906 */
-	/*	There are several items we should check here. */
-	/*	1. This probe request frame must contain the P2P IE. (Done) */
-	/*	2. This probe request frame must contain the wildcard SSID. (Done) */
-	/*	3. Wildcard BSSID. (Todo) */
-	/*	4. Destination Address. (Done in mgt_dispatcher function) */
-	/*	5. Requested Device Type in WSC IE. (Todo) */
-	/*	6. Device ID attribute in P2P IE. (Todo) */
-
-	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, _SSID_IE_, (int *)&ssid_len,
-			len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
-
-	ssid_len &= 0xff;	/*	Just last 1 byte is valid for ssid len of the probe request */
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-		p2pie = rtw_get_p2p_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_, NULL, &p2pielen);
-		if (p2pie) {
-			if ((p != NULL) && !memcmp((void *)(p+2), (void *)pwdinfo->p2p_wildcard_ssid, 7)) {
-				/* todo: */
-				/* Check Requested Device Type attributes in WSC IE. */
-				/* Check Device ID attribute in P2P IE */
-
-				ret = true;
-			} else if ((p != NULL) && (ssid_len == 0)) {
-				ret = true;
-			}
-		} else {
-			/* non -p2p device */
-		}
-	}
-	return ret;
-}
-
-u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len, struct sta_info *psta)
-{
-	u8 status_code = P2P_STATUS_SUCCESS;
-	u8 *pbuf, *pattr_content = NULL;
-	u32 attr_contentlen = 0;
-	u16 cap_attr = 0;
-	unsigned short	frame_type, ie_offset = 0;
-	u8 *ies;
-	u32 ies_len;
-	u8 *p2p_ie;
-	u32	p2p_ielen = 0;
-	__be16 be_tmp;
-	__le16 le_tmp;
-
-	if (!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
-		return P2P_STATUS_FAIL_REQUEST_UNABLE;
-
-	frame_type = GetFrameSubType(pframe);
-	if (frame_type == WIFI_ASSOCREQ)
-		ie_offset = _ASOCREQ_IE_OFFSET_;
-	else /*  WIFI_REASSOCREQ */
-		ie_offset = _REASOCREQ_IE_OFFSET_;
-
-	ies = pframe + WLAN_HDR_A3_LEN + ie_offset;
-	ies_len = len - WLAN_HDR_A3_LEN - ie_offset;
-
-	p2p_ie = rtw_get_p2p_ie(ies, ies_len, NULL, &p2p_ielen);
-
-	if (!p2p_ie) {
-		DBG_8192D("[%s] P2P IE not Found!!\n", __func__);
-		status_code =  P2P_STATUS_FAIL_INVALID_PARAM;
-	} else {
-		DBG_8192D("[%s] P2P IE Found!!\n", __func__);
-	}
-
-	while (p2p_ie) {
-		/* Check P2P Capability ATTR */
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&le_tmp, (uint *)&attr_contentlen)) {
-			DBG_8192D("[%s] Got P2P Capability Attr!!\n", __func__);
-			cap_attr = le16_to_cpu(le_tmp);
-			psta->dev_cap = cap_attr&0xff;
-		}
-
-		/* Check Extended Listen Timing ATTR */
-
-		/* Check P2P Device Info ATTR */
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, NULL, (uint *)&attr_contentlen)) {
-			DBG_8192D("[%s] Got P2P DEVICE INFO Attr!!\n", __func__);
-			pattr_content = kzalloc(attr_contentlen, GFP_KERNEL);
-			pbuf = pattr_content;
-			if (pattr_content) {
-				u8 num_of_secdev_type;
-				u16 dev_name_len;
-
-				rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, pattr_content, (uint *)&attr_contentlen);
-
-				memcpy(psta->dev_addr,	pattr_content, ETH_ALEN);/* P2P Device Address */
-
-				pattr_content += ETH_ALEN;
-
-				memcpy(&be_tmp, pattr_content, 2);/* Config Methods */
-				psta->config_methods = be16_to_cpu(be_tmp);
-
-				pattr_content += 2;
-
-				memcpy(psta->primary_dev_type, pattr_content, 8);
-
-				pattr_content += 8;
-
-				num_of_secdev_type = *pattr_content;
-				pattr_content += 1;
-
-				if (num_of_secdev_type == 0) {
-					psta->num_of_secdev_type = 0;
-				} else {
-					u32 len;
-
-					psta->num_of_secdev_type = num_of_secdev_type;
-
-					len = (sizeof(psta->secdev_types_list) < (num_of_secdev_type*8)) ?
-					      (sizeof(psta->secdev_types_list)) : (num_of_secdev_type*8);
-					memcpy(psta->secdev_types_list, pattr_content, len);
-					pattr_content += (num_of_secdev_type*8);
-				}
-				psta->dev_name_len = 0;
-				if (WPS_ATTR_DEVICE_NAME == be16_to_cpu(*(__be16 *)pattr_content)) {
-					dev_name_len = be16_to_cpu(*(__be16 *)(pattr_content+2));
-					psta->dev_name_len = (sizeof(psta->dev_name) < dev_name_len) ? sizeof(psta->dev_name) : dev_name_len;
-					memcpy(psta->dev_name, pattr_content+4, psta->dev_name_len);
-				}
-				kfree(pbuf);
-			}
-		}
-		/* Get the next P2P IE */
-		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len - (p2p_ie - ies + p2p_ielen), NULL, &p2p_ielen);
-	}
-	return status_code;
-}
-
-u32 process_p2p_devdisc_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
-{
-	u8 *frame_body;
-	u8 status, dialogToken;
-	struct sta_info *psta = NULL;
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	struct sta_priv *pstapriv = &padapter->stapriv;
-	u8 *p2p_ie;
-	u32	p2p_ielen = 0;
-
-	frame_body = (unsigned char *)(pframe + sizeof(struct ieee80211_hdr_3addr));
-
-	dialogToken = frame_body[7];
-	status = P2P_STATUS_FAIL_UNKNOWN_P2PGROUP;
-
-	p2p_ie = rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen);
-	if (p2p_ie) {
-		u8 groupid[38] = { 0x00 };
-		u8 dev_addr[ETH_ALEN] = { 0x00 };
-		u32	attr_contentlen = 0;
-
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen)) {
-			if (!memcmp(pwdinfo->device_addr, groupid, ETH_ALEN) &&
-			    !memcmp(pwdinfo->p2p_group_ssid, groupid+ETH_ALEN, pwdinfo->p2p_group_ssid_len)) {
-				attr_contentlen = 0;
-				if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_ID, dev_addr, &attr_contentlen)) {
-					struct list_head *phead, *plist;
-
-					spin_lock_bh(&pstapriv->asoc_list_lock);
-					phead = &pstapriv->asoc_list;
-					plist = phead->next;
-
-					/* look up sta asoc_queue */
-					while ((rtw_end_of_queue_search(phead, plist)) == false) {
-						psta = container_of(plist, struct sta_info, asoc_list);
-
-						plist = plist->next;
-
-						if (psta->is_p2p_device && (psta->dev_cap&P2P_DEVCAP_CLIENT_DISCOVERABILITY) &&
-						    !memcmp(psta->dev_addr, dev_addr, ETH_ALEN)) {
-							issue_group_disc_req(pwdinfo, psta->hwaddr);
-							status = P2P_STATUS_SUCCESS;
-							break;
-						} else {
-							status = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
-						}
-					}
-					spin_unlock_bh(&pstapriv->asoc_list_lock);
-				} else {
-					status = P2P_STATUS_FAIL_INVALID_PARAM;
-				}
-
-			} else {
-				status = P2P_STATUS_FAIL_INVALID_PARAM;
-			}
-		}
-	}
-	/* issue Device Discoverability Response */
-	issue_p2p_devdisc_resp(pwdinfo, GetAddr2Ptr(pframe), status, dialogToken);
-	return (status == P2P_STATUS_SUCCESS) ? true : false;
-}
-
-u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,  u8 *pframe, uint len)
-{
-	u8 *frame_body;
-	u8 *wpsie;
-	uint	wps_ielen = 0, attr_contentlen = 0;
-	u16	uconfig_method = 0;
-	__be16 be_tmp;
-
-	frame_body = (pframe + sizeof(struct ieee80211_hdr_3addr));
-
-	wpsie = rtw_get_wps_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &wps_ielen);
-	if (wpsie) {
-		if (rtw_get_wps_attr_content(wpsie, wps_ielen, WPS_ATTR_CONF_METHOD, (u8 *)&be_tmp, &attr_contentlen)) {
-			uconfig_method = be16_to_cpu(be_tmp);
-			switch (uconfig_method) {
-			case WPS_CM_DISPLYA:
-				memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis", 3);
-				break;
-			case WPS_CM_LABEL:
-				memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "lab", 3);
-				break;
-			case WPS_CM_PUSH_BUTTON:
-				memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3);
-				break;
-			case WPS_CM_KEYPAD:
-				memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3);
-				break;
-			}
-			issue_p2p_provision_resp(pwdinfo, GetAddr2Ptr(pframe), frame_body, uconfig_method);
-		}
-	}
-	DBG_8192D("[%s] config method = %s\n", __func__, pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req);
-	return true;
-}
-
-static u8 rtw_p2p_get_peer_ch_list(struct wifidirect_info *pwdinfo, u8 *ch_content, u8 ch_cnt, u8 *peer_ch_list)
-{
-	u8 i = 0, j = 0;
-	u8 temp = 0;
-	u8 ch_no = 0;
-	ch_content += 3;
-	ch_cnt -= 3;
-
-	while (ch_cnt > 0) {
-		ch_content += 1;
-		ch_cnt -= 1;
-		temp = *ch_content;
-		for (i = 0; i < temp; i++, j++)
-			peer_ch_list[j] = *(ch_content + 1 + i);
-		ch_content += (temp + 1);
-		ch_cnt -= (temp + 1);
-		ch_no += temp;
-	}
-
-	return ch_no;
-}
-
-static u8 rtw_p2p_ch_inclusion(struct mlme_ext_priv *pmlmeext, u8 *peer_ch_list, u8 peer_ch_num, u8 *ch_list_inclusioned)
-{
-	int	i = 0, j = 0, temp = 0;
-	u8 ch_no = 0;
-
-	for (i = 0; i < peer_ch_num; i++) {
-		for (j = temp; j < pmlmeext->max_chan_nums; j++) {
-			if (*(peer_ch_list + i) == pmlmeext->channel_set[j].ChannelNum) {
-				ch_list_inclusioned[ch_no++] = *(peer_ch_list + i);
-				temp = j;
-				break;
-			}
-		}
-	}
-
-	return ch_no;
-}
-
-u8 process_p2p_group_negotation_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
-{
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	u8 result = P2P_STATUS_SUCCESS;
-	u32	p2p_ielen = 0, wps_ielen = 0;
-	u8 *ies;
-	u32 ies_len;
-	u8 *p2p_ie;
-	u8 *wpsie;
-	u16		wps_devicepassword_id = 0x0000;
-	uint	wps_devicepassword_id_len = 0;
-	__be16 be_tmp;
-#ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter				*pbuddy_adapter = pwdinfo->padapter->pbuddy_adapter;
-	struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
-	struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
-	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif
-
-	wpsie = rtw_get_wps_ie(pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &wps_ielen);
-	if (wpsie) {
-		/*	Commented by Kurt 20120113 */
-		/*	If some device wants to do p2p handshake without sending prov_disc_req */
-		/*	We have to get peer_req_cm from here. */
-		if (!memcmp(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3)) {
-			rtw_get_wps_attr_content(wpsie, wps_ielen, WPS_ATTR_DEVICE_PWID, (u8 *)&be_tmp, &wps_devicepassword_id_len);
-			wps_devicepassword_id = be16_to_cpu(be_tmp);
-
-			if (wps_devicepassword_id == WPS_DPID_USER_SPEC)
-				memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis", 3);
-			else if (wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC)
-				memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3);
-			else
-				memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3);
-		}
-	} else {
-		DBG_8192D("[%s] WPS IE not Found!!\n", __func__);
-		result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
-		return result;
-	}
-
-	if (pwdinfo->ui_got_wps_info == P2P_NO_WPSINFO) {
-		result = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_INFOR_NOREADY);
-		return result;
-	}
-
-	ies = pframe + _PUBLIC_ACTION_IE_OFFSET_;
-	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
-
-	p2p_ie = rtw_get_p2p_ie(ies, ies_len, NULL, &p2p_ielen);
-
-	if (!p2p_ie) {
-		DBG_8192D("[%s] P2P IE not Found!!\n", __func__);
-		result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
-	}
-
-	while (p2p_ie) {
-		u8 attr_content = 0x00;
-		u32	attr_contentlen = 0;
-		u8 ch_content[50] = { 0x00 };
-		uint	ch_cnt = 0;
-		u8 peer_ch_list[50] = { 0x00 };
-		u8 peer_ch_num = 0;
-		u8 ch_list_inclusioned[50] = { 0x00 };
-		u8 ch_num_inclusioned = 0;
-		u16	cap_attr;
-		__le16 le_tmp;
-
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);
-
-		/* Check P2P Capability ATTR */
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&le_tmp, (uint *)&attr_contentlen))
-			cap_attr = le16_to_cpu(le_tmp);
-
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT, &attr_content, &attr_contentlen)) {
-			DBG_8192D("[%s] GO Intent = %d, tie = %d\n", __func__, attr_content >> 1, attr_content & 0x01);
-			pwdinfo->peer_intent = attr_content;	/*	include both intent and tie breaker values. */
-
-			if (pwdinfo->intent == (pwdinfo->peer_intent >> 1)) {
-				/*	Try to match the tie breaker value */
-				if (pwdinfo->intent == P2P_MAX_INTENT) {
-					rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
-					result = P2P_STATUS_FAIL_BOTH_GOINTENT_15;
-				} else {
-					if (attr_content & 0x01)
-						rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
-					else
-						rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
-				}
-			} else if (pwdinfo->intent > (pwdinfo->peer_intent >> 1)) {
-				rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
-			} else {
-				rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
-			}
-
-			if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-				/*	Store the group id information. */
-				memcpy(pwdinfo->groupid_info.go_device_addr, pwdinfo->device_addr, ETH_ALEN);
-				memcpy(pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen);
-			}
-		}
-
-		attr_contentlen = 0;
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INTENTED_IF_ADDR, pwdinfo->p2p_peer_interface_addr, &attr_contentlen)) {
-			if (attr_contentlen != ETH_ALEN)
-				memset(pwdinfo->p2p_peer_interface_addr, 0x00, ETH_ALEN);
-		}
-
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, ch_content, &ch_cnt)) {
-			peer_ch_num = rtw_p2p_get_peer_ch_list(pwdinfo, ch_content, ch_cnt, peer_ch_list);
-			ch_num_inclusioned = rtw_p2p_ch_inclusion(&padapter->mlmeextpriv, peer_ch_list, peer_ch_num, ch_list_inclusioned);
-
-			if (ch_num_inclusioned == 0) {
-				DBG_8192D("[%s] No common channel in channel list!\n", __func__);
-				result = P2P_STATUS_FAIL_NO_COMMON_CH;
-				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
-				break;
-			}
-
-			if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-				if (!rtw_p2p_is_channel_list_ok(pwdinfo->operating_channel, ch_list_inclusioned, ch_num_inclusioned)) {
-#ifdef CONFIG_CONCURRENT_MODE
-					if (check_buddy_fwstate(padapter, _FW_LINKED)) {
-						DBG_8192D("[%s] desired channel NOT Found!\n", __func__);
-						result = P2P_STATUS_FAIL_NO_COMMON_CH;
-						rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
-						break;
-					} else
-#endif /* CONFIG_CONCURRENT_MODE */
-					{
-						u8 operatingch_info[5] = { 0x00 }, peer_operating_ch = 0;
-						attr_contentlen = 0;
-
-						if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen))
-							peer_operating_ch = operatingch_info[4];
-
-						if (rtw_p2p_is_channel_list_ok(peer_operating_ch, ch_list_inclusioned, ch_num_inclusioned)) {
-							/**
-							 *	Change our operating channel as peer's for compatibility.
-							 */
-							pwdinfo->operating_channel = peer_operating_ch;
-							DBG_8192D("[%s] Change op ch to %02x as peer's\n", __func__, pwdinfo->operating_channel);
-						} else {
-							/*  Take first channel of ch_list_inclusioned as operating channel */
-							pwdinfo->operating_channel = ch_list_inclusioned[0];
-							DBG_8192D("[%s] Change op ch to %02x\n", __func__, pwdinfo->operating_channel);
-						}
-					}
-				}
-			}
-		}
-
-		/* Get the next P2P IE */
-		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len - (p2p_ie - ies + p2p_ielen), NULL, &p2p_ielen);
-	}
-	return result;
-}
-
-u8 process_p2p_group_negotation_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
-{
-	struct rtw_adapter *padapter = pwdinfo->padapter;
-	u8 result = P2P_STATUS_SUCCESS;
-	u32	p2p_ielen, wps_ielen;
-	u8 *ies;
-	u32 ies_len;
-	u8 *p2p_ie;
-
-	ies = pframe + _PUBLIC_ACTION_IE_OFFSET_;
-	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
-
-	/*	Be able to know which one is the P2P GO and which one is P2P client. */
-
-	if (rtw_get_wps_ie(ies, ies_len, NULL, &wps_ielen)) {
-		;
-	} else {
-		DBG_8192D("[%s] WPS IE not Found!!\n", __func__);
-		result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
-	}
-
-	p2p_ie = rtw_get_p2p_ie(ies, ies_len, NULL, &p2p_ielen);
-	if (!p2p_ie) {
-		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
-		result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
-	} else {
-		u8 attr_content = 0x00;
-		u32	attr_contentlen = 0;
-		u8 operatingch_info[5] = { 0x00 };
-		u8 groupid[38];
-		u16	cap_attr;
-		u8 peer_ch_list[50] = { 0x00 };
-		u8 peer_ch_num = 0;
-		u8 ch_list_inclusioned[50] = { 0x00 };
-		u8 ch_num_inclusioned = 0;
-		__le16 le_tmp;
-
-		while (p2p_ie) {
-			/* Check P2P Capability ATTR */
-			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&le_tmp, (uint *)&attr_contentlen))
-				cap_attr = le16_to_cpu(le_tmp);
-
-			rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, &attr_content, &attr_contentlen);
-			if (attr_contentlen == 1) {
-				DBG_8192D("[%s] Status = %d\n", __func__, attr_content);
-				if (attr_content == P2P_STATUS_SUCCESS) {
-					; /*	Do nothing. */
-				} else {
-					if (P2P_STATUS_FAIL_INFO_UNAVAILABLE == attr_content)
-						rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_INFOR_NOREADY);
-					else
-						rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
-					rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
-					result = attr_content;
-					break;
-				}
-			}
-
-			/*	Try to get the peer's interface address */
-			attr_contentlen = 0;
-			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INTENTED_IF_ADDR, pwdinfo->p2p_peer_interface_addr, &attr_contentlen)) {
-				if (attr_contentlen != ETH_ALEN)
-					memset(pwdinfo->p2p_peer_interface_addr, 0x00, ETH_ALEN);
-			}
-
-			/*	Try to get the peer's intent and tie breaker value. */
-			attr_content = 0x00;
-			attr_contentlen = 0;
-			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT, &attr_content, &attr_contentlen)) {
-				DBG_8192D("[%s] GO Intent = %d, tie = %d\n", __func__, attr_content >> 1, attr_content & 0x01);
-				pwdinfo->peer_intent = attr_content;	/*	include both intent and tie breaker values. */
-
-				if (pwdinfo->intent == (pwdinfo->peer_intent >> 1)) {
-					/*	Try to match the tie breaker value */
-					if (pwdinfo->intent == P2P_MAX_INTENT) {
-						rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
-						result = P2P_STATUS_FAIL_BOTH_GOINTENT_15;
-						rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
-					} else {
-						rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
-						rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
-						if (attr_content & 0x01)
-							rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
-						else
-							rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
-					}
-				} else if (pwdinfo->intent > (pwdinfo->peer_intent >> 1)) {
-					rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
-					rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
-					rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
-				} else {
-					rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
-					rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
-					rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
-				}
-
-				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-					/*	Store the group id information. */
-					memcpy(pwdinfo->groupid_info.go_device_addr, pwdinfo->device_addr, ETH_ALEN);
-					memcpy(pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen);
-				}
-			}
-
-			/*	Try to get the operation channel information */
-
-			attr_contentlen = 0;
-			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen)) {
-				DBG_8192D("[%s] Peer's operating channel = %d\n", __func__, operatingch_info[4]);
-				pwdinfo->peer_operating_ch = operatingch_info[4];
-			}
-
-			/*	Try to get the channel list information */
-			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, pwdinfo->channel_list_attr, &pwdinfo->channel_list_attr_len)) {
-				DBG_8192D("[%s] channel list attribute found, len = %d\n", __func__,  pwdinfo->channel_list_attr_len);
-
-				peer_ch_num = rtw_p2p_get_peer_ch_list(pwdinfo, pwdinfo->channel_list_attr, pwdinfo->channel_list_attr_len, peer_ch_list);
-				ch_num_inclusioned = rtw_p2p_ch_inclusion(&padapter->mlmeextpriv, peer_ch_list, peer_ch_num, ch_list_inclusioned);
-
-				if (ch_num_inclusioned == 0) {
-					DBG_8192D("[%s] No common channel in channel list!\n", __func__);
-					result = P2P_STATUS_FAIL_NO_COMMON_CH;
-					rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
-					break;
-				}
-
-					if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-					if (!rtw_p2p_is_channel_list_ok(pwdinfo->operating_channel, ch_list_inclusioned, ch_num_inclusioned)) {
-#ifdef CONFIG_CONCURRENT_MODE
-						if (check_buddy_fwstate(padapter, _FW_LINKED)) {
-							DBG_8192D("[%s] desired channel NOT Found!\n", __func__);
-							result = P2P_STATUS_FAIL_NO_COMMON_CH;
-							rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
-							break;
-						} else
-#endif /* CONFIG_CONCURRENT_MODE */
-						{
-							u8 operatingch_info[5] = { 0x00 }, peer_operating_ch = 0;
-							attr_contentlen = 0;
-
-							if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH,
-										     operatingch_info, &attr_contentlen))
-								peer_operating_ch = operatingch_info[4];
-
-							if (rtw_p2p_is_channel_list_ok(peer_operating_ch, ch_list_inclusioned, ch_num_inclusioned)) {
-								/**
-								 *	Change our operating channel as peer's for compatibility.
-								 */
-								pwdinfo->operating_channel = peer_operating_ch;
-								DBG_8192D("[%s] Change op ch to %02x as peer's\n", __func__, pwdinfo->operating_channel);
-							} else {
-								/*  Take first channel of ch_list_inclusioned as operating channel */
-								pwdinfo->operating_channel = ch_list_inclusioned[0];
-								DBG_8192D("[%s] Change op ch to %02x\n", __func__, pwdinfo->operating_channel);
-							}
-						}
-					}
-				}
-
-			} else {
-				DBG_8192D("[%s] channel list attribute not found!\n", __func__);
-			}
-
-			/*	Try to get the group id information if peer is GO */
-			attr_contentlen = 0;
-			memset(groupid, 0x00, 38);
-			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen)) {
-				memcpy(pwdinfo->groupid_info.go_device_addr, &groupid[0], ETH_ALEN);
-				memcpy(pwdinfo->groupid_info.ssid, &groupid[6], attr_contentlen - ETH_ALEN);
-			}
-
-			/* Get the next P2P IE */
-			p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len - (p2p_ie - ies + p2p_ielen), NULL, &p2p_ielen);
-		}
-	}
-	return result;
-}
-
-u8 process_p2p_group_negotation_confirm(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
-{
-	u8 *ies;
-	u32 ies_len;
-	u8 *p2p_ie;
-	u32	p2p_ielen = 0;
-	u8 result = P2P_STATUS_SUCCESS;
-	ies = pframe + _PUBLIC_ACTION_IE_OFFSET_;
-	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
-
-	p2p_ie = rtw_get_p2p_ie(ies, ies_len, NULL, &p2p_ielen);
-	while (p2p_ie) {
-		u8 attr_content = 0x00, operatingch_info[5] = { 0x00 };
-		u8 groupid[38] = { 0x00 };
-		u32	attr_contentlen = 0;
-
-		pwdinfo->negotiation_dialog_token = 1;
-		rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, &attr_content, &attr_contentlen);
-		if (attr_contentlen == 1) {
-			DBG_8192D("[%s] Status = %d\n", __func__, attr_content);
-			result = attr_content;
-
-			if (attr_content == P2P_STATUS_SUCCESS) {
-				u8 bcancelled = 0;
-
-				_cancel_timer(&pwdinfo->restore_p2p_state_timer, &bcancelled);
-
-				/*	Commented by Albert 20100911 */
-				/*	Todo: Need to handle the case which both Intents are the same. */
-				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
-				rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
-				if ((pwdinfo->intent) > (pwdinfo->peer_intent >> 1)) {
-					rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
-				} else if ((pwdinfo->intent) < (pwdinfo->peer_intent >> 1)) {
-					rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
-				} else {
-					/*	Have to compare the Tie Breaker */
-					if (pwdinfo->peer_intent & 0x01)
-						rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
-					else
-						rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
-				}
-
-#ifdef CONFIG_CONCURRENT_MODE
-				if (check_buddy_fwstate(pwdinfo->padapter, _FW_LINKED)) {
-					/*	Switch back to the AP channel soon. */
-					_set_timer(&pwdinfo->ap_p2p_switch_timer, 100);
-				}
-#endif
-			} else {
-				rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
-				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
-				break;
-			}
-		}
-
-		/*	Try to get the group id information */
-		attr_contentlen = 0;
-		memset(groupid, 0x00, 38);
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen)) {
-			DBG_8192D("[%s] Ssid = %s, ssidlen = %d\n", __func__, &groupid[ETH_ALEN], (u32)strlen(&groupid[ETH_ALEN]));
-			memcpy(pwdinfo->groupid_info.go_device_addr, &groupid[0], ETH_ALEN);
-			memcpy(pwdinfo->groupid_info.ssid, &groupid[6], attr_contentlen - ETH_ALEN);
-		}
-
-		attr_contentlen = 0;
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen)) {
-			DBG_8192D("[%s] Peer's operating channel = %d\n", __func__, operatingch_info[4]);
-			pwdinfo->peer_operating_ch = operatingch_info[4];
-		}
-
-		/* Get the next P2P IE */
-		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len - (p2p_ie - ies + p2p_ielen), NULL, &p2p_ielen);
-	}
-	return result;
-}
-
-u8 process_p2p_presence_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
-{
-	u8 *frame_body;
-	u8 dialogToken = 0;
-	u8 status = P2P_STATUS_SUCCESS;
-
-	frame_body = (unsigned char *)(pframe + sizeof(struct ieee80211_hdr_3addr));
-
-	dialogToken = frame_body[6];
-
-	/* todo: check NoA attribute */
-
-	issue_p2p_presence_resp(pwdinfo, GetAddr2Ptr(pframe), status, dialogToken);
-
-	return true;
-}
-
-static void find_phase_handler(struct rtw_adapter *padapter)
-{
-	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
-	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-	struct ndis_802_11_ssid	ssid;
-
-	memset((unsigned char *)&ssid, 0, sizeof(struct ndis_802_11_ssid));
-	memcpy(ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN);
-	ssid.SsidLength = P2P_WILDCARD_SSID_LEN;
-
-	rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
-
-	spin_lock_bh(&pmlmepriv->lock);
-	rtw_sitesurvey_cmd(padapter, &ssid, 1, NULL, 0);
-	spin_unlock_bh(&pmlmepriv->lock);
-
-}
-
-void p2p_concurrent_handler(struct rtw_adapter *padapter);
-
-static void restore_p2p_state_handler(struct rtw_adapter *padapter)
-{
-	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) ||
-	    rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
-		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(padapter, _FW_LINKED)) {
-		struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
-		struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
-		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
-		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_RSP)) {
-			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-
-			issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
-		}
-	}
-#endif
-
-	rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
-
-	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE)) {
-#ifdef CONFIG_CONCURRENT_MODE
-		p2p_concurrent_handler(padapter);
-#else
-		/*	In the P2P client mode, the driver should not switch back to its listen channel */
-		/*	because this P2P client should stay at the operating channel of P2P GO. */
-		set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-#endif
-	}
-
-}
-
-static void pre_tx_invitereq_handler(struct rtw_adapter *padapter)
-{
-	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
-	u8 val8 = 1;
-
-	set_channel_bwmode(padapter, pwdinfo->invitereq_info.peer_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
-	issue_probereq_p2p(padapter, NULL);
-	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
-
-}
-
-static void pre_tx_provdisc_handler(struct rtw_adapter *padapter)
-{
-	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
-	u8 val8 = 1;
-
-	set_channel_bwmode(padapter, pwdinfo->tx_prov_disc_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
-	issue_probereq_p2p(padapter, NULL);
-	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
-
-}
-
-static void pre_tx_negoreq_handler(struct rtw_adapter *padapter)
-{
-	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
-	u8 val8 = 1;
-
-	set_channel_bwmode(padapter, pwdinfo->nego_req_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
-	issue_probereq_p2p(padapter, NULL);
-	_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
-
-}
-
-#ifdef CONFIG_CONCURRENT_MODE
-void p2p_concurrent_handler(struct rtw_adapter *padapter)
-{
-	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
-	/* _adapter				*pbuddy_adapter = padapter->pbuddy_adapter; */
-	/* struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo; */
-	/* struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv; */
-	/* struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv; */
-	u8 val8;
-
-	if (check_buddy_fwstate(padapter, _FW_LINKED)) {
-		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
-		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
-		pwdinfo->operating_channel = pbuddy_mlmeext->cur_channel;
-
-		DBG_8192D("%s, switch ch back to buddy's cur_channel =%d\n", __func__, pbuddy_mlmeext->cur_channel);
-
-		set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-
-		issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
-	} else {
-		set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-	}
-
-}
-#endif
-
-static void ro_ch_handler(struct rtw_adapter *padapter)
-{
-	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
-	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(padapter, _FW_LINKED)) {
-		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
-		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
-		DBG_8192D("%s, switch ch back to buddy's cur_channel =%d\n",
-			  __func__, pbuddy_mlmeext->cur_channel);
-
-		set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel,
-				   pbuddy_mlmeext->cur_ch_offset,
-				   pbuddy_mlmeext->cur_bwmode);
-		pmlmeext->cur_channel = pbuddy_mlmeext->cur_channel;
-
-	} else
-#endif /* CONFIG_CONCURRENT_MODE */
-	if (pcfg80211_wdinfo->restore_channel != pmlmeext->cur_channel) {
-		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
-			pmlmeext->cur_channel = pcfg80211_wdinfo->restore_channel;
-
-		set_channel_bwmode(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-	}
-
-	rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
-
-	pcfg80211_wdinfo->is_ro_ch = false;
-
-	DBG_8192D("cfg80211_remain_on_channel_expired\n");
-
-	cfg80211_remain_on_channel_expired(padapter->rtw_wdev,
-		pcfg80211_wdinfo->remain_on_ch_cookie,
-		&pcfg80211_wdinfo->remain_on_ch_channel,
-		GFP_KERNEL);
-}
-
-static void ro_ch_timer_process (void *FunctionContext)
-{
-	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
-
-#ifdef	CONFIG_CONCURRENT_MODE
-	atomic_set(&pwdev_priv->ro_ch_to, 1);
-#endif
-
-	p2p_protocol_wk_cmd(adapter, P2P_RO_CH_WK);
-}
-
-int rtw_p2p_check_frames(struct rtw_adapter *padapter, const u8 *buf, u32 len, u8 tx)
-{
-	int is_p2p_frame = (-1);
-	unsigned char	*frame_body;
-	u8 category, action, OUI_Subtype, dialogToken = 0;
-	u8 *p2p_ie = NULL;
-	uint p2p_ielen = 0;
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
-
-	frame_body = (unsigned char *)(buf + sizeof(struct ieee80211_hdr_3addr));
-	category = frame_body[0];
-	/* just for check */
-	if (category == RTW_WLAN_CATEGORY_PUBLIC) {
-		action = frame_body[1];
-		if (action == ACT_PUBLIC_VENDOR &&
-		    !memcmp(frame_body+2, P2P_OUI, 4)) {
-			OUI_Subtype = frame_body[6];
-			dialogToken = frame_body[7];
-			is_p2p_frame = OUI_Subtype;
-
-			p2p_ie = rtw_get_p2p_ie(
-				(u8 *)buf+sizeof(struct ieee80211_hdr_3addr)+_PUBLIC_ACTION_IE_OFFSET_,
-				len-sizeof(struct ieee80211_hdr_3addr)-_PUBLIC_ACTION_IE_OFFSET_,
-				NULL, &p2p_ielen);
-
-			switch (OUI_Subtype) {
-			u8 *cont;
-			uint cont_len;
-			case P2P_GO_NEGO_REQ:
-				DBG_8192D("RTW_%s:P2P_GO_NEGO_REQ, dialogToken =%d\n",
-					  tx ? "Tx" : "Rx", dialogToken);
-
-				if (tx) {
-#ifdef CONFIG_CONCURRENT_MODE
-					if (check_buddy_fwstate(padapter, _FW_LINKED))
-						rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct ieee80211_hdr_3addr));
-#endif
-				}
-
-				break;
-			case P2P_GO_NEGO_RESP:
-				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
-				DBG_8192D("RTW_%s:P2P_GO_NEGO_RESP, dialogToken =%d, status:%d\n",
-					  tx ? "Tx" : "Rx", dialogToken, cont ? *cont : -1);
-
-				if (!tx)
-					pwdev_priv->provdisc_req_issued = false;
-#ifdef CONFIG_CONCURRENT_MODE
-				else {
-					if (check_buddy_fwstate(padapter, _FW_LINKED))
-						rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct ieee80211_hdr_3addr));
-				}
-#endif
-				break;
-			case P2P_GO_NEGO_CONF:
-				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
-				DBG_8192D("RTW_%s:P2P_GO_NEGO_CONF, dialogToken =%d, status:%d\n",
-					  tx ? "Tx" : "Rx", dialogToken, cont ? *cont : -1);
-#ifdef CONFIG_CONCURRENT_MODE
-				if (tx) {
-					if (check_buddy_fwstate(padapter, _FW_LINKED))
-						rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct ieee80211_hdr_3addr));
-				}
-#endif
-				break;
-			case P2P_INVIT_REQ: {
-				struct rtw_wdev_invit_info *invit_info = &pwdev_priv->invit_info;
-				int flags = -1;
-				int op_ch = 0;
-
-				if (tx) {
-					#ifdef CONFIG_CONCURRENT_MODE
-					if (check_buddy_fwstate(padapter, _FW_LINKED))
-						rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct ieee80211_hdr_3addr));
-					#endif
-				}
-
-				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INVITATION_FLAGS, NULL, &cont_len);
-				if (cont)
-					flags = *cont;
-				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, &cont_len);
-				if (cont)
-					op_ch = *(cont+4);
-
-				if (invit_info->token != dialogToken)
-					rtw_wdev_invit_info_init(invit_info);
-
-				invit_info->token = dialogToken;
-				invit_info->flags = (flags == -1) ? 0x0 : flags;
-				invit_info->req_op_ch = op_ch;
-
-				DBG_8192D("RTW_%s:P2P_INVIT_REQ, dialogToken =%d, flags:0x%02x, op_ch:%d\n",
-					  tx ? "Tx" : "Rx", dialogToken, flags, op_ch);
-				break;
-			}
-			case P2P_INVIT_RESP: {
-				struct rtw_wdev_invit_info *invit_info = &pwdev_priv->invit_info;
-				int status = -1;
-				int op_ch = 0;
-
-				if (tx) {
-					#ifdef CONFIG_CONCURRENT_MODE
-					if (check_buddy_fwstate(padapter, _FW_LINKED))
-						rtw_cfg80211_adjust_p2pie_channel(padapter, frame_body, len-sizeof(struct ieee80211_hdr_3addr));
-					#endif
-				}
-
-				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
-				if (cont)
-					status = *cont;
-				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, &cont_len);
-				if (cont)
-					op_ch = *(cont+4);
-
-				if (invit_info->token != dialogToken) {
-					rtw_wdev_invit_info_init(invit_info);
-				} else {
-					invit_info->token = 0;
-					invit_info->status = (status == -1) ? 0xff : status;
-					invit_info->rsp_op_ch = op_ch;
-				}
-
-				DBG_8192D("RTW_%s:P2P_INVIT_RESP, dialogToken =%d, status:%d, op_ch:%d\n",
-					  tx ? "Tx" : "Rx", dialogToken, status, op_ch);
-				break;
-			}
-			case P2P_DEVDISC_REQ:
-				DBG_8192D("RTW_%s:P2P_DEVDISC_REQ, dialogToken =%d\n",
-					  tx ? "Tx" : "Rx", dialogToken);
-				break;
-			case P2P_DEVDISC_RESP:
-				cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, NULL, &cont_len);
-				DBG_8192D("RTW_%s:P2P_DEVDISC_RESP, dialogToken =%d, status:%d\n",
-					  tx ? "Tx" : "Rx", dialogToken, cont ? *cont : -1);
-				break;
-			case P2P_PROVISION_DISC_REQ: {
-				size_t frame_body_len = len - sizeof(struct ieee80211_hdr_3addr);
-				u8 *p2p_ie;
-				uint p2p_ielen = 0;
-				uint contentlen = 0;
-
-				DBG_8192D("RTW_%s:P2P_PROVISION_DISC_REQ, dialogToken =%d\n",
-					  tx ? "Tx" : "Rx", dialogToken);
-
-				pwdev_priv->provdisc_req_issued = false;
-
-				p2p_ie = rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_,
-							frame_body_len - _PUBLIC_ACTION_IE_OFFSET_,
-							NULL, &p2p_ielen);
-				if (p2p_ie) {
-					if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, NULL, &contentlen))
-						pwdev_priv->provdisc_req_issued = false;/* case: p2p_client join p2p GO */
-					else
-						pwdev_priv->provdisc_req_issued = true;/* case: p2p_devices connection before Nego req. */
-				}
-				break; }
-			case P2P_PROVISION_DISC_RESP:
-				DBG_8192D("RTW_%s:P2P_PROVISION_DISC_RESP, dialogToken =%d\n",
-					  tx ? "Tx" : "Rx", dialogToken);
-				break;
-			default:
-				DBG_8192D("RTW_%s:OUI_Subtype =%d, dialogToken =%d\n",
-					  tx ? "Tx" : "Rx", OUI_Subtype, dialogToken);
-				break;
-			}
-		}
-	} else if (category == RTW_WLAN_CATEGORY_P2P) {
-		OUI_Subtype = frame_body[5];
-		dialogToken = frame_body[6];
-
-		is_p2p_frame = OUI_Subtype;
-
-		switch (OUI_Subtype) {
-		case P2P_NOTICE_OF_ABSENCE:
-			DBG_8192D("RTW_%s:P2P_NOTICE_OF_ABSENCE, dialogToken =%d\n", tx ? "TX" : "RX", dialogToken);
-			break;
-		case P2P_PRESENCE_REQUEST:
-			DBG_8192D("RTW_%s:P2P_PRESENCE_REQUEST, dialogToken =%d\n", tx ? "TX" : "RX", dialogToken);
-			break;
-		case P2P_PRESENCE_RESPONSE:
-			DBG_8192D("RTW_%s:P2P_PRESENCE_RESPONSE, dialogToken =%d\n", tx ? "TX" : "RX", dialogToken);
-			break;
-		case P2P_GO_DISC_REQUEST:
-			DBG_8192D("RTW_%s:P2P_GO_DISC_REQUEST, dialogToken =%d\n", tx ? "TX" : "RX", dialogToken);
-			break;
-		default:
-			DBG_8192D("RTW_%s:OUI_Subtype =%d, dialogToken =%d\n", tx ? "TX" : "RX", OUI_Subtype, dialogToken);
-			break;
-		}
-
-	} else {
-		DBG_8192D("RTW_%s:action frame category =%d\n", tx ? "TX" : "RX", category);
-		/* is_p2p_frame = (-1); */
-	}
-
-	return is_p2p_frame;
-}
-
-void rtw_init_cfg80211_wifidirect_info(struct rtw_adapter *padapter)
-{
-	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
-
-	memset(pcfg80211_wdinfo, 0x00, sizeof(struct cfg80211_wifidirect_info));
-
-	_init_timer(&pcfg80211_wdinfo->remain_on_ch_timer, padapter->pnetdev, ro_ch_timer_process, padapter);
-}
-
-void p2p_protocol_wk_hdl(struct rtw_adapter *padapter, int intCmdType)
-{
-	switch (intCmdType) {
-	case P2P_FIND_PHASE_WK:
-		find_phase_handler(padapter);
-		break;
-	case P2P_RESTORE_STATE_WK:
-		restore_p2p_state_handler(padapter);
-		break;
-	case P2P_PRE_TX_PROVDISC_PROCESS_WK:
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED))
-			p2p_concurrent_handler(padapter);
-		else
-			pre_tx_provdisc_handler(padapter);
-#else
-		pre_tx_provdisc_handler(padapter);
-#endif
-		break;
-	case P2P_PRE_TX_INVITEREQ_PROCESS_WK:
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED))
-			p2p_concurrent_handler(padapter);
-		else
-			pre_tx_invitereq_handler(padapter);
-#else
-		pre_tx_invitereq_handler(padapter);
-#endif
-		break;
-	case P2P_PRE_TX_NEGOREQ_PROCESS_WK:
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED))
-			p2p_concurrent_handler(padapter);
-		else
-			pre_tx_negoreq_handler(padapter);
-#else
-		pre_tx_negoreq_handler(padapter);
-#endif
-		break;
-#ifdef CONFIG_92D_P2P
-#ifdef CONFIG_CONCURRENT_MODE
-	case P2P_AP_P2P_CH_SWITCH_PROCESS_WK:
-		p2p_concurrent_handler(padapter);
-		break;
-#endif
-#endif
-	case P2P_RO_CH_WK:
-		ro_ch_handler(padapter);
-		break;
-	}
-
-}
-
-static void reset_ch_sitesurvey_timer_process(void *FunctionContext)
-{
-	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
-	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		return;
-
-	DBG_8192D("[%s] In\n", __func__);
-	/*	Reset the operation channel information */
-	pwdinfo->rx_invitereq_info.operation_ch[0] = 0;
-	pwdinfo->rx_invitereq_info.scan_op_ch_only = 0;
-}
-
-static void reset_ch_sitesurvey_timer_process2(void *FunctionContext)
-{
-	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
-	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		return;
-
-	DBG_8192D("[%s] In\n", __func__);
-	/*	Reset the operation channel information */
-	pwdinfo->p2p_info.operation_ch[0] = 0;
-	pwdinfo->p2p_info.scan_op_ch_only = 0;
-}
-
-static void restore_p2p_state_timer_process(void *FunctionContext)
-{
-	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
-	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		return;
-
-	p2p_protocol_wk_cmd(adapter, P2P_RESTORE_STATE_WK);
-}
-
-static void pre_tx_scan_timer_process(void *FunctionContext)
-{
-	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
-	struct	wifidirect_info *pwdinfo = &adapter->wdinfo;
-	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		return;
-
-	spin_lock_bh(&pmlmepriv->lock);
-
-	/*	Commented by Albert 20110805 */
-	/*	Todo: Use the issuing probe request directly instead of using the rtw_sitesurvey_cmd!! */
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ)) {
-		if (true == pwdinfo->tx_prov_disc_info.benable) {
-			/* the provision discovery request frame is trigger to send or not */
-			p2p_protocol_wk_cmd(adapter, P2P_PRE_TX_PROVDISC_PROCESS_WK);
-			/* issue_probereq_p2p(adapter, NULL); */
-			/* _set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT); */
-		}
-	} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING)) {
-		if (true == pwdinfo->nego_req_info.benable) {
-			p2p_protocol_wk_cmd(adapter, P2P_PRE_TX_NEGOREQ_PROCESS_WK);
-			/* issue_probereq_p2p(adapter, NULL); */
-			/* _set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT); */
-		}
-	} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ)) {
-		if (true == pwdinfo->invitereq_info.benable)
-			p2p_protocol_wk_cmd(adapter, P2P_PRE_TX_INVITEREQ_PROCESS_WK);
-	} else {
-		DBG_8192D("[%s] p2p_state is %d, ignore!!\n", __func__, rtw_p2p_state(pwdinfo));
-	}
-
-	spin_unlock_bh(&pmlmepriv->lock);
-}
-
-static void find_phase_timer_process(void *FunctionContext)
-{
-	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
-	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		return;
-
-	adapter->wdinfo.find_phase_state_exchange_cnt++;
-
-	p2p_protocol_wk_cmd(adapter, P2P_FIND_PHASE_WK);
-}
-
-#ifdef CONFIG_CONCURRENT_MODE
-static void ap_p2p_switch_timer_process(void *FunctionContext)
-{
-	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
-	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
-	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		return;
-
-	atomic_set(&pwdev_priv->switch_ch_to, 1);
-	p2p_protocol_wk_cmd(adapter, P2P_AP_P2P_CH_SWITCH_PROCESS_WK);
-}
-#endif
-
-void reset_global_wifidirect_info(struct rtw_adapter *padapter)
-{
-	struct wifidirect_info	*pwdinfo;
-
-	pwdinfo = &padapter->wdinfo;
-	pwdinfo->persistent_supported = 0;
-	pwdinfo->session_available = true;
-	pwdinfo->wfd_tdls_enable = 0;
-	pwdinfo->wfd_tdls_weaksec = 0;
-}
-
-void rtw_init_wifidirect_timers(struct rtw_adapter *padapter)
-{
-	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-
-	_init_timer(&pwdinfo->find_phase_timer, padapter->pnetdev, find_phase_timer_process, padapter);
-	_init_timer(&pwdinfo->restore_p2p_state_timer, padapter->pnetdev, restore_p2p_state_timer_process, padapter);
-	_init_timer(&pwdinfo->pre_tx_scan_timer, padapter->pnetdev, pre_tx_scan_timer_process, padapter);
-	_init_timer(&pwdinfo->reset_ch_sitesurvey, padapter->pnetdev, reset_ch_sitesurvey_timer_process, padapter);
-	_init_timer(&pwdinfo->reset_ch_sitesurvey2, padapter->pnetdev, reset_ch_sitesurvey_timer_process2, padapter);
-#ifdef CONFIG_CONCURRENT_MODE
-	_init_timer(&pwdinfo->ap_p2p_switch_timer, padapter->pnetdev, ap_p2p_switch_timer_process, padapter);
-#endif
-}
-
-void rtw_init_wifidirect_addrs(struct rtw_adapter *padapter, u8 *dev_addr, u8 *iface_addr)
-{
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-
-	if (dev_addr)
-		memcpy(pwdinfo->device_addr, dev_addr, ETH_ALEN);
-	if (iface_addr)
-		memcpy(pwdinfo->interface_addr, iface_addr, ETH_ALEN);
-#endif
-}
-
-void init_wifidirect_info(struct rtw_adapter *padapter, enum P2P_ROLE role)
-{
-	struct wifidirect_info	*pwdinfo;
-#ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
-	struct mlme_ext_priv	*pbuddy_mlmeext;
-#endif
-
-	pwdinfo = &padapter->wdinfo;
-
-	pwdinfo->padapter = padapter;
-
-	/*	1, 6, 11 are the social channel defined in the WiFi Direct specification. */
-	pwdinfo->social_chan[0] = 1;
-	pwdinfo->social_chan[1] = 6;
-	pwdinfo->social_chan[2] = 11;
-	pwdinfo->social_chan[3] = 0;	/*	channel 0 for scanning ending in site survey function. */
-
-#ifdef CONFIG_CONCURRENT_MODE
-	if (pbuddy_adapter)
-		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
-	if ((check_buddy_fwstate(padapter, _FW_LINKED) == true) &&
-	    ((pbuddy_mlmeext->cur_channel == 1) ||
-	     (pbuddy_mlmeext->cur_channel == 6) ||
-	     (pbuddy_mlmeext->cur_channel == 11))) {
-		/*	Use the AP's channel as the listen channel */
-		/*	This will avoid the channel switch between AP's channel and listen channel. */
-		pwdinfo->listen_channel = pbuddy_mlmeext->cur_channel;
-	} else
-#endif /* CONFIG_CONCURRENT_MODE */
-	{
-		/*	Use the channel 11 as the listen channel */
-		pwdinfo->listen_channel = 11;
-	}
-
-	if (role == P2P_ROLE_DEVICE) {
-		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
-		#ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED) == true)
-			rtw_p2p_set_state(pwdinfo, P2P_STATE_IDLE);
-		else
-		#endif
-			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
-		pwdinfo->intent = 1;
-		rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_LISTEN);
-	} else if (role == P2P_ROLE_CLIENT) {
-		rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
-		pwdinfo->intent = 1;
-		rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
-	} else if (role == P2P_ROLE_GO) {
-		rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
-		pwdinfo->intent = 15;
-		rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
-	}
-
-/*	Use the OFDM rate in the P2P probe response frame. (6(B), 9(B), 12, 18, 24, 36, 48, 54) */
-	pwdinfo->support_rate[0] = 0x8c;	/*	6(B) */
-	pwdinfo->support_rate[1] = 0x92;	/*	9(B) */
-	pwdinfo->support_rate[2] = 0x18;	/*	12 */
-	pwdinfo->support_rate[3] = 0x24;	/*	18 */
-	pwdinfo->support_rate[4] = 0x30;	/*	24 */
-	pwdinfo->support_rate[5] = 0x48;	/*	36 */
-	pwdinfo->support_rate[6] = 0x60;	/*	48 */
-	pwdinfo->support_rate[7] = 0x6c;	/*	54 */
-
-	memcpy((void *)pwdinfo->p2p_wildcard_ssid, "DIRECT-", 7);
-
-	memset(pwdinfo->device_name, 0x00, WPS_MAX_DEVICE_NAME_LEN);
-	pwdinfo->device_name_len = 0;
-
-	memset(&pwdinfo->invitereq_info, 0x00, sizeof(struct tx_invite_req_info));
-	pwdinfo->invitereq_info.token = 3;	/*	Token used for P2P invitation request frame. */
-
-	memset(&pwdinfo->inviteresp_info, 0x00, sizeof(struct tx_invite_resp_info));
-	pwdinfo->inviteresp_info.token = 0;
-
-	pwdinfo->profileindex = 0;
-	memset(&pwdinfo->profileinfo[0], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
-
-	rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
-
-	pwdinfo->listen_dwell = (u8) ((jiffies % 3) + 1);
-	/* DBG_8192D("[%s] listen_dwell time is %d00ms\n", __func__, pwdinfo->listen_dwell); */
-
-	memset(&pwdinfo->tx_prov_disc_info, 0x00, sizeof(struct tx_provdisc_req_info));
-	pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_NONE;
-
-	memset(&pwdinfo->nego_req_info, 0x00, sizeof(struct tx_nego_req_info));
-
-	pwdinfo->device_password_id_for_nego = WPS_DPID_PBC;
-	pwdinfo->negotiation_dialog_token = 1;
-
-	memset(pwdinfo->nego_ssid, 0x00, WLAN_SSID_MAXLEN);
-	pwdinfo->nego_ssidlen = 0;
-
-	pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
-	pwdinfo->supported_wps_cm = WPS_CONFIG_METHOD_DISPLAY | WPS_CONFIG_METHOD_PBC | WPS_CONFIG_METHOD_KEYPAD;
-	pwdinfo->channel_list_attr_len = 0;
-	memset(pwdinfo->channel_list_attr, 0x00, 100);
-
-	memset(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, 0x00, 4);
-	memset(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, '0', 3);
-	memset(&pwdinfo->groupid_info, 0x00, sizeof(struct group_id_info));
-#ifdef CONFIG_CONCURRENT_MODE
-	pwdinfo->ext_listen_interval = 1000; /* The interval to be available with legacy AP during p2p0-find/scan */
-	pwdinfo->ext_listen_period = 3000; /* The time period to be available for P2P during nego */
-#endif
-	pwdinfo->wfd_tdls_enable = 0;
-	memset(pwdinfo->p2p_peer_interface_addr, 0x00, ETH_ALEN);
-	memset(pwdinfo->p2p_peer_device_addr, 0x00, ETH_ALEN);
-
-	pwdinfo->rx_invitereq_info.operation_ch[0] = 0;
-	pwdinfo->rx_invitereq_info.operation_ch[1] = 0;	/*	Used to indicate the scan end in site survey function */
-	pwdinfo->rx_invitereq_info.scan_op_ch_only = 0;
-	pwdinfo->p2p_info.operation_ch[0] = 0;
-	pwdinfo->p2p_info.operation_ch[1] = 0;			/*	Used to indicate the scan end in site survey function */
-	pwdinfo->p2p_info.scan_op_ch_only = 0;
-}
-
-int rtw_p2p_enable(struct rtw_adapter *padapter, enum P2P_ROLE role)
-{
-	int ret = 1;
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-
-	if (role == P2P_ROLE_DEVICE || role == P2P_ROLE_CLIENT ||
-	    role == P2P_ROLE_GO) {
-#ifdef CONFIG_CONCURRENT_MODE
-		struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
-		struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
-		/*	The driver just supports 1 P2P group operation. */
-		/*	So, this function will do nothing if the buddy adapter had enabled the P2P function. */
-		if (!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE)) {
-			/*	The buddy adapter had enabled the P2P function. */
-			return ret;
-		}
-#endif /* CONFIG_CONCURRENT_MODE */
-
-		/* leave IPS/Autosuspend */
-		if (0 == rtw_pwr_wakeup(padapter)) {
-			ret = 0;
-			goto exit;
-		}
-
-		/*	Added by Albert 2011/03/22 */
-		/*	In the P2P mode, the driver should not support the b mode. */
-		/*	So, the Tx packet shouldn't use the CCK rate */
-		update_tx_basic_rate(padapter, WIRELESS_11AGN);
-
-		/* Enable P2P function */
-		init_wifidirect_info(padapter, role);
-	} else if (role == P2P_ROLE_DISABLE) {
-		if (0 == rtw_pwr_wakeup(padapter)) {
-			ret = 0;
-			goto exit;
-		}
-
-		/* Disable P2P function */
-		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-			del_timer_sync(&pwdinfo->find_phase_timer);
-			del_timer_sync(&pwdinfo->restore_p2p_state_timer);
-			del_timer_sync(&pwdinfo->pre_tx_scan_timer);
-			del_timer_sync(&pwdinfo->reset_ch_sitesurvey);
-			del_timer_sync(&pwdinfo->reset_ch_sitesurvey2);
-			reset_ch_sitesurvey_timer_process(padapter);
-			reset_ch_sitesurvey_timer_process2(padapter);
-			#ifdef CONFIG_CONCURRENT_MODE
-			del_timer_sync(&pwdinfo->ap_p2p_switch_timer);
-			#endif
-			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
-			rtw_p2p_set_role(pwdinfo, P2P_ROLE_DISABLE);
-			memset(&pwdinfo->rx_prov_disc_info, 0x00, sizeof(struct rx_provdisc_req_info));
-		}
-
-		/* Restore to initial setting. */
-		update_tx_basic_rate(padapter, padapter->registrypriv.wireless_mode);
-	}
-
-exit:
-	return ret;
-}
-
-#endif /* CONFIG_92D_P2P */
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -103,9 +103,6 @@ static bool rtw_pwr_unassociated_idle(st
 {
 	struct rtw_adapter *buddy = adapter->pbuddy_adapter;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &(adapter->wdinfo);
-#endif
 
 	bool ret = false;
 
@@ -117,25 +114,16 @@ static bool rtw_pwr_unassociated_idle(st
 	if (check_fwstate(pmlmepriv, WIFI_ASOC_STATE | WIFI_SITE_MONITOR) ||
 	    check_fwstate(pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS) ||
 	    check_fwstate(pmlmepriv, WIFI_AP_STATE) ||
-#if defined(CONFIG_92D_P2P)
-	    !rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) ||
-#endif
 	    check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE))
 		goto exit;
 
 	/* consider buddy, if exist */
 	if (buddy) {
 		struct mlme_priv *b_pmlmepriv = &(buddy->mlmepriv);
-#ifdef CONFIG_92D_P2P
-		struct wifidirect_info *b_pwdinfo = &(buddy->wdinfo);
-#endif
 
 		if (check_fwstate(b_pmlmepriv, WIFI_ASOC_STATE | WIFI_SITE_MONITOR) ||
 		    check_fwstate(b_pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS) ||
 		    check_fwstate(b_pmlmepriv, WIFI_AP_STATE) ||
-#if defined(CONFIG_92D_P2P)
-		    !rtw_p2p_chk_state(b_pwdinfo, P2P_STATE_NONE) ||
-#endif
 		    check_fwstate(b_pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE)) {
 			goto exit;
 		}
@@ -316,20 +304,12 @@ void rtw_lps_enter(struct rtw_adapter *p
 	/* consider buddy, if exist */
 	if (buddy) {
 		struct mlme_priv *b_pmlmepriv = &(buddy->mlmepriv);
-#ifdef CONFIG_92D_P2P
-		struct wifidirect_info *b_pwdinfo = &(buddy->wdinfo);
-		struct cfg80211_wifidirect_info *b_pcfg80211_wdinfo =
-		    &buddy->cfg80211_wdinfo;
-#endif
 
 		if (check_fwstate
 		    (b_pmlmepriv, WIFI_ASOC_STATE | WIFI_SITE_MONITOR) ||
-		     check_fwstate(b_pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS) ||
-		     check_fwstate(b_pmlmepriv, WIFI_AP_STATE) ||
-		     check_fwstate(b_pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE) ||
-#if defined(CONFIG_92D_P2P)
-		    !rtw_p2p_chk_state(b_pwdinfo, P2P_STATE_NONE) ||
-#endif
+		    check_fwstate(b_pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS) ||
+		    check_fwstate(b_pmlmepriv, WIFI_AP_STATE) ||
+		    check_fwstate(b_pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE) ||
 		    rtw_is_scan_deny(buddy))
 			return;
 	}
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -1197,15 +1197,7 @@ void update_tx_basic_rate(struct rtw_ada
 {
 	unsigned char supported_rates[NDIS_802_11_LENGTH_RATES_EX];
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 
-	/*	Added by Albert 2011/03/22 */
-	/*	In the P2P mode, the driver should not support the b mode. */
-	/*	So, the Tx packet shouldn't use the CCK rate */
-	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		return;
-#endif /* CONFIG_92D_P2P */
 	memset(supported_rates, 0, NDIS_802_11_LENGTH_RATES_EX);
 
 	/* clear B mod if current channel is in 5G band, avoid tx cck rate in 5G band. */
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -230,10 +230,6 @@ static s32 update_txdesc(struct xmit_fra
 	struct pkt_attrib		*pattrib = &pxmitframe->attrib;
 	struct tx_desc		*ptxdesc = (struct tx_desc *)pmem;
 	int	bmcst = IS_MCAST(pattrib->ra);
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
-	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
-#endif /* CONFIG_92D_P2P */
 
 	if (padapter->registrypriv.mp_mode == 0) {
 
@@ -312,18 +308,6 @@ static s32 update_txdesc(struct xmit_fra
 			ptxdesc->txdw5 |= cpu_to_le32(ratetohwrate(pmlmeext->tx_rate));
 		}
 
-#ifdef CONFIG_92D_P2P
-		if (pregistrypriv->wifi_spec==1 && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		{
-			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));/* AGG BK */
-
-			ptxdesc->txdw4 |= cpu_to_le32(BIT(8));/* driver uses rate */
-
-			ptxdesc->txdw5 = cpu_to_le32(0x0001ff00);/*  */
-
-			ptxdesc->txdw5 |= cpu_to_le32(BIT(2));/*  use OFDM 6Mbps */
-		}
-#endif /* CONFIG_92D_P2P */
 	} else if ((pxmitframe->frame_tag&0x0f)== MGNT_FRAMETAG) {
 
 		/* offset 4 */
@@ -350,12 +334,7 @@ static s32 update_txdesc(struct xmit_fra
 #ifdef CONFIG_92D_AP_MODE
 		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
 			ptxdesc->txdw5 |= cpu_to_le32(BIT(17));/* retry limit enable */
-#ifdef CONFIG_92D_P2P
-			if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-				ptxdesc->txdw5 |= cpu_to_le32(0x00080000);/* retry limit = 2 */
-			} else
-#endif /* CONFIG_92D_P2P */
-				ptxdesc->txdw5 |= cpu_to_le32(0x00180000);/* retry limit = 6 */
+			ptxdesc->txdw5 |= cpu_to_le32(0x00180000);/* retry limit = 6 */
 		}
 #endif
 
--- a/drivers/staging/rtl8192du/include/autoconf.h
+++ b/drivers/staging/rtl8192du/include/autoconf.h
@@ -25,8 +25,6 @@
 
 #define CONFIG_92D_AP_MODE 1
 
-#define CONFIG_92D_P2P	1
-
 #define CONFIG_92D_BT_COEXIST
 
 #define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable,*/
--- a/drivers/staging/rtl8192du/include/drv_types.h
+++ b/drivers/staging/rtl8192du/include/drv_types.h
@@ -310,10 +310,6 @@ struct rtw_adapter {
 	u8 bForceWriteInitGain;
 	/* 	The driver will show up the desired channel number when this flag is 1. */
 	u8 bNotifyChannelChange;
-#ifdef CONFIG_92D_P2P
-	/* 	The driver will show the current P2P status when the upper application reads it. */
-	u8 bShowGetP2PState;
-#endif
 
 	/* pbuddy_adapter is used only in  two inteface case, (iface_nums=2 in struct dvobj_priv) */
 	/* PRIMARY_ADAPTER's buddy is SECONDARY_ADAPTER */
--- a/drivers/staging/rtl8192du/include/ieee80211.h
+++ b/drivers/staging/rtl8192du/include/ieee80211.h
@@ -1157,16 +1157,6 @@ u8 *rtw_get_wps_attr_content(u8 *wps_ie,
 
 void dump_ies(u8 *buf, u32 buf_len);
 void dump_wps_ie(u8 *ie, u32 ie_len);
-
-#ifdef CONFIG_92D_P2P
-void dump_p2p_ie(u8 *ie, u32 ie_len);
-u8 *rtw_get_p2p_ie(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen);
-u8 *rtw_get_p2p_attr(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id ,u8 *buf_attr, u32 *len_attr);
-u8 *rtw_get_p2p_attr_content(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id ,u8 *buf_content, uint *len_content);
-u32 rtw_set_p2p_attr_content(u8 *pbuf, u8 attr_id, u16 attr_len, u8 *pdata_attr);
-void rtw_wlan_bssid_ex_remove_p2p_attr(struct wlan_bssid_ex *bss_ex, u8 attr_id);
-#endif
-
 uint	rtw_get_rateset_len(u8	*rateset);
 
 struct registry_priv;
--- a/drivers/staging/rtl8192du/include/rtl8192d_cmd.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_cmd.h
@@ -99,9 +99,6 @@ void	rtl8192d_set_FwJoinBssReport_cmd(st
 u8	rtl8192d_set_rssi_cmd(struct rtw_adapter*padapter, u8 *param);
 u8	rtl8192d_set_raid_cmd(struct rtw_adapter*padapter, u32 mask, u8 arg);
 void	rtl8192d_Add_RateATid(struct rtw_adapter * adapter, u32 bitmap, u8 arg);
-#ifdef CONFIG_92D_P2P
-void	rtl8192d_set_p2p_ps_offload_cmd(struct rtw_adapter* padapter, u8 p2p_ps_state);
-#endif /* CONFIG_92D_P2P */
 
 #ifdef CONFIG_CONCURRENT_MODE
 int reset_tsf(struct rtw_adapter * adapter, u8 reset_port);
--- a/drivers/staging/rtl8192du/include/rtl8192d_hal.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_hal.h
@@ -595,9 +595,6 @@ struct hal_data_8192du {
 
 	u16	EfuseUsedBytes;
 	u8	RTSInitRate;	 /*  2010.11.24.by tynli. */
-#ifdef CONFIG_92D_P2P
-	struct P2P_PS_Offload_t	p2p_ps_offload;
-#endif /* CONFIG_92D_P2P */
 };
 
 #define GET_HAL_DATA(__adapter)	((struct hal_data_8192du *)((__adapter)->HalData))
--- a/drivers/staging/rtl8192du/include/rtw_cmd.h
+++ b/drivers/staging/rtl8192du/include/rtw_cmd.h
@@ -99,12 +99,8 @@ void rtw_free_cmd_priv (struct cmd_priv
 
 u32 rtw_init_evt_priv (struct evt_priv *pevtpriv);
 void rtw_evt_notify_isr(struct evt_priv *pevtpriv);
-#ifdef CONFIG_92D_P2P
-u8 p2p_protocol_wk_cmd(struct rtw_adapter*padapter, int intCmdType);
-#endif /* CONFIG_92D_P2P */
 
-enum rtw_drvextra_cmd_id
-{
+enum rtw_drvextra_cmd_id {
 	NONE_WK_CID,
 	DYNAMIC_CHK_WK_CID,
 	DM_CTRL_WK_CID,
@@ -120,8 +116,7 @@ enum rtw_drvextra_cmd_id
 	MAX_WK_CID
 };
 
-enum LPS_CTRL_TYPE
-{
+enum LPS_CTRL_TYPE {
 	LPS_CTRL_SCAN=0,
 	LPS_CTRL_JOINBSS=1,
 	LPS_CTRL_CONNECT=2,
--- a/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
@@ -523,15 +523,6 @@ void dump_mgntframe(struct rtw_adapter *
 s32 dump_mgntframe_and_wait(struct rtw_adapter *padapter, struct xmit_frame *pmgntframe, int timeout_ms);
 s32 dump_mgntframe_and_wait_ack(struct rtw_adapter *padapter, struct xmit_frame *pmgntframe);
 
-#ifdef CONFIG_92D_P2P
-void issue_probersp_p2p(struct rtw_adapter *padapter, unsigned char *da);
-void issue_p2p_provision_request(struct rtw_adapter *padapter, u8* pssid, u8 ussidlen, u8* pdev_raddr);
-void issue_p2p_GO_request(struct rtw_adapter *padapter, u8* raddr);
-void issue_probereq_p2p(struct rtw_adapter *padapter, u8 *da);
-int issue_probereq_p2p_ex(struct rtw_adapter *adapter, u8 *da, int try_cnt, int wait_ms);
-void issue_p2p_invitation_response(struct rtw_adapter *padapter, u8* raddr, u8 dialogToken, u8 success);
-void issue_p2p_invitation_request(struct rtw_adapter *padapter, u8* raddr);
-#endif /* CONFIG_92D_P2P */
 void issue_beacon(struct rtw_adapter *padapter);
 void issue_probersp(struct rtw_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probereq);
 void issue_assocreq(struct rtw_adapter *padapter);
--- a/drivers/staging/rtl8192du/include/sta_info.h
+++ b/drivers/staging/rtl8192du/include/sta_info.h
@@ -179,22 +179,6 @@ struct sta_info {
 	u8 has_legacy_ac;
 	unsigned int sleepq_ac_len;
 
-#ifdef CONFIG_92D_P2P
-	/* p2p priv data */
-	u8 is_p2p_device;
-	u8 p2p_status_code;
-
-	/* p2p client info */
-	u8 dev_addr[ETH_ALEN];
-	u8 dev_cap;
-	u16 config_methods;
-	u8 primary_dev_type[8];
-	u8 num_of_secdev_type;
-	u8 secdev_types_list[32];/*  32/8 == 4; */
-	u16 dev_name_len;
-	u8 dev_name[32];
-#endif /* CONFIG_92D_P2P */
-
 	u8 under_exist_checking;
 
 	u8 keep_alive_trycnt;
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -366,8 +366,6 @@ static int rtw_cfg80211_inform_bss(struc
 	memcpy(pbuf, pnetwork->network.IEs, pnetwork->network.IELength);
 	len += pnetwork->network.IELength;
 
-	/* ifdef CONFIG_92D_P2P */
-
 	bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)buf,
 		len, notify_signal, GFP_ATOMIC);
 	if (unlikely(!bss)) {
@@ -385,9 +383,6 @@ void rtw_cfg80211_indicate_connect(struc
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
 	struct wireless_dev *pwdev = padapter->rtw_wdev;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
-#endif
 
 	DBG_8192D("%s(padapter=%p)\n", __func__, padapter);
 
@@ -398,16 +393,6 @@ void rtw_cfg80211_indicate_connect(struc
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		return;
 
-#ifdef CONFIG_92D_P2P
-	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-	{
-		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
-		rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
-		DBG_8192D("%s, role=%d, p2p_state=%d, pre_p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo), rtw_p2p_pre_state(pwdinfo));
-	}
-#endif /* CONFIG_92D_P2P */
-
 	if (rtw_to_roaming(padapter) > 0) {
 		struct wiphy *wiphy = pwdev->wiphy;
 		struct ieee80211_channel *notify_channel;
@@ -447,12 +432,8 @@ void rtw_cfg80211_indicate_disconnect(st
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct wireless_dev *pwdev = padapter->rtw_wdev;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
-#endif
 
 	DBG_8192D("%s(padapter=%p)\n", __func__, padapter);
-
 	if (pwdev->iftype != NL80211_IFTYPE_STATION &&
 	    pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT)
 		return;
@@ -460,19 +441,6 @@ void rtw_cfg80211_indicate_disconnect(st
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		return;
 
-#ifdef CONFIG_92D_P2P
-	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-		del_timer_sync(&pwdinfo->find_phase_timer);
-		del_timer_sync(&pwdinfo->restore_p2p_state_timer);
-		del_timer_sync(&pwdinfo->pre_tx_scan_timer);
-
-		rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
-		rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
-
-		DBG_8192D("%s, role=%d, p2p_state=%d, pre_p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo), rtw_p2p_pre_state(pwdinfo));
-	}
-#endif /* CONFIG_92D_P2P */
-
 	if (!padapter->mlmepriv.not_indic_disco) {
 		if (check_fwstate(&padapter->mlmepriv, WIFI_UNDER_LINKING)) {
 			cfg80211_connect_result(padapter->pnetdev, NULL, NULL,
@@ -883,12 +851,8 @@ static int rtw_cfg80211_set_encryption(s
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
-#endif /* CONFIG_92D_P2P */
 
 	DBG_8192D("%s\n", __func__);
-
 	param->u.crypt.err = 0;
 	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
 
@@ -1002,13 +966,6 @@ static int rtw_cfg80211_set_encryption(s
 					padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
 
 					rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1);
-#ifdef CONFIG_92D_P2P
-					if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
-					{
-						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_DONE);
-					}
-#endif /* CONFIG_92D_P2P */
-
 				}
 			}
 
@@ -1267,9 +1224,6 @@ static int cfg80211_rtw_change_iface(str
 	struct wireless_dev *rtw_wdev = wiphy_to_wdev(wiphy);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct __queue *queue = &pmlmepriv->scanned_queue;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
-#endif
 	int ret = 0;
 	u8 change = false;
 
@@ -1312,29 +1266,10 @@ static int cfg80211_rtw_change_iface(str
 	case NL80211_IFTYPE_P2P_CLIENT:
 	case NL80211_IFTYPE_STATION:
 		networkType = NDIS802_11INFRA;
-		#ifdef CONFIG_92D_P2P
-		if (change && rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-			del_timer_sync(&pwdinfo->find_phase_timer);
-			del_timer_sync(&pwdinfo->restore_p2p_state_timer);
-			del_timer_sync(&pwdinfo->pre_tx_scan_timer);
-
-			/* it means remove GO and change mode from AP(GO) to station(P2P DEVICE) */
-			rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
-			rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
-
-			DBG_8192D("%s, role=%d, p2p_state=%d, pre_p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo), rtw_p2p_pre_state(pwdinfo));
-		}
-		#endif /* CONFIG_92D_P2P */
 		break;
 	case NL80211_IFTYPE_P2P_GO:
 	case NL80211_IFTYPE_AP:
 		networkType = Ndis802_11APMode;
-		#ifdef CONFIG_92D_P2P
-		if (change && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-			/* it means P2P Group created, we will be GO and change mode from  P2P DEVICE to AP(GO) */
-			rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
-		}
-		#endif /* CONFIG_92D_P2P */
 		break;
 	default:
 		return -EOPNOTSUPP;
@@ -1413,10 +1348,6 @@ static int rtw_cfg80211_set_probe_req_wp
 	uint wps_ielen = 0;
 	u8 *wps_ie;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-#ifdef CONFIG_92D_P2P
-	u32 p2p_ielen = 0;
-	u8 *p2p_ie;
-#endif
 
 	if (len > 0) {
 		if ((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen))) {
@@ -1435,26 +1366,6 @@ static int rtw_cfg80211_set_probe_req_wp
 			memcpy(pmlmepriv->wps_probe_req_ie, wps_ie, wps_ielen);
 			pmlmepriv->wps_probe_req_ie_len = wps_ielen;
 		}
-
-		#ifdef CONFIG_92D_P2P
-		if ((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen))) {
-
-			if (pmlmepriv->p2p_probe_req_ie) {
-				pmlmepriv->p2p_probe_req_ie_len = 0;
-				kfree(pmlmepriv->p2p_probe_req_ie);
-				pmlmepriv->p2p_probe_req_ie = NULL;
-			}
-
-			pmlmepriv->p2p_probe_req_ie = kmalloc(p2p_ielen, GFP_KERNEL);
-			if (pmlmepriv->p2p_probe_req_ie == NULL) {
-				DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
-				return -ENOMEM;
-
-			}
-			memcpy(pmlmepriv->p2p_probe_req_ie, p2p_ie, p2p_ielen);
-			pmlmepriv->p2p_probe_req_ie_len = p2p_ielen;
-		}
-		#endif /* CONFIG_92D_P2P */
 	}
 	return ret;
 }
@@ -1466,10 +1377,6 @@ static int cfg80211_rtw_scan(struct wiph
 	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
 	struct ndis_802_11_ssid ssid[RTW_SSID_SCAN_AMOUNT];
 	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
-	int social_channel = 0;
-#endif /* CONFIG_92D_P2P */
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 	struct cfg80211_ssid *ssids = request->ssids;
 #ifdef CONFIG_CONCURRENT_MODE
@@ -1497,25 +1404,6 @@ static int cfg80211_rtw_scan(struct wiph
 		goto check_need_indicate_scan_done;
 	}
 
-	#ifdef CONFIG_92D_P2P
-	if (ssids->ssid != NULL && !memcmp(ssids->ssid, "DIRECT-", 7) &&
-	    rtw_get_p2p_ie((u8 *)request->ie, request->ie_len, NULL, NULL)) {
-		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-			rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
-			wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = true;
-		} else {
-			rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
-		}
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
-
-		if (request->n_channels == 3 &&
-		    request->channels[0]->hw_value == 1 &&
-		    request->channels[1]->hw_value == 6 &&
-		    request->channels[2]->hw_value == 11)
-			social_channel = 1;
-	}
-	#endif /* CONFIG_92D_P2P */
-
 	if (request->ie && request->ie_len>0)
 		rtw_cfg80211_set_probe_req_wpsp2pie(padapter, (u8 *)request->ie, request->ie_len);
 
@@ -1563,19 +1451,6 @@ static int cfg80211_rtw_scan(struct wiph
 	}
 #endif
 
-#ifdef CONFIG_92D_P2P
-	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
-	{
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
-		rtw_free_network_queue(padapter, true);
-
-		if (social_channel == 0)
-			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
-		else
-			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_SOCIAL_LAST);
-	}
-#endif /* CONFIG_92D_P2P */
-
 	memset(ssid, 0, sizeof(struct ndis_802_11_ssid)*RTW_SSID_SCAN_AMOUNT);
 	/* parsing request ssids, n_ssids */
 	for (i = 0; i < request->n_ssids && i < RTW_SSID_SCAN_AMOUNT; i++) {
@@ -1873,30 +1748,6 @@ static int rtw_cfg80211_set_wpa_ie(struc
 		}
 	}
 
-	#ifdef CONFIG_92D_P2P
-	{/* check p2p_ie for assoc req; */
-		uint p2p_ielen=0;
-		u8 *p2p_ie;
-		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
-		if ((p2p_ie=rtw_get_p2p_ie(buf, ielen, NULL, &p2p_ielen))) {
-			if (pmlmepriv->p2p_assoc_req_ie) {
-				pmlmepriv->p2p_assoc_req_ie_len = 0;
-				kfree(pmlmepriv->p2p_assoc_req_ie);
-				pmlmepriv->p2p_assoc_req_ie = NULL;
-			}
-
-			pmlmepriv->p2p_assoc_req_ie = kmalloc(p2p_ielen, GFP_KERNEL);
-			if (pmlmepriv->p2p_assoc_req_ie == NULL) {
-				DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
-				goto exit;
-			}
-			memcpy(pmlmepriv->p2p_assoc_req_ie, p2p_ie, p2p_ielen);
-			pmlmepriv->p2p_assoc_req_ie_len = p2p_ielen;
-		}
-	}
-	#endif /* CONFIG_92D_P2P */
-
 	/* TKIP and AES disallow multicast packets until installing group key */
 	if (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_ ||
 	    padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_ ||
@@ -2491,9 +2342,6 @@ static int rtw_cfg80211_monitor_if_xmit_
 		u8 *buf = skb->data;
 		u32 len = skb->len;
 		u8 category, action;
-#ifdef CONFIG_92D_P2P
-		int type = -1;
-#endif
 
 		if (rtw_action_frame_parse(buf, len, &category, &action) == false) {
 			DBG_8192D(FUNC_NDEV_FMT" frame_control:0x%x\n", FUNC_NDEV_ARG(ndev),
@@ -2503,18 +2351,11 @@ static int rtw_cfg80211_monitor_if_xmit_
 
 		DBG_8192D("RTW_Tx:da=%pM via "FUNC_NDEV_FMT"\n",
 			GetAddr1Ptr(buf), FUNC_NDEV_ARG(ndev));
-		#ifdef CONFIG_92D_P2P
-		if ((type = rtw_p2p_check_frames(padapter, buf, len, true)) >= 0)
-			goto dump;
-		#endif
 		if (category == RTW_WLAN_CATEGORY_PUBLIC)
 			DBG_8192D("RTW_Tx:%s\n", action_public_str(action));
 		else
 			DBG_8192D("RTW_Tx:category(%u), action(%u)\n", category, action);
 
-#ifdef CONFIG_92D_P2P
-dump:
-#endif
 		/* starting alloc mgmt frame to dump it */
 		if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 			goto fail;
@@ -2714,10 +2555,6 @@ static int rtw_add_beacon(struct rtw_ada
 	u8 *pbuf = NULL;
 	uint len, wps_ielen=0;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
-#ifdef CONFIG_92D_P2P
-	u32 p2p_ielen = 0;
-	u8 got_p2p_ie = false;
-#endif
 
 	DBG_8192D("%s beacon_head_len=%zu, beacon_tail_len=%zu\n", __func__, head_len, tail_len);
 
@@ -2740,60 +2577,15 @@ static int rtw_add_beacon(struct rtw_ada
 	if (rtw_get_wps_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &wps_ielen))
 		DBG_8192D("add bcn, wps_ielen=%d\n", wps_ielen);
 
-#ifdef CONFIG_92D_P2P
-	/* check p2p ie if inclued */
-	if (rtw_get_p2p_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &p2p_ielen)) {
-		DBG_8192D("got p2p_ie, len=%d\n", p2p_ielen);
-		got_p2p_ie = true;
-	}
-#endif
-
 	rtw_ies_remove_ie(pbuf, &len, _BEACON_IE_OFFSET_, _VENDOR_SPECIFIC_IE_, P2P_OUI, 4);
 
 	/*  pbss_network->IEs will not include p2p_ie */
 	if (rtw_check_beacon_data(adapter, pbuf,  len) == 1)
-	{
-#ifdef  CONFIG_92D_P2P
-		/* check p2p if enable */
-		if (got_p2p_ie == true)
-		{
-			struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
-			struct wifidirect_info *pwdinfo= &(adapter->wdinfo);
-
-			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-			{
-				DBG_8192D("Enable P2P function for the first time\n");
-				rtw_p2p_enable(adapter, P2P_ROLE_GO);
-				wdev_to_priv(adapter->rtw_wdev)->p2p_enabled = true;
-			}
-			else
-			{
-				del_timer_sync(&pwdinfo->find_phase_timer);
-				del_timer_sync(&pwdinfo->restore_p2p_state_timer);
-				del_timer_sync(&pwdinfo->pre_tx_scan_timer);
-
-				DBG_8192D("enter GO Mode, p2p_ielen=%d\n", p2p_ielen);
-
-				rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
-				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
-				pwdinfo->intent = 15;
-			}
-
-			pwdinfo->operating_channel = pmlmeext->cur_channel;
-
-		}
-#endif /* CONFIG_92D_P2P */
-
 		ret = 0;
-
-	}
 	else
-	{
 		ret = -EINVAL;
-	}
 
 	kfree(pbuf);
-
 	return ret;
 }
 
@@ -2960,24 +2752,13 @@ void rtw_cfg80211_rx_action_p2p(struct r
 	int channel;
 	u8 category, action;
 	u32 flags = 0;		/* FIX ME */
-#ifdef CONFIG_92D_P2P
-	int type;
-#endif
 
 	channel = rtw_get_oper_ch(padapter);
 
 	DBG_8192D("RTW_Rx:cur_ch=%d\n", channel);
-	#ifdef CONFIG_92D_P2P
-	type = rtw_p2p_check_frames(padapter, pmgmt_frame, frame_len, false);
-	if (type >= 0)
-		goto indicate;
-	#endif
 	rtw_action_frame_parse(pmgmt_frame, frame_len, &category, &action);
 	DBG_8192D("RTW_Rx:category(%u), action(%u)\n", category, action);
 
-#ifdef CONFIG_92D_P2P
-indicate:
-#endif
 	if (channel <= RTW_CH_MAX_2G_CHANNEL)
 		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 	else
@@ -2992,30 +2773,13 @@ void rtw_cfg80211_rx_p2p_action_public(s
 	int channel;
 	u8 category, action;
 	u32 flags = 0; /*FIX ME */
-#ifdef CONFIG_92D_P2P
-	int type;
-#endif
 
 	channel = rtw_get_oper_ch(padapter);
 
 	DBG_8192D("RTW_Rx:cur_ch=%d\n", channel);
-	#ifdef CONFIG_92D_P2P
-	type = rtw_p2p_check_frames(padapter, pmgmt_frame, frame_len, false);
-	if (type >= 0) {
-		switch (type) {
-		case P2P_GO_NEGO_CONF:
-		case P2P_PROVISION_DISC_RESP:
-			rtw_clear_scan_deny(padapter);
-		}
-		goto indicate;
-	}
-	#endif
 	rtw_action_frame_parse(pmgmt_frame, frame_len, &category, &action);
 	DBG_8192D("RTW_Rx:category(%u), action(%u)\n", category, action);
 
-#ifdef CONFIG_92D_P2P
-indicate:
-#endif
 	if (channel <= RTW_CH_MAX_2G_CHANNEL)
 		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 	else
@@ -3049,358 +2813,6 @@ void rtw_cfg80211_rx_action(struct rtw_a
 	cfg80211_rx_mgmt(adapter->rtw_wdev, freq, 0, frame, frame_len, flags, GFP_ATOMIC);
 }
 
-#ifdef CONFIG_92D_P2P
-void rtw_cfg80211_issue_p2p_provision_request(struct rtw_adapter *padapter, const u8 *buf, size_t len)
-{
-	__be16	wps_devicepassword_id = 0x0000;
-	uint	wps_devicepassword_id_len = 0;
-	u8	wpsie[255] = { 0x00 }, p2p_ie[255] = { 0x00 };
-	uint	p2p_ielen = 0;
-	uint	wpsielen = 0;
-	u32	devinfo_contentlen = 0;
-	u8	devinfo_content[64] = { 0x00 };
-	u16	capability = 0;
-	uint capability_len = 0;
-	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
-	u8	action = P2P_PUB_ACTION_ACTION;
-	u8	dialogToken = 1;
-	__be32	p2poui = cpu_to_be32(P2POUI);
-	u8	oui_subtype = P2P_PROVISION_DISC_REQ;
-	u32	p2pielen = 0;
-	struct xmit_frame	*pmgntframe;
-	struct pkt_attrib	*pattrib;
-	unsigned char		*pframe;
-	struct ieee80211_hdr	*pwlanhdr;
-	unsigned short		*fctrl;
-	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-	u8 *frame_body = (unsigned char *)(buf + sizeof(struct ieee80211_hdr_3addr));
-	size_t frame_body_len = len - sizeof(struct ieee80211_hdr_3addr);
-
-	DBG_8192D("[%s] In\n", __func__);
-
-	/* prepare for building provision_request frame */
-	memcpy(pwdinfo->tx_prov_disc_info.peerIFAddr, GetAddr1Ptr(buf), ETH_ALEN);
-	memcpy(pwdinfo->tx_prov_disc_info.peerDevAddr, GetAddr1Ptr(buf), ETH_ALEN);
-
-	pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_PUSH_BUTTON;
-
-	rtw_get_wps_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, wpsie, &wpsielen);
-	rtw_get_wps_attr_content(wpsie, wpsielen, WPS_ATTR_DEVICE_PWID, (u8*) &wps_devicepassword_id, &wps_devicepassword_id_len);
-
-	switch (be16_to_cpu(wps_devicepassword_id)) {
-	case WPS_DPID_PIN:
-		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_LABEL;
-		break;
-	case WPS_DPID_USER_SPEC:
-		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_DISPLYA;
-		break;
-	case WPS_DPID_MACHINE_SPEC:
-		break;
-	case WPS_DPID_REKEY:
-		break;
-	case WPS_DPID_PBC:
-		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_PUSH_BUTTON;
-		break;
-	case WPS_DPID_REGISTRAR_SPEC:
-		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_KEYPAD;
-		break;
-	default:
-		break;
-	}
-
-	if (rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, p2p_ie, &p2p_ielen))
-	{
-
-		rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, devinfo_content, &devinfo_contentlen);
-		rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&capability, &capability_len);
-
-	}
-
-	/* start to build provision_request frame */
-	memset(wpsie, 0, sizeof(wpsie));
-	memset(p2p_ie, 0, sizeof(p2p_ie));
-	p2p_ielen = 0;
-
-	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(padapter, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_control);
-	*(fctrl) = 0;
-
-	memcpy(pwlanhdr->addr1, pwdinfo->tx_prov_disc_info.peerDevAddr, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
-	memcpy(pwlanhdr->addr3, pwdinfo->tx_prov_disc_info.peerDevAddr, ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof(struct ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct ieee80211_hdr_3addr);
-
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
-
-	/* build_prov_disc_request_p2p_ie */
-	/*	P2P OUI */
-	p2pielen = 0;
-	p2p_ie[p2pielen++] = 0x50;
-	p2p_ie[p2pielen++] = 0x6F;
-	p2p_ie[p2pielen++] = 0x9A;
-	p2p_ie[p2pielen++] = 0x09;	/*	WFA P2P v1.0 */
-
-	/*	Commented by Albert 20110301 */
-	/*	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes */
-	/*	1. P2P Capability */
-	/*	2. Device Info */
-	/*	3. Group ID (When joining an operating P2P Group) */
-
-	/*	P2P Capability ATTR */
-	/*	Type: */
-	p2p_ie[p2pielen++] = P2P_ATTR_CAPABILITY;
-
-	/*	Length: */
-	RTW_PUT_LE16(p2p_ie + p2pielen, 0x0002);
-	p2pielen += 2;
-
-	/*	Value: */
-	/*	Device Capability Bitmap, 1 byte */
-	/*	Group Capability Bitmap, 1 byte */
-	memcpy(p2p_ie + p2pielen, &capability, 2);
-	p2pielen += 2;
-
-	/*	Device Info ATTR */
-	/*	Type: */
-	p2p_ie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
-
-	/*	Length: */
-	/*	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
-	/*	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
-	RTW_PUT_LE16(p2p_ie + p2pielen, devinfo_contentlen);
-	p2pielen += 2;
-
-	/*	Value: */
-	memcpy(p2p_ie + p2pielen, devinfo_content, devinfo_contentlen);
-	p2pielen += devinfo_contentlen;
-
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2p_ie, &p2p_ielen);
-	pattrib->pktlen += p2p_ielen;
-
-	wpsielen = 0;
-	/*	WPS OUI */
-	*(__be32 *)(wpsie) = cpu_to_be32(WPSOUI);
-	wpsielen += 4;
-
-	/*	WPS version */
-	/*	Type: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
-	wpsielen += 2;
-
-	/*	Length: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
-	wpsielen += 2;
-
-	/*	Value: */
-	wpsie[wpsielen++] = WPS_VERSION_1;	/*	Version 1.0 */
-
-	/*	Config Method */
-	/*	Type: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
-	wpsielen += 2;
-
-	/*	Length: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
-	wpsielen += 2;
-
-	/*	Value: */
-	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(pwdinfo->tx_prov_disc_info.wps_config_method_request);
-	wpsielen += 2;
-
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != 1)
-		DBG_8192D("%s, ack to\n", __func__);
-
-}
-
-static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
-	struct wireless_dev *wdev,
-	struct ieee80211_channel * channel,
-	unsigned int duration, u64 *cookie)
-{
-	s32 err = 0;
-	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
-	u8 remain_ch = (u8) ieee80211_frequency_to_channel(channel->center_freq);
-	u8 ready_on_channel = false;
-
-	DBG_8192D(FUNC_ADPT_FMT" ch:%u duration:%d\n", FUNC_ADPT_ARG(padapter), remain_ch, duration);
-
-	if (pcfg80211_wdinfo->is_ro_ch == true)
-	{
-		DBG_8192D("%s, cancel ro ch timer\n", __func__);
-
-		del_timer_sync(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
-
-#ifdef CONFIG_CONCURRENT_MODE
-                atomic_set(&pwdev_priv->ro_ch_to, 1);
-#endif /* CONFIG_CONCURRENT_MODE */
-
-		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
-	}
-
-	pcfg80211_wdinfo->is_ro_ch = true;
-
-	if (0 == rtw_pwr_wakeup(padapter)) {
-		err = -EFAULT;
-		goto exit;
-	}
-
-	memcpy(&pcfg80211_wdinfo->remain_on_ch_channel, channel, sizeof(struct ieee80211_channel));
-	pcfg80211_wdinfo->remain_on_ch_cookie= *cookie;
-
-	rtw_scan_abort(padapter);
-#ifdef CONFIG_CONCURRENT_MODE
-	if (rtw_buddy_adapter_up(padapter))
-		rtw_scan_abort(padapter->pbuddy_adapter);
-#endif /* CONFIG_CONCURRENT_MODE */
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-		rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
-		wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = true;
-	} else {
-		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
-	}
-
-	rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
-
-	if (duration < 400)
-		duration = duration*3;/* extend from exper. */
-
-#ifdef	CONFIG_CONCURRENT_MODE
-	if (check_buddy_fwstate(padapter, _FW_LINKED) &&
-	    (duration<pwdinfo->ext_listen_interval))
-		duration = duration +	pwdinfo->ext_listen_interval;
-#endif
-
-	pcfg80211_wdinfo->restore_channel = pmlmeext->cur_channel;
-
-	if (rtw_ch_set_search_ch(pmlmeext->channel_set, remain_ch) >= 0) {
-#ifdef	CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED)) {
-			struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
-			struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
-			if (remain_ch != pbuddy_mlmeext->cur_channel) {
-				if (atomic_read(&pwdev_priv->switch_ch_to)==1 ||
-				    (remain_ch != pmlmeext->cur_channel)) {
-					DBG_8192D("%s, issue nulldata pwrbit=1\n", __func__);
-					issue_nulldata(padapter->pbuddy_adapter, NULL, 1, 3, 500);
-
-					atomic_set(&pwdev_priv->switch_ch_to, 0);
-
-					DBG_8192D("%s, set switch ch timer, duration=%d\n", __func__, duration-pwdinfo->ext_listen_interval);
-					_set_timer(&pwdinfo->ap_p2p_switch_timer, duration-pwdinfo->ext_listen_interval);
-				}
-			}
-
-			ready_on_channel = true;
-		} else
-#endif /* CONFIG_CONCURRENT_MODE */
-		if (remain_ch != pmlmeext->cur_channel)
-		{
-			ready_on_channel = true;
-		}
-	} else {
-		DBG_8192D("%s remain_ch:%u not in channel plan!!!!\n", __func__, remain_ch);
-	}
-
-	/* call this after other things have been done */
-#ifdef	CONFIG_CONCURRENT_MODE
-	if (atomic_read(&pwdev_priv->ro_ch_to)==1 ||
-		(remain_ch != pmlmeext->cur_channel))
-	{
-		u8 co_channel = 0xff;
-		atomic_set(&pwdev_priv->ro_ch_to, 0);
-#endif
-
-		if (ready_on_channel == true)
-		{
-			if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
-				pmlmeext->cur_channel = remain_ch;
-
-#ifdef	CONFIG_CONCURRENT_MODE
-			co_channel = rtw_get_oper_ch(padapter);
-
-			if (co_channel !=remain_ch)
-#endif
-				set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-		}
-
-		DBG_8192D("%s, set ro ch timer, duration=%d\n", __func__, duration);
-		_set_timer(&pcfg80211_wdinfo->remain_on_ch_timer, duration);
-
-#ifdef	CONFIG_CONCURRENT_MODE
-	}
-#endif
-
-	cfg80211_ready_on_channel(padapter->rtw_wdev, *cookie, channel, duration, GFP_KERNEL);
-
-	pwdinfo->listen_channel = pmlmeext->cur_channel;
-
-exit:
-	if (err)
-		pcfg80211_wdinfo->is_ro_ch = false;
-
-	return err;
-}
-
-static s32 cfg80211_rtw_cancel_remain_on_channel(struct wiphy *wiphy,
-	struct wireless_dev *wdev,
-	u64 cookie)
-{
-	s32 err = 0;
-	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
-	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
-
-	DBG_8192D(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
-
-	if (pcfg80211_wdinfo->is_ro_ch == true) {
-		DBG_8192D("%s, cancel ro ch timer\n", __func__);
-		del_timer_sync(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
-		#ifdef CONFIG_CONCURRENT_MODE
-		atomic_set(&pwdev_priv->ro_ch_to, 1);
-		#endif
-		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
-	}
-
-	rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
-	pcfg80211_wdinfo->is_ro_ch = false;
-
-	return err;
-}
-
-#endif /* CONFIG_92D_P2P */
-
 static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
 {
 	int ret = 0;
@@ -3412,10 +2824,6 @@ static int rtw_cfg80211_set_beacon_wpsp2
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(ndev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
-#ifdef CONFIG_92D_P2P
-	u32 p2p_ielen = 0;
-	u8 *p2p_ie;
-#endif
 
 	DBG_8192D(FUNC_NDEV_FMT" ielen=%d\n", FUNC_NDEV_ARG(ndev), len);
 
@@ -3441,28 +2849,6 @@ static int rtw_cfg80211_set_beacon_wpsp2
 			update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, true);
 #endif
 		}
-
-		#ifdef CONFIG_92D_P2P
-		if ((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen))) {
-			if (pmlmepriv->p2p_beacon_ie) {
-				pmlmepriv->p2p_beacon_ie_len = 0;
-				kfree(pmlmepriv->p2p_beacon_ie);
-				pmlmepriv->p2p_beacon_ie = NULL;
-			}
-
-			pmlmepriv->p2p_beacon_ie = kmalloc(p2p_ielen, GFP_KERNEL);
-			if (pmlmepriv->p2p_beacon_ie == NULL) {
-				DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
-				return -EINVAL;
-
-			}
-
-			memcpy(pmlmepriv->p2p_beacon_ie, p2p_ie, p2p_ielen);
-			pmlmepriv->p2p_beacon_ie_len = p2p_ielen;
-
-		}
-		#endif /* CONFIG_92D_P2P */
-
 		pmlmeext->bstart_bss = true;
 	}
 	return ret;
@@ -3475,10 +2861,6 @@ static int rtw_cfg80211_set_probe_resp_w
 	int ret = 0;
 	uint wps_ielen = 0;
 	u8 *wps_ie;
-#ifdef CONFIG_92D_P2P
-	u32 p2p_ielen = 0;
-	u8 *p2p_ie;
-#endif
 
 	if (len > 0) {
 		wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen);
@@ -3508,60 +2890,6 @@ static int rtw_cfg80211_set_probe_resp_w
 
 		}
 
-		#ifdef CONFIG_92D_P2P
-		if ((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen))) {
-			u8 is_GO = false;
-			u32 attr_contentlen = 0;
-			__le16 cap_attr = 0;
-
-			/* Check P2P Capability ATTR */
-			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen,
-						     P2P_ATTR_CAPABILITY,
-						     (u8 *)&cap_attr,
-						     (uint *) &attr_contentlen)) {
-				u8 grp_cap;
-				grp_cap = (u8)((le16_to_cpu(cap_attr) >> 8) & 0xff);
-
-				is_GO = (grp_cap&BIT(0)) ? true:false;
-
-				if (is_GO)
-					DBG_8192D("Got P2P Capability Attr, grp_cap=0x%x, is_GO\n", grp_cap);
-			}
-
-			if (is_GO == false) {
-				if (pmlmepriv->p2p_probe_resp_ie) {
-					pmlmepriv->p2p_probe_resp_ie_len = 0;
-					kfree(pmlmepriv->p2p_probe_resp_ie);
-					pmlmepriv->p2p_probe_resp_ie = NULL;
-				}
-
-				pmlmepriv->p2p_probe_resp_ie = kmalloc(p2p_ielen, GFP_KERNEL);
-				if (pmlmepriv->p2p_probe_resp_ie == NULL) {
-					DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
-					return -EINVAL;
-
-				}
-				memcpy(pmlmepriv->p2p_probe_resp_ie, p2p_ie, p2p_ielen);
-				pmlmepriv->p2p_probe_resp_ie_len = p2p_ielen;
-			} else {
-				if (pmlmepriv->p2p_go_probe_resp_ie) {
-					pmlmepriv->p2p_go_probe_resp_ie_len = 0;
-					kfree(pmlmepriv->p2p_go_probe_resp_ie);
-					pmlmepriv->p2p_go_probe_resp_ie = NULL;
-				}
-
-				pmlmepriv->p2p_go_probe_resp_ie = kmalloc(p2p_ielen, GFP_KERNEL);
-				if (pmlmepriv->p2p_go_probe_resp_ie == NULL) {
-					DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
-					return -EINVAL;
-
-				}
-				memcpy(pmlmepriv->p2p_go_probe_resp_ie, p2p_ie, p2p_ielen);
-				pmlmepriv->p2p_go_probe_resp_ie_len = p2p_ielen;
-			}
-
-		}
-		#endif /* CONFIG_92D_P2P */
 	}
 	return ret;
 }
@@ -3601,15 +2929,8 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struc
 {
 	int ret = 0;
 	uint wps_ielen = 0;
-#ifdef CONFIG_92D_P2P
-	u32 p2p_ielen = 0;
-#endif
 
-	if ((rtw_get_wps_ie(buf, len, NULL, &wps_ielen) && (wps_ielen>0))
-		#ifdef CONFIG_92D_P2P
-		|| (rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen) && (p2p_ielen>0))
-		#endif
-	) {
+	if ((rtw_get_wps_ie(buf, len, NULL, &wps_ielen) && (wps_ielen>0))) {
 		if (net != NULL) {
 			switch (type) {
 			case 0x1: /* BEACON */
@@ -3661,11 +2982,6 @@ static struct cfg80211_ops rtw_cfg80211_
 	.dump_station = cfg80211_rtw_dump_station,
 	.change_bss = cfg80211_rtw_change_bss,
 #endif /* CONFIG_92D_AP_MODE */
-
-#ifdef CONFIG_92D_P2P
-	.remain_on_channel = cfg80211_rtw_remain_on_channel,
-	.cancel_remain_on_channel = cfg80211_rtw_cancel_remain_on_channel,
-#endif
 };
 
 static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap, enum ieee80211_band band, u8 rf_type)
@@ -3766,10 +3082,6 @@ static void rtw_cfg80211_preinit_wiphy(s
 				 BIT(NL80211_IFTYPE_AP) |
 				 BIT(NL80211_IFTYPE_MONITOR) |
 #endif
-#if defined(CONFIG_92D_P2P)
-				 BIT(NL80211_IFTYPE_P2P_CLIENT) |
-				 BIT(NL80211_IFTYPE_P2P_GO) |
-#endif
 				 0;
 
 #ifdef CONFIG_92D_AP_MODE
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -114,38 +114,7 @@ static char *translate_scan(struct rtw_a
 	u32 i = 0;
 	u8 bw_40MHz = 0, short_GI = 0;
 	u16 mcs_rate = 0;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
-#endif /* CONFIG_92D_P2P */
 
-#ifdef CONFIG_92D_P2P
-	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-	{
-		u32	blnGotP2PIE = false;
-
-		/*	User is doing the P2P device discovery */
-		/*	The prefix of SSID should be "DIRECT-" and the IE should contains the P2P IE. */
-		/*	If not, the driver should ignore this AP and go to the next AP. */
-
-		/*	Verifying the SSID */
-		if (!memcmp(pnetwork->network.Ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN))
-		{
-			u32	p2pielen = 0;
-
-			/*	Verifying the P2P IE */
-			if (rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen))
-			{
-				blnGotP2PIE = true;
-			}
-		}
-
-		if (blnGotP2PIE == false)
-		{
-			return start;
-		}
-	}
-
-#endif /* CONFIG_92D_P2P */
 	/*  AP MAC address  */
 	iwe.cmd = SIOCGIWAP;
 	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
@@ -401,9 +370,6 @@ static int wpa_set_encryption(struct net
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
-#endif /* CONFIG_92D_P2P */
 
 	param->u.crypt.err = 0;
 	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
@@ -533,11 +499,6 @@ static int wpa_set_encryption(struct net
 					padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
 
 					rtw_set_key(padapter,&padapter->securitypriv, param->u.crypt.idx, 1);
-#ifdef CONFIG_92D_P2P
-					if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
-						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_DONE);
-#endif /* CONFIG_92D_P2P */
-
 				}
 			}
 
@@ -568,9 +529,6 @@ static int rtw_set_wpa_ie(struct rtw_ada
 	int ret = 0;
 	u8	null_addr[]= {0, 0, 0, 0, 0, 0};
 	int i;
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
-#endif /* CONFIG_92D_P2P */
 
 	if ((ielen > MAX_WPA_IE_LEN) || (pie == NULL)) {
 		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
@@ -682,10 +640,6 @@ static int rtw_set_wpa_ie(struct rtw_ada
 					memcpy(padapter->securitypriv.wps_ie, &buf[cnt], padapter->securitypriv.wps_ie_len);
 
 					set_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS);
-#ifdef CONFIG_92D_P2P
-					if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_OK))
-						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_ING);
-#endif /* CONFIG_92D_P2P */
 					cnt += buf[cnt+1]+2;
 
 					break;
@@ -1238,9 +1192,7 @@ static int rtw_wx_set_scan(struct net_de
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct ndis_802_11_ssid ssid[RTW_SSID_SCAN_AMOUNT];
-#ifdef CONFIG_92D_P2P
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-#endif /* CONFIG_92D_P2P */
+
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_set_scan\n"));
 
 	if (0 == rtw_pwr_wakeup(padapter)) {
@@ -1299,19 +1251,6 @@ static int rtw_wx_set_scan(struct net_de
 	}
 #endif
 
-/*	For the DMP WiFi Display project, the driver won't to scan because */
-/*	the pmlmepriv->scan_interval is always equal to 3. */
-/*	So, the wpa_supplicant won't find out the WPS SoftAP. */
-
-#ifdef CONFIG_92D_P2P
-	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
-		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_FULL);
-		rtw_free_network_queue(padapter, true);
-	}
-#endif /* CONFIG_92D_P2P */
-
 	memset(ssid, 0, sizeof(struct ndis_802_11_ssid)*RTW_SSID_SCAN_AMOUNT);
 
 	if (wrqu->data.length == sizeof(struct iw_scan_req)) {
@@ -1410,11 +1349,7 @@ static int rtw_wx_get_scan(struct net_de
 	u32 cnt = 0;
 	u32 wait_for_surveydone;
 	int wait_status;
-#ifdef CONFIG_CONCURRENT_MODE
-#endif
-#ifdef CONFIG_92D_P2P
-	struct	wifidirect_info*	pwdinfo = &padapter->wdinfo;
-#endif /* CONFIG_92D_P2P */
+
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan\n"));
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, (" Start of Query SIOCGIWSCAN .\n"));
 
@@ -1423,25 +1358,7 @@ static int rtw_wx_get_scan(struct net_de
 		goto exit;
 	}
 
-#ifdef CONFIG_92D_P2P
-	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-	{
-		/*	P2P is enabled */
-		if (padapter->chip_type == RTL8192D)
-			wait_for_surveydone = 300;	/*	Because the 8192du supports more channels. */
-		else
-			wait_for_surveydone = 200;
-	}
-	else
-	{
-		/*	P2P is disabled */
-		wait_for_surveydone = 100;
-	}
-#else
-	{
-		wait_for_surveydone = 100;
-	}
-#endif /* CONFIG_92D_P2P */
+	wait_for_surveydone = 100;
 
 	wait_status = _FW_UNDER_SURVEY
 		|_FW_UNDER_LINKING
@@ -2763,1531 +2680,60 @@ static int rtw_wps_start(struct net_devi
 	return ret;
 }
 
-#ifdef CONFIG_92D_P2P
-static int rtw_wext_p2p_enable(struct net_device *dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	enum P2P_ROLE init_role = P2P_ROLE_DISABLE;
-
-	if (*extra == '0')
-		init_role = P2P_ROLE_DISABLE;
-	else if (*extra == '1')
-		init_role = P2P_ROLE_DEVICE;
-	else if (*extra == '2')
-		init_role = P2P_ROLE_CLIENT;
-	else if (*extra == '3')
-		init_role = P2P_ROLE_GO;
-
-	if (0 == rtw_p2p_enable(padapter, init_role))
-	{
-		ret = -EFAULT;
-		goto exit;
-	}
-
-	/* set channel/bandwidth */
-	if (init_role != P2P_ROLE_DISABLE)
-	{
-		u8 channel, ch_offset;
-		u16 bwmode;
-
-		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN))
-		{
-			/*	Stay at the listen state and wait for discovery. */
-			channel = pwdinfo->listen_channel;
-			pwdinfo->operating_channel = pwdinfo->listen_channel;
-			ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
-			bwmode = HT_CHANNEL_WIDTH_20;
-		}
-#ifdef CONFIG_CONCURRENT_MODE
-		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
-		{
-			struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
-			struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
-			struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
-			_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_interval);
-			if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
-			{
-				pwdinfo->operating_channel = pbuddy_mlmeext->cur_channel;
-				/*	How about the ch_offset and bwmode ?? */
-			}
-			else
-			{
-				pwdinfo->operating_channel = pwdinfo->listen_channel;
-			}
-
-			channel = pbuddy_mlmeext->cur_channel;
-			ch_offset = pbuddy_mlmeext->cur_ch_offset;
-			bwmode = pbuddy_mlmeext->cur_bwmode;
-		}
-#endif
-		else
-		{
-			pwdinfo->operating_channel = pmlmeext->cur_channel;
-
-			channel = pwdinfo->operating_channel;
-			ch_offset = pmlmeext->cur_ch_offset;
-			bwmode = pmlmeext->cur_bwmode;
-		}
-
-		set_channel_bwmode(padapter, channel, ch_offset, bwmode);
-	}
-
-exit:
-	return ret;
-}
-
-static int rtw_p2p_set_go_nego_ssid(struct net_device *dev,
-				    struct iw_request_info *info,
-				    union iwreq_data *wrqu, char *extra)
+static int rtw_p2p_set(struct net_device *dev,
+		       struct iw_request_info *info,
+		       union iwreq_data *wrqu, char *extra)
 {
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-
-	DBG_8192D("[%s] ssid = %s, len = %d\n", __func__, extra, (u32)strlen(extra));
-	memcpy(pwdinfo->nego_ssid, extra, strlen(extra));
-	pwdinfo->nego_ssidlen = strlen(extra);
-
 	return 0;
 }
 
-static int rtw_p2p_set_intent(struct net_device *dev,
-			      struct iw_request_info *info,
-			      union iwreq_data *wrqu, char *extra)
+static int rtw_p2p_get(struct net_device *dev,
+		       struct iw_request_info *info,
+		       union iwreq_data *wrqu, char *extra)
 {
-	int	ret = 0;
-	struct rtw_adapter						*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info			*pwdinfo = &(padapter->wdinfo);
-	u8							intent = pwdinfo->intent;
-
-	switch (wrqu->data.length)
-	{
-		case 1:
-		{
-			intent = extra[0] - '0';
-			break;
-		}
-		case 2:
-		{
-			intent = str_2char2num(extra[0], extra[1]);
-			break;
-		}
-	}
-
-	if (intent <= 15)
-	{
-		pwdinfo->intent = intent;
-	}
-	else
-	{
-		ret = -1;
-	}
-
-	DBG_8192D("[%s] intent = %d\n", __func__, intent);
-
-	return ret;
+	return 0;
 }
 
-static int rtw_p2p_set_listen_ch(struct net_device *dev,
-				 struct iw_request_info *info,
-				 union iwreq_data *wrqu, char *extra)
+static int rtw_p2p_get2(struct net_device *dev,
+						struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-	u8	listen_ch = pwdinfo->listen_channel;	/*	Listen channel number */
-
-	switch (wrqu->data.length)
-	{
-		case 1:
-		{
-			listen_ch = extra[0] - '0';
-			break;
-		}
-		case 2:
-		{
-			listen_ch = str_2char2num(extra[0], extra[1]);
-			break;
-		}
-	}
-
-	if ((listen_ch == 1) || (listen_ch == 6) || (listen_ch == 11))
-	{
-		pwdinfo->listen_channel = listen_ch;
-		set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-	}
-	else
-	{
-		ret = -1;
-	}
-
-	DBG_8192D("[%s] listen_ch = %d\n", __func__, pwdinfo->listen_channel);
-
-	return ret;
+	return 0;
 }
 
-static int rtw_p2p_set_op_ch(struct net_device *dev,
+static int rtw_rereg_nd_name(struct net_device *dev,
 			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
-/*	Commented by Albert 20110524 */
-/*	This function is used to set the operating channel if the driver will become the group owner */
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-	u8	op_ch = pwdinfo->operating_channel;	/*	Operating channel number */
-
-	switch (wrqu->data.length)
-	{
-		case 1:
-		{
-			op_ch = extra[0] - '0';
-			break;
-		}
-		case 2:
-		{
-			op_ch = str_2char2num(extra[0], extra[1]);
-			break;
-		}
-	}
-
-	if (op_ch > 0)
-	{
-		pwdinfo->operating_channel = op_ch;
-	}
-	else
-	{
-		ret = -1;
-	}
-
-	DBG_8192D("[%s] op_ch = %d\n", __func__, pwdinfo->operating_channel);
-
-	return ret;
-}
-
-static int rtw_p2p_profilefound(struct net_device *dev,
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-{
 	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-
-	/*	Comment by Albert 2010/10/13 */
-	/*	Input data format: */
-	/*	Ex:  0 */
-	/*	Ex:  1XX:XX:XX:XX:XX:XXYYSSID */
-	/*	0 => Reflush the profile record list. */
-	/*	1 => Add the profile list */
-	/*	XX:XX:XX:XX:XX:XX => peer's MAC Address (ex: 00:E0:4C:00:00:01) */
-	/*	YY => SSID Length */
-	/*	SSID => SSID for persistence group */
-
-	DBG_8192D("[%s] In value = %s, len = %d\n", __func__, extra, wrqu->data.length -1);
+	struct rtw_adapter *padapter = rtw_netdev_priv(dev);
+	struct rereg_nd_name_data *rereg_priv = &padapter->rereg_nd_name_priv;
+	char new_ifname[IFNAMSIZ];
 
-	/*	The upper application should pass the SSID to driver by using this rtw_p2p_profilefound function. */
-	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-	{
-		if (extra[0] == '0')
-		{
-			/*	Remove all the profile information of wifidirect_info structure. */
-			memset(&pwdinfo->profileinfo[0], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
-			pwdinfo->profileindex = 0;
-		}
-		else
-		{
-			if (pwdinfo->profileindex >= P2P_MAX_PERSISTENT_GROUP_NUM)
-		{
-				ret = -1;
-		}
+	if (rereg_priv->old_ifname[0] == 0) {
+		char *reg_ifname;
+#ifdef CONFIG_CONCURRENT_MODE
+		if (padapter->isprimary)
+			reg_ifname = padapter->registrypriv.ifname;
 		else
-		{
-				int jj, kk;
-
-				/*	Add this profile information into pwdinfo->profileinfo */
-				/*	Ex:  1XX:XX:XX:XX:XX:XXYYSSID */
-				for (jj = 0, kk = 1; jj < ETH_ALEN; jj++, kk += 3)
-				{
-					pwdinfo->profileinfo[pwdinfo->profileindex].peermac[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
-				}
+#endif
+		reg_ifname = padapter->registrypriv.if2name;
 
-				pwdinfo->profileindex++;
-			}
-		}
+		strncpy(rereg_priv->old_ifname, reg_ifname, IFNAMSIZ);
+		rereg_priv->old_ifname[IFNAMSIZ-1] = 0;
 	}
+	if (wrqu->data.length > IFNAMSIZ)
+		return -EFAULT;
 
-	return ret;
-}
-
-static int rtw_p2p_setDN(struct net_device *dev,
-			 struct iw_request_info *info,
-			 union iwreq_data *wrqu, char *extra)
-{
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
-	memset(pwdinfo->device_name, 0x00, WPS_MAX_DEVICE_NAME_LEN);
-	memcpy(pwdinfo->device_name, extra, wrqu->data.length - 1);
-	pwdinfo->device_name_len = wrqu->data.length - 1;
-	return 0;
-}
-
-static int rtw_p2p_get_status(struct net_device *dev,
-			      struct iw_request_info *info,
-			      union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	if (padapter->bShowGetP2PState) {
-		DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n",
-			  __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-			  pwdinfo->p2p_peer_interface_addr[0],
-			  pwdinfo->p2p_peer_interface_addr[1],
-			  pwdinfo->p2p_peer_interface_addr[2],
-			  pwdinfo->p2p_peer_interface_addr[3],
-			  pwdinfo->p2p_peer_interface_addr[4],
-			  pwdinfo->p2p_peer_interface_addr[5]);
-	}
-
-	/*	Commented by Albert 2010/10/12 */
-	/*	Because of the output size limitation, I had removed the "Role" information. */
-	/*	About the "Role" information, we will use the new private IOCTL to get the "Role" information. */
-	sprintf(extra, "\n\nStatus =%.2d\n", rtw_p2p_state(pwdinfo));
-	wrqu->data.length = strlen(extra);
-
-	return ret;
-}
-
-/*	Commented by Albert 20110520 */
-/*	This function will return the config method description */
-/*	This config method description will show us which config method the remote P2P device is intented to use */
-/*	by sending the provisioning discovery request frame. */
-
-static int rtw_p2p_get_req_cm(struct net_device *dev,
-			      struct iw_request_info *info,
-			      union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	sprintf(extra, "\n\nCM =%s\n", pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req);
-	wrqu->data.length = strlen(extra);
-	return ret;
-}
-
-static int rtw_p2p_get_role(struct net_device *dev,
-			    struct iw_request_info *info,
-			    union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n",
-		  __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-		  pwdinfo->p2p_peer_interface_addr[0],
-		  pwdinfo->p2p_peer_interface_addr[1],
-		  pwdinfo->p2p_peer_interface_addr[2],
-		  pwdinfo->p2p_peer_interface_addr[3],
-		  pwdinfo->p2p_peer_interface_addr[4],
-		  pwdinfo->p2p_peer_interface_addr[5]);
-
-	sprintf(extra, "\n\nRole =%.2d\n", rtw_p2p_role(pwdinfo));
-	wrqu->data.length = strlen(extra);
-	return ret;
-}
-
-static int rtw_p2p_get_peer_ifaddr(struct net_device *dev,
-				   struct iw_request_info *info,
-				   union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-			pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
-			pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
-
-	sprintf(extra, "\nMAC %.2X:%.2X:%.2X:%.2X:%.2X:%.2X",
-			pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1], pwdinfo->p2p_peer_interface_addr[2],
-			pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
-	wrqu->data.length = strlen(extra);
-	return ret;
-}
-
-static int rtw_p2p_get_peer_devaddr(struct net_device *dev,
-				    struct iw_request_info *info,
-				    union iwreq_data *wrqu, char *extra)
-
-{
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-			pwdinfo->rx_prov_disc_info.peerDevAddr[0], pwdinfo->rx_prov_disc_info.peerDevAddr[1],
-			pwdinfo->rx_prov_disc_info.peerDevAddr[2], pwdinfo->rx_prov_disc_info.peerDevAddr[3],
-			pwdinfo->rx_prov_disc_info.peerDevAddr[4], pwdinfo->rx_prov_disc_info.peerDevAddr[5]);
-	sprintf(extra, "\n%.2X%.2X%.2X%.2X%.2X%.2X",
-			pwdinfo->rx_prov_disc_info.peerDevAddr[0], pwdinfo->rx_prov_disc_info.peerDevAddr[1],
-			pwdinfo->rx_prov_disc_info.peerDevAddr[2], pwdinfo->rx_prov_disc_info.peerDevAddr[3],
-			pwdinfo->rx_prov_disc_info.peerDevAddr[4], pwdinfo->rx_prov_disc_info.peerDevAddr[5]);
-	wrqu->data.length = strlen(extra);
-	return ret;
-}
-
-static int rtw_p2p_get_peer_devaddr_by_invitation(struct net_device *dev,
-						  struct iw_request_info *info,
-						  union iwreq_data *wrqu, char *extra)
-{
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	DBG_8192D("[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-			pwdinfo->p2p_peer_device_addr[0], pwdinfo->p2p_peer_device_addr[1],
-			pwdinfo->p2p_peer_device_addr[2], pwdinfo->p2p_peer_device_addr[3],
-			pwdinfo->p2p_peer_device_addr[4], pwdinfo->p2p_peer_device_addr[5]);
-	sprintf(extra, "\nMAC %.2X:%.2X:%.2X:%.2X:%.2X:%.2X",
-			pwdinfo->p2p_peer_device_addr[0], pwdinfo->p2p_peer_device_addr[1],
-			pwdinfo->p2p_peer_device_addr[2], pwdinfo->p2p_peer_device_addr[3],
-			pwdinfo->p2p_peer_device_addr[4], pwdinfo->p2p_peer_device_addr[5]);
-	wrqu->data.length = strlen(extra);
-	return 0;
-}
+	if (copy_from_user(new_ifname, wrqu->data.pointer, IFNAMSIZ))
+		return -EFAULT;
 
-static int rtw_p2p_get_groupid(struct net_device *dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *wrqu, char *extra)
-
-{
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	sprintf(extra, "\n%pM %s",
-		pwdinfo->groupid_info.go_device_addr,
-		pwdinfo->groupid_info.ssid);
-	wrqu->data.length = strlen(extra);
-	return 0;
-}
-
-static int rtw_p2p_get_op_ch(struct net_device *dev,
-			     struct iw_request_info *info,
-			     union iwreq_data *wrqu, char *extra)
-{
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	DBG_8192D("[%s] Op_ch = %02x\n", __func__, pwdinfo->operating_channel);
-
-	sprintf(extra, "\n\nOp_ch =%.2d\n", pwdinfo->operating_channel);
-	wrqu->data.length = strlen(extra);
-	return 0;
-}
-
-inline static void macstr2num(u8 *dst, u8 *src)
-{
-	int	jj, kk;
-	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
-	{
-		dst[jj] = key_2char2num(src[kk], src[kk + 1]);
-	}
-}
-
-static int rtw_p2p_get_wps_configmethod(struct net_device *dev,
-					struct iw_request_info *info,
-					union iwreq_data *wrqu, char *extra, char *subcmd)
-{
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	u8 peerMAC[ETH_ALEN] = { 0x00 };
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct list_head *plist, *phead;
-	struct __queue *queue = &(pmlmepriv->scanned_queue);
-	struct wlan_network *pnetwork = NULL;
-	u8 blnMatch = 0;
-	__be16	attr_content = 0;
-	u16 c_attr_content;
-	uint attr_contentlen = 0;
-	u8	attr_content_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
-
-	/*	Commented by Albert 20110727 */
-	/*	The input data is the MAC address which the application wants to know its WPS config method. */
-	/*	After knowing its WPS config method, the application can decide the config method for provisioning discovery. */
-	/*	Format: iwpriv wlanx p2p_get_wpsCM 00:E0:4C:00:00:05 */
-
-	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
-
-	macstr2num(peerMAC, subcmd);
-
-	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	phead = get_list_head(queue);
-	plist = phead->next;
-
-	while (1)
-	{
-		if (rtw_end_of_queue_search(phead, plist) == true) break;
-
-		pnetwork = container_of(plist, struct wlan_network, list);
-		if (!memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
-		{
-			u8 *wpsie;
-			uint	wpsie_len = 0;
-
-			/*	The mac address is matched. */
-
-			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
-			{
-				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_CONF_METHOD, (u8 *)&attr_content, &attr_contentlen);
-				if (attr_contentlen) {
-					c_attr_content = be16_to_cpu(attr_content);
-					sprintf(attr_content_str, "\n\nM =%.4d", c_attr_content);
-					blnMatch = 1;
-				}
-			}
-			break;
-		}
-
-		plist = plist->next;
-
-	}
-
-	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	if (!blnMatch)
-	{
-		sprintf(attr_content_str, "\n\nM = 0000");
-	}
-
-	wrqu->data.length = strlen(attr_content_str);
-	memcpy(extra, attr_content_str, wrqu->data.length);
-
-	return ret;
-}
-
-static int rtw_p2p_get_go_device_address(struct net_device *dev,
-					 struct iw_request_info *info,
-					 union iwreq_data *wrqu, char *extra, char *subcmd)
-{
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	u8 peerMAC[ETH_ALEN] = { 0x00 };
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct list_head *plist, *phead;
-	struct __queue *queue = &(pmlmepriv->scanned_queue);
-	struct wlan_network *pnetwork = NULL;
-	u8 blnMatch = 0;
-	u8 *p2pie;
-	uint p2pielen = 0, attr_contentlen = 0;
-	u8 attr_content[100] = { 0x00 };
-	u8 go_devadd_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
-
-	/*	Commented by Albert 20121209 */
-	/*	The input data is the GO's interface address which the application wants to know its device address. */
-	/*	Format: iwpriv wlanx p2p_get2 go_devadd = 00:E0:4C:00:00:05 */
-
-	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
-
-	macstr2num(peerMAC, subcmd);
-
-	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	phead = get_list_head(queue);
-	plist = phead->next;
-
-	while (1)
-	{
-		if (rtw_end_of_queue_search(phead, plist) == true) break;
-
-		pnetwork = container_of(plist, struct wlan_network, list);
-		if (!memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
-		{
-			/*	Commented by Albert 2011/05/18 */
-			/*	Match the device address located in the P2P IE */
-			/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
-
-			if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
-			{
-				while (p2pie)
-				{
-					/*	The P2P Device ID attribute is included in the Beacon frame. */
-					/*	The P2P Device Info attribute is included in the probe response frame. */
-
-					memset(attr_content, 0x00, 100);
-					if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
-					{
-						/*	Handle the P2P Device ID attribute of Beacon first */
-						blnMatch = 1;
-						break;
-
-					} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
-					{
-						/*	Handle the P2P Device Info attribute of probe response */
-						blnMatch = 1;
-						break;
-					}
-
-					/* Get the next P2P IE */
-					p2pie = rtw_get_p2p_ie(p2pie + p2pielen, pnetwork->network.IELength - 12 - (p2pie - &pnetwork->network.IEs[12] + p2pielen), NULL, &p2pielen);
-				}
-			}
-		}
-
-		plist = plist->next;
-
-	}
-
-	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	if (!blnMatch)
-	{
-		sprintf(go_devadd_str, "\n\ndev_add = NULL");
-	} else
-	{
-		sprintf(go_devadd_str, "\n\ndev_add =%.2X:%.2X:%.2X:%.2X:%.2X:%.2X",
-				attr_content[0], attr_content[1], attr_content[2], attr_content[3], attr_content[4], attr_content[5]);
-	}
-
-	wrqu->data.length = strlen(go_devadd_str);
-	memcpy(extra, go_devadd_str, wrqu->data.length);
-
-	return ret;
-}
-
-static int rtw_p2p_get_device_type(struct net_device *dev,
-				   struct iw_request_info *info,
-				   union iwreq_data *wrqu, char *extra, char *subcmd)
-{
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	u8 peerMAC[ETH_ALEN] = { 0x00 };
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct list_head *plist, *phead;
-	struct __queue *queue = &(pmlmepriv->scanned_queue);
-	struct wlan_network *pnetwork = NULL;
-	u8 blnMatch = 0;
-	u8 dev_type[8] = { 0x00 };
-	uint dev_type_len = 0;
-	u8 dev_type_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };    /*  +9 is for the str "dev_type =", we have to clear it at wrqu->data.pointer */
-
-	/*	Commented by Albert 20121209 */
-	/*	The input data is the MAC address which the application wants to know its device type. */
-	/*	Such user interface could know the device type. */
-	/*	Format: iwpriv wlanx p2p_get2 dev_type = 00:E0:4C:00:00:05 */
-
-	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
-
-	macstr2num(peerMAC, subcmd);
-
-	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	phead = get_list_head(queue);
-	plist = phead->next;
-
-	while (1)
-	{
-		if (rtw_end_of_queue_search(phead, plist) == true) break;
-
-		pnetwork = container_of(plist, struct wlan_network, list);
-		if (!memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
-		{
-			u8 *wpsie;
-			uint	wpsie_len = 0;
-
-			/*	The mac address is matched. */
-
-			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
-			{
-				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_PRIMARY_DEV_TYPE, dev_type, &dev_type_len);
-				if (dev_type_len)
-				{
-					__be16 type;
-
-					memcpy(&type, dev_type, 2);
-					sprintf(dev_type_str, "\n\nN =%.2d", be16_to_cpu(type));
-					blnMatch = 1;
-				}
-			}
-			break;
-		}
-
-		plist = plist->next;
-
-	}
-
-	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	if (!blnMatch)
-	{
-		sprintf(dev_type_str, "\n\nN = 00");
-	}
-
-	wrqu->data.length = strlen(dev_type_str);
-	memcpy(extra, dev_type_str, wrqu->data.length);
-
-	return ret;
-}
-
-static int rtw_p2p_get_device_name(struct net_device *dev,
-								   struct iw_request_info *info,
-								   union iwreq_data *wrqu, char *extra, char *subcmd)
-{
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	u8 peerMAC[ETH_ALEN] = { 0x00 };
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct list_head *plist, *phead;
-	struct __queue *queue = &(pmlmepriv->scanned_queue);
-	struct wlan_network *pnetwork = NULL;
-	u8 blnMatch = 0;
-	u8 dev_name[WPS_MAX_DEVICE_NAME_LEN] = { 0x00 };
-	uint dev_len = 0;
-	u8 dev_name_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
-
-	/*	Commented by Albert 20121225 */
-	/*	The input data is the MAC address which the application wants to know its device name. */
-	/*	Such user interface could show peer device's device name instead of ssid. */
-	/*	Format: iwpriv wlanx p2p_get2 devN = 00:E0:4C:00:00:05 */
-
-	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
-
-	macstr2num(peerMAC, subcmd);
-
-	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	phead = get_list_head(queue);
-	plist = phead->next;
-
-	while (1)
-	{
-		if (rtw_end_of_queue_search(phead, plist) == true) break;
-
-		pnetwork = container_of(plist, struct wlan_network, list);
-		if (!memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
-		{
-			u8 *wpsie;
-			uint	wpsie_len = 0;
-
-			/*	The mac address is matched. */
-
-			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
-			{
-				rtw_get_wps_attr_content(wpsie, wpsie_len, WPS_ATTR_DEVICE_NAME, dev_name, &dev_len);
-				if (dev_len)
-				{
-					sprintf(dev_name_str, "\n\nN =%s", dev_name);
-					blnMatch = 1;
-				}
-			}
-			break;
-		}
-
-		plist = plist->next;
-
-	}
-
-	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	if (!blnMatch)
-	{
-		sprintf(dev_name_str, "\n\nN = 0000");
-	}
-
-	wrqu->data.length = strlen(dev_name_str);
-	memcpy(extra, dev_name_str, wrqu->data.length);
-
-	return ret;
-}
-
-static int rtw_p2p_get_invitation_procedure(struct net_device *dev,
-											struct iw_request_info *info,
-											union iwreq_data *wrqu, char *extra, char *subcmd)
-{
-
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	u8 peerMAC[ETH_ALEN] = { 0x00 };
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct list_head *plist, *phead;
-	struct __queue *queue	= &(pmlmepriv->scanned_queue);
-	struct wlan_network *pnetwork = NULL;
-	u8 blnMatch = 0;
-	u8 *p2pie;
-	uint p2pielen = 0, attr_contentlen = 0;
-	u8 attr_content[2] = { 0x00 };
-	u8 inv_proc_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
-
-	/*	Commented by Ouden 20121226 */
-	/*	The application wants to know P2P initation procedure is support or not. */
-	/*	Format: iwpriv wlanx p2p_get2 InvProc = 00:E0:4C:00:00:05 */
-
-	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
-
-	macstr2num(peerMAC, subcmd);
-
-	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	phead = get_list_head(queue);
-	plist = phead->next;
-
-	while (1)
-	{
-		if (rtw_end_of_queue_search(phead, plist) == true) break;
-
-		pnetwork = container_of(plist, struct wlan_network, list);
-		if (!memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
-		{
-			/*	Commented by Albert 20121226 */
-			/*	Match the device address located in the P2P IE */
-			/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
-
-			if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
-			{
-				while (p2pie)
-				{
-					if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_CAPABILITY, attr_content, &attr_contentlen))
-					{
-						/*	Handle the P2P capability attribute */
-						blnMatch = 1;
-						break;
-
-					}
-
-					/* Get the next P2P IE */
-					p2pie = rtw_get_p2p_ie(p2pie + p2pielen, pnetwork->network.IELength - 12 - (p2pie - &pnetwork->network.IEs[12] + p2pielen), NULL, &p2pielen);
-				}
-			}
-		}
-
-		plist = plist->next;
-
-	}
-
-	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	if (!blnMatch)
-	{
-		sprintf(inv_proc_str, "\nIP =-1");
-	} else
-	{
-		if (attr_content[0] & 0x20)
-		{
-			sprintf(inv_proc_str, "\nIP = 1");
-		} else
-		{
-			sprintf(inv_proc_str, "\nIP = 0");
-		}
-	}
-
-	wrqu->data.length = strlen(inv_proc_str);
-	memcpy(extra, inv_proc_str, wrqu->data.length);
-
-	return ret;
-}
-
-static int rtw_p2p_connect(struct net_device *dev,
-			   struct iw_request_info *info,
-			   union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-	struct rtw_adapter				*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	u8					peerMAC[ETH_ALEN] = { 0x00 };
-	int					jj, kk;
-	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-	struct list_head *plist, *phead;
-	struct __queue *queue	= &(pmlmepriv->scanned_queue);
-	struct	wlan_network	*pnetwork = NULL;
-	uint					uintPeerChannel = 0;
-#ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
-	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-	/*	Commented by Albert 20110304 */
-	/*	The input data contains two informations. */
-	/*	1. First information is the MAC address which wants to formate with */
-	/*	2. Second information is the WPS PINCode or "pbc" string for push button method */
-	/*	Format: 00:E0:4C:00:00:05 */
-	/*	Format: 00:E0:4C:00:00:05 */
-
-	DBG_8192D("[%s] data = %s\n", __func__, extra);
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-	{
-		DBG_8192D("[%s] WiFi Direct is disable!\n", __func__);
-		return ret;
-	}
-
-	if (pwdinfo->ui_got_wps_info == P2P_NO_WPSINFO)
-	{
-		return -1;
-	}
-
-	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
-	{
-		peerMAC[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
-	}
-
-	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	phead = get_list_head(queue);
-	plist = phead->next;
-
-	while (1)
-	{
-		if (rtw_end_of_queue_search(phead, plist) == true)
-			break;
-
-		pnetwork = container_of(plist, struct wlan_network, list);
-		if (!memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN)) {
-			uintPeerChannel = pnetwork->network.Configuration.DSConfig;
-			break;
-		}
-
-		plist = plist->next;
-
-	}
-
-	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	if (uintPeerChannel)
-	{
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED))
-		{
-			del_timer_sync(&pwdinfo->ap_p2p_switch_timer);
-		}
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-		memset(&pwdinfo->nego_req_info, 0x00, sizeof(struct tx_nego_req_info));
-		memset(&pwdinfo->groupid_info, 0x00, sizeof(struct group_id_info));
-
-		pwdinfo->nego_req_info.peer_channel_num[0] = uintPeerChannel;
-		memcpy(pwdinfo->nego_req_info.peerDevAddr, pnetwork->network.MacAddress, ETH_ALEN);
-		pwdinfo->nego_req_info.benable = true;
-
-		del_timer_sync(&pwdinfo->restore_p2p_state_timer);
-		if (rtw_p2p_state(pwdinfo) != P2P_STATE_GONEGO_OK) {
-			/*	Restore to the listen state if the current p2p state is not nego OK */
-			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
-		}
-
-		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);
-
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED)) {
-			/*	Have to enter the power saving with the AP */
-			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel,
-					   pbuddy_mlmeext->cur_ch_offset,
-					   pbuddy_mlmeext->cur_bwmode);
-
-			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
-		}
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-		DBG_8192D("[%s] Start PreTx Procedure!\n", __func__);
-		_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
-
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED))
-			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_GO_NEGO_TIMEOUT);
-		else
-			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_GO_NEGO_TIMEOUT);
-#else
-		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_GO_NEGO_TIMEOUT);
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-	} else {
-		DBG_8192D("[%s] Not Found in Scanning Queue~\n", __func__);
-		ret = -1;
-	}
-	return ret;
-}
-
-static int rtw_p2p_invite_req(struct net_device *dev,
-			      struct iw_request_info *info,
-			      union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-	int jj, kk;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct list_head *plist, *phead;
-	struct __queue *queue = &(pmlmepriv->scanned_queue);
-	struct	wlan_network		*pnetwork = NULL;
-	uint uintPeerChannel = 0;
-	u8 attr_content[50] = { 0x00 };
-	u8 *p2pie;
-	uint p2pielen = 0, attr_contentlen = 0;
-	struct tx_invite_req_info *pinvite_req_info = &pwdinfo->invitereq_info;
-#ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter					*pbuddy_adapter = padapter->pbuddy_adapter;
-	struct mlme_priv			*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
-	struct mlme_ext_priv		*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-	/*	The input data contains two informations. */
-	/*	1. First information is the P2P device address which you want to send to. */
-	/*	2. Second information is the group id which combines with GO's mac address, space and GO's ssid. */
-	/*	Command line sample: iwpriv wlan0 p2p_set invite ="00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy" */
-	/*	Format: 00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy */
-
-	DBG_8192D("[%s] data = %s\n", __func__, extra);
-
-	if (wrqu->data.length <=  37) {
-		DBG_8192D("[%s] Wrong format!\n", __func__);
-		return ret;
-	}
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-		DBG_8192D("[%s] WiFi Direct is disable!\n", __func__);
-		return ret;
-	} else {
-		/*	Reset the content of struct tx_invite_req_info */
-		pinvite_req_info->benable = false;
-		memset(pinvite_req_info->go_bssid, 0x00, ETH_ALEN);
-		memset(pinvite_req_info->go_ssid, 0x00, WLAN_SSID_MAXLEN);
-		pinvite_req_info->ssidlen = 0x00;
-		pinvite_req_info->operating_ch = pwdinfo->operating_channel;
-		memset(pinvite_req_info->peer_macaddr, 0x00, ETH_ALEN);
-		pinvite_req_info->token = 3;
-	}
-
-	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
-		pinvite_req_info->peer_macaddr[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
-
-	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	phead = get_list_head(queue);
-	plist = phead->next;
-
-	while (1) {
-		if (rtw_end_of_queue_search(phead, plist) == true)
-			break;
-
-		pnetwork = container_of(plist, struct wlan_network, list);
-
-		/*	Match the device address located in the P2P IE */
-		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
-
-		if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen))) {
-			/*	The P2P Device ID attribute is included in the Beacon frame. */
-			/*	The P2P Device Info attribute is included in the probe response frame. */
-
-			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen)) {
-				/*	Handle the P2P Device ID attribute of Beacon first */
-				if (!memcmp(attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN)) {
-					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
-					break;
-				}
-			} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen)) {
-				/*	Handle the P2P Device Info attribute of probe response */
-				if (!memcmp(attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN)) {
-					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
-					break;
-				}
-			}
-		}
-		plist = plist->next;
-	}
-
-	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	if (uintPeerChannel) {
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
-			del_timer_sync(&pwdinfo->ap_p2p_switch_timer);
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-		/*	Store the GO's bssid */
-		for (jj = 0, kk = 18; jj < ETH_ALEN; jj++, kk += 3)
-			pinvite_req_info->go_bssid[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
-
-		/*	Store the GO's ssid */
-		pinvite_req_info->ssidlen = wrqu->data.length - 36;
-		memcpy(pinvite_req_info->go_ssid, &extra[36], (u32) pinvite_req_info->ssidlen);
-		pinvite_req_info->benable = true;
-		pinvite_req_info->peer_ch = uintPeerChannel;
-
-		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_INVITE_REQ);
-
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) {
-			/*	Have to enter the power saving with the AP */
-			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-
-			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
-		} else {
-			set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-		}
-#else
-		set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-#endif
-		_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
-
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
-			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_INVITE_TIMEOUT);
-		else
-			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT);
-#else
-		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT);
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-	} else {
-		DBG_8192D("[%s] NOT Found in the Scanning Queue!\n", __func__);
-	}
-	return ret;
-}
-
-static int rtw_p2p_set_persistent(struct net_device *dev,
-				  struct iw_request_info *info,
-				  union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
-#ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
-	struct mlme_priv *pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
-	struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-	/*	The input data is 0 or 1 */
-	/*	0: disable persistent group functionality */
-	/*	1: enable persistent group founctionality */
-
-	DBG_8192D("[%s] data = %s\n", __func__, extra);
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-		DBG_8192D("[%s] WiFi Direct is disable!\n", __func__);
-		return ret;
-	} else {
-		if (extra[0] == '0')	/*	Disable the persistent group function. */
-			pwdinfo->persistent_supported = false;
-		else if (extra[0] == '1')	/*	Enable the persistent group function. */
-			pwdinfo->persistent_supported = true;
-		else
-			pwdinfo->persistent_supported = false;
-	}
-	DBG_8192D("[%s] persistent_supported = %d\n", __func__, pwdinfo->persistent_supported);
-	return ret;
-}
-
-static int rtw_p2p_prov_disc(struct net_device *dev,
-			     struct iw_request_info *info,
-			     union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-	u8 peerMAC[ETH_ALEN] = { 0x00 };
-	int jj, kk;
-	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-	struct list_head *plist, *phead;
-	struct __queue *queue = &(pmlmepriv->scanned_queue);
-	struct	wlan_network	*pnetwork = NULL;
-	uint uintPeerChannel = 0;
-	u8 attr_content[100] = { 0x00 };
-	u8 *p2pie;
-	uint p2pielen = 0, attr_contentlen = 0;
-#ifdef CONFIG_CONCURRENT_MODE
-	struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
-	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-	/*	Commented by Albert 20110301 */
-	/*	The input data contains two informations. */
-	/*	1. First information is the MAC address which wants to issue the provisioning discovery request frame. */
-	/*	2. Second information is the WPS configuration method which wants to discovery */
-	/*	Format: 00:E0:4C:00:00:05_display */
-	/*	Format: 00:E0:4C:00:00:05_keypad */
-	/*	Format: 00:E0:4C:00:00:05_pbc */
-	/*	Format: 00:E0:4C:00:00:05_label */
-
-	DBG_8192D("[%s] data = %s\n", __func__, extra);
-
-	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) {
-		DBG_8192D("[%s] WiFi Direct is disable!\n", __func__);
-		return ret;
-	} else {
-		/*	Reset the content of struct tx_provdisc_req_info excluded the wps_config_method_request. */
-		memset(pwdinfo->tx_prov_disc_info.peerDevAddr, 0x00, ETH_ALEN);
-		memset(pwdinfo->tx_prov_disc_info.peerIFAddr, 0x00, ETH_ALEN);
-		memset(&pwdinfo->tx_prov_disc_info.ssid, 0x00, sizeof(struct ndis_802_11_ssid));
-		pwdinfo->tx_prov_disc_info.peer_channel_num[0] = 0;
-		pwdinfo->tx_prov_disc_info.peer_channel_num[1] = 0;
-		pwdinfo->tx_prov_disc_info.benable = false;
-	}
-
-	for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
-		peerMAC[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
-
-	if (!memcmp(&extra[18], "display", 7)) {
-		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_DISPLYA;
-	} else if (!memcmp(&extra[18], "keypad", 7)) {
-		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_KEYPAD;
-	} else if (!memcmp(&extra[18], "pbc", 3)) {
-		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_PUSH_BUTTON;
-	} else if (!memcmp(&extra[18], "label", 5)) {
-		pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_LABEL;
-	} else {
-		DBG_8192D("[%s] Unknown WPS config methodn", __func__);
-		return ret;
-	}
-
-	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	phead = get_list_head(queue);
-	plist = phead->next;
-
-	while (1) {
-		if (rtw_end_of_queue_search(phead, plist) == true)
-			break;
-
-		if (uintPeerChannel != 0)
-			break;
-
-		pnetwork = container_of(plist, struct wlan_network, list);
-
-		/*	Commented by Albert 2011/05/18 */
-		/*	Match the device address located in the P2P IE */
-		/*	This is for the case that the P2P device address is not the same as the P2P interface address. */
-
-		if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen))) {
-			while (p2pie) {
-				/*	The P2P Device ID attribute is included in the Beacon frame. */
-				/*	The P2P Device Info attribute is included in the probe response frame. */
-
-				if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen)) {
-					/*	Handle the P2P Device ID attribute of Beacon first */
-					if (!memcmp(attr_content, peerMAC, ETH_ALEN)) {
-						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
-						break;
-					}
-				} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen)) {
-					/*	Handle the P2P Device Info attribute of probe response */
-					if (!memcmp(attr_content, peerMAC, ETH_ALEN)) {
-						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
-						break;
-					}
-				}
-
-				/* Get the next P2P IE */
-				p2pie = rtw_get_p2p_ie(p2pie+p2pielen, pnetwork->network.IELength - 12 -(p2pie -&pnetwork->network.IEs[12] + p2pielen), NULL, &p2pielen);
-			}
-		}
-		plist = plist->next;
-	}
-
-	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-
-	if (uintPeerChannel) {
-		DBG_8192D("[%s] peer channel: %d!\n", __func__, uintPeerChannel);
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED))
-			del_timer_sync(&pwdinfo->ap_p2p_switch_timer);
-#endif /*  CONFIG_CONCURRENT_MODE */
-		memcpy(pwdinfo->tx_prov_disc_info.peerIFAddr, pnetwork->network.MacAddress, ETH_ALEN);
-		memcpy(pwdinfo->tx_prov_disc_info.peerDevAddr, peerMAC, ETH_ALEN);
-		pwdinfo->tx_prov_disc_info.peer_channel_num[0] = (u16) uintPeerChannel;
-		pwdinfo->tx_prov_disc_info.benable = true;
-		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
-		rtw_p2p_set_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ);
-
-		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT)) {
-			memcpy(&pwdinfo->tx_prov_disc_info.ssid, &pnetwork->network.Ssid, sizeof(struct ndis_802_11_ssid));
-		} else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
-			memcpy(pwdinfo->tx_prov_disc_info.ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN);
-			pwdinfo->tx_prov_disc_info.ssid.SsidLength = P2P_WILDCARD_SSID_LEN;
-		}
-
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED)) {
-			/*	Have to enter the power saving with the AP */
-			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-
-			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
-		} else {
-			set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-		}
-#else
-		set_channel_bwmode(padapter, uintPeerChannel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-#endif
-
-		_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
-
-#ifdef CONFIG_CONCURRENT_MODE
-		if (check_buddy_fwstate(padapter, _FW_LINKED))
-			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_CONCURRENT_PROVISION_TIMEOUT);
-		else
-			_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
-#else
-		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
-#endif /*  CONFIG_CONCURRENT_MODE */
-
-	} else {
-		DBG_8192D("[%s] NOT Found in the Scanning Queue!\n", __func__);
-	}
-	return ret;
-}
-
-/*	Added by Albert 20110328 */
-/*	This function is used to inform the driver the user had specified the pin code value or pbc */
-/*	to application. */
-
-static int rtw_p2p_got_wpsinfo(struct net_device *dev,
-			       struct iw_request_info *info,
-			       union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-	struct rtw_adapter				*padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-
-	DBG_8192D("[%s] data = %s\n", __func__, extra);
-	/*	Added by Albert 20110328 */
-	/*	if the input data is P2P_NO_WPSINFO -> reset the wpsinfo */
-	/*	if the input data is P2P_GOT_WPSINFO_PEER_DISPLAY_PIN -> the utility just input the PIN code got from the peer P2P device. */
-	/*	if the input data is P2P_GOT_WPSINFO_SELF_DISPLAY_PIN -> the utility just got the PIN code from itself. */
-	/*	if the input data is P2P_GOT_WPSINFO_PBC -> the utility just determine to use the PBC */
-
-	if (*extra == '0')
-	{
-		pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
-	}
-	else if (*extra == '1')
-	{
-		pwdinfo->ui_got_wps_info = P2P_GOT_WPSINFO_PEER_DISPLAY_PIN;
-	}
-	else if (*extra == '2')
-	{
-		pwdinfo->ui_got_wps_info = P2P_GOT_WPSINFO_SELF_DISPLAY_PIN;
-	}
-	else if (*extra == '3')
-	{
-		pwdinfo->ui_got_wps_info = P2P_GOT_WPSINFO_PBC;
-	}
-	else
-	{
-		pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
-	}
-
-	return ret;
-}
-
-#endif /* CONFIG_92D_P2P */
-
-static int rtw_p2p_set(struct net_device *dev,
-		       struct iw_request_info *info,
-		       union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-#ifdef CONFIG_92D_P2P
-
-	DBG_8192D("[%s] extra = %s\n", __func__, extra);
-
-	if (!memcmp(extra, "enable =", 7)) {
-		rtw_wext_p2p_enable(dev, info, wrqu, &extra[7]);
-	} else if (!memcmp(extra, "setDN=", 6)) {
-		wrqu->data.length -= 6;
-		rtw_p2p_setDN(dev, info, wrqu, &extra[6]);
-	} else if (!memcmp(extra, "profilefound=", 13)) {
-		wrqu->data.length -= 13;
-		rtw_p2p_profilefound(dev, info, wrqu, &extra[13]);
-	} else if (!memcmp(extra, "prov_disc=", 10)) {
-		wrqu->data.length -= 10;
-		rtw_p2p_prov_disc(dev, info, wrqu, &extra[10]);
-	} else if (!memcmp(extra, "nego=", 5)) {
-		wrqu->data.length -= 5;
-		rtw_p2p_connect(dev, info, wrqu, &extra[5]);
-	} else if (!memcmp(extra, "intent=", 7)) {
-		/*	The wrqu->data.length will include the null character */
-		/*	So, we will decrease 7 + 1 */
-		wrqu->data.length -= 8;
-		rtw_p2p_set_intent(dev, info, wrqu, &extra[7]);
-	} else if (!memcmp(extra, "ssid=", 5)) {
-		wrqu->data.length -= 5;
-		rtw_p2p_set_go_nego_ssid(dev, info, wrqu, &extra[5]);
-	} else if (!memcmp(extra, "got_wpsinfo=", 12)) {
-		wrqu->data.length -= 12;
-		rtw_p2p_got_wpsinfo(dev, info, wrqu, &extra[12]);
-	} else if (!memcmp(extra, "listen_ch=", 10)) {
-		/*	The wrqu->data.length will include the null character */
-		/*	So, we will decrease (10 + 1) */
-		wrqu->data.length -= 11;
-		rtw_p2p_set_listen_ch(dev, info, wrqu, &extra[10]);
-	} else if (!memcmp(extra, "op_ch=", 6)) {
-		/*	The wrqu->data.length will include the null character */
-		/*	So, we will decrease (6 + 1) */
-		wrqu->data.length -= 7;
-		rtw_p2p_set_op_ch(dev, info, wrqu, &extra[6]);
-	} else if (!memcmp(extra, "invite=", 7)) {
-		wrqu->data.length -= 8;
-		rtw_p2p_invite_req(dev, info, wrqu, &extra[7]);
-	} else if (!memcmp(extra, "persistent=", 11)) {
-		wrqu->data.length -= 11;
-		rtw_p2p_set_persistent(dev, info, wrqu, &extra[11]);
-	}
-#endif /* CONFIG_92D_P2P */
-
-	return ret;
-}
-
-static int rtw_p2p_get(struct net_device *dev,
-		       struct iw_request_info *info,
-		       union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-
-#ifdef CONFIG_92D_P2P
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-
-	if (padapter->bShowGetP2PState)
-		DBG_8192D("[%s] extra = %s\n", __func__, (char *)wrqu->data.pointer);
-
-	if (!memcmp(wrqu->data.pointer, "status", 6)) {
-		rtw_p2p_get_status(dev, info, wrqu, extra);
-	} else if (!memcmp(wrqu->data.pointer, "role", 4)) {
-		rtw_p2p_get_role(dev, info, wrqu, extra);
-	} else if (!memcmp(wrqu->data.pointer, "peer_ifa", 8)) {
-		rtw_p2p_get_peer_ifaddr(dev, info, wrqu, extra);
-	} else if (!memcmp(wrqu->data.pointer, "req_cm", 6)) {
-		rtw_p2p_get_req_cm(dev, info, wrqu, extra);
-	} else if (!memcmp(wrqu->data.pointer, "peer_deva", 9)) {
-		/*	Get the P2P device address when receiving the provision discovery request frame. */
-		rtw_p2p_get_peer_devaddr(dev, info, wrqu, extra);
-	} else if (!memcmp(wrqu->data.pointer, "group_id", 8)) {
-		rtw_p2p_get_groupid(dev, info, wrqu, extra);
-	} else if (!memcmp(wrqu->data.pointer, "peer_deva_inv", 9)) {
-		/*	Get the P2P device address when receiving the P2P Invitation request frame. */
-		rtw_p2p_get_peer_devaddr_by_invitation(dev, info, wrqu, extra);
-	} else if (!memcmp((void const *)wrqu->data.pointer, "op_ch", 5)) {
-		rtw_p2p_get_op_ch(dev, info, wrqu, extra);
-	}
-#endif /* CONFIG_92D_P2P */
-
-	return ret;
-}
-
-static int rtw_p2p_get2(struct net_device *dev,
-						struct iw_request_info *info,
-						union iwreq_data *wrqu, char *extra)
-{
-
-	int ret = 0;
-
-#ifdef CONFIG_92D_P2P
-
-	int length = wrqu->data.length;
-	char *buffer = (u8 *)kmalloc(length, GFP_KERNEL);
-
-	if (buffer == NULL)
-	{
-		ret = -ENOMEM;
-		goto bad;
-	}
-
-	if (copy_from_user(buffer, wrqu->data.pointer, wrqu->data.length))
-	{
-		ret = -EFAULT;
-		goto bad;
-	}
-
-	DBG_8192D("[%s] buffer = %s\n", __func__, buffer);
-
-	if (!memcmp(buffer, "wpsCM =", 6))
-	{
-		ret = rtw_p2p_get_wps_configmethod(dev, info, wrqu, extra, &buffer[6]);
-	} else if (!memcmp(buffer, "devN =", 5))
-	{
-		ret = rtw_p2p_get_device_name(dev, info, wrqu, extra, &buffer[5]);
-	} else if (!memcmp(buffer, "dev_type =", 9))
-	{
-		ret = rtw_p2p_get_device_type(dev, info, wrqu, extra, &buffer[9]);
-	} else if (!memcmp(buffer, "go_devadd =", 10))
-	{
-		ret = rtw_p2p_get_go_device_address(dev, info, wrqu, extra, &buffer[10]);
-	} else if (!memcmp(buffer, "InvProc =", 8))
-	{
-		ret = rtw_p2p_get_invitation_procedure(dev, info, wrqu, extra, &buffer[8]);
-	} else
-	{
-		snprintf(extra, sizeof("Command not found."), "Command not found.");
-		wrqu->data.length = strlen(extra);
-	}
-
-bad:
-	kfree(buffer);
-
-#endif /* CONFIG_92D_P2P */
-
-	return ret;
-}
-
-static int rtw_rereg_nd_name(struct net_device *dev,
-			     struct iw_request_info *info,
-			     union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-	struct rtw_adapter *padapter = rtw_netdev_priv(dev);
-	struct rereg_nd_name_data *rereg_priv = &padapter->rereg_nd_name_priv;
-	char new_ifname[IFNAMSIZ];
-
-	if (rereg_priv->old_ifname[0] == 0) {
-		char *reg_ifname;
-#ifdef CONFIG_CONCURRENT_MODE
-		if (padapter->isprimary)
-			reg_ifname = padapter->registrypriv.ifname;
-		else
-#endif
-		reg_ifname = padapter->registrypriv.if2name;
-
-		strncpy(rereg_priv->old_ifname, reg_ifname, IFNAMSIZ);
-		rereg_priv->old_ifname[IFNAMSIZ-1] = 0;
-	}
-
-	/* DBG_8192D("%s wrqu->data.length:%d\n", __func__, wrqu->data.length); */
-	if (wrqu->data.length > IFNAMSIZ)
-		return -EFAULT;
-
-	if (copy_from_user(new_ifname, wrqu->data.pointer, IFNAMSIZ)) {
-		return -EFAULT;
-	}
-
-	if (0 == strcmp(rereg_priv->old_ifname, new_ifname)) {
-		return ret;
-	}
+	if (0 == strcmp(rereg_priv->old_ifname, new_ifname))
+		return ret;
 
 	DBG_8192D("%s new_ifname:%s\n", __func__, new_ifname);
-	if (0 != (ret = rtw_change_ifname(padapter, new_ifname))) {
+	if (0 != (ret = rtw_change_ifname(padapter, new_ifname)))
 		goto exit;
-	}
 
 	if (!memcmp(rereg_priv->old_ifname, "disable%d", 9)) {
 		padapter->ledpriv.bRegUseLed = rereg_priv->old_bRegUseLed;
@@ -4668,10 +3114,6 @@ static int rtw_dbg_port(struct net_devic
 				padapter->bNotifyChannelChange = extra_arg;
 				break;
 			case 0x24:
-#ifdef CONFIG_92D_P2P
-				DBG_8192D("turn %s the bShowGetP2PState Variable\n", (extra_arg == 1)?"on":"off");
-				padapter->bShowGetP2PState = extra_arg;
-#endif /*  CONFIG_92D_P2P */
 				break;
 			case 0xdd:/* registers dump , 0 for mac reg, 1 for bb reg, 2 for rf reg */
 				if (extra_arg == 0)
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -172,7 +172,7 @@ module_param(rtw_80211d, int, 0644);
 
 static uint rtw_notch_filter = RTW_NOTCH_FILTER;
 module_param(rtw_notch_filter, uint, 0644);
-MODULE_PARM_DESC(rtw_notch_filter, "0:Disable, 1:Enable, 2:Enable only for P2P");
+MODULE_PARM_DESC(rtw_notch_filter, "0:Disable, 1:Enable");
 
 int _netdev_open(struct net_device *pnetdev);
 int netdev_open (struct net_device *pnetdev);
@@ -518,9 +518,6 @@ static u8 rtw_init_default_value(struct
 	padapter->bRxRSSIDisplay = 0;
 	padapter->bForceWriteInitGain = 1;
 	padapter->bNotifyChannelChange = 0;
-#ifdef CONFIG_92D_P2P
-	padapter->bShowGetP2PState = 1;
-#endif
 	return ret;
 }
 
@@ -586,13 +583,6 @@ u8 rtw_init_drv_sw(struct rtw_adapter *p
 		goto exit;
 	}
 
-#ifdef CONFIG_92D_P2P
-	rtw_init_wifidirect_timers(padapter);
-	init_wifidirect_info(padapter, P2P_ROLE_DISABLE);
-	reset_global_wifidirect_info(padapter);
-	rtw_init_cfg80211_wifidirect_info(padapter);
-#endif /* CONFIG_92D_P2P */
-
 	if (init_mlme_ext_priv(padapter) == 0) {
 		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init mlme_ext_priv\n"));
 		ret8 = 0;
@@ -656,10 +646,6 @@ void rtw_cancel_all_timer(struct rtw_ada
 
 	del_timer_sync(&padapter->pwrctrlpriv.pwr_state_check_timer);
 
-#ifdef CONFIG_92D_P2P
-	del_timer_sync(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
-#endif /* CONFIG_92D_P2P */
-
 	del_timer_sync(&padapter->mlmepriv.set_scan_deny_timer);
 	rtw_clear_scan_deny(padapter);
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel set_scan_deny_timer!\n"));
@@ -674,25 +660,6 @@ u8 rtw_free_drv_sw(struct rtw_adapter *p
 {
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("==>rtw_free_drv_sw"));
 
-	/* we can call rtw_p2p_enable here, but: */
-	/*  1. rtw_p2p_enable may have IO operation */
-	/*  2. rtw_p2p_enable is bundled with wext interface */
-	#ifdef CONFIG_92D_P2P
-	{
-		struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		{
-			del_timer_sync(&pwdinfo->find_phase_timer);
-			del_timer_sync(&pwdinfo->restore_p2p_state_timer);
-			del_timer_sync(&pwdinfo->pre_tx_scan_timer);
-#ifdef CONFIG_CONCURRENT_MODE
-			del_timer_sync(&pwdinfo->ap_p2p_switch_timer);
-#endif /*  CONFIG_CONCURRENT_MODE */
-			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
-		}
-	}
-	#endif
-
 	free_mlme_ext_priv(&padapter->mlmeextpriv);
 
 	rtw_free_cmd_priv(&padapter->cmdpriv);
@@ -924,9 +891,6 @@ struct rtw_adapter *rtw_drv_if2_init(str
 	}
 
 	memcpy(padapter->eeprompriv.mac_addr, mac, ETH_ALEN);
-#ifdef CONFIG_92D_P2P
-	rtw_init_wifidirect_addrs(padapter, padapter->eeprompriv.mac_addr, padapter->eeprompriv.mac_addr);
-#endif
 	memcpy(pnetdev->dev_addr, mac, ETH_ALEN);
 
 	DBG_8192D("MAC Address (if2) = %pM\n", mac);
@@ -1224,12 +1188,6 @@ static int netdev_close(struct net_devic
 		rtw_led_control(padapter, LED_CTL_POWER_OFF);
 	}
 
-#ifdef CONFIG_92D_P2P
-	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled == true)
-		wdev_to_priv(padapter->rtw_wdev)->p2p_enabled = false;
-	rtw_p2p_enable(padapter, P2P_ROLE_DISABLE);
-#endif /* CONFIG_92D_P2P */
-
 	rtw_scan_abort(padapter);
 	padapter->rtw_wdev->iftype = NL80211_IFTYPE_MONITOR; /* set this at the end */
 
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -586,9 +586,6 @@ static struct rtw_adapter *rtw_usb_if1_i
 	/*  alloc dev name after read efuse. */
 	rtw_init_netdev_name(pnetdev, padapter->registrypriv.ifname);
 	rtw_macaddr_cfg(padapter->eeprompriv.mac_addr);
-#ifdef CONFIG_92D_P2P
-	rtw_init_wifidirect_addrs(padapter, padapter->eeprompriv.mac_addr, padapter->eeprompriv.mac_addr);
-#endif
 	memcpy(pnetdev->dev_addr, padapter->eeprompriv.mac_addr, ETH_ALEN);
 	DBG_8192D("MAC Address from pnetdev->dev_addr= %pM\n", pnetdev->dev_addr);
 

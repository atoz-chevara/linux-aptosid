From 7b84b56715fc5bf95efad781545ef9c0221b23f0 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Wed, 19 Feb 2014 15:59:57 -0600
Subject: [PATCH 209/390] rtl8192du: Remove all dependence on KERNEL_VERSION

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_ap.c            |   2 +-
 core/rtw_mlme.c          |  18 +--
 core/rtw_mlme_ext.c      |   6 +-
 core/rtw_pwrctrl.c       |   4 -
 core/rtw_recv.c          |   4 -
 core/rtw_xmit.c          |  18 ---
 hal/rtl8192du_recv.c     |  10 +-
 hal/rtl8192du_xmit.c     |   4 -
 hal/usb_ops_linux.c      |  29 +---
 include/ioctl_cfg80211.h |  25 ----
 include/osdep_intf.h     |   2 -
 include/osdep_service.h  |  99 ++-----------
 include/rtw_event.h      |   4 -
 include/rtw_io.h         |  13 --
 include/rtw_led.h        |   4 -
 include/usb_ops.h        |   9 --
 include/usb_ops_linux.h  |   2 -
 os_dep/ioctl_cfg80211.c  | 375 +++++++----------------------------------------
 os_dep/ioctl_linux.c     |  10 +-
 os_dep/mlme_linux.c      |  14 --
 os_dep/os_intfs.c        | 117 ++-------------
 os_dep/osdep_service.c   |  22 ---
 os_dep/recv_linux.c      |   2 -
 os_dep/rtw_android.c     |  15 --
 os_dep/usb_intf.c        |  66 ++-------
 os_dep/xmit_linux.c      |   9 --
 26 files changed, 101 insertions(+), 782 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_ap.c
+++ b/drivers/staging/rtl8192du/core/rtw_ap.c
@@ -1919,7 +1919,7 @@ u8 ap_free_sta(struct rtw_adapter *padap
 	if (1) {
 		#ifdef COMPAT_KERNEL_RELEASE
 		rtw_cfg80211_indicate_sta_disassoc(padapter, psta->hwaddr, reason);
-		#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
+		#elif !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 		rtw_cfg80211_indicate_sta_disassoc(padapter, psta->hwaddr,
 						   reason);
 		#endif
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -1782,7 +1782,7 @@ void rtw_stassoc_event_callback(struct r
 #ifdef CONFIG_IOCTL_CFG80211
 #ifdef COMPAT_KERNEL_RELEASE
 
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)) || defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
+#elif defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 			u8 *passoc_req = NULL;
 			u32 assoc_req_len;
 
@@ -1808,7 +1808,7 @@ void rtw_stassoc_event_callback(struct r
 
 				kfree(passoc_req);
 			}
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)) || defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
+#endif /* defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
 #endif /* CONFIG_IOCTL_CFG80211 */
 
 			ap_sta_info_defer_update(adapter, psta);
@@ -1882,10 +1882,10 @@ void rtw_stadel_event_callback(struct rt
 #ifdef CONFIG_IOCTL_CFG80211
 #ifdef COMPAT_KERNEL_RELEASE
 
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37)) || defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
+#elif defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 		rtw_cfg80211_indicate_sta_disassoc(adapter, pstadel->macaddr,
 						   *(u16 *)pstadel->rsvd);
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)) || defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
+#endif /* defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
 #endif /* CONFIG_IOCTL_CFG80211 */
 
 		return;
@@ -2176,17 +2176,10 @@ void rtw_dynamic_check_timer_handlder(st
 
 #ifdef CONFIG_BR_EXT
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
 	rcu_read_lock();
-#endif /*  (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35)) */
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-	if (adapter->pnetdev->br_port &&
-	    check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE)) {
-#else /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 	if (rcu_dereference(adapter->pnetdev->rx_handler_data) &&
 	    check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE)) {
-#endif /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 		/*  expire NAT2.5 entry */
 		nat25_db_expire(adapter);
 
@@ -2199,10 +2192,7 @@ void rtw_dynamic_check_timer_handlder(st
 			adapter->pppoe_connection_in_progress--;
 		}
 	}
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
 	rcu_read_unlock();
-#endif /*  (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35)) */
-
 #endif /*  CONFIG_BR_EXT */
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -1860,10 +1860,10 @@ unsigned int OnAssocReq(struct rtw_adapt
 #ifdef COMPAT_KERNEL_RELEASE
 			rtw_cfg80211_indicate_sta_assoc(adapt, pframe,
 							pkt_len);
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
+#elif !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 			rtw_cfg80211_indicate_sta_assoc(adapt, pframe,
 							pkt_len);
-#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
+#else /* !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
 			spin_lock_bh(&pstat->lock);
 			kfree(pstat->passoc_req);
 			pstat->passoc_req = NULL;
@@ -1875,7 +1875,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 				pstat->assoc_req_len = pkt_len;
 			}
 			spin_unlock_bh(&pstat->lock);
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
+#endif /* !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
 		} else
 #endif /* CONFIG_IOCTL_CFG80211 */
 		{
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -656,12 +656,8 @@ void LeaveAllPowerSaveMode(struct rtw_ad
 		if (adapter->pwrctrlpriv.rf_pwrstate == rf_off) {
 #ifdef CONFIG_AUTOSUSPEND
 			if (adapter->registrypriv.usbss_enable) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
 				usb_disable_autosuspend(adapter_to_dvobj
 							(adapter)->pusbdev);
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22) && LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34))
-				adapter_to_dvobj(adapter)->pusbdev->autosuspend_disabled = adapter->bDisableAutosuspend;	/* autosuspend disabled by the user */
-#endif
 			} else
 #endif
 			{
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -2189,14 +2189,10 @@ static int amsdu_to_msdu(struct rtw_adap
 			struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 			void *br_port = NULL;
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-			br_port = padapter->pnetdev->br_port;
-#else /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 			rcu_read_lock();
 			br_port =
 			    rcu_dereference(padapter->pnetdev->rx_handler_data);
 			rcu_read_unlock();
-#endif /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 
 			if (br_port &&
 			    (check_fwstate(pmlmepriv, WIFI_STATION_STATE |
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -1724,12 +1724,6 @@ struct xmit_frame *rtw_alloc_xmitframe(s
 
 		pxframe->agg_num = 1;
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35))
-		if (pxmitpriv->free_xmitframe_cnt == 1) {
-			if (!rtw_netif_queue_stopped(padapter->pnetdev))
-				rtw_netif_stop_queue(padapter->pnetdev);
-		}
-#endif
 		pxframe->ack_report = 0;
 	}
 	spin_unlock_bh(&pfree_xmit_queue->lock);
@@ -2022,13 +2016,9 @@ static int rtw_br_client_tx(struct rtw_a
 	unsigned short vlan_hdr = 0;
 	void *br_port = NULL;
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-	br_port = padapter->pnetdev->br_port;
-#else   /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 	rcu_read_lock();
 	br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
 	rcu_read_unlock();
-#endif  /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 	spin_lock_bh(&padapter->br_ext_lock);
 	if (!(skb->data[0] & 1) && br_port &&
 	    memcmp(skb->data+MACADDRLEN, padapter->br_mac, MACADDRLEN) &&
@@ -2105,11 +2095,7 @@ static int rtw_br_client_tx(struct rtw_a
 			if (skb_is_nonlinear(skb))
 				ERR_8192D("%s(): skb_is_nonlinear!!\n", __func__);
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
-			res = skb_linearize(skb, GFP_ATOMIC);
-#else	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)) */
 			res = skb_linearize(skb);
-#endif	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)) */
 			if (res < 0) {
 				ERR_8192D("TX DROP: skb_linearize fail!\n");
 				return -1;
@@ -2185,13 +2171,9 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 
 #ifdef CONFIG_BR_EXT
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-	br_port = padapter->pnetdev->br_port;
-#else   /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 	rcu_read_lock();
 	br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
 	rcu_read_unlock();
-#endif  /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 
 	if (br_port && check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) {
 		res = rtw_br_client_tx(padapter, ppkt);
--- a/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
@@ -96,16 +96,10 @@ int	rtl8192du_init_recv_priv(struct rtw_
 
 		skb_queue_head_init(&precvpriv->free_recv_skb_queue);
 
-		for (i=0; i<NR_PREALLOC_RECV_SKB; i++)
-		{
-	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
-			pskb = dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
-	#else
+		for (i = 0; i < NR_PREALLOC_RECV_SKB; i++) {
 			pskb = netdev_alloc_skb(padapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
-	#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) */
 
-			if (pskb)
-			{
+			if (pskb) {
 				pskb->dev = padapter->pnetdev;
 
 				tmpaddr = (SIZE_PTR)pskb->data;
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -917,11 +917,7 @@ s32 rtl8192du_hostap_mgnt_xmit_entry(str
 	if ((fc & RTW_IEEE80211_FCTL_FTYPE) != RTW_IEEE80211_FTYPE_MGMT)
 		goto _exit;
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
-	pxmit_skb = dev_alloc_skb(len + TXDESC_SIZE);
-#else
 	pxmit_skb = netdev_alloc_skb(pnetdev, len + TXDESC_SIZE);
-#endif
 
 	if (!pxmit_skb)
 		goto _exit;
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -426,13 +426,8 @@ static s32 pre_recv_entry(struct recv_fr
 					alloc_sz += 14;
 				}
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
-				pkt_copy = dev_alloc_skb(alloc_sz);
-#else
 				pkt_copy = netdev_alloc_skb(secondary_padapter->pnetdev, alloc_sz);
-#endif
-				if (pkt_copy)
-				{
+				if (pkt_copy) {
 					pkt_copy->dev = secondary_padapter->pnetdev;
 					precvframe_if2->pkt = pkt_copy;
 					precvframe_if2->rx_head = pkt_copy->data;
@@ -552,13 +547,8 @@ static int recvbuf2recvframe(struct rtw_
 			alloc_sz += 14;
 		}
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
-		pkt_copy = dev_alloc_skb(alloc_sz);
-#else
 		pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
-#endif
-		if (pkt_copy)
-		{
+		if (pkt_copy) {
 			precvframe->pkt = pkt_copy;
 			precvframe->rx_head = pkt_copy->data;
 			precvframe->rx_end = pkt_copy->data + alloc_sz;
@@ -566,17 +556,12 @@ static int recvbuf2recvframe(struct rtw_
 			skb_reserve(pkt_copy, shift_sz);/* force ip_hdr at 8-byte alignment address according to shift_sz. */
 			memcpy(pkt_copy->data, (pbuf + pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE), skb_len);
 			precvframe->rx_data = precvframe->rx_tail = pkt_copy->data;
-		}
-		else
-		{
+		} else {
 			precvframe->pkt = skb_clone(pskb, GFP_ATOMIC);
-			if (pkt_copy)
-			{
+			if (pkt_copy) {
 				precvframe->rx_head = precvframe->rx_data = precvframe->rx_tail = pbuf;
 				precvframe->rx_end = pbuf + alloc_sz;
-			}
-			else
-			{
+			} else {
 				DBG_8192D("recvbuf2recvframe: skb_clone fail\n");
 				rtw_free_recvframe(precvframe, pfree_recv_queue);
 				goto _exit_recvbuf2recvframe;
@@ -773,11 +758,7 @@ static u32 usb_read_port(struct intf_hdl
 
 		/* re-assign for linux based on skb */
 		if ((precvbuf->reuse == false) || (precvbuf->pskb == NULL)) {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
-			precvbuf->pskb = dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
-#else
 			precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
-#endif
 			if (precvbuf->pskb == NULL) {
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("init_recvbuf(): alloc_skb fail!\n"));
 				return _FAIL;
--- a/drivers/staging/rtl8192du/include/ioctl_cfg80211.h
+++ b/drivers/staging/rtl8192du/include/ioctl_cfg80211.h
@@ -19,9 +19,6 @@
 #if defined(CONFIG_IOCTL_CFG80211) && !defined(CONFIG_CFG80211) && !defined(CONFIG_CFG80211_MODULE)
 	#error "Can't define CONFIG_IOCTL_CFG80211 because neither CONFIG_CFG80211 nor CONFIG_CFG80211_MODULE is defined in kernel"
 #endif
-#if defined(CONFIG_IOCTL_CFG80211) && LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
-	#error "We haven't verify our cfg80211 solution below kernel version 2.6.35"
-#endif
 
 #if defined(RTW_USE_CFG80211_STA_EVENT)
 	#undef CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
@@ -106,35 +103,13 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struc
 
 bool rtw_cfg80211_pwr_mgmt(struct rtw_adapter *adapter);
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))  && !defined(COMPAT_KERNEL_RELEASE)
-#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->pnetdev, freq, buf, len, gfp)
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
-#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->pnetdev, freq, sig_dbm, buf, len, gfp)
-#else
 #define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, gfp)
-#endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))  && !defined(COMPAT_KERNEL_RELEASE)
-#define rtw_cfg80211_send_rx_assoc(adapter, bss, buf, len) cfg80211_send_rx_assoc((adapter)->pnetdev, buf, len)
-#else
 #define rtw_cfg80211_send_rx_assoc(adapter, bss, buf, len) cfg80211_send_rx_assoc((adapter)->pnetdev, bss, buf, len)
-#endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
-#define rtw_cfg80211_mgmt_tx_status(adapter, cookie, buf, len, ack, gfp) cfg80211_mgmt_tx_status((adapter)->pnetdev, cookie, buf, len, ack, gfp)
-#else
 #define rtw_cfg80211_mgmt_tx_status(adapter, cookie, buf, len, ack, gfp) cfg80211_mgmt_tx_status((adapter)->rtw_wdev, cookie, buf, len, ack, gfp)
-#endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
-#define rtw_cfg80211_ready_on_channel(adapter, cookie, chan, channel_type, duration, gfp)  cfg80211_ready_on_channel((adapter)->pnetdev, cookie, chan, channel_type, duration, gfp)
-#define rtw_cfg80211_remain_on_channel_expired(adapter, cookie, chan, chan_type, gfp) cfg80211_remain_on_channel_expired((adapter)->pnetdev, cookie, chan, chan_type, gfp)
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
-#define rtw_cfg80211_ready_on_channel(adapter, cookie, chan, channel_type, duration, gfp)  cfg80211_ready_on_channel((adapter)->rtw_wdev, cookie, chan, channel_type, duration, gfp)
-#define rtw_cfg80211_remain_on_channel_expired(adapter, cookie, chan, chan_type, gfp) cfg80211_remain_on_channel_expired((adapter)->rtw_wdev, cookie, chan, chan_type, gfp)
-#else
 #define rtw_cfg80211_ready_on_channel(adapter, cookie, chan, channel_type, duration, gfp)  cfg80211_ready_on_channel((adapter)->rtw_wdev, cookie, chan, duration, gfp)
 #define rtw_cfg80211_remain_on_channel_expired(adapter, cookie, chan, chan_type, gfp) cfg80211_remain_on_channel_expired((adapter)->rtw_wdev, cookie, chan, gfp)
-#endif
 
 #endif /* __IOCTL_CFG80211_H__ */
--- a/drivers/staging/rtl8192du/include/osdep_intf.h
+++ b/drivers/staging/rtl8192du/include/osdep_intf.h
@@ -76,9 +76,7 @@ int rtw_ioctl(struct net_device *dev, st
 int rtw_init_netdev_name(struct net_device *pnetdev, const char *ifname);
 struct net_device *rtw_init_netdev(struct rtw_adapter *padapter);
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 u16 rtw_recv_select_queue(struct sk_buff *skb);
-#endif /* LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35) */
 
 #ifdef CONFIG_PROC_DEBUG
 void rtw_proc_init_one(struct net_device *dev);
--- a/drivers/staging/rtl8192du/include/osdep_service.h
+++ b/drivers/staging/rtl8192du/include/osdep_service.h
@@ -31,20 +31,14 @@
 	#include <linux/init.h>
 	#include <linux/slab.h>
 	#include <linux/module.h>
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,5))
 	#include <linux/kref.h>
-#endif
 	#include <linux/netdevice.h>
 	#include <linux/skbuff.h>
 	#include <asm/uaccess.h>
 	#include <asm/byteorder.h>
 	#include <asm/atomic.h>
 	#include <asm/io.h>
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
-	#include <asm/semaphore.h>
-#else
 	#include <linux/semaphore.h>
-#endif
 	#include <linux/sem.h>
 	#include <linux/sched.h>
 	#include <linux/etherdevice.h>
@@ -69,56 +63,19 @@
 #endif
 
 	#include <linux/usb.h>
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
-	#include <linux/usb_ch9.h>
-#else
 	#include <linux/usb/ch9.h>
-#endif
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22))
 #ifdef CONFIG_USB_SUSPEND
 #define CONFIG_AUTOSUSPEND	1
 #endif
-#endif
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
-	#define _mutex	struct mutex
-#else
-	#define _mutex	struct semaphore
-#endif
-	struct	__queue	{
-		struct	list_head	queue;
-		spinlock_t	lock;
-	};
-
-	#define thread_exit() complete_and_exit(NULL, 0)
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
-	#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
-#endif
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
-/*  Porting from linux kernel, for compatible with old kernel. */
-static inline unsigned char *skb_tail_pointer(const struct sk_buff *skb)
-{
-	return skb->tail;
-}
 
-static inline void skb_reset_tail_pointer(struct sk_buff *skb)
-{
-	skb->tail = skb->data;
-}
-
-static inline void skb_set_tail_pointer(struct sk_buff *skb, const int offset)
-{
-	skb->tail = skb->data + offset;
-}
+#define _mutex	struct mutex
+struct	__queue	{
+	struct	list_head	queue;
+	spinlock_t	lock;
+};
 
-static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
-{
-	return skb->end;
-}
-#endif
+#define thread_exit() complete_and_exit(NULL, 0)
 
 static inline struct list_head *get_list_head(struct __queue *queue)
 {
@@ -127,21 +84,13 @@ static inline struct list_head *get_list
 
 static inline void _enter_critical_mutex(_mutex *pmutex)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
-		mutex_lock(pmutex);
-#else
-		down(pmutex);
-#endif
+	mutex_lock(pmutex);
 }
 
 
 static inline void _exit_critical_mutex(_mutex *pmutex)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
-		mutex_unlock(pmutex);
-#else
-		up(pmutex);
-#endif
+	mutex_unlock(pmutex);
 }
 
 static inline void _init_timer(struct timer_list *timer, struct net_device * nic_hdl, void *pfunc, void *cntx)
@@ -170,11 +119,7 @@ static inline void _cancel_timer(struct
 
 static inline void _init_workitem(struct work_struct *pwork, void *pfunc, void * cntx)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 	INIT_WORK(pwork, pfunc);
-#else
-	INIT_WORK(pwork, pfunc,pwork);
-#endif
 }
 
 static inline void _set_workitem(struct work_struct *pwork)
@@ -184,11 +129,7 @@ static inline void _set_workitem(struct
 
 static inline void _cancel_workitem_sync(struct work_struct *pwork)
 {
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22))
 	cancel_work_sync(pwork);
-#else
-	flush_scheduled_work();
-#endif
 }
 
 /*  */
@@ -211,41 +152,25 @@ static inline void _cancel_workitem_sync
 
 static inline int rtw_netif_queue_stopped(struct net_device *pnetdev)
 {
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
-	return (netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 0)) &&
+	return	netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 0)) &&
 		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 1)) &&
 		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 2)) &&
-		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 3)));
-#else
-	return netif_queue_stopped(pnetdev);
-#endif
+		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 3));
 }
 
 static inline void rtw_netif_wake_queue(struct net_device *pnetdev)
 {
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 	netif_tx_wake_all_queues(pnetdev);
-#else
-	netif_wake_queue(pnetdev);
-#endif
 }
 
 static inline void rtw_netif_start_queue(struct net_device *pnetdev)
 {
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 	netif_tx_start_all_queues(pnetdev);
-#else
-	netif_start_queue(pnetdev);
-#endif
 }
 
 static inline void rtw_netif_stop_queue(struct net_device *pnetdev)
 {
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 	netif_tx_stop_all_queues(pnetdev);
-#else
-	netif_stop_queue(pnetdev);
-#endif
 }
 
 
@@ -475,11 +400,7 @@ extern void rtw_free_netdev(struct net_d
 #define FUNC_ADPT_FMT "%s(%s)"
 #define FUNC_ADPT_ARG(adapter) __func__, adapter->pnetdev->name
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
 #define rtw_signal_process(pid, sig) kill_pid(find_vpid((pid)),(sig), 1)
-#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)) */
-#define rtw_signal_process(pid, sig) kill_proc((pid), (sig), 1)
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)) */
 
 extern u64 rtw_modular64(u64 x, u64 y);
 extern u64 rtw_division64(u64 x, u64 y);
--- a/drivers/staging/rtl8192du/include/rtw_event.h
+++ b/drivers/staging/rtl8192du/include/rtw_event.h
@@ -19,11 +19,7 @@
 #include <osdep_service.h>
 
 #include <wlan_bssdef.h>
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
-#include <asm/semaphore.h>
-#else
 #include <linux/semaphore.h>
-#endif
 #include <linux/sem.h>
 
 #ifdef CONFIG_H2CLBK
--- a/drivers/staging/rtl8192du/include/rtw_io.h
+++ b/drivers/staging/rtl8192du/include/rtw_io.h
@@ -22,29 +22,16 @@
 #include <osdep_intf.h>
 
 #include <asm/byteorder.h>
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
-#include <asm/semaphore.h>
-#else
 #include <linux/semaphore.h>
-#endif
 #include <linux/list.h>
 #include <linux/spinlock.h>
 #include <asm/atomic.h>
 
 #include <linux/usb.h>
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
-#include <linux/usb_ch9.h>
-#else
 #include <linux/usb/ch9.h>
-#endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 #define rtw_usb_buffer_alloc(dev, size, mem_flags, dma) usb_alloc_coherent((dev), (size), (mem_flags), (dma))
 #define rtw_usb_buffer_free(dev, size, addr, dma) usb_free_coherent((dev), (size), (addr), (dma))
-#else
-#define rtw_usb_buffer_alloc(dev, size, mem_flags, dma) usb_buffer_alloc((dev), (size), (mem_flags), (dma))
-#define rtw_usb_buffer_free(dev, size, addr, dma) usb_buffer_free((dev), (size), (addr), (dma))
-#endif
 
 #define NUM_IOREQ		8
 
--- a/drivers/staging/rtl8192du/include/rtw_led.h
+++ b/drivers/staging/rtl8192du/include/rtw_led.h
@@ -92,15 +92,11 @@ struct LED_871X {
 	enum LED_STATE_871X		BlinkingLedState; /*  Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are. */
 
 	struct timer_list		BlinkTimer; /*  Timer object for led blinking. */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
 	struct work_struct BlinkWorkItem; /*  Workitem used by BlinkTimer to manipulate H/W to blink LED. */
-#endif
 };
 
 
-/*  */
 /*  LED customization. */
-/*  */
 
 enum LED_STRATEGY_871X {
 	SW_LED_MODE0, /*  SW control 1 LED via GPIO0. It is default option. */
--- a/drivers/staging/rtl8192du/include/usb_ops.h
+++ b/drivers/staging/rtl8192du/include/usb_ops.h
@@ -34,19 +34,10 @@ enum{
 #define MAX_VENDOR_REQ_CMD_SIZE	254		/* 8188cu SIE Support */
 #define MAX_USB_IO_CTL_SIZE		(MAX_VENDOR_REQ_CMD_SIZE +ALIGNMENT_UNIT)
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
 #define rtw_usb_control_msg(dev, pipe, request, requesttype, value, index, data, size, timeout_ms) \
 	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), (timeout_ms))
 #define rtw_usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout_ms) \
 	usb_bulk_msg((usb_dev), (pipe), (data), (len), (actual_length), (timeout_ms))
-#else
-#define rtw_usb_control_msg(dev, pipe, request, requesttype, value, index, data, size,timeout_ms) \
-	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), \
-		((timeout_ms) == 0) ||((timeout_ms)*HZ/1000>0)?((timeout_ms)*HZ/1000):1)
-#define rtw_usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout_ms) \
-	usb_bulk_msg((usb_dev), (pipe), (data), (len), (actual_length), \
-		((timeout_ms) == 0) ||((timeout_ms)*HZ/1000>0)?((timeout_ms)*HZ/1000):1)
-#endif
 #include <usb_ops_linux.h>
 
 void rtl8192du_set_intf_ops(struct _io_ops *pops);
--- a/drivers/staging/rtl8192du/include/usb_ops_linux.h
+++ b/drivers/staging/rtl8192du/include/usb_ops_linux.h
@@ -25,14 +25,12 @@
 
 #define RTW_USB_BULKOUT_TIMEOUT	5000/* ms */
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)) || (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
 #define _usbctrl_vendorreq_async_callback(urb, regs)	_usbctrl_vendorreq_async_callback(urb)
 #define usb_bulkout_zero_complete(purb, regs)	usb_bulkout_zero_complete(purb)
 #define usb_write_mem_complete(purb, regs)	usb_write_mem_complete(purb)
 #define usb_write_port_complete(purb, regs)	usb_write_port_complete(purb)
 #define usb_read_port_complete(purb, regs)	usb_read_port_complete(purb)
 #define usb_read_interrupt_complete(purb, regs)	usb_read_interrupt_complete(purb)
-#endif
 
 unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr);
 
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -236,7 +236,6 @@ void rtw_spt_band_free(struct ieee80211_
 	kfree(spt_band);
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 static const struct ieee80211_txrx_stypes
 rtw_cfg80211_default_mgmt_stypes[NUM_NL80211_IFTYPES] = {
 	[NL80211_IFTYPE_ADHOC] = {
@@ -285,7 +284,6 @@ rtw_cfg80211_default_mgmt_stypes[NUM_NL8
 		BIT(IEEE80211_STYPE_ACTION >> 4)
 	},
 };
-#endif
 
 static int rtw_ieee80211_channel_to_frequency(int chan, int band)
 {
@@ -406,40 +404,7 @@ static int rtw_cfg80211_inform_bss(_adap
 		return -EINVAL;
 	}
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38))
-#ifndef COMPAT_KERNEL_RELEASE
-	/* patch for cfg80211, update beacon ies to information_elements */
-	if (pnetwork->network.Reserved[0] == 1) { /*  WIFI_BEACON */
-
-		 if (bss->len_information_elements != bss->len_beacon_ies)
-		 {
-			bss->information_elements = bss->beacon_ies;
-			bss->len_information_elements =  bss->len_beacon_ies;
-		 }
-	}
-#endif /* COMPAT_KERNEL_RELEASE */
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) */
-
-/*
-	{
-		if (bss->information_elements == bss->proberesp_ies)
-		{
-			if (bss->len_information_elements !=  bss->len_proberesp_ies)
-			{
-				DBG_8192C("error!, len_information_elements !=  bss->len_proberesp_ies\n");
-			}
-
-		}
-		else if (bss->len_information_elements <  bss->len_beacon_ies)
-		{
-			bss->information_elements = bss->beacon_ies;
-			bss->len_information_elements =  bss->len_beacon_ies;
-		}
-	}
-*/
-
 	cfg80211_put_bss(bss);
-
 exit:
 	return ret;
 }
@@ -455,13 +420,9 @@ void rtw_cfg80211_indicate_connect(_adap
 
 	DBG_8192C("%s(padapter=%p)\n", __func__, padapter);
 
-	if (pwdev->iftype != NL80211_IFTYPE_STATION
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
-		&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT
-		#endif
-	) {
+	if (pwdev->iftype != NL80211_IFTYPE_STATION &&
+	    pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT)
 		return;
-	}
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		return;
@@ -478,7 +439,6 @@ void rtw_cfg80211_indicate_connect(_adap
 
 	#ifdef CONFIG_LAYER2_ROAMING
 	if (rtw_to_roaming(padapter) > 0) {
-		#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39) || defined(COMPAT_KERNEL_RELEASE)
 		struct wiphy *wiphy = pwdev->wiphy;
 		struct ieee80211_channel *notify_channel;
 		u32 freq;
@@ -490,21 +450,20 @@ void rtw_cfg80211_indicate_connect(_adap
 			freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
 
 		notify_channel = ieee80211_get_channel(wiphy, freq);
-		#endif
 
 		DBG_871X("%s call cfg80211_roamed\n", __func__);
-		cfg80211_roamed(padapter->pnetdev
-			#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39) || defined(COMPAT_KERNEL_RELEASE)
-			, notify_channel
-			#endif
-			, cur_network->network.MacAddress
-			, pmlmepriv->assoc_req+sizeof(struct rtw_ieee80211_hdr_3addr)+2
-			, pmlmepriv->assoc_req_len-sizeof(struct rtw_ieee80211_hdr_3addr)-2
-			, pmlmepriv->assoc_rsp+sizeof(struct rtw_ieee80211_hdr_3addr)+6
-			, pmlmepriv->assoc_rsp_len-sizeof(struct rtw_ieee80211_hdr_3addr)-6
-			, GFP_ATOMIC);
-	}
-	else
+		cfg80211_roamed(padapter->pnetdev, notify_channel,
+				cur_network->network.MacAddress,
+				pmlmepriv->assoc_req +
+				sizeof(struct rtw_ieee80211_hdr_3addr) + 2,
+				pmlmepriv->assoc_req_len -
+				sizeof(struct rtw_ieee80211_hdr_3addr) - 2,
+				pmlmepriv->assoc_rsp +
+				sizeof(struct rtw_ieee80211_hdr_3addr) + 6,
+				pmlmepriv->assoc_rsp_len -
+				sizeof(struct rtw_ieee80211_hdr_3addr) - 6,
+				GFP_ATOMIC);
+	} else
 	#endif
 	{
 		DBG_8192C("pwdev->sme_state(b)=%d\n", pwdev->sme_state);
@@ -528,13 +487,9 @@ void rtw_cfg80211_indicate_disconnect(_a
 
 	DBG_8192C("%s(padapter=%p)\n", __func__, padapter);
 
-	if (pwdev->iftype != NL80211_IFTYPE_STATION
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
-		&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT
-		#endif
-	) {
+	if (pwdev->iftype != NL80211_IFTYPE_STATION &&
+	    pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT)
 		return;
-	}
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		return;
@@ -1137,11 +1092,7 @@ exit:
 }
 
 static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 				u8 key_index, bool pairwise, const u8 *mac_addr,
-#else	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
-				u8 key_index, const u8 *mac_addr,
-#endif	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
 				struct key_params *params)
 {
 	char *alg_name;
@@ -1157,9 +1108,7 @@ static int cfg80211_rtw_add_key(struct w
 	DBG_871X("key_len=0x%x\n", params->key_len);
 	DBG_871X("seq_len=0x%x\n", params->seq_len);
 	DBG_871X("key_index=%d\n", key_index);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	DBG_871X("pairwise=%d\n", pairwise);
-#endif	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
 
 	param_len = sizeof(struct ieee_param) + params->key_len;
 	param = (struct ieee_param *)kmalloc(param_len, GFP_KERNEL);
@@ -1236,11 +1185,7 @@ static int cfg80211_rtw_add_key(struct w
 }
 
 static int cfg80211_rtw_get_key(struct wiphy *wiphy, struct net_device *ndev,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 				u8 key_index, bool pairwise, const u8 *mac_addr,
-#else	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
-				u8 key_index, const u8 *mac_addr,
-#endif	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
 				void *cookie,
 				void (*callback)(void *cookie,
 						 struct key_params*))
@@ -1250,11 +1195,7 @@ static int cfg80211_rtw_get_key(struct w
 }
 
 static int cfg80211_rtw_del_key(struct wiphy *wiphy, struct net_device *ndev,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 				u8 key_index, bool pairwise, const u8 *mac_addr)
-#else	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
-				u8 key_index, const u8 *mac_addr)
-#endif	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
@@ -1271,24 +1212,14 @@ static int cfg80211_rtw_del_key(struct w
 }
 
 static int cfg80211_rtw_set_default_key(struct wiphy *wiphy,
-	struct net_device *ndev, u8 key_index
-	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
-	, bool unicast, bool multicast
-	#endif
-	)
+					struct net_device *ndev, u8 key_index,
+					bool unicast, bool multicast)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 
-		DBG_871X(FUNC_NDEV_FMT" key_index=%d"
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
-		", unicast=%d, multicast=%d"
-		#endif
-		".\n", FUNC_NDEV_ARG(ndev), key_index
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
-		, unicast, multicast
-		#endif
-		);
+	DBG_871X(FUNC_NDEV_FMT" key_index=%d, unicast=%d, multicast=%d.\n",
+		 FUNC_NDEV_ARG(ndev), key_index, unicast, multicast);
 
 	if ((key_index < WEP_KEYS) && ((psecuritypriv->dot11PrivacyAlgrthm == _WEP40_) || (psecuritypriv->dot11PrivacyAlgrthm == _WEP104_))) /* set wep default key */
 	{
@@ -1442,9 +1373,7 @@ static int cfg80211_rtw_change_iface(str
 	case NL80211_IFTYPE_ADHOC:
 		networkType = Ndis802_11IBSS;
 		break;
-#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE))
 	case NL80211_IFTYPE_P2P_CLIENT:
-#endif
 	case NL80211_IFTYPE_STATION:
 		networkType = Ndis802_11Infrastructure;
 		#ifdef CONFIG_P2P
@@ -1462,9 +1391,7 @@ static int cfg80211_rtw_change_iface(str
 		}
 		#endif /* CONFIG_P2P */
 		break;
-#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE))
 	case NL80211_IFTYPE_P2P_GO:
-#endif
 	case NL80211_IFTYPE_AP:
 		networkType = Ndis802_11APMode;
 		#ifdef CONFIG_P2P
@@ -1681,11 +1608,8 @@ static int rtw_cfg80211_set_probe_req_wp
 	return ret;
 }
 
-static int cfg80211_rtw_scan(struct wiphy *wiphy
-	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
-	, struct net_device *ndev
-	#endif
-	, struct cfg80211_scan_request *request)
+static int cfg80211_rtw_scan(struct wiphy *wiphy,
+			     struct cfg80211_scan_request *request)
 {
 	int i;
 	u8 _status = false;
@@ -2539,24 +2463,15 @@ static int cfg80211_rtw_disconnect(struc
 }
 
 static int cfg80211_rtw_set_txpower(struct wiphy *wiphy,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0))
-	struct wireless_dev *wdev,
-#endif
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)) || defined(COMPAT_KERNEL_RELEASE)
-	enum nl80211_tx_power_setting type, int mbm)
-#else
-	enum tx_power_setting type, int dbm)
-#endif
+				    struct wireless_dev *wdev,
+				    enum nl80211_tx_power_setting type, int mbm)
 {
 	DBG_8192C("%s\n", __func__);
 	return 0;
 }
 
 static int cfg80211_rtw_get_txpower(struct wiphy *wiphy,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0))
-	struct wireless_dev *wdev,
-#endif
-	int *dbm)
+				    struct wireless_dev *wdev, int *dbm)
 {
 	DBG_8192C("%s\n", __func__);
 	*dbm = (12);
@@ -2723,7 +2638,7 @@ void rtw_cfg80211_indicate_sta_assoc(_ad
 
 	#ifdef COMPAT_KERNEL_RELEASE
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
-	#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
+	#elif !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
 	#else /* COMPAT_KERNEL_RELEASE */
 	{
@@ -2754,9 +2669,9 @@ void rtw_cfg80211_indicate_sta_disassoc(
 	DBG_8192C("%s(padapter=%p,%s)\n", __func__, padapter, ndev->name);
 
 #if defined(RTW_USE_CFG80211_STA_EVENT) || defined(COMPAT_KERNEL_RELEASE)
-	cfg80211_del_sta(ndev, da, GFP_ATOMIC);
+	xcfg80211_del_sta(ndev, da, GFP_ATOMIC);
 #else /* defined(RTW_USE_CFG80211_STA_EVENT) */
-	channel = pmlmeext->cur_channel;
+	ychannel = pmlmeext->cur_channel;
 	if (channel <= RTW_CH_MAX_2G_CHANNEL)
 		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 	else
@@ -2784,7 +2699,7 @@ void rtw_cfg80211_indicate_sta_disassoc(
 
 	#ifdef COMPAT_KERNEL_RELEASE
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, mgmt_buf, frame_len, GFP_ATOMIC);
-	#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
+	#elif !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, mgmt_buf, frame_len, GFP_ATOMIC);
 	#else /* COMPAT_KERNEL_RELEASE */
 	cfg80211_send_disassoc(padapter->pnetdev, mgmt_buf, frame_len);
@@ -2980,17 +2895,12 @@ static int rtw_cfg80211_monitor_if_set_m
 	return ret;
 }
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
 static const struct net_device_ops rtw_cfg80211_monitor_if_ops = {
 	.ndo_open = rtw_cfg80211_monitor_if_open,
        .ndo_stop = rtw_cfg80211_monitor_if_close,
        .ndo_start_xmit = rtw_cfg80211_monitor_if_xmit_entry,
-       #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0))
-       .ndo_set_multicast_list = rtw_cfg80211_monitor_if_set_multicast_list,
-       #endif
        .ndo_set_mac_address = rtw_cfg80211_monitor_if_set_mac_address,
 };
-#endif
 
 static int rtw_cfg80211_add_monitor_if (_adapter *padapter, char *name, struct net_device **ndev)
 {
@@ -3025,14 +2935,7 @@ static int rtw_cfg80211_add_monitor_if (
 	mon_ndev->name[IFNAMSIZ - 1] = 0;
 	mon_ndev->destructor = rtw_ndev_destructor;
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
 	mon_ndev->netdev_ops = &rtw_cfg80211_monitor_if_ops;
-#else
-	mon_ndev->open = rtw_cfg80211_monitor_if_open;
-	mon_ndev->stop = rtw_cfg80211_monitor_if_close;
-	mon_ndev->hard_start_xmit = rtw_cfg80211_monitor_if_xmit_entry;
-	mon_ndev->set_mac_address = rtw_cfg80211_monitor_if_set_mac_address;
-#endif
 
 	pnpi = netdev_priv(mon_ndev);
 	pnpi->priv = padapter;
@@ -3073,21 +2976,11 @@ out:
 	return ret;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
-static struct wireless_dev *
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
-static struct net_device *
-#else
-static int
-#endif
-	cfg80211_rtw_add_virtual_intf(
-		struct wiphy *wiphy,
-	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0))
-		const char *name,
-	#else
-		char *name,
-	#endif
-		enum nl80211_iftype type, u32 *flags, struct vif_params *params)
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     const char *name,
+					     enum nl80211_iftype type,
+					     u32 *flags,
+					     struct vif_params *params)
 {
 	int ret = 0;
 	struct net_device* ndev = NULL;
@@ -3106,17 +2999,11 @@ static int
 	case NL80211_IFTYPE_MONITOR:
 		ret = rtw_cfg80211_add_monitor_if (padapter, (char *)name, &ndev);
 		break;
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	case NL80211_IFTYPE_P2P_CLIENT:
-#endif
 	case NL80211_IFTYPE_STATION:
 		ret = -ENODEV;
 		break;
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	case NL80211_IFTYPE_P2P_GO:
-#endif
 	case NL80211_IFTYPE_AP:
 		ret = -ENODEV;
 		break;
@@ -3128,28 +3015,15 @@ static int
 
 	DBG_871X(FUNC_ADPT_FMT" ndev:%p, ret:%d\n", FUNC_ADPT_ARG(padapter), ndev, ret);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
 	return ndev ? ndev->ieee80211_ptr : ERR_PTR(ret);
-#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
-	return ndev ? ndev : ERR_PTR(ret);
-#else
-	return ret;
-#endif
 }
 
 static int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
-	struct wireless_dev *wdev
-#else
-	struct net_device *ndev
-#endif
-)
+					 struct wireless_dev *wdev)
 {
 	struct rtw_wdev_priv *pwdev_priv = (struct rtw_wdev_priv *)wiphy_priv(wiphy);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
 	struct net_device *ndev;
 	ndev = wdev ? wdev->netdev : NULL;
-#endif
 
 	if (!ndev)
 		goto exit;
@@ -3255,41 +3129,6 @@ static int rtw_add_beacon(_adapter *adap
 	return ret;
 }
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)) && !defined(COMPAT_KERNEL_RELEASE)
-static int	cfg80211_rtw_add_beacon(struct wiphy *wiphy, struct net_device *ndev,
-			      struct beacon_parameters *info)
-{
-	int ret=0;
-	_adapter *adapter = wiphy_to_adapter(wiphy);
-
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-	ret = rtw_add_beacon(adapter, info->head, info->head_len, info->tail, info->tail_len);
-
-	return ret;
-}
-
-static int	cfg80211_rtw_set_beacon(struct wiphy *wiphy, struct net_device *ndev,
-			      struct beacon_parameters *info)
-{
-	_adapter *padapter = wiphy_to_adapter(wiphy);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-
-	pmlmeext->bstart_bss = true;
-
-	cfg80211_rtw_add_beacon(wiphy, ndev, info);
-
-	return 0;
-}
-
-static int	cfg80211_rtw_del_beacon(struct wiphy *wiphy, struct net_device *ndev)
-{
-	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-
-	return 0;
-}
-#else
 static int cfg80211_rtw_start_ap(struct wiphy *wiphy, struct net_device *ndev,
 								struct cfg80211_ap_settings *settings)
 {
@@ -3336,9 +3175,7 @@ static int cfg80211_rtw_stop_ap(struct w
 	return 0;
 }
 
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)) */
-
-static int	cfg80211_rtw_add_station(struct wiphy *wiphy, struct net_device *ndev,
+static int cfg80211_rtw_add_station(struct wiphy *wiphy, struct net_device *ndev,
 			       u8 *mac, struct station_parameters *params)
 {
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
@@ -3457,15 +3294,11 @@ static int	cfg80211_rtw_change_bss(struc
 	return 0;
 }
 
-static int	cfg80211_rtw_set_channel(struct wiphy *wiphy
-	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
-	, struct net_device *ndev
-	#endif
-	, struct ieee80211_channel *chan, enum nl80211_channel_type channel_type)
+static int rtw_set_channel(struct wiphy *wiphy, struct net_device *ndev,
+			   struct ieee80211_channel *chan,
+			   enum nl80211_channel_type channel_type)
 {
-	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-	#endif
 
 	return 0;
 }
@@ -3512,11 +3345,7 @@ indicate:
 	else
 		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
-#else
-	cfg80211_rx_action(padapter->pnetdev, freq, pmgmt_frame, frame_len, GFP_ATOMIC);
-#endif
 }
 
 void rtw_cfg80211_rx_p2p_action_public(_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
@@ -3550,11 +3379,7 @@ indicate:
 	else
 		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
-#else
-	cfg80211_rx_action(padapter->pnetdev, freq, pmgmt_frame, frame_len, GFP_ATOMIC);
-#endif
 }
 
 void rtw_cfg80211_rx_action(_adapter *adapter, u8 *frame, uint frame_len, const char*msg)
@@ -3580,11 +3405,7 @@ void rtw_cfg80211_rx_action(_adapter *ad
 	else
 		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	rtw_cfg80211_rx_mgmt(adapter, freq, 0, frame, frame_len, GFP_ATOMIC);
-#else
-	cfg80211_rx_action(adapter->pnetdev, freq, frame, frame_len, GFP_ATOMIC);
-#endif
 }
 
 #ifdef CONFIG_P2P
@@ -3795,15 +3616,8 @@ void rtw_cfg80211_issue_p2p_provision_re
 }
 
 static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
 	struct wireless_dev *wdev,
-#else
-	struct net_device *ndev,
-#endif
 	struct ieee80211_channel * channel,
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
-	enum nl80211_channel_type channel_type,
-#endif
 	unsigned int duration, u64 *cookie)
 {
 	s32 err = 0;
@@ -3838,9 +3652,6 @@ static s32 cfg80211_rtw_remain_on_channe
 	}
 
 	memcpy(&pcfg80211_wdinfo->remain_on_ch_channel, channel, sizeof(struct ieee80211_channel));
-	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
-	pcfg80211_wdinfo->remain_on_ch_type= channel_type;
-	#endif
 	pcfg80211_wdinfo->remain_on_ch_cookie= *cookie;
 
 	rtw_scan_abort(padapter);
@@ -3951,11 +3762,7 @@ exit:
 }
 
 static s32 cfg80211_rtw_cancel_remain_on_channel(struct wiphy *wiphy,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
 	struct wireless_dev *wdev,
-#else
-	struct net_device *ndev,
-#endif
 	u64 cookie)
 {
 	s32 err = 0;
@@ -4123,31 +3930,13 @@ exit:
 }
 
 static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
 	struct wireless_dev *wdev,
-#else
-	struct net_device *ndev,
-#endif
 	struct ieee80211_channel *chan,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
 	bool offchan,
-#endif
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
-	enum nl80211_channel_type channel_type,
-	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
-	bool channel_type_valid,
-	#endif
-#endif
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
 	unsigned int wait,
-#endif
 	const u8 *buf, size_t len,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	bool no_cck,
-#endif
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
 	bool dont_wait_for_ack,
-#endif
 	u64 *cookie)
 {
 	_adapter *padapter = (_adapter *)wiphy_to_adapter(wiphy);
@@ -4166,30 +3955,12 @@ static int cfg80211_rtw_mgmt_tx(struct w
 	*cookie = (unsigned long) buf;
 
 #ifdef CONFIG_DEBUG_CFG80211
-	DBG_871X(FUNC_ADPT_FMT" len=%zu, ch=%d"
-	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
-		", ch_type=%d"
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
-		", channel_type_valid=%d"
-		#endif
-	#endif
-		"\n", FUNC_ADPT_ARG(padapter),
-		len, tx_ch
-	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
-		, channel_type
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
-		, channel_type_valid
-		#endif
-	#endif
-	);
+	DBG_871X(FUNC_ADPT_FMT" len=%zu, ch=%d\n",
+		 FUNC_ADPT_ARG(padapter), len, tx_ch);
 #endif /* CONFIG_DEBUG_CFG80211 */
 
 	/* indicate ack before issue frame to avoid racing with rsp frame */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	rtw_cfg80211_mgmt_tx_status(padapter, *cookie, buf, len, ack, GFP_KERNEL);
-#elif  (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,34) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,35))
-	cfg80211_action_tx_status(ndev, *cookie, buf, len, ack, GFP_KERNEL);
-#endif
 
 	if (rtw_action_frame_parse(buf, len, &category, &action) == false) {
 		DBG_8192C(FUNC_ADPT_FMT" frame_control:0x%x\n", FUNC_ADPT_ARG(padapter),
@@ -4240,11 +4011,7 @@ exit:
 }
 
 static void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
 	struct wireless_dev *wdev,
-#else
-	struct net_device *ndev,
-#endif
 	u16 frame_type, bool reg)
 {
 	_adapter *adapter = wiphy_to_adapter(wiphy);
@@ -4607,10 +4374,10 @@ static struct cfg80211_ops rtw_cfg80211_
 	.flush_pmksa = cfg80211_rtw_flush_pmksa,
 
 #ifdef CONFIG_92D_AP_MODE
-	.add_virtual_intf = cfg80211_rtw_add_virtual_intf,
+	.add_virtual_intf = add_virtual_intf,
 	.del_virtual_intf = cfg80211_rtw_del_virtual_intf,
 
-	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)) && !defined(COMPAT_KERNEL_RELEASE)
+	#if !defined(COMPAT_KERNEL_RELEASE)
 	.add_beacon = cfg80211_rtw_add_beacon,
 	.set_beacon = cfg80211_rtw_set_beacon,
 	.del_beacon = cfg80211_rtw_del_beacon,
@@ -4625,9 +4392,6 @@ static struct cfg80211_ops rtw_cfg80211_
 	.change_station = cfg80211_rtw_change_station,
 	.dump_station = cfg80211_rtw_dump_station,
 	.change_bss = cfg80211_rtw_change_bss,
-	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
-	.set_channel = cfg80211_rtw_set_channel,
-	#endif
 #endif /* CONFIG_92D_AP_MODE */
 
 #ifdef CONFIG_P2P
@@ -4635,12 +4399,8 @@ static struct cfg80211_ops rtw_cfg80211_
 	.cancel_remain_on_channel = cfg80211_rtw_cancel_remain_on_channel,
 #endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	.mgmt_tx = cfg80211_rtw_mgmt_tx,
 	.mgmt_frame_register = cfg80211_rtw_mgmt_frame_register,
-#elif  (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,34) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,35))
-	.action = cfg80211_rtw_mgmt_tx,
-#endif
 };
 
 static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap, enum ieee80211_band band, u8 rf_type)
@@ -4724,29 +4484,6 @@ void rtw_cfg80211_init_wiphy(_adapter *p
 	}
 }
 
-/*
-struct ieee80211_iface_limit rtw_limits[] = {
-	{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION)
-					| BIT(NL80211_IFTYPE_ADHOC)
-#ifdef CONFIG_92D_AP_MODE
-					| BIT(NL80211_IFTYPE_AP)
-#endif
-#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE))
-					| BIT(NL80211_IFTYPE_P2P_CLIENT)
-					| BIT(NL80211_IFTYPE_P2P_GO)
-#endif
-	},
-	{.max = 1, .types = BIT(NL80211_IFTYPE_MONITOR)},
-};
-
-struct ieee80211_iface_combination rtw_combinations = {
-	.limits = rtw_limits,
-	.n_limits = ARRAY_SIZE(rtw_limits),
-	.max_interfaces = 2,
-	.num_different_channels = 1,
-};
-*/
-
 static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
 {
 
@@ -4756,27 +4493,23 @@ static void rtw_cfg80211_preinit_wiphy(_
 	wiphy->max_scan_ie_len = RTW_SCAN_IE_LEN_MAX;
 	wiphy->max_num_pmkids = RTW_MAX_NUM_PMKIDS;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
 	wiphy->max_remain_on_channel_duration = RTW_MAX_REMAIN_ON_CHANNEL_DURATION;
-#endif
 
-	wiphy->interface_modes =	BIT(NL80211_IFTYPE_STATION)
-								| BIT(NL80211_IFTYPE_ADHOC)
+	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+		 		 BIT(NL80211_IFTYPE_ADHOC) |
 #ifdef CONFIG_92D_AP_MODE
-								| BIT(NL80211_IFTYPE_AP)
-								| BIT(NL80211_IFTYPE_MONITOR)
+				 BIT(NL80211_IFTYPE_AP) |
+				 BIT(NL80211_IFTYPE_MONITOR) |
 #endif
-#if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE))
-								| BIT(NL80211_IFTYPE_P2P_CLIENT)
-								| BIT(NL80211_IFTYPE_P2P_GO)
+#if defined(CONFIG_P2P)
+				 BIT(NL80211_IFTYPE_P2P_CLIENT) |
+				 BIT(NL80211_IFTYPE_P2P_GO) |
 #endif
-								;
+				 0;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 #ifdef CONFIG_92D_AP_MODE
 	wiphy->mgmt_stypes = rtw_cfg80211_default_mgmt_stypes;
 #endif /* CONFIG_92D_AP_MODE */
-#endif
 
 	wiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);
 
@@ -4793,14 +4526,8 @@ static void rtw_cfg80211_preinit_wiphy(_
 	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11A) */
 		wiphy->bands[IEEE80211_BAND_5GHZ] = rtw_spt_band_alloc(IEEE80211_BAND_5GHZ);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38) && LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
-	wiphy->flags |= WIPHY_FLAG_SUPPORTS_SEPARATE_DEFAULT_KEYS;
-#endif
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
 	wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
 	wiphy->flags |= WIPHY_FLAG_OFFCHAN_TX | WIPHY_FLAG_HAVE_AP_SME;
-#endif
 
 	if (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
 		wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -30,11 +30,6 @@
 #include <usb_ops.h>
 #include <linux/vmalloc.h>
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 27))
-#define  iwe_stream_add_event(a, b, c, d, e)  iwe_stream_add_event(b, c, d, e)
-#define  iwe_stream_add_point(a, b, c, d, e)  iwe_stream_add_point(b, c, d, e)
-#endif
-
 #define RTL_IOCTL_WPA_SUPPLICANT	(SIOCIWFIRSTPRIV+30)
 
 #define SCAN_ITEM_SIZE 768
@@ -8417,10 +8412,7 @@ static struct iw_statistics *rtw_get_wir
 		piwstats->qual.qual = tmp_qual;
 		piwstats->qual.noise = tmp_noise;
 	}
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 14))
 	piwstats->qual.updated = IW_QUAL_ALL_UPDATED ;/* IW_QUAL_DBM; */
-#else
-#endif
 
 	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
 	piwstats->qual.updated = piwstats->qual.updated | IW_QUAL_DBM;
@@ -8434,7 +8426,7 @@ static struct iw_statistics *rtw_get_wir
 struct iw_handler_def rtw_handlers_def = {
 	.standard = rtw_handlers,
 	.num_standard = sizeof(rtw_handlers) / sizeof(iw_handler),
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)) || defined(CONFIG_WEXT_PRIV)
+#if defined(CONFIG_WEXT_PRIV)
 	.private = rtw_private_handler,
 	.private_args = (struct iw_priv_args *)rtw_private_args,
 	.num_private = sizeof(rtw_private_handler) / sizeof(iw_handler),
--- a/drivers/staging/rtl8192du/os_dep/mlme_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/mlme_linux.c
@@ -335,13 +335,11 @@ static int mgnt_netdev_close(struct net_
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
 static const struct net_device_ops rtl871x_mgnt_netdev_ops = {
 	.ndo_open = mgnt_netdev_open,
        .ndo_stop = mgnt_netdev_close,
        .ndo_start_xmit = mgnt_xmit_entry,
 };
-#endif
 
 int hostapd_mode_init(struct rtw_adapter *padapter)
 {
@@ -360,22 +358,10 @@ int hostapd_mode_init(struct rtw_adapter
 	phostapdpriv->padapter= padapter;
 	padapter->phostapdpriv = phostapdpriv;
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
-
 	DBG_8192D("register rtl871x_mgnt_netdev_ops to netdev_ops\n");
 
 	pnetdev->netdev_ops = &rtl871x_mgnt_netdev_ops;
 
-#else
-
-	pnetdev->open = mgnt_netdev_open;
-
-	pnetdev->stop = mgnt_netdev_close;
-
-	pnetdev->hard_start_xmit = mgnt_xmit_entry;
-
-#endif
-
 	pnetdev->watchdog_timeo = HZ; /* 1 second timeout */
 
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -250,7 +250,7 @@ void rtw_proc_init_one(struct net_device
 {
 }
 
-#else	/* LINUX_VERSION_CODE > KERNEL_VERSION(3, 8. 0) */
+#else
 void rtw_proc_init_one(struct net_device *dev)
 {
 	struct proc_dir_entry *dir_dev = NULL;
@@ -270,11 +270,7 @@ void rtw_proc_init_one(struct net_device
 		else
 			memcpy(rtw_proc_name, RTW_PROC_NAME, sizeof(RTW_PROC_NAME));
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
-		rtw_proc = create_proc_entry(rtw_proc_name, S_IFDIR, proc_net);
-#else
 		rtw_proc = create_proc_entry(rtw_proc_name, S_IFDIR, init_net.proc_net);
-#endif
 		if (rtw_proc == NULL) {
 			DBG_8192D(KERN_ERR "Unable to create rtw_proc directory\n");
 			return;
@@ -305,11 +301,7 @@ void rtw_proc_init_one(struct net_device
 		if (dir_dev == NULL) {
 			if (rtw_proc_cnt == 0) {
 				if (rtw_proc) {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
-					remove_proc_entry(rtw_proc_name, proc_net);
-#else
 					remove_proc_entry(rtw_proc_name, init_net.proc_net);
-#endif
 					rtw_proc = NULL;
 				}
 			}
@@ -638,11 +630,7 @@ void rtw_proc_remove_one(struct net_devi
 			remove_proc_entry("ver_info", rtw_proc);
 
 			remove_proc_entry("log_level", rtw_proc);
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
-			remove_proc_entry(rtw_proc_name, proc_net);
-#else
 			remove_proc_entry(rtw_proc_name, init_net.proc_net);
-#endif
 			rtw_proc = NULL;
 		}
 	}
@@ -793,7 +781,6 @@ static struct net_device_stats *rtw_net_
 	return &padapter->stats;
 }
 
-#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 35))
 /*
  * AC to queue mapping
  *
@@ -828,12 +815,8 @@ static unsigned int rtw_classify8021d(st
 	return dscp >> 5;
 }
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 12, 0))
-static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb)
-#else
 static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb,
 			    void *accel)
-#endif
 {
 	struct rtw_adapter	*padapter = rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -873,21 +856,15 @@ u16 rtw_recv_select_queue(struct sk_buff
 	return rtw_1d_to_queue[priority];
 }
 
-#endif
-
-#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
 static const struct net_device_ops rtw_netdev_ops = {
 	.ndo_open = netdev_open,
 	.ndo_stop = netdev_close,
 	.ndo_start_xmit = rtw_xmit_entry,
-#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 35))
 	.ndo_select_queue	= rtw_select_queue,
-#endif
 	.ndo_set_mac_address = rtw_net_set_mac_address,
 	.ndo_get_stats = rtw_net_get_stats,
 	.ndo_do_ioctl = rtw_ioctl,
 };
-#endif
 
 int rtw_init_netdev_name(struct net_device *pnetdev, const char *ifname)
 {
@@ -900,16 +877,8 @@ int rtw_init_netdev_name(struct net_devi
 
 	if (padapter->bDongle == 1)
 	{
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
-		TargetNetdev = dev_get_by_name("wlan0");
-#else
-	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
-		devnet = pnetdev->nd_net;
-	#else
 		devnet = dev_net(pnetdev);
-	#endif
 		TargetNetdev = dev_get_by_name(devnet, "wlan0");
-#endif
 		if (TargetNetdev) {
 			DBG_8192D("Force onboard module driver disappear !!!\n");
 			target_adapter = rtw_netdev_priv(TargetNetdev);
@@ -962,21 +931,8 @@ struct net_device *rtw_init_netdev(struc
 	padapter = rtw_netdev_priv(pnetdev);
 	padapter->pnetdev = pnetdev;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
-	SET_MODULE_OWNER(pnetdev);
-#endif
-
-#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
 	DBG_8192D("register rtw_netdev_ops to netdev_ops\n");
 	pnetdev->netdev_ops = &rtw_netdev_ops;
-#else
-	pnetdev->open = netdev_open;
-	pnetdev->stop = netdev_close;
-	pnetdev->hard_start_xmit = rtw_xmit_entry;
-	pnetdev->set_mac_address = rtw_net_set_mac_address;
-	pnetdev->get_stats = rtw_net_get_stats;
-	pnetdev->do_ioctl = rtw_ioctl;
-#endif
 
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
 	pnetdev->features |= NETIF_F_IP_CSUM;
@@ -1141,12 +1097,6 @@ u8 rtw_reset_drv_sw(struct rtw_adapter *
 
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY |_FW_UNDER_LINKING);
 
-#ifdef CONFIG_AUTOSUSPEND
-	#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 22) && LINUX_VERSION_CODE<= KERNEL_VERSION(2, 6, 34))
-		adapter_to_dvobj(padapter)->pusbdev->autosuspend_disabled = 1;/* autosuspend disabled by the user */
-	#endif
-#endif
-
 #ifdef DBG_CONFIG_ERROR_DETECT
 	rtw_hal_sreset_reset_value(padapter);
 #endif
@@ -1491,7 +1441,6 @@ static int netdev_vir_if_close(struct ne
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
 static const struct net_device_ops rtw_netdev_vir_if_ops = {
 	 .ndo_open = netdev_vir_if_open,
         .ndo_stop = netdev_vir_if_close,
@@ -1499,11 +1448,8 @@ static const struct net_device_ops rtw_n
         .ndo_set_mac_address = rtw_net_set_mac_address,
         .ndo_get_stats = rtw_net_get_stats,
         .ndo_do_ioctl = rtw_ioctl,
-#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 35))
 	.ndo_select_queue	= rtw_select_queue,
-#endif
 };
-#endif
 
 _adapter *rtw_drv_add_vir_if (struct rtw_adapter *primary_padapter, char *name,
 	void (*set_intf_ops)(struct _io_ops *pops))
@@ -1528,13 +1474,8 @@ _adapter *rtw_drv_add_vir_if (struct rtw
 	if (!pnetdev)
 		goto error_rtw_drv_add_iface;
 
-#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
 	DBG_8192D("register rtw_netdev_virtual_iface_ops to netdev_ops\n");
 	pnetdev->netdev_ops = &rtw_netdev_vir_if_ops;
-#else
-	pnetdev->open = netdev_vir_if_open;
-	pnetdev->stop = netdev_vir_if_close;
-#endif
 
 #ifdef CONFIG_NO_WIRELESS_HANDLERS
 	pnetdev->wireless_handlers = NULL;
@@ -1848,7 +1789,6 @@ static int netdev_if2_close(struct net_d
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
 static const struct net_device_ops rtw_netdev_if2_ops = {
 	.ndo_open = netdev_if2_open,
         .ndo_stop = netdev_if2_close,
@@ -1856,11 +1796,8 @@ static const struct net_device_ops rtw_n
         .ndo_set_mac_address = rtw_net_set_mac_address,
         .ndo_get_stats = rtw_net_get_stats,
         .ndo_do_ioctl = rtw_ioctl,
-#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 35))
 	.ndo_select_queue	= rtw_select_queue,
-#endif
 };
-#endif
 
 struct rtw_adapter *rtw_drv_if2_init(struct rtw_adapter *primary_padapter, char *name,
 	void (*set_intf_ops)(struct _io_ops *pops))
@@ -1875,13 +1812,8 @@ struct rtw_adapter *rtw_drv_if2_init(str
 	if (!pnetdev)
 		goto error_rtw_drv_if2_init;
 
-#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
 	DBG_8192D("register rtw_netdev_if2_ops to netdev_ops\n");
 	pnetdev->netdev_ops = &rtw_netdev_if2_ops;
-#else
-	pnetdev->open = netdev_if2_open;
-	pnetdev->stop = netdev_if2_close;
-#endif
 
 #ifdef CONFIG_NO_WIRELESS_HANDLERS
 	pnetdev->wireless_handlers = NULL;
@@ -2069,45 +2001,26 @@ void netdev_br_init(struct net_device *n
 {
 	struct rtw_adapter *adapter = (struct rtw_adapter *)rtw_netdev_priv(netdev);
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
 	rcu_read_lock();
-#endif	/*  (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35)) */
 
-	{
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-		if (netdev->br_port)
-#else   /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
-		if (rcu_dereference(adapter->pnetdev->rx_handler_data))
-#endif  /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
-		{
-			struct net_device *br_netdev;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
-			br_netdev = dev_get_by_name(CONFIG_BR_EXT_BRNAME);
-#else	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)) */
-			struct net *devnet = NULL;
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
-			devnet = netdev->nd_net;
-#else	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)) */
-			devnet = dev_net(netdev);
-#endif	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)) */
-
-			br_netdev = dev_get_by_name(devnet, CONFIG_BR_EXT_BRNAME);
-#endif	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)) */
-
-			if (br_netdev) {
-				memcpy(adapter->br_mac, br_netdev->dev_addr, ETH_ALEN);
-				dev_put(br_netdev);
-			} else
-				printk("%s()-%d: dev_get_by_name(%s) failed!", __func__, __LINE__, CONFIG_BR_EXT_BRNAME);
-		}
+	if (rcu_dereference(adapter->pnetdev->rx_handler_data)) {
+		struct net_device *br_netdev;
+		struct net *devnet = NULL;
+
+		devnet = dev_net(netdev);
 
-		adapter->eth_br_ext_info.addPPPoETag = 1;
+		br_netdev = dev_get_by_name(devnet, CONFIG_BR_EXT_BRNAME);
+
+		if (br_netdev) {
+			memcpy(adapter->br_mac, br_netdev->dev_addr, ETH_ALEN);
+			dev_put(br_netdev);
+		} else
+			printk("%s()-%d: dev_get_by_name(%s) failed!", __func__, __LINE__, CONFIG_BR_EXT_BRNAME);
 	}
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+	adapter->eth_br_ext_info.addPPPoETag = 1;
+
 	rcu_read_unlock();
-#endif	/*  (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35)) */
 }
 #endif /* CONFIG_BR_EXT */
 
--- a/drivers/staging/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8192du/os_dep/osdep_service.c
@@ -123,18 +123,12 @@ u32 _rtw_down_sema(struct  semaphore *se
 
 void	_rtw_mutex_init(_mutex *pmutex)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 	mutex_init(pmutex);
-#else
-	init_MUTEX(pmutex);
-#endif
 }
 
 void	_rtw_mutex_free(_mutex *pmutex)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 	mutex_destroy(pmutex);
-#endif
 }
 
 void	_rtw_spinlock_init(spinlock_t *plock)
@@ -580,11 +574,7 @@ struct net_device *rtw_alloc_etherdev_wi
 	struct net_device *pnetdev;
 	struct rtw_netdev_priv_indicator *pnpi;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	pnetdev = alloc_etherdev_mq(sizeof(struct rtw_netdev_priv_indicator), 4);
-#else
-	pnetdev = alloc_etherdev(sizeof(struct rtw_netdev_priv_indicator));
-#endif
 	if (!pnetdev)
 		goto RETURN;
 
@@ -601,11 +591,7 @@ struct net_device *rtw_alloc_etherdev(in
 	struct net_device *pnetdev;
 	struct rtw_netdev_priv_indicator *pnpi;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	pnetdev = alloc_etherdev_mq(sizeof(struct rtw_netdev_priv_indicator), 4);
-#else
-	pnetdev = alloc_etherdev(sizeof(struct rtw_netdev_priv_indicator));
-#endif
 	if (!pnetdev)
 		goto RETURN;
 
@@ -642,10 +628,6 @@ RETURN:
 	return;
 }
 
-/*
-* Jeff: this function should be called under ioctl (rtnl_lock is accquired) while
-* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
-*/
 int rtw_change_ifname(struct rtw_adapter *padapter, const char *ifname)
 {
 	struct net_device *pnetdev;
@@ -665,11 +647,9 @@ int rtw_change_ifname(struct rtw_adapter
 		rereg_priv->old_pnetdev = NULL;
 	}
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
 	if (!rtnl_is_locked())
 		unregister_netdev(cur_pnetdev);
 	else
-#endif
 		unregister_netdevice(cur_pnetdev);
 
 	rtw_proc_remove_one(cur_pnetdev);
@@ -688,11 +668,9 @@ int rtw_change_ifname(struct rtw_adapter
 
 	memcpy(pnetdev->dev_addr, padapter->eeprompriv.mac_addr, ETH_ALEN);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
 	if (!rtnl_is_locked())
 		ret = register_netdev(pnetdev);
 	else
-#endif
 		ret = register_netdevice(pnetdev);
 
 	if (ret != 0) {
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -255,9 +255,7 @@ int rtw_recv_indicatepkt(struct rtw_adap
 				struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;
 
 				skb->dev = pnetdev;
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 				skb_set_queue_mapping(skb, rtw_recv_select_queue(skb));
-#endif /* LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35) */
 
 				rtw_xmit_entry(skb, pnetdev);
 
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -25,11 +25,7 @@
 
 #if defined(RTW_ENABLE_WIFI_CONTROL_FUNC)
 #include <linux/platform_device.h>
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
 #include <linux/wlan_plat.h>
-#else
-#include <linux/wifi_tiwlan.h>
-#endif
 #endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
 
 static const char *android_wifi_cmd_str[ANDROID_WIFI_CMD_MAX] = {
@@ -623,7 +619,6 @@ int wifi_set_power(int on, unsigned long
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
 int wifi_get_mac_addr(unsigned char *buf)
 {
 	DBG_8192D("%s\n", __func__);
@@ -634,9 +629,7 @@ int wifi_get_mac_addr(unsigned char *buf
 	}
 	return -EOPNOTSUPP;
 }
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)) */
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)) || defined(COMPAT_KERNEL_RELEASE)
 void *wifi_get_country_code(char *ccode)
 {
 	DBG_8192D("%s\n", __func__);
@@ -647,7 +640,6 @@ void *wifi_get_country_code(char *ccode)
 	}
 	return NULL;
 }
-#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)) */
 
 static int wifi_set_carddetect(int on)
 {
@@ -695,19 +687,12 @@ static int wifi_remove(struct platform_d
 static int wifi_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	DBG_8192D("##> %s\n", __func__);
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) && defined(OOB_INTR_ONLY)
-	bcmsdh_oob_intr_set(0);
-#endif
 	return 0;
 }
 
 static int wifi_resume(struct platform_device *pdev)
 {
 	DBG_8192D("##> %s\n", __func__);
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) && defined(OOB_INTR_ONLY)
-	if (dhd_os_check_if_up(bcmsdh_get_drvdata()))
-		bcmsdh_oob_intr_set(1);
-#endif
 	return 0;
 }
 
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -194,9 +194,7 @@ static struct rtw_usb_drv rtl8192d_usb_d
 	.usbdrv.id_table = rtl8192d_usb_id_tbl,
 	.usbdrv.suspend =  rtw_suspend,
 	.usbdrv.resume = rtw_resume,
-	#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
 	.usbdrv.reset_resume   = rtw_resume,
-	#endif
 	#ifdef CONFIG_AUTOSUSPEND
 	.usbdrv.supports_autosuspend = 1,
 	#endif
@@ -860,27 +858,12 @@ void autosuspend_enter(struct rtw_adapte
 
 	DBG_8192D("==>autosuspend_enter...........\n");
 
-	if (rf_off == pwrpriv->change_rfpwrstate)
-	{
-		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	if (rf_off == pwrpriv->change_rfpwrstate) {
 		usb_enable_autosuspend(dvobj->pusbdev);
-		#else
-		dvobj->pusbdev->autosuspend_disabled = 0;/* autosuspend disabled by the user */
-		#endif
 
-		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,33))
-			usb_autopm_put_interface(dvobj->pusbintf);
-		#elif (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,20))
-			usb_autopm_enable(dvobj->pusbintf);
-		#else
-			usb_autosuspend_device(dvobj->pusbdev, 1);
-		#endif
+		usb_autopm_put_interface(dvobj->pusbintf);
 	}
-	#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,32))
 	DBG_8192D("...pm_usage_cnt(%d).....\n", atomic_read(&(dvobj->pusbintf->pm_usage_cnt)));
-	#else
-	DBG_8192D("...pm_usage_cnt(%d).....\n", dvobj->pusbintf->pm_usage_cnt);
-	#endif
 }
 
 int autoresume_enter(struct rtw_adapter* padapter)
@@ -894,27 +877,14 @@ int autoresume_enter(struct rtw_adapter*
 
 	DBG_8192D("====> autoresume_enter\n");
 
-	if (rf_off == pwrpriv->rf_pwrstate)
-	{
+	if (rf_off == pwrpriv->rf_pwrstate) {
 		pwrpriv->ps_flag = false;
-		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,33))
-			if (usb_autopm_get_interface(dvobj->pusbintf) < 0)
-			{
-				DBG_8192D("can't get autopm: %d\n", result);
-				result = _FAIL;
-				goto error_exit;
-			}
-		#elif (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,20))
-			usb_autopm_disable(dvobj->pusbintf);
-		#else
-			usb_autoresume_device(dvobj->pusbdev, 1);
-		#endif
-
-		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,32))
+		if (usb_autopm_get_interface(dvobj->pusbintf) < 0) {
+			DBG_8192D("can't get autopm: %d\n", result);
+			result = _FAIL;
+			goto error_exit;
+		}
 		DBG_8192D("...pm_usage_cnt(%d).....\n", atomic_read(&(dvobj->pusbintf->pm_usage_cnt)));
-		#else
-		DBG_8192D("...pm_usage_cnt(%d).....\n", dvobj->pusbintf->pm_usage_cnt);
-		#endif
 	}
 	DBG_8192D("<==== autoresume_enter\n");
 error_exit:
@@ -1006,9 +976,7 @@ static struct rtw_adapter *rtw_usb_if1_i
 	}
 
 #ifdef CONFIG_PM
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
-	if (padapter->pwrctrlpriv.bSupportRemoteWakeup)
-	{
+	if (padapter->pwrctrlpriv.bSupportRemoteWakeup) {
 		dvobj->pusbdev->do_remote_wakeup=1;
 		pusb_intf->needs_remote_wakeup = 1;
 		device_init_wakeup(&pusb_intf->dev, 1);
@@ -1016,32 +984,18 @@ static struct rtw_adapter *rtw_usb_if1_i
 		DBG_8192D("\n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~[%d]~~~\n",device_may_wakeup(&pusb_intf->dev));
 	}
 #endif
-#endif
 
 #ifdef CONFIG_AUTOSUSPEND
 	if (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
 	{
 		if (padapter->registrypriv.usbss_enable) {	/* autosuspend (2s delay) */
-			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,38))
 			dvobj->pusbdev->dev.power.autosuspend_delay = 0 * HZ;/* 15 * HZ; idle-delay time */
-			#else
-			dvobj->pusbdev->autosuspend_delay = 0 * HZ;/* 15 * HZ; idle-delay time */
-			#endif
 
-			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 			usb_enable_autosuspend(dvobj->pusbdev);
-			#elif  (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,34))
-			padapter->bDisableAutosuspend = dvobj->pusbdev->autosuspend_disabled ;
-			dvobj->pusbdev->autosuspend_disabled = 0;/* autosuspend disabled by the user */
-			#endif
 
 			usb_autopm_get_interface(dvobj->pusbintf);/* init pm_usage_cnt ,let it start from 1 */
 
-			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,32))
 			DBG_8192D("%s...pm_usage_cnt(%d).....\n",__func__, atomic_read(&(dvobj->pusbintf ->pm_usage_cnt)));
-			#else
-			DBG_8192D("%s...pm_usage_cnt(%d).....\n",__func__, dvobj->pusbintf ->pm_usage_cnt);
-			#endif
 		}
 	}
 #endif
@@ -1250,9 +1204,7 @@ static void rtw_dev_remove(struct usb_in
 	return;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
 extern int console_suspend_enabled;
-#endif
 
 static int __init rtw_drv_entry(void)
 {
--- a/drivers/staging/rtl8192du/os_dep/xmit_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/xmit_linux.c
@@ -162,7 +162,6 @@ void rtw_os_xmit_resource_free(struct rt
 
 void rtw_os_pkt_complete(struct rtw_adapter *padapter, struct sk_buff *pkt)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	u16	queue;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
@@ -172,10 +171,6 @@ void rtw_os_pkt_complete(struct rtw_adap
 	{
 		netif_wake_subqueue(padapter->pnetdev, queue);
 	}
-#else
-	if (netif_queue_stopped(padapter->pnetdev))
-		netif_wake_queue(padapter->pnetdev);
-#endif
 
 	dev_kfree_skb_any(pkt);
 }
@@ -266,9 +261,7 @@ int rtw_xmit_entry(struct sk_buff *pkt,
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	s32 res = 0;
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 	u16 queue;
-#endif
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("+xmit_enry\n"));
 
@@ -280,14 +273,12 @@ int rtw_xmit_entry(struct sk_buff *pkt,
 		goto drop_packet;
 	}
 
-#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 	queue = skb_get_queue_mapping(pkt);
 	/* No free space for Tx, tx_worker is too slow */
 	if (pxmitpriv->hwxmits[queue].accnt > NR_XMITFRAME/2) {
 		netif_stop_subqueue(padapter->pnetdev, queue);
 		return NETDEV_TX_BUSY;
 	}
-#endif
 
 	if (!rtw_mc2u_disable
 		&& check_fwstate(pmlmepriv, WIFI_AP_STATE) == true

From ceff89ea776fb081d1721203a5d23deb7e02ce94 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Thu, 20 Feb 2014 13:04:46 -0600
Subject: [PATCH 226/390] rtl8192du: Remove CONFIG_TDLS

We are not supporting TDLS (Tunneled Direct Link Setup).

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 Makefile               |    1 -
 core/rtw_cmd.c         |   61 +-
 core/rtw_mlme.c        |   30 +-
 core/rtw_mlme_ext.c    |  251 +----
 core/rtw_pwrctrl.c     |   57 --
 core/rtw_recv.c        |  265 +-----
 core/rtw_security.c    |  126 ---
 core/rtw_sta_mgt.c     |   19 -
 core/rtw_tdls.c        | 2395 ------------------------------------------------
 core/rtw_wlan_util.c   |   27 -
 core/rtw_xmit.c        |  412 +--------
 hal/rtl8192d_dm.c      |   21 +-
 hal/rtl8192du_xmit.c   |   39 +-
 hal/usb_halinit.c      |   59 +-
 include/drv_types.h    |    4 -
 include/ieee80211.h    |   20 -
 include/rtw_mlme_ext.h |   34 -
 include/rtw_security.h |    9 -
 include/rtw_tdls.h     |  113 ---
 include/rtw_xmit.h     |    5 +-
 include/sta_info.h     |   33 -
 os_dep/ioctl_linux.c   |  239 +----
 os_dep/os_intfs.c      |   18 +-
 23 files changed, 63 insertions(+), 4175 deletions(-)
 delete mode 100644 core/rtw_tdls.c

--- a/drivers/staging/rtl8192du/Makefile
+++ b/drivers/staging/rtl8192du/Makefile
@@ -138,7 +138,6 @@ rtk_core :=	core/rtw_cmd.o \
 		core/rtw_ap.o \
 		core/rtw_xmit.o	\
 		core/rtw_p2p.o \
-		core/rtw_tdls.o \
 		core/rtw_br_ext.o \
 		core/rtw_sreset.o
 
--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -1152,27 +1152,15 @@ u8 rtw_setstakey_cmd(struct rtw_adapter
 
 	memcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);
 
-	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
-#ifdef CONFIG_TDLS
-		if (sta->tdls_sta_state&TDLS_LINKED_STATE)
-			psetstakey_para->algorithm = (u8)sta->dot118021XPrivacy;
-		else
-#endif /* CONFIG_TDLS */
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
 		psetstakey_para->algorithm = (unsigned char) psecuritypriv->dot11PrivacyAlgrthm;
-	} else {
+	else
 		GET_ENCRY_ALGO(psecuritypriv, sta, psetstakey_para->algorithm, false);
-	}
 
-	if (unicast_key == true) {
-#ifdef CONFIG_TDLS
-		if (sta->tdls_sta_state&TDLS_LINKED_STATE)
-			memcpy(&psetstakey_para->key, sta->tpk.tk, 16);
-		else
-#endif /* CONFIG_TDLS */
-			memcpy(&psetstakey_para->key, &sta->dot118021x_UncstKey, 16);
-	} else {
+	if (unicast_key)
+		memcpy(&psetstakey_para->key, &sta->dot118021x_UncstKey, 16);
+	else
 		memcpy(&psetstakey_para->key, &psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey, 16);
-	}
 
 	/* jeff: set this becasue at least sw key is ready */
 	padapter->securitypriv.busetkipkey = true;
@@ -1596,34 +1584,6 @@ u8 rtw_tdls_cmd(struct rtw_adapter *pada
 
 	u8 res = _SUCCESS;
 
-#ifdef CONFIG_TDLS
-
-	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_tdls_cmd\n"));
-
-	pcmdobj = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
-	if (pcmdobj == NULL) {
-		res = _FAIL;
-		goto exit;
-	}
-
-	TDLSoption = (struct TDLSoption_param *)kzalloc(sizeof(struct TDLSoption_param), GFP_ATOMIC);
-	if (TDLSoption == NULL) {
-		kfree(pcmdobj);
-		res = _FAIL;
-		goto exit;
-	}
-
-	spin_lock(&(padapter->tdlsinfo.cmd_lock));
-	memcpy(TDLSoption->addr, addr, 6);
-	TDLSoption->option = option;
-	spin_unlock(&(padapter->tdlsinfo.cmd_lock));
-	init_h2fwcmd_w_parm_no_rsp(pcmdobj, TDLSoption, GEN_CMD_CODE(_TDLS));
-	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
-
-#endif	/* CONFIG_TDLS */
-
-exit:
-
 	return res;
 }
 
@@ -1633,9 +1593,6 @@ static void traffic_status_watchdog(stru
 	u8 bBusyTraffic = false, bTxBusyTraffic = false, bRxBusyTraffic = false;
 	u8 bHigherBusyTraffic = false, bHigherBusyRxTraffic = false, bHigherBusyTxTraffic = false;
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
-#ifdef CONFIG_TDLS
-	struct tdls_info *ptdlsinfo = &(padapter->tdlsinfo);
-#endif /* CONFIG_TDLS */
 
 	/*  Determine if our traffic is busy now */
 	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
@@ -1664,14 +1621,6 @@ static void traffic_status_watchdog(stru
 				bHigherBusyTxTraffic = true;
 		}
 
-#ifdef CONFIG_TDLS
-#ifdef CONFIG_TDLS_AUTOSETUP
-		if ((ptdlsinfo->watchdog_count % TDLS_WATCHDOG_PERIOD) == 0)	/* TDLS_WATCHDOG_PERIOD * 2sec, periodically sending */
-			issue_tdls_dis_req(padapter, NULL);
-		ptdlsinfo->watchdog_count++;
-#endif /* CONFIG_TDLS_AUTOSETUP */
-#endif /* CONFIG_TDLS */
-
 		/*  check traffic for  powersaving. */
 		if (((pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod + pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) > 8) ||
 		    (pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2))
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -1126,9 +1126,7 @@ static void free_scanqueue(struct mlme_p
 
 }
 
-/*
-*rtw_free_assoc_resources: the caller has to lock pmlmepriv->lock
-*/
+/* rtw_free_assoc_resources: the caller has to lock pmlmepriv->lock */
 void rtw_free_assoc_resources(struct rtw_adapter *adapter,
 			      int lock_scanned_queue)
 {
@@ -1137,10 +1135,6 @@ void rtw_free_assoc_resources(struct rtw
 	struct sta_priv *pstapriv = &adapter->stapriv;
 	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
 
-#ifdef CONFIG_TDLS
-	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
-#endif /* CONFIG_TDLS */
-
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
 		 ("+rtw_free_assoc_resources\n"));
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
@@ -1151,23 +1145,11 @@ void rtw_free_assoc_resources(struct rtw
 	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_AP_STATE)) {
 		struct sta_info *psta;
 
-		psta =
-		    rtw_get_stainfo(&adapter->stapriv,
-				    tgt_network->network.MacAddress);
-
-#ifdef CONFIG_TDLS
-		if (ptdlsinfo->setup_state != TDLS_STATE_NONE) {
-			rtw_tdls_cmd(adapter, myid(&(adapter->eeprompriv)),
-				     TDLS_RS_RCR);
-			rtw_reset_tdls_info(adapter);
-			rtw_free_all_stainfo(adapter);
-		} else
-#endif /* CONFIG_TDLS */
-		{
-			spin_lock_bh(&(pstapriv->sta_hash_lock));
-			rtw_free_stainfo(adapter, psta);
-			spin_unlock_bh(&(pstapriv->sta_hash_lock));
-		}
+		psta = rtw_get_stainfo(&adapter->stapriv,
+				       tgt_network->network.MacAddress);
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
+		rtw_free_stainfo(adapter, psta);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 	}
 
 	if (check_fwstate
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -618,17 +618,6 @@ void mgt_dispatcher(struct rtw_adapter *
 
 	index = GetFrameSubType(pframe) >> 4;
 
-#ifdef CONFIG_TDLS
-	if ((index << 4) == WIFI_ACTION) {
-		/* category==RTW_WLAN_CATEGORY_PUBLIC, action==TDLS_DISCOVERY_RESPONSE */
-		if (*(pframe + IEEE80211_MGMT_HDR_LEN) == RTW_WLAN_CATEGORY_PUBLIC &&
-		    *(pframe + IEEE80211_MGMT_HDR_LEN + 1) == TDLS_DISCOVERY_RESPONSE) {
-			DBG_8192D("recv tdls discovery response frame\n");
-			On_TDLS_Dis_Rsp(adapt, precv_frame);
-		}
-	}
-#endif /* CONFIG_TDLS */
-
 	if (index > 13) {
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 			 ("Currently we do not support reserved sub-fr-type=%d\n",
@@ -2276,22 +2265,13 @@ unsigned int OnAction_back(struct rtw_ad
 
 	category = frame_body[0];
 	if (category == RTW_WLAN_CATEGORY_BACK) {	/*  representing Block Ack */
-#ifdef CONFIG_TDLS
-		if ((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
-		    (psta->htpriv.ht_option == true) &&
-		    (psta->htpriv.ampdu_enable == true)) {
-			/* do nothing; just don't want to return _SUCCESS; */
-		} else
-#endif /* CONFIG_TDLS */
-		if (!pmlmeinfo->HT_enable) {
+		if (!pmlmeinfo->HT_enable)
 			return _SUCCESS;
-		}
 
 		action = frame_body[1];
 		DBG_8192D("%s, action=%d\n", __func__, action);
 		switch (action) {
 		case RTW_WLAN_ACTION_ADDBA_REQ:	/* ADDBA request */
-
 			memcpy(&(pmlmeinfo->ADDBA_req), &(frame_body[2]),
 			       sizeof(struct ADDBA_request));
 			/*process_addba_req(adapt, (u8*)&(pmlmeinfo->ADDBA_req), GetAddr3Ptr(pframe)); */
@@ -2305,11 +2285,8 @@ unsigned int OnAction_back(struct rtw_ad
 			} else {
 				issue_action_BA(adapt, addr, RTW_WLAN_ACTION_ADDBA_RESP, 37);	/* reject ADDBA Req */
 			}
-
 			break;
-
 		case RTW_WLAN_ACTION_ADDBA_RESP:	/* ADDBA response */
-
 			status = RTW_GET_LE16(&frame_body[3]);
 			tid = ((frame_body[5] >> 2) & 0x7);
 
@@ -2320,10 +2297,7 @@ unsigned int OnAction_back(struct rtw_ad
 			} else {
 				psta->htpriv.agg_enable_bitmap &= ~BIT(tid);
 			}
-
-			/* DBG_8192D("marc: ADDBA RSP: %x\n", pmlmeinfo->agg_enable_bitmap); */
 			break;
-
 		case RTW_WLAN_ACTION_DELBA:	/* DELBA */
 			if ((frame_body[3] & BIT(3)) == 0) {
 				psta->htpriv.agg_enable_bitmap &=
@@ -2350,12 +2324,10 @@ unsigned int OnAction_back(struct rtw_ad
 				  pmlmeinfo->agg_enable_bitmap, reason_code);
 			/* todo: how to notify the host while receiving DELETE BA */
 			break;
-
 		default:
 			break;
 		}
 	}
-
 	return _SUCCESS;
 }
 
@@ -10722,14 +10694,6 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 #ifdef CONFIG_CONCURRENT_MODE
 		else if (is_client_associated_to_ap(adapt->pbuddy_adapter) ==
 			 true) {
-#ifdef CONFIG_TDLS
-			if (adapt->pbuddy_adapter->wdinfo.wfd_tdls_enable ==
-			    1) {
-				issue_tunneled_probe_req(adapt->
-							 pbuddy_adapter);
-			}
-#endif /* CONFIG_TDLS */
-
 			pmlmeext->sitesurvey_res.state = SCAN_TXNULL;
 
 			issue_nulldata(adapt->pbuddy_adapter, NULL, 1, 3,
@@ -10830,12 +10794,6 @@ u8 set_stakey_hdl(struct rtw_adapter *ad
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct set_stakey_parm *pparm = (struct set_stakey_parm *)pbuf;
-#ifdef CONFIG_TDLS
-	struct tdls_info *ptdlsinfo = &adapt->tdlsinfo;
-	struct sta_priv *pstapriv = &adapt->stapriv;
-	struct sta_info *psta;
-#endif /* CONFIG_TDLS */
-
 	/* cam_entry: */
 	/* 0~3 for default key */
 
@@ -10911,21 +10869,7 @@ u8 set_stakey_hdl(struct rtw_adapter *ad
 
 	ctrl = BIT(15) | ((pparm->algorithm) << 2);
 
-#ifdef CONFIG_TDLS
-	if (ptdlsinfo->clear_cam != 0) {
-		clear_cam_entry(adapt, ptdlsinfo->clear_cam);
-		ptdlsinfo->clear_cam = 0;
-
-		return H2C_SUCCESS;
-	}
-
-	psta = rtw_get_stainfo(pstapriv, pparm->addr);	/* Get TDLS Peer STA */
-	if (psta->tdls_sta_state & TDLS_LINKED_STATE) {
-		write_cam(adapt, psta->mac_id, ctrl, pparm->addr,
-			  pparm->key);
-	} else
-#endif /* CONFIG_TDLS */
-		write_cam(adapt, cam_id, ctrl, pparm->addr, pparm->key);
+	write_cam(adapt, cam_id, ctrl, pparm->addr, pparm->key);
 
 	pmlmeinfo->enc_algo = pparm->algorithm;
 
@@ -10953,18 +10897,7 @@ u8 add_ba_hdl(struct rtw_adapter *adapt,
 				RTW_WLAN_ACTION_ADDBA_REQ, (u16) pparm->tid);
 		/* _set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO); */
 		_set_timer(&psta->addba_retry_timer, ADDBA_TO);
-	}
-#ifdef CONFIG_TDLS
-	else if ((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
-		 (psta->htpriv.ht_option == true) &&
-		 (psta->htpriv.ampdu_enable == true)) {
-		issue_action_BA(adapt, pparm->addr,
-				RTW_WLAN_ACTION_ADDBA_REQ, (u16) pparm->tid);
-		/* _set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO); */
-		_set_timer(&psta->addba_retry_timer, ADDBA_TO);
-	}
-#endif /* CONFIG */
-	else {
+	} else {
 		psta->htpriv.candidate_tid_bitmap &= ~BIT(pparm->tid);
 	}
 
@@ -12256,185 +12189,7 @@ u8 set_csa_hdl(struct rtw_adapter *adapt
 #endif /* CONFIG_DFS */
 }
 
-/*  TDLS_WRCR		: write RCR DATA BIT */
-/*  TDLS_SD_PTI		: issue peer traffic indication */
-/*  TDLS_CS_OFF		: go back to the channel linked with AP, terminating channel switch procedure */
-/*  TDLS_INIT_CH_SEN	: init channel sensing, receive all data and mgnt frame */
-/*  TDLS_DONE_CH_SEN: channel sensing and report candidate channel */
-/*  TDLS_OFF_CH		: first time set channel to off channel */
-/*  TDLS_BASE_CH		: go back tp the channel linked with AP when set base channel as target channel */
-/*  TDLS_P_OFF_CH	: periodically go to off channel */
-/*  TDLS_P_BASE_CH	: periodically go back to base channel */
-/*  TDLS_RS_RCR		: restore RCR */
-/*  TDLS_CKALV_PH1	: check alive timer phase1 */
-/*  TDLS_CKALV_PH2	: check alive timer phase2 */
-/*  TDLS_FREE_STA	: free tdls sta */
 u8 tdls_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
 {
-#ifdef CONFIG_TDLS
-	struct tdls_info *ptdlsinfo = &adapt->tdlsinfo;
-	struct TDLSoption_param *TDLSoption;
-	struct sta_info *ptdls_sta;
-	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
-	struct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;
-	u8 survey_channel, i, min, option;
-
-	if (!pbuf)
-		return H2C_PARAMETERS_ERROR;
-
-	TDLSoption = (struct TDLSoption_param *)pbuf;
-
-	ptdls_sta = rtw_get_stainfo(&(adapt->stapriv), TDLSoption->addr);
-	option = TDLSoption->option;
-
-	if (ptdls_sta == NULL) {
-		if (option != TDLS_RS_RCR)
-			return H2C_REJECTED;
-	}
-
-	/* spin_lock_bh(&(ptdlsinfo->hdl_lock)); */
-	DBG_8192D("[%s] option:%d\n", __func__, option);
-
-	switch (option) {
-	case TDLS_WRCR:
-		/* As long as TDLS handshake success, we should set RCR_CBSSID_DATA bit to 0 */
-		/* such we can receive all kinds of data frames. */
-		rtw_hal_set_hwreg(adapt, HW_VAR_TDLS_WRCR, 0);
-		DBG_8192D("TDLS with %pM\n", ptdls_sta->hwaddr);
-
-		pmlmeinfo->FW_sta_info[ptdls_sta->mac_id].psta = ptdls_sta;
-		/* set TDLS sta rate. */
-		set_sta_rate(adapt, ptdls_sta);
-		break;
-	case TDLS_SD_PTI:
-		issue_tdls_peer_traffic_indication(adapt, ptdls_sta);
-		break;
-	case TDLS_CS_OFF:
-		_cancel_timer_ex(&ptdls_sta->base_ch_timer);
-		_cancel_timer_ex(&ptdls_sta->off_ch_timer);
-		SelectChannel(adapt, pmlmeext->cur_channel);
-		ptdls_sta->tdls_sta_state &= ~(TDLS_CH_SWITCH_ON_STATE |
-					       TDLS_PEER_AT_OFF_STATE |
-					       TDLS_AT_OFF_CH_STATE);
-		DBG_8192D("go back to base channel\n ");
-		issue_nulldata(adapt, NULL, 0, 0, 0);
-		break;
-	case TDLS_INIT_CH_SEN:
-		rtw_hal_set_hwreg(adapt, HW_VAR_TDLS_INIT_CH_SEN, 0);
-		pmlmeext->sitesurvey_res.channel_idx = 0;
-		ptdls_sta->option = TDLS_DONE_CH_SEN;
-		rtw_tdls_cmd(adapt, ptdls_sta->hwaddr, TDLS_DONE_CH_SEN);
-		break;
-	case TDLS_DONE_CH_SEN:
-		survey_channel =
-		    pmlmeext->channel_set[pmlmeext->sitesurvey_res.channel_idx].
-		    ChannelNum;
-		if (survey_channel) {
-			SelectChannel(adapt, survey_channel);
-			ptdlsinfo->cur_channel = survey_channel;
-			pmlmeext->sitesurvey_res.channel_idx++;
-			_set_timer(&ptdls_sta->option_timer, SURVEY_TO);
-		} else {
-			SelectChannel(adapt, pmlmeext->cur_channel);
-
-			rtw_hal_set_hwreg(adapt, HW_VAR_TDLS_DONE_CH_SEN, 0);
-
-			if (ptdlsinfo->ch_sensing == 1) {
-				ptdlsinfo->ch_sensing = 0;
-				ptdlsinfo->cur_channel = 1;
-				min = ptdlsinfo->collect_pkt_num[0];
-				for (i = 1; i < MAX_CHANNEL_NUM - 1; i++) {
-					if (min > ptdlsinfo->collect_pkt_num[i]) {
-						ptdlsinfo->cur_channel = i + 1;
-						min =
-						    ptdlsinfo->
-						    collect_pkt_num[i];
-					}
-					ptdlsinfo->collect_pkt_num[i] = 0;
-				}
-				ptdlsinfo->collect_pkt_num[0] = 0;
-				ptdlsinfo->candidate_ch =
-				    ptdlsinfo->cur_channel;
-				DBG_8192D
-				    ("TDLS channel sensing done, candidate channel: %02x\n",
-				     ptdlsinfo->candidate_ch);
-				ptdlsinfo->cur_channel = 0;
-			}
-
-			if (ptdls_sta->tdls_sta_state & TDLS_PEER_SLEEP_STATE) {
-				ptdls_sta->tdls_sta_state |=
-				    TDLS_APSD_CHSW_STATE;
-			} else {
-				/* send null data with pwrbit==1 before send ch_switching_req to peer STA. */
-				issue_nulldata(adapt, NULL, 1, 0, 0);
-
-				ptdls_sta->tdls_sta_state |=
-				    TDLS_CH_SW_INITIATOR_STATE;
-
-				issue_tdls_ch_switch_req(adapt,
-							 ptdls_sta->hwaddr);
-				DBG_8192D("issue tdls ch switch req\n");
-			}
-		}
-		break;
-	case TDLS_OFF_CH:
-		issue_nulldata(adapt, NULL, 1, 0, 0);
-		SelectChannel(adapt, ptdls_sta->off_ch);
-
-		DBG_8192D("change channel to tar ch:%02x\n", ptdls_sta->off_ch);
-		ptdls_sta->tdls_sta_state |= TDLS_AT_OFF_CH_STATE;
-		ptdls_sta->tdls_sta_state &= ~(TDLS_PEER_AT_OFF_STATE);
-		_set_timer(&ptdls_sta->option_timer,
-			   (u32) ptdls_sta->ch_switch_time);
-		break;
-	case TDLS_BASE_CH:
-		_cancel_timer_ex(&ptdls_sta->base_ch_timer);
-		_cancel_timer_ex(&ptdls_sta->off_ch_timer);
-		SelectChannel(adapt, pmlmeext->cur_channel);
-		ptdls_sta->tdls_sta_state &= ~(TDLS_CH_SWITCH_ON_STATE |
-					       TDLS_PEER_AT_OFF_STATE |
-					       TDLS_AT_OFF_CH_STATE);
-		DBG_8192D("go back to base channel\n ");
-		issue_nulldata(adapt, NULL, 0, 0, 0);
-		_set_timer(&ptdls_sta->option_timer,
-			   (u32) ptdls_sta->ch_switch_time);
-		break;
-	case TDLS_P_OFF_CH:
-		SelectChannel(adapt, pmlmeext->cur_channel);
-		issue_nulldata(adapt, NULL, 0, 0, 0);
-		DBG_8192D("change channel to base ch:%02x\n",
-			  pmlmeext->cur_channel);
-		ptdls_sta->tdls_sta_state &=
-		    ~(TDLS_PEER_AT_OFF_STATE | TDLS_AT_OFF_CH_STATE);
-		_set_timer(&ptdls_sta->off_ch_timer, TDLS_STAY_TIME);
-		break;
-	case TDLS_P_BASE_CH:
-		issue_nulldata(ptdls_sta->adapt, NULL, 1, 0, 0);
-		SelectChannel(adapt, ptdls_sta->off_ch);
-		DBG_8192D("change channel to off ch:%02x\n", ptdls_sta->off_ch);
-		ptdls_sta->tdls_sta_state |= TDLS_AT_OFF_CH_STATE;
-		if ((ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE) !=
-		    TDLS_PEER_AT_OFF_STATE) {
-			issue_nulldata_to_TDLS_peer_STA(adapt, ptdls_sta, 0);
-		}
-		_set_timer(&ptdls_sta->base_ch_timer, TDLS_STAY_TIME);
-		break;
-	case TDLS_RS_RCR:
-		rtw_hal_set_hwreg(adapt, HW_VAR_TDLS_RS_RCR, 0);
-		DBG_8192D("wirte REG_RCR, set bit6 on\n");
-		break;
-	case TDLS_CKALV_PH1:
-		_set_timer(&ptdls_sta->alive_timer2, TDLS_ALIVE_TIMER_PH2);
-		break;
-	case TDLS_CKALV_PH2:
-		_set_timer(&ptdls_sta->alive_timer1, TDLS_ALIVE_TIMER_PH1);
-		break;
-	case TDLS_FREE_STA:
-		free_tdls_sta(adapt, ptdls_sta);
-		break;
-	}
-	return H2C_SUCCESS;
-#else
 	return H2C_REJECTED;
-#endif /* CONFIG_TDLS */
 }
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -368,12 +368,6 @@ void rtw_set_ps_mode(struct rtw_adapter
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
 #endif /* CONFIG_P2P */
-#ifdef CONFIG_TDLS
-	struct sta_priv *pstapriv = &padapter->stapriv;
-	int i, j;
-	_list *plist, *phead;
-	struct sta_info *ptdls_sta;
-#endif /* CONFIG_TDLS */
 
 	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
 		 ("%s: PowerMode=%d Smart_PS=%d\n",
@@ -398,31 +392,6 @@ void rtw_set_ps_mode(struct rtw_adapter
 			DBG_8192D
 			    ("rtw_set_ps_mode(): Busy Traffic , Leave 802.11 power save..\n");
 
-#ifdef CONFIG_TDLS
-			spin_lock_bh(&pstapriv->sta_hash_lock);
-
-			for (i = 0; i < NUM_STA; i++) {
-				phead = &(pstapriv->sta_hash[i]);
-				plist = phead->next;
-
-				while ((rtw_end_of_queue_search(phead, plist))
-				       == false) {
-					ptdls_sta =
-					    container_of(plist,
-							   struct sta_info,
-							   hash_list);
-
-					if (ptdls_sta->
-					    tdls_sta_state & TDLS_LINKED_STATE)
-						issue_nulldata_to_TDLS_peer_STA
-						    (padapter, ptdls_sta, 0);
-					plist = plist->next;
-				}
-			}
-
-			spin_unlock_bh(&pstapriv->sta_hash_lock);
-#endif /* CONFIG_TDLS */
-
 			pwrpriv->smart_ps = smart_ps;
 			pwrpriv->pwr_mode = ps_mode;
 
@@ -436,31 +405,6 @@ void rtw_set_ps_mode(struct rtw_adapter
 			DBG_8192D
 			    ("rtw_set_ps_mode(): Enter 802.11 power save mode...\n");
 
-#ifdef CONFIG_TDLS
-			spin_lock_bh(&pstapriv->sta_hash_lock);
-
-			for (i = 0; i < NUM_STA; i++) {
-				phead = &(pstapriv->sta_hash[i]);
-				plist = phead->next;
-
-				while ((rtw_end_of_queue_search(phead, plist))
-				       == false) {
-					ptdls_sta =
-					    container_of(plist,
-							   struct sta_info,
-							   hash_list);
-
-					if (ptdls_sta->
-					    tdls_sta_state & TDLS_LINKED_STATE)
-						issue_nulldata_to_TDLS_peer_STA
-						    (padapter, ptdls_sta, 1);
-					plist = plist->next;
-				}
-			}
-
-			spin_unlock_bh(&pstapriv->sta_hash_lock);
-#endif /* CONFIG_TDLS */
-
 			pwrpriv->smart_ps = smart_ps;
 			pwrpriv->pwr_mode = ps_mode;
 			pwrpriv->bFwCurrentInPSMode = true;
@@ -473,7 +417,6 @@ void rtw_set_ps_mode(struct rtw_adapter
 			rtw_set_rpwm(padapter, PS_STATE_S2);
 		}
 	}
-
 }
 
 /*	Description: */
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -786,19 +786,11 @@ void process_wmmps_data(struct rtw_adapt
 	if (!psta)
 		return;
 
-#ifdef CONFIG_TDLS
-	if (!(psta->tdls_sta_state & TDLS_LINKED_STATE)) {
-#endif /* CONFIG_TDLS */
-
-		if (!psta->qos_option)
-			return;
-
-		if (!(psta->qos_info & 0xf))
-			return;
+	if (!psta->qos_option)
+		return;
 
-#ifdef CONFIG_TDLS
-	}
-#endif /* CONFIG_TDLS */
+	if (!(psta->qos_info & 0xf))
+		return;
 
 	if (psta->state & WIFI_SLEEP_STATE) {
 		u8 wmmps_ac = 0;
@@ -839,70 +831,6 @@ void process_wmmps_data(struct rtw_adapt
 #endif
 }
 
-#ifdef CONFIG_TDLS
-int OnTDLS(struct rtw_adapter *adapter, struct recv_frame_hdr *precv_frame)
-{
-	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
-	int ret = _SUCCESS;
-	u8 *paction = get_recvframe_data(precv_frame);
-	u8 category_field = 1;
-	struct tdls_info *ptdlsinfo = &(adapter->tdlsinfo);
-
-	/* point to action field */
-	paction += pattrib->hdrlen
-	    + pattrib->iv_len
-	    + SNAP_SIZE + ETH_TYPE_LEN + PAYLOAD_TYPE_LEN + category_field;
-
-	if (ptdlsinfo->enable == 0) {
-		DBG_8192D("recv tdls frame, " "but tdls haven't enabled\n");
-		ret = _FAIL;
-		return ret;
-	}
-
-	switch (*paction) {
-	case TDLS_SETUP_REQUEST:
-		DBG_8192D("recv tdls setup request frame\n");
-		ret = On_TDLS_Setup_Req(adapter, precv_frame);
-		break;
-	case TDLS_SETUP_RESPONSE:
-		DBG_8192D("recv tdls setup response frame\n");
-		ret = On_TDLS_Setup_Rsp(adapter, precv_frame);
-		break;
-	case TDLS_SETUP_CONFIRM:
-		DBG_8192D("recv tdls setup confirm frame\n");
-		ret = On_TDLS_Setup_Cfm(adapter, precv_frame);
-		break;
-	case TDLS_TEARDOWN:
-		DBG_8192D("recv tdls teardown, free sta_info\n");
-		ret = On_TDLS_Teardown(adapter, precv_frame);
-		break;
-	case TDLS_DISCOVERY_REQUEST:
-		DBG_8192D("recv tdls discovery request frame\n");
-		ret = On_TDLS_Dis_Req(adapter, precv_frame);
-		break;
-	case TDLS_PEER_TRAFFIC_RESPONSE:
-		DBG_8192D("recv tdls peer traffic response frame\n");
-		ret = On_TDLS_Peer_Traffic_Rsp(adapter, precv_frame);
-		break;
-	case TDLS_CHANNEL_SWITCH_REQUEST:
-		DBG_8192D("recv tdls channel switch request frame\n");
-		ret = On_TDLS_Ch_Switch_Req(adapter, precv_frame);
-		break;
-	case TDLS_CHANNEL_SWITCH_RESPONSE:
-		DBG_8192D("recv tdls channel switch response frame\n");
-		ret = On_TDLS_Ch_Switch_Rsp(adapter, precv_frame);
-		break;
-	default:
-		DBG_8192D("receive TDLS frame but not supported\n");
-		ret = _FAIL;
-		break;
-	}
-
-exit:
-	return ret;
-}
-#endif /* CONFIG_TDLS */
-
 static void count_rx_stats(struct rtw_adapter *padapter, struct recv_frame_hdr *prframe,
 			   struct sta_info *sta)
 {
@@ -946,13 +874,6 @@ static int sta2sta_data_frame(struct rtw
 	u8 *sta_addr = NULL;
 	int bmcast = IS_MCAST(pattrib->dst);
 
-#ifdef CONFIG_TDLS
-	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
-	struct sta_info *ptdls_sta = NULL;
-	u8 *psnap_type = ptr + pattrib->hdrlen + pattrib->iv_len + SNAP_SIZE;
-	u8 *pframe_body = psnap_type + ETH_TYPE_LEN + PAYLOAD_TYPE_LEN;
-#endif /* CONFIG_TDLS */
-
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
 	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
 		/*  filter packets that SA is myself or multicast or broadcast */
@@ -978,105 +899,16 @@ static int sta2sta_data_frame(struct rtw
 		sta_addr = pattrib->src;
 
 	} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {
-#ifdef CONFIG_TDLS
-		/* direct link data transfer */
-		if (ptdlsinfo->setup_state == TDLS_LINKED_STATE) {
-			ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->src);
-			if (ptdls_sta == NULL) {
-				ret = _FAIL;
-				goto exit;
-			} else if (ptdls_sta->
-				   tdls_sta_state & TDLS_LINKED_STATE) {
-				/* drop QoS-SubType Data, including QoS NULL, excluding QoS-Data */
-				if ((GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE)
-				    == WIFI_QOS_DATA_TYPE) {
-					if (GetFrameSubType(ptr) &
-					    (BIT(4) | BIT(5) | BIT(6))) {
-						DBG_8192D
-						    ("drop QoS-Sybtype Data\n");
-						ret = _FAIL;
-						goto exit;
-					}
-				}
-				/*  filter packets that SA is myself or multicast or broadcast */
-				if (_rtw_memcmp
-				    (myhwaddr, pattrib->src, ETH_ALEN)) {
-					ret = _FAIL;
-					goto exit;
-				}
-				/*  da should be for me */
-				if ((!_rtw_memcmp (myhwaddr, pattrib->dst, ETH_ALEN)) &&
-				    (!bmcast)) {
-					ret = _FAIL;
-					goto exit;
-				}
-				/*  check BSSID */
-				if (_rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
-				    _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
-				    (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN))) {
-					ret = _FAIL;
-					goto exit;
-				}
-
-				/* process UAPSD tdls sta */
-				process_pwrbit_data(adapter, precv_frame);
-
-				/*  if NULL-frame, check pwrbit */
-				if ((GetFrameSubType(ptr)) == WIFI_DATA_NULL) {
-					/* NULL-frame with pwrbit=1, buffer_STA should buffer frames for sleep_STA */
-					if (GetPwrMgt(ptr)) {
-						DBG_8192D
-						    ("TDLS: recv peer null frame with pwr bit 1\n");
-						ptdls_sta->tdls_sta_state |=
-						    TDLS_PEER_SLEEP_STATE;
-					}
-					/*  it would be triggered when we are off channel and receiving NULL DATA */
-					/*  we can confirm that peer STA is at off channel */
-					else if (ptdls_sta->
-						 tdls_sta_state &
-						 TDLS_CH_SWITCH_ON_STATE) {
-						if ((ptdls_sta->
-						     tdls_sta_state &
-						     TDLS_PEER_AT_OFF_STATE) !=
-						    TDLS_PEER_AT_OFF_STATE) {
-							issue_nulldata_to_TDLS_peer_STA
-							    (adapter, ptdls_sta,
-							     0);
-							ptdls_sta->
-							    tdls_sta_state |=
-							    TDLS_PEER_AT_OFF_STATE;
-							On_TDLS_Peer_Traffic_Rsp
-							    (adapter,
-							     precv_frame);
-						}
-					}
-
-					ret = _FAIL;
-					goto exit;
-				}
-				/* receive some of all TDLS management frames, process it at ON_TDLS */
-				if ((_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_TDLS, 2))) {
-					ret = OnTDLS(adapter, precv_frame);
-					goto exit;
-				}
-			}
-
-			sta_addr = pattrib->src;
-
-		} else
-#endif /* CONFIG_TDLS */
-		{
-			/*  For Station mode, sa and bssid should always be BSSID, and DA is my mac-address */
-			if (!_rtw_memcmp
-			    (pattrib->bssid, pattrib->src, ETH_ALEN)) {
-				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
-					 ("bssid != TA under STATION_MODE; drop pkt\n"));
-				ret = _FAIL;
-				goto exit;
-			}
-
-			sta_addr = pattrib->bssid;
+		/*  For Station mode, sa and bssid should always be BSSID, and DA is my mac-address */
+		if (!_rtw_memcmp
+		    (pattrib->bssid, pattrib->src, ETH_ALEN)) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("bssid != TA under STATION_MODE; drop pkt\n"));
+			ret = _FAIL;
+			goto exit;
 		}
+
+		sta_addr = pattrib->bssid;
 	} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
 		if (bmcast) {
 			/*  For AP mode, if DA == MCAST, then BSSID should be also MCAST */
@@ -1113,11 +945,6 @@ static int sta2sta_data_frame(struct rtw
 	else
 		*psta = rtw_get_stainfo(pstapriv, sta_addr);	/*  get ap_info */
 
-#ifdef CONFIG_TDLS
-	if (ptdls_sta != NULL)
-		*psta = ptdls_sta;
-#endif /* CONFIG_TDLS */
-
 	if (*psta == NULL) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 			 ("can't get psta under sta2sta_data_frame ; drop pkt\n"));
@@ -1535,9 +1362,6 @@ static int validate_recv_data_frame(stru
 	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
 	struct security_priv *psecuritypriv = &adapter->securitypriv;
 	int ret = _SUCCESS;
-#ifdef CONFIG_TDLS
-	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
-#endif /* CONFIG_TDLS */
 
 	bretry = GetRetry(ptr);
 	pda = get_da(ptr);
@@ -1642,14 +1466,8 @@ static int validate_recv_data_frame(stru
 			 ("\n ^^^^^^^^^^^IS_MCAST(pattrib->ra(0x%02x))=%d^^^^^^^^^^^^^^^6\n",
 			  pattrib->ra[0], IS_MCAST(pattrib->ra)));
 
-#ifdef CONFIG_TDLS
-		if ((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
-		    (psta->dot118021XPrivacy == _AES_)) {
-			pattrib->encrypt = psta->dot118021XPrivacy;
-		} else
-#endif /* CONFIG_TDLS */
-			GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt,
-				       IS_MCAST(pattrib->ra));
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt,
+			       IS_MCAST(pattrib->ra));
 
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
 			 ("\n pattrib->encrypt=%d\n", pattrib->encrypt));
@@ -1673,24 +1491,15 @@ static int validate_recv_frame(struct rt
 	/* shall check frame subtype, to / from ds, da, bssid */
 
 	/* then call check if rx seq/frag. duplicated. */
-
 	u8 type;
 	u8 subtype;
 	int retval = _SUCCESS;
-
 	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
-
 	u8 *ptr = precv_frame->rx_data;
 	u8 ver = (unsigned char)(*ptr) & 0x3;
 #ifdef CONFIG_FIND_BEST_CHANNEL
 	struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
-#endif
-
-#ifdef CONFIG_TDLS
-	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
-#endif /* CONFIG_TDLS */
 
-#ifdef CONFIG_FIND_BEST_CHANNEL
 	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {
 		int ch_set_idx =
 		    rtw_ch_set_search_ch(pmlmeext->channel_set,
@@ -1700,11 +1509,6 @@ static int validate_recv_frame(struct rt
 	}
 #endif
 
-#ifdef CONFIG_TDLS
-	if (ptdlsinfo->ch_sensing == 1 && ptdlsinfo->cur_channel != 0)
-		ptdlsinfo->collect_pkt_num[ptdlsinfo->cur_channel - 1]++;
-#endif /* CONFIG_TDLS */
-
 	/* add version chk */
 	if (ver != 0) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
@@ -2535,21 +2339,9 @@ static int process_recv_indicatepkts(str
 	/* struct recv_priv *precvpriv = &padapter->recvpriv; */
 	/* struct rx_pkt_attrib *pattrib = &prframe->attrib; */
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-#ifdef CONFIG_TDLS
-	struct sta_info *psta = prframe->psta;
-#endif /* CONFIG_TDLS */
-
 	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
 
-#ifdef CONFIG_TDLS
-	if ((phtpriv->ht_option == true) ||
-	    ((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
-	     (psta->htpriv.ht_option == true) &&
-	     (psta->htpriv.ampdu_enable == true)))	/* B/G/N Mode */
-#else
-	if (phtpriv->ht_option == true)	/* B/G/N Mode */
-#endif /* CONFIG_TDLS */
-	{
+	if (phtpriv->ht_option == true)	/* B/G/N Mode */ {
 		if (recv_indicatepkt_reorder(padapter, prframe) != _SUCCESS) {	/*  including perform A-MPDU Rx Ordering Buffer Control */
 #ifdef DBG_RX_DROP_FRAME
 			DBG_8192D
@@ -2627,11 +2419,6 @@ static int recv_func_posthandle(struct r
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 	struct __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
 
-#ifdef CONFIG_TDLS
-	u8 *psnap_type, *pcategory;
-	struct sta_info *ptdls_sta = NULL;
-#endif /* CONFIG_TDLS */
-
 	/*  DATA FRAME */
 	rtw_led_control(padapter, LED_CTL_RX);
 
@@ -2646,20 +2433,6 @@ static int recv_func_posthandle(struct r
 		ret = _FAIL;
 		goto _recv_data_drop;
 	}
-#ifdef CONFIG_TDLS
-	/* check TDLS frame */
-	psnap_type = get_recvframe_data(orig_prframe);
-	psnap_type += pattrib->hdrlen + pattrib->iv_len + SNAP_SIZE;
-	pcategory = psnap_type + ETH_TYPE_LEN + PAYLOAD_TYPE_LEN;
-
-	if ((_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_TDLS, ETH_TYPE_LEN)) &&
-	    ((*pcategory == RTW_WLAN_CATEGORY_TDLS) ||
-	     (*pcategory == RTW_WLAN_CATEGORY_P2P))) {
-		ret = OnTDLS(padapter, prframe);	/* all of functions will return _FAIL */
-		goto _exit_recv_func;
-	}
-#endif /* CONFIG_TDLS */
-
 	prframe = recvframe_chk_defrag(padapter, prframe);
 	if (prframe == NULL) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
@@ -2683,13 +2456,7 @@ static int recv_func_posthandle(struct r
 		ret = _FAIL;
 		goto _recv_data_drop;
 	}
-#ifdef CONFIG_TDLS
-	if (padapter->tdlsinfo.setup_state == TDLS_LINKED_STATE)
-		ptdls_sta = rtw_get_stainfo(&padapter->stapriv, pattrib->src);
-	count_rx_stats(padapter, prframe, ptdls_sta);
-#else
 	count_rx_stats(padapter, prframe, NULL);
-#endif /* CONFIG_TDLS */
 
 	ret = process_recv_indicatepkts(padapter, prframe);
 	if (ret != _SUCCESS) {
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -1394,22 +1394,6 @@ u32 rtw_aes_encrypt(struct rtw_adapter *
 			} else {
 				prwskey = &stainfo->dot118021x_UncstKey.skey[0];
 			}
-
-#ifdef CONFIG_TDLS		/* swencryption */
-			{
-				struct sta_info *ptdls_sta;
-				ptdls_sta =
-				    rtw_get_stainfo(&padapter->stapriv,
-						    &pattrib->dst[0]);
-				if ((ptdls_sta != NULL) &&
-				    (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE)) {
-					DBG_8192D("[%s] for tdls link\n",
-						  __func__);
-					prwskey = &ptdls_sta->tpk.tk[0];
-				}
-			}
-#endif /* CONFIG_TDLS */
-
 			for (curfragnum = 0; curfragnum < pattrib->nr_frags;
 			     curfragnum++) {
 				if ((curfragnum + 1) == pattrib->nr_frags) {	/* 4 the last fragment */
@@ -2445,116 +2429,6 @@ static int omac1_aes_128(u8 *key, u8 *da
 	return omac1_aes_128_vector(key, 1, &data, &data_len, mac);
 }
 
-#ifdef CONFIG_TDLS
-void wpa_tdls_generate_tpk(struct rtw_adapter *padapter, struct sta_info *psta)
-{
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	u8 *SNonce = psta->SNonce;
-	u8 *ANonce = psta->ANonce;
-
-	u8 key_input[SHA256_MAC_LEN];
-	u8 *nonce[2];
-	size_t len[2];
-	u8 data[3 * ETH_ALEN];
-
-	/* IEEE Std 802.11z-2010 8.5.9.1:
-	 * TPK-Key-Input = SHA-256(min(SNonce, ANonce) || max(SNonce, ANonce))
-	 */
-	len[0] = 32;
-	len[1] = 32;
-	if (os_memcmp(SNonce, ANonce, 32) < 0) {
-		nonce[0] = SNonce;
-		nonce[1] = ANonce;
-	} else {
-		nonce[0] = ANonce;
-		nonce[1] = SNonce;
-	}
-
-	sha256_vector(2, nonce, len, key_input);
-
-	/*
-	 * TPK-Key-Data = KDF-N_KEY(TPK-Key-Input, "TDLS PMK",
-	 *      min(MAC_I, MAC_R) || max(MAC_I, MAC_R) || BSSID || N_KEY)
-	 * TODO: is N_KEY really included in KDF Context and if so, in which
-	 * presentation format (little endian 16-bit?) is it used? It gets
-	 * added by the KDF anyway..
-	 */
-
-	if (os_memcmp(myid(&(padapter->eeprompriv)), psta->hwaddr, ETH_ALEN) < 0) {
-		memcpy(data, myid(&(padapter->eeprompriv)), ETH_ALEN);
-		memcpy(data + ETH_ALEN, psta->hwaddr, ETH_ALEN);
-	} else {
-		memcpy(data, psta->hwaddr, ETH_ALEN);
-		memcpy(data + ETH_ALEN, myid(&(padapter->eeprompriv)),
-		       ETH_ALEN);
-	}
-	memcpy(data + 2 * ETH_ALEN, get_bssid(pmlmepriv), ETH_ALEN);
-
-	sha256_prf(key_input, SHA256_MAC_LEN, "TDLS PMK", data, sizeof(data),
-		   (u8 *)&psta->tpk, sizeof(psta->tpk));
-}
-
-int tdls_verify_mic(u8 *kck, u8 trans_seq,
-		    u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie)
-{
-	u8 *buf, *pos;
-	int len;
-	u8 mic[16];
-	int ret;
-	u8 *rx_ftie, *tmp_ftie;
-
-	if (lnkid == NULL || rsnie == NULL || timeoutie == NULL || ftie == NULL)
-		return 0;
-
-	len = 2 * ETH_ALEN + 1 + 2 + 18 + 2 + *(rsnie + 1) + 2 +
-	      *(timeoutie + 1) + 2 + *(ftie + 1);
-
-	buf = kzalloc(len, GFP_KERNEL);
-	if (buf == NULL)
-		return 0;
-
-	pos = buf;
-	/* 1) TDLS initiator STA MAC address */
-	memcpy(pos, lnkid + ETH_ALEN + 2, ETH_ALEN);
-	pos += ETH_ALEN;
-	/* 2) TDLS responder STA MAC address */
-	memcpy(pos, lnkid + 2 * ETH_ALEN + 2, ETH_ALEN);
-	pos += ETH_ALEN;
-	/* 3) Transaction Sequence number */
-	*pos++ = trans_seq;
-	/* 4) Link Identifier IE */
-	memcpy(pos, lnkid, 2 + 18);
-	pos += 2 + 18;
-	/* 5) RSN IE */
-	memcpy(pos, rsnie, 2 + *(rsnie + 1));
-	pos += 2 + *(rsnie + 1);
-	/* 6) Timeout Interval IE */
-	memcpy(pos, timeoutie, 2 + *(timeoutie + 1));
-	pos += 2 + *(timeoutie + 1);
-	/* 7) FTIE, with the MIC field of the FTIE set to 0 */
-	memcpy(pos, ftie, 2 + *(ftie + 1));
-	pos += 2;
-	tmp_ftie = (u8 *)(pos + 2);
-	memset(tmp_ftie, 0, 16);
-	pos += *(ftie + 1);
-
-	ret = omac1_aes_128(kck, buf, pos - buf, mic);
-	kfree(buf);
-	if (ret)
-		return 0;
-	rx_ftie = ftie + 4;
-
-	if (os_memcmp(mic, rx_ftie, 16) == 0) {
-		/* Valid MIC */
-		return 1;
-	}
-
-	/* Invalid MIC */
-	DBG_8192D("[%s] Invalid MIC\n", __func__);
-	return 0;
-}
-#endif /* CONFIG_TDLS */
-
 void rtw_use_tkipkey_handler(void *FunctionContext)
 {
 	struct rtw_adapter *padapter = (struct rtw_adapter *)FunctionContext;
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -295,16 +295,6 @@ struct	sta_info *rtw_alloc_stainfo(struc
 
 		init_addba_retry_timer(pstapriv->padapter, psta);
 
-#ifdef CONFIG_TDLS
-		psta->padapter = pstapriv->padapter;
-		init_TPK_timer(pstapriv->padapter, psta);
-		init_ch_switch_timer(pstapriv->padapter, psta);
-		init_base_ch_timer(pstapriv->padapter, psta);
-		init_off_ch_timer(pstapriv->padapter, psta);
-		init_handshake_timer(pstapriv->padapter, psta);
-		init_tdls_alive_timer(pstapriv->padapter, psta);
-#endif /* CONFIG_TDLS */
-
 		/* for A-MPDU Rx reordering buffer control */
 		for (i = 0; i < 16; i++) {
 			reorder = &psta->recvreorder_ctrl[i];
@@ -391,15 +381,6 @@ u32	rtw_free_stainfo(struct rtw_adapter
 
 	_cancel_timer_ex(&psta->addba_retry_timer);
 
-#ifdef CONFIG_TDLS
-	_cancel_timer_ex(&psta->TPK_timer);
-	_cancel_timer_ex(&psta->option_timer);
-	_cancel_timer_ex(&psta->base_ch_timer);
-	_cancel_timer_ex(&psta->off_ch_timer);
-	_cancel_timer_ex(&psta->alive_timer1);
-	_cancel_timer_ex(&psta->alive_timer2);
-#endif /* CONFIG_TDLS */
-
 	/* for A-MPDU Rx reordering buffer control, cancel reorder_ctrl_timer */
 	for (i = 0; i < 16; i++) {
 		struct list_head *phead, *plist;
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ /dev/null
@@ -1,2395 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *
- ******************************************************************************/
-#define _RTW_TDLS_C_
-
-#include <drv_types.h>
-#include <ethernet.h>
-#include <rtw_tdls.h>
-#include <wifi.h>
-#include <usb_osintf.h>
-
-#ifdef CONFIG_TDLS
-extern unsigned char MCS_rate_2R[16];
-extern unsigned char MCS_rate_1R[16];
-
-void rtw_reset_tdls_info(_adapter *padapter)
-{
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-
-	ptdlsinfo->ap_prohibited = false;
-	ptdlsinfo->setup_state = TDLS_STATE_NONE;
-	ptdlsinfo->sta_cnt = 0;
-	ptdlsinfo->sta_maximum = false;
-	ptdlsinfo->macid_index = 6;
-	ptdlsinfo->clear_cam = 0;
-	ptdlsinfo->ch_sensing = 0;
-	ptdlsinfo->cur_channel = 0;
-	ptdlsinfo->candidate_ch = 1;	/* when inplement channel switching, default candidate channel is 1 */
-	ptdlsinfo->watchdog_count = 0;
-	ptdlsinfo->dev_discovered = 0;
-}
-
-int rtw_init_tdls_info(_adapter *padapter)
-{
-	int	res = _SUCCESS;
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-
-	ptdlsinfo->enable = 1;
-	rtw_reset_tdls_info(padapter);
-
-	spin_lock_init(&ptdlsinfo->cmd_lock);
-	spin_lock_init(&ptdlsinfo->hdl_lock);
-
-	return res;
-}
-
-void rtw_free_tdls_info(struct tdls_info *ptdlsinfo)
-{
-	memset(ptdlsinfo, 0, sizeof(struct tdls_info));
-}
-
-void issue_nulldata_to_TDLS_peer_STA(_adapter *padapter, struct sta_info *ptdls_sta, unsigned int power_mode)
-{
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	unsigned char					*pframe;
-	struct rtw_ieee80211_hdr	*pwlanhdr;
-	unsigned short				*fctrl;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(padapter, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_ctl);
-	*(fctrl) = 0;
-	if (power_mode)
-		SetPwrMgt(fctrl);
-
-	memcpy(pwlanhdr->addr1, ptdls_sta->hwaddr, ETH_ALEN);
-	memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
-	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
-
-	ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
-	ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
-	pattrib->seqnum = ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority];
-	SetSeqNum(pwlanhdr, pattrib->seqnum);
-
-	SetFrameSubType(pframe, WIFI_DATA_NULL);
-
-	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
-
-	pattrib->last_txcmdsz = pattrib->pktlen;
-	dump_mgntframe(padapter, pmgntframe);
-
-	return;
-}
-
-s32 update_tdls_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
-{
-	struct sta_info *psta = NULL;
-	struct sta_priv		*pstapriv = &padapter->stapriv;
-	struct security_priv	*psecuritypriv = &padapter->securitypriv;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
-
-	s32 res = _SUCCESS;
-	int bmcast;
-
-	bmcast = IS_MCAST(pattrib->ra);
-
-	psta = rtw_get_stainfo(pstapriv, pattrib->ra);
-	if (psta == NULL) {
-		res = _FAIL;
-		goto exit;
-	}
-
-	pattrib->mac_id = psta->mac_id;
-
-	pattrib->psta = psta;
-
-	pattrib->ack_policy = 0;
-	/*  get ether_hdr_len */
-	pattrib->pkt_hdrlen = ETH_HLEN;/* pattrib->ether_type == 0x8100) ? (14 + 4): 14; vlan tag */
-
-	if (pqospriv->qos_option &&  psta->qos_option) {
-		pattrib->priority = 1;	/* tdls management frame should be AC_BK */
-		pattrib->hdrlen = WLAN_HDR_A3_QOS_LEN;
-		pattrib->subtype = WIFI_QOS_DATA_TYPE;
-	} else {
-		pattrib->hdrlen = WLAN_HDR_A3_LEN;
-		pattrib->subtype = WIFI_DATA_TYPE;
-		pattrib->priority = 0;
-	}
-
-	if (psta->ieee8021x_blocked == true) {
-		pattrib->encrypt = 0;
-	} else {
-		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);
-
-		switch (psecuritypriv->dot11AuthAlgrthm) {
-		case dot11AuthAlgrthm_Open:
-		case dot11AuthAlgrthm_Shared:
-		case dot11AuthAlgrthm_Auto:
-			pattrib->key_idx = (u8)psecuritypriv->dot11PrivacyKeyIndex;
-			break;
-		case dot11AuthAlgrthm_8021X:
-			pattrib->key_idx = 0;
-			break;
-		default:
-			pattrib->key_idx = 0;
-			break;
-		}
-	}
-
-	switch (pattrib->encrypt) {
-	case _WEP40_:
-	case _WEP104_:
-		pattrib->iv_len = 4;
-		pattrib->icv_len = 4;
-		break;
-	case _TKIP_:
-		pattrib->iv_len = 8;
-		pattrib->icv_len = 4;
-		if (padapter->securitypriv.busetkipkey == _FAIL) {
-			res = _FAIL;
-			goto exit;
-		}
-		break;
-	case _AES_:
-		pattrib->iv_len = 8;
-		pattrib->icv_len = 8;
-		break;
-	default:
-		pattrib->iv_len = 0;
-		pattrib->icv_len = 0;
-		break;
-	}
-
-	if (pattrib->encrypt &&
-	    ((padapter->securitypriv.sw_encrypt == true) ||
-	    (psecuritypriv->hw_decrypted == false)))
-		pattrib->bswenc = true;
-	else
-		pattrib->bswenc = false;
-
-	/* qos_en, ht_en, init rate, , bw, ch_offset, sgi */
-	pattrib->qos_en = psta->qos_option;
-	pattrib->ht_en = psta->htpriv.ht_option;
-	pattrib->raid = psta->raid;
-	pattrib->bwmode = psta->htpriv.bwmode;
-	pattrib->ch_offset = psta->htpriv.ch_offset;
-	pattrib->sgi = psta->htpriv.sgi;
-	pattrib->ampdu_en = false;
-exit:
-	return res;
-}
-
-void free_tdls_sta(_adapter *padapter, struct sta_info *ptdls_sta)
-{
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-	struct sta_priv *pstapriv = &padapter->stapriv;
-
-	/* free peer sta_info */
-	spin_lock_bh(&(pstapriv->sta_hash_lock));
-	if (ptdlsinfo->sta_cnt != 0)
-		ptdlsinfo->sta_cnt--;
-	spin_unlock_bh(&(pstapriv->sta_hash_lock));
-	if (ptdlsinfo->sta_cnt < (NUM_STA - 2)) { /*  -2: AP + BC/MC sta */
-		ptdlsinfo->sta_maximum = false;
-		memset(&ptdlsinfo->ss_record, 0x00, sizeof(struct tdls_ss_record));
-	}
-	/* ready to clear cam */
-	if (ptdls_sta->mac_id != 0) {
-		ptdlsinfo->clear_cam = ptdls_sta->mac_id;
-		rtw_setstakey_cmd(padapter, (u8 *)ptdls_sta, true);
-	}
-
-	if (ptdlsinfo->sta_cnt == 0) {
-		rtw_tdls_cmd(padapter, myid(&(padapter->eeprompriv)), TDLS_RS_RCR);
-		ptdlsinfo->setup_state = TDLS_STATE_NONE;
-	} else {
-		DBG_871X("Remain tdls sta:%02x\n", ptdlsinfo->sta_cnt);
-	}
-
-	rtw_free_stainfo(padapter,  ptdls_sta);
-}
-
-/*  cam entry will be the same as mac_id */
-void rtw_tdls_set_mac_id(struct tdls_info *ptdlsinfo, struct sta_info *ptdls_sta)
-{
-	if (ptdls_sta->mac_id == 0) {
-		ptdls_sta->mac_id = ptdlsinfo->macid_index;
-		if ((++ptdlsinfo->macid_index) > (NUM_STA - 2))
-			ptdlsinfo->macid_index = TDLS_INI_MACID_ENTRY;
-	}
-}
-
-/* TDLS encryption(if needed) will always be CCMP */
-void rtw_tdls_set_key(_adapter *adapter, struct rx_pkt_attrib *prx_pkt_attrib, struct sta_info *ptdls_sta)
-{
-	if (prx_pkt_attrib->encrypt) {
-		ptdls_sta->dot118021XPrivacy = _AES_;
-		rtw_setstakey_cmd(adapter, (u8 *)ptdls_sta, true);
-	}
-}
-
-void rtw_tdls_process_ht_cap(_adapter *adapter, struct sta_info *ptdls_sta, u8 *data, u8 Length)
-{
-	/* save HT capabilities in the sta object */
-	memset(&ptdls_sta->htpriv.ht_cap, 0, sizeof(struct rtw_ieee80211_ht_cap));
-	if (data && Length >= sizeof(struct rtw_ieee80211_ht_cap)) {
-		ptdls_sta->flags |= WLAN_STA_HT;
-
-		ptdls_sta->flags |= WLAN_STA_WME;
-
-		memcpy(&ptdls_sta->htpriv.ht_cap, data, sizeof(struct rtw_ieee80211_ht_cap));
-
-	} else {
-		ptdls_sta->flags &= ~WLAN_STA_HT;
-	}
-
-	if (ptdls_sta->flags & WLAN_STA_HT) {
-		if (adapter->registrypriv.ht_enable == true) {
-			ptdls_sta->htpriv.ht_option = true;
-		} else {
-			ptdls_sta->htpriv.ht_option = false;
-			ptdls_sta->stat_code = _STATS_FAILURE_;
-		}
-	}
-
-	/* HT related cap */
-	if (ptdls_sta->htpriv.ht_option) {
-		/* check if sta supports rx ampdu */
-		if (adapter->registrypriv.ampdu_enable == 1)
-			ptdls_sta->htpriv.ampdu_enable = true;
-
-		/* check if sta support s Short GI */
-		if (ptdls_sta->htpriv.ht_cap.cap_info & (IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))
-			ptdls_sta->htpriv.sgi = true;
-
-		/*  bwmode would still followed AP's setting */
-		if (ptdls_sta->htpriv.ht_cap.cap_info & IEEE80211_HT_CAP_SUP_WIDTH) {
-			ptdls_sta->htpriv.bwmode = adapter->mlmeextpriv.cur_bwmode;
-			ptdls_sta->htpriv.ch_offset = adapter->mlmeextpriv.cur_ch_offset;
-		}
-	}
-}
-
-u8 *rtw_tdls_set_ht_cap(_adapter *padapter, u8 *pframe, struct pkt_attrib *pattrib)
-{
-	struct rtw_ieee80211_ht_cap ht_capie;
-	u8 rf_type;
-	u32 rx_packet_offset, max_recvbuf_sz;
-
-	/* HT capabilities */
-	memset(&ht_capie, 0, sizeof(struct rtw_ieee80211_ht_cap));
-
-	ht_capie.cap_info = IEEE80211_HT_CAP_SUP_WIDTH |
-			    IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_SM_PS |
-			    IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_TX_STBC |
-			    IEEE80211_HT_CAP_DSSSCCK40;
-
-	rtw_hal_get_def_var(padapter, HAL_DEF_RX_PACKET_OFFSET, &rx_packet_offset);
-	rtw_hal_get_def_var(padapter, HAL_DEF_MAX_RECVBUF_SZ, &max_recvbuf_sz);
-	if (max_recvbuf_sz-rx_packet_offset > (8191-256))
-		ht_capie.cap_info = ht_capie.cap_info | IEEE80211_HT_CAP_MAX_AMSDU;
-
-	ht_capie.ampdu_params_info = (IEEE80211_HT_CAP_AMPDU_FACTOR&0x03);
-
-	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-	switch (rf_type) {
-	case RF_1T1R:
-		ht_capie.cap_info |= 0x0100;/* RX STBC One spatial stream */
-		memcpy(ht_capie.supp_mcs_set, MCS_rate_1R, 16);
-		break;
-	case RF_2T2R:
-	case RF_1T2R:
-	default:
-		ht_capie.cap_info |= 0x0200;/* RX STBC two spatial stream */
-		memcpy(ht_capie.supp_mcs_set, MCS_rate_2R, 16);
-		break;
-	}
-
-	return(rtw_set_ie(pframe, _HT_CAPABILITY_IE_,
-			  sizeof(struct rtw_ieee80211_ht_cap),
-			  (unsigned char *)&ht_capie, &(pattrib->pktlen)));
-}
-
-u8 *rtw_tdls_set_sup_ch(struct mlme_ext_priv *pmlmeext, u8 *pframe, struct pkt_attrib *pattrib)
-{
-	u8 sup_ch[30 * 2] = { 0x00 }, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
-	do {
-		if (pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14) {
-			sup_ch[0] = 1;	/* First channel number */
-			sup_ch[1] = pmlmeext->channel_set[sup_ch_idx].ChannelNum;	/* Number of channel */
-		} else {
-			sup_ch[idx_5g++] = pmlmeext->channel_set[sup_ch_idx].ChannelNum;
-			sup_ch[idx_5g++] = 1;
-		}
-
-		sup_ch_idx++;
-	} while (pmlmeext->channel_set[sup_ch_idx].ChannelNum != 0);
-	return rtw_set_ie(pframe, _SUPPORTED_CH_IE_, idx_5g, sup_ch, &(pattrib->pktlen));
-}
-
-void issue_tdls_setup_req(_adapter *padapter, u8 *mac_addr)
-{
-	struct tdls_info	*ptdlsinfo = &padapter->tdlsinfo;
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct sta_priv *pstapriv = &padapter->stapriv;
-	struct sta_info *ptdls_sta = NULL;
-	static u8 dialogtoken;
-	u32 timeout_interval = TPK_RESEND_COUNT * 1000;	/* retry timer should set at least 301 sec, using TPK_count counting 301 times. */
-
-	if (ptdlsinfo->ap_prohibited == true)
-		goto exit;
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-
-	pmgntframe->frame_tag = DATA_FRAMETAG;
-	pattrib->ether_type = 0x890d;
-	pattrib->pctrl = 0;
-
-	memcpy(pattrib->dst, mac_addr, ETH_ALEN);
-	memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
-
-	memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
-	memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
-
-	update_tdls_attrib(padapter, pattrib);
-
-	/* init peer sta_info */
-	ptdls_sta = rtw_get_stainfo(pstapriv, mac_addr);
-	if (ptdls_sta == NULL) {
-		ptdls_sta = rtw_alloc_stainfo(pstapriv, mac_addr);
-		if (ptdls_sta) {
-			spin_lock_bh(&(pstapriv->sta_hash_lock));
-			if (!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
-				ptdlsinfo->sta_cnt++;
-			spin_unlock_bh(&(pstapriv->sta_hash_lock));
-			if (ptdlsinfo->sta_cnt == (NUM_STA - 2))	/*  -2: AP + BC/MC sta */
-				ptdlsinfo->sta_maximum  = true;
-		} else {
-			rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
-			rtw_free_xmitframe(pxmitpriv, pmgntframe);
-			goto exit;
-		}
-	}
-
-	if (ptdls_sta) {
-		ptdls_sta->tdls_sta_state |= TDLS_RESPONDER_STATE;
-		/* for tdls; ptdls_sta->aid is used to fill dialogtoken */
-		ptdls_sta->dialog = dialogtoken;
-		dialogtoken = (dialogtoken+1)%256;
-		ptdls_sta->TDLS_PeerKey_Lifetime = timeout_interval;
-		_set_timer(&ptdls_sta->handshake_timer, TDLS_HANDSHAKE_TIME);
-	}
-
-	pattrib->qsel = pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_SETUP_REQUEST) != _SUCCESS) {
-		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
-		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit;
-	}
-	rtw_dump_xframe(padapter, pmgntframe);
-
-exit:
-
-	return;
-}
-
-void issue_tdls_teardown(_adapter *padapter, u8 *mac_addr)
-{
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct sta_priv *pstapriv = &padapter->stapriv;
-	struct sta_info	*ptdls_sta = NULL;
-
-	ptdls_sta = rtw_get_stainfo(pstapriv, mac_addr);
-	if (ptdls_sta == NULL) {
-		DBG_871X("issue tdls teardown unsuccessful\n");
-		return;
-	} else {
-		ptdls_sta->tdls_sta_state = TDLS_STATE_NONE;
-	}
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-
-	pmgntframe->frame_tag = DATA_FRAMETAG;
-	pattrib->ether_type = 0x890d;
-	pattrib->pctrl = 0;
-
-	memcpy(pattrib->dst, mac_addr, ETH_ALEN);
-	memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
-
-	memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
-	memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
-
-	update_tdls_attrib(padapter, pattrib);
-	pattrib->qsel = pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_TEARDOWN) != _SUCCESS) {
-		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
-		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit;
-	}
-	rtw_dump_xframe(padapter, pmgntframe);
-
-	if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE)
-		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
-
-	if (ptdls_sta->timer_flag == 1) {
-		spin_lock_bh(&(padapter->tdlsinfo.hdl_lock));
-		ptdls_sta->timer_flag = 2;
-		spin_unlock_bh(&(padapter->tdlsinfo.hdl_lock));
-	} else {
-		rtw_tdls_cmd(padapter, mac_addr, TDLS_FREE_STA);
-	}
-
-exit:
-
-	return;
-}
-
-void issue_tdls_dis_req(_adapter *padapter, u8 *mac_addr)
-{
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	u8 baddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-
-	pmgntframe->frame_tag = DATA_FRAMETAG;
-	pattrib->ether_type = 0x890d;
-	pattrib->pctrl = 0;
-
-	if (mac_addr == NULL)
-		memcpy(pattrib->dst, baddr, ETH_ALEN);
-	else
-		memcpy(pattrib->dst, mac_addr, ETH_ALEN);
-
-	memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
-
-	memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
-	memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
-
-	update_tdls_attrib(padapter, pattrib);
-	pattrib->qsel = pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_DISCOVERY_REQUEST) != _SUCCESS) {
-		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
-		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit;
-	}
-	rtw_dump_xframe(padapter, pmgntframe);
-	DBG_871X("issue tdls dis req\n");
-
-exit:
-
-	return;
-}
-
-void issue_tdls_setup_rsp(_adapter *padapter, struct recv_frame_hdr *precv_frame)
-{
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct rx_pkt_attrib	*rx_pkt_pattrib = &precv_frame->attrib;
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-
-	pmgntframe->frame_tag = DATA_FRAMETAG;
-	pattrib->ether_type = 0x890d;
-	pattrib->pctrl = 0;
-
-	memcpy(pattrib->dst, rx_pkt_pattrib->src, ETH_ALEN);
-	memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
-
-	memcpy(pattrib->ra, rx_pkt_pattrib->bssid, ETH_ALEN);
-	memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
-
-	update_tdls_attrib(padapter, pattrib);
-	pattrib->qsel = pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_SETUP_RESPONSE) != _SUCCESS) {
-		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
-		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit;
-	}
-	rtw_dump_xframe(padapter, pmgntframe);
-
-exit:
-
-	return;
-}
-
-void issue_tdls_setup_cfm(_adapter *padapter, struct recv_frame_hdr *precv_frame)
-{
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct sta_info		*ptdls_sta = NULL;
-
-	struct rx_pkt_attrib	*rx_pkt_pattrib = &precv_frame->attrib;
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-
-	pmgntframe->frame_tag = DATA_FRAMETAG;
-	pattrib->ether_type = 0x890d;
-	pattrib->pctrl = 0;
-
-	memcpy(pattrib->dst, rx_pkt_pattrib->src, ETH_ALEN);
-	memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
-
-	memcpy(pattrib->ra, rx_pkt_pattrib->bssid, ETH_ALEN);
-	memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
-
-	update_tdls_attrib(padapter, pattrib);
-	pattrib->qsel = pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_SETUP_CONFIRM) != _SUCCESS) {
-		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
-		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit;
-	}
-
-	rtw_dump_xframe(padapter, pmgntframe);
-
-exit:
-
-	return;
-}
-
-/* TDLS Discovery Response frame is a management action frame */
-void issue_tdls_dis_rsp(_adapter *padapter, struct recv_frame_hdr *precv_frame, u8 dialog)
-{
-	struct xmit_frame		*pmgntframe;
-	struct pkt_attrib		*pattrib;
-	unsigned char			*pframe;
-	struct rtw_ieee80211_hdr	*pwlanhdr;
-	unsigned short		*fctrl;
-	struct xmit_priv		*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-
-	struct rx_pkt_attrib	*rx_pkt_pattrib = &precv_frame->attrib;
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(padapter, pattrib);
-
-	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
-	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
-
-	fctrl = &(pwlanhdr->frame_ctl);
-	*(fctrl) = 0;
-
-	/*	unicast probe request frame */
-	memcpy(pwlanhdr->addr1, rx_pkt_pattrib->src, ETH_ALEN);
-	memcpy(pattrib->dst, pwlanhdr->addr1, ETH_ALEN);
-
-	memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
-	memcpy(pattrib->src, pwlanhdr->addr2, ETH_ALEN);
-
-	memcpy(pwlanhdr->addr3, rx_pkt_pattrib->bssid, ETH_ALEN);
-	memcpy(pattrib->ra, pwlanhdr->addr3, ETH_ALEN);
-
-	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
-	pmlmeext->mgnt_seq++;
-	SetFrameSubType(pframe, WIFI_ACTION);
-
-	pframe += sizeof (struct rtw_ieee80211_hdr_3addr);
-	pattrib->pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
-
-	rtw_build_tdls_dis_rsp_ies(padapter, pmgntframe, pframe, dialog);
-
-	pattrib->nr_frags = 1;
-	pattrib->last_txcmdsz = pattrib->pktlen;
-
-	dump_mgntframe(padapter, pmgntframe);
-
-	return;
-}
-
-void issue_tdls_peer_traffic_indication(_adapter *padapter, struct sta_info *ptdls_sta)
-{
-	struct xmit_frame			*pmgntframe;
-	struct pkt_attrib			*pattrib;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-
-	static u8 dialogtoken;
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-
-	pmgntframe->frame_tag = DATA_FRAMETAG;
-	pattrib->ether_type = 0x890d;
-	pattrib->pctrl = 0;
-
-	memcpy(pattrib->dst, ptdls_sta->hwaddr, ETH_ALEN);
-	memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
-
-	memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
-	memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
-
-	/* for tdls; pattrib->nr_frags is used to fill dialogtoken */
-	ptdls_sta->dialog = dialogtoken;
-	dialogtoken = (dialogtoken+1)%256;
-	/* PTI frame's priority should be AC_VO */
-	pattrib->priority = 7;
-
-	update_tdls_attrib(padapter, pattrib);
-	pattrib->qsel = pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_PEER_TRAFFIC_INDICATION) != _SUCCESS) {
-		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
-		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit;
-	}
-	rtw_dump_xframe(padapter, pmgntframe);
-
-exit:
-
-	return;
-}
-
-void issue_tdls_ch_switch_req(_adapter *padapter, u8 *mac_addr)
-{
-	struct xmit_frame	*pmgntframe;
-	struct pkt_attrib	*pattrib;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-
-	pmgntframe->frame_tag = DATA_FRAMETAG;
-	pattrib->ether_type = 0x890d;
-	pattrib->pctrl = 0;
-
-	memcpy(pattrib->dst, mac_addr, ETH_ALEN);
-	memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
-
-	memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
-	memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
-
-	update_tdls_attrib(padapter, pattrib);
-
-	pattrib->qsel = pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_REQUEST) != _SUCCESS) {
-		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
-		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit;
-	}
-	rtw_dump_xframe(padapter, pmgntframe);
-
-exit:
-
-	return;
-}
-
-void issue_tdls_ch_switch_rsp(_adapter *padapter, u8 *mac_addr)
-{
-	struct xmit_frame	*pmgntframe;
-	struct pkt_attrib	*pattrib;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
-
-	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
-	if (pmgntframe == NULL)
-		return;
-
-	/* update attribute */
-	pattrib = &pmgntframe->attrib;
-
-	pmgntframe->frame_tag = DATA_FRAMETAG;
-	pattrib->ether_type = 0x890d;
-	pattrib->pctrl = 0;
-
-	memcpy(pattrib->dst, mac_addr, ETH_ALEN);
-	memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
-
-	memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
-	memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
-
-	update_tdls_attrib(padapter, pattrib);
-
-	pattrib->qsel = pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_RESPONSE) != _SUCCESS) {
-		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
-		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit;
-	}
-	rtw_dump_xframe(padapter, pmgntframe);
-
-exit:
-
-	return;
-}
-
-int On_TDLS_Dis_Rsp(_adapter *adapter, struct recv_frame_hdr *precv_frame)
-{
-	struct sta_info *ptdls_sta = NULL, *psta = rtw_get_stainfo(&(adapter->stapriv), get_bssid(&(adapter->mlmepriv)));
-	struct recv_priv *precvpriv = &(adapter->recvpriv);
-	u8 *ptr = precv_frame->rx_data, *psa;
-	struct rx_pkt_attrib *pattrib = &(precv_frame->attrib);
-	struct tdls_info *ptdlsinfo = &(adapter->tdlsinfo);
-	u8 empty_addr[ETH_ALEN] = { 0x00 };
-	int UndecoratedSmoothedPWDB;
-
-	/* WFDTDLS: for sigma test, not to setup direct link automatically */
-	ptdlsinfo->dev_discovered = 1;
-
-#ifdef CONFIG_TDLS_AUTOSETUP
-	psa = get_sa(ptr);
-	ptdls_sta = rtw_get_stainfo(&(adapter->stapriv), psa);
-
-	if (ptdls_sta != NULL) {
-		ptdls_sta->tdls_sta_state |= TDLS_ALIVE_STATE;
-
-		/* Record the tdls sta with lowest signal strength */
-		if ((ptdlsinfo->sta_maximum == true) && (ptdls_sta->alive_count >= 1)) {
-			if (_rtw_memcmp(ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN)) {
-				memcpy(ptdlsinfo->ss_record.macaddr, psa, ETH_ALEN);
-				ptdlsinfo->ss_record.rxpwdb_all = pattrib->rxpwdb_all;
-			} else {
-				if (ptdlsinfo->ss_record.rxpwdb_all < pattrib->rxpwdb_all) {
-					memcpy(ptdlsinfo->ss_record.macaddr, psa, ETH_ALEN);
-					ptdlsinfo->ss_record.rxpwdb_all = pattrib->rxpwdb_all;
-				}
-			}
-	}
-
-	} else {
-		if (ptdlsinfo->sta_maximum == true) {
-			if (_rtw_memcmp(ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN)) {
-				/* All traffics are busy, do not set up another direct link. */
-				return _FAIL;
-			} else {
-				if (pattrib->rxpwdb_all > ptdlsinfo->ss_record.rxpwdb_all)
-					issue_tdls_teardown(adapter, ptdlsinfo->ss_record.macaddr);
-				else
-					return _FAIL;
-			}
-		}
-
-		rtw_hal_get_def_var(adapter, HAL_DEF_UNDERCORATEDSMOOTHEDPWDB, &UndecoratedSmoothedPWDB);
-
-		if (pattrib->rxpwdb_all + TDLS_SIGNAL_THRESH >= UndecoratedSmoothedPWDB) {
-			DBG_871X("pattrib->rxpwdb_all =%d, pdmpriv->UndecoratedSmoothedPWDB =%d\n",
-				 pattrib->rxpwdb_all, UndecoratedSmoothedPWDB);
-			issue_tdls_setup_req(adapter, psa);
-		}
-	}
-#endif /* CONFIG_TDLS_AUTOSETUP */
-
-	return _SUCCESS;
-}
-
-int On_TDLS_Setup_Req(_adapter *adapter, struct recv_frame_hdr *precv_frame)
-{
-	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
-	u8 *psa, *pmyid;
-	struct sta_info *ptdls_sta = NULL;
-	struct sta_priv *pstapriv = &adapter->stapriv;
-	u8 *ptr = precv_frame->rx_data;
-	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
-	struct security_priv *psecuritypriv = &adapter->securitypriv;
-	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->attrib;
-	u8 *prsnie, *ppairwise_cipher;
-	u8 i, k, pairwise_count;
-	u8 ccmp_have = 0, rsnie_have = 0;
-	u16 j;
-	u8 SNonce[32];
-	u32 *timeout_interval;
-	int parsing_length;	/* frame body length, without icv_len */
-	PNDIS_802_11_VARIABLE_IEs	pIE;
-	u8 FIXED_IE = 5;
-	unsigned char		supportRate[16];
-	int				supportRateNum = 0;
-
-	psa = get_sa(ptr);
-	ptdls_sta = rtw_get_stainfo(pstapriv, psa);
-
-	pmyid = myid(&(adapter->eeprompriv));
-	ptr += prx_pkt_attrib->hdrlen + prx_pkt_attrib->iv_len+LLC_HEADER_SIZE+TYPE_LENGTH_FIELD_SIZE+1;
-	parsing_length = ((struct recv_frame_hdr *)precv_frame)->len
-			-prx_pkt_attrib->hdrlen
-			-prx_pkt_attrib->iv_len
-			-prx_pkt_attrib->icv_len
-			-LLC_HEADER_SIZE
-			-ETH_TYPE_LEN
-			-PAYLOAD_TYPE_LEN
-			-FIXED_IE;
-
-	if (ptdlsinfo->ap_prohibited == true)
-		goto exit;
-
-	if (ptdls_sta == NULL) {
-		ptdls_sta = rtw_alloc_stainfo(pstapriv, psa);
-	} else {
-		if (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) {
-			/* If the direct link is already set up */
-			/* Process as re-setup after tear down */
-			DBG_871X("re-setup a direct link\n");
-		}
-		/* already receiving TDLS setup request */
-		else if (ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE) {
-			DBG_871X("receive duplicated TDLS setup request frame in handshaking\n");
-			goto exit;
-		}
-		/* When receiving and sending setup_req to the same link at the same time, STA with higher MAC_addr would be initiator */
-		/* following is to check out MAC_addr */
-		else if (ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE) {
-			DBG_871X("receive setup_req after sending setup_req\n");
-			for (i = 0; i < 6; i++) {
-				if (*(pmyid+i) == *(psa+i)) {
-					;
-				} else if (*(pmyid+i) > *(psa+i)) {
-					goto exit;
-				} else if (*(pmyid+i) < *(psa+i)) {
-					ptdls_sta->tdls_sta_state = TDLS_INITIATOR_STATE;
-					break;
-				}
-			}
-		}
-	}
-
-	if (ptdls_sta) {
-		ptdls_sta->dialog = *(ptr+2);	/* copy dialog token */
-		ptdls_sta->stat_code = 0;
-
-		/* parsing information element */
-		for (j = FIXED_IE; j < parsing_length;) {
-			pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr + j);
-
-			switch (pIE->ElementID) {
-			case _SUPPORTEDRATES_IE_:
-				memcpy(supportRate, pIE->data, pIE->Length);
-				supportRateNum = pIE->Length;
-				break;
-			case _COUNTRY_IE_:
-				break;
-			case _EXT_SUPPORTEDRATES_IE_:
-				if (supportRateNum <= sizeof(supportRate)) {
-					memcpy(supportRate+supportRateNum, pIE->data, pIE->Length);
-					supportRateNum += pIE->Length;
-				}
-				break;
-			case _SUPPORTED_CH_IE_:
-				break;
-			case _RSN_IE_2_:
-				rsnie_have = 1;
-				if (prx_pkt_attrib->encrypt) {
-					prsnie = (u8 *)pIE;
-					/* check whether initiator STA has CCMP pairwise_cipher. */
-					ppairwise_cipher = prsnie+10;
-					memcpy(&pairwise_count, (u16 *)(ppairwise_cipher-2), 1);
-					for (k = 0; k < pairwise_count; k++) {
-						if (_rtw_memcmp(ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4) == true)
-							ccmp_have = 1;
-					}
-					if (ccmp_have == 0) {
-						/* invalid contents of RSNIE */
-						ptdls_sta->stat_code = 72;
-					}
-				}
-				break;
-			case _EXT_CAP_IE_:
-				break;
-			case _VENDOR_SPECIFIC_IE_:
-				break;
-			case _FTIE_:
-				if (prx_pkt_attrib->encrypt)
-					memcpy(SNonce, (ptr+j+52), 32);
-				break;
-			case _TIMEOUT_ITVL_IE_:
-				if (prx_pkt_attrib->encrypt)
-					timeout_interval = (u32 *)(ptr+j+3);
-				break;
-			case _RIC_Descriptor_IE_:
-				break;
-			case _HT_CAPABILITY_IE_:
-				rtw_tdls_process_ht_cap(adapter, ptdls_sta, pIE->data, pIE->Length);
-				break;
-			case EID_BSSCoexistence:
-				break;
-			case _LINK_ID_IE_:
-				if (_rtw_memcmp(get_bssid(pmlmepriv), pIE->data, 6) == false) {
-					/* not in the same BSS */
-					ptdls_sta->stat_code = 7;
-				}
-				break;
-			default:
-				break;
-			}
-			j += (pIE->Length + 2);
-		}
-
-		/* update station supportRate */
-		ptdls_sta->bssratelen = supportRateNum;
-		memcpy(ptdls_sta->bssrateset, supportRate, supportRateNum);
-
-		/* check status code */
-		/* if responder STA has/hasn't security on AP, but request hasn't/has RSNIE, it should reject */
-		if (ptdls_sta->stat_code == 0) {
-			if (rsnie_have && (prx_pkt_attrib->encrypt == 0)) {
-				/* security disabled */
-				ptdls_sta->stat_code = 5;
-			} else if (rsnie_have == 0 && (prx_pkt_attrib->encrypt)) {
-				/* request haven't RSNIE */
-				ptdls_sta->stat_code = 38;
-			}
-
-		}
-
-		ptdls_sta->tdls_sta_state |= TDLS_INITIATOR_STATE;
-		if (prx_pkt_attrib->encrypt) {
-			memcpy(ptdls_sta->SNonce, SNonce, 32);
-			memcpy(&(ptdls_sta->TDLS_PeerKey_Lifetime), timeout_interval, 4);
-		}
-		spin_lock_bh(&(pstapriv->sta_hash_lock));
-		if (!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
-			ptdlsinfo->sta_cnt++;
-		spin_unlock_bh(&(pstapriv->sta_hash_lock));
-		if (ptdlsinfo->sta_cnt == (NUM_STA - 2))	/*  -2: AP + BC/MC sta */
-			ptdlsinfo->sta_maximum = true;
-	} else {
-		goto exit;
-	}
-
-	issue_tdls_setup_rsp(adapter, precv_frame);
-
-	if (ptdls_sta->stat_code == 0)
-		_set_timer(&ptdls_sta->handshake_timer, TDLS_HANDSHAKE_TIME);
-	else		/* status code!= 0 ; setup unsuccess */
-		free_tdls_sta(adapter, ptdls_sta);
-exit:
-
-	return _FAIL;
-}
-
-int On_TDLS_Setup_Rsp(_adapter *adapter, struct recv_frame_hdr *precv_frame)
-{
-	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
-	struct sta_info *ptdls_sta = NULL;
-	struct sta_priv *pstapriv = &adapter->stapriv;
-	u8 *ptr = precv_frame->rx_data;
-	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->attrib;
-	u8 *psa;
-	u16 stat_code;
-	int parsing_length;	/* frame body length, without icv_len */
-	PNDIS_802_11_VARIABLE_IEs	pIE;
-	u8 FIXED_IE = 7;
-	u8  *pftie, *ptimeout_ie, *plinkid_ie, *prsnie, *pftie_mic, *ppairwise_cipher;
-	u16 pairwise_count, j, k;
-	u8 verify_ccmp = 0;
-	unsigned char		supportRate[16];
-	int				supportRateNum = 0;
-
-	psa = get_sa(ptr);
-	ptdls_sta = rtw_get_stainfo(pstapriv, psa);
-
-	if (NULL == ptdls_sta)
-		return _FAIL;
-
-	ptr += prx_pkt_attrib->hdrlen + prx_pkt_attrib->iv_len+LLC_HEADER_SIZE+TYPE_LENGTH_FIELD_SIZE+1;
-	parsing_length = ((struct recv_frame_hdr *)precv_frame)->len
-			-prx_pkt_attrib->hdrlen
-			-prx_pkt_attrib->iv_len
-			-prx_pkt_attrib->icv_len
-			-LLC_HEADER_SIZE
-			-TYPE_LENGTH_FIELD_SIZE
-			-1
-			-FIXED_IE;
-
-	memcpy(&stat_code, ptr+2, 2);
-
-	if (stat_code != 0) {
-		DBG_871X("[%s] status_code = %d, free_tdls_sta\n", __func__, stat_code);
-		free_tdls_sta(adapter, ptdls_sta);
-		return _FAIL;
-	}
-
-	stat_code = 0;
-
-	/* parsing information element */
-	for (j = FIXED_IE; j < parsing_length;) {
-		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr + j);
-
-		switch (pIE->ElementID) {
-		case _SUPPORTEDRATES_IE_:
-			memcpy(supportRate, pIE->data, pIE->Length);
-			supportRateNum = pIE->Length;
-			break;
-		case _COUNTRY_IE_:
-			break;
-		case _EXT_SUPPORTEDRATES_IE_:
-			if (supportRateNum <= sizeof(supportRate)) {
-				memcpy(supportRate+supportRateNum, pIE->data, pIE->Length);
-				supportRateNum += pIE->Length;
-			}
-			break;
-		case _SUPPORTED_CH_IE_:
-			break;
-		case _RSN_IE_2_:
-			prsnie = (u8 *)pIE;
-			/* check whether responder STA has CCMP pairwise_cipher. */
-			ppairwise_cipher = prsnie+10;
-			memcpy(&pairwise_count, (u16 *)(ppairwise_cipher-2), 2);
-			for (k = 0; k < pairwise_count; k++) {
-				if (_rtw_memcmp(ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4) == true)
-					verify_ccmp = 1;
-			}
-		case _EXT_CAP_IE_:
-			break;
-		case _VENDOR_SPECIFIC_IE_:
-			break;
-		case _FTIE_:
-			pftie = (u8 *)pIE;
-			memcpy(ptdls_sta->ANonce, (ptr+j+20), 32);
-			break;
-		case _TIMEOUT_ITVL_IE_:
-			ptimeout_ie = (u8 *)pIE;
-			break;
-		case _RIC_Descriptor_IE_:
-			break;
-		case _HT_CAPABILITY_IE_:
-			rtw_tdls_process_ht_cap(adapter, ptdls_sta, pIE->data, pIE->Length);
-			break;
-		case EID_BSSCoexistence:
-			break;
-		case _LINK_ID_IE_:
-			plinkid_ie = (u8 *)pIE;
-			break;
-		default:
-			break;
-		}
-		j += (pIE->Length + 2);
-	}
-
-	/* update station supportRate */
-	ptdls_sta->bssratelen = supportRateNum;
-	memcpy(ptdls_sta->bssrateset, supportRate, supportRateNum);
-
-	if (stat_code != 0) {
-		ptdls_sta->stat_code = stat_code;
-	} else {
-		if (prx_pkt_attrib->encrypt) {
-			if (verify_ccmp == 1) {
-				wpa_tdls_generate_tpk(adapter, ptdls_sta);
-				ptdls_sta->stat_code = 0;
-				if (tdls_verify_mic(ptdls_sta->tpk.kck, 2, plinkid_ie, prsnie, ptimeout_ie, pftie) == 0) {	/* 0: Invalid, 1: valid */
-					free_tdls_sta(adapter, ptdls_sta);
-					return _FAIL;
-				}
-			} else {
-				ptdls_sta->stat_code = 72;	/* invalide contents of RSNIE */
-			}
-
-		} else {
-			ptdls_sta->stat_code = 0;
-		}
-	}
-
-	DBG_871X("issue_tdls_setup_cfm\n");
-	issue_tdls_setup_cfm(adapter, precv_frame);
-
-	if (ptdls_sta->stat_code == 0) {
-		ptdlsinfo->setup_state = TDLS_LINKED_STATE;
-
-		if (ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE) {
-			ptdls_sta->tdls_sta_state |= TDLS_LINKED_STATE;
-			_cancel_timer_ex(&ptdls_sta->handshake_timer);
-#ifdef CONFIG_TDLS_AUTOCHECKALIVE
-			_set_timer(&ptdls_sta->alive_timer1, TDLS_ALIVE_TIMER_PH1);
-#endif /* CONFIG_TDLS_AUTOSETUP */
-		}
-
-		rtw_tdls_set_mac_id(ptdlsinfo, ptdls_sta);
-		rtw_tdls_set_key(adapter, prx_pkt_attrib, ptdls_sta);
-
-		rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_WRCR);
-
-	} else { /* status code!= 0 ; setup unsuccessful */
-		free_tdls_sta(adapter, ptdls_sta);
-	}
-
-	return _FAIL;
-}
-
-int On_TDLS_Setup_Cfm(_adapter *adapter, struct recv_frame_hdr *precv_frame)
-{
-	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
-	struct sta_info *ptdls_sta = NULL;
-	struct sta_priv *pstapriv = &adapter->stapriv;
-	u8 *ptr = precv_frame->rx_data;
-	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->attrib;
-	u8 *psa;
-	u16 stat_code;
-	int parsing_length;
-	PNDIS_802_11_VARIABLE_IEs	pIE;
-	u8 FIXED_IE = 5;
-	u8  *pftie, *ptimeout_ie, *plinkid_ie, *prsnie, *pftie_mic, *ppairwise_cipher;
-	u16 j, pairwise_count;
-
-	psa = get_sa(ptr);
-	ptdls_sta = rtw_get_stainfo(pstapriv, psa);
-
-	ptr += prx_pkt_attrib->hdrlen + prx_pkt_attrib->iv_len+LLC_HEADER_SIZE+TYPE_LENGTH_FIELD_SIZE+1;
-	parsing_length = ((struct recv_frame_hdr *)precv_frame)->len
-			-prx_pkt_attrib->hdrlen
-			-prx_pkt_attrib->iv_len
-			-prx_pkt_attrib->icv_len
-			-LLC_HEADER_SIZE
-			-ETH_TYPE_LEN
-			-PAYLOAD_TYPE_LEN
-			-FIXED_IE;
-	memcpy(&stat_code, ptr+2, 2);
-
-	if (stat_code != 0) {
-		DBG_871X("[%s] stat_code = %d\n, free_tdls_sta", __func__, stat_code);
-		free_tdls_sta(adapter, ptdls_sta);
-		return _FAIL;
-	}
-
-	if (prx_pkt_attrib->encrypt) {
-		/* parsing information element */
-		for (j = FIXED_IE; j < parsing_length;) {
-			pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr + j);
-
-			switch (pIE->ElementID) {
-			case _RSN_IE_2_:
-				prsnie = (u8 *)pIE;
-				break;
-			case _VENDOR_SPECIFIC_IE_:
-				break;
-			case _FTIE_:
-				pftie = (u8 *)pIE;
-				break;
-			case _TIMEOUT_ITVL_IE_:
-				ptimeout_ie = (u8 *)pIE;
-				break;
-			case _HT_EXTRA_INFO_IE_:
-				break;
-			case _LINK_ID_IE_:
-				plinkid_ie = (u8 *)pIE;
-				break;
-			default:
-				break;
-			}
-			j += (pIE->Length + 2);
-		}
-
-		/* verify mic in FTIE MIC field */
-		if (tdls_verify_mic(ptdls_sta->tpk.kck, 3, plinkid_ie, prsnie, ptimeout_ie, pftie) == 0) {	/* 0: Invalid, 1: Valid */
-			free_tdls_sta(adapter, ptdls_sta);
-			return _FAIL;
-		}
-	}
-
-	ptdlsinfo->setup_state = TDLS_LINKED_STATE;
-	if (ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE) {
-		ptdls_sta->tdls_sta_state |= TDLS_LINKED_STATE;
-		_cancel_timer_ex(&ptdls_sta->handshake_timer);
-#ifdef CONFIG_TDLS_AUTOCHECKALIVE
-		_set_timer(&ptdls_sta->alive_timer1, TDLS_ALIVE_TIMER_PH1);
-#endif /* CONFIG_TDLS_AUTOCHECKALIVE */
-	}
-
-	rtw_tdls_set_mac_id(ptdlsinfo, ptdls_sta);
-	rtw_tdls_set_key(adapter, prx_pkt_attrib, ptdls_sta);
-
-	rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_WRCR);
-
-	return _FAIL;
-}
-
-int On_TDLS_Dis_Req(_adapter *adapter, struct recv_frame_hdr *precv_frame)
-{
-	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->attrib;
-	struct sta_priv *pstapriv = &adapter->stapriv;
-	struct sta_info *psta_ap;
-	u8 *ptr = precv_frame->rx_data;
-	int parsing_length;	/* frame body length, without icv_len */
-	PNDIS_802_11_VARIABLE_IEs	pIE;
-	u8 FIXED_IE = 3, *dst, *pdialog = NULL;
-	u16 j;
-
-	ptr += prx_pkt_attrib->hdrlen + prx_pkt_attrib->iv_len + LLC_HEADER_SIZE+TYPE_LENGTH_FIELD_SIZE + 1;
-	pdialog = ptr+2;
-
-	parsing_length = ((struct recv_frame_hdr *)precv_frame)->len
-			-prx_pkt_attrib->hdrlen
-			-prx_pkt_attrib->iv_len
-			-prx_pkt_attrib->icv_len
-			-LLC_HEADER_SIZE
-			-TYPE_LENGTH_FIELD_SIZE
-			-1
-			-FIXED_IE;
-
-	/* parsing information element */
-	for (j = FIXED_IE; j < parsing_length;) {
-		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr + j);
-
-		switch (pIE->ElementID) {
-		case _LINK_ID_IE_:
-			psta_ap = rtw_get_stainfo(pstapriv, pIE->data);
-			if (psta_ap == NULL)
-				goto exit;
-			dst = pIE->data + 12;
-			if ((MacAddr_isBcst(dst) == false) && (_rtw_memcmp(myid(&(adapter->eeprompriv)), dst, 6) == false))
-				goto exit;
-			break;
-		default:
-			break;
-		}
-		j += (pIE->Length + 2);
-	}
-
-	/* check frame contents */
-
-	issue_tdls_dis_rsp(adapter, precv_frame, *(pdialog));
-
-exit:
-
-	return _FAIL;
-}
-
-int On_TDLS_Teardown(_adapter *adapter, struct recv_frame_hdr *precv_frame)
-{
-	u8 *psa;
-	u8 *ptr = precv_frame->rx_data;
-	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->attrib;
-	struct mlme_ext_priv	*pmlmeext = &(adapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct sta_priv		*pstapriv = &adapter->stapriv;
-	struct sta_info *ptdls_sta = NULL;
-
-	psa = get_sa(ptr);
-
-	ptdls_sta = rtw_get_stainfo(pstapriv, psa);
-	if (ptdls_sta != NULL) {
-		if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE) {
-			rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
-		}
-		free_tdls_sta(adapter, ptdls_sta);
-	}
-
-	return _FAIL;
-}
-
-u8 TDLS_check_ch_state(uint state)
-{
-	if ((state & TDLS_CH_SWITCH_ON_STATE) &&
-	    (state & TDLS_AT_OFF_CH_STATE) &&
-	    (state & TDLS_PEER_AT_OFF_STATE)) {
-		if (state & TDLS_PEER_SLEEP_STATE)
-			return 2;	/* U-APSD + ch. switch */
-		else
-			return 1;	/* ch. switch */
-	} else {
-		return 0;
-	}
-}
-
-/* we process buffered data for 1. U-APSD, 2. ch. switch, 3. U-APSD + ch. switch here */
-int On_TDLS_Peer_Traffic_Rsp(_adapter *adapter, struct recv_frame_hdr *precv_frame)
-{
-	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
-	struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
-	struct rx_pkt_attrib	*pattrib = &precv_frame->attrib;
-	struct sta_priv *pstapriv = &adapter->stapriv;
-	/* get peer sta infomation */
-	struct sta_info *ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->src);
-	u8 wmmps_ac = 0, state = TDLS_check_ch_state(ptdls_sta->tdls_sta_state);
-	int i;
-
-	ptdls_sta->sta_stats.rx_data_pkts++;
-
-	/* receive peer traffic response frame, sleeping STA wakes up */
-	/* ptdls_sta->tdls_sta_state &= ~(TDLS_PEER_SLEEP_STATE); */
-	process_wmmps_data(adapter, precv_frame);
-
-	/*  if noticed peer STA wakes up by receiving peer traffic response */
-	/*  and we want to do channel swtiching, then we will transmit channel switch request first */
-	if (ptdls_sta->tdls_sta_state & TDLS_APSD_CHSW_STATE) {
-		issue_tdls_ch_switch_req(adapter, pattrib->src);
-		ptdls_sta->tdls_sta_state &= ~(TDLS_APSD_CHSW_STATE);
-		return  _FAIL;
-	}
-
-	/* check 4-AC queue bit */
-	if (ptdls_sta->uapsd_vo || ptdls_sta->uapsd_vi || ptdls_sta->uapsd_be || ptdls_sta->uapsd_bk)
-		wmmps_ac = 1;
-
-	/* if it's a direct link and have buffered frame */
-	if (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) {
-		if (wmmps_ac && state) {
-			_list	*xmitframe_plist, *xmitframe_phead;
-			struct xmit_frame *pxmitframe = NULL;
-
-			spin_lock_bh(&ptdls_sta->sleep_q.lock);
-
-			xmitframe_phead = get_list_head(&ptdls_sta->sleep_q);
-			xmitframe_plist = xmitframe_phead->next;
-
-			/* transmit buffered frames */
-			while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
-				pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
-				xmitframe_plist = xmitframe_plist->next;
-				list_del_init(&pxmitframe->list);
-
-				ptdls_sta->sleepq_len--;
-				if (ptdls_sta->sleepq_len > 0) {
-					pxmitframe->attrib.mdata = 1;
-					pxmitframe->attrib.eosp = 0;
-				} else {
-					pxmitframe->attrib.mdata = 0;
-					pxmitframe->attrib.eosp = 1;
-				}
-				if (rtw_hal_xmit(adapter, pxmitframe) == true)
-					rtw_os_xmit_complete(adapter, pxmitframe);
-			}
-
-			if (ptdls_sta->sleepq_len == 0) {
-				DBG_871X("no buffered packets for tdls to xmit\n");
-				/* on U-APSD + CH. switch state, when there is no buffered date to xmit, */
-				/*  we should go back to base channel */
-				if (state == 2) {
-					rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
-				} else if (ptdls_sta->tdls_sta_state&TDLS_SW_OFF_STATE) {
-						ptdls_sta->tdls_sta_state &= ~(TDLS_SW_OFF_STATE);
-						ptdlsinfo->candidate_ch = pmlmeext->cur_channel;
-						issue_tdls_ch_switch_req(adapter, pattrib->src);
-						DBG_871X("issue tdls ch switch req back to base channel\n");
-				}
-
-			} else {
-				DBG_871X("error!psta->sleepq_len =%d\n", ptdls_sta->sleepq_len);
-				ptdls_sta->sleepq_len = 0;
-			}
-
-			spin_unlock_bh(&ptdls_sta->sleep_q.lock);
-		}
-	}
-	return _FAIL;
-}
-
-int On_TDLS_Ch_Switch_Req(_adapter *adapter, struct recv_frame_hdr *precv_frame)
-{
-	struct sta_info *ptdls_sta = NULL;
-	struct sta_priv *pstapriv = &adapter->stapriv;
-	u8 *ptr = precv_frame->rx_data;
-	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->attrib;
-	u8 *psa;
-	int parsing_length;
-	PNDIS_802_11_VARIABLE_IEs	pIE;
-	u8 FIXED_IE = 3;
-	u16 j;
-	struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
-
-	psa = get_sa(ptr);
-	ptdls_sta = rtw_get_stainfo(pstapriv, psa);
-
-	ptr += prx_pkt_attrib->hdrlen + prx_pkt_attrib->iv_len+LLC_HEADER_SIZE+TYPE_LENGTH_FIELD_SIZE+1;
-	parsing_length = ((struct recv_frame_hdr *)precv_frame)->len
-			-prx_pkt_attrib->hdrlen
-			-prx_pkt_attrib->iv_len
-			-prx_pkt_attrib->icv_len
-			-LLC_HEADER_SIZE
-			-ETH_TYPE_LEN
-			-PAYLOAD_TYPE_LEN
-			-FIXED_IE;
-
-	ptdls_sta->off_ch = *(ptr+2);
-
-	/* parsing information element */
-	for (j = FIXED_IE; j < parsing_length;) {
-		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr + j);
-
-		switch (pIE->ElementID) {
-		case _COUNTRY_IE_:
-			break;
-		case _CH_SWTICH_ANNOUNCE_:
-			break;
-		case _LINK_ID_IE_:
-			break;
-		case _CH_SWITCH_TIMING_:
-			memcpy(&ptdls_sta->ch_switch_time, pIE->data, 2);
-			memcpy(&ptdls_sta->ch_switch_timeout, pIE->data+2, 2);
-		default:
-			break;
-		}
-		j += (pIE->Length + 2);
-	}
-
-	/* todo: check status */
-	ptdls_sta->stat_code = 0;
-	ptdls_sta->tdls_sta_state |= TDLS_CH_SWITCH_ON_STATE;
-
-	issue_nulldata(adapter, NULL, 1, 0, 0);
-
-	issue_tdls_ch_switch_rsp(adapter, psa);
-
-	DBG_871X("issue tdls channel switch response\n");
-
-	if ((ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE) && ptdls_sta->off_ch == pmlmeext->cur_channel) {
-		DBG_871X("back to base channel %x\n", pmlmeext->cur_channel);
-		ptdls_sta->option = 7;
-		rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_BASE_CH);
-	} else {
-		ptdls_sta->option = 6;
-		rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_OFF_CH);
-	}
-	return _FAIL;
-}
-
-int On_TDLS_Ch_Switch_Rsp(_adapter *adapter, struct recv_frame_hdr *precv_frame)
-{
-	struct sta_info *ptdls_sta = NULL;
-	struct sta_priv *pstapriv = &adapter->stapriv;
-	u8 *ptr = precv_frame->rx_data;
-	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->attrib;
-	u8 *psa;
-	int parsing_length;
-	PNDIS_802_11_VARIABLE_IEs	pIE;
-	u8 FIXED_IE = 4;
-	u16 stat_code, j, switch_time, switch_timeout;
-	struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
-
-	psa = get_sa(ptr);
-	ptdls_sta = rtw_get_stainfo(pstapriv, psa);
-
-	/* if channel switch is running and receiving Unsolicited TDLS Channel Switch Response, */
-	/* it will go back to base channel and terminate this channel switch procedure */
-	if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE) {
-		if (pmlmeext->cur_channel == ptdls_sta->off_ch) {
-			DBG_871X("back to base channel %x\n", pmlmeext->cur_channel);
-			ptdls_sta->option = 7;
-			rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_OFF_CH);
-		} else {
-			DBG_871X("receive unsolicited channel switch response\n");
-			rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
-		}
-		return _FAIL;
-	}
-
-	/* avoiding duplicated or unconditional ch. switch. rsp */
-	if ((ptdls_sta->tdls_sta_state & TDLS_CH_SW_INITIATOR_STATE) != TDLS_CH_SW_INITIATOR_STATE)
-		return _FAIL;
-
-	ptr += prx_pkt_attrib->hdrlen + prx_pkt_attrib->iv_len+LLC_HEADER_SIZE+TYPE_LENGTH_FIELD_SIZE+1;
-	parsing_length = ((struct recv_frame_hdr *)precv_frame)->len
-			-prx_pkt_attrib->hdrlen
-			-prx_pkt_attrib->iv_len
-			-prx_pkt_attrib->icv_len
-			-LLC_HEADER_SIZE
-			-ETH_TYPE_LEN
-			-PAYLOAD_TYPE_LEN
-			-FIXED_IE;
-
-	memcpy(&stat_code, ptr+2, 2);
-
-	if (stat_code != 0)
-		return _FAIL;
-
-	/* parsing information element */
-	for (j = FIXED_IE; j < parsing_length;) {
-		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr + j);
-
-		switch (pIE->ElementID) {
-		case _LINK_ID_IE_:
-			break;
-		case _CH_SWITCH_TIMING_:
-			memcpy(&switch_time, pIE->data, 2);
-			if (switch_time > ptdls_sta->ch_switch_time)
-				memcpy(&ptdls_sta->ch_switch_time, &switch_time, 2);
-
-			memcpy(&switch_timeout, pIE->data+2, 2);
-			if (switch_timeout > ptdls_sta->ch_switch_timeout)
-				memcpy(&ptdls_sta->ch_switch_timeout, &switch_timeout, 2);
-
-		default:
-			break;
-		}
-		j += (pIE->Length + 2);
-	}
-
-	ptdls_sta->tdls_sta_state &= ~(TDLS_CH_SW_INITIATOR_STATE);
-	ptdls_sta->tdls_sta_state |= TDLS_CH_SWITCH_ON_STATE;
-
-	/* goto set_channel_workitem_callback() */
-	ptdls_sta->option = 6;
-	rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_OFF_CH);
-
-	return _FAIL;
-}
-
-void rtw_build_tdls_setup_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
-{
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &pmlmeext->mlmext_info;
-	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
-	struct sta_info *ptdls_sta = rtw_get_stainfo((&padapter->stapriv) , pattrib->dst);
-
-	u8 payload_type = 0x02;
-	u8 category = RTW_WLAN_CATEGORY_TDLS;
-	u8 action = TDLS_SETUP_REQUEST;
-	u8 bssrate[NDIS_802_11_LENGTH_RATES_EX]; /* Use NDIS_802_11_LENGTH_RATES_EX in order to call func.rtw_set_supported_rate */
-	int	bssrate_len = 0, i = 0 ;
-	u8 more_supportedrates = 0;
-	unsigned int ie_len;
-	u8 *p;
-	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-	u8 link_id_addr[18] = {0};
-	u8 iedata = 0;
-	u8 sup_ch[30 * 2] = {0x00 }, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
-	u8 timeout_itvl[5];	/* set timeout interval to maximum value */
-	u32 time;
-
-	/* SNonce */
-	if (pattrib->encrypt) {
-		for (i = 0; i < 8; i++) {
-			time = rtw_get_current_time();
-			memcpy(&ptdls_sta->SNonce[4*i], (u8 *)&time, 4);
-		}
-	}
-
-	/* payload type */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	/* category, action, dialog token */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(ptdls_sta->dialog), &(pattrib->pktlen));
-
-	/* capability */
-	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
-
-	if (pattrib->encrypt)
-		*pframe = *pframe | BIT(4);
-	pframe += 2;
-	pattrib->pktlen += 2;
-
-	/* supported rates */
-	rtw_set_supported_rate(bssrate, WIRELESS_11BG_24N);
-	bssrate_len = IEEE80211_CCK_RATE_LEN + IEEE80211_NUM_OFDM_RATESLEN;
-
-	if (bssrate_len > 8) {
-		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , 8, bssrate, &(pattrib->pktlen));
-		more_supportedrates = 1;
-	} else {
-		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));
-	}
-
-	/* country(optional) */
-	/* extended supported rates */
-	if (more_supportedrates == 1) {
-		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
-	}
-
-	/* supported channels */
-	pframe = rtw_tdls_set_sup_ch(pmlmeext, pframe, pattrib);
-
-	/*	SRC IE */
-	pframe = rtw_set_ie(pframe, _SRC_IE_, 16, TDLS_SRC, &(pattrib->pktlen));
-
-	/* RSNIE */
-	if (pattrib->encrypt)
-		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
-
-	/* extended capabilities */
-	pframe = rtw_set_ie(pframe, _EXT_CAP_IE_ , 5, TDLS_EXT_CAPIE, &(pattrib->pktlen));
-
-	/* QoS capability(WMM_IE) */
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 7, TDLS_WMMIE,  &(pattrib->pktlen));
-
-	if (pattrib->encrypt) {
-		/* FTIE */
-		memset(pframe, 0, 84);	/* All fields except SNonce shall be set to 0 */
-		memset(pframe, _FTIE_, 1);	/* version */
-		memset((pframe+1), 82, 1);	/* length */
-		memcpy((pframe+52), ptdls_sta->SNonce, 32);
-		pframe += 84;
-		pattrib->pktlen += 84;
-
-		/* Timeout interval */
-		timeout_itvl[0] = 0x02;
-		memcpy(timeout_itvl+1, (u8 *)(&ptdls_sta->TDLS_PeerKey_Lifetime), 4);
-		pframe = rtw_set_ie(pframe, _TIMEOUT_ITVL_IE_, 5, timeout_itvl,  &(pattrib->pktlen));
-	}
-
-	/* Sup_reg_classes(optional) */
-	/* HT capabilities */
-	pframe = rtw_tdls_set_ht_cap(padapter, pframe, pattrib);
-
-	/* 20/40 BSS coexistence */
-	if (pmlmepriv->num_FortyMHzIntolerant > 0)
-		iedata |= BIT(2);/* 20 MHz BSS Width Request */
-	pframe = rtw_set_ie(pframe, EID_BSSCoexistence,  1, &iedata, &(pattrib->pktlen));
-
-	/* Link identifier */
-	memcpy(link_id_addr, pattrib->ra, 6);
-	memcpy((link_id_addr+6), pattrib->src, 6);
-	memcpy((link_id_addr+12), pattrib->dst, 6);
-	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-}
-
-void rtw_build_tdls_setup_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
-{
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	struct sta_info *ptdls_sta;
-	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
-
-	u8 payload_type = 0x02;
-	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
-	unsigned char action = TDLS_SETUP_RESPONSE;
-	unsigned char	bssrate[NDIS_802_11_LENGTH_RATES_EX];
-	int	bssrate_len = 0;
-	u8 more_supportedrates = 0;
-	unsigned int ie_len;
-	unsigned char *p;
-	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-	u8 link_id_addr[18] = {0};
-	u8 iedata = 0;
-	u8 timeout_itvl[5];	/* setup response timeout interval will copy from request */
-	u8 ANonce[32];	/* maybe it can put in ontdls_req */
-	u8 k;		/* for random ANonce */
-	u8  *pftie, *ptimeout_ie, *plinkid_ie, *prsnie, *pftie_mic;
-	u32 time;
-
-	ptdls_sta = rtw_get_stainfo(&(padapter->stapriv) , pattrib->dst);
-
-	if (ptdls_sta == NULL) {
-		DBG_871X("[%s] %d\n", __func__, __LINE__);
-		return;
-	}
-
-	if (pattrib->encrypt) {
-		for (k = 0; k < 8; k++) {
-			time = rtw_get_current_time();
-			memcpy(&ptdls_sta->ANonce[4*k], (u8 *)&time, 4);
-		}
-	}
-
-	/* payload type */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	/* category, action, status code */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 2, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
-
-	if (ptdls_sta->stat_code != 0) {	/* invalid setup request */
-		DBG_871X("ptdls_sta->stat_code:%04x\n", ptdls_sta->stat_code);
-		return;
-	}
-
-	/* dialog token */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(ptdls_sta->dialog), &(pattrib->pktlen));
-
-	/* capability */
-	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
-
-	if (pattrib->encrypt)
-		*pframe = *pframe | BIT(4);
-	pframe += 2;
-	pattrib->pktlen += 2;
-
-	/* supported rates */
-	rtw_set_supported_rate(bssrate, WIRELESS_11BG_24N);
-	bssrate_len = IEEE80211_CCK_RATE_LEN + IEEE80211_NUM_OFDM_RATESLEN;
-
-	if (bssrate_len > 8) {
-		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , 8, bssrate, &(pattrib->pktlen));
-		more_supportedrates = 1;
-	} else {
-		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));
-	}
-
-	/* country(optional) */
-	/* extended supported rates */
-	if (more_supportedrates == 1) {
-		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
-	}
-
-	/* supported channels */
-	pframe = rtw_tdls_set_sup_ch(pmlmeext, pframe, pattrib);
-
-	/*  SRC IE */
-	pframe = rtw_set_ie(pframe, _SRC_IE_ , 16, TDLS_SRC, &(pattrib->pktlen));
-
-	/* RSNIE */
-	if (pattrib->encrypt) {
-		prsnie = pframe;
-		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
-	}
-
-	/* extended capabilities */
-	pframe = rtw_set_ie(pframe, _EXT_CAP_IE_ , 5, TDLS_EXT_CAPIE, &(pattrib->pktlen));
-
-	/* QoS capability(WMM_IE) */
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 7, TDLS_WMMIE,  &(pattrib->pktlen));
-
-	if (pattrib->encrypt) {
-		wpa_tdls_generate_tpk(padapter, ptdls_sta);
-
-		/* FTIE */
-		pftie = pframe;
-		pftie_mic = pframe+4;
-		memset(pframe, 0, 84);	/* All fields except SNonce shall be set to 0 */
-		memset(pframe, _FTIE_, 1);	/* version */
-		memset((pframe+1), 82, 1);	/* length */
-		memcpy((pframe+20), ptdls_sta->ANonce, 32);
-		memcpy((pframe+52), ptdls_sta->SNonce, 32);
-		pframe += 84;
-		pattrib->pktlen += 84;
-
-		/* Timeout interval */
-		ptimeout_ie = pframe;
-		timeout_itvl[0] = 0x02;
-		memcpy(timeout_itvl+1, (u8 *)(&ptdls_sta->TDLS_PeerKey_Lifetime), 4);
-		pframe = rtw_set_ie(pframe, _TIMEOUT_ITVL_IE_, 5, timeout_itvl,  &(pattrib->pktlen));
-	}
-
-	/* Sup_reg_classes(optional) */
-	/* HT capabilities */
-	pframe = rtw_tdls_set_ht_cap(padapter, pframe, pattrib);
-
-	/* 20/40 BSS coexistence */
-	if (pmlmepriv->num_FortyMHzIntolerant > 0)
-		iedata |= BIT(2);/* 20 MHz BSS Width Request */
-	pframe = rtw_set_ie(pframe, EID_BSSCoexistence,  1, &iedata, &(pattrib->pktlen));
-
-	/* Link identifier */
-	plinkid_ie = pframe;
-	memcpy(link_id_addr, pattrib->ra, 6);
-	memcpy((link_id_addr+6), pattrib->dst, 6);
-	memcpy((link_id_addr+12), pattrib->src, 6);
-	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-
-	/* fill FTIE mic */
-	if (pattrib->encrypt)
-		wpa_tdls_ftie_mic(ptdls_sta->tpk.kck, 2, plinkid_ie, prsnie, ptimeout_ie, pftie, pftie_mic);
-}
-
-void rtw_build_tdls_setup_cfm_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
-{
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	struct sta_info *ptdls_sta = rtw_get_stainfo((&padapter->stapriv) , pattrib->dst);
-
-	u8 payload_type = 0x02;
-	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
-	unsigned char action = TDLS_SETUP_CONFIRM;
-	u8 more_supportedrates = 0;
-	unsigned int ie_len;
-	unsigned char *p;
-	u8 timeout_itvl[5];	/* set timeout interval to maximum value */
-	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-	u8	link_id_addr[18] = {0};
-	u8  *pftie, *ptimeout_ie, *plinkid_ie, *prsnie, *pftie_mic;
-
-	/* payload type */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	/* category, action, status code, dialog token */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 2, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(ptdls_sta->dialog), &(pattrib->pktlen));
-
-	if (ptdls_sta->stat_code != 0)	/* invalid setup request */
-		return;
-
-	/* RSNIE */
-	if (pattrib->encrypt) {
-		prsnie = pframe;
-		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
-	}
-
-	/* EDCA param set; WMM param ele. */
-	if (pattrib->encrypt) {
-		/* FTIE */
-		pftie = pframe;
-		pftie_mic = pframe+4;
-		memset(pframe, 0, 84);	/* All fields except SNonce shall be set to 0 */
-		memset(pframe, _FTIE_, 1);	/* version */
-		memset((pframe+1), 82, 1);	/* length */
-		memcpy((pframe+20), ptdls_sta->ANonce, 32);
-		memcpy((pframe+52), ptdls_sta->SNonce, 32);
-		pframe += 84;
-		pattrib->pktlen += 84;
-
-		/* Timeout interval */
-		ptimeout_ie = pframe;
-		timeout_itvl[0] = 0x02;
-		memcpy(timeout_itvl+1, (u8 *)(&ptdls_sta->TDLS_PeerKey_Lifetime), 4);
-		ptdls_sta->TPK_count = 0;
-		_set_timer(&ptdls_sta->TPK_timer, ptdls_sta->TDLS_PeerKey_Lifetime/TPK_RESEND_COUNT);
-		pframe = rtw_set_ie(pframe, _TIMEOUT_ITVL_IE_, 5, timeout_itvl,  &(pattrib->pktlen));
-	}
-
-	/* HT operation; todo */
-	/* Link identifier */
-	plinkid_ie = pframe;
-	memcpy(link_id_addr, pattrib->ra, 6);
-	memcpy((link_id_addr+6), pattrib->src, 6);
-	memcpy((link_id_addr+12), pattrib->dst, 6);
-	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-
-	/* fill FTIE mic */
-	if (pattrib->encrypt)
-		wpa_tdls_ftie_mic(ptdls_sta->tpk.kck, 3, plinkid_ie, prsnie, ptimeout_ie, pftie, pftie_mic);
-}
-
-void rtw_build_tdls_teardown_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
-{
-	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	u8 payload_type = 0x02;
-	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
-	unsigned char action = TDLS_TEARDOWN;
-	u8	link_id_addr[18] = {0};
-
-	struct sta_info *ptdls_sta = rtw_get_stainfo(&(padapter->stapriv) , pattrib->dst);
-	struct sta_priv		*pstapriv = &padapter->stapriv;
-
-	/* payload type */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	/* category, action, reason code */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
-
-	/* Link identifier */
-	if (ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE) {
-		memcpy(link_id_addr, pattrib->ra, 6);
-		memcpy((link_id_addr+6), pattrib->src, 6);
-		memcpy((link_id_addr+12), pattrib->dst, 6);
-	} else  if (ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE) {
-		memcpy(link_id_addr, pattrib->ra, 6);
-		memcpy((link_id_addr+6), pattrib->dst, 6);
-		memcpy((link_id_addr+12), pattrib->src, 6);
-	}
-	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-}
-
-void rtw_build_tdls_dis_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
-{
-	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	u8 payload_type = 0x02;
-	u8 category = RTW_WLAN_CATEGORY_TDLS;
-	u8 action = TDLS_DISCOVERY_REQUEST;
-	u8	link_id_addr[18] = {0};
-	static u8 dialogtoken;
-
-	/* payload type */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	/* category, action, reason code */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogtoken), &(pattrib->pktlen));
-	dialogtoken = (dialogtoken+1)%256;
-
-	/* Link identifier */
-	memcpy(link_id_addr, pattrib->ra, 6);
-	memcpy((link_id_addr+6), pattrib->src, 6);
-	memcpy((link_id_addr+12), pattrib->dst, 6);
-	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-}
-
-void rtw_build_tdls_dis_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, u8 dialog)
-{
-	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &pmlmeext->mlmext_info;
-	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
-
-	u8 category = RTW_WLAN_CATEGORY_PUBLIC;
-	u8 action = TDLS_DISCOVERY_RESPONSE;
-	u8 bssrate[NDIS_802_11_LENGTH_RATES_EX];
-	int bssrate_len = 0;
-	u8 more_supportedrates = 0;
-	u8 *p;
-	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-	u8 link_id_addr[18] = {0};
-	u8 iedata = 0;
-	u8 timeout_itvl[5];	/* set timeout interval to maximum value */
-	u32 timeout_interval = TPK_RESEND_COUNT * 1000;
-
-	/* category, action, dialog token */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialog), &(pattrib->pktlen));
-
-	/* capability */
-	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
-
-	if (pattrib->encrypt)
-		*pframe = *pframe | BIT(4);
-	pframe += 2;
-	pattrib->pktlen += 2;
-
-	/* supported rates */
-	rtw_set_supported_rate(bssrate, WIRELESS_11BG_24N);
-	bssrate_len = IEEE80211_CCK_RATE_LEN + IEEE80211_NUM_OFDM_RATESLEN;
-
-	if (bssrate_len > 8) {
-		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , 8, bssrate, &(pattrib->pktlen));
-		more_supportedrates = 1;
-	} else {
-		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));
-	}
-
-	/* extended supported rates */
-	if (more_supportedrates == 1) {
-		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
-	}
-
-	/* supported channels */
-	pframe = rtw_tdls_set_sup_ch(pmlmeext, pframe, pattrib);
-
-	/* RSNIE */
-	if (pattrib->encrypt)
-		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
-
-	/* extended capability */
-	pframe = rtw_set_ie(pframe, _EXT_CAP_IE_ , 5, TDLS_EXT_CAPIE, &(pattrib->pktlen));
-
-	if (pattrib->encrypt) {
-		/* FTIE */
-		memset(pframe, 0, 84);	/* All fields shall be set to 0 */
-		memset(pframe, _FTIE_, 1);	/* version */
-		memset((pframe+1), 82, 1);	/* length */
-		pframe += 84;
-		pattrib->pktlen += 84;
-
-		/* Timeout interval */
-		timeout_itvl[0] = 0x02;
-		memcpy(timeout_itvl+1, &timeout_interval, 4);
-		pframe = rtw_set_ie(pframe, _TIMEOUT_ITVL_IE_, 5, timeout_itvl,  &(pattrib->pktlen));
-	}
-
-	/* Sup_reg_classes(optional) */
-	/* HT capabilities */
-	pframe = rtw_tdls_set_ht_cap(padapter, pframe, pattrib);
-
-	/* 20/40 BSS coexistence */
-	if (pmlmepriv->num_FortyMHzIntolerant > 0)
-		iedata |= BIT(2);/* 20 MHz BSS Width Request */
-	pframe = rtw_set_ie(pframe, EID_BSSCoexistence, 1, &iedata, &(pattrib->pktlen));
-
-	/* Link identifier */
-	memcpy(link_id_addr, pattrib->ra, 6);
-	memcpy((link_id_addr+6), pattrib->dst, 6);
-	memcpy((link_id_addr+12), pattrib->src, 6);
-	pframe = rtw_set_ie(pframe, _LINK_ID_IE_, 18, link_id_addr, &(pattrib->pktlen));
-}
-
-void rtw_build_tdls_peer_traffic_indication_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
-{
-	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	u8 payload_type = 0x02;
-	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
-	unsigned char action = TDLS_PEER_TRAFFIC_INDICATION;
-
-	u8	link_id_addr[18] = {0};
-	u8 AC_queue = 0;
-	struct sta_priv		*pstapriv = &padapter->stapriv;
-	struct sta_info *ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
-
-	/* payload type */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	/* category, action, reason code */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(ptdls_sta->dialog), &(pattrib->pktlen));
-
-	/* Link identifier */
-	memcpy(link_id_addr, pattrib->ra, 6);
-	memcpy((link_id_addr+6), pattrib->src, 6);
-	memcpy((link_id_addr+12), pattrib->dst, 6);
-	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-
-	/* PTI control */
-	/* PU buffer status */
-	if (ptdls_sta->uapsd_bk&BIT(1))
-		AC_queue = BIT(0);
-	if (ptdls_sta->uapsd_be&BIT(1))
-		AC_queue = BIT(1);
-	if (ptdls_sta->uapsd_vi&BIT(1))
-		AC_queue = BIT(2);
-	if (ptdls_sta->uapsd_vo&BIT(1))
-		AC_queue = BIT(3);
-	pframe = rtw_set_ie(pframe, _PTI_BUFFER_STATUS_, 1, &AC_queue, &(pattrib->pktlen));
-}
-
-void rtw_build_tdls_ch_switch_req_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
-{
-	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-	u8 payload_type = 0x02;
-	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
-	unsigned char action = TDLS_CHANNEL_SWITCH_REQUEST;
-	u8	link_id_addr[18] = {0};
-	struct sta_priv		*pstapriv = &padapter->stapriv;
-	struct sta_info *ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
-	u8 ch_switch_timing[4] = {0};
-	u16 switch_time = CH_SWITCH_TIME, switch_timeout = CH_SWITCH_TIMEOUT;
-
-	/* payload type */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	/* category, action, target_ch */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(ptdlsinfo->candidate_ch), &(pattrib->pktlen));
-
-	/* Link identifier */
-	memcpy(link_id_addr, pattrib->ra, 6);
-	memcpy((link_id_addr+6), pattrib->src, 6);
-	memcpy((link_id_addr+12), pattrib->dst, 6);
-	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-
-	/* ch switch timing */
-	memcpy(ch_switch_timing, &switch_time, 2);
-	memcpy(ch_switch_timing+2, &switch_timeout, 2);
-	pframe = rtw_set_ie(pframe, _CH_SWITCH_TIMING_,  4, ch_switch_timing, &(pattrib->pktlen));
-
-	/* update ch switch attrib to sta_info */
-	ptdls_sta->off_ch = ptdlsinfo->candidate_ch;
-	ptdls_sta->ch_switch_time = switch_time;
-	ptdls_sta->ch_switch_timeout = switch_timeout;
-}
-
-void rtw_build_tdls_ch_switch_rsp_ies(_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe)
-{
-	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	u8 payload_type = 0x02;
-	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
-	unsigned char action = TDLS_CHANNEL_SWITCH_RESPONSE;
-	u8	link_id_addr[18] = {0};
-	struct sta_priv		*pstapriv = &padapter->stapriv;
-	struct sta_info *ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;
-	u8 ch_switch_timing[4] = {0};
-
-	/* payload type */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	/* category, action, status_code */
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 2, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
-
-	/* Link identifier */
-	memcpy(link_id_addr, pattrib->ra, 6);
-	memcpy((link_id_addr+6), pattrib->src, 6);
-	memcpy((link_id_addr+12), pattrib->dst, 6);
-	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-
-	/* ch switch timing */
-	memcpy(ch_switch_timing, &ptdls_sta->ch_switch_time, 2);
-	memcpy(ch_switch_timing+2, &ptdls_sta->ch_switch_timeout, 2);
-	pframe = rtw_set_ie(pframe, _CH_SWITCH_TIMING_,  4, ch_switch_timing, &(pattrib->pktlen));
-}
-
-void _TPK_timer_hdl(void *FunctionContext)
-{
-	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
-
-	ptdls_sta->TPK_count++;
-	/* TPK_timer set 1000 as default */
-	/* retry timer should set at least 301 sec. */
-	if (ptdls_sta->TPK_count == TPK_RESEND_COUNT) {
-		ptdls_sta->TPK_count = 0;
-		issue_tdls_setup_req(ptdls_sta->padapter, ptdls_sta->hwaddr);
-	}
-
-	_set_timer(&ptdls_sta->TPK_timer, ptdls_sta->TDLS_PeerKey_Lifetime/TPK_RESEND_COUNT);
-}
-
-void init_TPK_timer(_adapter *padapter, struct sta_info *psta)
-{
-	psta->padapter = padapter;
-
-	_init_timer(&psta->TPK_timer, padapter->pnetdev, _TPK_timer_hdl, psta);
-}
-
-/*  TDLS_DONE_CH_SEN: channel sensing and report candidate channel */
-/*  TDLS_OFF_CH: first time set channel to off channel */
-/*  TDLS_BASE_CH: when go back to the channel linked with AP, send null data to peer STA as an indication */
-void _ch_switch_timer_hdl(void *FunctionContext)
-{
-	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
-	_adapter *padapter = ptdls_sta->padapter;
-
-	if (ptdls_sta->option == TDLS_DONE_CH_SEN) {
-		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_DONE_CH_SEN);
-	} else if (ptdls_sta->option == TDLS_OFF_CH) {
-		issue_nulldata_to_TDLS_peer_STA(ptdls_sta->padapter, ptdls_sta, 0);
-		_set_timer(&ptdls_sta->base_ch_timer, 500);
-	} else if (ptdls_sta->option == TDLS_BASE_CH) {
-		issue_nulldata_to_TDLS_peer_STA(ptdls_sta->padapter, ptdls_sta, 0);
-	}
-}
-
-void init_ch_switch_timer(_adapter *padapter, struct sta_info *psta)
-{
-	psta->padapter = padapter;
-	_init_timer(&psta->option_timer, padapter->pnetdev, _ch_switch_timer_hdl, psta);
-}
-
-void _base_ch_timer_hdl(void *FunctionContext)
-{
-	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
-	rtw_tdls_cmd(ptdls_sta->padapter, ptdls_sta->hwaddr, TDLS_P_OFF_CH);
-}
-
-void init_base_ch_timer(_adapter *padapter, struct sta_info *psta)
-{
-	psta->padapter = padapter;
-	_init_timer(&psta->base_ch_timer, padapter->pnetdev, _base_ch_timer_hdl, psta);
-}
-
-void _off_ch_timer_hdl(void *FunctionContext)
-{
-	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
-	rtw_tdls_cmd(ptdls_sta->padapter, ptdls_sta->hwaddr, TDLS_P_BASE_CH);
-}
-
-void init_off_ch_timer(_adapter *padapter, struct sta_info *psta)
-{
-	psta->padapter = padapter;
-	_init_timer(&psta->off_ch_timer, padapter->pnetdev, _off_ch_timer_hdl, psta);
-}
-
-void _tdls_handshake_timer_hdl(void *FunctionContext)
-{
-	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
-
-	if (ptdls_sta != NULL) {
-		if (!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE)) {
-			DBG_871X("tdls handshake time out\n");
-			free_tdls_sta(ptdls_sta->padapter, ptdls_sta);
-		}
-	}
-}
-
-void init_handshake_timer(_adapter *padapter, struct sta_info *psta)
-{
-	psta->padapter = padapter;
-	_init_timer(&psta->handshake_timer, padapter->pnetdev, _tdls_handshake_timer_hdl, psta);
-}
-
-/* Check tdls peer sta alive. */
-void _tdls_alive_timer_phase1_hdl(void *FunctionContext)
-{
-	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
-	_adapter *padapter = ptdls_sta->padapter;
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-
-	spin_lock_bh(&ptdlsinfo->hdl_lock);
-	ptdls_sta->timer_flag = 1;
-	spin_unlock_bh(&ptdlsinfo->hdl_lock);
-
-	ptdls_sta->tdls_sta_state &= (~TDLS_ALIVE_STATE);
-
-	DBG_871X("issue_tdls_dis_req to check alive\n");
-	issue_tdls_dis_req(padapter, ptdls_sta->hwaddr);
-	rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_CKALV_PH1);
-	sta_update_last_rx_pkts(ptdls_sta);
-
-	if (ptdls_sta->timer_flag == 2) {
-		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_FREE_STA);
-	} else {
-		spin_lock_bh(&ptdlsinfo->hdl_lock);
-		ptdls_sta->timer_flag = 0;
-		spin_unlock_bh(&ptdlsinfo->hdl_lock);
-	}
-}
-
-void _tdls_alive_timer_phase2_hdl(void *FunctionContext)
-{
-	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
-	_adapter *padapter = ptdls_sta->padapter;
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-
-	spin_lock_bh(&(ptdlsinfo->hdl_lock));
-	ptdls_sta->timer_flag = 1;
-	spin_unlock_bh(&ptdlsinfo->hdl_lock);
-
-	if ((ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE) &&
-	    (sta_last_rx_pkts(ptdls_sta) + 3 <= sta_rx_pkts(ptdls_sta))) {
-		DBG_871X("TDLS STA ALIVE, ptdls_sta->sta_stats.last_rx_pkts:%llu, ptdls_sta->sta_stats.rx_pkts:%llu\n",
-			 sta_last_rx_pkts(ptdls_sta), sta_rx_pkts(ptdls_sta));
-
-		ptdls_sta->alive_count = 0;
-		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_CKALV_PH2);
-	} else {
-		if (!(ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE))
-			DBG_871X("TDLS STA TOO FAR\n");
-		if (!(sta_last_rx_pkts(ptdls_sta) + 3 <= sta_rx_pkts(ptdls_sta)))
-			DBG_871X("TDLS LINK WITH LOW TRAFFIC, ptdls_sta->sta_stats.last_rx_pkts:%llu, ptdls_sta->sta_stats.rx_pkts:%llu\n",
-				 sta_last_rx_pkts(ptdls_sta), sta_rx_pkts(ptdls_sta));
-
-		ptdls_sta->alive_count++;
-		if (ptdls_sta->alive_count == TDLS_ALIVE_COUNT) {
-			ptdls_sta->stat_code = _RSON_TDLS_TEAR_TOOFAR_;
-			issue_tdls_teardown(padapter, ptdls_sta->hwaddr);
-		} else {
-			rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_CKALV_PH2);
-		}
-	}
-
-	if (ptdls_sta->timer_flag == 2) {
-		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_FREE_STA);
-	} else {
-		spin_lock_bh(&(ptdlsinfo->hdl_lock));
-		ptdls_sta->timer_flag = 0;
-		spin_unlock_bh(&ptdlsinfo->hdl_lock);
-}
-}
-
-void init_tdls_alive_timer(_adapter *padapter, struct sta_info *psta)
-{
-	psta->padapter = padapter;
-	_init_timer(&psta->alive_timer1, padapter->pnetdev, _tdls_alive_timer_phase1_hdl, psta);
-	_init_timer(&psta->alive_timer2, padapter->pnetdev, _tdls_alive_timer_phase2_hdl, psta);
-}
-
-int update_sgi_tdls(_adapter *padapter, struct sta_info *psta)
-{
-	struct ht_priv	*psta_ht = NULL;
-	psta_ht = &psta->htpriv;
-
-	if (psta_ht->ht_option)
-		return psta_ht->sgi;
-	else
-		return false;
-}
-
-u32 update_mask_tdls(_adapter *padapter, struct sta_info *psta)
-{
-	int i;
-	u8 rf_type, id;
-	unsigned char sta_band = 0;
-	unsigned char limit;
-	unsigned int tx_ra_bitmap = 0;
-	struct ht_priv	*psta_ht = NULL;
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct wlan_bssid_ex *pcur_network = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;
-
-	psta_ht = &psta->htpriv;
-	/* b/g mode ra_bitmap */
-	for (i = 0; i < sizeof(psta->bssrateset); i++) {
-		if (psta->bssrateset[i])
-			tx_ra_bitmap |= rtw_get_bit_value_from_ieee_value(psta->bssrateset[i]&0x7f);
-	}
-
-	/* n mode ra_bitmap */
-	if (psta_ht->ht_option) {
-		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-		if (rf_type == RF_2T2R)
-			limit = 16;/*  2R */
-		else
-			limit = 8;/*   1R */
-
-		for (i = 0; i < limit; i++) {
-			if (psta_ht->ht_cap.supp_mcs_set[i/8] & BIT(i%8))
-				tx_ra_bitmap |= BIT(i+12);
-		}
-	}
-
-	if (pcur_network->Configuration.DSConfig > 14) {
-		/*  5G band */
-		if (tx_ra_bitmap & 0xffff000)
-			sta_band |= WIRELESS_11_5N | WIRELESS_11A;
-		else
-			sta_band |= WIRELESS_11A;
-	} else {
-		if (tx_ra_bitmap & 0xffff000)
-			sta_band |= WIRELESS_11_24N | WIRELESS_11G | WIRELESS_11B;
-		else if (tx_ra_bitmap & 0xff0)
-			sta_band |= WIRELESS_11G | WIRELESS_11B;
-		else
-			sta_band |= WIRELESS_11B;
-	}
-
-	id = networktype_to_raid(sta_band);
-	tx_ra_bitmap |= ((id<<28)&0xf0000000);
-	return tx_ra_bitmap;
-}
-
-#endif /* CONFIG_TDLS */
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -994,33 +994,12 @@ void VCS_update(struct rtw_adapter *pada
 	}
 }
 
-#ifdef CONFIG_TDLS
-int check_ap_tdls_prohibited(u8 *pframe, u8 pkt_len)
-{
-	u8 tdls_prohibited_bit = 0x40; /* bit(38); TDLS_prohibited */
-
-	if (pkt_len < 5)
-		return false;
-
-	pframe += 4;
-	if ((*pframe) & tdls_prohibited_bit)
-		return true;
-
-	return false;
-}
-#endif /* CONFIG_TDLS */
-
 void update_beacon_info(struct rtw_adapter *padapter, u8 *pframe, uint pkt_len, struct sta_info *psta)
 {
 	unsigned int i;
 	unsigned int len;
 	struct ndis_802_11_variable_ies *pIE;
 
-#ifdef CONFIG_TDLS
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-	u8 tdls_prohibited[] = { 0x00, 0x00, 0x00, 0x00, 0x10 }; /* bit(38): TDLS_prohibited */
-#endif /* CONFIG_TDLS */
-
 	len = pkt_len - (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN);
 
 	for (i = 0; i < len;) {
@@ -1034,12 +1013,6 @@ void update_beacon_info(struct rtw_adapt
 			ERP_IE_handler(padapter, pIE);
 			VCS_update(padapter, psta);
 			break;
-#ifdef CONFIG_TDLS
-		case _EXT_CAP_IE_:
-			if (check_ap_tdls_prohibited(pIE->data, pIE->Length) == true)
-				ptdlsinfo->ap_prohibited = true;
-			break;
-#endif /* CONFIG_TDLS */
 		default:
 			break;
 		}
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -778,23 +778,13 @@ static s32 xmitframe_swencrypt(struct rt
 s32 rtw_make_wlanhdr (struct rtw_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib)
 {
 	u16 *qc;
-
 	struct rtw_ieee80211_hdr *pwlanhdr = (struct rtw_ieee80211_hdr *)hdr;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
 	u8 qos_option = false;
-#ifdef CONFIG_TDLS
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-	struct sta_priv		*pstapriv = &padapter->stapriv;
-	struct sta_info *ptdls_sta = NULL, *psta_backup = NULL;
-	u8 direct_link = 0;
-#endif /* CONFIG_TDLS */
-
 	int res = _SUCCESS;
 	u16 *fctrl = &pwlanhdr->frame_ctl;
-
 	struct sta_info *psta;
-
 	int bmcst = IS_MCAST(pattrib->ra);
 
 	if (pattrib->psta) {
@@ -813,32 +803,11 @@ s32 rtw_make_wlanhdr (struct rtw_adapter
 	if (pattrib->subtype & WIFI_DATA_TYPE) {
 		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == true)) {
 			/* to_ds = 1, fr_ds = 0; */
-#ifdef CONFIG_TDLS
-			if ((ptdlsinfo->setup_state == TDLS_LINKED_STATE)) {
-				ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
-				if ((ptdls_sta != NULL) && (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) && (pattrib->ether_type != 0x0806)) {
-					/* TDLS data transfer, ToDS = 0, FrDs = 0 */
-					memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
-					memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
-					memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
-					direct_link = 1;
-				} else {
-					/*  1.Data transfer to AP */
-					/*  2.Arp pkt will relayed by AP */
-					SetToDs(fctrl);
-					memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
-					memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
-					memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
-				}
-			} else
-#endif /* CONFIG_TDLS */
-			{
-				/* Data transfer to AP */
-				SetToDs(fctrl);
-				memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
-				memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
-				memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
-			}
+			/* Data transfer to AP */
+			SetToDs(fctrl);
+			memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
+			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
 
 			if (pqospriv->qos_option)
 				qos_option = true;
@@ -886,13 +855,6 @@ s32 rtw_make_wlanhdr (struct rtw_adapter
 
 		/* Update Seq Num will be handled by f/w */
 		if (psta) {
-#ifdef CONFIG_TDLS
-			if (direct_link == 1) {
-				psta_backup = psta;
-				psta = ptdls_sta;
-			}
-#endif /* CONFIG_TDLS */
-
 			psta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
 			psta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
 
@@ -926,31 +888,9 @@ s32 rtw_make_wlanhdr (struct rtw_adapter
 					pattrib->ampdu_en = true;/* AGG EN */
 				}
 			}
-
-#ifdef CONFIG_TDLS
-			if (direct_link == 1) {
-				if (pattrib->encrypt) {
-					pattrib->encrypt = _AES_;
-					pattrib->iv_len = 8;
-					pattrib->icv_len = 8;
-				}
-
-				/* qos_en, ht_en, init rate, , bw, ch_offset, sgi */
-				/* pattrib->qos_en = ptdls_sta->qos_option; */
-				pattrib->ht_en = ptdls_sta->htpriv.ht_option;
-				pattrib->raid = ptdls_sta->raid;
-				pattrib->bwmode = ptdls_sta->htpriv.bwmode;
-				pattrib->ch_offset = ptdls_sta->htpriv.ch_offset;
-				pattrib->sgi = ptdls_sta->htpriv.sgi;
-				pattrib->mac_id = ptdls_sta->mac_id;
-				psta = psta_backup;
-			}
-#endif /* CONFIG_TDLS */
 		}
 	}
-
 exit:
-
 	return res;
 }
 
@@ -995,238 +935,6 @@ s32 rtw_txframes_sta_ac_pending(struct r
 	return ptxservq->qcnt;
 }
 
-#ifdef CONFIG_TDLS
-
-int rtw_build_tdls_ies(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, u8 action)
-{
-	int res = _SUCCESS;
-
-	switch (action) {
-	case TDLS_SETUP_REQUEST:
-		rtw_build_tdls_setup_req_ies(padapter, pxmitframe, pframe);
-		break;
-	case TDLS_SETUP_RESPONSE:
-		rtw_build_tdls_setup_rsp_ies(padapter, pxmitframe, pframe);
-		break;
-	case TDLS_SETUP_CONFIRM:
-		rtw_build_tdls_setup_cfm_ies(padapter, pxmitframe, pframe);
-		break;
-	case TDLS_TEARDOWN:
-		rtw_build_tdls_teardown_ies(padapter, pxmitframe, pframe);
-		break;
-	case TDLS_DISCOVERY_REQUEST:
-		rtw_build_tdls_dis_req_ies(padapter, pxmitframe, pframe);
-		break;
-	case TDLS_PEER_TRAFFIC_INDICATION:
-		rtw_build_tdls_peer_traffic_indication_ies(padapter, pxmitframe, pframe);
-		break;
-	case TDLS_CHANNEL_SWITCH_REQUEST:
-		rtw_build_tdls_ch_switch_req_ies(padapter, pxmitframe, pframe);
-		break;
-	case TDLS_CHANNEL_SWITCH_RESPONSE:
-		rtw_build_tdls_ch_switch_rsp_ies(padapter, pxmitframe, pframe);
-		break;
-	default:
-		res = _FAIL;
-		break;
-	}
-	return res;
-}
-
-s32 rtw_make_tdls_wlanhdr(struct rtw_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib, u8 action)
-{
-	u16 *qc;
-	struct rtw_ieee80211_hdr *pwlanhdr = (struct rtw_ieee80211_hdr *)hdr;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
-	struct sta_priv		*pstapriv = &padapter->stapriv;
-	struct sta_info *psta = NULL, *ptdls_sta = NULL;
-	u8 tdls_seq = 0, baddr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
-
-	int res = _SUCCESS;
-	u16 *fctrl = &pwlanhdr->frame_ctl;
-
-	memset(hdr, 0, WLANHDR_OFFSET);
-
-	SetFrameSubType(fctrl, pattrib->subtype);
-
-	switch (action) {
-	case TDLS_SETUP_REQUEST:
-	case TDLS_SETUP_RESPONSE:
-	case TDLS_SETUP_CONFIRM:
-	case TDLS_TEARDOWN:	/* directly to peer STA or via AP */
-	case TDLS_PEER_TRAFFIC_INDICATION:
-	case TDLS_PEER_PSM_REQUEST:	/* directly to peer STA or via AP */
-	case TUNNELED_PROBE_REQ:
-	case TUNNELED_PROBE_RSP:
-		SetToDs(fctrl);
-		memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
-		memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
-		memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
-		break;
-	case TDLS_CHANNEL_SWITCH_REQUEST:
-	case TDLS_CHANNEL_SWITCH_RESPONSE:
-	case TDLS_PEER_PSM_RESPONSE:
-	case TDLS_PEER_TRAFFIC_RESPONSE:
-		memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
-		memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
-		memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
-		tdls_seq = 1;
-		break;
-	case TDLS_DISCOVERY_REQUEST:	/* unicast: directly to peer sta, Bcast: via AP */
-		if (_rtw_memcmp(pattrib->dst, baddr, ETH_ALEN)) {
-			SetToDs(fctrl);
-			memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
-			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
-			memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
-		} else {
-			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
-			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
-			memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
-			tdls_seq = 1;
-		}
-		break;
-	}
-	if (pattrib->encrypt)
-		SetPrivacy(fctrl);
-
-	if (pqospriv->qos_option) {
-		qc = (unsigned short *)(hdr + pattrib->hdrlen - 2);
-		if (pattrib->priority)
-			SetPriority(qc, pattrib->priority);
-		SetAckpolicy(qc, pattrib->ack_policy);
-	}
-
-	psta = pattrib->psta;
-
-	/*   1. update seq_num per link by sta_info */
-	/*   2. rewrite encrypt to _AES_, also rewrite iv_len, icv_len */
-	if (tdls_seq == 1) {
-		ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
-		if (ptdls_sta) {
-			ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
-			ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
-			pattrib->seqnum = ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority];
-			SetSeqNum(hdr, pattrib->seqnum);
-
-			if (pattrib->encrypt) {
-				pattrib->encrypt = _AES_;
-				pattrib->iv_len = 8;
-				pattrib->icv_len = 8;
-			}
-		} else {
-			res = _FAIL;
-			goto exit;
-		}
-	} else if (psta) {
-		psta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
-		psta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
-		pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[pattrib->priority];
-		SetSeqNum(hdr, pattrib->seqnum);
-	}
-
-exit:
-
-	return res;
-}
-
-s32 rtw_xmit_tdls_coalesce(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe, u8 action)
-{
-	s32 llc_sz;
-
-	u8 *pframe, *mem_start;
-
-	struct sta_info		*psta;
-	struct sta_priv		*pstapriv = &padapter->stapriv;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
-	u8 *pbuf_start;
-	s32 bmcst = IS_MCAST(pattrib->ra);
-	s32 res = _SUCCESS;
-
-	if (pattrib->psta) {
-		psta = pattrib->psta;
-	} else {
-		if (bmcst)
-			psta = rtw_get_bcmc_stainfo(padapter);
-		else
-			psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
-	}
-
-	if (psta == NULL)
-		return _FAIL;
-
-	if (pxmitframe->buf_addr == NULL)
-		return _FAIL;
-
-	pbuf_start = pxmitframe->buf_addr;
-	mem_start = pbuf_start + TXDESC_OFFSET;
-
-	if (rtw_make_tdls_wlanhdr(padapter, mem_start, pattrib, action) == _FAIL) {
-		res = _FAIL;
-		goto exit;
-	}
-
-	pframe = mem_start;
-	pframe += pattrib->hdrlen;
-
-	/* adding icv, if necessary... */
-	if (pattrib->iv_len) {
-		if (psta != NULL) {
-			switch (pattrib->encrypt) {
-			case _WEP40_:
-			case _WEP104_:
-					WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
-				break;
-			case _TKIP_:
-				if (bmcst)
-					TKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
-				else
-					TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
-				break;
-			case _AES_:
-				if (bmcst)
-					AES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
-				else
-					AES_IV(pattrib->iv, psta->dot11txpn, 0);
-				break;
-			}
-		}
-		memcpy(pframe, pattrib->iv, pattrib->iv_len);
-		pframe += pattrib->iv_len;
-	}
-
-	llc_sz = rtw_put_snap(pframe, pattrib->ether_type);
-	pframe += llc_sz;
-
-	/* pattrib->pktlen will be counted in rtw_build_tdls_ies */
-	pattrib->pktlen = 0;
-
-	rtw_build_tdls_ies(padapter, pxmitframe, pframe, action);
-
-	if ((pattrib->icv_len > 0) && (pattrib->bswenc)) {
-		pframe += pattrib->pktlen;
-		memcpy(pframe, pattrib->icv, pattrib->icv_len);
-		pframe += pattrib->icv_len;
-	}
-
-	pattrib->nr_frags = 1;
-	pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + llc_sz +
-			((pattrib->bswenc) ? pattrib->icv_len : 0) + pattrib->pktlen;
-
-	if (xmitframe_addmic(padapter, pxmitframe) == _FAIL)
-		goto exit;
-
-	xmitframe_swencrypt(padapter, pxmitframe);
-
-	update_attrib_vcs_info(padapter, pxmitframe);
-
-exit:
-
-	return res;
-}
-#endif /* CONFIG_TDLS */
-
 /*
  * Calculate wlan 802.11 packet MAX size from pkt_attrib
  * This function doesn't consider fragment case
@@ -2174,7 +1882,7 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 
 	do_queue_select(padapter, &pxmitframe->attrib);
 
-#if defined(CONFIG_92D_AP_MODE) || defined(CONFIG_TDLS)
+#if defined(CONFIG_92D_AP_MODE)
 	spin_lock_bh(&pxmitpriv->lock);
 	if (xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == true) {
 		spin_unlock_bh(&pxmitpriv->lock);
@@ -2188,69 +1896,7 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 	return 0;
 }
 
-#ifdef CONFIG_TDLS
-int xmitframe_enqueue_for_tdls_sleeping_sta(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
-{
-	int ret = false;
-	struct sta_info *ptdls_sta = NULL;
-	struct sta_priv *pstapriv = &padapter->stapriv;
-	struct pkt_attrib *pattrib = &pxmitframe->attrib;
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	int i;
-
-	ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
-	if (ptdls_sta == NULL) {
-		return ret;
-	} else if (ptdls_sta->tdls_sta_state&TDLS_LINKED_STATE) {
-		if (pattrib->triggered == 1) {
-			ret = true;
-			return ret;
-		}
-
-		spin_lock_bh(&ptdls_sta->sleep_q.lock);
-
-		if (ptdls_sta->state&WIFI_SLEEP_STATE) {
-			list_del_init(&pxmitframe->list);
-
-			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&ptdls_sta->sleep_q));
-
-			ptdls_sta->sleepq_len++;
-			ptdls_sta->sleepq_ac_len++;
-
-			/* indicate 4-AC queue bit in TDLS peer traffic indication */
-			switch (pattrib->priority) {
-			case 1:
-			case 2:
-				ptdls_sta->uapsd_bk = ptdls_sta->uapsd_bk | BIT(1);
-				break;
-			case 4:
-			case 5:
-				ptdls_sta->uapsd_vi = ptdls_sta->uapsd_vi | BIT(1);
-				break;
-			case 6:
-			case 7:
-				ptdls_sta->uapsd_vo = ptdls_sta->uapsd_vo | BIT(1);
-				break;
-			case 0:
-			case 3:
-			default:
-				ptdls_sta->uapsd_be = ptdls_sta->uapsd_be | BIT(1);
-				break;
-			}
-
-			if (ptdls_sta->sleepq_len == 1) {
-				/* transmit TDLS PTI via AP */
-				rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_SD_PTI);
-			}
-			ret = true;
-		}
-		spin_unlock_bh(&ptdls_sta->sleep_q.lock);
-	}
-	return ret;
-}
-#endif /* CONFIG_TDLS */
-
-#if defined(CONFIG_92D_AP_MODE) || defined(CONFIG_TDLS)
+#if defined(CONFIG_92D_AP_MODE)
 
 int xmitframe_enqueue_for_sleeping_sta(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
 {
@@ -2260,14 +1906,6 @@ int xmitframe_enqueue_for_sleeping_sta(s
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	int bmcst = IS_MCAST(pattrib->ra);
-#ifdef CONFIG_TDLS
-	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-
-	if (ptdlsinfo->setup_state == TDLS_LINKED_STATE) {
-		ret = xmitframe_enqueue_for_tdls_sleeping_sta(padapter, pxmitframe);
-		return ret;
-	}
-#endif /* CONFIG_TDLS */
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == false)
 	    return ret;
@@ -2397,10 +2035,7 @@ void stop_sta_xmit(struct rtw_adapter *p
 
 	psta->state |= WIFI_SLEEP_STATE;
 
-#ifdef CONFIG_TDLS
-	if (!(psta->tdls_sta_state & TDLS_LINKED_STATE))
-#endif /* CONFIG_TDLS */
-		pstapriv->sta_dz_bitmap |= BIT(psta->aid);
+	pstapriv->sta_dz_bitmap |= BIT(psta->aid);
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vo_q.sta_pending);
 	list_del_init(&(pstaxmitpriv->vo_q.tx_pending));
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vi_q.sta_pending);
@@ -2410,18 +2045,10 @@ void stop_sta_xmit(struct rtw_adapter *p
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->bk_q.sta_pending);
 	list_del_init(&(pstaxmitpriv->bk_q.tx_pending));
 
-#ifdef CONFIG_TDLS
-	if (!(psta->tdls_sta_state & TDLS_LINKED_STATE)) {
-		if (psta_bmc != NULL) {
-#endif /* CONFIG_TDLS */
-			/* for BC/MC Frames */
-			pstaxmitpriv = &psta_bmc->sta_xmitpriv;
-			dequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, &pstaxmitpriv->be_q.sta_pending);
-			list_del_init(&(pstaxmitpriv->be_q.tx_pending));
-#ifdef CONFIG_TDLS
-		}
-	}
-#endif /* CONFIG_TDLS */
+	/* for BC/MC Frames */
+	pstaxmitpriv = &psta_bmc->sta_xmitpriv;
+	dequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, &pstaxmitpriv->be_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->be_q.tx_pending));
 	spin_unlock_bh(&pxmitpriv->lock);
 }
 
@@ -2490,15 +2117,6 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 		spin_lock_bh(&psta->sleep_q.lock);
 	}
 	if (psta->sleepq_len == 0) {
-#ifdef CONFIG_TDLS
-		if (psta->tdls_sta_state & TDLS_LINKED_STATE) {
-			if (psta->state&WIFI_SLEEP_STATE)
-				psta->state ^= WIFI_SLEEP_STATE;
-
-			spin_unlock_bh(&psta->sleep_q.lock);
-			return;
-		}
-#endif /* CONFIG_TDLS */
 		pstapriv->tim_bitmap &= ~BIT(psta->aid);
 
 		update_mask = BIT(0);
@@ -2610,12 +2228,6 @@ void xmit_delivery_enabled_frames(struct
 			rtw_os_xmit_complete(padapter, pxmitframe);
 
 		if ((psta->sleepq_ac_len == 0) && (!psta->has_legacy_ac) && (wmmps_ac)) {
-#ifdef CONFIG_TDLS
-			if (psta->tdls_sta_state & TDLS_LINKED_STATE) {
-				spin_unlock_bh(&psta->sleep_q.lock);
-				return;
-			}
-#endif /* CONFIG_TDLS */
 			pstapriv->tim_bitmap &= ~BIT(psta->aid);
 
 			/* upate BCN for TIM IE */
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -2481,29 +2481,13 @@ rtl8192d_HalDmWatchDog(
 _record_initrate:
 
 		/*  Read REG_INIDATA_RATE_SEL value for TXDESC. */
-		if (check_fwstate(&adapter->mlmepriv, WIFI_STATION_STATE) == true)
-		{
+		if (check_fwstate(&adapter->mlmepriv, WIFI_STATION_STATE)) {
 			pdmpriv->INIDATA_RATE[0] = rtw_read8(adapter, REG_INIDATA_RATE_SEL) & 0x3f;
 
-#ifdef CONFIG_TDLS
-			if (adapter->tdlsinfo.setup_state == TDLS_LINKED_STATE)
-			{
-				u8 i=1;
-				for (; i < (adapter->tdlsinfo.macid_index) ; i++)
-				{
-					pdmpriv->INIDATA_RATE[i] = rtw_read8(adapter, (REG_INIDATA_RATE_SEL+i)) & 0x3f;
-				}
-			}
-#endif /* CONFIG_TDLS */
-
-		}
-		else
-		{
+		} else {
 			u8	i;
 			for (i=1 ; i < (adapter->stapriv.asoc_sta_count + 1); i++)
-			{
 				pdmpriv->INIDATA_RATE[i] = rtw_read8(adapter, (REG_INIDATA_RATE_SEL+i)) & 0x3f;
-			}
 		}
 	}
 
@@ -2514,5 +2498,4 @@ skip_dm:
 	/*  Check Hardware Radio ON/OFF or not */
 
 	dm_CheckPbcGPIO(adapter);				/*  Add by hpfan 2008-03-11 */
-
 }
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -456,66 +456,39 @@ s32 rtw_dump_xframe(struct rtw_adapter *
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
-#ifdef CONFIG_TDLS
-	struct sta_priv		*pstapriv = &padapter->stapriv;
-	struct sta_info *ptdls_sta=NULL, *psta_backup=NULL;
-	u8 ra_backup[6];
-#endif /* CONFIG_TDLS */
 
 	if ((pxmitframe->frame_tag == DATA_FRAMETAG) &&
 	    (pxmitframe->attrib.ether_type != 0x0806) &&
 	    (pxmitframe->attrib.ether_type != 0x888e) &&
 	    (pxmitframe->attrib.dhcp_pkt != 1))
-	{
-#ifdef CONFIG_TDLS
-		ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
-		if ((ptdls_sta!=NULL)&&(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
-		{
-			psta_backup = pattrib->psta;
-			pattrib->psta = ptdls_sta;
-			memcpy(ra_backup, pattrib->ra, ETH_ALEN);
-			memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
-			rtw_issue_addbareq_cmd(padapter, pxmitframe);
-			pattrib->psta = psta_backup;
-			memcpy(pattrib->ra, ra_backup, ETH_ALEN);
-		}
-#endif /* CONFIG_TDLS */
 		rtw_issue_addbareq_cmd(padapter, pxmitframe);
-	}
 
 	mem_addr = pxmitframe->buf_addr;
 
-       RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_dump_xframe()\n"));
+	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_dump_xframe()\n"));
 
-	for (t = 0; t < pattrib->nr_frags; t++)
-	{
+	for (t = 0; t < pattrib->nr_frags; t++) {
 		if (inner_ret != _SUCCESS && ret == _SUCCESS)
 			ret = _FAIL;
 
-		if (t != (pattrib->nr_frags - 1))
-		{
+		if (t != (pattrib->nr_frags - 1)) {
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("pattrib->nr_frags=%d\n", pattrib->nr_frags));
 
 			sz = pxmitpriv->frag_len;
 			sz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 : pattrib->icv_len);
-		}
-		else /* no frag */
-		{
+		} else { /* no frag */
 			sz = pattrib->last_txcmdsz;
 		}
 
 		pull = update_txdesc(pxmitframe, mem_addr, sz, false);
 
-		if (pull)
-		{
+		if (pull) {
 			mem_addr += PACKET_OFFSET_SZ; /* pull txdesc head */
 
 			pxmitframe->buf_addr = mem_addr;
 
 			w_sz = sz + TXDESC_SIZE;
-		}
-		else
-		{
+		} else {
 			w_sz = sz + TXDESC_SIZE + PACKET_OFFSET_SZ;
 		}
 
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -3595,18 +3595,10 @@ static void hw_var_set_mlme_sitesurvey(s
 #ifdef CONFIG_CONCURRENT_MODE
 		|| (check_buddy_fwstate(adapter, WIFI_AP_STATE) == true)
 #endif
-#ifdef CONFIG_TDLS
-		/*  TDLS will clear RCR_CBSSID_DATA bit for connection. */
-		|| (adapter->tdlsinfo.setup_state & TDLS_LINKED_STATE)
-#endif /*  CONFIG_TDLS */
 		)
-	{
 		rcr_clear_bit = RCR_CBSSID_BCN;
-	}
 	else
-	{
 		rcr_clear_bit = (RCR_CBSSID_BCN | RCR_CBSSID_DATA);
-	}
 
 	/*  Recieve all data frames */
 	value_rxfltmap2 = 0xFFFF;
@@ -4415,30 +4407,6 @@ static void SetHwReg8192DU(struct rtw_ad
 			}
 			break;
 #endif /*  CONFIG_P2P_PS */
-#ifdef CONFIG_TDLS
-		case HW_VAR_TDLS_WRCR:
-			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)&(~ BIT(6)));
-			break;
-		case HW_VAR_TDLS_INIT_CH_SEN:
-			{
-				rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)&(~ BIT(6))&(~ BIT(7)));
-				rtw_write16(adapter, REG_RXFLTMAP2, 0xffff);
-
-				/* disable update TSF */
-				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
-			}
-			break;
-		case HW_VAR_TDLS_DONE_CH_SEN:
-			{
-				/* enable update TSF */
-				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~ BIT(4)));
-				rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|(BIT(7)));
-			}
-			break;
-		case HW_VAR_TDLS_RS_RCR:
-			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|(BIT(6)));
-			break;
-#endif /* CONFIG_TDLS */
 		case HW_VAR_INITIAL_GAIN:
 			{
 				struct DIG_T *dig_table = &pdmpriv->DM_DigTable;
@@ -4899,28 +4867,15 @@ static void UpdateHalRAMask8192DUsb(stru
 			break;
 
 		default: /* for each sta in IBSS */
-#ifdef CONFIG_TDLS
-			if (psta->tdls_sta_state & TDLS_LINKED_STATE)
-			{
-				shortGIrate = update_sgi_tdls(padapter, psta);
-				mask = update_mask_tdls(padapter, psta);
-				raid = mask>>28;
-				break;
-			}
-			else
-#endif /* CONFIG_TDLS */
-			{
-				supportRateNum = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[mac_id].SupportedRates);
-				networkType = judge_network_type(padapter, pmlmeinfo->FW_sta_info[mac_id].SupportedRates, supportRateNum);
-				raid = networktype_to_raid(networkType);
-
-				mask = update_supported_rate(cur_network->SupportedRates, supportRateNum);
-				mask |= ((raid<<28)&0xf0000000);
+			supportRateNum = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[mac_id].SupportedRates);
+			networkType = judge_network_type(padapter, pmlmeinfo->FW_sta_info[mac_id].SupportedRates, supportRateNum);
+			raid = networktype_to_raid(networkType);
 
-				/* todo: support HT in IBSS */
+			mask = update_supported_rate(cur_network->SupportedRates, supportRateNum);
+			mask |= ((raid<<28)&0xf0000000);
 
-				break;
-			}
+			/* todo: support HT in IBSS */
+			break;
 	}
 
 #ifdef CONFIG_BT_COEXIST
--- a/drivers/staging/rtl8192du/include/drv_types.h
+++ b/drivers/staging/rtl8192du/include/drv_types.h
@@ -311,10 +311,6 @@ struct rtw_adapter {
 	struct wifidirect_info	wdinfo;
 #endif /* CONFIG_P2P */
 
-#ifdef CONFIG_TDLS
-	struct tdls_info	tdlsinfo;
-#endif /* CONFIG_TDLS */
-
 	void *HalData;
 	u32 hal_data_sz;
 	struct hal_ops	HalFunc;
--- a/drivers/staging/rtl8192du/include/ieee80211.h
+++ b/drivers/staging/rtl8192du/include/ieee80211.h
@@ -1008,26 +1008,6 @@ enum _PUBLIC_ACTION{
 	ACT_PUBLIC_MAX
 };
 
-#ifdef CONFIG_TDLS
-enum TDLS_ACTION_FIELD{
-	TDLS_SETUP_REQUEST = 0,
-	TDLS_SETUP_RESPONSE = 1,
-	TDLS_SETUP_CONFIRM = 2,
-	TDLS_TEARDOWN = 3,
-	TDLS_PEER_TRAFFIC_INDICATION = 4,
-	TDLS_CHANNEL_SWITCH_REQUEST = 5,
-	TDLS_CHANNEL_SWITCH_RESPONSE = 6,
-	TDLS_PEER_PSM_REQUEST = 7,
-	TDLS_PEER_PSM_RESPONSE = 8,
-	TDLS_PEER_TRAFFIC_RESPONSE = 9,
-	TDLS_DISCOVERY_REQUEST = 10,
-	TDLS_DISCOVERY_RESPONSE = 14,	/* it's used in public action frame */
-};
-
-#define	TUNNELED_PROBE_REQ	15
-#define	TUNNELED_PROBE_RSP	16
-#endif /* CONFIG_TDLS */
-
 /* BACK action code */
 enum rtw_ieee80211_back_actioncode {
 	RTW_WLAN_ACTION_ADDBA_REQ = 0,
--- a/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
@@ -261,40 +261,6 @@ struct	ss_res
 
 #define	WIFI_FW_LINKING_STATE		(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE | WIFI_FW_AUTH_SUCCESS |WIFI_FW_ASSOC_STATE)
 
-#ifdef CONFIG_TDLS
-/*  1: Write RCR DATA BIT */
-/*  2: Issue peer traffic indication */
-/*  3: Go back to the channel linked with AP, terminating channel switch procedure */
-/*  4: Init channel sensing, receive all data and mgnt frame */
-/*  5: Channel sensing and report candidate channel */
-/*  6: First time set channel to off channel */
-/*  7: Go back tp the channel linked with AP when set base channel as target channel */
-/*  8: Set channel back to base channel */
-/*  9: Set channel back to off channel */
-/*  10: Restore RCR DATA BIT */
-/*  11: Check alive */
-/*  12: Check alive */
-/*  13: Free TDLS sta */
-enum TDLS_option
-{
-	TDLS_WRCR			=	1,
-	TDLS_SD_PTI		=	2,
-	TDLS_CS_OFF		=	3,
-	TDLS_INIT_CH_SEN	=	4,
-	TDLS_DONE_CH_SEN	=	5,
-	TDLS_OFF_CH		=	6,
-	TDLS_BASE_CH		=	7,
-	TDLS_P_OFF_CH		=	8,
-	TDLS_P_BASE_CH	=	9,
-	TDLS_RS_RCR		=	10,
-	TDLS_CKALV_PH1	=	11,
-	TDLS_CKALV_PH2	=	12,
-	TDLS_FREE_STA		=	13,
-	maxTDLS,
-};
-
-#endif /* CONFIG_TDLS */
-
 struct FW_Sta_Info
 {
 	struct sta_info	*psta;
--- a/drivers/staging/rtl8192du/include/rtw_security.h
+++ b/drivers/staging/rtl8192du/include/rtw_security.h
@@ -380,15 +380,6 @@ u32 rtw_aes_decrypt(struct rtw_adapter *
 u32 rtw_tkip_decrypt(struct rtw_adapter *padapter, u8  *precvframe);
 void rtw_wep_decrypt(struct rtw_adapter *padapter, u8  *precvframe);
 
-#ifdef CONFIG_TDLS
-void wpa_tdls_generate_tpk(struct rtw_adapter *padapter, struct sta_info *psta);
-int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq,
-						u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie,
-						u8 *mic);
-int tdls_verify_mic(u8 *kck, u8 trans_seq,
-						u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie);
-#endif /* CONFIG_TDLS */
-
 void rtw_use_tkipkey_handler(void* FunctionContext);
 
 #endif	/* __RTL871X_SECURITY_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_tdls.h
+++ b/drivers/staging/rtl8192du/include/rtw_tdls.h
@@ -18,119 +18,6 @@
 
 #include <drv_types.h>
 
-#ifdef CONFIG_TDLS
-/* TDLS STA state */
-#define	TDLS_STATE_NONE				0x00000000	/* default state */
-#define	TDLS_INITIATOR_STATE			0x10000000
-#define	TDLS_RESPONDER_STATE			0x20000000
-#define	TDLS_LINKED_STATE				0x40000000
-#define	TDLS_CH_SWITCH_ON_STATE		0x01000000
-#define	TDLS_PEER_AT_OFF_STATE		0x02000000	/* could send pkt on target ch */
-#define	TDLS_AT_OFF_CH_STATE			0x04000000
-#define	TDLS_CH_SW_INITIATOR_STATE	0x08000000	/* avoiding duplicated or unconditional ch. switch rsp. */
-#define	TDLS_APSD_CHSW_STATE		0x00100000	/* in APSD and want to setup channel switch */
-#define	TDLS_PEER_SLEEP_STATE		0x00200000	/* peer sta is sleeping */
-#define	TDLS_SW_OFF_STATE			0x00400000	/* terminate channel swithcing */
-#define	TDLS_ALIVE_STATE				0x00010000	/* Check if peer sta is alived. */
-
-#define	TPK_RESEND_COUNT				301
-#define		CH_SWITCH_TIME				10
-#define		CH_SWITCH_TIMEOUT			30
-#define	TDLS_STAY_TIME				500
-#define	TDLS_SIGNAL_THRESH			0x20
-#define	TDLS_WATCHDOG_PERIOD		10	/* Periodically sending tdls discovery request in TDLS_WATCHDOG_PERIOD * 2 sec */
-#define	TDLS_ALIVE_TIMER_PH1			5000
-#define	TDLS_ALIVE_TIMER_PH2			2000
-#define	TDLS_STAY_TIME				500
-#define	TDLS_HANDSHAKE_TIME			2000
-#define	TDLS_ALIVE_COUNT				3
-#define	TDLS_INI_MACID_ENTRY			6
-
-/* TDLS */
-#define TDLS_MIC_LEN 16
-#define WPA_NONCE_LEN 32
-#define TDLS_TIMEOUT_LEN 4
-
-struct wpa_tdls_ftie {
-	u8 ie_type; /* FTIE */
-	u8 ie_len;
-	u8 mic_ctrl[2];
-	u8 mic[TDLS_MIC_LEN];
-	u8 Anonce[WPA_NONCE_LEN]; /* Responder Nonce in TDLS */
-	u8 Snonce[WPA_NONCE_LEN]; /* Initiator Nonce in TDLS */
-	/* followed by optional elements */
-};
-
-struct wpa_tdls_lnkid {
-	u8 ie_type; /* Link Identifier IE */
-	u8 ie_len;
-	u8 bssid[ETH_ALEN];
-	u8 init_sta[ETH_ALEN];
-	u8 resp_sta[ETH_ALEN];
-};
-
-static u8 TDLS_RSNIE[] = {
-	0x01, 0x00,	/* version shall be set to 1 */
-	0x00, 0x0f, 0xac, 0x07,	/* group sipher suite */
-	0x01, 0x00,	/* pairwise cipher suite count */
-	0x00, 0x0f, 0xac, 0x04,	/* pairwise cipher suite list; CCMP only */
-	0x01, 0x00,	/* AKM suite count */
-	0x00, 0x0f, 0xac, 0x07,	/* TPK Handshake */
-	0x00, 0x02,
-	/* PMKID shall not be present */
-};
-
-static u8 TDLS_WMMIE[]={0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};	/* Qos info all set zero */
-
-static u8 TDLS_EXT_CAPIE[] = {0x00, 0x00, 0x00, 0x50, 0x20};	/* bit(28), bit(30), bit(37) */
-
-/* 	SRC: Supported Regulatory Classes */
-static u8 TDLS_SRC[] = { 0x01, 0x01, 0x02, 0x03, 0x04, 0x0c, 0x16, 0x17, 0x18, 0x19, 0x1b, 0x1c, 0x1d, 0x1e, 0x20, 0x21 };
-
-void rtw_reset_tdls_info(_adapter* padapter);
-int rtw_init_tdls_info(_adapter* padapter);
-void rtw_free_tdls_info(struct tdls_info *ptdlsinfo);
-void issue_nulldata_to_TDLS_peer_STA(_adapter *padapter, struct sta_info *ptdls_sta, unsigned int power_mode);
-void init_TPK_timer(_adapter *padapter, struct sta_info *psta);
-void init_ch_switch_timer(_adapter *padapter, struct sta_info *psta);
-void init_base_ch_timer(_adapter *padapter, struct sta_info *psta);
-void init_off_ch_timer(_adapter *padapter, struct sta_info *psta);
-void init_tdls_alive_timer(_adapter *padapter, struct sta_info *psta);
-void init_handshake_timer(_adapter *padapter, struct sta_info *psta);
-void free_tdls_sta(_adapter *padapter, struct sta_info *ptdls_sta);
-void issue_tdls_dis_req(_adapter *padapter, u8 *mac_addr);
-void issue_tdls_setup_req(_adapter *padapter, u8 *mac_addr);
-void issue_tdls_setup_rsp(_adapter *padapter, struct recv_frame_hdr *precv_frame);
-void issue_tdls_setup_cfm(_adapter *padapter, struct recv_frame_hdr *precv_frame);
-void issue_tdls_dis_rsp(_adapter * padapter, struct recv_frame_hdr * precv_frame, u8 dialog);
-void issue_tdls_teardown(_adapter *padapter, u8 *mac_addr);
-void issue_tdls_peer_traffic_indication(_adapter *padapter, struct sta_info *psta);
-void issue_tdls_ch_switch_req(_adapter *padapter, u8 *mac_addr);
-void issue_tdls_ch_switch_rsp(_adapter *padapter, u8 *mac_addr);
-int On_TDLS_Dis_Rsp(_adapter *adapter, struct recv_frame_hdr *precv_frame);
-int On_TDLS_Setup_Req(_adapter *adapter, struct recv_frame_hdr *precv_frame);
-int On_TDLS_Setup_Rsp(_adapter *adapter, struct recv_frame_hdr *precv_frame);
-int On_TDLS_Setup_Cfm(_adapter *adapter, struct recv_frame_hdr *precv_frame);
-int On_TDLS_Dis_Req(_adapter *adapter, struct recv_frame_hdr *precv_frame);
-int On_TDLS_Teardown(_adapter *adapter, struct recv_frame_hdr *precv_frame);
-int On_TDLS_Peer_Traffic_Rsp(_adapter *adapter, struct recv_frame_hdr *precv_frame);
-int On_TDLS_Ch_Switch_Req(_adapter *adapter, struct recv_frame_hdr *precv_frame);
-int On_TDLS_Ch_Switch_Rsp(_adapter *adapter, struct recv_frame_hdr *precv_frame);
-void rtw_build_tdls_setup_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe);
-void rtw_build_tdls_setup_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe);
-void rtw_build_tdls_setup_cfm_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe);
-void rtw_build_tdls_teardown_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe);
-void rtw_build_tdls_dis_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe);
-void rtw_build_tdls_dis_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, u8 dialog);
-void rtw_build_tdls_peer_traffic_indication_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe);
-void rtw_build_tdls_ch_switch_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe);
-void rtw_build_tdls_ch_switch_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe);
-void rtw_build_tunneled_probe_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe);
-void rtw_build_tunneled_probe_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe);
-
-int update_sgi_tdls(_adapter *padapter, struct sta_info *psta);
-u32 update_mask_tdls(_adapter *padapter, struct sta_info *psta);
-#endif /* CONFIG_TDLS */
 s32 rtw_dump_xframe(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe);
 
 #endif
--- a/drivers/staging/rtl8192du/include/rtw_xmit.h
+++ b/drivers/staging/rtl8192du/include/rtw_xmit.h
@@ -414,9 +414,6 @@ int rtw_xmit_thread(void *context);
 u32 rtw_calculate_wlan_pkt_size_by_attribue(struct pkt_attrib *pattrib);
 #define rtw_wlan_pkt_size(f) rtw_calculate_wlan_pkt_size_by_attribue(&f->attrib)
 s32 rtw_xmitframe_coalesce(struct rtw_adapter *padapter, struct sk_buff *pkt, struct xmit_frame *pxmitframe);
-#ifdef CONFIG_TDLS
-s32 rtw_xmit_tdls_coalesce(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe, u8 action);
-#endif /* CONFIG_TDLS */
 s32 _rtw_init_hw_txqueue(struct hw_txqueue* phw_txqueue, u8 ac_tag);
 void _rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);
 
@@ -432,7 +429,7 @@ void rtw_free_hwxmits(struct rtw_adapter
 
 s32 rtw_xmit(struct rtw_adapter *padapter, struct sk_buff **pkt);
 
-#if defined(CONFIG_92D_AP_MODE) || defined(CONFIG_TDLS)
+#if defined(CONFIG_92D_AP_MODE)
 int xmitframe_enqueue_for_sleeping_sta(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe);
 void stop_sta_xmit(struct rtw_adapter *padapter, struct sta_info *psta);
 void wakeup_sta_to_xmit(struct rtw_adapter *padapter, struct sta_info *psta);
--- a/drivers/staging/rtl8192du/include/sta_info.h
+++ b/drivers/staging/rtl8192du/include/sta_info.h
@@ -81,13 +81,6 @@ struct	stainfo_stats	{
 
 };
 
-#ifdef CONFIG_TDLS
-struct TDLS_PeerKey {
-	u8 kck[16]; /* TPK-KCK */
-	u8 tk[16]; /* TPK-TK; only CCMP will be used */
-} ;
-#endif /* CONFIG_TDLS */
-
 struct sta_info {
 	spinlock_t lock;
 	struct list_head list; /* free_sta_queue */
@@ -126,32 +119,6 @@ struct sta_info {
 	u32	ra_mask;
 	struct stainfo_stats sta_stats;
 
-#ifdef CONFIG_TDLS
-	u32	tdls_sta_state;
-	u8	dialog;
-	u8	SNonce[32];
-	u8	ANonce[32];
-	u32	TDLS_PeerKey_Lifetime;
-	u16	TPK_count;
-	struct timer_list TPK_timer;
-	struct TDLS_PeerKey	tpk;
-	struct rtw_adapter *padapter;
-	u16	stat_code;
-	u8	off_ch;
-	u16	ch_switch_time;
-	u16	ch_switch_timeout;
-	u8	option;
-	struct timer_list option_timer;
-	struct timer_list base_ch_timer;
-	struct timer_list off_ch_timer;
-
-	struct timer_list handshake_timer;
-	struct timer_list alive_timer1;
-	struct timer_list alive_timer2;
-	u8 timer_flag;
-	u8 alive_count;
-#endif /* CONFIG_TDLS */
-
 	/* for A-MPDU TX, ADDBA timeout check */
 	struct timer_list addba_retry_timer;
 
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -6981,20 +6981,6 @@ static int rtw_tdls_weaksec(struct net_d
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-
-	u8 i, j;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
-
-	if (extra[0] == '0') {
-		padapter->wdinfo.wfd_tdls_weaksec = 0;
-	} else {
-		padapter->wdinfo.wfd_tdls_weaksec = 1;
-	}
-#endif
-
 	return ret;
 }
 
@@ -7004,56 +6990,6 @@ static int rtw_tdls_enable(struct net_de
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct tdls_info	*ptdlsinfo = &padapter->tdlsinfo;
-	struct list_head *plist, *phead;
-	s32	index;
-	struct sta_info *psta = NULL;
-	struct	sta_priv *pstapriv = &padapter->stapriv;
-	u8 tdls_sta[NUM_STA][ETH_ALEN];
-	u8 empty_hwaddr[ETH_ALEN] = { 0x00 };
-
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
-
-	memset(tdls_sta, 0x00, sizeof(tdls_sta));
-
-	if (extra[0] == '0') {
-		ptdlsinfo->enable = 0;
-
-		if (pstapriv->asoc_sta_count == 1)
-			return ret;
-
-		spin_lock_bh(&pstapriv->sta_hash_lock);
-		for (index = 0; index< NUM_STA; index++) {
-			phead = &(pstapriv->sta_hash[index]);
-			plist = phead->next;
-
-			while ((rtw_end_of_queue_search(phead, plist)) == false) {
-				psta = container_of(plist, struct sta_info , hash_list);
-
-				plist = plist->next;
-
-				if (psta->tdls_sta_state != TDLS_STATE_NONE)
-					memcpy(tdls_sta[index], psta->hwaddr, ETH_ALEN);
-			}
-		}
-		spin_unlock_bh(&pstapriv->sta_hash_lock);
-
-		for (index = 0; index< NUM_STA; index++) {
-			if (!!memcmp(tdls_sta[index], empty_hwaddr, ETH_ALEN)) {
-				DBG_8192D("issue tear down to %pM\n", tdls_sta[index]);
-				issue_tdls_teardown(padapter, tdls_sta[index]);
-			}
-		}
-		rtw_tdls_cmd(padapter, myid(&(padapter->eeprompriv)), TDLS_RS_RCR);
-		rtw_reset_tdls_info(padapter);
-	} else if (extra[0] == '1') {
-		ptdlsinfo->enable = 1;
-	}
-#endif /* CONFIG_TDLS */
-
 	return ret;
 }
 
@@ -7063,19 +6999,6 @@ static int rtw_tdls_setup(struct net_dev
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-
-	u8 i, j;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	u8 mac_addr[ETH_ALEN];
-
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
-
-	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3)
-		mac_addr[i]= key_2char2num(*(extra+j), *(extra+j+1));
-
-	issue_tdls_setup_req(padapter, mac_addr);
-#endif
 	return ret;
 }
 
@@ -7085,27 +7008,6 @@ static int rtw_tdls_teardown(struct net_
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-
-	u8 i, j;
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct sta_info *ptdls_sta = NULL;
-	u8 mac_addr[ETH_ALEN];
-
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
-
-	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3)
-		mac_addr[i]= key_2char2num(*(extra+j), *(extra+j+1));
-
-	ptdls_sta = rtw_get_stainfo(&(padapter->stapriv), mac_addr);
-
-	if (ptdls_sta != NULL) {
-		ptdls_sta->stat_code = _RSON_TDLS_TEAR_UN_RSN_;
-		issue_tdls_teardown(padapter, mac_addr);
-	}
-
-#endif /* CONFIG_TDLS */
-
 	return ret;
 }
 
@@ -7115,18 +7017,6 @@ static int rtw_tdls_discovery(struct net
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
-
-	issue_tdls_dis_req(padapter, NULL);
-
-#endif /* CONFIG_TDLS */
-
 	return ret;
 }
 
@@ -7136,28 +7026,7 @@ static int rtw_tdls_ch_switch (struct ne
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct tdls_info	*ptdlsinfo = &padapter->tdlsinfo;
-	u8 i, j, mac_addr[ETH_ALEN];
-	struct sta_info *ptdls_sta = NULL;
-
-	DBG_8192S("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
-
-	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3)
-		mac_addr[i]= key_2char2num(*(extra+j), *(extra+j+1));
-
-	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
-	if (ptdls_sta == NULL)
-		return ret;
-	ptdlsinfo->ch_sensing = 1;
-
-	rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_INIT_CH_SEN);
-
-#endif /* CONFIG_TDLS */
-
-		return ret;
+	return ret;
 }
 
 static int rtw_tdls_pson(struct net_device *dev,
@@ -7166,26 +7035,7 @@ static int rtw_tdls_pson(struct net_devi
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	u8 i, j, mac_addr[ETH_ALEN];
-	struct sta_info *ptdls_sta = NULL;
-
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
-
-	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3)
-		mac_addr[i]= key_2char2num(*(extra+j), *(extra+j+1));
-
-	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
-
-	issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 1);
-
-#endif /* CONFIG_TDLS */
-
-		return ret;
+	return ret;
 }
 
 static int rtw_tdls_psoff(struct net_device *dev,
@@ -7194,25 +7044,6 @@ static int rtw_tdls_psoff(struct net_dev
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	u8 i, j, mac_addr[ETH_ALEN];
-	struct sta_info *ptdls_sta = NULL;
-
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
-
-	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3)
-		mac_addr[i]= key_2char2num(*(extra+j), *(extra+j+1));
-
-	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
-
-	issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 0);
-
-#endif /* CONFIG_TDLS */
-
 	return ret;
 }
 
@@ -7270,24 +7101,6 @@ static int rtw_tdls_ch_switch_off(struct
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	u8 i, j, mac_addr[ETH_ALEN];
-	struct sta_info *ptdls_sta = NULL;
-
-	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
-
-	for (i = 0, j = 0 ; i < ETH_ALEN; i++, j+= 3) {
-		mac_addr[i]= key_2char2num(*(extra+j), *(extra+j+1));
-	}
-
-	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
-
-	ptdls_sta->tdls_sta_state |= TDLS_SW_OFF_STATE;
-
-#endif /* CONFIG_TDLS */
-
 	return ret;
 }
 
@@ -7297,54 +7110,6 @@ static int rtw_tdls(struct net_device *d
 {
 	int ret = 0;
 
-#ifdef CONFIG_TDLS
-	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-
-	DBG_8192D("[%s] extra = %s\n", __func__, extra);
-	/*	WFD Sigma will use the tdls enable command to let the driver know we want to test the tdls now! */
-	if (!memcmp(extra, "wfdenable =", 10)) {
-		wrqu->data.length -= 10;
-		rtw_wfd_tdls_enable(dev, info, wrqu, &extra[10]);
-		return ret;
-	} else if (!memcmp(extra, "weaksec =", 8)) {
-		wrqu->data.length -= 8;
-		rtw_tdls_weaksec(dev, info, wrqu, &extra[8]);
-		return ret;
-	} else if (!memcmp(extra, "tdlsenable =", 11)) {
-		wrqu->data.length -= 11;
-		rtw_tdls_enable(dev, info, wrqu, &extra[11]);
-		return ret;
-	}
-
-	if (padapter->tdlsinfo.enable == 0) {
-		DBG_8192D("tdls haven't enabled\n");
-		return 0;
-	}
-
-	if (!memcmp(extra, "setup =", 6)) {
-		wrqu->data.length -= 6;
-		rtw_tdls_setup(dev, info, wrqu, &extra[6]);
-	} else if (!memcmp(extra, "tear =", 5)) {
-		wrqu->data.length -= 5;
-		rtw_tdls_teardown(dev, info, wrqu, &extra[5]);
-	} else if (!memcmp(extra, "dis =", 4)) {
-		wrqu->data.length -= 4;
-		rtw_tdls_discovery(dev, info, wrqu, &extra[4]);
-	} else if (!memcmp(extra, "sw =", 3)) {
-		wrqu->data.length -= 3;
-		rtw_tdls_ch_switch (dev, info, wrqu, &extra[3]);
-	} else if (!memcmp(extra, "swoff =", 6)) {
-		wrqu->data.length -= 6;
-		rtw_tdls_ch_switch_off(dev, info, wrqu, &extra[6]);
-	} else if (!memcmp(extra, "pson =", 5)) {
-		wrqu->data.length -= 5;
-		rtw_tdls_pson(dev, info, wrqu, &extra[5]);
-	} else if (!memcmp(extra, "psoff =", 6)) {
-		wrqu->data.length -= 6;
-		rtw_tdls_psoff(dev, info, wrqu, &extra[6]);
-	}
-#endif /* CONFIG_TDLS */
-
 	return ret;
 }
 
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -1119,31 +1119,19 @@ u8 rtw_init_drv_sw(struct rtw_adapter *p
 	#endif
 #endif /* CONFIG_P2P */
 
-	if (init_mlme_ext_priv(padapter) == _FAIL)
-	{
+	if (init_mlme_ext_priv(padapter) == _FAIL) {
 		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init mlme_ext_priv\n"));
 		ret8 = _FAIL;
 		goto exit;
 	}
 
-#ifdef CONFIG_TDLS
-	if (rtw_init_tdls_info(padapter) == _FAIL)
-	{
-		DBG_8192D("Can't rtw_init_tdls_info\n");
-		ret8 = _FAIL;
-		goto exit;
-	}
-#endif /* CONFIG_TDLS */
-
-	if (_rtw_init_xmit_priv(&padapter->xmitpriv, padapter) == _FAIL)
-	{
+	if (_rtw_init_xmit_priv(&padapter->xmitpriv, padapter) == _FAIL) {
 		DBG_8192D("Can't _rtw_init_xmit_priv\n");
 		ret8 = _FAIL;
 		goto exit;
 	}
 
-	if (_rtw_init_recv_priv(&padapter->recvpriv, padapter) == _FAIL)
-	{
+	if (_rtw_init_recv_priv(&padapter->recvpriv, padapter) == _FAIL) {
 		DBG_8192D("Can't _rtw_init_recv_priv\n");
 		ret8 = _FAIL;
 		goto exit;

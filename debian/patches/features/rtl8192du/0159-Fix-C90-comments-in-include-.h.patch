From 8135efc42a4c5faef87e46a0e9f093514f671422 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Tue, 14 May 2013 23:26:11 -0500
Subject: [PATCH 159/390] Fix C90 comments in include/*.h

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 include/Hal8192DPhyCfg.h        | 193 +++++----
 include/Hal8192DPhyReg.h        | 506 +++++++++++------------
 include/Hal8192DUHWImg.h        |   2 +-
 include/Hal8192DUHWImg_wowlan.h |   2 +-
 include/autoconf.h              |  71 +---
 include/basic_types.h           |  88 ++--
 include/circ_buf.h              |   2 +-
 include/drv_conf.h              |  21 +-
 include/drv_types.h             | 150 +++----
 include/ethernet.h              |  18 +-
 include/hal_intf.h              |  16 +-
 include/ieee80211.h             |  91 ++--
 include/ioctl_cfg80211.h        |   8 +-
 include/mlme_osdep.h            |   2 +-
 include/mp_custom_oid.h         | 240 +++++------
 include/nic_spec.h              |   2 +-
 include/osdep_intf.h            |  22 +-
 include/osdep_service.h         |  37 +-
 include/rtl8192d_cmd.h          |  48 +--
 include/rtl8192d_dm.h           | 115 +++---
 include/rtl8192d_hal.h          | 255 ++++++------
 include/rtl8192d_led.h          |   6 +-
 include/rtl8192d_recv.h         |   8 +-
 include/rtl8192d_rf.h           |  12 +-
 include/rtl8192d_spec.h         | 894 ++++++++++++++++++++--------------------
 include/rtl8192d_xmit.h         |  16 +-
 include/rtw_android.h           |   2 +-
 include/rtw_ap.h                |   4 +-
 include/rtw_br_ext.h            |   4 +-
 include/rtw_cmd.h               |  72 ++--
 include/rtw_debug.h             |   6 +-
 include/rtw_eeprom.h            |  44 +-
 include/rtw_efuse.h             |   8 +-
 include/rtw_event.h             |   6 +-
 include/rtw_ht.h                |  20 +-
 include/rtw_io.h                |  64 ++-
 include/rtw_ioctl.h             |  18 +-
 include/rtw_ioctl_rtl.h         |  16 +-
 include/rtw_led.h               |  70 ++--
 include/rtw_mlme.h              | 318 +++++++-------
 include/rtw_mlme_ext.h          | 208 +++++-----
 include/rtw_mp.h                | 136 +++---
 include/rtw_mp_ioctl.h          | 304 +++++++-------
 include/rtw_mp_phy_regdef.h     | 508 +++++++++++------------
 include/rtw_p2p.h               |  18 +-
 include/rtw_pwrctrl.h           |  65 ++-
 include/rtw_qos.h               |   4 +-
 include/rtw_recv.h              | 113 +++--
 include/rtw_rf.h                |  62 ++-
 include/rtw_security.h          |  76 ++--
 include/rtw_tdls.h              |  49 +--
 include/rtw_xmit.h              |  97 ++---
 include/sta_info.h              |  80 ++--
 include/usb_hal.h               |   6 +-
 include/usb_ops.h               |   6 +-
 include/usb_ops_linux.h         |   6 +-
 include/usb_osintf.h            |   3 -
 include/usb_vendor_req.h        |   4 +-
 include/wifi.h                  | 197 +++++----
 include/wlan_bssdef.h           |  80 ++--
 include/xmit_osdep.h            |   4 +-
 61 files changed, 2625 insertions(+), 2878 deletions(-)

--- a/drivers/staging/rtl8192du/include/Hal8192DPhyCfg.h
+++ b/drivers/staging/rtl8192du/include/Hal8192DPhyCfg.h
@@ -42,8 +42,8 @@
 
 /*--------------------------Define Parameters-------------------------------*/
 #define LOOP_LIMIT				5
-#define MAX_STALL_TIME			50		//us
-#define AntennaDiversityValue	0x80	//(Adapter->bSoftwareAntennaDiversity ? 0x00:0x80)
+#define MAX_STALL_TIME			50		/* us */
+#define AntennaDiversityValue	0x80	/* Adapter->bSoftwareAntennaDiversity ? 0x00:0x80) */
 #define MAX_TXPWR_IDX_NMODE_92S	63
 #define Reset_Cnt_Limit			3
 
@@ -88,10 +88,10 @@ enum HW90_BLOCK {
 	HW90_BLOCK_PHY0 = 1,
 	HW90_BLOCK_PHY1 = 2,
 	HW90_BLOCK_RF = 3,
-	HW90_BLOCK_MAXIMUM = 4, // Never use this
+	HW90_BLOCK_MAXIMUM = 4, /*  Never use this */
 };
 
-//vivi added this for read parameter from header, 20100908
+/* vivi added this for read parameter from header, 20100908 */
 enum RF_CONTENT {
 	radioa_txt = 0x1000,
 	radiob_txt = 0x1001,
@@ -112,8 +112,8 @@ enum WIRELESS_MODE {
 };
 
 
-#define CHANNEL_MAX_NUMBER		14+24+21	// 14 is the max channel number
-#define CHANNEL_GROUP_MAX		3+9	// ch1~3, ch4~9, ch10~14 total three groups
+#define CHANNEL_MAX_NUMBER		14+24+21	/*  14 is the max channel number */
+#define CHANNEL_GROUP_MAX		3+9	/*  ch1~3, ch4~9, ch10~14 total three groups */
 #define MAX_PG_GROUP 13
 
 #define	CHANNEL_GROUP_MAX_2G		3
@@ -124,8 +124,8 @@ enum WIRELESS_MODE {
 #define	CHANNEL_MAX_NUMBER_2G		14
 
 enum BaseBand_Config_Type {
-	BaseBand_Config_PHY_REG = 0,			//Radio Path A
-	BaseBand_Config_AGC_TAB = 1,			//Radio Path B
+	BaseBand_Config_PHY_REG = 0,			/* Radio Path A */
+	BaseBand_Config_AGC_TAB = 1,			/* Radio Path B */
 };
 
 enum MACPHY_MODE_8192D {
@@ -164,51 +164,51 @@ enum PHY_Rate_Tx_Power_Offset_Area {
 
 /* BB/RF related */
 enum RF_TYPE_8190P {
-	RF_TYPE_MIN,	// 0
-	RF_8225=1,			// 1 11b/g RF for verification only
-	RF_8256=2,			// 2 11b/g/n
-	RF_8258=3,			// 3 11a/b/g/n RF
-	RF_6052=4,		// 4 11b/g/n RF
-	// TODO: We should remove this psudo PHY RF after we get new RF.
-	RF_PSEUDO_11N=5,	// 5, It is a temporality RF.
+	RF_TYPE_MIN,	/*  0 */
+	RF_8225=1,			/*  1 11b/g RF for verification only */
+	RF_8256=2,			/*  2 11b/g/n */
+	RF_8258=3,			/*  3 11a/b/g/n RF */
+	RF_6052=4,		/*  4 11b/g/n RF */
+	/*  TODO: We should remove this psudo PHY RF after we get new RF. */
+	RF_PSEUDO_11N=5,	/*  5, It is a temporality RF. */
 };
 
 struct bb_register_def {
-	u32 rfintfs;		// set software control:
-				//		0x870~0x877[8 bytes]
-	u32 rfintfi;		// readback data:
-				//		0x8e0~0x8e7[8 bytes]
-	u32 rfintfo;		// output data:
-				//		0x860~0x86f [16 bytes]
-	u32 rfintfe;		// output enable:
-				//		0x860~0x86f [16 bytes]
-	u32 rf3wireOffset;	// LSSI data:
-				//		0x840~0x84f [16 bytes]
-	u32 rfLSSI_Select;	// BB Band Select:
-				//		0x878~0x87f [8 bytes]
-	u32 rfTxGainStage;	// Tx gain stage:
-				//		0x80c~0x80f [4 bytes]
-	u32 rfHSSIPara1;	// wire parameter control1 :
-				//		0x820~0x823,0x828~0x82b, 0x830~0x833, 0x838~0x83b [16 bytes]
-	u32 rfHSSIPara2;	// wire parameter control2 :
-				//		0x824~0x827,0x82c~0x82f, 0x834~0x837, 0x83c~0x83f [16 bytes]
-	u32 rfSwitchControl;	//Tx Rx antenna control :
-				//		0x858~0x85f [16 bytes]
-	u32 rfAGCControl1;	//AGC parameter control1 :
-				//		0xc50~0xc53,0xc58~0xc5b, 0xc60~0xc63, 0xc68~0xc6b [16 bytes]
-	u32 rfAGCControl2;	//AGC parameter control2 :
-				//		0xc54~0xc57,0xc5c~0xc5f, 0xc64~0xc67, 0xc6c~0xc6f [16 bytes]
-	u32 rfRxIQImbalance;	//OFDM Rx IQ imbalance matrix :
-				//		0xc14~0xc17,0xc1c~0xc1f, 0xc24~0xc27, 0xc2c~0xc2f [16 bytes]
-	u32 rfRxAFE;		//Rx IQ DC ofset and Rx digital filter, Rx DC notch filter :
-				//		0xc10~0xc13,0xc18~0xc1b, 0xc20~0xc23, 0xc28~0xc2b [16 bytes]
-	u32 rfTxIQImbalance;	//OFDM Tx IQ imbalance matrix
-				//		0xc80~0xc83,0xc88~0xc8b, 0xc90~0xc93, 0xc98~0xc9b [16 bytes]
-	u32 rfTxAFE;		//Tx IQ DC Offset and Tx DFIR type
-				//		0xc84~0xc87,0xc8c~0xc8f, 0xc94~0xc97, 0xc9c~0xc9f [16 bytes]
-	u32 rfLSSIReadBack;	//LSSI RF readback data SI mode
-				//		0x8a0~0x8af [16 bytes]
-	u32 rfLSSIReadBackPi;	//LSSI RF readback data PI mode 0x8b8-8bc for Path A and B
+	u32 rfintfs;		/*  set software control: */
+				/* 		0x870~0x877[8 bytes] */
+	u32 rfintfi;		/*  readback data: */
+				/* 		0x8e0~0x8e7[8 bytes] */
+	u32 rfintfo;		/*  output data: */
+				/* 		0x860~0x86f [16 bytes] */
+	u32 rfintfe;		/*  output enable: */
+				/* 		0x860~0x86f [16 bytes] */
+	u32 rf3wireOffset;	/*  LSSI data: */
+				/* 		0x840~0x84f [16 bytes] */
+	u32 rfLSSI_Select;	/*  BB Band Select: */
+				/* 		0x878~0x87f [8 bytes] */
+	u32 rfTxGainStage;	/*  Tx gain stage: */
+				/* 		0x80c~0x80f [4 bytes] */
+	u32 rfHSSIPara1;	/*  wire parameter control1 : */
+				/* 		0x820~0x823,0x828~0x82b, 0x830~0x833, 0x838~0x83b [16 bytes] */
+	u32 rfHSSIPara2;	/*  wire parameter control2 : */
+				/* 		0x824~0x827,0x82c~0x82f, 0x834~0x837, 0x83c~0x83f [16 bytes] */
+	u32 rfSwitchControl;	/* Tx Rx antenna control : */
+				/* 		0x858~0x85f [16 bytes] */
+	u32 rfAGCControl1;	/* AGC parameter control1 : */
+				/* 		0xc50~0xc53,0xc58~0xc5b, 0xc60~0xc63, 0xc68~0xc6b [16 bytes] */
+	u32 rfAGCControl2;	/* AGC parameter control2 : */
+				/* 		0xc54~0xc57,0xc5c~0xc5f, 0xc64~0xc67, 0xc6c~0xc6f [16 bytes] */
+	u32 rfRxIQImbalance;	/* OFDM Rx IQ imbalance matrix : */
+				/* 		0xc14~0xc17,0xc1c~0xc1f, 0xc24~0xc27, 0xc2c~0xc2f [16 bytes] */
+	u32 rfRxAFE;		/* Rx IQ DC ofset and Rx digital filter, Rx DC notch filter : */
+				/* 		0xc10~0xc13,0xc18~0xc1b, 0xc20~0xc23, 0xc28~0xc2b [16 bytes] */
+	u32 rfTxIQImbalance;	/* OFDM Tx IQ imbalance matrix */
+				/* 		0xc80~0xc83,0xc88~0xc8b, 0xc90~0xc93, 0xc98~0xc9b [16 bytes] */
+	u32 rfTxAFE;		/* Tx IQ DC Offset and Tx DFIR type */
+				/* 		0xc84~0xc87,0xc8c~0xc8f, 0xc94~0xc97, 0xc9c~0xc9f [16 bytes] */
+	u32 rfLSSIReadBack;	/* LSSI RF readback data SI mode */
+				/* 		0x8a0~0x8af [16 bytes] */
+	u32 rfLSSIReadBackPi;	/* LSSI RF readback data PI mode 0x8b8-8bc for Path A and B */
 };
 
 struct antenna_select_ofdm {
@@ -239,14 +239,14 @@ struct antenna_select_cck {
 /*------------------------Export Marco Definition---------------------------*/
 /*------------------------Export Marco Definition---------------------------*/
 
-//Added for TX Power
-//u8 GetRightChnlPlace(u8 chnl);
+/* Added for TX Power */
+/* u8 GetRightChnlPlace(u8 chnl); */
 u8 rtl8192d_GetRightChnlPlaceforIQK(u8 chnl);
 u8 rtl8192d_getChnlGroupfromArray(u8 chnl);
 /*--------------------------Exported Function prototype---------------------*/
-//
-// BB and RF register read/write
-//
+/*  */
+/*  BB and RF register read/write */
+/*  */
 void	rtl8192d_PHY_SetBBReg1Byte(	struct rtw_adapter *	Adapter,
 								u32		RegAddr,
 								u32		BitMask,
@@ -268,9 +268,9 @@ void	rtl8192d_PHY_SetRFReg(	struct rtw_a
 								u32				BitMask,
 								u32				Data	);
 
-//
-// Initialization related function
-//
+/*  */
+/*  Initialization related function */
+/*  */
 /* MAC/BB/RF HAL config */
 extern	int	PHY_MACConfig8192D(	struct rtw_adapter *	Adapter	);
 extern	int	PHY_BBConfig8192D(	struct rtw_adapter *	Adapter	);
@@ -289,15 +289,13 @@ int	rtl8192d_PHY_CheckBBAndRFOK(	struct
 /* Read initi reg value for tx power setting. */
 void	rtl8192d_PHY_GetHWRegOriginalValue(	struct rtw_adapter *		Adapter	);
 
-//
-// RF Power setting
-//
-//extern	bool	PHY_SetRFPowerState(struct rtw_adapter *			Adapter,
-//									RT_RF_POWER_STATE	eRFPowerState);
-
-//
-// BB TX Power R/W
-//
+/*  */
+/*  RF Power setting */
+/*  */
+
+/*  */
+/*  BB TX Power R/W */
+/*  */
 void	PHY_GetTxPowerLevel8192D(	struct rtw_adapter *		Adapter,
 											u32*		powerlevel	);
 void	PHY_SetTxPowerLevel8192D(	struct rtw_adapter *		Adapter,
@@ -305,73 +303,70 @@ void	PHY_SetTxPowerLevel8192D(	struct rt
 bool	PHY_UpdateTxPowerDbm8192D(	struct rtw_adapter *	Adapter,
 											int		powerInDbm	);
 
-//
+/*  */
 void
 PHY_ScanOperationBackup8192D(struct rtw_adapter *	Adapter,
 										u8		Operation	);
 
-//
-// Switch bandwidth for 8192S
-//
-//void	PHY_SetBWModeCallback8192C(	PRT_TIMER		pTimer	);
+/*  */
+/*  Switch bandwidth for 8192S */
+/*  */
 void	PHY_SetBWMode8192D(	struct rtw_adapter *			pAdapter,
 			enum HT_CHANNEL_WIDTH	ChnlWidth,
 									unsigned char	Offset	);
 
-//
-// Set FW CMD IO for 8192S.
-//
-//extern	bool HalSetIO8192C(	struct rtw_adapter *			Adapter,
-//									IO_TYPE				IOType);
-
-//
-// Set A2 entry to fw for 8192S
-//
+/*  */
+/*  Set FW CMD IO for 8192S. */
+/*  */
+
+/*  */
+/*  Set A2 entry to fw for 8192S */
+/*  */
 extern	void FillA2Entry8192C(		struct rtw_adapter *			Adapter,
 										u8				index,
 										u8*				val);
 
 
-//
-// channel switch related funciton
-//
+/*  */
+/*  channel switch related funciton */
+/*  */
 void	PHY_SwChnl8192D(	struct rtw_adapter *		pAdapter,
 									u8			channel	);
-				// Call after initialization
+				/*  Call after initialization */
 void	PHY_SwChnlPhy8192D(	struct rtw_adapter *		pAdapter,
 									u8			channel	);
 
 extern void ChkFwCmdIoDone(	struct rtw_adapter *	Adapter);
 
-//
-// BB/MAC/RF other monitor API
-//
+/*  */
+/*  BB/MAC/RF other monitor API */
+/*  */
 void	PHY_SetMonitorMode8192D(struct rtw_adapter *	pAdapter,
 										bool		bEnableMonitorMode	);
 
 bool	PHY_CheckIsLegalRfPath8192D(struct rtw_adapter *	pAdapter,
 											u32		eRFPath	);
 
-//
-// IQ calibrate
-//
+/*  */
+/*  IQ calibrate */
+/*  */
 void	rtl8192d_PHY_IQCalibrate(	struct rtw_adapter *	pAdapter);
 
 
-//
-// LC calibrate
-//
+/*  */
+/*  LC calibrate */
+/*  */
 void	rtl8192d_PHY_LCCalibrate(struct rtw_adapter *	pAdapter);
 
-//
-// AP calibrate
-//
+/*  */
+/*  AP calibrate */
+/*  */
 void	rtl8192d_PHY_APCalibrate(struct rtw_adapter *	pAdapter, char		delta);
 
 
-//
-// Modify the value of the hw register when beacon interval be changed.
-//
+/*  */
+/*  Modify the value of the hw register when beacon interval be changed. */
+/*  */
 void
 rtl8192d_PHY_SetBeaconHwReg(	struct rtw_adapter *		Adapter,
 					u16			BeaconInterval	);
@@ -453,4 +448,4 @@ void PHY_InitPABias92D(struct rtw_adapte
 
 #define PHY_SetMacReg	PHY_SetBBReg
 
-#endif	// __INC_HAL8192SPHYCFG_H
+#endif	/*  __INC_HAL8192SPHYCFG_H */
--- a/drivers/staging/rtl8192du/include/Hal8192DPhyReg.h
+++ b/drivers/staging/rtl8192du/include/Hal8192DPhyReg.h
@@ -46,24 +46,24 @@
 
 /*--------------------------Define Parameters-------------------------------*/
 
-//============================================================
-//       8192S Regsiter offset definition
-//============================================================
-
-//
-// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
-// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
-// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
-// 3. RF register 0x00-2E
-// 4. Bit Mask for BB/RF register
-// 5. Other defintion for BB/RF R/W
-//
-
-
-//
-// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
-// 1. Page1(0x100)
-//
+/*  */
+/*        8192S Regsiter offset definition */
+/*  */
+
+/*  */
+/*  BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF */
+/*  1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF */
+/*  2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00 */
+/*  3. RF register 0x00-2E */
+/*  4. Bit Mask for BB/RF register */
+/*  5. Other defintion for BB/RF R/W */
+/*  */
+
+
+/*  */
+/*  1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF */
+/*  1. Page1(0x100) */
+/*  */
 #define		rPMAC_Reset					0x100
 #define		rPMAC_TxStart					0x104
 #define		rPMAC_TxLegacySIG				0x108
@@ -92,27 +92,27 @@
 #define		rPMAC_CCKCRxRC32OK			0x188
 #define		rPMAC_TxStatus					0x18c
 
-//
-// 2. Page2(0x200)
-//
-// The following two definition are only used for USB interface.
-#define		RF_BB_CMD_ADDR				0x02c0	// RF/BB read/write command address.
-#define		RF_BB_CMD_DATA				0x02c4	// RF/BB read/write command data.
-
-//
-// 3. Page8(0x800)
-//
-#define		rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+/*  */
+/*  2. Page2(0x200) */
+/*  */
+/*  The following two definition are only used for USB interface. */
+#define		RF_BB_CMD_ADDR				0x02c0	/*  RF/BB read/write command address. */
+#define		RF_BB_CMD_DATA				0x02c4	/*  RF/BB read/write command data. */
+
+/*  */
+/*  3. Page8(0x800) */
+/*  */
+#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC RF BW Setting?? */
 
-#define		rFPGA0_TxInfo				0x804	// Status report??
+#define		rFPGA0_TxInfo				0x804	/*  Status report?? */
 #define		rFPGA0_PSDFunction			0x808
 
-#define		rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+#define		rFPGA0_TxGainStage			0x80c	/*  Set TX PWR init gain? */
 
-#define		rFPGA0_RFTiming1			0x810	// Useless now
+#define		rFPGA0_RFTiming1			0x810	/*  Useless now */
 #define		rFPGA0_RFTiming2			0x814
 
-#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
+#define		rFPGA0_XA_HSSIParameter1		0x820	/*  RF 3 wire register */
 #define		rFPGA0_XA_HSSIParameter2		0x824
 #define		rFPGA0_XB_HSSIParameter1		0x828
 #define		rFPGA0_XB_HSSIParameter2		0x82c
@@ -120,76 +120,76 @@
 #define		rFPGA0_XA_LSSIParameter		0x840
 #define		rFPGA0_XB_LSSIParameter		0x844
 
-#define		rFPGA0_RFWakeUpParameter		0x850	// Useless now
+#define		rFPGA0_RFWakeUpParameter		0x850	/*  Useless now */
 #define		rFPGA0_RFSleepUpParameter		0x854
 
-#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
+#define		rFPGA0_XAB_SwitchControl		0x858	/*  RF Channel switch */
 #define		rFPGA0_XCD_SwitchControl		0x85c
 
-#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
+#define		rFPGA0_XA_RFInterfaceOE		0x860	/*  RF Channel switch */
 #define		rFPGA0_XB_RFInterfaceOE		0x864
 
-#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	/*  RF Interface Software Control */
 #define		rFPGA0_XCD_RFInterfaceSW		0x874
 
-#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define		rFPGA0_XAB_RFParameter		0x878	/*  RF Parameter */
 #define		rFPGA0_XCD_RFParameter		0x87c
 
-#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define		rFPGA0_AnalogParameter1		0x880	/*  Crystal cap setting RF-R/W protection for parameter4?? */
 #define		rFPGA0_AnalogParameter2		0x884
 #define		rFPGA0_AnalogParameter3		0x888
-#define		rFPGA0_AdDaClockEn			0x888	// enable ad/da clock1 for dual-phy
+#define		rFPGA0_AdDaClockEn			0x888	/*  enable ad/da clock1 for dual-phy */
 #define		rFPGA0_AnalogParameter4		0x88c
 
-#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	/*  Tranceiver LSSI Readback */
 #define		rFPGA0_XB_LSSIReadBack		0x8a4
 #define		rFPGA0_XC_LSSIReadBack		0x8a8
 #define		rFPGA0_XD_LSSIReadBack		0x8ac
 
-#define		rFPGA0_PSDReport				0x8b4	// Useless now
-#define		TransceiverA_HSPI_Readback	0x8b8	// Transceiver A HSPI Readback
-#define		TransceiverB_HSPI_Readback	0x8bc	// Transceiver B HSPI Readback
-#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
-#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
-
-//
-// 4. Page9(0x900)
-//
-#define		rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
-
-#define		rFPGA1_TxBlock				0x904	// Useless now
-#define		rFPGA1_DebugSelect			0x908	// Useless now
-#define		rFPGA1_TxInfo				0x90c	// Useless now // Status report??
-
-//
-// 5. PageA(0xA00)
-//
-// Set Control channel to upper or lower. These settings are required only for 40MHz
+#define		rFPGA0_PSDReport				0x8b4	/*  Useless now */
+#define		TransceiverA_HSPI_Readback	0x8b8	/*  Transceiver A HSPI Readback */
+#define		TransceiverB_HSPI_Readback	0x8bc	/*  Transceiver B HSPI Readback */
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/*  Useless now RF Interface Readback Value */
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/*  Useless now */
+
+/*  */
+/*  4. Page9(0x900) */
+/*  */
+#define		rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC RF BW Setting?? */
+
+#define		rFPGA1_TxBlock				0x904	/*  Useless now */
+#define		rFPGA1_DebugSelect			0x908	/*  Useless now */
+#define		rFPGA1_TxInfo				0x90c	/*  Useless now Status report?? */
+
+/*  */
+/*  5. PageA(0xA00) */
+/*  */
+/*  Set Control channel to upper or lower. These settings are required only for 40MHz */
 #define		rCCK0_System				0xa00
 
-#define		rCCK0_AFESetting			0xa04	// Disable init gain now // Select RX path by RSSI
-#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
+#define		rCCK0_AFESetting			0xa04	/*  Disable init gain now Select RX path by RSSI */
+#define		rCCK0_CCA					0xa08	/*  Disable init gain now Init gain */
 
-#define		rCCK0_RxAGC1				0xa0c	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
-#define		rCCK0_RxAGC2				0xa10	//AGC & DAGC
+#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
+#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */
 
 #define		rCCK0_RxHP					0xa14
 
-#define		rCCK0_DSPParameter1		0xa18	//Timing recovery & Channel estimation threshold
-#define		rCCK0_DSPParameter2		0xa1c	//SQ threshold
+#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
+#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */
 
 #define		rCCK0_TxFilter1				0xa20
 #define		rCCK0_TxFilter2				0xa24
-#define		rCCK0_DebugPort			0xa28	//debug port and Tx filter3
-#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
+#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
 #define		rCCK0_TRSSIReport			0xa50
-#define		rCCK0_RxReport				0xa54  //0xa57
-#define		rCCK0_FACounterLower		0xa5c  //0xa5b
-#define		rCCK0_FACounterUpper		0xa58  //0xa5c
-
-//
-// PageB(0xB00)
-//
+#define		rCCK0_RxReport				0xa54  /* 0xa57 */
+#define		rCCK0_FACounterLower		0xa5c  /* 0xa5b */
+#define		rCCK0_FACounterUpper		0xa58  /* 0xa5c */
+
+/*  */
+/*  PageB(0xB00) */
+/*  */
 #define		rPdp_AntA					0xb00
 #define		rPdp_AntA_4				0xb04
 #define		rPdp_AntA_8				0xb08
@@ -235,17 +235,17 @@
 #define		rPm_Rx2_AntB				0xbf4
 #define		rPm_Rx3_AntB				0xbf8
 
-//
-// 6. PageC(0xC00)
-//
+/*  */
+/*  6. PageC(0xC00) */
+/*  */
 #define		rOFDM0_LSTF				0xc00
 
 #define		rOFDM0_TRxPathEnable		0xc04
 #define		rOFDM0_TRMuxPar			0xc08
 #define		rOFDM0_TRSWIsolation		0xc0c
 
-#define		rOFDM0_XARxAFE			0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
-#define		rOFDM0_XARxIQImbalance		0xc14  //RxIQ imblance matrix
+#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
+#define		rOFDM0_XARxIQImbalance		0xc14  /* RxIQ imblance matrix */
 #define		rOFDM0_XBRxAFE				0xc18
 #define		rOFDM0_XBRxIQImbalance		0xc1c
 #define		rOFDM0_XCRxAFE				0xc20
@@ -253,17 +253,17 @@
 #define		rOFDM0_XDRxAFE				0xc28
 #define		rOFDM0_XDRxIQImbalance		0xc2c
 
-#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
-#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
-#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
-#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
-
-#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
-#define		rOFDM0_CFOandDAGC		0xc44  //CFO & DAGC
-#define		rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
-#define		rOFDM0_ECCAThreshold		0xc4c // energy CCA
+#define		rOFDM0_RxDetector1			0xc30  /* PD,BW & SBD	DM tune init gain */
+#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
+#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
+#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */
+
+#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
+#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
+#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
+#define		rOFDM0_ECCAThreshold		0xc4c /*  energy CCA */
 
-#define		rOFDM0_XAAGCCore1			0xc50	// DIG
+#define		rOFDM0_XAAGCCore1			0xc50	/*  DIG */
 #define		rOFDM0_XAAGCCore2			0xc54
 #define		rOFDM0_XBAGCCore1			0xc58
 #define		rOFDM0_XBAGCCore2			0xc5c
@@ -277,7 +277,7 @@
 #define		rOFDM0_AGCRSSITable			0xc78
 #define		rOFDM0_HTSTFAGC				0xc7c
 
-#define		rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define		rOFDM0_XATxIQImbalance		0xc80	/*  TX PWR TRACK and DIG */
 #define		rOFDM0_XATxAFE				0xc84
 #define		rOFDM0_XBTxIQImbalance		0xc88
 #define		rOFDM0_XBTxAFE				0xc8c
@@ -298,13 +298,13 @@
 #define		rOFDM0_FrameSync				0xcf0
 #define		rOFDM0_DFSReport				0xcf4
 
-//
-// 7. PageD(0xD00)
-//
+/*  */
+/*  7. PageD(0xD00) */
+/*  */
 #define		rOFDM1_LSTF					0xd00
 #define		rOFDM1_TRxPathEnable			0xd04
 
-#define		rOFDM1_CFO						0xd08	// No setting now
+#define		rOFDM1_CFO						0xd08	/*  No setting now */
 #define		rOFDM1_CSI1					0xd10
 #define		rOFDM1_SBD						0xd14
 #define		rOFDM1_CSI2					0xd18
@@ -315,11 +315,11 @@
 #define		rOFDM1_PseudoNoiseStateCD		0xd54
 #define		rOFDM1_RxPseudoNoiseWgt		0xd58
 
-#define		rOFDM_PHYCounter1				0xda0  //cca, parity fail
-#define		rOFDM_PHYCounter2				0xda4  //rate illegal, crc8 fail
-#define		rOFDM_PHYCounter3				0xda8  //MCS not support
+#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
+#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
+#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */
 
-#define		rOFDM_ShortCFOAB				0xdac	// No setting now
+#define		rOFDM_ShortCFOAB				0xdac	/*  No setting now */
 #define		rOFDM_ShortCFOCD				0xdb0
 #define		rOFDM_LongCFOAB				0xdb4
 #define		rOFDM_LongCFOCD				0xdb8
@@ -334,9 +334,9 @@
 #define		rOFDM_SIGReport				0xddc
 
 
-//
-// 8. PageE(0xE00)
-//
+/*  */
+/*  8. PageE(0xE00) */
+/*  */
 #define		rTxAGC_A_Rate18_06			0xe00
 #define		rTxAGC_A_Rate54_24			0xe04
 #define		rTxAGC_A_CCK1_Mcs32			0xe08
@@ -403,114 +403,114 @@
 #define		rSleep							0xee0
 #define		rPMPD_ANAEN					0xeec
 
-//
-// 7. RF Register 0x00-0x2E (RF 8256)
-//    RF-0222D 0x00-3F
-//
-//Zebra1
-#define		rZebra1_HSSIEnable				0x0	// Useless now
+/*  */
+/*  7. RF Register 0x00-0x2E (RF 8256) */
+/*     RF-0222D 0x00-3F */
+/*  */
+/* Zebra1 */
+#define		rZebra1_HSSIEnable				0x0	/*  Useless now */
 #define		rZebra1_TRxEnable1				0x1
 #define		rZebra1_TRxEnable2				0x2
 #define		rZebra1_AGC					0x4
 #define		rZebra1_ChargePump			0x5
-#define		rZebra1_Channel				0x7	// RF channel switch
+#define		rZebra1_Channel				0x7	/*  RF channel switch */
 
-//#endif
-#define		rZebra1_TxGain					0x8	// Useless now
+/* endif */
+#define		rZebra1_TxGain					0x8	/*  Useless now */
 #define		rZebra1_TxLPF					0x9
 #define		rZebra1_RxLPF					0xb
 #define		rZebra1_RxHPFCorner			0xc
 
-//Zebra4
-#define		rGlobalCtrl						0	// Useless now
+/* Zebra4 */
+#define		rGlobalCtrl						0	/*  Useless now */
 #define		rRTL8256_TxLPF					19
 #define		rRTL8256_RxLPF					11
 
-//RTL8258
-#define		rRTL8258_TxLPF					0x11	// Useless now
+/* RTL8258 */
+#define		rRTL8258_TxLPF					0x11	/*  Useless now */
 #define		rRTL8258_RxLPF					0x13
 #define		rRTL8258_RSSILPF				0xa
 
-//
-// RL6052 Register definition
-//
-#define		RF_AC						0x00	//
+/*  */
+/*  RL6052 Register definition */
+/*  */
+#define		RF_AC						0x00	/*  */
 
-#define		RF_IQADJ_G1				0x01	//
-#define		RF_IQADJ_G2				0x02	//
+#define		RF_IQADJ_G1				0x01	/*  */
+#define		RF_IQADJ_G2				0x02	/*  */
 #define		RF_BS_PA_APSET_G1_G4		0x03
 #define		RF_BS_PA_APSET_G5_G8		0x04
-#define		RF_POW_TRSW				0x05	//
+#define		RF_POW_TRSW				0x05	/*  */
 
-#define		RF_GAIN_RX					0x06	//
-#define		RF_GAIN_TX					0x07	//
+#define		RF_GAIN_RX					0x06	/*  */
+#define		RF_GAIN_TX					0x07	/*  */
 
-#define		RF_TXM_IDAC				0x08	//
-#define		RF_IPA_G					0x09	//
+#define		RF_TXM_IDAC				0x08	/*  */
+#define		RF_IPA_G					0x09	/*  */
 #define		RF_TXBIAS_G				0x0A
 #define		RF_TXPA_AG					0x0B
-#define		RF_IPA_A					0x0C	//
+#define		RF_IPA_A					0x0C	/*  */
 #define		RF_TXBIAS_A				0x0D
 #define		RF_BS_PA_APSET_G9_G11	0x0E
-#define		RF_BS_IQGEN				0x0F	//
+#define		RF_BS_IQGEN				0x0F	/*  */
 
-#define		RF_MODE1					0x10	//
-#define		RF_MODE2					0x11	//
+#define		RF_MODE1					0x10	/*  */
+#define		RF_MODE2					0x11	/*  */
 
-#define		RF_RX_AGC_HP				0x12	//
-#define		RF_TX_AGC					0x13	//
-#define		RF_BIAS						0x14	//
-#define		RF_IPA						0x15	//
-#define		RF_POW_ABILITY			0x17	//
-#define		RF_MODE_AG				0x18	//
-#define		rRfChannel					0x18	// RF channel and BW switch
-#define		RF_CHNLBW					0x18	// RF channel and BW switch
-#define		RF_TOP						0x19	//
-
-#define		RF_RX_G1					0x1A	//
-#define		RF_RX_G2					0x1B	//
-
-#define		RF_RX_BB2					0x1C	//
-#define		RF_RX_BB1					0x1D	//
-
-#define		RF_RCK1					0x1E	//
-#define		RF_RCK2					0x1F	//
-
-#define		RF_TX_G1					0x20	//
-#define		RF_TX_G2					0x21	//
-#define		RF_TX_G3					0x22	//
-
-#define		RF_TX_BB1					0x23	//
-
-#define		RF_T_METER					0x42	//
-
-#define		RF_SYN_G1					0x25	// RF TX Power control
-#define		RF_SYN_G2					0x26	// RF TX Power control
-#define		RF_SYN_G3					0x27	// RF TX Power control
-#define		RF_SYN_G4					0x28	// RF TX Power control
-#define		RF_SYN_G5					0x29	// RF TX Power control
-#define		RF_SYN_G6					0x2A	// RF TX Power control
-#define		RF_SYN_G7					0x2B	// RF TX Power control
-#define		RF_SYN_G8					0x2C	// RF TX Power control
-
-#define		RF_RCK_OS					0x30	// RF TX PA control
-
-#define		RF_TXPA_G1					0x31	// RF TX PA control
-#define		RF_TXPA_G2					0x32	// RF TX PA control
-#define		RF_TXPA_G3					0x33	// RF TX PA control
+#define		RF_RX_AGC_HP				0x12	/*  */
+#define		RF_TX_AGC					0x13	/*  */
+#define		RF_BIAS						0x14	/*  */
+#define		RF_IPA						0x15	/*  */
+#define		RF_POW_ABILITY			0x17	/*  */
+#define		RF_MODE_AG				0x18	/*  */
+#define		rRfChannel					0x18	/*  RF channel and BW switch */
+#define		RF_CHNLBW					0x18	/*  RF channel and BW switch */
+#define		RF_TOP						0x19	/*  */
+
+#define		RF_RX_G1					0x1A	/*  */
+#define		RF_RX_G2					0x1B	/*  */
+
+#define		RF_RX_BB2					0x1C	/*  */
+#define		RF_RX_BB1					0x1D	/*  */
+
+#define		RF_RCK1					0x1E	/*  */
+#define		RF_RCK2					0x1F	/*  */
+
+#define		RF_TX_G1					0x20	/*  */
+#define		RF_TX_G2					0x21	/*  */
+#define		RF_TX_G3					0x22	/*  */
+
+#define		RF_TX_BB1					0x23	/*  */
+
+#define		RF_T_METER					0x42	/*  */
+
+#define		RF_SYN_G1					0x25	/*  RF TX Power control */
+#define		RF_SYN_G2					0x26	/*  RF TX Power control */
+#define		RF_SYN_G3					0x27	/*  RF TX Power control */
+#define		RF_SYN_G4					0x28	/*  RF TX Power control */
+#define		RF_SYN_G5					0x29	/*  RF TX Power control */
+#define		RF_SYN_G6					0x2A	/*  RF TX Power control */
+#define		RF_SYN_G7					0x2B	/*  RF TX Power control */
+#define		RF_SYN_G8					0x2C	/*  RF TX Power control */
+
+#define		RF_RCK_OS					0x30	/*  RF TX PA control */
+
+#define		RF_TXPA_G1					0x31	/*  RF TX PA control */
+#define		RF_TXPA_G2					0x32	/*  RF TX PA control */
+#define		RF_TXPA_G3					0x33	/*  RF TX PA control */
 #define		RF_LOBF_9					0x38
-#define		RF_RXRF_A3					0x3C	//
+#define		RF_RXRF_A3					0x3C	/*  */
 #define		RF_TRSW					0x3F
 
 #define		RF_TXRF_A2					0x41
 #define		RF_TXPA_G4					0x46
 #define		RF_TXPA_A4					0x4B
 
-//
-//Bit Mask
-//
-// 1. Page1(0x100)
-#define		bBBResetB						0x100	// Useless now?
+/*  */
+/* Bit Mask */
+/*  */
+/*  1. Page1(0x100) */
+#define		bBBResetB						0x100	/*  Useless now? */
 #define		bGlobalResetB					0x200
 #define		bOFDMTxStart					0x4
 #define		bCCKTxStart						0x8
@@ -557,36 +557,36 @@
 
 #define			IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
 
-// 2. Page8(0x800)
-#define		bRFMOD							0x1	// Reg 0x800 rFPGA0_RFMOD
+/*  2. Page8(0x800) */
+#define		bRFMOD							0x1	/*  Reg 0x800 rFPGA0_RFMOD */
 #define		bJapanMode						0x2
 #define		bCCKTxSC						0x30
 #define		bCCKEn							0x1000000
 #define		bOFDMEn						0x2000000
 
-#define		bOFDMRxADCPhase				0x10000	// Useless now
+#define		bOFDMRxADCPhase				0x10000	/*  Useless now */
 #define		bOFDMTxDACPhase				0x40000
 #define		bXATxAGC					0x3f
 
 #define		bAntennaSelect				0x0300
 
-#define		bXBTxAGC					0xf00	// Reg 80c rFPGA0_TxGainStage
+#define		bXBTxAGC					0xf00	/*  Reg 80c rFPGA0_TxGainStage */
 #define		bXCTxAGC					0xf000
 #define		bXDTxAGC					0xf0000
 
-#define		bPAStart					0xf0000000	// Useless now
+#define		bPAStart					0xf0000000	/*  Useless now */
 #define		bTRStart					0x00f00000
 #define		bRFStart					0x0000f000
 #define		bBBStart					0x000000f0
 #define		bBBCCKStart				0x0000000f
-#define		bPAEnd						0xf          //Reg0x814
+#define		bPAEnd						0xf          /* Reg0x814 */
 #define		bTREnd						0x0f000000
 #define		bRFEnd						0x000f0000
-#define		bCCAMask					0x000000f0   //T2R
+#define		bCCAMask					0x000000f0   /* T2R */
 #define		bR2RCCAMask				0x00000f00
 #define		bHSSI_R2TDelay				0xf8000000
 #define		bHSSI_T2RDelay				0xf80000
-#define		bContTxHSSI				0x400     //chane gain at continue Tx
+#define		bContTxHSSI				0x400     /* chane gain at continue Tx */
 #define		bIGFromCCK				0x200
 #define		bAGCAddress				0x3f
 #define		bRxHPTx						0x7000
@@ -595,11 +595,11 @@
 #define		bAGCTxCode				0xc00000
 #define		bAGCRxCode				0x300000
 
-#define		b3WireDataLength			0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
+#define		b3WireDataLength			0x800	/*  Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
 #define		b3WireAddressLength			0x400
 
-#define		b3WireRFPowerDown			0x1	// Useless now
-//#define bHWSISelect				0x8
+#define		b3WireRFPowerDown			0x1	/*  Useless now */
+/* define bHWSISelect				0x8 */
 #define		b5GPAPEPolarity				0x40000000
 #define		b2GPAPEPolarity				0x80000000
 #define		bRFSW_TxDefaultAnt			0x3
@@ -612,9 +612,9 @@
 #define		bRFSI_3WireRW				0x8
 #define		bRFSI_3Wire					0xf
 
-#define		bRFSI_RFENV				0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
+#define		bRFSI_RFENV				0x10	/*  Reg 0x870 rFPGA0_XAB_RFInterfaceSW */
 
-#define		bRFSI_TRSW				0x20	// Useless now
+#define		bRFSI_TRSW				0x20	/*  Useless now */
 #define		bRFSI_TRSWB				0x40
 #define		bRFSI_ANTSW				0x100
 #define		bRFSI_ANTSWB				0x200
@@ -638,14 +638,14 @@
 #define		bLSIG_Parity					0x20
 #define		bCCKRxPhase				0x4
 
-#define		bLSSIReadAddress			0x7f800000   // T65 RF
+#define		bLSSIReadAddress			0x7f800000   /*  T65 RF */
 
-#define		bLSSIReadEdge				0x80000000   //LSSI "Read" edge signal
+#define		bLSSIReadEdge				0x80000000   /* LSSI "Read" edge signal */
 
-#define		bLSSIReadBackData			0xfffff		// T65 RF
+#define		bLSSIReadBackData			0xfffff		/*  T65 RF */
 
-#define		bLSSIReadOKFlag				0x1000	// Useless now
-#define		bCCKSampleRate				0x8       //0: 44MHz, 1:88MHz
+#define		bLSSIReadOKFlag				0x1000	/*  Useless now */
+#define		bCCKSampleRate				0x8       /* 0: 44MHz, 1:88MHz */
 #define		bRegulator0Standby			0x1
 #define		bRegulatorPLLStandby			0x2
 #define		bRegulator1Standby			0x4
@@ -659,17 +659,17 @@
 #define		bDA6DebugMode				0x20000
 #define		bDA6Swing					0x380000
 
-#define		bADClkPhase				0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
+#define		bADClkPhase				0x4000000	/*  Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */
 
-#define		b80MClkDelay				0x18000000	// Useless
+#define		b80MClkDelay				0x18000000	/*  Useless */
 #define		bAFEWatchDogEnable			0x20000000
 
-#define		bXtalCap01					0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
+#define		bXtalCap01					0xc0000000	/*  Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
 #define		bXtalCap23					0x3
 #define		bXtalCap92x					0x0f000000
 #define			bXtalCap					0x0f000000
 
-#define		bIntDifClkEnable			0x400	// Useless
+#define		bIntDifClkEnable			0x400	/*  Useless */
 #define		bExtSigClkEnable			0x800
 #define		bBandgapMbiasPowerUp		0x10000
 #define		bAD11SHGain				0xc0000
@@ -703,12 +703,12 @@
 #define		bPSDSineToneScale			0x7f000000
 #define		bPSDReport					0xffff
 
-// 3. Page9(0x900)
-#define		bOFDMTxSC				0x30000000	// Useless
+/*  3. Page9(0x900) */
+#define		bOFDMTxSC				0x30000000	/*  Useless */
 #define		bCCKTxOn					0x1
 #define		bOFDMTxOn				0x2
-#define		bDebugPage				0xfff  //reset debug page and also HWord, LWord
-#define		bDebugItem				0xff   //reset debug page and LWord
+#define		bDebugPage				0xfff  /* reset debug page and also HWord, LWord */
+#define		bDebugItem				0xff   /* reset debug page and LWord */
 #define		bAntL					0x10
 #define		bAntNonHT					0x100
 #define		bAntHT1					0x1000
@@ -716,14 +716,14 @@
 #define		bAntHT1S1					0x100000
 #define		bAntNonHTS1				0x1000000
 
-// 4. PageA(0xA00)
-#define		bCCKBBMode				0x3	// Useless
+/*  4. PageA(0xA00) */
+#define		bCCKBBMode				0x3	/*  Useless */
 #define		bCCKTxPowerSaving		0x80
 #define		bCCKRxPowerSaving		0x40
 
-#define		bCCKSideBand			0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+#define		bCCKSideBand			0x10	/*  Reg 0xa00 rCCK0_System 20/40 switch */
 
-#define		bCCKScramble			0x8	// Useless
+#define		bCCKScramble			0x8	/*  Useless */
 #define		bCCKAntDiversity		0x8000
 #define		bCCKCarrierRecovery		0x4000
 #define		bCCKTxRate				0x3000
@@ -739,7 +739,7 @@
 #define		bCCKBistMode			0x80000000
 #define		bCCKCCAMask			0x40000000
 #define		bCCKTxDACPhase		0x4
-#define		bCCKRxADCPhase		0x20000000   //r_rx_clk
+#define		bCCKRxADCPhase		0x20000000   /* r_rx_clk */
 #define		bCCKr_cp_mode0		0x0100
 #define		bCCKTxDCOffset			0xf0
 #define		bCCKRxDCOffset			0xf
@@ -753,12 +753,11 @@
 #define		bCCKRxIG				0x7f00
 #define		bCCKLNAPolarity			0x800000
 #define		bCCKRx1stGain			0x7f0000
-#define		bCCKRFExtend			0x20000000 //CCK Rx Iinital gain polarity
+#define		bCCKRFExtend			0x20000000 /* CCK Rx Iinital gain polarity */
 #define		bCCKRxAGCSatLevel		0x1f000000
 #define		bCCKRxAGCSatCount		0xe0
-#define		bCCKRxRFSettle			0x1f       //AGCsamp_dly
+#define		bCCKRxRFSettle			0x1f       /* AGCsamp_dly */
 #define		bCCKFixedRxAGC			0x8000
-//#define bCCKRxAGCFormat			0x4000   //remove to HSSI register 0x824
 #define		bCCKAntennaPolarity		0x2000
 #define		bCCKTxFilterType		0x0c00
 #define		bCCKRxAGCReportType	0x0300
@@ -797,8 +796,8 @@
 #define		bCCKDefaultRxPath		0xc000000
 #define		bCCKOptionRxPath		0x3000000
 
-// 5. PageC(0xC00)
-#define		bNumOfSTF				0x3	// Useless
+/*  5. PageC(0xC00) */
+#define		bNumOfSTF				0x3	/*  Useless */
 #define		bShift_L					0xc0
 #define		bGI_TH					0xc
 #define		bRxPathA				0x1
@@ -899,8 +898,8 @@
 #define		bRxHP_BBP1				0x7000
 #define		bRxHP_BBP2				0x70000
 #define		bRxHP_BBP3				0x700000
-#define		bRSSI_H					0x7f0000     //the threshold for high power
-#define		bRSSI_Gen				0x7f000000   //the threshold for ant diversity
+#define		bRSSI_H					0x7f0000     /* the threshold for high power */
+#define		bRSSI_Gen				0x7f000000   /* the threshold for ant diversity */
 #define		bRxSettle_TRSW			0x7
 #define		bRxSettle_LNA			0x38
 #define		bRxSettle_RSSI			0x1c0
@@ -934,7 +933,7 @@
 #define		bRxPD_Delay_TH1		0x38
 #define		bRxPD_Delay_TH2		0x1c0
 #define		bRxPD_DC_COUNT_MAX	0x600
-//#define bRxMF_Hold               0x3800
+/* define bRxMF_Hold               0x3800 */
 #define		bRxPD_Delay_TH			0x8000
 #define		bRxProcess_Delay		0xf0000
 #define		bRxSearchrange_GI2_Early	0x700000
@@ -955,8 +954,8 @@
 #define		bTRSWIsolation_D		0x7f000000
 #define		bExtLNAGain				0x7c00
 
-// 6. PageE(0xE00)
-#define		bSTBCEn				0x4	// Useless
+/*  6. PageE(0xE00) */
+#define		bSTBCEn				0x4	/*  Useless */
 #define		bAntennaMapping		0x10
 #define		bNss					0x20
 #define		bCFOAntSumD			0x200
@@ -965,12 +964,12 @@
 #define		bOFDMContinueTx		0x10000000
 #define		bOFDMSingleCarrier		0x20000000
 #define		bOFDMSingleTone		0x40000000
-//#define bRxPath1                 0x01
-//#define bRxPath2                 0x02
-//#define bRxPath3                 0x04
-//#define bRxPath4                 0x08
-//#define bTxPath1                 0x10
-//#define bTxPath2                 0x20
+/* define bRxPath1                 0x01 */
+/* define bRxPath2                 0x02 */
+/* define bRxPath3                 0x04 */
+/* define bRxPath4                 0x08 */
+/* define bTxPath1                 0x10 */
+/* define bTxPath2                 0x20 */
 #define		bHTDetect			0x100
 #define		bCFOEn				0x10000
 #define		bCFOValue			0xfff00000
@@ -983,8 +982,8 @@
 #define		bCounter_MCSNoSupport	0xffff
 #define		bCounter_FastSync	0xffff
 #define		bShortCFO			0xfff
-#define		bShortCFOTLength	12   //total
-#define		bShortCFOFLength	11   //fraction
+#define		bShortCFOTLength	12   /* total */
+#define		bShortCFOFLength	11   /* fraction */
 #define		bLongCFO			0x7ff
 #define		bLongCFOTLength	11
 #define		bLongCFOFLength	11
@@ -1019,7 +1018,7 @@
 #define		bPWDB				0xff00
 #define		bSGIEN				0x10000
 
-#define		bSFactorQAM1		0xf	// Useless
+#define		bSFactorQAM1		0xf	/*  Useless */
 #define		bSFactorQAM2		0xf0
 #define		bSFactorQAM3		0xf00
 #define		bSFactorQAM4		0xf000
@@ -1030,7 +1029,7 @@
 #define		bSFactorQAM9		0xf0000000
 #define		bCSIScheme			0x100000
 
-#define		bNoiseLvlTopSet		0x3	// Useless
+#define		bNoiseLvlTopSet		0x3	/*  Useless */
 #define		bChSmooth			0x4
 #define		bChSmoothCfg1		0x38
 #define		bChSmoothCfg2		0x1c0
@@ -1039,7 +1038,7 @@
 #define		bMRCMode			0x800000
 #define		bTHEVMCfg			0x7000000
 
-#define		bLoopFitType		0x1	// Useless
+#define		bLoopFitType		0x1	/*  Useless */
 #define		bUpdCFO			0x40
 #define		bUpdCFOOffData		0x80
 #define		bAdvUpdCFO			0x100
@@ -1055,8 +1054,8 @@
 #define		bUChCfg				0x7000000
 #define		bUpdEqz			0x8000000
 
-//Rx Pseduo noise
-#define		bRxPesudoNoiseOn		0x20000000	// Useless
+/* Rx Pseduo noise */
+#define		bRxPesudoNoiseOn		0x20000000	/*  Useless */
 #define		bRxPesudoNoise_A		0xff
 #define		bRxPesudoNoise_B		0xff00
 #define		bRxPesudoNoise_C		0xff0000
@@ -1066,9 +1065,9 @@
 #define		bPesudoNoiseState_C	0xffff
 #define		bPesudoNoiseState_D	0xffff0000
 
-//7. RF Register
-//Zebra1
-#define		bZebra1_HSSIEnable		0x8		// Useless
+/* 7. RF Register */
+/* Zebra1 */
+#define		bZebra1_HSSIEnable		0x8		/*  Useless */
 #define		bZebra1_TRxControl		0xc00
 #define		bZebra1_TRxGainSetting	0x07f
 #define		bZebra1_RxCorner		0xc00
@@ -1078,24 +1077,24 @@
 #define		bZebra1_TxLPFBW		0x400
 #define		bZebra1_RxLPFBW		0x600
 
-//Zebra4
-#define		bRTL8256RegModeCtrl1	0x100	// Useless
+/* Zebra4 */
+#define		bRTL8256RegModeCtrl1	0x100	/*  Useless */
 #define		bRTL8256RegModeCtrl0	0x40
 #define		bRTL8256_TxLPFBW		0x18
 #define		bRTL8256_RxLPFBW		0x600
 
-//RTL8258
-#define		bRTL8258_TxLPFBW		0xc	// Useless
+/* RTL8258 */
+#define		bRTL8258_TxLPFBW		0xc	/*  Useless */
 #define		bRTL8258_RxLPFBW		0xc00
 #define		bRTL8258_RSSILPFBW	0xc0
 
 
-//
-// Other Definition
-//
+/*  */
+/*  Other Definition */
+/*  */
 
-//byte endable for sb_write
-#define		bByte0				0x1	// Useless
+/* byte endable for sb_write */
+#define		bByte0				0x1	/*  Useless */
 #define		bByte1				0x2
 #define		bByte2				0x4
 #define		bByte3				0x8
@@ -1103,8 +1102,8 @@
 #define		bWord1				0xc
 #define		bDWord				0xf
 
-//for PutRegsetting & GetRegSetting BitMask
-#define		bMaskByte0			0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+/* for PutRegsetting & GetRegSetting BitMask */
+#define		bMaskByte0			0xff	/*  Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
 #define		bMaskByte1			0xff00
 #define		maskbyte2			0xff0000
 #define		bMaskByte3			0xff000000
@@ -1116,50 +1115,47 @@
 #define		bMaskOFDM_D		0xffc00000
 #define		bMaskCCK			0x3f3f3f3f
 
-//for PutRFRegsetting & GetRFRegSetting BitMask
-//#define		bMask12Bits			0xfffff	// RF Reg mask bits
-//#define		bMask20Bits			0xfffff	// RF Reg mask bits T65 RF
+/* for PutRFRegsetting & GetRFRegSetting BitMask */
 #define			bRFRegOffsetMask		0xfffff
-//#define		bRFRegOffsetMask		0xfff
 
-//MAC0 will wirte PHY1
+/* MAC0 will wirte PHY1 */
 #define	MAC0_ACCESS_PHY1	0x4000
-//MAC1 will wirte PHY0
+/* MAC1 will wirte PHY0 */
 #define	MAC1_ACCESS_PHY0	0x2000
 
-#define		bEnable			0x1	// Useless
+#define		bEnable			0x1	/*  Useless */
 #define		bDisable		0x0
 
-#define		LeftAntenna		0x0	// Useless
+#define		LeftAntenna		0x0	/*  Useless */
 #define		RightAntenna	0x1
 
-#define		tCheckTxStatus		500   //500ms // Useless
-#define		tUpdateRxCounter	100   //100ms
+#define		tCheckTxStatus		500   /* 500ms Useless */
+#define		tUpdateRxCounter	100   /* 100ms */
 
-#define		rateCCK		0	// Useless
+#define		rateCCK		0	/*  Useless */
 #define		rateOFDM	1
 #define		rateHT		2
 
-//define Register-End
-#define		bPMAC_End			0x1ff	// Useless
+/* define Register-End */
+#define		bPMAC_End			0x1ff	/*  Useless */
 #define		bFPGAPHY0_End		0x8ff
 #define		bFPGAPHY1_End		0x9ff
 #define		bCCKPHY0_End		0xaff
 #define		bOFDMPHY0_End		0xcff
 #define		bOFDMPHY1_End		0xdff
 
-//define max debug item in each debug page
-//#define bMaxItem_FPGA_PHY0        0x9
-//#define bMaxItem_FPGA_PHY1        0x3
-//#define bMaxItem_PHY_11B          0x16
-//#define bMaxItem_OFDM_PHY0        0x29
-//#define bMaxItem_OFDM_PHY1        0x0
+/* define max debug item in each debug page */
+/* define bMaxItem_FPGA_PHY0        0x9 */
+/* define bMaxItem_FPGA_PHY1        0x3 */
+/* define bMaxItem_PHY_11B          0x16 */
+/* define bMaxItem_OFDM_PHY0        0x29 */
+/* define bMaxItem_OFDM_PHY1        0x0 */
 
-#define		bPMACControl		0x0		// Useless
+#define		bPMACControl		0x0		/*  Useless */
 #define		bWMACControl		0x1
 #define		bWNICControl		0x2
 
-#define		PathA			0x0	// Useless
+#define		PathA			0x0	/*  Useless */
 #define		PathB			0x1
 #define		PathC			0x2
 #define		PathD			0x3
@@ -1167,4 +1163,4 @@
 /*--------------------------Define Parameters-------------------------------*/
 
 
-#endif	//__INC_HAL8192SPHYREG_H
+#endif	/* __INC_HAL8192SPHYREG_H */
--- a/drivers/staging/rtl8192du/include/Hal8192DUHWImg.h
+++ b/drivers/staging/rtl8192du/include/Hal8192DUHWImg.h
@@ -63,4 +63,4 @@ extern const u32 Rtl8192DUAGCTAB_2TArray
 #define Rtl8192DUAGCTAB_1TArrayLength 1
 extern const u32 Rtl8192DUAGCTAB_1TArray[Rtl8192DUAGCTAB_1TArrayLength];
 
-#endif //__INC_HAL8192CU_FW_IMG_H
+#endif /* __INC_HAL8192CU_FW_IMG_H */
--- a/drivers/staging/rtl8192du/include/Hal8192DUHWImg_wowlan.h
+++ b/drivers/staging/rtl8192du/include/Hal8192DUHWImg_wowlan.h
@@ -26,4 +26,4 @@
 #define DUWWImgArrayLength 24818
 extern u8 Rtl8192DUFwWWImgArray[DUWWImgArrayLength];
 
-#endif //__INC_HAL8192DU_FW_IMG_WOWLAN_H
+#endif /* __INC_HAL8192DU_FW_IMG_WOWLAN_H */
--- a/drivers/staging/rtl8192du/include/autoconf.h
+++ b/drivers/staging/rtl8192du/include/autoconf.h
@@ -26,7 +26,7 @@
 #define DRV_NAME "rtl8192du"
 #define DRIVERVERSION	"v4.2.1_7122.20130408"
 
-//#define CONFIG_IOCTL_CFG80211 1
+/* define CONFIG_IOCTL_CFG80211 1 */
 
 #ifdef CONFIG_IOCTL_CFG80211
 	#define CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
@@ -36,16 +36,15 @@
 /*
  * Internal  General Config
  */
-//#define CONFIG_PWRCTRL	1
-//#define CONFIG_H2CLBK	1
+/* define CONFIG_PWRCTRL	1 */
+/* define CONFIG_H2CLBK	1 */
 
 #define CONFIG_EMBEDDED_FWIMG	1
-//#define CONFIG_FILE_FWIMG
+/* define CONFIG_FILE_FWIMG */
 
 #ifdef CONFIG_WAKE_ON_WLAN
 #define CONFIG_WOWLAN 1
-#endif //CONFIG_WAKE_ON_WLAN
-//#define CONFIG_WOWLAN_MANUAL		/* manually use ioctl to enter suspend */
+#endif /* CONFIG_WAKE_ON_WLAN */
 #define CONFIG_R871X_TEST	1
 
 #define CONFIG_XMIT_ACK
@@ -71,73 +70,51 @@
 	#define CONFIG_FIND_BEST_CHANNEL	1
 #endif
 
-//	Added by Albert 20110314
+/* 	Added by Albert 20110314 */
 #define CONFIG_P2P	1
 #ifdef CONFIG_P2P
-	//Added by Albert 20110812
-	//The CONFIG_WFD is for supporting the Wi-Fi display
-	//#define CONFIG_WFD	1
+	/* Added by Albert 20110812 */
+	/* The CONFIG_WFD is for supporting the Wi-Fi display */
+	/* define CONFIG_WFD	1 */
 
 	#ifndef CONFIG_WIFI_TEST
 		#define CONFIG_P2P_REMOVE_GROUP_INFO
 	#endif
-	//#define CONFIG_DBG_P2P
-
-	//#define CONFIG_P2P_PS
-	//#define CONFIG_P2P_IPS
-#endif
-
-//	Added by Kurt 20110511
-//#define CONFIG_TDLS 1
-#ifdef CONFIG_TDLS
-//	#ifndef CONFIG_WFD
-//		#define CONFIG_WFD	1
-//	#endif
-//	#define CONFIG_TDLS_AUTOSETUP			1
-//	#define CONFIG_TDLS_AUTOCHECKALIVE		1
 #endif
 
-//#define CONFIG_DUALMAC_CONCURRENT	1 //for 92D dual mac concurrent ,DMSP DMDP SMSP switch
-
-#define CONFIG_SKB_COPY	1//for amsdu
+#define CONFIG_SKB_COPY	1/* for amsdu */
 
 #define CONFIG_DFS	1
 
 #define CONFIG_LED
 #ifdef CONFIG_LED
 	#define CONFIG_SW_LED
-#endif //CONFIG_LED
+#endif /* CONFIG_LED */
 
 
 #define CONFIG_LAYER2_ROAMING
 #define CONFIG_LAYER2_ROAMING_RESUME
-//#define CONFIG_SET_SCAN_DENY_TIMER
+/* define CONFIG_SET_SCAN_DENY_TIMER */
 #define CONFIG_NEW_SIGNAL_STAT_PROCESS
-//#define CONFIG_SIGNAL_DISPLAY_DBM //display RX signal with dbm
 #define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable,*/
 
-#define CONFIG_BR_EXT	1	// Enable NAT2.5 support for STA mode interface with a L2 Bridge
+#define CONFIG_BR_EXT	1	/*  Enable NAT2.5 support for STA mode interface with a L2 Bridge */
 #ifdef CONFIG_BR_EXT
 #define CONFIG_BR_EXT_BRNAME	"br0"
-#endif	// CONFIG_BR_EXT
+#endif	/*  CONFIG_BR_EXT */
 
-//#define CONFIG_CHECK_AC_LIFETIME	1	// Check packet lifetime of 4 ACs.
-//#define CONFIG_DISABLE_MCS13TO15	1	// Disable MSC13-15 rates for more stable TX throughput with some 5G APs
 
 #define CONFIG_CONCURRENT_MODE 1
 #ifdef CONFIG_CONCURRENT_MODE
-	#define CONFIG_TSF_RESET_OFFLOAD 1			// For 2 PORT TSF SYNC.
-	//#define CONFIG_HWPORT_SWAP				//Port0->Sec , Port1 -> Pri
-	//#define CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-	//#define CONFIG_MULTI_VIR_IFACES //besides primary&secondary interfaces, extend to support more interfaces
-#endif	// CONFIG_CONCURRENT_MODE
+	#define CONFIG_TSF_RESET_OFFLOAD 1			/*  For 2 PORT TSF SYNC. */
+#endif	/*  CONFIG_CONCURRENT_MODE */
 
 #define CONFIG_80211D
 
 /*
  * Interface  Related Config
  */
-//#define CONFIG_USB_INTERRUPT_IN_PIPE	1
+/* define CONFIG_USB_INTERRUPT_IN_PIPE	1 */
 
 #ifndef CONFIG_MINIMAL_MEMORY_USAGE
 	#define CONFIG_USB_TX_AGGREGATION	1
@@ -145,16 +122,12 @@
 #endif
 
 #define CONFIG_PREALLOC_RECV_SKB	1
-//#define CONFIG_REDUCE_USB_TX_INT	1	// Trade-off: Improve performance, but may cause TX URBs blocked by USB Host/Bus driver on few platforms.
-//#define CONFIG_EASY_REPLACEMENT	1
 
 
 
 /*
  * CONFIG_USE_USB_BUFFER_ALLOC_XX uses Linux USB Buffer alloc API and is for Linux platform only now!
  */
-//#define CONFIG_USE_USB_BUFFER_ALLOC_TX 1	// Trade-off: For TX path, improve stability on some platforms, but may cause performance degrade on other platforms.
-//#define CONFIG_USE_USB_BUFFER_ALLOC_RX 1	// For RX path
 #ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
 #undef CONFIG_PREALLOC_RECV_SKB
 #endif
@@ -163,12 +136,12 @@
  * USB VENDOR REQ BUFFER ALLOCATION METHOD
  * if not set we'll use function local variable (stack memory)
  */
-//#define CONFIG_USB_VENDOR_REQ_BUFFER_DYNAMIC_ALLOCATE
+/* define CONFIG_USB_VENDOR_REQ_BUFFER_DYNAMIC_ALLOCATE */
 #define CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
 
 #define CONFIG_USB_VENDOR_REQ_MUTEX
 
-//#define CONFIG_USB_SUPPORT_ASYNC_VDN_REQ 1
+/* define CONFIG_USB_SUPPORT_ASYNC_VDN_REQ 1 */
 
 
 /*
@@ -183,7 +156,7 @@
 
 #define ENABLE_USB_DROP_INCORRECT_OUT	0
 
-#define RTL8192CU_ASIC_VERIFICATION	0	// For ASIC verification.
+#define RTL8192CU_ASIC_VERIFICATION	0	/*  For ASIC verification. */
 
 #define RTL8192CU_ADHOC_WORKAROUND_SETTING 1
 
@@ -193,7 +166,7 @@
 
 #define ANTENNA_SELECTION_STATIC_SETTING 0
 
-#define TX_POWER_FOR_5G_BAND				1	//For 5G band TX Power
+#define TX_POWER_FOR_5G_BAND				1	/* For 5G band TX Power */
 
 #define RTL8192D_EASY_SMART_CONCURRENT	0
 
@@ -208,7 +181,7 @@
 /*
  * Debug  Related Config
  */
-//#define CONFIG_DEBUG_RTL871X
+/* define CONFIG_DEBUG_RTL871X */
 
 #define DBG 0
 
--- a/drivers/staging/rtl8192du/include/basic_types.h
+++ b/drivers/staging/rtl8192du/include/basic_types.h
@@ -36,8 +36,8 @@
 #define SIZE_PTR __kernel_size_t
 #define SSIZE_PTR __kernel_ssize_t
 
-//port from fw by thomas
-// TODO: Belows are Sync from SD7-Driver. It is necessary to check correctness
+/* port from fw by thomas */
+/*  TODO: Belows are Sync from SD7-Driver. It is necessary to check correctness */
 
 /*
  *	Call endian free function when
@@ -46,57 +46,57 @@
  *		3. After read integer from IO.
 */
 
-//
-// Byte Swapping routine.
-//
+/*  */
+/*  Byte Swapping routine. */
+/*  */
 #define EF1Byte
 #define EF2Byte		le16_to_cpu
 #define EF4Byte	le32_to_cpu
 
-//
-// Read LE format data from memory
-//
+/*  */
+/*  Read LE format data from memory */
+/*  */
 #define ReadEF1Byte(_ptr)		EF1Byte(*((u8 *)(_ptr)))
 #define ReadEF2Byte(_ptr)		EF2Byte(*((u16 *)(_ptr)))
 #define ReadEF4Byte(_ptr)		EF4Byte(*((u32 *)(_ptr)))
 
-//
-// Write LE data to memory
-//
+/*  */
+/*  Write LE data to memory */
+/*  */
 #define WriteEF1Byte(_ptr, _val)	(*((u8 *)(_ptr)))=EF1Byte(_val)
 #define WriteEF2Byte(_ptr, _val)	(*((u16 *)(_ptr)))=EF2Byte(_val)
 #define WriteEF4Byte(_ptr, _val)	(*((u32 *)(_ptr)))=EF4Byte(_val)
 
-//
-//	Example:
-//		BIT_LEN_MASK_32(0) => 0x00000000
-//		BIT_LEN_MASK_32(1) => 0x00000001
-//		BIT_LEN_MASK_32(2) => 0x00000003
-//		BIT_LEN_MASK_32(32) => 0xFFFFFFFF
-//
+/*  */
+/* 	Example: */
+/* 		BIT_LEN_MASK_32(0) => 0x00000000 */
+/* 		BIT_LEN_MASK_32(1) => 0x00000001 */
+/* 		BIT_LEN_MASK_32(2) => 0x00000003 */
+/* 		BIT_LEN_MASK_32(32) => 0xFFFFFFFF */
+/*  */
 #define BIT_LEN_MASK_32(__BitLen) \
 	(0xFFFFFFFF >> (32 - (__BitLen)))
-//
-//	Example:
-//		BIT_OFFSET_LEN_MASK_32(0, 2) => 0x00000003
-//		BIT_OFFSET_LEN_MASK_32(16, 2) => 0x00030000
-//
+/*  */
+/* 	Example: */
+/* 		BIT_OFFSET_LEN_MASK_32(0, 2) => 0x00000003 */
+/* 		BIT_OFFSET_LEN_MASK_32(16, 2) => 0x00030000 */
+/*  */
 #define BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen) \
 	(BIT_LEN_MASK_32(__BitLen) << (__BitOffset))
 
-//
-//	Description:
-//		Return 4-byte value in host byte ordering from
-//		4-byte pointer in litten-endian system.
-//
+/*  */
+/* 	Description: */
+/* 		Return 4-byte value in host byte ordering from */
+/* 		4-byte pointer in litten-endian system. */
+/*  */
 #define LE_P4BYTE_TO_HOST_4BYTE(__pStart) \
 	(EF4Byte(*((u32 *)(__pStart))))
 
-//
-//	Description:
-//		Translate subfield (continuous bits in little-endian) of 4-byte value in litten byte to
-//		4-byte value in host byte ordering.
-//
+/*  */
+/* 	Description: */
+/* 		Translate subfield (continuous bits in little-endian) of 4-byte value in litten byte to */
+/* 		4-byte value in host byte ordering. */
+/*  */
 #define LE_BITS_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
 	(\
 		(LE_P4BYTE_TO_HOST_4BYTE(__pStart) >> (__BitOffset)) \
@@ -104,11 +104,11 @@
 		BIT_LEN_MASK_32(__BitLen) \
 	)
 
-//
-//	Description:
-//		Mask subfield (continuous bits in little-endian) of 4-byte value in litten byte oredering
-//		and return the result in 4-byte value in host byte ordering.
-//
+/*  */
+/* 	Description: */
+/* 		Mask subfield (continuous bits in little-endian) of 4-byte value in litten byte oredering */
+/* 		and return the result in 4-byte value in host byte ordering. */
+/*  */
 #define LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
 	(\
 		LE_P4BYTE_TO_HOST_4BYTE(__pStart) \
@@ -116,10 +116,10 @@
 		(~BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen)) \
 	)
 
-//
-//	Description:
-//		Set subfield of little-endian 4-byte value to specified value.
-//
+/*  */
+/* 	Description: */
+/* 		Set subfield of little-endian 4-byte value to specified value. */
+/*  */
 #define SET_BITS_TO_LE_4BYTE(__pStart, __BitOffset, __BitLen, __Value) \
 	*((u32 *)(__pStart)) = \
 		EF4Byte(\
@@ -191,7 +191,7 @@
 			((((u8)__Value) & BIT_LEN_MASK_8(__BitLen)) << (__BitOffset)) \
 		);
 
-// Get the N-bytes aligment offset from the current length
+/*  Get the N-bytes aligment offset from the current length */
 #define N_BYTE_ALIGMENT(__Value, __Aligment) ((__Aligment == 1) ? (__Value) : (((__Value + __Aligment - 1) / __Aligment) * __Aligment))
 
-#endif //__BASIC_TYPES_H__
+#endif /* __BASIC_TYPES_H__ */
--- a/drivers/staging/rtl8192du/include/circ_buf.h
+++ b/drivers/staging/rtl8192du/include/circ_buf.h
@@ -24,4 +24,4 @@
 
 #define CIRC_SPACE(head,tail,size) CIRC_CNT((tail),((head)+1),(size))
 
-#endif //_CIRC_BUF_H_
+#endif /* _CIRC_BUF_H_ */
--- a/drivers/staging/rtl8192du/include/drv_conf.h
+++ b/drivers/staging/rtl8192du/include/drv_conf.h
@@ -23,12 +23,12 @@
 
 
 #ifdef CONFIG_ANDROID
-//Some Android build will restart the UI while non-printable ascii is passed
-//between java and c/c++ layer (JNI). We force CONFIG_VALIDATE_SSID
-//for Android here. If you are sure there is no risk on your system about this,
-//mask this macro define to support non-printable ascii ssid.
-//#define CONFIG_VALIDATE_SSID
-//Android expect dbm as the rx signal strength unit
+/* Some Android build will restart the UI while non-printable ascii is passed */
+/* between java and c/c++ layer (JNI). We force CONFIG_VALIDATE_SSID */
+/* for Android here. If you are sure there is no risk on your system about this, */
+/* mask this macro define to support non-printable ascii ssid. */
+/* define CONFIG_VALIDATE_SSID */
+/* Android expect dbm as the rx signal strength unit */
 #define CONFIG_SIGNAL_DISPLAY_DBM
 #endif
 
@@ -42,14 +42,14 @@
 	#undef CONFIG_RESUME_IN_WORKQUEUE
 #endif
 
-#ifdef CONFIG_RESUME_IN_WORKQUEUE //this can be removed, because there is no case for this...
+#ifdef CONFIG_RESUME_IN_WORKQUEUE /* this can be removed, because there is no case for this... */
 	#if !defined(CONFIG_WAKELOCK) && !defined(CONFIG_ANDROID_POWER)
 	#error "enable CONFIG_RESUME_IN_WORKQUEUE without CONFIG_WAKELOCK or CONFIG_ANDROID_POWER will suffer from the danger of wifi's unfunctionality..."
 	#error "If you still want to enable CONFIG_RESUME_IN_WORKQUEUE in this case, mask this preprossor checking and GOOD LUCK..."
 	#endif
 #endif
 
-//About USB VENDOR REQ
+/* About USB VENDOR REQ */
 #if defined(CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC) && !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
 	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC automatically"
 	#define CONFIG_USB_VENDOR_REQ_MUTEX
@@ -59,7 +59,4 @@
 	#define CONFIG_USB_VENDOR_REQ_MUTEX
 #endif
 
-
-//#include <rtl871x_byteorder.h>
-
-#endif // __DRV_CONF_H__
+#endif /*  __DRV_CONF_H__ */
--- a/drivers/staging/rtl8192du/include/drv_types.h
+++ b/drivers/staging/rtl8192du/include/drv_types.h
@@ -68,11 +68,11 @@ enum {
 
 #ifdef CONFIG_BR_EXT
 #include <rtw_br_ext.h>
-#endif	// CONFIG_BR_EXT
+#endif	/*  CONFIG_BR_EXT */
 
 #ifdef CONFIG_IOCTL_CFG80211
 	#include "ioctl_cfg80211.h"
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 #define SPEC_DEV_ID_NONE BIT(0)
 #define SPEC_DEV_ID_DISABLE_HT BIT(1)
@@ -94,14 +94,14 @@ struct registry_priv {
 	u8	lbkmode;
 	u8	hci;
 	struct ndis_802_11_ssid	ssid;
-	u8	network_mode;	//infra, ad-hoc, auto
-	u8	channel;//ad-hoc support requirement
-	u8	wireless_mode;//A, B, G, auto
-	u8	scan_mode;//active, passive
+	u8	network_mode;	/* infra, ad-hoc, auto */
+	u8	channel;/* ad-hoc support requirement */
+	u8	wireless_mode;/* A, B, G, auto */
+	u8	scan_mode;/* active, passive */
 	u8	radio_enable;
-	u8	preamble;//long, short, auto
-	u8	vrtl_carrier_sense;//Enable, Disable, Auto
-	u8	vcs_type;//RTS/CTS, CTS-to-self
+	u8	preamble;/* long, short, auto */
+	u8	vrtl_carrier_sense;/* Enable, Disable, Auto */
+	u8	vcs_type;/* RTS/CTS, CTS-to-self */
 	u16	rts_thresh;
 	u16	frag_thresh;
 	u8	adhoc_tx_pwr;
@@ -118,7 +118,7 @@ struct registry_priv {
 	u8	software_decrypt;
 
 	u8	acm_method;
-	  //UAPSD
+	  /* UAPSD */
 	u8	wmm_enable;
 	u8	uapsd_enable;
 	u8	uapsd_max_sp;
@@ -132,16 +132,16 @@ struct registry_priv {
 #ifdef CONFIG_80211N_HT
 	u8	ht_enable;
 	u8	cbw40_enable;
-	u8	ampdu_enable;//for tx
+	u8	ampdu_enable;/* for tx */
 	u8	rx_stbc;
-	u8	ampdu_amsdu;//A-MPDU Supports A-MSDU is permitted
+	u8	ampdu_amsdu;/* A-MPDU Supports A-MSDU is permitted */
 #endif
 	u8	lowrate_two_xmit;
 
 	u8	rf_config ;
 	u8	low_power ;
 
-	u8	wifi_spec;// !turbo_mode
+	u8	wifi_spec;/*  !turbo_mode */
 
 	u8	channel_plan;
 #ifdef CONFIG_BT_COEXIST
@@ -153,22 +153,22 @@ struct registry_priv {
 
 	u8	antdiv_cfg;
 
-	u8	usbss_enable;//0:disable,1:enable
-	u8	hwpdn_mode;//0:disable,1:enable,2:decide by EFUSE config
-	u8	hwpwrp_detect;//0:disable,1:enable
+	u8	usbss_enable;/* 0:disable,1:enable */
+	u8	hwpdn_mode;/* 0:disable,1:enable,2:decide by EFUSE config */
+	u8	hwpwrp_detect;/* 0:disable,1:enable */
 
-	u8	hw_wps_pbc;//0:disable,1:enable
+	u8	hw_wps_pbc;/* 0:disable,1:enable */
 
 #ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
 	char	adaptor_info_caching_file_path[PATH_LENGTH_MAX];
 #endif
 
 #ifdef CONFIG_LAYER2_ROAMING
-	u8	max_roaming_times; // the max number driver will try to roaming
+	u8	max_roaming_times; /*  the max number driver will try to roaming */
 #endif
 
-	u8  special_rf_path; //0: 2T2R ,1: only turn on path A 1T1R, 2: only turn on path B 1T1R
-	u8	mac_phy_mode; //0:by efuse, 1:smsp, 2:dmdp, 3:dmsp.
+	u8  special_rf_path; /* 0: 2T2R ,1: only turn on path A 1T1R, 2: only turn on path B 1T1R */
+	u8	mac_phy_mode; /* 0:by efuse, 1:smsp, 2:dmdp, 3:dmsp. */
 
 #ifdef CONFIG_80211D
 	u8 enable80211d;
@@ -180,12 +180,12 @@ struct registry_priv {
 	u8 notch_filter;
 
 #ifdef CONFIG_MULTI_VIR_IFACES
-	u8 ext_iface_num;//primary/secondary iface is excluded
+	u8 ext_iface_num;/* primary/secondary iface is excluded */
 #endif
 };
 
 
-//For registry parameters
+/* For registry parameters */
 #define RGTRY_OFT(field) ((u32)FIELD_OFFSET(struct registry_priv, field))
 #define RGTRY_SZ(field)   sizeof(((struct registry_priv*) 0)->field)
 #define BSSID_OFT(field) ((u32)FIELD_OFFSET(struct wlan_bssid_ex, field))
@@ -198,37 +198,37 @@ struct registry_priv {
 #ifdef CONFIG_CONCURRENT_MODE
 #define GET_IFACE_NUMS(padapter) (((struct rtw_adapter *)padapter)->dvobj->iface_nums)
 #define GET_ADAPTER(padapter, iface_id) (((struct rtw_adapter *)padapter)->dvobj->padapters[iface_id])
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 enum _IFACE_ID {
-	IFACE_ID0, //maping to PRIMARY_ADAPTER
-	IFACE_ID1, //maping to SECONDARY_ADAPTER
+	IFACE_ID0, /* maping to PRIMARY_ADAPTER */
+	IFACE_ID1, /* maping to SECONDARY_ADAPTER */
 	IFACE_ID2,
 	IFACE_ID3,
 	IFACE_ID_MAX,
 };
 
 struct dvobj_priv {
-	struct rtw_adapter *if1; //PRIMARY_ADAPTER
-	struct rtw_adapter *if2; //SECONDARY_ADAPTER
+	struct rtw_adapter *if1; /* PRIMARY_ADAPTER */
+	struct rtw_adapter *if2; /* SECONDARY_ADAPTER */
 
-	//for local/global synchronization
+	/* for local/global synchronization */
 	_mutex hw_init_mutex;
 	_mutex h2c_fwcmd_mutex;
 	_mutex setch_mutex;
 	_mutex setbw_mutex;
 
-	unsigned char	oper_channel; //saved channel info when call set_channel_bw
+	unsigned char	oper_channel; /* saved channel info when call set_channel_bw */
 	unsigned char	oper_bwmode;
-	unsigned char	oper_ch_offset;//PRIME_CHNL_OFFSET
+	unsigned char	oper_ch_offset;/* PRIME_CHNL_OFFSET */
 
 #ifdef CONFIG_CONCURRENT_MODE
-	//extend to support mulitu interface
+	/* extend to support mulitu interface */
 	struct rtw_adapter *padapters[IFACE_ID_MAX];
-	u8 iface_nums; // total number of ifaces used runtime
-#endif //CONFIG_CONCURRENT_MODE
+	u8 iface_nums; /*  total number of ifaces used runtime */
+#endif /* CONFIG_CONCURRENT_MODE */
 
-	//For 92D, DMDP have 2 interface.
+	/* For 92D, DMDP have 2 interface. */
 	u8	InterfaceNumber;
 	u8	NumInterfaces;
 	u8	DualMacMode;
@@ -246,7 +246,7 @@ struct dvobj_priv {
 	u8	ishighspeed;
 	u8	RtNumInPipes;
 	u8	RtNumOutPipes;
-	int	ep_num[5]; //endpoint number
+	int	ep_num[5]; /* endpoint number */
 
 	int	RegUsbSS;
 
@@ -274,8 +274,8 @@ static struct device *dvobj_to_dev(struc
 }
 
 enum _IFACE_TYPE {
-	IFACE_PORT0, //mapping to port0 for C/D series chips
-	IFACE_PORT1, //mapping to port1 for C/D series chip
+	IFACE_PORT0, /* mapping to port0 for C/D series chips */
+	IFACE_PORT1, /* mapping to port1 for C/D series chip */
 	MAX_IFACE_PORT,
 };
 
@@ -292,12 +292,12 @@ enum DRIVER_STATE {
 };
 
 struct rtw_adapter {
-	int	DriverState;// for disable driver using module, use dongle to replace module.
-	int	pid[3];//process id from UI, 0:wps, 1:hostapd, 2:dhcpcd
-	int	bDongle;//build-in module or external dongle
+	int	DriverState;/*  for disable driver using module, use dongle to replace module. */
+	int	pid[3];/* process id from UI, 0:wps, 1:hostapd, 2:dhcpcd */
+	int	bDongle;/* build-in module or external dongle */
 	u16	chip_type;
 	u16	HardwareType;
-	u16	interface_type;//USB,SDIO,PCI
+	u16	interface_type;/* USB,SDIO,PCI */
 
 	struct dvobj_priv *dvobj;
 	struct	mlme_priv mlmepriv;
@@ -325,20 +325,20 @@ struct rtw_adapter {
 #ifdef CONFIG_IOCTL_CFG80211
 #ifdef CONFIG_P2P
 	struct cfg80211_wifidirect_info	cfg80211_wdinfo;
-#endif //CONFIG_P2P
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_P2P */
+#endif /* CONFIG_IOCTL_CFG80211 */
 	u32	setband;
 #ifdef CONFIG_P2P
 	struct wifidirect_info	wdinfo;
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 #ifdef CONFIG_TDLS
 	struct tdls_info	tdlsinfo;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 #ifdef CONFIG_WFD
 	struct wifi_display_info wfd_info;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	void *HalData;
 	u32 hal_data_sz;
@@ -367,7 +367,7 @@ struct rtw_adapter {
 
 	struct net_device *pnetdev;
 
-	// used by rtw_rereg_nd_name related function
+	/*  used by rtw_rereg_nd_name related function */
 	struct rereg_nd_name_data {
 		struct net_device *old_pnetdev;
 		char old_ifname[IFNAMSIZ];
@@ -378,11 +378,11 @@ struct rtw_adapter {
 	int bup;
 	struct net_device_stats stats;
 	struct iw_statistics iwstats;
-	struct proc_dir_entry *dir_dev;// for proc directory
+	struct proc_dir_entry *dir_dev;/*  for proc directory */
 
 #ifdef CONFIG_IOCTL_CFG80211
 	struct wireless_dev *rtw_wdev;
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 	int net_closed;
 
@@ -390,46 +390,46 @@ struct rtw_adapter {
 	u8 bReadPortCancel;
 	u8 bWritePortCancel;
 	u8 bRxRSSIDisplay;
-	//	Added by Albert 2012/07/26
-	//	The driver will write the initial gain everytime when running in the DM_Write_DIG function.
+	/* 	Added by Albert 2012/07/26 */
+	/* 	The driver will write the initial gain everytime when running in the DM_Write_DIG function. */
 	u8 bForceWriteInitGain;
-	//	Added by Albert 2012/10/26
-	//	The driver will show up the desired channel number when this flag is 1.
+	/* 	Added by Albert 2012/10/26 */
+	/* 	The driver will show up the desired channel number when this flag is 1. */
 	u8 bNotifyChannelChange;
 #ifdef CONFIG_P2P
-	//	Added by Albert 2012/12/06
-	//	The driver will show the current P2P status when the upper application reads it.
+	/* 	Added by Albert 2012/12/06 */
+	/* 	The driver will show the current P2P status when the upper application reads it. */
 	u8 bShowGetP2PState;
 #endif
 #ifdef CONFIG_AUTOSUSPEND
 	u8	bDisableAutosuspend;
 #endif
 
-	//pbuddy_adapter is used only in  two inteface case, (iface_nums=2 in struct dvobj_priv)
-	//PRIMARY_ADAPTER's buddy is SECONDARY_ADAPTER
-	//SECONDARY_ADAPTER's buddy is PRIMARY_ADAPTER
-	//for iface_id > SECONDARY_ADAPTER(IFACE_ID1), refer to padapters[iface_id]  in struct dvobj_priv
-	//and their pbuddy_adapter is PRIMARY_ADAPTER.
-	//for PRIMARY_ADAPTER(IFACE_ID0) can directly refer to if1 in struct dvobj_priv
+	/* pbuddy_adapter is used only in  two inteface case, (iface_nums=2 in struct dvobj_priv) */
+	/* PRIMARY_ADAPTER's buddy is SECONDARY_ADAPTER */
+	/* SECONDARY_ADAPTER's buddy is PRIMARY_ADAPTER */
+	/* for iface_id > SECONDARY_ADAPTER(IFACE_ID1), refer to padapters[iface_id]  in struct dvobj_priv */
+	/* and their pbuddy_adapter is PRIMARY_ADAPTER. */
+	/* for PRIMARY_ADAPTER(IFACE_ID0) can directly refer to if1 in struct dvobj_priv */
 	struct rtw_adapter *pbuddy_adapter;
 
 #if defined(CONFIG_CONCURRENT_MODE) || defined(CONFIG_DUALMAC_CONCURRENT)
-	u8 isprimary; //is primary adapter or not
-	//notes:
-	// if isprimary is true, the adapter_type value is 0, iface_id is IFACE_ID0 for PRIMARY_ADAPTER
-	// if isprimary is false, the adapter_type value is 1, iface_id is IFACE_ID1 for SECONDARY_ADAPTER
-	// refer to iface_id if iface_nums>2 and isprimary is false and the adapter_type value is 0xff.
-	u8 adapter_type;//used only in  two inteface case(PRIMARY_ADAPTER and SECONDARY_ADAPTER) .
-	u8 iface_type; //interface port type, it depends on HW port
-
-	//extend to support multi interface
-       //IFACE_ID0 is equals to PRIMARY_ADAPTER
-       //IFACE_ID1 is equals to SECONDARY_ADAPTER
+	u8 isprimary; /* is primary adapter or not */
+	/* notes: */
+	/*  if isprimary is true, the adapter_type value is 0, iface_id is IFACE_ID0 for PRIMARY_ADAPTER */
+	/*  if isprimary is false, the adapter_type value is 1, iface_id is IFACE_ID1 for SECONDARY_ADAPTER */
+	/*  refer to iface_id if iface_nums>2 and isprimary is false and the adapter_type value is 0xff. */
+	u8 adapter_type;/* used only in  two inteface case(PRIMARY_ADAPTER and SECONDARY_ADAPTER) . */
+	u8 iface_type; /* interface port type, it depends on HW port */
+
+	/* extend to support multi interface */
+       /* IFACE_ID0 is equals to PRIMARY_ADAPTER */
+       /* IFACE_ID1 is equals to SECONDARY_ADAPTER */
 	u8 iface_id;
 #endif
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	u8 DualMacConcurrent; // 1: DMSP 0:DMDP
+	u8 DualMacConcurrent; /*  1: DMSP 0:DMDP */
 #endif
 
 #ifdef CONFIG_BR_EXT
@@ -444,7 +444,7 @@ struct rtw_adapter {
 	unsigned char			br_ip[4];
 
 	struct br_ext_info		eth_br_ext_info;
-#endif	// CONFIG_BR_EXT
+#endif	/*  CONFIG_BR_EXT */
 };
 
 #define adapter_to_dvobj(adapter) (adapter->dvobj)
@@ -456,4 +456,4 @@ __inline static u8 *myid(struct eeprom_p
 	return (peepriv->mac_addr);
 }
 
-#endif //__DRV_TYPES_H__
+#endif /* __DRV_TYPES_H__ */
--- a/drivers/staging/rtl8192du/include/ethernet.h
+++ b/drivers/staging/rtl8192du/include/ethernet.h
@@ -21,21 +21,21 @@
 #ifndef __INC_ETHERNET_H
 #define __INC_ETHERNET_H
 
-#define ETHERNET_ADDRESS_LENGTH			6		//!< Ethernet Address Length
-#define ETHERNET_HEADER_SIZE			14		//!< Ethernet Header Length
-#define LLC_HEADER_SIZE				6		//!< LLC Header Length
-#define TYPE_LENGTH_FIELD_SIZE			2		//!< Type/Length Size
-#define MINIMUM_ETHERNET_PACKET_SIZE		60		//!< Minimum Ethernet Packet Size
-#define MAXIMUM_ETHERNET_PACKET_SIZE		1514	//!< Maximum Ethernet Packet Size
+#define ETHERNET_ADDRESS_LENGTH			6		/*  Ethernet Address Length */
+#define ETHERNET_HEADER_SIZE			14		/*  Ethernet Header Length */
+#define LLC_HEADER_SIZE				6		/*  LLC Header Length */
+#define TYPE_LENGTH_FIELD_SIZE			2		/*  Type/Length Size */
+#define MINIMUM_ETHERNET_PACKET_SIZE		60		/*  Minimum Ethernet Packet Size */
+#define MAXIMUM_ETHERNET_PACKET_SIZE		1514	/*  Maximum Ethernet Packet Size */
 
-#define RT_ETH_IS_MULTICAST(_pAddr)	((((u8 *)(_pAddr))[0]&0x01)!=0)		//!< Is Multicast Address?
+#define RT_ETH_IS_MULTICAST(_pAddr)	((((u8 *)(_pAddr))[0]&0x01)!=0)		/*  Is Multicast Address? */
 #define RT_ETH_IS_BROADCAST(_pAddr)	(										\
 					((u8 *)(_pAddr))[0]==0xff	&&		\
 					((u8 *)(_pAddr))[1]==0xff	&&		\
 					((u8 *)(_pAddr))[2]==0xff	&&		\
 					((u8 *)(_pAddr))[3]==0xff	&&		\
 					((u8 *)(_pAddr))[4]==0xff	&&		\
-					((u8 *)(_pAddr))[5]==0xff		)	//!< Is Broadcast Address?
+					((u8 *)(_pAddr))[5]==0xff		)	/*  Is Broadcast Address? */
 
 
-#endif // #ifndef __INC_ETHERNET_H
+#endif /*  #ifndef __INC_ETHERNET_H */
--- a/drivers/staging/rtl8192du/include/hal_intf.h
+++ b/drivers/staging/rtl8192du/include/hal_intf.h
@@ -107,7 +107,7 @@ enum HW_VARIABLES {
 	HW_VAR_EFUSE_BYTES,
 	HW_VAR_FIFO_CLEARN_UP,
 	HW_VAR_CHECK_TXBUF,
-	HW_VAR_APFM_ON_MAC, //Auto FSM to Turn On, include clock, isolation, power control for MAC only
+	HW_VAR_APFM_ON_MAC, /* Auto FSM to Turn On, include clock, isolation, power control for MAC only */
 	HW_VAR_WOWLAN,
 	HW_VAR_VID,
 	HW_VAR_PID,
@@ -123,8 +123,8 @@ enum HAL_DEF_VARIABLE {
 	HAL_DEF_DRVINFO_SZ,
 	HAL_DEF_MAX_RECVBUF_SZ,
 	HAL_DEF_RX_PACKET_OFFSET,
-	HAL_DEF_DBG_DUMP_RXPKT,//for dbg
-	HAL_DEF_DBG_DM_FUNC,//for dbg
+	HAL_DEF_DBG_DUMP_RXPKT,/* for dbg */
+	HAL_DEF_DBG_DM_FUNC,/* for dbg */
 
 };
 
@@ -262,9 +262,9 @@ enum HARDWARE_TYPE {
 	HARDWARE_TYPE_MAX,
 };
 
-//
-// RTL8192D Series
-//
+/*  */
+/*  RTL8192D Series */
+/*  */
 #define IS_HARDWARE_TYPE_8192DE(_Adapter)			\
 		(((struct rtw_adapter *)_Adapter)->HardwareType==HARDWARE_TYPE_RTL8192DE)
 #define IS_HARDWARE_TYPE_8192DU(_Adapter)			\
@@ -306,7 +306,7 @@ struct wowlan_ioctl_param{
 #define Rx_MagicPkt				BIT(5)
 #define FinishBtFwPatch				BIT(7)
 
-#endif // CONFIG_WOWLAN
+#endif /*  CONFIG_WOWLAN */
 
 void rtw_hal_def_value_init(struct rtw_adapter *padapter);
 void rtw_hal_free_data(struct rtw_adapter *padapter);
@@ -390,4 +390,4 @@ void rtw_hal_reset_security_engine(struc
 s32 rtw_hal_c2h_handler(struct rtw_adapter *adapter, struct c2h_evt_hdr *c2h_evt);
 c2h_id_filter rtw_hal_c2h_id_filter_ccx(struct rtw_adapter *adapter);
 
-#endif //__HAL_INTF_H__
+#endif /* __HAL_INTF_H__ */
--- a/drivers/staging/rtl8192du/include/ieee80211.h
+++ b/drivers/staging/rtl8192du/include/ieee80211.h
@@ -149,9 +149,9 @@ extern u8 RSN_CIPHER_SUITE_CCMP[];
 extern u8 RSN_CIPHER_SUITE_WEP104[];
 
 enum RATR_TABLE_MODE {
-	RATR_INX_WIRELESS_NGB = 0,	// BGN 40 Mhz 2SS 1SS
-	RATR_INX_WIRELESS_NG = 1,		// GN or N
-	RATR_INX_WIRELESS_NB = 2,		// BGN 20 Mhz 2SS 1SS  or BN
+	RATR_INX_WIRELESS_NGB = 0,	/*  BGN 40 Mhz 2SS 1SS */
+	RATR_INX_WIRELESS_NG = 1,		/*  GN or N */
+	RATR_INX_WIRELESS_NB = 2,		/*  BGN 20 Mhz 2SS 1SS  or BN */
 	RATR_INX_WIRELESS_N = 3,
 	RATR_INX_WIRELESS_GB = 4,
 	RATR_INX_WIRELESS_G = 5,
@@ -163,21 +163,21 @@ enum RATR_TABLE_MODE {
 enum NETWORK_TYPE
 {
     WIRELESS_INVALID = 0,
-    //Sub-Element
-    WIRELESS_11B = BIT(0), // tx: cck only , rx: cck only, hw: cck
-    WIRELESS_11G = BIT(1), // tx: ofdm only, rx: ofdm & cck, hw: cck & ofdm
-    WIRELESS_11A = BIT(2), // tx: ofdm only, rx: ofdm only, hw: ofdm only
-    WIRELESS_11_24N = BIT(3), // tx: MCS only, rx: MCS & cck, hw: MCS & cck
-    WIRELESS_11_5N = BIT(4), // tx: MCS only, rx: MCS & ofdm, hw: ofdm only
-	//WIRELESS_AUTO		= BIT(5),
+    /* Sub-Element */
+    WIRELESS_11B = BIT(0), /*  tx: cck only , rx: cck only, hw: cck */
+    WIRELESS_11G = BIT(1), /*  tx: ofdm only, rx: ofdm & cck, hw: cck & ofdm */
+    WIRELESS_11A = BIT(2), /*  tx: ofdm only, rx: ofdm only, hw: ofdm only */
+    WIRELESS_11_24N = BIT(3), /*  tx: MCS only, rx: MCS & cck, hw: MCS & cck */
+    WIRELESS_11_5N = BIT(4), /*  tx: MCS only, rx: MCS & ofdm, hw: ofdm only */
+	/* WIRELESS_AUTO		= BIT(5), */
 	WIRELESS_AC		= BIT(6),
 
-    //Combination
-    WIRELESS_11BG = (WIRELESS_11B|WIRELESS_11G), // tx: cck & ofdm, rx: cck & ofdm & MCS, hw: cck & ofdm
-    WIRELESS_11G_24N = (WIRELESS_11G|WIRELESS_11_24N), // tx: ofdm & MCS, rx: ofdm & cck & MCS, hw: cck & ofdm
-    WIRELESS_11A_5N = (WIRELESS_11A|WIRELESS_11_5N), // tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only
-    WIRELESS_11BG_24N = (WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N), // tx: ofdm & cck & MCS, rx: ofdm & cck & MCS, hw: ofdm & cck
-    WIRELESS_11AGN = (WIRELESS_11A|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N), // tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only
+    /* Combination */
+    WIRELESS_11BG = (WIRELESS_11B|WIRELESS_11G), /*  tx: cck & ofdm, rx: cck & ofdm & MCS, hw: cck & ofdm */
+    WIRELESS_11G_24N = (WIRELESS_11G|WIRELESS_11_24N), /*  tx: ofdm & MCS, rx: ofdm & cck & MCS, hw: cck & ofdm */
+    WIRELESS_11A_5N = (WIRELESS_11A|WIRELESS_11_5N), /*  tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only */
+    WIRELESS_11BG_24N = (WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N), /*  tx: ofdm & cck & MCS, rx: ofdm & cck & MCS, hw: ofdm & cck */
+    WIRELESS_11AGN = (WIRELESS_11A|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N), /*  tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only */
     WIRELESS_11ABGN = (WIRELESS_11A|WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N),
 };
 
@@ -234,7 +234,7 @@ struct ieee_param {
 			struct rtw_ieee80211_ht_cap ht_cap;
 		} add_sta;
 		struct {
-			u8	reserved[2];//for set max_num_sta
+			u8	reserved[2];/* for set max_num_sta */
 			u8	buf[0];
 		} bcn_ie;
 #endif
@@ -642,13 +642,11 @@ struct ieee80211_snap_hdr {
  *       information for frames received.  Not setting these will not cause
  *       any adverse affects. */
 struct ieee80211_rx_stats {
-	//u32 mac_time[2];
 	s8 rssi;
 	u8 signal;
 	u8 noise;
 	u8 received_channel;
 	u16 rate; /* in 100 kbps */
-	//u8 control;
 	u8 mask;
 	u8 freq;
 	u16 len;
@@ -664,8 +662,8 @@ struct ieee80211_frag_entry {
 	u32 first_frag_time;
 	uint seq;
 	uint last_frag;
-	uint qos;   //jackson
-	uint tid;	//jackson
+	uint qos;   /* jackson */
+	uint tid;	/* jackson */
 	struct sk_buff *skb;
 	u8 src_addr[ETH_ALEN];
 	u8 dst_addr[ETH_ALEN];
@@ -822,7 +820,6 @@ struct ieee80211_authentication {
 	u16 algorithm;
 	u16 transaction;
 	u16 status;
-	//struct ieee80211_info_element_hdr info_element;
 } __attribute__ ((packed));
 
 struct ieee80211_probe_response {
@@ -835,14 +832,12 @@ struct ieee80211_probe_response {
 
 struct ieee80211_probe_request {
 	struct ieee80211_header_data header;
-	/*struct ieee80211_info_element info_element;*/
 } __attribute__ ((packed));
 
 struct ieee80211_assoc_request_frame {
 	struct rtw_ieee80211_hdr_3addr header;
 	u16 capability;
 	u16 listen_interval;
-	//u8 current_ap[ETH_ALEN];
 	struct ieee80211_info_element_hdr info_element;
 } __attribute__ ((packed));
 
@@ -851,7 +846,6 @@ struct ieee80211_assoc_response_frame {
 	u16 capability;
 	u16 status;
 	u16 aid;
-//	struct ieee80211_info_element info_element; /* supported rates */
 } __attribute__ ((packed));
 
 struct ieee80211_txb {
@@ -876,7 +870,7 @@ struct ieee80211_txb {
 #define MAX_NETWORK_COUNT                  128
 #define MAX_CHANNEL_NUMBER                 161
 #define IEEE80211_SOFTMAC_SCAN_TIME	  400
-//(HZ / 2)
+/* HZ / 2) */
 #define IEEE80211_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)
 
 #define CRC_LENGTH                 4U
@@ -968,7 +962,7 @@ extern __inline int is_broadcast_mac_add
 #define IEEE_G            (1<<2)
 #define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
 
-//Baron move to ieee80211.c
+/* Baron move to ieee80211.c */
 int ieee80211_is_empty_essid(const char *essid, int essid_len);
 int ieee80211_get_hdrlen(u16 fc);
 
@@ -978,14 +972,14 @@ enum rtw_ieee80211_category {
 	RTW_WLAN_CATEGORY_QOS = 1,
 	RTW_WLAN_CATEGORY_DLS = 2,
 	RTW_WLAN_CATEGORY_BACK = 3,
-	RTW_WLAN_CATEGORY_PUBLIC = 4, //IEEE 802.11 public action frames
+	RTW_WLAN_CATEGORY_PUBLIC = 4, /* IEEE 802.11 public action frames */
 	RTW_WLAN_CATEGORY_RADIO_MEASUREMENT  = 5,
 	RTW_WLAN_CATEGORY_FT = 6,
 	RTW_WLAN_CATEGORY_HT = 7,
 	RTW_WLAN_CATEGORY_SA_QUERY = 8,
 	RTW_WLAN_CATEGORY_TDLS = 12,
 	RTW_WLAN_CATEGORY_WMM = 17,
-	RTW_WLAN_CATEGORY_P2P = 0x7f,//P2P action frames
+	RTW_WLAN_CATEGORY_P2P = 0x7f,/* P2P action frames */
 };
 
 /* SPECTRUM_MGMT action code */
@@ -999,16 +993,16 @@ enum rtw_ieee80211_spectrum_mgmt_actionc
 };
 
 enum _PUBLIC_ACTION{
-	ACT_PUBLIC_BSSCOEXIST = 0, // 20/40 BSS Coexistence
+	ACT_PUBLIC_BSSCOEXIST = 0, /*  20/40 BSS Coexistence */
 	ACT_PUBLIC_DSE_ENABLE = 1,
 	ACT_PUBLIC_DSE_DEENABLE = 2,
 	ACT_PUBLIC_DSE_REG_LOCATION = 3,
 	ACT_PUBLIC_EXT_CHL_SWITCH = 4,
 	ACT_PUBLIC_DSE_MSR_REQ = 5,
 	ACT_PUBLIC_DSE_MSR_RPRT = 6,
-	ACT_PUBLIC_MP = 7, // Measurement Pilot
+	ACT_PUBLIC_MP = 7, /*  Measurement Pilot */
 	ACT_PUBLIC_DSE_PWR_CONSTRAINT = 8,
-	ACT_PUBLIC_VENDOR = 9, // for WIFI_DIRECT
+	ACT_PUBLIC_VENDOR = 9, /*  for WIFI_DIRECT */
 	ACT_PUBLIC_GAS_INITIAL_REQ = 10,
 	ACT_PUBLIC_GAS_INITIAL_RSP = 11,
 	ACT_PUBLIC_GAS_COMEBACK_REQ = 12,
@@ -1031,12 +1025,12 @@ enum TDLS_ACTION_FIELD{
 	TDLS_PEER_PSM_RESPONSE = 8,
 	TDLS_PEER_TRAFFIC_RESPONSE = 9,
 	TDLS_DISCOVERY_REQUEST = 10,
-	TDLS_DISCOVERY_RESPONSE = 14,	//it's used in public action frame
+	TDLS_DISCOVERY_RESPONSE = 14,	/* it's used in public action frame */
 };
 
 #define	TUNNELED_PROBE_REQ	15
 #define	TUNNELED_PROBE_RSP	16
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 /* BACK action code */
 enum rtw_ieee80211_back_actioncode {
@@ -1120,44 +1114,17 @@ enum rtw_ieee80211_back_parties {
 
 /* Represent channel details, subset of ieee80211_channel */
 struct rtw_ieee80211_channel {
-	//enum ieee80211_band band;
-	//u16 center_freq;
 	u16 hw_value;
 	u32 flags;
-	//int max_antenna_gain;
-	//int max_power;
-	//int max_reg_power;
-	//bool beacon_found;
-	//u32 orig_flags;
-	//int orig_mag;
-	//int orig_mpwr;
 };
 
 #define CHAN_FMT \
-	/*"band:%d, "*/ \
-	/*"center_freq:%u, "*/ \
 	"hw_value:%u, " \
 	"flags:0x%08x" \
-	/*"max_antenna_gain:%d\n"*/ \
-	/*"max_power:%d\n"*/ \
-	/*"max_reg_power:%d\n"*/ \
-	/*"beacon_found:%u\n"*/ \
-	/*"orig_flags:0x%08x\n"*/ \
-	/*"orig_mag:%d\n"*/ \
-	/*"orig_mpwr:%d\n"*/
 
 #define CHAN_ARG(channel) \
-	/*(channel)->band*/ \
-	/*, (channel)->center_freq*/ \
 	(channel)->hw_value \
 	, (channel)->flags \
-	/*, (channel)->max_antenna_gain*/ \
-	/*, (channel)->max_power*/ \
-	/*, (channel)->max_reg_power*/ \
-	/*, (channel)->beacon_found*/ \
-	/*, (channel)->orig_flags*/ \
-	/*, (channel)->orig_mag*/ \
-	/*, (channel)->orig_mpwr*/ \
 
 /* Parsed Information Elements */
 struct rtw_ieee802_11_elems {
@@ -1277,7 +1244,7 @@ void rtw_wlan_bssid_ex_remove_p2p_attr(s
 #ifdef CONFIG_WFD
 int rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen);
 int rtw_get_wfd_attr_content(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id ,u8 *attr_content, uint *attr_contentlen);
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
 uint	rtw_get_rateset_len(u8	*rateset);
 
--- a/drivers/staging/rtl8192du/include/ioctl_cfg80211.h
+++ b/drivers/staging/rtl8192du/include/ioctl_cfg80211.h
@@ -58,8 +58,8 @@ struct rtw_wdev_priv
 	struct cfg80211_scan_request *scan_request;
 	spinlock_t scan_req_lock;
 
-	struct net_device *pmon_ndev;//for monitor interface
-	char ifname_mon[IFNAMSIZ + 1]; //interface name for monitor interface
+	struct net_device *pmon_ndev;/* for monitor interface */
+	char ifname_mon[IFNAMSIZ + 1]; /* interface name for monitor interface */
 
 	u8 p2p_enabled;
 
@@ -99,7 +99,7 @@ void rtw_cfg80211_indicate_scan_done(str
 #ifdef CONFIG_AP_MODE
 void rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
 void rtw_cfg80211_indicate_sta_disassoc(struct rtw_adapter *padapter, unsigned char *da, unsigned short reason);
-#endif //CONFIG_AP_MODE
+#endif /* CONFIG_AP_MODE */
 
 void rtw_cfg80211_issue_p2p_provision_request(struct rtw_adapter *padapter, const u8 *buf, size_t len);
 void rtw_cfg80211_rx_p2p_action_public(struct rtw_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
@@ -141,4 +141,4 @@ bool rtw_cfg80211_pwr_mgmt(struct rtw_ad
 #define rtw_cfg80211_remain_on_channel_expired(adapter, cookie, chan, chan_type, gfp) cfg80211_remain_on_channel_expired((adapter)->rtw_wdev, cookie, chan, gfp)
 #endif
 
-#endif //__IOCTL_CFG80211_H__
+#endif /* __IOCTL_CFG80211_H__ */
--- a/drivers/staging/rtl8192du/include/mlme_osdep.h
+++ b/drivers/staging/rtl8192du/include/mlme_osdep.h
@@ -32,4 +32,4 @@ extern void rtw_report_sec_ie(struct rtw
 
 void rtw_reset_securitypriv(struct rtw_adapter *adapter);
 
-#endif	//_MLME_OSDEP_H_
+#endif	/* _MLME_OSDEP_H_ */
--- a/drivers/staging/rtl8192du/include/mp_custom_oid.h
+++ b/drivers/staging/rtl8192du/include/mp_custom_oid.h
@@ -20,20 +20,20 @@
 #ifndef	__CUSTOM_OID_H
 #define __CUSTOM_OID_H
 
-// by Owen
-// 0xFF818000 - 0xFF81802F		RTL8180 Mass Production Kit
-// 0xFF818500 - 0xFF81850F		RTL8185 Setup Utility
-// 0xFF818580 - 0xFF81858F		RTL8185 Phy Status Utility
-
-//
-
-// by Owen for Production Kit
-// For Production Kit with Agilent Equipments
-// in order to make our custom oids hopefully somewhat unique
-// we will use 0xFF (indicating implementation specific OID)
-//               81(first byte of non zero Realtek unique identifier)
-//               80 (second byte of non zero Realtek unique identifier)
-//               XX (the custom OID number - providing 255 possible custom oids)
+/*  by Owen */
+/*  0xFF818000 - 0xFF81802F		RTL8180 Mass Production Kit */
+/*  0xFF818500 - 0xFF81850F		RTL8185 Setup Utility */
+/*  0xFF818580 - 0xFF81858F		RTL8185 Phy Status Utility */
+
+/*  */
+
+/*  by Owen for Production Kit */
+/*  For Production Kit with Agilent Equipments */
+/*  in order to make our custom oids hopefully somewhat unique */
+/*  we will use 0xFF (indicating implementation specific OID) */
+/*                81(first byte of non zero Realtek unique identifier) */
+/*                80 (second byte of non zero Realtek unique identifier) */
+/*                XX (the custom OID number - providing 255 possible custom oids) */
 
 #define OID_RT_PRO_RESET_DUT				0xFF818000
 #define OID_RT_PRO_SET_DATA_RATE			0xFF818001
@@ -78,26 +78,26 @@
 #define OID_RT_PRO_QUERY_PERMANENT_ADDRESS		0xFF818029
 #define OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS		0xFF81802A
 #define OID_RT_PRO_RECEIVE_PACKET			0xFF81802C
-// added by Owen on 04/08/03 for Cameo's request
+/*  added by Owen on 04/08/03 for Cameo's request */
 #define OID_RT_PRO_WRITE_EEPROM_BYTE			0xFF81802D
 #define OID_RT_PRO_READ_EEPROM_BYTE			0xFF81802E
 #define OID_RT_PRO_SET_MODULATION			0xFF81802F
-//
+/*  */
 
-//Sean
+/* Sean */
 #define OID_RT_DRIVER_OPTION				0xFF818080
 #define OID_RT_RF_OFF					0xFF818081
 #define OID_RT_AUTH_STATUS				0xFF818082
 
-//========================================================================
+/*  */
 #define OID_RT_PRO_SET_CONTINUOUS_TX			0xFF81800B
 #define OID_RT_PRO_SET_SINGLE_CARRIER_TX		0xFF81800C
 #define OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX		0xFF81802B
 #define OID_RT_PRO_SET_SINGLE_TONE_TX			0xFF818043
-//========================================================================
+/*  */
 
 
-// by Owen for RTL8185 Phy Status Report Utility
+/*  by Owen for RTL8185 Phy Status Report Utility */
 #define OID_RT_UTILITY_FALSE_ALARM_COUNTERS				0xFF818580
 #define OID_RT_UTILITY_SELECT_DEBUG_MODE				0xFF818581
 #define OID_RT_UTILITY_SELECT_SUBCARRIER_NUMBER				0xFF818582
@@ -105,14 +105,14 @@
 #define OID_RT_UTILITY_GET_FRAME_DETECTION_STATUS			0xFF818584
 #define OID_RT_UTILITY_GET_AGC_AND_FREQUENCY_OFFSET_ESTIMATION_STATUS	0xFF818585
 #define OID_RT_UTILITY_GET_CHANNEL_ESTIMATION_STATUS			0xFF818586
-//
+/*  */
 
-// by Owen on 03/09/19-03/09/22 for RTL8185
+/*  by Owen on 03/09/19-03/09/22 for RTL8185 */
 #define OID_RT_WIRELESS_MODE				0xFF818500
 #define OID_RT_SUPPORTED_RATES				0xFF818501
 #define OID_RT_DESIRED_RATES				0xFF818502
 #define OID_RT_WIRELESS_MODE_STARTING_ADHOC		0xFF818503
-//
+/*  */
 
 #define OID_RT_GET_CONNECT_STATE			0xFF030001
 #define OID_RT_RESCAN					0xFF030002
@@ -127,8 +127,8 @@
 #define OID_RT_GET_LARGE_PACKET_CRC			0xFF010187
 #define OID_RT_GET_TX_RETRY				0xFF010188
 #define OID_RT_GET_RX_RETRY				0xFF010189
-#define OID_RT_PRO_SET_FW_DIG_STATE			0xFF01018A//S
-#define OID_RT_PRO_SET_FW_RA_STATE			0xFF01018B//S
+#define OID_RT_PRO_SET_FW_DIG_STATE			0xFF01018A/* S */
+#define OID_RT_PRO_SET_FW_RA_STATE			0xFF01018B/* S */
 
 #define OID_RT_GET_RX_TOTAL_PACKET			0xFF010190
 #define OID_RT_GET_TX_BEACON_OK				0xFF010191
@@ -155,9 +155,9 @@
 #define OID_RT_GET_CCA_UPGRADE_EVALUATE_TIMES		0xFF0101A3
 #define OID_RT_GET_CCA_FALLBACK_EVALUATE_TIMES		0xFF0101A4
 
-// by Owen on 03/31/03 for Cameo's request
+/*  by Owen on 03/31/03 for Cameo's request */
 #define OID_RT_SET_RATE_ADAPTIVE			0xFF0101A5
-//
+/*  */
 #define OID_RT_GET_DCST_EVALUATE_PERIOD			0xFF0101A5
 #define OID_RT_GET_DCST_TIME_UNIT_INDEX			0xFF0101A6
 #define OID_RT_GET_TOTAL_TX_BYTES			0xFF0101A7
@@ -188,20 +188,20 @@
 #define OID_RT_RF_READ_WRITE_OFFSET			0xFF0101BF
 #define OID_RT_RF_READ_WRITE				0xFF0101C0
 
-// For Netgear request. 2005.01.13, by rcnjko.
+/*  For Netgear request. 2005.01.13, by rcnjko. */
 #define OID_RT_FORCED_DATA_RATE				0xFF0101C1
 #define OID_RT_WIRELESS_MODE_FOR_SCAN_LIST		0xFF0101C2
-// For Netgear request. 2005.02.17, by rcnjko.
+/*  For Netgear request. 2005.02.17, by rcnjko. */
 #define OID_RT_GET_BSS_WIRELESS_MODE			0xFF0101C3
-// For AZ project. 2005.06.27, by rcnjko.
+/*  For AZ project. 2005.06.27, by rcnjko. */
 #define OID_RT_SCAN_WITH_MAGIC_PACKET			0xFF0101C4
 
-// Vincent 8185MP
+/*  Vincent 8185MP */
 #define OID_RT_PRO_RX_FILTER				0xFF0111C0
 
-//Andy TEST
-//#define OID_RT_PRO_WRITE_REGISTRY			0xFF0111C1
-//#define OID_RT_PRO_READ_REGISTRY			0xFF0111C2
+/* Andy TEST */
+/* define OID_RT_PRO_WRITE_REGISTRY			0xFF0111C1 */
+/* define OID_RT_PRO_READ_REGISTRY			0xFF0111C2 */
 #define OID_CE_USB_WRITE_REGISTRY			0xFF0111C1
 #define OID_CE_USB_READ_REGISTRY			0xFF0111C2
 
@@ -215,139 +215,139 @@
 #define OID_RT_PRO_RF_READ_REGISTRY			0xFF0111C9
 #define OID_RT_PRO_QUERY_RF_TYPE			0xFF0111CA
 
-// AP OID
+/*  AP OID */
 #define OID_RT_AP_GET_ASSOCIATED_STATION_LIST		0xFF010300
 #define OID_RT_AP_GET_CURRENT_TIME_STAMP		0xFF010301
 #define OID_RT_AP_SWITCH_INTO_AP_MODE			0xFF010302
 #define OID_RT_AP_SET_DTIM_PERIOD			0xFF010303
-#define OID_RT_AP_SUPPORTED				0xFF010304	// Determine if driver supports AP mode. 2004.08.27, by rcnjko.
-#define OID_RT_AP_SET_PASSPHRASE			0xFF010305	// Set WPA-PSK passphrase into authenticator. 2005.07.08, byrcnjko.
+#define OID_RT_AP_SUPPORTED				0xFF010304	/*  Determine if driver supports AP mode. 2004.08.27, by rcnjko. */
+#define OID_RT_AP_SET_PASSPHRASE			0xFF010305	/*  Set WPA-PSK passphrase into authenticator. 2005.07.08, byrcnjko. */
 
-// 8187MP. 2004.09.06, by rcnjko.
+/*  8187MP. 2004.09.06, by rcnjko. */
 #define OID_RT_PRO8187_WI_POLL				0xFF818780
 #define OID_RT_PRO_WRITE_BB_REG				0xFF818781
 #define OID_RT_PRO_READ_BB_REG				0xFF818782
 #define OID_RT_PRO_WRITE_RF_REG				0xFF818783
 #define OID_RT_PRO_READ_RF_REG				0xFF818784
 
-// Meeting House. added by Annie, 2005-07-20.
+/*  Meeting House. added by Annie, 2005-07-20. */
 #define OID_RT_MH_VENDER_ID				0xFFEDC100
 
-//8711 MP OID added 20051230.
-#define OID_RT_PRO8711_JOIN_BSS				0xFF871100//S
+/* 8711 MP OID added 20051230. */
+#define OID_RT_PRO8711_JOIN_BSS				0xFF871100/* S */
 
-#define OID_RT_PRO_READ_REGISTER			0xFF871101 //Q
-#define OID_RT_PRO_WRITE_REGISTER			0xFF871102 //S
+#define OID_RT_PRO_READ_REGISTER			0xFF871101 /* Q */
+#define OID_RT_PRO_WRITE_REGISTER			0xFF871102 /* S */
 
-#define OID_RT_PRO_BURST_READ_REGISTER			0xFF871103 //Q
-#define OID_RT_PRO_BURST_WRITE_REGISTER			0xFF871104 //S
+#define OID_RT_PRO_BURST_READ_REGISTER			0xFF871103 /* Q */
+#define OID_RT_PRO_BURST_WRITE_REGISTER			0xFF871104 /* S */
 
-#define OID_RT_PRO_WRITE_TXCMD				0xFF871105 //S
-
-#define OID_RT_PRO_READ16_EEPROM			0xFF871106 //Q
-#define OID_RT_PRO_WRITE16_EEPROM			0xFF871107 //S
-
-#define OID_RT_PRO_H2C_SET_COMMAND			0xFF871108 //S
-#define OID_RT_PRO_H2C_QUERY_RESULT			0xFF871109 //Q
-
-#define OID_RT_PRO8711_WI_POLL				0xFF87110A //Q
-#define OID_RT_PRO8711_PKT_LOSS				0xFF87110B //Q
-#define OID_RT_RD_ATTRIB_MEM				0xFF87110C//Q
-#define OID_RT_WR_ATTRIB_MEM				0xFF87110D//S
-
-
-//Method 2 for H2C/C2H
-#define OID_RT_PRO_H2C_CMD_MODE				0xFF871110 //S
-#define OID_RT_PRO_H2C_CMD_RSP_MODE			0xFF871111 //Q
-#define OID_RT_PRO_H2C_CMD_EVENT_MODE			0xFF871112 //S
-#define OID_RT_PRO_WAIT_C2H_EVENT			0xFF871113 //Q
-#define OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST		0xFF871114//Q
-
-#define OID_RT_PRO_SCSI_ACCESS_TEST			0xFF871115 //Q, S
-
-#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT		0xFF871116 //S
-#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN			0xFF871117 //Q,S
-#define OID_RT_RRO_RX_PKT_VIA_IOCTRL			0xFF871118 //Q
-#define OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL		0xFF871119 //Q
-
-#define OID_RT_RPO_SET_PWRMGT_TEST			0xFF87111A //S
-#define OID_RT_PRO_QRY_PWRMGT_TEST			0XFF87111B //Q
-#define OID_RT_RPO_ASYNC_RWIO_TEST			0xFF87111C //S
-#define OID_RT_RPO_ASYNC_RWIO_POLL			0xFF87111D //Q
-#define OID_RT_PRO_SET_RF_INTFS				0xFF87111E //S
-#define OID_RT_POLL_RX_STATUS				0xFF87111F //Q
-
-#define OID_RT_PRO_CFG_DEBUG_MESSAGE			0xFF871120 //Q,S
-#define OID_RT_PRO_SET_DATA_RATE_EX			0xFF871121//S
-#define OID_RT_PRO_SET_BASIC_RATE			0xFF871122//S
-#define OID_RT_PRO_READ_TSSI				0xFF871123//S
-#define OID_RT_PRO_SET_POWER_TRACKING			0xFF871124//S
-
-
-#define OID_RT_PRO_QRY_PWRSTATE				0xFF871150 //Q
-#define OID_RT_PRO_SET_PWRSTATE				0xFF871151 //S
-
-//Method 2 , using workitem
-#define OID_RT_SET_READ_REG				0xFF871181 //S
-#define OID_RT_SET_WRITE_REG				0xFF871182 //S
-#define OID_RT_SET_BURST_READ_REG			0xFF871183 //S
-#define OID_RT_SET_BURST_WRITE_REG			0xFF871184 //S
-#define OID_RT_SET_WRITE_TXCMD				0xFF871185 //S
-#define OID_RT_SET_READ16_EEPROM			0xFF871186 //S
-#define OID_RT_SET_WRITE16_EEPROM			0xFF871187 //S
-#define OID_RT_QRY_POLL_WKITEM				0xFF871188 //Q
+#define OID_RT_PRO_WRITE_TXCMD				0xFF871105 /* S */
+
+#define OID_RT_PRO_READ16_EEPROM			0xFF871106 /* Q */
+#define OID_RT_PRO_WRITE16_EEPROM			0xFF871107 /* S */
+
+#define OID_RT_PRO_H2C_SET_COMMAND			0xFF871108 /* S */
+#define OID_RT_PRO_H2C_QUERY_RESULT			0xFF871109 /* Q */
+
+#define OID_RT_PRO8711_WI_POLL				0xFF87110A /* Q */
+#define OID_RT_PRO8711_PKT_LOSS				0xFF87110B /* Q */
+#define OID_RT_RD_ATTRIB_MEM				0xFF87110C/* Q */
+#define OID_RT_WR_ATTRIB_MEM				0xFF87110D/* S */
+
+
+/* Method 2 for H2C/C2H */
+#define OID_RT_PRO_H2C_CMD_MODE				0xFF871110 /* S */
+#define OID_RT_PRO_H2C_CMD_RSP_MODE			0xFF871111 /* Q */
+#define OID_RT_PRO_H2C_CMD_EVENT_MODE			0xFF871112 /* S */
+#define OID_RT_PRO_WAIT_C2H_EVENT			0xFF871113 /* Q */
+#define OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST		0xFF871114/* Q */
+
+#define OID_RT_PRO_SCSI_ACCESS_TEST			0xFF871115 /* Q, S */
+
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT		0xFF871116 /* S */
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN			0xFF871117 /* Q,S */
+#define OID_RT_RRO_RX_PKT_VIA_IOCTRL			0xFF871118 /* Q */
+#define OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL		0xFF871119 /* Q */
+
+#define OID_RT_RPO_SET_PWRMGT_TEST			0xFF87111A /* S */
+#define OID_RT_PRO_QRY_PWRMGT_TEST			0XFF87111B /* Q */
+#define OID_RT_RPO_ASYNC_RWIO_TEST			0xFF87111C /* S */
+#define OID_RT_RPO_ASYNC_RWIO_POLL			0xFF87111D /* Q */
+#define OID_RT_PRO_SET_RF_INTFS				0xFF87111E /* S */
+#define OID_RT_POLL_RX_STATUS				0xFF87111F /* Q */
+
+#define OID_RT_PRO_CFG_DEBUG_MESSAGE			0xFF871120 /* Q,S */
+#define OID_RT_PRO_SET_DATA_RATE_EX			0xFF871121/* S */
+#define OID_RT_PRO_SET_BASIC_RATE			0xFF871122/* S */
+#define OID_RT_PRO_READ_TSSI				0xFF871123/* S */
+#define OID_RT_PRO_SET_POWER_TRACKING			0xFF871124/* S */
+
+
+#define OID_RT_PRO_QRY_PWRSTATE				0xFF871150 /* Q */
+#define OID_RT_PRO_SET_PWRSTATE				0xFF871151 /* S */
+
+/* Method 2 , using workitem */
+#define OID_RT_SET_READ_REG				0xFF871181 /* S */
+#define OID_RT_SET_WRITE_REG				0xFF871182 /* S */
+#define OID_RT_SET_BURST_READ_REG			0xFF871183 /* S */
+#define OID_RT_SET_BURST_WRITE_REG			0xFF871184 /* S */
+#define OID_RT_SET_WRITE_TXCMD				0xFF871185 /* S */
+#define OID_RT_SET_READ16_EEPROM			0xFF871186 /* S */
+#define OID_RT_SET_WRITE16_EEPROM			0xFF871187 /* S */
+#define OID_RT_QRY_POLL_WKITEM				0xFF871188 /* Q */
 
-//For SDIO INTERFACE only
-#define OID_RT_PRO_SYNCPAGERW_SRAM			0xFF8711A0 //Q, S
+/* For SDIO INTERFACE only */
+#define OID_RT_PRO_SYNCPAGERW_SRAM			0xFF8711A0 /* Q, S */
 #define OID_RT_PRO_871X_DRV_EXT				0xFF8711A1
 
-//For USB INTERFACE only
-#define OID_RT_PRO_USB_VENDOR_REQ			0xFF8711B0 //Q, S
-#define OID_RT_PRO_SCSI_AUTO_TEST			0xFF8711B1 //S
-#define OID_RT_PRO_USB_MAC_AC_FIFO_WRITE		0xFF8711B2 //S
-#define OID_RT_PRO_USB_MAC_RX_FIFO_READ			0xFF8711B3 //Q
-#define OID_RT_PRO_USB_MAC_RX_FIFO_POLLING		0xFF8711B4 //Q
+/* For USB INTERFACE only */
+#define OID_RT_PRO_USB_VENDOR_REQ			0xFF8711B0 /* Q, S */
+#define OID_RT_PRO_SCSI_AUTO_TEST			0xFF8711B1 /* S */
+#define OID_RT_PRO_USB_MAC_AC_FIFO_WRITE		0xFF8711B2 /* S */
+#define OID_RT_PRO_USB_MAC_RX_FIFO_READ			0xFF8711B3 /* Q */
+#define OID_RT_PRO_USB_MAC_RX_FIFO_POLLING		0xFF8711B4 /* Q */
 
-#define OID_RT_PRO_H2C_SET_RATE_TABLE			0xFF8711FB //S
-#define OID_RT_PRO_H2C_GET_RATE_TABLE			0xFF8711FC //S
+#define OID_RT_PRO_H2C_SET_RATE_TABLE			0xFF8711FB /* S */
+#define OID_RT_PRO_H2C_GET_RATE_TABLE			0xFF8711FC /* S */
 #define OID_RT_PRO_H2C_C2H_LBK_TEST			0xFF8711FE
 
-#define OID_RT_PRO_ENCRYPTION_CTRL			0xFF871200 //Q, S
-#define OID_RT_PRO_ADD_STA_INFO				0xFF871201 //S
-#define OID_RT_PRO_DELE_STA_INFO			0xFF871202 //S
-#define OID_RT_PRO_QUERY_DR_VARIABLE			0xFF871203 //Q
+#define OID_RT_PRO_ENCRYPTION_CTRL			0xFF871200 /* Q, S */
+#define OID_RT_PRO_ADD_STA_INFO				0xFF871201 /* S */
+#define OID_RT_PRO_DELE_STA_INFO			0xFF871202 /* S */
+#define OID_RT_PRO_QUERY_DR_VARIABLE			0xFF871203 /* Q */
 
-#define OID_RT_PRO_RX_PACKET_TYPE			0xFF871204 //Q, S
+#define OID_RT_PRO_RX_PACKET_TYPE			0xFF871204 /* Q, S */
 
-#define OID_RT_PRO_READ_EFUSE				0xFF871205 //Q
-#define OID_RT_PRO_WRITE_EFUSE				0xFF871206 //S
-#define OID_RT_PRO_RW_EFUSE_PGPKT			0xFF871207 //Q, S
-#define OID_RT_GET_EFUSE_CURRENT_SIZE			0xFF871208 //Q
+#define OID_RT_PRO_READ_EFUSE				0xFF871205 /* Q */
+#define OID_RT_PRO_WRITE_EFUSE				0xFF871206 /* S */
+#define OID_RT_PRO_RW_EFUSE_PGPKT			0xFF871207 /* Q, S */
+#define OID_RT_GET_EFUSE_CURRENT_SIZE			0xFF871208 /* Q */
 
-#define OID_RT_SET_BANDWIDTH				0xFF871209 //S
-#define OID_RT_SET_CRYSTAL_CAP				0xFF87120A //S
+#define OID_RT_SET_BANDWIDTH				0xFF871209 /* S */
+#define OID_RT_SET_CRYSTAL_CAP				0xFF87120A /* S */
 
-#define OID_RT_SET_RX_PACKET_TYPE			0xFF87120B //S
+#define OID_RT_SET_RX_PACKET_TYPE			0xFF87120B /* S */
 
-#define OID_RT_GET_EFUSE_MAX_SIZE			0xFF87120C //Q
+#define OID_RT_GET_EFUSE_MAX_SIZE			0xFF87120C /* Q */
 
-#define OID_RT_PRO_SET_TX_AGC_OFFSET			0xFF87120D //S
+#define OID_RT_PRO_SET_TX_AGC_OFFSET			0xFF87120D /* S */
 
-#define OID_RT_PRO_SET_PKT_TEST_MODE			0xFF87120E //S
+#define OID_RT_PRO_SET_PKT_TEST_MODE			0xFF87120E /* S */
 
-#define OID_RT_PRO_FOR_EVM_TEST_SETTING			0xFF87120F //S
+#define OID_RT_PRO_FOR_EVM_TEST_SETTING			0xFF87120F /* S */
 
-#define OID_RT_PRO_GET_THERMAL_METER			0xFF871210 //Q
+#define OID_RT_PRO_GET_THERMAL_METER			0xFF871210 /* Q */
 
-#define OID_RT_RESET_PHY_RX_PACKET_COUNT		0xFF871211 //S
-#define OID_RT_GET_PHY_RX_PACKET_RECEIVED		0xFF871212 //Q
-#define OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR		0xFF871213 //Q
+#define OID_RT_RESET_PHY_RX_PACKET_COUNT		0xFF871211 /* S */
+#define OID_RT_GET_PHY_RX_PACKET_RECEIVED		0xFF871212 /* Q */
+#define OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR		0xFF871213 /* Q */
 
-#define OID_RT_SET_POWER_DOWN				0xFF871214 //S
+#define OID_RT_SET_POWER_DOWN				0xFF871214 /* S */
 
-#define OID_RT_GET_POWER_MODE				0xFF871215 //Q
+#define OID_RT_GET_POWER_MODE				0xFF871215 /* Q */
 
-#define OID_RT_PRO_EFUSE				0xFF871216 //Q, S
-#define OID_RT_PRO_EFUSE_MAP				0xFF871217 //Q, S
+#define OID_RT_PRO_EFUSE				0xFF871216 /* Q, S */
+#define OID_RT_PRO_EFUSE_MAP				0xFF871217 /* Q, S */
 
-#endif //#ifndef	__CUSTOM_OID_H
+#endif /* ifndef	__CUSTOM_OID_H */
--- a/drivers/staging/rtl8192du/include/nic_spec.h
+++ b/drivers/staging/rtl8192du/include/nic_spec.h
@@ -43,4 +43,4 @@
 #include <rtl8711_bitdef.h>
 
 
-#endif // __RTL8711_SPEC_H__
+#endif /*  __RTL8711_SPEC_H__ */
--- a/drivers/staging/rtl8192du/include/osdep_intf.h
+++ b/drivers/staging/rtl8192du/include/osdep_intf.h
@@ -28,14 +28,14 @@
 struct intf_priv {
 
 	u8 *intf_dev;
-	u32	max_iosz;	//USB2.0: 128, USB1.1: 64, SDIO:64
-	u32	max_xmitsz; //USB2.0: unlimited, SDIO:512
-	u32	max_recvsz; //USB2.0: unlimited, SDIO:512
+	u32	max_iosz;	/* USB2.0: 128, USB1.1: 64, SDIO:64 */
+	u32	max_xmitsz; /* USB2.0: unlimited, SDIO:512 */
+	u32	max_recvsz; /* USB2.0: unlimited, SDIO:512 */
 
 	volatile u8 *io_rwmem;
 	volatile u8 *allocated_io_rwmem;
-	u32	io_wsz; //unit: 4bytes
-	u32	io_rsz;//unit: 4bytes
+	u32	io_wsz; /* unit: 4bytes */
+	u32	io_rsz;/* unit: 4bytes */
 	u8 intf_status;
 
 	void (*_bus_io)(u8 *priv);
@@ -50,7 +50,7 @@ The protection mechanism is through the
 
 	_mutex ioctl_mutex;
 
-	// when in USB, IO is through interrupt in/out endpoints
+	/*  when in USB, IO is through interrupt in/out endpoints */
 	struct usb_device	*udev;
 	struct urb *piorw_urb;
 	u8 io_irp_cnt;
@@ -82,15 +82,15 @@ struct net_device *rtw_init_netdev(struc
 
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 u16 rtw_recv_select_queue(struct sk_buff *skb);
-#endif //LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35)
+#endif /* LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35) */
 
 #ifdef CONFIG_PROC_DEBUG
 void rtw_proc_init_one(struct net_device *dev);
 void rtw_proc_remove_one(struct net_device *dev);
-#else //!CONFIG_PROC_DEBUG
+#else /* CONFIG_PROC_DEBUG */
 static void rtw_proc_init_one(struct net_device *dev) {}
 static void rtw_proc_remove_one(struct net_device *dev) {}
-#endif //!CONFIG_PROC_DEBUG
+#endif /* CONFIG_PROC_DEBUG */
 
 void rtw_ips_dev_unload(struct rtw_adapter *padapter);
 #ifdef CONFIG_IPS
@@ -108,9 +108,9 @@ struct dvobj_priv;
 _adapter *rtw_drv_add_vir_if (struct rtw_adapter *primary_padapter, char *name,	void (*set_intf_ops)(struct _io_ops *pops));
 void rtw_drv_stop_vir_ifaces(struct dvobj_priv *dvobj);
 void rtw_drv_free_vir_ifaces(struct dvobj_priv *dvobj);
-#endif //CONFIG_MULTI_VIR_IFACES
+#endif /* CONFIG_MULTI_VIR_IFACES */
 #endif
 
 void rtw_ndev_destructor(struct net_device *ndev);
 
-#endif	//_OSDEP_INTF_H_
+#endif	/* _OSDEP_INTF_H_ */
--- a/drivers/staging/rtl8192du/include/osdep_service.h
+++ b/drivers/staging/rtl8192du/include/osdep_service.h
@@ -22,12 +22,10 @@
 
 #include <drv_conf.h>
 #include <basic_types.h>
-//#include <rtl871x_byteorder.h>
 
 #define _FAIL		0
 #define _SUCCESS	1
 #define RTW_RX_HANDLED 2
-//#define RTW_STATUS_TIMEDOUT -110
 
 	#include <linux/version.h>
 	#include <linux/spinlock.h>
@@ -60,16 +58,15 @@
 	#include <linux/if_arp.h>
 	#include <linux/rtnetlink.h>
 	#include <linux/delay.h>
-	#include <linux/proc_fs.h>	// Necessary because we use the proc fs
-	#include <linux/interrupt.h>	// for struct tasklet_struct
+	#include <linux/proc_fs.h>	/*  Necessary because we use the proc fs */
+	#include <linux/interrupt.h>	/*  for struct tasklet_struct */
 	#include <linux/ip.h>
 	#include <linux/kthread.h>
 
 #ifdef CONFIG_IOCTL_CFG80211
-//	#include <linux/ieee80211.h>
         #include <net/ieee80211_radiotap.h>
 	#include <net/cfg80211.h>
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
 	#include <linux/in.h>
@@ -106,7 +103,7 @@
 #endif
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
-// Porting from linux kernel, for compatible with old kernel.
+/*  Porting from linux kernel, for compatible with old kernel. */
 static inline unsigned char *skb_tail_pointer(const struct sk_buff *skb)
 {
 	return skb->tail;
@@ -213,9 +210,9 @@ static inline void _cancel_workitem_sync
 #endif
 }
 
-//
-// Global Mutex: can only be used at PASSIVE level.
-//
+/*  */
+/*  Global Mutex: can only be used at PASSIVE level. */
+/*  */
 
 #define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
 {                                                               \
@@ -277,7 +274,7 @@ static inline void rtw_netif_stop_queue(
 
 extern int RTW_STATUS_CODE(int error_code);
 
-//flags used for rtw_update_mem_stat()
+/* flags used for rtw_update_mem_stat() */
 enum {
 	MEM_STAT_VIR_ALLOC_SUCCESS,
 	MEM_STAT_VIR_ALLOC_FAIL,
@@ -285,11 +282,11 @@ enum {
 	MEM_STAT_PHY_ALLOC_SUCCESS,
 	MEM_STAT_PHY_ALLOC_FAIL,
 	MEM_STAT_PHY_FREE,
-	MEM_STAT_TX, //used to distinguish TX/RX, asigned from caller
+	MEM_STAT_TX, /* used to distinguish TX/RX, asigned from caller */
 	MEM_STAT_TX_ALLOC_SUCCESS,
 	MEM_STAT_TX_ALLOC_FAIL,
 	MEM_STAT_TX_FREE,
-	MEM_STAT_RX, //used to distinguish TX/RX, asigned from caller
+	MEM_STAT_RX, /* used to distinguish TX/RX, asigned from caller */
 	MEM_STAT_RX_ALLOC_SUCCESS,
 	MEM_STAT_RX_ALLOC_FAIL,
 	MEM_STAT_RX_FREE
@@ -450,13 +447,13 @@ static inline u32 bitshift(u32 bitmask)
 	return i;
 }
 
-//#ifdef __GNUC__
+/* ifdef __GNUC__ */
 #define STRUCT_PACKED __attribute__ ((packed))
 
-// limitation of path length
+/*  limitation of path length */
 	#define PATH_LENGTH_MAX PATH_MAX
 
-// Suspend lock prevent system from going suspend
+/*  Suspend lock prevent system from going suspend */
 #ifdef CONFIG_WAKELOCK
 #include <linux/wakelock.h>
 #elif defined(CONFIG_ANDROID_POWER)
@@ -469,7 +466,7 @@ extern void rtw_lock_suspend(void);
 extern void rtw_unlock_suspend(void);
 
 
-//Atomic integer operations
+/* Atomic integer operations */
 	#define ATOMIC_T atomic_t
 
 extern void ATOMIC_SET(ATOMIC_T *v, int i);
@@ -483,7 +480,7 @@ extern int ATOMIC_SUB_RETURN(ATOMIC_T *v
 extern int ATOMIC_INC_RETURN(ATOMIC_T *v);
 extern int ATOMIC_DEC_RETURN(ATOMIC_T *v);
 
-//File operation APIs, just for linux now
+/* File operation APIs, just for linux now */
 extern int rtw_is_file_readable(char *path);
 extern int rtw_retrive_from_file(char *path, u8* buf, u32 sz);
 extern int rtw_store_to_file(char *path, u8* buf, u32 sz);
@@ -511,9 +508,9 @@ extern void rtw_free_netdev(struct net_d
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
 #define rtw_signal_process(pid, sig) kill_pid(find_vpid((pid)),(sig), 1)
-#else //(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)) */
 #define rtw_signal_process(pid, sig) kill_proc((pid), (sig), 1)
-#endif //(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)) */
 
 extern u64 rtw_modular64(u64 x, u64 y);
 extern u64 rtw_division64(u64 x, u64 y);
--- a/drivers/staging/rtl8192du/include/rtl8192d_cmd.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_cmd.h
@@ -21,34 +21,34 @@
 #define __RTL8192D_CMD_H_
 
 
-//--------------------------------------------
-//3				Host Message Box
-//--------------------------------------------
+/*  */
+/* 3				Host Message Box */
+/*  */
 
-// User Define Message [31:8]
+/*  User Define Message [31:8] */
 
-//_SETPWRMODE_PARM
+/* _SETPWRMODE_PARM */
 #define SET_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
 #define SET_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
 #define SET_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
 
-//JOINBSSRPT_PARM
+/* JOINBSSRPT_PARM */
 #define SET_H2CCMD_JOINBSSRPT_PARM_OPMODE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
 
-//_RSVDPAGE_LOC
+/* _RSVDPAGE_LOC */
 #define SET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
 #define SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
 #define SET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
 
-//P2P_PS_OFFLOAD
+/* P2P_PS_OFFLOAD */
 
 struct P2P_PS_Offload_t {
  unsigned char Offload_En:1;
- unsigned char role:1; // 1: Owner, 0: Client
+ unsigned char role:1; /*  1: Owner, 0: Client */
  unsigned char CTWindow_En:1;
  unsigned char NoA0_En:1;
  unsigned char NoA1_En:1;
- unsigned char AllStaSleep:1; // Only valid in Owner
+ unsigned char AllStaSleep:1; /*  Only valid in Owner */
  unsigned char discovery:1;
  unsigned char rsvd:1;
 };
@@ -61,8 +61,8 @@ struct P2P_PS_Offload_t {
 #define SET_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
 #define SET_H2CCMD_P2P_PS_OFFLOAD_DISCOVERY(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
 
-// Description: Determine the types of H2C commands that are the same in driver and Fw.
-// Fisrt constructed by tynli. 2009.10.09.
+/*  Description: Determine the types of H2C commands that are the same in driver and Fw. */
+/*  Fisrt constructed by tynli. 2009.10.09. */
 enum RTL8192D_H2C_CMD {
 	H2C_AP_OFFLOAD = 0,		/*0*/
 	H2C_SETPWRMODE = 1,		/*1*/
@@ -74,30 +74,30 @@ enum RTL8192D_H2C_CMD {
 	H2C_MAC_MODE_SEL = 9,
 	H2C_PWRM=15,
 #ifdef CONFIG_WOWLAN
-	H2C_WO_WLAN_CMD = 20,	// Wake on Wlan.
-#endif // CONFIG_WOWLAN
+	H2C_WO_WLAN_CMD = 20,	/*  Wake on Wlan. */
+#endif /*  CONFIG_WOWLAN */
 	H2C_P2P_PS_CTW_CMD = 24,
-	H2C_PathDiv = 26,                  //PathDiv--NeilChen--2011.07.15
+	H2C_PathDiv = 26,                  /* PathDiv--NeilChen--2011.07.15 */
 #ifdef CONFIG_WOWLAN
-	KEEP_ALIVE_CONTROL_CMD=31, //keep alive for wake on wlan
+	KEEP_ALIVE_CONTROL_CMD=31, /* keep alive for wake on wlan */
 	DISCONNECT_DECISION_CTRL_CMD=32,
 	REMOTE_WAKE_CTRL_CMD=34,
-#endif // CONFIG_WOWLAN
+#endif /*  CONFIG_WOWLAN */
 	H2C_92D_TSF_SYNC=36,
 	H2C_92D_RESET_TSF = 43,
 	H2C_CMD_MAX
 };
 
 struct cmd_msg_parm {
-	u8 eid; //element id
-	u8 sz; // sz
+	u8 eid; /* element id */
+	u8 sz; /*  sz */
 	u8 buf[6];
 };
 
 
 void	FillH2CCmd92D(struct rtw_adapter* padapter, u8 ElementID, u32 CmdLen, u8* pCmdBuffer);
 
-// host message to firmware cmd
+/*  host message to firmware cmd */
 void	rtl8192d_set_FwPwrMode_cmd(struct rtw_adapter*padapter, u8 Mode);
 void	rtl8192d_set_FwJoinBssReport_cmd(struct rtw_adapter* padapter, u8 mstatus);
 u8	rtl8192d_set_rssi_cmd(struct rtw_adapter*padapter, u8 *param);
@@ -105,11 +105,11 @@ u8	rtl8192d_set_raid_cmd(struct rtw_adap
 void	rtl8192d_Add_RateATid(struct rtw_adapter * pAdapter, u32 bitmap, u8 arg);
 #ifdef CONFIG_P2P
 void	rtl8192d_set_p2p_ps_offload_cmd(struct rtw_adapter* padapter, u8 p2p_ps_state);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 int reset_tsf(struct rtw_adapter * Adapter, u8 reset_port);
-#endif	// CONFIG_TSF_RESET_OFFLOAD
+#endif	/*  CONFIG_TSF_RESET_OFFLOAD */
 
 #ifdef CONFIG_WOWLAN
 struct set_wowlan_parm {
@@ -134,6 +134,6 @@ struct set_wowlan_parm {
 
 void rtl8192d_set_wowlan_cmd(struct rtw_adapter* padapter);
 void SetFwRelatedForWoWLAN8192DU(struct rtw_adapter*	padapter,u8 bHostIsGoingtoSleep);
-#endif // CONFIG_WOWLAN
+#endif /*  CONFIG_WOWLAN */
 
-#endif	// __RTL8192D_CMD_H_
+#endif	/*  __RTL8192D_CMD_H_ */
--- a/drivers/staging/rtl8192du/include/rtl8192d_dm.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_dm.h
@@ -19,22 +19,22 @@
  ******************************************************************************/
 #ifndef	__RTL8192D_DM_H__
 #define __RTL8192D_DM_H__
-//============================================================
-// Description:
-//
-// This file is for 92CE/92CU dynamic mechanism only
-//
-//
-//============================================================
-//============================================================
-// Global var
-//============================================================
+/*  */
+/*  Description: */
+/*  */
+/*  This file is for 92CE/92CU dynamic mechanism only */
+/*  */
+/*  */
+/*  */
+/*  */
+/*  Global var */
+/*  */
 
 extern u32 EDCAParam[maxAP][3] ;
 
-//============================================================
-// structure and define
-//============================================================
+/*  */
+/*  structure and define */
+/*  */
 
 struct FALSE_ALARM_STATISTICS {
 	u32	Cnt_Parity_Fail;
@@ -146,17 +146,17 @@ enum DM_DIG_CONNECT_E {
 #define		DM_FALSEALARM_THRESH_HIGH	1000
 
 #define		DM_DIG_MAX					0x3e
-#define		DM_DIG_MIN					0x1e //0x22//0x1c
+#define		DM_DIG_MIN					0x1e
 
 #define		DM_DIG_FA_UPPER				0x32
 #define		DM_DIG_FA_LOWER				0x20
 
-//vivi 92c&92d has different definition, 20110504
-//this is for 92c
-#define		DM_DIG_FA_TH0				0x200//0x20
-#define		DM_DIG_FA_TH1				0x300//0x100
-#define		DM_DIG_FA_TH2				0x400//0x200
-//this is for 92d
+/* vivi 92c&92d has different definition, 20110504 */
+/* this is for 92c */
+#define		DM_DIG_FA_TH0				0x200/* 0x20 */
+#define		DM_DIG_FA_TH1				0x300/* 0x100 */
+#define		DM_DIG_FA_TH2				0x400/* 0x200 */
+/* this is for 92d */
 #define		DM_DIG_FA_TH0_92D			0x100
 #define		DM_DIG_FA_TH1_92D			0x150
 #define		DM_DIG_FA_TH2_92D			0x250
@@ -178,7 +178,7 @@ enum DM_DIG_CONNECT_E {
 
 #define		WAIotTHVal						25
 
-//Dynamic Tx Power Control Threshold
+/* Dynamic Tx Power Control Threshold */
 #define		TX_POWER_NEAR_FIELD_THRESH_LVL2	74
 #define		TX_POWER_NEAR_FIELD_THRESH_LVL1	67
 
@@ -212,9 +212,9 @@ struct rate_adaptive {
 	u32				LowRSSIThresholdRATR;
 	u32				LowRSSIThresholdRATR40M;
 	u32				LowRSSIThresholdRATR20M;
-	u8				PingRSSIEnable;	//cosa add for Netcore long range ping issue
-	u32				PingRSSIRATR;	//cosa add for Netcore long range ping issue
-	u32				PingRSSIThreshForRA;//cosa add for Netcore long range ping issue
+	u8				PingRSSIEnable;	/* cosa add for Netcore long range ping issue */
+	u32				PingRSSIRATR;	/* cosa add for Netcore long range ping issue */
+	u32				PingRSSIThreshForRA;/* cosa add for Netcore long range ping issue */
 	u32				LastRATR;
 	u8				PreRATRState;
 };
@@ -225,11 +225,11 @@ enum DM_SWAS_E {
 	Antenna_MAX = 3,
 };
 
-// 20100514 Joseph: Add definition for antenna switching test after link.
-// This indicates two different the steps.
-// In SWAW_STEP_PEAK, driver needs to switch antenna and listen to the signal on the air.
-// In SWAW_STEP_DETERMINE, driver just compares the signal captured in SWAW_STEP_PEAK
-// with original RSSI to determine if it is necessary to switch antenna.
+/*  20100514 Joseph: Add definition for antenna switching test after link. */
+/*  This indicates two different the steps. */
+/*  In SWAW_STEP_PEAK, driver needs to switch antenna and listen to the signal on the air. */
+/*  In SWAW_STEP_DETERMINE, driver just compares the signal captured in SWAW_STEP_PEAK */
+/*  with original RSSI to determine if it is necessary to switch antenna. */
 #define SWAW_STEP_PEAK		0
 #define SWAW_STEP_DETERMINE	1
 
@@ -238,10 +238,10 @@ enum DM_SWAS_E {
 #define	TRAFFIC_LOW	0
 #define	TRAFFIC_HIGH	1
 
-//=============================
-//Neil Chen---2011--06--15--
-//==============================
-//3 PathDiv
+/*  */
+/* Neil Chen---2011--06--15-- */
+/*  */
+/* 3 PathDiv */
 struct sw_antenna_switch {
 	u8		try_flag;
 	s32		PreRSSI;
@@ -252,32 +252,31 @@ struct sw_antenna_switch {
 	u8		bTriggerAntennaSwitch;
 	u8		SelectAntennaMap;
 
-	// Before link Antenna Switch check
+	/*  Before link Antenna Switch check */
 	u8		SWAS_NoLink_State;
 	u32		SWAS_NoLink_BK_Reg860;
 };
 
-//========================================
+/*  */
 
 struct	dm_priv
 {
 	u8	DM_Type;
 	u8	DMFlag, DMFlag_tmp;
 
-	//for DIG
+	/* for DIG */
 	u8	bDMInitialGainEnable;
-	//u8	binitialized; // for dm_initial_gain_Multi_STA use.
 	struct DIG_T	DM_DigTable;
 
 	struct PS_T	DM_PSTable;
 
 	struct FALSE_ALARM_STATISTICS	falsealmcnt;
 
-	//for rate adaptive, in fact,  88c/92c fw will handle this
+	/* for rate adaptive, in fact,  88c/92c fw will handle this */
 	u8	bUseRAMask;
 	struct rate_adaptive RateAdaptive;
 
-	//* Upper and Lower Signal threshold for Rate Adaptive*/
+	/* Upper and Lower Signal threshold for Rate Adaptive*/
 	int	UndecoratedSmoothedPWDB;
 	int	EntryMinUndecoratedSmoothedPWDB;
 	int	EntryMaxUndecoratedSmoothedPWDB;
@@ -293,19 +292,19 @@ struct	dm_priv
 	u8	CurTxHighLvlForAnotherMacOfDMSP;
 #endif
 
-	//for High Power
+	/* for High Power */
 	u8	bDynamicTxPowerEnable;
 	u8	LastDTPLvl;
-	u8	DynamicTxHighPowerLvl;//Add by Jacken Tx Power Control for Near/Far Range 2008/03/06
+	u8	DynamicTxHighPowerLvl;/* Add by Jacken Tx Power Control for Near/Far Range 2008/03/06 */
 
-	//for tx power tracking
+	/* for tx power tracking */
 	u8	bTXPowerTracking;
 	u8	TXPowercount;
 	u8	bTXPowerTrackingInit;
-	u8	TxPowerTrackControl;	//for mp mode, turn off txpwrtracking as default
+	u8	TxPowerTrackControl;	/* for mp mode, turn off txpwrtracking as default */
 	u8	TM_Trigger;
 
-	u8	ThermalMeter[2];	// ThermalMeter, index 0 for RFIC0, and 1 for RFIC1
+	u8	ThermalMeter[2];	/*  ThermalMeter, index 0 for RFIC0, and 1 for RFIC1 */
 	u8	ThermalValue;
 	u8	ThermalValue_LCK;
 	u8	ThermalValue_IQK;
@@ -319,8 +318,8 @@ struct	dm_priv
 	u8	bReloadtxpowerindex;
 	u8	bDoneTxpower;
 
-	//for APK
-	u32	APKoutput[2][2];	//path A/B; output1_1a/output1_2a
+	/* for APK */
+	u32	APKoutput[2][2];	/* path A/B; output1_1a/output1_2a */
 	u8	bAPKdone;
 	u8	bAPKThermalMeterIgnore;
 	bool		bDPKdone[2];
@@ -331,7 +330,7 @@ struct	dm_priv
 
 	u32	RegA24;
 
-	//for IQK
+	/* for IQK */
 	u32	Reg874;
 	u32	RegC08;
 	u32	Reg88C;
@@ -346,13 +345,11 @@ struct	dm_priv
 	u8	bCCKinCH14;
 
 	char	CCK_index;
-	//u8 Record_CCK_20Mindex;
-	//u8 Record_CCK_40Mindex;
 	char	OFDM_index[2];
 
 	struct sw_antenna_switch DM_SWAT_Table;
 
-	//for TxPwrTracking
+	/* for TxPwrTracking */
 	int	RegE94;
 	int	RegE9C;
 	int	RegEB4;
@@ -361,13 +358,13 @@ struct	dm_priv
 	u8	RegC04_MP;
 	u32	RegD04_MP;
 #endif
-	u32	TXPowerTrackingCallbackCnt;	//cosa add for debug
+	u32	TXPowerTrackingCallbackCnt;	/* cosa add for debug */
 
-	u32	prv_traffic_idx; // edca turbo
+	u32	prv_traffic_idx; /*  edca turbo */
 
-	u32	RegRF3C[2];	//pathA / pathB
+	u32	RegRF3C[2];	/* pathA / pathB */
 
-	// Add for Reading Initial Data Rate SEL Register 0x484 during watchdog. Using for fill tx desc. 2011.3.21 by Thomas
+	/*  Add for Reading Initial Data Rate SEL Register 0x484 during watchdog. Using for fill tx desc. 2011.3.21 by Thomas */
 	u8	INIDATA_RATE[32];
 };
 
@@ -375,12 +372,12 @@ struct	dm_priv
 /*------------------------Export global variable----------------------------*/
 /*------------------------Export global variable----------------------------*/
 /*------------------------Export Marco Definition---------------------------*/
-//#define DM_MultiSTA_InitGainChangeNotify(Event) {DM_DigTable.CurMultiSTAConnectState = Event;}
+/* define DM_MultiSTA_InitGainChangeNotify(Event) {DM_DigTable.CurMultiSTAConnectState = Event;} */
 
 
-//============================================================
-// function prototype
-//============================================================
+/*  */
+/*  function prototype */
+/*  */
 void rtl8192d_init_dm_priv(struct rtw_adapter * Adapter);
 void rtl8192d_deinit_dm_priv(struct rtw_adapter * Adapter);
 void	rtl8192d_InitHalDm(struct rtw_adapter * Adapter);
@@ -388,4 +385,4 @@ void	rtl8192d_HalDmWatchDog(struct rtw_a
 
 void rtl8192d_dm_CheckTXPowerTracking(struct rtw_adapter * Adapter);
 
-#endif	//__HAL8190PCIDM_H__
+#endif	/* __HAL8190PCIDM_H__ */
--- a/drivers/staging/rtl8192du/include/rtl8192d_hal.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_hal.h
@@ -50,7 +50,6 @@
 #define TARGET_CHNL_NUM_2G_5G	59
 #define CV_CURVE_CNT			64
 
-//static u32	 RF_REG_FOR_5G_SWCHNL[MAX_RF_IMR_INDEX]={0,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x38,0x39,0x0};
 static u32	   RF_REG_FOR_5G_SWCHNL_NORMAL[MAX_RF_IMR_INDEX_NORMAL]={0,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x0};
 
 static u8	RF_REG_for_C_CUT_5G[RF_REG_NUM_for_C_CUT_5G] =
@@ -66,7 +65,7 @@ static u32	RF_REG_MASK_for_C_CUT_2G[RF_R
 			{BIT19|BIT18|BIT17|BIT14|BIT1,	BIT10|BIT9,
 			BIT18|BIT17|BIT16|BIT1,		BIT2|BIT1,
 			BIT15|BIT14|BIT13|BIT12|BIT11};
-#endif	//amy, temp remove
+#endif	/* amy, temp remove */
 static u8	RF_CHNL_5G[RF_CHNL_NUM_5G] =
 			{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140};
 static u8	RF_CHNL_5G_40M[RF_CHNL_NUM_5G_40M] =
@@ -95,16 +94,14 @@ static u32	RF_REG_Param_for_C_CUT_5G_int
 
 
 
-//[mode][patha+b][reg]
+/* mode][patha+b][reg] */
 static u32 RF_IMR_Param_Normal[1][3][MAX_RF_IMR_INDEX_NORMAL]={{
-	{0x70000,0x00ff0,0x4400f,0x00ff0,0x0,0x0,0x0,0x0,0x0,0x64888,0xe266c,0x00090,0x22fff},// channel 1-14.
-	{0x70000,0x22880,0x4470f,0x55880,0x00070, 0x88000, 0x0,0x88080,0x70000,0x64a82,0xe466c,0x00090,0x32c9a}, //path 36-64
-	{0x70000,0x44880,0x4477f,0x77880,0x00070, 0x88000, 0x0,0x880b0,0x0,0x64b82,0xe466c,0x00090,0x32c9a} //100 -165
+	{0x70000,0x00ff0,0x4400f,0x00ff0,0x0,0x0,0x0,0x0,0x0,0x64888,0xe266c,0x00090,0x22fff},/*  channel 1-14. */
+	{0x70000,0x22880,0x4470f,0x55880,0x00070, 0x88000, 0x0,0x88080,0x70000,0x64a82,0xe466c,0x00090,0x32c9a}, /* path 36-64 */
+	{0x70000,0x44880,0x4477f,0x77880,0x00070, 0x88000, 0x0,0x880b0,0x0,0x64b82,0xe466c,0x00090,0x32c9a} /* 100 -165 */
 }
 };
 
-//static u32 CurveIndex_5G[TARGET_CHNL_NUM_5G]={0};
-//static u32 CurveIndex_2G[TARGET_CHNL_NUM_2G]={0};
 static u32 CurveIndex[TARGET_CHNL_NUM_2G_5G]={0};
 
 static u32 TargetChnl_5G[TARGET_CHNL_NUM_5G] = {
@@ -154,7 +151,7 @@ static u32 TargetChnl_5G[TARGET_CHNL_NUM
 25292,	25267,	25242,	25216,	25191,
 25166	};
 
-static u32 TargetChnl_2G[TARGET_CHNL_NUM_2G] = {	// channel 1~14
+static u32 TargetChnl_2G[TARGET_CHNL_NUM_2G] = {	/*  channel 1~14 */
 26084, 26030, 25976, 25923, 25869, 25816, 25764,
 25711, 25658, 25606, 25554, 25502, 25451, 25328
 };
@@ -164,12 +161,12 @@ static u32 TargetChnl_2G[TARGET_CHNL_NUM
 
 #ifdef CONFIG_WOWLAN
 	#include "Hal8192DUHWImg_wowlan.h"
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 	#define RTL819X_DEFAULT_RF_TYPE		RF_1T2R
 
-//---------------------------------------------------------------------
-//		RTL8192DU From file
-//---------------------------------------------------------------------
+/*  */
+/* 		RTL8192DU From file */
+/*  */
 	#define RTL8192D_FW_IMG					"rtl8192DU\\rtl8192dfw.bin"
 
 	#define RTL8192D_PHY_REG					"rtl8192DU\\PHY_REG.txt"
@@ -185,16 +182,16 @@ static u32 TargetChnl_2G[TARGET_CHNL_NUM
 	#define RTL8192D_PHY_RADIO_B_intPA		"rtl8192DU\\radio_b_intPA.txt"
 	#define RTL8192D_PHY_MACREG				"rtl8192DU\\MAC_REG.txt"
 
-//---------------------------------------------------------------------
-//		RTL8192DU From header
-//---------------------------------------------------------------------
+/*  */
+/* 		RTL8192DU From header */
+/*  */
 
-	// Fw Array
+	/*  Fw Array */
 	#define Rtl8192D_FwImageArray					Rtl8192DUFwImgArray
 #ifdef CONFIG_WOWLAN
 	#define Rtl8192D_FwWWImageArray				Rtl8192DUFwWWImgArray
-#endif //CONFIG_WOWLAN
-	// MAC/BB/PHY Array
+#endif /* CONFIG_WOWLAN */
+	/*  MAC/BB/PHY Array */
 	#define Rtl8192D_MAC_Array						Rtl8192DUMAC_2T_Array
 	#define Rtl8192D_AGCTAB_Array					Rtl8192DUAGCTAB_Array
 	#define Rtl8192D_AGCTAB_5GArray				Rtl8192DUAGCTAB_5GArray
@@ -212,7 +209,7 @@ static u32 TargetChnl_2G[TARGET_CHNL_NUM
 	#define Rtl8192D_RadioA_2T_intPAArray			Rtl8192DURadioA_2T_intPAArray
 	#define Rtl8192D_RadioB_2T_intPAArray			Rtl8192DURadioB_2T_intPAArray
 
-	// Array length
+	/*  Array length */
 	#define Rtl8192D_FwImageArrayLength			Rtl8192DUImgArrayLength
 	#define Rtl8192D_MAC_ArrayLength				Rtl8192DUMAC_2T_ArrayLength
 	#define Rtl8192D_AGCTAB_5GArrayLength			Rtl8192DUAGCTAB_5GArrayLength
@@ -229,15 +226,15 @@ static u32 TargetChnl_2G[TARGET_CHNL_NUM
 	#define Rtl8192D_RadioA_2T_intPAArrayLength		Rtl8192DURadioA_2T_intPAArrayLength
 	#define Rtl8192D_RadioB_2T_intPAArrayLength		Rtl8192DURadioB_2T_intPAArrayLength
 
-	// The file name "_2T" is for 92CU, "_1T"  is for 88CU. Modified by tynli. 2009.11.24.
+	/*  The file name "_2T" is for 92CU, "_1T"  is for 88CU. Modified by tynli. 2009.11.24. */
 
-#define DRVINFO_SZ	4 // unit is 8bytes
+#define DRVINFO_SZ	4 /*  unit is 8bytes */
 #define PageNum_128(_Len)		(u32)(((_Len)>>7) + ((_Len)&0x7F ? 1:0))
 
-//
-// Check if FW header exists. We do not consider the lower 4 bits in this case.
-// By tynli. 2009.12.04.
-//
+/*  */
+/*  Check if FW header exists. We do not consider the lower 4 bits in this case. */
+/*  By tynli. 2009.12.04. */
+/*  */
 #define IS_FW_HEADER_EXIST(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature)&0xFFF0) == 0x92C0 ||\
 					(le16_to_cpu(_pFwHdr->Signature)&0xFFF0) == 0x88C0 ||\
 					(le16_to_cpu(_pFwHdr->Signature)&0xFFFF) == 0x92D0 ||\
@@ -245,15 +242,15 @@ static u32 TargetChnl_2G[TARGET_CHNL_NUM
 					(le16_to_cpu(_pFwHdr->Signature)&0xFFFF) == 0x92D2 ||\
 					(le16_to_cpu(_pFwHdr->Signature)&0xFFFF) == 0x92D3)
 
-#define FW_8192D_SIZE				0x8020 // Max FW len = 32k + 32(FW header length).
+#define FW_8192D_SIZE				0x8020 /*  Max FW len = 32k + 32(FW header length). */
 #define FW_8192D_START_ADDRESS	0x1000
 #define FW_8192D_END_ADDRESS		0x1FFF
 
-#define MAX_PAGE_SIZE				4096	// @ page : 4k bytes
+#define MAX_PAGE_SIZE				4096	/*  @ page : 4k bytes */
 
 enum FIRMWARE_SOURCE {
 	FW_SOURCE_IMG_FILE = 0,
-	FW_SOURCE_HEADER_FILE = 1,              //from header file
+	FW_SOURCE_HEADER_FILE = 1,              /* from header file */
 };
 
 struct RT_FIRMWARE_92D {
@@ -263,37 +260,37 @@ struct RT_FIRMWARE_92D {
 #ifdef CONFIG_WOWLAN
 	u8*			szWoWLANFwBuffer;
 	u32			ulWoWLANFwLength;
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 };
 
-//
-// This structure must be cared byte-ordering
-//
-// Added by tynli. 2009.12.04.
-struct rt_8192d_firmware_hdr { //8-byte alinment required
-
-	//--- LONG WORD 0 ----
-	u16		Signature;	// 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut
-	u8		Category;	// AP/NIC and USB/PCI
-	u8		Function;	// Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
-	u16		Version;		// FW Version
-	u8		Subversion;	// FW Subversion, default 0x00
+/*  */
+/*  This structure must be cared byte-ordering */
+/*  */
+/*  Added by tynli. 2009.12.04. */
+struct rt_8192d_firmware_hdr { /* 8-byte alinment required */
+
+	/*  LONG WORD 0 ---- */
+	u16		Signature;	/*  92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut */
+	u8		Category;	/*  AP/NIC and USB/PCI */
+	u8		Function;	/*  Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions */
+	u16		Version;		/*  FW Version */
+	u8		Subversion;	/*  FW Subversion, default 0x00 */
 	u8		Rsvd1;
 
 
-	//--- LONG WORD 1 ----
-	u8		Month;	// Release time Month field
-	u8		Date;	// Release time Date field
-	u8		Hour;	// Release time Hour field
-	u8		Minute;	// Release time Minute field
-	u16		RamCodeSize;	// The size of RAM code
+	/*  LONG WORD 1 ---- */
+	u8		Month;	/*  Release time Month field */
+	u8		Date;	/*  Release time Date field */
+	u8		Hour;	/*  Release time Hour field */
+	u8		Minute;	/*  Release time Minute field */
+	u16		RamCodeSize;	/*  The size of RAM code */
 	u16		Rsvd2;
 
-	//--- LONG WORD 2 ----
-	u32		SvnIdx;	// The SVN entry index
+	/*  LONG WORD 2 ---- */
+	u32		SvnIdx;	/*  The SVN entry index */
 	u32		Rsvd3;
 
-	//--- LONG WORD 3 ----
+	/*  LONG WORD 3 ---- */
 	u32		Rsvd4;
 	u32		Rsvd5;
 };
@@ -301,7 +298,7 @@ struct rt_8192d_firmware_hdr { //8-byte
 #define DRIVER_EARLY_INT_TIME		0x05
 #define BCN_DMA_ATIME_INT_TIME		0x02
 
-//Added for 92D IQK setting.
+/* Added for 92D IQK setting. */
 struct iqk_matrix_regs_setting {
 	bool		bIQKDone;
 	int		Value[1][IQK_Matrix_REG_NUM];
@@ -316,28 +313,28 @@ enum USB_RX_AGG_MODE {
 	USB_RX_AGG_DMA_USB
 };
 
-#define MAX_RX_DMA_BUFFER_SIZE	10240		// 10K for 8192C RX DMA buffer
+#define MAX_RX_DMA_BUFFER_SIZE	10240		/*  10K for 8192C RX DMA buffer */
 
 #endif
 
 
-#define TX_SELE_HQ			BIT(0)		// High Queue
-#define TX_SELE_LQ			BIT(1)		// Low Queue
-#define TX_SELE_NQ			BIT(2)		// Normal Queue
+#define TX_SELE_HQ			BIT(0)		/*  High Queue */
+#define TX_SELE_LQ			BIT(1)		/*  Low Queue */
+#define TX_SELE_NQ			BIT(2)		/*  Normal Queue */
 
 
-// Note: We will divide number of page equally for each queue other than public queue!
+/*  Note: We will divide number of page equally for each queue other than public queue! */
 
 #define TX_TOTAL_PAGE_NUMBER		0xF8
 #define TX_PAGE_BOUNDARY			(TX_TOTAL_PAGE_NUMBER + 1)
 
-// For Normal Chip Setting
-// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER
+/*  For Normal Chip Setting */
+/*  (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER */
 #define NORMAL_PAGE_NUM_PUBQ		0x56
 
 
-// For Test Chip Setting
-// (HPQ + LPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER
+/*  For Test Chip Setting */
+/*  (HPQ + LPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER */
 #define TEST_PAGE_NUM_PUBQ			0x89
 #define TX_TOTAL_PAGE_NUMBER_92D_DUAL_MAC		0x7A
 #define NORMAL_PAGE_NUM_PUBQ_92D_DUAL_MAC			0x5A
@@ -347,52 +344,52 @@ enum USB_RX_AGG_MODE {
 
 #define TX_PAGE_BOUNDARY_DUAL_MAC			(TX_TOTAL_PAGE_NUMBER_92D_DUAL_MAC + 1)
 
-// For Test Chip Setting
+/*  For Test Chip Setting */
 #define WMM_TEST_TX_TOTAL_PAGE_NUMBER	0xF5
-#define WMM_TEST_TX_PAGE_BOUNDARY	(WMM_TEST_TX_TOTAL_PAGE_NUMBER + 1) //F6
+#define WMM_TEST_TX_PAGE_BOUNDARY	(WMM_TEST_TX_TOTAL_PAGE_NUMBER + 1) /* F6 */
 
 #define WMM_TEST_PAGE_NUM_PUBQ		0xA3
 #define WMM_TEST_PAGE_NUM_HPQ		0x29
 #define WMM_TEST_PAGE_NUM_LPQ		0x29
 
 
-//Note: For Normal Chip Setting ,modify later
+/* Note: For Normal Chip Setting ,modify later */
 #define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER	0xF5
-#define WMM_NORMAL_TX_PAGE_BOUNDARY	(WMM_TEST_TX_TOTAL_PAGE_NUMBER + 1) //F6
+#define WMM_NORMAL_TX_PAGE_BOUNDARY	(WMM_TEST_TX_TOTAL_PAGE_NUMBER + 1) /* F6 */
 
 #define WMM_NORMAL_PAGE_NUM_PUBQ		0xB0
 #define WMM_NORMAL_PAGE_NUM_HPQ		0x29
 #define WMM_NORMAL_PAGE_NUM_LPQ			0x1C
 #define WMM_NORMAL_PAGE_NUM_NPQ		0x1C
 
-#define WMM_NORMAL_PAGE_NUM_PUBQ_92D		0X65//0x82
-#define WMM_NORMAL_PAGE_NUM_HPQ_92D		0X30//0x29
+#define WMM_NORMAL_PAGE_NUM_PUBQ_92D		0X65/* 0x82 */
+#define WMM_NORMAL_PAGE_NUM_HPQ_92D		0X30/* 0x29 */
 #define WMM_NORMAL_PAGE_NUM_LPQ_92D		0X30
 #define WMM_NORMAL_PAGE_NUM_NPQ_92D		0X30
 
-//-------------------------------------------------------------------------
-//	Chip specific
-//-------------------------------------------------------------------------
+/*  */
+/* 	Chip specific */
+/*  */
 
 #define CHIP_BONDING_IDENTIFIER(_value)	(((_value)>>22)&0x3)
 #define CHIP_BONDING_92C_1T2R	0x1
 #define CHIP_BONDING_88C_USB_MCARD	0x2
 #define CHIP_BONDING_88C_USB_HP	0x1
 
-//
-// 2011.01.06. Define new structure of chip version for RTL8723 and so on. Added by tynli.
-//
+/*  */
+/*  2011.01.06. Define new structure of chip version for RTL8723 and so on. Added by tynli. */
+/*  */
 /*
      | BIT15:12           |  BIT11:8        | BIT 7              |  BIT6:4  |      BIT3          | BIT2:0  |
      |-------------+-----------+-----------+-------+-----------+-------|
      | IC version(CUT)  | ROM version  | Manufacturer  | RF type  |  Chip type       | IC Type |
      |                           |                      | TSMC/UMC    |              | TEST/NORMAL|             |
 */
-// [15:12] IC version(CUT): A-cut=0, B-cut=1, C-cut=2, D-cut=3
-// [7] Manufacturer: TSMC=0, UMC=1
-// [6:4] RF type: 1T1R=0, 1T2R=1, 2T2R=2
-// [3] Chip type: TEST=0, NORMAL=1
-// [2:0] IC type: 81xxC=0, 8723=1, 92D=2
+/*  [15:12] IC version(CUT): A-cut=0, B-cut=1, C-cut=2, D-cut=3 */
+/*  [7] Manufacturer: TSMC=0, UMC=1 */
+/*  [6:4] RF type: 1T1R=0, 1T2R=1, 2T2R=2 */
+/*  [3] Chip type: TEST=0, NORMAL=1 */
+/*  [2:0] IC type: 81xxC=0, 8723=1, 92D=2 */
 
 #define CHIP_8723						BIT(0)
 #define CHIP_92D						BIT(1)
@@ -407,7 +404,7 @@ enum USB_RX_AGG_MODE {
 #define E_CUT_VERSION					BIT(14)
 
 
-// MASK
+/*  MASK */
 #define IC_TYPE_MASK					(BIT(0)|BIT(1)|BIT(2))
 #define CHIP_TYPE_MASK				BIT(3)
 #define RF_TYPE_MASK					(BIT(4)|BIT(5)|BIT(6))
@@ -415,7 +412,7 @@ enum USB_RX_AGG_MODE {
 #define ROM_VERSION_MASK				(BIT(11)|BIT(10)|BIT(9)|BIT(8))
 #define CUT_VERSION_MASK				(BIT(15)|BIT(14)|BIT(13)|BIT(12))
 
-// Get element
+/*  Get element */
 #define GET_CVID_IC_TYPE(version)			((version) & IC_TYPE_MASK)
 #define GET_CVID_CHIP_TYPE(version)			((version) & CHIP_TYPE_MASK)
 #define GET_CVID_RF_TYPE(version)			((version) & RF_TYPE_MASK)
@@ -434,7 +431,7 @@ enum USB_RX_AGG_MODE {
 #define IS_92C_SERIAL(version)					((IS_81XXC(version) && IS_2T2R(version)) ? true : false)
 #define IS_VENDOR_UMC_A_CUT(version)		((IS_CHIP_VENDOR_UMC(version)) ? ((GET_CVID_CUT_VERSION(version)) ? false : true) : false)
 #define IS_VENDOR_8723_A_CUT(version)		((IS_8723_SERIES(version)) ? ((GET_CVID_CUT_VERSION(version)) ? false : true) : false)
-// <tynli_Note> 88/92C UMC B-cut vendor is set to TSMC so we need to check CHIP_VENDOR_UMC bit is not 1.
+/*  <tynli_Note> 88/92C UMC B-cut vendor is set to TSMC so we need to check CHIP_VENDOR_UMC bit is not 1. */
 #define IS_81xxC_VENDOR_UMC_B_CUT(version)	((IS_CHIP_VENDOR_UMC(version)) ? ((GET_CVID_CUT_VERSION(version) == B_CUT_VERSION) ? true : false):false)
 #define IS_92D_SINGLEPHY(version)			((IS_92D(version)) ? (IS_2T2R(version) ? true: false) : false)
 
@@ -471,9 +468,9 @@ enum VERSION_8192D {
 };
 
 
-//-------------------------------------------------------------------------
-//	Channel Plan
-//-------------------------------------------------------------------------
+/*  */
+/* 	Channel Plan */
+/*  */
 enum ChannelPlan{
 	CHPL_FCC	= 0,
 	CHPL_IC		= 1,
@@ -498,7 +495,7 @@ struct tx_power_info {
 	u8 HT20MaxOffset[RF_PATH_MAX][CHANNEL_GROUP_MAX];
 	u8 TSSI_A[3];
 	u8 TSSI_B[3];
-	u8 TSSI_A_5G[3];		//5GL/5GM/5GH
+	u8 TSSI_A_5G[3];		/* 5GL/5GM/5GH */
 	u8 TSSI_B_5G[3];
 };
 
@@ -506,11 +503,11 @@ struct tx_power_info {
 #define EFUSE_MAP_LEN				256
 #define EFUSE_MAX_SECTION			32
 #define EFUSE_MAX_SECTION_BASE	16
-// <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section
-// 9bytes + 1byt + 5bytes and pre 1byte.
-// For worst case:
-// | 2byte|----8bytes----|1byte|--7bytes--| //92D
-#define EFUSE_OOB_PROTECT_BYTES		18 // PG data exclude header, dummy 7 bytes frome CP test and reserved 1byte.
+/*  <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section */
+/*  9bytes + 1byt + 5bytes and pre 1byte. */
+/*  For worst case: */
+/*  | 2byte|----8bytes----|1byte|--7bytes--| 92D */
+#define EFUSE_OOB_PROTECT_BYTES		18 /*  PG data exclude header, dummy 7 bytes frome CP test and reserved 1byte. */
 
 enum PA_MODE {
 	PA_MODE_EXTERNAL = 0x00,
@@ -537,9 +534,9 @@ enum c2h_id_8192d {
 struct hal_data_8192du {
 	enum VERSION_8192D	VersionID;
 
-	// add for 92D Phy mode/mac/Band mode
+	/*  add for 92D Phy mode/mac/Band mode */
 	enum MACPHY_MODE_8192D	MacPhyMode92D;
-	enum BAND_TYPE	CurrentBandType92D;	//0:2.4G, 1:5G
+	enum BAND_TYPE	CurrentBandType92D;	/* 0:2.4G, 1:5G */
 	enum BAND_TYPE	BandSet92D;
 	bool		bIsVS;
 
@@ -558,22 +555,22 @@ struct hal_data_8192du {
 	u16	FirmwareVersionRev;
 	u16	FirmwareSubVersion;
 
-	//current WIFI_PHY values
+	/* current WIFI_PHY values */
 	u32	ReceiveConfig;
 	enum WIRELESS_MODE	CurrentWirelessMode;
 	enum HT_CHANNEL_WIDTH	CurrentChannelBW;
 	u8	CurrentChannel;
-	u8	nCur40MhzPrimeSC;// Control channel sub-carrier
+	u8	nCur40MhzPrimeSC;/*  Control channel sub-carrier */
 	u16	BasicRateSet;
 
-	//rf_ctrl
+	/* rf_ctrl */
 	u8	rf_chip;
 	u8	rf_type;
 	u8	NumTotalRFPath;
 
-	//
-	// EEPROM setting.
-	//
+	/*  */
+	/*  EEPROM setting. */
+	/*  */
 	u8	EEPROMVersion;
 	u16	EEPROMVID;
 	u16	EEPROMPID;
@@ -590,23 +587,23 @@ struct hal_data_8192du {
 	u8	PAMode;
 
 	u8	TxPwrLevelCck[RF_PATH_MAX][CHANNEL_MAX_NUMBER_2G];
-	u8	TxPwrLevelHT40_1S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
-	u8	TxPwrLevelHT40_2S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
-	s8	TxPwrHt20Diff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];// HT 20<->40 Pwr diff
-	u8	TxPwrLegacyHtDiff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];// For HT<->legacy pwr diff
-	// For power group
+	u8	TxPwrLevelHT40_1S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	/*  For HT 40MHZ pwr */
+	u8	TxPwrLevelHT40_2S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	/*  For HT 40MHZ pwr */
+	s8	TxPwrHt20Diff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];/*  HT 20<->40 Pwr diff */
+	u8	TxPwrLegacyHtDiff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];/*  For HT<->legacy pwr diff */
+	/*  For power group */
 	u8	PwrGroupHT20[RF_PATH_MAX][CHANNEL_MAX_NUMBER];
 	u8	PwrGroupHT40[RF_PATH_MAX][CHANNEL_MAX_NUMBER];
 
-	u8	LegacyHTTxPowerDiff;// Legacy to HT rate power diff
+	u8	LegacyHTTxPowerDiff;/*  Legacy to HT rate power diff */
 
-	u8	CrystalCap;	// CrystalCap.
+	u8	CrystalCap;	/*  CrystalCap. */
 
 #ifdef CONFIG_BT_COEXIST
 	struct btcoexist_priv	bt_coexist;
 #endif
 
-	// Read/write are allow for following hardware information variables
+	/*  Read/write are allow for following hardware information variables */
 	u8	framesync;
 	u32	framesyncC34;
 	u8	framesyncMonitor;
@@ -615,23 +612,23 @@ struct hal_data_8192du {
 	u32	MCSTxPowerLevelOriginalOffset[MAX_PG_GROUP][16];
 	u32	CCKTxPowerLevelOriginalOffset;
 
-	u32	AntennaTxPath;					// Antenna path Tx
-	u32	AntennaRxPath;					// Antenna path Rx
+	u32	AntennaTxPath;					/*  Antenna path Tx */
+	u32	AntennaRxPath;					/*  Antenna path Rx */
 	u8	BluetoothCoexist;
 	u8	ExternalPA;
-	u8	InternalPA5G[2];	//pathA / pathB
-	u8	b1x1RecvCombine;	// for 1T1R receive combining
+	u8	InternalPA5G[2];	/* pathA / pathB */
+	u8	b1x1RecvCombine;	/*  for 1T1R receive combining */
 
 	u8	bCurrentTurboEDCA;
-	u32	AcParam_BE; //Original parameter for BE, use for EDCA turbo.
+	u32	AcParam_BE; /* Original parameter for BE, use for EDCA turbo. */
 
-	// The current Tx Power Level
+	/*  The current Tx Power Level */
 	u8	CurrentCckTxPwrIdx;
 	u8	CurrentOfdm24GTxPwrIdx;
 
-	struct bb_register_def PHYRegDef[4];	//Radio A/B/C/D
+	struct bb_register_def PHYRegDef[4];	/* Radio A/B/C/D */
 
-	bool		bRFPathRxEnable[4];	// We support 4 RF path now.
+	bool		bRFPathRxEnable[4];	/*  We support 4 RF path now. */
 
 	u32	RfRegChnlVal[2];
 
@@ -643,10 +640,10 @@ struct hal_data_8192du {
 
 	bool		bInSetPower;
 
-	//RDG enable
+	/* RDG enable */
 	bool		bRDGEnable;
 
-	bool		bLoadIMRandIQKSettingFor2G;// True if IMR or IQK  have done  for 2.4G in scan progress
+	bool		bLoadIMRandIQKSettingFor2G;/*  True if IMR or IQK  have done  for 2.4G in scan progress */
 	bool		bNeedIQK;
 
 	bool		bLCKInProgress;
@@ -655,23 +652,23 @@ struct hal_data_8192du {
 
 	struct iqk_matrix_regs_setting IQKMatrixRegSetting[IQK_Matrix_Settings_NUM];
 
-	//for host message to fw
+	/* for host message to fw */
 	u8	LastHMEBoxNum;
 	u8	fw_ractrl;
-	// Beacon function related global variable.
+	/*  Beacon function related global variable. */
 	u32	RegBcnCtrlVal;
 	u8	RegTxPause;
 	u8	RegFwHwTxQCtrl;
 	u8	RegReg542;
 	u8	RegCR_1;
 	struct dm_priv	dmpriv;
-	u8	FwRsvdPageStartOffset; //2010.06.23. Added by tynli. Reserve page start offset except beacon in TxQ.
+	u8	FwRsvdPageStartOffset; /* 2010.06.23. Added by tynli. Reserve page start offset except beacon in TxQ. */
 
-	//Query RF by FW
+	/* Query RF by FW */
 	bool		bReadRFbyFW;
 
-	// For 92C USB endpoint setting
-	//
+	/*  For 92C USB endpoint setting */
+	/*  */
 
 	u32	UsbBulkOutSize;
 
@@ -679,36 +676,36 @@ struct hal_data_8192du {
 	int	RtBulkInPipe;
 	int	RtIntInPipe;
 
-	// Add for dual MAC  0--Mac0 1--Mac1
+	/*  Add for dual MAC  0--Mac0 1--Mac1 */
 	u32	interfaceIndex;
 
 	u8	OutEpQueueSel;
 	u8	OutEpNumber;
 
-	u8	Queue2EPNum[8];//for out endpoint number mapping
+	u8	Queue2EPNum[8];/* for out endpoint number mapping */
 
 #ifdef CONFIG_USB_TX_AGGREGATION
 	u8	UsbTxAggMode;
 	u8	UsbTxAggDescNum;
 #endif
 #ifdef CONFIG_USB_RX_AGGREGATION
-	u16	HwRxPageSize;				// Hardware setting
+	u16	HwRxPageSize;				/*  Hardware setting */
 	u32	MaxUsbRxAggBlock;
 
 	enum USB_RX_AGG_MODE	UsbRxAggMode;
-	u8	UsbRxAggBlockCount;			// USB Block count. Block size is 512-byte in hight speed and 64-byte in full speed
+	u8	UsbRxAggBlockCount;			/*  USB Block count. Block size is 512-byte in hight speed and 64-byte in full speed */
 	u8	UsbRxAggBlockTimeout;
-	u8	UsbRxAggPageCount;			// 8192C DMA page count
+	u8	UsbRxAggPageCount;			/*  8192C DMA page count */
 	u8	UsbRxAggPageTimeout;
 #endif
 
 	u16	RegRRSR;
 
 	u16	EfuseUsedBytes;
-	u8	RTSInitRate;	 // 2010.11.24.by tynli.
+	u8	RTSInitRate;	 /*  2010.11.24.by tynli. */
 #ifdef CONFIG_P2P
 	struct P2P_PS_Offload_t	p2p_ps_offload;
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 };
 
 #define GET_HAL_DATA(__pAdapter)	((struct hal_data_8192du *)((__pAdapter)->HalData))
--- a/drivers/staging/rtl8192du/include/rtl8192d_led.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_led.h
@@ -25,9 +25,9 @@
 #include <drv_types.h>
 
 
-//================================================================================
-// Interface to manipulate LED objects.
-//================================================================================
+/*  */
+/*  Interface to manipulate LED objects. */
+/*  */
 void rtl8192du_InitSwLeds(struct rtw_adapter *padapter);
 void rtl8192du_DeInitSwLeds(struct rtw_adapter *padapter);
 
--- a/drivers/staging/rtl8192du/include/rtl8192d_recv.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_recv.h
@@ -29,14 +29,14 @@
 	#define NR_RECVBUFF (1)
 #else
 	#define NR_RECVBUFF (4)
-#endif //CONFIG_SINGLE_RECV_BUF
+#endif /* CONFIG_SINGLE_RECV_BUF */
 	#define NR_PREALLOC_RECV_SKB (8)
 
 #define RECV_BLK_SZ 512
 #define RECV_BLK_CNT 16
 #define RECV_BLK_TH RECV_BLK_CNT
 
-#define MAX_RECVBUF_SZ (8192+1024) // 8K+1k
+#define MAX_RECVBUF_SZ (8192+1024) /*  8K+1k */
 
 #define RECV_BULK_IN_ADDR		0x80
 #define RECV_INT_IN_ADDR		0x81
@@ -75,7 +75,7 @@ struct phy_ofdm_rx_status_report_8192cd
 	unsigned char r_ant_train_en:1;
 	unsigned char ANTSELB:1;
 	unsigned char ANTSEL:1;
-#else	// _BIG_ENDIAN_
+#else	/*  _BIG_ENDIAN_ */
 	unsigned char ANTSEL:1;
 	unsigned char ANTSELB:1;
 	unsigned char r_ant_train_en:1;
@@ -94,7 +94,7 @@ struct phy_cck_rx_status_report_8192cd {
 	u8	cck_agc_rpt;
 };
 
-// Rx smooth factor
+/*  Rx smooth factor */
 #define	Rx_Smooth_Factor (20)
 
 void rtl8192du_init_recvbuf(struct rtw_adapter *padapter, struct recv_buf *precvbuf);
--- a/drivers/staging/rtl8192du/include/rtl8192d_rf.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_rf.h
@@ -44,9 +44,9 @@
 
 /*--------------------------Define Parameters-------------------------------*/
 
-//
-// For RF 6052 Series
-//
+/*  */
+/*  For RF 6052 Series */
+/*  */
 #define		RF6052_MAX_TX_PWR			0x3F
 #define		RF6052_MAX_REG				0x3F
 #define		RF6052_MAX_PATH				2
@@ -68,9 +68,9 @@
 
 /*--------------------------Exported Function prototype---------------------*/
 
-//
-// RF RL6052 Series API
-//
+/*  */
+/*  RF RL6052 Series API */
+/*  */
 void		rtl8192d_RF_ChangeTxPath(	struct rtw_adapter *	Adapter,
 										u16		DataRate);
 void		rtl8192d_PHY_RF6052SetBandwidth(
--- a/drivers/staging/rtl8192du/include/rtl8192d_spec.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_spec.h
@@ -61,20 +61,20 @@
 #define BIT31	0x80000000
 
 
-//============================================================
-//       8192D Regsiter offset definition
-//============================================================
+/*  */
+/*        8192D Regsiter offset definition */
+/*  */
 
 
-//============================================================
-//
-//============================================================
-
-//-----------------------------------------------------
-//
-//	0x0000h ~ 0x00FFh	System Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/*  */
+
+/*  */
+/*  */
+/* 	0x0000h ~ 0x00FFh	System Configuration */
+/*  */
+/*  */
 #define REG_SYS_ISO_CTRL			0x0000
 #define REG_SYS_FUNC_EN			0x0002
 #define REG_APS_FSMCO				0x0004
@@ -93,14 +93,14 @@
 #define REG_LPLDO_CTRL				0x0023
 #define REG_AFE_XTAL_CTRL			0x0024
 #define REG_AFE_PLL_CTRL			0x0028
-#define REG_MAC_PHY_CTRL			0x002c //for 92d, DMDP,SMSP,DMSP contrl
+#define REG_MAC_PHY_CTRL			0x002c /* for 92d, DMDP,SMSP,DMSP contrl */
 #define REG_EFUSE_CTRL				0x0030
 #define REG_EFUSE_TEST				0x0034
 #define REG_PWR_DATA				0x0038
 #define REG_CAL_TIMER				0x003C
 #define REG_ACLK_MON				0x003E
 #define REG_GPIO_MUXCFG			0x0040
-//#define REG_GPIO_MUXCFG				0x0041
+/* define REG_GPIO_MUXCFG				0x0041 */
 #define REG_GPIO_IO_SEL				0x0042
 #define REG_MAC_PINMUX_CFG		0x0043
 #define REG_GPIO_PIN_CTRL			0x0044
@@ -115,7 +115,7 @@
 #define REG_MCUFWDL				0x0080
 #ifdef CONFIG_WOWLAN
 #define REG_WOWLAN_REASON			0x00FC
-#endif // CONFIG_WOWLAN
+#endif /*  CONFIG_WOWLAN */
 #define REG_HMEBOX_EXT_0			0x0088
 #define REG_HMEBOX_EXT_1			0x008A
 #define REG_HMEBOX_EXT_2			0x008C
@@ -141,11 +141,11 @@
 #define  mac1_ready					BIT0
 
 
-//-----------------------------------------------------
-//
-//	0x0100h ~ 0x01FFh	MACTOP General Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/* 	0x0100h ~ 0x01FFh	MACTOP General Configuration */
+/*  */
+/*  */
 #define REG_CR						0x0100
 #define REG_PBP						0x0104
 #define REG_TRXDMA_CTRL			0x010C
@@ -189,11 +189,11 @@
 #define REG_BB_ACCESS_DATA		0x01EC
 
 
-//-----------------------------------------------------
-//
-//	0x0200h ~ 0x027Fh	TXDMA Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/* 	0x0200h ~ 0x027Fh	TXDMA Configuration */
+/*  */
+/*  */
 #define REG_RQPN					0x0200
 #define REG_FIFOPAGE				0x0204
 #define REG_TDECTRL					0x0208
@@ -201,52 +201,52 @@
 #define REG_TXDMA_STATUS			0x0210
 #define REG_RQPN_NPQ				0x0214
 
-//-----------------------------------------------------
-//
-//	0x0280h ~ 0x02FFh	RXDMA Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/* 	0x0280h ~ 0x02FFh	RXDMA Configuration */
+/*  */
+/*  */
 #define REG_RXDMA_AGG_PG_TH		0x0280
 #define REG_RXPKT_NUM				0x0284
 #define REG_RXDMA_STATUS			0x0288
 
 
-//-----------------------------------------------------
-//
-//	0x0300h ~ 0x03FFh	PCIe
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/* 	0x0300h ~ 0x03FFh	PCIe */
+/*  */
+/*  */
 #define	REG_PCIE_CTRL_REG			0x0300
-#define	REG_INT_MIG				0x0304	// Interrupt Migration
-#define	REG_BCNQ_DESA				0x0308	// TX Beacon Descriptor Address
-#define	REG_HQ_DESA				0x0310	// TX High Queue Descriptor Address
-#define	REG_MGQ_DESA				0x0318	// TX Manage Queue Descriptor Address
-#define	REG_VOQ_DESA				0x0320	// TX VO Queue Descriptor Address
-#define	REG_VIQ_DESA				0x0328	// TX VI Queue Descriptor Address
-#define	REG_BEQ_DESA				0x0330	// TX BE Queue Descriptor Address
-#define	REG_BKQ_DESA				0x0338	// TX BK Queue Descriptor Address
-#define	REG_RX_DESA				0x0340	// RX Queue	Descriptor Address
-#define	REG_DBI					0x0348	// Backdoor REG for Access Configuration
-//sherry added for DBI Read/Write  20091126
-#define	REG_DBI_WDATA				0x0348	// Backdoor REG for Access Configuration
-#define		REG_DBI_RDATA				0x034C //Backdoor REG for Access Configuration
-#define	REG_DBI_CTRL				0x0350  //Backdoor REG for Access Configuration
-#define	REG_DBI_FLAG				0x0352 //Backdoor REG for Access Configuration#define	REG_MDIO					0x0354	// MDIO for Access PCIE PHY
-#define	REG_MDIO					0x0354	// MDIO for Access PCIE PHY
-#define	REG_DBG_SEL				0x0360	// Debug Selection Register
-#define	REG_PCIE_HRPWM			0x0361	//PCIe RPWM
-#define	REG_PCIE_HCPWM			0x0363	//PCIe CPWM
-#define	REG_UART_CTRL				0x0364	// UART	Control
-#define	REG_UART_TX_DESA			0x0370	// UART TX Descriptor Address
-#define	REG_UART_RX_DESA			0x0378	// UART Rx Descriptor Address
-
-
-// spec version 11
-//-----------------------------------------------------
-//
-//	0x0400h ~ 0x047Fh	Protocol Configuration
-//
-//-----------------------------------------------------
+#define	REG_INT_MIG				0x0304	/*  Interrupt Migration */
+#define	REG_BCNQ_DESA				0x0308	/*  TX Beacon Descriptor Address */
+#define	REG_HQ_DESA				0x0310	/*  TX High Queue Descriptor Address */
+#define	REG_MGQ_DESA				0x0318	/*  TX Manage Queue Descriptor Address */
+#define	REG_VOQ_DESA				0x0320	/*  TX VO Queue Descriptor Address */
+#define	REG_VIQ_DESA				0x0328	/*  TX VI Queue Descriptor Address */
+#define	REG_BEQ_DESA				0x0330	/*  TX BE Queue Descriptor Address */
+#define	REG_BKQ_DESA				0x0338	/*  TX BK Queue Descriptor Address */
+#define	REG_RX_DESA				0x0340	/*  RX Queue	Descriptor Address */
+#define	REG_DBI					0x0348	/*  Backdoor REG for Access Configuration */
+/* sherry added for DBI Read/Write  20091126 */
+#define	REG_DBI_WDATA				0x0348	/*  Backdoor REG for Access Configuration */
+#define		REG_DBI_RDATA				0x034C /* Backdoor REG for Access Configuration */
+#define	REG_DBI_CTRL				0x0350  /* Backdoor REG for Access Configuration */
+#define	REG_DBI_FLAG				0x0352 /* Backdoor REG for Access Configuration#define	REG_MDIO					0x0354	MDIO for Access PCIE PHY */
+#define	REG_MDIO					0x0354	/*  MDIO for Access PCIE PHY */
+#define	REG_DBG_SEL				0x0360	/*  Debug Selection Register */
+#define	REG_PCIE_HRPWM			0x0361	/* PCIe RPWM */
+#define	REG_PCIE_HCPWM			0x0363	/* PCIe CPWM */
+#define	REG_UART_CTRL				0x0364	/*  UART	Control */
+#define	REG_UART_TX_DESA			0x0370	/*  UART TX Descriptor Address */
+#define	REG_UART_RX_DESA			0x0378	/*  UART Rx Descriptor Address */
+
+
+/*  spec version 11 */
+/*  */
+/*  */
+/* 	0x0400h ~ 0x047Fh	Protocol Configuration */
+/*  */
+/*  */
 #define REG_VOQ_INFORMATION			0x0400
 #define REG_VIQ_INFORMATION			0x0404
 #define REG_BEQ_INFORMATION			0x0408
@@ -280,7 +280,7 @@
 #define REG_INIRTS_RATE_SEL			0x0480
 #define REG_INIDATA_RATE_SEL			0x0484
 
-//#define REG_FW_TSF_SYNC_CNT				0x04A0
+/* define REG_FW_TSF_SYNC_CNT				0x04A0 */
 #define REG_FW_RESET_TSF_CNT_1				0x05FC
 #define REG_FW_RESET_TSF_CNT_0				0x05FD
 #define REG_FW_BCN_DIS_CNT				0x05FE
@@ -306,11 +306,11 @@
 
 
 
-//-----------------------------------------------------
-//
-//	0x0500h ~ 0x05FFh	EDCA Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/* 	0x0500h ~ 0x05FFh	EDCA Configuration */
+/*  */
+/*  */
 #define REG_EDCA_VO_PARAM			0x0500
 #define REG_EDCA_VI_PARAM			0x0504
 #define REG_EDCA_BE_PARAM			0x0508
@@ -334,7 +334,7 @@
 #define REG_BCN_CTRL_1				0x0551
 #define REG_MBID_NUM				0x0552
 #define REG_DUAL_TSF_RST			0x0553
-#define REG_BCN_INTERVAL			0x0554	// The same as REG_MBSSID_BCN_SPACE
+#define REG_BCN_INTERVAL			0x0554	/*  The same as REG_MBSSID_BCN_SPACE */
 #define REG_MBSSID_BCN_SPACE		0x0554
 #define REG_DRVERLYINT				0x0558
 #define REG_BCNDMATIM				0x0559
@@ -359,14 +359,14 @@
 #define REG_EDCA_RANDOM_GEN		0x05CC
 #define REG_SCH_TXCMD				0x05D0
 
-#define REG_DMC						0x05F0	//Dual MAC Co-Existence Register
+#define REG_DMC						0x05F0	/* Dual MAC Co-Existence Register */
 
 
-//-----------------------------------------------------
-//
-//	0x0600h ~ 0x07FFh	WMAC Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/* 	0x0600h ~ 0x07FFh	WMAC Configuration */
+/*  */
+/*  */
 #define REG_APSD_CTRL				0x0600
 #define REG_BWOPMODE				0x0603
 #define REG_TCR						0x0604
@@ -389,7 +389,7 @@
 #define REG_EIFS						0x0642
 
 
-//WMA, BA, CCX
+/* WMA, BA, CCX */
 #define REG_NAV_CTRL				0x0650
 #define REG_BACAMCMD				0x0654
 #define REG_BACAMCONTENT			0x0658
@@ -399,14 +399,14 @@
 #define REG_WMAC_TRXPTCL_CTL		0x0668
 
 
-// Security
+/*  Security */
 #define REG_CAMCMD					0x0670
 #define REG_CAMWRITE				0x0674
 #define REG_CAMREAD				0x0678
 #define REG_CAMDBG					0x067C
 #define REG_SECCFG					0x0680
 
-// Power
+/*  Power */
 #define REG_WOW_CTRL				0x0690
 #define REG_PSSTATUS				0x0691
 #define REG_PS_RX_INFO				0x0692
@@ -425,83 +425,81 @@
 #define REG_MACID1					0x0700
 #define REG_BSSID1					0x0708
 
-//-----------------------------------------------------
-//
-//	0xFE00h ~ 0xFE55h	USB Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/* 	0xFE00h ~ 0xFE55h	USB Configuration */
+/*  */
+/*  */
 #define REG_USB_INFO				0xFE17
 #define REG_USB_SPECIAL_OPTION	0xFE55
 #define REG_USB_DMA_AGG_TO		0xFE5B
 #define REG_USB_AGG_TO				0xFE5C
 #define REG_USB_AGG_TH				0xFE5D
 
-// for 92DU high_Queue low_Queue Normal_Queue select
+/*  for 92DU high_Queue low_Queue Normal_Queue select */
 #define REG_USB_High_NORMAL_Queue_Select_MAC0  0xFE44
-//#define REG_USB_LOW_Queue_Select_MAC0       0xFE45
 #define REG_USB_High_NORMAL_Queue_Select_MAC1  0xFE47
-//#define REG_USB_LOW_Queue_Select_MAC1       0xFE48
 
-// For test chip
+/*  For test chip */
 #define REG_TEST_USB_TXQS			0xFE48
-#define REG_TEST_SIE_VID			0xFE60		// 0xFE60~0xFE61
-#define REG_TEST_SIE_PID			0xFE62		// 0xFE62~0xFE63
+#define REG_TEST_SIE_VID			0xFE60		/*  0xFE60~0xFE61 */
+#define REG_TEST_SIE_PID			0xFE62		/*  0xFE62~0xFE63 */
 #define REG_TEST_SIE_OPTIONAL		0xFE64
 #define REG_TEST_SIE_CHIRP_K		0xFE65
-#define REG_TEST_SIE_PHY			0xFE66		// 0xFE66~0xFE6B
-#define REG_TEST_SIE_MAC_ADDR		0xFE70		// 0xFE70~0xFE75
-#define REG_TEST_SIE_STRING		0xFE80		// 0xFE80~0xFEB9
+#define REG_TEST_SIE_PHY			0xFE66		/*  0xFE66~0xFE6B */
+#define REG_TEST_SIE_MAC_ADDR		0xFE70		/*  0xFE70~0xFE75 */
+#define REG_TEST_SIE_STRING		0xFE80		/*  0xFE80~0xFEB9 */
 
 
-// For normal chip
-#define REG_NORMAL_SIE_VID			0xFE60		// 0xFE60~0xFE61
-#define REG_NORMAL_SIE_PID			0xFE62		// 0xFE62~0xFE63
+/*  For normal chip */
+#define REG_NORMAL_SIE_VID			0xFE60		/*  0xFE60~0xFE61 */
+#define REG_NORMAL_SIE_PID			0xFE62		/*  0xFE62~0xFE63 */
 #define REG_NORMAL_SIE_OPTIONAL	0xFE64
-#define REG_NORMAL_SIE_EP			0xFE65		// 0xFE65~0xFE67
-#define REG_NORMAL_SIE_PHY		0xFE68		// 0xFE68~0xFE6B
-#define REG_NORMAL_SIE_MAC_ADDR	0xFE70		// 0xFE70~0xFE75
-#define REG_NORMAL_SIE_STRING		0xFE80		// 0xFE80~0xFEDF
-
-
-//-----------------------------------------------------
-//
-//	Redifine 8192C register definition for compatibility
-//
-//-----------------------------------------------------
+#define REG_NORMAL_SIE_EP			0xFE65		/*  0xFE65~0xFE67 */
+#define REG_NORMAL_SIE_PHY		0xFE68		/*  0xFE68~0xFE6B */
+#define REG_NORMAL_SIE_MAC_ADDR	0xFE70		/*  0xFE70~0xFE75 */
+#define REG_NORMAL_SIE_STRING		0xFE80		/*  0xFE80~0xFEDF */
+
+
+/*  */
+/*  */
+/* 	Redifine 8192C register definition for compatibility */
+/*  */
+/*  */
 
-// TODO: use these definition when using REG_xxx naming rule.
-// NOTE: DO NOT Remove these definition. Use later.
+/*  TODO: use these definition when using REG_xxx naming rule. */
+/*  NOTE: DO NOT Remove these definition. Use later. */
 
-#define	SYS_ISO_CTRL				REG_SYS_ISO_CTRL	// System Isolation Interface Control.
-#define	SYS_FUNC_EN				REG_SYS_FUNC_EN		// System Function Enable.
+#define	SYS_ISO_CTRL				REG_SYS_ISO_CTRL	/*  System Isolation Interface Control. */
+#define	SYS_FUNC_EN				REG_SYS_FUNC_EN		/*  System Function Enable. */
 #define	SYS_CLK						REG_SYS_CLKR
-#define	CR9346						REG_9346CR			// 93C46/93C56 Command Register.
-#define	EFUSE_CTRL					REG_EFUSE_CTRL		// E-Fuse Control.
-#define	EFUSE_TEST					REG_EFUSE_TEST		// E-Fuse Test.
-#define	MSR							(REG_CR + 2)		// Media Status register
+#define	CR9346						REG_9346CR			/*  93C46/93C56 Command Register. */
+#define	EFUSE_CTRL					REG_EFUSE_CTRL		/*  E-Fuse Control. */
+#define	EFUSE_TEST					REG_EFUSE_TEST		/*  E-Fuse Test. */
+#define	MSR							(REG_CR + 2)		/*  Media Status register */
 #define	ISR							REG_HISR
-#define	TSFR						REG_TSFTR			// Timing Sync Function Timer Register.
+#define	TSFR						REG_TSFTR			/*  Timing Sync Function Timer Register. */
 
-#define	MACIDR0					REG_MACID			// MAC ID Register, Offset 0x0050-0x0053
-#define	MACIDR4					(REG_MACID + 4)		// MAC ID Register, Offset 0x0054-0x0055
+#define	MACIDR0					REG_MACID			/*  MAC ID Register, Offset 0x0050-0x0053 */
+#define	MACIDR4					(REG_MACID + 4)		/*  MAC ID Register, Offset 0x0054-0x0055 */
 
 #define		PBP							REG_PBP
 
-// Redifine MACID register, to compatible prior ICs.
+/*  Redifine MACID register, to compatible prior ICs. */
 #define	IDR0						MACIDR0
 #define	IDR4						MACIDR4
 
 
-//
-// 9. Security Control Registers	(Offset:)
-//
-#define	RWCAM						REG_CAMCMD		//IN 8190 Data Sheet is called CAMcmd
-#define	WCAMI						REG_CAMWRITE	// Software write CAM input content
-#define	RCAMO						REG_CAMREAD		// Software read/write CAM config
+/*  */
+/*  9. Security Control Registers	(Offset:) */
+/*  */
+#define	RWCAM						REG_CAMCMD		/* IN 8190 Data Sheet is called CAMcmd */
+#define	WCAMI						REG_CAMWRITE	/*  Software write CAM input content */
+#define	RCAMO						REG_CAMREAD		/*  Software read/write CAM config */
 #define	CAMDBG						REG_CAMDBG
-#define	SECR						REG_SECCFG		//Security Configuration Register
+#define	SECR						REG_SECCFG		/* Security Configuration Register */
 
-// Unused register
+/*  Unused register */
 #define	UnusedRegister				0x1BF
 #define	DCAM						UnusedRegister
 #define	PSR							UnusedRegister
@@ -510,36 +508,36 @@
 
 #define	InvalidBBRFValue			0x12345678
 
-// Min Spacing related settings.
+/*  Min Spacing related settings. */
 #define	MAX_MSS_DENSITY_2T			0x13
 #define	MAX_MSS_DENSITY_1T			0x0A
 
-//----------------------------------------------------------------------------
-//       8192C Cmd9346CR bits					(Offset 0xA, 16bit)
-//----------------------------------------------------------------------------
-#define	CmdEEPROM_En				BIT5	 // EEPROM enable when set 1
-#define	CmdEERPOMSEL				BIT4	// System EEPROM select, 0: boot from E-FUSE, 1: The EEPROM used is 9346
+/*  */
+/*        8192C Cmd9346CR bits					(Offset 0xA, 16bit) */
+/*  */
+#define	CmdEEPROM_En				BIT5	 /*  EEPROM enable when set 1 */
+#define	CmdEERPOMSEL				BIT4	/*  System EEPROM select, 0: boot from E-FUSE, 1: The EEPROM used is 9346 */
 #define	Cmd9346CR_9356SEL			BIT4
 #define	AutoLoadEEPROM			(CmdEEPROM_En|CmdEERPOMSEL)
 #define	AutoLoadEFUSE				CmdEEPROM_En
 
-//       8192C GPIO MUX Configuration Register (offset 0x40, 4 byte)
-//----------------------------------------------------------------------------
+/*        8192C GPIO MUX Configuration Register (offset 0x40, 4 byte) */
+/*  */
 #define	GPIOSEL_GPIO				0
 #define	GPIOSEL_ENBT				BIT5
 
-//----------------------------------------------------------------------------
-//       8192C GPIO PIN Control Register (offset 0x44, 4 byte)
-//----------------------------------------------------------------------------
-#define	GPIO_IN						REG_GPIO_PIN_CTRL		// GPIO pins input value
-#define	GPIO_OUT					(REG_GPIO_PIN_CTRL+1)	// GPIO pins output value
-#define	GPIO_IO_SEL				(REG_GPIO_PIN_CTRL+2)	// GPIO pins output enable when a bit is set to "1"; otherwise, input is configured.
+/*  */
+/*        8192C GPIO PIN Control Register (offset 0x44, 4 byte) */
+/*  */
+#define	GPIO_IN						REG_GPIO_PIN_CTRL		/*  GPIO pins input value */
+#define	GPIO_OUT					(REG_GPIO_PIN_CTRL+1)	/*  GPIO pins output value */
+#define	GPIO_IO_SEL				(REG_GPIO_PIN_CTRL+2)	/*  GPIO pins output enable when a bit is set to "1"; otherwise, input is configured. */
 #define	GPIO_MOD					(REG_GPIO_PIN_CTRL+3)
 
 
-//----------------------------------------------------------------------------
-//       8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits)
-//----------------------------------------------------------------------------
+/*  */
+/*        8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits) */
+/*  */
 /*
 Network Type
 00: No link
@@ -553,12 +551,12 @@ Default: 00b.
 #define	MSR_INFRA					0x02
 #define	MSR_AP						0x03
 
-//
-// 6. Adaptive Control Registers  (Offset: 0x0160 - 0x01CF)
-//
-//----------------------------------------------------------------------------
-//       8192C Response Rate Set Register	(offset 0x181, 24bits)
-//----------------------------------------------------------------------------
+/*  */
+/*  6. Adaptive Control Registers  (Offset: 0x0160 - 0x01CF) */
+/*  */
+/*  */
+/*        8192C Response Rate Set Register	(offset 0x181, 24bits) */
+/*  */
 #define	RRSR_RSC_OFFSET			21
 #define	RRSR_SHORT_OFFSET			23
 #define	RRSR_RSC_BW_40M			0x600000
@@ -586,18 +584,18 @@ Default: 00b.
 #define	RRSR_MCS6					BIT18
 #define	RRSR_MCS7					BIT19
 #define	BRSR_AckShortPmb			BIT23
-// CCK ACK: use Short Preamble or not
+/*  CCK ACK: use Short Preamble or not */
 
 
-//----------------------------------------------------------------------------
-//       8192C Rate Definition
-//----------------------------------------------------------------------------
-//CCK
+/*  */
+/*        8192C Rate Definition */
+/*  */
+/* CCK */
 #define	RATR_1M					0x00000001
 #define	RATR_2M					0x00000002
 #define	RATR_55M					0x00000004
 #define	RATR_11M					0x00000008
-//OFDM
+/* OFDM */
 #define	RATR_6M					0x00000010
 #define	RATR_9M					0x00000020
 #define	RATR_12M					0x00000040
@@ -606,7 +604,7 @@ Default: 00b.
 #define	RATR_36M					0x00000200
 #define	RATR_48M					0x00000400
 #define	RATR_54M					0x00000800
-//MCS 1 Spatial Stream
+/* MCS 1 Spatial Stream */
 #define	RATR_MCS0					0x00001000
 #define	RATR_MCS1					0x00002000
 #define	RATR_MCS2					0x00004000
@@ -615,7 +613,7 @@ Default: 00b.
 #define	RATR_MCS5					0x00020000
 #define	RATR_MCS6					0x00040000
 #define	RATR_MCS7					0x00080000
-//MCS 2 Spatial Stream
+/* MCS 2 Spatial Stream */
 #define	RATR_MCS8					0x00100000
 #define	RATR_MCS9					0x00200000
 #define	RATR_MCS10					0x00400000
@@ -625,17 +623,17 @@ Default: 00b.
 #define	RATR_MCS14					0x04000000
 #define	RATR_MCS15					0x08000000
 
-//----------------------------------------------------------------------------
-//       8192C BW_OPMODE bits					(Offset 0x203, 8bit)
-//----------------------------------------------------------------------------
+/*  */
+/*        8192C BW_OPMODE bits					(Offset 0x203, 8bit) */
+/*  */
 #define	BW_OPMODE_20MHZ			BIT2
 #define	BW_OPMODE_5G				BIT1
 #define	BW_OPMODE_11J				BIT0
 
 
-//----------------------------------------------------------------------------
-//       8192C CAM Config Setting (offset 0x250, 1 byte)
-//----------------------------------------------------------------------------
+/*  */
+/*        8192C CAM Config Setting (offset 0x250, 1 byte) */
+/*  */
 #define	CAM_VALID					BIT15
 #define	CAM_NOTVALID				0x0000
 #define	CAM_USEDK					BIT5
@@ -665,74 +663,74 @@ Default: 00b.
 #define	SCR_RxSecEnable			0x04
 
 
-//
-// 12. Host Interrupt Status Registers	 (Offset: 0x0300 - 0x030F)
-//
-//----------------------------------------------------------------------------
-//       8190 IMR/ISR bits						(offset 0xfd,  8bits)
-//----------------------------------------------------------------------------
+/*  */
+/*  12. Host Interrupt Status Registers	 (Offset: 0x0300 - 0x030F) */
+/*  */
+/*  */
+/*        8190 IMR/ISR bits						(offset 0xfd,  8bits) */
+/*  */
 #define	IMR8190_DISABLED			0x0
-// IMR DW0 Bit 0-31
-#define	IMR_BCNDMAINT6			BIT31		// Beacon DMA Interrupt 6
-#define	IMR_BCNDMAINT5			BIT30		// Beacon DMA Interrupt 5
-#define	IMR_BCNDMAINT4			BIT29		// Beacon DMA Interrupt 4
-#define	IMR_BCNDMAINT3			BIT28		// Beacon DMA Interrupt 3
-#define	IMR_BCNDMAINT2			BIT27		// Beacon DMA Interrupt 2
-#define	IMR_BCNDMAINT1			BIT26		// Beacon DMA Interrupt 1
-#define	IMR_BCNDOK8				BIT25		// Beacon Queue DMA OK Interrup 8
-#define	IMR_BCNDOK7				BIT24		// Beacon Queue DMA OK Interrup 7
-#define	IMR_BCNDOK6				BIT23		// Beacon Queue DMA OK Interrup 6
-#define	IMR_BCNDOK5				BIT22		// Beacon Queue DMA OK Interrup 5
-#define	IMR_BCNDOK4				BIT21		// Beacon Queue DMA OK Interrup 4
-#define	IMR_BCNDOK3				BIT20		// Beacon Queue DMA OK Interrup 3
-#define	IMR_BCNDOK2				BIT19		// Beacon Queue DMA OK Interrup 2
-#define	IMR_BCNDOK1				BIT18		// Beacon Queue DMA OK Interrup 1
-#define	IMR_TIMEOUT2				BIT17		// Timeout interrupt 2
-#define	IMR_TIMEOUT1				BIT16		// Timeout interrupt 1
-#define	IMR_TXFOVW				BIT15		// Transmit FIFO Overflow
-#define	IMR_PSTIMEOUT				BIT14		// Power save time out interrupt
-#define	IMR_BcnInt					BIT13		// Beacon DMA Interrupt 0
-#define	IMR_RXFOVW				BIT12		// Receive FIFO Overflow
-#define	IMR_RDU					BIT11		// Receive Descriptor Unavailable
-#define	IMR_ATIMEND				BIT10		// For 92C,ATIM Window End Interrupt
-#define	IMR_BDOK					BIT9		// Beacon Queue DMA OK Interrup
-#define	IMR_HIGHDOK				BIT8		// High Queue DMA OK Interrupt
-#define	IMR_TBDOK					BIT7		// Transmit Beacon OK interrup
-#define	IMR_MGNTDOK				BIT6		// Management Queue DMA OK Interrupt
-#define	IMR_TBDER					BIT5		// For 92C,Transmit Beacon Error Interrupt
-#define	IMR_BKDOK					BIT4		// AC_BK DMA OK Interrupt
-#define	IMR_BEDOK					BIT3		// AC_BE DMA OK Interrupt
-#define	IMR_VIDOK					BIT2		// AC_VI DMA OK Interrupt
-#define	IMR_VODOK					BIT1		// AC_VO DMA Interrupt
-#define	IMR_ROK					BIT0		// Receive DMA OK Interrupt
+/*  IMR DW0 Bit 0-31 */
+#define	IMR_BCNDMAINT6			BIT31		/*  Beacon DMA Interrupt 6 */
+#define	IMR_BCNDMAINT5			BIT30		/*  Beacon DMA Interrupt 5 */
+#define	IMR_BCNDMAINT4			BIT29		/*  Beacon DMA Interrupt 4 */
+#define	IMR_BCNDMAINT3			BIT28		/*  Beacon DMA Interrupt 3 */
+#define	IMR_BCNDMAINT2			BIT27		/*  Beacon DMA Interrupt 2 */
+#define	IMR_BCNDMAINT1			BIT26		/*  Beacon DMA Interrupt 1 */
+#define	IMR_BCNDOK8				BIT25		/*  Beacon Queue DMA OK Interrup 8 */
+#define	IMR_BCNDOK7				BIT24		/*  Beacon Queue DMA OK Interrup 7 */
+#define	IMR_BCNDOK6				BIT23		/*  Beacon Queue DMA OK Interrup 6 */
+#define	IMR_BCNDOK5				BIT22		/*  Beacon Queue DMA OK Interrup 5 */
+#define	IMR_BCNDOK4				BIT21		/*  Beacon Queue DMA OK Interrup 4 */
+#define	IMR_BCNDOK3				BIT20		/*  Beacon Queue DMA OK Interrup 3 */
+#define	IMR_BCNDOK2				BIT19		/*  Beacon Queue DMA OK Interrup 2 */
+#define	IMR_BCNDOK1				BIT18		/*  Beacon Queue DMA OK Interrup 1 */
+#define	IMR_TIMEOUT2				BIT17		/*  Timeout interrupt 2 */
+#define	IMR_TIMEOUT1				BIT16		/*  Timeout interrupt 1 */
+#define	IMR_TXFOVW				BIT15		/*  Transmit FIFO Overflow */
+#define	IMR_PSTIMEOUT				BIT14		/*  Power save time out interrupt */
+#define	IMR_BcnInt					BIT13		/*  Beacon DMA Interrupt 0 */
+#define	IMR_RXFOVW				BIT12		/*  Receive FIFO Overflow */
+#define	IMR_RDU					BIT11		/*  Receive Descriptor Unavailable */
+#define	IMR_ATIMEND				BIT10		/*  For 92C,ATIM Window End Interrupt */
+#define	IMR_BDOK					BIT9		/*  Beacon Queue DMA OK Interrup */
+#define	IMR_HIGHDOK				BIT8		/*  High Queue DMA OK Interrupt */
+#define	IMR_TBDOK					BIT7		/*  Transmit Beacon OK interrup */
+#define	IMR_MGNTDOK				BIT6		/*  Management Queue DMA OK Interrupt */
+#define	IMR_TBDER					BIT5		/*  For 92C,Transmit Beacon Error Interrupt */
+#define	IMR_BKDOK					BIT4		/*  AC_BK DMA OK Interrupt */
+#define	IMR_BEDOK					BIT3		/*  AC_BE DMA OK Interrupt */
+#define	IMR_VIDOK					BIT2		/*  AC_VI DMA OK Interrupt */
+#define	IMR_VODOK					BIT1		/*  AC_VO DMA Interrupt */
+#define	IMR_ROK					BIT0		/*  Receive DMA OK Interrupt */
 
-// 13. Host Interrupt Status Extension Register	 (Offset: 0x012C-012Eh)
+/*  13. Host Interrupt Status Extension Register	 (Offset: 0x012C-012Eh) */
 #define	IMR_TXERR					BIT11
 #define	IMR_RXERR					BIT10
 #define	IMR_C2HCMD				BIT9
 #define	IMR_CPWM					BIT8
-//RSVD [2-7]
+/* RSVD [2-7] */
 #define	IMR_OCPINT					BIT1
 #define	IMR_WLANOFF				BIT0
 
 
 
-//----------------------------------------------------------------------------
-// 8192D EFUSE
-//----------------------------------------------------------------------------
+/*  */
+/*  8192D EFUSE */
+/*  */
 #define	HWSET_MAX_SIZE				256
 
-//----------------------------------------------------------------------------
-//       8192C EEPROM/EFUSE share register definition.
-//----------------------------------------------------------------------------
-
-//
-// Default Value for EEPROM or EFUSE!!!
-//
+/*  */
+/*        8192C EEPROM/EFUSE share register definition. */
+/*  */
+
+/*  */
+/*  Default Value for EEPROM or EFUSE!!! */
+/*  */
 #define	EEPROM_Default_TSSI					0x0
 #define		EEPROM_Default_TxPowerDiff				0x0
-#define		EEPROM_Default_CrystalCap				0x0		//92D default 0x0
-#define		EEPROM_Default_BoardType				0x02 // Default: 2X2, RTL8192CE(QFPN68)
+#define		EEPROM_Default_CrystalCap				0x0		/* 92D default 0x0 */
+#define		EEPROM_Default_BoardType				0x02 /*  Default: 2X2, RTL8192CE(QFPN68) */
 #define		EEPROM_Default_TxPower				0x1010
 #define	EEPROM_Default_HT2T_TxPwr				0x10
 
@@ -740,17 +738,17 @@ Default: 00b.
 #define	EEPROM_Default_ThermalMeter			0x12
 
 #define	EEPROM_Default_AntTxPowerDiff			0x0
-//#define	EEPROM_Default_TxPwDiff_CrystalCap		0x5
+/* define	EEPROM_Default_TxPwDiff_CrystalCap		0x5 */
 #define	EEPROM_Default_TxPowerLevel_2G		0x2C
 #define	EEPROM_Default_TxPowerLevel_5G		0x22
 
 #define	EEPROM_Default_HT40_2SDiff				0x0
-#define		EEPROM_Default_HT20_Diff				2	// HT20<->40 default Tx Power Index Difference
-#define	EEPROM_Default_LegacyHTTxPowerDiff	0x4	//OFDM Tx Power index diff
+#define		EEPROM_Default_HT20_Diff				2	/*  HT20<->40 default Tx Power Index Difference */
+#define	EEPROM_Default_LegacyHTTxPowerDiff	0x4	/* OFDM Tx Power index diff */
 #define		EEPROM_Default_HT40_PwrMaxOffset		0
 #define		EEPROM_Default_HT20_PwrMaxOffset		0
 
-// For debug
+/*  For debug */
 #define		EEPROM_Default_PID						0x1234
 #define		EEPROM_Default_VID						0x5678
 #define		EEPROM_Default_CustomerID				0xAB
@@ -781,36 +779,36 @@ Default: 00b.
 
 #define		EEPROM_CID_DEFAULT					0x0
 #define		EEPROM_CID_TOSHIBA					0x4
-#define	EEPROM_CID_CCX						0x10 // CCX test. By Bruce, 2009-02-25.
+#define	EEPROM_CID_CCX						0x10 /*  CCX test. By Bruce, 2009-02-25. */
 #define	EEPROM_CID_QMI						0x0D
-#define		EEPROM_CID_WHQL							0xFE // added by chiyoko for dtm, 20090108
+#define		EEPROM_CID_WHQL							0xFE /*  added by chiyoko for dtm, 20090108 */
 
 
 #define	RTL8192_EEPROM_ID						0x8129
 #define	EEPROM_WAPI_SUPPORT					0x78
 
-#define RTL8190_EEPROM_ID						0x8129	// 0-1
-#define EEPROM_HPON							0x02 // LDO settings.2-5
-#define EEPROM_CLK								0x06 // Clock settings.6-7
-#define EEPROM_MAC_FUNCTION					0x08 // SE Test mode.8
+#define RTL8190_EEPROM_ID						0x8129	/*  0-1 */
+#define EEPROM_HPON							0x02 /*  LDO settings.2-5 */
+#define EEPROM_CLK								0x06 /*  Clock settings.6-7 */
+#define EEPROM_MAC_FUNCTION					0x08 /*  SE Test mode.8 */
 
-#define EEPROM_VID								0xC // SE Vendor ID.A-B
-#define EEPROM_PID								0xE // SE Device ID. C-D
+#define EEPROM_VID								0xC /*  SE Vendor ID.A-B */
+#define EEPROM_PID								0xE /*  SE Device ID. C-D */
 #define EEPROM_ENDPOINT_SETTING				0x10
 #ifdef CONFIG_WOWLAN
 #define EEPROM_Option_Setting				0x11
-#endif // CONFIG_WOWLAN
-#define EEPROM_CHIRP_K							0x12	// Changed
-#define EEPROM_USB_PHY							0x13	// Changed
-#define EEPROM_NORMAL_BoardType				EEPROM_RF_OPT1	//[7:5]
-#define EEPROM_MAC_ADDR						0x16 // SEMAC Address. 12-17
+#endif /*  CONFIG_WOWLAN */
+#define EEPROM_CHIRP_K							0x12	/*  Changed */
+#define EEPROM_USB_PHY							0x13	/*  Changed */
+#define EEPROM_NORMAL_BoardType				EEPROM_RF_OPT1	/* 7:5] */
+#define EEPROM_MAC_ADDR						0x16 /*  SEMAC Address. 12-17 */
 #define EEPROM_STRING							0x1F
 #define EEPROM_SUBCUSTOMER_ID					0x59
 
 #define EEPROM_MAC_ADDR_MAC0_92D			0x19
 #define EEPROM_MAC_ADDR_MAC1_92D			0x5B
-//----------------------------------------------------------------
-// 2.4G band Tx power index setting
+/*  */
+/*  2.4G band Tx power index setting */
 #define EEPROM_CCK_TX_PWR_INX_2G				0x61
 #define EEPROM_HT40_1S_TX_PWR_INX_2G		0x67
 #define EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G	0x6D
@@ -819,7 +817,7 @@ Default: 00b.
 #define EEPROM_HT40_MAX_PWR_OFFSET_2G		0x76
 #define EEPROM_HT20_MAX_PWR_OFFSET_2G		0x79
 
-//5GL channel 32-64
+/* 5GL channel 32-64 */
 #define EEPROM_HT40_1S_TX_PWR_INX_5GL		0x7C
 #define EEPROM_HT40_2S_TX_PWR_INX_DIFF_5GL	0x82
 #define EEPROM_HT20_TX_PWR_INX_DIFF_5GL		0x85
@@ -827,7 +825,7 @@ Default: 00b.
 #define EEPROM_HT40_MAX_PWR_OFFSET_5GL		0x8B
 #define EEPROM_HT20_MAX_PWR_OFFSET_5GL		0x8E
 
-//5GM channel 100-140
+/* 5GM channel 100-140 */
 #define EEPROM_HT40_1S_TX_PWR_INX_5GM		0x91
 #define EEPROM_HT40_2S_TX_PWR_INX_DIFF_5GM	0x97
 #define EEPROM_HT20_TX_PWR_INX_DIFF_5GM		0x9A
@@ -835,7 +833,7 @@ Default: 00b.
 #define EEPROM_HT40_MAX_PWR_OFFSET_5GM		0xA0
 #define EEPROM_HT20_MAX_PWR_OFFSET_5GM		0xA3
 
-//5GH channel 149-165
+/* 5GH channel 149-165 */
 #define EEPROM_HT40_1S_TX_PWR_INX_5GH		0xA6
 #define EEPROM_HT40_2S_TX_PWR_INX_DIFF_5GH	0xAC
 #define EEPROM_HT20_TX_PWR_INX_DIFF_5GH		0xAF
@@ -843,15 +841,15 @@ Default: 00b.
 #define EEPROM_HT40_MAX_PWR_OFFSET_5GH		0xB5
 #define EEPROM_HT20_MAX_PWR_OFFSET_5GH		0xB8
 
-#define EEPROM_CHANNEL_PLAN					0xBB // Map of supported channels.
+#define EEPROM_CHANNEL_PLAN					0xBB /*  Map of supported channels. */
 #define EEPROM_TEST_CHANNEL_PLAN				0xBB
 #define EEPROM_IQK_DELTA						0xBC
 #define EEPROM_LCK_DELTA						0xBC
-#define EEPROM_XTAL_K							0xBD	//[7:5]
+#define EEPROM_XTAL_K							0xBD	/* 7:5] */
 #define EEPROM_TSSI_A_5G						0xBE
 #define EEPROM_TSSI_B_5G						0xBF
 #define EEPROM_TSSI_AB_5G						0xC0
-#define EEPROM_THERMAL_METER					0xC3	//[4:0]
+#define EEPROM_THERMAL_METER					0xC3	/* 4:0] */
 #define EEPROM_RF_OPT1							0xC4
 #define EEPROM_RF_OPT2							0xC5
 #define EEPROM_RF_OPT3							0xC6
@@ -862,13 +860,13 @@ Default: 00b.
 #define EEPROM_CUSTOMER_ID					0xCB
 #define EEPROM_RF_OPT7							0xCC
 
-#define EEPROM_DEF_PART_NO					0x3FD  //Byte
+#define EEPROM_DEF_PART_NO					0x3FD  /* Byte */
 #define EEPROME_CHIP_VERSION_L				0x3FF
 #define EEPROME_CHIP_VERSION_H				0x3FE
 
-//-------------------------------------------------------------
-//	EEPROM content definitions
-//-------------------------------------------------------------
+/*  */
+/* 	EEPROM content definitions */
+/*  */
 #define OS_LINK_SPEED_NORMAL_MASK			BIT3 | BIT2
 #define OS_LINK_SPEED_TEST_MASK				BIT3 | BIT4
 
@@ -881,45 +879,45 @@ Default: 00b.
 #define BT_CO_SHIFT_TEST						4
 #define BT_CO_SHIFT_NORMAL					5
 
-#define EP_NUMBER_MASK_TEST					0x30	//bit 4:5 0Eh
+#define EP_NUMBER_MASK_TEST					0x30	/* bit 4:5 0Eh */
 #define EP_NUMBER_SHIFT_TEST					4
 
 #define USB_PHY_PARA_SIZE_TEST				6
 #define USB_PHY_PARA_SIZE_NORMAL				4
 
-//-------------------------------------------------------------
-//	EEPROM default value definitions
-//-------------------------------------------------------------
-// Use 0xABCD instead of 0x8192 for debug
-#define	EEPROM_DEF_ID_0						0xCD	// Byte 0x00
-#define	EEPROM_DEF_ID_1						0xAB	// Byte 0x01
-
-#define EEPROM_DEF_RTK_RSV_A3					0x74	// Byte 0x03
-#define EEPROM_DEF_RTK_RSV_A4					0x6D	// Byte 0x04
-#define EEPROM_DEF_RTK_RSV_A8					0xFF	// Byte 0x08
+/*  */
+/* 	EEPROM default value definitions */
+/*  */
+/*  Use 0xABCD instead of 0x8192 for debug */
+#define	EEPROM_DEF_ID_0						0xCD	/*  Byte 0x00 */
+#define	EEPROM_DEF_ID_1						0xAB	/*  Byte 0x01 */
+
+#define EEPROM_DEF_RTK_RSV_A3					0x74	/*  Byte 0x03 */
+#define EEPROM_DEF_RTK_RSV_A4					0x6D	/*  Byte 0x04 */
+#define EEPROM_DEF_RTK_RSV_A8					0xFF	/*  Byte 0x08 */
 
-#define EEPROM_DEF_VID_0						0x0A	// Byte 0x0A
+#define EEPROM_DEF_VID_0						0x0A	/*  Byte 0x0A */
 #define EEPROM_DEF_VID_1						0x0B
 
-#define EEPROM_DEF_PID_0						0x92	// Byte 0x0C
+#define EEPROM_DEF_PID_0						0x92	/*  Byte 0x0C */
 #define EEPROM_DEF_PID_1						0x81
 
 
-#define EEPROM_TEST_DEF_USB_OPT				0x80	// Byte 0x0E
-#define EEPROM_NORMAL_DEF_USB_OPT			0x00	// Byte 0x0E
+#define EEPROM_TEST_DEF_USB_OPT				0x80	/*  Byte 0x0E */
+#define EEPROM_NORMAL_DEF_USB_OPT			0x00	/*  Byte 0x0E */
 
-#define EEPROM_DEF_CHIRPK						0x15	// Byte 0x0F
+#define EEPROM_DEF_CHIRPK						0x15	/*  Byte 0x0F */
 
-#define EEPROM_DEF_USB_PHY_0					0x85	// Byte 0x10
-#define EEPROM_DEF_USB_PHY_1					0x62	// Byte 0x11
-#define EEPROM_DEF_USB_PHY_2					0x9E	// Byte 0x12
-#define EEPROM_DEF_USB_PHY_3					0x06	// Byte 0x13
+#define EEPROM_DEF_USB_PHY_0					0x85	/*  Byte 0x10 */
+#define EEPROM_DEF_USB_PHY_1					0x62	/*  Byte 0x11 */
+#define EEPROM_DEF_USB_PHY_2					0x9E	/*  Byte 0x12 */
+#define EEPROM_DEF_USB_PHY_3					0x06	/*  Byte 0x13 */
 
-#define EEPROM_DEF_TSSI_A						0x09	// Byte 0x78
-#define EEPROM_DEF_TSSI_B						0x09	// Byte 0x79
+#define EEPROM_DEF_TSSI_A						0x09	/*  Byte 0x78 */
+#define EEPROM_DEF_TSSI_B						0x09	/*  Byte 0x79 */
 
 
-#define EEPROM_DEF_THERMAL_METER				0x12	// Byte 0x7A
+#define EEPROM_DEF_THERMAL_METER				0x12	/*  Byte 0x7A */
 
 
 #define	EEPROM_USB_SN							BIT(0)
@@ -950,50 +948,49 @@ Current IOREG MAP
 0x2000h ~ 0x3FFFh   8051 FW Download Region (8196 Bytes)
 */
 
-//----------------------------------------------------------------------------
-//       8192C (RCR) Receive Configuration Register	(Offset 0x608, 32 bits)
-//----------------------------------------------------------------------------
-#define	RCR_APPFCS					BIT31		//WMAC append FCS after pauload
-#define	RCR_APP_MIC				BIT30		//
-#define	RCR_APP_ICV				BIT29       //
-#define	RCR_APP_PHYST_RXFF		BIT28       //
-#define	RCR_APP_BA_SSN			BIT27		//Accept BA SSN
-#define	RCR_ENMBID					BIT24		//Enable Multiple BssId.
+/*  */
+/*        8192C (RCR) Receive Configuration Register	(Offset 0x608, 32 bits) */
+/*  */
+#define	RCR_APPFCS					BIT31		/* WMAC append FCS after pauload */
+#define	RCR_APP_MIC				BIT30		/*  */
+#define	RCR_APP_ICV				BIT29       /*  */
+#define	RCR_APP_PHYST_RXFF		BIT28       /*  */
+#define	RCR_APP_BA_SSN			BIT27		/* Accept BA SSN */
+#define	RCR_ENMBID					BIT24		/* Enable Multiple BssId. */
 #define	RCR_LSIGEN					BIT23
 #define	RCR_MFBEN					BIT22
-#define	RCR_HTC_LOC_CTRL			BIT14       //MFC<--HTC=1 MFC-->HTC=0
-#define	RCR_AMF					BIT13		//Accept management type frame
-#define	RCR_ACF					BIT12		//Accept control type frame
-#define	RCR_ADF					BIT11		//Accept data type frame
-#define	RCR_AICV					BIT9		//Accept ICV error packet
-#define	RCR_ACRC32					BIT8		//Accept CRC32 error packet
-#define	RCR_CBSSID_BCN			BIT7		//Accept BSSID match packet (Rx beacon, probe rsp)
-#define	RCR_CBSSID_DATA			BIT6		//Accept BSSID match packet (Data)
-#define	RCR_CBSSID					RCR_CBSSID_DATA		//Accept BSSID match packet
-#define	RCR_APWRMGT				BIT5		//Accept power management packet
-#define	RCR_ADD3					BIT4		//Accept address 3 match packet
-#define	RCR_AB						BIT3		//Accept broadcast packet
-#define	RCR_AM						BIT2		//Accept multicast packet
-#define	RCR_APM					BIT1		//Accept physical match packet
-#define	RCR_AAP					BIT0		//Accept all unicast packet
+#define	RCR_HTC_LOC_CTRL			BIT14       /* MFC<--HTC=1 MFC-->HTC=0 */
+#define	RCR_AMF					BIT13		/* Accept management type frame */
+#define	RCR_ACF					BIT12		/* Accept control type frame */
+#define	RCR_ADF					BIT11		/* Accept data type frame */
+#define	RCR_AICV					BIT9		/* Accept ICV error packet */
+#define	RCR_ACRC32					BIT8		/* Accept CRC32 error packet */
+#define	RCR_CBSSID_BCN			BIT7		/* Accept BSSID match packet (Rx beacon, probe rsp) */
+#define	RCR_CBSSID_DATA			BIT6		/* Accept BSSID match packet (Data) */
+#define	RCR_CBSSID					RCR_CBSSID_DATA		/* Accept BSSID match packet */
+#define	RCR_APWRMGT				BIT5		/* Accept power management packet */
+#define	RCR_ADD3					BIT4		/* Accept address 3 match packet */
+#define	RCR_AB						BIT3		/* Accept broadcast packet */
+#define	RCR_AM						BIT2		/* Accept multicast packet */
+#define	RCR_APM					BIT1		/* Accept physical match packet */
+#define	RCR_AAP					BIT0		/* Accept all unicast packet */
 #define	RCR_MXDMA_OFFSET			8
 #define	RCR_FIFO_OFFSET			13
 
 
 
-//============================================================================
-//       8192c USB specific Regsiter Offset and Content definition,
-//       2009.08.18, added by vivi. for merge 92c and 92C into one driver
-//============================================================================
-//#define APS_FSMCO				0x0004  same with 92Ce
+/*  */
+/*        8192c USB specific Regsiter Offset and Content definition, */
+/*        2009.08.18, added by vivi. for merge 92c and 92C into one driver */
+/*  */
 #define RSV_CTRL					0x001C
 #define RD_CTRL					0x0524
 
-//-----------------------------------------------------
-//
-//	0xFE00h ~ 0xFE55h	USB Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/* 	0xFE00h ~ 0xFE55h	USB Configuration */
+/*  */
+/*  */
 #define REG_USB_INFO				0xFE17
 #define REG_USB_SPECIAL_OPTION	0xFE55
 #define REG_USB_DMA_AGG_TO		0xFE5B
@@ -1012,20 +1009,20 @@ Current IOREG MAP
 
 #define InvalidBBRFValue			0x12345678
 
-//============================================================================
-//       8192C Regsiter Bit and Content definition
-//============================================================================
-//-----------------------------------------------------
-//
-//	0x0000h ~ 0x00FFh	System Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*        8192C Regsiter Bit and Content definition */
+/*  */
+/*  */
+/*  */
+/* 	0x0000h ~ 0x00FFh	System Configuration */
+/*  */
+/*  */
 
-//2 SPS0_CTRL
+/* 2 SPS0_CTRL */
 #define SW18_FPWM					BIT(3)
 
 
-//2 SYS_ISO_CTRL
+/* 2 SYS_ISO_CTRL */
 #define ISO_MD2PP					BIT(0)
 #define ISO_UA2USB					BIT(1)
 #define ISO_UD2CORE					BIT(2)
@@ -1041,7 +1038,7 @@ Current IOREG MAP
 #define PWC_EV12V					BIT(15)
 
 
-//2 SYS_FUNC_EN
+/* 2 SYS_FUNC_EN */
 #define FEN_BBRSTB					BIT(0)
 #define FEN_BB_GLB_RSTn			BIT(1)
 #define FEN_USBA					BIT(2)
@@ -1059,7 +1056,7 @@ Current IOREG MAP
 #define FEN_HWPDN					BIT(14)
 #define FEN_MREGEN					BIT(15)
 
-//2 APS_FSMCO
+/* 2 APS_FSMCO */
 #define PFM_LDALL					BIT(0)
 #define PFM_ALDN					BIT(1)
 #define PFM_LDKP					BIT(2)
@@ -1087,7 +1084,7 @@ Current IOREG MAP
 #define SOP_A8M						BIT(30)
 #define XOP_BTCK					BIT(31)
 
-//2 SYS_CLKR
+/* 2 SYS_CLKR */
 #define ANAD16V_EN					BIT(0)
 #define ANA8M						BIT(1)
 #define MACSLP						BIT(4)
@@ -1101,25 +1098,25 @@ Current IOREG MAP
 #define RING_CLK_EN					BIT(13)
 
 
-//2 9346CR
+/* 2 9346CR */
 
 #define BOOT_FROM_EEPROM			BIT(4)
 #define EEPROM_EN					BIT(5)
 
 
-//2 AFE_MISC
+/* 2 AFE_MISC */
 #define AFE_BGEN					BIT(0)
 #define AFE_MBEN					BIT(1)
 #define MAC_ID_EN					BIT(7)
 
 
-//2 SPS0_CTRL
+/* 2 SPS0_CTRL */
 
 
-//2 SPS_OCP_CFG
+/* 2 SPS_OCP_CFG */
 
 
-//2 RSV_CTRL
+/* 2 RSV_CTRL */
 #define WLOCK_ALL					BIT(0)
 #define WLOCK_00					BIT(1)
 #define WLOCK_04					BIT(2)
@@ -1129,14 +1126,14 @@ Current IOREG MAP
 #define R_DIS_PRST_1				BIT(6)
 #define LOCK_ALL_EN					BIT(7)
 
-//2 RF_CTRL
+/* 2 RF_CTRL */
 #define RF_EN						BIT(0)
 #define RF_RSTB						BIT(1)
 #define RF_SDMRSTB					BIT(2)
 
 
 
-//2 LDOA15_CTRL
+/* 2 LDOA15_CTRL */
 #define LDA15_EN					BIT(0)
 #define LDA15_STBY					BIT(1)
 #define LDA15_OBUF					BIT(2)
@@ -1145,7 +1142,7 @@ Current IOREG MAP
 
 
 
-//2 LDOV12D_CTRL
+/* 2 LDOV12D_CTRL */
 #define LDV12_EN					BIT(0)
 #define LDV12_SDBY					BIT(1)
 #define LPLDO_HSM					BIT(2)
@@ -1153,7 +1150,7 @@ Current IOREG MAP
 #define _LDV12_VADJ(x)				(((x) & 0xF) << 4)
 
 
-//2 AFE_XTAL_CTRL
+/* 2 AFE_XTAL_CTRL */
 #define XTAL_EN						BIT(0)
 #define XTAL_BSEL					BIT(1)
 #define _XTAL_BOSC(x)				(((x) & 0x3) << 2)
@@ -1177,7 +1174,7 @@ Current IOREG MAP
 #define CKDLY_BT					BIT(29)
 
 
-//2 AFE_PLL_CTRL
+/* 2 AFE_PLL_CTRL */
 #define APLL_EN						BIT(0)
 #define APLL_320_EN					BIT(1)
 #define APLL_FREF_SEL				BIT(2)
@@ -1198,25 +1195,25 @@ Current IOREG MAP
 #define APLL_1MEN					BIT(24)
 
 
-//2 EFUSE_CTRL
+/* 2 EFUSE_CTRL */
 #define ALD_EN						BIT(18)
 #define EF_PD						BIT(19)
 #define EF_FLAG						BIT(31)
 
-//2 EFUSE_TEST
+/* 2 EFUSE_TEST */
 #define EF_TRPT						BIT(7)
 #define LDOE25_EN					BIT(31)
 
-//2 PWR_DATA
+/* 2 PWR_DATA */
 
-//2 CAL_TIMER
+/* 2 CAL_TIMER */
 
-//2 ACLK_MON
+/* 2 ACLK_MON */
 #define RSM_EN						BIT(0)
 #define Timer_EN						BIT(4)
 
 
-//2 GPIO_MUXCFG
+/* 2 GPIO_MUXCFG */
 #define TRSW0EN						BIT(2)
 #define TRSW1EN						BIT(3)
 #define EROM_EN						BIT(4)
@@ -1230,26 +1227,26 @@ Current IOREG MAP
 #define EnHDP						BIT(14)
 #define SIC_LBK						BIT(15)
 
-//2 GPIO_PIN_CTRL
+/* 2 GPIO_PIN_CTRL */
 
 
 
-//2 GPIO_INTM
+/* 2 GPIO_INTM */
 
-//2 LEDCFG
+/* 2 LEDCFG */
 #define LED0PL					BIT(4)
 #define LED1PL					BIT(12)
 #define LED0DIS					BIT(7)
 
 #define  SECCAM_CLR				BIT(30)
 
-//2 FSIMR
+/* 2 FSIMR */
 
-//2 FSISR
+/* 2 FSISR */
 
 
-//2 8051FWDL
-//2 MCUFWDL
+/* 2 8051FWDL */
+/* 2 MCUFWDL */
 #define MCUFWDL_EN					BIT(0)
 #define MCUFWDL_RDY				BIT(1)
 #define FWDL_ChkSum_rpt			BIT(2)
@@ -1257,13 +1254,13 @@ Current IOREG MAP
 #define BBINI_RDY					BIT(4)
 #define RFINI_RDY					BIT(5)
 #define WINTINI_RDY					BIT(6)
-#define MAC1_WINTINI_RDY			BIT(11)// 0X81 BIT3
+#define MAC1_WINTINI_RDY			BIT(11)/*  0X81 BIT3 */
 #define CPRST						BIT(23)
 
 
 
 
-//2 REG_SYS_CFG
+/* 2 REG_SYS_CFG */
 #define XCLK_VLD						BIT(0)
 #define ACLK_VLD					BIT(1)
 #define UCLK_VLD					BIT(2)
@@ -1282,18 +1279,18 @@ Current IOREG MAP
 #define BD_HCI_SEL					BIT(26)
 #define TYPE_ID						BIT(27)
 
-#define CHIP_VER_RTL_MASK			0xF000	//Bit 12 ~ 15
+#define CHIP_VER_RTL_MASK			0xF000	/* Bit 12 ~ 15 */
 #define CHIP_VER_RTL_SHIFT			12
 
-//-----------------------------------------------------
-//
-//	0x0100h ~ 0x01FFh	MACTOP General Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/* 	0x0100h ~ 0x01FFh	MACTOP General Configuration */
+/*  */
+/*  */
 
 
-//2 Function Enable Registers
-//2 CR
+/* 2 Function Enable Registers */
+/* 2 CR */
 
 #define REG_LBMODE					(REG_CR + 3)
 
@@ -1309,7 +1306,7 @@ Current IOREG MAP
 #define ENSWBCN						BIT(8)
 #define ENSEC						BIT(9)
 
-// Network type
+/*  Network type */
 #define _NETTYPE(x)					(((x) & 0x3) << 16)
 #define MASK_NETTYPE				0x30000
 #define NT_NO_LINK					0x0
@@ -1326,7 +1323,7 @@ Current IOREG MAP
 #define LOOPBACK_DMA				0x7
 
 
-//2 PBP - Page Size Register
+/* 2 PBP - Page Size Register */
 #define GET_RX_PAGE_SIZE(value)		((value) & 0xF)
 #define GET_TX_PAGE_SIZE(value)		(((value) & 0xF0) >> 4)
 #define _PSRX_MASK					0xF
@@ -1341,7 +1338,7 @@ Current IOREG MAP
 #define PBP_1024					0x4
 
 
-//2 TX/RXDMA
+/* 2 TX/RXDMA */
 #define RXDMA_ARBBW_EN			BIT(0)
 #define RXSHFT_EN					BIT(1)
 #define RXDMA_AGG_EN				BIT(2)
@@ -1359,7 +1356,7 @@ Current IOREG MAP
 #define HQSEL_MGTQ					BIT(4)
 #define HQSEL_HIQ					BIT(5)
 
-// For normal driver, 0x10C
+/*  For normal driver, 0x10C */
 #define _TXDMA_HIQ_MAP(x)			(((x)&0x3) << 14)
 #define _TXDMA_MGQ_MAP(x)			(((x)&0x3) << 12)
 #define _TXDMA_BKQ_MAP(x)			(((x)&0x3) << 10)
@@ -1373,10 +1370,10 @@ Current IOREG MAP
 
 
 
-//2 TRXFF_BNDY
+/* 2 TRXFF_BNDY */
 
 
-//2 LLT_INIT
+/* 2 LLT_INIT */
 #define _LLT_NO_ACTIVE				0x0
 #define _LLT_WRITE_ACCESS			0x1
 #define _LLT_READ_ACCESS			0x2
@@ -1387,23 +1384,21 @@ Current IOREG MAP
 #define _LLT_OP_VALUE(x)			(((x) >> 30) & 0x3)
 
 
-//2 BB_ACCESS_CTRL
+/* 2 BB_ACCESS_CTRL */
 #define BB_WRITE_READ_MASK		(BIT(31) | BIT(30))
 #define BB_WRITE_EN					BIT(30)
 #define BB_READ_EN					BIT(31)
-//#define BB_ADDR_MASK				0xFFF
-//#define _BB_ADDR(x)					((x) & BB_ADDR_MASK)
 
-//-----------------------------------------------------
-//
-//	0x0200h ~ 0x027Fh	TXDMA Configuration
-//
-//-----------------------------------------------------
-//2 RQPN
+/*  */
+/*  */
+/* 	0x0200h ~ 0x027Fh	TXDMA Configuration */
+/*  */
+/*  */
+/* 2 RQPN */
 #define _HPQ(x)						((x) & 0xFF)
 #define _LPQ(x)						(((x) & 0xFF) << 8)
 #define _PUBQ(x)						(((x) & 0xFF) << 16)
-#define _NPQ(x)						((x) & 0xFF)			// NOTE: in RQPN_NPQ register
+#define _NPQ(x)						((x) & 0xFF)			/*  NOTE: in RQPN_NPQ register */
 
 
 #define HPQ_PUBLIC_DIS				BIT(24)
@@ -1411,37 +1406,37 @@ Current IOREG MAP
 #define LD_RQPN						BIT(31)
 
 
-//2 TDECTRL
+/* 2 TDECTRL */
 #define BCN_VALID					BIT(16)
 #define BCN_HEAD(x)					(((x) & 0xFF) << 8)
 #define	BCN_HEAD_MASK				0xFF00
 
-//2 TDECTL
+/* 2 TDECTL */
 #define BLK_DESC_NUM_SHIFT			4
 #define BLK_DESC_NUM_MASK			0xF
 
 
-//2 TXDMA_OFFSET_CHK
+/* 2 TXDMA_OFFSET_CHK */
 #define DROP_DATA_EN				BIT(9)
 
-//-----------------------------------------------------
-//
-//	0x0400h ~ 0x047Fh	Protocol Configuration
-//
-//-----------------------------------------------------
-//2 FWHW_TXQ_CTRL
+/*  */
+/*  */
+/* 	0x0400h ~ 0x047Fh	Protocol Configuration */
+/*  */
+/*  */
+/* 2 FWHW_TXQ_CTRL */
 #define EN_AMPDU_RTY_NEW			BIT(7)
 
-//2 INIRTSMCS_SEL
+/* 2 INIRTSMCS_SEL */
 #define _INIRTSMCS_SEL(x)			((x) & 0x3F)
 
 
-//2 SPEC SIFS
+/* 2 SPEC SIFS */
 #define _SPEC_SIFS_CCK(x)			((x) & 0xFF)
 #define _SPEC_SIFS_OFDM(x)			(((x) & 0xFF) << 8)
 
 
-//2 RRSR
+/* 2 RRSR */
 
 #define RATE_REG_BITMAP_ALL			0xFFFFF
 
@@ -1454,10 +1449,10 @@ Current IOREG MAP
 #define RRSR_RSC_DUPLICATE_MODE		0x3
 
 
-//2 ARFR
+/* 2 ARFR */
 #define USE_SHORT_G1				BIT(20)
 
-//2 AGGLEN_LMT_L
+/* 2 AGGLEN_LMT_L */
 #define _AGGLMT_MCS0(x)				((x) & 0xF)
 #define _AGGLMT_MCS1(x)				(((x) & 0xF) << 4)
 #define _AGGLMT_MCS2(x)				(((x) & 0xF) << 8)
@@ -1468,29 +1463,29 @@ Current IOREG MAP
 #define _AGGLMT_MCS7(x)				(((x) & 0xF) << 28)
 
 
-//2 RL
+/* 2 RL */
 #define	RETRY_LIMIT_SHORT_SHIFT		8
 #define	RETRY_LIMIT_LONG_SHIFT		0
 
 
-//2 DARFRC
+/* 2 DARFRC */
 #define _DARF_RC1(x)				((x) & 0x1F)
 #define _DARF_RC2(x)				(((x) & 0x1F) << 8)
 #define _DARF_RC3(x)				(((x) & 0x1F) << 16)
 #define _DARF_RC4(x)				(((x) & 0x1F) << 24)
-// NOTE: shift starting from address (DARFRC + 4)
+/*  NOTE: shift starting from address (DARFRC + 4) */
 #define _DARF_RC5(x)				((x) & 0x1F)
 #define _DARF_RC6(x)				(((x) & 0x1F) << 8)
 #define _DARF_RC7(x)				(((x) & 0x1F) << 16)
 #define _DARF_RC8(x)				(((x) & 0x1F) << 24)
 
 
-//2 RARFRC
+/* 2 RARFRC */
 #define _RARF_RC1(x)				((x) & 0x1F)
 #define _RARF_RC2(x)				(((x) & 0x1F) << 8)
 #define _RARF_RC3(x)				(((x) & 0x1F) << 16)
 #define _RARF_RC4(x)				(((x) & 0x1F) << 24)
-// NOTE: shift starting from address (RARFRC + 4)
+/*  NOTE: shift starting from address (RARFRC + 4) */
 #define _RARF_RC5(x)				((x) & 0x1F)
 #define _RARF_RC6(x)				(((x) & 0x1F) << 8)
 #define _RARF_RC7(x)				(((x) & 0x1F) << 16)
@@ -1499,62 +1494,62 @@ Current IOREG MAP
 
 
 
-//-----------------------------------------------------
-//
-//	0x0500h ~ 0x05FFh	EDCA Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/* 	0x0500h ~ 0x05FFh	EDCA Configuration */
+/*  */
+/*  */
 
 
 
-//2 EDCA setting
+/* 2 EDCA setting */
 #define AC_PARAM_TXOP_LIMIT_OFFSET	16
 #define AC_PARAM_ECW_MAX_OFFSET		12
 #define AC_PARAM_ECW_MIN_OFFSET		8
 #define AC_PARAM_AIFS_OFFSET			0
 
 
-//2 EDCA_VO_PARAM
+/* 2 EDCA_VO_PARAM */
 #define _AIFS(x)						(x)
 #define _ECW_MAX_MIN(x)			((x) << 8)
-#define _TXOP_LIMIT(x)				((x) << 16)
+#define _TXOP_LIMIT(x)			((x) << 16)
 
 
-#define _BCNIFS(x)					((x) & 0xFF)
-#define _BCNECW(x)					(((x) & 0xF))<< 8)
+#define _BCNIFS(x)			((x) & 0xFF)
+#define _BCNECW(x)			((((x) & 0xF))<< 8)
 
 
-#define _LRL(x)						((x) & 0x3F)
-#define _SRL(x)						(((x) & 0x3F) << 8)
+#define _LRL(x)				((x) & 0x3F)
+#define _SRL(x)				(((x) & 0x3F) << 8)
 
 
-//2 SIFS_CCK
-#define _SIFS_CCK_CTX(x)			((x) & 0xFF)
-#define _SIFS_CCK_TRX(x)			(((x) & 0xFF) << 8);
+/* 2 SIFS_CCK */
+#define _SIFS_CCK_CTX(x)		((x) & 0xFF)
+#define _SIFS_CCK_TRX(x)		(((x) & 0xFF) << 8);
 
 
-//2 SIFS_OFDM
-#define _SIFS_OFDM_CTX(x)			((x) & 0xFF)
-#define _SIFS_OFDM_TRX(x)			(((x) & 0xFF) << 8);
+/* 2 SIFS_OFDM */
+#define _SIFS_OFDM_CTX(x)		((x) & 0xFF)
+#define _SIFS_OFDM_TRX(x)		(((x) & 0xFF) << 8);
 
 
-//2 TBTT PROHIBIT
+/* 2 TBTT PROHIBIT */
 #define _TBTT_PROHIBIT_HOLD(x)		(((x) & 0xFF) << 8)
 
 
-//2 REG_RD_CTRL
+/* 2 REG_RD_CTRL */
 #define DIS_EDCA_CNT_DWN			BIT(11)
 
 
-//2 BCN_CTRL
+/* 2 BCN_CTRL */
 #define EN_MBSSID						BIT(1)
 #define EN_TXBCN_RPT					BIT(2)
 #define EN_BCN_FUNCTION				BIT(3)
-// The same function but different bit field.
+/*  The same function but different bit field. */
 #define DIS_TSF_UDT0_NORMAL_CHIP		BIT(4)
 #define DIS_TSF_UDT0_TEST_CHIP		BIT(5)
 
-//2 ACMHWCTRL
+/* 2 ACMHWCTRL */
 #define	AcmHw_HwEn					BIT(0)
 #define	AcmHw_BeqEn					BIT(1)
 #define	AcmHw_ViqEn					BIT(2)
@@ -1565,29 +1560,28 @@ Current IOREG MAP
 
 
 
-//-----------------------------------------------------
-//
-//	0x0600h ~ 0x07FFh	WMAC Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/* 	0x0600h ~ 0x07FFh	WMAC Configuration */
+/*  */
+/*  */
 
-//2 APSD_CTRL
+/* 2 APSD_CTRL */
 #define APSDOFF						BIT(6)
 #define APSDOFF_STATUS				BIT(7)
 
 
-//2 BWOPMODE
+/* 2 BWOPMODE */
 #define BW_20MHZ					BIT(2)
-//#define BW_OPMODE_20MHZ				BIT(2)	// For compability
 
 
 #define RATE_BITMAP_ALL			0xFFFFF
 
-// Only use CCK 1M rate for ACK
+/*  Only use CCK 1M rate for ACK */
 #define RATE_RRSR_CCK_ONLY_1M		0xFFFF1
 #define RATE_RRSR_WITHOUT_CCK		0xFFFF0
 
-//2 TCR
+/* 2 TCR */
 #define TSFRST						BIT(0)
 #define DIS_GCLK						BIT(1)
 #define PAD_SEL						BIT(2)
@@ -1599,7 +1593,7 @@ Current IOREG MAP
 
 
 
-//2 RCR
+/* 2 RCR */
 #define AAP							BIT(0)
 #define APM							BIT(1)
 #define AM							BIT(2)
@@ -1625,20 +1619,20 @@ Current IOREG MAP
 #define APP_MIC						BIT(30)
 #define APP_FCS						BIT(31)
 
-//2 RX_PKT_LIMIT
+/* 2 RX_PKT_LIMIT */
 
-//2 RX_DLK_TIME
+/* 2 RX_DLK_TIME */
 
-//2 MBIDCAMCFG
+/* 2 MBIDCAMCFG */
 
 
 
-//2 AMPDU_MIN_SPACE
+/* 2 AMPDU_MIN_SPACE */
 #define _MIN_SPACE(x)				((x) & 0x7)
 #define _SHORT_GI_PADDING(x)		(((x) & 0x1F) << 3)
 
 
-//2 RXERR_RPT
+/* 2 RXERR_RPT */
 #define RXERR_TYPE_OFDM_PPDU			0
 #define RXERR_TYPE_OFDMfalse_ALARM	1
 #define RXERR_TYPE_OFDM_MPDU_OK		2
@@ -1659,30 +1653,30 @@ Current IOREG MAP
 #define _RXERR_RPT_SEL(type)			((type) << 28)
 
 
-//2 SECCFG
-#define	SCR_TxUseDK					BIT(0)			//Force Tx Use Default Key
-#define	SCR_RxUseDK					BIT(1)			//Force Rx Use Default Key
-#define	SCR_TxEncEnable				BIT(2)			//Enable Tx Encryption
-#define	SCR_RxDecEnable				BIT(3)			//Enable Rx Decryption
-#define	SCR_SKByA2						BIT(4)			//Search kEY BY A2
-#define	SCR_NoSKMC						BIT(5)			//No Key Search Multicast
-#define		SCR_TXBCUSEDK					BIT(6)			// Force Tx Broadcast packets Use Default Key
-#define		SCR_RXBCUSEDK					BIT(7)			// Force Rx Broadcast packets Use Default Key
+/* 2 SECCFG */
+#define	SCR_TxUseDK					BIT(0)			/* Force Tx Use Default Key */
+#define	SCR_RxUseDK					BIT(1)			/* Force Rx Use Default Key */
+#define	SCR_TxEncEnable				BIT(2)			/* Enable Tx Encryption */
+#define	SCR_RxDecEnable				BIT(3)			/* Enable Rx Decryption */
+#define	SCR_SKByA2						BIT(4)			/* Search kEY BY A2 */
+#define	SCR_NoSKMC						BIT(5)			/* No Key Search Multicast */
+#define		SCR_TXBCUSEDK					BIT(6)			/*  Force Tx Broadcast packets Use Default Key */
+#define		SCR_RXBCUSEDK					BIT(7)			/*  Force Rx Broadcast packets Use Default Key */
 
-//vivi added for new cam search flow, 20091028
+/* vivi added for new cam search flow, 20091028 */
 #ifdef HW_EN_DE_CRYPTION_FOR_NEW_CAM_SEARCH_FLOW
-#define	SCR_TxUseBroadcastDK			BIT6			//Force Tx Use Broadcast Default Key
-#define	SCR_RxUseBroadcastDK			BIT7			//Force Rx Use Broadcast Default Key
+#define	SCR_TxUseBroadcastDK			BIT6			/* Force Tx Use Broadcast Default Key */
+#define	SCR_RxUseBroadcastDK			BIT7			/* Force Rx Use Broadcast Default Key */
 #endif
 
 
-//-----------------------------------------------------
-//
-//	0xFE00h ~ 0xFE55h	USB Configuration
-//
-//-----------------------------------------------------
+/*  */
+/*  */
+/* 	0xFE00h ~ 0xFE55h	USB Configuration */
+/*  */
+/*  */
 
-//2 USB Information (0xFE17)
+/* 2 USB Information (0xFE17) */
 #define USB_IS_HIGH_SPEED				0
 #define USB_IS_FULL_SPEED				1
 #define USB_SPEED_MASK					BIT(5)
@@ -1693,24 +1687,24 @@ Current IOREG MAP
 #define USB_TEST_EP_MASK				0x30
 #define USB_TEST_EP_SHIFT				4
 
-//2 Special Option
+/* 2 Special Option */
 #define USB_AGG_EN						BIT(3)
 
 
-//2REG_C2HEVT_CLEAR
-#define C2H_EVT_HOST_CLOSE				0x00	// Set by driver and notify FW that the driver has read the C2H command message
-#define C2H_EVT_FW_CLOSE				0xFF	// Set by FW indicating that FW had set the C2H command message and it's not yet read by driver.
+/* 2REG_C2HEVT_CLEAR */
+#define C2H_EVT_HOST_CLOSE				0x00	/*  Set by driver and notify FW that the driver has read the C2H command message */
+#define C2H_EVT_FW_CLOSE				0xFF	/*  Set by FW indicating that FW had set the C2H command message and it's not yet read by driver. */
 
-//2 8192D PartNo.
+/* 2 8192D PartNo. */
 #define		PARTNO_92D_NIC			(BIT7|BIT6)
 #define		PARTNO_92D_NIC_REMARK (BIT5|BIT4)
 #define		PARTNO_SINGLE_BAND_VS  BIT3
 #define		PARTNO_SINGLE_BAND_VS_REMARK BIT1
 #define		PARTNO_CONCURRENT_BAND_VC (BIT3|BIT2)
 #define		PARTNO_CONCURRENT_BAND_VC_REMARK (BIT1|BIT0)
-//========================================================
-// General definitions
-//========================================================
+/*  */
+/*  General definitions */
+/*  */
 
 #define MAC_ADDR_LEN						6
 #define LAST_ENTRY_OF_TX_PKT_BUFFER		255
@@ -1719,10 +1713,10 @@ Current IOREG MAP
 #define POLLING_LLT_THRESHOLD				20
 #define POLLING_READY_TIMEOUT_COUNT		1000
 
-// Min Spacing related settings.
+/*  Min Spacing related settings. */
 #define	MAX_MSS_DENSITY_2T				0x13
 #define	MAX_MSS_DENSITY_1T				0x0A
-// GPIO BIT
+/*  GPIO BIT */
 #define	HAL_8192C_HW_GPIO_WPS_BIT		BIT2
 
 
--- a/drivers/staging/rtl8192du/include/rtl8192d_xmit.h
+++ b/drivers/staging/rtl8192du/include/rtl8192d_xmit.h
@@ -20,24 +20,24 @@
 #ifndef _RTL8192D_XMIT_H_
 #define _RTL8192D_XMIT_H_
 
-//
-// Queue Select Value in TxDesc
-//
-#define QSLT_BK							0x2//0x01
+/*  */
+/*  Queue Select Value in TxDesc */
+/*  */
+#define QSLT_BK							0x2/* 0x01 */
 #define QSLT_BE							0x0
-#define QSLT_VI							0x5//0x4
-#define QSLT_VO							0x7//0x6
+#define QSLT_VI							0x5/* 0x4 */
+#define QSLT_VO							0x7/* 0x6 */
 #define QSLT_BEACON						0x10
 #define QSLT_HIGH						0x11
 #define QSLT_MGNT						0x12
 #define QSLT_CMD						0x13
 
-//Because we open EM for normal case, we just always insert 2*8 bytes.by wl
+/* Because we open EM for normal case, we just always insert 2*8 bytes.by wl */
 #define USB_92D_DUMMY_OFFSET		2
 #define USB_92D_DUMMY_LENGTH		(USB_92D_DUMMY_OFFSET * PACKET_OFFSET_SZ)
 #define USB_HWDESC_HEADER_LEN	(TXDESC_SIZE + USB_92D_DUMMY_LENGTH)
 
-//For 92D early mode
+/* For 92D early mode */
 #define SET_EARLYMODE_PKTNUM(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 0, 3, __Value)
 #define SET_EARLYMODE_LEN0(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 4, 12, __Value)
 #define SET_EARLYMODE_LEN1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 16, 12, __Value)
--- a/drivers/staging/rtl8192du/include/rtw_android.h
+++ b/drivers/staging/rtl8192du/include/rtw_android.h
@@ -86,4 +86,4 @@ static int rtw_android_wifictrl_func_add
 static void rtw_android_wifictrl_func_del(void) {}
 #endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
 
-#endif //__RTW_ANDROID_H__
+#endif /* __RTW_ANDROID_H__ */
--- a/drivers/staging/rtl8192du/include/rtw_ap.h
+++ b/drivers/staging/rtl8192du/include/rtw_ap.h
@@ -27,7 +27,7 @@
 
 #ifdef CONFIG_AP_MODE
 
-//external function
+/* external function */
 extern void rtw_indicate_sta_assoc_event(struct rtw_adapter *padapter, struct sta_info *psta);
 extern void rtw_indicate_sta_disassoc_event(struct rtw_adapter *padapter, struct sta_info *psta);
 
@@ -56,6 +56,6 @@ int rtw_ap_inform_ch_switch (struct rtw_
 void start_ap_mode(struct rtw_adapter *padapter);
 void stop_ap_mode(struct rtw_adapter *padapter);
 #endif
-#endif //end of CONFIG_AP_MODE
+#endif /* end of CONFIG_AP_MODE */
 
 #endif
--- a/drivers/staging/rtl8192du/include/rtw_br_ext.h
+++ b/drivers/staging/rtl8192du/include/rtw_br_ext.h
@@ -57,11 +57,11 @@ struct br_ext_info {
 	unsigned int	nat25_disable;
 	unsigned int	macclone_enable;
 	unsigned int	dhcp_bcst_disable;
-	int		addPPPoETag;		// 1: Add PPPoE relay-SID, 0: disable
+	int		addPPPoETag;		/*  1: Add PPPoE relay-SID, 0: disable */
 	unsigned char	nat25_dmzMac[MACADDRLEN];
 	unsigned int	nat25sc_disable;
 };
 
 void nat25_db_cleanup(struct rtw_adapter *priv);
 
-#endif // _RTW_BR_EXT_H_
+#endif /*  _RTW_BR_EXT_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_cmd.h
+++ b/drivers/staging/rtl8192du/include/rtw_cmd.h
@@ -28,7 +28,7 @@
 #define C2H_MEM_SZ (16*1024)
 
 	#include <osdep_service.h>
-	#include <ieee80211.h> // <ieee80211/ieee80211.h>
+	#include <ieee80211.h> /*  <ieee80211/ieee80211.h> */
 
 
 	#define FREE_CMDOBJ_SZ	128
@@ -55,9 +55,9 @@
 		struct  semaphore terminate_cmdthread_sema;
 		struct __queue cmd_queue;
 		u8	cmd_seq;
-		u8	*cmd_buf;	//shall be non-paged, and 4 bytes aligned
+		u8	*cmd_buf;	/* shall be non-paged, and 4 bytes aligned */
 		u8	*cmd_allocated_buf;
-		u8	*rsp_buf;	//shall be non-paged, and 4 bytes aligned
+		u8	*rsp_buf;	/* shall be non-paged, and 4 bytes aligned */
 		u8	*rsp_allocated_buf;
 		u32	cmd_issued_cnt;
 		u32	cmd_done_cnt;
@@ -83,7 +83,7 @@
 		struct __queue evt_queue;
 #endif
 
-//#define CONFIG_C2H_WK
+/* define CONFIG_C2H_WK */
 #ifdef CONFIG_C2H_WK
 		struct work_struct c2h_wk;
 		bool c2h_wk_alive;
@@ -98,7 +98,7 @@
 		u8	*cmdevt_parm;
 #endif
 		ATOMIC_T event_seq;
-		u8	*evt_buf;	//shall be non-paged, and 4 bytes aligned
+		u8	*evt_buf;	/* shall be non-paged, and 4 bytes aligned */
 		u8	*evt_allocated_buf;
 		u32	evt_done_cnt;
 	};
@@ -143,7 +143,7 @@ extern void rtw_cmd_clr_isr(struct cmd_p
 extern void rtw_evt_notify_isr(struct evt_priv *pevtpriv);
 #ifdef CONFIG_P2P
 u8 p2p_protocol_wk_cmd(struct rtw_adapter*padapter, int intCmdType);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 enum rtw_drvextra_cmd_id
 {
@@ -151,12 +151,12 @@ enum rtw_drvextra_cmd_id
 	DYNAMIC_CHK_WK_CID,
 	DM_CTRL_WK_CID,
 	PBC_POLLING_WK_CID,
-	POWER_SAVING_CTRL_WK_CID,//IPS,AUTOSuspend
+	POWER_SAVING_CTRL_WK_CID,/* IPS,AUTOSuspend */
 	LPS_CTRL_WK_CID,
 	ANT_SELECT_WK_CID,
 	P2P_PS_WK_CID,
 	P2P_PROTO_WK_CID,
-	CHECK_HIQ_WK_CID,//for softap mode, check hi queue if empty
+	CHECK_HIQ_WK_CID,/* for softap mode, check hi queue if empty */
 	INTEl_WIDI_WK_CID,
 	C2H_WK_CID,
 	MAX_WK_CID
@@ -186,7 +186,7 @@ Command Mode
 
 */
 struct usb_suspend_parm {
-	u32 action;// 1: sleep, 0:resume
+	u32 action;/*  1: sleep, 0:resume */
 };
 
 /*
@@ -233,24 +233,6 @@ struct createbss_parm {
 	struct wlan_bssid_ex network;
 };
 
-/*
-Caller Mode: AP, Ad-HoC, Infra
-
-Notes: To set the NIC mode of RTL8711
-
-Command Mode
-
-The definition of mode:
-
-#define IW_MODE_AUTO	0	// Let the driver decides which AP to join
-#define IW_MODE_ADHOC	1	// SINGLE cell network (Ad-Hoc Clients)
-#define IW_MODE_INFRA	2	// Multi cell network, roaming, ..
-#define IW_MODE_MASTER	3	// Synchronisation master or Access Point
-#define IW_MODE_REPEAT	4	// Wireless Repeater (forwarder)
-#define IW_MODE_SECOND	5	// Secondary master/repeater (backup)
-#define IW_MODE_MONITOR	6	// Passive monitor (listen only)
-
-*/
 struct	setopmode_parm {
 	u8	mode;
 	u8	rsvd[3];
@@ -265,10 +247,10 @@ Command-Event Mode
 
 */
 
-#define RTW_SSID_SCAN_AMOUNT 9 // for WEXT_CSCAN_AMOUNT 9
+#define RTW_SSID_SCAN_AMOUNT 9 /*  for WEXT_CSCAN_AMOUNT 9 */
 #define RTW_CHANNEL_SCAN_AMOUNT (14+37)
 struct sitesurvey_parm {
-	int scan_mode;	//active: 1, passive: 0
+	int scan_mode;	/* active: 1, passive: 0 */
 	u8 ssid_num;
 	u8 ch_num;
 	struct ndis_802_11_ssid ssid[RTW_SSID_SCAN_AMOUNT];
@@ -284,8 +266,8 @@ Command Mode
 
 */
 struct setauth_parm {
-	u8 mode;  //0: legacy open, 1: legacy shared 2: 802.1x
-	u8 _1x;   //0: PSK, 1: TLS
+	u8 mode;  /* 0: legacy open, 1: legacy shared 2: 802.1x */
+	u8 _1x;   /* 0: PSK, 1: TLS */
 	u8 rsvd[2];
 };
 
@@ -302,11 +284,11 @@ when 802.1x ==> keyid > 2 ==> unicast ke
 
 */
 struct setkey_parm {
-	u8	algorithm;	// encryption algorithm, could be none, wep40, TKIP, CCMP, wep104
+	u8	algorithm;	/*  encryption algorithm, could be none, wep40, TKIP, CCMP, wep104 */
 	u8	keyid;
-	u8	grpkey;		// 1: this is the grpkey for 802.1x. 0: this is the unicast key for 802.1x
-	u8	set_tx;		// 1: main tx key for wep. 0: other key.
-	u8	key[16];	// this could be 40 or 104
+	u8	grpkey;		/*  1: this is the grpkey for 802.1x. 0: this is the unicast key for 802.1x */
+	u8	set_tx;		/*  1: main tx key for wep. 0: other key. */
+	u8	key[16];	/*  this could be 40 or 104 */
 };
 
 /*
@@ -321,7 +303,7 @@ when shared key ==> algorithm/keyid
 struct set_stakey_parm {
 	u8	addr[ETH_ALEN];
 	u8	algorithm;
-	u8	id;// currently for erasing cam entry if algorithm == _NO_PRIVACY_
+	u8	id;/*  currently for erasing cam entry if algorithm == _NO_PRIVACY_ */
 	u8	key[16];
 };
 
@@ -624,10 +606,10 @@ struct geth2clbk_rsp {
 
 #endif	/* CONFIG_H2CLBK */
 
-// CMD param Formart for driver extra cmd handler
+/*  CMD param Formart for driver extra cmd handler */
 struct drvextra_cmd_parm {
-	int ec_id; //extra cmd id
-	int type_size; // Can use this field as the type id or command size
+	int ec_id; /* extra cmd id */
+	int type_size; /*  Can use this field as the type id or command size */
 	unsigned char *pbuf;
 };
 
@@ -656,7 +638,7 @@ struct gettxagctbl_rsp {
 };
 
 struct setagcctrl_parm {
-	u32	agcctrl;		// 0: pure hw, 1: fw
+	u32	agcctrl;		/*  0: pure hw, 1: fw */
 };
 
 
@@ -725,7 +707,7 @@ struct getratable_rsp {
 };
 
 
-//to get TX,RX retry count
+/* to get TX,RX retry count */
 struct gettxretrycnt_parm{
 	unsigned int rsvd;
 };
@@ -740,7 +722,7 @@ struct getrxretrycnt_rsp{
 	unsigned long rx_retrycnt;
 };
 
-//to get BCNOK,BCNERR count
+/* to get BCNOK,BCNERR count */
 struct getbcnokcnt_parm{
 	unsigned int rsvd;
 };
@@ -755,7 +737,7 @@ struct getbcnerrcnt_rsp{
 	unsigned long bcnerrcnt;
 };
 
-// to get current TX power level
+/*  to get current TX power level */
 struct getcurtxpwrlevel_parm{
 	unsigned int rsvd;
 };
@@ -813,7 +795,7 @@ struct SWITCHANTENNA_parm
 {
 	u16 antenna_tx;
 	u16 antenna_rx;
-//	R_ANTENNA_SELECT_CCK cck_txrx;
+/* 	R_ANTENNA_SELECT_CCK cck_txrx; */
 	u8 cck_txrx;
 };
 
@@ -1136,4 +1118,4 @@ struct _cmd_callback	rtw_cmd_callback[]
 };
 #endif
 
-#endif // _CMD_H_
+#endif /*  _CMD_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_debug.h
+++ b/drivers/staging/rtl8192du/include/rtw_debug.h
@@ -64,7 +64,7 @@
 #define _module_hci_ops_os_c_			BIT(24)
 #define _module_rtl871x_ioctl_os_c		BIT(25)
 #define _module_rtl8712_cmd_c_		BIT(26)
-//#define _module_efuse_			BIT(27)
+/* define _module_efuse_			BIT(27) */
 #define	_module_rtl8192c_xmit_c_ BIT(28)
 #define _module_hal_xmit_c_	BIT(28)
 #define _module_efuse_			BIT(29)
@@ -418,6 +418,6 @@ extern u32 GlobalDebugLevel;
 		unsigned long count, void *data);
 
 
-#endif //CONFIG_PROC_DEBUG
+#endif /* CONFIG_PROC_DEBUG */
 
-#endif	//__RTW_DEBUG_H__
+#endif	/* __RTW_DEBUG_H__ */
--- a/drivers/staging/rtl8192du/include/rtw_eeprom.h
+++ b/drivers/staging/rtl8192du/include/rtw_eeprom.h
@@ -26,19 +26,19 @@
 
 #define	RTL8712_EEPROM_ID			0x8712
 #define	EEPROM_MAX_SIZE			256
-#define	CLOCK_RATE					50			//100us
+#define	CLOCK_RATE					50			/* 100us */
 
-//- EEPROM opcodes
+/*  EEPROM opcodes */
 #define EEPROM_READ_OPCODE		06
 #define EEPROM_WRITE_OPCODE		05
 #define EEPROM_ERASE_OPCODE		07
-#define EEPROM_EWEN_OPCODE		19      // Erase/write enable
-#define EEPROM_EWDS_OPCODE		16      // Erase/write disable
+#define EEPROM_EWEN_OPCODE		19      /*  Erase/write enable */
+#define EEPROM_EWDS_OPCODE		16      /*  Erase/write disable */
 
-//Country codes
+/* Country codes */
 #define USA							0x555320
-#define EUROPE						0x1 //temp, should be provided later
-#define JAPAN						0x2 //temp, should be provided later
+#define EUROPE						0x1 /* temp, should be provided later */
+#define JAPAN						0x2 /* temp, should be provided later */
 
 #define	EEPROM_CID_DEFAULT			0x0
 #define	EEPROM_CID_ALPHA				0x1
@@ -52,16 +52,16 @@
 #define	EEPROM_CID_CAMEO1				0xF
 #define	EEPROM_CID_WNC_COREGA		0x12
 #define	EEPROM_CID_CLEVO				0x13
-#define	EEPROM_CID_WHQL				0xFE // added by chiyoko for dtm, 20090108
+#define	EEPROM_CID_WHQL				0xFE /*  added by chiyoko for dtm, 20090108 */
 
-//
-// Customer ID, note that:
-// This variable is initiailzed through EEPROM or registry,
-// however, its definition may be different with that in EEPROM for
-// EEPROM size consideration. So, we have to perform proper translation between them.
-// Besides, CustomerID of registry has precedence of that of EEPROM.
-// defined below. 060703, by rcnjko.
-//
+/*  */
+/*  Customer ID, note that: */
+/*  This variable is initiailzed through EEPROM or registry, */
+/*  however, its definition may be different with that in EEPROM for */
+/*  EEPROM size consideration. So, we have to perform proper translation between them. */
+/*  Besides, CustomerID of registry has precedence of that of EEPROM. */
+/*  defined below. 060703, by rcnjko. */
+/*  */
 enum RT_CUSTOMER_ID {
 	RT_CID_DEFAULT = 0,
 	RT_CID_8187_ALPHA0 = 1,
@@ -72,7 +72,7 @@ enum RT_CUSTOMER_ID {
 	RT_CID_819x_CAMEO  = 6,
 	RT_CID_819x_RUNTOP = 7,
 	RT_CID_819x_Senao = 8,
-	RT_CID_TOSHIBA = 9,	// Merge by Jacken, 2008/01/31.
+	RT_CID_TOSHIBA = 9,	/*  Merge by Jacken, 2008/01/31. */
 	RT_CID_819x_Netcore = 10,
 	RT_CID_Nettronix = 11,
 	RT_CID_DLINK = 12,
@@ -81,7 +81,7 @@ enum RT_CUSTOMER_ID {
 	RT_CID_CHINA_MOBILE = 15,
 	RT_CID_819x_ALPHA = 16,
 	RT_CID_819x_Sitecom = 17,
-	RT_CID_CCX = 18, // It's set under CCX logo test and isn't demanded for CCX functions, but for test behavior like retry limit and tx report. By Bruce, 2009-02-17.
+	RT_CID_CCX = 18, /*  It's set under CCX logo test and isn't demanded for CCX functions, but for test behavior like retry limit and tx report. By Bruce, 2009-02-17. */
 	RT_CID_819x_Lenovo = 19,
 	RT_CID_819x_QMI = 20,
 	RT_CID_819x_Edimax_Belkin = 21,
@@ -90,7 +90,7 @@ enum RT_CUSTOMER_ID {
 	RT_CID_819x_MSI = 24,
 	RT_CID_819x_Acer = 25,
 	RT_CID_819x_AzWave_ASUS = 26,
-	RT_CID_819x_AzWave = 27, // For AzWave in PCIe, The ID is AzWave use and not only Asus
+	RT_CID_819x_AzWave = 27, /*  For AzWave in PCIe, The ID is AzWave use and not only Asus */
 	RT_CID_819x_HP = 28,
 	RT_CID_819x_WNC_COREGA = 29,
 	RT_CID_819x_Arcadyan_Belkin = 30,
@@ -105,7 +105,7 @@ enum RT_CUSTOMER_ID {
 struct eeprom_priv
 {
 	u8		bautoload_fail_flag;
-	u8		mac_addr[6];	//PermanentAddress
+	u8		mac_addr[6];	/* PermanentAddress */
 	u16		channel_plan;
 	u8		EepromOrEfuse;
 	u8		efuse_eeprom_data[EEPROM_MAX_SIZE];
@@ -123,6 +123,6 @@ extern void read_eeprom_content_by_attri
 extern int isAdaptorInfoFileValid(void);
 extern int storeAdaptorInfoFile(char *path, struct eeprom_priv * eeprom_priv);
 extern int retriveAdaptorInfoFile(char *path, struct eeprom_priv * eeprom_priv);
-#endif //CONFIG_ADAPTOR_INFO_CACHING_FILE
+#endif /* CONFIG_ADAPTOR_INFO_CACHING_FILE */
 
-#endif  //__RTL871X_EEPROM_H__
+#endif  /* __RTL871X_EEPROM_H__ */
--- a/drivers/staging/rtl8192du/include/rtw_efuse.h
+++ b/drivers/staging/rtl8192du/include/rtw_efuse.h
@@ -59,13 +59,13 @@ enum _EFUSE_DEF_TYPE {
 
 #define		EFUSE_REPEAT_THRESHOLD_			3
 
-//=============================================
-//	The following is for BT Efuse definition
-//=============================================
+/*  */
+/* 	The following is for BT Efuse definition */
+/*  */
 #define		EFUSE_BT_MAX_MAP_LEN		1024
 #define		EFUSE_MAX_BANK			4
 #define		EFUSE_MAX_BT_BANK		(EFUSE_MAX_BANK-1)
-//=============================================
+/*  */
 /*--------------------------Define Parameters-------------------------------*/
 #define		EFUSE_MAX_WORD_UNIT			4
 
--- a/drivers/staging/rtl8192du/include/rtw_event.h
+++ b/drivers/staging/rtl8192du/include/rtw_event.h
@@ -83,7 +83,7 @@ struct stassoc_event {
 
 struct stadel_event {
  unsigned char macaddr[6];
- unsigned char rsvd[2]; //for reason
+ unsigned char rsvd[2]; /* for reason */
  int mac_id;
 };
 
@@ -104,7 +104,7 @@ struct c2hlbk_event{
 	unsigned char	b1;
 	unsigned int	w1;
 };
-#endif//CONFIG_H2CLBK
+#endif/* CONFIG_H2CLBK */
 
 #define GEN_EVT_CODE(event)	event ## _EVT_
 
@@ -142,4 +142,4 @@ struct network_queue {
 };
 
 
-#endif // _WLANEVENT_H_
+#endif /*  _WLANEVENT_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_ht.h
+++ b/drivers/staging/rtl8192du/include/rtw_ht.h
@@ -27,23 +27,21 @@
 struct ht_priv
 {
 	u32	ht_option;
-	u32	ampdu_enable;//for enable Tx A-MPDU
-	//u8	baddbareq_issued[16];
-	u32	tx_amsdu_enable;//for enable Tx A-MSDU
-	u32	tx_amdsu_maxlen; // 1: 8k, 0:4k ; default:8k, for tx
-	u32	rx_ampdu_maxlen; //for rx reordering ctrl win_sz, updated when join_callback.
+	u32	ampdu_enable;/* for enable Tx A-MPDU */
+	u32	tx_amsdu_enable;/* for enable Tx A-MSDU */
+	u32	tx_amdsu_maxlen; /*  1: 8k, 0:4k ; default:8k, for tx */
+	u32	rx_ampdu_maxlen; /* for rx reordering ctrl win_sz, updated when join_callback. */
 
-	u8	bwmode;//
-	u8	ch_offset;//PRIME_CHNL_OFFSET
-	u8	sgi;//short GI
+	u8	bwmode;/*  */
+	u8	ch_offset;/* PRIME_CHNL_OFFSET */
+	u8	sgi;/* short GI */
 
-	//for processing Tx A-MPDU
+	/* for processing Tx A-MPDU */
 	u8	agg_enable_bitmap;
-	//u8	ADDBA_retry_count;
 	u8	candidate_tid_bitmap;
 
 	struct rtw_ieee80211_ht_cap ht_cap;
 
 };
 
-#endif	//_RTL871X_HT_H_
+#endif	/* _RTL871X_HT_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_io.h
+++ b/drivers/staging/rtl8192du/include/rtw_io.h
@@ -58,7 +58,7 @@
 #define _IO_WAIT_COMPLETE   1
 #define _IO_WAIT_RSP        2
 
-// IO COMMAND TYPE
+/*  IO COMMAND TYPE */
 #define _IOSZ_MASK_		(0x7F)
 #define _IO_WRITE_		BIT(7)
 #define _IO_FIXED_		BIT(8)
@@ -77,7 +77,7 @@
 
 
 
-// IO STATUS TYPE
+/*  IO STATUS TYPE */
 #define _IO_ERR_		BIT(2)
 #define _IO_SUCCESS_	BIT(1)
 #define _IO_DONE_		BIT(0)
@@ -110,9 +110,9 @@
 
 
 
-//below is for the intf_option bit defition...
+/* below is for the intf_option bit defition... */
 
-#define _INTF_ASYNC_	BIT(0)	//support async io
+#define _INTF_ASYNC_	BIT(0)	/* support async io */
 
 struct intf_priv;
 struct intf_hdl;
@@ -165,7 +165,7 @@ struct io_req {
 
 struct	intf_hdl {
 	struct rtw_adapter *padapter;
-	struct dvobj_priv *pintf_dev;//	pointer to &(padapter->dvobjpriv);
+	struct dvobj_priv *pintf_dev;/* 	pointer to &(padapter->dvobjpriv); */
 	struct _io_ops	io_ops;
 };
 
@@ -173,34 +173,33 @@ struct reg_protocol_rd {
 
 #ifdef CONFIG_LITTLE_ENDIAN
 
-	//DW1
+	/* DW1 */
 	u32		NumOfTrans:4;
 	u32		Reserved1:4;
 	u32		Reserved2:24;
-	//DW2
+	/* DW2 */
 	u32		ByteCount:7;
-	u32		WriteEnable:1;		//0:read, 1:write
-	u32		FixOrContinuous:1;	//0:continuous, 1: Fix
+	u32		WriteEnable:1;		/* 0:read, 1:write */
+	u32		FixOrContinuous:1;	/* 0:continuous, 1: Fix */
 	u32		BurstMode:1;
 	u32		Byte1Access:1;
 	u32		Byte2Access:1;
 	u32		Byte4Access:1;
 	u32		Reserved3:3;
 	u32		Reserved4:16;
-	//DW3
+	/* DW3 */
 	u32		BusAddress;
-	//DW4
-	//u32		Value;
+	/* DW4 */
 #else
 
 
-//DW1
+/* DW1 */
 	u32 Reserved1  :4;
 	u32 NumOfTrans :4;
 
 	u32 Reserved2  :24;
 
-	//DW2
+	/* DW2 */
 	u32 WriteEnable : 1;
 	u32 ByteCount :7;
 
@@ -215,11 +214,10 @@ struct reg_protocol_rd {
 
 	u32 Reserved4 : 16;
 
-	//DW3
+	/* DW3 */
 	u32		BusAddress;
 
-	//DW4
-	//u32		Value;
+	/* DW4 */
 
 #endif
 
@@ -231,33 +229,33 @@ struct reg_protocol_wt {
 
 #ifdef CONFIG_LITTLE_ENDIAN
 
-	//DW1
+	/* DW1 */
 	u32		NumOfTrans:4;
 	u32		Reserved1:4;
 	u32		Reserved2:24;
-	//DW2
+	/* DW2 */
 	u32		ByteCount:7;
-	u32		WriteEnable:1;		//0:read, 1:write
-	u32		FixOrContinuous:1;	//0:continuous, 1: Fix
+	u32		WriteEnable:1;		/* 0:read, 1:write */
+	u32		FixOrContinuous:1;	/* 0:continuous, 1: Fix */
 	u32		BurstMode:1;
 	u32		Byte1Access:1;
 	u32		Byte2Access:1;
 	u32		Byte4Access:1;
 	u32		Reserved3:3;
 	u32		Reserved4:16;
-	//DW3
+	/* DW3 */
 	u32		BusAddress;
-	//DW4
+	/* DW4 */
 	u32		Value;
 
 #else
-	//DW1
+	/* DW1 */
 	u32 Reserved1  :4;
 	u32 NumOfTrans :4;
 
 	u32 Reserved2  :24;
 
-	//DW2
+	/* DW2 */
 	u32 WriteEnable : 1;
 	u32 ByteCount :7;
 
@@ -271,10 +269,10 @@ struct reg_protocol_wt {
 
 	u32 Reserved4 : 16;
 
-	//DW3
+	/* DW3 */
 	u32		BusAddress;
 
-	//DW4
+	/* DW4 */
 	u32		Value;
 
 #endif
@@ -291,9 +289,9 @@ Below is the data structure used by _io_
 struct io_queue {
 	spinlock_t lock;
 	struct list_head free_ioreqs;
-	struct list_head pending;		//The io_req list that will be served in the single protocol read/write.
+	struct list_head pending;		/* The io_req list that will be served in the single protocol read/write. */
 	struct list_head processing;
-	u8	*free_ioreqs_buf; // 4-byte aligned
+	u8	*free_ioreqs_buf; /*  4-byte aligned */
 	u8	*pallocated_free_ioreqs_buf;
 	struct	intf_hdl	intf;
 };
@@ -375,7 +373,7 @@ extern int dbg_rtw_writeN(struct rtw_ada
 #define rtw_write_port(adapter, addr, cnt, mem) _rtw_write_port(adapter, addr, cnt, mem)
 #define rtw_write_port_and_wait(adapter, addr, cnt, mem, timeout_ms) _rtw_write_port_and_wait((adapter), (addr), (cnt), (mem), (timeout_ms))
 #define rtw_write_port_cancel(adapter) _rtw_write_port_cancel(adapter)
-#else //DBG_IO
+#else /* DBG_IO */
 #define rtw_read8(adapter, addr) _rtw_read8((adapter), (addr))
 #define rtw_read16(adapter, addr) _rtw_read16((adapter), (addr))
 #define rtw_read32(adapter, addr) _rtw_read32((adapter), (addr))
@@ -396,11 +394,11 @@ extern int dbg_rtw_writeN(struct rtw_ada
 #define rtw_write_port(adapter, addr, cnt, mem) _rtw_write_port((adapter), (addr), (cnt), (mem))
 #define rtw_write_port_and_wait(adapter, addr, cnt, mem, timeout_ms) _rtw_write_port_and_wait((adapter), (addr), (cnt), (mem), (timeout_ms))
 #define rtw_write_port_cancel(adapter) _rtw_write_port_cancel((adapter))
-#endif //DBG_IO
+#endif /* DBG_IO */
 
 extern void rtw_write_scsi(struct rtw_adapter *adapter, u32 cnt, u8 *pmem);
 
-//ioreq
+/* ioreq */
 extern void ioreq_read8(struct rtw_adapter *adapter, u32 addr, u8 *pval);
 extern void ioreq_read16(struct rtw_adapter *adapter, u32 addr, u16 *pval);
 extern void ioreq_read32(struct rtw_adapter *adapter, u32 addr, u32 *pval);
@@ -458,4 +456,4 @@ extern void dev_power_down(struct rtw_ad
 #define RTL_READ_BB(reg)	phy_QueryUsbBBReg(padapter, reg)
 */
 
-#endif	//_RTL8711_IO_H_
+#endif	/* _RTL8711_IO_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_ioctl.h
+++ b/drivers/staging/rtl8192du/include/rtw_ioctl.h
@@ -33,7 +33,7 @@
 #endif
 
 
-// For DDK-defined OIDs
+/*  For DDK-defined OIDs */
 #define OID_NDIS_SEG1	0x00010100
 #define OID_NDIS_SEG2	0x00010200
 #define OID_NDIS_SEG3	0x00020100
@@ -56,7 +56,7 @@
 #define SZ_OID_NDIS_SEG9		  24
 #define SZ_OID_NDIS_SEG10		  19
 
-// For Realtek-defined OIDs
+/*  For Realtek-defined OIDs */
 #define OID_MP_SEG1		0xFF871100
 #define OID_MP_SEG2		0xFF818000
 
@@ -77,12 +77,12 @@ enum oid_type
 };
 
 struct oid_funs_node {
-	unsigned int oid_start; //the starting number for OID
-	unsigned int oid_end; //the ending number for OID
+	unsigned int oid_start; /* the starting number for OID */
+	unsigned int oid_end; /* the ending number for OID */
 	struct oid_obj_priv *node_array;
-	unsigned int array_sz; //the size of node_array
-	int query_counter; //count the number of query hits for this segment
-	int set_counter; //count the number of set hits for this segment
+	unsigned int array_sz; /* the size of node_array */
+	int query_counter; /* count the number of query hits for this segment */
+	int set_counter; /* count the number of set hits for this segment */
 };
 
 struct oid_par_priv
@@ -98,7 +98,7 @@ struct oid_par_priv
 };
 
 struct oid_obj_priv {
-	unsigned char	dbg; // 0: without OID debug message  1: with OID debug message
+	unsigned char	dbg; /*  0: without OID debug message  1: with OID debug message */
 	uint (*oidfuns)(struct oid_par_priv *poid_par_priv);
 };
 
@@ -124,4 +124,4 @@ extern	uint	drv_set_info(
 		u32 *BytesNeeded
 	);
 
-#endif // #ifndef __INC_CEINFO_
+#endif /*  #ifndef __INC_CEINFO_ */
--- a/drivers/staging/rtl8192du/include/rtw_ioctl_rtl.h
+++ b/drivers/staging/rtl8192du/include/rtw_ioctl_rtl.h
@@ -24,8 +24,8 @@
 #include <osdep_service.h>
 #include <drv_types.h>
 
-//************** oid_rtl_seg_01_01 **************
-uint oid_rt_get_signal_quality_hdl(struct oid_par_priv* poid_par_priv);//84
+/*  oid_rtl_seg_01_01 ************** */
+uint oid_rt_get_signal_quality_hdl(struct oid_par_priv* poid_par_priv);/* 84 */
 uint oid_rt_get_small_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_get_middle_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_get_large_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
@@ -35,10 +35,10 @@ uint oid_rt_get_rx_total_packet_hdl(stru
 uint oid_rt_get_tx_beacon_ok_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_get_tx_beacon_err_hdl(struct oid_par_priv* poid_par_priv);
 
-uint oid_rt_pro_set_fw_dig_state_hdl(struct oid_par_priv* poid_par_priv);	//8a
-uint oid_rt_pro_set_fw_ra_state_hdl(struct oid_par_priv* poid_par_priv);	//8b
+uint oid_rt_pro_set_fw_dig_state_hdl(struct oid_par_priv* poid_par_priv);	/* 8a */
+uint oid_rt_pro_set_fw_ra_state_hdl(struct oid_par_priv* poid_par_priv);	/* 8b */
 
-uint oid_rt_get_rx_icv_err_hdl(struct oid_par_priv* poid_par_priv);//93
+uint oid_rt_get_rx_icv_err_hdl(struct oid_par_priv* poid_par_priv);/* 93 */
 uint oid_rt_set_encryption_algorithm_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_get_preamble_mode_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_get_ap_ip_hdl(struct oid_par_priv* poid_par_priv);
@@ -63,17 +63,17 @@ uint oid_rt_wireless_mode_for_scan_list_
 uint oid_rt_get_bss_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_scan_with_magic_packet_hdl(struct oid_par_priv* poid_par_priv);
 
-//**************  oid_rtl_seg_01_03 section start **************
+/*   oid_rtl_seg_01_03 section start ************** */
 uint oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_ap_switch_into_ap_mode_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_ap_supported_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_ap_set_passphrase_hdl(struct oid_par_priv* poid_par_priv);
 
-// oid_rtl_seg_01_11
+/*  oid_rtl_seg_01_11 */
 uint oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv* poid_par_priv);
 
-//**************  oid_rtl_seg_03_00 section start **************
+/*   oid_rtl_seg_03_00 section start ************** */
 uint oid_rt_get_connect_state_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_set_default_key_id_hdl(struct oid_par_priv* poid_par_priv);
 
--- a/drivers/staging/rtl8192du/include/rtw_led.h
+++ b/drivers/staging/rtl8192du/include/rtw_led.h
@@ -37,15 +37,15 @@ enum LED_CTL_MODE {
 	LED_CTL_START_TO_LINK = 8,
 	LED_CTL_START_WPS = 9,
 	LED_CTL_STOP_WPS = 10,
-	LED_CTL_START_WPS_BOTTON = 11, //added for runtop
-	LED_CTL_STOP_WPS_FAIL = 12, //added for ALPHA
-	LED_CTL_STOP_WPS_FAIL_OVERLAP = 13, //added for BELKIN
+	LED_CTL_START_WPS_BOTTON = 11, /* added for runtop */
+	LED_CTL_STOP_WPS_FAIL = 12, /* added for ALPHA */
+	LED_CTL_STOP_WPS_FAIL_OVERLAP = 13, /* added for BELKIN */
 };
 
 
-//================================================================================
-// LED object.
-//================================================================================
+/*  */
+/*  LED object. */
+/*  */
 
 enum LED_STATE_871X {
 	LED_UNKNOWN = 0,
@@ -54,13 +54,13 @@ enum LED_STATE_871X {
 	LED_BLINK_NORMAL = 3,
 	LED_BLINK_SLOWLY = 4,
 	LED_POWER_ON_BLINK = 5,
-	LED_SCAN_BLINK = 6, // LED is blinking during scanning period, the # of times to blink is depend on time for scanning.
-	LED_NO_LINK_BLINK = 7, // LED is blinking during no link state.
-	LED_BLINK_StartToBlink = 8,// Customzied for Sercomm Printer Server case
-	LED_BLINK_WPS = 9,	// LED is blinkg during WPS communication
+	LED_SCAN_BLINK = 6, /*  LED is blinking during scanning period, the # of times to blink is depend on time for scanning. */
+	LED_NO_LINK_BLINK = 7, /*  LED is blinking during no link state. */
+	LED_BLINK_StartToBlink = 8,/*  Customzied for Sercomm Printer Server case */
+	LED_BLINK_WPS = 9,	/*  LED is blinkg during WPS communication */
 	LED_TXRX_BLINK = 10,
-	LED_BLINK_WPS_STOP = 11,	//for ALPHA
-	LED_BLINK_WPS_STOP_OVERLAP = 12,	//for BELKIN
+	LED_BLINK_WPS_STOP = 11,	/* for ALPHA */
+	LED_BLINK_WPS_STOP_OVERLAP = 12,	/* for BELKIN */
 };
 
 #define IS_LED_WPS_BLINKING(_LED_871X)	(((struct LED_871X *)_LED_871X)->CurrLedState==LED_BLINK_WPS \
@@ -78,43 +78,43 @@ enum LED_PIN_871X {
 
 struct LED_871X {
 	struct rtw_adapter				*padapter;
-	enum LED_PIN_871X		LedPin;	// Identify how to implement this SW led.
-	enum LED_STATE_871X		CurrLedState; // Current LED state.
-	u8					bLedOn; // true if LED is ON, false if LED is OFF.
+	enum LED_PIN_871X		LedPin;	/*  Identify how to implement this SW led. */
+	enum LED_STATE_871X		CurrLedState; /*  Current LED state. */
+	u8					bLedOn; /*  true if LED is ON, false if LED is OFF. */
 
 	u8					bSWLedCtrl;
 
-	u8					bLedBlinkInProgress; // true if it is blinking, false o.w..
-	// ALPHA, added by chiyoko, 20090106
+	u8					bLedBlinkInProgress; /*  true if it is blinking, false o.w.. */
+	/*  ALPHA, added by chiyoko, 20090106 */
 	u8					bLedNoLinkBlinkInProgress;
 	u8					bLedLinkBlinkInProgress;
 	u8					bLedStartToLinkBlinkInProgress;
 	u8					bLedScanBlinkInProgress;
 	u8					bLedWPSBlinkInProgress;
 
-	u32					BlinkTimes; // Number of times to toggle led state for blinking.
-	enum LED_STATE_871X		BlinkingLedState; // Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are.
+	u32					BlinkTimes; /*  Number of times to toggle led state for blinking. */
+	enum LED_STATE_871X		BlinkingLedState; /*  Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are. */
 
-	struct timer_list		BlinkTimer; // Timer object for led blinking.
+	struct timer_list		BlinkTimer; /*  Timer object for led blinking. */
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
-	struct work_struct BlinkWorkItem; // Workitem used by BlinkTimer to manipulate H/W to blink LED.
+	struct work_struct BlinkWorkItem; /*  Workitem used by BlinkTimer to manipulate H/W to blink LED. */
 #endif
 };
 
 
-//================================================================================
-// LED customization.
-//================================================================================
+/*  */
+/*  LED customization. */
+/*  */
 
 enum LED_STRATEGY_871X {
-	SW_LED_MODE0, // SW control 1 LED via GPIO0. It is default option.
-	SW_LED_MODE1, // 2 LEDs, through LED0 and LED1. For ALPHA.
-	SW_LED_MODE2, // SW control 1 LED via GPIO0, customized for AzWave 8187 minicard.
-	SW_LED_MODE3, // SW control 1 LED via GPIO0, customized for Sercomm Printer Server case.
-	SW_LED_MODE4, //for Edimax / Belkin
-	SW_LED_MODE5, //for Sercomm / Belkin
-	SW_LED_MODE6, //for 88CU minicard, porting from ce SW_LED_MODE7
-	HW_LED, // HW control 2 LEDs, LED0 and LED1 (there are 4 different control modes, see MAC.CONFIG1 for details.)
+	SW_LED_MODE0, /*  SW control 1 LED via GPIO0. It is default option. */
+	SW_LED_MODE1, /*  2 LEDs, through LED0 and LED1. For ALPHA. */
+	SW_LED_MODE2, /*  SW control 1 LED via GPIO0, customized for AzWave 8187 minicard. */
+	SW_LED_MODE3, /*  SW control 1 LED via GPIO0, customized for Sercomm Printer Server case. */
+	SW_LED_MODE4, /* for Edimax / Belkin */
+	SW_LED_MODE5, /* for Sercomm / Belkin */
+	SW_LED_MODE6, /* for 88CU minicard, porting from ce SW_LED_MODE7 */
+	HW_LED, /*  HW control 2 LEDs, LED0 and LED1 (there are 4 different control modes, see MAC.CONFIG1 for details.) */
 };
 
 struct led_priv{
@@ -133,10 +133,10 @@ struct led_priv{
 		if ((adapter)->ledpriv.LedControlHandler) \
 			(adapter)->ledpriv.LedControlHandler((adapter), (LedAction)); \
 	} while (0)
-#else //CONFIG_SW_LED
+#else /* CONFIG_SW_LED */
 #define rtw_led_control(adapter, LedAction)
-#endif //CONFIG_SW_LED
+#endif /* CONFIG_SW_LED */
 
 extern void BlinkHandler(struct LED_871X *pLed);
 
-#endif //__RTW_LED_H_
+#endif /* __RTW_LED_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_mlme.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme.h
@@ -31,26 +31,24 @@
 #endif
 
 #define	MAX_BSS_CNT	128
-//#define   MAX_JOIN_TIMEOUT	2000
-//#define   MAX_JOIN_TIMEOUT	2500
 #define   MAX_JOIN_TIMEOUT	6500
 
-//	Commented by Albert 20101105
-//	Increase the scanning timeout because of increasing the SURVEY_TO value.
+/* 	Commented by Albert 20101105 */
+/* 	Increase the scanning timeout because of increasing the SURVEY_TO value. */
 
 #define		SCANNING_TIMEOUT	8000
 
-#define	SCAN_INTERVAL	(30) // unit:2sec, 30*2=60sec
+#define	SCAN_INTERVAL	(30) /*  unit:2sec, 30*2=60sec */
 
 #ifdef PALTFORM_OS_WINCE
-#define	SCANQUEUE_LIFETIME 12000000 // unit:us
+#define	SCANQUEUE_LIFETIME 12000000 /*  unit:us */
 #else
-#define	SCANQUEUE_LIFETIME 20 // unit:sec
+#define	SCANQUEUE_LIFETIME 20 /*  unit:sec */
 #endif
 
 #define		WIFI_NULL_STATE			0x00000000
 
-#define	WIFI_ASOC_STATE			0x00000001		// Under Linked state...
+#define	WIFI_ASOC_STATE			0x00000001		/*  Under Linked state... */
 #define		WIFI_REASOC_STATE		0x00000002
 #define	WIFI_SLEEP_STATE			0x00000004
 #define	WIFI_STATION_STATE		0x00000008
@@ -61,38 +59,25 @@
 #define   WIFI_UNDER_LINKING		0x00000080
 
 #define	WIFI_UNDER_WPS			0x00000100
-//#define	WIFI_UNDER_CMD			0x00000200
-//#define	WIFI_UNDER_P2P			0x00000400
 #define	WIFI_STA_ALIVE_CHK_STATE	0x00000400
-#define	WIFI_SITE_MONITOR			0x00000800		//to indicate the station is under site surveying
+#define	WIFI_SITE_MONITOR			0x00000800		/* to indicate the station is under site surveying */
 
 #ifdef WDS
 #define	WIFI_WDS					0x00001000
-#define	WIFI_WDS_RX_BEACON		0x00002000		// already rx WDS AP beacon
+#define	WIFI_WDS_RX_BEACON		0x00002000		/*  already rx WDS AP beacon */
 #endif
 #ifdef AUTO_CONFIG
 #define	WIFI_AUTOCONF				0x00004000
 #define	WIFI_AUTOCONF_IND		0x00008000
 #endif
 
-/*
-// ========== P2P Section Start ===============
-#define	WIFI_P2P_LISTEN_STATE		0x00010000
-#define	WIFI_P2P_GROUP_FORMATION_STATE		0x00020000
-// ========== P2P Section End ===============
-*/
-
-//#ifdef UNDER_MPTEST
 #define	WIFI_MP_STATE							0x00010000
-#define	WIFI_MP_CTX_BACKGROUND				0x00020000	// in continous tx background
-#define	WIFI_MP_CTX_ST						0x00040000	// in continous tx with single-tone
-#define	WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000	// pending in continous tx background due to out of skb
-#define	WIFI_MP_CTX_CCK_HW					0x00100000	// in continous tx
-#define	WIFI_MP_CTX_CCK_CS					0x00200000	// in continous tx with carrier suppression
+#define	WIFI_MP_CTX_BACKGROUND				0x00020000	/*  in continous tx background */
+#define	WIFI_MP_CTX_ST						0x00040000	/*  in continous tx with single-tone */
+#define	WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000	/*  pending in continous tx background due to out of skb */
+#define	WIFI_MP_CTX_CCK_HW					0x00100000	/*  in continous tx */
+#define	WIFI_MP_CTX_CCK_CS					0x00200000	/*  in continous tx with carrier suppression */
 #define   WIFI_MP_LPBK_STATE					0x00400000
-//#endif
-
-//#define _FW_UNDER_CMD		WIFI_UNDER_CMD
 #define _FW_UNDER_LINKING	WIFI_UNDER_LINKING
 #define _FW_LINKED			WIFI_ASOC_STATE
 #define _FW_UNDER_SURVEY	WIFI_SITE_MONITOR
@@ -106,7 +91,7 @@ enum dot11AuthAlgrthmNum {
  dot11AuthAlgrthm_MaxNum
 };
 
-// Scan type including active and passive scan.
+/*  Scan type including active and passive scan. */
 enum RT_SCAN_TYPE {
 	SCAN_PASSIVE,
 	SCAN_ACTIVE,
@@ -122,10 +107,10 @@ enum  _BAND
 
 enum SCAN_RESULT_TYPE
 {
-	SCAN_RESULT_P2P_ONLY = 0,		//	Will return all the P2P devices.
-	SCAN_RESULT_ALL = 1,			//	Will return all the scanned device, include AP.
-	SCAN_RESULT_WFD_TYPE = 2		//	Will just return the correct WFD device.
-									//	If this device is Miracast sink device, it will just return all the Miracast source devices.
+	SCAN_RESULT_P2P_ONLY = 0,		/* 	Will return all the P2P devices. */
+	SCAN_RESULT_ALL = 1,			/* 	Will return all the scanned device, include AP. */
+	SCAN_RESULT_WFD_TYPE = 2		/* 	Will just return the correct WFD device. */
+									/* 	If this device is Miracast sink device, it will just return all the Miracast source devices. */
 };
 
 /*
@@ -161,9 +146,9 @@ struct rt_link_detect {
 	bool			bBusyTraffic;
 	bool			bTxBusyTraffic;
 	bool			bRxBusyTraffic;
-	bool			bHigherBusyTraffic; // For interrupt migration purpose.
-	bool			bHigherBusyRxTraffic; // We may disable Tx interrupt according as Rx traffic.
-	bool			bHigherBusyTxTraffic; // We may disable Tx interrupt according as Tx traffic.
+	bool			bHigherBusyTraffic; /*  For interrupt migration purpose. */
+	bool			bHigherBusyRxTraffic; /*  We may disable Tx interrupt according as Rx traffic. */
+	bool			bHigherBusyTxTraffic; /*  We may disable Tx interrupt according as Tx traffic. */
 };
 
 struct profile_info {
@@ -179,69 +164,69 @@ struct tx_invite_req_info{
 	u8					ssidlen;
 	u8					go_bssid[ETH_ALEN];
 	u8					peer_macaddr[ETH_ALEN];
-	u8					operating_ch;	//	This information will be set by using the p2p_set op_ch=x
-	u8					peer_ch;		//	The listen channel for peer P2P device
+	u8					operating_ch;	/* 	This information will be set by using the p2p_set op_ch=x */
+	u8					peer_ch;		/* 	The listen channel for peer P2P device */
 
 };
 
 struct tx_invite_resp_info{
-	u8					token;	//	Used to record the dialog token of p2p invitation request frame.
+	u8					token;	/* 	Used to record the dialog token of p2p invitation request frame. */
 };
 
 #ifdef CONFIG_WFD
 
 struct wifi_display_info{
-	u16							wfd_enable;			//	Eanble/Disable the WFD function.
-	u16							rtsp_ctrlport;		//	TCP port number at which the this WFD device listens for RTSP messages
-	u16							peer_rtsp_ctrlport;	//	TCP port number at which the peer WFD device listens for RTSP messages
-													//	This filed should be filled when receiving the gropu negotiation request
-
-	u8							peer_session_avail;	//	WFD session is available or not for the peer wfd device.
-													//	This variable will be set when sending the provisioning discovery request to peer WFD device.
-													//	And this variable will be reset when it is read by using the iwpriv p2p_get wfd_sa command.
+	u16							wfd_enable;			/* 	Eanble/Disable the WFD function. */
+	u16							rtsp_ctrlport;		/* 	TCP port number at which the this WFD device listens for RTSP messages */
+	u16							peer_rtsp_ctrlport;	/* 	TCP port number at which the peer WFD device listens for RTSP messages */
+													/* 	This filed should be filled when receiving the gropu negotiation request */
+
+	u8							peer_session_avail;	/* 	WFD session is available or not for the peer wfd device. */
+													/* 	This variable will be set when sending the provisioning discovery request to peer WFD device. */
+													/* 	And this variable will be reset when it is read by using the iwpriv p2p_get wfd_sa command. */
 
 	u8							ip_address[4];
 	u8							peer_ip_address[4];
-	u8							wfd_pc;				//	WFD preferred connection
-													//	0 -> Prefer to use the P2P for WFD connection on peer side.
-													//	1 -> Prefer to use the TDLS for WFD connection on peer side.
-
-	u8							wfd_device_type;	//	WFD Device Type
-													//	0 -> WFD Source Device
-													//	1 -> WFD Primary Sink Device
-	enum	SCAN_RESULT_TYPE	scan_result_type;	//	Used when P2P is enable. This parameter will impact the scan result.
+	u8							wfd_pc;				/* 	WFD preferred connection */
+													/* 	0 -> Prefer to use the P2P for WFD connection on peer side. */
+													/* 	1 -> Prefer to use the TDLS for WFD connection on peer side. */
+
+	u8							wfd_device_type;	/* 	WFD Device Type */
+													/* 	0 -> WFD Source Device */
+													/* 	1 -> WFD Primary Sink Device */
+	enum	SCAN_RESULT_TYPE	scan_result_type;	/* 	Used when P2P is enable. This parameter will impact the scan result. */
 };
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 struct tx_provdisc_req_info{
-	u16					wps_config_method_request;	//	Used when sending the provisioning request frame
-	u16					peer_channel_num[2];		//	The channel number which the receiver stands.
+	u16					wps_config_method_request;	/* 	Used when sending the provisioning request frame */
+	u16					peer_channel_num[2];		/* 	The channel number which the receiver stands. */
 	struct ndis_802_11_ssid	ssid;
-	u8					peerDevAddr[ETH_ALEN];		//	Peer device address
-	u8					peerIFAddr[ETH_ALEN];		//	Peer interface address
-	u8					benable;					//	This provision discovery request frame is trigger to send or not
+	u8					peerDevAddr[ETH_ALEN];		/* 	Peer device address */
+	u8					peerIFAddr[ETH_ALEN];		/* 	Peer interface address */
+	u8					benable;					/* 	This provision discovery request frame is trigger to send or not */
 };
 
-struct rx_provdisc_req_info{	//When peer device issue prov_disc_req first, we should store the following informations
-	u8					peerDevAddr[ETH_ALEN];		//	Peer device address
-	u8					strconfig_method_desc_of_prov_disc_req[4];	//	description for the config method located in the provisioning discovery request frame.
-																	//	The UI must know this information to know which config method the remote p2p device is requiring.
+struct rx_provdisc_req_info{	/* When peer device issue prov_disc_req first, we should store the following informations */
+	u8					peerDevAddr[ETH_ALEN];		/* 	Peer device address */
+	u8					strconfig_method_desc_of_prov_disc_req[4];	/* 	description for the config method located in the provisioning discovery request frame. */
+																	/* 	The UI must know this information to know which config method the remote p2p device is requiring. */
 };
 
 struct tx_nego_req_info{
-	u16					peer_channel_num[2];		//	The channel number which the receiver stands.
-	u8					peerDevAddr[ETH_ALEN];		//	Peer device address
-	u8					benable;					//	This negoitation request frame is trigger to send or not
+	u16					peer_channel_num[2];		/* 	The channel number which the receiver stands. */
+	u8					peerDevAddr[ETH_ALEN];		/* 	Peer device address */
+	u8					benable;					/* 	This negoitation request frame is trigger to send or not */
 };
 
 struct group_id_info{
-	u8					go_device_addr[ETH_ALEN];	//	The GO's device address of this P2P group
-	u8					ssid[WLAN_SSID_MAXLEN];	//	The SSID of this P2P group
+	u8					go_device_addr[ETH_ALEN];	/* 	The GO's device address of this P2P group */
+	u8					ssid[WLAN_SSID_MAXLEN];	/* 	The SSID of this P2P group */
 };
 
 struct scan_limit_info{
-	u8					scan_op_ch_only;			//	When this flag is set, the driver should just scan the operation channel
-	u8					operation_ch[2];				//	Store the operation channel of invitation request frame
+	u8					scan_op_ch_only;			/* 	When this flag is set, the driver should just scan the operation channel */
+	u8					operation_ch[2];				/* 	Store the operation channel of invitation request frame */
 };
 
 #ifdef CONFIG_IOCTL_CFG80211
@@ -253,115 +238,115 @@ struct cfg80211_wifidirect_info{
 	u64				remain_on_ch_cookie;
 	bool is_ro_ch;
 };
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 struct wifidirect_info{
 	struct rtw_adapter *padapter;
 	struct timer_list			find_phase_timer;
 	struct timer_list			restore_p2p_state_timer;
 
-	//	Used to do the scanning. After confirming the peer is availalble, the driver transmits the P2P frame to peer.
+	/* 	Used to do the scanning. After confirming the peer is availalble, the driver transmits the P2P frame to peer. */
 	struct timer_list			pre_tx_scan_timer;
 	struct timer_list			reset_ch_sitesurvey;
-	struct timer_list			reset_ch_sitesurvey2;	//	Just for resetting the scan limit function by using p2p nego
+	struct timer_list			reset_ch_sitesurvey2;	/* 	Just for resetting the scan limit function by using p2p nego */
 #ifdef CONFIG_CONCURRENT_MODE
-	//	Used to switch the channel between legacy AP and listen state.
+	/* 	Used to switch the channel between legacy AP and listen state. */
 	struct timer_list			ap_p2p_switch_timer;
 #endif
 	struct tx_provdisc_req_info	tx_prov_disc_info;
 	struct rx_provdisc_req_info rx_prov_disc_info;
 	struct tx_invite_req_info	invitereq_info;
-	struct profile_info			profileinfo[P2P_MAX_PERSISTENT_GROUP_NUM];	//	Store the profile information of persistent group
+	struct profile_info			profileinfo[P2P_MAX_PERSISTENT_GROUP_NUM];	/* 	Store the profile information of persistent group */
 	struct tx_invite_resp_info	inviteresp_info;
 	struct tx_nego_req_info	nego_req_info;
-	struct group_id_info		groupid_info;	//	Store the group id information when doing the group negotiation handshake.
-	struct scan_limit_info		rx_invitereq_info;	//	Used for get the limit scan channel from the Invitation procedure
-	struct scan_limit_info		p2p_info;		//	Used for get the limit scan channel from the P2P negotiation handshake
+	struct group_id_info		groupid_info;	/* 	Store the group id information when doing the group negotiation handshake. */
+	struct scan_limit_info		rx_invitereq_info;	/* 	Used for get the limit scan channel from the Invitation procedure */
+	struct scan_limit_info		p2p_info;		/* 	Used for get the limit scan channel from the P2P negotiation handshake */
 #ifdef CONFIG_WFD
 	struct wifi_display_info		*wfd_info;
 #endif
 	enum P2P_ROLE			role;
 	enum P2P_STATE			pre_p2p_state;
 	enum P2P_STATE			p2p_state;
-	u8						device_addr[ETH_ALEN];	//	The device address should be the mac address of this device.
+	u8						device_addr[ETH_ALEN];	/* 	The device address should be the mac address of this device. */
 	u8						interface_addr[ETH_ALEN];
 	u8						social_chan[4];
 	u8						listen_channel;
 	u8						operating_channel;
-	u8						listen_dwell;		//	This value should be between 1 and 3
+	u8						listen_dwell;		/* 	This value should be between 1 and 3 */
 	u8						support_rate[8];
 	u8						p2p_wildcard_ssid[P2P_WILDCARD_SSID_LEN];
-	u8						intent;		//	should only include the intent value.
+	u8						intent;		/* 	should only include the intent value. */
 	u8						p2p_peer_interface_addr[ETH_ALEN];
 	u8						p2p_peer_device_addr[ETH_ALEN];
-	u8						peer_intent;	//	Included the intent value and tie breaker value.
-	u8						device_name[WPS_MAX_DEVICE_NAME_LEN];	//	Device name for displaying on searching device screen
+	u8						peer_intent;	/* 	Included the intent value and tie breaker value. */
+	u8						device_name[WPS_MAX_DEVICE_NAME_LEN];	/* 	Device name for displaying on searching device screen */
 	u8						device_name_len;
-	u8						profileindex;	//	Used to point to the index of profileinfo array
+	u8						profileindex;	/* 	Used to point to the index of profileinfo array */
 	u8						peer_operating_ch;
 	u8						find_phase_state_exchange_cnt;
-	u16						device_password_id_for_nego;	//	The device password ID for group negotation
+	u16						device_password_id_for_nego;	/* 	The device password ID for group negotation */
 	u8						negotiation_dialog_token;
-	u8						nego_ssid[WLAN_SSID_MAXLEN];	//	SSID information for group negotitation
+	u8						nego_ssid[WLAN_SSID_MAXLEN];	/* 	SSID information for group negotitation */
 	u8						nego_ssidlen;
 	u8						p2p_group_ssid[WLAN_SSID_MAXLEN];
 	u8						p2p_group_ssid_len;
-	u8						persistent_supported;		//	Flag to know the persistent function should be supported or not.
-														//	In the Sigma test, the Sigma will provide this enable from the sta_set_p2p CAPI.
-														//	0: disable
-														//	1: enable
-	u8						session_available;			//	Flag to set the WFD session available to enable or disable "by Sigma"
-														//	In the Sigma test, the Sigma will disable the session available by using the sta_preset CAPI.
-														//	0: disable
-														//	1: enable
-	u8						wfd_tdls_enable;			//	Flag to enable or disable the TDLS by WFD Sigma
-														//	0: disable
-														//	1: enable
-	u8						wfd_tdls_weaksec;			//	Flag to enable or disable the weak security function for TDLS by WFD Sigma
-														//	0: disable
-														//	In this case, the driver can't issue the tdsl setup request frame.
-														//	1: enable
-														//	In this case, the driver can issue the tdls setup request frame
-														//	even the current security is weak security.
-
-	enum	P2P_WPSINFO		ui_got_wps_info;			//	This field will store the WPS value (PIN value or PBC) that UI had got from the user.
-	u16						supported_wps_cm;			//	This field describes the WPS config method which this driver supported.
-														//	The value should be the combination of config method defined in page104 of WPS v2.0 spec.
-	uint						channel_list_attr_len;		//	This field will contain the length of body of P2P Channel List attribute of group negotitation response frame.
-	u8						channel_list_attr[100];		//	This field will contain the body of P2P Channel List attribute of group negotitation response frame.
-														//	We will use the channel_cnt and channel_list fields when constructing the group negotitation confirm frame.
+	u8						persistent_supported;		/* 	Flag to know the persistent function should be supported or not. */
+														/* 	In the Sigma test, the Sigma will provide this enable from the sta_set_p2p CAPI. */
+														/* 	0: disable */
+														/* 	1: enable */
+	u8						session_available;			/* 	Flag to set the WFD session available to enable or disable "by Sigma" */
+														/* 	In the Sigma test, the Sigma will disable the session available by using the sta_preset CAPI. */
+														/* 	0: disable */
+														/* 	1: enable */
+	u8						wfd_tdls_enable;			/* 	Flag to enable or disable the TDLS by WFD Sigma */
+														/* 	0: disable */
+														/* 	1: enable */
+	u8						wfd_tdls_weaksec;			/* 	Flag to enable or disable the weak security function for TDLS by WFD Sigma */
+														/* 	0: disable */
+														/* 	In this case, the driver can't issue the tdsl setup request frame. */
+														/* 	1: enable */
+														/* 	In this case, the driver can issue the tdls setup request frame */
+														/* 	even the current security is weak security. */
+
+	enum	P2P_WPSINFO		ui_got_wps_info;			/* 	This field will store the WPS value (PIN value or PBC) that UI had got from the user. */
+	u16						supported_wps_cm;			/* 	This field describes the WPS config method which this driver supported. */
+														/* 	The value should be the combination of config method defined in page104 of WPS v2.0 spec. */
+	uint						channel_list_attr_len;		/* 	This field will contain the length of body of P2P Channel List attribute of group negotitation response frame. */
+	u8						channel_list_attr[100];		/* 	This field will contain the body of P2P Channel List attribute of group negotitation response frame. */
+														/* 	We will use the channel_cnt and channel_list fields when constructing the group negotitation confirm frame. */
 #ifdef CONFIG_CONCURRENT_MODE
-	u16						ext_listen_interval;	//	The interval to be available with legacy AP (ms)
-	u16						ext_listen_period;	//	The time period to be available for P2P listen state (ms)
+	u16						ext_listen_interval;	/* 	The interval to be available with legacy AP (ms) */
+	u16						ext_listen_period;	/* 	The time period to be available for P2P listen state (ms) */
 #endif
 #ifdef CONFIG_P2P_PS
-	enum P2P_PS_MODE		p2p_ps_mode; // indicate p2p ps mode
-	enum P2P_PS_STATE		p2p_ps_state; // indicate p2p ps state
-	u8						noa_index; // Identifies and instance of Notice of Absence timing.
-	u8						ctwindow; // Client traffic window. A period of time in TU after TBTT.
-	u8						opp_ps; // opportunistic power save.
-	u8						noa_num; // number of NoA descriptor in P2P IE.
-	u8						noa_count[P2P_MAX_NOA_NUM]; // Count for owner, Type of client.
-	u32						noa_duration[P2P_MAX_NOA_NUM]; // Max duration for owner, preferred or min acceptable duration for client.
-	u32						noa_interval[P2P_MAX_NOA_NUM]; // Length of interval for owner, preferred or max acceptable interval of client.
-	u32						noa_start_time[P2P_MAX_NOA_NUM]; // schedule expressed in terms of the lower 4 bytes of the TSF timer.
-#endif // CONFIG_P2P_PS
+	enum P2P_PS_MODE		p2p_ps_mode; /*  indicate p2p ps mode */
+	enum P2P_PS_STATE		p2p_ps_state; /*  indicate p2p ps state */
+	u8						noa_index; /*  Identifies and instance of Notice of Absence timing. */
+	u8						ctwindow; /*  Client traffic window. A period of time in TU after TBTT. */
+	u8						opp_ps; /*  opportunistic power save. */
+	u8						noa_num; /*  number of NoA descriptor in P2P IE. */
+	u8						noa_count[P2P_MAX_NOA_NUM]; /*  Count for owner, Type of client. */
+	u32						noa_duration[P2P_MAX_NOA_NUM]; /*  Max duration for owner, preferred or min acceptable duration for client. */
+	u32						noa_interval[P2P_MAX_NOA_NUM]; /*  Length of interval for owner, preferred or max acceptable interval of client. */
+	u32						noa_start_time[P2P_MAX_NOA_NUM]; /*  schedule expressed in terms of the lower 4 bytes of the TSF timer. */
+#endif /*  CONFIG_P2P_PS */
 };
 
-struct tdls_ss_record{	//signal strength record; recording the tdls sta with lowerest ss
+struct tdls_ss_record{	/* signal strength record; recording the tdls sta with lowerest ss */
 	u8		macaddr[ETH_ALEN];
 	u8		RxPWDBAll;
-	u8		is_tdls_sta;	// true: direct link sta, false: else
+	u8		is_tdls_sta;	/*  true: direct link sta, false: else */
 };
 
 struct tdls_info{
 	u8					ap_prohibited;
 	uint					setup_state;
 	u8					sta_cnt;
-	u8					sta_maximum;	// 1:tdls sta is equal (NUM_STA-1), reach max direct link number; 0: else;
+	u8					sta_maximum;	/*  1:tdls sta is equal (NUM_STA-1), reach max direct link number; 0: else; */
 	struct tdls_ss_record	ss_record;
-	u8					macid_index;	//macid entry that is ready to write
-	u8					clear_cam;	//cam entry that is trying to clear, using it in direct link teardown
+	u8					macid_index;	/* macid entry that is ready to write */
+	u8					clear_cam;	/* cam entry that is trying to clear, using it in direct link teardown */
 	u8					ch_sensing;
 	u8					cur_channel;
 	u8					candidate_ch;
@@ -369,7 +354,7 @@ struct tdls_info{
 	spinlock_t				cmd_lock;
 	spinlock_t				hdl_lock;
 	u8					watchdog_count;
-	u8					dev_discovered;		//WFD_TDLS: for sigma test
+	u8					dev_discovered;		/* WFD_TDLS: for sigma test */
 	u8					enable;
 #ifdef CONFIG_WFD
 	struct wifi_display_info		*wfd_info;
@@ -379,11 +364,11 @@ struct tdls_info{
 struct mlme_priv {
 
 	spinlock_t	lock;
-	int	fw_state;	//shall we protect this variable? maybe not necessarily...
+	int	fw_state;	/* shall we protect this variable? maybe not necessarily... */
 
-	u8	to_join; //flag
+	u8	to_join; /* flag */
 	#ifdef CONFIG_LAYER2_ROAMING
-	u8 to_roaming; // roaming trying times
+	u8 to_roaming; /*  roaming trying times */
 	#endif
 
 	u8	*nic_hdl;
@@ -400,7 +385,7 @@ struct mlme_priv {
 
 	struct wlan_network	cur_network;
 
-	//uint wireless_mode; no used, remove it
+	/* uint wireless_mode; no used, remove it */
 
 	u32	scan_interval;
 
@@ -409,12 +394,12 @@ struct mlme_priv {
 	uint assoc_by_bssid;
 	uint assoc_by_rssi;
 
-	struct timer_list scan_to_timer; // driver itself handles scan_timeout status.
-	u32 scan_start_time; // used to evaluate the time spent in scanning
+	struct timer_list scan_to_timer; /*  driver itself handles scan_timeout status. */
+	u32 scan_start_time; /*  used to evaluate the time spent in scanning */
 
 	#ifdef CONFIG_SET_SCAN_DENY_TIMER
 	struct timer_list set_scan_deny_timer;
-	ATOMIC_T set_scan_deny; //0: allowed, 1: deny
+	ATOMIC_T set_scan_deny; /* 0: allowed, 1: deny */
 	#endif
 
 	struct qos_priv qospriv;
@@ -425,7 +410,7 @@ struct mlme_priv {
 	int num_sta_no_ht;
 
 	/* Number of HT AP/stations 20 MHz */
-	//int num_sta_ht_20mhz;
+	/* int num_sta_ht_20mhz; */
 
 
 	int num_FortyMHzIntolerant;
@@ -435,15 +420,13 @@ struct mlme_priv {
 #endif
 
 	struct rt_link_detect LinkDetectInfo;
-	struct timer_list dynamic_chk_timer; //dynamic/periodic check timer
+	struct timer_list dynamic_chk_timer; /* dynamic/periodic check timer */
 
-	u8	key_mask; //use for ips to set wep key after ips_leave
-	u8	acm_mask; // for wmm acm mask
+	u8	key_mask; /* use for ips to set wep key after ips_leave */
+	u8	acm_mask; /*  for wmm acm mask */
 	u8	ChannelPlan;
-	enum RT_SCAN_TYPE	scan_mode; // active: 1, passive: 0
+	enum RT_SCAN_TYPE	scan_mode; /*  active: 1, passive: 0 */
 
-	//u8 probereq_wpsie[MAX_WPS_IE_LEN];//added in probe req
-	//int probereq_wpsie_len;
 	u8 *wps_probe_req_ie;
 	u32 wps_probe_req_ie_len;
 
@@ -464,7 +447,7 @@ struct mlme_priv {
 	int num_sta_ht_no_gf;
 
 	/* Number of associated non-HT stations */
-	//int num_sta_no_ht;
+	/* int num_sta_no_ht; */
 
 	/* Number of HT associated stations 20 MHz */
 	int num_sta_ht_20mhz;
@@ -482,57 +465,42 @@ struct mlme_priv {
 	u32 assoc_rsp_len;
 
 	u8 *wps_beacon_ie;
-	//u8 *wps_probe_req_ie;
 	u8 *wps_probe_resp_ie;
-	u8 *wps_assoc_resp_ie; // for CONFIG_IOCTL_CFG80211, this IE could include p2p ie / wfd ie
+	u8 *wps_assoc_resp_ie; /*  for CONFIG_IOCTL_CFG80211, this IE could include p2p ie / wfd ie */
 
 	u32 wps_beacon_ie_len;
-	//u32 wps_probe_req_ie_len;
 	u32 wps_probe_resp_ie_len;
-	u32 wps_assoc_resp_ie_len; // for CONFIG_IOCTL_CFG80211, this IE len could include p2p ie / wfd ie
+	u32 wps_assoc_resp_ie_len; /*  for CONFIG_IOCTL_CFG80211, this IE len could include p2p ie / wfd ie */
 
 	u8 *p2p_beacon_ie;
 	u8 *p2p_probe_req_ie;
 	u8 *p2p_probe_resp_ie;
-	u8 *p2p_go_probe_resp_ie; //for GO
+	u8 *p2p_go_probe_resp_ie; /* for GO */
 	u8 *p2p_assoc_req_ie;
 
 	u32 p2p_beacon_ie_len;
 	u32 p2p_probe_req_ie_len;
 	u32 p2p_probe_resp_ie_len;
-	u32 p2p_go_probe_resp_ie_len; //for GO
+	u32 p2p_go_probe_resp_ie_len; /* for GO */
 	u32 p2p_assoc_req_ie_len;
-/*
-#if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
-	//u8 *wps_p2p_beacon_ie;
-	u8 *p2p_beacon_ie;
-	u8 *wps_p2p_probe_resp_ie;
-	u8 *wps_p2p_assoc_resp_ie;
-	//u32 wps_p2p_beacon_ie_len;
-	u32 p2p_beacon_ie_len;
-	u32 wps_p2p_probe_resp_ie_len;
-	u32 wps_p2p_assoc_resp_ie_len;
-#endif
-*/
-
 	spinlock_t	bcn_update_lock;
 	u8		update_bcn;
 
 
-#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+#endif /* if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME) */
 
 #if defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211)
 
 	u8 *wfd_beacon_ie;
 	u8 *wfd_probe_req_ie;
 	u8 *wfd_probe_resp_ie;
-	u8 *wfd_go_probe_resp_ie; //for GO
+	u8 *wfd_go_probe_resp_ie; /* for GO */
 	u8 *wfd_assoc_req_ie;
 
 	u32 wfd_beacon_ie_len;
 	u32 wfd_probe_req_ie_len;
 	u32 wfd_probe_resp_ie_len;
-	u32 wfd_go_probe_resp_ie_len; //for GO
+	u32 wfd_go_probe_resp_ie_len; /* for GO */
 	u32 wfd_assoc_req_ie_len;
 
 #endif
@@ -541,12 +509,12 @@ struct mlme_priv {
 	int	widi_state;
 	int	listen_state;
 	struct timer_list listen_timer;
-	ATOMIC_T	rx_probe_rsp; // 1:receive probe respone from RDS source.
+	ATOMIC_T	rx_probe_rsp; /*  1:receive probe respone from RDS source. */
 	u8	*l2sdTaBuffer;
 	u8	channel_idx;
-	s8	group_cnt;	//For WiDi 3.5, they specified another scan algo. for WFD/RDS co-existed
+	s8	group_cnt;	/* For WiDi 3.5, they specified another scan algo. for WFD/RDS co-existed */
 	u8	sa_ext[L2SDTA_SERVICE_VE_LEN];
-#endif // CONFIG_INTEL_WIDI
+#endif /*  CONFIG_INTEL_WIDI */
 
 #ifdef CONFIG_CONCURRENT_MODE
 	u8	scanning_via_buddy_intf;
@@ -584,15 +552,15 @@ extern int event_thread(void *context);
 extern void rtw_join_timeout_handler(void* FunctionContext);
 extern void _rtw_scan_timeout_handler(void* FunctionContext);
 extern void rtw_free_network_queue(struct rtw_adapter *adapter,u8 isfreeall);
-extern int rtw_init_mlme_priv(struct rtw_adapter *adapter);// (struct mlme_priv *pmlmepriv);
+extern int rtw_init_mlme_priv(struct rtw_adapter *adapter);/*  (struct mlme_priv *pmlmepriv); */
 extern void rtw_free_mlme_priv (struct mlme_priv *pmlmepriv);
 extern int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv);
 extern int rtw_set_key(struct rtw_adapter *adapter,struct security_priv *psecuritypriv,int keyid, u8 set_tx);
 extern int rtw_set_auth(struct rtw_adapter *adapter,struct security_priv *psecuritypriv);
 
 __inline static u8 *get_bssid(struct mlme_priv *pmlmepriv)
-{	//if sta_mode:pmlmepriv->cur_network.network.MacAddress=> bssid
-	// if adhoc_mode:pmlmepriv->cur_network.network.MacAddress=> ibss mac address
+{	/* if sta_mode:pmlmepriv->cur_network.network.MacAddress=> bssid */
+	/*  if adhoc_mode:pmlmepriv->cur_network.network.MacAddress=> ibss mac address */
 	return pmlmepriv->cur_network.network.MacAddress;
 }
 
@@ -655,7 +623,7 @@ __inline static void up_scanned_network(
 #ifdef CONFIG_CONCURRENT_MODE
 int rtw_buddy_adapter_up(struct rtw_adapter *padapter);
 int check_buddy_fwstate(struct rtw_adapter *padapter, int state);
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 __inline static void down_scanned_network(struct mlme_priv *pmlmepriv)
 {
@@ -761,4 +729,4 @@ u8 rtw_to_roaming(struct rtw_adapter *ad
 #define rtw_to_roaming(adapter) 0
 #endif
 
-#endif //__RTL871X_MLME_H_
+#endif /* __RTL871X_MLME_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme_ext.h
@@ -26,38 +26,27 @@
 #include <wlan_bssdef.h>
 
 
-//	Commented by Albert 20101105
-//	Increase the SURVEY_TO value from 100 to 150  (100ms to 150ms)
-//	The Realtek 8188CE SoftAP will spend around 100ms to send the probe response after receiving the probe request.
-//	So, this driver tried to extend the dwell time for each scanning channel.
-//	This will increase the chance to receive the probe response from SoftAP.
+/* 	Commented by Albert 20101105 */
+/* 	Increase the SURVEY_TO value from 100 to 150  (100ms to 150ms) */
+/* 	The Realtek 8188CE SoftAP will spend around 100ms to send the probe response after receiving the probe request. */
+/* 	So, this driver tried to extend the dwell time for each scanning channel. */
+/* 	This will increase the chance to receive the probe response from SoftAP. */
 
 #define SURVEY_TO		(100)
-#define REAUTH_TO		(300) //(50)
-#define REASSOC_TO		(300) //(50)
-//#define DISCONNECT_TO	(3000)
+#define REAUTH_TO		(300) /* 50) */
+#define REASSOC_TO		(300) /* 50) */
 #define ADDBA_TO			(2000)
 
-#define LINKED_TO (1) //unit:2 sec, 1x2=2 sec
+#define LINKED_TO (1) /* unit:2 sec, 1x2=2 sec */
 
 #define REAUTH_LIMIT	(4)
 #define REASSOC_LIMIT	(4)
 #define READDBA_LIMIT	(2)
 
-//#define	IOCMD_REG0		0x10250370
-//#define	IOCMD_REG1		0x10250374
-//#define	IOCMD_REG2		0x10250378
-
-//#define	FW_DYNAMIC_FUN_SWITCH	0x10250364
-
-//#define	WRITE_BB_CMD		0xF0000001
-//#define	SET_CHANNEL_CMD	0xF3000000
-//#define	UPDATE_RA_CMD	0xFD0000A2
-
 #define	DYNAMIC_FUNC_DISABLE		(0x0)
 #define	DYNAMIC_FUNC_DIG			BIT(0)
 #define	DYNAMIC_FUNC_HP			BIT(1)
-#define	DYNAMIC_FUNC_SS			BIT(2) //Tx Power Tracking
+#define	DYNAMIC_FUNC_SS			BIT(2) /* Tx Power Tracking */
 #define DYNAMIC_FUNC_BT			BIT(3)
 #define DYNAMIC_FUNC_ANT_DIV		BIT(4)
 
@@ -91,16 +80,16 @@ extern unsigned char WMM_INFO_OUI[];
 extern unsigned char WMM_PARA_OUI[];
 
 
-//
-// Channel Plan Type.
-// Note:
-//	We just add new channel plan when the new channel plan is different from any of the following
-//	channel plan.
-//	If you just wnat to customize the acitions(scan period or join actions) about one of the channel plan,
-//	customize them in struct rt_channel_info in the RT_CHANNEL_LIST.
-//
+/*  */
+/*  Channel Plan Type. */
+/*  Note: */
+/* 	We just add new channel plan when the new channel plan is different from any of the following */
+/* 	channel plan. */
+/* 	If you just wnat to customize the acitions(scan period or join actions) about one of the channel plan, */
+/* 	customize them in struct rt_channel_info in the RT_CHANNEL_LIST. */
+/*  */
 enum RT_CHANNEL_DOMAIN {
-	//===== old channel plan mapping =====//
+	/*  old channel plan mapping ===== */
 	RT_CHANNEL_DOMAIN_FCC = 0x00,
 	RT_CHANNEL_DOMAIN_IC = 0x01,
 	RT_CHANNEL_DOMAIN_ETSI = 0x02,
@@ -123,7 +112,7 @@ enum RT_CHANNEL_DOMAIN {
 	RT_CHANNEL_DOMAIN_WORLD_WIDE_5G = 0x13,
 	RT_CHANNEL_DOMAIN_TAIWAN_NO_DFS = 0x14,
 
-	//===== new channel plan mapping, (2GDOMAIN_5GDOMAIN) =====//
+	/*  new channel plan mapping, (2GDOMAIN_5GDOMAIN) ===== */
 	RT_CHANNEL_DOMAIN_WORLD_NULL = 0x20,
 	RT_CHANNEL_DOMAIN_ETSI1_NULL = 0x21,
 	RT_CHANNEL_DOMAIN_FCC1_NULL = 0x22,
@@ -146,42 +135,42 @@ enum RT_CHANNEL_DOMAIN {
 	RT_CHANNEL_DOMAIN_FCC1_NCC1 = 0x39,
 	RT_CHANNEL_DOMAIN_FCC1_NCC2 = 0x40,
 
-	//===== Add new channel plan above this line===============//
+	/*  Add new channel plan above this line=============== */
 	RT_CHANNEL_DOMAIN_MAX,
 	RT_CHANNEL_DOMAIN_REALTEK_DEFINE = 0x7F,
 };
 
 enum RT_CHANNEL_DOMAIN_2G {
-	RT_CHANNEL_DOMAIN_2G_WORLD = 0x00,		//Worldwird 13
-	RT_CHANNEL_DOMAIN_2G_ETSI1 = 0x01,		//Europe
-	RT_CHANNEL_DOMAIN_2G_FCC1 = 0x02,		//US
-	RT_CHANNEL_DOMAIN_2G_MKK1 = 0x03,		//Japan
-	RT_CHANNEL_DOMAIN_2G_ETSI2 = 0x04,		//France
+	RT_CHANNEL_DOMAIN_2G_WORLD = 0x00,		/* Worldwird 13 */
+	RT_CHANNEL_DOMAIN_2G_ETSI1 = 0x01,		/* Europe */
+	RT_CHANNEL_DOMAIN_2G_FCC1 = 0x02,		/* US */
+	RT_CHANNEL_DOMAIN_2G_MKK1 = 0x03,		/* Japan */
+	RT_CHANNEL_DOMAIN_2G_ETSI2 = 0x04,		/* France */
 	RT_CHANNEL_DOMAIN_2G_NULL = 0x05,
-	//===== Add new channel plan above this line===============//
+	/*  Add new channel plan above this line=============== */
 	RT_CHANNEL_DOMAIN_2G_MAX,
 };
 
 enum RT_CHANNEL_DOMAIN_5G {
 	RT_CHANNEL_DOMAIN_5G_NULL = 0x00,
-	RT_CHANNEL_DOMAIN_5G_ETSI1 = 0x01,		//Europe
-	RT_CHANNEL_DOMAIN_5G_ETSI2 = 0x02,		//Australia, New Zealand
-	RT_CHANNEL_DOMAIN_5G_ETSI3 = 0x03,		//Russia
-	RT_CHANNEL_DOMAIN_5G_FCC1 = 0x04,		//US
-	RT_CHANNEL_DOMAIN_5G_FCC2 = 0x05,		//FCC o/w DFS Channels
-	RT_CHANNEL_DOMAIN_5G_FCC3 = 0x06,		//India, Mexico
-	RT_CHANNEL_DOMAIN_5G_FCC4 = 0x07,		//Venezuela
-	RT_CHANNEL_DOMAIN_5G_FCC5 = 0x08,		//China
-	RT_CHANNEL_DOMAIN_5G_FCC6 = 0x09,		//Israel
-	RT_CHANNEL_DOMAIN_5G_FCC7_IC1 = 0x0A,	//US, Canada
-	RT_CHANNEL_DOMAIN_5G_KCC1 = 0x0B,		//Korea
-	RT_CHANNEL_DOMAIN_5G_MKK1 = 0x0C,		//Japan
-	RT_CHANNEL_DOMAIN_5G_MKK2 = 0x0D,		//Japan (W52, W53)
-	RT_CHANNEL_DOMAIN_5G_MKK3 = 0x0E,		//Japan (W56)
-	RT_CHANNEL_DOMAIN_5G_NCC1 = 0x0F,		//Taiwan
-	RT_CHANNEL_DOMAIN_5G_NCC2 = 0x10,		//Taiwan o/w DFS
-	//===== Add new channel plan above this line===============//
-	//===== Driver Self Defined =====//
+	RT_CHANNEL_DOMAIN_5G_ETSI1 = 0x01,		/* Europe */
+	RT_CHANNEL_DOMAIN_5G_ETSI2 = 0x02,		/* Australia, New Zealand */
+	RT_CHANNEL_DOMAIN_5G_ETSI3 = 0x03,		/* Russia */
+	RT_CHANNEL_DOMAIN_5G_FCC1 = 0x04,		/* US */
+	RT_CHANNEL_DOMAIN_5G_FCC2 = 0x05,		/* FCC o/w DFS Channels */
+	RT_CHANNEL_DOMAIN_5G_FCC3 = 0x06,		/* India, Mexico */
+	RT_CHANNEL_DOMAIN_5G_FCC4 = 0x07,		/* Venezuela */
+	RT_CHANNEL_DOMAIN_5G_FCC5 = 0x08,		/* China */
+	RT_CHANNEL_DOMAIN_5G_FCC6 = 0x09,		/* Israel */
+	RT_CHANNEL_DOMAIN_5G_FCC7_IC1 = 0x0A,	/* US, Canada */
+	RT_CHANNEL_DOMAIN_5G_KCC1 = 0x0B,		/* Korea */
+	RT_CHANNEL_DOMAIN_5G_MKK1 = 0x0C,		/* Japan */
+	RT_CHANNEL_DOMAIN_5G_MKK2 = 0x0D,		/* Japan (W52, W53) */
+	RT_CHANNEL_DOMAIN_5G_MKK3 = 0x0E,		/* Japan (W56) */
+	RT_CHANNEL_DOMAIN_5G_NCC1 = 0x0F,		/* Taiwan */
+	RT_CHANNEL_DOMAIN_5G_NCC2 = 0x10,		/* Taiwan o/w DFS */
+	/*  Add new channel plan above this line=============== */
+	/*  Driver Self Defined ===== */
 	RT_CHANNEL_DOMAIN_5G_FCC = 0x11,
 	RT_CHANNEL_DOMAIN_5G_JAPAN_NO_DFS = 0x12,
 	RT_CHANNEL_DOMAIN_5G_FCC4_NO_DFS = 0x13,
@@ -257,10 +246,10 @@ struct	ss_res
 	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
 };
 
-//#define AP_MODE				0x0C
-//#define STATION_MODE	0x08
-//#define AD_HOC_MODE		0x04
-//#define NO_LINK_MODE	0x00
+/* define AP_MODE				0x0C */
+/* define STATION_MODE	0x08 */
+/* define AD_HOC_MODE		0x04 */
+/* define NO_LINK_MODE	0x00 */
 
 #define		WIFI_FW_NULL_STATE			_HW_STATE_NOLINK_
 #define	WIFI_FW_STATION_STATE		_HW_STATE_STATION_
@@ -277,19 +266,19 @@ struct	ss_res
 #define	WIFI_FW_LINKING_STATE		(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE | WIFI_FW_AUTH_SUCCESS |WIFI_FW_ASSOC_STATE)
 
 #ifdef CONFIG_TDLS
-// 1: Write RCR DATA BIT
-// 2: Issue peer traffic indication
-// 3: Go back to the channel linked with AP, terminating channel switch procedure
-// 4: Init channel sensing, receive all data and mgnt frame
-// 5: Channel sensing and report candidate channel
-// 6: First time set channel to off channel
-// 7: Go back tp the channel linked with AP when set base channel as target channel
-// 8: Set channel back to base channel
-// 9: Set channel back to off channel
-// 10: Restore RCR DATA BIT
-// 11: Check alive
-// 12: Check alive
-// 13: Free TDLS sta
+/*  1: Write RCR DATA BIT */
+/*  2: Issue peer traffic indication */
+/*  3: Go back to the channel linked with AP, terminating channel switch procedure */
+/*  4: Init channel sensing, receive all data and mgnt frame */
+/*  5: Channel sensing and report candidate channel */
+/*  6: First time set channel to off channel */
+/*  7: Go back tp the channel linked with AP when set base channel as target channel */
+/*  8: Set channel back to base channel */
+/*  9: Set channel back to off channel */
+/*  10: Restore RCR DATA BIT */
+/*  11: Check alive */
+/*  12: Check alive */
+/*  13: Free TDLS sta */
 enum TDLS_option
 {
 	TDLS_WRCR			=	1,
@@ -308,7 +297,7 @@ enum TDLS_option
 	maxTDLS,
 };
 
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 struct FW_Sta_Info
 {
@@ -339,9 +328,9 @@ struct FW_Sta_Info
  */
 #if defined CONFIG_STA_MODE_SCAN_UNDER_AP_MODE && defined CONFIG_CONCURRENT_MODE
 #define RTW_SCAN_NUM_OF_CH			8
-#define RTW_STAY_AP_CH_MILLISECOND	3	// this value is a multiplier,for example, when this value is 3, it would stay AP's op ch for
-											// 3 * SURVEY_TO millisecond.
-#endif //defined CONFIG_STA_MODE_SCAN_UNDER_AP_MODE && defined CONFIG_CONCURRENT_MODE
+#define RTW_STAY_AP_CH_MILLISECOND	3	/*  this value is a multiplier,for example, when this value is 3, it would stay AP's op ch for */
+											/*  3 * SURVEY_TO millisecond. */
+#endif /* defined CONFIG_STA_MODE_SCAN_UNDER_AP_MODE && defined CONFIG_CONCURRENT_MODE */
 
 struct mlme_ext_info
 {
@@ -350,10 +339,10 @@ struct mlme_ext_info
 	u32	reassoc_count;
 	u32	link_count;
 	u32	auth_seq;
-	u32	auth_algo;	// 802.11 auth, could be open, shared, auto
+	u32	auth_algo;	/*  802.11 auth, could be open, shared, auto */
 	u32	authModeToggle;
-	u32	enc_algo;//encrypt algorithm;
-	u32	key_index;	// this is only valid for legendary wep, 0~3 for key id.
+	u32	enc_algo;/* encrypt algorithm; */
+	u32	key_index;	/*  this is only valid for legendary wep, 0~3 for key id. */
 	u32	iv;
 	u8	chg_txt[128];
 	u16	aid;
@@ -376,7 +365,7 @@ struct mlme_ext_info
 	u8	ADDBA_retry_count;
 	u8	candidate_tid_bitmap;
 	u8	dialogToken;
-	// Accept ADDBA Request
+	/*  Accept ADDBA Request */
 	bool bAcceptAddbaReq;
 	u8	bwmode_updated;
 	u8	hidden_ssid_mode;
@@ -385,21 +374,18 @@ struct mlme_ext_info
 	struct WMM_para_element	WMM_param;
 	struct HT_caps_element	HT_caps;
 	struct HT_info_element		HT_info;
-	struct wlan_bssid_ex network;//join network or bss_network, if in ap mode, it is the same to cur_network.network
+	struct wlan_bssid_ex network;/* join network or bss_network, if in ap mode, it is the same to cur_network.network */
 	struct FW_Sta_Info		FW_sta_info[NUM_STA];
 
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 	u8 scan_cnt;
-#endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
 };
 
-// The channel information about this channel including joining, scanning, and power constraints.
+/*  The channel information about this channel including joining, scanning, and power constraints. */
 struct rt_channel_info {
-	u8				ChannelNum;		// The channel number.
-	enum RT_SCAN_TYPE	ScanType;		// Scan type such as passive or active scan.
-	//u16				ScanPeriod;		// Listen time in millisecond in this channel.
-	//s32				MaxTxPwrDbm;	// Max allowed tx power.
-	//u32				ExInfo;			// Extended Information for this channel.
+	u8				ChannelNum;		/*  The channel number. */
+	enum RT_SCAN_TYPE	ScanType;		/*  Scan type such as passive or active scan. */
 #ifdef CONFIG_FIND_BEST_CHANNEL
 	u32				rx_count;
 #endif
@@ -407,27 +393,27 @@ struct rt_channel_info {
 
 int rtw_ch_set_search_ch(struct rt_channel_info *ch_set, const u32 ch);
 
-// P2P_MAX_REG_CLASSES - Maximum number of regulatory classes
+/*  P2P_MAX_REG_CLASSES - Maximum number of regulatory classes */
 #define P2P_MAX_REG_CLASSES 10
 
-// P2P_MAX_REG_CLASS_CHANNELS - Maximum number of channels per regulatory class
+/*  P2P_MAX_REG_CLASS_CHANNELS - Maximum number of channels per regulatory class */
 #define P2P_MAX_REG_CLASS_CHANNELS 20
 
-//  struct p2p_channels - List of supported channels
+/*   struct p2p_channels - List of supported channels */
 struct p2p_channels {
-	// struct p2p_reg_class - Supported regulatory class
+	/*  struct p2p_reg_class - Supported regulatory class */
 	struct p2p_reg_class {
-		// reg_class - Regulatory class (IEEE 802.11-2007, Annex J)
+		/*  reg_class - Regulatory class (IEEE 802.11-2007, Annex J) */
 		u8 reg_class;
 
-		// channel - Supported channels
+		/*  channel - Supported channels */
 		u8 channel[P2P_MAX_REG_CLASS_CHANNELS];
 
-		// channels - Number of channel entries in use
+		/*  channels - Number of channel entries in use */
 		size_t channels;
 	} reg_class[P2P_MAX_REG_CLASSES];
 
-	// reg_classes - Number of reg_class entries in use
+	/*  reg_classes - Number of reg_class entries in use */
 	size_t reg_classes;
 };
 
@@ -447,11 +433,9 @@ struct mlme_ext_priv
 	ATOMIC_T		event_seq;
 	u16	mgnt_seq;
 
-	//struct fw_priv	fwpriv;
-
 	unsigned char	cur_channel;
 	unsigned char	cur_bwmode;
-	unsigned char	cur_ch_offset;//PRIME_CHNL_OFFSET
+	unsigned char	cur_ch_offset;/* PRIME_CHNL_OFFSET */
 	unsigned char	cur_wireless_mode;
 
 	unsigned char	max_chan_nums;
@@ -461,16 +445,16 @@ struct mlme_ext_priv
 	unsigned char	datarate[NUMRATES];
 
 	struct ss_res		sitesurvey_res;
-	struct mlme_ext_info	mlmext_info;//for sta/adhoc mode, including current scanning/connecting/connected related info.
-                                                     //for ap mode, network includes ap's cap_info
+	struct mlme_ext_info	mlmext_info;/* for sta/adhoc mode, including current scanning/connecting/connected related info. */
+                                                     /* for ap mode, network includes ap's cap_info */
 	struct timer_list survey_timer;
 	struct timer_list link_timer;
 	u16			chan_scan_time;
 
 	u8	scan_abort;
-	u8	tx_rate; // TXRATE when USERATE is set.
+	u8	tx_rate; /*  TXRATE when USERATE is set. */
 
-	u32	retry; //retry for issue probereq
+	u32	retry; /* retry for issue probereq */
 
 	u64 TSFValue;
 
@@ -478,7 +462,7 @@ struct mlme_ext_priv
 	unsigned char bstart_bss;
 #endif
 
-	//recv_decache check for Action_public frame
+	/* recv_decache check for Action_public frame */
         u8 action_public_dialog_token;
 	u16	 action_public_rxseq;
 
@@ -566,7 +550,7 @@ void VCS_update(struct rtw_adapter *pada
 void update_beacon_info(struct rtw_adapter *padapter, u8 *pframe, uint len, struct sta_info *psta);
 #ifdef CONFIG_DFS
 void process_csa_ie(struct rtw_adapter *padapter, u8 *pframe, uint len);
-#endif //CONFIG_DFS
+#endif /* CONFIG_DFS */
 void update_IOT_info(struct rtw_adapter *padapter);
 void update_capinfo(struct rtw_adapter *Adapter, u16 updateCap);
 void update_wireless_mode(struct rtw_adapter *padapter);
@@ -574,7 +558,7 @@ void update_tx_basic_rate(struct rtw_ada
 void update_bmc_sta_support_rate(struct rtw_adapter *padapter, u32 mac_id);
 int update_sta_support_rate(struct rtw_adapter *padapter, u8* pvar_ie, uint var_ie_len, int cam_idx);
 
-//for sta/adhoc mode
+/* for sta/adhoc mode */
 void update_sta_info(struct rtw_adapter *padapter, struct sta_info *psta);
 unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz);
 unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz);
@@ -612,7 +596,7 @@ void issue_probereq_p2p(struct rtw_adapt
 int issue_probereq_p2p_ex(struct rtw_adapter *adapter, u8 *da, int try_cnt, int wait_ms);
 void issue_p2p_invitation_response(struct rtw_adapter *padapter, u8* raddr, u8 dialogToken, u8 success);
 void issue_p2p_invitation_request(struct rtw_adapter *padapter, u8* raddr);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 void issue_beacon(struct rtw_adapter *padapter);
 void issue_probersp(struct rtw_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probereq);
 void issue_assocreq(struct rtw_adapter *padapter);
@@ -692,7 +676,7 @@ extern void correct_TSF(struct rtw_adapt
 int check_buddy_mlmeinfo_state(struct rtw_adapter *padapter, u32 state);
 int concurrent_chk_start_clnt_join(struct rtw_adapter *padapter);
 void concurrent_chk_joinbss_done(struct rtw_adapter *padapter, int join_res);
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 void	dc_SelectChannel(struct rtw_adapter *padapter, unsigned char channel);
@@ -742,7 +726,7 @@ u8 tx_beacon_hdl(struct rtw_adapter *pad
 u8 set_ch_hdl(struct rtw_adapter *padapter, u8 *pbuf);
 u8 set_chplan_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);
 u8 led_blink_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);
-u8 set_csa_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);	//Kurt: Handling DFS channel switch announcement ie.
+u8 set_csa_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);	/* Kurt: Handling DFS channel switch announcement ie. */
 u8 tdls_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);
 
 
@@ -876,8 +860,8 @@ enum rtw_c2h_event
 	GEN_EVT_CODE(_C2HFEEDBACK),            /*20*/
 	GEN_EVT_CODE(_ADDBA),
 	GEN_EVT_CODE(_C2HBCN),
-	GEN_EVT_CODE(_REPORTPWRSTATE),		//filen: only for PCIE, USB
-	GEN_EVT_CODE(_CLOSERF),			//filen: only for PCIE, work around ASPM
+	GEN_EVT_CODE(_REPORTPWRSTATE),		/* filen: only for PCIE, USB */
+	GEN_EVT_CODE(_CLOSERF),			/* filen: only for PCIE, work around ASPM */
 	MAX_C2HEVT
 };
 
@@ -913,6 +897,6 @@ static struct fwevent wlanevents[] =
 	{0, &rtw_cpwm_event_callback},
 };
 
-#endif//_RTL8192C_CMD_C_
+#endif/* _RTL8192C_CMD_C_ */
 
 #endif
--- a/drivers/staging/rtl8192du/include/rtw_mp.h
+++ b/drivers/staging/rtl8192du/include/rtw_mp.h
@@ -20,8 +20,8 @@
 #ifndef _RTW_MP_H_
 #define _RTW_MP_H_
 
-//	00 - Success
-//	11 - Error
+/* 	00 - Success */
+/* 	11 - Error */
 #define STATUS_SUCCESS				(0x00000000L)
 #define STATUS_PENDING				(0x00000103L)
 
@@ -73,12 +73,12 @@
 #define uint_SAP_IN_USE			((uint)0xC0010021L)
 #define uint_INVALID_ADDRESS		((uint)0xC0010022L)
 #define uint_VC_NOT_ACTIVATED		((uint)0xC0010023L)
-#define uint_DEST_OUT_OF_ORDER		((uint)0xC0010024L)  // cause 27
-#define uint_VC_NOT_AVAILABLE		((uint)0xC0010025L)  // cause 35,45
-#define uint_CELLRATE_NOT_AVAILABLE	((uint)0xC0010026L)  // cause 37
-#define uint_INCOMPATABLE_QOS		((uint)0xC0010027L)  // cause 49
-#define uint_AAL_PARAMS_UNSUPPORTED	((uint)0xC0010028L)  // cause 93
-#define uint_NO_ROUTE_TO_DESTINATION	((uint)0xC0010029L)  // cause 3
+#define uint_DEST_OUT_OF_ORDER		((uint)0xC0010024L)  /*  cause 27 */
+#define uint_VC_NOT_AVAILABLE		((uint)0xC0010025L)  /*  cause 35,45 */
+#define uint_CELLRATE_NOT_AVAILABLE	((uint)0xC0010026L)  /*  cause 37 */
+#define uint_INCOMPATABLE_QOS		((uint)0xC0010027L)  /*  cause 49 */
+#define uint_AAL_PARAMS_UNSUPPORTED	((uint)0xC0010028L)  /*  cause 93 */
+#define uint_NO_ROUTE_TO_DESTINATION	((uint)0xC0010029L)  /*  cause 3 */
 
 #define MAX_MP_XMITBUF_SZ	2048
 #define NR_MP_XMITFRAME		8
@@ -89,8 +89,7 @@ struct mp_xmit_frame {
 	struct sk_buff *pkt;
 	int frame_tag;
 	struct rtw_adapter *padapter;
-	//insert urb, irp, and irpcnt info below...
-	//max frag_cnt = 8
+	/* insert urb, irp, and irpcnt info below... */
 	u8 *mem_addr;
 	u32 sz[8];
 	struct urb *pxmit_urb[8];
@@ -130,70 +129,66 @@ struct mp_tx {
 #define s4Byte s32
 
 struct mpt_context {
-	// Indicate if we have started Mass Production Test.
+	/*  Indicate if we have started Mass Production Test. */
 	bool			bMassProdTest;
 
-	// Indicate if the driver is unloading or unloaded.
+	/*  Indicate if the driver is unloading or unloaded. */
 	bool			bMptDrvUnload;
 
-	// Indicate a MptWorkItem is scheduled and not yet finished.
+	/*  Indicate a MptWorkItem is scheduled and not yet finished. */
 	bool			bMptWorkItemInProgress;
 
-	// 1=Start, 0=Stop from UI.
+	/*  1=Start, 0=Stop from UI. */
 	u32			MptTestStart;
-	// _TEST_MODE, defined in MPT_Req2.h
+	/*  _TEST_MODE, defined in MPT_Req2.h */
 	u32			MptTestItem;
-	// Variable needed in each implementation of CurrMptAct.
-	u32			MptActType;	// Type of action performed in CurrMptAct.
-	// The Offset of IO operation is depend of MptActType.
+	/*  Variable needed in each implementation of CurrMptAct. */
+	u32			MptActType;	/*  Type of action performed in CurrMptAct. */
+	/*  The Offset of IO operation is depend of MptActType. */
 	u32			MptIoOffset;
-	// The Value of IO operation is depend of MptActType.
+	/*  The Value of IO operation is depend of MptActType. */
 	u32			MptIoValue;
-	// The RfPath of IO operation is depend of MptActType.
+	/*  The RfPath of IO operation is depend of MptActType. */
 	u32			MptRfPath;
 
-	enum WIRELESS_MODE	MptWirelessModeToSw;	// Wireless mode to switch.
-	u8			MptChannelToSw;		// Channel to switch.
-	u8			MptInitGainToSet;	// Initial gain to set.
-	//u32			bMptAntennaA;		// TRUE if we want to use antenna A.
-	u32			MptBandWidth;		// bandwidth to switch.
-	u32			MptRateIndex;		// rate index.
-	// Register value kept for Single Carrier Tx test.
+	enum WIRELESS_MODE	MptWirelessModeToSw;	/*  Wireless mode to switch. */
+	u8			MptChannelToSw;		/*  Channel to switch. */
+	u8			MptInitGainToSet;	/*  Initial gain to set. */
+	u32			MptBandWidth;		/*  bandwidth to switch. */
+	u32			MptRateIndex;		/*  rate index. */
+	/*  Register value kept for Single Carrier Tx test. */
 	u8			btMpCckTxPower;
-	// Register value kept for Single Carrier Tx test.
+	/*  Register value kept for Single Carrier Tx test. */
 	u8			btMpOfdmTxPower;
-	// For MP Tx Power index
-	u8			TxPwrLevel[2];	// rf-A, rf-B
+	/*  For MP Tx Power index */
+	u8			TxPwrLevel[2];	/*  rf-A, rf-B */
 
-	// Content of RCR Regsiter for Mass Production Test.
+	/*  Content of RCR Regsiter for Mass Production Test. */
 	u32			MptRCR;
-	// TRUE if we only receive packets with specific pattern.
+	/*  TRUE if we only receive packets with specific pattern. */
 	bool			bMptFilterPattern;
-	// Rx OK count, statistics used in Mass Production Test.
+	/*  Rx OK count, statistics used in Mass Production Test. */
 	u32			MptRxOkCnt;
-	// Rx CRC32 error count, statistics used in Mass Production Test.
+	/*  Rx CRC32 error count, statistics used in Mass Production Test. */
 	u32			MptRxCrcErrCnt;
 
-	bool			bCckContTx;	// TRUE if we are in CCK Continuous Tx test.
-	bool			bOfdmContTx;	// TRUE if we are in OFDM Continuous Tx test.
-	bool			bStartContTx;	// TRUE if we have start Continuous Tx test.
-	// TRUE if we are in Single Carrier Tx test.
+	bool			bCckContTx;	/*  TRUE if we are in CCK Continuous Tx test. */
+	bool			bOfdmContTx;	/*  TRUE if we are in OFDM Continuous Tx test. */
+	bool			bStartContTx;	/*  TRUE if we have start Continuous Tx test. */
+	/*  TRUE if we are in Single Carrier Tx test. */
 	bool			bSingleCarrier;
-	// TRUE if we are in Carrier Suppression Tx Test.
+	/*  TRUE if we are in Carrier Suppression Tx Test. */
 	bool			bCarrierSuppression;
-	//TRUE if we are in Single Tone Tx test.
+	/* TRUE if we are in Single Tone Tx test. */
 	bool			bSingleTone;
 
-	// ACK counter asked by K.Y..
+	/*  ACK counter asked by K.Y.. */
 	bool			bMptEnableAckCounter;
 	u32			MptAckCounter;
 
-	// SD3 Willis For 8192S to save 1T/2T RF table for ACUT	Only fro ACUT delete later ~~~!
-	//s1Byte		BufOfLines[2][MAX_LINES_HWCONFIG_TXT][MAX_BYTES_LINE_HWCONFIG_TXT];
-	//s1Byte			BufOfLines[2][MP_MAX_LINES][MP_MAX_LINES_BYTES];
-	//s4Byte			RfReadLine[2];
+	/*  SD3 Willis For 8192S to save 1T/2T RF table for ACUT	Only fro ACUT delete later ~~~! */
 
-	u8		APK_bound[2];	//for APK	path A/path B
+	u8		APK_bound[2];	/* for APK	path A/path B */
 	bool		bMptIndexEven;
 
 	u8		backup0xc50;
@@ -207,7 +202,6 @@ struct mpt_context {
 
 /* end of E-Fuse */
 
-//#define RTPRIV_IOCTL_MP					(SIOCIWFIRSTPRIV + 0x17)
 enum {
 	WRITE_REG = 1,
 	READ_REG,
@@ -240,28 +234,27 @@ struct mp_priv
 {
 	struct rtw_adapter *papdater;
 
-	//Testing Flag
-	u32 mode;//0 for normal type packet, 1 for loopback packet (16bytes TXCMD)
+	/* Testing Flag */
+	u32 mode;/* 0 for normal type packet, 1 for loopback packet (16bytes TXCMD) */
 
 	u32 prev_fw_state;
 
-	//OID cmd handler
+	/* OID cmd handler */
 	struct mp_wiparam workparam;
-//	u8 act_in_progress;
 
-	//Tx Section
+	/* Tx Section */
 	u8 TID;
 	u32 tx_pktcount;
 	struct mp_tx tx;
 
-	//Rx Section
+	/* Rx Section */
 	u32 rx_pktcount;
 	u32 rx_crcerrpktcount;
 	u32 rx_pktloss;
 
 	struct recv_stat rxstat;
 
-	//RF/BB relative
+	/* RF/BB relative */
 	u8 channel;
 	u8 bandwidth;
 	u8 prime_channel_offset;
@@ -269,17 +262,13 @@ struct mp_priv
 	u8 txpoweridx_b;
 	u8 rateidx;
 	u32 preamble;
-//	u8 modem;
 	u32 CrystalCap;
-//	u32 curr_crystalcap;
 
 	u16 antenna_tx;
 	u16 antenna_rx;
-//	u8 curr_rfpath;
 
 	u8 check_mp_pkt;
 
-//	uint ForcedDataRate;
 
 	struct wlan_network mp_network;
 	unsigned char network_macaddr[6];
@@ -302,7 +291,7 @@ struct bb_reg_param {
 	u32 offset;
 	u32 value;
 };
-//=======================================================================
+/*  */
 
 #define LOWER	true
 #define RAISE	false
@@ -370,7 +359,7 @@ enum MPT_RATE_E {
 	MPT_RATE_LAST
 };
 
-#define MAX_TX_PWR_INDEX_N_MODE 64	// 0x3F
+#define MAX_TX_PWR_INDEX_N_MODE 64	/*  0x3F */
 
 enum POWER_MODE {
 	POWER_LOW = 0,
@@ -383,10 +372,10 @@ enum POWER_MODE {
 #define RX_PKT_PHY_MATCH	3
 
 enum ENCRY_CTRL_STATE {
-	HW_CONTROL,		//hw encryption& decryption
-	SW_CONTROL,		//sw encryption& decryption
-	HW_ENCRY_SW_DECRY,	//hw encryption & sw decryption
-	SW_ENCRY_HW_DECRY	//sw encryption & hw decryption
+	HW_CONTROL,		/* hw encryption& decryption */
+	SW_CONTROL,		/* sw encryption& decryption */
+	HW_ENCRY_SW_DECRY,	/* hw encryption & sw decryption */
+	SW_ENCRY_HW_DECRY	/* sw encryption & hw decryption */
 };
 
 enum OFDM_TX_MODE {
@@ -396,9 +385,7 @@ enum OFDM_TX_MODE {
 	OFDM_SingleTone		= 4,
 };
 
-//=======================================================================
-//extern struct mp_xmit_frame *alloc_mp_xmitframe(struct mp_priv *pmp_priv);
-//extern int free_mp_xmitframe(struct xmit_priv *pxmitpriv, struct mp_xmit_frame *pmp_xmitframe);
+/*  */
 
 extern s32 init_mp_priv(struct rtw_adapter * padapter);
 extern void free_mp_priv(struct mp_priv *pmp_priv);
@@ -407,18 +394,9 @@ extern void MPT_DeInitAdapter(struct rtw
 extern s32 mp_start_test(struct rtw_adapter * padapter);
 extern void mp_stop_test(struct rtw_adapter * padapter);
 
-//=======================================================================
-//extern void	IQCalibrateBcut(struct rtw_adapter * pAdapter);
+/*  */
+
 
-//extern u32	bb_reg_read(struct rtw_adapter * Adapter, u16 offset);
-//extern u8	bb_reg_write(struct rtw_adapter * Adapter, u16 offset, u32 value);
-//extern u32	rf_reg_read(struct rtw_adapter * Adapter, u8 path, u8 offset);
-//extern u8	rf_reg_write(struct rtw_adapter * Adapter, u8 path, u8 offset, u32 value);
-
-//extern u32	get_bb_reg(struct rtw_adapter * Adapter, u16 offset, u32 bitmask);
-//extern u8	set_bb_reg(struct rtw_adapter * Adapter, u16 offset, u32 bitmask, u32 value);
-//extern u32	get_rf_reg(struct rtw_adapter * Adapter, u8 path, u8 offset, u32 bitmask);
-//extern u8	set_rf_reg(struct rtw_adapter * Adapter, u8 path, u8 offset, u32 bitmask, u32 value);
 
 extern u32 _read_rfreg(struct rtw_adapter * padapter, u8 rfpath, u32 addr, u32 bitmask);
 extern void _write_rfreg(struct rtw_adapter * padapter, u8 rfpath, u32 addr, u32 bitmask, u32 val);
@@ -434,12 +412,10 @@ extern void	SetChannel(struct rtw_adapte
 extern void	SetBandwidth(struct rtw_adapter * pAdapter);
 extern void	SetTxPower(struct rtw_adapter * pAdapter);
 extern void	SetAntennaPathPower(struct rtw_adapter * pAdapter);
-//extern void	SetTxAGCOffset(struct rtw_adapter * pAdapter, u32 ulTxAGCOffset);
 extern void	SetDataRate(struct rtw_adapter * pAdapter);
 
 extern void	SetAntenna(struct rtw_adapter * pAdapter);
 
-//extern void	SetCrystalCap(struct rtw_adapter * pAdapter);
 
 extern s32	SetThermalMeter(struct rtw_adapter * pAdapter, u8 target_ther);
 extern void	GetThermalMeter(struct rtw_adapter * pAdapter, u8 *value);
@@ -491,4 +467,4 @@ extern void Hal_SetCCKContinuousTx(struc
 extern void Hal_SetOFDMContinuousTx(struct rtw_adapter * pAdapter, u8 bStart);
 extern void Hal_ProSetCrystalCap (struct rtw_adapter * pAdapter, u32 CrystalCapVal);
 
-#endif //_RTW_MP_H_
+#endif /* _RTW_MP_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_mp_ioctl.h
+++ b/drivers/staging/rtl8192du/include/rtw_mp_ioctl.h
@@ -27,7 +27,7 @@
 #include <rtw_efuse.h>
 #include <rtw_mp.h>
 
-//------------------------------------------------------------------------------
+/*  */
 struct mp_rw_reg {
 	u32 offset;
 	u32 width;
@@ -36,14 +36,14 @@ struct mp_rw_reg {
 
 #define _irqlevel_changed_(a,b)
 
-//oid_rtl_seg_81_80_00
+/* oid_rtl_seg_81_80_00 */
 uint oid_rt_pro_set_data_rate_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_start_test_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_stop_test_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_set_channel_direct_call_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_set_antenna_bb_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_set_tx_power_control_hdl(struct oid_par_priv* poid_par_priv);
-//oid_rtl_seg_81_80_20
+/* oid_rtl_seg_81_80_20 */
 uint oid_rt_pro_query_tx_packet_sent_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_query_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_query_rx_packet_crc32_error_hdl(struct oid_par_priv* poid_par_priv);
@@ -58,7 +58,7 @@ uint oid_rt_pro_set_carrier_suppression_
 uint oid_rt_pro_set_single_tone_tx_hdl(struct oid_par_priv* poid_par_priv);
 
 
-//oid_rtl_seg_81_87
+/* oid_rtl_seg_81_87 */
 uint oid_rt_pro_write_bb_reg_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_read_bb_reg_hdl(struct oid_par_priv* poid_par_priv);
 
@@ -66,11 +66,11 @@ uint oid_rt_pro_write_rf_reg_hdl(struct
 uint oid_rt_pro_read_rf_reg_hdl(struct oid_par_priv* poid_par_priv);
 
 
-//oid_rtl_seg_81_85
+/* oid_rtl_seg_81_85 */
 uint oid_rt_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
 
 
-// oid_rtl_seg_87_11_00
+/*  oid_rtl_seg_87_11_00 */
 uint oid_rt_pro8711_join_bss_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_read_register_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_write_register_hdl(struct oid_par_priv* poid_par_priv);
@@ -85,21 +85,21 @@ uint oid_rt_rd_attrib_mem_hdl(struct oid
 uint oid_rt_wr_attrib_mem_hdl (struct oid_par_priv* poid_par_priv);
 uint  oid_rt_pro_set_rf_intfs_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_poll_rx_status_hdl(struct oid_par_priv* poid_par_priv);
-// oid_rtl_seg_87_11_20
+/*  oid_rtl_seg_87_11_20 */
 uint oid_rt_pro_cfg_debug_message_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_set_data_rate_ex_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_set_basic_rate_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_read_tssi_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_set_power_tracking_hdl(struct oid_par_priv* poid_par_priv);
-//oid_rtl_seg_87_11_50
+/* oid_rtl_seg_87_11_50 */
 uint oid_rt_pro_qry_pwrstate_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_set_pwrstate_hdl(struct oid_par_priv* poid_par_priv);
-//oid_rtl_seg_87_11_F0
+/* oid_rtl_seg_87_11_F0 */
 uint oid_rt_pro_h2c_set_rate_table_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_h2c_get_rate_table_hdl(struct oid_par_priv* poid_par_priv);
 
 
-//oid_rtl_seg_87_12_00
+/* oid_rtl_seg_87_12_00 */
 uint oid_rt_pro_encryption_ctrl_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_add_sta_info_hdl(struct oid_par_priv* poid_par_priv);
 uint oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv* poid_par_priv);
@@ -137,201 +137,201 @@ uint oid_rt_pro_trigger_gpio_hdl(struct
 
 const struct oid_obj_priv oid_rtl_seg_81_80_00[] =
 {
-	{1, &oid_null_function},			//0x00	OID_RT_PRO_RESET_DUT
-	{1, &oid_rt_pro_set_data_rate_hdl},		//0x01
-	{1, &oid_rt_pro_start_test_hdl},		//0x02
-	{1, &oid_rt_pro_stop_test_hdl},			//0x03
-	{1, &oid_null_function},			//0x04	OID_RT_PRO_SET_PREAMBLE
-	{1, &oid_null_function},			//0x05	OID_RT_PRO_SET_SCRAMBLER
-	{1, &oid_null_function},			//0x06	OID_RT_PRO_SET_FILTER_BB
-	{1, &oid_null_function},			//0x07	OID_RT_PRO_SET_MANUAL_DIVERSITY_BB
-	{1, &oid_rt_pro_set_channel_direct_call_hdl},	//0x08
-	{1, &oid_null_function},			//0x09	OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL
-	{1, &oid_null_function},			//0x0A	OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL
-	{1, &oid_rt_pro_set_continuous_tx_hdl},		//0x0B	OID_RT_PRO_SET_TX_CONTINUOUS_DIRECT_CALL
-	{1, &oid_rt_pro_set_single_carrier_tx_hdl},	//0x0C	OID_RT_PRO_SET_SINGLE_CARRIER_TX_CONTINUOUS
-	{1, &oid_null_function},			//0x0D	OID_RT_PRO_SET_TX_ANTENNA_BB
-	{1, &oid_rt_pro_set_antenna_bb_hdl},		//0x0E
-	{1, &oid_null_function},			//0x0F	OID_RT_PRO_SET_CR_SCRAMBLER
-	{1, &oid_null_function},			//0x10	OID_RT_PRO_SET_CR_NEW_FILTER
-	{1, &oid_rt_pro_set_tx_power_control_hdl},	//0x11	OID_RT_PRO_SET_TX_POWER_CONTROL
-	{1, &oid_null_function},			//0x12	OID_RT_PRO_SET_CR_TX_CONFIG
-	{1, &oid_null_function},			//0x13	OID_RT_PRO_GET_TX_POWER_CONTROL
-	{1, &oid_null_function},			//0x14	OID_RT_PRO_GET_CR_SIGNAL_QUALITY
-	{1, &oid_null_function},			//0x15	OID_RT_PRO_SET_CR_SETPOINT
-	{1, &oid_null_function},			//0x16	OID_RT_PRO_SET_INTEGRATOR
-	{1, &oid_null_function},			//0x17	OID_RT_PRO_SET_SIGNAL_QUALITY
-	{1, &oid_null_function},			//0x18	OID_RT_PRO_GET_INTEGRATOR
-	{1, &oid_null_function},			//0x19	OID_RT_PRO_GET_SIGNAL_QUALITY
-	{1, &oid_null_function},			//0x1A	OID_RT_PRO_QUERY_EEPROM_TYPE
-	{1, &oid_null_function},			//0x1B	OID_RT_PRO_WRITE_MAC_ADDRESS
-	{1, &oid_null_function},			//0x1C	OID_RT_PRO_READ_MAC_ADDRESS
-	{1, &oid_null_function},			//0x1D	OID_RT_PRO_WRITE_CIS_DATA
-	{1, &oid_null_function},			//0x1E	OID_RT_PRO_READ_CIS_DATA
-	{1, &oid_null_function}				//0x1F	OID_RT_PRO_WRITE_POWER_CONTROL
+	{1, &oid_null_function},			/* 0x00	OID_RT_PRO_RESET_DUT */
+	{1, &oid_rt_pro_set_data_rate_hdl},		/* 0x01 */
+	{1, &oid_rt_pro_start_test_hdl},		/* 0x02 */
+	{1, &oid_rt_pro_stop_test_hdl},			/* 0x03 */
+	{1, &oid_null_function},			/* 0x04	OID_RT_PRO_SET_PREAMBLE */
+	{1, &oid_null_function},			/* 0x05	OID_RT_PRO_SET_SCRAMBLER */
+	{1, &oid_null_function},			/* 0x06	OID_RT_PRO_SET_FILTER_BB */
+	{1, &oid_null_function},			/* 0x07	OID_RT_PRO_SET_MANUAL_DIVERSITY_BB */
+	{1, &oid_rt_pro_set_channel_direct_call_hdl},	/* 0x08 */
+	{1, &oid_null_function},			/* 0x09	OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL */
+	{1, &oid_null_function},			/* 0x0A	OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL */
+	{1, &oid_rt_pro_set_continuous_tx_hdl},		/* 0x0B	OID_RT_PRO_SET_TX_CONTINUOUS_DIRECT_CALL */
+	{1, &oid_rt_pro_set_single_carrier_tx_hdl},	/* 0x0C	OID_RT_PRO_SET_SINGLE_CARRIER_TX_CONTINUOUS */
+	{1, &oid_null_function},			/* 0x0D	OID_RT_PRO_SET_TX_ANTENNA_BB */
+	{1, &oid_rt_pro_set_antenna_bb_hdl},		/* 0x0E */
+	{1, &oid_null_function},			/* 0x0F	OID_RT_PRO_SET_CR_SCRAMBLER */
+	{1, &oid_null_function},			/* 0x10	OID_RT_PRO_SET_CR_NEW_FILTER */
+	{1, &oid_rt_pro_set_tx_power_control_hdl},	/* 0x11	OID_RT_PRO_SET_TX_POWER_CONTROL */
+	{1, &oid_null_function},			/* 0x12	OID_RT_PRO_SET_CR_TX_CONFIG */
+	{1, &oid_null_function},			/* 0x13	OID_RT_PRO_GET_TX_POWER_CONTROL */
+	{1, &oid_null_function},			/* 0x14	OID_RT_PRO_GET_CR_SIGNAL_QUALITY */
+	{1, &oid_null_function},			/* 0x15	OID_RT_PRO_SET_CR_SETPOINT */
+	{1, &oid_null_function},			/* 0x16	OID_RT_PRO_SET_INTEGRATOR */
+	{1, &oid_null_function},			/* 0x17	OID_RT_PRO_SET_SIGNAL_QUALITY */
+	{1, &oid_null_function},			/* 0x18	OID_RT_PRO_GET_INTEGRATOR */
+	{1, &oid_null_function},			/* 0x19	OID_RT_PRO_GET_SIGNAL_QUALITY */
+	{1, &oid_null_function},			/* 0x1A	OID_RT_PRO_QUERY_EEPROM_TYPE */
+	{1, &oid_null_function},			/* 0x1B	OID_RT_PRO_WRITE_MAC_ADDRESS */
+	{1, &oid_null_function},			/* 0x1C	OID_RT_PRO_READ_MAC_ADDRESS */
+	{1, &oid_null_function},			/* 0x1D	OID_RT_PRO_WRITE_CIS_DATA */
+	{1, &oid_null_function},			/* 0x1E	OID_RT_PRO_READ_CIS_DATA */
+	{1, &oid_null_function}				/* 0x1F	OID_RT_PRO_WRITE_POWER_CONTROL */
 
 };
 
 const struct oid_obj_priv oid_rtl_seg_81_80_20[] =
 {
-	{1, &oid_null_function},			//0x20	OID_RT_PRO_READ_POWER_CONTROL
-	{1, &oid_null_function},			//0x21	OID_RT_PRO_WRITE_EEPROM
-	{1, &oid_null_function},			//0x22	OID_RT_PRO_READ_EEPROM
-	{1, &oid_rt_pro_reset_tx_packet_sent_hdl},	//0x23
-	{1, &oid_rt_pro_query_tx_packet_sent_hdl},	//0x24
-	{1, &oid_rt_pro_reset_rx_packet_received_hdl},	//0x25
-	{1, &oid_rt_pro_query_rx_packet_received_hdl},	//0x26
-	{1, &oid_rt_pro_query_rx_packet_crc32_error_hdl},	//0x27
-	{1, &oid_null_function},			//0x28	OID_RT_PRO_QUERY_CURRENT_ADDRESS
-	{1, &oid_null_function},			//0x29	OID_RT_PRO_QUERY_PERMANENT_ADDRESS
-	{1, &oid_null_function},			//0x2A	OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS
-	{1, &oid_rt_pro_set_carrier_suppression_tx_hdl},//0x2B	OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX
-	{1, &oid_null_function},			//0x2C	OID_RT_PRO_RECEIVE_PACKET
-	{1, &oid_null_function},			//0x2D	OID_RT_PRO_WRITE_EEPROM_BYTE
-	{1, &oid_null_function},			//0x2E	OID_RT_PRO_READ_EEPROM_BYTE
-	{1, &oid_rt_pro_set_modulation_hdl}		//0x2F
+	{1, &oid_null_function},			/* 0x20	OID_RT_PRO_READ_POWER_CONTROL */
+	{1, &oid_null_function},			/* 0x21	OID_RT_PRO_WRITE_EEPROM */
+	{1, &oid_null_function},			/* 0x22	OID_RT_PRO_READ_EEPROM */
+	{1, &oid_rt_pro_reset_tx_packet_sent_hdl},	/* 0x23 */
+	{1, &oid_rt_pro_query_tx_packet_sent_hdl},	/* 0x24 */
+	{1, &oid_rt_pro_reset_rx_packet_received_hdl},	/* 0x25 */
+	{1, &oid_rt_pro_query_rx_packet_received_hdl},	/* 0x26 */
+	{1, &oid_rt_pro_query_rx_packet_crc32_error_hdl},	/* 0x27 */
+	{1, &oid_null_function},			/* 0x28	OID_RT_PRO_QUERY_CURRENT_ADDRESS */
+	{1, &oid_null_function},			/* 0x29	OID_RT_PRO_QUERY_PERMANENT_ADDRESS */
+	{1, &oid_null_function},			/* 0x2A	OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS */
+	{1, &oid_rt_pro_set_carrier_suppression_tx_hdl},/* 0x2B	OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX */
+	{1, &oid_null_function},			/* 0x2C	OID_RT_PRO_RECEIVE_PACKET */
+	{1, &oid_null_function},			/* 0x2D	OID_RT_PRO_WRITE_EEPROM_BYTE */
+	{1, &oid_null_function},			/* 0x2E	OID_RT_PRO_READ_EEPROM_BYTE */
+	{1, &oid_rt_pro_set_modulation_hdl}		/* 0x2F */
 
 };
 
 const struct oid_obj_priv oid_rtl_seg_81_80_40[] =
 {
-	{1, &oid_null_function},			//0x40
-	{1, &oid_null_function},			//0x41
-	{1, &oid_null_function},			//0x42
-	{1, &oid_rt_pro_set_single_tone_tx_hdl},	//0x43
-	{1, &oid_null_function},			//0x44
-	{1, &oid_null_function}				//0x45
+	{1, &oid_null_function},			/* 0x40 */
+	{1, &oid_null_function},			/* 0x41 */
+	{1, &oid_null_function},			/* 0x42 */
+	{1, &oid_rt_pro_set_single_tone_tx_hdl},	/* 0x43 */
+	{1, &oid_null_function},			/* 0x44 */
+	{1, &oid_null_function}				/* 0x45 */
 };
 
 const struct oid_obj_priv oid_rtl_seg_81_80_80[] =
 {
-	{1, &oid_null_function},			//0x80	OID_RT_DRIVER_OPTION
-	{1, &oid_null_function},			//0x81	OID_RT_RF_OFF
-	{1, &oid_null_function}				//0x82	OID_RT_AUTH_STATUS
+	{1, &oid_null_function},			/* 0x80	OID_RT_DRIVER_OPTION */
+	{1, &oid_null_function},			/* 0x81	OID_RT_RF_OFF */
+	{1, &oid_null_function}				/* 0x82	OID_RT_AUTH_STATUS */
 
 };
 
 const struct oid_obj_priv oid_rtl_seg_81_85[] =
 {
-	{1, &oid_rt_wireless_mode_hdl}			//0x00	OID_RT_WIRELESS_MODE
+	{1, &oid_rt_wireless_mode_hdl}			/* 0x00	OID_RT_WIRELESS_MODE */
 };
 
 struct oid_obj_priv oid_rtl_seg_81_87[] =
 {
-	{1, &oid_null_function},			//0x80	OID_RT_PRO8187_WI_POLL
-	{1, &oid_rt_pro_write_bb_reg_hdl},		//0x81
-	{1, &oid_rt_pro_read_bb_reg_hdl},		//0x82
-	{1, &oid_rt_pro_write_rf_reg_hdl},		//0x82
-	{1, &oid_rt_pro_read_rf_reg_hdl}		//0x83
+	{1, &oid_null_function},			/* 0x80	OID_RT_PRO8187_WI_POLL */
+	{1, &oid_rt_pro_write_bb_reg_hdl},		/* 0x81 */
+	{1, &oid_rt_pro_read_bb_reg_hdl},		/* 0x82 */
+	{1, &oid_rt_pro_write_rf_reg_hdl},		/* 0x82 */
+	{1, &oid_rt_pro_read_rf_reg_hdl}		/* 0x83 */
 };
 
 struct oid_obj_priv oid_rtl_seg_87_11_00[] =
 {
-	{1, &oid_rt_pro8711_join_bss_hdl},		//0x00  //S
-	{1, &oid_rt_pro_read_register_hdl},		//0x01
-	{1, &oid_rt_pro_write_register_hdl},		//0x02
-	{1, &oid_rt_pro_burst_read_register_hdl},	//0x03
-	{1, &oid_rt_pro_burst_write_register_hdl},	//0x04
-	{1, &oid_rt_pro_write_txcmd_hdl},		//0x05
-	{1, &oid_rt_pro_read16_eeprom_hdl},		//0x06
-	{1, &oid_rt_pro_write16_eeprom_hdl},		//0x07
-	{1, &oid_null_function},			//0x08	OID_RT_PRO_H2C_SET_COMMAND
-	{1, &oid_null_function},			//0x09	OID_RT_PRO_H2C_QUERY_RESULT
-	{1, &oid_rt_pro8711_wi_poll_hdl},		//0x0A
-	{1, &oid_rt_pro8711_pkt_loss_hdl},		//0x0B
-	{1, &oid_rt_rd_attrib_mem_hdl},			//0x0C
-	{1, &oid_rt_wr_attrib_mem_hdl},			//0x0D
-	{1, &oid_null_function},			//0x0E
-	{1, &oid_null_function},			//0x0F
-	{1, &oid_null_function},			//0x10	OID_RT_PRO_H2C_CMD_MODE
-	{1, &oid_null_function},			//0x11	OID_RT_PRO_H2C_CMD_RSP_MODE
-	{1, &oid_null_function},			//0X12	OID_RT_PRO_WAIT_C2H_EVENT
-	{1, &oid_null_function},			//0X13	OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST
-	{1, &oid_null_function},			//0X14	OID_RT_PRO_SCSI_ACCESS_TEST
-	{1, &oid_null_function},			//0X15	OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT
-	{1, &oid_null_function},			//0X16	OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN
-	{1, &oid_null_function},			//0X17	OID_RT_RRO_RX_PKT_VIA_IOCTRL
-	{1, &oid_null_function},			//0X18	OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL
-	{1, &oid_null_function},			//0X19	OID_RT_RPO_SET_PWRMGT_TEST
-	{1, &oid_null_function},			//0X1A
-	{1, &oid_null_function},			//0X1B	OID_RT_PRO_QRY_PWRMGT_TEST
-	{1, &oid_null_function},			//0X1C	OID_RT_RPO_ASYNC_RWIO_TEST
-	{1, &oid_null_function},			//0X1D	OID_RT_RPO_ASYNC_RWIO_POLL
-	{1, &oid_rt_pro_set_rf_intfs_hdl},		//0X1E
-	{1, &oid_rt_poll_rx_status_hdl}			//0X1F
+	{1, &oid_rt_pro8711_join_bss_hdl},		/* 0x00 */
+	{1, &oid_rt_pro_read_register_hdl},		/* 0x01 */
+	{1, &oid_rt_pro_write_register_hdl},		/* 0x02 */
+	{1, &oid_rt_pro_burst_read_register_hdl},	/* 0x03 */
+	{1, &oid_rt_pro_burst_write_register_hdl},	/* 0x04 */
+	{1, &oid_rt_pro_write_txcmd_hdl},		/* 0x05 */
+	{1, &oid_rt_pro_read16_eeprom_hdl},		/* 0x06 */
+	{1, &oid_rt_pro_write16_eeprom_hdl},		/* 0x07 */
+	{1, &oid_null_function},			/* 0x08	OID_RT_PRO_H2C_SET_COMMAND */
+	{1, &oid_null_function},			/* 0x09	OID_RT_PRO_H2C_QUERY_RESULT */
+	{1, &oid_rt_pro8711_wi_poll_hdl},		/* 0x0A */
+	{1, &oid_rt_pro8711_pkt_loss_hdl},		/* 0x0B */
+	{1, &oid_rt_rd_attrib_mem_hdl},			/* 0x0C */
+	{1, &oid_rt_wr_attrib_mem_hdl},			/* 0x0D */
+	{1, &oid_null_function},			/* 0x0E */
+	{1, &oid_null_function},			/* 0x0F */
+	{1, &oid_null_function},			/* 0x10	OID_RT_PRO_H2C_CMD_MODE */
+	{1, &oid_null_function},			/* 0x11	OID_RT_PRO_H2C_CMD_RSP_MODE */
+	{1, &oid_null_function},			/* 0X12	OID_RT_PRO_WAIT_C2H_EVENT */
+	{1, &oid_null_function},			/* 0X13	OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST */
+	{1, &oid_null_function},			/* 0X14	OID_RT_PRO_SCSI_ACCESS_TEST */
+	{1, &oid_null_function},			/* 0X15	OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT */
+	{1, &oid_null_function},			/* 0X16	OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN */
+	{1, &oid_null_function},			/* 0X17	OID_RT_RRO_RX_PKT_VIA_IOCTRL */
+	{1, &oid_null_function},			/* 0X18	OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL */
+	{1, &oid_null_function},			/* 0X19	OID_RT_RPO_SET_PWRMGT_TEST */
+	{1, &oid_null_function},			/* 0X1A */
+	{1, &oid_null_function},			/* 0X1B	OID_RT_PRO_QRY_PWRMGT_TEST */
+	{1, &oid_null_function},			/* 0X1C	OID_RT_RPO_ASYNC_RWIO_TEST */
+	{1, &oid_null_function},			/* 0X1D	OID_RT_RPO_ASYNC_RWIO_POLL */
+	{1, &oid_rt_pro_set_rf_intfs_hdl},		/* 0X1E */
+	{1, &oid_rt_poll_rx_status_hdl}			/* 0X1F */
 };
 
 struct oid_obj_priv oid_rtl_seg_87_11_20[] =
 {
-	{1, &oid_rt_pro_cfg_debug_message_hdl},		//0x20
-	{1, &oid_rt_pro_set_data_rate_ex_hdl},		//0x21
-	{1, &oid_rt_pro_set_basic_rate_hdl},		//0x22
-	{1, &oid_rt_pro_read_tssi_hdl},			//0x23
-	{1, &oid_rt_pro_set_power_tracking_hdl}		//0x24
+	{1, &oid_rt_pro_cfg_debug_message_hdl},		/* 0x20 */
+	{1, &oid_rt_pro_set_data_rate_ex_hdl},		/* 0x21 */
+	{1, &oid_rt_pro_set_basic_rate_hdl},		/* 0x22 */
+	{1, &oid_rt_pro_read_tssi_hdl},			/* 0x23 */
+	{1, &oid_rt_pro_set_power_tracking_hdl}		/* 0x24 */
 };
 
 
 struct oid_obj_priv oid_rtl_seg_87_11_50[] =
 {
-	{1, &oid_rt_pro_qry_pwrstate_hdl},		//0x50
-	{1, &oid_rt_pro_set_pwrstate_hdl}		//0x51
+	{1, &oid_rt_pro_qry_pwrstate_hdl},		/* 0x50 */
+	{1, &oid_rt_pro_set_pwrstate_hdl}		/* 0x51 */
 };
 
 struct oid_obj_priv oid_rtl_seg_87_11_80[] =
 {
-	{1, &oid_null_function}				//0x80
+	{1, &oid_null_function}				/* 0x80 */
 };
 
 struct oid_obj_priv oid_rtl_seg_87_11_B0[] =
 {
-	{1, &oid_null_function}				//0xB0
+	{1, &oid_null_function}				/* 0xB0 */
 };
 
 struct oid_obj_priv oid_rtl_seg_87_11_F0[] =
 {
-	{1, &oid_null_function},			//0xF0
-	{1, &oid_null_function},			//0xF1
-	{1, &oid_null_function},			//0xF2
-	{1, &oid_null_function},			//0xF3
-	{1, &oid_null_function},			//0xF4
-	{1, &oid_null_function},			//0xF5
-	{1, &oid_null_function},			//0xF6
-	{1, &oid_null_function},			//0xF7
-	{1, &oid_null_function},			//0xF8
-	{1, &oid_null_function},			//0xF9
-	{1, &oid_null_function},			//0xFA
-	{1, &oid_rt_pro_h2c_set_rate_table_hdl},	//0xFB
-	{1, &oid_rt_pro_h2c_get_rate_table_hdl},	//0xFC
-	{1, &oid_null_function},			//0xFD
-	{1, &oid_null_function},			//0xFE	OID_RT_PRO_H2C_C2H_LBK_TEST
-	{1, &oid_null_function}				//0xFF
+	{1, &oid_null_function},			/* 0xF0 */
+	{1, &oid_null_function},			/* 0xF1 */
+	{1, &oid_null_function},			/* 0xF2 */
+	{1, &oid_null_function},			/* 0xF3 */
+	{1, &oid_null_function},			/* 0xF4 */
+	{1, &oid_null_function},			/* 0xF5 */
+	{1, &oid_null_function},			/* 0xF6 */
+	{1, &oid_null_function},			/* 0xF7 */
+	{1, &oid_null_function},			/* 0xF8 */
+	{1, &oid_null_function},			/* 0xF9 */
+	{1, &oid_null_function},			/* 0xFA */
+	{1, &oid_rt_pro_h2c_set_rate_table_hdl},	/* 0xFB */
+	{1, &oid_rt_pro_h2c_get_rate_table_hdl},	/* 0xFC */
+	{1, &oid_null_function},			/* 0xFD */
+	{1, &oid_null_function},			/* 0xFE	OID_RT_PRO_H2C_C2H_LBK_TEST */
+	{1, &oid_null_function}				/* 0xFF */
 
 };
 
 struct oid_obj_priv oid_rtl_seg_87_12_00[]=
 {
-	{1, &oid_rt_pro_encryption_ctrl_hdl},		//0x00	Q&S
-	{1, &oid_rt_pro_add_sta_info_hdl},		//0x01	S
-	{1, &oid_rt_pro_dele_sta_info_hdl},		//0x02	S
-	{1, &oid_rt_pro_query_dr_variable_hdl},		//0x03	Q
-	{1, &oid_rt_pro_rx_packet_type_hdl},		//0x04	Q,S
-	{1, &oid_rt_pro_read_efuse_hdl},		//0x05	Q	OID_RT_PRO_READ_EFUSE
-	{1, &oid_rt_pro_write_efuse_hdl},		//0x06	S	OID_RT_PRO_WRITE_EFUSE
-	{1, &oid_rt_pro_rw_efuse_pgpkt_hdl},		//0x07	Q,S
-	{1, &oid_rt_get_efuse_current_size_hdl},	//0x08	Q
-	{1, &oid_rt_set_bandwidth_hdl},			//0x09
-	{1, &oid_rt_set_crystal_cap_hdl},		//0x0a
-	{1, &oid_rt_set_rx_packet_type_hdl},		//0x0b	S
-	{1, &oid_rt_get_efuse_max_size_hdl},		//0x0c
-	{1, &oid_rt_pro_set_tx_agc_offset_hdl},		//0x0d
-	{1, &oid_rt_pro_set_pkt_test_mode_hdl},		//0x0e
-	{1, &oid_null_function},			//0x0f		OID_RT_PRO_FOR_EVM_TEST_SETTING
-	{1, &oid_rt_get_thermal_meter_hdl},		//0x10	Q	OID_RT_PRO_GET_THERMAL_METER
-	{1, &oid_rt_reset_phy_rx_packet_count_hdl},	//0x11	S	OID_RT_RESET_PHY_RX_PACKET_COUNT
-	{1, &oid_rt_get_phy_rx_packet_received_hdl},	//0x12	Q	OID_RT_GET_PHY_RX_PACKET_RECEIVED
-	{1, &oid_rt_get_phy_rx_packet_crc32_error_hdl},	//0x13	Q	OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR
-	{1, &oid_rt_set_power_down_hdl},		//0x14	Q	OID_RT_SET_POWER_DOWN
-	{1, &oid_rt_get_power_mode_hdl}			//0x15	Q	OID_RT_GET_POWER_MODE
+	{1, &oid_rt_pro_encryption_ctrl_hdl},		/* 0x00	Q&S */
+	{1, &oid_rt_pro_add_sta_info_hdl},		/* 0x01	S */
+	{1, &oid_rt_pro_dele_sta_info_hdl},		/* 0x02	S */
+	{1, &oid_rt_pro_query_dr_variable_hdl},		/* 0x03	Q */
+	{1, &oid_rt_pro_rx_packet_type_hdl},		/* 0x04	Q,S */
+	{1, &oid_rt_pro_read_efuse_hdl},		/* 0x05	Q	OID_RT_PRO_READ_EFUSE */
+	{1, &oid_rt_pro_write_efuse_hdl},		/* 0x06	S	OID_RT_PRO_WRITE_EFUSE */
+	{1, &oid_rt_pro_rw_efuse_pgpkt_hdl},		/* 0x07	Q,S */
+	{1, &oid_rt_get_efuse_current_size_hdl},	/* 0x08	Q */
+	{1, &oid_rt_set_bandwidth_hdl},			/* 0x09 */
+	{1, &oid_rt_set_crystal_cap_hdl},		/* 0x0a */
+	{1, &oid_rt_set_rx_packet_type_hdl},		/* 0x0b	S */
+	{1, &oid_rt_get_efuse_max_size_hdl},		/* 0x0c */
+	{1, &oid_rt_pro_set_tx_agc_offset_hdl},		/* 0x0d */
+	{1, &oid_rt_pro_set_pkt_test_mode_hdl},		/* 0x0e */
+	{1, &oid_null_function},			/* 0x0f		OID_RT_PRO_FOR_EVM_TEST_SETTING */
+	{1, &oid_rt_get_thermal_meter_hdl},		/* 0x10	Q	OID_RT_PRO_GET_THERMAL_METER */
+	{1, &oid_rt_reset_phy_rx_packet_count_hdl},	/* 0x11	S	OID_RT_RESET_PHY_RX_PACKET_COUNT */
+	{1, &oid_rt_get_phy_rx_packet_received_hdl},	/* 0x12	Q	OID_RT_GET_PHY_RX_PACKET_RECEIVED */
+	{1, &oid_rt_get_phy_rx_packet_crc32_error_hdl},	/* 0x13	Q	OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR */
+	{1, &oid_rt_set_power_down_hdl},		/* 0x14	Q	OID_RT_SET_POWER_DOWN */
+	{1, &oid_rt_get_power_mode_hdl}			/* 0x15	Q	OID_RT_GET_POWER_MODE */
 };
 
 #else /* _RTL871X_MP_IOCTL_C_ */
--- a/drivers/staging/rtl8192du/include/rtw_mp_phy_regdef.h
+++ b/drivers/staging/rtl8192du/include/rtw_mp_phy_regdef.h
@@ -46,24 +46,24 @@
 
 /*--------------------------Define Parameters-------------------------------*/
 
-//============================================================
-//       8192S Regsiter offset definition
-//============================================================
-
-//
-// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
-// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
-// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
-// 3. RF register 0x00-2E
-// 4. Bit Mask for BB/RF register
-// 5. Other defintion for BB/RF R/W
-//
-
-
-//
-// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
-// 1. Page1(0x100)
-//
+/*  */
+/*        8192S Regsiter offset definition */
+/*  */
+
+/*  */
+/*  BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF */
+/*  1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF */
+/*  2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00 */
+/*  3. RF register 0x00-2E */
+/*  4. Bit Mask for BB/RF register */
+/*  5. Other defintion for BB/RF R/W */
+/*  */
+
+
+/*  */
+/*  1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF */
+/*  1. Page1(0x100) */
+/*  */
 #define		rPMAC_Reset					0x100
 #define		rPMAC_TxStart					0x104
 #define		rPMAC_TxLegacySIG				0x108
@@ -92,29 +92,24 @@
 #define		rPMAC_CCKCRxRC32OK			0x188
 #define		rPMAC_TxStatus					0x18c
 
-//
-// 2. Page2(0x200)
-//
-// The following two definition are only used for USB interface.
-//#define		RF_BB_CMD_ADDR				0x02c0	// RF/BB read/write command address.
-//#define		RF_BB_CMD_DATA				0x02c4	// RF/BB read/write command data.
-
-//
-// 3. Page8(0x800)
-//
-#define		rFPGA0_RFMOD				0x800	//RF mode & CCK TxSC // RF BW Setting??
+/*  */
+/*  2. Page2(0x200) */
+/*  */
+
+/*  */
+/*  3. Page8(0x800) */
+/*  */
+#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC  RF BW Setting?? */
 
-#define		rFPGA0_TxInfo				0x804	// Status report??
+#define		rFPGA0_TxInfo				0x804	/*  Status report?? */
 #define		rFPGA0_PSDFunction			0x808
 
-#define		rFPGA0_TxGainStage			0x80c	// Set TX PWR init gain?
+#define		rFPGA0_TxGainStage			0x80c	/*  Set TX PWR init gain? */
 
-#define		rFPGA0_RFTiming1			0x810	// Useless now
+#define		rFPGA0_RFTiming1			0x810	/*  Useless now */
 #define		rFPGA0_RFTiming2			0x814
-//#define rFPGA0_XC_RFTiming			0x818
-//#define rFPGA0_XD_RFTiming			0x81c
 
-#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
+#define		rFPGA0_XA_HSSIParameter1		0x820	/*  RF 3 wire register */
 #define		rFPGA0_XA_HSSIParameter2		0x824
 #define		rFPGA0_XB_HSSIParameter1		0x828
 #define		rFPGA0_XB_HSSIParameter2		0x82c
@@ -127,83 +122,83 @@
 #define		rFPGA0_XC_LSSIParameter		0x848
 #define		rFPGA0_XD_LSSIParameter		0x84c
 
-#define		rFPGA0_RFWakeUpParameter		0x850	// Useless now
+#define		rFPGA0_RFWakeUpParameter		0x850	/*  Useless now */
 #define		rFPGA0_RFSleepUpParameter		0x854
 
-#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
+#define		rFPGA0_XAB_SwitchControl		0x858	/*  RF Channel switch */
 #define		rFPGA0_XCD_SwitchControl		0x85c
 
-#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
+#define		rFPGA0_XA_RFInterfaceOE		0x860	/*  RF Channel switch */
 #define		rFPGA0_XB_RFInterfaceOE		0x864
 #define		rFPGA0_XC_RFInterfaceOE		0x868
 #define		rFPGA0_XD_RFInterfaceOE		0x86c
 
-#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	/*  RF Interface Software Control */
 #define		rFPGA0_XCD_RFInterfaceSW		0x874
 
-#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define		rFPGA0_XAB_RFParameter		0x878	/*  RF Parameter */
 #define		rFPGA0_XCD_RFParameter		0x87c
 
-#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define		rFPGA0_AnalogParameter1		0x880	/*  Crystal cap setting RF-R/W protection for parameter4?? */
 #define		rFPGA0_AnalogParameter2		0x884
-#define		rFPGA0_AnalogParameter3		0x888	// Useless now
+#define		rFPGA0_AnalogParameter3		0x888	/*  Useless now */
 #define		rFPGA0_AnalogParameter4		0x88c
 
-#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	/*  Tranceiver LSSI Readback */
 #define		rFPGA0_XB_LSSIReadBack		0x8a4
 #define		rFPGA0_XC_LSSIReadBack		0x8a8
 #define		rFPGA0_XD_LSSIReadBack		0x8ac
 
-#define		rFPGA0_PSDReport				0x8b4	// Useless now
-#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
-#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
-
-//
-// 4. Page9(0x900)
-//
-#define		rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
-
-#define		rFPGA1_TxBlock				0x904	// Useless now
-#define		rFPGA1_DebugSelect			0x908	// Useless now
-#define		rFPGA1_TxInfo				0x90c	// Useless now // Status report??
-
-//
-// 5. PageA(0xA00)
-//
-// Set Control channel to upper or lower. These settings are required only for 40MHz
+#define		rFPGA0_PSDReport				0x8b4	/*  Useless now */
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/*  Useless now  RF Interface Readback Value */
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/*  Useless now */
+
+/*  */
+/*  4. Page9(0x900) */
+/*  */
+#define		rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC RF BW Setting?? */
+
+#define		rFPGA1_TxBlock				0x904	/*  Useless now */
+#define		rFPGA1_DebugSelect			0x908	/*  Useless now */
+#define		rFPGA1_TxInfo				0x90c	/*  Useless now Status report?? */
+
+/*  */
+/*  5. PageA(0xA00) */
+/*  */
+/*  Set Control channel to upper or lower. These settings are required only for 40MHz */
 #define		rCCK0_System				0xa00
 
-#define		rCCK0_AFESetting			0xa04	// Disable init gain now // Select RX path by RSSI
-#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
+#define		rCCK0_AFESetting			0xa04	/*  Disable init gain now Select RX path by RSSI */
+#define		rCCK0_CCA					0xa08	/*  Disable init gain now Init gain */
 
-#define		rCCK0_RxAGC1				0xa0c	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
-#define		rCCK0_RxAGC2				0xa10	//AGC & DAGC
+#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
+#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */
 
 #define		rCCK0_RxHP					0xa14
 
-#define		rCCK0_DSPParameter1		0xa18	//Timing recovery & Channel estimation threshold
-#define		rCCK0_DSPParameter2		0xa1c	//SQ threshold
+#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
+#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */
 
 #define		rCCK0_TxFilter1				0xa20
 #define		rCCK0_TxFilter2				0xa24
-#define		rCCK0_DebugPort			0xa28	//debug port and Tx filter3
-#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
+#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
 #define		rCCK0_TRSSIReport			0xa50
-#define		rCCK0_RxReport				0xa54  //0xa57
-#define		rCCK0_FACounterLower		0xa5c  //0xa5b
-#define		rCCK0_FACounterUpper		0xa58  //0xa5c
-
-//
-// 6. PageC(0xC00)
-//
+#define		rCCK0_RxReport				0xa54  /* 0xa57 */
+#define		rCCK0_FACounterLower		0xa5c  /* 0xa5b */
+#define		rCCK0_FACounterUpper		0xa58  /* 0xa5c */
+
+/*  */
+/*  6. PageC(0xC00) */
+/*  */
 #define		rOFDM0_LSTF				0xc00
 
 #define		rOFDM0_TRxPathEnable		0xc04
 #define		rOFDM0_TRMuxPar			0xc08
 #define		rOFDM0_TRSWIsolation		0xc0c
 
-#define		rOFDM0_XARxAFE			0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
-#define		rOFDM0_XARxIQImbalance		0xc14  //RxIQ imblance matrix
+#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
+#define		rOFDM0_XARxIQImbalance		0xc14  /* RxIQ imblance matrix */
 #define		rOFDM0_XBRxAFE				0xc18
 #define		rOFDM0_XBRxIQImbalance		0xc1c
 #define		rOFDM0_XCRxAFE				0xc20
@@ -211,17 +206,17 @@
 #define		rOFDM0_XDRxAFE				0xc28
 #define		rOFDM0_XDRxIQImbalance		0xc2c
 
-#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
-#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
-#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
-#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
-
-#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
-#define		rOFDM0_CFOandDAGC		0xc44  //CFO & DAGC
-#define		rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
-#define		rOFDM0_ECCAThreshold		0xc4c // energy CCA
+#define		rOFDM0_RxDetector1			0xc30  /* PD,BW & SBD	DM tune init gain */
+#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
+#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
+#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */
+
+#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
+#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
+#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
+#define		rOFDM0_ECCAThreshold		0xc4c /*  energy CCA */
 
-#define		rOFDM0_XAAGCCore1			0xc50	// DIG
+#define		rOFDM0_XAAGCCore1			0xc50	/*  DIG */
 #define		rOFDM0_XAAGCCore2			0xc54
 #define		rOFDM0_XBAGCCore1			0xc58
 #define		rOFDM0_XBAGCCore2			0xc5c
@@ -235,7 +230,7 @@
 #define		rOFDM0_AGCRSSITable			0xc78
 #define		rOFDM0_HTSTFAGC				0xc7c
 
-#define		rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define		rOFDM0_XATxIQImbalance		0xc80	/*  TX PWR TRACK and DIG */
 #define		rOFDM0_XATxAFE				0xc84
 #define		rOFDM0_XBTxIQImbalance		0xc88
 #define		rOFDM0_XBTxAFE				0xc8c
@@ -257,13 +252,13 @@
 #define		rOFDM0_TxCoeff6				0xcb8
 
 
-//
-// 7. PageD(0xD00)
-//
+/*  */
+/*  7. PageD(0xD00) */
+/*  */
 #define		rOFDM1_LSTF					0xd00
 #define		rOFDM1_TRxPathEnable			0xd04
 
-#define		rOFDM1_CFO						0xd08	// No setting now
+#define		rOFDM1_CFO						0xd08	/*  No setting now */
 #define		rOFDM1_CSI1					0xd10
 #define		rOFDM1_SBD						0xd14
 #define		rOFDM1_CSI2					0xd18
@@ -274,11 +269,11 @@
 #define		rOFDM1_PseudoNoiseStateCD		0xd54
 #define		rOFDM1_RxPseudoNoiseWgt		0xd58
 
-#define		rOFDM_PHYCounter1				0xda0  //cca, parity fail
-#define		rOFDM_PHYCounter2				0xda4  //rate illegal, crc8 fail
-#define		rOFDM_PHYCounter3				0xda8  //MCS not support
+#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
+#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
+#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */
 
-#define		rOFDM_ShortCFOAB				0xdac	// No setting now
+#define		rOFDM_ShortCFOAB				0xdac	/*  No setting now */
 #define		rOFDM_ShortCFOCD				0xdb0
 #define		rOFDM_LongCFOAB				0xdb4
 #define		rOFDM_LongCFOCD				0xdb8
@@ -293,9 +288,9 @@
 #define		rOFDM_SIGReport				0xddc
 
 
-//
-// 8. PageE(0xE00)
-//
+/*  */
+/*  8. PageE(0xE00) */
+/*  */
 #define		rTxAGC_Rate18_06				0xe00
 #define		rTxAGC_Rate54_24				0xe04
 #define		rTxAGC_CCK_Mcs32				0xe08
@@ -304,106 +299,103 @@
 #define		rTxAGC_Mcs11_Mcs08			0xe18
 #define		rTxAGC_Mcs15_Mcs12			0xe1c
 
-// Analog- control in RX_WAIT_CCA : REG: EE0 [Analog- Power & Control Register]
+/*  Analog- control in RX_WAIT_CCA : REG: EE0 [Analog- Power & Control Register] */
 #define			rRx_Wait_CCCA					0xe70
 #define		rAnapar_Ctrl_BB					0xee0
 
-//
-// 7. RF Register 0x00-0x2E (RF 8256)
-//    RF-0222D 0x00-3F
-//
-//Zebra1
+/*  */
+/*  7. RF Register 0x00-0x2E (RF 8256) */
+/*     RF-0222D 0x00-3F */
+/*  */
+/* Zebra1 */
 #define RTL92SE_FPGA_VERIFY 0
-#define		rZebra1_HSSIEnable				0x0	// Useless now
+#define		rZebra1_HSSIEnable				0x0	/*  Useless now */
 #define		rZebra1_TRxEnable1				0x1
 #define		rZebra1_TRxEnable2				0x2
 #define		rZebra1_AGC					0x4
 #define		rZebra1_ChargePump			0x5
-//#if (RTL92SE_FPGA_VERIFY == 1)
-#define		rZebra1_Channel				0x7	// RF channel switch
-//#else
+#define		rZebra1_Channel				0x7	/*  RF channel switch */
 
-//#endif
-#define		rZebra1_TxGain					0x8	// Useless now
+#define		rZebra1_TxGain					0x8	/*  Useless now */
 #define		rZebra1_TxLPF					0x9
 #define		rZebra1_RxLPF					0xb
 #define		rZebra1_RxHPFCorner			0xc
 
-//Zebra4
-#define		rGlobalCtrl						0	// Useless now
+/* Zebra4 */
+#define		rGlobalCtrl						0	/*  Useless now */
 #define		rRTL8256_TxLPF					19
 #define		rRTL8256_RxLPF					11
 
-//RTL8258
-#define		rRTL8258_TxLPF					0x11	// Useless now
+/* RTL8258 */
+#define		rRTL8258_TxLPF					0x11	/*  Useless now */
 #define		rRTL8258_RxLPF					0x13
 #define		rRTL8258_RSSILPF				0xa
 
-//
-// RL6052 Register definition
-//
-#define		RF_AC						0x00	//
-
-#define		RF_IQADJ_G1				0x01	//
-#define		RF_IQADJ_G2				0x02	//
-#define		RF_POW_TRSW				0x05	//
-
-#define		RF_GAIN_RX					0x06	//
-#define		RF_GAIN_TX					0x07	//
-
-#define		RF_TXM_IDAC				0x08	//
-#define		RF_BS_IQGEN				0x0F	//
-
-#define		RF_MODE1					0x10	//
-#define		RF_MODE2					0x11	//
-
-#define		RF_RX_AGC_HP				0x12	//
-#define		RF_TX_AGC					0x13	//
-#define		RF_BIAS						0x14	//
-#define		RF_IPA						0x15	//
-#define		RF_POW_ABILITY			0x17	//
-#define		RF_MODE_AG				0x18	//
-#define		rRfChannel					0x18	// RF channel and BW switch
-#define		RF_CHNLBW					0x18	// RF channel and BW switch
-#define		RF_TOP						0x19	//
-
-#define		RF_RX_G1					0x1A	//
-#define		RF_RX_G2					0x1B	//
-
-#define		RF_RX_BB2					0x1C	//
-#define		RF_RX_BB1					0x1D	//
-
-#define		RF_RCK1					0x1E	//
-#define		RF_RCK2					0x1F	//
-
-#define		RF_TX_G1					0x20	//
-#define		RF_TX_G2					0x21	//
-#define		RF_TX_G3					0x22	//
-
-#define		RF_TX_BB1					0x23	//
-
-#define		RF_T_METER					0x24	//
-
-#define		RF_SYN_G1					0x25	// RF TX Power control
-#define		RF_SYN_G2					0x26	// RF TX Power control
-#define		RF_SYN_G3					0x27	// RF TX Power control
-#define		RF_SYN_G4					0x28	// RF TX Power control
-#define		RF_SYN_G5					0x29	// RF TX Power control
-#define		RF_SYN_G6					0x2A	// RF TX Power control
-#define		RF_SYN_G7					0x2B	// RF TX Power control
-#define		RF_SYN_G8					0x2C	// RF TX Power control
-
-#define		RF_RCK_OS					0x30	// RF TX PA control
-
-#define		RF_TXPA_G1					0x31	// RF TX PA control
-#define		RF_TXPA_G2					0x32	// RF TX PA control
-#define		RF_TXPA_G3					0x33	// RF TX PA control
-
-//
-//Bit Mask
-//
-// 1. Page1(0x100)
-#define		bBBResetB						0x100	// Useless now?
+/*  */
+/*  RL6052 Register definition */
+/*  */
+#define		RF_AC						0x00	/*  */
+
+#define		RF_IQADJ_G1				0x01	/*  */
+#define		RF_IQADJ_G2				0x02	/*  */
+#define		RF_POW_TRSW				0x05	/*  */
+
+#define		RF_GAIN_RX					0x06	/*  */
+#define		RF_GAIN_TX					0x07	/*  */
+
+#define		RF_TXM_IDAC				0x08	/*  */
+#define		RF_BS_IQGEN				0x0F	/*  */
+
+#define		RF_MODE1					0x10	/*  */
+#define		RF_MODE2					0x11	/*  */
+
+#define		RF_RX_AGC_HP				0x12	/*  */
+#define		RF_TX_AGC					0x13	/*  */
+#define		RF_BIAS						0x14	/*  */
+#define		RF_IPA						0x15	/*  */
+#define		RF_POW_ABILITY			0x17	/*  */
+#define		RF_MODE_AG				0x18	/*  */
+#define		rRfChannel					0x18	/*  RF channel and BW switch */
+#define		RF_CHNLBW					0x18	/*  RF channel and BW switch */
+#define		RF_TOP						0x19	/*  */
+
+#define		RF_RX_G1					0x1A	/*  */
+#define		RF_RX_G2					0x1B	/*  */
+
+#define		RF_RX_BB2					0x1C	/*  */
+#define		RF_RX_BB1					0x1D	/*  */
+
+#define		RF_RCK1					0x1E	/*  */
+#define		RF_RCK2					0x1F	/*  */
+
+#define		RF_TX_G1					0x20	/*  */
+#define		RF_TX_G2					0x21	/*  */
+#define		RF_TX_G3					0x22	/*  */
+
+#define		RF_TX_BB1					0x23	/*  */
+
+#define		RF_T_METER					0x24	/*  */
+
+#define		RF_SYN_G1					0x25	/*  RF TX Power control */
+#define		RF_SYN_G2					0x26	/*  RF TX Power control */
+#define		RF_SYN_G3					0x27	/*  RF TX Power control */
+#define		RF_SYN_G4					0x28	/*  RF TX Power control */
+#define		RF_SYN_G5					0x29	/*  RF TX Power control */
+#define		RF_SYN_G6					0x2A	/*  RF TX Power control */
+#define		RF_SYN_G7					0x2B	/*  RF TX Power control */
+#define		RF_SYN_G8					0x2C	/*  RF TX Power control */
+
+#define		RF_RCK_OS					0x30	/*  RF TX PA control */
+
+#define		RF_TXPA_G1					0x31	/*  RF TX PA control */
+#define		RF_TXPA_G2					0x32	/*  RF TX PA control */
+#define		RF_TXPA_G3					0x33	/*  RF TX PA control */
+
+/*  */
+/* Bit Mask */
+/*  */
+/*  1. Page1(0x100) */
+#define		bBBResetB						0x100	/*  Useless now? */
 #define		bGlobalResetB					0x200
 #define		bOFDMTxStart					0x4
 #define		bCCKTxStart						0x8
@@ -450,34 +442,34 @@
 
 #define			IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
 
-// 2. Page8(0x800)
-#define		bRFMOD							0x1	// Reg 0x800 rFPGA0_RFMOD
+/*  2. Page8(0x800) */
+#define		bRFMOD							0x1	/*  Reg 0x800 rFPGA0_RFMOD */
 #define		bJapanMode						0x2
 #define		bCCKTxSC						0x30
 #define		bCCKEn							0x1000000
 #define		bOFDMEn						0x2000000
 
-#define		bOFDMRxADCPhase				0x10000	// Useless now
+#define		bOFDMRxADCPhase				0x10000	/*  Useless now */
 #define		bOFDMTxDACPhase				0x40000
 #define		bXATxAGC					0x3f
 
-#define		bXBTxAGC					0xf00	// Reg 80c rFPGA0_TxGainStage
+#define		bXBTxAGC					0xf00	/*  Reg 80c rFPGA0_TxGainStage */
 #define		bXCTxAGC					0xf000
 #define		bXDTxAGC					0xf0000
 
-#define		bPAStart					0xf0000000	// Useless now
+#define		bPAStart					0xf0000000	/*  Useless now */
 #define		bTRStart					0x00f00000
 #define		bRFStart					0x0000f000
 #define		bBBStart					0x000000f0
 #define		bBBCCKStart				0x0000000f
-#define		bPAEnd						0xf          //Reg0x814
+#define		bPAEnd						0xf          /* Reg0x814 */
 #define		bTREnd						0x0f000000
 #define		bRFEnd						0x000f0000
-#define		bCCAMask					0x000000f0   //T2R
+#define		bCCAMask					0x000000f0   /* T2R */
 #define		bR2RCCAMask				0x00000f00
 #define		bHSSI_R2TDelay				0xf8000000
 #define		bHSSI_T2RDelay				0xf80000
-#define		bContTxHSSI				0x400     //chane gain at continue Tx
+#define		bContTxHSSI				0x400     /* chane gain at continue Tx */
 #define		bIGFromCCK				0x200
 #define		bAGCAddress				0x3f
 #define		bRxHPTx						0x7000
@@ -486,11 +478,11 @@
 #define		bAGCTxCode				0xc00000
 #define		bAGCRxCode				0x300000
 
-#define		b3WireDataLength			0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
+#define		b3WireDataLength			0x800	/*  Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
 #define		b3WireAddressLength			0x400
 
-#define		b3WireRFPowerDown			0x1	// Useless now
-//#define bHWSISelect				0x8
+#define		b3WireRFPowerDown			0x1	/*  Useless now */
+/* define bHWSISelect				0x8 */
 #define		b5GPAPEPolarity				0x40000000
 #define		b2GPAPEPolarity				0x80000000
 #define		bRFSW_TxDefaultAnt			0x3
@@ -503,9 +495,9 @@
 #define		bRFSI_3WireRW				0x8
 #define		bRFSI_3Wire					0xf
 
-#define		bRFSI_RFENV				0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
+#define		bRFSI_RFENV				0x10	/*  Reg 0x870 rFPGA0_XAB_RFInterfaceSW */
 
-#define		bRFSI_TRSW				0x20	// Useless now
+#define		bRFSI_TRSW				0x20	/*  Useless now */
 #define		bRFSI_TRSWB				0x40
 #define		bRFSI_ANTSW				0x100
 #define		bRFSI_ANTSWB				0x200
@@ -529,18 +521,18 @@
 #define		bLSIG_Parity					0x20
 #define		bCCKRxPhase				0x4
 #if (RTL92SE_FPGA_VERIFY == 1)
-#define		bLSSIReadAddress			0x3f000000   //LSSI "Read" Address	// Reg 0x824 rFPGA0_XA_HSSIParameter2
+#define		bLSSIReadAddress			0x3f000000   /* LSSI "Read" Address  Reg 0x824 rFPGA0_XA_HSSIParameter2 */
 #else
-#define		bLSSIReadAddress			0x7f800000   // T65 RF
+#define		bLSSIReadAddress			0x7f800000   /*  T65 RF */
 #endif
-#define		bLSSIReadEdge				0x80000000   //LSSI "Read" edge signal
+#define		bLSSIReadEdge				0x80000000   /* LSSI "Read" edge signal */
 #if (RTL92SE_FPGA_VERIFY == 1)
-#define		bLSSIReadBackData			0xfff		// Reg 0x8a0 rFPGA0_XA_LSSIReadBack
+#define		bLSSIReadBackData			0xfff		/*  Reg 0x8a0 rFPGA0_XA_LSSIReadBack */
 #else
-#define		bLSSIReadBackData			0xfffff		// T65 RF
+#define		bLSSIReadBackData			0xfffff		/*  T65 RF */
 #endif
-#define		bLSSIReadOKFlag				0x1000	// Useless now
-#define		bCCKSampleRate				0x8       //0: 44MHz, 1:88MHz
+#define		bLSSIReadOKFlag				0x1000	/*  Useless now */
+#define		bCCKSampleRate				0x8       /* 0: 44MHz, 1:88MHz */
 #define		bRegulator0Standby			0x1
 #define		bRegulatorPLLStandby			0x2
 #define		bRegulator1Standby			0x4
@@ -554,17 +546,17 @@
 #define		bDA6DebugMode				0x20000
 #define		bDA6Swing					0x380000
 
-#define		bADClkPhase				0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
+#define		bADClkPhase				0x4000000	/*  Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */
 
-#define		b80MClkDelay				0x18000000	// Useless
+#define		b80MClkDelay				0x18000000	/*  Useless */
 #define		bAFEWatchDogEnable			0x20000000
 
-#define		bXtalCap01					0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
+#define		bXtalCap01					0xc0000000	/*  Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
 #define		bXtalCap23					0x3
 #define		bXtalCap92x					0x0f000000
 #define			bXtalCap					0x0f000000
 
-#define		bIntDifClkEnable			0x400	// Useless
+#define		bIntDifClkEnable			0x400	/*  Useless */
 #define		bExtSigClkEnable			0x800
 #define		bBandgapMbiasPowerUp		0x10000
 #define		bAD11SHGain				0xc0000
@@ -598,12 +590,12 @@
 #define		bPSDSineToneScale			0x7f000000
 #define		bPSDReport					0xffff
 
-// 3. Page9(0x900)
-#define		bOFDMTxSC				0x30000000	// Useless
+/*  3. Page9(0x900) */
+#define		bOFDMTxSC				0x30000000	/*  Useless */
 #define		bCCKTxOn					0x1
 #define		bOFDMTxOn				0x2
-#define		bDebugPage				0xfff  //reset debug page and also HWord, LWord
-#define		bDebugItem				0xff   //reset debug page and LWord
+#define		bDebugPage				0xfff  /* reset debug page and also HWord, LWord */
+#define		bDebugItem				0xff   /* reset debug page and LWord */
 #define		bAntL					0x10
 #define		bAntNonHT					0x100
 #define		bAntHT1					0x1000
@@ -611,14 +603,14 @@
 #define		bAntHT1S1					0x100000
 #define		bAntNonHTS1				0x1000000
 
-// 4. PageA(0xA00)
-#define		bCCKBBMode				0x3	// Useless
+/*  4. PageA(0xA00) */
+#define		bCCKBBMode				0x3	/*  Useless */
 #define		bCCKTxPowerSaving			0x80
 #define		bCCKRxPowerSaving			0x40
 
-#define		bCCKSideBand				0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+#define		bCCKSideBand				0x10	/*  Reg 0xa00 rCCK0_System 20/40 switch */
 
-#define		bCCKScramble				0x8	// Useless
+#define		bCCKScramble				0x8	/*  Useless */
 #define		bCCKAntDiversity			0x8000
 #define		bCCKCarrierRecovery		0x4000
 #define		bCCKTxRate				0x3000
@@ -634,7 +626,7 @@
 #define		bCCKBistMode				0x80000000
 #define		bCCKCCAMask				0x40000000
 #define		bCCKTxDACPhase			0x4
-#define		bCCKRxADCPhase			0x20000000   //r_rx_clk
+#define		bCCKRxADCPhase			0x20000000   /* r_rx_clk */
 #define		bCCKr_cp_mode0			0x0100
 #define		bCCKTxDCOffset				0xf0
 #define		bCCKRxDCOffset				0xf
@@ -648,12 +640,11 @@
 #define		bCCKRxIG					0x7f00
 #define		bCCKLNAPolarity				0x800000
 #define		bCCKRx1stGain				0x7f0000
-#define		bCCKRFExtend				0x20000000 //CCK Rx Iinital gain polarity
+#define		bCCKRFExtend				0x20000000 /* CCK Rx Iinital gain polarity */
 #define		bCCKRxAGCSatLevel			0x1f000000
 #define		bCCKRxAGCSatCount			0xe0
-#define		bCCKRxRFSettle				0x1f       //AGCsamp_dly
+#define		bCCKRxRFSettle				0x1f       /* AGCsamp_dly */
 #define		bCCKFixedRxAGC				0x8000
-//#define bCCKRxAGCFormat			0x4000   //remove to HSSI register 0x824
 #define		bCCKAntennaPolarity			0x2000
 #define		bCCKTxFilterType			0x0c00
 #define		bCCKRxAGCReportType		0x0300
@@ -692,8 +683,8 @@
 #define		bCCKDefaultRxPath			0xc000000
 #define		bCCKOptionRxPath			0x3000000
 
-// 5. PageC(0xC00)
-#define		bNumOfSTF					0x3	// Useless
+/*  5. PageC(0xC00) */
+#define		bNumOfSTF					0x3	/*  Useless */
 #define		bShift_L					0xc0
 #define		bGI_TH						0xc
 #define		bRxPathA					0x1
@@ -794,8 +785,8 @@
 #define		bRxHP_BBP1               0x7000
 #define		bRxHP_BBP2               0x70000
 #define		bRxHP_BBP3               0x700000
-#define		bRSSI_H                  0x7f0000     //the threshold for high power
-#define		bRSSI_Gen                0x7f000000   //the threshold for ant diversity
+#define		bRSSI_H                  0x7f0000     /* the threshold for high power */
+#define		bRSSI_Gen                0x7f000000   /* the threshold for ant diversity */
 #define		bRxSettle_TRSW           0x7
 #define		bRxSettle_LNA            0x38
 #define		bRxSettle_RSSI           0x1c0
@@ -829,7 +820,7 @@
 #define		bRxPD_Delay_TH1          0x38
 #define		bRxPD_Delay_TH2          0x1c0
 #define		bRxPD_DC_COUNT_MAX       0x600
-//#define bRxMF_Hold               0x3800
+/* define bRxMF_Hold               0x3800 */
 #define		bRxPD_Delay_TH           0x8000
 #define		bRxProcess_Delay         0xf0000
 #define		bRxSearchrange_GI2_Early 0x700000
@@ -850,8 +841,8 @@
 #define		bTRSWIsolation_D         0x7f000000
 #define		bExtLNAGain              0x7c00
 
-// 6. PageE(0xE00)
-#define		bSTBCEn                  0x4	// Useless
+/*  6. PageE(0xE00) */
+#define		bSTBCEn                  0x4	/*  Useless */
 #define		bAntennaMapping          0x10
 #define		bNss                     0x20
 #define		bCFOAntSumD              0x200
@@ -860,12 +851,6 @@
 #define		bOFDMContinueTx          0x10000000
 #define		bOFDMSingleCarrier       0x20000000
 #define		bOFDMSingleTone          0x40000000
-//#define bRxPath1                 0x01
-//#define bRxPath2                 0x02
-//#define bRxPath3                 0x04
-//#define bRxPath4                 0x08
-//#define bTxPath1                 0x10
-//#define bTxPath2                 0x20
 #define		bHTDetect                0x100
 #define		bCFOEn                   0x10000
 #define		bCFOValue                0xfff00000
@@ -878,8 +863,8 @@
 #define		bCounter_MCSNoSupport    0xffff
 #define		bCounter_FastSync        0xffff
 #define		bShortCFO                0xfff
-#define		bShortCFOTLength         12   //total
-#define		bShortCFOFLength         11   //fraction
+#define		bShortCFOTLength         12   /* total */
+#define		bShortCFOFLength         11   /* fraction */
 #define		bLongCFO                 0x7ff
 #define		bLongCFOTLength          11
 #define		bLongCFOFLength          11
@@ -914,7 +899,7 @@
 #define		bPWDB                    0xff00
 #define		bSGIEN                   0x10000
 
-#define		bSFactorQAM1             0xf	// Useless
+#define		bSFactorQAM1             0xf	/*  Useless */
 #define		bSFactorQAM2             0xf0
 #define		bSFactorQAM3             0xf00
 #define		bSFactorQAM4             0xf000
@@ -925,7 +910,7 @@
 #define		bSFactorQAM9             0xf0000000
 #define		bCSIScheme               0x100000
 
-#define		bNoiseLvlTopSet          0x3	// Useless
+#define		bNoiseLvlTopSet          0x3	/*  Useless */
 #define		bChSmooth                0x4
 #define		bChSmoothCfg1            0x38
 #define		bChSmoothCfg2            0x1c0
@@ -934,7 +919,7 @@
 #define		bMRCMode                 0x800000
 #define		bTHEVMCfg                0x7000000
 
-#define		bLoopFitType             0x1	// Useless
+#define		bLoopFitType             0x1	/*  Useless */
 #define		bUpdCFO                  0x40
 #define		bUpdCFOOffData           0x80
 #define		bAdvUpdCFO               0x100
@@ -950,7 +935,7 @@
 #define		bUChCfg                  0x7000000
 #define		bUpdEqz                  0x8000000
 
-#define		bTxAGCRate18_06			0x7f7f7f7f	// Useless
+#define		bTxAGCRate18_06			0x7f7f7f7f	/*  Useless */
 #define		bTxAGCRate54_24			0x7f7f7f7f
 #define		bTxAGCRateMCS32			0x7f
 #define		bTxAGCRateCCK			0x7f00
@@ -959,8 +944,8 @@
 #define		bTxAGCRateMCS11_MCS8	0x7f7f7f7f
 #define		bTxAGCRateMCS15_MCS12	0x7f7f7f7f
 
-//Rx Pseduo noise
-#define		bRxPesudoNoiseOn         0x20000000	// Useless
+/* Rx Pseduo noise */
+#define		bRxPesudoNoiseOn         0x20000000	/*  Useless */
 #define		bRxPesudoNoise_A         0xff
 #define		bRxPesudoNoise_B         0xff00
 #define		bRxPesudoNoise_C         0xff0000
@@ -970,9 +955,9 @@
 #define		bPesudoNoiseState_C      0xffff
 #define		bPesudoNoiseState_D      0xffff0000
 
-//7. RF Register
-//Zebra1
-#define		bZebra1_HSSIEnable        0x8		// Useless
+/* 7. RF Register */
+/* Zebra1 */
+#define		bZebra1_HSSIEnable        0x8		/*  Useless */
 #define		bZebra1_TRxControl        0xc00
 #define		bZebra1_TRxGainSetting    0x07f
 #define		bZebra1_RxCorner          0xc00
@@ -982,24 +967,24 @@
 #define		bZebra1_TxLPFBW           0x400
 #define		bZebra1_RxLPFBW           0x600
 
-//Zebra4
-#define		bRTL8256RegModeCtrl1      0x100	// Useless
+/* Zebra4 */
+#define		bRTL8256RegModeCtrl1      0x100	/*  Useless */
 #define		bRTL8256RegModeCtrl0      0x40
 #define		bRTL8256_TxLPFBW          0x18
 #define		bRTL8256_RxLPFBW          0x600
 
-//RTL8258
-#define		bRTL8258_TxLPFBW          0xc	// Useless
+/* RTL8258 */
+#define		bRTL8258_TxLPFBW          0xc	/*  Useless */
 #define		bRTL8258_RxLPFBW          0xc00
 #define		bRTL8258_RSSILPFBW        0xc0
 
 
-//
-// Other Definition
-//
+/*  */
+/*  Other Definition */
+/*  */
 
-//byte endable for sb_write
-#define		bByte0                    0x1	// Useless
+/* byte endable for sb_write */
+#define		bByte0                    0x1	/*  Useless */
 #define		bByte1                    0x2
 #define		bByte2                    0x4
 #define		bByte3                    0x8
@@ -1007,8 +992,8 @@
 #define		bWord1                    0xc
 #define		bDWord                    0xf
 
-//for PutRegsetting & GetRegSetting BitMask
-#define		bMaskByte0		0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+/* for PutRegsetting & GetRegSetting BitMask */
+#define		bMaskByte0		0xff	/*  Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
 #define		bMaskByte1		0xff00
 #define		maskbyte2		0xff0000
 #define		bMaskByte3		0xff000000
@@ -1020,68 +1005,57 @@
 #define		bMaskCCK		0x3f3f3f3f
 #define		bMask12Bits		0xfff
 
-//for PutRFRegsetting & GetRFRegSetting BitMask
+/* for PutRFRegsetting & GetRFRegSetting BitMask */
 #if (RTL92SE_FPGA_VERIFY == 1)
-//#define		bMask12Bits               0xfff	// RF Reg mask bits
-//#define		bMask20Bits               0xfff	// RF Reg mask bits T65 RF
 #define			bRFRegOffsetMask	0xfff
 #else
-//#define		bMask12Bits               0xfffff	// RF Reg mask bits
-//#define		bMask20Bits               0xfffff	// RF Reg mask bits T65 RF
 #define			bRFRegOffsetMask	0xfffff
 #endif
-#define		bEnable                   0x1	// Useless
+#define		bEnable                   0x1	/*  Useless */
 #define		bDisable                  0x0
 
-#define		LeftAntenna               0x0	// Useless
+#define		LeftAntenna               0x0	/*  Useless */
 #define		RightAntenna              0x1
 
-#define		tCheckTxStatus            500   //500ms // Useless
-#define		tUpdateRxCounter          100   //100ms
+#define		tCheckTxStatus            500   /* 500ms Useless */
+#define		tUpdateRxCounter          100   /* 100ms */
 
-#define		rateCCK     0	// Useless
+#define		rateCCK     0	/*  Useless */
 #define		rateOFDM    1
 #define		rateHT      2
 
-//define Register-End
-#define		bPMAC_End                 0x1ff	// Useless
+/* define Register-End */
+#define		bPMAC_End                 0x1ff	/*  Useless */
 #define		bFPGAPHY0_End             0x8ff
 #define		bFPGAPHY1_End             0x9ff
 #define		bCCKPHY0_End              0xaff
 #define		bOFDMPHY0_End             0xcff
 #define		bOFDMPHY1_End             0xdff
 
-//define max debug item in each debug page
-//#define bMaxItem_FPGA_PHY0        0x9
-//#define bMaxItem_FPGA_PHY1        0x3
-//#define bMaxItem_PHY_11B          0x16
-//#define bMaxItem_OFDM_PHY0        0x29
-//#define bMaxItem_OFDM_PHY1        0x0
-
-#define		bPMACControl	0x0		// Useless
+#define		bPMACControl	0x0		/*  Useless */
 #define		bWMACControl	0x1
 #define		bWNICControl	0x2
 
-#define RCR_AAP			BIT(0)				// accept all physical address
-#define RCR_APM			BIT(1)				// accept physical match
-#define RCR_AM			BIT(2)				// accept multicast
-#define RCR_AB			BIT(3)				// accept broadcast
-#define RCR_ACRC32		BIT(5)				// accept error packet
+#define RCR_AAP			BIT(0)				/*  accept all physical address */
+#define RCR_APM			BIT(1)				/*  accept physical match */
+#define RCR_AM			BIT(2)				/*  accept multicast */
+#define RCR_AB			BIT(3)				/*  accept broadcast */
+#define RCR_ACRC32		BIT(5)				/*  accept error packet */
 #define RCR_9356SEL		BIT(6)
-#define RCR_AICV		BIT(12)				// Accept ICV error packet
-#define RCR_RXFTH0		(BIT(13)|BIT(14)|BIT(15))	// Rx FIFO threshold
-#define RCR_ADF			BIT(18)				// Accept Data(frame type) frame
-#define RCR_ACF			BIT(19)				// Accept control frame
-#define RCR_AMF			BIT(20)				// Accept management frame
+#define RCR_AICV		BIT(12)				/*  Accept ICV error packet */
+#define RCR_RXFTH0		(BIT(13)|BIT(14)|BIT(15))	/*  Rx FIFO threshold */
+#define RCR_ADF			BIT(18)				/*  Accept Data(frame type) frame */
+#define RCR_ACF			BIT(19)				/*  Accept control frame */
+#define RCR_AMF			BIT(20)				/*  Accept management frame */
 #define RCR_ADD3		BIT(21)
-#define RCR_APWRMGT		BIT(22)				// Accept power management packet
-#define RCR_CBSSID		BIT(23)				// Accept BSSID match packet
-#define RCR_ENMARP		BIT(28)				// enable mac auto reset phy
-#define RCR_EnCS1		BIT(29)				// enable carrier sense method 1
-#define RCR_EnCS2		BIT(30)				// enable carrier sense method 2
-#define RCR_OnlyErlPkt		BIT(31)				// Rx Early mode is performed for packet size greater than 1536
+#define RCR_APWRMGT		BIT(22)				/*  Accept power management packet */
+#define RCR_CBSSID		BIT(23)				/*  Accept BSSID match packet */
+#define RCR_ENMARP		BIT(28)				/*  enable mac auto reset phy */
+#define RCR_EnCS1		BIT(29)				/*  enable carrier sense method 1 */
+#define RCR_EnCS2		BIT(30)				/*  enable carrier sense method 2 */
+#define RCR_OnlyErlPkt		BIT(31)				/*  Rx Early mode is performed for packet size greater than 1536 */
 
 /*--------------------------Define Parameters-------------------------------*/
 
 
-#endif	//__INC_HAL8192SPHYREG_H
+#endif	/* __INC_HAL8192SPHYREG_H */
--- a/drivers/staging/rtl8192du/include/rtw_p2p.h
+++ b/drivers/staging/rtl8192du/include/rtw_p2p.h
@@ -40,7 +40,7 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 u32 build_assoc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
 u32 build_provdisc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
 u32 build_provdisc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
 u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len, struct sta_info *psta);
@@ -59,13 +59,13 @@ void p2p_protocol_wk_hdl(struct rtw_adap
 void	process_p2p_ps_ie(PADAPTER padapter, u8 *IEs, u32 IELength);
 void	p2p_ps_wk_hdl(struct rtw_adapter *padapter, u8 p2p_ps_state);
 u8	p2p_ps_wk_cmd(struct rtw_adapter*padapter, u8 p2p_ps_state, u8 enqueue);
-#endif // CONFIG_P2P_PS
+#endif /*  CONFIG_P2P_PS */
 
 #ifdef CONFIG_IOCTL_CFG80211
 void rtw_init_cfg80211_wifidirect_info(struct rtw_adapter *padapter);
 int rtw_p2p_check_frames(struct rtw_adapter *padapter, const u8 *buf, u32 len, u8 tx);
 void rtw_append_wfd_ie(struct rtw_adapter *padapter, u8 *buf, u32 *len);
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 void reset_global_wifidirect_info(struct rtw_adapter *padapter);
 int rtw_init_wifi_display_info(struct rtw_adapter *padapter);
@@ -77,7 +77,6 @@ int rtw_p2p_enable(struct rtw_adapter *p
 static inline void _rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
 {
 	if (wdinfo->p2p_state != state) {
-		//wdinfo->pre_p2p_state = wdinfo->p2p_state;
 		wdinfo->p2p_state = state;
 	}
 }
@@ -118,18 +117,15 @@ static inline bool _rtw_p2p_chk_role(str
 #ifdef CONFIG_DBG_P2P
 void dbg_rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line);
 void dbg_rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line);
-//void dbg_rtw_p2p_restore_state(struct wifidirect_info *wdinfo, const char *caller, int line);
 void dbg_rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role, const char *caller, int line);
 #define rtw_p2p_set_state(wdinfo, state) dbg_rtw_p2p_set_state(wdinfo, state, __func__, __LINE__)
 #define rtw_p2p_set_pre_state(wdinfo, state) dbg_rtw_p2p_set_pre_state(wdinfo, state, __func__, __LINE__)
 #define rtw_p2p_set_role(wdinfo, role) dbg_rtw_p2p_set_role(wdinfo, role, __func__, __LINE__)
-//#define rtw_p2p_restore_state(wdinfo) dbg_rtw_p2p_restore_state(wdinfo, __func__, __LINE__)
-#else //CONFIG_DBG_P2P
+#else /* CONFIG_DBG_P2P */
 #define rtw_p2p_set_state(wdinfo, state) _rtw_p2p_set_state(wdinfo, state)
 #define rtw_p2p_set_pre_state(wdinfo, state) _rtw_p2p_set_pre_state(wdinfo, state)
 #define rtw_p2p_set_role(wdinfo, role) _rtw_p2p_set_role(wdinfo, role)
-//#define rtw_p2p_restore_state(wdinfo) _rtw_p2p_restore_state(wdinfo)
-#endif //CONFIG_DBG_P2P
+#endif /* CONFIG_DBG_P2P */
 
 #define rtw_p2p_state(wdinfo) _rtw_p2p_state(wdinfo)
 #define rtw_p2p_pre_state(wdinfo) _rtw_p2p_pre_state(wdinfo)
@@ -140,11 +136,11 @@ void dbg_rtw_p2p_set_role(struct wifidir
 #define rtw_p2p_findphase_ex_set(wdinfo, value) \
 	(wdinfo)->find_phase_state_exchange_cnt = (value)
 
-//is this find phase exchange for social channel scan?
+/* is this find phase exchange for social channel scan? */
 #define rtw_p2p_findphase_ex_is_social(wdinfo)   \
 	(wdinfo)->find_phase_state_exchange_cnt >= P2P_FINDPHASE_EX_SOCIAL_FIRST
 
-//should we need find phase exchange anymore?
+/* should we need find phase exchange anymore? */
 #define rtw_p2p_findphase_ex_is_needed(wdinfo) \
 	((wdinfo)->find_phase_state_exchange_cnt < P2P_FINDPHASE_EX_MAX && \
 	(wdinfo)->find_phase_state_exchange_cnt != P2P_FINDPHASE_EX_NONE)
--- a/drivers/staging/rtl8192du/include/rtw_pwrctrl.h
+++ b/drivers/staging/rtl8192du/include/rtw_pwrctrl.h
@@ -26,7 +26,7 @@
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
-#endif //CONFIG_HAS_EARLYSUSPEND
+#endif /* CONFIG_HAS_EARLYSUSPEND */
 
 
 #define FW_PWR0	0
@@ -106,7 +106,7 @@ enum Power_Mgnt
 
 struct reportpwrstate_parm {
 	unsigned char mode;
-	unsigned char state; //the CPWM value
+	unsigned char state; /* the CPWM value */
 	unsigned short rsvd;
 };
 
@@ -132,31 +132,31 @@ __inline static void _exit_pwrlock(struc
 	_rtw_up_sema(plock);
 }
 
-#define LPS_DELAY_TIME	1*HZ // 1 sec
+#define LPS_DELAY_TIME	1*HZ /*  1 sec */
 
 #define EXE_PWR_NONE	0x01
 #define EXE_PWR_IPS		0x02
 #define EXE_PWR_LPS		0x04
 
-// RF state.
+/*  RF state. */
 enum rt_rf_power_state {
-	rf_on,		// RF is on after RFSleep or RFOff
-	rf_sleep,	// 802.11 Power Save mode
-	rf_off,		// HW/SW Radio OFF or Inactive Power Save
-	//=====Add the new RF state above this line=====//
+	rf_on,		/*  RF is on after RFSleep or RFOff */
+	rf_sleep,	/*  802.11 Power Save mode */
+	rf_off,		/*  HW/SW Radio OFF or Inactive Power Save */
+	/* Add the new RF state above this line===== */
 	rf_max
 };
 
-// RF Off Level for IPS or HW/SW radio off
-#define	RT_RF_OFF_LEVL_ASPM			BIT(0)	// PCI ASPM
-#define	RT_RF_OFF_LEVL_CLK_REQ		BIT(1)	// PCI clock request
-#define	RT_RF_OFF_LEVL_PCI_D3			BIT(2)	// PCI D3 mode
-#define	RT_RF_OFF_LEVL_HALT_NIC		BIT(3)	// NIC halt, re-initialize hw parameters
-#define	RT_RF_OFF_LEVL_FREE_FW		BIT(4)	// FW free, re-download the FW
-#define	RT_RF_OFF_LEVL_FW_32K		BIT(5)	// FW in 32k
-#define	RT_RF_PS_LEVEL_ALWAYS_ASPM	BIT(6)	// Always enable ASPM and Clock Req in initialization.
-#define	RT_RF_LPS_DISALBE_2R			BIT(30)	// When LPS is on, disable 2R if no packet is received or transmittd.
-#define	RT_RF_LPS_LEVEL_ASPM			BIT(31)	// LPS with ASPM
+/*  RF Off Level for IPS or HW/SW radio off */
+#define	RT_RF_OFF_LEVL_ASPM			BIT(0)	/*  PCI ASPM */
+#define	RT_RF_OFF_LEVL_CLK_REQ		BIT(1)	/*  PCI clock request */
+#define	RT_RF_OFF_LEVL_PCI_D3			BIT(2)	/*  PCI D3 mode */
+#define	RT_RF_OFF_LEVL_HALT_NIC		BIT(3)	/*  NIC halt, re-initialize hw parameters */
+#define	RT_RF_OFF_LEVL_FREE_FW		BIT(4)	/*  FW free, re-download the FW */
+#define	RT_RF_OFF_LEVL_FW_32K		BIT(5)	/*  FW in 32k */
+#define	RT_RF_PS_LEVEL_ALWAYS_ASPM	BIT(6)	/*  Always enable ASPM and Clock Req in initialization. */
+#define	RT_RF_LPS_DISALBE_2R			BIT(30)	/*  When LPS is on, disable 2R if no packet is received or transmittd. */
+#define	RT_RF_LPS_LEVEL_ASPM			BIT(31)	/*  LPS with ASPM */
 
 #define	RT_IN_PS_LEVEL(ppsc, _PS_FLAG)		((ppsc->cur_ps_level & _PS_FLAG) ? true : false)
 #define	RT_CLEAR_PS_LEVEL(ppsc, _PS_FLAG)	(ppsc->cur_ps_level &= (~(_PS_FLAG)))
@@ -171,7 +171,7 @@ enum _PS_BBRegBackup_ {
 	PSBBREG_TOTALCNT
 };
 
-enum { // for ips_mode
+enum { /*  for ips_mode */
 	IPS_NONE=0,
 	IPS_NORMAL,
 	IPS_LEVEL_2,
@@ -180,27 +180,27 @@ enum { // for ips_mode
 struct pwrctrl_priv
 {
 	struct  semaphore lock;
-	volatile u8 rpwm; // requested power state for fw
-	volatile u8 cpwm; // fw current power state. updated when 1. read from HCPWM 2. driver lowers power level
-	volatile u8 tog; // toggling
-	volatile u8 cpwm_tog; // toggling
+	volatile u8 rpwm; /*  requested power state for fw */
+	volatile u8 cpwm; /*  fw current power state. updated when 1. read from HCPWM 2. driver lowers power level */
+	volatile u8 tog; /*  toggling */
+	volatile u8 cpwm_tog; /*  toggling */
 	u8	pwr_mode;
 	u8	smart_ps;
 	u32 alives;
 
 	u8	b_hw_radio_off;
 	u8	reg_rfoff;
-	u8	reg_pdnmode; //powerdown mode
+	u8	reg_pdnmode; /* powerdown mode */
 	u32	rfoff_reason;
 
-	//RF OFF Level
+	/* RF OFF Level */
 	u32	cur_ps_level;
 	u32	reg_rfps_level;
 	uint	ips_enter_cnts;
 	uint	ips_leave_cnts;
 
 	u8	ips_mode;
-	u8	ips_mode_req; // used to accept the mode setting request, will update to ipsmode later
+	u8	ips_mode_req; /*  used to accept the mode setting request, will update to ipsmode later */
 	uint bips_processing;
 	u32 ips_deny_time; /* will deny IPS when system time is smaller than this */
 	u8 ps_processing; /* temporarily used to mark whether in rtw_ps_processor */
@@ -225,19 +225,18 @@ struct pwrctrl_priv
 	u8		wowlan_unicast;
 	u8		wowlan_pattern_idx;
 	u32		wowlan_pattern_context[8][5];
-#endif // CONFIG_WOWLAN
+#endif /*  CONFIG_WOWLAN */
 	struct timer_list pwr_state_check_timer;
 	int		pwr_state_check_interval;
 	u8		pwr_state_check_cnts;
 
 	int		ps_flag;
 
-	enum rt_rf_power_state	rf_pwrstate;//cur power state
-	//rt_rf_power_state	current_rfpwrstate;
+	enum rt_rf_power_state	rf_pwrstate;/* cur power state */
 	enum rt_rf_power_state	change_rfpwrstate;
 
 	u8		wepkeymask;
-	u8		bHWPowerdown;//if support hw power down
+	u8		bHWPowerdown;/* if support hw power down */
 	u8		bHWPwrPindetect;
 	u8		bkeepfwalive;
 	u8		brfoffbyhw;
@@ -251,7 +250,7 @@ struct pwrctrl_priv
 	#ifdef CONFIG_HAS_EARLYSUSPEND
 	struct early_suspend early_suspend;
 	u8 do_late_resume;
-	#endif //CONFIG_HAS_EARLYSUSPEND
+	#endif /* CONFIG_HAS_EARLYSUSPEND */
 
 	#ifdef CONFIG_ANDROID_POWER
 	android_early_suspend_t early_suspend;
@@ -317,7 +316,7 @@ void rtw_lps_leave(struct rtw_adapter *
 
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
 void rtw_resume_in_workqueue(struct pwrctrl_priv *pwrpriv);
-#endif //CONFIG_RESUME_IN_WORKQUEUE
+#endif /* CONFIG_RESUME_IN_WORKQUEUE */
 
 #if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
 bool rtw_is_earlysuspend_registered(struct pwrctrl_priv *pwrpriv);
@@ -341,4 +340,4 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 int rtw_pm_set_ips(struct rtw_adapter *padapter, u8 mode);
 int rtw_pm_set_lps(struct rtw_adapter *padapter, u8 mode);
 
-#endif  //__RTL871X_PWRCTRL_H_
+#endif  /* __RTL871X_PWRCTRL_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_qos.h
+++ b/drivers/staging/rtl8192du/include/rtw_qos.h
@@ -31,9 +31,9 @@
 
 struct	qos_priv	{
 
-	unsigned int	  qos_option;	//bit mask option: u-apsd, s-apsd, ts, block ack...
+	unsigned int	  qos_option;	/* bit mask option: u-apsd, s-apsd, ts, block ack... */
 
 };
 
 
-#endif	//_RTL871X_QOS_H_
+#endif	/* _RTL871X_QOS_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_recv.h
+++ b/drivers/staging/rtl8192du/include/rtw_recv.h
@@ -41,7 +41,7 @@ static u8 SNAP_ETH_TYPE_IPX[2] = {0x81,
 static u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};
 static u8 SNAP_ETH_TYPE_APPLETALK_DDP[2] = {0x80, 0x9b};
 static u8 SNAP_ETH_TYPE_TDLS[2] = {0x89, 0x0d};
-static u8 SNAP_HDR_APPLETALK_DDP[3] = {0x08, 0x00, 0x07}; // Datagram Delivery Protocol
+static u8 SNAP_HDR_APPLETALK_DDP[3] = {0x08, 0x00, 0x07}; /*  Datagram Delivery Protocol */
 
 static u8 oui_8021h[] = {0x00, 0x00, 0xf8};
 static u8 oui_rfc1042[]= {0x00,0x00,0x00};
@@ -53,12 +53,12 @@ static u8 rtw_rfc1042_header[] =
 static u8 rtw_bridge_tunnel_header[] =
 { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
 
-//for Rx reordering buffer control
+/* for Rx reordering buffer control */
 struct recv_reorder_ctrl
 {
 	struct rtw_adapter	*padapter;
 	u8 enable;
-	u16 indicate_seq;//=wstart_b, init_value=0xffff
+	u16 indicate_seq;/* wstart_b, init_value=0xffff */
 	u16 wend_b;
 	u8 wsize_b;
 	struct __queue pending_recvframe_queue;
@@ -89,17 +89,17 @@ struct	stainfo_rxcache	{
 
 
 struct smooth_rssi_data {
-	u32	elements[100];	//array to store values
-	u32	index;			//index to current array to store
-	u32	total_num;		//num of valid elements
-	u32	total_val;		//sum of valid elements
+	u32	elements[100];	/* array to store values */
+	u32	index;			/* index to current array to store */
+	u32	total_num;		/* num of valid elements */
+	u32	total_val;		/* sum of valid elements */
 };
 
 struct signal_stat {
-	u8	update_req;		//used to indicate
-	u8	avg_val;		//avg of valid elements
-	u32	total_num;		//num of valid elements
-	u32	total_val;		//sum of valid elements
+	u8	update_req;		/* used to indicate */
+	u8	avg_val;		/* avg of valid elements */
+	u32	total_num;		/* num of valid elements */
+	u32	total_val;		/* sum of valid elements */
 };
 
 struct rx_pkt_attrib {
@@ -107,7 +107,7 @@ struct rx_pkt_attrib {
 	u8	physt;
 	u8	drvinfo_sz;
 	u8	shift_sz;
-	u8	hdrlen; //the WLAN Header Len
+	u8	hdrlen; /* the WLAN Header Len */
 	u8	to_fr_ds;
 	u8	amsdu;
 	u8	qos;
@@ -118,9 +118,9 @@ struct rx_pkt_attrib {
 	u8	frag_num;
 	u8	mfrag;
 	u8	order;
-	u8	privacy; //in frame_ctrl field
+	u8	privacy; /* in frame_ctrl field */
 	u8	bdecrypted;
-	u8	encrypt; //when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
+	u8	encrypt; /* when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith */
 	u8	iv_len;
 	u8	icv_len;
 	u8	crc_err;
@@ -136,11 +136,9 @@ struct rx_pkt_attrib {
 
 	u8 ack_policy;
 
-//#ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
-	u8	tcpchk_valid; // 0: invalid, 1: valid
-	u8	ip_chkrpt; //0: incorrect, 1: correct
-	u8	tcp_chkrpt; //0: incorrect, 1: correct
-//#endif
+	u8	tcpchk_valid; /*  0: invalid, 1: valid */
+	u8	ip_chkrpt; /* 0: incorrect, 1: correct */
+	u8	tcp_chkrpt; /* 0: incorrect, 1: correct */
 	u8	key_index;
 
 	u8	mcs_rate;
@@ -149,19 +147,17 @@ struct rx_pkt_attrib {
 	u8	signal_qual;
 	s8	rx_mimo_signal_qual[2];
 	u8	signal_strength;
-	u8	rx_rssi[2];  //This value is percentage
+	u8	rx_rssi[2];  /* This value is percentage */
 	u8	rx_snr[2];
 	u32	RxPWDBAll;
 	s32	RecvSignalPower;
 };
 
 
-//These definition is used for Rx packet reordering.
+/* These definition is used for Rx packet reordering. */
 #define SN_LESS(a, b)		(((a-b)&0x800)!=0)
 #define SN_EQUAL(a, b)	(a == b)
-//#define REORDER_WIN_SIZE	128
-//#define REORDER_ENTRY_NUM	128
-#define REORDER_WAIT_TIME	(50) // (ms)
+#define REORDER_WAIT_TIME	(50) /*  (ms) */
 
 #define RECVBUFF_ALIGN_SZ 8
 
@@ -233,20 +229,20 @@ struct recv_priv {
 #ifdef CONFIG_RX_INDICATE_QUEUE
 	struct task rx_indicate_tasklet;
 	struct ifqueue rx_indicate_queue;
-#endif	// CONFIG_RX_INDICATE_QUEUE
+#endif	/*  CONFIG_RX_INDICATE_QUEUE */
 
 #ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
 	struct __queue recv_buf_pending_queue;
-#endif	// CONFIG_USE_USB_BUFFER_ALLOC_RX
+#endif	/*  CONFIG_USE_USB_BUFFER_ALLOC_RX */
 
 	u8 *pallocated_recv_buf;
-	u8 *precv_buf;    // 4 alignment
+	u8 *precv_buf;    /*  4 alignment */
 	struct __queue free_recv_buf_queue;
 	u32	free_recv_buf_queue_cnt;
 
-	//For display the phy informatiom
-	u8 is_signal_dbg;	// for debug
-	u8 signal_strength_dbg;	// for debug
+	/* For display the phy informatiom */
+	u8 is_signal_dbg;	/*  for debug */
+	u8 signal_strength_dbg;	/*  for debug */
 	s8 rssi;
 	s8 rxpwdb;
 	u8 signal_strength;
@@ -259,13 +255,12 @@ struct recv_priv {
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	struct timer_list signal_stat_timer;
 	u32 signal_stat_sampling_interval;
-	//u32 signal_stat_converging_constant;
 	struct signal_stat signal_qual_data;
 	struct signal_stat signal_strength_data;
-#else //CONFIG_NEW_SIGNAL_STAT_PROCESS
+#else /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 	struct smooth_rssi_data signal_qual_data;
 	struct smooth_rssi_data signal_strength_data;
-#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 	u32 recvbuf_skb_alloc_fail_cnt;
 	u32 recvbuf_null_cnt;
@@ -277,12 +272,12 @@ struct recv_priv {
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 #define rtw_set_signal_stat_timer(recvpriv) _set_timer(&(recvpriv)->signal_stat_timer, (recvpriv)->signal_stat_sampling_interval)
-#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 struct sta_recv_priv {
 	spinlock_t lock;
 	int	option;
-	struct __queue defrag_q;	 //keeping the fragment frame until defrag
+	struct __queue defrag_q;	 /* keeping the fragment frame until defrag */
 	struct	stainfo_rxcache rxcache;
 };
 
@@ -335,10 +330,10 @@ struct recv_frame_hdr
 #ifndef CONFIG_BSD_RX_USE_MBUF
 	struct sk_buff	 *pkt;
 	struct sk_buff	 *pkt_newalloc;
-#else // CONFIG_BSD_RX_USE_MBUF
+#else /*  CONFIG_BSD_RX_USE_MBUF */
 	struct sk_buff *pkt;
 	struct sk_buff *pkt_newalloc;
-#endif // CONFIG_BSD_RX_USE_MBUF
+#endif /*  CONFIG_BSD_RX_USE_MBUF */
 
 	struct rtw_adapter  *adapter;
 
@@ -357,10 +352,10 @@ struct recv_frame_hdr
 	void *precvbuf;
 
 
-	//
+	/*  */
 	struct sta_info *psta;
 
-	//for A-MPDU Rx reordering buffer control
+	/* for A-MPDU Rx reordering buffer control */
 	struct recv_reorder_ctrl *preorder_ctrl;
 
 };
@@ -375,8 +370,8 @@ union recv_frame{
 };
 
 
-extern union recv_frame *_rtw_alloc_recvframe (struct __queue *pfree_recv_queue);  //get a free recv_frame from pfree_recv_queue
-extern union recv_frame *rtw_alloc_recvframe (struct __queue *pfree_recv_queue);  //get a free recv_frame from pfree_recv_queue
+extern union recv_frame *_rtw_alloc_recvframe (struct __queue *pfree_recv_queue);  /* get a free recv_frame from pfree_recv_queue */
+extern union recv_frame *rtw_alloc_recvframe (struct __queue *pfree_recv_queue);  /* get a free recv_frame from pfree_recv_queue */
 extern void rtw_init_recvframe(union recv_frame *precvframe ,struct recv_priv *precvpriv);
 extern int	 rtw_free_recvframe(union recv_frame *precvframe, struct __queue *pfree_recv_queue);
 
@@ -395,7 +390,7 @@ void rtw_reordering_ctrl_timeout_handler
 
 static inline u8 *get_rxmem(union recv_frame *precvframe)
 {
-	//always return rx_head...
+	/* always return rx_head... */
 	if (precvframe==NULL)
 		return NULL;
 
@@ -412,7 +407,7 @@ static inline u8 *get_rx_status(union re
 static inline u8 *get_recvframe_data(union recv_frame *precvframe)
 {
 
-	//alwasy return rx_data
+	/* alwasy return rx_data */
 	if (precvframe==NULL)
 		return NULL;
 
@@ -422,7 +417,7 @@ static inline u8 *get_recvframe_data(uni
 
 static inline u8 *recvframe_push(union recv_frame *precvframe, int sz)
 {
-	// append data before rx_data
+	/*  append data before rx_data */
 
 	/* add data to the start of recv_frame
  *
@@ -450,9 +445,9 @@ static inline u8 *recvframe_push(union r
 
 static inline u8 *recvframe_pull(union recv_frame *precvframe, int sz)
 {
-	// rx_data += sz; move rx_data sz bytes  hereafter
+	/*  rx_data += sz; move rx_data sz bytes  hereafter */
 
-	//used for extract sz bytes from rx_data, update rx_data and return the updated rx_data to the caller
+	/* used for extract sz bytes from rx_data, update rx_data and return the updated rx_data to the caller */
 
 
 	if (precvframe==NULL)
@@ -475,10 +470,10 @@ static inline u8 *recvframe_pull(union r
 
 static inline u8 *recvframe_put(union recv_frame *precvframe, int sz)
 {
-	// rx_tai += sz; move rx_tail sz bytes  hereafter
+	/*  rx_tai += sz; move rx_tail sz bytes  hereafter */
 
-	//used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller
-	//after putting, rx_tail must be still larger than rx_end.
+	/* used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller */
+	/* after putting, rx_tail must be still larger than rx_end. */
 	unsigned char * prev_rx_tail;
 
 	if (precvframe==NULL)
@@ -504,10 +499,10 @@ static inline u8 *recvframe_put(union re
 
 static inline u8 *recvframe_pull_tail(union recv_frame *precvframe, int sz)
 {
-	// rmv data from rx_tail (by yitsen)
+	/*  rmv data from rx_tail (by yitsen) */
 
-	//used for extract sz bytes from rx_end, update rx_end and return the updated rx_end to the caller
-	//after pulling, rx_end must be still larger than rx_data.
+	/* used for extract sz bytes from rx_end, update rx_end and return the updated rx_end to the caller */
+	/* after pulling, rx_end must be still larger than rx_data. */
 
 	if (precvframe==NULL)
 		return NULL;
@@ -540,9 +535,9 @@ static inline unsigned char *get_rxbuf_d
 
 static inline union recv_frame *rxmem_to_recvframe(u8 *rxmem)
 {
-	//due to the design of 2048 bytes alignment of recv_frame, we can reference the union recv_frame
-	//from any given member of recv_frame.
-	// rxmem indicates the any member/address in recv_frame
+	/* due to the design of 2048 bytes alignment of recv_frame, we can reference the union recv_frame */
+	/* from any given member of recv_frame. */
+	/*  rxmem indicates the any member/address in recv_frame */
 
 	return (union recv_frame*)(((SIZE_PTR)rxmem >> RXFRAME_ALIGN) << RXFRAME_ALIGN);
 
@@ -560,7 +555,7 @@ static inline union recv_frame *pkt_to_r
 
 static inline u8 *pkt_to_recvmem(struct sk_buff *pkt)
 {
-	// return the rx_head
+	/*  return the rx_head */
 
 	union recv_frame * precv_frame = pkt_to_recvframe(pkt);
 
@@ -570,7 +565,7 @@ static inline u8 *pkt_to_recvmem(struct
 
 static inline u8 *pkt_to_recvdata(struct sk_buff *pkt)
 {
-	// return the rx_data
+	/*  return the rx_data */
 
 	union recv_frame * precv_frame =pkt_to_recvframe(pkt);
 
@@ -602,9 +597,9 @@ static inline u8 query_rx_pwr_percentage
 
 static inline s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)
 {
-	s32	SignalPower; // in dBm.
+	s32	SignalPower; /*  in dBm. */
 
-	// Translate to dBm (x=0.5y-95).
+	/*  Translate to dBm (x=0.5y-95). */
 	SignalPower = (s32)((SignalStrengthIndex + 1) >> 1);
 	SignalPower -= 95;
 
--- a/drivers/staging/rtl8192du/include/rtw_rf.h
+++ b/drivers/staging/rtl8192du/include/rtw_rf.h
@@ -29,38 +29,37 @@
 
 #define NUMRATES	(13)
 
-// slot time for 11g
+/*  slot time for 11g */
 #define SHORT_SLOT_TIME					9
 #define NON_SHORT_SLOT_TIME				20
 
 #define RTL8711_RF_MAX_SENS 6
 #define RTL8711_RF_DEF_SENS 4
 
-//
-// We now define the following channels as the max channels in each channel plan.
-// 2G, total 14 chnls
-// {1,2,3,4,5,6,7,8,9,10,11,12,13,14}
-// 5G, total 24 chnls
-// {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165}
+/*  */
+/*  We now define the following channels as the max channels in each channel plan. */
+/*  2G, total 14 chnls */
+/*  {1,2,3,4,5,6,7,8,9,10,11,12,13,14} */
+/*  5G, total 24 chnls */
+/*  {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165} */
 #define	MAX_CHANNEL_NUM_2G				14
 #define	MAX_CHANNEL_NUM_5G				24
-#define	MAX_CHANNEL_NUM					38//14+24
+#define	MAX_CHANNEL_NUM					38/* 14+24 */
 
-//#define NUM_REGULATORYS	21
 #define NUM_REGULATORYS	1
 
-//Country codes
+/* Country codes */
 #define USA							0x555320
-#define EUROPE						0x1 //temp, should be provided later
-#define JAPAN						0x2 //temp, should be provided later
+#define EUROPE						0x1 /* temp, should be provided later */
+#define JAPAN						0x2 /* temp, should be provided later */
 
 struct	regulatory_class {
-	u32	starting_freq;					//MHz,
+	u32	starting_freq;					/* MHz, */
 	u8	channel_set[MAX_CHANNEL_NUM];
-	u8	channel_cck_power[MAX_CHANNEL_NUM];//dbm
-	u8	channel_ofdm_power[MAX_CHANNEL_NUM];//dbm
-	u8	txpower_limit;					//dbm
-	u8	channel_spacing;				//MHz
+	u8	channel_cck_power[MAX_CHANNEL_NUM];/* dbm */
+	u8	channel_ofdm_power[MAX_CHANNEL_NUM];/* dbm */
+	u8	txpower_limit;					/* dbm */
+	u8	channel_spacing;				/* MHz */
 	u8	modem;
 };
 
@@ -74,10 +73,10 @@ enum CAPABILITY {
 	cPBCC			= 0x0040,
 	cChannelAgility	= 0x0080,
 	cSpectrumMgnt	= 0x0100,
-	cQos			= 0x0200,	// For HCCA, use with CF-Pollable and CF-PollReq
+	cQos			= 0x0200,	/*  For HCCA, use with CF-Pollable and CF-PollReq */
 	cShortSlotTime	= 0x0400,
 	cAPSD			= 0x0800,
-	cRM				= 0x1000,	// RRM (Radio Request Measurement)
+	cRM				= 0x1000,	/*  RRM (Radio Request Measurement) */
 	cDSSS_OFDM	= 0x2000,
 	cDelayedBA		= 0x4000,
 	cImmediateBA	= 0x8000,
@@ -102,22 +101,22 @@ enum _RTL8712_RF_MIMO_CONFIG_ {
 };
 
 
-// Bandwidth Offset
+/*  Bandwidth Offset */
 #define HAL_PRIME_CHNL_OFFSET_DONT_CARE	0
 #define HAL_PRIME_CHNL_OFFSET_LOWER	1
 #define HAL_PRIME_CHNL_OFFSET_UPPER	2
 
-// Represent Channel Width in HT Capabilities
-//
+/*  Represent Channel Width in HT Capabilities */
+/*  */
 enum HT_CHANNEL_WIDTH {
 	HT_CHANNEL_WIDTH_20 = 0,
 	HT_CHANNEL_WIDTH_40 = 1,
 };
 
-//
-// Represent Extention Channel Offset in HT Capabilities
-// This is available only in 40Mhz mode.
-//
+/*  */
+/*  Represent Extention Channel Offset in HT Capabilities */
+/*  This is available only in 40Mhz mode. */
+/*  */
 enum HT_EXTCHNL_OFFSET {
 	HT_EXTCHNL_OFFSET_NO_EXT = 0,
 	HT_EXTCHNL_OFFSET_UPPER = 1,
@@ -136,15 +135,14 @@ enum RT_RF_TYPE_DEF_E {
 };
 
 enum RF_RADIO_PATH_E {
-	RF_PATH_A = 0,			//Radio Path A
-	RF_PATH_B = 1,			//Radio Path B
-	RF_PATH_C = 2,			//Radio Path C
-	RF_PATH_D = 3,			//Radio Path D
-	//RF_PATH_MAX				//Max RF number 90 support
+	RF_PATH_A = 0,			/* Radio Path A */
+	RF_PATH_B = 1,			/* Radio Path B */
+	RF_PATH_C = 2,			/* Radio Path C */
+	RF_PATH_D = 3,			/* Radio Path D */
 };
 
 u32 rtw_ch2freq(u32 ch);
 u32 rtw_freq2ch(u32 freq);
 
 
-#endif //_RTL8711_RF_H_
+#endif /* _RTL8711_RF_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_security.h
+++ b/drivers/staging/rtl8192du/include/rtw_security.h
@@ -98,79 +98,73 @@ struct RT_PMKID_LIST {
 
 struct security_priv
 {
-	u32	  dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, 8021x and authswitch
-	u32	  dot11PrivacyAlgrthm;	// This specify the privacy for shared auth. algorithm.
+	u32	  dot11AuthAlgrthm;		/*  802.11 auth, could be open, shared, 8021x and authswitch */
+	u32	  dot11PrivacyAlgrthm;	/*  This specify the privacy for shared auth. algorithm. */
 
 	/* WEP */
-	u32	  dot11PrivacyKeyIndex;	// this is only valid for legendary wep, 0~3 for key id. (tx key index)
-	union Keytype dot11DefKey[4];			// this is only valid for def. key
+	u32	  dot11PrivacyKeyIndex;	/*  this is only valid for legendary wep, 0~3 for key id. (tx key index) */
+	union Keytype dot11DefKey[4];			/*  this is only valid for def. key */
 	u32	dot11DefKeylen[4];
 
-	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key
-	u32	dot118021XGrpKeyid;		// key id used for Grp Key (tx key index)
-	union Keytype	dot118021XGrpKey[4];	// 802.1x Group Key, for inx0 and inx1
+	u32 dot118021XGrpPrivacy;	/*  This specify the privacy algthm. used for Grp key */
+	u32	dot118021XGrpKeyid;		/*  key id used for Grp Key (tx key index) */
+	union Keytype	dot118021XGrpKey[4];	/*  802.1x Group Key, for inx0 and inx1 */
 	union Keytype	dot118021XGrptxmickey[4];
 	union Keytype	dot118021XGrprxmickey[4];
-	union pn48		dot11Grptxpn;			// PN48 used for Grp Key xmit.
-	union pn48		dot11Grprxpn;			// PN48 used for Grp Key recv.
+	union pn48		dot11Grptxpn;			/*  PN48 used for Grp Key xmit. */
+	union pn48		dot11Grprxpn;			/*  PN48 used for Grp Key recv. */
 
 #ifdef CONFIG_AP_MODE
-	//extend security capabilities for AP_MODE
-	unsigned int dot8021xalg;//0:disable, 1:psk, 2:802.1x
-	unsigned int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
+	/* extend security capabilities for AP_MODE */
+	unsigned int dot8021xalg;/* 0:disable, 1:psk, 2:802.1x */
+	unsigned int wpa_psk;/* 0:disable, bit(0): WPA, bit(1):WPA2 */
 	unsigned int wpa_group_cipher;
 	unsigned int wpa2_group_cipher;
 	unsigned int wpa_pairwise_cipher;
 	unsigned int wpa2_pairwise_cipher;
 #endif
 
-	u8 wps_ie[MAX_WPS_IE_LEN];//added in assoc req
+	u8 wps_ie[MAX_WPS_IE_LEN];/* added in assoc req */
 	int wps_ie_len;
 
 
 	u8	binstallGrpkey;
 	u8	busetkipkey;
-	//struct timer_list tkip_timer;
 	u8	bcheck_grpkey;
 	u8	bgrpkey_handshake;
 
-	//u8	packet_cnt;//unused, removed
 
-	s32	sw_encrypt;//from registry_priv
-	s32	sw_decrypt;//from registry_priv
+	s32	sw_encrypt;/* from registry_priv */
+	s32	sw_decrypt;/* from registry_priv */
 
-	s32	hw_decrypted;//if the rx packets is hw_decrypted==false, it means the hw has not been ready.
+	s32	hw_decrypted;/* if the rx packets is hw_decrypted==false, it means the hw has not been ready. */
 
 
-	//keeps the auth_type & enc_status from upper layer ioctl(wpa_supplicant or wzc)
-	u32 ndisauthtype;	// NDIS_802_11_AUTHENTICATION_MODE
-	u32 ndisencryptstatus;	// NDIS_802_11_ENCRYPTION_STATUS
+	/* keeps the auth_type & enc_status from upper layer ioctl(wpa_supplicant or wzc) */
+	u32 ndisauthtype;	/*  NDIS_802_11_AUTHENTICATION_MODE */
+	u32 ndisencryptstatus;	/*  NDIS_802_11_ENCRYPTION_STATUS */
 
-	struct wlan_bssid_ex sec_bss;  //for joinbss (h2c buffer) usage
+	struct wlan_bssid_ex sec_bss;  /* for joinbss (h2c buffer) usage */
 
 	struct ndis_802_11_wep ndiswep;
 	u8 assoc_info[600];
-	u8 szofcapability[256]; //for wpa2 usage
-	u8 oidassociation[512]; //for wpa/wpa2 usage
-	u8 authenticator_ie[256];  //store ap security information element
-	u8 supplicant_ie[256];  //store sta security information element
+	u8 szofcapability[256]; /* for wpa2 usage */
+	u8 oidassociation[512]; /* for wpa/wpa2 usage */
+	u8 authenticator_ie[256];  /* store ap security information element */
+	u8 supplicant_ie[256];  /* store sta security information element */
 
 
-	//for tkip countermeasure
+	/* for tkip countermeasure */
 	u32 last_mic_err_time;
 	u8	btkip_countermeasure;
 	u8	btkip_wait_report;
 	u32 btkip_countermeasure_time;
 
-	//---------------------------------------------------------------------------
-	// For WPA2 Pre-Authentication.
-	//---------------------------------------------------------------------------
-	//u8				RegEnablePreAuth;				// Default value: Pre-Authentication enabled or not, from registry "EnablePreAuth". Added by Annie, 2005-11-01.
-	//u8				EnablePreAuthentication;			// Current Value: Pre-Authentication enabled or not.
-	struct RT_PMKID_LIST		PMKIDList[NUM_PMKID_CACHE];	// Renamed from PreAuthKey[NUM_PRE_AUTH_KEY]. Annie, 2006-10-13.
+	/*  */
+	/*  For WPA2 Pre-Authentication. */
+	/*  */
+	struct RT_PMKID_LIST		PMKIDList[NUM_PMKID_CACHE];	/*  Renamed from PreAuthKey[NUM_PRE_AUTH_KEY]. Annie, 2006-10-13. */
 	u8				PMKIDIndex;
-	//u32				PMKIDCount;						// Added by Annie, 2006-10-13.
-	//u8				szCapability[256];				// For WPA2-PSK using zero-config, by Annie, 2005-09-20.
 
 	u8 bWepDefaultKeyIdxSet;
 };
@@ -241,10 +235,10 @@ do{\
 
 struct mic_data
 {
-	u32  K0, K1;         // Key
-	u32  L, R;           // Current state
-	u32  M;              // Message accumulator (single word)
-	u32     nBytesInM;      // # bytes in M
+	u32  K0, K1;         /*  Key */
+	u32  L, R;           /*  Current state */
+	u32  M;              /*  Message accumulator (single word) */
+	u32     nBytesInM;      /*  # bytes in M */
 };
 
 extern const u32 Te0[256];
@@ -398,8 +392,8 @@ int wpa_tdls_ftie_mic(u8 *kck, u8 trans_
 						u8 *mic);
 int tdls_verify_mic(u8 *kck, u8 trans_seq,
 						u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie);
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 void rtw_use_tkipkey_handler(void* FunctionContext);
 
-#endif	//__RTL871X_SECURITY_H_
+#endif	/* __RTL871X_SECURITY_H_ */
--- a/drivers/staging/rtl8192du/include/rtw_tdls.h
+++ b/drivers/staging/rtl8192du/include/rtw_tdls.h
@@ -24,25 +24,25 @@
 
 #ifdef CONFIG_TDLS
 /* TDLS STA state */
-#define	TDLS_STATE_NONE				0x00000000	//default state
+#define	TDLS_STATE_NONE				0x00000000	/* default state */
 #define	TDLS_INITIATOR_STATE			0x10000000
 #define	TDLS_RESPONDER_STATE			0x20000000
 #define	TDLS_LINKED_STATE				0x40000000
 #define	TDLS_CH_SWITCH_ON_STATE		0x01000000
-#define	TDLS_PEER_AT_OFF_STATE		0x02000000	//could send pkt on target ch
+#define	TDLS_PEER_AT_OFF_STATE		0x02000000	/* could send pkt on target ch */
 #define	TDLS_AT_OFF_CH_STATE			0x04000000
-#define	TDLS_CH_SW_INITIATOR_STATE	0x08000000	//avoiding duplicated or unconditional ch. switch rsp.
-#define	TDLS_APSD_CHSW_STATE		0x00100000	//in APSD and want to setup channel switch
-#define	TDLS_PEER_SLEEP_STATE		0x00200000	//peer sta is sleeping
-#define	TDLS_SW_OFF_STATE			0x00400000	//terminate channel swithcing
-#define	TDLS_ALIVE_STATE				0x00010000	//Check if peer sta is alived.
+#define	TDLS_CH_SW_INITIATOR_STATE	0x08000000	/* avoiding duplicated or unconditional ch. switch rsp. */
+#define	TDLS_APSD_CHSW_STATE		0x00100000	/* in APSD and want to setup channel switch */
+#define	TDLS_PEER_SLEEP_STATE		0x00200000	/* peer sta is sleeping */
+#define	TDLS_SW_OFF_STATE			0x00400000	/* terminate channel swithcing */
+#define	TDLS_ALIVE_STATE				0x00010000	/* Check if peer sta is alived. */
 
 #define	TPK_RESEND_COUNT				301
 #define		CH_SWITCH_TIME				10
 #define		CH_SWITCH_TIMEOUT			30
 #define	TDLS_STAY_TIME				500
 #define	TDLS_SIGNAL_THRESH			0x20
-#define	TDLS_WATCHDOG_PERIOD		10	//Periodically sending tdls discovery request in TDLS_WATCHDOG_PERIOD * 2 sec
+#define	TDLS_WATCHDOG_PERIOD		10	/* Periodically sending tdls discovery request in TDLS_WATCHDOG_PERIOD * 2 sec */
 #define	TDLS_ALIVE_TIMER_PH1			5000
 #define	TDLS_ALIVE_TIMER_PH2			2000
 #define	TDLS_STAY_TIME				500
@@ -63,7 +63,7 @@ struct wpa_tdls_ftie {
 	u8 Anonce[WPA_NONCE_LEN]; /* Responder Nonce in TDLS */
 	u8 Snonce[WPA_NONCE_LEN]; /* Initiator Nonce in TDLS */
 	/* followed by optional elements */
-} ;
+};
 
 struct wpa_tdls_lnkid {
 	u8 ie_type; /* Link Identifier IE */
@@ -71,23 +71,24 @@ struct wpa_tdls_lnkid {
 	u8 bssid[ETH_ALEN];
 	u8 init_sta[ETH_ALEN];
 	u8 resp_sta[ETH_ALEN];
-} ;
+};
 
-static u8 TDLS_RSNIE[]={	0x01, 0x00,	//version shall be set to 1
-						0x00, 0x0f, 0xac, 0x07,	//group sipher suite
-						0x01, 0x00,	//pairwise cipher suite count
-						0x00, 0x0f, 0xac, 0x04,	//pairwise cipher suite list; CCMP only
-						0x01, 0x00,	//AKM suite count
-						0x00, 0x0f, 0xac, 0x07,	//TPK Handshake
-						0x00, 0x02,
-						//PMKID shall not be present
-						};
+static u8 TDLS_RSNIE[] = {
+	0x01, 0x00,	/* version shall be set to 1 */
+	0x00, 0x0f, 0xac, 0x07,	/* group sipher suite */
+	0x01, 0x00,	/* pairwise cipher suite count */
+	0x00, 0x0f, 0xac, 0x04,	/* pairwise cipher suite list; CCMP only */
+	0x01, 0x00,	/* AKM suite count */
+	0x00, 0x0f, 0xac, 0x07,	/* TPK Handshake */
+	0x00, 0x02,
+	/* PMKID shall not be present */
+};
 
-static u8 TDLS_WMMIE[]={0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};	//Qos info all set zero
+static u8 TDLS_WMMIE[]={0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};	/* Qos info all set zero */
 
-static u8 TDLS_EXT_CAPIE[] = {0x00, 0x00, 0x00, 0x50, 0x20};	//bit(28), bit(30), bit(37)
+static u8 TDLS_EXT_CAPIE[] = {0x00, 0x00, 0x00, 0x50, 0x20};	/* bit(28), bit(30), bit(37) */
 
-//	SRC: Supported Regulatory Classes
+/* 	SRC: Supported Regulatory Classes */
 static u8 TDLS_SRC[] = { 0x01, 0x01, 0x02, 0x03, 0x04, 0x0c, 0x16, 0x17, 0x18, 0x19, 0x1b, 0x1c, 0x1d, 0x1e, 0x20, 0x21 };
 
 void rtw_reset_tdls_info(_adapter* padapter);
@@ -104,7 +105,7 @@ void free_tdls_sta(_adapter *padapter, s
 #ifdef CONFIG_WFD
 void issue_tunneled_probe_req(_adapter *padapter);
 void issue_tunneled_probe_rsp(_adapter *padapter, union recv_frame *precv_frame);
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 void issue_tdls_dis_req(_adapter *padapter, u8 *mac_addr);
 void issue_tdls_setup_req(_adapter *padapter, u8 *mac_addr);
 void issue_tdls_setup_rsp(_adapter *padapter, union recv_frame *precv_frame);
@@ -137,6 +138,6 @@ void rtw_build_tunneled_probe_rsp_ies(_a
 
 int update_sgi_tdls(_adapter *padapter, struct sta_info *psta);
 u32 update_mask_tdls(_adapter *padapter, struct sta_info *psta);
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 #endif
--- a/drivers/staging/rtl8192du/include/rtw_xmit.h
+++ b/drivers/staging/rtl8192du/include/rtw_xmit.h
@@ -24,25 +24,25 @@
 #include <osdep_service.h>
 #include <drv_types.h>
 #ifdef CONFIG_USB_TX_AGGREGATION
-	#define MAX_XMITBUF_SZ	(20480)	// 20k
+	#define MAX_XMITBUF_SZ	(20480)	/*  20k */
 #else
 #define MAX_XMITBUF_SZ	(2048)
-#endif //CONFIG_USB_TX_AGGREGATION
+#endif /* CONFIG_USB_TX_AGGREGATION */
 #ifdef CONFIG_SINGLE_XMIT_BUF
 #define NR_XMITBUFF	(1)
 #else
 #define NR_XMITBUFF	(4)
-#endif //CONFIG_SINGLE_XMIT_BUF
+#endif /* CONFIG_SINGLE_XMIT_BUF */
 
 #define XMITBUF_ALIGN_SZ 512
 
-// xmit extension buff defination
+/*  xmit extension buff defination */
 #define MAX_XMIT_EXTBUF_SZ	(1536)
 #ifdef CONFIG_SINGLE_XMIT_BUF
 #define NR_XMIT_EXTBUFF	(1)
 #else
 #define NR_XMIT_EXTBUFF	(32)
-#endif //CONFIG_SINGLE_XMIT_BUF
+#endif /* CONFIG_SINGLE_XMIT_BUF */
 
 #define MAX_NUMBLKS		(1)
 
@@ -106,13 +106,13 @@ do{\
 #define PACKET_OFFSET_SZ (8)
 #define TXDESC_OFFSET (TXDESC_SIZE + PACKET_OFFSET_SZ)
 
-//
-//defined for TX DESC Operation
-//
+/*  */
+/* defined for TX DESC Operation */
+/*  */
 
 #define MAX_TID (15)
 
-//OFFSET 0
+/* OFFSET 0 */
 #define OFFSET_SZ	0
 #define OFFSET_SHT	16
 #define BMC		BIT(24)
@@ -120,7 +120,7 @@ do{\
 #define FSG		BIT(27)
 #define OWN		BIT(31)
 
-//OFFSET 4
+/* OFFSET 4 */
 #define PKT_OFFSET_SZ	0
 #define BK		BIT(6)
 #define QSEL_SHT	8
@@ -129,13 +129,13 @@ do{\
 #define PKT_OFFSET_SHT	26
 #define HWPC		BIT(31)
 
-//OFFSET 8
+/* OFFSET 8 */
 #define AGG_EN		BIT(29)
 
-//OFFSET 12
+/* OFFSET 12 */
 #define SEQ_SHT		16
 
-//OFFSET 16
+/* OFFSET 16 */
 #define QoS		BIT(6)
 #define HW_SEQ_EN	BIT(7)
 #define USERATE		BIT(8)
@@ -143,11 +143,11 @@ do{\
 #define DATA_SHORT	BIT(24)
 #define DATA_BW		BIT(25)
 
-//OFFSET 20
+/* OFFSET 20 */
 #define SGI		BIT(6)
 
 struct tx_desc{
-	//DWORD 0
+	/* DWORD 0 */
 	unsigned int txdw0;
 	unsigned int txdw1;
 	unsigned int txdw2;
@@ -169,7 +169,7 @@ struct	hw_xmit	{
 	int	accnt;
 };
 
-//reduce size
+/* reduce size */
 struct pkt_attrib
 {
 	u8	type;
@@ -178,12 +178,12 @@ struct pkt_attrib
 	u8	dhcp_pkt;
 	u16	ether_type;
 	u16	seqnum;
-	u16	pkt_hdrlen;	//the original 802.3 pkt header len
-	u16	hdrlen;		//the WLAN Header Len
-	u32	pktlen;		//the original 802.3 pkt raw_data len (not include ether_hdr data)
+	u16	pkt_hdrlen;	/* the original 802.3 pkt header len */
+	u16	hdrlen;		/* the WLAN Header Len */
+	u32	pktlen;		/* the original 802.3 pkt raw_data len (not include ether_hdr data) */
 	u32	last_txcmdsz;
 	u8	nr_frags;
-	u8	encrypt;	//when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
+	u8	encrypt;	/* when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith */
 	u8	iv_len;
 	u8	icv_len;
 	u8	iv[8];
@@ -191,7 +191,7 @@ struct pkt_attrib
 	u8	priority;
 	u8	ack_policy;
 	u8	mac_id;
-	u8	vcs_mode;	//virtual carrier sense method
+	u8	vcs_mode;	/* virtual carrier sense method */
 	u8	dst[ETH_ALEN];
 	u8	src[ETH_ALEN];
 	u8	ta[ETH_ALEN];
@@ -199,14 +199,14 @@ struct pkt_attrib
 	u8	key_idx;
 	u8	qos_en;
 	u8	ht_en;
-	u8	raid;//rate adpative id
+	u8	raid;/* rate adpative id */
 	u8	bwmode;
-	u8	ch_offset;//PRIME_CHNL_OFFSET
-	u8	sgi;//short GI
-	u8	ampdu_en;//tx ampdu enable
-	u8	mdata;//more data bit
-	u8	pctrl;//per packet txdesc control enable
-	u8	triggered;//for ap mode handling Power Saving sta
+	u8	ch_offset;/* PRIME_CHNL_OFFSET */
+	u8	sgi;/* short GI */
+	u8	ampdu_en;/* tx ampdu enable */
+	u8	mdata;/* more data bit */
+	u8	pctrl;/* per packet txdesc control enable */
+	u8	triggered;/* for ap mode handling Power Saving sta */
 	u8	qsel;
 	u8	eosp;
 	u8	rate;
@@ -273,7 +273,7 @@ struct xmit_buf
 
 	void *priv_data;
 
-	u16 ext_tag; // 0: Normal xmitbuf, 1: extension xmitbuf.
+	u16 ext_tag; /*  0: Normal xmitbuf, 1: extension xmitbuf. */
 	u16 flags;
 	u32 alloc_sz;
 
@@ -301,7 +301,7 @@ struct xmit_frame {
 #endif
 	u8	pkt_offset;
 	u8	EMPktNum;
-	u16	EMPktLen[5];//The max value by HW
+	u16	EMPktLen[5];/* The max value by HW */
 #ifdef CONFIG_XMIT_ACK
 	u8 ack_report;
 #endif
@@ -318,11 +318,11 @@ struct tx_servq {
 struct sta_xmit_priv {
 	spinlock_t lock;
 	int	option;
-	int	apsd_setting;	//When bit mask is on, the associated edca queue supports APSD.
-	struct tx_servq	be_q;			//priority == 0,3
-	struct tx_servq	bk_q;			//priority == 1,2
-	struct tx_servq	vi_q;			//priority == 4,5
-	struct tx_servq	vo_q;			//priority == 6,7
+	int	apsd_setting;	/* When bit mask is on, the associated edca queue supports APSD. */
+	struct tx_servq	be_q;			/* priority == 0,3 */
+	struct tx_servq	bk_q;			/* priority == 1,2 */
+	struct tx_servq	vi_q;			/* priority == 4,5 */
+	struct tx_servq	vo_q;			/* priority == 6,7 */
 	struct list_head legacy_dz;
 	struct list_head apsd;
 	u16 txseq_tid[16];
@@ -332,7 +332,7 @@ struct sta_xmit_priv {
 struct	hw_txqueue	{
 	volatile int	head;
 	volatile int	tail;
-	volatile int	free_sz;	//in units of 64 bytes
+	volatile int	free_sz;	/* in units of 64 bytes */
 	volatile int      free_cmdsz;
 	volatile int	 txsz[8];
 	uint	ff_hwaddr;
@@ -358,17 +358,8 @@ struct	xmit_priv	{
 	u8 *pxmit_frame_buf;
 	uint free_xmitframe_cnt;
 
-	//uint mapping_addr;
-	//uint pkt_sz;
-
 	struct __queue free_xmit_queue;
 
-	//struct	hw_txqueue	be_txqueue;
-	//struct	hw_txqueue	bk_txqueue;
-	//struct	hw_txqueue	vi_txqueue;
-	//struct	hw_txqueue	vo_txqueue;
-	//struct	hw_txqueue	bmc_txqueue;
-
 	uint	frag_len;
 
 	struct rtw_adapter	*adapter;
@@ -376,7 +367,7 @@ struct	xmit_priv	{
 	u8   vcs_setting;
 	u8	vcs;
 	u8	vcs_type;
-	//u16  rts_thresh;
+	/* u16  rts_thresh; */
 
 	u64	tx_bytes;
 	u64	tx_pkts;
@@ -386,10 +377,10 @@ struct	xmit_priv	{
 
 	struct hw_xmit *hwxmits;
 	u8	hwxmit_entry;
-	struct  semaphore tx_retevt;//all tx return event;
-	u8		txirp_cnt;//
+	struct  semaphore tx_retevt;/* all tx return event; */
+	u8		txirp_cnt;/*  */
 	struct tasklet_struct xmit_tasklet;
-	//per AC pending irp
+	/* per AC pending irp */
 	int beq_cnt;
 	int bkq_cnt;
 	int viq_cnt;
@@ -440,7 +431,7 @@ extern u32 rtw_calculate_wlan_pkt_size_b
 extern s32 rtw_xmitframe_coalesce(struct rtw_adapter *padapter, struct sk_buff *pkt, struct xmit_frame *pxmitframe);
 #ifdef CONFIG_TDLS
 s32 rtw_xmit_tdls_coalesce(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe, u8 action);
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 s32 _rtw_init_hw_txqueue(struct hw_txqueue* phw_txqueue, u8 ac_tag);
 void _rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);
 
@@ -472,10 +463,10 @@ u8	qos_acm(u8 acm_mask, u8 priority);
 #ifdef CONFIG_XMIT_ACK
 int rtw_ack_tx_wait(struct xmit_priv *pxmitpriv, u32 timeout_ms);
 void rtw_ack_tx_done(struct xmit_priv *pxmitpriv, int status);
-#endif //CONFIG_XMIT_ACK
+#endif /* CONFIG_XMIT_ACK */
 
 
-//include after declaring struct xmit_buf, in order to avoid warning
+/* include after declaring struct xmit_buf, in order to avoid warning */
 #include <xmit_osdep.h>
 
-#endif	//_RTL871X_XMIT_H_
+#endif	/* _RTL871X_XMIT_H_ */
--- a/drivers/staging/rtl8192du/include/sta_info.h
+++ b/drivers/staging/rtl8192du/include/sta_info.h
@@ -30,17 +30,17 @@
 #define NUM_ACL 16
 
 
-//if mode ==0, then the sta is allowed once the addr is hit.
-//if mode ==1, then the sta is rejected once the addr is non-hit.
+/* if mode ==0, then the sta is allowed once the addr is hit. */
+/* if mode ==1, then the sta is rejected once the addr is non-hit. */
 struct rtw_wlan_acl_node {
         struct list_head list;
         u8       addr[ETH_ALEN];
         u8       valid;
 };
 
-//mode=0, disable
-//mode=1, accept unless in deny list
-//mode=2, deny unless in accept list
+/* mode=0, disable */
+/* mode=1, accept unless in deny list */
+/* mode=2, deny unless in accept list */
 struct wlan_acl_pool {
 	int mode;
 	int num;
@@ -90,12 +90,12 @@ struct TDLS_PeerKey {
 	u8 kck[16]; /* TPK-KCK */
 	u8 tk[16]; /* TPK-TK; only CCMP will be used */
 } ;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 struct sta_info {
 	spinlock_t lock;
-	struct list_head list; //free_sta_queue
-	struct list_head hash_list; //sta_hash
+	struct list_head list; /* free_sta_queue */
+	struct list_head hash_list; /* sta_hash */
 	struct sta_xmit_priv sta_xmitpriv;
 	struct sta_recv_priv sta_recvpriv;
 
@@ -108,13 +108,13 @@ struct sta_info {
 	uint qos_option;
 	u8	hwaddr[ETH_ALEN];
 
-	uint	ieee8021x_blocked;	//0: allowed, 1:blocked
-	uint	dot118021XPrivacy; //aes, tkip...
+	uint	ieee8021x_blocked;	/* 0: allowed, 1:blocked */
+	uint	dot118021XPrivacy; /* aes, tkip... */
 	union Keytype	dot11tkiptxmickey;
 	union Keytype	dot11tkiprxmickey;
 	union Keytype	dot118021x_UncstKey;
-	union pn48		dot11txpn;			// PN48 used for Unicast xmit.
-	union pn48		dot11rxpn;			// PN48 used for Unicast recv.
+	union pn48		dot11txpn;			/*  PN48 used for Unicast xmit. */
+	union pn48		dot11rxpn;			/*  PN48 used for Unicast recv. */
 
 
 	u8	bssrateset[16];
@@ -154,16 +154,15 @@ struct sta_info {
 	struct timer_list alive_timer2;
 	u8 timer_flag;
 	u8 alive_count;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
-	//for A-MPDU TX, ADDBA timeout check
+	/* for A-MPDU TX, ADDBA timeout check */
 	struct timer_list addba_retry_timer;
 
-	//for A-MPDU Rx reordering buffer control
+	/* for A-MPDU Rx reordering buffer control */
 	struct recv_reorder_ctrl recvreorder_ctrl[16];
 
-	//for A-MPDU Tx
-	//unsigned char		ampdu_txen_bitmap;
+	/* for A-MPDU Tx */
 	u16	BA_starting_seqctrl[16];
 
 
@@ -171,14 +170,14 @@ struct sta_info {
 	struct ht_priv	htpriv;
 #endif
 
-	//Notes:
-	//STA_Mode:
-	//curr_network(mlme_priv/security_priv/qos/ht) + sta_info: (STA & AP) CAP/INFO
-	//scan_q: AP CAP/INFO
-
-	//AP_Mode:
-	//curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO
-	//sta_info: (AP & STA) CAP/INFO
+	/* Notes: */
+	/* STA_Mode: */
+	/* curr_network(mlme_priv/security_priv/qos/ht) + sta_info: (STA & AP) CAP/INFO */
+	/* scan_q: AP CAP/INFO */
+
+	/* AP_Mode: */
+	/* curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO */
+	/* sta_info: (AP & STA) CAP/INFO */
 
 #ifdef CONFIG_AP_MODE
 
@@ -193,8 +192,8 @@ struct sta_info {
 	u16 capability;
 	int flags;
 
-	int dot8021xalg;//0:disable, 1:psk, 2:802.1x
-	int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
+	int dot8021xalg;/* 0:disable, 1:psk, 2:802.1x */
+	int wpa_psk;/* 0:disable, bit(0): WPA, bit(1):WPA2 */
 	int wpa_group_cipher;
 	int wpa2_group_cipher;
 	int wpa_pairwise_cipher;
@@ -211,13 +210,13 @@ struct sta_info {
 	u8 no_ht_gf_set;
 	u8 no_ht_set;
 	u8 ht_20mhz_set;
-#endif	// CONFIG_NATIVEAP_MLME
+#endif	/*  CONFIG_NATIVEAP_MLME */
 
 	unsigned int tx_ra_bitmap;
 	u8 qos_info;
 
 	u8 max_sp_len;
-	u8 uapsd_bk;//BIT(0): Delivery enabled, BIT(1): Trigger enabled
+	u8 uapsd_bk;/* BIT(0): Delivery enabled, BIT(1): Trigger enabled */
 	u8 uapsd_be;
 	u8 uapsd_vi;
 	u8 uapsd_vo;
@@ -226,34 +225,33 @@ struct sta_info {
 	unsigned int sleepq_ac_len;
 
 #ifdef CONFIG_P2P
-	//p2p priv data
+	/* p2p priv data */
 	u8 is_p2p_device;
 	u8 p2p_status_code;
 
-	//p2p client info
+	/* p2p client info */
 	u8 dev_addr[ETH_ALEN];
-	//u8 iface_addr[ETH_ALEN];//= hwaddr[ETH_ALEN]
 	u8 dev_cap;
 	u16 config_methods;
 	u8 primary_dev_type[8];
 	u8 num_of_secdev_type;
-	u8 secdev_types_list[32];// 32/8 == 4;
+	u8 secdev_types_list[32];/*  32/8 == 4; */
 	u16 dev_name_len;
 	u8 dev_name[32];
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	u8 under_exist_checking;
 
 	u8 keep_alive_trycnt;
 
-#endif	// CONFIG_AP_MODE
+#endif	/*  CONFIG_AP_MODE */
 
 #ifdef CONFIG_IOCTL_CFG80211
 	u8 *passoc_req;
 	u32 assoc_req_len;
 #endif
 
-	//for DM
+	/* for DM */
 	struct rssi_sta	 rssi_stat;
 
         /* To store the sequence number of received management frame */
@@ -364,9 +362,9 @@ struct	sta_priv {
 	u8 asoc_list_cnt;
 	u8 auth_list_cnt;
 
-	unsigned int auth_to;  //sec, time to expire in authenticating.
-	unsigned int assoc_to; //sec, time to expire before associating.
-	unsigned int expire_to; //sec , time to expire after associated.
+	unsigned int auth_to;  /* sec, time to expire in authenticating. */
+	unsigned int assoc_to; /* sec, time to expire before associating. */
+	unsigned int expire_to; /* sec , time to expire after associated. */
 
 	/* pointers to STA info; based on allocated AID or NULL if AID free
 	 * AID is in the range 1-2007, so sta_aid[0] corresponders to AID 1
@@ -374,8 +372,8 @@ struct	sta_priv {
 	 */
 	struct sta_info *sta_aid[NUM_STA];
 
-	u16 sta_dz_bitmap;//only support 15 stations, staion aid bitmap for sleeping sta.
-	u16 tim_bitmap;//only support 15 stations, aid=0~15 mapping bit0~bit15
+	u16 sta_dz_bitmap;/* only support 15 stations, staion aid bitmap for sleeping sta. */
+	u16 tim_bitmap;/* only support 15 stations, aid=0~15 mapping bit0~bit15 */
 
 	u16 max_num_sta;
 
@@ -418,4 +416,4 @@ extern u32 rtw_init_bcmc_stainfo(struct
 extern struct sta_info* rtw_get_bcmc_stainfo(struct rtw_adapter* padapter);
 extern u8 rtw_access_ctrl(struct rtw_adapter *padapter, u8 *mac_addr);
 
-#endif //_STA_INFO_H_
+#endif /* _STA_INFO_H_ */
--- a/drivers/staging/rtl8192du/include/usb_hal.h
+++ b/drivers/staging/rtl8192du/include/usb_hal.h
@@ -28,7 +28,7 @@ void rtl8192du_set_hal_ops(struct rtw_ad
 #ifdef CONFIG_WOWLAN_MANUAL
 extern int rtw_suspend_toshiba(struct rtw_adapter * Adapter);
 extern int rtw_resume_toshiba(struct rtw_adapter * Adapter);
-#endif // CONFIG_WOWLAN_MANUAL
-#endif //CONFIG_WOWLAN
+#endif /*  CONFIG_WOWLAN_MANUAL */
+#endif /* CONFIG_WOWLAN */
 
-#endif //__USB_HAL_H__
+#endif /* __USB_HAL_H__ */
--- a/drivers/staging/rtl8192du/include/usb_ops.h
+++ b/drivers/staging/rtl8192du/include/usb_ops.h
@@ -35,7 +35,7 @@ enum{
 	VENDOR_READ = 0x01,
 };
 #define ALIGNMENT_UNIT				16
-#define MAX_VENDOR_REQ_CMD_SIZE	254		//8188cu SIE Support
+#define MAX_VENDOR_REQ_CMD_SIZE	254		/* 8188cu SIE Support */
 #define MAX_USB_IO_CTL_SIZE		(MAX_VENDOR_REQ_CMD_SIZE +ALIGNMENT_UNIT)
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
@@ -72,8 +72,6 @@ static inline int rtw_inc_and_chk_contin
 	if ((value=ATOMIC_INC_RETURN(&dvobj->continual_urb_error)) > MAX_CONTINUAL_URB_ERR) {
 		DBG_8192D("[dvobj:%p][ERROR] continual_urb_error:%d > %d\n", dvobj, value, MAX_CONTINUAL_URB_ERR);
 		ret = true;
-	} else {
-		//DBG_8192D("[dvobj:%p] continual_urb_error:%d\n", dvobj, value);
 	}
 	return ret;
 }
@@ -86,4 +84,4 @@ static inline void rtw_reset_continual_u
 	ATOMIC_SET(&dvobj->continual_urb_error, 0);
 }
 
-#endif //__USB_OPS_H_
+#endif /* __USB_OPS_H_ */
--- a/drivers/staging/rtl8192du/include/usb_ops_linux.h
+++ b/drivers/staging/rtl8192du/include/usb_ops_linux.h
@@ -22,8 +22,8 @@
 
 #define VENDOR_CMD_MAX_DATA_LEN	254
 
-#define RTW_USB_CONTROL_MSG_TIMEOUT_TEST	10//ms
-#define RTW_USB_CONTROL_MSG_TIMEOUT	500//ms
+#define RTW_USB_CONTROL_MSG_TIMEOUT_TEST	10/* ms */
+#define RTW_USB_CONTROL_MSG_TIMEOUT	500/* ms */
 
 #if defined(CONFIG_VENDOR_REQ_RETRY) && defined(CONFIG_USB_VENDOR_REQ_MUTEX)
 /* vendor req retry should be in the situation when each vendor req is atomically submitted from others */
@@ -32,7 +32,7 @@
 #define MAX_USBCTRL_VENDORREQ_TIMES	1
 #endif
 
-#define RTW_USB_BULKOUT_TIMEOUT	5000//ms
+#define RTW_USB_BULKOUT_TIMEOUT	5000/* ms */
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)) || (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
 #define _usbctrl_vendorreq_async_callback(urb, regs)	_usbctrl_vendorreq_async_callback(urb)
--- a/drivers/staging/rtl8192du/include/usb_osintf.h
+++ b/drivers/staging/rtl8192du/include/usb_osintf.h
@@ -28,9 +28,6 @@
 #define USBD_HALTED(Status) ((u32)(Status) >> 30 == 3)
 
 
-//uint usb_dvobj_init(_adapter * adapter);
-//void usb_dvobj_deinit(_adapter * adapter);
-
 u8 usbvendorrequest(struct dvobj_priv *pdvobjpriv,
 		    enum RT_USB_BREQUEST brequest,
 		    enum RT_USB_WVALUE wvalue, u8 windex, void *data,
--- a/drivers/staging/rtl8192du/include/usb_vendor_req.h
+++ b/drivers/staging/rtl8192du/include/usb_vendor_req.h
@@ -20,7 +20,7 @@
 #ifndef _USB_VENDOR_REQUEST_H_
 #define _USB_VENDOR_REQUEST_H_
 
-//4	Set/Get Register related wIndex/Data
+/* 4	Set/Get Register related wIndex/Data */
 #define	RT_USB_RESET_MASK_OFF		0
 #define	RT_USB_RESET_MASK_ON		1
 #define	RT_USB_SLEEP_MASK_OFF		0
@@ -28,7 +28,7 @@
 #define	RT_USB_LDO_ON				1
 #define	RT_USB_LDO_OFF				0
 
-//4	Set/Get SYSCLK related	wValue or Data
+/* 4	Set/Get SYSCLK related	wValue or Data */
 #define	RT_USB_SYSCLK_32KHZ		0
 #define	RT_USB_SYSCLK_40MHZ		1
 #define	RT_USB_SYSCLK_60MHZ		2
--- a/drivers/staging/rtl8192du/include/wifi.h
+++ b/drivers/staging/rtl8192du/include/wifi.h
@@ -22,7 +22,6 @@
 
 
 #ifdef BIT
-//#error	"BIT define occurred earlier elsewhere!\n"
 #undef BIT
 #endif
 #define BIT(x)	(1 << (x))
@@ -59,12 +58,12 @@ enum WIFI_FRAME_TYPE {
 	WIFI_MGT_TYPE  =	(0),
 	WIFI_CTRL_TYPE =	(BIT(2)),
 	WIFI_DATA_TYPE =	(BIT(3)),
-	WIFI_QOS_DATA_TYPE	= (BIT(7)|BIT(3)),	//!< QoS Data
+	WIFI_QOS_DATA_TYPE	= (BIT(7)|BIT(3)),	/*  QoS Data */
 };
 
 enum WIFI_FRAME_SUBTYPE {
 
-    // below is for mgt frame
+    /*  below is for mgt frame */
     WIFI_ASSOCREQ       = (0 | WIFI_MGT_TYPE),
     WIFI_ASSOCRSP       = (BIT(4) | WIFI_MGT_TYPE),
     WIFI_REASSOCREQ     = (BIT(5) | WIFI_MGT_TYPE),
@@ -78,7 +77,7 @@ enum WIFI_FRAME_SUBTYPE {
     WIFI_DEAUTH         = (BIT(7) | BIT(6) | WIFI_MGT_TYPE),
     WIFI_ACTION         = (BIT(7) | BIT(6) | BIT(4) | WIFI_MGT_TYPE),
 
-    // below is for control frame
+    /*  below is for control frame */
     WIFI_PSPOLL         = (BIT(7) | BIT(5) | WIFI_CTRL_TYPE),
     WIFI_RTS            = (BIT(7) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
     WIFI_CTS            = (BIT(7) | BIT(6) | WIFI_CTRL_TYPE),
@@ -86,7 +85,7 @@ enum WIFI_FRAME_SUBTYPE {
     WIFI_CFEND          = (BIT(7) | BIT(6) | BIT(5) | WIFI_CTRL_TYPE),
     WIFI_CFEND_CFACK    = (BIT(7) | BIT(6) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
 
-    // below is for data frame
+    /*  below is for data frame */
     WIFI_DATA           = (0 | WIFI_DATA_TYPE),
     WIFI_DATA_CFACK     = (BIT(4) | WIFI_DATA_TYPE),
     WIFI_DATA_CFPOLL    = (BIT(5) | WIFI_DATA_TYPE),
@@ -110,7 +109,7 @@ enum WIFI_REASON_CODE	{
 	_RSON_DISAOC_STA_LEAVING_		= 8,
 	_RSON_ASOC_NOT_AUTH_			= 9,
 
-	// WPA reason
+	/*  WPA reason */
 	_RSON_INVALID_IE_				= 13,
 	_RSON_MIC_FAILURE_				= 14,
 	_RSON_4WAY_HNDSHK_TIMEOUT_		= 15,
@@ -123,7 +122,7 @@ enum WIFI_REASON_CODE	{
 	_RSON_INVALID_RSNE_CAP_			= 22,
 	_RSON_IEEE_802DOT1X_AUTH_FAIL_	= 23,
 
-	//belowing are Realtek definition
+	/* belowing are Realtek definition */
 	_RSON_PMK_NOT_AVAILABLE_		= 24,
 	_RSON_TDLS_TEAR_TOOFAR_			= 25,
 	_RSON_TDLS_TEAR_UN_RSN_			= 26,
@@ -182,7 +181,7 @@ enum WIFI_STATUS_CODE {
 #define WLAN_STATUS_AUTH_TIMEOUT 16
 #define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
 #define WLAN_STATUS_ASSOC_DENIED_RATES 18
-//entended
+/* entended */
 /* IEEE 802.11b */
 #define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
 #define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
@@ -433,16 +432,16 @@ __inline static unsigned char * get_da(u
 	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
 
 	switch (to_fr_ds) {
-		case 0x00:	// ToDs=0, FromDs=0
+		case 0x00:	/*  ToDs=0, FromDs=0 */
 			da = GetAddr1Ptr(pframe);
 			break;
-		case 0x01:	// ToDs=0, FromDs=1
+		case 0x01:	/*  ToDs=0, FromDs=1 */
 			da = GetAddr1Ptr(pframe);
 			break;
-		case 0x02:	// ToDs=1, FromDs=0
+		case 0x02:	/*  ToDs=1, FromDs=0 */
 			da = GetAddr3Ptr(pframe);
 			break;
-		default:	// ToDs=1, FromDs=1
+		default:	/*  ToDs=1, FromDs=1 */
 			da = GetAddr3Ptr(pframe);
 			break;
 	}
@@ -457,16 +456,16 @@ __inline static unsigned char * get_sa(u
 	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
 
 	switch (to_fr_ds) {
-		case 0x00:	// ToDs=0, FromDs=0
+		case 0x00:	/*  ToDs=0, FromDs=0 */
 			sa = GetAddr2Ptr(pframe);
 			break;
-		case 0x01:	// ToDs=0, FromDs=1
+		case 0x01:	/*  ToDs=0, FromDs=1 */
 			sa = GetAddr3Ptr(pframe);
 			break;
-		case 0x02:	// ToDs=1, FromDs=0
+		case 0x02:	/*  ToDs=1, FromDs=0 */
 			sa = GetAddr2Ptr(pframe);
 			break;
-		default:	// ToDs=1, FromDs=1
+		default:	/*  ToDs=1, FromDs=1 */
 			sa = GetAddr4Ptr(pframe);
 			break;
 	}
@@ -480,20 +479,20 @@ __inline static unsigned char * get_hdr_
 	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
 
 	switch (to_fr_ds) {
-		case 0x00:	// ToDs=0, FromDs=0
+		case 0x00:	/*  ToDs=0, FromDs=0 */
 			sa = GetAddr3Ptr(pframe);
 			break;
-		case 0x01:	// ToDs=0, FromDs=1
+		case 0x01:	/*  ToDs=0, FromDs=1 */
 			sa = GetAddr2Ptr(pframe);
 			break;
-		case 0x02:	// ToDs=1, FromDs=0
+		case 0x02:	/*  ToDs=1, FromDs=0 */
 			sa = GetAddr1Ptr(pframe);
 			break;
-		case 0x03:	// ToDs=1, FromDs=1
+		case 0x03:	/*  ToDs=1, FromDs=1 */
 			sa = GetAddr1Ptr(pframe);
 			break;
 		default:
-			sa =NULL; //???????
+			sa =NULL; /*  */
 			break;
 	}
 
@@ -520,10 +519,10 @@ __inline static int IsFrameTypeCtrl(unsi
 #define _PRE_ALLOCMICHDR_		6
 
 #define _SIFSTIME_				((priv->pmib->dot11BssType.net_work_type&WIRELESS_11A)?16:10)
-#define _ACKCTSLNG_				14	//14 bytes long, including crclng
+#define _ACKCTSLNG_				14	/* 14 bytes long, including crclng */
 #define _CRCLNG_				4
 
-#define _ASOCREQ_IE_OFFSET_		4	// excluding wlan_hdr
+#define _ASOCREQ_IE_OFFSET_		4	/*  excluding wlan_hdr */
 #define	_ASOCRSP_IE_OFFSET_		6
 #define _REASOCREQ_IE_OFFSET_	10
 #define _REASOCRSP_IE_OFFSET_	6
@@ -545,7 +544,7 @@ __inline static int IsFrameTypeCtrl(unsi
 #define _CHLGETXT_IE_			16
 #define _POW_CAP_IE_			33
 #define _SUPPORTED_CH_IE_		36
-#define _CH_SWTICH_ANNOUNCE_	37	//Secondary Channel Offset
+#define _CH_SWTICH_ANNOUNCE_	37	/* Secondary Channel Offset */
 #define _RSN_IE_2_				48
 #define _SSN_IE_1_					221
 #define _ERPINFO_IE_			42
@@ -556,9 +555,9 @@ __inline static int IsFrameTypeCtrl(unsi
 #define _TIMEOUT_ITVL_IE_			56
 #define _SRC_IE_				59
 #define _HT_EXTRA_INFO_IE_			61
-#define _HT_ADD_INFO_IE_			61 //_HT_EXTRA_INFO_IE_
+#define _HT_ADD_INFO_IE_			61 /* _HT_EXTRA_INFO_IE_ */
 
-#define	EID_BSSCoexistence			72 // 20/40 BSS Coexistence
+#define	EID_BSSCoexistence			72 /*  20/40 BSS Coexistence */
 #define	EID_BSSIntolerantChlReport	73
 #define _RIC_Descriptor_IE_			75
 
@@ -606,23 +605,13 @@ __inline static int IsFrameTypeCtrl(unsi
 /*-----------------------------------------------------------------------------
 				Below is the definition for 802.11i / 802.1x
 ------------------------------------------------------------------------------*/
-#define _IEEE8021X_MGT_			1		// WPA
-#define _IEEE8021X_PSK_			2		// WPA with pre-shared key
-
-/*
-#define _NO_PRIVACY_			0
-#define _WEP_40_PRIVACY_		1
-#define _TKIP_PRIVACY_			2
-#define _WRAP_PRIVACY_			3
-#define _CCMP_PRIVACY_			4
-#define _WEP_104_PRIVACY_		5
-#define _WEP_WPA_MIXED_PRIVACY_ 6	// WEP + WPA
-*/
+#define _IEEE8021X_MGT_			1		/*  WPA */
+#define _IEEE8021X_PSK_			2		/*  WPA with pre-shared key */
 
 /*-----------------------------------------------------------------------------
 				Below is the definition for WMM
 ------------------------------------------------------------------------------*/
-#define _WMM_IE_Length_				7  // for WMM STA
+#define _WMM_IE_Length_				7  /*  for WMM STA */
 #define _WMM_Para_Element_Length_		24
 
 
@@ -637,7 +626,7 @@ __inline static int IsFrameTypeCtrl(unsi
 #define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
 #define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
 
-//#ifdef CONFIG_80211N_HT
+/* ifdef CONFIG_80211N_HT */
 
 #define SetOrderBit(pbuf)	\
 	do	{	\
@@ -828,12 +817,12 @@ struct ADDBA_request
 
 
 
-//#endif
+/* endif */
 
-//	===============WPS Section===============
-//	For WPSv1.0
+/* 	===============WPS Section=============== */
+/* 	For WPSv1.0 */
 #define WPSOUI							0x0050f204
-//	WPS attribute ID
+/* 	WPS attribute ID */
 #define WPS_ATTR_VER1					0x104A
 #define WPS_ATTR_SIMPLE_CONF_STATE	0x1044
 #define WPS_ATTR_RESP_TYPE			0x103B
@@ -854,29 +843,29 @@ struct ADDBA_request
 #define WPS_ATTR_VENDOR_EXT			0x1049
 #define WPS_ATTR_SELECTED_REGISTRAR	0x1041
 
-//	Value of WPS attribute "WPS_ATTR_DEVICE_NAME
+/* 	Value of WPS attribute "WPS_ATTR_DEVICE_NAME */
 #define WPS_MAX_DEVICE_NAME_LEN		32
 
-//	Value of WPS Request Type Attribute
+/* 	Value of WPS Request Type Attribute */
 #define WPS_REQ_TYPE_ENROLLEE_INFO_ONLY			0x00
 #define WPS_REQ_TYPE_ENROLLEE_OPEN_8021X		0x01
 #define WPS_REQ_TYPE_REGISTRAR					0x02
 #define WPS_REQ_TYPE_WLAN_MANAGER_REGISTRAR	0x03
 
-//	Value of WPS Response Type Attribute
+/* 	Value of WPS Response Type Attribute */
 #define WPS_RESPONSE_TYPE_INFO_ONLY	0x00
 #define WPS_RESPONSE_TYPE_8021X		0x01
 #define WPS_RESPONSE_TYPE_REGISTRAR	0x02
 #define WPS_RESPONSE_TYPE_AP			0x03
 
-//	Value of WPS WiFi Simple Configuration State Attribute
+/* 	Value of WPS WiFi Simple Configuration State Attribute */
 #define WPS_WSC_STATE_NOT_CONFIG	0x01
 #define WPS_WSC_STATE_CONFIG			0x02
 
-//	Value of WPS Version Attribute
+/* 	Value of WPS Version Attribute */
 #define WPS_VERSION_1					0x10
 
-//	Value of WPS Configuration Method Attribute
+/* 	Value of WPS Configuration Method Attribute */
 #define WPS_CONFIG_METHOD_FLASH		0x0001
 #define WPS_CONFIG_METHOD_ETHERNET	0x0002
 #define WPS_CONFIG_METHOD_LABEL		0x0004
@@ -891,16 +880,16 @@ struct ADDBA_request
 #define WPS_CONFIG_METHOD_VDISPLAY	0x2008
 #define WPS_CONFIG_METHOD_PDISPLAY	0x4008
 
-//	Value of Category ID of WPS Primary Device Type Attribute
+/* 	Value of Category ID of WPS Primary Device Type Attribute */
 #define WPS_PDT_CID_DISPLAYS			0x0007
 #define WPS_PDT_CID_MULIT_MEDIA		0x0008
 #define WPS_PDT_CID_RTK_WIDI			WPS_PDT_CID_MULIT_MEDIA
 
-//	Value of Sub Category ID of WPS Primary Device Type Attribute
+/* 	Value of Sub Category ID of WPS Primary Device Type Attribute */
 #define WPS_PDT_SCID_MEDIA_SERVER	0x0005
 #define WPS_PDT_SCID_RTK_DMP			WPS_PDT_SCID_MEDIA_SERVER
 
-//	Value of Device Password ID
+/* 	Value of Device Password ID */
 #define WPS_DPID_PIN					0x0000
 #define WPS_DPID_USER_SPEC			0x0001
 #define WPS_DPID_MACHINE_SPEC			0x0002
@@ -908,22 +897,22 @@ struct ADDBA_request
 #define WPS_DPID_PBC					0x0004
 #define WPS_DPID_REGISTRAR_SPEC		0x0005
 
-//	Value of WPS RF Bands Attribute
+/* 	Value of WPS RF Bands Attribute */
 #define WPS_RF_BANDS_2_4_GHZ		0x01
 #define WPS_RF_BANDS_5_GHZ		0x02
 
-//	Value of WPS Association State Attribute
+/* 	Value of WPS Association State Attribute */
 #define WPS_ASSOC_STATE_NOT_ASSOCIATED			0x00
 #define WPS_ASSOC_STATE_CONNECTION_SUCCESS		0x01
 #define WPS_ASSOC_STATE_CONFIGURATION_FAILURE	0x02
 #define WPS_ASSOC_STATE_ASSOCIATION_FAILURE		0x03
 #define WPS_ASSOC_STATE_IP_FAILURE				0x04
 
-//	=====================P2P Section=====================
-//	For P2P
+/* 	=====================P2P Section===================== */
+/* 	For P2P */
 #define	P2POUI							0x506F9A09
 
-//	P2P Attribute ID
+/* 	P2P Attribute ID */
 #define	P2P_ATTR_STATUS					0x00
 #define	P2P_ATTR_MINOR_REASON_CODE		0x01
 #define	P2P_ATTR_CAPABILITY				0x02
@@ -944,7 +933,7 @@ struct ADDBA_request
 #define	P2P_ATTR_OPERATING_CH			0x11
 #define	P2P_ATTR_INVITATION_FLAGS		0x12
 
-//	Value of Status Attribute
+/* 	Value of Status Attribute */
 #define	P2P_STATUS_SUCCESS						0x00
 #define	P2P_STATUS_FAIL_INFO_UNAVAILABLE		0x01
 #define	P2P_STATUS_FAIL_INCOMPATIBLE_PARAM		0x02
@@ -958,7 +947,7 @@ struct ADDBA_request
 #define	P2P_STATUS_FAIL_INCOMPATIBLE_PROVSION	0x0A
 #define	P2P_STATUS_FAIL_USER_REJECT				0x0B
 
-//	Value of Inviation Flags Attribute
+/* 	Value of Inviation Flags Attribute */
 #define	P2P_INVITATION_FLAGS_PERSISTENT			BIT(0)
 
 #define	DMP_P2P_DEVCAP_SUPPORT	(P2P_DEVCAP_SERVICE_DISCOVERY | \
@@ -968,7 +957,7 @@ struct ADDBA_request
 
 #define	DMP_P2P_GRPCAP_SUPPORT	(P2P_GRPCAP_INTRABSS)
 
-//	Value of Device Capability Bitmap
+/* 	Value of Device Capability Bitmap */
 #define	P2P_DEVCAP_SERVICE_DISCOVERY		BIT(0)
 #define	P2P_DEVCAP_CLIENT_DISCOVERABILITY	BIT(1)
 #define	P2P_DEVCAP_CONCURRENT_OPERATION	BIT(2)
@@ -976,7 +965,7 @@ struct ADDBA_request
 #define	P2P_DEVCAP_DEVICE_LIMIT				BIT(4)
 #define	P2P_DEVCAP_INVITATION_PROC			BIT(5)
 
-//	Value of Group Capability Bitmap
+/* 	Value of Group Capability Bitmap */
 #define	P2P_GRPCAP_GO							BIT(0)
 #define	P2P_GRPCAP_PERSISTENT_GROUP			BIT(1)
 #define	P2P_GRPCAP_GROUP_LIMIT				BIT(2)
@@ -985,10 +974,10 @@ struct ADDBA_request
 #define	P2P_GRPCAP_PERSISTENT_RECONN		BIT(5)
 #define	P2P_GRPCAP_GROUP_FORMATION			BIT(6)
 
-//	P2P Public Action Frame (Management Frame)
+/* 	P2P Public Action Frame (Management Frame) */
 #define	P2P_PUB_ACTION_ACTION				0x09
 
-//	P2P Public Action Frame Type
+/* 	P2P Public Action Frame Type */
 #define	P2P_GO_NEGO_REQ						0
 #define	P2P_GO_NEGO_RESP						1
 #define	P2P_GO_NEGO_CONF						2
@@ -999,7 +988,7 @@ struct ADDBA_request
 #define	P2P_PROVISION_DISC_REQ				7
 #define	P2P_PROVISION_DISC_RESP				8
 
-//	P2P Action Frame Type
+/* 	P2P Action Frame Type */
 #define	P2P_NOTICE_OF_ABSENCE	0
 #define	P2P_PRESENCE_REQUEST		1
 #define	P2P_PRESENCE_RESPONSE	2
@@ -1012,25 +1001,25 @@ struct ADDBA_request
 
 #define	P2P_WILDCARD_SSID_LEN				7
 
-#define	P2P_FINDPHASE_EX_NONE				0	// default value, used when: (1)p2p disabed or (2)p2p enabled but only do 1 scan phase
-#define	P2P_FINDPHASE_EX_FULL				1	// used when p2p enabled and want to do 1 scan phase and P2P_FINDPHASE_EX_MAX-1 find phase
+#define	P2P_FINDPHASE_EX_NONE				0	/*  default value, used when: (1)p2p disabed or (2)p2p enabled but only do 1 scan phase */
+#define	P2P_FINDPHASE_EX_FULL				1	/*  used when p2p enabled and want to do 1 scan phase and P2P_FINDPHASE_EX_MAX-1 find phase */
 #define	P2P_FINDPHASE_EX_SOCIAL_FIRST		(P2P_FINDPHASE_EX_FULL+1)
 #define	P2P_FINDPHASE_EX_MAX					4
 #define	P2P_FINDPHASE_EX_SOCIAL_LAST		P2P_FINDPHASE_EX_MAX
 
-#define	P2P_PROVISION_TIMEOUT				5000	//	5 seconds timeout for sending the provision discovery request
-#define	P2P_CONCURRENT_PROVISION_TIMEOUT	3000	//	3 seconds timeout for sending the provision discovery request under concurrent mode
-#define	P2P_GO_NEGO_TIMEOUT					5000	//	5 seconds timeout for receiving the group negotation response
-#define	P2P_CONCURRENT_GO_NEGO_TIMEOUT		3000	//	3 seconds timeout for sending the negotiation request under concurrent mode
-#define	P2P_TX_PRESCAN_TIMEOUT				100		//	100ms
-#define	P2P_INVITE_TIMEOUT					5000	//	5 seconds timeout for sending the invitation request
-#define	P2P_CONCURRENT_INVITE_TIMEOUT		3000	//	3 seconds timeout for sending the invitation request under concurrent mode
-#define	P2P_RESET_SCAN_CH						15000	//	15 seconds timeout to reset the scan channel (based on channel plan)
+#define	P2P_PROVISION_TIMEOUT				5000	/* 	5 seconds timeout for sending the provision discovery request */
+#define	P2P_CONCURRENT_PROVISION_TIMEOUT	3000	/* 	3 seconds timeout for sending the provision discovery request under concurrent mode */
+#define	P2P_GO_NEGO_TIMEOUT					5000	/* 	5 seconds timeout for receiving the group negotation response */
+#define	P2P_CONCURRENT_GO_NEGO_TIMEOUT		3000	/* 	3 seconds timeout for sending the negotiation request under concurrent mode */
+#define	P2P_TX_PRESCAN_TIMEOUT				100		/* 	100ms */
+#define	P2P_INVITE_TIMEOUT					5000	/* 	5 seconds timeout for sending the invitation request */
+#define	P2P_CONCURRENT_INVITE_TIMEOUT		3000	/* 	3 seconds timeout for sending the invitation request under concurrent mode */
+#define	P2P_RESET_SCAN_CH						15000	/* 	15 seconds timeout to reset the scan channel (based on channel plan) */
 #define	P2P_MAX_INTENT						15
 
 #define	P2P_MAX_NOA_NUM						2
 
-//	WPS Configuration Method
+/* 	WPS Configuration Method */
 #define	WPS_CM_NONE							0x0000
 #define	WPS_CM_LABEL							0x0004
 #define	WPS_CM_DISPLYA						0x0008
@@ -1052,29 +1041,29 @@ enum P2P_ROLE {
 };
 
 enum P2P_STATE {
-	P2P_STATE_NONE = 0,							//	P2P disable
-	P2P_STATE_IDLE = 1,								//	P2P had enabled and do nothing
-	P2P_STATE_LISTEN = 2,							//	In pure listen state
-	P2P_STATE_SCAN = 3,							//	In scan phase
-	P2P_STATE_FIND_PHASE_LISTEN = 4,				//	In the listen state of find phase
-	P2P_STATE_FIND_PHASE_SEARCH = 5,				//	In the search state of find phase
-	P2P_STATE_TX_PROVISION_DIS_REQ = 6,			//	In P2P provisioning discovery
+	P2P_STATE_NONE = 0,							/* 	P2P disable */
+	P2P_STATE_IDLE = 1,								/* 	P2P had enabled and do nothing */
+	P2P_STATE_LISTEN = 2,							/* 	In pure listen state */
+	P2P_STATE_SCAN = 3,							/* 	In scan phase */
+	P2P_STATE_FIND_PHASE_LISTEN = 4,				/* 	In the listen state of find phase */
+	P2P_STATE_FIND_PHASE_SEARCH = 5,				/* 	In the search state of find phase */
+	P2P_STATE_TX_PROVISION_DIS_REQ = 6,			/* 	In P2P provisioning discovery */
 	P2P_STATE_RX_PROVISION_DIS_RSP = 7,
 	P2P_STATE_RX_PROVISION_DIS_REQ = 8,
-	P2P_STATE_GONEGO_ING = 9,						//	Doing the group owner negoitation handshake
-	P2P_STATE_GONEGO_OK = 10,						//	finish the group negoitation handshake with success
-	P2P_STATE_GONEGO_FAIL = 11,					//	finish the group negoitation handshake with failure
-	P2P_STATE_RECV_INVITE_REQ_MATCH = 12,		//	receiving the P2P Inviation request and match with the profile.
-	P2P_STATE_PROVISIONING_ING = 13,				//	Doing the P2P WPS
-	P2P_STATE_PROVISIONING_DONE = 14,			//	Finish the P2P WPS
-	P2P_STATE_TX_INVITE_REQ = 15,					//	Transmit the P2P Invitation request
-	P2P_STATE_RX_INVITE_RESP_OK = 16,				//	Receiving the P2P Invitation response with sucess
-	P2P_STATE_RECV_INVITE_REQ_DISMATCH = 17,	//	receiving the P2P Inviation request and dismatch with the profile.
-	P2P_STATE_RECV_INVITE_REQ_GO = 18,			//	receiving the P2P Inviation request and this wifi is GO.
-	P2P_STATE_RECV_INVITE_REQ_JOIN = 19,			//	receiving the P2P Inviation request to join an existing P2P Group.
-	P2P_STATE_RX_INVITE_RESP_FAIL = 20,			//	recveing the P2P Inviation response with failure
-	P2P_STATE_RX_INFOR_NOREADY = 21,			// receiving p2p negoitation response with information is not available
-	P2P_STATE_TX_INFOR_NOREADY = 22,			// sending p2p negoitation response with information is not available
+	P2P_STATE_GONEGO_ING = 9,						/* 	Doing the group owner negoitation handshake */
+	P2P_STATE_GONEGO_OK = 10,						/* 	finish the group negoitation handshake with success */
+	P2P_STATE_GONEGO_FAIL = 11,					/* 	finish the group negoitation handshake with failure */
+	P2P_STATE_RECV_INVITE_REQ_MATCH = 12,		/* 	receiving the P2P Inviation request and match with the profile. */
+	P2P_STATE_PROVISIONING_ING = 13,				/* 	Doing the P2P WPS */
+	P2P_STATE_PROVISIONING_DONE = 14,			/* 	Finish the P2P WPS */
+	P2P_STATE_TX_INVITE_REQ = 15,					/* 	Transmit the P2P Invitation request */
+	P2P_STATE_RX_INVITE_RESP_OK = 16,				/* 	Receiving the P2P Invitation response with sucess */
+	P2P_STATE_RECV_INVITE_REQ_DISMATCH = 17,	/* 	receiving the P2P Inviation request and dismatch with the profile. */
+	P2P_STATE_RECV_INVITE_REQ_GO = 18,			/* 	receiving the P2P Inviation request and this wifi is GO. */
+	P2P_STATE_RECV_INVITE_REQ_JOIN = 19,			/* 	receiving the P2P Inviation request to join an existing P2P Group. */
+	P2P_STATE_RX_INVITE_RESP_FAIL = 20,			/* 	recveing the P2P Inviation response with failure */
+	P2P_STATE_RX_INFOR_NOREADY = 21,			/*  receiving p2p negoitation response with information is not available */
+	P2P_STATE_TX_INFOR_NOREADY = 22,			/*  sending p2p negoitation response with information is not available */
 };
 
 enum P2P_WPSINFO {
@@ -1104,7 +1093,7 @@ enum P2P_PS_STATE
 	P2P_PS_ENABLE = 1,
 	P2P_PS_SCAN = 2,
 	P2P_PS_SCAN_DONE = 3,
-	P2P_PS_ALLSTASLEEP = 4, // for P2P GO
+	P2P_PS_ALLSTASLEEP = 4, /*  for P2P GO */
 };
 
 enum P2P_PS_MODE
@@ -1112,12 +1101,12 @@ enum P2P_PS_MODE
 	P2P_PS_NONE = 0,
 	P2P_PS_CTWINDOW = 1,
 	P2P_PS_NOA	 = 2,
-	P2P_PS_MIX = 3, // CTWindow and NoA
+	P2P_PS_MIX = 3, /*  CTWindow and NoA */
 };
-#endif // CONFIG_P2P_PS
+#endif /*  CONFIG_P2P_PS */
 
-//	=====================WFD Section=====================
-//	For Wi-Fi Display
+/* 	=====================WFD Section===================== */
+/* 	For Wi-Fi Display */
 #define	WFD_ATTR_DEVICE_INFO			0x00
 #define	WFD_ATTR_ASSOC_BSSID			0x01
 #define	WFD_ATTR_COUPLED_SINK_INFO	0x06
@@ -1125,7 +1114,7 @@ enum P2P_PS_MODE
 #define	WFD_ATTR_SESSION_INFO		0x09
 #define	WFD_ATTR_ALTER_MAC			0x0a
 
-//	For WFD Device Information Attribute
+/* 	For WFD Device Information Attribute */
 #define	WFD_DEVINFO_SOURCE					0x0000
 #define	WFD_DEVINFO_PSINK					0x0001
 #define	WFD_DEVINFO_SSINK					0x0002
@@ -1140,4 +1129,4 @@ enum P2P_PS_MODE
 #define ICMPV6_MCAST_MAC(mac)	((mac[0]==0x33)&&(mac[1]==0x33)&&(mac[2]!=0xff))
 extern unsigned char REALTEK_96B_IE[6];
 
-#endif // _WIFI_H_
+#endif /*  _WIFI_H_ */
--- a/drivers/staging/rtl8192du/include/wlan_bssdef.h
+++ b/drivers/staging/rtl8192du/include/wlan_bssdef.h
@@ -27,8 +27,6 @@
 #define NDIS_802_11_LENGTH_RATES        8
 #define NDIS_802_11_LENGTH_RATES_EX     16
 
-//typedef unsigned char   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates
-
 struct ndis_802_11_ssid {
 	u32  SsidLength;
 	u8  Ssid[32];
@@ -39,14 +37,14 @@ enum NDIS_802_11_NETWORK_TYPE {
 	NDIS802_11DS,
 	NDIS802_11OFDM5,
 	NDIS802_11OFDM24,
-	NDIS802_11NetworkTypeMax    // not a real type - upper bound
+	NDIS802_11NetworkTypeMax    /*  not a real type - upper bound */
 };
 
 struct ndis_802_11_config_fh {
-    u32           Length;             // Length of structure
-    u32           HopPattern;         // As defined by 802.11, MSB set
-    u32           HopSet;             // to one if non-802.11
-    u32           DwellTime;          // units are Kusec
+    u32           Length;             /*  Length of structure */
+    u32           HopPattern;         /*  As defined by 802.11, MSB set */
+    u32           HopSet;             /*  to one if non-802.11 */
+    u32           DwellTime;          /*  units are Kusec */
 };
 
 
@@ -54,10 +52,10 @@ struct ndis_802_11_config_fh {
  *	ODI Handler will convert the channel number to freq. number.
  */
 struct ndis_802_11_config {
-	u32           Length;             // Length of structure
-	u32           BeaconPeriod;       // units are Kusec
-	u32           ATIMWindow;         // units are Kusec
-	u32           DSConfig;           // Frequency, units are kHz
+	u32           Length;             /*  Length of structure */
+	u32           BeaconPeriod;       /*  units are Kusec */
+	u32           ATIMWindow;         /*  units are Kusec */
+	u32           DSConfig;           /*  Frequency, units are kHz */
 	struct ndis_802_11_config_fh    FHConfig;
 };
 
@@ -65,7 +63,7 @@ enum NDIS_802_11_NETWORK_INFRASTRUCTURE
 	NDIS802_11IBSS,
 	NDIS802_11INFRA,
 	NDIS802_11AUTOUNK,
-	NDIS802_11INFRA_MAX,     // Not a real value, defined as upper bound
+	NDIS802_11INFRA_MAX,     /*  Not a real value, defined as upper bound */
 	NDIS802_11APMODE
 };
 
@@ -98,7 +96,7 @@ enum NDIS_802_11_AUTHENTICATION_MODE {
 	NDIS802_11AUTHMODEWPA,
 	NDIS802_11AUTHMODEWPAPSK,
 	NDIS802_11AUTHMODEWPANONE,
-	NDIS802_11AUTHMODEMAX               // Not a real mode, defined as upper bound
+	NDIS802_11AUTHMODEMAX               /*  Not a real mode, defined as upper bound */
 };
 
 enum NDIS_802_11_ENCRYPTION_STATUS {
@@ -148,31 +146,31 @@ struct ndis_802_11_assoc_info {
     u32                   OffsetResponseIEs;
 };
 
-// Key mapping keys require a BSSID
+/*  Key mapping keys require a BSSID */
 struct ndis_802_11_key {
-    u32           Length;             // Length of this structure
+    u32           Length;             /*  Length of this structure */
     u32           KeyIndex;
-    u32           KeyLength;          // length of key in bytes
+    u32           KeyLength;          /*  length of key in bytes */
     unsigned char BSSID[6];
     unsigned long long KeyRSC;
-    u8           KeyMaterial[32];     // variable length depending on above field
+    u8           KeyMaterial[32];     /*  variable length depending on above field */
 };
 
 struct ndis_802_11_remove_key {
-    u32                   Length;        // Length of this structure
+    u32                   Length;        /*  Length of this structure */
     u32                   KeyIndex;
     unsigned char BSSID[6];
 };
 
 struct ndis_802_11_wep {
-    u32     Length;        // Length of this structure
-    u32     KeyIndex;      // 0 is the per-client key, 1-N are the global keys
-    u32     KeyLength;     // length of key in bytes
-    u8     KeyMaterial[16];// variable length depending on above field
+    u32     Length;        /*  Length of this structure */
+    u32     KeyIndex;      /*  0 is the per-client key, 1-N are the global keys */
+    u32     KeyLength;     /*  length of key in bytes */
+    u8     KeyMaterial[16];/*  variable length depending on above field */
 };
 
 struct ndis_802_11_auth_req {
-    u32 Length;            // Length of structure
+    u32 Length;            /*  Length of structure */
     unsigned char Bssid[6];
     u32 Flags;
 };
@@ -181,21 +179,21 @@ enum NDIS_802_11_STATUS_TYPE {
 	Ndis802_11StatusType_Authentication,
 	Ndis802_11StatusType_MediaStreamMode,
 	Ndis802_11StatusType_PMKID_CandidateList,
-	Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
+	Ndis802_11StatusTypeMax    /*  not a real type, defined as an upper bound */
 };
 
 struct ndis_802_11_status_ind {
 	enum NDIS_802_11_STATUS_TYPE StatusType;
 };
 
-// mask for authentication/integrity fields
+/*  mask for authentication/integrity fields */
 #define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
 #define NDIS_802_11_AUTH_REQUEST_REAUTH			0x01
 #define NDIS_802_11_AUTH_REQUEST_KEYUPDATE		0x02
 #define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
 #define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E
 
-// MIC check time, 60 seconds.
+/*  MIC check time, 60 seconds. */
 #define MIC_CHECK_TIME	60000000
 
 struct ndis_802_11_auth_event {
@@ -217,26 +215,26 @@ struct ndis_802_11_test {
 #endif
 
 struct wlan_phy_info {
-	u8	SignalStrength;//(in percentage)
-	u8	SignalQuality;//(in percentage)
-	u8	Optimum_antenna;  //for Antenna diversity
+	u8	SignalStrength;/* in percentage) */
+	u8	SignalQuality;/* in percentage) */
+	u8	Optimum_antenna;  /* for Antenna diversity */
 	u8	Reserved_0;
 };
 
 struct wlan_bssid_ex {
 	u32  Length;
 	unsigned char  MacAddress[6];
-	u8  Reserved[2];//[0]: IS beacon frame
+	u8  Reserved[2];/* 0]: IS beacon frame */
 	struct ndis_802_11_ssid  Ssid;
 	u32  Privacy;
-	long  Rssi;//(in dBM,raw data ,get from PHY)
+	long  Rssi;/* in dBM,raw data ,get from PHY) */
 	enum NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
 	struct ndis_802_11_config  Configuration;
 	enum NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
 	unsigned char SupportedRates[NDIS_802_11_LENGTH_RATES_EX];
 	struct wlan_phy_info PhyInfo;
 	u32  IELength;
-	u8  IEs[MAX_IE_SZ];	//(timestamp, beacon interval, and capability information)
+	u8  IEs[MAX_IE_SZ];	/* timestamp, beacon interval, and capability information) */
 } __packed;
 
 __inline  static uint get_wlan_bssid_ex_sz(struct wlan_bssid_ex *bss)
@@ -246,12 +244,12 @@ __inline  static uint get_wlan_bssid_ex_
 
 struct	wlan_network {
 	struct list_head list;
-	int	network_type;	//refer to ieee80211.h for WIRELESS_11A/B/G
-	int	fixed;			// set to fixed when not to be removed as site-surveying
-	unsigned long	last_scanned; //timestamp for the network
-	int	aid;			//will only be valid when a BSS is joinned.
+	int	network_type;	/* refer to ieee80211.h for WIRELESS_11A/B/G */
+	int	fixed;			/*  set to fixed when not to be removed as site-surveying */
+	unsigned long	last_scanned; /* timestamp for the network */
+	int	aid;			/* will only be valid when a BSS is joinned. */
 	int	join_res;
-	struct wlan_bssid_ex network; //must be the last item
+	struct wlan_bssid_ex network; /* must be the last item */
 };
 
 enum VRTL_CARRIER_SENSE
@@ -287,7 +285,7 @@ enum UAPSD_MAX_SP
 };
 
 
-//john
+/* john */
 #define NUM_PRE_AUTH_KEY 16
 #define NUM_PMKID_CACHE NUM_PRE_AUTH_KEY
 
@@ -301,8 +299,8 @@ struct pmkid_candidate {
 };
 
 struct ndis_802_11_pmkid_list {
-	u32 Version;       // Version of the structure
-	u32 NumCandidates; // No. of pmkid candidates
+	u32 Version;       /*  Version of the structure */
+	u32 NumCandidates; /*  No. of pmkid candidates */
 	struct pmkid_candidate CandidateList[1];
 };
 
@@ -322,4 +320,4 @@ struct ndis_802_11_capa {
 };
 
 
-#endif //#ifndef WLAN_BSSDEF_H_
+#endif /* ifndef WLAN_BSSDEF_H_ */
--- a/drivers/staging/rtl8192du/include/xmit_osdep.h
+++ b/drivers/staging/rtl8192du/include/xmit_osdep.h
@@ -26,7 +26,7 @@
 
 struct pkt_file {
 	struct sk_buff *pkt;
-	__kernel_size_t pkt_len;	 //the remainder length of the open_file
+	__kernel_size_t pkt_len;	 /* the remainder length of the open_file */
 	unsigned char *cur_buffer;
 	u8 *buf_start;
 	u8 *cur_addr;
@@ -58,4 +58,4 @@ extern int rtw_endofpktfile (struct pkt_
 extern void rtw_os_pkt_complete(struct rtw_adapter *padapter, struct sk_buff *pkt);
 extern void rtw_os_xmit_complete(struct rtw_adapter *padapter, struct xmit_frame *pxframe);
 
-#endif //__XMIT_OSDEP_H_
+#endif /* __XMIT_OSDEP_H_ */

From 20908504318087e2b1937019da2a61f999020409 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sat, 15 Mar 2014 10:49:46 -0500
Subject: [PATCH 257/390] Fix checkpatch warnings in core/rtw_cmd.c

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_cmd.c      |  639 ++++++++++--------
 core/rtw_mlme_ext.c |    2 +-
 hal/rtl8192du_led.c | 1830 +++++++++++++++++++++++++--------------------------
 include/rtw_cmd.h   |    4 +-
 include/rtw_led.h   |   36 +-
 5 files changed, 1286 insertions(+), 1225 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -39,14 +39,17 @@ int _rtw_init_cmd_priv(struct cmd_priv *
 
 	pcmdpriv->cmd_seq = 1;
 
-	pcmdpriv->cmd_allocated_buf = kzalloc(MAX_CMDSZ + CMDBUFF_ALIGN_SZ, GFP_ATOMIC);
+	pcmdpriv->cmd_allocated_buf = kzalloc(MAX_CMDSZ +
+					      CMDBUFF_ALIGN_SZ, GFP_ATOMIC);
 
 	if (pcmdpriv->cmd_allocated_buf == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	pcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ - ((SIZE_PTR)(pcmdpriv->cmd_allocated_buf) & (CMDBUFF_ALIGN_SZ-1));
+	pcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ -
+			    ((SIZE_PTR)(pcmdpriv->cmd_allocated_buf) &
+			    (CMDBUFF_ALIGN_SZ-1));
 
 	pcmdpriv->rsp_allocated_buf = kzalloc(MAX_RSPSZ + 4, GFP_ATOMIC);
 
@@ -78,7 +81,6 @@ int _rtw_init_evt_priv(struct evt_priv *
 
 void _rtw_free_evt_priv(struct evt_priv *pevtpriv)
 {
-
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("+_rtw_free_evt_priv\n"));
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("-_rtw_free_evt_priv\n"));
@@ -159,29 +161,26 @@ u32	rtw_init_evt_priv(struct evt_priv *p
 
 void rtw_free_evt_priv(struct evt_priv *pevtpriv)
 {
-
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("rtw_free_evt_priv\n"));
 	_rtw_free_evt_priv(pevtpriv);
-
 }
 
 void rtw_free_cmd_priv(struct cmd_priv *pcmdpriv)
 {
-
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("rtw_free_cmd_priv\n"));
 	_rtw_free_cmd_priv(pcmdpriv);
-
 }
 
 static int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
 {
-	u8 allow = false; /* set to true to allow enqueuing cmd when hw_init_completed is false */
+	/* set to true to allow enqueuing cmd when hw_init_completed is false */
+	u8 allow = false;
 
 	if (cmd_obj->cmdcode == GEN_CMD_CODE(_SETCHANNELPLAN))
 		allow = true;
 
-	if ((pcmdpriv->padapter->hw_init_completed == false && allow == false) ||
-	    pcmdpriv->cmdthd_running == false)	/* com_thread not running */
+	if ((!pcmdpriv->padapter->hw_init_completed && !allow) ||
+	    !pcmdpriv->cmdthd_running)	/* com_thread not running */
 		return _FAIL;
 	return _SUCCESS;
 }
@@ -191,15 +190,15 @@ u32 rtw_enqueue_cmd(struct cmd_priv *pcm
 	int res = _FAIL;
 	struct rtw_adapter *padapter = pcmdpriv->padapter;
 
-	if (cmd_obj == NULL) {
+	if (cmd_obj == NULL)
 		goto exit;
-	}
 
 	cmd_obj->padapter = padapter;
 
 #ifdef CONFIG_CONCURRENT_MODE
 	/* change pcmdpriv to primary's pcmdpriv */
-	if (padapter->adapter_type != PRIMARY_ADAPTER && padapter->pbuddy_adapter)
+	if (padapter->adapter_type != PRIMARY_ADAPTER &&
+	    padapter->pbuddy_adapter)
 		pcmdpriv = &(padapter->pbuddy_adapter->cmdpriv);
 #endif
 
@@ -229,14 +228,11 @@ struct cmd_obj *rtw_dequeue_cmd(struct c
 
 void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv)
 {
-
 	pcmdpriv->cmd_done_cnt++;
-
 }
 
 void rtw_free_cmd_obj(struct cmd_obj *pcmd)
 {
-
 	if ((pcmd->cmdcode != _JOINBSS_CMD_) &&
 	    (pcmd->cmdcode != _CREATEBSS_CMD_)) {
 		/* free parmbuf in cmd_obj */
@@ -252,7 +248,6 @@ void rtw_free_cmd_obj(struct cmd_obj *pc
 
 	/* free cmd_obj */
 	kfree(pcmd);
-
 }
 
 int rtw_cmd_thread(void *context)
@@ -272,14 +267,15 @@ int rtw_cmd_thread(void *context)
 	pcmdpriv->cmdthd_running = true;
 	_rtw_up_sema(&pcmdpriv->terminate_cmdthread_sema);
 
-	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("start r871x rtw_cmd_thread !!!!\n"));
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_,
+		 ("start r871x rtw_cmd_thread !!!!\n"));
 
 	while (1) {
 		if ((_rtw_down_sema(&(pcmdpriv->cmd_queue_sema))) == _FAIL)
 			break;
 _next:
-		if ((padapter->bDriverStopped == true) ||
-		    (padapter->bSurpriseRemoved == true)) {
+		if ((padapter->bDriverStopped) ||
+		    (padapter->bSurpriseRemoved)) {
 			DBG_8192D("###> rtw_cmd_thread break.................\n");
 			RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_,
 				 ("rtw_cmd_thread:bDriverStopped(%d) OR bSurpriseRemoved(%d)",
@@ -326,14 +322,20 @@ _next:
 post_process:
 
 		/* call callback function for post-processed */
-		if (pcmd->cmdcode < (sizeof(rtw_cmd_callback) / sizeof(struct _cmd_callback))) {
+		if (pcmd->cmdcode < (sizeof(rtw_cmd_callback) /
+		    sizeof(struct _cmd_callback))) {
 			pcmd_callback = rtw_cmd_callback[pcmd->cmdcode].callback;
 			if (pcmd_callback == NULL) {
-				RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("mlme_cmd_hdl(): pcmd_callback = 0x%p, cmdcode = 0x%x\n", pcmd_callback, pcmd->cmdcode));
+				RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_,
+					 ("mlme_cmd_hdl(): pcmd_callback = 0x%p, cmdcode = 0x%x\n",
+					 pcmd_callback, pcmd->cmdcode));
 				rtw_free_cmd_obj(pcmd);
 			} else {
-				/* todo: !!! fill rsp_buf to pcmd->rsp if (pcmd->rsp!= NULL) */
-				pcmd_callback(pcmd->padapter, pcmd);/* need conider that free cmd_obj in rtw_cmd_callback */
+				/* todo: !!! fill rsp_buf to pcmd->rsp if
+				 * (pcmd->rsp!= NULL). need conider that cmd_obj
+				 * is freed in rtw_cmd_callback
+				 */
+				pcmd_callback(pcmd->padapter, pcmd);
 			}
 		}
 
@@ -364,13 +366,13 @@ u8 rtw_setstandby_cmd(struct rtw_adapter
 
 	u8 ret = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		ret = _FAIL;
 		goto exit;
 	}
 
-	psetusbsuspend = (struct usb_suspend_parm *)kzalloc(sizeof(struct usb_suspend_parm), GFP_ATOMIC);
+	psetusbsuspend = kzalloc(sizeof(*pcmdpriv), GFP_ATOMIC);
 	if (psetusbsuspend == NULL) {
 		kfree(ph2c);
 		ret = _FAIL;
@@ -379,7 +381,8 @@ u8 rtw_setstandby_cmd(struct rtw_adapter
 
 	psetusbsuspend->action = action;
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, psetusbsuspend, GEN_CMD_CODE(_SETUSBSUSPEND));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetusbsuspend,
+				   GEN_CMD_CODE(_SETUSBSUSPEND));
 
 	ret = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
@@ -387,56 +390,58 @@ exit:
 	return ret;
 }
 
-/*
-rtw_sitesurvey_cmd(~)
-	### NOTE:#### (!!!!)
-	MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
-*/
-u8 rtw_sitesurvey_cmd(struct rtw_adapter *padapter, struct ndis_802_11_ssid *ssid, int ssid_num,
-	struct rtw_ieee80211_channel *ch, int ch_num)
+/* rtw_sitesurvey_cmd(~)
+ *	### NOTE:#### (!!!!)
+ *	MUST TAKE CARE THAT BEFORE CALLING THIS FUNC,
+ *      YOU MUST HAVE LOCKED pmlmepriv->lock
+ */
+u8 rtw_sitesurvey_cmd(struct rtw_adapter *padapter,
+		      struct ndis_802_11_ssid *ssid, int ssid_num,
+		      struct rtw_ieee80211_channel *ch, int ch_num)
 {
-	u8 res = _FAIL;
 	struct cmd_obj *ph2c;
-	struct sitesurvey_parm *psurveyPara;
-	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct sitesurvey_parm *psurveypara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	u8 res = _FAIL;
 
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+	if (check_fwstate(pmlmepriv, _FW_LINKED))
 		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SCAN, 1);
-	}
 
 #ifdef CONFIG_P2P_PS
-	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+	if (check_fwstate(pmlmepriv, _FW_LINKED))
 		p2p_ps_wk_cmd(padapter, P2P_PS_SCAN, 1);
-	}
 #endif /*  CONFIG_P2P_PS */
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL)
 		return _FAIL;
 
-	psurveyPara = (struct sitesurvey_parm *)kzalloc(sizeof(struct sitesurvey_parm), GFP_ATOMIC);
-	if (psurveyPara == NULL) {
+	psurveypara = kzalloc(sizeof(*psurveypara), GFP_ATOMIC);
+	if (psurveypara == NULL) {
 		kfree(ph2c);
 		return _FAIL;
 	}
 
 	rtw_free_network_queue(padapter, false);
 
-	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("\nflush  network queue\n\n"));
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_,
+		 ("\nflush  network queue\n\n"));
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara, GEN_CMD_CODE(_SITESURVEY));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psurveypara,
+				   GEN_CMD_CODE(_SITESURVEY));
 
-	/* psurveyPara->bsslimit = 48; */
-	psurveyPara->scan_mode = pmlmepriv->scan_mode;
+	/* psurveypara->bsslimit = 48; */
+	psurveypara->scan_mode = pmlmepriv->scan_mode;
 
 	/* prepare ssid list */
 	if (ssid) {
 		int i;
 		for (i = 0; i < ssid_num && i < RTW_SSID_SCAN_AMOUNT; i++) {
 			if (ssid[i].SsidLength) {
-				memcpy(&psurveyPara->ssid[i], &ssid[i], sizeof(struct ndis_802_11_ssid));
-				psurveyPara->ssid_num++;
+				memcpy(&psurveypara->ssid[i], &ssid[i],
+				       sizeof(struct ndis_802_11_ssid));
+				psurveypara->ssid_num++;
 			}
 		}
 	}
@@ -446,8 +451,9 @@ u8 rtw_sitesurvey_cmd(struct rtw_adapter
 		int i;
 		for (i = 0; i < ch_num && i < RTW_CHANNEL_SCAN_AMOUNT; i++) {
 			if (ch[i].hw_value && !(ch[i].flags & RTW_IEEE80211_CHAN_DISABLED)) {
-				memcpy(&psurveyPara->ch[i], &ch[i], sizeof(struct rtw_ieee80211_channel));
-				psurveyPara->ch_num++;
+				memcpy(&psurveypara->ch[i], &ch[i],
+				       sizeof(struct rtw_ieee80211_channel));
+				psurveypara->ch_num++;
 			}
 		}
 	}
@@ -461,7 +467,9 @@ u8 rtw_sitesurvey_cmd(struct rtw_adapter
 
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 		if ((padapter->pbuddy_adapter->mlmeextpriv.mlmext_info.state&0x03) == WIFI_FW_AP_STATE)
-			_set_timer(&pmlmepriv->scan_to_timer, SURVEY_TO * (38 + (38 / RTW_SCAN_NUM_OF_CH) * RTW_STAY_AP_CH_MILLISECOND) + 1000);
+			_set_timer(&pmlmepriv->scan_to_timer, SURVEY_TO *
+				   (38 + (38 / RTW_SCAN_NUM_OF_CH) *
+				    RTW_STAY_AP_CH_MILLISECOND) + 1000);
 		else
 #endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
 			_set_timer(&pmlmepriv->scan_to_timer, SCANNING_TIMEOUT);
@@ -483,20 +491,21 @@ u8 rtw_setdatarate_cmd(struct rtw_adapte
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	pbsetdataratepara = (struct setdatarate_parm *)kzalloc(sizeof(struct setdatarate_parm), GFP_ATOMIC);
-	if (pbsetdataratepara == NULL) {
+	pbsetdataratepara = kzalloc(sizeof(*pbsetdataratepara), GFP_ATOMIC);
+	if (!pbsetdataratepara) {
 		kfree(ph2c);
 		res = _FAIL;
 		goto exit;
 	}
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pbsetdataratepara, GEN_CMD_CODE(_SETDATARATE));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pbsetdataratepara,
+				   GEN_CMD_CODE(_SETDATARATE));
 	pbsetdataratepara->mac_id = 5;
 	memcpy(pbsetdataratepara->datarates, rateset, NUMRATES);
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
@@ -511,12 +520,12 @@ u8 rtw_setbasicrate_cmd(struct rtw_adapt
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
-	pssetbasicratepara = (struct setbasicrate_parm *)kzalloc(sizeof(struct setbasicrate_parm), GFP_ATOMIC);
+	pssetbasicratepara = kzalloc(sizeof(*pssetbasicratepara), GFP_ATOMIC);
 
 	if (pssetbasicratepara == NULL) {
 		kfree(ph2c);
@@ -524,7 +533,8 @@ u8 rtw_setbasicrate_cmd(struct rtw_adapt
 		goto exit;
 	}
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pssetbasicratepara, _SETBASICRATE_CMD_);
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pssetbasicratepara,
+				   _SETBASICRATE_CMD_);
 
 	memcpy(pssetbasicratepara->basicrates, rateset, NUMRATES);
 
@@ -533,13 +543,11 @@ exit:
 	return res;
 }
 
-/*
-unsigned char rtw_setphy_cmd(unsigned char  *adapter)
-
-1.  be called only after rtw_update_registrypriv_dev_network(~) or mp testing program
-2.  for AdHoc/Ap mode or mp mode?
-
-*/
+/* unsigned char rtw_setphy_cmd(unsigned char  *adapter)
+ * 1. be called only after rtw_update_registrypriv_dev_network(~) or
+ *    mp testing program
+ *2.  for AdHoc/Ap mode or mp mode?
+ */
 u8 rtw_setphy_cmd(struct rtw_adapter *padapter, u8 modem, u8 ch)
 {
 	struct cmd_obj *ph2c;
@@ -547,12 +555,12 @@ u8 rtw_setphy_cmd(struct rtw_adapter *pa
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
-	psetphypara = (struct setphy_parm *)kzalloc(sizeof(struct setphy_parm), GFP_ATOMIC);
+	psetphypara = kzalloc(sizeof(*psetphypara), GFP_ATOMIC);
 
 	if (psetphypara == NULL) {
 		kfree(ph2c);
@@ -562,7 +570,8 @@ u8 rtw_setphy_cmd(struct rtw_adapter *pa
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, psetphypara, _SETPHY_CMD_);
 
-	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("CH =%d, modem =%d", ch, modem));
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_,
+		 ("CH =%d, modem =%d", ch, modem));
 
 	psetphypara->modem = modem;
 	psetphypara->rfchannel = ch;
@@ -580,12 +589,12 @@ u8 rtw_setbbreg_cmd(struct rtw_adapter *
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
-		}
-	pwritebbparm = (struct writeBB_parm *)kzalloc(sizeof(struct writeBB_parm), GFP_ATOMIC);
+	}
+	pwritebbparm = kzalloc(sizeof(*pwritebbparm), GFP_ATOMIC);
 
 	if (pwritebbparm == NULL) {
 		kfree(ph2c);
@@ -611,12 +620,12 @@ u8 rtw_getbbreg_cmd(struct rtw_adapter *
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
-	prdbbparm = (struct readBB_parm *)kzalloc(sizeof(struct readBB_parm), GFP_ATOMIC);
+	prdbbparm = kzalloc(sizeof(*prdbbparm), GFP_ATOMIC);
 
 	if (prdbbparm == NULL) {
 		kfree(ph2c);
@@ -645,12 +654,12 @@ u8 rtw_setrfreg_cmd(struct rtw_adapter *
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
-	pwriterfparm = (struct writeRF_parm *)kzalloc(sizeof(struct writeRF_parm), GFP_ATOMIC);
+	pwriterfparm = kzalloc(sizeof(*pwriterfparm), GFP_ATOMIC);
 
 	if (pwriterfparm == NULL) {
 		kfree(ph2c);
@@ -676,13 +685,13 @@ u8 rtw_getrfreg_cmd(struct rtw_adapter *
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	prdrfparm = (struct readRF_parm *)kzalloc(sizeof(struct readRF_parm), GFP_ATOMIC);
+	prdrfparm = kzalloc(sizeof(*prdrfparm), GFP_ATOMIC);
 	if (prdrfparm == NULL) {
 		kfree(ph2c);
 		res = _FAIL;
@@ -705,20 +714,18 @@ exit:
 	return res;
 }
 
-void rtw_getbbrfreg_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
+void rtw_getbbrfreg_cmdrsp_callback(struct rtw_adapter *padapter,
+				    struct cmd_obj *pcmd)
 {
-
 	kfree(pcmd->parmbuf);
 	kfree(pcmd);
-
 }
 
-void rtw_readtssi_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
+void rtw_readtssi_cmdrsp_callback(struct rtw_adapter *padapter,
+				  struct cmd_obj *pcmd)
 {
-
 	kfree(pcmd->parmbuf);
 	kfree(pcmd);
-
 }
 
 u8 rtw_createbss_cmd(struct rtw_adapter *padapter)
@@ -731,13 +738,16 @@ u8 rtw_createbss_cmd(struct rtw_adapter
 
 	rtw_led_control(padapter, LED_CTL_START_TO_LINK);
 
-	if (pmlmepriv->assoc_ssid.SsidLength == 0) {
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, (" createbss for Any SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
-	} else {
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, (" createbss for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
-	}
+	if (pmlmepriv->assoc_ssid.SsidLength == 0)
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_,
+			 (" createbss for Any SSid:%s\n",
+			 pmlmepriv->assoc_ssid.Ssid));
+	else
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_,
+			 (" createbss for SSid:%s\n",
+			 pmlmepriv->assoc_ssid.Ssid));
 
-	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	pcmd = kzalloc(sizeof(*pcmd), GFP_ATOMIC);
 	if (pcmd == NULL) {
 		res = _FAIL;
 		goto exit;
@@ -758,13 +768,14 @@ exit:
 	return res;
 }
 
-u8 rtw_createbss_cmd_ex(struct rtw_adapter *padapter, unsigned char *pbss, unsigned int sz)
+u8 rtw_createbss_cmd_ex(struct rtw_adapter *padapter, unsigned char *pbss,
+			unsigned int sz)
 {
 	struct cmd_obj *pcmd;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	pcmd = kzalloc(sizeof(*pcmd), GFP_ATOMIC);
 	if (pcmd == NULL) {
 		res = _FAIL;
 		goto exit;
@@ -786,39 +797,43 @@ exit:
 
 u8 rtw_joinbss_cmd(struct rtw_adapter *padapter, struct wlan_network *pnetwork)
 {
-	u8 res = _SUCCESS;
-	uint	t_len = 0;
 	struct wlan_bssid_ex	*psecnetwork;
 	struct cmd_obj *pcmd;
 	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
-	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
-	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
-	enum NDIS_802_11_NETWORK_INFRASTRUCTURE ndis_network_mode = pnetwork->network.InfrastructureMode;
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 res = _SUCCESS;
+	uint	t_len = 0;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE ndis_network_mode;
 
+	ndis_network_mode = pnetwork->network.InfrastructureMode;
 	rtw_led_control(padapter, LED_CTL_START_TO_LINK);
 
-	if (pmlmepriv->assoc_ssid.SsidLength == 0) {
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("+Join cmd: Any SSid\n"));
-	} else {
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+Join cmd: SSid =[%s]\n", pmlmepriv->assoc_ssid.Ssid));
-	}
+	if (pmlmepriv->assoc_ssid.SsidLength == 0)
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_,
+			 ("+Join cmd: Any SSid\n"));
+	else
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_,
+			 ("+Join cmd: SSid =[%s]\n",
+			 pmlmepriv->assoc_ssid.Ssid));
 
-	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	pcmd = kzalloc(sizeof(*pcmd), GFP_ATOMIC);
 	if (pcmd == NULL) {
 		res = _FAIL;
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd: memory allocate for cmd_obj fail!!!\n"));
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+			 ("rtw_joinbss_cmd: memory allocate for cmd_obj fail!!!\n"));
 		goto exit;
 	}
 	/* for IEs is fix buf size */
 	t_len = sizeof(struct wlan_bssid_ex);
 
 	/* for hidden ap to set fw_state here */
-	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) != true) {
+	if (!check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE)) {
 		switch (ndis_network_mode) {
 		case NDIS802_11IBSS:
 			set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
@@ -837,53 +852,66 @@ u8 rtw_joinbss_cmd(struct rtw_adapter *p
 	if (psecnetwork == NULL) {
 		kfree(pcmd);
 		res = _FAIL;
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd :psecnetwork == NULL!!!\n"));
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+			 ("rtw_joinbss_cmd :psecnetwork == NULL!!!\n"));
 		goto exit;
 	}
 
 	memset(psecnetwork, 0, t_len);
 
-	memcpy(psecnetwork, &pnetwork->network, get_wlan_bssid_ex_sz(&pnetwork->network));
+	memcpy(psecnetwork, &pnetwork->network,
+	       get_wlan_bssid_ex_sz(&pnetwork->network));
 
 	psecuritypriv->authenticator_ie[0] = (unsigned char)psecnetwork->IELength;
 
-	if ((psecnetwork->IELength-12) < (256-1)) {
-		memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], psecnetwork->IELength-12);
-	} else {
-		memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], (256-1));
-	}
+	if ((psecnetwork->IELength-12) < (256-1))
+		memcpy(&psecuritypriv->authenticator_ie[1],
+		       &psecnetwork->IEs[12], psecnetwork->IELength-12);
+	else
+		memcpy(&psecuritypriv->authenticator_ie[1],
+		       &psecnetwork->IEs[12], (256-1));
 
 	psecnetwork->IELength = 0;
-	/*  Added by Albert 2009/02/18 */
-	/*  If the the driver wants to use the bssid to create the connection. */
-	/*  If not,  we have to copy the connecting AP's MAC address to it so that */
-	/*  the driver just has the bssid information for PMKIDList searching. */
-
-	if (pmlmepriv->assoc_by_bssid == false)
-		memcpy(&pmlmepriv->assoc_bssid[0], &pnetwork->network.MacAddress[0], ETH_ALEN);
-
-	psecnetwork->IELength = rtw_restruct_sec_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength);
+	/*  If the the driver wants to use the bssid to create the connection.
+	 *  If not,  we have to copy the connecting AP's MAC address to it so that
+	 *  the driver just has the bssid information for PMKIDList searching.
+	 */
+	if (!pmlmepriv->assoc_by_bssid)
+		memcpy(&pmlmepriv->assoc_bssid[0],
+		       &pnetwork->network.MacAddress[0], ETH_ALEN);
+
+	psecnetwork->IELength = rtw_restruct_sec_ie(padapter,
+						    &pnetwork->network.IEs[0],
+						    &psecnetwork->IEs[0],
+						    pnetwork->network.IELength);
 
 	pqospriv->qos_option = 0;
 
 	if (pregistrypriv->wmm_enable) {
 		u32 tmp_len;
 
-		tmp_len = rtw_restruct_wmm_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength, psecnetwork->IELength);
+		tmp_len = rtw_restruct_wmm_ie(padapter,
+					      &pnetwork->network.IEs[0],
+					      &psecnetwork->IEs[0],
+					      pnetwork->network.IELength,
+					      psecnetwork->IELength);
 
 		if (psecnetwork->IELength != tmp_len) {
 			psecnetwork->IELength = tmp_len;
-			pqospriv->qos_option = 1; /* There is WMM IE in this corresp. beacon */
+			/* There is WMM IE in this corresp. beacon */
+			pqospriv->qos_option = 1;
 		} else {
-			pqospriv->qos_option = 0;/* There is no WMM IE in this corresp. beacon */
+			/* There is no WMM IE in this corresp. beacon */
+			pqospriv->qos_option = 0;
 		}
 	}
 
 	phtpriv->ht_option = false;
 	if (pregistrypriv->ht_enable) {
-		/*	Added by Albert 2010/06/23 */
-		/*	For the WEP mode, we will use the bg mode to do the connection to avoid some IOT issue. */
-		/*	Especially for Realtek 8192u SoftAP. */
+		/*  For the WEP mode, we will use the bg mode to do the
+		 *  connection to avoid some IOT issue.
+		 *  Especially for Realtek 8192u SoftAP.
+		 */
 		if ((padapter->securitypriv.dot11PrivacyAlgrthm != _WEP40_) &&
 		    (padapter->securitypriv.dot11PrivacyAlgrthm != _WEP104_) &&
 		    (padapter->securitypriv.dot11PrivacyAlgrthm != _TKIP_)) {
@@ -896,9 +924,11 @@ u8 rtw_joinbss_cmd(struct rtw_adapter *p
 		}
 	}
 
-	pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->network.IEs, pnetwork->network.IELength);
+	pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->network.IEs,
+						    pnetwork->network.IELength);
 
-	pcmd->cmdsz = get_wlan_bssid_ex_sz(psecnetwork);/* get cmdsz before endian conversion */
+	/* get cmdsz before endian conversion */
+	pcmd->cmdsz = get_wlan_bssid_ex_sz(psecnetwork);
 
 	INIT_LIST_HEAD(&pcmd->list);
 	pcmd->cmdcode = _JOINBSS_CMD_;/* GEN_CMD_CODE(_JoinBss) */
@@ -913,7 +943,8 @@ exit:
 	return res;
 }
 
-u8 rtw_disassoc_cmd(struct rtw_adapter *padapter, u32 deauth_timeout_ms, bool enqueue) /* for sta_mode */
+u8 rtw_disassoc_cmd(struct rtw_adapter *padapter, u32 deauth_timeout_ms,
+		    bool enqueue) /* for sta_mode */
 {
 	struct cmd_obj *cmdobj = NULL;
 	struct disconnect_parm *param = NULL;
@@ -923,7 +954,7 @@ u8 rtw_disassoc_cmd(struct rtw_adapter *
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_disassoc_cmd\n"));
 
 	/* prepare cmd parameter */
-	param = (struct disconnect_parm *)kzalloc(sizeof(*param), GFP_ATOMIC);
+	param = kzalloc(sizeof(*param), GFP_ATOMIC);
 	if (param == NULL) {
 		res = _FAIL;
 		goto exit;
@@ -932,7 +963,7 @@ u8 rtw_disassoc_cmd(struct rtw_adapter *
 
 	if (enqueue) {
 		/* need enqueue, prepare cmd_obj and enqueue */
-		cmdobj = (struct cmd_obj *)kzalloc(sizeof(*cmdobj), GFP_ATOMIC);
+		cmdobj = kzalloc(sizeof(*cmdobj), GFP_ATOMIC);
 		if (cmdobj == NULL) {
 			res = _FAIL;
 			kfree(param);
@@ -941,18 +972,17 @@ u8 rtw_disassoc_cmd(struct rtw_adapter *
 		init_h2fwcmd_w_parm_no_rsp(cmdobj, param, _DISCONNECT_CMD_);
 		res = rtw_enqueue_cmd(cmdpriv, cmdobj);
 	} else {
-		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
+		/* no need to enqueue, do the cmd hdl directly */
 		if (H2C_SUCCESS != disconnect_hdl(padapter, (u8 *)param))
 			res = _FAIL;
 		kfree(param);
 	}
-
 exit:
-
 	return res;
 }
 
-u8 rtw_setopmode_cmd(struct rtw_adapter *padapter, enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+u8 rtw_setopmode_cmd(struct rtw_adapter *padapter,
+		     enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
 {
 	struct cmd_obj *ph2c;
 	struct setopmode_parm *psetop;
@@ -960,12 +990,12 @@ u8 rtw_setopmode_cmd(struct rtw_adapter
 	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = false;
 		goto exit;
 	}
-	psetop = (struct setopmode_parm *)kzalloc(sizeof(struct setopmode_parm), GFP_ATOMIC);
+	psetop = kzalloc(sizeof(*psetop), GFP_ATOMIC);
 	if (psetop == NULL) {
 		kfree(ph2c);
 		res = false;
@@ -986,28 +1016,28 @@ u8 rtw_setstakey_cmd(struct rtw_adapter
 {
 	struct cmd_obj *ph2c;
 	struct set_stakey_parm *psetstakey_para;
-	struct cmd_priv				*pcmdpriv = &padapter->cmdpriv;
-	struct set_stakey_rsp		*psetstakey_rsp = NULL;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	struct set_stakey_rsp *psetstakey_rsp = NULL;
 
-	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
-	struct security_priv		*psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct sta_info *sta = (struct sta_info *)psta;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	psetstakey_para = (struct set_stakey_parm *)kzalloc(sizeof(struct set_stakey_parm), GFP_ATOMIC);
+	psetstakey_para = kzalloc(sizeof(*psetstakey_para), GFP_ATOMIC);
 	if (psetstakey_para == NULL) {
 		kfree(ph2c);
 		res = _FAIL;
 		goto exit;
 	}
 
-	psetstakey_rsp = (struct set_stakey_rsp *)kzalloc(sizeof(struct set_stakey_rsp), GFP_ATOMIC);
+	psetstakey_rsp = kzalloc(sizeof(*psetstakey_rsp), GFP_ATOMIC);
 	if (psetstakey_rsp == NULL) {
 		kfree(ph2c);
 		kfree(psetstakey_para);
@@ -1022,14 +1052,16 @@ u8 rtw_setstakey_cmd(struct rtw_adapter
 	memcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);
 
 	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
-		psetstakey_para->algorithm = (unsigned char) psecuritypriv->dot11PrivacyAlgrthm;
+		psetstakey_para->algorithm = (unsigned char)psecuritypriv->dot11PrivacyAlgrthm;
 	else
-		GET_ENCRY_ALGO(psecuritypriv, sta, psetstakey_para->algorithm, false);
+		GET_ENCRY_ALGO(psecuritypriv, sta, psetstakey_para->algorithm,
+			       false);
 
 	if (unicast_key)
 		memcpy(&psetstakey_para->key, &sta->dot118021x_UncstKey, 16);
 	else
-		memcpy(&psetstakey_para->key, &psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey, 16);
+		memcpy(&psetstakey_para->key,
+		       &psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey, 16);
 
 	/* jeff: set this becasue at least sw key is ready */
 	padapter->securitypriv.busetkipkey = true;
@@ -1055,20 +1087,20 @@ u8 rtw_clearstakey_cmd(struct rtw_adapte
 	if (!enqueue) {
 		clear_cam_entry(padapter, entry);
 	} else {
-		ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+		ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 		if (ph2c == NULL) {
 			res = _FAIL;
 			goto exit;
 		}
 
-		psetstakey_para = (struct set_stakey_parm *)kzalloc(sizeof(struct set_stakey_parm), GFP_ATOMIC);
+		psetstakey_para = kzalloc(sizeof(*psetstakey_para), GFP_ATOMIC);
 		if (psetstakey_para == NULL) {
 			kfree(ph2c);
 			res = _FAIL;
 			goto exit;
 		}
 
-		psetstakey_rsp = (struct set_stakey_rsp *)kzalloc(sizeof(struct set_stakey_rsp), GFP_ATOMIC);
+		psetstakey_rsp = kzalloc(sizeof(*psetstakey_rsp), GFP_ATOMIC);
 		if (psetstakey_rsp == NULL) {
 			kfree(ph2c);
 			kfree(psetstakey_para);
@@ -1076,7 +1108,8 @@ u8 rtw_clearstakey_cmd(struct rtw_adapte
 			goto exit;
 		}
 
-		init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SETSTAKEY_CMD_);
+		init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para,
+					   _SETSTAKEY_CMD_);
 		ph2c->rsp = (u8 *)psetstakey_rsp;
 		ph2c->rspsz = sizeof(struct set_stakey_rsp);
 
@@ -1100,12 +1133,12 @@ u8 rtw_setrttbl_cmd(struct rtw_adapter *
 	struct cmd_priv				*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
-		}
-	psetrttblparm = (struct setratable_parm *)kzalloc(sizeof(struct setratable_parm), GFP_ATOMIC);
+	}
+	psetrttblparm = kzalloc(sizeof(*psetrttblparm), GFP_ATOMIC);
 
 	if (psetrttblparm == NULL) {
 		kfree(ph2c);
@@ -1113,7 +1146,8 @@ u8 rtw_setrttbl_cmd(struct rtw_adapter *
 		goto exit;
 	}
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm, GEN_CMD_CODE(_SETRATABLE));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm,
+				   GEN_CMD_CODE(_SETRATABLE));
 
 	memcpy(psetrttblparm, prate_table, sizeof(struct setratable_parm));
 
@@ -1130,12 +1164,12 @@ u8 rtw_getrttbl_cmd(struct rtw_adapter *
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
-	pgetrttblparm = (struct getratable_parm *)kzalloc(sizeof(struct getratable_parm), GFP_ATOMIC);
+	pgetrttblparm = kzalloc(sizeof(*pgetrttblparm), GFP_ATOMIC);
 
 	if (pgetrttblparm == NULL) {
 		kfree(ph2c);
@@ -1146,7 +1180,7 @@ u8 rtw_getrttbl_cmd(struct rtw_adapter *
 	INIT_LIST_HEAD(&ph2c->list);
 	ph2c->cmdcode = GEN_CMD_CODE(_GETRATABLE);
 	ph2c->parmbuf = (unsigned char *)pgetrttblparm;
-	ph2c->cmdsz =  sizeof(struct getratable_parm);
+	ph2c->cmdsz =  sizeof(*pgetrttblparm);
 	ph2c->rsp = (u8 *)pval;
 	ph2c->rspsz = sizeof(struct getratable_rsp);
 
@@ -1167,20 +1201,20 @@ u8 rtw_setassocsta_cmd(struct rtw_adapte
 
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	psetassocsta_para = (struct set_assocsta_parm *)kzalloc(sizeof(struct set_assocsta_parm), GFP_ATOMIC);
+	psetassocsta_para = kzalloc(sizeof(*psetassocsta_para), GFP_ATOMIC);
 	if (psetassocsta_para == NULL) {
 		kfree(ph2c);
 		res = _FAIL;
 		goto exit;
 	}
 
-	psetassocsta_rsp = (struct set_stakey_rsp *)kzalloc(sizeof(struct set_assocsta_rsp), GFP_ATOMIC);
+	psetassocsta_rsp = kzalloc(sizeof(*psetassocsta_para), GFP_ATOMIC);
 	if (psetassocsta_rsp == NULL) {
 		kfree(ph2c);
 		kfree(psetassocsta_para);
@@ -1189,7 +1223,7 @@ u8 rtw_setassocsta_cmd(struct rtw_adapte
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, psetassocsta_para, _SETASSOCSTA_CMD_);
 	ph2c->rsp = (u8 *)psetassocsta_rsp;
-	ph2c->rspsz = sizeof(struct set_assocsta_rsp);
+	ph2c->rspsz = sizeof(*psetassocsta_para);
 
 	memcpy(psetassocsta_para->addr, mac_addr, ETH_ALEN);
 
@@ -1198,7 +1232,7 @@ u8 rtw_setassocsta_cmd(struct rtw_adapte
 exit:
 
 	return res;
- }
+}
 
 u8 rtw_addbareq_cmd(struct rtw_adapter *padapter, u8 tid, u8 *addr)
 {
@@ -1208,13 +1242,13 @@ u8 rtw_addbareq_cmd(struct rtw_adapter *
 
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	paddbareq_parm = (struct addBaReq_parm *)kzalloc(sizeof(struct addBaReq_parm), GFP_ATOMIC);
+	paddbareq_parm = kzalloc(sizeof(*paddbareq_parm), GFP_ATOMIC);
 	if (paddbareq_parm == NULL) {
 		kfree(ph2c);
 		res = _FAIL;
@@ -1224,7 +1258,8 @@ u8 rtw_addbareq_cmd(struct rtw_adapter *
 	paddbareq_parm->tid = tid;
 	memcpy(paddbareq_parm->addr, addr, ETH_ALEN);
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, paddbareq_parm, GEN_CMD_CODE(_ADDBAREQ));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, paddbareq_parm,
+				   GEN_CMD_CODE(_ADDBAREQ));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
@@ -1240,22 +1275,23 @@ u8 rtw_dynamic_chk_wk_cmd(struct rtw_ada
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	if ((padapter->bDriverStopped == true) ||
-	    (padapter->bSurpriseRemoved == true))
+	if ((padapter->bDriverStopped) ||
+	    (padapter->bSurpriseRemoved))
 		goto exit;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if (padapter->adapter_type != PRIMARY_ADAPTER && padapter->pbuddy_adapter)
+	if (padapter->adapter_type != PRIMARY_ADAPTER &&
+	    padapter->pbuddy_adapter)
 		pcmdpriv = &(padapter->pbuddy_adapter->cmdpriv);
 #endif
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);
+	pdrvextra_cmd_parm = kzalloc(sizeof(*pdrvextra_cmd_parm), GFP_ATOMIC);
 	if (pdrvextra_cmd_parm == NULL) {
 		kfree(ph2c);
 		res = _FAIL;
@@ -1266,7 +1302,8 @@ u8 rtw_dynamic_chk_wk_cmd(struct rtw_ada
 	pdrvextra_cmd_parm->type_size = 0;
 	pdrvextra_cmd_parm->pbuf = (u8 *)padapter;
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm,
+				   GEN_CMD_CODE(_SET_DRV_EXTRA));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
@@ -1274,7 +1311,8 @@ exit:
 	return res;
 }
 
-u8 rtw_set_ch_cmd(struct rtw_adapter *padapter, u8 ch, u8 bw, u8 ch_offset, u8 enqueue)
+u8 rtw_set_ch_cmd(struct rtw_adapter *padapter, u8 ch, u8 bw, u8 ch_offset,
+		  u8 enqueue)
 {
 	struct cmd_obj *pcmdobj;
 	struct set_ch_parm *set_ch_parm;
@@ -1288,7 +1326,7 @@ u8 rtw_set_ch_cmd(struct rtw_adapter *pa
 	/* check input parameter */
 
 	/* prepare cmd parameter */
-	set_ch_parm = (struct set_ch_parm *)kzalloc(sizeof(*set_ch_parm), GFP_ATOMIC);
+	set_ch_parm = kzalloc(sizeof(*set_ch_parm), GFP_ATOMIC);
 	if (set_ch_parm == NULL) {
 		res = _FAIL;
 		goto exit;
@@ -1299,17 +1337,18 @@ u8 rtw_set_ch_cmd(struct rtw_adapter *pa
 
 	if (enqueue) {
 		/* need enqueue, prepare cmd_obj and enqueue */
-		pcmdobj = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+		pcmdobj = kzalloc(sizeof(*pcmdobj), GFP_ATOMIC);
 		if (pcmdobj == NULL) {
 			kfree(set_ch_parm);
 			res = _FAIL;
 			goto exit;
 		}
 
-		init_h2fwcmd_w_parm_no_rsp(pcmdobj, set_ch_parm, GEN_CMD_CODE(_SETCHANNEL));
+		init_h2fwcmd_w_parm_no_rsp(pcmdobj, set_ch_parm,
+					   GEN_CMD_CODE(_SETCHANNEL));
 		res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
 	} else {
-		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
+		/* no need to enqueue, do the cmd hdl directly */
 		if (H2C_SUCCESS != set_ch_hdl(padapter, (u8 *)set_ch_parm))
 			res = _FAIL;
 
@@ -1320,7 +1359,8 @@ u8 rtw_set_ch_cmd(struct rtw_adapter *pa
 
 exit:
 
-	DBG_8192D(FUNC_NDEV_FMT" res:%u\n", FUNC_NDEV_ARG(padapter->pnetdev), res);
+	DBG_8192D(FUNC_NDEV_FMT" res:%u\n",
+		  FUNC_NDEV_ARG(padapter->pnetdev), res);
 
 	return res;
 }
@@ -1333,7 +1373,8 @@ u8 rtw_set_chplan_cmd(struct rtw_adapter
 
 	u8 res = _SUCCESS;
 
-	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_chplan_cmd\n"));
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_,
+		 ("+rtw_set_chplan_cmd\n"));
 
 	/* check input parameter */
 	if (!rtw_is_channel_plan_valid(chplan)) {
@@ -1342,7 +1383,8 @@ u8 rtw_set_chplan_cmd(struct rtw_adapter
 	}
 
 	/* prepare cmd parameter */
-	setchannelplan_param = (struct setchannelplan_param *)kzalloc(sizeof(struct setchannelplan_param), GFP_ATOMIC);
+	setchannelplan_param = kzalloc(sizeof(*setchannelplan_param),
+				       GFP_ATOMIC);
 	if (setchannelplan_param == NULL) {
 		res = _FAIL;
 		goto exit;
@@ -1351,18 +1393,20 @@ u8 rtw_set_chplan_cmd(struct rtw_adapter
 
 	if (enqueue) {
 		/* need enqueue, prepare cmd_obj and enqueue */
-		pcmdobj = (struct cmd_obj *)kzalloc(sizeof(struct	cmd_obj), GFP_ATOMIC);
+		pcmdobj = kzalloc(sizeof(*pcmdobj), GFP_ATOMIC);
 		if (pcmdobj == NULL) {
 			kfree(setchannelplan_param);
 			res = _FAIL;
 			goto exit;
 		}
 
-		init_h2fwcmd_w_parm_no_rsp(pcmdobj, setchannelplan_param, GEN_CMD_CODE(_SETCHANNELPLAN));
+		init_h2fwcmd_w_parm_no_rsp(pcmdobj, setchannelplan_param,
+					   GEN_CMD_CODE(_SETCHANNELPLAN));
 		res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
 	} else {
-		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
-		if (H2C_SUCCESS != set_chplan_hdl(padapter, (unsigned char *)setchannelplan_param))
+		/* no need to enqueue, do the cmd hdl directly */
+		if (H2C_SUCCESS != set_chplan_hdl(padapter,
+						  (unsigned char *)setchannelplan_param))
 			res = _FAIL;
 
 		kfree(setchannelplan_param);
@@ -1377,32 +1421,34 @@ exit:
 	return res;
 }
 
-u8 rtw_led_blink_cmd(struct rtw_adapter *padapter, struct LED_871X *pLed)
+u8 rtw_led_blink_cmd(struct rtw_adapter *padapter, struct LED_871X *pled)
 {
 	struct cmd_obj *pcmdobj;
-	struct ledblink_param *ledBlink_param;
+	struct ledblink_param *ledblink_param;
 	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
 
 	u8 res = _SUCCESS;
 
-	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_led_blink_cmd\n"));
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_,
+		 ("+rtw_led_blink_cmd\n"));
 
-	pcmdobj = (struct cmd_obj *)kzalloc(sizeof(struct	cmd_obj), GFP_ATOMIC);
+	pcmdobj = kzalloc(sizeof(*pcmdobj), GFP_ATOMIC);
 	if (pcmdobj == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	ledBlink_param = (struct ledblink_param *)kzalloc(sizeof(struct	ledblink_param), GFP_ATOMIC);
-	if (ledBlink_param == NULL) {
+	ledblink_param = kzalloc(sizeof(*ledblink_param), GFP_ATOMIC);
+	if (ledblink_param == NULL) {
 		kfree(pcmdobj);
 		res = _FAIL;
 		goto exit;
 	}
 
-	ledBlink_param->pLed = pLed;
+	ledblink_param->pled = pled;
 
-	init_h2fwcmd_w_parm_no_rsp(pcmdobj, ledBlink_param, GEN_CMD_CODE(_LEDBLINK));
+	init_h2fwcmd_w_parm_no_rsp(pcmdobj, ledblink_param,
+				   GEN_CMD_CODE(_LEDBLINK));
 	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
 
 exit:
@@ -1421,13 +1467,14 @@ u8 rtw_set_csa_cmd(struct rtw_adapter *p
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_csa_cmd\n"));
 
-	pcmdobj = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	pcmdobj = kzalloc(sizeof(*pcmdobj), GFP_ATOMIC);
 	if (pcmdobj == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	setchannelswitch_param = (struct setchannelswitch_param *)kzalloc(sizeof(struct setchannelswitch_param), GFP_ATOMIC);
+	setchannelswitch_param = kzalloc(sizeof(*setchannelswitch_param),
+					 GFP_ATOMIC);
 	if (setchannelswitch_param == NULL) {
 		kfree(pcmdobj);
 		res = _FAIL;
@@ -1436,7 +1483,8 @@ u8 rtw_set_csa_cmd(struct rtw_adapter *p
 
 	setchannelswitch_param->new_ch_no = new_ch_no;
 
-	init_h2fwcmd_w_parm_no_rsp(pcmdobj, setchannelswitch_param, GEN_CMD_CODE(_SETCHANNELSWITCH));
+	init_h2fwcmd_w_parm_no_rsp(pcmdobj, setchannelswitch_param,
+				   GEN_CMD_CODE(_SETCHANNELSWITCH));
 	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
 
 exit:
@@ -1459,12 +1507,14 @@ u8 rtw_tdls_cmd(struct rtw_adapter *pada
 static void traffic_status_watchdog(struct rtw_adapter *padapter)
 {
 	u8 enterps;
-	u8 bBusyTraffic = false, bTxBusyTraffic = false, bRxBusyTraffic = false;
-	u8 bHigherBusyTraffic = false, bHigherBusyRxTraffic = false, bHigherBusyTxTraffic = false;
-	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+	u8 bBusyTraffic = false, bTxBusyTraffic = false;
+	u8 bRxBusyTraffic = false;
+	u8 bHigherBusyTraffic = false, bHigherBusyRxTraffic = false;
+	u8 bHigherBusyTxTraffic = false;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
 	/*  Determine if our traffic is busy now */
-	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+	if ((check_fwstate(pmlmepriv, _FW_LINKED))) {
 		if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 100 ||
 		    pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 100) {
 			bBusyTraffic = true;
@@ -1491,7 +1541,8 @@ static void traffic_status_watchdog(stru
 		}
 
 		/*  check traffic for  powersaving. */
-		if (((pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod + pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) > 8) ||
+		if (((pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod +
+		      pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) > 8) ||
 		    (pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2))
 			enterps = false;
 		else
@@ -1521,8 +1572,8 @@ static void dynamic_chk_wk_hdl(struct rt
 {
 	struct mlme_priv *pmlmepriv;
 
-	if ((padapter->bDriverStopped == true) ||
-	    (padapter->bSurpriseRemoved == true))
+	if ((padapter->bDriverStopped) ||
+	    (padapter->bSurpriseRemoved))
 		return;
 
 	if ((void *)padapter != (void *)pbuf && padapter->pbuddy_adapter == NULL)
@@ -1530,14 +1581,14 @@ static void dynamic_chk_wk_hdl(struct rt
 
 	padapter = (struct rtw_adapter *)pbuf;
 
-	if ((padapter->bDriverStopped == true) ||
-	    (padapter->bSurpriseRemoved == true))
+	if ((padapter->bDriverStopped) ||
+	    (padapter->bSurpriseRemoved))
 		return;
 
 	pmlmepriv = &(padapter->mlmepriv);
 
 #ifdef CONFIG_92D_AP_MODE
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE))
 		expire_timeout_chk(padapter);
 #endif
 	linked_status_chk(padapter);
@@ -1552,8 +1603,8 @@ static void lps_ctrl_wk_hdl(struct rtw_a
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	u8 mstatus;
 
-	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
-	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)))
 		return;
 
 	switch (lps_ctrl_type) {
@@ -1567,12 +1618,14 @@ static void lps_ctrl_wk_hdl(struct rtw_a
 		mstatus = 1;
 		/*  Reset LPS Setting */
 		padapter->pwrctrlpriv.LpsIdleCount = 0;
-		rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));
+		rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT,
+				  (u8 *)(&mstatus));
 		break;
 	case LPS_CTRL_DISCONNECT:
 		mstatus = 0;
 		rtw_lps_leave(padapter);
-		rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));
+		rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT,
+				  (u8 *)(&mstatus));
 		break;
 	case LPS_CTRL_SPECIAL_PACKET:
 		pwrpriv->DelayLPSLastTimeStamp = rtw_get_current_time();
@@ -1582,10 +1635,10 @@ static void lps_ctrl_wk_hdl(struct rtw_a
 	default:
 		break;
 	}
-
 }
 
-u8 rtw_lps_ctrl_wk_cmd(struct rtw_adapter *padapter, u8 lps_ctrl_type, u8 enqueue)
+u8 rtw_lps_ctrl_wk_cmd(struct rtw_adapter *padapter, u8 lps_ctrl_type,
+		       u8 enqueue)
 {
 	struct cmd_obj *ph2c;
 	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
@@ -1598,13 +1651,14 @@ u8 rtw_lps_ctrl_wk_cmd(struct rtw_adapte
 #endif
 
 	if (enqueue) {
-		ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+		ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 		if (ph2c == NULL) {
 			res = _FAIL;
 			goto exit;
 		}
 
-		pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);
+		pdrvextra_cmd_parm = kzalloc(sizeof(*pdrvextra_cmd_parm),
+					     GFP_ATOMIC);
 		if (pdrvextra_cmd_parm == NULL) {
 			kfree(ph2c);
 			res = _FAIL;
@@ -1615,7 +1669,8 @@ u8 rtw_lps_ctrl_wk_cmd(struct rtw_adapte
 		pdrvextra_cmd_parm->type_size = lps_ctrl_type;
 		pdrvextra_cmd_parm->pbuf = NULL;
 
-		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
+		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm,
+					   GEN_CMD_CODE(_SET_DRV_EXTRA));
 
 		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 	} else {
@@ -1633,7 +1688,7 @@ static void power_saving_wk_hdl(struct r
 }
 
 #ifdef CONFIG_P2P
-u8 p2p_protocol_wk_cmd(struct rtw_adapter *padapter, int intCmdType)
+u8 p2p_protocol_wk_cmd(struct rtw_adapter *padapter, int intcmdtype)
 {
 	struct cmd_obj *ph2c;
 	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
@@ -1644,13 +1699,13 @@ u8 p2p_protocol_wk_cmd(struct rtw_adapte
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return res;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);
+	pdrvextra_cmd_parm = kzalloc(sizeof(*pdrvextra_cmd_parm), GFP_ATOMIC);
 	if (pdrvextra_cmd_parm == NULL) {
 		kfree(ph2c);
 		res = _FAIL;
@@ -1658,10 +1713,11 @@ u8 p2p_protocol_wk_cmd(struct rtw_adapte
 	}
 
 	pdrvextra_cmd_parm->ec_id = P2P_PROTO_WK_CID;
-	pdrvextra_cmd_parm->type_size = intCmdType;	/*	As the command tppe. */
-	pdrvextra_cmd_parm->pbuf = NULL;		/*	Must be NULL here */
+	pdrvextra_cmd_parm->type_size = intcmdtype;/* As the command type. */
+	pdrvextra_cmd_parm->pbuf = NULL;	/* Must be NULL here */
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm,
+				   GEN_CMD_CODE(_SET_DRV_EXTRA));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
@@ -1683,13 +1739,13 @@ u8 rtw_ps_cmd(struct rtw_adapter *padapt
 		goto exit;
 #endif
 
-	ppscmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ppscmd = kzalloc(sizeof(*ppscmd), GFP_ATOMIC);
 	if (ppscmd == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);
+	pdrvextra_cmd_parm = kzalloc(sizeof(*pdrvextra_cmd_parm), GFP_ATOMIC);
 	if (pdrvextra_cmd_parm == NULL) {
 		kfree(ppscmd);
 		res = _FAIL;
@@ -1698,7 +1754,8 @@ u8 rtw_ps_cmd(struct rtw_adapter *padapt
 
 	pdrvextra_cmd_parm->ec_id = POWER_SAVING_CTRL_WK_CID;
 	pdrvextra_cmd_parm->pbuf = NULL;
-	init_h2fwcmd_w_parm_no_rsp(ppscmd, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
+	init_h2fwcmd_w_parm_no_rsp(ppscmd, pdrvextra_cmd_parm,
+				   GEN_CMD_CODE(_SET_DRV_EXTRA));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ppscmd);
 
@@ -1742,12 +1799,12 @@ u8 rtw_chk_hi_queue_cmd(struct rtw_adapt
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);
+	pdrvextra_cmd_parm = kzalloc(sizeof(*pdrvextra_cmd_parm), GFP_ATOMIC);
 	if (pdrvextra_cmd_parm == NULL) {
 		kfree(ph2c);
 		res = _FAIL;
@@ -1757,7 +1814,8 @@ u8 rtw_chk_hi_queue_cmd(struct rtw_adapt
 	pdrvextra_cmd_parm->type_size = 0;
 	pdrvextra_cmd_parm->pbuf = NULL;
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm,
+				   GEN_CMD_CODE(_SET_DRV_EXTRA));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
@@ -1773,13 +1831,13 @@ u8 rtw_c2h_wk_cmd(struct rtw_adapter *pa
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);
+	pdrvextra_cmd_parm = kzalloc(sizeof(*pdrvextra_cmd_parm), GFP_ATOMIC);
 	if (pdrvextra_cmd_parm == NULL) {
 		kfree(ph2c);
 		res = _FAIL;
@@ -1790,7 +1848,8 @@ u8 rtw_c2h_wk_cmd(struct rtw_adapter *pa
 	pdrvextra_cmd_parm->type_size = c2h_evt ? 16 : 0;
 	pdrvextra_cmd_parm->pbuf = c2h_evt;
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm,
+				   GEN_CMD_CODE(_SET_DRV_EXTRA));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
@@ -1799,7 +1858,8 @@ exit:
 	return res;
 }
 
-s32 c2h_evt_hdl(struct rtw_adapter *adapter, struct c2h_evt_hdr *c2h_evt, c2h_id_filter filter)
+s32 c2h_evt_hdl(struct rtw_adapter *adapter, struct c2h_evt_hdr *c2h_evt,
+		c2h_id_filter filter)
 {
 	s32 ret = _FAIL;
 	u8 buf[16];
@@ -1809,13 +1869,13 @@ s32 c2h_evt_hdl(struct rtw_adapter *adap
 		if (c2h_evt_read(adapter, buf) == _SUCCESS) {
 			c2h_evt = (struct c2h_evt_hdr *)buf;
 
-			if (filter && filter(c2h_evt->id) == false)
+			if (filter && !filter(c2h_evt->id))
 				goto exit;
 
 			ret = rtw_hal_c2h_handler(adapter, c2h_evt);
 		}
 	} else {
-		if (filter && filter(c2h_evt->id) == false)
+		if (filter && !filter(c2h_evt->id))
 			goto exit;
 		ret = rtw_hal_c2h_handler(adapter, c2h_evt);
 	}
@@ -1834,10 +1894,12 @@ u8 rtw_drvextra_cmd_hdl(struct rtw_adapt
 
 	switch (pdrvextra_cmd->ec_id) {
 	case DYNAMIC_CHK_WK_CID:
-		dynamic_chk_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
+		dynamic_chk_wk_hdl(padapter, pdrvextra_cmd->pbuf,
+				   pdrvextra_cmd->type_size);
 		break;
 	case POWER_SAVING_CTRL_WK_CID:
-		power_saving_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
+		power_saving_wk_hdl(padapter, pdrvextra_cmd->pbuf,
+				    pdrvextra_cmd->type_size);
 		break;
 	case LPS_CTRL_WK_CID:
 		lps_ctrl_wk_hdl(padapter, (u8)pdrvextra_cmd->type_size);
@@ -1848,7 +1910,6 @@ u8 rtw_drvextra_cmd_hdl(struct rtw_adapt
 		break;
 #endif /*  CONFIG_P2P_PS */
 	case P2P_PROTO_WK_CID:
-		/*	Commented by Albert 2011/07/01 */
 		/*	I used the type_size as the type command */
 		p2p_protocol_wk_hdl(padapter, pdrvextra_cmd->type_size);
 		break;
@@ -1870,25 +1931,28 @@ u8 rtw_drvextra_cmd_hdl(struct rtw_adapt
 	return H2C_SUCCESS;
 }
 
-void rtw_survey_cmd_callback(struct rtw_adapter *padapter ,  struct cmd_obj *pcmd)
+void rtw_survey_cmd_callback(struct rtw_adapter *padapter,
+			     struct cmd_obj *pcmd)
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
 	if (pcmd->res == H2C_DROPPED) {
-		/* TODO: cancel timer and do timeout handler directly... */
-		/* need to make timeout handlerOS independent */
+		/* TODO: cancel timer and do timeout handler directly...
+		 * need to make timeout handlerOS independent
+		 */
 		_set_timer(&pmlmepriv->scan_to_timer, 1);
 	} else if (pcmd->res != H2C_SUCCESS) {
 		_set_timer(&pmlmepriv->scan_to_timer, 1);
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ********Error: MgntActrtw_set_802_11_bssid_LIST_SCAN Fail ************\n\n."));
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+			 ("\n ********Error: MgntActrtw_set_802_11_bssid_LIST_SCAN Fail ************\n\n."));
 	}
 
 	/*  free cmd */
 	rtw_free_cmd_obj(pcmd);
-
 }
 
-void rtw_disassoc_cmd_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
+void rtw_disassoc_cmd_callback(struct rtw_adapter *padapter,
+			       struct cmd_obj *pcmd)
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
@@ -1897,31 +1961,35 @@ void rtw_disassoc_cmd_callback(struct rt
 		set_fwstate(pmlmepriv, _FW_LINKED);
 		spin_unlock_bh(&pmlmepriv->lock);
 
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ***Error: disconnect_cmd_callback Fail ***\n."));
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+			 ("\n ***Error: disconnect_cmd_callback Fail ***\n."));
 		return;
 	}
 	/*  free cmd */
 	rtw_free_cmd_obj(pcmd);
 }
 
-void rtw_joinbss_cmd_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
+void rtw_joinbss_cmd_callback(struct rtw_adapter *padapter,
+			      struct cmd_obj *pcmd)
 {
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
 	if (pcmd->res == H2C_DROPPED) {
-		/* TODO: cancel timer and do timeout handler directly... */
-		/* need to make timeout handlerOS independent */
+		/* TODO: cancel timer and do timeout handler directly...
+		 * need to make timeout handlerOS independent
+		 */
 		_set_timer(&pmlmepriv->assoc_timer, 1);
 	} else if (pcmd->res != H2C_SUCCESS) {
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("********Error:rtw_select_and_join_from_scanned_queue Wait Sema  Fail ************\n"));
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+			 ("********Error:rtw_select_and_join_from_scanned_queue Wait Sema  Fail ************\n"));
 		_set_timer(&pmlmepriv->assoc_timer, 1);
 	}
 
 	rtw_free_cmd_obj(pcmd);
-
 }
 
-void rtw_createbss_cmd_callback(struct rtw_adapter *padapter, struct cmd_obj *pcmd)
+void rtw_createbss_cmd_callback(struct rtw_adapter *padapter,
+				struct cmd_obj *pcmd)
 {
 	u8 timer_cancelled;
 	struct sta_info *psta = NULL;
@@ -1930,36 +1998,23 @@ void rtw_createbss_cmd_callback(struct r
 	struct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)pcmd->parmbuf;
 	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
 
-	if ((pcmd->res != H2C_SUCCESS)) {
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ********Error: rtw_createbss_cmd_callback  Fail ************\n\n."));
+	if (pcmd->res != H2C_SUCCESS) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+			 ("\n ********Error: rtw_createbss_cmd_callback  Fail ************\n\n"));
 		_set_timer(&pmlmepriv->assoc_timer, 1);
 	}
 	_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
 
-#ifdef CONFIG_FW_MLMLE
-       /* endian_convert */
-	pnetwork->Length = le32_to_cpu(pnetwork->Length);
-	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
-	pnetwork->Privacy = le32_to_cpu(pnetwork->Privacy);
-	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
-	pnetwork->NetworkTypeInUse = le32_to_cpu(pnetwork->NetworkTypeInUse);
-	pnetwork->Configuration.ATIMWindow = le32_to_cpu(pnetwork->Configuration.ATIMWindow);
-	pnetwork->Configuration.DSConfig = le32_to_cpu(pnetwork->Configuration.DSConfig);
-	pnetwork->Configuration.FHConfig.DwellTime = le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
-	pnetwork->Configuration.FHConfig.HopPattern = le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
-	pnetwork->Configuration.FHConfig.HopSet = le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
-	pnetwork->Configuration.FHConfig.Length = le32_to_cpu(pnetwork->Configuration.FHConfig.Length);
-	pnetwork->Configuration.Length = le32_to_cpu(pnetwork->Configuration.Length);
-	pnetwork->InfrastructureMode = le32_to_cpu(pnetwork->InfrastructureMode);
-	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
-#endif
 	spin_lock_bh(&pmlmepriv->lock);
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
-		psta = rtw_get_stainfo(&padapter->stapriv, pnetwork->MacAddress);
+		psta = rtw_get_stainfo(&padapter->stapriv,
+				       pnetwork->MacAddress);
 		if (!psta) {
-			psta = rtw_alloc_stainfo(&padapter->stapriv, pnetwork->MacAddress);
+			psta = rtw_alloc_stainfo(&padapter->stapriv,
+						 pnetwork->MacAddress);
 			if (psta == NULL) {
-				RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nCan't alloc sta_info when createbss_cmd_callback\n"));
+				RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+					 ("\nCan't alloc sta_info when createbss_cmd_callback\n"));
 				goto createbss_cmd_fail;
 			}
 		}
@@ -1970,25 +2025,30 @@ void rtw_createbss_cmd_callback(struct r
 		if (pwlan == NULL) {
 			pwlan = rtw_get_oldest_wlan_network(&pmlmepriv->scanned_queue);
 			if (pwlan == NULL) {
-				RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n Error:  can't get pwlan in rtw_joinbss_event_callback\n"));
+				RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+					 ("\n Error:  can't get pwlan in rtw_joinbss_event_callback\n"));
 				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 				goto createbss_cmd_fail;
 			}
 			pwlan->last_scanned = rtw_get_current_time();
 		} else {
-			rtw_list_insert_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
+			rtw_list_insert_tail(&(pwlan->list),
+					     &pmlmepriv->scanned_queue.queue);
 		}
 
 		pnetwork->Length = get_wlan_bssid_ex_sz(pnetwork);
 		memcpy(&(pwlan->network), pnetwork, pnetwork->Length);
 
-		/*  copy pdev_network information to	pmlmepriv->cur_network */
-		memcpy(&tgt_network->network, pnetwork, (get_wlan_bssid_ex_sz(pnetwork)));
+		/*  copy pdev_network information to pmlmepriv->cur_network */
+		memcpy(&tgt_network->network, pnetwork,
+		       get_wlan_bssid_ex_sz(pnetwork));
 
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
 		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-		/*  we will set _FW_LINKED when there is one more sat to join us (rtw_stassoc_event_callback) */
+		/* we will set _FW_LINKED when there is one more sat to join us
+		 * (rtw_stassoc_event_callback)
+		 */
 	}
 
 createbss_cmd_fail:
@@ -1996,25 +2056,26 @@ createbss_cmd_fail:
 	spin_unlock_bh(&pmlmepriv->lock);
 
 	rtw_free_cmd_obj(pcmd);
-
 }
 
-void rtw_setstakey_cmdrsp_callback(struct rtw_adapter *padapter, struct cmd_obj *pcmd)
+void rtw_setstakey_cmdrsp_callback(struct rtw_adapter *padapter,
+				   struct cmd_obj *pcmd)
 {
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct set_stakey_rsp *psetstakey_rsp = (struct set_stakey_rsp *)(pcmd->rsp);
 	struct sta_info *psta = rtw_get_stainfo(pstapriv, psetstakey_rsp->addr);
 
 	if (psta == NULL) {
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nERROR: rtw_setstaKey_cmdrsp_callback => can't get sta_info\n\n"));
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+			 ("\nERROR: rtw_setstaKey_cmdrsp_callback => can't get sta_info\n\n"));
 		goto exit;
 	}
 exit:
 	rtw_free_cmd_obj(pcmd);
-
 }
 
-void rtw_setassocsta_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
+void rtw_setassocsta_cmdrsp_callback(struct rtw_adapter *padapter,
+				     struct cmd_obj *pcmd)
 {
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -2023,7 +2084,8 @@ void rtw_setassocsta_cmdrsp_callback(str
 	struct sta_info *psta = rtw_get_stainfo(pstapriv, passocsta_parm->addr);
 
 	if (psta == NULL) {
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nERROR: setassocsta_cmdrsp_callbac => can't get sta_info\n\n"));
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+			 ("\nERROR: setassocsta_cmdrsp_callbac => can't get sta_info\n\n"));
 		goto exit;
 	}
 
@@ -2032,7 +2094,8 @@ void rtw_setassocsta_cmdrsp_callback(str
 
 	spin_lock_bh(&pmlmepriv->lock);
 
-	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) && (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true))
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE)) &&
+	    (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)))
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
 	set_fwstate(pmlmepriv, _FW_LINKED);
@@ -2040,12 +2103,10 @@ void rtw_setassocsta_cmdrsp_callback(str
 
 exit:
 	rtw_free_cmd_obj(pcmd);
-
 }
 
-static void rtw_getrttbl_cmd_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
+static void rtw_getrttbl_cmd_cmdrsp_callback(struct rtw_adapter *padapter,
+					     struct cmd_obj *pcmd)
 {
-
 	rtw_free_cmd_obj(pcmd);
-
 }
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -11960,7 +11960,7 @@ u8 led_blink_hdl(struct rtw_adapter *ada
 
 #ifdef CONFIG_LED_HANDLED_BY_CMD_THREAD
 	ledBlink_param = (struct LedBlink_param *)pbuf;
-	BlinkHandler(ledBlink_param->pLed);
+	BlinkHandler(ledBlink_param->pled);
 #endif
 	return H2C_SUCCESS;
 }
--- a/drivers/staging/rtl8192du/hal/rtl8192du_led.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_led.c
@@ -43,7 +43,7 @@
 /*	Prototype of protected function. */
 /*  */
 
-static void BlinkTimerCallback(unsigned long data);
+static void blinktimerCallback(unsigned long data);
 
 static void
 BlinkWorkItemCallback(
@@ -51,18 +51,18 @@ BlinkWorkItemCallback(
 	);
 
 static void
-ResetLedStatus(struct LED_871X *	pLed) {
-	pLed->CurrLedState = RTW_LED_OFF; /*  Current LED state. */
-	pLed->bLedOn = false; /*  true if LED is ON, false if LED is OFF. */
-
-	pLed->bLedBlinkInProgress = false; /*  true if it is blinking, false o.w.. */
-	pLed->bLedNoLinkBlinkInProgress = false;
-	pLed->bLedLinkBlinkInProgress = false;
-	pLed->bLedStartToLinkBlinkInProgress = false;
-	pLed->bLedScanBlinkInProgress = false;
-	pLed->bLedWPSBlinkInProgress = false;
-	pLed->BlinkTimes = 0; /*  Number of times to toggle led state for blinking. */
-	pLed->BlinkingLedState = LED_UNKNOWN; /*  Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are. */
+ResetLedStatus(struct LED_871X *	pled) {
+	pled->currledstate = RTW_LED_OFF; /*  Current LED state. */
+	pled->led_on = false; /*  true if LED is ON, false if LED is OFF. */
+
+	pled->blink_in_prog = false; /*  true if it is blinking, false o.w.. */
+	pled->nolink_blink_in_prog = false;
+	pled->link_blink_in_prog = false;
+	pled->start_link_blink_in_prog = false;
+	pled->scan_blink_in_prog = false;
+	pled->wps_blink_in_prog = false;
+	pled->blinktimes = 0; /*  Number of times to toggle led state for blinking. */
+	pled->blinkingledstate = LED_UNKNOWN; /*  Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are. */
 }
 
 /*  */
@@ -75,40 +75,40 @@ ResetLedStatus(struct LED_871X *	pLed) {
 /*  */
 
 static void InitLed871x(struct rtw_adapter *padapter,
-	struct LED_871X *		pLed,
+	struct LED_871X *		pled,
 	enum LED_PIN_871X	LedPin
 	)
 {
-	pLed->padapter = padapter;
+	pled->padapter = padapter;
 
-	pLed->LedPin = LedPin;
+	pled->LedPin = LedPin;
 
-	pLed->CurrLedState = RTW_LED_OFF;
-	pLed->bLedOn = false;
+	pled->currledstate = RTW_LED_OFF;
+	pled->led_on = false;
 
-	pLed->bLedBlinkInProgress = false;
-	pLed->BlinkTimes = 0;
-	pLed->BlinkingLedState = LED_UNKNOWN;
+	pled->blink_in_prog = false;
+	pled->blinktimes = 0;
+	pled->blinkingledstate = LED_UNKNOWN;
 
-	_init_timer(&(pLed->BlinkTimer), padapter->pnetdev, BlinkTimerCallback, pLed);
+	_init_timer(&(pled->blinktimer), padapter->pnetdev, blinktimerCallback, pled);
 
-	_init_workitem(&(pLed->BlinkWorkItem), BlinkWorkItemCallback, pLed);
+	_init_workitem(&(pled->BlinkWorkItem), BlinkWorkItemCallback, pled);
 }
 
 /*  */
 /*	Description: */
 /*		DeInitialize an struct LED_871X object. */
 /*  */
-static void DeInitLed871x(struct LED_871X *pLed)
+static void DeInitLed871x(struct LED_871X *pled)
 {
-	/* call _cancel_workitem_sync(&(pLed->BlinkWorkItem)) */
-    /* before _cancel_timer_ex(&(pLed->BlinkTimer)) to */
+	/* call _cancel_workitem_sync(&(pled->BlinkWorkItem)) */
+    /* before _cancel_timer_ex(&(pled->blinktimer)) to */
     /* avoid led timer restarting when driver is removed */
 
-	_cancel_workitem_sync(&(pLed->BlinkWorkItem));
-	_cancel_timer_ex(&(pLed->BlinkTimer));
-	/*  We should reset bLedBlinkInProgress if we cancel the LedControlTimer, 2005.03.10, by rcnjko. */
-	ResetLedStatus(pLed);
+	_cancel_workitem_sync(&(pled->BlinkWorkItem));
+	_cancel_timer_ex(&(pled->blinktimer));
+	/*  We should reset blink_in_prog if we cancel the LedControlTimer, 2005.03.10, by rcnjko. */
+	ResetLedStatus(pled);
 }
 
 /*  */
@@ -116,7 +116,7 @@ static void DeInitLed871x(struct LED_871
 /*		Turn on LED according to LedPin specified. */
 /*  */
 
-static void SwLedOn(struct rtw_adapter *padapter, struct LED_871X *pLed)
+static void SwLedOn(struct rtw_adapter *padapter, struct LED_871X *pled)
 {
 	u8	LedCfg;
 
@@ -125,7 +125,7 @@ static void SwLedOn(struct rtw_adapter *
 		return;
 	}
 
-	switch (pLed->LedPin)
+	switch (pled->LedPin)
 	{
 		case LED_PIN_GPIO0:
 			break;
@@ -146,14 +146,14 @@ static void SwLedOn(struct rtw_adapter *
 			break;
 	}
 
-	pLed->bLedOn = true;
+	pled->led_on = true;
 }
 
 /*  */
 /*	Description: */
 /*		Turn off LED according to LedPin specified. */
 /*  */
-static void SwLedOff(struct rtw_adapter *padapter, struct LED_871X *pLed)
+static void SwLedOff(struct rtw_adapter *padapter, struct LED_871X *pled)
 {
 	u8	LedCfg;
 
@@ -162,7 +162,7 @@ static void SwLedOff(struct rtw_adapter
              return;
 	}
 
-	switch (pLed->LedPin)
+	switch (pled->LedPin)
 	{
 		case LED_PIN_GPIO0:
 			break;
@@ -185,7 +185,7 @@ static void SwLedOff(struct rtw_adapter
 			break;
 	}
 
-	pLed->bLedOn = false;
+	pled->led_on = false;
 }
 
 /*  */
@@ -193,31 +193,31 @@ static void SwLedOff(struct rtw_adapter
 /*		Implementation of LED blinking behavior. */
 /*		It toggle off LED and schedule corresponding timer if necessary. */
 /*  */
-static void SwLedBlink(struct LED_871X *pLed)
+static void SwLedBlink(struct LED_871X *pled)
 {
-	struct rtw_adapter			*padapter = pLed->padapter;
+	struct rtw_adapter			*padapter = pled->padapter;
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	u8				bStopBlinking = false;
 
-	/*  Change LED according to BlinkingLedState specified. */
-	if (pLed->BlinkingLedState == RTW_LED_ON)
+	/*  Change LED according to blinkingledstate specified. */
+	if (pled->blinkingledstate == RTW_LED_ON)
 	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+		SwLedOn(padapter, pled);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pled->blinktimes));
 	}
 	else
 	{
-		SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+		SwLedOff(padapter, pled);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pled->blinktimes));
 	}
 
 	/*  Determine if we shall change LED state again. */
-	pLed->BlinkTimes--;
-	switch (pLed->CurrLedState)
+	pled->blinktimes--;
+	switch (pled->currledstate)
 	{
 
 	case LED_BLINK_NORMAL:
-		if (pLed->BlinkTimes == 0)
+		if (pled->blinktimes == 0)
 		{
 			bStopBlinking = true;
 		}
@@ -233,14 +233,14 @@ static void SwLedBlink(struct LED_871X *
 		{
 			bStopBlinking = true;
 		}
-		else if (pLed->BlinkTimes == 0)
+		else if (pled->blinktimes == 0)
 		{
 			bStopBlinking = true;
 		}
 		break;
 
 	case LED_BLINK_WPS:
-		if (pLed->BlinkTimes == 0)
+		if (pled->blinktimes == 0)
 		{
 			bStopBlinking = true;
 		}
@@ -256,127 +256,127 @@ static void SwLedBlink(struct LED_871X *
 	{
 		if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 		{
-			SwLedOff(padapter, pLed);
+			SwLedOff(padapter, pled);
 		}
-		else if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) && (pLed->bLedOn == false))
+		else if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) && (pled->led_on == false))
 		{
-			SwLedOn(padapter, pLed);
+			SwLedOn(padapter, pled);
 		}
-		else if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) &&  pLed->bLedOn == true)
+		else if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) &&  pled->led_on == true)
 		{
-			SwLedOff(padapter, pLed);
+			SwLedOff(padapter, pled);
 		}
 
-		pLed->BlinkTimes = 0;
-		pLed->bLedBlinkInProgress = false;
+		pled->blinktimes = 0;
+		pled->blink_in_prog = false;
 	}
 	else
 	{
 		/*  Assign LED state to toggle. */
-		if (pLed->BlinkingLedState == RTW_LED_ON)
-			pLed->BlinkingLedState = RTW_LED_OFF;
+		if (pled->blinkingledstate == RTW_LED_ON)
+			pled->blinkingledstate = RTW_LED_OFF;
 		else
-			pLed->BlinkingLedState = RTW_LED_ON;
+			pled->blinkingledstate = RTW_LED_ON;
 
 		/*  Schedule a timer to toggle LED state. */
-		switch (pLed->CurrLedState)
+		switch (pled->currledstate)
 		{
 		case LED_BLINK_NORMAL:
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			_set_timer(&(pled->blinktimer), LED_BLINK_NORMAL_INTERVAL);
 			break;
 
 		case LED_BLINK_SLOWLY:
 		case LED_BLINK_StartToBlink:
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			_set_timer(&(pled->blinktimer), LED_BLINK_SLOWLY_INTERVAL);
 			break;
 
 		case LED_BLINK_WPS:
 			{
-				if (pLed->BlinkingLedState == RTW_LED_ON)
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+				if (pled->blinkingledstate == RTW_LED_ON)
+					_set_timer(&(pled->blinktimer), LED_BLINK_LONG_INTERVAL);
 				else
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+					_set_timer(&(pled->blinktimer), LED_BLINK_LONG_INTERVAL);
 			}
 			break;
 
 		default:
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			_set_timer(&(pled->blinktimer), LED_BLINK_SLOWLY_INTERVAL);
 			break;
 		}
 	}
 }
 
-static void SwLedBlink1(struct LED_871X *pLed)
+static void SwLedBlink1(struct LED_871X *pled)
 {
-	struct rtw_adapter				*padapter = pLed->padapter;
+	struct rtw_adapter				*padapter = pled->padapter;
 	struct hal_data_8192du		*pHalData = GET_HAL_DATA(padapter);
 	struct led_priv		*ledpriv = &(padapter->ledpriv);
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
-	struct LED_871X *			pLed1 = &(ledpriv->SwLed1);
+	struct LED_871X *			pled1 = &(ledpriv->SwLed1);
 	u8					bStopBlinking = false;
 
 	if (pHalData->CustomerID == RT_CID_819x_CAMEO)
-		pLed = &(ledpriv->SwLed1);
+		pled = &(ledpriv->SwLed1);
 
-	/*  Change LED according to BlinkingLedState specified. */
-	if (pLed->BlinkingLedState == RTW_LED_ON)
+	/*  Change LED according to blinkingledstate specified. */
+	if (pled->blinkingledstate == RTW_LED_ON)
 	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+		SwLedOn(padapter, pled);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pled->blinktimes));
 	}
 	else
 	{
-		SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+		SwLedOff(padapter, pled);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pled->blinktimes));
 	}
 
 	if (pHalData->CustomerID == RT_CID_DEFAULT)
 	{
 		if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 		{
-			if (!pLed1->bSWLedCtrl)
+			if (!pled1->bSWLedCtrl)
 			{
-				SwLedOn(padapter, pLed1);
-				pLed1->bSWLedCtrl = true;
+				SwLedOn(padapter, pled1);
+				pled1->bSWLedCtrl = true;
 			}
-			else if (!pLed1->bLedOn)
-				SwLedOn(padapter, pLed1);
-			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn on pLed1\n"));
+			else if (!pled1->led_on)
+				SwLedOn(padapter, pled1);
+			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn on pled1\n"));
 		}
 		else
 		{
-			if (!pLed1->bSWLedCtrl)
+			if (!pled1->bSWLedCtrl)
 			{
-				SwLedOff(padapter, pLed1);
-				pLed1->bSWLedCtrl = true;
+				SwLedOff(padapter, pled1);
+				pled1->bSWLedCtrl = true;
 			}
-			else if (pLed1->bLedOn)
-				SwLedOff(padapter, pLed1);
-			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn off pLed1\n"));
+			else if (pled1->led_on)
+				SwLedOff(padapter, pled1);
+			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn off pled1\n"));
 		}
 	}
 
-	switch (pLed->CurrLedState)
+	switch (pled->currledstate)
 	{
 		case LED_BLINK_SLOWLY:
-			if (pLed->bLedOn)
-				pLed->BlinkingLedState = RTW_LED_OFF;
+			if (pled->led_on)
+				pled->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 			break;
 
 		case LED_BLINK_NORMAL:
-			if (pLed->bLedOn)
-				pLed->BlinkingLedState = RTW_LED_OFF;
+			if (pled->led_on)
+				pled->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_LINK_INTERVAL_ALPHA);
 			break;
 
 		case LED_SCAN_BLINK:
-			pLed->BlinkTimes--;
-			if (pLed->BlinkTimes == 0)
+			pled->blinktimes--;
+			if (pled->blinktimes == 0)
 			{
 				bStopBlinking = true;
 			}
@@ -385,53 +385,53 @@ static void SwLedBlink1(struct LED_871X
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
-					pLed->bLedLinkBlinkInProgress = true;
-					pLed->CurrLedState = LED_BLINK_NORMAL;
-					if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					pled->link_blink_in_prog = true;
+					pled->currledstate = LED_BLINK_NORMAL;
+					if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 
 				}
 				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
-					pLed->bLedNoLinkBlinkInProgress = true;
-					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					pled->nolink_blink_in_prog = true;
+					pled->currledstate = LED_BLINK_SLOWLY;
+					if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 				}
-				pLed->bLedScanBlinkInProgress = false;
+				pled->scan_blink_in_prog = false;
 			}
 			else
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					 if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					 if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 				}
 			}
 			break;
 
 		case LED_TXRX_BLINK:
-			pLed->BlinkTimes--;
-			if (pLed->BlinkTimes == 0)
+			pled->blinktimes--;
+			if (pled->blinktimes == 0)
 			{
 				bStopBlinking = true;
 			}
@@ -439,63 +439,63 @@ static void SwLedBlink1(struct LED_871X
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
-					pLed->bLedLinkBlinkInProgress = true;
-					pLed->CurrLedState = LED_BLINK_NORMAL;
-					if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					pled->link_blink_in_prog = true;
+					pled->currledstate = LED_BLINK_NORMAL;
+					if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 				}
 				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
-					pLed->bLedNoLinkBlinkInProgress = true;
-					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					pled->nolink_blink_in_prog = true;
+					pled->currledstate = LED_BLINK_SLOWLY;
+					if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 				}
-				pLed->BlinkTimes = 0;
-				pLed->bLedBlinkInProgress = false;
+				pled->blinktimes = 0;
+				pled->blink_in_prog = false;
 			}
 			else
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					 if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					 if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 			}
 			break;
 
 		case LED_BLINK_WPS:
-			if (pLed->bLedOn)
-				pLed->BlinkingLedState = RTW_LED_OFF;
+			if (pled->led_on)
+				pled->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			break;
 
 		case LED_BLINK_WPS_STOP:	/* WPS success */
-			if (pLed->BlinkingLedState == RTW_LED_ON)
+			if (pled->blinkingledstate == RTW_LED_ON)
 			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_OFF;
+				_set_timer(&(pled->blinktimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
 				bStopBlinking = false;
 			}
 			else
@@ -507,20 +507,20 @@ static void SwLedBlink1(struct LED_871X
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					pLed->bLedLinkBlinkInProgress = true;
-					pLed->CurrLedState = LED_BLINK_NORMAL;
-					if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					pled->link_blink_in_prog = true;
+					pled->currledstate = LED_BLINK_NORMAL;
+					if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 				}
-				pLed->bLedWPSBlinkInProgress = false;
+				pled->wps_blink_in_prog = false;
 			}
 			break;
 
@@ -529,29 +529,29 @@ static void SwLedBlink1(struct LED_871X
 	}
 }
 
-static void SwLedBlink2(struct LED_871X *pLed)
+static void SwLedBlink2(struct LED_871X *pled)
 {
-	struct rtw_adapter				*padapter = pLed->padapter;
+	struct rtw_adapter				*padapter = pled->padapter;
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
 	u8					bStopBlinking = false;
 
-	/*  Change LED according to BlinkingLedState specified. */
-	if (pLed->BlinkingLedState == RTW_LED_ON)
+	/*  Change LED according to blinkingledstate specified. */
+	if (pled->blinkingledstate == RTW_LED_ON)
 	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+		SwLedOn(padapter, pled);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pled->blinktimes));
 	}
 	else
 	{
-		SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+		SwLedOff(padapter, pled);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pled->blinktimes));
 	}
 
-	switch (pLed->CurrLedState)
+	switch (pled->currledstate)
 	{
 		case LED_SCAN_BLINK:
-			pLed->BlinkTimes--;
-			if (pLed->BlinkTimes == 0)
+			pled->blinktimes--;
+			if (pled->blinktimes == 0)
 			{
 				bStopBlinking = true;
 			}
@@ -560,45 +560,45 @@ static void SwLedBlink2(struct LED_871X
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
-					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
-					SwLedOn(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
+					pled->currledstate = RTW_LED_ON;
+					pled->blinkingledstate = RTW_LED_ON;
+					SwLedOn(padapter, pled);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink currledstate %d\n", pled->currledstate));
 
 				}
 				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
-					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					SwLedOff(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
+					pled->currledstate = RTW_LED_OFF;
+					pled->blinkingledstate = RTW_LED_OFF;
+					SwLedOff(padapter, pled);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink currledstate %d\n", pled->currledstate));
 				}
-				pLed->bLedScanBlinkInProgress = false;
+				pled->scan_blink_in_prog = false;
 			}
 			else
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					 if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					 if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 				}
 			}
 			break;
 
 		case LED_TXRX_BLINK:
-			pLed->BlinkTimes--;
-			if (pLed->BlinkTimes == 0)
+			pled->blinktimes--;
+			if (pled->blinktimes == 0)
 			{
 				bStopBlinking = true;
 			}
@@ -606,38 +606,38 @@ static void SwLedBlink2(struct LED_871X
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
-					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
-					SwLedOn(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
+					pled->currledstate = RTW_LED_ON;
+					pled->blinkingledstate = RTW_LED_ON;
+					SwLedOn(padapter, pled);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop currledstate %d\n", pled->currledstate));
 
 				}
 				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
-					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					SwLedOff(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
+					pled->currledstate = RTW_LED_OFF;
+					pled->blinkingledstate = RTW_LED_OFF;
+					SwLedOff(padapter, pled);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop currledstate %d\n", pled->currledstate));
 				}
-				pLed->bLedBlinkInProgress = false;
+				pled->blink_in_prog = false;
 			}
 			else
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					 if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					 if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 			}
 			break;
@@ -647,30 +647,30 @@ static void SwLedBlink2(struct LED_871X
 	}
 }
 
-static void SwLedBlink3(struct LED_871X *pLed)
+static void SwLedBlink3(struct LED_871X *pled)
 {
-	struct rtw_adapter			*padapter = pLed->padapter;
+	struct rtw_adapter			*padapter = pled->padapter;
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	u8				bStopBlinking = false;
 
-	/*  Change LED according to BlinkingLedState specified. */
-	if (pLed->BlinkingLedState == RTW_LED_ON)
+	/*  Change LED according to blinkingledstate specified. */
+	if (pled->blinkingledstate == RTW_LED_ON)
 	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+		SwLedOn(padapter, pled);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pled->blinktimes));
 	}
 	else
 	{
-		if (pLed->CurrLedState != LED_BLINK_WPS_STOP)
-			SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+		if (pled->currledstate != LED_BLINK_WPS_STOP)
+			SwLedOff(padapter, pled);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pled->blinktimes));
 	}
 
-	switch (pLed->CurrLedState)
+	switch (pled->currledstate)
 	{
 		case LED_SCAN_BLINK:
-			pLed->BlinkTimes--;
-			if (pLed->BlinkTimes == 0)
+			pled->blinktimes--;
+			if (pled->blinktimes == 0)
 			{
 				bStopBlinking = true;
 			}
@@ -679,48 +679,48 @@ static void SwLedBlink3(struct LED_871X
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
-					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
-					if (!pLed->bLedOn)
-						SwLedOn(padapter, pLed);
+					pled->currledstate = RTW_LED_ON;
+					pled->blinkingledstate = RTW_LED_ON;
+					if (!pled->led_on)
+						SwLedOn(padapter, pled);
 
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 				}
 				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
-					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					if (pLed->bLedOn)
-						SwLedOff(padapter, pLed);
+					pled->currledstate = RTW_LED_OFF;
+					pled->blinkingledstate = RTW_LED_OFF;
+					if (pled->led_on)
+						SwLedOff(padapter, pled);
 
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 				}
-				pLed->bLedScanBlinkInProgress = false;
+				pled->scan_blink_in_prog = false;
 			}
 			else
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 				}
 			}
 			break;
 
 		case LED_TXRX_BLINK:
-			pLed->BlinkTimes--;
-			if (pLed->BlinkTimes == 0)
+			pled->blinktimes--;
+			if (pled->blinktimes == 0)
 			{
 				bStopBlinking = true;
 			}
@@ -728,60 +728,60 @@ static void SwLedBlink3(struct LED_871X
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
 				{
-					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
+					pled->currledstate = RTW_LED_ON;
+					pled->blinkingledstate = RTW_LED_ON;
 
-					if (!pLed->bLedOn)
-						SwLedOn(padapter, pLed);
+					if (!pled->led_on)
+						SwLedOn(padapter, pled);
 
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 				}
 				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
 				{
-					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pled->currledstate = RTW_LED_OFF;
+					pled->blinkingledstate = RTW_LED_OFF;
 
-					if (pLed->bLedOn)
-						SwLedOff(padapter, pLed);
+					if (pled->led_on)
+						SwLedOff(padapter, pled);
 
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 				}
-				pLed->bLedBlinkInProgress = false;
+				pled->blink_in_prog = false;
 			}
 			else
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 			}
 			break;
 
 		case LED_BLINK_WPS:
-			if (pLed->bLedOn)
-				pLed->BlinkingLedState = RTW_LED_OFF;
+			if (pled->led_on)
+				pled->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			break;
 
 		case LED_BLINK_WPS_STOP:	/* WPS success */
-			if (pLed->BlinkingLedState == RTW_LED_ON)
+			if (pled->blinkingledstate == RTW_LED_ON)
 			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_OFF;
+				_set_timer(&(pled->blinktimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
 				bStopBlinking = false;
 			}
 			else
@@ -793,16 +793,16 @@ static void SwLedBlink3(struct LED_871X
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
-					SwLedOn(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					pled->currledstate = RTW_LED_ON;
+					pled->blinkingledstate = RTW_LED_ON;
+					SwLedOn(padapter, pled);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 				}
-				pLed->bLedWPSBlinkInProgress = false;
+				pled->wps_blink_in_prog = false;
 			}
 			break;
 
@@ -811,58 +811,58 @@ static void SwLedBlink3(struct LED_871X
 	}
 }
 
-static void SwLedBlink4(struct LED_871X *pLed)
+static void SwLedBlink4(struct LED_871X *pled)
 {
-	struct rtw_adapter			*padapter = pLed->padapter;
+	struct rtw_adapter			*padapter = pled->padapter;
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
-	struct LED_871X *		pLed1 = &(ledpriv->SwLed1);
+	struct LED_871X *		pled1 = &(ledpriv->SwLed1);
 	u8				bStopBlinking = false;
 
-	/*  Change LED according to BlinkingLedState specified. */
-	if (pLed->BlinkingLedState == RTW_LED_ON)
+	/*  Change LED according to blinkingledstate specified. */
+	if (pled->blinkingledstate == RTW_LED_ON)
 	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+		SwLedOn(padapter, pled);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pled->blinktimes));
 	}
 	else
 	{
-		SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+		SwLedOff(padapter, pled);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pled->blinktimes));
 	}
 
-	if (!pLed1->bLedWPSBlinkInProgress && pLed1->BlinkingLedState == LED_UNKNOWN)
+	if (!pled1->wps_blink_in_prog && pled1->blinkingledstate == LED_UNKNOWN)
 	{
-		pLed1->BlinkingLedState = RTW_LED_OFF;
-		pLed1->CurrLedState = RTW_LED_OFF;
-		SwLedOff(padapter, pLed1);
+		pled1->blinkingledstate = RTW_LED_OFF;
+		pled1->currledstate = RTW_LED_OFF;
+		SwLedOff(padapter, pled1);
 	}
 
-	switch (pLed->CurrLedState)
+	switch (pled->currledstate)
 	{
 		case LED_BLINK_SLOWLY:
-			if (pLed->bLedOn)
-				pLed->BlinkingLedState = RTW_LED_OFF;
+			if (pled->led_on)
+				pled->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 			break;
 
 		case LED_BLINK_StartToBlink:
-			if (pLed->bLedOn)
+			if (pled->led_on)
 			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+				pled->blinkingledstate = RTW_LED_OFF;
+				_set_timer(&(pled->blinktimer), LED_BLINK_SLOWLY_INTERVAL);
 			}
 			else
 			{
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+				pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_NORMAL_INTERVAL);
 			}
 			break;
 
 		case LED_SCAN_BLINK:
-			pLed->BlinkTimes--;
-			if (pLed->BlinkTimes == 0)
+			pled->blinktimes--;
+			if (pled->blinktimes == 0)
 			{
 				bStopBlinking = false;
 			}
@@ -871,40 +871,40 @@ static void SwLedBlink4(struct LED_871X
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					pLed->bLedNoLinkBlinkInProgress = false;
-					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					pled->nolink_blink_in_prog = false;
+					pled->currledstate = LED_BLINK_SLOWLY;
+					if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 				}
-				pLed->bLedScanBlinkInProgress = false;
+				pled->scan_blink_in_prog = false;
 			}
 			else
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					 if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					 if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 				}
 			}
 			break;
 
 		case LED_TXRX_BLINK:
-			pLed->BlinkTimes--;
-			if (pLed->BlinkTimes == 0)
+			pled->blinktimes--;
+			if (pled->blinktimes == 0)
 			{
 				bStopBlinking = true;
 			}
@@ -912,66 +912,66 @@ static void SwLedBlink4(struct LED_871X
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					pLed->bLedNoLinkBlinkInProgress = true;
-					pLed->CurrLedState = LED_BLINK_SLOWLY;
-					if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					pled->nolink_blink_in_prog = true;
+					pled->currledstate = LED_BLINK_SLOWLY;
+					if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 				}
-				pLed->bLedBlinkInProgress = false;
+				pled->blink_in_prog = false;
 			}
 			else
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					 if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					 if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 			}
 			break;
 
 		case LED_BLINK_WPS:
-			if (pLed->bLedOn)
+			if (pled->led_on)
 			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+				pled->blinkingledstate = RTW_LED_OFF;
+				_set_timer(&(pled->blinktimer), LED_BLINK_SLOWLY_INTERVAL);
 			}
 			else
 			{
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+				pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_NORMAL_INTERVAL);
 			}
 			break;
 
 		case LED_BLINK_WPS_STOP:	/* WPS authentication fail */
-			if (pLed->bLedOn)
-				pLed->BlinkingLedState = RTW_LED_OFF;
+			if (pled->led_on)
+				pled->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed->BlinkingLedState = RTW_LED_ON;
+				pled->blinkingledstate = RTW_LED_ON;
 
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			_set_timer(&(pled->blinktimer), LED_BLINK_NORMAL_INTERVAL);
 			break;
 
 		case LED_BLINK_WPS_STOP_OVERLAP:	/* WPS session overlap */
-			pLed->BlinkTimes--;
-			if (pLed->BlinkTimes == 0)
+			pled->blinktimes--;
+			if (pled->blinktimes == 0)
 			{
-				if (pLed->bLedOn)
+				if (pled->led_on)
 				{
-					pLed->BlinkTimes = 1;
+					pled->blinktimes = 1;
 				}
 				else
 				{
@@ -981,18 +981,18 @@ static void SwLedBlink4(struct LED_871X
 
 			if (bStopBlinking)
 			{
-				pLed->BlinkTimes = 10;
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+				pled->blinktimes = 10;
+				pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_LINK_INTERVAL_ALPHA);
 			}
 			else
 			{
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
+					pled->blinkingledstate = RTW_LED_ON;
 
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+				_set_timer(&(pled->blinktimer), LED_BLINK_NORMAL_INTERVAL);
 			}
 			break;
 
@@ -1000,32 +1000,32 @@ static void SwLedBlink4(struct LED_871X
 			break;
 	}
 
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink4 CurrLedState %d\n", pLed->CurrLedState));
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink4 currledstate %d\n", pled->currledstate));
 
 }
 
-static void SwLedBlink5(struct LED_871X *pLed)
+static void SwLedBlink5(struct LED_871X *pled)
 {
-	struct rtw_adapter			*padapter = pLed->padapter;
+	struct rtw_adapter			*padapter = pled->padapter;
 	u8				bStopBlinking = false;
 
-	/*  Change LED according to BlinkingLedState specified. */
-	if (pLed->BlinkingLedState == RTW_LED_ON)
+	/*  Change LED according to blinkingledstate specified. */
+	if (pled->blinkingledstate == RTW_LED_ON)
 	{
-		SwLedOn(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+		SwLedOn(padapter, pled);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pled->blinktimes));
 	}
 	else
 	{
-		SwLedOff(padapter, pLed);
-		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+		SwLedOff(padapter, pled);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pled->blinktimes));
 	}
 
-	switch (pLed->CurrLedState)
+	switch (pled->currledstate)
 	{
 		case LED_SCAN_BLINK:
-			pLed->BlinkTimes--;
-			if (pLed->BlinkTimes == 0)
+			pled->blinktimes--;
+			if (pled->blinktimes == 0)
 			{
 				bStopBlinking = true;
 			}
@@ -1034,40 +1034,40 @@ static void SwLedBlink5(struct LED_871X
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
-					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					if (pLed->bLedOn)
-						SwLedOff(padapter, pLed);
+					pled->currledstate = RTW_LED_OFF;
+					pled->blinkingledstate = RTW_LED_OFF;
+					if (pled->led_on)
+						SwLedOff(padapter, pled);
 				}
 				else
-				{		pLed->CurrLedState = RTW_LED_ON;
-						pLed->BlinkingLedState = RTW_LED_ON;
-						if (!pLed->bLedOn)
-							_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				{		pled->currledstate = RTW_LED_ON;
+						pled->blinkingledstate = RTW_LED_ON;
+						if (!pled->led_on)
+							_set_timer(&(pled->blinktimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 
-				pLed->bLedScanBlinkInProgress = false;
+				pled->scan_blink_in_prog = false;
 			}
 			else
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 				}
 			}
 			break;
 
 		case LED_TXRX_BLINK:
-			pLed->BlinkTimes--;
-			if (pLed->BlinkTimes == 0)
+			pled->blinktimes--;
+			if (pled->blinktimes == 0)
 			{
 				bStopBlinking = true;
 			}
@@ -1076,34 +1076,34 @@ static void SwLedBlink5(struct LED_871X
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
-					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					if (pLed->bLedOn)
-						SwLedOff(padapter, pLed);
+					pled->currledstate = RTW_LED_OFF;
+					pled->blinkingledstate = RTW_LED_OFF;
+					if (pled->led_on)
+						SwLedOff(padapter, pled);
 				}
 				else
 				{
-					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
-					if (!pLed->bLedOn)
-						_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+					pled->currledstate = RTW_LED_ON;
+					pled->blinkingledstate = RTW_LED_ON;
+					if (!pled->led_on)
+						_set_timer(&(pled->blinktimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 
-				pLed->bLedBlinkInProgress = false;
+				pled->blink_in_prog = false;
 			}
 			else
 			{
 				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
-					SwLedOff(padapter, pLed);
+					SwLedOff(padapter, pled);
 				}
 				else
 				{
-					 if (pLed->bLedOn)
-						pLed->BlinkingLedState = RTW_LED_OFF;
+					 if (pled->led_on)
+						pled->blinkingledstate = RTW_LED_OFF;
 					else
-						pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+						pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 			}
 			break;
@@ -1112,29 +1112,29 @@ static void SwLedBlink5(struct LED_871X
 			break;
 	}
 
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink5 CurrLedState %d\n", pLed->CurrLedState));
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink5 currledstate %d\n", pled->currledstate));
 
 }
 
 /*  */
 /*	Description: */
-/*		Callback function of LED BlinkTimer, */
+/*		Callback function of LED blinktimer, */
 /*		it just schedules to corresponding BlinkWorkItem. */
 /*  */
 static void
-BlinkTimerCallback(
+blinktimerCallback(
 	unsigned long data
 	)
 {
-	struct LED_871X *	 pLed = (struct LED_871X *)data;
-	struct rtw_adapter		*padapter = pLed->padapter;
+	struct LED_871X *	 pled = (struct LED_871X *)data;
+	struct rtw_adapter		*padapter = pled->padapter;
 
 	 if ((padapter->bSurpriseRemoved == true) || (padapter->bDriverStopped == true))
        {
              return;
        }
 
-	_set_workitem(&(pLed->BlinkWorkItem));
+	_set_workitem(&(pled->BlinkWorkItem));
 }
 
 /*  */
@@ -1144,9 +1144,9 @@ BlinkTimerCallback(
 /*  */
 static void BlinkWorkItemCallback(struct work_struct *work)
 {
-	struct LED_871X *	 pLed = container_of(work, struct LED_871X, BlinkWorkItem);
-	struct led_priv	*ledpriv = &(pLed->padapter->ledpriv);
-	struct rtw_adapter		*padapter = pLed->padapter;
+	struct LED_871X *	 pled = container_of(work, struct LED_871X, BlinkWorkItem);
+	struct led_priv	*ledpriv = &(pled->padapter->ledpriv);
+	struct rtw_adapter		*padapter = pled->padapter;
 
 	 if ((padapter->bSurpriseRemoved == true) || (padapter->bDriverStopped == true))
        {
@@ -1156,31 +1156,31 @@ static void BlinkWorkItemCallback(struct
 	switch (ledpriv->LedStrategy)
 	{
 		case SW_LED_MODE0:
-			SwLedBlink(pLed);
+			SwLedBlink(pled);
 			break;
 
 		case SW_LED_MODE1:
-			SwLedBlink1(pLed);
+			SwLedBlink1(pled);
 			break;
 
 		case SW_LED_MODE2:
-			SwLedBlink2(pLed);
+			SwLedBlink2(pled);
 			break;
 
 		case SW_LED_MODE3:
-			SwLedBlink3(pLed);
+			SwLedBlink3(pled);
 			break;
 
 		case SW_LED_MODE4:
-			SwLedBlink4(pLed);
+			SwLedBlink4(pled);
 			break;
 
 		case SW_LED_MODE5:
-			SwLedBlink5(pLed);
+			SwLedBlink5(pled);
 			break;
 
 		default:
-			SwLedBlink(pLed);
+			SwLedBlink(pled);
 			break;
 	}
 }
@@ -1200,103 +1200,103 @@ static void SwLedControlMode0(
 )
 {
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
-	struct LED_871X *	pLed = &(ledpriv->SwLed1);
+	struct LED_871X *	pled = &(ledpriv->SwLed1);
 
 	/*  Decide led state */
 	switch (LedAction)
 	{
 	case LED_CTL_TX:
 	case LED_CTL_RX:
-		if (pLed->bLedBlinkInProgress == false)
+		if (pled->blink_in_prog == false)
 		{
-			pLed->bLedBlinkInProgress = true;
+			pled->blink_in_prog = true;
 
-			pLed->CurrLedState = LED_BLINK_NORMAL;
-			pLed->BlinkTimes = 2;
+			pled->currledstate = LED_BLINK_NORMAL;
+			pled->blinktimes = 2;
 
-			if (pLed->bLedOn)
-				pLed->BlinkingLedState = RTW_LED_OFF;
+			if (pled->led_on)
+				pled->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+				pled->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_NORMAL_INTERVAL);
 		}
 		break;
 
 	case LED_CTL_START_TO_LINK:
-		if (pLed->bLedBlinkInProgress == false)
+		if (pled->blink_in_prog == false)
 		{
-			pLed->bLedBlinkInProgress = true;
+			pled->blink_in_prog = true;
 
-			pLed->CurrLedState = LED_BLINK_StartToBlink;
-			pLed->BlinkTimes = 24;
+			pled->currledstate = LED_BLINK_StartToBlink;
+			pled->blinktimes = 24;
 
-			if (pLed->bLedOn)
-				pLed->BlinkingLedState = RTW_LED_OFF;
+			if (pled->led_on)
+				pled->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+				pled->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_SLOWLY_INTERVAL);
 		}
 		else
 		{
-			pLed->CurrLedState = LED_BLINK_StartToBlink;
+			pled->currledstate = LED_BLINK_StartToBlink;
 		}
 		break;
 
 	case LED_CTL_LINK:
-		pLed->CurrLedState = RTW_LED_ON;
-		if (pLed->bLedBlinkInProgress == false)
+		pled->currledstate = RTW_LED_ON;
+		if (pled->blink_in_prog == false)
 		{
-			SwLedOn(padapter, pLed);
+			SwLedOn(padapter, pled);
 		}
 		break;
 
 	case LED_CTL_NO_LINK:
-		pLed->CurrLedState = RTW_LED_OFF;
-		if (pLed->bLedBlinkInProgress == false)
+		pled->currledstate = RTW_LED_OFF;
+		if (pled->blink_in_prog == false)
 		{
-			SwLedOff(padapter, pLed);
+			SwLedOff(padapter, pled);
 		}
 		break;
 
 	case LED_CTL_POWER_OFF:
-		pLed->CurrLedState = RTW_LED_OFF;
-		pLed->BlinkingLedState = RTW_LED_OFF;
+		pled->currledstate = RTW_LED_OFF;
+		pled->blinkingledstate = RTW_LED_OFF;
 
-		if (pLed->bLedBlinkInProgress)
+		if (pled->blink_in_prog)
 		{
-			_cancel_timer_ex(&(pLed->BlinkTimer));
-			pLed->bLedBlinkInProgress = false;
+			_cancel_timer_ex(&(pled->blinktimer));
+			pled->blink_in_prog = false;
 		}
-		SwLedOff(padapter, pLed);
+		SwLedOff(padapter, pled);
 		break;
 
 	case LED_CTL_START_WPS:
-		if (pLed->bLedBlinkInProgress == false || pLed->CurrLedState == RTW_LED_ON)
+		if (pled->blink_in_prog == false || pled->currledstate == RTW_LED_ON)
 		{
-			pLed->bLedBlinkInProgress = true;
+			pled->blink_in_prog = true;
 
-			pLed->CurrLedState = LED_BLINK_WPS;
-			pLed->BlinkTimes = 20;
+			pled->currledstate = LED_BLINK_WPS;
+			pled->blinktimes = 20;
 
-			if (pLed->bLedOn)
+			if (pled->led_on)
 			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+				pled->blinkingledstate = RTW_LED_OFF;
+				_set_timer(&(pled->blinktimer), LED_BLINK_LONG_INTERVAL);
 			}
 			else
 			{
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+				pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_LONG_INTERVAL);
 			}
 		}
 		break;
 
 	case LED_CTL_STOP_WPS:
-		if (pLed->bLedBlinkInProgress)
+		if (pled->blink_in_prog)
 		{
-			pLed->CurrLedState = RTW_LED_OFF;
-			_cancel_timer_ex(&(pLed->BlinkTimer));
-			pLed->bLedBlinkInProgress = false;
+			pled->currledstate = RTW_LED_OFF;
+			_cancel_timer_ex(&(pled->blinktimer));
+			pled->blink_in_prog = false;
 		}
 		break;
 
@@ -1304,7 +1304,7 @@ static void SwLedControlMode0(
 		break;
 	}
 
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pled->currledstate));
 }
 
  /* ALPHA, added by chiyoko, 20090106 */
@@ -1315,257 +1315,257 @@ static void SwLedControlMode1(
 {
 	struct hal_data_8192du		*pHalData = GET_HAL_DATA(padapter);
 	struct led_priv		*ledpriv = &(padapter->ledpriv);
-	struct LED_871X *			pLed = &(ledpriv->SwLed0);
+	struct LED_871X *			pled = &(ledpriv->SwLed0);
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
 
 	if (pHalData->CustomerID == RT_CID_819x_CAMEO)
-		pLed = &(ledpriv->SwLed1);
+		pled = &(ledpriv->SwLed1);
 
 	switch (LedAction)
 	{
 		case LED_CTL_START_TO_LINK:
 		case LED_CTL_NO_LINK:
-			if (pLed->bLedNoLinkBlinkInProgress == false)
+			if (pled->nolink_blink_in_prog == false)
 			{
-				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pled->currledstate == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pled))
 				{
 					return;
 				}
-				if (pLed->bLedLinkBlinkInProgress == true)
+				if (pled->link_blink_in_prog == true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedLinkBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->link_blink_in_prog = false;
 				}
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
 
-				pLed->bLedNoLinkBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_SLOWLY;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->nolink_blink_in_prog = true;
+				pled->currledstate = LED_BLINK_SLOWLY;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 			}
 			break;
 
 		case LED_CTL_LINK:
-			if (pLed->bLedLinkBlinkInProgress == false)
+			if (pled->link_blink_in_prog == false)
 			{
-				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pled->currledstate == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pled))
 				{
 					return;
 				}
-				if (pLed->bLedNoLinkBlinkInProgress == true)
+				if (pled->nolink_blink_in_prog == true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->nolink_blink_in_prog = false;
 				}
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
-				pLed->bLedLinkBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_NORMAL;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->link_blink_in_prog = true;
+				pled->currledstate = LED_BLINK_NORMAL;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_LINK_INTERVAL_ALPHA);
 			}
 			break;
 
 		case LED_CTL_SITE_SURVEY:
 			 if ((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 				;
-			 else if (pLed->bLedScanBlinkInProgress ==false)
+			 else if (pled->scan_blink_in_prog ==false)
 			 {
-				if (IS_LED_WPS_BLINKING(pLed))
+				if (IS_LED_WPS_BLINKING(pled))
 					return;
 
-				if (pLed->bLedNoLinkBlinkInProgress == true)
+				if (pled->nolink_blink_in_prog == true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->nolink_blink_in_prog = false;
 				}
-				if (pLed->bLedLinkBlinkInProgress == true)
+				if (pled->link_blink_in_prog == true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					 pLed->bLedLinkBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					 pled->link_blink_in_prog = false;
 				}
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
-				pLed->bLedScanBlinkInProgress = true;
-				pLed->CurrLedState = LED_SCAN_BLINK;
-				pLed->BlinkTimes = 24;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->scan_blink_in_prog = true;
+				pled->currledstate = LED_SCAN_BLINK;
+				pled->blinktimes = 24;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			 }
 			break;
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if (pLed->bLedBlinkInProgress ==false)
+			if (pled->blink_in_prog ==false)
 			{
-                            if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+                            if (pled->currledstate == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pled))
                             {
 					return;
                             }
-                            if (pLed->bLedNoLinkBlinkInProgress == true)
+                            if (pled->nolink_blink_in_prog == true)
                             {
-                                _cancel_timer_ex(&(pLed->BlinkTimer));
-                                pLed->bLedNoLinkBlinkInProgress = false;
+                                _cancel_timer_ex(&(pled->blinktimer));
+                                pled->nolink_blink_in_prog = false;
                             }
-                            if (pLed->bLedLinkBlinkInProgress == true)
+                            if (pled->link_blink_in_prog == true)
                             {
-                                _cancel_timer_ex(&(pLed->BlinkTimer));
-                                pLed->bLedLinkBlinkInProgress = false;
+                                _cancel_timer_ex(&(pled->blinktimer));
+                                pled->link_blink_in_prog = false;
                             }
-                            pLed->bLedBlinkInProgress = true;
-                            pLed->CurrLedState = LED_TXRX_BLINK;
-                            pLed->BlinkTimes = 2;
-                            if (pLed->bLedOn)
-                                pLed->BlinkingLedState = RTW_LED_OFF;
+                            pled->blink_in_prog = true;
+                            pled->currledstate = LED_TXRX_BLINK;
+                            pled->blinktimes = 2;
+                            if (pled->led_on)
+                                pled->blinkingledstate = RTW_LED_OFF;
                             else
-                                pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+                                pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 			}
 			break;
 
 		case LED_CTL_START_WPS: /* wait until xinpin finish */
 		case LED_CTL_START_WPS_BOTTON:
-			 if (pLed->bLedWPSBlinkInProgress ==false)
+			 if (pled->wps_blink_in_prog ==false)
 			 {
-				if (pLed->bLedNoLinkBlinkInProgress == true)
+				if (pled->nolink_blink_in_prog == true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->nolink_blink_in_prog = false;
 				}
-				if (pLed->bLedLinkBlinkInProgress == true)
+				if (pled->link_blink_in_prog == true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					 pLed->bLedLinkBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					 pled->link_blink_in_prog = false;
 				}
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
-				if (pLed->bLedScanBlinkInProgress ==true)
+				if (pled->scan_blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedScanBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->scan_blink_in_prog = false;
 				}
-				pLed->bLedWPSBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_WPS;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->wps_blink_in_prog = true;
+				pled->currledstate = LED_BLINK_WPS;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			 }
 			break;
 
 		case LED_CTL_STOP_WPS:
-			if (pLed->bLedNoLinkBlinkInProgress == true)
+			if (pled->nolink_blink_in_prog == true)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedNoLinkBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->nolink_blink_in_prog = false;
 			}
-			if (pLed->bLedLinkBlinkInProgress == true)
+			if (pled->link_blink_in_prog == true)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				 pLed->bLedLinkBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				 pled->link_blink_in_prog = false;
 			}
-			if (pLed->bLedBlinkInProgress ==true)
+			if (pled->blink_in_prog ==true)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->blink_in_prog = false;
 			}
-			if (pLed->bLedScanBlinkInProgress ==true)
+			if (pled->scan_blink_in_prog ==true)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->scan_blink_in_prog = false;
 			}
-			if (pLed->bLedWPSBlinkInProgress)
+			if (pled->wps_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
+				_cancel_timer_ex(&(pled->blinktimer));
 			}
 			else
 			{
-				pLed->bLedWPSBlinkInProgress = true;
+				pled->wps_blink_in_prog = true;
 			}
 
-			pLed->CurrLedState = LED_BLINK_WPS_STOP;
-			if (pLed->bLedOn)
+			pled->currledstate = LED_BLINK_WPS_STOP;
+			if (pled->led_on)
 			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_OFF;
+				_set_timer(&(pled->blinktimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
 			}
 			else
 			{
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), 0);
+				pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), 0);
 			}
 			break;
 
 		case LED_CTL_STOP_WPS_FAIL:
-			if (pLed->bLedWPSBlinkInProgress)
+			if (pled->wps_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->wps_blink_in_prog = false;
 			}
 
-			pLed->bLedNoLinkBlinkInProgress = true;
-			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if (pLed->bLedOn)
-				pLed->BlinkingLedState = RTW_LED_OFF;
+			pled->nolink_blink_in_prog = true;
+			pled->currledstate = LED_BLINK_SLOWLY;
+			if (pled->led_on)
+				pled->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 			break;
 
 		case LED_CTL_POWER_OFF:
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
+			pled->currledstate = RTW_LED_OFF;
+			pled->blinkingledstate = RTW_LED_OFF;
 
-			if (pLed->bLedNoLinkBlinkInProgress)
+			if (pled->nolink_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedNoLinkBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->nolink_blink_in_prog = false;
 			}
-			if (pLed->bLedLinkBlinkInProgress)
+			if (pled->link_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedLinkBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->link_blink_in_prog = false;
 			}
-			if (pLed->bLedBlinkInProgress)
+			if (pled->blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->blink_in_prog = false;
 			}
-			if (pLed->bLedWPSBlinkInProgress)
+			if (pled->wps_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->wps_blink_in_prog = false;
 			}
-			if (pLed->bLedScanBlinkInProgress)
+			if (pled->scan_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->scan_blink_in_prog = false;
 			}
 
-			SwLedOff(padapter, pLed);
+			SwLedOff(padapter, pled);
 			break;
 
 		default:
@@ -1573,7 +1573,7 @@ static void SwLedControlMode1(
 
 	}
 
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pled->currledstate));
 }
 
  /* Arcadyan/Sitecom , added by chiyoko, 20090216 */
@@ -1584,152 +1584,152 @@ static void SwLedControlMode2(
 {
 	struct led_priv	 *ledpriv = &(padapter->ledpriv);
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct LED_871X *		pLed = &(ledpriv->SwLed0);
+	struct LED_871X *		pled = &(ledpriv->SwLed0);
 
 	switch (LedAction)
 	{
 		case LED_CTL_SITE_SURVEY:
 			 if (pmlmepriv->LinkDetectInfo.bBusyTraffic)
 				;
-			 else if (pLed->bLedScanBlinkInProgress ==false)
+			 else if (pled->scan_blink_in_prog ==false)
 			 {
-				if (IS_LED_WPS_BLINKING(pLed))
+				if (IS_LED_WPS_BLINKING(pled))
 					return;
 
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
-				pLed->bLedScanBlinkInProgress = true;
-				pLed->CurrLedState = LED_SCAN_BLINK;
-				pLed->BlinkTimes = 24;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->scan_blink_in_prog = true;
+				pled->currledstate = LED_SCAN_BLINK;
+				pled->blinktimes = 24;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			 }
 			break;
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if ((pLed->bLedBlinkInProgress ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
+			if ((pled->blink_in_prog ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 			{
-				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pled->currledstate == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pled))
 				{
 					return;
 				}
 
-				pLed->bLedBlinkInProgress = true;
-				pLed->CurrLedState = LED_TXRX_BLINK;
-				pLed->BlinkTimes = 2;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->blink_in_prog = true;
+				pled->currledstate = LED_TXRX_BLINK;
+				pled->blinktimes = 2;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 			}
 			break;
 
 		case LED_CTL_LINK:
-			pLed->CurrLedState = RTW_LED_ON;
-			pLed->BlinkingLedState = RTW_LED_ON;
-			if (pLed->bLedBlinkInProgress)
+			pled->currledstate = RTW_LED_ON;
+			pled->blinkingledstate = RTW_LED_ON;
+			if (pled->blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->blink_in_prog = false;
 			}
-			if (pLed->bLedScanBlinkInProgress)
+			if (pled->scan_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->scan_blink_in_prog = false;
 			}
 
-			_set_timer(&(pLed->BlinkTimer), 0);
+			_set_timer(&(pled->blinktimer), 0);
 			break;
 
 		case LED_CTL_START_WPS: /* wait until xinpin finish */
 		case LED_CTL_START_WPS_BOTTON:
-			if (pLed->bLedWPSBlinkInProgress ==false)
+			if (pled->wps_blink_in_prog ==false)
 			{
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
-				if (pLed->bLedScanBlinkInProgress ==true)
+				if (pled->scan_blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedScanBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->scan_blink_in_prog = false;
 				}
-				pLed->bLedWPSBlinkInProgress = true;
-				pLed->CurrLedState = RTW_LED_ON;
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), 0);
+				pled->wps_blink_in_prog = true;
+				pled->currledstate = RTW_LED_ON;
+				pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), 0);
 			 }
 			break;
 
 		case LED_CTL_STOP_WPS:
-			pLed->bLedWPSBlinkInProgress = false;
+			pled->wps_blink_in_prog = false;
 			if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 			{
-				SwLedOff(padapter, pLed);
+				SwLedOff(padapter, pled);
 			}
 			else
 			{
-				pLed->CurrLedState = RTW_LED_ON;
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), 0);
-				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+				pled->currledstate = RTW_LED_ON;
+				pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), 0);
+				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 			}
 			break;
 
 		case LED_CTL_STOP_WPS_FAIL:
-			pLed->bLedWPSBlinkInProgress = false;
+			pled->wps_blink_in_prog = false;
 			if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 			{
-				SwLedOff(padapter, pLed);
+				SwLedOff(padapter, pled);
 			}
 			else
 			{
-				pLed->CurrLedState = RTW_LED_OFF;
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), 0);
-				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+				pled->currledstate = RTW_LED_OFF;
+				pled->blinkingledstate = RTW_LED_OFF;
+				_set_timer(&(pled->blinktimer), 0);
+				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 			}
 			break;
 
 		case LED_CTL_START_TO_LINK:
 		case LED_CTL_NO_LINK:
-			if (!IS_LED_BLINKING(pLed))
+			if (!IS_LED_BLINKING(pled))
 			{
-				pLed->CurrLedState = RTW_LED_OFF;
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), 0);
+				pled->currledstate = RTW_LED_OFF;
+				pled->blinkingledstate = RTW_LED_OFF;
+				_set_timer(&(pled->blinktimer), 0);
 			}
 			break;
 
 		case LED_CTL_POWER_OFF:
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
-			if (pLed->bLedBlinkInProgress)
+			pled->currledstate = RTW_LED_OFF;
+			pled->blinkingledstate = RTW_LED_OFF;
+			if (pled->blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->blink_in_prog = false;
 			}
-			if (pLed->bLedScanBlinkInProgress)
+			if (pled->scan_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->scan_blink_in_prog = false;
 			}
-			if (pLed->bLedWPSBlinkInProgress)
+			if (pled->wps_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->wps_blink_in_prog = false;
 			}
 
-			_set_timer(&(pLed->BlinkTimer), 0);
+			_set_timer(&(pled->blinktimer), 0);
 			break;
 
 		default:
@@ -1737,7 +1737,7 @@ static void SwLedControlMode2(
 
 	}
 
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 }
 
   /* COREGA, added by chiyoko, 20090316 */
@@ -1748,165 +1748,165 @@ static void SwLedControlMode3(
 {
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct LED_871X *		pLed = &(ledpriv->SwLed0);
+	struct LED_871X *		pled = &(ledpriv->SwLed0);
 
 	switch (LedAction)
 	{
 		case LED_CTL_SITE_SURVEY:
 			if (pmlmepriv->LinkDetectInfo.bBusyTraffic)
 				;
-			else if (pLed->bLedScanBlinkInProgress ==false)
+			else if (pled->scan_blink_in_prog ==false)
 			{
-				if (IS_LED_WPS_BLINKING(pLed))
+				if (IS_LED_WPS_BLINKING(pled))
 					return;
 
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
-				pLed->bLedScanBlinkInProgress = true;
-				pLed->CurrLedState = LED_SCAN_BLINK;
-				pLed->BlinkTimes = 24;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->scan_blink_in_prog = true;
+				pled->currledstate = LED_SCAN_BLINK;
+				pled->blinktimes = 24;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			}
 			break;
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if ((pLed->bLedBlinkInProgress ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
+			if ((pled->blink_in_prog ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 			{
-				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pled->currledstate == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pled))
 				{
 					return;
 				}
 
-				pLed->bLedBlinkInProgress = true;
-				pLed->CurrLedState = LED_TXRX_BLINK;
-				pLed->BlinkTimes = 2;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->blink_in_prog = true;
+				pled->currledstate = LED_TXRX_BLINK;
+				pled->blinktimes = 2;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 			}
 			break;
 
 		case LED_CTL_LINK:
-			if (IS_LED_WPS_BLINKING(pLed))
+			if (IS_LED_WPS_BLINKING(pled))
 				return;
 
-			pLed->CurrLedState = RTW_LED_ON;
-			pLed->BlinkingLedState = RTW_LED_ON;
-			if (pLed->bLedBlinkInProgress)
+			pled->currledstate = RTW_LED_ON;
+			pled->blinkingledstate = RTW_LED_ON;
+			if (pled->blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->blink_in_prog = false;
 			}
-			if (pLed->bLedScanBlinkInProgress)
+			if (pled->scan_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->scan_blink_in_prog = false;
 			}
 
-			_set_timer(&(pLed->BlinkTimer), 0);
+			_set_timer(&(pled->blinktimer), 0);
 			break;
 
 		case LED_CTL_START_WPS: /* wait until xinpin finish */
 		case LED_CTL_START_WPS_BOTTON:
-			if (pLed->bLedWPSBlinkInProgress ==false)
+			if (pled->wps_blink_in_prog ==false)
 			{
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
-				if (pLed->bLedScanBlinkInProgress ==true)
+				if (pled->scan_blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedScanBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->scan_blink_in_prog = false;
 				}
-				pLed->bLedWPSBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_WPS;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->wps_blink_in_prog = true;
+				pled->currledstate = LED_BLINK_WPS;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			}
 			break;
 
 		case LED_CTL_STOP_WPS:
-			if (pLed->bLedWPSBlinkInProgress)
+			if (pled->wps_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->wps_blink_in_prog = false;
 			}
 			else
 			{
-				pLed->bLedWPSBlinkInProgress = true;
+				pled->wps_blink_in_prog = true;
 			}
 
-			pLed->CurrLedState = LED_BLINK_WPS_STOP;
-			if (pLed->bLedOn)
+			pled->currledstate = LED_BLINK_WPS_STOP;
+			if (pled->led_on)
 			{
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_OFF;
+				_set_timer(&(pled->blinktimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
 			}
 			else
 			{
-				pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), 0);
+				pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), 0);
 			}
 
 			break;
 
 		case LED_CTL_STOP_WPS_FAIL:
-			if (pLed->bLedWPSBlinkInProgress)
+			if (pled->wps_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->wps_blink_in_prog = false;
 			}
 
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
-			_set_timer(&(pLed->BlinkTimer), 0);
+			pled->currledstate = RTW_LED_OFF;
+			pled->blinkingledstate = RTW_LED_OFF;
+			_set_timer(&(pled->blinktimer), 0);
 			break;
 
 		case LED_CTL_START_TO_LINK:
 		case LED_CTL_NO_LINK:
-			if (!IS_LED_BLINKING(pLed))
+			if (!IS_LED_BLINKING(pled))
 			{
-				pLed->CurrLedState = RTW_LED_OFF;
-				pLed->BlinkingLedState = RTW_LED_OFF;
-				_set_timer(&(pLed->BlinkTimer), 0);
+				pled->currledstate = RTW_LED_OFF;
+				pled->blinkingledstate = RTW_LED_OFF;
+				_set_timer(&(pled->blinktimer), 0);
 			}
 			break;
 
 		case LED_CTL_POWER_OFF:
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
-			if (pLed->bLedBlinkInProgress)
+			pled->currledstate = RTW_LED_OFF;
+			pled->blinkingledstate = RTW_LED_OFF;
+			if (pled->blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->blink_in_prog = false;
 			}
-			if (pLed->bLedScanBlinkInProgress)
+			if (pled->scan_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->scan_blink_in_prog = false;
 			}
-			if (pLed->bLedWPSBlinkInProgress)
+			if (pled->wps_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->wps_blink_in_prog = false;
 			}
 
-			_set_timer(&(pLed->BlinkTimer), 0);
+			_set_timer(&(pled->blinktimer), 0);
 			break;
 
 		default:
@@ -1914,7 +1914,7 @@ static void SwLedControlMode3(
 
 	}
 
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("currledstate %d\n", pled->currledstate));
 }
 
  /* Edimax-Belkin, added by chiyoko, 20090413 */
@@ -1925,52 +1925,52 @@ static void SwLedControlMode4(
 {
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct LED_871X *		pLed = &(ledpriv->SwLed0);
-	struct LED_871X *		pLed1 = &(ledpriv->SwLed1);
+	struct LED_871X *		pled = &(ledpriv->SwLed0);
+	struct LED_871X *		pled1 = &(ledpriv->SwLed1);
 
 	switch (LedAction)
 	{
 		case LED_CTL_START_TO_LINK:
-			if (pLed1->bLedWPSBlinkInProgress)
+			if (pled1->wps_blink_in_prog)
 			{
-				pLed1->bLedWPSBlinkInProgress = false;
-				_cancel_timer_ex(&(pLed1->BlinkTimer));
+				pled1->wps_blink_in_prog = false;
+				_cancel_timer_ex(&(pled1->blinktimer));
 
-				pLed1->BlinkingLedState = RTW_LED_OFF;
-				pLed1->CurrLedState = RTW_LED_OFF;
+				pled1->blinkingledstate = RTW_LED_OFF;
+				pled1->currledstate = RTW_LED_OFF;
 
-				if (pLed1->bLedOn)
-					_set_timer(&(pLed->BlinkTimer), 0);
+				if (pled1->led_on)
+					_set_timer(&(pled->blinktimer), 0);
 			}
 
-			if (pLed->bLedStartToLinkBlinkInProgress == false)
+			if (pled->start_link_blink_in_prog == false)
 			{
-				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pled->currledstate == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pled))
 				{
 					return;
 				}
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
-				if (pLed->bLedNoLinkBlinkInProgress ==true)
+				if (pled->nolink_blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->nolink_blink_in_prog = false;
 				}
 
-				pLed->bLedStartToLinkBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_StartToBlink;
-				if (pLed->bLedOn)
+				pled->start_link_blink_in_prog = true;
+				pled->currledstate = LED_BLINK_StartToBlink;
+				if (pled->led_on)
 				{
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+					pled->blinkingledstate = RTW_LED_OFF;
+					_set_timer(&(pled->blinktimer), LED_BLINK_SLOWLY_INTERVAL);
 				}
 				else
 				{
-					pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+					pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_NORMAL_INTERVAL);
 				}
 			}
 			break;
@@ -1980,262 +1980,262 @@ static void SwLedControlMode4(
 			/* LED1 settings */
 			if (LedAction == LED_CTL_LINK)
 			{
-				if (pLed1->bLedWPSBlinkInProgress)
+				if (pled1->wps_blink_in_prog)
 				{
-					pLed1->bLedWPSBlinkInProgress = false;
-					_cancel_timer_ex(&(pLed1->BlinkTimer));
+					pled1->wps_blink_in_prog = false;
+					_cancel_timer_ex(&(pled1->blinktimer));
 
-					pLed1->BlinkingLedState = RTW_LED_OFF;
-					pLed1->CurrLedState = RTW_LED_OFF;
+					pled1->blinkingledstate = RTW_LED_OFF;
+					pled1->currledstate = RTW_LED_OFF;
 
-					if (pLed1->bLedOn)
-						_set_timer(&(pLed->BlinkTimer), 0);
+					if (pled1->led_on)
+						_set_timer(&(pled->blinktimer), 0);
 				}
 			}
 
-			if (pLed->bLedNoLinkBlinkInProgress == false)
+			if (pled->nolink_blink_in_prog == false)
 			{
-				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pled->currledstate == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pled))
 				{
 					return;
 				}
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
 
-				pLed->bLedNoLinkBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_SLOWLY;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->nolink_blink_in_prog = true;
+				pled->currledstate = LED_BLINK_SLOWLY;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 			}
 			break;
 
 		case LED_CTL_SITE_SURVEY:
 			if ((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 				;
-			else if (pLed->bLedScanBlinkInProgress ==false)
+			else if (pled->scan_blink_in_prog ==false)
 			{
-				if (IS_LED_WPS_BLINKING(pLed))
+				if (IS_LED_WPS_BLINKING(pled))
 					return;
 
-				if (pLed->bLedNoLinkBlinkInProgress == true)
+				if (pled->nolink_blink_in_prog == true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->nolink_blink_in_prog = false;
 				}
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
-				pLed->bLedScanBlinkInProgress = true;
-				pLed->CurrLedState = LED_SCAN_BLINK;
-				pLed->BlinkTimes = 24;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->scan_blink_in_prog = true;
+				pled->currledstate = LED_SCAN_BLINK;
+				pled->blinktimes = 24;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			}
 			break;
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if (pLed->bLedBlinkInProgress ==false)
+			if (pled->blink_in_prog ==false)
 			{
-				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				if (pled->currledstate == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pled))
 				{
 					return;
 				}
-				if (pLed->bLedNoLinkBlinkInProgress == true)
+				if (pled->nolink_blink_in_prog == true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->nolink_blink_in_prog = false;
 				}
-				pLed->bLedBlinkInProgress = true;
-				pLed->CurrLedState = LED_TXRX_BLINK;
-				pLed->BlinkTimes = 2;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->blink_in_prog = true;
+				pled->currledstate = LED_TXRX_BLINK;
+				pled->blinktimes = 2;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 			}
 			break;
 
 		case LED_CTL_START_WPS: /* wait until xinpin finish */
 		case LED_CTL_START_WPS_BOTTON:
-			if (pLed1->bLedWPSBlinkInProgress)
+			if (pled1->wps_blink_in_prog)
 			{
-				pLed1->bLedWPSBlinkInProgress = false;
-				_cancel_timer_ex(&(pLed1->BlinkTimer));
+				pled1->wps_blink_in_prog = false;
+				_cancel_timer_ex(&(pled1->blinktimer));
 
-				pLed1->BlinkingLedState = RTW_LED_OFF;
-				pLed1->CurrLedState = RTW_LED_OFF;
+				pled1->blinkingledstate = RTW_LED_OFF;
+				pled1->currledstate = RTW_LED_OFF;
 
-				if (pLed1->bLedOn)
-					_set_timer(&(pLed->BlinkTimer), 0);
+				if (pled1->led_on)
+					_set_timer(&(pled->blinktimer), 0);
 			}
 
-			if (pLed->bLedWPSBlinkInProgress ==false)
+			if (pled->wps_blink_in_prog ==false)
 			{
-				if (pLed->bLedNoLinkBlinkInProgress == true)
+				if (pled->nolink_blink_in_prog == true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedNoLinkBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->nolink_blink_in_prog = false;
 				}
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
-				if (pLed->bLedScanBlinkInProgress ==true)
+				if (pled->scan_blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedScanBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->scan_blink_in_prog = false;
 				}
-				pLed->bLedWPSBlinkInProgress = true;
-				pLed->CurrLedState = LED_BLINK_WPS;
-				if (pLed->bLedOn)
+				pled->wps_blink_in_prog = true;
+				pled->currledstate = LED_BLINK_WPS;
+				if (pled->led_on)
 				{
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+					pled->blinkingledstate = RTW_LED_OFF;
+					_set_timer(&(pled->blinktimer), LED_BLINK_SLOWLY_INTERVAL);
 				}
 				else
 				{
-					pLed->BlinkingLedState = RTW_LED_ON;
-					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+					pled->blinkingledstate = RTW_LED_ON;
+					_set_timer(&(pled->blinktimer), LED_BLINK_NORMAL_INTERVAL);
 				}
 			}
 			break;
 
 		case LED_CTL_STOP_WPS:	/* WPS connect success */
-			if (pLed->bLedWPSBlinkInProgress)
+			if (pled->wps_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->wps_blink_in_prog = false;
 			}
 
-			pLed->bLedNoLinkBlinkInProgress = true;
-			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if (pLed->bLedOn)
-				pLed->BlinkingLedState = RTW_LED_OFF;
+			pled->nolink_blink_in_prog = true;
+			pled->currledstate = LED_BLINK_SLOWLY;
+			if (pled->led_on)
+				pled->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 
 			break;
 
 		case LED_CTL_STOP_WPS_FAIL:		/* WPS authentication fail */
-			if (pLed->bLedWPSBlinkInProgress)
+			if (pled->wps_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->wps_blink_in_prog = false;
 			}
 
-			pLed->bLedNoLinkBlinkInProgress = true;
-			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if (pLed->bLedOn)
-				pLed->BlinkingLedState = RTW_LED_OFF;
+			pled->nolink_blink_in_prog = true;
+			pled->currledstate = LED_BLINK_SLOWLY;
+			if (pled->led_on)
+				pled->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 
 			/* LED1 settings */
-			if (pLed1->bLedWPSBlinkInProgress)
-				_cancel_timer_ex(&(pLed1->BlinkTimer));
+			if (pled1->wps_blink_in_prog)
+				_cancel_timer_ex(&(pled1->blinktimer));
 			else
-				pLed1->bLedWPSBlinkInProgress = true;
+				pled1->wps_blink_in_prog = true;
 
-			pLed1->CurrLedState = LED_BLINK_WPS_STOP;
-			if (pLed1->bLedOn)
-				pLed1->BlinkingLedState = RTW_LED_OFF;
+			pled1->currledstate = LED_BLINK_WPS_STOP;
+			if (pled1->led_on)
+				pled1->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed1->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+				pled1->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_NORMAL_INTERVAL);
 
 			break;
 
 		case LED_CTL_STOP_WPS_FAIL_OVERLAP:	/* WPS session overlap */
-			if (pLed->bLedWPSBlinkInProgress)
+			if (pled->wps_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->wps_blink_in_prog = false;
 			}
 
-			pLed->bLedNoLinkBlinkInProgress = true;
-			pLed->CurrLedState = LED_BLINK_SLOWLY;
-			if (pLed->bLedOn)
-				pLed->BlinkingLedState = RTW_LED_OFF;
+			pled->nolink_blink_in_prog = true;
+			pled->currledstate = LED_BLINK_SLOWLY;
+			if (pled->led_on)
+				pled->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+				pled->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 
 			/* LED1 settings */
-			if (pLed1->bLedWPSBlinkInProgress)
-				_cancel_timer_ex(&(pLed1->BlinkTimer));
+			if (pled1->wps_blink_in_prog)
+				_cancel_timer_ex(&(pled1->blinktimer));
 			else
-				pLed1->bLedWPSBlinkInProgress = true;
+				pled1->wps_blink_in_prog = true;
 
-			pLed1->CurrLedState = LED_BLINK_WPS_STOP_OVERLAP;
-			pLed1->BlinkTimes = 10;
-			if (pLed1->bLedOn)
-				pLed1->BlinkingLedState = RTW_LED_OFF;
+			pled1->currledstate = LED_BLINK_WPS_STOP_OVERLAP;
+			pled1->blinktimes = 10;
+			if (pled1->led_on)
+				pled1->blinkingledstate = RTW_LED_OFF;
 			else
-				pLed1->BlinkingLedState = RTW_LED_ON;
-			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+				pled1->blinkingledstate = RTW_LED_ON;
+			_set_timer(&(pled->blinktimer), LED_BLINK_NORMAL_INTERVAL);
 
 			break;
 
 		case LED_CTL_POWER_OFF:
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
+			pled->currledstate = RTW_LED_OFF;
+			pled->blinkingledstate = RTW_LED_OFF;
 
-			if (pLed->bLedNoLinkBlinkInProgress)
+			if (pled->nolink_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedNoLinkBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->nolink_blink_in_prog = false;
 			}
-			if (pLed->bLedLinkBlinkInProgress)
+			if (pled->link_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedLinkBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->link_blink_in_prog = false;
 			}
-			if (pLed->bLedBlinkInProgress)
+			if (pled->blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->blink_in_prog = false;
 			}
-			if (pLed->bLedWPSBlinkInProgress)
+			if (pled->wps_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->wps_blink_in_prog = false;
 			}
-			if (pLed->bLedScanBlinkInProgress)
+			if (pled->scan_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedScanBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->scan_blink_in_prog = false;
 			}
-			if (pLed->bLedStartToLinkBlinkInProgress)
+			if (pled->start_link_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedStartToLinkBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->start_link_blink_in_prog = false;
 			}
 
-			if (pLed1->bLedWPSBlinkInProgress)
+			if (pled1->wps_blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed1->BlinkTimer));
-				pLed1->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pled1->blinktimer));
+				pled1->wps_blink_in_prog = false;
 			}
 
-			pLed1->BlinkingLedState = LED_UNKNOWN;
-			SwLedOff(padapter, pLed);
-			SwLedOff(padapter, pLed1);
+			pled1->blinkingledstate = LED_UNKNOWN;
+			SwLedOff(padapter, pled);
+			SwLedOff(padapter, pled1);
 			break;
 
 		default:
@@ -2243,7 +2243,7 @@ static void SwLedControlMode4(
 
 	}
 
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pled->currledstate));
 }
 
 /* Sercomm-Belkin, added by chiyoko, 20090415 */
@@ -2255,73 +2255,73 @@ static void SwLedControlMode5(
 	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct LED_871X *		pLed = &(ledpriv->SwLed0);
+	struct LED_871X *		pled = &(ledpriv->SwLed0);
 
 	if (pHalData->EEPROMCustomerID == RT_CID_819x_CAMEO)
-		pLed = &(ledpriv->SwLed1);
+		pled = &(ledpriv->SwLed1);
 
 	switch (LedAction)
 	{
 		case LED_CTL_POWER_ON:
 		case LED_CTL_NO_LINK:
 		case LED_CTL_LINK:	/* solid blue */
-			pLed->CurrLedState = RTW_LED_ON;
-			pLed->BlinkingLedState = RTW_LED_ON;
+			pled->currledstate = RTW_LED_ON;
+			pled->blinkingledstate = RTW_LED_ON;
 
-			_set_timer(&(pLed->BlinkTimer), 0);
+			_set_timer(&(pled->blinktimer), 0);
 			break;
 
 		case LED_CTL_SITE_SURVEY:
 			if ((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
 				;
-			else if (pLed->bLedScanBlinkInProgress ==false)
+			else if (pled->scan_blink_in_prog ==false)
 			{
-				if (pLed->bLedBlinkInProgress ==true)
+				if (pled->blink_in_prog ==true)
 				{
-					_cancel_timer_ex(&(pLed->BlinkTimer));
-					pLed->bLedBlinkInProgress = false;
+					_cancel_timer_ex(&(pled->blinktimer));
+					pled->blink_in_prog = false;
 				}
-				pLed->bLedScanBlinkInProgress = true;
-				pLed->CurrLedState = LED_SCAN_BLINK;
-				pLed->BlinkTimes = 24;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->scan_blink_in_prog = true;
+				pled->currledstate = LED_SCAN_BLINK;
+				pled->blinktimes = 24;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			}
 			break;
 
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if (pLed->bLedBlinkInProgress ==false)
+			if (pled->blink_in_prog ==false)
 			{
-				if (pLed->CurrLedState == LED_SCAN_BLINK)
+				if (pled->currledstate == LED_SCAN_BLINK)
 				{
 					return;
 				}
-				pLed->bLedBlinkInProgress = true;
-				pLed->CurrLedState = LED_TXRX_BLINK;
-				pLed->BlinkTimes = 2;
-				if (pLed->bLedOn)
-					pLed->BlinkingLedState = RTW_LED_OFF;
+				pled->blink_in_prog = true;
+				pled->currledstate = LED_TXRX_BLINK;
+				pled->blinktimes = 2;
+				if (pled->led_on)
+					pled->blinkingledstate = RTW_LED_OFF;
 				else
-					pLed->BlinkingLedState = RTW_LED_ON;
-				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+					pled->blinkingledstate = RTW_LED_ON;
+				_set_timer(&(pled->blinktimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 			}
 			break;
 
 		case LED_CTL_POWER_OFF:
-			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
+			pled->currledstate = RTW_LED_OFF;
+			pled->blinkingledstate = RTW_LED_OFF;
 
-			if (pLed->bLedBlinkInProgress)
+			if (pled->blink_in_prog)
 			{
-				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedBlinkInProgress = false;
+				_cancel_timer_ex(&(pled->blinktimer));
+				pled->blink_in_prog = false;
 			}
 
-			SwLedOff(padapter, pLed);
+			SwLedOff(padapter, pled);
 			break;
 
 		default:
@@ -2329,7 +2329,7 @@ static void SwLedControlMode5(
 
 	}
 
-	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pled->currledstate));
 }
 
 /*  */
--- a/drivers/staging/rtl8192du/include/rtw_cmd.h
+++ b/drivers/staging/rtl8192du/include/rtw_cmd.h
@@ -718,7 +718,7 @@ struct setchannelplan_param
 /*H2C Handler index: 60 */
 struct ledblink_param
 {
-	struct LED_871X	*pLed;
+	struct LED_871X	*pled;
 };
 
 /*H2C Handler index: 61 */
@@ -799,7 +799,7 @@ u8 rtw_chk_hi_queue_cmd(struct rtw_adapt
 
 u8 rtw_set_ch_cmd(struct rtw_adapter*padapter, u8 ch, u8 bw, u8 ch_offset, u8 enqueue);
 u8 rtw_set_chplan_cmd(struct rtw_adapter*padapter, u8 chplan, u8 enqueue);
-u8 rtw_led_blink_cmd(struct rtw_adapter*padapter, struct LED_871X *pLed);
+u8 rtw_led_blink_cmd(struct rtw_adapter*padapter, struct LED_871X *pled);
 u8 rtw_set_csa_cmd(struct rtw_adapter*padapter, u8 new_ch_no);
 u8 rtw_tdls_cmd(struct rtw_adapter*padapter, u8 *addr, u8 option);
 
--- a/drivers/staging/rtl8192du/include/rtw_led.h
+++ b/drivers/staging/rtl8192du/include/rtw_led.h
@@ -59,12 +59,12 @@ enum LED_STATE_871X {
 	LED_BLINK_WPS_STOP_OVERLAP = 12,	/* for BELKIN */
 };
 
-#define IS_LED_WPS_BLINKING(_LED_871X)	(((struct LED_871X *)_LED_871X)->CurrLedState==LED_BLINK_WPS \
-					|| ((struct LED_871X *)_LED_871X)->CurrLedState==LED_BLINK_WPS_STOP \
-					|| ((struct LED_871X *)_LED_871X)->bLedWPSBlinkInProgress)
+#define IS_LED_WPS_BLINKING(_LED_871X)	(((struct LED_871X *)_LED_871X)->currledstate==LED_BLINK_WPS \
+					|| ((struct LED_871X *)_LED_871X)->currledstate==LED_BLINK_WPS_STOP \
+					|| ((struct LED_871X *)_LED_871X)->wps_blink_in_prog)
 
-#define IS_LED_BLINKING(_LED_871X)	(((struct LED_871X *)_LED_871X)->bLedWPSBlinkInProgress \
-					||((struct LED_871X *)_LED_871X)->bLedScanBlinkInProgress)
+#define IS_LED_BLINKING(_LED_871X)	(((struct LED_871X *)_LED_871X)->wps_blink_in_prog \
+					||((struct LED_871X *)_LED_871X)->scan_blink_in_prog)
 
 enum LED_PIN_871X {
 	LED_PIN_GPIO0,
@@ -75,24 +75,24 @@ enum LED_PIN_871X {
 struct LED_871X {
 	struct rtw_adapter				*padapter;
 	enum LED_PIN_871X		LedPin;	/*  Identify how to implement this SW led. */
-	enum LED_STATE_871X		CurrLedState; /*  Current LED state. */
-	u8					bLedOn; /*  true if LED is ON, false if LED is OFF. */
+	enum LED_STATE_871X		currledstate; /*  Current LED state. */
+	u8					led_on; /*  true if LED is ON, false if LED is OFF. */
 
 	u8					bSWLedCtrl;
 
-	u8					bLedBlinkInProgress; /*  true if it is blinking, false o.w.. */
+	u8					blink_in_prog; /*  true if it is blinking, false o.w.. */
 	/*  ALPHA, added by chiyoko, 20090106 */
-	u8					bLedNoLinkBlinkInProgress;
-	u8					bLedLinkBlinkInProgress;
-	u8					bLedStartToLinkBlinkInProgress;
-	u8					bLedScanBlinkInProgress;
-	u8					bLedWPSBlinkInProgress;
+	u8					nolink_blink_in_prog;
+	u8					link_blink_in_prog;
+	u8					start_link_blink_in_prog;
+	u8					scan_blink_in_prog;
+	u8					wps_blink_in_prog;
 
-	u32					BlinkTimes; /*  Number of times to toggle led state for blinking. */
-	enum LED_STATE_871X		BlinkingLedState; /*  Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are. */
+	u32					blinktimes; /*  Number of times to toggle led state for blinking. */
+	enum LED_STATE_871X		blinkingledstate; /*  Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are. */
 
-	struct timer_list		BlinkTimer; /*  Timer object for led blinking. */
-	struct work_struct BlinkWorkItem; /*  Workitem used by BlinkTimer to manipulate H/W to blink LED. */
+	struct timer_list		blinktimer; /*  Timer object for led blinking. */
+	struct work_struct BlinkWorkItem; /*  Workitem used by blinktimer to manipulate H/W to blink LED. */
 };
 
 
@@ -126,6 +126,6 @@ struct led_priv{
 							     (_ledaction)); \
 	} while (0)
 
-extern void BlinkHandler(struct LED_871X *pLed);
+extern void BlinkHandler(struct LED_871X *pled);
 
 #endif /* __RTW_LED_H_ */

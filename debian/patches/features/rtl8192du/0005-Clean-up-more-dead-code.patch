From dc26ebdb07ea92cfc599a650e9609d805932ac18 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Tue, 16 Apr 2013 22:33:30 -0500
Subject: [PATCH 005/390] Clean up more dead code

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 hal/rtl8192d_dm.c       |  241 +-----
 hal/rtl8192d_dm.o       |  Bin 386080 -> 386080 bytes
 hal/usb_ops_bsd.c       | 2068 -----------------------------------------------
 os_dep/ioctl_cfg80211.c |  126 +--
 os_dep/ioctl_linux.c    |  274 +------
 os_dep/ioctl_linux.o    |  Bin 762312 -> 762280 bytes
 6 files changed, 7 insertions(+), 2702 deletions(-)
 delete mode 100644 hal/usb_ops_bsd.c

--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -261,31 +261,17 @@ odm_FalseAlarmCounterStatistics(
 		pbuddy_adapter->recvpriv.FalseAlmCnt_all = FalseAlmCnt->Cnt_all;
 #endif //CONFIG_CONCURRENT_MODE
 
-#if 0 //Just for debug
-	if(pDM_DigTable->CurIGValue < 0x25)
-		FalseAlmCnt->Cnt_all = 12000;
-	else if(pDM_DigTable->CurIGValue < 0x2A)
-		FalseAlmCnt->Cnt_all = 20;
-	else if(pDM_DigTable->CurIGValue < 0x2D)
-		FalseAlmCnt->Cnt_all = 0;
-#endif
-
 	//reset false alarm counter registers
 	PHY_SetBBReg(Adapter, rOFDM1_LSTF, 0x08000000, 1);
 	PHY_SetBBReg(Adapter, rOFDM1_LSTF, 0x08000000, 0);
 	//update ofdm counter
 	PHY_SetBBReg(Adapter, rOFDM0_LSTF, BIT31, 0); //update page C counter
 	PHY_SetBBReg(Adapter, rOFDM1_LSTF, BIT31, 0); //update page D counter
-	if(pHalData->CurrentBandType92D != BAND_ON_5G)
-	{
+	if(pHalData->CurrentBandType92D != BAND_ON_5G) {
 		//reset cck counter
-		//AcquireCCKAndRWPageAControl(Adapter);
-		//RT_TRACE(COMP_INIT,DBG_LOUD,("Acquiere mutex in dm_falsealarmcount 111 \n"));
 		PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, 0x0000c000, 0);
 		//enable cck counter
 		PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, 0x0000c000, 2);
-		//ReleaseCCKAndRWPageAControl(Adapter);
-		//RT_TRACE(COMP_INIT,DBG_LOUD,("Release mutex in dm_falsealarmcount 111 \n"));
 	}
 
 	//BB Reset
@@ -430,24 +416,6 @@ odm_initial_gain_MinPWDB(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	s32	Rssi_val_min = 0;
-#if 0
-	pDIG_T	pDM_DigTable = &pdmpriv->DM_DigTable;
-
-	if(	(pDM_DigTable->CurMultiSTAConnectState == DIG_MultiSTA_CONNECT) &&
-		(pDM_DigTable->CurSTAConnectState == DIG_STA_CONNECT) )
-	{
-		if(pHalData->EntryMinUndecoratedSmoothedPWDB != 0)
-			Rssi_val_min  =  (pdmpriv->EntryMinUndecoratedSmoothedPWDB > pdmpriv->UndecoratedSmoothedPWDB)?
-					pdmpriv->UndecoratedSmoothedPWDB:pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-		else
-			Rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
-	}
-	else if(	pDM_DigTable->CurSTAConnectState == DIG_STA_CONNECT ||
-			pDM_DigTable->CurSTAConnectState == DIG_STA_BEFORE_CONNECT)
-		Rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
-	else if(pDM_DigTable->CurMultiSTAConnectState == DIG_MultiSTA_CONNECT)
-		Rssi_val_min = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
-#endif
 	if(pdmpriv->EntryMinUndecoratedSmoothedPWDB != 0)
 		Rssi_val_min  =  (pdmpriv->EntryMinUndecoratedSmoothedPWDB > pdmpriv->UndecoratedSmoothedPWDB)?
 					pdmpriv->UndecoratedSmoothedPWDB:pdmpriv->EntryMinUndecoratedSmoothedPWDB;
@@ -1752,23 +1720,6 @@ IN	PADAPTER	pAdapter
 #endif
 			dm_1R_CCA(pAdapter);
 	}
-
-#if 0
-	if(bRestoreRssi)
-	{
-		bRestoreRssi = _FALSE;
-		pdmpriv->MinUndecoratedPWDBForDM = Rssi_val_min_back_for_mac0;
-	}
-#endif
-
-// 20100628 Joseph: Turn off BB power save for 88CE because it makesthroughput unstable.
-#if 0
-	//1 3.Power Saving for 88C
-	if(!IS_92C_SERIAL(pHalData->VersionID))
-	{
-		dm_RF_Saving(pAdapter, FALSE);
-	}
-#endif
 }
 
 static	VOID
@@ -2561,162 +2512,6 @@ dm_InitRateAdaptiveMask(
 static VOID
 dm_RefreshRateAdaptiveMask(	IN	PADAPTER	pAdapter)
 {
-#if 0
-	PADAPTER				pTargetAdapter;
-	HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(pAdapter);
-	PMGNT_INFO				pMgntInfo = &(ADJUST_TO_ADAPTIVE_ADAPTER(pAdapter, TRUE)->MgntInfo);
-	PRATE_ADAPTIVE			pRA = (PRATE_ADAPTIVE)&pMgntInfo->RateAdaptive;
-	u4Byte					LowRSSIThreshForRA = 0, HighRSSIThreshForRA = 0;
-
-	if(pAdapter->bDriverStopped)
-	{
-		RT_TRACE(COMP_RATR, DBG_TRACE, ("<---- dm_RefreshRateAdaptiveMask(): driver is going to unload\n"));
-		return;
-	}
-
-	if(!pMgntInfo->bUseRAMask)
-	{
-		RT_TRACE(COMP_RATR, DBG_LOUD, ("<---- dm_RefreshRateAdaptiveMask(): driver does not control rate adaptive mask\n"));
-		return;
-	}
-
-	// if default port is connected, update RA table for default port (infrastructure mode only)
-	if(pAdapter->MgntInfo.mAssoc && (!ACTING_AS_AP(pAdapter)))
-	{
-
-		// decide rastate according to rssi
-		switch (pRA->PreRATRState)
-		{
-			case DM_RATR_STA_HIGH:
-				HighRSSIThreshForRA = 50;
-				LowRSSIThreshForRA = 20;
-				break;
-
-			case DM_RATR_STA_MIDDLE:
-				HighRSSIThreshForRA = 55;
-				LowRSSIThreshForRA = 20;
-				break;
-
-			case DM_RATR_STA_LOW:
-				HighRSSIThreshForRA = 50;
-				LowRSSIThreshForRA = 25;
-				break;
-
-			default:
-				HighRSSIThreshForRA = 50;
-				LowRSSIThreshForRA = 20;
-				break;
-		}
-
-		if(pHalData->UndecoratedSmoothedPWDB > (s4Byte)HighRSSIThreshForRA)
-			pRA->RATRState = DM_RATR_STA_HIGH;
-		else if(pHalData->UndecoratedSmoothedPWDB > (s4Byte)LowRSSIThreshForRA)
-			pRA->RATRState = DM_RATR_STA_MIDDLE;
-		else
-			pRA->RATRState = DM_RATR_STA_LOW;
-
-		if(pRA->PreRATRState != pRA->RATRState)
-		{
-			RT_PRINT_ADDR(COMP_RATR, DBG_LOUD, ("Target AP addr : "), pMgntInfo->Bssid);
-			RT_TRACE(COMP_RATR, DBG_LOUD, ("RSSI = %ld\n", pHalData->UndecoratedSmoothedPWDB));
-			RT_TRACE(COMP_RATR, DBG_LOUD, ("RSSI_LEVEL = %d\n", pRA->RATRState));
-			RT_TRACE(COMP_RATR, DBG_LOUD, ("PreState = %d, CurState = %d\n", pRA->PreRATRState, pRA->RATRState));
-			pAdapter->HalFunc.UpdateHalRAMaskHandler(
-									pAdapter,
-									FALSE,
-									0,
-									NULL,
-									NULL,
-									pRA->RATRState);
-			pRA->PreRATRState = pRA->RATRState;
-		}
-	}
-
-	//
-	// The following part configure AP/VWifi/IBSS rate adaptive mask.
-	//
-	if(ACTING_AS_AP(pAdapter) || ACTING_AS_IBSS(pAdapter))
-	{
-		pTargetAdapter = pAdapter;
-	}
-	else
-	{
-		pTargetAdapter = ADJUST_TO_ADAPTIVE_ADAPTER(pAdapter, FALSE);
-		if(!ACTING_AS_AP(pTargetAdapter))
-			pTargetAdapter = NULL;
-	}
-
-	// if extension port (softap) is started, updaet RA table for more than one clients associate
-	if(pTargetAdapter != NULL)
-	{
-		int	i;
-		PRT_WLAN_STA	pEntry;
-		PRATE_ADAPTIVE     pEntryRA;
-
-		for(i = 0; i < ASSOCIATE_ENTRY_NUM; i++)
-		{
-			if(	pTargetAdapter->MgntInfo.AsocEntry[i].bUsed && pTargetAdapter->MgntInfo.AsocEntry[i].bAssociated)
-			{
-				pEntry = pTargetAdapter->MgntInfo.AsocEntry+i;
-				pEntryRA = &pEntry->RateAdaptive;
-
-				switch (pEntryRA->PreRATRState)
-				{
-					case DM_RATR_STA_HIGH:
-					{
-						HighRSSIThreshForRA = 50;
-						LowRSSIThreshForRA = 20;
-					}
-					break;
-
-					case DM_RATR_STA_MIDDLE:
-					{
-						HighRSSIThreshForRA = 55;
-						LowRSSIThreshForRA = 20;
-					}
-					break;
-
-					case DM_RATR_STA_LOW:
-					{
-						HighRSSIThreshForRA = 50;
-						LowRSSIThreshForRA = 25;
-					}
-					break;
-
-					default:
-					{
-						HighRSSIThreshForRA = 50;
-						LowRSSIThreshForRA = 20;
-					}
-				}
-
-				if(pEntry->rssi_stat.UndecoratedSmoothedPWDB > (s4Byte)HighRSSIThreshForRA)
-					pEntryRA->RATRState = DM_RATR_STA_HIGH;
-				else if(pEntry->rssi_stat.UndecoratedSmoothedPWDB > (s4Byte)LowRSSIThreshForRA)
-					pEntryRA->RATRState = DM_RATR_STA_MIDDLE;
-				else
-					pEntryRA->RATRState = DM_RATR_STA_LOW;
-
-				if(pEntryRA->PreRATRState != pEntryRA->RATRState)
-				{
-					RT_PRINT_ADDR(COMP_RATR, DBG_LOUD, ("AsocEntry addr : "), pEntry->MacAddr);
-					RT_TRACE(COMP_RATR, DBG_LOUD, ("RSSI = %ld\n", pEntry->rssi_stat.UndecoratedSmoothedPWDB));
-					RT_TRACE(COMP_RATR, DBG_LOUD, ("RSSI_LEVEL = %d\n", pEntryRA->RATRState));
-					RT_TRACE(COMP_RATR, DBG_LOUD, ("PreState = %d, CurState = %d\n", pEntryRA->PreRATRState, pEntryRA->RATRState));
-					pAdapter->HalFunc.UpdateHalRAMaskHandler(
-											pTargetAdapter,
-											FALSE,
-											pEntry->AID+1,
-											pEntry->MacAddr,
-											pEntry,
-											pEntryRA->RATRState);
-					pEntryRA->PreRATRState = pEntryRA->RATRState;
-				}
-
-			}
-		}
-	}
-#endif
 }
 #ifndef PLATFORM_FREEBSD
 static VOID
@@ -2724,26 +2519,6 @@ dm_CheckProtection(
 	IN	PADAPTER	Adapter
 	)
 {
-#if 0
-	PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
-	u1Byte			CurRate, RateThreshold;
-
-	if(pMgntInfo->pHTInfo->bCurBW40MHz)
-		RateThreshold = MGN_MCS1;
-	else
-		RateThreshold = MGN_MCS3;
-
-	if(Adapter->TxStats.CurrentInitTxRate <= RateThreshold)
-	{
-		pMgntInfo->bDmDisableProtect = TRUE;
-		DbgPrint("Forced disable protect: %x\n", Adapter->TxStats.CurrentInitTxRate);
-	}
-	else
-	{
-		pMgntInfo->bDmDisableProtect = FALSE;
-		DbgPrint("Enable protect: %x\n", Adapter->TxStats.CurrentInitTxRate);
-	}
-#endif
 }
 #endif //PLATFORM_FREEBSD
 
@@ -2752,20 +2527,6 @@ dm_CheckStatistics(
 	IN	PADAPTER	Adapter
 	)
 {
-#if 0
-	if(!Adapter->MgntInfo.bMediaConnect)
-		return;
-
-	//2008.12.10 tynli Add for getting Current_Tx_Rate_Reg flexibly.
-	rtw_hal_get_hwreg( Adapter, HW_VAR_INIT_TX_RATE, (pu1Byte)(&Adapter->TxStats.CurrentInitTxRate) );
-
-	// Calculate current Tx Rate(Successful transmited!!)
-
-	// Calculate current Rx Rate(Successful received!!)
-
-	//for tx tx retry count
-	rtw_hal_get_hwreg( Adapter, HW_VAR_RETRY_COUNT, (pu1Byte)(&Adapter->TxStats.NumTxRetryCount) );
-#endif
 }
 
 //
--- a/drivers/staging/rtl8192du/hal/usb_ops_bsd.c
+++ /dev/null
@@ -1,2068 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#define _HCI_OPS_OS_C_
-
-#include <drv_conf.h>
-#include <osdep_service.h>
-#include <drv_types.h>
-#include <osdep_intf.h>
-#include <usb_ops.h>
-#include <circ_buf.h>
-#include <recv_osdep.h>
-#include <rtl8192d_hal.h>
-
-#if defined (PLATFORM_LINUX) && defined (PLATFORM_FREEBSD)
-
-#error "Shall be Linux or FreeBSD, but not both!\n"
-
-#endif
-
-struct zero_bulkout_context{
-	void *pbuf;
-	void *purb;
-	void *pirp;
-	void *padapter;
-};
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
-#define USB_CONTROL_MSG_TIMEOUT	500		//ms
-#else
-#define USB_CONTROL_MSG_TIMEOUT	HZ/2	//jiffies
-#endif
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)) || (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
-#define _usbctrl_vendorreq_async_callback(urb, regs)	_usbctrl_vendorreq_async_callback(urb)
-#define usb_bulkout_zero_complete(purb, regs)	usb_bulkout_zero_complete(purb)
-#define usb_write_mem_complete(purb, regs)	usb_write_mem_complete(purb)
-#define usb_write_port_complete(purb, regs)	usb_write_port_complete(purb)
-#define usb_read_port_complete(purb, regs)	usb_read_port_complete(purb)
-#define usb_read_interrupt_complete(purb, regs)	usb_read_interrupt_complete(purb)
-#endif
-
-#ifdef CONFIG_USB_VENDOR_REQ_PREALLOC
-static int usbctrl_vendorreq(struct dvobj_priv  *pdvobjpriv, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype)
-{
-#ifdef PLATFORM_FREEBSD
-	struct usb_host_endpoint *pipe;
-#else /* PLATFORM_FREEBSD */
-	unsigned int pipe;
-#endif /* PLATFORM_FREEBSD */
-	int status = 0;
-	u32 tmp_buflen=0;
-	u8 reqtype;
-	u8 *pIo_buf;
-	_adapter		*padapter = pdvobjpriv->padapter ;
-	struct usb_device *udev=pdvobjpriv->pusbdev;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pdvobjpriv->padapter);
-
-	if( (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usbctrl_vendorreq:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
-		return(-1);
-	}
-
-	if(len>MAX_VENDOR_REQ_CMD_SIZE)
-	{
-		DBG_8192C( "[%s] Buffer len error ,vendor request failed\n", __FUNCTION__ );
-		return(-1);
-	}
-
-	if ( pdvobjpriv->usb_vendor_req_buf== NULL)
-	{
-		DBG_8192C( "[%s] usb_vendor_req_buf == NULL \n", __FUNCTION__ );
-		return(-1);
-	}
-
-	_enter_critical_mutex(&pdvobjpriv->usb_vendor_req_mutex, NULL);
-
-	pIo_buf = pdvobjpriv->usb_vendor_req_buf;
-	_rtw_memset(pIo_buf, 0, MAX_VENDOR_REQ_CMD_SIZE);
-
-	if (requesttype == 0x01)
-	{
-		pipe = usb_rcvctrlpipe(udev, 0);//read_in
-		reqtype =  REALTEK_USB_VENQT_READ;
-	}
-	else
-	{
-		pipe = usb_sndctrlpipe(udev, 0);//write_out
-		reqtype =  REALTEK_USB_VENQT_WRITE;
-		_rtw_memcpy( pIo_buf, pdata, len);
-	}
-
-	if (requesttype == 0x01)
-	{
-		if (pHalData->interfaceIndex!=0)
-		{
-			if(value<0x1000)
-				value|=0x4000;
-			else if ((value&MAC1_ACCESS_PHY0) && !(value&0x8000))
-				value &= 0xfff;
-			index = 0;
-		}
-
-		pipe = usb_rcvctrlpipe(udev, 0);//read_in
-		reqtype =  REALTEK_USB_VENQT_READ;
-	}
-	else
-	{
-		if (pHalData->interfaceIndex!=0)
-		{
-			if(value<0x1000)
-				value|=0x4000;
-			else if((value&MAC1_ACCESS_PHY0) && !(value&0x8000))// MAC1 need to access PHY0
-				value &= 0xFFF;
-			index = 0;
-		}
-
-		pipe = usb_sndctrlpipe(udev, 0);//write_out
-		reqtype =  REALTEK_USB_VENQT_WRITE;
-		_rtw_memcpy( pIo_buf, pdata, len);
-	}
-
-	status = usb_control_msg(udev, pipe, request, reqtype, value, index, pIo_buf, len, USB_CONTROL_MSG_TIMEOUT);
-
-	if (status < 0)
-       {
-	if(status == (-ESHUTDOWN))
-		{
-			DBG_8192C("reg 0x%x, usb %s  fail ,status:%d value=0x%x\n", value,(requesttype == 0x01)?"read":"write" , status, *(u32*)pdata);
-			padapter->bDriverStopped=_TRUE;
-		}
-		else{
-			DBG_8192C("reg 0x%x, usb %s  fail ,status:%d value=0x%x\n", value,(requesttype == 0x01)?"read":"write" , status, *(u32*)pdata);
-#ifdef DBG_CONFIG_ERROR_DETECT
-			{
-				_adapter *padapter =  pdvobjpriv->padapter;
-				HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
-				pHalData->srestpriv.Wifi_Error_Status = USB_VEN_REQ_CMD_FAIL;
-			}
-#endif
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("reg 0x%x, usb %s  fail ,status:%d value=0x%x\n", value, status, *(u32*)pdata));
-		}
-       }
-	else if ( status > 0 )   // Success this control transfer.
-	{
-               if ( requesttype == 0x01 )
-               {   // For Control read transfer, we have to copy the read data from pIo_buf to pdata.
-                       _rtw_memcpy( pdata, pIo_buf,  status );
-               }
-	}
-	_exit_critical_mutex(&pdvobjpriv->usb_vendor_req_mutex, NULL);
-	return status;
-}
-
-#else
-static int usbctrl_vendorreq(struct dvobj_priv  *pdvobjpriv, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype)
-{
-#ifdef PLATFORM_FREEBSD
-	struct usb_host_endpoint *pipe;
-#else /* PLATFORM_FREEBSD */
-	unsigned int	pipe;
-#endif /* PLATFORM_FREEBSD */
-	int	status;
-	u8	reqtype;
-	u32	tmp_buflen=0;
-	_adapter		*padapter = pdvobjpriv->padapter ;
-
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC
-	dma_addr_t	dma_addr;
-#else
-
-#ifndef CONFIG_DYNAMIC_ALLOCIATE_VENDOR_CMD
-	u8	tmp_buf[MAX_USB_IO_CTL_SIZE];
-#endif
-
-#endif
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pdvobjpriv->padapter);
-	struct usb_device	*udev=pdvobjpriv->pusbdev;
-
-	// Added by Albert 2010/02/09
-	// For mstar platform, mstar suggests the address for USB IO should be 16 bytes alignment.
-	// Trying to fix it here.
-
-	u8 *palloc_buf, *pIo_buf;
-	if( (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usbctrl_vendorreq:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
-		return _FAIL;
-	}
-
-	if(len>MAX_VENDOR_REQ_CMD_SIZE)
-	{
-		DBG_8192C( "[%s] Buffer len error ,vendor request failed\n", __FUNCTION__ );
-		return(-1);
-	}
-
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
-	pIo_buf = usb_alloc_coherent(udev, (size_t)len, GFP_ATOMIC, &dma_addr);
-#else
-        pIo_buf = rtw_usb_buffer_alloc(udev, (size_t)len, GFP_ATOMIC, &dma_addr);
-#endif
-
-	if(pIo_buf == NULL)
-	{
-		DBG_8192C( "[%s] Can't alloc memory for vendor request\n", __FUNCTION__);
-		return(-1);
-	}
-
-	_rtw_memset(pIo_buf, 0, len);
-
-#else
-
-#ifdef CONFIG_DYNAMIC_ALLOCIATE_VENDOR_CMD
-	palloc_buf = rtw_malloc( (u32) len + ALIGNMENT_UNIT);
-	tmp_buflen =  (u32)len + ALIGNMENT_UNIT;
-#else
-	palloc_buf = tmp_buf;
-	tmp_buflen = MAX_USB_IO_CTL_SIZE;
-#endif
-
-	if ( palloc_buf== NULL)
-	{
-		DBG_8192C( "[%s] Can't alloc memory for vendor request\n", __FUNCTION__ );
-		return(-1);
-	}
-
-	_rtw_memset(palloc_buf, 0, tmp_buflen);
-
-	pIo_buf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(palloc_buf), ALIGNMENT_UNIT);
-
-#endif
-
-	if (requesttype == 0x01)
-	{
-		if((value & 0xff00) == 0xff00)
-		{
-			// Temply for pomelo read/write 0x00-0x100 ,will removed when the 0xffxx register eanble  zhiyuan 2009/10/23
-			value &= 0x00ff;
-		}
-		if (pHalData->interfaceIndex!=0)
-		{
-			if(value<0x1000)
-				value|=0x4000;
-			else if ((value&MAC1_ACCESS_PHY0) && !(value&0x8000))
-				value &= 0xfff;
-			index = 0;
-		}
-
-		pipe = usb_rcvctrlpipe(udev, 0);//read_in
-		reqtype =  REALTEK_USB_VENQT_READ;
-	}
-	else
-	{
-		if((value & 0xff00) == 0xff00)
-		{
-			// Temply for pomelo read/write 0x00-0x100 ,will removed when the 0xffxx register eanble  zhiyuan 2009/10/23
-			value &= 0x00ff;
-		}
-		if (pHalData->interfaceIndex!=0)
-		{
-			if(value<0x1000)
-				value|=0x4000;
-			else if((value&MAC1_ACCESS_PHY0) && !(value&0x8000))// MAC1 need to access PHY0
-				value &= 0xFFF;
-			index = 0;
-		}
-
-		pipe = usb_sndctrlpipe(udev, 0);//write_out
-		reqtype =  REALTEK_USB_VENQT_WRITE;
-		_rtw_memcpy( pIo_buf, pdata, len);
-	}
-
-        status = rtw_usb_control_msg(udev, pipe, request, reqtype, value, index, pIo_buf, len, USB_CONTROL_MSG_TIMEOUT);
-
-	if (status < 0)
-       {
-		DBG_8192C("reg 0x%x, usb read/write TimeOut! status:%d value=0x%x\n", value, status, *(u32*)pdata);
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("reg 0x%x, usb_read8 TimeOut! status:0x%x value=0x%x\n", value, status, *(u32*)pdata));
-       }
-	else if ( status > 0 )   // Success this control transfer.
-	{
-               if ( requesttype == 0x01 )
-               {   // For Control read transfer, we have to copy the read data from pIo_buf to pdata.
-                       _rtw_memcpy( pdata, pIo_buf,  status );
-               }
-	}
-
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
-	usb_free_coherent(udev, (size_t)len, pIo_buf, dma_addr);
-#else
-        rtw_usb_buffer_free(udev, (size_t)len, pIo_buf, dma_addr);
-#endif
-
-#else
-
-#ifdef CONFIG_DYNAMIC_ALLOCIATE_VENDOR_CMD
-	rtw_mfree( palloc_buf,tmp_buflen);
-#endif
-
-#endif
-
-	return status;
-
-}
-#endif
-
-static u8 usb_read8(struct intf_hdl *pintfhdl, u32 addr)
-{
-	u8 request;
-	u8 requesttype;
-	u16 wvalue;
-	u16 index;
-	u16 len;
-	u32 data=0;
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-
-	_func_enter_;
-
-	request = 0x05;
-	requesttype = 0x01;//read_in
-	index = 0;//n/a
-
-	wvalue = (u16)(addr&0x0000ffff);
-	len = 1;
-
-	usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
-
-	_func_exit_;
-
-	return (u8)(le32_to_cpu(data)&0x0ff);
-
-}
-
-static u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr)
-{
-	u8 request;
-	u8 requesttype;
-	u16 wvalue;
-	u16 index;
-	u16 len;
-	u32 data=0;
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-
-	_func_enter_;
-
-	request = 0x05;
-	requesttype = 0x01;//read_in
-	index = 0;//n/a
-
-	wvalue = (u16)(addr&0x0000ffff);
-	len = 2;
-
-	usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
-
-	_func_exit_;
-
-	return (u16)(le32_to_cpu(data)&0xffff);
-
-}
-
-static void usb_read_rf_byfw(struct dvobj_priv  *pdvobjpriv, u16 byteCount, u32 registerIndex, PVOID buffer)
-{
-	u16	wPage = 0x0000, offset;
-	PADAPTER	Adapter = pdvobjpriv->padapter;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	u8	RFPath=0,nPHY=0;
-
-	RFPath =(u8) ((registerIndex&0xff0000)>>16);
-
-	if (pHalData->interfaceIndex!=0)
-	{
-		nPHY = 1; //MAC1
-		if(registerIndex&MAC1_ACCESS_PHY0)// MAC1 need to access PHY0
-			nPHY = 0;
-	}
-	else
-	{
-		if(registerIndex&MAC0_ACCESS_PHY1)
-			nPHY = 1;
-	}
-	registerIndex &= 0xFF;
-	wPage = ((nPHY<<7)|(RFPath<<5)|8)<<8;
-	offset = (u16)registerIndex;
-
-	//
-	// IN a vendor request to read back MAC register.
-	//
-	usbctrl_vendorreq(pdvobjpriv, 0x05, offset, wPage, buffer, byteCount, 0x01);
-
-}
-
-static u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr)
-{
-	u8 request;
-	u8 requesttype;
-	u16 wvalue;
-	u16 index;
-	u16 len;
-	u32 data=0;
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-
-	_func_enter_;
-
-	request = 0x05;
-	requesttype = 0x01;//read_in
-	index = 0;//n/a
-
-	wvalue = (u16)(addr&0x0000ffff);
-	len = 4;
-
-	if((addr&0xff000000)>>24 == 0x66){
-		usb_read_rf_byfw(pdvobjpriv, len, addr, &data);
-	}
-	else {
-		usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
-	}
-
-	_func_exit_;
-
-	return le32_to_cpu(data);
-
-}
-
-static void usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
-{
-	u8 request;
-	u8 requesttype;
-	u16 wvalue;
-	u16 index;
-	u16 len;
-	u32 data;
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-
-	_func_enter_;
-
-	request = 0x05;
-	requesttype = 0x00;//write_out
-	index = 0;//n/a
-
-	wvalue = (u16)(addr&0x0000ffff);
-	len = 1;
-
-	data = val;
-	data = cpu_to_le32(data&0x000000ff);
-
-	usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
-
-	_func_exit_;
-
-}
-
-static void usb_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val)
-{
-	u8 request;
-	u8 requesttype;
-	u16 wvalue;
-	u16 index;
-	u16 len;
-	u32 data;
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-
-	_func_enter_;
-
-	request = 0x05;
-	requesttype = 0x00;//write_out
-	index = 0;//n/a
-
-	wvalue = (u16)(addr&0x0000ffff);
-	len = 2;
-
-	data = val;
-	data = cpu_to_le32(data&0x0000ffff);
-
-	usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
-
-	_func_exit_;
-
-}
-
-static void usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
-{
-	u8 request;
-	u8 requesttype;
-	u16 wvalue;
-	u16 index;
-	u16 len;
-	u32 data;
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-
-	_func_enter_;
-
-	request = 0x05;
-	requesttype = 0x00;//write_out
-	index = 0;//n/a
-
-	wvalue = (u16)(addr&0x0000ffff);
-	len = 4;
-	data = cpu_to_le32(val);
-
-	usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, &data, len, requesttype);
-
-	_func_exit_;
-
-}
-#define VENDOR_CMD_MAX_DATA_LEN	254
-void usb_writeN(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata);
-void usb_writeN(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata)
-{
-	u8 request;
-	u8 requesttype;
-	u16 wvalue;
-	u16 index;
-	u16 len;
-	u8 buf[VENDOR_CMD_MAX_DATA_LEN]={0};
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-
-	_func_enter_;
-
-	request = 0x05;
-	requesttype = 0x00;//write_out
-	index = 0;//n/a
-
-	wvalue = (u16)(addr&0x0000ffff);
-	len = length;
-	 _rtw_memcpy(buf, pdata, len );
-
-	usbctrl_vendorreq(pdvobjpriv, request, wvalue, index, buf, len, requesttype);
-
-	_func_exit_;
-
-}
-
-#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
-#ifndef PLATFORM_FREEBSD
-static void _usbctrl_vendorreq_async_callback(struct urb *urb, struct pt_regs *regs)
-{
-	if(urb){
-		if(urb->context){
-			rtw_mfree(urb->context);
-		}
-                rtw_usb_free_urb(urb);
-	}
-}
-
-static int _usbctrl_vendorreq_async_write(struct usb_device *udev, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype)
-{
-	int rc;
-	unsigned int pipe;
-	u8 reqtype;
-	struct usb_ctrlrequest *dr;
-	struct urb *urb;
-	struct rtl819x_async_write_data {
-		u8 data[VENDOR_CMD_MAX_DATA_LEN];
-		struct usb_ctrlrequest dr;
-	} *buf;
-
-
-	if (requesttype == VENDOR_READ){
-		pipe = usb_rcvctrlpipe(udev, 0);//read_in
-		reqtype =  REALTEK_USB_VENQT_READ;
-	}
-	else {
-		pipe = usb_sndctrlpipe(udev, 0);//write_out
-		reqtype =  REALTEK_USB_VENQT_WRITE;
-	}
-
-	//buf = kmalloc(sizeof(*buf), GFP_ATOMIC);
-	buf = (struct rtl819x_async_write_data *)rtw_zmalloc(sizeof(*buf));
-	if (!buf)
-		return -ENOMEM;
-
-	urb = usb_alloc_urb(0, GFP_ATOMIC);
-	if (!urb) {
-		rtw_mfree((u8*)buf, sizeof(*buf));
-		return -ENOMEM;
-	}
-
-	dr = &buf->dr;
-
-	dr->bRequestType = reqtype;
-	dr->bRequest = request;
-	dr->wValue = cpu_to_le16(value);
-	dr->wIndex = cpu_to_le16(index);
-	dr->wLength = cpu_to_le16(len);
-
-	_rtw_memcpy(buf, pdata, len);
-
-	usb_fill_control_urb(urb, udev, pipe,
-			     (unsigned char *)dr, buf, len,
-			     _usbctrl_vendorreq_async_callback, buf);
-
-	rc = usb_submit_urb(urb, GFP_ATOMIC);
-	if (rc < 0) {
-		rtw_mfree((u8*)buf, sizeof(*buf));
-		usb_free_urb(urb);
-	}
-	return rc;
-}
-#endif /* PLATFORM_FREEBSD */
-
-static void usb_write_async(struct usb_device *udev, u32 addr, u32 val, u16 len)
-{
-#ifndef PLATFORM_FREEBSD
-	u8 request;
-	u8 requesttype;
-	u16 wvalue;
-	u16 index;
-	u32 data;
-
-	requesttype = VENDOR_WRITE;//write_out
-	request = REALTEK_USB_VENQT_CMD_REQ;
-	index = REALTEK_USB_VENQT_CMD_IDX;//n/a
-
-	wvalue = (u16)(addr&0x0000ffff);
-	data = val & (0xffffffff >> ((4 - len) * 8));
-	data = cpu_to_le32(data);
-
-	_usbctrl_vendorreq_async_write(udev, request, wvalue, index, &data, len, requesttype);
-#else /* PLATFORM_FREEBSD */
-	DBG_8192C("*** %s() is not implemented! ***\n", __FUNCTION__);
-#endif /* PLATFORM_FREEBSD */
-}
-static void usb_async_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
-{
-	u32 data;
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-	struct usb_device *udev=pdvobjpriv->pusbdev;
-
-	_func_enter_;
-	data = cpu_to_le32(val & 0xFF);
-	usb_write_async(udev, addr, val, 1);
-	_func_exit_;
-}
-
-static void usb_async_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val)
-{
-	u32 data;
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-	struct usb_device *udev=pdvobjpriv->pusbdev;
-
-	_func_enter_;
-	data = cpu_to_le32(val & 0xFFFF);
-	usb_write_async(udev, addr, val, 2);
-	_func_exit_;
-}
-static void usb_async_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
-{
-	u32 data;
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfhdl->pintf_dev;
-	struct usb_device *udev=pdvobjpriv->pusbdev;
-
-	_func_enter_;
-	data = cpu_to_le32(val);
-	usb_write_async(udev, addr, val, 4);
-	_func_exit_;
-}
-#endif
-
-static struct usb_host_endpoint * ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr)
-{
-	struct usb_host_endpoint *pipe = NULL;
-	int ep_num=0;
-	_adapter *padapter = pdvobj->padapter;
-	struct usb_device *pusbd = pdvobj->pusbdev;
-	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
-
-	if(addr == RECV_BULK_IN_ADDR)
-	{
-		pipe=usb_rcvbulkpipe(pusbd, pHalData->RtBulkInPipe);
-
-		return pipe;
-	}
-
-	if(addr == RECV_INT_IN_ADDR)
-	{
-		pipe=usb_rcvbulkpipe(pusbd, pHalData->RtIntInPipe);
-
-		return pipe;
-	}
-
-	if(addr < HW_QUEUE_ENTRY)
-	{
-		//ep_num = (pHalData->Queue2EPNum[(u8)addr] & 0x0f);
-		ep_num = pHalData->Queue2EPNum[addr];
-
-		pipe = usb_sndbulkpipe(pusbd, ep_num);
-
-		return pipe;
-	}
-
-	return pipe;
-
-}
-#ifndef PLATFORM_FREEBSD
-static void usb_bulkout_zero_complete(struct urb *purb, struct pt_regs *regs)
-{
-	struct zero_bulkout_context *pcontext = (struct zero_bulkout_context *)purb->context;
-
-	//DBG_8192C("+usb_bulkout_zero_complete\n");
-
-	if(pcontext)
-	{
-		if(pcontext->pbuf)
-		{
-			rtw_mfree(pcontext->pbuf, sizeof(int));
-		}
-
-		if(pcontext->purb && (pcontext->purb==purb))
-		{
-                        rtw_usb_free_urb(pcontext->purb);
-		}
-
-
-		rtw_mfree((u8*)pcontext, sizeof(struct zero_bulkout_context));
-	}
-
-
-}
-
-static u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
-{
-	int status, len;
-	struct usb_host_endpoint *pipe;
-	u32 ret;
-	unsigned char *pbuf;
-	struct zero_bulkout_context *pcontext;
-	PURB	purb = NULL;
-	_adapter *padapter = (_adapter *)pintfhdl->padapter;
-	struct dvobj_priv *pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
-	struct usb_device *pusbd = pdvobj->pusbdev;
-
-	//DBG_8192C("+usb_bulkout_zero\n");
-
-
-	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
-	{
-		return _FAIL;
-	}
-
-
-	pcontext = (struct zero_bulkout_context *)rtw_malloc(sizeof(struct zero_bulkout_context));
-
-	pbuf = (unsigned char *)rtw_malloc(sizeof(int));
-        purb = rtw_usb_alloc_urb(0, GFP_ATOMIC);
-
-	len = 0;
-	pcontext->pbuf = pbuf;
-	pcontext->purb = purb;
-	pcontext->pirp = NULL;
-	pcontext->padapter = padapter;
-
-
-	//translate DMA FIFO addr to pipehandle
-	//pipe = ffaddr2pipehdl(pdvobj, addr);
-
-        rtw_usb_fill_bulk_urb(purb, pusbd, pipe,
-				pbuf,
-				len,
-				usb_bulkout_zero_complete,
-				pcontext);//context is pcontext
-
-        status = rtw_usb_submit_urb(purb, GFP_ATOMIC);
-
-	if (!status)
-	{
-		ret= _SUCCESS;
-	}
-	else
-	{
-		ret= _FAIL;
-	}
-
-
-	return _SUCCESS;
-
-}
-#endif /* PLATFORM_FREEBSD */
-
-static void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
-{
-
-}
-
-static void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
-{
-
-}
-
-#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
-static void usb_read_interrupt_complete(struct urb *purb, struct pt_regs *regs)
-{
-	int	err;
-	_adapter		*padapter = (_adapter	 *)purb->context;
-
-	padapter->recvpriv.int_cnt ++;
-	if(purb->status==0)//SUCCESS
-	{
-		if (purb->actual_length > sizeof(INTERRUPT_MSG_FORMAT_EX))
-		{
-			DBG_8192C("usb_read_interrupt_complete: purb->actual_length > sizeof(INTERRUPT_MSG_FORMAT_EX) \n");
-		}
-
-                err = rtw_usb_submit_urb(purb, GFP_ATOMIC);
-		if((err) && (err != (-EPERM)))
-		{
-			DBG_8192C("cannot submit interrupt in-token(err = 0x%08x),urb_status = %d\n",err, purb->status);
-		}
-	}
-	else
-	{
-		DBG_8192C("###=> usb_read_interrupt_complete => urb status(%d)\n", purb->status);
-
-		switch(purb->status) {
-			case -EINVAL:
-			case -EPIPE:
-			case -ENODEV:
-			case -ESHUTDOWN:
-				//padapter->bSurpriseRemoved=_TRUE;
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
-			case -ENOENT:
-				padapter->bDriverStopped=_TRUE;
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
-				break;
-			case -EPROTO:
-				break;
-			case -EINPROGRESS:
-				DBG_8192C("ERROR: URB IS IN PROGRESS!/n");
-				break;
-			default:
-				break;
-		}
-	}
-
-}
-
-static u32 usb_read_interrupt(struct intf_hdl *pintfhdl, u32 addr)
-{
-	int	err;
-	struct usb_host_endpoint *pipe;
-	u32	ret = _SUCCESS;
-	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)pintfhdl->pintf_dev;
-	_adapter			*adapter = (_adapter *)pdvobj->padapter;
-	struct recv_priv	*precvpriv = &adapter->recvpriv;
-	struct usb_device	*pusbd = pdvobj->pusbdev;
-
-_func_enter_;
-
-	//translate DMA FIFO addr to pipehandle
-	pipe = ffaddr2pipehdl(pdvobj, addr);
-
-	usb_fill_int_urb(precvpriv->int_in_urb, pusbd, pipe,
-					precvpriv->int_in_buf,
-					sizeof(INTERRUPT_MSG_FORMAT_EX),
-					usb_read_interrupt_complete,
-					adapter,
-					3);
-
-        err = rtw_usb_submit_urb(precvpriv->int_in_urb, GFP_ATOMIC);
-	if((err) && (err != (-EPERM)))
-	{
-		DBG_8192C("cannot submit interrupt in-token(err = 0x%08x),urb_status = %d\n",err, precvpriv->int_in_urb->status);
-		ret = _FAIL;
-	}
-
-_func_exit_;
-
-	return ret;
-}
-#endif
-
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC
-static int recvbuf2recvframe(_adapter *padapter, struct recv_buf *precvbuf)
-{
-	u8	*pbuf;
-	u8	qos, shift_sz = 0;
-	u16	pkt_cnt, drvinfo_sz;
-	u32	pkt_len, pkt_offset,  tmpaddr = 0;
-	s32	transfer_len;
-	int	alignment = 0;
-	struct recv_stat	*prxstat;
-	_pkt	*pkt_copy = NULL;
-	union recv_frame	*precvframe = NULL;
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);
-	struct recv_priv	*precvpriv = &padapter->recvpriv;
-	_queue			*pfree_recv_queue = &precvpriv->free_recv_queue;
-
-
-	transfer_len = (s32)precvbuf->transfer_len;
-	pbuf = precvbuf->pbuf;
-
-	prxstat = (struct recv_stat *)pbuf;
-	pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
-
-#if 0 //temp remove when disable usb rx aggregation
-	if((pkt_cnt > 10) || (pkt_cnt < 1) || (transfer_len<RXDESC_SIZE) ||(pkt_len<=0))
-	{
-		return _FAIL;
-	}
-#endif
-
-	do{
-		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
-			 ("recvbuf2recvframe: rxdesc=offsset 0:0x%08x, 4:0x%08x, 8:0x%08x, C:0x%08x\n",
-			  prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4));
-
-		prxstat = (struct recv_stat *)pbuf;
-		pkt_len =  le32_to_cpu(prxstat->rxdw0)&0x00003fff;
-
-
-		drvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;//uint 2^3 = 8 bytes
-		drvinfo_sz = drvinfo_sz << 3;
-		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: DRV_INFO_SIZE=%d\n", drvinfo_sz));
-
-		pkt_offset = pkt_len + drvinfo_sz + RXDESC_SIZE;
-
-		if((pkt_len<=0) || (pkt_offset>transfer_len))
-		{
-			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: pkt_len<=0\n"));
-			goto _exit_recvbuf2recvframe;
-		}
-
-#if 0
-		shift_sz = (le32_to_cpu(prxstat->rxdw0) & 0x03000000) >> 24;
-#else
-		//shift_sz deponds on qos bit
-		qos = (le32_to_cpu(prxstat->rxdw0) & 0x00800000) >> 23;
-		//	Modified by Albert 20101213
-		//	For 8 bytes IP header alignment.
-		shift_sz = (qos==1) ? 6:0;
-#endif
-
-		precvframe = rtw_alloc_recvframe(pfree_recv_queue);
-		if(precvframe==NULL)
-		{
-			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: precvframe==NULL\n"));
-			goto _exit_recvbuf2recvframe;
-		}
-
-		_rtw_init_listhead(&precvframe->u.hdr.list);
-		precvframe->u.hdr.precvbuf = NULL;	//can't access the precvbuf for new arch.
-		precvframe->u.hdr.len=0;
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
-		pkt_copy = dev_alloc_skb((pkt_offset>1612?pkt_offset:1612) + shift_sz + 8);
-#else
-		pkt_copy = netdev_alloc_skb(padapter->pnetdev, (pkt_offset>1612?pkt_offset:1612) + shift_sz + 8);
-#endif
-
-		if(pkt_copy)
-		{
-			tmpaddr = (u32)pkt_copy->data;
-			alignment = tmpaddr & (7);
-			skb_reserve(pkt_copy, (8 - alignment));//force pkt_copy->data at 8-byte alignment address
-
-			skb_reserve(pkt_copy, shift_sz);//force ip_hdr at 8-byte alignment address according to shift_sz.
-
-			//pkt_copy->dev = padapter->pnetdev;
-
-			_rtw_memcpy(pkt_copy->data, pbuf, pkt_offset);
-			precvframe->u.hdr.pkt = pkt_copy;
-			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
-			precvframe->u.hdr.rx_end = pkt_copy->data + (pkt_offset>1612?pkt_offset:1612);
-		}
-		else
-		{
-			DBG_8192C("recvbuf2recvframe:can not allocate memory for skb copy\n");
-			//precvframe->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC);
-			//precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pbuf;
-			//precvframe->u.hdr.rx_end = pbuf + (pkt_offset>1612?pkt_offset:1612);
-
-			precvframe->u.hdr.pkt = NULL;
-			rtw_free_recvframe(precvframe, pfree_recv_queue);
-
-			goto _exit_recvbuf2recvframe;
-		}
-
-		recvframe_put(precvframe, pkt_len + drvinfo_sz + RXDESC_SIZE);
-		recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);
-
-#if CONFIG_USB_RX_AGGREGATION
-		switch(pHalData->UsbRxAggMode)
-		{
-			case USB_RX_AGG_DMA:
-			case USB_RX_AGG_MIX:
-				pkt_offset = (u16)_RND128(pkt_offset);
-				break;
-				case USB_RX_AGG_USB:
-				pkt_offset = (u16)_RND4(pkt_offset);
-				break;
-			case USB_RX_AGG_DISABLE:
-			default:
-				break;
-		}
-#endif
-
-		//because the endian issue, driver avoid reference to the rxstat after calling update_recvframe_attrib_from_recvstat();
-		rtl8192cu_update_recvframe_attrib_from_recvstat(precvframe, prxstat);
-
-		if(rtw_recv_entry(precvframe) != _SUCCESS)
-		{
-			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
-		}
-
-		pkt_cnt--;
-
-		transfer_len -= pkt_offset;
-		pbuf += pkt_offset;
-		precvframe = NULL;
-		pkt_copy = NULL;
-
-		if(transfer_len>0 && pkt_cnt==0)
-			pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
-
-	}while((transfer_len>0) && (pkt_cnt>0));
-
-_exit_recvbuf2recvframe:
-
-	return _SUCCESS;
-
-}
-
-void rtl8192du_recv_tasklet(void *priv)
-{
-	struct recv_buf *precvbuf = NULL;
-	_adapter	*padapter = (_adapter*)priv;
-	struct recv_priv	*precvpriv = &padapter->recvpriv;
-
-	while (NULL != (precvbuf = rtw_dequeue_recvbuf(&precvpriv->recv_buf_pending_queue)))
-	{
-		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
-		{
-			DBG_8192C("recv_tasklet => bDriverStopped or bSurpriseRemoved \n");
-
-			break;
-		}
-
-
-		recvbuf2recvframe(padapter, precvbuf);
-
-		rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-	}
-
-}
-
-static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
-{
-	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;
-	_adapter			*padapter =(_adapter *)precvbuf->adapter;
-	struct recv_priv	*precvpriv = &padapter->recvpriv;
-
-	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
-
-	precvpriv->rx_pending_cnt --;
-
-	if(padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));
-
-		goto exit;
-	}
-
-	if(purb->status==0)//SUCCESS
-	{
-		if ((purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE))
-		{
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n"));
-
-			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-		}
-		else
-		{
-			precvbuf->transfer_len = purb->actual_length;
-
-			//rtw_enqueue_rx_transfer_buffer(precvpriv, rx_transfer_buf);
-			rtw_enqueue_recvbuf(precvbuf, &precvpriv->recv_buf_pending_queue);
-
-			tasklet_schedule(&precvpriv->recv_tasklet);
-		}
-	}
-	else
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete : purb->status(%d) != 0 \n", purb->status));
-
-		DBG_8192C("###=> usb_read_port_complete => urb status(%d)\n", purb->status);
-
-		switch(purb->status) {
-			case -EINVAL:
-			case -EPIPE:
-			case -ENODEV:
-			case -ESHUTDOWN:
-				//padapter->bSurpriseRemoved=_TRUE;
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
-			case -ENOENT:
-				padapter->bDriverStopped=_TRUE;
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
-				break;
-			case -EPROTO:
-				rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-				break;
-			case -EINPROGRESS:
-				DBG_8192C("ERROR: URB IS IN PROGRESS!/n");
-				break;
-			default:
-				break;
-		}
-
-	}
-
-exit:
-
-_func_exit_;
-
-}
-
-u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
-u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
-{
-	int err;
-	struct usb_host_endpoint *pipe;
-	u32 ret = _SUCCESS;
-	PURB purb = NULL;
-	struct recv_buf	*precvbuf = (struct recv_buf *)rmem;
-	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)pintfhdl->pintf_dev;
-	_adapter		*adapter = (_adapter *)pdvobj->padapter;
-	struct recv_priv	*precvpriv = &adapter->recvpriv;
-	struct usb_device	*pusbd = pdvobj->pusbdev;
-
-	if(adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
-		return _FAIL;
-	}
-
-	if(precvbuf !=NULL)
-	{
-		rtl8192du_init_recvbuf(adapter, precvbuf);
-
-		if(precvbuf->pbuf)
-		{
-			precvpriv->rx_pending_cnt++;
-
-			purb = precvbuf->purb;
-
-			//translate DMA FIFO addr to pipehandle
-			pipe = ffaddr2pipehdl(pdvobj, addr);
-
-                        rtw_usb_fill_bulk_urb(purb, pusbd, pipe,
-						precvbuf->pbuf,
-						MAX_RECVBUF_SZ,
-						usb_read_port_complete,
-						precvbuf);//context is precvbuf
-
-			purb->transfer_dma = precvbuf->dma_transfer_addr;
-			purb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-
-                        err = rtw_usb_submit_urb(purb, GFP_ATOMIC);
-			if((err) && (err != (-EPERM)))
-			{
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cannot submit rx in-token(err=0x%.8x), URB_STATUS =0x%.8x", err, purb->status));
-				DBG_8192C("cannot submit rx in-token(err = 0x%08x),urb_status = %d\n",err,purb->status);
-				ret = _FAIL;
-			}
-
-		}
-
-	}
-	else
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:precvbuf ==NULL\n"));
-		ret = _FAIL;
-	}
-
-	return ret;
-
-}
-#else // CONFIG_USE_USB_BUFFER_ALLOC
-
-
-int recvbuf2recvframe(_adapter *padapter, struct sk_buff  *pskb);
-
-int recvbuf2recvframe(_adapter *padapter, struct sk_buff  *pskb)
-{
-	u8	*pbuf;
-	u8	frag, mf, shift_sz = 0;
-	u16	pkt_cnt, drvinfo_sz;
-	u32	pkt_len, pkt_offset, skb_len, alloc_sz;
-	int	transfer_len;
-	struct recv_stat	*prxstat;
-#ifdef CONFIG_BSD_RX_USE_MBUF
-	struct mbuf		*pkt_copy = NULL;
-#else // CONFIG_BSD_RX_USE_MBUF
-	struct sk_buff		*pkt_copy = NULL;
-#endif // CONFIG_BSD_RX_USE_MBUF
-	union recv_frame	*precvframe = NULL;
-#ifdef CONFIG_USB_RX_AGGREGATION
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
-#endif
-	struct recv_priv	*precvpriv = &padapter->recvpriv;
-	_queue			*pfree_recv_queue = &precvpriv->free_recv_queue;
-
-	transfer_len = pskb->len;
-	pbuf = pskb->data;
-
-	prxstat = (struct recv_stat *)pbuf;
-	pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
-
-#if 0 //temp remove when disable usb rx aggregation
-	if((pkt_cnt > 10) || (pkt_cnt < 1) || (transfer_len<RXDESC_SIZE) ||(pkt_len<=0))
-	{
-		return _FAIL;
-	}
-#endif
-
-	do{
-		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
-			 ("recvbuf2recvframe: rxdesc=offsset 0:0x%08x, 4:0x%08x, 8:0x%08x, C:0x%08x\n",
-			  prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4));
-
-		prxstat = (struct recv_stat *)pbuf;
-		pkt_len =  le32_to_cpu(prxstat->rxdw0)&0x00003fff;
-
-		mf = (le32_to_cpu(prxstat->rxdw1) >> 27) & 0x1;//more fragment bit
-		frag = (le32_to_cpu(prxstat->rxdw2) >> 12) & 0xf;//fragmentation number
-
-		drvinfo_sz = (le32_to_cpu(prxstat->rxdw0) & 0x000f0000) >> 16;//uint 2^3 = 8 bytes
-		drvinfo_sz = drvinfo_sz << 3;
-		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: DRV_INFO_SIZE=%d\n", drvinfo_sz));
-
-		pkt_offset = pkt_len + drvinfo_sz + RXDESC_SIZE;
-
-		if((pkt_len<=0) || (pkt_len>transfer_len))
-		{
-			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: pkt_len<=0\n"));
-			goto _exit_recvbuf2recvframe;
-		}
-
-		if ( ( le32_to_cpu( prxstat->rxdw0 ) >> 23 ) & 0x01 )	//	Qos data, wireless lan header length is 26, LLC is 8, total is 34
-		{
-			shift_sz = 6;
-		}
-		else
-		{
-			shift_sz = 0;
-		}
-
-		precvframe = rtw_alloc_recvframe(pfree_recv_queue);
-		if(precvframe==NULL)
-		{
-			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: precvframe==NULL\n"));
-			goto _exit_recvbuf2recvframe;
-		}
-
-		_rtw_init_listhead(&precvframe->u.hdr.list);
-		precvframe->u.hdr.precvbuf = NULL;	//can't access the precvbuf for new arch.
-		precvframe->u.hdr.len=0;
-
-		skb_len = pkt_len;
-
-		// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
-		// modify alloc_sz for recvive crc error packet by thomas 2011-06-02
-		if((mf ==1)&&(frag == 0)){
-			//alloc_sz = 1664;	//1664 is 128 alignment.
-			if(skb_len <= 1650)
-				alloc_sz = 1664;
-			else
-				alloc_sz = skb_len + 14;
-		}
-		else {
-			alloc_sz = skb_len;
-			//	6 is for IP header 8 bytes alignment in QoS packet case.
-			//	8 is for skb->data 4 bytes alignment.
-			alloc_sz += 14;
-		}
-
-#ifdef CONFIG_BSD_RX_USE_MBUF
-
-		pkt_copy = m_getjcl(M_DONTWAIT, MT_DATA, M_PKTHDR,
-			alloc_sz <= MCLBYTES ? MCLBYTES :
-#if MJUMPAGESIZE != MCLBYTES
-			alloc_sz <= MJUMPAGESIZE ? MJUMPAGESIZE :
-#endif
-			alloc_sz <= MJUM9BYTES ? MJUM9BYTES : MJUM16BYTES);
-		//printf("%s()-%d: pkt_copy = %p, pkt_copy->head = %p\n", __FUNCTION__, __LINE__, pkt_copy, pkt_copy->head);
-		if(pkt_copy)
-		{
-#if 0
-			if ((pkt_copy->m_flags & M_PKTHDR) == 0) {
-				printf("%s()-%d: pkt_copy->m_flags = %08X\n", __FUNCTION__, __LINE__, pkt_copy->m_flags);
-			}
-#endif
-			//pkt_copy->dev = padapter->pifp;
-			pkt_copy->m_pkthdr.rcvif = padapter->pifp;
-			pkt_copy->m_len = alloc_sz;
-
-
-			precvframe->u.hdr.pkt = pkt_copy;
-			//skb_reserve( pkt_copy, 8 - ((SIZE_PTR)( pkt_copy->data ) & 7 ));//force pkt_copy->data at 8-byte alignment address
-			m_adj(pkt_copy, 8 - ((SIZE_PTR)( mtod(pkt_copy, caddr_t) ) & 7 ));
-			//skb_reserve( pkt_copy, shift_sz );//force ip_hdr at 8-byte alignment address according to shift_sz.
-			m_adj( pkt_copy, shift_sz );//force ip_hdr at 8-byte alignment address according to shift_sz.
-
-			//_rtw_memcpy(mtod(pkt_copy, caddr_t), pbuf + (drvinfo_sz + RXDESC_SIZE), skb_len);
-			m_copyback(pkt_copy, 0, skb_len, pbuf + (drvinfo_sz + RXDESC_SIZE));
-			//printf("%s()-%d: mtod(pkt_copy) = %p\n", __FUNCTION__, __LINE__, mtod(pkt_copy, caddr_t));
-
-			//precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
-			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = mtod(pkt_copy, caddr_t);
-			//precvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;
-			precvframe->u.hdr.rx_end = mtod(pkt_copy, caddr_t) + alloc_sz;
-
-
-			//printf("%s()-%d: pkt = %p, head = %p\n", __FUNCTION__, __LINE__, precvframe->u.hdr.pkt, precvframe->u.hdr.pkt->head);
-		}
-		else
-		{
-#ifdef PLATFORM_FREEBSD
-			printf("%s(),LINE %d: allocate failure 881\n",__FUNCTION__,__LINE__);
-			rtw_free_recvframe(precvframe, pfree_recv_queue);
-			goto _exit_recvbuf2recvframe;
-#else // PLATFORM_FREEBSD
-			//DBG_8192C("recvbuf2recvframe:can not allocate memory for skb copy\n");
-			precvframe->u.hdr.pkt = skb_clone(pskb, GFP_ATOMIC);
-			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pbuf;
-			precvframe->u.hdr.rx_end = pbuf + alloc_sz;
-#endif // PLATFORM_FREEBSD
-		}
-
-#else // CONFIG_BSD_RX_USE_MBUF
-
-		pkt_copy = dev_alloc_skb(alloc_sz);
-
-		//printf("%s()-%d: pkt_copy = %p, pkt_copy->head = %p\n", __FUNCTION__, __LINE__, pkt_copy, pkt_copy->head);
-		if(pkt_copy)
-		{
-			pkt_copy->dev = padapter->pifp;
-			precvframe->u.hdr.pkt = pkt_copy;
-			skb_reserve( pkt_copy, 8 - ((SIZE_PTR)( pkt_copy->data ) & 7 ));//force pkt_copy->data at 8-byte alignment address
-			skb_reserve( pkt_copy, shift_sz );//force ip_hdr at 8-byte alignment address according to shift_sz.
-			_rtw_memcpy(pkt_copy->data, pbuf + (drvinfo_sz + RXDESC_SIZE), skb_len);
-			precvframe->u.hdr.rx_head = precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
-			precvframe->u.hdr.rx_end = pkt_copy->data + alloc_sz;
-		}
-		else
-		{
-			printf("%s(),LINE %d: allocate failure 881\n",__FUNCTION__,__LINE__);
-			rtw_free_recvframe(precvframe, pfree_recv_queue);
-			goto _exit_recvbuf2recvframe;
-		}
-
-#endif // CONFIG_BSD_RX_USE_MBUF
-
-		recvframe_put(precvframe, skb_len);
-		//recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);
-
-#ifdef CONFIG_USB_RX_AGGREGATION
-		switch(pHalData->UsbRxAggMode)
-		{
-			case USB_RX_AGG_DMA:
-			case USB_RX_AGG_DMA_USB:
-				pkt_offset = (u16)_RND128(pkt_offset);
-				break;
-				case USB_RX_AGG_USB:
-				pkt_offset = (u16)_RND4(pkt_offset);
-				break;
-			case USB_RX_AGG_DISABLE:
-			default:
-				break;
-		}
-#endif  // CONFIG_USB_RX_AGGREGATION
-
-		//because the endian issue, driver avoid reference to the rxstat after calling update_recvframe_attrib_from_recvstat();
-		rtl8192du_update_recvframe_attrib_from_recvstat(precvframe, prxstat);
-
-		if(rtw_recv_entry(precvframe) != _SUCCESS)
-		{
-			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
-		}
-
-		pkt_cnt--;
-
-		transfer_len -= pkt_offset;
-		pbuf += pkt_offset;
-		precvframe = NULL;
-		pkt_copy = NULL;
-
-		if(transfer_len>0 && pkt_cnt==0)
-			pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
-
-	}while((transfer_len>0) && (pkt_cnt>0));
-
-_exit_recvbuf2recvframe:
-
-	return _SUCCESS;
-}
-#endif // CONFIG_USE_USB_BUFFER_ALLOC
-
-void rtl8192du_recv_tasklet(void *priv, int npending)
-{
-	struct sk_buff  *pskb;
-	_adapter		*padapter = (_adapter*)priv;
-	struct recv_priv	*precvpriv = &padapter->recvpriv;
-
-	while (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue)))
-	{
-		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
-		{
-			DBG_8192C("recv_tasklet => bDriverStopped or bSurpriseRemoved \n");
-			dev_kfree_skb_any(pskb);
-			break;
-		}
-
-		recvbuf2recvframe(padapter, pskb);
-
-#ifdef CONFIG_PREALLOC_RECV_SKB
-
-		pskb->tail = pskb->data;
-		pskb->len = 0;
-
-		skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
-
-#else
-		dev_kfree_skb_any(pskb);
-#endif
-
-	}
-
-}
-
-#define CONFIG_CALL_RXBUF2FRAME_DIRECTLY	1
-
-void usb_read_port_complete(struct urb *purb, struct pt_regs *regs);
-void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
-{
-	//_irqL irqL;
-	//uint isevt, *pbuf;
-	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;
-	_adapter			*padapter =(_adapter *)precvbuf->adapter;
-	struct recv_priv	*precvpriv = &padapter->recvpriv;
-#ifndef CONFIG_CALL_RXBUF2FRAME_DIRECTLY
-	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
-#endif
-
-	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
-
-	precvpriv->rx_pending_cnt --;
-
-	if(padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));
-
-	#ifdef CONFIG_PREALLOC_RECV_SKB
-		precvbuf->reuse = _TRUE;
-	#else
-		if(precvbuf->pskb){
-			DBG_8192C("==> free skb(%p)\n",precvbuf->pskb);
-			dev_kfree_skb_any(precvbuf->pskb);
-		}
-	#endif
-
-		goto exit;
-	}
-
-	if(purb->status==0)//SUCCESS
-	{
-#if 0 // Had scheduled TX task after enqueue.
-		//force tx to enqueue, in receving time to run the task
-		taskqueue_enqueue_fast(taskqueue_fast, &pxmitpriv->xmit_tasklet);
-#endif
-		if ((purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE))
-		{
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n"));
-			precvbuf->reuse = _TRUE;
-			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-		}
-		else
-		{
-			precvbuf->transfer_len = purb->actual_length;
-
-			skb_put(precvbuf->pskb, purb->actual_length);
-
-#ifdef CONFIG_CALL_RXBUF2FRAME_DIRECTLY
-
-			recvbuf2recvframe(padapter, precvbuf->pskb);
-
-			precvbuf->pskb->tail = precvbuf->pskb->data;
-			precvbuf->pskb->len = 0;
-
-			precvbuf->reuse = _TRUE;
-
-
-#else // CONFIG_CALL_RXBUF2FRAME_DIRECTLY
-
-			skb_queue_tail(&precvpriv->rx_skb_queue, precvbuf->pskb);
-
-#if 0 // 1: call rx task directly
-			rtl8192du_recv_tasklet(padapter, 0);
-			//printf("%s()-%d\n", __FUNCTION__, __LINE__);
-
-#else // 1: call rx task directly
-			if (skb_queue_len(&precvpriv->rx_skb_queue)<=1)
-				taskqueue_enqueue_fast(taskqueue_fast, &precvpriv->recv_tasklet);
-#endif // 1: call rx task directly
-
-			precvbuf->pskb = NULL;
-			precvbuf->reuse = _FALSE;
-#endif // CONFIG_CALL_RXBUF2FRAME_DIRECTLY
-
-			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-
-		}
-	}
-	else
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete : purb->status(%d) != 0 \n", purb->status));
-
-		DBG_8192C("###=> usb_read_port_complete => urb status(%d)\n", purb->status);
-
-		switch(purb->status) {
-			case -EINVAL:
-			case -EPIPE:
-			case -ENODEV:
-			case -ESHUTDOWN:
-				//padapter->bSurpriseRemoved=_TRUE;
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
-			case -ENOENT:
-				padapter->bDriverStopped=_TRUE;
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
-				break;
-			case -EPROTO:
-				precvbuf->reuse = _TRUE;
-				rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-				break;
-			case -EINPROGRESS:
-				DBG_8192C("ERROR: URB IS IN PROGRESS!/n");
-				break;
-			default:
-				break;
-		}
-
-	}
-
-exit:
-
-_func_exit_;
-}
-
-u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
-u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
-{
-	//_irqL irqL;
-	int err;
-	struct usb_host_endpoint *pipe;
-	SIZE_PTR tmpaddr=0;
-	SIZE_PTR alignment=0;
-	u32 ret = _SUCCESS;
-	PURB purb = NULL;
-	struct recv_buf	*precvbuf = (struct recv_buf *)rmem;
-	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)pintfhdl->pintf_dev;
-	_adapter		*adapter = (_adapter *)pdvobj->padapter;
-	struct recv_priv	*precvpriv = &adapter->recvpriv;
-	struct usb_device	*pusbd = pdvobj->pusbdev;
-
-
-_func_enter_;
-
-	if(adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
-		return _FAIL;
-	}
-
-#ifdef CONFIG_PREALLOC_RECV_SKB
-	if((precvbuf->reuse == _FALSE) || (precvbuf->pskb == NULL))
-	{
-		if (NULL != (precvbuf->pskb = skb_dequeue(&precvpriv->free_recv_skb_queue)))
-		{
-			precvbuf->reuse = _TRUE;
-		}
-	}
-#endif
-
-
-	if(precvbuf !=NULL)
-	{
-		rtl8192du_init_recvbuf(adapter, precvbuf);
-
-		//re-assign for linux based on skb
-		if((precvbuf->reuse == _FALSE) || (precvbuf->pskb == NULL))
-		{
-
-#ifdef PLATFORM_FREEBSD
-			precvbuf->pskb = dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
-#else // PLATFORM_FREEBSD
-			//precvbuf->pskb = alloc_skb(MAX_RECVBUF_SZ, GFP_ATOMIC);//don't use this after v2.6.25
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) // http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html
-			precvbuf->pskb = dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
-#else
-			precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
-#endif //(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
-#endif //PLATFORM_FREEBSD
-			if(precvbuf->pskb == NULL)
-			{
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("init_recvbuf(): alloc_skb fail!\n"));
-				return _FAIL;
-			}
-
-			tmpaddr = (SIZE_PTR)precvbuf->pskb->data;
-			alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
-			skb_reserve(precvbuf->pskb, (RECVBUFF_ALIGN_SZ - alignment));
-
-			precvbuf->phead = precvbuf->pskb->head;
-			precvbuf->pdata = precvbuf->pskb->data;
-			precvbuf->ptail = skb_tail_pointer(precvbuf->pskb);
-			precvbuf->pend = skb_end_pointer(precvbuf->pskb);
-			precvbuf->pbuf = precvbuf->pskb->data;
-		}
-		else//reuse skb
-		{
-			precvbuf->phead = precvbuf->pskb->head;
-			precvbuf->pdata = precvbuf->pskb->data;
-			precvbuf->ptail = skb_tail_pointer(precvbuf->pskb);
-			precvbuf->pend = skb_end_pointer(precvbuf->pskb);
-			precvbuf->pbuf = precvbuf->pskb->data;
-
-			precvbuf->reuse = _FALSE;
-		}
-
-		//_enter_critical(&precvpriv->lock, &irqL);
-		//precvpriv->rx_pending_cnt++;
-		//precvbuf->irp_pending = _TRUE;
-		//_exit_critical(&precvpriv->lock, &irqL);
-
-		precvpriv->rx_pending_cnt++;
-
-		purb = precvbuf->purb;
-
-		//translate DMA FIFO addr to pipehandle
-		pipe = ffaddr2pipehdl(pdvobj, addr);
-
-                rtw_usb_fill_bulk_urb(purb, pusbd, pipe,
-						precvbuf->pbuf,
-						MAX_RECVBUF_SZ,
-						usb_read_port_complete,
-						precvbuf);//context is precvbuf
-
-                err = rtw_usb_submit_urb(purb, GFP_ATOMIC);
-		if((err) && (err != (-EPERM)))
-		{
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cannot submit rx in-token(err=0x%.8x), URB_STATUS =0x%.8x", err, purb->status));
-			DBG_8192C("cannot submit rx in-token(err = 0x%08x),urb_status = %d\n",err,purb->status);
-			ret = _FAIL;
-		}
-	}
-	else
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:precvbuf ==NULL\n"));
-		ret = _FAIL;
-	}
-
-_func_exit_;
-
-	return ret;
-}
-
-void usb_read_port_cancel(struct intf_hdl *pintfhdl);
-void usb_read_port_cancel(struct intf_hdl *pintfhdl)
-{
-	int i;
-
-	struct recv_buf *precvbuf;
-
-	_adapter	*padapter = pintfhdl->padapter;
-	precvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;
-
-	DBG_8192C("usb_read_port_cancel \n");
-
-	padapter->bReadPortCancel = _TRUE;
-
-	for(i=0; i < NR_RECVBUFF ; i++)
-	{
-		precvbuf->reuse = _TRUE;
-		if(precvbuf->purb)
-		{
-                        //DBG_8192C("usb_read_port_cancel : rtw_usb_kill_urb \n");
-                        rtw_usb_kill_urb(precvbuf->purb);
-		}
-
-		precvbuf++;
-	}
-
-#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
-        rtw_usb_kill_urb(padapter->recvpriv.int_in_urb);
-#endif
-}
-
-void rtl8192du_xmit_tasklet(void *priv)
-{
-	int ret = _FALSE;
-	_adapter *padapter = (_adapter*)priv;
-	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
-
-	if(check_fwstate(&padapter->mlmepriv, _FW_UNDER_SURVEY) == _TRUE)
-		return;
-
-	while(1)
-	{
-		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
-		{
-			DBG_8192C("xmit_tasklet => bDriverStopped or bSurpriseRemoved \n");
-			break;
-		}
-
-		ret = rtl8192du_xmitframe_complete(padapter, pxmitpriv, NULL);
-
-		if(ret==_FALSE)
-			break;
-
-	}
-
-}
-
-static void usb_write_port_complete(struct urb *purb, struct pt_regs *regs)
-{
-
-//	_irqL irqL;
-//	int i;
-	struct xmit_buf *pxmitbuf = (struct xmit_buf *)purb->context;
-	//struct xmit_frame *pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
-	//_adapter			*padapter = pxmitframe->padapter;
-	_adapter	*padapter = pxmitbuf->padapter;
-       struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
-	//struct pkt_attrib *pattrib = &pxmitframe->attrib;
-
-_func_enter_;
-
-	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port_complete\n"));
-
-/*
-	_enter_critical(&pxmitpriv->lock, &irqL);
-
-	pxmitpriv->txirp_cnt--;
-
-	switch(pattrib->priority)
-	{
-		case 1:
-		case 2:
-			pxmitpriv->bkq_cnt--;
-			//DBG_8192C("pxmitpriv->bkq_cnt=%d\n", pxmitpriv->bkq_cnt);
-			break;
-		case 4:
-		case 5:
-			pxmitpriv->viq_cnt--;
-			//DBG_8192C("pxmitpriv->viq_cnt=%d\n", pxmitpriv->viq_cnt);
-			break;
-		case 6:
-		case 7:
-			pxmitpriv->voq_cnt--;
-			//DBG_8192C("pxmitpriv->voq_cnt=%d\n", pxmitpriv->voq_cnt);
-			break;
-		case 0:
-		case 3:
-		default:
-			pxmitpriv->beq_cnt--;
-			//DBG_8192C("pxmitpriv->beq_cnt=%d\n", pxmitpriv->beq_cnt);
-			break;
-
-	}
-
-	_exit_critical(&pxmitpriv->lock, &irqL);
-
-
-	if(pxmitpriv->txirp_cnt==0)
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));
-		_rtw_up_sema(&(pxmitpriv->tx_retevt));
-	}
-*/
-        //rtw_free_xmitframe(pxmitpriv, pxmitframe);
-
-	rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
-
-	if(padapter->bSurpriseRemoved || padapter->bDriverStopped ||padapter->bWritePortCancel)
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
-		goto exit;
-	}
-
-
-	if(purb->status==0)
-	{
-
-	}
-	else
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete : purb->status(%d) != 0 \n", purb->status));
-		DBG_8192C("###=> urb_write_port_complete status(%d)\n",purb->status);
-		if((purb->status==-EPIPE)||(purb->status==-EPROTO))
-		{
-                        //rtw_usb_clear_halt(pusbdev, purb->pipe);
-			//msleep(10);
-		}
-		else if(purb->status == (-ESHUTDOWN))
-		{
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: ESHUTDOWN\n"));
-
-			padapter->bDriverStopped=_TRUE;
-
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped=TRUE\n"));
-
-			goto exit;
-		}
-		else
-		{
-			padapter->bSurpriseRemoved=_TRUE;
-			DBG_8192C("bSurpriseRemoved=TRUE\n");
-			//rtl8192cu_trigger_gpio_0(padapter);
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bSurpriseRemoved=TRUE\n"));
-
-			goto exit;
-		}
-
-
-
-	}
-
-	//if(rtw_txframes_pending(padapter))
-	{
-				//printf("%s(),%d:\n",__FUNCTION__,__LINE__);
-		//tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
-		taskqueue_enqueue_fast(taskqueue_fast, &pxmitpriv->xmit_tasklet);
-	}
-
-
-	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("-usb_write_port_complete\n"));
-
-exit:
-
-_func_exit_;
-
-}
-
-static u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
-{
-
-//	_irqL irqL;
-	int status;
-	struct usb_host_endpoint *pipe;
-	u32 ret;//, bwritezero = _FALSE;
-	PURB	purb = NULL;
-	_adapter *padapter = (_adapter *)pintfhdl->padapter;
-	struct dvobj_priv	*pdvobj = (struct dvobj_priv   *)&padapter->dvobjpriv;
-//	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
-	struct xmit_buf *pxmitbuf = (struct xmit_buf *)wmem;
-	struct xmit_frame *pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
-	struct usb_device *pusbd = pdvobj->pusbdev;
-//	struct pkt_attrib *pattrib = &pxmitframe->attrib;
-
-_func_enter_;
-
-	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port\n"));
-
-	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
-		return _FAIL;
-	}
-
-/*
-	_enter_critical(&pxmitpriv->lock, &irqL);
-
-	//total irp
-	pxmitpriv->txirp_cnt++;
-
-	//per ac irp
-	switch(pattrib->priority)
-	{
-		case 1:
-		case 2:
-			pxmitpriv->bkq_cnt++;
-			break;
-		case 4:
-		case 5:
-			pxmitpriv->viq_cnt++;
-			break;
-		case 6:
-		case 7:
-			pxmitpriv->voq_cnt++;
-			break;
-		case 0:
-		case 3:
-		default:
-			pxmitpriv->beq_cnt++;
-			break;
-	}
-
-
-	_exit_critical(&pxmitpriv->lock, &irqL);
-*/
-
-	purb	= pxmitbuf->pxmit_urb[0];
-
-#if 0
-	if(pdvobj->ishighspeed)
-	{
-		if(cnt> 0 && cnt%512 == 0)
-		{
-			//DBG_8192C("ishighspeed, cnt=%d\n", cnt);
-			bwritezero = _TRUE;
-		}
-	}
-	else
-	{
-		if(cnt > 0 && cnt%64 == 0)
-		{
-			//DBG_8192C("cnt=%d\n", cnt);
-			bwritezero = _TRUE;
-		}
-	}
-#endif
-
-	//translate DMA FIFO addr to pipehandle
-	pipe = ffaddr2pipehdl(pdvobj, addr);
-
-#ifdef CONFIG_REDUCE_USB_TX_INT
-	if ( pxmitpriv->free_xmitbuf_cnt%NR_XMITBUFF == 0
-		|| pxmitbuf->ext_tag )
-	{
-		purb->transfer_flags  &=  (~URB_NO_INTERRUPT);
-	} else {
-		purb->transfer_flags  |=  URB_NO_INTERRUPT;
-		//DBG_8192C("URB_NO_INTERRUPT ");
-	}
-#endif
-
-
-        rtw_usb_fill_bulk_urb(purb, pusbd, pipe,
-				pxmitframe->buf_addr,
-				cnt,
-				usb_write_port_complete,
-				pxmitbuf);//context is pxmitbuf
-
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC
-	purb->transfer_dma = pxmitbuf->dma_transfer_addr;
-	purb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-	purb->transfer_flags |= URB_ZERO_PACKET;
-#endif
-
-#if 0
-	if (bwritezero)
-        {
-            purb->transfer_flags |= URB_ZERO_PACKET;
-        }
-#endif
-
-        status = rtw_usb_submit_urb(purb, GFP_ATOMIC);
-
-	if (!status)
-	{
-		ret= _SUCCESS;
-	}
-	else
-	{
-		DBG_8192C("usb_write_port, status=%d\n", status);
-                RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port(): rtw_usb_submit_urb, status=%x\n", status));
-		ret= _FAIL;
-	}
-
-//   Commented by Albert 2009/10/13
-//   We add the URB_ZERO_PACKET flag to urb so that the host will send the zero packet automatically.
-/*
-	if(bwritezero == _TRUE)
-	{
-		usb_bulkout_zero(pintfhdl, addr);
-	}
-*/
-
-_func_exit_;
-
-	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("-usb_write_port\n"));
-
-	return ret;
-
-}
-
-static void usb_write_port_cancel(struct intf_hdl *pintfhdl)
-{
-
-	int i, j;
-	_adapter	*padapter = pintfhdl->padapter;
-	struct xmit_buf *pxmitbuf = (struct xmit_buf *)padapter->xmitpriv.pxmitbuf;
-
-	DBG_8192C("usb_write_port_cancel \n");
-
-	padapter->bWritePortCancel = _TRUE;
-
-	for(i=0; i<NR_XMITBUFF; i++)
-	{
-		for(j=0; j<8; j++)
-		{
-		        if(pxmitbuf->pxmit_urb[j])
-		        {
-                                rtw_usb_kill_urb(pxmitbuf->pxmit_urb[j]);
-		        }
-		}
-
-		pxmitbuf++;
-	}
-
-}
-
-
-void rtl8192du_set_intf_ops(struct _io_ops	*pops)
-{
-	_func_enter_;
-
-	_rtw_memset((u8 *)pops, 0, sizeof(struct _io_ops));
-
-	pops->_read8 = &usb_read8;
-	pops->_read16 = &usb_read16;
-	pops->_read32 = &usb_read32;
-	pops->_read_mem = &usb_read_mem;
-	pops->_read_port = &usb_read_port;
-
-	pops->_write8 = &usb_write8;
-	pops->_write16 = &usb_write16;
-	pops->_write32 = &usb_write32;
-	pops->_writeN = &usb_writeN;
-
-#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
-	pops->_write8_async= &usb_async_write8;
-	pops->_write16_async = &usb_async_write16;
-	pops->_write32_async = &usb_async_write32;
-#endif
-	pops->_write_mem = &usb_write_mem;
-	pops->_write_port = &usb_write_port;
-
-
-	pops->_read_port_cancel = &usb_read_port_cancel;
-	pops->_write_port_cancel = &usb_write_port_cancel;
-
-#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
-	pops->_read_interrupt = &usb_read_interrupt;
-#endif
-
-	_func_exit_;
-
-}
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -1314,25 +1314,6 @@ static int cfg80211_rtw_get_key(struct w
 				void (*callback)(void *cookie,
 						 struct key_params*))
 {
-#if 0
-	struct iwm_priv *iwm = ndev_to_iwm(ndev);
-	struct iwm_key *key = &iwm->keys[key_index];
-	struct key_params params;
-
-	IWM_DBG_WEXT(iwm, DBG, "Getting key %d\n", key_index);
-
-	memset(&params, 0, sizeof(params));
-
-	params.cipher = key->cipher;
-	params.key_len = key->key_len;
-	params.seq_len = key->seq_len;
-	params.seq = key->seq;
-	params.key = key->key;
-
-	callback(cookie, &params);
-
-	return key->key_len ? 0 : -ENOENT;
-#endif
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 	return 0;
 }
@@ -2015,35 +1996,6 @@ exit:
 
 static int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy, u32 changed)
 {
-#if 0
-	struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
-
-	if (changed & WIPHY_PARAM_RTS_THRESHOLD &&
-	    (iwm->conf.rts_threshold != wiphy->rts_threshold)) {
-		int ret;
-
-		iwm->conf.rts_threshold = wiphy->rts_threshold;
-
-		ret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,
-					     CFG_RTS_THRESHOLD,
-					     iwm->conf.rts_threshold);
-		if (ret < 0)
-			return ret;
-	}
-
-	if (changed & WIPHY_PARAM_FRAG_THRESHOLD &&
-	    (iwm->conf.frag_threshold != wiphy->frag_threshold)) {
-		int ret;
-
-		iwm->conf.frag_threshold = wiphy->frag_threshold;
-
-		ret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_FA_CFG_FIX,
-					     CFG_FRAG_THRESHOLD,
-					     iwm->conf.frag_threshold);
-		if (ret < 0)
-			return ret;
-	}
-#endif
 	DBG_8192C("%s\n", __func__);
 	return 0;
 }
@@ -2051,38 +2003,12 @@ static int cfg80211_rtw_set_wiphy_params
 static int cfg80211_rtw_join_ibss(struct wiphy *wiphy, struct net_device *ndev,
 				  struct cfg80211_ibss_params *params)
 {
-#if 0
-	struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
-	struct ieee80211_channel *chan = params->channel;
-
-	if (!test_bit(IWM_STATUS_READY, &iwm->status))
-		return -EIO;
-
-	/* UMAC doesn't support creating or joining an IBSS network
-	 * with specified bssid. */
-	if (params->bssid)
-		return -EOPNOTSUPP;
-
-	iwm->channel = ieee80211_frequency_to_channel(chan->center_freq);
-	iwm->umac_profile->ibss.band = chan->band;
-	iwm->umac_profile->ibss.channel = iwm->channel;
-	iwm->umac_profile->ssid.ssid_len = params->ssid_len;
-	memcpy(iwm->umac_profile->ssid.ssid, params->ssid, params->ssid_len);
-
-	return iwm_send_mlme_profile(iwm);
-#endif
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 	return 0;
 }
 
 static int cfg80211_rtw_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)
 {
-#if 0
-	struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
-
-	if (iwm->umac_profile_active)
-		return iwm_invalidate_mlme_profile(iwm);
-#endif
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 	return 0;
 }
@@ -2784,32 +2710,6 @@ static int cfg80211_rtw_set_txpower(stru
 	enum tx_power_setting type, int dbm)
 #endif
 {
-#if 0
-	struct iwm_priv *iwm = wiphy_to_iwm(wiphy);
-	int ret;
-
-	switch (type) {
-	case NL80211_TX_POWER_AUTOMATIC:
-		return 0;
-	case NL80211_TX_POWER_FIXED:
-		if (mbm < 0 || (mbm % 100))
-			return -EOPNOTSUPP;
-
-		if (!test_bit(IWM_STATUS_READY, &iwm->status))
-			return 0;
-
-		ret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,
-					      CFG_TX_PWR_LIMIT_USR,
-					      MBM_TO_DBM(mbm) * 2);
-		if (ret < 0)
-			return ret;
-
-		return iwm_tx_power_trigger(iwm);
-	default:
-		IWM_ERR(iwm, "Unsupported power type: %d\n", type);
-		return -EOPNOTSUPP;
-	}
-#endif
 	DBG_8192C("%s\n", __func__);
 	return 0;
 }
@@ -2820,12 +2720,8 @@ static int cfg80211_rtw_get_txpower(stru
 #endif
 	int *dbm)
 {
-	//_adapter *padapter = wiphy_to_adapter(wiphy);
-
 	DBG_8192C("%s\n", __func__);
-
 	*dbm = (12);
-
 	return 0;
 }
 
@@ -4327,28 +4223,10 @@ static s32 cfg80211_rtw_cancel_remain_on
 		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
 	}
 
-	#if 0
-	//	Disable P2P Listen State
-	if(!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) && !rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
-	{
-		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		{
-			_cancel_timer_ex( &pwdinfo->find_phase_timer );
-			_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
-			_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
-
-			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
-			_rtw_memset(pwdinfo, 0x00, sizeof(struct wifidirect_info));
-		}
-	}
-	else
-	#endif
-	{
-		 rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
+	 rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
 #ifdef CONFIG_DEBUG_CFG80211
-		 DBG_8192C("%s, role=%d, p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo));
+	 DBG_8192C("%s, role=%d, p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo));
 #endif
-	}
 	pcfg80211_wdinfo->is_ro_ch = _FALSE;
 
 	return err;
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -946,21 +946,6 @@ static int rtw_set_wpa_ie(_adapter *pada
 			goto exit;
 		}
 
-#if 0
-		pos += RSN_HEADER_LEN;
-		left  = ielen - RSN_HEADER_LEN;
-
-		if (left >= RSN_SELECTOR_LEN){
-			pos += RSN_SELECTOR_LEN;
-			left -= RSN_SELECTOR_LEN;
-		}
-		else if (left > 0){
-			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie length mismatch, %u too much \n", left));
-			ret =-1;
-			goto exit;
-		}
-#endif
-
 		if(rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
 			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
@@ -1637,29 +1622,9 @@ static int rtw_wx_set_wap(struct net_dev
        phead = get_list_head(queue);
        pmlmepriv->pscanned = get_next(phead);
 
-	while (1)
-	 {
-
+	while (1) {
 		if ((rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) == _TRUE)
-		{
-#if 0
-			ret = -EINVAL;
-			goto exit;
-
-			if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
-			{
-				rtw_set_802_11_bssid(padapter, temp->sa_data);
-				goto exit;
-			}
-			else
-			{
-				ret = -EINVAL;
-				goto exit;
-			}
-#endif
-
 			break;
-		}
 
 		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
 
@@ -1669,10 +1634,8 @@ static int rtw_wx_set_wap(struct net_dev
 
 		src_bssid = temp->sa_data;
 
-		if ((_rtw_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == _TRUE)
-		{
-			if(!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode))
-			{
+		if ((_rtw_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == _TRUE) {
+			if(!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode)) {
 				ret = -1;
 				_exit_critical_bh(&queue->lock, &irqL);
 				_exit_critical_bh(&pmlmepriv->lock, &irqL);
@@ -1738,16 +1701,6 @@ static int rtw_wx_set_mlme(struct net_de
 			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
-#if 0
-/* SIOCSIWMLME data */
-struct	iw_mlme
-{
-	__u16		cmd; /* IW_MLME_* */
-	__u16		reason_code;
-	struct sockaddr	addr;
-};
-#endif
-
 	int ret=0;
 	u16 reason;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
@@ -1999,26 +1952,14 @@ _func_enter_;
 					//DBG_871X("WEXT_CSCAN_TYPE_SECTION\n");
 					pos+=1; len-=1;
 					break;
-				#if 0
-				case WEXT_CSCAN_NPROBE_SECTION:
-					DBG_871X("WEXT_CSCAN_NPROBE_SECTION\n");
-					break;
-				#endif
-
 				default:
-					//DBG_871X("Unknown CSCAN section %c\n", section);
 					len = 0; // stop parsing
 			}
-			//DBG_871X("len:%d\n", len);
-
 		}
-
 		//jeff: it has still some scan paramater to parse, we only do this now...
 		_status = rtw_set_802_11_bssid_list_scan(padapter, ssid, RTW_SSID_SCAN_AMOUNT);
 
-	} else
-
-	{
+	} else {
 		_status = rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);
 	}
 
@@ -2310,20 +2251,6 @@ static int rtw_wx_set_essid(struct net_d
 		{
 			if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == _TRUE)
 			{
-#if 0
-				if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
-				{
-					rtw_set_802_11_ssid(padapter, &ndis_ssid);
-
-					goto exit;
-				}
-				else
-				{
-					RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("rtw_wx_set_ssid(): scanned_queue is empty\n"));
-					ret = -EINVAL;
-					goto exit;
-				}
-#endif
 			        RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_warning_,
 					 ("rtw_wx_set_essid: scan_q is empty, set ssid to check if scanning again!\n"));
 
@@ -2640,29 +2567,6 @@ static int rtw_wx_get_retry(struct net_d
 
 }
 
-#if 0
-#define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
-#define IW_ENCODE_FLAGS		0xFF00	/* Flags defined below */
-#define IW_ENCODE_MODE		0xF000	/* Modes defined below */
-#define IW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
-#define IW_ENCODE_ENABLED	0x0000	/* Encoding enabled */
-#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
-#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
-#define IW_ENCODE_NOKEY		0x0800  /* Key is write only, so not present */
-#define IW_ENCODE_TEMP		0x0400  /* Temporary key */
-/*
-iwconfig wlan0 key on -> flags = 0x6001 -> maybe it means auto
-iwconfig wlan0 key off -> flags = 0x8800
-iwconfig wlan0 key open -> flags = 0x2800
-iwconfig wlan0 key open 1234567890 -> flags = 0x2000
-iwconfig wlan0 key restricted -> flags = 0x4800
-iwconfig wlan0 key open [3] 1234567890 -> flags = 0x2003
-iwconfig wlan0 key restricted [2] 1234567890 -> flags = 0x4002
-iwconfig wlan0 key open [3] -> flags = 0x2803
-iwconfig wlan0 key restricted [2] -> flags = 0x4802
-*/
-#endif
-
 static int rtw_wx_set_enc(struct net_device *dev,
 			    struct iw_request_info *info,
 			    union iwreq_data *wrqu, char *keybuf)
@@ -3151,55 +3055,7 @@ static int rtw_wx_get_nick(struct net_de
 		_rtw_memcpy(extra, "<WIFI@REALTEK>", 14);
 	}
 
-	//rtw_signal_process(pid, SIGUSR1); //for test
-
-	//dump debug info here
-/*
-	u32 dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, and 8021x
-	u32 dot11PrivacyAlgrthm;	// This specify the privacy for shared auth. algorithm.
-	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key
-	u32 ndisauthtype;
-	u32 ndisencryptstatus;
-*/
-
-	//DBG_871X("auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n",
-	//		psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
-	//		psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
-
-	//DBG_871X("enc_alg=0x%x\n", psecuritypriv->dot11PrivacyAlgrthm);
-	//DBG_871X("auth_type=0x%x\n", psecuritypriv->ndisauthtype);
-	//DBG_871X("enc_type=0x%x\n", psecuritypriv->ndisencryptstatus);
-
-#if 0
-	DBG_871X("dbg(0x210)=0x%x\n", rtw_read32(padapter, 0x210));
-	DBG_871X("dbg(0x608)=0x%x\n", rtw_read32(padapter, 0x608));
-	DBG_871X("dbg(0x280)=0x%x\n", rtw_read32(padapter, 0x280));
-	DBG_871X("dbg(0x284)=0x%x\n", rtw_read32(padapter, 0x284));
-	DBG_871X("dbg(0x288)=0x%x\n", rtw_read32(padapter, 0x288));
-
-	DBG_871X("dbg(0x664)=0x%x\n", rtw_read32(padapter, 0x664));
-
-
-	DBG_871X("\n");
-
-	DBG_871X("dbg(0x430)=0x%x\n", rtw_read32(padapter, 0x430));
-	DBG_871X("dbg(0x438)=0x%x\n", rtw_read32(padapter, 0x438));
-
-	DBG_871X("dbg(0x440)=0x%x\n", rtw_read32(padapter, 0x440));
-
-	DBG_871X("dbg(0x458)=0x%x\n", rtw_read32(padapter, 0x458));
-
-	DBG_871X("dbg(0x484)=0x%x\n", rtw_read32(padapter, 0x484));
-	DBG_871X("dbg(0x488)=0x%x\n", rtw_read32(padapter, 0x488));
-
-	DBG_871X("dbg(0x444)=0x%x\n", rtw_read32(padapter, 0x444));
-	DBG_871X("dbg(0x448)=0x%x\n", rtw_read32(padapter, 0x448));
-	DBG_871X("dbg(0x44c)=0x%x\n", rtw_read32(padapter, 0x44c));
-	DBG_871X("dbg(0x450)=0x%x\n", rtw_read32(padapter, 0x450));
-#endif
-
 	return 0;
-
 }
 
 static int rtw_wx_read32(struct net_device *dev,
@@ -3359,12 +3215,6 @@ static int rtw_wx_set_channel_plan(struc
 	extern int rtw_channel_plan;
 	u8 channel_plan_req = (u8) (*((int *)wrqu));
 
-	#if 0
-	rtw_channel_plan = (int)wrqu->data.pointer;
-	pregistrypriv->channel_plan = rtw_channel_plan;
-	pmlmepriv->ChannelPlan = pregistrypriv->channel_plan;
-	#endif
-
 	if( _SUCCESS == rtw_set_chplan_cmd(padapter, channel_plan_req, 1) ) {
 		DBG_871X("%s set channel_plan = 0x%02X\n", __func__, pmlmepriv->ChannelPlan);
 	} else
@@ -3428,15 +3278,6 @@ static  int rtw_drvext_hdl(struct net_de
 						union iwreq_data *wrqu, char *extra)
 {
 
- #if 0
-struct	iw_point
-{
-  void __user	*pointer;	/* Pointer to the data  (in user space) */
-  __u16		length;		/* number of fields or size in bytes */
-  __u16		flags;		/* Optional params */
-};
- #endif
-
 #ifdef CONFIG_DRVEXT_MODULE
 	u8 res;
 	struct drvext_handler *phandler;
@@ -6209,56 +6050,6 @@ exit:
 
 }
 
-#if 0
-void mac_reg_dump(_adapter *padapter)
-{
-	int i,j=1;
-	DBG_871X("\n======= MAC REG =======\n");
-	for(i=0x0;i<0x300;i+=4)
-	{
-		if(j%4==1)	DBG_871X("0x%02x",i);
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	DBG_871X("\n");
-	}
-	for(i=0x400;i<0x800;i+=4)
-	{
-		if(j%4==1)	DBG_871X("0x%02x",i);
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	DBG_871X("\n");
-	}
-}
-void bb_reg_dump(_adapter *padapter)
-{
-	int i,j=1;
-	DBG_871X("\n======= BB REG =======\n");
-	for(i=0x800;i<0x1000;i+=4)
-	{
-		if(j%4==1) DBG_871X("0x%02x",i);
-
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	DBG_871X("\n");
-	}
-}
-void rf_reg_dump(_adapter *padapter)
-{
-	int i,j=1,path;
-	u32 value;
-	DBG_871X("\n======= RF REG =======\n");
-	for(path=0;path<2;path++)
-	{
-		DBG_871X("\nRF_Path(%x)\n",path);
-		for(i=0;i<0x100;i++)
-		{
-			value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
-			if(j%4==1)	DBG_871X("0x%02x ",i);
-			DBG_871X(" 0x%08x ",value);
-			if((j++)%4==0)	DBG_871X("\n");
-		}
-	}
-}
-
-#endif
-
 void mac_reg_dump(_adapter *padapter)
 {
 	int i,j=1;
@@ -6711,17 +6502,6 @@ static int rtw_dbg_port(struct net_devic
 						rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DUMP_RXPKT, &(extra_arg));
 					}
 					break;
-#if 0
-					case 0x0d://dump cam
-					{
-						//u8 entry = (u8) extra_arg;
-						u8 entry=0;
-						//dump cam
-						for(entry=0;entry<32;entry++)
-							read_cam(padapter,entry);
-					}
-					break;
-#endif
 		#ifdef DBG_CONFIG_ERROR_DETECT
 				case 0x0f:
 						{
@@ -6948,26 +6728,6 @@ static int wpa_set_param(struct net_devi
 		 * be set.
 		 */
 
-#if 0
-		struct ieee80211_security sec = {
-			.flags = SEC_ENABLED,
-			.enabled = value,
-		};
-		ieee->drop_unencrypted = value;
-		/* We only change SEC_LEVEL for open mode. Others
-		 * are set by ipw_wpa_set_encryption.
-		 */
-		if (!value) {
-			sec.flags |= SEC_LEVEL;
-			sec.level = SEC_LEVEL_0;
-		}
-		else {
-			sec.flags |= SEC_LEVEL;
-			sec.level = SEC_LEVEL_1;
-		}
-		if (ieee->set_security)
-			ieee->set_security(ieee->dev, &sec);
-#endif
 		break;
 
 	}
@@ -7786,23 +7546,6 @@ static int rtw_ioctl_get_sta_data(struct
 	psta = rtw_get_stainfo(pstapriv, param_ex->sta_addr);
 	if(psta)
 	{
-#if 0
-		struct {
-			u16 aid;
-			u16 capability;
-			int flags;
-			u32 sta_set;
-			u8 tx_supp_rates[16];
-			u32 tx_supp_rates_len;
-			struct rtw_ieee80211_ht_cap ht_cap;
-			u64	rx_pkts;
-			u64	rx_bytes;
-			u64	rx_drops;
-			u64	tx_pkts;
-			u64	tx_bytes;
-			u64	tx_drops;
-		} get_sta;
-#endif
 		psta_data->aid = (u16)psta->aid;
 		psta_data->capability = psta->capability;
 		psta_data->flags = psta->flags;
@@ -10853,10 +10596,6 @@ static s32 createpseudoadhoc(PADAPTER pa
 	pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 
-#if 0
-	err = rtw_createbss_cmd(padapter);
-	if (err == _FAIL) return _FAIL;
-#else
 {
 	struct wlan_network *pcur_network;
 	struct sta_info *psta;
@@ -10877,9 +10616,6 @@ static s32 createpseudoadhoc(PADAPTER pa
 	_rtw_memcpy(&pcur_network->network, pdev_network, get_WLAN_BSSID_EX_sz(pdev_network));
 
 	// set msr to WIFI_FW_ADHOC_STATE
-#if 0
-	Set_NETYPE0_MSR(padapter, WIFI_FW_ADHOC_STATE);
-#else
 	{
 		u8 val8;
 
@@ -10888,9 +10624,7 @@ static s32 createpseudoadhoc(PADAPTER pa
 		val8 |= WIFI_FW_ADHOC_STATE & 0x3;
 		rtw_write8(padapter, MSR, val8);
 	}
-#endif
 }
-#endif
 
 	return _SUCCESS;
 }

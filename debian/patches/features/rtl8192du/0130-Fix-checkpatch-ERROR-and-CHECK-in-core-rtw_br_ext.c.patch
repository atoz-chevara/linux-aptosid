From 7a29ae82235426910032f394f25ec6cb557d52d8 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Mon, 6 May 2013 13:41:10 -0500
Subject: [PATCH 130/210] Fix checkpatch ERROR and CHECK in core/rtw_br_ext.c

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_br_ext.c |   14 +-
 core/rtw_xmit.c   | 1883 +++++++++++++++++++++--------------------------------
 2 files changed, 760 insertions(+), 1137 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_br_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_br_ext.c
@@ -149,12 +149,12 @@ static inline int  __nat25_has_expired(s
 
 
 static inline void __nat25_generate_ipv4_network_addr(unsigned char *networkAddr,
-				unsigned int *ipAddr)
+				unsigned int *ipaddr)
 {
 	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
 
 	networkAddr[0] = NAT25_IPV4;
-	memcpy(networkAddr+7, (unsigned char *)ipAddr, 4);
+	memcpy(networkAddr+7, (unsigned char *)ipaddr, 4);
 }
 
 
@@ -201,12 +201,12 @@ static inline void __nat25_generate_pppo
 
 #ifdef CL_IPV6_PASS
 static  void __nat25_generate_ipv6_network_addr(unsigned char *networkAddr,
-				unsigned int *ipAddr)
+				unsigned int *ipaddr)
 {
 	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
 
 	networkAddr[0] = NAT25_IPV6;
-	memcpy(networkAddr+1, (unsigned char *)ipAddr, 16);
+	memcpy(networkAddr+1, (unsigned char *)ipaddr, 16);
 }
 
 
@@ -1433,14 +1433,14 @@ void dhcp_flag_bcast(struct rtw_adapter
 }
 
 
-void *scdb_findEntry(struct rtw_adapter *priv, unsigned char *macaddr,
-				unsigned char *ipAddr)
+void *scdb_findentry(struct rtw_adapter *priv, unsigned char *macaddr,
+				unsigned char *ipaddr)
 {
 	unsigned char networkAddr[MAX_NETWORK_ADDR_LEN];
 	struct nat25_network_db_entry *db;
 	int hash;
 
-	__nat25_generate_ipv4_network_addr(networkAddr, (unsigned int *)ipAddr);
+	__nat25_generate_ipv4_network_addr(networkAddr, (unsigned int *)ipaddr);
 	hash = __nat25_network_hash(networkAddr);
 	db = priv->nethash[hash];
 	while (db != NULL) {
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -43,17 +43,16 @@ _func_enter_;
 _func_exit_;
 }
 
-
 void	_rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)
 {
 _func_enter_;
 
-	memset((unsigned char *)psta_xmitpriv, 0, sizeof (struct sta_xmit_priv));
+	memset((unsigned char *)psta_xmitpriv, 0, sizeof(struct sta_xmit_priv));
 
 	_rtw_spinlock_init(&psta_xmitpriv->lock);
 
 	/* for (i = 0 ; i < MAX_NUMBLKS; i++) */
-	/* 	_init_txservq(&(psta_xmitpriv->blk_q[i])); */
+	/*	_init_txservq(&(psta_xmitpriv->blk_q[i])); */
 
 	_init_txservq(&psta_xmitpriv->be_q);
 	_init_txservq(&psta_xmitpriv->bk_q);
@@ -70,7 +69,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv
 	int i;
 	struct xmit_buf *pxmitbuf;
 	struct xmit_frame *pxframe;
-	int	res=_SUCCESS;
+	int	res = _SUCCESS;
 
 _func_enter_;
 
@@ -87,21 +86,14 @@ _func_enter_;
 
 	pxmitpriv->adapter = padapter;
 
-	/* for (i = 0 ; i < MAX_NUMBLKS; i++) */
-	/* 	_rtw_init_queue(&pxmitpriv->blk_strms[i]); */
-
 	_rtw_init_queue(&pxmitpriv->be_pending);
 	_rtw_init_queue(&pxmitpriv->bk_pending);
 	_rtw_init_queue(&pxmitpriv->vi_pending);
 	_rtw_init_queue(&pxmitpriv->vo_pending);
 	_rtw_init_queue(&pxmitpriv->bm_pending);
 
-	/* _rtw_init_queue(&pxmitpriv->legacy_dz_queue); */
-	/* _rtw_init_queue(&pxmitpriv->apsd_queue); */
-
 	_rtw_init_queue(&pxmitpriv->free_xmit_queue);
 
-
 	/*
 	Please allocate memory with the sz = (struct xmit_frame) * NR_XMITFRAME,
 	and initialize free_xmit_frame below.
@@ -111,19 +103,16 @@ _func_enter_;
 	pxmitpriv->pallocated_frame_buf = rtw_zvmalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
 
 	if (pxmitpriv->pallocated_frame_buf  == NULL) {
-		pxmitpriv->pxmit_frame_buf =NULL;
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_frame fail!\n"));
-		res= _FAIL;
+		pxmitpriv->pxmit_frame_buf = NULL;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_frame fail!\n"));
+		res = _FAIL;
 		goto exit;
 	}
 	pxmitpriv->pxmit_frame_buf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_frame_buf), 4);
-	/* pxmitpriv->pxmit_frame_buf = pxmitpriv->pallocated_frame_buf + 4 - */
-	/* 						((SIZE_PTR) (pxmitpriv->pallocated_frame_buf) &3); */
 
-	pxframe = (struct xmit_frame*) pxmitpriv->pxmit_frame_buf;
+	pxframe = (struct xmit_frame *)pxmitpriv->pxmit_frame_buf;
 
-	for (i = 0; i < NR_XMITFRAME; i++)
-	{
+	for (i = 0; i < NR_XMITFRAME; i++) {
 		INIT_LIST_HEAD(&(pxframe->list));
 
 		pxframe->padapter = padapter;
@@ -151,41 +140,35 @@ _func_enter_;
 	pxmitpriv->pallocated_xmitbuf = rtw_zvmalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
 
 	if (pxmitpriv->pallocated_xmitbuf  == NULL) {
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_buf fail!\n"));
-		res= _FAIL;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_buf fail!\n"));
+		res = _FAIL;
 		goto exit;
 	}
 
 	pxmitpriv->pxmitbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_xmitbuf), 4);
-	/* pxmitpriv->pxmitbuf = pxmitpriv->pallocated_xmitbuf + 4 - */
-	/* 						((SIZE_PTR) (pxmitpriv->pallocated_xmitbuf) &3); */
 
-	pxmitbuf = (struct xmit_buf*)pxmitpriv->pxmitbuf;
+	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
 
-	for (i = 0; i < NR_XMITBUFF; i++)
-	{
+	for (i = 0; i < NR_XMITBUFF; i++) {
 		INIT_LIST_HEAD(&pxmitbuf->list);
 
 		pxmitbuf->priv_data = NULL;
 		pxmitbuf->padapter = padapter;
 		pxmitbuf->ext_tag = false;
 
-		if ((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ))) == _FAIL) {
-			res= _FAIL;
+		res = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ));
+		if (res == _FAIL)
 			goto exit;
-		}
 
 		pxmitbuf->flags = XMIT_VO_QUEUE;
 
 		rtw_list_insert_tail(&pxmitbuf->list, &(pxmitpriv->free_xmitbuf_queue.queue));
 		#ifdef DBG_XMIT_BUF
-		pxmitbuf->no=i;
+		pxmitbuf->no = i;
 		#endif
 
 		pxmitbuf++;
-
 	}
-
 	pxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;
 
 	/*  Init xmit extension buff */
@@ -194,34 +177,31 @@ _func_enter_;
 	pxmitpriv->pallocated_xmit_extbuf = rtw_zvmalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);
 
 	if (pxmitpriv->pallocated_xmit_extbuf  == NULL) {
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_extbuf fail!\n"));
-		res= _FAIL;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_extbuf fail!\n"));
+		res = _FAIL;
 		goto exit;
 	}
 
 	pxmitpriv->pxmit_extbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_xmit_extbuf), 4);
 
-	pxmitbuf = (struct xmit_buf*)pxmitpriv->pxmit_extbuf;
+	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;
 
-	for (i = 0; i < NR_XMIT_EXTBUFF; i++)
-	{
+	for (i = 0; i < NR_XMIT_EXTBUFF; i++) {
 		INIT_LIST_HEAD(&pxmitbuf->list);
 
 		pxmitbuf->priv_data = NULL;
 		pxmitbuf->padapter = padapter;
 		pxmitbuf->ext_tag = true;
 
-		if ((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ)) == _FAIL) {
-			res= _FAIL;
+		res = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ);
+		if (res == _FAIL)
 			goto exit;
-		}
 
 		rtw_list_insert_tail(&pxmitbuf->list, &(pxmitpriv->free_xmit_extbuf_queue.queue));
 		#ifdef DBG_XMIT_BUF
-		pxmitbuf->no=i;
+		pxmitbuf->no = i;
 		#endif
 		pxmitbuf++;
-
 	}
 
 	pxmitpriv->free_xmit_extbuf_cnt = NR_XMIT_EXTBUFF;
@@ -229,7 +209,7 @@ _func_enter_;
 	rtw_alloc_hwxmits(padapter);
 	rtw_init_hwxmits(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);
 
-	pxmitpriv->txirp_cnt=1;
+	pxmitpriv->txirp_cnt = 1;
 
 	_rtw_init_sema(&(pxmitpriv->tx_retevt), 0);
 
@@ -244,9 +224,7 @@ _func_enter_;
 	_rtw_mutex_init(&pxmitpriv->ack_tx_mutex);
 	rtw_sctx_init(&pxmitpriv->ack_tx_ops, 0);
 #endif
-
 	rtw_hal_init_xmit_priv(padapter);
-
 exit:
 
 _func_exit_;
@@ -254,8 +232,7 @@ _func_exit_;
 	return res;
 }
 
-void  rtw_mfree_xmit_priv_lock (struct xmit_priv *pxmitpriv);
-void  rtw_mfree_xmit_priv_lock (struct xmit_priv *pxmitpriv)
+void  rtw_mfree_xmit_priv_lock(struct xmit_priv *pxmitpriv)
 {
 	_rtw_spinlock_free(&pxmitpriv->lock);
 	_rtw_free_sema(&pxmitpriv->xmit_sema);
@@ -267,67 +244,49 @@ void  rtw_mfree_xmit_priv_lock (struct x
 	_rtw_spinlock_free(&pxmitpriv->vo_pending.lock);
 	_rtw_spinlock_free(&pxmitpriv->bm_pending.lock);
 
-	/* _rtw_spinlock_free(&pxmitpriv->legacy_dz_queue.lock); */
-	/* _rtw_spinlock_free(&pxmitpriv->apsd_queue.lock); */
-
 	_rtw_spinlock_free(&pxmitpriv->free_xmit_queue.lock);
 	_rtw_spinlock_free(&pxmitpriv->free_xmitbuf_queue.lock);
 	_rtw_spinlock_free(&pxmitpriv->pending_xmitbuf_queue.lock);
 }
 
-
-void _rtw_free_xmit_priv (struct xmit_priv *pxmitpriv)
+void _rtw_free_xmit_priv(struct xmit_priv *pxmitpriv)
 {
 	int i;
 	struct rtw_adapter *padapter = pxmitpriv->adapter;
-	struct xmit_frame	*pxmitframe = (struct xmit_frame*) pxmitpriv->pxmit_frame_buf;
+	struct xmit_frame	*pxmitframe = (struct xmit_frame *)pxmitpriv->pxmit_frame_buf;
 	struct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
 
- _func_enter_;
-
+_func_enter_;
 	rtw_hal_free_xmit_priv(padapter);
-
 	rtw_mfree_xmit_priv_lock(pxmitpriv);
-
-	if (pxmitpriv->pxmit_frame_buf==NULL)
+	if (pxmitpriv->pxmit_frame_buf == NULL)
 		goto out;
 
-	for (i=0; i<NR_XMITFRAME; i++)
-	{
+	for (i = 0; i < NR_XMITFRAME; i++) {
 		rtw_os_xmit_complete(padapter, pxmitframe);
-
 		pxmitframe++;
 	}
-
-	for (i=0; i<NR_XMITBUFF; i++)
-	{
-		rtw_os_xmit_resource_free(padapter, pxmitbuf,(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ));
+	for (i = 0; i < NR_XMITBUFF; i++) {
+		rtw_os_xmit_resource_free(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ));
 		pxmitbuf++;
 	}
-
-	if (pxmitpriv->pallocated_frame_buf) {
+	if (pxmitpriv->pallocated_frame_buf)
 		rtw_vmfree(pxmitpriv->pallocated_frame_buf, NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
-	}
-
-
-	if (pxmitpriv->pallocated_xmitbuf) {
+	if (pxmitpriv->pallocated_xmitbuf)
 		rtw_vmfree(pxmitpriv->pallocated_xmitbuf, NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
-	}
 
 	/*  free xmit extension buff */
 	_rtw_spinlock_free(&pxmitpriv->free_xmit_extbuf_queue.lock);
 
 	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;
-	for (i=0; i<NR_XMIT_EXTBUFF; i++)
-	{
-		rtw_os_xmit_resource_free(padapter, pxmitbuf,(MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ));
+	for (i = 0; i < NR_XMIT_EXTBUFF; i++) {
+		rtw_os_xmit_resource_free(padapter, pxmitbuf, (MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ));
 
 		pxmitbuf++;
 	}
 
-	if (pxmitpriv->pallocated_xmit_extbuf) {
+	if (pxmitpriv->pallocated_xmit_extbuf)
 		rtw_vmfree(pxmitpriv->pallocated_xmit_extbuf, NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);
-	}
 
 	rtw_free_hwxmits(padapter);
 
@@ -350,18 +309,14 @@ static void update_attrib_vcs_info(struc
 
 
 	if (pattrib->nr_frags != 1)
-	{
 		sz = padapter->xmitpriv.frag_len;
-	}
 	else /* no frag */
-	{
 		sz = pattrib->last_txcmdsz;
-	}
 
 	/*  (1) RTS_Threshold is compared to the MPDU, not MSDU. */
 	/*  (2) If there are more than one frag in  this MSDU, only the first frag uses protection frame. */
-	/* 		Other fragments are protected by previous fragment. */
-	/* 		So we only need to check the length of first fragment. */
+	/*		Other fragments are protected by previous fragment. */
+	/*		So we only need to check the length of first fragment. */
 	if (pmlmeext->cur_wireless_mode < WIRELESS_11_24N  || padapter->registrypriv.wifi_spec) {
 		if (sz > padapter->registrypriv.rts_thresh) {
 			pattrib->vcs_mode = RTS_CTS;
@@ -376,9 +331,8 @@ static void update_attrib_vcs_info(struc
 	} else {
 		while (true) {
 			/* IOT action */
-			if ((pmlmeinfo->assoc_AP_vendor == atherosAP) && (pattrib->ampdu_en==true) &&
-				(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_))
-			{
+			if ((pmlmeinfo->assoc_AP_vendor == atherosAP) && (pattrib->ampdu_en == true) &&
+			    (padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)) {
 				pattrib->vcs_mode = CTS_TO_SELF;
 				break;
 			}
@@ -396,17 +350,16 @@ static void update_attrib_vcs_info(struc
 
 			/* check HT op mode */
 			if (pattrib->ht_en) {
-				u8 HTOpMode = pmlmeinfo->HT_protection;
-				if ((pmlmeext->cur_bwmode && (HTOpMode == 2 || HTOpMode == 3)) ||
-				    (!pmlmeext->cur_bwmode && HTOpMode == 3)) {
+				u8 ht_op_mode = pmlmeinfo->HT_protection;
+				if ((pmlmeext->cur_bwmode && (ht_op_mode == 2 || ht_op_mode == 3)) ||
+				    (!pmlmeext->cur_bwmode && ht_op_mode == 3)) {
 					pattrib->vcs_mode = RTS_CTS;
 					break;
 				}
 			}
 
 			/* check rts */
-			if (sz > padapter->registrypriv.rts_thresh)
-			{
+			if (sz > padapter->registrypriv.rts_thresh) {
 				pattrib->vcs_mode = RTS_CTS;
 				break;
 			}
@@ -414,8 +367,7 @@ static void update_attrib_vcs_info(struc
 			/* to do list: check MIMO power save condition. */
 
 			/* check AMPDU aggregation for TXOP */
-			if (pattrib->ampdu_en==true)
-			{
+			if (pattrib->ampdu_en == true) {
 				pattrib->vcs_mode = RTS_CTS;
 				break;
 			}
@@ -428,18 +380,17 @@ static void update_attrib_vcs_info(struc
 
 static void update_attrib_phy_info(struct pkt_attrib *pattrib, struct sta_info *psta)
 {
-
 	pattrib->mdata = 0;
 	pattrib->eosp = 0;
-	pattrib->triggered=0;
+	pattrib->triggered = 0;
 
-	/* qos_en, ht_en, init rate, ,bw, ch_offset, sgi */
+	/* qos_en, ht_en, init rate, , bw, ch_offset, sgi */
 	pattrib->qos_en = psta->qos_option;
 	pattrib->ht_en = psta->htpriv.ht_option;
 	pattrib->raid = psta->raid;
 	pattrib->bwmode = psta->htpriv.bwmode;
 	pattrib->ch_offset = psta->htpriv.ch_offset;
-	pattrib->sgi= psta->htpriv.sgi;
+	pattrib->sgi = psta->htpriv.sgi;
 	pattrib->ampdu_en = false;
 
 	pattrib->retry_ctrl = false;
@@ -449,29 +400,28 @@ u8	qos_acm(u8 acm_mask, u8 priority)
 {
 	u8	change_priority = priority;
 
-	switch (priority)
-	{
-		case 0:
-		case 3:
-			if (acm_mask & BIT(1))
-				change_priority = 1;
-			break;
-		case 1:
-		case 2:
-			break;
-		case 4:
-		case 5:
-			if (acm_mask & BIT(2))
-				change_priority = 0;
-			break;
-		case 6:
-		case 7:
-			if (acm_mask & BIT(3))
-				change_priority = 5;
-			break;
-		default:
-			DBG_8192D("qos_acm(): invalid pattrib->priority: %d!!!\n", priority);
-			break;
+	switch (priority) {
+	case 0:
+	case 3:
+		if (acm_mask & BIT(1))
+			change_priority = 1;
+		break;
+	case 1:
+	case 2:
+		break;
+	case 4:
+	case 5:
+		if (acm_mask & BIT(2))
+			change_priority = 0;
+		break;
+	case 6:
+	case 7:
+		if (acm_mask & BIT(3))
+			change_priority = 5;
+		break;
+	default:
+		DBG_8192D("qos_acm(): invalid pattrib->priority: %d!!!\n", priority);
+		break;
 	}
 
 	return change_priority;
@@ -481,24 +431,23 @@ static void set_qos(struct pkt_file *ppk
 {
 	struct ethhdr etherhdr;
 	struct iphdr ip_hdr;
-	s32 UserPriority = 0;
+	s32 userpriority = 0;
 
 
 	_rtw_open_pktfile(ppktfile->pkt, ppktfile);
-	_rtw_pktfile_read(ppktfile, (unsigned char*)&etherhdr, ETH_HLEN);
+	_rtw_pktfile_read(ppktfile, (unsigned char *)&etherhdr, ETH_HLEN);
 
-	/*  get UserPriority from IP hdr */
+	/*  get userpriority from IP hdr */
 	if (pattrib->ether_type == 0x0800) {
-		_rtw_pktfile_read(ppktfile, (u8*)&ip_hdr, sizeof(ip_hdr));
-/* 		UserPriority = (ntohs(ip_hdr.tos) >> 5) & 0x3; */
-		UserPriority = ip_hdr.tos >> 5;
+		_rtw_pktfile_read(ppktfile, (u8 *)&ip_hdr, sizeof(ip_hdr));
+		userpriority = ip_hdr.tos >> 5;
 	} else if (pattrib->ether_type == 0x888e) {
 		/*  "When priority processing of data frames is supported, */
 		/*  a STA's SME should send EAPOL-Key frames at the highest priority." */
-		UserPriority = 7;
+		userpriority = 7;
 	}
 
-	pattrib->priority = UserPriority;
+	pattrib->priority = userpriority;
 	pattrib->hdrlen = WLAN_HDR_A3_QOS_LEN;
 	pattrib->subtype = WIFI_QOS_DATA_TYPE;
 }
@@ -514,13 +463,13 @@ static s32 update_attrib(struct rtw_adap
 	struct sta_priv		*pstapriv = &padapter->stapriv;
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct qos_priv		*pqospriv= &pmlmepriv->qospriv;
+	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
 	int res = _SUCCESS;
 
- _func_enter_;
+_func_enter_;
 
 	_rtw_open_pktfile(pkt, &pktfile);
-	i = _rtw_pktfile_read(&pktfile, (u8*)&etherhdr, ETH_HLEN);
+	i = _rtw_pktfile_read(&pktfile, (u8 *)&etherhdr, ETH_HLEN);
 
 	pattrib->ether_type = ntohs(etherhdr.h_proto);
 
@@ -531,23 +480,20 @@ static s32 update_attrib(struct rtw_adap
 	pattrib->pctrl = 0;
 
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
-		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
 		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
 		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
-	}
-	else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+	} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
 		memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
 		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
-	}
-	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+	} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
 		memcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);
 	}
 
 	pattrib->pktlen = pktfile.pkt_len;
 
-	if (ETH_P_IP == pattrib->ether_type)
-	{
+	if (ETH_P_IP == pattrib->ether_type) {
 		/*  The following is for DHCP and ARP packet, we use cck1M to tx these packets and let LPS awake some time */
 		/*  to prevent DHCP protocol fail */
 		u8 tmp[24];
@@ -556,19 +502,10 @@ static s32 update_attrib(struct rtw_adap
 		if (pktfile.pkt_len > 282) {/* MINIMUM_DHCP_PACKET_SIZE) { */
 			if (ETH_P_IP == pattrib->ether_type) {/*  IP header */
 				if (((tmp[21] == 68) && (tmp[23] == 67)) ||
-					((tmp[21] == 67) && (tmp[23] == 68))) {
+				    ((tmp[21] == 67) && (tmp[23] == 68))) {
 					/*  68 : UDP BOOTP client */
 					/*  67 : UDP BOOTP server */
-					RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("======================update_attrib: get DHCP Packet\n"));
-					/*  Use low rate to send DHCP packet. */
-					/* if (pMgntInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom) */
-					/*  */
-					/* 	tcb_desc->DataRate = MgntQuery_TxRateExcludeCCKRates(ieee); 0xc; ofdm 6m */
-					/* 	tcb_desc->bTxDisableRateFallBack = false; */
-					/*  */
-					/* else */
-					/* 	pTcb->DataRate = Adapter->MgntInfo.LowestBasicRate; */
-					/* RTPRINT(FDM, WA_IOT, ("DHCP TranslateHeader(), pTcb->DataRate = 0x%x\n", pTcb->DataRate)); */
+					RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("====================== update_attrib: get DHCP Packet\n"));
 					pattrib->dhcp_pkt = 1;
 				}
 			}
@@ -576,14 +513,11 @@ static s32 update_attrib(struct rtw_adap
 	}
 
 	if ((pattrib->ether_type == 0x888e) || (pattrib->dhcp_pkt == 1))
-	{
 		rtw_set_scan_deny(padapter, 3000);
-	}
 
 #ifdef CONFIG_LPS
 	/*  If EAPOL , ARP , OR DHCP packet, driver must be in active mode. */
-	if ((pattrib->ether_type == 0x0806) || (pattrib->ether_type == 0x888e) || (pattrib->dhcp_pkt == 1))
-	{
+	if ((pattrib->ether_type == 0x0806) || (pattrib->ether_type == 0x888e) || (pattrib->dhcp_pkt == 1)) {
 		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SPECIAL_PACKET, 1);
 	}
 #endif
@@ -595,28 +529,23 @@ static s32 update_attrib(struct rtw_adap
 		psta = rtw_get_bcmc_stainfo(padapter);
 	} else {
 		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
-		if (psta == NULL)	{ /*  if we cannot get psta => drrp the pkt */
+		if (psta == NULL) { /*  if we cannot get psta => drrp the pkt */
 			RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("\nupdate_attrib => get sta_info fail, ra:%pM\n", pattrib->ra));
 			#ifdef DBG_TX_DROP_FRAME
 			DBG_8192D("DBG_TX_DROP_FRAME %s get sta_info fail, ra:%pM\n", __func__, pattrib->ra);
 			#endif
-			res =_FAIL;
+			res = _FAIL;
 			goto exit;
-		}
-		else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE)==true)&&(!(psta->state & _FW_LINKED)))
-		{
-			res =_FAIL;
+		} else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) && (!(psta->state & _FW_LINKED))) {
+			res = _FAIL;
 			goto exit;
 		}
 	}
 
-	if (psta)
-	{
+	if (psta) {
 		pattrib->mac_id = psta->mac_id;
 		pattrib->psta = psta;
-	}
-	else
-	{
+	} else {
 		/*  if we cannot get psta => drop the pkt */
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("\nupdate_attrib => get sta_info fail, ra:%pM\n", pattrib->ra));
 		#ifdef DBG_TX_DROP_FRAME
@@ -634,120 +563,100 @@ static s32 update_attrib(struct rtw_adap
 	pattrib->subtype = WIFI_DATA_TYPE;
 	pattrib->priority = 0;
 
-	if (check_fwstate(pmlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
-	{
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE)) {
 		if (psta->qos_option)
 			set_qos(&pktfile, pattrib);
-	}
-	else
-	{
-		if (pqospriv->qos_option)
-		{
+	} else {
+		if (pqospriv->qos_option) {
 			set_qos(&pktfile, pattrib);
 
 			if (pmlmepriv->acm_mask != 0)
-			{
 				pattrib->priority = qos_acm(pmlmepriv->acm_mask, pattrib->priority);
-			}
 		}
 	}
 
 	if (psta->ieee8021x_blocked == true) {
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\n psta->ieee8021x_blocked == true\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("\n psta->ieee8021x_blocked == true\n"));
 
 		pattrib->encrypt = 0;
 
-		if ((pattrib->ether_type != 0x888e) && (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false))
-		{
-			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\npsta->ieee8021x_blocked == true,  pattrib->ether_type(%.4x) != 0x888e\n",pattrib->ether_type));
+		if ((pattrib->ether_type != 0x888e) && (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false)) {
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("\npsta->ieee8021x_blocked == true,  pattrib->ether_type(%.4x) != 0x888e\n", pattrib->ether_type));
 			#ifdef DBG_TX_DROP_FRAME
-			DBG_8192D("DBG_TX_DROP_FRAME %s psta->ieee8021x_blocked == true,  pattrib->ether_type(%.4x) != 0x888e\n", __func__,pattrib->ether_type);
+			DBG_8192D("DBG_TX_DROP_FRAME %s psta->ieee8021x_blocked == true,  pattrib->ether_type(%.4x) != 0x888e\n", __func__, pattrib->ether_type);
 			#endif
 			res = _FAIL;
 			goto exit;
 		}
-	}
-	else
-	{
+	} else {
 		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);
 
-		switch (psecuritypriv->dot11AuthAlgrthm)
-		{
-			case dot11AuthAlgrthm_Open:
-			case dot11AuthAlgrthm_Shared:
-			case dot11AuthAlgrthm_Auto:
-				pattrib->key_idx = (u8)psecuritypriv->dot11PrivacyKeyIndex;
-				break;
-			case dot11AuthAlgrthm_8021X:
-				if (bmcast)
-					pattrib->key_idx = (u8)psecuritypriv->dot118021XGrpKeyid;
-				else
-					pattrib->key_idx = 0;
-				break;
-			default:
+		switch (psecuritypriv->dot11AuthAlgrthm) {
+		case dot11AuthAlgrthm_Open:
+		case dot11AuthAlgrthm_Shared:
+		case dot11AuthAlgrthm_Auto:
+			pattrib->key_idx = (u8)psecuritypriv->dot11PrivacyKeyIndex;
+			break;
+		case dot11AuthAlgrthm_8021X:
+			if (bmcast)
+				pattrib->key_idx = (u8)psecuritypriv->dot118021XGrpKeyid;
+			else
 				pattrib->key_idx = 0;
-				break;
-		}
-
-
-	}
-
-	switch (pattrib->encrypt)
-	{
-		case _WEP40_:
-		case _WEP104_:
-			pattrib->iv_len = 4;
-			pattrib->icv_len = 4;
 			break;
-
-		case _TKIP_:
-			pattrib->iv_len = 8;
-			pattrib->icv_len = 4;
-
-			if (padapter->securitypriv.busetkipkey==_FAIL)
-			{
-				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\npadapter->securitypriv.busetkipkey(%d)==_FAIL drop packet\n", padapter->securitypriv.busetkipkey));
-				#ifdef DBG_TX_DROP_FRAME
-				DBG_8192D("DBG_TX_DROP_FRAME %s padapter->securitypriv.busetkipkey(%d)==_FAIL drop packet\n", __func__, padapter->securitypriv.busetkipkey);
-				#endif
-				res =_FAIL;
-				goto exit;
-			}
-
-			break;
-		case _AES_:
-			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\n pattrib->encrypt=%d  (_AES_)\n",pattrib->encrypt));
-			pattrib->iv_len = 8;
-			pattrib->icv_len = 8;
-			break;
-
 		default:
-			pattrib->iv_len = 0;
-			pattrib->icv_len = 0;
+			pattrib->key_idx = 0;
 			break;
+		}
+	}
+	switch (pattrib->encrypt) {
+	case _WEP40_:
+	case _WEP104_:
+		pattrib->iv_len = 4;
+		pattrib->icv_len = 4;
+		break;
+	case _TKIP_:
+		pattrib->iv_len = 8;
+		pattrib->icv_len = 4;
+
+		if (padapter->securitypriv.busetkipkey == _FAIL) {
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("\npadapter->securitypriv.busetkipkey(%d) == _FAIL drop packet\n", padapter->securitypriv.busetkipkey));
+			#ifdef DBG_TX_DROP_FRAME
+			DBG_8192D("DBG_TX_DROP_FRAME %s padapter->securitypriv.busetkipkey(%d) == _FAIL drop packet\n", __func__, padapter->securitypriv.busetkipkey);
+			#endif
+			res = _FAIL;
+			goto exit;
+		}
+		break;
+	case _AES_:
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("\n pattrib->encrypt =%d  (_AES_)\n", pattrib->encrypt));
+		pattrib->iv_len = 8;
+		pattrib->icv_len = 8;
+		break;
+	default:
+		pattrib->iv_len = 0;
+		pattrib->icv_len = 0;
+		break;
 	}
 
 	RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,
-		 ("update_attrib: encrypt=%d  securitypriv.sw_encrypt=%d\n",
+		 ("update_attrib: encrypt =%d  securitypriv.sw_encrypt =%d\n",
 		  pattrib->encrypt, padapter->securitypriv.sw_encrypt));
 
 	if (pattrib->encrypt &&
-	    ((padapter->securitypriv.sw_encrypt == true) || (psecuritypriv->hw_decrypted == false)))
-	{
+	    ((padapter->securitypriv.sw_encrypt == true) ||
+	    (psecuritypriv->hw_decrypted == false))) {
 		pattrib->bswenc = true;
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,
-			 ("update_attrib: encrypt=%d securitypriv.hw_decrypted=%d bswenc=true\n",
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+			 ("update_attrib: encrypt =%d securitypriv.hw_decrypted =%d bswenc = true\n",
 			  pattrib->encrypt, padapter->securitypriv.sw_encrypt));
 	} else {
 		pattrib->bswenc = false;
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("update_attrib: bswenc=false\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("update_attrib: bswenc = false\n"));
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if ((pattrib->encrypt && bmcast) || (pattrib->encrypt ==_WEP40_) || (pattrib->encrypt ==_WEP104_))
-	{
+	if ((pattrib->encrypt && bmcast) || (pattrib->encrypt == _WEP40_) || (pattrib->encrypt == _WEP104_))
 		pattrib->bswenc = true;/* force using sw enc. */
-	}
 #endif
 
 	rtw_set_tx_chksum_offload(pkt, pattrib);
@@ -761,36 +670,29 @@ _func_exit_;
 	return res;
 }
 
-static s32 xmitframe_addmic(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe) {
-	int			curfragnum,length;
-	u8	*pframe, *payload,mic[8];
+static s32 xmitframe_addmic(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	int			curfragnum, length;
+	u8	*pframe, *payload, mic[8];
 	struct	mic_data		micdata;
 	struct	sta_info		*stainfo;
-	struct	qos_priv   *pqospriv= &(padapter->mlmepriv.qospriv);
+	struct	qos_priv   *pqospriv = &(padapter->mlmepriv.qospriv);
 	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
-	struct	security_priv	*psecuritypriv=&padapter->securitypriv;
-	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
-	u8 priority[4]={0x0,0x0,0x0,0x0};
+	struct	security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct	xmit_priv		*pxmitpriv = &padapter->xmitpriv;
+	u8 priority[4] = {0x0, 0x0, 0x0, 0x0};
 	int bmcst = IS_MCAST(pattrib->ra);
 
 	if (pattrib->psta)
-	{
 		stainfo = pattrib->psta;
-	}
 	else
-	{
-		stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0]);
-	}
-
-
-
+		stainfo = rtw_get_stainfo(&padapter->stapriv, &pattrib->ra[0]);
 _func_enter_;
 
-	if (pattrib->encrypt ==_TKIP_)/* if (psecuritypriv->dot11PrivacyAlgrthm==_TKIP_PRIVACY_) */
-	{
+	if (pattrib->encrypt == _TKIP_) {
 		/* encode mic code */
-		if (stainfo!= NULL) {
-			u8 null_key[16]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
+		if (stainfo != NULL) {
+			u8 null_key[16] = {0};
 
 #ifdef CONFIG_USB_TX_AGGREGATION
 			pframe = pxmitframe->buf_addr + TXDESC_SIZE + (pxmitframe->pkt_offset * PACKET_OFFSET_SZ);
@@ -798,20 +700,17 @@ _func_enter_;
 			pframe = pxmitframe->buf_addr + TXDESC_OFFSET;
 #endif
 
-			if (bmcst)
-			{
-				if (_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16)==true) {
-					/* DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n"); */
+			if (bmcst) {
+				if (_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16) == true) {
+					/* DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey == 0\n"); */
 					/* rtw_msleep_os(10); */
 					return _FAIL;
 				}
 				/* start to calculate the mic code */
 				rtw_secmicsetkey(&micdata, psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey);
-			}
-			else
-			{
-				if (_rtw_memcmp(&stainfo->dot11tkiptxmickey.skey[0],null_key, 16)==true) {
-					/* DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n"); */
+			} else {
+				if (_rtw_memcmp(&stainfo->dot11tkiptxmickey.skey[0], null_key, 16) == true) {
+					/* DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey == 0\n"); */
 					/* rtw_msleep_os(10); */
 					return _FAIL;
 				}
@@ -819,71 +718,83 @@ _func_enter_;
 				rtw_secmicsetkey(&micdata, &stainfo->dot11tkiptxmickey.skey[0]);
 			}
 
-			if (pframe[1]&1) {   /* ToDS==1 */
+			if (pframe[1]&1) {   /* ToDS == 1 */
 				rtw_secmicappend(&micdata, &pframe[16], 6);  /* DA */
-				if (pframe[1]&2)  /* From Ds==1 */
+				if (pframe[1]&2)  /* From Ds == 1 */
 					rtw_secmicappend(&micdata, &pframe[24], 6);
 				else
 				rtw_secmicappend(&micdata, &pframe[10], 6);
-			}
-			else {	/* ToDS==0 */
+			} else {	/* ToDS == 0 */
 				rtw_secmicappend(&micdata, &pframe[4], 6);   /* DA */
-				if (pframe[1]&2)  /* From Ds==1 */
+				if (pframe[1]&2)  /* From Ds == 1 */
 					rtw_secmicappend(&micdata, &pframe[16], 6);
 				else
 					rtw_secmicappend(&micdata, &pframe[10], 6);
-
 			}
-
-                    /* if (pqospriv->qos_option==1) */
-                    if (pattrib->qos_en)
-				priority[0]=(u8)pxmitframe->attrib.priority;
-
-
+			if (pattrib->qos_en)
+				priority[0] = (u8)pxmitframe->attrib.priority;
 			rtw_secmicappend(&micdata, &priority[0], 4);
 
-			payload=pframe;
+			payload = pframe;
 
-			for (curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++) {
-				payload=(u8 *)RND4((SIZE_PTR)(payload));
-				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("===curfragnum=%d, pframe= 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x,!!!\n",
-					curfragnum,*payload, *(payload+1),*(payload+2),*(payload+3),*(payload+4),*(payload+5),*(payload+6),*(payload+7)));
-
-				payload=payload+pattrib->hdrlen+pattrib->iv_len;
-				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("curfragnum=%d pattrib->hdrlen=%d pattrib->iv_len=%d",curfragnum,pattrib->hdrlen,pattrib->iv_len));
-				if ((curfragnum+1)==pattrib->nr_frags) {
-					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);
-					rtw_secmicappend(&micdata, payload,length);
-					payload=payload+length;
-				}
-				else {
-					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);
+			for (curfragnum = 0; curfragnum < pattrib->nr_frags; curfragnum++) {
+				payload = (u8 *)RND4((SIZE_PTR)(payload));
+				RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+					 ("=== curfragnum =%d, pframe = 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x,!!!\n",
+					 curfragnum, *payload, *(payload+1),
+					 *(payload+2), *(payload+3),
+					 *(payload+4), *(payload+5),
+					 *(payload+6), *(payload+7)));
+
+				payload = payload+pattrib->hdrlen+pattrib->iv_len;
+				RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+					 ("curfragnum =%d pattrib->hdrlen =%d pattrib->iv_len =%d",
+					 curfragnum, pattrib->hdrlen,
+					 pattrib->iv_len));
+				if ((curfragnum+1) == pattrib->nr_frags) {
+					length = pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);
+					rtw_secmicappend(&micdata, payload, length);
+					payload = payload+length;
+				} else {
+					length = pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);
 					rtw_secmicappend(&micdata, payload, length);
-					payload=payload+length+pattrib->icv_len;
-					RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("curfragnum=%d length=%d pattrib->icv_len=%d",curfragnum,length,pattrib->icv_len));
+					payload = payload+length+pattrib->icv_len;
+					RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+						 ("curfragnum =%d length =%d pattrib->icv_len =%d",
+						 curfragnum, length, pattrib->icv_len));
 				}
 			}
-			rtw_secgetmic(&micdata,&(mic[0]));
-			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: before add mic code!!!\n"));
-			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: pattrib->last_txcmdsz=%d!!!\n",pattrib->last_txcmdsz));
-			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: mic[0]=0x%.2x ,mic[1]=0x%.2x ,mic[2]=0x%.2x ,mic[3]=0x%.2x\n\
-  mic[4]=0x%.2x ,mic[5]=0x%.2x ,mic[6]=0x%.2x ,mic[7]=0x%.2x !!!!\n",
-				mic[0],mic[1],mic[2],mic[3],mic[4],mic[5],mic[6],mic[7]));
+			rtw_secgetmic(&micdata, &(mic[0]));
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+				 ("xmitframe_addmic: before add mic code!!!\n"));
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+				 ("xmitframe_addmic: pattrib->last_txcmdsz =%d!!!\n",
+				 pattrib->last_txcmdsz));
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+				 ("xmitframe_addmic: mic[0]= 0x%.2x , mic[1]= 0x%.2x , mic[2]= 0x%.2x , mic[3]= 0x%.2x\n\mic[4]= 0x%.2x , mic[5]= 0x%.2x , mic[6]= 0x%.2x , mic[7]= 0x%.2x !!!!\n",
+				 mic[0], mic[1], mic[2], mic[3], mic[4], mic[5],
+				 mic[6], mic[7]));
 			/* add mic code  and add the mic code length in last_txcmdsz */
 
-			memcpy(payload, &(mic[0]),8);
-			pattrib->last_txcmdsz+=8;
+			memcpy(payload, &(mic[0]), 8);
+			pattrib->last_txcmdsz += 8;
 
-			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("\n ========last pkt========\n"));
-			payload=payload-pattrib->last_txcmdsz+8;
-			for (curfragnum=0;curfragnum<pattrib->last_txcmdsz;curfragnum=curfragnum+8)
-					RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,(" %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x ",
-					*(payload+curfragnum), *(payload+curfragnum+1), *(payload+curfragnum+2),*(payload+curfragnum+3),
-					*(payload+curfragnum+4),*(payload+curfragnum+5),*(payload+curfragnum+6),*(payload+curfragnum+7)));
-			}
-			else {
-				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: rtw_get_stainfo==NULL!!!\n"));
-			}
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("\n ======== last pkt ========\n"));
+			payload = payload-pattrib->last_txcmdsz+8;
+			for (curfragnum = 0; curfragnum < pattrib->last_txcmdsz; curfragnum += 8)
+				RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,
+					 (" %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x ",
+					 *(payload+curfragnum),
+					 *(payload+curfragnum+1),
+					 *(payload+curfragnum+2),
+					 *(payload+curfragnum+3),
+					 *(payload+curfragnum+4),
+					 *(payload+curfragnum+5),
+					 *(payload+curfragnum+6),
+					 *(payload+curfragnum+7)));
+		} else {
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic: rtw_get_stainfo == NULL!!!\n"));
+		}
 	}
 
 _func_exit_;
@@ -891,17 +802,14 @@ _func_exit_;
 	return _SUCCESS;
 }
 
-static s32 xmitframe_swencrypt(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe) {
+static s32 xmitframe_swencrypt(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
+{
 	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
-	/* struct	security_priv	*psecuritypriv=&padapter->securitypriv; */
 
 _func_enter_;
 
-	/* if ((psecuritypriv->sw_encrypt)||(pattrib->bswenc)) */
-	if (pattrib->bswenc)
-	{
-		/* DBG_8192D("start xmitframe_swencrypt\n"); */
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_alert_,("### xmitframe_swencrypt\n"));
+	if (pattrib->bswenc) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("### xmitframe_swencrypt\n"));
 		switch (pattrib->encrypt) {
 		case _WEP40_:
 		case _WEP104_:
@@ -918,7 +826,7 @@ _func_enter_;
 		}
 
 	} else {
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_notice_,("### xmitframe_hwencrypt\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_, ("### xmitframe_hwencrypt\n"));
 	}
 
 _func_exit_;
@@ -937,8 +845,8 @@ s32 rtw_make_wlanhdr (struct rtw_adapter
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	struct sta_priv		*pstapriv = &padapter->stapriv;
-	struct sta_info *ptdls_sta=NULL, *psta_backup=NULL;
-	u8 direct_link=0;
+	struct sta_info *ptdls_sta = NULL, *psta_backup = NULL;
+	u8 direct_link = 0;
 #endif /* CONFIG_TDLS */
 
 	int res = _SUCCESS;
@@ -953,30 +861,28 @@ _func_enter_;
 	if (pattrib->psta) {
 		psta = pattrib->psta;
 	} else {
-		if (bmcst) {
+		if (bmcst)
 			psta = rtw_get_bcmc_stainfo(padapter);
-		} else {
+		else
 			psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
-		}
 	}
 
 	memset(hdr, 0, WLANHDR_OFFSET);
 
 	SetFrameSubType(fctrl, pattrib->subtype);
 
-	if (pattrib->subtype & WIFI_DATA_TYPE)
-	{
+	if (pattrib->subtype & WIFI_DATA_TYPE) {
 		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == true)) {
 			/* to_ds = 1, fr_ds = 0; */
 #ifdef CONFIG_TDLS
 			if ((ptdlsinfo->setup_state == TDLS_LINKED_STATE)) {
 				ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
-				if ((ptdls_sta!=NULL)&&(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE)&&(pattrib->ether_type!=0x0806)) {
-					/* TDLS data transfer, ToDS=0, FrDs=0 */
+				if ((ptdls_sta != NULL) && (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) && (pattrib->ether_type != 0x0806)) {
+					/* TDLS data transfer, ToDS = 0, FrDs = 0 */
 					memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
 					memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 					memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
-					direct_link=1;
+					direct_link = 1;
 				} else {
 					/*  1.Data transfer to AP */
 					/*  2.Arp pkt will relayed by AP */
@@ -997,9 +903,7 @@ _func_enter_;
 
 			if (pqospriv->qos_option)
 				qos_option = true;
-
-		}
-		else if ((check_fwstate(pmlmepriv,  WIFI_AP_STATE) == true)) {
+		} else if ((check_fwstate(pmlmepriv,  WIFI_AP_STATE) == true)) {
 			/* to_ds = 0, fr_ds = 1; */
 			SetFrDs(fctrl);
 			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
@@ -1008,8 +912,7 @@ _func_enter_;
 
 			if (psta->qos_option)
 				qos_option = true;
-		}
-		else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
+		} else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
 			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
 			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
@@ -1017,9 +920,8 @@ _func_enter_;
 
 			if (psta->qos_option)
 				qos_option = true;
-		}
-		else {
-			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("fw_state:%x is not allowed to xmit frame\n", get_fwstate(pmlmepriv)));
+		} else {
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("fw_state:%x is not allowed to xmit frame\n", get_fwstate(pmlmepriv)));
 			res = _FAIL;
 			goto exit;
 		}
@@ -1030,8 +932,7 @@ _func_enter_;
 		if (pattrib->encrypt)
 			SetPrivacy(fctrl);
 
-		if (qos_option)
-		{
+		if (qos_option) {
 			qc = (unsigned short *)(hdr + pattrib->hdrlen - 2);
 
 			if (pattrib->priority)
@@ -1045,88 +946,69 @@ _func_enter_;
 		/* TODO: fill HT Control Field */
 
 		/* Update Seq Num will be handled by f/w */
-		{
-			if (psta) {
+		if (psta) {
 #ifdef CONFIG_TDLS
-				if (direct_link==1)
-				{
-					psta_backup = psta;
-					psta = ptdls_sta;
-				}
+			if (direct_link == 1) {
+				psta_backup = psta;
+				psta = ptdls_sta;
+			}
 #endif /* CONFIG_TDLS */
 
-				psta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
-				psta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
+			psta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
+			psta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
 
-				pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[pattrib->priority];
+			pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[pattrib->priority];
 
-				SetSeqNum(hdr, pattrib->seqnum);
+			SetSeqNum(hdr, pattrib->seqnum);
 
 
-				/* check if enable ampdu */
-				if (pattrib->ht_en && psta->htpriv.ampdu_enable)
-				{
-					if (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
+			/* check if enable ampdu */
+			if (pattrib->ht_en && psta->htpriv.ampdu_enable) {
+				if (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
 					pattrib->ampdu_en = true;
-				}
-
-				/* re-check if enable ampdu by BA_starting_seqctrl */
-				if (pattrib->ampdu_en == true)
-				{
-					u16 tx_seq;
-
-					tx_seq = psta->BA_starting_seqctrl[pattrib->priority & 0x0f];
-
-					/* check BA_starting_seqctrl */
-					if (SN_LESS(pattrib->seqnum, tx_seq))
-					{
-						/* DBG_8192D("tx ampdu seqnum(%d) < tx_seq(%d)\n", pattrib->seqnum, tx_seq); */
-						pattrib->ampdu_en = false;/* AGG BK */
-					}
-					else if (SN_EQUAL(pattrib->seqnum, tx_seq))
-					{
-						psta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (tx_seq+1)&0xfff;
+			}
 
-						pattrib->ampdu_en = true;/* AGG EN */
-					}
-					else
-					{
-						/* DBG_8192D("tx ampdu over run\n"); */
-						psta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (pattrib->seqnum+1)&0xfff;
-						pattrib->ampdu_en = true;/* AGG EN */
-					}
+			/* re-check if enable ampdu by BA_starting_seqctrl */
+			if (pattrib->ampdu_en == true) {
+				u16 tx_seq;
+
+				tx_seq = psta->BA_starting_seqctrl[pattrib->priority & 0x0f];
+
+				/* check BA_starting_seqctrl */
+				if (SN_LESS(pattrib->seqnum, tx_seq)) {
+					/* DBG_8192D("tx ampdu seqnum(%d) < tx_seq(%d)\n", pattrib->seqnum, tx_seq); */
+					pattrib->ampdu_en = false;/* AGG BK */
+				} else if (SN_EQUAL(pattrib->seqnum, tx_seq)) {
+					psta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (tx_seq+1)&0xfff;
 
+					pattrib->ampdu_en = true;/* AGG EN */
+				} else {
+					/* DBG_8192D("tx ampdu over run\n"); */
+					psta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (pattrib->seqnum+1)&0xfff;
+					pattrib->ampdu_en = true;/* AGG EN */
 				}
+			}
 
 #ifdef CONFIG_TDLS
-				if (direct_link==1)
-				{
-					if (pattrib->encrypt) {
-						pattrib->encrypt= _AES_;
-						pattrib->iv_len=8;
-						pattrib->icv_len=8;
-					}
-
-					/* qos_en, ht_en, init rate, ,bw, ch_offset, sgi */
-					/* pattrib->qos_en = ptdls_sta->qos_option; */
-					pattrib->ht_en = ptdls_sta->htpriv.ht_option;
-					pattrib->raid = ptdls_sta->raid;
-					pattrib->bwmode = ptdls_sta->htpriv.bwmode;
-					pattrib->ch_offset = ptdls_sta->htpriv.ch_offset;
-					pattrib->sgi= ptdls_sta->htpriv.sgi;
-
-					pattrib->mac_id = ptdls_sta->mac_id;
-
-					psta = psta_backup;
+			if (direct_link == 1) {
+				if (pattrib->encrypt) {
+					pattrib->encrypt = _AES_;
+					pattrib->iv_len = 8;
+					pattrib->icv_len = 8;
 				}
-#endif /* CONFIG_TDLS */
 
+				/* qos_en, ht_en, init rate, , bw, ch_offset, sgi */
+				/* pattrib->qos_en = ptdls_sta->qos_option; */
+				pattrib->ht_en = ptdls_sta->htpriv.ht_option;
+				pattrib->raid = ptdls_sta->raid;
+				pattrib->bwmode = ptdls_sta->htpriv.bwmode;
+				pattrib->ch_offset = ptdls_sta->htpriv.ch_offset;
+				pattrib->sgi = ptdls_sta->htpriv.sgi;
+				pattrib->mac_id = ptdls_sta->mac_id;
+				psta = psta_backup;
 			}
+#endif /* CONFIG_TDLS */
 		}
-
-	}
-	else
-	{
 	}
 
 exit:
@@ -1154,26 +1036,24 @@ s32 rtw_txframes_sta_ac_pending(struct r
 
 	psta = pattrib->psta;
 
-	switch (priority)
-	{
-			case 1:
-			case 2:
-				ptxservq = &(psta->sta_xmitpriv.bk_q);
-				break;
-			case 4:
-			case 5:
-				ptxservq = &(psta->sta_xmitpriv.vi_q);
-				break;
-			case 6:
-			case 7:
-				ptxservq = &(psta->sta_xmitpriv.vo_q);
-				break;
-			case 0:
-			case 3:
-			default:
-				ptxservq = &(psta->sta_xmitpriv.be_q);
-			break;
-
+	switch (priority) {
+	case 1:
+	case 2:
+		ptxservq = &(psta->sta_xmitpriv.bk_q);
+		break;
+	case 4:
+	case 5:
+		ptxservq = &(psta->sta_xmitpriv.vi_q);
+		break;
+	case 6:
+	case 7:
+		ptxservq = &(psta->sta_xmitpriv.vo_q);
+		break;
+	case 0:
+	case 3:
+	default:
+		ptxservq = &(psta->sta_xmitpriv.be_q);
+	break;
 	}
 
 	return ptxservq->qcnt;
@@ -1181,60 +1061,60 @@ s32 rtw_txframes_sta_ac_pending(struct r
 
 #ifdef CONFIG_TDLS
 
-int rtw_build_tdls_ies(struct rtw_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, u8 action)
+int rtw_build_tdls_ies(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe, u8 *pframe, u8 action)
 {
-	int res=_SUCCESS;
+	int res = _SUCCESS;
 
 	switch (action) {
-		case TDLS_SETUP_REQUEST:
-			rtw_build_tdls_setup_req_ies(padapter, pxmitframe, pframe);
-			break;
-		case TDLS_SETUP_RESPONSE:
-			rtw_build_tdls_setup_rsp_ies(padapter, pxmitframe, pframe);
-			break;
-		case TDLS_SETUP_CONFIRM:
-			rtw_build_tdls_setup_cfm_ies(padapter, pxmitframe, pframe);
-			break;
-		case TDLS_TEARDOWN:
-			rtw_build_tdls_teardown_ies(padapter, pxmitframe, pframe);
-			break;
-		case TDLS_DISCOVERY_REQUEST:
-			rtw_build_tdls_dis_req_ies(padapter, pxmitframe, pframe);
-			break;
-		case TDLS_PEER_TRAFFIC_INDICATION:
-			rtw_build_tdls_peer_traffic_indication_ies(padapter, pxmitframe, pframe);
-			break;
-		case TDLS_CHANNEL_SWITCH_REQUEST:
-			rtw_build_tdls_ch_switch_req_ies(padapter, pxmitframe, pframe);
-			break;
-		case TDLS_CHANNEL_SWITCH_RESPONSE:
-			rtw_build_tdls_ch_switch_rsp_ies(padapter, pxmitframe, pframe);
-			break;
+	case TDLS_SETUP_REQUEST:
+		rtw_build_tdls_setup_req_ies(padapter, pxmitframe, pframe);
+		break;
+	case TDLS_SETUP_RESPONSE:
+		rtw_build_tdls_setup_rsp_ies(padapter, pxmitframe, pframe);
+		break;
+	case TDLS_SETUP_CONFIRM:
+		rtw_build_tdls_setup_cfm_ies(padapter, pxmitframe, pframe);
+		break;
+	case TDLS_TEARDOWN:
+		rtw_build_tdls_teardown_ies(padapter, pxmitframe, pframe);
+		break;
+	case TDLS_DISCOVERY_REQUEST:
+		rtw_build_tdls_dis_req_ies(padapter, pxmitframe, pframe);
+		break;
+	case TDLS_PEER_TRAFFIC_INDICATION:
+		rtw_build_tdls_peer_traffic_indication_ies(padapter, pxmitframe, pframe);
+		break;
+	case TDLS_CHANNEL_SWITCH_REQUEST:
+		rtw_build_tdls_ch_switch_req_ies(padapter, pxmitframe, pframe);
+		break;
+	case TDLS_CHANNEL_SWITCH_RESPONSE:
+		rtw_build_tdls_ch_switch_rsp_ies(padapter, pxmitframe, pframe);
+		break;
 #ifdef CONFIG_WFD
-		case TUNNELED_PROBE_REQ:
-			rtw_build_tunneled_probe_req_ies(padapter, pxmitframe, pframe);
-			break;
-		case TUNNELED_PROBE_RSP:
-			rtw_build_tunneled_probe_rsp_ies(padapter, pxmitframe, pframe);
-			break;
+	case TUNNELED_PROBE_REQ:
+		rtw_build_tunneled_probe_req_ies(padapter, pxmitframe, pframe);
+		break;
+	case TUNNELED_PROBE_RSP:
+		rtw_build_tunneled_probe_rsp_ies(padapter, pxmitframe, pframe);
+		break;
 #endif /* CONFIG_WFD */
-		default:
-			res=_FAIL;
-			break;
+	default:
+		res = _FAIL;
+		break;
 	}
 
 	return res;
 }
 
-s32 rtw_make_tdls_wlanhdr (struct rtw_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib, u8 action)
+s32 rtw_make_tdls_wlanhdr(struct rtw_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib, u8 action)
 {
 	u16 *qc;
 	struct rtw_ieee80211_hdr *pwlanhdr = (struct rtw_ieee80211_hdr *)hdr;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
 	struct sta_priv		*pstapriv = &padapter->stapriv;
-	struct sta_info *psta=NULL, *ptdls_sta=NULL;
-	u8 tdls_seq=0, baddr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+	struct sta_info *psta = NULL, *ptdls_sta = NULL;
+	u8 tdls_seq = 0, baddr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 
 	int res = _SUCCESS;
 	u16 *fctrl = &pwlanhdr->frame_ctl;
@@ -1246,51 +1126,46 @@ _func_enter_;
 	SetFrameSubType(fctrl, pattrib->subtype);
 
 	switch (action) {
-		case TDLS_SETUP_REQUEST:
-		case TDLS_SETUP_RESPONSE:
-		case TDLS_SETUP_CONFIRM:
-		case TDLS_TEARDOWN:	/* directly to peer STA or via AP */
-		case TDLS_PEER_TRAFFIC_INDICATION:
-		case TDLS_PEER_PSM_REQUEST:	/* directly to peer STA or via AP */
-		case TUNNELED_PROBE_REQ:
-		case TUNNELED_PROBE_RSP:
+	case TDLS_SETUP_REQUEST:
+	case TDLS_SETUP_RESPONSE:
+	case TDLS_SETUP_CONFIRM:
+	case TDLS_TEARDOWN:	/* directly to peer STA or via AP */
+	case TDLS_PEER_TRAFFIC_INDICATION:
+	case TDLS_PEER_PSM_REQUEST:	/* directly to peer STA or via AP */
+	case TUNNELED_PROBE_REQ:
+	case TUNNELED_PROBE_RSP:
+		SetToDs(fctrl);
+		memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
+		memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+		memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
+		break;
+	case TDLS_CHANNEL_SWITCH_REQUEST:
+	case TDLS_CHANNEL_SWITCH_RESPONSE:
+	case TDLS_PEER_PSM_RESPONSE:
+	case TDLS_PEER_TRAFFIC_RESPONSE:
+		memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+		memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+		memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
+		tdls_seq = 1;
+		break;
+	case TDLS_DISCOVERY_REQUEST:	/* unicast: directly to peer sta, Bcast: via AP */
+		if (_rtw_memcmp(pattrib->dst, baddr, ETH_ALEN)) {
 			SetToDs(fctrl);
 			memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
 			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 			memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
-			break;
-		case TDLS_CHANNEL_SWITCH_REQUEST:
-		case TDLS_CHANNEL_SWITCH_RESPONSE:
-		case TDLS_PEER_PSM_RESPONSE:
-		case TDLS_PEER_TRAFFIC_RESPONSE:
+		} else {
 			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
 			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 			memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
-			tdls_seq=1;
-			break;
-		case TDLS_DISCOVERY_REQUEST:	/* unicast: directly to peer sta, Bcast: via AP */
-			if (_rtw_memcmp(pattrib->dst, baddr, ETH_ALEN))
-			{
-				SetToDs(fctrl);
-				memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
-				memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
-				memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
-			}
-			else
-			{
-				memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
-				memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
-				memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
-				tdls_seq=1;
-			}
-			break;
+			tdls_seq = 1;
+		}
+		break;
 	}
-
 	if (pattrib->encrypt)
 		SetPrivacy(fctrl);
 
-	if (pqospriv->qos_option)
-	{
+	if (pqospriv->qos_option) {
 		qc = (unsigned short *)(hdr + pattrib->hdrlen - 2);
 		if (pattrib->priority)
 			SetPriority(qc, pattrib->priority);
@@ -1301,8 +1176,8 @@ _func_enter_;
 
 	/*   1. update seq_num per link by sta_info */
 	/*   2. rewrite encrypt to _AES_, also rewrite iv_len, icv_len */
-	if (tdls_seq==1) {
-		ptdls_sta=rtw_get_stainfo(pstapriv, pattrib->dst);
+	if (tdls_seq == 1) {
+		ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
 		if (ptdls_sta) {
 			ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
 			ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
@@ -1310,12 +1185,12 @@ _func_enter_;
 			SetSeqNum(hdr, pattrib->seqnum);
 
 			if (pattrib->encrypt) {
-				pattrib->encrypt= _AES_;
-				pattrib->iv_len=8;
-				pattrib->icv_len=8;
+				pattrib->encrypt = _AES_;
+				pattrib->iv_len = 8;
+				pattrib->icv_len = 8;
 			}
 		} else {
-			res=_FAIL;
+			res = _FAIL;
 			goto exit;
 		}
 	} else if (psta) {
@@ -1333,7 +1208,7 @@ _func_exit_;
 	return res;
 }
 
-s32 rtw_xmit_tdls_coalesce(struct rtw_adapter * padapter, struct xmit_frame * pxmitframe, u8 action)
+s32 rtw_xmit_tdls_coalesce(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe, u8 action)
 {
 	s32 llc_sz;
 
@@ -1352,14 +1227,13 @@ _func_enter_;
 	if (pattrib->psta) {
 		psta = pattrib->psta;
 	} else {
-		if (bmcst) {
+		if (bmcst)
 			psta = rtw_get_bcmc_stainfo(padapter);
-		} else {
+		else
 			psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
-	        }
 	}
 
-	if (psta==NULL)
+	if (psta == NULL)
 		return _FAIL;
 
 	if (pxmitframe->buf_addr == NULL)
@@ -1377,34 +1251,29 @@ _func_enter_;
 	pframe += pattrib->hdrlen;
 
 	/* adding icv, if necessary... */
-	if (pattrib->iv_len)
-	{
-		if (psta != NULL)
-		{
-			switch (pattrib->encrypt)
-			{
-				case _WEP40_:
-				case _WEP104_:
-						WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
-					break;
-				case _TKIP_:
-					if (bmcst)
-						TKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
-					else
-						TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
-					break;
-				case _AES_:
-					if (bmcst)
-						AES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
-					else
-						AES_IV(pattrib->iv, psta->dot11txpn, 0);
-					break;
+	if (pattrib->iv_len) {
+		if (psta != NULL) {
+			switch (pattrib->encrypt) {
+			case _WEP40_:
+			case _WEP104_:
+					WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+				break;
+			case _TKIP_:
+				if (bmcst)
+					TKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+				else
+					TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
+				break;
+			case _AES_:
+				if (bmcst)
+					AES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+				else
+					AES_IV(pattrib->iv, psta->dot11txpn, 0);
+				break;
 			}
 		}
-
 		memcpy(pframe, pattrib->iv, pattrib->iv_len);
 		pframe += pattrib->iv_len;
-
 	}
 
 	llc_sz = rtw_put_snap(pframe, pattrib->ether_type);
@@ -1415,7 +1284,7 @@ _func_enter_;
 
 	rtw_build_tdls_ies(padapter, pxmitframe, pframe, action);
 
-	if ((pattrib->icv_len >0)&& (pattrib->bswenc)) {
+	if ((pattrib->icv_len > 0) && (pattrib->bswenc)) {
 		pframe += pattrib->pktlen;
 		memcpy(pframe, pattrib->icv, pattrib->icv_len);
 		pframe += pattrib->icv_len;
@@ -1426,9 +1295,7 @@ _func_enter_;
 			((pattrib->bswenc) ? pattrib->icv_len : 0) + pattrib->pktlen;
 
 	if (xmitframe_addmic(padapter, pxmitframe) == _FAIL)
-	{
 		goto exit;
-	}
 
 	xmitframe_swencrypt(padapter, pxmitframe);
 
@@ -1453,7 +1320,8 @@ u32 rtw_calculate_wlan_pkt_size_by_attri
 	len = pattrib->hdrlen + pattrib->iv_len; /*  WLAN Header and IV */
 	len += SNAP_SIZE + sizeof(u16); /*  LLC */
 	len += pattrib->pktlen;
-	if (pattrib->encrypt == _TKIP_) len += 8; /*  MIC */
+	if (pattrib->encrypt == _TKIP_)
+		len += 8; /*  MIC */
 	len += pattrib->icv_len; /*  ICV */
 
 	return len;
@@ -1495,13 +1363,12 @@ s32 rtw_xmitframe_coalesce(struct rtw_ad
 
 _func_enter_;
 
-	if (pattrib->psta) {
+	if (pattrib->psta)
 		psta = pattrib->psta;
-	} else {
+	else
 		psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
-	}
 
-	if (psta==NULL)
+	if (psta == NULL)
 		return _FAIL;
 
 	if (pxmitframe->buf_addr == NULL)
@@ -1527,8 +1394,7 @@ _func_enter_;
 	frg_inx = 0;
 	frg_len = pxmitpriv->frag_len - 4;/* 2346-4 = 2342 */
 
-	while (1)
-	{
+	while (1) {
 		llc_sz = 0;
 
 		mpdu_len = frg_len;
@@ -1541,40 +1407,32 @@ _func_enter_;
 		mpdu_len -= pattrib->hdrlen;
 
 		/* adding icv, if necessary... */
-		if (pattrib->iv_len)
-		{
-			/* if (check_fwstate(pmlmepriv, WIFI_MP_STATE)) */
-			/* 	psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv)); */
-			/* else */
-			/* 	psta = rtw_get_stainfo(pstapriv, pattrib->ra); */
-
-			if (psta != NULL)
-			{
-				switch (pattrib->encrypt)
-				{
-					case _WEP40_:
-					case _WEP104_:
-							WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
-						break;
-					case _TKIP_:
-						if (bmcst)
-							TKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
-						else
-							TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
-						break;
-					case _AES_:
-						if (bmcst)
-							AES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
-						else
-							AES_IV(pattrib->iv, psta->dot11txpn, 0);
-						break;
+		if (pattrib->iv_len) {
+			if (psta != NULL) {
+				switch (pattrib->encrypt) {
+				case _WEP40_:
+				case _WEP104_:
+						WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+					break;
+				case _TKIP_:
+					if (bmcst)
+						TKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+					else
+						TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
+					break;
+				case _AES_:
+					if (bmcst)
+						AES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+					else
+						AES_IV(pattrib->iv, psta->dot11txpn, 0);
+					break;
 				}
 			}
 
 			memcpy(pframe, pattrib->iv, pattrib->iv_len);
 
 			RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_,
-				 ("rtw_xmitframe_coalesce: keyid=%d pattrib->iv[3]=%.2x pframe=%.2x %.2x %.2x %.2x\n",
+				 ("rtw_xmitframe_coalesce: keyid =%d pattrib->iv[3]=%.2x pframe =%.2x %.2x %.2x %.2x\n",
 				  padapter->securitypriv.dot11PrivacyKeyIndex, pattrib->iv[3], *pframe, *(pframe+1), *(pframe+2), *(pframe+3)));
 
 			pframe += pattrib->iv_len;
@@ -1588,10 +1446,8 @@ _func_enter_;
 			mpdu_len -= llc_sz;
 		}
 
-		if ((pattrib->icv_len >0) && (pattrib->bswenc)) {
+		if ((pattrib->icv_len > 0) && (pattrib->bswenc))
 			mpdu_len -= pattrib->icv_len;
-		}
-
 
 		if (bmcst) {
 			/*  don't do fragment to broadcat/multicast packets */
@@ -1602,18 +1458,17 @@ _func_enter_;
 
 		pframe += mem_sz;
 
-		if ((pattrib->icv_len >0)&& (pattrib->bswenc)) {
+		if ((pattrib->icv_len > 0) && (pattrib->bswenc)) {
 			memcpy(pframe, pattrib->icv, pattrib->icv_len);
 			pframe += pattrib->icv_len;
 		}
 
 		frg_inx++;
 
-		if (bmcst || (rtw_endofpktfile(&pktfile) == true))
-		{
+		if (bmcst || (rtw_endofpktfile(&pktfile) == true)) {
 			pattrib->nr_frags = frg_inx;
 
-			pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + ((pattrib->nr_frags==1)? llc_sz:0) +
+			pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + ((pattrib->nr_frags == 1) ? llc_sz : 0) +
 					((pattrib->bswenc) ? pattrib->icv_len : 0) + mem_sz;
 
 			ClearMFrag(mem_start);
@@ -1629,9 +1484,8 @@ _func_enter_;
 		memcpy(mem_start, pbuf_start + TXDESC_OFFSET, pattrib->hdrlen);
 	}
 
-	if (xmitframe_addmic(padapter, pxmitframe) == _FAIL)
-	{
-		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic(padapter, pxmitframe)==_FAIL\n"));
+	if (xmitframe_addmic(padapter, pxmitframe) == _FAIL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic(padapter, pxmitframe) == _FAIL\n"));
 		res = _FAIL;
 		goto exit;
 	}
@@ -1695,38 +1549,29 @@ void rtw_update_protection(struct rtw_ad
 
 _func_enter_;
 
-	switch (pxmitpriv->vcs_setting)
-	{
-		case DISABLE_VCS:
+	switch (pxmitpriv->vcs_setting) {
+	case DISABLE_VCS:
+		pxmitpriv->vcs = NONE_VCS;
+		break;
+	case ENABLE_VCS:
+		break;
+	case AUTO_VCS:
+	default:
+		perp = rtw_get_ie(ie, _ERPINFO_IE_, &erp_len, ie_len);
+		if (perp == NULL) {
 			pxmitpriv->vcs = NONE_VCS;
-			break;
-
-		case ENABLE_VCS:
-			break;
-
-		case AUTO_VCS:
-		default:
-			perp = rtw_get_ie(ie, _ERPINFO_IE_, &erp_len, ie_len);
-			if (perp == NULL)
-			{
-				pxmitpriv->vcs = NONE_VCS;
-			}
-			else
-			{
-				protection = (*(perp + 2)) & BIT(1);
-				if (protection)
-				{
-					if (pregistrypriv->vcs_type == RTS_CTS)
-						pxmitpriv->vcs = RTS_CTS;
-					else
-						pxmitpriv->vcs = CTS_TO_SELF;
-				}
+		} else {
+			protection = (*(perp + 2)) & BIT(1);
+			if (protection) {
+				if (pregistrypriv->vcs_type == RTS_CTS)
+					pxmitpriv->vcs = RTS_CTS;
 				else
-					pxmitpriv->vcs = NONE_VCS;
-			}
-
-			break;
-
+					pxmitpriv->vcs = CTS_TO_SELF;
+			} else {
+				pxmitpriv->vcs = NONE_VCS;
+			}
+		}
+		break;
 	}
 
 _func_exit_;
@@ -1739,8 +1584,7 @@ void rtw_count_tx_stats(struct rtw_adapt
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 
-	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
-	{
+	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {
 		pxmitpriv->tx_bytes += sz;
 #ifdef CONFIG_USB_TX_AGGREGATION
 		pmlmepriv->LinkDetectInfo.NumTxOkInPeriod += pxmitframe->agg_num;
@@ -1750,8 +1594,7 @@ void rtw_count_tx_stats(struct rtw_adapt
 
 		psta = pxmitframe->attrib.psta;
 
-		if (psta)
-		{
+		if (psta) {
 			pstats = &psta->sta_stats;
 #ifdef CONFIG_USB_TX_AGGREGATION
 			pstats->tx_pkts += pxmitframe->agg_num;
@@ -1765,14 +1608,14 @@ void rtw_count_tx_stats(struct rtw_adapt
 
 struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv)
 {
-	long unsigned int irqL;
+	long unsigned int flags;
 	struct xmit_buf *pxmitbuf =  NULL;
 	struct list_head *plist, *phead;
 	struct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;
 
 _func_enter_;
 
-	spin_lock_irqsave(&pfree_queue->lock, irqL);
+	spin_lock_irqsave(&pfree_queue->lock, flags);
 
 	if (_rtw_queue_empty(pfree_queue) == true) {
 		pxmitbuf = NULL;
@@ -1785,25 +1628,18 @@ _func_enter_;
 
 		rtw_list_delete(&(pxmitbuf->list));
 	}
-
-	if (pxmitbuf !=  NULL)
-	{
+	if (pxmitbuf !=  NULL) {
 		pxmitpriv->free_xmit_extbuf_cnt--;
 		#ifdef DBG_XMIT_BUF
-		DBG_8192D("DBG_XMIT_BUF ALLOC no=%d,  free_xmit_extbuf_cnt=%d\n",pxmitbuf->no, pxmitpriv->free_xmit_extbuf_cnt);
+		DBG_8192D("DBG_XMIT_BUF ALLOC no =%d,  free_xmit_extbuf_cnt =%d\n", pxmitbuf->no, pxmitpriv->free_xmit_extbuf_cnt);
 		#endif
-
-
 		pxmitbuf->priv_data = NULL;
-
 		if (pxmitbuf->sctx) {
 			DBG_8192D("%s pxmitbuf->sctx is not NULL\n", __func__);
 			rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);
 		}
-
 	}
-
-	spin_unlock_irqrestore(&pfree_queue->lock, irqL);
+	spin_unlock_irqrestore(&pfree_queue->lock, flags);
 
 _func_exit_;
 
@@ -1812,27 +1648,25 @@ _func_exit_;
 
 s32 rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
 {
-	long unsigned int irqL;
+	long unsigned int flags;
 	struct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;
 
 _func_enter_;
 
-	if (pxmitbuf==NULL)
-	{
+	if (pxmitbuf == NULL)
 		return _FAIL;
-	}
 
-	spin_lock_irqsave(&pfree_queue->lock, irqL);
+	spin_lock_irqsave(&pfree_queue->lock, flags);
 
 	rtw_list_delete(&pxmitbuf->list);
 
 	rtw_list_insert_tail(&(pxmitbuf->list), get_list_head(pfree_queue));
 	pxmitpriv->free_xmit_extbuf_cnt++;
 	#ifdef DBG_XMIT_BUF
-	DBG_8192D("DBG_XMIT_BUF FREE no=%d, free_xmit_extbuf_cnt=%d\n",pxmitbuf->no ,pxmitpriv->free_xmit_extbuf_cnt);
+	DBG_8192D("DBG_XMIT_BUF FREE no =%d, free_xmit_extbuf_cnt =%d\n", pxmitbuf->no , pxmitpriv->free_xmit_extbuf_cnt);
 	#endif
 
-	spin_unlock_irqrestore(&pfree_queue->lock, irqL);
+	spin_unlock_irqrestore(&pfree_queue->lock, flags);
 
 _func_exit_;
 
@@ -1841,7 +1675,7 @@ _func_exit_;
 
 struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv)
 {
-	long unsigned int irqL;
+	long unsigned int flags;
 	struct xmit_buf *pxmitbuf =  NULL;
 	struct list_head *plist, *phead;
 	struct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
@@ -1850,7 +1684,7 @@ _func_enter_;
 
 	/* DBG_8192D("+rtw_alloc_xmitbuf\n"); */
 
-	spin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);
+	spin_lock_irqsave(&pfree_xmitbuf_queue->lock, flags);
 
 	if (_rtw_queue_empty(pfree_xmitbuf_queue) == true) {
 		pxmitbuf = NULL;
@@ -1864,13 +1698,11 @@ _func_enter_;
 		rtw_list_delete(&(pxmitbuf->list));
 	}
 
-	if (pxmitbuf !=  NULL)
-	{
+	if (pxmitbuf !=  NULL) {
 		pxmitpriv->free_xmitbuf_cnt--;
 		#ifdef DBG_XMIT_BUF
-		DBG_8192D("DBG_XMIT_BUF ALLOC no=%d,  free_xmitbuf_cnt=%d\n",pxmitbuf->no, pxmitpriv->free_xmitbuf_cnt);
+		DBG_8192D("DBG_XMIT_BUF ALLOC no =%d,  free_xmitbuf_cnt =%d\n", pxmitbuf->no, pxmitpriv->free_xmitbuf_cnt);
 		#endif
-		/* DBG_8192D("alloc, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt); */
 
 		pxmitbuf->priv_data = NULL;
 
@@ -1880,13 +1712,12 @@ _func_enter_;
 		}
 	}
 	#ifdef DBG_XMIT_BUF
-	else
-	{
+	else {
 		DBG_8192D("DBG_XMIT_BUF rtw_alloc_xmitbuf return NULL\n");
 	}
 	#endif
 
-	spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);
+	spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, flags);
 
 _func_exit_;
 
@@ -1895,41 +1726,34 @@ _func_exit_;
 
 s32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
 {
-	long unsigned int irqL;
+	long unsigned int flags;
 	struct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
 
 _func_enter_;
 
-	/* DBG_8192D("+rtw_free_xmitbuf\n"); */
-
-	if (pxmitbuf==NULL)
-	{
+	if (pxmitbuf == NULL)
 		return _FAIL;
-	}
 
 	if (pxmitbuf->sctx) {
 		DBG_8192D("%s pxmitbuf->sctx is not NULL\n", __func__);
 		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_FREE);
 	}
 
-	if (pxmitbuf->ext_tag)
-	{
+	if (pxmitbuf->ext_tag) {
 		rtw_free_xmitbuf_ext(pxmitpriv, pxmitbuf);
-	}
-	else
-	{
-		spin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);
+	} else {
+		spin_lock_irqsave(&pfree_xmitbuf_queue->lock, flags);
 
 		rtw_list_delete(&pxmitbuf->list);
 
 		rtw_list_insert_tail(&(pxmitbuf->list), get_list_head(pfree_xmitbuf_queue));
 
 		pxmitpriv->free_xmitbuf_cnt++;
-		/* DBG_8192D("FREE, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt); */
+		/* DBG_8192D("FREE, free_xmitbuf_cnt =%d\n", pxmitpriv->free_xmitbuf_cnt); */
 		#ifdef DBG_XMIT_BUF
-		DBG_8192D("DBG_XMIT_BUF FREE no=%d, free_xmitbuf_cnt=%d\n",pxmitbuf->no ,pxmitpriv->free_xmitbuf_cnt);
+		DBG_8192D("DBG_XMIT_BUF FREE no =%d, free_xmitbuf_cnt =%d\n", pxmitbuf->no , pxmitpriv->free_xmitbuf_cnt);
 		#endif
-		spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, irqL);
+		spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, flags);
 	}
 
 _func_exit_;
@@ -1967,7 +1791,7 @@ _func_enter_;
 	spin_lock_bh(&pfree_xmit_queue->lock);
 
 	if (_rtw_queue_empty(pfree_xmit_queue) == true) {
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_alloc_xmitframe:%d\n", pxmitpriv->free_xmitframe_cnt));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_alloc_xmitframe:%d\n", pxmitpriv->free_xmitframe_cnt));
 		pxframe =  NULL;
 	} else {
 		phead = get_list_head(pfree_xmit_queue);
@@ -1979,11 +1803,10 @@ _func_enter_;
 		rtw_list_delete(&(pxframe->list));
 	}
 
-	if (pxframe !=  NULL)
-	{
+	if (pxframe !=  NULL) {
 		pxmitpriv->free_xmitframe_cnt--;
 
-		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_alloc_xmitframe():free_xmitframe_cnt=%d\n", pxmitpriv->free_xmitframe_cnt));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_alloc_xmitframe():free_xmitframe_cnt =%d\n", pxmitpriv->free_xmitframe_cnt));
 
 		pxframe->buf_addr = NULL;
 		pxframe->pxmitbuf = NULL;
@@ -2000,9 +1823,8 @@ _func_enter_;
 		pxframe->agg_num = 1;
 #endif
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
-		if (pxmitpriv->free_xmitframe_cnt==1)
-		{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35))
+		if (pxmitpriv->free_xmitframe_cnt == 1) {
 			if (!rtw_netif_queue_stopped(padapter->pnetdev))
 				rtw_netif_stop_queue(padapter->pnetdev);
 		}
@@ -2011,13 +1833,9 @@ _func_enter_;
 #ifdef CONFIG_XMIT_ACK
 		pxframe->ack_report = 0;
 #endif
-
 	}
-
 	spin_unlock_bh(&pfree_xmit_queue->lock);
-
 _func_exit_;
-
 	return pxframe;
 }
 
@@ -2030,7 +1848,7 @@ s32 rtw_free_xmitframe(struct xmit_priv
 _func_enter_;
 
 	if (pxmitframe == NULL) {
-		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("======rtw_free_xmitframe():pxmitframe==NULL!!!!!!!!!!\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("====== rtw_free_xmitframe():pxmitframe == NULL!!!!!!!!!!\n"));
 		goto exit;
 	}
 
@@ -2046,7 +1864,7 @@ _func_enter_;
 	rtw_list_insert_tail(&pxmitframe->list, get_list_head(pfree_xmit_queue));
 
 	pxmitpriv->free_xmitframe_cnt++;
-	RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("rtw_free_xmitframe():free_xmitframe_cnt=%d\n", pxmitpriv->free_xmitframe_cnt));
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("rtw_free_xmitframe():free_xmitframe_cnt =%d\n", pxmitpriv->free_xmitframe_cnt));
 
 	spin_unlock_bh(&pfree_xmit_queue->lock);
 
@@ -2073,14 +1891,10 @@ _func_enter_;
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
 
-	while (rtw_end_of_queue_search(phead, plist) == false)
-	{
+	while (rtw_end_of_queue_search(phead, plist) == false) {
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
-
 		plist = get_next(plist);
-
-		rtw_free_xmitframe(pxmitpriv,pxmitframe);
-
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
 	}
 	spin_unlock_bh(&(pframequeue->lock));
 
@@ -2089,11 +1903,9 @@ _func_exit_;
 
 s32 rtw_xmitframe_enqueue(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
 {
-	if (rtw_xmit_classifier(padapter, pxmitframe) == _FAIL)
-	{
+	if (rtw_xmit_classifier(padapter, pxmitframe) == _FAIL) {
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
 			 ("rtw_xmitframe_enqueue: drop xmit pkt for classifier fail\n"));
-/* 		pxmitframe->pkt = NULL; */
 		return _FAIL;
 	}
 
@@ -2106,13 +1918,12 @@ static struct xmit_frame *dequeue_one_xm
 						struct __queue *pframe_queue)
 {
 	struct list_head *xmitframe_plist, *xmitframe_phead;
-	struct	xmit_frame	*pxmitframe=NULL;
+	struct	xmit_frame	*pxmitframe = NULL;
 
 	xmitframe_phead = get_list_head(pframe_queue);
 	xmitframe_plist = get_next(xmitframe_phead);
 
-	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
-	{
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
 		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
 		xmitframe_plist = get_next(xmitframe_plist);
@@ -2120,17 +1931,13 @@ static struct xmit_frame *dequeue_one_xm
 		rtw_list_delete(&pxmitframe->list);
 
 		ptxservq->qcnt--;
-
-			break;
-
+		break;
 		pxmitframe = NULL;
-
 	}
-
 	return pxmitframe;
 }
 
-struct xmit_frame* rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i, int entry)
+struct xmit_frame *rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i, int entry)
 {
 	struct list_head *sta_plist, *sta_phead;
 	struct hw_xmit *phwxmit;
@@ -2145,8 +1952,7 @@ _func_enter_;
 
 	inx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;
 
-	if (pregpriv->wifi_spec==1)
-	{
+	if (pregpriv->wifi_spec == 1) {
 		int j, tmp, acirp_cnt[4];
 		/* entry indx: 0->vo, 1->vi, 2->be, 3->bk. */
 		acirp_cnt[0] = pxmitpriv->voq_cnt;
@@ -2154,12 +1960,9 @@ _func_enter_;
 		acirp_cnt[2] = pxmitpriv->beq_cnt;
 		acirp_cnt[3] = pxmitpriv->bkq_cnt;
 
-		for (i=0; i<4; i++)
-		{
-			for (j=i+1; j<4; j++)
-			{
-				if (acirp_cnt[j]<acirp_cnt[i])
-				{
+		for (i = 0; i < 4; i++) {
+			for (j = i+1; j < 4; j++) {
+				if (acirp_cnt[j] < acirp_cnt[i]) {
 					tmp = acirp_cnt[i];
 					acirp_cnt[i] = acirp_cnt[j];
 					acirp_cnt[j] = tmp;
@@ -2174,36 +1977,29 @@ _func_enter_;
 
 	spin_lock_bh(&pxmitpriv->lock);
 
-	for (i = 0; i < entry; i++)
-	{
+	for (i = 0; i < entry; i++) {
 		phwxmit = phwxmit_i + inx[i];
 
 		sta_phead = get_list_head(phwxmit->sta_queue);
 		sta_plist = get_next(sta_phead);
 
-		while ((rtw_end_of_queue_search(sta_phead, sta_plist)) == false)
-		{
-			ptxservq= LIST_CONTAINOR(sta_plist, struct tx_servq, tx_pending);
+		while ((rtw_end_of_queue_search(sta_phead, sta_plist)) == false) {
+			ptxservq = LIST_CONTAINOR(sta_plist, struct tx_servq, tx_pending);
 
 			pframe_queue = &ptxservq->sta_pending;
 
 			pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
 
-			if (pxmitframe)
-			{
+			if (pxmitframe) {
 				phwxmit->accnt--;
 
 				/* Remove sta node when there is no pending packets. */
 				if (_rtw_queue_empty(pframe_queue)) /* must be done after get_next and before break */
 					rtw_list_delete(&ptxservq->tx_pending);
-
 				goto exit;
 			}
-
 			sta_plist = get_next(sta_plist);
-
 		}
-
 	}
 
 exit:
@@ -2226,26 +2022,26 @@ _func_enter_;
 	case 2:
 		ptxservq = &(psta->sta_xmitpriv.bk_q);
 		*(ac) = 3;
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_get_sta_pending : BK\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : BK\n"));
 		break;
 	case 4:
 	case 5:
 		ptxservq = &(psta->sta_xmitpriv.vi_q);
 		*(ac) = 1;
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_get_sta_pending : VI\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : VI\n"));
 		break;
 	case 6:
 	case 7:
 		ptxservq = &(psta->sta_xmitpriv.vo_q);
 		*(ac) = 0;
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_get_sta_pending : VO\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : VO\n"));
 		break;
 	case 0:
 	case 3:
 	default:
 		ptxservq = &(psta->sta_xmitpriv.be_q);
 		*(ac) = 2;
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_get_sta_pending : BE\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : BE\n"));
 	break;
 	}
 _func_exit_;
@@ -2268,15 +2064,14 @@ s32 rtw_xmit_classifier(struct rtw_adapt
 
 _func_enter_;
 
-	if (pattrib->psta) {
+	if (pattrib->psta)
 		psta = pattrib->psta;
-	} else {
+	else
 		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
-	}
 
 	if (psta == NULL) {
 		res = _FAIL;
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("rtw_xmit_classifier: psta == NULL\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("rtw_xmit_classifier: psta == NULL\n"));
 		goto exit;
 	}
 
@@ -2304,56 +2099,22 @@ void rtw_alloc_hwxmits(struct rtw_adapte
 
 	pxmitpriv->hwxmit_entry = HWXMIT_ENTRY;
 
-	pxmitpriv->hwxmits = (struct hw_xmit *)rtw_zmalloc(sizeof (struct hw_xmit) * pxmitpriv->hwxmit_entry);
+	pxmitpriv->hwxmits = (struct hw_xmit *)rtw_zmalloc(sizeof(struct hw_xmit) * pxmitpriv->hwxmit_entry);
 
 	hwxmits = pxmitpriv->hwxmits;
 
-	if (pxmitpriv->hwxmit_entry == 5)
-	{
-		/* pxmitpriv->bmc_txqueue.head = 0; */
-		/* hwxmits[0] .phwtxqueue = &pxmitpriv->bmc_txqueue; */
+	if (pxmitpriv->hwxmit_entry == 5) {
 		hwxmits[0] .sta_queue = &pxmitpriv->bm_pending;
-
-		/* pxmitpriv->vo_txqueue.head = 0; */
-		/* hwxmits[1] .phwtxqueue = &pxmitpriv->vo_txqueue; */
 		hwxmits[1] .sta_queue = &pxmitpriv->vo_pending;
-
-		/* pxmitpriv->vi_txqueue.head = 0; */
-		/* hwxmits[2] .phwtxqueue = &pxmitpriv->vi_txqueue; */
 		hwxmits[2] .sta_queue = &pxmitpriv->vi_pending;
-
-		/* pxmitpriv->bk_txqueue.head = 0; */
-		/* hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue; */
 		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
-
-		/* pxmitpriv->be_txqueue.head = 0; */
-		/* hwxmits[4] .phwtxqueue = &pxmitpriv->be_txqueue; */
 		hwxmits[4] .sta_queue = &pxmitpriv->be_pending;
-
-	}
-	else if (pxmitpriv->hwxmit_entry == 4)
-	{
-		/* pxmitpriv->vo_txqueue.head = 0; */
-		/* hwxmits[0] .phwtxqueue = &pxmitpriv->vo_txqueue; */
+	} else if (pxmitpriv->hwxmit_entry == 4) {
 		hwxmits[0] .sta_queue = &pxmitpriv->vo_pending;
-
-		/* pxmitpriv->vi_txqueue.head = 0; */
-		/* hwxmits[1] .phwtxqueue = &pxmitpriv->vi_txqueue; */
 		hwxmits[1] .sta_queue = &pxmitpriv->vi_pending;
-
-		/* pxmitpriv->be_txqueue.head = 0; */
-		/* hwxmits[2] .phwtxqueue = &pxmitpriv->be_txqueue; */
 		hwxmits[2] .sta_queue = &pxmitpriv->be_pending;
-
-		/* pxmitpriv->bk_txqueue.head = 0; */
-		/* hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue; */
 		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
 	}
-	else
-	{
-
-	}
-
 }
 
 void rtw_free_hwxmits(struct rtw_adapter *padapter)
@@ -2370,12 +2131,7 @@ void rtw_init_hwxmits(struct hw_xmit *ph
 	int i;
 _func_enter_;
 	for (i = 0; i < entry; i++, phwxmit++)
-	{
-		/* _rtw_spinlock_init(&phwxmit->xmit_lock); */
-		/* INIT_LIST_HEAD(&phwxmit->pending); */
-		/* phwxmit->txcmdcnt = 0; */
 		phwxmit->accnt = 0;
-	}
 _func_exit_;
 }
 
@@ -2384,147 +2140,134 @@ int rtw_br_client_tx(struct rtw_adapter
 {
 	struct sk_buff *skb = *pskb;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
-	{
-		void dhcp_flag_bcast(struct rtw_adapter *priv, struct sk_buff *skb);
-		int res, is_vlan_tag=0, i, do_nat25=1;
-		unsigned short vlan_hdr=0;
-		void *br_port = NULL;
-
-		/* mac_clone_handle_frame(priv, skb); */
+	void dhcp_flag_bcast(struct rtw_adapter *priv, struct sk_buff *skb);
+	int res, is_vlan_tag = 0, i, do_nat25 = 1;
+	unsigned short vlan_hdr = 0;
+	void *br_port = NULL;
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-		br_port = padapter->pnetdev->br_port;
+	br_port = padapter->pnetdev->br_port;
 #else   /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
-		rcu_read_lock();
-		br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
-		rcu_read_unlock();
+	rcu_read_lock();
+	br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
+	rcu_read_unlock();
 #endif  /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
-		spin_lock_bh(&padapter->br_ext_lock);
-		if (	!(skb->data[0] & 1) &&
-				br_port &&
-				memcmp(skb->data+MACADDRLEN, padapter->br_mac, MACADDRLEN) &&
-				*((unsigned short *)(skb->data+MACADDRLEN*2)) != __constant_htons(ETH_P_8021Q) &&
-				*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP) &&
-				!memcmp(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN) && padapter->scdb_entry) {
-			memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
-			padapter->scdb_entry->ageing_timer = jiffies;
-			spin_unlock_bh(&padapter->br_ext_lock);
-		} else {
-			if (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_8021Q)) {
-				is_vlan_tag = 1;
-				vlan_hdr = *((unsigned short *)(skb->data+MACADDRLEN*2+2));
-				for (i=0; i<6; i++)
-					*((unsigned short *)(skb->data+MACADDRLEN*2+2-i*2)) = *((unsigned short *)(skb->data+MACADDRLEN*2-2-i*2));
-				skb_pull(skb, 4);
-			}
-			/* if SA == br_mac && skb== IP  => copy SIP to br_ip ?? why */
-			if (!memcmp(skb->data+MACADDRLEN, padapter->br_mac, MACADDRLEN) &&
-				(*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)))
-				memcpy(padapter->br_ip, skb->data+WLAN_ETHHDR_LEN+12, 4);
-
-			if (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)) {
-				if (memcmp(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN)) {
-					void *scdb_findEntry(struct rtw_adapter *priv, unsigned char *macaddr, unsigned char *ipAddr);
-
-					if ((padapter->scdb_entry = (struct nat25_network_db_entry *)scdb_findEntry(padapter,
-								skb->data+MACADDRLEN, skb->data+WLAN_ETHHDR_LEN+12)) != NULL) {
-						memcpy(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN);
-						memcpy(padapter->scdb_ip, skb->data+WLAN_ETHHDR_LEN+12, 4);
-						padapter->scdb_entry->ageing_timer = jiffies;
-						do_nat25 = 0;
-					}
+	spin_lock_bh(&padapter->br_ext_lock);
+	if (!(skb->data[0] & 1) && br_port &&
+	    memcmp(skb->data+MACADDRLEN, padapter->br_mac, MACADDRLEN) &&
+	    *((unsigned short *)(skb->data+MACADDRLEN*2)) != __constant_htons(ETH_P_8021Q) &&
+	    *((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP) &&
+	    !memcmp(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN) && padapter->scdb_entry) {
+		memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
+		padapter->scdb_entry->ageing_timer = jiffies;
+		spin_unlock_bh(&padapter->br_ext_lock);
+	} else {
+		if (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_8021Q)) {
+			is_vlan_tag = 1;
+			vlan_hdr = *((unsigned short *)(skb->data+MACADDRLEN*2+2));
+			for (i = 0; i < 6; i++)
+				*((unsigned short *)(skb->data+MACADDRLEN*2+2-i*2)) = *((unsigned short *)(skb->data+MACADDRLEN*2-2-i*2));
+			skb_pull(skb, 4);
+		}
+		/* if SA == br_mac && skb == IP  => copy SIP to br_ip ?? why */
+		if (!memcmp(skb->data+MACADDRLEN, padapter->br_mac, MACADDRLEN) &&
+		    (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)))
+			memcpy(padapter->br_ip, skb->data+WLAN_ETHHDR_LEN+12, 4);
+
+		if (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)) {
+			if (memcmp(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN)) {
+				void *scdb_findentry(struct rtw_adapter *priv, unsigned char *macaddr, unsigned char *ipaddr);
+
+				padapter->scdb_entry = (struct nat25_network_db_entry *)
+						       scdb_findentry(padapter,
+						       skb->data+MACADDRLEN,
+						       skb->data+WLAN_ETHHDR_LEN+12);
+				if (padapter->scdb_entry != NULL) {
+					memcpy(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN);
+					memcpy(padapter->scdb_ip, skb->data+WLAN_ETHHDR_LEN+12, 4);
+					padapter->scdb_entry->ageing_timer = jiffies;
+					do_nat25 = 0;
 				}
-				else {
-					if (padapter->scdb_entry) {
-						padapter->scdb_entry->ageing_timer = jiffies;
-						do_nat25 = 0;
-					}
-					else {
-						memset(padapter->scdb_mac, 0, MACADDRLEN);
-						memset(padapter->scdb_ip, 0, 4);
-					}
+			} else {
+				if (padapter->scdb_entry) {
+					padapter->scdb_entry->ageing_timer = jiffies;
+					do_nat25 = 0;
+				} else {
+					memset(padapter->scdb_mac, 0, MACADDRLEN);
+					memset(padapter->scdb_ip, 0, 4);
 				}
 			}
-			spin_unlock_bh(&padapter->br_ext_lock);
-			if (do_nat25)
-			{
-				int nat25_db_handle(struct rtw_adapter *priv, struct sk_buff *skb, int method);
-				if (nat25_db_handle(padapter, skb, NAT25_CHECK) == 0) {
-					struct sk_buff *newskb;
-
-					if (is_vlan_tag) {
-						skb_push(skb, 4);
-						for (i=0; i<6; i++)
-							*((unsigned short *)(skb->data+i*2)) = *((unsigned short *)(skb->data+4+i*2));
-						*((unsigned short *)(skb->data+MACADDRLEN*2)) = __constant_htons(ETH_P_8021Q);
-						*((unsigned short *)(skb->data+MACADDRLEN*2+2)) = vlan_hdr;
-					}
-
-					newskb = skb_copy(skb, GFP_ATOMIC);
-					if (newskb == NULL) {
-						/* priv->ext_stats.tx_drops++; */
-						ERR_8192D("TX DROP: skb_copy fail!\n");
-						/* goto stop_proc; */
-						return -1;
-					}
-					dev_kfree_skb_any(skb);
-
-					*pskb = skb = newskb;
-					if (is_vlan_tag) {
-						vlan_hdr = *((unsigned short *)(skb->data+MACADDRLEN*2+2));
-						for (i=0; i<6; i++)
-							*((unsigned short *)(skb->data+MACADDRLEN*2+2-i*2)) = *((unsigned short *)(skb->data+MACADDRLEN*2-2-i*2));
-						skb_pull(skb, 4);
-					}
+		}
+		spin_unlock_bh(&padapter->br_ext_lock);
+		if (do_nat25) {
+			int nat25_db_handle(struct rtw_adapter *priv, struct sk_buff *skb, int method);
+			if (nat25_db_handle(padapter, skb, NAT25_CHECK) == 0) {
+				struct sk_buff *newskb;
+
+				if (is_vlan_tag) {
+					skb_push(skb, 4);
+					for (i = 0; i < 6; i++)
+						*((unsigned short *)(skb->data+i*2)) = *((unsigned short *)(skb->data+4+i*2));
+					*((unsigned short *)(skb->data+MACADDRLEN*2)) = __constant_htons(ETH_P_8021Q);
+					*((unsigned short *)(skb->data+MACADDRLEN*2+2)) = vlan_hdr;
+				}
+
+				newskb = skb_copy(skb, GFP_ATOMIC);
+				if (newskb == NULL) {
+					ERR_8192D("TX DROP: skb_copy fail!\n");
+					return -1;
 				}
+				dev_kfree_skb_any(skb);
 
-				if (skb_is_nonlinear(skb))
-					ERR_8192D("%s(): skb_is_nonlinear!!\n", __func__);
+				*pskb = skb = newskb;
+				if (is_vlan_tag) {
+					vlan_hdr = *((unsigned short *)(skb->data+MACADDRLEN*2+2));
+					for (i = 0; i < 6; i++)
+						*((unsigned short *)(skb->data+MACADDRLEN*2+2-i*2)) = *((unsigned short *)(skb->data+MACADDRLEN*2-2-i*2));
+					skb_pull(skb, 4);
+				}
+			}
 
+			if (skb_is_nonlinear(skb))
+				ERR_8192D("%s(): skb_is_nonlinear!!\n", __func__);
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
-				res = skb_linearize(skb, GFP_ATOMIC);
+			res = skb_linearize(skb, GFP_ATOMIC);
 #else	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)) */
-				res = skb_linearize(skb);
+			res = skb_linearize(skb);
 #endif	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)) */
-				if (res < 0) {
-						ERR_8192D("TX DROP: skb_linearize fail!\n");
-						/* goto free_and_stop; */
-						return -1;
-				}
-
-				res = nat25_db_handle(padapter, skb, NAT25_INSERT);
-				if (res < 0) {
-					if (res == -2) {
-						/* priv->ext_stats.tx_drops++; */
-						ERR_8192D("TX DROP: nat25_db_handle fail!\n");
-						/* goto free_and_stop; */
-						return -1;
+			if (res < 0) {
+				ERR_8192D("TX DROP: skb_linearize fail!\n");
+				return -1;
+			}
 
-					}
-					return 0;
+			res = nat25_db_handle(padapter, skb, NAT25_INSERT);
+			if (res < 0) {
+				if (res == -2) {
+					ERR_8192D("TX DROP: nat25_db_handle fail!\n");
+					return -1;
 				}
+				return 0;
 			}
+		}
+		memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
 
-			memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
-
-			dhcp_flag_bcast(padapter, skb);
+		dhcp_flag_bcast(padapter, skb);
 
-			if (is_vlan_tag) {
-				skb_push(skb, 4);
-				for (i=0; i<6; i++)
-					*((unsigned short *)(skb->data+i*2)) = *((unsigned short *)(skb->data+4+i*2));
-				*((unsigned short *)(skb->data+MACADDRLEN*2)) = __constant_htons(ETH_P_8021Q);
-				*((unsigned short *)(skb->data+MACADDRLEN*2+2)) = vlan_hdr;
-			}
-		}
-		/*  check if SA is equal to our MAC */
-		if (memcmp(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN)) {
-			ERR_8192D("TX DROP: untransformed frame SA:%02X%02X%02X%02X%02X%02X!\n",
-				skb->data[6],skb->data[7],skb->data[8],skb->data[9],skb->data[10],skb->data[11]);
-			return -1;
+		if (is_vlan_tag) {
+			skb_push(skb, 4);
+			for (i = 0; i < 6; i++)
+				*((unsigned short *)(skb->data+i*2)) = *((unsigned short *)(skb->data+4+i*2));
+			*((unsigned short *)(skb->data+MACADDRLEN*2)) = __constant_htons(ETH_P_8021Q);
+			*((unsigned short *)(skb->data+MACADDRLEN*2+2)) = vlan_hdr;
 		}
 	}
+	/*  check if SA is equal to our MAC */
+	if (memcmp(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN)) {
+		ERR_8192D("TX DROP: untransformed frame SA:%02X%02X%02X%02X%02X%02X!\n",
+			  skb->data[6], skb->data[7], skb->data[8], skb->data[9], skb->data[10], skb->data[11]);
+		return -1;
+	}
 	return 0;
 }
 #endif	/*  CONFIG_BR_EXT */
@@ -2534,7 +2277,7 @@ static void do_queue_select(struct rtw_a
 	u8 qsel;
 
 	qsel = pattrib->priority;
-	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("### do_queue_select priority=%d ,qsel = %d\n",pattrib->priority ,qsel));
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("### do_queue_select priority =%d , qsel = %d\n", pattrib->priority , qsel));
 
 	pattrib->qsel = qsel;
 }
@@ -2549,15 +2292,12 @@ static void do_queue_select(struct rtw_a
  */
 s32 rtw_xmit(struct rtw_adapter *padapter, struct sk_buff **ppkt)
 {
-#ifdef CONFIG_AP_MODE
-#endif
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	struct xmit_frame *pxmitframe = NULL;
 #ifdef CONFIG_BR_EXT
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	void *br_port = NULL;
 #endif	/*  CONFIG_BR_EXT */
-
 	s32 res;
 
 	pxmitframe = rtw_alloc_xmitframe(pxmitpriv);
@@ -2579,11 +2319,9 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 	rcu_read_unlock();
 #endif  /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 
-	if (br_port	&& check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true)
-	{
+	if (br_port && check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) {
 		res = rtw_br_client_tx(padapter, ppkt);
-		if (res == -1)
-		{
+		if (res == -1) {
 			rtw_free_xmitframe(pxmitpriv, pxmitframe);
 			return -1;
 		}
@@ -2608,8 +2346,7 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 
 #if defined(CONFIG_AP_MODE) || defined(CONFIG_TDLS)
 	spin_lock_bh(&pxmitpriv->lock);
-	if (xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == true)
-	{
+	if (xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == true) {
 		spin_unlock_bh(&pxmitpriv->lock);
 		return 1;
 	}
@@ -2618,26 +2355,24 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 
 	if (rtw_hal_xmit(padapter, pxmitframe) == false)
 		return 1;
-
 	return 0;
 }
 
 #ifdef CONFIG_TDLS
 int xmitframe_enqueue_for_tdls_sleeping_sta(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
 {
-	int ret=false;
-
-	struct sta_info *ptdls_sta=NULL;
+	int ret = false;
+	struct sta_info *ptdls_sta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	int i;
 
-	ptdls_sta=rtw_get_stainfo(pstapriv, pattrib->dst);
-	if (ptdls_sta==NULL) {
+	ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
+	if (ptdls_sta == NULL) {
 		return ret;
 	} else if (ptdls_sta->tdls_sta_state&TDLS_LINKED_STATE) {
-		if (pattrib->triggered==1) {
+		if (pattrib->triggered == 1) {
 			ret = true;
 			return ret;
 		}
@@ -2653,39 +2388,34 @@ int xmitframe_enqueue_for_tdls_sleeping_
 			ptdls_sta->sleepq_ac_len++;
 
 			/* indicate 4-AC queue bit in TDLS peer traffic indication */
-			switch (pattrib->priority)
-			{
-				case 1:
-				case 2:
-					ptdls_sta->uapsd_bk = ptdls_sta->uapsd_bk | BIT(1);
-					break;
-				case 4:
-				case 5:
-					ptdls_sta->uapsd_vi = ptdls_sta->uapsd_vi | BIT(1);
-					break;
-				case 6:
-				case 7:
-					ptdls_sta->uapsd_vo = ptdls_sta->uapsd_vo | BIT(1);
-					break;
-				case 0:
-				case 3:
-				default:
-					ptdls_sta->uapsd_be = ptdls_sta->uapsd_be | BIT(1);
-					break;
+			switch (pattrib->priority) {
+			case 1:
+			case 2:
+				ptdls_sta->uapsd_bk = ptdls_sta->uapsd_bk | BIT(1);
+				break;
+			case 4:
+			case 5:
+				ptdls_sta->uapsd_vi = ptdls_sta->uapsd_vi | BIT(1);
+				break;
+			case 6:
+			case 7:
+				ptdls_sta->uapsd_vo = ptdls_sta->uapsd_vo | BIT(1);
+				break;
+			case 0:
+			case 3:
+			default:
+				ptdls_sta->uapsd_be = ptdls_sta->uapsd_be | BIT(1);
+				break;
 			}
 
-			if (ptdls_sta->sleepq_len==1)
-			{
+			if (ptdls_sta->sleepq_len == 1) {
 				/* transmit TDLS PTI via AP */
 				rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_SD_PTI);
 			}
 			ret = true;
-
 		}
-
 		spin_unlock_bh(&ptdls_sta->sleep_q.lock);
 	}
-
 	return ret;
 }
 #endif /* CONFIG_TDLS */
@@ -2694,8 +2424,8 @@ int xmitframe_enqueue_for_tdls_sleeping_
 
 int xmitframe_enqueue_for_sleeping_sta(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
 {
-	int ret=false;
-	struct sta_info *psta=NULL;
+	int ret = false;
+	struct sta_info *psta = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -2703,8 +2433,7 @@ int xmitframe_enqueue_for_sleeping_sta(s
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 
-	if (ptdlsinfo->setup_state == TDLS_LINKED_STATE)
-	{
+	if (ptdlsinfo->setup_state == TDLS_LINKED_STATE) {
 		ret = xmitframe_enqueue_for_tdls_sleeping_sta(padapter, pxmitframe);
 		return ret;
 	}
@@ -2714,37 +2443,22 @@ int xmitframe_enqueue_for_sleeping_sta(s
 	    return ret;
 
 	if (pattrib->psta)
-	{
 		psta = pattrib->psta;
-	}
 	else
-	{
-		psta=rtw_get_stainfo(pstapriv, pattrib->ra);
-	}
+		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
 
-	if (psta==NULL)
+	if (psta == NULL)
 		return ret;
 
-	if (pattrib->triggered==1)
-	{
-		/* DBG_8192D("directly xmit pspoll_triggered packet\n"); */
-
-		/* pattrib->triggered=0; */
-
+	if (pattrib->triggered == 1) {
 		if (bmcst)
 			pattrib->qsel = 0x11;/* HIQ */
-
-
 		return ret;
 	}
-
-
-	if (bmcst)
-	{
+	if (bmcst) {
 		spin_lock_bh(&psta->sleep_q.lock);
 
-		if (pstapriv->sta_dz_bitmap)/* if anyone sta is in ps mode */
-		{
+		if (pstapriv->sta_dz_bitmap) {/* if anyone sta is in ps mode */
 			rtw_list_delete(&pxmitframe->list);
 
 			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
@@ -2757,70 +2471,55 @@ int xmitframe_enqueue_for_sleeping_sta(s
 			update_beacon(padapter, _TIM_IE_, NULL, false);/* tx bc/mc packets after upate bcn */
 
 			ret = true;
-
 		}
-
 		spin_unlock_bh(&psta->sleep_q.lock);
-
 		return ret;
-
 	}
-
-
 	spin_lock_bh(&psta->sleep_q.lock);
+	if (psta->state&WIFI_SLEEP_STATE) {
+		u8 wmmps_ac = 0;
 
-	if (psta->state&WIFI_SLEEP_STATE)
-	{
-		u8 wmmps_ac=0;
-
-		if (pstapriv->sta_dz_bitmap&BIT(psta->aid))
-		{
+		if (pstapriv->sta_dz_bitmap&BIT(psta->aid)) {
 			rtw_list_delete(&pxmitframe->list);
 
 			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
 
 			psta->sleepq_len++;
 
-			switch (pattrib->priority)
-			{
-				case 1:
-				case 2:
-					wmmps_ac = psta->uapsd_bk&BIT(0);
-					break;
-				case 4:
-				case 5:
-					wmmps_ac = psta->uapsd_vi&BIT(0);
-					break;
-				case 6:
-				case 7:
-					wmmps_ac = psta->uapsd_vo&BIT(0);
-					break;
-				case 0:
-				case 3:
-				default:
-					wmmps_ac = psta->uapsd_be&BIT(0);
-					break;
+			switch (pattrib->priority) {
+			case 1:
+			case 2:
+				wmmps_ac = psta->uapsd_bk&BIT(0);
+				break;
+			case 4:
+			case 5:
+				wmmps_ac = psta->uapsd_vi&BIT(0);
+				break;
+			case 6:
+			case 7:
+				wmmps_ac = psta->uapsd_vo&BIT(0);
+				break;
+			case 0:
+			case 3:
+			default:
+				wmmps_ac = psta->uapsd_be&BIT(0);
+				break;
 			}
 
 			if (wmmps_ac)
 				psta->sleepq_ac_len++;
 
-			if (((psta->has_legacy_ac) && (!wmmps_ac)) ||((!psta->has_legacy_ac)&&(wmmps_ac)))
-			{
+			if (((psta->has_legacy_ac) && (!wmmps_ac)) || ((!psta->has_legacy_ac) && (wmmps_ac))) {
 				pstapriv->tim_bitmap |= BIT(psta->aid);
 
-				if (psta->sleepq_len==1)
-				{
+				if (psta->sleepq_len == 1)
 					update_beacon(padapter, _TIM_IE_, NULL, false);
-				}
 			}
 
 			ret = true;
 		}
 	}
-
 	spin_unlock_bh(&psta->sleep_q.lock);
-
 	return ret;
 }
 
@@ -2836,8 +2535,7 @@ static void dequeue_xmitframes_to_sleepi
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
 
-	while (rtw_end_of_queue_search(phead, plist) == false)
-	{
+	while (rtw_end_of_queue_search(phead, plist) == false) {
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 
 		plist = get_next(plist);
@@ -2865,7 +2563,6 @@ void stop_sta_xmit(struct rtw_adapter *p
 	/* for BC/MC Frames */
 	psta_bmc = rtw_get_bcmc_stainfo(padapter);
 
-
 	spin_lock_bh(&pxmitpriv->lock);
 
 	psta->state |= WIFI_SLEEP_STATE;
@@ -2873,39 +2570,24 @@ void stop_sta_xmit(struct rtw_adapter *p
 #ifdef CONFIG_TDLS
 	if (!(psta->tdls_sta_state & TDLS_LINKED_STATE))
 #endif /* CONFIG_TDLS */
-	pstapriv->sta_dz_bitmap |= BIT(psta->aid);
-
-
-
+		pstapriv->sta_dz_bitmap |= BIT(psta->aid);
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vo_q.sta_pending);
 	rtw_list_delete(&(pstaxmitpriv->vo_q.tx_pending));
-
-
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vi_q.sta_pending);
 	rtw_list_delete(&(pstaxmitpriv->vi_q.tx_pending));
-
-
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->be_q.sta_pending);
 	rtw_list_delete(&(pstaxmitpriv->be_q.tx_pending));
-
-
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->bk_q.sta_pending);
 	rtw_list_delete(&(pstaxmitpriv->bk_q.tx_pending));
 
 #ifdef CONFIG_TDLS
-	if (!(psta->tdls_sta_state & TDLS_LINKED_STATE))
-	{
-		if (psta_bmc != NULL)
-		{
+	if (!(psta->tdls_sta_state & TDLS_LINKED_STATE)) {
+		if (psta_bmc != NULL) {
 #endif /* CONFIG_TDLS */
-
-
-	/* for BC/MC Frames */
-	pstaxmitpriv = &psta_bmc->sta_xmitpriv;
-	dequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, &pstaxmitpriv->be_q.sta_pending);
-	rtw_list_delete(&(pstaxmitpriv->be_q.tx_pending));
-
-
+			/* for BC/MC Frames */
+			pstaxmitpriv = &psta_bmc->sta_xmitpriv;
+			dequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, &pstaxmitpriv->be_q.sta_pending);
+			rtw_list_delete(&(pstaxmitpriv->be_q.tx_pending));
 #ifdef CONFIG_TDLS
 		}
 	}
@@ -2915,10 +2597,10 @@ void stop_sta_xmit(struct rtw_adapter *p
 
 void wakeup_sta_to_xmit(struct rtw_adapter *padapter, struct sta_info *psta)
 {
-	u8 update_mask=0, wmmps_ac=0;
+	u8 update_mask = 0, wmmps_ac = 0;
 	struct sta_info *psta_bmc;
 	struct list_head *xmitframe_plist, *xmitframe_phead;
-	struct xmit_frame *pxmitframe=NULL;
+	struct xmit_frame *pxmitframe = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
 	spin_lock_bh(&psta->sleep_q.lock);
@@ -2926,51 +2608,45 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 	xmitframe_phead = get_list_head(&psta->sleep_q);
 	xmitframe_plist = get_next(xmitframe_phead);
 
-	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
-	{
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
 		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
 		xmitframe_plist = get_next(xmitframe_plist);
 
 		rtw_list_delete(&pxmitframe->list);
 
-		switch (pxmitframe->attrib.priority)
-		{
-			case 1:
-			case 2:
-				wmmps_ac = psta->uapsd_bk&BIT(1);
-				break;
-			case 4:
-			case 5:
-				wmmps_ac = psta->uapsd_vi&BIT(1);
-				break;
-			case 6:
-			case 7:
-				wmmps_ac = psta->uapsd_vo&BIT(1);
-				break;
-			case 0:
-			case 3:
-			default:
-				wmmps_ac = psta->uapsd_be&BIT(1);
-				break;
+		switch (pxmitframe->attrib.priority) {
+		case 1:
+		case 2:
+			wmmps_ac = psta->uapsd_bk&BIT(1);
+			break;
+		case 4:
+		case 5:
+			wmmps_ac = psta->uapsd_vi&BIT(1);
+			break;
+		case 6:
+		case 7:
+			wmmps_ac = psta->uapsd_vo&BIT(1);
+			break;
+		case 0:
+		case 3:
+		default:
+			wmmps_ac = psta->uapsd_be&BIT(1);
+			break;
 		}
 
 		psta->sleepq_len--;
-		if (psta->sleepq_len>0)
+		if (psta->sleepq_len > 0)
 			pxmitframe->attrib.mdata = 1;
 		else
 			pxmitframe->attrib.mdata = 0;
 
-		if (wmmps_ac)
-		{
+		if (wmmps_ac) {
 			psta->sleepq_ac_len--;
-			if (psta->sleepq_ac_len>0)
-			{
+			if (psta->sleepq_ac_len > 0) {
 				pxmitframe->attrib.mdata = 1;
 				pxmitframe->attrib.eosp = 0;
-			}
-			else
-			{
+			} else {
 				pxmitframe->attrib.mdata = 0;
 				pxmitframe->attrib.eosp = 1;
 			}
@@ -2982,14 +2658,10 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 		if (rtw_hal_xmit(padapter, pxmitframe) == true)
 			rtw_os_xmit_complete(padapter, pxmitframe);
 		spin_lock_bh(&psta->sleep_q.lock);
-
 	}
-
-	if (psta->sleepq_len==0)
-	{
+	if (psta->sleepq_len == 0) {
 #ifdef CONFIG_TDLS
-		if (psta->tdls_sta_state & TDLS_LINKED_STATE)
-		{
+		if (psta->tdls_sta_state & TDLS_LINKED_STATE) {
 			if (psta->state&WIFI_SLEEP_STATE)
 				psta->state ^= WIFI_SLEEP_STATE;
 
@@ -3004,8 +2676,7 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 		if (psta->state&WIFI_SLEEP_STATE)
 			psta->state ^= WIFI_SLEEP_STATE;
 
-		if (psta->state & WIFI_STA_ALIVE_CHK_STATE)
-		{
+		if (psta->state & WIFI_STA_ALIVE_CHK_STATE) {
 			psta->expire_to = pstapriv->expire_to;
 			psta->state ^= WIFI_STA_ALIVE_CHK_STATE;
 		}
@@ -3015,21 +2686,18 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 
 	spin_unlock_bh(&psta->sleep_q.lock);
 
-
 	/* for BC/MC Frames */
 	psta_bmc = rtw_get_bcmc_stainfo(padapter);
 	if (!psta_bmc)
 		return;
 
-	if ((pstapriv->sta_dz_bitmap&0xfffe) == 0x0)/* no any sta in ps mode */
-	{
+	if ((pstapriv->sta_dz_bitmap&0xfffe) == 0x0) { /* no any sta in ps mode */
 		spin_lock_bh(&psta_bmc->sleep_q.lock);
 
 		xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
 		xmitframe_plist = get_next(xmitframe_phead);
 
-		while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
-		{
+		while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
 			pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
 			xmitframe_plist = get_next(xmitframe_plist);
@@ -3037,101 +2705,71 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 			rtw_list_delete(&pxmitframe->list);
 
 			psta_bmc->sleepq_len--;
-			if (psta_bmc->sleepq_len>0)
+			if (psta_bmc->sleepq_len > 0)
 				pxmitframe->attrib.mdata = 1;
 			else
 				pxmitframe->attrib.mdata = 0;
-
-
 			pxmitframe->attrib.triggered = 1;
-
 			spin_unlock_bh(&psta_bmc->sleep_q.lock);
 			if (rtw_hal_xmit(padapter, pxmitframe) == true)
-			{
 				rtw_os_xmit_complete(padapter, pxmitframe);
-			}
 			spin_lock_bh(&psta_bmc->sleep_q.lock);
-
-
 		}
-
-		if (psta_bmc->sleepq_len==0)
-		{
+		if (psta_bmc->sleepq_len == 0) {
 			pstapriv->tim_bitmap &= ~BIT(0);
 			pstapriv->sta_dz_bitmap &= ~BIT(0);
-
-			/* DBG_8192D("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap); */
-			/* upate BCN for TIM IE */
-			/* update_BCNTIM(padapter); */
 			update_mask |= BIT(1);
 		}
-
 		spin_unlock_bh(&psta_bmc->sleep_q.lock);
-
 	}
-
-
 	if (update_mask)
-	{
-		/* update_BCNTIM(padapter); */
 		update_beacon(padapter, _TIM_IE_, NULL, false);
-	}
 }
 
 void xmit_delivery_enabled_frames(struct rtw_adapter *padapter, struct sta_info *psta)
 {
-	u8 wmmps_ac=0;
+	u8 wmmps_ac = 0;
 	struct list_head *xmitframe_plist, *xmitframe_phead;
-	struct xmit_frame *pxmitframe=NULL;
+	struct xmit_frame *pxmitframe = NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
 	spin_lock_bh(&psta->sleep_q.lock);
-
 	xmitframe_phead = get_list_head(&psta->sleep_q);
 	xmitframe_plist = get_next(xmitframe_phead);
 
-	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
-	{
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
 		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
 		xmitframe_plist = get_next(xmitframe_plist);
 
-		switch (pxmitframe->attrib.priority)
-		{
-			case 1:
-			case 2:
-				wmmps_ac = psta->uapsd_bk&BIT(1);
-				break;
-			case 4:
-			case 5:
-				wmmps_ac = psta->uapsd_vi&BIT(1);
-				break;
-			case 6:
-			case 7:
-				wmmps_ac = psta->uapsd_vo&BIT(1);
-				break;
-			case 0:
-			case 3:
-			default:
-				wmmps_ac = psta->uapsd_be&BIT(1);
-				break;
+		switch (pxmitframe->attrib.priority) {
+		case 1:
+		case 2:
+			wmmps_ac = psta->uapsd_bk&BIT(1);
+			break;
+		case 4:
+		case 5:
+			wmmps_ac = psta->uapsd_vi&BIT(1);
+			break;
+		case 6:
+		case 7:
+			wmmps_ac = psta->uapsd_vo&BIT(1);
+			break;
+		case 0:
+		case 3:
+		default:
+			wmmps_ac = psta->uapsd_be&BIT(1);
+			break;
 		}
-
 		if (!wmmps_ac)
 			continue;
-
 		rtw_list_delete(&pxmitframe->list);
-
 		psta->sleepq_len--;
 		psta->sleepq_ac_len--;
-
-		if (psta->sleepq_ac_len>0)
-		{
+		if (psta->sleepq_ac_len > 0) {
 			pxmitframe->attrib.mdata = 1;
 			pxmitframe->attrib.eosp = 0;
-		}
-		else
-		{
+		} else {
 			pxmitframe->attrib.mdata = 0;
 			pxmitframe->attrib.eosp = 1;
 		}
@@ -3139,39 +2777,29 @@ void xmit_delivery_enabled_frames(struct
 		pxmitframe->attrib.triggered = 1;
 
 		if (rtw_hal_xmit(padapter, pxmitframe) == true)
-		{
 			rtw_os_xmit_complete(padapter, pxmitframe);
-		}
 
-		if ((psta->sleepq_ac_len==0) && (!psta->has_legacy_ac) && (wmmps_ac))
-		{
+		if ((psta->sleepq_ac_len == 0) && (!psta->has_legacy_ac) && (wmmps_ac)) {
 #ifdef CONFIG_TDLS
-			if (psta->tdls_sta_state & TDLS_LINKED_STATE)
-			{
+			if (psta->tdls_sta_state & TDLS_LINKED_STATE) {
 				spin_unlock_bh(&psta->sleep_q.lock);
 				return;
 			}
 #endif /* CONFIG_TDLS */
 			pstapriv->tim_bitmap &= ~BIT(psta->aid);
 
-			/* DBG_8192D("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap); */
 			/* upate BCN for TIM IE */
-			/* update_BCNTIM(padapter); */
 			update_beacon(padapter, _TIM_IE_, NULL, false);
-			/* update_mask = BIT(0); */
 		}
-
 	}
-
 	spin_unlock_bh(&psta->sleep_q.lock);
 }
-
 #endif
 
 void rtw_sctx_init(struct submit_ctx *sctx, int timeout_ms)
 {
 	sctx->timeout_ms = timeout_ms;
-	sctx->submit_time= rtw_get_current_time();
+	sctx->submit_time = rtw_get_current_time();
 	init_completion(&sctx->done);
 	sctx->status = RTW_SCTX_SUBMITTED;
 }
@@ -3182,7 +2810,7 @@ int rtw_sctx_wait(struct submit_ctx *sct
 	unsigned long expire;
 	int status = 0;
 
-	expire= sctx->timeout_ms ? msecs_to_jiffies(sctx->timeout_ms) : MAX_SCHEDULE_TIMEOUT;
+	expire = sctx->timeout_ms ? msecs_to_jiffies(sctx->timeout_ms) : MAX_SCHEDULE_TIMEOUT;
 	if (!wait_for_completion_timeout(&sctx->done, expire)) {
 		/* timeout, do something?? */
 		status = RTW_SCTX_DONE_TIMEOUT;
@@ -3191,10 +2819,8 @@ int rtw_sctx_wait(struct submit_ctx *sct
 		status = sctx->status;
 	}
 
-	if (status == RTW_SCTX_DONE_SUCCESS) {
+	if (status == RTW_SCTX_DONE_SUCCESS)
 		ret = _SUCCESS;
-	}
-
 	return ret;
 }
 
@@ -3204,7 +2830,6 @@ bool rtw_sctx_chk_waring_status(int stat
 	case RTW_SCTX_DONE_UNKNOWN:
 	case RTW_SCTX_DONE_BUF_ALLOC:
 	case RTW_SCTX_DONE_BUF_FREE:
-
 	case RTW_SCTX_DONE_DRV_STOP:
 	case RTW_SCTX_DONE_DEV_REMOVE:
 		return true;
@@ -3257,7 +2882,6 @@ int rtw_ack_tx_polling(struct xmit_priv
 		c2h_evt_hdl(adapter, NULL, rtw_hal_c2h_id_filter_ccx(adapter));
 		if (pack_tx_ops->status != RTW_SCTX_SUBMITTED)
 			break;
-
 		if (adapter->bDriverStopped) {
 			pack_tx_ops->status = RTW_SCTX_DONE_DRV_STOP;
 			break;
@@ -3301,10 +2925,9 @@ void rtw_ack_tx_done(struct xmit_priv *p
 {
 	struct submit_ctx *pack_tx_ops = &pxmitpriv->ack_tx_ops;
 
-	if (pxmitpriv->ack_tx) {
+	if (pxmitpriv->ack_tx)
 		rtw_sctx_done_err(&pack_tx_ops, status);
-	} else {
+	else
 		DBG_8192D("%s ack_tx not set\n", __func__);
-	}
 }
 #endif /* CONFIG_XMIT_ACK */

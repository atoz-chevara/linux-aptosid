From 86357fefe206f08ae4cc21e6de33a03b5858caef Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Thu, 2 May 2013 13:27:31 -0500
Subject: [PATCH 102/210] Remove ERROR and CHECK from core/rtw_cmd.c

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_cmd.c        | 1660 ++++++++++++++++++++++---------------------------
 core/rtw_pwrctrl.c    |    6 +-
 include/rtw_cmd.h     |    8 +-
 include/rtw_pwrctrl.h |    4 +-
 4 files changed, 741 insertions(+), 937 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -28,15 +28,15 @@
 #include <rtw_byteorder.h>
 #ifdef CONFIG_BR_EXT
 #include <rtw_br_ext.h>
-#endif //CONFIG_BR_EXT
+#endif /* CONFIG_BR_EXT */
 /*
 Caller and the rtw_cmd_thread can protect cmd_q by spin_lock.
 No irqsave is necessary.
 */
 
-int	_rtw_init_cmd_priv (struct	cmd_priv *pcmdpriv)
+int _rtw_init_cmd_priv(struct cmd_priv *pcmdpriv)
 {
-	int res=_SUCCESS;
+	int res = _SUCCESS;
 
 _func_enter_;
 
@@ -50,23 +50,26 @@ _func_enter_;
 
 	pcmdpriv->cmd_allocated_buf = rtw_zmalloc(MAX_CMDSZ + CMDBUFF_ALIGN_SZ);
 
-	if (pcmdpriv->cmd_allocated_buf == NULL){
-		res= _FAIL;
+	if (pcmdpriv->cmd_allocated_buf == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
-	pcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ - ( (SIZE_PTR)(pcmdpriv->cmd_allocated_buf) & (CMDBUFF_ALIGN_SZ-1));
+	pcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ - ((SIZE_PTR)(pcmdpriv->cmd_allocated_buf) & (CMDBUFF_ALIGN_SZ-1));
 
 	pcmdpriv->rsp_allocated_buf = rtw_zmalloc(MAX_RSPSZ + 4);
 
-	if (pcmdpriv->rsp_allocated_buf == NULL){
-		res= _FAIL;
+	if (pcmdpriv->rsp_allocated_buf == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
-	pcmdpriv->rsp_buf = pcmdpriv->rsp_allocated_buf  +  4 - ( (SIZE_PTR)(pcmdpriv->rsp_allocated_buf) & 3);
+	pcmdpriv->rsp_buf = pcmdpriv->rsp_allocated_buf  +  4 -
+			    ((SIZE_PTR)(pcmdpriv->rsp_allocated_buf) & 3);
 
-	pcmdpriv->cmd_issued_cnt = pcmdpriv->cmd_done_cnt = pcmdpriv->rsp_cnt = 0;
+	pcmdpriv->cmd_issued_cnt = 0;
+	pcmdpriv->cmd_done_cnt = 0;
+	pcmdpriv->rsp_cnt = 0;
 
 exit:
 
@@ -79,7 +82,7 @@ static void c2h_wk_callback(_workitem *w
 #endif
 int _rtw_init_evt_priv(struct evt_priv *pevtpriv)
 {
-	int res=_SUCCESS;
+	int res = _SUCCESS;
 
 _func_enter_;
 
@@ -90,7 +93,7 @@ _func_enter_;
 	pevtpriv->cmdevt_parm = NULL;
 #endif
 
-	//allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf
+	/* allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf */
 	ATOMIC_SET(&pevtpriv->event_seq, 0);
 	pevtpriv->evt_done_cnt = 0;
 
@@ -100,8 +103,8 @@ _func_enter_;
 	_rtw_init_sema(&(pevtpriv->terminate_evtthread_sema), 0);
 
 	pevtpriv->evt_allocated_buf = rtw_zmalloc(MAX_EVTSZ + 4);
-	if (pevtpriv->evt_allocated_buf == NULL){
-		res= _FAIL;
+	if (pevtpriv->evt_allocated_buf == NULL) {
+		res = _FAIL;
 		goto exit;
 		}
 	pevtpriv->evt_buf = pevtpriv->evt_allocated_buf  +  4 - ((unsigned int)(pevtpriv->evt_allocated_buf) & 3);
@@ -110,7 +113,7 @@ _func_enter_;
 
 exit:
 
-#endif //end of CONFIG_EVENT_THREAD_MODE
+#endif /* end of CONFIG_EVENT_THREAD_MODE */
 
 #ifdef CONFIG_C2H_WK
 	_init_workitem(&pevtpriv->c2h_wk, c2h_wk_callback, NULL);
@@ -123,11 +126,11 @@ _func_exit_;
 	return res;
 }
 
-void _rtw_free_evt_priv (struct	evt_priv *pevtpriv)
+void _rtw_free_evt_priv(struct evt_priv *pevtpriv)
 {
 _func_enter_;
 
-	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("+_rtw_free_evt_priv \n"));
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("+_rtw_free_evt_priv\n"));
 
 #ifdef CONFIG_EVENT_THREAD_MODE
 	_rtw_free_sema(&(pevtpriv->evt_notify));
@@ -140,29 +143,26 @@ _func_enter_;
 
 #ifdef CONFIG_C2H_WK
 	_cancel_workitem_sync(&pevtpriv->c2h_wk);
-	while(pevtpriv->c2h_wk_alive)
+	while (pevtpriv->c2h_wk_alive)
 		rtw_msleep_os(10);
 
 	while (!rtw_cbuf_empty(pevtpriv->c2h_queue)) {
-		void *c2h;
-		if ((c2h = rtw_cbuf_pop(pevtpriv->c2h_queue)) != NULL
-			&& c2h != (void *)pevtpriv) {
+		void *c2h = rtw_cbuf_pop(pevtpriv->c2h_queue);
+		if (c2h != NULL && c2h != (void *)pevtpriv)
 			rtw_mfree(c2h, 16);
-		}
 	}
 #endif
 
-	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("-_rtw_free_evt_priv \n"));
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("-_rtw_free_evt_priv\n"));
 
 _func_exit_;
-
 }
 
-void _rtw_free_cmd_priv (struct	cmd_priv *pcmdpriv)
+void _rtw_free_cmd_priv(struct cmd_priv *pcmdpriv)
 {
 _func_enter_;
 
-	if(pcmdpriv){
+	if (pcmdpriv) {
 		_rtw_spinlock_free(&(pcmdpriv->cmd_queue.lock));
 		_rtw_free_sema(&(pcmdpriv->cmd_queue_sema));
 		_rtw_free_sema(&(pcmdpriv->terminate_cmdthread_sema));
@@ -188,18 +188,18 @@ ISR/Call-Back functions can't call this
 
 int	_rtw_enqueue_cmd(struct __queue *queue, struct cmd_obj *obj)
 {
-	long unsigned int irqL;
+	long unsigned int flags;
 
 _func_enter_;
 
 	if (obj == NULL)
 		goto exit;
 
-	spin_lock_irqsave(&queue->lock, irqL);
+	spin_lock_irqsave(&queue->lock, flags);
 
 	rtw_list_insert_tail(&obj->list, &queue->queue);
 
-	spin_unlock_irqrestore(&queue->lock, irqL);
+	spin_unlock_irqrestore(&queue->lock, flags);
 
 exit:
 
@@ -208,23 +208,22 @@ _func_exit_;
 	return _SUCCESS;
 }
 
-struct	cmd_obj	*_rtw_dequeue_cmd(struct __queue *queue)
+struct cmd_obj *_rtw_dequeue_cmd(struct __queue *queue)
 {
-	long unsigned int irqL;
+	long unsigned int flags;
 	struct cmd_obj *obj;
 
 _func_enter_;
 
-	spin_lock_irqsave(&queue->lock, irqL);
-	if (rtw_is_list_empty(&(queue->queue)))
+	spin_lock_irqsave(&queue->lock, flags);
+	if (rtw_is_list_empty(&(queue->queue))) {
 		obj = NULL;
-	else
-	{
+	} else {
 		obj = LIST_CONTAINOR(get_next(&(queue->queue)), struct cmd_obj, list);
 		rtw_list_delete(&obj->list);
 	}
 
-	spin_unlock_irqrestore(&queue->lock, irqL);
+	spin_unlock_irqrestore(&queue->lock, flags);
 
 _func_exit_;
 
@@ -235,12 +234,12 @@ u32	rtw_init_cmd_priv(struct cmd_priv *p
 {
 	u32	res;
 _func_enter_;
-	res = _rtw_init_cmd_priv (pcmdpriv);
+	res = _rtw_init_cmd_priv(pcmdpriv);
 _func_exit_;
 	return res;
 }
 
-u32	rtw_init_evt_priv (struct	evt_priv *pevtpriv)
+u32	rtw_init_evt_priv(struct evt_priv *pevtpriv)
 {
 	int	res;
 _func_enter_;
@@ -249,18 +248,18 @@ _func_exit_;
 	return res;
 }
 
-void rtw_free_evt_priv (struct	evt_priv *pevtpriv)
+void rtw_free_evt_priv(struct evt_priv *pevtpriv)
 {
 _func_enter_;
-	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("rtw_free_evt_priv\n"));
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("rtw_free_evt_priv\n"));
 	_rtw_free_evt_priv(pevtpriv);
 _func_exit_;
 }
 
-void rtw_free_cmd_priv (struct	cmd_priv *pcmdpriv)
+void rtw_free_cmd_priv(struct cmd_priv *pcmdpriv)
 {
 _func_enter_;
-	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("rtw_free_cmd_priv\n"));
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("rtw_free_cmd_priv\n"));
 	_rtw_free_cmd_priv(pcmdpriv);
 _func_exit_;
 }
@@ -268,32 +267,26 @@ _func_exit_;
 int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj);
 int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
 {
-	u8 bAllow = false; //set to true to allow enqueuing cmd when hw_init_completed is false
+	u8 allow = false; /* set to true to allow enqueuing cmd when hw_init_completed is false */
 
 	#ifdef SUPPORT_HW_RFOFF_DETECTED
-	//To decide allow or not
-	if(	(pcmdpriv->padapter->pwrctrlpriv.bHWPwrPindetect)
-		&&(!pcmdpriv->padapter->registrypriv.usbss_enable)
-	)
-	{
-		if(cmd_obj->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra) )
-		{
-			struct drvextra_cmd_parm	*pdrvextra_cmd_parm = (struct drvextra_cmd_parm	*)cmd_obj->parmbuf;
-			if(pdrvextra_cmd_parm->ec_id == POWER_SAVING_CTRL_WK_CID)
-				bAllow = true;
+	/* To decide allow or not */
+	if ((pcmdpriv->padapter->pwrctrlpriv.bHWPwrPindetect) &&
+	    (!pcmdpriv->padapter->registrypriv.usbss_enable)) {
+		if (cmd_obj->cmdcode == GEN_CMD_CODE(_SET_DRV_EXTRA)) {
+			struct drvextra_cmd_parm *pdrvextra_cmd_parm = (struct drvextra_cmd_parm	*)cmd_obj->parmbuf;
+			if (pdrvextra_cmd_parm->ec_id == POWER_SAVING_CTRL_WK_CID)
+				allow = true;
 		}
 	}
 	#endif
 
-	if(cmd_obj->cmdcode == GEN_CMD_CODE(_SetChannelPlan))
-		bAllow = true;
+	if (cmd_obj->cmdcode == GEN_CMD_CODE(_SetChannelPlan))
+		allow = true;
 
-	if( (pcmdpriv->padapter->hw_init_completed ==false && bAllow == false)
-		|| pcmdpriv->cmdthd_running== false	//com_thread not running
-	)
-	{
+	if ((pcmdpriv->padapter->hw_init_completed == false && allow == false) ||
+	    pcmdpriv->cmdthd_running == false)	/* com_thread not running */
 		return _FAIL;
-	}
 	return _SUCCESS;
 }
 
@@ -311,19 +304,20 @@ _func_enter_;
 	cmd_obj->padapter = padapter;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	//change pcmdpriv to primary's pcmdpriv
+	/* change pcmdpriv to primary's pcmdpriv */
 	if (padapter->adapter_type != PRIMARY_ADAPTER && padapter->pbuddy_adapter)
 		pcmdpriv = &(padapter->pbuddy_adapter->cmdpriv);
 #endif
 
-	if( _FAIL == (res=rtw_cmd_filter(pcmdpriv, cmd_obj)) ) {
+	res = rtw_cmd_filter(pcmdpriv, cmd_obj);
+	if (_FAIL == res) {
 		rtw_free_cmd_obj(cmd_obj);
 		goto exit;
 	}
 
 	res = _rtw_enqueue_cmd(&pcmdpriv->cmd_queue, cmd_obj);
 
-	if(res == _SUCCESS)
+	if (res == _SUCCESS)
 		_rtw_up_sema(&pcmdpriv->cmd_queue_sema);
 
 exit:
@@ -333,7 +327,7 @@ _func_exit_;
 	return res;
 }
 
-struct	cmd_obj	*rtw_dequeue_cmd(struct cmd_priv *pcmdpriv)
+struct cmd_obj *rtw_dequeue_cmd(struct cmd_priv *pcmdpriv)
 {
 	struct cmd_obj *cmd_obj;
 
@@ -345,11 +339,10 @@ _func_exit_;
 	return cmd_obj;
 }
 
-void rtw_cmd_clr_isr(struct	cmd_priv *pcmdpriv)
+void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv)
 {
 _func_enter_;
 	pcmdpriv->cmd_done_cnt++;
-	//_rtw_up_sema(&(pcmdpriv->cmd_done_sema));
 _func_exit_;
 }
 
@@ -357,23 +350,21 @@ void rtw_free_cmd_obj(struct cmd_obj *pc
 {
 _func_enter_;
 
-	if((pcmd->cmdcode!=_JoinBss_CMD_) &&(pcmd->cmdcode!= _CreateBss_CMD_))
-	{
-		//free parmbuf in cmd_obj
-		rtw_mfree((unsigned char*)pcmd->parmbuf, pcmd->cmdsz);
+	if ((pcmd->cmdcode != _JOINBSS_CMD_) &&
+	    (pcmd->cmdcode != _CreateBss_CMD_)) {
+		/* free parmbuf in cmd_obj */
+		rtw_mfree((unsigned char *)pcmd->parmbuf, pcmd->cmdsz);
 	}
 
-	if(pcmd->rsp!=NULL)
-	{
-		if(pcmd->rspsz!= 0)
-		{
-			//free rsp in cmd_obj
-			rtw_mfree((unsigned char*)pcmd->rsp, pcmd->rspsz);
+	if (pcmd->rsp != NULL) {
+		if (pcmd->rspsz != 0) {
+			/* free rsp in cmd_obj */
+			rtw_mfree((unsigned char *)pcmd->rsp, pcmd->rspsz);
 		}
 	}
 
-	//free cmd_obj
-	rtw_mfree((unsigned char*)pcmd, sizeof(struct cmd_obj));
+	/* free cmd_obj */
+	rtw_mfree((unsigned char *)pcmd, sizeof(struct cmd_obj));
 
 _func_exit_;
 }
@@ -383,7 +374,7 @@ int rtw_cmd_thread(void *context)
 	u8 ret;
 	struct cmd_obj *pcmd;
 	u8 *pcmdbuf, *prspbuf;
-	u8 (*cmd_hdl)(struct rtw_adapter *padapter, u8* pbuf);
+	u8 (*cmd_hdl)(struct rtw_adapter *padapter, u8 *pbuf);
 	void (*pcmd_callback)(struct rtw_adapter *dev, struct cmd_obj *pcmd);
 	struct rtw_adapter *padapter = (struct rtw_adapter *)context;
 	struct cmd_priv *pcmdpriv = &(padapter->cmdpriv);
@@ -395,69 +386,65 @@ _func_enter_;
 	pcmdbuf = pcmdpriv->cmd_buf;
 	prspbuf = pcmdpriv->rsp_buf;
 
-	pcmdpriv->cmdthd_running=true;
+	pcmdpriv->cmdthd_running = true;
 	_rtw_up_sema(&pcmdpriv->terminate_cmdthread_sema);
 
-	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("start r871x rtw_cmd_thread !!!!\n"));
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("start r871x rtw_cmd_thread !!!!\n"));
 
-	while(1)
-	{
+	while (1) {
 		if ((_rtw_down_sema(&(pcmdpriv->cmd_queue_sema))) == _FAIL)
 			break;
 
 #ifdef CONFIG_LPS_LCLK
 		if (rtw_register_cmd_alive(padapter) != _SUCCESS)
-		{
 			continue;
-		}
 #endif
 
 _next:
-		if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
-		{
+		if ((padapter->bDriverStopped == true) ||
+		    (padapter->bSurpriseRemoved == true)) {
 			DBG_8192D("###> rtw_cmd_thread break.................\n");
-			RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("rtw_cmd_thread:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+			RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_,
+				 ("rtw_cmd_thread:bDriverStopped(%d) OR bSurpriseRemoved(%d)",
+				 padapter->bDriverStopped,
+				 padapter->bSurpriseRemoved));
 			break;
 		}
 
-		if(!(pcmd = rtw_dequeue_cmd(pcmdpriv))) {
+		pcmd = rtw_dequeue_cmd(pcmdpriv);
+		if (!pcmd) {
 #ifdef CONFIG_LPS_LCLK
 			rtw_unregister_cmd_alive(padapter);
 #endif
 			continue;
 		}
 
-		if( _FAIL == rtw_cmd_filter(pcmdpriv, pcmd) )
-		{
+		if (_FAIL == rtw_cmd_filter(pcmdpriv, pcmd)) {
 			pcmd->res = H2C_DROPPED;
 			goto post_process;
 		}
 
-		if( _FAIL == rtw_cmd_filter(pcmdpriv, pcmd) ) {
+		if (_FAIL == rtw_cmd_filter(pcmdpriv, pcmd)) {
 			rtw_free_cmd_obj(pcmd);
 			continue;
 		}
 
 		pcmdpriv->cmd_issued_cnt++;
 
-		pcmd->cmdsz = _RND4((pcmd->cmdsz));//_RND4
+		pcmd->cmdsz = _RND4((pcmd->cmdsz));/* _RND4 */
 
 		_rtw_memcpy(pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);
 
-		if(pcmd->cmdcode <= (sizeof(wlancmds) /sizeof(struct cmd_hdl)))
-		{
+		if (pcmd->cmdcode <= (sizeof(wlancmds) / sizeof(struct cmd_hdl))) {
 			cmd_hdl = wlancmds[pcmd->cmdcode].h2cfuns;
 
-			if (cmd_hdl)
-			{
+			if (cmd_hdl) {
 				ret = cmd_hdl(pcmd->padapter, pcmdbuf);
 				pcmd->res = ret;
 			}
 
 			pcmdpriv->cmd_seq++;
-		}
-		else
-		{
+		} else {
 			pcmd->res = H2C_PARAMETERS_ERROR;
 		}
 
@@ -465,50 +452,42 @@ _next:
 
 post_process:
 
-		//call callback function for post-processed
-		if(pcmd->cmdcode <= (sizeof(rtw_cmd_callback) /sizeof(struct _cmd_callback)))
-		{
+		/* call callback function for post-processed */
+		if (pcmd->cmdcode <= (sizeof(rtw_cmd_callback) / sizeof(struct _cmd_callback))) {
 			pcmd_callback = rtw_cmd_callback[pcmd->cmdcode].callback;
-			if(pcmd_callback == NULL)
-			{
-				RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("mlme_cmd_hdl(): pcmd_callback=0x%p, cmdcode=0x%x\n", pcmd_callback, pcmd->cmdcode));
+			if (pcmd_callback == NULL) {
+				RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("mlme_cmd_hdl(): pcmd_callback = 0x%p, cmdcode = 0x%x\n", pcmd_callback, pcmd->cmdcode));
 				rtw_free_cmd_obj(pcmd);
-			}
-			else
-			{
-				//todo: !!! fill rsp_buf to pcmd->rsp if (pcmd->rsp!=NULL)
-				pcmd_callback(pcmd->padapter, pcmd);//need conider that free cmd_obj in rtw_cmd_callback
+			} else {
+				/* todo: !!! fill rsp_buf to pcmd->rsp if (pcmd->rsp!= NULL) */
+				pcmd_callback(pcmd->padapter, pcmd);/* need conider that free cmd_obj in rtw_cmd_callback */
 			}
 		}
 
 		flush_signals_thread();
 
 		goto _next;
-
 	}
-	pcmdpriv->cmdthd_running=false;
+	pcmdpriv->cmdthd_running = false;
 
 
-	// free all cmd_obj resources
-	do{
+	/*  free all cmd_obj resources */
+	do {
 		pcmd = rtw_dequeue_cmd(pcmdpriv);
-		if(pcmd==NULL)
+		if (pcmd == NULL)
 			break;
 
-		//DBG_8192D("%s: leaving... drop cmdcode:%u\n", __FUNCTION__, pcmd->cmdcode);
 
 		rtw_free_cmd_obj(pcmd);
-	}while(1);
+	} while (1);
 
 	_rtw_up_sema(&pcmdpriv->terminate_cmdthread_sema);
 
 _func_exit_;
 
 	thread_exit();
-
 }
 
-
 #ifdef CONFIG_EVENT_THREAD_MODE
 u32 rtw_enqueue_evt(struct evt_priv *pevtpriv, struct evt_obj *obj)
 {
@@ -530,8 +509,6 @@ _func_enter_;
 
 	spin_unlock_bh(&queue->lock);
 
-	//rtw_evt_notify_isr(pevtpriv);
-
 exit:
 
 _func_exit_;
@@ -541,16 +518,15 @@ _func_exit_;
 
 struct evt_obj *rtw_dequeue_evt(_queue *queue)
 {
-	struct	evt_obj	*pevtobj;
+	struct evt_obj *pevtobj;
 
 _func_enter_;
 
 	spin_lock_bh(&queue->lock);
 
-	if (rtw_is_list_empty(&(queue->queue)))
+	if (rtw_is_list_empty(&(queue->queue))) {
 		pevtobj = NULL;
-	else
-	{
+	} else {
 		pevtobj = LIST_CONTAINOR(get_next(&(queue->queue)), struct evt_obj, list);
 		rtw_list_delete(&pevtobj->list);
 	}
@@ -566,10 +542,10 @@ void rtw_free_evt_obj(struct evt_obj *pe
 {
 _func_enter_;
 
-	if(pevtobj->parmbuf)
-		rtw_mfree((unsigned char*)pevtobj->parmbuf, pevtobj->evtsz);
+	if (pevtobj->parmbuf)
+		rtw_mfree((unsigned char *)pevtobj->parmbuf, pevtobj->evtsz);
 
-	rtw_mfree((unsigned char*)pevtobj, sizeof(struct evt_obj));
+	rtw_mfree((unsigned char *)pevtobj, sizeof(struct evt_obj));
 
 _func_exit_;
 }
@@ -589,23 +565,23 @@ u8 rtw_setstandby_cmd(unsigned char  *ad
 */
 u8 rtw_setstandby_cmd(struct rtw_adapter *padapter, uint action)
 {
-	struct cmd_obj*			ph2c;
-	struct usb_suspend_parm*	psetusbsuspend;
-	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
+	struct cmd_obj *ph2c;
+	struct usb_suspend_parm *psetusbsuspend;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 
 	u8 ret = _SUCCESS;
 
 _func_enter_;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
 	if (ph2c == NULL) {
 		ret = _FAIL;
 		goto exit;
 	}
 
-	psetusbsuspend = (struct usb_suspend_parm*)rtw_zmalloc(sizeof(struct usb_suspend_parm));
+	psetusbsuspend = (struct usb_suspend_parm *)rtw_zmalloc(sizeof(struct usb_suspend_parm));
 	if (psetusbsuspend == NULL) {
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
 		ret = _FAIL;
 		goto exit;
 	}
@@ -632,15 +608,15 @@ u8 rtw_sitesurvey_cmd(struct rtw_adapter
 	struct rtw_ieee80211_channel *ch, int ch_num)
 {
 	u8 res = _FAIL;
-	struct cmd_obj		*ph2c;
-	struct sitesurvey_parm	*psurveyPara;
+	struct cmd_obj *ph2c;
+	struct sitesurvey_parm *psurveyPara;
 	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 
 _func_enter_;
 
 #ifdef CONFIG_LPS
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == true){
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
 		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SCAN, 1);
 	}
 #endif
@@ -649,15 +625,15 @@ _func_enter_;
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
 		p2p_ps_wk_cmd(padapter, P2P_PS_SCAN, 1);
 	}
-#endif // CONFIG_P2P_PS
+#endif /*  CONFIG_P2P_PS */
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
 	if (ph2c == NULL)
 		return _FAIL;
 
-	psurveyPara = (struct sitesurvey_parm*)rtw_zmalloc(sizeof(struct sitesurvey_parm));
+	psurveyPara = (struct sitesurvey_parm *)rtw_zmalloc(sizeof(struct sitesurvey_parm));
 	if (psurveyPara == NULL) {
-		rtw_mfree((unsigned char*) ph2c, sizeof(struct cmd_obj));
+		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
 		return _FAIL;
 	}
 
@@ -673,13 +649,13 @@ _func_enter_;
 	/* prepare ssid list */
 	if (ssid) {
 		int i;
-		for (i=0; i<ssid_num && i< RTW_SSID_SCAN_AMOUNT; i++) {
+		for (i = 0; i < ssid_num && i < RTW_SSID_SCAN_AMOUNT; i++) {
 			if (ssid[i].SsidLength) {
 				_rtw_memcpy(&psurveyPara->ssid[i], &ssid[i], sizeof(struct ndis_802_11_ssid));
 				psurveyPara->ssid_num++;
 				if (0)
 				DBG_8192D(FUNC_ADPT_FMT" ssid:(%s, %d)\n", FUNC_ADPT_ARG(padapter),
-					psurveyPara->ssid[i].Ssid, psurveyPara->ssid[i].SsidLength);
+					  psurveyPara->ssid[i].Ssid, psurveyPara->ssid[i].SsidLength);
 			}
 		}
 	}
@@ -687,13 +663,10 @@ _func_enter_;
 	/* prepare channel list */
 	if (ch) {
 		int i;
-		for (i=0; i<ch_num && i< RTW_CHANNEL_SCAN_AMOUNT; i++) {
+		for (i = 0; i < ch_num && i < RTW_CHANNEL_SCAN_AMOUNT; i++) {
 			if (ch[i].hw_value && !(ch[i].flags & RTW_IEEE80211_CHAN_DISABLED)) {
 				_rtw_memcpy(&psurveyPara->ch[i], &ch[i], sizeof(struct rtw_ieee80211_channel));
 				psurveyPara->ch_num++;
-				if (0)
-				DBG_8192D(FUNC_ADPT_FMT" ch:%u\n", FUNC_ADPT_ARG(padapter),
-					psurveyPara->ch[i].hw_value);
 			}
 		}
 	}
@@ -702,20 +675,19 @@ _func_enter_;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
-	if(res == _SUCCESS) {
-
+	if (res == _SUCCESS) {
 		pmlmepriv->scan_start_time = rtw_get_current_time();
 
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-		if((padapter->pbuddy_adapter->mlmeextpriv.mlmext_info.state&0x03) == WIFI_FW_AP_STATE)
-			_set_timer(&pmlmepriv->scan_to_timer, SURVEY_TO * ( 38 + ( 38 / RTW_SCAN_NUM_OF_CH ) * RTW_STAY_AP_CH_MILLISECOND ) + 1000 );
+		if ((padapter->pbuddy_adapter->mlmeextpriv.mlmext_info.state&0x03) == WIFI_FW_AP_STATE)
+			_set_timer(&pmlmepriv->scan_to_timer, SURVEY_TO * (38 + (38 / RTW_SCAN_NUM_OF_CH) * RTW_STAY_AP_CH_MILLISECOND) + 1000);
 		else
-#endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
 			_set_timer(&pmlmepriv->scan_to_timer, SCANNING_TIMEOUT);
 
 		rtw_led_control(padapter, LED_CTL_SITE_SURVEY);
 
-		pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
+		pmlmepriv->scan_interval = SCAN_INTERVAL;/*  30*2 sec = 60sec */
 	} else {
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 	}
@@ -727,30 +699,29 @@ _func_exit_;
 
 u8 rtw_setdatarate_cmd(struct rtw_adapter *padapter, u8 *rateset)
 {
-	struct cmd_obj*			ph2c;
-	struct setdatarate_parm*	pbsetdataratepara;
-	struct cmd_priv*		pcmdpriv = &padapter->cmdpriv;
-	u8	res = _SUCCESS;
+	struct cmd_obj *ph2c;
+	struct setdatarate_parm *pbsetdataratepara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	pbsetdataratepara = (struct setdatarate_parm*)rtw_zmalloc(sizeof(struct setdatarate_parm));
+	pbsetdataratepara = (struct setdatarate_parm *)rtw_zmalloc(sizeof(struct setdatarate_parm));
 	if (pbsetdataratepara == NULL) {
-		rtw_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
 		res = _FAIL;
 		goto exit;
 	}
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, pbsetdataratepara, GEN_CMD_CODE(_SetDataRate));
 #ifdef MP_FIRMWARE_OFFLOAD
-	pbsetdataratepara->curr_rateidx = *(u32*)rateset;
-//	_rtw_memcpy(pbsetdataratepara, rateset, sizeof(u32));
+	pbsetdataratepara->curr_rateidx = *(u32 *)rateset;
 #else
 	pbsetdataratepara->mac_id = 5;
 	_rtw_memcpy(pbsetdataratepara->datarates, rateset, NumRates);
@@ -765,22 +736,22 @@ _func_exit_;
 
 u8 rtw_setbasicrate_cmd(struct rtw_adapter *padapter, u8 *rateset)
 {
-	struct cmd_obj*			ph2c;
-	struct setbasicrate_parm*	pssetbasicratepara;
-	struct cmd_priv*		pcmdpriv=&padapter->cmdpriv;
-	u8	res = _SUCCESS;
+	struct cmd_obj *ph2c;
+	struct setbasicrate_parm *pssetbasicratepara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
 	if (ph2c == NULL) {
-		res= _FAIL;
+		res = _FAIL;
 		goto exit;
 	}
-	pssetbasicratepara = (struct setbasicrate_parm*)rtw_zmalloc(sizeof(struct setbasicrate_parm));
+	pssetbasicratepara = (struct setbasicrate_parm *)rtw_zmalloc(sizeof(struct setbasicrate_parm));
 
 	if (pssetbasicratepara == NULL) {
-		rtw_mfree((u8*) ph2c, sizeof(struct cmd_obj));
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
 		res = _FAIL;
 		goto exit;
 	}
@@ -801,37 +772,35 @@ _func_exit_;
 /*
 unsigned char rtw_setphy_cmd(unsigned char  *adapter)
 
-1.  be called only after rtw_update_registrypriv_dev_network( ~) or mp testing program
+1.  be called only after rtw_update_registrypriv_dev_network(~) or mp testing program
 2.  for AdHoc/Ap mode or mp mode?
 
 */
 u8 rtw_setphy_cmd(struct rtw_adapter *padapter, u8 modem, u8 ch)
 {
-	struct cmd_obj*			ph2c;
-	struct setphy_parm*		psetphypara;
-	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
-//	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
-//	struct registry_priv*		pregistry_priv = &padapter->registrypriv;
-	u8	res=_SUCCESS;
+	struct cmd_obj *ph2c;
+	struct setphy_parm *psetphypara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 		}
-	psetphypara = (struct setphy_parm*)rtw_zmalloc(sizeof(struct setphy_parm));
+	psetphypara = (struct setphy_parm *)rtw_zmalloc(sizeof(struct setphy_parm));
 
-	if(psetphypara==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
+	if (psetphypara == NULL) {
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
 		goto exit;
 	}
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, psetphypara, _SetPhy_CMD_);
 
-	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("CH=%d, modem=%d", ch, modem));
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("CH =%d, modem =%d", ch, modem));
 
 	psetphypara->modem = modem;
 	psetphypara->rfchannel = ch;
@@ -842,23 +811,23 @@ _func_exit_;
 	return res;
 }
 
-u8 rtw_setbbreg_cmd(struct rtw_adapter*padapter, u8 offset, u8 val)
+u8 rtw_setbbreg_cmd(struct rtw_adapter *padapter, u8 offset, u8 val)
 {
-	struct cmd_obj*			ph2c;
-	struct writeBB_parm*		pwritebbparm;
-	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
+	struct cmd_obj *ph2c;
+	struct writeBB_parm *pwritebbparm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
 _func_enter_;
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 		}
-	pwritebbparm = (struct writeBB_parm*)rtw_zmalloc(sizeof(struct writeBB_parm));
+	pwritebbparm = (struct writeBB_parm *)rtw_zmalloc(sizeof(struct writeBB_parm));
 
-	if(pwritebbparm==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
+	if (pwritebbparm == NULL) {
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
 		goto exit;
 	}
 
@@ -875,32 +844,32 @@ _func_exit_;
 
 u8 rtw_getbbreg_cmd(struct rtw_adapter *padapter, u8 offset, u8 *pval)
 {
-	struct cmd_obj*			ph2c;
-	struct readBB_parm*		prdbbparm;
-	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
+	struct cmd_obj *ph2c;
+	struct readBB_parm *prdbbparm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
 
 _func_enter_;
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res=_FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 		}
-	prdbbparm = (struct readBB_parm*)rtw_zmalloc(sizeof(struct readBB_parm));
+	prdbbparm = (struct readBB_parm *)rtw_zmalloc(sizeof(struct readBB_parm));
 
-	if(prdbbparm ==NULL){
-		rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
+	if (prdbbparm == NULL) {
+		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
 		return _FAIL;
 	}
 
 	_rtw_init_listhead(&ph2c->list);
-	ph2c->cmdcode =GEN_CMD_CODE(_GetBBReg);
+	ph2c->cmdcode = GEN_CMD_CODE(_GetBBReg);
 	ph2c->parmbuf = (unsigned char *)prdbbparm;
 	ph2c->cmdsz =  sizeof(struct readBB_parm);
 	ph2c->rsp = pval;
 	ph2c->rspsz = sizeof(struct readBB_rsp);
 
-	prdbbparm ->offset = offset;
+	prdbbparm->offset = offset;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
@@ -910,21 +879,21 @@ _func_exit_;
 
 u8 rtw_setrfreg_cmd(struct rtw_adapter *padapter, u8 offset, u32 val)
 {
-	struct cmd_obj*			ph2c;
-	struct writeRF_parm*		pwriterfparm;
-	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
+	struct cmd_obj *ph2c;
+	struct writeRF_parm *pwriterfparm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
 _func_enter_;
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
-	pwriterfparm = (struct writeRF_parm*)rtw_zmalloc(sizeof(struct writeRF_parm));
+	pwriterfparm = (struct writeRF_parm *)rtw_zmalloc(sizeof(struct writeRF_parm));
 
-	if(pwriterfparm==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
+	if (pwriterfparm == NULL) {
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
 		goto exit;
 	}
 
@@ -941,34 +910,34 @@ _func_exit_;
 
 u8 rtw_getrfreg_cmd(struct rtw_adapter *padapter, u8 offset, u8 *pval)
 {
-	struct cmd_obj*			ph2c;
-	struct readRF_parm*		prdrfparm;
-	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
+	struct cmd_obj *ph2c;
+	struct readRF_parm *prdrfparm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
-	prdrfparm = (struct readRF_parm*)rtw_zmalloc(sizeof(struct readRF_parm));
-	if(prdrfparm ==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
+	prdrfparm = (struct readRF_parm *)rtw_zmalloc(sizeof(struct readRF_parm));
+	if (prdrfparm == NULL) {
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
 		goto exit;
 	}
 
 	_rtw_init_listhead(&ph2c->list);
-	ph2c->cmdcode =GEN_CMD_CODE(_GetRFReg);
+	ph2c->cmdcode = GEN_CMD_CODE(_GetRFReg);
 	ph2c->parmbuf = (unsigned char *)prdrfparm;
 	ph2c->cmdsz =  sizeof(struct readRF_parm);
 	ph2c->rsp = pval;
 	ph2c->rspsz = sizeof(struct readRF_rsp);
 
-	prdrfparm ->offset = offset;
+	prdrfparm->offset = offset;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
@@ -983,12 +952,11 @@ void rtw_getbbrfreg_cmdrsp_callback(stru
 {
  _func_enter_;
 
-	//rtw_free_cmd_obj(pcmd);
-	rtw_mfree((unsigned char*) pcmd->parmbuf, pcmd->cmdsz);
-	rtw_mfree((unsigned char*) pcmd, sizeof(struct cmd_obj));
+	rtw_mfree((unsigned char *)pcmd->parmbuf, pcmd->cmdsz);
+	rtw_mfree((unsigned char *)pcmd, sizeof(struct cmd_obj));
 
 #ifdef CONFIG_MP_INCLUDED
-	padapter->mppriv.workparam.bcompleted= true;
+	padapter->mppriv.workparam.bcompleted = true;
 #endif
 _func_exit_;
 }
@@ -997,11 +965,11 @@ void rtw_readtssi_cmdrsp_callback(struct
 {
  _func_enter_;
 
-	rtw_mfree((unsigned char*) pcmd->parmbuf, pcmd->cmdsz);
-	rtw_mfree((unsigned char*) pcmd, sizeof(struct cmd_obj));
+	rtw_mfree((unsigned char *)pcmd->parmbuf, pcmd->cmdsz);
+	rtw_mfree((unsigned char *)pcmd, sizeof(struct cmd_obj));
 
 #ifdef CONFIG_MP_INCLUDED
-	padapter->mppriv.workparam.bcompleted= true;
+	padapter->mppriv.workparam.bcompleted = true;
 #endif
 
 _func_exit_;
@@ -1009,32 +977,32 @@ _func_exit_;
 
 u8 rtw_createbss_cmd(struct rtw_adapter *padapter)
 {
-	struct cmd_obj*			pcmd;
-	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
-	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
+	struct cmd_obj *pcmd;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct wlan_bssid_ex *pdev_network = &padapter->registrypriv.dev_network;
-	u8	res=_SUCCESS;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
 	rtw_led_control(padapter, LED_CTL_START_TO_LINK);
 
-	if (pmlmepriv->assoc_ssid.SsidLength == 0){
-		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,(" createbss for Any SSid:%s\n",pmlmepriv->assoc_ssid.Ssid));
+	if (pmlmepriv->assoc_ssid.SsidLength == 0) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, (" createbss for Any SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
 	} else {
-		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,(" createbss for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, (" createbss for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
 	}
 
-	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(pcmd==NULL){
-		res= _FAIL;
+	pcmd = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
 	_rtw_init_listhead(&pcmd->list);
 	pcmd->cmdcode = _CreateBss_CMD_;
 	pcmd->parmbuf = (unsigned char *)pdev_network;
-	pcmd->cmdsz = get_wlan_bssid_ex_sz((struct wlan_bssid_ex*)pdev_network);
+	pcmd->cmdsz = get_wlan_bssid_ex_sz((struct wlan_bssid_ex *)pdev_network);
 	pcmd->rsp = NULL;
 	pcmd->rspsz = 0;
 
@@ -1048,15 +1016,15 @@ _func_exit_;
 
 u8 rtw_createbss_cmd_ex(struct rtw_adapter *padapter, unsigned char *pbss, unsigned int sz)
 {
-	struct cmd_obj*	pcmd;
-	struct cmd_priv		*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
+	struct cmd_obj *pcmd;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(pcmd==NULL){
-		res= _FAIL;
+	pcmd = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
@@ -1076,16 +1044,16 @@ _func_exit_;
 	return res;
 }
 
-u8 rtw_joinbss_cmd(struct rtw_adapter *padapter, struct wlan_network* pnetwork)
+u8 rtw_joinbss_cmd(struct rtw_adapter *padapter, struct wlan_network *pnetwork)
 {
-	u8	*auth, res = _SUCCESS;
+	u8 *auth, res = _SUCCESS;
 	uint	t_len = 0;
 	struct wlan_bssid_ex	*psecnetwork;
-	struct cmd_obj		*pcmd;
-	struct cmd_priv		*pcmdpriv=&padapter->cmdpriv;
+	struct cmd_obj *pcmd;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-	struct qos_priv		*pqospriv= &pmlmepriv->qospriv;
-	struct security_priv	*psecuritypriv=&padapter->securitypriv;
+	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
 	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
 	enum NDIS_802_11_NETWORK_INFRASTRUCTURE ndis_network_mode = pnetwork->network.InfrastructureMode;
@@ -1096,60 +1064,46 @@ _func_enter_;
 
 	rtw_led_control(padapter, LED_CTL_START_TO_LINK);
 
-	if (pmlmepriv->assoc_ssid.SsidLength == 0){
+	if (pmlmepriv->assoc_ssid.SsidLength == 0) {
 		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("+Join cmd: Any SSid\n"));
 	} else {
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+Join cmd: SSid=[%s]\n", pmlmepriv->assoc_ssid.Ssid));
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+Join cmd: SSid =[%s]\n", pmlmepriv->assoc_ssid.Ssid));
 	}
 
-	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(pcmd==NULL){
-		res=_FAIL;
+	pcmd = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		res = _FAIL;
 		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd: memory allocate for cmd_obj fail!!!\n"));
 		goto exit;
 	}
-	/* // for IEs is pointer
-	t_len = sizeof (u32) + sizeof (NDIS_802_11_MAC_ADDRESS) + 2 +
-			sizeof (struct ndis_802_11_ssid) + sizeof (u32) +
-			sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) +
-			sizeof (NDIS_802_11_CONFIGURATION) +
-			sizeof (NDIS_802_11_NETWORK_INFRASTRUCTURE) +
-			sizeof (NDIS_802_11_RATES_EX)+ sizeof(WLAN_PHY_INFO)+ sizeof (u32) + MAX_IE_SZ;
-	*/
-	//for IEs is fix buf size
+	/* for IEs is fix buf size */
 	t_len = sizeof(struct wlan_bssid_ex);
 
 
-	//for hidden ap to set fw_state here
-	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) != true)
-	{
-		switch(ndis_network_mode)
-		{
-			case NDIS802_11IBSS:
-				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
-				break;
-
-			case NDIS802_11INFRA:
-				set_fwstate(pmlmepriv, WIFI_STATION_STATE);
-				break;
-
-			case NDIS802_11APMODE:
-			case NDIS802_11AUTOUNK:
-			case NDIS802_11INFRA_MAX:
-				break;
-
+	/* for hidden ap to set fw_state here */
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) != true) {
+		switch (ndis_network_mode) {
+		case NDIS802_11IBSS:
+			set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			break;
+		case NDIS802_11INFRA:
+			set_fwstate(pmlmepriv, WIFI_STATION_STATE);
+			break;
+		case NDIS802_11APMODE:
+		case NDIS802_11AUTOUNK:
+		case NDIS802_11INFRA_MAX:
+			break;
 		}
 	}
 
-	psecnetwork=(struct wlan_bssid_ex *)&psecuritypriv->sec_bss;
-	if(psecnetwork==NULL)
-	{
-		if(pcmd !=NULL)
-			rtw_mfree((unsigned char *)pcmd, sizeof(struct	cmd_obj));
+	psecnetwork = (struct wlan_bssid_ex *)&psecuritypriv->sec_bss;
+	if (psecnetwork == NULL) {
+		if (pcmd != NULL)
+			rtw_mfree((unsigned char *)pcmd, sizeof(struct cmd_obj));
 
-		res=_FAIL;
+		res = _FAIL;
 
-		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd :psecnetwork==NULL!!!\n"));
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd :psecnetwork == NULL!!!\n"));
 
 		goto exit;
 	}
@@ -1158,62 +1112,57 @@ _func_enter_;
 
 	_rtw_memcpy(psecnetwork, &pnetwork->network, get_wlan_bssid_ex_sz(&pnetwork->network));
 
-	auth=&psecuritypriv->authenticator_ie[0];
-	psecuritypriv->authenticator_ie[0]=(unsigned char)psecnetwork->IELength;
+	auth = &psecuritypriv->authenticator_ie[0];
+	psecuritypriv->authenticator_ie[0] = (unsigned char)psecnetwork->IELength;
 
-	if((psecnetwork->IELength-12) < (256-1)) {
+	if ((psecnetwork->IELength-12) < (256-1)) {
 		_rtw_memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], psecnetwork->IELength-12);
 	} else {
 		_rtw_memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], (256-1));
 	}
 
 	psecnetwork->IELength = 0;
-	// Added by Albert 2009/02/18
-	// If the the driver wants to use the bssid to create the connection.
-	// If not,  we have to copy the connecting AP's MAC address to it so that
-	// the driver just has the bssid information for PMKIDList searching.
-
-	if ( pmlmepriv->assoc_by_bssid == false )
-	{
-		_rtw_memcpy( &pmlmepriv->assoc_bssid[ 0 ], &pnetwork->network.MacAddress[ 0 ], ETH_ALEN );
-	}
+	/*  Added by Albert 2009/02/18 */
+	/*  If the the driver wants to use the bssid to create the connection. */
+	/*  If not,  we have to copy the connecting AP's MAC address to it so that */
+	/*  the driver just has the bssid information for PMKIDList searching. */
+
+	if (pmlmepriv->assoc_by_bssid == false)
+		_rtw_memcpy(&pmlmepriv->assoc_bssid[0], &pnetwork->network.MacAddress[0], ETH_ALEN);
 
 	psecnetwork->IELength = rtw_restruct_sec_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength);
 
 
 	pqospriv->qos_option = 0;
 
-	if(pregistrypriv->wmm_enable)
-	{
+	if (pregistrypriv->wmm_enable) {
 		u32 tmp_len;
 
 		tmp_len = rtw_restruct_wmm_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength, psecnetwork->IELength);
 
-		if (psecnetwork->IELength != tmp_len)
-		{
+		if (psecnetwork->IELength != tmp_len) {
 			psecnetwork->IELength = tmp_len;
-			pqospriv->qos_option = 1; //There is WMM IE in this corresp. beacon
-		}
-		else
-		{
-			pqospriv->qos_option = 0;//There is no WMM IE in this corresp. beacon
+			pqospriv->qos_option = 1; /* There is WMM IE in this corresp. beacon */
+		} else {
+			pqospriv->qos_option = 0;/* There is no WMM IE in this corresp. beacon */
 		}
 	}
 
 #ifdef CONFIG_80211N_HT
 	phtpriv->ht_option = false;
-	if(pregistrypriv->ht_enable)
-	{
-		//	Added by Albert 2010/06/23
-		//	For the WEP mode, we will use the bg mode to do the connection to avoid some IOT issue.
-		//	Especially for Realtek 8192u SoftAP.
-		if (	( padapter->securitypriv.dot11PrivacyAlgrthm != _WEP40_ ) &&
-			( padapter->securitypriv.dot11PrivacyAlgrthm != _WEP104_ ) &&
-			( padapter->securitypriv.dot11PrivacyAlgrthm != _TKIP_ ))
-		{
-			//rtw_restructure_ht_ie
-			rtw_restructure_ht_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0],
-									pnetwork->network.IELength, &psecnetwork->IELength, (u8)psecnetwork->Configuration.DSConfig );
+	if (pregistrypriv->ht_enable) {
+		/*	Added by Albert 2010/06/23 */
+		/*	For the WEP mode, we will use the bg mode to do the connection to avoid some IOT issue. */
+		/*	Especially for Realtek 8192u SoftAP. */
+		if ((padapter->securitypriv.dot11PrivacyAlgrthm != _WEP40_) &&
+		    (padapter->securitypriv.dot11PrivacyAlgrthm != _WEP104_) &&
+		    (padapter->securitypriv.dot11PrivacyAlgrthm != _TKIP_)) {
+			/* rtw_restructure_ht_ie */
+			rtw_restructure_ht_ie(padapter, &pnetwork->network.IEs[0],
+					      &psecnetwork->IEs[0],
+					      pnetwork->network.IELength,
+					      &psecnetwork->IELength,
+					      (u8)psecnetwork->Configuration.DSConfig);
 		}
 	}
 
@@ -1221,23 +1170,10 @@ _func_enter_;
 
 	pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->network.IEs, pnetwork->network.IELength);
 
-	#if 0
-	psecuritypriv->supplicant_ie[0]=(u8)psecnetwork->IELength;
-
-	if(psecnetwork->IELength < (256-1))
-	{
-		_rtw_memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0], psecnetwork->IELength);
-	}
-	else
-	{
-		_rtw_memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0], (256-1));
-	}
-	#endif
-
-	pcmd->cmdsz = get_wlan_bssid_ex_sz(psecnetwork);//get cmdsz before endian conversion
+	pcmd->cmdsz = get_wlan_bssid_ex_sz(psecnetwork);/* get cmdsz before endian conversion */
 
 	_rtw_init_listhead(&pcmd->list);
-	pcmd->cmdcode = _JoinBss_CMD_;//GEN_CMD_CODE(_JoinBss)
+	pcmd->cmdcode = _JOINBSS_CMD_;/* GEN_CMD_CODE(_JoinBss) */
 	pcmd->parmbuf = (unsigned char *)psecnetwork;
 	pcmd->rsp = NULL;
 	pcmd->rspsz = 0;
@@ -1296,24 +1232,24 @@ _func_exit_;
 
 u8 rtw_setopmode_cmd(struct rtw_adapter *padapter, enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
 {
-	struct	cmd_obj*	ph2c;
-	struct	setopmode_parm* psetop;
+	struct cmd_obj *ph2c;
+	struct setopmode_parm *psetop;
 
-	struct	cmd_priv   *pcmdpriv= &padapter->cmdpriv;
-	u8	res=_SUCCESS;
+	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= false;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = false;
 		goto exit;
 	}
-	psetop = (struct setopmode_parm*)rtw_zmalloc(sizeof(struct setopmode_parm));
+	psetop = (struct setopmode_parm *)rtw_zmalloc(sizeof(struct setopmode_parm));
 
-	if(psetop==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res=false;
+	if (psetop == NULL) {
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
+		res = false;
 		goto exit;
 	}
 
@@ -1331,69 +1267,69 @@ _func_exit_;
 
 u8 rtw_setstakey_cmd(struct rtw_adapter *padapter, u8 *psta, u8 unicast_key)
 {
-	struct cmd_obj*			ph2c;
-	struct set_stakey_parm	*psetstakey_para;
-	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
+	struct cmd_obj *ph2c;
+	struct set_stakey_parm *psetstakey_para;
+	struct cmd_priv				*pcmdpriv = &padapter->cmdpriv;
 	struct set_stakey_rsp		*psetstakey_rsp = NULL;
 
 	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
 	struct security_priv		*psecuritypriv = &padapter->securitypriv;
-	struct sta_info*			sta = (struct sta_info* )psta;
-	u8	res=_SUCCESS;
+	struct sta_info *sta = (struct sta_info *)psta;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if ( ph2c == NULL){
-		res= _FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
-	psetstakey_para = (struct set_stakey_parm*)rtw_zmalloc(sizeof(struct set_stakey_parm));
-	if(psetstakey_para==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res=_FAIL;
+	psetstakey_para = (struct set_stakey_parm *)rtw_zmalloc(sizeof(struct set_stakey_parm));
+	if (psetstakey_para == NULL) {
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
 		goto exit;
 	}
 
-	psetstakey_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_stakey_rsp));
-	if(psetstakey_rsp == NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		rtw_mfree((u8 *) psetstakey_para, sizeof(struct set_stakey_parm));
-		res=_FAIL;
+	psetstakey_rsp = (struct set_stakey_rsp *)rtw_zmalloc(sizeof(struct set_stakey_rsp));
+	if (psetstakey_rsp == NULL) {
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
+		rtw_mfree((u8 *)psetstakey_para, sizeof(struct set_stakey_parm));
+		res = _FAIL;
 		goto exit;
 	}
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);
-	ph2c->rsp = (u8 *) psetstakey_rsp;
+	ph2c->rsp = (u8 *)psetstakey_rsp;
 	ph2c->rspsz = sizeof(struct set_stakey_rsp);
 
-	_rtw_memcpy(psetstakey_para->addr, sta->hwaddr,ETH_ALEN);
+	_rtw_memcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);
 
-	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE)){
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
 #ifdef CONFIG_TDLS
-		if(sta->tdls_sta_state&TDLS_LINKED_STATE)
-			psetstakey_para->algorithm=(u8)sta->dot118021XPrivacy;
+		if (sta->tdls_sta_state&TDLS_LINKED_STATE)
+			psetstakey_para->algorithm = (u8)sta->dot118021XPrivacy;
 		else
-#endif //CONFIG_TDLS
-		psetstakey_para->algorithm =(unsigned char) psecuritypriv->dot11PrivacyAlgrthm;
-	}else{
+#endif /* CONFIG_TDLS */
+		psetstakey_para->algorithm = (unsigned char) psecuritypriv->dot11PrivacyAlgrthm;
+	} else {
 		GET_ENCRY_ALGO(psecuritypriv, sta, psetstakey_para->algorithm, false);
 	}
 
 	if (unicast_key == true) {
 #ifdef CONFIG_TDLS
-		if(sta->tdls_sta_state&TDLS_LINKED_STATE)
+		if (sta->tdls_sta_state&TDLS_LINKED_STATE)
 			_rtw_memcpy(&psetstakey_para->key, sta->tpk.tk, 16);
 		else
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 			_rtw_memcpy(&psetstakey_para->key, &sta->dot118021x_UncstKey, 16);
-        } else {
+	} else {
 		_rtw_memcpy(&psetstakey_para->key, &psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey, 16);
-        }
+	}
 
-	//jeff: set this becasue at least sw key is ready
-	padapter->securitypriv.busetkipkey=true;
+	/* jeff: set this becasue at least sw key is ready */
+	padapter->securitypriv.busetkipkey = true;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
@@ -1406,46 +1342,43 @@ _func_exit_;
 
 u8 rtw_clearstakey_cmd(struct rtw_adapter *padapter, u8 *psta, u8 entry, u8 enqueue)
 {
-	struct cmd_obj*			ph2c;
-	struct set_stakey_parm	*psetstakey_para;
-	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
+	struct cmd_obj *ph2c;
+	struct set_stakey_parm *psetstakey_para;
+	struct cmd_priv				*pcmdpriv = &padapter->cmdpriv;
 	struct set_stakey_rsp		*psetstakey_rsp = NULL;
 	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
 	struct security_priv		*psecuritypriv = &padapter->securitypriv;
-	struct sta_info*			sta = (struct sta_info* )psta;
-	u8	res=_SUCCESS;
+	struct sta_info *sta = (struct sta_info *)psta;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	if(!enqueue)
-	{
+	if (!enqueue) {
 		clear_cam_entry(padapter, entry);
-	}
-	else
-	{
-		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-		if ( ph2c == NULL){
-			res= _FAIL;
+	} else {
+		ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+		if (ph2c == NULL) {
+			res = _FAIL;
 			goto exit;
 		}
 
-		psetstakey_para = (struct set_stakey_parm*)rtw_zmalloc(sizeof(struct set_stakey_parm));
-		if(psetstakey_para==NULL){
-			rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-			res=_FAIL;
+		psetstakey_para = (struct set_stakey_parm *)rtw_zmalloc(sizeof(struct set_stakey_parm));
+		if (psetstakey_para == NULL) {
+			rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
+			res = _FAIL;
 			goto exit;
 		}
 
-		psetstakey_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_stakey_rsp));
-		if(psetstakey_rsp == NULL){
-			rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-			rtw_mfree((u8 *) psetstakey_para, sizeof(struct set_stakey_parm));
-			res=_FAIL;
+		psetstakey_rsp = (struct set_stakey_rsp *)rtw_zmalloc(sizeof(struct set_stakey_rsp));
+		if (psetstakey_rsp == NULL) {
+			rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
+			rtw_mfree((u8 *)psetstakey_para, sizeof(struct set_stakey_parm));
+			res = _FAIL;
 			goto exit;
 		}
 
 		init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);
-		ph2c->rsp = (u8 *) psetstakey_rsp;
+		ph2c->rsp = (u8 *)psetstakey_rsp;
 		ph2c->rspsz = sizeof(struct set_stakey_rsp);
 
 		_rtw_memcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);
@@ -1455,123 +1388,115 @@ _func_enter_;
 		psetstakey_para->id = entry;
 
 		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
 	}
-
 exit:
-
 _func_exit_;
-
 	return res;
 }
 
 u8 rtw_setrttbl_cmd(struct rtw_adapter *padapter, struct setratable_parm *prate_table)
 {
-	struct cmd_obj*			ph2c;
-	struct setratable_parm *	psetrttblparm;
-	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
+	struct cmd_obj *ph2c;
+	struct setratable_parm *psetrttblparm;
+	struct cmd_priv				*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
 _func_enter_;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 		}
-	psetrttblparm = (struct setratable_parm*)rtw_zmalloc(sizeof(struct setratable_parm));
+	psetrttblparm = (struct setratable_parm *)rtw_zmalloc(sizeof(struct setratable_parm));
 
-	if(psetrttblparm==NULL){
-		rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
+	if (psetrttblparm == NULL) {
+		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
 		goto exit;
 	}
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm, GEN_CMD_CODE(_SetRaTable));
 
-	_rtw_memcpy(psetrttblparm,prate_table,sizeof(struct setratable_parm));
+	_rtw_memcpy(psetrttblparm, prate_table, sizeof(struct setratable_parm));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
 _func_exit_;
 	return res;
-
 }
 
 u8 rtw_getrttbl_cmd(struct rtw_adapter *padapter, struct getratable_rsp *pval)
 {
-	struct cmd_obj*			ph2c;
-	struct getratable_parm *	pgetrttblparm;
-	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
+	struct cmd_obj *ph2c;
+	struct getratable_parm *pgetrttblparm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
 _func_enter_;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
-	pgetrttblparm = (struct getratable_parm*)rtw_zmalloc(sizeof(struct getratable_parm));
+	pgetrttblparm = (struct getratable_parm *)rtw_zmalloc(sizeof(struct getratable_parm));
 
-	if(pgetrttblparm==NULL){
-		rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
+	if (pgetrttblparm == NULL) {
+		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
 		goto exit;
 	}
 
-//	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm, GEN_CMD_CODE(_SetRaTable));
-
 	_rtw_init_listhead(&ph2c->list);
-	ph2c->cmdcode =GEN_CMD_CODE(_GetRaTable);
+	ph2c->cmdcode = GEN_CMD_CODE(_GetRaTable);
 	ph2c->parmbuf = (unsigned char *)pgetrttblparm;
 	ph2c->cmdsz =  sizeof(struct getratable_parm);
-	ph2c->rsp = (u8*)pval;
+	ph2c->rsp = (u8 *)pval;
 	ph2c->rspsz = sizeof(struct getratable_rsp);
 
-	pgetrttblparm ->rsvd = 0x0;
+	pgetrttblparm->rsvd = 0x0;
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 exit:
 _func_exit_;
 	return res;
-
 }
 
 u8 rtw_setassocsta_cmd(struct rtw_adapter *padapter, u8 *mac_addr)
 {
-	struct cmd_priv			*pcmdpriv = &padapter->cmdpriv;
-	struct cmd_obj*			ph2c;
-	struct set_assocsta_parm	*psetassocsta_para;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj *ph2c;
+	struct set_assocsta_parm *psetassocsta_para;
 	struct set_stakey_rsp		*psetassocsta_rsp = NULL;
 
-	u8	res=_SUCCESS;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
-	psetassocsta_para = (struct set_assocsta_parm*)rtw_zmalloc(sizeof(struct set_assocsta_parm));
-	if(psetassocsta_para==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		res=_FAIL;
+	psetassocsta_para = (struct set_assocsta_parm *)rtw_zmalloc(sizeof(struct set_assocsta_parm));
+	if (psetassocsta_para == NULL) {
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
 		goto exit;
 	}
 
-	psetassocsta_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_assocsta_rsp));
-	if(psetassocsta_rsp==NULL){
-		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
-		rtw_mfree((u8 *) psetassocsta_para, sizeof(struct set_assocsta_parm));
+	psetassocsta_rsp = (struct set_stakey_rsp *)rtw_zmalloc(sizeof(struct set_assocsta_rsp));
+	if (psetassocsta_rsp == NULL) {
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
+		rtw_mfree((u8 *)psetassocsta_para, sizeof(struct set_assocsta_parm));
 		return _FAIL;
 	}
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, psetassocsta_para, _SetAssocSta_CMD_);
-	ph2c->rsp = (u8 *) psetassocsta_rsp;
+	ph2c->rsp = (u8 *)psetassocsta_rsp;
 	ph2c->rspsz = sizeof(struct set_assocsta_rsp);
 
-	_rtw_memcpy(psetassocsta_para->addr, mac_addr,ETH_ALEN);
+	_rtw_memcpy(psetassocsta_para->addr, mac_addr, ETH_ALEN);
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
@@ -1584,24 +1509,24 @@ _func_exit_;
 
 u8 rtw_addbareq_cmd(struct rtw_adapter *padapter, u8 tid, u8 *addr)
 {
-	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
-	struct cmd_obj*		ph2c;
-	struct addBaReq_parm	*paddbareq_parm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj *ph2c;
+	struct addBaReq_parm *paddbareq_parm;
 
-	u8	res=_SUCCESS;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
-	paddbareq_parm = (struct addBaReq_parm*)rtw_zmalloc(sizeof(struct addBaReq_parm));
-	if(paddbareq_parm==NULL){
-		rtw_mfree((unsigned char *)ph2c, sizeof(struct	cmd_obj));
-		res= _FAIL;
+	paddbareq_parm = (struct addBaReq_parm *)rtw_zmalloc(sizeof(struct addBaReq_parm));
+	if (paddbareq_parm == NULL) {
+		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
+		res = _FAIL;
 		goto exit;
 	}
 
@@ -1610,9 +1535,6 @@ _func_enter_;
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, paddbareq_parm, GEN_CMD_CODE(_AddBAReq));
 
-	//DBG_8192D("rtw_addbareq_cmd, tid=%d\n", tid);
-
-	//rtw_enqueue_cmd(pcmdpriv, ph2c);
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
 exit:
@@ -1624,14 +1546,15 @@ _func_exit_;
 
 u8 rtw_dynamic_chk_wk_cmd(struct rtw_adapter *padapter)
 {
-	struct cmd_obj*		ph2c;
+	struct cmd_obj *ph2c;
 	struct drvextra_cmd_parm  *pdrvextra_cmd_parm;
-	struct cmd_priv	*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
+	if ((padapter->bDriverStopped == true) ||
+	    (padapter->bSurpriseRemoved == true))
 		goto exit;
 
 
@@ -1640,16 +1563,16 @@ _func_enter_;
 		pcmdpriv = &(padapter->pbuddy_adapter->cmdpriv);
 #endif
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
-	if(pdrvextra_cmd_parm==NULL){
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	if (pdrvextra_cmd_parm == NULL) {
 		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
-		res= _FAIL;
+		res = _FAIL;
 		goto exit;
 	}
 
@@ -1657,18 +1580,14 @@ _func_enter_;
 	pdrvextra_cmd_parm->type_size = 0;
 	pdrvextra_cmd_parm->pbuf = (u8 *)padapter;
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
-
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
 
-	//rtw_enqueue_cmd(pcmdpriv, ph2c);
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
 exit:
 
 _func_exit_;
 
 	return res;
-
 }
 
 u8 rtw_set_ch_cmd(struct rtw_adapter *padapter, u8 ch, u8 bw, u8 ch_offset, u8 enqueue)
@@ -1677,19 +1596,19 @@ u8 rtw_set_ch_cmd(struct rtw_adapter *pa
 	struct set_ch_parm *set_ch_parm;
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 
-	u8 res=_SUCCESS;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
 	DBG_8192D(FUNC_NDEV_FMT" ch:%u, bw:%u, ch_offset:%u\n",
-		FUNC_NDEV_ARG(padapter->pnetdev), ch, bw, ch_offset);
+		  FUNC_NDEV_ARG(padapter->pnetdev), ch, bw, ch_offset);
 
 	/* check input parameter */
 
 	/* prepare cmd parameter */
 	set_ch_parm = (struct set_ch_parm *)rtw_zmalloc(sizeof(*set_ch_parm));
 	if (set_ch_parm == NULL) {
-		res= _FAIL;
+		res = _FAIL;
 		goto exit;
 	}
 	set_ch_parm->ch = ch;
@@ -1698,10 +1617,10 @@ _func_enter_;
 
 	if (enqueue) {
 		/* need enqueue, prepare cmd_obj and enqueue */
-		pcmdobj = (struct cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-		if(pcmdobj == NULL){
+		pcmdobj = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+		if (pcmdobj == NULL) {
 			rtw_mfree((u8 *)set_ch_parm, sizeof(*set_ch_parm));
-			res=_FAIL;
+			res = _FAIL;
 			goto exit;
 		}
 
@@ -1709,7 +1628,7 @@ _func_enter_;
 		res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
 	} else {
 		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
-		if( H2C_SUCCESS !=set_ch_hdl(padapter, (u8 *)set_ch_parm) )
+		if (H2C_SUCCESS != set_ch_hdl(padapter, (u8 *)set_ch_parm))
 			res = _FAIL;
 
 		rtw_mfree((u8 *)set_ch_parm, sizeof(*set_ch_parm));
@@ -1728,54 +1647,51 @@ _func_exit_;
 
 u8 rtw_set_chplan_cmd(struct rtw_adapter *padapter, u8 chplan, u8 enqueue)
 {
-	struct	cmd_obj*	pcmdobj;
-	struct	SetChannelPlan_param *setChannelPlan_param;
-	struct	cmd_priv   *pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj *pcmdobj;
+	struct SetChannelPlan_param *setChannelPlan_param;
+	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
 
-	u8	res=_SUCCESS;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_chplan_cmd\n"));
 
-	//check input parameter
-	if(!rtw_is_channel_plan_valid(chplan)) {
+	/* check input parameter */
+	if (!rtw_is_channel_plan_valid(chplan)) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	//prepare cmd parameter
-	setChannelPlan_param = (struct	SetChannelPlan_param *)rtw_zmalloc(sizeof(struct SetChannelPlan_param));
-	if(setChannelPlan_param == NULL) {
-		res= _FAIL;
+	/* prepare cmd parameter */
+	setChannelPlan_param = (struct SetChannelPlan_param *)rtw_zmalloc(sizeof(struct SetChannelPlan_param));
+	if (setChannelPlan_param == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
-	setChannelPlan_param->channel_plan=chplan;
+	setChannelPlan_param->channel_plan = chplan;
 
-	if(enqueue)
-	{
-		//need enqueue, prepare cmd_obj and enqueue
-		pcmdobj = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-		if(pcmdobj == NULL){
+	if (enqueue) {
+		/* need enqueue, prepare cmd_obj and enqueue */
+		pcmdobj = (struct cmd_obj *)rtw_zmalloc(sizeof(struct	cmd_obj));
+		if (pcmdobj == NULL) {
 			rtw_mfree((u8 *)setChannelPlan_param, sizeof(struct SetChannelPlan_param));
-			res=_FAIL;
+			res = _FAIL;
 			goto exit;
 		}
 
 		init_h2fwcmd_w_parm_no_rsp(pcmdobj, setChannelPlan_param, GEN_CMD_CODE(_SetChannelPlan));
 		res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
-	}
-	else
-	{
-		//no need to enqueue, do the cmd hdl directly and free cmd parameter
-		if( H2C_SUCCESS !=set_chplan_hdl(padapter, (unsigned char *)setChannelPlan_param) )
+	} else {
+		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
+		if (H2C_SUCCESS != set_chplan_hdl(padapter, (unsigned char *)setChannelPlan_param))
 			res = _FAIL;
 
 		rtw_mfree((u8 *)setChannelPlan_param, sizeof(struct SetChannelPlan_param));
 	}
 
-	//do something based on res...
-	if(res == _SUCCESS)
+	/* do something based on res... */
+	if (res == _SUCCESS)
 		padapter->mlmepriv.ChannelPlan = chplan;
 
 exit:
@@ -1787,30 +1703,30 @@ _func_exit_;
 
 u8 rtw_led_blink_cmd(struct rtw_adapter *padapter, struct LED_871X *pLed)
 {
-	struct	cmd_obj*	pcmdobj;
-	struct	LedBlink_param *ledBlink_param;
-	struct	cmd_priv   *pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj *pcmdobj;
+	struct LedBlink_param *ledBlink_param;
+	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
 
-	u8	res=_SUCCESS;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_led_blink_cmd\n"));
 
-	pcmdobj = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if(pcmdobj == NULL){
-		res=_FAIL;
+	pcmdobj = (struct cmd_obj *)rtw_zmalloc(sizeof(struct	cmd_obj));
+	if (pcmdobj == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
-	ledBlink_param = (struct	LedBlink_param *)rtw_zmalloc(sizeof(struct	LedBlink_param));
-	if(ledBlink_param == NULL) {
+	ledBlink_param = (struct LedBlink_param *)rtw_zmalloc(sizeof(struct	LedBlink_param));
+	if (ledBlink_param == NULL) {
 		rtw_mfree((u8 *)pcmdobj, sizeof(struct cmd_obj));
-		res= _FAIL;
+		res = _FAIL;
 		goto exit;
 	}
 
-	ledBlink_param->pLed=pLed;
+	ledBlink_param->pLed = pLed;
 
 	init_h2fwcmd_w_parm_no_rsp(pcmdobj, ledBlink_param, GEN_CMD_CODE(_LedBlink));
 	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
@@ -1824,31 +1740,31 @@ _func_exit_;
 
 u8 rtw_set_csa_cmd(struct rtw_adapter *padapter, u8 new_ch_no)
 {
-	struct	cmd_obj*	pcmdobj;
-	struct	SetChannelSwitch_param*setChannelSwitch_param;
-	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct	cmd_priv   *pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj *pcmdobj;
+	struct SetChannelSwitch_param *setChannelSwitch_param;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
 
-	u8	res=_SUCCESS;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_csa_cmd\n"));
 
-	pcmdobj = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if(pcmdobj == NULL){
-		res=_FAIL;
+	pcmdobj = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmdobj == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
-	setChannelSwitch_param = (struct SetChannelSwitch_param *)rtw_zmalloc(sizeof(struct	SetChannelSwitch_param));
-	if(setChannelSwitch_param == NULL) {
+	setChannelSwitch_param = (struct SetChannelSwitch_param *)rtw_zmalloc(sizeof(struct SetChannelSwitch_param));
+	if (setChannelSwitch_param == NULL) {
 		rtw_mfree((u8 *)pcmdobj, sizeof(struct cmd_obj));
-		res= _FAIL;
+		res = _FAIL;
 		goto exit;
 	}
 
-	setChannelSwitch_param->new_ch_no=new_ch_no;
+	setChannelSwitch_param->new_ch_no = new_ch_no;
 
 	init_h2fwcmd_w_parm_no_rsp(pcmdobj, setChannelSwitch_param, GEN_CMD_CODE(_SetChannelSwitch));
 	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
@@ -1862,12 +1778,12 @@ _func_exit_;
 
 u8 rtw_tdls_cmd(struct rtw_adapter *padapter, u8 *addr, u8 option)
 {
-	struct	cmd_obj*	pcmdobj;
-	struct	TDLSoption_param	*TDLSoption;
-	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	struct	cmd_priv   *pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj *pcmdobj;
+	struct TDLSoption_param	*TDLSoption;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
 
-	u8	res=_SUCCESS;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
@@ -1875,16 +1791,16 @@ _func_enter_;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_tdls_cmd\n"));
 
-	pcmdobj = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if(pcmdobj == NULL){
-		res=_FAIL;
+	pcmdobj = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmdobj == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
-	TDLSoption= (struct TDLSoption_param *)rtw_zmalloc(sizeof(struct TDLSoption_param));
-	if(TDLSoption == NULL) {
+	TDLSoption = (struct TDLSoption_param *)rtw_zmalloc(sizeof(struct TDLSoption_param));
+	if (TDLSoption == NULL) {
 		rtw_mfree((u8 *)pcmdobj, sizeof(struct cmd_obj));
-		res= _FAIL;
+		res = _FAIL;
 		goto exit;
 	}
 
@@ -1895,7 +1811,7 @@ _func_enter_;
 	init_h2fwcmd_w_parm_no_rsp(pcmdobj, TDLSoption, GEN_CMD_CODE(_TDLS));
 	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
 
-#endif	//CONFIG_TDLS
+#endif	/* CONFIG_TDLS */
 
 exit:
 
@@ -1908,85 +1824,67 @@ _func_exit_;
 static void traffic_status_watchdog(struct rtw_adapter *padapter)
 {
 #ifdef CONFIG_LPS
-	u8	bEnterPS;
+	u8 enterps;
 #endif
-	u8	bBusyTraffic = false, bTxBusyTraffic = false, bRxBusyTraffic = false;
-	u8	bHigherBusyTraffic = false, bHigherBusyRxTraffic = false, bHigherBusyTxTraffic = false;
+	u8 bBusyTraffic = false, bTxBusyTraffic = false, bRxBusyTraffic = false;
+	u8 bHigherBusyTraffic = false, bHigherBusyRxTraffic = false, bHigherBusyTxTraffic = false;
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &(padapter->tdlsinfo);
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
-	//
-	// Determine if our traffic is busy now
-	//
-	if((check_fwstate(pmlmepriv, _FW_LINKED)== true)
-		/*&& !MgntInitAdapterInProgress(pMgntInfo)*/)
-	{
-
-		if( pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 100 ||
-			pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 100 )
-		{
+	/*  Determine if our traffic is busy now */
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+		if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 100 ||
+		    pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 100) {
 			bBusyTraffic = true;
 
-			if(pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 100)
+			if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 100)
 				bRxBusyTraffic = true;
 
-			if(pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 100)
+			if (pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 100)
 				bTxBusyTraffic = true;
 		}
 
-		// Higher Tx/Rx data.
-		if( pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 4000 ||
-			pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 4000 )
-		{
+		/*  Higher Tx/Rx data. */
+		if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 4000 ||
+		    pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 4000) {
 			bHigherBusyTraffic = true;
 
-			// Extremely high Rx data.
-			if(pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 5000)
+			/*  Extremely high Rx data. */
+			if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 5000)
 				bHigherBusyRxTraffic = true;
 
-			// Extremely high Tx data.
-			if(pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 5000)
+			/*  Extremely high Tx data. */
+			if (pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 5000)
 				bHigherBusyTxTraffic = true;
 		}
 
 #ifdef CONFIG_TDLS
 #ifdef CONFIG_TDLS_AUTOSETUP
-		if( ( ptdlsinfo->watchdog_count % TDLS_WATCHDOG_PERIOD ) == 0 )	//TDLS_WATCHDOG_PERIOD * 2sec, periodically sending
-			issue_tdls_dis_req( padapter, NULL );
+		if ((ptdlsinfo->watchdog_count % TDLS_WATCHDOG_PERIOD) == 0)	/* TDLS_WATCHDOG_PERIOD * 2sec, periodically sending */
+			issue_tdls_dis_req(padapter, NULL);
 		ptdlsinfo->watchdog_count++;
-#endif //CONFIG_TDLS_AUTOSETUP
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS_AUTOSETUP */
+#endif /* CONFIG_TDLS */
 
 #ifdef CONFIG_LPS
-		// check traffic for  powersaving.
-		if( ((pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod + pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) > 8 ) ||
-			(pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2) )
-		{
-			//DBG_8192D("Tx = %d, Rx = %d \n",pmlmepriv->LinkDetectInfo.NumTxOkInPeriod,pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod);
-			bEnterPS= false;
-		}
+		/*  check traffic for  powersaving. */
+		if (((pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod + pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) > 8) ||
+		    (pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2))
+			enterps = false;
 		else
-		{
-			bEnterPS= true;
-		}
+			enterps = true;
 
-		// LeisurePS only work in infra mode.
-		if(bEnterPS)
-		{
-			LPS_Enter(padapter);
-		}
+		/*  LeisurePS only work in infra mode. */
+		if (enterps)
+			rtw_lps_enter(padapter);
 		else
-		{
-			LPS_Leave(padapter);
-		}
+			rtw_lps_leave(padapter);
 #endif
-	}
-	else
-	{
+	} else {
 #ifdef CONFIG_LPS
-		LPS_Leave(padapter);
+		rtw_lps_leave(padapter);
 #endif
 	}
 
@@ -1999,49 +1897,42 @@ static void traffic_status_watchdog(stru
 	pmlmepriv->LinkDetectInfo.bHigherBusyTraffic = bHigherBusyTraffic;
 	pmlmepriv->LinkDetectInfo.bHigherBusyRxTraffic = bHigherBusyRxTraffic;
 	pmlmepriv->LinkDetectInfo.bHigherBusyTxTraffic = bHigherBusyTxTraffic;
-
 }
 
 void dynamic_chk_wk_hdl(struct rtw_adapter *padapter, u8 *pbuf, int sz)
 {
 	struct mlme_priv *pmlmepriv;
 
-	if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
+	if ((padapter->bDriverStopped == true) ||
+	    (padapter->bSurpriseRemoved == true))
 		return;
 
-	if((void*)padapter != (void*)pbuf && padapter->pbuddy_adapter == NULL)
+	if ((void *)padapter != (void *)pbuf && padapter->pbuddy_adapter == NULL)
 		return;
 
 	padapter = (struct rtw_adapter *)pbuf;
 
-	if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
+	if ((padapter->bDriverStopped == true) ||
+	    (padapter->bSurpriseRemoved == true))
 		return;
 
 	pmlmepriv = &(padapter->mlmepriv);
 
 #ifdef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
 #ifdef CONFIG_AP_MODE
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
-	{
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		expire_timeout_chk(padapter);
-	}
 #endif
-#endif //CONFIG_ACTIVE_KEEP_ALIVE_CHECK
+#endif /* CONFIG_ACTIVE_KEEP_ALIVE_CHECK */
 
 	#ifdef DBG_CONFIG_ERROR_DETECT
 	rtw_hal_sreset_xmit_status_check(padapter);
 	#endif
 
-	//if(check_fwstate(pmlmepriv, _FW_UNDER_LINKING|_FW_UNDER_SURVEY)==false)
-	{
-		linked_status_chk(padapter);
-		traffic_status_watchdog(padapter);
-	}
+	linked_status_chk(padapter);
+	traffic_status_watchdog(padapter);
 
 	rtw_hal_dm_watchdog(padapter);
-
-	//check_hw_pbc(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
-
 }
 
 #ifdef CONFIG_LPS
@@ -2050,47 +1941,39 @@ void lps_ctrl_wk_hdl(struct rtw_adapter
 {
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	u8	mstatus;
+	u8 mstatus;
 
 _func_enter_;
 
-	if((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)
-		|| (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
-	{
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
 		return;
-	}
 
-	switch(lps_ctrl_type)
-	{
-		case LPS_CTRL_SCAN:
-			//DBG_8192D("LPS_CTRL_SCAN \n");
-			LeaveAllPowerSaveMode(padapter);
-			break;
-		case LPS_CTRL_JOINBSS:
-			//DBG_8192D("LPS_CTRL_JOINBSS \n");
-			LPS_Leave(padapter);
-			break;
-		case LPS_CTRL_CONNECT:
-			//DBG_8192D("LPS_CTRL_CONNECT \n");
-			mstatus = 1;
-			// Reset LPS Setting
-			padapter->pwrctrlpriv.LpsIdleCount = 0;
-			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));
-			break;
-		case LPS_CTRL_DISCONNECT:
-			//DBG_8192D("LPS_CTRL_DISCONNECT \n");
-			mstatus = 0;
-			LPS_Leave(padapter);
-			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));
-			break;
-		case LPS_CTRL_SPECIAL_PACKET:
-			//DBG_8192D("LPS_CTRL_SPECIAL_PACKET \n");
-			pwrpriv->DelayLPSLastTimeStamp = rtw_get_current_time();
-			LPS_Leave(padapter);
-			break;
+	switch (lps_ctrl_type) {
+	case LPS_CTRL_SCAN:
+		LeaveAllPowerSaveMode(padapter);
+		break;
+	case LPS_CTRL_JOINBSS:
+		rtw_lps_leave(padapter);
+		break;
+	case LPS_CTRL_CONNECT:
+		mstatus = 1;
+		/*  Reset LPS Setting */
+		padapter->pwrctrlpriv.LpsIdleCount = 0;
+		rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));
+		break;
+	case LPS_CTRL_DISCONNECT:
+		mstatus = 0;
+		rtw_lps_leave(padapter);
+		rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));
+		break;
+	case LPS_CTRL_SPECIAL_PACKET:
+		pwrpriv->DelayLPSLastTimeStamp = rtw_get_current_time();
+		rtw_lps_leave(padapter);
+		break;
 
-		default:
-			break;
+	default:
+		break;
 	}
 
 _func_exit_;
@@ -2098,34 +1981,29 @@ _func_exit_;
 
 u8 rtw_lps_ctrl_wk_cmd(struct rtw_adapter *padapter, u8 lps_ctrl_type, u8 enqueue)
 {
-	struct cmd_obj	*ph2c;
-	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
+	struct cmd_obj *ph2c;
+	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	//struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
-	u8	res = _SUCCESS;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	//if(!pwrctrlpriv->bLeisurePs)
-	//	return res;
-
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type != IFACE_PORT0)
 		return res;
 #endif
 
-	if(enqueue)
-	{
-		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-		if(ph2c==NULL){
-			res= _FAIL;
+	if (enqueue) {
+		ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+		if (ph2c == NULL) {
+			res = _FAIL;
 			goto exit;
 		}
 
-		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
-		if(pdrvextra_cmd_parm==NULL){
+		pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+		if (pdrvextra_cmd_parm == NULL) {
 			rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
-			res= _FAIL;
+			res = _FAIL;
 			goto exit;
 		}
 
@@ -2133,12 +2011,10 @@ _func_enter_;
 		pdrvextra_cmd_parm->type_size = lps_ctrl_type;
 		pdrvextra_cmd_parm->pbuf = NULL;
 
-		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
 
 		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-	}
-	else
-	{
+	} else {
 		lps_ctrl_wk_hdl(padapter, lps_ctrl_type);
 	}
 
@@ -2147,7 +2023,6 @@ exit:
 _func_exit_;
 
 	return res;
-
 }
 
 #endif
@@ -2158,49 +2033,45 @@ void antenna_select_wk_hdl(struct rtw_ad
 	rtw_hal_set_hwreg(padapter, HW_VAR_ANTENNA_DIVERSITY_SELECT, (u8 *)(&antenna));
 }
 
-u8 rtw_antenna_select_cmd(struct rtw_adapter *padapter, u8 antenna,u8 enqueue)
+u8 rtw_antenna_select_cmd(struct rtw_adapter *padapter, u8 antenna, u8 enqueue)
 {
-	struct cmd_obj		*ph2c;
-	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
+	struct cmd_obj *ph2c;
+	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8	bSupportAntDiv = false;
-	u8	res = _SUCCESS;
+	u8 support_ant_div = false;
+	u8 res = _SUCCESS;
 
 _func_enter_;
-	rtw_hal_get_def_var(padapter, HAL_DEF_IS_SUPPORT_ANT_DIV, &(bSupportAntDiv));
-	if(false == bSupportAntDiv )	return res;
+	rtw_hal_get_def_var(padapter, HAL_DEF_IS_SUPPORT_ANT_DIV, &(support_ant_div));
+	if (false == support_ant_div)
+		return res;
 
-	if(true == enqueue)
-	{
-		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-		if(ph2c==NULL){
-			res= _FAIL;
+	if (true == enqueue) {
+		ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+		if (ph2c == NULL) {
+			res = _FAIL;
 			goto exit;
 		}
 
-		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
-		if(pdrvextra_cmd_parm==NULL){
+		pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+		if (pdrvextra_cmd_parm == NULL) {
 			rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
-			res= _FAIL;
+			res = _FAIL;
 			goto exit;
 		}
 
 		pdrvextra_cmd_parm->ec_id = ANT_SELECT_WK_CID;
 		pdrvextra_cmd_parm->type_size = antenna;
 		pdrvextra_cmd_parm->pbuf = NULL;
-		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
 
 		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-	}
-	else{
-		antenna_select_wk_hdl(padapter,antenna );
+	} else {
+		antenna_select_wk_hdl(padapter, antenna);
 	}
 exit:
-
 _func_exit_;
-
 	return res;
-
 }
 #endif
 
@@ -2210,58 +2081,52 @@ void power_saving_wk_hdl(struct rtw_adap
 }
 
 #ifdef CONFIG_P2P
-u8 p2p_protocol_wk_cmd(struct rtw_adapter *padapter, int intCmdType )
+u8 p2p_protocol_wk_cmd(struct rtw_adapter *padapter, int intCmdType)
 {
-	struct cmd_obj	*ph2c;
-	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
-	struct wifidirect_info	*pwdinfo= &(padapter->wdinfo);
+	struct cmd_obj *ph2c;
+	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8	res = _SUCCESS;
+	u8 res = _SUCCESS;
 
 _func_enter_;
 
-	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-	{
+	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return res;
-	}
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
-	if(pdrvextra_cmd_parm==NULL){
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	if (pdrvextra_cmd_parm == NULL) {
 		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
-		res= _FAIL;
+		res = _FAIL;
 		goto exit;
 	}
 
 	pdrvextra_cmd_parm->ec_id = P2P_PROTO_WK_CID;
-	pdrvextra_cmd_parm->type_size = intCmdType;	//	As the command tppe.
-	pdrvextra_cmd_parm->pbuf = NULL;		//	Must be NULL here
+	pdrvextra_cmd_parm->type_size = intCmdType;	/*	As the command tppe. */
+	pdrvextra_cmd_parm->pbuf = NULL;		/*	Must be NULL here */
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
 exit:
-
 _func_exit_;
-
 	return res;
-
 }
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 u8 rtw_ps_cmd(struct rtw_adapter *padapter)
 {
-	struct cmd_obj		*ppscmd;
-	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
+	struct cmd_obj *ppscmd;
+	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 
-	u8	res = _SUCCESS;
+	u8 res = _SUCCESS;
 _func_enter_;
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -2269,22 +2134,22 @@ _func_enter_;
 		goto exit;
 #endif
 
-	ppscmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ppscmd==NULL){
-		res= _FAIL;
+	ppscmd = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ppscmd == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
 
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
-	if(pdrvextra_cmd_parm==NULL){
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	if (pdrvextra_cmd_parm == NULL) {
 		rtw_mfree((unsigned char *)ppscmd, sizeof(struct cmd_obj));
-		res= _FAIL;
+		res = _FAIL;
 		goto exit;
 	}
 
 	pdrvextra_cmd_parm->ec_id = POWER_SAVING_CTRL_WK_CID;
 	pdrvextra_cmd_parm->pbuf = NULL;
-	init_h2fwcmd_w_parm_no_rsp(ppscmd, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+	init_h2fwcmd_w_parm_no_rsp(ppscmd, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ppscmd);
 
@@ -2293,77 +2158,65 @@ exit:
 _func_exit_;
 
 	return res;
-
 }
 
 #ifdef CONFIG_AP_MODE
 
 static void rtw_chk_hi_queue_hdl(struct rtw_adapter *padapter)
 {
-	int cnt=0;
+	int cnt = 0;
 	struct sta_info *psta_bmc;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
 	psta_bmc = rtw_get_bcmc_stainfo(padapter);
-	if(!psta_bmc)
+	if (!psta_bmc)
 		return;
 
 
-	if(psta_bmc->sleepq_len==0)
-	{
-		while((rtw_read32(padapter, 0x414)&0x00ffff00)!=0)
-		{
+	if (psta_bmc->sleepq_len == 0) {
+		while ((rtw_read32(padapter, 0x414)&0x00ffff00) != 0) {
 			rtw_msleep_os(100);
-
 			cnt++;
-
-			if(cnt>10)
+			if (cnt > 10)
 				break;
 		}
 
-		if(cnt<=10)
-		{
+		if (cnt <= 10) {
 			pstapriv->tim_bitmap &= ~BIT(0);
 			pstapriv->sta_dz_bitmap &= ~BIT(0);
-
 			update_beacon(padapter, _TIM_IE_, NULL, false);
 		}
 	}
-
 }
 
 u8 rtw_chk_hi_queue_cmd(struct rtw_adapter *padapter)
 {
-	struct cmd_obj	*ph2c;
-	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
+	struct cmd_obj *ph2c;
+	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8	res = _SUCCESS;
+	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if(ph2c==NULL){
-		res= _FAIL;
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL) {
+		res = _FAIL;
 		goto exit;
 	}
-
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
-	if(pdrvextra_cmd_parm==NULL){
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	if (pdrvextra_cmd_parm == NULL) {
 		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
-		res= _FAIL;
+		res = _FAIL;
 		goto exit;
 	}
-
 	pdrvextra_cmd_parm->ec_id = CHECK_HIQ_WK_CID;
 	pdrvextra_cmd_parm->type_size = 0;
 	pdrvextra_cmd_parm->pbuf = NULL;
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
 exit:
-
 	return res;
-
 }
 #endif
 
@@ -2372,26 +2225,26 @@ u8 rtw_c2h_wk_cmd(struct rtw_adapter *pa
 	struct cmd_obj *ph2c;
 	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8	res = _SUCCESS;
+	u8 res = _SUCCESS;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	ph2c = (struct cmd_obj *)rtw_zmalloc(sizeof(struct cmd_obj));
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
 	if (pdrvextra_cmd_parm == NULL) {
-		rtw_mfree((u8*)ph2c, sizeof(struct cmd_obj));
+		rtw_mfree((u8 *)ph2c, sizeof(struct cmd_obj));
 		res = _FAIL;
 		goto exit;
 	}
 
 	pdrvextra_cmd_parm->ec_id = C2H_WK_CID;
-	pdrvextra_cmd_parm->type_size = c2h_evt?16:0;
+	pdrvextra_cmd_parm->type_size = c2h_evt ? 16 : 0;
 	pdrvextra_cmd_parm->pbuf = c2h_evt;
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
@@ -2416,10 +2269,8 @@ s32 c2h_evt_hdl(struct rtw_adapter *adap
 			ret = rtw_hal_c2h_handler(adapter, c2h_evt);
 		}
 	} else {
-
 		if (filter && filter(c2h_evt->id) == false)
 			goto exit;
-
 		ret = rtw_hal_c2h_handler(adapter, c2h_evt);
 	}
 exit:
@@ -2437,12 +2288,13 @@ static void c2h_wk_callback(_workitem *w
 	evtpriv->c2h_wk_alive = true;
 
 	while (!rtw_cbuf_empty(evtpriv->c2h_queue)) {
-		if ((c2h_evt = (struct c2h_evt_hdr *)rtw_cbuf_pop(evtpriv->c2h_queue)) != NULL) {
+		c2h_evt = (struct c2h_evt_hdr *)rtw_cbuf_pop(evtpriv->c2h_queue);
+		if (c2h_evt != NULL) {
 			/* This C2H event is read, clear it */
 			c2h_evt_clear(adapter);
 		} else if ((c2h_evt = (struct c2h_evt_hdr *)rtw_malloc(16)) != NULL) {
 			/* This C2H event is not read, read & clear now */
-			if (c2h_evt_read(adapter, (u8*)c2h_evt) != _SUCCESS)
+			if (c2h_evt_read(adapter, (u8 *)c2h_evt) != _SUCCESS)
 				continue;
 		}
 
@@ -2451,14 +2303,14 @@ static void c2h_wk_callback(_workitem *w
 			continue;
 
 		if (!c2h_evt_exist(c2h_evt)) {
-			rtw_mfree((u8*)c2h_evt, 16);
+			rtw_mfree((u8 *)c2h_evt, 16);
 			continue;
 		}
 
 		if (ccx_id_filter(c2h_evt->id) == true) {
 			/* Handle CCX report here */
 			rtw_hal_c2h_handler(adapter, c2h_evt);
-			rtw_mfree((u8*)c2h_evt, 16);
+			rtw_mfree((u8 *)c2h_evt, 16);
 		} else {
 			/* Enqueue into cmd_thread for others */
 			rtw_c2h_wk_cmd(adapter, (u8 *)c2h_evt);
@@ -2473,113 +2325,104 @@ u8 rtw_drvextra_cmd_hdl(struct rtw_adapt
 {
 	struct drvextra_cmd_parm *pdrvextra_cmd;
 
-	if(!pbuf)
+	if (!pbuf)
 		return H2C_PARAMETERS_ERROR;
 
-	pdrvextra_cmd = (struct drvextra_cmd_parm*)pbuf;
+	pdrvextra_cmd = (struct drvextra_cmd_parm *)pbuf;
 
-	switch(pdrvextra_cmd->ec_id)
-	{
-		case DYNAMIC_CHK_WK_CID:
-			dynamic_chk_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
-			break;
-		case POWER_SAVING_CTRL_WK_CID:
-			power_saving_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
-			break;
+	switch (pdrvextra_cmd->ec_id) {
+	case DYNAMIC_CHK_WK_CID:
+		dynamic_chk_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
+		break;
+	case POWER_SAVING_CTRL_WK_CID:
+		power_saving_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
+		break;
 #ifdef CONFIG_LPS
-		case LPS_CTRL_WK_CID:
-			lps_ctrl_wk_hdl(padapter, (u8)pdrvextra_cmd->type_size);
-			break;
+	case LPS_CTRL_WK_CID:
+		lps_ctrl_wk_hdl(padapter, (u8)pdrvextra_cmd->type_size);
+		break;
 #endif
 #ifdef CONFIG_ANTENNA_DIVERSITY
-		case ANT_SELECT_WK_CID:
-			antenna_select_wk_hdl(padapter, pdrvextra_cmd->type_size);
-			break;
+	case ANT_SELECT_WK_CID:
+		antenna_select_wk_hdl(padapter, pdrvextra_cmd->type_size);
+		break;
 #endif
 #ifdef CONFIG_P2P_PS
-		case P2P_PS_WK_CID:
-			p2p_ps_wk_hdl(padapter, pdrvextra_cmd->type_size);
-			break;
-#endif // CONFIG_P2P_PS
-		case P2P_PROTO_WK_CID:
-			//	Commented by Albert 2011/07/01
-			//	I used the type_size as the type command
-			p2p_protocol_wk_hdl( padapter, pdrvextra_cmd->type_size );
-			break;
+	case P2P_PS_WK_CID:
+		p2p_ps_wk_hdl(padapter, pdrvextra_cmd->type_size);
+		break;
+#endif /*  CONFIG_P2P_PS */
+	case P2P_PROTO_WK_CID:
+		/*	Commented by Albert 2011/07/01 */
+		/*	I used the type_size as the type command */
+		p2p_protocol_wk_hdl(padapter, pdrvextra_cmd->type_size);
+		break;
 #ifdef CONFIG_AP_MODE
-		case CHECK_HIQ_WK_CID:
-			rtw_chk_hi_queue_hdl(padapter);
-			break;
-#endif //CONFIG_AP_MODE
+	case CHECK_HIQ_WK_CID:
+		rtw_chk_hi_queue_hdl(padapter);
+		break;
+#endif /* CONFIG_AP_MODE */
 #ifdef CONFIG_INTEL_WIDI
-		case INTEl_WIDI_WK_CID:
-			intel_widi_wk_hdl(padapter, pdrvextra_cmd->type_size, pdrvextra_cmd->pbuf);
-			break;
-#endif //CONFIG_INTEL_WIDI
-
-		case C2H_WK_CID:
-			c2h_evt_hdl(padapter, (struct c2h_evt_hdr *)pdrvextra_cmd->pbuf, NULL);
-			break;
-
-		default:
-			break;
+	case INTEl_WIDI_WK_CID:
+		intel_widi_wk_hdl(padapter, pdrvextra_cmd->type_size, pdrvextra_cmd->pbuf);
+		break;
+#endif /* CONFIG_INTEL_WIDI */
+	case C2H_WK_CID:
+		c2h_evt_hdl(padapter, (struct c2h_evt_hdr *)pdrvextra_cmd->pbuf, NULL);
+		break;
+	default:
+		break;
 	}
 
 
-	if(pdrvextra_cmd->pbuf && pdrvextra_cmd->type_size>0)
-	{
+	if (pdrvextra_cmd->pbuf && pdrvextra_cmd->type_size > 0)
 		rtw_mfree(pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
-	}
-
 
 	return H2C_SUCCESS;
-
 }
 
 void rtw_survey_cmd_callback(struct rtw_adapter *padapter ,  struct cmd_obj *pcmd)
 {
-	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
 _func_enter_;
 
-	if(pcmd->res == H2C_DROPPED)
-	{
-		//TODO: cancel timer and do timeout handler directly...
-		//need to make timeout handlerOS independent
+	if (pcmd->res == H2C_DROPPED) {
+		/* TODO: cancel timer and do timeout handler directly... */
+		/* need to make timeout handlerOS independent */
 		_set_timer(&pmlmepriv->scan_to_timer, 1);
-	}
-	else if (pcmd->res != H2C_SUCCESS) {
+	} else if (pcmd->res != H2C_SUCCESS) {
 		_set_timer(&pmlmepriv->scan_to_timer, 1);
-		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ********Error: MgntActrtw_set_802_11_bssid_LIST_SCAN Fail ************\n\n."));
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ********Error: MgntActrtw_set_802_11_bssid_LIST_SCAN Fail ************\n\n."));
 	}
 
-	// free cmd
+	/*  free cmd */
 	rtw_free_cmd_obj(pcmd);
 
 _func_exit_;
 }
+
 void rtw_disassoc_cmd_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
 {
-	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
 _func_enter_;
 
-	if (pcmd->res != H2C_SUCCESS)
-	{
+	if (pcmd->res != H2C_SUCCESS) {
 		spin_lock_bh(&pmlmepriv->lock);
 		set_fwstate(pmlmepriv, _FW_LINKED);
 		spin_unlock_bh(&pmlmepriv->lock);
 
-		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ***Error: disconnect_cmd_callback Fail ***\n."));
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ***Error: disconnect_cmd_callback Fail ***\n."));
 
 		goto exit;
 	}
 #ifdef CONFIG_BR_EXT
-	else //clear bridge database
+	else /* clear bridge database */
 		nat25_db_cleanup(padapter);
-#endif //CONFIG_BR_EXT
+#endif /* CONFIG_BR_EXT */
 
-	// free cmd
+	/*  free cmd */
 	rtw_free_cmd_obj(pcmd);
 
 exit:
@@ -2590,19 +2433,16 @@ _func_exit_;
 
 void rtw_joinbss_cmd_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
 {
-	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
 _func_enter_;
 
-	if(pcmd->res == H2C_DROPPED)
-	{
-		//TODO: cancel timer and do timeout handler directly...
-		//need to make timeout handlerOS independent
+	if (pcmd->res == H2C_DROPPED) {
+		/* TODO: cancel timer and do timeout handler directly... */
+		/* need to make timeout handlerOS independent */
 		_set_timer(&pmlmepriv->assoc_timer, 1);
-	}
-	else if(pcmd->res != H2C_SUCCESS)
-	{
-		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("********Error:rtw_select_and_join_from_scanned_queue Wait Sema  Fail ************\n"));
+	} else if (pcmd->res != H2C_SUCCESS) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("********Error:rtw_select_and_join_from_scanned_queue Wait Sema  Fail ************\n"));
 		_set_timer(&pmlmepriv->assoc_timer, 1);
 	}
 
@@ -2616,95 +2456,71 @@ void rtw_createbss_cmd_callback(struct r
 	u8 timer_cancelled;
 	struct sta_info *psta = NULL;
 	struct wlan_network *pwlan = NULL;
-	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)pcmd->parmbuf;
 	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
 
 _func_enter_;
 
-	if((pcmd->res != H2C_SUCCESS))
-	{
-		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ********Error: rtw_createbss_cmd_callback  Fail ************\n\n."));
-		_set_timer(&pmlmepriv->assoc_timer, 1 );
+	if ((pcmd->res != H2C_SUCCESS)) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ********Error: rtw_createbss_cmd_callback  Fail ************\n\n."));
+		_set_timer(&pmlmepriv->assoc_timer, 1);
 	}
-
 	_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
 
 #ifdef CONFIG_FW_MLMLE
-       //endian_convert
+       /* endian_convert */
 	pnetwork->Length = le32_to_cpu(pnetwork->Length);
 	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
-	pnetwork->Privacy =le32_to_cpu(pnetwork->Privacy);
+	pnetwork->Privacy = le32_to_cpu(pnetwork->Privacy);
 	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
-	pnetwork->NetworkTypeInUse =le32_to_cpu(pnetwork->NetworkTypeInUse);
+	pnetwork->NetworkTypeInUse = le32_to_cpu(pnetwork->NetworkTypeInUse);
 	pnetwork->Configuration.ATIMWindow = le32_to_cpu(pnetwork->Configuration.ATIMWindow);
-	//pnetwork->Configuration.BeaconPeriod = le32_to_cpu(pnetwork->Configuration.BeaconPeriod);
-	pnetwork->Configuration.DSConfig =le32_to_cpu(pnetwork->Configuration.DSConfig);
-	pnetwork->Configuration.FHConfig.DwellTime=le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
-	pnetwork->Configuration.FHConfig.HopPattern=le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
-	pnetwork->Configuration.FHConfig.HopSet=le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
-	pnetwork->Configuration.FHConfig.Length=le32_to_cpu(pnetwork->Configuration.FHConfig.Length);
+	pnetwork->Configuration.DSConfig = le32_to_cpu(pnetwork->Configuration.DSConfig);
+	pnetwork->Configuration.FHConfig.DwellTime = le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
+	pnetwork->Configuration.FHConfig.HopPattern = le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
+	pnetwork->Configuration.FHConfig.HopSet = le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
+	pnetwork->Configuration.FHConfig.Length = le32_to_cpu(pnetwork->Configuration.FHConfig.Length);
 	pnetwork->Configuration.Length = le32_to_cpu(pnetwork->Configuration.Length);
 	pnetwork->InfrastructureMode = le32_to_cpu(pnetwork->InfrastructureMode);
 	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
 #endif
-
 	spin_lock_bh(&pmlmepriv->lock);
-
-
-	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) )
-	{
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 		psta = rtw_get_stainfo(&padapter->stapriv, pnetwork->MacAddress);
-		if(!psta)
-		{
-		psta = rtw_alloc_stainfo(&padapter->stapriv, pnetwork->MacAddress);
-		if (psta == NULL)
-		{
-			RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nCan't alloc sta_info when createbss_cmd_callback\n"));
-			goto createbss_cmd_fail ;
-		}
+		if (!psta) {
+			psta = rtw_alloc_stainfo(&padapter->stapriv, pnetwork->MacAddress);
+			if (psta == NULL) {
+				RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nCan't alloc sta_info when createbss_cmd_callback\n"));
+				goto createbss_cmd_fail;
+			}
 		}
-
-		rtw_indicate_connect( padapter);
-	}
-	else
-	{
-
+		rtw_indicate_connect(padapter);
+	} else {
 		pwlan = _rtw_alloc_network(pmlmepriv);
 		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
-		if ( pwlan == NULL)
-		{
+		if (pwlan == NULL) {
 			pwlan = rtw_get_oldest_wlan_network(&pmlmepriv->scanned_queue);
-			if( pwlan == NULL)
-			{
-				RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n Error:  can't get pwlan in rtw_joinbss_event_callback \n"));
+			if (pwlan == NULL) {
+				RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n Error:  can't get pwlan in rtw_joinbss_event_callback\n"));
 				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 				goto createbss_cmd_fail;
 			}
 			pwlan->last_scanned = rtw_get_current_time();
-		}
-		else
-		{
+		} else {
 			rtw_list_insert_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
 		}
 
 		pnetwork->Length = get_wlan_bssid_ex_sz(pnetwork);
 		_rtw_memcpy(&(pwlan->network), pnetwork, pnetwork->Length);
-		//pwlan->fixed = true;
-
-		//rtw_list_insert_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
 
-		// copy pdev_network information to	pmlmepriv->cur_network
+		/*  copy pdev_network information to	pmlmepriv->cur_network */
 		_rtw_memcpy(&tgt_network->network, pnetwork, (get_wlan_bssid_ex_sz(pnetwork)));
 
-		// reset DSConfig
-		//tgt_network->network.Configuration.DSConfig = (u32)rtw_ch2freq(pnetwork->Configuration.DSConfig);
-
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
 		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-		// we will set _FW_LINKED when there is one more sat to join us (rtw_stassoc_event_callback)
-
+		/*  we will set _FW_LINKED when there is one more sat to join us (rtw_stassoc_event_callback) */
 	}
 
 createbss_cmd_fail:
@@ -2712,54 +2528,43 @@ createbss_cmd_fail:
 	spin_unlock_bh(&pmlmepriv->lock);
 
 	rtw_free_cmd_obj(pcmd);
-
 _func_exit_;
-
 }
 
-
-
 void rtw_setstaKey_cmdrsp_callback(struct rtw_adapter *padapter, struct cmd_obj *pcmd)
 {
-
-	struct sta_priv * pstapriv = &padapter->stapriv;
-	struct set_stakey_rsp* psetstakey_rsp = (struct set_stakey_rsp*) (pcmd->rsp);
-	struct sta_info*	psta = rtw_get_stainfo(pstapriv, psetstakey_rsp->addr);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct set_stakey_rsp *psetstakey_rsp = (struct set_stakey_rsp *)(pcmd->rsp);
+	struct sta_info *psta = rtw_get_stainfo(pstapriv, psetstakey_rsp->addr);
 
 _func_enter_;
 
-	if(psta==NULL)
-	{
-		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nERROR: rtw_setstaKey_cmdrsp_callback => can't get sta_info \n\n"));
+	if (psta == NULL) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nERROR: rtw_setstaKey_cmdrsp_callback => can't get sta_info\n\n"));
 		goto exit;
 	}
-
-	//psta->aid = psta->mac_id = psetstakey_rsp->keyid; //CAM_ID(CAM_ENTRY)
-
 exit:
-
 	rtw_free_cmd_obj(pcmd);
-
 _func_exit_;
-
 }
+
 void rtw_setassocsta_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
 {
-	struct sta_priv * pstapriv = &padapter->stapriv;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	struct set_assocsta_parm* passocsta_parm = (struct set_assocsta_parm*)(pcmd->parmbuf);
-	struct set_assocsta_rsp* passocsta_rsp = (struct set_assocsta_rsp*) (pcmd->rsp);
-	struct sta_info*	psta = rtw_get_stainfo(pstapriv, passocsta_parm->addr);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct set_assocsta_parm *passocsta_parm = (struct set_assocsta_parm *)(pcmd->parmbuf);
+	struct set_assocsta_rsp *passocsta_rsp = (struct set_assocsta_rsp *)(pcmd->rsp);
+	struct sta_info *psta = rtw_get_stainfo(pstapriv, passocsta_parm->addr);
 
 _func_enter_;
 
-	if(psta==NULL)
-	{
-		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nERROR: setassocsta_cmdrsp_callbac => can't get sta_info \n\n"));
+	if (psta == NULL) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nERROR: setassocsta_cmdrsp_callbac => can't get sta_info\n\n"));
 		goto exit;
 	}
 
-	psta->aid = psta->mac_id = passocsta_rsp->cam_id;
+	psta->aid = passocsta_rsp->cam_id;
+	psta->mac_id = passocsta_rsp->cam_id;
 
 	spin_lock_bh(&pmlmepriv->lock);
 
@@ -2781,9 +2586,8 @@ _func_enter_;
 
 	rtw_free_cmd_obj(pcmd);
 #ifdef CONFIG_MP_INCLUDED
-	padapter->mppriv.workparam.bcompleted=true;
+	padapter->mppriv.workparam.bcompleted = true;
 #endif
 
 _func_exit_;
-
 }
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -529,7 +529,7 @@ _func_exit_;
 //	Description:
 //		Enter the leisure power save mode.
 //
-void LPS_Enter(struct rtw_adapter * padapter)
+void rtw_lps_enter(struct rtw_adapter * padapter)
 {
 	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
@@ -602,7 +602,7 @@ _func_exit_;
 //	Description:
 //		Leave the leisure power save mode.
 //
-void LPS_Leave(struct rtw_adapter * padapter)
+void rtw_lps_leave(struct rtw_adapter * padapter)
 {
 #define LPS_LEAVE_TIMEOUT_MS 100
 
@@ -672,7 +672,7 @@ _func_enter_;
 #endif // CONFIG_P2P_PS
 #ifdef CONFIG_LPS
 		//DBG_8192D("==> leave LPS.......\n");
-		LPS_Leave(Adapter);
+		rtw_lps_leave(Adapter);
 #endif
 	}
 	else
--- a/drivers/staging/rtl8192du/include/rtw_cmd.h
+++ b/drivers/staging/rtl8192du/include/rtw_cmd.h
@@ -995,7 +995,7 @@ enum rtw_h2c_cmd
 	GEN_CMD_CODE(_Write_CAM) ,
 	GEN_CMD_CODE(_setBCNITV),
 	GEN_CMD_CODE(_setMBIDCFG),
-	GEN_CMD_CODE(_JoinBss),   /*14*/
+	GEN_CMD_CODE(_JOINBSS),   /*14*/
 	GEN_CMD_CODE(_DisConnect) , /*15*/
 	GEN_CMD_CODE(_CreateBss) ,
 	GEN_CMD_CODE(_SetOpMode) ,
@@ -1043,7 +1043,7 @@ enum rtw_h2c_cmd
 	GEN_CMD_CODE(_TX_Beacon), /*55*/
 
 	GEN_CMD_CODE(_Set_MLME_EVT), /*56*/
-	GEN_CMD_CODE(_Set_Drv_Extra), /*57*/
+	GEN_CMD_CODE(_SET_DRV_EXTRA), /*57*/
 	GEN_CMD_CODE(_Set_H2C_MSG), /*58*/
 
 	GEN_CMD_CODE(_SetChannelPlan), /*59*/
@@ -1078,7 +1078,7 @@ struct _cmd_callback	rtw_cmd_callback[]
 	{GEN_CMD_CODE(_Write_CAM),	 NULL},
 	{GEN_CMD_CODE(_setBCNITV), NULL},
 	{GEN_CMD_CODE(_setMBIDCFG), NULL},
-	{GEN_CMD_CODE(_JoinBss), &rtw_joinbss_cmd_callback},  /*14*/
+	{GEN_CMD_CODE(_JOINBSS), &rtw_joinbss_cmd_callback},  /*14*/
 	{GEN_CMD_CODE(_DisConnect), &rtw_disassoc_cmd_callback}, /*15*/
 	{GEN_CMD_CODE(_CreateBss), &rtw_createbss_cmd_callback},
 	{GEN_CMD_CODE(_SetOpMode), NULL},
@@ -1126,7 +1126,7 @@ struct _cmd_callback	rtw_cmd_callback[]
 	{GEN_CMD_CODE(_TX_Beacon), NULL},/*55*/
 
 	{GEN_CMD_CODE(_Set_MLME_EVT), NULL},/*56*/
-	{GEN_CMD_CODE(_Set_Drv_Extra), NULL},/*57*/
+	{GEN_CMD_CODE(_SET_DRV_EXTRA), NULL},/*57*/
 	{GEN_CMD_CODE(_Set_H2C_MSG), NULL},/*58*/
 	{GEN_CMD_CODE(_SetChannelPlan), NULL},/*59*/
 	{GEN_CMD_CODE(_LedBlink), NULL},/*60*/
--- a/drivers/staging/rtl8192du/include/rtw_pwrctrl.h
+++ b/drivers/staging/rtl8192du/include/rtw_pwrctrl.h
@@ -311,8 +311,8 @@ rt_rf_power_state RfOnOffDetect(IN	struc
 
 
 #ifdef CONFIG_LPS
-void LPS_Enter(struct rtw_adapter * padapter);
-void LPS_Leave(struct rtw_adapter * padapter);
+void rtw_lps_enter(struct rtw_adapter * padapter);
+void rtw_lps_leave(struct rtw_adapter * padapter);
 #endif
 
 #ifdef CONFIG_RESUME_IN_WORKQUEUE

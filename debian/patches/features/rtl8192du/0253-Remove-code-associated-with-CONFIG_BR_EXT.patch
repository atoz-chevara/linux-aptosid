From 41c3c396c487352f71f21922d90093e2b021f261 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Thu, 13 Mar 2014 18:17:25 -0500
Subject: [PATCH 253/390] Remove code associated with CONFIG_BR_EXT

The kernel provides bridging support.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 Makefile             |    3 +-
 core/rtw_br_ext.c    | 1406 --------------------------------------------------
 core/rtw_cmd.c       |    8 -
 core/rtw_mlme.c      |   24 -
 core/rtw_recv.c      |   36 +-
 core/rtw_xmit.c      |  145 ------
 include/autoconf.h   |    6 -
 include/drv_types.h  |   18 -
 include/rtw_br_ext.h |   63 ---
 os_dep/os_intfs.c    |   46 --
 10 files changed, 6 insertions(+), 1749 deletions(-)
 delete mode 100644 core/rtw_br_ext.c
 delete mode 100644 include/rtw_br_ext.h

--- a/drivers/staging/rtl8192du/Makefile
+++ b/drivers/staging/rtl8192du/Makefile
@@ -132,8 +132,7 @@ rtk_core :=	core/rtw_cmd.o \
 		core/rtw_sta_mgt.o \
 		core/rtw_ap.o \
 		core/rtw_xmit.o	\
-		core/rtw_p2p.o \
-		core/rtw_br_ext.o
+		core/rtw_p2p.o
 
 $(MODULE_NAME)-y += $(rtk_core)
 
--- a/drivers/staging/rtl8192du/core/rtw_br_ext.c
+++ /dev/null
@@ -1,1406 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *
- ******************************************************************************/
-#define _RTW_BR_EXT_C_
-
-#ifdef __KERNEL__
-#include <linux/if_arp.h>
-#include <net/ip.h>
-#include <net/ipx.h>
-#include <linux/atalk.h>
-#include <linux/udp.h>
-#include <linux/if_pppox.h>
-#endif
-
-#include <drv_conf.h>
-#include <drv_types.h>
-#include "rtw_br_ext.h"
-#include <usb_osintf.h>
-
-#ifdef CL_IPV6_PASS
-#ifdef __KERNEL__
-#include <linux/ipv6.h>
-#include <linux/icmpv6.h>
-#include <net/ndisc.h>
-#include <net/checksum.h>
-#endif
-#endif
-
-/* some architectures need an extra header */
-#ifndef csum_ipv6_magic
-#include <net/ip6_checksum.h>
-#endif
-
-#ifdef CONFIG_BR_EXT
-
-#define NAT25_IPV4		01
-#define NAT25_IPV6		02
-#define NAT25_IPX		03
-#define NAT25_APPLE		04
-#define NAT25_PPPOE		05
-
-#define RTL_RELAY_TAG_LEN (ETH_ALEN)
-#define TAG_HDR_LEN		4
-
-#define MAGIC_CODE		0x8186
-#define MAGIC_CODE_LEN	2
-#define WAIT_TIME_PPPOE	5	/*  waiting time for pppoe server in sec */
-
-/*-----------------------------------------------------------------
-  How database records network address:
-	   0    1    2    3    4    5    6    7    8    9   10
-	|----|----|----|----|----|----|----|----|----|----|----|
-  IPv4  |type|                             |      IP addr      |
-  IPX   |type|      Net addr     |          Node addr          |
-  IPX   |type|      Net addr     |Sckt addr|
-  Apple |type| Network |node|
-  PPPoE |type|   SID   |           AC MAC            |
------------------------------------------------------------------*/
-
-/* Find a tag in pppoe frame and return the pointer */
-static inline unsigned char *__nat25_find_pppoe_tag(struct pppoe_hdr *ph, unsigned short type)
-{
-	unsigned char *cur_ptr, *start_ptr;
-	unsigned short tagLen, tagType;
-
-	start_ptr = (unsigned char *)ph->tag;
-	cur_ptr = (unsigned char *)ph->tag;
-	while ((cur_ptr - start_ptr) < ntohs(ph->length)) {
-		/*  prevent un-alignment access */
-		tagType = (unsigned short)((cur_ptr[0] << 8) + cur_ptr[1]);
-		tagLen  = (unsigned short)((cur_ptr[2] << 8) + cur_ptr[3]);
-		if (tagType == type)
-			return cur_ptr;
-		cur_ptr = cur_ptr + TAG_HDR_LEN + tagLen;
-	}
-	return NULL;
-}
-
-static inline int __nat25_add_pppoe_tag(struct sk_buff *skb, struct pppoe_tag *tag)
-{
-	struct pppoe_hdr *ph = (struct pppoe_hdr *)(skb->data + ETH_HLEN);
-	int data_len;
-
-	data_len = tag->tag_len + TAG_HDR_LEN;
-	if (skb_tailroom(skb) < data_len) {
-		ERR_8192D("skb_tailroom() failed in add SID tag!\n");
-		return -1;
-	}
-
-	skb_put(skb, data_len);
-	/*  have a room for new tag */
-	memmove(((unsigned char *)ph->tag + data_len), (unsigned char *)ph->tag, ntohs(ph->length));
-	ph->length = htons(ntohs(ph->length) + data_len);
-	memcpy((unsigned char *)ph->tag, tag, data_len);
-	return data_len;
-}
-
-static int skb_pull_and_merge(struct sk_buff *skb, unsigned char *src, int len)
-{
-	int tail_len;
-	unsigned long end, tail;
-
-	if ((src+len) > skb_tail_pointer(skb) || skb->len < len)
-		return -1;
-
-	tail = (unsigned long)skb_tail_pointer(skb);
-	end = (unsigned long)src+len;
-	if (tail < end)
-		return -1;
-
-	tail_len = (int)(tail-end);
-	if (tail_len > 0)
-		memmove(src, src+len, tail_len);
-
-	skb_trim(skb, skb->len-len);
-	return 0;
-}
-
-static inline unsigned long __nat25_timeout(struct rtw_adapter *priv)
-{
-	unsigned long timeout;
-
-	timeout = jiffies - NAT25_AGEING_TIME*HZ;
-
-	return timeout;
-}
-
-static inline int  __nat25_has_expired(struct rtw_adapter *priv,
-				struct nat25_network_db_entry *fdb)
-{
-	if (time_before_eq(fdb->ageing_timer, __nat25_timeout(priv)))
-		return 1;
-
-	return 0;
-}
-
-static inline void __nat25_generate_ipv4_network_addr(unsigned char *networkAddr,
-				__be32 *ipaddr)
-{
-	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
-
-	networkAddr[0] = NAT25_IPV4;
-	memcpy(networkAddr+7, (unsigned char *)ipaddr, 4);
-}
-
-static inline void __nat25_generate_ipx_network_addr_with_node(unsigned char *networkAddr,
-				__be32 *ipxNetAddr, unsigned char *ipxNodeAddr)
-{
-	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
-
-	networkAddr[0] = NAT25_IPX;
-	memcpy(networkAddr+1, (unsigned char *)ipxNetAddr, 4);
-	memcpy(networkAddr+5, ipxNodeAddr, 6);
-}
-
-static inline void __nat25_generate_ipx_network_addr_with_socket(unsigned char *networkAddr,
-				__be32 *ipxNetAddr, __be16 *ipxSocketAddr)
-{
-	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
-
-	networkAddr[0] = NAT25_IPX;
-	memcpy(networkAddr+1, (unsigned char *)ipxNetAddr, 4);
-	memcpy(networkAddr+5, (unsigned char *)ipxSocketAddr, 2);
-}
-
-static inline void __nat25_generate_apple_network_addr(unsigned char *networkAddr,
-				__be16 *network, unsigned char *node)
-{
-	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
-
-	networkAddr[0] = NAT25_APPLE;
-	memcpy(networkAddr+1, (unsigned char *)network, 2);
-	networkAddr[3] = *node;
-}
-
-static inline void __nat25_generate_pppoe_network_addr(unsigned char *networkAddr,
-				unsigned char *ac_mac, unsigned short *sid)
-{
-	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
-
-	networkAddr[0] = NAT25_PPPOE;
-	memcpy(networkAddr+1, (unsigned char *)sid, 2);
-	memcpy(networkAddr+3, (unsigned char *)ac_mac, 6);
-}
-
-#ifdef CL_IPV6_PASS
-static  void __nat25_generate_ipv6_network_addr(unsigned char *networkAddr,
-				unsigned int *ipaddr)
-{
-	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
-
-	networkAddr[0] = NAT25_IPV6;
-	memcpy(networkAddr+1, (unsigned char *)ipaddr, 16);
-}
-
-static unsigned char *scan_tlv(unsigned char *data, int len, unsigned char tag, unsigned char len8b)
-{
-	while (len > 0) {
-		if (*data == tag && *(data+1) == len8b && len >= len8b*8)
-			return data+2;
-
-		len -= (*(data+1))*8;
-		data += (*(data+1))*8;
-	}
-	return NULL;
-}
-
-static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char *replace_mac)
-{
-	struct icmp6hdr *icmphdr = (struct icmp6hdr *)data;
-	unsigned char *mac;
-
-	if (icmphdr->icmp6_type == NDISC_ROUTER_SOLICITATION) {
-		if (len >= 8) {
-			mac = scan_tlv(&data[8], len-8, 1, 1);
-			if (mac) {
-				DBG_8192D("Router Solicitation, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					  mac[0], mac[1], mac[2], mac[3], mac[4], mac[5],
-					  replace_mac[0], replace_mac[1], replace_mac[2], replace_mac[3], replace_mac[4], replace_mac[5]);
-				memcpy(mac, replace_mac, 6);
-				return 1;
-			}
-		}
-	} else if (icmphdr->icmp6_type == NDISC_ROUTER_ADVERTISEMENT) {
-		if (len >= 16) {
-			mac = scan_tlv(&data[16], len-16, 1, 1);
-			if (mac) {
-				DBG_8192D("Router Advertisement, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					  mac[0], mac[1], mac[2], mac[3], mac[4], mac[5],
-					  replace_mac[0], replace_mac[1], replace_mac[2], replace_mac[3], replace_mac[4], replace_mac[5]);
-				memcpy(mac, replace_mac, 6);
-				return 1;
-			}
-		}
-	} else if (icmphdr->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION) {
-		if (len >= 24) {
-			mac = scan_tlv(&data[24], len-24, 1, 1);
-			if (mac) {
-				DBG_8192D("Neighbor Solicitation, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					  mac[0], mac[1], mac[2], mac[3],
-					  mac[4], mac[5], replace_mac[0],
-					  replace_mac[1], replace_mac[2],
-					  replace_mac[3], replace_mac[4],
-					  replace_mac[5]);
-				memcpy(mac, replace_mac, 6);
-				return 1;
-			}
-		}
-	} else if (icmphdr->icmp6_type == NDISC_NEIGHBOUR_ADVERTISEMENT) {
-		if (len >= 24) {
-			mac = scan_tlv(&data[24], len-24, 2, 1);
-			if (mac) {
-				DBG_8192D("Neighbor Advertisement, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					  mac[0], mac[1], mac[2], mac[3],
-					  mac[4], mac[5], replace_mac[0],
-					  replace_mac[1], replace_mac[2],
-					  replace_mac[3], replace_mac[4],
-					  replace_mac[5]);
-				memcpy(mac, replace_mac, 6);
-				return 1;
-			}
-		}
-	} else if (icmphdr->icmp6_type == NDISC_REDIRECT) {
-		if (len >= 40) {
-			mac = scan_tlv(&data[40], len-40, 2, 1);
-			if (mac) {
-				DBG_8192D("Redirect,  replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					  mac[0], mac[1], mac[2], mac[3],
-					  mac[4], mac[5], replace_mac[0],
-					  replace_mac[1], replace_mac[2],
-					  replace_mac[3], replace_mac[4],
-					  replace_mac[5]);
-				memcpy(mac, replace_mac, 6);
-				return 1;
-			}
-		}
-	}
-	return 0;
-}
-
-static void convert_ipv6_mac_to_mc(struct sk_buff *skb)
-{
-	struct ipv6hdr *iph = (struct ipv6hdr *)(skb->data + ETH_HLEN);
-	unsigned char *dst_mac = skb->data;
-
-	dst_mac[0] = 0x33;
-	dst_mac[1] = 0x33;
-	memcpy(&dst_mac[2], &iph->daddr.s6_addr32[3], 4);
-	#if defined(__LINUX_2_6__)
-	/*modified by qinjunjie, warning:should not remove next line*/
-	skb->pkt_type = PACKET_MULTICAST;
-	#endif
-}
-#endif /* CL_IPV6_PASS */
-
-static inline int __nat25_network_hash(unsigned char *networkAddr)
-{
-	if (networkAddr[0] == NAT25_IPV4) {
-		unsigned long x;
-
-		x = networkAddr[7] ^ networkAddr[8] ^ networkAddr[9] ^ networkAddr[10];
-
-		return x & (NAT25_HASH_SIZE - 1);
-	} else if (networkAddr[0] == NAT25_IPX) {
-		unsigned long x;
-
-		x = networkAddr[1] ^ networkAddr[2] ^ networkAddr[3] ^ networkAddr[4] ^ networkAddr[5] ^
-			networkAddr[6] ^ networkAddr[7] ^ networkAddr[8] ^ networkAddr[9] ^ networkAddr[10];
-
-		return x & (NAT25_HASH_SIZE - 1);
-	} else if (networkAddr[0] == NAT25_APPLE) {
-		unsigned long x;
-
-		x = networkAddr[1] ^ networkAddr[2] ^ networkAddr[3];
-
-		return x & (NAT25_HASH_SIZE - 1);
-	} else if (networkAddr[0] == NAT25_PPPOE) {
-		unsigned long x;
-
-		x = networkAddr[0] ^ networkAddr[1] ^ networkAddr[2] ^ networkAddr[3] ^ networkAddr[4] ^ networkAddr[5] ^ networkAddr[6] ^ networkAddr[7] ^ networkAddr[8];
-
-		return x & (NAT25_HASH_SIZE - 1);
-	}
-#ifdef CL_IPV6_PASS
-	else if (networkAddr[0] == NAT25_IPV6) {
-		unsigned long x;
-
-		x = networkAddr[1] ^ networkAddr[2] ^ networkAddr[3] ^ networkAddr[4] ^ networkAddr[5] ^
-			networkAddr[6] ^ networkAddr[7] ^ networkAddr[8] ^ networkAddr[9] ^ networkAddr[10] ^
-			networkAddr[11] ^ networkAddr[12] ^ networkAddr[13] ^ networkAddr[14] ^ networkAddr[15] ^
-			networkAddr[16];
-
-		return x & (NAT25_HASH_SIZE - 1);
-	}
-#endif
-	else {
-		unsigned long x = 0;
-		int i;
-
-		for (i = 0; i < MAX_NETWORK_ADDR_LEN; i++)
-			x ^= networkAddr[i];
-
-		return x & (NAT25_HASH_SIZE - 1);
-	}
-}
-
-static inline void __network_hash_link(struct rtw_adapter *priv,
-				struct nat25_network_db_entry *ent, int hash)
-{
-	/*  Caller must hold spin_lock_bh already! */
-
-	ent->next_hash = priv->nethash[hash];
-	if (ent->next_hash != NULL)
-		ent->next_hash->pprev_hash = &ent->next_hash;
-	priv->nethash[hash] = ent;
-	ent->pprev_hash = &priv->nethash[hash];
-}
-
-static inline void __network_hash_unlink(struct nat25_network_db_entry *ent)
-{
-	/*  Caller must hold spin_lock_bh already! */
-
-	*(ent->pprev_hash) = ent->next_hash;
-	if (ent->next_hash != NULL)
-		ent->next_hash->pprev_hash = ent->pprev_hash;
-	ent->next_hash = NULL;
-	ent->pprev_hash = NULL;
-}
-
-static int __nat25_db_network_lookup_and_replace(struct rtw_adapter *priv,
-				struct sk_buff *skb, unsigned char *networkAddr)
-{
-	struct nat25_network_db_entry *db;
-	spin_lock_bh(&priv->br_ext_lock);
-
-	db = priv->nethash[__nat25_network_hash(networkAddr)];
-	while (db != NULL) {
-		if (!memcmp(db->networkAddr, networkAddr, MAX_NETWORK_ADDR_LEN)) {
-			if (!__nat25_has_expired(priv, db)) {
-				/*  replace the destination mac address */
-				memcpy(skb->data, db->macaddr, ETH_ALEN);
-				atomic_inc(&db->use_count);
-
-#ifdef CL_IPV6_PASS
-				DBG_8192D("NAT25: Lookup M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
-							"%02x%02x%02x%02x%02x%02x\n",
-					  db->macaddr[0],
-					  db->macaddr[1],
-					  db->macaddr[2],
-					  db->macaddr[3],
-					  db->macaddr[4],
-					  db->macaddr[5],
-					  db->networkAddr[0],
-					  db->networkAddr[1],
-					  db->networkAddr[2],
-					  db->networkAddr[3],
-					  db->networkAddr[4],
-					  db->networkAddr[5],
-					  db->networkAddr[6],
-					  db->networkAddr[7],
-					  db->networkAddr[8],
-					  db->networkAddr[9],
-					  db->networkAddr[10],
-					  db->networkAddr[11],
-					  db->networkAddr[12],
-					  db->networkAddr[13],
-					  db->networkAddr[14],
-					  db->networkAddr[15],
-					  db->networkAddr[16]);
-#else
-				DBG_8192D("NAT25: Lookup M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-					  db->macaddr[0],
-					  db->macaddr[1],
-					  db->macaddr[2],
-					  db->macaddr[3],
-					  db->macaddr[4],
-					  db->macaddr[5],
-					  db->networkAddr[0],
-					  db->networkAddr[1],
-					  db->networkAddr[2],
-					  db->networkAddr[3],
-					  db->networkAddr[4],
-					  db->networkAddr[5],
-					  db->networkAddr[6],
-					  db->networkAddr[7],
-					  db->networkAddr[8],
-					  db->networkAddr[9],
-					  db->networkAddr[10]);
-#endif
-			}
-			spin_unlock_bh(&priv->br_ext_lock);
-			return 1;
-		}
-
-		db = db->next_hash;
-	}
-
-	spin_unlock_bh(&priv->br_ext_lock);
-	return 0;
-}
-
-static void __nat25_db_network_insert(struct rtw_adapter *priv,
-				unsigned char *macaddr, unsigned char *networkAddr)
-{
-	struct nat25_network_db_entry *db;
-	int hash;
-	spin_lock_bh(&priv->br_ext_lock);
-
-	hash = __nat25_network_hash(networkAddr);
-	db = priv->nethash[hash];
-	while (db != NULL) {
-		if (!memcmp(db->networkAddr, networkAddr, MAX_NETWORK_ADDR_LEN)) {
-			memcpy(db->macaddr, macaddr, ETH_ALEN);
-			db->ageing_timer = jiffies;
-			spin_unlock_bh(&priv->br_ext_lock);
-			return;
-		}
-
-		db = db->next_hash;
-	}
-
-	db = (struct nat25_network_db_entry *)kmalloc(sizeof(*db), GFP_KERNEL);
-	if (db == NULL) {
-		spin_unlock_bh(&priv->br_ext_lock);
-		return;
-	}
-
-	memcpy(db->networkAddr, networkAddr, MAX_NETWORK_ADDR_LEN);
-	memcpy(db->macaddr, macaddr, ETH_ALEN);
-	atomic_set(&db->use_count, 1);
-	db->ageing_timer = jiffies;
-
-	__network_hash_link(priv, db, hash);
-
-	spin_unlock_bh(&priv->br_ext_lock);
-}
-
-static void __nat25_db_print(struct rtw_adapter *priv)
-{
-	spin_lock_bh(&priv->br_ext_lock);
-
-#ifdef BR_EXT_DEBUG
-	static int counter;
-	int i, j;
-	struct nat25_network_db_entry *db;
-
-	counter++;
-	if ((counter % 16) != 0)
-		return;
-
-	for (i = 0, j = 0; i < NAT25_HASH_SIZE; i++) {
-		db = priv->nethash[i];
-
-		while (db != NULL) {
-#ifdef CL_IPV6_PASS
-			panic_printk("NAT25: DB(%d) H(%02d) C(%d) M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-				     j, i,
-				     atomic_read(&db->use_count),
-				     db->macaddr[0], db->macaddr[1],
-				     db->macaddr[2], db->macaddr[3],
-				     db->macaddr[4], db->macaddr[5],
-				     db->networkAddr[0], db->networkAddr[1],
-				     db->networkAddr[2], db->networkAddr[3],
-				     db->networkAddr[4], db->networkAddr[5],
-				     db->networkAddr[6], db->networkAddr[7],
-				     db->networkAddr[8], db->networkAddr[9],
-				     db->networkAddr[10], db->networkAddr[11],
-				     db->networkAddr[12], db->networkAddr[13],
-				     db->networkAddr[14], db->networkAddr[15],
-				     db->networkAddr[16]);
-#else
-			panic_printk("NAT25: DB(%d) H(%02d) C(%d) M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-				     j, i, atomic_read(&db->use_count),
-				     db->macaddr[0], db->macaddr[1],
-				     db->macaddr[2], db->macaddr[3],
-				     db->macaddr[4], db->macaddr[5],
-				     db->networkAddr[0], db->networkAddr[1],
-				     db->networkAddr[2], db->networkAddr[3],
-				     db->networkAddr[4], db->networkAddr[5],
-				     db->networkAddr[6], db->networkAddr[7],
-				     db->networkAddr[8], db->networkAddr[9],
-				     db->networkAddr[10]);
-#endif
-			j++;
-
-			db = db->next_hash;
-		}
-	}
-#endif
-
-	spin_unlock_bh(&priv->br_ext_lock);
-}
-
-/*
- *	NAT2.5 interface
- */
-
-void nat25_db_cleanup(struct rtw_adapter *priv)
-{
-	int i;
-	spin_lock_bh(&priv->br_ext_lock);
-
-	for (i = 0; i < NAT25_HASH_SIZE; i++) {
-		struct nat25_network_db_entry *f;
-		f = priv->nethash[i];
-		while (f != NULL) {
-			struct nat25_network_db_entry *g;
-
-			g = f->next_hash;
-			if (priv->scdb_entry == f) {
-				memset(priv->scdb_mac, 0, ETH_ALEN);
-				memset(priv->scdb_ip, 0, 4);
-				priv->scdb_entry = NULL;
-			}
-			__network_hash_unlink(f);
-			kfree(f);
-
-			f = g;
-		}
-	}
-
-	spin_unlock_bh(&priv->br_ext_lock);
-}
-
-void nat25_db_expire(struct rtw_adapter *priv)
-{
-	int i;
-
-	spin_lock_bh(&priv->br_ext_lock);
-
-	for (i = 0; i < NAT25_HASH_SIZE; i++) {
-		struct nat25_network_db_entry *f;
-		f = priv->nethash[i];
-
-		while (f != NULL) {
-			struct nat25_network_db_entry *g;
-			g = f->next_hash;
-
-			if (__nat25_has_expired(priv, f)) {
-				if (atomic_dec_and_test(&f->use_count)) {
-#ifdef BR_EXT_DEBUG
-#ifdef CL_IPV6_PASS
-					panic_printk("NAT25 Expire H(%02d) M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
-							"%02x%02x%02x%02x%02x%02x\n",
-						i,
-						f->macaddr[0],
-						f->macaddr[1],
-						f->macaddr[2],
-						f->macaddr[3],
-						f->macaddr[4],
-						f->macaddr[5],
-						f->networkAddr[0],
-						f->networkAddr[1],
-						f->networkAddr[2],
-						f->networkAddr[3],
-						f->networkAddr[4],
-						f->networkAddr[5],
-						f->networkAddr[6],
-						f->networkAddr[7],
-						f->networkAddr[8],
-						f->networkAddr[9],
-						f->networkAddr[10],
-						f->networkAddr[11],
-						f->networkAddr[12],
-						f->networkAddr[13],
-						f->networkAddr[14],
-						f->networkAddr[15],
-						f->networkAddr[16]);
-#else
-
-					panic_printk("NAT25 Expire H(%02d) M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-						     i, f->macaddr[0],
-						     f->macaddr[1],
-						     f->macaddr[2],
-						     f->macaddr[3],
-						     f->macaddr[4],
-						     f->macaddr[5],
-						     f->networkAddr[0],
-						     f->networkAddr[1],
-						     f->networkAddr[2],
-						     f->networkAddr[3],
-						     f->networkAddr[4],
-						     f->networkAddr[5],
-						     f->networkAddr[6],
-						     f->networkAddr[7],
-						     f->networkAddr[8],
-						     f->networkAddr[9],
-						     f->networkAddr[10]);
-#endif
-#endif
-					if (priv->scdb_entry == f) {
-						memset(priv->scdb_mac, 0, ETH_ALEN);
-						memset(priv->scdb_ip, 0, 4);
-						priv->scdb_entry = NULL;
-					}
-					__network_hash_unlink(f);
-					kfree(f);
-				}
-			}
-			f = g;
-		}
-	}
-	spin_unlock_bh(&priv->br_ext_lock);
-}
-
-#ifdef SUPPORT_TX_MCAST2UNI
-static int checkIPMcAndReplace(struct rtw_adapter *priv, struct sk_buff *skb, unsigned int *dst_ip)
-{
-	struct stat_info	*pstat;
-	struct list_head	*phead, *plist;
-	int i;
-
-	phead = &priv->asoc_list;
-	plist = phead->next;
-
-	while (plist != phead) {
-		pstat = list_entry(plist, struct stat_info, asoc_list);
-		plist = plist->next;
-
-		if (pstat->ipmc_num == 0)
-			continue;
-
-		for (i = 0; i < MAX_IP_MC_ENTRY; i++) {
-			if (pstat->ipmc[i].used && !memcmp(&pstat->ipmc[i].mcmac[3], ((unsigned char *)dst_ip)+1, 3)) {
-				memcpy(skb->data, pstat->ipmc[i].mcmac, ETH_ALEN);
-				return 1;
-			}
-		}
-	}
-	return 0;
-}
-#endif
-
-int nat25_db_handle(struct rtw_adapter *priv, struct sk_buff *skb, int method)
-{
-	unsigned short protocol;
-	unsigned char networkAddr[MAX_NETWORK_ADDR_LEN];
-
-	if (skb == NULL)
-		return -1;
-
-	if ((method <= NAT25_MIN) || (method >= NAT25_MAX))
-		return -1;
-
-	protocol = be16_to_cpu(*((__be16 *)(skb->data + 2 * ETH_ALEN)));
-
-	/*---------------------------------------------------*/
-	/*                 Handle IP frame                   */
-	/*---------------------------------------------------*/
-	if (protocol == ETH_P_IP) {
-		struct iphdr *iph = (struct iphdr *)(skb->data + ETH_HLEN);
-
-		if (((unsigned char *)(iph) + (iph->ihl<<2)) >= (skb->data + ETH_HLEN + skb->len)) {
-			ERR_8192D("NAT25: malformed IP packet !\n");
-			return -1;
-		}
-		switch (method) {
-		case NAT25_CHECK:
-			return -1;
-		case NAT25_INSERT:
-			/* some muticast with source IP is all zero, maybe other case is illegal */
-			/* in class A, B, C, host address is all zero or all one is illegal */
-			if (iph->saddr == 0)
-				return 0;
-			DBG_8192D("NAT25: Insert IP, SA =%08x, DA =%08x\n", iph->saddr, iph->daddr);
-			__nat25_generate_ipv4_network_addr(networkAddr, &iph->saddr);
-			/* record source IP address and , source mac address into db */
-			__nat25_db_network_insert(priv, skb->data+ETH_ALEN, networkAddr);
-
-			__nat25_db_print(priv);
-			return 0;
-		case NAT25_LOOKUP:
-			DBG_8192D("NAT25: Lookup IP, SA =%08x, DA =%08x\n", iph->saddr, iph->daddr);
-#ifdef SUPPORT_TX_MCAST2UNI
-			if (priv->pshare->rf_ft_var.mc2u_disable ||
-			    ((((OPMODE & (WIFI_STATION_STATE|WIFI_ASOC_STATE)) ==
-			    (WIFI_STATION_STATE|WIFI_ASOC_STATE)) &&
-			    !checkIPMcAndReplace(priv, skb, &iph->daddr)) ||
-			    (OPMODE & WIFI_ADHOC_STATE)))
-#endif
-			{
-				__nat25_generate_ipv4_network_addr(networkAddr, &iph->daddr);
-
-				if (!__nat25_db_network_lookup_and_replace(priv, skb, networkAddr)) {
-					if (*((unsigned char *)&iph->daddr + 3) == 0xff) {
-						/*  L2 is unicast but L3 is broadcast, make L2 bacome broadcast */
-						DBG_8192D("NAT25: Set DA as boardcast\n");
-						memset(skb->data, 0xff, ETH_ALEN);
-					} else {
-						/*  forward unknown IP packet to upper TCP/IP */
-						DBG_8192D("NAT25: Replace DA with BR's MAC\n");
-						if ((*(u32 *)priv->br_mac) == 0 && (*(u16 *)(priv->br_mac+4)) == 0) {
-							printk("Re-init netdev_br_init() due to br_mac == 0!\n");
-							netdev_br_init(priv->pnetdev);
-						}
-						memcpy(skb->data, priv->br_mac, ETH_ALEN);
-					}
-				}
-			}
-			return 0;
-
-		default:
-			return -1;
-		}
-
-	/*---------------------------------------------------*/
-	/*                 Handle ARP frame                  */
-	/*---------------------------------------------------*/
-	} else if (protocol == ETH_P_ARP) {
-		struct arphdr *arp = (struct arphdr *)(skb->data + ETH_HLEN);
-		unsigned char *arp_ptr = (unsigned char *)(arp + 1);
-		__be32 *target;
-		__be32 *sender;
-
-		if (arp->ar_pro != __constant_htons(ETH_P_IP)) {
-			ERR_8192D("NAT25: arp protocol unknown (%4x)!\n", arp->ar_pro);
-			return -1;
-		}
-
-		switch (method) {
-		case NAT25_CHECK:
-			return 0;	/*  skb_copy for all ARP frame */
-		case NAT25_INSERT:
-			DBG_8192D("NAT25: Insert ARP, MAC =%02x%02x%02x%02x%02x%02x\n", arp_ptr[0],
-				  arp_ptr[1], arp_ptr[2], arp_ptr[3], arp_ptr[4], arp_ptr[5]);
-
-			/*  change to ARP sender mac address to wlan STA address */
-			memcpy(arp_ptr, GET_MY_HWADDR(priv), ETH_ALEN);
-
-			arp_ptr += arp->ar_hln;
-			sender = (__be32 *)arp_ptr;
-
-			__nat25_generate_ipv4_network_addr(networkAddr, sender);
-
-			__nat25_db_network_insert(priv, skb->data+ETH_ALEN, networkAddr);
-
-			__nat25_db_print(priv);
-			return 0;
-		case NAT25_LOOKUP:
-			DBG_8192D("NAT25: Lookup ARP\n");
-
-			arp_ptr += arp->ar_hln;
-			sender = (__be32 *)arp_ptr;
-			arp_ptr += (arp->ar_hln + arp->ar_pln);
-			target = (__be32 *)arp_ptr;
-
-			__nat25_generate_ipv4_network_addr(networkAddr, target);
-
-			__nat25_db_network_lookup_and_replace(priv, skb, networkAddr);
-
-			/*  change to ARP target mac address to Lookup result */
-			arp_ptr = (unsigned char *)(arp + 1);
-			arp_ptr += (arp->ar_hln + arp->ar_pln);
-			memcpy(arp_ptr, skb->data, ETH_ALEN);
-			return 0;
-		default:
-			return -1;
-		}
-
-	/*---------------------------------------------------*/
-	/*         Handle IPX and Apple Talk frame           */
-	/*---------------------------------------------------*/
-	} else if ((protocol == ETH_P_IPX) ||
-		   (protocol <= ETH_FRAME_LEN)) {
-		unsigned char ipx_header[2] = {0xFF, 0xFF};
-		struct ipxhdr	*ipx = NULL;
-		struct elapaarp	*ea = NULL;
-		struct ddpehdr	*ddp = NULL;
-		unsigned char *frameptr = skb->data + ETH_HLEN;
-
-		if (protocol == ETH_P_IPX) {
-			DBG_8192D("NAT25: Protocol = IPX (Ethernet II)\n");
-			ipx = (struct ipxhdr *)frameptr;
-		} else if (protocol <= ETH_FRAME_LEN) {
-			if (!memcmp(ipx_header, frameptr, 2)) {
-				DBG_8192D("NAT25: Protocol = IPX (Ethernet 802.3)\n");
-				ipx = (struct ipxhdr *)frameptr;
-			} else {
-				unsigned char ipx_8022_type =  0xE0;
-				unsigned char snap_8022_type = 0xAA;
-
-				if (*frameptr == snap_8022_type) {
-					unsigned char ipx_snap_id[5] = {0x0, 0x0, 0x0, 0x81, 0x37};		/*  IPX SNAP ID */
-					unsigned char aarp_snap_id[5] = {0x00, 0x00, 0x00, 0x80, 0xF3};	/*  Apple Talk AARP SNAP ID */
-					unsigned char ddp_snap_id[5] = {0x08, 0x00, 0x07, 0x80, 0x9B};	/*  Apple Talk DDP SNAP ID */
-
-					frameptr += 3;	/*  eliminate the 802.2 header */
-
-					if (!memcmp(ipx_snap_id, frameptr, 5)) {
-						frameptr += 5;	/*  eliminate the SNAP header */
-
-						DBG_8192D("NAT25: Protocol = IPX (Ethernet SNAP)\n");
-						ipx = (struct ipxhdr *)frameptr;
-					} else if (!memcmp(aarp_snap_id, frameptr, 5)) {
-						frameptr += 5;	/*  eliminate the SNAP header */
-
-						ea = (struct elapaarp *)frameptr;
-					} else if (!memcmp(ddp_snap_id, frameptr, 5)) {
-						frameptr += 5;	/*  eliminate the SNAP header */
-
-						ddp = (struct ddpehdr *)frameptr;
-					} else {
-						ERR_8192D("NAT25: Protocol = Ethernet SNAP %02x%02x%02x%02x%02x\n", frameptr[0],
-							  frameptr[1], frameptr[2], frameptr[3], frameptr[4]);
-						return -1;
-					}
-				} else if (*frameptr == ipx_8022_type) {
-					frameptr += 3;	/*  eliminate the 802.2 header */
-
-					if (!memcmp(ipx_header, frameptr, 2)) {
-						DBG_8192D("NAT25: Protocol = IPX (Ethernet 802.2)\n");
-						ipx = (struct ipxhdr *)frameptr;
-					} else {
-						return -1;
-					}
-				} else {
-					return -1;
-				}
-			}
-		} else {
-			return -1;
-		}
-
-		/*   IPX   */
-		if (ipx != NULL) {
-			switch (method) {
-			case NAT25_CHECK:
-				if (!memcmp(skb->data+ETH_ALEN, ipx->ipx_source.node, ETH_ALEN)) {
-					DBG_8192D("NAT25: Check IPX skb_copy\n");
-					return 0;
-				}
-				return -1;
-			case NAT25_INSERT:
-				DBG_8192D("NAT25: Insert IPX, Dest =%08x,%02x%02x%02x%02x%02x%02x,%04x Source =%08x,%02x%02x%02x%02x%02x%02x,%04x\n",
-					  ipx->ipx_dest.net,
-					  ipx->ipx_dest.node[0],
-					  ipx->ipx_dest.node[1],
-					  ipx->ipx_dest.node[2],
-					  ipx->ipx_dest.node[3],
-					  ipx->ipx_dest.node[4],
-					  ipx->ipx_dest.node[5],
-					  ipx->ipx_dest.sock,
-					  ipx->ipx_source.net,
-					  ipx->ipx_source.node[0],
-					  ipx->ipx_source.node[1],
-					  ipx->ipx_source.node[2],
-					  ipx->ipx_source.node[3],
-					  ipx->ipx_source.node[4],
-					  ipx->ipx_source.node[5],
-					  ipx->ipx_source.sock);
-
-				if (!memcmp(skb->data+ETH_ALEN, ipx->ipx_source.node, ETH_ALEN)) {
-					DBG_8192D("NAT25: Use IPX Net, and Socket as network addr\n");
-
-					__nat25_generate_ipx_network_addr_with_socket(networkAddr, &ipx->ipx_source.net, &ipx->ipx_source.sock);
-
-					/*  change IPX source node addr to wlan STA address */
-					memcpy(ipx->ipx_source.node, GET_MY_HWADDR(priv), ETH_ALEN);
-				} else {
-					__nat25_generate_ipx_network_addr_with_node(networkAddr, &ipx->ipx_source.net, ipx->ipx_source.node);
-				}
-
-				__nat25_db_network_insert(priv, skb->data+ETH_ALEN, networkAddr);
-
-				__nat25_db_print(priv);
-				return 0;
-			case NAT25_LOOKUP:
-				if (!memcmp(GET_MY_HWADDR(priv), ipx->ipx_dest.node, ETH_ALEN)) {
-					DBG_8192D("NAT25: Lookup IPX, Modify Destination IPX Node addr\n");
-
-					__nat25_generate_ipx_network_addr_with_socket(networkAddr, &ipx->ipx_dest.net, &ipx->ipx_dest.sock);
-
-					__nat25_db_network_lookup_and_replace(priv, skb, networkAddr);
-
-					/*  replace IPX destination node addr with Lookup destination MAC addr */
-					memcpy(ipx->ipx_dest.node, skb->data, ETH_ALEN);
-				} else {
-					__nat25_generate_ipx_network_addr_with_node(networkAddr, &ipx->ipx_dest.net, ipx->ipx_dest.node);
-
-					__nat25_db_network_lookup_and_replace(priv, skb, networkAddr);
-				}
-				return 0;
-			default:
-				return -1;
-			}
-
-		/*   AARP   */
-		} else if (ea != NULL) {
-			/* Sanity check fields. */
-			if (ea->hw_len != ETH_ALEN || ea->pa_len != AARP_PA_ALEN) {
-				ERR_8192D("NAT25: Appletalk AARP Sanity check fail!\n");
-				return -1;
-			}
-
-			switch (method) {
-			case NAT25_CHECK:
-				return 0;
-			case NAT25_INSERT:
-				/*  change to AARP source mac address to wlan STA address */
-				memcpy(ea->hw_src, GET_MY_HWADDR(priv), ETH_ALEN);
-
-				DBG_8192D("NAT25: Insert AARP, Source =%d,%d Destination =%d,%d\n",
-					  ea->pa_src_net,
-					  ea->pa_src_node,
-					  ea->pa_dst_net,
-					  ea->pa_dst_node);
-
-				__nat25_generate_apple_network_addr(networkAddr, &ea->pa_src_net, &ea->pa_src_node);
-
-				__nat25_db_network_insert(priv, skb->data+ETH_ALEN, networkAddr);
-
-				__nat25_db_print(priv);
-				return 0;
-			case NAT25_LOOKUP:
-				DBG_8192D("NAT25: Lookup AARP, Source =%d,%d Destination =%d,%d\n",
-					  ea->pa_src_net, ea->pa_src_node,
-					  ea->pa_dst_net, ea->pa_dst_node);
-
-				__nat25_generate_apple_network_addr(networkAddr, &ea->pa_dst_net, &ea->pa_dst_node);
-
-				__nat25_db_network_lookup_and_replace(priv, skb, networkAddr);
-
-				/*  change to AARP destination mac address to Lookup result */
-				memcpy(ea->hw_dst, skb->data, ETH_ALEN);
-				return 0;
-			default:
-				return -1;
-			}
-
-		/*   DDP   */
-		} else if (ddp != NULL) {
-			switch (method) {
-			case NAT25_CHECK:
-				return -1;
-			case NAT25_INSERT:
-				DBG_8192D("NAT25: Insert DDP, Source =%d,%d Destination =%d,%d\n",
-					  ddp->deh_snet, ddp->deh_snode,
-					  ddp->deh_dnet, ddp->deh_dnode);
-
-				__nat25_generate_apple_network_addr(networkAddr, &ddp->deh_snet, &ddp->deh_snode);
-
-				__nat25_db_network_insert(priv, skb->data+ETH_ALEN, networkAddr);
-
-				__nat25_db_print(priv);
-				return 0;
-			case NAT25_LOOKUP:
-				DBG_8192D("NAT25: Lookup DDP, Source =%d,%d Destination =%d,%d\n",
-					  ddp->deh_snet, ddp->deh_snode,
-					  ddp->deh_dnet, ddp->deh_dnode);
-
-				__nat25_generate_apple_network_addr(networkAddr, &ddp->deh_dnet, &ddp->deh_dnode);
-
-				__nat25_db_network_lookup_and_replace(priv, skb, networkAddr);
-				return 0;
-			default:
-				return -1;
-			}
-		}
-		return -1;
-
-	/*---------------------------------------------------*/
-	/*                Handle PPPoE frame                 */
-	/*---------------------------------------------------*/
-	} else if ((protocol == ETH_P_PPP_DISC) ||
-		(protocol == ETH_P_PPP_SES)) {
-		struct pppoe_hdr *ph = (struct pppoe_hdr *)(skb->data + ETH_HLEN);
-		unsigned short *magic;
-
-		switch (method) {
-		case NAT25_CHECK:
-			if (ph->sid == 0)
-				return 0;
-			return 1;
-		case NAT25_INSERT:
-			if (ph->sid == 0) {	/*  Discovery phase according to tag */
-				if (ph->code == PADI_CODE || ph->code == PADR_CODE) {
-					if (priv->eth_br_ext_info.addPPPoETag) {
-						struct pppoe_tag *tag, *old_tag;
-						unsigned char tag_buf[40];
-						int old_tag_len = 0;
-
-						tag = (struct pppoe_tag *)tag_buf;
-						old_tag = (struct pppoe_tag *)__nat25_find_pppoe_tag(ph, ntohs(PTT_RELAY_SID));
-						if (old_tag) { /*  if SID existed, copy old value and delete it */
-							old_tag_len = ntohs(old_tag->tag_len);
-							if (old_tag_len+TAG_HDR_LEN+MAGIC_CODE_LEN+RTL_RELAY_TAG_LEN > sizeof(tag_buf)) {
-								ERR_8192D("SID tag length too long!\n");
-								return -1;
-							}
-							memcpy(tag->tag_data+MAGIC_CODE_LEN+RTL_RELAY_TAG_LEN,
-							       old_tag->tag_data, old_tag_len);
-							if (skb_pull_and_merge(skb, (unsigned char *)old_tag, TAG_HDR_LEN+old_tag_len) < 0) {
-								ERR_8192D("call skb_pull_and_merge() failed in PADI/R packet!\n");
-								return -1;
-							}
-							ph->length = htons(ntohs(ph->length)-TAG_HDR_LEN-old_tag_len);
-						}
-						tag->tag_type = PTT_RELAY_SID;
-						tag->tag_len = htons(MAGIC_CODE_LEN+RTL_RELAY_TAG_LEN+old_tag_len);
-						/*  insert the magic_code+client mac in relay tag */
-						magic = (unsigned short *)tag->tag_data;
-						*magic = htons(MAGIC_CODE);
-						memcpy(tag->tag_data+MAGIC_CODE_LEN, skb->data+ETH_ALEN, ETH_ALEN);
-
-						/* Add relay tag */
-						if (__nat25_add_pppoe_tag(skb, tag) < 0)
-							return -1;
-						DBG_8192D("NAT25: Insert PPPoE, forward %s packet\n",
-							  (ph->code == PADI_CODE ? "PADI" : "PADR"));
-					} else { /*  not add relay tag */
-						if (priv->pppoe_connection_in_progress &&
-						    memcmp(skb->data+ETH_ALEN, priv->pppoe_addr, ETH_ALEN)) {
-							ERR_8192D("Discard PPPoE packet due to another PPPoE connection is in progress!\n");
-							return -2;
-						}
-						if (priv->pppoe_connection_in_progress == 0)
-							memcpy(priv->pppoe_addr, skb->data+ETH_ALEN, ETH_ALEN);
-						priv->pppoe_connection_in_progress = WAIT_TIME_PPPOE;
-					}
-				} else {
-					return -1;
-				}
-			} else {	/*  session phase */
-				DBG_8192D("NAT25: Insert PPPoE, insert session packet to %s\n", skb->dev->name);
-				__nat25_generate_pppoe_network_addr(networkAddr, skb->data, &(ph->sid));
-				__nat25_db_network_insert(priv, skb->data+ETH_ALEN, networkAddr);
-				__nat25_db_print(priv);
-				if (!priv->eth_br_ext_info.addPPPoETag &&
-				    priv->pppoe_connection_in_progress &&
-				    !memcmp(skb->data+ETH_ALEN, priv->pppoe_addr, ETH_ALEN))
-					priv->pppoe_connection_in_progress = 0;
-			}
-			return 0;
-		case NAT25_LOOKUP:
-			if (ph->code == PADO_CODE || ph->code == PADS_CODE) {
-				if (priv->eth_br_ext_info.addPPPoETag) {
-					struct pppoe_tag *tag;
-					unsigned char *ptr;
-					unsigned short tagType, tagLen;
-					int offset = 0;
-
-					ptr = __nat25_find_pppoe_tag(ph, ntohs(PTT_RELAY_SID));
-					if (ptr == NULL) {
-						ERR_8192D("Fail to find PTT_RELAY_SID in FADO!\n");
-						return -1;
-					}
-					tag = (struct pppoe_tag *)ptr;
-					tagType = (unsigned short)((ptr[0] << 8) + ptr[1]);
-					tagLen = (unsigned short)((ptr[2] << 8) + ptr[3]);
-					if ((tagType != ntohs(PTT_RELAY_SID)) || (tagLen < (MAGIC_CODE_LEN+RTL_RELAY_TAG_LEN))) {
-						ERR_8192D("Invalid PTT_RELAY_SID tag length [%d]!\n", tagLen);
-						return -1;
-					}
-
-					magic = (unsigned short *)tag->tag_data;
-					if (ntohs(*magic) != MAGIC_CODE) {
-						ERR_8192D("Can't find MAGIC_CODE in %s packet!\n",
-							  (ph->code == PADO_CODE ? "PADO" : "PADS"));
-						return -1;
-					}
-
-					memcpy(skb->data, tag->tag_data+MAGIC_CODE_LEN, ETH_ALEN);
-
-					if (tagLen > MAGIC_CODE_LEN+RTL_RELAY_TAG_LEN)
-						offset = TAG_HDR_LEN;
-
-					if (skb_pull_and_merge(skb, ptr+offset, TAG_HDR_LEN+MAGIC_CODE_LEN+RTL_RELAY_TAG_LEN-offset) < 0) {
-						ERR_8192D("call skb_pull_and_merge() failed in PADO packet!\n");
-						return -1;
-					}
-					ph->length = htons(ntohs(ph->length)-(TAG_HDR_LEN+MAGIC_CODE_LEN+RTL_RELAY_TAG_LEN-offset));
-					if (offset > 0)
-						tag->tag_len = htons(tagLen-MAGIC_CODE_LEN-RTL_RELAY_TAG_LEN);
-
-					DBG_8192D("NAT25: Lookup PPPoE, forward %s Packet from %s\n",
-						  (ph->code == PADO_CODE ? "PADO" : "PADS"), skb->dev->name);
-				} else { /*  not add relay tag */
-					if (!priv->pppoe_connection_in_progress) {
-						ERR_8192D("Discard PPPoE packet due to no connection in progresss!\n");
-						return -1;
-					}
-					memcpy(skb->data, priv->pppoe_addr, ETH_ALEN);
-					priv->pppoe_connection_in_progress = WAIT_TIME_PPPOE;
-				}
-			} else {
-				if (ph->sid != 0) {
-					DBG_8192D("NAT25: Lookup PPPoE, lookup session packet from %s\n", skb->dev->name);
-					__nat25_generate_pppoe_network_addr(networkAddr, skb->data+ETH_ALEN, &(ph->sid));
-					__nat25_db_network_lookup_and_replace(priv, skb, networkAddr);
-					__nat25_db_print(priv);
-				} else {
-					return -1;
-				}
-			}
-			return 0;
-		default:
-			return -1;
-		}
-
-	/*---------------------------------------------------*/
-	/*                 Handle EAP frame                  */
-	/*---------------------------------------------------*/
-	} else if (protocol == 0x888e) {
-		switch (method) {
-		case NAT25_CHECK:
-			return -1;
-		case NAT25_INSERT:
-			return 0;
-		case NAT25_LOOKUP:
-			return 0;
-		default:
-			return -1;
-		}
-
-	/*---------------------------------------------------*/
-	/*         Handle C-Media proprietary frame          */
-	/*---------------------------------------------------*/
-	} else if ((protocol == 0xe2ae) ||
-		(protocol == 0xe2af)) {
-		switch (method) {
-		case NAT25_CHECK:
-			return -1;
-		case NAT25_INSERT:
-			return 0;
-		case NAT25_LOOKUP:
-			return 0;
-		default:
-			return -1;
-		}
-	}
-
-	/*---------------------------------------------------*/
-	/*         Handle IPV6 frame								  */
-	/*---------------------------------------------------*/
-#ifdef CL_IPV6_PASS
-	else if (protocol == ETH_P_IPV6) {
-		struct ipv6hdr *iph = (struct ipv6hdr *)(skb->data + ETH_HLEN);
-
-		if (sizeof(*iph) >= (skb->len - ETH_HLEN)) {
-			ERR_8192D("NAT25: malformed IPv6 packet !\n");
-			return -1;
-		}
-
-		switch (method) {
-		case NAT25_CHECK:
-			if (skb->data[0] & 1)
-				return 0;
-			return -1;
-		case NAT25_INSERT:
-			DBG_8192D("NAT25: Insert IP, SA =%8ph, DA = %8ph\n",
-				  iph->saddr.s6_addr16,
-				  iph->daddr.s6_addr16);
-
-			if (memcmp(&iph->saddr, "\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0", 16)) {
-				__nat25_generate_ipv6_network_addr(networkAddr, (unsigned int *)&iph->saddr);
-				__nat25_db_network_insert(priv, skb->data+ETH_ALEN, networkAddr);
-				__nat25_db_print(priv);
-
-				if (iph->nexthdr == IPPROTO_ICMPV6 &&
-				    skb->len > (ETH_HLEN +  sizeof(*iph) + 4)) {
-					if (update_nd_link_layer_addr(skb->data + ETH_HLEN + sizeof(*iph),
-								      skb->len - ETH_HLEN - sizeof(*iph),
-								      GET_MY_HWADDR(priv))) {
-						struct icmp6hdr  *hdr = (struct icmp6hdr *)(skb->data + ETH_HLEN + sizeof(*iph));
-						hdr->icmp6_cksum = 0;
-						hdr->icmp6_cksum = csum_ipv6_magic(&iph->saddr, &iph->daddr,
-										be16_to_cpu(iph->payload_len),
-										IPPROTO_ICMPV6,
-										csum_partial((__u8 *)hdr, be16_to_cpu(iph->payload_len), 0));
-					}
-				}
-			}
-			return 0;
-		case NAT25_LOOKUP:
-			DBG_8192D("NAT25: Lookup IP, SA =%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x,DA =%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n",
-				  iph->saddr.s6_addr16[0], iph->saddr.s6_addr16[1],
-				  iph->saddr.s6_addr16[2], iph->saddr.s6_addr16[3],
-				  iph->saddr.s6_addr16[4], iph->saddr.s6_addr16[5],
-				  iph->saddr.s6_addr16[6], iph->saddr.s6_addr16[7],
-				  iph->daddr.s6_addr16[0], iph->daddr.s6_addr16[1],
-				  iph->daddr.s6_addr16[2], iph->daddr.s6_addr16[3],
-				  iph->daddr.s6_addr16[4], iph->daddr.s6_addr16[5],
-				  iph->daddr.s6_addr16[6], iph->daddr.s6_addr16[7]);
-			__nat25_generate_ipv6_network_addr(networkAddr, (unsigned int *)&iph->daddr);
-			if (!__nat25_db_network_lookup_and_replace(priv, skb, networkAddr)) {
-#ifdef SUPPORT_RX_UNI2MCAST
-				if (iph->daddr.s6_addr[0] == 0xff)
-					convert_ipv6_mac_to_mc(skb);
-#endif
-			}
-			return 0;
-		default:
-			return -1;
-		}
-	}
-#endif	/*  CL_IPV6_PASS */
-
-	return -1;
-}
-
-int nat25_handle_frame(struct rtw_adapter *priv, struct sk_buff *skb)
-{
-#ifdef BR_EXT_DEBUG
-	if ((!priv->eth_br_ext_info.nat25_disable) && (!(skb->data[0] & 1))) {
-		panic_printk("NAT25: Input Frame: DA =%02x%02x%02x%02x%02x%02x SA =%02x%02x%02x%02x%02x%02x\n",
-			     skb->data[0], skb->data[1], skb->data[2],
-			     skb->data[3], skb->data[4], skb->data[5],
-			     skb->data[6], skb->data[7], skb->data[8],
-			     skb->data[9], skb->data[10], skb->data[11]);
-	}
-#endif
-
-	if (!(skb->data[0] & 1)) {
-		int is_vlan_tag = 0, i, retval = 0;
-		unsigned short vlan_hdr = 0;
-		unsigned short protocol;
-
-		protocol = be16_to_cpu(*((__be16 *)(skb->data + 2 * ETH_ALEN)));
-		if (protocol == ETH_P_8021Q) {
-			is_vlan_tag = 1;
-			vlan_hdr = *((unsigned short *)(skb->data+ETH_ALEN*2+2));
-			for (i = 0; i < 6; i++)
-				*((unsigned short *)(skb->data+ETH_ALEN*2+2-i*2)) = *((unsigned short *)(skb->data+ETH_ALEN*2-2-i*2));
-			skb_pull(skb, 4);
-		}
-
-		if (!priv->eth_br_ext_info.nat25_disable) {
-			spin_lock_bh(&priv->br_ext_lock);
-			/*
-			 *	This function look up the destination network address from
-			 *	the NAT2.5 database. Return value = -1 means that the
-			 *	corresponding network protocol is NOT support.
-			 */
-			if (!priv->eth_br_ext_info.nat25sc_disable &&
-			    (be16_to_cpu(*((__be16 *)(skb->data+ETH_ALEN*2))) == ETH_P_IP) &&
-			    !memcmp(priv->scdb_ip, skb->data+ETH_HLEN+16, 4)) {
-				memcpy(skb->data, priv->scdb_mac, ETH_ALEN);
-
-				spin_unlock_bh(&priv->br_ext_lock);
-			} else {
-				spin_unlock_bh(&priv->br_ext_lock);
-
-				retval = nat25_db_handle(priv, skb, NAT25_LOOKUP);
-			}
-		} else {
-			if (((be16_to_cpu(*((__be16 *)(skb->data+ETH_ALEN*2))) == ETH_P_IP) &&
-			     !memcmp(priv->br_ip, skb->data+ETH_HLEN+16, 4)) ||
-			     ((be16_to_cpu(*((__be16 *)(skb->data+ETH_ALEN*2))) == ETH_P_ARP) &&
-			     !memcmp(priv->br_ip, skb->data+ETH_HLEN+24, 4))) {
-				/*  for traffic to upper TCP/IP */
-				retval = nat25_db_handle(priv, skb, NAT25_LOOKUP);
-			}
-		}
-
-		if (is_vlan_tag) {
-			skb_push(skb, 4);
-			for (i = 0; i < 6; i++)
-				*((unsigned short *)(skb->data+i*2)) = *((unsigned short *)(skb->data+4+i*2));
-			*((__be16 *)(skb->data+ETH_ALEN*2)) = __constant_htons(ETH_P_8021Q);
-			*((__be16 *)(skb->data+ETH_ALEN*2+2)) = cpu_to_be16(vlan_hdr);
-		}
-
-		if (retval == -1)
-			return -1;
-	}
-	return 0;
-}
-
-#define SERVER_PORT			67
-#define CLIENT_PORT			68
-#define DHCP_MAGIC			0x63825363
-#define BROADCAST_FLAG		0x8000
-
-struct dhcp_message {
-	u_int8_t op;
-	u_int8_t htype;
-	u_int8_t hlen;
-	u_int8_t hops;
-	u_int32_t xid;
-	u_int16_t secs;
-	__be16 flags;
-	u_int32_t ciaddr;
-	u_int32_t yiaddr;
-	u_int32_t siaddr;
-	u_int32_t giaddr;
-	u_int8_t chaddr[16];
-	u_int8_t sname[64];
-	u_int8_t file[128];
-	__be32 cookie;
-	u_int8_t options[308]; /* 312 - cookie */
-};
-
-void dhcp_flag_bcast(struct rtw_adapter *priv, struct sk_buff *skb)
-{
-	if (skb == NULL)
-		return;
-
-	if (!priv->eth_br_ext_info.dhcp_bcst_disable) {
-		__be16 protocol = *((__be16 *)(skb->data + 2 * ETH_ALEN));
-
-		if (protocol == __constant_htons(ETH_P_IP)) { /*  IP */
-			struct iphdr *iph = (struct iphdr *)(skb->data + ETH_HLEN);
-
-			if (iph->protocol == IPPROTO_UDP) { /*  UDP */
-				struct udphdr *udph = (struct udphdr *)((SIZE_PTR)iph + (iph->ihl << 2));
-
-				if ((udph->source == __constant_htons(CLIENT_PORT)) &&
-				    (udph->dest == __constant_htons(SERVER_PORT))) { /*  DHCP request */
-					struct dhcp_message *dhcph =
-						(struct dhcp_message *)((SIZE_PTR)udph + sizeof(struct udphdr));
-					u32 cookie = be32_to_cpu((__be32)dhcph->cookie);
-
-					if (cookie == DHCP_MAGIC) { /*  match magic word */
-						if (!(dhcph->flags & htons(BROADCAST_FLAG))) { /*  if not broadcast */
-							register int sum = 0;
-
-							DBG_8192D("DHCP: change flag of DHCP request to broadcast.\n");
-							/*  or BROADCAST flag */
-							dhcph->flags |= htons(BROADCAST_FLAG);
-							/*  recalculate checksum */
-							sum = ~(udph->check) & 0xffff;
-							sum += be16_to_cpu(dhcph->flags);
-							while (sum >> 16)
-								sum = (sum & 0xffff) + (sum >> 16);
-							udph->check = ~sum;
-						}
-					}
-				}
-			}
-		}
-	}
-}
-
-void *scdb_findentry(struct rtw_adapter *priv, unsigned char *macaddr,
-				unsigned char *ipaddr)
-{
-	unsigned char networkAddr[MAX_NETWORK_ADDR_LEN];
-	struct nat25_network_db_entry *db;
-	int hash;
-
-	__nat25_generate_ipv4_network_addr(networkAddr, (__be32 *)ipaddr);
-	hash = __nat25_network_hash(networkAddr);
-	db = priv->nethash[hash];
-	while (db != NULL) {
-		if (!memcmp(db->networkAddr, networkAddr, MAX_NETWORK_ADDR_LEN))
-			return (void *)db;
-
-		db = db->next_hash;
-	}
-
-	return NULL;
-}
-
-#endif	/*  CONFIG_BR_EXT */
--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -22,9 +22,6 @@
 #include <cmd_osdep.h>
 #include <mlme_osdep.h>
 #include <rtw_cmd.h>
-#ifdef CONFIG_BR_EXT
-#include <rtw_br_ext.h>
-#endif /* CONFIG_BR_EXT */
 #include <usb_osintf.h>
 /*
 Caller and the rtw_cmd_thread can protect cmd_q by spin_lock.
@@ -1903,11 +1900,6 @@ void rtw_disassoc_cmd_callback(struct rt
 		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ***Error: disconnect_cmd_callback Fail ***\n."));
 		return;
 	}
-#ifdef CONFIG_BR_EXT
-	else /* clear bridge database */
-		nat25_db_cleanup(padapter);
-#endif /* CONFIG_BR_EXT */
-
 	/*  free cmd */
 	rtw_free_cmd_obj(pcmd);
 }
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -1994,9 +1994,6 @@ static void rtw_auto_scan_handler(struct
 
 void rtw_dynamic_check_timer_handlder(struct rtw_adapter *adapter)
 {
-#ifdef CONFIG_BR_EXT
-	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
-#endif
 	struct registry_priv *pregistrypriv = &adapter->registrypriv;
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter *pbuddy_adapter = adapter->pbuddy_adapter;
@@ -2036,27 +2033,6 @@ void rtw_dynamic_check_timer_handlder(st
 			rtw_auto_scan_handler(adapter);
 		}
 	}
-
-#ifdef CONFIG_BR_EXT
-
-	rcu_read_lock();
-
-	if (rcu_dereference(adapter->pnetdev->rx_handler_data) &&
-	    check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE)) {
-		/*  expire NAT2.5 entry */
-		nat25_db_expire(adapter);
-
-		if (adapter->pppoe_connection_in_progress > 0) {
-			adapter->pppoe_connection_in_progress--;
-		}
-
-		/*  due to rtw_dynamic_check_timer_handlder() is called every 2 seconds */
-		if (adapter->pppoe_connection_in_progress > 0) {
-			adapter->pppoe_connection_in_progress--;
-		}
-	}
-	rcu_read_unlock();
-#endif /*  CONFIG_BR_EXT */
 }
 
 #ifdef CONFIG_IOCTL_CFG80211
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -1960,38 +1960,12 @@ static int amsdu_to_msdu(struct rtw_adap
 		}
 
 		/* Indicat the packets to upper layer */
-		{
+		sub_skb->protocol =
+		    eth_type_trans(sub_skb, padapter->pnetdev);
+		sub_skb->dev = padapter->pnetdev;
 
-#ifdef CONFIG_BR_EXT
-			/*  Insert NAT2.5 RX here! */
-			struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-			void *br_port = NULL;
-
-			rcu_read_lock();
-			br_port =
-			    rcu_dereference(padapter->pnetdev->rx_handler_data);
-			rcu_read_unlock();
-
-			if (br_port &&
-			    (check_fwstate(pmlmepriv, WIFI_STATION_STATE |
-					   WIFI_ADHOC_STATE) == true)) {
-				if (nat25_handle_frame(padapter, sub_skb) == -1) {
-					/* priv->ext_stats.rx_data_drops++; */
-					/* DEBUG_ERR("RX DROP: nat25_handle_frame fail!\n"); */
-					/* return FAIL; */
-
-					/*  bypass this frame to upper layer!! */
-				}
-			}
-#endif /*  CONFIG_BR_EXT */
-
-			sub_skb->protocol =
-			    eth_type_trans(sub_skb, padapter->pnetdev);
-			sub_skb->dev = padapter->pnetdev;
-
-			sub_skb->ip_summed = CHECKSUM_NONE;
-			netif_rx(sub_skb);
-		}
+		sub_skb->ip_summed = CHECKSUM_NONE;
+		netif_rx(sub_skb);
 	}
 
 exit:
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -1689,131 +1689,6 @@ void rtw_init_hwxmits(struct hw_xmit *ph
 
 }
 
-#ifdef CONFIG_BR_EXT
-static int rtw_br_client_tx(struct rtw_adapter *padapter, struct sk_buff **pskb)
-{
-	struct sk_buff *skb = *pskb;
-	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
-	int res, is_vlan_tag = 0, i, do_nat25 = 1;
-	unsigned short vlan_hdr = 0;
-	void *br_port = NULL;
-
-	rcu_read_lock();
-	br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
-	rcu_read_unlock();
-	spin_lock_bh(&padapter->br_ext_lock);
-	if (!(skb->data[0] & 1) && br_port &&
-	    memcmp(skb->data+MACADDRLEN, padapter->br_mac, MACADDRLEN) &&
-	    *((__be16 *)(skb->data+MACADDRLEN*2)) != __constant_htons(ETH_P_8021Q) &&
-	    *((__be16 *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP) &&
-	    !memcmp(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN) && padapter->scdb_entry) {
-		memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
-		padapter->scdb_entry->ageing_timer = jiffies;
-		spin_unlock_bh(&padapter->br_ext_lock);
-	} else {
-		if (*((__be16 *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_8021Q)) {
-			is_vlan_tag = 1;
-			vlan_hdr = *((unsigned short *)(skb->data+MACADDRLEN*2+2));
-			for (i = 0; i < 6; i++)
-				*((unsigned short *)(skb->data+MACADDRLEN*2+2-i*2)) = *((unsigned short *)(skb->data+MACADDRLEN*2-2-i*2));
-			skb_pull(skb, 4);
-		}
-		/* if SA == br_mac && skb == IP  => copy SIP to br_ip ?? why */
-		if (!memcmp(skb->data+MACADDRLEN, padapter->br_mac, MACADDRLEN) &&
-		    (*((__be16 *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)))
-			memcpy(padapter->br_ip, skb->data+WLAN_ETHHDR_LEN+12, 4);
-
-		if (*((__be16 *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)) {
-			if (memcmp(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN)) {
-				padapter->scdb_entry = (struct nat25_network_db_entry *)
-						       scdb_findentry(padapter,
-						       skb->data+MACADDRLEN,
-						       skb->data+WLAN_ETHHDR_LEN+12);
-				if (padapter->scdb_entry != NULL) {
-					memcpy(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN);
-					memcpy(padapter->scdb_ip, skb->data+WLAN_ETHHDR_LEN+12, 4);
-					padapter->scdb_entry->ageing_timer = jiffies;
-					do_nat25 = 0;
-				}
-			} else {
-				if (padapter->scdb_entry) {
-					padapter->scdb_entry->ageing_timer = jiffies;
-					do_nat25 = 0;
-				} else {
-					memset(padapter->scdb_mac, 0, MACADDRLEN);
-					memset(padapter->scdb_ip, 0, 4);
-				}
-			}
-		}
-		spin_unlock_bh(&padapter->br_ext_lock);
-		if (do_nat25) {
-			if (nat25_db_handle(padapter, skb, NAT25_CHECK) == 0) {
-				struct sk_buff *newskb;
-
-				if (is_vlan_tag) {
-					skb_push(skb, 4);
-					for (i = 0; i < 6; i++)
-						*((unsigned short *)(skb->data+i*2)) = *((unsigned short *)(skb->data+4+i*2));
-					*((__be16 *)(skb->data+MACADDRLEN*2)) = __constant_htons(ETH_P_8021Q);
-					*((unsigned short *)(skb->data+MACADDRLEN*2+2)) = vlan_hdr;
-				}
-
-				newskb = skb_copy(skb, GFP_ATOMIC);
-				if (newskb == NULL) {
-					ERR_8192D("TX DROP: skb_copy fail!\n");
-					return -1;
-				}
-				dev_kfree_skb_any(skb);
-
-				*pskb = skb = newskb;
-				if (is_vlan_tag) {
-					vlan_hdr = *((unsigned short *)(skb->data+MACADDRLEN*2+2));
-					for (i = 0; i < 6; i++)
-						*((unsigned short *)(skb->data+MACADDRLEN*2+2-i*2)) = *((unsigned short *)(skb->data+MACADDRLEN*2-2-i*2));
-					skb_pull(skb, 4);
-				}
-			}
-
-			if (skb_is_nonlinear(skb))
-				ERR_8192D("%s(): skb_is_nonlinear!!\n", __func__);
-
-			res = skb_linearize(skb);
-			if (res < 0) {
-				ERR_8192D("TX DROP: skb_linearize fail!\n");
-				return -1;
-			}
-
-			res = nat25_db_handle(padapter, skb, NAT25_INSERT);
-			if (res < 0) {
-				if (res == -2) {
-					ERR_8192D("TX DROP: nat25_db_handle fail!\n");
-					return -1;
-				}
-				return 0;
-			}
-		}
-		memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
-
-		dhcp_flag_bcast(padapter, skb);
-
-		if (is_vlan_tag) {
-			skb_push(skb, 4);
-			for (i = 0; i < 6; i++)
-				*((unsigned short *)(skb->data+i*2)) = *((unsigned short *)(skb->data+4+i*2));
-			*((__be16 *)(skb->data+MACADDRLEN*2)) = __constant_htons(ETH_P_8021Q);
-			*((unsigned short *)(skb->data+MACADDRLEN*2+2)) = vlan_hdr;
-		}
-	}
-	/*  check if SA is equal to our MAC */
-	if (memcmp(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN)) {
-		ERR_8192D("TX DROP: untransformed frame SA:%02X%02X%02X%02X%02X%02X!\n",
-			  skb->data[6], skb->data[7], skb->data[8], skb->data[9], skb->data[10], skb->data[11]);
-		return -1;
-	}
-	return 0;
-}
-#endif	/*  CONFIG_BR_EXT */
-
 static void do_queue_select(struct rtw_adapter	*padapter, struct pkt_attrib *pattrib)
 {
 	u8 qsel;
@@ -1836,10 +1711,6 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 {
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	struct xmit_frame *pxmitframe = NULL;
-#ifdef CONFIG_BR_EXT
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
-	void *br_port = NULL;
-#endif	/*  CONFIG_BR_EXT */
 	s32 res;
 
 	pxmitframe = rtw_alloc_xmitframe(pxmitpriv);
@@ -1851,22 +1722,6 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 		return -1;
 	}
 
-#ifdef CONFIG_BR_EXT
-
-	rcu_read_lock();
-	br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
-	rcu_read_unlock();
-
-	if (br_port && check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true) {
-		res = rtw_br_client_tx(padapter, ppkt);
-		if (res == -1) {
-			rtw_free_xmitframe(pxmitpriv, pxmitframe);
-			return -1;
-		}
-	}
-
-#endif	/*  CONFIG_BR_EXT */
-
 	res = update_attrib(padapter, *ppkt, &pxmitframe->attrib);
 	if (res == _FAIL) {
 		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit: update attrib fail\n"));
--- a/drivers/staging/rtl8192du/include/autoconf.h
+++ b/drivers/staging/rtl8192du/include/autoconf.h
@@ -52,12 +52,6 @@
 
 #define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable,*/
 
-#define CONFIG_BR_EXT	1	/*  Enable NAT2.5 support for STA mode interface with a L2 Bridge */
-#ifdef CONFIG_BR_EXT
-#define CONFIG_BR_EXT_BRNAME	"br0"
-#endif	/*  CONFIG_BR_EXT */
-
-
 //#define CONFIG_CONCURRENT_MODE 1
 #ifdef CONFIG_CONCURRENT_MODE
 	#define CONFIG_TSF_RESET_OFFLOAD 1			/*  For 2 PORT TSF SYNC. */
--- a/drivers/staging/rtl8192du/include/drv_types.h
+++ b/drivers/staging/rtl8192du/include/drv_types.h
@@ -53,10 +53,6 @@
 #include <drvext_api.h>
 #endif
 
-#ifdef CONFIG_BR_EXT
-#include <rtw_br_ext.h>
-#endif	/*  CONFIG_BR_EXT */
-
 #ifdef CONFIG_IOCTL_CFG80211
 	#include "ioctl_cfg80211.h"
 #endif /* CONFIG_IOCTL_CFG80211 */
@@ -394,20 +390,6 @@ struct rtw_adapter {
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	u8 DualMacConcurrent; /*  1: DMSP 0:DMDP */
 #endif
-
-#ifdef CONFIG_BR_EXT
-	spinlock_t			br_ext_lock;
-	struct nat25_network_db_entry	*nethash[NAT25_HASH_SIZE];
-	int				pppoe_connection_in_progress;
-	unsigned char			pppoe_addr[MACADDRLEN];
-	unsigned char			scdb_mac[MACADDRLEN];
-	unsigned char			scdb_ip[4];
-	struct nat25_network_db_entry	*scdb_entry;
-	unsigned char			br_mac[MACADDRLEN];
-	unsigned char			br_ip[4];
-
-	struct br_ext_info		eth_br_ext_info;
-#endif	/*  CONFIG_BR_EXT */
 };
 
 #define adapter_to_dvobj(adapter) (adapter->dvobj)
--- a/drivers/staging/rtl8192du/include/rtw_br_ext.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *
- ******************************************************************************/
-#ifndef _RTW_BR_EXT_H_
-#define _RTW_BR_EXT_H_
-
-#define CL_IPV6_PASS		1
-#define MACADDRLEN		6
-#define GET_MY_HWADDR(padapter)		((padapter)->eeprompriv.mac_addr)
-
-#define NAT25_HASH_BITS		4
-#define NAT25_HASH_SIZE		(1 << NAT25_HASH_BITS)
-#define NAT25_AGEING_TIME	300
-
-#ifdef CL_IPV6_PASS
-#define MAX_NETWORK_ADDR_LEN	17
-#else
-#define MAX_NETWORK_ADDR_LEN	11
-#endif
-
-struct nat25_network_db_entry
-{
-	struct nat25_network_db_entry	*next_hash;
-	struct nat25_network_db_entry	**pprev_hash;
-	atomic_t		use_count;
-	unsigned char		macaddr[6];
-	unsigned long		ageing_timer;
-	unsigned char		networkAddr[MAX_NETWORK_ADDR_LEN];
-};
-
-enum NAT25_METHOD {
-	NAT25_MIN,
-	NAT25_CHECK,
-	NAT25_INSERT,
-	NAT25_LOOKUP,
-	NAT25_PARSE,
-	NAT25_MAX
-};
-
-struct br_ext_info {
-	unsigned int	nat25_disable;
-	unsigned int	macclone_enable;
-	unsigned int	dhcp_bcst_disable;
-	int		addPPPoETag;		/*  1: Add PPPoE relay-SID, 0: disable */
-	unsigned char	nat25_dmzMac[MACADDRLEN];
-	unsigned int	nat25sc_disable;
-};
-
-void nat25_db_cleanup(struct rtw_adapter *priv);
-
-#endif /*  _RTW_BR_EXT_H_ */
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -27,10 +27,6 @@
 #include <rtl8192d_hal.h>
 #include <linux/vmalloc.h>
 
-#ifdef CONFIG_BR_EXT
-#include <rtw_br_ext.h>
-#endif /* CONFIG_BR_EXT */
-
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Realtek Wireless Lan Driver");
 MODULE_AUTHOR("Realtek Semiconductor Corp.");
@@ -1124,14 +1120,8 @@ u8 rtw_init_drv_sw(struct rtw_adapter *p
 	rtw_hal_dm_init(padapter);
 	rtw_hal_sw_led_init(padapter);
 
-#ifdef CONFIG_BR_EXT
-	spin_lock_init(&padapter->br_ext_lock);
-#endif	/*  CONFIG_BR_EXT */
-
 exit:
-
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-rtw_init_drv_sw\n"));
-
 	return ret8;
 }
 
@@ -1888,34 +1878,6 @@ void rtw_drv_if2_stop(struct rtw_adapter
 }
 #endif /* end of CONFIG_CONCURRENT_MODE */
 
-#ifdef CONFIG_BR_EXT
-void netdev_br_init(struct net_device *netdev)
-{
-	struct rtw_adapter *adapter = (struct rtw_adapter *)rtw_netdev_priv(netdev);
-
-	rcu_read_lock();
-
-	if (rcu_dereference(adapter->pnetdev->rx_handler_data)) {
-		struct net_device *br_netdev;
-		struct net *devnet = NULL;
-
-		devnet = dev_net(netdev);
-
-		br_netdev = dev_get_by_name(devnet, CONFIG_BR_EXT_BRNAME);
-
-		if (br_netdev) {
-			memcpy(adapter->br_mac, br_netdev->dev_addr, ETH_ALEN);
-			dev_put(br_netdev);
-		} else
-			printk("%s()-%d: dev_get_by_name(%s) failed!", __func__, __LINE__, CONFIG_BR_EXT_BRNAME);
-	}
-
-	adapter->eth_br_ext_info.addPPPoETag = 1;
-
-	rcu_read_unlock();
-}
-#endif /* CONFIG_BR_EXT */
-
 int _netdev_open(struct net_device *pnetdev)
 {
 	uint status;
@@ -1988,10 +1950,6 @@ int _netdev_open(struct net_device *pnet
 	else
 		rtw_netif_wake_queue(pnetdev);
 
-#ifdef CONFIG_BR_EXT
-	netdev_br_init(pnetdev);
-#endif	/*  CONFIG_BR_EXT */
-
 netdev_open_normal_process:
 
 	#ifdef CONFIG_CONCURRENT_MODE
@@ -2155,10 +2113,6 @@ static int netdev_close(struct net_devic
 		rtw_led_control(padapter, LED_CTL_POWER_OFF);
 	}
 
-#ifdef CONFIG_BR_EXT
-	nat25_db_cleanup(padapter);
-#endif	/*  CONFIG_BR_EXT */
-
 #ifdef CONFIG_P2P
 	#ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled == true)

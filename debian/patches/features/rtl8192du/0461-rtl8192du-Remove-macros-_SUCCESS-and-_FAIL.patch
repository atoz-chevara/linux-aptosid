From fb3533c4c958005748e6596a67a71098b30a7482 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Thu, 3 Apr 2014 19:48:41 -0500
Subject: [PATCH 461/470] rtl8192du: Remove macros _SUCCESS and _FAIL

These are set to 1 and 0 respectively.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_ap.c           |  20 +--
 core/rtw_cmd.c          | 222 +++++++++++++++----------------
 core/rtw_efuse.c        |  26 ++--
 core/rtw_ieee80211.c    |  32 ++---
 core/rtw_io.c           |  10 +-
 core/rtw_ioctl_set.c    |  82 ++++++------
 core/rtw_mlme.c         |  42 +++---
 core/rtw_mlme_ext.c     | 338 ++++++++++++++++++++++++------------------------
 core/rtw_p2p.c          |  14 +-
 core/rtw_pwrctrl.c      |  20 +--
 core/rtw_recv.c         | 164 +++++++++++------------
 core/rtw_security.c     |  36 +++---
 core/rtw_sta_mgt.c      |  12 +-
 core/rtw_wlan_util.c    |  28 ++--
 core/rtw_xmit.c         |  88 ++++++-------
 hal/hal_com.c           |   4 +-
 hal/hal_intf.c          |  30 ++---
 hal/rtl8192d_cmd.c      |   8 +-
 hal/rtl8192d_hal_init.c |  48 +++----
 hal/rtl8192d_phycfg.c   |  36 +++---
 hal/rtl8192d_rf6052.c   |   6 +-
 hal/rtl8192du_recv.c    |   6 +-
 hal/rtl8192du_xmit.c    |  20 +--
 hal/usb_halinit.c       |  60 ++++-----
 hal/usb_ops_linux.c     |  26 ++--
 include/hal_intf.h      |   2 +-
 include/osdep_service.h |   2 -
 include/rtw_mp.h        |   8 +-
 include/wifi.h          |   2 +-
 os_dep/ioctl_cfg80211.c |  48 +++----
 os_dep/ioctl_linux.c    |  52 ++++----
 os_dep/os_intfs.c       |  66 +++++-----
 os_dep/osdep_service.c  |   8 +-
 os_dep/recv_linux.c     |  12 +-
 os_dep/usb_intf.c       |  42 +++---
 os_dep/usb_ops_linux.c  |  12 +-
 os_dep/xmit_linux.c     |   6 +-
 37 files changed, 818 insertions(+), 820 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_ap.c
+++ b/drivers/staging/rtl8192du/core/rtw_ap.c
@@ -428,7 +428,7 @@ void	expire_timeout_chk(struct rtw_adapt
 
 		/* issue null data to check sta alive*/
 		for (i = 0; i < chk_alive_num; i++) {
-			int ret = _FAIL;
+			int ret = 0;
 
 			psta = rtw_get_stainfo_by_offset(pstapriv,
 							 chk_alive_list[i]);
@@ -441,7 +441,7 @@ void	expire_timeout_chk(struct rtw_adapt
 						     0, 3, 50);
 
 			psta->keep_alive_trycnt++;
-			if (ret == _SUCCESS) {
+			if (ret == 1) {
 				DBG_8192D("asoc check, sta(%pM) is alive\n",
 					  psta->hwaddr);
 				psta->expire_to = pstapriv->expire_to;
@@ -1037,7 +1037,7 @@ static void start_bss_network(struct rtw
 		/* other case will  tx beacon when bcn interrupt coming in.
 		 * issue beacon frame
 		 */
-		if (send_beacon(padapter) == _FAIL)
+		if (send_beacon(padapter) == 0)
 			DBG_8192D("issue_beacon, fail!\n");
 	}
 
@@ -1047,7 +1047,7 @@ static void start_bss_network(struct rtw
 
 int rtw_check_beacon_data(struct rtw_adapter *padapter, u8 *pbuf,  int len)
 {
-	int ret = _SUCCESS;
+	int ret = 1;
 	u8 *p;
 	u8 *ht_caps_ie = NULL;
 	u8 *ht_info_ie = NULL;
@@ -1082,10 +1082,10 @@ int rtw_check_beacon_data(struct rtw_ada
 	DBG_8192D("%s, len =%d\n", __func__, len);
 
 	if (!check_fwstate(pmlmepriv, WIFI_AP_STATE))
-		return _FAIL;
+		return 0;
 
 	if (len > MAX_IE_SZ)
-		return _FAIL;
+		return 0;
 
 	pbss_network->IELength = len;
 
@@ -1094,7 +1094,7 @@ int rtw_check_beacon_data(struct rtw_ada
 	memcpy(ie, pbuf, pbss_network->IELength);
 
 	if (pbss_network->InfrastructureMode != NDIS802_11APMODE)
-		return _FAIL;
+		return 0;
 
 	pbss_network->Rssi = 0;
 
@@ -1171,7 +1171,7 @@ int rtw_check_beacon_data(struct rtw_ada
 		       (pbss_network->IELength - _BEACON_IE_OFFSET_));
 	if (p && ie_len > 0) {
 		if (rtw_parse_wpa2_ie(p, ie_len+2, &group_cipher,
-				      &pairwise_cipher) == _SUCCESS) {
+				      &pairwise_cipher) == 1) {
 			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
 
 			psecuritypriv->dot8021xalg = 1;/* psk,  todo:802.1x */
@@ -1191,7 +1191,7 @@ int rtw_check_beacon_data(struct rtw_ada
 			       _BEACON_IE_OFFSET_ - (ie_len + 2)));
 		if ((p) && (!memcmp(p+2, OUI1, 4))) {
 			if (rtw_parse_wpa_ie(p, ie_len+2, &group_cipher,
-					     &pairwise_cipher) == _SUCCESS) {
+					     &pairwise_cipher) == 1) {
 				psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
 
 				psecuritypriv->dot8021xalg = 1;
@@ -1318,7 +1318,7 @@ int rtw_check_beacon_data(struct rtw_ada
 		psta = rtw_alloc_stainfo(&padapter->stapriv,
 					 pbss_network->MacAddress);
 		if (psta == NULL)
-			return _FAIL;
+			return 0;
 	}
 	/* fix bug of flush_cam_entry at STOP AP mode */
 	psta->state |= WIFI_AP_STATE;
--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -29,7 +29,7 @@ No irqsave is necessary.
 
 int _rtw_init_cmd_priv(struct cmd_priv *pcmdpriv)
 {
-	int res = _SUCCESS;
+	int res = 1;
 
 	sema_init(&(pcmdpriv->cmd_queue_sema), 0);
 	sema_init(&(pcmdpriv->terminate_cmdthread_sema), 0);
@@ -42,7 +42,7 @@ int _rtw_init_cmd_priv(struct cmd_priv *
 					      CMDBUFF_ALIGN_SZ, GFP_ATOMIC);
 
 	if (pcmdpriv->cmd_allocated_buf == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -53,7 +53,7 @@ int _rtw_init_cmd_priv(struct cmd_priv *
 	pcmdpriv->rsp_allocated_buf = kzalloc(MAX_RSPSZ + 4, GFP_ATOMIC);
 
 	if (pcmdpriv->rsp_allocated_buf == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -70,7 +70,7 @@ exit:
 
 int _rtw_init_evt_priv(struct evt_priv *pevtpriv)
 {
-	int res = _SUCCESS;
+	int res = 1;
 
 	/* allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf */
 	atomic_set(&pevtpriv->event_seq, 0);
@@ -110,7 +110,7 @@ int	_rtw_enqueue_cmd(struct __queue *que
 	spin_unlock_irqrestore(&queue->lock, flags);
 
 exit:
-	return _SUCCESS;
+	return 1;
 }
 
 struct cmd_obj *_rtw_dequeue_cmd(struct __queue *queue)
@@ -165,13 +165,13 @@ static int rtw_cmd_filter(struct cmd_pri
 
 	if ((!pcmdpriv->padapter->hw_init_completed && !allow) ||
 	    !pcmdpriv->cmdthd_running)	/* com_thread not running */
-		return _FAIL;
-	return _SUCCESS;
+		return 0;
+	return 1;
 }
 
 u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
 {
-	int res = _FAIL;
+	int res = 0;
 	struct rtw_adapter *padapter = pcmdpriv->padapter;
 
 	if (cmd_obj == NULL)
@@ -187,14 +187,14 @@ u32 rtw_enqueue_cmd(struct cmd_priv *pcm
 #endif
 
 	res = rtw_cmd_filter(pcmdpriv, cmd_obj);
-	if (_FAIL == res) {
+	if (0 == res) {
 		rtw_free_cmd_obj(cmd_obj);
 		goto exit;
 	}
 
 	res = _rtw_enqueue_cmd(&pcmdpriv->cmd_queue, cmd_obj);
 
-	if (res == _SUCCESS)
+	if (res == 1)
 		up(&pcmdpriv->cmd_queue_sema);
 
 exit:
@@ -250,7 +250,7 @@ int rtw_cmd_thread(void *context)
 		 ("start r871x rtw_cmd_thread !!!!\n"));
 
 	while (1) {
-		if ((_rtw_down_sema(&(pcmdpriv->cmd_queue_sema))) == _FAIL)
+		if ((_rtw_down_sema(&(pcmdpriv->cmd_queue_sema))) == 0)
 			break;
 _next:
 		if ((padapter->bDriverStopped) ||
@@ -267,12 +267,12 @@ _next:
 		if (!pcmd)
 			continue;
 
-		if (_FAIL == rtw_cmd_filter(pcmdpriv, pcmd)) {
+		if (0 == rtw_cmd_filter(pcmdpriv, pcmd)) {
 			pcmd->res = H2C_DROPPED;
 			goto post_process;
 		}
 
-		if (_FAIL == rtw_cmd_filter(pcmdpriv, pcmd)) {
+		if (0 == rtw_cmd_filter(pcmdpriv, pcmd)) {
 			rtw_free_cmd_obj(pcmd);
 			continue;
 		}
@@ -345,18 +345,18 @@ u8 rtw_setstandby_cmd(struct rtw_adapter
 	struct usb_suspend_parm *psetusbsuspend;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 
-	u8 ret = _SUCCESS;
+	u8 ret = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		ret = _FAIL;
+		ret = 0;
 		goto exit;
 	}
 
 	psetusbsuspend = kzalloc(sizeof(*pcmdpriv), GFP_ATOMIC);
 	if (psetusbsuspend == NULL) {
 		kfree(ph2c);
-		ret = _FAIL;
+		ret = 0;
 		goto exit;
 	}
 
@@ -384,19 +384,19 @@ u8 rtw_sitesurvey_cmd(struct rtw_adapter
 	struct sitesurvey_parm *psurveypara;
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	u8 res = _FAIL;
+	u8 res = 0;
 
 	if (check_fwstate(pmlmepriv, _FW_LINKED))
 		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SCAN, 1);
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL)
-		return _FAIL;
+		return 0;
 
 	psurveypara = kzalloc(sizeof(*psurveypara), GFP_ATOMIC);
 	if (psurveypara == NULL) {
 		kfree(ph2c);
-		return _FAIL;
+		return 0;
 	}
 
 	rtw_free_network_queue(padapter, false);
@@ -438,7 +438,7 @@ u8 rtw_sitesurvey_cmd(struct rtw_adapter
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
-	if (res == _SUCCESS) {
+	if (res == 1) {
 		pmlmepriv->scan_start_time = jiffies;
 
 		_set_timer(&pmlmepriv->scan_to_timer, SCANNING_TIMEOUT);
@@ -458,18 +458,18 @@ u8 rtw_setdatarate_cmd(struct rtw_adapte
 	struct cmd_obj *ph2c;
 	struct setdatarate_parm *pbsetdataratepara;
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
 	pbsetdataratepara = kzalloc(sizeof(*pbsetdataratepara), GFP_ATOMIC);
 	if (!pbsetdataratepara) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -487,18 +487,18 @@ u8 rtw_setbasicrate_cmd(struct rtw_adapt
 	struct cmd_obj *ph2c;
 	struct setbasicrate_parm *pssetbasicratepara;
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	pssetbasicratepara = kzalloc(sizeof(*pssetbasicratepara), GFP_ATOMIC);
 
 	if (pssetbasicratepara == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -522,18 +522,18 @@ u8 rtw_setphy_cmd(struct rtw_adapter *pa
 	struct cmd_obj *ph2c;
 	struct setphy_parm *psetphypara;
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	psetphypara = kzalloc(sizeof(*psetphypara), GFP_ATOMIC);
 
 	if (psetphypara == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -556,18 +556,18 @@ u8 rtw_setbbreg_cmd(struct rtw_adapter *
 	struct cmd_obj *ph2c;
 	struct writeBB_parm *pwritebbparm;
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	pwritebbparm = kzalloc(sizeof(*pwritebbparm), GFP_ATOMIC);
 
 	if (pwritebbparm == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -587,18 +587,18 @@ u8 rtw_getbbreg_cmd(struct rtw_adapter *
 	struct cmd_obj *ph2c;
 	struct readBB_parm *prdbbparm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	prdbbparm = kzalloc(sizeof(*prdbbparm), GFP_ATOMIC);
 
 	if (prdbbparm == NULL) {
 		kfree(ph2c);
-		return _FAIL;
+		return 0;
 	}
 
 	INIT_LIST_HEAD(&ph2c->list);
@@ -621,18 +621,18 @@ u8 rtw_setrfreg_cmd(struct rtw_adapter *
 	struct cmd_obj *ph2c;
 	struct writeRF_parm *pwriterfparm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	pwriterfparm = kzalloc(sizeof(*pwriterfparm), GFP_ATOMIC);
 
 	if (pwriterfparm == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -652,18 +652,18 @@ u8 rtw_getrfreg_cmd(struct rtw_adapter *
 	struct cmd_obj *ph2c;
 	struct readRF_parm *prdrfparm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
 	prdrfparm = kzalloc(sizeof(*prdrfparm), GFP_ATOMIC);
 	if (prdrfparm == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -703,7 +703,7 @@ u8 rtw_createbss_cmd(struct rtw_adapter
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct wlan_bssid_ex *pdev_network = &padapter->registrypriv.dev_network;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	rtw_led_control(padapter, LED_CTL_START_TO_LINK);
 
@@ -718,7 +718,7 @@ u8 rtw_createbss_cmd(struct rtw_adapter
 
 	pcmd = kzalloc(sizeof(*pcmd), GFP_ATOMIC);
 	if (pcmd == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -742,11 +742,11 @@ u8 rtw_createbss_cmd_ex(struct rtw_adapt
 {
 	struct cmd_obj *pcmd;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	pcmd = kzalloc(sizeof(*pcmd), GFP_ATOMIC);
 	if (pcmd == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -776,7 +776,7 @@ u8 rtw_joinbss_cmd(struct rtw_adapter *p
 	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	u8 res = _SUCCESS;
+	u8 res = 1;
 	uint	t_len = 0;
 	enum NDIS_802_11_NETWORK_INFRASTRUCTURE ndis_network_mode;
 
@@ -793,7 +793,7 @@ u8 rtw_joinbss_cmd(struct rtw_adapter *p
 
 	pcmd = kzalloc(sizeof(*pcmd), GFP_ATOMIC);
 	if (pcmd == NULL) {
-		res = _FAIL;
+		res = 0;
 		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
 			 ("rtw_joinbss_cmd: memory allocate for cmd_obj fail!!!\n"));
 		goto exit;
@@ -820,7 +820,7 @@ u8 rtw_joinbss_cmd(struct rtw_adapter *p
 	psecnetwork = (struct wlan_bssid_ex *)&psecuritypriv->sec_bss;
 	if (psecnetwork == NULL) {
 		kfree(pcmd);
-		res = _FAIL;
+		res = 0;
 		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
 			 ("rtw_joinbss_cmd :psecnetwork == NULL!!!\n"));
 		goto exit;
@@ -918,14 +918,14 @@ u8 rtw_disassoc_cmd(struct rtw_adapter *
 	struct cmd_obj *cmdobj = NULL;
 	struct disconnect_parm *param = NULL;
 	struct cmd_priv *cmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_disassoc_cmd\n"));
 
 	/* prepare cmd parameter */
 	param = kzalloc(sizeof(*param), GFP_ATOMIC);
 	if (param == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	param->deauth_timeout_ms = deauth_timeout_ms;
@@ -934,7 +934,7 @@ u8 rtw_disassoc_cmd(struct rtw_adapter *
 		/* need enqueue, prepare cmd_obj and enqueue */
 		cmdobj = kzalloc(sizeof(*cmdobj), GFP_ATOMIC);
 		if (cmdobj == NULL) {
-			res = _FAIL;
+			res = 0;
 			kfree(param);
 			goto exit;
 		}
@@ -943,7 +943,7 @@ u8 rtw_disassoc_cmd(struct rtw_adapter *
 	} else {
 		/* no need to enqueue, do the cmd hdl directly */
 		if (H2C_SUCCESS != disconnect_hdl(padapter, (u8 *)param))
-			res = _FAIL;
+			res = 0;
 		kfree(param);
 	}
 exit:
@@ -957,7 +957,7 @@ u8 rtw_setopmode_cmd(struct rtw_adapter
 	struct setopmode_parm *psetop;
 
 	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
@@ -991,18 +991,18 @@ u8 rtw_setstakey_cmd(struct rtw_adapter
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct sta_info *sta = (struct sta_info *)psta;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
 	psetstakey_para = kzalloc(sizeof(*psetstakey_para), GFP_ATOMIC);
 	if (psetstakey_para == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1010,7 +1010,7 @@ u8 rtw_setstakey_cmd(struct rtw_adapter
 	if (psetstakey_rsp == NULL) {
 		kfree(ph2c);
 		kfree(psetstakey_para);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1051,21 +1051,21 @@ u8 rtw_clearstakey_cmd(struct rtw_adapte
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct sta_info *sta = (struct sta_info *)psta;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	if (!enqueue) {
 		clear_cam_entry(padapter, entry);
 	} else {
 		ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 		if (ph2c == NULL) {
-			res = _FAIL;
+			res = 0;
 			goto exit;
 		}
 
 		psetstakey_para = kzalloc(sizeof(*psetstakey_para), GFP_ATOMIC);
 		if (psetstakey_para == NULL) {
 			kfree(ph2c);
-			res = _FAIL;
+			res = 0;
 			goto exit;
 		}
 
@@ -1073,7 +1073,7 @@ u8 rtw_clearstakey_cmd(struct rtw_adapte
 		if (psetstakey_rsp == NULL) {
 			kfree(ph2c);
 			kfree(psetstakey_para);
-			res = _FAIL;
+			res = 0;
 			goto exit;
 		}
 
@@ -1100,18 +1100,18 @@ u8 rtw_setrttbl_cmd(struct rtw_adapter *
 	struct cmd_obj *ph2c;
 	struct setratable_parm *psetrttblparm;
 	struct cmd_priv				*pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	psetrttblparm = kzalloc(sizeof(*psetrttblparm), GFP_ATOMIC);
 
 	if (psetrttblparm == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1131,18 +1131,18 @@ u8 rtw_getrttbl_cmd(struct rtw_adapter *
 	struct cmd_obj *ph2c;
 	struct getratable_parm *pgetrttblparm;
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	pgetrttblparm = kzalloc(sizeof(*pgetrttblparm), GFP_ATOMIC);
 
 	if (pgetrttblparm == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1168,18 +1168,18 @@ u8 rtw_setassocsta_cmd(struct rtw_adapte
 	struct set_assocsta_parm *psetassocsta_para;
 	struct set_stakey_rsp		*psetassocsta_rsp = NULL;
 
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
 	psetassocsta_para = kzalloc(sizeof(*psetassocsta_para), GFP_ATOMIC);
 	if (psetassocsta_para == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1187,7 +1187,7 @@ u8 rtw_setassocsta_cmd(struct rtw_adapte
 	if (psetassocsta_rsp == NULL) {
 		kfree(ph2c);
 		kfree(psetassocsta_para);
-		return _FAIL;
+		return 0;
 	}
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, psetassocsta_para, _SETASSOCSTA_CMD_);
@@ -1209,18 +1209,18 @@ u8 rtw_addbareq_cmd(struct rtw_adapter *
 	struct cmd_obj *ph2c;
 	struct addBaReq_parm *paddbareq_parm;
 
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
 	paddbareq_parm = kzalloc(sizeof(*paddbareq_parm), GFP_ATOMIC);
 	if (paddbareq_parm == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1242,7 +1242,7 @@ u8 rtw_dynamic_chk_wk_cmd(struct rtw_ada
 	struct cmd_obj *ph2c;
 	struct drvextra_cmd_parm  *pdrvextra_cmd_parm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	if ((padapter->bDriverStopped) ||
 	    (padapter->bSurpriseRemoved))
@@ -1256,14 +1256,14 @@ u8 rtw_dynamic_chk_wk_cmd(struct rtw_ada
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
 	pdrvextra_cmd_parm = kzalloc(sizeof(*pdrvextra_cmd_parm), GFP_ATOMIC);
 	if (pdrvextra_cmd_parm == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1287,7 +1287,7 @@ u8 rtw_set_ch_cmd(struct rtw_adapter *pa
 	struct set_ch_parm *set_ch_parm;
 	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
 
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	DBG_8192D(FUNC_NDEV_FMT" ch:%u, bw:%u, ch_offset:%u\n",
 		  FUNC_NDEV_ARG(padapter->pnetdev), ch, bw, ch_offset);
@@ -1297,7 +1297,7 @@ u8 rtw_set_ch_cmd(struct rtw_adapter *pa
 	/* prepare cmd parameter */
 	set_ch_parm = kzalloc(sizeof(*set_ch_parm), GFP_ATOMIC);
 	if (set_ch_parm == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	set_ch_parm->ch = ch;
@@ -1309,7 +1309,7 @@ u8 rtw_set_ch_cmd(struct rtw_adapter *pa
 		pcmdobj = kzalloc(sizeof(*pcmdobj), GFP_ATOMIC);
 		if (pcmdobj == NULL) {
 			kfree(set_ch_parm);
-			res = _FAIL;
+			res = 0;
 			goto exit;
 		}
 
@@ -1319,7 +1319,7 @@ u8 rtw_set_ch_cmd(struct rtw_adapter *pa
 	} else {
 		/* no need to enqueue, do the cmd hdl directly */
 		if (H2C_SUCCESS != set_ch_hdl(padapter, (u8 *)set_ch_parm))
-			res = _FAIL;
+			res = 0;
 
 		kfree(set_ch_parm);
 	}
@@ -1340,14 +1340,14 @@ u8 rtw_set_chplan_cmd(struct rtw_adapter
 	struct setchannelplan_param *setchannelplan_param;
 	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
 
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_,
 		 ("+rtw_set_chplan_cmd\n"));
 
 	/* check input parameter */
 	if (!rtw_is_channel_plan_valid(chplan)) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1355,7 +1355,7 @@ u8 rtw_set_chplan_cmd(struct rtw_adapter
 	setchannelplan_param = kzalloc(sizeof(*setchannelplan_param),
 				       GFP_ATOMIC);
 	if (setchannelplan_param == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	setchannelplan_param->channel_plan = chplan;
@@ -1365,7 +1365,7 @@ u8 rtw_set_chplan_cmd(struct rtw_adapter
 		pcmdobj = kzalloc(sizeof(*pcmdobj), GFP_ATOMIC);
 		if (pcmdobj == NULL) {
 			kfree(setchannelplan_param);
-			res = _FAIL;
+			res = 0;
 			goto exit;
 		}
 
@@ -1376,13 +1376,13 @@ u8 rtw_set_chplan_cmd(struct rtw_adapter
 		/* no need to enqueue, do the cmd hdl directly */
 		if (H2C_SUCCESS != set_chplan_hdl(padapter,
 						  (unsigned char *)setchannelplan_param))
-			res = _FAIL;
+			res = 0;
 
 		kfree(setchannelplan_param);
 	}
 
 	/* do something based on res... */
-	if (res == _SUCCESS)
+	if (res == 1)
 		padapter->mlmepriv.ChannelPlan = chplan;
 
 exit:
@@ -1396,21 +1396,21 @@ u8 rtw_led_blink_cmd(struct rtw_adapter
 	struct ledblink_param *ledblink_param;
 	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
 
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_,
 		 ("+rtw_led_blink_cmd\n"));
 
 	pcmdobj = kzalloc(sizeof(*pcmdobj), GFP_ATOMIC);
 	if (pcmdobj == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
 	ledblink_param = kzalloc(sizeof(*ledblink_param), GFP_ATOMIC);
 	if (ledblink_param == NULL) {
 		kfree(pcmdobj);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1432,13 +1432,13 @@ u8 rtw_set_csa_cmd(struct rtw_adapter *p
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
 
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_csa_cmd\n"));
 
 	pcmdobj = kzalloc(sizeof(*pcmdobj), GFP_ATOMIC);
 	if (pcmdobj == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1446,7 +1446,7 @@ u8 rtw_set_csa_cmd(struct rtw_adapter *p
 					 GFP_ATOMIC);
 	if (setchannelswitch_param == NULL) {
 		kfree(pcmdobj);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1468,7 +1468,7 @@ u8 rtw_tdls_cmd(struct rtw_adapter *pada
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
 
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	return res;
 }
@@ -1612,7 +1612,7 @@ u8 rtw_lps_ctrl_wk_cmd(struct rtw_adapte
 	struct cmd_obj *ph2c;
 	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type != IFACE_PORT0)
@@ -1622,7 +1622,7 @@ u8 rtw_lps_ctrl_wk_cmd(struct rtw_adapte
 	if (enqueue) {
 		ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 		if (ph2c == NULL) {
-			res = _FAIL;
+			res = 0;
 			goto exit;
 		}
 
@@ -1630,7 +1630,7 @@ u8 rtw_lps_ctrl_wk_cmd(struct rtw_adapte
 					     GFP_ATOMIC);
 		if (pdrvextra_cmd_parm == NULL) {
 			kfree(ph2c);
-			res = _FAIL;
+			res = 0;
 			goto exit;
 		}
 
@@ -1663,21 +1663,21 @@ u8 p2p_protocol_wk_cmd(struct rtw_adapte
 	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return res;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
 	pdrvextra_cmd_parm = kzalloc(sizeof(*pdrvextra_cmd_parm), GFP_ATOMIC);
 	if (pdrvextra_cmd_parm == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1701,7 +1701,7 @@ u8 rtw_ps_cmd(struct rtw_adapter *padapt
 	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->adapter_type != PRIMARY_ADAPTER)
@@ -1710,14 +1710,14 @@ u8 rtw_ps_cmd(struct rtw_adapter *padapt
 
 	ppscmd = kzalloc(sizeof(*ppscmd), GFP_ATOMIC);
 	if (ppscmd == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
 	pdrvextra_cmd_parm = kzalloc(sizeof(*pdrvextra_cmd_parm), GFP_ATOMIC);
 	if (pdrvextra_cmd_parm == NULL) {
 		kfree(ppscmd);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1766,17 +1766,17 @@ u8 rtw_chk_hi_queue_cmd(struct rtw_adapt
 	struct cmd_obj *ph2c;
 	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	pdrvextra_cmd_parm = kzalloc(sizeof(*pdrvextra_cmd_parm), GFP_ATOMIC);
 	if (pdrvextra_cmd_parm == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	pdrvextra_cmd_parm->ec_id = CHECK_HIQ_WK_CID;
@@ -1798,18 +1798,18 @@ u8 rtw_c2h_wk_cmd(struct rtw_adapter *pa
 	struct cmd_obj *ph2c;
 	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-	u8 res = _SUCCESS;
+	u8 res = 1;
 
 	ph2c = kzalloc(sizeof(*ph2c), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
 	pdrvextra_cmd_parm = kzalloc(sizeof(*pdrvextra_cmd_parm), GFP_ATOMIC);
 	if (pdrvextra_cmd_parm == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1830,12 +1830,12 @@ exit:
 s32 c2h_evt_hdl(struct rtw_adapter *adapter, struct c2h_evt_hdr *c2h_evt,
 		c2h_id_filter filter)
 {
-	s32 ret = _FAIL;
+	s32 ret = 0;
 	u8 buf[16];
 
 	if (!c2h_evt) {
 		/* No c2h event in cmd_obj, read c2h event before handling*/
-		if (c2h_evt_read(adapter, buf) == _SUCCESS) {
+		if (c2h_evt_read(adapter, buf) == 1) {
 			c2h_evt = (struct c2h_evt_hdr *)buf;
 
 			if (filter && !filter(c2h_evt->id))
--- a/drivers/staging/rtl8192du/core/rtw_efuse.c
+++ b/drivers/staging/rtl8192du/core/rtw_efuse.c
@@ -396,18 +396,18 @@ u8 rtw_efuse_access(struct rtw_adapter *
 {
 	int i = 0;
 	u16 real_content_len = 0, max_available_size = 0;
-	u8 res = _FAIL;
+	u8 res = 0;
 	u8 (*rw8)(struct rtw_adapter *, u16, u8*);
 
 	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_REAL_CONTENT_LEN, (void *)&real_content_len, false);
 	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
 
 	if (start_addr > real_content_len)
-		return _FAIL;
+		return 0;
 
 	if (true == write) {
 		if ((start_addr + cnts) > max_available_size)
-			return _FAIL;
+			return 0;
 		rw8 = &efuse_write8;
 	} else {
 		rw8 = &efuse_read8;
@@ -418,12 +418,12 @@ u8 rtw_efuse_access(struct rtw_adapter *
 	/*  e-fuse one byte read / write */
 	for (i = 0; i < cnts; i++) {
 		if (start_addr >= real_content_len) {
-			res = _FAIL;
+			res = 0;
 			break;
 		}
 
 		res = rw8(padapter, start_addr++, data++);
-		if (_FAIL == res)
+		if (0 == res)
 			break;
 	}
 
@@ -445,7 +445,7 @@ u8 efuse_GetCurrentSize(struct rtw_adapt
 	*size = Efuse_GetCurrentSize(padapter, EFUSE_WIFI, false);
 	Efuse_PowerSwitch(padapter, false, false);
 
-	return _SUCCESS;
+	return 1;
 }
 
 u8 rtw_efuse_map_read(struct rtw_adapter *padapter, u16 addr, u16 cnts, u8 *data)
@@ -455,7 +455,7 @@ u8 rtw_efuse_map_read(struct rtw_adapter
 	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (void *)&maplen, false);
 
 	if ((addr + cnts) > maplen)
-		return _FAIL;
+		return 0;
 
 	Efuse_PowerSwitch(padapter, false, true);
 
@@ -463,7 +463,7 @@ u8 rtw_efuse_map_read(struct rtw_adapter
 
 	Efuse_PowerSwitch(padapter, false, false);
 
-	return _SUCCESS;
+	return 1;
 }
 
 u8 rtw_efuse_map_write(struct rtw_adapter *padapter, u16 addr, u16 cnts, u8 *data)
@@ -472,20 +472,20 @@ u8 rtw_efuse_map_write(struct rtw_adapte
 	u8 *map;
 	u8 newdata[PGPKT_DATA_SIZE + 1];
 	s32	i, idx;
-	u8 ret = _SUCCESS;
+	u8 ret = 1;
 	u16 maplen = 0;
 
 	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (void *)&maplen, false);
 
 	if ((addr + cnts) > maplen)
-		return _FAIL;
+		return 0;
 
 	map = kzalloc(maplen, GFP_KERNEL);
 	if (map == NULL)
-		return _FAIL;
+		return 0;
 
 	ret = rtw_efuse_map_read(padapter, 0, maplen, map);
-	if (ret == _FAIL)
+	if (ret == 0)
 		goto exit;
 
 	Efuse_PowerSwitch(padapter, true, true);
@@ -538,7 +538,7 @@ u8 rtw_efuse_map_write(struct rtw_adapte
 
 			for (i = 0; i < PGPKT_DATA_SIZE; i++)
 				DBG_8192D("data =%x \t", newdata[i]);
-			if (ret == _FAIL)
+			if (ret == 0)
 				break;
 		}
 
--- a/drivers/staging/rtl8192du/core/rtw_ieee80211.c
+++ b/drivers/staging/rtl8192du/core/rtw_ieee80211.c
@@ -281,11 +281,11 @@ u8 *rtw_get_ie_ex(u8 *in_ie, uint in_len
  * @oui: OUI to match
  * @oui_len: OUI length
  *
- * Returns: _SUCCESS: ies is updated, _FAIL: not updated
+ * Returns: 1: ies is updated, 0: not updated
  */
 int rtw_ies_remove_ie(u8 *ies, uint *ies_len, uint offset, u8 eid, u8 *oui, u8 oui_len)
 {
-	int ret = _FAIL;
+	int ret = 0;
 	u8 *target_ie;
 	u32 target_ielen;
 	u8 *start;
@@ -307,7 +307,7 @@ int rtw_ies_remove_ie(u8 *ies, uint *ies
 			memcpy(buf, remain_ies, remain_len);
 			memcpy(target_ie, buf, remain_len);
 			*ies_len = *ies_len - target_ielen;
-			ret = _SUCCESS;
+			ret = 1;
 
 			start = target_ie;
 			search_len = remain_len;
@@ -424,7 +424,7 @@ int rtw_generate_ie(struct registry_priv
 	if (rate_len > 8)
 		ie = rtw_set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (pdev_network->SupportedRates + 8), &sz);
 
-	/* return _SUCCESS; */
+	/* return 1; */
 	return sz;
 }
 
@@ -513,18 +513,18 @@ int rtw_get_wpa2_cipher_suite(u8 *s)
 
 int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher)
 {
-	int i, ret = _SUCCESS;
+	int i, ret = 1;
 	int left, count;
 	u8 *pos;
 
 	if (wpa_ie_len <= 0) {
 		/* No WPA IE - fail silently */
-		return _FAIL;
+		return 0;
 	}
 
 	if ((*wpa_ie != _WPA_IE_ID_) || (*(wpa_ie+1) != (u8)(wpa_ie_len - 2)) ||
 	    (memcmp(wpa_ie+2, RTW_WPA_OUI_TYPE, WPA_SELECTOR_LEN)))
-		return _FAIL;
+		return 0;
 
 	pos = wpa_ie;
 
@@ -541,7 +541,7 @@ int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa
 	} else if (left > 0) {
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie length mismatch, %u too much", __func__, left));
 
-		return _FAIL;
+		return 0;
 	}
 
 	/* pairwise_cipher */
@@ -555,7 +555,7 @@ int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa
 			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 				 ("%s: ie count botch (pairwise), count %u left %u",
 				 __func__, count, left));
-			return _FAIL;
+			return 0;
 		}
 
 		for (i = 0; i < count; i++) {
@@ -567,7 +567,7 @@ int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa
 
 	} else if (left == 1) {
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie too short (for key mgmt)",   __func__));
-		return _FAIL;
+		return 0;
 	}
 
 	return ret;
@@ -575,18 +575,18 @@ int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa
 
 int rtw_parse_wpa2_ie(u8 *rsn_ie, int rsn_ie_len, int *group_cipher, int *pairwise_cipher)
 {
-	int i, ret = _SUCCESS;
+	int i, ret = 1;
 	int left, count;
 	u8 *pos;
 
 	if (rsn_ie_len <= 0) {
 		/* No RSN IE - fail silently */
-		return _FAIL;
+		return 0;
 	}
 
 	if ((*rsn_ie != _WPA2_IE_ID_) ||
 	    (*(rsn_ie+1) != (u8)(rsn_ie_len - 2)))
-		return _FAIL;
+		return 0;
 
 	pos = rsn_ie;
 	pos += 4;
@@ -601,7 +601,7 @@ int rtw_parse_wpa2_ie(u8 *rsn_ie, int rs
 
 	} else if (left > 0) {
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie length mismatch, %u too much", __func__, left));
-		return _FAIL;
+		return 0;
 	}
 
 	/* pairwise_cipher */
@@ -613,7 +613,7 @@ int rtw_parse_wpa2_ie(u8 *rsn_ie, int rs
 		if (count == 0 || left < count * RSN_SELECTOR_LEN) {
 			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie count botch (pairwise), "
 						 "count %u left %u", __func__, count, left));
-			return _FAIL;
+			return 0;
 		}
 
 		for (i = 0; i < count; i++) {
@@ -626,7 +626,7 @@ int rtw_parse_wpa2_ie(u8 *rsn_ie, int rs
 	} else if (left == 1) {
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie too short (for key mgmt)",  __func__));
 
-		return _FAIL;
+		return 0;
 	}
 
 	return ret;
--- a/drivers/staging/rtl8192du/core/rtw_io.c
+++ b/drivers/staging/rtl8192du/core/rtw_io.c
@@ -252,7 +252,7 @@ u32 _rtw_write_port(struct rtw_adapter *
 			   u32 cnt, u8 *pmem);
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
-	u32 ret = _SUCCESS;
+	u32 ret = 1;
 
 	_write_port = pintfhdl->io_ops._write_port;
 
@@ -264,7 +264,7 @@ u32 _rtw_write_port(struct rtw_adapter *
 u32 _rtw_write_port_and_wait(struct rtw_adapter *adapter, u32 addr, u32 cnt,
 			     u8 *pmem, int timeout_ms)
 {
-	int ret = _SUCCESS;
+	int ret = 1;
 	struct xmit_buf *pxmitbuf = (struct xmit_buf *)pmem;
 	struct submit_ctx sctx;
 
@@ -273,7 +273,7 @@ u32 _rtw_write_port_and_wait(struct rtw_
 
 	ret = _rtw_write_port(adapter, addr, cnt, pmem);
 
-	if (ret == _SUCCESS)
+	if (ret == 1)
 		ret = rtw_sctx_wait(&sctx);
 
 	 return ret;
@@ -298,7 +298,7 @@ int rtw_init_io_priv(struct rtw_adapter
 	struct intf_hdl *pintf = &piopriv->intf;
 
 	if (set_intf_ops == NULL)
-		return _FAIL;
+		return 0;
 
 	piopriv->padapter = padapter;
 	pintf->padapter = padapter;
@@ -306,5 +306,5 @@ int rtw_init_io_priv(struct rtw_adapter
 
 	set_intf_ops(&pintf->io_ops);
 
-	return _SUCCESS;
+	return 1;
 }
--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -62,7 +62,7 @@ u8 rtw_do_join(struct rtw_adapter *padap
 	u8 *pibss = NULL;
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	struct __queue *queue = &(pmlmepriv->scanned_queue);
-	u8 ret = _SUCCESS;
+	u8 ret = 1;
 
 	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 	phead = get_list_head(queue);
@@ -90,7 +90,7 @@ u8 rtw_do_join(struct rtw_adapter *padap
 				 ("rtw_do_join(): site survey if scanned_queue is empty\n."));
 			/*  submit site_survey_cmd */
 			ret = rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);
-			if (_SUCCESS != ret) {
+			if (1 != ret) {
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,
 					 _drv_err_,
 					 ("rtw_do_join(): site survey return error\n."));
@@ -102,11 +102,11 @@ u8 rtw_do_join(struct rtw_adapter *padap
 		int select_ret;
 		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 		select_ret = rtw_select_and_join_from_scanned_queue(pmlmepriv);
-		if (select_ret == _SUCCESS) {
+		if (select_ret == 1) {
 			pmlmepriv->to_join = false;
 			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
 		} else if (ret == 2) { /* there is no need to wait for join */
-			ret = _SUCCESS;
+			ret = 1;
 			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 			rtw_indicate_connect(padapter);
 		} else {
@@ -127,7 +127,7 @@ u8 rtw_do_join(struct rtw_adapter *padap
 
 				rtw_generate_random_ibss(pibss);
 
-				if (rtw_createbss_cmd(padapter) != _SUCCESS) {
+				if (rtw_createbss_cmd(padapter) != 1) {
 					RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("***Error=>do_goin: rtw_createbss_cmd status FAIL***\n "));
 					ret =  false;
 					goto exit;
@@ -146,7 +146,7 @@ u8 rtw_do_join(struct rtw_adapter *padap
 				if (pmlmepriv->LinkDetectInfo.bBusyTraffic == false ||
 				    rtw_to_roaming(padapter) > 0) {
 					ret = rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);
-					if (_SUCCESS != ret)
+					if (1 != ret)
 						RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 							 ("do_join(): site survey return error\n."));
 				}
@@ -161,7 +161,7 @@ exit:
 
 u8 rtw_set_802_11_bssid(struct rtw_adapter *padapter, u8 *bssid)
 {
-	u8 status = _SUCCESS;
+	u8 status = 1;
 	u32 cur_time = 0;
 
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -171,7 +171,7 @@ u8 rtw_set_802_11_bssid(struct rtw_adapt
 
 	if ((bssid[0] == 0x00 && bssid[1] == 0x00 && bssid[2] == 0x00 && bssid[3] == 0x00 && bssid[4] == 0x00 && bssid[5] == 0x00) ||
 	    (bssid[0] == 0xFF && bssid[1] == 0xFF && bssid[2] == 0xFF && bssid[3] == 0xFF && bssid[4] == 0xFF && bssid[5] == 0xFF)) {
-		status = _FAIL;
+		status = 0;
 		goto exit;
 	}
 
@@ -218,7 +218,7 @@ handle_tkip_countermeasure:
 			padapter->securitypriv.btkip_countermeasure = false;
 			padapter->securitypriv.btkip_countermeasure_time = 0;
 		} else {
-			status = _FAIL;
+			status = 0;
 			goto release_mlme_lock;
 		}
 	}
@@ -243,7 +243,7 @@ exit:
 
 u8 rtw_set_802_11_ssid(struct rtw_adapter *padapter, struct ndis_802_11_ssid *ssid)
 {
-	u8 status = _SUCCESS;
+	u8 status = 1;
 	u32 cur_time = 0;
 
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -256,7 +256,7 @@ u8 rtw_set_802_11_ssid(struct rtw_adapte
 	if (padapter->hw_init_completed == false) {
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 			 ("set_ssid: hw_init_completed== false=>exit!!!\n"));
-		status = _FAIL;
+		status = 0;
 		goto exit;
 	}
 
@@ -326,7 +326,7 @@ handle_tkip_countermeasure:
 			padapter->securitypriv.btkip_countermeasure = false;
 			padapter->securitypriv.btkip_countermeasure_time = 0;
 		} else {
-			status = _FAIL;
+			status = 0;
 			goto release_mlme_lock;
 		}
 	}
@@ -459,7 +459,7 @@ u8 rtw_set_802_11_bssid_list_scan(struct
 		if (rtw_is_scan_deny(padapter)) {
 			DBG_8192D(FUNC_ADPT_FMT": scan deny\n", FUNC_ADPT_ARG(padapter));
 			indicate_wx_scan_complete_event(padapter);
-			return _SUCCESS;
+			return 1;
 		}
 
 		spin_lock_bh(&pmlmepriv->lock);
@@ -492,7 +492,7 @@ u8 rtw_set_802_11_authentication_mode(st
 
 	res = rtw_set_auth(padapter, psecuritypriv);
 
-	if (res == _SUCCESS)
+	if (res == 1)
 		ret = true;
 	else
 		ret = false;
@@ -504,7 +504,7 @@ u8 rtw_set_802_11_add_wep(struct rtw_ada
 {
 	int		keyid, res;
 	struct security_priv *psecuritypriv = &(padapter->securitypriv);
-	u8		ret = _SUCCESS;
+	u8		ret = 1;
 
 	keyid = wep->KeyIndex & 0x3fffffff;
 
@@ -547,7 +547,7 @@ u8 rtw_set_802_11_add_wep(struct rtw_ada
 
 	res = rtw_set_key(padapter, psecuritypriv, keyid, 1);
 
-	if (res == _FAIL)
+	if (res == 0)
 		ret = false;
 exit:
 
@@ -556,7 +556,7 @@ exit:
 
 u8 rtw_set_802_11_remove_wep(struct rtw_adapter *padapter, u32 keyindex)
 {
-	u8 ret = _SUCCESS;
+	u8 ret = 1;
 
 	if (keyindex >= 0x80000000 || padapter == NULL) {
 		ret = false;
@@ -571,10 +571,10 @@ u8 rtw_set_802_11_remove_wep(struct rtw_
 
 			psecuritypriv->dot11DefKeylen[keyindex] = 0;
 
-			if (res == _FAIL)
-				ret = _FAIL;
+			if (res == 0)
+				ret = 0;
 		} else {
-			ret = _FAIL;
+			ret = 0;
 		}
 	}
 
@@ -590,7 +590,7 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 	struct sta_info *stainfo;
 	u8	bgroup = false;
 	u8	bgrouptkey = false;/* can be remove later */
-	u8	ret = _SUCCESS;
+	u8	ret = 1;
 
 	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)) {
 		/*  It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination, */
@@ -598,7 +598,7 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("rtw_set_802_11_add_key: ((key->KeyIndex & 0x80000000) == 0)[=%d] ", (int)(key->KeyIndex & 0x80000000) == 0));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("rtw_set_802_11_add_key:((key->KeyIndex & 0x40000000) > 0)[=%d]", (int)(key->KeyIndex & 0x40000000) > 0));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("rtw_set_802_11_add_key: key->KeyIndex =%d\n", (int)key->KeyIndex));
-		ret = _FAIL;
+		ret = 0;
 		goto exit;
 	}
 
@@ -637,7 +637,7 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 			/*  The key index should be set to zero for a Pairwise key, and the driver should fail with */
 			/*  NDIS_STATUS_INVALID_DATA if the lower 8 bits is not zero */
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, (" key->KeyIndex & 0x000000FF.\n"));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -652,7 +652,7 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 		/* if (encryptionAlgorithm == RT_ENC_TKIP_ENCRYPTION && key->KeyLength != 32) */
 		if ((encryptionalgo == _TKIP_) && (key->KeyLength != 32)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("TKIP KeyLength:0x%x != 32\n", key->KeyLength));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -662,7 +662,7 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 			if (key->KeyLength == 32) {
 				key->KeyLength = 16;
 			} else {
-				ret = _FAIL;
+				ret = 0;
 				goto exit;
 			}
 		}
@@ -671,7 +671,7 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 		if ((encryptionalgo == _WEP40_ || encryptionalgo == _WEP104_) &&
 		    (key->KeyLength != 5 && key->KeyLength != 13)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("WEP KeyLength:0x%x != 5 or 13\n", key->KeyLength));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -730,21 +730,21 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 
 		if ((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE) == true) && (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == false)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, (" IBSS but BSSID is not Broadcast Address.\n"));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
 		/*  Check key length for TKIP */
 		if ((encryptionalgo == _TKIP_) && (key->KeyLength != 32)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, (" TKIP GTK KeyLength:%u != 32\n", key->KeyLength));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 
 		} else if (encryptionalgo == _AES_ && (key->KeyLength != 16 && key->KeyLength != 32)) {
 			/*  Check key length for AES */
 			/*  For NDTEST, we allow keylen= 32 in this case. 2005.01.27, by rcnjko. */
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("<=== SetInfo, OID_802_11_ADD_KEY: AES GTK KeyLength:%u != 16 or 32\n", key->KeyLength));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -819,7 +819,7 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 			padapter->securitypriv.dot118021XGrpKeyid = (u8)key->KeyIndex;
 
 		if ((key->KeyIndex&0x3) == 0) {
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -873,8 +873,8 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 
 		res = rtw_set_key(padapter, &padapter->securitypriv, key->KeyIndex, 1);
 
-		if (res == _FAIL)
-			ret = _FAIL;
+		if (res == 0)
+			ret = 0;
 
 		goto exit;
 
@@ -919,7 +919,7 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 			}
 
 			if (res == false)
-				ret = _FAIL;
+				ret = 0;
 		}
 	}
 
@@ -935,10 +935,10 @@ u8 rtw_set_802_11_remove_key(struct rtw_
 	struct sta_info *stainfo;
 	u8	bgroup = (key->KeyIndex & 0x4000000) > 0 ? false : true;
 	u8	keyIndex = (u8)key->KeyIndex & 0x03;
-	u8	ret = _SUCCESS;
+	u8	ret = 1;
 
 	if ((key->KeyIndex & 0xbffffffc) > 0) {
-		ret = _FAIL;
+		ret = 0;
 		goto exit;
 	}
 	if (bgroup == true) {
@@ -955,7 +955,7 @@ u8 rtw_set_802_11_remove_key(struct rtw_
 			memset(&stainfo->dot118021x_UncstKey, 0, 16);
 			/*  \todo Send a H2C Command to Firmware for disable this Key in CAM Entry. */
 		} else {
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 	}
@@ -1032,16 +1032,16 @@ u16 rtw_get_cur_max_rate(struct rtw_adap
 * @adapter: pointer to _adapter structure
 * @scan_mode:
 *
-* Return _SUCCESS or _FAIL
+* Return 1 or 0
 */
 int rtw_set_scan_mode(struct rtw_adapter *adapter, enum RT_SCAN_TYPE scan_mode)
 {
 	if (scan_mode != SCAN_ACTIVE && scan_mode != SCAN_PASSIVE)
-		return _FAIL;
+		return 0;
 
 	adapter->mlmepriv.scan_mode = scan_mode;
 
-	return _SUCCESS;
+	return 1;
 }
 
 /*
@@ -1049,7 +1049,7 @@ int rtw_set_scan_mode(struct rtw_adapter
 * @adapter: pointer to _adapter structure
 * @channel_plan:
 *
-* Return _SUCCESS or _FAIL
+* Return 1 or 0
 */
 int rtw_set_channel_plan(struct rtw_adapter *adapter, u8 channel_plan)
 {
@@ -1065,7 +1065,7 @@ int rtw_set_channel_plan(struct rtw_adap
 * @adapter: pointer to _adapter structure
 * @country_code: string of country code
 *
-* Return _SUCCESS or _FAIL
+* Return 1 or 0
 */
 int rtw_set_country(struct rtw_adapter *adapter, const char *country_code)
 {
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -37,7 +37,7 @@ int _rtw_init_mlme_priv(struct rtw_adapt
 	u8 *pbuf;
 	struct wlan_network *pnetwork;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	int res = _SUCCESS;
+	int res = 1;
 
 	/*  We don't need to memset padapter->XXX to zero,
 	 * because adapter is allocated by vzalloc(). */
@@ -60,7 +60,7 @@ int _rtw_init_mlme_priv(struct rtw_adapt
 	pbuf = vzalloc(MAX_BSS_CNT * (sizeof(struct wlan_network)));
 
 	if (pbuf == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	pmlmepriv->free_bss_buf = pbuf;
@@ -149,7 +149,7 @@ int _rtw_enqueue_network(struct __queue
 
 exit:
 
-	return _SUCCESS;
+	return 1;
 }
 
 struct wlan_network *_rtw_dequeue_network(struct __queue *queue)
@@ -899,7 +899,7 @@ void rtw_surveydone_event_callback(struc
 				set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
 
 				if (rtw_select_and_join_from_scanned_queue
-				    (pmlmepriv) == _SUCCESS) {
+				    (pmlmepriv) == 1) {
 					_set_timer(&pmlmepriv->assoc_timer,
 						   MAX_JOIN_TIMEOUT);
 				} else {
@@ -931,7 +931,7 @@ void rtw_surveydone_event_callback(struc
 					    WIFI_ADHOC_MASTER_STATE;
 
 					if (rtw_createbss_cmd(adapter) !=
-					    _SUCCESS) {
+					    1) {
 						RT_TRACE
 						    (_module_rtl871x_mlme_c_,
 						     _drv_err_,
@@ -946,7 +946,7 @@ void rtw_surveydone_event_callback(struc
 			set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
 			pmlmepriv->to_join = false;
 			s_ret = rtw_select_and_join_from_scanned_queue(pmlmepriv);
-			if (_SUCCESS == s_ret) {
+			if (1 == s_ret) {
 				_set_timer(&pmlmepriv->assoc_timer,
 					   MAX_JOIN_TIMEOUT);
 			} else if (s_ret == 2) {	/* there is no need to wait for join */
@@ -957,7 +957,7 @@ void rtw_surveydone_event_callback(struc
 				    ("try_to_join, but select scanning queue fail, to_roaming:%d\n",
 				     rtw_to_roaming(adapter));
 				if (rtw_to_roaming(adapter) != 0) {
-					if (--pmlmepriv->to_roaming == 0 || _SUCCESS !=
+					if (--pmlmepriv->to_roaming == 0 || 1 !=
 					    rtw_sitesurvey_cmd(adapter,
 							       &pmlmepriv->
 							       assoc_ssid, 1,
@@ -1732,7 +1732,7 @@ void rtw_stadel_event_callback(struct rt
 				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_STATE);
 			}
 
-			if (rtw_createbss_cmd(adapter) != _SUCCESS) {
+			if (rtw_createbss_cmd(adapter) != 1) {
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,
 					 _drv_err_,
 					 ("***Error=>stadel_event_callback: rtw_createbss_cmd status FAIL***\n "));
@@ -1772,7 +1772,7 @@ void _rtw_join_timeout_handler(struct rt
 			if (rtw_to_roaming(adapter) != 0) {	/* try another */
 				DBG_8192D("%s try another roaming\n", __func__);
 				do_join_r = rtw_do_join(adapter);
-				if (_SUCCESS != do_join_r) {
+				if (1 != do_join_r) {
 					DBG_8192D
 					    ("%s roaming do_join return %d\n",
 					     __func__, do_join_r);
@@ -2025,9 +2025,9 @@ int rtw_select_and_join_from_scanned_que
 				   list);
 		if (pnetwork == NULL) {
 			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
-				 ("%s return _FAIL:(pnetwork==NULL)\n",
+				 ("%s return 0:(pnetwork==NULL)\n",
 				  __func__));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -2037,8 +2037,8 @@ int rtw_select_and_join_from_scanned_que
 	}
 
 	if (candidate == NULL) {
-		DBG_8192D("%s: return _FAIL(candidate == NULL)\n", __func__);
-		ret = _FAIL;
+		DBG_8192D("%s: return 0(candidate == NULL)\n", __func__);
+		ret = 0;
 		goto exit;
 	} else {
 		DBG_8192D("%s: candidate: %s(%pM, ch:%u)\n", __func__,
@@ -2071,11 +2071,11 @@ int rtw_set_auth(struct rtw_adapter *ada
 	struct cmd_obj *pcmd;
 	struct setauth_parm *psetauthparm;
 	struct cmd_priv *pcmdpriv = &(adapter->cmdpriv);
-	int res = _SUCCESS;
+	int res = 1;
 
 	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (pcmd == NULL) {
-		res = _FAIL;	/* try again */
+		res = 0;	/* try again */
 		goto exit;
 	}
 
@@ -2083,7 +2083,7 @@ int rtw_set_auth(struct rtw_adapter *ada
 	    (struct setauth_parm *)kzalloc(sizeof(struct setauth_parm), GFP_KERNEL);
 	if (psetauthparm == NULL) {
 		kfree(pcmd);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -2117,18 +2117,18 @@ int rtw_set_key(struct rtw_adapter *adap
 	struct setkey_parm *psetkeyparm;
 	struct cmd_priv *pcmdpriv = &(adapter->cmdpriv);
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
-	int res = _SUCCESS;
+	int res = 1;
 
 	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (pcmd == NULL) {
-		res = _FAIL;	/* try again */
+		res = 0;	/* try again */
 		goto exit;
 	}
 	psetkeyparm =
 	    (struct setkey_parm *)kzalloc(sizeof(struct setkey_parm), GFP_KERNEL);
 	if (psetkeyparm == NULL) {
 		kfree(pcmd);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -2184,7 +2184,7 @@ int rtw_set_key(struct rtw_adapter *adap
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 			 ("\n rtw_set_key:psecuritypriv->dot11PrivacyAlgrthm = %x (must be 1 or 2 or 4 or 5)\n",
 			  psecuritypriv->dot11PrivacyAlgrthm));
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -2737,7 +2737,7 @@ void _rtw_roaming(struct rtw_adapter *pa
 
 		while (1) {
 			do_join_r = rtw_do_join(padapter);
-			if (_SUCCESS == do_join_r) {
+			if (1 == do_join_r) {
 				break;
 			} else {
 				DBG_8192D("roaming do_join return %d\n",
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -254,7 +254,7 @@ int init_hw_mlme_ext(struct rtw_adapter
 	set_channel_bwmode(adapt, pmlmeext->cur_channel,
 			   pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 
-	return _SUCCESS;
+	return 1;
 }
 
 static void init_mlme_ext_priv_value(struct rtw_adapter *adapt)
@@ -471,7 +471,7 @@ static u8 init_channel_set(struct rtw_ad
 
 int init_mlme_ext_priv(struct rtw_adapter *adapt)
 {
-	int res = _SUCCESS;
+	int res = 1;
 	struct registry_priv *pregistrypriv = &adapt->registrypriv;
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
 	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
@@ -661,7 +661,7 @@ static u32 p2p_listen_state_process(stru
 	if (response == true)
 		issue_probersp_p2p(adapt, da);
 
-	return _SUCCESS;
+	return 1;
 }
 #endif /* CONFIG_P2P */
 
@@ -709,7 +709,7 @@ unsigned int OnProbeReq(struct rtw_adapt
 								 get_sa
 								 (pframe));
 
-					return _SUCCESS;
+					return 1;
 				}
 
 				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
@@ -723,19 +723,19 @@ _continue:
 #endif /* CONFIG_P2P */
 
 	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
-		return _SUCCESS;
+		return 1;
 	}
 
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == false &&
 	    check_fwstate(pmlmepriv,
 			  WIFI_ADHOC_MASTER_STATE | WIFI_AP_STATE) == false) {
-		return _SUCCESS;
+		return 1;
 	}
 #ifdef CONFIG_CONCURRENT_MODE
 	if (((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) &&
 	    check_buddy_fwstate(adapt, _FW_UNDER_LINKING | _FW_UNDER_SURVEY)) {
 		/* don't process probe req */
-		return _SUCCESS;
+		return 1;
 	}
 #endif
 
@@ -755,7 +755,7 @@ _continue:
 					 cur->Ssid.SsidLength)) ||
 		    (ielen == 0 && pmlmeinfo->hidden_ssid_mode)
 		   ) {
-			return _SUCCESS;
+			return 1;
 		}
 
 _issue_probersp:
@@ -766,7 +766,7 @@ _issue_probersp:
 				       is_valid_p2p_probereq);
 		}
 	}
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int OnProbeRsp(struct rtw_adapter *adapt,
@@ -813,7 +813,7 @@ unsigned int OnProbeRsp(struct rtw_adapt
 				}
 			}
 		}
-		return _SUCCESS;
+		return 1;
 	} else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING)) {
 		if (true == pwdinfo->nego_req_info.benable) {
 			DBG_8192D("[%s] P2P State is GONEGO ING!\n", __func__);
@@ -850,10 +850,10 @@ unsigned int OnProbeRsp(struct rtw_adapt
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		dc_report_survey_event(adapt, precv_frame);
 #endif
-		return _SUCCESS;
+		return 1;
 	}
 
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int OnBeacon(struct rtw_adapter *adapt,
@@ -877,7 +877,7 @@ unsigned int OnBeacon(struct rtw_adapter
 		dc_report_survey_event(adapt, precv_frame);
 #endif
 
-		return _SUCCESS;
+		return 1;
 	}
 
 	if (!memcmp
@@ -894,7 +894,7 @@ unsigned int OnBeacon(struct rtw_adapter
 			/* start auth */
 			start_clnt_auth(adapt);
 
-			return _SUCCESS;
+			return 1;
 		}
 
 		if (((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) &&
@@ -930,7 +930,7 @@ unsigned int OnBeacon(struct rtw_adapter
 				     (pframe + WLAN_HDR_A3_LEN +
 				      _BEACON_IE_OFFSET_),
 				     (len - WLAN_HDR_A3_LEN -
-				      _BEACON_IE_OFFSET_), cam_idx) == _FAIL) {
+				      _BEACON_IE_OFFSET_), cam_idx) == 0) {
 					pmlmeinfo->FW_sta_info[cam_idx].status =
 					    0;
 					goto _END_ONBEACON_;
@@ -949,7 +949,7 @@ unsigned int OnBeacon(struct rtw_adapter
 
 _END_ONBEACON_:
 
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int OnAuth(struct rtw_adapter *adapt, struct recv_frame_hdr *precv_frame)
@@ -972,12 +972,12 @@ unsigned int OnAuth(struct rtw_adapter *
 	if (((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) &&
 	    check_buddy_fwstate(adapt, _FW_UNDER_LINKING | _FW_UNDER_SURVEY)) {
 		/* don't process auth request; */
-		return _SUCCESS;
+		return 1;
 	}
 #endif /* CONFIG_CONCURRENT_MODE */
 
 	if ((pmlmeinfo->state & 0x03) != WIFI_FW_AP_STATE)
-		return _FAIL;
+		return 0;
 
 	DBG_8192D("+OnAuth\n");
 
@@ -1125,7 +1125,7 @@ unsigned int OnAuth(struct rtw_adapter *
 	if (pstat->state & WIFI_FW_AUTH_SUCCESS)
 		pstat->auth_seq = 0;
 
-	return _SUCCESS;
+	return 1;
 
 auth_fail:
 
@@ -1140,7 +1140,7 @@ auth_fail:
 	issue_auth(adapt, pstat, (unsigned short)status);
 
 #endif
-	return _FAIL;
+	return 0;
 }
 
 unsigned int OnAuthClient(struct rtw_adapter *adapt,
@@ -1159,10 +1159,10 @@ unsigned int OnAuthClient(struct rtw_ada
 	/* check A1 matches or not */
 	if (memcmp
 	    (myid(&(adapt->eeprompriv)), get_da(pframe), ETH_ALEN))
-		return _SUCCESS;
+		return 1;
 
 	if (!(pmlmeinfo->state & WIFI_FW_AUTH_STATE))
-		return _SUCCESS;
+		return 1;
 
 	offset = (GetPrivacy(pframe)) ? 4 : 0;
 
@@ -1202,7 +1202,7 @@ unsigned int OnAuthClient(struct rtw_ada
 			issue_auth(adapt, NULL, 0);
 			set_link_timer(pmlmeext, REAUTH_TO);
 
-			return _SUCCESS;
+			return 1;
 		} else {
 			/*  open system */
 			go2asoc = 1;
@@ -1220,12 +1220,12 @@ unsigned int OnAuthClient(struct rtw_ada
 
 	if (go2asoc) {
 		start_clnt_assoc(adapt);
-		return _SUCCESS;
+		return 1;
 	}
 
 authclnt_fail:
 
-	return _FAIL;
+	return 0;
 }
 
 unsigned int OnAssocReq(struct rtw_adapter *adapt,
@@ -1261,12 +1261,12 @@ unsigned int OnAssocReq(struct rtw_adapt
 	if (((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) &&
 	    check_buddy_fwstate(adapt, _FW_UNDER_LINKING | _FW_UNDER_SURVEY)) {
 		/* don't process assoc request; */
-		return _SUCCESS;
+		return 1;
 	}
 #endif /* CONFIG_CONCURRENT_MODE */
 
 	if ((pmlmeinfo->state & 0x03) != WIFI_FW_AP_STATE)
-		return _FAIL;
+		return 0;
 
 	frame_type = GetFrameSubType(pframe);
 	if (frame_type == WIFI_ASSOCREQ) {
@@ -1282,7 +1282,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 		DBG_8192D
 		    ("handle_assoc(reassoc=%d) - too short payload (len=%lu)"
 		     "\n", reassoc, (unsigned long)pkt_len);
-		return _FAIL;
+		return 0;
 	}
 
 	pstat = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
@@ -1398,7 +1398,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 
 		if (rtw_parse_wpa2_ie
 		    (wpa_ie - 2, wpa_ie_len + 2, &group_cipher,
-		     &pairwise_cipher) == _SUCCESS) {
+		     &pairwise_cipher) == 1) {
 			pstat->dot8021xalg = 1;	/*psk,  todo:802.1x */
 			pstat->wpa_psk |= BIT(1);
 
@@ -1425,7 +1425,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 
 		if (rtw_parse_wpa_ie
 		    (wpa_ie - 2, wpa_ie_len + 2, &group_cipher,
-		     &pairwise_cipher) == _SUCCESS) {
+		     &pairwise_cipher) == 1) {
 			pstat->dot8021xalg = 1;	/*psk,  todo:802.1x */
 			pstat->wpa_psk |= BIT(0);
 
@@ -1718,12 +1718,12 @@ unsigned int OnAssocReq(struct rtw_adapt
 		report_add_sta_event(adapt, pstat->hwaddr, pstat->aid);
 	}
 
-	return _SUCCESS;
+	return 1;
 
 asoc_class2_error:
 
 	issue_deauth(adapt, (void *)GetAddr2Ptr(pframe), status);
-	return _FAIL;
+	return 0;
 
 OnAssocReqFail:
 
@@ -1733,7 +1733,7 @@ OnAssocReqFail:
 	else
 		issue_asocrsp(adapt, status, pstat, WIFI_REASSOCRSP);
 #endif /* CONFIG_92D_AP_MODE */
-	return _FAIL;
+	return 0;
 }
 
 unsigned int OnAssocRsp(struct rtw_adapter *adapt,
@@ -1755,13 +1755,13 @@ unsigned int OnAssocRsp(struct rtw_adapt
 	/* check A1 matches or not */
 	if (memcmp
 	    (myid(&(adapt->eeprompriv)), get_da(pframe), ETH_ALEN))
-		return _SUCCESS;
+		return 1;
 
 	if (!(pmlmeinfo->state & (WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE)))
-		return _SUCCESS;
+		return 1;
 
 	if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
-		return _SUCCESS;
+		return 1;
 
 	del_timer_sync(&pmlmeext->link_timer);
 
@@ -1833,7 +1833,7 @@ report_assoc_result:
 
 	report_join_res(adapt, res);
 
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int OnDeAuth(struct rtw_adapter *adapt,
@@ -1853,7 +1853,7 @@ unsigned int OnDeAuth(struct rtw_adapter
 	    (!memcmp
 	     (GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network),
 	      ETH_ALEN)))
-		return _SUCCESS;
+		return 1;
 
 #ifdef CONFIG_P2P
 	if (pwdinfo->rx_invitereq_info.scan_op_ch_only) {
@@ -1889,7 +1889,7 @@ unsigned int OnDeAuth(struct rtw_adapter
 			associated_clients_update(adapt, updated);
 		}
 
-		return _SUCCESS;
+		return 1;
 	} else
 #endif
 	{
@@ -1898,7 +1898,7 @@ unsigned int OnDeAuth(struct rtw_adapter
 		receive_disconnect(adapt, GetAddr3Ptr(pframe), reason);
 	}
 	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int OnDisassoc(struct rtw_adapter *adapt,
@@ -1918,7 +1918,7 @@ unsigned int OnDisassoc(struct rtw_adapt
 	    (!memcmp
 	     (GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network),
 	      ETH_ALEN)))
-		return _SUCCESS;
+		return 1;
 
 #ifdef CONFIG_P2P
 	if (pwdinfo->rx_invitereq_info.scan_op_ch_only) {
@@ -1954,7 +1954,7 @@ unsigned int OnDisassoc(struct rtw_adapt
 			associated_clients_update(adapt, updated);
 		}
 
-		return _SUCCESS;
+		return 1;
 	} else
 #endif
 	{
@@ -1963,25 +1963,25 @@ unsigned int OnDisassoc(struct rtw_adapt
 		receive_disconnect(adapt, GetAddr3Ptr(pframe), reason);
 	}
 	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int OnAtim(struct rtw_adapter *adapt, struct recv_frame_hdr *precv_frame)
 {
 	DBG_8192D("%s\n", __func__);
-	return _SUCCESS;
+	return 1;
 }
 
 static unsigned int on_action_spct_ch_switch(struct rtw_adapter *adapt,
 					     struct sta_info *psta, u8 *ies,
 					     uint ies_len)
 {
-	unsigned int ret = _FAIL;
+	unsigned int ret = 0;
 	struct mlme_ext_priv *mlmeext = &adapt->mlmeextpriv;
 	struct mlme_ext_info *pmlmeinfo = &(mlmeext->mlmext_info);
 
 	if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {
-		ret = _SUCCESS;
+		ret = 1;
 		goto exit;
 	}
 
@@ -2012,7 +2012,7 @@ static unsigned int on_action_spct_ch_sw
 		}
 
 		if (ch == -1)
-			return _SUCCESS;
+			return 1;
 
 		if (ch_offset == -1)
 			bwmode = mlmeext->cur_bwmode;
@@ -2040,19 +2040,19 @@ exit:
 unsigned int on_action_spct(struct rtw_adapter *adapt,
 			    struct recv_frame_hdr *precv_frame)
 {
-	return _FAIL;
+	return 0;
 }
 
 unsigned int OnAction_qos(struct rtw_adapter *adapt,
 			  struct recv_frame_hdr *precv_frame)
 {
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int OnAction_dls(struct rtw_adapter *adapt,
 			  struct recv_frame_hdr *precv_frame)
 {
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int OnAction_back(struct rtw_adapter *adapt,
@@ -2071,19 +2071,19 @@ unsigned int OnAction_back(struct rtw_ad
 
 	/* check RA matches or not */
 	if (memcmp(myid(&(adapt->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))	/* for if1, sta/ap mode */
-		return _SUCCESS;
+		return 1;
 
 	DBG_8192D("%s\n", __func__);
 
 	if ((pmlmeinfo->state & 0x03) != WIFI_FW_AP_STATE)
 		if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
-			return _SUCCESS;
+			return 1;
 
 	addr = GetAddr2Ptr(pframe);
 	psta = rtw_get_stainfo(pstapriv, addr);
 
 	if (psta == NULL)
-		return _SUCCESS;
+		return 1;
 
 	frame_body =
 	    (unsigned char *)(pframe + sizeof(struct ieee80211_hdr_3addr));
@@ -2091,7 +2091,7 @@ unsigned int OnAction_back(struct rtw_ad
 	category = frame_body[0];
 	if (category == RTW_WLAN_CATEGORY_BACK) {	/*  representing Block Ack */
 		if (!pmlmeinfo->HT_enable)
-			return _SUCCESS;
+			return 1;
 
 		action = frame_body[1];
 		DBG_8192D("%s, action=%d\n", __func__, action);
@@ -2148,7 +2148,7 @@ unsigned int OnAction_back(struct rtw_ad
 			break;
 		}
 	}
-	return _SUCCESS;
+	return 1;
 }
 
 #ifdef CONFIG_P2P
@@ -4320,7 +4320,7 @@ void issue_probersp_p2p(struct rtw_adapt
 
 static int _issue_probereq_p2p(struct rtw_adapter *adapt, u8 *da, int wait_ack)
 {
-	int ret = _FAIL;
+	int ret = 0;
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	unsigned char *pframe;
@@ -4646,7 +4646,7 @@ static int _issue_probereq_p2p(struct rt
 		ret = dump_mgntframe_and_wait_ack(adapt, pmgntframe);
 	} else {
 		dump_mgntframe(adapt, pmgntframe);
-		ret = _SUCCESS;
+		ret = 1;
 	}
 
 exit:
@@ -4675,13 +4675,13 @@ int issue_probereq_p2p_ex(struct rtw_ada
 		if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
 			break;
 
-		if (i < try_cnt && wait_ms > 0 && ret == _FAIL)
+		if (i < try_cnt && wait_ms > 0 && ret == 0)
 			msleep(wait_ms);
 
-	} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));
+	} while ((i < try_cnt) && ((ret == 0) || (wait_ms == 0)));
 
-	if (ret != _FAIL) {
-		ret = _SUCCESS;
+	if (ret != 0) {
+		ret = 1;
 		goto exit;
 	}
 
@@ -4691,13 +4691,13 @@ int issue_probereq_p2p_ex(struct rtw_ada
 				  " to %pM, ch:%u%s, %d/%d in %u ms\n",
 				  FUNC_ADPT_ARG(adapter), da,
 				  rtw_get_oper_ch(adapter),
-				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  ret == 1 ? ", acked" : "", i, try_cnt,
 				  rtw_systime_to_ms(jiffies - start));
 		else
 			DBG_8192D(FUNC_ADPT_FMT ", ch:%u%s, %d/%d in %u ms\n",
 				  FUNC_ADPT_ARG(adapter),
 				  rtw_get_oper_ch(adapter),
-				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  ret == 1 ? ", acked" : "", i, try_cnt,
 				  rtw_systime_to_ms(jiffies - start));
 	}
 exit:
@@ -4722,7 +4722,7 @@ static s32 rtw_action_public_decache(str
 					  " seq_ctrl=0x%x, rxseq=0x%x, token:%d\n",
 					  FUNC_ADPT_ARG(adapter), seq_ctrl,
 					  mlmeext->action_public_rxseq, token);
-				return _FAIL;
+				return 0;
 			}
 		} else {
 			if (seq_ctrl == mlmeext->action_public_rxseq) {
@@ -4730,7 +4730,7 @@ static s32 rtw_action_public_decache(str
 					  " seq_ctrl=0x%x, rxseq=0x%x\n",
 					  FUNC_ADPT_ARG(adapter), seq_ctrl,
 					  mlmeext->action_public_rxseq);
-				return _FAIL;
+				return 0;
 			}
 		}
 	}
@@ -4740,7 +4740,7 @@ static s32 rtw_action_public_decache(str
 	if (token >= 0)
 		mlmeext->action_public_dialog_token = token;
 
-	return _SUCCESS;
+	return 1;
 }
 
 static unsigned int on_action_public_p2p(struct recv_frame_hdr *precv_frame)
@@ -4763,8 +4763,8 @@ static unsigned int on_action_public_p2p
 
 	dialogToken = frame_body[7];
 
-	if (rtw_action_public_decache(precv_frame, dialogToken) == _FAIL)
-		return _FAIL;
+	if (rtw_action_public_decache(precv_frame, dialogToken) == 0)
+		return 0;
 
 #ifdef CONFIG_P2P
 	del_timer_sync(&pwdinfo->reset_ch_sitesurvey);
@@ -4774,7 +4774,7 @@ static unsigned int on_action_public_p2p
 		/*      Do nothing if the driver doesn't enable the P2P function. */
 		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) ||
 		    rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
-			return _SUCCESS;
+			return 1;
 
 		len -= sizeof(struct ieee80211_hdr_3addr);
 
@@ -5273,12 +5273,12 @@ static unsigned int on_action_public_p2p
 	}
 #endif /* CONFIG_P2P */
 
-	return _SUCCESS;
+	return 1;
 }
 
 static unsigned int on_action_public_vendor(struct recv_frame_hdr *precv_frame)
 {
-	unsigned int ret = _FAIL;
+	unsigned int ret = 0;
 	u8 *pframe = precv_frame->rx_data;
 	uint frame_len = precv_frame->len;
 	u8 *frame_body = pframe + sizeof(struct ieee80211_hdr_3addr);
@@ -5293,7 +5293,7 @@ static unsigned int on_action_public_ven
 static unsigned int on_action_public_default(struct recv_frame_hdr *precv_frame, u8 action)
 {
 	struct rtw_adapter *adapter = precv_frame->adapter;
-	unsigned int ret = _FAIL;
+	unsigned int ret = 0;
 	u8 *pframe = precv_frame->rx_data;
 	uint frame_len = precv_frame->len;
 	u8 *frame_body = pframe + sizeof(struct ieee80211_hdr_3addr);
@@ -5303,14 +5303,14 @@ static unsigned int on_action_public_def
 
 	token = frame_body[2];
 
-	if (rtw_action_public_decache(precv_frame, token) == _FAIL)
+	if (rtw_action_public_decache(precv_frame, token) == 0)
 		goto exit;
 
 	cnt += sprintf((msg + cnt), "%s(token:%u)", action_public_str(action),
 		       token);
 	rtw_cfg80211_rx_action(adapter, pframe, frame_len, msg);
 
-	ret = _SUCCESS;
+	ret = 1;
 
 exit:
 	return ret;
@@ -5319,7 +5319,7 @@ exit:
 unsigned int on_action_public(struct rtw_adapter *adapt,
 			      struct recv_frame_hdr *precv_frame)
 {
-	unsigned int ret = _FAIL;
+	unsigned int ret = 0;
 	u8 *pframe = precv_frame->rx_data;
 	uint frame_len = precv_frame->len;
 	u8 *frame_body = pframe + sizeof(struct ieee80211_hdr_3addr);
@@ -5351,13 +5351,13 @@ exit:
 unsigned int OnAction_ht(struct rtw_adapter *adapt,
 			 struct recv_frame_hdr *precv_frame)
 {
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int OnAction_wmm(struct rtw_adapter *adapt,
 			  struct recv_frame_hdr *precv_frame)
 {
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int OnAction_p2p(struct rtw_adapter *adapt,
@@ -5374,21 +5374,21 @@ unsigned int OnAction_p2p(struct rtw_ada
 
 	/* check RA matches or not */
 	if (memcmp(myid(&(adapt->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))	/* for if1, sta/ap mode */
-		return _SUCCESS;
+		return 1;
 
 	frame_body =
 	    (unsigned char *)(pframe + sizeof(struct ieee80211_hdr_3addr));
 
 	category = frame_body[0];
 	if (category != RTW_WLAN_CATEGORY_P2P)
-		return _SUCCESS;
+		return 1;
 
 	if (be32_to_cpu(*((__be32 *)(frame_body + 1))) != P2POUI)
-		return _SUCCESS;
+		return 1;
 
 	if (wdev_to_priv(adapt->rtw_wdev)->p2p_enabled) {
 		rtw_cfg80211_rx_action_p2p(adapt, pframe, len);
-		return _SUCCESS;
+		return 1;
 	} else {
 		len -= sizeof(struct ieee80211_hdr_3addr);
 		OUI_Subtype = frame_body[5];
@@ -5408,7 +5408,7 @@ unsigned int OnAction_p2p(struct rtw_ada
 	}
 #endif /* CONFIG_P2P */
 
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int OnAction(struct rtw_adapter *adapt,
@@ -5432,14 +5432,14 @@ unsigned int OnAction(struct rtw_adapter
 		if (category == ptable->num)
 			ptable->func(adapt, precv_frame);
 	}
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int DoReserved(struct rtw_adapter *adapt,
 			struct recv_frame_hdr *precv_frame)
 {
 	/* DBG_8192D("rcvd mgt frame(%x, %x)\n", (GetFrameSubType(pframe) >> 4), *(unsigned int *)GetAddr1Ptr(pframe)); */
-	return _SUCCESS;
+	return 1;
 }
 
 struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv)
@@ -5532,7 +5532,7 @@ void dump_mgntframe(struct rtw_adapter *
 s32 dump_mgntframe_and_wait(struct rtw_adapter *adapt,
 			    struct xmit_frame *pmgntframe, int timeout_ms)
 {
-	s32 ret = _FAIL;
+	s32 ret = 0;
 	struct xmit_buf *pxmitbuf = pmgntframe->pxmitbuf;
 	struct submit_ctx sctx;
 
@@ -5545,7 +5545,7 @@ s32 dump_mgntframe_and_wait(struct rtw_a
 
 	ret = rtw_hal_mgnt_xmit(adapt, pmgntframe);
 
-	if (ret == _SUCCESS)
+	if (ret == 1)
 		ret = rtw_sctx_wait(&sctx);
 
 	return ret;
@@ -5555,7 +5555,7 @@ s32 dump_mgntframe_and_wait_ack(struct r
 				struct xmit_frame *pmgntframe)
 {
 	struct xmit_priv *pxmitpriv = &adapt->xmitpriv;
-	s32 ret = _FAIL;
+	s32 ret = 0;
 	u32 timeout_ms = 500;	/*   500ms */
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -5571,7 +5571,7 @@ s32 dump_mgntframe_and_wait_ack(struct r
 	pxmitpriv->ack_tx = true;
 
 	pmgntframe->ack_report = 1;
-	if (rtw_hal_mgnt_xmit(adapt, pmgntframe) == _SUCCESS) {
+	if (rtw_hal_mgnt_xmit(adapt, pmgntframe) == 1) {
 		ret = rtw_ack_tx_wait(pxmitpriv, timeout_ms);
 	}
 
@@ -6175,7 +6175,7 @@ void issue_probersp(struct rtw_adapter *
 static int _issue_probereq(struct rtw_adapter *adapt,
 		    struct ndis_802_11_ssid *pssid, u8 *da, int wait_ack)
 {
-	int ret = _FAIL;
+	int ret = 0;
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	unsigned char *pframe;
@@ -6270,7 +6270,7 @@ static int _issue_probereq(struct rtw_ad
 		ret = dump_mgntframe_and_wait_ack(adapt, pmgntframe);
 	} else {
 		dump_mgntframe(adapt, pmgntframe);
-		ret = _SUCCESS;
+		ret = 1;
 	}
 
 exit:
@@ -6301,13 +6301,13 @@ int issue_probereq_ex(struct rtw_adapter
 		if (adapt->bDriverStopped || adapt->bSurpriseRemoved)
 			break;
 
-		if (i < try_cnt && wait_ms > 0 && ret == _FAIL)
+		if (i < try_cnt && wait_ms > 0 && ret == 0)
 			msleep(wait_ms);
 
-	} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));
+	} while ((i < try_cnt) && ((ret == 0) || (wait_ms == 0)));
 
-	if (ret != _FAIL) {
-		ret = _SUCCESS;
+	if (ret != 0) {
+		ret = 1;
 		goto exit;
 	}
 
@@ -6317,13 +6317,13 @@ int issue_probereq_ex(struct rtw_adapter
 				  " to %pM, ch:%u%s, %d/%d in %u ms\n",
 				  FUNC_ADPT_ARG(adapt), da,
 				  rtw_get_oper_ch(adapt),
-				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  ret == 1 ? ", acked" : "", i, try_cnt,
 				  rtw_systime_to_ms(jiffies - start));
 		else
 			DBG_8192D(FUNC_ADPT_FMT ", ch:%u%s, %d/%d in %u ms\n",
 				  FUNC_ADPT_ARG(adapt),
 				  rtw_get_oper_ch(adapt),
-				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  ret == 1 ? ", acked" : "", i, try_cnt,
 				  rtw_systime_to_ms(jiffies - start));
 	}
 exit:
@@ -6658,7 +6658,7 @@ void issue_asocrsp(struct rtw_adapter *a
 
 void issue_assocreq(struct rtw_adapter *adapt)
 {
-	int ret = _FAIL;
+	int ret = 0;
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	unsigned char *pframe, *p;
@@ -7113,10 +7113,10 @@ void issue_assocreq(struct rtw_adapter *
 	pattrib->last_txcmdsz = pattrib->pktlen;
 	dump_mgntframe(adapt, pmgntframe);
 
-	ret = _SUCCESS;
+	ret = 1;
 
 exit:
-	if (ret == _SUCCESS)
+	if (ret == 1)
 		rtw_buf_update(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len,
 			       (u8 *)pwlanhdr, pattrib->pktlen);
 	else
@@ -7129,7 +7129,7 @@ exit:
 static int _issue_nulldata(struct rtw_adapter *adapt, unsigned char *da,
 			   unsigned int power_mode, int wait_ack)
 {
-	int ret = _FAIL;
+	int ret = 0;
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	unsigned char *pframe;
@@ -7192,7 +7192,7 @@ static int _issue_nulldata(struct rtw_ad
 		ret = dump_mgntframe_and_wait_ack(adapt, pmgntframe);
 	} else {
 		dump_mgntframe(adapt, pmgntframe);
-		ret = _SUCCESS;
+		ret = 1;
 	}
 
 exit:
@@ -7224,13 +7224,13 @@ int issue_nulldata(struct rtw_adapter *a
 		if (adapt->bDriverStopped || adapt->bSurpriseRemoved)
 			break;
 
-		if (i < try_cnt && wait_ms > 0 && ret == _FAIL)
+		if (i < try_cnt && wait_ms > 0 && ret == 0)
 			msleep(wait_ms);
 
-	} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));
+	} while ((i < try_cnt) && ((ret == 0) || (wait_ms == 0)));
 
-	if (ret != _FAIL) {
-		ret = _SUCCESS;
+	if (ret != 0) {
+		ret = 1;
 		goto exit;
 	}
 
@@ -7240,13 +7240,13 @@ int issue_nulldata(struct rtw_adapter *a
 				  " to %pM, ch:%u%s, %d/%d in %u ms\n",
 				  FUNC_ADPT_ARG(adapt), da,
 				  rtw_get_oper_ch(adapt),
-				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  ret == 1 ? ", acked" : "", i, try_cnt,
 				  rtw_systime_to_ms(jiffies - start));
 		else
 			DBG_8192D(FUNC_ADPT_FMT ", ch:%u%s, %d/%d in %u ms\n",
 				  FUNC_ADPT_ARG(adapt),
 				  rtw_get_oper_ch(adapt),
-				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  ret == 1 ? ", acked" : "", i, try_cnt,
 				  rtw_systime_to_ms(jiffies - start));
 	}
 exit:
@@ -7257,7 +7257,7 @@ exit:
 static int _issue_qos_nulldata(struct rtw_adapter *adapt, unsigned char *da,
 			       u16 tid, int wait_ack)
 {
-	int ret = _FAIL;
+	int ret = 0;
 	struct xmit_frame *pmgntframe;
 	struct pkt_attrib *pattrib;
 	unsigned char *pframe;
@@ -7325,7 +7325,7 @@ static int _issue_qos_nulldata(struct rt
 		ret = dump_mgntframe_and_wait_ack(adapt, pmgntframe);
 	} else {
 		dump_mgntframe(adapt, pmgntframe);
-		ret = _SUCCESS;
+		ret = 1;
 	}
 
 exit:
@@ -7357,13 +7357,13 @@ int issue_qos_nulldata(struct rtw_adapte
 		if (adapt->bDriverStopped || adapt->bSurpriseRemoved)
 			break;
 
-		if (i < try_cnt && wait_ms > 0 && ret == _FAIL)
+		if (i < try_cnt && wait_ms > 0 && ret == 0)
 			msleep(wait_ms);
 
-	} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));
+	} while ((i < try_cnt) && ((ret == 0) || (wait_ms == 0)));
 
-	if (ret != _FAIL) {
-		ret = _SUCCESS;
+	if (ret != 0) {
+		ret = 1;
 		goto exit;
 	}
 
@@ -7373,13 +7373,13 @@ int issue_qos_nulldata(struct rtw_adapte
 				  " to %pM, ch:%u%s, %d/%d in %u ms\n",
 				  FUNC_ADPT_ARG(adapt), da,
 				  rtw_get_oper_ch(adapt),
-				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  ret == 1 ? ", acked" : "", i, try_cnt,
 				  rtw_systime_to_ms(jiffies - start));
 		else
 			DBG_8192D(FUNC_ADPT_FMT ", ch:%u%s, %d/%d in %u ms\n",
 				  FUNC_ADPT_ARG(adapt),
 				  rtw_get_oper_ch(adapt),
-				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  ret == 1 ? ", acked" : "", i, try_cnt,
 				  rtw_systime_to_ms(jiffies - start));
 	}
 exit:
@@ -7397,7 +7397,7 @@ static int _issue_deauth(struct rtw_adap
 	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
-	int ret = _FAIL;
+	int ret = 0;
 	__le16 le_tmp;
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
@@ -7450,7 +7450,7 @@ static int _issue_deauth(struct rtw_adap
 		ret = dump_mgntframe_and_wait_ack(adapt, pmgntframe);
 	} else {
 		dump_mgntframe(adapt, pmgntframe);
-		ret = _SUCCESS;
+		ret = 1;
 	}
 
 exit:
@@ -7481,13 +7481,13 @@ int issue_deauth_ex(struct rtw_adapter *
 		if (adapt->bDriverStopped || adapt->bSurpriseRemoved)
 			break;
 
-		if (i < try_cnt && wait_ms > 0 && ret == _FAIL)
+		if (i < try_cnt && wait_ms > 0 && ret == 0)
 			msleep(wait_ms);
 
-	} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));
+	} while ((i < try_cnt) && ((ret == 0) || (wait_ms == 0)));
 
-	if (ret != _FAIL) {
-		ret = _SUCCESS;
+	if (ret != 0) {
+		ret = 1;
 		goto exit;
 	}
 
@@ -7497,13 +7497,13 @@ int issue_deauth_ex(struct rtw_adapter *
 				  " to %pM, ch:%u%s, %d/%d in %u ms\n",
 				  FUNC_ADPT_ARG(adapt), da,
 				  rtw_get_oper_ch(adapt),
-				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  ret == 1 ? ", acked" : "", i, try_cnt,
 				  rtw_systime_to_ms(jiffies - start));
 		else
 			DBG_8192D(FUNC_ADPT_FMT ", ch:%u%s, %d/%d in %u ms\n",
 				  FUNC_ADPT_ARG(adapt),
 				  rtw_get_oper_ch(adapt),
-				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  ret == 1 ? ", acked" : "", i, try_cnt,
 				  rtw_systime_to_ms(jiffies - start));
 	}
 exit:
@@ -7884,11 +7884,11 @@ unsigned int send_delba(struct rtw_adapt
 
 	if ((pmlmeinfo->state & 0x03) != WIFI_FW_AP_STATE)
 		if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
-			return _SUCCESS;
+			return 1;
 
 	psta = rtw_get_stainfo(pstapriv, addr);
 	if (psta == NULL)
-		return _SUCCESS;
+		return 1;
 
 	/* DBG_8192D("%s:%s\n", __func__, (initiator==0)?"RX_DIR":"TX_DIR"); */
 
@@ -7919,7 +7919,7 @@ unsigned int send_delba(struct rtw_adapt
 		}
 	}
 
-	return _SUCCESS;
+	return 1;
 }
 
 unsigned int send_beacon(struct rtw_adapter *adapt)
@@ -7946,11 +7946,11 @@ unsigned int send_beacon(struct rtw_adap
 		 !adapt->bDriverStopped);
 
 	if (adapt->bSurpriseRemoved || adapt->bDriverStopped)
-		return _FAIL;
+		return 0;
 	if (false == bxmitok) {
 		DBG_8192D("%s fail! %u ms\n", __func__,
 			  rtw_systime_to_ms(jiffies - start));
-		return _FAIL;
+		return 0;
 	} else {
 		u32 passing_time = rtw_systime_to_ms(jiffies - start);
 
@@ -7958,7 +7958,7 @@ unsigned int send_beacon(struct rtw_adap
 			DBG_8192D("%s success, issue:%d, poll:%d, %u ms\n",
 				  __func__, issue, poll,
 				  rtw_systime_to_ms(jiffies - start));
-		return _SUCCESS;
+		return 1;
 	}
 }
 
@@ -8316,7 +8316,7 @@ u8 collect_bss_info(struct rtw_adapter *
 
 	if (len > MAX_IE_SZ) {
 		/* DBG_8192D("IE too long for survey event\n"); */
-		return _FAIL;
+		return 0;
 	}
 
 	memset(bssid, 0, sizeof(struct wlan_bssid_ex));
@@ -8344,7 +8344,7 @@ u8 collect_bss_info(struct rtw_adapter *
 	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SSID_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
 	if (p == NULL) {
 		DBG_8192D("marc: cannot find SSID for survey event\n");
-		return _FAIL;
+		return 0;
 	}
 
 	if (*(p + 1)) {
@@ -8352,7 +8352,7 @@ u8 collect_bss_info(struct rtw_adapter *
 			DBG_8192D
 			    ("%s()-%d: IE too long (%d) for survey event\n",
 			     __func__, __LINE__, len);
-			return _FAIL;
+			return 0;
 		}
 		memcpy(bssid->Ssid.Ssid, (p + 2), *(p + 1));
 		bssid->Ssid.SsidLength = *(p + 1);
@@ -8371,7 +8371,7 @@ u8 collect_bss_info(struct rtw_adapter *
 			DBG_8192D
 			    ("%s()-%d: IE too long (%d) for survey event\n",
 			     __func__, __LINE__, len);
-			return _FAIL;
+			return 0;
 		}
 		memcpy(bssid->SupportedRates, (p + 2), len);
 		i = len;
@@ -8384,7 +8384,7 @@ u8 collect_bss_info(struct rtw_adapter *
 			DBG_8192D
 			    ("%s()-%d: IE too long (%d) for survey event\n",
 			     __func__, __LINE__, len);
-			return _FAIL;
+			return 0;
 		}
 		memcpy(bssid->SupportedRates + i, (p + 2), len);
 	}
@@ -8393,7 +8393,7 @@ u8 collect_bss_info(struct rtw_adapter *
 	bssid->NetworkTypeInUse = NDIS802_11OFDM24;
 
 	if (bssid->IELength < 12)
-		return _FAIL;
+		return 0;
 
 	/*  Checking for DSConfig */
 	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _DSSET_IE_, &len,
@@ -8463,7 +8463,7 @@ u8 collect_bss_info(struct rtw_adapter *
 		bssid->PhyInfo.SignalQuality = 101;
 	}
 
-	return _SUCCESS;
+	return 1;
 }
 
 void start_create_ibss(struct rtw_adapter *adapt)
@@ -8500,7 +8500,7 @@ void start_create_ibss(struct rtw_adapte
 		Set_MSR(adapt, (pmlmeinfo->state & 0x3));
 
 		/* issue beacon */
-		if (send_beacon(adapt) == _FAIL) {
+		if (send_beacon(adapt) == 0) {
 			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 				 ("issuing beacon frame fail....\n"));
 
@@ -8547,13 +8547,13 @@ void start_clnt_join(struct rtw_adapter
 	if (caps & cap_ESS) {
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		dc_join_status = dc_handle_join_request(adapt);
-		if (dc_join_status == _FAIL) {
+		if (dc_join_status == 0) {
 			DBG_8192D("dc_handle_join_request for STA fail !!!\n");
 			return;
 		}
 #endif
 #ifdef CONFIG_CONCURRENT_MODE
-		if (concurrent_chk_start_clnt_join(adapt) == _FAIL)
+		if (concurrent_chk_start_clnt_join(adapt) == 0)
 			return;
 #endif
 
@@ -8579,7 +8579,7 @@ void start_clnt_join(struct rtw_adapter
 	} else if (caps & cap_IBSS) {	/* adhoc client */
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		dc_join_status = dc_handle_join_request(adapt);
-		if (dc_join_status == _FAIL) {
+		if (dc_join_status == 0) {
 			DBG_8192D
 			    ("dc_handle_join_request for Ad-hoc fail !!!\n");
 			return;
@@ -8660,7 +8660,7 @@ unsigned int receive_disconnect(struct r
 	/* check A3 */
 	if (!
 	    (!memcmp(MacAddr, get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))
-		return _SUCCESS;
+		return 1;
 
 	DBG_8192D("%s\n", __func__);
 
@@ -8675,7 +8675,7 @@ unsigned int receive_disconnect(struct r
 		}
 	}
 
-	return _SUCCESS;
+	return 1;
 }
 
 static void process_80211d(struct rtw_adapter *adapt,
@@ -8985,7 +8985,7 @@ void report_survey_event(struct rtw_adap
 
 	if (collect_bss_info
 	    (adapt, precv_frame,
-	     (struct wlan_bssid_ex *)&psurvey_evt->bss) == _FAIL) {
+	     (struct wlan_bssid_ex *)&psurvey_evt->bss) == 0) {
 		kfree(pcmd_obj);
 		kfree(pevtcmd);
 		return;
@@ -9373,7 +9373,7 @@ void mlmeext_sta_add_event_callback(stru
 			correct_TSF(adapt, pmlmeext);
 
 			/* start beacon */
-			if (send_beacon(adapt) == _FAIL) {
+			if (send_beacon(adapt) == 0) {
 				pmlmeinfo->FW_sta_info[psta->mac_id].status = 0;
 				pmlmeinfo->state ^= WIFI_FW_ADHOC_STATE;
 				return;
@@ -9543,7 +9543,7 @@ void linked_status_chk(struct rtw_adapte
 	if (is_client_associated_to_ap(adapt)) {
 		/* linked infrastructure client mode */
 
-		int tx_chk = _SUCCESS, rx_chk = _SUCCESS;
+		int tx_chk = 1, rx_chk = 1;
 		int rx_chk_limit;
 
 		rx_chk_limit = 4;
@@ -9558,13 +9558,13 @@ void linked_status_chk(struct rtw_adapte
 #endif
 
 			if (chk_ap_is_alive(adapt, psta) == false)
-				rx_chk = _FAIL;
+				rx_chk = 0;
 
 			if (pxmitpriv->last_tx_pkts == pxmitpriv->tx_pkts)
-				tx_chk = _FAIL;
+				tx_chk = 0;
 
 			if (pmlmeext->active_keep_alive_check &&
-			    (rx_chk == _FAIL || tx_chk == _FAIL)) {
+			    (rx_chk == 0 || tx_chk == 0)) {
 				u8 backup_oper_channel = 0;
 
 				/* switch to correct channel of current network  before issue keep-alive frames */
@@ -9576,21 +9576,21 @@ void linked_status_chk(struct rtw_adapte
 						      pmlmeext->cur_channel);
 				}
 
-				if (rx_chk != _SUCCESS)
+				if (rx_chk != 1)
 					issue_probereq_ex(adapt,
 							  &pmlmeinfo->network.
 							  Ssid, psta->hwaddr, 3,
 							  1);
 
-				if ((tx_chk != _SUCCESS && pmlmeinfo->link_count++ == 0xf) ||
-				    rx_chk != _SUCCESS) {
+				if ((tx_chk != 1 && pmlmeinfo->link_count++ == 0xf) ||
+				    rx_chk != 1) {
 					tx_chk =
 					    issue_nulldata(adapt,
 							   psta->hwaddr, 0, 3,
 							   1);
-					/* if tx acked and p2p disabled, set rx_chk _SUCCESS to reset retry count */
-					if (tx_chk == _SUCCESS && !is_p2p_enable)
-						rx_chk = _SUCCESS;
+					/* if tx acked and p2p disabled, set rx_chk 1 to reset retry count */
+					if (tx_chk == 1 && !is_p2p_enable)
+						rx_chk = 1;
 				}
 
 				/* back to the original operation channel */
@@ -9598,7 +9598,7 @@ void linked_status_chk(struct rtw_adapte
 					SelectChannel(adapt,
 						      backup_oper_channel);
 			} else {
-				if (rx_chk != _SUCCESS) {
+				if (rx_chk != 1) {
 					if (pmlmeext->retry == 0) {
 						issue_probereq(adapt,
 							       &pmlmeinfo->
@@ -9621,12 +9621,12 @@ void linked_status_chk(struct rtw_adapte
 					}
 				}
 
-				if (tx_chk != _SUCCESS && pmlmeinfo->link_count++ == 0xf) {
+				if (tx_chk != 1 && pmlmeinfo->link_count++ == 0xf) {
 					tx_chk = issue_nulldata(adapt, NULL, 0, 1, 0);
 				}
 			}
 
-			if (rx_chk == _FAIL) {
+			if (rx_chk == 0) {
 				pmlmeext->retry++;
 				if (pmlmeext->retry > rx_chk_limit) {
 					DBG_8192D(FUNC_ADPT_FMT
@@ -9642,7 +9642,7 @@ void linked_status_chk(struct rtw_adapte
 				pmlmeext->retry = 0;
 			}
 
-			if (tx_chk == _FAIL) {
+			if (tx_chk == 0) {
 				pmlmeinfo->link_count &= 0xf;
 			} else {
 				pxmitpriv->last_tx_pkts = pxmitpriv->tx_pkts;
@@ -10426,19 +10426,19 @@ u8 set_tx_beacon_cmd(struct rtw_adapter
 	struct cmd_priv *pcmdpriv = &(adapt->cmdpriv);
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
-	u8 res = _SUCCESS;
+	u8 res = 1;
 	int len_diff = 0;
 
 	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
 	ptxBeacon_parm = (struct Tx_Beacon_param *)kzalloc(sizeof(struct Tx_Beacon_param), GFP_ATOMIC);
 	if (ptxBeacon_parm == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -10515,7 +10515,7 @@ u8 h2c_msg_hdl(struct rtw_adapter *adapt
 
 u8 tx_beacon_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
 {
-	if (send_beacon(adapt) == _FAIL) {
+	if (send_beacon(adapt) == 0) {
 		DBG_8192D("issue_beacon, fail!\n");
 		return H2C_PARAMETERS_ERROR;
 	}
@@ -10711,7 +10711,7 @@ u8 dc_handle_join_request(struct rtw_ada
 	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
 	struct mlme_ext_priv *pbuddy_mlmeext = NULL;
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
-	u8 ret = _SUCCESS;
+	u8 ret = 1;
 
 	if (pbuddy_adapter != NULL && adapt->DualMacConcurrent == true) {
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -10736,11 +10736,11 @@ u8 dc_handle_join_request(struct rtw_ada
 					if ((pmlmeext->cur_bwmode == pbuddy_mlmeext->cur_bwmode) &&
 					    (pmlmeext->cur_ch_offset != pbuddy_mlmeext-> cur_ch_offset)) {
 						report_join_res(adapt, -4);
-						ret = _FAIL;
+						ret = 0;
 					}
 				} else {
 					report_join_res(adapt, -4);
-					ret = _FAIL;
+					ret = 0;
 				}
 			}
 		} else if (is_client_associated_to_ap(pbuddy_adapter) == true) {
@@ -11262,7 +11262,7 @@ int check_buddy_mlmeinfo_state(struct rt
 
 int concurrent_chk_start_clnt_join(struct rtw_adapter *adapt)
 {
-	int ret = _FAIL;
+	int ret = 0;
 	struct mlme_ext_priv *pmlmeext;
 	struct rtw_adapter *pbuddy_adapter;
 	struct mlme_ext_priv *pbuddy_mlmeext;
@@ -11270,7 +11270,7 @@ int concurrent_chk_start_clnt_join(struc
 	struct mlme_priv *pbuddy_mlmepriv;
 
 	if (!rtw_buddy_adapter_up(adapt))
-		return _SUCCESS;
+		return 1;
 
 	pmlmeext = &adapt->mlmeextpriv;
 
@@ -11299,7 +11299,7 @@ int concurrent_chk_start_clnt_join(struc
 		struct wifidirect_info *pbuddy_wdinfo =
 		    &(pbuddy_adapter->wdinfo);
 		if (!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
-			return _SUCCESS;	/* wlan0-sta mode has higher priority than p2p0-p2p client */
+			return 1;	/* wlan0-sta mode has higher priority than p2p0-p2p client */
 #endif /* CONFIG_P2P */
 
 		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel) {
@@ -11326,7 +11326,7 @@ int concurrent_chk_start_clnt_join(struc
 			return ret;
 		}
 	}
-	return _SUCCESS;
+	return 1;
 }
 
 void concurrent_chk_joinbss_done(struct rtw_adapter *adapt, int join_res)
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -1046,10 +1046,10 @@ static u8 rtw_p2p_check_peer_oper_ch(str
 
 	for (i = 0; i < pmlmeext->max_chan_nums; i++) {
 		if (pmlmeext->channel_set[i].ChannelNum == ch)
-			return _SUCCESS;
+			return 1;
 	}
 
-	return _FAIL;
+	return 0;
 }
 
 static u8 rtw_p2p_ch_inclusion(struct mlme_ext_priv *pmlmeext, u8 *peer_ch_list, u8 peer_ch_num, u8 *ch_list_inclusioned)
@@ -2257,7 +2257,7 @@ void init_wifidirect_info(struct rtw_ada
 
 int rtw_p2p_enable(struct rtw_adapter *padapter, enum P2P_ROLE role)
 {
-	int ret = _SUCCESS;
+	int ret = 1;
 	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 
@@ -2278,8 +2278,8 @@ int rtw_p2p_enable(struct rtw_adapter *p
 #endif /* CONFIG_CONCURRENT_MODE */
 
 		/* leave IPS/Autosuspend */
-		if (_FAIL == rtw_pwr_wakeup(padapter)) {
-			ret = _FAIL;
+		if (0 == rtw_pwr_wakeup(padapter)) {
+			ret = 0;
 			goto exit;
 		}
 
@@ -2291,8 +2291,8 @@ int rtw_p2p_enable(struct rtw_adapter *p
 		/* Enable P2P function */
 		init_wifidirect_info(padapter, role);
 	} else if (role == P2P_ROLE_DISABLE) {
-		if (_FAIL == rtw_pwr_wakeup(padapter)) {
-			ret = _FAIL;
+		if (0 == rtw_pwr_wakeup(padapter)) {
+			ret = 0;
 			goto exit;
 		}
 
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -51,7 +51,7 @@ int ips_leave(struct rtw_adapter *padapt
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct security_priv *psecuritypriv = &(padapter->securitypriv);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	int result = _SUCCESS;
+	int result = 1;
 	int keyid;
 	_enter_pwrlock(&pwrpriv->lock);
 	if ((pwrpriv->rf_pwrstate == rf_off) && (!pwrpriv->bips_processing)) {
@@ -61,7 +61,7 @@ int ips_leave(struct rtw_adapter *padapt
 		DBG_8192D("==>ips_leave cnts:%d\n", pwrpriv->ips_leave_cnts);
 
 		result = rtw_ips_pwr_up(padapter);
-		if (result == _SUCCESS)
+		if (result == 1)
 			pwrpriv->rf_pwrstate = rf_on;
 
 		if ((_WEP40_ == psecuritypriv->dot11PrivacyAlgrthm) ||
@@ -485,14 +485,14 @@ inline void rtw_set_ips_deny(struct rtw_
 * rtw_pwr_wakeup - Wake the NIC up from: 1)IPS. 2)USB autosuspend
 * @adapter: pointer to _adapter structure
 * @ips_deffer_ms: the ms wiil prevent from falling into IPS after wakeup
-* Return _SUCCESS or _FAIL
+* Return 1 or 0
 */
 int _rtw_pwr_wakeup(struct rtw_adapter *padapter, u32 ips_deffer_ms,
 		    const char *caller)
 {
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	int ret = _SUCCESS;
+	int ret = 1;
 	u32 start = jiffies;
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -536,29 +536,29 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 	/* System suspend is not allowed to wakeup */
 	if ((pwrpriv->bInternalAutoSuspend == false) &&
 	    (true == pwrpriv->bInSuspend)) {
-		ret = _FAIL;
+		ret = 0;
 		goto exit;
 	}
 
 	/* block??? */
 	if ((pwrpriv->bInternalAutoSuspend == true) &&
 	    (padapter->net_closed == true)) {
-		ret = _FAIL;
+		ret = 0;
 		goto exit;
 	}
 
 	/* I think this should be check in IPS, LPS, autosuspend functions... */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
-		ret = _SUCCESS;
+		ret = 1;
 		goto exit;
 	}
 
 	if (rf_off == pwrpriv->rf_pwrstate) {
 		DBG_8192D("%s call ips_leave....\n", __func__);
-		if (_FAIL == ips_leave(padapter)) {
+		if (0 == ips_leave(padapter)) {
 			DBG_8192D
 			    ("======> ips_leave fail.............\n");
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 	}
@@ -618,7 +618,7 @@ int rtw_pm_set_ips(struct rtw_adapter *p
 		rtw_ips_mode_req(pwrctrlpriv, mode);
 		DBG_8192D("%s %s\n", __func__, "IPS_NONE");
 		if ((padapter->bSurpriseRemoved == 0) &&
-		    (_FAIL == rtw_pwr_wakeup(padapter)))
+		    (0 == rtw_pwr_wakeup(padapter)))
 			return -EFAULT;
 	} else {
 		return -EINVAL;
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -49,7 +49,7 @@ int _rtw_init_recv_priv(struct recv_priv
 
 	struct recv_frame_hdr *precvframe;
 
-	int res = _SUCCESS;
+	int res = 1;
 
 	spin_lock_init(&precvpriv->lock);
 
@@ -66,7 +66,7 @@ int _rtw_init_recv_priv(struct recv_priv
 			 RXFRAME_ALIGN_SZ);
 
 	if (precvpriv->pallocated_frame_buf == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	precvpriv->precv_frame_buf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(precvpriv->pallocated_frame_buf), RXFRAME_ALIGN_SZ);
@@ -209,7 +209,7 @@ int rtw_free_recvframe(struct recv_frame
 
 	spin_unlock_bh(&pfree_recv_queue->lock);
 
-	return _SUCCESS;
+	return 1;
 }
 
 int _rtw_enqueue_recvframe(struct recv_frame_hdr *precvframe, struct __queue *queue)
@@ -227,7 +227,7 @@ int _rtw_enqueue_recvframe(struct recv_f
 			precvpriv->free_recvframe_cnt++;
 	}
 
-	return _SUCCESS;
+	return 1;
 }
 
 int rtw_enqueue_recvframe(struct recv_frame_hdr *precvframe, struct __queue *queue)
@@ -300,7 +300,7 @@ int rtw_enqueue_recvbuf_to_head(struct r
 
 	spin_unlock_irqrestore(&queue->lock, irqL);
 
-	return _SUCCESS;
+	return 1;
 }
 
 int rtw_enqueue_recvbuf(struct recv_buf *precvbuf, struct __queue *queue)
@@ -315,7 +315,7 @@ int rtw_enqueue_recvbuf(struct recv_buf
 
 	spin_unlock_irqrestore(&queue->lock, irqL);
 
-	return _SUCCESS;
+	return 1;
 }
 
 struct recv_buf *rtw_dequeue_recvbuf(struct __queue *queue)
@@ -343,7 +343,7 @@ struct recv_buf *rtw_dequeue_recvbuf(str
 
 static int recvframe_chkmic(struct rtw_adapter *adapter, struct recv_frame_hdr *precvframe)
 {
-	int i, res = _SUCCESS;
+	int i, res = 1;
 	u32 datalen;
 	u8 miccode[8];
 	u8 bmic_err = false, brpt_micerror = true;
@@ -385,7 +385,7 @@ static int recvframe_chkmic(struct rtw_a
 				/*                                                              psecuritypriv->dot118021XGrpKeyid,pmlmeinfo->key_index,rxdata_key_idx); */
 
 				if (psecuritypriv->binstallGrpkey == false) {
-					res = _FAIL;
+					res = 0;
 					RT_TRACE(_module_rtl871x_recv_c_,
 						 _drv_err_,
 						 ("\n recvframe_chkmic:didn't install group key!!!!!!!!!!\n"));
@@ -506,7 +506,7 @@ static int recvframe_chkmic(struct rtw_a
 					     brpt_micerror);
 				}
 
-				res = _FAIL;
+				res = 0;
 
 			} else {
 				/* mic checked ok */
@@ -538,7 +538,7 @@ static struct recv_frame_hdr *decryptor(
 	struct rx_pkt_attrib *prxattrib = &precv_frame->attrib;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct recv_frame_hdr *return_packet = precv_frame;
-	u32 res = _SUCCESS;
+	u32 res = 1;
 
 	RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
 		 ("prxstat->decrypted=%x prxattrib->encrypt = 0x%03x\n",
@@ -596,7 +596,7 @@ static struct recv_frame_hdr *decryptor(
 		psecuritypriv->hw_decrypted = true;
 	}
 
-	if (res == _FAIL) {
+	if (res == 0) {
 		rtw_free_recvframe(return_packet,
 				   &padapter->recvpriv.free_recv_queue);
 		return_packet = NULL;
@@ -705,7 +705,7 @@ static int recv_decache(struct recv_fram
 			 ("recv_decache, (tid>15)! seq_ctrl=0x%x, tid=0x%x\n",
 			  seq_ctrl, tid));
 
-		return _FAIL;
+		return 0;
 	}
 
 	if (1) {		/* if (bretry) */
@@ -714,13 +714,13 @@ static int recv_decache(struct recv_fram
 				 ("recv_decache, seq_ctrl=0x%x, tid=0x%x, tid_rxseq=0x%x\n",
 				  seq_ctrl, tid, prxcache->tid_rxseq[tid]));
 
-			return _FAIL;
+			return 0;
 		}
 	}
 
 	prxcache->tid_rxseq[tid] = seq_ctrl;
 
-	return _SUCCESS;
+	return 1;
 }
 
 static void process_pwrbit_data(struct rtw_adapter *padapter,
@@ -841,7 +841,7 @@ static int sta2sta_data_frame(struct rtw
 		       struct recv_frame_hdr *precv_frame, struct sta_info **psta)
 {
 	u8 *ptr = precv_frame->rx_data;
-	int ret = _SUCCESS;
+	int ret = 1;
 	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
 	struct sta_priv *pstapriv = &adapter->stapriv;
 	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
@@ -856,19 +856,19 @@ static int sta2sta_data_frame(struct rtw
 		if (!memcmp(myhwaddr, pattrib->src, ETH_ALEN)) {
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 				 (" SA==myself\n"));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
 		if ((memcmp(myhwaddr, pattrib->dst, ETH_ALEN)) && (!bmcast)) {
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
 		if (!memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 		    !memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 		    (memcmp(pattrib->bssid, mybssid, ETH_ALEN))) {
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -880,7 +880,7 @@ static int sta2sta_data_frame(struct rtw
 		    (pattrib->bssid, pattrib->src, ETH_ALEN)) {
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 				 ("bssid != TA under STATION_MODE; drop pkt\n"));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -889,7 +889,7 @@ static int sta2sta_data_frame(struct rtw
 		if (bmcast) {
 			/*  For AP mode, if DA == MCAST, then BSSID should be also MCAST */
 			if (!IS_MCAST(pattrib->bssid)) {
-				ret = _FAIL;
+				ret = 0;
 				goto exit;
 			}
 		} else {	/*  not mc-frame */
@@ -897,7 +897,7 @@ static int sta2sta_data_frame(struct rtw
 			/*  For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID */
 			if (memcmp
 			    (pattrib->bssid, pattrib->dst, ETH_ALEN)) {
-				ret = _FAIL;
+				ret = 0;
 				goto exit;
 			}
 
@@ -913,7 +913,7 @@ static int sta2sta_data_frame(struct rtw
 
 		sta_addr = mybssid;
 	} else {
-		ret = _FAIL;
+		ret = 0;
 	}
 
 	if (bmcast)
@@ -924,7 +924,7 @@ static int sta2sta_data_frame(struct rtw
 	if (*psta == NULL) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 			 ("can't get psta under sta2sta_data_frame ; drop pkt\n"));
-		ret = _FAIL;
+		ret = 0;
 		goto exit;
 	}
 
@@ -938,7 +938,7 @@ static int ap2sta_data_frame(struct rtw_
 {
 	u8 *ptr = precv_frame->rx_data;
 	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
-	int ret = _SUCCESS;
+	int ret = 1;
 	struct sta_priv *pstapriv = &adapter->stapriv;
 	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
 	u8 *mybssid = get_bssid(pmlmepriv);
@@ -952,7 +952,7 @@ static int ap2sta_data_frame(struct rtw_
 		if (!memcmp(myhwaddr, pattrib->src, ETH_ALEN)) {
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 				 (" SA==myself\n"));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -961,7 +961,7 @@ static int ap2sta_data_frame(struct rtw_
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
 				 (" ap2sta_data_frame:  compare DA fail; DA=%pM\n",
 				  pattrib->dst));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -982,7 +982,7 @@ static int ap2sta_data_frame(struct rtw_
 					     WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
 			}
 
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -994,7 +994,7 @@ static int ap2sta_data_frame(struct rtw_
 		if (*psta == NULL) {
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 				 ("ap2sta: can't get psta under STATION_MODE ; drop pkt\n"));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -1020,7 +1020,7 @@ static int ap2sta_data_frame(struct rtw_
 		if (*psta == NULL) {
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 				 ("can't get psta under MP_MODE ; drop pkt\n"));
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -1041,7 +1041,7 @@ static int ap2sta_data_frame(struct rtw_
 			}
 		}
 
-		ret = _FAIL;
+		ret = 0;
 	}
 
 exit:
@@ -1057,12 +1057,12 @@ static int sta2ap_data_frame(struct rtw_
 	struct sta_priv *pstapriv = &adapter->stapriv;
 	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
 	unsigned char *mybssid = get_bssid(pmlmepriv);
-	int ret = _SUCCESS;
+	int ret = 1;
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
 		/* For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR */
 		if (memcmp(pattrib->bssid, mybssid, ETH_ALEN)) {
-			ret = _FAIL;
+			ret = 0;
 			goto exit;
 		}
 
@@ -1124,12 +1124,12 @@ static int validate_recv_ctrl_frame(stru
 	/* DBG_8192D("+validate_recv_ctrl_frame\n"); */
 
 	if (GetFrameType(pframe) != WIFI_CTRL_TYPE) {
-		return _FAIL;
+		return 0;
 	}
 
 	/* receive the frames that ra(a1) is my address */
 	if (memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN))
-		return _FAIL;
+		return 0;
 
 	/* only handle ps-poll */
 	if (GetFrameSubType(pframe) == WIFI_PSPOLL) {
@@ -1141,7 +1141,7 @@ static int validate_recv_ctrl_frame(stru
 		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
 
 		if ((psta == NULL) || (psta->aid != aid))
-			return _FAIL;
+			return 0;
 
 		/* for rx pkt statistics */
 		psta->sta_stats.rx_ctrl_pkts++;
@@ -1167,7 +1167,7 @@ static int validate_recv_ctrl_frame(stru
 		}
 
 		if (wmmps_ac)
-			return _FAIL;
+			return 0;
 
 		if (psta->state & WIFI_STA_ALIVE_CHK_STATE) {
 			DBG_8192D("%s alive check-rx ps-poll\n", __func__);
@@ -1246,7 +1246,7 @@ static int validate_recv_ctrl_frame(stru
 	}
 #endif
 
-	return _FAIL;
+	return 0;
 }
 
 struct recv_frame_hdr *recvframe_chk_defrag(struct rtw_adapter *padapter,
@@ -1261,7 +1261,7 @@ static int validate_recv_mgnt_frame(stru
 	if (precv_frame == NULL) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
 			 ("%s: fragment packet\n", __func__));
-		return _SUCCESS;
+		return 1;
 	}
 
 	{
@@ -1288,7 +1288,7 @@ static int validate_recv_mgnt_frame(stru
 
 	mgt_dispatcher(padapter, precv_frame);
 
-	return _SUCCESS;
+	return 1;
 }
 
 static int validate_recv_data_frame(struct rtw_adapter *adapter,
@@ -1300,7 +1300,7 @@ static int validate_recv_data_frame(stru
 	u8 *ptr = precv_frame->rx_data;
 	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
 	struct security_priv *psecuritypriv = &adapter->securitypriv;
-	int ret = _SUCCESS;
+	int ret = 1;
 
 	bretry = GetRetry(ptr);
 	pda = get_da(ptr);
@@ -1308,7 +1308,7 @@ static int validate_recv_data_frame(stru
 	pbssid = get_hdr_bssid(ptr);
 
 	if (pbssid == NULL) {
-		ret = _FAIL;
+		ret = 0;
 		goto exit;
 	}
 
@@ -1336,21 +1336,21 @@ static int validate_recv_data_frame(stru
 	case 3:
 		memcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);
 		memcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);
-		ret = _FAIL;
+		ret = 0;
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, (" case 3\n"));
 		break;
 	default:
-		ret = _FAIL;
+		ret = 0;
 		break;
 	}
 
-	if (ret == _FAIL || ret == RTW_RX_HANDLED)
+	if (ret == 0 || ret == RTW_RX_HANDLED)
 		goto exit;
 
 	if (psta == NULL) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 			 (" after to_fr_ds_chk; psta==NULL\n"));
-		ret = _FAIL;
+		ret = 0;
 		goto exit;
 	}
 
@@ -1381,10 +1381,10 @@ static int validate_recv_data_frame(stru
 
 	/*  decache, drop duplicate recv packets */
 	if (recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) ==
-	    _FAIL) {
+	    0) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 			 ("decache : drop pkt\n"));
-		ret = _FAIL;
+		ret = 0;
 		goto exit;
 	}
 
@@ -1425,7 +1425,7 @@ static int validate_recv_frame(struct rt
 	struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
 	u8 type;
 	u8 subtype;
-	int retval = _SUCCESS;
+	int retval = 1;
 	u8 *ptr = precv_frame->rx_data;
 	u8 ver = (unsigned char)(*ptr) & 0x3;
 
@@ -1441,7 +1441,7 @@ static int validate_recv_frame(struct rt
 	if (ver != 0) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 			 ("validate_recv_data_frame fail! (ver!=0)\n"));
-		retval = _FAIL;
+		retval = 0;
 		goto exit;
 	}
 
@@ -1461,23 +1461,23 @@ static int validate_recv_frame(struct rt
 	switch (type) {
 	case WIFI_MGT_TYPE:	/* mgnt */
 		retval = validate_recv_mgnt_frame(adapter, precv_frame);
-		if (retval == _FAIL)
+		if (retval == 0)
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 				 ("validate_recv_mgnt_frame fail\n"));
-		retval = _FAIL;	/*  only data frame return _SUCCESS */
+		retval = 0;	/*  only data frame return 1 */
 		break;
 	case WIFI_CTRL_TYPE:	/* ctrl */
 		retval = validate_recv_ctrl_frame(adapter, precv_frame);
-		if (retval == _FAIL)
+		if (retval == 0)
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 				 ("validate_recv_ctrl_frame fail\n"));
-		retval = _FAIL;	/*  only data frame return _SUCCESS */
+		retval = 0;	/*  only data frame return 1 */
 		break;
 	case WIFI_DATA_TYPE:	/* data */
 		rtw_led_control(adapter, LED_CTL_RX);
 		pattrib->qos = (subtype & BIT(7)) ? 1 : 0;
 		retval = validate_recv_data_frame(adapter, precv_frame);
-		if (retval == _FAIL) {
+		if (retval == 0) {
 			struct recv_priv *precvpriv = &adapter->recvpriv;
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 				 ("validate_recv_data_frame fail\n"));
@@ -1487,7 +1487,7 @@ static int validate_recv_frame(struct rt
 	default:
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 			 ("validate_recv_data_frame fail! type=0x%x\n", type));
-		retval = _FAIL;
+		retval = 0;
 		break;
 	}
 
@@ -1507,7 +1507,7 @@ static int wlanhdr_to_ethhdr(struct recv
 	struct ieee80211_snap_hdr *psnap;
 	__be16 be_tmp;
 
-	int ret = _SUCCESS;
+	int ret = 1;
 	struct rtw_adapter *adapter = precvframe->adapter;
 	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
 
@@ -1761,9 +1761,9 @@ struct recv_frame_hdr *recvframe_chk_def
 	}
 	if ((prtnframe != NULL) && (prtnframe->attrib.privacy)) {
 		/* after defrag we must check tkip mic code */
-		if (recvframe_chkmic(padapter, prtnframe) == _FAIL) {
+		if (recvframe_chkmic(padapter, prtnframe) == 0) {
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
-				 ("recvframe_chkmic(padapter,  prtnframe)==_FAIL\n"));
+				 ("recvframe_chkmic(padapter,  prtnframe)==0\n"));
 			rtw_free_recvframe(prtnframe, pfree_recv_queue);
 			prtnframe = NULL;
 		}
@@ -1783,7 +1783,7 @@ static int amsdu_to_msdu(struct rtw_adap
 	struct sk_buff *sub_skb, *subframes[MAX_SUBFRAME_COUNT];
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 	struct __queue *pfree_recv_queue = &(precvpriv->free_recv_queue);
-	int ret = _SUCCESS;
+	int ret = 1;
 	nr_subframes = 0;
 
 	pattrib = &prframe->attrib;
@@ -2017,7 +2017,7 @@ static int recv_indicatepkts_in_order(st
 
 			} else if (pattrib->amsdu == 1) {
 				if (amsdu_to_msdu(padapter, prframe) !=
-				    _SUCCESS) {
+				    1) {
 					rtw_free_recvframe(prframe,
 							   &precvpriv->
 							   free_recv_queue);
@@ -2040,7 +2040,7 @@ static int recv_indicatepkts_in_order(st
 static int recv_indicatepkt_reorder(struct rtw_adapter *padapter,
 				    struct recv_frame_hdr *prframe)
 {
-	int retval = _SUCCESS;
+	int retval = 1;
 	struct rx_pkt_attrib *pattrib = &prframe->attrib;
 	struct recv_reorder_ctrl *preorder_ctrl = prframe->preorder_ctrl;
 	struct __queue *ppending_recvframe_queue =
@@ -2057,9 +2057,9 @@ static int recv_indicatepkt_reorder(stru
 				RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_,
 					 ("@@@@  recv_indicatepkt_reorder -recv_func recv_indicatepkt\n"));
 				rtw_recv_indicatepkt(padapter, prframe);
-				return _SUCCESS;
+				return 1;
 			}
-			return _FAIL;
+			return 0;
 		}
 
 		if (preorder_ctrl->enable == false) {
@@ -2070,7 +2070,7 @@ static int recv_indicatepkt_reorder(stru
 
 			preorder_ctrl->indicate_seq =
 			    (preorder_ctrl->indicate_seq + 1) % 4096;
-			return _SUCCESS;
+			return 1;
 		}
 	} else if (pattrib->amsdu == 1) {	/* temp filter -> means didn't support A-MSDUs in a A-MPDU */
 		if (preorder_ctrl->enable == false) {
@@ -2087,7 +2087,7 @@ static int recv_indicatepkt_reorder(stru
 				 __func__, __LINE__, preorder_ctrl->indicate_seq,
 				 pattrib->seq_num);
 
-			if (retval != _SUCCESS) {
+			if (retval != 1) {
 				DBG_8192D("DBG_RX_DROP_FRAME %s amsdu_to_msdu fail\n",
 					 __func__);
 			}
@@ -2134,10 +2134,10 @@ static int recv_indicatepkt_reorder(stru
 		del_timer_sync(&preorder_ctrl->reordering_ctrl_timer);
 	}
 	spin_unlock_bh(&ppending_recvframe_queue->lock);
-	return _SUCCESS;
+	return 1;
 _err_exit:
 	spin_unlock_bh(&ppending_recvframe_queue->lock);
-	return _FAIL;
+	return 0;
 }
 
 void rtw_reordering_ctrl_timeout_handler(void *pcontext)
@@ -2166,24 +2166,24 @@ void rtw_reordering_ctrl_timeout_handler
 static int process_recv_indicatepkts(struct rtw_adapter *padapter,
 				     struct recv_frame_hdr *prframe)
 {
-	int retval = _SUCCESS;
+	int retval = 1;
 	/* struct recv_priv *precvpriv = &padapter->recvpriv; */
 	/* struct rx_pkt_attrib *pattrib = &prframe->attrib; */
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
 
 	if (phtpriv->ht_option == true)	/* B/G/N Mode */ {
-		if (recv_indicatepkt_reorder(padapter, prframe) != _SUCCESS) {
+		if (recv_indicatepkt_reorder(padapter, prframe) != 1) {
 			/*  perform A-MPDU Rx Ordering Buffer Control */
 			if ((padapter->bDriverStopped == false) &&
 			    (padapter->bSurpriseRemoved == false)) {
-				retval = _FAIL;
+				retval = 0;
 				return retval;
 			}
 		}
 	} else {	/* B/G mode */
 		retval = wlanhdr_to_ethhdr(prframe);
-		if (retval != _SUCCESS) {
+		if (retval != 1) {
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 				 ("wlanhdr_to_ethhdr: drop pkt\n"));
 			return retval;
@@ -2204,7 +2204,7 @@ static int process_recv_indicatepkts(str
 				 ("recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)",
 				  padapter->bDriverStopped,
 				  padapter->bSurpriseRemoved));
-			retval = _FAIL;
+			retval = 0;
 			return retval;
 		}
 	}
@@ -2213,14 +2213,14 @@ static int process_recv_indicatepkts(str
 
 static int recv_func_prehandle(struct rtw_adapter *padapter, struct recv_frame_hdr *rframe)
 {
-	int ret = _SUCCESS;
+	int ret = 1;
 	struct rx_pkt_attrib *pattrib = &rframe->attrib;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 	struct __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
 
 	/* check the frame crtl field and decache */
 	ret = validate_recv_frame(padapter, rframe);
-	if (ret != _SUCCESS) {
+	if (ret != 1) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
 			 ("recv_func: validate_recv_frame fail! drop pkt\n"));
 		rtw_free_recvframe(rframe, pfree_recv_queue);	/* free this recv_frame */
@@ -2234,7 +2234,7 @@ exit:
 static int recv_func_posthandle(struct rtw_adapter *padapter,
 			 struct recv_frame_hdr *prframe)
 {
-	int ret = _SUCCESS;
+	int ret = 1;
 	struct recv_frame_hdr *orig_prframe = prframe;
 	struct rx_pkt_attrib *pattrib = &prframe->attrib;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
@@ -2247,7 +2247,7 @@ static int recv_func_posthandle(struct r
 	if (prframe == NULL) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 			 ("decryptor: drop pkt\n"));
-		ret = _FAIL;
+		ret = 0;
 		goto _recv_data_drop;
 	}
 	prframe = recvframe_chk_defrag(padapter, prframe);
@@ -2261,13 +2261,13 @@ static int recv_func_posthandle(struct r
 	if (prframe == NULL) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 			 ("portctrl: drop pkt\n"));
-		ret = _FAIL;
+		ret = 0;
 		goto _recv_data_drop;
 	}
 	count_rx_stats(padapter, prframe, NULL);
 
 	ret = process_recv_indicatepkts(padapter, prframe);
-	if (ret != _SUCCESS) {
+	if (ret != 1) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
 			 ("recv_func: process_recv_indicatepkts fail!\n"));
 		rtw_free_recvframe(orig_prframe, pfree_recv_queue);	/* free this recv_frame */
@@ -2299,7 +2299,7 @@ static int recv_func(struct rtw_adapter
 			rtw_alloc_recvframe(&padapter->recvpriv.
 					    uc_swdec_pending_queue))) {
 			if (recv_func_posthandle(padapter, pending_frame) ==
-			    _SUCCESS)
+			    1)
 				DBG_8192D
 				    ("%s: dequeue uc_swdec_pending_queue\n",
 				     __func__);
@@ -2308,7 +2308,7 @@ static int recv_func(struct rtw_adapter
 
 	ret = recv_func_prehandle(padapter, rframe);
 
-	if (ret == _SUCCESS) {
+	if (ret == 1) {
 		/* check if need to enqueue into uc_swdec_pending_queue */
 		if (check_fwstate(mlmepriv, WIFI_STATION_STATE) &&
 		    !IS_MCAST(prxattrib->ra) && prxattrib->encrypt > 0 &&
@@ -2336,14 +2336,14 @@ s32 rtw_recv_entry(struct recv_frame_hdr
 {
 	struct rtw_adapter *padapter;
 	struct recv_priv *precvpriv;
-	s32 ret = _SUCCESS;
+	s32 ret = 1;
 
 	padapter = precvframe->adapter;
 
 	precvpriv = &padapter->recvpriv;
 
 	ret = recv_func(padapter, precvframe);
-	if (ret == _FAIL) {
+	if (ret == 0) {
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
 			 ("rtw_recv_entry: recv_func return fail!!!\n"));
 		goto _recv_entry_drop;
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -626,10 +626,10 @@ u32 rtw_tkip_encrypt(struct rtw_adapter
 	struct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
-	u32 res = _SUCCESS;
+	u32 res = 1;
 
 	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
-		return _FAIL;
+		return 0;
 
 	pframe = ((struct xmit_frame *)pxmitframe)->buf_addr + TXDESC_SIZE +
 	    (((struct xmit_frame *)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);
@@ -710,7 +710,7 @@ u32 rtw_tkip_encrypt(struct rtw_adapter
 		} else {
 			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
 				 ("rtw_tkip_encrypt: stainfo == NULL!!!\n"));
-			res = _FAIL;
+			res = 0;
 		}
 	}
 
@@ -734,7 +734,7 @@ u32 rtw_tkip_decrypt(struct rtw_adapter
 	struct rx_pkt_attrib *prxattrib =
 	    &((struct recv_frame_hdr *)precvframe)->attrib;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
-	u32 res = _SUCCESS;
+	u32 res = 1;
 
 	pframe =
 	    (unsigned char *)((struct recv_frame_hdr *)precvframe)->rx_data;
@@ -746,7 +746,7 @@ u32 rtw_tkip_decrypt(struct rtw_adapter
 		if (stainfo != NULL) {
 			if (IS_MCAST(prxattrib->ra)) {
 				if (psecuritypriv->binstallGrpkey == false) {
-					res = _FAIL;
+					res = 0;
 					DBG_8192D
 					    ("%s:rx bc/mc packets, but didn't install group key!!!!!!!!!!\n",
 					     __func__);
@@ -796,12 +796,12 @@ u32 rtw_tkip_decrypt(struct rtw_adapter
 					  payload[length - 2], crc[1],
 					  payload[length - 3], crc[0],
 					  payload[length - 4]));
-				res = _FAIL;
+				res = 0;
 			}
 		} else {
 			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
 				 ("rtw_tkip_decrypt: stainfo == NULL!!!\n"));
-			res = _FAIL;
+			res = 0;
 		}
 	}
 
@@ -1338,7 +1338,7 @@ static int aes_cipher(u8 *key, uint hdrl
 	for (j = 0; j < 8; j++)
 		pframe[payload_index++] = chain_buffer[j];
 
-	return _SUCCESS;
+	return 1;
 }
 
 u32 rtw_aes_encrypt(struct rtw_adapter *padapter, u8 *pxmitframe)
@@ -1353,10 +1353,10 @@ u32 rtw_aes_encrypt(struct rtw_adapter *
 	struct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
-	u32 res = _SUCCESS;
+	u32 res = 1;
 
 	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
-		return _FAIL;
+		return 0;
 
 	pframe = ((struct xmit_frame *)pxmitframe)->buf_addr + TXDESC_SIZE +
 		 (((struct xmit_frame *)pxmitframe)->pkt_offset *
@@ -1409,7 +1409,7 @@ u32 rtw_aes_encrypt(struct rtw_adapter *
 		} else {
 			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
 				 ("rtw_aes_encrypt: stainfo == NULL!!!\n"));
-			res = _FAIL;
+			res = 0;
 		}
 	}
 
@@ -1421,7 +1421,7 @@ static int aes_decipher(u8 *key, uint hd
 	static u8 message[MAX_MSG_SIZE];
 	uint qc_exists, a4_exists, i, j, payload_remainder,
 	    num_blocks, payload_index;
-	int res = _SUCCESS;
+	int res = 1;
 	u8 pn_vector[6];
 	u8 mic_iv[16];
 	u8 mic_header1[16];
@@ -1623,11 +1623,11 @@ static int aes_decipher(u8 *key, uint hd
 			    ("aes_decipher:mic check error mic[%d]: pframe(%x) != message(%x)\n",
 			     i, pframe[hdrlen + 8 + plen - 8 + i],
 			     message[hdrlen + 8 + plen - 8 + i]);
-			res = _FAIL;
+			res = 0;
 		}
 	}
 
-	if (res == _FAIL) {
+	if (res == 0) {
 		int gg = 0;
 		for (gg = 0; gg < 32; gg++)
 			DBG_8192D(" [%d]=%02x ", gg, pframe[gg]);
@@ -1648,7 +1648,7 @@ u32 rtw_aes_decrypt(struct rtw_adapter *
 	struct rx_pkt_attrib *prxattrib =
 	    &((struct recv_frame_hdr *)precvframe)->attrib;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
-	u32 res = _SUCCESS;
+	u32 res = 1;
 
 	pframe =
 	    (unsigned char *)((struct recv_frame_hdr *)precvframe)->rx_data;
@@ -1663,7 +1663,7 @@ u32 rtw_aes_decrypt(struct rtw_adapter *
 			if (IS_MCAST(prxattrib->ra)) {
 				/* in concurrent we should use sw descrypt in group key, so we remove this message */
 				if (psecuritypriv->binstallGrpkey == false) {
-					res = _FAIL;
+					res = 0;
 					DBG_8192D
 					    ("%s:rx bc/mc packets, but didn't install group key!!!!!!!!!!\n",
 					     __func__);
@@ -1680,7 +1680,7 @@ u32 rtw_aes_decrypt(struct rtw_adapter *
 					    ("not match packet_index =%d, install_index =%d\n",
 					     prxattrib->key_index,
 					     psecuritypriv->dot118021XGrpKeyid);
-					res = _FAIL;
+					res = 0;
 					goto exit;
 				}
 			} else {
@@ -1697,7 +1697,7 @@ u32 rtw_aes_decrypt(struct rtw_adapter *
 		} else {
 			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
 				 ("rtw_aes_encrypt: stainfo == NULL!!!\n"));
-			res = _FAIL;
+			res = 0;
 		}
 	}
 
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -75,7 +75,7 @@ u32	_rtw_init_sta_priv(struct	sta_priv *
 						   NUM_STA + 4);
 
 	if (!pstapriv->pallocated_stainfo_buf)
-		return _FAIL;
+		return 0;
 
 	pstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -
 		((SIZE_PTR)(pstapriv->pallocated_stainfo_buf) & 3);
@@ -119,7 +119,7 @@ u32	_rtw_init_sta_priv(struct	sta_priv *
 
 #endif
 
-	return _SUCCESS;
+	return 1;
 }
 
 inline int rtw_stainfo_offset(struct sta_priv *stapriv, struct sta_info *sta)
@@ -223,7 +223,7 @@ u32	_rtw_free_sta_priv(struct	sta_priv *
 			vfree(pstapriv->pallocated_stainfo_buf);
 	}
 
-	return _SUCCESS;
+	return 1;
 }
 
 struct	sta_info *rtw_alloc_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
@@ -445,7 +445,7 @@ u32	rtw_free_stainfo(struct rtw_adapter
 
 exit:
 
-	return _SUCCESS;
+	return 1;
 }
 
 /*  free all stainfo which in sta_hash[all] */
@@ -523,7 +523,7 @@ struct sta_info *rtw_get_stainfo(struct
 u32 rtw_init_bcmc_stainfo(struct rtw_adapter *padapter)
 {
 	struct sta_info		*psta;
-	u32 res = _SUCCESS;
+	u32 res = 1;
 	unsigned char bcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 
 	struct	sta_priv *pstapriv = &padapter->stapriv;
@@ -531,7 +531,7 @@ u32 rtw_init_bcmc_stainfo(struct rtw_ada
 	psta = rtw_alloc_stainfo(pstapriv, bcast_addr);
 
 	if (psta == NULL) {
-		res = _FAIL;
+		res = 0;
 		RT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_err_,
 			 ("rtw_alloc_stainfo fail"));
 		goto exit;
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -332,7 +332,7 @@ void Switch_DM_Func(struct rtw_adapter *
 
 static void Set_NETYPE1_MSR(struct rtw_adapter *padapter, u8 type)
 {
-	rtw_hal_set_hwreg(padapter, HW_VAR_MEDIA_STATUS1, (u8 *)(&type));
+	rtw_hal_set_hwreg(padapter, HW_VAR_MEDIA_STATUS_SUCCESS, (u8 *)(&type));
 }
 
 static void Set_NETYPE0_MSR(struct rtw_adapter *padapter, u8 type)
@@ -506,7 +506,7 @@ int is_client_associated_to_ap(struct rt
 	struct mlme_ext_info	*pmlmeinfo;
 
 	if (!padapter)
-		return _FAIL;
+		return 0;
 
 	pmlmeext = &padapter->mlmeextpriv;
 	pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -514,7 +514,7 @@ int is_client_associated_to_ap(struct rt
 	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE))
 		return true;
 	else
-		return _FAIL;
+		return 0;
 }
 
 int is_client_associated_to_ibss(struct rtw_adapter *padapter)
@@ -525,7 +525,7 @@ int is_client_associated_to_ibss(struct
 	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))
 		return true;
 	else
-		return _FAIL;
+		return 0;
 }
 
 int is_IBSS_empty(struct rtw_adapter *padapter)
@@ -536,7 +536,7 @@ int is_IBSS_empty(struct rtw_adapter *pa
 
 	for (i = IBSS_START_MAC_ID; i < NUM_STA; i++) {
 		if (pmlmeinfo->FW_sta_info[i].status == 1)
-			return _FAIL;
+			return 0;
 	}
 	return true;
 }
@@ -668,7 +668,7 @@ int WMM_param_handler(struct rtw_adapter
 
 	if (pmlmepriv->qospriv.qos_option == 0) {
 		pmlmeinfo->WMM_enable = 0;
-		return _FAIL;
+		return 0;
 	}
 
 	pmlmeinfo->WMM_enable = 1;
@@ -1159,17 +1159,17 @@ int support_short_GI(struct rtw_adapter
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	if (!(pmlmeinfo->HT_enable))
-		return _FAIL;
+		return 0;
 
 	if ((pmlmeinfo->assoc_AP_vendor == ralinkAP))
-		return _FAIL;
+		return 0;
 
 	bit_offset = (pmlmeext->cur_bwmode & HT_CHANNEL_WIDTH_40) ? 6 : 5;
 
 	if (le16_to_cpu(pHT_caps->u.HT_cap_element.HT_caps_info) & (0x1 << bit_offset))
-		return _SUCCESS;
+		return 1;
 	else
-		return _FAIL;
+		return 0;
 }
 
 unsigned char get_highest_rate_idx(u32 mask)
@@ -1458,7 +1458,7 @@ int update_sta_support_rate(struct rtw_a
 
 	pIE = (struct ndis_802_11_variable_ies *)rtw_get_ie(pvar_ie, _SUPPORTEDRATES_IE_, &ie_len, var_ie_len);
 	if (pIE == NULL)
-		return _FAIL;
+		return 0;
 
 	memcpy(pmlmeinfo->FW_sta_info[cam_idx].SupportedRates, pIE->data, ie_len);
 	supportRateNum = ie_len;
@@ -1467,7 +1467,7 @@ int update_sta_support_rate(struct rtw_a
 	if (pIE)
 		memcpy((pmlmeinfo->FW_sta_info[cam_idx].SupportedRates + supportRateNum), pIE->data, ie_len);
 
-	return _SUCCESS;
+	return 1;
 }
 
 void process_addba_req(struct rtw_adapter *padapter, u8 *paddba_req, u8 *addr)
@@ -1518,7 +1518,7 @@ static struct rtw_adapter *pbuddy_padapt
 
 int rtw_handle_dualmac(struct rtw_adapter *adapter, bool init)
 {
-	int status = _SUCCESS;
+	int status = 1;
 	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
 
 	if (init) {
@@ -1531,7 +1531,7 @@ int rtw_handle_dualmac(struct rtw_adapte
 		/* For SMSP on 92DU-VC, driver do not probe another Interface. */
 		if ((dvobj->DualMacMode != true) && (dvobj->InterfaceNumber != 0)) {
 			DBG_8192D("%s(): Do not init another USB Interface because SMSP\n", __func__);
-			status = _FAIL;
+			status = 0;
 			goto exit;
 		}
 #ifdef CONFIG_DUALMAC_CONCURRENT
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -61,7 +61,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv
 	int i;
 	struct xmit_buf *pxmitbuf;
 	struct xmit_frame *pxframe;
-	int	res = _SUCCESS;
+	int	res = 1;
 
 	/*  We don't need to memset padapter->XXX to zero, because adapter is allocated by vzalloc(). */
 	/* memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv)); */
@@ -95,7 +95,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv
 	if (pxmitpriv->pallocated_frame_buf  == NULL) {
 		pxmitpriv->pxmit_frame_buf = NULL;
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_frame fail!\n"));
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	pxmitpriv->pxmit_frame_buf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_frame_buf), 4);
@@ -130,7 +130,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv
 
 	if (pxmitpriv->pallocated_xmitbuf  == NULL) {
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_buf fail!\n"));
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -146,7 +146,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv
 		pxmitbuf->ext_tag = false;
 
 		res = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ));
-		if (res == _FAIL)
+		if (res == 0)
 			goto exit;
 
 		pxmitbuf->flags = XMIT_VO_QUEUE;
@@ -164,7 +164,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv
 
 	if (pxmitpriv->pallocated_xmit_extbuf  == NULL) {
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_extbuf fail!\n"));
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -180,7 +180,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv
 		pxmitbuf->ext_tag = true;
 
 		res = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ);
-		if (res == _FAIL)
+		if (res == 0)
 			goto exit;
 
 		list_add_tail(&pxmitbuf->list, &(pxmitpriv->free_xmit_extbuf_queue.queue));
@@ -415,7 +415,7 @@ static s32 update_attrib(struct rtw_adap
 	struct security_priv	*psecuritypriv = &padapter->securitypriv;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
-	int res = _SUCCESS;
+	int res = 1;
 
 	_rtw_open_pktfile(pkt, &pktfile);
 	_rtw_pktfile_read(&pktfile, (u8 *)&etherhdr, ETH_HLEN);
@@ -477,10 +477,10 @@ static s32 update_attrib(struct rtw_adap
 		if (psta == NULL) { /*  if we cannot get psta => drrp the pkt */
 			RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,
 				 ("\nupdate_attrib => get sta_info fail, ra:%pM\n", pattrib->ra));
-			res = _FAIL;
+			res = 0;
 			goto exit;
 		} else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) && (!(psta->state & _FW_LINKED))) {
-			res = _FAIL;
+			res = 0;
 			goto exit;
 		}
 	}
@@ -492,7 +492,7 @@ static s32 update_attrib(struct rtw_adap
 		/*  if we cannot get psta => drop the pkt */
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,
 			 ("\nupdate_attrib => get sta_info fail, ra:%pM\n", pattrib->ra));
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -525,7 +525,7 @@ static s32 update_attrib(struct rtw_adap
 			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
 				 ("\npsta->ieee8021x_blocked == true,  pattrib->ether_type(%.4x) != 0x888e\n",
 				 pattrib->ether_type));
-			res = _FAIL;
+			res = 0;
 			goto exit;
 		}
 	} else {
@@ -558,11 +558,11 @@ static s32 update_attrib(struct rtw_adap
 		pattrib->iv_len = 8;
 		pattrib->icv_len = 4;
 
-		if (padapter->securitypriv.busetkipkey == _FAIL) {
+		if (padapter->securitypriv.busetkipkey == 0) {
 			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
-				 ("\npadapter->securitypriv.busetkipkey(%d) == _FAIL drop packet\n",
+				 ("\npadapter->securitypriv.busetkipkey(%d) == 0 drop packet\n",
 				 padapter->securitypriv.busetkipkey));
-			res = _FAIL;
+			res = 0;
 			goto exit;
 		}
 		break;
@@ -636,7 +636,7 @@ static s32 xmitframe_addmic(struct rtw_a
 
 			if (bmcst) {
 				if (!memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16)) {
-					return _FAIL;
+					return 0;
 				}
 				/* start to calculate the mic code */
 				rtw_secmicsetkey(&micdata, psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey);
@@ -644,7 +644,7 @@ static s32 xmitframe_addmic(struct rtw_a
 				if (!memcmp(&stainfo->dot11tkiptxmickey.skey[0], null_key, 16)) {
 					/* DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey == 0\n"); */
 					/* msleep(10); */
-					return _FAIL;
+					return 0;
 				}
 				/* start to calculate the mic code */
 				rtw_secmicsetkey(&micdata, &stainfo->dot11tkiptxmickey.skey[0]);
@@ -729,7 +729,7 @@ static s32 xmitframe_addmic(struct rtw_a
 		}
 	}
 
-	return _SUCCESS;
+	return 1;
 }
 
 static s32 xmitframe_swencrypt(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
@@ -757,7 +757,7 @@ static s32 xmitframe_swencrypt(struct rt
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_, ("### xmitframe_hwencrypt\n"));
 	}
 
-	return _SUCCESS;
+	return 1;
 }
 
 s32 rtw_make_wlanhdr (struct rtw_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib)
@@ -767,7 +767,7 @@ s32 rtw_make_wlanhdr (struct rtw_adapter
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
 	u8 qos_option = false;
-	int res = _SUCCESS;
+	int res = 1;
 	u16 *fctrl = &pwlanhdr->frame_control;
 	struct sta_info *psta;
 	int bmcst = IS_MCAST(pattrib->ra);
@@ -815,7 +815,7 @@ s32 rtw_make_wlanhdr (struct rtw_adapter
 				qos_option = true;
 		} else {
 			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("fw_state:%x is not allowed to xmit frame\n", get_fwstate(pmlmepriv)));
-			res = _FAIL;
+			res = 0;
 			goto exit;
 		}
 
@@ -970,7 +970,7 @@ s32 rtw_xmitframe_coalesce(struct rtw_ad
 	u8 *pbuf_start;
 
 	s32 bmcst = IS_MCAST(pattrib->ra);
-	s32 res = _SUCCESS;
+	s32 res = 1;
 
 	if (pattrib->psta)
 		psta = pattrib->psta;
@@ -978,18 +978,18 @@ s32 rtw_xmitframe_coalesce(struct rtw_ad
 		psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
 
 	if (psta == NULL)
-		return _FAIL;
+		return 0;
 
 	if (pxmitframe->buf_addr == NULL)
-		return _FAIL;
+		return 0;
 
 	pbuf_start = pxmitframe->buf_addr;
 
 	mem_start = pbuf_start + TXDESC_SIZE + (pxmitframe->pkt_offset * PACKET_OFFSET_SZ);
 
-	if (rtw_make_wlanhdr(padapter, mem_start, pattrib) == _FAIL) {
+	if (rtw_make_wlanhdr(padapter, mem_start, pattrib) == 0) {
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("rtw_xmitframe_coalesce: rtw_make_wlanhdr fail; drop pkt\n"));
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -1089,9 +1089,9 @@ s32 rtw_xmitframe_coalesce(struct rtw_ad
 		memcpy(mem_start, pbuf_start + TXDESC_OFFSET, pattrib->hdrlen);
 	}
 
-	if (xmitframe_addmic(padapter, pxmitframe) == _FAIL) {
-		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic(padapter, pxmitframe) == _FAIL\n"));
-		res = _FAIL;
+	if (xmitframe_addmic(padapter, pxmitframe) == 0) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic(padapter, pxmitframe) == 0\n"));
+		res = 0;
 		goto exit;
 	}
 
@@ -1233,7 +1233,7 @@ s32 rtw_free_xmitbuf_ext(struct xmit_pri
 	struct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;
 
 	if (pxmitbuf == NULL)
-		return _FAIL;
+		return 0;
 
 	spin_lock_irqsave(&pfree_queue->lock, flags);
 
@@ -1244,7 +1244,7 @@ s32 rtw_free_xmitbuf_ext(struct xmit_pri
 
 	spin_unlock_irqrestore(&pfree_queue->lock, flags);
 
-	return _SUCCESS;
+	return 1;
 }
 
 struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv)
@@ -1291,7 +1291,7 @@ s32 rtw_free_xmitbuf(struct xmit_priv *p
 	struct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
 
 	if (pxmitbuf == NULL)
-		return _FAIL;
+		return 0;
 
 	if (pxmitbuf->sctx) {
 		DBG_8192D("%s pxmitbuf->sctx is not NULL\n", __func__);
@@ -1311,7 +1311,7 @@ s32 rtw_free_xmitbuf(struct xmit_priv *p
 		spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, flags);
 	}
 
-	return _SUCCESS;
+	return 1;
 }
 
 /*
@@ -1411,7 +1411,7 @@ s32 rtw_free_xmitframe(struct xmit_priv
 
 exit:
 
-	return _SUCCESS;
+	return 1;
 }
 
 void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, struct __queue *pframequeue)
@@ -1435,13 +1435,13 @@ void rtw_free_xmitframe_queue(struct xmi
 
 s32 rtw_xmitframe_enqueue(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
 {
-	if (rtw_xmit_classifier(padapter, pxmitframe) == _FAIL) {
+	if (rtw_xmit_classifier(padapter, pxmitframe) == 0) {
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
 			 ("rtw_xmitframe_enqueue: drop xmit pkt for classifier fail\n"));
-		return _FAIL;
+		return 0;
 	}
 
-	return _SUCCESS;
+	return 1;
 }
 
 static struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv,
@@ -1584,7 +1584,7 @@ s32 rtw_xmit_classifier(struct rtw_adapt
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	struct sta_priv	*pstapriv = &padapter->stapriv;
 	struct hw_xmit	*phwxmits =  padapter->xmitpriv.hwxmits;
-	int res = _SUCCESS;
+	int res = 1;
 
 	if (pattrib->psta)
 		psta = pattrib->psta;
@@ -1592,7 +1592,7 @@ s32 rtw_xmit_classifier(struct rtw_adapt
 		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
 
 	if (psta == NULL) {
-		res = _FAIL;
+		res = 0;
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("rtw_xmit_classifier: psta == NULL\n"));
 		goto exit;
 	}
@@ -1679,7 +1679,7 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 	}
 
 	res = update_attrib(padapter, *ppkt, &pxmitframe->attrib);
-	if (res == _FAIL) {
+	if (res == 0) {
 		RT_TRACE(_module_xmit_osdep_c_, _drv_err_,
 			 ("rtw_xmit: update attrib fail\n"));
 		rtw_free_xmitframe(pxmitpriv, pxmitframe);
@@ -2057,7 +2057,7 @@ void rtw_sctx_init(struct submit_ctx *sc
 
 int rtw_sctx_wait(struct submit_ctx *sctx)
 {
-	int ret = _FAIL;
+	int ret = 0;
 	unsigned long expire;
 	int status = 0;
 
@@ -2071,7 +2071,7 @@ int rtw_sctx_wait(struct submit_ctx *sct
 	}
 
 	if (status == RTW_SCTX_DONE_SUCCESS)
-		ret = _SUCCESS;
+		ret = 1;
 	return ret;
 }
 
@@ -2112,11 +2112,11 @@ void rtw_sctx_done(struct submit_ctx **s
  *
  * Init ack_tx_ops and then do c2h_evt_hdl() and polling ack_tx_ops repeatedly
  * till tx report or timeout
- * Returns: _SUCCESS if TX report ok, _FAIL for others
+ * Returns: 1 if TX report ok, 0 for others
  */
 static int rtw_ack_tx_polling(struct xmit_priv *pxmitpriv, u32 timeout_ms)
 {
-	int ret = _FAIL;
+	int ret = 0;
 	struct submit_ctx *pack_tx_ops = &pxmitpriv->ack_tx_ops;
 	struct rtw_adapter *adapter = container_of(pxmitpriv, struct rtw_adapter, xmitpriv);
 
@@ -2146,7 +2146,7 @@ static int rtw_ack_tx_polling(struct xmi
 	}
 
 	if (pack_tx_ops->status == RTW_SCTX_DONE_SUCCESS)
-		ret = _SUCCESS;
+		ret = 1;
 
 	return ret;
 }
--- a/drivers/staging/rtl8192du/hal/hal_com.c
+++ b/drivers/staging/rtl8192du/hal/hal_com.c
@@ -298,7 +298,7 @@ void c2h_evt_clear(struct rtw_adapter *a
 
 s32 c2h_evt_read(struct rtw_adapter *adapter, u8 *buf)
 {
-	s32 ret = _FAIL;
+	s32 ret = 0;
 	struct c2h_evt_hdr *c2h_evt;
 	int i;
 	u8 trigger;
@@ -331,7 +331,7 @@ s32 c2h_evt_read(struct rtw_adapter *ada
 	RT_PRINT_DATA(_module_hal_init_c_, _drv_info_,
 		      "c2h_evt_read(): Command Content:\n",
 		      c2h_evt->payload, c2h_evt->plen);
-	ret = _SUCCESS;
+	ret = 1;
 clear_evt:
 	/*
 	* Clear event to notify FW we have read the command.
--- a/drivers/staging/rtl8192du/hal/hal_intf.c
+++ b/drivers/staging/rtl8192du/hal/hal_intf.c
@@ -77,7 +77,7 @@ void rtw_hal_sw_led_deinit(struct rtw_ad
 
 uint	 rtw_hal_init(struct rtw_adapter *padapter)
 {
-	uint	status = _SUCCESS;
+	uint	status = 1;
 
 	if (padapter->hw_init_completed == true) {
 		DBG_8192D("rtw_hal_init: hw_init_completed == true\n");
@@ -93,7 +93,7 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 			DBG_8192D("rtw_hal_init: pbuddy_adapter hw_init_completed == true\n");
 		} else {
 			status =	padapter->HalFunc.hal_init(padapter->pbuddy_adapter);
-			if (status == _SUCCESS) {
+			if (status == 1) {
 				padapter->pbuddy_adapter->hw_init_completed = true;
 			} else {
 				padapter->pbuddy_adapter->hw_init_completed = false;
@@ -108,7 +108,7 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 
 	status = padapter->HalFunc.hal_init(padapter);
 
-	if (status == _SUCCESS) {
+	if (status == 1) {
 		padapter->hw_init_completed = true;
 
 		if (padapter->registrypriv.notch_filter == 1)
@@ -127,11 +127,11 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 
 uint rtw_hal_deinit(struct rtw_adapter *padapter)
 {
-	uint	status = _SUCCESS;
+	uint	status = 1;
 
 	status = padapter->HalFunc.hal_deinit(padapter);
 
-	if (status == _SUCCESS)
+	if (status == 1)
 		padapter->hw_init_completed = false;
 	else
 		RT_TRACE(_module_hal_init_c_,_drv_err_,("\n rtw_hal_deinit: hal_init fail\n"));
@@ -155,14 +155,14 @@ u8 rtw_hal_set_def_var(struct rtw_adapte
 {
 	if (padapter->HalFunc.SetHalDefVarHandler)
 		return padapter->HalFunc.SetHalDefVarHandler(padapter,eVariable,pValue);
-	return _FAIL;
+	return 0;
 }
 
 u8 rtw_hal_get_def_var(struct rtw_adapter *padapter, enum HAL_DEF_VARIABLE eVariable, void * pValue)
 {
 	if (padapter->HalFunc.GetHalDefVarHandler)
 		return padapter->HalFunc.GetHalDefVarHandler(padapter,eVariable,pValue);
-	return _FAIL;
+	return 0;
 }
 
 void rtw_hal_enable_interrupt(struct rtw_adapter *padapter)
@@ -182,7 +182,7 @@ void rtw_hal_disable_interrupt(struct rt
 
 u32	rtw_hal_inirp_init(struct rtw_adapter *padapter)
 {
-	u32 rst = _FAIL;
+	u32 rst = 0;
 	if (padapter->HalFunc.inirp_init)
 		rst = padapter->HalFunc.inirp_init(padapter);
 	else
@@ -196,14 +196,14 @@ u32	rtw_hal_inirp_deinit(struct rtw_adap
 	if (padapter->HalFunc.inirp_deinit)
 		return padapter->HalFunc.inirp_deinit(padapter);
 
-	return _FAIL;
+	return 0;
 }
 
 u8 rtw_hal_intf_ps_func(struct rtw_adapter *padapter, enum HAL_INTF_PS_FUNC efunc_id, u8* val)
 {
 	if (padapter->HalFunc.interface_ps_func)
 		return padapter->HalFunc.interface_ps_func(padapter,efunc_id,val);
-	return _FAIL;
+	return 0;
 }
 
 s32 rtw_hal_xmit(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
@@ -216,7 +216,7 @@ s32 rtw_hal_xmit(struct rtw_adapter *pad
 
 s32	rtw_hal_mgnt_xmit(struct rtw_adapter *padapter, struct xmit_frame *pmgntframe)
 {
-	s32 ret = _FAIL;
+	s32 ret = 0;
 	if (padapter->HalFunc.mgnt_xmit)
 		ret = padapter->HalFunc.mgnt_xmit(padapter, pmgntframe);
 	return ret;
@@ -226,7 +226,7 @@ s32 rtw_hal_init_xmit_priv(struct rtw_ad
 {
 	if (padapter->HalFunc.init_xmit_priv != NULL)
 		return padapter->HalFunc.init_xmit_priv(padapter);
-	return _FAIL;
+	return 0;
 }
 
 void rtw_hal_free_xmit_priv(struct rtw_adapter *padapter)
@@ -240,7 +240,7 @@ s32 rtw_hal_init_recv_priv(struct rtw_ad
 	if (padapter->HalFunc.init_recv_priv)
 		return padapter->HalFunc.init_recv_priv(padapter);
 
-	return _FAIL;
+	return 0;
 }
 
 void rtw_hal_free_recv_priv(struct rtw_adapter *padapter)
@@ -293,7 +293,7 @@ s32 rtw_hal_interrupt_handler(struct rtw
 {
 	if (padapter->HalFunc.interrupt_handler)
 		return padapter->HalFunc.interrupt_handler(padapter);
-	return _FAIL;
+	return 0;
 }
 
 void rtw_hal_set_bwmode(struct rtw_adapter *padapter, enum HT_CHANNEL_WIDTH Bandwidth, u8 Offset)
@@ -334,7 +334,7 @@ void rtw_hal_reset_security_engine(struc
 
 s32 rtw_hal_c2h_handler(struct rtw_adapter *adapter, struct c2h_evt_hdr *c2h_evt)
 {
-	s32 ret = _FAIL;
+	s32 ret = 0;
 	if (adapter->HalFunc.c2h_handler)
 		ret = adapter->HalFunc.c2h_handler(adapter, c2h_evt);
 	return ret;
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -285,7 +285,7 @@ static u8 rtl8192d_h2c_msg_hdl(struct rt
 u8 rtl8192d_set_raid_cmd(struct rtw_adapter*padapter, u32 mask, u8 arg)
 {
 	u8	buf[5];
-	u8	res=_SUCCESS;
+	u8	res=1;
 	__le32	le_mask;
 
 	memset(buf, 0, 5);
@@ -824,7 +824,7 @@ void rtl8192d_set_FwJoinBssReport_cmd(st
 static u8 rtl8192d_reset_tsf(struct rtw_adapter *padapter, u8 reset_port)
 {
 	u8	buf[2];
-	u8	res=_SUCCESS;
+	u8	res=1;
 
 	if (IFACE_PORT0==reset_port) {
 		buf[0] = 0x1; buf[1] = 0;
@@ -853,7 +853,7 @@ int reset_tsf(struct rtw_adapter * adapt
 		reset_cnt_after = rtw_read8(adapter, reg_reset_tsf_cnt);
 	}
 
-	return(loop_cnt >= 10) ? _FAIL : true;
+	return(loop_cnt >= 10) ? 0 : true;
 }
 
 #endif	/*  CONFIG_CONCURRENT_MODE */
@@ -862,7 +862,7 @@ int reset_tsf(struct rtw_adapter * adapt
 
 void rtl8192d_set_wowlan_cmd(struct rtw_adapter* padapter)
 {
-	u8	res=_SUCCESS;
+	u8	res=1;
 	u32 test=0;
 	struct recv_priv	*precvpriv = &padapter->recvpriv;
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -64,7 +64,7 @@ static void _FWDownloadEnable(struct rtw
 
 static int _BlockWrite_92d(struct rtw_adapter *adapter, void *buffer, u32 size)
 {
-	int ret = _SUCCESS;
+	int ret = 1;
 	u32			blockSize8 = sizeof(u64);
 	u32			blocksize4 = sizeof(u32);
 	u32			blockSize = 64;
@@ -78,7 +78,7 @@ static int _BlockWrite_92d(struct rtw_ad
 		offset = i * blockSize;
 		ret = rtw_writeN(adapter, (FW_8192D_START_ADDRESS + offset), 64, (bufferPtr + offset));
 
-		if (ret == _FAIL)
+		if (ret == 0)
 			goto exit;
 	}
 
@@ -90,7 +90,7 @@ static int _BlockWrite_92d(struct rtw_ad
 		for (i = 0; i < blockCount8; i++) {
 			ret = rtw_writeN(adapter, (FW_8192D_START_ADDRESS + offset+i*blockSize8), 8, (bufferPtr + offset+i*blockSize8));
 
-			if (ret == _FAIL)
+			if (ret == 0)
 				goto exit;
 		}
 
@@ -102,7 +102,7 @@ static int _BlockWrite_92d(struct rtw_ad
 			for (i = 0; i < blockCount4; i++) {
 				ret = rtw_write32(adapter, (FW_8192D_START_ADDRESS + offset+i*blocksize4), le32_to_cpu(*(__le32 *)(pu4BytePtr+ offset/4+i)));
 
-				if (ret == _FAIL)
+				if (ret == 0)
 					goto exit;
 			}
 
@@ -111,7 +111,7 @@ static int _BlockWrite_92d(struct rtw_ad
 				for (i = 0; i < remainSize; i++) {
 					ret = rtw_write8(adapter, (FW_8192D_START_ADDRESS + offset + i), *(bufferPtr +offset+ i));
 
-					if (ret == _FAIL)
+					if (ret == 0)
 						goto exit;
 				}
 			}
@@ -137,7 +137,7 @@ static int _PageWrite(struct rtw_adapter
 
 static int _WriteFW(struct rtw_adapter *adapter, void *buffer, u32 size)
 {
-	int ret = _SUCCESS;
+	int ret = 1;
 	/*  Since we need to dynamically decide method of download fw,
 	 *  we call this function to get chip version.
 	 *  We can remove _ReadChipVersion from ReadadapterInfo8192C later.
@@ -153,7 +153,7 @@ static int _WriteFW(struct rtw_adapter *
 		offset = page *MAX_PAGE_SIZE;
 		ret = _PageWrite(adapter, page, (bufferPtr+offset), MAX_PAGE_SIZE);
 
-		if (ret == _FAIL)
+		if (ret == 0)
 			goto exit;
 	}
 	if (remainSize) {
@@ -161,7 +161,7 @@ static int _WriteFW(struct rtw_adapter *
 		page = pageNums;
 		ret = _PageWrite(adapter, page, (bufferPtr+offset), remainSize);
 
-		if (ret == _FAIL)
+		if (ret == 0)
 			goto exit;
 	}
 	DBG_8192D("_WriteFW Done- for Normal chip.\n");
@@ -182,14 +182,14 @@ static int _FWFreeToGo_92D(struct rtw_ad
 
 	if (counter >= POLLING_READY_TIMEOUT_COUNT) {
 		DBG_8192D("chksum report faill ! REG_MCUFWDL:0x%08x .\n", value32);
-		return _FAIL;
+		return 0;
 	}
 	DBG_8192D("Checksum report OK ! REG_MCUFWDL:0x%08x .\n", value32);
 
 	value32 = rtw_read32(adapter, REG_MCUFWDL);
 	value32 |= MCUFWDL_RDY;
 	rtw_write32(adapter, REG_MCUFWDL, value32);
-	return _SUCCESS;
+	return 1;
 }
 
 void rtl8192d_FirmwareSelfReset(struct rtw_adapter *adapter)
@@ -241,14 +241,14 @@ static int _FWInit(struct rtw_adapter *a
 			if (rtw_read8(adapter, FW_MAC0_ready) & mac0_ready) {
 				DBG_8192D("Polling FW ready success!! FW_MAC0_ready:0x%x\n",
 					  rtw_read8(adapter, FW_MAC0_ready));
-				return _SUCCESS;
+				return 1;
 			}
 			udelay(5);
 		} else {
 			if (rtw_read8(adapter, FW_MAC1_ready) &mac1_ready) {
 				DBG_8192D("Polling FW ready success!! FW_MAC1_ready:0x%x\n",
 					  rtw_read8(adapter, FW_MAC1_ready));
-				return _SUCCESS;
+				return 1;
 			}
 			udelay(5);
 		}
@@ -265,7 +265,7 @@ static int _FWInit(struct rtw_adapter *a
 
 	DBG_8192D("Polling FW ready fail!! REG_MCUFWDL:0x%x\n",
 		  rtw_read32(adapter, REG_MCUFWDL));
-	return _FAIL;
+	return 0;
 }
 
 static bool get_fw_from_file(struct rtw_adapter *adapter)
@@ -317,7 +317,7 @@ MODULE_FIRMWARE("rtlwifi/rtl8192dufw.bin
 /*	Description: Download 8192D firmware code. */
 int FirmwareDownload92D(struct rtw_adapter *adapter, bool bUsedWoWLANFw)
 {
-	int rtStatus = _SUCCESS;
+	int rtStatus = 1;
 	u8 writeFW_retry = 0;
 	u32 fwdl_start_time;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
@@ -329,7 +329,7 @@ int FirmwareDownload92D(struct rtw_adapt
 	bool bFwDownloaded = false, bFwDownloadInProcess = false;
 
 	if (adapter->bSurpriseRemoved)
-		return _FAIL;
+		return 0;
 
 	/* Single MAC Single PHY units break if external firmware is loaded */
 	if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY)
@@ -337,7 +337,7 @@ int FirmwareDownload92D(struct rtw_adapt
 
 	if (!adapter->firmware || !adapter->firmware->buffer) {
 		if (!get_fw_from_file(adapter)) {
-			rtStatus = _FAIL;
+			rtStatus = 0;
 			adapter->firmware = NULL;
 			goto Exit;
 		}
@@ -425,7 +425,7 @@ int FirmwareDownload92D(struct rtw_adapt
 
 			rtStatus = _WriteFW(adapter, pFirmwareBuf, FirmwareLen);
 
-			if (rtStatus == _SUCCESS ||
+			if (rtStatus == 1 ||
 			    (rtw_systime_to_ms(jiffies - fwdl_start_time) > 500 &&
 			    writeFW_retry++ >= 3))
 				break;
@@ -435,7 +435,7 @@ int FirmwareDownload92D(struct rtw_adapt
 				  rtw_systime_to_ms(jiffies - fwdl_start_time));
 		}
 		_FWDownloadEnable(adapter, false);
-		if (_SUCCESS != rtStatus) {
+		if (1 != rtStatus) {
 			DBG_8192D("DL Firmware failed!\n");
 			goto Exit;
 		}
@@ -448,7 +448,7 @@ int FirmwareDownload92D(struct rtw_adapt
 		rtw_write8(adapter, 0x1f, value);
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 
-		if (_SUCCESS != rtStatus) {
+		if (1 != rtStatus) {
 			DBG_8192D("Firmware is not ready to run!\n");
 			goto Exit;
 		}
@@ -481,14 +481,14 @@ void InitializeFirmwareVars92D(struct rt
  */
 void SetFwRelatedForWoWLAN8192DU(struct rtw_adapter *padapter, u8 bHostIsGoingtoSleep)
 {
-	int	status = _FAIL;
+	int	status = 0;
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
 	u8	 bRecover = false;
 
 	if (bHostIsGoingtoSleep) {
 		/*  1. Before WoWLAN we need to re-download WoWLAN Fw. */
 		status = FirmwareDownload92D(padapter, bHostIsGoingtoSleep);
-		if (status != _SUCCESS) {
+		if (status != 1) {
 			DBG_8192D("ConfigFwRelatedForWoWLAN8192DU(): Re-Download Firmware failed!!\n");
 			return;
 		} else {
@@ -1801,12 +1801,12 @@ static s32 c2h_id_filter_ccx_8192d(u8 id
 
 static s32 c2h_handler_8192d(struct rtw_adapter *padapter, struct c2h_evt_hdr *c2h_evt)
 {
-	s32 ret = _SUCCESS;
+	s32 ret = 1;
 	u8 i = 0;
 
 	if (c2h_evt == NULL) {
 		DBG_8192D("%s c2h_evt is NULL\n", __func__);
-		ret = _FAIL;
+		ret = 0;
 		goto exit;
 	}
 
@@ -1815,7 +1815,7 @@ static s32 c2h_handler_8192d(struct rtw_
 		handle_txrpt_ccx_8192d(padapter, c2h_evt->payload);
 		break;
 	default:
-		ret = _FAIL;
+		ret = 0;
 		break;
 	}
 
--- a/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
@@ -585,7 +585,7 @@ phy_ConfigMACWithHeaderFile(
 		rtw_write8(adapter, ptrArray[i], (u8)ptrArray[i+1]);
 	}
 
-	return _SUCCESS;
+	return 1;
 }
 
 /*-----------------------------------------------------------------------------
@@ -607,10 +607,10 @@ phy_ConfigMACWithHeaderFile(
 int PHY_MACConfig8192D(struct rtw_adapter *adapter)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
-	int		rtStatus = _SUCCESS;
+	int		rtStatus = 1;
 
 	if (adapter->bSurpriseRemoved) {
-		rtStatus = _FAIL;
+		rtStatus = 0;
 		return rtStatus;
 	}
 
@@ -845,7 +845,7 @@ phy_ConfigBBWithHeaderFile(
 		}
 	}
 
-	return _SUCCESS;
+	return 1;
 }
 
 static void storePwrIndexDiffRateOffset(struct rtw_adapter *adapter,
@@ -926,19 +926,19 @@ phy_ConfigBBWithPgHeaderFile(
 		}
 	}
 
-	return _SUCCESS;
+	return 1;
 }	/* phy_ConfigBBWithPgHeaderFile */
 
 static	int phy_BB8192D_Config_ParaFile(struct rtw_adapter *adapter)
 {
 	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
-	int		rtStatus = _SUCCESS;
+	int		rtStatus = 1;
 
 	/*  1. Read PHY_REG.TXT BB INIT!! */
 	/*  We will seperate as 88C / 92C according to chip version */
 	rtStatus = phy_ConfigBBWithHeaderFile(adapter, BaseBand_Config_PHY_REG);
-	if (rtStatus != _SUCCESS)
+	if (rtStatus != 1)
 		goto phy_BB8190_Config_ParaFile_Fail;
 
 	/*  2. If EEPROM or EFUSE autoload OK, We must config by PHY_REG_PG.txt */
@@ -948,7 +948,7 @@ static	int phy_BB8192D_Config_ParaFile(s
 		rtStatus = phy_ConfigBBWithPgHeaderFile(adapter, BaseBand_Config_PHY_REG);
 	}
 
-	if (rtStatus != _SUCCESS)
+	if (rtStatus != 1)
 		goto phy_BB8190_Config_ParaFile_Fail;
 
 	/*  3. BB AGC table Initialization */
@@ -963,7 +963,7 @@ static	int phy_BB8192D_Config_ParaFile(s
 		rtStatus = phy_ConfigBBWithHeaderFile(adapter, BaseBand_Config_AGC_TAB);
 	}
 
-	if (rtStatus != _SUCCESS)
+	if (rtStatus != 1)
 		goto phy_BB8190_Config_ParaFile_Fail;
 
 	/*  Check if the CCK HighPower is turned ON. */
@@ -980,7 +980,7 @@ PHY_BBConfig8192D(
 	struct rtw_adapter *	adapter
 	)
 {
-	int	rtStatus = _SUCCESS;
+	int	rtStatus = 1;
 	/* u8		PathMap = 0, index = 0, rf_num = 0; */
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
 	u32	RegVal;
@@ -988,7 +988,7 @@ PHY_BBConfig8192D(
 	struct registry_priv *pregistrypriv = &adapter->registrypriv;
 
 	if (adapter->bSurpriseRemoved) {
-		rtStatus = _FAIL;
+		rtStatus = 0;
 		return rtStatus;
 	}
 
@@ -1070,10 +1070,10 @@ PHY_RFConfig8192D(
 	struct rtw_adapter *	adapter
 	)
 {
-	int		rtStatus = _SUCCESS;
+	int		rtStatus = 1;
 
 	if (adapter->bSurpriseRemoved) {
-		rtStatus = _FAIL;
+		rtStatus = 0;
 		return rtStatus;
 	}
 
@@ -1108,7 +1108,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 )
 {
 	int	i, j;
-	int	rtStatus = _SUCCESS;
+	int	rtStatus = 1;
 	u32*	Rtl819XRadioA_Array_Table;
 	u32*	Rtl819XRadioB_Array_Table;
 	u16		RadioA_ArrayLen, RadioB_ArrayLen;
@@ -1136,7 +1136,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 		Rtl819XRadioB_Array_Table = (u32 *)Rtl8192D_RadioB_2T_intPAArray;
 	}
 
-	rtStatus = _SUCCESS;
+	rtStatus = 1;
 
 	/* vivi added this for read parameter from header, 20100908 */
 	/* 1this only happens when DMDP, mac0 start on 2.4G, mac1 start on 5G, */
@@ -1230,7 +1230,7 @@ rtl8192d_PHY_CheckBBAndRFOK(
 	enum RF_RADIO_PATH_E	eRFPath
 	)
 {
-	int			rtStatus = _SUCCESS;
+	int			rtStatus = 1;
 
 	u32				i, CheckTimes = 4, ulRegRead = 0;
 
@@ -1276,7 +1276,7 @@ rtl8192d_PHY_CheckBBAndRFOK(
 			break;
 
 		default:
-			rtStatus = _FAIL;
+			rtStatus = 0;
 			break;
 		}
 
@@ -1285,7 +1285,7 @@ rtl8192d_PHY_CheckBBAndRFOK(
 		/*  */
 		if (ulRegRead != WriteData[i])
 		{
-			rtStatus = _FAIL;
+			rtStatus = 0;
 			break;
 		}
 	}
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
@@ -548,7 +548,7 @@ phy_RF6052_Config_ParaFile(
 	u32	u4RegValue=0;
 	u8	eRFPath;
 	struct bb_register_def *pPhyReg;
-	int	rtStatus = _SUCCESS;
+	int	rtStatus = 1;
 	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	bool		bMac1NeedInitRadioAFirst = false,bMac0NeedInitRadioBFirst = false;
@@ -671,7 +671,7 @@ phy_RF6052_Config_ParaFile(
 				break;
 		}
 
-		if (rtStatus != _SUCCESS) {
+		if (rtStatus != 1) {
 			goto phy_RF6052_Config_ParaFile_Fail;
 		}
 
@@ -702,7 +702,7 @@ PHY_RF6052_Config8192D(
 	struct rtw_adapter *		adapter)
 {
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
-	int rtStatus = _SUCCESS;
+	int rtStatus = 1;
 
 	/*  */
 	/*  Initialize general global value */
--- a/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
@@ -45,7 +45,7 @@ int	rtl8192du_init_recv_priv(struct rtw_
 {
 	struct recv_priv	*precvpriv = &padapter->recvpriv;
 	struct sk_buff *pskb=NULL;
-	int	i, res = _SUCCESS;
+	int	i, res = 1;
 	struct recv_buf *precvbuf;
 	SIZE_PTR tmpaddr=0;
 	SIZE_PTR alignment=0;
@@ -59,7 +59,7 @@ int	rtl8192du_init_recv_priv(struct rtw_
 
 	precvpriv->pallocated_recv_buf = kzalloc(NR_RECVBUFF *sizeof(struct recv_buf) + 4, GFP_KERNEL);
 	if (precvpriv->pallocated_recv_buf==NULL) {
-		res= _FAIL;
+		res= 0;
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("alloc recv_buf fail!\n"));
 		goto exit;
 	}
@@ -76,7 +76,7 @@ int	rtl8192du_init_recv_priv(struct rtw_
 		precvbuf->alloc_sz = MAX_RECVBUF_SZ;
 
 		res = rtw_os_recvbuf_resource_alloc(padapter, precvbuf);
-		if (res==_FAIL)
+		if (res==0)
 			break;
 
 		precvbuf->ref_cnt = 0;
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -29,7 +29,7 @@ s32	rtl8192du_init_xmit_priv(struct rtw_
 	tasklet_init(&pxmitpriv->xmit_tasklet,
 	     (void(*)(unsigned long))rtl8192du_xmit_tasklet,
 	     (unsigned long)padapter);
-	return _SUCCESS;
+	return 1;
 }
 
 void	rtl8192du_free_xmit_priv(struct rtw_adapter *padapter)
@@ -425,8 +425,8 @@ static s32 update_txdesc(struct xmit_fra
 
 static s32 rtw_dump_xframe(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
 {
-	s32 ret = _SUCCESS;
-	s32 inner_ret = _SUCCESS;
+	s32 ret = 1;
+	s32 inner_ret = 1;
 	int t, sz, w_sz, pull=0;
 	u8 *mem_addr;
 	u32 ff_hwaddr;
@@ -446,8 +446,8 @@ static s32 rtw_dump_xframe(struct rtw_ad
 	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_dump_xframe()\n"));
 
 	for (t = 0; t < pattrib->nr_frags; t++) {
-		if (inner_ret != _SUCCESS && ret == _SUCCESS)
-			ret = _FAIL;
+		if (inner_ret != 1 && ret == 1)
+			ret = 0;
 
 		if (t != (pattrib->nr_frags - 1)) {
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("pattrib->nr_frags=%d\n", pattrib->nr_frags));
@@ -486,7 +486,7 @@ static s32 rtw_dump_xframe(struct rtw_ad
 
 	rtw_free_xmitframe(pxmitpriv, pxmitframe);
 
-	if  (ret != _SUCCESS)
+	if  (ret != 1)
 		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_UNKNOWN);
 
 	return ret;
@@ -731,10 +731,10 @@ s32 rtl8192du_xmitframe_complete(struct
 
 static s32 xmitframe_direct(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
 {
-	s32 res = _SUCCESS;
+	s32 res = 1;
 
 	res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
-	if (res == _SUCCESS) {
+	if (res == 1) {
 		rtw_dump_xframe(padapter, pxmitframe);
 	}
 
@@ -780,7 +780,7 @@ static s32 pre_xmitframe(struct rtw_adap
 	pxmitframe->buf_addr = pxmitbuf->pbuf;
 	pxmitbuf->priv_data = pxmitframe;
 
-	if (xmitframe_direct(padapter, pxmitframe) != _SUCCESS) {
+	if (xmitframe_direct(padapter, pxmitframe) != 1) {
 		rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pxmitframe);
 	}
@@ -791,7 +791,7 @@ enqueue:
 	res = rtw_xmitframe_enqueue(padapter, pxmitframe);
 	spin_unlock_bh(&pxmitpriv->lock);
 
-	if (res != _SUCCESS) {
+	if (res != 1) {
 		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("pre_xmitframe: enqueue xmitframe fail\n"));
 		rtw_free_xmitframe(pxmitpriv, pxmitframe);
 
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -250,7 +250,7 @@ static void rtl8192du_interface_configur
 
 static u8 _InitPowerOn(struct rtw_adapter *padapter)
 {
-	u8	ret = _SUCCESS;
+	u8	ret = 1;
 	u16	value16 = 0;
 	u8	value8 = 0;
 
@@ -258,7 +258,7 @@ static u8 _InitPowerOn(struct rtw_adapte
 	u32	pollingCount = 0;
 
 	if (padapter->bSurpriseRemoved) {
-		return _FAIL;
+		return 0;
 	}
 
 	pollingCount = 0;
@@ -271,7 +271,7 @@ static u8 _InitPowerOn(struct rtw_adapte
 
 		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT) {
 			/* RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling REG_APS_FSMCO[PFM_ALDN] done!\n")); */
-			return _FAIL;
+			return 0;
 		}
 
 	}while (true);
@@ -309,7 +309,7 @@ static u8 _InitPowerOn(struct rtw_adapte
 
 		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT) {
 			/* RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling REG_APS_FSMCO[APFM_ONMAC] done!\n")); */
-			return _FAIL;
+			return 0;
 		}
 
 	}while (true);
@@ -578,7 +578,7 @@ static u8 _LLTWrite(
 	u32		data
 	)
 {
-	u8	status = _SUCCESS;
+	u8	status = 1;
 	int	count = 0;
 	u32	value = _LLT_INIT_ADDR(address) | _LLT_INIT_DATA(data) | _LLT_OP(_LLT_WRITE_ACCESS);
 
@@ -594,7 +594,7 @@ static u8 _LLTWrite(
 
 		if (count > POLLING_LLT_THRESHOLD) {
 			/* RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling write LLT done at address %d!\n", address)); */
-			status = _FAIL;
+			status = 0;
 			break;
 		}
 	}while (count++);
@@ -634,7 +634,7 @@ static u8 InitLLTTable(
 	u32		boundary
 	)
 {
-	u8		status = _SUCCESS;
+	u8		status = 1;
 	u32		i;
 	u32		txpktbuf_bndy = boundary;
 	u32		Last_Entry_Of_TxPktBuf = LAST_ENTRY_OF_TX_PKT_BUFFER;
@@ -654,14 +654,14 @@ static u8 InitLLTTable(
 
 	for (i = 0 ; i < (txpktbuf_bndy - 1) ; i++) {
 		status = _LLTWrite(adapter, i , i + 1);
-		if (_SUCCESS != status) {
+		if (1 != status) {
 			return status;
 		}
 	}
 
 	/*  end of list */
 	status = _LLTWrite(adapter, (txpktbuf_bndy - 1), 0xFF);
-	if (_SUCCESS != status) {
+	if (1 != status) {
 		return status;
 	}
 
@@ -670,14 +670,14 @@ static u8 InitLLTTable(
 	/*  Otherwise used as local loopback buffer. */
 	for (i = txpktbuf_bndy ; i < Last_Entry_Of_TxPktBuf ; i++) {
 		status = _LLTWrite(adapter, i, (i + 1));
-		if (_SUCCESS != status) {
+		if (1 != status) {
 			return status;
 		}
 	}
 
 	/*  Let last entry point to the start entry of ring buffer */
 	status = _LLTWrite(adapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);
-	if (_SUCCESS != status) {
+	if (1 != status) {
 		return status;
 	}
 
@@ -1439,7 +1439,7 @@ static u32 rtl8192du_hal_init(struct rtw
 #endif
 	u8	val8 = 0, tmpU1b;
 	u16	val16;
-	u32	boundary, i = 0,  status = _SUCCESS;
+	u32	boundary, i = 0,  status = 1;
 	u32 init_start_time = jiffies;
 
 	padapter->init_adpt_in_progress = true;
@@ -1459,7 +1459,7 @@ static u32 rtl8192du_hal_init(struct rtw
 			if (i == 100)
 			{
 				DBG_8192D("fail to initialization due to another adapter is in halt\n");
-				return _FAIL;
+				return 0;
 			}
 		}
 	}
@@ -1467,7 +1467,7 @@ static u32 rtl8192du_hal_init(struct rtw
 	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("--->Initializeadapter8192CUsb()\n")); */
 
 	if (padapter->bSurpriseRemoved)
-		return _FAIL;
+		return 0;
 
 	/* Let the first starting mac load RF parameters and do LCK in this case, by wl */
 	if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
@@ -1517,7 +1517,7 @@ static u32 rtl8192du_hal_init(struct rtw
 	PHY_SetPowerOnFor8192D(padapter);
 
 	status = _InitPowerOn(padapter);
-	if (status == _FAIL) {
+	if (status == 0) {
 		RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init power on!\n"));
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
@@ -1537,7 +1537,7 @@ static u32 rtl8192du_hal_init(struct rtw
 	PHY_ConfigMacCoexist_RFPage92D(padapter);
 
 	status =  InitLLTTable(padapter, boundary);
-	if (status == _FAIL) {
+	if (status == 0) {
 		RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init power on!\n"));
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
@@ -1549,7 +1549,7 @@ static u32 rtl8192du_hal_init(struct rtw
 
 	status = FirmwareDownload92D(padapter, false);
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
-	if (status == _FAIL) {
+	if (status == 0) {
 		padapter->bFWReady = false;
 		pHalData->fw_ractrl = false;
 		DBG_8192D("fw download fail!\n");
@@ -1581,7 +1581,7 @@ static u32 rtl8192du_hal_init(struct rtw
 	/*  <Roger_Notes> Current Channel will be updated again later. */
 
 	status = PHY_MACConfig8192D(padapter);
-	if (status == _FAIL) {
+	if (status == 0) {
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
 		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
@@ -1683,7 +1683,7 @@ static u32 rtl8192du_hal_init(struct rtw
 	/* d. Initialize BB related configurations. */
 	/*  */
 	status = PHY_BBConfig8192D(padapter);
-	if (status == _FAIL) {
+	if (status == 0) {
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
 		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
 			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
@@ -1719,7 +1719,7 @@ static u32 rtl8192du_hal_init(struct rtw
 	PHY_SetBBReg(padapter, rFPGA0_AnalogParameter4, 0x00f00000,  0xf);
 
 	status = PHY_RFConfig8192D(padapter);
-	if (status == _FAIL)
+	if (status == 0)
 	{
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
 		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
@@ -1908,7 +1908,7 @@ _DisableRF_AFE(
 	struct rtw_adapter *			adapter
 	)
 {
-	int		rtStatus = _SUCCESS;
+	int		rtStatus = 1;
 	u32			pollingCount = 0;
 	u8			value8;
 
@@ -2240,7 +2240,7 @@ CardDisableHWSM(/*  HW Auto state machin
 	)
 {
 	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
-	int		rtStatus = _SUCCESS;
+	int		rtStatus = 1;
 	u8		value;
 
 	if (adapter->bSurpriseRemoved) {
@@ -2291,7 +2291,7 @@ CardDisableWithoutHWSM(/*  without HW Au
 	)
 {
 	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
-	int		rtStatus = _SUCCESS;
+	int		rtStatus = 1;
 	u8		value;
 
 	if (adapter->bSurpriseRemoved) {
@@ -2363,7 +2363,7 @@ static u32 rtl8192du_hal_deinit(struct r
 	if (RT_IN_PS_LEVEL(pwrpriv, RT_RF_OFF_LEVL_HALT_NIC))
 	{
 		DBG_8192D("Haltadapter8192DUsb(): Not to haltadapter if HW already halt\n");
-		return _FAIL;
+		return 0;
 	}
 
 	padapter->bHaltInProgress = true;
@@ -2397,7 +2397,7 @@ static u32 rtl8192du_hal_deinit(struct r
 
 	padapter->bHaltInProgress = false;
 
-	return _SUCCESS;
+	return 1;
  }
 
 static unsigned int rtl8192du_inirp_init(struct rtw_adapter *padapter)
@@ -2411,7 +2411,7 @@ static unsigned int rtl8192du_inirp_init
 
 	_read_port = pintfhdl->io_ops._read_port;
 
-	status = _SUCCESS;
+	status = 1;
 
 	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("===> usb_inirp_init\n"));
 
@@ -2424,7 +2424,7 @@ static unsigned int rtl8192du_inirp_init
 		if (_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == false)
 		{
 			RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("usb_rx_init: usb_read_port error\n"));
-			status = _FAIL;
+			status = 0;
 			goto exit;
 		}
 
@@ -2446,7 +2446,7 @@ static unsigned int rtl8192du_inirp_dein
 
 	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("\n <=== usb_rx_deinit\n"));
 
-	return _SUCCESS;
+	return 1;
 }
 
 /*  */
@@ -2832,7 +2832,7 @@ static int _ReadadapterInfo8192DU(struct
 	/* For 92DU Phy and Mac mode set , will initialize by EFUSE/EPPROM     zhiyuan 2010/03/25 */
 	DBG_8192D("<==== %s in %d ms\n", __func__, rtw_systime_to_ms(jiffies - start));
 
-	return _SUCCESS;
+	return 1;
 }
 
 static void ReadadapterInfo8192DU(struct rtw_adapter *adapter)
@@ -3611,7 +3611,7 @@ static void SetHwReg8192DU(struct rtw_ad
 				rtw_write8(adapter, MSR, val8);
 			}
 			break;
-		case HW_VAR_MEDIA_STATUS1:
+		case HW_VAR_MEDIA_STATUS_SUCCESS:
 			{
 				u8 val8;
 
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -321,7 +321,7 @@ static int usb_writeN(struct intf_hdl *p
 
 static s32 pre_recv_entry(struct recv_frame_hdr *precvframe, struct recv_stat *prxstat, struct phy_stat *pphy_info)
 {
-	s32 ret=_SUCCESS;
+	s32 ret=1;
 #ifdef CONFIG_CONCURRENT_MODE
 	u8 *primary_myid, *secondary_myid, *paddr1;
 	struct recv_frame_hdr	*precvframe_if2 = NULL;
@@ -558,17 +558,17 @@ static int recvbuf2recvframe(struct rtw_
 		}
 #ifdef CONFIG_CONCURRENT_MODE
 		if (rtw_buddy_adapter_up(padapter)) {
-			if (pre_recv_entry(precvframe, prxstat, pphy_info) != _SUCCESS)
-				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: recv_entry(precvframe) != _SUCCESS\n"));
+			if (pre_recv_entry(precvframe, prxstat, pphy_info) != 1)
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: recv_entry(precvframe) != 1\n"));
 		} else {
 			rtl8192d_translate_rx_signal_stuff(precvframe, pphy_info);
-			if (rtw_recv_entry(precvframe) != _SUCCESS)
-				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
+			if (rtw_recv_entry(precvframe) != 1)
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != 1\n"));
 		}
 #else
 		rtl8192d_translate_rx_signal_stuff(precvframe, pphy_info);
-		if (rtw_recv_entry(precvframe) != _SUCCESS)
-			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
+		if (rtw_recv_entry(precvframe) != 1)
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != 1\n"));
 #endif /* CONFIG_CONCURRENT_MODE */
 		pkt_cnt--;
 
@@ -584,7 +584,7 @@ static int recvbuf2recvframe(struct rtw_
 
 _exit_recvbuf2recvframe:
 
-	return _SUCCESS;
+	return 1;
 }
 
 void rtl8192du_recv_tasklet(void *priv)
@@ -687,7 +687,7 @@ static u32 usb_read_port(struct intf_hdl
 	int err, pipe;
 	SIZE_PTR tmpaddr=0;
 	SIZE_PTR alignment=0;
-	u32 ret = _SUCCESS;
+	u32 ret = 1;
 	struct urb *purb = NULL;
 	struct recv_buf	*precvbuf = (struct recv_buf *)rmem;
 	struct rtw_adapter *adapter = pintfhdl->padapter;
@@ -699,12 +699,12 @@ static u32 usb_read_port(struct intf_hdl
 	    adapter->pwrctrlpriv.pnp_bstop_trx) {
 		RT_TRACE(_module_hci_ops_os_c_, _drv_err_,
 			 ("usb_read_port:(padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
-		return _FAIL;
+		return 0;
 	}
 
 	if (!precvbuf) {
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:precvbuf ==NULL\n"));
-		return _FAIL;
+		return 0;
 	}
 	if ((precvbuf->reuse == false) || (precvbuf->pskb == NULL)) {
 		if (NULL != (precvbuf->pskb = skb_dequeue(&precvpriv->free_recv_skb_queue)))
@@ -718,7 +718,7 @@ static u32 usb_read_port(struct intf_hdl
 			precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
 			if (precvbuf->pskb == NULL) {
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("init_recvbuf(): alloc_skb fail!\n"));
-				return _FAIL;
+				return 0;
 			}
 
 			tmpaddr = (SIZE_PTR)precvbuf->pskb->data;
@@ -759,7 +759,7 @@ static u32 usb_read_port(struct intf_hdl
 		if ((err) && (err != (-EPERM))) {
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cannot submit rx in-token(err=0x%.8x), URB_STATUS =0x%.8x", err, purb->status));
 			DBG_8192D("cannot submit rx in-token(err = 0x%08x),urb_status = %d\n",err,purb->status);
-			ret = _FAIL;
+			ret = 0;
 		}
 	}
 
--- a/drivers/staging/rtl8192du/include/hal_intf.h
+++ b/drivers/staging/rtl8192du/include/hal_intf.h
@@ -132,7 +132,7 @@ enum _CHIP_TYPE {
 
 enum HW_VARIABLES {
 	HW_VAR_MEDIA_STATUS,
-	HW_VAR_MEDIA_STATUS1,
+	HW_VAR_MEDIA_STATUS_SUCCESS,
 	HW_VAR_SET_OPMODE,
 	HW_VAR_MAC_ADDR,
 	HW_VAR_BSSID,
--- a/drivers/staging/rtl8192du/include/osdep_service.h
+++ b/drivers/staging/rtl8192du/include/osdep_service.h
@@ -19,8 +19,6 @@
 #include <autoconf.h>
 #include <basic_types.h>
 
-#define _FAIL		0
-#define _SUCCESS	1
 #define RTW_RX_HANDLED 2
 
 #include <linux/spinlock.h>
--- a/drivers/staging/rtl8192du/include/rtw_mp.h
+++ b/drivers/staging/rtl8192du/include/rtw_mp.h
@@ -25,21 +25,21 @@
 #define STATUS_INSUFFICIENT_RESOURCES		(0xC000009AL)
 #define STATUS_NOT_SUPPORTED			(0xC00000BBL)
 
-#define uint_SUCCESS			((uint)STATUS_SUCCESS)
+#define UINT_SUCCESS			((uint)STATUS_SUCCESS)
 #define uint_PENDING			((uint)STATUS_PENDING)
 #define uint_NOT_RECOGNIZED		((uint)0x00010001L)
 #define uint_NOT_COPIED			((uint)0x00010002L)
 #define uint_NOT_ACCEPTED		((uint)0x00010003L)
 #define uint_CALL_ACTIVE			((uint)0x00010007L)
 
-#define uint_FAILURE			((uint)STATUS_UNSUCCESSFUL)
+#define UINT_FAILURE			((uint)STATUS_UNSUCCESSFUL)
 #define uint_RESOURCES			((uint)STATUS_INSUFFICIENT_RESOURCES)
 #define uint_CLOSING			((uint)0xC0010002L)
 #define uint_BAD_VERSION			((uint)0xC0010004L)
 #define uint_BAD_CHARACTERISTICS		((uint)0xC0010005L)
 #define uint_ADAPTER_NOT_FOUND		((uint)0xC0010006L)
-#define uint_OPEN_FAILED			((uint)0xC0010007L)
-#define uint_DEVICE_FAILED		((uint)0xC0010008L)
+#define UINT_OPEN_FAILED			((uint)0xC0010007L)
+#define UINT_DEVICE_FAILED		((uint)0xC0010008L)
 #define uint_MULTICAST_FULL		((uint)0xC0010009L)
 #define uint_MULTICAST_EXISTS		((uint)0xC001000AL)
 #define uint_MULTICAST_NOT_FOUND		((uint)0xC001000BL)
--- a/drivers/staging/rtl8192du/include/wifi.h
+++ b/drivers/staging/rtl8192du/include/wifi.h
@@ -103,7 +103,7 @@ enum WIFI_REASON_CODE	{
 
 	/*  WPA reason */
 	_RSON_INVALID_IE_				= 13,
-	_RSON_MIC_FAILURE_				= 14,
+	_RSON_MIC_FAILURE__				= 14,
 	_RSON_4WAY_HNDSHK_TIMEOUT_		= 15,
 	_RSON_GROUP_KEY_UPDATE_TIMEOUT_	= 16,
 	_RSON_DIFF_IE_					= 17,
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -493,18 +493,18 @@ static u8 set_pairwise_key(struct rtw_ad
 	struct cmd_obj*			ph2c;
 	struct set_stakey_parm	*psetstakey_para;
 	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
-	u8	res=_SUCCESS;
+	u8	res=1;
 
 	ph2c = (struct cmd_obj*)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
-		res= _FAIL;
+		res= 0;
 		goto exit;
 	}
 
 	psetstakey_para = (struct set_stakey_parm*)kzalloc(sizeof(struct set_stakey_parm), GFP_KERNEL);
 	if (psetstakey_para==NULL) {
 		kfree(ph2c);
-		res=_FAIL;
+		res=0;
 		goto exit;
 	}
 
@@ -529,19 +529,19 @@ static int set_group_key(struct rtw_adap
 	struct cmd_obj* pcmd;
 	struct setkey_parm *psetkeyparm;
 	struct cmd_priv	*pcmdpriv=&(padapter->cmdpriv);
-	int res=_SUCCESS;
+	int res=1;
 
 	DBG_8192D("%s\n", __func__);
 
 	pcmd = (struct cmd_obj*)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (pcmd==NULL) {
-		res= _FAIL;
+		res= 0;
 		goto exit;
 	}
 	psetkeyparm=(struct setkey_parm*)kzalloc(sizeof(struct setkey_parm), GFP_KERNEL);
 	if (psetkeyparm==NULL) {
 		kfree(pcmd);
-		res= _FAIL;
+		res= 0;
 		goto exit;
 	}
 
@@ -1304,7 +1304,7 @@ static int cfg80211_rtw_change_iface(str
 		}
 	}
 
-	if (_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (0 == rtw_pwr_wakeup(padapter)) {
 		ret= -EPERM;
 		goto exit;
 	}
@@ -1520,7 +1520,7 @@ static int cfg80211_rtw_scan(struct wiph
 	pwdev_priv->scan_request = request;
 	spin_unlock_bh(&pwdev_priv->scan_req_lock);
 
-	if (_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (0 == rtw_pwr_wakeup(padapter)) {
 		need_indicate_scan_done = true;
 		goto check_need_indicate_scan_done;
 	}
@@ -1825,7 +1825,7 @@ static int rtw_cfg80211_set_wpa_ie(struc
 
 	pwpa = rtw_get_wpa_ie(buf, &wpa_ielen, ielen);
 	if (pwpa && wpa_ielen > 0) {
-		if (rtw_parse_wpa_ie(pwpa, wpa_ielen+2, &group_cipher, &pairwise_cipher) == _SUCCESS) {
+		if (rtw_parse_wpa_ie(pwpa, wpa_ielen+2, &group_cipher, &pairwise_cipher) == 1) {
 			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
 			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPAPSK;
 			memcpy(padapter->securitypriv.supplicant_ie, &pwpa[0], wpa_ielen+2);
@@ -1836,7 +1836,7 @@ static int rtw_cfg80211_set_wpa_ie(struc
 
 	pwpa2 = rtw_get_wpa2_ie(buf, &wpa2_ielen, ielen);
 	if (pwpa2 && wpa2_ielen > 0) {
-		if (rtw_parse_wpa2_ie(pwpa2, wpa2_ielen+2, &group_cipher, &pairwise_cipher) == _SUCCESS) {
+		if (rtw_parse_wpa2_ie(pwpa2, wpa2_ielen+2, &group_cipher, &pairwise_cipher) == 1) {
 			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
 			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPA2PSK;
 			memcpy(padapter->securitypriv.supplicant_ie, &pwpa2[0], wpa2_ielen+2);
@@ -1983,7 +1983,7 @@ static int cfg80211_rtw_connect(struct w
 		goto exit;
 	}
 
-	if (_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (0 == rtw_pwr_wakeup(padapter)) {
 		ret= -EPERM;
 		goto exit;
 	}
@@ -2175,7 +2175,7 @@ static int cfg80211_rtw_connect(struct w
 
 		memcpy(pwep->KeyMaterial,  (void *)sme->key, pwep->KeyLength);
 
-		if (rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
+		if (rtw_set_802_11_add_wep(padapter, pwep) == (u8)0)
 			ret = -EOPNOTSUPP ;
 
 		if (pwep)
@@ -2799,7 +2799,7 @@ static int rtw_add_beacon(struct rtw_ada
 	rtw_ies_remove_ie(pbuf, &len, _BEACON_IE_OFFSET_, _VENDOR_SPECIFIC_IE_, P2P_OUI, 4);
 
 	/*  pbss_network->IEs will not include p2p_ie */
-	if (rtw_check_beacon_data(adapter, pbuf,  len) == _SUCCESS)
+	if (rtw_check_beacon_data(adapter, pbuf,  len) == 1)
 	{
 #ifdef  CONFIG_P2P
 		/* check p2p if enable */
@@ -3309,7 +3309,7 @@ void rtw_cfg80211_issue_p2p_provision_re
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
-	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS)
+	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != 1)
 		DBG_8192D("%s, ack to\n", __func__);
 
 }
@@ -3345,7 +3345,7 @@ static s32 cfg80211_rtw_remain_on_channe
 
 	pcfg80211_wdinfo->is_ro_ch = true;
 
-	if (_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (0 == rtw_pwr_wakeup(padapter)) {
 		err = -EFAULT;
 		goto exit;
 	}
@@ -3484,7 +3484,7 @@ static int _cfg80211_rtw_mgmt_tx(struct
 	struct xmit_frame	*pmgntframe;
 	struct pkt_attrib	*pattrib;
 	unsigned char	*pframe;
-	int ret = _FAIL;
+	int ret = 0;
 	bool ack = true;
 	struct ieee80211_hdr *pwlanhdr;
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
@@ -3493,7 +3493,7 @@ static int _cfg80211_rtw_mgmt_tx(struct
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 
-	if (_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (0 == rtw_pwr_wakeup(padapter)) {
 		ret = -EFAULT;
 		goto exit;
 	}
@@ -3551,7 +3551,7 @@ static int _cfg80211_rtw_mgmt_tx(struct
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
 		/* ret = -ENOMEM; */
-		ret = _FAIL;
+		ret = 0;
 		goto exit;
 	}
 
@@ -3575,11 +3575,11 @@ static int _cfg80211_rtw_mgmt_tx(struct
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
-	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS) {
+	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != 1) {
 		ack = false;
-		ret = _FAIL;
+		ret = 0;
 	} else {
-		ret = _SUCCESS;
+		ret = 1;
 	}
 
 exit:
@@ -3635,11 +3635,11 @@ dump:
 	do {
 		dump_cnt++;
 		tx_ret = _cfg80211_rtw_mgmt_tx(padapter, tx_ch, buf, len);
-	} while (dump_cnt < dump_limit && tx_ret != _SUCCESS);
+	} while (dump_cnt < dump_limit && tx_ret != 1);
 
-	if (tx_ret != _SUCCESS || dump_cnt > 1) {
+	if (tx_ret != 1 || dump_cnt > 1) {
 		DBG_8192D(FUNC_ADPT_FMT" %s (%d/%d) in %d ms\n", FUNC_ADPT_ARG(padapter),
-			tx_ret==_SUCCESS?"OK":"FAIL", dump_cnt, dump_limit, rtw_systime_to_ms(jiffies - start));
+			tx_ret==1?"OK":"FAIL", dump_cnt, dump_limit, rtw_systime_to_ms(jiffies - start));
 	}
 
 	switch (type) {
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -490,7 +490,7 @@ static int wpa_set_encryption(struct net
 		if (param->u.crypt.set_tx) {
 			DBG_8192D("wep, set_tx = 1\n");
 
-			if (rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
+			if (rtw_set_802_11_add_wep(padapter, pwep) == (u8)0)
 				ret = -EOPNOTSUPP ;
 		} else {
 			DBG_8192D("wep, set_tx = 0\n");
@@ -617,13 +617,13 @@ static int rtw_set_wpa_ie(struct rtw_ada
 			goto exit;
 		}
 
-		if (rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS) {
+		if (rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher) == 1) {
 			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
 			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPAPSK;
 			memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);
 		}
 
-		if (rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS) {
+		if (rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher) == 1) {
 			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
 			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPA2PSK;
 			memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);
@@ -821,7 +821,7 @@ static int rtw_wx_set_mode(struct net_de
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct __queue *queue = &pmlmepriv->scanned_queue;
 
-	if (_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (0 == rtw_pwr_wakeup(padapter)) {
 		ret = -EPERM;
 		goto exit;
 	}
@@ -1124,7 +1124,7 @@ static int rtw_wx_set_wap(struct net_dev
 	}
 #endif
 
-	if (_FAIL == rtw_pwr_wakeup(padapter))
+	if (0 == rtw_pwr_wakeup(padapter))
 	{
 		ret = -1;
 		goto exit;
@@ -1259,7 +1259,7 @@ static int rtw_wx_set_scan(struct net_de
 #endif /* CONFIG_P2P */
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_set_scan\n"));
 
-	if (_FAIL == rtw_pwr_wakeup(padapter)) {
+	if (0 == rtw_pwr_wakeup(padapter)) {
 		ret = -1;
 		goto exit;
 	}
@@ -1558,7 +1558,7 @@ static int rtw_wx_set_essid(struct net_d
 
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
 		 ("+rtw_wx_set_essid: fw_state = 0x%08x\n", get_fwstate(pmlmepriv)));
-	if (_FAIL == rtw_pwr_wakeup(padapter))
+	if (0 == rtw_pwr_wakeup(padapter))
 	{
 		ret = -1;
 		goto exit;
@@ -1768,7 +1768,7 @@ set_rate:
 		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("datarate_inx =%d\n", datarates[i]));
 	}
 
-	if (rtw_setdatarate_cmd(padapter, datarates) != _SUCCESS) {
+	if (rtw_setdatarate_cmd(padapter, datarates) != 1) {
 		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("rtw_wx_set_rate Fail!!!\n"));
 		ret = -1;
 	}
@@ -2441,7 +2441,7 @@ static int rtw_wx_set_channel_plan(struc
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	u8 channel_plan_req = (u8) (*((int *)wrqu));
 
-	if (_SUCCESS == rtw_set_chplan_cmd(padapter, channel_plan_req, 1)) {
+	if (1 == rtw_set_chplan_cmd(padapter, channel_plan_req, 1)) {
 		DBG_8192D("%s set channel_plan = 0x%02X\n", __func__, pmlmepriv->ChannelPlan);
 	} else
 		return -EPERM;
@@ -2810,7 +2810,7 @@ static int rtw_wext_p2p_enable(struct ne
 	else if (*extra == '3')
 		init_role = P2P_ROLE_GO;
 
-	if (_FAIL == rtw_p2p_enable(padapter, init_role))
+	if (0 == rtw_p2p_enable(padapter, init_role))
 	{
 		ret = -EFAULT;
 		goto exit;
@@ -5129,18 +5129,18 @@ static u8 set_pairwise_key(struct rtw_ad
 	struct cmd_obj*			ph2c;
 	struct set_stakey_parm	*psetstakey_para;
 	struct cmd_priv				*pcmdpriv =&padapter->cmdpriv;
-	u8	res = _SUCCESS;
+	u8	res = 1;
 
 	ph2c = (struct cmd_obj*)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (ph2c == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
 	psetstakey_para = (struct set_stakey_parm*)kzalloc(sizeof(struct set_stakey_parm), GFP_KERNEL);
 	if (psetstakey_para == NULL) {
 		kfree(ph2c);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -5165,19 +5165,19 @@ static int set_group_key(struct rtw_adap
 	struct cmd_obj* pcmd;
 	struct setkey_parm *psetkeyparm;
 	struct cmd_priv	*pcmdpriv =&(padapter->cmdpriv);
-	int res = _SUCCESS;
+	int res = 1;
 
 	DBG_8192D("%s\n", __func__);
 
 	pcmd = (struct cmd_obj*)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
 	if (pcmd == NULL) {
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 	psetkeyparm = (struct setkey_parm*)kzalloc(sizeof(struct setkey_parm), GFP_KERNEL);
 	if (psetkeyparm == NULL) {
 		kfree(pcmd);
-		res = _FAIL;
+		res = 0;
 		goto exit;
 	}
 
@@ -5576,7 +5576,7 @@ static int rtw_set_beacon(struct net_dev
 	if ((pstapriv->max_num_sta>NUM_STA) || (pstapriv->max_num_sta<= 0))
 		pstapriv->max_num_sta = NUM_STA;
 
-	if (rtw_check_beacon_data(padapter, pbuf,  (len-12-2)) == _SUCCESS)/*  12 = param header, 2:no packed */
+	if (rtw_check_beacon_data(padapter, pbuf,  (len-12-2)) == 1)/*  12 = param header, 2:no packed */
 		ret = 0;
 	else
 		ret = -EINVAL;
@@ -6248,7 +6248,7 @@ static int rtw_mp_efuse_get(struct net_d
 
 		mapLen = EFUSE_MAP_SIZE;
 
-		if (rtw_efuse_map_read(padapter, 0, mapLen, data) == _SUCCESS) {
+		if (rtw_efuse_map_read(padapter, 0, mapLen, data) == 1) {
 			DBG_8192D("\t  rtw_efuse_map_read\n");
 		} else {
 			DBG_8192D("\t  rtw_efuse_map_read : Fail\n");
@@ -6297,7 +6297,7 @@ static int rtw_mp_efuse_get(struct net_d
 			return -EFAULT;
 		}
 
-		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL)
+		if (rtw_efuse_map_read(padapter, addr, cnts, data) == 0)
 			DBG_8192D("rtw_efuse_access error\n");
 		else
 			DBG_8192D("rtw_efuse_access ok\n");
@@ -6319,7 +6319,7 @@ static int rtw_mp_efuse_get(struct net_d
 		addr = 0;
 		mapLen = EFUSE_MAX_SIZE;
 
-		if (rtw_efuse_access(padapter, false, addr, mapLen, rawdata) == _FAIL) {
+		if (rtw_efuse_access(padapter, false, addr, mapLen, rawdata) == 0) {
 			DBG_8192D("\t  rtw_efuse_map_read : Fail\n");
 			return -EFAULT;
 		} else {
@@ -6350,7 +6350,7 @@ static int rtw_mp_efuse_get(struct net_d
 			DBG_8192D("(addr + cnts parameter error\n");
 			return -EFAULT;
 		}
-		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL)
+		if (rtw_efuse_map_read(padapter, addr, cnts, data) == 0)
 			DBG_8192D("rtw_efuse_access error\n");
 		else
 			DBG_8192D("rtw_efuse_access ok\n");
@@ -6373,7 +6373,7 @@ static int rtw_mp_efuse_get(struct net_d
 			DBG_8192D("(addr + cnts parameter error\n");
 			return -EFAULT;
 		}
-		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL) {
+		if (rtw_efuse_map_read(padapter, addr, cnts, data) == 0) {
 			DBG_8192D("rtw_efuse_access error\n");
 		} else {
 			DBG_8192D("rtw_efuse_access ok\n");
@@ -6456,7 +6456,7 @@ static int rtw_mp_efuse_set(struct net_d
 					DBG_8192D("parameter error\n");
 					return -EFAULT;
 		}
-		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
+		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == 0) {
 				DBG_8192D("rtw_efuse_map_write error\n");
 				return -EFAULT;
 		} else
@@ -6479,7 +6479,7 @@ static int rtw_mp_efuse_set(struct net_d
 			for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
 					setrawdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+ 1]);
 
-			if (rtw_efuse_access(padapter, true, addr, cnts, setrawdata) == _FAIL) {
+			if (rtw_efuse_access(padapter, true, addr, cnts, setrawdata) == 0) {
 					DBG_8192D("\t  rtw_efuse_map_read : Fail\n");
 						return -EFAULT;
 			} else {
@@ -6508,7 +6508,7 @@ static int rtw_mp_efuse_set(struct net_d
 						DBG_8192D("parameter error\n");
 						return -EFAULT;
 				}
-				if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
+				if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == 0) {
 					DBG_8192D("rtw_efuse_map_write error\n");
 					return -EFAULT;
 				} else
@@ -6536,7 +6536,7 @@ static int rtw_mp_efuse_set(struct net_d
 				return -EFAULT;
 			}
 
-			if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
+			if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == 0) {
 				DBG_8192D("rtw_efuse_map_write error\n");
 				return -EFAULT;
 			} else
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -180,7 +180,7 @@ static int netdev_close (struct net_devi
 
 static uint loadparam(struct rtw_adapter *padapter, struct net_device *pnetdev)
 {
-	uint status = _SUCCESS;
+	uint status = 1;
 	struct registry_priv  *registry_par = &padapter->registrypriv;
 
 	registry_par->chip_version = (u8)rtw_chip_version;
@@ -431,7 +431,7 @@ struct net_device *rtw_init_netdev(struc
 u32 rtw_start_drv_threads(struct rtw_adapter *padapter)
 {
 
-	u32 _status = _SUCCESS;
+	u32 _status = 1;
 
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_start_drv_threads\n"));
 
@@ -441,7 +441,7 @@ u32 rtw_start_drv_threads(struct rtw_ada
 	{
 		padapter->cmdThread = kthread_run(rtw_cmd_thread, padapter, "RTW_CMD_THREAD");
 		if (IS_ERR(padapter->cmdThread))
-			_status = _FAIL;
+			_status = 0;
 		else
 			_rtw_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema); /* wait for cmd_thread to run */
 	}
@@ -466,7 +466,7 @@ void rtw_stop_drv_threads (struct rtw_ad
 
 static u8 rtw_init_default_value(struct rtw_adapter *padapter)
 {
-	u8 ret  = _SUCCESS;
+	u8 ret  = 1;
 	struct registry_priv* pregistrypriv = &padapter->registrypriv;
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -490,7 +490,7 @@ static u8 rtw_init_default_value(struct
 	pmlmepriv->htpriv.ampdu_enable = false;/* set to disabled */
 
 	/* security_priv */
-	psecuritypriv->binstallGrpkey = _FAIL;
+	psecuritypriv->binstallGrpkey = 0;
 	psecuritypriv->sw_encrypt = pregistrypriv->software_encrypt;
 	psecuritypriv->sw_decrypt = pregistrypriv->software_decrypt;
 
@@ -528,7 +528,7 @@ static u8 rtw_init_default_value(struct
 
 u8 rtw_reset_drv_sw(struct rtw_adapter *padapter)
 {
-	u8	ret8 = _SUCCESS;
+	u8	ret8 = 1;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 
@@ -561,30 +561,30 @@ u8 rtw_reset_drv_sw(struct rtw_adapter *
 u8 rtw_init_drv_sw(struct rtw_adapter *padapter)
 {
 
-	u8	ret8 = _SUCCESS;
+	u8	ret8 = 1;
 
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_init_drv_sw\n"));
 
-	if ((rtw_init_cmd_priv(&padapter->cmdpriv)) == _FAIL)
+	if ((rtw_init_cmd_priv(&padapter->cmdpriv)) == 0)
 	{
 		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init cmd_priv\n"));
-		ret8 = _FAIL;
+		ret8 = 0;
 		goto exit;
 	}
 
 	padapter->cmdpriv.padapter = padapter;
 
-	if ((rtw_init_evt_priv(&padapter->evtpriv)) == _FAIL)
+	if ((rtw_init_evt_priv(&padapter->evtpriv)) == 0)
 	{
 		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init evt_priv\n"));
-		ret8 = _FAIL;
+		ret8 = 0;
 		goto exit;
 	}
 
-	if (rtw_init_mlme_priv(padapter) == _FAIL)
+	if (rtw_init_mlme_priv(padapter) == 0)
 	{
 		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init mlme_priv\n"));
-		ret8 = _FAIL;
+		ret8 = 0;
 		goto exit;
 	}
 
@@ -595,31 +595,31 @@ u8 rtw_init_drv_sw(struct rtw_adapter *p
 	rtw_init_cfg80211_wifidirect_info(padapter);
 #endif /* CONFIG_P2P */
 
-	if (init_mlme_ext_priv(padapter) == _FAIL) {
+	if (init_mlme_ext_priv(padapter) == 0) {
 		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init mlme_ext_priv\n"));
-		ret8 = _FAIL;
+		ret8 = 0;
 		goto exit;
 	}
 
-	if (_rtw_init_xmit_priv(&padapter->xmitpriv, padapter) == _FAIL) {
+	if (_rtw_init_xmit_priv(&padapter->xmitpriv, padapter) == 0) {
 		DBG_8192D("Can't _rtw_init_xmit_priv\n");
-		ret8 = _FAIL;
+		ret8 = 0;
 		goto exit;
 	}
 
-	if (_rtw_init_recv_priv(&padapter->recvpriv, padapter) == _FAIL) {
+	if (_rtw_init_recv_priv(&padapter->recvpriv, padapter) == 0) {
 		DBG_8192D("Can't _rtw_init_recv_priv\n");
-		ret8 = _FAIL;
+		ret8 = 0;
 		goto exit;
 	}
 
 	/* We don't need to memset padapter->XXX to zero, because adapter
 	 * is allocated by vzalloc().
 	 */
-	if (_rtw_init_sta_priv(&padapter->stapriv) == _FAIL)
+	if (_rtw_init_sta_priv(&padapter->stapriv) == 0)
 	{
 		DBG_8192D("Can't _rtw_init_sta_priv\n");
-		ret8 = _FAIL;
+		ret8 = 0;
 		goto exit;
 	}
 
@@ -727,7 +727,7 @@ u8 rtw_free_drv_sw(struct rtw_adapter *p
 
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-rtw_free_drv_sw\n"));
 
-	return _SUCCESS;
+	return 1;
 }
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -759,7 +759,7 @@ static int _netdev_if2_open(struct net_d
 
 		rtw_hal_set_hwreg(padapter, HW_VAR_DM_INIT_PWDB, NULL);
 
-		if (rtw_start_drv_threads(padapter) == _FAIL)
+		if (rtw_start_drv_threads(padapter) == 0)
 			goto netdev_if2_open_error;
 
 		if (padapter->intf_start)
@@ -889,7 +889,7 @@ struct rtw_adapter *rtw_drv_if2_init(str
 	padapter->intf_stop = primary_padapter->intf_stop;
 
 	/* step init_io_priv */
-	if ((rtw_init_io_priv(padapter, set_intf_ops)) == _FAIL) {
+	if ((rtw_init_io_priv(padapter, set_intf_ops)) == 0) {
 		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("\n Can't init io_reqs\n"));
 	}
 
@@ -900,7 +900,7 @@ struct rtw_adapter *rtw_drv_if2_init(str
 	rtw_hal_chip_configure(padapter);
 
 	/* init drv data */
-	if (rtw_init_drv_sw(padapter)!= _SUCCESS)
+	if (rtw_init_drv_sw(padapter)!= 1)
 		goto error_rtw_drv_if2_init;
 
 	/*  alloc dev name after got efuse data. */
@@ -1033,7 +1033,7 @@ int _netdev_open(struct net_device *pnet
 		padapter->bCardDisableWOHSM = false;
 
 		status = rtw_hal_init(padapter);
-		if (status == _FAIL)
+		if (status == 0)
 		{
 			RT_TRACE(_module_os_intfs_c_, _drv_err_, ("rtl871x_hal_init(): Can't init h/w!\n"));
 			goto netdev_open_error;
@@ -1042,13 +1042,13 @@ int _netdev_open(struct net_device *pnet
 		DBG_8192D("MAC Address = %pM\n", pnetdev->dev_addr);
 
 		status = rtw_start_drv_threads(padapter);
-		if (status == _FAIL)
+		if (status == 0)
 		{
 			RT_TRACE(_module_os_intfs_c_, _drv_err_, ("Initialize driver software resource Failed!\n"));
 			goto netdev_open_error;
 		}
 
-		if (init_hw_mlme_ext(padapter) == _FAIL)
+		if (init_hw_mlme_ext(padapter) == 0)
 		{
 			RT_TRACE(_module_os_intfs_c_, _drv_err_, ("can't init mlme_ext_priv\n"));
 			goto netdev_open_error;
@@ -1116,7 +1116,7 @@ int netdev_open(struct net_device *pnetd
 
 static int  ips_netdrv_open(struct rtw_adapter *padapter)
 {
-	int status = _SUCCESS;
+	int status = 1;
 	padapter->net_closed = false;
 	DBG_8192D("===> %s.........\n", __func__);
 
@@ -1125,7 +1125,7 @@ static int  ips_netdrv_open(struct rtw_a
 	padapter->bCardDisableWOHSM = false;
 
 	status = rtw_hal_init(padapter);
-	if (status == _FAIL) {
+	if (status == 0) {
 		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("ips_netdrv_open(): Can't init h/w!\n"));
 		goto netdev_open_error;
 	}
@@ -1136,12 +1136,12 @@ static int  ips_netdrv_open(struct rtw_a
 	rtw_set_pwr_state_check_timer(&padapter->pwrctrlpriv);
 	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 5000);
 
-	 return _SUCCESS;
+	 return 1;
 
 netdev_open_error:
 	DBG_8192D("-ips_netdrv_open - drv_open failure, bup =%d\n", padapter->bup);
 
-	return _FAIL;
+	return 0;
 }
 
 int rtw_ips_pwr_up(struct rtw_adapter *padapter)
@@ -1196,7 +1196,7 @@ int pm_netdev_open(struct net_device *pn
 	if (bnormal)
 		status = netdev_open(pnetdev);
 	else
-		status =  (_SUCCESS == ips_netdrv_open((struct rtw_adapter *)rtw_netdev_priv(pnetdev)))?(0):(-1);
+		status =  (1 == ips_netdrv_open((struct rtw_adapter *)rtw_netdev_priv(pnetdev)))?(0):(-1);
 
 	return status;
 }
--- a/drivers/staging/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8192du/os_dep/osdep_service.c
@@ -28,20 +28,20 @@
 */
 inline int RTW_STATUS_CODE(int error_code) {
 	if (error_code >=0)
-		return _SUCCESS;
+		return 1;
 
 	switch (error_code) {
 		default:
-			return _FAIL;
+			return 0;
 	}
 }
 
 u32 _rtw_down_sema(struct  semaphore *sema)
 {
 	if (down_interruptible(sema))
-		return _FAIL;
+		return 0;
 	else
-		return _SUCCESS;
+		return 1;
 }
 
 void	_rtw_init_queue(struct __queue *pqueue)
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -26,7 +26,7 @@
 /* alloc os related resource in struct recv_frame_hdr */
 int rtw_os_recv_resource_alloc(struct rtw_adapter *padapter, struct recv_frame_hdr *precvframe)
 {
-	int	res=_SUCCESS;
+	int	res=1;
 
 	precvframe->pkt_newalloc = precvframe->pkt = NULL;
 
@@ -41,7 +41,7 @@ void rtw_os_recv_resource_free(struct re
 /* alloc os related resource in struct recv_buf */
 int rtw_os_recvbuf_resource_alloc(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
 {
-	int res=_SUCCESS;
+	int res=1;
 
 	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
 	struct usb_device	*pusbd = pdvobjpriv->pusbdev;
@@ -49,7 +49,7 @@ int rtw_os_recvbuf_resource_alloc(struct
 	precvbuf->irp_pending = false;
 	precvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);
 	if (precvbuf->purb == NULL) {
-		res = _FAIL;
+		res = 0;
 	}
 
 	precvbuf->pskb = NULL;
@@ -70,7 +70,7 @@ int rtw_os_recvbuf_resource_alloc(struct
 /* free os related resource in struct recv_buf */
 int rtw_os_recvbuf_resource_free(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
 {
-	int ret = _SUCCESS;
+	int ret = 1;
 
 	if (precvbuf->purb)
 		usb_free_urb(precvbuf->purb);
@@ -215,14 +215,14 @@ _recv_indicatepkt_end:
 
 	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n rtw_recv_indicatepkt :after netif_rx!!!!\n"));
 
-        return _SUCCESS;
+        return 1;
 
 _recv_indicatepkt_drop:
 
 	 /* enqueue back to free_recv_queue */
 	 rtw_free_recvframe(precv_frame, pfree_recv_queue);
 
-	 return _FAIL;
+	 return 0;
 }
 
 void rtw_os_read_port(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -105,14 +105,14 @@ static inline int RT_usb_endpoint_num(co
 
 static u8 rtw_init_intf_priv(struct dvobj_priv *dvobj)
 {
-	u8 rst = _SUCCESS;
+	u8 rst = 1;
 
 	mutex_init(&dvobj->usb_vendor_req_mutex);
 
 	dvobj->usb_alloc_vendor_req_buf = kzalloc(MAX_USB_IO_CTL_SIZE, GFP_KERNEL);
 	if (dvobj->usb_alloc_vendor_req_buf == NULL) {
 		DBG_8192D("alloc usb_vendor_req_buf failed... /n");
-		rst = _FAIL;
+		rst = 0;
 		goto exit;
 	}
 	dvobj->usb_vendor_req_buf  =
@@ -123,7 +123,7 @@ exit:
 
 static u8 rtw_deinit_intf_priv(struct dvobj_priv *dvobj)
 {
-	u8 rst = _SUCCESS;
+	u8 rst = 1;
 
 	kfree(dvobj->usb_alloc_vendor_req_buf);
 	mutex_destroy(&dvobj->usb_vendor_req_mutex);
@@ -134,7 +134,7 @@ static struct dvobj_priv *usb_dvobj_init
 {
 	int	i;
 	u8	val8;
-	int	status = _FAIL;
+	int	status = 0;
 	struct dvobj_priv *pdvobjpriv = NULL;
 	struct usb_device				*pusbd;
 	struct usb_host_config			*phost_conf;
@@ -206,7 +206,7 @@ static struct dvobj_priv *usb_dvobj_init
 		DBG_8192D("NON USB_SPEED_HIGH\n");
 	}
 
-	if (rtw_init_intf_priv(pdvobjpriv) == _FAIL) {
+	if (rtw_init_intf_priv(pdvobjpriv) == 0) {
 		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't INIT rtw_init_intf_priv\n"));
 		goto free_dvobj;
 	}
@@ -218,10 +218,10 @@ static struct dvobj_priv *usb_dvobj_init
 
 	usb_get_dev(pusbd);
 
-	status = _SUCCESS;
+	status = 1;
 
 free_dvobj:
-	if (status != _SUCCESS && pdvobjpriv) {
+	if (status != 1 && pdvobjpriv) {
 		usb_set_intfdata(usb_intf, NULL);
 		mutex_destroy(&pdvobjpriv->hw_init_mutex);
 		mutex_destroy(&pdvobjpriv->h2c_fwcmd_mutex);
@@ -512,7 +512,7 @@ static struct rtw_adapter *rtw_usb_if1_i
 {
 	struct rtw_adapter *padapter = NULL;
 	struct net_device *pnetdev = NULL;
-	int status = _FAIL;
+	int status = 0;
 
 	padapter = (struct rtw_adapter *)vzalloc(sizeof(*padapter));
 	if (!padapter)
@@ -541,7 +541,7 @@ static struct rtw_adapter *rtw_usb_if1_i
 	SET_NETDEV_DEV(pnetdev, dvobj_to_dev(dvobj));
 	padapter = rtw_netdev_priv(pnetdev);
 
-	if (rtw_handle_dualmac(padapter, 1) != _SUCCESS)
+	if (rtw_handle_dualmac(padapter, 1) != 1)
 		goto free_adapter;
 
 	if (rtw_wdev_alloc(padapter, dvobj_to_dev(dvobj)) != 0)
@@ -560,7 +560,7 @@ static struct rtw_adapter *rtw_usb_if1_i
 	padapter->intf_stop=&usb_intf_stop;
 
 	/* 2 */
-	if ((rtw_init_io_priv(padapter, usb_set_intf_ops)) == _FAIL) {
+	if ((rtw_init_io_priv(padapter, usb_set_intf_ops)) == 0) {
 		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("\n Can't init io_reqs\n"));
 		goto free_hal_data;
 	}
@@ -574,7 +574,7 @@ static struct rtw_adapter *rtw_usb_if1_i
 	rtw_hal_read_chip_info(padapter);
 
 	/* step 5. */
-	if (rtw_init_drv_sw(padapter) == _FAIL) {
+	if (rtw_init_drv_sw(padapter) == 0) {
 		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Initialize driver software resource Failed!\n"));
 		goto free_hal_data;
 	}
@@ -612,21 +612,21 @@ static struct rtw_adapter *rtw_usb_if1_i
 		  padapter->bup, padapter->hw_init_completed
 	);
 
-	status = _SUCCESS;
+	status = 1;
 
 free_hal_data:
-	if (status != _SUCCESS && padapter->HalData)
+	if (status != 1 && padapter->HalData)
 		kfree(padapter->HalData);
 free_wdev:
-	if (status != _SUCCESS) {
+	if (status != 1) {
 		rtw_wdev_unregister(padapter->rtw_wdev);
 		rtw_wdev_free(padapter->rtw_wdev);
 	}
 handle_dualmac:
-	if (status != _SUCCESS)
+	if (status != 1)
 		rtw_handle_dualmac(padapter, 0);
 free_adapter:
-	if (status != _SUCCESS) {
+	if (status != 1) {
 		if (pnetdev)
 			rtw_free_netdev(pnetdev);
 		else if (padapter)
@@ -687,7 +687,7 @@ static int rtw_drv_init(struct usb_inter
 {
 	struct rtw_adapter *if1 = NULL, *if2 = NULL;
 	struct dvobj_priv *dvobj = NULL;
-	uint status = _FAIL;
+	uint status = 0;
 
 	/* step 0. */
 	process_spec_devid(did);
@@ -711,16 +711,16 @@ static int rtw_drv_init(struct usb_inter
 	}
 #endif
 
-	status = _SUCCESS;
+	status = 1;
 
 free_if1:
-	if (status != _SUCCESS && if1)
+	if (status != 1 && if1)
 		rtw_usb_if1_deinit(if1);
 free_dvobj:
-	if (status != _SUCCESS)
+	if (status != 1)
 		usb_dvobj_deinit(pusb_intf);
 exit:
-	return status == _SUCCESS ? 0 : -ENODEV;
+	return status == 1 ? 0 : -ENODEV;
 }
 
 /* dev_remove() - our device is being removed
--- a/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
@@ -74,7 +74,7 @@ static u32 usb_bulkout_zero(struct intf_
 
 	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||
 	    (padapter->pwrctrlpriv.pnp_bstop_trx))
-		return _FAIL;
+		return 0;
 
 	pcontext = (struct zero_bulkout_context *)kzalloc(sizeof(struct zero_bulkout_context), GFP_KERNEL);
 
@@ -95,9 +95,9 @@ static u32 usb_bulkout_zero(struct intf_
 	status = usb_submit_urb(purb, GFP_ATOMIC);
 
 	if (!status)
-		ret= _SUCCESS;
+		ret= 1;
 	else
-		ret= _FAIL;
+		ret= 0;
 
 	return ret;
 }
@@ -224,7 +224,7 @@ u32 usb_write_port(struct intf_hdl *pint
 	long unsigned int irqL;
 	unsigned int pipe;
 	int status;
-	u32 ret = _FAIL, bwritezero = false;
+	u32 ret = 0, bwritezero = false;
 	struct urb *purb = NULL;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)pintfhdl->padapter;
 	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);
@@ -299,11 +299,11 @@ u32 usb_write_port(struct intf_hdl *pint
 		}
 		goto exit;
 	}
-	ret= _SUCCESS;
+	ret= 1;
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("-usb_write_port\n"));
 
 exit:
-	if (ret != _SUCCESS)
+	if (ret != 1)
 		rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
 
 	return ret;
--- a/drivers/staging/rtl8192du/os_dep/xmit_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/xmit_linux.c
@@ -83,7 +83,7 @@ int rtw_os_xmit_resource_alloc(struct rt
 	pxmitbuf->pallocated_buf = kzalloc(alloc_sz, GFP_KERNEL);
 	if (pxmitbuf->pallocated_buf == NULL)
 	{
-		return _FAIL;
+		return 0;
 	}
 
 	pxmitbuf->pbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitbuf->pallocated_buf), XMITBUF_ALIGN_SZ);
@@ -93,11 +93,11 @@ int rtw_os_xmit_resource_alloc(struct rt
 		pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
 		if (pxmitbuf->pxmit_urb[i] == NULL) {
 			DBG_8192D("pxmitbuf->pxmit_urb[i]==NULL");
-			return _FAIL;
+			return 0;
 		}
 
 	}
-	return _SUCCESS;
+	return 1;
 }
 
 void rtw_os_xmit_resource_free(struct rtw_adapter *padapter, struct xmit_buf *pxmitbuf,u32 free_sz)

From d85217e8a6974004e5bf781e2e6f4f1e4bf538b7 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Wed, 19 Feb 2014 12:09:20 -0600
Subject: [PATCH 205/210] rtl8192du: Clean up include/rtw_recv.h

This cleanup includes removing ifdef conditional statements, all
checkpatch errors and warnings, and camelcase variables.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_mlme.c        |  11 +-
 core/rtw_mlme_ext.c    |   2 +-
 core/rtw_recv.c        |  23 +--
 core/rtw_tdls.c        |  14 +-
 hal/rtl8192d_rxdesc.c  |  73 +--------
 hal/rtl8192du_recv.c   |  35 +----
 hal/usb_halinit.c      |  13 --
 hal/usb_ops_linux.c    | 406 -------------------------------------------------
 include/autoconf.h     |  23 +--
 include/rtw_mlme.h     |   2 +-
 include/rtw_recv.h     | 357 ++++++++++++++++---------------------------
 os_dep/os_intfs.c      |  20 ---
 os_dep/recv_linux.c    |  19 ---
 os_dep/usb_ops_linux.c |   9 +-
 14 files changed, 155 insertions(+), 852 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -964,10 +964,7 @@ void rtw_surveydone_event_callback(struc
 			 ("nic status =%x, survey done event comes too late!\n",
 			  get_fwstate(pmlmepriv)));
 	}
-
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	rtw_set_signal_stat_timer(&adapter->recvpriv);
-#endif
 
 	if (pmlmepriv->to_join == true) {
 		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)) {
@@ -1470,14 +1467,14 @@ static void rtw_joinbss_update_network(s
 
 	cur_network->aid = pnetwork->join_res;
 
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	rtw_set_signal_stat_timer(&padapter->recvpriv);
-#endif
 	padapter->recvpriv.signal_strength =
 	    ptarget_wlan->network.PhyInfo.SignalStrength;
 	padapter->recvpriv.signal_qual =
 	    ptarget_wlan->network.PhyInfo.SignalQuality;
-	/* the ptarget_wlan->network.Rssi is raw data, we use ptarget_wlan->network.PhyInfo.SignalStrength instead (has scaled) */
+	/* the ptarget_wlan->network.Rssi is raw data,
+	 * we use scaled ptarget_wlan->network.PhyInfo.SignalStrength instead
+	 */
 	padapter->recvpriv.rssi =
 	    translate_percentage_to_dbm(ptarget_wlan->network.PhyInfo.
 					SignalStrength);
@@ -1486,9 +1483,7 @@ static void rtw_joinbss_update_network(s
 		  "\n", __func__, adapter->recvpriv.signal_strength,
 		  adapter->recvpriv.rssi, adapter->recvpriv.signal_qual);
 #endif
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	rtw_set_signal_stat_timer(&padapter->recvpriv);
-#endif
 
 	/* update fw_state will clr _FW_UNDER_LINKING here indirectly */
 	switch (pnetwork->network.InfrastructureMode) {
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -9040,7 +9040,7 @@ u8 collect_bss_info(struct rtw_adapter *
 	/* get the signal strength */
 	bssid->PhyInfo.SignalQuality = precv_frame->attrib.signal_qual;	/* in percentage */
 	bssid->PhyInfo.SignalStrength = precv_frame->attrib.signal_strength;	/* in percentage */
-	bssid->Rssi = precv_frame->attrib.RecvSignalPower;	/*  in dBM.raw data */
+	bssid->Rssi = precv_frame->attrib.recvsignalpower;	/*  in dBM.raw data */
 
 #ifdef CONFIG_ANTENNA_DIVERSITY
 	/* rtw_hal_get_hwreg(adapt, HW_VAR_CURRENT_ANTENNA, (u8 *)(&bssid->PhyInfo.Optimum_antenna)); */
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -27,9 +27,7 @@
 #include <usb_osintf.h>
 #include <linux/vmalloc.h>
 
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS);
-#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
 {
@@ -99,36 +97,23 @@ int _rtw_init_recv_priv(struct recv_priv
 	precvpriv->read_port_complete_EINPROGRESS_cnt = 0;
 	precvpriv->read_port_complete_other_urb_err_cnt = 0;
 
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	_init_timer(&precvpriv->signal_stat_timer, padapter->pnetdev,
 		    RTW_TIMER_HDL_NAME(signal_stat), padapter);
 
 	precvpriv->signal_stat_sampling_interval = 1000;	/* ms */
 
 	rtw_set_signal_stat_timer(precvpriv);
-#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 exit:
-
 	return res;
 }
 
 static void rtw_mfree_recv_priv_lock(struct recv_priv *precvpriv)
 {
 	_rtw_spinlock_free(&precvpriv->lock);
-#ifdef CONFIG_RECV_THREAD_MODE
-	_rtw_free_sema(&precvpriv->recv_sema);
-	_rtw_free_sema(&precvpriv->terminate_recvthread_sema);
-#endif
-
 	_rtw_spinlock_free(&precvpriv->free_recv_queue.lock);
 	_rtw_spinlock_free(&precvpriv->recv_pending_queue.lock);
-
 	_rtw_spinlock_free(&precvpriv->free_recv_buf_queue.lock);
-
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
-	_rtw_spinlock_free(&precvpriv->recv_buf_pending_queue.lock);
-#endif /*  CONFIG_USE_USB_BUFFER_ALLOC_RX */
 }
 
 void _rtw_free_recv_priv(struct recv_priv *precvpriv)
@@ -213,11 +198,7 @@ int rtw_free_recvframe(struct recv_frame
 	}
 #endif
 	if (precvframe->pkt) {
-#ifdef CONFIG_BSD_RX_USE_MBUF
-		m_freem(precvframe->pkt);
-#else /*  CONFIG_BSD_RX_USE_MBUF */
 		dev_kfree_skb_any(precvframe->pkt);	/* free skb by driver */
-#endif /*  CONFIG_BSD_RX_USE_MBUF */
 		precvframe->pkt = NULL;
 	}
 
@@ -957,7 +938,7 @@ static void count_rx_stats(struct rtw_ad
 	struct rx_pkt_attrib *pattrib = &prframe->attrib;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 
-	sz = get_recvframe_len(prframe);
+	sz = prframe->len;
 	precvpriv->rx_bytes += sz;
 
 	padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod++;
@@ -2911,7 +2892,6 @@ _recv_entry_drop:
 	return ret;
 }
 
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS)
 {
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
@@ -2992,4 +2972,3 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 	}
 	rtw_set_signal_stat_timer(recvpriv);
 }
-#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ b/drivers/staging/rtl8192du/core/rtw_tdls.c
@@ -950,11 +950,11 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, s
 		if ((ptdlsinfo->sta_maximum == true) && (ptdls_sta->alive_count >= 1)) {
 			if (_rtw_memcmp(ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN)) {
 				memcpy(ptdlsinfo->ss_record.macaddr, psa, ETH_ALEN);
-				ptdlsinfo->ss_record.RxPWDBAll = pattrib->RxPWDBAll;
+				ptdlsinfo->ss_record.rxpwdb_all = pattrib->rxpwdb_all;
 			} else {
-				if (ptdlsinfo->ss_record.RxPWDBAll < pattrib->RxPWDBAll) {
+				if (ptdlsinfo->ss_record.rxpwdb_all < pattrib->rxpwdb_all) {
 					memcpy(ptdlsinfo->ss_record.macaddr, psa, ETH_ALEN);
-					ptdlsinfo->ss_record.RxPWDBAll = pattrib->RxPWDBAll;
+					ptdlsinfo->ss_record.rxpwdb_all = pattrib->rxpwdb_all;
 				}
 			}
 	}
@@ -965,7 +965,7 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, s
 				/* All traffics are busy, do not set up another direct link. */
 				return _FAIL;
 			} else {
-				if (pattrib->RxPWDBAll > ptdlsinfo->ss_record.RxPWDBAll)
+				if (pattrib->rxpwdb_all > ptdlsinfo->ss_record.rxpwdb_all)
 					issue_tdls_teardown(adapter, ptdlsinfo->ss_record.macaddr);
 				else
 					return _FAIL;
@@ -974,9 +974,9 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, s
 
 		rtw_hal_get_def_var(adapter, HAL_DEF_UNDERCORATEDSMOOTHEDPWDB, &UndecoratedSmoothedPWDB);
 
-		if (pattrib->RxPWDBAll + TDLS_SIGNAL_THRESH >= UndecoratedSmoothedPWDB) {
-			DBG_871X("pattrib->RxPWDBAll =%d, pdmpriv->UndecoratedSmoothedPWDB =%d\n",
-				 pattrib->RxPWDBAll, UndecoratedSmoothedPWDB);
+		if (pattrib->rxpwdb_all + TDLS_SIGNAL_THRESH >= UndecoratedSmoothedPWDB) {
+			DBG_871X("pattrib->rxpwdb_all =%d, pdmpriv->UndecoratedSmoothedPWDB =%d\n",
+				 pattrib->rxpwdb_all, UndecoratedSmoothedPWDB);
 			issue_tdls_setup_req(adapter, psa);
 		}
 	}
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
@@ -180,8 +180,8 @@ static void query_rx_phy_status(struct r
 				pwdb_all -= 4;
 		}
 
-		pattrib->RxPWDBAll = pwdb_all;
-		pattrib->RecvSignalPower = rx_pwr_all;
+		pattrib->rxpwdb_all = pwdb_all;
+		pattrib->recvsignalpower = rx_pwr_all;
 		padapter->recvpriv.rxpwdb = rx_pwr_all;
 
 		/*  */
@@ -305,8 +305,8 @@ static void query_rx_phy_status(struct r
 
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("PWDB_ALL=%d\n",	pwdb_all));
 
-		pattrib->RxPWDBAll = pwdb_all;	/* for DIG/rate adaptive */
-		pattrib->RecvSignalPower = rx_pwr_all;
+		pattrib->rxpwdb_all = pwdb_all;	/* for DIG/rate adaptive */
+		pattrib->recvsignalpower = rx_pwr_all;
 		padapter->recvpriv.rxpwdb = rx_pwr_all;
 
 		/*  */
@@ -366,12 +366,9 @@ static void process_rssi(struct rtw_adap
 {
 	u32	last_rssi, tmp_val;
 	struct rx_pkt_attrib *pattrib = &prframe->attrib;
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	struct signal_stat * signal_stat = &padapter->recvpriv.signal_strength_data;
-#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 	{
-	#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 		if (signal_stat->update_req) {
 			signal_stat->total_num = 0;
 			signal_stat->total_val = 0;
@@ -381,26 +378,6 @@ static void process_rssi(struct rtw_adap
 		signal_stat->total_num++;
 		signal_stat->total_val  += pattrib->signal_strength;
 		signal_stat->avg_val = signal_stat->total_val / signal_stat->total_num;
-	#else /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
-
-		if (padapter->recvpriv.signal_strength_data.total_num++ >= PHY_RSSI_SLID_WIN_MAX)
-		{
-			padapter->recvpriv.signal_strength_data.total_num = PHY_RSSI_SLID_WIN_MAX;
-			last_rssi = padapter->recvpriv.signal_strength_data.elements[padapter->recvpriv.signal_strength_data.index];
-			padapter->recvpriv.signal_strength_data.total_val -= last_rssi;
-		}
-		padapter->recvpriv.signal_strength_data.total_val  +=pattrib->signal_strength;
-
-		padapter->recvpriv.signal_strength_data.elements[padapter->recvpriv.signal_strength_data.index++] = pattrib->signal_strength;
-		if (padapter->recvpriv.signal_strength_data.index >= PHY_RSSI_SLID_WIN_MAX)
-			padapter->recvpriv.signal_strength_data.index = 0;
-
-		tmp_val = padapter->recvpriv.signal_strength_data.total_val/padapter->recvpriv.signal_strength_data.total_num;
-		padapter->recvpriv.signal_strength= tmp_val;
-		padapter->recvpriv.rssi=(s8)translate2dbm((u8)tmp_val);
-
-		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("UI RSSI = %d, ui_rssi.TotalVal = %d, ui_rssi.TotalNum = %d\n", tmp_val, padapter->recvpriv.signal_strength_data.total_val,padapter->recvpriv.signal_strength_data.total_num));
-	#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 	}
 }/*  Process_UI_RSSI_8192S */
 
@@ -424,14 +401,14 @@ static void process_PWDB(struct rtw_adap
 	{
 		if (UndecoratedSmoothedPWDB == 0) /*  initialize */
 		{
-			UndecoratedSmoothedPWDB = pattrib->RxPWDBAll;
+			UndecoratedSmoothedPWDB = pattrib->rxpwdb_all;
 		}
 
-		if (pattrib->RxPWDBAll > (u32)UndecoratedSmoothedPWDB)
+		if (pattrib->rxpwdb_all > (u32)UndecoratedSmoothedPWDB)
 		{
 			UndecoratedSmoothedPWDB =
 					(((UndecoratedSmoothedPWDB)*(Rx_Smooth_Factor-1)) +
-					(pattrib->RxPWDBAll)) /(Rx_Smooth_Factor);
+					(pattrib->rxpwdb_all)) /(Rx_Smooth_Factor);
 
 			UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB + 1;
 		}
@@ -439,7 +416,7 @@ static void process_PWDB(struct rtw_adap
 		{
 			UndecoratedSmoothedPWDB =
 					(((UndecoratedSmoothedPWDB)*(Rx_Smooth_Factor-1)) +
-					(pattrib->RxPWDBAll)) /(Rx_Smooth_Factor);
+					(pattrib->rxpwdb_all)) /(Rx_Smooth_Factor);
 		}
 
 		if (psta)
@@ -458,20 +435,15 @@ static void process_link_qual(struct rtw
 {
 	u32	last_evm=0,  tmpVal;
 	struct rx_pkt_attrib *pattrib;
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	struct signal_stat * signal_stat;
-#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 	if (prframe == NULL || padapter==NULL) {
 		return;
 	}
 
 	pattrib = &prframe->attrib;
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	signal_stat = &padapter->recvpriv.signal_qual_data;
-#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	if (signal_stat->update_req) {
 		signal_stat->total_num = 0;
 		signal_stat->total_val = 0;
@@ -482,35 +454,6 @@ static void process_link_qual(struct rtw
 	signal_stat->total_val  += pattrib->signal_qual;
 	signal_stat->avg_val = signal_stat->total_val / signal_stat->total_num;
 
-#else /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
-	if (pattrib->signal_qual != 0)
-	{
-			/*  */
-			/*  1. Record the general EVM to the sliding window. */
-			/*  */
-			if (padapter->recvpriv.signal_qual_data.total_num++ >= PHY_LINKQUALITY_SLID_WIN_MAX)
-			{
-				padapter->recvpriv.signal_qual_data.total_num = PHY_LINKQUALITY_SLID_WIN_MAX;
-				last_evm = padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index];
-				padapter->recvpriv.signal_qual_data.total_val -= last_evm;
-			}
-			padapter->recvpriv.signal_qual_data.total_val += pattrib->signal_qual;
-
-			padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index++] = pattrib->signal_qual;
-			if (padapter->recvpriv.signal_qual_data.index >= PHY_LINKQUALITY_SLID_WIN_MAX)
-				padapter->recvpriv.signal_qual_data.index = 0;
-
-			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("Total SQ=%d  pattrib->signal_qual= %d\n", padapter->recvpriv.signal_qual_data.total_val, pattrib->signal_qual));
-
-			/*  <1> Showed on UI for user, in percentage. */
-			tmpVal = padapter->recvpriv.signal_qual_data.total_val/padapter->recvpriv.signal_qual_data.total_num;
-			padapter->recvpriv.signal_qual=(u8)tmpVal;
-	}
-	else
-	{
-		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" pattrib->signal_qual =%d\n", pattrib->signal_qual));
-	}
-#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 }/*  Process_UiLinkQuality8192S */
 
 static void process_phy_info(struct rtw_adapter *padapter, struct recv_frame_hdr *prframe)
--- a/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
@@ -48,31 +48,10 @@ int	rtl8192du_init_recv_priv(struct rtw_
 	int	i, res = _SUCCESS;
 	struct recv_buf *precvbuf;
 
-#ifdef CONFIG_RECV_THREAD_MODE
-	_rtw_init_sema(&precvpriv->recv_sema, 0);/* will be removed */
-	_rtw_init_sema(&precvpriv->terminate_recvthread_sema, 0);/* will be removed */
-#endif /* CONFIG_RECV_THREAD_MODE */
-
 	tasklet_init(&precvpriv->recv_tasklet,
 	     (void(*)(unsigned long))rtl8192du_recv_tasklet,
 	     (unsigned long)padapter);
 
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
-	_rtw_init_queue(&precvpriv->recv_buf_pending_queue);
-#endif	/*  CONFIG_USE_USB_BUFFER_ALLOC_RX */
-
-#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
-
-	precvpriv->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (precvpriv->int_in_urb == NULL) {
-		DBG_8192D("alloc_urb for interrupt in endpoint fail !!!!\n");
-	}
-	precvpriv->int_in_buf = kmalloc(sizeof(INTERRUPT_MSG_FORMAT_EX), GFP_KERNEL);
-	if (precvpriv->int_in_buf == NULL) {
-		DBG_8192D("alloc_mem for interrupt in endpoint fail !!!!\n");
-	}
-#endif /* CONFIG_USB_INTERRUPT_IN_PIPE */
-
 	/* init recv_buf */
 	_rtw_init_queue(&precvpriv->free_recv_buf_queue);
 
@@ -108,11 +87,6 @@ int	rtl8192du_init_recv_priv(struct rtw_
 	precvpriv->free_recv_buf_queue_cnt = NR_RECVBUFF;
 	skb_queue_head_init(&precvpriv->rx_skb_queue);
 
-#ifdef CONFIG_RX_INDICATE_QUEUE
-	memset(&precvpriv->rx_indicate_queue, 0, sizeof(struct ifqueue));
-	mtx_init(&precvpriv->rx_indicate_queue.ifq_mtx, "rx_indicate_queue", NULL, MTX_DEF);
-#endif	/*  CONFIG_RX_INDICATE_QUEUE */
-
 #ifdef CONFIG_PREALLOC_RECV_SKB
 	{
 		int i;
@@ -167,15 +141,8 @@ void rtl8192du_free_recv_priv (struct rt
 
 	kfree(precvpriv->pallocated_recv_buf);
 
-#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
-	if (precvpriv->int_in_urb)
-		usb_free_urb(precvpriv->int_in_urb);
-	kfree(precvpriv->int_in_buf);
-#endif
-
-	if (skb_queue_len(&precvpriv->rx_skb_queue)) {
+	if (skb_queue_len(&precvpriv->rx_skb_queue))
 		DBG_8192D(KERN_WARNING "rx_skb_queue not empty\n");
-	}
 
 	skb_queue_purge(&precvpriv->rx_skb_queue);
 
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -2822,9 +2822,6 @@ static unsigned int rtl8192du_inirp_init
 	struct intf_hdl * pintfhdl=&padapter->iopriv.intf;
 	struct recv_priv *precvpriv = &(padapter->recvpriv);
 	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
-#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
-	u32 (*_read_interrupt)(struct intf_hdl *pintfhdl, u32 addr);
-#endif
 
 	_read_port = pintfhdl->io_ops._read_port;
 
@@ -2849,19 +2846,9 @@ static unsigned int rtl8192du_inirp_init
 		precvpriv->free_recv_buf_queue_cnt--;
 	}
 
-#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
-	_read_interrupt = pintfhdl->io_ops._read_interrupt;
-	if (_read_interrupt(pintfhdl, RECV_INT_IN_ADDR) == false)
-	{
-		RT_TRACE(_module_hci_hal_init_c_,_drv_err_,("usb_rx_init: usb_read_interrupt error\n"));
-		status = _FAIL;
-	}
-#endif
-
 exit:
 
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("<=== usb_inirp_init\n"));
-
 	return status;
 }
 
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -359,81 +359,6 @@ static int usb_writeN(struct intf_hdl *p
 	return ret;
 }
 
-#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
-static void usb_read_interrupt_complete(struct urb *purb, struct pt_regs *regs)
-{
-	int	err;
-	struct rtw_adapter		*padapter = (struct rtw_adapter	 *)purb->context;
-
-	padapter->recvpriv.int_cnt ++;
-	if (purb->status==0)/* SUCCESS */
-	{
-		if (purb->actual_length > sizeof(INTERRUPT_MSG_FORMAT_EX))
-		{
-			DBG_8192D("usb_read_interrupt_complete: purb->actual_length > sizeof(INTERRUPT_MSG_FORMAT_EX)\n");
-		}
-
-		err = usb_submit_urb(purb, GFP_ATOMIC);
-		if ((err) && (err != (-EPERM)))
-		{
-			DBG_8192D("cannot submit interrupt in-token(err = 0x%08x),urb_status = %d\n",err, purb->status);
-		}
-	}
-	else
-	{
-		DBG_8192D("###=> usb_read_interrupt_complete => urb status(%d)\n", purb->status);
-
-		switch (purb->status) {
-			case -EINVAL:
-			case -EPIPE:
-			case -ENODEV:
-			case -ESHUTDOWN:
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
-			case -ENOENT:
-				padapter->bDriverStopped=true;
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
-				break;
-			case -EPROTO:
-				break;
-			case -EINPROGRESS:
-				DBG_8192D("ERROR: URB IS IN PROGRESS!/n");
-				break;
-			default:
-				break;
-		}
-	}
-}
-
-static u32 usb_read_interrupt(struct intf_hdl *pintfhdl, u32 addr)
-{
-	int	err, pipe;
-	u32	ret = _SUCCESS;
-	struct rtw_adapter			*adapter = pintfhdl->padapter;
-	struct dvobj_priv	*pdvobj = adapter_to_dvobj(adapter);
-	struct recv_priv	*precvpriv = &adapter->recvpriv;
-	struct usb_device	*pusbd = pdvobj->pusbdev;
-
-	/* translate DMA FIFO addr to pipehandle */
-	pipe = ffaddr2pipehdl(pdvobj, addr);
-
-	usb_fill_int_urb(precvpriv->int_in_urb, pusbd, pipe,
-					precvpriv->int_in_buf,
-					sizeof(INTERRUPT_MSG_FORMAT_EX),
-					usb_read_interrupt_complete,
-					adapter,
-					3);
-
-	err = usb_submit_urb(precvpriv->int_in_urb, GFP_ATOMIC);
-	if ((err) && (err != (-EPERM)))
-	{
-		DBG_8192D("cannot submit interrupt in-token(err = 0x%08x),urb_status = %d\n",err, precvpriv->int_in_urb->status);
-		ret = _FAIL;
-	}
-
-	return ret;
-}
-#endif
-
 static s32 pre_recv_entry(struct recv_frame_hdr *precvframe, struct recv_stat *prxstat, struct phy_stat *pphy_info)
 {
 	s32 ret=_SUCCESS;
@@ -554,331 +479,6 @@ static s32 pre_recv_entry(struct recv_fr
 	return ret;
 }
 
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
-static int recvbuf2recvframe(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
-{
-	u8	*pbuf;
-	u8	shift_sz = 0;
-	u16	pkt_cnt;
-	u32	pkt_offset, skb_len, alloc_sz;
-	int	transfer_len;
-	struct recv_stat	*prxstat;
-	struct phy_stat	*pphy_info = NULL;
-	struct sk_buff *pkt_copy = NULL;
-	struct recv_frame_hdr	*precvframe = NULL;
-	struct rx_pkt_attrib	*pattrib = NULL;
-	struct hal_data_8192du		*pHalData = GET_HAL_DATA(padapter);
-	struct recv_priv	*precvpriv = &padapter->recvpriv;
-	struct __queue *pfree_recv_queue = &precvpriv->free_recv_queue;
-
-	transfer_len = (s32)precvbuf->transfer_len;
-	pbuf = precvbuf->pbuf;
-
-	prxstat = (struct recv_stat *)pbuf;
-	pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
-
-	do{
-		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
-			 ("recvbuf2recvframe: rxdesc=offsset 0:0x%08x, 4:0x%08x, 8:0x%08x, C:0x%08x\n",
-			  prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4));
-
-		prxstat = (struct recv_stat *)pbuf;
-
-		precvframe = rtw_alloc_recvframe(pfree_recv_queue);
-		if (precvframe==NULL)
-		{
-			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: precvframe==NULL\n"));
-			DBG_8192D("%s()-%d: rtw_alloc_recvframe() failed! RX Drop!\n", __func__, __LINE__);
-			goto _exit_recvbuf2recvframe;
-		}
-
-		INIT_LIST_HEAD(&precvframe->list);
-		precvframe->precvbuf = NULL;	/* can't access the precvbuf for new arch. */
-		precvframe->len=0;
-
-		rtl8192d_query_rx_desc_status(precvframe, prxstat);
-
-		pattrib = &precvframe->attrib;
-		if (pattrib->physt)
-		{
-			pphy_info = (struct phy_stat *)(pbuf + RXDESC_OFFSET);
-		}
-
-		pkt_offset = RXDESC_SIZE + pattrib->drvinfo_sz + pattrib->shift_sz + pattrib->pkt_len;
-
-		if ((pattrib->pkt_len<=0) || (pkt_offset>transfer_len))
-		{
-			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: pkt_len<=0\n"));
-			DBG_8192D("%s()-%d: RX Warning!\n", __func__, __LINE__);
-			rtw_free_recvframe(precvframe, pfree_recv_queue);
-			goto _exit_recvbuf2recvframe;
-		}
-
-		/*	Modified by Albert 20101213 */
-		/*	For 8 bytes IP header alignment. */
-		if (pattrib->qos)	/*	Qos data, wireless lan header length is 26 */
-		{
-			shift_sz = 6;
-		}
-		else
-		{
-			shift_sz = 0;
-		}
-
-		skb_len = pattrib->pkt_len;
-
-		/*  for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet. */
-		/*  modify alloc_sz for recvive crc error packet by thomas 2011-06-02 */
-		if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)) {
-			if (skb_len <= 1650)
-				alloc_sz = 1664;
-			else
-				alloc_sz = skb_len + 14;
-		}
-		else {
-			alloc_sz = skb_len;
-			/*	6 is for IP header 8 bytes alignment in QoS packet case. */
-			/*	8 is for skb->data 4 bytes alignment. */
-			alloc_sz += 14;
-		}
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
-		pkt_copy = dev_alloc_skb(alloc_sz);
-#else
-		pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
-#endif
-		if (pkt_copy)
-		{
-			precvframe->pkt = pkt_copy;
-			precvframe->rx_head = pkt_copy->data;
-			precvframe->rx_end = pkt_copy->data + alloc_sz;
-			skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));/* force pkt_copy->data at 8-byte alignment address */
-			skb_reserve(pkt_copy, shift_sz);/* force ip_hdr at 8-byte alignment address according to shift_sz. */
-			memcpy(pkt_copy->data, (pbuf + pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE), skb_len);
-			precvframe->rx_data = precvframe->rx_tail = pkt_copy->data;
-		}
-		else
-		{
-			DBG_8192D("recvbuf2recvframe:can not allocate memory for skb copy\n");
-			/* precvframe->pkt = skb_clone(pskb, GFP_ATOMIC); */
-			/* precvframe->rx_head = precvframe->rx_data = precvframe->rx_tail = pbuf; */
-			/* precvframe->rx_end = pbuf + (pkt_offset>1612?pkt_offset:1612); */
-
-			precvframe->pkt = NULL;
-			rtw_free_recvframe(precvframe, pfree_recv_queue);
-
-			goto _exit_recvbuf2recvframe;
-		}
-
-		recvframe_put(precvframe, skb_len);
-		/* recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE); */
-
-#ifdef CONFIG_USB_RX_AGGREGATION
-		switch (pHalData->UsbRxAggMode)
-		{
-			case USB_RX_AGG_DMA:
-			case USB_RX_AGG_DMA_USB:
-				pkt_offset = (u16)_RND128(pkt_offset);
-				break;
-				case USB_RX_AGG_USB:
-				pkt_offset = (u16)_RND4(pkt_offset);
-				break;
-			case USB_RX_AGG_DISABLE:
-			default:
-				break;
-		}
-#endif
-
-#ifdef CONFIG_CONCURRENT_MODE
-		if (rtw_buddy_adapter_up(padapter))
-		{
-			if (pre_recv_entry(precvframe, prxstat, pphy_info) != _SUCCESS)
-			{
-				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: recv_entry(precvframe) != _SUCCESS\n"));
-			}
-		}
-		else
-		{
-			rtl8192d_translate_rx_signal_stuff(precvframe, pphy_info);
-			if (rtw_recv_entry(precvframe) != _SUCCESS)
-			{
-				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
-			}
-		}
-#else
-		rtl8192d_translate_rx_signal_stuff(precvframe, pphy_info);
-		if (rtw_recv_entry(precvframe) != _SUCCESS)
-		{
-			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
-		}
-#endif /* CONFIG_CONCURRENT_MODE */
-
-		pkt_cnt--;
-
-		transfer_len -= pkt_offset;
-		pbuf += pkt_offset;
-		precvframe = NULL;
-		pkt_copy = NULL;
-
-		if (transfer_len>0 && pkt_cnt==0)
-			pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
-
-	}while ((transfer_len>0) && (pkt_cnt>0));
-
-_exit_recvbuf2recvframe:
-
-	return _SUCCESS;
-}
-
-void rtl8192du_recv_tasklet(void *priv)
-{
-	struct recv_buf *precvbuf = NULL;
-	struct rtw_adapter	*padapter = (struct rtw_adapter*)priv;
-	struct recv_priv	*precvpriv = &padapter->recvpriv;
-
-	while (NULL != (precvbuf = rtw_dequeue_recvbuf(&precvpriv->recv_buf_pending_queue)))
-	{
-		if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
-		{
-			DBG_8192D("recv_tasklet => bDriverStopped or bSurpriseRemoved\n");
-
-			break;
-		}
-
-		recvbuf2recvframe(padapter, precvbuf);
-
-		rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-	}
-}
-
-static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
-{
-	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;
-	struct rtw_adapter			*padapter =(struct rtw_adapter *)precvbuf->adapter;
-	struct recv_priv	*precvpriv = &padapter->recvpriv;
-
-	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
-
-	precvpriv->rx_pending_cnt --;
-
-	if (padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));
-
-		goto exit;
-	}
-
-	if (purb->status==0)/* SUCCESS */
-	{
-		if ((purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE))
-		{
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n"));
-
-			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-		}
-		else
-		{
-			precvbuf->transfer_len = purb->actual_length;
-
-			/* rtw_enqueue_rx_transfer_buffer(precvpriv, rx_transfer_buf); */
-			rtw_enqueue_recvbuf(precvbuf, &precvpriv->recv_buf_pending_queue);
-
-			tasklet_schedule(&precvpriv->recv_tasklet);
-		}
-	}
-	else
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete : purb->status(%d) != 0\n", purb->status));
-
-		DBG_8192D("###=> usb_read_port_complete => urb status(%d)\n", purb->status);
-
-		switch (purb->status) {
-			case -EINVAL:
-			case -EPIPE:
-			case -ENODEV:
-			case -ESHUTDOWN:
-				/* padapter->bSurpriseRemoved=true; */
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
-			case -ENOENT:
-				padapter->bDriverStopped=true;
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
-				break;
-			case -EPROTO:
-			case -EOVERFLOW:
-				rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-				break;
-			case -EINPROGRESS:
-				DBG_8192D("ERROR: URB IS IN PROGRESS!/n");
-				break;
-			default:
-				break;
-		}
-
-	}
-
-exit:
-
-}
-
-static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
-{
-	int err, pipe;
-	u32 ret = _SUCCESS;
-	struct urb * purb = NULL;
-	struct recv_buf	*precvbuf = (struct recv_buf *)rmem;
-	struct rtw_adapter *adapter = pintfhdl->padapter;
-	struct dvobj_priv	*pdvobj = adapter_to_dvobj(adapter);
-	struct recv_priv	*precvpriv = &adapter->recvpriv;
-	struct usb_device	*pusbd = pdvobj->pusbdev;
-
-	if (adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:(padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
-		return _FAIL;
-	}
-
-	if (precvbuf !=NULL)
-	{
-		rtl8192du_init_recvbuf(adapter, precvbuf);
-
-		if (precvbuf->pbuf)
-		{
-			precvpriv->rx_pending_cnt++;
-
-			purb = precvbuf->purb;
-
-			/* translate DMA FIFO addr to pipehandle */
-			pipe = ffaddr2pipehdl(pdvobj, addr);
-
-			usb_fill_bulk_urb(purb, pusbd, pipe,
-						precvbuf->pbuf,
-						MAX_RECVBUF_SZ,
-						usb_read_port_complete,
-						precvbuf);/* context is precvbuf */
-
-			purb->transfer_dma = precvbuf->dma_transfer_addr;
-			purb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
-
-			err = usb_submit_urb(purb, GFP_ATOMIC);
-			if ((err) && (err != (-EPERM)))
-			{
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cannot submit rx in-token(err=0x%.8x), URB_STATUS =0x%.8x", err, purb->status));
-				DBG_8192D("cannot submit rx in-token(err = 0x%08x),urb_status = %d\n",err,purb->status);
-				ret = _FAIL;
-			}
-
-		}
-
-	}
-	else
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:precvbuf ==NULL\n"));
-		ret = _FAIL;
-	}
-
-	return ret;
-}
-#else	/*  CONFIG_USE_USB_BUFFER_ALLOC_RX */
 static int recvbuf2recvframe(struct rtw_adapter *padapter, struct sk_buff *pskb)
 {
 	u8	*pbuf;
@@ -1253,7 +853,6 @@ static u32 usb_read_port(struct intf_hdl
 
 	return ret;
 }
-#endif	/*  CONFIG_USE_USB_BUFFER_ALLOC_RX */
 
 void rtl8192du_xmit_tasklet(void *priv)
 {
@@ -1307,9 +906,4 @@ void rtl8192du_set_intf_ops(struct _io_o
 
 	pops->_read_port_cancel = &usb_read_port_cancel;
 	pops->_write_port_cancel = &usb_write_port_cancel;
-
-#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
-	pops->_read_interrupt = &usb_read_interrupt;
-#endif
-
 }
--- a/drivers/staging/rtl8192du/include/autoconf.h
+++ b/drivers/staging/rtl8192du/include/autoconf.h
@@ -90,7 +90,6 @@
 #define CONFIG_LAYER2_ROAMING
 #define CONFIG_LAYER2_ROAMING_RESUME
 /* define CONFIG_SET_SCAN_DENY_TIMER */
-#define CONFIG_NEW_SIGNAL_STAT_PROCESS
 #define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable,*/
 
 #define CONFIG_BR_EXT	1	/*  Enable NAT2.5 support for STA mode interface with a L2 Bridge */
@@ -106,10 +105,7 @@
 
 #define CONFIG_80211D
 
-/*
- * Interface  Related Config
- */
-/* define CONFIG_USB_INTERRUPT_IN_PIPE	1 */
+/* Interface  Related Config */
 
 #ifndef CONFIG_MINIMAL_MEMORY_USAGE
 	#define CONFIG_USB_TX_AGGREGATION	1
@@ -118,30 +114,15 @@
 
 #define CONFIG_PREALLOC_RECV_SKB	1
 
-
-
-/*
- * CONFIG_USE_USB_BUFFER_ALLOC_XX uses Linux USB Buffer alloc API and is for Linux platform only now!
- */
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
-#undef CONFIG_PREALLOC_RECV_SKB
-#endif
-
 /*
  * USB VENDOR REQ BUFFER ALLOCATION METHOD
  * if not set we'll use function local variable (stack memory)
  */
-/* define CONFIG_USB_VENDOR_REQ_BUFFER_DYNAMIC_ALLOCATE */
 #define CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
 
 #define CONFIG_USB_VENDOR_REQ_MUTEX
 
-/* define CONFIG_USB_SUPPORT_ASYNC_VDN_REQ 1 */
-
-
-/*
- * HAL  Related Config
- */
+/* HAL  Related Config */
 
 #define RTL8192C_RX_PACKET_NO_INCLUDE_CRC	1
 
--- a/drivers/staging/rtl8192du/include/rtw_mlme.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme.h
@@ -331,7 +331,7 @@ struct wifidirect_info{
 
 struct tdls_ss_record{	/* signal strength record; recording the tdls sta with lowerest ss */
 	u8		macaddr[ETH_ALEN];
-	u8		RxPWDBAll;
+	u8		rxpwdb_all;
 	u8		is_tdls_sta;	/*  true: direct link sta, false: else */
 };
 
--- a/drivers/staging/rtl8192du/include/rtw_recv.h
+++ b/drivers/staging/rtl8192du/include/rtw_recv.h
@@ -20,38 +20,37 @@
 #include <osdep_service.h>
 #include <drv_types.h>
 
+#define NR_RECVFRAME			256
 
-#define NR_RECVFRAME 256
-
-#define RXFRAME_ALIGN	8
+#define RXFRAME_ALIGN			8
 #define RXFRAME_ALIGN_SZ	(1<<RXFRAME_ALIGN)
 
-#define MAX_RXFRAME_CNT	512
-#define MAX_RX_NUMBLKS		(32)
-#define RECVFRAME_HDR_ALIGN 128
-
-#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+#define MAX_RXFRAME_CNT			512
+#define MAX_RX_NUMBLKS			32
+#define RECVFRAME_HDR_ALIGN		128
 
 static u8 SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};
 
 static u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};
-static u8 SNAP_ETH_TYPE_APPLETALK_DDP[2] = {0x80, 0x9b};
 static u8 SNAP_ETH_TYPE_TDLS[2] = {0x89, 0x0d};
-static u8 SNAP_HDR_APPLETALK_DDP[3] = {0x08, 0x00, 0x07}; /*  Datagram Delivery Protocol */
+static u8 SNAP_HDR_APPLETALK_DDP[3] = {
+	0x08, 0x00, 0x07
+}; /*  Datagram Delivery Protocol */
 
 static u8 oui_8021h[] = {0x00, 0x00, 0xf8};
-static u8 oui_rfc1042[]= {0x00,0x00,0x00};
+static u8 oui_rfc1042[] = {0x00, 0x00, 0x00};
 
-#define MAX_SUBFRAME_COUNT	64
-static u8 rtw_rfc1042_header[] =
-{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+#define MAX_SUBFRAME_COUNT		64
+static u8 rtw_rfc1042_header[] = {
+	0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00
+};
 /* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
-static u8 rtw_bridge_tunnel_header[] =
-{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
+static u8 rtw_bridge_tunnel_header[] = {
+	0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8
+};
 
 /* for Rx reordering buffer control */
-struct recv_reorder_ctrl
-{
+struct recv_reorder_ctrl {
 	struct rtw_adapter	*padapter;
 	u8 enable;
 	u16 indicate_seq;/* wstart_b, init_value=0xffff */
@@ -65,7 +64,6 @@ struct	stainfo_rxcache	{
 	u16	tid_rxseq[16];
 };
 
-
 struct smooth_rssi_data {
 	u32	elements[100];	/* array to store values */
 	u32	index;			/* index to current array to store */
@@ -98,27 +96,22 @@ struct rx_pkt_attrib {
 	u8	order;
 	u8	privacy; /* in frame_ctrl field */
 	u8	bdecrypted;
-	u8	encrypt; /* when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith */
+	u8	encrypt; /* when non-zero, indicate the encrypt algorith */
 	u8	iv_len;
 	u8	icv_len;
 	u8	crc_err;
 	u8	icv_err;
-
-	u16 eth_type;
-
+	u16	eth_type;
 	u8	dst[ETH_ALEN];
 	u8	src[ETH_ALEN];
 	u8	ta[ETH_ALEN];
 	u8	ra[ETH_ALEN];
 	u8	bssid[ETH_ALEN];
-
-	u8 ack_policy;
-
+	u8	ack_policy;
 	u8	tcpchk_valid; /*  0: invalid, 1: valid */
 	u8	ip_chkrpt; /* 0: incorrect, 1: correct */
 	u8	tcp_chkrpt; /* 0: incorrect, 1: correct */
 	u8	key_index;
-
 	u8	mcs_rate;
 	u8	rxht;
 	u8	sgi;
@@ -127,23 +120,21 @@ struct rx_pkt_attrib {
 	u8	signal_strength;
 	u8	rx_rssi[2];  /* This value is percentage */
 	u8	rx_snr[2];
-	u32	RxPWDBAll;
-	s32	RecvSignalPower;
+	u32	rxpwdb_all;
+	s32	recvsignalpower;
 };
 
-
 /* These definition is used for Rx packet reordering. */
-#define SN_LESS(a, b)		(((a-b)&0x800)!=0)
-#define SN_EQUAL(a, b)	(a == b)
+#define SN_LESS(a, b)		(((a - b) & 0x800) != 0)
+#define SN_EQUAL(a, b)		(a == b)
 #define REORDER_WAIT_TIME	(50) /*  (ms) */
 
-#define RECVBUFF_ALIGN_SZ 8
+#define RECVBUFF_ALIGN_SZ	8
 
-#define RXDESC_SIZE	24
-#define RXDESC_OFFSET RXDESC_SIZE
+#define RXDESC_SIZE		24
+#define RXDESC_OFFSET		RXDESC_SIZE
 
-struct recv_stat
-{
+struct recv_stat {
 	__le32 rxdw0;
 	__le32 rxdw1;
 	__le32 rxdw2;
@@ -152,33 +143,35 @@ struct recv_stat
 	__le32 rxdw5;
 };
 
-#define EOR BIT(30)
+#define EOR			BIT(30)
 
-/*
-accesser of recv_priv: rtw_recv_entry(dispatch / passive level); recv_thread(passive) ; returnpkt(dispatch)
-; halt(passive) ;
-
-using enter_critical section to protect
-*/
+/* accesser of recv_priv: rtw_recv_entry(dispatch / passive level);
+ * recv_thread(passive); returnpkt(dispatch); halt(passive);
+ *
+ * use enter_critical section to protect
+ */
 struct recv_priv {
-	  spinlock_t	lock;
-
-#ifdef CONFIG_RECV_THREAD_MODE
-	struct  semaphore recv_sema;
-	struct  semaphore terminate_recvthread_sema;
-#endif
-
 	struct __queue free_recv_queue;
 	struct __queue recv_pending_queue;
 	struct __queue uc_swdec_pending_queue;
+	struct rtw_adapter	*adapter;
+	struct  semaphore allrxreturnevt;
+	struct tasklet_struct irq_prepare_beacon_tasklet;
+	struct tasklet_struct recv_tasklet;
+	struct sk_buff_head free_recv_skb_queue;
+	struct sk_buff_head rx_skb_queue;
+	struct __queue free_recv_buf_queue;
+	struct timer_list signal_stat_timer;
+	struct signal_stat signal_qual_data;
+	struct signal_stat signal_strength_data;
+
+	spinlock_t lock;
 
 	u8 *pallocated_frame_buf;
 	u8 *precv_frame_buf;
 
 	uint free_recvframe_cnt;
 
-	struct rtw_adapter	*adapter;
-
 	u32	bIsAnyNonBEPkts;
 	u64	rx_bytes;
 	u64	rx_pkts;
@@ -190,32 +183,11 @@ struct recv_priv {
 	uint  rx_smallpacket_crcerr;
 	uint  rx_middlepacket_crcerr;
 
-	struct  semaphore allrxreturnevt;
 	uint	ff_hwaddr;
 	u8	rx_pending_cnt;
 
-#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
-	struct urb *	int_in_urb;
-
-	u8	*int_in_buf;
-#endif
-
-	struct tasklet_struct irq_prepare_beacon_tasklet;
-	struct tasklet_struct recv_tasklet;
-	struct sk_buff_head free_recv_skb_queue;
-	struct sk_buff_head rx_skb_queue;
-#ifdef CONFIG_RX_INDICATE_QUEUE
-	struct task rx_indicate_tasklet;
-	struct ifqueue rx_indicate_queue;
-#endif	/*  CONFIG_RX_INDICATE_QUEUE */
-
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
-	struct __queue recv_buf_pending_queue;
-#endif	/*  CONFIG_USE_USB_BUFFER_ALLOC_RX */
-
 	u8 *pallocated_recv_buf;
 	u8 *precv_buf;    /*  4 alignment */
-	struct __queue free_recv_buf_queue;
 	u32	free_recv_buf_queue_cnt;
 
 	/* For display the phy informatiom */
@@ -230,135 +202,109 @@ struct recv_priv {
 	s8 RxRssi[2];
 	int falsealmcnt_all;
 
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
-	struct timer_list signal_stat_timer;
 	u32 signal_stat_sampling_interval;
-	struct signal_stat signal_qual_data;
-	struct signal_stat signal_strength_data;
-#else /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
-	struct smooth_rssi_data signal_qual_data;
-	struct smooth_rssi_data signal_strength_data;
-#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 	u32 recvbuf_skb_alloc_fail_cnt;
 	u32 recvbuf_null_cnt;
 	u32 read_port_complete_EINPROGRESS_cnt;
 	u32 read_port_complete_other_urb_err_cnt;
-
-
 };
 
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
-#define rtw_set_signal_stat_timer(recvpriv) _set_timer(&(recvpriv)->signal_stat_timer, (recvpriv)->signal_stat_sampling_interval)
-#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
+#define rtw_set_signal_stat_timer(recvpriv)				\
+	_set_timer(&(recvpriv)->signal_stat_timer,			\
+		   (recvpriv)->signal_stat_sampling_interval)
 
 struct sta_recv_priv {
+	struct __queue defrag_q; /* keeping the fragment frame until defrag */
+	struct	stainfo_rxcache rxcache;
 	spinlock_t lock;
 	int	option;
-	struct __queue defrag_q;	 /* keeping the fragment frame until defrag */
-	struct	stainfo_rxcache rxcache;
 };
 
-
 struct recv_buf {
 	struct list_head list;
+	struct rtw_adapter *adapter;
+	struct urb *purb;
+	struct sk_buff *pskb;
+	dma_addr_t dma_transfer_addr;	/* (in) dma addr for transfer_buffer */
 
 	spinlock_t recvbuf_lock;
 
 	u32	ref_cnt;
-
-	struct rtw_adapter * adapter;
-
+	u32	len;
 	u8	*pbuf;
 	u8	*pallocated_buf;
 
-	u32	len;
 	u8	*phead;
 	u8	*pdata;
 	u8	*ptail;
 	u8	*pend;
-	struct urb *purb;
-	dma_addr_t dma_transfer_addr;	/* (in) dma addr for transfer_buffer */
-	u32 alloc_sz;
-	u8  irp_pending;
-	int  transfer_len;
-	struct sk_buff *pskb;
+	u32	alloc_sz;
+	u8	irp_pending;
+	int	transfer_len;
 	u8	reuse;
 };
 
-
-/*
-	head  ----->
-
-		data  ----->
-
-			payload
-
-		tail  ----->
-
-
-	end   ----->
-
-	len = (unsigned int)(tail - data);
-
-*/
+/*	head  ----->
+ *		data  ----->
+ *			payload
+ *		tail  ----->
+ *	end   ----->
+ *
+ *	len = (unsigned int)(tail - data);
+ */
 struct recv_frame_hdr {
 	struct list_head list;
-#ifndef CONFIG_BSD_RX_USE_MBUF
 	struct sk_buff	 *pkt;
 	struct sk_buff	 *pkt_newalloc;
-#else /*  CONFIG_BSD_RX_USE_MBUF */
-	struct sk_buff *pkt;
-	struct sk_buff *pkt_newalloc;
-#endif /*  CONFIG_BSD_RX_USE_MBUF */
-
 	struct rtw_adapter  *adapter;
+	struct rx_pkt_attrib attrib;
+	struct sta_info *psta;
+	/* for A-MPDU Rx reordering buffer control */
+	struct recv_reorder_ctrl *preorder_ctrl;
+	void *precvbuf;
 
 	u8 fragcnt;
 
 	int frame_tag;
 
-	struct rx_pkt_attrib attrib;
-
 	uint  len;
 	u8 *rx_head;
 	u8 *rx_data;
 	u8 *rx_tail;
 	u8 *rx_end;
-
-	void *precvbuf;
-
-
-	/*  */
-	struct sta_info *psta;
-
-	/* for A-MPDU Rx reordering buffer control */
-	struct recv_reorder_ctrl *preorder_ctrl;
-
 };
 
-struct recv_frame_hdr *_rtw_alloc_recvframe (struct __queue *pfree_recv_queue);  /* get a free recv_frame from pfree_recv_queue */
-struct recv_frame_hdr *rtw_alloc_recvframe (struct __queue *pfree_recv_queue);  /* get a free recv_frame from pfree_recv_queue */
-void rtw_init_recvframe(struct recv_frame_hdr *precvframe ,struct recv_priv *precvpriv);
-int	 rtw_free_recvframe(struct recv_frame_hdr *precvframe, struct __queue *pfree_recv_queue);
+/* get a free recv_frame from pfree_recv_queue */
+struct recv_frame_hdr *_rtw_alloc_recvframe(struct __queue *pfree_recv_queue);
+/* get a free recv_frame from pfree_recv_queue */
+struct recv_frame_hdr *rtw_alloc_recvframe(struct __queue *pfree_recv_queue);
+void rtw_init_recvframe(struct recv_frame_hdr *precvframe,
+			struct recv_priv *precvpriv);
+int rtw_free_recvframe(struct recv_frame_hdr *precvframe,
+		       struct __queue *pfree_recv_queue);
 
 #define rtw_dequeue_recvframe(queue) rtw_alloc_recvframe(queue)
-int _rtw_enqueue_recvframe(struct recv_frame_hdr *precvframe, struct __queue *queue);
-int rtw_enqueue_recvframe(struct recv_frame_hdr *precvframe, struct __queue *queue);
+int _rtw_enqueue_recvframe(struct recv_frame_hdr *precvframe,
+			   struct __queue *queue);
+int rtw_enqueue_recvframe(struct recv_frame_hdr *precvframe,
+			  struct __queue *queue);
 
-void rtw_free_recvframe_queue(struct __queue *pframequeue, struct __queue *pfree_recv_queue);
+void rtw_free_recvframe_queue(struct __queue *pframequeue,
+			      struct __queue *pfree_recv_queue);
 u32 rtw_free_uc_swdec_pending_queue(struct rtw_adapter *adapter);
 
-int rtw_enqueue_recvbuf_to_head(struct recv_buf *precvbuf, struct __queue *queue);
+int rtw_enqueue_recvbuf_to_head(struct recv_buf *precvbuf,
+				struct __queue *queue);
 int rtw_enqueue_recvbuf(struct recv_buf *precvbuf, struct __queue *queue);
-struct recv_buf *rtw_dequeue_recvbuf (struct __queue *queue);
+struct recv_buf *rtw_dequeue_recvbuf(struct __queue *queue);
 
 void rtw_reordering_ctrl_timeout_handler(void *pcontext);
 
 static inline u8 *get_rxmem(struct recv_frame_hdr *precvframe)
 {
 	/* always return rx_head... */
-	if (precvframe==NULL)
+	if (precvframe == NULL)
 		return NULL;
 
 	return precvframe->rx_head;
@@ -366,83 +312,67 @@ static inline u8 *get_rxmem(struct recv_
 
 static inline u8 *get_rx_status(struct recv_frame_hdr *precvframe)
 {
-
 	return get_rxmem(precvframe);
-
 }
 
 static inline u8 *get_recvframe_data(struct recv_frame_hdr *precvframe)
 {
-
 	/* alwasy return rx_data */
-	if (precvframe==NULL)
+	if (precvframe == NULL)
 		return NULL;
 
 	return precvframe->rx_data;
-
 }
 
 static inline u8 *recvframe_push(struct recv_frame_hdr *precvframe, int sz)
 {
-	/*  append data before rx_data */
-
-	/* add data to the start of recv_frame
+/*  append data before rx_data
+ * add data to the start of recv_frame
  *
  *      This function extends the used data area of the recv_frame at the buffer
  *      start. rx_data must be still larger than rx_head, after pushing.
  */
-
-	if (precvframe==NULL)
+	if (precvframe == NULL)
 		return NULL;
-
-
-	precvframe->rx_data -= sz ;
-	if (precvframe->rx_data < precvframe->rx_head)
-	{
-		precvframe->rx_data += sz ;
+	precvframe->rx_data -= sz;
+	if (precvframe->rx_data < precvframe->rx_head) {
+		precvframe->rx_data += sz;
 		return NULL;
 	}
-
-	precvframe->len +=sz;
-
+	precvframe->len += sz;
 	return precvframe->rx_data;
-
 }
 
-
 static inline u8 *recvframe_pull(struct recv_frame_hdr *precvframe, int sz)
 {
-	/*  rx_data += sz; move rx_data sz bytes  hereafter */
-
-	/* used for extract sz bytes from rx_data, update rx_data and return the updated rx_data to the caller */
-
-
-	if (precvframe==NULL)
+/*  rx_data += sz; move rx_data sz bytes  hereafter
+ * used for extract sz bytes from rx_data, update rx_data and return the
+ * updated rx_data to the caller
+ */
+	if (precvframe == NULL)
 		return NULL;
 
 
 	precvframe->rx_data += sz;
 
-	if (precvframe->rx_data > precvframe->rx_tail)
-	{
+	if (precvframe->rx_data > precvframe->rx_tail) {
 		precvframe->rx_data -= sz;
 		return NULL;
 	}
 
-	precvframe->len -=sz;
+	precvframe->len -= sz;
 
 	return precvframe->rx_data;
-
 }
 
 static inline u8 *recvframe_put(struct recv_frame_hdr *precvframe, int sz)
 {
-	/*  rx_tai += sz; move rx_tail sz bytes  hereafter */
-
-	/* used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller */
-	/* after putting, rx_tail must be still larger than rx_end. */
-
-	if (precvframe==NULL)
+/*  rx_tai += sz; move rx_tail sz bytes  hereafter
+ * used for append sz bytes from ptr to rx_tail, update rx_tail and return
+ * the updated rx_tail to the caller
+ * after putting, rx_tail must be still larger than rx_end.
+ */
+	if (precvframe == NULL)
 		return NULL;
 
 	precvframe->rx_tail += sz;
@@ -452,96 +382,67 @@ static inline u8 *recvframe_put(struct r
 		return NULL;
 	}
 
-	precvframe->len +=sz;
+	precvframe->len += sz;
 
 	return precvframe->rx_tail;
 }
 
-
-
 static inline u8 *recvframe_pull_tail(struct recv_frame_hdr *precvframe, int sz)
 {
-	/*  rmv data from rx_tail (by yitsen) */
-
-	/* used for extract sz bytes from rx_end, update rx_end and return the updated rx_end to the caller */
-	/* after pulling, rx_end must be still larger than rx_data. */
-
-	if (precvframe==NULL)
+/*  rmv data from rx_tail
+ * used for extract sz bytes from rx_end, update rx_end and return the
+ * updated rx_end to the caller
+ * after pulling, rx_end must be still larger than rx_data.
+ */
+	if (precvframe == NULL)
 		return NULL;
 
 	precvframe->rx_tail -= sz;
 
-	if (precvframe->rx_tail < precvframe->rx_data)
-	{
+	if (precvframe->rx_tail < precvframe->rx_data) {
 		precvframe->rx_tail += sz;
 		return NULL;
 	}
 
-	precvframe->len -=sz;
+	precvframe->len -= sz;
 
 	return precvframe->rx_tail;
-
 }
 
-
-
 static inline unsigned char *get_rxbuf_desc(struct recv_frame_hdr *precvframe)
 {
 	unsigned char *buf_desc;
 
-	if (precvframe==NULL)
+	if (precvframe == NULL)
 		return NULL;
 	return buf_desc;
 }
 
-
-static inline struct recv_frame_hdr *rxmem_to_recvframe(u8 *rxmem)
-{
-	/* due to the design of 2048 bytes alignment of recv_frame, we can reference the struct recv_frame_hdr */
-	/* from any given member of recv_frame. */
-	/*  rxmem indicates the any member/address in recv_frame */
-
-	return (struct recv_frame_hdr*)(((SIZE_PTR)rxmem >> RXFRAME_ALIGN) << RXFRAME_ALIGN);
-
-}
-
-static inline int get_recvframe_len(struct recv_frame_hdr *precvframe)
-{
-	return precvframe->len;
-}
-
 static inline u8 query_rx_pwr_percentage(s8 antpower)
 {
 	if ((antpower <= -100) || (antpower >= 20))
-	{
 		return	0;
-	}
 	else if (antpower >= 0)
-	{
 		return	100;
-	}
 	else
-	{
-		return	(100+antpower);
-	}
+		return	100+antpower;
 }
 
-static inline s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)
+static inline s32 translate_percentage_to_dbm(u32 index)
 {
-	s32	SignalPower; /*  in dBm. */
+	s32	power; /*  in dBm. */
 
 	/*  Translate to dBm (x=0.5y-95). */
-	SignalPower = (s32)((SignalStrengthIndex + 1) >> 1);
-	SignalPower -= 95;
+	power = (s32)((index + 1) >> 1);
+	power -= 95;
 
-	return SignalPower;
+	return power;
 }
 
-
 struct sta_info;
 
 void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv);
-
-void  mgt_dispatcher(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+void  mgt_dispatcher(struct rtw_adapter *padapter,
+		     struct recv_frame_hdr *precv_frame);
 
 #endif
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -1004,12 +1004,6 @@ u32 rtw_start_drv_threads(struct rtw_ada
 		_status = _FAIL;
 #endif
 
-#ifdef CONFIG_RECV_THREAD_MODE
-	padapter->recvThread = kthread_run(rtw_recv_thread, padapter, "RTW_RECV_THREAD");
-	if (IS_ERR(padapter->recvThread))
-		_status = _FAIL;
-#endif
-
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->isprimary == true)
 #endif /* CONFIG_CONCURRENT_MODE */
@@ -1058,17 +1052,8 @@ void rtw_stop_drv_threads (struct rtw_ad
 	_rtw_down_sema(&padapter->xmitpriv.terminate_xmitthread_sema);
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("\n drv_halt: rtw_xmit_thread can be terminated !\n"));
 #endif
-
-#ifdef CONFIG_RECV_THREAD_MODE
-	/*  Below is to termindate rx_thread... */
-	_rtw_up_sema(&padapter->recvpriv.recv_sema);
-	_rtw_down_sema(&padapter->recvpriv.terminate_recvthread_sema);
-	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("\n drv_halt:recv_thread can be terminated!\n"));
-#endif
-
 }
 
-u8 rtw_init_default_value(struct rtw_adapter *padapter);
 u8 rtw_init_default_value(struct rtw_adapter *padapter)
 {
 	u8 ret  = _SUCCESS;
@@ -1170,10 +1155,7 @@ u8 rtw_reset_drv_sw(struct rtw_adapter *
 	/* mlmeextpriv */
 	padapter->mlmeextpriv.sitesurvey_res.state = SCAN_DISABLE;
 
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	rtw_set_signal_stat_timer(&padapter->recvpriv);
-#endif
-
 	return ret8;
 }
 
@@ -1326,9 +1308,7 @@ void rtw_cancel_all_timer(struct rtw_ada
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel set_scan_deny_timer!\n"));
 #endif
 
-#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	_cancel_timer_ex(&padapter->recvpriv.signal_stat_timer);
-#endif
 
 	/*  cancel dm  timer */
 	rtw_hal_dm_deinit(padapter);
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -76,12 +76,6 @@ int rtw_os_recvbuf_resource_alloc(struct
 
 	precvbuf->len = 0;
 
-	#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
-	precvbuf->pallocated_buf = rtw_usb_buffer_alloc(pusbd, (size_t)precvbuf->alloc_sz, GFP_ATOMIC, &precvbuf->dma_transfer_addr);
-	precvbuf->pbuf = precvbuf->pallocated_buf;
-	if (precvbuf->pallocated_buf == NULL)
-		return _FAIL;
-	#endif /* CONFIG_USE_USB_BUFFER_ALLOC_RX */
 	return res;
 }
 
@@ -90,21 +84,8 @@ int rtw_os_recvbuf_resource_free(struct
 {
 	int ret = _SUCCESS;
 
-#ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
-
-	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
-	struct usb_device	*pusbd = pdvobjpriv->pusbdev;
-
-	rtw_usb_buffer_free(pusbd, (size_t)precvbuf->alloc_sz, precvbuf->pallocated_buf, precvbuf->dma_transfer_addr);
-	precvbuf->pallocated_buf =  NULL;
-	precvbuf->dma_transfer_addr = 0;
-
-#endif /* CONFIG_USE_USB_BUFFER_ALLOC_RX */
-
 	if (precvbuf->purb)
-	{
 		usb_free_urb(precvbuf->purb);
-	}
 
 	if (precvbuf->pskb)
 		dev_kfree_skb_any(precvbuf->pskb);
--- a/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
@@ -260,18 +260,13 @@ void usb_read_port_cancel(struct intf_hd
 
 	padapter->bReadPortCancel = true;
 
-	for (i=0; i < NR_RECVBUFF ; i++) {
+	for (i = 0; i < NR_RECVBUFF; i++) {
 
 		precvbuf->reuse = true;
-		if (precvbuf->purb)	 {
+		if (precvbuf->purb)
 			usb_kill_urb(precvbuf->purb);
-		}
 		precvbuf++;
 	}
-
-#ifdef CONFIG_USB_INTERRUPT_IN_PIPE
-	usb_kill_urb(padapter->recvpriv.int_in_urb);
-#endif
 }
 
 static void usb_write_port_complete(struct urb *purb, struct pt_regs *regs)

From d3604ed5480ad77940c729e604247b0d2d30d25f Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sat, 4 May 2013 20:30:26 -0500
Subject: [PATCH 126/390] Convert "}else", "else{" and "){" to correct for

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_ioctl_set.c    |  48 +++++-----
 core/rtw_mlme.c         |  38 ++++----
 core/rtw_mlme_ext.c     |  32 +++----
 core/rtw_p2p.c          |   6 +-
 core/rtw_pwrctrl.c      |  14 +--
 core/rtw_recv.c         |  72 +++++++-------
 core/rtw_security.c     |  54 +++++------
 core/rtw_sreset.c       |   4 +-
 core/rtw_sta_mgt.c      |   6 +-
 core/rtw_tdls.c         | 140 +++++++++++++--------------
 core/rtw_wlan_util.c    |   2 +-
 core/rtw_xmit.c         |  72 +++++++-------
 hal/hal_intf.c          |  20 ++--
 hal/rtl8192d_cmd.c      |  12 +--
 hal/rtl8192d_dm.c       |  12 +--
 hal/rtl8192d_hal_init.c | 138 +++++++++++++--------------
 hal/rtl8192d_mp.c       |   2 +-
 hal/rtl8192d_phycfg.c   | 100 ++++++++++----------
 hal/rtl8192d_rf6052.c   |   2 +-
 hal/rtl8192d_rxdesc.c   |   4 +-
 hal/rtl8192du_recv.c    |   6 +-
 hal/rtl8192du_xmit.c    |   8 +-
 hal/usb_halinit.c       | 246 ++++++++++++++++++++++++------------------------
 hal/usb_ops_linux.c     |  16 ++--
 include/generic.h       |   2 +-
 include/osdep_intf.h    |   4 +-
 include/rtw_sreset.h    |   8 +-
 os_dep/ioctl_cfg80211.c |  24 ++---
 os_dep/ioctl_linux.c    | 150 ++++++++++++++---------------
 os_dep/mlme_linux.c     |   2 +-
 os_dep/os_intfs.c       |  10 +-
 os_dep/osdep_service.c  |   4 +-
 os_dep/recv_linux.c     |   2 +-
 os_dep/rtw_android.c    |   2 +-
 os_dep/usb_intf.c       |  10 +-
 35 files changed, 636 insertions(+), 636 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -53,7 +53,7 @@ _func_enter_;
 	for (i = 0; i < ssid->SsidLength; i++)
 	{
 		//wifi, printable ascii code must be supported
-		if (!((ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e))){
+		if (!((ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e))) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid has nonprintabl ascii\n"));
 			ret= false;
 			break;
@@ -187,7 +187,7 @@ _func_enter_;
 				)
 				{
 					//DBG_8192D("rtw_do_join() when   no desired bss in scanning queue\n");
-					if (_SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0))){
+					if (_SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0))) {
 						RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("do_join(): site survey return error\n."));
 					}
 				}
@@ -317,7 +317,7 @@ _func_enter_;
 		 ("+rtw_set_802_11_ssid: ssid=[%s] fw_state=0x%08x\n",
 		  ssid->Ssid, get_fwstate(pmlmepriv)));
 
-	if (padapter->hw_init_completed==false){
+	if (padapter->hw_init_completed==false) {
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 			 ("set_ssid: hw_init_completed==false=>exit!!!\n"));
 		status = _FAIL;
@@ -564,7 +564,7 @@ _func_enter_;
 		res=false;
 		goto exit;
 	}
-	if (padapter->hw_init_completed==false){
+	if (padapter->hw_init_completed==false) {
 		res = false;
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n===rtw_set_802_11_bssid_list_scan:hw_init_completed==false===\n"));
 		goto exit;
@@ -577,7 +577,7 @@ _func_enter_;
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_bssid_list_scan fail since fw_state = %x\n", get_fwstate(pmlmepriv)));
 		res = true;
 
-		if (check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))== true){
+		if (check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))== true) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n###_FW_UNDER_SURVEY|_FW_UNDER_LINKING\n\n"));
 		} else {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n###pmlmepriv->sitesurveyctrl.traffic_busy==true\n\n"));
@@ -631,7 +631,7 @@ _func_exit_;
 	return ret;
 }
 
-u8 rtw_set_802_11_add_wep(struct rtw_adapter* padapter, struct ndis_802_11_wep *wep){
+u8 rtw_set_802_11_add_wep(struct rtw_adapter* padapter, struct ndis_802_11_wep *wep) {
 	u8		bdefaultkey;
 	u8		btransmitkey;
 	int		keyid,res;
@@ -693,12 +693,12 @@ _func_exit_;
 	return ret;
 }
 
-u8 rtw_set_802_11_remove_wep(struct rtw_adapter* padapter, u32 keyindex){
+u8 rtw_set_802_11_remove_wep(struct rtw_adapter* padapter, u32 keyindex) {
 	u8 ret=_SUCCESS;
 
 _func_enter_;
 
-	if (keyindex >= 0x80000000 || padapter == NULL){
+	if (keyindex >= 0x80000000 || padapter == NULL) {
 		ret=false;
 		goto exit;
 
@@ -707,7 +707,7 @@ _func_enter_;
 	{
 		int res;
 		struct security_priv* psecuritypriv=&(padapter->securitypriv);
-		if (keyindex < 4){
+		if (keyindex < 4) {
 			memset(&psecuritypriv->dot11DefKey[keyindex], 0, 16);
 
 			res=rtw_set_key(padapter,psecuritypriv,keyindex, 0);
@@ -732,7 +732,7 @@ _func_exit_;
 	return ret;
 }
 
-u8 rtw_set_802_11_add_key(struct rtw_adapter* padapter, struct ndis_802_11_key *key){
+u8 rtw_set_802_11_add_key(struct rtw_adapter* padapter, struct ndis_802_11_key *key) {
 	uint	encryptionalgo;
 	u8 * pbssid;
 	struct sta_info *stainfo;
@@ -742,7 +742,7 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 
 _func_enter_;
 
-	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)){
+	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)) {
 		// It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination,
 		// it must fail the request and return NDIS_STATUS_INVALID_DATA.
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_add_key: ((key->KeyIndex & 0x80000000) == 0)[=%d] ",(int)(key->KeyIndex & 0x80000000) == 0));
@@ -761,11 +761,11 @@ _func_enter_;
 		pbssid=get_bssid(&padapter->mlmepriv);
 		stainfo=rtw_get_stainfo(&padapter->stapriv, pbssid);
 
-		if ((stainfo!=NULL)&&(padapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)){
+		if ((stainfo!=NULL)&&(padapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY:(stainfo!=NULL)&&(Adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)\n"));
 			encryptionalgo=stainfo->dot118021XPrivacy;
 		}
-		else{
+		else {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: stainfo==NULL)||(Adapter->securitypriv.dot11AuthAlgrthm!=dot11AuthAlgrthm_8021X)\n"));
 			encryptionalgo=padapter->securitypriv.dot11PrivacyAlgrthm;
 		}
@@ -774,11 +774,11 @@ _func_enter_;
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (Adapter->securitypriv.dot11PrivacyAlgrthm ==%d)!\n",padapter->securitypriv.dot11PrivacyAlgrthm));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (Adapter->securitypriv.dot11AuthAlgrthm ==%d)!\n",padapter->securitypriv.dot11AuthAlgrthm));
 
-		if ((stainfo!=NULL)){
+		if ((stainfo!=NULL)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (stainfo->dot118021XPrivacy ==%d)!\n", stainfo->dot118021XPrivacy));
 		}
 
-		if (key->KeyIndex & 0x000000FF){
+		if (key->KeyIndex & 0x000000FF) {
 			// The key index is specified in the lower 8 bits by values of zero to 255.
 			// The key index should be set to zero for a Pairwise key, and the driver should fail with
 			// NDIS_STATUS_INVALID_DATA if the lower 8 bits is not zero
@@ -788,7 +788,7 @@ _func_enter_;
 		}
 
 		// check BSSID
-		if (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == true){
+		if (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == true) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("MacAddr_isBcst(key->BSSID)\n"));
 			ret= false;
 			goto exit;
@@ -796,7 +796,7 @@ _func_enter_;
 
 		// Check key length for TKIP.
 		//if (encryptionAlgorithm == RT_ENC_TKIP_ENCRYPTION && key->KeyLength != 32)
-		if ((encryptionalgo== _TKIP_)&& (key->KeyLength != 32)){
+		if ((encryptionalgo== _TKIP_)&& (key->KeyLength != 32)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("TKIP KeyLength:0x%x != 32\n", key->KeyLength));
 			ret=_FAIL;
 			goto exit;
@@ -946,7 +946,7 @@ _func_enter_;
 
 	}
 
-	if (key->KeyIndex & 0x20000000){
+	if (key->KeyIndex & 0x20000000) {
 		// SetRSC
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ SetRSC+++++\n"));
 		if (bgroup == true)
@@ -973,7 +973,7 @@ _func_enter_;
 			padapter->securitypriv.dot118021XGrpKeyid=(u8)key->KeyIndex;
 		}
 
-		if ((key->KeyIndex&0x3) == 0){
+		if ((key->KeyIndex&0x3) == 0) {
 			ret = _FAIL;
 			goto exit;
 		}
@@ -1050,7 +1050,7 @@ _func_enter_;
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n ==========_set_timer\n"));
 
 				// if TKIP, save the Receive/Transmit MIC key in KeyMaterial[128-255]
-				if ((key->KeyIndex & 0x10000000)){
+				if ((key->KeyIndex & 0x10000000)) {
 					memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 16, 8);
 					memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 24, 8);
 
@@ -1072,7 +1072,7 @@ _func_enter_;
 				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, false);
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(group)\n"));
 			}
-			else{
+			else {
 				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, true);
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(unicast)\n"));
 			}
@@ -1091,7 +1091,7 @@ _func_exit_;
 	return ret;
 }
 
-u8 rtw_set_802_11_remove_key(struct rtw_adapter*	padapter, struct ndis_802_11_remove_key *key){
+u8 rtw_set_802_11_remove_key(struct rtw_adapter*	padapter, struct ndis_802_11_remove_key *key) {
 	uint				encryptionalgo;
 	u8 * pbssid;
 	struct sta_info *stainfo;
@@ -1118,7 +1118,7 @@ _func_enter_;
 	} else {
 		pbssid=get_bssid(&padapter->mlmepriv);
 		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid);
-		if (stainfo !=NULL){
+		if (stainfo !=NULL) {
 			encryptionalgo=stainfo->dot118021XPrivacy;
 
 		// clear key by BSSID
@@ -1127,7 +1127,7 @@ _func_enter_;
 		//! \todo Send a H2C Command to Firmware for disable this Key in CAM Entry.
 
 		}
-		else{
+		else {
 			ret= _FAIL;
 			goto exit;
 		}
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -73,7 +73,7 @@ _func_enter_;
 
 	pbuf = rtw_zvmalloc(MAX_BSS_CNT * (sizeof(struct wlan_network)));
 
-	if (pbuf == NULL){
+	if (pbuf == NULL) {
 		res=_FAIL;
 		goto exit;
 	}
@@ -151,7 +151,7 @@ _func_enter_;
 
 	rtw_free_mlme_priv_ie_data(pmlmepriv);
 
-	if (pmlmepriv){
+	if (pmlmepriv) {
 		rtw_mfree_mlme_priv_lock (pmlmepriv);
 
 		if (pmlmepriv->free_bss_buf) {
@@ -326,7 +326,7 @@ struct wlan_network *_rtw_find_network(s
 
 _func_enter_;
 
-	if (_rtw_memcmp(zero_addr, addr, ETH_ALEN)){
+	if (_rtw_memcmp(zero_addr, addr, ETH_ALEN)) {
 		pnetwork=NULL;
 		goto exit;
 	}
@@ -397,7 +397,7 @@ int rtw_if_up(struct rtw_adapter *padapt
 _func_enter_;
 
 	if (padapter->bDriverStopped || padapter->bSurpriseRemoved ||
-		(check_fwstate(&padapter->mlmepriv, _FW_LINKED)== false)){
+		(check_fwstate(&padapter->mlmepriv, _FW_LINKED)== false)) {
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_if_up:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
 		res=false;
 	}
@@ -791,7 +791,7 @@ _func_enter_;
 
 			pnetwork = rtw_alloc_network(pmlmepriv); // will update scan_time
 
-			if (pnetwork==NULL){
+			if (pnetwork==NULL) {
 				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n\n\nsomething wrong here\n\n\n"));
 				goto exit;
 			}
@@ -1134,7 +1134,7 @@ _func_enter_;
 #endif
 	{
 		struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
-		if (pmlmeext->sitesurvey_res.bss_cnt == 0){
+		if (pmlmeext->sitesurvey_res.bss_cnt == 0) {
 			rtw_hal_sreset_reset(adapter);
 		}
 	}
@@ -1642,14 +1642,14 @@ _func_enter_;
 					if (pcur_wlan)	pcur_wlan->fixed = false;
 
 					pcur_sta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
-					if (pcur_sta){
+					if (pcur_sta) {
 						spin_lock_bh(&(pstapriv->sta_hash_lock));
 						rtw_free_stainfo(adapter,  pcur_sta);
 						spin_unlock_bh(&(pstapriv->sta_hash_lock));
 					}
 
 					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
-					if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true){
+					if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {
 						if (ptarget_wlan)	ptarget_wlan->fixed = true;
 					}
 				}
@@ -1658,7 +1658,7 @@ _func_enter_;
 			else
 			{
 				ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
-				if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true){
+				if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {
 					if (ptarget_wlan)	ptarget_wlan->fixed = true;
 				}
 			}
@@ -2359,7 +2359,7 @@ static int rtw_check_join_candidate(stru
 		updated = true;
 	}
 
-	if (updated){
+	if (updated) {
 		DBG_8192D("[by_bssid:%u][assoc_ssid:%s]"
 			#ifdef  CONFIG_LAYER2_ROAMING
 			"[to_roaming:%u] "
@@ -2411,7 +2411,7 @@ _func_enter_;
 
 	while (!rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) {
 		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
-		if (pnetwork==NULL){
+		if (pnetwork==NULL) {
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s return _FAIL:(pnetwork==NULL)\n", __func__));
 			ret = _FAIL;
 			goto exit;
@@ -2476,13 +2476,13 @@ int rtw_set_auth(struct rtw_adapter * ad
 _func_enter_;
 
 	pcmd = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if (pcmd==NULL){
+	if (pcmd==NULL) {
 		res= _FAIL;  //try again
 		goto exit;
 	}
 
 	psetauthparm=(struct setauth_parm*)rtw_zmalloc(sizeof(struct setauth_parm));
-	if (psetauthparm==NULL){
+	if (psetauthparm==NULL) {
 		kfree(pcmd);
 		res= _FAIL;
 		goto exit;
@@ -2524,12 +2524,12 @@ int rtw_set_key(struct rtw_adapter * ada
 _func_enter_;
 
 	pcmd = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if (pcmd==NULL){
+	if (pcmd==NULL) {
 		res= _FAIL;  //try again
 		goto exit;
 	}
 	psetkeyparm=(struct setkey_parm*)rtw_zmalloc(sizeof(struct setkey_parm));
-	if (psetkeyparm==NULL){
+	if (psetkeyparm==NULL) {
 		kfree(pcmd);
 		res= _FAIL;
 		goto exit;
@@ -2537,11 +2537,11 @@ _func_enter_;
 
 	memset(psetkeyparm, 0, sizeof(struct setkey_parm));
 
-	if (psecuritypriv->dot11AuthAlgrthm ==dot11AuthAlgrthm_8021X){
+	if (psecuritypriv->dot11AuthAlgrthm ==dot11AuthAlgrthm_8021X) {
 		psetkeyparm->algorithm=(unsigned char)psecuritypriv->dot118021XGrpPrivacy;
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key: psetkeyparm->algorithm=(unsigned char)psecuritypriv->dot118021XGrpPrivacy=%d\n", psetkeyparm->algorithm));
 	}
-	else{
+	else {
 		psetkeyparm->algorithm=(u8)psecuritypriv->dot11PrivacyAlgrthm;
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key: psetkeyparm->algorithm=(u8)psecuritypriv->dot11PrivacyAlgrthm=%d\n", psetkeyparm->algorithm));
 
@@ -2559,7 +2559,7 @@ _func_enter_;
 	DBG_8192D("==> rtw_set_key algorithm(%x),keyid(%x),key_mask(%x)\n",psetkeyparm->algorithm,psetkeyparm->keyid,pmlmepriv->key_mask);
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key: psetkeyparm->algorithm=%d psetkeyparm->keyid=(u8)keyid=%d\n",psetkeyparm->algorithm, keyid));
 
-	switch (psetkeyparm->algorithm){
+	switch (psetkeyparm->algorithm) {
 		case _WEP40_:
 			keylen=5;
 			memcpy(&(psetkeyparm->key[0]), &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);
@@ -2701,7 +2701,7 @@ static int rtw_append_pmkid(struct rtw_a
 {
 	struct security_priv *psecuritypriv=&Adapter->securitypriv;
 
-	if (ie[13]<=20){
+	if (ie[13]<=20) {
 		// The RSN IE didn't include the PMK ID, append the PMK information
 			ie[ie_len]=1;
 			ie_len++;
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -260,7 +260,7 @@ static struct rt_channel_plan_map RTW_CH
 int rtw_ch_set_search_ch(struct rt_channel_info *ch_set, const u32 ch)
 {
 	int i;
-	for (i=0;ch_set[i].ChannelNum!=0;i++){
+	for (i=0;ch_set[i].ChannelNum!=0;i++) {
 		if (ch == ch_set[i].ChannelNum)
 			break;
 	}
@@ -637,7 +637,7 @@ void mgt_dispatcher(struct rtw_adapter *
 	index = GetFrameSubType(pframe) >> 4;
 
 #ifdef CONFIG_TDLS
-	if ((index << 4)==WIFI_ACTION){
+	if ((index << 4)==WIFI_ACTION) {
 		//category==RTW_WLAN_CATEGORY_PUBLIC, action==TDLS_DISCOVERY_RESPONSE
 		if (*(pframe + IEEE80211_MGMT_HDR_LEN) == RTW_WLAN_CATEGORY_PUBLIC
 			&& *(pframe + IEEE80211_MGMT_HDR_LEN + 1) == TDLS_DISCOVERY_RESPONSE)
@@ -7290,7 +7290,7 @@ void issue_assocreq(struct rtw_adapter *
 						//Commented by Kurt 20110629
 						//In some older APs, WPS handshake
 						//would be fail if we append vender extensions informations to AP
-						if (_rtw_memcmp(pIE->data, WPS_OUI, 4)){
+						if (_rtw_memcmp(pIE->data, WPS_OUI, 4)) {
 							pIE->Length=14;
 						}
 					}
@@ -8483,7 +8483,7 @@ void site_survey(struct rtw_adapter *pad
 			#endif //CONFIG_P2P
 			{
 				int i;
-				for (i=0;i<RTW_SSID_SCAN_AMOUNT;i++){
+				for (i=0;i<RTW_SSID_SCAN_AMOUNT;i++) {
 					if (pmlmeext->sitesurvey_res.ssid[i].SsidLength) {
 						//todo: to issue two probe req???
 						issue_probereq(padapter, &(pmlmeext->sitesurvey_res.ssid[i]), NULL);
@@ -10679,7 +10679,7 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 		pmlmeext->sitesurvey_res.bss_cnt = 0;
 		pmlmeext->sitesurvey_res.channel_idx = 0;
 
-		for (i=0;i<RTW_SSID_SCAN_AMOUNT;i++){
+		for (i=0;i<RTW_SSID_SCAN_AMOUNT;i++) {
 			if (pparm->ssid[i].SsidLength) {
 				memcpy(pmlmeext->sitesurvey_res.ssid[i].Ssid, pparm->ssid[i].Ssid, IW_ESSID_MAX_SIZE);
 				pmlmeext->sitesurvey_res.ssid[i].SsidLength= pparm->ssid[i].SsidLength;
@@ -10932,7 +10932,7 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 	ctrl = BIT(15) | ((pparm->algorithm) << 2);
 
 #ifdef CONFIG_TDLS
-	if (ptdlsinfo->clear_cam!=0){
+	if (ptdlsinfo->clear_cam!=0) {
 		clear_cam_entry(padapter, ptdlsinfo->clear_cam);
 		ptdlsinfo->clear_cam=0;
 
@@ -10940,7 +10940,7 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 	}
 
 	psta = rtw_get_stainfo(pstapriv, pparm->addr);//Get TDLS Peer STA
-	if (psta->tdls_sta_state&TDLS_LINKED_STATE){
+	if (psta->tdls_sta_state&TDLS_LINKED_STATE) {
 		write_cam(padapter, psta->mac_id, ctrl, pparm->addr, pparm->key);
 	}
 	else
@@ -12219,7 +12219,7 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 	//spin_lock_bh(&(ptdlsinfo->hdl_lock));
 	DBG_8192D("[%s] option:%d\n", __func__, option);
 
-	switch (option){
+	switch (option) {
 		case TDLS_WRCR:
 			//As long as TDLS handshake success, we should set RCR_CBSSID_DATA bit to 0
 			//such we can receive all kinds of data frames.
@@ -12251,22 +12251,22 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 			break;
 		case TDLS_DONE_CH_SEN:
 			survey_channel = pmlmeext->channel_set[pmlmeext->sitesurvey_res.channel_idx].ChannelNum;
-			if (survey_channel){
+			if (survey_channel) {
 				SelectChannel(padapter, survey_channel);
 				ptdlsinfo->cur_channel = survey_channel;
 				pmlmeext->sitesurvey_res.channel_idx++;
 				_set_timer(&ptdls_sta->option_timer, SURVEY_TO);
-			}else{
+			} else {
 				SelectChannel(padapter, pmlmeext->cur_channel);
 
 				rtw_hal_set_hwreg(padapter, HW_VAR_TDLS_DONE_CH_SEN, 0);
 
-				if (ptdlsinfo->ch_sensing==1){
+				if (ptdlsinfo->ch_sensing==1) {
 					ptdlsinfo->ch_sensing=0;
 					ptdlsinfo->cur_channel=1;
 					min=ptdlsinfo->collect_pkt_num[0];
-					for (i=1; i<MAX_CHANNEL_NUM-1; i++){
-						if (min > ptdlsinfo->collect_pkt_num[i]){
+					for (i=1; i<MAX_CHANNEL_NUM-1; i++) {
+						if (min > ptdlsinfo->collect_pkt_num[i]) {
 							ptdlsinfo->cur_channel=i+1;
 							min=ptdlsinfo->collect_pkt_num[i];
 						}
@@ -12279,9 +12279,9 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 
 				}
 
-				if (ptdls_sta->tdls_sta_state & TDLS_PEER_SLEEP_STATE){
+				if (ptdls_sta->tdls_sta_state & TDLS_PEER_SLEEP_STATE) {
 					ptdls_sta->tdls_sta_state |= TDLS_APSD_CHSW_STATE;
-				}else{
+				} else {
 					//send null data with pwrbit==1 before send ch_switching_req to peer STA.
 					issue_nulldata(padapter, NULL, 1, 0, 0);
 
@@ -12324,7 +12324,7 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 			SelectChannel(padapter, ptdls_sta->off_ch);
 			DBG_8192D("change channel to off ch:%02x\n", ptdls_sta->off_ch);
 			ptdls_sta->tdls_sta_state |= TDLS_AT_OFF_CH_STATE;
-			if ((ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE) != TDLS_PEER_AT_OFF_STATE){
+			if ((ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE) != TDLS_PEER_AT_OFF_STATE) {
 				issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 0);
 			}
 			_set_timer(&ptdls_sta->base_ch_timer, TDLS_STAY_TIME);
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -3489,7 +3489,7 @@ _func_enter_;
 
 			pmlmeext->cur_channel = pbuddy_mlmeext->cur_channel;
 
-		}else
+		} else
 #endif //CONFIG_CONCURRENT_MODE
 		if (pcfg80211_wdinfo->restore_channel != pmlmeext->cur_channel)
 		{
@@ -4218,13 +4218,13 @@ _func_enter_;
 	if (enqueue)
 	{
 		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-		if (ph2c==NULL){
+		if (ph2c==NULL) {
 			res= _FAIL;
 			goto exit;
 		}
 
 		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
-		if (pdrvextra_cmd_parm==NULL){
+		if (pdrvextra_cmd_parm==NULL) {
 			kfree(ph2c);
 			res= _FAIL;
 			goto exit;
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -76,8 +76,8 @@ int ips_leave(struct rtw_adapter * padap
 		{
 			DBG_8192D("==>%s,channel(%d),processing(%x)\n",__func__,padapter->mlmeextpriv.cur_channel,pwrpriv->bips_processing);
 			set_channel_bwmode(padapter, padapter->mlmeextpriv.cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-			for (keyid=0;keyid<4;keyid++){
-				if (pmlmepriv->key_mask & BIT(keyid)){
+			for (keyid=0;keyid<4;keyid++) {
+				if (pmlmepriv->key_mask & BIT(keyid)) {
 					if (keyid == psecuritypriv->dot11PrivacyKeyIndex)
 						result=rtw_set_key(padapter,psecuritypriv, keyid, 1);
 					else
@@ -405,7 +405,7 @@ _func_enter_;
 	}
 
 	if ((pwrpriv->pwr_mode == ps_mode) &&
-		(pwrpriv->smart_ps == smart_ps)){
+		(pwrpriv->smart_ps == smart_ps)) {
 		return;
 	}
 
@@ -1285,7 +1285,7 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 	if (padapter->pbuddy_adapter)
 		LeaveAllPowerSaveMode(padapter->pbuddy_adapter);
 
-	if ((padapter->isprimary == false) && padapter->pbuddy_adapter){
+	if ((padapter->isprimary == false) && padapter->pbuddy_adapter) {
 		padapter = padapter->pbuddy_adapter;
 		pwrpriv = &padapter->pwrctrlpriv;
 		pmlmepriv = &padapter->mlmepriv;
@@ -1320,7 +1320,7 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 	}
 
 	//System suspend is not allowed to wakeup
-	if ((pwrpriv->bInternalAutoSuspend == false) && (true == pwrpriv->bInSuspend)){
+	if ((pwrpriv->bInternalAutoSuspend == false) && (true == pwrpriv->bInSuspend)) {
 		ret = _FAIL;
 		goto exit;
 	}
@@ -1376,7 +1376,7 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 	if (padapter->bDriverStopped
 		|| !padapter->bup
 		|| !padapter->hw_init_completed
-	){
+	) {
 		DBG_8192D("%s: bDriverStopped=%d, bup=%d, hw_init_completed=%u\n"
 			, caller
 			, padapter->bDriverStopped
@@ -1430,7 +1430,7 @@ int rtw_pm_set_ips(struct rtw_adapter *p
 		DBG_8192D("%s %s\n", __func__, mode == IPS_NORMAL?"IPS_NORMAL":"IPS_LEVEL_2");
 		return 0;
 	}
-	else if (mode ==IPS_NONE){
+	else if (mode ==IPS_NONE) {
 		rtw_ips_mode_req(pwrctrlpriv, mode);
 		DBG_8192D("%s %s\n", __func__, "IPS_NONE");
 		if ((padapter->bSurpriseRemoved ==0)&&(_FAIL == rtw_pwr_wakeup(padapter)))
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -79,7 +79,7 @@ _func_enter_;
 
 	precvpriv->pallocated_frame_buf = rtw_zvmalloc(NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
 
-	if (precvpriv->pallocated_frame_buf==NULL){
+	if (precvpriv->pallocated_frame_buf==NULL) {
 		res= _FAIL;
 		goto exit;
 	}
@@ -191,7 +191,7 @@ _func_enter_;
 
 		rtw_list_delete(&precvframe->u.hdr.list);
 		padapter=precvframe->u.hdr.adapter;
-		if (padapter !=NULL){
+		if (padapter !=NULL) {
 			precvpriv=&padapter->recvpriv;
 			if (pfree_recv_queue == &precvpriv->free_recv_queue)
 				precvpriv->free_recvframe_cnt--;
@@ -255,7 +255,7 @@ _func_enter_;
 
 	rtw_list_insert_tail(&(precvframe->u.hdr.list), get_list_head(pfree_recv_queue));
 
-	if (padapter !=NULL){
+	if (padapter !=NULL) {
 		if (pfree_recv_queue == &precvpriv->free_recv_queue)
 				precvpriv->free_recvframe_cnt++;
 	}
@@ -412,7 +412,7 @@ struct recv_buf *rtw_dequeue_recvbuf(str
 }
 
 int recvframe_chkmic(struct rtw_adapter *adapter,  union recv_frame *precvframe);
-int recvframe_chkmic(struct rtw_adapter *adapter,  union recv_frame *precvframe){
+int recvframe_chkmic(struct rtw_adapter *adapter,  union recv_frame *precvframe) {
 	int	i,res=_SUCCESS;
 	u32	datalen;
 	u8	miccode[8];
@@ -458,7 +458,7 @@ _func_enter_;
 					goto exit;
 				}
 			}
-			else{
+			else {
 				mickey=&stainfo->dot11tkiprxmickey.skey[0];
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n recvframe_chkmic: unicast key\n"));
 			}
@@ -477,15 +477,15 @@ _func_enter_;
 
 			bmic_err=false;
 
-			for (i=0;i<8;i++){
-				if (miccode[i] != *(pframemic+i)){
+			for (i=0;i<8;i++) {
+				if (miccode[i] != *(pframemic+i)) {
 					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvframe_chkmic:miccode[%d](%02x) != *(pframemic+%d)(%02x) ",i,miccode[i],i,*(pframemic+i)));
 					bmic_err=true;
 				}
 			}
 
 
-			if (bmic_err==true){
+			if (bmic_err==true) {
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n *(pframemic-8)-*(pframemic-1)=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
 					*(pframemic-8),*(pframemic-7),*(pframemic-6),*(pframemic-5),*(pframemic-4),*(pframemic-3),*(pframemic-2),*(pframemic-1)));
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n *(pframemic-16)-*(pframemic-9)=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
@@ -494,7 +494,7 @@ _func_enter_;
 				{
 					uint i;
 					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n ======demp packet (len=%d)======\n",precvframe->u.hdr.len));
-					for (i=0;i<precvframe->u.hdr.len;i=i+8){
+					for (i=0;i<precvframe->u.hdr.len;i=i+8) {
 						RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x",
 							*(precvframe->u.hdr.rx_data+i),*(precvframe->u.hdr.rx_data+i+1),
 							*(precvframe->u.hdr.rx_data+i+2),*(precvframe->u.hdr.rx_data+i+3),
@@ -524,9 +524,9 @@ _func_enter_;
 				res=_FAIL;
 
 			}
-			else{
+			else {
 				//mic checked ok
-				if ((psecuritypriv->bcheck_grpkey ==false)&&(IS_MCAST(prxattrib->ra)==true)){
+				if ((psecuritypriv->bcheck_grpkey ==false)&&(IS_MCAST(prxattrib->ra)==true)) {
 					psecuritypriv->bcheck_grpkey =true;
 					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("psecuritypriv->bcheck_grpkey =true"));
 				}
@@ -570,7 +570,7 @@ _func_enter_;
 		{
 			DBG_8192D("prxattrib->key_index(%d) > WEP_KEYS\n", prxattrib->key_index);
 
-			switch (prxattrib->encrypt){
+			switch (prxattrib->encrypt) {
 				case _WEP40_:
 				case _WEP104_:
 					prxattrib->key_index = psecuritypriv->dot11PrivacyKeyIndex;
@@ -596,7 +596,7 @@ _func_enter_;
 			, prxattrib->bdecrypted ,prxattrib->encrypt, psecuritypriv->hw_decrypted);
 		#endif
 
-		switch (prxattrib->encrypt){
+		switch (prxattrib->encrypt) {
 		case _WEP40_:
 		case _WEP104_:
 			rtw_wep_decrypt(padapter, (u8 *)precv_frame);
@@ -700,13 +700,13 @@ _func_enter_;
 
 			prtnframe=precv_frame;
 			//check is the EAPOL frame or not (Rekey)
-			if (ether_type == eapol_type){
+			if (ether_type == eapol_type) {
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("########portctrl:ether_type == 0x888e\n"));
 				//check Rekey
 
 				prtnframe=precv_frame;
 			}
-			else{
+			else {
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("########portctrl:ether_type = 0x%.4x\n",ether_type));
 			}
 		}
@@ -901,7 +901,7 @@ int OnTDLS(struct rtw_adapter *adapter,
 		return ret;
 	}
 
-	switch (*paction){
+	switch (*paction) {
 		case TDLS_SETUP_REQUEST:
 			DBG_8192D("recv tdls setup request frame\n");
 			ret=On_TDLS_Setup_Req(adapter, precv_frame);
@@ -979,7 +979,7 @@ void count_rx_stats(struct rtw_adapter *
 
 	padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod++;
 
-	if ((!MacAddr_isBcst(pattrib->dst)) && (!IS_MCAST(pattrib->dst))){
+	if ((!MacAddr_isBcst(pattrib->dst)) && (!IS_MCAST(pattrib->dst))) {
 		padapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod++;
 	}
 
@@ -1031,13 +1031,13 @@ _func_enter_;
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))
 	{
 		// filter packets that SA is myself or multicast or broadcast
-		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
+		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)) {
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" SA==myself\n"));
 			ret= _FAIL;
 			goto exit;
 		}
 
-		if ((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))	&& (!bmcast)){
+		if ((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))	&& (!bmcast)) {
 			ret= _FAIL;
 			goto exit;
 		}
@@ -1056,7 +1056,7 @@ _func_enter_;
 	{
 #ifdef CONFIG_TDLS
 		//direct link data transfer
-		if (ptdlsinfo->setup_state == TDLS_LINKED_STATE){
+		if (ptdlsinfo->setup_state == TDLS_LINKED_STATE) {
 			ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->src);
 			if (ptdls_sta==NULL)
 			{
@@ -1076,7 +1076,7 @@ _func_enter_;
 					}
 				}
 				// filter packets that SA is myself or multicast or broadcast
-				if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
+				if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)) {
 					ret= _FAIL;
 					goto exit;
 				}
@@ -1123,7 +1123,7 @@ _func_enter_;
 					goto exit;
 				}
 				//receive some of all TDLS management frames, process it at ON_TDLS
-				if ((_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_TDLS, 2))){
+				if ((_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_TDLS, 2))) {
 					ret= OnTDLS(adapter, precv_frame);
 					goto exit;
 				}
@@ -1152,7 +1152,7 @@ _func_enter_;
 		if (bmcast)
 		{
 			// For AP mode, if DA == MCAST, then BSSID should be also MCAST
-			if (!IS_MCAST(pattrib->bssid)){
+			if (!IS_MCAST(pattrib->bssid)) {
 					ret= _FAIL;
 					goto exit;
 			}
@@ -1238,7 +1238,7 @@ _func_enter_;
 		)
 	{
 		// filter packets that SA is myself or multicast or broadcast
-		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
+		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)) {
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" SA==myself\n"));
 			#ifdef DBG_RX_DROP_FRAME
 			DBG_8192D("DBG_RX_DROP_FRAME %s SA=%x:%x:%x:%x:%x:%x, myhwaddr= %x:%x:%x:%x:%x:%x\n", __func__,
@@ -1655,7 +1655,7 @@ _func_enter_;
 	psa = get_sa(ptr);
 	pbssid = get_hdr_bssid(ptr);
 
-	if (pbssid == NULL){
+	if (pbssid == NULL) {
 		ret= _FAIL;
 		goto exit;
 	}
@@ -1698,7 +1698,7 @@ _func_enter_;
 
 	}
 
-	if (ret ==_FAIL){
+	if (ret ==_FAIL) {
 		#ifdef DBG_RX_DROP_FRAME
 		DBG_8192D("DBG_RX_DROP_FRAME %s case:%d, res:%d\n", __func__, pattrib->to_fr_ds, ret);
 		#endif
@@ -1708,7 +1708,7 @@ _func_enter_;
 	}
 
 
-	if (psta==NULL){
+	if (psta==NULL) {
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" after to_fr_ds_chk; psta==NULL\n"));
 		ret= _FAIL;
 		goto exit;
@@ -1756,7 +1756,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	if (pattrib->privacy){
+	if (pattrib->privacy) {
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("validate_recv_data_frame:pattrib->privacy=%x\n", pattrib->privacy));
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n ^^^^^^^^^^^IS_MCAST(pattrib->ra(0x%02x))=%d^^^^^^^^^^^^^^^6\n", pattrib->ra[0],IS_MCAST(pattrib->ra)));
 
@@ -1821,13 +1821,13 @@ _func_enter_;
 #endif
 
 #ifdef CONFIG_TDLS
-	if (ptdlsinfo->ch_sensing==1 && ptdlsinfo->cur_channel !=0){
+	if (ptdlsinfo->ch_sensing==1 && ptdlsinfo->cur_channel !=0) {
 		ptdlsinfo->collect_pkt_num[ptdlsinfo->cur_channel-1]++;
 	}
 #endif //CONFIG_TDLS
 
 	//add version chk
-	if (ver!=0){
+	if (ver!=0) {
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_data_frame fail! (ver!=0)\n"));
 		retval= _FAIL;
 		goto exit;
@@ -1904,7 +1904,7 @@ int wlanhdr_to_ethhdr (union recv_frame
 
 _func_enter_;
 
-	if (pattrib->encrypt){
+	if (pattrib->encrypt) {
 		recvframe_pull_tail(precvframe, pattrib->icv_len);
 	}
 
@@ -1916,7 +1916,7 @@ _func_enter_;
 		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == false) &&
 		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2)==false))||
 		//eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
-		 _rtw_memcmp(psnap, rtw_bridge_tunnel_header, SNAP_SIZE)){
+		 _rtw_memcmp(psnap, rtw_bridge_tunnel_header, SNAP_SIZE)) {
 		/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
 		bsnaphdr = true;
 	}
@@ -2274,7 +2274,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 		}
 	}
 
-	for (i=0; i<nr_subframes; i++){
+	for (i=0; i<nr_subframes; i++) {
 		sub_skb = subframes[i];
 		/* convert hdr + possible LLC headers into Ethernet header */
 #ifdef ENDIAN_FREE
@@ -2680,7 +2680,7 @@ int recv_indicatepkt_reorder(struct rtw_
 				preorder_ctrl->indicate_seq, pattrib->seq_num);
 			#endif
 
-			if (retval != _SUCCESS){
+			if (retval != _SUCCESS) {
 				#ifdef DBG_RX_DROP_FRAME
 				DBG_8192D("DBG_RX_DROP_FRAME %s amsdu_to_msdu fail\n", __func__);
 				#endif
@@ -2940,7 +2940,7 @@ int recv_func_posthandle(struct rtw_adap
 	pcategory = psnap_type + ETH_TYPE_LEN + PAYLOAD_TYPE_LEN;
 
 	if ((_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_TDLS, ETH_TYPE_LEN)) &&
-		((*pcategory==RTW_WLAN_CATEGORY_TDLS) || (*pcategory==RTW_WLAN_CATEGORY_P2P))){
+		((*pcategory==RTW_WLAN_CATEGORY_TDLS) || (*pcategory==RTW_WLAN_CATEGORY_P2P))) {
 		ret = OnTDLS(padapter, prframe);	//all of functions will return _FAIL
 		goto _exit_recv_func;
 	}
@@ -3141,7 +3141,7 @@ _func_exit_;
 }
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
-void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS){
+void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS) {
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
 	struct recv_priv *recvpriv = &adapter->recvpriv;
 
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -112,7 +112,7 @@ static void crc32_init(void)
 _func_enter_;
 	if (bcrc32initialized == 1)
 		goto exit;
-	else{
+	else {
 		int i, j;
 		u32 c;
 		u8 *p=(u8 *)&c, *p1;
@@ -123,7 +123,7 @@ _func_enter_;
 		for (i = 0; i < 256; ++i)
 		{
 			k = crc32_reverseBit((u8)i);
-			for (c = ((u32)k) << 24, j = 8; j > 0; --j){
+			for (c = ((u32)k) << 24, j = 8; j > 0; --j) {
 				c = c & 0x80000000 ? (c << 1) ^ CRC32_POLY : (c << 1);
 			}
 			p1 = (u8 *)&crc32_table[i];
@@ -402,14 +402,14 @@ _func_enter_;
 	priority[0]=pri;
 
 	/* Michael MIC pseudo header: DA, SA, 3 x 0, Priority */
-	if (header[1]&1){   //ToDS==1
+	if (header[1]&1) {   //ToDS==1
 			rtw_secmicappend(&micdata, &header[16], 6);  //DA
 		if (header[1]&2)  //From Ds==1
 			rtw_secmicappend(&micdata, &header[24], 6);
 		else
 			rtw_secmicappend(&micdata, &header[10], 6);
 	}
-	else{	//ToDS==0
+	else {	//ToDS==0
 		rtw_secmicappend(&micdata, &header[4], 6);   //DA
 		if (header[1]&2)  //From Ds==1
 			rtw_secmicappend(&micdata, &header[16], 6);
@@ -669,7 +669,7 @@ _func_enter_;
 #endif
 
 	//4 start to encrypt each fragment
-	if (pattrib->encrypt==_TKIP_){
+	if (pattrib->encrypt==_TKIP_) {
 		if (pattrib->psta)
 		{
 			stainfo = pattrib->psta;
@@ -679,7 +679,7 @@ _func_enter_;
 			stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0]);
 		}
 
-		if (stainfo!=NULL){
+		if (stainfo!=NULL) {
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_encrypt: stainfo!=NULL!!!\n"));
 
 			if (IS_MCAST(pattrib->ra))
@@ -693,7 +693,7 @@ _func_enter_;
 
 			prwskeylen=16;
 
-			for (curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
+			for (curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++) {
 				iv=pframe+pattrib->hdrlen;
 				payload=pframe+pattrib->iv_len+pattrib->hdrlen;
 
@@ -706,7 +706,7 @@ _func_enter_;
 
 				phase2(&rc4key[0],prwskey,(u16 *)&ttkey[0],pnl);
 
-				if ((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
+				if ((curfragnum+1)==pattrib->nr_frags) {	//4 the last fragment
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
 					RT_TRACE(_module_rtl871x_security_c_,_drv_info_,("pattrib->iv_len =%x, pattrib->icv_len =%x\n", pattrib->iv_len,pattrib->icv_len));
 					*((u32 *)crc)=cpu_to_le32(getcrc32(payload,length));/* modified by Amy*/
@@ -716,7 +716,7 @@ _func_enter_;
 					arcfour_encrypt(&mycontext, payload+length, crc, 4);
 
 				}
-				else{
+				else {
 					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
 					*((u32 *)crc)=cpu_to_le32(getcrc32(payload,length));/* modified by Amy*/
 					arcfour_init(&mycontext,rc4key,16);
@@ -731,7 +731,7 @@ _func_enter_;
 
 
 		}
-		else{
+		else {
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_encrypt: stainfo==NULL!!!\n"));
 			res=_FAIL;
 		}
@@ -767,9 +767,9 @@ _func_enter_;
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
 
 	//4 start to decrypt recvframe
-	if (prxattrib->encrypt==_TKIP_){
+	if (prxattrib->encrypt==_TKIP_) {
 		stainfo=rtw_get_stainfo(&padapter->stapriv ,&prxattrib->ta[0]);
-		if (stainfo!=NULL){
+		if (stainfo!=NULL) {
 			if (IS_MCAST(prxattrib->ra))
 			{
 				if (psecuritypriv->binstallGrpkey==false)
@@ -818,7 +818,7 @@ _func_enter_;
 
 
 		}
-		else{
+		else {
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_decrypt: stainfo==NULL!!!\n"));
 			res=_FAIL;
 		}
@@ -1336,7 +1336,7 @@ _func_enter_;
 		(frtype == WIFI_DATA_CFACKPOLL))
 		{
 			qc_exists = 1;
-					if (hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+					if (hdrlen !=  WLAN_HDR_A3_QOS_LEN) {
 					hdrlen += 2;
 			}
 		}
@@ -1346,7 +1346,7 @@ _func_enter_;
 		(frsubtype == 0x0a)||
 		(frsubtype == 0x0b))
 		{
-			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN) {
 					hdrlen += 2;
 			}
 			qc_exists = 1;
@@ -1514,7 +1514,7 @@ _func_enter_;
 #endif
 
 	//4 start to encrypt each fragment
-	if ((pattrib->encrypt==_AES_)){
+	if ((pattrib->encrypt==_AES_)) {
 		if (pattrib->psta)
 		{
 			stainfo = pattrib->psta;
@@ -1524,7 +1524,7 @@ _func_enter_;
 			stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0]);
 		}
 
-		if (stainfo!=NULL){
+		if (stainfo!=NULL) {
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_encrypt: stainfo!=NULL!!!\n"));
 
 			if (IS_MCAST(pattrib->ra))
@@ -1550,13 +1550,13 @@ _func_enter_;
 
 			prwskeylen=16;
 
-			for (curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
-				if ((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
+			for (curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++) {
+				if ((curfragnum+1)==pattrib->nr_frags) {	//4 the last fragment
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
 
 					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
 				}
-				else{
+				else {
 					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
 
 					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
@@ -1568,7 +1568,7 @@ _func_enter_;
 
 
 		}
-		else{
+		else {
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_encrypt: stainfo==NULL!!!\n"));
 			res=_FAIL;
 		}
@@ -1640,7 +1640,7 @@ _func_enter_;
 		(frtype == WIFI_DATA_CFACKPOLL))
 		{
 			qc_exists = 1;
-					if (hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+					if (hdrlen !=  WLAN_HDR_A3_QOS_LEN) {
 					hdrlen += 2;
 			}
 		}
@@ -1650,7 +1650,7 @@ _func_enter_;
 		(frsubtype == 0x0a)||
 		(frsubtype == 0x0b))
 		{
-			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+			if (hdrlen !=  WLAN_HDR_A3_QOS_LEN) {
 					hdrlen += 2;
 			}
 			qc_exists = 1;
@@ -1832,7 +1832,7 @@ _func_enter_;
     for (j=0; j<8;j++) message[payload_index++] = chain_buffer[j];
 
 	//compare the mic
-	for (i=0;i<8;i++){
+	for (i=0;i<8;i++) {
 		if (pframe[hdrlen+8+plen-8+i] != message[hdrlen+8+plen-8+i])
 		{
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("aes_decipher:mic check error mic[%d]: pframe(%x) != message(%x)\n",
@@ -1876,9 +1876,9 @@ u32	rtw_aes_decrypt(struct rtw_adapter *
 _func_enter_;
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
 	//4 start to encrypt each fragment
-	if ((prxattrib->encrypt==_AES_)){
+	if ((prxattrib->encrypt==_AES_)) {
 		stainfo=rtw_get_stainfo(&padapter->stapriv ,&prxattrib->ta[0]);
-		if (stainfo!=NULL){
+		if (stainfo!=NULL) {
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_decrypt: stainfo!=NULL!!!\n"));
 
 			if (IS_MCAST(prxattrib->ra))
@@ -2741,7 +2741,7 @@ int tdls_verify_mic(u8 *kck, u8 trans_se
 	u8 *rx_ftie, *tmp_ftie;
 
 	if (lnkid == NULL || rsnie == NULL ||
-	    timeoutie == NULL || ftie == NULL){
+	    timeoutie == NULL || ftie == NULL) {
 		return 0;
 	}
 
--- a/drivers/staging/rtl8192du/core/rtw_sreset.c
+++ b/drivers/staging/rtl8192du/core/rtw_sreset.c
@@ -55,10 +55,10 @@ u8 sreset_get_wifi_status(_adapter *pada
 		return status;
 	}
 	val32 =rtw_read32(padapter,REG_TXDMA_STATUS);
-	if (val32==0xeaeaeaea){
+	if (val32==0xeaeaeaea) {
 		psrtpriv->Wifi_Error_Status = WIFI_IF_NOT_EXIST;
 	}
-	else if (val32!=0){
+	else if (val32!=0) {
 		DBG_8192C("txdmastatu(%x)\n",val32);
 		psrtpriv->Wifi_Error_Status = WIFI_MAC_TXDMA_ERROR;
 	}
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -254,7 +254,7 @@ u32	_rtw_free_sta_priv(struct	sta_priv *
 	int	index;
 
 _func_enter_;
-	if (pstapriv){
+	if (pstapriv) {
 		/*	delete all reordering_ctrl_timer		*/
 		spin_lock_bh(&pstapriv->sta_hash_lock);
 		for (index = 0; index < NUM_STA; index++)
@@ -331,7 +331,7 @@ _func_enter_;
 
 		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_info_,("rtw_alloc_stainfo: index  = %x", index));
 
-		if (index >= NUM_STA){
+		if (index >= NUM_STA) {
 			RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("ERROR=> rtw_alloc_stainfo: index >= NUM_STA"));
 			psta= NULL;
 			goto exit;
@@ -659,7 +659,7 @@ _func_enter_;
 
 	psta = rtw_alloc_stainfo(pstapriv, bcast_addr);
 
-	if (psta==NULL){
+	if (psta==NULL) {
 		res=_FAIL;
 		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("rtw_alloc_stainfo fail"));
 		goto exit;
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ b/drivers/staging/rtl8192du/core/rtw_tdls.c
@@ -257,12 +257,12 @@ void free_tdls_sta(_adapter *padapter, s
 		memset(&ptdlsinfo->ss_record, 0x00, sizeof(struct tdls_ss_record));
 	}
 	//ready to clear cam
-	if (ptdls_sta->mac_id!=0){
+	if (ptdls_sta->mac_id!=0) {
 		ptdlsinfo->clear_cam=ptdls_sta->mac_id;
 		rtw_setstakey_cmd(padapter, (u8 *)ptdls_sta, true);
 	}
 
-	if (ptdlsinfo->sta_cnt==0){
+	if (ptdlsinfo->sta_cnt==0) {
 		rtw_tdls_cmd(padapter, myid(&(padapter->eeprompriv)), TDLS_RS_RCR);
 		ptdlsinfo->setup_state=TDLS_STATE_NONE;
 	}
@@ -591,7 +591,7 @@ void issue_tdls_setup_req(_adapter *pada
 		}
 	}
 
-	if (ptdls_sta){
+	if (ptdls_sta) {
 		ptdls_sta->tdls_sta_state |= TDLS_RESPONDER_STATE;
 		//for tdls; ptdls_sta->aid is used to fill dialogtoken
 		ptdls_sta->dialog = dialogtoken;
@@ -601,7 +601,7 @@ void issue_tdls_setup_req(_adapter *pada
 	}
 
 	pattrib->qsel=pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_SETUP_REQUEST) !=_SUCCESS){
+	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_SETUP_REQUEST) !=_SUCCESS) {
 		rtw_free_xmitbuf(pxmitpriv,pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
 		goto exit;
@@ -623,10 +623,10 @@ void issue_tdls_teardown(_adapter *padap
 	struct sta_info	*ptdls_sta=NULL;
 
 	ptdls_sta = rtw_get_stainfo(pstapriv, mac_addr);
-	if (ptdls_sta==NULL){
+	if (ptdls_sta==NULL) {
 		DBG_871X("issue tdls teardown unsuccessful\n");
 		return;
-	}else{
+	} else {
 		ptdls_sta->tdls_sta_state=TDLS_STATE_NONE;
 	}
 
@@ -657,7 +657,7 @@ void issue_tdls_teardown(_adapter *padap
 	}
 	rtw_dump_xframe(padapter, pmgntframe);
 
-	if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE){
+	if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE) {
 		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
 	}
 
@@ -937,7 +937,7 @@ void issue_tdls_ch_switch_req(_adapter *
 	update_tdls_attrib(padapter, pattrib);
 
 	pattrib->qsel=pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_REQUEST) !=_SUCCESS){
+	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_REQUEST) !=_SUCCESS) {
 		rtw_free_xmitbuf(pxmitpriv,pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
 		goto exit;
@@ -978,7 +978,7 @@ void issue_tdls_ch_switch_rsp(_adapter *
 	update_tdls_attrib(padapter, pattrib);
 
 	pattrib->qsel=pattrib->priority;
-	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_RESPONSE) !=_SUCCESS){
+	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_RESPONSE) !=_SUCCESS) {
 		rtw_free_xmitbuf(pxmitpriv,pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
 		goto exit;
@@ -1107,29 +1107,29 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 		goto exit;
 	}
 
-	if (ptdls_sta==NULL){
+	if (ptdls_sta==NULL) {
 		ptdls_sta = rtw_alloc_stainfo(pstapriv, psa);
-	}else{
-		if (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE){
+	} else {
+		if (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) {
 			//If the direct link is already set up
 			//Process as re-setup after tear down
 			DBG_871X("re-setup a direct link\n");
 		}
 		//already receiving TDLS setup request
-		else if (ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE){
+		else if (ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE) {
 			DBG_871X("receive duplicated TDLS setup request frame in handshaking\n");
 			goto exit;
 		}
 		//When receiving and sending setup_req to the same link at the same time, STA with higher MAC_addr would be initiator
 		//following is to check out MAC_addr
-		else if (ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE){
+		else if (ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE) {
 			DBG_871X("receive setup_req after sending setup_req\n");
-			for (i=0;i<6;i++){
-				if (*(pmyid+i)==*(psa+i)){
+			for (i=0;i<6;i++) {
+				if (*(pmyid+i)==*(psa+i)) {
 				}
-				else if (*(pmyid+i)>*(psa+i)){
+				else if (*(pmyid+i)>*(psa+i)) {
 					goto exit;
-				}else if (*(pmyid+i)<*(psa+i)){
+				} else if (*(pmyid+i)<*(psa+i)) {
 					ptdls_sta->tdls_sta_state=TDLS_INITIATOR_STATE;
 					break;
 				}
@@ -1143,7 +1143,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 		ptdls_sta->stat_code = 0;
 
 		//parsing information element
-		for (j=FIXED_IE; j<parsing_length;){
+		for (j=FIXED_IE; j<parsing_length;) {
 			pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
 			switch (pIE->ElementID)
@@ -1165,16 +1165,16 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 					break;
 				case _RSN_IE_2_:
 					rsnie_have=1;
-					if (prx_pkt_attrib->encrypt){
+					if (prx_pkt_attrib->encrypt) {
 						prsnie=(u8*)pIE;
 						//check whether initiator STA has CCMP pairwise_cipher.
 						ppairwise_cipher=prsnie+10;
 						memcpy(&pairwise_count, (u16*)(ppairwise_cipher-2), 1);
-						for (k=0;k<pairwise_count;k++){
+						for (k=0;k<pairwise_count;k++) {
 							if (_rtw_memcmp(ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==true)
 								ccmp_have=1;
 						}
-						if (ccmp_have==0){
+						if (ccmp_have==0) {
 							//invalid contents of RSNIE
 							ptdls_sta->stat_code=72;
 						}
@@ -1222,10 +1222,10 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 		//if responder STA has/hasn't security on AP, but request hasn't/has RSNIE, it should reject
 		if (ptdls_sta->stat_code == 0)
 		{
-			if (rsnie_have && (prx_pkt_attrib->encrypt==0)){
+			if (rsnie_have && (prx_pkt_attrib->encrypt==0)) {
 				//security disabled
 				ptdls_sta->stat_code = 5;
-			}else if (rsnie_have==0 && (prx_pkt_attrib->encrypt)){
+			} else if (rsnie_have==0 && (prx_pkt_attrib->encrypt)) {
 				//request haven't RSNIE
 				ptdls_sta->stat_code = 38;
 			}
@@ -1244,7 +1244,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 		}
 
 		ptdls_sta->tdls_sta_state|= TDLS_INITIATOR_STATE;
-		if (prx_pkt_attrib->encrypt){
+		if (prx_pkt_attrib->encrypt) {
 			memcpy(ptdls_sta->SNonce, SNonce, 32);
 			memcpy(&(ptdls_sta->TDLS_PeerKey_Lifetime), timeout_interval, 4);
 		}
@@ -1357,7 +1357,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 				//check whether responder STA has CCMP pairwise_cipher.
 				ppairwise_cipher=prsnie+10;
 				memcpy(&pairwise_count, (u16*)(ppairwise_cipher-2), 2);
-				for (k=0;k<pairwise_count;k++){
+				for (k=0;k<pairwise_count;k++) {
 					if (_rtw_memcmp(ppairwise_cipher+4*k, RSN_CIPHER_SUITE_CCMP, 4)==true)
 						verify_ccmp=1;
 				}
@@ -1421,7 +1421,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 				ptdls_sta->stat_code=72;	//invalide contents of RSNIE
 			}
 
-		}else{
+		} else {
 			ptdls_sta->stat_code=0;
 		}
 	}
@@ -1485,15 +1485,15 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 			-FIXED_IE;
 	memcpy(&stat_code, ptr+2, 2);
 
-	if (stat_code!=0){
+	if (stat_code!=0) {
 		DBG_871X("[%s] stat_code = %d\n, free_tdls_sta", __func__, stat_code);
 		free_tdls_sta(adapter, ptdls_sta);
 		return _FAIL;
 	}
 
-	if (prx_pkt_attrib->encrypt){
+	if (prx_pkt_attrib->encrypt) {
 		//parsing information element
-		for (j=FIXED_IE; j<parsing_length;){
+		for (j=FIXED_IE; j<parsing_length;) {
 			pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
 			switch (pIE->ElementID)
@@ -1523,7 +1523,7 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 		}
 
 		//verify mic in FTIE MIC field
-		if (tdls_verify_mic(ptdls_sta->tpk.kck, 3, plinkid_ie, prsnie, ptimeout_ie, pftie)==0){	//0: Invalid, 1: Valid
+		if (tdls_verify_mic(ptdls_sta->tpk.kck, 3, plinkid_ie, prsnie, ptimeout_ie, pftie)==0) {	//0: Invalid, 1: Valid
 			free_tdls_sta(adapter, ptdls_sta);
 			return _FAIL;
 		}
@@ -1572,7 +1572,7 @@ int On_TDLS_Dis_Req(_adapter *adapter, u
 			-FIXED_IE;
 
 	//parsing information element
-	for (j=FIXED_IE; j<parsing_length;){
+	for (j=FIXED_IE; j<parsing_length;) {
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
 		switch (pIE->ElementID)
@@ -1619,8 +1619,8 @@ int On_TDLS_Teardown(_adapter *adapter,
 	psa = get_sa(ptr);
 
 	ptdls_sta = rtw_get_stainfo(pstapriv, psa);
-	if (ptdls_sta!=NULL){
-		if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE){
+	if (ptdls_sta!=NULL) {
+		if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE) {
 			rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
 		}
 		free_tdls_sta(adapter, ptdls_sta);
@@ -1629,15 +1629,15 @@ int On_TDLS_Teardown(_adapter *adapter,
 	return _FAIL;
 }
 
-u8 TDLS_check_ch_state(uint state){
+u8 TDLS_check_ch_state(uint state) {
 	if (	(state & TDLS_CH_SWITCH_ON_STATE) &&
 		(state & TDLS_AT_OFF_CH_STATE) &&
-		(state & TDLS_PEER_AT_OFF_STATE)){
+		(state & TDLS_PEER_AT_OFF_STATE)) {
 		if (state & TDLS_PEER_SLEEP_STATE)
 			return 2;	//U-APSD + ch. switch
 		else
 			return 1;	//ch. switch
-	}else
+	} else
 		return 0;
 }
 
@@ -1661,7 +1661,7 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 
 	// if noticed peer STA wakes up by receiving peer traffic response
 	// and we want to do channel swtiching, then we will transmit channel switch request first
-	if (ptdls_sta->tdls_sta_state & TDLS_APSD_CHSW_STATE){
+	if (ptdls_sta->tdls_sta_state & TDLS_APSD_CHSW_STATE) {
 		issue_tdls_ch_switch_req(adapter, pattrib->src);
 		ptdls_sta->tdls_sta_state &= ~(TDLS_APSD_CHSW_STATE);
 		return  _FAIL;
@@ -1672,7 +1672,7 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 		wmmps_ac=1;
 
 	//if it's a direct link and have buffered frame
-	if (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE){
+	if (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) {
 		if (wmmps_ac && state)
 		{
 			_list	*xmitframe_plist, *xmitframe_phead;
@@ -1691,10 +1691,10 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 				rtw_list_delete(&pxmitframe->list);
 
 				ptdls_sta->sleepq_len--;
-				if (ptdls_sta->sleepq_len>0){
+				if (ptdls_sta->sleepq_len>0) {
 					pxmitframe->attrib.mdata = 1;
 					pxmitframe->attrib.eosp = 0;
-				}else{
+				} else {
 					pxmitframe->attrib.mdata = 0;
 					pxmitframe->attrib.eosp = 1;
 				}
@@ -1711,9 +1711,9 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 				DBG_871X("no buffered packets for tdls to xmit\n");
 				//on U-APSD + CH. switch state, when there is no buffered date to xmit,
 				// we should go back to base channel
-				if (state==2){
+				if (state==2) {
 					rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
-				}else if (ptdls_sta->tdls_sta_state&TDLS_SW_OFF_STATE){
+				} else if (ptdls_sta->tdls_sta_state&TDLS_SW_OFF_STATE) {
 						ptdls_sta->tdls_sta_state &= ~(TDLS_SW_OFF_STATE);
 						ptdlsinfo->candidate_ch= pmlmeext->cur_channel;
 						issue_tdls_ch_switch_req(adapter, pattrib->src);
@@ -1765,7 +1765,7 @@ int On_TDLS_Ch_Switch_Req(_adapter *adap
 	ptdls_sta->off_ch = *(ptr+2);
 
 	//parsing information element
-	for (j=FIXED_IE; j<parsing_length;){
+	for (j=FIXED_IE; j<parsing_length;) {
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
 		switch (pIE->ElementID)
@@ -1797,11 +1797,11 @@ int On_TDLS_Ch_Switch_Req(_adapter *adap
 
 	DBG_871X("issue tdls channel switch response\n");
 
-	if ((ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE) && ptdls_sta->off_ch==pmlmeext->cur_channel){
+	if ((ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE) && ptdls_sta->off_ch==pmlmeext->cur_channel) {
 		DBG_871X("back to base channel %x\n", pmlmeext->cur_channel);
 		ptdls_sta->option=7;
 		rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_BASE_CH);
-	}else{
+	} else {
 		ptdls_sta->option=6;
 		rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_OFF_CH);
 	}
@@ -1826,12 +1826,12 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 
 	//if channel switch is running and receiving Unsolicited TDLS Channel Switch Response,
 	//it will go back to base channel and terminate this channel switch procedure
-	if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE){
-		if (pmlmeext->cur_channel==ptdls_sta->off_ch){
+	if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE) {
+		if (pmlmeext->cur_channel==ptdls_sta->off_ch) {
 			DBG_871X("back to base channel %x\n", pmlmeext->cur_channel);
 			ptdls_sta->option=7;
 			rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_OFF_CH);
-		}else{
+		} else {
 			DBG_871X("receive unsolicited channel switch response\n");
 			rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
 		}
@@ -1854,12 +1854,12 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 
 	memcpy(&stat_code, ptr+2, 2);
 
-	if (stat_code!=0){
+	if (stat_code!=0) {
 		return _FAIL;
 	}
 
 	//parsing information element
-	for (j=FIXED_IE; j<parsing_length;){
+	for (j=FIXED_IE; j<parsing_length;) {
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
 		switch (pIE->ElementID)
@@ -2006,8 +2006,8 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	u32 time;
 
 	//SNonce
-	if (pattrib->encrypt){
-		for (i=0;i<8;i++){
+	if (pattrib->encrypt) {
+		for (i=0;i<8;i++) {
 			time=rtw_get_current_time();
 			memcpy(&ptdls_sta->SNonce[4*i], (u8 *)&time, 4);
 		}
@@ -2044,7 +2044,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 
 	//country(optional)
 	//extended supported rates
-	if (more_supportedrates==1){
+	if (more_supportedrates==1) {
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
 	}
 
@@ -2065,7 +2065,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 7, TDLS_WMMIE,  &(pattrib->pktlen));
 
 
-	if (pattrib->encrypt){
+	if (pattrib->encrypt) {
 		//FTIE
 		memset(pframe, 0, 84);	//All fields except SNonce shall be set to 0
 		memset(pframe, _FTIE_, 1);	//version
@@ -2133,8 +2133,8 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 		return;
 	}
 
-	if (pattrib->encrypt){
-		for (k=0;k<8;k++){
+	if (pattrib->encrypt) {
+		for (k=0;k<8;k++) {
 			time=rtw_get_current_time();
 			memcpy(&ptdls_sta->ANonce[4*k], (u8*)&time, 4);
 		}
@@ -2180,7 +2180,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 
 	//country(optional)
 	//extended supported rates
-	if (more_supportedrates==1){
+	if (more_supportedrates==1) {
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
 	}
 
@@ -2191,7 +2191,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	pframe = rtw_set_ie(pframe, _SRC_IE_ , 16, TDLS_SRC, &(pattrib->pktlen));
 
 	//RSNIE
-	if (pattrib->encrypt){
+	if (pattrib->encrypt) {
 		prsnie = pframe;
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
 	}
@@ -2202,7 +2202,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	//QoS capability(WMM_IE)
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 7, TDLS_WMMIE,  &(pattrib->pktlen));
 
-	if (pattrib->encrypt){
+	if (pattrib->encrypt) {
 		wpa_tdls_generate_tpk(padapter, ptdls_sta);
 
 		//FTIE
@@ -2278,13 +2278,13 @@ void rtw_build_tdls_setup_cfm_ies(_adapt
 		return;
 
 	//RSNIE
-	if (pattrib->encrypt){
+	if (pattrib->encrypt) {
 		prsnie = pframe;
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
 	}
 
 	//EDCA param set; WMM param ele.
-	if (pattrib->encrypt){
+	if (pattrib->encrypt) {
 		//FTIE
 		pftie = pframe;
 		pftie_mic = pframe+4;
@@ -2337,11 +2337,11 @@ void rtw_build_tdls_teardown_ies(_adapte
 	pframe = rtw_set_fixed_ie(pframe, 1, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
 
 	//Link identifier
-	if (ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE){
+	if (ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE) {
 		memcpy(link_id_addr, pattrib->ra, 6);
 		memcpy((link_id_addr+6), pattrib->src, 6);
 		memcpy((link_id_addr+12), pattrib->dst, 6);
-	}else  if (ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE){
+	} else  if (ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE) {
 		memcpy(link_id_addr, pattrib->ra, 6);
 		memcpy((link_id_addr+6), pattrib->dst, 6);
 		memcpy((link_id_addr+12), pattrib->src, 6);
@@ -2420,7 +2420,7 @@ void rtw_build_tdls_dis_rsp_ies(_adapter
 	}
 
 	//extended supported rates
-	if (more_supportedrates==1){
+	if (more_supportedrates==1) {
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
 	}
 
@@ -2434,7 +2434,7 @@ void rtw_build_tdls_dis_rsp_ies(_adapter
 	//extended capability
 	pframe = rtw_set_ie(pframe, _EXT_CAP_IE_ , 5, TDLS_EXT_CAPIE, &(pattrib->pktlen));
 
-	if (pattrib->encrypt){
+	if (pattrib->encrypt) {
 		//FTIE
 		memset(pframe, 0, 84);	//All fields shall be set to 0
 		memset(pframe, _FTIE_, 1);	//version
@@ -2644,7 +2644,7 @@ void _TPK_timer_hdl(void *FunctionContex
 	ptdls_sta->TPK_count++;
 	//TPK_timer set 1000 as default
 	//retry timer should set at least 301 sec.
-	if (ptdls_sta->TPK_count==TPK_RESEND_COUNT){
+	if (ptdls_sta->TPK_count==TPK_RESEND_COUNT) {
 		ptdls_sta->TPK_count=0;
 		issue_tdls_setup_req(ptdls_sta->padapter, ptdls_sta->hwaddr);
 	}
@@ -2667,12 +2667,12 @@ void _ch_switch_timer_hdl(void *Function
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
 	_adapter *padapter = ptdls_sta->padapter;
 
-	if (ptdls_sta->option == TDLS_DONE_CH_SEN){
+	if (ptdls_sta->option == TDLS_DONE_CH_SEN) {
 		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_DONE_CH_SEN);
-	}else if (ptdls_sta->option == TDLS_OFF_CH){
+	} else if (ptdls_sta->option == TDLS_OFF_CH) {
 		issue_nulldata_to_TDLS_peer_STA(ptdls_sta->padapter, ptdls_sta, 0);
 		_set_timer(&ptdls_sta->base_ch_timer, 500);
-	}else if (ptdls_sta->option == TDLS_BASE_CH){
+	} else if (ptdls_sta->option == TDLS_BASE_CH) {
 		issue_nulldata_to_TDLS_peer_STA(ptdls_sta->padapter, ptdls_sta, 0);
 	}
 }
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -1991,7 +1991,7 @@ int rtw_handle_dualmac(struct rtw_adapte
 			DBG_8192D("%s(): SECONDARY_ADAPTER\n",__func__);
 		}
 #endif
-	}else {
+	} else {
 		pbuddy_padapter = NULL;
 	}
 exit:
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -110,7 +110,7 @@ _func_enter_;
 
 	pxmitpriv->pallocated_frame_buf = rtw_zvmalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
 
-	if (pxmitpriv->pallocated_frame_buf  == NULL){
+	if (pxmitpriv->pallocated_frame_buf  == NULL) {
 		pxmitpriv->pxmit_frame_buf =NULL;
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_frame fail!\n"));
 		res= _FAIL;
@@ -150,7 +150,7 @@ _func_enter_;
 
 	pxmitpriv->pallocated_xmitbuf = rtw_zvmalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
 
-	if (pxmitpriv->pallocated_xmitbuf  == NULL){
+	if (pxmitpriv->pallocated_xmitbuf  == NULL) {
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_buf fail!\n"));
 		res= _FAIL;
 		goto exit;
@@ -205,7 +205,7 @@ _func_enter_;
 
 	pxmitpriv->pallocated_xmit_extbuf = rtw_zvmalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);
 
-	if (pxmitpriv->pallocated_xmit_extbuf  == NULL){
+	if (pxmitpriv->pallocated_xmit_extbuf  == NULL) {
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_extbuf fail!\n"));
 		res= _FAIL;
 		goto exit;
@@ -826,7 +826,7 @@ _func_exit_;
 	return res;
 }
 
-static s32 xmitframe_addmic(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe){
+static s32 xmitframe_addmic(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe) {
 	int			curfragnum,length;
 	u8	*pframe, *payload,mic[8];
 	struct	mic_data		micdata;
@@ -854,7 +854,7 @@ _func_enter_;
 	if (pattrib->encrypt ==_TKIP_)//if (psecuritypriv->dot11PrivacyAlgrthm==_TKIP_PRIVACY_)
 	{
 		//encode mic code
-		if (stainfo!= NULL){
+		if (stainfo!= NULL) {
 			u8 null_key[16]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
 
 #ifdef CONFIG_USB_TX_AGGREGATION
@@ -865,7 +865,7 @@ _func_enter_;
 
 			if (bmcst)
 			{
-				if (_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16)==true){
+				if (_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16)==true) {
 					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
 					//rtw_msleep_os(10);
 					return _FAIL;
@@ -875,7 +875,7 @@ _func_enter_;
 			}
 			else
 			{
-				if (_rtw_memcmp(&stainfo->dot11tkiptxmickey.skey[0],null_key, 16)==true){
+				if (_rtw_memcmp(&stainfo->dot11tkiptxmickey.skey[0],null_key, 16)==true) {
 					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
 					//rtw_msleep_os(10);
 					return _FAIL;
@@ -884,14 +884,14 @@ _func_enter_;
 				rtw_secmicsetkey(&micdata, &stainfo->dot11tkiptxmickey.skey[0]);
 			}
 
-			if (pframe[1]&1){   //ToDS==1
+			if (pframe[1]&1) {   //ToDS==1
 				rtw_secmicappend(&micdata, &pframe[16], 6);  //DA
 				if (pframe[1]&2)  //From Ds==1
 					rtw_secmicappend(&micdata, &pframe[24], 6);
 				else
 				rtw_secmicappend(&micdata, &pframe[10], 6);
 			}
-			else{	//ToDS==0
+			else {	//ToDS==0
 				rtw_secmicappend(&micdata, &pframe[4], 6);   //DA
 				if (pframe[1]&2)  //From Ds==1
 					rtw_secmicappend(&micdata, &pframe[16], 6);
@@ -909,19 +909,19 @@ _func_enter_;
 
 			payload=pframe;
 
-			for (curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
+			for (curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++) {
 				payload=(u8 *)RND4((SIZE_PTR)(payload));
 				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("===curfragnum=%d, pframe= 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x,!!!\n",
 					curfragnum,*payload, *(payload+1),*(payload+2),*(payload+3),*(payload+4),*(payload+5),*(payload+6),*(payload+7)));
 
 				payload=payload+pattrib->hdrlen+pattrib->iv_len;
 				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("curfragnum=%d pattrib->hdrlen=%d pattrib->iv_len=%d",curfragnum,pattrib->hdrlen,pattrib->iv_len));
-				if ((curfragnum+1)==pattrib->nr_frags){
+				if ((curfragnum+1)==pattrib->nr_frags) {
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);
 					rtw_secmicappend(&micdata, payload,length);
 					payload=payload+length;
 				}
-				else{
+				else {
 					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);
 					rtw_secmicappend(&micdata, payload, length);
 					payload=payload+length+pattrib->icv_len;
@@ -946,7 +946,7 @@ _func_enter_;
 					*(payload+curfragnum), *(payload+curfragnum+1), *(payload+curfragnum+2),*(payload+curfragnum+3),
 					*(payload+curfragnum+4),*(payload+curfragnum+5),*(payload+curfragnum+6),*(payload+curfragnum+7)));
 			}
-			else{
+			else {
 				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: rtw_get_stainfo==NULL!!!\n"));
 			}
 	}
@@ -956,7 +956,7 @@ _func_exit_;
 	return _SUCCESS;
 }
 
-static s32 xmitframe_swencrypt(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe){
+static s32 xmitframe_swencrypt(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe) {
 	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
 	//struct	security_priv	*psecuritypriv=&padapter->securitypriv;
 
@@ -967,7 +967,7 @@ _func_enter_;
 	{
 		//DBG_8192D("start xmitframe_swencrypt\n");
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_alert_,("### xmitframe_swencrypt\n"));
-		switch (pattrib->encrypt){
+		switch (pattrib->encrypt) {
 		case _WEP40_:
 		case _WEP104_:
 			rtw_wep_encrypt(padapter, (u8 *)pxmitframe);
@@ -1034,15 +1034,15 @@ _func_enter_;
 		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == true)) {
 			//to_ds = 1, fr_ds = 0;
 #ifdef CONFIG_TDLS
-			if ((ptdlsinfo->setup_state == TDLS_LINKED_STATE)){
+			if ((ptdlsinfo->setup_state == TDLS_LINKED_STATE)) {
 				ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
-				if ((ptdls_sta!=NULL)&&(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE)&&(pattrib->ether_type!=0x0806)){
+				if ((ptdls_sta!=NULL)&&(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE)&&(pattrib->ether_type!=0x0806)) {
 					//TDLS data transfer, ToDS=0, FrDs=0
 					memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
 					memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 					memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
 					direct_link=1;
-				}else{
+				} else {
 					// 1.Data transfer to AP
 					// 2.Arp pkt will relayed by AP
 					SetToDs(fctrl);
@@ -1050,7 +1050,7 @@ _func_enter_;
 					memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 					memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
 				}
-			}else
+			} else
 #endif //CONFIG_TDLS
 			{
 				//Data transfer to AP
@@ -1111,7 +1111,7 @@ _func_enter_;
 
 		//Update Seq Num will be handled by f/w
 		{
-			if (psta){
+			if (psta) {
 #ifdef CONFIG_TDLS
 				if (direct_link==1)
 				{
@@ -1166,7 +1166,7 @@ _func_enter_;
 #ifdef CONFIG_TDLS
 				if (direct_link==1)
 				{
-					if (pattrib->encrypt){
+					if (pattrib->encrypt) {
 						pattrib->encrypt= _AES_;
 						pattrib->iv_len=8;
 						pattrib->icv_len=8;
@@ -1250,7 +1250,7 @@ int rtw_build_tdls_ies(struct rtw_adapte
 {
 	int res=_SUCCESS;
 
-	switch (action){
+	switch (action) {
 		case TDLS_SETUP_REQUEST:
 			rtw_build_tdls_setup_req_ies(padapter, pxmitframe, pframe);
 			break;
@@ -1310,7 +1310,7 @@ _func_enter_;
 
 	SetFrameSubType(fctrl, pattrib->subtype);
 
-	switch (action){
+	switch (action) {
 		case TDLS_SETUP_REQUEST:
 		case TDLS_SETUP_RESPONSE:
 		case TDLS_SETUP_CONFIRM:
@@ -1366,24 +1366,24 @@ _func_enter_;
 
 	//  1. update seq_num per link by sta_info
 	//  2. rewrite encrypt to _AES_, also rewrite iv_len, icv_len
-	if (tdls_seq==1){
+	if (tdls_seq==1) {
 		ptdls_sta=rtw_get_stainfo(pstapriv, pattrib->dst);
-		if (ptdls_sta){
+		if (ptdls_sta) {
 			ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
 			ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
 			pattrib->seqnum = ptdls_sta->sta_xmitpriv.txseq_tid[pattrib->priority];
 			SetSeqNum(hdr, pattrib->seqnum);
 
-			if (pattrib->encrypt){
+			if (pattrib->encrypt) {
 				pattrib->encrypt= _AES_;
 				pattrib->iv_len=8;
 				pattrib->icv_len=8;
 			}
-		}else{
+		} else {
 			res=_FAIL;
 			goto exit;
 		}
-	}else if (psta){
+	} else if (psta) {
 		psta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
 		psta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
 		pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[pattrib->priority];
@@ -2103,7 +2103,7 @@ _func_enter_;
 
 	rtw_list_delete(&pxmitframe->list);
 
-	if (pxmitframe->pkt){
+	if (pxmitframe->pkt) {
 		pndis_pkt = pxmitframe->pkt;
 		pxmitframe->pkt = NULL;
 	}
@@ -2587,18 +2587,18 @@ int rtw_br_client_tx(struct rtw_adapter
 			}
 		}
 #if 0
-		else{
+		else {
 			if (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_8021Q)) {
 				is_vlan_tag = 1;
 			}
 
-			if (is_vlan_tag){
-				if (ICMPV6_MCAST_MAC(skb->data) && ICMPV6_PROTO1A_VALN(skb->data)){
+			if (is_vlan_tag) {
+				if (ICMPV6_MCAST_MAC(skb->data) && ICMPV6_PROTO1A_VALN(skb->data)) {
                                         memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
 				}
-			}else
+			} else
 			{
-				if (ICMPV6_MCAST_MAC(skb->data) && ICMPV6_PROTO1A(skb->data)){
+				if (ICMPV6_MCAST_MAC(skb->data) && ICMPV6_PROTO1A(skb->data)) {
                                         memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
 				}
 			}
@@ -2728,9 +2728,9 @@ int xmitframe_enqueue_for_tdls_sleeping_
 	int i;
 
 	ptdls_sta=rtw_get_stainfo(pstapriv, pattrib->dst);
-	if (ptdls_sta==NULL){
+	if (ptdls_sta==NULL) {
 		return ret;
-	}else if (ptdls_sta->tdls_sta_state&TDLS_LINKED_STATE){
+	} else if (ptdls_sta->tdls_sta_state&TDLS_LINKED_STATE) {
 		if (pattrib->triggered==1) {
 			ret = true;
 			return ret;
--- a/drivers/staging/rtl8192du/hal/hal_intf.c
+++ b/drivers/staging/rtl8192du/hal/hal_intf.c
@@ -92,7 +92,7 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 	}
 #ifdef CONFIG_DEINIT_BEFORE_INIT
 	status = padapter->HalFunc.hal_deinit(padapter);
-	if (status != _SUCCESS){
+	if (status != _SUCCESS) {
 		DBG_8192D("rtw_hal_init: hal_deinit before hal_init FAIL !!\n");
 		return status;
 	}
@@ -111,16 +111,16 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 		{
 #ifdef CONFIG_DEINIT_BEFORE_INIT
 			status = padapter->HalFunc.hal_deinit(padapter->pbuddy_adapter);
-			if (status != _SUCCESS){
+			if (status != _SUCCESS) {
 				DBG_8192D("rtw_hal_init: hal_deinit before hal_init FAIL !!(pbuddy_adapter)\n");
 				return status;
 			}
 #endif
 			status =	padapter->HalFunc.hal_init(padapter->pbuddy_adapter);
-			if (status == _SUCCESS){
+			if (status == _SUCCESS) {
 				padapter->pbuddy_adapter->hw_init_completed = true;
 			}
-			else{
+			else {
 				padapter->pbuddy_adapter->hw_init_completed = false;
 				RT_TRACE(_module_hal_init_c_,_drv_err_,("rtw_hal_init: hal__init fail(pbuddy_adapter)\n"));
 				return status;
@@ -136,16 +136,16 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 		{
 #ifdef CONFIG_DEINIT_BEFORE_INIT
 			status = padapter->HalFunc.hal_deinit(padapter->pbuddy_adapter);
-			if (status != _SUCCESS){
+			if (status != _SUCCESS) {
 				DBG_8192D("rtw_hal_init: hal_deinit before hal_init FAIL !!(pbuddy_adapter)\n");
 				return status;
 			}
 #endif
 			status = padapter->HalFunc.hal_init(padapter->pbuddy_adapter);
-			if (status == _SUCCESS){
+			if (status == _SUCCESS) {
 				padapter->pbuddy_adapter->hw_init_completed = true;
 			}
-			else{
+			else {
 				padapter->pbuddy_adapter->hw_init_completed = false;
 				RT_TRACE(_module_hal_init_c_,_drv_err_,("rtw_hal_init: hal__init fail for another interface\n"));
 			}
@@ -157,7 +157,7 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 
 	status = padapter->HalFunc.hal_init(padapter);
 
-	if (status == _SUCCESS){
+	if (status == _SUCCESS) {
 		padapter->hw_init_completed = true;
 
 		if (padapter->registrypriv.notch_filter == 1)
@@ -165,7 +165,7 @@ uint	 rtw_hal_init(struct rtw_adapter *p
 
 		rtw_hal_reset_security_engine(padapter);
 	}
-	else{
+	else {
 		padapter->hw_init_completed = false;
 		RT_TRACE(_module_hal_init_c_,_drv_err_,("rtw_hal_init: hal__init fail\n"));
 	}
@@ -183,7 +183,7 @@ _func_enter_;
 
 	status = padapter->HalFunc.hal_deinit(padapter);
 
-	if (status == _SUCCESS){
+	if (status == _SUCCESS) {
 		padapter->hw_init_completed = false;
 	}
 	else
--- a/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_cmd.c
@@ -696,7 +696,7 @@ void SetFwRsvdPagePkt(struct rtw_adapter
 	DBG_8192D("%s\n", __func__);
 
 	reservedpagepacket = (u8*)rtw_malloc(1000);
-	if (reservedpagepacket == NULL){
+	if (reservedpagepacket == NULL) {
 		DBG_8192D("%s(): alloc reservedpagepacket fail !!!\n", __func__);
 		return;
 	}
@@ -1010,7 +1010,7 @@ _func_enter_;
 	if (IFACE_PORT0==reset_port) {
 		buf[0] = 0x1; buf[1] = 0;
 
-	} else{
+	} else {
 		buf[0] = 0x0; buf[1] = 0x1;
 	}
 	FillH2CCmd92D(padapter, H2C_92D_RESET_TSF, 2, buf);
@@ -1062,7 +1062,7 @@ _func_enter_;
 
 
 
-	if (pwrpriv->wowlan_mode ==true){
+	if (pwrpriv->wowlan_mode ==true) {
 		//pause RX DMA
 		test = rtw_read8(padapter, REG_RXPKT_NUM+2);
 		test |= BIT(2);
@@ -1085,15 +1085,15 @@ _func_enter_;
 
 		pwowlan_parm.mode |=FW_WOWLAN_FUN_EN;
 		//printk("\n %s 1.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
-		if (pwrpriv->wowlan_pattern ==true){
+		if (pwrpriv->wowlan_pattern ==true) {
 			pwowlan_parm.mode |= FW_WOWLAN_PATTERN_MATCH;
 		//printk("\n %s 2.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		}
-		if (pwrpriv->wowlan_magic ==true){
+		if (pwrpriv->wowlan_magic ==true) {
 			//pwowlan_parm.mode |=FW_WOWLAN_MAGIC_PKT;
 		//printk("\n %s 3.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		}
-		if (pwrpriv->wowlan_unicast ==true){
+		if (pwrpriv->wowlan_unicast ==true) {
 			pwowlan_parm.mode |=FW_WOWLAN_UNICAST;
 		//printk("\n %s 4.pwowlan_parm.mode=0x%x\n",__func__,pwowlan_parm.mode);
 		}
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -929,7 +929,7 @@ static void dm_CCK_PacketDetectionThresh
 			else
 				dm_digtable->curcckpdstate = CCK_PD_STAGE_HIGHRSSI;
 		}
-		else{
+		else {
 			if (dm_digtable->rssi_val_min <= 20)
 				dm_digtable->curcckpdstate = CCK_PD_STAGE_LOWRSSI;
 			else
@@ -1106,7 +1106,7 @@ static void dm_1R_CCA(struct rtw_adapter
 					dm_pstable->curccastate = CCA_2R;
 
 			}
-			else{
+			else {
 				if (pdmpriv->MinUndecoratedPWDBForDM <= 30)
 					dm_pstable->curccastate = CCA_2R;
 				else
@@ -1223,7 +1223,7 @@ static void odm_DynamicTxPower_92D(struc
 		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x\n", UndecoratedSmoothedPWDB));
 	}
 
-	if (pHalData->CurrentBandType92D == BAND_ON_5G){
+	if (pHalData->CurrentBandType92D == BAND_ON_5G) {
 		if (UndecoratedSmoothedPWDB >= 0x33)
 		{
 			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
@@ -1626,7 +1626,7 @@ dm_RXGainTrackingCallback_ThermalMeter_9
 
 	//DBG_8192D("===>dm_RXGainTrackingCallback_ThermalMeter_92D interface %d  Rx Gain %x\n", pHalData->interfaceIndex, u4tmp);
 
-	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++){
+	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++) {
 		PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_RXRF_A3, bRFRegOffsetMask, (pdmpriv->RegRF3C[eRFPath]&(~(0xF000)))|u4tmp);
 	}
 };
@@ -2029,7 +2029,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
 				{
 					//Adjust CCK according to IQK result
-					if (!pdmpriv->bCCKinCH14){
+					if (!pdmpriv->bCCKinCH14) {
 						rtw_write8(Adapter, 0xa22, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][0]);
 						rtw_write8(Adapter, 0xa23, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][1]);
 						rtw_write8(Adapter, 0xa24, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][2]);
@@ -2039,7 +2039,7 @@ dm_TXPowerTrackingCallback_ThermalMeter_
 						rtw_write8(Adapter, 0xa28, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][6]);
 						rtw_write8(Adapter, 0xa29, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][7]);
 					}
-					else{
+					else {
 						rtw_write8(Adapter, 0xa22, CCKSwingTable_Ch14[(u8)CCK_index][0]);
 						rtw_write8(Adapter, 0xa23, CCKSwingTable_Ch14[(u8)CCK_index][1]);
 						rtw_write8(Adapter, 0xa24, CCKSwingTable_Ch14[(u8)CCK_index][2]);
--- a/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_hal_init.c
@@ -56,10 +56,10 @@ _FWDownloadEnable(
 #if 0
 	u32	value32 = rtw_read32(Adapter, REG_MCUFWDL);
 
-	if (enable){
+	if (enable) {
 		value32 |= MCUFWDL_EN;
 	}
-	else{
+	else {
 		value32 &= ~MCUFWDL_EN;
 	}
 
@@ -119,7 +119,7 @@ _BlockWrite_92d(
 
 	blockCount = size / blockSize;
 	remain8 = size % blockSize;
-	for (i = 0 ; i < blockCount ; i++){
+	for (i = 0 ; i < blockCount ; i++) {
 		offset = i * blockSize;
 		ret = rtw_writeN(Adapter, (FW_8192D_START_ADDRESS + offset), 64,(bufferPtr + offset));
 
@@ -128,34 +128,34 @@ _BlockWrite_92d(
 	}
 
 
-	if (remain8){
+	if (remain8) {
 		offset = blockCount * blockSize;
 
 		blockCount8=remain8/blockSize8;
 		remain4=remain8%blockSize8;
 		//RT_TRACE(COMP_INIT,DBG_LOUD,("remain4 size %x blockcount %x blockCount8 %x\n",remain4,blockCount,blockCount8));
-		for (i = 0 ; i < blockCount8 ; i++){
+		for (i = 0 ; i < blockCount8 ; i++) {
 			ret = rtw_writeN(Adapter, (FW_8192D_START_ADDRESS + offset+i*blockSize8), 8,(bufferPtr + offset+i*blockSize8));
 
 			if (ret == _FAIL)
 				goto exit;
 		}
 
-		if (remain4){
+		if (remain4) {
 			offset=blockCount * blockSize+blockCount8*blockSize8;
 			blockCount4=remain4/blocksize4;
 			remainSize=remain8%blocksize4;
 
-			for (i = 0 ; i < blockCount4 ; i++){
+			for (i = 0 ; i < blockCount4 ; i++) {
 				ret = rtw_write32(Adapter, (FW_8192D_START_ADDRESS + offset+i*blocksize4), cpu_to_le32(*(pu4BytePtr+ offset/4+i)));
 
 				if (ret == _FAIL)
 					goto exit;
 			}
 
-			if (remainSize){
+			if (remainSize) {
 				offset=blockCount * blockSize+blockCount8*blockSize8+blockCount4*blocksize4;
-				for (i = 0 ; i < remainSize ; i++){
+				for (i = 0 ; i < remainSize ; i++) {
 					ret = rtw_write8(Adapter, (FW_8192D_START_ADDRESS + offset + i), *(bufferPtr +offset+ i));
 
 					if (ret == _FAIL)
@@ -204,14 +204,14 @@ _WriteFW(
 	pageNums = size / MAX_PAGE_SIZE ;
 	remainSize = size % MAX_PAGE_SIZE;
 
-	for (page = 0; page < pageNums;  page++){
+	for (page = 0; page < pageNums;  page++) {
 		offset = page *MAX_PAGE_SIZE;
 		ret = _PageWrite(Adapter,page, (bufferPtr+offset),MAX_PAGE_SIZE);
 
 		if (ret == _FAIL)
 			goto exit;
 	}
-	if (remainSize){
+	if (remainSize) {
 		offset = pageNums *MAX_PAGE_SIZE;
 		page = pageNums;
 		ret = _PageWrite(Adapter,page, (bufferPtr+offset),remainSize);
@@ -238,7 +238,7 @@ int _FWFreeToGo_92D(
 		value32 = rtw_read32(Adapter, REG_MCUFWDL);
 	}while ((counter ++ < POLLING_READY_TIMEOUT_COUNT) && (!(value32 & FWDL_ChkSum_rpt )));
 
-	if (counter >= POLLING_READY_TIMEOUT_COUNT){
+	if (counter >= POLLING_READY_TIMEOUT_COUNT) {
 		DBG_8192D("chksum report faill ! REG_MCUFWDL:0x%08x .\n",value32);
 		return _FAIL;
 	}
@@ -316,15 +316,15 @@ int _FWInit(
 	counter = 0;
 	do
 	{
-		if (pHalData->interfaceIndex==0){
-			if (rtw_read8(Adapter, FW_MAC0_ready) & mac0_ready){
+		if (pHalData->interfaceIndex==0) {
+			if (rtw_read8(Adapter, FW_MAC0_ready) & mac0_ready) {
 				DBG_8192D("Polling FW ready success!! FW_MAC0_ready:0x%x .\n",rtw_read8(Adapter, FW_MAC0_ready));
 				return _SUCCESS;
 			}
 			rtw_udelay_os(5);
 		}
-		else{
-			if (rtw_read8(Adapter, FW_MAC1_ready) &mac1_ready){
+		else {
+			if (rtw_read8(Adapter, FW_MAC1_ready) &mac1_ready) {
 				DBG_8192D("Polling FW ready success!! FW_MAC1_ready:0x%x .\n",rtw_read8(Adapter, FW_MAC1_ready));
 				return _SUCCESS;
 			}
@@ -333,10 +333,10 @@ int _FWInit(
 
 	}while (counter++ < POLLING_READY_TIMEOUT_COUNT);
 
-	if (pHalData->interfaceIndex==0){
+	if (pHalData->interfaceIndex==0) {
 		DBG_8192D("Polling FW ready fail!! MAC0 FW init not ready:0x%x .\n",rtw_read8(Adapter, FW_MAC0_ready));
 	}
-	else{
+	else {
 		DBG_8192D("Polling FW ready fail!! MAC1 FW init not ready:0x%x .\n",rtw_read8(Adapter, FW_MAC1_ready));
 	}
 
@@ -378,7 +378,7 @@ int FirmwareDownload92D(
 	u32		count;
 	bool	 bFwDownloaded = false,bFwDownloadInProcess = false;
 
-	if (Adapter->bSurpriseRemoved){
+	if (Adapter->bSurpriseRemoved) {
 		return _FAIL;
 	}
 
@@ -429,7 +429,7 @@ int FirmwareDownload92D(
 			break;
 		case FW_SOURCE_HEADER_FILE:
 #if 0
-			if (ImgArrayLength > FW_8192C_SIZE){
+			if (ImgArrayLength > FW_8192C_SIZE) {
 				rtStatus = _FAIL;
 				//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Firmware size exceed 0x%X. Check it.\n", FW_8192C_SIZE));
 				goto Exit;
@@ -572,7 +572,7 @@ int FirmwareDownload92D(
 		);
 	}
 	_FWDownloadEnable(Adapter, false);
-	if (_SUCCESS != rtStatus){
+	if (_SUCCESS != rtStatus) {
 		DBG_8192D("DL Firmware failed!\n");
 		goto Exit;
 	}
@@ -585,7 +585,7 @@ int FirmwareDownload92D(
 	rtw_write8(Adapter, 0x1f,value);
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
 
-	if (_SUCCESS != rtStatus){
+	if (_SUCCESS != rtStatus) {
 		DBG_8192D("Firmware is not ready to run!\n");
 		goto Exit;
 	}
@@ -777,9 +777,9 @@ hal_ReadPowerValueFromPROM92D(
 
 	memset(pwrInfo, 0, sizeof(struct tx_power_info));
 
-	if (AutoLoadFail){
-		for (group = 0 ; group < CHANNEL_GROUP_MAX ; group++){
-			for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
+	if (AutoLoadFail) {
+		for (group = 0 ; group < CHANNEL_GROUP_MAX ; group++) {
+			for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++) {
 				if (group< CHANNEL_GROUP_MAX_2G)
 				{
 					pwrInfo->CCKIndex[rfPath][group]		= EEPROM_Default_TxPowerLevel_2G;
@@ -808,8 +808,8 @@ hal_ReadPowerValueFromPROM92D(
 
 	//Maybe autoload OK,buf the tx power index vlaue is not filled.
 	//If we find it,we set it default value.
-	for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
-		for (group = 0 ; group < CHANNEL_GROUP_MAX_2G; group++){
+	for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++) {
+		for (group = 0 ; group < CHANNEL_GROUP_MAX_2G; group++) {
 			eeAddr = EEPROM_CCK_TX_PWR_INX_2G + (rfPath * 3) + group;
 			pwrInfo->CCKIndex[rfPath][group] =
 				(PROMContent[eeAddr] == 0xFF)?(eeAddr>0x7B?EEPROM_Default_TxPowerLevel_5G:EEPROM_Default_TxPowerLevel_2G):PROMContent[eeAddr];
@@ -817,8 +817,8 @@ hal_ReadPowerValueFromPROM92D(
 				pHalData->bNOPG = true;
 		}
 	}
-	for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
-		for (group = 0 ; group < CHANNEL_GROUP_MAX ; group++){
+	for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++) {
+		for (group = 0 ; group < CHANNEL_GROUP_MAX ; group++) {
 			offset1 = group / 3;
 			offset2 = group % 3;
 			eeAddr = EEPROM_HT40_1S_TX_PWR_INX_2G+ (rfPath * 3) + offset2 + offset1*21;
@@ -828,8 +828,8 @@ hal_ReadPowerValueFromPROM92D(
 	}
 
 	//These just for 92D efuse offset.
-	for (group = 0 ; group < CHANNEL_GROUP_MAX ; group++){
-		for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
+	for (group = 0 ; group < CHANNEL_GROUP_MAX ; group++) {
+		for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++) {
 			offset1 = group / 3;
 			offset2 = group % 3;
 
@@ -874,7 +874,7 @@ hal_ReadPowerValueFromPROM92D(
 		}
 	}
 
-	if (PROMContent[EEPROM_TSSI_A_5G] != 0xFF){
+	if (PROMContent[EEPROM_TSSI_A_5G] != 0xFF) {
 		//5GL
 		pwrInfo->TSSI_A_5G[0] = PROMContent[EEPROM_TSSI_A_5G] & 0x3F;	//[0:5]
 		pwrInfo->TSSI_B_5G[0] = PROMContent[EEPROM_TSSI_B_5G] & 0x3F;
@@ -1031,8 +1031,8 @@ rtl8192d_ReadTxPowerInfo(
 	//RTPRINT(FINIT, INIT_TxPower, ("CrystalCap = 0x%x\n", pHalData->CrystalCap));
 	//RTPRINT(FINIT, INIT_TxPower, ("Delta_IQK = 0x%x Delta_LCK = 0x%x\n", pHalData->Delta_IQK, pHalData->Delta_LCK));
 
-	for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
-		for (ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
+	for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++) {
+		for (ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++) {
 			group = Hal_GetChnlGroupfromArray((u8)ch);
 
 			if (ch < CHANNEL_MAX_NUMBER_2G)
@@ -1053,8 +1053,8 @@ rtl8192d_ReadTxPowerInfo(
 
 #if DBG
 
-	for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
-		for (ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
+	for (rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++) {
+		for (ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++) {
 			if (ch < CHANNEL_MAX_NUMBER_2G)
 			{
 				DBG_8192D("RF(%d)-Ch(%d) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\n",
@@ -1073,19 +1073,19 @@ rtl8192d_ReadTxPowerInfo(
 		}
 	}
 
-	for (ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
+	for (ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++) {
 		DBG_8192D("RF-A Ht20 to HT40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrHt20Diff[RF_PATH_A][ch]);
 	}
 
-	for (ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
+	for (ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++) {
 		DBG_8192D("RF-A Legacy to Ht40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrLegacyHtDiff[RF_PATH_A][ch]);
 	}
 
-	for (ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
+	for (ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++) {
 		DBG_8192D("RF-B Ht20 to HT40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrHt20Diff[RF_PATH_B][ch]);
 	}
 
-	for (ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
+	for (ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++) {
 		DBG_8192D("RF-B Legacy to HT40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrLegacyHtDiff[RF_PATH_B][ch]);
 	}
 
@@ -1163,7 +1163,7 @@ PHY_CheckPowerOffFor8192D(
 	}
 
 	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
-	if (pHalData->interfaceIndex == 0){
+	if (pHalData->interfaceIndex == 0) {
 		u1bTmp = rtw_read8(Adapter, REG_MAC0);
 		rtw_write8(Adapter, REG_MAC0, u1bTmp&(~MAC0_ON));
 		u1bTmp = rtw_read8(Adapter, REG_MAC1);
@@ -1305,12 +1305,12 @@ rtl8192d_EfusePowerSwitch(
 
 		// Clock: Gated(0x0008h[5]) 8M(0x0008h[1]) clock from ANA, default valid
 		tmpV16 = rtw_read16(pAdapter, REG_SYS_CLKR);
-		if ((!(tmpV16 & LOADER_CLK_EN)) || (!(tmpV16 & ANA8M))){
+		if ((!(tmpV16 & LOADER_CLK_EN)) || (!(tmpV16 & ANA8M))) {
 			tmpV16 |= (LOADER_CLK_EN | ANA8M);
 			rtw_write16(pAdapter, REG_SYS_CLKR, tmpV16);
 		}
 
-		if (bWrite == true){
+		if (bWrite == true) {
 			// Enable LDO 2.5V before read/write action
 			tempval = rtw_read8(pAdapter, EFUSE_TEST+3);
 			tempval &= 0x0F;
@@ -1516,7 +1516,7 @@ hal_EfuseUpdateNormalChipVersion_92D(
 	ReadEFuseByte(Adapter,EEPROME_CHIP_VERSION_L,&CutValue[0], false);
 
 	ChipValue= (CutValue[1]<<8)|CutValue[0];
-	switch (ChipValue){
+	switch (ChipValue) {
 		case 0xAA55:
 			//ChipVer |= CHIP_92D_C_CUT;
 			ChipVer = (enum VERSION_8192D)(ChipVer | C_CUT_VERSION);
@@ -1774,29 +1774,29 @@ rtl8192d_Efuse_PgPacketRead(	struct rtw_
 				word_cnts = Efuse_CalculateWordCnts(hworden);
 				bDataEmpty = true ;
 
-				if (hoffset==offset){
-					for (tmpidx = 0;tmpidx< word_cnts*2 ;tmpidx++){
-						if (efuse_OneByteRead(pAdapter, efuse_addr+1+tmpidx ,&efuse_data, bPseudoTest)){
+				if (hoffset==offset) {
+					for (tmpidx = 0;tmpidx< word_cnts*2 ;tmpidx++) {
+						if (efuse_OneByteRead(pAdapter, efuse_addr+1+tmpidx ,&efuse_data, bPseudoTest)) {
 							tmpdata[tmpidx] = efuse_data;
-							if (efuse_data!=0xff){
+							if (efuse_data!=0xff) {
 								bDataEmpty = false;
 							}
 						}
 					}
-					if (bDataEmpty==false){
+					if (bDataEmpty==false) {
 						ReadState = PG_STATE_DATA;
-					}else{//read next header
+					} else {//read next header
 						efuse_addr = efuse_addr + (word_cnts*2)+1;
 						ReadState = PG_STATE_HEADER;
 					}
 				}
-				else{//read next header
+				else {//read next header
 					efuse_addr = efuse_addr + (word_cnts*2)+1;
 					ReadState = PG_STATE_HEADER;
 				}
 
 			}
-			else{
+			else {
 				bContinual = false ;
 			}
 		}
@@ -1941,7 +1941,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 					//************  so-2 *******************
 					for (tmpindex=0 ; tmpindex<(tmp_word_cnts*2) ; tmpindex++)
 					{
-						if (efuse_OneByteRead(pAdapter, (efuse_addr+1+tmpindex) ,&efuse_data, bPseudoTest)&&(efuse_data != 0xFF)){
+						if (efuse_OneByteRead(pAdapter, (efuse_addr+1+tmpindex) ,&efuse_data, bPseudoTest)&&(efuse_data != 0xFF)) {
 							bDataEmpty = false;
 						}
 					}
@@ -2012,7 +2012,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 							}
 
 							//************  so-2-2-A-2 *******************
-							if ((tmp_word_en&0x0F)!=0x0F){
+							if ((tmp_word_en&0x0F)!=0x0F) {
 								//reorganize other pg packet
 //								efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr
 								efuse_addr = Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest);
@@ -2020,19 +2020,19 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 								target_pkt.offset = offset;
 								target_pkt.word_en= tmp_word_en;
 								//===========================
-							}else{
+							} else {
 								bContinual = false;
 							}
 #if (EFUSE_ERROE_HANDLE == 1)
 							WriteState=PG_STATE_HEADER;
 							repeat_times++;
-							if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
+							if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
 								bContinual = false;
 								bResult = false;
 							}
 #endif
 						}
-						else{//************  so-2-2-B *******************
+						else {//************  so-2-2-B *******************
 							//reorganize other pg packet
 							efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr
 							//===========================
@@ -2066,7 +2066,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 
 						repeat_times++;
 
-						if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
+						if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
 							bContinual = false;
 							bResult = false;
 							efuse_addr++;
@@ -2094,7 +2094,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 						{
 							repeat_times++;
 
-							if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
+							if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
 								bContinual = false;
 								bResult = false;
 								break;
@@ -2110,7 +2110,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 						{
 							repeat_times++;
 
-							if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
+							if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
 								bContinual = false;
 								bResult = false;
 								break;
@@ -2147,11 +2147,11 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 					WriteState = PG_STATE_DATA;
 				}
 #if (EFUSE_ERROE_HANDLE == 1)
-				else if (tmp_header == 0xFF){//************  s1-3: if Write or read func doesn't work *******************
+				else if (tmp_header == 0xFF) {//************  s1-3: if Write or read func doesn't work *******************
 					//efuse_addr doesn't change
 					WriteState = PG_STATE_HEADER;
 					repeat_times++;
-					if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
+					if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
 						bContinual = false;
 						bResult = false;
 					}
@@ -2183,7 +2183,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 							efuse_addr = Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest);
 						}
 						//############################
-						else{
+						else {
 							efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet
 						}
 					}
@@ -2196,7 +2196,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 #if (EFUSE_ERROE_HANDLE == 1)
 					WriteState=PG_STATE_HEADER;
 					repeat_times++;
-					if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
+					if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
 						bContinual = false;
 						bResult = false;
 					}
@@ -2230,7 +2230,7 @@ rtl8192d_Efuse_PgPacketWrite(struct rtw_
 #if (EFUSE_ERROE_HANDLE == 1)
 				WriteState=PG_STATE_HEADER;
 				repeat_times++;
-				if (repeat_times>EFUSE_REPEAT_THRESHOLD_){
+				if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
 					bContinual = false;
 					bResult = false;
 				}
@@ -2275,7 +2275,7 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 
 		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[0], bPseudoTest);
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[1], bPseudoTest);
-		if ((data[0]!=tmpdata[0])||(data[1]!=tmpdata[1])){
+		if ((data[0]!=tmpdata[0])||(data[1]!=tmpdata[1])) {
 			badworden &= (~BIT0);
 		}
 	}
@@ -2287,7 +2287,7 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 
 		efuse_OneByteRead(pAdapter,tmpaddr    , &tmpdata[2], bPseudoTest);
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[3], bPseudoTest);
-		if ((data[2]!=tmpdata[2])||(data[3]!=tmpdata[3])){
+		if ((data[2]!=tmpdata[2])||(data[3]!=tmpdata[3])) {
 			badworden &=(~BIT1);
 		}
 	}
@@ -2299,7 +2299,7 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 
 		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[4], bPseudoTest);
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[5], bPseudoTest);
-		if ((data[4]!=tmpdata[4])||(data[5]!=tmpdata[5])){
+		if ((data[4]!=tmpdata[4])||(data[5]!=tmpdata[5])) {
 			badworden &=(~BIT2);
 		}
 	}
@@ -2311,7 +2311,7 @@ rtl8192d_Efuse_WordEnableDataWrite(	stru
 
 		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[6], bPseudoTest);
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[7], bPseudoTest);
-		if ((data[6]!=tmpdata[6])||(data[7]!=tmpdata[7])){
+		if ((data[6]!=tmpdata[6])||(data[7]!=tmpdata[7])) {
 			badworden &=(~BIT3);
 		}
 	}
--- a/drivers/staging/rtl8192du/hal/rtl8192d_mp.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_mp.c
@@ -1207,7 +1207,7 @@ void
 
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
 		{
-			if (bNeedPowerDownRadio){
+			if (bNeedPowerDownRadio) {
 				phy_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
 			PHY_PowerDownAnotherPHY(Adapter, true);
--- a/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_phycfg.c
@@ -715,7 +715,7 @@ phy_ConfigMACWithHeaderFile(
 	ptrArray = (u32 *)Rtl8192D_MAC_Array;
 	//RT_TRACE(COMP_INIT, DBG_LOUD, (" ===> phy_ConfigMACWithHeaderFile() Img:Rtl819XMAC_Array\n"));
 
-	for (i = 0 ;i < ArrayLength;i=i+2){ // Add by tynli for 2 column
+	for (i = 0 ;i < ArrayLength;i=i+2) { // Add by tynli for 2 column
 		rtw_write8(Adapter, ptrArray[i], (u8)ptrArray[i+1]);
 	}
 
@@ -748,7 +748,7 @@ PHY_MACConfig8192D(
 	char		sz92DMACRegFile[] = RTL8192D_PHY_MACREG;
 	int		rtStatus = _SUCCESS;
 
-	if (Adapter->bSurpriseRemoved){
+	if (Adapter->bSurpriseRemoved) {
 		rtStatus = _FAIL;
 		return rtStatus;
 	}
@@ -962,7 +962,7 @@ phy_ConfigBBWithHeaderFile(
 	{
 		for (i=0;i<PHY_REGArrayLen;i=i+2)
 		{
-			if (Rtl819XPHY_REGArray_Table[i] == 0xfe || Rtl819XPHY_REGArray_Table[i] == 0xffe){
+			if (Rtl819XPHY_REGArray_Table[i] == 0xfe || Rtl819XPHY_REGArray_Table[i] == 0xffe) {
 				#ifdef CONFIG_LONG_DELAY_ISSUE
 				rtw_msleep_os(50);
 				#else
@@ -1424,7 +1424,7 @@ phy_BB8192D_Config_ParaFile(
 	rtStatus = phy_ConfigBBWithParaFile(Adapter,pszBBRegFile);
 #endif
 
-	if (rtStatus != _SUCCESS){
+	if (rtStatus != _SUCCESS) {
 		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():Write BB Reg Fail!!"));
 		goto phy_BB8190_Config_ParaFile_Fail;
 	}
@@ -1442,7 +1442,7 @@ phy_BB8192D_Config_ParaFile(
 	rtStatus = phy_ConfigBBWithMpParaFile(Adapter,pszBBRegMpFile);
 #endif
 
-	if (rtStatus != _SUCCESS){
+	if (rtStatus != _SUCCESS) {
 		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():Write BB Reg MP Fail!!"));
 		goto phy_BB8190_Config_ParaFile_Fail;
 	}
@@ -1463,7 +1463,7 @@ phy_BB8192D_Config_ParaFile(
 #endif
 	}
 
-	if (rtStatus != _SUCCESS){
+	if (rtStatus != _SUCCESS) {
 		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():BB_PG Reg Fail!!"));
 		goto phy_BB8190_Config_ParaFile_Fail;
 	}
@@ -1488,7 +1488,7 @@ phy_BB8192D_Config_ParaFile(
 	rtStatus = phy_ConfigBBWithParaFile(Adapter, pszAGCTableFile);
 #endif
 
-	if (rtStatus != _SUCCESS){
+	if (rtStatus != _SUCCESS) {
 		//RT_TRACE(COMP_FPGA, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():AGC Table Fail\n"));
 		goto phy_BB8190_Config_ParaFile_Fail;
 	}
@@ -1514,7 +1514,7 @@ PHY_BBConfig8192D(
 	u8	value;
 	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
 
-	if (Adapter->bSurpriseRemoved){
+	if (Adapter->bSurpriseRemoved) {
 		rtStatus = _FAIL;
 		return rtStatus;
 	}
@@ -1601,7 +1601,7 @@ PHY_RFConfig8192D(
 	//struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 	int		rtStatus = _SUCCESS;
 
-	if (Adapter->bSurpriseRemoved){
+	if (Adapter->bSurpriseRemoved) {
 		rtStatus = _FAIL;
 		return rtStatus;
 	}
@@ -1710,7 +1710,7 @@ rtl8192d_PHY_ConfigRFWithHeaderFile(
 		Rtl819XRadioA_Array_Table = Rtl819XRadioB_Array_Table;
 	}
 
-	switch (eRFPath){
+	switch (eRFPath) {
 		case RF_PATH_A:
 			for (i = 0;i<RadioA_ArrayLen; i=i+2)
 			{
@@ -2951,7 +2951,7 @@ PHY_RestoreRFENV(
 #endif
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
 		{
-			if (bNeedPowerDownRadio){
+			if (bNeedPowerDownRadio) {
 				PHY_RestoreRFENV(Adapter, path,MaskforPhySet, &u4RegValue);
 			}
 			rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
@@ -3024,7 +3024,7 @@ static  void
 
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_SYN_G4|MaskforPhySet, 0x3f800, u4tmp);
 
-			if (bNeedPowerDownRadio){
+			if (bNeedPowerDownRadio) {
 				PHY_RestoreRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
 				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, false);
 			}
@@ -3047,7 +3047,7 @@ static  void
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_SYN_G4|MaskforPhySet, 0x3f800, u4tmp);
 			//RTPRINT(FINIT, INIT_IQK, ("cosa ver 3 set RF-B, 2G, 0x28 = 0x%lx !!\n", PHY_QueryRFReg(Adapter, (enum RF_RADIO_PATH_E) eRFPath, RF_SYN_G4|MaskforPhyAccess, 0x3f800)));
 
-			if (bNeedPowerDownRadio){
+			if (bNeedPowerDownRadio) {
 				PHY_RestoreRFENV(Adapter, eRFPath,MaskforPhySet, &u4RegValue);
 				rtl8192d_PHY_PowerDownAnotherPHY(Adapter, true);
 			}
@@ -3108,23 +3108,23 @@ static  void
 		group = channel<=64?1:2; //leave 0 for channel1-14.
 		IMR_NUM = MAX_RF_IMR_INDEX_NORMAL;
 
-		for (i=0; i<IMR_NUM; i++){
+		for (i=0; i<IMR_NUM; i++) {
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_REG_FOR_5G_SWCHNL_NORMAL[i], RFMask,RF_IMR_Param_Normal[0][group][i]);
 		}
 		PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,0);
 		PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 2);
 	}
-	else{ //G band.
+	else { //G band.
 		//RT_TRACE(COMP_SCAN,DBG_LOUD,("Load RF IMR parameters for G band. IMR already setting %d\n",pMgntInfo->bLoadIMRandIQKSettingFor2G));
 
-		if (!pHalData->bLoadIMRandIQKSettingFor2G){
+		if (!pHalData->bLoadIMRandIQKSettingFor2G) {
 			//RT_TRACE(COMP_SCAN,DBG_LOUD,("Load RF IMR parameters for G band. %d\n",eRFPath));
 			//AcquireCCKAndRWPageAControl(Adapter);
 			PHY_SetBBReg1Byte(Adapter, rFPGA0_RFMOD, BIT25|BIT24, 0);
 			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,	0xf);
 
 			IMR_NUM = MAX_RF_IMR_INDEX_NORMAL;
-			for (i=0; i<IMR_NUM; i++){
+			for (i=0; i<IMR_NUM; i++) {
 				PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_REG_FOR_5G_SWCHNL_NORMAL[i], bRFRegOffsetMask,RF_IMR_Param_Normal[0][0][i]);
 			}
 			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter4, 0x00f00000,0);
@@ -3234,7 +3234,7 @@ static void _PHY_SwChnl8192D(struct rtw_
 		DBG_8192D("[%s] ch = %d\n", __func__, channel);
 	}
 
-	if (pHalData->BandSet92D == BAND_ON_BOTH){
+	if (pHalData->BandSet92D == BAND_ON_BOTH) {
 		// Need change band?
 		// BB {Reg878[0],[16]} bit0= 1 is 5G, bit0=0 is 2G.
 		ret_value = PHY_QueryBBReg(Adapter, rFPGA0_XAB_RFParameter, bMaskDWord);
@@ -3426,7 +3426,7 @@ PHY_SwChnl8192D(	// Call after initializ
 	//--------------------------------------------
 
 	//pHalData->SwChnlInProgress = TRUE;
-	if (channel == 0){//FIXME!!!A band?
+	if (channel == 0) {//FIXME!!!A band?
 		channel = 1;
 	}
 
@@ -4277,7 +4277,7 @@ phy_SaveADDARegisters(
 	//	return;
 
 	//RTPRINT(FINIT, INIT_IQK, ("Save ADDA parameters.\n"));
-	for (i = 0 ; i < RegisterNum ; i++){
+	for (i = 0 ; i < RegisterNum ; i++) {
 		ADDABackup[i] = PHY_QueryBBReg(pAdapter, ADDAReg[i], bMaskDWord);
 	}
 }
@@ -4292,7 +4292,7 @@ phy_SaveMACRegisters(
 	u32	i;
 
 	//RTPRINT(FINIT, INIT_IQK, ("Save MAC parameters.\n"));
-	for (i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
+	for (i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++) {
 		MACBackup[i] = rtw_read8(pAdapter, MACReg[i]);
 	}
 	MACBackup[i] = rtw_read32(pAdapter, MACReg[i]);
@@ -4309,7 +4309,7 @@ phy_ReloadADDARegisters(
 	u32	i;
 
 	//RTPRINT(FINIT, INIT_IQK, ("Reload ADDA power saving parameters !\n"));
-	for (i = 0 ; i < RegiesterNum ; i++){
+	for (i = 0 ; i < RegiesterNum ; i++) {
 		//path-A/B BB to initial gain
 		if (ADDAReg[i] == rOFDM0_XAAGCCore1 || ADDAReg[i] == rOFDM0_XBAGCCore1)
 			PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, 0x50);
@@ -4327,7 +4327,7 @@ phy_ReloadMACRegisters(
 	u32	i;
 
 	//RTPRINT(FINIT, INIT_IQK, ("Reload MAC parameters !\n"));
-	for (i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
+	for (i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++) {
 		rtw_write8(pAdapter, MACReg[i], (u8)MACBackup[i]);
 	}
 	rtw_write32(pAdapter, MACReg[i], MACBackup[i]);
@@ -4353,7 +4353,7 @@ phy_PathADDAOn(
 	if (isPathAOn)     // Neil Chen
 		pathOn = pHalData->interfaceIndex == 0? 0x04db25a4 : 0x0b1b25a4;
 
-	for (i = 0 ; i < IQK_ADDA_REG_NUM ; i++){
+	for (i = 0 ; i < IQK_ADDA_REG_NUM ; i++) {
 		PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, pathOn);
 	}
 }
@@ -4371,7 +4371,7 @@ phy_MACSettingCalibration(
 
 	rtw_write8(pAdapter, MACReg[i], 0x3F);
 
-	for (i = 1 ; i < (IQK_MAC_REG_NUM - 1); i++){
+	for (i = 1 ; i < (IQK_MAC_REG_NUM - 1); i++) {
 		rtw_write8(pAdapter, MACReg[i], (u8)(MACBackup[i]&(~BIT3)));
 	}
 	rtw_write8(pAdapter, MACReg[i], (u8)(MACBackup[i]&(~BIT5)));
@@ -4583,7 +4583,7 @@ phy_IQCalibrate(
 		pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
 	}
 
-	if (!pdmpriv->bRfPiEnable){
+	if (!pdmpriv->bRfPiEnable) {
 		// Switch BB to PI mode to do IQ Calibration.
 		phy_PIModeSwitch(pAdapter, true);
 	}
@@ -4637,9 +4637,9 @@ phy_IQCalibrate(
 	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x01007c00);
 	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
 
-	for (i = 0 ; i < retryCount ; i++){
+	for (i = 0 ; i < retryCount ; i++) {
 		PathAOK = phy_PathA_IQK(pAdapter, is2T);
-		if (PathAOK == 0x03){
+		if (PathAOK == 0x03) {
 			//RTPRINT(FINIT, INIT_IQK, ("Path A IQK Success!!\n"));
 			result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
@@ -4656,19 +4656,19 @@ phy_IQCalibrate(
 		}
 	}
 
-	if (0x00 == PathAOK){
+	if (0x00 == PathAOK) {
 		DBG_8192D("Path A IQK failed!!\n");
 	}
 
-	if (is2T){
+	if (is2T) {
 		phy_PathAStandBy(pAdapter);
 
 		// Turn Path B ADDA on
 		phy_PathADDAOn(pAdapter, ADDA_REG, false, is2T);
 
-		for (i = 0 ; i < retryCount ; i++){
+		for (i = 0 ; i < retryCount ; i++) {
 			PathBOK = phy_PathB_IQK(pAdapter);
-			if (PathBOK == 0x03){
+			if (PathBOK == 0x03) {
 				//RTPRINT(FINIT, INIT_IQK, ("Path B IQK Success!!\n"));
 				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
@@ -4684,7 +4684,7 @@ phy_IQCalibrate(
 			}
 		}
 
-		if (0x00 == PathBOK){
+		if (0x00 == PathBOK) {
 			DBG_8192D("Path B IQK failed!!\n");
 		}
 	}
@@ -4695,7 +4695,7 @@ phy_IQCalibrate(
 
 	if (t!=0)
 	{
-		if (!pdmpriv->bRfPiEnable){
+		if (!pdmpriv->bRfPiEnable) {
 			// Switch back BB to SI mode after finish IQ Calibration.
 			phy_PIModeSwitch(pAdapter, false);
 		}
@@ -4721,7 +4721,7 @@ phy_IQCalibrate(
 		{
 			// Restore RX initial gain
 			PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032ed3);
-			if (is2T){
+			if (is2T) {
 				PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032ed3);
 			}
 		}
@@ -5205,7 +5205,7 @@ phy_IQCalibrate_5G_Normal(
 		pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(pAdapter, rFPGA0_XA_HSSIParameter1, BIT(8));
 	}
 
-	if (!pdmpriv->bRfPiEnable){
+	if (!pdmpriv->bRfPiEnable) {
 		// Switch BB to PI mode to do IQ Calibration.
 		phy_PIModeSwitch(pAdapter, true);
 	}
@@ -5232,7 +5232,7 @@ phy_IQCalibrate_5G_Normal(
 
 	{
 		PathAOK = phy_PathA_IQK_5G_Normal(pAdapter, is2T);
-		if (PathAOK == 0x03){
+		if (PathAOK == 0x03) {
 			DBG_8192D("Path A IQK Success!!\n");
 			result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
 			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
@@ -5256,7 +5256,7 @@ phy_IQCalibrate_5G_Normal(
 		}
 	}
 
-	if (is2T){
+	if (is2T) {
 		//_PHY_PathAStandBy(pAdapter);
 
 		// Turn Path B ADDA on
@@ -5264,7 +5264,7 @@ phy_IQCalibrate_5G_Normal(
 
 		{
 			PathBOK = phy_PathB_IQK_5G_Normal(pAdapter);
-			if (PathBOK == 0x03){
+			if (PathBOK == 0x03) {
 				DBG_8192D("Path B IQK Success!!\n");
 				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
@@ -5277,7 +5277,7 @@ phy_IQCalibrate_5G_Normal(
 				result[t][4] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 				result[t][5] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
 			}
-			else{
+			else {
 				DBG_8192D("Path B IQK failed!!\n");
 			}
 		}
@@ -5306,7 +5306,7 @@ phy_IQCalibrate_5G_Normal(
 		// Reload MAC parameters
 		phy_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
-		if (!pdmpriv->bRfPiEnable){
+		if (!pdmpriv->bRfPiEnable) {
 			// Switch back BB to SI mode after finish IQ Calibration.
 			phy_PIModeSwitch(pAdapter, false);
 		}
@@ -6377,7 +6377,7 @@ rtl8192d_PHY_LCCalibrate(
 	{
 		phy_LCCalibrate(pAdapter, true);
 	}
-	else{
+	else {
 		// For 88C 1T1R
 		phy_LCCalibrate(pAdapter, false);
 	}
@@ -6406,10 +6406,10 @@ rtl8192d_PHY_APCalibrate(
 	if (pdmpriv->bAPKdone)
 		return;
 
-	if (IS_92D_SINGLEPHY(pHalData->VersionID)){
+	if (IS_92D_SINGLEPHY(pHalData->VersionID)) {
 		phy_APCalibrate(pAdapter, delta, true);
 	}
-	else{
+	else {
 		// For 88C 1T1R
 		phy_APCalibrate(pAdapter, delta, false);
 	}
@@ -6613,14 +6613,14 @@ PHY_UpdateBBRFConfiguration8192D(
 	//Update RF
 	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 	{
-		if (pHalData->CurrentBandType92D == BAND_ON_2_4G){
+		if (pHalData->CurrentBandType92D == BAND_ON_2_4G) {
 			//MOD_AG for RF paht_A 0x18 BIT8,BIT16
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT8|BIT16|BIT18|0xFF, 1);
 
 			//RF0x0b[16:14] =3b'111
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_TXPA_AG, 0x1c000, 0x07);
 		}
-		else{ //5G band
+		else { //5G band
 			//MOD_AG for RF paht_A 0x18 BIT8,BIT16
 			PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x97524); //set channel 36
 
@@ -6803,7 +6803,7 @@ void PHY_ConfigMacPhyMode92D(
 
 	temp = rtw_read8(Adapter, offset);
 	temp &= ~(BIT(0)|BIT(1)|BIT(2));
-	switch (pHalData->MacPhyMode92D){
+	switch (pHalData->MacPhyMode92D) {
 		case DUALMAC_DUALPHY:
 			MSG_8192D("MacPhyMode: DUALMAC_DUALPHY\n");
 			rtw_write8(Adapter, offset, temp | BIT(0)|BIT(1));
@@ -6841,7 +6841,7 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 	struct hal_data_8192du *pHalDataBuddyAdapter;
 #endif
 
-	switch (pHalData->MacPhyMode92D){
+	switch (pHalData->MacPhyMode92D) {
 		case DUALMAC_SINGLEPHY:
 			pHalData->rf_type = RF_2T2R;
 			pHalData->VersionID = (enum VERSION_8192D)(pHalData->VersionID | RF_TYPE_2T2R);
@@ -6886,11 +6886,11 @@ void PHY_ConfigMacPhyModeInfo92D(struct
 		case DUALMAC_DUALPHY:
 			pHalData->rf_type = RF_1T1R;
 			pHalData->VersionID = (enum VERSION_8192D)(pHalData->VersionID & RF_TYPE_1T1R);
-			if (pHalData->interfaceIndex == 1){
+			if (pHalData->interfaceIndex == 1) {
 				pHalData->BandSet92D = BAND_ON_5G;
 				pHalData->CurrentBandType92D = BAND_ON_5G;//Now we let MAC1 run on 5G band.
 			}
-			else{
+			else {
 				pHalData->BandSet92D = BAND_ON_2_4G;
 				pHalData->CurrentBandType92D = BAND_ON_2_4G;//
 			}
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rf6052.c
@@ -803,7 +803,7 @@ phy_RF6052_Config_ParaFile(
 				break;
 		}
 
-		if (rtStatus != _SUCCESS){
+		if (rtStatus != _SUCCESS) {
 			//RT_TRACE(COMP_FPGA, DBG_LOUD, ("phy_RF6052_Config_ParaFile():Radio[%d] Fail!!", eRFPath));
 			goto phy_RF6052_Config_ParaFile_Fail;
 		}
--- a/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_rxdesc.c
@@ -486,7 +486,7 @@ static void process_link_qual(struct rtw
 	struct signal_stat * signal_stat;
 #endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
 
-	if (prframe == NULL || padapter==NULL){
+	if (prframe == NULL || padapter==NULL) {
 		return;
 	}
 
@@ -638,7 +638,7 @@ void rtl8192d_query_rx_desc_status(union
 
 	//Offset 12
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
-	if (le32_to_cpu(pdesc->rxdw3) & BIT(13)){
+	if (le32_to_cpu(pdesc->rxdw3) & BIT(13)) {
 		pattrib->tcpchk_valid = 1; // valid
 		if (le32_to_cpu(pdesc->rxdw3) & BIT(11)) {
 			pattrib->tcp_chkrpt = 1; // correct
--- a/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_recv.c
@@ -69,11 +69,11 @@ int	rtl8192du_init_recv_priv(struct rtw_
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
 
 	precvpriv->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);
-	if (precvpriv->int_in_urb == NULL){
+	if (precvpriv->int_in_urb == NULL) {
 		DBG_8192D("alloc_urb for interrupt in endpoint fail !!!!\n");
 	}
 	precvpriv->int_in_buf = rtw_malloc(sizeof(INTERRUPT_MSG_FORMAT_EX));
-	if (precvpriv->int_in_buf == NULL){
+	if (precvpriv->int_in_buf == NULL) {
 		DBG_8192D("alloc_mem for interrupt in endpoint fail !!!!\n");
 	}
 #endif //CONFIG_USB_INTERRUPT_IN_PIPE
@@ -82,7 +82,7 @@ int	rtl8192du_init_recv_priv(struct rtw_
 	_rtw_init_queue(&precvpriv->free_recv_buf_queue);
 
 	precvpriv->pallocated_recv_buf = rtw_zmalloc(NR_RECVBUFF *sizeof(struct recv_buf) + 4);
-	if (precvpriv->pallocated_recv_buf==NULL){
+	if (precvpriv->pallocated_recv_buf==NULL) {
 		res= _FAIL;
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("alloc recv_buf fail!\n"));
 		goto exit;
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -120,7 +120,7 @@ void rtl8192du_cal_txdesc_chksum(struct
 		//Clear first
 		ptxdesc->txdw7 &= cpu_to_le32(0xffff0000);
 
-		for (index = 0 ; index < count ; index++){
+		for (index = 0 ; index < count ; index++) {
 			checksum = checksum ^ le16_to_cpu(*(usPtr + index));
 		}
 
@@ -284,12 +284,12 @@ if (padapter->registrypriv.mp_mode == 0)
 
 		fill_txdesc_sectype(pattrib, ptxdesc);
 
-		if (pattrib->ampdu_en==true){
+		if (pattrib->ampdu_en==true) {
 			ptxdesc->txdw1 |= cpu_to_le32(BIT(5));//AGG EN
 			//Insert Early Mode Content after tx desc position.
-			if ((pHalData->bEarlyModeEnable) && (true == bagg_pkt)){
+			if ((pHalData->bEarlyModeEnable) && (true == bagg_pkt)) {
 				ptxdesc->txdw0 |= cpu_to_le32(((USB_HWDESC_HEADER_LEN-8) << OFFSET_SHT) & 0x00ff0000);//32 bytes for TX Desc
-				if (pxmitframe->EMPktNum > 0){
+				if (pxmitframe->EMPktNum > 0) {
 					InsertEMContent(pxmitframe, pmem+TXDESC_SIZE);
 				}
 			}
--- a/drivers/staging/rtl8192du/hal/usb_halinit.c
+++ b/drivers/staging/rtl8192du/hal/usb_halinit.c
@@ -87,7 +87,7 @@ _TwoOutEpMapping(
 	)
 {
 
-	if (bWIFICfg){ // Normal chip && wmm
+	if (bWIFICfg) { // Normal chip && wmm
 
 		//	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA
 		//{  0,		1,	0,	1,	0,	0,	0,	0,		0	};
@@ -104,7 +104,7 @@ _TwoOutEpMapping(
 		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];//BCN
 
 	}
-	else{//typical setting
+	else {//typical setting
 
 
 		//BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA
@@ -130,7 +130,7 @@ static void _ThreeOutEpMapping(
 	bool			bWIFICfg
 	)
 {
-	if (bWIFICfg){//for WMM
+	if (bWIFICfg) {//for WMM
 
 		//	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA
 		//{  1,		2,	1,	0,	0,	0,	0,	0,		0	};
@@ -147,7 +147,7 @@ static void _ThreeOutEpMapping(
 		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];//BCN
 
 	}
-	else{//typical setting
+	else {//typical setting
 
 
 		//	BK,	BE,	VI,	VO,	BCN,	CMD,MGT,HIGH,HCCA
@@ -216,12 +216,12 @@ _ConfigChipOutEP(
 	else
 		value8=rtw_read8(pAdapter, REG_USB_High_NORMAL_Queue_Select_MAC1);
 
-	if (value8 & USB_NORMAL_SIE_EP_MASK){
+	if (value8 & USB_NORMAL_SIE_EP_MASK) {
 		pHalData->OutEpQueueSel |= TX_SELE_HQ;
 		pHalData->OutEpNumber++;
 	}
 
-	if ((value8 >> USB_NORMAL_SIE_EP_SHIFT) & USB_NORMAL_SIE_EP_MASK){
+	if ((value8 >> USB_NORMAL_SIE_EP_SHIFT) & USB_NORMAL_SIE_EP_MASK) {
 		pHalData->OutEpQueueSel |= TX_SELE_NQ;
 		pHalData->OutEpNumber++;
 	}
@@ -232,13 +232,13 @@ _ConfigChipOutEP(
 	else
 		value8=rtw_read8(pAdapter, (REG_USB_High_NORMAL_Queue_Select_MAC1+1));
 
-	if (value8 & USB_NORMAL_SIE_EP_MASK){
+	if (value8 & USB_NORMAL_SIE_EP_MASK) {
 		pHalData->OutEpQueueSel |= TX_SELE_LQ;
 		pHalData->OutEpNumber++;
 	}
 
 	//add for 0xfe44 0xfe45 0xfe47 0xfe48 not validly
-	switch (NumOutPipe){
+	switch (NumOutPipe) {
 		case 3:
 			pHalData->OutEpQueueSel=TX_SELE_HQ| TX_SELE_LQ|TX_SELE_NQ;
 			pHalData->OutEpNumber=3;
@@ -271,8 +271,8 @@ static bool HalUsbSetQueuePipeMapping819
 	_ConfigChipOutEP(pAdapter, NumOutPipe);
 
 	// Normal chip with one IN and one OUT doesn't have interrupt IN EP.
-	if (1 == pHalData->OutEpNumber){
-		if (1 != NumInPipe){
+	if (1 == pHalData->OutEpNumber) {
+		if (1 != NumInPipe) {
 			return result;
 		}
 	}
@@ -332,19 +332,19 @@ static u8 _InitPowerOn(struct rtw_adapte
 	// polling autoload done.
 	u32	pollingCount = 0;
 
-	if (padapter->bSurpriseRemoved){
+	if (padapter->bSurpriseRemoved) {
 		return _FAIL;
 	}
 
 	pollingCount = 0;
 	do
 	{
-		if (rtw_read8(padapter, REG_APS_FSMCO) & PFM_ALDN){
+		if (rtw_read8(padapter, REG_APS_FSMCO) & PFM_ALDN) {
 			//RT_TRACE(COMP_INIT,DBG_LOUD,("Autoload Done!\n"));
 			break;
 		}
 
-		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT){
+		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT) {
 			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling REG_APS_FSMCO[PFM_ALDN] done!\n"));
 			return _FAIL;
 		}
@@ -360,7 +360,7 @@ static u8 _InitPowerOn(struct rtw_adapte
 	rtw_usleep_os(100);//PlatformSleepUs(150);//this is not necessary when initially power on
 
 	value8 = rtw_read8(padapter, REG_LDOV12D_CTRL);
-	if (0== (value8 & LDV12_EN)){
+	if (0== (value8 & LDV12_EN)) {
 		value8 |= LDV12_EN;
 		rtw_write8(padapter, REG_LDOV12D_CTRL, value8);
 		//RT_TRACE(COMP_INIT, DBG_LOUD, (" power-on :REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8));
@@ -378,12 +378,12 @@ static u8 _InitPowerOn(struct rtw_adapte
 
 	do
 	{
-		if (0 == (rtw_read16(padapter, REG_APS_FSMCO) & APFM_ONMAC)){
+		if (0 == (rtw_read16(padapter, REG_APS_FSMCO) & APFM_ONMAC)) {
 			//RT_TRACE(COMP_INIT,DBG_LOUD,("MAC auto ON okay!\n"));
 			break;
 		}
 
-		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT){
+		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT) {
 			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling REG_APS_FSMCO[APFM_ONMAC] done!\n"));
 			return _FAIL;
 		}
@@ -484,7 +484,7 @@ u16 calc_crc(u8 * pdata,int length)
 
 
 #ifdef CONFIG_WOWLAN
-static int rtw_wowlan_set_pattern(struct rtw_adapter *padapter ,u8* pbuf){
+static int rtw_wowlan_set_pattern(struct rtw_adapter *padapter ,u8* pbuf) {
 	struct pwrctrl_priv *pwrpriv=&padapter->pwrctrlpriv;
 	int res=0,crc_idx;
 	u32 content=0,cmd=0;
@@ -505,10 +505,10 @@ static int rtw_wowlan_set_pattern(struct
 
 	// Write to the Wakeup CAM
 	//offset 0
-	if (pattern_len>=4){
+	if (pattern_len>=4) {
 		content=pdata[1];
 	}
-	else{
+	else {
 		content=0;
 	}
 	DBG_8192D("\nrtw_wowlan_set_pattern offset[0]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
@@ -517,10 +517,10 @@ static int rtw_wowlan_set_pattern(struct
 	//cmd=BIT(31)|BIT(16)|(idx+0);
 	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 	//offset 4
-	if (pattern_len>=8){
+	if (pattern_len>=8) {
 		content=pdata[2];
 	}
-	else{
+	else {
 		content=0;
 	}
 	DBG_8192D("rtw_wowlan_set_pattern offset[4]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
@@ -530,10 +530,10 @@ static int rtw_wowlan_set_pattern(struct
 	//cmd=BIT(31)|BIT(16)|(idx+1);
 	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 	//offset 8
-	if (pattern_len>=12){
+	if (pattern_len>=12) {
 		content=pdata[3];
 	}
-	else{
+	else {
 		content=0;
 	}
 	DBG_8192D("rtw_wowlan_set_pattern offset[8]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
@@ -542,10 +542,10 @@ static int rtw_wowlan_set_pattern(struct
 	//cmd=BIT(31)|BIT(16)|(idx+2);
 	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 	//offset 12
-	if (pattern_len>=16){
+	if (pattern_len>=16) {
 		content=pdata[4];
 	}
-	else{
+	else {
 		content=0;
 	}
 	DBG_8192D("rtw_wowlan_set_pattern offset[12]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
@@ -554,18 +554,18 @@ static int rtw_wowlan_set_pattern(struct
 	//cmd=BIT(31)|BIT(16)|(idx+3);
 	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 
-	if (crc){
+	if (crc) {
 		// Have the CRC value
 		crc_val=*(u16 *)(&pbuf[2]);
 		DBG_8192D("rtw_wowlan_set_pattern crc_val  0x%x \n", crc_val);
 		crc_val=__cpu_to_le16(crc_val);
 		DBG_8192D("rtw_wowlan_set_pattern crc_val  after 0x%x \n", crc_val);
 	}
-	else{
+	else {
 		DBG_8192D("+rtw_wowlan_set_pattern   crc=0[%x]  Should calculate the CRC\n", crc);
 		// calculate the CRC the write to the Wakeup CAM
 		crc_idx=0;
-		for (i=0;i<packet_len;i++){
+		for (i=0;i<packet_len;i++) {
 			if (pbuf[4+(i/8)]&(0x01<<(i%8)))
 			{
 				packet[crc_idx++]=pbuf[20+i];
@@ -592,13 +592,13 @@ _rtw_wowlan_set_pattern_exit:
 
 
 
-void rtw_wowlan_reload_pattern(struct rtw_adapter *padapter){
+void rtw_wowlan_reload_pattern(struct rtw_adapter *padapter) {
 	struct pwrctrl_priv *pwrpriv=&padapter->pwrctrlpriv;
 	u32 content=0,cmd=0;
 	u8 idx;
 
-	for (idx=0;idx<8;idx ++){
-		if (pwrpriv->wowlan_pattern_idx & BIT(idx)){
+	for (idx=0;idx<8;idx ++) {
+		if (pwrpriv->wowlan_pattern_idx & BIT(idx)) {
 			//offset 0
 			rtw_write32(padapter, REG_WKFMCAM_RWD, pwrpriv->wowlan_pattern_context[idx][0]);
 			cmd=BIT(31)|BIT(16)|(idx+0);
@@ -669,11 +669,11 @@ static u8 _LLTWrite(
 	do{
 
 		value = rtw_read32(Adapter, REG_LLT_INIT);
-		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)){
+		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)) {
 			break;
 		}
 
-		if (count > POLLING_LLT_THRESHOLD){
+		if (count > POLLING_LLT_THRESHOLD) {
 			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling write LLT done at address %d!\n", address));
 			status = _FAIL;
 			break;
@@ -697,11 +697,11 @@ static u8 _LLTRead(
 	do{
 
 		value = rtw_read32(Adapter, REG_LLT_INIT);
-		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)){
+		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)) {
 			return (u8)value;
 		}
 
-		if (count > POLLING_LLT_THRESHOLD){
+		if (count > POLLING_LLT_THRESHOLD) {
 			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling read LLT done at address %d!\n", address));
 			break;
 		}
@@ -722,44 +722,44 @@ static u8 InitLLTTable(
 	struct hal_data_8192du *pHalData = GET_HAL_DATA(Adapter);
 
 
-	if (pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY){
+	if (pHalData->MacPhyMode92D !=SINGLEMAC_SINGLEPHY) {
 		//for 92du two mac: The page size is different from 92c and 92s
 		txpktbuf_bndy =TX_PAGE_BOUNDARY_DUAL_MAC;
 		Last_Entry_Of_TxPktBuf=LAST_ENTRY_OF_TX_PKT_BUFFER_DUAL_MAC;
 	}
-	else{
+	else {
 		txpktbuf_bndy = boundary;
 		Last_Entry_Of_TxPktBuf=LAST_ENTRY_OF_TX_PKT_BUFFER;
 		//txpktbuf_bndy =253;
 		//Last_Entry_Of_TxPktBuf=255;
 	}
 
-	for (i = 0 ; i < (txpktbuf_bndy - 1) ; i++){
+	for (i = 0 ; i < (txpktbuf_bndy - 1) ; i++) {
 		status = _LLTWrite(Adapter, i , i + 1);
-		if (_SUCCESS != status){
+		if (_SUCCESS != status) {
 			return status;
 		}
 	}
 
 	// end of list
 	status = _LLTWrite(Adapter, (txpktbuf_bndy - 1), 0xFF);
-	if (_SUCCESS != status){
+	if (_SUCCESS != status) {
 		return status;
 	}
 
 	// Make the other pages as ring buffer
 	// This ring buffer is used as beacon buffer if we config this MAC as two MAC transfer.
 	// Otherwise used as local loopback buffer.
-	for (i = txpktbuf_bndy ; i < Last_Entry_Of_TxPktBuf ; i++){
+	for (i = txpktbuf_bndy ; i < Last_Entry_Of_TxPktBuf ; i++) {
 		status = _LLTWrite(Adapter, i, (i + 1));
-		if (_SUCCESS != status){
+		if (_SUCCESS != status) {
 			return status;
 		}
 	}
 
 	// Let last entry point to the start entry of ring buffer
 	status = _LLTWrite(Adapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);
-	if (_SUCCESS != status){
+	if (_SUCCESS != status) {
 		return status;
 	}
 
@@ -777,7 +777,7 @@ _SetMacID(
 	)
 {
 	u32 i;
-	for (i=0 ; i< MAC_ADDR_LEN ; i++){
+	for (i=0 ; i< MAC_ADDR_LEN ; i++) {
 #ifdef  CONFIG_CONCURRENT_MODE
 		if (Adapter->iface_type == IFACE_PORT1)
 			rtw_write32(Adapter, REG_MACID1+i, MacID[i]);
@@ -793,7 +793,7 @@ _SetBSSID(
 	)
 {
 	u32 i;
-	for (i=0 ; i< MAC_ADDR_LEN ; i++){
+	for (i=0 ; i< MAC_ADDR_LEN ; i++) {
 #ifdef  CONFIG_CONCURRENT_MODE
 		if (Adapter->iface_type == IFACE_PORT1)
 			rtw_write32(Adapter, REG_BSSID1+i, BSSID[i]);
@@ -862,15 +862,15 @@ _InitQueueReservedPage(
 			txQPageUnit = txQPageNum/outEPNum;
 			txQRemainPage = txQPageNum % outEPNum;
 
-			if (pHalData->OutEpQueueSel & TX_SELE_HQ){
+			if (pHalData->OutEpQueueSel & TX_SELE_HQ) {
 				numHQ = txQPageUnit;
 			}
-			if (pHalData->OutEpQueueSel & TX_SELE_LQ){
+			if (pHalData->OutEpQueueSel & TX_SELE_LQ) {
 				numLQ = txQPageUnit;
 			}
 			// HIGH priority queue always present in the configuration of 2 or 3 out-ep
 			// so ,remainder pages have assigned to High queue
-			if ((outEPNum>1) && (txQRemainPage)){
+			if ((outEPNum>1) && (txQRemainPage)) {
 				numHQ += txQRemainPage;
 			}
 
@@ -882,22 +882,22 @@ _InitQueueReservedPage(
 			rtw_write8(Adapter, REG_RQPN_NPQ, value8);
 		}
 	}
-	else{ //for WMM
+	else { //for WMM
 		//RT_ASSERT((outEPNum>=2), ("for WMM ,number of out-ep must more than or equal to 2!\n"));
 		// 92du wifi config only for SMSP
 		//RT_ASSERT((pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY), ("for WMM ,only SMSP come here!\n"));
 
 		numPubQ = (outEPNum==2)?WMM_NORMAL_PAGE_NUM_PUBQ:WMM_NORMAL_PAGE_NUM_PUBQ_92D;
 
-		if (pHalData->OutEpQueueSel & TX_SELE_HQ){
+		if (pHalData->OutEpQueueSel & TX_SELE_HQ) {
 			numHQ = (outEPNum==2)?WMM_NORMAL_PAGE_NUM_HPQ:WMM_NORMAL_PAGE_NUM_HPQ_92D;
 		}
 
-		if (pHalData->OutEpQueueSel & TX_SELE_LQ){
+		if (pHalData->OutEpQueueSel & TX_SELE_LQ) {
 			numLQ = (outEPNum==2)?WMM_NORMAL_PAGE_NUM_LPQ:WMM_NORMAL_PAGE_NUM_LPQ_92D;
 		}
 
-		if (pHalData->OutEpQueueSel & TX_SELE_NQ){
+		if (pHalData->OutEpQueueSel & TX_SELE_NQ) {
 			numNQ = (outEPNum==2)?WMM_NORMAL_PAGE_NUM_NPQ:WMM_NORMAL_PAGE_NUM_NPQ_92D;
 			value8 = (u8)_NPQ(numNQ);
 			rtw_write8(Adapter, REG_RQPN_NPQ, value8);
@@ -920,10 +920,10 @@ _InitTxBufferBoundary(
 	//u16	txdmactrl;
 	u8	txpktbuf_bndy;
 
-	if (!pregistrypriv->wifi_spec){
+	if (!pregistrypriv->wifi_spec) {
 		txpktbuf_bndy = TX_PAGE_BOUNDARY;
 	}
-	else{//for WMM
+	else {//for WMM
 		txpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY;
 	}
 
@@ -1024,7 +1024,7 @@ _InitNormalChipTwoOutEpPriority(
 			break;
 	}
 
-	if (!pregistrypriv->wifi_spec){
+	if (!pregistrypriv->wifi_spec) {
 		beQ		= valueLow;
 		bkQ		= valueLow;
 		viQ		= valueHi;
@@ -1032,7 +1032,7 @@ _InitNormalChipTwoOutEpPriority(
 		mgtQ	= valueHi;
 		hiQ		= valueHi;
 	}
-	else{//for WMM ,CONFIG_OUT_EP_WIFI_MODE
+	else {//for WMM ,CONFIG_OUT_EP_WIFI_MODE
 		beQ		= valueLow;
 		bkQ		= valueHi;
 		viQ		= valueHi;
@@ -1052,7 +1052,7 @@ _InitNormalChipThreeOutEpPriority(
 	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
 
-	if (!pregistrypriv->wifi_spec){// typical setting
+	if (!pregistrypriv->wifi_spec) {// typical setting
 		beQ		= QUEUE_LOW;
 		bkQ		= QUEUE_LOW;
 		viQ		= QUEUE_NORMAL;
@@ -1060,7 +1060,7 @@ _InitNormalChipThreeOutEpPriority(
 		mgtQ	= QUEUE_HIGH;
 		hiQ		= QUEUE_HIGH;
 	}
-	else{// for WMM
+	else {// for WMM
 		beQ		= QUEUE_LOW;
 		bkQ		= QUEUE_NORMAL;
 		viQ		= QUEUE_NORMAL;
@@ -1360,7 +1360,7 @@ _InitUsbAggregationSetting(
 	if (pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
 		pHalData->UsbTxAggDescNum = 2;
 
-	if (pHalData->UsbTxAggMode){
+	if (pHalData->UsbTxAggMode) {
 		value32 = rtw_read32(Adapter, REG_TDECTRL);
 		value32 = value32 & ~(BLK_DESC_NUM_MASK << BLK_DESC_NUM_SHIFT);
 		value32 |= ((pHalData->UsbTxAggDescNum & BLK_DESC_NUM_MASK) << BLK_DESC_NUM_SHIFT);
@@ -1597,7 +1597,7 @@ _InitRFType(
 	{
 		pHalData->rf_type = RF_1T1R;
 	}
-	else{// SMSP OR DMSP
+	else {// SMSP OR DMSP
 		pHalData->rf_type = RF_2T2R;
 	}
 #endif
@@ -1660,7 +1660,7 @@ static void _RfPowerSave(
 	return;
 #endif
 
-	if (pwrctrlpriv->reg_rfoff == true){ // User disable RF via registry.
+	if (pwrctrlpriv->reg_rfoff == true) { // User disable RF via registry.
 		//RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RegRfOff.\n"));
 		//MgntActSet_RF_State(Adapter, rf_off, RF_CHANGE_BY_SW, true);
 		// Those action will be discard in MgntActSet_RF_State because off the same state
@@ -1671,11 +1671,11 @@ static void _RfPowerSave(
 		for (eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 			PHY_SetRFReg(Adapter, (enum RF_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
 	}
-	else if (pwrctrlpriv->rfoff_reason > RF_CHANGE_BY_PS){ // H/W or S/W RF OFF before sleep.
+	else if (pwrctrlpriv->rfoff_reason > RF_CHANGE_BY_PS) { // H/W or S/W RF OFF before sleep.
 		//RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason));
 		//MgntActSet_RF_State(Adapter, rf_off, pMgntInfo->RfOffReason, true);
 	}
-	else{
+	else {
 		pwrctrlpriv->rf_pwrstate = rf_on;
 		pwrctrlpriv->rfoff_reason = 0;
 		//if (Adapter->bInSetPower || Adapter->bResetInProgress)
@@ -1885,7 +1885,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEG
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PW_ON);
 	status = _InitPowerOn(padapter);
-	if (status == _FAIL){
+	if (status == _FAIL) {
 		RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init power on!\n"));
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
@@ -1896,17 +1896,17 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INI
 	}
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_LLTT);
-	if (!pregistrypriv->wifi_spec){
+	if (!pregistrypriv->wifi_spec) {
 		boundary = TX_PAGE_BOUNDARY;
 	}
-	else{// for WMM
+	else {// for WMM
 		boundary = WMM_NORMAL_TX_PAGE_BOUNDARY;
 	}
 
 	PHY_ConfigMacCoexist_RFPage92D(padapter);
 
 	status =  InitLLTTable(padapter, boundary);
-	if (status == _FAIL){
+	if (status == _FAIL) {
 		RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init power on!\n"));
 		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
 		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
@@ -1930,7 +1930,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOW
 
 	status = FirmwareDownload92D(padapter, false);
 	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
-	if (status == _FAIL){
+	if (status == _FAIL) {
 		padapter->bFWReady = false;
 		pHalData->fw_ractrl = false;
 		DBG_8192D("fw download fail!\n");
@@ -1956,7 +1956,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOW
 
 	pHalData->LastHMEBoxNum = 0;
 
-	if (pwrctrlpriv->reg_rfoff == true){
+	if (pwrctrlpriv->reg_rfoff == true) {
 		pwrctrlpriv->rf_pwrstate = rf_off;
 	}
 
@@ -2023,12 +2023,12 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 #if ENABLE_USB_DROP_INCORRECT_OUT
 	_InitHardwareDropIncorrectBulkOut(padapter);
 #endif
-	if (pHalData->bRDGEnable){
+	if (pHalData->bRDGEnable) {
 		_InitRDGSetting(padapter);
 	}
 
 	// Set Data Auto Rate Fallback Reg.
-	for (i = 0 ; i < 4 ; i++){
+	for (i = 0 ; i < 4 ; i++) {
 		rtw_write32(padapter, REG_ARFR0+i*4, 0x1f8ffff0);
 	}
 
@@ -2036,14 +2036,14 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MIS
 	{
 		rtw_write16(padapter, REG_FAST_EDCA_CTRL, 0);
 	}
-	else{
-		if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY){
+	else {
+		if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY) {
 			if (pHalData->OutEpNumber == 2)  // suggested by chunchu
 				rtw_write32(padapter, REG_FAST_EDCA_CTRL, 0x03066666);
 		       else
 				rtw_write16(padapter, REG_FAST_EDCA_CTRL, 0x8888);
 		}
-		else{
+		else {
 			rtw_write16(padapter, REG_FAST_EDCA_CTRL, 0x5555);
 		}
 	}
@@ -2427,12 +2427,12 @@ _DisableRF_AFE(
 
 	do
 	{
-		if (rtw_read8(Adapter, REG_APSD_CTRL) & APSDOFF_STATUS){
+		if (rtw_read8(Adapter, REG_APSD_CTRL) & APSDOFF_STATUS) {
 			//RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE, AD, DA Done!\n"));
 			break;
 		}
 
-		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT){
+		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT) {
 			//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling APSDOFF_STATUS done!\n"));
 			return _FAIL;
 		}
@@ -2557,14 +2557,14 @@ e.	SYS_FUNC_EN 0x02[7:0] = 0x14		//reset
 
 	if (pHalData->MacPhyMode92D!=SINGLEMAC_SINGLEPHY)
 	{
-		if (pHalData->interfaceIndex!=0){
+		if (pHalData->interfaceIndex!=0) {
 			//before BB reset should do clock gated
 			rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 			value8 &=(~FEN_BB_GLB_RSTn);
 			rtw_write8(Adapter, REG_SYS_FUNC_EN, value8); //0x14
 		}
 	}
-	else{
+	else {
 		//before BB reset should do clock gated
 		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 		value8 &=(~FEN_BB_GLB_RSTn);
@@ -2635,7 +2635,7 @@ _ResetDigitalProcedure1(
 	rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x54);	//Reset MAC and Enable 8051
 	rtw_write8(Adapter, REG_MCUFWDL, 0);
 
-	if (bWithoutHWSM){
+	if (bWithoutHWSM) {
 	/*****************************
 		Without HW auto state machine
 	g.	SYS_CLKR 0x08[15:0] = 0x30A3			//disable MAC clock
@@ -2679,7 +2679,7 @@ _DisableAnalog(
 	u32 value16 = 0;
 	u8 value8=0;
 
-	if (bWithoutHWSM){
+	if (bWithoutHWSM) {
 	/*****************************
 	n.	LDOA15_CTRL 0x20[7:0] = 0x04		// disable A15 power
 	o.	LDOV12D_CTRL 0x21[7:0] = 0x54		// disable digital core power
@@ -2783,7 +2783,7 @@ CardDisableHWSM(// HW Auto state machine
 	int		rtStatus = _SUCCESS;
 	u8		value;
 
-	if (Adapter->bSurpriseRemoved){
+	if (Adapter->bSurpriseRemoved) {
 		return rtStatus;
 	}
 
@@ -2834,7 +2834,7 @@ CardDisableWithoutHWSM(// without HW Aut
 	int		rtStatus = _SUCCESS;
 	u8		value;
 
-	if (Adapter->bSurpriseRemoved){
+	if (Adapter->bSurpriseRemoved) {
 		return rtStatus;
 	}
 
@@ -2916,12 +2916,12 @@ _func_enter_;
 
 	rtw_write16(padapter, REG_GPIO_MUXCFG, rtw_read16(padapter, REG_GPIO_MUXCFG)&(~BIT12));
 
-	if (/*Adapter->bInUsbIfTest ||*/ !pHalData->bSupportRemoteWakeUp){
+	if (/*Adapter->bInUsbIfTest ||*/ !pHalData->bSupportRemoteWakeUp) {
 		if (padapter->bCardDisableWOHSM == false)
 			CardDisableHWSM(padapter, false);
 		else
 			CardDisableWithoutHWSM(padapter);
-	} else{
+	} else {
 
 		// Wake on WLAN
 	}
@@ -3029,10 +3029,10 @@ _ReadPROMVersion(
 {
 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
 
-	if (AutoloadFail){
+	if (AutoloadFail) {
 		pHalData->EEPROMVersion = EEPROM_Default_Version;
 	}
-	else{
+	else {
 		pHalData->EEPROMVersion = *(u8 *)&PROMContent[EEPROM_VERSION];
 	}
 }
@@ -3048,10 +3048,10 @@ _GetChannelGroup(
 {
 	//RT_ASSERT((channel < 14), ("Channel %d no is supported!\n"));
 
-	if (channel < 3){	// Channel 1~3
+	if (channel < 3) {	// Channel 1~3
 		return 0;
 	}
-	else if (channel < 9){ // Channel 4~9
+	else if (channel < 9) { // Channel 4~9
 		return 1;
 	}
 
@@ -3068,7 +3068,7 @@ _ReadIDs(
 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
 
 
-	if (false == AutoloadFail){
+	if (false == AutoloadFail) {
 		// VID, PID
 		pHalData->EEPROMVID = le16_to_cpu(*(u16 *)&PROMContent[EEPROM_VID]);
 		pHalData->EEPROMPID = le16_to_cpu(*(u16 *)&PROMContent[EEPROM_PID]);
@@ -3078,7 +3078,7 @@ _ReadIDs(
 		pHalData->EEPROMSubCustomerID = *(u8 *)&PROMContent[EEPROM_SUBCUSTOMER_ID];
 
 	}
-	else{
+	else {
 		pHalData->EEPROMVID	 = EEPROM_Default_VID;
 		pHalData->EEPROMPID	 = EEPROM_Default_PID;
 
@@ -3128,12 +3128,12 @@ _ReadMACAddress(
 
 	// Dual MAC should assign diffrent MAC address ,or, it is wil cause hang in single phy mode  zhiyuan 04/07/2010
 	//Temply random assigh mac address for  efuse mac address not ready now
-	if (AutoloadFail == false ){
-		if (pHalData->interfaceIndex == 0){
+	if (AutoloadFail == false ) {
+		if (pHalData->interfaceIndex == 0) {
 			//change to use memcpy, in order to avoid alignment issue. Baron 2011/6/20
 			memcpy(&pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR_MAC0_92D], ETH_ALEN);
 		}
-		else{
+		else {
 			//change to use memcpy, in order to avoid alignment issue. Baron 2011/6/20
 			memcpy(&pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR_MAC1_92D], ETH_ALEN);
 		}
@@ -3143,7 +3143,7 @@ _ReadMACAddress(
 			//Random assigh MAC address
 			u8 sMacAddr[MAC_ADDR_LEN] = {0x00, 0xE0, 0x4C, 0x81, 0x92, 0x00};
 			//u32	curtime = rtw_get_current_time();
-			if (pHalData->interfaceIndex == 1){
+			if (pHalData->interfaceIndex == 1) {
 				sMacAddr[5] = 0x01;
 				//sMacAddr[5] = (u8)(curtime & 0xff);
 				//sMacAddr[5] = (u8)GetRandomNumber(1, 254);
@@ -3156,7 +3156,7 @@ _ReadMACAddress(
 		//Random assigh MAC address
 		u8 sMacAddr[MAC_ADDR_LEN] = {0x00, 0xE0, 0x4C, 0x81, 0x92, 0x00};
 		//u32	curtime = rtw_get_current_time();
-		if (pHalData->interfaceIndex == 1){
+		if (pHalData->interfaceIndex == 1) {
 			sMacAddr[5] = 0x01;
 			//sMacAddr[5] = (u8)(curtime & 0xff);
 			//sMacAddr[5] = (u8)GetRandomNumber(1, 254);
@@ -3226,13 +3226,13 @@ hal_ReadMacPhyMode_92D(
 
 
 
-	if (AutoloadFail==true){
+	if (AutoloadFail==true) {
 		Mac1EnableValue = rtw_read8(Adapter,0xFE64);
 		PHY_ReadMacPhyMode92D(Adapter, AutoloadFail);
 
 		DBG_8192D("_ReadMacPhyMode(): AutoloadFail %d 0xFE64 = 0x%x\n",AutoloadFail, Mac1EnableValue);
 	}
-	else{
+	else {
 		hal_ReadMacPhyModeFromPROM92DU(Adapter, PROMContent);
 	}
 
@@ -3273,7 +3273,7 @@ _ReadBoardType(
 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
 	u8			boardType;
 
-	if (AutoloadFail){
+	if (AutoloadFail) {
 		pHalData->rf_type = RF_2T2R;
 		pHalData->BluetoothCoexist = false;
 		return;
@@ -3418,7 +3418,7 @@ _InitOtherVariable(
 {
 	struct hal_data_8192du 	*pHalData = GET_HAL_DATA(Adapter);
 
-	//if (Adapter->bInHctTest){
+	//if (Adapter->bInHctTest) {
 	//	pMgntInfo->PowerSaveControl.bInactivePs = false;
 	//	pMgntInfo->PowerSaveControl.bIPSModeBackup = false;
 	//	pMgntInfo->PowerSaveControl.bLeisurePs = false;
@@ -3428,10 +3428,10 @@ _InitOtherVariable(
 	// 2009/06/10 MH For 92S 1*1=1R/ 1*2&2*2 use 2R. We default set 1*1 use radio A
 	// So if you want to use radio B. Please modify RF path enable bit for correct signal
 	// strength calculate.
-	if (pHalData->rf_type == RF_1T1R){
+	if (pHalData->rf_type == RF_1T1R) {
 		pHalData->bRFPathRxEnable[0] = true;
 	}
-	else{
+	else {
 		pHalData->bRFPathRxEnable[0] = pHalData->bRFPathRxEnable[1] = true;
 	}
 }
@@ -4909,7 +4909,7 @@ _func_enter_;
 							break;
 					}
 
-					if (MinSpacingToSet < SecMinSpace){
+					if (MinSpacingToSet < SecMinSpace) {
 						MinSpacingToSet = SecMinSpace;
 					}
 
@@ -4926,13 +4926,13 @@ _func_enter_;
 				u8	index = 0;
 
 				RegToSet = 0xb972a841;
-				if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY){
+				if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY) {
 					RegToSet = 0x88728841;
 				}
-				else if (pHalData->MacPhyMode92D==DUALMAC_DUALPHY){
+				else if (pHalData->MacPhyMode92D==DUALMAC_DUALPHY) {
 					RegToSet = 0x66525541;
 				}
-				else if (pHalData->MacPhyMode92D==DUALMAC_SINGLEPHY){
+				else if (pHalData->MacPhyMode92D==DUALMAC_SINGLEPHY) {
 					RegToSet = 0x44444441;
 				}
 
@@ -5032,12 +5032,12 @@ _func_enter_;
 				struct DIG_T *dig_table = &pdmpriv->DM_DigTable;
 				u32		rx_gain = ((u32 *)(val))[0];
 
-				if (rx_gain == 0xff){//restore rx gain
+				if (rx_gain == 0xff) {//restore rx gain
 					dig_table->curigvalue = dig_table->backupigvalue;
 					PHY_SetBBReg(Adapter, rOFDM0_XAAGCCore1, 0x7f,dig_table->curigvalue);
 					PHY_SetBBReg(Adapter, rOFDM0_XBAGCCore1, 0x7f,dig_table->curigvalue);
 				}
-				else{
+				else {
 					dig_table->backupigvalue = dig_table->curigvalue;
 					PHY_SetBBReg(Adapter, rOFDM0_XAAGCCore1, 0x7f,rx_gain);
 					PHY_SetBBReg(Adapter, rOFDM0_XBAGCCore1, 0x7f,rx_gain);
@@ -5092,16 +5092,16 @@ _func_enter_;
 				int res;
 
 				poidparam = (struct wowlan_ioctl_param *)val;
-				switch (poidparam->subcode){
+				switch (poidparam->subcode) {
 					case WOWLAN_PATTERN_MATCH:
 						//Turn on the Pattern Match feature
 						DBG_8192D("\n PATTERN_MATCH poidparam->subcode_value=%d\n",poidparam->subcode_value);
-						if (poidparam->subcode_value==1){
+						if (poidparam->subcode_value==1) {
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(1)));
 							Adapter->pwrctrlpriv.wowlan_pattern=true;
 							DBG_8192D("%s Adapter->pwrctrlpriv.wowlan_pattern=%x\n",__func__,Adapter->pwrctrlpriv.wowlan_pattern);
 						}
-						else{
+						else {
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&~BIT(1)));
 							Adapter->pwrctrlpriv.wowlan_pattern=false;
 						}
@@ -5109,23 +5109,23 @@ _func_enter_;
 					case WOWLAN_MAGIC_PACKET:
 						//Turn on the Magic Packet feature
 						DBG_8192D("\n MAGIC_PACKET poidparam->subcode_value=%d\n",poidparam->subcode_value);
-						if (poidparam->subcode_value==1){
+						if (poidparam->subcode_value==1) {
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(2)));
 							Adapter->pwrctrlpriv.wowlan_magic=true;
 							DBG_8192D("%s Adapter->pwrctrlpriv.wowlan_magic=%x\n",__func__,Adapter->pwrctrlpriv.wowlan_magic);
 						}
-						else{
+						else {
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&~BIT(2)));
 							Adapter->pwrctrlpriv.wowlan_magic=false;
 						}
 						break;
 					case WOWLAN_UNICAST:
 						//Turn on the Unicast wakeup feature
-						if (poidparam->subcode_value==1){
+						if (poidparam->subcode_value==1) {
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(3)));
 							Adapter->pwrctrlpriv.wowlan_unicast=true;
 						}
-						else{
+						else {
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&~BIT(3)));
 							Adapter->pwrctrlpriv.wowlan_unicast=false;
 							DBG_8192D("%s Adapter->pwrctrlpriv.wowlan_unicast=%x\n",__func__,Adapter->pwrctrlpriv.wowlan_unicast);
@@ -5142,7 +5142,7 @@ _func_enter_;
 						/*DBG_8192D("\n\n\n\n rtw_wowlan_ctrl: WOW_CTRL=0x%x\n",rtw_read8(Adapter, REG_WOW_CTRL));
 						DBG_8192D("print WKFMCAM index =%d ",poidparam->data[0]);
 						{	int cmd=0,offset=0;
-							for (offset=0;offset<5;offset++){
+							for (offset=0;offset<5;offset++) {
 								cmd=BIT(31)|(poidparam->data[0]+offset);
 								rtw_write32(Adapter, REG_WKFMCAM_CMD, cmd);
 								DBG_8192D("offset[%d]=0x%.8x  ",offset,rtw_read32(Adapter, REG_WKFMCAM_RWD));
@@ -5412,28 +5412,28 @@ SetHalDefVar8192DUsb(
 				u8 dm_func = *((u8*)pValue);
 				struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
-				if (dm_func == 0){ //disable all dynamic func
+				if (dm_func == 0) { //disable all dynamic func
 					pdmpriv->DMFlag = DYNAMIC_FUNC_DISABLE;
 					DBG_8192D("==> Disable all dynamic function...\n");
 				}
-				else if (dm_func == 1){//disable DIG
+				else if (dm_func == 1) {//disable DIG
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_DIG);
 					DBG_8192D("==> Disable DIG...\n");
 				}
-				else if (dm_func == 2){//disable High power
+				else if (dm_func == 2) {//disable High power
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_HP);
 				}
-				else if (dm_func == 3){//disable tx power tracking
+				else if (dm_func == 3) {//disable tx power tracking
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_SS);
 					DBG_8192D("==> Disable tx power tracking...\n");
 				}
-				else if (dm_func == 4){//disable BT coexistence
+				else if (dm_func == 4) {//disable BT coexistence
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_BT);
 				}
-				else if (dm_func == 5){//disable antenna diversity
+				else if (dm_func == 5) {//disable antenna diversity
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_ANT_DIV);
 				}
-				else if (dm_func == 6){//turn on all dynamic func
+				else if (dm_func == 6) {//turn on all dynamic func
 					if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
 					{
 						struct dm_priv	*pdmpriv = &pHalData->dmpriv;
@@ -5711,7 +5711,7 @@ void rtl8192du_set_hal_ops(struct rtw_ad
 _func_enter_;
 
 	padapter->HalData = rtw_zmalloc(sizeof(struct hal_data_8192du));
-	if (padapter->HalData == NULL){
+	if (padapter->HalData == NULL) {
 		DBG_8192D("cant not alloc memory for HAL DATA\n");
 	}
 	//memset(padapter->HalData, 0, sizeof(struct hal_data_8192du));
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -59,13 +59,13 @@ static int usbctrl_vendorreq(struct intf
 
 	//DBG_8192D("%s %s:%d\n",__func__, current->comm, current->pid);
 
-	if ((padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx)){
+	if ((padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx)) {
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usbctrl_vendorreq:(padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
 		status = -EPERM;
 		goto exit;
 	}
 
-	if (len>MAX_VENDOR_REQ_CMD_SIZE){
+	if (len>MAX_VENDOR_REQ_CMD_SIZE) {
 		DBG_8192D("[%s] Buffer len error ,vendor request failed\n", __func__);
 		status = -EINVAL;
 		goto exit;
@@ -152,7 +152,7 @@ static int usbctrl_vendorreq(struct intf
 				}
 			}
 
-			if (rtw_inc_and_chk_continual_urb_error(pdvobjpriv) == true){
+			if (rtw_inc_and_chk_continual_urb_error(pdvobjpriv) == true) {
 				padapter->bSurpriseRemoved = true;
 				break;
 			}
@@ -302,7 +302,7 @@ static u32 usb_read32(struct intf_hdl *p
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 4;
 
-	if ((addr&0xff000000)>>24 == 0x66){
+	if ((addr&0xff000000)>>24 == 0x66) {
 		usb_read_reg_rf_byfw(pintfhdl, len, addr, &data);
 	}
 	else {
@@ -549,7 +549,7 @@ static s32 pre_recv_entry(union recv_fra
 
 				// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
 				// modify alloc_sz for recvive crc error packet by thomas 2011-06-02
-				if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)){
+				if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)) {
 					//alloc_sz = 1664;	//1664 is 128 alignment.
 					if (skb_len <= 1650)
 						alloc_sz = 1664;
@@ -678,7 +678,7 @@ static int recvbuf2recvframe(struct rtw_
 
 		// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
 		// modify alloc_sz for recvive crc error packet by thomas 2011-06-02
-		if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)){
+		if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)) {
 			//alloc_sz = 1664;	//1664 is 128 alignment.
 			if (skb_len <= 1650)
 				alloc_sz = 1664;
@@ -1010,7 +1010,7 @@ static int recvbuf2recvframe(struct rtw_
 
 		// for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
 		// modify alloc_sz for recvive crc error packet by thomas 2011-06-02
-		if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)){
+		if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)) {
 			//alloc_sz = 1664;	//1664 is 128 alignment.
 			if (skb_len <= 1650)
 				alloc_sz = 1664;
@@ -1164,7 +1164,7 @@ static void usb_read_port_complete(struc
 	#ifdef CONFIG_PREALLOC_RECV_SKB
 		precvbuf->reuse = true;
 	#else
-		if (precvbuf->pskb){
+		if (precvbuf->pskb) {
 			DBG_8192D("==> free skb(%p)\n",precvbuf->pskb);
 			dev_kfree_skb_any(precvbuf->pskb);
 		}
--- a/drivers/staging/rtl8192du/include/generic.h
+++ b/drivers/staging/rtl8192du/include/generic.h
@@ -70,7 +70,7 @@
  * if that's true, then detect them, and take measures.
  * Anyway, the measure is: define only ___ntohl as a macro instead,
  * and in a separate file, have
- * unsigned long inline ntohl(x){return ___ntohl(x);}
+ * unsigned long inline ntohl(x) {return ___ntohl(x);}
  *
  * The same for constant arguments
  *	__constant_ntohl(__u32 x)
--- a/drivers/staging/rtl8192du/include/osdep_intf.h
+++ b/drivers/staging/rtl8192du/include/osdep_intf.h
@@ -88,8 +88,8 @@ u16 rtw_recv_select_queue(struct sk_buff
 void rtw_proc_init_one(struct net_device *dev);
 void rtw_proc_remove_one(struct net_device *dev);
 #else //!CONFIG_PROC_DEBUG
-static void rtw_proc_init_one(struct net_device *dev){}
-static void rtw_proc_remove_one(struct net_device *dev){}
+static void rtw_proc_init_one(struct net_device *dev) {}
+static void rtw_proc_remove_one(struct net_device *dev) {}
 #endif //!CONFIG_PROC_DEBUG
 
 void rtw_ips_dev_unload(struct rtw_adapter *padapter);
--- a/drivers/staging/rtl8192du/include/rtw_sreset.h
+++ b/drivers/staging/rtl8192du/include/rtw_sreset.h
@@ -49,10 +49,10 @@ void sreset_reset_value(struct rtw_adapt
 u8 sreset_get_wifi_status(struct rtw_adapter *padapter);
 void sreset_set_wifi_error_status(struct rtw_adapter *padapter, u32 status);
 #else
-static void sreset_init_value(struct rtw_adapter *padapter){}
-static void sreset_reset_value(struct rtw_adapter *padapter){}
-static u8 sreset_get_wifi_status(struct rtw_adapter *padapter){return WIFI_STATUS_SUCCESS;}
-static void sreset_set_wifi_error_status(struct rtw_adapter *padapter, u32 status){}
+static void sreset_init_value(struct rtw_adapter *padapter) {}
+static void sreset_reset_value(struct rtw_adapter *padapter) {}
+static u8 sreset_get_wifi_status(struct rtw_adapter *padapter) {return WIFI_STATUS_SUCCESS;}
+static void sreset_set_wifi_error_status(struct rtw_adapter *padapter, u32 status) {}
 #endif
 
 #endif
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -341,7 +341,7 @@ static int rtw_cfg80211_inform_bss(_adap
 	//DBG_8192C("%s\n", __func__);
 
 	bssinf_len = pnetwork->network.IELength+sizeof (struct rtw_ieee80211_hdr_3addr);
-	if (bssinf_len > MAX_BSSINFO_LEN){
+	if (bssinf_len > MAX_BSSINFO_LEN) {
 		DBG_871X("%s IE Length too long > %d byte\n",__func__,MAX_BSSINFO_LEN);
 		goto exit;
 	}
@@ -606,13 +606,13 @@ static u8 set_pairwise_key(_adapter *pad
 	u8	res=_SUCCESS;
 
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if (ph2c == NULL){
+	if (ph2c == NULL) {
 		res= _FAIL;
 		goto exit;
 	}
 
 	psetstakey_para = (struct set_stakey_parm*)rtw_zmalloc(sizeof(struct set_stakey_parm));
-	if (psetstakey_para==NULL){
+	if (psetstakey_para==NULL) {
 		kfree(ph2c);
 		res=_FAIL;
 		goto exit;
@@ -646,12 +646,12 @@ static int set_group_key(_adapter *padap
 	DBG_8192C("%s\n", __func__);
 
 	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if (pcmd==NULL){
+	if (pcmd==NULL) {
 		res= _FAIL;
 		goto exit;
 	}
 	psetkeyparm=(struct setkey_parm*)rtw_zmalloc(sizeof(struct setkey_parm));
-	if (psetkeyparm==NULL){
+	if (psetkeyparm==NULL) {
 		kfree(pcmd);
 		res= _FAIL;
 		goto exit;
@@ -1874,7 +1874,7 @@ static int cfg80211_rtw_scan(struct wiph
 		need_indicate_scan_done = true;
 		goto check_need_indicate_scan_done;
 	}
-	if (rtw_is_scan_deny(padapter)){
+	if (rtw_is_scan_deny(padapter)) {
 		DBG_871X(FUNC_ADPT_FMT  ": scan deny\n", FUNC_ADPT_ARG(padapter));
 		need_indicate_scan_done = true;
 		goto check_need_indicate_scan_done;
@@ -2148,7 +2148,7 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 	}
 
 	buf = rtw_zmalloc(ielen);
-	if (buf == NULL){
+	if (buf == NULL) {
 		ret =  -ENOMEM;
 		goto exit;
 	}
@@ -2164,7 +2164,7 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 	}
 
 	pos = buf;
-	if (ielen < RSN_HEADER_LEN){
+	if (ielen < RSN_HEADER_LEN) {
 		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie len too short %d\n", ielen));
 		ret  = -1;
 		goto exit;
@@ -2406,7 +2406,7 @@ static int cfg80211_rtw_connect(struct w
 		goto exit;
 	}
 
-	if (sme->ssid_len > IW_ESSID_MAX_SIZE){
+	if (sme->ssid_len > IW_ESSID_MAX_SIZE) {
 
 		ret= -E2BIG;
 		goto exit;
@@ -2565,7 +2565,7 @@ static int cfg80211_rtw_connect(struct w
 			wep_key_len = wep_key_len <= 5 ? 5 : 13;
 			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
 			pwep =(NDIS_802_11_WEP	 *) rtw_malloc(wep_total_len);
-			if (pwep == NULL){
+			if (pwep == NULL) {
 				DBG_871X(" wpa_set_encryption: pwep allocate fail !!!\n");
 				ret = -ENOMEM;
 				goto exit;
@@ -4093,7 +4093,7 @@ static s32 cfg80211_rtw_remain_on_channe
 			ready_on_channel = true;
 			//pmlmeext->cur_channel = remain_ch;
 			//set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-		}else
+		} else
 #endif //CONFIG_CONCURRENT_MODE
 		if (remain_ch != pmlmeext->cur_channel)
 		{
@@ -4249,7 +4249,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 
 		if (tx_ch != co_channel)
 			set_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-	}else
+	} else
 #endif //CONFIG_CONCURRENT_MODE
 	//if (tx_ch != pmlmeext->cur_channel) {
 	if (tx_ch != rtw_get_oper_ch(padapter)) {
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -436,7 +436,7 @@ static char *translate_scan(struct rtw_a
 
 	cap = le16_to_cpu(cap);
 
-	if (cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)){
+	if (cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)) {
 		if (cap & WLAN_CAPABILITY_BSS)
 			iwe.u.mode = IW_MODE_MASTER;
 		else
@@ -711,7 +711,7 @@ _func_enter_;
 			wep_key_len = wep_key_len <= 5 ? 5 : 13;
 			wep_total_len = wep_key_len + FIELD_OFFSET(struct ndis_802_11_wep, KeyMaterial);
 			pwep =(struct ndis_802_11_wep *) rtw_malloc(wep_total_len);
-			if (pwep == NULL){
+			if (pwep == NULL) {
 				RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,(" wpa_set_encryption: pwep allocate fail !!!\n"));
 				goto exit;
 			}
@@ -875,7 +875,7 @@ static int rtw_set_wpa_ie(struct rtw_ada
 	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
 #endif //CONFIG_P2P
 
-	if ((ielen > MAX_WPA_IE_LEN) || (pie == NULL)){
+	if ((ielen > MAX_WPA_IE_LEN) || (pie == NULL)) {
 		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
 		if (pie == NULL)
 			return ret;
@@ -886,7 +886,7 @@ static int rtw_set_wpa_ie(struct rtw_ada
 	if (ielen)
 	{
 		buf = rtw_zmalloc(ielen);
-		if (buf == NULL){
+		if (buf == NULL) {
 			ret =  -ENOMEM;
 			goto exit;
 		}
@@ -902,7 +902,7 @@ static int rtw_set_wpa_ie(struct rtw_ada
 		}
 
 		pos = buf;
-		if (ielen < RSN_HEADER_LEN){
+		if (ielen < RSN_HEADER_LEN) {
 			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie len too short %d\n", ielen));
 			ret  = -1;
 			goto exit;
@@ -1134,7 +1134,7 @@ static int rtw_wx_get_freq(struct net_de
 		wrqu->freq.i = pcur_bss->Configuration.DSConfig;
 
 	}
-	else{
+	else {
 		wrqu->freq.m = rtw_ch2freq(padapter->mlmeextpriv.cur_channel) * 100000;
 		wrqu->freq.e = 1;
 		wrqu->freq.i = padapter->mlmeextpriv.cur_channel;
@@ -1158,7 +1158,7 @@ static int rtw_wx_set_mode(struct net_de
 		goto exit;
 	}
 
-	if (padapter->hw_init_completed==false){
+	if (padapter->hw_init_completed==false) {
 		ret = -EPERM;
 		goto exit;
 	}
@@ -1201,7 +1201,7 @@ static int rtw_wx_set_mode(struct net_de
 */
 	spin_lock_bh(&pmlmepriv->lock);
 	spin_lock_bh(&queue->lock);
-	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==false){
+	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==false) {
 
 		ret = -EPERM;
 		spin_unlock_bh(&queue->lock);
@@ -1545,13 +1545,13 @@ static int rtw_wx_set_wap(struct net_dev
 		goto exit;
 	}
 
-	if (!padapter->bup){
+	if (!padapter->bup) {
 		ret = -1;
 		goto exit;
 	}
 
 
-	if (temp->sa_family != ARPHRD_ETHER){
+	if (temp->sa_family != ARPHRD_ETHER) {
 		ret = -EINVAL;
 		goto exit;
 	}
@@ -1718,18 +1718,18 @@ _func_enter_;
 		goto exit;
 	}
 
-	if (padapter->bDriverStopped){
+	if (padapter->bDriverStopped) {
            DBG_8192D("bDriverStopped=%d\n", padapter->bDriverStopped);
 		ret= -1;
 		goto exit;
 	}
 
-	if (!padapter->bup){
+	if (!padapter->bup) {
 		ret = -1;
 		goto exit;
 	}
 
-	if (padapter->hw_init_completed==false){
+	if (padapter->hw_init_completed==false) {
 		ret = -1;
 		goto exit;
 	}
@@ -2130,15 +2130,15 @@ static int rtw_wx_set_essid(struct net_d
 		goto exit;
 	}
 
-	if (!padapter->bup){
+	if (!padapter->bup) {
 		ret = -1;
 		goto exit;
 	}
 
 #if WIRELESS_EXT <= 20
-	if ((wrqu->essid.length-1) > IW_ESSID_MAX_SIZE){
+	if ((wrqu->essid.length-1) > IW_ESSID_MAX_SIZE) {
 #else
-	if (wrqu->essid.length > IW_ESSID_MAX_SIZE){
+	if (wrqu->essid.length > IW_ESSID_MAX_SIZE) {
 #endif
 		ret= -E2BIG;
 		goto exit;
@@ -2301,13 +2301,13 @@ _func_enter_;
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,(" rtw_wx_set_rate\n"));
 	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("target_rate = %d, fixed = %d\n",target_rate,fixed));
 
-	if (target_rate == -1){
+	if (target_rate == -1) {
 		ratevalue = 11;
 		goto set_rate;
 	}
 	target_rate = target_rate/100000;
 
-	switch (target_rate){
+	switch (target_rate) {
 		case 10:
 			ratevalue = 0;
 			break;
@@ -2363,7 +2363,7 @@ set_rate:
 		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("datarate_inx=%d\n",datarates[i]));
 	}
 
-	if (rtw_setdatarate_cmd(padapter, datarates) !=_SUCCESS){
+	if (rtw_setdatarate_cmd(padapter, datarates) !=_SUCCESS) {
 		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("rtw_wx_set_rate Fail!!!\n"));
 		ret = -1;
 	}
@@ -2806,7 +2806,7 @@ static int rtw_wx_set_auth(struct net_de
 						// then it needn't reset it;
 			}
 
-			if (param->value){
+			if (param->value) {
 				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
 				padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
 				padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
@@ -3170,7 +3170,7 @@ static  int rtw_drvext_hdl(struct net_de
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point *p = &wrqu->data;
 
-	if ((!p->length) || (!p->pointer)){
+	if ((!p->length) || (!p->pointer)) {
 		ret = -EINVAL;
 		goto _rtw_drvext_hdl_exit;
 	}
@@ -3179,7 +3179,7 @@ static  int rtw_drvext_hdl(struct net_de
 	bset = (u8)(p->flags&0xFFFF);
 	len = p->length;
 	pparmbuf = (u8*)rtw_malloc(len);
-	if (pparmbuf == NULL){
+	if (pparmbuf == NULL) {
 		ret = -ENOMEM;
 		goto _rtw_drvext_hdl_exit;
 	}
@@ -3384,7 +3384,7 @@ static int rtw_mp_ioctl_hdl(struct net_d
 	bset = (u8)(p->flags & 0xFFFF);
 	len = p->length;
 	pparmbuf = (u8*)rtw_malloc(len);
-	if (pparmbuf == NULL){
+	if (pparmbuf == NULL) {
 		ret = -ENOMEM;
 		goto _rtw_mp_ioctl_hdl_exit;
 	}
@@ -6028,7 +6028,7 @@ static int rtw_dbg_port(struct net_devic
 							break;
 						}
 
-						for (i=0;i<blink_num;i++){
+						for (i=0;i<blink_num;i++) {
 							rtw_IOL_append_WB_cmd(xmit_frame, reg, 0x00);
 							rtw_IOL_append_DELAY_MS_cmd(xmit_frame, blink_delay_ms);
 							rtw_IOL_append_WB_cmd(xmit_frame, reg, 0x08);
@@ -6056,7 +6056,7 @@ static int rtw_dbg_port(struct net_devic
 							break;
 						}
 
-						for (i=0;i<write_num;i++){
+						for (i=0;i<write_num;i++) {
 							rtw_IOL_append_WB_cmd(xmit_frame, reg, i+start_value);
 						}
 						if (_SUCCESS != rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000))
@@ -6088,7 +6088,7 @@ static int rtw_dbg_port(struct net_devic
 							break;
 						}
 
-						for (i=0;i<write_num;i++){
+						for (i=0;i<write_num;i++) {
 							rtw_IOL_append_WW_cmd(xmit_frame, reg, i+start_value);
 						}
 						if (_SUCCESS !=rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000))
@@ -6120,7 +6120,7 @@ static int rtw_dbg_port(struct net_devic
 							break;
 						}
 
-						for (i=0;i<write_num;i++){
+						for (i=0;i<write_num;i++) {
 							rtw_IOL_append_WD_cmd(xmit_frame, reg, i+start_value);
 						}
 						if (_SUCCESS !=rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000))
@@ -6294,7 +6294,7 @@ static int rtw_dbg_port(struct net_devic
 		#ifdef DBG_CONFIG_ERROR_DETECT
 				case 0x0f:
 						{
-							if (extra_arg == 0){
+							if (extra_arg == 0) {
 								DBG_8192D("###### silent reset test.......#####\n");
 								rtw_hal_sreset_reset(padapter);
 							}
@@ -6378,13 +6378,13 @@ static int rtw_dbg_port(struct net_devic
 #if 1
 				case 0xdd://registers dump , 0 for mac reg,1 for bb reg, 2 for rf reg
 					{
-						if (extra_arg==0){
+						if (extra_arg==0) {
 							mac_reg_dump(padapter);
 						}
-						else if (extra_arg==1){
+						else if (extra_arg==1) {
 							bb_reg_dump(padapter);
 						}
-						else if (extra_arg==2){
+						else if (extra_arg==2) {
 							rf_reg_dump(padapter);
 						}
 
@@ -6395,7 +6395,7 @@ static int rtw_dbg_port(struct net_devic
 					{
 						u8 dm_flag;
 
-						if (0xf==extra_arg){
+						if (0xf==extra_arg) {
 							rtw_hal_get_def_var(padapter, HAL_DEF_DBG_DM_FUNC,&dm_flag);
 							DBG_8192D(" === DMFlag(0x%02x) ===\n",dm_flag);
 							DBG_8192D("extra_arg = 0  - disable all dynamic func\n");
@@ -6406,7 +6406,7 @@ static int rtw_dbg_port(struct net_devic
 							DBG_8192D("extra_arg = 5  - disable antenna diversity - BIT(4)\n");
 							DBG_8192D("extra_arg = 6  - enable all dynamic func\n");
 						}
-						else{
+						else {
 							/*	extra_arg = 0  - disable all dynamic func
 								extra_arg = 1  - disable DIG
 								extra_arg = 2  - disable tx power tracking
@@ -6475,7 +6475,7 @@ static int wpa_set_param(struct net_devi
 	u32 flags;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-	switch (name){
+	switch (name) {
 	case IEEE_PARAM_WPA_ENABLED:
 
 		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X; //802.1x
@@ -6600,7 +6600,7 @@ static int wpa_supplicant_ioctl(struct n
 
 	//down(&ieee->wx_sem);
 
-	if (p->length < sizeof(struct ieee_param) || !p->pointer){
+	if (p->length < sizeof(struct ieee_param) || !p->pointer) {
 		ret = -EINVAL;
 		goto out;
 	}
@@ -6666,13 +6666,13 @@ static u8 set_pairwise_key(struct rtw_ad
 	u8	res=_SUCCESS;
 
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
-	if (ph2c == NULL){
+	if (ph2c == NULL) {
 		res= _FAIL;
 		goto exit;
 	}
 
 	psetstakey_para = (struct set_stakey_parm*)rtw_zmalloc(sizeof(struct set_stakey_parm));
-	if (psetstakey_para == NULL){
+	if (psetstakey_para == NULL) {
 		kfree(ph2c);
 		res=_FAIL;
 		goto exit;
@@ -6706,12 +6706,12 @@ static int set_group_key(struct rtw_adap
 	DBG_8192D("%s\n", __func__);
 
 	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
-	if (pcmd==NULL){
+	if (pcmd==NULL) {
 		res= _FAIL;
 		goto exit;
 	}
 	psetkeyparm=(struct setkey_parm*)rtw_zmalloc(sizeof(struct setkey_parm));
-	if (psetkeyparm==NULL){
+	if (psetkeyparm==NULL) {
 		kfree(pcmd);
 		res= _FAIL;
 		goto exit;
@@ -6856,7 +6856,7 @@ static int rtw_set_encryption(struct net
 			wep_key_len = wep_key_len <= 5 ? 5 : 13;
 			wep_total_len = wep_key_len + FIELD_OFFSET(struct ndis_802_11_wep, KeyMaterial);
 			pwep =(struct ndis_802_11_wep *)rtw_malloc(wep_total_len);
-			if (pwep == NULL){
+			if (pwep == NULL) {
 				DBG_8192D(" r871x_set_encryption: pwep allocate fail !!!\n");
 				goto exit;
 			}
@@ -7635,14 +7635,14 @@ static int rtw_hostapd_ioctl(struct net_
 	* so, we just check hw_init_completed instead of call rfpwrstate_check()
 	*/
 
-	if (padapter->hw_init_completed==false){
+	if (padapter->hw_init_completed==false) {
 		ret = -EPERM;
 		goto out;
 	}
 
 
-	//if (p->length < sizeof(struct ieee_param) || !p->pointer){
-	if (!p->pointer){
+	//if (p->length < sizeof(struct ieee_param) || !p->pointer) {
+	if (!p->pointer) {
 		ret = -EINVAL;
 		goto out;
 	}
@@ -7860,7 +7860,7 @@ static int rtw_wx_set_priv(struct net_de
 
 	if (	len >= WEXT_CSCAN_HEADER_SIZE
 		&& _rtw_memcmp(ext, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == true
-	){
+	) {
 		ret = rtw_wx_set_scan(dev, info, awrq, ext);
 		goto FREE_EXT;
 	}
@@ -7991,9 +7991,9 @@ static int rtw_mp_efuse_get(struct net_d
 
 		mapLen = EFUSE_MAP_SIZE;
 
-		if (rtw_efuse_map_read(padapter, 0, mapLen, data) == _SUCCESS){
+		if (rtw_efuse_map_read(padapter, 0, mapLen, data) == _SUCCESS) {
 			DBG_8192D("\t  rtw_efuse_map_read\n");
-		}else {
+		} else {
 			DBG_8192D("\t  rtw_efuse_map_read : Fail\n");
 			return -EFAULT;
 		}
@@ -8011,7 +8011,7 @@ static int rtw_mp_efuse_get(struct net_d
 			}
 			DBG_8192D("\t");
 			sprintf(extra,"%s\t",extra);
-			for (; j < 16; j++){
+			for (; j < 16; j++) {
 				DBG_8192D("%02X ", data[i+j]);
 				sprintf(extra, "%s %02X", extra, data[i+j]);
 			}
@@ -8046,7 +8046,7 @@ static int rtw_mp_efuse_get(struct net_d
 		{
 			DBG_8192D("rtw_efuse_access error\n");
 		}
-		else{
+		else {
 			DBG_8192D("rtw_efuse_access ok\n");
 		}
 
@@ -8082,11 +8082,11 @@ static int rtw_mp_efuse_get(struct net_d
 			DBG_8192D(" %02x", rawdata[i]);
 			sprintf(extra, "%s %02x", extra, rawdata[i]);
 
-			if ((i & 0xF) == 0xF){
+			if ((i & 0xF) == 0xF) {
 				DBG_8192D("\n\t");
 				sprintf(extra, "%s\n\t", extra);
 			}
-			else if ((i & 0x7) == 0x7){
+			else if ((i & 0x7) == 0x7) {
 				DBG_8192D("\t");
 				sprintf(extra, "%s\t", extra);
 			}
@@ -8107,7 +8107,7 @@ static int rtw_mp_efuse_get(struct net_d
 		{
 			DBG_8192D("rtw_efuse_access error\n");
 		}
-		else{
+		else {
 			DBG_8192D("rtw_efuse_access ok\n");
 		}
 		memset(extra, '\0', sizeof(extra));
@@ -8133,7 +8133,7 @@ static int rtw_mp_efuse_get(struct net_d
 		{
 			DBG_8192D("rtw_efuse_access error\n");
 		}
-		else{
+		else {
 			DBG_8192D("rtw_efuse_access ok\n");
 		}
 		memset(extra, '\0', sizeof(extra));
@@ -8153,7 +8153,7 @@ static int rtw_mp_efuse_get(struct net_d
 		wrqu->length = strlen(extra);
 
 		return 0;
-	}else
+	} else
 	{
 		 sprintf(extra, "%s : Command not found\n",extra);
 		  wrqu->length = strlen(extra);
@@ -8243,7 +8243,7 @@ static int rtw_mp_efuse_set(struct net_d
 					setrawdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+ 1]);
 			}
 
-			if (rtw_efuse_access(padapter, true, addr, cnts, setrawdata) == _FAIL){
+			if (rtw_efuse_access(padapter, true, addr, cnts, setrawdata) == _FAIL) {
 					DBG_8192D("\t  rtw_efuse_map_read : Fail\n");
 						return -EFAULT;
 			} else
@@ -8257,7 +8257,7 @@ static int rtw_mp_efuse_set(struct net_d
 				addr = 0x19;
 				cnts = strlen(tmp[1])/2;
 				if (cnts == 0) return -EFAULT;
-				if (cnts > 6){
+				if (cnts > 6) {
 						DBG_8192D("error data for mac addr = %s\n" ,tmp[1]);
 						return -EFAULT;
 				}
@@ -8313,7 +8313,7 @@ static int rtw_mp_efuse_set(struct net_d
 				DBG_8192D("rtw_efuse_map_write ok\n");
 
 			return 0;
-		} else{
+		} else {
 			DBG_8192D("Command not found\n");
 			return 0;
 		}
@@ -8477,7 +8477,7 @@ static int rtw_mp_read_reg(struct net_de
 						  strtout = simple_strtoul (pnext , &ptmp, 16);
 						  sprintf(extra, "%s %d" ,extra ,strtout);
 					}
-					else{
+					else {
 						  break;
 					}
 					pch = pnext;
@@ -8511,7 +8511,7 @@ static int rtw_mp_read_reg(struct net_de
 						  strtout = simple_strtoul (pnext , &ptmp, 16);
 						  sprintf(extra, "%s %d" ,extra ,strtout);
 					}
-					else{
+					else {
 			break;
 					}
 					pch = pnext;
@@ -8621,7 +8621,7 @@ static int rtw_mp_read_rf(struct net_dev
 						  strtou = simple_strtoul (pnext , &ptmp, 16);
 						  sprintf(extra, "%s %d" ,extra ,strtou);
 					}
-					else{
+					else {
 						  break;
 					}
 					pch = pnext;
@@ -8940,7 +8940,7 @@ static int rtw_mp_ctx(struct net_device
 
 		case MP_SINGLE_TONE_TX:
 			//DBG_8192D("%s: sgleTx %d\n", __func__, bStartTest);
-			if (bStartTest != 0){
+			if (bStartTest != 0) {
 				sprintf(extra, "Start continuous DA=ffffffffffff len=1500\n infinite=yes.");
 
 			 }
@@ -8949,7 +8949,7 @@ static int rtw_mp_ctx(struct net_device
 
 		case MP_CONTINUOUS_TX:
 			DBG_8192D("%s: cotuTx %d\n", __func__, bStartTest);
-			if (bStartTest != 0){
+			if (bStartTest != 0) {
 				sprintf(extra, "Start continuous DA=ffffffffffff len=1500\n infinite=yes.");
 			 }
 			 Hal_SetContinuousTx(padapter, (u8)bStartTest);
@@ -8957,11 +8957,11 @@ static int rtw_mp_ctx(struct net_device
 
 		case MP_CARRIER_SUPPRISSION_TX:
 			//DBG_8192D("%s: CarrSprTx %d\n", __func__, bStartTest);
-			if (bStartTest != 0){
+			if (bStartTest != 0) {
 				if (pmp_priv->rateidx <= MPT_RATE_11M)
 				{
 					sprintf(extra, "Start continuous DA=ffffffffffff len=1500\n infinite=yes.");
-				}else
+				} else
 					sprintf(extra, "Specify carrier suppression but not CCK rate");
 			}
 			Hal_SetCarrierSuppressionTx(padapter, (u8)bStartTest);
@@ -8969,7 +8969,7 @@ static int rtw_mp_ctx(struct net_device
 
 		case MP_SINGLE_CARRIER_TX:
 			//DBG_8192D("%s: scTx %d\n", __func__, bStartTest);
-			if (bStartTest != 0){
+			if (bStartTest != 0) {
 				sprintf(extra, "Start continuous DA=ffffffffffff len=1500\n infinite=yes.");
 			}
 			Hal_SetSingleCarrierTx(padapter, (u8)bStartTest);
@@ -9081,7 +9081,7 @@ static int rtw_mp_pwrtrk(struct net_devi
 				ret = Hal_SetThermalMeter(padapter, (u8)thermal);
 				if (ret == _FAIL) return -EPERM;
 				sprintf(extra, "mp tx power tracking start,target value=%d ok ",thermal);
-		}else	{
+		} else	{
 			return -EINVAL;
 		}
 	}
@@ -9568,7 +9568,7 @@ static int rtw_tdls_setup(struct net_dev
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
+	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3) {
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
 	}
 
@@ -9611,7 +9611,7 @@ static int rtw_tdls_teardown(struct net_
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
+	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3) {
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
 	}
 
@@ -9664,7 +9664,7 @@ static int rtw_tdls_ch_switch (struct ne
 
 	DBG_8192S("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
+	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3) {
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
 	}
 
@@ -9696,7 +9696,7 @@ static int rtw_tdls_pson(struct net_devi
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
+	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3) {
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
 	}
 
@@ -9725,7 +9725,7 @@ static int rtw_tdls_psoff(struct net_dev
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
+	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3) {
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
 	}
 
@@ -9925,7 +9925,7 @@ static int rtw_tdls_ch_switch_off(struct
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
-	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3){
+	for (i=0, j=0 ; i < ETH_ALEN; i++, j+=3) {
 		mac_addr[i]=key_2char2num(*(extra+j), *(extra+j+1));
 	}
 
@@ -9933,7 +9933,7 @@ static int rtw_tdls_ch_switch_off(struct
 
 	ptdls_sta->tdls_sta_state |= TDLS_SW_OFF_STATE;
 /*
-	if ((ptdls_sta->tdls_sta_state & TDLS_AT_OFF_CH_STATE) && (ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE)){
+	if ((ptdls_sta->tdls_sta_state & TDLS_AT_OFF_CH_STATE) && (ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE)) {
 		pmlmeinfo->tdls_candidate_ch= pmlmeext->cur_channel;
 		issue_tdls_ch_switch_req(padapter, mac_addr);
 		DBG_8192D("issue tdls ch switch req back to base channel\n");
@@ -10118,7 +10118,7 @@ static int rtw_wowlan_ctrl(struct net_de
 	bset = (u8)(p->flags & 0xFFFF);
 	len = p->length;
 	pparmbuf = (u8*)rtw_malloc(len);
-	if (pparmbuf == NULL){
+	if (pparmbuf == NULL) {
 		ret = -ENOMEM;
 		goto _rtw_wowlan_ctrl_exit;
 	}
@@ -10129,7 +10129,7 @@ static int rtw_wowlan_ctrl(struct net_de
 	}
 	poidparam = (struct wowlan_ioctl_param *)pparmbuf;
 
-	if (padapter->pwrctrlpriv.bSupportRemoteWakeup==false){
+	if (padapter->pwrctrlpriv.bSupportRemoteWakeup==false) {
 		ret = -EPERM;
 		DBG_8192D("+rtw_wowlan_ctrl: Device didn't support the remote wakeup!!\n");
 		goto _rtw_wowlan_ctrl_exit_free;
@@ -10528,7 +10528,7 @@ static struct iw_statistics *rtw_get_wir
 		piwstats->qual.noise = 0;
 		//DBG_8192D("No link  level:%d, qual:%d, noise:%d\n", tmp_level, tmp_qual, tmp_noise);
 	}
-	else{
+	else {
 		#ifdef CONFIG_SIGNAL_DISPLAY_DBM
 		tmp_level = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);
 		#else
--- a/drivers/staging/rtl8192du/os_dep/mlme_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/mlme_linux.c
@@ -203,7 +203,7 @@ _func_enter_;
 		len = sec_ie[1]+2;
 		len =  (len < IW_CUSTOM_MAX) ? len:IW_CUSTOM_MAX;
 
-		for (i=0;i<len;i++){
+		for (i=0;i<len;i++) {
 			p+=sprintf(p,"%02x",sec_ie[i]);
 		}
 
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -643,7 +643,7 @@ void rtw_proc_remove_one(struct net_devi
 
 	if (rtw_proc_cnt == 0)
 	{
-		if (rtw_proc){
+		if (rtw_proc) {
 			remove_proc_entry("ver_info", rtw_proc);
 
 			remove_proc_entry("log_level", rtw_proc);
@@ -1052,14 +1052,14 @@ void rtw_stop_drv_threads (struct rtw_ad
 	{
 		/* Below is to termindate rtw_cmd_thread & event_thread... */
 		_rtw_up_sema(&padapter->cmdpriv.cmd_queue_sema);
-		if (padapter->cmdThread){
+		if (padapter->cmdThread) {
 			_rtw_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema);
 		}
 	}
 
 #ifdef CONFIG_EVENT_THREAD_MODE
         _rtw_up_sema(&padapter->evtpriv.evt_notify);
-	if (padapter->evtThread){
+	if (padapter->evtThread) {
 		_rtw_down_sema(&padapter->evtpriv.terminate_evtthread_sema);
 	}
 #endif
@@ -2207,7 +2207,7 @@ int _netdev_open(struct net_device *pnet
 	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+871x_drv - dev_open\n"));
 	DBG_8192D("+871x_drv - drv_open, bup =%d\n", padapter->bup);
 
-	if (pwrctrlpriv->ps_flag == true){
+	if (pwrctrlpriv->ps_flag == true) {
 		padapter->net_closed = false;
 		goto netdev_open_normal_process;
 	}
@@ -2425,7 +2425,7 @@ static int netdev_close(struct net_devic
 	}
 	padapter->net_closed = true;
 
-	if (padapter->pwrctrlpriv.rf_pwrstate == rf_on){
+	if (padapter->pwrctrlpriv.rf_pwrstate == rf_on) {
 		DBG_8192D("(2)871x_drv - drv_close, bup =%d, hw_init_completed =%d\n", padapter->bup, padapter->hw_init_completed);
 
 		/* s1. */
--- a/drivers/staging/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8192du/os_dep/osdep_service.c
@@ -33,7 +33,7 @@
 * Translate the OS dependent @param error_code to OS independent RTW_STATUS_CODE
 * @return: one of RTW_STATUS_CODE
 */
-inline int RTW_STATUS_CODE(int error_code){
+inline int RTW_STATUS_CODE(int error_code) {
 	if (error_code >=0)
 		return _SUCCESS;
 
@@ -531,7 +531,7 @@ static int retriveFromFile(char *path, u
 	struct file *fp;
 
 	if (path && buf) {
-		if (0 == (ret=openFile(&fp,path, O_RDONLY, 0))){
+		if (0 == (ret=openFile(&fp,path, O_RDONLY, 0))) {
 			DBG_8192D("%s openFile path:%s fp=%p\n",__func__, path ,fp);
 
 			oldfs = get_fs(); set_fs(get_ds());
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -65,7 +65,7 @@ int rtw_os_recvbuf_resource_alloc(struct
 
 	precvbuf->irp_pending = false;
 	precvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);
-	if (precvbuf->purb == NULL){
+	if (precvbuf->purb == NULL) {
 		res = _FAIL;
 	}
 
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -351,7 +351,7 @@ int rtw_android_priv_cmd(struct net_devi
 		goto exit;
 	}
 
-	if (!access_ok(VERIFY_READ, priv_cmd.buf, priv_cmd.total_len)){
+	if (!access_ok(VERIFY_READ, priv_cmd.buf, priv_cmd.total_len)) {
 		DBG_8192D("%s: failed to access memory\n", __func__);
 		ret = -EFAULT;
 		goto exit;
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -567,7 +567,7 @@ static void rtw_dev_unload(struct rtw_ad
 		{
 			//DBG_8192D("r871x_dev_unload()->rtl871x_hal_deinit()\n");
 #ifdef CONFIG_WOWLAN
-			if ((padapter->pwrctrlpriv.bSupportRemoteWakeup==true)&&(padapter->pwrctrlpriv.wowlan_mode==true)){
+			if ((padapter->pwrctrlpriv.bSupportRemoteWakeup==true)&&(padapter->pwrctrlpriv.wowlan_mode==true)) {
 				DBG_8192D("%s bSupportWakeOnWlan==true  do not run rtw_hal_deinit()\n",__func__);
 			}
 			else
@@ -798,7 +798,7 @@ static int rtw_suspend(struct usb_interf
 		rtw_netif_stop_queue(pnetdev);
 	}
 #ifdef CONFIG_WOWLAN
-	if (padapter->pwrctrlpriv.bSupportRemoteWakeup==true&&padapter->pwrctrlpriv.wowlan_mode==true){
+	if (padapter->pwrctrlpriv.bSupportRemoteWakeup==true&&padapter->pwrctrlpriv.wowlan_mode==true) {
 		u8 ps_mode=PS_MODE_MIN;
 		//set H2C command
 		poidparam.subcode=WOWLAN_ENABLE;
@@ -864,7 +864,7 @@ static int rtw_resume(struct usb_interfa
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	 int ret = 0;
 
-	if (pwrpriv->bInternalAutoSuspend){
+	if (pwrpriv->bInternalAutoSuspend) {
 		ret = rtw_resume_process(padapter);
 	} else {
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
@@ -939,7 +939,7 @@ int rtw_resume_process(struct rtw_adapte
 			{
 				int keyid;
 
-				for (keyid=0;keyid<4;keyid++){
+				for (keyid=0;keyid<4;keyid++) {
 					if (pwrpriv->wepkeymask & BIT(keyid)) {
 						if (keyid == padapter->securitypriv.dot11PrivacyKeyIndex)
 							rtw_set_key(padapter,&padapter->securitypriv, keyid, 1);
@@ -1149,7 +1149,7 @@ struct rtw_adapter *rtw_usb_if1_init(str
 #ifdef CONFIG_AUTOSUSPEND
 	if (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
 	{
-		if (padapter->registrypriv.usbss_enable){	/* autosuspend (2s delay) */
+		if (padapter->registrypriv.usbss_enable) {	/* autosuspend (2s delay) */
 			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,38))
 			dvobj->pusbdev->dev.power.autosuspend_delay = 0 * HZ;//15 * HZ; idle-delay time
 			#else

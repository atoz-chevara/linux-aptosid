From bbb742a1a52bab7b916723ecb6e6ec86c34d5c06 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Wed, 24 Apr 2013 00:55:09 -0500
Subject: [PATCH 056/210] Clean up {enter,exit}_critical_section_bh

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_ap.c           |  98 ++++++++++++------------------
 core/rtw_br_ext.c       |  59 ++++++++----------
 core/rtw_cmd.c          |  51 +++++-----------
 core/rtw_debug.c        |   5 +-
 core/rtw_ioctl_set.c    |  28 ++++-----
 core/rtw_mlme.c         | 155 ++++++++++++++++++++----------------------------
 core/rtw_mlme_ext.c     |  65 ++++++++------------
 core/rtw_p2p.c          |  28 ++++-----
 core/rtw_pwrctrl.c      |  12 ++--
 core/rtw_recv.c         |  61 +++++--------------
 core/rtw_sreset.c       |   1 -
 core/rtw_sta_mgt.c      |  95 +++++++----------------------
 core/rtw_tdls.c         |  56 ++++++-----------
 core/rtw_xmit.c         | 129 +++++++++++-----------------------------
 hal/rtl8192d_dm.c       |   5 +-
 hal/rtl8192du_xmit.c    |  21 +++----
 hal/usb_ops_linux.c     |  18 ------
 include/osdep_service.h |  10 ----
 include/rtw_mlme.h      |  30 ++++------
 os_dep/ioctl_cfg80211.c |  58 ++++++++----------
 os_dep/ioctl_linux.c    | 137 ++++++++++++++++++------------------------
 os_dep/xmit_linux.c     |  12 ++--
 22 files changed, 394 insertions(+), 740 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_ap.c
+++ b/drivers/staging/rtl8192du/core/rtw_ap.c
@@ -53,7 +53,6 @@ void init_mlme_ap_info(_adapter *padapte
 
 void free_mlme_ap_info(_adapter *padapter)
 {
-	_irqL irqL;
 	struct sta_info *psta=NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -74,13 +73,11 @@ void free_mlme_ap_info(_adapter *padapte
 
 	//free bc/mc sta_info
 	psta = rtw_get_bcmc_stainfo(padapter);
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
 	rtw_free_stainfo(padapter, psta);
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
-
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 	_rtw_spinlock_free(&pmlmepriv->bcn_update_lock);
-
 }
 
 static void update_BCNTIM(_adapter *padapter)
@@ -352,7 +349,6 @@ u8 chk_sta_is_alive(struct sta_info *pst
 
 void	expire_timeout_chk(_adapter *padapter)
 {
-	_irqL irqL;
 	_list	*phead, *plist;
 	u8 updated;
 	struct sta_info *psta=NULL;
@@ -361,7 +357,7 @@ void	expire_timeout_chk(_adapter *padapt
 	char chk_alive_list[NUM_STA];
 	int i;
 
-	_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->auth_list_lock);
 
 	phead = &pstapriv->auth_list;
 	plist = get_next(phead);
@@ -389,24 +385,24 @@ void	expire_timeout_chk(_adapter *padapt
 				DBG_8192D("auth expire %02X%02X%02X%02X%02X%02X\n",
 					psta->hwaddr[0],psta->hwaddr[1],psta->hwaddr[2],psta->hwaddr[3],psta->hwaddr[4],psta->hwaddr[5]);
 
-				_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
+				spin_unlock_bh(&pstapriv->auth_list_lock);
 
-				_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+				spin_lock_bh(&(pstapriv->sta_hash_lock));
 				rtw_free_stainfo(padapter, psta);
-				_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+				spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
-				_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
+				spin_lock_bh(&pstapriv->auth_list_lock);
 			}
 		}
 
 	}
 
-	_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->auth_list_lock);
 
 	psta = NULL;
 
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
@@ -511,7 +507,7 @@ void	expire_timeout_chk(_adapter *padapt
 		}
 	}
 
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 #ifdef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
 if (chk_alive_num) {
@@ -554,11 +550,11 @@ if (chk_alive_num) {
 		psta->keep_alive_trycnt = 0;
 
 		DBG_8192D("asoc expire %pM, state=0x%x\n", psta->hwaddr, psta->state);
-		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		spin_lock_bh(&pstapriv->asoc_list_lock);
 		rtw_list_delete(&psta->asoc_list);
 		pstapriv->asoc_list_cnt--;
 		updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
-		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	}
 
@@ -791,7 +787,6 @@ static void add_RATid(_adapter *padapter
 
 static void update_bmc_sta(_adapter *padapter)
 {
-	_irqL	irqL;
 	u32 init_rate=0;
 	unsigned char	network_type, raid;
 	int i, supportRateNum = 0;
@@ -875,9 +870,9 @@ static void update_bmc_sta(_adapter *pad
 		psta->raid = raid;
 		psta->init_rate = init_rate;
 
-		_enter_critical_bh(&psta->lock, &irqL);
+		spin_lock_bh(&psta->lock);
 		psta->state = _FW_LINKED;
-		_exit_critical_bh(&psta->lock, &irqL);
+		spin_unlock_bh(&psta->lock);
 
 	}
 	else
@@ -896,7 +891,6 @@ static void update_bmc_sta(_adapter *pad
 
 void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta)
 {
-	_irqL	irqL;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
@@ -971,11 +965,9 @@ void update_sta_info_apmode(_adapter *pa
 	//add_RATid(padapter, psta);//move to ap_sta_info_defer_update()
 
 
-	_enter_critical_bh(&psta->lock, &irqL);
+	spin_lock_bh(&psta->lock);
 	psta->state |= _FW_LINKED;
-	_exit_critical_bh(&psta->lock, &irqL);
-
-
+	spin_unlock_bh(&psta->lock);
 }
 
 static void update_hw_ht_param(_adapter *padapter)
@@ -1755,7 +1747,6 @@ void rtw_set_macaddr_acl(_adapter *padap
 
 int rtw_acl_add_sta(_adapter *padapter, u8 *addr)
 {
-	_irqL irqL;
 	_list	*plist, *phead;
 	u8 added = false;
 	int i, ret=0;
@@ -1770,7 +1761,7 @@ int rtw_acl_add_sta(_adapter *padapter,
 		return (-1);
 
 
-	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_lock_bh(&(pacl_node_q->lock));
 
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
@@ -1791,14 +1782,14 @@ int rtw_acl_add_sta(_adapter *padapter,
 		}
 	}
 
-	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_unlock_bh(&(pacl_node_q->lock));
 
 
 	if(added == true)
 		return ret;
 
 
-	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_lock_bh(&(pacl_node_q->lock));
 
 	for(i=0; i< NUM_ACL; i++)
 	{
@@ -1822,14 +1813,13 @@ int rtw_acl_add_sta(_adapter *padapter,
 
 	DBG_8192D("%s, acl_num=%d\n", __func__, pacl_list->num);
 
-	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_unlock_bh(&(pacl_node_q->lock));
 
 	return ret;
 }
 
 int rtw_acl_remove_sta(_adapter *padapter, u8 *addr)
 {
-	_irqL irqL;
 	_list	*plist, *phead;
 	int i, ret=0;
 	struct rtw_wlan_acl_node *paclnode;
@@ -1839,7 +1829,7 @@ int rtw_acl_remove_sta(_adapter *padapte
 
 	DBG_8192D("%s(acl_num=%d)=%pM\n", __func__, pacl_list->num, addr);
 
-	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_lock_bh(&(pacl_node_q->lock));
 
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
@@ -1862,7 +1852,7 @@ int rtw_acl_remove_sta(_adapter *padapte
 		}
 	}
 
-	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_unlock_bh(&(pacl_node_q->lock));
 
 	DBG_8192D("%s, acl_num=%d\n", __func__, pacl_list->num);
 
@@ -2034,7 +2024,6 @@ static void update_bcn_vendor_spec_ie(_a
 
 void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)
 {
-	_irqL irqL;
 	struct mlme_priv *pmlmepriv;
 	struct mlme_ext_priv	*pmlmeext;
 	//struct mlme_ext_info	*pmlmeinfo;
@@ -2051,7 +2040,7 @@ void update_beacon(_adapter *padapter, u
 	if(false == pmlmeext->bstart_bss)
 		return;
 
-	_enter_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);
+	spin_lock_bh(&pmlmepriv->bcn_update_lock);
 
 	switch(ie_id)
 	{
@@ -2103,7 +2092,7 @@ void update_beacon(_adapter *padapter, u
 
 	pmlmepriv->update_bcn = true;
 
-	_exit_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->bcn_update_lock);
 
 #ifndef CONFIG_INTERRUPT_BASED_TXBCN
 	if(tx)
@@ -2203,12 +2192,11 @@ void associated_clients_update(_adapter
 	//update associcated stations cap.
 	if(updated == true)
 	{
-		_irqL irqL;
 		_list	*phead, *plist;
 		struct sta_info *psta=NULL;
 		struct sta_priv *pstapriv = &padapter->stapriv;
 
-		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		spin_lock_bh(&pstapriv->asoc_list_lock);
 
 		phead = &pstapriv->asoc_list;
 		plist = get_next(phead);
@@ -2223,10 +2211,8 @@ void associated_clients_update(_adapter
 			VCS_update(padapter, psta);
 		}
 
-		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
 	}
-
 }
 
 /* called > TSR LEVEL for USB or SDIO Interface*/
@@ -2511,7 +2497,6 @@ u8 bss_cap_update_on_sta_leave(_adapter
 
 u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, bool active, u16 reason)
 {
-	_irqL irqL;
 	u8 beacon_updated = false;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
@@ -2539,9 +2524,9 @@ u8 ap_free_sta(_adapter *padapter, struc
 	rtw_clearstakey_cmd(padapter, (u8*)psta, (u8)(psta->mac_id + 3), true);
 
 
-	_enter_critical_bh(&psta->lock, &irqL);
+	spin_lock_bh(&psta->lock);
 	psta->state &= ~_FW_LINKED;
-	_exit_critical_bh(&psta->lock, &irqL);
+	spin_unlock_bh(&psta->lock);
 
 	#ifdef CONFIG_IOCTL_CFG80211
 	if (1) {
@@ -2562,9 +2547,9 @@ u8 ap_free_sta(_adapter *padapter, struc
 
 	beacon_updated = bss_cap_update_on_sta_leave(padapter, psta);
 
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
 	rtw_free_stainfo(padapter, psta);
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 
 	return beacon_updated;
@@ -2573,7 +2558,6 @@ u8 ap_free_sta(_adapter *padapter, struc
 
 int rtw_ap_inform_ch_switch(_adapter *padapter, u8 new_ch, u8 ch_offset)
 {
-	_irqL irqL;
 	_list	*phead, *plist;
 	int ret=0;
 	struct sta_info *psta = NULL;
@@ -2588,7 +2572,7 @@ int rtw_ap_inform_ch_switch(_adapter *pa
 	DBG_8192D(FUNC_NDEV_FMT" with ch:%u, offset:%u\n",
 		FUNC_NDEV_ARG(padapter->pnetdev), new_ch, ch_offset);
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
@@ -2601,7 +2585,7 @@ int rtw_ap_inform_ch_switch(_adapter *pa
 		issue_action_spct_ch_switch(padapter, psta->hwaddr, new_ch, ch_offset);
 		psta->expire_to = ((pstapriv->expire_to * 2) > 5) ? 5 : (pstapriv->expire_to * 2);
 	}
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	issue_action_spct_ch_switch(padapter, bc_addr, new_ch, ch_offset);
 
@@ -2610,7 +2594,6 @@ int rtw_ap_inform_ch_switch(_adapter *pa
 
 int rtw_sta_flush(_adapter *padapter)
 {
-	_irqL irqL;
 	_list	*phead, *plist;
 	int ret=0;
 	struct sta_info *psta = NULL;
@@ -2625,7 +2608,7 @@ int rtw_sta_flush(_adapter *padapter)
 		return ret;
 
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
@@ -2639,19 +2622,15 @@ int rtw_sta_flush(_adapter *padapter)
 		rtw_list_delete(&psta->asoc_list);
 		pstapriv->asoc_list_cnt--;
 
-		//_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 		ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
-		//_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	}
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	issue_deauth(padapter, bc_addr, WLAN_REASON_DEAUTH_LEAVING);
 
 	associated_clients_update(padapter, true);
 
 	return ret;
-
 }
 
 /* called > TSR LEVEL for USB or SDIO Interface*/
@@ -2761,7 +2740,6 @@ void start_ap_mode(_adapter *padapter)
 
 void stop_ap_mode(_adapter *padapter)
 {
-	_irqL irqL;
 	_list	*phead, *plist;
 	struct rtw_wlan_acl_node *paclnode;
 	struct sta_info *psta=NULL;
@@ -2781,7 +2759,7 @@ void stop_ap_mode(_adapter *padapter)
 	padapter->securitypriv.ndisencryptstatus = Ndis802_11WEPDisabled;
 
 	//for ACL
-	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_lock_bh(&(pacl_node_q->lock));
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
 	while ((rtw_end_of_queue_search(phead, plist)) == false) {
@@ -2796,7 +2774,7 @@ void stop_ap_mode(_adapter *padapter)
 			pacl_list->num--;
 		}
 	}
-	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_unlock_bh(&(pacl_node_q->lock));
 
 	DBG_8192D("%s, free acl_node_queue, num=%d\n", __func__, pacl_list->num);
 
@@ -2806,9 +2784,9 @@ void stop_ap_mode(_adapter *padapter)
 	rtw_free_all_stainfo(padapter);
 
 	psta = rtw_get_bcmc_stainfo(padapter);
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
 	rtw_free_stainfo(padapter, psta);
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 	rtw_init_bcmc_stainfo(padapter);
 
--- a/drivers/staging/rtl8192du/core/rtw_br_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_br_ext.c
@@ -392,9 +392,8 @@ static __inline__ int __nat25_network_ha
 static __inline__ void __network_hash_link(_adapter *priv,
 				struct nat25_network_db_entry *ent, int hash)
 {
-	// Caller must _enter_critical_bh already!
-	//_irqL irqL;
-	//_enter_critical_bh(&priv->br_ext_lock, &irqL);
+	// Caller must spin_lock_bh already!
+	//spin_lock_bh(&priv->br_ext_lock);
 
 	ent->next_hash = priv->nethash[hash];
 	if(ent->next_hash != NULL)
@@ -402,15 +401,14 @@ static __inline__ void __network_hash_li
 	priv->nethash[hash] = ent;
 	ent->pprev_hash = &priv->nethash[hash];
 
-	//_exit_critical_bh(&priv->br_ext_lock, &irqL);
+	//spin_unlock_bh(&priv->br_ext_lock);
 }
 
 
 static __inline__ void __network_hash_unlink(struct nat25_network_db_entry *ent)
 {
-	// Caller must _enter_critical_bh already!
-	//_irqL irqL;
-	//_enter_critical_bh(&priv->br_ext_lock, &irqL);
+	// Caller must spin_lock_bh already!
+	//spin_lock_bh(&priv->br_ext_lock);
 
 	*(ent->pprev_hash) = ent->next_hash;
 	if(ent->next_hash != NULL)
@@ -418,7 +416,7 @@ static __inline__ void __network_hash_un
 	ent->next_hash = NULL;
 	ent->pprev_hash = NULL;
 
-	//_exit_critical_bh(&priv->br_ext_lock, &irqL);
+	//spin_unlock_bh(&priv->br_ext_lock);
 }
 
 
@@ -426,8 +424,7 @@ static int __nat25_db_network_lookup_and
 				struct sk_buff *skb, unsigned char *networkAddr)
 {
 	struct nat25_network_db_entry *db;
-	_irqL irqL;
-	_enter_critical_bh(&priv->br_ext_lock, &irqL);
+	spin_lock_bh(&priv->br_ext_lock);
 
 	db = priv->nethash[__nat25_network_hash(networkAddr)];
 	while (db != NULL)
@@ -487,14 +484,14 @@ static int __nat25_db_network_lookup_and
 					db->networkAddr[10]);
 #endif
 			}
-			_exit_critical_bh(&priv->br_ext_lock, &irqL);
+			spin_unlock_bh(&priv->br_ext_lock);
 			return 1;
 		}
 
 		db = db->next_hash;
 	}
 
-	_exit_critical_bh(&priv->br_ext_lock, &irqL);
+	spin_unlock_bh(&priv->br_ext_lock);
 	return 0;
 }
 
@@ -504,8 +501,7 @@ static void __nat25_db_network_insert(_a
 {
 	struct nat25_network_db_entry *db;
 	int hash;
-	_irqL irqL;
-	_enter_critical_bh(&priv->br_ext_lock, &irqL);
+	spin_lock_bh(&priv->br_ext_lock);
 
 	hash = __nat25_network_hash(networkAddr);
 	db = priv->nethash[hash];
@@ -515,7 +511,7 @@ static void __nat25_db_network_insert(_a
 		{
 			memcpy(db->macAddr, macAddr, ETH_ALEN);
 			db->ageing_timer = jiffies;
-			_exit_critical_bh(&priv->br_ext_lock, &irqL);
+			spin_unlock_bh(&priv->br_ext_lock);
 			return;
 		}
 
@@ -524,7 +520,7 @@ static void __nat25_db_network_insert(_a
 
 	db = (struct nat25_network_db_entry *) rtw_malloc(sizeof(*db));
 	if(db == NULL) {
-		_exit_critical_bh(&priv->br_ext_lock, &irqL);
+		spin_unlock_bh(&priv->br_ext_lock);
 		return;
 	}
 
@@ -535,14 +531,13 @@ static void __nat25_db_network_insert(_a
 
 	__network_hash_link(priv, db, hash);
 
-	_exit_critical_bh(&priv->br_ext_lock, &irqL);
+	spin_unlock_bh(&priv->br_ext_lock);
 }
 
 
 static void __nat25_db_print(_adapter *priv)
 {
-	_irqL irqL;
-	_enter_critical_bh(&priv->br_ext_lock, &irqL);
+	spin_lock_bh(&priv->br_ext_lock);
 
 #ifdef BR_EXT_DEBUG
 	static int counter = 0;
@@ -618,7 +613,7 @@ static void __nat25_db_print(_adapter *p
 	}
 #endif
 
-	_exit_critical_bh(&priv->br_ext_lock, &irqL);
+	spin_unlock_bh(&priv->br_ext_lock);
 }
 
 
@@ -631,8 +626,7 @@ static void __nat25_db_print(_adapter *p
 void nat25_db_cleanup(_adapter *priv)
 {
 	int i;
-	_irqL irqL;
-	_enter_critical_bh(&priv->br_ext_lock, &irqL);
+	spin_lock_bh(&priv->br_ext_lock);
 
 	for(i=0; i<NAT25_HASH_SIZE; i++)
 	{
@@ -655,15 +649,14 @@ void nat25_db_cleanup(_adapter *priv)
 		}
 	}
 
-	_exit_critical_bh(&priv->br_ext_lock, &irqL);
+	spin_unlock_bh(&priv->br_ext_lock);
 }
 
 
 void nat25_db_expire(_adapter *priv)
 {
 	int i;
-	_irqL irqL;
-	_enter_critical_bh(&priv->br_ext_lock, &irqL);
+	spin_lock_bh(&priv->br_ext_lock);
 
 	//if(!priv->ethBrExtInfo.nat25_disable)
 	{
@@ -748,7 +741,7 @@ void nat25_db_expire(_adapter *priv)
 		}
 	}
 
-	_exit_critical_bh(&priv->br_ext_lock, &irqL);
+	spin_unlock_bh(&priv->br_ext_lock);
 }
 
 
@@ -1520,8 +1513,7 @@ int nat25_handle_frame(_adapter *priv, s
 
 		if (!priv->ethBrExtInfo.nat25_disable)
 		{
-			_irqL irqL;
-			_enter_critical_bh(&priv->br_ext_lock, &irqL);
+			spin_lock_bh(&priv->br_ext_lock);
 			/*
 			 *	This function look up the destination network address from
 			 *	the NAT2.5 database. Return value = -1 means that the
@@ -1532,10 +1524,10 @@ int nat25_handle_frame(_adapter *priv, s
 				!memcmp(priv->scdb_ip, skb->data+ETH_HLEN+16, 4)) {
 				memcpy(skb->data, priv->scdb_mac, ETH_ALEN);
 
-				_exit_critical_bh(&priv->br_ext_lock, &irqL);
+				spin_unlock_bh(&priv->br_ext_lock);
 			}
 			else {
-				_exit_critical_bh(&priv->br_ext_lock, &irqL);
+				spin_unlock_bh(&priv->br_ext_lock);
 
 				retval = nat25_db_handle(priv, skb, NAT25_LOOKUP);
 			}
@@ -1644,8 +1636,7 @@ void *scdb_findEntry(_adapter *priv, uns
 	unsigned char networkAddr[MAX_NETWORK_ADDR_LEN];
 	struct nat25_network_db_entry *db;
 	int hash;
-	//_irqL irqL;
-	//_enter_critical_bh(&priv->br_ext_lock, &irqL);
+	//spin_lock_bh(&priv->br_ext_lock);
 
 	__nat25_generate_ipv4_network_addr(networkAddr, (unsigned int *)ipAddr);
 	hash = __nat25_network_hash(networkAddr);
@@ -1653,14 +1644,14 @@ void *scdb_findEntry(_adapter *priv, uns
 	while (db != NULL)
 	{
 		if(!memcmp(db->networkAddr, networkAddr, MAX_NETWORK_ADDR_LEN)) {
-			//_exit_critical_bh(&priv->br_ext_lock, &irqL);
+			//spin_unlock_bh(&priv->br_ext_lock);
 			return (void *)db;
 		}
 
 		db = db->next_hash;
 	}
 
-	//_exit_critical_bh(&priv->br_ext_lock, &irqL);
+	//spin_unlock_bh(&priv->br_ext_lock);
 	return NULL;
 }
 
--- a/drivers/staging/rtl8192du/core/rtw_cmd.c
+++ b/drivers/staging/rtl8192du/core/rtw_cmd.c
@@ -512,7 +512,6 @@ _func_exit_;
 #ifdef CONFIG_EVENT_THREAD_MODE
 u32 rtw_enqueue_evt(struct evt_priv *pevtpriv, struct evt_obj *obj)
 {
-	_irqL irqL;
 	int	res;
 	_queue *queue = &pevtpriv->evt_queue;
 
@@ -525,11 +524,11 @@ _func_enter_;
 		goto exit;
 	}
 
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 
 	rtw_list_insert_tail(&obj->list, &queue->queue);
 
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 	//rtw_evt_notify_isr(pevtpriv);
 
@@ -542,12 +541,11 @@ _func_exit_;
 
 struct evt_obj *rtw_dequeue_evt(_queue *queue)
 {
-	_irqL irqL;
 	struct	evt_obj	*pevtobj;
 
 _func_enter_;
 
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 
 	if (rtw_is_list_empty(&(queue->queue)))
 		pevtobj = NULL;
@@ -557,7 +555,7 @@ _func_enter_;
 		rtw_list_delete(&pevtobj->list);
 	}
 
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 _func_exit_;
 
@@ -2565,16 +2563,15 @@ _func_exit_;
 }
 void rtw_disassoc_cmd_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
 {
-	_irqL	irqL;
 	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
 _func_enter_;
 
 	if (pcmd->res != H2C_SUCCESS)
 	{
-		_enter_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_lock_bh(&pmlmepriv->lock);
 		set_fwstate(pmlmepriv, _FW_LINKED);
-		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_unlock_bh(&pmlmepriv->lock);
 
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ***Error: disconnect_cmd_callback Fail ***\n."));
 
@@ -2619,7 +2616,6 @@ _func_exit_;
 
 void rtw_createbss_cmd_callback(_adapter *padapter, struct cmd_obj *pcmd)
 {
-	_irqL irqL;
 	u8 timer_cancelled;
 	struct sta_info *psta = NULL;
 	struct wlan_network *pwlan = NULL;
@@ -2656,7 +2652,7 @@ _func_enter_;
 	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
 #endif
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) )
@@ -2676,17 +2672,16 @@ _func_enter_;
 	}
 	else
 	{
-		_irqL	irqL;
 
 		pwlan = _rtw_alloc_network(pmlmepriv);
-		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 		if ( pwlan == NULL)
 		{
 			pwlan = rtw_get_oldest_wlan_network(&pmlmepriv->scanned_queue);
 			if( pwlan == NULL)
 			{
 				RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n Error:  can't get pwlan in rtw_joinbss_event_callback \n"));
-				_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 				goto createbss_cmd_fail;
 			}
 			pwlan->last_scanned = rtw_get_current_time();
@@ -2710,31 +2705,14 @@ _func_enter_;
 
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
-#if 0
-		if((pmlmepriv->fw_state) & WIFI_AP_STATE)
-		{
-			psta = rtw_alloc_stainfo(&padapter->stapriv, pnetwork->MacAddress);
-
-			if (psta == NULL) { // for AP Mode & Adhoc Master Mode
-				RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nCan't alloc sta_info when createbss_cmd_callback\n"));
-				goto createbss_cmd_fail ;
-			}
-
-			rtw_indicate_connect( padapter);
-		}
-		else {
-
-			//rtw_indicate_disconnect(dev);
-		}
-#endif
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 		// we will set _FW_LINKED when there is one more sat to join us (rtw_stassoc_event_callback)
 
 	}
 
 createbss_cmd_fail:
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 	rtw_free_cmd_obj(pcmd);
 
@@ -2770,7 +2748,6 @@ _func_exit_;
 }
 void rtw_setassocsta_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
 {
-	_irqL	irqL;
 	struct sta_priv * pstapriv = &padapter->stapriv;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct set_assocsta_parm* passocsta_parm = (struct set_assocsta_parm*)(pcmd->parmbuf);
@@ -2787,13 +2764,13 @@ _func_enter_;
 
 	psta->aid = psta->mac_id = passocsta_rsp->cam_id;
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) && (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true))
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
-       set_fwstate(pmlmepriv, _FW_LINKED);
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	set_fwstate(pmlmepriv, _FW_LINKED);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 exit:
 	rtw_free_cmd_obj(pcmd);
--- a/drivers/staging/rtl8192du/core/rtw_debug.c
+++ b/drivers/staging/rtl8192du/core/rtw_debug.c
@@ -1042,7 +1042,6 @@ int proc_get_all_sta_info(char *page, ch
 			  off_t offset, int count,
 			  int *eof, void *data)
 {
-	_irqL irqL;
 	struct sta_info *psta;
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
@@ -1055,7 +1054,7 @@ int proc_get_all_sta_info(char *page, ch
 
 	len += snprintf(page + len, count - len, "sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
 
-	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_lock_bh(&pstapriv->sta_hash_lock);
 
 	for(i=0; i< NUM_STA; i++)
 	{
@@ -1101,7 +1100,7 @@ int proc_get_all_sta_info(char *page, ch
 
 	}
 
-	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
 
 	*eof = 1;
 	return len;
--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -70,7 +70,6 @@ _func_exit_;
 u8 rtw_do_join(_adapter * padapter);
 u8 rtw_do_join(_adapter * padapter)
 {
-	_irqL	irqL;
 	_list	*plist, *phead;
 	u8* pibss = NULL;
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
@@ -79,7 +78,7 @@ u8 rtw_do_join(_adapter * padapter)
 
 _func_enter_;
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 	phead = get_list_head(queue);
 	plist = get_next(phead);
 
@@ -95,7 +94,7 @@ _func_enter_;
 
 	if(_rtw_queue_empty(queue)== true)
 	{
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
 		//when set_ssid/set_bssid for rtw_do_join(), but scanning queue is empty
@@ -117,7 +116,7 @@ _func_enter_;
 	else
 	{
 		int select_ret;
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 		if((select_ret=rtw_select_and_join_from_scanned_queue(pmlmepriv))==_SUCCESS)
 		{
 			pmlmepriv->to_join = false;
@@ -210,7 +209,6 @@ _func_exit_;
 
 u8 rtw_set_802_11_bssid(_adapter* padapter, u8 *bssid)
 {
-	_irqL irqL;
 	u8 status=_SUCCESS;
 	u32 cur_time = 0;
 
@@ -228,7 +226,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 
 	DBG_8192D("Set BSSID under fw_state=0x%08x\n", get_fwstate(pmlmepriv));
@@ -294,7 +292,7 @@ handle_tkip_countermeasure:
 	}
 
 release_mlme_lock:
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 exit:
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
@@ -307,7 +305,6 @@ _func_exit_;
 
 u8 rtw_set_802_11_ssid(_adapter* padapter, NDIS_802_11_SSID *ssid)
 {
-	_irqL irqL;
 	u8 status = _SUCCESS;
 	u32 cur_time = 0;
 
@@ -327,7 +324,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	DBG_8192D("Set SSID under fw_state=0x%08x\n", get_fwstate(pmlmepriv));
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
@@ -431,7 +428,7 @@ handle_tkip_countermeasure:
 	}
 
 release_mlme_lock:
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 exit:
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
@@ -451,7 +448,6 @@ rtw_set_802_11_infrastructure_mode(~)
 u8 rtw_set_802_11_infrastructure_mode(_adapter* padapter,
 	NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
 {
-	_irqL irqL;
 	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct	wlan_network	*cur_network = &pmlmepriv->cur_network;
 	NDIS_802_11_NETWORK_INFRASTRUCTURE* pold_state = &(cur_network->network.InfrastructureMode);
@@ -536,12 +532,11 @@ _func_exit_;
 
 u8 rtw_set_802_11_disassociate(_adapter *padapter)
 {
-	_irqL irqL;
 	struct mlme_priv * pmlmepriv = &padapter->mlmepriv;
 
 _func_enter_;
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
@@ -552,7 +547,7 @@ _func_enter_;
 		rtw_free_assoc_resources(padapter, 1);
 	}
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 _func_exit_;
 
@@ -561,7 +556,6 @@ _func_exit_;
 
 u8 rtw_set_802_11_bssid_list_scan(_adapter* padapter, NDIS_802_11_SSID *pssid, int ssid_max_num)
 {
-	_irqL	irqL;
 	struct	mlme_priv		*pmlmepriv= &padapter->mlmepriv;
 	u8	res=true;
 
@@ -598,11 +592,11 @@ _func_enter_;
 			return _SUCCESS;
 		}
 
-		_enter_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_lock_bh(&pmlmepriv->lock);
 
 		res = rtw_sitesurvey_cmd(padapter, pssid, ssid_max_num, NULL, 0);
 
-		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_unlock_bh(&pmlmepriv->lock);
 	}
 exit:
 
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -166,18 +166,17 @@ _func_exit_;
 
 int	_rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork)
 {
-	_irqL irqL;
 
 _func_enter_;
 
 	if (pnetwork == NULL)
 		goto exit;
 
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 
 	rtw_list_insert_tail(&pnetwork->list, &queue->queue);
 
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 exit:
 
@@ -188,13 +187,12 @@ _func_exit_;
 
 struct	wlan_network *_rtw_dequeue_network(_queue *queue)
 {
-	_irqL irqL;
 
 	struct wlan_network *pnetwork;
 
 _func_enter_;
 
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 
 	if (_rtw_queue_empty(queue) == true)
 
@@ -207,7 +205,7 @@ _func_enter_;
 		rtw_list_delete(&(pnetwork->list));
 	}
 
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 _func_exit_;
 
@@ -216,14 +214,13 @@ _func_exit_;
 
 struct	wlan_network *_rtw_alloc_network(struct	mlme_priv *pmlmepriv )//(_queue *free_queue)
 {
-	_irqL	irqL;
 	struct	wlan_network	*pnetwork;
 	_queue *free_queue = &pmlmepriv->free_bss_pool;
 	_list* plist = NULL;
 
 _func_enter_;
 
-	_enter_critical_bh(&free_queue->lock, &irqL);
+	spin_lock_bh(&free_queue->lock);
 
 	if (_rtw_queue_empty(free_queue) == true) {
 		pnetwork=NULL;
@@ -245,7 +242,7 @@ _func_enter_;
 	pmlmepriv->num_of_scanned ++;
 
 exit:
-	_exit_critical_bh(&free_queue->lock, &irqL);
+	spin_unlock_bh(&free_queue->lock);
 
 _func_exit_;
 
@@ -256,7 +253,6 @@ void _rtw_free_network(struct	mlme_priv
 {
 	u32 curr_time, delta_time;
 	u32 lifetime = SCANQUEUE_LIFETIME;
-	_irqL irqL;
 	_queue *free_queue = &(pmlmepriv->free_bss_pool);
 
 _func_enter_;
@@ -283,7 +279,7 @@ _func_enter_;
 		}
 	}
 
-	_enter_critical_bh(&free_queue->lock, &irqL);
+	spin_lock_bh(&free_queue->lock);
 
 	rtw_list_delete(&(pnetwork->list));
 
@@ -291,7 +287,7 @@ _func_enter_;
 
 	pmlmepriv->num_of_scanned --;
 
-	_exit_critical_bh(&free_queue->lock, &irqL);
+	spin_unlock_bh(&free_queue->lock);
 
 exit:
 
@@ -312,16 +308,12 @@ _func_enter_;
 	if (pnetwork->fixed == true)
 		goto exit;
 
-	//_enter_critical(&free_queue->lock, &irqL);
-
 	rtw_list_delete(&(pnetwork->list));
 
 	rtw_list_insert_tail(&(pnetwork->list), get_list_head(free_queue));
 
 	pmlmepriv->num_of_scanned --;
 
-	//_exit_critical(&free_queue->lock, &irqL);
-
 exit:
 
 _func_exit_;
@@ -337,7 +329,6 @@ _func_exit_;
 struct wlan_network *_rtw_find_network(_queue *scanned_queue, u8 *addr)
 {
 
-	//_irqL irqL;
 	_list	*phead, *plist;
 	struct	wlan_network *pnetwork = NULL;
 	u8 zero_addr[ETH_ALEN] = {0,0,0,0,0,0};
@@ -349,7 +340,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	//_enter_critical_bh(&scanned_queue->lock, &irqL);
+	//spin_lock_bh(&scanned_queue->lock);
 
 	phead = get_list_head(scanned_queue);
 	plist = get_next(phead);
@@ -367,7 +358,7 @@ _func_enter_;
 	if(plist == phead)
 		pnetwork = NULL;
 
-	//_exit_critical_bh(&scanned_queue->lock, &irqL);
+	//spin_unlock_bh(&scanned_queue->lock);
 
 exit:
 
@@ -380,7 +371,6 @@ _func_exit_;
 
 void _rtw_free_network_queue(_adapter *padapter, u8 isfreeall)
 {
-	_irqL irqL;
 	_list *phead, *plist;
 	struct wlan_network *pnetwork;
 	struct mlme_priv* pmlmepriv = &padapter->mlmepriv;
@@ -389,7 +379,7 @@ void _rtw_free_network_queue(_adapter *p
 _func_enter_;
 
 
-	_enter_critical_bh(&scanned_queue->lock, &irqL);
+	spin_lock_bh(&scanned_queue->lock);
 
 	phead = get_list_head(scanned_queue);
 	plist = get_next(phead);
@@ -405,7 +395,7 @@ _func_enter_;
 
 	}
 
-	_exit_critical_bh(&scanned_queue->lock, &irqL);
+	spin_unlock_bh(&scanned_queue->lock);
 
 _func_exit_;
 
@@ -756,7 +746,6 @@ Caller must hold pmlmepriv->lock first.
 */
 void rtw_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target)
 {
-	_irqL irqL;
 	_list	*plist, *phead;
 	u32	bssid_ex_sz;
 	struct mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
@@ -766,7 +755,7 @@ void rtw_update_scanned_network(_adapter
 
 _func_enter_;
 
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 	phead = get_list_head(queue);
 	plist = get_next(phead);
 
@@ -865,7 +854,7 @@ _func_enter_;
 	}
 
 exit:
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 _func_exit_;
 }
@@ -873,13 +862,11 @@ _func_exit_;
 void rtw_add_network(_adapter *adapter, WLAN_BSSID_EX *pnetwork);
 void rtw_add_network(_adapter *adapter, WLAN_BSSID_EX *pnetwork)
 {
-	_irqL irqL;
 	struct	mlme_priv	*pmlmepriv = &(((_adapter *)adapter)->mlmepriv);
-	//_queue	*queue	= &(pmlmepriv->scanned_queue);
 
 _func_enter_;
 
-	//_enter_critical_bh(&queue->lock, &irqL);
+	//spin_lock_bh(&queue->lock);
 
 	#if defined(CONFIG_P2P) && defined(CONFIG_P2P_REMOVE_GROUP_INFO)
 	rtw_WLAN_BSSID_EX_remove_p2p_attr(pnetwork, P2P_ATTR_GROUP_INFO);
@@ -889,7 +876,7 @@ _func_enter_;
 
 	rtw_update_scanned_network(adapter, pnetwork);
 
-	//_exit_critical_bh(&queue->lock, &irqL);
+	//spin_unlock_bh(&queue->lock);
 
 _func_exit_;
 }
@@ -962,7 +949,6 @@ _func_exit_;
 
 void rtw_survey_event_callback(_adapter	*adapter, u8 *pbuf)
 {
-	_irqL  irqL;
 	u32 len;
 	WLAN_BSSID_EX *pnetwork;
 	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
@@ -981,24 +967,23 @@ _func_enter_;
 	}
 
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	// update IBSS_network 's timestamp
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) {
 		if(_rtw_memcmp(&(pmlmepriv->cur_network.network.MacAddress), pnetwork->MacAddress, ETH_ALEN)) {
 			struct wlan_network* ibss_wlan = NULL;
-			_irqL	irqL;
 
 			_rtw_memcpy(pmlmepriv->cur_network.network.IEs, pnetwork->IEs, 8);
-			_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 			ibss_wlan = rtw_find_network(&pmlmepriv->scanned_queue,  pnetwork->MacAddress);
 			if(ibss_wlan)
 			{
 				_rtw_memcpy(ibss_wlan->network.IEs , pnetwork->IEs, 8);
-				_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 				goto exit;
 			}
-			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 		}
 	}
 
@@ -1014,7 +999,7 @@ _func_enter_;
 
 exit:
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 _func_exit_;
 
@@ -1025,7 +1010,6 @@ _func_exit_;
 
 void rtw_surveydone_event_callback(_adapter	*adapter, u8 *pbuf)
 {
-	_irqL  irqL;
 	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
 #ifdef CONFIG_MLME_EXT
 
@@ -1035,7 +1019,7 @@ void rtw_surveydone_event_callback(_adap
 
 _func_enter_;
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	if(pmlmepriv->wps_probe_req_ie)
 	{
@@ -1149,7 +1133,7 @@ _func_enter_;
 	indicate_wx_scan_complete_event(adapter);
 	//DBG_8192D("scan complete in %dms\n",rtw_get_passing_time_ms(pmlmepriv->scan_start_time));
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 #ifdef CONFIG_P2P_PS
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
@@ -1201,7 +1185,6 @@ void rtw_fwdbg_event_callback(_adapter *
 
 static void free_scanqueue(struct	mlme_priv *pmlmepriv)
 {
-	_irqL irqL, irqL0;
 	_queue *free_queue = &pmlmepriv->free_bss_pool;
 	_queue *scan_queue = &pmlmepriv->scanned_queue;
 	_list	*plist, *phead, *ptemp;
@@ -1209,8 +1192,8 @@ static void free_scanqueue(struct	mlme_p
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+free_scanqueue\n"));
-	_enter_critical_bh(&scan_queue->lock, &irqL0);
-	_enter_critical_bh(&free_queue->lock, &irqL);
+	spin_lock_bh(&scan_queue->lock);
+	spin_lock_bh(&free_queue->lock);
 
 	phead = get_list_head(scan_queue);
 	plist = get_next(phead);
@@ -1224,8 +1207,8 @@ _func_enter_;
 		pmlmepriv->num_of_scanned --;
         }
 
-	_exit_critical_bh(&free_queue->lock, &irqL);
-	_exit_critical_bh(&scan_queue->lock, &irqL0);
+	spin_unlock_bh(&free_queue->lock);
+	spin_unlock_bh(&scan_queue->lock);
 
 _func_exit_;
 }
@@ -1235,7 +1218,6 @@ _func_exit_;
 */
 void rtw_free_assoc_resources(_adapter *adapter, int lock_scanned_queue)
 {
-	_irqL irqL;
 	struct wlan_network* pwlan = NULL;
 	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
 	struct	sta_priv *pstapriv = &adapter->stapriv;
@@ -1262,16 +1244,16 @@ _func_enter_;
 			rtw_tdls_cmd(adapter, myid(&(adapter->eeprompriv)), TDLS_RS_RCR);
 			rtw_reset_tdls_info(adapter);
 			rtw_free_all_stainfo(adapter);
-			_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+			spin_lock_bh(&(pstapriv->sta_hash_lock));
 		}
 		else
 #endif //CONFIG_TDLS
 		{
-			_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+			spin_lock_bh(&(pstapriv->sta_hash_lock));
 			rtw_free_stainfo(adapter,  psta);
 		}
 
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 	}
 
@@ -1282,15 +1264,15 @@ _func_enter_;
 		rtw_free_all_stainfo(adapter);
 
 		psta = rtw_get_bcmc_stainfo(adapter);
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
 		rtw_free_stainfo(adapter, psta);
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 		rtw_init_bcmc_stainfo(adapter);
 	}
 
 	if(lock_scanned_queue)
-		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
 	if(pwlan)
@@ -1310,7 +1292,7 @@ _func_enter_;
 	}
 
 	if(lock_scanned_queue)
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	pmlmepriv->key_mask = 0;
 
@@ -1636,7 +1618,6 @@ static void rtw_joinbss_update_network(_
 //#define REJOIN
 void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 {
-	_irqL irqL,irqL2;
 	static u8 retry=0;
 	u8 timer_cancelled;
 	struct sta_info *ptarget_sta= NULL, *pcur_sta = NULL;
@@ -1672,13 +1653,13 @@ _func_enter_;
 		goto ignore_joinbss_callback;
 	}
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n rtw_joinbss_event_callback !! _enter_critical \n"));
 
 	if(pnetwork->join_res > 0)
 	{
-		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 		retry = 0;
 		if (check_fwstate(pmlmepriv,_FW_UNDER_LINKING) )
 		{
@@ -1696,9 +1677,9 @@ _func_enter_;
 
 					pcur_sta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
 					if(pcur_sta){
-						_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+						spin_lock_bh(&(pstapriv->sta_hash_lock));
 						rtw_free_stainfo(adapter,  pcur_sta);
-						_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+						spin_unlock_bh(&(pstapriv->sta_hash_lock));
 					}
 
 					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
@@ -1724,7 +1705,7 @@ _func_enter_;
 			else
 			{
 				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't find ptarget_wlan when joinbss_event callback\n"));
-				_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 				goto ignore_joinbss_callback;
 			}
 
@@ -1736,7 +1717,7 @@ _func_enter_;
 				if(ptarget_sta==NULL)
 				{
 					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't update stainfo when joinbss_event callback\n"));
-					_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+					spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 					goto ignore_joinbss_callback;
 				}
 			}
@@ -1762,11 +1743,11 @@ _func_enter_;
 		else
 		{
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_joinbss_event_callback err: fw_state:%x", get_fwstate(pmlmepriv)));
-			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 			goto ignore_joinbss_callback;
 		}
 
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	}
 	else if(pnetwork->join_res == -4)
@@ -1821,7 +1802,7 @@ _func_enter_;
 
 ignore_joinbss_callback:
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 	_func_exit_;
 }
 
@@ -1848,7 +1829,6 @@ _func_exit_;
 
 void rtw_stassoc_event_callback(_adapter *adapter, u8 *pbuf)
 {
-	_irqL irqL;
 	struct sta_info *psta;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 	struct stassoc_event	*pstassoc	= (struct stassoc_event*)pbuf;
@@ -1873,7 +1853,7 @@ _func_enter_;
 			u8 *passoc_req = NULL;
 			u32 assoc_req_len;
 
-			_enter_critical_bh(&psta->lock, &irqL);
+			spin_lock_bh(&psta->lock);
 			if(psta->passoc_req && psta->assoc_req_len>0)
 			{
 				passoc_req = rtw_zmalloc(psta->assoc_req_len);
@@ -1887,7 +1867,7 @@ _func_enter_;
 					psta->assoc_req_len = 0;
 				}
 			}
-			_exit_critical_bh(&psta->lock, &irqL);
+			spin_unlock_bh(&psta->lock);
 
 			if(passoc_req && assoc_req_len>0)
 			{
@@ -1933,23 +1913,23 @@ _func_enter_;
 
 	psta->ieee8021x_blocked = false;
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==true ) ||
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true ) )
 	{
 		if(adapter->stapriv.asoc_sta_count== 2)
 		{
-			_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 			ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
 			if(ptarget_wlan)	ptarget_wlan->fixed = true;
-			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 			// a sta + bc/mc_stainfo (not Ibss_stainfo)
 			rtw_indicate_connect(adapter);
 		}
 	}
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 
 	mlmeext_sta_add_event_callback(adapter, psta);
@@ -1960,7 +1940,6 @@ _func_exit_;
 
 void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf)
 {
-	_irqL irqL,irqL2;
 	struct sta_info *psta;
 	struct wlan_network* pwlan = NULL;
 	WLAN_BSSID_EX    *pdev_network=NULL;
@@ -1988,7 +1967,7 @@ _func_enter_;
 
 	mlmeext_sta_del_event_callback(adapter);
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL2);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
 	{
@@ -2008,14 +1987,14 @@ _func_enter_;
 
 		rtw_free_assoc_resources(adapter, 1);
 		rtw_indicate_disconnect(adapter);
-		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 		// remove the network entry in scanned_queue
 		pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
 		if (pwlan) {
 			pwlan->fixed = false;
 			rtw_free_network_nolock(pmlmepriv, pwlan);
 		}
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 		_rtw_roaming(adapter, tgt_network);
 
@@ -2030,14 +2009,14 @@ _func_enter_;
 	{
 		psta = rtw_get_stainfo(&adapter->stapriv, pstadel->macaddr);
 
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
 		rtw_free_stainfo(adapter,  psta);
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 		if(adapter->stapriv.asoc_sta_count== 1) //a sta + bc/mc_stainfo (not Ibss_stainfo)
 		{
 			//rtw_indicate_disconnect(adapter);//removed@20091105
-			_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 			//free old ibss network
 			//pwlan = rtw_find_network(&pmlmepriv->scanned_queue, pstadel->macaddr);
 			pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
@@ -2046,7 +2025,7 @@ _func_enter_;
 				pwlan->fixed = false;
 				rtw_free_network_nolock(pmlmepriv, pwlan);
 			}
-			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 			//re-create ibss
 			pdev_network = &(adapter->registrypriv.dev_network);
 			pibss = adapter->registrypriv.dev_network.MacAddress;
@@ -2078,7 +2057,7 @@ _func_enter_;
 
 	}
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL2);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 _func_exit_;
 
@@ -2110,7 +2089,6 @@ _func_exit_;
 */
 void _rtw_join_timeout_handler (_adapter *adapter)
 {
-	_irqL irqL;
 	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
 #ifdef CONFIG_LAYER2_ROAMING
 	int do_join_r;
@@ -2123,7 +2101,7 @@ _func_enter_;
 		return;
 
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	#ifdef CONFIG_LAYER2_ROAMING
 	if (rtw_to_roaming(adapter) > 0) { /* join timeout caused by roaming */
@@ -2158,7 +2136,7 @@ _func_enter_;
 		free_scanqueue(pmlmepriv);//???
 	}
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 
 #ifdef CONFIG_DRVEXT_MODULE_WSC
@@ -2175,16 +2153,15 @@ _func_exit_;
 */
 void rtw_scan_timeout_handler (_adapter *adapter)
 {
-	_irqL irqL;
 	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
 
 	DBG_8192D(FUNC_ADPT_FMT" fw_state=%x\n", FUNC_ADPT_ARG(adapter), get_fwstate(pmlmepriv));
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 	rtw_indicate_scan_done(adapter, true);
 
@@ -2463,7 +2440,6 @@ pmlmepriv->lock
 
 int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 {
-	_irqL	irqL;
 	int ret;
 	_list	*phead;
 	_adapter *adapter;
@@ -2474,7 +2450,7 @@ int rtw_select_and_join_from_scanned_que
 
 _func_enter_;
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 	phead = get_list_head(queue);
 	adapter = (_adapter *)pmlmepriv->nic_hdl;
 
@@ -2531,7 +2507,7 @@ _func_enter_;
 	ret = rtw_joinbss_cmd(adapter, candidate);
 
 exit:
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 _func_exit_;
 
@@ -3303,12 +3279,11 @@ inline u8 rtw_to_roaming(_adapter *adapt
 
 void rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network)
 {
-	_irqL irqL;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	_rtw_roaming(padapter, tgt_network);
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 }
 void _rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network)
 {
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -1087,7 +1087,6 @@ _END_ONBEACON_:
 unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 {
 #ifdef CONFIG_AP_MODE
-	_irqL irqL;
 	unsigned int	auth_mode, seq, ie_len;
 	unsigned char	*sa, *p;
 	u16	algorithm;
@@ -1165,7 +1164,7 @@ unsigned int OnAuth(_adapter *padapter,
 		pstat->state = WIFI_FW_AUTH_NULL;
 		pstat->auth_seq = 0;
 	} else {
-		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		spin_lock_bh(&pstapriv->asoc_list_lock);
 		if(rtw_is_list_empty(&pstat->asoc_list)==false) {
 			rtw_list_delete(&pstat->asoc_list);
 			pstapriv->asoc_list_cnt--;
@@ -1174,20 +1173,20 @@ unsigned int OnAuth(_adapter *padapter,
 				//TODO: STA re_auth within expire_to
 			}
 		}
-		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 		if (seq==1) {
 			//TODO: STA re_auth and auth timeout
 		}
 	}
 
-	_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->auth_list_lock);
 	if (rtw_is_list_empty(&pstat->auth_list))
 	{
 		rtw_list_insert_tail(&pstat->auth_list, &pstapriv->auth_list);
 		pstapriv->auth_list_cnt++;
 	}
-	_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->auth_list_lock);
 
 	if (pstat->auth_seq == 0)
 		pstat->expire_to = pstapriv->auth_to;
@@ -1404,7 +1403,6 @@ authclnt_fail:
 unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 {
 #ifdef CONFIG_AP_MODE
-	_irqL irqL;
 	u16 capab_info, listen_interval;
 	struct rtw_ieee802_11_elems elems;
 	struct sta_info	*pstat;
@@ -1909,22 +1907,22 @@ unsigned int OnAssocReq(_adapter *padapt
 	pstat->state &= (~WIFI_FW_ASSOC_STATE);
 	pstat->state |= WIFI_FW_ASSOC_SUCCESS;
 
-	_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->auth_list_lock);
 	if (!rtw_is_list_empty(&pstat->auth_list))
 	{
 		rtw_list_delete(&pstat->auth_list);
 		pstapriv->auth_list_cnt--;
 	}
-	_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->auth_list_lock);
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 	if (rtw_is_list_empty(&pstat->asoc_list))
 	{
 		pstat->expire_to = pstapriv->expire_to;
 		rtw_list_insert_tail(&pstat->asoc_list, &pstapriv->asoc_list);
 		pstapriv->asoc_list_cnt++;
 	}
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	// now the station is qualified to join our BSS...
 	if(pstat && (pstat->state & WIFI_FW_ASSOC_SUCCESS) && (_STATS_SUCCESSFUL_==status))
@@ -1949,7 +1947,7 @@ unsigned int OnAssocReq(_adapter *padapt
 			#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 			rtw_cfg80211_indicate_sta_assoc(padapter, pframe, pkt_len);
 			#else //(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
-			_enter_critical_bh(&pstat->lock, &irqL);
+			spin_lock_bh(&pstat->lock);
 			if(pstat->passoc_req)
 			{
 				rtw_mfree(pstat->passoc_req, pstat->assoc_req_len);
@@ -1963,7 +1961,7 @@ unsigned int OnAssocReq(_adapter *padapt
 				_rtw_memcpy(pstat->passoc_req, pframe, pkt_len);
 				pstat->assoc_req_len = pkt_len;
 			}
-			_exit_critical_bh(&pstat->lock, &irqL);
+			spin_unlock_bh(&pstat->lock);
 			#endif //(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 		}
 		else
@@ -2148,14 +2146,9 @@ unsigned int OnDeAuth(_adapter *padapter
 #ifdef CONFIG_AP_MODE
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
-		_irqL irqL;
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &padapter->stapriv;
 
-		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
-		//rtw_free_stainfo(padapter, psta);
-		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
-
 		DBG_8192D("%s, STA: %pM\n", __FUNCTION__, GetAddr2Ptr(pframe));
 
 		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
@@ -2163,7 +2156,7 @@ unsigned int OnDeAuth(_adapter *padapter
 		{
 			u8 updated;
 
-			_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+			spin_lock_bh(&pstapriv->asoc_list_lock);
 			if(rtw_is_list_empty(&psta->asoc_list)==false)
 			{
 				rtw_list_delete(&psta->asoc_list);
@@ -2171,7 +2164,7 @@ unsigned int OnDeAuth(_adapter *padapter
 				updated = ap_free_sta(padapter, psta, false, reason);
 
 			}
-			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 			associated_clients_update(padapter, updated);
 		}
@@ -2221,14 +2214,9 @@ unsigned int OnDisassoc(_adapter *padapt
 #ifdef CONFIG_AP_MODE
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
-		_irqL irqL;
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &padapter->stapriv;
 
-		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
-		//rtw_free_stainfo(padapter, psta);
-		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
-
 		DBG_8192D("%s, STA: %pM\n", __FUNCTION__, GetAddr2Ptr(pframe));
 
 		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
@@ -2236,7 +2224,7 @@ unsigned int OnDisassoc(_adapter *padapt
 		{
 			u8 updated;
 
-			_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+			spin_lock_bh(&pstapriv->asoc_list_lock);
 			if(rtw_is_list_empty(&psta->asoc_list)==false)
 			{
 				rtw_list_delete(&psta->asoc_list);
@@ -2244,7 +2232,7 @@ unsigned int OnDisassoc(_adapter *padapt
 				updated = ap_free_sta(padapter, psta, false, reason);
 
 			}
-			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 			associated_clients_update(padapter, updated);
 		}
@@ -6013,7 +6001,6 @@ void issue_beacon(_adapter *padapter)
 	unsigned int	rate_len;
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
-	_irqL irqL;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 #endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
@@ -6033,7 +6020,7 @@ void issue_beacon(_adapter *padapter)
 		return;
 	}
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
-	_enter_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);
+	spin_lock_bh(&pmlmepriv->bcn_update_lock);
 #endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 
 	//update attribute
@@ -6299,7 +6286,7 @@ _issue_bcn:
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	pmlmepriv->update_bcn = false;
 
-	_exit_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->bcn_update_lock);
 #endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 
 	if ((pattrib->pktlen + TXDESC_SIZE) > 512)
@@ -7946,7 +7933,6 @@ exit:
 
 void issue_action_spct_ch_switch(_adapter *padapter, u8 *ra, u8 new_ch, u8 ch_offset)
 {
-	_irqL	irqL;
 	_list		*plist, *phead;
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
@@ -8140,7 +8126,6 @@ void issue_action_BA(_adapter *padapter,
 
 static void issue_action_BSSCoexistPacket(_adapter *padapter)
 {
-	_irqL	irqL;
 	_list		*plist, *phead;
 	unsigned char category, action;
 	struct xmit_frame			*pmgntframe;
@@ -8220,7 +8205,7 @@ static void issue_action_BSSCoexistPacke
 	{
 		int i;
 
-		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 		phead = get_list_head(queue);
 		plist = get_next(phead);
@@ -8254,7 +8239,7 @@ static void issue_action_BSSCoexistPacke
 
 		}
 
-		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 
 		for(i= 0;i<8;i++)
@@ -11212,7 +11197,6 @@ u8 tx_beacon_hdl(_adapter *padapter, uns
 #ifdef CONFIG_AP_MODE
 	else //tx bc/mc frames after update TIM
 	{
-		_irqL irqL;
 		struct sta_info *psta_bmc;
 		_list	*xmitframe_plist, *xmitframe_phead;
 		struct xmit_frame *pxmitframe=NULL;
@@ -11225,7 +11209,7 @@ u8 tx_beacon_hdl(_adapter *padapter, uns
 
 		if((pstapriv->tim_bitmap&BIT(0)) && (psta_bmc->sleepq_len>0)) {
 			rtw_msleep_os(10);// 10ms, ATIM(HIQ) Windows
-			_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+			spin_lock_bh(&psta_bmc->sleep_q.lock);
 
 			xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
 			xmitframe_plist = get_next(xmitframe_phead);
@@ -11248,18 +11232,18 @@ u8 tx_beacon_hdl(_adapter *padapter, uns
 
 				pxmitframe->attrib.qsel = 0x11;//HIQ
 
-				_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+				spin_unlock_bh(&psta_bmc->sleep_q.lock);
 				if(rtw_hal_xmit(padapter, pxmitframe) == true)
 				{
 					rtw_os_xmit_complete(padapter, pxmitframe);
 				}
-				_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+				spin_lock_bh(&psta_bmc->sleep_q.lock);
 
 				//pstapriv->tim_bitmap &= ~BIT(0);
 
 			}
 
-			_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+			spin_unlock_bh(&psta_bmc->sleep_q.lock);
 
 		}
 
@@ -12305,7 +12289,6 @@ u8 set_csa_hdl(_adapter *padapter, unsig
 u8 tdls_hdl(_adapter *padapter, unsigned char *pbuf)
 {
 #ifdef CONFIG_TDLS
-	_irqL irqL;
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	struct TDLSoption_param *TDLSoption;
 	struct sta_info *ptdls_sta;
@@ -12327,7 +12310,7 @@ u8 tdls_hdl(_adapter *padapter, unsigned
 			return H2C_REJECTED;
 	}
 
-	//_enter_critical_bh(&(ptdlsinfo->hdl_lock), &irqL);
+	//spin_lock_bh(&(ptdlsinfo->hdl_lock));
 	DBG_8192D("[%s] option:%d\n", __FUNCTION__, option);
 
 	switch(option){
@@ -12456,7 +12439,7 @@ u8 tdls_hdl(_adapter *padapter, unsigned
 
 	}
 
-	//_exit_critical_bh(&(ptdlsinfo->hdl_lock), &irqL);
+	//spin_unlock_bh(&(ptdlsinfo->hdl_lock));
 
 	return H2C_SUCCESS;
 #else
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -42,13 +42,12 @@ int rtw_p2p_is_channel_list_ok( u8 desir
 
 int	is_any_client_associated( _adapter *padapter )
 {
-	_irqL irqL;
 	_list	*phead, *plist;
 	int	intFound = false;
 
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
@@ -67,7 +66,7 @@ int	is_any_client_associated( _adapter *
 			, intFound, pstapriv->asoc_list_cnt);
 	}
 
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	return( intFound );
 
@@ -75,7 +74,6 @@ int	is_any_client_associated( _adapter *
 
 static u32 go_add_group_info_attr(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
-	_irqL irqL;
 	_list	*phead, *plist;
 	u32 len=0;
 	u16 attr_len = 0;
@@ -91,7 +89,7 @@ static u32 go_add_group_info_attr(struct
 	pstart = pdata_attr;
 	pcur = pdata_attr;
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
@@ -161,7 +159,7 @@ static u32 go_add_group_info_attr(struct
 
 
 	}
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	if(attr_len>0)
 	{
@@ -2488,10 +2486,9 @@ u32 process_p2p_devdisc_req(struct wifid
 				attr_contentlen=0;
 				if(rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_ID, dev_addr, &attr_contentlen))
 				{
-					_irqL irqL;
 					_list	*phead, *plist;
 
-					_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+					spin_lock_bh(&pstapriv->asoc_list_lock);
 					phead = &pstapriv->asoc_list;
 					plist = get_next(phead);
 
@@ -2506,10 +2503,7 @@ u32 process_p2p_devdisc_req(struct wifid
 							_rtw_memcmp(psta->dev_addr, dev_addr, ETH_ALEN))
 						{
 
-							//_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-							//issue GO Discoverability Request
 							issue_group_disc_req(pwdinfo, psta->hwaddr);
-							//_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
 							status = P2P_STATUS_SUCCESS;
 
@@ -2521,7 +2515,7 @@ u32 process_p2p_devdisc_req(struct wifid
 						}
 
 					}
-					_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+					spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 				}
 				else
@@ -3283,7 +3277,6 @@ void find_phase_handler( _adapter*	padap
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	NDIS_802_11_SSID	ssid;
-	_irqL				irqL;
 	u8					_status = 0;
 
 _func_enter_;
@@ -3294,9 +3287,9 @@ _func_enter_;
 
 	rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	_status = rtw_sitesurvey_cmd(padapter, &ssid, 1, NULL, 0);
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 
 _func_exit_;
@@ -4347,14 +4340,13 @@ static void pre_tx_scan_timer_process (v
 {
 	_adapter							*adapter = (_adapter *) FunctionContext;
 	struct	wifidirect_info				*pwdinfo = &adapter->wdinfo;
-	_irqL							irqL;
 	struct mlme_priv					*pmlmepriv = &adapter->mlmepriv;
 	u8								_status = 0;
 
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 
 	//	Commented by Albert 20110805
 	//	Todo: Use the issuing probe request directly instead of using the rtw_sitesurvey_cmd!!
@@ -4389,7 +4381,7 @@ static void pre_tx_scan_timer_process (v
 		DBG_8192D( "[%s] p2p_state is %d, ignore!!\n", __FUNCTION__, rtw_p2p_state(pwdinfo) );
 	}
 
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 }
 
 static void find_phase_timer_process (void *FunctionContext)
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -389,7 +389,6 @@ void rtw_set_ps_mode(PADAPTER padapter,
 #endif //CONFIG_P2P
 #ifdef CONFIG_TDLS
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	_irqL irqL;
 	int i, j;
 	_list	*plist, *phead;
 	struct sta_info *ptdls_sta;
@@ -424,10 +423,9 @@ _func_enter_;
 			DBG_8192D("rtw_set_ps_mode(): Busy Traffic , Leave 802.11 power save..\n");
 
 #ifdef CONFIG_TDLS
-			_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+			spin_lock_bh(&pstapriv->sta_hash_lock);
 
-			for(i=0; i< NUM_STA; i++)
-			{
+			for(i=0; i< NUM_STA; i++) {
 				phead = &(pstapriv->sta_hash[i]);
 				plist = get_next(phead);
 
@@ -441,7 +439,7 @@ _func_enter_;
 				}
 			}
 
-			_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+			spin_unlock_bh(&pstapriv->sta_hash_lock);
 #endif //CONFIG_TDLS
 
 			pwrpriv->smart_ps = smart_ps;
@@ -478,7 +476,7 @@ _func_enter_;
 			DBG_8192D("rtw_set_ps_mode(): Enter 802.11 power save mode...\n");
 
 #ifdef CONFIG_TDLS
-			_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+			spin_lock_bh(&pstapriv->sta_hash_lock);
 
 			for(i=0; i< NUM_STA; i++)
 			{
@@ -495,7 +493,7 @@ _func_enter_;
 				}
 			}
 
-			_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+			spin_unlock_bh(&pstapriv->sta_hash_lock);
 #endif //CONFIG_TDLS
 
 			pwrpriv->smart_ps = smart_ps;
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -211,14 +211,13 @@ _func_exit_;
 
 union recv_frame *rtw_alloc_recvframe (_queue *pfree_recv_queue)
 {
-	_irqL irqL;
 	union recv_frame  *precvframe;
 
-	_enter_critical_bh(&pfree_recv_queue->lock, &irqL);
+	spin_lock_bh(&pfree_recv_queue->lock);
 
 	precvframe = _rtw_alloc_recvframe(pfree_recv_queue);
 
-	_exit_critical_bh(&pfree_recv_queue->lock, &irqL);
+	spin_unlock_bh(&pfree_recv_queue->lock);
 
 	return precvframe;
 }
@@ -233,7 +232,6 @@ void rtw_init_recvframe(union recv_frame
 
 int rtw_free_recvframe(union recv_frame *precvframe, _queue *pfree_recv_queue)
 {
-	_irqL irqL;
 	_adapter *padapter=precvframe->u.hdr.adapter;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 
@@ -257,7 +255,7 @@ _func_enter_;
 		precvframe->u.hdr.pkt = NULL;
 	}
 
-	_enter_critical_bh(&pfree_recv_queue->lock, &irqL);
+	spin_lock_bh(&pfree_recv_queue->lock);
 
 	rtw_list_delete(&(precvframe->u.hdr.list));
 
@@ -268,7 +266,7 @@ _func_enter_;
 				precvpriv->free_recvframe_cnt++;
 	}
 
-      _exit_critical_bh(&pfree_recv_queue->lock, &irqL);
+      spin_unlock_bh(&pfree_recv_queue->lock);
 
 _func_exit_;
 
@@ -306,28 +304,15 @@ _func_exit_;
 int rtw_enqueue_recvframe(union recv_frame *precvframe, _queue *queue)
 {
 	int ret;
-	_irqL irqL;
 
-	//_spinlock(&pfree_recv_queue->lock);
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&queue->lock);
 	ret = _rtw_enqueue_recvframe(precvframe, queue);
-	//_rtw_spinunlock(&pfree_recv_queue->lock);
-	_exit_critical_bh(&queue->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
 
 	return ret;
 }
 
 /*
-int	rtw_enqueue_recvframe(union recv_frame *precvframe, _queue *queue)
-{
-	return rtw_free_recvframe(precvframe, queue);
-}
-*/
-
-
-
-
-/*
 caller : defrag ; recvframe_chk_defrag in recv_thread  (passive)
 pframequeue: defrag_queue : will be accessed in recv_thread  (passive)
 
@@ -1558,11 +1543,10 @@ int validate_recv_ctrl_frame(_adapter *p
 
 		if((psta->state&WIFI_SLEEP_STATE) && (pstapriv->sta_dz_bitmap&BIT(psta->aid)))
 		{
-			_irqL irqL;
 			_list	*xmitframe_plist, *xmitframe_phead;
 			struct xmit_frame *pxmitframe=NULL;
 
-			_enter_critical_bh(&psta->sleep_q.lock, &irqL);
+			spin_lock_bh(&psta->sleep_q.lock);
 
 			xmitframe_phead = get_list_head(&psta->sleep_q);
 			xmitframe_plist = get_next(xmitframe_phead);
@@ -1586,12 +1570,12 @@ int validate_recv_ctrl_frame(_adapter *p
 
 	                        //DBG_8192D("handling ps-poll, q_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
 
-				_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+				spin_unlock_bh(&psta->sleep_q.lock);
 				if(rtw_hal_xmit(padapter, pxmitframe) == true)
 				{
 					rtw_os_xmit_complete(padapter, pxmitframe);
 				}
-				_enter_critical_bh(&psta->sleep_q.lock, &irqL);
+				spin_lock_bh(&psta->sleep_q.lock);
 
 				if(psta->sleepq_len==0)
 				{
@@ -1632,7 +1616,7 @@ int validate_recv_ctrl_frame(_adapter *p
 
 			}
 
-			_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+			spin_unlock_bh(&psta->sleep_q.lock);
 
 		}
 
@@ -2549,21 +2533,13 @@ int enqueue_reorder_recvframe(struct rec
 int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *preorder_ctrl, int bforced);
 int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *preorder_ctrl, int bforced)
 {
-	//_irqL irql;
-	//u8 bcancelled;
 	_list	*phead, *plist;
 	union recv_frame *prframe;
 	struct rx_pkt_attrib *pattrib;
-	//u8 index = 0;
 	int bPktInBuf = false;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 	_queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
 
-	//DbgPrint("+recv_indicatepkts_in_order\n");
-
-	//_enter_critical_ex(&ppending_recvframe_queue->lock, &irql);
-	//_rtw_spinlock_ex(&ppending_recvframe_queue->lock);
-
 	phead =		get_list_head(ppending_recvframe_queue);
 	plist = get_next(phead);
 
@@ -2674,7 +2650,6 @@ int recv_indicatepkts_in_order(_adapter
 int recv_indicatepkt_reorder(_adapter *padapter, union recv_frame *prframe);
 int recv_indicatepkt_reorder(_adapter *padapter, union recv_frame *prframe)
 {
-	_irqL irql;
 	int retval = _SUCCESS;
 	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
 	struct recv_reorder_ctrl *preorder_ctrl = prframe->u.hdr.preorder_ctrl;
@@ -2765,7 +2740,7 @@ int recv_indicatepkt_reorder(_adapter *p
 
 	}
 
-	_enter_critical_bh(&ppending_recvframe_queue->lock, &irql);
+	spin_lock_bh(&ppending_recvframe_queue->lock);
 
 	RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
 		 ("recv_indicatepkt_reorder: indicate=%d seq=%d\n",
@@ -2814,11 +2789,11 @@ int recv_indicatepkt_reorder(_adapter *p
 	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, false)==true)
 	{
 		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
-		_exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
+		spin_unlock_bh(&ppending_recvframe_queue->lock);
 	}
 	else
 	{
-		_exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
+		spin_unlock_bh(&ppending_recvframe_queue->lock);
 		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);
 	}
 
@@ -2829,7 +2804,7 @@ _success_exit:
 
 _err_exit:
 
-        _exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
+        spin_unlock_bh(&ppending_recvframe_queue->lock);
 
 	return _FAIL;
 }
@@ -2837,7 +2812,6 @@ _err_exit:
 
 void rtw_reordering_ctrl_timeout_handler(void *pcontext)
 {
-	_irqL irql;
 	struct recv_reorder_ctrl *preorder_ctrl = (struct recv_reorder_ctrl *)pcontext;
 	_adapter *padapter = preorder_ctrl->padapter;
 	_queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
@@ -2850,18 +2824,16 @@ void rtw_reordering_ctrl_timeout_handler
 
 	//DBG_8192D("+rtw_reordering_ctrl_timeout_handler()=>\n");
 
-	_enter_critical_bh(&ppending_recvframe_queue->lock, &irql);
+	spin_lock_bh(&ppending_recvframe_queue->lock);
 
 	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, true)==true)
 	{
 		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
 	}
 
-	_exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
-
+	spin_unlock_bh(&ppending_recvframe_queue->lock);
 }
 
-int process_recv_indicatepkts(_adapter *padapter, union recv_frame *prframe);
 int process_recv_indicatepkts(_adapter *padapter, union recv_frame *prframe)
 {
 	int retval = _SUCCESS;
@@ -3147,7 +3119,6 @@ int recv_func(_adapter *padapter, union
 	if (check_fwstate(mlmepriv, WIFI_STATION_STATE) && psecuritypriv->busetkipkey)
 	{
 		union recv_frame *pending_frame;
-		_irqL irqL;
 
 		while((pending_frame=rtw_alloc_recvframe(&padapter->recvpriv.uc_swdec_pending_queue))) {
 			if (recv_func_posthandle(padapter, pending_frame) == _SUCCESS)
--- a/drivers/staging/rtl8192du/core/rtw_sreset.c
+++ b/drivers/staging/rtl8192du/core/rtw_sreset.c
@@ -50,7 +50,6 @@ u8 sreset_get_wifi_status(_adapter *pada
 
 	u8 status = WIFI_STATUS_SUCCESS;
 	u32 val32 = 0;
-	_irqL irqL;
 	if(psrtpriv->silent_reset_inprogress == true)
         {
 		return status;
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -214,13 +214,12 @@ _func_exit_;
 void rtw_mfree_all_stainfo(struct sta_priv *pstapriv );
 void rtw_mfree_all_stainfo(struct sta_priv *pstapriv )
 {
-	_irqL	 irqL;
 	_list	*plist, *phead;
 	struct sta_info *psta = NULL;
 
 _func_enter_;
 
-	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_lock_bh(&pstapriv->sta_hash_lock);
 
 	phead = get_list_head(&pstapriv->free_sta_queue);
 	plist = get_next(phead);
@@ -233,7 +232,7 @@ _func_enter_;
 		rtw_mfree_stainfo(psta);
 	}
 
-	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
 
 _func_exit_;
 
@@ -264,7 +263,6 @@ void rtw_mfree_sta_priv_lock(struct	sta_
 
 u32	_rtw_free_sta_priv(struct	sta_priv *pstapriv)
 {
-	_irqL	irqL;
 	_list	*phead, *plist;
 	struct sta_info *psta = NULL;
 	struct recv_reorder_ctrl *preorder_ctrl;
@@ -274,7 +272,7 @@ _func_enter_;
 	if(pstapriv){
 
 		/*	delete all reordering_ctrl_timer		*/
-		_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+		spin_lock_bh(&pstapriv->sta_hash_lock);
 		for(index = 0; index < NUM_STA; index++)
 		{
 			phead = &(pstapriv->sta_hash[index]);
@@ -293,7 +291,7 @@ _func_enter_;
 				}
 			}
 		}
-		_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+		spin_unlock_bh(&pstapriv->sta_hash_lock);
 		/*===============================*/
 
 		rtw_mfree_sta_priv_lock(pstapriv);
@@ -311,7 +309,6 @@ _func_exit_;
 //struct	sta_info *rtw_alloc_stainfo(_queue *pfree_sta_queue, unsigned char *hwaddr)
 struct	sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr)
 {
-	_irqL irqL, irqL2;
 	uint tmp_aid;
 	s32	index;
 	_list	*phash_list;
@@ -325,11 +322,11 @@ _func_enter_;
 
 	pfree_sta_queue = &pstapriv->free_sta_queue;
 
-	_enter_critical_bh(&(pfree_sta_queue->lock), &irqL);
+	spin_lock_bh(&(pfree_sta_queue->lock));
 
 	if (_rtw_queue_empty(pfree_sta_queue) == true)
 	{
-		_exit_critical_bh(&(pfree_sta_queue->lock), &irqL);
+		spin_unlock_bh(&(pfree_sta_queue->lock));
 		psta = NULL;
 	}
 	else
@@ -338,7 +335,7 @@ _func_enter_;
 
 		rtw_list_delete(&(psta->list));
 
-		_exit_critical_bh(&(pfree_sta_queue->lock), &irqL);
+		spin_unlock_bh(&(pfree_sta_queue->lock));
 
 		tmp_aid = psta->aid;
 
@@ -357,13 +354,13 @@ _func_enter_;
 		}
 		phash_list = &(pstapriv->sta_hash[index]);
 
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
 
 		rtw_list_insert_tail(&psta->hash_list, phash_list);
 
 		pstapriv->asoc_sta_count ++ ;
 
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 // Commented by Albert 2009/08/13
 // For the SMC router, the sequence number of first packet of WPS handshake will be 0.
@@ -436,7 +433,6 @@ _func_exit_;
 u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
 {
 	int i;
-	_irqL irqL0;
 	_queue *pfree_sta_queue;
 	struct recv_reorder_ctrl *preorder_ctrl;
 	struct	sta_xmit_priv	*pstaxmitpriv;
@@ -454,50 +450,28 @@ _func_enter_;
 
 	pstaxmitpriv = &psta->sta_xmitpriv;
 
-	//rtw_list_delete(&psta->sleep_list);
-
-	//rtw_list_delete(&psta->wakeup_list);
-
-	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
+	spin_lock_bh(&pxmitpriv->lock);
 
 	rtw_free_xmitframe_queue(pxmitpriv, &psta->sleep_q);
 	psta->sleepq_len = 0;
 
-	//_enter_critical_bh(&(pxmitpriv->vo_pending.lock), &irqL0);
-
 	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);
 
 	rtw_list_delete(&(pstaxmitpriv->vo_q.tx_pending));
 
-	//_exit_critical_bh(&(pxmitpriv->vo_pending.lock), &irqL0);
-
-
-	//_enter_critical_bh(&(pxmitpriv->vi_pending.lock), &irqL0);
-
 	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);
 
 	rtw_list_delete(&(pstaxmitpriv->vi_q.tx_pending));
 
-	//_exit_critical_bh(&(pxmitpriv->vi_pending.lock), &irqL0);
-
-
-	//_enter_critical_bh(&(pxmitpriv->bk_pending.lock), &irqL0);
-
 	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);
 
 	rtw_list_delete(&(pstaxmitpriv->bk_q.tx_pending));
 
-	//_exit_critical_bh(&(pxmitpriv->bk_pending.lock), &irqL0);
-
-	//_enter_critical_bh(&(pxmitpriv->be_pending.lock), &irqL0);
-
 	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->be_q.sta_pending);
 
 	rtw_list_delete(&(pstaxmitpriv->be_q.tx_pending));
 
-	//_exit_critical_bh(&(pxmitpriv->be_pending.lock), &irqL0);
-
-	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
+	spin_unlock_bh(&pxmitpriv->lock);
 
 	rtw_list_delete(&psta->hash_list);
 	RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x  \n",pstapriv->asoc_sta_count , psta->hwaddr[0], psta->hwaddr[1], psta->hwaddr[2],psta->hwaddr[3],psta->hwaddr[4],psta->hwaddr[5]));
@@ -522,7 +496,6 @@ _func_enter_;
 	//for A-MPDU Rx reordering buffer control, cancel reordering_ctrl_timer
 	for(i=0; i < 16 ; i++)
 	{
-		_irqL irqL;
 		_list	*phead, *plist;
 		union recv_frame *prframe;
 		_queue *ppending_recvframe_queue;
@@ -535,7 +508,7 @@ _func_enter_;
 
 		ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
 
-		_enter_critical_bh(&ppending_recvframe_queue->lock, &irqL);
+		spin_lock_bh(&ppending_recvframe_queue->lock);
 
 		phead =		get_list_head(ppending_recvframe_queue);
 		plist = get_next(phead);
@@ -551,24 +524,19 @@ _func_enter_;
 			rtw_free_recvframe(prframe, pfree_recv_queue);
 		}
 
-		_exit_critical_bh(&ppending_recvframe_queue->lock, &irqL);
+		spin_unlock_bh(&ppending_recvframe_queue->lock);
 
 	}
 
 
 #ifdef CONFIG_AP_MODE
 
-/*
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL0);
-	rtw_list_delete(&psta->asoc_list);
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL0);
-*/
-	_enter_critical_bh(&pstapriv->auth_list_lock, &irqL0);
+	spin_lock_bh(&pstapriv->auth_list_lock);
 	if (!rtw_is_list_empty(&psta->auth_list)) {
 		rtw_list_delete(&psta->auth_list);
 		pstapriv->auth_list_cnt--;
 	}
-	_exit_critical_bh(&pstapriv->auth_list_lock, &irqL0);
+	spin_unlock_bh(&pstapriv->auth_list_lock);
 
 	psta->expire_to = 0;
 
@@ -602,9 +570,9 @@ _func_enter_;
 
 #endif	// CONFIG_AP_MODE
 
-	_enter_critical_bh(&(pfree_sta_queue->lock), &irqL0);
+	spin_lock_bh(&(pfree_sta_queue->lock));
 	rtw_list_insert_tail(&psta->list, get_list_head(pfree_sta_queue));
-	_exit_critical_bh(&(pfree_sta_queue->lock), &irqL0);
+	spin_unlock_bh(&(pfree_sta_queue->lock));
 
 exit:
 
@@ -617,7 +585,6 @@ _func_exit_;
 // free all stainfo which in sta_hash[all]
 void rtw_free_all_stainfo(_adapter *padapter)
 {
-	_irqL	 irqL;
 	_list	*plist, *phead;
 	s32	index;
 	struct sta_info *psta = NULL;
@@ -629,7 +596,7 @@ _func_enter_;
 	if(pstapriv->asoc_sta_count==1)
 		goto exit;
 
-	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_lock_bh(&pstapriv->sta_hash_lock);
 
 	for(index=0; index< NUM_STA; index++)
 	{
@@ -648,7 +615,7 @@ _func_enter_;
 		}
 	}
 
-	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
 
 exit:
 
@@ -660,8 +627,6 @@ _func_exit_;
 struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
 {
 
-	_irqL	 irqL;
-
 	_list	*plist, *phead;
 
 	struct sta_info *psta = NULL;
@@ -678,17 +643,13 @@ _func_enter_;
 		return NULL;
 
 	if(IS_MCAST(hwaddr))
-	{
 		addr = bc_addr;
-	}
 	else
-	{
 		addr = hwaddr;
-	}
 
 	index = wifi_mac_hash(addr);
 
-	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_lock_bh(&pstapriv->sta_hash_lock);
 
 	phead = &(pstapriv->sta_hash[index]);
 	plist = get_next(phead);
@@ -707,7 +668,7 @@ _func_enter_;
 		plist = get_next(plist);
 	}
 
-	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
 _func_exit_;
 	return psta;
 
@@ -739,15 +700,6 @@ _func_enter_;
 
 	ptxservq= &(psta->sta_xmitpriv.be_q);
 
-/*
-	_enter_critical(&pstapending->lock, &irqL0);
-
-	if (rtw_is_list_empty(&ptxservq->tx_pending))
-		rtw_list_insert_tail(&ptxservq->tx_pending, get_list_head(pstapending));
-
-	_exit_critical(&pstapending->lock, &irqL0);
-*/
-
 exit:
 _func_exit_;
 	return _SUCCESS;
@@ -771,7 +723,6 @@ u8 rtw_access_ctrl(_adapter *padapter, u
 {
 	u8 res = true;
 #ifdef  CONFIG_AP_MODE
-	_irqL irqL;
 	_list	*plist, *phead;
 	struct rtw_wlan_acl_node *paclnode;
 	u8 match = false;
@@ -779,7 +730,7 @@ u8 rtw_access_ctrl(_adapter *padapter, u
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
 	_queue	*pacl_node_q =&pacl_list->acl_node_q;
 
-	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_lock_bh(&(pacl_node_q->lock));
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
 	while ((rtw_end_of_queue_search(phead, plist)) == false)
@@ -796,7 +747,7 @@ u8 rtw_access_ctrl(_adapter *padapter, u
 			}
 		}
 	}
-	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
+	spin_unlock_bh(&(pacl_node_q->lock));
 
 
 	if(pacl_list->mode == 1)//accept unless in deny list
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ b/drivers/staging/rtl8192du/core/rtw_tdls.c
@@ -248,13 +248,12 @@ void free_tdls_sta(_adapter *padapter, s
 {
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	struct sta_priv *pstapriv = &padapter->stapriv;
-	_irqL irqL;
 
 	//free peer sta_info
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
 	if(ptdlsinfo->sta_cnt != 0)
 		ptdlsinfo->sta_cnt--;
-	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
 	if( ptdlsinfo->sta_cnt < (NUM_STA - 2) )	// -2: AP + BC/MC sta
 	{
 		ptdlsinfo->sta_maximum = false;
@@ -546,7 +545,6 @@ void issue_tdls_setup_req(_adapter *pada
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct sta_info *ptdls_sta= NULL;
-	_irqL irqL;
 	static u8 dialogtoken = 0;
 	u32 timeout_interval= TPK_RESEND_COUNT * 1000;	//retry timer should set at least 301 sec, using TPK_count counting 301 times.
 
@@ -580,10 +578,10 @@ void issue_tdls_setup_req(_adapter *pada
 		ptdls_sta = rtw_alloc_stainfo(pstapriv, mac_addr);
 		if(ptdls_sta)
 		{
-			_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+			spin_lock_bh(&(pstapriv->sta_hash_lock));
 			if(!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 				ptdlsinfo->sta_cnt++;
-			_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+			spin_unlock_bh(&(pstapriv->sta_hash_lock));
 			if( ptdlsinfo->sta_cnt == (NUM_STA - 2) )	// -2: AP + BC/MC sta
 			{
 				ptdlsinfo->sta_maximum  = true;
@@ -627,7 +625,6 @@ void issue_tdls_teardown(_adapter *padap
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct sta_info	*ptdls_sta=NULL;
-	_irqL irqL;
 
 	ptdls_sta = rtw_get_stainfo(pstapriv, mac_addr);
 	if(ptdls_sta==NULL){
@@ -670,9 +667,9 @@ void issue_tdls_teardown(_adapter *padap
 
 	if( ptdls_sta->timer_flag == 1 )
 	{
-		_enter_critical_bh(&(padapter->tdlsinfo.hdl_lock), &irqL);
+		spin_lock_bh(&(padapter->tdlsinfo.hdl_lock));
 		ptdls_sta->timer_flag = 2;
-		_exit_critical_bh(&(padapter->tdlsinfo.hdl_lock), &irqL);
+		spin_unlock_bh(&(padapter->tdlsinfo.hdl_lock));
 	}
 	else
 		rtw_tdls_cmd(padapter, mac_addr, TDLS_FREE_STA );
@@ -736,7 +733,6 @@ void issue_tdls_setup_rsp(_adapter *pada
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct rx_pkt_attrib	*rx_pkt_pattrib = &precv_frame->u.hdr.attrib;
-	_irqL irqL;
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
@@ -778,7 +774,6 @@ void issue_tdls_setup_cfm(_adapter *pada
 	struct pkt_attrib			*pattrib;
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct sta_info		*ptdls_sta=NULL;
-	_irqL irqL;
 
 	struct rx_pkt_attrib	*rx_pkt_pattrib = & precv_frame->u.hdr.attrib;
 
@@ -967,7 +962,6 @@ void issue_tdls_ch_switch_rsp(_adapter *
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 
-        _irqL irqL;
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
@@ -990,13 +984,6 @@ void issue_tdls_ch_switch_rsp(_adapter *
 	update_tdls_attrib(padapter, pattrib);
 
 	pattrib->qsel=pattrib->priority;
-/*
-	_enter_critical_bh(&pxmitpriv->lock, &irqL);
-	if(xmitframe_enqueue_for_tdls_sleeping_sta(padapter, pmgntframe)==true){
-		_exit_critical_bh(&pxmitpriv->lock, &irqL);
-		return false;
-	}
-*/
 	if(rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_RESPONSE) !=_SUCCESS ){
 		rtw_free_xmitbuf(pxmitpriv,pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
@@ -1094,7 +1081,6 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 	struct security_priv *psecuritypriv = &adapter->securitypriv;
-	_irqL irqL;
 	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->u.hdr.attrib;
 	u8 *prsnie, *ppairwise_cipher;
 	u8 i, k, pairwise_count;
@@ -1269,10 +1255,10 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 			_rtw_memcpy(ptdls_sta->SNonce, SNonce, 32);
 			_rtw_memcpy(&(ptdls_sta->TDLS_PeerKey_Lifetime), timeout_interval, 4);
 		}
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
 		if(!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 			ptdlsinfo->sta_cnt++;
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 		if( ptdlsinfo->sta_cnt == (NUM_STA - 2) )	// -2: AP + BC/MC sta
 		{
 			ptdlsinfo->sta_maximum = true;
@@ -1310,7 +1296,6 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 	struct sta_info *ptdls_sta= NULL;
 	struct sta_priv *pstapriv = &adapter->stapriv;
 	u8 *ptr = precv_frame->u.hdr.rx_data;
-	_irqL irqL;
 	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->u.hdr.attrib;
 	u8 *psa;
 	u16 stat_code;
@@ -1485,7 +1470,6 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 	struct sta_info *ptdls_sta= NULL;
 	struct sta_priv *pstapriv = &adapter->stapriv;
 	u8 *ptr = precv_frame->u.hdr.rx_data;
-	_irqL irqL;
 	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->u.hdr.attrib;
 	u8 *psa;
 	u16 stat_code;
@@ -1643,7 +1627,6 @@ int On_TDLS_Teardown(_adapter *adapter,
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct sta_priv		*pstapriv = &adapter->stapriv;
 	struct sta_info *ptdls_sta= NULL;
-	_irqL irqL;
 
 	psa = get_sa(ptr);
 
@@ -1706,11 +1689,10 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 	if(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE){
 		if(wmmps_ac && state)
 		{
-			_irqL irqL;
 			_list	*xmitframe_plist, *xmitframe_phead;
 			struct xmit_frame *pxmitframe=NULL;
 
-			_enter_critical_bh(&ptdls_sta->sleep_q.lock, &irqL);
+			spin_lock_bh(&ptdls_sta->sleep_q.lock);
 
 			xmitframe_phead = get_list_head(&ptdls_sta->sleep_q);
 			xmitframe_plist = get_next(xmitframe_phead);
@@ -1759,7 +1741,7 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 				ptdls_sta->sleepq_len=0;
 			}
 
-			_exit_critical_bh(&ptdls_sta->sleep_q.lock, &irqL);
+			spin_unlock_bh(&ptdls_sta->sleep_q.lock);
 
 		}
 
@@ -2785,14 +2767,13 @@ void init_handshake_timer(_adapter *pada
 //Check tdls peer sta alive.
 void _tdls_alive_timer_phase1_hdl(void *FunctionContext)
 {
-	_irqL irqL;
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
 	_adapter *padapter = ptdls_sta->padapter;
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 
-	_enter_critical_bh(&ptdlsinfo->hdl_lock, &irqL);
+	spin_lock_bh(&ptdlsinfo->hdl_lock);
 	ptdls_sta->timer_flag = 1;
-	_exit_critical_bh(&ptdlsinfo->hdl_lock, &irqL);
+	spin_unlock_bh(&ptdlsinfo->hdl_lock);
 
 	ptdls_sta->tdls_sta_state &= (~TDLS_ALIVE_STATE);
 
@@ -2805,23 +2786,22 @@ void _tdls_alive_timer_phase1_hdl(void *
 		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_FREE_STA);
 	else
 	{
-		_enter_critical_bh(&ptdlsinfo->hdl_lock, &irqL);
+		spin_lock_bh(&ptdlsinfo->hdl_lock);
 		ptdls_sta->timer_flag = 0;
-		_exit_critical_bh(&ptdlsinfo->hdl_lock, &irqL);
+		spin_unlock_bh(&ptdlsinfo->hdl_lock);
 	}
 
 }
 
 void _tdls_alive_timer_phase2_hdl(void *FunctionContext)
 {
-	_irqL irqL;
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
 	_adapter *padapter = ptdls_sta->padapter;
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 
-	_enter_critical_bh(&(ptdlsinfo->hdl_lock), &irqL);
+	spin_lock_bh(&(ptdlsinfo->hdl_lock));
 	ptdls_sta->timer_flag = 1;
-	_exit_critical_bh(&ptdlsinfo->hdl_lock, &irqL);
+	spin_unlock_bh(&ptdlsinfo->hdl_lock);
 
 	if( (ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE) &&
 		(sta_last_rx_pkts(ptdls_sta) + 3 <= sta_rx_pkts(ptdls_sta)) )
@@ -2856,9 +2836,9 @@ void _tdls_alive_timer_phase2_hdl(void *
 		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_FREE_STA);
 	else
 	{
-		_enter_critical_bh(&(ptdlsinfo->hdl_lock), &irqL);
+		spin_lock_bh(&(ptdlsinfo->hdl_lock));
 		ptdls_sta->timer_flag = 0;
-		_exit_critical_bh(&ptdlsinfo->hdl_lock, &irqL);
+		spin_unlock_bh(&ptdlsinfo->hdl_lock);
 }
 
 }
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -2040,7 +2040,6 @@ struct xmit_frame *rtw_alloc_xmitframe(s
 		pfree_xmit_queue
 	*/
 
-	_irqL irqL;
 	struct xmit_frame *pxframe = NULL;
 	_list *plist, *phead;
 	_queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
@@ -2048,7 +2047,7 @@ struct xmit_frame *rtw_alloc_xmitframe(s
 
 _func_enter_;
 
-	_enter_critical_bh(&pfree_xmit_queue->lock, &irqL);
+	spin_lock_bh(&pfree_xmit_queue->lock);
 
 	if (_rtw_queue_empty(pfree_xmit_queue) == true) {
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_alloc_xmitframe:%d\n", pxmitpriv->free_xmitframe_cnt));
@@ -2098,7 +2097,7 @@ _func_enter_;
 
 	}
 
-	_exit_critical_bh(&pfree_xmit_queue->lock, &irqL);
+	spin_unlock_bh(&pfree_xmit_queue->lock);
 
 _func_exit_;
 
@@ -2107,7 +2106,6 @@ _func_exit_;
 
 s32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe)
 {
-	_irqL irqL;
 	_queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
 	_adapter *padapter = pxmitpriv->adapter;
 	_pkt *pndis_pkt = NULL;
@@ -2119,7 +2117,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	_enter_critical_bh(&pfree_xmit_queue->lock, &irqL);
+	spin_lock_bh(&pfree_xmit_queue->lock);
 
 	rtw_list_delete(&pxmitframe->list);
 
@@ -2133,7 +2131,7 @@ _func_enter_;
 	pxmitpriv->free_xmitframe_cnt++;
 	RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("rtw_free_xmitframe():free_xmitframe_cnt=%d\n", pxmitpriv->free_xmitframe_cnt));
 
-	_exit_critical_bh(&pfree_xmit_queue->lock, &irqL);
+	spin_unlock_bh(&pfree_xmit_queue->lock);
 
 
 	if(pndis_pkt)
@@ -2148,13 +2146,12 @@ _func_exit_;
 
 void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, _queue *pframequeue)
 {
-	_irqL irqL;
 	_list	*plist, *phead;
 	struct	xmit_frame	*pxmitframe;
 
 _func_enter_;
 
-	_enter_critical_bh(&(pframequeue->lock), &irqL);
+	spin_lock_bh(&(pframequeue->lock));
 
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
@@ -2169,7 +2166,7 @@ _func_enter_;
 		rtw_free_xmitframe(pxmitpriv,pxmitframe);
 
 	}
-	_exit_critical_bh(&(pframequeue->lock), &irqL);
+	spin_unlock_bh(&(pframequeue->lock));
 
 _func_exit_;
 }
@@ -2216,7 +2213,6 @@ static struct xmit_frame *dequeue_one_xm
 
 struct xmit_frame* rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i, int entry)
 {
-	_irqL irqL0;
 	_list *sta_plist, *sta_phead;
 	struct hw_xmit *phwxmit;
 	struct tx_servq *ptxservq = NULL;
@@ -2257,14 +2253,12 @@ _func_enter_;
 		}
 	}
 
-	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
+	spin_lock_bh(&pxmitpriv->lock);
 
 	for(i = 0; i < entry; i++)
 	{
 		phwxmit = phwxmit_i + inx[i];
 
-		//_enter_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
-
 		sta_phead = get_list_head(phwxmit->sta_queue);
 		sta_plist = get_next(sta_phead);
 
@@ -2285,8 +2279,6 @@ _func_enter_;
 				if(_rtw_queue_empty(pframe_queue)) //must be done after get_next and before break
 					rtw_list_delete(&ptxservq->tx_pending);
 
-				//_exit_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
-
 				goto exit;
 			}
 
@@ -2294,13 +2286,11 @@ _func_enter_;
 
 		}
 
-		//_exit_critical_ex(&phwxmit->sta_queue->lock, &irqL0);
-
 	}
 
 exit:
 
-	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
+	spin_unlock_bh(&pxmitpriv->lock);
 
 _func_exit_;
 
@@ -2350,7 +2340,6 @@ _func_exit_;
  */
 s32 rtw_xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe)
 {
-	//_irqL irqL0;
 	u8	ac_index;
 	struct sta_info	*psta;
 	struct tx_servq	*ptxservq;
@@ -2375,22 +2364,14 @@ _func_enter_;
 
 	ptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));
 
-	//_enter_critical(&pstapending->lock, &irqL0);
-
 	if (rtw_is_list_empty(&ptxservq->tx_pending)) {
 		rtw_list_insert_tail(&ptxservq->tx_pending, get_list_head(phwxmits[ac_index].sta_queue));
 	}
 
-	//_enter_critical(&ptxservq->sta_pending.lock, &irqL1);
-
 	rtw_list_insert_tail(&pxmitframe->list, get_list_head(&ptxservq->sta_pending));
 	ptxservq->qcnt++;
 	phwxmits[ac_index].accnt++;
 
-	//_exit_critical(&ptxservq->sta_pending.lock, &irqL1);
-
-	//_exit_critical(&pstapending->lock, &irqL0);
-
 exit:
 
 _func_exit_;
@@ -2489,8 +2470,6 @@ int rtw_br_client_tx(_adapter *padapter,
 {
 	struct sk_buff *skb = *pskb;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
-	_irqL irqL;
-	//if(check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true)
 	{
 		void dhcp_flag_bcast(_adapter *priv, struct sk_buff *skb);
 		int res, is_vlan_tag=0, i, do_nat25=1;
@@ -2506,7 +2485,7 @@ int rtw_br_client_tx(_adapter *padapter,
 		br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
 		rcu_read_unlock();
 #endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-		_enter_critical_bh(&padapter->br_ext_lock, &irqL);
+		spin_lock_bh(&padapter->br_ext_lock);
 		if (	!(skb->data[0] & 1) &&
 				br_port &&
 				memcmp(skb->data+MACADDRLEN, padapter->br_mac, MACADDRLEN) &&
@@ -2515,7 +2494,7 @@ int rtw_br_client_tx(_adapter *padapter,
 				!memcmp(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN) && padapter->scdb_entry) {
 			memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
 			padapter->scdb_entry->ageing_timer = jiffies;
-			_exit_critical_bh(&padapter->br_ext_lock, &irqL);
+			spin_unlock_bh(&padapter->br_ext_lock);
 		}
 		else
 		//if (!priv->pmib->ethBrExtInfo.nat25_disable)
@@ -2558,7 +2537,7 @@ int rtw_br_client_tx(_adapter *padapter,
 					}
 				}
 			}
-			_exit_critical_bh(&padapter->br_ext_lock, &irqL);
+			spin_unlock_bh(&padapter->br_ext_lock);
 #endif // 1
 			if (do_nat25)
 			{
@@ -2693,7 +2672,6 @@ static void do_queue_select(_adapter	*pa
 s32 rtw_xmit(_adapter *padapter, _pkt **ppkt)
 {
 #ifdef CONFIG_AP_MODE
-	_irqL irqL0;
 #endif
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	struct xmit_frame *pxmitframe = NULL;
@@ -2751,13 +2729,13 @@ s32 rtw_xmit(_adapter *padapter, _pkt **
 	do_queue_select(padapter, &pxmitframe->attrib);
 
 #if defined(CONFIG_AP_MODE) || defined(CONFIG_TDLS)
-	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
+	spin_lock_bh(&pxmitpriv->lock);
 	if(xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == true)
 	{
-		_exit_critical_bh(&pxmitpriv->lock, &irqL0);
+		spin_unlock_bh(&pxmitpriv->lock);
 		return 1;
 	}
-	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
+	spin_unlock_bh(&pxmitpriv->lock);
 #endif
 
 	if (rtw_hal_xmit(padapter, pxmitframe) == false)
@@ -2771,7 +2749,6 @@ int xmitframe_enqueue_for_tdls_sleeping_
 {
 	int ret=false;
 
-	_irqL irqL;
 	struct sta_info *ptdls_sta=NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
@@ -2789,14 +2766,12 @@ int xmitframe_enqueue_for_tdls_sleeping_
 			return ret;
 			}
 
-		_enter_critical_bh(&ptdls_sta->sleep_q.lock, &irqL);
+		spin_lock_bh(&ptdls_sta->sleep_q.lock);
 
 		if(ptdls_sta->state&WIFI_SLEEP_STATE)
 		{
 			rtw_list_delete(&pxmitframe->list);
 
-			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);
-
 			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&ptdls_sta->sleep_q));
 
 			ptdls_sta->sleepq_len++;
@@ -2833,7 +2808,7 @@ int xmitframe_enqueue_for_tdls_sleeping_
 
 		}
 
-		_exit_critical_bh(&ptdls_sta->sleep_q.lock, &irqL);
+		spin_unlock_bh(&ptdls_sta->sleep_q.lock);
 	}
 
 	return ret;
@@ -2845,7 +2820,6 @@ int xmitframe_enqueue_for_tdls_sleeping_
 
 int xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe)
 {
-	_irqL irqL;
 	int ret=false;
 	struct sta_info *psta=NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
@@ -2893,16 +2867,12 @@ int xmitframe_enqueue_for_sleeping_sta(_
 
 	if(bmcst)
 	{
-		_enter_critical_bh(&psta->sleep_q.lock, &irqL);
+		spin_lock_bh(&psta->sleep_q.lock);
 
 		if(pstapriv->sta_dz_bitmap)//if anyone sta is in ps mode
 		{
-			//pattrib->qsel = 0x11;//HIQ
-
 			rtw_list_delete(&pxmitframe->list);
 
-			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);
-
 			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
 
 			psta->sleepq_len++;
@@ -2910,24 +2880,20 @@ int xmitframe_enqueue_for_sleeping_sta(_
 			pstapriv->tim_bitmap |= BIT(0);//
 			pstapriv->sta_dz_bitmap |= BIT(0);
 
-			//DBG_8192D("enqueue, sq_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
-
 			update_beacon(padapter, _TIM_IE_, NULL, false);//tx bc/mc packets after upate bcn
 
-			//_exit_critical_bh(&psta->sleep_q.lock, &irqL);
-
 			ret = true;
 
 		}
 
-		_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+		spin_unlock_bh(&psta->sleep_q.lock);
 
 		return ret;
 
 	}
 
 
-	_enter_critical_bh(&psta->sleep_q.lock, &irqL);
+	spin_lock_bh(&psta->sleep_q.lock);
 
 	if(psta->state&WIFI_SLEEP_STATE)
 	{
@@ -2937,8 +2903,6 @@ int xmitframe_enqueue_for_sleeping_sta(_
 		{
 			rtw_list_delete(&pxmitframe->list);
 
-			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);
-
 			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
 
 			psta->sleepq_len++;
@@ -2971,33 +2935,19 @@ int xmitframe_enqueue_for_sleeping_sta(_
 			{
 				pstapriv->tim_bitmap |= BIT(psta->aid);
 
-				//DBG_8192D("enqueue, sq_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
-
 				if(psta->sleepq_len==1)
 				{
-					//DBG_8192D("sleepq_len==1, update BCNTIM\n");
-					//upate BCN for TIM IE
 					update_beacon(padapter, _TIM_IE_, NULL, false);
 				}
 			}
 
-			//_exit_critical_bh(&psta->sleep_q.lock, &irqL);
-
-			//if(psta->sleepq_len > (NR_XMITFRAME>>3))
-			//{
-			//	wakeup_sta_to_xmit(padapter, psta);
-			//}
-
 			ret = true;
-
 		}
-
 	}
 
-	_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+	spin_unlock_bh(&psta->sleep_q.lock);
 
 	return ret;
-
 }
 
 static void dequeue_xmitframes_to_sleeping_queue(_adapter *padapter, struct sta_info *psta, _queue *pframequeue)
@@ -3032,7 +2982,6 @@ static void dequeue_xmitframes_to_sleepi
 
 void stop_sta_xmit(_adapter *padapter, struct sta_info *psta)
 {
-	_irqL irqL0;
 	struct sta_info *psta_bmc;
 	struct sta_xmit_priv *pstaxmitpriv;
 	struct sta_priv *pstapriv = &padapter->stapriv;
@@ -3044,7 +2993,7 @@ void stop_sta_xmit(_adapter *padapter, s
 	psta_bmc = rtw_get_bcmc_stainfo(padapter);
 
 
-	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
+	spin_lock_bh(&pxmitpriv->lock);
 
 	psta->state |= WIFI_SLEEP_STATE;
 
@@ -3088,21 +3037,18 @@ void stop_sta_xmit(_adapter *padapter, s
 		}
 	}
 #endif //CONFIG_TDLS
-	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
-
-
+	spin_unlock_bh(&pxmitpriv->lock);
 }
 
 void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 {
-	_irqL irqL;
 	u8 update_mask=0, wmmps_ac=0;
 	struct sta_info *psta_bmc;
 	_list	*xmitframe_plist, *xmitframe_phead;
 	struct xmit_frame *pxmitframe=NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
-	_enter_critical_bh(&psta->sleep_q.lock, &irqL);
+	spin_lock_bh(&psta->sleep_q.lock);
 
 	xmitframe_phead = get_list_head(&psta->sleep_q);
 	xmitframe_plist = get_next(xmitframe_phead);
@@ -3159,12 +3105,10 @@ void wakeup_sta_to_xmit(_adapter *padapt
 
 		pxmitframe->attrib.triggered = 1;
 
-		_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+		spin_unlock_bh(&psta->sleep_q.lock);
 		if(rtw_hal_xmit(padapter, pxmitframe) == true)
-		{
 			rtw_os_xmit_complete(padapter, pxmitframe);
-		}
-		_enter_critical_bh(&psta->sleep_q.lock, &irqL);
+		spin_lock_bh(&psta->sleep_q.lock);
 
 	}
 
@@ -3176,15 +3120,12 @@ void wakeup_sta_to_xmit(_adapter *padapt
 			if(psta->state&WIFI_SLEEP_STATE)
 				psta->state ^= WIFI_SLEEP_STATE;
 
-			_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+			spin_unlock_bh(&psta->sleep_q.lock);
 			return;
 		}
 #endif //CONFIG_TDLS
 		pstapriv->tim_bitmap &= ~BIT(psta->aid);
 
-		//DBG_8192D("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap);
-		//upate BCN for TIM IE
-		//update_BCNTIM(padapter);
 		update_mask = BIT(0);
 
 		if(psta->state&WIFI_SLEEP_STATE)
@@ -3199,7 +3140,7 @@ void wakeup_sta_to_xmit(_adapter *padapt
 		pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);
 	}
 
-	_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+	spin_unlock_bh(&psta->sleep_q.lock);
 
 
 	//for BC/MC Frames
@@ -3209,7 +3150,7 @@ void wakeup_sta_to_xmit(_adapter *padapt
 
 	if((pstapriv->sta_dz_bitmap&0xfffe) == 0x0)//no any sta in ps mode
 	{
-		_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+		spin_lock_bh(&psta_bmc->sleep_q.lock);
 
 		xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
 		xmitframe_plist = get_next(xmitframe_phead);
@@ -3231,12 +3172,12 @@ void wakeup_sta_to_xmit(_adapter *padapt
 
 			pxmitframe->attrib.triggered = 1;
 
-			_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+			spin_unlock_bh(&psta_bmc->sleep_q.lock);
 			if(rtw_hal_xmit(padapter, pxmitframe) == true)
 			{
 				rtw_os_xmit_complete(padapter, pxmitframe);
 			}
-			_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+			spin_lock_bh(&psta_bmc->sleep_q.lock);
 
 
 		}
@@ -3252,7 +3193,7 @@ void wakeup_sta_to_xmit(_adapter *padapt
 			update_mask |= BIT(1);
 		}
 
-		_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+		spin_unlock_bh(&psta_bmc->sleep_q.lock);
 
 	}
 
@@ -3267,13 +3208,12 @@ void wakeup_sta_to_xmit(_adapter *padapt
 
 void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta)
 {
-	_irqL irqL;
 	u8 wmmps_ac=0;
 	_list	*xmitframe_plist, *xmitframe_phead;
 	struct xmit_frame *pxmitframe=NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
-	_enter_critical_bh(&psta->sleep_q.lock, &irqL);
+	spin_lock_bh(&psta->sleep_q.lock);
 
 	xmitframe_phead = get_list_head(&psta->sleep_q);
 	xmitframe_plist = get_next(xmitframe_phead);
@@ -3336,7 +3276,7 @@ void xmit_delivery_enabled_frames(_adapt
 #ifdef CONFIG_TDLS
 			if(psta->tdls_sta_state & TDLS_LINKED_STATE )
 			{
-				_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+				spin_unlock_bh(&psta->sleep_q.lock);
 				return;
 			}
 #endif //CONFIG_TDLS
@@ -3351,8 +3291,7 @@ void xmit_delivery_enabled_frames(_adapt
 
 	}
 
-	_exit_critical_bh(&psta->sleep_q.lock, &irqL);
-
+	spin_unlock_bh(&psta->sleep_q.lock);
 }
 
 #endif
--- a/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192d_dm.c
@@ -1347,13 +1347,12 @@ static void PWDB_Monitor(
 
 	if(check_fwstate(&Adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
 	{
-		_irqL irqL;
 		_list	*plist, *phead;
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &Adapter->stapriv;
 		u8 bcast_addr[ETH_ALEN]= {0xff,0xff,0xff,0xff,0xff,0xff};
 
-		_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+		spin_lock_bh(&pstapriv->sta_hash_lock);
 
 		for(i=0; i< NUM_STA; i++)
 		{
@@ -1384,7 +1383,7 @@ static void PWDB_Monitor(
 			}
 		}
 
-		_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+		spin_unlock_bh(&pstapriv->sta_hash_lock);
 
 		if(pHalData->fw_ractrl == true)
 		{
--- a/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
+++ b/drivers/staging/rtl8192du/hal/rtl8192du_xmit.c
@@ -615,7 +615,6 @@ static u32 xmitframe_need_length(struct
 void UpdateEarlyModeInfo8192D(_adapter *padapter, struct xmit_frame *pxmitframe,struct tx_servq	*ptxservq);
 void UpdateEarlyModeInfo8192D(_adapter *padapter, struct xmit_frame *pxmitframe,struct tx_servq	*ptxservq)
 {
-	_irqL irqL;
 	u32	len;
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
@@ -628,7 +627,7 @@ void UpdateEarlyModeInfo8192D(_adapter *
 	pxmitframe->EMPktNum = 0;
 
 	// dequeue same priority packet from station tx queue
-	_enter_critical_bh(&pxmitpriv->lock, &irqL);
+	spin_lock_bh(&pxmitpriv->lock);
 
 	xmitframe_phead = get_list_head(&ptxservq->sta_pending);
 	xmitframe_plist = get_next(xmitframe_phead);
@@ -641,7 +640,7 @@ void UpdateEarlyModeInfo8192D(_adapter *
 		pxmitframe->EMPktLen[pxmitframe->EMPktNum] = len;
 		pxmitframe->EMPktNum++;
 	}
-	_exit_critical_bh(&pxmitpriv->lock, &irqL);
+	spin_unlock_bh(&pxmitpriv->lock);
 
 }
 
@@ -656,7 +655,6 @@ s32 rtl8192du_xmitframe_complete(_adapte
 	struct hw_xmit	*phwxmit = pxmitpriv->hwxmits;
 	struct tx_servq	*ptxservq = NULL;
 
-	_irqL irqL;
 	_list *xmitframe_plist = NULL, *xmitframe_phead = NULL;
 
 	u32	pbuf=0; // next pkt address
@@ -709,15 +707,15 @@ s32 rtl8192du_xmitframe_complete(_adapte
 			pxmitframe->pkt_offset = USB_92D_DUMMY_OFFSET; // first frame of aggregation, reserve 2 offset for 512 alignment and early mode
 
 			pfirstframe = pxmitframe;
-			_enter_critical_bh(&pxmitpriv->lock, &irqL);
+			spin_lock_bh(&pxmitpriv->lock);
 			ptxservq = rtw_get_sta_pending(padapter, pfirstframe->attrib.psta, pfirstframe->attrib.priority, (u8 *)(&ac_index));
-			_exit_critical_bh(&pxmitpriv->lock, &irqL);
+			spin_unlock_bh(&pxmitpriv->lock);
 		}
 		//3 2. aggregate same priority and same DA(AP or STA) frames
 		else
 		{
 			// dequeue same priority packet from station tx queue
-			_enter_critical_bh(&pxmitpriv->lock, &irqL);
+			spin_lock_bh(&pxmitpriv->lock);
 
 			if (_rtw_queue_empty(&ptxservq->sta_pending) == false)
 			{
@@ -748,7 +746,7 @@ s32 rtl8192du_xmitframe_complete(_adapte
 				bulkstart = true;
 			}
 
-			_exit_critical_bh(&pxmitpriv->lock, &irqL);
+			spin_unlock_bh(&pxmitpriv->lock);
 
 			if(bulkstart)
 			{
@@ -952,14 +950,13 @@ static s32 xmitframe_direct(_adapter *pa
  */
 static s32 pre_xmitframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 {
-	_irqL irqL;
 	s32 res;
 	struct xmit_buf *pxmitbuf = NULL;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-	_enter_critical_bh(&pxmitpriv->lock, &irqL);
+	spin_lock_bh(&pxmitpriv->lock);
 
 	if (rtw_txframes_sta_ac_pending(padapter, pattrib) > 0
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -982,7 +979,7 @@ static s32 pre_xmitframe(_adapter *padap
 	if (pxmitbuf == NULL)
 		goto enqueue;
 
-	_exit_critical_bh(&pxmitpriv->lock, &irqL);
+	spin_unlock_bh(&pxmitpriv->lock);
 
 	pxmitframe->pxmitbuf = pxmitbuf;
 	pxmitframe->buf_addr = pxmitbuf->pbuf;
@@ -997,7 +994,7 @@ static s32 pre_xmitframe(_adapter *padap
 
 enqueue:
 	res = rtw_xmitframe_enqueue(padapter, pxmitframe);
-	_exit_critical_bh(&pxmitpriv->lock, &irqL);
+	spin_unlock_bh(&pxmitpriv->lock);
 
 	if (res != _SUCCESS) {
 		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("pre_xmitframe: enqueue xmitframe fail\n"));
--- a/drivers/staging/rtl8192du/hal/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/hal/usb_ops_linux.c
@@ -1161,7 +1161,6 @@ void rtl8192du_recv_tasklet(void *priv)
 
 static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
 {
-	_irqL irqL;
 	uint isevt, *pbuf;
 	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;
 	_adapter			*padapter =(_adapter *)precvbuf->adapter;
@@ -1169,19 +1168,8 @@ static void usb_read_port_complete(struc
 
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
 
-	//_enter_critical(&precvpriv->lock, &irqL);
-	//precvbuf->irp_pending=false;
-	//precvpriv->rx_pending_cnt --;
-	//_exit_critical(&precvpriv->lock, &irqL);
-
 	precvpriv->rx_pending_cnt --;
 
-	//if(precvpriv->rx_pending_cnt== 0)
-	//{
-	//	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: rx_pending_cnt== 0, set allrxreturnevt!\n"));
-	//	_rtw_up_sema(&precvpriv->allrxreturnevt);
-	//}
-
 	if(padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));
@@ -1260,7 +1248,6 @@ _func_exit_;
 
 static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 {
-	_irqL irqL;
 	int err, pipe;
 	SIZE_PTR tmpaddr=0;
 	SIZE_PTR alignment=0;
@@ -1331,11 +1318,6 @@ _func_enter_;
 			precvbuf->reuse = false;
 		}
 
-		//_enter_critical(&precvpriv->lock, &irqL);
-		//precvpriv->rx_pending_cnt++;
-		//precvbuf->irp_pending = true;
-		//_exit_critical(&precvpriv->lock, &irqL);
-
 		precvpriv->rx_pending_cnt++;
 
 		purb = precvbuf->purb;
--- a/drivers/staging/rtl8192du/include/osdep_service.h
+++ b/drivers/staging/rtl8192du/include/osdep_service.h
@@ -187,16 +187,6 @@ static inline void _exit_critical_ex(_lo
 	spin_unlock_irqrestore(plock, *pirqL);
 }
 
-static inline void _enter_critical_bh(_lock *plock, _irqL *pirqL)
-{
-	spin_lock_bh(plock);
-}
-
-static inline void _exit_critical_bh(_lock *plock, _irqL *pirqL)
-{
-	spin_unlock_bh(plock);
-}
-
 static inline void _enter_critical_mutex(_mutex *pmutex)
 {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
--- a/drivers/staging/rtl8192du/include/rtw_mlme.h
+++ b/drivers/staging/rtl8192du/include/rtw_mlme.h
@@ -633,30 +633,24 @@ __inline static void _clr_fwstate_(struc
  */
 __inline static void clr_fwstate(struct mlme_priv *pmlmepriv, int state)
 {
-	_irqL irqL;
-
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	if (check_fwstate(pmlmepriv, state) == true)
 		pmlmepriv->fw_state ^= state;
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 }
 
 __inline static void clr_fwstate_ex(struct mlme_priv *pmlmepriv, int state)
 {
-	_irqL irqL;
-
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	_clr_fwstate_(pmlmepriv, state);
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 }
 
 __inline static void up_scanned_network(struct mlme_priv *pmlmepriv)
 {
-	_irqL irqL;
-
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	pmlmepriv->num_of_scanned++;
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 }
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -666,20 +660,16 @@ int check_buddy_fwstate(_adapter *padapt
 
 __inline static void down_scanned_network(struct mlme_priv *pmlmepriv)
 {
-	_irqL irqL;
-
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	pmlmepriv->num_of_scanned--;
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 }
 
 __inline static void set_scanned_network_val(struct mlme_priv *pmlmepriv, int val)
 {
-	_irqL irqL;
-
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	pmlmepriv->num_of_scanned = val;
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 }
 
 extern u16 rtw_get_capability(WLAN_BSSID_EX *bss);
--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -1482,7 +1482,6 @@ static int cfg80211_rtw_change_iface(str
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct wireless_dev *rtw_wdev = wiphy_to_wdev(wiphy);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	_irqL irqL;
 	_queue *queue = &pmlmepriv->scanned_queue;
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
@@ -1568,19 +1567,19 @@ static int cfg80211_rtw_change_iface(str
 
 	rtw_wdev->iftype = type;
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
+	spin_lock_bh(&queue->lock);
 
 	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==false)
 	{
 		rtw_wdev->iftype = old_type;
 		ret = -EPERM;
-		_exit_critical_bh(&queue->lock, &irqL);
-		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_unlock_bh(&queue->lock);
+		spin_unlock_bh(&pmlmepriv->lock);
 		goto exit;
 	}
-	_exit_critical_bh(&queue->lock, &irqL);
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 	rtw_setopmode_cmd(padapter, networkType);
 
@@ -1591,9 +1590,8 @@ exit:
 
 void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv, bool aborted)
 {
-	_irqL	irqL;
 
-	_enter_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	spin_lock_bh(&pwdev_priv->scan_req_lock);
 	if(pwdev_priv->scan_request != NULL)
 	{
 		//struct cfg80211_scan_request *scan_request = pwdev_priv->scan_request;
@@ -1620,12 +1618,11 @@ void rtw_cfg80211_indicate_scan_done(str
 		DBG_871X("%s without scan req\n", __FUNCTION__);
 		#endif
 	}
-	_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	spin_unlock_bh(&pwdev_priv->scan_req_lock);
 }
 
 void rtw_cfg80211_surveydone_event_callback(_adapter *padapter)
 {
-	_irqL	irqL;
 	_list					*plist, *phead;
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	_queue				*queue	= &(pmlmepriv->scanned_queue);
@@ -1643,7 +1640,7 @@ void rtw_cfg80211_surveydone_event_callb
 	DBG_8192C("%s\n", __func__);
 #endif
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -1670,7 +1667,7 @@ void rtw_cfg80211_surveydone_event_callb
 
 	}
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	//call this after other things have been done
 	rtw_cfg80211_indicate_scan_done(wdev_to_priv(padapter->rtw_wdev), false);
@@ -1793,7 +1790,6 @@ static int cfg80211_rtw_scan(struct wiph
 	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
 	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
 	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
-	_irqL	irqL;
 	u8 *wps_ie=NULL;
 	uint wps_ielen=0;
 	u8 *p2p_ie=NULL;
@@ -1830,9 +1826,9 @@ static int cfg80211_rtw_scan(struct wiph
 	}
 #endif
 
-	_enter_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	spin_lock_bh(&pwdev_priv->scan_req_lock);
 	pwdev_priv->scan_request = request;
-	_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
+	spin_unlock_bh(&pwdev_priv->scan_req_lock);
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
@@ -1967,7 +1963,7 @@ static int cfg80211_rtw_scan(struct wiph
 		ch[i].flags = request->channels[i]->flags;
 	}
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
 	if (request->n_channels == 1) {
 		_rtw_memcpy(&ch[1], &ch[0], sizeof(struct rtw_ieee80211_channel));
 		_rtw_memcpy(&ch[2], &ch[0], sizeof(struct rtw_ieee80211_channel));
@@ -1975,7 +1971,7 @@ static int cfg80211_rtw_scan(struct wiph
 	} else {
 		_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, NULL, 0);
 	}
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 
 	if(_status == false)
@@ -2373,7 +2369,6 @@ static int cfg80211_rtw_connect(struct w
 				 struct cfg80211_connect_params *sme)
 {
 	int ret=0;
-	_irqL irqL;
 	_list *phead;
 	struct wlan_network *pnetwork = NULL;
 	NDIS_802_11_AUTHENTICATION_MODE authmode;
@@ -2454,8 +2449,8 @@ static int cfg80211_rtw_connect(struct w
 		rtw_scan_abort(padapter);
 	}
 
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
+	spin_lock_bh(&queue->lock);
 
 	phead = get_list_head(queue);
 	pmlmepriv->pscanned = get_next(phead);
@@ -2521,8 +2516,8 @@ static int cfg80211_rtw_connect(struct w
 	{
 		ret = -ENOENT;
 		DBG_8192C("connect, matched == false, goto exit\n");
-		_exit_critical_bh(&queue->lock, &irqL);
-		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_unlock_bh(&queue->lock);
+		spin_unlock_bh(&pmlmepriv->lock);
 		goto exit;
 	}
 
@@ -2530,12 +2525,12 @@ static int cfg80211_rtw_connect(struct w
 	if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == false)
 	{
 		ret = -EPERM;
-		_exit_critical_bh(&queue->lock, &irqL);
-		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_unlock_bh(&queue->lock);
+		spin_unlock_bh(&pmlmepriv->lock);
 		goto exit;
 	}
-	_exit_critical_bh(&queue->lock, &irqL);
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
+	spin_unlock_bh(&pmlmepriv->lock);
 
 	psecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;
 	psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
@@ -3527,7 +3522,6 @@ static int	cfg80211_rtw_del_station(stru
 			       u8 *mac)
 {
 	int ret=0;
-	_irqL irqL;
 	_list	*phead, *plist;
 	u8 updated;
 	struct sta_info *psta = NULL;
@@ -3566,7 +3560,7 @@ static int	cfg80211_rtw_del_station(stru
 	}
 
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
@@ -3591,9 +3585,9 @@ static int	cfg80211_rtw_del_station(stru
 				rtw_list_delete(&psta->asoc_list);
 				pstapriv->asoc_list_cnt--;
 
-				//_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+				//spin_unlock_bh(&pstapriv->asoc_list_lock);
 				updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
-				//_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+				//spin_lock_bh(&pstapriv->asoc_list_lock);
 
 				psta = NULL;
 
@@ -3604,7 +3598,7 @@ static int	cfg80211_rtw_del_station(stru
 
 	}
 
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 	associated_clients_update(padapter, updated);
 
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -1156,7 +1156,6 @@ static int rtw_wx_set_mode(struct net_de
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType ;
 	int ret = 0;
-	_irqL irqL;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	_queue *queue = &pmlmepriv->scanned_queue;
 	_func_enter_;
@@ -1207,18 +1206,18 @@ static int rtw_wx_set_mode(struct net_de
 		rtw_setopmode_cmd(padapter, Ndis802_11AutoUnknown);
 	}
 */
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
-	_enter_critical_bh(&queue->lock, &irqL);
+	spin_lock_bh(&pmlmepriv->lock);
+	spin_lock_bh(&queue->lock);
 	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==false){
 
 		ret = -EPERM;
-		_exit_critical_bh(&queue->lock, &irqL);
-		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_unlock_bh(&queue->lock);
+		spin_unlock_bh(&pmlmepriv->lock);
 		goto exit;
 
 	}
-	_exit_critical_bh(&queue->lock, &irqL);
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
+	spin_unlock_bh(&pmlmepriv->lock);
 	rtw_setopmode_cmd(padapter, networkType);
 
 exit:
@@ -1509,7 +1508,6 @@ static int rtw_wx_set_wap(struct net_dev
 			 union iwreq_data *awrq,
 			 char *extra)
 {
-	_irqL	irqL;
 	uint ret = 0;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct sockaddr *temp = (struct sockaddr *)awrq;
@@ -1569,10 +1567,10 @@ static int rtw_wx_set_wap(struct net_dev
 	}
 
 	authmode = padapter->securitypriv.ndisauthtype;
-	_enter_critical_bh(&pmlmepriv->lock, &irqL);
-	_enter_critical_bh(&queue->lock, &irqL);
-       phead = get_list_head(queue);
-       pmlmepriv->pscanned = get_next(phead);
+	spin_lock_bh(&pmlmepriv->lock);
+	spin_lock_bh(&queue->lock);
+	phead = get_list_head(queue);
+	pmlmepriv->pscanned = get_next(phead);
 
 	while (1) {
 		if ((rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) == true)
@@ -1589,8 +1587,8 @@ static int rtw_wx_set_wap(struct net_dev
 		if ((_rtw_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == true) {
 			if (!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode)) {
 				ret = -1;
-				_exit_critical_bh(&queue->lock, &irqL);
-				_exit_critical_bh(&pmlmepriv->lock, &irqL);
+				spin_unlock_bh(&queue->lock);
+				spin_unlock_bh(&pmlmepriv->lock);
 				goto exit;
 			}
 
@@ -1598,8 +1596,8 @@ static int rtw_wx_set_wap(struct net_dev
 		}
 
 	}
-	_exit_critical_bh(&queue->lock, &irqL);
-	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	spin_unlock_bh(&queue->lock);
+	spin_unlock_bh(&pmlmepriv->lock);
 	rtw_set_802_11_authentication_mode(padapter, authmode);
 	//set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
 	if (rtw_set_802_11_bssid(padapter, temp->sa_data) == false) {
@@ -1698,7 +1696,6 @@ static int rtw_wx_set_scan(struct net_de
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
 	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
-	_irqL	irqL;
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 #endif //CONFIG_P2P
@@ -1831,11 +1828,11 @@ _func_enter_;
 
 			DBG_8192D("IW_SCAN_THIS_ESSID, ssid=%s, len=%d\n", req->essid, req->essid_len);
 
-			_enter_critical_bh(&pmlmepriv->lock, &irqL);
+			spin_lock_bh(&pmlmepriv->lock);
 
 			_status = rtw_sitesurvey_cmd(padapter, ssid, 1, NULL, 0);
 
-			_exit_critical_bh(&pmlmepriv->lock, &irqL);
+			spin_unlock_bh(&pmlmepriv->lock);
 
 		}
 		else if (req->scan_type == IW_SCAN_TYPE_PASSIVE)
@@ -1931,7 +1928,6 @@ _func_exit_;
 static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *extra)
 {
-	_irqL	irqL;
 	_list					*plist, *phead;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
@@ -2033,7 +2029,7 @@ static int rtw_wx_get_scan(struct net_de
 			break;
 	}
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -2064,7 +2060,7 @@ static int rtw_wx_get_scan(struct net_de
 
 	}
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
        wrqu->data.length = ev-extra;
 	wrqu->data.flags = 0;
@@ -2090,7 +2086,6 @@ static int rtw_wx_set_essid(struct net_d
 			      struct iw_request_info *a,
 			      union iwreq_data *wrqu, char *extra)
 {
-	_irqL irqL;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	_queue *queue = &pmlmepriv->scanned_queue;
@@ -2194,15 +2189,13 @@ static int rtw_wx_set_essid(struct net_d
 		src_ssid = ndis_ssid.Ssid;
 
 		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("rtw_wx_set_essid: ssid=[%s]\n", src_ssid));
-		_enter_critical_bh(&pmlmepriv->lock, &irqL);
-		_enter_critical_bh(&queue->lock, &irqL);
-	       phead = get_list_head(queue);
-              pmlmepriv->pscanned = get_next(phead);
+		spin_lock_bh(&pmlmepriv->lock);
+		spin_lock_bh(&queue->lock);
+		phead = get_list_head(queue);
+		pmlmepriv->pscanned = get_next(phead);
 
-		while (1)
-		{
-			if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == true)
-			{
+		while (1) {
+			if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == true) {
 			        RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_warning_,
 					 ("rtw_wx_set_essid: scan_q is empty, set ssid to check if scanning again!\n"));
 
@@ -2234,16 +2227,16 @@ static int rtw_wx_set_essid(struct net_d
 				if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == false)
 				{
 					ret = -1;
-					_exit_critical_bh(&queue->lock, &irqL);
-					_exit_critical_bh(&pmlmepriv->lock, &irqL);
+					spin_unlock_bh(&queue->lock);
+					spin_unlock_bh(&pmlmepriv->lock);
 					goto exit;
 				}
 
 				break;
 			}
 		}
-		_exit_critical_bh(&queue->lock, &irqL);
-		_exit_critical_bh(&pmlmepriv->lock, &irqL);
+		spin_unlock_bh(&queue->lock);
+		spin_unlock_bh(&pmlmepriv->lock);
 		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
 			 ("set ssid: set_802_11_auth. mode=%d\n", authmode));
 		rtw_set_802_11_authentication_mode(padapter, authmode);
@@ -3520,7 +3513,6 @@ static int rtw_get_ap_info(struct net_de
 {
 	int bssid_match, ret = 0;
 	u32 cnt=0, wpa_ielen;
-	_irqL	irqL;
 	_list	*plist, *phead;
 	unsigned char *pbuf;
 	u8 bssid[ETH_ALEN];
@@ -3564,7 +3556,7 @@ static int rtw_get_ap_info(struct net_de
 		goto exit;
 	}
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -3581,7 +3573,7 @@ static int rtw_get_ap_info(struct net_de
 		if (hwaddr_aton_i(data, bssid))
 		{
 			DBG_8192D("Invalid BSSID '%s'.\n", (u8*)data);
-			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 			return -EINVAL;
 		}
 
@@ -3610,7 +3602,7 @@ static int rtw_get_ap_info(struct net_de
 
 	}
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	if (pdata->length>=34) {
 		if (copy_to_user((u8 __user *)pdata->pointer+32, (u8*)&pdata->flags, 1)) {
@@ -4203,7 +4195,6 @@ static int rtw_p2p_get_wps_configmethod(
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	u8 peerMAC[ETH_ALEN] = { 0x00 };
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	_irqL irqL;
 	_list * plist,*phead;
 	_queue *queue = &(pmlmepriv->scanned_queue);
 	struct wlan_network *pnetwork = NULL;
@@ -4221,7 +4212,7 @@ static int rtw_p2p_get_wps_configmethod(
 
 	macstr2num(peerMAC, subcmd);
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -4256,7 +4247,7 @@ static int rtw_p2p_get_wps_configmethod(
 
 	}
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	if (!blnMatch)
 	{
@@ -4340,7 +4331,6 @@ static int rtw_p2p_get_go_device_address
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	u8 peerMAC[ETH_ALEN] = { 0x00 };
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	_irqL irqL;
 	_list *plist, *phead;
 	_queue *queue	= &(pmlmepriv->scanned_queue);
 	struct wlan_network *pnetwork = NULL;
@@ -4358,7 +4348,7 @@ static int rtw_p2p_get_go_device_address
 
 	macstr2num(peerMAC, subcmd);
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -4405,7 +4395,7 @@ static int rtw_p2p_get_go_device_address
 
 	}
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	if (!blnMatch)
 	{
@@ -4432,7 +4422,6 @@ static int rtw_p2p_get_device_type(struc
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	u8 peerMAC[ETH_ALEN] = { 0x00 };
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	_irqL irqL;
 	_list *plist, *phead;
 	_queue *queue = &(pmlmepriv->scanned_queue);
 	struct wlan_network *pnetwork = NULL;
@@ -4450,7 +4439,7 @@ static int rtw_p2p_get_device_type(struc
 
 	macstr2num(peerMAC, subcmd);
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -4487,7 +4476,7 @@ static int rtw_p2p_get_device_type(struc
 
 	}
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	if (!blnMatch)
 	{
@@ -4510,7 +4499,6 @@ static int rtw_p2p_get_device_name(struc
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	u8 peerMAC[ETH_ALEN] = { 0x00 };
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	_irqL irqL;
 	_list *plist, *phead;
 	_queue *queue = &(pmlmepriv->scanned_queue);
 	struct wlan_network *pnetwork = NULL;
@@ -4528,7 +4516,7 @@ static int rtw_p2p_get_device_name(struc
 
 	macstr2num(peerMAC, subcmd);
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -4561,7 +4549,7 @@ static int rtw_p2p_get_device_name(struc
 
 	}
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	if (!blnMatch)
 	{
@@ -4584,7 +4572,6 @@ static int rtw_p2p_get_invitation_proced
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	u8 peerMAC[ETH_ALEN] = { 0x00 };
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-	_irqL irqL;
 	_list *plist, *phead;
 	_queue *queue	= &(pmlmepriv->scanned_queue);
 	struct wlan_network *pnetwork = NULL;
@@ -4602,7 +4589,7 @@ static int rtw_p2p_get_invitation_proced
 
 	macstr2num(peerMAC, subcmd);
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -4641,7 +4628,7 @@ static int rtw_p2p_get_invitation_proced
 
 	}
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	if (!blnMatch)
 	{
@@ -4676,7 +4663,6 @@ static int rtw_p2p_connect(struct net_de
 	int					jj,kk;
 	u8					peerMACStr[ ETH_ALEN * 2 ] = { 0x00 };
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
-	_irqL				irqL;
 	_list					*plist, *phead;
 	_queue				*queue	= &(pmlmepriv->scanned_queue);
 	struct	wlan_network	*pnetwork = NULL;
@@ -4712,7 +4698,7 @@ static int rtw_p2p_connect(struct net_de
 		peerMAC[ jj ] = key_2char2num(extra[kk], extra[kk+ 1]);
 	}
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -4733,7 +4719,7 @@ static int rtw_p2p_connect(struct net_de
 
 	}
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	if (uintPeerChannel)
 	{
@@ -4816,7 +4802,6 @@ static int rtw_p2p_invite_req(struct net
 	u8						attr_content[50] = { 0x00 }, _status = 0;
 	u8						*p2pie;
 	uint						p2pielen = 0, attr_contentlen = 0;
-	_irqL					irqL;
 	struct tx_invite_req_info*	pinvite_req_info = &pwdinfo->invitereq_info;
 #ifdef CONFIG_CONCURRENT_MODE
 	_adapter					*pbuddy_adapter = padapter->pbuddy_adapter;
@@ -4865,7 +4850,7 @@ static int rtw_p2p_invite_req(struct net
 		pinvite_req_info->peer_macaddr[ jj ] = key_2char2num(extra[kk], extra[kk+ 1]);
 	}
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -4911,7 +4896,7 @@ static int rtw_p2p_invite_req(struct net
 
 	}
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 #ifdef CONFIG_WFD
 	if (uintPeerChannel)
@@ -5038,7 +5023,6 @@ static int rtw_p2p_set_persistent(struct
 	u8						attr_content[50] = { 0x00 }, _status = 0;
 	u8						*p2pie;
 	uint						p2pielen = 0, attr_contentlen = 0;
-	_irqL					irqL;
 	struct tx_invite_req_info*	pinvite_req_info = &pwdinfo->invitereq_info;
 #ifdef CONFIG_CONCURRENT_MODE
 	_adapter					*pbuddy_adapter = padapter->pbuddy_adapter;
@@ -5105,7 +5089,6 @@ static int rtw_p2p_set_pc(struct net_dev
 	u8					attr_content[50] = { 0x00 }, _status = 0;
 	u8 *p2pie;
 	uint					p2pielen = 0, attr_contentlen = 0;
-	_irqL				irqL;
 	uint					uintPeerChannel = 0;
 #ifdef CONFIG_CONCURRENT_MODE
 	_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
@@ -5130,7 +5113,7 @@ static int rtw_p2p_set_pc(struct net_dev
 		peerMAC[ jj ] = key_2char2num(extra[kk], extra[kk+ 1]);
 	}
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -5178,7 +5161,7 @@ static int rtw_p2p_set_pc(struct net_dev
 
 	}
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 	DBG_8192D("[%s] channel = %d\n", __func__, uintPeerChannel);
 
 	if (uintPeerChannel)
@@ -5360,7 +5343,6 @@ static int rtw_p2p_prov_disc(struct net_
 	u8					attr_content[100] = { 0x00 }, _status = 0;
 	u8 *p2pie;
 	uint					p2pielen = 0, attr_contentlen = 0;
-	_irqL				irqL;
 #ifdef CONFIG_CONCURRENT_MODE
 	_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -5424,7 +5406,7 @@ static int rtw_p2p_prov_disc(struct net_
 		return(ret);
 	}
 
-	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
@@ -5478,7 +5460,7 @@ static int rtw_p2p_prov_disc(struct net_
 
 	}
 
-	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
 #ifdef CONFIG_WFD
 	{
@@ -5997,7 +5979,6 @@ static int rtw_dbg_port(struct net_devic
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-	_irqL irqL;
 	int ret = 0;
 	u8 major_cmd, minor_cmd;
 	u16 arg;
@@ -6324,7 +6305,7 @@ static int rtw_dbg_port(struct net_devic
 #ifdef CONFIG_AP_MODE
 						DBG_8192D("sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
 #endif
-						_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+						spin_lock_bh(&pstapriv->sta_hash_lock);
 
 						for(i=0; i< NUM_STA; i++)
 						{
@@ -6372,7 +6353,7 @@ static int rtw_dbg_port(struct net_devic
 							}
 						}
 
-						_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+						spin_unlock_bh(&pstapriv->sta_hash_lock);
 
 					}
 					break;
@@ -7238,7 +7219,6 @@ static int rtw_set_beacon(struct net_dev
 
 static int rtw_hostapd_sta_flush(struct net_device *dev)
 {
-	//_irqL irqL;
 	//_list	*phead, *plist;
 	int ret=0;
 	//struct sta_info *psta = NULL;
@@ -7257,7 +7237,6 @@ static int rtw_hostapd_sta_flush(struct
 
 static int rtw_add_sta(struct net_device *dev, struct ieee_param *param)
 {
-	_irqL irqL;
 	int ret=0;
 	struct sta_info *psta = NULL;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
@@ -7283,9 +7262,9 @@ static int rtw_add_sta(struct net_device
 	if (psta)
 	{
 		DBG_8192D("rtw_add_sta(), free has been added psta=%p\n", psta);
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
 		rtw_free_stainfo(padapter,  psta);
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
 		psta = NULL;
 	}
@@ -7346,7 +7325,6 @@ static int rtw_add_sta(struct net_device
 
 static int rtw_del_sta(struct net_device *dev, struct ieee_param *param)
 {
-	_irqL irqL;
 	int ret=0;
 	struct sta_info *psta = NULL;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
@@ -7369,7 +7347,7 @@ static int rtw_del_sta(struct net_device
 
 		//DBG_8192D("free psta=%p, aid=%d\n", psta, psta->aid);
 
-		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		spin_lock_bh(&pstapriv->asoc_list_lock);
 		if (rtw_is_list_empty(&psta->asoc_list)==false)
 		{
 			rtw_list_delete(&psta->asoc_list);
@@ -7377,7 +7355,7 @@ static int rtw_del_sta(struct net_device
 			updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
 
 		}
-		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 		associated_clients_update(padapter, updated);
 
@@ -9628,7 +9606,6 @@ static int rtw_tdls_enable(struct net_de
 
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct tdls_info	*ptdlsinfo = &padapter->tdlsinfo;
-	_irqL	 irqL;
 	_list	*plist, *phead;
 	s32	index;
 	struct sta_info *psta = NULL;
@@ -9647,7 +9624,7 @@ static int rtw_tdls_enable(struct net_de
 		if (pstapriv->asoc_sta_count==1)
 			return ret;
 
-		_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+		spin_lock_bh(&pstapriv->sta_hash_lock);
 		for(index=0; index< NUM_STA; index++)
 		{
 			phead = &(pstapriv->sta_hash[index]);
@@ -9665,7 +9642,7 @@ static int rtw_tdls_enable(struct net_de
 				}
 			}
 		}
-		_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+		spin_unlock_bh(&pstapriv->sta_hash_lock);
 
 		for(index=0; index< NUM_STA; index++)
 		{
--- a/drivers/staging/rtl8192du/os_dep/xmit_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/xmit_linux.c
@@ -223,7 +223,6 @@ void rtw_os_xmit_complete(_adapter *pada
 
 void rtw_os_xmit_schedule(_adapter *padapter)
 {
-	_irqL  irqL;
 	struct xmit_priv *pxmitpriv;
 
 	if(!padapter)
@@ -231,14 +230,14 @@ void rtw_os_xmit_schedule(_adapter *pada
 
 	pxmitpriv = &padapter->xmitpriv;
 
-	_enter_critical_bh(&pxmitpriv->lock, &irqL);
+	spin_lock_bh(&pxmitpriv->lock);
 
 	if(rtw_txframes_pending(padapter))
 	{
 		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
 	}
 
-	_exit_critical_bh(&pxmitpriv->lock, &irqL);
+	spin_unlock_bh(&pxmitpriv->lock);
 }
 
 
@@ -247,13 +246,12 @@ int rtw_mlcst2unicst(_adapter *padapter,
 {
 	struct	sta_priv *pstapriv = &padapter->stapriv;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
-	_irqL	irqL;
 	_list	*phead, *plist;
 	struct sk_buff *newskb;
 	struct sta_info *psta = NULL;
 	s32	res;
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_lock_bh(&pstapriv->asoc_list_lock);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
@@ -283,13 +281,13 @@ int rtw_mlcst2unicst(_adapter *padapter,
 			DBG_8192D("%s-%d: skb_copy() failed!\n", __FUNCTION__, __LINE__);
 			pxmitpriv->tx_drop++;
 
-			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
 			//dev_kfree_skb_any(skb);
 			return false;	// Caller shall tx this multicast frame via normal way.
 		}
 	}
 
-	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
 	dev_kfree_skb_any(skb);
 	return true;
 }

From d2ccfbcfb65967abd77d2e7bd4c832287f88e7d9 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sun, 23 Jun 2013 19:09:43 -0500
Subject: [PATCH 167/390] rtl8192du: Fix a number of sparse warnings

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_ap.c         |  10 +-
 core/rtw_ieee80211.c  |  13 +-
 core/rtw_ioctl_set.c  |   4 +-
 core/rtw_mlme.c       |  18 +-
 core/rtw_mlme_ext.c   | 474 +++++++++++++++++++++++++-------------------------
 core/rtw_p2p.c        |  49 +++---
 core/rtw_recv.c       |  16 +-
 core/rtw_security.c   |  20 +--
 core/rtw_tdls.c       |   4 +-
 core/rtw_wlan_util.c  |  12 +-
 core/rtw_xmit.c       |  16 +-
 include/basic_types.h |   4 +-
 include/rtw_xmit.h    |  16 +-
 include/wifi.h        |  86 ++++-----
 os_dep/os_intfs.c     |   6 +-
 15 files changed, 375 insertions(+), 373 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_ap.c
+++ b/drivers/staging/rtl8192du/core/rtw_ap.c
@@ -89,7 +89,7 @@ static void update_BCNTIM(struct rtw_ada
 	/* update TIM IE */
 	if (true) {
 		u8 *p, *dst_ie, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;
-		u16 tim_bitmap_le;
+		__le16 tim_bitmap_le;
 		uint offset, tmp_len, tim_ielen, tim_ie_offset, remainder_ielen;
 
 		tim_bitmap_le = cpu_to_le16(pstapriv->tim_bitmap);
@@ -702,11 +702,11 @@ void update_sta_info_apmode(struct rtw_a
 		phtpriv_sta->ampdu_enable = phtpriv_ap->ampdu_enable;
 
 		/* check if sta support s Short GI */
-		if ((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))
+		if ((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & (IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))
 			phtpriv_sta->sgi = true;
 
 		/*  bwmode */
-		if ((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH)) {
+		if ((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & IEEE80211_HT_CAP_SUP_WIDTH) {
 			phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
 			phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
 		}
@@ -769,7 +769,7 @@ static void update_hw_ht_param(struct rt
 	/*  */
 	/*  Config SM Power Save setting */
 	/*  */
-	pmlmeinfo->SM_PS = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 0x0C) >> 2;
+	pmlmeinfo->SM_PS = (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & 0x0C) >> 2;
 	if (pmlmeinfo->SM_PS == WLAN_HT_CAP_SM_PS_STATIC)
 		DBG_8192D("%s(): WLAN_HT_CAP_SM_PS_STATIC\n", __func__);
 }
@@ -1825,7 +1825,7 @@ void bss_cap_update_on_sta_join(struct r
 #ifdef CONFIG_80211N_HT
 
 	if (psta->flags & WLAN_STA_HT) {
-		u16 ht_capab = le16_to_cpu(psta->htpriv.ht_cap.cap_info);
+		u16 ht_capab = psta->htpriv.ht_cap.cap_info;
 
 		DBG_8192D("HT: STA %pM HT Capabilities Info: 0x%04x\n", psta->hwaddr, ht_capab);
 
--- a/drivers/staging/rtl8192du/core/rtw_ieee80211.c
+++ b/drivers/staging/rtl8192du/core/rtw_ieee80211.c
@@ -384,20 +384,20 @@ _func_enter_;
 	ie += sz;
 
 	/* beacon interval : 2bytes */
-	*(u16 *)ie = cpu_to_le16((u16)pdev_network->Configuration.BeaconPeriod);/* BCN_INTERVAL; */
+	*(__le16 *)ie = cpu_to_le16((u16)pdev_network->Configuration.BeaconPeriod);/* BCN_INTERVAL; */
 	sz += 2;
 	ie += 2;
 
 	/* capability info */
 	*(u16 *)ie = 0;
 
-	*(u16 *)ie |= cpu_to_le16(cap_IBSS);
+	*(__le16 *)ie |= cpu_to_le16(cap_IBSS);
 
 	if (pregistrypriv->preamble == PREAMBLE_SHORT)
-		*(u16 *)ie |= cpu_to_le16(cap_ShortPremble);
+		*(__le16 *)ie |= cpu_to_le16(cap_ShortPremble);
 
 	if (pdev_network->Privacy)
-		*(u16 *)ie |= cpu_to_le16(cap_Privacy);
+		*(__le16 *)ie |= cpu_to_le16(cap_Privacy);
 
 	sz += 2;
 	ie += 2;
@@ -443,6 +443,7 @@ unsigned char *rtw_get_wpa_ie(unsigned c
 {
 	int len;
 	u16 val16;
+	__le16 le_tmp;
 	unsigned char wpa_oui_type[] = {0x00, 0x50, 0xf2, 0x01};
 	u8 *pbuf = pie;
 
@@ -455,9 +456,9 @@ unsigned char *rtw_get_wpa_ie(unsigned c
 				goto check_next_ie;
 
 			/* check version... */
-			memcpy((u8 *)&val16, (pbuf + 6), sizeof(val16));
+			memcpy((u8 *)&le_tmp, (pbuf + 6), sizeof(val16));
 
-			val16 = le16_to_cpu(val16);
+			val16 = le16_to_cpu(le_tmp);
 			if (val16 != 0x0001)
 				goto check_next_ie;
 
--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -1069,8 +1069,8 @@ u16 rtw_get_cur_max_rate(struct rtw_adap
 			/* cur_bwmod is updated by beacon, pmlmeinfo is updated by association response */
 			bw_40MHz = (pmlmeext->cur_bwmode && (HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH & pmlmeinfo->HT_info.infos[0])) ? 1 : 0;
 
-			short_GI_20 = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info&IEEE80211_HT_CAP_SGI_20) ? 1 : 0;
-			short_GI_40 = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info&IEEE80211_HT_CAP_SGI_40) ? 1 : 0;
+			short_GI_20 = (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & IEEE80211_HT_CAP_SGI_20) ? 1 : 0;
+			short_GI_40 = (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & IEEE80211_HT_CAP_SGI_40) ? 1 : 0;
 
 			rtw_hal_get_hwreg(adapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 			max_rate = rtw_mcs_rate(
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -440,7 +440,7 @@ u8 *rtw_get_capability_from_ie(u8 *ie)
 
 u16 rtw_get_capability(struct wlan_bssid_ex *bss)
 {
-	u16 val;
+	__le16 val;
 	_func_enter_;
 
 	memcpy((u8 *)&val, rtw_get_capability_from_ie(bss->IEs), 2);
@@ -572,14 +572,15 @@ static inline int is_same_ess(struct wla
 int is_same_network(struct wlan_bssid_ex *src, struct wlan_bssid_ex *dst)
 {
 	u16 s_cap, d_cap;
+	__le16 le_scap, le_dcap;
 
 	_func_enter_;
 
-	memcpy((u8 *)&s_cap, rtw_get_capability_from_ie(src->IEs), 2);
-	memcpy((u8 *)&d_cap, rtw_get_capability_from_ie(dst->IEs), 2);
+	memcpy((u8 *)&le_scap, rtw_get_capability_from_ie(src->IEs), 2);
+	memcpy((u8 *)&le_dcap, rtw_get_capability_from_ie(dst->IEs), 2);
 
-	s_cap = le16_to_cpu(s_cap);
-	d_cap = le16_to_cpu(d_cap);
+	s_cap = le16_to_cpu(le_scap);
+	d_cap = le16_to_cpu(le_dcap);
 
 	_func_exit_;
 
@@ -1649,7 +1650,7 @@ void rtw_joinbss_event_prehandle(struct
 	if (pnetwork->network.Length > sizeof(struct wlan_bssid_ex)) {
 		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
 			 ("\n\n ***joinbss_evt_callback return a wrong bss ***\n\n"));
-		goto ignore_joinbss_callback;
+		goto ignore_nolock;
 	}
 
 	spin_lock_bh(&pmlmepriv->lock);
@@ -1830,6 +1831,7 @@ void rtw_joinbss_event_prehandle(struct
 ignore_joinbss_callback:
 
 	spin_unlock_bh(&pmlmepriv->lock);
+ignore_nolock:
 	_func_exit_;
 }
 
@@ -3092,7 +3094,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 
 	/* update cur_bwmode & cur_ch_offset */
 	if ((cbw40_enable) &&
-	    (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & BIT(1)) &&
+	    (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & BIT(1)) &&
 	    (pmlmeinfo->HT_info.infos[0] & BIT(2))) {
 		int i;
 		u8 rf_type;
@@ -3151,7 +3153,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 	/*  Config SM Power Save setting */
 	/*  */
 	pmlmeinfo->SM_PS =
-	    (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 0x0C) >> 2;
+	    (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & 0x0C) >> 2;
 	if (pmlmeinfo->SM_PS == WLAN_HT_CAP_SM_PS_STATIC) {
 		DBG_8192D("%s(): WLAN_HT_CAP_SM_PS_STATIC\n", __func__);
 	}
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -1099,11 +1099,8 @@ unsigned int OnAuth(struct rtw_adapter *
 	sa = GetAddr2Ptr(pframe);
 
 	auth_mode = psecuritypriv->dot11AuthAlgrthm;
-	seq = cpu_to_le16(*(u16 *)((SIZE_PTR) pframe + WLAN_HDR_A3_LEN + 2));
-	algorithm = cpu_to_le16(*(u16 *)((SIZE_PTR) pframe + WLAN_HDR_A3_LEN));
-
-	if (GetPrivacy(pframe)) {
-	}
+	seq = le16_to_cpu(*(__le16 *)((SIZE_PTR) pframe + WLAN_HDR_A3_LEN + 2));
+	algorithm = le16_to_cpu(*(__le16 *)((SIZE_PTR) pframe + WLAN_HDR_A3_LEN));
 
 	DBG_8192D("auth alg=%x, seq=%X\n", algorithm, seq);
 
@@ -1288,9 +1285,9 @@ unsigned int OnAuthClient(struct rtw_ada
 
 	offset = (GetPrivacy(pframe)) ? 4 : 0;
 
-	seq = le16_to_cpu(*(unsigned short *)
+	seq = le16_to_cpu(*(__le16 *)
 			((SIZE_PTR) pframe + WLAN_HDR_A3_LEN + offset + 2));
-	status = le16_to_cpu(*(unsigned short *)
+	status = le16_to_cpu(*(__le16 *)
 			((SIZE_PTR) pframe + WLAN_HDR_A3_LEN + offset + 4));
 
 	if (status != 0) {
@@ -1951,7 +1948,7 @@ unsigned int OnAssocRsp(struct rtw_adapt
 	_cancel_timer_ex(&pmlmeext->link_timer);
 
 	/* status */
-	status = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN + 2));
+	status = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN + 2));
 	if (status > 0) {
 		DBG_8192D("assoc reject, status code: %d\n", status);
 		pmlmeinfo->state = WIFI_FW_NULL_STATE;
@@ -1961,14 +1958,14 @@ unsigned int OnAssocRsp(struct rtw_adapt
 
 	/* get capabilities */
 	pmlmeinfo->capability =
-	    le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
+	    le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));
 
 	/* set slot time */
 	pmlmeinfo->slotTime = (pmlmeinfo->capability & BIT(10)) ? 9 : 20;
 
 	/* AID */
 	res = 
-	    (int)(le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN + 4))
+	    (int)(le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN + 4))
 		  & 0x3fff);
 	pmlmeinfo->aid = res;
 
@@ -2054,7 +2051,7 @@ unsigned int OnDeAuth(struct rtw_adapter
 	}
 #endif /* CONFIG_P2P */
 
-	reason = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
+	reason = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));
 
 	DBG_8192D("%s Reason code(%d)\n", __func__, reason);
 
@@ -2119,7 +2116,7 @@ unsigned int OnDisassoc(struct rtw_adapt
 	}
 #endif /* CONFIG_P2P */
 
-	reason = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
+	reason = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));
 
 	DBG_8192D("%s Reason code(%d)\n", __func__, reason);
 
@@ -2448,7 +2445,7 @@ void issue_p2p_GO_request(struct rtw_ada
 {
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8 action = P2P_PUB_ACTION_ACTION;
-	u32 p2poui = cpu_to_be32(P2POUI);
+	__be32 p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_GO_NEGO_REQ;
 	u8 wpsie[255] = { 0x00 }, p2pie[255] = {
 	0x00};
@@ -2512,16 +2509,16 @@ void issue_p2p_GO_request(struct rtw_ada
 	/*      WPS Section */
 	wpsielen = 0;
 	/*      WPS OUI */
-	*(u32 *)(wpsie) = cpu_to_be32(WPSOUI);
+	*(__be32 *)(wpsie) = cpu_to_be32(WPSOUI);
 	wpsielen += 4;
 
 	/*      WPS version */
 	/*      Type: */
-	*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
+	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 	wpsielen += 2;
 
 	/*      Length: */
-	*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
+	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
 	wpsielen += 2;
 
 	/*      Value: */
@@ -2529,22 +2526,22 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/*      Device Password ID */
 	/*      Type: */
-	*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
+	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
 	wpsielen += 2;
 
 	/*      Length: */
-	*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
+	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
 	wpsielen += 2;
 
 	/*      Value: */
 
 	if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN) {
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_USER_SPEC);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_USER_SPEC);
 	} else if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_SELF_DISPLAY_PIN) {
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);
 	} else if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PBC) {
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_PBC);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_PBC);
 	}
 
 	wpsielen += 2;
@@ -2579,7 +2576,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -2599,7 +2596,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[p2pielen++] = P2P_ATTR_GO_INTENT;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -2611,7 +2608,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -2623,7 +2620,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[p2pielen++] = P2P_ATTR_LISTEN_CH;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -2646,16 +2643,16 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0004);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0004);
 	p2pielen += 2;
 
 	/*      Value: */
 	/*      Availability Period */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 	p2pielen += 2;
 
 	/*      Availability Interval */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 	p2pielen += 2;
 
 	/*      Intended P2P Interface Address */
@@ -2663,7 +2660,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[p2pielen++] = P2P_ATTR_INTENTED_IF_ADDR;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -2684,13 +2681,13 @@ void issue_p2p_GO_request(struct rtw_ada
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(5 + 1);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(5 + 1);
 	} else {
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 	}
 #else
 
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 
 #endif
 	p2pielen += 2;
@@ -2781,7 +2778,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	/*      Length: */
 	/*      21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
 	/*      + NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
-	*(u16 *)(p2pie + p2pielen) =
+	*(__le16 *)(p2pie + p2pielen) =
 	    cpu_to_le16(21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
@@ -2793,21 +2790,21 @@ void issue_p2p_GO_request(struct rtw_ada
 	/*      Config Method */
 	/*      This field should be big endian. Noted by P2P specification. */
 
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
 
 	p2pielen += 2;
 
 	/*      Primary Device Type */
 	/*      Category ID */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
 	/*      OUI */
-	*(u32 *)(p2pie + p2pielen) = cpu_to_be32(WPSOUI);
+	*(__be32 *)(p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 	p2pielen += 4;
 
 	/*      Sub Category ID */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
 	/*      Number of Secondary Device Types */
@@ -2815,11 +2812,11 @@ void issue_p2p_GO_request(struct rtw_ada
 
 	/*      Device Name */
 	/*      Type: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -2832,7 +2829,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -2880,7 +2877,7 @@ static void issue_p2p_GO_response(struct
 {
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8 action = P2P_PUB_ACTION_ACTION;
-	u32 p2poui = cpu_to_be32(P2POUI);
+	__be32 p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_GO_NEGO_RESP;
 	u8 wpsie[255] = { 0x00 }, p2pie[255] = {
 	0x00};
@@ -2888,6 +2885,7 @@ static void issue_p2p_GO_response(struct
 	uint wpsielen = 0;
 	u16 wps_devicepassword_id = 0x0000;
 	uint wps_devicepassword_id_len = 0;
+	__be16 be_tmp;
 	u8 channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh;
 	u16 len_channellist_attr = 0;
 
@@ -2951,9 +2949,8 @@ static void issue_p2p_GO_response(struct
 	rtw_get_wps_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_,
 		       len - _PUBLIC_ACTION_IE_OFFSET_, wpsie, &wpsielen);
 	rtw_get_wps_attr_content(wpsie, wpsielen, WPS_ATTR_DEVICE_PWID,
-				 (u8 *)&wps_devicepassword_id,
-				 &wps_devicepassword_id_len);
-	wps_devicepassword_id = be16_to_cpu(wps_devicepassword_id);
+				 (u8 *)&be_tmp, &wps_devicepassword_id_len);
+	wps_devicepassword_id = be16_to_cpu(be_tmp);
 
 	memset(wpsie, 0x00, 255);
 	wpsielen = 0;
@@ -2961,16 +2958,16 @@ static void issue_p2p_GO_response(struct
 	/*      WPS Section */
 	wpsielen = 0;
 	/*      WPS OUI */
-	*(u32 *)(wpsie) = cpu_to_be32(WPSOUI);
+	*(__be32 *)(wpsie) = cpu_to_be32(WPSOUI);
 	wpsielen += 4;
 
 	/*      WPS version */
 	/*      Type: */
-	*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
+	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 	wpsielen += 2;
 
 	/*      Length: */
-	*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
+	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
 	wpsielen += 2;
 
 	/*      Value: */
@@ -2978,21 +2975,21 @@ static void issue_p2p_GO_response(struct
 
 	/*      Device Password ID */
 	/*      Type: */
-	*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
+	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
 	wpsielen += 2;
 
 	/*      Length: */
-	*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
+	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
 	wpsielen += 2;
 
 	/*      Value: */
 	if (wps_devicepassword_id == WPS_DPID_USER_SPEC) {
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);
 	} else if (wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC) {
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_USER_SPEC);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_USER_SPEC);
 	} else {
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_PBC);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_PBC);
 	}
 	wpsielen += 2;
 
@@ -3049,7 +3046,7 @@ static void issue_p2p_GO_response(struct
 	p2pie[p2pielen++] = P2P_ATTR_STATUS;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3060,7 +3057,7 @@ static void issue_p2p_GO_response(struct
 	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3089,7 +3086,7 @@ static void issue_p2p_GO_response(struct
 	p2pie[p2pielen++] = P2P_ATTR_GO_INTENT;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3106,7 +3103,7 @@ static void issue_p2p_GO_response(struct
 	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3118,7 +3115,7 @@ static void issue_p2p_GO_response(struct
 	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3151,7 +3148,7 @@ static void issue_p2p_GO_response(struct
 	p2pie[p2pielen++] = P2P_ATTR_INTENTED_IF_ADDR;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3171,13 +3168,13 @@ static void issue_p2p_GO_response(struct
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(5 + 1);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(5 + 1);
 	} else {
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 	}
 #else
 
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 
 #endif
 	p2pielen += 2;
@@ -3268,7 +3265,7 @@ static void issue_p2p_GO_response(struct
 	/*      Length: */
 	/*      21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
 	/*      + NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
-	*(u16 *)(p2pie + p2pielen) =
+	*(__le16 *)(p2pie + p2pielen) =
 	    cpu_to_le16(21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
@@ -3280,21 +3277,21 @@ static void issue_p2p_GO_response(struct
 	/*      Config Method */
 	/*      This field should be big endian. Noted by P2P specification. */
 
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
 
 	p2pielen += 2;
 
 	/*      Primary Device Type */
 	/*      Category ID */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
 	/*      OUI */
-	*(u32 *)(p2pie + p2pielen) = cpu_to_be32(WPSOUI);
+	*(__be32 *)(p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 	p2pielen += 4;
 
 	/*      Sub Category ID */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
 	/*      Number of Secondary Device Types */
@@ -3302,11 +3299,11 @@ static void issue_p2p_GO_response(struct
 
 	/*      Device Name */
 	/*      Type: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3320,7 +3317,7 @@ static void issue_p2p_GO_response(struct
 		p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
 
 		/*      Length: */
-		*(u16 *)(p2pie + p2pielen) =
+		*(__le16 *)(p2pie + p2pielen) =
 		    cpu_to_le16(ETH_ALEN + pwdinfo->nego_ssidlen);
 		p2pielen += 2;
 
@@ -3356,7 +3353,7 @@ static void issue_p2p_GO_confirm(struct
 {
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8 action = P2P_PUB_ACTION_ACTION;
-	u32 p2poui = cpu_to_be32(P2POUI);
+	__be32 p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_GO_NEGO_CONF;
 	u8 wpsie[255] = { 0x00 }, p2pie[255] = {
 	0x00};
@@ -3436,7 +3433,7 @@ static void issue_p2p_GO_confirm(struct
 	p2pie[p2pielen++] = P2P_ATTR_STATUS;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3447,7 +3444,7 @@ static void issue_p2p_GO_confirm(struct
 	p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3467,7 +3464,7 @@ static void issue_p2p_GO_confirm(struct
 	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3515,7 +3512,7 @@ static void issue_p2p_GO_confirm(struct
 	p2pie[p2pielen++] = P2P_ATTR_CH_LIST;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) =
+	*(__le16 *)(p2pie + p2pielen) =
 	    cpu_to_le16(pwdinfo->channel_list_attr_len);
 	p2pielen += 2;
 
@@ -3530,7 +3527,7 @@ static void issue_p2p_GO_confirm(struct
 		p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
 
 		/*      Length: */
-		*(u16 *)(p2pie + p2pielen) =
+		*(__le16 *)(p2pie + p2pielen) =
 		    cpu_to_le16(ETH_ALEN + pwdinfo->nego_ssidlen);
 		p2pielen += 2;
 
@@ -3566,7 +3563,7 @@ void issue_p2p_invitation_request(struct
 {
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8 action = P2P_PUB_ACTION_ACTION;
-	u32 p2poui = cpu_to_be32(P2POUI);
+	__be32 p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_INVIT_REQ;
 	u8 p2pie[255] = { 0x00 };
 	u8 p2pielen = 0, i;
@@ -3654,7 +3651,7 @@ void issue_p2p_invitation_request(struct
 	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3666,7 +3663,7 @@ void issue_p2p_invitation_request(struct
 	p2pie[p2pielen++] = P2P_ATTR_INVITATION_FLAGS;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3677,7 +3674,7 @@ void issue_p2p_invitation_request(struct
 	p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3709,7 +3706,7 @@ void issue_p2p_invitation_request(struct
 		p2pie[p2pielen++] = P2P_ATTR_GROUP_BSSID;
 
 		/*      Length: */
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
 		p2pielen += 2;
 
 		/*      Value: */
@@ -3733,13 +3730,13 @@ void issue_p2p_invitation_request(struct
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(5 + 1);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(5 + 1);
 	} else {
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 	}
 #else
 
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 
 #endif
 	p2pielen += 2;
@@ -3827,7 +3824,7 @@ void issue_p2p_invitation_request(struct
 	p2pie[p2pielen++] = P2P_ATTR_GROUP_ID;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) =
+	*(__le16 *)(p2pie + p2pielen) =
 	    cpu_to_le16(6 + pwdinfo->invitereq_info.ssidlen);
 	p2pielen += 2;
 
@@ -3848,7 +3845,7 @@ void issue_p2p_invitation_request(struct
 	/*      Length: */
 	/*      21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
 	/*      + NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
-	*(u16 *)(p2pie + p2pielen) =
+	*(__le16 *)(p2pie + p2pielen) =
 	    cpu_to_le16(21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
@@ -3859,20 +3856,20 @@ void issue_p2p_invitation_request(struct
 
 	/*      Config Method */
 	/*      This field should be big endian. Noted by P2P specification. */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY);
 	p2pielen += 2;
 
 	/*      Primary Device Type */
 	/*      Category ID */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
 	/*      OUI */
-	*(u32 *)(p2pie + p2pielen) = cpu_to_be32(WPSOUI);
+	*(__be32 *)(p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 	p2pielen += 4;
 
 	/*      Sub Category ID */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
 	/*      Number of Secondary Device Types */
@@ -3880,11 +3877,11 @@ void issue_p2p_invitation_request(struct
 
 	/*      Device Name */
 	/*      Type: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
+	*(__be16 *)(p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -3914,7 +3911,7 @@ void issue_p2p_invitation_response(struc
 {
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8 action = P2P_PUB_ACTION_ACTION;
-	u32 p2poui = cpu_to_be32(P2POUI);
+	__be32 p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_INVIT_RESP;
 	u8 p2pie[255] = { 0x00 };
 	u8 p2pielen = 0, i;
@@ -3999,7 +3996,7 @@ void issue_p2p_invitation_response(struc
 	p2pie[p2pielen++] = P2P_ATTR_STATUS;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -4016,7 +4013,7 @@ void issue_p2p_invitation_response(struc
 	p2pie[p2pielen++] = P2P_ATTR_CONF_TIMEOUT;
 
 	/*      Length: */
-	*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
+	*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
 	/*      Value: */
@@ -4035,7 +4032,7 @@ void issue_p2p_invitation_response(struc
 			p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
 
 			/*      Length: */
-			*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
+			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
 			p2pielen += 2;
 
 			/*      Value: */
@@ -4058,7 +4055,7 @@ void issue_p2p_invitation_response(struc
 			p2pie[p2pielen++] = P2P_ATTR_GROUP_BSSID;
 
 			/*      Length: */
-			*(u16 *)(p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
+			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
 			p2pielen += 2;
 
 			/*      Value: */
@@ -4082,14 +4079,14 @@ void issue_p2p_invitation_response(struc
 
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_buddy_fwstate(adapt, _FW_LINKED)) {
-			*(u16 *)(p2pie + p2pielen) = cpu_to_le16(5 + 1);
+			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(5 + 1);
 		} else {
-			*(u16 *)(p2pie + p2pielen) =
+			*(__le16 *)(p2pie + p2pielen) =
 			    cpu_to_le16(len_channellist_attr);
 		}
 #else
 
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(len_channellist_attr);
 
 #endif
 		p2pielen += 2;
@@ -4203,7 +4200,7 @@ void issue_p2p_provision_request(struct
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8 action = P2P_PUB_ACTION_ACTION;
 	u8 dialogToken = 1;
-	u32 p2poui = cpu_to_be32(P2POUI);
+	__be32 p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_PROVISION_DISC_REQ;
 	u8 wpsie[100] = { 0x00 };
 	u8 wpsielen = 0;
@@ -4269,16 +4266,16 @@ void issue_p2p_provision_request(struct
 
 	wpsielen = 0;
 	/*      WPS OUI */
-	*(u32 *)(wpsie) = cpu_to_be32(WPSOUI);
+	*(__be32 *)(wpsie) = cpu_to_be32(WPSOUI);
 	wpsielen += 4;
 
 	/*      WPS version */
 	/*      Type: */
-	*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
+	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 	wpsielen += 2;
 
 	/*      Length: */
-	*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
+	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
 	wpsielen += 2;
 
 	/*      Value: */
@@ -4286,15 +4283,15 @@ void issue_p2p_provision_request(struct
 
 	/*      Config Method */
 	/*      Type: */
-	*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
+	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
 	wpsielen += 2;
 
 	/*      Length: */
-	*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
+	*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
 	wpsielen += 2;
 
 	/*      Value: */
-	*(u16 *)(wpsie + wpsielen) =
+	*(__be16 *)(wpsie + wpsielen) =
 	    cpu_to_be16(pwdinfo->tx_prov_disc_info.wps_config_method_request);
 	wpsielen += 2;
 
@@ -4476,16 +4473,16 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		wpsielen = 0;
 		/*      WPS OUI */
-		*(u32 *)(wpsie) = cpu_to_be32(WPSOUI);
+		*(__be32 *)(wpsie) = cpu_to_be32(WPSOUI);
 		wpsielen += 4;
 
 		/*      WPS version */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
 		/*      Value: */
@@ -4530,12 +4527,12 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		/*      WiFi Simple Config State */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(WPS_ATTR_SIMPLE_CONF_STATE);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
 		/*      Value: */
@@ -4543,11 +4540,11 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		/*      Response Type */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_RESP_TYPE);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_RESP_TYPE);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
 		/*      Value: */
@@ -4555,11 +4552,11 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		/*      UUID-E */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_UUID_E);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_UUID_E);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0010);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0010);
 		wpsielen += 2;
 
 		/*      Value: */
@@ -4568,12 +4565,12 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		/*      Manufacturer */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(WPS_ATTR_MANUFACTURER);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0007);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0007);
 		wpsielen += 2;
 
 		/*      Value: */
@@ -4582,11 +4579,11 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		/*      Model Name */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_MODEL_NAME);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_MODEL_NAME);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0006);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0006);
 		wpsielen += 2;
 
 		/*      Value: */
@@ -4595,12 +4592,12 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		/*      Model Number */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(WPS_ATTR_MODEL_NUMBER);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
 		/*      Value: */
@@ -4608,12 +4605,12 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		/*      Serial Number */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(WPS_ATTR_SERIAL_NUMBER);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(ETH_ALEN);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(ETH_ALEN);
 		wpsielen += 2;
 
 		/*      Value: */
@@ -4622,34 +4619,34 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		/*      Primary Device Type */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0008);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0008);
 		wpsielen += 2;
 
 		/*      Value: */
 		/*      Category ID */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_PDT_CID_RTK_WIDI);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_PDT_CID_RTK_WIDI);
 		wpsielen += 2;
 
 		/*      OUI */
-		*(u32 *)(wpsie + wpsielen) = cpu_to_be32(WPSOUI);
+		*(__be32 *)(wpsie + wpsielen) = cpu_to_be32(WPSOUI);
 		wpsielen += 4;
 
 		/*      Sub Category ID */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_PDT_SCID_RTK_DMP);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_PDT_SCID_RTK_DMP);
 		wpsielen += 2;
 
 		/*      Device Name */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(pwdinfo->device_name_len);
 		wpsielen += 2;
 
@@ -4660,15 +4657,15 @@ void issue_probersp_p2p(struct rtw_adapt
 
 		/*      Config Method */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
 		wpsielen += 2;
 
 		/*      Value: */
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(pwdinfo->supported_wps_cm);
 		wpsielen += 2;
 
@@ -4819,16 +4816,16 @@ static int _issue_probereq_p2p(struct rt
 
 		wpsielen = 0;
 		/*      WPS OUI */
-		*(u32 *)(wpsie) = cpu_to_be32(WPSOUI);
+		*(__be32 *)(wpsie) = cpu_to_be32(WPSOUI);
 		wpsielen += 4;
 
 		/*      WPS version */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
 		/*      Value: */
@@ -4837,12 +4834,12 @@ static int _issue_probereq_p2p(struct rt
 		if (pmlmepriv->wps_probe_req_ie == NULL) {
 			/*      UUID-E */
 			/*      Type: */
-			*(u16 *)(wpsie + wpsielen) =
+			*(__be16 *)(wpsie + wpsielen) =
 			    cpu_to_be16(WPS_ATTR_UUID_E);
 			wpsielen += 2;
 
 			/*      Length: */
-			*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0010);
+			*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0010);
 			wpsielen += 2;
 
 			/*      Value: */
@@ -4852,27 +4849,27 @@ static int _issue_probereq_p2p(struct rt
 
 			/*      Config Method */
 			/*      Type: */
-			*(u16 *)(wpsie + wpsielen) =
+			*(__be16 *)(wpsie + wpsielen) =
 			    cpu_to_be16(WPS_ATTR_CONF_METHOD);
 			wpsielen += 2;
 
 			/*      Length: */
-			*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
+			*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
 			wpsielen += 2;
 
 			/*      Value: */
-			*(u16 *)(wpsie + wpsielen) =
+			*(__be16 *)(wpsie + wpsielen) =
 			    cpu_to_be16(pwdinfo->supported_wps_cm);
 			wpsielen += 2;
 		}
 
 		/*      Device Name */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(pwdinfo->device_name_len);
 		wpsielen += 2;
 
@@ -4883,40 +4880,40 @@ static int _issue_probereq_p2p(struct rt
 
 		/*      Primary Device Type */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0008);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0008);
 		wpsielen += 2;
 
 		/*      Value: */
 		/*      Category ID */
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 		wpsielen += 2;
 
 		/*      OUI */
-		*(u32 *)(wpsie + wpsielen) = cpu_to_be32(WPSOUI);
+		*(__be32 *)(wpsie + wpsielen) = cpu_to_be32(WPSOUI);
 		wpsielen += 4;
 
 		/*      Sub Category ID */
-		*(u16 *)(wpsie + wpsielen) =
+		*(__be16 *)(wpsie + wpsielen) =
 		    cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 		wpsielen += 2;
 
 		/*      Device Password ID */
 		/*      Type: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
 		wpsielen += 2;
 
 		/*      Length: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(0x0002);
 		wpsielen += 2;
 
 		/*      Value: */
-		*(u16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);	/*      Registrar-specified */
+		*(__be16 *)(wpsie + wpsielen) = cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);	/*      Registrar-specified */
 		wpsielen += 2;
 
 		pframe =
@@ -4943,7 +4940,7 @@ static int _issue_probereq_p2p(struct rt
 		p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 		/*      Length: */
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
 		p2pielen += 2;
 
 		/*      Value: */
@@ -4963,7 +4960,7 @@ static int _issue_probereq_p2p(struct rt
 		p2pie[p2pielen++] = P2P_ATTR_LISTEN_CH;
 
 		/*      Length: */
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
 		p2pielen += 2;
 
 		/*      Value: */
@@ -4986,16 +4983,16 @@ static int _issue_probereq_p2p(struct rt
 		p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
 
 		/*      Length: */
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0004);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0004);
 		p2pielen += 2;
 
 		/*      Value: */
 		/*      Availability Period */
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 		p2pielen += 2;
 
 		/*      Availability Interval */
-		*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
+		*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 		p2pielen += 2;
 
 		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)) {
@@ -5004,7 +5001,7 @@ static int _issue_probereq_p2p(struct rt
 			p2pie[p2pielen++] = P2P_ATTR_OPERATING_CH;
 
 			/*      Length: */
-			*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
+			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0005);
 			p2pielen += 2;
 
 			/*      Value: */
@@ -5862,7 +5859,7 @@ unsigned int OnAction_p2p(struct rtw_ada
 	if (category != RTW_WLAN_CATEGORY_P2P)
 		return _SUCCESS;
 
-	if (cpu_to_be32(*((u32 *)(frame_body + 1))) != P2POUI)
+	if (be32_to_cpu(*((__be32 *)(frame_body + 1))) != P2POUI)
 		return _SUCCESS;
 
 #ifdef CONFIG_IOCTL_CFG80211
@@ -6217,39 +6214,39 @@ void issue_beacon(struct rtw_adapter *ad
 				/* now pframe is end of wsc ie, insert Primary Device Type & Device Name */
 				/*      Primary Device Type */
 				/*      Type: */
-				*(u16 *)(pframe + insert_len) =
+				*(__be16 *)(pframe + insert_len) =
 				    cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
 				insert_len += 2;
 
 				/*      Length: */
-				*(u16 *)(pframe + insert_len) =
+				*(__be16 *)(pframe + insert_len) =
 				    cpu_to_be16(0x0008);
 				insert_len += 2;
 
 				/*      Value: */
 				/*      Category ID */
-				*(u16 *)(pframe + insert_len) =
+				*(__be16 *)(pframe + insert_len) =
 				    cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 				insert_len += 2;
 
 				/*      OUI */
-				*(u32 *)(pframe + insert_len) =
+				*(__be32 *)(pframe + insert_len) =
 				    cpu_to_be32(WPSOUI);
 				insert_len += 4;
 
 				/*      Sub Category ID */
-				*(u16 *)(pframe + insert_len) =
+				*(__be16 *)(pframe + insert_len) =
 				    cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 				insert_len += 2;
 
 				/*      Device Name */
 				/*      Type: */
-				*(u16 *)(pframe + insert_len) =
+				*(__be16 *)(pframe + insert_len) =
 				    cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 				insert_len += 2;
 
 				/*      Length: */
-				*(u16 *)(pframe + insert_len) =
+				*(__be16 *)(pframe + insert_len) =
 				    cpu_to_be16(pwdinfo->device_name_len);
 				insert_len += 2;
 
@@ -6919,6 +6916,7 @@ void issue_auth(struct rtw_adapter *adap
 
 	if (psta) {		/*  for AP mode */
 #ifdef CONFIG_NATIVEAP_MLME
+		__le16 le_tmp16;
 
 		memcpy(pwlanhdr->addr1, psta->hwaddr, ETH_ALEN);
 		memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)),
@@ -6933,29 +6931,29 @@ void issue_auth(struct rtw_adapter *adap
 			val16 = 0;
 
 		if (val16) {
-			val16 = cpu_to_le16(val16);
 			use_shared_key = 1;
 		}
 
+		le_tmp16 = cpu_to_le16(val16);
 		pframe =
 		    rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_,
-				     (unsigned char *)&val16,
+				     (unsigned char *)&le_tmp16,
 				     &(pattrib->pktlen));
 
 		/*  setting auth seq number */
 		val16 = (u16) psta->auth_seq;
-		val16 = cpu_to_le16(val16);
+		le_tmp16 = cpu_to_le16(val16);
 		pframe =
 		    rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_,
-				     (unsigned char *)&val16,
+				     (unsigned char *)&le_tmp16,
 				     &(pattrib->pktlen));
 
 		/*  setting status code... */
 		val16 = status;
-		val16 = cpu_to_le16(val16);
+		le_tmp16 = cpu_to_le16(val16);
 		pframe =
 		    rtw_set_fixed_ie(pframe, _STATUS_CODE_,
-				     (unsigned char *)&val16,
+				     (unsigned char *)&le_tmp16,
 				     &(pattrib->pktlen));
 
 		/*  added challenging text... */
@@ -6967,6 +6965,8 @@ void issue_auth(struct rtw_adapter *adap
 		}
 #endif
 	} else {
+		__le32 le_tmp32;
+		__le16 le_tmp16;
 		memcpy(pwlanhdr->addr1, get_my_bssid(&pmlmeinfo->network),
 		       ETH_ALEN);
 		memcpy(pwlanhdr->addr2, myid(&adapt->eeprompriv), ETH_ALEN);
@@ -6976,7 +6976,6 @@ void issue_auth(struct rtw_adapter *adap
 		/*  setting auth algo number */
 		val16 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared) ? 1 : 0;	/*  0:OPEN System, 1:Shared key */
 		if (val16) {
-			val16 = cpu_to_le16(val16);
 			use_shared_key = 1;
 		}
 
@@ -6985,33 +6984,34 @@ void issue_auth(struct rtw_adapter *adap
 		    (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key == 1)) {
 			val32 =
 			    ((pmlmeinfo->iv++) | (pmlmeinfo->key_index << 30));
-			val32 = cpu_to_le32(val32);
+			le_tmp32 = cpu_to_le32(val32);
 			pframe =
-			    rtw_set_fixed_ie(pframe, 4, (unsigned char *)&val32,
+			    rtw_set_fixed_ie(pframe, 4, (unsigned char *)&le_tmp32,
 					     &(pattrib->pktlen));
 
 			pattrib->iv_len = 4;
 		}
 
+		le_tmp16 = cpu_to_le16(val16);
 		pframe =
 		    rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_,
-				     (unsigned char *)&val16,
+				     (unsigned char *)&le_tmp16,
 				     &(pattrib->pktlen));
 
 		/*  setting auth seq number */
 		val16 = pmlmeinfo->auth_seq;
-		val16 = cpu_to_le16(val16);
+		le_tmp16 = cpu_to_le16(val16);
 		pframe =
 		    rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_,
-				     (unsigned char *)&val16,
+				     (unsigned char *)&le_tmp16,
 				     &(pattrib->pktlen));
 
 		/*  setting status code... */
 		val16 = status;
-		val16 = cpu_to_le16(val16);
+		le_tmp16 = cpu_to_le16(val16);
 		pframe =
 		    rtw_set_fixed_ie(pframe, _STATUS_CODE_,
-				     (unsigned char *)&val16,
+				     (unsigned char *)&le_tmp16,
 				     &(pattrib->pktlen));
 
 		/*  then checking to see if sending challenging text... */
@@ -7059,6 +7059,7 @@ void issue_asocrsp(struct rtw_adapter *a
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);
 	u8 *ie = pnetwork->IEs;
+	__le16 leval, lestatus;
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 #ifdef CONFIG_WFD
@@ -7108,14 +7109,14 @@ void issue_asocrsp(struct rtw_adapter *a
 	    rtw_set_fixed_ie(pframe, _CAPABILITY_, (unsigned char *)&val,
 			     &(pattrib->pktlen));
 
-	status = cpu_to_le16(status);
+	lestatus = cpu_to_le16(status);
 	pframe =
-	    rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&status,
+	    rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&lestatus,
 			     &(pattrib->pktlen));
 
-	val = cpu_to_le16(pstat->aid | BIT(14) | BIT(15));
+	leval = cpu_to_le16(pstat->aid | BIT(14) | BIT(15));
 	pframe =
-	    rtw_set_fixed_ie(pframe, _ASOC_ID_, (unsigned char *)&val,
+	    rtw_set_fixed_ie(pframe, _ASOC_ID_, (unsigned char *)&leval,
 			     &(pattrib->pktlen));
 
 	if (pstat->bssratelen <= 8) {
@@ -7242,6 +7243,7 @@ void issue_assocreq(struct rtw_adapter *
 	struct rtw_ieee80211_hdr *pwlanhdr;
 	unsigned short *fctrl;
 	unsigned short val16;
+	__le16 le_tmp;
 	unsigned int i, j, ie_len, index = 0;
 	unsigned char rf_type, bssrate[NUMRATES], sta_bssrate[NUMRATES];
 	struct ndis_802_11_variable_ies *pIE;
@@ -7309,8 +7311,8 @@ void issue_assocreq(struct rtw_adapter *
 
 	/* listen interval */
 	/* todo: listen interval for power saving */
-	val16 = cpu_to_le16(3);
-	memcpy(pframe, (unsigned char *)&val16, 2);
+	le_tmp = cpu_to_le16(3);
+	memcpy(pframe, (unsigned char *)&le_tmp, 2);
 	pframe += 2;
 	pattrib->pktlen += 2;
 
@@ -7447,15 +7449,15 @@ void issue_assocreq(struct rtw_adapter *
 
 			if (cbw40_enable == 0) {
 				pmlmeinfo->HT_caps.u.HT_cap_element.
-				    HT_caps_info &= (~(BIT(6) | BIT(1)));
+				    HT_caps_info &= cpu_to_le16((~(BIT(6) | BIT(1))));
 			} else {
 				pmlmeinfo->HT_caps.u.HT_cap_element.
-				    HT_caps_info |= BIT(1);
+				    HT_caps_info |= cpu_to_le16(BIT(1));
 			}
 
 			/* todo: disable SM power save mode */
 			pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |=
-			    0x000c;
+			    cpu_to_le16(0x000c);
 
 			rtw_hal_get_hwreg(adapt, HW_VAR_RF_TYPE,
 					  (u8 *)(&rf_type));
@@ -7512,8 +7514,7 @@ void issue_assocreq(struct rtw_adapter *
 			       MCS_rate_1R, 16);
 #endif
 			pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info =
-			    cpu_to_le16(pmlmeinfo->HT_caps.u.HT_cap_element.
-					HT_caps_info);
+			    pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info;
 			pframe =
 			    rtw_set_ie(pframe, _HT_CAPABILITY_IE_, ie_len,
 				       (u8 *)(&(pmlmeinfo->HT_caps)),
@@ -7599,7 +7600,7 @@ void issue_assocreq(struct rtw_adapter *
 			p2pie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
 			/*      Length: */
-			*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
+			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0002);
 			p2pielen += 2;
 
 			/*      Value: */
@@ -7619,16 +7620,16 @@ void issue_assocreq(struct rtw_adapter *
 			p2pie[p2pielen++] = P2P_ATTR_EX_LISTEN_TIMING;
 
 			/*      Length: */
-			*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x0004);
+			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x0004);
 			p2pielen += 2;
 
 			/*      Value: */
 			/*      Availability Period */
-			*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
+			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 			p2pielen += 2;
 
 			/*      Availability Interval */
-			*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
+			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 			p2pielen += 2;
 
 			/*      Device Info */
@@ -7638,7 +7639,7 @@ void issue_assocreq(struct rtw_adapter *
 			/*      Length: */
 			/*      21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
 			/*      + NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
-			*(u16 *)(p2pie + p2pielen) =
+			*(__le16 *)(p2pie + p2pielen) =
 			    cpu_to_le16(21 + pwdinfo->device_name_len);
 			p2pielen += 2;
 
@@ -7652,10 +7653,10 @@ void issue_assocreq(struct rtw_adapter *
 			/*      This field should be big endian. Noted by P2P specification. */
 			if ((pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN) ||
 			    (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_SELF_DISPLAY_PIN)) {
-				*(u16 *)(p2pie + p2pielen) =
+				*(__be16 *)(p2pie + p2pielen) =
 				    cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY);
 			} else {
-				*(u16 *)(p2pie + p2pielen) =
+				*(__be16 *)(p2pie + p2pielen) =
 				    cpu_to_be16(WPS_CONFIG_METHOD_PBC);
 			}
 
@@ -7663,16 +7664,16 @@ void issue_assocreq(struct rtw_adapter *
 
 			/*      Primary Device Type */
 			/*      Category ID */
-			*(u16 *)(p2pie + p2pielen) =
+			*(__be16 *)(p2pie + p2pielen) =
 			    cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 			p2pielen += 2;
 
 			/*      OUI */
-			*(u32 *)(p2pie + p2pielen) = cpu_to_be32(WPSOUI);
+			*(__be32 *)(p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 			p2pielen += 4;
 
 			/*      Sub Category ID */
-			*(u16 *)(p2pie + p2pielen) =
+			*(__be16 *)(p2pie + p2pielen) =
 			    cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 			p2pielen += 2;
 
@@ -7681,12 +7682,12 @@ void issue_assocreq(struct rtw_adapter *
 
 			/*      Device Name */
 			/*      Type: */
-			*(u16 *)(p2pie + p2pielen) =
+			*(__be16 *)(p2pie + p2pielen) =
 			    cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 			p2pielen += 2;
 
 			/*      Length: */
-			*(u16 *)(p2pie + p2pielen) =
+			*(__be16 *)(p2pie + p2pielen) =
 			    cpu_to_be16(pwdinfo->device_name_len);
 			p2pielen += 2;
 
@@ -7700,7 +7701,7 @@ void issue_assocreq(struct rtw_adapter *
 			p2pie[p2pielen++] = P2P_ATTR_INTERFACE;
 
 			/*      Length: */
-			*(u16 *)(p2pie + p2pielen) = cpu_to_le16(0x000D);
+			*(__le16 *)(p2pie + p2pielen) = cpu_to_le16(0x000D);
 			p2pielen += 2;
 
 			/*      Value: */
@@ -8040,6 +8041,7 @@ static int _issue_deauth(struct rtw_adap
 	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	int ret = _FAIL;
+	__le16 le_tmp;
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &(adapt->wdinfo);
 #endif /* CONFIG_P2P */
@@ -8080,9 +8082,9 @@ static int _issue_deauth(struct rtw_adap
 	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
 	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 
-	reason = cpu_to_le16(reason);
+	le_tmp = cpu_to_le16(reason);
 	pframe =
-	    rtw_set_fixed_ie(pframe, _RSON_CODE_, (unsigned char *)&reason,
+	    rtw_set_fixed_ie(pframe, _RSON_CODE_, (unsigned char *)&le_tmp,
 			     &(pattrib->pktlen));
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
@@ -8240,6 +8242,7 @@ void issue_action_BA(struct rtw_adapter
 	struct sta_info *psta;
 	struct sta_priv *pstapriv = &adapt->stapriv;
 	struct registry_priv *pregpriv = &adapt->registrypriv;
+	__le16 le_tmp;
 
 	DBG_8192D("%s, category=%d, action=%d, status=%d\n", __func__, category,
 		  action, status);
@@ -8275,8 +8278,6 @@ void issue_action_BA(struct rtw_adapter
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 
-	status = cpu_to_le16(status);
-
 	if (category == 3) {
 		switch (action) {
 		case 0:	/* ADDBA req */
@@ -8289,18 +8290,18 @@ void issue_action_BA(struct rtw_adapter
 					     &(pattrib->pktlen));
 
 			BA_para_set = (0x1002 | ((status & 0xf) << 2));	/* immediate ack & 64 buffer size */
-			BA_para_set = cpu_to_le16(BA_para_set);
+			le_tmp = cpu_to_le16(BA_para_set);
 			pframe =
 			    rtw_set_fixed_ie(pframe, 2,
-					     (unsigned char *)(&(BA_para_set)),
+					     (unsigned char *)(&(le_tmp)),
 					     &(pattrib->pktlen));
 
 			BA_timeout_value = 5000;	/*  5ms */
-			BA_timeout_value = cpu_to_le16(BA_timeout_value);
+			le_tmp = cpu_to_le16(BA_timeout_value);
 			pframe =
 			    rtw_set_fixed_ie(pframe, 2,
 					     (unsigned char
-					      *)(&(BA_timeout_value)),
+					      *)(&(le_tmp)),
 					     &(pattrib->pktlen));
 
 			psta = rtw_get_stainfo(pstapriv, raddr);
@@ -8319,11 +8320,11 @@ void issue_action_BA(struct rtw_adapter
 				BA_starting_seqctrl = start_seq << 4;
 			}
 
-			BA_starting_seqctrl = cpu_to_le16(BA_starting_seqctrl);
+			le_tmp = cpu_to_le16(BA_starting_seqctrl);
 			pframe =
 			    rtw_set_fixed_ie(pframe, 2,
 					     (unsigned char
-					      *)(&(BA_starting_seqctrl)),
+					      *)(&(le_tmp)),
 					     &(pattrib->pktlen));
 			break;
 
@@ -8338,40 +8339,32 @@ void issue_action_BA(struct rtw_adapter
 					     (unsigned char *)(&status),
 					     &(pattrib->pktlen));
 
-			BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000);	/* 64 buffer size */
+			le_tmp = cpu_to_le16((pmlmeinfo->ADDBA_req.BA_para_set & 0x3f) | 0x1000);	/* 64 buffer size */
 
 			if (pregpriv->ampdu_amsdu == 0)	/* disabled */
-				BA_para_set =
-				    cpu_to_le16(BA_para_set & ~BIT(0));
+				le_tmp = cpu_to_le16(BA_para_set & ~BIT(0));
 			else if (pregpriv->ampdu_amsdu == 1)	/* enabled */
-				BA_para_set = cpu_to_le16(BA_para_set | BIT(0));
+				le_tmp = cpu_to_le16(BA_para_set | BIT(0));
 			else	/* auto */
-				BA_para_set = cpu_to_le16(BA_para_set);
+				le_tmp = cpu_to_le16(BA_para_set);
 
-			pframe =
-			    rtw_set_fixed_ie(pframe, 2,
-					     (unsigned char *)(&(BA_para_set)),
-					     &(pattrib->pktlen));
-			pframe =
-			    rtw_set_fixed_ie(pframe, 2,
-					     (unsigned char
-					      *)(&(pmlmeinfo->ADDBA_req.
-						   BA_timeout_value)),
-					     &(pattrib->pktlen));
+			pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(le_tmp)), &(pattrib->pktlen));
+			pframe = rtw_set_fixed_ie(pframe, 2,
+					     (unsigned char *)(&(pmlmeinfo->ADDBA_req.  BA_timeout_value)), &(pattrib->pktlen));
 			break;
 		case 2:	/* DELBA */
 			BA_para_set = (status & 0x1F) << 3;
-			BA_para_set = cpu_to_le16(BA_para_set);
+			le_tmp = cpu_to_le16(BA_para_set);
 			pframe =
 			    rtw_set_fixed_ie(pframe, 2,
-					     (unsigned char *)(&(BA_para_set)),
+					     (unsigned char *)(&(le_tmp)),
 					     &(pattrib->pktlen));
 
 			reason_code = 37;	/* Requested from peer STA as it does not want to use the mechanism */
-			reason_code = cpu_to_le16(reason_code);
+			le_tmp = cpu_to_le16(reason_code);
 			pframe =
 			    rtw_set_fixed_ie(pframe, 2,
-					     (unsigned char *)(&(reason_code)),
+					     (unsigned char *)(&(le_tmp)),
 					     &(pattrib->pktlen));
 			break;
 		default:
@@ -9024,6 +9017,7 @@ u8 collect_bss_info(struct rtw_adapter *
 	struct registry_priv *pregistrypriv = &adapt->registrypriv;
 	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	__le32 le32_tmp;
 
 	len = packet_len - sizeof(struct rtw_ieee80211_hdr_3addr);
 
@@ -9138,10 +9132,8 @@ u8 collect_bss_info(struct rtw_adapter *
 		}
 	}
 
-	memcpy(&bssid->Configuration.BeaconPeriod,
-	       rtw_get_beacon_interval_from_ie(bssid->IEs), 2);
-	bssid->Configuration.BeaconPeriod =
-	    le32_to_cpu(bssid->Configuration.BeaconPeriod);
+	memcpy(&le32_tmp, rtw_get_beacon_interval_from_ie(bssid->IEs), 2);
+	bssid->Configuration.BeaconPeriod = le32_to_cpu(le32_tmp);
 
 	val16 = rtw_get_capability((struct wlan_bssid_ex *)bssid);
 
@@ -9172,7 +9164,7 @@ u8 collect_bss_info(struct rtw_adapter *
 			struct HT_caps_element *pHT_caps;
 			pHT_caps = (struct HT_caps_element *)(p + 2);
 
-			if (pHT_caps->u.HT_cap_element.HT_caps_info & BIT(14))
+			if (le16_to_cpu(pHT_caps->u.HT_cap_element.HT_caps_info) & BIT(14))
 				pmlmepriv->num_FortyMHzIntolerant++;
 		} else {
 			pmlmepriv->num_sta_no_ht++;
@@ -10149,7 +10141,7 @@ void mlmeext_sta_del_event_callback(stru
 	if (is_client_associated_to_ap(adapt) || is_IBSS_empty(adapt)) {
 		/* set_opmode_cmd(adapt, infra_client_with_mlme); */
 
-		rtw_hal_set_hwreg(adapt, HW_VAR_MLME_DISCONNECT, 0);
+		rtw_hal_set_hwreg(adapt, HW_VAR_MLME_DISCONNECT, NULL);
 		rtw_hal_set_hwreg(adapt, HW_VAR_BSSID, null_addr);
 
 		/* restore to initial setting. */
@@ -10718,7 +10710,7 @@ u8 join_cmd_hdl(struct rtw_adapter *adap
 		/* Set_MSR(adapt, _HW_STATE_NOLINK_); */
 		Set_MSR(adapt, _HW_STATE_STATION_);
 
-		rtw_hal_set_hwreg(adapt, HW_VAR_MLME_DISCONNECT, 0);
+		rtw_hal_set_hwreg(adapt, HW_VAR_MLME_DISCONNECT, NULL);
 	}
 #ifdef CONFIG_ANTENNA_DIVERSITY
 	rtw_antenna_select_cmd(adapt, pparm->network.PhyInfo.Optimum_antenna,
@@ -10854,7 +10846,7 @@ u8 disconnect_hdl(struct rtw_adapter *ad
 
 	/*pmlmeinfo->state = WIFI_FW_NULL_STATE; */
 
-	rtw_hal_set_hwreg(adapt, HW_VAR_MLME_DISCONNECT, 0);
+	rtw_hal_set_hwreg(adapt, HW_VAR_MLME_DISCONNECT, NULL);
 	rtw_hal_set_hwreg(adapt, HW_VAR_BSSID, null_addr);
 
 	/* restore to initial setting. */
@@ -10981,7 +10973,7 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 
 	if (pmlmeext->sitesurvey_res.state == SCAN_DISABLE) {
 		/* for first time sitesurvey_cmd */
-		rtw_hal_set_hwreg(adapt, HW_VAR_CHECK_TXBUF, 0);
+		rtw_hal_set_hwreg(adapt, HW_VAR_CHECK_TXBUF, NULL);
 
 		pmlmeext->sitesurvey_res.state = SCAN_START;
 		pmlmeext->sitesurvey_res.bss_cnt = 0;
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -163,7 +163,7 @@ static void issue_group_disc_req(struct
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	unsigned char category = RTW_WLAN_CATEGORY_P2P;/* P2P action frame */
-	u32	p2poui = cpu_to_be32(P2POUI);
+	__be32	p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_GO_DISC_REQUEST;
 	u8 dialogToken = 0;
 
@@ -221,7 +221,7 @@ static void issue_p2p_devdisc_resp(struc
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8 action = P2P_PUB_ACTION_ACTION;
-	u32			p2poui = cpu_to_be32(P2POUI);
+	__be32 	p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_DEVDISC_RESP;
 	u8 p2pie[8] = { 0x00 };
 	u32 p2pielen = 0;
@@ -287,7 +287,7 @@ static void issue_p2p_provision_resp(str
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8 action = P2P_PUB_ACTION_ACTION;
 	u8 dialogToken = frame_body[7];	/*	The Dialog Token of provisioning discovery request frame. */
-	u32			p2poui = cpu_to_be32(P2POUI);
+	__be32 	p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_PROVISION_DISC_RESP;
 	u8 wpsie[100] = { 0x00 };
 	u8 wpsielen = 0;
@@ -382,7 +382,7 @@ static void issue_p2p_presence_resp(stru
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	unsigned char category = RTW_WLAN_CATEGORY_P2P;/* P2P action frame */
-	u32	p2poui = cpu_to_be32(P2POUI);
+	__be32	p2poui = cpu_to_be32(P2POUI);
 	u8 oui_subtype = P2P_PRESENCE_RESPONSE;
 	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
 	u8 noa_attr_content[32] = { 0x00 };
@@ -458,7 +458,7 @@ u32 build_beacon_p2p_ie(struct wifidirec
 	u8 p2pie[MAX_P2P_IE_LEN] = { 0x00 };
 	u16 capability = 0;
 	u32 len = 0, p2pielen = 0;
-
+	__le16 le_tmp;
 
 	/*	P2P OUI */
 	p2pielen = 0;
@@ -486,9 +486,9 @@ u32 build_beacon_p2p_ie(struct wifidirec
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
 		capability |= (P2P_GRPCAP_GROUP_FORMATION<<8);
 
-	capability = cpu_to_le16(capability);
+	le_tmp = cpu_to_le16(capability);
 
-	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_CAPABILITY, 2, (u8 *)&capability);
+	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_CAPABILITY, 2, (u8 *)&le_tmp);
 
 
 	/*  P2P Device ID ATTR */
@@ -2130,6 +2130,8 @@ u32 process_assoc_req_p2p_ie(struct wifi
 	u32 ies_len;
 	u8 *p2p_ie;
 	u32	p2p_ielen = 0;
+	__be16 be_tmp;
+	__le16 le_tmp;
 
 	if (!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 		return P2P_STATUS_FAIL_REQUEST_UNABLE;
@@ -2154,9 +2156,9 @@ u32 process_assoc_req_p2p_ie(struct wifi
 
 	while (p2p_ie) {
 		/* Check P2P Capability ATTR */
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&cap_attr, (uint *)&attr_contentlen)) {
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&le_tmp, (uint *)&attr_contentlen)) {
 			DBG_8192D("[%s] Got P2P Capability Attr!!\n", __func__);
-			cap_attr = le16_to_cpu(cap_attr);
+			cap_attr = le16_to_cpu(le_tmp);
 			psta->dev_cap = cap_attr&0xff;
 		}
 
@@ -2179,8 +2181,8 @@ u32 process_assoc_req_p2p_ie(struct wifi
 
 				pattr_content += ETH_ALEN;
 
-				memcpy(&psta->config_methods, pattr_content, 2);/* Config Methods */
-				psta->config_methods = be16_to_cpu(psta->config_methods);
+				memcpy(&be_tmp, pattr_content, 2);/* Config Methods */
+				psta->config_methods = be16_to_cpu(be_tmp);
 
 				pattr_content += 2;
 
@@ -2204,8 +2206,8 @@ u32 process_assoc_req_p2p_ie(struct wifi
 					pattr_content += (num_of_secdev_type*8);
 				}
 				psta->dev_name_len = 0;
-				if (WPS_ATTR_DEVICE_NAME == be16_to_cpu(*(u16 *)pattr_content)) {
-					dev_name_len = be16_to_cpu(*(u16 *)(pattr_content+2));
+				if (WPS_ATTR_DEVICE_NAME == be16_to_cpu(*(__be16 *)pattr_content)) {
+					dev_name_len = be16_to_cpu(*(__be16 *)(pattr_content+2));
 					psta->dev_name_len = (sizeof(psta->dev_name) < dev_name_len) ? sizeof(psta->dev_name) : dev_name_len;
 					memcpy(psta->dev_name, pattr_content+4, psta->dev_name_len);
 				}
@@ -2291,14 +2293,14 @@ u8 process_p2p_provdisc_req(struct wifid
 	u8 *wpsie;
 	uint	wps_ielen = 0, attr_contentlen = 0;
 	u16	uconfig_method = 0;
-
+	__be16 be_tmp;
 
 	frame_body = (pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
 
 	wpsie = rtw_get_wps_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &wps_ielen);
 	if (wpsie) {
-		if (rtw_get_wps_attr_content(wpsie, wps_ielen, WPS_ATTR_CONF_METHOD, (u8 *)&uconfig_method, &attr_contentlen)) {
-			uconfig_method = be16_to_cpu(uconfig_method);
+		if (rtw_get_wps_attr_content(wpsie, wps_ielen, WPS_ATTR_CONF_METHOD, (u8 *)&be_tmp, &attr_contentlen)) {
+			uconfig_method = be16_to_cpu(be_tmp);
 			switch (uconfig_method) {
 			case WPS_CM_DISPLYA:
 				memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis", 3);
@@ -2388,6 +2390,7 @@ u8 process_p2p_group_negotation_req(stru
 	u8 *wpsie;
 	u16		wps_devicepassword_id = 0x0000;
 	uint	wps_devicepassword_id_len = 0;
+	__be16 be_tmp;
 #ifdef CONFIG_WFD
 	u8 wfd_ie[128] = { 0x00 };
 	u32	wfd_ielen = 0;
@@ -2408,8 +2411,8 @@ u8 process_p2p_group_negotation_req(stru
 		/*	If some device wants to do p2p handshake without sending prov_disc_req */
 		/*	We have to get peer_req_cm from here. */
 		if (_rtw_memcmp(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3)) {
-			rtw_get_wps_attr_content(wpsie, wps_ielen, WPS_ATTR_DEVICE_PWID, (u8 *)&wps_devicepassword_id, &wps_devicepassword_id_len);
-			wps_devicepassword_id = be16_to_cpu(wps_devicepassword_id);
+			rtw_get_wps_attr_content(wpsie, wps_ielen, WPS_ATTR_DEVICE_PWID, (u8 *)&be_tmp, &wps_devicepassword_id_len);
+			wps_devicepassword_id = be16_to_cpu(be_tmp);
 
 			if (wps_devicepassword_id == WPS_DPID_USER_SPEC)
 				memcpy(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "dis", 3);
@@ -2452,12 +2455,13 @@ u8 process_p2p_group_negotation_req(stru
 		u8 ch_list_inclusioned[50] = { 0x00 };
 		u8 ch_num_inclusioned = 0;
 		u16	cap_attr;
+		__le16 le_tmp;
 
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);
 
 		/* Check P2P Capability ATTR */
-		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&cap_attr, (uint *)&attr_contentlen)) {
-			cap_attr = le16_to_cpu(cap_attr);
+		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&le_tmp, (uint *)&attr_contentlen)) {
+			cap_attr = le16_to_cpu(le_tmp);
 
 #if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 			if (!(cap_attr & P2P_GRPCAP_INTRABSS))
@@ -2613,11 +2617,12 @@ u8 process_p2p_group_negotation_resp(str
 		u8 peer_ch_num = 0;
 		u8 ch_list_inclusioned[50] = { 0x00 };
 		u8 ch_num_inclusioned = 0;
+		__le16 le_tmp;
 
 		while (p2p_ie) {
 			/* Check P2P Capability ATTR */
-			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&cap_attr, (uint *)&attr_contentlen)) {
-				cap_attr = le16_to_cpu(cap_attr);
+			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8 *)&le_tmp, (uint *)&attr_contentlen)) {
+				cap_attr = le16_to_cpu(le_tmp);
 #if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 			if (!(cap_attr & P2P_GRPCAP_INTRABSS))
 				ptdlsinfo->ap_prohibited = true;
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -700,6 +700,7 @@ static union recv_frame *portctrl(struct
 	u16 ether_type = 0;
 	u16 eapol_type = 0x888e;	/* for Funia BD's WPA issue */
 	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
+	__be16 be_tmp;
 
 	_func_enter_;
 
@@ -728,8 +729,8 @@ static union recv_frame *portctrl(struct
 			ptr =
 			    ptr + pfhdr->attrib.hdrlen + pfhdr->attrib.iv_len +
 			    LLC_HEADER_SIZE;
-			memcpy(&ether_type, ptr, 2);
-			ether_type = ntohs((unsigned short)ether_type);
+			memcpy(&be_tmp, ptr, 2);
+			ether_type = ntohs(be_tmp);
 
 			if (ether_type == eapol_type) {
 				prtnframe = precv_frame;
@@ -1884,6 +1885,7 @@ static int wlanhdr_to_ethhdr(union recv_
 	u8 bsnaphdr;
 	u8 *psnap_type;
 	struct ieee80211_snap_hdr *psnap;
+	__be16 be_tmp;
 
 	int ret = _SUCCESS;
 	struct rtw_adapter *adapter = precvframe->u.hdr.adapter;
@@ -1924,8 +1926,8 @@ static int wlanhdr_to_ethhdr(union recv_
 		 ("\n===pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n\n",
 		  pattrib->hdrlen, pattrib->iv_len));
 
-	memcpy(&eth_type, ptr + rmv_len, 2);
-	eth_type = ntohs((unsigned short)eth_type);	/* pattrib->ether_type */
+	memcpy(&be_tmp, ptr + rmv_len, 2);
+	eth_type = ntohs(be_tmp);	/* pattrib->ether_type */
 	pattrib->eth_type = eth_type;
 
 	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)) {
@@ -1951,8 +1953,8 @@ static int wlanhdr_to_ethhdr(union recv_
 	memcpy(ptr + ETH_ALEN, pattrib->src, ETH_ALEN);
 
 	if (!bsnaphdr) {
-		len = htons(len);
-		memcpy(ptr + 12, &len, 2);
+		be_tmp = htons(len);
+		memcpy(ptr + 12, &be_tmp, 2);
 	}
 
 	_func_exit_;
@@ -2264,7 +2266,7 @@ static int amsdu_to_msdu(struct rtw_adap
 			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst,
 			       ETH_ALEN);
 		} else {
-			u16 len;
+			__be16 len;
 			/* Leave Ethernet header part of hdr and full payload */
 			len = htons(sub_skb->len);
 			memcpy(skb_push(sub_skb, 2), &len, 2);
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -138,7 +138,7 @@ exit:
 	_func_exit_;
 }
 
-static u32 getcrc32(u8 *buf, int len)
+static __le32 getcrc32(u8 *buf, int len)
 {
 	u8 *p;
 	u32 crc;
@@ -152,7 +152,7 @@ static u32 getcrc32(u8 *buf, int len)
 	for (p = buf; len > 0; ++p, --len)
 		crc = crc32_table[(crc ^ *p) & 0xff] ^ (crc >> 8);
 	_func_exit_;
-	return ~crc;		/* transmit complement, per CRC-32 spec */
+	return cpu_to_le32(~crc);	/* transmit complement, per CRC-32 spec */
 }
 
 /*
@@ -204,8 +204,7 @@ void rtw_wep_encrypt(struct rtw_adapter
 				    pattrib->last_txcmdsz - pattrib->hdrlen -
 				    pattrib->iv_len - pattrib->icv_len;
 
-				*((unsigned long *)crc) =
-				    cpu_to_le32(getcrc32(payload, length));
+				*((__le32 *)crc) = getcrc32(payload, length);
 
 				arcfour_init(&mycontext, wepkey, 3 + keylength);
 				arcfour_encrypt(&mycontext, payload, payload,
@@ -216,8 +215,7 @@ void rtw_wep_encrypt(struct rtw_adapter
 				length =
 				    pxmitpriv->frag_len - pattrib->hdrlen -
 				    pattrib->iv_len - pattrib->icv_len;
-				*((unsigned long *)crc) =
-				    cpu_to_le32(getcrc32(payload, length));
+				*((__le32 *)crc) = getcrc32(payload, length);
 				arcfour_init(&mycontext, wepkey, 3 + keylength);
 				arcfour_encrypt(&mycontext, payload, payload,
 						length);
@@ -273,8 +271,7 @@ void rtw_wep_decrypt(struct rtw_adapter
 		arcfour_encrypt(&mycontext, payload, payload, length);
 
 		/* calculate icv and compare the icv */
-		*((unsigned long *)crc) =
-		    le32_to_cpu(getcrc32(payload, length - 4));
+		*((__le32 *)crc) = getcrc32(payload, length - 4);
 
 		if (crc[3] != payload[length - 1] ||
 		    crc[2] != payload[length - 2] ||
@@ -707,7 +704,7 @@ u32 rtw_tkip_encrypt(struct rtw_adapter
 						 ("pattrib->iv_len =%x, pattrib->icv_len =%x\n",
 						  pattrib->iv_len,
 						  pattrib->icv_len));
-					*((u32 *)crc) = cpu_to_le32(getcrc32(payload, length));	/* modified by Amy */
+					*((__le32 *)crc) = getcrc32(payload, length);	/* modified by Amy */
 
 					arcfour_init(&mycontext, rc4key, 16);
 					arcfour_encrypt(&mycontext, payload,
@@ -720,7 +717,7 @@ u32 rtw_tkip_encrypt(struct rtw_adapter
 					    pxmitpriv->frag_len -
 					    pattrib->hdrlen - pattrib->iv_len -
 					    pattrib->icv_len;
-					*((u32 *)crc) = cpu_to_le32(getcrc32(payload, length));	/* modified by Amy */
+					*((__le32 *)crc) = getcrc32(payload, length);	/* modified by Amy */
 					arcfour_init(&mycontext, rc4key, 16);
 					arcfour_encrypt(&mycontext, payload,
 							payload, length);
@@ -810,8 +807,7 @@ u32 rtw_tkip_decrypt(struct rtw_adapter
 			arcfour_init(&mycontext, rc4key, 16);
 			arcfour_encrypt(&mycontext, payload, payload, length);
 
-			*((u32 *)crc) = le32_to_cpu(getcrc32(payload,
-						    length - 4));
+			*((__le32 *)crc) = getcrc32(payload, length - 4);
 
 			if (crc[3] != payload[length - 1] ||
 			    crc[2] != payload[length - 2] ||
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ b/drivers/staging/rtl8192du/core/rtw_tdls.c
@@ -301,11 +301,11 @@ void rtw_tdls_process_ht_cap(_adapter *a
 			ptdls_sta->htpriv.ampdu_enable = true;
 
 		/* check if sta support s Short GI */
-		if (ptdls_sta->htpriv.ht_cap.cap_info & cpu_to_le16(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))
+		if (ptdls_sta->htpriv.ht_cap.cap_info & (IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))
 			ptdls_sta->htpriv.sgi = true;
 
 		/*  bwmode would still followed AP's setting */
-		if (ptdls_sta->htpriv.ht_cap.cap_info & cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH)) {
+		if (ptdls_sta->htpriv.ht_cap.cap_info & IEEE80211_HT_CAP_SUP_WIDTH) {
 			ptdls_sta->htpriv.bwmode = adapter->mlmeextpriv.cur_bwmode;
 			ptdls_sta->htpriv.ch_offset = adapter->mlmeextpriv.cur_ch_offset;
 		}
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -503,7 +503,7 @@ inline u8 *get_my_bssid(struct wlan_bssi
 
 u16 get_beacon_interval(struct wlan_bssid_ex *bss)
 {
-	unsigned short val;
+	__le16 val;
 	memcpy((unsigned char *)&val, rtw_get_beacon_interval_from_ie(bss->IEs), 2);
 
 	return le16_to_cpu(val);
@@ -662,7 +662,7 @@ void flush_all_cam_entry(struct rtw_adap
 	}
 #else /* CONFIG_CONCURRENT_MODE */
 
-	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);
+	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, NULL);
 
 #endif /* CONFIG_CONCURRENT_MODE */
 
@@ -909,8 +909,8 @@ void HT_caps_handler(struct rtw_adapter
 	/*	Commented by Albert 2010/07/12 */
 	/*	Have to handle the endian issue after copying. */
 	/*	HT_ext_caps didn't be used yet. */
-	pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info);
-	pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps = le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps);
+	pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info;
+	pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps = pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps;
 
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
@@ -1607,10 +1607,10 @@ void process_addba_req(struct rtw_adapte
 void update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len)
 {
 	u8 *pIE;
-	u32 *pbuf;
+	__le32 *pbuf;
 
 	pIE = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
-	pbuf = (u32 *)pIE;
+	pbuf = (__le32 *)pIE;
 	pmlmeext->TSFValue = le32_to_cpu(*(pbuf+1));
 	pmlmeext->TSFValue = pmlmeext->TSFValue << 32;
 	pmlmeext->TSFValue |= le32_to_cpu(*pbuf);
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -1530,7 +1530,7 @@ _func_enter_;
 	snap->oui[1] = oui[1];
 	snap->oui[2] = oui[2];
 
-	*(u16 *)(data + SNAP_SIZE) = htons(h_proto);
+	*(__be16 *)(data + SNAP_SIZE) = htons(h_proto);
 
 _func_exit_;
 
@@ -2152,14 +2152,14 @@ static int rtw_br_client_tx(struct rtw_a
 	spin_lock_bh(&padapter->br_ext_lock);
 	if (!(skb->data[0] & 1) && br_port &&
 	    memcmp(skb->data+MACADDRLEN, padapter->br_mac, MACADDRLEN) &&
-	    *((unsigned short *)(skb->data+MACADDRLEN*2)) != __constant_htons(ETH_P_8021Q) &&
-	    *((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP) &&
+	    *((__be16 *)(skb->data+MACADDRLEN*2)) != __constant_htons(ETH_P_8021Q) &&
+	    *((__be16 *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP) &&
 	    !memcmp(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN) && padapter->scdb_entry) {
 		memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
 		padapter->scdb_entry->ageing_timer = jiffies;
 		spin_unlock_bh(&padapter->br_ext_lock);
 	} else {
-		if (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_8021Q)) {
+		if (*((__be16 *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_8021Q)) {
 			is_vlan_tag = 1;
 			vlan_hdr = *((unsigned short *)(skb->data+MACADDRLEN*2+2));
 			for (i = 0; i < 6; i++)
@@ -2168,10 +2168,10 @@ static int rtw_br_client_tx(struct rtw_a
 		}
 		/* if SA == br_mac && skb == IP  => copy SIP to br_ip ?? why */
 		if (!memcmp(skb->data+MACADDRLEN, padapter->br_mac, MACADDRLEN) &&
-		    (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)))
+		    (*((__be16 *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)))
 			memcpy(padapter->br_ip, skb->data+WLAN_ETHHDR_LEN+12, 4);
 
-		if (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)) {
+		if (*((__be16 *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)) {
 			if (memcmp(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN)) {
 				padapter->scdb_entry = (struct nat25_network_db_entry *)
 						       scdb_findentry(padapter,
@@ -2202,7 +2202,7 @@ static int rtw_br_client_tx(struct rtw_a
 					skb_push(skb, 4);
 					for (i = 0; i < 6; i++)
 						*((unsigned short *)(skb->data+i*2)) = *((unsigned short *)(skb->data+4+i*2));
-					*((unsigned short *)(skb->data+MACADDRLEN*2)) = __constant_htons(ETH_P_8021Q);
+					*((__be16 *)(skb->data+MACADDRLEN*2)) = __constant_htons(ETH_P_8021Q);
 					*((unsigned short *)(skb->data+MACADDRLEN*2+2)) = vlan_hdr;
 				}
 
@@ -2252,7 +2252,7 @@ static int rtw_br_client_tx(struct rtw_a
 			skb_push(skb, 4);
 			for (i = 0; i < 6; i++)
 				*((unsigned short *)(skb->data+i*2)) = *((unsigned short *)(skb->data+4+i*2));
-			*((unsigned short *)(skb->data+MACADDRLEN*2)) = __constant_htons(ETH_P_8021Q);
+			*((__be16 *)(skb->data+MACADDRLEN*2)) = __constant_htons(ETH_P_8021Q);
 			*((unsigned short *)(skb->data+MACADDRLEN*2+2)) = vlan_hdr;
 		}
 	}
--- a/drivers/staging/rtl8192du/include/basic_types.h
+++ b/drivers/staging/rtl8192du/include/basic_types.h
@@ -90,7 +90,7 @@
 /* 		4-byte pointer in litten-endian system. */
 /*  */
 #define LE_P4BYTE_TO_HOST_4BYTE(__pStart) \
-	(EF4Byte(*((u32 *)(__pStart))))
+	(EF4Byte(*((__le32 *)(__pStart))))
 
 /*  */
 /* 	Description: */
@@ -121,7 +121,7 @@
 /* 		Set subfield of little-endian 4-byte value to specified value. */
 /*  */
 #define SET_BITS_TO_LE_4BYTE(__pStart, __BitOffset, __BitLen, __Value) \
-	*((u32 *)(__pStart)) = \
+	*((__le32 *)(__pStart)) = \
 		EF4Byte(\
 			LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
 			| \
--- a/drivers/staging/rtl8192du/include/rtw_xmit.h
+++ b/drivers/staging/rtl8192du/include/rtw_xmit.h
@@ -148,14 +148,14 @@ do{\
 
 struct tx_desc{
 	/* DWORD 0 */
-	unsigned int txdw0;
-	unsigned int txdw1;
-	unsigned int txdw2;
-	unsigned int txdw3;
-	unsigned int txdw4;
-	unsigned int txdw5;
-	unsigned int txdw6;
-	unsigned int txdw7;
+	__le32 txdw0;
+	__le32 txdw1;
+	__le32 txdw2;
+	__le32 txdw3;
+	__le32 txdw4;
+	__le32 txdw5;
+	__le32 txdw6;
+	__le32 txdw7;
 };
 
 
--- a/drivers/staging/rtl8192du/include/wifi.h
+++ b/drivers/staging/rtl8192du/include/wifi.h
@@ -242,26 +242,26 @@ enum WIFI_REG_DOMAIN {
 
 #define SetToDs(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16(_TO_DS_); \
+		*(__le16 *)(pbuf) |= cpu_to_le16(_TO_DS_); \
 	} while (0)
 
-#define GetToDs(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_TO_DS_)) != 0)
+#define GetToDs(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_TO_DS_)) != 0)
 
 #define ClearToDs(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
 	} while (0)
 
 #define SetFrDs(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16(_FROM_DS_); \
+		*(__le16 *)(pbuf) |= cpu_to_le16(_FROM_DS_); \
 	} while (0)
 
-#define GetFrDs(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_FROM_DS_)) != 0)
+#define GetFrDs(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_FROM_DS_)) != 0)
 
 #define ClearFrDs(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
 	} while (0)
 
 #define get_tofr_ds(pframe)	((GetToDs(pframe) << 1) | GetFrDs(pframe))
@@ -269,68 +269,68 @@ enum WIFI_REG_DOMAIN {
 
 #define SetMFrag(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
+		*(__le16 *)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
 	} while (0)
 
-#define GetMFrag(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_MORE_FRAG_)) != 0)
+#define GetMFrag(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_MORE_FRAG_)) != 0)
 
 #define ClearMFrag(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
 	} while (0)
 
 #define SetRetry(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16(_RETRY_); \
+		*(__le16 *)(pbuf) |= cpu_to_le16(_RETRY_); \
 	} while (0)
 
-#define GetRetry(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_RETRY_)) != 0)
+#define GetRetry(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_RETRY_)) != 0)
 
 #define ClearRetry(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
 	} while (0)
 
 #define SetPwrMgt(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16(_PWRMGT_); \
+		*(__le16 *)(pbuf) |= cpu_to_le16(_PWRMGT_); \
 	} while (0)
 
-#define GetPwrMgt(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_PWRMGT_)) != 0)
+#define GetPwrMgt(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_PWRMGT_)) != 0)
 
 #define ClearPwrMgt(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
 	} while (0)
 
 #define SetMData(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
+		*(__le16 *)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
 	} while (0)
 
-#define GetMData(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_MORE_DATA_)) != 0)
+#define GetMData(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_MORE_DATA_)) != 0)
 
 #define ClearMData(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
 	} while (0)
 
 #define SetPrivacy(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16(_PRIVACY_); \
+		*(__le16 *)(pbuf) |= cpu_to_le16(_PRIVACY_); \
 	} while (0)
 
-#define GetPrivacy(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_PRIVACY_)) != 0)
+#define GetPrivacy(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_PRIVACY_)) != 0)
 
 #define ClearPrivacy(pbuf)	\
 	do	{	\
-		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
 	} while (0)
 
 
-#define GetOrder(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
+#define GetOrder(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_ORDER_)) != 0)
 
-#define GetFrameType(pbuf)	(le16_to_cpu(*(unsigned short *)(pbuf)) & (BIT(3) | BIT(2)))
+#define GetFrameType(pbuf)	(le16_to_cpu(*(__le16 *)(pbuf)) & (BIT(3) | BIT(2)))
 
 #define SetFrameType(pbuf,type)	\
 	do {	\
@@ -338,17 +338,17 @@ enum WIFI_REG_DOMAIN {
 		*(unsigned short *)(pbuf) |= __constant_cpu_to_le16(type); \
 	} while (0)
 
-#define GetFrameSubType(pbuf)	(cpu_to_le16(*(unsigned short *)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))
+#define GetFrameSubType(pbuf)	(le16_to_cpu(*(__le16 *)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))
 
 #define SetFrameSubType(pbuf,type) \
 	do {    \
-		*(unsigned short *)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
-		*(unsigned short *)(pbuf) |= cpu_to_le16(type); \
+		*(__le16 *)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
+		*(__le16 *)(pbuf) |= cpu_to_le16(type); \
 	} while (0)
 
-#define GetSequence(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) >> 4)
+#define GetSequence(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) + 22)) >> 4)
 
-#define GetFragNum(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) & 0x0f)
+#define GetFragNum(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) + 22)) & 0x0f)
 
 #define GetTupleCache(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)))
 
@@ -361,46 +361,48 @@ enum WIFI_REG_DOMAIN {
 
 #define SetSeqNum(pbuf, num) \
 	do {    \
-		*(unsigned short *)((SIZE_PTR)(pbuf) + 22) = \
-			((*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) & le16_to_cpu((unsigned short)0x000f)) | \
-			le16_to_cpu((unsigned short)(0xfff0 & (num << 4))); \
+		*(__le16 *)((SIZE_PTR)(pbuf) + 22) = \
+			((*(__le16 *)((SIZE_PTR)(pbuf) + 22)) & cpu_to_le16((unsigned short)0x000f)) | \
+			cpu_to_le16((unsigned short)(0xfff0 & (num << 4))); \
 	} while (0)
 
 #define SetDuration(pbuf, dur) \
 	do {    \
-		*(unsigned short *)((SIZE_PTR)(pbuf) + 2) = cpu_to_le16(0xffff & (dur)); \
+		*(__le16 *)((SIZE_PTR)(pbuf) + 2) = cpu_to_le16(0xffff & (dur)); \
 	} while (0)
 
 
 #define SetPriority(pbuf, tid)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16(tid & 0xf); \
+		*(__le16 *)(pbuf) |= cpu_to_le16(tid & 0xf); \
 	} while (0)
 
-#define GetPriority(pbuf)	((le16_to_cpu(*(unsigned short *)(pbuf))) & 0xf)
+#define GetPriority(pbuf)	((le16_to_cpu(*(__le16 *)(pbuf))) & 0xf)
 
 #define SetEOSP(pbuf, eosp)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16((eosp & 1) << 4); \
+		*(__le16 *)(pbuf) |= cpu_to_le16((eosp & 1) << 4); \
 	} while (0)
 
 #define SetAckpolicy(pbuf, ack)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16((ack & 3) << 5); \
+		*(__le16 *)(pbuf) |= cpu_to_le16((ack & 3) << 5); \
 	} while (0)
 
-#define GetAckpolicy(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 5) & 0x3)
+#define GetAckpolicy(pbuf) (((le16_to_cpu(*(__le16 *)pbuf)) >> 5) & 0x3)
 
-#define GetAMsdu(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 7) & 0x1)
+#define GetAMsdu(pbuf) (((le16_to_cpu(*(__le16 *)pbuf)) >> 7) & 0x1)
 
 #define SetAMsdu(pbuf, amsdu)	\
 	do	{	\
-		*(unsigned short *)(pbuf) |= cpu_to_le16((amsdu & 1) << 7); \
+		*(__le16 *)(pbuf) |= cpu_to_le16((amsdu & 1) << 7); \
 	} while (0)
 
-#define GetAid(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 2)) & 0x3fff)
+#define GetAid(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) + 2)) & 0x3fff)
 
-#define GetTid(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + (((GetToDs(pbuf)<<1)|GetFrDs(pbuf))==3?30:24))) & 0x000f)
+#define GetTid(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) +	\
+			(((GetToDs(pbuf)<<1) | GetFrDs(pbuf)) == 3 ?	\
+			30 : 24))) & 0x000f)
 
 #define GetAddr1Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 4))
 
@@ -692,7 +694,7 @@ struct HT_caps_element
 	{
 		struct
 		{
-			unsigned short	HT_caps_info;
+			__le16	HT_caps_info;
 			unsigned char	AMPDU_para;
 			unsigned char	MCS_rate[16];
 			unsigned short	HT_ext_caps;
--- a/drivers/staging/rtl8192du/os_dep/os_intfs.c
+++ b/drivers/staging/rtl8192du/os_dep/os_intfs.c
@@ -867,11 +867,13 @@ u16 rtw_recv_select_queue(struct sk_buff
 	u16	eth_type;
 	u32 priority;
 	u8 *pdata = skb->data;
+	__be16 be_tmp;
 
-	memcpy(&eth_type, pdata+(ETH_ALEN<<1), 2);
+	memcpy(&be_tmp, pdata+(ETH_ALEN<<1), 2);
+	eth_type = be16_to_cpu(be_tmp);
 
 	switch (eth_type) {
-	case __constant_htons(ETH_P_IP):
+	case ETH_P_IP:
 		piphdr = (struct iphdr *)(pdata+ETH_HLEN);
 		dscp = piphdr->tos & 0xfc;
 		priority = dscp >> 5;

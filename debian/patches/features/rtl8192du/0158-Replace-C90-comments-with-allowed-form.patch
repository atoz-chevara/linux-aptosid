From 611c371698f8393c101b31c5be123e22d17ad897 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Tue, 14 May 2013 17:05:53 -0500
Subject: [PATCH 158/210] Replace C90 comments with allowed form

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 os_dep/ioctl_cfg80211.c |  483 ++++++++------------
 os_dep/ioctl_linux.c    | 1129 +++++++++++++++++++++--------------------------
 os_dep/mlme_linux.c     |   64 +--
 os_dep/osdep_service.c  |   13 +-
 os_dep/recv_linux.c     |   49 +-
 os_dep/rtw_android.c    |   29 +-
 os_dep/usb_intf.c       |  155 +++----
 os_dep/usb_ops_linux.c  |   86 +---
 os_dep/xmit_linux.c     |   27 +-
 9 files changed, 796 insertions(+), 1239 deletions(-)

--- a/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -33,7 +33,7 @@
 #define RTW_MAX_MGMT_TX_CNT (8)
 
 #define RTW_SCAN_IE_LEN_MAX      2304
-#define RTW_MAX_REMAIN_ON_CHANNEL_DURATION 65535 //ms
+#define RTW_MAX_REMAIN_ON_CHANNEL_DURATION 65535 /* ms */
 #define RTW_MAX_NUM_PMKIDS 4
 
 #define RTW_CH_MAX_2G_CHANNEL               14      /* Max channel in 2G band */
@@ -208,7 +208,7 @@ struct ieee80211_supported_band *rtw_spt
 		rtw_5g_rates_init(spt_band->bitrates);
 	}
 
-	//spt_band.ht_cap
+	/* spt_band.ht_cap */
 
 exit:
 
@@ -318,7 +318,6 @@ static int rtw_cfg80211_inform_bss(_adap
 	int ret=0;
 	struct ieee80211_channel *notify_channel;
 	struct cfg80211_bss *bss;
-	//struct ieee80211_supported_band *band;
 	u16 channel;
 	u32 freq;
 	u64 notify_timestamp;
@@ -338,8 +337,6 @@ static int rtw_cfg80211_inform_bss(_adap
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
 
-	//DBG_8192C("%s\n", __func__);
-
 	bssinf_len = pnetwork->network.IELength+sizeof (struct rtw_ieee80211_hdr_3addr);
 	if (bssinf_len > MAX_BSSINFO_LEN) {
 		DBG_871X("%s IE Length too long > %d byte\n",__func__,MAX_BSSINFO_LEN);
@@ -354,7 +351,6 @@ static int rtw_cfg80211_inform_bss(_adap
 
 	notify_channel = ieee80211_get_channel(wiphy, freq);
 
-	//rtw_get_timestampe_from_ie()
 	notify_timestamp = jiffies_to_msecs(jiffies)*1000; /* uSec */
 
 	notify_interval = le16_to_cpu(*(u16*)rtw_get_beacon_interval_from_ie(pnetwork->network.IEs));
@@ -364,12 +360,12 @@ static int rtw_cfg80211_inform_bss(_adap
 	notify_ie = pnetwork->network.IEs+_FIXED_IE_LENGTH_;
 	notify_ielen = pnetwork->network.IELength-_FIXED_IE_LENGTH_;
 
-	//We've set wiphy's signal_type as CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm)
+	/* We've set wiphy's signal_type as CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm) */
 	if (check_fwstate(pmlmepriv, _FW_LINKED)== true &&
 		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network)) {
-		notify_signal = 100*translate_percentage_to_dbm(padapter->recvpriv.signal_strength);//dbm
+		notify_signal = 100*translate_percentage_to_dbm(padapter->recvpriv.signal_strength);/* dbm */
 	} else {
-		notify_signal = 100*translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength);//dbm
+		notify_signal = 100*translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength);/* dbm */
 	}
 
 /*
@@ -390,9 +386,8 @@ static int rtw_cfg80211_inform_bss(_adap
 	*(fctrl) = 0;
 
 	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
-	//pmlmeext->mgnt_seq++;
 
-	if (pnetwork->network.Reserved[0] == 1) { // WIFI_BEACON
+	if (pnetwork->network.Reserved[0] == 1) { /*  WIFI_BEACON */
 		memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
 		SetFrameSubType(pbuf, WIFI_BEACON);
 	} else {
@@ -410,12 +405,7 @@ static int rtw_cfg80211_inform_bss(_adap
 	memcpy(pbuf, pnetwork->network.IEs, pnetwork->network.IELength);
 	len += pnetwork->network.IELength;
 
-	//#ifdef CONFIG_P2P
-	//if (rtw_get_p2p_ie(pnetwork->network.IEs+12, pnetwork->network.IELength-12, NULL, NULL))
-	//{
-	//	DBG_8192C("%s, got p2p_ie\n", __func__);
-	//}
-	//#endif
+	/* ifdef CONFIG_P2P */
 
 
 	bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)buf,
@@ -427,8 +417,8 @@ static int rtw_cfg80211_inform_bss(_adap
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38))
 #ifndef COMPAT_KERNEL_RELEASE
-	//patch for cfg80211, update beacon ies to information_elements
-	if (pnetwork->network.Reserved[0] == 1) { // WIFI_BEACON
+	/* patch for cfg80211, update beacon ies to information_elements */
+	if (pnetwork->network.Reserved[0] == 1) { /*  WIFI_BEACON */
 
 		 if (bss->len_information_elements != bss->len_beacon_ies)
 		 {
@@ -436,8 +426,8 @@ static int rtw_cfg80211_inform_bss(_adap
 			bss->len_information_elements =  bss->len_beacon_ies;
 		 }
 	}
-#endif //COMPAT_KERNEL_RELEASE
-#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+#endif /* COMPAT_KERNEL_RELEASE */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) */
 
 /*
 	{
@@ -494,7 +484,7 @@ void rtw_cfg80211_indicate_connect(_adap
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
 		DBG_8192C("%s, role=%d, p2p_state=%d, pre_p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo), rtw_p2p_pre_state(pwdinfo));
 	}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	#ifdef CONFIG_LAYER2_ROAMING
 	if (rtw_to_roaming(padapter) > 0) {
@@ -571,7 +561,7 @@ void rtw_cfg80211_indicate_disconnect(_a
 
 		DBG_8192C("%s, role=%d, p2p_state=%d, pre_p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo), rtw_p2p_pre_state(pwdinfo));
 	}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	if (!padapter->mlmepriv.not_indic_disco) {
 		DBG_8192C("pwdev->sme_state(b)=%d\n", pwdev->sme_state);
@@ -581,8 +571,6 @@ void rtw_cfg80211_indicate_disconnect(_a
 				WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC/*GFP_KERNEL*/);
 		else if (pwdev->sme_state==CFG80211_SME_CONNECTED)
 			cfg80211_disconnected(padapter->pnetdev, 0, NULL, 0, GFP_ATOMIC);
-		//else
-			//DBG_8192C("pwdev->sme_state=%d\n", pwdev->sme_state);
 
 		DBG_8192C("pwdev->sme_state(a)=%d\n", pwdev->sme_state);
 	}
@@ -726,8 +714,7 @@ static int rtw_cfg80211_ap_set_encryptio
 	param->u.crypt.err = 0;
 	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
 
-	//sizeof(struct ieee_param) = 64 bytes;
-	//if (param_len !=  (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
+	/* sizeof(struct ieee_param) = 64 bytes; */
 	if (param_len !=  sizeof(struct ieee_param) + param->u.crypt.key_len)
 	{
 		ret =  -EINVAL;
@@ -749,7 +736,6 @@ static int rtw_cfg80211_ap_set_encryptio
 		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
 		if (!psta)
 		{
-			//ret = -EINVAL;
 			DBG_8192C("rtw_set_encryption(), sta has already been removed or never been added\n");
 			goto exit;
 		}
@@ -757,7 +743,7 @@ static int rtw_cfg80211_ap_set_encryptio
 
 	if (strcmp(param->u.crypt.alg, "none") == 0 && (psta==NULL))
 	{
-		//todo:clear default encryption keys
+		/* todo:clear default encryption keys */
 
 		DBG_8192C("clear default encryption keys, keyid=%d\n", param->u.crypt.idx);
 
@@ -787,7 +773,7 @@ static int rtw_cfg80211_ap_set_encryptio
 
 		if (psecuritypriv->bWepDefaultKeyIdxSet == 0)
 		{
-			//wep default key has not been set, so use this key index as default key.
+			/* wep default key has not been set, so use this key index as default key. */
 
 			psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
 			psecuritypriv->dot11PrivacyAlgrthm=_WEP40_;
@@ -813,9 +799,9 @@ static int rtw_cfg80211_ap_set_encryptio
 	}
 
 
-	if (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) // //group key
+	if (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) /*  group key */
 	{
-		if (param->u.crypt.set_tx == 0) //group key
+		if (param->u.crypt.set_tx == 0) /* group key */
 		{
 			if (strcmp(param->u.crypt.alg, "WEP") == 0)
 			{
@@ -838,8 +824,7 @@ static int rtw_cfg80211_ap_set_encryptio
 
 				memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
-				//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
-				//set mic key
+				/* set mic key */
 				memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 				memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 
@@ -865,7 +850,7 @@ static int rtw_cfg80211_ap_set_encryptio
 
 			psecuritypriv->binstallGrpkey = true;
 
-			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
+			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;/*  */
 
 			set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
 
@@ -873,7 +858,7 @@ static int rtw_cfg80211_ap_set_encryptio
 			if (pbcmc_sta)
 			{
 				pbcmc_sta->ieee8021x_blocked = false;
-				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
+				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;/* rx will use bmc_sta's dot118021XPrivacy */
 			}
 
 		}
@@ -882,11 +867,11 @@ static int rtw_cfg80211_ap_set_encryptio
 
 	}
 
-	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) // psk/802_1x
+	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) /*  psk/802_1x */
 	{
 		if (check_fwstate(pmlmepriv, WIFI_AP_STATE))
 		{
-			if (param->u.crypt.set_tx ==1) //pairwise key
+			if (param->u.crypt.set_tx ==1) /* pairwise key */
 			{
 				memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
@@ -906,8 +891,7 @@ static int rtw_cfg80211_ap_set_encryptio
 
 					psta->dot118021XPrivacy = _TKIP_;
 
-					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
-					//set mic key
+					/* set mic key */
 					memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 					memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
@@ -935,7 +919,7 @@ static int rtw_cfg80211_ap_set_encryptio
 				psta->bpairwise_key_installed = true;
 
 			}
-			else//group key???
+			else/* group key??? */
 			{
 				if (strcmp(param->u.crypt.alg, "WEP") == 0)
 				{
@@ -953,8 +937,7 @@ static int rtw_cfg80211_ap_set_encryptio
 
 					memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
-					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
-					//set mic key
+					/* set mic key */
 					memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 					memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 
@@ -976,7 +959,7 @@ static int rtw_cfg80211_ap_set_encryptio
 
 				psecuritypriv->binstallGrpkey = true;
 
-				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
+				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;/*  */
 
 				set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
 
@@ -984,7 +967,7 @@ static int rtw_cfg80211_ap_set_encryptio
 				if (pbcmc_sta)
 				{
 					pbcmc_sta->ieee8021x_blocked = false;
-					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
+					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;/* rx will use bmc_sta's dot118021XPrivacy */
 				}
 
 			}
@@ -1008,7 +991,7 @@ static int rtw_cfg80211_set_encryption(s
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 #ifdef CONFIG_P2P
 	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 _func_enter_;
 
@@ -1053,7 +1036,7 @@ _func_enter_;
 
 		if (psecuritypriv->bWepDefaultKeyIdxSet == 0)
 		{
-			//wep default key has not been set, so use this key index as default key.
+			/* wep default key has not been set, so use this key index as default key. */
 
 			wep_key_len = wep_key_len <= 5 ? 5 : 13;
 
@@ -1079,23 +1062,21 @@ _func_enter_;
 		goto exit;
 	}
 
-	if (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) // 802_1x
+	if (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) /*  802_1x */
 	{
 		struct sta_info * psta,*pbcmc_sta;
 		struct sta_priv * pstapriv = &padapter->stapriv;
 
-		//DBG_8192C("%s, : dot11AuthAlgrthm == dot11AuthAlgrthm_8021X\n", __func__);
 
-		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true) //sta mode
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true) /* sta mode */
 		{
 			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
 			if (psta == NULL) {
-				//DEBUG_ERR(("Set wpa_set_encryption: Obtain Sta_info fail\n"));
 				DBG_8192C("%s, : Obtain Sta_info fail\n", __func__);
 			}
 			else
 			{
-				//Jeff: don't disable ieee8021x_blocked while clearing key
+				/* Jeff: don't disable ieee8021x_blocked while clearing key */
 				if (strcmp(param->u.crypt.alg, "none") != 0)
 					psta->ieee8021x_blocked = false;
 
@@ -1106,35 +1087,31 @@ _func_enter_;
 					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
 				}
 
-				if (param->u.crypt.set_tx ==1)//pairwise key
+				if (param->u.crypt.set_tx ==1)/* pairwise key */
 				{
 
 					DBG_8192C("%s, : param->u.crypt.set_tx ==1\n", __func__);
 
 					memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
-					if (strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
+					if (strcmp(param->u.crypt.alg, "TKIP") == 0)/* set mic key */
 					{
-						//DEBUG_ERR(("\nset key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
 						memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 						memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
 						padapter->securitypriv.busetkipkey=false;
-						//_set_timer(&padapter->securitypriv.tkip_timer, 50);
 					}
 
-					//DEBUG_ERR((" param->u.crypt.key_len=%d\n",param->u.crypt.key_len));
 					DBG_871X(" ~~~~set sta key:unicastkey\n");
 
 					rtw_setstakey_cmd(padapter, (unsigned char *)psta, true);
 				}
-				else//group key
+				else/* group key */
 				{
 					memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 					memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[16]),8);
 					memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[24]),8);
                                         padapter->securitypriv.binstallGrpkey = true;
-					//DEBUG_ERR((" param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
 					DBG_871X(" ~~~~set sta key:groupkey\n");
 
 					padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
@@ -1145,7 +1122,7 @@ _func_enter_;
 					{
 						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_DONE);
 					}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 				}
 			}
@@ -1153,11 +1130,10 @@ _func_enter_;
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
 			if (pbcmc_sta==NULL)
 			{
-				//DEBUG_ERR(("Set OID_802_11_ADD_KEY: bcmc stainfo is null\n"));
 			}
 			else
 			{
-				//Jeff: don't disable ieee8021x_blocked while clearing key
+				/* Jeff: don't disable ieee8021x_blocked while clearing key */
 				if (strcmp(param->u.crypt.alg, "none") != 0)
 					pbcmc_sta->ieee8021x_blocked = false;
 
@@ -1168,7 +1144,7 @@ _func_enter_;
 				}
 			}
 		}
-		else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
+		else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) /* adhoc mode */
 		{
 		}
 	}
@@ -1185,9 +1161,9 @@ exit:
 static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 				u8 key_index, bool pairwise, const u8 *mac_addr,
-#else	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+#else	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
 				u8 key_index, const u8 *mac_addr,
-#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+#endif	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
 				struct key_params *params)
 {
 	char *alg_name;
@@ -1205,7 +1181,7 @@ static int cfg80211_rtw_add_key(struct w
 	DBG_871X("key_index=%d\n", key_index);
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	DBG_871X("pairwise=%d\n", pairwise);
-#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+#endif	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
 
 	param_len = sizeof(struct ieee_param) + params->key_len;
 	param = (struct ieee_param *)rtw_malloc(param_len);
@@ -1219,8 +1195,8 @@ static int cfg80211_rtw_add_key(struct w
 
 	switch (params->cipher) {
 	case IW_AUTH_CIPHER_NONE:
-		//todo: remove key
-		//remove = 1;
+		/* todo: remove key */
+		/* remove = 1; */
 		alg_name = "none";
 		break;
 	case WLAN_CIPHER_SUITE_WEP40:
@@ -1242,13 +1218,12 @@ static int cfg80211_rtw_add_key(struct w
 
 	if (!mac_addr || is_broadcast_ether_addr(mac_addr))
 	{
-		param->u.crypt.set_tx = 0; //for wpa/wpa2 group key
+		param->u.crypt.set_tx = 0; /* for wpa/wpa2 group key */
 	} else {
-		param->u.crypt.set_tx = 1; //for wpa/wpa2 pairwise key
+		param->u.crypt.set_tx = 1; /* for wpa/wpa2 pairwise key */
 	}
 
 
-	//param->u.crypt.idx = key_index - 1;
 	param->u.crypt.idx = key_index;
 
 	if (params->seq_len && params->seq)
@@ -1287,9 +1262,9 @@ static int cfg80211_rtw_add_key(struct w
 static int cfg80211_rtw_get_key(struct wiphy *wiphy, struct net_device *ndev,
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 				u8 key_index, bool pairwise, const u8 *mac_addr,
-#else	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+#else	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
 				u8 key_index, const u8 *mac_addr,
-#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+#endif	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
 				void *cookie,
 				void (*callback)(void *cookie,
 						 struct key_params*))
@@ -1301,9 +1276,9 @@ static int cfg80211_rtw_get_key(struct w
 static int cfg80211_rtw_del_key(struct wiphy *wiphy, struct net_device *ndev,
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 				u8 key_index, bool pairwise, const u8 *mac_addr)
-#else	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+#else	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
 				u8 key_index, const u8 *mac_addr)
-#endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+#endif	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
@@ -1312,7 +1287,7 @@ static int cfg80211_rtw_del_key(struct w
 
 	if (key_index == psecuritypriv->dot11PrivacyKeyIndex)
 	{
-		//clear the flag of wep default key set.
+		/* clear the flag of wep default key set. */
 		psecuritypriv->bWepDefaultKeyIdxSet = 0;
 	}
 
@@ -1339,7 +1314,7 @@ static int cfg80211_rtw_set_default_key(
 		#endif
 		);
 
-	if ((key_index < WEP_KEYS) && ((psecuritypriv->dot11PrivacyAlgrthm == _WEP40_) || (psecuritypriv->dot11PrivacyAlgrthm == _WEP104_))) //set wep default key
+	if ((key_index < WEP_KEYS) && ((psecuritypriv->dot11PrivacyAlgrthm == _WEP40_) || (psecuritypriv->dot11PrivacyAlgrthm == _WEP104_))) /* set wep default key */
 	{
 		psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
 
@@ -1353,7 +1328,7 @@ static int cfg80211_rtw_set_default_key(
 			psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
 		}
 
-		psecuritypriv->bWepDefaultKeyIdxSet = 1; //set the flag to represent that wep default key has been set
+		psecuritypriv->bWepDefaultKeyIdxSet = 1; /* set the flag to represent that wep default key has been set */
 	}
 
 	return 0;
@@ -1388,7 +1363,7 @@ static int cfg80211_rtw_get_station(stru
 	DBG_871X(FUNC_NDEV_FMT" mac=%pM\n", FUNC_NDEV_ARG(ndev), mac);
 #endif
 
-	//for infra./P2PClient mode
+	/* for infra./P2PClient mode */
 	if (	check_fwstate(pmlmepriv, WIFI_STATION_STATE)
 		&& check_fwstate(pmlmepriv, _FW_LINKED)
 	)
@@ -1415,14 +1390,14 @@ static int cfg80211_rtw_get_station(stru
 
 	}
 
-	//for Ad-Hoc/AP mode
+	/* for Ad-Hoc/AP mode */
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)
 			||check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)
 			||check_fwstate(pmlmepriv, WIFI_AP_STATE))
 		&& check_fwstate(pmlmepriv, _FW_LINKED)
 	)
 	{
-		//TODO: should acquire station info...
+		/* TODO: should acquire station info... */
 	}
 
 exit:
@@ -1434,23 +1409,6 @@ extern int netdev_open(struct net_device
 extern int netdev_if2_open(struct net_device *pnetdev);
 #endif
 
-/*
-enum nl80211_iftype {
-	NL80211_IFTYPE_UNSPECIFIED,
-       NL80211_IFTYPE_ADHOC, //1
-       NL80211_IFTYPE_STATION, //2
-       NL80211_IFTYPE_AP, //3
-       NL80211_IFTYPE_AP_VLAN,
-       NL80211_IFTYPE_WDS,
-       NL80211_IFTYPE_MONITOR, //6
-       NL80211_IFTYPE_MESH_POINT,
-       NL80211_IFTYPE_P2P_CLIENT, //8
-	NL80211_IFTYPE_P2P_GO, //9
-       //keep last
-       NUM_NL80211_IFTYPES,
-       NL80211_IFTYPE_MAX = NUM_NL80211_IFTYPES - 1
-};
-*/
 static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
 				     struct net_device *ndev,
 				     enum nl80211_iftype type, u32 *flags,
@@ -1479,7 +1437,7 @@ static int cfg80211_rtw_change_iface(str
 		}
 	}
 	else if (padapter->adapter_type == PRIMARY_ADAPTER)
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 	{
 		DBG_871X(FUNC_NDEV_FMT" call netdev_open\n", FUNC_NDEV_ARG(ndev));
 		if (netdev_open(ndev) != 0) {
@@ -1520,13 +1478,13 @@ static int cfg80211_rtw_change_iface(str
 			_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
 			_cancel_timer_ex(&pwdinfo->pre_tx_scan_timer);
 
-			//it means remove GO and change mode from AP(GO) to station(P2P DEVICE)
+			/* it means remove GO and change mode from AP(GO) to station(P2P DEVICE) */
 			rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
 			rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
 
 			DBG_8192C("%s, role=%d, p2p_state=%d, pre_p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo), rtw_p2p_pre_state(pwdinfo));
 		}
-		#endif //CONFIG_P2P
+		#endif /* CONFIG_P2P */
 		break;
 #if defined(CONFIG_P2P) && ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE))
 	case NL80211_IFTYPE_P2P_GO:
@@ -1536,10 +1494,10 @@ static int cfg80211_rtw_change_iface(str
 		#ifdef CONFIG_P2P
 		if (change && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
-			//it means P2P Group created, we will be GO and change mode from  P2P DEVICE to AP(GO)
+			/* it means P2P Group created, we will be GO and change mode from  P2P DEVICE to AP(GO) */
 			rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
 		}
-		#endif //CONFIG_P2P
+		#endif /* CONFIG_P2P */
 		break;
 	default:
 		return -EOPNOTSUPP;
@@ -1574,14 +1532,11 @@ void rtw_cfg80211_indicate_scan_done(str
 	spin_lock_bh(&pwdev_priv->scan_req_lock);
 	if (pwdev_priv->scan_request != NULL)
 	{
-		//struct cfg80211_scan_request *scan_request = pwdev_priv->scan_request;
-
 		#ifdef CONFIG_DEBUG_CFG80211
 		DBG_871X("%s with scan req\n", __func__);
 		#endif
 
-		//avoid WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req);
-		//if (scan_request == wiphy_to_dev(scan_request->wiphy)->scan_req)
+		/* avoid WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req); */
 		if (pwdev_priv->scan_request->wiphy != pwdev_priv->rtw_wdev->wiphy)
 		{
 			DBG_8192C("error wiphy compare\n");
@@ -1612,7 +1567,7 @@ void rtw_cfg80211_surveydone_event_callb
 	int wait_status;
 #ifdef CONFIG_P2P
 	struct	wifidirect_info*	pwdinfo = &padapter->wdinfo;
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 
@@ -1632,14 +1587,14 @@ void rtw_cfg80211_surveydone_event_callb
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		//report network only if the current channel set contains the channel to which this network belongs
+		/* report network only if the current channel set contains the channel to which this network belongs */
 		if (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
 			#ifdef CONFIG_VALIDATE_SSID
 			&& true == rtw_validate_ssid(&(pnetwork->network.Ssid))
 			#endif
 		)
 		{
-			//ev=translate_scan(padapter, a, pnetwork, ev, stop);
+			/* ev=translate_scan(padapter, a, pnetwork, ev, stop); */
 			rtw_cfg80211_inform_bss(padapter, pnetwork);
 		}
 
@@ -1649,7 +1604,7 @@ void rtw_cfg80211_surveydone_event_callb
 
 	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 
-	//call this after other things have been done
+	/* call this after other things have been done */
 	rtw_cfg80211_indicate_scan_done(wdev_to_priv(padapter->rtw_wdev), false);
 }
 
@@ -1694,9 +1649,6 @@ static int rtw_cfg80211_set_probe_req_wp
 			pmlmepriv->wps_probe_req_ie_len = wps_ielen;
 		}
 
-		//buf += wps_ielen;
-		//len -= wps_ielen;
-
 		#ifdef CONFIG_P2P
 		if ((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
 		{
@@ -1721,10 +1673,7 @@ static int rtw_cfg80211_set_probe_req_wp
 			memcpy(pmlmepriv->p2p_probe_req_ie, p2p_ie, p2p_ielen);
 			pmlmepriv->p2p_probe_req_ie_len = p2p_ielen;
 		}
-		#endif //CONFIG_P2P
-
-		//buf += p2p_ielen;
-		//len -= p2p_ielen;
+		#endif /* CONFIG_P2P */
 
 		#ifdef CONFIG_WFD
 		if (rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
@@ -1749,7 +1698,7 @@ static int rtw_cfg80211_set_probe_req_wp
 			}
 			rtw_get_wfd_ie(buf, len, pmlmepriv->wfd_probe_req_ie, &pmlmepriv->wfd_probe_req_ie_len);
 		}
-		#endif //CONFIG_WFD
+		#endif /* CONFIG_WFD */
 
 	}
 
@@ -1775,7 +1724,7 @@ static int cfg80211_rtw_scan(struct wiph
 	uint p2p_ielen=0;
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 	struct cfg80211_ssid *ssids = request->ssids;
 	int social_channel = 0, j = 0;
@@ -1783,7 +1732,7 @@ static int cfg80211_rtw_scan(struct wiph
 #ifdef CONFIG_CONCURRENT_MODE
 	PADAPTER pbuddy_adapter = NULL;
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 #ifdef CONFIG_DEBUG_CFG80211
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
@@ -1795,7 +1744,7 @@ static int cfg80211_rtw_scan(struct wiph
 		pbuddy_adapter = padapter->pbuddy_adapter;
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 	}
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 	spin_lock_bh(&pwdev_priv->scan_req_lock);
 	pwdev_priv->scan_request = request;
@@ -1807,8 +1756,6 @@ static int cfg80211_rtw_scan(struct wiph
 #ifdef CONFIG_DEBUG_CFG80211
 		DBG_871X("%s under WIFI_AP_STATE\n", __func__);
 #endif
-		//need_indicate_scan_done = true;
-		//goto check_need_indicate_scan_done;
 	}
 
 	if (_FAIL == rtw_pwr_wakeup(padapter)) {
@@ -1845,7 +1792,7 @@ static int cfg80211_rtw_scan(struct wiph
 			social_channel = 1;
 		}
 	}
-	#endif //CONFIG_P2P
+	#endif /* CONFIG_P2P */
 
 	if (request->ie && request->ie_len>0)
 	{
@@ -1871,7 +1818,7 @@ static int cfg80211_rtw_scan(struct wiph
 		need_indicate_scan_done = true;
 		goto check_need_indicate_scan_done;
 	}
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
 	{
@@ -1909,11 +1856,11 @@ static int cfg80211_rtw_scan(struct wiph
 		else
 			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_SOCIAL_LAST);
 	}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 
 	memset(ssid, 0, sizeof(struct ndis_802_11_ssid)*RTW_SSID_SCAN_AMOUNT);
-	//parsing request ssids, n_ssids
+	/* parsing request ssids, n_ssids */
 	for (i = 0; i < request->n_ssids && i < RTW_SSID_SCAN_AMOUNT; i++) {
 		#ifdef CONFIG_DEBUG_CFG80211
 		DBG_8192C("ssid=%s, len=%d\n", ssids[i].ssid, ssids[i].ssid_len);
@@ -2033,7 +1980,7 @@ static int rtw_cfg80211_set_auth_type(st
 		break;
 	default:
 		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
-		//return -ENOTSUPP;
+		/* return -ENOTSUPP; */
 	}
 
 	return 0;
@@ -2082,13 +2029,8 @@ static int rtw_cfg80211_set_cipher(struc
 	}
 
 	if (ucast)
-	{
 		psecuritypriv->ndisencryptstatus = ndisencryptstatus;
 
-		//if (psecuritypriv->dot11PrivacyAlgrthm >= _AES_)
-		//	psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPA2PSK;
-	}
-
 	return 0;
 }
 
@@ -2097,13 +2039,11 @@ static int rtw_cfg80211_set_key_mgt(stru
 	DBG_8192C("%s, key_mgt=0x%x\n", __func__, key_mgt);
 
 	if (key_mgt == WLAN_AKM_SUITE_8021X)
-		//*auth_type = UMAC_AUTH_TYPE_8021X;
 		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
 	else if (key_mgt == WLAN_AKM_SUITE_PSK) {
 		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
 	} else {
 		DBG_8192C("Invalid key mgt: 0x%x\n", key_mgt);
-		//return -EINVAL;
 	}
 
 	return 0;
@@ -2139,7 +2079,7 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 
 	memcpy(buf, pie , ielen);
 
-	//dump
+	/* dump */
 	{
 		int i;
 		DBG_8192C("set wpa_ie(length:%zu):\n", ielen);
@@ -2253,7 +2193,7 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 	}
 
 	#ifdef CONFIG_P2P
-	{//check p2p_ie for assoc req;
+	{/* check p2p_ie for assoc req; */
 		uint p2p_ielen=0;
 		u8 *p2p_ie;
 		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -2281,10 +2221,10 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 			pmlmepriv->p2p_assoc_req_ie_len = p2p_ielen;
 		}
 	}
-	#endif //CONFIG_P2P
+	#endif /* CONFIG_P2P */
 
 	#ifdef CONFIG_WFD
-	{//check wfd_ie for assoc req;
+	{/* check wfd_ie for assoc req; */
 		uint wfd_ielen=0;
 		u8 *wfd_ie;
 		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -2311,14 +2251,13 @@ static int rtw_cfg80211_set_wpa_ie(_adap
 			rtw_get_wfd_ie(buf, ielen, pmlmepriv->wfd_assoc_req_ie, &pmlmepriv->wfd_assoc_req_ie_len);
 		}
 	}
-	#endif //CONFIG_WFD
+	#endif /* CONFIG_WFD */
 
-	//TKIP and AES disallow multicast packets until installing group key
+	/* TKIP and AES disallow multicast packets until installing group key */
 	if (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
-		//WPS open need to enable multicast
-		//|| check_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS) == true)
+		/* WPS open need to enable multicast */
 		rtw_hal_set_hwreg(padapter, HW_VAR_OFF_RCR_AM, null_addr);
 
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
@@ -2343,8 +2282,6 @@ static int cfg80211_rtw_connect(struct w
 	struct ndis_802_11_ssid ndis_ssid;
 	u8 *dst_ssid, *src_ssid;
 	u8 *dst_bssid, *src_bssid;
-	//u8 matched_by_bssid=false;
-	//u8 matched_by_ssid=false;
 	u8 matched=false;
 	_adapter *padapter = wiphy_to_adapter(wiphy);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -2503,7 +2440,7 @@ static int cfg80211_rtw_connect(struct w
 	psecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;
 	psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
 	psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
-	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; //open system
+	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
 	psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;
 
 
@@ -2527,7 +2464,7 @@ static int cfg80211_rtw_connect(struct w
 			goto exit;
 	}
 
-	//For WEP Shared auth
+	/* For WEP Shared auth */
 	if ((psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Shared
 		|| psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Auto) && sme->key
 	)
@@ -2599,8 +2536,6 @@ static int cfg80211_rtw_connect(struct w
 	authmode = psecuritypriv->ndisauthtype;
 	rtw_set_802_11_authentication_mode(padapter, authmode);
 
-	//rtw_set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
-
 	if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == false) {
 		ret = -1;
 		goto exit;
@@ -2712,11 +2647,11 @@ static int cfg80211_rtw_set_pmksa(struct
 
 	blInserted = false;
 
-	//overwrite PMKID
+	/* overwrite PMKID */
 	for (index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
 		if (_rtw_memcmp(psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==true)
-		{ // BSSID is matched, the same AP => rewrite with new PMKID.
+		{ /*  BSSID is matched, the same AP => rewrite with new PMKID. */
 			DBG_871X(FUNC_NDEV_FMT" BSSID exists in the PMKList.\n", FUNC_NDEV_ARG(netdev));
 
 			memcpy(psecuritypriv->PMKIDList[index].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
@@ -2729,7 +2664,7 @@ static int cfg80211_rtw_set_pmksa(struct
 
 	if (!blInserted)
 	{
-		// Find a new entry
+		/*  Find a new entry */
 		DBG_871X(FUNC_NDEV_FMT" Use the new entry index = %d for this PMKID.\n",
 			FUNC_NDEV_ARG(netdev), psecuritypriv->PMKIDIndex);
 
@@ -2760,7 +2695,7 @@ static int cfg80211_rtw_del_pmksa(struct
 	for (index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
 		if (_rtw_memcmp(psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==true)
-		{ // BSSID is matched, the same AP => Remove this PMKID information and reset it.
+		{ /*  BSSID is matched, the same AP => Remove this PMKID information and reset it. */
 			memset(psecuritypriv->PMKIDList[index].Bssid, 0x00, ETH_ALEN);
 			memset(psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN);
 			psecuritypriv->PMKIDList[index].bUsed = false;
@@ -2810,7 +2745,7 @@ void rtw_cfg80211_indicate_sta_assoc(_ad
 		u8 ie_offset;
 		if (GetFrameSubType(pmgmt_frame) == WIFI_ASSOCREQ)
 			ie_offset = _ASOCREQ_IE_OFFSET_;
-		else // WIFI_REASSOCREQ
+		else /*  WIFI_REASSOCREQ */
 			ie_offset = _REASOCREQ_IE_OFFSET_;
 
 		sinfo.filled = 0;
@@ -2830,16 +2765,16 @@ void rtw_cfg80211_indicate_sta_assoc(_ad
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
 	#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
-	#else //COMPAT_KERNEL_RELEASE
+	#else /* COMPAT_KERNEL_RELEASE */
 	{
-		//to avoid WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION)  when calling cfg80211_send_rx_assoc()
+		/* to avoid WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION)  when calling cfg80211_send_rx_assoc() */
 		pwdev->iftype = NL80211_IFTYPE_STATION;
 		DBG_8192C("iftype=%d before call cfg80211_send_rx_assoc()\n", pwdev->iftype);
 		rtw_cfg80211_send_rx_assoc(padapter, NULL, pmgmt_frame, frame_len);
 		DBG_8192C("iftype=%d after call cfg80211_send_rx_assoc()\n", pwdev->iftype);
 		pwdev->iftype = NL80211_IFTYPE_AP;
 	}
-	#endif //COMPAT_KERNEL_RELEASE
+	#endif /* COMPAT_KERNEL_RELEASE */
 #endif /* defined(RTW_USE_CFG80211_STA_EVENT) */
 }
 
@@ -2873,8 +2808,6 @@ void rtw_cfg80211_indicate_sta_disassoc(
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
 
-	//memcpy(pwlanhdr->addr1, da, ETH_ALEN);
-	//memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
 	memcpy(pwlanhdr->addr1, myid(&(padapter->eeprompriv)), ETH_ALEN);
 	memcpy(pwlanhdr->addr2, da, ETH_ALEN);
 	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
@@ -2893,10 +2826,9 @@ void rtw_cfg80211_indicate_sta_disassoc(
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, mgmt_buf, frame_len, GFP_ATOMIC);
 	#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, mgmt_buf, frame_len, GFP_ATOMIC);
-	#else //COMPAT_KERNEL_RELEASE
+	#else /* COMPAT_KERNEL_RELEASE */
 	cfg80211_send_disassoc(padapter->pnetdev, mgmt_buf, frame_len);
-	//cfg80211_rx_action(padapter->pnetdev, freq, mgmt_buf, frame_len, GFP_ATOMIC);
-	#endif //COMPAT_KERNEL_RELEASE
+	#endif /* COMPAT_KERNEL_RELEASE */
 #endif /* defined(RTW_USE_CFG80211_STA_EVENT) */
 }
 
@@ -2990,12 +2922,10 @@ static int rtw_cfg80211_monitor_if_xmit_
 		== (RTW_IEEE80211_FTYPE_MGMT|RTW_IEEE80211_STYPE_ACTION)
 	)
 	{
-		//only for action frames
+		/* only for action frames */
 		struct xmit_frame		*pmgntframe;
 		struct pkt_attrib	*pattrib;
 		unsigned char	*pframe;
-		//u8 category, action, OUI_Subtype, dialogToken=0;
-		//unsigned char	*frame_body;
 		struct rtw_ieee80211_hdr *pwlanhdr;
 		struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 		struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
@@ -3022,13 +2952,13 @@ static int rtw_cfg80211_monitor_if_xmit_
 			DBG_871X("RTW_Tx:category(%u), action(%u)\n", category, action);
 
 dump:
-		//starting alloc mgmt frame to dump it
+		/* starting alloc mgmt frame to dump it */
 		if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 		{
 			goto fail;
 		}
 
-		//update attribute
+		/* update attribute */
 		pattrib = &pmgntframe->attrib;
 		update_mgntframe_attrib(padapter, pattrib);
 		pattrib->retry_ctrl = false;
@@ -3050,11 +2980,11 @@ dump:
 				rtw_append_wfd_ie(padapter, pframe, &len);
 			}
 		}
-		#endif // CONFIG_WFD
+		#endif /*  CONFIG_WFD */
 		pattrib->pktlen = len;
 
 		pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
-		//update seq number
+		/* update seq number */
 		pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
 		pattrib->seqnum = pmlmeext->mgnt_seq;
 		pmlmeext->mgnt_seq++;
@@ -3287,8 +3217,6 @@ static int rtw_add_beacon(_adapter *adap
 	u8 *p2p_ie;
 	u8 got_p2p_ie = false;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
-	//struct sta_priv *pstapriv = &padapter->stapriv;
-
 
 	DBG_8192C("%s beacon_head_len=%zu, beacon_tail_len=%zu\n", __func__, head_len, tail_len);
 
@@ -3304,24 +3232,17 @@ static int rtw_add_beacon(_adapter *adap
 	if (!pbuf)
 		return -ENOMEM;
 
-
-	//memcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);
-
-	//if ((pstapriv->max_num_sta>NUM_STA) || (pstapriv->max_num_sta<=0))
-	//	pstapriv->max_num_sta = NUM_STA;
-
-
-	memcpy(pbuf, (void *)head+24, head_len-24);// 24=beacon header len.
+	memcpy(pbuf, (void *)head+24, head_len-24);/*  24=beacon header len. */
 	memcpy(pbuf+head_len-24, (void *)tail, tail_len);
 
 	len = head_len+tail_len-24;
 
-	//check wps ie if inclued
+	/* check wps ie if inclued */
 	if (rtw_get_wps_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &wps_ielen))
 		DBG_8192C("add bcn, wps_ielen=%d\n", wps_ielen);
 
 #ifdef CONFIG_P2P
-	//check p2p ie if inclued
+	/* check p2p ie if inclued */
 	if (rtw_get_p2p_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &p2p_ielen))
 	{
 		DBG_8192C("got p2p_ie, len=%d\n", p2p_ielen);
@@ -3331,12 +3252,11 @@ static int rtw_add_beacon(_adapter *adap
 
 	rtw_ies_remove_ie(pbuf, &len, _BEACON_IE_OFFSET_, _VENDOR_SPECIFIC_IE_, P2P_OUI, 4);
 
-	// pbss_network->IEs will not include p2p_ie
+	/*  pbss_network->IEs will not include p2p_ie */
 	if (rtw_check_beacon_data(adapter, pbuf,  len) == _SUCCESS)
-	//if (rtw_check_beacon_data(padapter, pbuf,  len) == _SUCCESS)
 	{
 #ifdef  CONFIG_P2P
-		//check p2p if enable
+		/* check p2p if enable */
 		if (got_p2p_ie == true)
 		{
 			struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
@@ -3364,7 +3284,7 @@ static int rtw_add_beacon(_adapter *adap
 			pwdinfo->operating_channel = pmlmeext->cur_channel;
 
 		}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 		ret = 0;
 
@@ -3461,7 +3381,7 @@ static int cfg80211_rtw_stop_ap(struct w
 	return 0;
 }
 
-#endif //(LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)) */
 
 static int	cfg80211_rtw_add_station(struct wiphy *wiphy, struct net_device *ndev,
 			       u8 *mac, struct station_parameters *params)
@@ -3495,7 +3415,7 @@ static int	cfg80211_rtw_del_station(stru
 	{
 		DBG_8192C("flush all sta, and cam_entry\n");
 
-		flush_all_cam_entry(padapter);	//clear CAM
+		flush_all_cam_entry(padapter);	/* clear CAM */
 
 		ret = rtw_sta_flush(padapter);
 
@@ -3518,7 +3438,7 @@ static int	cfg80211_rtw_del_station(stru
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
-	//check asoc_queue
+	/* check asoc_queue */
 	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
@@ -3538,9 +3458,7 @@ static int	cfg80211_rtw_del_station(stru
 				rtw_list_delete(&psta->asoc_list);
 				pstapriv->asoc_list_cnt--;
 
-				//spin_unlock_bh(&pstapriv->asoc_list_lock);
 				updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
-				//spin_lock_bh(&pstapriv->asoc_list_lock);
 
 				psta = NULL;
 
@@ -3573,7 +3491,7 @@ static int	cfg80211_rtw_dump_station(str
 {
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
-	//TODO: dump scanned queue
+	/* TODO: dump scanned queue */
 
 	return -ENOENT;
 }
@@ -3584,19 +3502,6 @@ static int	cfg80211_rtw_change_bss(struc
 	u8 i;
 
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-/*
-	DBG_8192C("use_cts_prot=%d\n", params->use_cts_prot);
-	DBG_8192C("use_short_preamble=%d\n", params->use_short_preamble);
-	DBG_8192C("use_short_slot_time=%d\n", params->use_short_slot_time);
-	DBG_8192C("ap_isolate=%d\n", params->ap_isolate);
-
-	DBG_8192C("basic_rates_len=%d\n", params->basic_rates_len);
-	for (i=0; i<params->basic_rates_len; i++)
-	{
-		DBG_8192C("basic_rates=%d\n", params->basic_rates[i]);
-
-	}
-*/
 	return 0;
 }
 
@@ -3628,7 +3533,7 @@ static int	cfg80211_rtw_assoc(struct wip
 
 	return 0;
 }
-#endif //CONFIG_AP_MODE
+#endif /* CONFIG_AP_MODE */
 
 void rtw_cfg80211_rx_action_p2p(_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
 {
@@ -3751,7 +3656,7 @@ void rtw_cfg80211_issue_p2p_provision_re
 	u32			p2pielen = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
@@ -3769,7 +3674,7 @@ void rtw_cfg80211_issue_p2p_provision_re
 
 	DBG_871X("[%s] In\n", __func__);
 
-	//prepare for building provision_request frame
+	/* prepare for building provision_request frame */
 	memcpy(pwdinfo->tx_prov_disc_info.peerIFAddr, GetAddr1Ptr(buf), ETH_ALEN);
 	memcpy(pwdinfo->tx_prov_disc_info.peerDevAddr, GetAddr1Ptr(buf), ETH_ALEN);
 
@@ -3811,7 +3716,7 @@ void rtw_cfg80211_issue_p2p_provision_re
 	}
 
 
-	//start to build provision_request frame
+	/* start to build provision_request frame */
 	memset(wpsie, 0, sizeof(wpsie));
 	memset(p2p_ie, 0, sizeof(p2p_ie));
 	p2p_ielen = 0;
@@ -3822,7 +3727,7 @@ void rtw_cfg80211_issue_p2p_provision_re
 	}
 
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -3852,84 +3757,80 @@ void rtw_cfg80211_issue_p2p_provision_re
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
 
-	//build_prov_disc_request_p2p_ie
-	//	P2P OUI
+	/* build_prov_disc_request_p2p_ie */
+	/* 	P2P OUI */
 	p2pielen = 0;
 	p2p_ie[p2pielen++] = 0x50;
 	p2p_ie[p2pielen++] = 0x6F;
 	p2p_ie[p2pielen++] = 0x9A;
-	p2p_ie[p2pielen++] = 0x09;	//	WFA P2P v1.0
+	p2p_ie[p2pielen++] = 0x09;	/* 	WFA P2P v1.0 */
 
-	//	Commented by Albert 20110301
-	//	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes
-	//	1. P2P Capability
-	//	2. Device Info
-	//	3. Group ID (When joining an operating P2P Group)
+	/* 	Commented by Albert 20110301 */
+	/* 	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes */
+	/* 	1. P2P Capability */
+	/* 	2. Device Info */
+	/* 	3. Group ID (When joining an operating P2P Group) */
 
-	//	P2P Capability ATTR
-	//	Type:
+	/* 	P2P Capability ATTR */
+	/* 	Type: */
 	p2p_ie[p2pielen++] = P2P_ATTR_CAPABILITY;
 
-	//	Length:
-	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
+	/* 	Length: */
 	RTW_PUT_LE16(p2p_ie + p2pielen, 0x0002);
 	p2pielen += 2;
 
-	//	Value:
-	//	Device Capability Bitmap, 1 byte
-	//	Group Capability Bitmap, 1 byte
+	/* 	Value: */
+	/* 	Device Capability Bitmap, 1 byte */
+	/* 	Group Capability Bitmap, 1 byte */
 	memcpy(p2p_ie + p2pielen, &capability, 2);
 	p2pielen += 2;
 
 
-	//	Device Info ATTR
-	//	Type:
+	/* 	Device Info ATTR */
+	/* 	Type: */
 	p2p_ie[p2pielen++] = P2P_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
-	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
-	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
+	/* 	Length: */
+	/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
+	/* 	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
 	RTW_PUT_LE16(p2p_ie + p2pielen, devinfo_contentlen);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	memcpy(p2p_ie + p2pielen, devinfo_content, devinfo_contentlen);
 	p2pielen += devinfo_contentlen;
 
 
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2p_ie, &p2p_ielen);
-	//p2pielen = build_prov_disc_request_p2p_ie(pwdinfo, pframe, NULL, 0, pwdinfo->tx_prov_disc_info.peerDevAddr);
-	//pframe += p2pielen;
 	pattrib->pktlen += p2p_ielen;
 
 	wpsielen = 0;
-	//	WPS OUI
+	/* 	WPS OUI */
 	*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 	wpsielen += 4;
 
-	//	WPS version
-	//	Type:
+	/* 	WPS version */
+	/* 	Type: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 	wpsielen += 2;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 	wpsielen += 2;
 
-	//	Value:
-	wpsie[wpsielen++] = WPS_VERSION_1;	//	Version 1.0
+	/* 	Value: */
+	wpsie[wpsielen++] = WPS_VERSION_1;	/* 	Version 1.0 */
 
-	//	Config Method
-	//	Type:
+	/* 	Config Method */
+	/* 	Type: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
 	wpsielen += 2;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 	wpsielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->tx_prov_disc_info.wps_config_method_request);
 	wpsielen += 2;
 
@@ -3940,19 +3841,13 @@ void rtw_cfg80211_issue_p2p_provision_re
 	wfdielen = build_provdisc_req_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
 	pattrib->pktlen += wfdielen;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
-	//dump_mgntframe(padapter, pmgntframe);
 	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS)
 		DBG_8192C("%s, ack to\n", __func__);
 
-	//if (wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC)
-	//{
-	//	DBG_8192C("waiting for p2p peer key-in PIN CODE\n");
-	//	rtw_msleep_os(15000); // 15 sec for key in PIN CODE, workaround for GS2 before issuing Nego Req.
-	//}
 }
 
 static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
@@ -3986,7 +3881,7 @@ static s32 cfg80211_rtw_remain_on_channe
 
 #ifdef CONFIG_CONCURRENT_MODE
                 ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
 	}
@@ -4008,9 +3903,8 @@ static s32 cfg80211_rtw_remain_on_channe
 #ifdef CONFIG_CONCURRENT_MODE
 	if (rtw_buddy_adapter_up(padapter))
 		rtw_scan_abort(padapter->pbuddy_adapter);
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
-	//if (!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) && !rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		rtw_p2p_enable(padapter, P2P_ROLE_DEVICE);
@@ -4029,7 +3923,7 @@ static s32 cfg80211_rtw_remain_on_channe
 
 
 	if (duration < 400)
-		duration = duration*3;//extend from exper.
+		duration = duration*3;/* extend from exper. */
 
 
 #ifdef	CONFIG_CONCURRENT_MODE
@@ -4065,22 +3959,18 @@ static s32 cfg80211_rtw_remain_on_channe
 			}
 
 			ready_on_channel = true;
-			//pmlmeext->cur_channel = remain_ch;
-			//set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 		} else
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 		if (remain_ch != pmlmeext->cur_channel)
 		{
 			ready_on_channel = true;
-			//pmlmeext->cur_channel = remain_ch;
-			//set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 		}
 	} else {
 		DBG_871X("%s remain_ch:%u not in channel plan!!!!\n", __func__, remain_ch);
 	}
 
 
-	//call this after other things have been done
+	/* call this after other things have been done */
 #ifdef	CONFIG_CONCURRENT_MODE
 	if (ATOMIC_READ(&pwdev_priv->ro_ch_to)==1 ||
 		(remain_ch != pmlmeext->cur_channel))
@@ -4155,7 +4045,7 @@ static s32 cfg80211_rtw_cancel_remain_on
 	return err;
 }
 
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 static int _cfg80211_rtw_mgmt_tx(_adapter *padapter, u8 tx_ch, const u8 *buf, size_t len)
 {
@@ -4170,7 +4060,6 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
-	//struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 
 	if (_FAIL == rtw_pwr_wakeup(padapter)) {
 		ret = -EFAULT;
@@ -4186,13 +4075,10 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 	#endif /* CONFIG_CONCURRENT_MODE */
 
 	if (padapter->cfg80211_wdinfo.is_ro_ch == true) {
-		//DBG_8192C("%s, cancel ro ch timer\n", __func__);
-		//_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
-		//padapter->cfg80211_wdinfo.is_ro_ch = false;
 		#ifdef CONFIG_CONCURRENT_MODE
 		DBG_8192C("%s, extend ro ch time\n", __func__);
 		_set_timer(&padapter->cfg80211_wdinfo.remain_on_ch_timer, pwdinfo->ext_listen_period);
-		#endif //CONFIG_CONCURRENT_MODE
+		#endif /* CONFIG_CONCURRENT_MODE */
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
@@ -4210,8 +4096,6 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 
 				ATOMIC_SET(&pwdev_priv->switch_ch_to, 0);
 
-				//DBG_8192C("%s, set switch ch timer, period=%d\n", __func__, pwdinfo->ext_listen_period);
-				//_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_period);
 			}
 
 			DBG_8192C("%s, set switch ch timer, period=%d\n", __func__, pwdinfo->ext_listen_period);
@@ -4224,23 +4108,22 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 		if (tx_ch != co_channel)
 			set_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	} else
-#endif //CONFIG_CONCURRENT_MODE
-	//if (tx_ch != pmlmeext->cur_channel) {
+#endif /* CONFIG_CONCURRENT_MODE */
 	if (tx_ch != rtw_get_oper_ch(padapter)) {
 		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
 			pmlmeext->cur_channel = tx_ch;
 		set_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 	}
 
-	//starting alloc mgmt frame to dump it
+	/* starting alloc mgmt frame to dump it */
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
-		//ret = -ENOMEM;
+		/* ret = -ENOMEM; */
 		ret = _FAIL;
 		goto exit;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 	pattrib->retry_ctrl = false;
@@ -4253,7 +4136,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 	pattrib->pktlen = len;
 
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
-	//update seq number
+	/* update seq number */
 	pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
 	pattrib->seqnum = pmlmeext->mgnt_seq;
 	pmlmeext->mgnt_seq++;
@@ -4269,7 +4152,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapte
 			rtw_append_wfd_ie(padapter, pframe, &pattrib->pktlen);
 		}
 	}
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -4483,9 +4366,6 @@ static int rtw_cfg80211_set_beacon_wpsp2
 
 		}
 
-		//buf += wps_ielen;
-		//len -= wps_ielen;
-
 		#ifdef CONFIG_P2P
 		if ((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
 		{
@@ -4512,10 +4392,7 @@ static int rtw_cfg80211_set_beacon_wpsp2
 			pmlmepriv->p2p_beacon_ie_len = p2p_ielen;
 
 		}
-		#endif //CONFIG_P2P
-
-		//buf += p2p_ielen;
-		//len -= p2p_ielen;
+		#endif /* CONFIG_P2P */
 
 		#ifdef CONFIG_WFD
 		if (rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
@@ -4540,7 +4417,7 @@ static int rtw_cfg80211_set_beacon_wpsp2
 			}
 			rtw_get_wfd_ie(buf, len, pmlmepriv->wfd_beacon_ie, &pmlmepriv->wfd_beacon_ie_len);
 		}
-		#endif //CONFIG_WFD
+		#endif /* CONFIG_WFD */
 
 		pmlmeext->bstart_bss = true;
 
@@ -4591,13 +4468,9 @@ static int rtw_cfg80211_set_probe_resp_w
 
 			}
 
-			//add PUSH_BUTTON config_method by driver self in wpsie of probe_resp at GO Mode
+			/* add PUSH_BUTTON config_method by driver self in wpsie of probe_resp at GO Mode */
 			if ((puconfig_method = (u16*)rtw_get_wps_attr_content(wps_ie, wps_ielen, WPS_ATTR_CONF_METHOD , NULL, &attr_contentlen)) != NULL)
 			{
-				#ifdef CONFIG_DEBUG_CFG80211
-				//printk("config_method in wpsie of probe_resp = 0x%x\n", be16_to_cpu(*puconfig_method));
-				#endif
-
 				uconfig_method = WPS_CM_PUSH_BUTTON;
 				uconfig_method = cpu_to_be16(uconfig_method);
 
@@ -4609,9 +4482,6 @@ static int rtw_cfg80211_set_probe_resp_w
 
 		}
 
-		//buf += wps_ielen;
-		//len -= wps_ielen;
-
 		#ifdef CONFIG_P2P
 		if ((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
 		{
@@ -4623,11 +4493,10 @@ static int rtw_cfg80211_set_probe_resp_w
 			DBG_8192C("probe_resp_p2p_ielen=%d\n", p2p_ielen);
 			#endif
 
-			//Check P2P Capability ATTR
+			/* Check P2P Capability ATTR */
 			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*) &attr_contentlen))
 			{
 				u8 grp_cap=0;
-				//DBG_8192C("[%s] Got P2P Capability Attr!!\n", __func__);
 				cap_attr = le16_to_cpu(cap_attr);
 				grp_cap = (u8)((cap_attr >> 8)&0xff);
 
@@ -4678,10 +4547,7 @@ static int rtw_cfg80211_set_probe_resp_w
 			}
 
 		}
-		#endif //CONFIG_P2P
-
-		//buf += p2p_ielen;
-		//len -= p2p_ielen;
+		#endif /* CONFIG_P2P */
 
 		#ifdef CONFIG_WFD
 		if (rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
@@ -4706,7 +4572,7 @@ static int rtw_cfg80211_set_probe_resp_w
 			}
 			rtw_get_wfd_ie(buf, len, pmlmepriv->wfd_probe_resp_ie, &pmlmepriv->wfd_probe_resp_ie_len);
 		}
-		#endif //CONFIG_WFD
+		#endif /* CONFIG_WFD */
 
 	}
 
@@ -4765,13 +4631,13 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struc
 		{
 			switch (type)
 			{
-				case 0x1: //BEACON
+				case 0x1: /* BEACON */
 				ret = rtw_cfg80211_set_beacon_wpsp2pie(net, buf, len);
 				break;
-				case 0x2: //PROBE_RESP
+				case 0x2: /* PROBE_RESP */
 				ret = rtw_cfg80211_set_probe_resp_wpsp2pie(net, buf, len);
 				break;
-				case 0x4: //ASSOC_RESP
+				case 0x4: /* ASSOC_RESP */
 				ret = rtw_cfg80211_set_assoc_resp_wpsp2pie(net, buf, len);
 				break;
 			}
@@ -4823,9 +4689,7 @@ static struct cfg80211_ops rtw_cfg80211_
 	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
 	.set_channel = cfg80211_rtw_set_channel,
 	#endif
-	//.auth = cfg80211_rtw_auth,
-	//.assoc = cfg80211_rtw_assoc,
-#endif //CONFIG_AP_MODE
+#endif /* CONFIG_AP_MODE */
 
 #ifdef CONFIG_P2P
 	.remain_on_channel = cfg80211_rtw_remain_on_channel,
@@ -4972,7 +4836,7 @@ static void rtw_cfg80211_preinit_wiphy(_
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 #ifdef CONFIG_AP_MODE
 	wiphy->mgmt_stypes = rtw_cfg80211_default_mgmt_stypes;
-#endif //CONFIG_AP_MODE
+#endif /* CONFIG_AP_MODE */
 #endif
 
 	wiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);
@@ -5040,12 +4904,11 @@ int rtw_wdev_alloc(_adapter *padapter, s
 	}
 	wdev->wiphy = wiphy;
 	wdev->netdev = pnetdev;
-	//wdev->iftype = NL80211_IFTYPE_STATION;
-	wdev->iftype = NL80211_IFTYPE_MONITOR; // for rtw_setopmode_cmd() in cfg80211_rtw_change_iface()
+	wdev->iftype = NL80211_IFTYPE_MONITOR; /*  for rtw_setopmode_cmd() in cfg80211_rtw_change_iface() */
 	padapter->rtw_wdev = wdev;
 	pnetdev->ieee80211_ptr = wdev;
 
-	//init pwdev_priv
+	/* init pwdev_priv */
 	pwdev_priv = wdev_to_priv(wdev);
 	pwdev_priv->rtw_wdev = wdev;
 	pwdev_priv->pmon_ndev = NULL;
@@ -5121,4 +4984,4 @@ void rtw_wdev_unregister(struct wireless
 	wiphy_unregister(wdev->wiphy);
 }
 
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
--- a/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/ioctl_linux.c
@@ -46,7 +46,7 @@
 #define MAX_CUSTOM_LEN 64
 #define RATE_COUNT 4
 
-// combo scan
+/*  combo scan */
 #define WEXT_CSCAN_AMOUNT 9
 #define WEXT_CSCAN_BUF_LEN		360
 #define WEXT_CSCAN_HEADER		"CSCAN S\x01\x00\x00S\x00"
@@ -189,7 +189,6 @@ void indicate_wx_scan_complete_event(str
 
 	memset(&wrqu, 0, sizeof(union iwreq_data));
 
-	//DBG_8192D("+rtw_indicate_wx_scan_complete_event\n");
 	wireless_send_event(padapter->pnetdev, SIOCGIWSCAN, &wrqu, NULL);
 #endif
 }
@@ -207,7 +206,6 @@ void rtw_indicate_wx_assoc_event(struct
 
 	memcpy(wrqu.ap_addr.sa_data, pmlmepriv->cur_network.network.MacAddress, ETH_ALEN);
 
-	//DBG_8192D("+rtw_indicate_wx_assoc_event\n");
 	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
 #endif
 }
@@ -222,7 +220,6 @@ void rtw_indicate_wx_disassoc_event(stru
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
 	memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
 
-	//DBG_8192D("+rtw_indicate_wx_disassoc_event\n");
 	wireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);
 #endif
 }
@@ -277,7 +274,7 @@ static char *translate_scan(struct rtw_a
 	struct registry_priv *pregpriv = &padapter->registrypriv;
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 #ifdef CONFIG_P2P
 #ifdef CONFIG_WFD
@@ -287,22 +284,22 @@ static char *translate_scan(struct rtw_a
 	}
 	else if ((SCAN_RESULT_P2P_ONLY == pwdinfo->wfd_info->scan_result_type) ||
 		      (SCAN_RESULT_WFD_TYPE == pwdinfo->wfd_info->scan_result_type))
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 	{
 		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
 			u32	blnGotP2PIE = false;
 
-			//	User is doing the P2P device discovery
-			//	The prefix of SSID should be "DIRECT-" and the IE should contains the P2P IE.
-			//	If not, the driver should ignore this AP and go to the next AP.
+			/* 	User is doing the P2P device discovery */
+			/* 	The prefix of SSID should be "DIRECT-" and the IE should contains the P2P IE. */
+			/* 	If not, the driver should ignore this AP and go to the next AP. */
 
-			//	Verifying the SSID
+			/* 	Verifying the SSID */
 			if (_rtw_memcmp(pnetwork->network.Ssid.Ssid, pwdinfo->p2p_wildcard_ssid, P2P_WILDCARD_SSID_LEN))
 			{
 				u32	p2pielen = 0;
 
-				//	Verifying the P2P IE
+				/* 	Verifying the P2P IE */
 				if (rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen))
 				{
 					blnGotP2PIE = true;
@@ -333,20 +330,20 @@ static char *translate_scan(struct rtw_a
 			{
 				if (pwdinfo->wfd_info->wfd_device_type == WFD_DEVINFO_PSINK)
 				{
-					//	the first two bits will indicate the WFD device type
+					/* 	the first two bits will indicate the WFD device type */
 					if ((wfd_devinfo[1] & 0x03) == WFD_DEVINFO_SOURCE)
 					{
-						//	If this device is Miracast PSink device, the scan reuslt should just provide the Miracast source.
+						/* 	If this device is Miracast PSink device, the scan reuslt should just provide the Miracast source. */
 						blnGotWFD = true;
 					}
 				}
 				else if (pwdinfo->wfd_info->wfd_device_type == WFD_DEVINFO_SOURCE)
 				{
-					//	the first two bits will indicate the WFD device type
+					/* 	the first two bits will indicate the WFD device type */
 					if ((wfd_devinfo[1] & 0x03) == WFD_DEVINFO_PSINK)
 					{
-						//	If this device is Miracast source device, the scan reuslt should just provide the Miracast PSink.
-						//	Todo: How about the SSink?!
+						/* 	If this device is Miracast source device, the scan reuslt should just provide the Miracast PSink. */
+						/* 	Todo: How about the SSink?! */
 						blnGotWFD = true;
 					}
 				}
@@ -358,9 +355,9 @@ static char *translate_scan(struct rtw_a
 			return start;
 		}
 	}
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 	/*  AP MAC address  */
 	iwe.cmd = SIOCGIWAP;
 	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
@@ -374,7 +371,7 @@ static char *translate_scan(struct rtw_a
 	iwe.u.data.length = min((u16)pnetwork->network.Ssid.SsidLength, (u16)32);
 	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
 
-	//parsing HT_CAP_IE
+	/* parsing HT_CAP_IE */
 		p = rtw_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-12);
 
 	if (p && ht_ielen>0)
@@ -474,22 +471,22 @@ static char *translate_scan(struct rtw_a
 
 	if (ht_cap == true)
 	{
-		if (mcs_rate&0x8000)//MCS15
+		if (mcs_rate&0x8000)/* MCS15 */
 		{
 			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
 
 		}
-		else if (mcs_rate&0x0080)//MCS7
+		else if (mcs_rate&0x0080)/* MCS7 */
 		{
 			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
 		}
-		else//default MCS7
+		else/* default MCS7 */
 		{
 			DBG_8192D("wx_get_scan, mcs_rate_bitmap=0x%x\n", mcs_rate);
 			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
 		}
 
-		max_rate = max_rate*2;//Mbps/2;
+		max_rate = max_rate*2;/* Mbps/2; */
 	}
 
 	iwe.cmd = SIOCGIWRATE;
@@ -497,7 +494,7 @@ static char *translate_scan(struct rtw_a
 	iwe.u.bitrate.value = max_rate * 500000;
 	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_PARAM_LEN);
 
-	//parsing WPA/WPA2 IE
+	/* parsing WPA/WPA2 IE */
 	{
 		u8 buf[MAX_WPA_IE_LEN];
 		u8 wpa_ie[255],rsn_ie[255];
@@ -547,7 +544,7 @@ static char *translate_scan(struct rtw_a
 		}
 	}
 
-	{ //parsing WPS IE
+	{ /* parsing WPS IE */
 		uint cnt = 0,total_ielen;
 		u8 *wpsie_ptr=NULL;
 		uint wps_ielen = 0;
@@ -564,7 +561,7 @@ static char *translate_scan(struct rtw_a
 				iwe.u.data.length = (u16)wps_ielen;
 				start = iwe_stream_add_point(info, start, stop, &iwe, wpsie_ptr);
 			}
-			cnt+=ie_ptr[cnt+1]+2; //goto next
+			cnt+=ie_ptr[cnt+1]+2; /* goto next */
 		}
 	}
 
@@ -592,14 +589,14 @@ static char *translate_scan(struct rtw_a
 
 
 	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
-	iwe.u.qual.level = (u8) translate_percentage_to_dbm(ss);//dbm
+	iwe.u.qual.level = (u8) translate_percentage_to_dbm(ss);/* dbm */
 	#else
-	iwe.u.qual.level = (u8)ss;//%
+	iwe.u.qual.level = (u8)ss;/*  */
 	#endif
 
-	iwe.u.qual.qual = (u8)sq;   // signal quality
+	iwe.u.qual.qual = (u8)sq;   /*  signal quality */
 
-	iwe.u.qual.noise = 0; // noise level
+	iwe.u.qual.noise = 0; /*  noise level */
 
 	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
 }
@@ -653,7 +650,7 @@ static int wpa_set_encryption(struct net
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 #ifdef CONFIG_P2P
 	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 _func_enter_;
 
@@ -744,9 +741,6 @@ _func_enter_;
 		{
 			DBG_8192D("wep, set_tx=0\n");
 
-			//don't update "psecuritypriv->dot11PrivacyAlgrthm" and
-			//"psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to fw/cam
-
 			if (wep_key_idx >= WEP_KEYS) {
 				ret = -EOPNOTSUPP ;
 				goto exit;
@@ -760,20 +754,19 @@ _func_enter_;
 		goto exit;
 	}
 
-	if (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) // 802_1x
+	if (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) /*  802_1x */
 	{
 		struct sta_info * psta,*pbcmc_sta;
 		struct sta_priv * pstapriv = &padapter->stapriv;
 
-		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true) //sta mode
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true) /* sta mode */
 		{
 			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
 			if (psta == NULL) {
-				//DEBUG_ERR(("Set wpa_set_encryption: Obtain Sta_info fail\n"));
 			}
 			else
 			{
-				//Jeff: don't disable ieee8021x_blocked while clearing key
+				/* Jeff: don't disable ieee8021x_blocked while clearing key */
 				if (strcmp(param->u.crypt.alg, "none") != 0)
 					psta->ieee8021x_blocked = false;
 
@@ -783,34 +776,28 @@ _func_enter_;
 					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
 				}
 
-				if (param->u.crypt.set_tx ==1)//pairwise key
+				if (param->u.crypt.set_tx ==1)/* pairwise key */
 				{
 					memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
-					if (strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
+					if (strcmp(param->u.crypt.alg, "TKIP") == 0)/* set mic key */
 					{
-						//DEBUG_ERR(("\nset key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
 						memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 						memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
 						padapter->securitypriv.busetkipkey=false;
-						//_set_timer(&padapter->securitypriv.tkip_timer, 50);
 					}
 
-					//DEBUG_ERR(("\n param->u.crypt.key_len=%d\n",param->u.crypt.key_len));
-					//DEBUG_ERR(("\n ~~~~stastakey:unicastkey\n"));
 					DBG_8192D("\n ~~~~stastakey:unicastkey\n");
 
 					rtw_setstakey_cmd(padapter, (unsigned char *)psta, true);
 				}
-				else//group key
+				else/* group key */
 				{
 					memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 					memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[16]),8);
 					memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[24]),8);
                                         padapter->securitypriv.binstallGrpkey = true;
-					//DEBUG_ERR(("\n param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
-					//DEBUG_ERR(("\n ~~~~stastakey:groupkey\n"));
 					DBG_8192D("\n ~~~~stastakey:groupkey\n");
 
 					padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
@@ -821,7 +808,7 @@ _func_enter_;
 					{
 						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_DONE);
 					}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 				}
 			}
@@ -829,11 +816,10 @@ _func_enter_;
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
 			if (pbcmc_sta==NULL)
 			{
-				//DEBUG_ERR(("Set OID_802_11_ADD_KEY: bcmc stainfo is null\n"));
 			}
 			else
 			{
-				//Jeff: don't disable ieee8021x_blocked while clearing key
+				/* Jeff: don't disable ieee8021x_blocked while clearing key */
 				if (strcmp(param->u.crypt.alg, "none") != 0)
 					pbcmc_sta->ieee8021x_blocked = false;
 
@@ -844,7 +830,7 @@ _func_enter_;
 				}
 			}
 		}
-		else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
+		else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) /* adhoc mode */
 		{
 		}
 	}
@@ -867,7 +853,7 @@ static int rtw_set_wpa_ie(struct rtw_ada
 	u8	null_addr[]= {0,0,0,0,0,0};
 #ifdef CONFIG_P2P
 	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	if ((ielen > MAX_WPA_IE_LEN) || (pie == NULL)) {
 		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
@@ -887,7 +873,7 @@ static int rtw_set_wpa_ie(struct rtw_ada
 
 		memcpy(buf, pie , ielen);
 
-		//dump
+		/* dump */
 		{
 			int i;
 			DBG_8192D("\n wpa_ie(length:%d):\n", ielen);
@@ -974,7 +960,7 @@ static int rtw_set_wpa_ie(struct rtw_ada
 		}
 
 		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
-		{//set wps_ie
+		{/* set wps_ie */
 			u16 cnt = 0;
 			u8 eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
 
@@ -997,23 +983,22 @@ static int rtw_set_wpa_ie(struct rtw_ada
 					{
 						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_ING);
 					}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 					cnt += buf[cnt+1]+2;
 
 					break;
 				} else {
-					cnt += buf[cnt+1]+2; //goto next
+					cnt += buf[cnt+1]+2; /* goto next */
 				}
 			}
 		}
 	}
 
-	//TKIP and AES disallow multicast packets until installing group key
+	/* TKIP and AES disallow multicast packets until installing group key */
 	if (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
-		//WPS open need to enable multicast
-		//|| check_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS) == true)
+		/* WPS open need to enable multicast */
 		rtw_hal_set_hwreg(padapter, HW_VAR_OFF_RCR_AM, null_addr);
 
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
@@ -1046,7 +1031,7 @@ static int rtw_wx_get_name(struct net_de
 
 	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true)
 	{
-		//parsing HT_CAP_IE
+		/* parsing HT_CAP_IE */
 		p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
 		if (p && ht_ielen>0)
 		{
@@ -1089,8 +1074,6 @@ static int rtw_wx_get_name(struct net_de
 	}
 	else
 	{
-		//prates = &padapter->registrypriv.dev_network.SupportedRates;
-		//snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
 		snprintf(wrqu->name, IFNAMSIZ, "unassociated");
 	}
 
@@ -1122,7 +1105,6 @@ static int rtw_wx_get_freq(struct net_de
 
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
-		//wrqu->freq.m = ieee80211_wlan_frequencies[pcur_bss->Configuration.DSConfig-1] * 100000;
 		wrqu->freq.m = rtw_ch2freq(pcur_bss->Configuration.DSConfig) * 100000;
 		wrqu->freq.e = 1;
 		wrqu->freq.i = pcur_bss->Configuration.DSConfig;
@@ -1170,7 +1152,6 @@ static int rtw_wx_set_mode(struct net_de
 		case IW_MODE_MASTER:
 			networkType = NDIS802_11APMODE;
 			DBG_8192D("set_mode = IW_MODE_MASTER\n");
-                        //rtw_setopmode_cmd(padapter, networkType);
 			break;
 		case IW_MODE_INFRA:
 			networkType = NDIS802_11INFRA;
@@ -1262,19 +1243,6 @@ static int rtw_wx_set_pmkid(struct net_d
         u8     strZeroMacAddress[ETH_ALEN] = { 0x00 };
         u8     strIssueBssid[ETH_ALEN] = { 0x00 };
 
-/*
-        struct iw_pmksa
-        {
-            __u32   cmd;
-            struct sockaddr bssid;
-            __u8    pmkid[IW_PMKID_LEN];   //IW_PMKID_LEN=16
-        }
-        There are the BSSID information in the bssid.sa_data array.
-        If cmd is IW_PMKSA_FLUSH, it means the wpa_suppplicant wants to clear all the PMKID information.
-        If cmd is IW_PMKSA_ADD, it means the wpa_supplicant wants to add a PMKID/BSSID to driver.
-        If cmd is IW_PMKSA_REMOVE, it means the wpa_supplicant wants to remove a PMKID/BSSID from driver.
-        */
-
 	memcpy(strIssueBssid, pPMK->bssid.sa_data, ETH_ALEN);
         if (pPMK->cmd == IW_PMKSA_ADD)
         {
@@ -1289,11 +1257,11 @@ static int rtw_wx_set_pmkid(struct net_d
                 }
 		blInserted = false;
 
-		//overwrite PMKID
+		/* overwrite PMKID */
 		for (j=0 ; j<NUM_PMKID_CACHE; j++)
 		{
 			if (_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==true)
-			{ // BSSID is matched, the same AP => rewrite with new PMKID.
+			{ /*  BSSID is matched, the same AP => rewrite with new PMKID. */
 
                                 DBG_8192D("[rtw_wx_set_pmkid] BSSID exists in the PMKList.\n");
 
@@ -1307,7 +1275,7 @@ static int rtw_wx_set_pmkid(struct net_d
 
 	        if (!blInserted)
                 {
-		    // Find a new entry
+		    /*  Find a new entry */
                     DBG_8192D("[rtw_wx_set_pmkid] Use the new entry index = %d for this PMKID.\n",
                             psecuritypriv->PMKIDIndex);
 
@@ -1329,7 +1297,7 @@ static int rtw_wx_set_pmkid(struct net_d
 		for (j=0 ; j<NUM_PMKID_CACHE; j++)
 		{
 			if (_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==true)
-			{ // BSSID is matched, the same AP => Remove this PMKID information and reset it.
+			{ /*  BSSID is matched, the same AP => Remove this PMKID information and reset it. */
                                 memset(psecuritypriv->PMKIDList[j].Bssid, 0x00, ETH_ALEN);
                                 psecuritypriv->PMKIDList[j].bUsed = false;
 				break;
@@ -1385,19 +1353,11 @@ static int rtw_wx_get_range(struct net_d
 	/* ~5 Mb/s real (802.11b) */
 	range->throughput = 5 * 1000 * 1000;
 
-	// TODO: Not used in 802.11b?
-//	range->min_nwid;	/* Minimal NWID we are able to set */
-	// TODO: Not used in 802.11b?
-//	range->max_nwid;	/* Maximal NWID we are able to set */
 
         /* Old Frequency (backward compat - moved lower) */
-//	range->old_num_channels;
-//	range->old_num_frequency;
-//	range->old_freq[6]; /* Filler to keep "version" at the same offset */
-
 	/* signal level threshold range */
 
-	//percent values between 0 and 100.
+	/* percent values between 0 and 100. */
 	range->max_qual.qual = 100;
 	range->max_qual.level = 100;
 	range->max_qual.noise = 100;
@@ -1424,17 +1384,10 @@ static int rtw_wx_get_range(struct net_d
 	range->we_version_compiled = WIRELESS_EXT;
 	range->we_version_source = 16;
 
-//	range->retry_capa;	/* What retry options are supported */
-//	range->retry_flags;	/* How to decode max/min retry limit */
-//	range->r_time_flags;	/* How to decode max/min retry life */
-//	range->min_retry;	/* Minimal number of retries */
-//	range->max_retry;	/* Maximal number of retries */
-//	range->min_r_time;	/* Minimal retry lifetime */
-//	range->max_r_time;	/* Maximal retry lifetime */
 
 	for (i = 0, val = 0; i < MAX_CHANNEL_NUM; i++) {
 
-		// Include only legal frequencies for some countries
+		/*  Include only legal frequencies for some countries */
 		if (pmlmeext->channel_set[i].ChannelNum != 0)
 		{
 			range->freq[val].i = pmlmeext->channel_set[i].ChannelNum;
@@ -1450,10 +1403,10 @@ static int rtw_wx_get_range(struct net_d
 	range->num_channels = val;
 	range->num_frequency = val;
 
-// Commented by Albert 2009/10/13
-// The following code will proivde the security capability to network manager.
-// If the driver doesn't provide this capability to network manager,
-// the WPA/WPA2 routers can't be choosen in the network manager.
+/*  Commented by Albert 2009/10/13 */
+/*  The following code will proivde the security capability to network manager. */
+/*  If the driver doesn't provide this capability to network manager, */
+/*  the WPA/WPA2 routers can't be choosen in the network manager. */
 
 /*
 #define IW_SCAN_CAPA_NONE		0x00
@@ -1471,7 +1424,7 @@ static int rtw_wx_get_range(struct net_d
 			  IW_ENC_CAPA_CIPHER_TKIP|IW_ENC_CAPA_CIPHER_CCMP;
 #endif
 
-#ifdef IW_SCAN_CAPA_ESSID //WIRELESS_EXT > 21
+#ifdef IW_SCAN_CAPA_ESSID /* WIRELESS_EXT > 21 */
 	range->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE |IW_SCAN_CAPA_BSSID|
 					IW_SCAN_CAPA_CHANNEL|IW_SCAN_CAPA_MODE|IW_SCAN_CAPA_RATE;
 #endif
@@ -1482,11 +1435,11 @@ static int rtw_wx_get_range(struct net_d
 	return 0;
 }
 
-//set bssid flow
-//s1. rtw_set_802_11_infrastructure_mode()
-//s2. rtw_set_802_11_authentication_mode()
-//s3. set_802_11_encryption_mode()
-//s4. rtw_set_802_11_bssid()
+/* set bssid flow */
+/* s1. rtw_set_802_11_infrastructure_mode() */
+/* s2. rtw_set_802_11_authentication_mode() */
+/* s3. set_802_11_encryption_mode() */
+/* s4. rtw_set_802_11_bssid() */
 static int rtw_wx_set_wap(struct net_device *dev,
 			 struct iw_request_info *info,
 			 union iwreq_data *awrq,
@@ -1583,7 +1536,6 @@ static int rtw_wx_set_wap(struct net_dev
 	spin_unlock_bh(&queue->lock);
 	spin_unlock_bh(&pmlmepriv->lock);
 	rtw_set_802_11_authentication_mode(padapter, authmode);
-	//set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
 	if (rtw_set_802_11_bssid(padapter, temp->sa_data) == false) {
 		ret = -1;
 		goto exit;
@@ -1680,7 +1632,7 @@ static int rtw_wx_set_scan(struct net_de
 	struct ndis_802_11_ssid ssid[RTW_SSID_SCAN_AMOUNT];
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_set_scan\n"));
 
 _func_enter_;
@@ -1711,9 +1663,9 @@ _func_enter_;
 		goto exit;
 	}
 
-	// When Busy Traffic, driver do not site survey. So driver return success.
-	// wpa_supplicant will not issue SIOCSIWSCAN cmd again after scan timeout.
-	// modify by thomas 2011-02-22.
+	/*  When Busy Traffic, driver do not site survey. So driver return success. */
+	/*  wpa_supplicant will not issue SIOCSIWSCAN cmd again after scan timeout. */
+	/*  modify by thomas 2011-02-22. */
 	if (pmlmepriv->LinkDetectInfo.bBusyTraffic == true)
 	{
 		indicate_wx_scan_complete_event(padapter);
@@ -1750,23 +1702,11 @@ _func_enter_;
 	}
 #endif
 
-//	Mareded by Albert 20101103
-//	For the DMP WiFi Display project, the driver won't to scan because
-//	the pmlmepriv->scan_interval is always equal to 3.
-//	So, the wpa_supplicant won't find out the WPS SoftAP.
-
-/*
-	if (pmlmepriv->scan_interval>10)
-		pmlmepriv->scan_interval = 0;
-
-	if (pmlmepriv->scan_interval > 0)
-	{
-		DBG_8192D("scan done\n");
-		ret = 0;
-		goto exit;
-	}
+/* 	Mareded by Albert 20101103 */
+/* 	For the DMP WiFi Display project, the driver won't to scan because */
+/* 	the pmlmepriv->scan_interval is always equal to 3. */
+/* 	So, the wpa_supplicant won't find out the WPS SoftAP. */
 
-*/
 #ifdef CONFIG_P2P
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
@@ -1775,7 +1715,7 @@ _func_enter_;
 		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_FULL);
 		rtw_free_network_queue(padapter, true);
 	}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	memset(ssid, 0, sizeof(struct ndis_802_11_ssid)*RTW_SSID_SCAN_AMOUNT);
 
@@ -1819,14 +1759,11 @@ _func_enter_;
 		char sec_len;
 		int ssid_index = 0;
 
-		//DBG_8192D("%s COMBO_SCAN header is recognized\n", __func__);
-
 		while (len >= 1) {
 			section = *(pos++); len-=1;
 
 			switch (section) {
 				case WEXT_CSCAN_SSID_SECTION:
-					//DBG_8192D("WEXT_CSCAN_SSID_SECTION\n");
 					if (len < 1) {
 						len = 0;
 						break;
@@ -1837,8 +1774,6 @@ _func_enter_;
 					if (sec_len>0 && sec_len<=len) {
 						ssid[ssid_index].SsidLength = sec_len;
 						memcpy(ssid[ssid_index].Ssid, pos, ssid[ssid_index].SsidLength);
-						//DBG_8192D("%s COMBO_SCAN with specific ssid:%s, %d\n", __func__
-						//	, ssid[ssid_index].Ssid, ssid[ssid_index].SsidLength);
 						ssid_index++;
 					}
 
@@ -1847,30 +1782,25 @@ _func_enter_;
 
 
 				case WEXT_CSCAN_CHANNEL_SECTION:
-					//DBG_8192D("WEXT_CSCAN_CHANNEL_SECTION\n");
 					pos+=1; len-=1;
 					break;
 				case WEXT_CSCAN_ACTV_DWELL_SECTION:
-					//DBG_8192D("WEXT_CSCAN_ACTV_DWELL_SECTION\n");
 					pos+=2; len-=2;
 					break;
 				case WEXT_CSCAN_PASV_DWELL_SECTION:
-					//DBG_8192D("WEXT_CSCAN_PASV_DWELL_SECTION\n");
 					pos+=2; len-=2;
 					break;
 				case WEXT_CSCAN_HOME_DWELL_SECTION:
-					//DBG_8192D("WEXT_CSCAN_HOME_DWELL_SECTION\n");
 					pos+=2; len-=2;
 					break;
 				case WEXT_CSCAN_TYPE_SECTION:
-					//DBG_8192D("WEXT_CSCAN_TYPE_SECTION\n");
 					pos+=1; len-=1;
 					break;
 				default:
-					len = 0; // stop parsing
+					len = 0; /*  stop parsing */
 			}
 		}
-		//jeff: it has still some scan paramater to parse, we only do this now...
+		/* jeff: it has still some scan paramater to parse, we only do this now... */
 		_status = rtw_set_802_11_bssid_list_scan(padapter, ssid, RTW_SSID_SCAN_AMOUNT);
 
 	} else {
@@ -1905,12 +1835,10 @@ static int rtw_wx_get_scan(struct net_de
 	u32 wait_for_surveydone;
 	int wait_status;
 #ifdef CONFIG_CONCURRENT_MODE
-	//struct rtw_adapter * pbuddy_adapter = padapter->pbuddy_adapter;
-	//struct mlme_priv *pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 #endif
 #ifdef CONFIG_P2P
 	struct	wifidirect_info*	pwdinfo = &padapter->wdinfo;
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_scan\n"));
 	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_, (" Start of Query SIOCGIWSCAN .\n"));
 
@@ -1920,15 +1848,6 @@ static int rtw_wx_get_scan(struct net_de
 	DBG_8192D("DBG_IOCTL %s:%d\n",__func__, __LINE__);
 	#endif
 
-/*
-#ifdef CONFIG_CONCURRENT_MODE
-	if (padapter->iface_type > PRIMARY_IFACE)
-	{
-		ret = -EINVAL;
-		goto exit;
-	}
-#endif
-*/
 	if (padapter->pwrctrlpriv.brfoffbyhw && padapter->bDriverStopped)
 	{
 		ret = -EINVAL;
@@ -1938,37 +1857,22 @@ static int rtw_wx_get_scan(struct net_de
 #ifdef CONFIG_P2P
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
-		//	P2P is enabled
+		/* 	P2P is enabled */
 		if (padapter->chip_type == RTL8192D)
-			wait_for_surveydone = 300;	//	Because the 8192du supports more channels.
+			wait_for_surveydone = 300;	/* 	Because the 8192du supports more channels. */
 		else
 			wait_for_surveydone = 200;
 	}
 	else
 	{
-		//	P2P is disabled
+		/* 	P2P is disabled */
 		wait_for_surveydone = 100;
 	}
 #else
 	{
 		wait_for_surveydone = 100;
 	}
-#endif //CONFIG_P2P
-
-/*
-#ifdef CONFIG_CONCURRENT_MODE
-	if (pmlmepriv->scanning_via_buddy_intf == true)
-	{
-		pmlmepriv->scanning_via_buddy_intf = false;//reset
-
-		// change pointers to buddy interface
-		padapter = pbuddy_adapter;
-		pmlmepriv = pbuddy_mlmepriv;
-		queue = &(pbuddy_mlmepriv->scanned_queue);
-
-	}
-#endif // CONFIG_CONCURRENT_MODE
-*/
+#endif /* CONFIG_P2P */
 
 	wait_status = _FW_UNDER_SURVEY
 		#ifndef CONFIG_ANDROID
@@ -1984,7 +1888,7 @@ static int rtw_wx_get_scan(struct net_de
 		if (cnt > wait_for_surveydone)
 			break;
 	}
-#endif // CONFIG_DUALMAC_CONCURRENT
+#endif /*  CONFIG_DUALMAC_CONCURRENT */
 
 	while (check_fwstate(pmlmepriv, wait_status) == true)
 	{
@@ -2011,7 +1915,7 @@ static int rtw_wx_get_scan(struct net_de
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		//report network only if the current channel set contains the channel to which this network belongs
+		/* report network only if the current channel set contains the channel to which this network belongs */
 		if (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
 			#ifdef CONFIG_VALIDATE_SSID
 			&& true == rtw_validate_ssid(&(pnetwork->network.Ssid))
@@ -2041,11 +1945,11 @@ exit:
 	return ret ;
 }
 
-//set ssid flow
-//s1. rtw_set_802_11_infrastructure_mode()
-//s2. set_802_11_authenticaion_mode()
-//s3. set_802_11_encryption_mode()
-//s4. rtw_set_802_11_ssid()
+/* set ssid flow */
+/* s1. rtw_set_802_11_infrastructure_mode() */
+/* s2. set_802_11_authenticaion_mode() */
+/* s3. set_802_11_encryption_mode() */
+/* s4. rtw_set_802_11_ssid() */
 static int rtw_wx_set_essid(struct net_device *dev,
 			      struct iw_request_info *a,
 			      union iwreq_data *wrqu, char *extra)
@@ -2130,14 +2034,14 @@ static int rtw_wx_set_essid(struct net_d
 	DBG_8192D("=>%s\n",__func__);
 	if (wrqu->essid.flags && wrqu->essid.length)
 	{
-		// Commented by Albert 20100519
-		// We got the codes in "set_info" function of iwconfig source code.
-		//	=========================================
-		//	wrq.u.essid.length = strlen(essid) + 1;
-		//	if (we_kernel_version > 20)
-		//		wrq.u.essid.length--;
-		//	=========================================
-		//	That means, if the WIRELESS_EXT less than or equal to 20, the correct ssid len should subtract 1.
+		/*  Commented by Albert 20100519 */
+		/*  We got the codes in "set_info" function of iwconfig source code. */
+		/* 	========================================= */
+		/* 	wrq.u.essid.length = strlen(essid) + 1; */
+		/* 	if (we_kernel_version > 20) */
+		/* 		wrq.u.essid.length--; */
+		/* 	========================================= */
+		/* 	That means, if the WIRELESS_EXT less than or equal to 20, the correct ssid len should subtract 1. */
 #if WIRELESS_EXT <= 20
 		len = ((wrqu->essid.length-1) < IW_ESSID_MAX_SIZE) ? (wrqu->essid.length-1) : IW_ESSID_MAX_SIZE;
 #else
@@ -2204,7 +2108,6 @@ static int rtw_wx_set_essid(struct net_d
 		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
 			 ("set ssid: set_802_11_auth. mode=%d\n", authmode));
 		rtw_set_802_11_authentication_mode(padapter, authmode);
-		//set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
 		if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == false) {
 			ret = -1;
 			goto exit;
@@ -2404,7 +2307,6 @@ static int rtw_wx_get_rts(struct net_dev
 
 	wrqu->rts.value = padapter->registrypriv.rts_thresh;
 	wrqu->rts.fixed = 0;	/* no auto select */
-	//wrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD);
 
 	_func_exit_;
 
@@ -2448,7 +2350,6 @@ static int rtw_wx_get_frag(struct net_de
 
 	wrqu->frag.value = padapter->xmitpriv.frag_len;
 	wrqu->frag.fixed = 0;	/* no auto select */
-	//wrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FRAG_THRESHOLD);
 
 	_func_exit_;
 
@@ -2459,9 +2360,6 @@ static int rtw_wx_get_retry(struct net_d
 			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
-	//_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-
-
 	wrqu->retry.value = 7;
 	wrqu->retry.fixed = 0;	/* no auto select */
 	wrqu->retry.disabled = 1;
@@ -2495,7 +2393,7 @@ static int rtw_wx_set_enc(struct net_dev
 		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
 		padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
 		padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
-		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; //open system
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; /* open system */
 		authmode = NDIS802_11AUTHMODEOPEN;
 		padapter->securitypriv.ndisauthtype=authmode;
 
@@ -2515,11 +2413,11 @@ static int rtw_wx_set_enc(struct net_dev
 		DBG_8192D("rtw_wx_set_enc, key=%d\n", key);
 	}
 
-	//set authentication mode
+	/* set authentication mode */
 	if (erq->flags & IW_ENCODE_OPEN)
 	{
 		DBG_8192D("rtw_wx_set_enc():IW_ENCODE_OPEN\n");
-		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;//NDIS802_11ENCRYPTION_DISABLED;
+		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;/* NDIS802_11ENCRYPTION_DISABLED; */
 
 		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open;
 
@@ -2544,8 +2442,8 @@ static int rtw_wx_set_enc(struct net_dev
 	{
 		DBG_8192D("rtw_wx_set_enc():erq->flags=0x%x\n", erq->flags);
 
-		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;//NDIS802_11ENCRYPTION_DISABLED;
-		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; //open system
+		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;/* NDIS802_11ENCRYPTION_DISABLED; */
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; /* open system */
 		padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
 		padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
 		authmode = NDIS802_11AUTHMODEOPEN;
@@ -2563,7 +2461,7 @@ static int rtw_wx_set_enc(struct net_dev
 	{
 		wep.KeyLength = 0 ;
 
-		if (keyindex_provided == 1)// set key_id only, no given KeyMaterial(erq->length==0).
+		if (keyindex_provided == 1)/*  set key_id only, no given KeyMaterial(erq->length==0). */
 		{
 			padapter->securitypriv.dot11PrivacyKeyIndex = key;
 
@@ -2640,11 +2538,6 @@ static int rtw_wx_get_enc(struct net_dev
 
 	erq->flags = key + 1;
 
-	//if (padapter->securitypriv.ndisauthtype == NDIS802_11AUTHMODEOPEN)
-	//{
-	//      erq->flags |= IW_ENCODE_OPEN;
-	//}
-
 	switch (padapter->securitypriv.ndisencryptstatus)
 	{
 		case NDIS802_11ENCRYPTIONNOTSUPPORTED:
@@ -2707,8 +2600,6 @@ static int rtw_wx_get_power(struct net_d
 			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
-	//_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-
 	wrqu->power.value = 0;
 	wrqu->power.fixed = 0;	/* no auto select */
 	wrqu->power.disabled = 1;
@@ -2754,11 +2645,11 @@ static int rtw_wx_set_auth(struct net_de
 	case IW_AUTH_TKIP_COUNTERMEASURES:
         {
 	    if (param->value)
-            {  // wpa_supplicant is enabling the tkip countermeasure.
+            {  /*  wpa_supplicant is enabling the tkip countermeasure. */
                padapter->securitypriv.btkip_countermeasure = true;
             }
             else
-            {  // wpa_supplicant is disabling the tkip countermeasure.
+            {  /*  wpa_supplicant is disabling the tkip countermeasure. */
                padapter->securitypriv.btkip_countermeasure = false;
             }
 		break;
@@ -2779,15 +2670,15 @@ static int rtw_wx_set_auth(struct net_de
 
 			if (padapter->securitypriv.ndisencryptstatus == NDIS802_11ENCRYPTION1ENABLED)
 			{
-				break;//it means init value, or using wep, ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED,
-						// then it needn't reset it;
+				break;/* it means init value, or using wep, ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED, */
+						/*  then it needn't reset it; */
 			}
 
 			if (param->value) {
 				padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
 				padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
 				padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
-				padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; //open system
+				padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; /* open system */
 				padapter->securitypriv.ndisauthtype=NDIS802_11AUTHMODEOPEN;
 			}
 
@@ -2809,33 +2700,16 @@ static int rtw_wx_set_auth(struct net_de
 		}
 		#endif
 
-
 		ret = wpa_set_auth_algs(dev, (u32)param->value);
-
 		break;
-
 	case IW_AUTH_WPA_ENABLED:
-
-		//if (param->value)
-		//	padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X; //802.1x
-		//else
-		//	padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;//open system
-
-		//_disassociate(priv);
-
 		break;
-
 	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
-		//ieee->ieee802_1x = param->value;
 		break;
-
 	case IW_AUTH_PRIVACY_INVOKED:
-		//ieee->privacy_invoked = param->value;
 		break;
-
 	default:
 		return -EOPNOTSUPP;
-
 	}
 
 	return ret;
@@ -2865,8 +2739,8 @@ static int rtw_wx_set_enc_ext(struct net
 
 	switch (pext->alg) {
 	case IW_ENCODE_ALG_NONE:
-		//todo: remove key
-		//remove = 1;
+		/* todo: remove key */
+		/* remove = 1; */
 		alg_name = "none";
 		break;
 	case IW_ENCODE_ALG_WEP:
@@ -2885,12 +2759,12 @@ static int rtw_wx_set_enc_ext(struct net
 	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
 
 
-	if (pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)//?
+	if (pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)/*  */
 	{
 		param->u.crypt.set_tx = 0;
 	}
 
-	if (pext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)//?
+	if (pext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)/*  */
 	{
 		param->u.crypt.set_tx = 1;
 	}
@@ -2905,15 +2779,14 @@ static int rtw_wx_set_enc_ext(struct net
 	if (pext->key_len)
 	{
 		param->u.crypt.key_len = pext->key_len;
-		//memcpy(param + 1, pext + 1, pext->key_len);
 		memcpy(param->u.crypt.key, pext + 1, pext->key_len);
 	}
 
 
 	if (pencoding->flags & IW_ENCODE_DISABLED)
 	{
-		//todo: remove key
-		//remove = 1;
+		/* todo: remove key */
+		/* remove = 1; */
 	}
 
 	ret =  wpa_set_encryption(dev, param, param_len);
@@ -2930,9 +2803,6 @@ static int rtw_wx_get_nick(struct net_de
 			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
-	//_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	 //struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	 //struct security_priv *psecuritypriv = &padapter->securitypriv;
 
 	if (extra)
 	{
@@ -3045,7 +2915,6 @@ static int rtw_wx_read_rf(struct net_dev
 	path = *(u32*)extra;
 	addr = *((u32*)extra + 1);
 	data32 = rtw_hal_read_rfreg(padapter, path, addr, 0xFFFFF);
-//	DBG_8192D("%s: path=%d addr=0x%02x data=0x%05x\n", __func__, path, addr, data32);
 	/*
 	 * IMPORTANT!!
 	 * Only when wireless private ioctl is at odd order,
@@ -3067,7 +2936,6 @@ static int rtw_wx_write_rf(struct net_de
 	path = *(u32*)extra;
 	addr = *((u32*)extra + 1);
 	data32 = *((u32*)extra + 2);
-//	DBG_8192D("%s: path=%d addr=0x%02x data=0x%05x\n", __func__, path, addr, data32);
 	rtw_hal_write_rfreg(padapter, path, addr, 0xFFFFF, data32);
 
 	return 0;
@@ -3082,10 +2950,7 @@ static int rtw_wx_priv_null(struct net_d
 static int dummy(struct net_device *dev, struct iw_request_info *a,
 		 union iwreq_data *wrqu, char *b)
 {
-	//_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
-	//struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-	//DBG_8192D("cmd_code=%x, fwstate=0x%x\n", a->cmd, get_fwstate(pmlmepriv));
 
 	return -1;
 }
@@ -3161,7 +3026,7 @@ static  int rtw_drvext_hdl(struct net_de
 		goto _rtw_drvext_hdl_exit;
 	}
 
-	if (bset)//set info
+	if (bset)/* set info */
 	{
 		if (copy_from_user(pparmbuf, p->pointer,len)) {
 			kfree(pparmbuf);
@@ -3169,20 +3034,20 @@ static  int rtw_drvext_hdl(struct net_de
 			goto _rtw_drvext_hdl_exit;
 		}
 	}
-	else//query info
+	else/* query info */
 	{
 
 	}
 
 
-	//
+	/*  */
 	poidparam = (struct drvext_oidparam *)pparmbuf;
 
 	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("drvext set oid subcode [%d], len[%d], InformationBufferLength[%d]\r\n",
 						 poidparam->subcode, poidparam->len, len));
 
 
-	//check subcode
+	/* check subcode */
 	if (poidparam->subcode >= MAX_DRVEXT_HANDLERS)
 	{
 		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext handlers\r\n"));
@@ -3216,8 +3081,7 @@ static  int rtw_drvext_hdl(struct net_de
 	{
 		ret = 0;
 
-		if (bset == 0x00) {//query info
-			//memcpy(p->pointer, pparmbuf, len);
+		if (bset == 0x00) {/* query info */
 			if (copy_to_user(p->pointer, pparmbuf, len))
 				ret = -EFAULT;
 		}
@@ -3348,10 +3212,6 @@ static int rtw_mp_ioctl_hdl(struct net_d
 	struct rtw_adapter * padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point *p = &wrqu->data;
 
-	//DBG_8192D("+rtw_mp_ioctl_hdl\n");
-
-	//mutex_lock(&ioctl_mutex);
-
 	if ((!p->length) || (!p->pointer)) {
 		ret = -EINVAL;
 		goto _rtw_mp_ioctl_hdl_exit;
@@ -3383,7 +3243,7 @@ static int rtw_mp_ioctl_hdl(struct net_d
 	}
 	rtw_dbg_mode_hdl(padapter, poidparam->subcode, poidparam->data, poidparam->len);
 
-	if (bset == 0x00) {//query info
+	if (bset == 0x00) {/* query info */
 		if (copy_to_user(p->pointer, pparmbuf, len))
 			ret = -EFAULT;
 	}
@@ -3432,8 +3292,6 @@ static int rtw_get_ap_info(struct net_de
 			break;
 	}
 
-
-	//pdata->length = 0;//?
 	pdata->flags = 0;
 	if (pdata->length>=32)
 	{
@@ -3462,7 +3320,6 @@ static int rtw_get_ap_info(struct net_de
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		//if (hwaddr_aton_i(pdata->pointer, bssid))
 		if (hwaddr_aton_i(data, bssid))
 		{
 			DBG_8192D("Invalid BSSID '%s'.\n", (u8*)data);
@@ -3471,7 +3328,7 @@ static int rtw_get_ap_info(struct net_de
 		}
 
 
-		if (_rtw_memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN) == true)//BSSID match, then check if supporting wpa/wpa2
+		if (_rtw_memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN) == true)/* BSSID match, then check if supporting wpa/wpa2 */
 		{
 			DBG_8192D("BSSID:%pM\n", bssid);
 
@@ -3558,22 +3415,22 @@ static int rtw_wps_start(struct net_devi
 
 	DBG_8192D("[%s] wps_start = %d\n", __func__, u32wps_start);
 
-	if (u32wps_start == 1) // WPS Start
+	if (u32wps_start == 1) /*  WPS Start */
 	{
 		rtw_led_control(padapter, LED_CTL_START_WPS);
 	}
-	else if (u32wps_start == 2) // WPS Stop because of wps success
+	else if (u32wps_start == 2) /*  WPS Stop because of wps success */
 	{
 		rtw_led_control(padapter, LED_CTL_STOP_WPS);
 	}
-	else if (u32wps_start == 3) // WPS Stop because of wps fail
+	else if (u32wps_start == 3) /*  WPS Stop because of wps fail */
 	{
 		rtw_led_control(padapter, LED_CTL_STOP_WPS_FAIL);
 	}
 
 #ifdef CONFIG_INTEL_WIDI
 	process_intel_widi_wps_status(padapter, u32wps_start);
-#endif //CONFIG_INTEL_WIDI
+#endif /* CONFIG_INTEL_WIDI */
 
 exit:
 
@@ -3610,7 +3467,7 @@ static int rtw_wext_p2p_enable(struct ne
 		goto exit;
 	}
 
-	//set channel/bandwidth
+	/* set channel/bandwidth */
 	if (init_role != P2P_ROLE_DISABLE)
 	{
 		u8 channel, ch_offset;
@@ -3618,7 +3475,7 @@ static int rtw_wext_p2p_enable(struct ne
 
 		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN))
 		{
-			//	Stay at the listen state and wait for discovery.
+			/* 	Stay at the listen state and wait for discovery. */
 			channel = pwdinfo->listen_channel;
 			pwdinfo->operating_channel = pwdinfo->listen_channel;
 			ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
@@ -3628,7 +3485,6 @@ static int rtw_wext_p2p_enable(struct ne
 		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 		{
 			struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
-			//struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
 			struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
 			struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
@@ -3636,7 +3492,7 @@ static int rtw_wext_p2p_enable(struct ne
 			if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
 			{
 				pwdinfo->operating_channel = pbuddy_mlmeext->cur_channel;
-				//	How about the ch_offset and bwmode ??
+				/* 	How about the ch_offset and bwmode ?? */
 			}
 			else
 			{
@@ -3728,7 +3584,7 @@ static int rtw_p2p_set_listen_ch(struct
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
-	u8	listen_ch = pwdinfo->listen_channel;	//	Listen channel number
+	u8	listen_ch = pwdinfo->listen_channel;	/* 	Listen channel number */
 
 	switch (wrqu->data.length)
 	{
@@ -3763,13 +3619,13 @@ static int rtw_p2p_set_op_ch(struct net_
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-//	Commented by Albert 20110524
-//	This function is used to set the operating channel if the driver will become the group owner
+/* 	Commented by Albert 20110524 */
+/* 	This function is used to set the operating channel if the driver will become the group owner */
 
 	int ret = 0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
-	u8	op_ch = pwdinfo->operating_channel;	//	Operating channel number
+	u8	op_ch = pwdinfo->operating_channel;	/* 	Operating channel number */
 
 	switch (wrqu->data.length)
 	{
@@ -3809,25 +3665,25 @@ static int rtw_p2p_profilefound(struct n
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 
-	//	Comment by Albert 2010/10/13
-	//	Input data format:
-	//	Ex:  0
-	//	Ex:  1XX:XX:XX:XX:XX:XXYYSSID
-	//	0 => Reflush the profile record list.
-	//	1 => Add the profile list
-	//	XX:XX:XX:XX:XX:XX => peer's MAC Address (ex: 00:E0:4C:00:00:01)
-	//	YY => SSID Length
-	//	SSID => SSID for persistence group
+	/* 	Comment by Albert 2010/10/13 */
+	/* 	Input data format: */
+	/* 	Ex:  0 */
+	/* 	Ex:  1XX:XX:XX:XX:XX:XXYYSSID */
+	/* 	0 => Reflush the profile record list. */
+	/* 	1 => Add the profile list */
+	/* 	XX:XX:XX:XX:XX:XX => peer's MAC Address (ex: 00:E0:4C:00:00:01) */
+	/* 	YY => SSID Length */
+	/* 	SSID => SSID for persistence group */
 
 	DBG_8192D("[%s] In value = %s, len = %d\n", __func__, extra, wrqu->data.length -1);
 
 
-	//	The upper application should pass the SSID to driver by using this rtw_p2p_profilefound function.
+	/* 	The upper application should pass the SSID to driver by using this rtw_p2p_profilefound function. */
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
 		if (extra[0] == '0')
 		{
-			//	Remove all the profile information of wifidirect_info structure.
+			/* 	Remove all the profile information of wifidirect_info structure. */
 			memset(&pwdinfo->profileinfo[0], 0x00, sizeof(struct profile_info) * P2P_MAX_PERSISTENT_GROUP_NUM);
 			pwdinfo->profileindex = 0;
 		}
@@ -3841,15 +3697,13 @@ static int rtw_p2p_profilefound(struct n
 		{
 				int jj, kk;
 
-				//	Add this profile information into pwdinfo->profileinfo
-				//	Ex:  1XX:XX:XX:XX:XX:XXYYSSID
+				/* 	Add this profile information into pwdinfo->profileinfo */
+				/* 	Ex:  1XX:XX:XX:XX:XX:XXYYSSID */
 				for (jj = 0, kk = 1; jj < ETH_ALEN; jj++, kk += 3)
 				{
 					pwdinfo->profileinfo[pwdinfo->profileindex].peermac[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
 				}
 
-				//pwdinfo->profileinfo[pwdinfo->profileindex].ssidlen = (extra[18] - '0') * 10 + (extra[19] - '0');
-				//memcpy(pwdinfo->profileinfo[pwdinfo->profileindex].ssid, &extra[20], pwdinfo->profileinfo[pwdinfo->profileindex].ssidlen);
 				pwdinfo->profileindex++;
 			}
 		}
@@ -3895,19 +3749,19 @@ static int rtw_p2p_get_status(struct net
 				pwdinfo->p2p_peer_interface_addr[3], pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5]);
 	}
 
-	//	Commented by Albert 2010/10/12
-	//	Because of the output size limitation, I had removed the "Role" information.
-	//	About the "Role" information, we will use the new private IOCTL to get the "Role" information.
+	/* 	Commented by Albert 2010/10/12 */
+	/* 	Because of the output size limitation, I had removed the "Role" information. */
+	/* 	About the "Role" information, we will use the new private IOCTL to get the "Role" information. */
 	sprintf(extra, "\n\nStatus=%.2d\n", rtw_p2p_state(pwdinfo));
 	wrqu->data.length = strlen(extra);
 
 	return ret;
 }
 
-//	Commented by Albert 20110520
-//	This function will return the config method description
-//	This config method description will show us which config method the remote P2P device is intented to use
-//	by sending the provisioning discovery request frame.
+/* 	Commented by Albert 20110520 */
+/* 	This function will return the config method description */
+/* 	This config method description will show us which config method the remote P2P device is intented to use */
+/* 	by sending the provisioning discovery request frame. */
 
 static int rtw_p2p_get_req_cm(struct net_device *dev,
                                struct iw_request_info *info,
@@ -4079,10 +3933,10 @@ static int rtw_p2p_get_wps_configmethod(
 	uint attr_contentlen = 0;
 	u8	attr_content_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
 
-	//	Commented by Albert 20110727
-	//	The input data is the MAC address which the application wants to know its WPS config method.
-	//	After knowing its WPS config method, the application can decide the config method for provisioning discovery.
-	//	Format: iwpriv wlanx p2p_get_wpsCM 00:E0:4C:00:00:05
+	/* 	Commented by Albert 20110727 */
+	/* 	The input data is the MAC address which the application wants to know its WPS config method. */
+	/* 	After knowing its WPS config method, the application can decide the config method for provisioning discovery. */
+	/* 	Format: iwpriv wlanx p2p_get_wpsCM 00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
 
@@ -4103,7 +3957,7 @@ static int rtw_p2p_get_wps_configmethod(
 			u8 *wpsie;
 			uint	wpsie_len = 0;
 
-			//	The mac address is matched.
+			/* 	The mac address is matched. */
 
 			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
 			{
@@ -4170,7 +4024,7 @@ static int rtw_p2p_get_peer_wfd_preferre
 	DBG_8192D("[%s] wfd_pc = %d\n", __func__, pwdinfo->wfd_info->wfd_pc);
 
 	wrqu->data.length = strlen(extra);
-	pwdinfo->wfd_info->wfd_pc = false;	//	Reset the WFD preferred connection to P2P
+	pwdinfo->wfd_info->wfd_pc = false;	/* 	Reset the WFD preferred connection to P2P */
 	return ret;
 }
 
@@ -4188,11 +4042,11 @@ static int rtw_p2p_get_peer_wfd_session_
 	DBG_8192D("[%s] wfd_sa = %d\n", __func__, pwdinfo->wfd_info->peer_session_avail);
 
 	wrqu->data.length = strlen(extra);
-	pwdinfo->wfd_info->peer_session_avail = true;	//	Reset the WFD session available
+	pwdinfo->wfd_info->peer_session_avail = true;	/* 	Reset the WFD session available */
 	return ret;
 }
 
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
 static int rtw_p2p_get_go_device_address(struct net_device *dev,
 										 struct iw_request_info *info,
@@ -4212,9 +4066,9 @@ static int rtw_p2p_get_go_device_address
 	u8 attr_content[100] = { 0x00 };
 	u8 go_devadd_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
 
-	//	Commented by Albert 20121209
-	//	The input data is the GO's interface address which the application wants to know its device address.
-	//	Format: iwpriv wlanx p2p_get2 go_devadd=00:E0:4C:00:00:05
+	/* 	Commented by Albert 20121209 */
+	/* 	The input data is the GO's interface address which the application wants to know its device address. */
+	/* 	Format: iwpriv wlanx p2p_get2 go_devadd=00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
 
@@ -4232,32 +4086,32 @@ static int rtw_p2p_get_go_device_address
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
 		{
-			//	Commented by Albert 2011/05/18
-			//	Match the device address located in the P2P IE
-			//	This is for the case that the P2P device address is not the same as the P2P interface address.
+			/* 	Commented by Albert 2011/05/18 */
+			/* 	Match the device address located in the P2P IE */
+			/* 	This is for the case that the P2P device address is not the same as the P2P interface address. */
 
 			if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
 			{
 				while (p2pie)
 				{
-					//	The P2P Device ID attribute is included in the Beacon frame.
-					//	The P2P Device Info attribute is included in the probe response frame.
+					/* 	The P2P Device ID attribute is included in the Beacon frame. */
+					/* 	The P2P Device Info attribute is included in the probe response frame. */
 
 					memset(attr_content, 0x00, 100);
 					if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
 					{
-						//	Handle the P2P Device ID attribute of Beacon first
+						/* 	Handle the P2P Device ID attribute of Beacon first */
 						blnMatch = 1;
 						break;
 
 					} else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
 					{
-						//	Handle the P2P Device Info attribute of probe response
+						/* 	Handle the P2P Device Info attribute of probe response */
 						blnMatch = 1;
 						break;
 					}
 
-					//Get the next P2P IE
+					/* Get the next P2P IE */
 					p2pie = rtw_get_p2p_ie(p2pie + p2pielen, pnetwork->network.IELength - 12 - (p2pie - &pnetwork->network.IEs[12] + p2pielen), NULL, &p2pielen);
 				}
 			}
@@ -4299,12 +4153,12 @@ static int rtw_p2p_get_device_type(struc
 	u8 blnMatch = 0;
 	u8 dev_type[8] = { 0x00 };
 	uint dev_type_len = 0;
-	u8 dev_type_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };    // +9 is for the str "dev_type=", we have to clear it at wrqu->data.pointer
+	u8 dev_type_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };    /*  +9 is for the str "dev_type=", we have to clear it at wrqu->data.pointer */
 
-	//	Commented by Albert 20121209
-	//	The input data is the MAC address which the application wants to know its device type.
-	//	Such user interface could know the device type.
-	//	Format: iwpriv wlanx p2p_get2 dev_type=00:E0:4C:00:00:05
+	/* 	Commented by Albert 20121209 */
+	/* 	The input data is the MAC address which the application wants to know its device type. */
+	/* 	Such user interface could know the device type. */
+	/* 	Format: iwpriv wlanx p2p_get2 dev_type=00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
 
@@ -4325,7 +4179,7 @@ static int rtw_p2p_get_device_type(struc
 			u8 *wpsie;
 			uint	wpsie_len = 0;
 
-			//	The mac address is matched.
+			/* 	The mac address is matched. */
 
 			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
 			{
@@ -4377,10 +4231,10 @@ static int rtw_p2p_get_device_name(struc
 	uint dev_len = 0;
 	u8 dev_name_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
 
-	//	Commented by Albert 20121225
-	//	The input data is the MAC address which the application wants to know its device name.
-	//	Such user interface could show peer device's device name instead of ssid.
-	//	Format: iwpriv wlanx p2p_get2 devN=00:E0:4C:00:00:05
+	/* 	Commented by Albert 20121225 */
+	/* 	The input data is the MAC address which the application wants to know its device name. */
+	/* 	Such user interface could show peer device's device name instead of ssid. */
+	/* 	Format: iwpriv wlanx p2p_get2 devN=00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
 
@@ -4401,7 +4255,7 @@ static int rtw_p2p_get_device_name(struc
 			u8 *wpsie;
 			uint	wpsie_len = 0;
 
-			//	The mac address is matched.
+			/* 	The mac address is matched. */
 
 			if ((wpsie = rtw_get_wps_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &wpsie_len)))
 			{
@@ -4450,9 +4304,9 @@ static int rtw_p2p_get_invitation_proced
 	u8 attr_content[2] = { 0x00 };
 	u8 inv_proc_str[P2P_PRIVATE_IOCTL_SET_LEN] = { 0x00 };
 
-	//	Commented by Ouden 20121226
-	//	The application wants to know P2P initation procedure is support or not.
-	//	Format: iwpriv wlanx p2p_get2 InvProc=00:E0:4C:00:00:05
+	/* 	Commented by Ouden 20121226 */
+	/* 	The application wants to know P2P initation procedure is support or not. */
+	/* 	Format: iwpriv wlanx p2p_get2 InvProc=00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, subcmd);
 
@@ -4470,24 +4324,23 @@ static int rtw_p2p_get_invitation_proced
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 		if (_rtw_memcmp(pnetwork->network.MacAddress, peerMAC, ETH_ALEN))
 		{
-			//	Commented by Albert 20121226
-			//	Match the device address located in the P2P IE
-			//	This is for the case that the P2P device address is not the same as the P2P interface address.
+			/* 	Commented by Albert 20121226 */
+			/* 	Match the device address located in the P2P IE */
+			/* 	This is for the case that the P2P device address is not the same as the P2P interface address. */
 
 			if ((p2pie = rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
 			{
 				while (p2pie)
 				{
-					//memset(attr_content, 0x00, 2);
 					if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_CAPABILITY, attr_content, &attr_contentlen))
 					{
-						//	Handle the P2P capability attribute
+						/* 	Handle the P2P capability attribute */
 						blnMatch = 1;
 						break;
 
 					}
 
-					//Get the next P2P IE
+					/* Get the next P2P IE */
 					p2pie = rtw_get_p2p_ie(p2pie + p2pielen, pnetwork->network.IELength - 12 - (p2pie - &pnetwork->network.IEs[12] + p2pielen), NULL, &p2pielen);
 				}
 			}
@@ -4538,15 +4391,15 @@ static int rtw_p2p_connect(struct net_de
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
 
-	//	Commented by Albert 20110304
-	//	The input data contains two informations.
-	//	1. First information is the MAC address which wants to formate with
-	//	2. Second information is the WPS PINCode or "pbc" string for push button method
-	//	Format: 00:E0:4C:00:00:05
-	//	Format: 00:E0:4C:00:00:05
+	/* 	Commented by Albert 20110304 */
+	/* 	The input data contains two informations. */
+	/* 	1. First information is the MAC address which wants to formate with */
+	/* 	2. Second information is the WPS PINCode or "pbc" string for push button method */
+	/* 	Format: 00:E0:4C:00:00:05 */
+	/* 	Format: 00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
@@ -4596,7 +4449,7 @@ static int rtw_p2p_connect(struct net_de
 		{
 			_cancel_timer_ex(&pwdinfo->ap_p2p_switch_timer);
 		}
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
 		memset(&pwdinfo->nego_req_info, 0x00, sizeof(struct tx_nego_req_info));
 		memset(&pwdinfo->groupid_info, 0x00, sizeof(struct group_id_info));
@@ -4608,7 +4461,7 @@ static int rtw_p2p_connect(struct net_de
 		_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
 		if (rtw_p2p_state(pwdinfo) != P2P_STATE_GONEGO_OK)
 		{
-			//	Restore to the listen state if the current p2p state is not nego OK
+			/* 	Restore to the listen state if the current p2p state is not nego OK */
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
 		}
 
@@ -4618,12 +4471,12 @@ static int rtw_p2p_connect(struct net_de
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_buddy_fwstate(padapter, _FW_LINKED))
 		{
-			//	Have to enter the power saving with the AP
+			/* 	Have to enter the power saving with the AP */
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 
 			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
 		}
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
 		DBG_8192D("[%s] Start PreTx Procedure!\n", __func__);
 		_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
@@ -4639,7 +4492,7 @@ static int rtw_p2p_connect(struct net_de
 		}
 #else
 		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_GO_NEGO_TIMEOUT);
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
 	}
 	else
@@ -4675,18 +4528,18 @@ static int rtw_p2p_invite_req(struct net
 	struct rtw_adapter					*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_priv			*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
 	struct mlme_ext_priv		*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
 #ifdef CONFIG_WFD
 	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
-	//	Commented by Albert 20120321
-	//	The input data contains two informations.
-	//	1. First information is the P2P device address which you want to send to.
-	//	2. Second information is the group id which combines with GO's mac address, space and GO's ssid.
-	//	Command line sample: iwpriv wlan0 p2p_set invite="00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy"
-	//	Format: 00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy
+	/* 	Commented by Albert 20120321 */
+	/* 	The input data contains two informations. */
+	/* 	1. First information is the P2P device address which you want to send to. */
+	/* 	2. Second information is the group id which combines with GO's mac address, space and GO's ssid. */
+	/* 	Command line sample: iwpriv wlan0 p2p_set invite="00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy" */
+	/* 	Format: 00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
@@ -4703,7 +4556,7 @@ static int rtw_p2p_invite_req(struct net
 	}
 	else
 	{
-		//	Reset the content of struct tx_invite_req_info
+		/* 	Reset the content of struct tx_invite_req_info */
 		pinvite_req_info->benable = false;
 		memset(pinvite_req_info->go_bssid, 0x00, ETH_ALEN);
 		memset(pinvite_req_info->go_ssid, 0x00, WLAN_SSID_MAXLEN);
@@ -4730,18 +4583,18 @@ static int rtw_p2p_invite_req(struct net
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		//	Commented by Albert 2011/05/18
-		//	Match the device address located in the P2P IE
-		//	This is for the case that the P2P device address is not the same as the P2P interface address.
+		/* 	Commented by Albert 2011/05/18 */
+		/* 	Match the device address located in the P2P IE */
+		/* 	This is for the case that the P2P device address is not the same as the P2P interface address. */
 
 		if ((p2pie=rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
 		{
-			//	The P2P Device ID attribute is included in the Beacon frame.
-			//	The P2P Device Info attribute is included in the probe response frame.
+			/* 	The P2P Device ID attribute is included in the Beacon frame. */
+			/* 	The P2P Device Info attribute is included in the probe response frame. */
 
 			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
 			{
-				//	Handle the P2P Device ID attribute of Beacon first
+				/* 	Handle the P2P Device ID attribute of Beacon first */
 				if (_rtw_memcmp(attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN))
 				{
 					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
@@ -4750,7 +4603,7 @@ static int rtw_p2p_invite_req(struct net
 			}
 			else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
 			{
-				//	Handle the P2P Device Info attribute of probe response
+				/* 	Handle the P2P Device Info attribute of probe response */
 				if (_rtw_memcmp(attr_content, pinvite_req_info->peer_macaddr, ETH_ALEN))
 				{
 					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
@@ -4782,9 +4635,9 @@ static int rtw_p2p_invite_req(struct net
 			{
 				u16	wfd_devinfo_field = 0;
 
-				//	Commented by Albert 20120319
-				//	The first two bytes are the WFD device information field of WFD device information subelement.
-				//	In big endian format.
+				/* 	Commented by Albert 20120319 */
+				/* 	The first two bytes are the WFD device information field of WFD device information subelement. */
+				/* 	In big endian format. */
 				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
 				if (wfd_devinfo_field & WFD_DEVINFO_SESSION_AVAIL)
 				{
@@ -4803,7 +4656,7 @@ static int rtw_p2p_invite_req(struct net
 			goto exit;
 		}
 	}
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
 	if (uintPeerChannel)
 	{
@@ -4812,15 +4665,15 @@ static int rtw_p2p_invite_req(struct net
 		{
 			_cancel_timer_ex(&pwdinfo->ap_p2p_switch_timer);
 		}
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
-		//	Store the GO's bssid
+		/* 	Store the GO's bssid */
 		for (jj = 0, kk = 18; jj < ETH_ALEN; jj++, kk += 3)
 		{
 			pinvite_req_info->go_bssid[jj] = key_2char2num(extra[kk], extra[kk+ 1]);
 		}
 
-		//	Store the GO's ssid
+		/* 	Store the GO's ssid */
 		pinvite_req_info->ssidlen = wrqu->data.length - 36;
 		memcpy(pinvite_req_info->go_ssid, &extra[36], (u32) pinvite_req_info->ssidlen);
 		pinvite_req_info->benable = true;
@@ -4832,7 +4685,7 @@ static int rtw_p2p_invite_req(struct net
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
 		{
-			//	Have to enter the power saving with the AP
+			/* 	Have to enter the power saving with the AP */
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 
 			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
@@ -4858,7 +4711,7 @@ static int rtw_p2p_invite_req(struct net
 		}
 #else
 		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT);
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
 
 	}
@@ -4895,16 +4748,16 @@ static int rtw_p2p_set_persistent(struct
 	struct rtw_adapter					*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_priv			*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
 	struct mlme_ext_priv		*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
 #ifdef CONFIG_WFD
 	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
-	//	Commented by Albert 20120328
-	//	The input data is 0 or 1
-	//	0: disable persistent group functionality
-	//	1: enable persistent group founctionality
+	/* 	Commented by Albert 20120328 */
+	/* 	The input data is 0 or 1 */
+	/* 	0: disable persistent group functionality */
+	/* 	1: enable persistent group founctionality */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
@@ -4915,11 +4768,11 @@ static int rtw_p2p_set_persistent(struct
 	}
 	else
 	{
-		if (extra[0] == '0')	//	Disable the persistent group function.
+		if (extra[0] == '0')	/* 	Disable the persistent group function. */
 		{
 			pwdinfo->persistent_supported = false;
 		}
-		else if (extra[0] == '1')	//	Enable the persistent group function.
+		else if (extra[0] == '1')	/* 	Enable the persistent group function. */
 		{
 			pwdinfo->persistent_supported = true;
 		}
@@ -4959,12 +4812,12 @@ static int rtw_p2p_set_pc(struct net_dev
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
 
-	//	Commented by Albert 20120512
-	//	1. Input information is the MAC address which wants to know the Preferred Connection bit (PC bit)
-	//	Format: 00:E0:4C:00:00:05
+	/* 	Commented by Albert 20120512 */
+	/* 	1. Input information is the MAC address which wants to know the Preferred Connection bit (PC bit) */
+	/* 	Format: 00:E0:4C:00:00:05 */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
@@ -4991,18 +4844,18 @@ static int rtw_p2p_set_pc(struct net_dev
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		//	Commented by Albert 2011/05/18
-		//	Match the device address located in the P2P IE
-		//	This is for the case that the P2P device address is not the same as the P2P interface address.
+		/* 	Commented by Albert 2011/05/18 */
+		/* 	Match the device address located in the P2P IE */
+		/* 	This is for the case that the P2P device address is not the same as the P2P interface address. */
 
 		if ((p2pie=rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
 		{
-			//	The P2P Device ID attribute is included in the Beacon frame.
-			//	The P2P Device Info attribute is included in the probe response frame.
+			/* 	The P2P Device ID attribute is included in the Beacon frame. */
+			/* 	The P2P Device Info attribute is included in the probe response frame. */
 			DBG_8192D("[%s] Got P2P IE\n", __func__);
 			if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
 			{
-				//	Handle the P2P Device ID attribute of Beacon first
+				/* 	Handle the P2P Device ID attribute of Beacon first */
 				DBG_8192D("[%s] P2P_ATTR_DEVICE_ID\n", __func__);
 				if (_rtw_memcmp(attr_content, peerMAC, ETH_ALEN))
 				{
@@ -5012,7 +4865,7 @@ static int rtw_p2p_set_pc(struct net_dev
 			}
 			else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
 			{
-				//	Handle the P2P Device Info attribute of probe response
+				/* 	Handle the P2P Device Info attribute of probe response */
 				DBG_8192D("[%s] P2P_ATTR_DEVICE_INFO\n", __func__);
 				if (_rtw_memcmp(attr_content, peerMAC, ETH_ALEN))
 				{
@@ -5045,9 +4898,9 @@ static int rtw_p2p_set_pc(struct net_dev
 			{
 				u16	wfd_devinfo_field = 0;
 
-				//	Commented by Albert 20120319
-				//	The first two bytes are the WFD device information field of WFD device information subelement.
-				//	In big endian format.
+				/* 	Commented by Albert 20120319 */
+				/* 	The first two bytes are the WFD device information field of WFD device information subelement. */
+				/* 	In big endian format. */
 				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
 				if (wfd_devinfo_field & WFD_DEVINFO_PC_TDLS)
 				{
@@ -5081,18 +4934,18 @@ static int rtw_p2p_set_wfd_device_type(s
 	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
 	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
 
-	//	Commented by Albert 20120328
-	//	The input data is 0 or 1
-	//	0: specify to Miracast source device
-	//	1 or others: specify to Miracast sink device (display device)
+	/* 	Commented by Albert 20120328 */
+	/* 	The input data is 0 or 1 */
+	/* 	0: specify to Miracast source device */
+	/* 	1 or others: specify to Miracast sink device (display device) */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
-	if (extra[0] == '0')	//	Set to Miracast source device.
+	if (extra[0] == '0')	/* 	Set to Miracast source device. */
 	{
 		pwfd_info->wfd_device_type = WFD_DEVINFO_SOURCE;
 	}
-	else					//	Set to Miracast sink device.
+	else					/* 	Set to Miracast sink device. */
 	{
 		pwfd_info->wfd_device_type = WFD_DEVINFO_PSINK;
 	}
@@ -5113,13 +4966,13 @@ static int rtw_p2p_set_scan_result_type(
 	struct wifidirect_info		*pwdinfo = &(padapter->wdinfo);
 	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
 
-	//	Commented by Albert 20120328
-	//	The input data is 0 , 1 , 2
-	//	0: when the P2P is enabled, the scan result will return all the found P2P device.
-	//	1: when the P2P is enabled, the scan result will return all the found P2P device and AP.
-	//	2: when the P2P is enabled, the scan result will show up the found Miracast devices base on...
-	//	It will show up all the Miracast source device if this device is sink.
-	//	It will show up all the Miracast sink device if this device is source.
+	/* 	Commented by Albert 20120328 */
+	/* 	The input data is 0 , 1 , 2 */
+	/* 	0: when the P2P is enabled, the scan result will return all the found P2P device. */
+	/* 	1: when the P2P is enabled, the scan result will return all the found P2P device and AP. */
+	/* 	2: when the P2P is enabled, the scan result will show up the found Miracast devices base on... */
+	/* 	It will show up all the Miracast source device if this device is sink. */
+	/* 	It will show up all the Miracast sink device if this device is source. */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
@@ -5145,7 +4998,7 @@ exit:
 	return ret;
 }
 
-//	To set the WFD session available to enable or disable
+/* 	To set the WFD session available to enable or disable */
 static int rtw_p2p_set_sa(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
@@ -5159,9 +5012,9 @@ static int rtw_p2p_set_sa(struct net_dev
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
-	if (extra[0] == '0')	//	Disable the session available.
+	if (extra[0] == '0')	/* 	Disable the session available. */
 		pwdinfo->session_available = false;
-	else if (extra[0] == '1')	//	Enable the session available.
+	else if (extra[0] == '1')	/* 	Enable the session available. */
 		pwdinfo->session_available = true;
 	else
 		pwdinfo->session_available = false;
@@ -5171,7 +5024,7 @@ exit:
 
 	return ret;
 }
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 static int rtw_p2p_prov_disc(struct net_device *dev,
                                struct iw_request_info *info,
@@ -5194,20 +5047,20 @@ static int rtw_p2p_prov_disc(struct net_
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
 #ifdef CONFIG_WFD
 	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
-	//	Commented by Albert 20110301
-	//	The input data contains two informations.
-	//	1. First information is the MAC address which wants to issue the provisioning discovery request frame.
-	//	2. Second information is the WPS configuration method which wants to discovery
-	//	Format: 00:E0:4C:00:00:05_display
-	//	Format: 00:E0:4C:00:00:05_keypad
-	//	Format: 00:E0:4C:00:00:05_pbc
-	//	Format: 00:E0:4C:00:00:05_label
+	/* 	Commented by Albert 20110301 */
+	/* 	The input data contains two informations. */
+	/* 	1. First information is the MAC address which wants to issue the provisioning discovery request frame. */
+	/* 	2. Second information is the WPS configuration method which wants to discovery */
+	/* 	Format: 00:E0:4C:00:00:05_display */
+	/* 	Format: 00:E0:4C:00:00:05_keypad */
+	/* 	Format: 00:E0:4C:00:00:05_pbc */
+	/* 	Format: 00:E0:4C:00:00:05_label */
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
 
@@ -5218,7 +5071,7 @@ static int rtw_p2p_prov_disc(struct net_
 	}
 	else
 	{
-		//	Reset the content of struct tx_provdisc_req_info excluded the wps_config_method_request.
+		/* 	Reset the content of struct tx_provdisc_req_info excluded the wps_config_method_request. */
 		memset(pwdinfo->tx_prov_disc_info.peerDevAddr, 0x00, ETH_ALEN);
 		memset(pwdinfo->tx_prov_disc_info.peerIFAddr, 0x00, ETH_ALEN);
 		memset(&pwdinfo->tx_prov_disc_info.ssid, 0x00, sizeof(struct ndis_802_11_ssid));
@@ -5269,20 +5122,20 @@ static int rtw_p2p_prov_disc(struct net_
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		//	Commented by Albert 2011/05/18
-		//	Match the device address located in the P2P IE
-		//	This is for the case that the P2P device address is not the same as the P2P interface address.
+		/* 	Commented by Albert 2011/05/18 */
+		/* 	Match the device address located in the P2P IE */
+		/* 	This is for the case that the P2P device address is not the same as the P2P interface address. */
 
 		if ((p2pie=rtw_get_p2p_ie(&pnetwork->network.IEs[12], pnetwork->network.IELength - 12, NULL, &p2pielen)))
 		{
 			while (p2pie)
 			{
-				//	The P2P Device ID attribute is included in the Beacon frame.
-				//	The P2P Device Info attribute is included in the probe response frame.
+				/* 	The P2P Device ID attribute is included in the Beacon frame. */
+				/* 	The P2P Device Info attribute is included in the probe response frame. */
 
 				if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_ID, attr_content, &attr_contentlen))
 				{
-					//	Handle the P2P Device ID attribute of Beacon first
+					/* 	Handle the P2P Device ID attribute of Beacon first */
 					if (_rtw_memcmp(attr_content, peerMAC, ETH_ALEN))
 					{
 						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
@@ -5291,7 +5144,7 @@ static int rtw_p2p_prov_disc(struct net_
 				}
 				else if (rtw_get_p2p_attr_content(p2pie, p2pielen, P2P_ATTR_DEVICE_INFO, attr_content, &attr_contentlen))
 				{
-					//	Handle the P2P Device Info attribute of probe response
+					/* 	Handle the P2P Device Info attribute of probe response */
 					if (_rtw_memcmp(attr_content, peerMAC, ETH_ALEN))
 					{
 						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
@@ -5299,7 +5152,7 @@ static int rtw_p2p_prov_disc(struct net_
 					}
 				}
 
-				//Get the next P2P IE
+				/* Get the next P2P IE */
 				p2pie = rtw_get_p2p_ie(p2pie+p2pielen, pnetwork->network.IELength - 12 -(p2pie -&pnetwork->network.IEs[12] + p2pielen), NULL, &p2pielen);
 			}
 		}
@@ -5325,9 +5178,9 @@ static int rtw_p2p_prov_disc(struct net_
 			{
 				u16	wfd_devinfo_field = 0;
 
-				//	Commented by Albert 20120319
-				//	The first two bytes are the WFD device information field of WFD device information subelement.
-				//	In big endian format.
+				/* 	Commented by Albert 20120319 */
+				/* 	The first two bytes are the WFD device information field of WFD device information subelement. */
+				/* 	In big endian format. */
 				wfd_devinfo_field = RTW_GET_BE16(wfd_devinfo);
 				if (wfd_devinfo_field & WFD_DEVINFO_SESSION_AVAIL)
 				{
@@ -5346,7 +5199,7 @@ static int rtw_p2p_prov_disc(struct net_
 			goto exit;
 		}
 	}
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
 	if (uintPeerChannel)
 	{
@@ -5357,7 +5210,7 @@ static int rtw_p2p_prov_disc(struct net_
 		{
 			_cancel_timer_ex(&pwdinfo->ap_p2p_switch_timer);
 		}
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 		memcpy(pwdinfo->tx_prov_disc_info.peerIFAddr, pnetwork->network.MacAddress, ETH_ALEN);
 		memcpy(pwdinfo->tx_prov_disc_info.peerDevAddr, peerMAC, ETH_ALEN);
 		pwdinfo->tx_prov_disc_info.peer_channel_num[0] = (u16) uintPeerChannel;
@@ -5378,7 +5231,7 @@ static int rtw_p2p_prov_disc(struct net_
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_buddy_fwstate(padapter, _FW_LINKED))
 		{
-			//	Have to enter the power saving with the AP
+			/* 	Have to enter the power saving with the AP */
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 
 			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
@@ -5404,7 +5257,7 @@ static int rtw_p2p_prov_disc(struct net_
 		}
 #else
 		_set_timer(&pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT);
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
 
 	}
@@ -5417,9 +5270,9 @@ exit:
 	return ret;
 }
 
-//	Added by Albert 20110328
-//	This function is used to inform the driver the user had specified the pin code value or pbc
-//	to application.
+/* 	Added by Albert 20110328 */
+/* 	This function is used to inform the driver the user had specified the pin code value or pbc */
+/* 	to application. */
 
 static int rtw_p2p_got_wpsinfo(struct net_device *dev,
                                struct iw_request_info *info,
@@ -5432,11 +5285,11 @@ static int rtw_p2p_got_wpsinfo(struct ne
 
 
 	DBG_8192D("[%s] data = %s\n", __func__, extra);
-	//	Added by Albert 20110328
-	//	if the input data is P2P_NO_WPSINFO -> reset the wpsinfo
-	//	if the input data is P2P_GOT_WPSINFO_PEER_DISPLAY_PIN -> the utility just input the PIN code got from the peer P2P device.
-	//	if the input data is P2P_GOT_WPSINFO_SELF_DISPLAY_PIN -> the utility just got the PIN code from itself.
-	//	if the input data is P2P_GOT_WPSINFO_PBC -> the utility just determine to use the PBC
+	/* 	Added by Albert 20110328 */
+	/* 	if the input data is P2P_NO_WPSINFO -> reset the wpsinfo */
+	/* 	if the input data is P2P_GOT_WPSINFO_PEER_DISPLAY_PIN -> the utility just input the PIN code got from the peer P2P device. */
+	/* 	if the input data is P2P_GOT_WPSINFO_SELF_DISPLAY_PIN -> the utility just got the PIN code from itself. */
+	/* 	if the input data is P2P_GOT_WPSINFO_PBC -> the utility just determine to use the PBC */
 
 	if (*extra == '0')
 	{
@@ -5462,7 +5315,7 @@ static int rtw_p2p_got_wpsinfo(struct ne
 	return ret;
 }
 
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 static int rtw_p2p_set(struct net_device *dev,
                                struct iw_request_info *info,
@@ -5506,9 +5359,9 @@ static int rtw_p2p_set(struct net_device
 	}
 	else if (_rtw_memcmp(extra, "intent=", 7))
 	{
-		//	Commented by Albert 2011/03/23
-		//	The wrqu->data.length will include the null character
-		//	So, we will decrease 7 + 1
+		/* 	Commented by Albert 2011/03/23 */
+		/* 	The wrqu->data.length will include the null character */
+		/* 	So, we will decrease 7 + 1 */
 		wrqu->data.length -= 8;
 		rtw_p2p_set_intent(dev, info, wrqu, &extra[7]);
 	}
@@ -5524,17 +5377,17 @@ static int rtw_p2p_set(struct net_device
 	}
 	else if (_rtw_memcmp(extra, "listen_ch=", 10))
 	{
-		//	Commented by Albert 2011/05/24
-		//	The wrqu->data.length will include the null character
-		//	So, we will decrease (10 + 1)
+		/* 	Commented by Albert 2011/05/24 */
+		/* 	The wrqu->data.length will include the null character */
+		/* 	So, we will decrease (10 + 1) */
 		wrqu->data.length -= 11;
 		rtw_p2p_set_listen_ch(dev, info, wrqu, &extra[10]);
 	}
 	else if (_rtw_memcmp(extra, "op_ch=", 6))
 	{
-		//	Commented by Albert 2011/05/24
-		//	The wrqu->data.length will include the null character
-		//	So, we will decrease (6 + 1)
+		/* 	Commented by Albert 2011/05/24 */
+		/* 	The wrqu->data.length will include the null character */
+		/* 	So, we will decrease (6 + 1) */
 		wrqu->data.length -= 7;
 		rtw_p2p_set_op_ch(dev, info, wrqu, &extra[6]);
 	}
@@ -5551,19 +5404,19 @@ static int rtw_p2p_set(struct net_device
 #ifdef CONFIG_WFD
 	else if (_rtw_memcmp(extra, "sa=", 3))
 	{
-		//	sa: WFD Session Available information
+		/* 	sa: WFD Session Available information */
 		wrqu->data.length -= 3;
 		rtw_p2p_set_sa(dev, info, wrqu, &extra[3]);
 	}
 	else if (_rtw_memcmp(extra, "pc=", 3))
 	{
-		//	pc: WFD Preferred Connection
+		/* 	pc: WFD Preferred Connection */
 		wrqu->data.length -= 3;
 		rtw_p2p_set_pc(dev, info, wrqu, &extra[3]);
 	}
 	else if (_rtw_memcmp(extra, "wfd_type=", 9))
 	{
-		//	Specify this device is Mircast source or sink
+		/* 	Specify this device is Mircast source or sink */
 		wrqu->data.length -= 9;
 		rtw_p2p_set_wfd_device_type(dev, info, wrqu, &extra[9]);
 	}
@@ -5572,9 +5425,9 @@ static int rtw_p2p_set(struct net_device
 		wrqu->data.length -= 10;
 		rtw_p2p_set_scan_result_type(dev, info, wrqu, &extra[10]);
 	}
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	return ret;
 }
@@ -5606,12 +5459,12 @@ static int rtw_p2p_get(struct net_device
 	} else if (_rtw_memcmp(wrqu->data.pointer, "req_cm", 6)) {
 		rtw_p2p_get_req_cm(dev, info, wrqu, extra);
 	} else if (_rtw_memcmp(wrqu->data.pointer, "peer_deva", 9)) {
-		//	Get the P2P device address when receiving the provision discovery request frame.
+		/* 	Get the P2P device address when receiving the provision discovery request frame. */
 		rtw_p2p_get_peer_devaddr(dev, info, wrqu, extra);
 	} else if (_rtw_memcmp(wrqu->data.pointer, "group_id", 8)) {
 		rtw_p2p_get_groupid(dev, info, wrqu, extra);
 	} else if (_rtw_memcmp(wrqu->data.pointer, "peer_deva_inv", 9)) {
-		//	Get the P2P device address when receiving the P2P Invitation request frame.
+		/* 	Get the P2P device address when receiving the P2P Invitation request frame. */
 		rtw_p2p_get_peer_devaddr_by_invitation(dev, info, wrqu, extra);
 	} else if (_rtw_memcmp(wrqu->data.pointer, "op_ch", 5)) {
 		rtw_p2p_get_op_ch(dev, info, wrqu, extra);
@@ -5624,9 +5477,9 @@ static int rtw_p2p_get(struct net_device
 	} else if (_rtw_memcmp(wrqu->data.pointer, "wfd_pc", 6)) {
 		rtw_p2p_get_peer_wfd_preferred_connection(dev, info, wrqu, extra);
 	}
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	return ret;
 }
@@ -5681,7 +5534,7 @@ static int rtw_p2p_get2(struct net_devic
 bad:
 	kfree(buffer);
 
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	return ret;
 }
@@ -5709,7 +5562,7 @@ static int rtw_rereg_nd_name(struct net_
 		rereg_priv->old_ifname[IFNAMSIZ-1] = 0;
 	}
 
-	//DBG_8192D("%s wrqu->data.length:%d\n", __func__, wrqu->data.length);
+	/* DBG_8192D("%s wrqu->data.length:%d\n", __func__, wrqu->data.length); */
 	if (wrqu->data.length > IFNAMSIZ)
 		return -EFAULT;
 
@@ -5738,16 +5591,16 @@ static int rtw_rereg_nd_name(struct net_
 	if (_rtw_memcmp(new_ifname, "disable%d", 9) == true) {
 
 		DBG_8192D("%s disable\n", __func__);
-		// free network queue for Android's timming issue
+		/*  free network queue for Android's timming issue */
 		rtw_free_network_queue(padapter, true);
 
-		// close led
+		/*  close led */
 		rtw_led_control(padapter, LED_CTL_POWER_OFF);
 		rereg_priv->old_bRegUseLed = padapter->ledpriv.bRegUseLed;
 		padapter->ledpriv.bRegUseLed= false;
 		rtw_hal_sw_led_deinit(padapter);
 
-		// the interface is being "disabled", we can do deeper IPS
+		/*  the interface is being "disabled", we can do deeper IPS */
 		rereg_priv->old_ips_mode = rtw_get_ips_mode_req(&padapter->pwrctrlpriv);
 		rtw_ips_mode_req(&padapter->pwrctrlpriv, IPS_NORMAL);
 	}
@@ -5802,7 +5655,7 @@ void rf_reg_dump(struct rtw_adapter *pad
 		DBG_8192D("\nRF_Path(%x)\n",path);
 		for (i=0;i<0x100;i++)
 		{
-			//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
+			/* value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord); */
 			value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
 			if (j%4==1)	DBG_8192D("0x%02x ",i);
 			DBG_8192D(" 0x%08x ",value);
@@ -5840,7 +5693,7 @@ static int rtw_dbg_port(struct net_devic
 
 	switch (major_cmd)
 	{
-		case 0x70://read_reg
+		case 0x70:/* read_reg */
 			switch (minor_cmd)
 			{
 				case 1:
@@ -5854,7 +5707,7 @@ static int rtw_dbg_port(struct net_devic
 					break;
 			}
 			break;
-		case 0x71://write_reg
+		case 0x71:/* write_reg */
 			switch (minor_cmd)
 			{
 				case 1:
@@ -5871,17 +5724,17 @@ static int rtw_dbg_port(struct net_devic
 					break;
 			}
 			break;
-		case 0x72://read_bb
+		case 0x72:/* read_bb */
 			DBG_8192D("read_bbreg(0x%x)=0x%x\n", arg, rtw_hal_read_bbreg(padapter, arg, 0xffffffff));
 			break;
-		case 0x73://write_bb
+		case 0x73:/* write_bb */
 			rtw_hal_write_bbreg(padapter, arg, 0xffffffff, extra_arg);
 			DBG_8192D("write_bbreg(0x%x)=0x%x\n", arg, rtw_hal_read_bbreg(padapter, arg, 0xffffffff));
 			break;
-		case 0x74://read_rf
+		case 0x74:/* read_rf */
 			DBG_8192D("read RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n",minor_cmd,arg,rtw_hal_read_rfreg(padapter, minor_cmd, arg, 0xffffffff));
 			break;
-		case 0x75://write_rf
+		case 0x75:/* write_rf */
 			rtw_hal_write_rfreg(padapter, minor_cmd, arg, 0xffffffff, extra_arg);
 			DBG_8192D("write RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n",minor_cmd,arg, rtw_hal_read_rfreg(padapter, minor_cmd, arg, 0xffffffff));
 			break;
@@ -5889,10 +5742,10 @@ static int rtw_dbg_port(struct net_devic
 		case 0x76:
 			switch (minor_cmd)
 			{
-				case 0x00: //normal mode,
+				case 0x00: /* normal mode, */
 					padapter->recvpriv.is_signal_dbg = 0;
 					break;
-				case 0x01: //dbg mode
+				case 0x01: /* dbg mode */
 					padapter->recvpriv.is_signal_dbg = 1;
 					extra_arg = extra_arg>100?100:extra_arg;
 					extra_arg = extra_arg<0?0:extra_arg;
@@ -5900,7 +5753,7 @@ static int rtw_dbg_port(struct net_devic
 					break;
 			}
 			break;
-		case 0x78: //IOL test
+		case 0x78: /* IOL test */
 			break;
 		case 0x7a:
 			receive_disconnect(padapter, pmlmeinfo->network.MacAddress
@@ -6048,10 +5901,10 @@ static int rtw_dbg_port(struct net_devic
 					}
 					break;
 
-                                case 0x0c://dump rx packet
+                                case 0x0c:/* dump rx packet */
 					{
 						DBG_8192D("dump rx packet (%d)\n",extra_arg);
-						//pHalData->bDumpRxPkt =extra_arg;
+						/* pHalData->bDumpRxPkt =extra_arg; */
 						rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DUMP_RXPKT, &(extra_arg));
 					}
 					break;
@@ -6074,7 +5927,7 @@ static int rtw_dbg_port(struct net_devic
 
 		#endif
 
-				case 0x10:// driver version display
+				case 0x10:/*  driver version display */
 					DBG_8192D("rtw driver version=%s\n", DRIVERVERSION);
 					break;
 				case 0x11:
@@ -6083,11 +5936,11 @@ static int rtw_dbg_port(struct net_devic
 						padapter->bRxRSSIDisplay = extra_arg ;
 					}
 					break;
-				case 0x12: //set rx_stbc
+				case 0x12: /* set rx_stbc */
 				{
 					struct registry_priv	*pregpriv = &padapter->registrypriv;
-					// 0: disable, bit(0):enable 2.4g, bit(1):enable 5g, 0x3: enable both 2.4g and 5g
-					//default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ
+					/*  0: disable, bit(0):enable 2.4g, bit(1):enable 5g, 0x3: enable both 2.4g and 5g */
+					/* default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ */
 					if (pregpriv && (extra_arg == 0 || extra_arg == 1|| extra_arg == 2 || extra_arg == 3))
 					{
 						pregpriv->rx_stbc= extra_arg;
@@ -6098,10 +5951,10 @@ static int rtw_dbg_port(struct net_devic
 
 				}
 				break;
-				case 0x13: //set ampdu_enable
+				case 0x13: /* set ampdu_enable */
 				{
 					struct registry_priv	*pregpriv = &padapter->registrypriv;
-					// 0: disable, 0x1:enable (but wifi_spec should be 0), 0x2: force enable (don't care wifi_spec)
+					/*  0: disable, 0x1:enable (but wifi_spec should be 0), 0x2: force enable (don't care wifi_spec) */
 					if (pregpriv && extra_arg >= 0 && extra_arg < 3)
 					{
 						pregpriv->ampdu_enable= extra_arg;
@@ -6112,7 +5965,7 @@ static int rtw_dbg_port(struct net_devic
 
 				}
 				break;
-				case 0x14: //get wifi_spec
+				case 0x14: /* get wifi_spec */
 				{
 					struct registry_priv	*pregpriv = &padapter->registrypriv;
 					DBG_8192D("get wifi_spec=%d\n",pregpriv->wifi_spec);
@@ -6136,10 +5989,10 @@ static int rtw_dbg_port(struct net_devic
 #ifdef CONFIG_P2P
 						DBG_8192D("turn %s the bShowGetP2PState Variable\n",(extra_arg==1)?"on":"off");
 						padapter->bShowGetP2PState = extra_arg;
-#endif // CONFIG_P2P
+#endif /*  CONFIG_P2P */
 						break;
 					}
-				case 0xdd://registers dump , 0 for mac reg,1 for bb reg, 2 for rf reg
+				case 0xdd:/* registers dump , 0 for mac reg,1 for bb reg, 2 for rf reg */
 					if (extra_arg==0) {
 						mac_reg_dump(padapter);
 					}
@@ -6151,7 +6004,7 @@ static int rtw_dbg_port(struct net_devic
 					}
 
 					break;
-				case 0xee://turn on/off dynamic funcs
+				case 0xee:/* turn on/off dynamic funcs */
 					{
 						u8 dm_flag;
 
@@ -6238,18 +6091,18 @@ static int wpa_set_param(struct net_devi
 	switch (name) {
 	case IEEE_PARAM_WPA_ENABLED:
 
-		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X; //802.1x
+		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X; /* 802.1x */
 
-		//ret = ieee80211_wpa_enable(ieee, value);
+		/* ret = ieee80211_wpa_enable(ieee, value); */
 
 		switch ((value)&0xff)
 		{
-			case 1 : //WPA
-			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPAPSK; //WPA_PSK
+			case 1 : /* WPA */
+			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPAPSK; /* WPA_PSK */
 			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION2ENABLED;
 				break;
-			case 2: //WPA2
-			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPA2PSK; //WPA2_PSK
+			case 2: /* WPA2 */
+			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPA2PSK; /* WPA2_PSK */
 			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION3ENABLED;
 				break;
 		}
@@ -6259,7 +6112,7 @@ static int wpa_set_param(struct net_devi
 		break;
 
 	case IEEE_PARAM_TKIP_COUNTERMEASURES:
-		//ieee->tkip_countermeasures=value;
+		/* ieee->tkip_countermeasures=value; */
 		break;
 
 	case IEEE_PARAM_DROP_UNENCRYPTED:
@@ -6281,7 +6134,7 @@ static int wpa_set_param(struct net_devi
 	}
 	case IEEE_PARAM_PRIVACY_INVOKED:
 
-		//ieee->privacy_invoked=value;
+		/* ieee->privacy_invoked=value; */
 
 		break;
 
@@ -6293,14 +6146,14 @@ static int wpa_set_param(struct net_devi
 
 	case IEEE_PARAM_IEEE_802_1X:
 
-		//ieee->ieee802_1x=value;
+		/* ieee->ieee802_1x=value; */
 
 		break;
 
 	case IEEE_PARAM_WPAX_SELECT:
 
-		// added for WPA2 mixed mode
-		//DBG_8192D(KERN_WARNING "------------------------>wpax value = %x\n", value);
+		/*  added for WPA2 mixed mode */
+		/* DBG_8192D(KERN_WARNING "------------------------>wpax value = %x\n", value); */
 		/*
 		spin_lock_irqsave(&ieee->wpax_suitlist_lock,flags);
 		ieee->wpax_type_set = 1;
@@ -6358,7 +6211,7 @@ static int wpa_supplicant_ioctl(struct n
 	struct ieee_param *param;
 	uint ret=0;
 
-	//down(&ieee->wx_sem);
+	/* down(&ieee->wx_sem); */
 
 	if (p->length < sizeof(struct ieee_param) || !p->pointer) {
 		ret = -EINVAL;
@@ -6386,7 +6239,7 @@ static int wpa_supplicant_ioctl(struct n
 		break;
 
 	case IEEE_CMD_SET_WPA_IE:
-		//ret = wpa_set_wpa_ie(dev, param, p->length);
+		/* ret = wpa_set_wpa_ie(dev, param, p->length); */
 		ret =  rtw_set_wpa_ie((struct rtw_adapter *)rtw_netdev_priv(dev), (char*)param->u.wpa_ie.data, (u16)param->u.wpa_ie.len);
 		break;
 
@@ -6412,7 +6265,7 @@ static int wpa_supplicant_ioctl(struct n
 
 out:
 
-	//up(&ieee->wx_sem);
+	/* up(&ieee->wx_sem); */
 
 	return ret;
 }
@@ -6556,8 +6409,8 @@ static int rtw_set_encryption(struct net
 	param->u.crypt.err = 0;
 	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
 
-	//sizeof(struct ieee_param) = 64 bytes;
-	//if (param_len !=  (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
+	/* sizeof(struct ieee_param) = 64 bytes; */
+	/* if (param_len !=  (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len) */
 	if (param_len !=  sizeof(struct ieee_param) + param->u.crypt.key_len)
 	{
 		ret =  -EINVAL;
@@ -6579,7 +6432,7 @@ static int rtw_set_encryption(struct net
 		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
 		if (!psta)
 		{
-			//ret = -EINVAL;
+			/* ret = -EINVAL; */
 			DBG_8192D("rtw_set_encryption(), sta has already been removed or never been added\n");
 			goto exit;
 		}
@@ -6587,7 +6440,7 @@ static int rtw_set_encryption(struct net
 
 	if (strcmp(param->u.crypt.alg, "none") == 0 && (psta==NULL))
 	{
-		//todo:clear default encryption keys
+		/* todo:clear default encryption keys */
 
 		DBG_8192D("clear default encryption keys, keyid=%d\n", param->u.crypt.idx);
 
@@ -6661,8 +6514,8 @@ static int rtw_set_encryption(struct net
 		{
 			DBG_8192D("wep, set_tx=0\n");
 
-			//don't update "psecuritypriv->dot11PrivacyAlgrthm" and
-			//"psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to cam
+			/* don't update "psecuritypriv->dot11PrivacyAlgrthm" and */
+			/* psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to cam */
 
 		      memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
 
@@ -6677,7 +6530,7 @@ static int rtw_set_encryption(struct net
 	}
 
 
-	if (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) // //group key
+	if (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) /*  group key */
 	{
 		if (param->u.crypt.set_tx ==1)
 		{
@@ -6702,8 +6555,8 @@ static int rtw_set_encryption(struct net
 
 				memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
-				//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
-				//set mic key
+				/* DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len); */
+				/* set mic key */
 				memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 				memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 
@@ -6729,7 +6582,7 @@ static int rtw_set_encryption(struct net
 
 			psecuritypriv->binstallGrpkey = true;
 
-			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
+			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;/*  */
 
 			set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
 
@@ -6737,7 +6590,7 @@ static int rtw_set_encryption(struct net
 			if (pbcmc_sta)
 			{
 				pbcmc_sta->ieee8021x_blocked = false;
-				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
+				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;/* rx will use bmc_sta's dot118021XPrivacy */
 			}
 
 		}
@@ -6746,7 +6599,7 @@ static int rtw_set_encryption(struct net
 
 	}
 
-	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) // psk/802_1x
+	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) /*  psk/802_1x */
 	{
 		if (check_fwstate(pmlmepriv, WIFI_AP_STATE))
 		{
@@ -6770,8 +6623,8 @@ static int rtw_set_encryption(struct net
 
 					psta->dot118021XPrivacy = _TKIP_;
 
-					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
-					//set mic key
+					/* DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len); */
+					/* set mic key */
 					memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 					memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
@@ -6797,7 +6650,7 @@ static int rtw_set_encryption(struct net
 				psta->ieee8021x_blocked = false;
 
 			}
-			else//group key???
+			else/* group key??? */
 			{
 				if (strcmp(param->u.crypt.alg, "WEP") == 0)
 				{
@@ -6815,8 +6668,8 @@ static int rtw_set_encryption(struct net
 
 					memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 
-					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
-					//set mic key
+					/* DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len); */
+					/* set mic key */
 					memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 					memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 
@@ -6838,7 +6691,7 @@ static int rtw_set_encryption(struct net
 
 				psecuritypriv->binstallGrpkey = true;
 
-				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
+				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;/*  */
 
 				set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
 
@@ -6846,7 +6699,7 @@ static int rtw_set_encryption(struct net
 				if (pbcmc_sta)
 				{
 					pbcmc_sta->ieee8021x_blocked = false;
-					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
+					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;/* rx will use bmc_sta's dot118021XPrivacy */
 				}
 
 			}
@@ -6882,7 +6735,7 @@ static int rtw_set_beacon(struct net_dev
 		pstapriv->max_num_sta = NUM_STA;
 
 
-	if (rtw_check_beacon_data(padapter, pbuf,  (len-12-2)) == _SUCCESS)// 12 = param header, 2:no packed
+	if (rtw_check_beacon_data(padapter, pbuf,  (len-12-2)) == _SUCCESS)/*  12 = param header, 2:no packed */
 		ret = 0;
 	else
 		ret = -EINVAL;
@@ -6898,7 +6751,7 @@ static int rtw_hostapd_sta_flush(struct
 
 	DBG_8192D("%s\n", __func__);
 
-	flush_all_cam_entry(padapter);	//clear CAM
+	flush_all_cam_entry(padapter);	/* clear CAM */
 
 	ret = rtw_sta_flush(padapter);
 
@@ -6939,20 +6792,20 @@ static int rtw_add_sta(struct net_device
 		psta = NULL;
 	}
 */
-	//psta = rtw_alloc_stainfo(pstapriv, param->sta_addr);
+	/* psta = rtw_alloc_stainfo(pstapriv, param->sta_addr); */
 	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
 	if (psta)
 	{
 		int flags = param->u.add_sta.flags;
 
-		//DBG_8192D("rtw_add_sta(), init sta's variables, psta=%p\n", psta);
+		/* DBG_8192D("rtw_add_sta(), init sta's variables, psta=%p\n", psta); */
 
-		psta->aid = param->u.add_sta.aid;//aid=1~2007
+		psta->aid = param->u.add_sta.aid;/* aid=1~2007 */
 
 		memcpy(psta->bssrateset, param->u.add_sta.tx_supp_rates, 16);
 
 
-		//check wmm cap.
+		/* check wmm cap. */
 		if (WLAN_STA_WME&flags)
 			psta->qos_option = 1;
 		else
@@ -6963,7 +6816,7 @@ static int rtw_add_sta(struct net_device
 
 
 #ifdef CONFIG_80211N_HT
-		//chec 802.11n ht cap.
+		/* chec 802.11n ht cap. */
 		if (WLAN_STA_HT&flags)
 		{
 			psta->htpriv.ht_option = true;
@@ -7014,7 +6867,7 @@ static int rtw_del_sta(struct net_device
 	if (psta) {
 		u8 updated;
 
-		//DBG_8192D("free psta=%p, aid=%d\n", psta, psta->aid);
+		/* DBG_8192D("free psta=%p, aid=%d\n", psta, psta->aid); */
 
 		spin_lock_bh(&pstapriv->asoc_list_lock);
 		if (rtw_is_list_empty(&psta->asoc_list)==false)
@@ -7035,7 +6888,7 @@ static int rtw_del_sta(struct net_device
 	{
 		DBG_8192D("rtw_del_sta(), sta has already been removed or never been added\n");
 
-		//ret = -1;
+		/* ret = -1; */
 	}
 
 
@@ -7152,7 +7005,7 @@ static int rtw_get_sta_wpaie(struct net_
 		}
 		else
 		{
-			//ret = -1;
+			/* ret = -1; */
 			DBG_8192D("sta's wpa_ie is NONE\n");
 		}
 	}
@@ -7179,7 +7032,7 @@ static int rtw_set_wps_beacon(struct net
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
-	ie_len = len-12-2;// 12 = param header, 2:no packed
+	ie_len = len-12-2;/*  12 = param header, 2:no packed */
 
 
 	kfree(pmlmepriv->wps_beacon_ie);
@@ -7218,7 +7071,7 @@ static int rtw_set_wps_probe_resp(struct
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
-	ie_len = len-12-2;// 12 = param header, 2:no packed
+	ie_len = len-12-2;/*  12 = param header, 2:no packed */
 
 
 	kfree(pmlmepriv->wps_probe_resp_ie);
@@ -7251,7 +7104,7 @@ static int rtw_set_wps_assoc_resp(struct
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
 		return -EINVAL;
 
-	ie_len = len-12-2;// 12 = param header, 2:no packed
+	ie_len = len-12-2;/*  12 = param header, 2:no packed */
 
 
 	kfree(pmlmepriv->wps_assoc_resp_ie);
@@ -7293,7 +7146,7 @@ static int rtw_set_hidden_ssid(struct ne
 
 	mlmeinfo->hidden_ssid_mode = ignore_broadcast_ssid = param->u.bcn_ie.reserved[1];
 
-	ie_len = len-12-2;// 12 = param header, 2:no packed
+	ie_len = len-12-2;/*  12 = param header, 2:no packed */
 	ssid_ie = rtw_get_ie(param->u.bcn_ie.buf,  WLAN_EID_SSID, &ssid_len, ie_len);
 
 	if (ssid_ie && ssid_len) {
@@ -7378,7 +7231,7 @@ static int rtw_hostapd_ioctl(struct net_
 	int ret=0;
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
-	//DBG_8192D("%s\n", __func__);
+	/* DBG_8192D("%s\n", __func__); */
 
 	/*
 	* this function is expect to call in master mode, which allows no power saving
@@ -7391,7 +7244,7 @@ static int rtw_hostapd_ioctl(struct net_
 	}
 
 
-	//if (p->length < sizeof(struct ieee_param) || !p->pointer) {
+	/* if (p->length < sizeof(struct ieee_param) || !p->pointer) { */
 	if (!p->pointer) {
 		ret = -EINVAL;
 		goto out;
@@ -7411,7 +7264,7 @@ static int rtw_hostapd_ioctl(struct net_
 		goto out;
 	}
 
-	//DBG_8192D("%s, cmd=%d\n", __func__, param->cmd);
+	/* DBG_8192D("%s, cmd=%d\n", __func__, param->cmd); */
 
 	switch (param->cmd)
 	{
@@ -7537,7 +7390,7 @@ static int rtw_wx_set_priv(struct net_de
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 	struct iw_point *dwrq = (struct iw_point*)awrq;
 
-	//RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+rtw_wx_set_priv\n"));
+	/* RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+rtw_wx_set_priv\n")); */
 	if (dwrq->length == 0)
 		return -EFAULT;
 	len = dwrq->length;
@@ -7550,9 +7403,9 @@ static int rtw_wx_set_priv(struct net_de
 	}
 
 
-	//RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
-	//	 ("rtw_wx_set_priv: %s req=%s\n",
-	//	  dev->name, ext));
+	/* RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, */
+	/* 	 ("rtw_wx_set_priv: %s req=%s\n", */
+	/* 	  dev->name, ext)); */
 
 	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
 	if (!(ext_dbg = rtw_vmalloc(len)))
@@ -7564,7 +7417,7 @@ static int rtw_wx_set_priv(struct net_de
 	memcpy(ext_dbg, ext, len);
 	#endif
 
-	//added for wps2.0 @20110524
+	/* added for wps2.0 @20110524 */
 	if (dwrq->flags == 0x8766 && len > 8)
 	{
 		u32 cp_sz;
@@ -7578,8 +7431,8 @@ static int rtw_wx_set_priv(struct net_de
 		{
 			cp_sz = probereq_wpsie_len>MAX_WPS_IE_LEN ? MAX_WPS_IE_LEN:probereq_wpsie_len;
 
-			//memcpy(pmlmepriv->probereq_wpsie, probereq_wpsie, cp_sz);
-			//pmlmepriv->probereq_wpsie_len = cp_sz;
+			/* memcpy(pmlmepriv->probereq_wpsie, probereq_wpsie, cp_sz); */
+			/* pmlmepriv->probereq_wpsie_len = cp_sz; */
 
 			DBG_8192D("probe_req_wps_ielen=%d\n", cp_sz);
 
@@ -7616,7 +7469,7 @@ static int rtw_wx_set_priv(struct net_de
 	}
 
 #ifdef CONFIG_ANDROID
-	//DBG_8192D("rtw_wx_set_priv: %s req=%s\n", dev->name, ext);
+	/* DBG_8192D("rtw_wx_set_priv: %s req=%s\n", dev->name, ext); */
 
 	i = rtw_android_cmdstr_to_num(ext);
 
@@ -7650,13 +7503,13 @@ static int rtw_wx_set_priv(struct net_de
 			break;
 		case ANDROID_WIFI_CMD_SCAN_ACTIVE :
 			{
-				//rtw_set_scan_mode(padapter, SCAN_ACTIVE);
+				/* rtw_set_scan_mode(padapter, SCAN_ACTIVE); */
 				sprintf(ext, "OK");
 			}
 			break;
 		case ANDROID_WIFI_CMD_SCAN_PASSIVE :
 			{
-				//rtw_set_scan_mode(padapter, SCAN_PASSIVE);
+				/* rtw_set_scan_mode(padapter, SCAN_PASSIVE); */
 				sprintf(ext, "OK");
 			}
 			break;
@@ -7686,7 +7539,7 @@ static int rtw_wx_set_priv(struct net_de
 	DBG_8192D("%s: %s req=%s rep=%s dwrq->length=%d, strlen(ext)+1=%d\n", __func__,
 		dev->name, ext_dbg ,ext, dwrq->length, (u16)(strlen(ext)+1));
 	#endif
-#endif //end of CONFIG_ANDROID
+#endif /* end of CONFIG_ANDROID */
 
 
 FREE_EXT:
@@ -7696,8 +7549,8 @@ FREE_EXT:
 	rtw_vmfree(ext_dbg, len);
 	#endif
 
-	//DBG_8192D("rtw_wx_set_priv: (SIOCSIWPRIV) %s ret=%d\n",
-	//		dev->name, ret);
+	/* DBG_8192D("rtw_wx_set_priv: (SIOCSIWPRIV) %s ret=%d\n", */
+	/* 		dev->name, ret); */
 
 	return ret;
 }
@@ -7727,7 +7580,7 @@ static int rtw_mp_efuse_get(struct net_d
 	DBG_8192D("%s: in=%s\n", __func__, extra);
 
 	i=0;
-	//mac 16 "00e04c871200" rmap,00,2
+	/* mac 16 "00e04c871200" rmap,00,2 */
 	while ((token = strsep (&pch,","))!=NULL)
 	{
 			if (i>2) break;
@@ -7775,7 +7628,7 @@ static int rtw_mp_efuse_get(struct net_d
 	}
 	else if (strcmp(tmp[0],"rmap") == 0) {
 		if (tmp[1]==NULL || tmp[2]==NULL) return	-EINVAL;
-		// rmap addr cnts
+		/*  rmap addr cnts */
 		addr = simple_strtoul(tmp[1], &ptmp, 16);
 
 		DBG_8192D("addr = %x\n" ,addr);
@@ -7784,7 +7637,7 @@ static int rtw_mp_efuse_get(struct net_d
 		if (cnts==0) return -EINVAL;
 
 		DBG_8192D("cnts = %d\n" ,cnts);
-		//memset(extra, '\0', wrqu->data.length);
+		/* memset(extra, '\0', wrqu->data.length); */
 
 		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
 		if ((addr + cnts) > max_available_size) {
@@ -7940,8 +7793,8 @@ static int rtw_mp_efuse_set(struct net_d
 		i++;
 	}
 
-	// tmp[0],[1],[2]
-	// wmap,addr,00e04c871200
+	/*  tmp[0],[1],[2] */
+	/*  wmap,addr,00e04c871200 */
 	if (strcmp(tmp[0],"wmap") == 0) {
 		 if (tmp[1]==NULL || tmp[2]==NULL) return	-EINVAL;
 			if (! strlen(tmp[2])/2 > 1) return -EFAULT;
@@ -8003,7 +7856,7 @@ static int rtw_mp_efuse_set(struct net_d
 		}
 	else if (strcmp(tmp[0],"mac") == 0) {
 			 if (tmp[1]==NULL || tmp[2]==NULL) return	-EINVAL;
-			//mac,00e04c871200
+			/* mac,00e04c871200 */
 				addr = 0x19;
 				cnts = strlen(tmp[1])/2;
 				if (cnts == 0) return -EFAULT;
@@ -8036,7 +7889,7 @@ static int rtw_mp_efuse_set(struct net_d
 		else if (strcmp(tmp[0],"vidpid") == 0) {
 			if (tmp[1]==NULL || tmp[2]==NULL)
 				return	-EINVAL;
-				// pidvid,da0b7881
+				/*  pidvid,da0b7881 */
 			addr = 0x0c;
 
 			cnts=strlen(tmp[1])/2;
@@ -8093,8 +7946,8 @@ static int rtw_wfd_tdls_enable(struct ne
 		padapter->wdinfo.wfd_tdls_enable = 1;
 	}
 
-#endif //CONFIG_WFD
-#endif //CONFIG_TDLS
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_TDLS */
 
 	return ret;
 }
@@ -8187,7 +8040,7 @@ static int rtw_tdls_enable(struct net_de
 	} else if (extra[0] == '1') {
 		ptdlsinfo->enable = 1;
 	}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	return ret;
 }
@@ -8206,7 +8059,7 @@ static int rtw_tdls_setup(struct net_dev
 
 #ifdef CONFIG_WFD
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
 	DBG_8192D("[%s] %s %d\n", __func__, extra, wrqu->data.length -1);
 
@@ -8217,10 +8070,10 @@ static int rtw_tdls_setup(struct net_dev
 #ifdef CONFIG_WFD
 	if (_AES_ != padapter->securitypriv.dot11PrivacyAlgrthm)
 	{
-		//	Weak Security situation with AP.
+		/* 	Weak Security situation with AP. */
 		if (0 == pwdinfo->wfd_tdls_weaksec)
 		{
-			//	Can't send the tdls setup request out!!
+			/* 	Can't send the tdls setup request out!! */
 			DBG_8192D("[%s] Current link is not AES, SKIP sending the tdls setup request!!\n", __func__);
 		}
 		else
@@ -8229,7 +8082,7 @@ static int rtw_tdls_setup(struct net_dev
 		}
 	}
 	else
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 	{
 		issue_tdls_setup_req(padapter, mac_addr);
 	}
@@ -8265,7 +8118,7 @@ static int rtw_tdls_teardown(struct net_
 		issue_tdls_teardown(padapter, mac_addr);
 	}
 
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	return ret;
 }
@@ -8286,7 +8139,7 @@ static int rtw_tdls_discovery(struct net
 
 	issue_tdls_dis_req(padapter, NULL);
 
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	return ret;
 }
@@ -8317,7 +8170,7 @@ static int rtw_tdls_ch_switch (struct ne
 
 	rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_INIT_CH_SEN);
 
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 		return ret;
 }
@@ -8346,7 +8199,7 @@ static int rtw_tdls_pson(struct net_devi
 
 	issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 1);
 
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 		return ret;
 }
@@ -8375,7 +8228,7 @@ static int rtw_tdls_psoff(struct net_dev
 
 	issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 0);
 
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	return ret;
 }
@@ -8422,8 +8275,8 @@ static int rtw_tdls_setip(struct net_dev
 		ptdlsinfo->wfd_info->ip_address[2], ptdlsinfo->wfd_info->ip_address[3]
 	);
 
-#endif //CONFIG_WFD
-#endif //CONFIG_TDLS
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_TDLS */
 
 	return ret;
 }
@@ -8455,8 +8308,8 @@ static int rtw_tdls_getip(struct net_dev
 
 	wrqu->data.length = strlen(extra);
 
-#endif //CONFIG_WFD
-#endif //CONFIG_TDLS
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_TDLS */
 
 	return ret;
 }
@@ -8482,13 +8335,13 @@ static int rtw_tdls_getport(struct net_d
 
 	wrqu->data.length = strlen(extra);
 
-#endif //CONFIG_WFD
-#endif //CONFIG_TDLS
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_TDLS */
 
 	return ret;
 }
 
-//WFDTDLS, for sigma test
+/* WFDTDLS, for sigma test */
 static int rtw_tdls_dis_result(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
@@ -8513,13 +8366,13 @@ static int rtw_tdls_dis_result(struct ne
 
 	wrqu->data.length = strlen(extra);
 
-#endif //CONFIG_WFD
-#endif //CONFIG_TDLS
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_TDLS */
 
 	return ret;
 }
 
-//WFDTDLS, for sigma test
+/* WFDTDLS, for sigma test */
 static int rtw_wfd_tdls_status(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
@@ -8547,8 +8400,8 @@ static int rtw_wfd_tdls_status(struct ne
 
 	wrqu->data.length = strlen(extra);
 
-#endif //CONFIG_WFD
-#endif //CONFIG_TDLS
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_TDLS */
 
 	return ret;
 }
@@ -8582,7 +8435,7 @@ static int rtw_tdls_ch_switch_off(struct
 	}
 */
 
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	return ret;
 }
@@ -8597,7 +8450,7 @@ static int rtw_tdls(struct net_device *d
 	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
 
 	DBG_8192D("[%s] extra = %s\n", __func__, extra);
-	//	WFD Sigma will use the tdls enable command to let the driver know we want to test the tdls now!
+	/* 	WFD Sigma will use the tdls enable command to let the driver know we want to test the tdls now! */
 	if (_rtw_memcmp(extra, "wfdenable=", 10))
 	{
 		wrqu->data.length -=10;
@@ -8668,9 +8521,9 @@ static int rtw_tdls(struct net_device *d
 	{
 		issue_tunneled_probe_req((struct rtw_adapter *)rtw_netdev_priv(dev));
 	}
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	return ret;
 }
@@ -8695,7 +8548,7 @@ static int rtw_tdls_get(struct net_devic
 		rtw_tdls_getport(dev, info, wrqu, extra);
 	}
 
-	//WFDTDLS, for sigma test
+	/* WFDTDLS, for sigma test */
 	if (_rtw_memcmp(wrqu->data.pointer, "dis", 3))
 	{
 		rtw_tdls_dis_result(dev, info, wrqu, extra);
@@ -8705,7 +8558,7 @@ static int rtw_tdls_get(struct net_devic
 		rtw_wfd_tdls_status(dev, info, wrqu, extra);
 	}
 
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	return ret;
 }
@@ -8747,9 +8600,9 @@ static int rtw_wowlan_ctrl(struct net_de
 
 	struct iw_point *p = &wrqu->data;
 
-	//DBG_8192D("+rtw_wowlan_ctrl\n");
+	/* DBG_8192D("+rtw_wowlan_ctrl\n"); */
 
-	//mutex_lock(&ioctl_mutex);
+	/* mutex_lock(&ioctl_mutex); */
 
 	if ((!p->length) || (!p->pointer)) {
 		ret = -EINVAL;
@@ -8793,7 +8646,7 @@ _rtw_wowlan_ctrl_exit:
 
 	return ret;
 }
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 
 #ifdef CONFIG_INTEL_WIDI
 static int rtw_widi_set(struct net_device *dev,
@@ -8824,7 +8677,7 @@ static int rtw_widi_set_probe_request(st
 	return ret;
 }
 
-#endif // CONFIG_INTEL_WIDI
+#endif /*  CONFIG_INTEL_WIDI */
 
 static int rtw_test(
 	struct net_device *dev,
@@ -8989,7 +8842,7 @@ static const struct iw_priv_args rtw_pri
 	{
 		SIOCIWFIRSTPRIV + 0xE,0,0, "wowlan_ctrl"
 	},
-#endif // CONFIG_WOWLAN
+#endif /*  CONFIG_WOWLAN */
 	{
 		SIOCIWFIRSTPRIV + 0x10,
 		IW_PRIV_TYPE_CHAR | P2P_PRIVATE_IOCTL_SET_LEN, 0, "p2p_set"
@@ -9035,61 +8888,61 @@ static const struct iw_priv_args rtw_pri
 		SIOCIWFIRSTPRIV + 0x1F,
 		IW_PRIV_TYPE_CHAR | 128, 0, "widi_prob_req"
 	},
-#endif // CONFIG_INTEL_WIDI
+#endif /*  CONFIG_INTEL_WIDI */
 };
 
 static iw_handler rtw_private_handler[] =
 {
-	rtw_wx_write32,					//0x00
-	rtw_wx_read32,					//0x01
-	rtw_drvext_hdl,					//0x02
-	rtw_mp_ioctl_hdl,				//0x03
-
-// for MM DTV platform
-	rtw_get_ap_info,					//0x04
-
-	rtw_set_pid,						//0x05
-	rtw_wps_start,					//0x06
-
-	rtw_wx_get_sensitivity,			//0x07
-	rtw_wx_set_mtk_wps_probe_ie,	//0x08
-	rtw_wx_set_mtk_wps_ie,			//0x09
-
-// Set Channel depend on the country code
-	rtw_wx_set_channel_plan,		//0x0A
-
-	rtw_dbg_port,					//0x0B
-	rtw_wx_write_rf,					//0x0C
-	rtw_wx_read_rf,					//0x0D
+	rtw_wx_write32,					/* 0x00 */
+	rtw_wx_read32,					/* 0x01 */
+	rtw_drvext_hdl,					/* 0x02 */
+	rtw_mp_ioctl_hdl,				/* 0x03 */
+
+/*  for MM DTV platform */
+	rtw_get_ap_info,					/* 0x04 */
+
+	rtw_set_pid,						/* 0x05 */
+	rtw_wps_start,					/* 0x06 */
+
+	rtw_wx_get_sensitivity,			/* 0x07 */
+	rtw_wx_set_mtk_wps_probe_ie,	/* 0x08 */
+	rtw_wx_set_mtk_wps_ie,			/* 0x09 */
+
+/*  Set Channel depend on the country code */
+	rtw_wx_set_channel_plan,		/* 0x0A */
+
+	rtw_dbg_port,					/* 0x0B */
+	rtw_wx_write_rf,					/* 0x0C */
+	rtw_wx_read_rf,					/* 0x0D */
 
 #ifdef CONFIG_WOWLAN
-	rtw_wowlan_ctrl,					//0x0E
+	rtw_wowlan_ctrl,					/* 0x0E */
 #else
-	rtw_wx_priv_null,				//0x0E
-#endif //CONFIG_WOWLAN
-	rtw_wx_priv_null,				//0x0F
-
-	rtw_p2p_set,					//0x10
-	rtw_p2p_get,					//0x11
-	NULL,							//0x12
-	rtw_p2p_get2,					//0x13
-
-	rtw_tdls,						//0x14
-	rtw_tdls_get,					//0x15
-
-	rtw_pm_set,						//0x16
-	rtw_wx_priv_null,				//0x17
-	rtw_rereg_nd_name,				//0x18
-	rtw_wx_priv_null,				//0x19
-
-	rtw_mp_efuse_set,				//0x1A
-	rtw_mp_efuse_get,				//0x1B
-	NULL,							// 0x1C is reserved for hostapd
-	rtw_test	,						// 0x1D
+	rtw_wx_priv_null,				/* 0x0E */
+#endif /* CONFIG_WOWLAN */
+	rtw_wx_priv_null,				/* 0x0F */
+
+	rtw_p2p_set,					/* 0x10 */
+	rtw_p2p_get,					/* 0x11 */
+	NULL,							/* 0x12 */
+	rtw_p2p_get2,					/* 0x13 */
+
+	rtw_tdls,						/* 0x14 */
+	rtw_tdls_get,					/* 0x15 */
+
+	rtw_pm_set,						/* 0x16 */
+	rtw_wx_priv_null,				/* 0x17 */
+	rtw_rereg_nd_name,				/* 0x18 */
+	rtw_wx_priv_null,				/* 0x19 */
+
+	rtw_mp_efuse_set,				/* 0x1A */
+	rtw_mp_efuse_get,				/* 0x1B */
+	NULL,							/*  0x1C is reserved for hostapd */
+	rtw_test	,						/*  0x1D */
 #ifdef CONFIG_INTEL_WIDI
-	rtw_widi_set,					//0x1E
-	rtw_widi_set_probe_request,		//0x1F
-#endif // CONFIG_INTEL_WIDI
+	rtw_widi_set,					/* 0x1E */
+	rtw_widi_set_probe_request,		/* 0x1F */
+#endif /*  CONFIG_INTEL_WIDI */
 };
 
 #if WIRELESS_EXT >= 17
@@ -9106,7 +8959,7 @@ static struct iw_statistics *rtw_get_wir
 		piwstats->qual.qual = 0;
 		piwstats->qual.level = 0;
 		piwstats->qual.noise = 0;
-		//DBG_8192D("No link  level:%d, qual:%d, noise:%d\n", tmp_level, tmp_qual, tmp_noise);
+		/* DBG_8192D("No link  level:%d, qual:%d, noise:%d\n", tmp_level, tmp_qual, tmp_noise); */
 	}
 	else {
 		#ifdef CONFIG_SIGNAL_DISPLAY_DBM
@@ -9117,14 +8970,14 @@ static struct iw_statistics *rtw_get_wir
 
 		tmp_qual = padapter->recvpriv.signal_qual;
 		tmp_noise =padapter->recvpriv.noise;
-		//DBG_8192D("level:%d, qual:%d, noise:%d, rssi (%d)\n", tmp_level, tmp_qual, tmp_noise,padapter->recvpriv.rssi);
+		/* DBG_8192D("level:%d, qual:%d, noise:%d, rssi (%d)\n", tmp_level, tmp_qual, tmp_noise,padapter->recvpriv.rssi); */
 
 		piwstats->qual.level = tmp_level;
 		piwstats->qual.qual = tmp_qual;
 		piwstats->qual.noise = tmp_noise;
 	}
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14))
-	piwstats->qual.updated = IW_QUAL_ALL_UPDATED ;//|IW_QUAL_DBM;
+	piwstats->qual.updated = IW_QUAL_ALL_UPDATED ;/* IW_QUAL_DBM; */
 #else
 #endif
 
--- a/drivers/staging/rtl8192du/os_dep/mlme_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/mlme_linux.c
@@ -63,7 +63,6 @@ void rtw_init_mlme_timer(struct rtw_adap
 	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
 	_init_timer(&(pmlmepriv->assoc_timer), padapter->pnetdev, rtw_join_timeout_handler, padapter);
-	//_init_timer(&(pmlmepriv->sitesurveyctrl.sitesurvey_ctrl_timer), padapter->pnetdev, sitesurvey_ctrl_handler, padapter);
 	_init_timer(&(pmlmepriv->scan_to_timer), padapter->pnetdev, _rtw_scan_timeout_handler, padapter);
 
 	_init_timer(&(pmlmepriv->dynamic_chk_timer), padapter->pnetdev, _dynamic_check_timer_handlder, padapter);
@@ -83,7 +82,7 @@ _func_enter_;
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_cfg80211_indicate_connect(adapter);
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 	rtw_indicate_wx_assoc_event(adapter);
 	netif_carrier_on(adapter->pnetdev);
@@ -110,13 +109,13 @@ void rtw_reset_securitypriv(struct rtw_a
 	u8	backupTKIPCountermeasure = 0x00;
 	u32	backupTKIPcountermeasure_time = 0;
 
-	if (adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)//802.1x
+	if (adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)/* 802.1x */
 	{
-		// Added by Albert 2009/02/18
-		// We have to backup the PMK information for WiFi PMK Caching test item.
-		//
-		// Backup the btkip_countermeasure information.
-		// When the countermeasure is trigger, the driver have to disconnect with AP for 60 seconds.
+		/*  Added by Albert 2009/02/18 */
+		/*  We have to backup the PMK information for WiFi PMK Caching test item. */
+		/*  */
+		/*  Backup the btkip_countermeasure information. */
+		/*  When the countermeasure is trigger, the driver have to disconnect with AP for 60 seconds. */
 
 		memset(&backupPMKIDList[0], 0x00, sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
 
@@ -126,10 +125,9 @@ void rtw_reset_securitypriv(struct rtw_a
 		backupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;
 
 		memset((unsigned char *)&adapter->securitypriv, 0, sizeof (struct security_priv));
-		//_init_timer(&(adapter->securitypriv.tkip_timer),adapter->pnetdev, rtw_use_tkipkey_handler, adapter);
 
-		// Added by Albert 2009/02/18
-		// Restore the PMK information to securitypriv structure for the following connection.
+		/*  Added by Albert 2009/02/18 */
+		/*  Restore the PMK information to securitypriv structure for the following connection. */
 		memcpy(&adapter->securitypriv.PMKIDList[0], &backupPMKIDList[0], sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
 		adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
 		adapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
@@ -139,13 +137,11 @@ void rtw_reset_securitypriv(struct rtw_a
 		adapter->securitypriv.ndisencryptstatus = NDIS802_11WEPDISABLED;
 
 	}
-	else //reset values in securitypriv
+	else /* reset values in securitypriv */
 	{
-		//if (adapter->mlmepriv.fw_state & WIFI_STATION_STATE)
-		//{
 		struct security_priv *psec_priv=&adapter->securitypriv;
 
-		psec_priv->dot11AuthAlgrthm =dot11AuthAlgrthm_Open;  //open system
+		psec_priv->dot11AuthAlgrthm =dot11AuthAlgrthm_Open;  /* open system */
 		psec_priv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
 		psec_priv->dot11PrivacyKeyIndex = 0;
 
@@ -154,21 +150,20 @@ void rtw_reset_securitypriv(struct rtw_a
 
 		psec_priv->ndisauthtype = NDIS802_11AUTHMODEOPEN;
 		psec_priv->ndisencryptstatus = NDIS802_11WEPDISABLED;
-		//}
+		/*  */
 	}
 }
 
 void rtw_os_indicate_disconnect(struct rtw_adapter *adapter)
 {
-   //struct RT_PMKID_LIST   backupPMKIDList[NUM_PMKID_CACHE];
 
 _func_enter_;
 
-	netif_carrier_off(adapter->pnetdev); // Do it first for tx broadcast pkt after disconnection issue!
+	netif_carrier_off(adapter->pnetdev); /*  Do it first for tx broadcast pkt after disconnection issue! */
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_cfg80211_indicate_disconnect(adapter);
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 	rtw_indicate_wx_disassoc_event(adapter);
 
@@ -269,10 +264,6 @@ void init_mlme_ext_timer(struct rtw_adap
 
 	_init_timer(&pmlmeext->survey_timer, padapter->pnetdev, _survey_timer_hdl, padapter);
 	_init_timer(&pmlmeext->link_timer, padapter->pnetdev, _link_timer_hdl, padapter);
-	//_init_timer(&pmlmeext->ADDBA_timer, padapter->pnetdev, _addba_timer_hdl, padapter);
-
-	//_init_timer(&pmlmeext->reauth_timer, padapter->pnetdev, _reauth_timer_hdl, padapter);
-	//_init_timer(&pmlmeext->reassoc_timer, padapter->pnetdev, _reassoc_timer_hdl, padapter);
 }
 
 #ifdef CONFIG_AP_MODE
@@ -333,8 +324,6 @@ static int mgnt_xmit_entry(struct sk_buf
 	struct hostapd_priv *phostapdpriv = rtw_netdev_priv(pnetdev);
 	struct rtw_adapter *padapter = (struct rtw_adapter *)phostapdpriv->padapter;
 
-	//DBG_8192D("%s\n", __func__);
-
 	return rtw_hal_hostap_mgnt_xmit_entry(padapter, skb);
 }
 
@@ -355,8 +344,6 @@ static int mgnt_netdev_open(struct net_d
 
 	netif_carrier_on(pnetdev);
 
-	//rtw_write16(phostapdpriv->padapter, 0x0116, 0x0100);//only excluding beacon
-
 	return 0;
 }
 static int mgnt_netdev_close(struct net_device *pnetdev)
@@ -372,7 +359,6 @@ static int mgnt_netdev_close(struct net_
 	if (!rtw_netif_queue_stopped(pnetdev))
 		rtw_netif_stop_queue(pnetdev);
 
-	//rtw_write16(phostapdpriv->padapter, 0x0116, 0x3f3f);
 
 	return 0;
 }
@@ -382,9 +368,6 @@ static const struct net_device_ops rtl87
 	.ndo_open = mgnt_netdev_open,
        .ndo_stop = mgnt_netdev_close,
        .ndo_start_xmit = mgnt_xmit_entry,
-       //.ndo_set_mac_address = r871x_net_set_mac_address,
-       //.ndo_get_stats = r871x_net_get_stats,
-       //.ndo_do_ioctl = r871x_mp_ioctl,
 };
 #endif
 
@@ -398,17 +381,14 @@ int hostapd_mode_init(struct rtw_adapter
 	if (!pnetdev)
 	   return -ENOMEM;
 
-	//SET_MODULE_OWNER(pnetdev);
        ether_setup(pnetdev);
 
-	//pnetdev->type = ARPHRD_IEEE80211;
 
 	phostapdpriv = rtw_netdev_priv(pnetdev);
 	phostapdpriv->pmgnt_netdev = pnetdev;
 	phostapdpriv->padapter= padapter;
 	padapter->phostapdpriv = phostapdpriv;
 
-	//pnetdev->init = NULL;
 
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
 
@@ -424,31 +404,15 @@ int hostapd_mode_init(struct rtw_adapter
 
 	pnetdev->hard_start_xmit = mgnt_xmit_entry;
 
-	//pnetdev->set_mac_address = r871x_net_set_mac_address;
-
-	//pnetdev->get_stats = r871x_net_get_stats;
-
-	//pnetdev->do_ioctl = r871x_mp_ioctl;
-
 #endif
 
 	pnetdev->watchdog_timeo = HZ; /* 1 second timeout */
 
-	//pnetdev->wireless_handlers = NULL;
-
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
 	pnetdev->features |= NETIF_F_IP_CSUM;
 #endif
-
-
-
 	if (dev_alloc_name(pnetdev,"mgnt.wlan%d") < 0)
-	{
 		DBG_8192D("hostapd_mode_init(): dev_alloc_name, fail!\n");
-	}
-
-
-	//SET_NETDEV_DEV(pnetdev, pintfpriv->udev);
 
 
 	mac[0]=0x00;
--- a/drivers/staging/rtl8192du/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8192du/os_dep/osdep_service.c
@@ -38,8 +38,6 @@ inline int RTW_STATUS_CODE(int error_cod
 		return _SUCCESS;
 
 	switch (error_code) {
-		//case -ETIMEDOUT:
-		//	return RTW_STATUS_TIMEDOUT;
 		default:
 			return _FAIL;
 	}
@@ -109,7 +107,7 @@ u8* _rtw_zmalloc(u32 sz)
 
 int	_rtw_memcmp(void *dst, void *src, u32 sz)
 {
-//under Linux/GNU/GLibc, the return value of memcmp for two same mem. chunk is 0
+/* under Linux/GNU/GLibc, the return value of memcmp for two same mem. chunk is 0 */
 	if (!(memcmp(dst, src, sz)))
 		return true;
 	else
@@ -248,7 +246,7 @@ inline u32 rtw_ms_to_systime(u32 ms)
 	return ms * HZ / 1000;
 }
 
-// the input parameter start use the same unit as returned by rtw_get_current_time
+/*  the input parameter start use the same unit as returned by rtw_get_current_time */
 inline s32 rtw_get_passing_time_ms(u32 start)
 {
 	return rtw_systime_to_ms(jiffies-start);
@@ -263,9 +261,9 @@ void rtw_sleep_schedulable(int ms)
 {
     u32 delta;
 
-    delta = (ms * HZ)/1000;//(ms)
+    delta = (ms * HZ)/1000;/* ms) */
     if (delta == 0) {
-        delta = 1;// 1 ms
+        delta = 1;/*  1 ms */
     }
     set_current_state(TASK_INTERRUPTIBLE);
     if (schedule_timeout(delta) != 0) {
@@ -281,7 +279,6 @@ void rtw_msleep_os(int ms)
 
 void rtw_usleep_os(int us)
 {
-      // msleep((unsigned int)us);
       if (1 < (us/1000))
                 msleep(1);
       else
@@ -706,7 +703,7 @@ int rtw_change_ifname(struct rtw_adapter
 
 	rereg_priv = &padapter->rereg_nd_name_priv;
 
-	//free the old_pnetdev
+	/* free the old_pnetdev */
 	if (rereg_priv->old_pnetdev) {
 		free_netdev(rereg_priv->old_pnetdev);
 		rereg_priv->old_pnetdev = NULL;
--- a/drivers/staging/rtl8192du/os_dep/recv_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/recv_linux.c
@@ -31,7 +31,7 @@
 
 #include <usb_ops.h>
 
-//init os related resource in struct recv_priv
+/* init os related resource in struct recv_priv */
 int rtw_os_recv_resource_init(struct recv_priv *precvpriv, struct rtw_adapter *padapter)
 {
 	int	res=_SUCCESS;
@@ -39,7 +39,7 @@ int rtw_os_recv_resource_init(struct rec
 	return res;
 }
 
-//alloc os related resource in union recv_frame
+/* alloc os related resource in union recv_frame */
 int rtw_os_recv_resource_alloc(struct rtw_adapter *padapter, union recv_frame *precvframe)
 {
 	int	res=_SUCCESS;
@@ -49,13 +49,13 @@ int rtw_os_recv_resource_alloc(struct rt
 	return res;
 }
 
-//free os related resource in union recv_frame
+/* free os related resource in union recv_frame */
 void rtw_os_recv_resource_free(struct recv_priv *precvpriv)
 {
 }
 
 
-//alloc os related resource in struct recv_buf
+/* alloc os related resource in struct recv_buf */
 int rtw_os_recvbuf_resource_alloc(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
 {
 	int res=_SUCCESS;
@@ -86,11 +86,11 @@ int rtw_os_recvbuf_resource_alloc(struct
 	precvbuf->pbuf = precvbuf->pallocated_buf;
 	if (precvbuf->pallocated_buf == NULL)
 		return _FAIL;
-	#endif //CONFIG_USE_USB_BUFFER_ALLOC_RX
+	#endif /* CONFIG_USE_USB_BUFFER_ALLOC_RX */
 	return res;
 }
 
-//free os related resource in struct recv_buf
+/* free os related resource in struct recv_buf */
 int rtw_os_recvbuf_resource_free(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
 {
 	int ret = _SUCCESS;
@@ -104,11 +104,10 @@ int rtw_os_recvbuf_resource_free(struct
 	precvbuf->pallocated_buf =  NULL;
 	precvbuf->dma_transfer_addr = 0;
 
-#endif //CONFIG_USE_USB_BUFFER_ALLOC_RX
+#endif /* CONFIG_USE_USB_BUFFER_ALLOC_RX */
 
 	if (precvbuf->purb)
 	{
-		//usb_kill_urb(precvbuf->purb);
 		usb_free_urb(precvbuf->purb);
 	}
 
@@ -201,26 +200,19 @@ void rtw_hostapd_mlme_rx(struct rtw_adap
 	skb->tail = precv_frame->u.hdr.rx_tail;
 	skb->len = precv_frame->u.hdr.len;
 
-	//pskb_copy = skb_copy(skb, GFP_ATOMIC);
-//	if (skb == NULL) goto _exit;
-
 	skb->dev = pmgnt_netdev;
 	skb->ip_summed = CHECKSUM_NONE;
 	skb->pkt_type = PACKET_OTHERHOST;
-	//skb->protocol = __constant_htons(0x0019); /*ETH_P_80211_RAW*/
 	skb->protocol = __constant_htons(0x0003); /*ETH_P_80211_RAW*/
 
-	//DBG_871X("(1)data=0x%x, head=0x%x, tail=0x%x, mac_header=0x%x, len=%d\n", skb->data, skb->head, skb->tail, skb->mac_header, skb->len);
 
-	//skb->mac.raw = skb->data;
 	skb_reset_mac_header(skb);
 
-       //skb_pull(skb, 24);
        memset(skb->cb, 0, sizeof(skb->cb));
 
 	netif_rx(skb);
 
-	precv_frame->u.hdr.pkt = NULL; // set pointer to NULL before rtw_free_recvframe() if call netif_rx()
+	precv_frame->u.hdr.pkt = NULL; /*  set pointer to NULL before rtw_free_recvframe() if call netif_rx() */
 #endif
 }
 
@@ -277,12 +269,8 @@ _func_enter_;
 		struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
 		int bmcast = IS_MCAST(pattrib->dst);
 
-		//DBG_871X("bmcast=%d\n", bmcast);
-
 		if (_rtw_memcmp(pattrib->dst, myid(&padapter->eeprompriv), ETH_ALEN)==false)
 		{
-			//DBG_871X("not ap psta=%p, addr=%pM\n", psta, pattrib->dst);
-
 			if (bmcast)
 			{
 				psta = rtw_get_bcmc_stainfo(padapter);
@@ -295,13 +283,10 @@ _func_enter_;
 			{
 				struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;
 
-				//DBG_871X("directly forwarding to the rtw_xmit_entry\n");
-
-				//skb->ip_summed = CHECKSUM_NONE;
 				skb->dev = pnetdev;
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 				skb_set_queue_mapping(skb, rtw_recv_select_queue(skb));
-#endif //LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35)
+#endif /* LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35) */
 
 				rtw_xmit_entry(skb, pnetdev);
 
@@ -313,10 +298,6 @@ _func_enter_;
 
 
 		}
-		else// to APself
-		{
-			//DBG_871X("to APSelf\n");
-		}
 	}
 
 
@@ -324,13 +305,13 @@ _func_enter_;
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 	br_port = padapter->pnetdev->br_port;
-#else   // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+#else   /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 	rcu_read_lock();
 	br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
 	rcu_read_unlock();
-#endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+#endif  /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 
-#endif	// CONFIG_BR_EXT
+#endif	/*  CONFIG_BR_EXT */
 
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
 	if ((pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1)) {
@@ -351,7 +332,7 @@ _func_enter_;
 
 _recv_indicatepkt_end:
 
-	precv_frame->u.hdr.pkt = NULL; // pointers to NULL before rtw_free_recvframe()
+	precv_frame->u.hdr.pkt = NULL; /*  pointers to NULL before rtw_free_recvframe() */
 
 	rtw_free_recvframe(precv_frame, pfree_recv_queue);
 
@@ -363,7 +344,7 @@ _func_exit_;
 
 _recv_indicatepkt_drop:
 
-	 //enqueue back to free_recv_queue
+	 /* enqueue back to free_recv_queue */
 	 if (precv_frame)
 		 rtw_free_recvframe(precv_frame, pfree_recv_queue);
 
@@ -378,7 +359,7 @@ void rtw_os_read_port(struct rtw_adapter
 
 	precvbuf->ref_cnt--;
 
-	//free skb in recv_buf
+	/* free skb in recv_buf */
 	dev_kfree_skb_any(precvbuf->pskb);
 
 	precvbuf->pskb = NULL;
--- a/drivers/staging/rtl8192du/os_dep/rtw_android.c
+++ b/drivers/staging/rtl8192du/os_dep/rtw_android.c
@@ -288,7 +288,7 @@ static int rtw_android_get_p2p_dev_addr(
 	int ret;
 	int bytes_written = 0;
 
-	//We use the same address as our HW MAC address
+	/* We use the same address as our HW MAC address */
 	memcpy(command, net->dev_addr, ETH_ALEN);
 
 	bytes_written = ETH_ALEN;
@@ -316,7 +316,7 @@ static int get_int_from_command(char* pc
 	{
 		if (pcmd[i] == '=')
 		{
-			//	Skip the '=' and space characters.
+			/* 	Skip the '=' and space characters. */
 			i += 2;
 			break;
 		}
@@ -368,7 +368,6 @@ int rtw_android_priv_cmd(struct net_devi
 
 	switch (cmd_num) {
 	case ANDROID_WIFI_CMD_START:
-		//bytes_written = wl_android_wifi_on(net);
 		goto response;
 	case ANDROID_WIFI_CMD_SETFWPATH:
 		goto response;
@@ -455,14 +454,14 @@ int rtw_android_priv_cmd(struct net_devi
 		bytes_written = rtw_cfg80211_set_mgnt_wpsp2pie(net, command + skip, priv_cmd.total_len - skip, *(command + skip - 2) - '0');
 		break;
 	}
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 #ifdef CONFIG_WFD
 	case ANDROID_WIFI_CMD_WFD_ENABLE:
 	{
-		//	Commented by Albert 2012/07/24
-		//	We can enable the WFD function by using the following command:
-		//	wpa_cli driver wfd-enable
+		/* 	Commented by Albert 2012/07/24 */
+		/* 	We can enable the WFD function by using the following command: */
+		/* 	wpa_cli driver wfd-enable */
 
 		struct wifi_display_info		*pwfd_info;
 		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
@@ -473,9 +472,9 @@ int rtw_android_priv_cmd(struct net_devi
 	}
 	case ANDROID_WIFI_CMD_WFD_DISABLE:
 	{
-		//	Commented by Albert 2012/07/24
-		//	We can disable the WFD function by using the following command:
-		//	wpa_cli driver wfd-disable
+		/* 	Commented by Albert 2012/07/24 */
+		/* 	We can disable the WFD function by using the following command: */
+		/* 	wpa_cli driver wfd-disable */
 
 		struct wifi_display_info		*pwfd_info;
 		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
@@ -486,9 +485,9 @@ int rtw_android_priv_cmd(struct net_devi
 	}
 	case ANDROID_WIFI_CMD_WFD_SET_TCPPORT:
 	{
-		//	Commented by Albert 2012/07/24
-		//	We can set the tcp port number by using the following command:
-		//	wpa_cli driver wfd-set-tcpport = 554
+		/* 	Commented by Albert 2012/07/24 */
+		/* 	We can set the tcp port number by using the following command: */
+		/* 	wpa_cli driver wfd-set-tcpport = 554 */
 
 		struct wifi_display_info		*pwfd_info;
 		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
@@ -501,8 +500,8 @@ int rtw_android_priv_cmd(struct net_devi
 		break;
 	case ANDROID_WIFI_CMD_WFD_SET_DEVTYPE:
 	{
-		//	Commented by Albert 2012/08/28
-		//	Specify the WFD device type (WFD source/primary sink)
+		/* 	Commented by Albert 2012/08/28 */
+		/* 	Specify the WFD device type (WFD source/primary sink) */
 
 		struct wifi_display_info		*pwfd_info;
 		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
--- a/drivers/staging/rtl8192du/os_dep/usb_intf.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_intf.c
@@ -33,7 +33,7 @@
 #ifdef CONFIG_80211N_HT
 extern int rtw_ht_enable;
 extern int rtw_cbw40_enable;
-extern int rtw_ampdu_enable;//for enable tx_ampdu
+extern int rtw_ampdu_enable;/* for enable tx_ampdu */
 #endif
 
 extern int pm_netdev_open(struct net_device *pnetdev,u8 bnormal);
@@ -180,11 +180,11 @@ MODULE_DEVICE_TABLE(usb, rtw_usb_id_tbl)
 int const rtw_usb_id_len = sizeof(rtw_usb_id_tbl) / sizeof(struct usb_device_id);
 
 static struct specific_device_id specific_device_id_tbl[] = {
-	{.idVendor=USB_VENDER_ID_REALTEK, .idProduct=0x8177, .flags=SPEC_DEV_ID_DISABLE_HT},//8188cu 1*1 dongole, (b/g mode only)
-	{.idVendor=USB_VENDER_ID_REALTEK, .idProduct=0x817E, .flags=SPEC_DEV_ID_DISABLE_HT},//8188CE-VAU USB minCard (b/g mode only)
+	{.idVendor=USB_VENDER_ID_REALTEK, .idProduct=0x8177, .flags=SPEC_DEV_ID_DISABLE_HT},/* 8188cu 1*1 dongole, (b/g mode only) */
+	{.idVendor=USB_VENDER_ID_REALTEK, .idProduct=0x817E, .flags=SPEC_DEV_ID_DISABLE_HT},/* 8188CE-VAU USB minCard (b/g mode only) */
 	{.idVendor=0x0b05, .idProduct=0x1791, .flags=SPEC_DEV_ID_DISABLE_HT},
 	{.idVendor=0x13D3, .idProduct=0x3311, .flags=SPEC_DEV_ID_DISABLE_HT},
-	{.idVendor=0x13D3, .idProduct=0x3359, .flags=SPEC_DEV_ID_DISABLE_HT},//Russian customer -Azwave (8188CE-VAU  g mode)
+	{.idVendor=0x13D3, .idProduct=0x3359, .flags=SPEC_DEV_ID_DISABLE_HT},/* Russian customer -Azwave (8188CE-VAU  g mode) */
 	{}
 };
 
@@ -380,7 +380,7 @@ _func_enter_;
 		goto free_dvobj;
 	}
 
-	//.3 misc
+	/* 3 misc */
 	_rtw_init_sema(&(pdvobjpriv->usb_suspend_sema), 0);
 
 	rtw_reset_continual_urb_error(pdvobjpriv);
@@ -412,16 +412,7 @@ _func_enter_;
 
 	usb_set_intfdata(usb_intf, NULL);
 	if (dvobj) {
-		//Modify condition for 92DU DMDP 2010.11.18, by Thomas
-		/*if ((dvobj->NumInterfaces == 1)
-			|| ((dvobj->InterfaceNumber == 1) && (dvobj->DualMacMode == true))) {
-			if (interface_to_usbdev(usb_intf)->state != USB_STATE_NOTATTACHED) {
-				//If we didn't unplug usb dongle and remove/insert modlue, driver fails on sitesurvey for the first time when device is up .
-				//Reset usb port for sitesurvey fail issue. 2009.8.13, by Thomas
-				DBG_8192D("usb attached..., try to reset usb device\n");
-				usb_reset_device(interface_to_usbdev(usb_intf));
-			}
-		}*/
+		/* Modify condition for 92DU DMDP 2010.11.18, by Thomas */
 		rtw_deinit_intf_priv(dvobj);
 		_rtw_mutex_free(&dvobj->hw_init_mutex);
 		_rtw_mutex_free(&dvobj->h2c_fwcmd_mutex);
@@ -430,7 +421,6 @@ _func_enter_;
 		kfree(dvobj);
 	}
 
-	//DBG_8192D("%s %d\n", __func__, ATOMIC_READ(&usb_intf->dev.kobj.kref.refcount));
 	usb_put_dev(interface_to_usbdev(usb_intf));
 
 _func_exit_;
@@ -456,21 +446,21 @@ static void usb_intf_stop(struct rtw_ada
 
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+usb_intf_stop\n"));
 
-	//disabel_hw_interrupt
+	/* disabel_hw_interrupt */
 	if (padapter->bSurpriseRemoved == false)
 	{
-		//device still exists, so driver can do i/o operation
-		//TODO:
+		/* device still exists, so driver can do i/o operation */
+		/* TODO: */
 		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("SurpriseRemoved==false\n"));
 	}
 
-	//cancel in irp
+	/* cancel in irp */
 	rtw_hal_inirp_deinit(padapter);
 
-	//cancel out irp
+	/* cancel out irp */
 	rtw_write_port_cancel(padapter);
 
-	//todo:cancel other irps
+	/* todo:cancel other irps */
 
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-usb_intf_stop\n"));
 }
@@ -491,27 +481,26 @@ static void rtw_dev_unload(struct rtw_ad
 			rtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_DRV_STOP);
 		#endif
 
-		//s3.
+		/* s3. */
 		if (padapter->intf_stop)
 		{
 			padapter->intf_stop(padapter);
 		}
 
-		//s4.
+		/* s4. */
 		if (!padapter->pwrctrlpriv.bInternalAutoSuspend)
 		rtw_stop_drv_threads(padapter);
 
 
-		//s5.
+		/* s5. */
 		if (padapter->bSurpriseRemoved == false)
 		{
-			//DBG_8192D("r871x_dev_unload()->rtl871x_hal_deinit()\n");
 #ifdef CONFIG_WOWLAN
 			if ((padapter->pwrctrlpriv.bSupportRemoteWakeup==true)&&(padapter->pwrctrlpriv.wowlan_mode==true)) {
 				DBG_8192D("%s bSupportWakeOnWlan==true  do not run rtw_hal_deinit()\n",__func__);
 			}
 			else
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 			{
 				rtw_hal_deinit(padapter);
 			}
@@ -521,7 +510,7 @@ static void rtw_dev_unload(struct rtw_ad
 		padapter->bup = false;
 #ifdef CONFIG_WOWLAN
 		padapter->hw_init_completed=false;
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 	}
 	else
 	{
@@ -574,26 +563,24 @@ int rtw_hw_suspend(struct rtw_adapter *p
 		goto error_exit;
 	}
 
-	if (padapter)//system suspend
+	if (padapter)/* system suspend */
 	{
 		LeaveAllPowerSaveMode(padapter);
 
 		DBG_8192D("==> rtw_hw_suspend\n");
 		_enter_pwrlock(&pwrpriv->lock);
 		pwrpriv->bips_processing = true;
-		//padapter->net_closed = true;
-		//s1.
+		/* s1. */
 		if (pnetdev)
 		{
 			netif_carrier_off(pnetdev);
 			rtw_netif_stop_queue(pnetdev);
 		}
 
-		//s2.
+		/* s2. */
 		rtw_disassoc_cmd(padapter, 500, false);
 
-		//s2-2.  indicate disconnect to os
-		//rtw_indicate_disconnect(padapter);
+		/* s2-2.  indicate disconnect to os */
 		{
 			struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
@@ -606,16 +593,16 @@ int rtw_hw_suspend(struct rtw_adapter *p
 				rtw_os_indicate_disconnect(padapter);
 
 				#ifdef CONFIG_LPS
-				//donnot enqueue cmd
+				/* donnot enqueue cmd */
 				rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_DISCONNECT, 0);
 				#endif
 			}
 
 		}
-		//s2-3.
+		/* s2-3. */
 		rtw_free_assoc_resources(padapter, 1);
 
-		//s2-4.
+		/* s2-4. */
 		rtw_free_network_queue(padapter,true);
 		#ifdef CONFIG_IPS
 		rtw_ips_dev_unload(padapter);
@@ -644,7 +631,7 @@ int rtw_hw_resume(struct rtw_adapter *pa
 
 	_func_enter_;
 
-	if (padapter)//system resume
+	if (padapter)/* system resume */
 	{
 		DBG_8192D("==> rtw_hw_resume\n");
 		_enter_pwrlock(&pwrpriv->lock);
@@ -697,7 +684,7 @@ static int rtw_suspend(struct usb_interf
 	struct usb_device *usb_dev = interface_to_usbdev(pusb_intf);
 #ifdef CONFIG_WOWLAN
 	struct wowlan_ioctl_param poidparam;
-#endif // CONFIG_WOWLAN
+#endif /*  CONFIG_WOWLAN */
 	int ret = 0;
 	u32 start_time = rtw_get_current_time();
 	_func_enter_;
@@ -715,12 +702,11 @@ static int rtw_suspend(struct usb_interf
 	{
 	#ifdef CONFIG_AUTOSUSPEND
 	#ifdef SUPPORT_HW_RFOFF_DETECTED
-		// The FW command register update must after MAC and FW init ready.
+		/*  The FW command register update must after MAC and FW init ready. */
 		if ((padapter->bFWReady) && (padapter->pwrctrlpriv.bHWPwrPindetect) && (padapter->registrypriv.usbss_enable))
 		{
 			u8 bOpen = true;
 			rtw_interface_ps_func(padapter,HAL_USB_SELECT_SUSPEND,&bOpen);
-			//rtl8192c_set_FwSelectSuspend_cmd(padapter,true ,500);//note fw to support hw power down ping detect
 		}
 	#endif
 	#endif
@@ -730,8 +716,7 @@ static int rtw_suspend(struct usb_interf
 	LeaveAllPowerSaveMode(padapter);
 
 	_enter_pwrlock(&pwrpriv->lock);
-	//padapter->net_closed = true;
-	//s1.
+	/* s1. */
 	if (pnetdev)
 	{
 		netif_carrier_off(pnetdev);
@@ -740,23 +725,20 @@ static int rtw_suspend(struct usb_interf
 #ifdef CONFIG_WOWLAN
 	if (padapter->pwrctrlpriv.bSupportRemoteWakeup==true&&padapter->pwrctrlpriv.wowlan_mode==true) {
 		u8 ps_mode=PS_MODE_MIN;
-		//set H2C command
+		/* set H2C command */
 		poidparam.subcode=WOWLAN_ENABLE;
 		rtw_hal_set_hwreg(padapter,HW_VAR_WOWLAN,(u8 *)&poidparam);
-		//rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, &ps_mode);
-		//rtw_set_rpwm(padapter, PS_STATE_S2);
 	}
 	else
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 	{
-		//s2.
+		/* s2. */
 		rtw_disassoc_cmd(padapter, 0, false);
 	}
 
 #ifdef CONFIG_LAYER2_ROAMING_RESUME
 	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) && check_fwstate(pmlmepriv, _FW_LINKED))
 	{
-		//DBG_8192D("%s:%d assoc_ssid:%s\n", __func__, __LINE__, pmlmepriv->assoc_ssid.Ssid);
 		DBG_8192D("%s:%d %s(%pM), length:%d assoc_ssid.length:%d\n",__func__, __LINE__,
 				pmlmepriv->cur_network.network.Ssid.Ssid,
 				pmlmepriv->cur_network.network.MacAddress,
@@ -765,14 +747,14 @@ static int rtw_suspend(struct usb_interf
 		rtw_set_roaming(padapter, 1);
 		}
 #endif
-	//s2-2.  indicate disconnect to os
+	/* s2-2.  indicate disconnect to os */
 	rtw_indicate_disconnect(padapter);
-	//s2-3.
+	/* s2-3. */
 	rtw_free_assoc_resources(padapter, 1);
 #ifdef CONFIG_AUTOSUSPEND
 	if (!pwrpriv->bInternalAutoSuspend)
 #endif
-	//s2-4.
+	/* s2-4. */
 	rtw_free_network_queue(padapter, true);
 
 	rtw_dev_unload(padapter);
@@ -859,10 +841,9 @@ int rtw_resume_process(struct rtw_adapte
 	{
 		#ifdef CONFIG_AUTOSUSPEND
 		#ifdef SUPPORT_HW_RFOFF_DETECTED
-			// The FW command register update must after MAC and FW init ready.
+			/*  The FW command register update must after MAC and FW init ready. */
 		if ((padapter->bFWReady) && (padapter->pwrctrlpriv.bHWPwrPindetect) && (padapter->registrypriv.usbss_enable))
 		{
-			//rtl8192c_set_FwSelectSuspend_cmd(padapter,false ,500);//note fw to support hw power down ping detect
 			u8 bOpen = false;
 			rtw_interface_ps_func(padapter,HAL_USB_SELECT_SUSPEND,&bOpen);
 		}
@@ -906,7 +887,7 @@ int rtw_resume_process(struct rtw_adapte
 exit:
 	#ifdef CONFIG_RESUME_IN_WORKQUEUE
 	rtw_unlock_suspend();
-	#endif //CONFIG_RESUME_IN_WORKQUEUE
+	#endif /* CONFIG_RESUME_IN_WORKQUEUE */
 
 	pwrpriv->bInSuspend = false;
 	DBG_8192D("<===  %s return %d.............. in %dms\n", __func__
@@ -933,7 +914,7 @@ void autosuspend_enter(struct rtw_adapte
 		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 		usb_enable_autosuspend(dvobj->pusbdev);
 		#else
-		dvobj->pusbdev->autosuspend_disabled = 0;//autosuspend disabled by the user
+		dvobj->pusbdev->autosuspend_disabled = 0;/* autosuspend disabled by the user */
 		#endif
 
 		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,33))
@@ -1008,7 +989,7 @@ struct rtw_adapter *rtw_usb_if1_init(str
 	padapter->bDriverStopped=true;
 
 #if defined(CONFIG_CONCURRENT_MODE) || defined(CONFIG_DUALMAC_CONCURRENT)
-	//set adapter_type/iface type for primary padapter
+	/* set adapter_type/iface type for primary padapter */
 	padapter->isprimary = true;
 	padapter->adapter_type = PRIMARY_ADAPTER;
 	padapter->iface_id = IFACE_ID0;
@@ -1021,7 +1002,7 @@ struct rtw_adapter *rtw_usb_if1_init(str
 #endif
 
 	#ifndef RTW_DVOBJ_CHIP_HW_TYPE
-	//step 1-1., decide the chip_type via vid/pid
+	/* step 1-1., decide the chip_type via vid/pid */
 	padapter->interface_type = RTW_USB;
 	decide_chip_type_by_usb_device_id(padapter, pdid);
 	#endif
@@ -1041,7 +1022,7 @@ struct rtw_adapter *rtw_usb_if1_init(str
 	}
 #endif
 
-	//step 2. hook HalFunc, allocate HalData
+	/* step 2. hook HalFunc, allocate HalData */
 	if (padapter->chip_type == RTL8192D) {
 		rtl8192du_set_hal_ops(padapter);
 	} else {
@@ -1049,11 +1030,11 @@ struct rtw_adapter *rtw_usb_if1_init(str
 		goto free_wdev;
 	}
 
-	//step 3.
+	/* step 3. */
 	padapter->intf_start=&usb_intf_start;
 	padapter->intf_stop=&usb_intf_stop;
 
-	//.2
+	/* 2 */
 	if ((rtw_init_io_priv(padapter, usb_set_intf_ops)) == _FAIL) {
 		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("\n Can't init io_reqs\n"));
 		goto free_hal_data;
@@ -1061,13 +1042,13 @@ struct rtw_adapter *rtw_usb_if1_init(str
 
 	rtw_hal_read_chip_version(padapter);
 
-	//.4 usb endpoint mapping
+	/* 4 usb endpoint mapping */
 	rtw_hal_chip_configure(padapter);
 
-	//step 4. read efuse/eeprom data and get mac_addr
+	/* step 4. read efuse/eeprom data and get mac_addr */
 	rtw_hal_read_chip_info(padapter);
 
-	//step 5.
+	/* step 5. */
 	if (rtw_init_drv_sw(padapter) == _FAIL) {
 		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Initialize driver software resource Failed!\n"));
 		goto free_hal_data;
@@ -1091,19 +1072,19 @@ struct rtw_adapter *rtw_usb_if1_init(str
 	{
 		if (padapter->registrypriv.usbss_enable) {	/* autosuspend (2s delay) */
 			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,38))
-			dvobj->pusbdev->dev.power.autosuspend_delay = 0 * HZ;//15 * HZ; idle-delay time
+			dvobj->pusbdev->dev.power.autosuspend_delay = 0 * HZ;/* 15 * HZ; idle-delay time */
 			#else
-			dvobj->pusbdev->autosuspend_delay = 0 * HZ;//15 * HZ; idle-delay time
+			dvobj->pusbdev->autosuspend_delay = 0 * HZ;/* 15 * HZ; idle-delay time */
 			#endif
 
 			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 			usb_enable_autosuspend(dvobj->pusbdev);
 			#elif  (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,34))
 			padapter->bDisableAutosuspend = dvobj->pusbdev->autosuspend_disabled ;
-			dvobj->pusbdev->autosuspend_disabled = 0;//autosuspend disabled by the user
+			dvobj->pusbdev->autosuspend_disabled = 0;/* autosuspend disabled by the user */
 			#endif
 
-			usb_autopm_get_interface(dvobj->pusbintf);//init pm_usage_cnt ,let it start from 1
+			usb_autopm_get_interface(dvobj->pusbintf);/* init pm_usage_cnt ,let it start from 1 */
 
 			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,32))
 			DBG_8192D("%s...pm_usage_cnt(%d).....\n",__func__, atomic_read(&(dvobj->pusbintf ->pm_usage_cnt)));
@@ -1114,7 +1095,7 @@ struct rtw_adapter *rtw_usb_if1_init(str
 	}
 #endif
 
-	// alloc dev name after read efuse.
+	/*  alloc dev name after read efuse. */
 	rtw_init_netdev_name(pnetdev, padapter->registrypriv.ifname);
 	rtw_macaddr_cfg(padapter->eeprompriv.mac_addr);
 	rtw_init_wifidirect_addrs(padapter, padapter->eeprompriv.mac_addr, padapter->eeprompriv.mac_addr);
@@ -1185,7 +1166,7 @@ static void rtw_usb_if1_deinit(struct rt
 	if (if1->DriverState != DRIVER_DISAPPEAR)
 	{
 		if (pnetdev) {
-			unregister_netdev(pnetdev); //will call netdev_close()
+			unregister_netdev(pnetdev); /* will call netdev_close() */
 			rtw_proc_remove_one(pnetdev);
 		}
 	}
@@ -1193,18 +1174,18 @@ static void rtw_usb_if1_deinit(struct rt
 	rtw_cancel_all_timer(if1);
 #ifdef CONFIG_WOWLAN
 	if1->pwrctrlpriv.wowlan_mode=false;
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 	rtw_dev_unload(if1);
 
 	DBG_8192D("%s, hw_init_completed=%d\n", __func__, if1->hw_init_completed);
 
-	//s6.
+	/* s6. */
 	rtw_handle_dualmac(if1, 0);
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_wdev_unregister(if1->rtw_wdev);
 	rtw_wdev_free(if1->rtw_wdev);
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 	rtw_free_drv_sw(if1);
 
@@ -1228,12 +1209,12 @@ static int rtw_drv_init(struct usb_inter
 	struct dvobj_priv *dvobj = NULL;
 #ifdef CONFIG_MULTI_VIR_IFACES
 	int i;
-#endif //CONFIG_MULTI_VIR_IFACES
+#endif /* CONFIG_MULTI_VIR_IFACES */
 
 	RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("+rtw_drv_init\n"));
 
 
-	//step 0.
+	/* step 0. */
 	process_spec_devid(did);
 
 	/* Initialize dvobj_priv */
@@ -1262,7 +1243,7 @@ static int rtw_drv_init(struct usb_inter
 			break;
 		}
 	}
-#endif //CONFIG_MULTI_VIR_IFACES
+#endif /* CONFIG_MULTI_VIR_IFACES */
 #endif
 
 	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-871x_drv - drv_init, success!\n"));
@@ -1283,7 +1264,7 @@ exit:
 /*
  * dev_remove() - our device is being removed
 */
-//rmmod module & unplug(SurpriseRemoved) will call r871xu_dev_remove() => how to recognize both
+/* rmmod module & unplug(SurpriseRemoved) will call r871xu_dev_remove() => how to recognize both */
 static void rtw_dev_remove(struct usb_interface *pusb_intf)
 {
 	struct dvobj_priv *dvobj = usb_get_intfdata(pusb_intf);
@@ -1296,14 +1277,8 @@ _func_exit_;
 
 	if (usb_drv->drv_registered == true)
 	{
-		//DBG_8192D("r871xu_dev_remove():padapter->bSurpriseRemoved == true\n");
 		padapter->bSurpriseRemoved = true;
 	}
-	/*else
-	{
-		//DBG_8192D("r871xu_dev_remove():module removed\n");
-		padapter->hw_init_completed = false;
-	}*/
 
 #if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
 	rtw_unregister_early_suspend(&padapter->pwrctrlpriv);
@@ -1317,18 +1292,18 @@ _func_exit_;
 #ifdef CONFIG_CONCURRENT_MODE
 #ifdef CONFIG_MULTI_VIR_IFACES
 	rtw_drv_stop_vir_ifaces(dvobj);
-#endif //CONFIG_MULTI_VIR_IFACES
+#endif /* CONFIG_MULTI_VIR_IFACES */
 	rtw_drv_if2_stop(dvobj->if2);
-#endif	//CONFIG_CONCURRENT_MODE
+#endif	/* CONFIG_CONCURRENT_MODE */
 
 	rtw_usb_if1_deinit(padapter);
 
 #ifdef CONFIG_CONCURRENT_MODE
 #ifdef CONFIG_MULTI_VIR_IFACES
 	rtw_drv_free_vir_ifaces(dvobj);
-#endif //CONFIG_MULTI_VIR_IFACES
+#endif /* CONFIG_MULTI_VIR_IFACES */
 	rtw_drv_if2_free(dvobj->if2);
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 	usb_dvobj_deinit(pusb_intf);
 
@@ -1390,11 +1365,11 @@ int rtw_suspend_toshiba(struct rtw_adapt
 	struct dvobj_priv *pdvobjpriv;
 	pdvobjpriv = adapter_to_dvobj(Adapter);
 	msg.event=0;
-	//for Toshiba only, they should call rtw_suspend before suspend
+	/* for Toshiba only, they should call rtw_suspend before suspend */
 	rtw_suspend(pdvobjpriv->pusbintf, msg);
 	return 0;
 }
 EXPORT_SYMBOL(rtw_suspend_toshiba);
 EXPORT_SYMBOL(rtw_resume_toshiba);
-#endif //CONFIG_WOWLAN_MANUAL
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN_MANUAL */
+#endif /* CONFIG_WOWLAN */
--- a/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/usb_ops_linux.c
@@ -48,11 +48,11 @@ static int _usbctrl_vendorreq_async_writ
 
 
 	if (requesttype == VENDOR_READ) {
-		pipe = usb_rcvctrlpipe(udev, 0);//read_in
+		pipe = usb_rcvctrlpipe(udev, 0);/* read_in */
 		reqtype =  REALTEK_USB_VENQT_READ;
 	}
 	else {
-		pipe = usb_sndctrlpipe(udev, 0);//write_out
+		pipe = usb_sndctrlpipe(udev, 0);/* write_out */
 		reqtype =  REALTEK_USB_VENQT_WRITE;
 	}
 
@@ -101,9 +101,9 @@ int usb_write_async(struct usb_device *u
 
 	int ret;
 
-	requesttype = VENDOR_WRITE;//write_out
+	requesttype = VENDOR_WRITE;/* write_out */
 	request = REALTEK_USB_VENQT_CMD_REQ;
-	index = REALTEK_USB_VENQT_CMD_IDX;//n/a
+	index = REALTEK_USB_VENQT_CMD_IDX;/* n/a */
 
 	wvalue = (u16)(addr&0x0000ffff);
 
@@ -191,8 +191,6 @@ static void usb_bulkout_zero_complete(st
 {
 	struct zero_bulkout_context *pcontext = (struct zero_bulkout_context *)purb->context;
 
-	//DBG_8192D("+usb_bulkout_zero_complete\n");
-
 	if (pcontext) {
 		kfree(pcontext->pbuf);
 
@@ -214,7 +212,6 @@ static u32 usb_bulkout_zero(struct intf_
 	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
 	struct usb_device *pusbd = pdvobj->pusbdev;
 
-	//DBG_8192D("%s\n", __func__);
 
 
 	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
@@ -235,14 +232,13 @@ static u32 usb_bulkout_zero(struct intf_
 	pcontext->padapter = padapter;
 
 
-	//translate DMA FIFO addr to pipehandle
-	//pipe = ffaddr2pipehdl(pdvobj, addr);
+	/* translate DMA FIFO addr to pipehandle */
 
 	usb_fill_bulk_urb(purb, pusbd, pipe,
 				pbuf,
 				len,
 				usb_bulkout_zero_complete,
-				pcontext);//context is pcontext
+				pcontext);/* context is pcontext */
 
 	status = usb_submit_urb(purb, GFP_ATOMIC);
 
@@ -283,7 +279,6 @@ void usb_read_port_cancel(struct intf_hd
 
 		precvbuf->reuse = true;
 		if (precvbuf->purb)	 {
-			//DBG_8192D("usb_read_port_cancel : usb_kill_urb\n");
 			usb_kill_urb(precvbuf->purb);
 		}
 		precvbuf++;
@@ -299,11 +294,8 @@ static void usb_write_port_complete(stru
 	long unsigned int irqL;
 	int i;
 	struct xmit_buf *pxmitbuf = (struct xmit_buf *)purb->context;
-	//struct xmit_frame *pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
-	//_adapter			*padapter = pxmitframe->padapter;
 	struct rtw_adapter	*padapter = pxmitbuf->padapter;
        struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
-	//struct pkt_attrib *pattrib = &pxmitframe->attrib;
 
 _func_enter_;
 
@@ -330,49 +322,6 @@ _func_enter_;
 			break;
 	}
 
-
-/*
-	spin_lock_irqsave(&pxmitpriv->lock, irqL);
-
-	pxmitpriv->txirp_cnt--;
-
-	switch (pattrib->priority)
-	{
-		case 1:
-		case 2:
-			pxmitpriv->bkq_cnt--;
-			//DBG_8192D("pxmitpriv->bkq_cnt=%d\n", pxmitpriv->bkq_cnt);
-			break;
-		case 4:
-		case 5:
-			pxmitpriv->viq_cnt--;
-			//DBG_8192D("pxmitpriv->viq_cnt=%d\n", pxmitpriv->viq_cnt);
-			break;
-		case 6:
-		case 7:
-			pxmitpriv->voq_cnt--;
-			//DBG_8192D("pxmitpriv->voq_cnt=%d\n", pxmitpriv->voq_cnt);
-			break;
-		case 0:
-		case 3:
-		default:
-			pxmitpriv->beq_cnt--;
-			//DBG_8192D("pxmitpriv->beq_cnt=%d\n", pxmitpriv->beq_cnt);
-			break;
-
-	}
-
-	spin_unlock_irqrestore(&pxmitpriv->lock, irqL);
-
-
-	if (pxmitpriv->txirp_cnt==0)
-	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));
-		_rtw_up_sema(&(pxmitpriv->tx_retevt));
-	}
-*/
-        //rtw_free_xmitframe(pxmitpriv, pxmitframe);
-
 	if (padapter->bSurpriseRemoved || padapter->bDriverStopped ||padapter->bWritePortCancel)
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
@@ -390,8 +339,6 @@ _func_enter_;
 		DBG_8192D("###=> urb_write_port_complete status(%d)\n",purb->status);
 		if ((purb->status==-EPIPE)||(purb->status==-EPROTO))
 		{
-			//usb_clear_halt(pusbdev, purb->pipe);
-			//msleep(10);
 			sreset_set_wifi_error_status(padapter, USB_WRITE_PORT_FAIL);
 		} else if (purb->status == -EINPROGRESS) {
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: EINPROGESS\n"));
@@ -416,7 +363,6 @@ _func_enter_;
 		{
 			padapter->bSurpriseRemoved=true;
 			DBG_8192D("bSurpriseRemoved=TRUE\n");
-			//rtl8192cu_trigger_gpio_0(padapter);
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bSurpriseRemoved=TRUE\n"));
 
 			goto check_completion;
@@ -436,7 +382,6 @@ check_completion:
 
 	rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
 
-	//if (rtw_txframes_pending(padapter))
 	{
 		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
 	}
@@ -505,7 +450,7 @@ _func_enter_;
 
 	purb	= pxmitbuf->pxmit_urb[0];
 
-	//translate DMA FIFO addr to pipehandle
+	/* translate DMA FIFO addr to pipehandle */
 	pipe = ffaddr2pipehdl(pdvobj, addr);
 
 #ifdef CONFIG_REDUCE_USB_TX_INT
@@ -518,16 +463,16 @@ _func_enter_;
 
 
 	usb_fill_bulk_urb(purb, pusbd, pipe,
-				pxmitframe->buf_addr, //= pxmitbuf->pbuf
+				pxmitframe->buf_addr, /*  pxmitbuf->pbuf */
 				cnt,
 				usb_write_port_complete,
-				pxmitbuf);//context is pxmitbuf
+				pxmitbuf);/* context is pxmitbuf */
 
 #ifdef CONFIG_USE_USB_BUFFER_ALLOC_TX
 	purb->transfer_dma = pxmitbuf->dma_transfer_addr;
 	purb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 	purb->transfer_flags |= URB_ZERO_PACKET;
-#endif	// CONFIG_USE_USB_BUFFER_ALLOC_TX
+#endif	/*  CONFIG_USE_USB_BUFFER_ALLOC_TX */
 
 	status = usb_submit_urb(purb, GFP_ATOMIC);
 	if (!status) {
@@ -551,18 +496,7 @@ _func_enter_;
 		}
 		goto exit;
 	}
-
 	ret= _SUCCESS;
-
-//   Commented by Albert 2009/10/13
-//   We add the URB_ZERO_PACKET flag to urb so that the host will send the zero packet automatically.
-/*
-	if (bwritezero == true)
-	{
-		usb_bulkout_zero(pintfhdl, addr);
-	}
-*/
-
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("-usb_write_port\n"));
 
 exit:
--- a/drivers/staging/rtl8192du/os_dep/xmit_linux.c
+++ b/drivers/staging/rtl8192du/os_dep/xmit_linux.c
@@ -96,18 +96,17 @@ void rtw_set_tx_chksum_offload(struct sk
 		{
                         const struct iphdr *ip = ip_hdr(skb);
                         if (ip->protocol == IPPROTO_TCP) {
-                                // TCP checksum offload by HW
+                                /*  TCP checksum offload by HW */
                                 DBG_8192D("CHECKSUM_PARTIAL TCP\n");
                                 pattrib->hw_tcp_csum = 1;
-                                //skb_checksum_help(skb);
+                                /* skb_checksum_help(skb); */
                         } else if (ip->protocol == IPPROTO_UDP) {
-                                //DBG_8192D("CHECKSUM_PARTIAL UDP\n");
                                 skb_checksum_help(skb);
                         } else {
 				DBG_8192D("%s-%d TCP CSUM offload Error!!\n", __func__, __LINE__);
                                 WARN_ON(1);     /* we need a WARN() */
 			    }
-		} else { // IP fragmentation case
+		} else { /*  IP fragmentation case */
 			DBG_8192D("%s-%d nr_frags != 0, using skb_checksum_help(skb);!!\n", __func__, __LINE__);
 			skb_checksum_help(skb);
 		}
@@ -126,7 +125,7 @@ int rtw_os_xmit_resource_alloc(struct rt
 	pxmitbuf->pbuf = pxmitbuf->pallocated_buf;
 	if (pxmitbuf->pallocated_buf == NULL)
 		return _FAIL;
-#else // CONFIG_USE_USB_BUFFER_ALLOC_TX
+#else /*  CONFIG_USE_USB_BUFFER_ALLOC_TX */
 
 	pxmitbuf->pallocated_buf = rtw_zmalloc(alloc_sz);
 	if (pxmitbuf->pallocated_buf == NULL)
@@ -137,7 +136,7 @@ int rtw_os_xmit_resource_alloc(struct rt
 	pxmitbuf->pbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitbuf->pallocated_buf), XMITBUF_ALIGN_SZ);
 	pxmitbuf->dma_transfer_addr = 0;
 
-#endif // CONFIG_USE_USB_BUFFER_ALLOC_TX
+#endif /*  CONFIG_USE_USB_BUFFER_ALLOC_TX */
 
 	for (i=0; i<8; i++)
 	{
@@ -163,7 +162,6 @@ void rtw_os_xmit_resource_free(struct rt
 	{
 		if (pxmitbuf->pxmit_urb[i])
 		{
-			//usb_kill_urb(pxmitbuf->pxmit_urb[i]);
 			usb_free_urb(pxmitbuf->pxmit_urb[i]);
 		}
 	}
@@ -172,9 +170,9 @@ void rtw_os_xmit_resource_free(struct rt
 	rtw_usb_buffer_free(pusbd, (size_t)free_sz, pxmitbuf->pallocated_buf, pxmitbuf->dma_transfer_addr);
 	pxmitbuf->pallocated_buf =  NULL;
 	pxmitbuf->dma_transfer_addr = 0;
-#else	// CONFIG_USE_USB_BUFFER_ALLOC_TX
+#else	/*  CONFIG_USE_USB_BUFFER_ALLOC_TX */
 	kfree(pxmitbuf->pallocated_buf);
-#endif	// CONFIG_USE_USB_BUFFER_ALLOC_TX
+#endif	/*  CONFIG_USE_USB_BUFFER_ALLOC_TX */
 }
 
 void rtw_os_pkt_complete(struct rtw_adapter *padapter, struct sk_buff *pkt)
@@ -201,9 +199,7 @@ void rtw_os_xmit_complete(struct rtw_ada
 {
 	if (pxframe->pkt)
 	{
-		//RT_TRACE(_module_xmit_osdep_c_,_drv_err_,("linux : rtw_os_xmit_complete, dev_kfree_skb()\n"));
 
-		//dev_kfree_skb_any(pxframe->pkt);
 		rtw_os_pkt_complete(padapter, pxframe->pkt);
 
 	}
@@ -245,7 +241,7 @@ int rtw_mlcst2unicst(struct rtw_adapter
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
-	//free sta asoc_queue
+	/* free sta asoc_queue */
 	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
@@ -272,8 +268,7 @@ int rtw_mlcst2unicst(struct rtw_adapter
 			pxmitpriv->tx_drop++;
 
 			spin_unlock_bh(&pstapriv->asoc_list_lock);
-			//dev_kfree_skb_any(skb);
-			return false;	// Caller shall tx this multicast frame via normal way.
+			return false;	/*  Caller shall tx this multicast frame via normal way. */
 		}
 	}
 
@@ -309,7 +304,6 @@ _func_enter_;
 	queue = skb_get_queue_mapping(pkt);
 	/* No free space for Tx, tx_worker is too slow */
 	if (pxmitpriv->hwxmits[queue].accnt > NR_XMITFRAME/2) {
-		//DBG_8192D("%s(): stop netif_subqueue[%d]\n", __func__, queue);
 		netif_stop_subqueue(padapter->pnetdev, queue);
 		return NETDEV_TX_BUSY;
 	}
@@ -327,9 +321,6 @@ _func_enter_;
 			if (res == true) {
 				goto exit;
 			}
-		} else {
-			//DBG_8192D("Stop M2U(%d, %d)! ", pxmitpriv->free_xmitframe_cnt, pxmitpriv->free_xmitbuf_cnt);
-			//DBG_8192D("!m2u);
 		}
 	}
 
